#
include
<
Cocoa
/
Cocoa
.
h
>
#
include
<
CoreServices
/
CoreServices
.
h
>
#
include
<
crt_externs
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
<
spawn
.
h
>
#
include
<
SystemConfiguration
/
SystemConfiguration
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
include
"
readstrings
.
h
"
#
define
ARCH_PATH
"
/
usr
/
bin
/
arch
"
#
if
defined
(
__x86_64__
)
#
define
kCFBundleExecutableArchitectureARM64
0x0100000c
#
endif
class
MacAutoreleasePool
{
public
:
MacAutoreleasePool
(
)
{
mPool
=
[
[
NSAutoreleasePool
alloc
]
init
]
;
}
~
MacAutoreleasePool
(
)
{
[
mPool
release
]
;
}
private
:
NSAutoreleasePool
*
mPool
;
}
;
static
void
LaunchTask
(
NSString
*
aPath
NSArray
*
aArguments
)
{
MacAutoreleasePool
pool
;
NSTask
*
task
=
[
[
NSTask
alloc
]
init
]
;
[
task
setExecutableURL
:
[
NSURL
fileURLWithPath
:
aPath
]
]
;
if
(
aArguments
)
{
[
task
setArguments
:
aArguments
]
;
}
[
task
launchAndReturnError
:
nil
]
;
[
task
waitUntilExit
]
;
[
task
release
]
;
}
static
void
RegisterAppWithLaunchServices
(
NSString
*
aBundlePath
)
{
MacAutoreleasePool
pool
;
try
{
OSStatus
status
=
LSRegisterURL
(
(
CFURLRef
)
[
NSURL
fileURLWithPath
:
aBundlePath
]
YES
)
;
if
(
status
!
=
noErr
)
{
NSLog
(
"
We
failed
to
register
the
app
in
the
Launch
Services
database
"
"
which
may
lead
to
a
failure
to
launch
the
app
.
Launch
path
:
%
"
aBundlePath
)
;
}
}
catch
(
NSException
*
e
)
{
NSLog
(
"
%
:
%
"
e
.
name
e
.
reason
)
;
}
}
static
void
StripQuarantineBit
(
NSString
*
aBundlePath
)
{
MacAutoreleasePool
pool
;
NSArray
*
arguments
=
[
"
-
dr
"
"
com
.
apple
.
quarantine
"
aBundlePath
]
;
LaunchTask
(
"
/
usr
/
bin
/
xattr
"
arguments
)
;
}
void
LaunchMacApp
(
int
argc
const
char
*
*
argv
)
{
MacAutoreleasePool
pool
;
try
{
NSString
*
launchPath
=
[
NSString
stringWithUTF8String
:
argv
[
0
]
]
;
NSMutableArray
*
arguments
=
[
NSMutableArray
arrayWithCapacity
:
argc
-
1
]
;
for
(
int
i
=
1
;
i
<
argc
;
i
+
+
)
{
[
arguments
addObject
:
[
NSString
stringWithUTF8String
:
argv
[
i
]
]
]
;
}
if
(
!
[
launchPath
hasSuffix
:
"
.
app
"
]
)
{
NSLog
(
"
The
updater
attempted
to
launch
an
app
that
was
not
a
.
app
"
"
bundle
.
Please
verify
launch
path
:
%
"
launchPath
)
;
return
;
}
StripQuarantineBit
(
launchPath
)
;
RegisterAppWithLaunchServices
(
launchPath
)
;
__block
dispatch_semaphore_t
semaphore
=
dispatch_semaphore_create
(
0
)
;
NSWorkspaceOpenConfiguration
*
config
=
[
NSWorkspaceOpenConfiguration
configuration
]
;
[
config
setArguments
:
arguments
]
;
[
config
setCreatesNewApplicationInstance
:
YES
]
;
[
config
setEnvironment
:
[
[
NSProcessInfo
processInfo
]
environment
]
]
;
[
[
NSWorkspace
sharedWorkspace
]
openApplicationAtURL
:
[
NSURL
fileURLWithPath
:
launchPath
]
configuration
:
config
completionHandler
:
^
(
NSRunningApplication
*
aChild
NSError
*
aError
)
{
if
(
aError
)
{
NSLog
(
"
launchchild_osx
:
Failed
to
run
application
.
Error
:
%
"
aError
)
;
}
dispatch_semaphore_signal
(
semaphore
)
;
}
]
;
dispatch_semaphore_wait
(
semaphore
DISPATCH_TIME_FOREVER
)
;
}
catch
(
NSException
*
e
)
{
NSLog
(
"
%
:
%
"
e
.
name
e
.
reason
)
;
}
}
void
LaunchMacPostProcess
(
const
char
*
aAppBundle
)
{
MacAutoreleasePool
pool
;
NSString
*
iniPath
=
[
NSString
stringWithUTF8String
:
aAppBundle
]
;
iniPath
=
[
iniPath
stringByAppendingPathComponent
:
"
Contents
/
Resources
/
updater
.
ini
"
]
;
NSFileManager
*
fileManager
=
[
NSFileManager
defaultManager
]
;
if
(
!
[
fileManager
fileExistsAtPath
:
iniPath
]
)
{
return
;
}
int
readResult
;
mozilla
:
:
UniquePtr
<
char
[
]
>
values
[
2
]
;
readResult
=
ReadStrings
(
[
iniPath
UTF8String
]
"
ExeRelPath
\
0ExeArg
\
0
"
2
values
"
PostUpdateMac
"
)
;
if
(
readResult
)
{
return
;
}
NSString
*
exeRelPath
=
[
NSString
stringWithUTF8String
:
values
[
0
]
.
get
(
)
]
;
NSString
*
exeArg
=
[
NSString
stringWithUTF8String
:
values
[
1
]
.
get
(
)
]
;
if
(
!
exeArg
|
|
!
exeRelPath
)
{
return
;
}
if
(
[
exeRelPath
isEqualToString
:
"
.
.
"
]
|
|
[
exeRelPath
hasPrefix
:
"
/
"
]
|
|
[
exeRelPath
hasPrefix
:
"
.
.
/
"
]
|
|
[
exeRelPath
hasSuffix
:
"
/
.
.
"
]
|
|
[
exeRelPath
containsString
:
"
/
.
.
/
"
]
)
{
return
;
}
NSString
*
exeFullPath
=
[
NSString
stringWithUTF8String
:
aAppBundle
]
;
exeFullPath
=
[
exeFullPath
stringByAppendingPathComponent
:
exeRelPath
]
;
mozilla
:
:
UniquePtr
<
char
[
]
>
optVal
;
readResult
=
ReadStrings
(
[
iniPath
UTF8String
]
"
ExeAsync
\
0
"
1
&
optVal
"
PostUpdateMac
"
)
;
NSTask
*
task
=
[
[
NSTask
alloc
]
init
]
;
[
task
setLaunchPath
:
exeFullPath
]
;
[
task
setArguments
:
[
NSArray
arrayWithObject
:
exeArg
]
]
;
[
task
setEnvironment
:
{
}
]
;
[
task
launch
]
;
if
(
!
readResult
)
{
NSString
*
exeAsync
=
[
NSString
stringWithUTF8String
:
optVal
.
get
(
)
]
;
if
(
[
exeAsync
isEqualToString
:
"
false
"
]
)
{
[
task
waitUntilExit
]
;
}
}
[
task
release
]
;
}
id
ConnectToUpdateServer
(
)
{
MacAutoreleasePool
pool
;
id
updateServer
=
nil
;
BOOL
isConnected
=
NO
;
int
currTry
=
0
;
const
int
numRetries
=
10
;
while
(
!
isConnected
&
&
currTry
<
numRetries
)
{
try
{
updateServer
=
(
id
)
[
NSConnection
rootProxyForConnectionWithRegisteredName
:
"
org
.
mozilla
.
updater
.
server
"
host
:
nil
usingNameServer
:
[
NSSocketPortNameServer
sharedInstance
]
]
;
if
(
!
updateServer
|
|
!
[
updateServer
respondsToSelector
:
selector
(
abort
)
]
|
|
!
[
updateServer
respondsToSelector
:
selector
(
getArguments
)
]
|
|
!
[
updateServer
respondsToSelector
:
selector
(
shutdown
)
]
)
{
NSLog
(
"
Server
doesn
'
t
exist
or
doesn
'
t
provide
correct
selectors
.
"
)
;
sleep
(
1
)
;
currTry
+
+
;
}
else
{
isConnected
=
YES
;
}
}
catch
(
NSException
*
e
)
{
NSLog
(
"
Encountered
exception
retrying
:
%
:
%
"
e
.
name
e
.
reason
)
;
sleep
(
1
)
;
currTry
+
+
;
}
}
if
(
!
isConnected
)
{
NSLog
(
"
Failed
to
connect
to
update
server
after
several
retries
.
"
)
;
return
nil
;
}
return
updateServer
;
}
void
CleanupElevatedMacUpdate
(
bool
aFailureOccurred
)
{
MacAutoreleasePool
pool
;
id
updateServer
=
ConnectToUpdateServer
(
)
;
if
(
updateServer
)
{
try
{
if
(
aFailureOccurred
)
{
[
updateServer
performSelector
:
selector
(
abort
)
]
;
}
else
{
[
updateServer
performSelector
:
selector
(
shutdown
)
]
;
}
}
catch
(
NSException
*
e
)
{
}
}
NSFileManager
*
manager
=
[
NSFileManager
defaultManager
]
;
[
manager
removeItemAtPath
:
"
/
Library
/
PrivilegedHelperTools
/
org
.
mozilla
.
updater
"
error
:
nil
]
;
[
manager
removeItemAtPath
:
"
/
Library
/
LaunchDaemons
/
org
.
mozilla
.
updater
.
plist
"
error
:
nil
]
;
LaunchTask
(
"
/
bin
/
launchctl
"
[
"
remove
"
"
org
.
mozilla
.
updater
"
]
)
;
}
bool
ObtainUpdaterArguments
(
int
*
aArgc
char
*
*
*
aArgv
MARChannelStringTable
*
aMARStrings
)
{
MacAutoreleasePool
pool
;
id
updateServer
=
ConnectToUpdateServer
(
)
;
if
(
!
updateServer
)
{
CleanupElevatedMacUpdate
(
true
)
;
return
false
;
}
try
{
NSArray
*
updaterArguments
=
[
updateServer
performSelector
:
selector
(
getArguments
)
]
;
*
aArgc
=
[
updaterArguments
count
]
;
char
*
*
tempArgv
=
(
char
*
*
)
malloc
(
sizeof
(
char
*
)
*
(
*
aArgc
)
)
;
for
(
int
i
=
0
;
i
<
*
aArgc
;
i
+
+
)
{
int
argLen
=
[
[
updaterArguments
objectAtIndex
:
i
]
length
]
+
1
;
tempArgv
[
i
]
=
(
char
*
)
malloc
(
argLen
)
;
strncpy
(
tempArgv
[
i
]
[
[
updaterArguments
objectAtIndex
:
i
]
UTF8String
]
argLen
)
;
}
*
aArgv
=
tempArgv
;
NSString
*
channelID
=
[
updateServer
performSelector
:
selector
(
getMARChannelID
)
]
;
const
char
*
channelIDStr
=
[
channelID
UTF8String
]
;
aMARStrings
-
>
MARChannelID
=
mozilla
:
:
MakeUnique
<
char
[
]
>
(
strlen
(
channelIDStr
)
+
1
)
;
strcpy
(
aMARStrings
-
>
MARChannelID
.
get
(
)
channelIDStr
)
;
}
catch
(
NSException
*
e
)
{
CleanupElevatedMacUpdate
(
true
)
;
return
false
;
}
return
true
;
}
interface
ElevatedUpdateServer
:
NSObject
{
NSArray
*
mUpdaterArguments
;
BOOL
mShouldKeepRunning
;
BOOL
mAborted
;
NSString
*
mMARChannelID
;
}
-
(
id
)
initWithArgs
:
(
NSArray
*
)
aArgs
marChannelID
:
(
NSString
*
)
aMARChannelID
;
-
(
BOOL
)
runServer
;
-
(
NSArray
*
)
getArguments
;
-
(
NSString
*
)
getMARChannelID
;
-
(
void
)
abort
;
-
(
BOOL
)
wasAborted
;
-
(
void
)
shutdown
;
-
(
BOOL
)
shouldKeepRunning
;
end
implementation
ElevatedUpdateServer
-
(
id
)
initWithArgs
:
(
NSArray
*
)
aArgs
marChannelID
:
(
NSString
*
)
aMARChannelID
{
self
=
[
super
init
]
;
if
(
!
self
)
{
return
nil
;
}
mUpdaterArguments
=
aArgs
;
mMARChannelID
=
aMARChannelID
;
mShouldKeepRunning
=
YES
;
mAborted
=
NO
;
return
self
;
}
-
(
BOOL
)
runServer
{
NSPort
*
serverPort
=
[
NSSocketPort
port
]
;
NSConnection
*
server
=
[
NSConnection
connectionWithReceivePort
:
serverPort
sendPort
:
serverPort
]
;
[
server
setRootObject
:
self
]
;
if
(
[
server
registerName
:
"
org
.
mozilla
.
updater
.
server
"
withNameServer
:
[
NSSocketPortNameServer
sharedInstance
]
]
=
=
NO
)
{
NSLog
(
"
Unable
to
register
as
DirectoryServer
.
"
)
;
NSLog
(
"
Is
another
copy
running
?
"
)
;
return
NO
;
}
while
(
[
self
shouldKeepRunning
]
&
&
[
[
NSRunLoop
currentRunLoop
]
runMode
:
NSDefaultRunLoopMode
beforeDate
:
[
NSDate
distantFuture
]
]
)
;
return
!
[
self
wasAborted
]
;
}
-
(
NSArray
*
)
getArguments
{
return
mUpdaterArguments
;
}
-
(
NSString
*
)
getMARChannelID
{
return
mMARChannelID
;
}
-
(
void
)
abort
{
mAborted
=
YES
;
[
self
shutdown
]
;
}
-
(
BOOL
)
wasAborted
{
return
mAborted
;
}
-
(
void
)
shutdown
{
mShouldKeepRunning
=
NO
;
}
-
(
BOOL
)
shouldKeepRunning
{
return
mShouldKeepRunning
;
}
end
bool
ServeElevatedUpdate
(
int
aArgc
const
char
*
*
aArgv
const
char
*
aMARChannelID
)
{
MacAutoreleasePool
pool
;
NSMutableArray
*
updaterArguments
=
[
NSMutableArray
arrayWithCapacity
:
aArgc
]
;
for
(
int
i
=
0
;
i
<
aArgc
;
i
+
+
)
{
[
updaterArguments
addObject
:
[
NSString
stringWithUTF8String
:
aArgv
[
i
]
]
]
;
}
NSString
*
channelID
=
[
NSString
stringWithUTF8String
:
aMARChannelID
]
;
ElevatedUpdateServer
*
updater
=
[
[
ElevatedUpdateServer
alloc
]
initWithArgs
:
updaterArguments
marChannelID
:
channelID
]
;
bool
didSucceed
=
[
updater
runServer
]
;
[
updater
release
]
;
return
didSucceed
;
}
bool
IsOwnedByGroupAdmin
(
const
char
*
aAppBundle
)
{
MacAutoreleasePool
pool
;
NSString
*
appDir
=
[
NSString
stringWithUTF8String
:
aAppBundle
]
;
NSFileManager
*
fileManager
=
[
NSFileManager
defaultManager
]
;
NSDictionary
*
attributes
=
[
fileManager
attributesOfItemAtPath
:
appDir
error
:
nil
]
;
bool
isOwnedByAdmin
=
false
;
if
(
attributes
&
&
[
[
attributes
valueForKey
:
NSFileGroupOwnerAccountID
]
intValue
]
=
=
80
)
{
isOwnedByAdmin
=
true
;
}
return
isOwnedByAdmin
;
}
void
SetGroupOwnershipAndPermissions
(
const
char
*
aAppBundle
)
{
MacAutoreleasePool
pool
;
NSString
*
appDir
=
[
NSString
stringWithUTF8String
:
aAppBundle
]
;
NSFileManager
*
fileManager
=
[
NSFileManager
defaultManager
]
;
NSError
*
error
=
nil
;
NSArray
*
paths
=
[
fileManager
subpathsOfDirectoryAtPath
:
appDir
error
:
&
error
]
;
if
(
error
)
{
return
;
}
if
(
!
[
fileManager
setAttributes
:
{
NSFileGroupOwnerAccountID
:
(
80
)
NSFilePosixPermissions
:
(
0775
)
}
ofItemAtPath
:
appDir
error
:
&
error
]
|
|
error
)
{
return
;
}
NSArray
*
permKeys
=
[
NSArray
arrayWithObjects
:
NSFileGroupOwnerAccountID
NSFilePosixPermissions
nil
]
;
for
(
NSString
*
currPath
in
paths
)
{
NSString
*
child
=
[
appDir
stringByAppendingPathComponent
:
currPath
]
;
NSDictionary
*
oldAttributes
=
[
fileManager
attributesOfItemAtPath
:
child
error
:
&
error
]
;
if
(
error
)
{
return
;
}
if
(
[
oldAttributes
fileType
]
=
=
NSFileTypeSymbolicLink
)
{
continue
;
}
NSNumber
*
oldPerms
=
(
NSNumber
*
)
[
oldAttributes
valueForKey
:
NSFilePosixPermissions
]
;
NSArray
*
permObjects
=
[
NSArray
arrayWithObjects
:
[
NSNumber
numberWithUnsignedLong
:
80
]
[
NSNumber
numberWithUnsignedLong
:
[
oldPerms
shortValue
]
|
020
]
nil
]
;
NSDictionary
*
attributes
=
[
NSDictionary
dictionaryWithObjects
:
permObjects
forKeys
:
permKeys
]
;
if
(
!
[
fileManager
setAttributes
:
attributes
ofItemAtPath
:
child
error
:
&
error
]
|
|
error
)
{
return
;
}
}
}
bool
PerformInstallationFromDMG
(
int
argc
char
*
*
argv
)
{
MacAutoreleasePool
pool
;
if
(
argc
<
4
)
{
return
false
;
}
NSString
*
bundlePath
=
[
NSString
stringWithUTF8String
:
argv
[
2
]
]
;
NSString
*
destPath
=
[
NSString
stringWithUTF8String
:
argv
[
3
]
]
;
if
(
[
[
NSFileManager
defaultManager
]
copyItemAtPath
:
bundlePath
toPath
:
destPath
error
:
nil
]
)
{
StripQuarantineBit
(
destPath
)
;
RegisterAppWithLaunchServices
(
destPath
)
;
return
true
;
}
return
false
;
}
