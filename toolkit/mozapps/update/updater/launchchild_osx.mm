#
include
<
Cocoa
/
Cocoa
.
h
>
#
include
<
CoreServices
/
CoreServices
.
h
>
#
include
<
crt_externs
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
<
spawn
.
h
>
#
include
<
SystemConfiguration
/
SystemConfiguration
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
include
"
readstrings
.
h
"
#
define
ARCH_PATH
"
/
usr
/
bin
/
arch
"
#
if
defined
(
__x86_64__
)
#
define
kCFBundleExecutableArchitectureARM64
0x0100000c
#
endif
class
MacAutoreleasePool
{
public
:
MacAutoreleasePool
(
)
{
mPool
=
[
[
NSAutoreleasePool
alloc
]
init
]
;
}
~
MacAutoreleasePool
(
)
{
[
mPool
release
]
;
}
private
:
NSAutoreleasePool
*
mPool
;
}
;
#
if
defined
(
__x86_64__
)
bool
IsProcessRosettaTranslated
(
)
{
int
ret
=
0
;
size_t
size
=
sizeof
(
ret
)
;
if
(
sysctlbyname
(
"
sysctl
.
proc_translated
"
&
ret
&
size
NULL
0
)
=
=
-
1
)
{
if
(
errno
!
=
ENOENT
)
{
fprintf
(
stderr
"
Failed
to
check
for
translation
environment
\
n
"
)
;
}
return
false
;
}
return
(
ret
=
=
1
)
;
}
bool
IsBinaryArmExecutable
(
const
char
*
executablePath
)
{
bool
isArmExecutable
=
false
;
CFURLRef
url
=
:
:
CFURLCreateFromFileSystemRepresentation
(
kCFAllocatorDefault
(
const
UInt8
*
)
executablePath
strlen
(
executablePath
)
false
)
;
if
(
!
url
)
{
return
false
;
}
CFArrayRef
archs
=
:
:
CFBundleCopyExecutableArchitecturesForURL
(
url
)
;
if
(
!
archs
)
{
CFRelease
(
url
)
;
return
false
;
}
CFIndex
archCount
=
:
:
CFArrayGetCount
(
archs
)
;
for
(
CFIndex
i
=
0
;
i
<
archCount
;
i
+
+
)
{
CFNumberRef
currentArch
=
static_cast
<
CFNumberRef
>
(
:
:
CFArrayGetValueAtIndex
(
archs
i
)
)
;
int
currentArchInt
=
0
;
if
(
!
:
:
CFNumberGetValue
(
currentArch
kCFNumberIntType
&
currentArchInt
)
)
{
continue
;
}
if
(
currentArchInt
=
=
kCFBundleExecutableArchitectureARM64
)
{
isArmExecutable
=
true
;
break
;
}
}
CFRelease
(
url
)
;
CFRelease
(
archs
)
;
return
isArmExecutable
;
}
bool
ShouldPreferArmLaunch
(
const
char
*
archPath
const
char
*
executablePath
)
{
if
(
!
IsProcessRosettaTranslated
(
)
)
{
return
false
;
}
NSFileManager
*
fileMgr
=
[
NSFileManager
defaultManager
]
;
NSString
*
archPathString
=
[
NSString
stringWithUTF8String
:
archPath
]
;
if
(
!
[
fileMgr
isExecutableFileAtPath
:
archPathString
]
)
{
return
false
;
}
return
IsBinaryArmExecutable
(
executablePath
)
;
}
#
endif
void
LaunchChild
(
int
argc
const
char
*
*
argv
)
{
MacAutoreleasePool
pool
;
try
{
bool
preferArmLaunch
=
false
;
#
if
defined
(
__x86_64__
)
preferArmLaunch
=
ShouldPreferArmLaunch
(
ARCH_PATH
argv
[
0
]
)
;
#
endif
NSString
*
launchPath
;
NSMutableArray
*
arguments
;
if
(
preferArmLaunch
)
{
launchPath
=
[
NSString
stringWithUTF8String
:
ARCH_PATH
]
;
arguments
=
[
NSMutableArray
arrayWithCapacity
:
argc
+
2
]
;
[
arguments
addObject
:
[
NSString
stringWithUTF8String
:
"
-
arm64
"
]
]
;
[
arguments
addObject
:
[
NSString
stringWithUTF8String
:
"
-
x86_64
"
]
]
;
[
arguments
addObject
:
[
NSString
stringWithUTF8String
:
argv
[
0
]
]
]
;
}
else
{
launchPath
=
[
NSString
stringWithUTF8String
:
argv
[
0
]
]
;
arguments
=
[
NSMutableArray
arrayWithCapacity
:
argc
-
1
]
;
}
for
(
int
i
=
1
;
i
<
argc
;
i
+
+
)
{
[
arguments
addObject
:
[
NSString
stringWithUTF8String
:
argv
[
i
]
]
]
;
}
[
NSTask
launchedTaskWithLaunchPath
:
launchPath
arguments
:
arguments
]
;
}
catch
(
NSException
*
e
)
{
NSLog
(
"
%
:
%
"
e
.
name
e
.
reason
)
;
}
}
void
LaunchMacPostProcess
(
const
char
*
aAppBundle
)
{
MacAutoreleasePool
pool
;
NSString
*
iniPath
=
[
NSString
stringWithUTF8String
:
aAppBundle
]
;
iniPath
=
[
iniPath
stringByAppendingPathComponent
:
"
Contents
/
Resources
/
updater
.
ini
"
]
;
NSFileManager
*
fileManager
=
[
NSFileManager
defaultManager
]
;
if
(
!
[
fileManager
fileExistsAtPath
:
iniPath
]
)
{
return
;
}
int
readResult
;
mozilla
:
:
UniquePtr
<
char
[
]
>
values
[
2
]
;
readResult
=
ReadStrings
(
[
iniPath
UTF8String
]
"
ExeRelPath
\
0ExeArg
\
0
"
2
values
"
PostUpdateMac
"
)
;
if
(
readResult
)
{
return
;
}
NSString
*
exeRelPath
=
[
NSString
stringWithUTF8String
:
values
[
0
]
.
get
(
)
]
;
NSString
*
exeArg
=
[
NSString
stringWithUTF8String
:
values
[
1
]
.
get
(
)
]
;
if
(
!
exeArg
|
|
!
exeRelPath
)
{
return
;
}
if
(
[
exeRelPath
isEqualToString
:
"
.
.
"
]
|
|
[
exeRelPath
hasPrefix
:
"
/
"
]
|
|
[
exeRelPath
hasPrefix
:
"
.
.
/
"
]
|
|
[
exeRelPath
hasSuffix
:
"
/
.
.
"
]
|
|
[
exeRelPath
containsString
:
"
/
.
.
/
"
]
)
{
return
;
}
NSString
*
exeFullPath
=
[
NSString
stringWithUTF8String
:
aAppBundle
]
;
exeFullPath
=
[
exeFullPath
stringByAppendingPathComponent
:
exeRelPath
]
;
mozilla
:
:
UniquePtr
<
char
[
]
>
optVal
;
readResult
=
ReadStrings
(
[
iniPath
UTF8String
]
"
ExeAsync
\
0
"
1
&
optVal
"
PostUpdateMac
"
)
;
NSTask
*
task
=
[
[
NSTask
alloc
]
init
]
;
[
task
setLaunchPath
:
exeFullPath
]
;
[
task
setArguments
:
[
NSArray
arrayWithObject
:
exeArg
]
]
;
[
task
setEnvironment
:
{
}
]
;
[
task
launch
]
;
if
(
!
readResult
)
{
NSString
*
exeAsync
=
[
NSString
stringWithUTF8String
:
optVal
.
get
(
)
]
;
if
(
[
exeAsync
isEqualToString
:
"
false
"
]
)
{
[
task
waitUntilExit
]
;
}
}
[
task
release
]
;
}
id
ConnectToUpdateServer
(
)
{
MacAutoreleasePool
pool
;
id
updateServer
=
nil
;
BOOL
isConnected
=
NO
;
int
currTry
=
0
;
const
int
numRetries
=
10
;
while
(
!
isConnected
&
&
currTry
<
numRetries
)
{
try
{
updateServer
=
(
id
)
[
NSConnection
rootProxyForConnectionWithRegisteredName
:
"
org
.
mozilla
.
updater
.
server
"
host
:
nil
usingNameServer
:
[
NSSocketPortNameServer
sharedInstance
]
]
;
if
(
!
updateServer
|
|
!
[
updateServer
respondsToSelector
:
selector
(
abort
)
]
|
|
!
[
updateServer
respondsToSelector
:
selector
(
getArguments
)
]
|
|
!
[
updateServer
respondsToSelector
:
selector
(
shutdown
)
]
)
{
NSLog
(
"
Server
doesn
'
t
exist
or
doesn
'
t
provide
correct
selectors
.
"
)
;
sleep
(
1
)
;
currTry
+
+
;
}
else
{
isConnected
=
YES
;
}
}
catch
(
NSException
*
e
)
{
NSLog
(
"
Encountered
exception
retrying
:
%
:
%
"
e
.
name
e
.
reason
)
;
sleep
(
1
)
;
currTry
+
+
;
}
}
if
(
!
isConnected
)
{
NSLog
(
"
Failed
to
connect
to
update
server
after
several
retries
.
"
)
;
return
nil
;
}
return
updateServer
;
}
void
CleanupElevatedMacUpdate
(
bool
aFailureOccurred
)
{
MacAutoreleasePool
pool
;
id
updateServer
=
ConnectToUpdateServer
(
)
;
if
(
updateServer
)
{
try
{
if
(
aFailureOccurred
)
{
[
updateServer
performSelector
:
selector
(
abort
)
]
;
}
else
{
[
updateServer
performSelector
:
selector
(
shutdown
)
]
;
}
}
catch
(
NSException
*
e
)
{
}
}
NSFileManager
*
manager
=
[
NSFileManager
defaultManager
]
;
[
manager
removeItemAtPath
:
"
/
Library
/
PrivilegedHelperTools
/
org
.
mozilla
.
updater
"
error
:
nil
]
;
[
manager
removeItemAtPath
:
"
/
Library
/
LaunchDaemons
/
org
.
mozilla
.
updater
.
plist
"
error
:
nil
]
;
const
char
*
launchctlArgs
[
]
=
{
"
/
bin
/
launchctl
"
"
remove
"
"
org
.
mozilla
.
updater
"
}
;
LaunchChild
(
3
launchctlArgs
)
;
}
bool
ObtainUpdaterArguments
(
int
*
aArgc
char
*
*
*
aArgv
MARChannelStringTable
*
aMARStrings
)
{
MacAutoreleasePool
pool
;
id
updateServer
=
ConnectToUpdateServer
(
)
;
if
(
!
updateServer
)
{
CleanupElevatedMacUpdate
(
true
)
;
return
false
;
}
try
{
NSArray
*
updaterArguments
=
[
updateServer
performSelector
:
selector
(
getArguments
)
]
;
*
aArgc
=
[
updaterArguments
count
]
;
char
*
*
tempArgv
=
(
char
*
*
)
malloc
(
sizeof
(
char
*
)
*
(
*
aArgc
)
)
;
for
(
int
i
=
0
;
i
<
*
aArgc
;
i
+
+
)
{
int
argLen
=
[
[
updaterArguments
objectAtIndex
:
i
]
length
]
+
1
;
tempArgv
[
i
]
=
(
char
*
)
malloc
(
argLen
)
;
strncpy
(
tempArgv
[
i
]
[
[
updaterArguments
objectAtIndex
:
i
]
UTF8String
]
argLen
)
;
}
*
aArgv
=
tempArgv
;
NSString
*
channelID
=
[
updateServer
performSelector
:
selector
(
getMARChannelID
)
]
;
const
char
*
channelIDStr
=
[
channelID
UTF8String
]
;
aMARStrings
-
>
MARChannelID
=
mozilla
:
:
MakeUnique
<
char
[
]
>
(
strlen
(
channelIDStr
)
+
1
)
;
strcpy
(
aMARStrings
-
>
MARChannelID
.
get
(
)
channelIDStr
)
;
}
catch
(
NSException
*
e
)
{
CleanupElevatedMacUpdate
(
true
)
;
return
false
;
}
return
true
;
}
interface
ElevatedUpdateServer
:
NSObject
{
NSArray
*
mUpdaterArguments
;
BOOL
mShouldKeepRunning
;
BOOL
mAborted
;
NSString
*
mMARChannelID
;
}
-
(
id
)
initWithArgs
:
(
NSArray
*
)
aArgs
marChannelID
:
(
NSString
*
)
aMARChannelID
;
-
(
BOOL
)
runServer
;
-
(
NSArray
*
)
getArguments
;
-
(
NSString
*
)
getMARChannelID
;
-
(
void
)
abort
;
-
(
BOOL
)
wasAborted
;
-
(
void
)
shutdown
;
-
(
BOOL
)
shouldKeepRunning
;
end
implementation
ElevatedUpdateServer
-
(
id
)
initWithArgs
:
(
NSArray
*
)
aArgs
marChannelID
:
(
NSString
*
)
aMARChannelID
{
self
=
[
super
init
]
;
if
(
!
self
)
{
return
nil
;
}
mUpdaterArguments
=
aArgs
;
mMARChannelID
=
aMARChannelID
;
mShouldKeepRunning
=
YES
;
mAborted
=
NO
;
return
self
;
}
-
(
BOOL
)
runServer
{
NSPort
*
serverPort
=
[
NSSocketPort
port
]
;
NSConnection
*
server
=
[
NSConnection
connectionWithReceivePort
:
serverPort
sendPort
:
serverPort
]
;
[
server
setRootObject
:
self
]
;
if
(
[
server
registerName
:
"
org
.
mozilla
.
updater
.
server
"
withNameServer
:
[
NSSocketPortNameServer
sharedInstance
]
]
=
=
NO
)
{
NSLog
(
"
Unable
to
register
as
DirectoryServer
.
"
)
;
NSLog
(
"
Is
another
copy
running
?
"
)
;
return
NO
;
}
while
(
[
self
shouldKeepRunning
]
&
&
[
[
NSRunLoop
currentRunLoop
]
runMode
:
NSDefaultRunLoopMode
beforeDate
:
[
NSDate
distantFuture
]
]
)
;
return
!
[
self
wasAborted
]
;
}
-
(
NSArray
*
)
getArguments
{
return
mUpdaterArguments
;
}
-
(
NSString
*
)
getMARChannelID
{
return
mMARChannelID
;
}
-
(
void
)
abort
{
mAborted
=
YES
;
[
self
shutdown
]
;
}
-
(
BOOL
)
wasAborted
{
return
mAborted
;
}
-
(
void
)
shutdown
{
mShouldKeepRunning
=
NO
;
}
-
(
BOOL
)
shouldKeepRunning
{
return
mShouldKeepRunning
;
}
end
bool
ServeElevatedUpdate
(
int
aArgc
const
char
*
*
aArgv
const
char
*
aMARChannelID
)
{
MacAutoreleasePool
pool
;
NSMutableArray
*
updaterArguments
=
[
NSMutableArray
arrayWithCapacity
:
aArgc
]
;
for
(
int
i
=
0
;
i
<
aArgc
;
i
+
+
)
{
[
updaterArguments
addObject
:
[
NSString
stringWithUTF8String
:
aArgv
[
i
]
]
]
;
}
NSString
*
channelID
=
[
NSString
stringWithUTF8String
:
aMARChannelID
]
;
ElevatedUpdateServer
*
updater
=
[
[
ElevatedUpdateServer
alloc
]
initWithArgs
:
updaterArguments
marChannelID
:
channelID
]
;
bool
didSucceed
=
[
updater
runServer
]
;
[
updater
release
]
;
return
didSucceed
;
}
bool
IsOwnedByGroupAdmin
(
const
char
*
aAppBundle
)
{
MacAutoreleasePool
pool
;
NSString
*
appDir
=
[
NSString
stringWithUTF8String
:
aAppBundle
]
;
NSFileManager
*
fileManager
=
[
NSFileManager
defaultManager
]
;
NSDictionary
*
attributes
=
[
fileManager
attributesOfItemAtPath
:
appDir
error
:
nil
]
;
bool
isOwnedByAdmin
=
false
;
if
(
attributes
&
&
[
[
attributes
valueForKey
:
NSFileGroupOwnerAccountID
]
intValue
]
=
=
80
)
{
isOwnedByAdmin
=
true
;
}
return
isOwnedByAdmin
;
}
void
SetGroupOwnershipAndPermissions
(
const
char
*
aAppBundle
)
{
MacAutoreleasePool
pool
;
NSString
*
appDir
=
[
NSString
stringWithUTF8String
:
aAppBundle
]
;
NSFileManager
*
fileManager
=
[
NSFileManager
defaultManager
]
;
NSError
*
error
=
nil
;
NSArray
*
paths
=
[
fileManager
subpathsOfDirectoryAtPath
:
appDir
error
:
&
error
]
;
if
(
error
)
{
return
;
}
if
(
!
[
fileManager
setAttributes
:
{
NSFileGroupOwnerAccountID
:
(
80
)
NSFilePosixPermissions
:
(
0775
)
}
ofItemAtPath
:
appDir
error
:
&
error
]
|
|
error
)
{
return
;
}
NSArray
*
permKeys
=
[
NSArray
arrayWithObjects
:
NSFileGroupOwnerAccountID
NSFilePosixPermissions
nil
]
;
for
(
NSString
*
currPath
in
paths
)
{
NSString
*
child
=
[
appDir
stringByAppendingPathComponent
:
currPath
]
;
NSDictionary
*
oldAttributes
=
[
fileManager
attributesOfItemAtPath
:
child
error
:
&
error
]
;
if
(
error
)
{
return
;
}
if
(
[
oldAttributes
fileType
]
=
=
NSFileTypeSymbolicLink
)
{
continue
;
}
NSNumber
*
oldPerms
=
(
NSNumber
*
)
[
oldAttributes
valueForKey
:
NSFilePosixPermissions
]
;
NSArray
*
permObjects
=
[
NSArray
arrayWithObjects
:
[
NSNumber
numberWithUnsignedLong
:
80
]
[
NSNumber
numberWithUnsignedLong
:
[
oldPerms
shortValue
]
|
020
]
nil
]
;
NSDictionary
*
attributes
=
[
NSDictionary
dictionaryWithObjects
:
permObjects
forKeys
:
permKeys
]
;
if
(
!
[
fileManager
setAttributes
:
attributes
ofItemAtPath
:
child
error
:
&
error
]
|
|
error
)
{
return
;
}
}
}
static
void
LaunchTask
(
NSString
*
aPath
NSArray
*
aArguments
)
{
NSTask
*
task
=
[
[
NSTask
alloc
]
init
]
;
[
task
setExecutableURL
:
[
NSURL
fileURLWithPath
:
aPath
]
]
;
if
(
aArguments
)
{
[
task
setArguments
:
aArguments
]
;
}
[
task
launchAndReturnError
:
nil
]
;
[
task
release
]
;
}
static
void
RegisterAppWithLaunchServices
(
NSString
*
aBundlePath
)
{
NSArray
*
arguments
=
[
"
-
f
"
aBundlePath
]
;
LaunchTask
(
"
/
System
/
Library
/
Frameworks
/
CoreServices
.
framework
/
Frameworks
/
"
"
LaunchServices
.
framework
/
Support
/
lsregister
"
arguments
)
;
}
static
void
StripQuarantineBit
(
NSString
*
aBundlePath
)
{
NSArray
*
arguments
=
[
"
-
d
"
"
com
.
apple
.
quarantine
"
aBundlePath
]
;
LaunchTask
(
"
/
usr
/
bin
/
xattr
"
arguments
)
;
}
bool
PerformInstallationFromDMG
(
int
argc
char
*
*
argv
)
{
MacAutoreleasePool
pool
;
if
(
argc
<
4
)
{
return
false
;
}
NSString
*
bundlePath
=
[
NSString
stringWithUTF8String
:
argv
[
2
]
]
;
NSString
*
destPath
=
[
NSString
stringWithUTF8String
:
argv
[
3
]
]
;
if
(
[
[
NSFileManager
defaultManager
]
copyItemAtPath
:
bundlePath
toPath
:
destPath
error
:
nil
]
)
{
RegisterAppWithLaunchServices
(
destPath
)
;
StripQuarantineBit
(
destPath
)
;
return
true
;
}
return
false
;
}
