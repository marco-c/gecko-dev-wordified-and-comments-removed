#
include
<
string
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
fcntl
.
h
>
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
endif
#
include
"
archivereader
.
h
"
#
include
"
errors
.
h
"
#
ifdef
XP_WIN
#
include
"
nsAlgorithm
.
h
"
#
include
"
updatehelper
.
h
"
#
endif
#
define
XZ_USE_CRC64
#
include
"
xz
.
h
"
#
ifdef
MOZ_VERIFY_MAR_SIGNATURE
#
ifdef
TEST_UPDATER
#
include
"
.
.
/
xpcshellCert
.
h
"
#
else
#
include
"
primaryCert
.
h
"
#
include
"
secondaryCert
.
h
"
#
endif
#
endif
#
define
UPDATER_NO_STRING_GLUE_STL
#
include
"
nsVersionComparator
.
cpp
"
#
undef
UPDATER_NO_STRING_GLUE_STL
#
if
defined
(
XP_UNIX
)
#
include
<
sys
/
types
.
h
>
#
elif
defined
(
XP_WIN
)
#
include
<
io
.
h
>
#
endif
template
<
uint32_t
SIZE
>
int
VerifyLoadedCert
(
MarFile
*
archive
const
uint8_t
(
&
certData
)
[
SIZE
]
)
{
(
void
)
archive
;
(
void
)
certData
;
#
ifdef
MOZ_VERIFY_MAR_SIGNATURE
const
uint32_t
size
=
SIZE
;
const
uint8_t
*
const
data
=
&
certData
[
0
]
;
if
(
mar_verify_signatures
(
archive
&
data
&
size
1
)
)
{
return
CERT_VERIFY_ERROR
;
}
#
endif
return
OK
;
}
int
ArchiveReader
:
:
VerifySignature
(
)
{
if
(
!
mArchive
)
{
return
ARCHIVE_NOT_OPEN
;
}
#
ifndef
MOZ_VERIFY_MAR_SIGNATURE
return
OK
;
#
else
#
ifdef
TEST_UPDATER
int
rv
=
VerifyLoadedCert
(
mArchive
xpcshellCertData
)
;
#
else
int
rv
=
VerifyLoadedCert
(
mArchive
primaryCertData
)
;
if
(
rv
!
=
OK
)
{
rv
=
VerifyLoadedCert
(
mArchive
secondaryCertData
)
;
}
#
endif
return
rv
;
#
endif
}
int
ArchiveReader
:
:
VerifyProductInformation
(
const
char
*
MARChannelID
const
char
*
appVersion
)
{
if
(
!
mArchive
)
{
return
ARCHIVE_NOT_OPEN
;
}
ProductInformationBlock
productInfoBlock
;
int
rv
=
mar_read_product_info_block
(
mArchive
&
productInfoBlock
)
;
if
(
rv
!
=
OK
)
{
return
COULD_NOT_READ_PRODUCT_INFO_BLOCK_ERROR
;
}
if
(
MARChannelID
&
&
strlen
(
MARChannelID
)
)
{
const
char
*
delimiter
=
"
\
t
"
;
char
channelCopy
[
512
]
=
{
0
}
;
strncpy
(
channelCopy
MARChannelID
sizeof
(
channelCopy
)
-
1
)
;
char
*
channel
=
strtok
(
channelCopy
delimiter
)
;
rv
=
MAR_CHANNEL_MISMATCH_ERROR
;
while
(
channel
)
{
if
(
!
strcmp
(
channel
productInfoBlock
.
MARChannelID
)
)
{
rv
=
OK
;
break
;
}
channel
=
strtok
(
nullptr
delimiter
)
;
}
}
if
(
rv
=
=
OK
)
{
int
versionCompareResult
=
mozilla
:
:
CompareVersions
(
appVersion
productInfoBlock
.
productVersion
)
;
if
(
1
=
=
versionCompareResult
)
{
rv
=
VERSION_DOWNGRADE_ERROR
;
}
}
free
(
(
void
*
)
productInfoBlock
.
MARChannelID
)
;
free
(
(
void
*
)
productInfoBlock
.
productVersion
)
;
return
rv
;
}
int
ArchiveReader
:
:
Open
(
const
NS_tchar
*
path
)
{
if
(
mArchive
)
Close
(
)
;
if
(
!
mInBuf
)
{
mInBuf
=
(
uint8_t
*
)
malloc
(
mInBufSize
)
;
if
(
!
mInBuf
)
{
mInBufSize
=
1024
;
mInBuf
=
(
uint8_t
*
)
malloc
(
mInBufSize
)
;
if
(
!
mInBuf
)
return
ARCHIVE_READER_MEM_ERROR
;
}
}
if
(
!
mOutBuf
)
{
mOutBuf
=
(
uint8_t
*
)
malloc
(
mOutBufSize
)
;
if
(
!
mOutBuf
)
{
mOutBufSize
=
1024
;
mOutBuf
=
(
uint8_t
*
)
malloc
(
mOutBufSize
)
;
if
(
!
mOutBuf
)
return
ARCHIVE_READER_MEM_ERROR
;
}
}
#
ifdef
XP_WIN
mArchive
=
mar_wopen
(
path
)
;
#
else
mArchive
=
mar_open
(
path
)
;
#
endif
if
(
!
mArchive
)
return
READ_ERROR
;
xz_crc32_init
(
)
;
xz_crc64_init
(
)
;
return
OK
;
}
void
ArchiveReader
:
:
Close
(
)
{
if
(
mArchive
)
{
mar_close
(
mArchive
)
;
mArchive
=
nullptr
;
}
if
(
mInBuf
)
{
free
(
mInBuf
)
;
mInBuf
=
nullptr
;
}
if
(
mOutBuf
)
{
free
(
mOutBuf
)
;
mOutBuf
=
nullptr
;
}
}
int
ArchiveReader
:
:
ExtractFile
(
const
char
*
name
const
NS_tchar
*
dest
)
{
const
MarItem
*
item
=
mar_find_item
(
mArchive
name
)
;
if
(
!
item
)
return
READ_ERROR
;
#
ifdef
XP_WIN
FILE
*
fp
=
_wfopen
(
dest
L
"
wb
+
"
)
;
#
else
int
fd
=
creat
(
dest
item
-
>
flags
)
;
if
(
fd
=
=
-
1
)
return
WRITE_ERROR
;
FILE
*
fp
=
fdopen
(
fd
"
wb
"
)
;
#
endif
if
(
!
fp
)
return
WRITE_ERROR
;
int
rv
=
ExtractItemToStream
(
item
fp
)
;
fclose
(
fp
)
;
return
rv
;
}
int
ArchiveReader
:
:
ExtractFileToStream
(
const
char
*
name
FILE
*
fp
)
{
const
MarItem
*
item
=
mar_find_item
(
mArchive
name
)
;
if
(
!
item
)
return
READ_ERROR
;
return
ExtractItemToStream
(
item
fp
)
;
}
int
ArchiveReader
:
:
ExtractItemToStream
(
const
MarItem
*
item
FILE
*
fp
)
{
int
offset
inlen
ret
=
OK
;
struct
xz_buf
strm
=
{
0
}
;
enum
xz_ret
xz_rv
=
XZ_OK
;
struct
xz_dec
*
dec
=
xz_dec_init
(
XZ_DYNALLOC
64
*
1024
*
1024
)
;
if
(
!
dec
)
{
return
UNEXPECTED_XZ_ERROR
;
}
strm
.
in
=
mInBuf
;
strm
.
in_pos
=
0
;
strm
.
in_size
=
0
;
strm
.
out
=
mOutBuf
;
strm
.
out_pos
=
0
;
strm
.
out_size
=
mOutBufSize
;
offset
=
0
;
for
(
;
;
)
{
if
(
!
item
-
>
length
)
{
ret
=
UNEXPECTED_MAR_ERROR
;
break
;
}
if
(
offset
<
(
int
)
item
-
>
length
&
&
strm
.
in_pos
=
=
strm
.
in_size
)
{
inlen
=
mar_read
(
mArchive
item
offset
mInBuf
mInBufSize
)
;
if
(
inlen
<
=
0
)
{
ret
=
READ_ERROR
;
break
;
}
offset
+
=
inlen
;
strm
.
in_size
=
inlen
;
strm
.
in_pos
=
0
;
}
xz_rv
=
xz_dec_run
(
dec
&
strm
)
;
if
(
strm
.
out_pos
=
=
mOutBufSize
)
{
if
(
fwrite
(
mOutBuf
1
strm
.
out_pos
fp
)
!
=
strm
.
out_pos
)
{
ret
=
WRITE_ERROR_EXTRACT
;
break
;
}
strm
.
out_pos
=
0
;
}
if
(
xz_rv
=
=
XZ_OK
)
{
continue
;
}
if
(
xz_rv
!
=
XZ_STREAM_END
)
{
ret
=
UNEXPECTED_XZ_ERROR
;
break
;
}
if
(
fwrite
(
mOutBuf
1
strm
.
out_pos
fp
)
!
=
strm
.
out_pos
)
{
ret
=
WRITE_ERROR_EXTRACT
;
}
break
;
}
xz_dec_end
(
dec
)
;
return
ret
;
}
