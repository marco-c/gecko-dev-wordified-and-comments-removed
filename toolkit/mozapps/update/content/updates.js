"
use
strict
"
;
const
{
classes
:
CoC
interfaces
:
CoI
results
:
CoR
utils
:
CoU
}
=
Components
;
CoU
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
jsm
"
this
)
;
CoU
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
CoU
.
import
(
"
resource
:
/
/
gre
/
modules
/
UpdateTelemetry
.
jsm
"
this
)
;
const
XMLNS_XUL
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
PREF_APP_UPDATE_BACKGROUNDERRORS
=
"
app
.
update
.
backgroundErrors
"
;
const
PREF_APP_UPDATE_CERT_ERRORS
=
"
app
.
update
.
cert
.
errors
"
;
const
PREF_APP_UPDATE_ELEVATE_NEVER
=
"
app
.
update
.
elevate
.
never
"
;
const
PREF_APP_UPDATE_ENABLED
=
"
app
.
update
.
enabled
"
;
const
PREF_APP_UPDATE_LOG
=
"
app
.
update
.
log
"
;
const
PREF_APP_UPDATE_NOTIFIEDUNSUPPORTED
=
"
app
.
update
.
notifiedUnsupported
"
;
const
PREF_APP_UPDATE_TEST_LOOP
=
"
app
.
update
.
test
.
loop
"
;
const
PREF_APP_UPDATE_URL_MANUAL
=
"
app
.
update
.
url
.
manual
"
;
const
UPDATE_TEST_LOOP_INTERVAL
=
2000
;
const
URI_UPDATES_PROPERTIES
=
"
chrome
:
/
/
mozapps
/
locale
/
update
/
updates
.
properties
"
;
const
STATE_DOWNLOADING
=
"
downloading
"
;
const
STATE_PENDING
=
"
pending
"
;
const
STATE_PENDING_SERVICE
=
"
pending
-
service
"
;
const
STATE_PENDING_ELEVATE
=
"
pending
-
elevate
"
;
const
STATE_APPLYING
=
"
applying
"
;
const
STATE_APPLIED
=
"
applied
"
;
const
STATE_APPLIED_SERVICE
=
"
applied
-
service
"
;
const
STATE_SUCCEEDED
=
"
succeeded
"
;
const
STATE_DOWNLOAD_FAILED
=
"
download
-
failed
"
;
const
STATE_FAILED
=
"
failed
"
;
const
SRCEVT_FOREGROUND
=
1
;
const
SRCEVT_BACKGROUND
=
2
;
const
BACKGROUNDCHECK_MULTIPLE_FAILURES
=
110
;
var
gLogEnabled
=
false
;
var
gUpdatesFoundPageId
;
function
LOG
(
module
string
)
{
if
(
gLogEnabled
)
{
dump
(
"
*
*
*
AUS
:
UI
"
+
module
+
"
:
"
+
string
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
"
AUS
:
UI
"
+
module
+
"
:
"
+
string
)
;
}
}
function
openUpdateURL
(
event
)
{
if
(
event
.
button
=
=
0
)
openURL
(
event
.
target
.
getAttribute
(
"
url
"
)
)
;
}
function
getPref
(
func
preference
defaultValue
)
{
try
{
return
Services
.
prefs
[
func
]
(
preference
)
;
}
catch
(
e
)
{
LOG
(
"
General
"
"
getPref
-
failed
to
get
preference
:
"
+
preference
)
;
}
return
defaultValue
;
}
var
gUpdates
=
{
update
:
null
strings
:
null
brandName
:
null
wiz
:
null
_runUnload
:
true
_submitTelemetry
(
aPageID
)
{
AUSTLMY
.
pingWizLastPageCode
(
aPageID
)
;
}
_setButton
(
button
string
)
{
if
(
string
)
{
var
label
=
this
.
getAUSString
(
string
)
;
if
(
label
.
indexOf
(
"
%
S
"
)
!
=
-
1
)
label
=
label
.
replace
(
/
%
S
/
this
.
brandName
)
;
button
.
label
=
label
;
button
.
setAttribute
(
"
accesskey
"
this
.
getAUSString
(
string
+
"
.
accesskey
"
)
)
;
}
else
{
button
.
label
=
button
.
defaultLabel
;
button
.
setAttribute
(
"
accesskey
"
button
.
defaultAccesskey
)
;
}
}
setButtons
(
extra1ButtonString
extra2ButtonString
nextFinishButtonString
canAdvance
showCancel
)
{
this
.
wiz
.
canAdvance
=
canAdvance
;
var
bnf
=
this
.
wiz
.
getButton
(
this
.
wiz
.
onLastPage
?
"
finish
"
:
"
next
"
)
;
var
be1
=
this
.
wiz
.
getButton
(
"
extra1
"
)
;
var
be2
=
this
.
wiz
.
getButton
(
"
extra2
"
)
;
var
bc
=
this
.
wiz
.
getButton
(
"
cancel
"
)
;
this
.
_setButton
(
bnf
nextFinishButtonString
)
;
this
.
_setButton
(
be1
extra1ButtonString
)
;
this
.
_setButton
(
be2
extra2ButtonString
)
;
bnf
.
hidden
=
bnf
.
disabled
=
!
nextFinishButtonString
;
be1
.
hidden
=
be1
.
disabled
=
!
extra1ButtonString
;
be2
.
hidden
=
be2
.
disabled
=
!
extra2ButtonString
;
bc
.
hidden
=
bc
.
disabled
=
!
showCancel
;
var
btn
=
this
.
wiz
.
getButton
(
"
back
"
)
;
btn
.
hidden
=
btn
.
disabled
=
true
;
btn
=
this
.
wiz
.
getButton
(
this
.
wiz
.
onLastPage
?
"
next
"
:
"
finish
"
)
;
btn
.
hidden
=
btn
.
disabled
=
true
;
}
getAUSString
(
key
strings
)
{
if
(
strings
)
return
this
.
strings
.
getFormattedString
(
key
strings
)
;
return
this
.
strings
.
getString
(
key
)
;
}
never
(
)
{
let
aus
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
CoI
.
nsIApplicationUpdateService
)
;
if
(
aus
.
elevationRequired
)
{
Services
.
prefs
.
setCharPref
(
PREF_APP_UPDATE_ELEVATE_NEVER
this
.
update
.
appVersion
)
;
}
}
_pages
:
{
}
onWizardFinish
(
)
{
this
.
_runUnload
=
false
;
var
pageid
=
document
.
documentElement
.
currentPage
.
pageid
;
if
(
"
onWizardFinish
"
in
this
.
_pages
[
pageid
]
)
this
.
_pages
[
pageid
]
.
onWizardFinish
(
)
;
this
.
_submitTelemetry
(
pageid
)
;
}
onWizardCancel
(
)
{
this
.
_runUnload
=
false
;
var
pageid
=
document
.
documentElement
.
currentPage
.
pageid
;
if
(
"
onWizardCancel
"
in
this
.
_pages
[
pageid
]
)
this
.
_pages
[
pageid
]
.
onWizardCancel
(
)
;
this
.
_submitTelemetry
(
pageid
)
;
}
onWizardNext
(
)
{
var
cp
=
document
.
documentElement
.
currentPage
;
if
(
!
cp
)
return
;
var
pageid
=
cp
.
pageid
;
if
(
"
onWizardNext
"
in
this
.
_pages
[
pageid
]
)
this
.
_pages
[
pageid
]
.
onWizardNext
(
)
;
}
sourceEvent
:
SRCEVT_FOREGROUND
_cacheButtonStrings
(
buttonName
)
{
var
button
=
this
.
wiz
.
getButton
(
buttonName
)
;
button
.
defaultLabel
=
button
.
label
;
button
.
defaultAccesskey
=
button
.
getAttribute
(
"
accesskey
"
)
;
}
onLoad
(
)
{
this
.
wiz
=
document
.
documentElement
;
gLogEnabled
=
getPref
(
"
getBoolPref
"
PREF_APP_UPDATE_LOG
false
)
;
this
.
strings
=
document
.
getElementById
(
"
updateStrings
"
)
;
var
brandStrings
=
document
.
getElementById
(
"
brandStrings
"
)
;
this
.
brandName
=
brandStrings
.
getString
(
"
brandShortName
"
)
;
var
pages
=
this
.
wiz
.
childNodes
;
for
(
var
i
=
0
;
i
<
pages
.
length
;
+
+
i
)
{
var
page
=
pages
[
i
]
;
if
(
page
.
localName
=
=
"
wizardpage
"
)
this
.
_pages
[
page
.
pageid
]
=
eval
(
page
.
getAttribute
(
"
object
"
)
)
;
}
this
.
_cacheButtonStrings
(
"
next
"
)
;
this
.
_cacheButtonStrings
(
"
finish
"
)
;
this
.
_cacheButtonStrings
(
"
extra1
"
)
;
this
.
_cacheButtonStrings
(
"
extra2
"
)
;
this
.
getStartPageID
(
function
(
startPageID
)
{
LOG
(
"
gUpdates
"
"
onLoad
-
setting
current
page
to
startpage
"
+
startPageID
)
;
gUpdates
.
wiz
.
currentPage
=
document
.
getElementById
(
startPageID
)
;
}
)
;
}
onUnload
(
)
{
if
(
this
.
_runUnload
)
{
var
cp
=
this
.
wiz
.
currentPage
;
if
(
cp
.
pageid
!
=
"
finished
"
&
&
cp
.
pageid
!
=
"
finishedBackground
"
)
this
.
onWizardCancel
(
)
;
}
}
getStartPageID
(
aCallback
)
{
if
(
"
arguments
"
in
window
&
&
window
.
arguments
[
0
]
)
{
var
arg0
=
window
.
arguments
[
0
]
;
if
(
arg0
instanceof
CoI
.
nsIUpdate
)
{
this
.
setUpdate
(
arg0
)
;
if
(
this
.
update
.
errorCode
=
=
BACKGROUNDCHECK_MULTIPLE_FAILURES
)
{
aCallback
(
"
errorextra
"
)
;
return
;
}
if
(
this
.
update
.
unsupported
)
{
aCallback
(
"
unsupported
"
)
;
return
;
}
var
p
=
this
.
update
.
selectedPatch
;
if
(
p
)
{
let
state
=
p
.
state
;
let
patchFailed
=
this
.
update
.
getProperty
(
"
patchingFailed
"
)
;
if
(
patchFailed
)
{
if
(
patchFailed
!
=
"
partial
"
|
|
this
.
update
.
patchCount
!
=
2
)
{
state
=
STATE_DOWNLOAD_FAILED
;
}
else
{
state
=
STATE_FAILED
;
}
}
switch
(
state
)
{
case
STATE_PENDING
:
case
STATE_PENDING_SERVICE
:
case
STATE_PENDING_ELEVATE
:
case
STATE_APPLIED
:
case
STATE_APPLIED_SERVICE
:
this
.
sourceEvent
=
SRCEVT_BACKGROUND
;
aCallback
(
"
finishedBackground
"
)
;
return
;
case
STATE_DOWNLOADING
:
aCallback
(
"
downloading
"
)
;
return
;
case
STATE_FAILED
:
window
.
getAttention
(
)
;
aCallback
(
"
errorpatching
"
)
;
return
;
case
STATE_DOWNLOAD_FAILED
:
case
STATE_APPLYING
:
aCallback
(
"
errors
"
)
;
return
;
}
}
let
aus
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
CoI
.
nsIApplicationUpdateService
)
;
if
(
!
aus
.
canApplyUpdates
)
{
aCallback
(
"
manualUpdate
"
)
;
return
;
}
aCallback
(
this
.
updatesFoundPageId
)
;
return
;
}
}
else
{
var
um
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
CoI
.
nsIUpdateManager
)
;
if
(
um
.
activeUpdate
)
{
this
.
setUpdate
(
um
.
activeUpdate
)
;
aCallback
(
"
downloading
"
)
;
return
;
}
}
aCallback
(
"
checking
"
)
;
}
get
updatesFoundPageId
(
)
{
if
(
gUpdatesFoundPageId
)
return
gUpdatesFoundPageId
;
return
gUpdatesFoundPageId
=
"
updatesfoundbasic
"
;
}
setUpdate
(
update
)
{
this
.
update
=
update
;
if
(
this
.
update
)
this
.
update
.
QueryInterface
(
CoI
.
nsIWritablePropertyBag
)
;
}
}
;
var
gCheckingPage
=
{
_checker
:
null
onPageShow
(
)
{
gUpdates
.
setButtons
(
null
null
null
false
true
)
;
gUpdates
.
wiz
.
getButton
(
"
cancel
"
)
.
focus
(
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_BACKGROUNDERRORS
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_BACKGROUNDERRORS
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_NOTIFIEDUNSUPPORTED
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_NOTIFIEDUNSUPPORTED
)
;
}
this
.
_checker
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
checker
;
1
"
]
.
createInstance
(
CoI
.
nsIUpdateChecker
)
;
this
.
_checker
.
checkForUpdates
(
this
.
updateListener
true
)
;
}
onWizardCancel
(
)
{
this
.
_checker
.
stopChecking
(
CoI
.
nsIUpdateChecker
.
CURRENT_CHECK
)
;
}
updateListener
:
{
onCheckComplete
(
request
updates
updateCount
)
{
var
aus
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
CoI
.
nsIApplicationUpdateService
)
;
gUpdates
.
setUpdate
(
aus
.
selectUpdate
(
updates
updates
.
length
)
)
;
if
(
gUpdates
.
update
)
{
LOG
(
"
gCheckingPage
"
"
onCheckComplete
-
update
found
"
)
;
if
(
gUpdates
.
update
.
unsupported
)
{
gUpdates
.
wiz
.
goTo
(
"
unsupported
"
)
;
return
;
}
if
(
gUpdates
.
update
.
elevationFailure
)
{
gUpdates
.
never
(
)
;
gUpdates
.
wiz
.
goTo
(
"
manualUpdate
"
)
;
return
;
}
if
(
!
aus
.
canApplyUpdates
)
{
gUpdates
.
wiz
.
goTo
(
"
manualUpdate
"
)
;
return
;
}
gUpdates
.
wiz
.
goTo
(
gUpdates
.
updatesFoundPageId
)
;
return
;
}
LOG
(
"
gCheckingPage
"
"
onCheckComplete
-
no
update
found
"
)
;
gUpdates
.
wiz
.
goTo
(
"
noupdatesfound
"
)
;
}
onError
(
request
update
)
{
LOG
(
"
gCheckingPage
"
"
onError
-
proceeding
to
error
page
"
)
;
gUpdates
.
setUpdate
(
update
)
;
gUpdates
.
wiz
.
goTo
(
"
errors
"
)
;
}
QueryInterface
(
aIID
)
{
if
(
!
aIID
.
equals
(
CoI
.
nsIUpdateCheckListener
)
&
&
!
aIID
.
equals
(
CoI
.
nsISupports
)
)
throw
CoR
.
NS_ERROR_NO_INTERFACE
;
return
this
;
}
}
}
;
var
gNoUpdatesPage
=
{
onPageShow
(
)
{
LOG
(
"
gNoUpdatesPage
"
"
onPageShow
-
could
not
select
an
appropriate
"
+
"
update
.
Either
there
were
no
updates
or
|
selectUpdate
|
failed
"
)
;
if
(
getPref
(
"
getBoolPref
"
PREF_APP_UPDATE_ENABLED
true
)
)
document
.
getElementById
(
"
noUpdatesAutoEnabled
"
)
.
hidden
=
false
;
else
document
.
getElementById
(
"
noUpdatesAutoDisabled
"
)
.
hidden
=
false
;
gUpdates
.
setButtons
(
null
null
"
okButton
"
true
)
;
gUpdates
.
wiz
.
getButton
(
"
finish
"
)
.
focus
(
)
;
}
}
;
var
gManualUpdatePage
=
{
onPageShow
(
)
{
var
manualURL
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_APP_UPDATE_URL_MANUAL
)
;
var
manualUpdateLinkLabel
=
document
.
getElementById
(
"
manualUpdateLinkLabel
"
)
;
manualUpdateLinkLabel
.
value
=
manualURL
;
manualUpdateLinkLabel
.
setAttribute
(
"
url
"
manualURL
)
;
gUpdates
.
setButtons
(
null
null
"
okButton
"
true
)
;
gUpdates
.
wiz
.
getButton
(
"
finish
"
)
.
focus
(
)
;
}
}
;
var
gUnsupportedPage
=
{
onPageShow
(
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_NOTIFIEDUNSUPPORTED
true
)
;
if
(
gUpdates
.
update
.
detailsURL
)
{
let
unsupportedLinkLabel
=
document
.
getElementById
(
"
unsupportedLinkLabel
"
)
;
unsupportedLinkLabel
.
setAttribute
(
"
url
"
gUpdates
.
update
.
detailsURL
)
;
}
gUpdates
.
setButtons
(
null
null
"
okButton
"
true
)
;
gUpdates
.
wiz
.
getButton
(
"
finish
"
)
.
focus
(
)
;
}
}
;
var
gUpdatesFoundBasicPage
=
{
onPageShow
(
)
{
gUpdates
.
wiz
.
canRewind
=
false
;
var
update
=
gUpdates
.
update
;
gUpdates
.
setButtons
(
"
askLaterButton
"
null
"
updateButton_
"
+
update
.
type
true
)
;
var
btn
=
gUpdates
.
wiz
.
getButton
(
"
next
"
)
;
btn
.
focus
(
)
;
var
updateName
=
update
.
name
;
if
(
update
.
channel
=
=
"
nightly
"
)
{
updateName
=
gUpdates
.
getAUSString
(
"
updateNightlyName
"
[
gUpdates
.
brandName
update
.
displayVersion
update
.
buildID
]
)
;
}
var
updateNameElement
=
document
.
getElementById
(
"
updateName
"
)
;
updateNameElement
.
value
=
updateName
;
var
introText
=
gUpdates
.
getAUSString
(
"
intro_
"
+
update
.
type
[
gUpdates
.
brandName
update
.
displayVersion
]
)
;
var
introElem
=
document
.
getElementById
(
"
updatesFoundInto
"
)
;
introElem
.
setAttribute
(
"
severity
"
update
.
type
)
;
introElem
.
textContent
=
introText
;
var
updateMoreInfoURL
=
document
.
getElementById
(
"
updateMoreInfoURL
"
)
;
if
(
update
.
detailsURL
)
updateMoreInfoURL
.
setAttribute
(
"
url
"
update
.
detailsURL
)
;
else
updateMoreInfoURL
.
hidden
=
true
;
var
updateTitle
=
gUpdates
.
getAUSString
(
"
updatesfound_
"
+
update
.
type
+
"
.
title
"
)
;
document
.
getElementById
(
"
updatesFoundBasicHeader
"
)
.
setAttribute
(
"
label
"
updateTitle
)
;
}
onExtra1
(
)
{
gUpdates
.
wiz
.
cancel
(
)
;
}
}
;
var
gDownloadingPage
=
{
_downloadStatus
:
null
_downloadProgress
:
null
_pauseButton
:
null
_paused
:
false
_label_downloadStatus
:
null
_lastSec
:
Infinity
_startTime
:
null
_pausedStatus
:
"
"
_hiding
:
false
_updateApplyingObserver
:
false
onPageShow
(
)
{
this
.
_downloadStatus
=
document
.
getElementById
(
"
downloadStatus
"
)
;
this
.
_downloadProgress
=
document
.
getElementById
(
"
downloadProgress
"
)
;
this
.
_pauseButton
=
document
.
getElementById
(
"
pauseButton
"
)
;
this
.
_label_downloadStatus
=
this
.
_downloadStatus
.
textContent
;
this
.
_pauseButton
.
setAttribute
(
"
tooltiptext
"
gUpdates
.
getAUSString
(
"
pauseButtonPause
"
)
)
;
this
.
_pauseButton
.
focus
(
)
;
this
.
_pauseButton
.
disabled
=
true
;
var
aus
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
CoI
.
nsIApplicationUpdateService
)
;
var
um
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
CoI
.
nsIUpdateManager
)
;
var
activeUpdate
=
um
.
activeUpdate
;
if
(
activeUpdate
)
{
gUpdates
.
setUpdate
(
activeUpdate
)
;
if
(
activeUpdate
.
state
=
=
STATE_PENDING
|
|
activeUpdate
.
state
=
=
STATE_PENDING_ELEVATE
|
|
activeUpdate
.
state
=
=
STATE_PENDING_SERVICE
)
{
if
(
!
activeUpdate
.
getProperty
(
"
stagingFailed
"
)
)
{
gUpdates
.
setButtons
(
"
hideButton
"
null
null
false
)
;
gUpdates
.
wiz
.
getButton
(
"
extra1
"
)
.
focus
(
)
;
this
.
_setUpdateApplying
(
)
;
return
;
}
gUpdates
.
wiz
.
goTo
(
"
finished
"
)
;
return
;
}
}
if
(
!
gUpdates
.
update
)
{
LOG
(
"
gDownloadingPage
"
"
onPageShow
-
no
valid
update
to
download
?
!
"
)
;
return
;
}
this
.
_startTime
=
Date
.
now
(
)
;
try
{
gUpdates
.
update
.
QueryInterface
(
CoI
.
nsIWritablePropertyBag
)
;
gUpdates
.
update
.
setProperty
(
"
foregroundDownload
"
"
true
"
)
;
aus
.
pauseDownload
(
)
;
var
state
=
aus
.
downloadUpdate
(
gUpdates
.
update
false
)
;
if
(
state
=
=
"
failed
"
)
{
this
.
cleanUp
(
)
;
gUpdates
.
wiz
.
goTo
(
"
errors
"
)
;
return
;
}
aus
.
addDownloadListener
(
this
)
;
if
(
activeUpdate
)
this
.
_setUIState
(
!
aus
.
isDownloading
)
;
}
catch
(
e
)
{
LOG
(
"
gDownloadingPage
"
"
onPageShow
-
error
:
"
+
e
)
;
}
gUpdates
.
setButtons
(
"
hideButton
"
null
null
false
)
;
gUpdates
.
wiz
.
getButton
(
"
extra1
"
)
.
focus
(
)
;
}
_setStatus
(
status
)
{
if
(
this
.
_downloadStatus
.
textContent
=
=
status
)
return
;
while
(
this
.
_downloadStatus
.
hasChildNodes
(
)
)
this
.
_downloadStatus
.
firstChild
.
remove
(
)
;
this
.
_downloadStatus
.
appendChild
(
document
.
createTextNode
(
status
)
)
;
}
_updateDownloadStatus
(
aCurr
aMax
)
{
let
status
;
let
rate
=
aCurr
/
(
Date
.
now
(
)
-
this
.
_startTime
)
*
1000
;
[
status
this
.
_lastSec
]
=
DownloadUtils
.
getDownloadStatus
(
aCurr
aMax
rate
this
.
_lastSec
)
;
this
.
_pausedStatus
=
DownloadUtils
.
getTransferTotal
(
aCurr
aMax
)
;
return
status
;
}
_setUIState
(
paused
)
{
var
u
=
gUpdates
.
update
;
if
(
paused
)
{
if
(
this
.
_downloadProgress
.
mode
!
=
"
normal
"
)
this
.
_downloadProgress
.
mode
=
"
normal
"
;
this
.
_pauseButton
.
setAttribute
(
"
tooltiptext
"
gUpdates
.
getAUSString
(
"
pauseButtonResume
"
)
)
;
this
.
_pauseButton
.
setAttribute
(
"
paused
"
"
true
"
)
;
var
p
=
u
.
selectedPatch
.
QueryInterface
(
CoI
.
nsIPropertyBag
)
;
var
status
=
p
.
getProperty
(
"
status
"
)
;
if
(
status
)
{
let
pausedStatus
=
gUpdates
.
getAUSString
(
"
downloadPausedStatus
"
[
status
]
)
;
this
.
_setStatus
(
pausedStatus
)
;
}
}
else
{
if
(
this
.
_downloadProgress
.
mode
!
=
"
undetermined
"
)
this
.
_downloadProgress
.
mode
=
"
undetermined
"
;
this
.
_pauseButton
.
setAttribute
(
"
paused
"
"
false
"
)
;
this
.
_pauseButton
.
setAttribute
(
"
tooltiptext
"
gUpdates
.
getAUSString
(
"
pauseButtonPause
"
)
)
;
this
.
_setStatus
(
this
.
_label_downloadStatus
)
;
}
}
_setUpdateApplying
(
)
{
this
.
_downloadProgress
.
mode
=
"
undetermined
"
;
this
.
_pauseButton
.
hidden
=
true
;
let
applyingStatus
=
gUpdates
.
getAUSString
(
"
applyingUpdate
"
)
;
this
.
_setStatus
(
applyingStatus
)
;
Services
.
obs
.
addObserver
(
this
"
update
-
staged
"
)
;
this
.
_updateApplyingObserver
=
true
;
}
cleanUp
(
)
{
var
aus
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
CoI
.
nsIApplicationUpdateService
)
;
aus
.
removeDownloadListener
(
this
)
;
if
(
this
.
_updateApplyingObserver
)
{
Services
.
obs
.
removeObserver
(
this
"
update
-
staged
"
)
;
this
.
_updateApplyingObserver
=
false
;
}
}
onPause
(
)
{
var
aus
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
CoI
.
nsIApplicationUpdateService
)
;
if
(
this
.
_paused
)
aus
.
downloadUpdate
(
gUpdates
.
update
false
)
;
else
{
var
patch
=
gUpdates
.
update
.
selectedPatch
;
patch
.
QueryInterface
(
CoI
.
nsIWritablePropertyBag
)
;
patch
.
setProperty
(
"
status
"
this
.
_pausedStatus
)
;
aus
.
pauseDownload
(
)
;
}
this
.
_paused
=
!
this
.
_paused
;
this
.
_setUIState
(
this
.
_paused
)
;
}
onWizardCancel
(
)
{
if
(
this
.
_hiding
)
return
;
this
.
cleanUp
(
)
;
}
onHide
(
)
{
this
.
_hiding
=
true
;
this
.
cleanUp
(
)
;
var
aus
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
CoI
.
nsIApplicationUpdateService
)
;
var
um
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
CoI
.
nsIUpdateManager
)
;
um
.
activeUpdate
=
gUpdates
.
update
;
var
downloadInBackground
=
true
;
if
(
this
.
_paused
)
{
var
title
=
gUpdates
.
getAUSString
(
"
resumePausedAfterCloseTitle
"
)
;
var
message
=
gUpdates
.
getAUSString
(
"
resumePausedAfterCloseMsg
"
[
gUpdates
.
brandName
]
)
;
var
ps
=
Services
.
prompt
;
var
flags
=
ps
.
STD_YES_NO_BUTTONS
;
window
.
focus
(
)
;
var
rv
=
ps
.
confirmEx
(
window
title
message
flags
null
null
null
null
{
}
)
;
if
(
rv
=
=
CoI
.
nsIPromptService
.
BUTTON_POS_0
)
downloadInBackground
=
false
;
}
if
(
downloadInBackground
)
{
LOG
(
"
gDownloadingPage
"
"
onHide
-
continuing
download
in
background
"
+
"
at
full
speed
"
)
;
aus
.
downloadUpdate
(
gUpdates
.
update
false
)
;
}
gUpdates
.
wiz
.
cancel
(
)
;
}
onStartRequest
(
request
context
)
{
if
(
this
.
_paused
)
return
;
if
(
this
.
_downloadProgress
.
mode
!
=
"
undetermined
"
)
this
.
_downloadProgress
.
mode
=
"
undetermined
"
;
this
.
_setStatus
(
this
.
_label_downloadStatus
)
;
}
onProgress
(
request
context
progress
maxProgress
)
{
let
status
=
this
.
_updateDownloadStatus
(
progress
maxProgress
)
;
var
currentProgress
=
Math
.
round
(
100
*
(
progress
/
maxProgress
)
)
;
var
p
=
gUpdates
.
update
.
selectedPatch
;
p
.
QueryInterface
(
CoI
.
nsIWritablePropertyBag
)
;
p
.
setProperty
(
"
progress
"
currentProgress
)
;
p
.
setProperty
(
"
status
"
status
)
;
if
(
this
.
_paused
)
return
;
if
(
this
.
_downloadProgress
.
mode
!
=
"
normal
"
)
this
.
_downloadProgress
.
mode
=
"
normal
"
;
if
(
this
.
_downloadProgress
.
value
!
=
currentProgress
)
this
.
_downloadProgress
.
value
=
currentProgress
;
if
(
this
.
_pauseButton
.
disabled
)
this
.
_pauseButton
.
disabled
=
false
;
if
(
progress
=
=
maxProgress
&
&
this
.
_downloadStatus
.
textContent
=
=
this
.
_label_downloadStatus
)
return
;
this
.
_setStatus
(
status
)
;
}
onStatus
(
request
context
status
statusText
)
{
this
.
_setStatus
(
statusText
)
;
}
onStopRequest
(
request
context
status
)
{
if
(
this
.
_downloadProgress
.
mode
!
=
"
normal
"
)
this
.
_downloadProgress
.
mode
=
"
normal
"
;
var
u
=
gUpdates
.
update
;
switch
(
status
)
{
case
CoR
.
NS_ERROR_CORRUPTED_CONTENT
:
case
CoR
.
NS_ERROR_UNEXPECTED
:
if
(
u
.
selectedPatch
.
state
=
=
STATE_DOWNLOAD_FAILED
&
&
(
u
.
isCompleteUpdate
|
|
u
.
patchCount
!
=
2
)
)
{
this
.
cleanUp
(
)
;
gUpdates
.
wiz
.
goTo
(
"
errors
"
)
;
break
;
}
this
.
_downloadProgress
.
mode
=
"
undetermined
"
;
this
.
_pauseButton
.
disabled
=
true
;
document
.
getElementById
(
"
verificationFailed
"
)
.
hidden
=
false
;
break
;
case
CoR
.
NS_BINDING_ABORTED
:
LOG
(
"
gDownloadingPage
"
"
onStopRequest
-
pausing
download
"
)
;
break
;
case
CoR
.
NS_OK
:
LOG
(
"
gDownloadingPage
"
"
onStopRequest
-
patch
verification
succeeded
"
)
;
let
aus
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
CoI
.
nsIApplicationUpdateService
)
;
if
(
aus
.
canStageUpdates
)
{
this
.
_setUpdateApplying
(
)
;
}
else
{
this
.
cleanUp
(
)
;
gUpdates
.
wiz
.
goTo
(
"
finished
"
)
;
}
break
;
default
:
LOG
(
"
gDownloadingPage
"
"
onStopRequest
-
transfer
failed
"
)
;
this
.
cleanUp
(
)
;
gUpdates
.
wiz
.
goTo
(
"
errors
"
)
;
break
;
}
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
update
-
staged
"
)
{
if
(
aData
=
=
STATE_DOWNLOADING
)
{
this
.
_setStatus
(
"
downloading
"
)
;
return
;
}
this
.
cleanUp
(
)
;
if
(
aData
=
=
STATE_APPLIED
|
|
aData
=
=
STATE_APPLIED_SERVICE
|
|
aData
=
=
STATE_PENDING
|
|
aData
=
=
STATE_PENDING_SERVICE
|
|
aData
=
=
STATE_PENDING_ELEVATE
)
{
gUpdates
.
wiz
.
goTo
(
"
finished
"
)
;
}
else
{
gUpdates
.
wiz
.
goTo
(
"
errors
"
)
;
}
}
}
QueryInterface
(
iid
)
{
if
(
!
iid
.
equals
(
CoI
.
nsIRequestObserver
)
&
&
!
iid
.
equals
(
CoI
.
nsIProgressEventSink
)
&
&
!
iid
.
equals
(
CoI
.
nsIObserver
)
&
&
!
iid
.
equals
(
CoI
.
nsISupports
)
)
throw
CoR
.
NS_ERROR_NO_INTERFACE
;
return
this
;
}
}
;
var
gErrorsPage
=
{
onPageShow
(
)
{
gUpdates
.
setButtons
(
null
null
"
okButton
"
true
)
;
gUpdates
.
wiz
.
getButton
(
"
finish
"
)
.
focus
(
)
;
var
statusText
=
gUpdates
.
update
.
statusText
;
LOG
(
"
gErrorsPage
"
"
onPageShow
-
update
.
statusText
:
"
+
statusText
)
;
var
errorReason
=
document
.
getElementById
(
"
errorReason
"
)
;
errorReason
.
value
=
statusText
;
var
manualURL
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_APP_UPDATE_URL_MANUAL
)
;
var
errorLinkLabel
=
document
.
getElementById
(
"
errorLinkLabel
"
)
;
errorLinkLabel
.
value
=
manualURL
;
errorLinkLabel
.
setAttribute
(
"
url
"
manualURL
)
;
}
}
;
var
gErrorExtraPage
=
{
onPageShow
(
)
{
gUpdates
.
setButtons
(
null
null
"
okButton
"
true
)
;
gUpdates
.
wiz
.
getButton
(
"
finish
"
)
.
focus
(
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_BACKGROUNDERRORS
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_BACKGROUNDERRORS
)
;
}
document
.
getElementById
(
"
genericBackgroundErrorLabel
"
)
.
hidden
=
false
;
let
manualURL
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_APP_UPDATE_URL_MANUAL
)
;
let
errorLinkLabel
=
document
.
getElementById
(
"
errorExtraLinkLabel
"
)
;
errorLinkLabel
.
value
=
manualURL
;
errorLinkLabel
.
setAttribute
(
"
url
"
manualURL
)
;
}
}
;
var
gErrorPatchingPage
=
{
onPageShow
(
)
{
gUpdates
.
setButtons
(
null
null
"
okButton
"
true
)
;
}
onWizardNext
(
)
{
switch
(
gUpdates
.
update
.
selectedPatch
.
state
)
{
case
STATE_APPLIED
:
case
STATE_APPLIED_SERVICE
:
gUpdates
.
wiz
.
goTo
(
"
finished
"
)
;
break
;
case
STATE_PENDING
:
case
STATE_PENDING_SERVICE
:
let
aus
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
CoI
.
nsIApplicationUpdateService
)
;
if
(
!
aus
.
canStageUpdates
)
{
gUpdates
.
wiz
.
goTo
(
"
finished
"
)
;
break
;
}
case
STATE_DOWNLOADING
:
gUpdates
.
wiz
.
goTo
(
"
downloading
"
)
;
break
;
case
STATE_DOWNLOAD_FAILED
:
gUpdates
.
wiz
.
goTo
(
"
errors
"
)
;
break
;
}
}
}
;
var
gFinishedPage
=
{
onPageShow
(
)
{
let
aus
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
CoI
.
nsIApplicationUpdateService
)
;
if
(
aus
.
elevationRequired
)
{
LOG
(
"
gFinishedPage
"
"
elevationRequired
"
)
;
gUpdates
.
setButtons
(
"
restartLaterButton
"
"
noThanksButton
"
"
restartNowButton
"
true
)
;
}
else
{
LOG
(
"
gFinishedPage
"
"
not
elevationRequired
"
)
;
gUpdates
.
setButtons
(
"
restartLaterButton
"
null
"
restartNowButton
"
true
)
;
}
gUpdates
.
wiz
.
getButton
(
"
finish
"
)
.
focus
(
)
;
}
onPageShowBackground
(
)
{
this
.
onPageShow
(
)
;
let
updateFinishedName
=
document
.
getElementById
(
"
updateFinishedName
"
)
;
updateFinishedName
.
value
=
gUpdates
.
update
.
name
;
let
link
=
document
.
getElementById
(
"
finishedBackgroundLink
"
)
;
if
(
gUpdates
.
update
.
detailsURL
)
{
link
.
setAttribute
(
"
url
"
gUpdates
.
update
.
detailsURL
)
;
link
.
disabled
=
false
;
}
else
{
link
.
hidden
=
true
;
}
let
aus
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
CoI
.
nsIApplicationUpdateService
)
;
if
(
aus
.
elevationRequired
)
{
let
more
=
document
.
getElementById
(
"
finishedBackgroundMore
"
)
;
more
.
setAttribute
(
"
hidden
"
"
true
"
)
;
let
moreElevated
=
document
.
getElementById
(
"
finishedBackgroundMoreElevated
"
)
;
moreElevated
.
setAttribute
(
"
hidden
"
"
false
"
)
;
let
moreElevatedLink
=
document
.
getElementById
(
"
finishedBackgroundMoreElevatedLink
"
)
;
moreElevatedLink
.
setAttribute
(
"
hidden
"
"
false
"
)
;
let
moreElevatedLinkLabel
=
document
.
getElementById
(
"
finishedBackgroundMoreElevatedLinkLabel
"
)
;
let
manualURL
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_APP_UPDATE_URL_MANUAL
)
;
moreElevatedLinkLabel
.
value
=
manualURL
;
moreElevatedLinkLabel
.
setAttribute
(
"
url
"
manualURL
)
;
moreElevatedLinkLabel
.
setAttribute
(
"
hidden
"
"
false
"
)
;
}
if
(
getPref
(
"
getBoolPref
"
PREF_APP_UPDATE_TEST_LOOP
false
)
)
{
setTimeout
(
function
(
)
{
gUpdates
.
wiz
.
getButton
(
"
finish
"
)
.
click
(
)
;
}
UPDATE_TEST_LOOP_INTERVAL
)
;
}
}
onWizardFinish
(
)
{
LOG
(
"
gFinishedPage
"
"
onWizardFinish
-
restarting
the
application
"
)
;
let
aus
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
CoI
.
nsIApplicationUpdateService
)
;
if
(
aus
.
elevationRequired
)
{
let
um
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
CoI
.
nsIUpdateManager
)
;
if
(
um
)
{
um
.
elevationOptedIn
(
)
;
}
}
gUpdates
.
wiz
.
getButton
(
"
finish
"
)
.
disabled
=
true
;
gUpdates
.
wiz
.
getButton
(
"
extra1
"
)
.
disabled
=
true
;
var
cancelQuit
=
CoC
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
CoI
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
"
restart
"
)
;
if
(
cancelQuit
.
data
)
return
;
if
(
Services
.
appinfo
.
inSafeMode
)
{
let
env
=
CoC
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
CoI
.
nsIEnvironment
)
;
env
.
set
(
"
MOZ_SAFE_MODE_RESTART
"
"
1
"
)
;
}
Services
.
startup
.
quit
(
CoI
.
nsIAppStartup
.
eAttemptQuit
|
CoI
.
nsIAppStartup
.
eRestart
)
;
}
onExtra1
(
)
{
gUpdates
.
wiz
.
cancel
(
)
;
}
async
onExtra2
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
update
-
canceled
"
)
;
let
um
=
CoC
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
CoI
.
nsIUpdateManager
)
;
um
.
cleanupActiveUpdate
(
)
;
gUpdates
.
never
(
)
;
gUpdates
.
wiz
.
cancel
(
)
;
}
}
;
function
setCurrentPage
(
pageid
)
{
gUpdates
.
wiz
.
currentPage
=
document
.
getElementById
(
pageid
)
;
}
