"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BackgroundUpdate
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
BackgroundTasksUtils
:
"
resource
:
/
/
gre
/
modules
/
BackgroundTasksUtils
.
jsm
"
BackgroundTasksManager
:
"
resource
:
/
/
gre
/
modules
/
BackgroundTasksManager
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
TaskScheduler
:
"
resource
:
/
/
gre
/
modules
/
TaskScheduler
.
jsm
"
UpdateUtils
:
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
let
consoleOptions
=
{
maxLogLevel
:
"
error
"
maxLogLevelPref
:
"
app
.
update
.
background
.
loglevel
"
prefix
:
"
BackgroundUpdate
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
localization
"
(
)
=
>
{
return
new
Localization
(
[
"
branding
/
brand
.
ftl
"
"
toolkit
/
updates
/
backgroundupdate
.
ftl
"
]
true
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
UpdateService
"
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
"
nsIApplicationUpdateService
"
)
;
const
TASK_DEF_CURRENT_VERSION
=
3
;
const
TASK_INSTALLED_VERSION_PREF
=
"
app
.
update
.
background
.
lastInstalledTaskVersion
"
;
var
BackgroundUpdate
=
{
_initialized
:
false
get
taskId
(
)
{
let
taskId
=
"
backgroundupdate
"
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
taskId
=
{
AppConstants
.
MOZ_APP_DISPLAYNAME_DO_NOT_USE
}
Background
Update
;
}
return
taskId
;
}
async
_hasOmnijar
(
)
{
const
appOmniJar
=
FileUtils
.
getFile
(
"
XCurProcD
"
[
AppConstants
.
OMNIJAR_NAME
]
)
;
const
greOmniJar
=
FileUtils
.
getFile
(
"
GreD
"
[
AppConstants
.
OMNIJAR_NAME
]
)
;
let
bothExist
=
(
await
IOUtils
.
exists
(
appOmniJar
.
path
)
)
&
&
(
await
IOUtils
.
exists
(
greOmniJar
.
path
)
)
;
return
bothExist
;
}
_force
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
app
.
update
.
background
.
force
"
false
)
;
}
async
_reasonsToNotUpdateInstallation
(
)
{
let
SLUG
=
"
_reasonsToNotUpdateInstallation
"
;
let
reasons
=
[
]
;
log
.
debug
(
{
SLUG
}
:
checking
app
.
update
.
auto
)
;
let
updateAuto
=
await
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
if
(
!
updateAuto
)
{
reasons
.
push
(
this
.
REASON
.
NO_APP_UPDATE_AUTO
)
;
}
log
.
debug
(
{
SLUG
}
:
checking
app
.
update
.
background
.
enabled
)
;
let
updateBackground
=
await
UpdateUtils
.
readUpdateConfigSetting
(
"
app
.
update
.
background
.
enabled
"
)
;
if
(
!
updateBackground
)
{
reasons
.
push
(
this
.
REASON
.
NO_APP_UPDATE_BACKGROUND_ENABLED
)
;
}
const
bts
=
"
mozilla
.
org
/
backgroundtasks
;
1
"
in
Cc
&
&
Cc
[
"
mozilla
.
org
/
backgroundtasks
;
1
"
]
.
getService
(
Ci
.
nsIBackgroundTasks
)
;
log
.
debug
(
{
SLUG
}
:
checking
for
MOZ_BACKGROUNDTASKS
)
;
if
(
!
AppConstants
.
MOZ_BACKGROUNDTASKS
|
|
!
bts
)
{
reasons
.
push
(
this
.
REASON
.
NO_MOZ_BACKGROUNDTASKS
)
;
}
let
updateService
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
Ci
.
nsIApplicationUpdateService
)
;
log
.
debug
(
{
SLUG
}
:
checking
that
updates
are
not
disabled
by
policy
testing
+
configuration
or
abnormal
runtime
environment
)
;
if
(
!
updateService
.
canUsuallyCheckForUpdates
)
{
reasons
.
push
(
this
.
REASON
.
CANNOT_USUALLY_CHECK
)
;
}
log
.
debug
(
{
SLUG
}
:
checking
that
we
can
make
progress
:
updates
can
stage
and
/
or
apply
)
;
if
(
!
updateService
.
canUsuallyStageUpdates
&
&
!
updateService
.
canUsuallyApplyUpdates
)
{
reasons
.
push
(
this
.
REASON
.
CANNOT_USUALLY_STAGE_AND_CANNOT_USUALLY_APPLY
)
;
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
if
(
!
updateService
.
canUsuallyUseBits
)
{
reasons
.
push
(
this
.
REASON
.
WINDOWS_CANNOT_USUALLY_USE_BITS
)
;
}
}
log
.
debug
(
{
SLUG
}
:
checking
that
this
installation
has
an
omnijar
)
;
if
(
!
(
await
this
.
_hasOmnijar
(
)
)
)
{
reasons
.
push
(
this
.
REASON
.
NO_OMNIJAR
)
;
}
if
(
updateService
.
manualUpdateOnly
)
{
reasons
.
push
(
this
.
REASON
.
MANUAL_UPDATE_ONLY
)
;
}
return
reasons
;
}
async
_reasonsToNotScheduleUpdates
(
)
{
let
SLUG
=
"
_reasonsToNotScheduleUpdates
"
;
let
reasons
=
[
]
;
const
bts
=
"
mozilla
.
org
/
backgroundtasks
;
1
"
in
Cc
&
&
Cc
[
"
mozilla
.
org
/
backgroundtasks
;
1
"
]
.
getService
(
Ci
.
nsIBackgroundTasks
)
;
if
(
bts
&
&
bts
.
isBackgroundTaskMode
)
{
throw
new
Components
.
Exception
(
Not
available
in
-
-
backgroundtask
mode
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
if
(
!
BackgroundTasksUtils
.
hasDefaultProfile
(
)
)
{
reasons
.
push
(
this
.
REASON
.
NO_DEFAULT_PROFILE_EXISTS
)
;
}
if
(
!
BackgroundTasksUtils
.
currentProfileIsDefaultProfile
(
)
)
{
reasons
.
push
(
this
.
REASON
.
NOT_DEFAULT_PROFILE
)
;
}
log
.
debug
(
{
SLUG
}
:
checking
app
.
update
.
langpack
.
enabled
)
;
let
updateLangpack
=
Services
.
prefs
.
getBoolPref
(
"
app
.
update
.
langpack
.
enabled
"
true
)
;
if
(
updateLangpack
)
{
log
.
debug
(
{
SLUG
}
:
app
.
update
.
langpack
.
enabled
=
true
checking
that
no
langpacks
are
installed
)
;
let
langpacks
=
await
AddonManager
.
getAddonsByTypes
(
[
"
locale
"
]
)
;
log
.
debug
(
{
langpacks
.
length
}
langpacks
installed
)
;
if
(
langpacks
.
length
)
{
reasons
.
push
(
this
.
REASON
.
LANGPACK_INSTALLED
)
;
}
}
let
serviceRegKeyExists
;
try
{
serviceRegKeyExists
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
processor
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdateProcessor
)
.
getServiceRegKeyExists
(
)
;
}
catch
(
ex
)
{
log
.
error
(
{
SLUG
}
:
Failed
to
check
for
Maintenance
Service
Registry
Key
:
{
ex
}
)
;
serviceRegKeyExists
=
false
;
}
if
(
!
serviceRegKeyExists
)
{
reasons
.
push
(
this
.
REASON
.
SERVICE_REGISTRY_KEY_MISSING
)
;
}
return
reasons
;
}
async
_registerBackgroundUpdateTask
(
taskId
=
this
.
taskId
)
{
let
binary
=
Services
.
dirsvc
.
get
(
"
XREExeF
"
Ci
.
nsIFile
)
;
let
args
=
[
"
-
-
MOZ_LOG
"
"
sync
prependheader
timestamp
append
maxsize
:
1
Dump
:
5
"
"
-
-
MOZ_LOG_FILE
"
FileUtils
.
getFile
(
"
UpdRootD
"
[
"
backgroundupdate
.
moz_log
"
]
)
.
path
"
-
-
backgroundtask
"
"
backgroundupdate
"
]
;
let
workingDirectory
=
FileUtils
.
getDir
(
"
UpdRootD
"
[
]
true
)
.
path
;
let
description
=
await
localization
.
formatValue
(
"
backgroundupdate
-
task
-
description
"
)
;
let
executionTimeoutSec
=
20
*
60
;
let
result
=
await
TaskScheduler
.
registerTask
(
taskId
binary
.
path
Services
.
prefs
.
getIntPref
(
"
app
.
update
.
background
.
interval
"
60
*
60
*
7
)
{
workingDirectory
args
description
executionTimeoutSec
}
)
;
Services
.
prefs
.
setIntPref
(
TASK_INSTALLED_VERSION_PREF
TASK_DEF_CURRENT_VERSION
)
;
return
result
;
}
async
ensureExperimentToRolloutTransitionPerformed
(
)
{
if
(
!
UpdateUtils
.
PER_INSTALLATION_PREFS_SUPPORTED
)
{
return
;
}
const
transitionPerformedPref
=
"
app
.
update
.
background
.
rolledout
"
;
if
(
Services
.
prefs
.
getBoolPref
(
transitionPerformedPref
false
)
)
{
return
;
}
Services
.
prefs
.
setBoolPref
(
transitionPerformedPref
true
)
;
const
defaultValue
=
UpdateUtils
.
PER_INSTALLATION_PREFS
[
"
app
.
update
.
background
.
enabled
"
]
.
defaultValue
;
await
UpdateUtils
.
writeUpdateConfigSetting
(
"
app
.
update
.
background
.
enabled
"
defaultValue
{
setDefaultOnly
:
true
}
)
;
Services
.
prefs
.
clearUserPref
(
"
app
.
update
.
background
.
scheduling
.
enabled
"
)
;
}
async
observe
(
subject
topic
data
)
{
let
whatChanged
;
switch
(
topic
)
{
case
"
nsPref
:
changed
"
:
whatChanged
=
per
-
profile
pref
{
data
}
;
break
;
case
"
auto
-
update
-
config
-
change
"
:
whatChanged
=
per
-
installation
pref
app
.
update
.
auto
;
break
;
case
"
background
-
update
-
config
-
change
"
:
whatChanged
=
per
-
installation
pref
app
.
update
.
background
.
enabled
;
break
;
}
log
.
debug
(
observe
:
{
whatChanged
}
may
have
changed
;
invoking
maybeScheduleBackgroundUpdateTask
)
;
return
this
.
maybeScheduleBackgroundUpdateTask
(
)
;
}
async
maybeScheduleBackgroundUpdateTask
(
)
{
let
SLUG
=
"
maybeScheduleBackgroundUpdateTask
"
;
await
this
.
ensureExperimentToRolloutTransitionPerformed
(
)
;
log
.
info
(
{
SLUG
}
:
checking
eligibility
before
scheduling
background
update
task
)
;
let
previousEnabled
;
let
successfullyReadPrevious
;
try
{
previousEnabled
=
await
TaskScheduler
.
taskExists
(
this
.
taskId
)
;
successfullyReadPrevious
=
true
;
}
catch
(
ex
)
{
successfullyReadPrevious
=
false
;
}
const
previousReasons
=
Services
.
prefs
.
getCharPref
(
"
app
.
update
.
background
.
previous
.
reasons
"
null
)
;
if
(
!
this
.
_initialized
)
{
Services
.
obs
.
addObserver
(
this
"
auto
-
update
-
config
-
change
"
)
;
Services
.
obs
.
addObserver
(
this
"
background
-
update
-
config
-
change
"
)
;
Services
.
prefs
.
addObserver
(
"
app
.
update
.
background
.
force
"
this
)
;
Services
.
prefs
.
addObserver
(
"
app
.
update
.
background
.
interval
"
this
)
;
Services
.
prefs
.
addObserver
(
"
app
.
update
.
langpack
.
enabled
"
this
)
;
const
onAddonEvent
=
async
addon
=
>
{
if
(
addon
.
type
!
=
"
locale
"
)
{
return
;
}
log
.
debug
(
{
SLUG
}
:
langpacks
may
have
changed
;
invoking
maybeScheduleBackgroundUpdateTask
)
;
this
.
maybeScheduleBackgroundUpdateTask
(
)
;
}
;
const
addonsListener
=
{
onEnabled
:
onAddonEvent
onDisabled
:
onAddonEvent
onInstalled
:
onAddonEvent
onUninstalled
:
onAddonEvent
}
;
AddonManager
.
addAddonListener
(
addonsListener
)
;
this
.
_initialized
=
true
;
}
log
.
debug
(
{
SLUG
}
:
checking
for
reasons
to
not
update
this
installation
)
;
let
reasons
=
await
this
.
_reasonsToNotUpdateInstallation
(
)
;
log
.
debug
(
{
SLUG
}
:
checking
for
reasons
to
not
schedule
background
updates
with
this
profile
)
;
let
moreReasons
=
await
this
.
_reasonsToNotScheduleUpdates
(
)
;
reasons
.
push
(
.
.
.
moreReasons
)
;
let
enabled
=
!
reasons
.
length
;
if
(
this
.
_force
(
)
)
{
log
.
debug
(
{
SLUG
}
:
app
.
update
.
background
.
force
=
true
ignoring
reasons
:
{
JSON
.
stringify
(
reasons
)
}
)
;
reasons
=
[
]
;
enabled
=
true
;
}
let
updatePreviousPrefs
=
(
)
=
>
{
if
(
reasons
.
length
)
{
Services
.
prefs
.
setCharPref
(
"
app
.
update
.
background
.
previous
.
reasons
"
JSON
.
stringify
(
reasons
)
)
;
}
else
{
Services
.
prefs
.
clearUserPref
(
"
app
.
update
.
background
.
previous
.
reasons
"
)
;
}
}
;
try
{
if
(
!
enabled
)
{
log
.
info
(
{
SLUG
}
:
not
scheduling
background
update
:
'
{
JSON
.
stringify
(
reasons
)
}
'
)
;
if
(
!
successfullyReadPrevious
|
|
previousEnabled
)
{
await
TaskScheduler
.
deleteTask
(
this
.
taskId
)
;
log
.
debug
(
{
SLUG
}
:
witnessed
falling
(
enabled
-
>
disabled
)
edge
;
deleted
task
{
this
.
taskId
}
.
)
;
}
updatePreviousPrefs
(
)
;
return
false
;
}
if
(
successfullyReadPrevious
&
&
previousEnabled
)
{
let
taskInstalledVersion
=
Services
.
prefs
.
getIntPref
(
TASK_INSTALLED_VERSION_PREF
1
)
;
if
(
taskInstalledVersion
=
=
TASK_DEF_CURRENT_VERSION
)
{
log
.
info
(
{
SLUG
}
:
background
update
was
previously
enabled
;
not
registering
task
.
)
;
return
true
;
}
log
.
info
(
{
SLUG
}
:
Detected
task
version
change
from
+
{
taskInstalledVersion
}
to
{
TASK_DEF_CURRENT_VERSION
}
.
+
Removing
task
so
the
new
version
can
be
registered
)
;
try
{
await
TaskScheduler
.
deleteTask
(
this
.
taskId
)
;
}
catch
(
e
)
{
log
.
error
(
{
SLUG
}
:
Error
removing
old
task
:
{
e
}
)
;
}
try
{
let
oldUpdateDir
=
FileUtils
.
getDir
(
"
OldUpdRootD
"
[
]
false
)
;
let
oldLog
=
oldUpdateDir
.
clone
(
)
;
oldLog
.
append
(
"
backgroundupdate
.
moz_log
"
)
;
if
(
oldLog
.
exists
(
)
)
{
oldLog
.
remove
(
false
)
;
oldUpdateDir
.
remove
(
false
)
;
oldUpdateDir
.
parent
.
remove
(
false
)
;
oldUpdateDir
.
parent
.
parent
.
remove
(
false
)
;
}
}
catch
(
ex
)
{
log
.
warn
(
{
SLUG
}
:
Ignoring
error
encountered
attempting
to
remove
stale
log
file
:
{
ex
}
)
;
}
}
log
.
info
(
{
SLUG
}
:
background
update
was
previously
disabled
for
reasons
:
'
{
previousReasons
}
'
)
;
await
this
.
_registerBackgroundUpdateTask
(
this
.
taskId
)
;
log
.
info
(
{
SLUG
}
:
witnessed
rising
(
disabled
-
>
enabled
)
edge
;
registered
task
{
this
.
taskId
}
)
;
updatePreviousPrefs
(
)
;
return
true
;
}
catch
(
e
)
{
log
.
error
(
{
SLUG
}
:
exiting
after
uncaught
exception
in
maybeScheduleBackgroundUpdateTask
!
e
)
;
return
false
;
}
}
async
recordUpdateEnvironment
(
)
{
try
{
Glean
.
update
.
serviceEnabled
.
set
(
Services
.
prefs
.
getBoolPref
(
"
app
.
update
.
service
.
enabled
"
false
)
)
;
}
catch
(
e
)
{
}
Glean
.
update
.
autoDownload
.
set
(
await
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
)
;
Glean
.
update
.
backgroundUpdate
.
set
(
await
UpdateUtils
.
readUpdateConfigSetting
(
"
app
.
update
.
background
.
enabled
"
)
)
;
Glean
.
update
.
channel
.
set
(
UpdateUtils
.
UpdateChannel
)
;
Glean
.
update
.
enabled
.
set
(
!
Services
.
policies
|
|
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
)
;
Glean
.
update
.
canUsuallyApplyUpdates
.
set
(
UpdateService
.
canUsuallyApplyUpdates
)
;
Glean
.
update
.
canUsuallyCheckForUpdates
.
set
(
UpdateService
.
canUsuallyCheckForUpdates
)
;
Glean
.
update
.
canUsuallyStageUpdates
.
set
(
UpdateService
.
canUsuallyStageUpdates
)
;
Glean
.
update
.
canUsuallyUseBits
.
set
(
UpdateService
.
canUsuallyUseBits
)
;
}
}
;
BackgroundUpdate
.
REASON
=
{
CANNOT_USUALLY_CHECK
:
"
cannot
usually
check
for
updates
due
to
policy
testing
configuration
or
runtime
environment
"
CANNOT_USUALLY_STAGE_AND_CANNOT_USUALLY_APPLY
:
"
updates
cannot
usually
stage
and
cannot
usually
apply
"
LANGPACK_INSTALLED
:
"
app
.
update
.
langpack
.
enabled
=
true
and
at
least
one
langpack
is
installed
"
MANUAL_UPDATE_ONLY
:
"
the
ManualAppUpdateOnly
policy
is
enabled
"
NO_DEFAULT_PROFILE_EXISTS
:
"
no
default
profile
exists
"
NOT_DEFAULT_PROFILE
:
"
not
default
profile
"
NO_APP_UPDATE_AUTO
:
"
app
.
update
.
auto
=
false
"
NO_APP_UPDATE_BACKGROUND_ENABLED
:
"
app
.
update
.
background
.
enabled
=
false
"
NO_MOZ_BACKGROUNDTASKS
:
"
MOZ_BACKGROUNDTASKS
=
0
"
NO_OMNIJAR
:
"
no
omnijar
"
SERVICE_REGISTRY_KEY_MISSING
:
"
the
maintenance
service
registry
key
is
not
present
"
WINDOWS_CANNOT_USUALLY_USE_BITS
:
"
on
Windows
but
cannot
usually
use
BITS
"
}
;
BackgroundUpdate
.
EXIT_CODE
=
{
.
.
.
BackgroundTasksManager
.
EXIT_CODE
DEFAULT_PROFILE_DOES_NOT_EXIST
:
11
DEFAULT_PROFILE_CANNOT_BE_LOCKED
:
12
DEFAULT_PROFILE_CANNOT_BE_READ
:
13
OTHER_INSTANCE
:
21
}
;
