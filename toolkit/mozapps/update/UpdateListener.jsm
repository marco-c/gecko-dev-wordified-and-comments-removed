"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UpdateListener
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
clearTimeout
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppMenuNotifications
"
"
resource
:
/
/
gre
/
modules
/
AppMenuNotifications
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
AppUpdateService
"
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
"
nsIApplicationUpdateService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
UpdateManager
"
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
"
nsIUpdateManager
"
)
;
const
PREF_APP_UPDATE_UNSUPPORTED_URL
=
"
app
.
update
.
unsupported
.
url
"
;
const
PREF_APP_UPDATE_SUPPRESS_PROMPTS
=
"
app
.
update
.
suppressPrompts
"
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
SUPPRESS_PROMPTS
"
PREF_APP_UPDATE_SUPPRESS_PROMPTS
false
)
;
var
UpdateListener
=
{
timeouts
:
[
]
restartDoorhangerShown
:
false
updateFirstReadyTime
:
null
promptDelayMsFromBuild
:
14
*
24
*
60
*
60
*
1000
promptDelayMsFromUpdate
:
7
*
24
*
60
*
60
*
1000
promptMaxFutureVariation
:
24
*
60
*
60
*
1000
latestUpdate
:
null
availablePromptScheduled
:
false
get
badgeWaitTime
(
)
{
return
Services
.
prefs
.
getIntPref
(
"
app
.
update
.
badgeWaitTime
"
4
*
24
*
3600
)
;
}
get
suppressedPromptDelay
(
)
{
let
now
=
Date
.
now
(
)
;
let
buildId
=
AppConstants
.
MOZ_BUILDID
;
let
buildTime
=
new
Date
(
buildId
.
slice
(
0
4
)
buildId
.
slice
(
4
6
)
-
1
buildId
.
slice
(
6
8
)
buildId
.
slice
(
8
10
)
buildId
.
slice
(
10
12
)
buildId
.
slice
(
12
14
)
)
.
getTime
(
)
?
?
0
;
let
updateTime
=
UpdateManager
.
getUpdateAt
(
0
)
?
.
installDate
?
?
0
;
if
(
buildTime
-
now
>
this
.
promptMaxFutureVariation
)
{
buildTime
=
0
;
}
if
(
updateTime
-
now
>
this
.
promptMaxFutureVariation
)
{
updateTime
=
0
;
}
let
promptTime
=
now
;
if
(
updateTime
&
&
buildTime
)
{
promptTime
=
Math
.
min
(
buildTime
+
this
.
promptDelayMsFromBuild
updateTime
+
this
.
promptDelayMsFromUpdate
)
;
}
else
if
(
updateTime
|
|
buildTime
)
{
promptTime
=
(
updateTime
|
|
buildTime
)
+
this
.
promptDelayMsFromUpdate
;
}
return
promptTime
-
now
;
}
init
(
)
{
let
url
=
Services
.
prefs
.
getCharPref
(
PREF_APP_UPDATE_UNSUPPORTED_URL
null
)
;
if
(
url
)
{
this
.
showUpdateNotification
(
"
unsupported
"
true
true
win
=
>
this
.
openUnsupportedUpdateUrl
(
win
url
)
)
;
}
}
uninit
(
)
{
this
.
reset
(
)
;
}
reset
(
)
{
this
.
clearPendingAndActiveNotifications
(
)
;
this
.
restartDoorhangerShown
=
false
;
this
.
updateFirstReadyTime
=
null
;
}
clearPendingAndActiveNotifications
(
)
{
AppMenuNotifications
.
removeNotification
(
/
^
update
-
/
)
;
this
.
clearCallbacks
(
)
;
}
clearCallbacks
(
)
{
this
.
timeouts
.
forEach
(
t
=
>
clearTimeout
(
t
)
)
;
this
.
timeouts
=
[
]
;
this
.
availablePromptScheduled
=
false
;
}
addTimeout
(
time
callback
)
{
this
.
timeouts
.
push
(
setTimeout
(
(
)
=
>
{
this
.
clearCallbacks
(
)
;
callback
(
)
;
}
time
)
)
;
}
requestRestart
(
)
{
let
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
"
restart
"
)
;
if
(
!
cancelQuit
.
data
)
{
Services
.
startup
.
quit
(
Services
.
startup
.
eAttemptQuit
|
Services
.
startup
.
eRestart
)
;
}
}
openManualUpdateUrl
(
win
)
{
let
manualUpdateUrl
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
update
.
url
.
manual
"
)
;
win
.
openURL
(
manualUpdateUrl
)
;
}
openUnsupportedUpdateUrl
(
win
detailsURL
)
{
win
.
openURL
(
detailsURL
)
;
}
showUpdateNotification
(
type
mainActionDismiss
dismissed
mainAction
beforeShowDoorhanger
)
{
const
addTelemetry
=
id
=
>
{
if
(
type
!
=
=
"
downloading
"
)
{
let
telemetryType
=
type
.
replaceAll
(
"
-
"
"
"
)
;
Services
.
telemetry
.
getHistogramById
(
id
)
.
add
(
telemetryType
)
;
}
}
;
let
action
=
{
callback
(
win
fromDoorhanger
)
{
if
(
fromDoorhanger
)
{
addTelemetry
(
"
UPDATE_NOTIFICATION_MAIN_ACTION_DOORHANGER
"
)
;
}
else
{
addTelemetry
(
"
UPDATE_NOTIFICATION_MAIN_ACTION_MENU
"
)
;
}
mainAction
(
win
)
;
}
dismiss
:
mainActionDismiss
}
;
let
secondaryAction
=
{
callback
(
)
{
addTelemetry
(
"
UPDATE_NOTIFICATION_DISMISSED
"
)
;
}
dismiss
:
true
}
;
AppMenuNotifications
.
showNotification
(
"
update
-
"
+
type
action
secondaryAction
{
dismissed
beforeShowDoorhanger
}
)
;
if
(
dismissed
)
{
addTelemetry
(
"
UPDATE_NOTIFICATION_BADGE_SHOWN
"
)
;
}
else
{
addTelemetry
(
"
UPDATE_NOTIFICATION_SHOWN
"
)
;
}
}
showRestartNotification
(
update
dismissed
)
{
let
notification
=
AppUpdateService
.
isOtherInstanceHandlingUpdates
?
"
other
-
instance
"
:
"
restart
"
;
if
(
!
dismissed
)
{
this
.
restartDoorhangerShown
=
true
;
}
this
.
showUpdateNotification
(
notification
true
dismissed
(
)
=
>
this
.
requestRestart
(
)
)
;
}
showUpdateAvailableNotification
(
update
dismissed
)
{
this
.
showUpdateNotification
(
"
available
"
false
dismissed
(
)
=
>
{
AppUpdateService
.
downloadUpdate
(
update
true
)
;
}
)
;
}
showManualUpdateNotification
(
update
dismissed
)
{
this
.
showUpdateNotification
(
"
manual
"
false
dismissed
win
=
>
this
.
openManualUpdateUrl
(
win
)
)
;
}
showUnsupportedUpdateNotification
(
update
dismissed
)
{
if
(
!
update
|
|
!
update
.
detailsURL
)
{
Cu
.
reportError
(
"
The
update
for
an
unsupported
notification
must
have
a
"
+
"
detailsURL
attribute
.
"
)
;
return
;
}
let
url
=
update
.
detailsURL
;
if
(
url
!
=
Services
.
prefs
.
getCharPref
(
PREF_APP_UPDATE_UNSUPPORTED_URL
null
)
)
{
Services
.
prefs
.
setCharPref
(
PREF_APP_UPDATE_UNSUPPORTED_URL
url
)
;
this
.
showUpdateNotification
(
"
unsupported
"
true
dismissed
win
=
>
this
.
openUnsupportedUpdateUrl
(
win
url
)
)
;
}
}
showUpdateDownloadingNotification
(
)
{
this
.
showUpdateNotification
(
"
downloading
"
true
true
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
"
show
-
update
-
progress
"
)
;
}
)
;
}
scheduleUpdateAvailableNotification
(
update
)
{
this
.
showUpdateAvailableNotification
(
update
true
)
;
this
.
latestUpdate
=
update
;
if
(
!
this
.
availablePromptScheduled
)
{
this
.
addTimeout
(
Math
.
max
(
0
this
.
suppressedPromptDelay
)
(
)
=
>
{
if
(
UpdateManager
.
downloadingUpdate
|
|
UpdateManager
.
readyUpdate
)
{
return
;
}
this
.
showUpdateAvailableNotification
(
this
.
latestUpdate
false
)
;
}
)
;
this
.
availablePromptScheduled
=
true
;
}
}
handleUpdateError
(
update
status
)
{
switch
(
status
)
{
case
"
download
-
attempt
-
failed
"
:
this
.
clearCallbacks
(
)
;
this
.
showUpdateAvailableNotification
(
update
false
)
;
break
;
case
"
download
-
attempts
-
exceeded
"
:
this
.
clearCallbacks
(
)
;
this
.
showManualUpdateNotification
(
update
false
)
;
break
;
case
"
elevation
-
attempt
-
failed
"
:
this
.
clearCallbacks
(
)
;
this
.
showRestartNotification
(
false
)
;
break
;
case
"
elevation
-
attempts
-
exceeded
"
:
this
.
clearCallbacks
(
)
;
this
.
showManualUpdateNotification
(
update
false
)
;
break
;
case
"
check
-
attempts
-
exceeded
"
:
case
"
unknown
"
:
case
"
bad
-
perms
"
:
this
.
clearCallbacks
(
)
;
this
.
showManualUpdateNotification
(
update
false
)
;
break
;
}
}
handleUpdateStagedOrDownloaded
(
update
status
)
{
switch
(
status
)
{
case
"
applied
"
:
case
"
pending
"
:
case
"
applied
-
service
"
:
case
"
pending
-
service
"
:
case
"
pending
-
elevate
"
:
case
"
success
"
:
this
.
clearCallbacks
(
)
;
let
initialBadgeWaitTimeMs
=
this
.
badgeWaitTime
*
1000
;
let
initialDoorhangerWaitTimeMs
=
update
.
promptWaitTime
*
1000
;
let
now
=
Date
.
now
(
)
;
if
(
!
this
.
updateFirstReadyTime
)
{
this
.
updateFirstReadyTime
=
now
;
}
let
badgeWaitTimeMs
=
Math
.
max
(
0
this
.
updateFirstReadyTime
+
initialBadgeWaitTimeMs
-
now
)
;
let
doorhangerWaitTimeMs
=
Math
.
max
(
0
this
.
updateFirstReadyTime
+
initialDoorhangerWaitTimeMs
-
now
)
;
if
(
AppConstants
.
NIGHTLY_BUILD
&
&
SUPPRESS_PROMPTS
)
{
this
.
showRestartNotification
(
update
true
)
;
}
else
if
(
badgeWaitTimeMs
<
doorhangerWaitTimeMs
)
{
this
.
addTimeout
(
badgeWaitTimeMs
(
)
=
>
{
if
(
!
AppUpdateService
.
isOtherInstanceHandlingUpdates
)
{
this
.
showRestartNotification
(
update
true
)
;
}
if
(
!
this
.
restartDoorhangerShown
)
{
let
remainingTime
=
doorhangerWaitTimeMs
-
badgeWaitTimeMs
;
this
.
addTimeout
(
remainingTime
(
)
=
>
{
this
.
showRestartNotification
(
update
false
)
;
}
)
;
}
}
)
;
}
else
{
this
.
addTimeout
(
doorhangerWaitTimeMs
(
)
=
>
{
this
.
showRestartNotification
(
update
this
.
restartDoorhangerShown
)
;
}
)
;
}
break
;
}
}
handleUpdateAvailable
(
update
status
)
{
switch
(
status
)
{
case
"
show
-
prompt
"
:
if
(
AppConstants
.
NIGHTLY_BUILD
&
&
SUPPRESS_PROMPTS
)
{
this
.
scheduleUpdateAvailableNotification
(
update
)
;
}
else
{
this
.
showUpdateAvailableNotification
(
update
false
)
;
}
break
;
case
"
cant
-
apply
"
:
this
.
clearCallbacks
(
)
;
this
.
showManualUpdateNotification
(
update
false
)
;
break
;
case
"
unsupported
"
:
this
.
clearCallbacks
(
)
;
this
.
showUnsupportedUpdateNotification
(
update
false
)
;
break
;
}
}
handleUpdateDownloading
(
status
)
{
switch
(
status
)
{
case
"
downloading
"
:
this
.
showUpdateDownloadingNotification
(
)
;
break
;
case
"
idle
"
:
this
.
clearPendingAndActiveNotifications
(
)
;
break
;
}
}
handleUpdateSwap
(
)
{
this
.
clearPendingAndActiveNotifications
(
)
;
}
observe
(
subject
topic
status
)
{
let
update
=
subject
&
&
subject
.
QueryInterface
(
Ci
.
nsIUpdate
)
;
switch
(
topic
)
{
case
"
update
-
available
"
:
if
(
status
!
=
"
unsupported
"
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_UNSUPPORTED_URL
)
;
}
this
.
handleUpdateAvailable
(
update
status
)
;
break
;
case
"
update
-
downloading
"
:
this
.
handleUpdateDownloading
(
status
)
;
break
;
case
"
update
-
staged
"
:
case
"
update
-
downloaded
"
:
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_UNSUPPORTED_URL
)
;
this
.
handleUpdateStagedOrDownloaded
(
update
status
)
;
break
;
case
"
update
-
error
"
:
this
.
handleUpdateError
(
update
status
)
;
break
;
case
"
update
-
swap
"
:
this
.
handleUpdateSwap
(
)
;
break
;
}
}
}
;
