"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AUSTLMY
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
BitsError
BitsUnknownError
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Bits
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
var
gUpdatePhasesSetForSession
=
false
;
var
AUSTLMY
=
{
EXTERNAL
:
"
EXTERNAL
"
NOTIFY
:
"
NOTIFY
"
CHK_NO_UPDATE_FOUND
:
0
CHK_DOWNLOAD_UPDATE
:
1
CHK_SHOWPROMPT_PREF
:
3
CHK_HAS_ACTIVEUPDATE
:
8
CHK_IS_DOWNLOADING
:
9
CHK_IS_STAGED
:
10
CHK_IS_DOWNLOADED
:
11
CHK_NO_MUTEX
:
14
CHK_UNABLE_TO_CHECK
:
15
CHK_OFFLINE
:
17
CHK_GENERAL_ERROR_PROMPT
:
22
CHK_GENERAL_ERROR_SILENT
:
23
CHK_NO_COMPAT_UPDATE_FOUND
:
24
CHK_UPDATE_PREVIOUS_VERSION
:
25
CHK_UPDATE_INVALID_TYPE
:
27
CHK_UNSUPPORTED
:
28
CHK_UNABLE_TO_APPLY
:
29
CHK_NO_OS_VERSION
:
30
CHK_NO_OS_ABI
:
31
CHK_INVALID_DEFAULT_URL
:
32
CHK_ELEVATION_DISABLED_FOR_VERSION
:
35
CHK_ELEVATION_OPTOUT_FOR_VERSION
:
36
CHK_DISABLED_BY_POLICY
:
37
CHK_ERR_WRITE_FAILURE
:
38
pingCheckCode
:
function
UT_pingCheckCode
(
aSuffix
aCode
)
{
try
{
if
(
aCode
=
=
this
.
CHK_NO_UPDATE_FOUND
)
{
let
id
=
"
UPDATE_CHECK_NO_UPDATE_
"
+
aSuffix
;
Services
.
telemetry
.
getHistogramById
(
id
)
.
add
(
)
;
}
else
{
let
id
=
"
UPDATE_CHECK_CODE_
"
+
aSuffix
;
Services
.
telemetry
.
getHistogramById
(
id
)
.
add
(
aCode
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
pingCheckExError
:
function
UT_pingCheckExError
(
aSuffix
aCode
)
{
try
{
let
id
=
"
UPDATE_CHECK_EXTENDED_ERROR_
"
+
aSuffix
;
let
val
=
"
AUS_CHECK_EX_ERR_
"
+
aCode
;
Services
.
telemetry
.
getKeyedHistogramById
(
id
)
.
add
(
val
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
STARTUP
:
"
STARTUP
"
STAGE
:
"
STAGE
"
PATCH_COMPLETE
:
"
COMPLETE
"
PATCH_PARTIAL
:
"
PARTIAL
"
PATCH_UNKNOWN
:
"
UNKNOWN
"
DWNLD_SUCCESS
:
0
DWNLD_RETRY_OFFLINE
:
1
DWNLD_RETRY_NET_TIMEOUT
:
2
DWNLD_RETRY_CONNECTION_REFUSED
:
3
DWNLD_RETRY_NET_RESET
:
4
DWNLD_ERR_NO_UPDATE
:
5
DWNLD_ERR_NO_UPDATE_PATCH
:
6
DWNLD_ERR_PATCH_SIZE_LARGER
:
8
DWNLD_ERR_PATCH_SIZE_NOT_EQUAL
:
9
DWNLD_ERR_BINDING_ABORTED
:
10
DWNLD_ERR_ABORT
:
11
DWNLD_ERR_DOCUMENT_NOT_CACHED
:
12
DWNLD_ERR_VERIFY_NO_REQUEST
:
13
DWNLD_ERR_VERIFY_PATCH_SIZE_NOT_EQUAL
:
14
DWNLD_ERR_WRITE_FAILURE
:
15
DWNLD_UNKNOWN_PHASE_ERR_WRITE_FAILURE
:
40
pingDownloadCode
:
function
UT_pingDownloadCode
(
aIsComplete
aCode
)
{
let
patchType
=
this
.
PATCH_UNKNOWN
;
if
(
aIsComplete
=
=
=
true
)
{
patchType
=
this
.
PATCH_COMPLETE
;
}
else
if
(
aIsComplete
=
=
=
false
)
{
patchType
=
this
.
PATCH_PARTIAL
;
}
try
{
let
id
=
"
UPDATE_DOWNLOAD_CODE_
"
+
patchType
;
Services
.
telemetry
.
getHistogramById
(
id
)
.
add
(
aCode
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
STATE_WRITE_FAILURE
:
14
pingStateCode
:
function
UT_pingStateCode
(
aSuffix
aCode
)
{
try
{
let
id
=
"
UPDATE_STATE_CODE_
"
+
aSuffix
;
Services
.
telemetry
.
getHistogramById
(
id
)
.
add
(
aCode
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
pingStatusErrorCode
:
function
UT_pingStatusErrorCode
(
aSuffix
aCode
)
{
try
{
let
id
=
"
UPDATE_STATUS_ERROR_CODE_
"
+
aSuffix
;
Services
.
telemetry
.
getHistogramById
(
id
)
.
add
(
aCode
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
pingBinaryTransparencyResult
:
function
UT_pingBinaryTransparencyResult
(
aSuffix
aCode
)
{
try
{
let
id
=
"
update
.
binarytransparencyresult
"
;
let
key
=
aSuffix
.
toLowerCase
(
)
.
replace
(
"
_
"
"
-
"
)
;
Services
.
telemetry
.
keyedScalarSet
(
id
key
aCode
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
pingBitsError
:
function
UT_pingBitsError
(
aIsComplete
aError
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
Cu
.
reportError
(
"
Warning
:
Attempted
to
submit
BITS
telemetry
on
a
"
+
"
non
-
Windows
platform
"
)
;
return
;
}
if
(
!
(
aError
instanceof
BitsError
)
)
{
Cu
.
reportError
(
"
Error
sending
BITS
Error
ping
:
Error
is
not
a
BitsError
"
)
;
aError
=
new
BitsUnknownError
(
)
;
}
let
type
=
+
aError
.
type
;
if
(
isNaN
(
type
)
)
{
Cu
.
reportError
(
"
Error
sending
BITS
Error
ping
:
Either
error
is
not
a
"
+
"
BitsError
or
error
type
is
not
an
integer
.
"
)
;
type
=
Ci
.
nsIBits
.
ERROR_TYPE_UNKNOWN
;
}
else
if
(
type
=
=
Ci
.
nsIBits
.
ERROR_TYPE_SUCCESS
)
{
Cu
.
reportError
(
"
Error
sending
BITS
Error
ping
:
The
error
type
must
not
"
+
"
be
the
success
type
.
"
)
;
type
=
Ci
.
nsIBits
.
ERROR_TYPE_UNKNOWN
;
}
this
.
_pingBitsResult
(
aIsComplete
type
)
;
if
(
aError
.
codeType
=
=
Ci
.
nsIBits
.
ERROR_CODE_TYPE_HRESULT
)
{
let
scalarKey
;
if
(
aIsComplete
)
{
scalarKey
=
this
.
PATCH_COMPLETE
;
}
else
{
scalarKey
=
this
.
PATCH_PARTIAL
;
}
try
{
Services
.
telemetry
.
keyedScalarSet
(
"
update
.
bitshresult
"
scalarKey
aError
.
code
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
pingBitsSuccess
:
function
UT_pingBitsSuccess
(
aIsComplete
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
Cu
.
reportError
(
"
Warning
:
Attempted
to
submit
BITS
telemetry
on
a
"
+
"
non
-
Windows
platform
"
)
;
return
;
}
this
.
_pingBitsResult
(
aIsComplete
Ci
.
nsIBits
.
ERROR_TYPE_SUCCESS
)
;
}
_pingBitsResult
:
function
UT_pingBitsResult
(
aIsComplete
aResultType
)
{
let
patchType
;
if
(
aIsComplete
)
{
patchType
=
this
.
PATCH_COMPLETE
;
}
else
{
patchType
=
this
.
PATCH_PARTIAL
;
}
try
{
let
id
=
"
UPDATE_BITS_RESULT_
"
+
patchType
;
Services
.
telemetry
.
getHistogramById
(
id
)
.
add
(
aResultType
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
pingLastUpdateTime
:
function
UT_pingLastUpdateTime
(
aSuffix
)
{
const
PREF_APP_UPDATE_LASTUPDATETIME
=
"
app
.
update
.
lastUpdateTime
.
background
-
update
-
timer
"
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_LASTUPDATETIME
)
)
{
let
lastUpdateTimeSeconds
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_LASTUPDATETIME
)
;
if
(
lastUpdateTimeSeconds
)
{
let
currentTimeSeconds
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
if
(
lastUpdateTimeSeconds
>
currentTimeSeconds
)
{
try
{
let
id
=
"
UPDATE_INVALID_LASTUPDATETIME_
"
+
aSuffix
;
Services
.
telemetry
.
getHistogramById
(
id
)
.
add
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
else
{
let
intervalDays
=
(
currentTimeSeconds
-
lastUpdateTimeSeconds
)
/
(
60
*
60
*
24
)
;
try
{
let
id
=
"
UPDATE_LAST_NOTIFY_INTERVAL_DAYS_
"
+
aSuffix
;
Services
.
telemetry
.
getHistogramById
(
id
)
.
add
(
intervalDays
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
}
}
pingUpdatePhases
:
function
UT_pingUpdatePhases
(
aUpdate
aIsStartup
)
{
if
(
!
aIsStartup
&
&
!
Cu
.
isInAutomation
)
{
if
(
gUpdatePhasesSetForSession
)
{
return
;
}
gUpdatePhasesSetForSession
=
true
;
}
let
basePrefix
=
aIsStartup
?
"
update
.
startup
.
"
:
"
update
.
session
.
"
;
try
{
let
update
=
aUpdate
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
let
scalarSet
=
Services
.
telemetry
.
scalarSet
;
scalarSet
(
basePrefix
+
"
from_app_version
"
aUpdate
.
previousAppVersion
)
;
scalarSet
(
basePrefix
+
"
intervals
.
check
"
update
.
getProperty
(
"
checkInterval
"
)
)
;
for
(
let
i
=
0
;
i
<
aUpdate
.
patchCount
;
+
+
i
)
{
let
patch
=
aUpdate
.
getPatchAt
(
i
)
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
let
type
=
patch
.
type
;
scalarSet
(
basePrefix
+
"
mar_
"
+
type
+
"
_size_bytes
"
patch
.
size
)
;
let
prefix
=
basePrefix
+
"
intervals
.
"
;
let
internalDownloadStart
=
patch
.
getProperty
(
"
internalDownloadStart
"
)
;
let
internalDownloadFinished
=
patch
.
getProperty
(
"
internalDownloadFinished
"
)
;
if
(
internalDownloadStart
!
=
=
null
&
&
internalDownloadFinished
!
=
=
null
)
{
scalarSet
(
prefix
+
"
download_internal_
"
+
type
Math
.
max
(
internalDownloadFinished
-
internalDownloadStart
1
)
)
;
}
let
bitsDownloadStart
=
patch
.
getProperty
(
"
bitsDownloadStart
"
)
;
let
bitsDownloadFinished
=
patch
.
getProperty
(
"
bitsDownloadFinished
"
)
;
if
(
bitsDownloadStart
!
=
=
null
&
&
bitsDownloadFinished
!
=
=
null
)
{
scalarSet
(
prefix
+
"
download_bits_
"
+
type
Math
.
max
(
bitsDownloadFinished
-
bitsDownloadStart
1
)
)
;
}
let
stageStart
=
patch
.
getProperty
(
"
stageStart
"
)
;
let
stageFinished
=
patch
.
getProperty
(
"
stageFinished
"
)
;
if
(
stageStart
!
=
=
null
&
&
stageFinished
!
=
=
null
)
{
scalarSet
(
prefix
+
"
stage_
"
+
type
Math
.
max
(
stageFinished
-
stageStart
1
)
)
;
}
let
applyStart
=
patch
.
getProperty
(
"
applyStart
"
)
;
if
(
applyStart
!
=
=
null
)
{
let
applyFinished
=
Math
.
ceil
(
Date
.
now
(
)
/
1000
)
;
scalarSet
(
prefix
+
"
apply_
"
+
type
Math
.
max
(
applyFinished
-
applyStart
1
)
)
;
}
prefix
=
basePrefix
+
"
downloads
.
"
;
let
internalBytes
=
patch
.
getProperty
(
"
internalBytes
"
)
;
if
(
internalBytes
!
=
=
null
)
{
scalarSet
(
prefix
+
"
internal_
"
+
type
+
"
_bytes
"
Math
.
max
(
internalBytes
1
)
)
;
}
let
internalSeconds
=
patch
.
getProperty
(
"
internalSeconds
"
)
;
if
(
internalSeconds
!
=
=
null
)
{
scalarSet
(
prefix
+
"
internal_
"
+
type
+
"
_seconds
"
Math
.
max
(
internalSeconds
1
)
)
;
}
let
bitsBytes
=
patch
.
getProperty
(
"
bitsBytes
"
)
;
if
(
bitsBytes
!
=
=
null
)
{
scalarSet
(
prefix
+
"
bits_
"
+
type
+
"
_bytes
"
Math
.
max
(
bitsBytes
1
)
)
;
}
let
bitsSeconds
=
patch
.
getProperty
(
"
bitsSeconds
"
)
;
if
(
bitsSeconds
!
=
=
null
)
{
scalarSet
(
prefix
+
"
bits_
"
+
type
+
"
_seconds
"
Math
.
max
(
bitsSeconds
1
)
)
;
}
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
pingServiceInstallStatus
:
function
UT_PSIS
(
aSuffix
aInstalled
)
{
if
(
!
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
in
Cc
)
)
{
Cu
.
reportError
(
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
try
{
let
id
=
"
UPDATE_SERVICE_INSTALLED_
"
+
aSuffix
;
Services
.
telemetry
.
getHistogramById
(
id
)
.
add
(
aInstalled
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
let
attempted
=
0
;
try
{
let
wrk
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
wrk
.
open
(
wrk
.
ROOT_KEY_LOCAL_MACHINE
"
SOFTWARE
\
\
Mozilla
\
\
MaintenanceService
"
wrk
.
ACCESS_READ
|
wrk
.
WOW64_64
)
;
attempted
=
wrk
.
readIntValue
(
"
Attempted
"
)
;
wrk
.
close
(
)
;
}
catch
(
e
)
{
}
try
{
let
id
=
"
UPDATE_SERVICE_MANUALLY_UNINSTALLED_
"
+
aSuffix
;
if
(
!
aInstalled
&
&
attempted
)
{
Services
.
telemetry
.
getHistogramById
(
id
)
.
add
(
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
pingBoolPref
:
function
UT_pingBoolPref
(
aID
aPref
aDefault
aExpected
)
{
try
{
let
val
=
aDefault
;
if
(
Services
.
prefs
.
getPrefType
(
aPref
)
!
=
Ci
.
nsIPrefBranch
.
PREF_INVALID
)
{
val
=
Services
.
prefs
.
getBoolPref
(
aPref
)
;
}
if
(
val
!
=
aExpected
)
{
Services
.
telemetry
.
getHistogramById
(
aID
)
.
add
(
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
pingIntPref
:
function
UT_pingIntPref
(
aID
aPref
aDefault
aExpected
)
{
try
{
let
val
=
aDefault
;
if
(
Services
.
prefs
.
getPrefType
(
aPref
)
!
=
Ci
.
nsIPrefBranch
.
PREF_INVALID
)
{
val
=
Services
.
prefs
.
getIntPref
(
aPref
)
;
}
if
(
aExpected
=
=
=
undefined
|
|
val
!
=
aExpected
)
{
Services
.
telemetry
.
getHistogramById
(
aID
)
.
add
(
val
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
pingGeneric
:
function
UT_pingGeneric
(
aID
aValue
aExpected
)
{
try
{
if
(
aExpected
=
=
=
undefined
)
{
Services
.
telemetry
.
getHistogramById
(
aID
)
.
add
(
aValue
)
;
}
else
if
(
aValue
!
=
aExpected
)
{
Services
.
telemetry
.
getHistogramById
(
aID
)
.
add
(
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
;
Object
.
freeze
(
AUSTLMY
)
;
