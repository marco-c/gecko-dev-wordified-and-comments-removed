var
gNextRunFunc
;
var
gExpectedCount
;
function
run_test
(
)
{
setupTestCommon
(
)
;
debugDump
(
"
testing
remote
update
xml
attributes
"
)
;
start_httpserver
(
)
;
setUpdateURL
(
gURLData
+
gHTTPHandlerPath
)
;
setUpdateChannel
(
"
test_channel
"
)
;
Services
.
prefs
.
deleteBranch
(
"
app
.
update
.
download
.
backgroundInterval
"
)
;
standardInit
(
)
;
executeSoon
(
run_test_pt01
)
;
}
function
run_test_helper_pt1
(
aMsg
aExpectedCount
aNextRunFunc
)
{
gUpdates
=
null
;
gUpdateCount
=
null
;
gCheckFunc
=
check_test_helper_pt1
;
gNextRunFunc
=
aNextRunFunc
;
gExpectedCount
=
aExpectedCount
;
debugDump
(
aMsg
Components
.
stack
.
caller
)
;
gUpdateChecker
.
checkForUpdates
(
updateCheckListener
true
)
;
}
function
check_test_helper_pt1
(
)
{
Assert
.
equal
(
gUpdateCount
gExpectedCount
"
the
update
count
"
+
MSG_SHOULD_EQUAL
)
;
gNextRunFunc
(
)
;
}
function
run_test_pt01
(
)
{
run_test_helper_pt1
(
"
testing
update
xml
not
available
"
null
run_test_pt02
)
;
}
function
run_test_pt02
(
)
{
debugDump
(
"
testing
one
update
available
and
the
update
'
s
property
values
"
)
;
gUpdates
=
null
;
gUpdateCount
=
null
;
gCheckFunc
=
check_test_pt02
;
let
patchProps
=
{
type
:
"
complete
"
url
:
"
http
:
/
/
complete
/
"
size
:
"
9856459
"
}
;
let
patches
=
getRemotePatchString
(
patchProps
)
;
patchProps
=
{
type
:
"
partial
"
url
:
"
http
:
/
/
partial
/
"
size
:
"
1316138
"
}
;
patches
+
=
getRemotePatchString
(
patchProps
)
;
let
updateProps
=
{
type
:
"
minor
"
name
:
"
Minor
Test
"
displayVersion
:
"
version
2
.
1a1pre
"
appVersion
:
"
2
.
1a1pre
"
buildID
:
"
20080811053724
"
detailsURL
:
"
http
:
/
/
details
/
"
promptWaitTime
:
"
345600
"
backgroundInterval
:
"
1200
"
custom1
:
"
custom1_attr
=
\
"
custom1
value
\
"
"
custom2
:
"
custom2_attr
=
\
"
custom2
value
\
"
"
}
;
let
updates
=
getRemoteUpdateString
(
updateProps
patches
)
;
gResponseBody
=
getRemoteUpdatesXMLString
(
updates
)
;
gUpdateChecker
.
checkForUpdates
(
updateCheckListener
true
)
;
}
function
check_test_pt02
(
)
{
Assert
.
equal
(
gUpdateCount
1
"
the
update
count
"
+
MSG_SHOULD_EQUAL
)
;
let
bestUpdate
=
gAUS
.
selectUpdate
(
gUpdates
gUpdateCount
)
.
QueryInterface
(
Ci
.
nsIPropertyBag
)
;
Assert
.
equal
(
bestUpdate
.
type
"
minor
"
"
the
update
type
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
name
"
Minor
Test
"
"
the
update
name
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
displayVersion
"
version
2
.
1a1pre
"
"
the
update
displayVersion
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
appVersion
"
2
.
1a1pre
"
"
the
update
appVersion
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
buildID
"
20080811053724
"
"
the
update
buildID
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
detailsURL
"
http
:
/
/
details
/
"
"
the
update
detailsURL
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
promptWaitTime
"
345600
"
"
the
update
promptWaitTime
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
getProperty
(
"
backgroundInterval
"
)
"
600
"
"
the
update
backgroundInterval
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
serviceURL
gURLData
+
gHTTPHandlerPath
+
"
?
force
=
1
"
"
the
update
serviceURL
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
channel
"
test_channel
"
"
the
update
channel
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
ok
(
!
bestUpdate
.
isCompleteUpdate
"
the
update
isCompleteUpdate
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
ok
(
!
bestUpdate
.
isSecurityUpdate
"
the
update
isSecurityUpdate
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
ok
(
(
Date
.
now
(
)
-
bestUpdate
.
installDate
)
<
10000
"
the
update
installDate
attribute
should
be
within
10
seconds
of
"
+
"
the
current
time
"
)
;
Assert
.
ok
(
!
bestUpdate
.
statusText
"
the
update
statusText
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
state
"
"
"
the
update
state
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
errorCode
0
"
the
update
errorCode
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
patchCount
2
"
the
update
patchCount
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
getProperty
(
"
custom1_attr
"
)
"
custom1
value
"
"
the
update
custom1_attr
property
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
getProperty
(
"
custom2_attr
"
)
"
custom2
value
"
"
the
update
custom2_attr
property
"
+
MSG_SHOULD_EQUAL
)
;
let
patch
=
bestUpdate
.
getPatchAt
(
0
)
;
Assert
.
equal
(
patch
.
type
"
complete
"
"
the
update
patch
type
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
patch
.
URL
"
http
:
/
/
complete
/
"
"
the
update
patch
URL
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
patch
.
size
9856459
"
the
update
patch
size
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
typeof
patch
.
state
"
string
"
"
the
update
patch
state
typeof
value
should
equal
|
string
|
"
)
;
Assert
.
equal
(
patch
.
state
STATE_NONE
"
the
update
patch
state
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
ok
(
!
patch
.
selected
"
the
update
patch
selected
attribute
"
+
MSG_SHOULD_EQUAL
)
;
patch
=
bestUpdate
.
getPatchAt
(
1
)
;
Assert
.
equal
(
patch
.
type
"
partial
"
"
the
update
patch
type
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
patch
.
URL
"
http
:
/
/
partial
/
"
"
the
update
patch
URL
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
patch
.
size
1316138
"
the
update
patch
size
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
patch
.
state
STATE_NONE
"
the
update
patch
state
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
ok
(
!
patch
.
selected
"
the
update
patch
selected
attribute
"
+
MSG_SHOULD_EQUAL
)
;
run_test_pt03
(
)
;
}
function
run_test_pt03
(
)
{
gResponseBody
=
"
<
parsererror
/
>
"
;
run_test_helper_pt1
(
"
testing
empty
update
xml
"
null
run_test_pt04
)
;
}
function
run_test_pt04
(
)
{
gResponseBody
=
getRemoteUpdatesXMLString
(
"
"
)
;
run_test_helper_pt1
(
"
testing
no
updates
available
"
0
run_test_pt05
)
;
}
function
run_test_pt05
(
)
{
let
patches
=
getRemotePatchString
(
{
}
)
;
let
patchProps
=
{
type
:
"
partial
"
}
;
patches
+
=
getRemotePatchString
(
patchProps
)
;
let
updates
=
getRemoteUpdateString
(
{
}
patches
)
;
gResponseBody
=
getRemoteUpdatesXMLString
(
updates
)
;
run_test_helper_pt1
(
"
testing
one
update
available
"
1
run_test_pt06
)
;
}
function
run_test_pt06
(
)
{
let
patches
=
getRemotePatchString
(
{
}
)
;
let
patchProps
=
{
type
:
"
partial
"
}
;
patches
+
=
getRemotePatchString
(
patchProps
)
;
let
updates
=
getRemoteUpdateString
(
{
}
patches
)
;
updates
+
=
updates
+
updates
;
gResponseBody
=
getRemoteUpdatesXMLString
(
updates
)
;
run_test_helper_pt1
(
"
testing
three
updates
available
"
3
run_test_pt07
)
;
}
function
run_test_pt07
(
)
{
let
patchProps
=
{
size
:
"
0
"
}
;
let
patches
=
getRemotePatchString
(
patchProps
)
;
patchProps
=
{
type
:
"
partial
"
size
:
"
0
"
}
;
patches
+
=
getRemotePatchString
(
patchProps
)
;
let
updates
=
getRemoteUpdateString
(
{
}
patches
)
;
gResponseBody
=
getRemoteUpdatesXMLString
(
updates
)
;
run_test_helper_pt1
(
"
testing
one
update
with
complete
and
partial
"
+
"
patches
with
size
0
"
0
run_test_pt08
)
;
}
function
run_test_pt08
(
)
{
let
patchProps
=
{
size
:
"
0
"
}
;
let
patches
=
getRemotePatchString
(
patchProps
)
;
let
updates
=
getRemoteUpdateString
(
{
}
patches
)
;
gResponseBody
=
getRemoteUpdatesXMLString
(
updates
)
;
run_test_helper_pt1
(
"
testing
one
update
with
complete
patch
with
size
0
"
0
run_test_pt9
)
;
}
function
run_test_pt9
(
)
{
let
patchProps
=
{
type
:
"
partial
"
size
:
"
0
"
}
;
let
patches
=
getRemotePatchString
(
patchProps
)
;
let
updates
=
getRemoteUpdateString
(
{
}
patches
)
;
gResponseBody
=
getRemoteUpdatesXMLString
(
updates
)
;
run_test_helper_pt1
(
"
testing
one
update
with
partial
patch
with
size
0
"
0
run_test_pt10
)
;
}
function
run_test_pt10
(
)
{
let
patches
=
getRemotePatchString
(
{
}
)
;
let
patchProps
=
{
type
:
"
partial
"
}
;
patches
+
=
getRemotePatchString
(
patchProps
)
;
let
updateProps
=
{
appVersion
:
"
1
.
0pre
"
}
;
let
updates
=
getRemoteUpdateString
(
updateProps
patches
)
;
updateProps
=
{
appVersion
:
"
1
.
0a
"
}
;
updates
+
=
getRemoteUpdateString
(
updateProps
patches
)
;
gResponseBody
=
getRemoteUpdatesXMLString
(
updates
)
;
run_test_helper_pt1
(
"
testing
two
updates
older
than
the
current
version
"
2
check_test_pt10
)
;
}
function
check_test_pt10
(
)
{
let
bestUpdate
=
gAUS
.
selectUpdate
(
gUpdates
gUpdateCount
)
;
Assert
.
ok
(
!
bestUpdate
"
there
should
be
no
update
available
"
)
;
run_test_pt11
(
)
;
}
function
run_test_pt11
(
)
{
let
patches
=
getRemotePatchString
(
{
}
)
;
let
patchProps
=
{
type
:
"
partial
"
}
;
patches
+
=
getRemotePatchString
(
patchProps
)
;
let
updateProps
=
{
appVersion
:
"
1
.
0
"
}
;
let
updates
=
getRemoteUpdateString
(
updateProps
patches
)
;
gResponseBody
=
getRemoteUpdatesXMLString
(
updates
)
;
run_test_helper_pt1
(
"
testing
one
update
equal
to
the
current
version
"
1
check_test_pt11
)
;
}
function
check_test_pt11
(
)
{
let
bestUpdate
=
gAUS
.
selectUpdate
(
gUpdates
gUpdateCount
)
;
Assert
.
ok
(
!
!
bestUpdate
"
there
should
be
one
update
available
"
)
;
Assert
.
equal
(
bestUpdate
.
appVersion
"
1
.
0
"
"
the
update
appVersion
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
bestUpdate
.
displayVersion
"
1
.
0
"
"
the
update
displayVersion
attribute
"
+
MSG_SHOULD_EQUAL
)
;
doTestFinish
(
)
;
}
