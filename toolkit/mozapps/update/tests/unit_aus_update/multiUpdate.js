let
{
HttpServer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
const
REL_PATH_DATA
=
"
"
;
const
APP_UPDATE_SJS_HOST
=
"
http
:
/
/
127
.
0
.
0
.
1
:
8888
"
;
const
URL_PATH_UPDATE_XML
=
"
/
"
+
REL_PATH_DATA
+
"
app_update
.
sjs
"
;
const
APP_UPDATE_SJS_URL
=
APP_UPDATE_SJS_HOST
+
URL_PATH_UPDATE_XML
;
const
CONTINUE_CHECK
=
"
continueCheck
"
;
const
CONTINUE_DOWNLOAD
=
"
continueDownload
"
;
const
CONTINUE_STAGING
=
"
continueStaging
"
;
const
FIRST_UPDATE_VERSION
=
"
999998
.
0
"
;
const
SECOND_UPDATE_VERSION
=
"
999999
.
0
"
;
async
function
downloadUpdate
(
appUpdateAuto
onDownloadStartCallback
)
{
let
downloadFinishedPromise
=
waitForEvent
(
"
update
-
downloaded
"
)
;
let
updateAvailablePromise
;
if
(
!
appUpdateAuto
)
{
updateAvailablePromise
=
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
status
)
=
>
{
Services
.
obs
.
removeObserver
(
observer
"
update
-
available
"
)
;
subject
.
QueryInterface
(
Ci
.
nsIUpdate
)
;
resolve
(
{
update
:
subject
status
}
)
;
}
;
Services
.
obs
.
addObserver
(
observer
"
update
-
available
"
)
;
}
)
;
}
let
waitToStartPromise
=
new
Promise
(
resolve
=
>
{
let
listener
=
{
onStartRequest
:
aRequest
=
>
{
gAUS
.
removeDownloadListener
(
listener
)
;
onDownloadStartCallback
(
)
;
resolve
(
)
;
}
onProgress
:
(
aRequest
aContext
aProgress
aMaxProgress
)
=
>
{
}
onStatus
:
(
aRequest
aStatus
aStatusText
)
=
>
{
}
onStopRequest
(
request
status
)
{
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIRequestObserver
"
"
nsIProgressEventSink
"
]
)
}
;
gAUS
.
addDownloadListener
(
listener
)
;
}
)
;
let
updateCheckStarted
=
gAUS
.
checkForBackgroundUpdates
(
)
;
Assert
.
ok
(
updateCheckStarted
"
Update
check
should
have
started
"
)
;
if
(
!
appUpdateAuto
)
{
let
{
update
status
}
=
await
updateAvailablePromise
;
Assert
.
equal
(
status
"
show
-
prompt
"
"
Should
attempt
to
show
the
update
-
available
prompt
"
)
;
gAUS
.
downloadUpdate
(
update
true
)
;
}
await
continueFileHandler
(
CONTINUE_DOWNLOAD
)
;
await
waitToStartPromise
;
await
downloadFinishedPromise
;
await
TestUtils
.
waitForTick
(
)
;
}
async
function
testUpdateDoesNotDownload
(
)
{
let
{
request
updates
}
=
await
new
Promise
(
(
resolve
reject
)
=
>
{
let
listener
=
{
onCheckComplete
:
async
(
request
updates
)
=
>
{
resolve
(
{
request
updates
}
)
;
}
onError
:
async
(
request
update
)
=
>
{
Assert
.
ok
(
false
"
Update
check
should
have
succeeded
"
)
;
reject
(
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUpdateCheckListener
"
]
)
}
;
gUpdateChecker
.
checkForUpdates
(
listener
false
)
;
}
)
;
Assert
.
equal
(
updates
.
length
1
"
Should
have
gotten
1
update
in
update
check
"
)
;
let
update
=
updates
[
0
]
;
let
downloadStarted
=
gAUS
.
downloadUpdate
(
update
true
)
;
Assert
.
equal
(
downloadStarted
false
"
Expected
that
we
would
not
start
downloading
an
update
"
)
;
let
updateAvailableObserved
=
false
;
let
observer
=
(
subject
topic
status
)
=
>
{
updateAvailableObserved
=
true
;
}
;
Services
.
obs
.
addObserver
(
observer
"
update
-
available
"
)
;
await
gAUS
.
onCheckComplete
(
request
updates
)
;
Services
.
obs
.
removeObserver
(
observer
"
update
-
available
"
)
;
Assert
.
equal
(
updateAvailableObserved
false
"
update
-
available
notification
should
not
fire
if
we
aren
'
t
going
to
"
+
"
download
the
update
.
"
)
;
}
function
testUpdateCheckDoesNotStart
(
)
{
let
updateCheckStarted
=
gAUS
.
checkForBackgroundUpdates
(
)
;
Assert
.
equal
(
updateCheckStarted
false
"
Update
check
should
not
have
started
"
)
;
}
function
prepareToDownloadVersion
(
version
onlyCompleteMar
=
false
)
{
let
updateUrl
=
{
APP_UPDATE_SJS_URL
}
?
useSlowDownloadMar
=
1
&
appVersion
=
{
version
}
;
if
(
onlyCompleteMar
)
{
updateUrl
+
=
"
&
completePatchOnly
=
1
"
;
}
setUpdateURL
(
updateUrl
)
;
}
function
startUpdateServer
(
)
{
let
httpServer
=
new
HttpServer
(
)
;
httpServer
.
registerContentType
(
"
sjs
"
"
sjs
"
)
;
httpServer
.
registerDirectory
(
"
/
"
do_get_cwd
(
)
)
;
httpServer
.
start
(
8888
)
;
registerCleanupFunction
(
async
function
cleanup_httpServer
(
)
{
await
new
Promise
(
resolve
=
>
{
httpServer
.
stop
(
resolve
)
;
}
)
;
}
)
;
}
async
function
multi_update_test
(
appUpdateAuto
)
{
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
appUpdateAuto
)
;
prepareToDownloadVersion
(
FIRST_UPDATE_VERSION
)
;
await
downloadUpdate
(
appUpdateAuto
(
)
=
>
{
Assert
.
ok
(
!
gUpdateManager
.
readyUpdate
"
There
should
not
be
a
ready
update
yet
"
)
;
Assert
.
ok
(
!
!
gUpdateManager
.
downloadingUpdate
"
First
update
download
should
be
in
downloadingUpdate
"
)
;
Assert
.
equal
(
gUpdateManager
.
downloadingUpdate
.
state
STATE_DOWNLOADING
"
downloadingUpdate
should
be
downloading
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_DOWNLOADING
"
Updater
state
should
be
downloading
"
)
;
}
)
;
Assert
.
ok
(
!
gUpdateManager
.
downloadingUpdate
"
First
update
download
should
no
longer
be
in
downloadingUpdate
"
)
;
Assert
.
ok
(
!
!
gUpdateManager
.
readyUpdate
"
First
update
download
should
be
in
readyUpdate
"
)
;
Assert
.
equal
(
gUpdateManager
.
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
be
pending
"
)
;
Assert
.
equal
(
gUpdateManager
.
readyUpdate
.
appVersion
FIRST_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
first
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
be
pending
"
)
;
let
existingUpdate
=
gUpdateManager
.
readyUpdate
;
await
testUpdateDoesNotDownload
(
)
;
Assert
.
equal
(
gUpdateManager
.
readyUpdate
existingUpdate
"
readyUpdate
should
not
have
changed
when
no
newer
update
is
available
"
)
;
Assert
.
equal
(
gUpdateManager
.
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
still
be
pending
"
)
;
Assert
.
equal
(
gUpdateManager
.
readyUpdate
.
appVersion
FIRST_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
first
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
still
be
pending
"
)
;
prepareToDownloadVersion
(
SECOND_UPDATE_VERSION
true
)
;
await
testUpdateDoesNotDownload
(
)
;
Assert
.
equal
(
gUpdateManager
.
readyUpdate
existingUpdate
"
readyUpdate
should
not
have
changed
when
no
newer
partial
update
is
available
"
)
;
Assert
.
equal
(
gUpdateManager
.
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
still
be
pending
"
)
;
Assert
.
equal
(
gUpdateManager
.
readyUpdate
.
appVersion
FIRST_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
first
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
still
be
pending
"
)
;
prepareToDownloadVersion
(
SECOND_UPDATE_VERSION
)
;
await
downloadUpdate
(
appUpdateAuto
(
)
=
>
{
Assert
.
ok
(
!
!
gUpdateManager
.
downloadingUpdate
"
Second
update
download
should
be
in
downloadingUpdate
"
)
;
Assert
.
equal
(
gUpdateManager
.
downloadingUpdate
.
state
STATE_DOWNLOADING
"
downloadingUpdate
should
be
downloading
"
)
;
Assert
.
ok
(
!
!
gUpdateManager
.
readyUpdate
"
First
update
download
should
still
be
in
readyUpdate
"
)
;
Assert
.
equal
(
gUpdateManager
.
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
still
be
pending
"
)
;
Assert
.
equal
(
gUpdateManager
.
readyUpdate
.
appVersion
FIRST_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
first
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
match
the
readyUpdate
'
s
state
"
)
;
}
)
;
Assert
.
ok
(
!
gUpdateManager
.
downloadingUpdate
"
Second
update
download
should
no
longer
be
in
downloadingUpdate
"
)
;
Assert
.
ok
(
!
!
gUpdateManager
.
readyUpdate
"
Second
update
download
should
be
in
readyUpdate
"
)
;
Assert
.
equal
(
gUpdateManager
.
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
be
pending
"
)
;
Assert
.
equal
(
gUpdateManager
.
readyUpdate
.
appVersion
SECOND_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
second
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
be
pending
"
)
;
reloadUpdateManagerData
(
true
)
;
prepareToDownloadVersion
(
FIRST_UPDATE_VERSION
true
)
;
await
downloadUpdate
(
appUpdateAuto
(
)
=
>
{
Assert
.
equal
(
gUpdateManager
.
downloadingUpdate
.
selectedPatch
.
type
"
complete
"
"
First
update
download
should
be
a
complete
patch
"
)
;
}
)
;
Assert
.
equal
(
gUpdateManager
.
readyUpdate
.
selectedPatch
.
type
"
complete
"
"
First
update
download
should
be
a
complete
patch
"
)
;
prepareToDownloadVersion
(
SECOND_UPDATE_VERSION
)
;
testUpdateCheckDoesNotStart
(
)
;
}
add_task
(
async
function
all_multi_update_tests
(
)
{
setupTestCommon
(
true
)
;
startUpdateServer
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_DISABLEDFORTESTING
false
)
;
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
false
)
;
let
origAppUpdateAutoVal
=
await
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
origAppUpdateAutoVal
)
;
}
)
;
await
multi_update_test
(
true
)
;
reloadUpdateManagerData
(
true
)
;
await
multi_update_test
(
false
)
;
doTestFinish
(
)
;
}
)
;
