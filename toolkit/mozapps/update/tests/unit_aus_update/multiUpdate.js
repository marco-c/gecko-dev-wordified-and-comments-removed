const
FIRST_UPDATE_VERSION
=
"
999998
.
0
"
;
const
SECOND_UPDATE_VERSION
=
"
999999
.
0
"
;
async
function
testUpdateDoesNotDownload
(
)
{
let
check
=
gUpdateChecker
.
checkForUpdates
(
gUpdateChecker
.
BACKGROUND_CHECK
)
;
let
result
=
await
check
.
result
;
Assert
.
ok
(
result
.
checksAllowed
"
Should
be
able
to
check
for
updates
"
)
;
Assert
.
ok
(
result
.
succeeded
"
Update
check
should
have
succeeded
"
)
;
Assert
.
equal
(
result
.
updates
.
length
1
"
Should
have
gotten
1
update
in
update
check
"
)
;
let
update
=
result
.
updates
[
0
]
;
let
downloadResult
=
await
gAUS
.
downloadUpdate
(
update
true
)
;
Assert
.
equal
(
downloadResult
Ci
.
nsIApplicationUpdateService
.
DOWNLOAD_FAILURE_GENERIC
"
Expected
that
we
would
not
start
downloading
an
update
"
)
;
let
updateAvailableObserved
=
false
;
let
observer
=
(
_subject
_topic
_status
)
=
>
{
updateAvailableObserved
=
true
;
}
;
Services
.
obs
.
addObserver
(
observer
"
update
-
available
"
)
;
await
gAUS
.
onCheckComplete
(
result
)
;
Services
.
obs
.
removeObserver
(
observer
"
update
-
available
"
)
;
Assert
.
equal
(
updateAvailableObserved
false
"
update
-
available
notification
should
not
fire
if
we
aren
'
t
going
to
"
+
"
download
the
update
.
"
)
;
}
async
function
testUpdateCheckDoesNotStart
(
)
{
let
updateCheckStarted
=
await
gAUS
.
checkForBackgroundUpdates
(
)
;
Assert
.
equal
(
updateCheckStarted
false
"
Update
check
should
not
have
started
"
)
;
}
function
prepareToDownloadVersion
(
version
onlyCompleteMar
=
false
)
{
let
updateUrl
=
{
gURLData
}
&
useSlowDownloadMar
=
1
&
useFirstByteEarly
=
1
&
appVersion
=
{
version
}
;
if
(
onlyCompleteMar
)
{
updateUrl
+
=
"
&
completePatchOnly
=
1
"
;
}
setUpdateURL
(
updateUrl
)
;
}
async
function
multi_update_test
(
appUpdateAuto
)
{
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
appUpdateAuto
)
;
prepareToDownloadVersion
(
FIRST_UPDATE_VERSION
)
;
await
downloadUpdate
(
{
appUpdateAuto
checkWithAUS
:
true
slowDownload
:
true
onDownloadStartCallback
:
async
(
)
=
>
{
const
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
const
downloadingUpdate
=
await
gUpdateManager
.
getDownloadingUpdate
(
)
;
Assert
.
ok
(
!
readyUpdate
"
There
should
not
be
a
ready
update
yet
"
)
;
Assert
.
ok
(
!
!
downloadingUpdate
"
First
update
download
should
be
in
downloadingUpdate
"
)
;
Assert
.
equal
(
downloadingUpdate
.
state
STATE_DOWNLOADING
"
downloadingUpdate
should
be
downloading
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_DOWNLOADING
"
Updater
state
should
be
downloading
"
)
;
}
}
)
;
let
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
let
downloadingUpdate
=
await
gUpdateManager
.
getDownloadingUpdate
(
)
;
Assert
.
ok
(
!
downloadingUpdate
"
First
update
download
should
no
longer
be
in
downloadingUpdate
"
)
;
Assert
.
ok
(
!
!
readyUpdate
"
First
update
download
should
be
in
readyUpdate
"
)
;
Assert
.
equal
(
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
be
pending
"
)
;
Assert
.
equal
(
readyUpdate
.
appVersion
FIRST_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
first
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
be
pending
"
)
;
let
existingUpdate
=
readyUpdate
;
await
testUpdateDoesNotDownload
(
)
;
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
Assert
.
equal
(
readyUpdate
existingUpdate
"
readyUpdate
should
not
have
changed
when
no
newer
update
is
available
"
)
;
Assert
.
equal
(
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
still
be
pending
"
)
;
Assert
.
equal
(
readyUpdate
.
appVersion
FIRST_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
first
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
still
be
pending
"
)
;
prepareToDownloadVersion
(
SECOND_UPDATE_VERSION
true
)
;
await
testUpdateDoesNotDownload
(
)
;
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
Assert
.
equal
(
readyUpdate
existingUpdate
"
readyUpdate
should
not
have
changed
when
no
newer
partial
update
is
available
"
)
;
Assert
.
equal
(
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
still
be
pending
"
)
;
Assert
.
equal
(
readyUpdate
.
appVersion
FIRST_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
first
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
still
be
pending
"
)
;
prepareToDownloadVersion
(
SECOND_UPDATE_VERSION
)
;
await
downloadUpdate
(
{
appUpdateAuto
checkWithAUS
:
true
slowDownload
:
true
onDownloadStartCallback
:
async
(
)
=
>
{
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
downloadingUpdate
=
await
gUpdateManager
.
getDownloadingUpdate
(
)
;
Assert
.
ok
(
!
!
downloadingUpdate
"
Second
update
download
should
be
in
downloadingUpdate
"
)
;
Assert
.
equal
(
downloadingUpdate
.
state
STATE_DOWNLOADING
"
downloadingUpdate
should
be
downloading
"
)
;
Assert
.
ok
(
!
!
readyUpdate
"
First
update
download
should
still
be
in
readyUpdate
"
)
;
Assert
.
equal
(
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
still
be
pending
"
)
;
Assert
.
equal
(
readyUpdate
.
appVersion
FIRST_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
first
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
match
the
readyUpdate
'
s
state
"
)
;
}
}
)
;
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
downloadingUpdate
=
await
gUpdateManager
.
getDownloadingUpdate
(
)
;
Assert
.
ok
(
!
downloadingUpdate
"
Second
update
download
should
no
longer
be
in
downloadingUpdate
"
)
;
Assert
.
ok
(
!
!
readyUpdate
"
Second
update
download
should
be
in
readyUpdate
"
)
;
Assert
.
equal
(
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
be
pending
"
)
;
Assert
.
equal
(
readyUpdate
.
appVersion
SECOND_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
second
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
be
pending
"
)
;
await
reloadUpdateManagerData
(
true
)
;
prepareToDownloadVersion
(
FIRST_UPDATE_VERSION
true
)
;
await
downloadUpdate
(
{
appUpdateAuto
checkWithAUS
:
true
slowDownload
:
true
onDownloadStartCallback
:
async
(
)
=
>
{
downloadingUpdate
=
await
gUpdateManager
.
getDownloadingUpdate
(
)
;
Assert
.
equal
(
downloadingUpdate
.
selectedPatch
.
type
"
complete
"
"
First
update
download
should
be
a
complete
patch
"
)
;
}
}
)
;
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
Assert
.
equal
(
readyUpdate
.
selectedPatch
.
type
"
complete
"
"
First
update
download
should
be
a
complete
patch
"
)
;
prepareToDownloadVersion
(
SECOND_UPDATE_VERSION
)
;
await
testUpdateCheckDoesNotStart
(
)
;
}
add_task
(
async
function
all_multi_update_tests
(
)
{
setupTestCommon
(
true
)
;
startSjsServer
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_DISABLEDFORTESTING
false
)
;
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
false
)
;
let
origAppUpdateAutoVal
=
await
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
origAppUpdateAutoVal
)
;
}
)
;
await
multi_update_test
(
true
)
;
await
reloadUpdateManagerData
(
true
)
;
await
multi_update_test
(
false
)
;
await
doTestFinish
(
)
;
}
)
;
