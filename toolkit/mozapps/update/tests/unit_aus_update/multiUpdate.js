let
{
HttpServer
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
httpd
.
sys
.
mjs
"
)
;
const
REL_PATH_DATA
=
"
"
;
const
APP_UPDATE_SJS_HOST
=
"
http
:
/
/
127
.
0
.
0
.
1
:
8888
"
;
const
URL_PATH_UPDATE_XML
=
"
/
"
+
REL_PATH_DATA
+
"
app_update
.
sjs
"
;
const
APP_UPDATE_SJS_URL
=
APP_UPDATE_SJS_HOST
+
URL_PATH_UPDATE_XML
;
const
CONTINUE_CHECK
=
"
continueCheck
"
;
const
CONTINUE_DOWNLOAD
=
"
continueDownload
"
;
const
CONTINUE_STAGING
=
"
continueStaging
"
;
const
FIRST_UPDATE_VERSION
=
"
999998
.
0
"
;
const
SECOND_UPDATE_VERSION
=
"
999999
.
0
"
;
async
function
downloadUpdate
(
appUpdateAuto
onDownloadStartCallback
)
{
let
downloadFinishedPromise
=
waitForEvent
(
"
update
-
downloaded
"
)
;
let
updateAvailablePromise
;
if
(
!
appUpdateAuto
)
{
updateAvailablePromise
=
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
status
)
=
>
{
Services
.
obs
.
removeObserver
(
observer
"
update
-
available
"
)
;
subject
.
QueryInterface
(
Ci
.
nsIUpdate
)
;
resolve
(
{
update
:
subject
status
}
)
;
}
;
Services
.
obs
.
addObserver
(
observer
"
update
-
available
"
)
;
}
)
;
}
let
waitToStartPromise
=
new
Promise
(
resolve
=
>
{
let
listener
=
{
onStartRequest
:
async
_aRequest
=
>
{
gAUS
.
removeDownloadListener
(
listener
)
;
await
onDownloadStartCallback
(
)
;
resolve
(
)
;
}
onProgress
:
(
_aRequest
_aContext
_aProgress
_aMaxProgress
)
=
>
{
}
onStatus
:
(
_aRequest
_aStatus
_aStatusText
)
=
>
{
}
onStopRequest
(
_request
_status
)
{
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIRequestObserver
"
"
nsIProgressEventSink
"
]
)
}
;
gAUS
.
addDownloadListener
(
listener
)
;
}
)
;
let
updateCheckStarted
=
await
gAUS
.
checkForBackgroundUpdates
(
)
;
Assert
.
ok
(
updateCheckStarted
"
Update
check
should
have
started
"
)
;
if
(
!
appUpdateAuto
)
{
let
{
update
status
}
=
await
updateAvailablePromise
;
Assert
.
equal
(
status
"
show
-
prompt
"
"
Should
attempt
to
show
the
update
-
available
prompt
"
)
;
await
gAUS
.
downloadUpdate
(
update
true
)
;
}
await
waitToStartPromise
;
await
continueFileHandler
(
CONTINUE_DOWNLOAD
)
;
await
downloadFinishedPromise
;
await
TestUtils
.
waitForTick
(
)
;
}
async
function
testUpdateDoesNotDownload
(
)
{
let
check
=
gUpdateChecker
.
checkForUpdates
(
gUpdateChecker
.
BACKGROUND_CHECK
)
;
let
result
=
await
check
.
result
;
Assert
.
ok
(
result
.
checksAllowed
"
Should
be
able
to
check
for
updates
"
)
;
Assert
.
ok
(
result
.
succeeded
"
Update
check
should
have
succeeded
"
)
;
Assert
.
equal
(
result
.
updates
.
length
1
"
Should
have
gotten
1
update
in
update
check
"
)
;
let
update
=
result
.
updates
[
0
]
;
let
downloadResult
=
await
gAUS
.
downloadUpdate
(
update
true
)
;
Assert
.
equal
(
downloadResult
Ci
.
nsIApplicationUpdateService
.
DOWNLOAD_FAILURE_GENERIC
"
Expected
that
we
would
not
start
downloading
an
update
"
)
;
let
updateAvailableObserved
=
false
;
let
observer
=
(
_subject
_topic
_status
)
=
>
{
updateAvailableObserved
=
true
;
}
;
Services
.
obs
.
addObserver
(
observer
"
update
-
available
"
)
;
await
gAUS
.
onCheckComplete
(
result
)
;
Services
.
obs
.
removeObserver
(
observer
"
update
-
available
"
)
;
Assert
.
equal
(
updateAvailableObserved
false
"
update
-
available
notification
should
not
fire
if
we
aren
'
t
going
to
"
+
"
download
the
update
.
"
)
;
}
async
function
testUpdateCheckDoesNotStart
(
)
{
let
updateCheckStarted
=
await
gAUS
.
checkForBackgroundUpdates
(
)
;
Assert
.
equal
(
updateCheckStarted
false
"
Update
check
should
not
have
started
"
)
;
}
function
prepareToDownloadVersion
(
version
onlyCompleteMar
=
false
)
{
let
updateUrl
=
{
APP_UPDATE_SJS_URL
}
?
useSlowDownloadMar
=
1
&
useFirstByteEarly
=
1
&
appVersion
=
{
version
}
;
if
(
onlyCompleteMar
)
{
updateUrl
+
=
"
&
completePatchOnly
=
1
"
;
}
setUpdateURL
(
updateUrl
)
;
}
function
startUpdateServer
(
)
{
let
httpServer
=
new
HttpServer
(
)
;
httpServer
.
registerContentType
(
"
sjs
"
"
sjs
"
)
;
httpServer
.
registerDirectory
(
"
/
"
do_get_cwd
(
)
)
;
httpServer
.
start
(
8888
)
;
registerCleanupFunction
(
async
function
cleanup_httpServer
(
)
{
await
new
Promise
(
resolve
=
>
{
httpServer
.
stop
(
resolve
)
;
}
)
;
}
)
;
}
async
function
multi_update_test
(
appUpdateAuto
)
{
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
appUpdateAuto
)
;
prepareToDownloadVersion
(
FIRST_UPDATE_VERSION
)
;
await
downloadUpdate
(
appUpdateAuto
async
(
)
=
>
{
const
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
const
downloadingUpdate
=
await
gUpdateManager
.
getDownloadingUpdate
(
)
;
Assert
.
ok
(
!
readyUpdate
"
There
should
not
be
a
ready
update
yet
"
)
;
Assert
.
ok
(
!
!
downloadingUpdate
"
First
update
download
should
be
in
downloadingUpdate
"
)
;
Assert
.
equal
(
downloadingUpdate
.
state
STATE_DOWNLOADING
"
downloadingUpdate
should
be
downloading
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_DOWNLOADING
"
Updater
state
should
be
downloading
"
)
;
}
)
;
let
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
let
downloadingUpdate
=
await
gUpdateManager
.
getDownloadingUpdate
(
)
;
Assert
.
ok
(
!
downloadingUpdate
"
First
update
download
should
no
longer
be
in
downloadingUpdate
"
)
;
Assert
.
ok
(
!
!
readyUpdate
"
First
update
download
should
be
in
readyUpdate
"
)
;
Assert
.
equal
(
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
be
pending
"
)
;
Assert
.
equal
(
readyUpdate
.
appVersion
FIRST_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
first
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
be
pending
"
)
;
let
existingUpdate
=
readyUpdate
;
await
testUpdateDoesNotDownload
(
)
;
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
Assert
.
equal
(
readyUpdate
existingUpdate
"
readyUpdate
should
not
have
changed
when
no
newer
update
is
available
"
)
;
Assert
.
equal
(
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
still
be
pending
"
)
;
Assert
.
equal
(
readyUpdate
.
appVersion
FIRST_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
first
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
still
be
pending
"
)
;
prepareToDownloadVersion
(
SECOND_UPDATE_VERSION
true
)
;
await
testUpdateDoesNotDownload
(
)
;
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
Assert
.
equal
(
readyUpdate
existingUpdate
"
readyUpdate
should
not
have
changed
when
no
newer
partial
update
is
available
"
)
;
Assert
.
equal
(
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
still
be
pending
"
)
;
Assert
.
equal
(
readyUpdate
.
appVersion
FIRST_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
first
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
still
be
pending
"
)
;
prepareToDownloadVersion
(
SECOND_UPDATE_VERSION
)
;
await
downloadUpdate
(
appUpdateAuto
async
(
)
=
>
{
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
downloadingUpdate
=
await
gUpdateManager
.
getDownloadingUpdate
(
)
;
Assert
.
ok
(
!
!
downloadingUpdate
"
Second
update
download
should
be
in
downloadingUpdate
"
)
;
Assert
.
equal
(
downloadingUpdate
.
state
STATE_DOWNLOADING
"
downloadingUpdate
should
be
downloading
"
)
;
Assert
.
ok
(
!
!
readyUpdate
"
First
update
download
should
still
be
in
readyUpdate
"
)
;
Assert
.
equal
(
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
still
be
pending
"
)
;
Assert
.
equal
(
readyUpdate
.
appVersion
FIRST_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
first
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
match
the
readyUpdate
'
s
state
"
)
;
}
)
;
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
downloadingUpdate
=
await
gUpdateManager
.
getDownloadingUpdate
(
)
;
Assert
.
ok
(
!
downloadingUpdate
"
Second
update
download
should
no
longer
be
in
downloadingUpdate
"
)
;
Assert
.
ok
(
!
!
readyUpdate
"
Second
update
download
should
be
in
readyUpdate
"
)
;
Assert
.
equal
(
readyUpdate
.
state
STATE_PENDING
"
readyUpdate
should
be
pending
"
)
;
Assert
.
equal
(
readyUpdate
.
appVersion
SECOND_UPDATE_VERSION
"
readyUpdate
version
should
be
match
the
version
of
the
second
update
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_PENDING
"
Updater
state
should
be
pending
"
)
;
await
reloadUpdateManagerData
(
true
)
;
prepareToDownloadVersion
(
FIRST_UPDATE_VERSION
true
)
;
await
downloadUpdate
(
appUpdateAuto
async
(
)
=
>
{
downloadingUpdate
=
await
gUpdateManager
.
getDownloadingUpdate
(
)
;
Assert
.
equal
(
downloadingUpdate
.
selectedPatch
.
type
"
complete
"
"
First
update
download
should
be
a
complete
patch
"
)
;
}
)
;
readyUpdate
=
await
gUpdateManager
.
getReadyUpdate
(
)
;
Assert
.
equal
(
readyUpdate
.
selectedPatch
.
type
"
complete
"
"
First
update
download
should
be
a
complete
patch
"
)
;
prepareToDownloadVersion
(
SECOND_UPDATE_VERSION
)
;
await
testUpdateCheckDoesNotStart
(
)
;
}
add_task
(
async
function
all_multi_update_tests
(
)
{
setupTestCommon
(
true
)
;
startUpdateServer
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_DISABLEDFORTESTING
false
)
;
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
false
)
;
let
origAppUpdateAutoVal
=
await
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
origAppUpdateAutoVal
)
;
}
)
;
await
multi_update_test
(
true
)
;
await
reloadUpdateManagerData
(
true
)
;
await
multi_update_test
(
false
)
;
await
doTestFinish
(
)
;
}
)
;
