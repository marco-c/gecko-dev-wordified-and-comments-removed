"
use
strict
"
;
var
TEST_MAR_CONTENTS
=
"
Arbitrary
MAR
contents
"
;
add_task
(
async
function
setup
(
)
{
setupTestCommon
(
)
;
start_httpserver
(
)
;
setUpdateURL
(
gURLData
+
gHTTPHandlerPath
)
;
setUpdateChannel
(
"
test_channel
"
)
;
const
bts
=
Cc
[
"
mozilla
.
org
/
backgroundtasks
;
1
"
]
.
getService
(
Ci
.
nsIBackgroundTasks
)
;
bts
.
overrideBackgroundTaskNameForTesting
(
"
test
-
task
"
)
;
const
downloadingMarFile
=
getUpdateDirFile
(
FILE_UPDATE_MAR
DIR_DOWNLOADING
)
;
await
IOUtils
.
writeUTF8
(
downloadingMarFile
.
path
TEST_MAR_CONTENTS
)
;
writeStatusFile
(
STATE_DOWNLOADING
)
;
let
patchProps
=
{
state
:
STATE_DOWNLOADING
bitsResult
:
Cr
.
NS_ERROR_FAILURE
}
;
let
patches
=
getLocalPatchString
(
patchProps
)
;
let
updateProps
=
{
appVersion
:
"
1
.
0
"
}
;
let
updates
=
getLocalUpdateString
(
updateProps
patches
)
;
writeUpdatesToXMLFile
(
getLocalUpdatesXMLString
(
updates
)
true
)
;
}
)
;
add_task
(
async
function
backgroundUpdate
(
)
{
let
patches
=
getRemotePatchString
(
{
}
)
;
let
updateString
=
getRemoteUpdateString
(
{
}
patches
)
;
gResponseBody
=
getRemoteUpdatesXMLString
(
updateString
)
;
let
{
updates
}
=
await
waitForUpdateCheck
(
true
)
;
let
bestUpdate
=
gAUS
.
selectUpdate
(
updates
)
;
let
success
=
gAUS
.
downloadUpdate
(
bestUpdate
false
)
;
Assert
.
equal
(
success
false
"
We
should
not
attempt
to
download
an
update
in
the
background
when
an
"
+
"
internal
update
download
is
already
in
progress
.
"
)
;
Assert
.
equal
(
readStatusFile
(
)
STATE_DOWNLOADING
"
Background
update
during
an
internally
downloading
update
should
not
"
+
"
change
update
status
"
)
;
const
downloadingMarFile
=
getUpdateDirFile
(
FILE_UPDATE_MAR
DIR_DOWNLOADING
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
downloadingMarFile
.
path
)
"
Downloading
MAR
should
still
exist
"
)
;
Assert
.
equal
(
await
IOUtils
.
readUTF8
(
downloadingMarFile
.
path
)
TEST_MAR_CONTENTS
"
Downloading
MAR
should
not
have
been
modified
"
)
;
}
)
;
add_task
(
async
function
finish
(
)
{
stop_httpserver
(
doTestFinish
)
;
}
)
;
