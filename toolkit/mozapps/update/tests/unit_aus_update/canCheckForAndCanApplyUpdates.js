async
function
run_test
(
)
{
setupTestCommon
(
)
;
debugDump
(
"
testing
write
access
to
the
application
directory
"
)
;
let
testFile
=
getCurrentProcessDir
(
)
;
testFile
.
append
(
"
update_write_access_test
"
)
;
testFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
PERMS_FILE
)
;
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
)
;
testFile
.
remove
(
false
)
;
Assert
.
ok
(
!
testFile
.
exists
(
)
MSG_SHOULD_NOT_EXIST
)
;
let
testUpdateMutexes
=
[
new
TestUpdateMutexInProcess
(
)
new
TestUpdateMutexCrossProcess
(
)
]
;
for
(
let
testUpdateMutex
of
testUpdateMutexes
)
{
debugDump
(
"
attempting
to
acquire
the
"
+
testUpdateMutex
.
kind
+
"
update
mutex
"
)
;
Assert
.
ok
(
await
testUpdateMutex
.
expectAcquire
(
)
"
should
be
able
to
acquire
the
"
+
testUpdateMutex
.
kind
+
"
update
mutex
"
)
;
try
{
Assert
.
ok
(
!
gAUS
.
canCheckForUpdates
"
should
not
be
able
to
check
for
updates
when
the
"
+
testUpdateMutex
.
kind
+
"
update
mutex
is
acquired
"
)
;
Assert
.
ok
(
!
gAUS
.
canApplyUpdates
"
should
not
be
able
to
apply
updates
when
the
"
+
testUpdateMutex
.
kind
+
"
update
mutex
is
acquired
"
)
;
}
finally
{
debugDump
(
"
releasing
the
"
+
testUpdateMutex
.
kind
+
"
update
mutex
"
)
;
await
testUpdateMutex
.
release
(
)
;
}
}
Assert
.
ok
(
gAUS
.
canCheckForUpdates
"
should
be
able
to
check
for
updates
"
)
;
Assert
.
ok
(
gAUS
.
canApplyUpdates
"
should
be
able
to
apply
updates
"
)
;
for
(
let
testUpdateMutex
of
testUpdateMutexes
)
{
debugDump
(
"
attempting
to
acquire
the
"
+
testUpdateMutex
.
kind
+
"
update
mutex
"
)
;
Assert
.
ok
(
await
testUpdateMutex
.
expectFailToAcquire
(
)
"
should
not
be
able
to
acquire
the
"
+
testUpdateMutex
.
kind
+
"
update
mutex
when
the
current
instance
has
already
acquired
it
"
)
;
}
await
doTestFinish
(
)
;
}
