"
use
strict
"
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
{
TestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
MockRegistrar
:
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
sys
.
mjs
"
updateAppInfo
:
"
resource
:
/
/
testing
-
common
/
AppInfo
.
sys
.
mjs
"
}
)
;
const
Cm
=
Components
.
manager
;
load
(
"
.
.
/
data
/
xpcshellConstantsPP
.
js
"
)
;
const
DIR_CONTENTS
=
AppConstants
.
platform
=
=
"
macosx
"
?
"
Contents
/
"
:
"
"
;
const
DIR_MACOS
=
AppConstants
.
platform
=
=
"
macosx
"
?
DIR_CONTENTS
+
"
MacOS
/
"
:
"
"
;
const
DIR_RESOURCES
=
AppConstants
.
platform
=
=
"
macosx
"
?
DIR_CONTENTS
+
"
Resources
/
"
:
"
"
;
const
TEST_FILE_SUFFIX
=
AppConstants
.
platform
=
=
"
macosx
"
?
"
_mac
"
:
"
"
;
const
FILE_COMPLETE_MAR
=
"
complete
"
+
TEST_FILE_SUFFIX
+
"
.
mar
"
;
const
FILE_PARTIAL_MAR
=
"
partial
"
+
TEST_FILE_SUFFIX
+
"
.
mar
"
;
const
FILE_COMPLETE_PRECOMPLETE
=
"
complete_precomplete
"
+
TEST_FILE_SUFFIX
;
const
FILE_PARTIAL_PRECOMPLETE
=
"
partial_precomplete
"
+
TEST_FILE_SUFFIX
;
const
FILE_COMPLETE_REMOVEDFILES
=
"
complete_removed
-
files
"
+
TEST_FILE_SUFFIX
;
const
FILE_PARTIAL_REMOVEDFILES
=
"
partial_removed
-
files
"
+
TEST_FILE_SUFFIX
;
const
FILE_UPDATE_IN_PROGRESS_LOCK
=
"
updated
.
update_in_progress
.
lock
"
;
const
COMPARE_LOG_SUFFIX
=
"
_
"
+
mozinfo
.
os
;
const
LOG_COMPLETE_SUCCESS
=
"
complete_log_success
"
+
COMPARE_LOG_SUFFIX
;
const
LOG_PARTIAL_SUCCESS
=
"
partial_log_success
"
+
COMPARE_LOG_SUFFIX
;
const
LOG_PARTIAL_FAILURE
=
"
partial_log_failure
"
+
COMPARE_LOG_SUFFIX
;
const
LOG_REPLACE_SUCCESS
=
"
replace_log_success
"
;
const
MAC_APP_XATTR_KEY
=
"
com
.
apple
.
application
-
instance
"
;
const
MAC_APP_XATTR_VALUE
=
"
dlsource
%
3Dmozillaci
"
;
const
USE_EXECV
=
AppConstants
.
platform
=
=
"
linux
"
;
const
URL_HOST
=
"
http
:
/
/
localhost
"
;
const
APP_INFO_NAME
=
"
XPCShell
"
;
const
APP_INFO_VENDOR
=
"
Mozilla
"
;
const
APP_BIN_SUFFIX
=
AppConstants
.
platform
=
=
"
linux
"
?
"
-
bin
"
:
mozinfo
.
bin_suffix
;
const
FILE_APP_BIN
=
AppConstants
.
MOZ_APP_NAME
+
APP_BIN_SUFFIX
;
const
FILE_COMPLETE_EXE
=
"
complete
.
exe
"
;
const
FILE_HELPER_BIN
=
AppConstants
.
platform
=
=
"
macosx
"
?
"
callback_app
.
app
/
Contents
/
MacOS
/
TestAUSHelper
"
:
"
TestAUSHelper
"
+
mozinfo
.
bin_suffix
;
const
FILE_HELPER_APP
=
AppConstants
.
platform
=
=
"
macosx
"
?
"
callback_app
.
app
"
:
FILE_HELPER_BIN
;
const
FILE_MAINTENANCE_SERVICE_BIN
=
"
maintenanceservice
.
exe
"
;
const
FILE_MAINTENANCE_SERVICE_INSTALLER_BIN
=
"
maintenanceservice_installer
.
exe
"
;
const
FILE_OLD_VERSION_MAR
=
"
old_version
.
mar
"
;
const
FILE_PARTIAL_EXE
=
"
partial
.
exe
"
;
const
FILE_UPDATER_BIN
=
"
updater
"
+
(
AppConstants
.
platform
=
=
"
macosx
"
?
"
.
app
"
:
mozinfo
.
bin_suffix
)
;
const
PERFORMING_STAGED_UPDATE
=
"
Performing
a
staged
update
"
;
const
CALL_QUIT
=
"
calling
QuitProgressUI
"
;
const
ERR_UPDATE_IN_PROGRESS
=
"
Update
already
in
progress
!
Exiting
"
;
const
ERR_RENAME_FILE
=
"
rename_file
:
failed
to
rename
file
"
;
const
ERR_ENSURE_COPY
=
"
ensure_copy
:
failed
to
copy
the
file
"
;
const
ERR_UNABLE_OPEN_DEST
=
"
unable
to
open
destination
file
"
;
const
ERR_BACKUP_DISCARD
=
"
backup_discard
:
unable
to
remove
"
;
const
ERR_MOVE_DESTDIR_7
=
"
Moving
destDir
to
tmpDir
failed
err
:
7
"
;
const
ERR_BACKUP_CREATE_7
=
"
backup_create
failed
:
7
"
;
const
ERR_LOADSOURCEFILE_FAILED
=
"
LoadSourceFile
failed
"
;
const
ERR_PARENT_PID_PERSISTS
=
"
The
parent
process
didn
'
t
exit
!
Continuing
with
update
.
"
;
const
ERR_BGTASK_EXCLUSIVE
=
"
failed
to
exclusively
open
executable
file
from
background
task
:
"
;
const
LOG_SVC_SUCCESSFUL_LAUNCH
=
"
Process
was
started
.
.
.
waiting
on
result
.
"
;
const
LOG_SVC_UNSUCCESSFUL_LAUNCH
=
"
The
install
directory
path
is
not
valid
for
this
application
.
"
;
const
MSG_SHOULD_EQUAL
=
"
should
equal
the
expected
value
"
;
const
MSG_SHOULD_EXIST
=
"
the
file
or
directory
should
exist
"
;
const
MSG_SHOULD_NOT_EXIST
=
"
the
file
or
directory
should
not
exist
"
;
const
HELPER_SLEEP_TIMEOUT
=
180
;
const
FILE_IN_USE_TIMEOUT_MS
=
1000
;
const
PIPE_TO_NULL
=
AppConstants
.
platform
=
=
"
win
"
?
"
>
nul
"
:
"
>
/
dev
/
null
2
>
&
1
"
;
const
LOG_FUNCTION
=
info
;
const
gHTTPHandlerPath
=
"
updates
.
xml
"
;
var
gIsServiceTest
;
var
gTestID
;
var
gURLData
=
URL_HOST
+
"
/
"
;
var
gTestserver
;
var
gUpdateCheckCount
=
0
;
var
gIncrementalDownloadErrorType
;
var
gResponseBody
;
var
gProcess
;
var
gAppTimer
;
var
gHandle
;
var
gGREDirOrig
;
var
gGREBinDirOrig
;
var
gPIDPersistProcess
;
var
gCallbackArgs
=
[
"
.
/
"
"
callback
.
log
"
"
Test
Arg
2
"
"
Test
Arg
3
"
]
;
var
gCallbackApp
=
(
(
)
=
>
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
return
"
callback_app
.
app
"
;
}
return
"
callback_app
"
+
mozinfo
.
bin_suffix
;
}
)
(
)
;
var
gCallbackBinFile
=
(
(
)
=
>
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
return
FILE_HELPER_BIN
;
}
return
"
callback_app
"
+
mozinfo
.
bin_suffix
;
}
)
(
)
;
var
gPostUpdateBinFile
=
"
postup_app
"
+
mozinfo
.
bin_suffix
;
var
gTimeoutRuns
=
0
;
var
gShouldResetEnv
=
undefined
;
var
gAddedEnvXRENoWindowsCrashDialog
=
false
;
var
gEnvXPCOMDebugBreak
;
var
gEnvXPCOMMemLeakLog
;
var
gEnvForceServiceFallback
=
false
;
const
URL_HTTP_UPDATE_SJS
=
"
http
:
/
/
test_details
/
"
;
const
DATA_URI_SPEC
=
Services
.
io
.
newFileURI
(
do_get_file
(
"
"
false
)
)
.
spec
;
load
(
"
shared
.
js
"
)
;
gDebugTest
=
true
;
var
gDebugTestLog
=
false
;
var
gTestsToLog
=
[
]
;
var
gRealDump
;
var
gFOS
;
var
gUpdateBin
;
var
gTestFiles
=
[
]
;
var
gTestDirs
=
[
]
;
var
gTestFilesCommon
=
[
{
description
:
"
Should
never
change
"
fileName
:
FILE_CHANNEL_PREFS
relPathDir
:
AppConstants
.
platform
=
=
"
macosx
"
?
"
Contents
/
Frameworks
/
ChannelPrefs
.
framework
/
"
:
DIR_RESOURCES
+
"
defaults
/
pref
/
"
originalContents
:
"
ShouldNotBeReplaced
\
n
"
compareContents
:
"
ShouldNotBeReplaced
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o767
comparePerms
:
0o767
}
]
;
var
gTestFilesCommonNonMac
=
[
{
description
:
"
Should
never
change
"
fileName
:
FILE_UPDATE_SETTINGS_INI
relPathDir
:
DIR_RESOURCES
originalContents
:
UPDATE_SETTINGS_CONTENTS
compareContents
:
UPDATE_SETTINGS_CONTENTS
originalFile
:
null
compareFile
:
null
originalPerms
:
0o767
comparePerms
:
0o767
}
]
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
gTestFilesCommon
=
gTestFilesCommon
.
concat
(
gTestFilesCommonNonMac
)
;
}
var
gTestFilesCommonMac
=
[
{
description
:
"
Should
never
change
"
fileName
:
FILE_UPDATE_SETTINGS_FRAMEWORK
relPathDir
:
DIR_MACOS
+
"
updater
.
app
/
Contents
/
Frameworks
/
UpdateSettings
.
framework
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
null
existingFile
:
true
}
{
description
:
"
Should
never
change
"
fileName
:
FILE_INFO_PLIST
relPathDir
:
DIR_CONTENTS
originalContents
:
DIR_APP_INFO_PLIST_FILE_CONTENTS
compareContents
:
DIR_APP_INFO_PLIST_FILE_CONTENTS
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
null
existingFile
:
true
}
{
description
:
"
Should
never
change
"
fileName
:
FILE_INFO_PLIST
relPathDir
:
DIR_MACOS
+
"
updater
.
app
/
Contents
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
null
existingFile
:
true
}
{
description
:
"
Should
never
change
"
fileName
:
FILE_INFO_PLIST
relPathDir
:
DIR_MACOS
+
"
callback_app
.
app
/
Contents
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
null
existingFile
:
true
}
]
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
gTestFilesCommon
=
gTestFilesCommon
.
concat
(
gTestFilesCommonMac
)
;
}
var
gTestFilesCompleteSuccess
=
[
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
precomplete
"
relPathDir
:
DIR_RESOURCES
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_PARTIAL_PRECOMPLETE
compareFile
:
FILE_COMPLETE_PRECOMPLETE
originalPerms
:
0o666
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
searchpluginstext0
"
relPathDir
:
DIR_RESOURCES
+
"
searchplugins
/
"
originalContents
:
"
ToBeReplacedWithFromComplete
\
n
"
compareContents
:
"
FromComplete
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o775
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
searchpluginspng1
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
searchplugins
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
"
complete
.
png
"
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
searchpluginspng0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
searchplugins
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
partial
.
png
"
compareFile
:
"
complete
.
png
"
originalPerms
:
0o666
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
removed
-
files
"
relPathDir
:
DIR_RESOURCES
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_PARTIAL_REMOVEDFILES
compareFile
:
FILE_COMPLETE_REMOVEDFILES
originalPerms
:
0o666
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
exists
(
add
-
if
)
"
fileName
:
"
extensions1text0
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions1
/
"
originalContents
:
null
compareContents
:
"
FromComplete
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
exists
(
add
-
if
)
"
fileName
:
"
extensions1png1
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions1
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
partial
.
png
"
compareFile
:
"
complete
.
png
"
originalPerms
:
0o666
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
exists
(
add
-
if
)
"
fileName
:
"
extensions1png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions1
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
"
complete
.
png
"
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
exists
(
add
-
if
)
"
fileName
:
"
extensions0text0
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions0
/
"
originalContents
:
"
ToBeReplacedWithFromComplete
\
n
"
compareContents
:
"
FromComplete
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
exists
(
add
-
if
)
"
fileName
:
"
extensions0png1
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions0
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
"
complete
.
png
"
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
exists
(
add
-
if
)
"
fileName
:
"
extensions0png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions0
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
"
complete
.
png
"
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
exe0
.
exe
"
relPathDir
:
DIR_MACOS
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_HELPER_BIN
compareFile
:
FILE_COMPLETE_EXE
originalPerms
:
0o777
comparePerms
:
0o755
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
10text0
"
relPathDir
:
DIR_RESOURCES
+
"
1
/
10
/
"
originalContents
:
"
ToBeReplacedWithFromComplete
\
n
"
compareContents
:
"
FromComplete
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o767
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
0exe0
.
exe
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_HELPER_BIN
compareFile
:
FILE_COMPLETE_EXE
originalPerms
:
0o777
comparePerms
:
0o755
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
00text1
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
"
ToBeReplacedWithFromComplete
\
n
"
compareContents
:
"
FromComplete
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o677
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
00text0
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
"
ToBeReplacedWithFromComplete
\
n
"
compareContents
:
"
FromComplete
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o775
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
00png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
"
complete
.
png
"
originalPerms
:
0o776
comparePerms
:
0o644
}
{
description
:
"
Removed
by
precomplete
(
remove
)
"
fileName
:
"
20text0
"
relPathDir
:
DIR_RESOURCES
+
"
2
/
20
/
"
originalContents
:
"
ToBeDeleted
\
n
"
compareContents
:
null
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
null
}
{
description
:
"
Removed
by
precomplete
(
remove
)
"
fileName
:
"
20png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
2
/
20
/
"
originalContents
:
"
ToBeDeleted
\
n
"
compareContents
:
null
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
null
}
]
;
gTestFilesCompleteSuccess
=
gTestFilesCompleteSuccess
.
concat
(
gTestFilesCommon
)
;
var
gTestFilesPartialSuccess
=
[
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
precomplete
"
relPathDir
:
DIR_RESOURCES
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_COMPLETE_PRECOMPLETE
compareFile
:
FILE_PARTIAL_PRECOMPLETE
originalPerms
:
0o666
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
searchpluginstext0
"
relPathDir
:
DIR_RESOURCES
+
"
searchplugins
/
"
originalContents
:
"
ToBeReplacedWithFromPartial
\
n
"
compareContents
:
"
FromPartial
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o775
comparePerms
:
0o644
}
{
description
:
"
Patched
by
update
.
manifest
if
the
file
exists
(
patch
-
if
)
"
fileName
:
"
searchpluginspng1
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
searchplugins
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o666
comparePerms
:
0o666
}
{
description
:
"
Patched
by
update
.
manifest
if
the
file
exists
(
patch
-
if
)
"
fileName
:
"
searchpluginspng0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
searchplugins
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o666
comparePerms
:
0o666
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
exists
(
add
-
if
)
"
fileName
:
"
extensions1text0
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions1
/
"
originalContents
:
null
compareContents
:
"
FromPartial
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Patched
by
update
.
manifest
if
the
parent
directory
exists
(
patch
-
if
)
"
fileName
:
"
extensions1png1
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions1
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o666
comparePerms
:
0o666
}
{
description
:
"
Patched
by
update
.
manifest
if
the
parent
directory
exists
(
patch
-
if
)
"
fileName
:
"
extensions1png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions1
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o666
comparePerms
:
0o666
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
exists
(
add
-
if
)
"
fileName
:
"
extensions0text0
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions0
/
"
originalContents
:
"
ToBeReplacedWithFromPartial
\
n
"
compareContents
:
"
FromPartial
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o644
comparePerms
:
0o644
}
{
description
:
"
Patched
by
update
.
manifest
if
the
parent
directory
exists
(
patch
-
if
)
"
fileName
:
"
extensions0png1
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions0
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o644
comparePerms
:
0o644
}
{
description
:
"
Patched
by
update
.
manifest
if
the
parent
directory
exists
(
patch
-
if
)
"
fileName
:
"
extensions0png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions0
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o644
comparePerms
:
0o644
}
{
description
:
"
Patched
by
update
.
manifest
(
patch
)
"
fileName
:
"
exe0
.
exe
"
relPathDir
:
DIR_MACOS
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_COMPLETE_EXE
compareFile
:
FILE_PARTIAL_EXE
originalPerms
:
0o755
comparePerms
:
0o755
}
{
description
:
"
Patched
by
update
.
manifest
(
patch
)
"
fileName
:
"
0exe0
.
exe
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_COMPLETE_EXE
compareFile
:
FILE_PARTIAL_EXE
originalPerms
:
0o755
comparePerms
:
0o755
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
00text0
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
"
ToBeReplacedWithFromPartial
\
n
"
compareContents
:
"
FromPartial
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o644
comparePerms
:
0o644
}
{
description
:
"
Patched
by
update
.
manifest
(
patch
)
"
fileName
:
"
00png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o666
comparePerms
:
0o666
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
20text0
"
relPathDir
:
DIR_RESOURCES
+
"
2
/
20
/
"
originalContents
:
null
compareContents
:
"
FromPartial
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
20png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
2
/
20
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
"
partial
.
png
"
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
00text2
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
null
compareContents
:
"
FromPartial
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Removed
by
update
.
manifest
(
remove
)
"
fileName
:
"
10text0
"
relPathDir
:
DIR_RESOURCES
+
"
1
/
10
/
"
originalContents
:
"
ToBeDeleted
\
n
"
compareContents
:
null
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
null
}
{
description
:
"
Removed
by
update
.
manifest
(
remove
)
"
fileName
:
"
00text1
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
"
ToBeDeleted
\
n
"
compareContents
:
null
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
null
}
]
;
gTestFilesPartialSuccess
=
gTestFilesPartialSuccess
.
concat
(
gTestFilesCommon
)
;
function
getTestFileByName
(
filename
)
{
return
gTestFiles
.
find
(
f
=
>
f
.
fileName
=
=
filename
)
?
?
null
;
}
var
gTestDirsCommon
=
[
{
relPathDir
:
DIR_RESOURCES
+
"
3
/
"
dirRemoved
:
false
files
:
[
"
3text0
"
"
3text1
"
]
filesRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
4
/
"
dirRemoved
:
true
files
:
[
"
4text0
"
"
4text1
"
]
filesRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
5
/
"
dirRemoved
:
true
files
:
[
"
5test
.
exe
"
"
5text0
"
"
5text1
"
]
filesRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
6
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
7
/
"
dirRemoved
:
true
files
:
[
"
7text0
"
"
7text1
"
]
subDirs
:
[
"
70
/
"
"
71
/
"
]
subDirFiles
:
[
"
7xtest
.
exe
"
"
7xtext0
"
"
7xtext1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
"
dirRemoved
:
false
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
80
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
81
/
"
dirRemoved
:
false
files
:
[
"
81text0
"
"
81text1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
82
/
"
dirRemoved
:
false
subDirs
:
[
"
820
/
"
"
821
/
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
83
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
84
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
85
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
86
/
"
dirRemoved
:
true
files
:
[
"
86text0
"
"
86text1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
87
/
"
dirRemoved
:
true
subDirs
:
[
"
870
/
"
"
871
/
"
]
subDirFiles
:
[
"
87xtext0
"
"
87xtext1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
88
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
89
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
90
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
91
/
"
dirRemoved
:
false
files
:
[
"
91text0
"
"
91text1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
92
/
"
dirRemoved
:
false
subDirs
:
[
"
920
/
"
"
921
/
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
93
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
94
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
95
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
96
/
"
dirRemoved
:
true
files
:
[
"
96text0
"
"
96text1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
97
/
"
dirRemoved
:
true
subDirs
:
[
"
970
/
"
"
971
/
"
]
subDirFiles
:
[
"
97xtext0
"
"
97xtext1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
98
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
99
/
"
dirRemoved
:
true
}
{
description
:
"
Silences
'
WARNING
:
Failed
to
resolve
XUL
App
Dir
.
'
in
debug
builds
"
relPathDir
:
DIR_RESOURCES
+
"
browser
"
dirRemoved
:
false
}
]
;
var
gTestDirsCompleteSuccess
=
[
{
description
:
"
Removed
by
precomplete
(
rmdir
)
"
relPathDir
:
DIR_RESOURCES
+
"
2
/
20
/
"
dirRemoved
:
true
}
{
description
:
"
Removed
by
precomplete
(
rmdir
)
"
relPathDir
:
DIR_RESOURCES
+
"
2
/
"
dirRemoved
:
true
}
]
;
gTestDirsCompleteSuccess
=
gTestDirsCommon
.
concat
(
gTestDirsCompleteSuccess
)
;
var
gTestDirsPartialSuccess
=
[
{
description
:
"
Removed
by
update
.
manifest
(
rmdir
)
"
relPathDir
:
DIR_RESOURCES
+
"
1
/
10
/
"
dirRemoved
:
true
}
{
description
:
"
Removed
by
update
.
manifest
(
rmdir
)
"
relPathDir
:
DIR_RESOURCES
+
"
1
/
"
dirRemoved
:
true
}
]
;
gTestDirsPartialSuccess
=
gTestDirsCommon
.
concat
(
gTestDirsPartialSuccess
)
;
function
setupTestCommon
(
aAppUpdateAutoEnabled
=
false
aAllowBits
=
false
)
{
debugDump
(
"
start
-
general
test
setup
"
)
;
Assert
.
strictEqual
(
gTestID
undefined
"
gTestID
should
be
'
undefined
'
(
setupTestCommon
should
"
+
"
only
be
called
once
)
"
)
;
let
caller
=
Components
.
stack
.
caller
;
gTestID
=
caller
.
filename
.
toString
(
)
.
split
(
"
/
"
)
.
pop
(
)
.
split
(
"
.
"
)
[
0
]
;
if
(
gDebugTestLog
&
&
!
gIsServiceTest
)
{
if
(
!
gTestsToLog
.
length
|
|
gTestsToLog
.
includes
(
gTestID
)
)
{
let
logFile
=
do_get_file
(
gTestID
+
"
.
log
"
true
)
;
if
(
!
logFile
.
exists
(
)
)
{
logFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
PERMS_FILE
)
;
}
gFOS
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
gFOS
.
init
(
logFile
MODE_WRONLY
|
MODE_APPEND
PERMS_FILE
0
)
;
gRealDump
=
dump
;
dump
=
dumpOverride
;
}
}
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
APP_INFO_NAME
"
1
.
0
"
"
2
.
0
"
)
;
if
(
gIsServiceTest
&
&
!
shouldRunServiceTest
(
)
)
{
return
false
;
}
do_test_pending
(
)
;
setDefaultPrefs
(
)
;
gGREDirOrig
=
getGREDir
(
)
;
gGREBinDirOrig
=
getGREBinDir
(
)
;
let
applyDir
=
getApplyDirFile
(
)
.
parent
;
if
(
applyDir
.
exists
(
)
)
{
debugDump
(
"
attempting
to
remove
directory
.
Path
:
"
+
applyDir
.
path
)
;
try
{
removeDirRecursive
(
applyDir
)
;
}
catch
(
e
)
{
logTestInfo
(
"
non
-
fatal
error
removing
directory
.
Path
:
"
+
applyDir
.
path
+
"
Exception
:
"
+
e
)
;
gTestID
+
=
"
_new
"
;
logTestInfo
(
"
using
a
new
directory
for
the
test
by
changing
gTestID
"
+
"
since
there
is
an
existing
test
directory
that
can
'
t
be
"
+
"
removed
gTestID
:
"
+
gTestID
)
;
}
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_SERVICE_ENABLED
!
!
gIsServiceTest
)
;
}
if
(
gIsServiceTest
)
{
let
exts
=
[
"
id
"
"
log
"
"
status
"
]
;
for
(
let
i
=
0
;
i
<
exts
.
length
;
+
+
i
)
{
let
file
=
getSecureOutputFile
(
exts
[
i
]
)
;
if
(
file
.
exists
(
)
)
{
try
{
file
.
remove
(
false
)
;
}
catch
(
e
)
{
}
}
}
}
adjustGeneralPaths
(
)
;
createWorldWritableAppUpdateDir
(
)
;
debugDump
(
"
Updates
Directory
(
UpdRootD
)
Path
:
"
+
getMockUpdRootD
(
)
.
path
)
;
let
grePrefsFile
=
getGREDir
(
)
;
if
(
!
grePrefsFile
.
exists
(
)
)
{
grePrefsFile
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
PERMS_DIRECTORY
)
;
}
grePrefsFile
.
append
(
"
greprefs
.
js
"
)
;
if
(
!
grePrefsFile
.
exists
(
)
)
{
grePrefsFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
PERMS_FILE
)
;
}
debugDump
(
"
resetting
update
lock
"
)
;
let
syncManager
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
sync
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateSyncManager
)
;
syncManager
.
resetLock
(
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
|
|
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
updatesDir
=
getMockUpdRootD
(
)
;
if
(
updatesDir
.
exists
(
)
)
{
debugDump
(
"
attempting
to
remove
directory
.
Path
:
"
+
updatesDir
.
path
)
;
try
{
removeDirRecursive
(
updatesDir
)
;
}
catch
(
e
)
{
logTestInfo
(
"
non
-
fatal
error
removing
directory
.
Path
:
"
+
updatesDir
.
path
+
"
Exception
:
"
+
e
)
;
}
}
}
setAppUpdateAutoSync
(
aAppUpdateAutoEnabled
)
;
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_BITS_ENABLED
aAllowBits
)
;
debugDump
(
"
finish
-
general
test
setup
"
)
;
return
true
;
}
function
cleanupTestCommon
(
)
{
debugDump
(
"
start
-
general
test
cleanup
"
)
;
if
(
gChannel
)
{
gPrefRoot
.
removeObserver
(
PREF_APP_UPDATE_CHANNEL
observer
)
;
}
gTestserver
=
null
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
|
|
AppConstants
.
platform
=
=
"
linux
"
)
{
getLaunchScript
(
)
;
}
if
(
gIsServiceTest
)
{
let
exts
=
[
"
id
"
"
log
"
"
status
"
]
;
for
(
let
i
=
0
;
i
<
exts
.
length
;
+
+
i
)
{
let
file
=
getSecureOutputFile
(
exts
[
i
]
)
;
if
(
file
.
exists
(
)
)
{
try
{
file
.
remove
(
false
)
;
}
catch
(
e
)
{
}
}
}
}
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
MOZ_APP_BASENAME
)
{
let
appDir
=
getApplyDirFile
(
)
;
let
vendor
=
MOZ_APP_VENDOR
?
MOZ_APP_VENDOR
:
"
Mozilla
"
;
const
REG_PATH
=
"
SOFTWARE
\
\
"
+
vendor
+
"
\
\
"
+
MOZ_APP_BASENAME
+
"
\
\
TaskBarIDs
"
;
let
key
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
try
{
key
.
open
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_LOCAL_MACHINE
REG_PATH
Ci
.
nsIWindowsRegKey
.
ACCESS_ALL
)
;
if
(
key
.
hasValue
(
appDir
.
path
)
)
{
key
.
removeValue
(
appDir
.
path
)
;
}
}
catch
(
e
)
{
}
try
{
key
.
open
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
REG_PATH
Ci
.
nsIWindowsRegKey
.
ACCESS_ALL
)
;
if
(
key
.
hasValue
(
appDir
.
path
)
)
{
key
.
removeValue
(
appDir
.
path
)
;
}
}
catch
(
e
)
{
}
}
if
(
AppConstants
.
platform
=
=
"
win
"
|
|
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
updatesDir
=
getMockUpdRootD
(
)
;
if
(
updatesDir
.
exists
(
)
)
{
debugDump
(
"
attempting
to
remove
directory
.
Path
:
"
+
updatesDir
.
path
)
;
try
{
removeDirRecursive
(
updatesDir
)
;
}
catch
(
e
)
{
logTestInfo
(
"
non
-
fatal
error
removing
directory
.
Path
:
"
+
updatesDir
.
path
+
"
Exception
:
"
+
e
)
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
updatesRootDir
=
gUpdatesRootDir
.
clone
(
)
;
while
(
updatesRootDir
.
path
!
=
updatesDir
.
path
)
{
if
(
updatesDir
.
exists
(
)
)
{
debugDump
(
"
attempting
to
remove
directory
.
Path
:
"
+
updatesDir
.
path
)
;
try
{
updatesDir
.
remove
(
false
)
;
}
catch
(
e
)
{
logTestInfo
(
"
non
-
fatal
error
removing
directory
.
Path
:
"
+
updatesDir
.
path
+
"
Exception
:
"
+
e
)
;
if
(
e
=
=
Cr
.
NS_ERROR_FILE_DIR_NOT_EMPTY
)
{
break
;
}
}
}
updatesDir
=
updatesDir
.
parent
;
}
}
}
}
let
applyDir
=
getApplyDirFile
(
)
.
parent
;
if
(
applyDir
.
exists
(
)
)
{
debugDump
(
"
attempting
to
remove
directory
.
Path
:
"
+
applyDir
.
path
)
;
try
{
removeDirRecursive
(
applyDir
)
;
}
catch
(
e
)
{
logTestInfo
(
"
non
-
fatal
error
removing
directory
.
Path
:
"
+
applyDir
.
path
+
"
Exception
:
"
+
e
)
;
}
}
resetEnvironment
(
)
;
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_BITS_ENABLED
)
;
debugDump
(
"
finish
-
general
test
cleanup
"
)
;
if
(
gRealDump
)
{
dump
=
gRealDump
;
gRealDump
=
null
;
}
if
(
gFOS
)
{
gFOS
.
close
(
)
;
}
}
function
dumpOverride
(
aText
)
{
gFOS
.
write
(
aText
aText
.
length
)
;
gRealDump
(
aText
)
;
}
async
function
doTestFinish
(
)
{
if
(
gDebugTest
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_LOG
false
)
;
gAUS
.
observe
(
null
"
nsPref
:
changed
"
PREF_APP_UPDATE_LOG
)
;
}
await
reloadUpdateManagerData
(
true
)
;
gAUS
.
observe
(
null
"
quit
-
application
"
"
"
)
;
executeSoon
(
do_test_finished
)
;
}
function
setDefaultPrefs
(
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_DISABLEDFORTESTING
false
)
;
if
(
gDebugTest
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_LOG
true
)
;
}
else
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_LOG
false
)
;
}
}
function
setTestFilesAndDirsForFailure
(
)
{
gTestFiles
.
forEach
(
function
STFADFF_Files
(
aTestFile
)
{
aTestFile
.
compareContents
=
aTestFile
.
originalContents
;
aTestFile
.
compareFile
=
aTestFile
.
originalFile
;
aTestFile
.
comparePerms
=
aTestFile
.
originalPerms
;
}
)
;
gTestDirs
.
forEach
(
function
STFADFF_Dirs
(
aTestDir
)
{
aTestDir
.
dirRemoved
=
false
;
if
(
aTestDir
.
filesRemoved
)
{
aTestDir
.
filesRemoved
=
false
;
}
}
)
;
}
function
preventDistributionFiles
(
)
{
gTestFiles
=
gTestFiles
.
filter
(
function
(
aTestFile
)
{
return
!
aTestFile
.
relPathDir
.
includes
(
"
distribution
/
"
)
;
}
)
;
gTestDirs
=
gTestDirs
.
filter
(
function
(
aTestDir
)
{
return
!
aTestDir
.
relPathDir
.
includes
(
"
distribution
/
"
)
;
}
)
;
}
function
setAppBundleModTime
(
)
{
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
return
;
}
let
now
=
Date
.
now
(
)
;
let
yesterday
=
now
-
1000
*
60
*
60
*
24
;
let
applyToDir
=
getApplyDirFile
(
)
;
applyToDir
.
lastModifiedTime
=
yesterday
;
}
function
checkAppBundleModTime
(
)
{
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
return
;
}
const
MAC_MAX_TIME_DIFFERENCE
=
60000
;
let
now
=
Date
.
now
(
)
;
let
applyToDir
=
getApplyDirFile
(
)
;
let
timeDiff
=
Math
.
abs
(
applyToDir
.
lastModifiedTime
-
now
)
;
Assert
.
ok
(
timeDiff
<
MAC_MAX_TIME_DIFFERENCE
"
the
last
modified
time
on
the
apply
to
directory
should
"
+
"
change
after
a
successful
update
"
)
;
}
async
function
checkUpdateManager
(
aStatusFileState
aHasActiveUpdate
aUpdateStatusState
aUpdateErrCode
aUpdateCount
)
{
let
activeUpdate
=
await
(
aUpdateStatusState
=
=
STATE_DOWNLOADING
?
gUpdateManager
.
getDownloadingUpdate
(
)
:
gUpdateManager
.
getReadyUpdate
(
)
)
;
Assert
.
equal
(
readStatusState
(
)
aStatusFileState
"
the
status
file
state
"
+
MSG_SHOULD_EQUAL
)
;
let
msgTags
=
[
"
after
startup
"
"
after
a
file
reload
"
]
;
for
(
let
i
=
0
;
i
<
msgTags
.
length
;
+
+
i
)
{
logTestInfo
(
"
checking
Update
Manager
updates
"
+
msgTags
[
i
]
+
"
is
performed
"
)
;
if
(
aHasActiveUpdate
)
{
Assert
.
ok
(
!
!
activeUpdate
msgTags
[
i
]
+
"
the
active
update
should
be
defined
"
)
;
}
else
{
Assert
.
ok
(
!
activeUpdate
msgTags
[
i
]
+
"
the
active
update
should
not
be
defined
"
)
;
}
const
history
=
await
gUpdateManager
.
getHistory
(
)
;
Assert
.
equal
(
history
.
length
aUpdateCount
msgTags
[
i
]
+
"
the
update
manager
updateCount
attribute
"
+
MSG_SHOULD_EQUAL
)
;
if
(
aUpdateCount
>
0
)
{
let
update
=
history
[
0
]
;
Assert
.
equal
(
update
.
state
aUpdateStatusState
msgTags
[
i
]
+
"
the
first
update
state
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
update
.
errorCode
aUpdateErrCode
msgTags
[
i
]
+
"
the
first
update
errorCode
"
+
MSG_SHOULD_EQUAL
)
;
}
if
(
i
!
=
msgTags
.
length
-
1
)
{
reloadUpdateManagerData
(
)
;
}
}
}
async
function
waitForUpdateXMLFiles
(
aActiveUpdateExists
=
false
aUpdatesExists
=
true
)
{
function
areFilesStabilized
(
)
{
let
file
=
getUpdateDirFile
(
FILE_ACTIVE_UPDATE_XML_TMP
)
;
if
(
file
.
exists
(
)
)
{
debugDump
(
"
file
exists
Path
:
"
+
file
.
path
)
;
return
false
;
}
file
=
getUpdateDirFile
(
FILE_UPDATES_XML_TMP
)
;
if
(
file
.
exists
(
)
)
{
debugDump
(
"
file
exists
Path
:
"
+
file
.
path
)
;
return
false
;
}
file
=
getUpdateDirFile
(
FILE_ACTIVE_UPDATE_XML
)
;
if
(
file
.
exists
(
)
!
=
aActiveUpdateExists
)
{
debugDump
(
"
file
exists
should
equal
:
"
+
aActiveUpdateExists
+
"
Path
:
"
+
file
.
path
)
;
return
false
;
}
file
=
getUpdateDirFile
(
FILE_UPDATES_XML
)
;
if
(
file
.
exists
(
)
!
=
aUpdatesExists
)
{
debugDump
(
"
file
exists
should
equal
:
"
+
aActiveUpdateExists
+
"
Path
:
"
+
file
.
path
)
;
return
false
;
}
return
true
;
}
await
TestUtils
.
waitForCondition
(
(
)
=
>
areFilesStabilized
(
)
"
Waiting
for
update
xml
files
to
stabilize
"
)
;
}
function
checkPostUpdateRunningFile
(
aShouldExist
)
{
if
(
AppConstants
.
platform
=
=
"
linux
"
)
{
return
;
}
let
postUpdateRunningFile
=
getPostUpdateFile
(
"
.
running
"
)
;
if
(
aShouldExist
)
{
Assert
.
ok
(
postUpdateRunningFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
postUpdateRunningFile
.
path
)
)
;
}
else
{
Assert
.
ok
(
!
postUpdateRunningFile
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
postUpdateRunningFile
.
path
)
)
;
}
}
async
function
standardInit
(
)
{
await
initUpdateServiceStub
(
)
;
}
function
getAppVersion
(
)
{
let
iniFile
=
gGREDirOrig
.
clone
(
)
;
iniFile
.
append
(
FILE_APPLICATION_INI
)
;
if
(
!
iniFile
.
exists
(
)
)
{
iniFile
=
gGREBinDirOrig
.
clone
(
)
;
iniFile
.
append
(
FILE_APPLICATION_INI
)
;
}
Assert
.
ok
(
iniFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
iniFile
.
path
)
)
;
let
iniParser
=
Cc
[
"
mozilla
.
org
/
xpcom
/
ini
-
parser
-
factory
;
1
"
]
.
getService
(
Ci
.
nsIINIParserFactory
)
.
createINIParser
(
iniFile
)
;
return
iniParser
.
getString
(
"
App
"
"
Version
"
)
;
}
function
getApplyDirPath
(
)
{
if
(
gIsServiceTest
&
&
IS_AUTHENTICODE_CHECK_ENABLED
)
{
let
dir
=
getMaintSvcDir
(
)
;
dir
.
append
(
gTestID
)
;
dir
.
append
(
"
dir
.
app
"
)
;
return
dir
.
path
;
}
return
gTestID
+
"
/
dir
.
app
/
"
;
}
function
getApplyDirFile
(
aRelPath
)
{
if
(
gIsServiceTest
&
&
IS_AUTHENTICODE_CHECK_ENABLED
)
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
getApplyDirPath
(
)
)
;
if
(
aRelPath
)
{
if
(
aRelPath
=
=
"
.
.
"
)
{
file
=
file
.
parent
;
}
else
{
aRelPath
=
aRelPath
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
file
.
appendRelativePath
(
aRelPath
)
;
}
}
return
file
;
}
let
relpath
=
getApplyDirPath
(
)
+
(
aRelPath
?
aRelPath
:
"
"
)
;
return
do_get_file
(
relpath
true
)
;
}
function
getTestDirPath
(
)
{
return
"
.
.
/
data
/
"
;
}
function
getTestDirFile
(
aRelPath
aAllowNonExists
)
{
let
relpath
=
getTestDirPath
(
)
+
(
aRelPath
?
aRelPath
:
"
"
)
;
return
do_get_file
(
relpath
!
!
aAllowNonExists
)
;
}
function
getMaintSvcDir
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
const
CSIDL_PROGRAM_FILES
=
0x26
;
const
CSIDL_PROGRAM_FILESX86
=
0x2a
;
let
maintSvcDir
=
getSpecialFolderDir
(
CSIDL_PROGRAM_FILESX86
)
;
if
(
maintSvcDir
)
{
maintSvcDir
.
append
(
"
Mozilla
Maintenance
Service
"
)
;
debugDump
(
"
using
CSIDL_PROGRAM_FILESX86
-
maintenance
service
install
"
+
"
directory
path
:
"
+
maintSvcDir
.
path
)
;
}
if
(
!
maintSvcDir
|
|
!
maintSvcDir
.
exists
(
)
)
{
maintSvcDir
=
getSpecialFolderDir
(
CSIDL_PROGRAM_FILES
)
;
if
(
maintSvcDir
)
{
maintSvcDir
.
append
(
"
Mozilla
Maintenance
Service
"
)
;
debugDump
(
"
using
CSIDL_PROGRAM_FILES
-
maintenance
service
install
"
+
"
directory
path
:
"
+
maintSvcDir
.
path
)
;
}
}
if
(
!
maintSvcDir
)
{
do_throw
(
"
Unable
to
find
the
maintenance
service
install
directory
"
)
;
}
return
maintSvcDir
;
}
function
readSecureStatusFile
(
)
{
let
file
=
getSecureOutputFile
(
"
status
"
)
;
if
(
!
file
.
exists
(
)
)
{
debugDump
(
"
update
status
file
does
not
exist
path
:
"
+
file
.
path
)
;
return
STATE_NONE
;
}
return
readFile
(
file
)
.
split
(
"
\
n
"
)
[
0
]
;
}
function
getSecureOutputFile
(
aFileExt
)
{
let
file
=
getMaintSvcDir
(
)
;
file
.
append
(
"
UpdateLogs
"
)
;
file
.
append
(
gTestID
+
"
.
"
+
aFileExt
)
;
return
file
;
}
function
getSpecialFolderDir
(
aCSIDL
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
let
lib
=
ctypes
.
open
(
"
shell32
"
)
;
let
SHGetSpecialFolderPath
=
lib
.
declare
(
"
SHGetSpecialFolderPathW
"
ctypes
.
winapi_abi
ctypes
.
bool
ctypes
.
int32_t
ctypes
.
char16_t
.
ptr
ctypes
.
int32_t
ctypes
.
bool
)
;
let
aryPath
=
ctypes
.
char16_t
.
array
(
)
(
260
)
;
let
rv
=
SHGetSpecialFolderPath
(
0
aryPath
aCSIDL
false
)
;
if
(
!
rv
)
{
do_throw
(
"
SHGetSpecialFolderPath
failed
to
retrieve
"
+
aCSIDL
+
"
with
Win32
error
"
+
ctypes
.
winLastError
)
;
}
lib
.
close
(
)
;
let
path
=
aryPath
.
readString
(
)
;
if
(
!
path
)
{
return
null
;
}
debugDump
(
"
SHGetSpecialFolderPath
returned
path
:
"
+
path
)
;
let
dir
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
dir
.
initWithPath
(
path
)
;
return
dir
;
}
ChromeUtils
.
defineLazyGetter
(
this
"
gInstallDirPathHash
"
function
test_gIDPH
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
if
(
!
MOZ_APP_BASENAME
)
{
return
null
;
}
let
vendor
=
MOZ_APP_VENDOR
?
MOZ_APP_VENDOR
:
"
Mozilla
"
;
let
appDir
=
getApplyDirFile
(
)
;
const
REG_PATH
=
"
SOFTWARE
\
\
"
+
vendor
+
"
\
\
"
+
MOZ_APP_BASENAME
+
"
\
\
TaskBarIDs
"
;
let
regKey
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
try
{
regKey
.
open
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_LOCAL_MACHINE
REG_PATH
Ci
.
nsIWindowsRegKey
.
ACCESS_ALL
)
;
regKey
.
writeStringValue
(
appDir
.
path
gTestID
)
;
return
gTestID
;
}
catch
(
e
)
{
}
try
{
regKey
.
create
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
REG_PATH
Ci
.
nsIWindowsRegKey
.
ACCESS_ALL
)
;
regKey
.
writeStringValue
(
appDir
.
path
gTestID
)
;
return
gTestID
;
}
catch
(
e
)
{
logTestInfo
(
"
failed
to
create
registry
value
.
Registry
Path
:
"
+
REG_PATH
+
"
Value
Name
:
"
+
appDir
.
path
+
"
Value
Data
:
"
+
gTestID
+
"
Exception
"
+
e
)
;
do_throw
(
"
Unable
to
write
HKLM
or
HKCU
TaskBarIDs
registry
value
key
path
:
"
+
REG_PATH
)
;
}
return
null
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
gLocalAppDataDir
"
function
test_gLADD
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
const
CSIDL_LOCAL_APPDATA
=
0x1c
;
return
getSpecialFolderDir
(
CSIDL_LOCAL_APPDATA
)
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
gCommonAppDataDir
"
function
test_gCDD
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
const
CSIDL_COMMON_APPDATA
=
0x0023
;
return
getSpecialFolderDir
(
CSIDL_COMMON_APPDATA
)
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
gProgFilesDir
"
function
test_gPFD
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
const
CSIDL_PROGRAM_FILES
=
0x26
;
return
getSpecialFolderDir
(
CSIDL_PROGRAM_FILES
)
;
}
)
;
function
getMockUpdRootD
(
aGetOldLocation
=
false
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
return
getMockUpdRootDWin
(
aGetOldLocation
)
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
return
getMockUpdRootDMac
(
)
;
}
return
getApplyDirFile
(
DIR_MACOS
)
;
}
function
getMockUpdRootDWin
(
aGetOldLocation
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
let
relPathUpdates
=
"
"
;
let
dataDirectory
=
gCommonAppDataDir
.
clone
(
)
;
if
(
aGetOldLocation
)
{
relPathUpdates
+
=
"
Mozilla
"
;
}
else
{
relPathUpdates
+
=
"
Mozilla
-
1de4eec8
-
1241
-
4177
-
a864
-
e594e8d1fb38
"
;
}
relPathUpdates
+
=
"
\
\
"
+
DIR_UPDATES
+
"
\
\
"
+
gInstallDirPathHash
;
let
updatesDir
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
updatesDir
.
initWithPath
(
dataDirectory
.
path
+
"
\
\
"
+
relPathUpdates
)
;
return
updatesDir
;
}
function
createWorldWritableAppUpdateDir
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
installDir
=
Services
.
dirsvc
.
get
(
XRE_EXECUTABLE_FILE
Ci
.
nsIFile
)
.
parent
;
let
exitValue
=
runTestHelperSync
(
[
"
create
-
update
-
dir
"
installDir
.
path
]
)
;
Assert
.
equal
(
exitValue
0
"
The
helper
process
exit
value
should
be
0
"
)
;
}
}
ChromeUtils
.
defineLazyGetter
(
this
"
gUpdatesRootDir
"
function
test_gURD
(
)
{
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
do_throw
(
"
Mac
OS
X
only
function
called
by
a
different
platform
!
"
)
;
}
let
dir
=
Services
.
dirsvc
.
get
(
"
ULibDir
"
Ci
.
nsIFile
)
;
dir
.
append
(
"
Caches
"
)
;
if
(
MOZ_APP_VENDOR
|
|
MOZ_APP_BASENAME
)
{
dir
.
append
(
MOZ_APP_VENDOR
?
MOZ_APP_VENDOR
:
MOZ_APP_BASENAME
)
;
}
else
{
dir
.
append
(
"
Mozilla
"
)
;
}
dir
.
append
(
DIR_UPDATES
)
;
return
dir
;
}
)
;
function
getMockUpdRootDMac
(
)
{
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
do_throw
(
"
Mac
OS
X
only
function
called
by
a
different
platform
!
"
)
;
}
let
appDir
=
Services
.
dirsvc
.
get
(
XRE_EXECUTABLE_FILE
Ci
.
nsIFile
)
.
parent
.
parent
.
parent
;
let
appDirPath
=
appDir
.
path
;
appDirPath
=
appDirPath
.
substr
(
0
appDirPath
.
length
-
4
)
;
let
pathUpdates
=
gUpdatesRootDir
.
path
+
appDirPath
;
let
updatesDir
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
updatesDir
.
initWithPath
(
pathUpdates
)
;
return
updatesDir
;
}
function
createUpdateInProgressLockFile
(
aDir
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
let
file
=
aDir
.
clone
(
)
;
file
.
append
(
FILE_UPDATE_IN_PROGRESS_LOCK
)
;
file
.
create
(
file
.
NORMAL_FILE_TYPE
0o444
)
;
file
.
QueryInterface
(
Ci
.
nsILocalFileWin
)
;
file
.
readOnly
=
true
;
Assert
.
ok
(
file
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
file
.
path
)
)
;
Assert
.
ok
(
!
file
.
isWritable
(
)
"
the
lock
file
should
not
be
writeable
"
)
;
}
function
removeUpdateInProgressLockFile
(
aDir
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
let
file
=
aDir
.
clone
(
)
;
file
.
append
(
FILE_UPDATE_IN_PROGRESS_LOCK
)
;
file
.
QueryInterface
(
Ci
.
nsILocalFileWin
)
;
file
.
readOnly
=
false
;
file
.
remove
(
false
)
;
Assert
.
ok
(
!
file
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
file
.
path
)
)
;
}
function
stripQuarantineBitFromPath
(
aPath
)
{
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
do_throw
(
"
macOS
-
only
function
called
by
a
different
platform
!
"
)
;
}
let
args
=
[
"
-
dr
"
"
com
.
apple
.
quarantine
"
aPath
]
;
let
stripQuarantineBitProcess
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
let
xattrBin
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
xattrBin
.
initWithPath
(
"
/
usr
/
bin
/
xattr
"
)
;
stripQuarantineBitProcess
.
init
(
xattrBin
)
;
stripQuarantineBitProcess
.
run
(
true
args
args
.
length
)
;
}
function
copyTestUpdaterToBinDir
(
)
{
let
testUpdater
=
getTestDirFile
(
FILE_UPDATER_BIN
)
;
let
updater
=
getGREBinDir
(
)
;
updater
.
append
(
FILE_UPDATER_BIN
)
;
if
(
!
updater
.
exists
(
)
)
{
testUpdater
.
copyToFollowingLinks
(
updater
.
parent
FILE_UPDATER_BIN
)
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
stripQuarantineBitFromPath
(
updater
.
path
)
;
updater
.
append
(
"
Contents
"
)
;
updater
.
append
(
"
MacOS
"
)
;
updater
.
append
(
"
org
.
mozilla
.
updater
"
)
;
}
return
updater
;
}
function
logUpdateLog
(
aLogLeafName
)
{
let
updateLog
=
getUpdateDirFile
(
aLogLeafName
)
;
if
(
updateLog
.
exists
(
)
)
{
let
updateLogContents
=
readFileBytes
(
updateLog
)
.
replace
(
/
\
r
\
n
/
g
"
\
n
"
)
;
updateLogContents
=
removeTimeStamps
(
updateLogContents
)
;
updateLogContents
=
replaceLogPaths
(
updateLogContents
)
;
let
aryLogContents
=
updateLogContents
.
split
(
"
\
n
"
)
;
logTestInfo
(
"
contents
of
"
+
updateLog
.
path
+
"
:
"
)
;
aryLogContents
.
forEach
(
function
LU_ULC_FE
(
aLine
)
{
logTestInfo
(
aLine
)
;
}
)
;
}
else
{
logTestInfo
(
"
update
log
doesn
'
t
exist
path
:
"
+
updateLog
.
path
)
;
}
if
(
gIsServiceTest
)
{
let
secureStatus
=
readSecureStatusFile
(
)
;
logTestInfo
(
"
secure
update
status
:
"
+
secureStatus
)
;
updateLog
=
getSecureOutputFile
(
"
log
"
)
;
if
(
updateLog
.
exists
(
)
)
{
let
updateLogContents
=
readFileBytes
(
updateLog
)
.
replace
(
/
\
r
\
n
/
g
"
\
n
"
)
;
updateLogContents
=
removeTimeStamps
(
updateLogContents
)
;
updateLogContents
=
replaceLogPaths
(
updateLogContents
)
;
let
aryLogContents
=
updateLogContents
.
split
(
"
\
n
"
)
;
logTestInfo
(
"
contents
of
"
+
updateLog
.
path
+
"
:
"
)
;
aryLogContents
.
forEach
(
function
LU_SULC_FE
(
aLine
)
{
logTestInfo
(
aLine
)
;
}
)
;
}
else
{
logTestInfo
(
"
secure
update
log
doesn
'
t
exist
path
:
"
+
updateLog
.
path
)
;
}
let
serviceLog
=
getMaintSvcDir
(
)
;
serviceLog
.
append
(
"
logs
"
)
;
serviceLog
.
append
(
"
maintenanceservice
.
log
"
)
;
if
(
serviceLog
.
exists
(
)
)
{
let
serviceLogContents
=
readFileBytes
(
serviceLog
)
.
replace
(
/
\
r
\
n
/
g
"
\
n
"
)
;
serviceLogContents
=
replaceLogPaths
(
serviceLogContents
)
;
let
aryLogContents
=
serviceLogContents
.
split
(
"
\
n
"
)
;
logTestInfo
(
"
contents
of
"
+
serviceLog
.
path
+
"
:
"
)
;
aryLogContents
.
forEach
(
function
LU_MSLC_FE
(
aLine
)
{
logTestInfo
(
aLine
)
;
}
)
;
}
else
{
logTestInfo
(
"
maintenance
service
log
doesn
'
t
exist
path
:
"
+
serviceLog
.
path
)
;
}
}
}
function
readServiceLogFile
(
)
{
let
file
=
getMaintSvcDir
(
)
;
file
.
append
(
"
logs
"
)
;
file
.
append
(
"
maintenanceservice
.
log
"
)
;
return
readFile
(
file
)
;
}
function
runUpdate
(
aExpectedStatus
aSwitchApp
aExpectedExitValue
aCheckSvcLog
aPatchDirPath
aInstallDirPath
aApplyToDirPath
aCallbackPath
)
{
let
isInvalidArgTest
=
!
!
aPatchDirPath
|
|
!
!
aInstallDirPath
|
|
!
!
aApplyToDirPath
|
|
!
!
aCallbackPath
;
let
svcOriginalLog
;
if
(
gIsServiceTest
)
{
copyFileToTestAppDir
(
FILE_MAINTENANCE_SERVICE_BIN
DIR_MACOS
)
;
copyFileToTestAppDir
(
FILE_MAINTENANCE_SERVICE_INSTALLER_BIN
DIR_MACOS
)
;
if
(
aCheckSvcLog
)
{
svcOriginalLog
=
readServiceLogFile
(
)
;
}
}
let
pid
=
0
;
if
(
gPIDPersistProcess
)
{
pid
=
gPIDPersistProcess
.
pid
;
Services
.
env
.
set
(
"
MOZ_TEST_SHORTER_WAIT_PID
"
"
1
"
)
;
}
if
(
!
gUpdateBin
)
{
gUpdateBin
=
copyTestUpdaterToBinDir
(
)
;
}
Assert
.
ok
(
gUpdateBin
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
gUpdateBin
.
path
)
)
;
let
updatesDirPath
=
aPatchDirPath
|
|
getUpdateDirFile
(
DIR_PATCH
)
.
path
;
let
installDirPath
=
aInstallDirPath
|
|
getApplyDirFile
(
)
.
path
;
let
applyToDirPath
=
aApplyToDirPath
|
|
getApplyDirFile
(
)
.
path
;
let
stageDirPath
=
aApplyToDirPath
|
|
getStageDirFile
(
)
.
path
;
let
callbackApp
=
getApplyDirFile
(
DIR_MACOS
+
gCallbackApp
)
;
Assert
.
ok
(
callbackApp
.
exists
(
)
MSG_SHOULD_EXIST
+
"
path
:
"
+
callbackApp
.
path
)
;
callbackApp
.
permissions
=
PERMS_DIRECTORY
;
setAppBundleModTime
(
)
;
let
args
=
[
updatesDirPath
installDirPath
]
;
if
(
aSwitchApp
)
{
args
[
2
]
=
stageDirPath
;
args
[
3
]
=
pid
+
"
/
replace
"
;
}
else
{
args
[
2
]
=
applyToDirPath
;
args
[
3
]
=
pid
;
}
let
launchBin
=
gIsServiceTest
&
&
isInvalidArgTest
?
callbackApp
:
gUpdateBin
;
if
(
!
isInvalidArgTest
)
{
args
=
args
.
concat
(
[
callbackApp
.
parent
.
path
callbackApp
.
path
]
)
;
args
=
args
.
concat
(
gCallbackArgs
)
;
}
else
if
(
gIsServiceTest
)
{
args
=
[
"
launch
-
service
"
gUpdateBin
.
path
]
.
concat
(
args
)
;
}
else
if
(
aCallbackPath
)
{
args
=
args
.
concat
(
[
callbackApp
.
parent
.
path
aCallbackPath
]
)
;
}
debugDump
(
"
launching
the
program
:
"
+
launchBin
.
path
+
"
"
+
args
.
join
(
"
"
)
)
;
if
(
aSwitchApp
&
&
!
isInvalidArgTest
)
{
gShouldResetEnv
=
undefined
;
}
setEnvironment
(
)
;
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
process
.
init
(
launchBin
)
;
process
.
run
(
true
args
args
.
length
)
;
resetEnvironment
(
)
;
if
(
gPIDPersistProcess
)
{
Services
.
env
.
set
(
"
MOZ_TEST_SHORTER_WAIT_PID
"
"
"
)
;
}
let
status
=
readStatusFile
(
)
;
if
(
(
!
gIsServiceTest
&
&
process
.
exitValue
!
=
aExpectedExitValue
)
|
|
(
status
!
=
aExpectedStatus
&
&
!
gIsServiceTest
&
&
!
isInvalidArgTest
)
)
{
if
(
process
.
exitValue
!
=
aExpectedExitValue
)
{
logTestInfo
(
"
updater
exited
with
unexpected
value
!
Got
:
"
+
process
.
exitValue
+
"
Expected
:
"
+
aExpectedExitValue
)
;
}
if
(
status
!
=
aExpectedStatus
)
{
logTestInfo
(
"
update
status
is
not
the
expected
status
!
Got
:
"
+
status
+
"
Expected
:
"
+
aExpectedStatus
)
;
}
logUpdateLog
(
FILE_LAST_UPDATE_LOG
)
;
}
if
(
gIsServiceTest
&
&
isInvalidArgTest
)
{
let
secureStatus
=
readSecureStatusFile
(
)
;
if
(
secureStatus
!
=
STATE_NONE
)
{
status
=
secureStatus
;
}
}
if
(
!
gIsServiceTest
)
{
Assert
.
equal
(
process
.
exitValue
aExpectedExitValue
"
the
process
exit
value
"
+
MSG_SHOULD_EQUAL
)
;
}
if
(
status
!
=
aExpectedStatus
)
{
logUpdateLog
(
FILE_UPDATE_LOG
)
;
}
Assert
.
equal
(
status
aExpectedStatus
"
the
update
status
"
+
MSG_SHOULD_EQUAL
)
;
if
(
gIsServiceTest
&
&
aCheckSvcLog
)
{
let
contents
=
readServiceLogFile
(
)
;
Assert
.
notEqual
(
contents
svcOriginalLog
"
the
contents
of
the
maintenanceservice
.
log
should
not
"
+
"
be
the
same
as
the
original
contents
"
)
;
if
(
gEnvForceServiceFallback
)
{
Assert
.
ok
(
contents
.
includes
(
LOG_SVC_UNSUCCESSFUL_LAUNCH
)
"
the
contents
of
the
maintenanceservice
.
log
should
"
+
"
contain
the
unsuccessful
launch
string
"
)
;
}
else
if
(
!
isInvalidArgTest
)
{
Assert
.
notEqual
(
contents
.
indexOf
(
LOG_SVC_SUCCESSFUL_LAUNCH
)
-
1
"
the
contents
of
the
maintenanceservice
.
log
should
"
+
"
contain
the
successful
launch
string
"
)
;
}
}
}
function
runTestHelperSync
(
aArgs
)
{
let
helperBin
=
getTestDirFile
(
FILE_HELPER_BIN
)
;
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
process
.
init
(
helperBin
)
;
debugDump
(
"
Running
"
+
helperBin
.
path
+
"
"
+
aArgs
.
join
(
"
"
)
)
;
process
.
run
(
true
aArgs
aArgs
.
length
)
;
return
process
.
exitValue
;
}
function
createSymlink
(
)
{
let
args
=
[
"
setup
-
symlink
"
"
moz
-
foo
"
"
moz
-
bar
"
"
target
"
getApplyDirFile
(
)
.
path
+
"
/
"
+
DIR_RESOURCES
+
"
link
"
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
equal
(
exitValue
0
"
the
helper
process
exit
value
should
be
0
"
)
;
let
file
=
getApplyDirFile
(
DIR_RESOURCES
+
"
link
"
)
;
Assert
.
ok
(
file
.
exists
(
)
MSG_SHOULD_EXIST
+
"
path
:
"
+
file
.
path
)
;
file
.
permissions
=
0o666
;
args
=
[
"
setup
-
symlink
"
"
moz
-
foo2
"
"
moz
-
bar2
"
"
target2
"
getApplyDirFile
(
)
.
path
+
"
/
"
+
DIR_RESOURCES
+
"
link2
"
"
change
-
perm
"
]
;
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
equal
(
exitValue
0
"
the
helper
process
exit
value
should
be
0
"
)
;
}
function
removeSymlink
(
)
{
let
args
=
[
"
remove
-
symlink
"
"
moz
-
foo
"
"
moz
-
bar
"
"
target
"
getApplyDirFile
(
)
.
path
+
"
/
"
+
DIR_RESOURCES
+
"
link
"
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
equal
(
exitValue
0
"
the
helper
process
exit
value
should
be
0
"
)
;
args
=
[
"
remove
-
symlink
"
"
moz
-
foo2
"
"
moz
-
bar2
"
"
target2
"
getApplyDirFile
(
)
.
path
+
"
/
"
+
DIR_RESOURCES
+
"
link2
"
]
;
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
equal
(
exitValue
0
"
the
helper
process
exit
value
should
be
0
"
)
;
}
function
checkSymlink
(
)
{
let
args
=
[
"
check
-
symlink
"
getApplyDirFile
(
)
.
path
+
"
/
"
+
DIR_RESOURCES
+
"
link
"
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
equal
(
exitValue
0
"
the
helper
process
exit
value
should
be
0
"
)
;
}
async
function
setupActiveUpdate
(
)
{
await
gAUS
.
init
(
)
;
let
pendingState
=
gIsServiceTest
?
STATE_PENDING_SVC
:
STATE_PENDING
;
let
patchProps
=
{
state
:
pendingState
}
;
let
patches
=
getLocalPatchString
(
patchProps
)
;
let
updates
=
getLocalUpdateString
(
{
}
patches
)
;
writeUpdatesToXMLFile
(
getLocalUpdatesXMLString
(
updates
)
true
)
;
writeVersionFile
(
DEFAULT_UPDATE_VERSION
)
;
writeStatusFile
(
pendingState
)
;
reloadUpdateManagerData
(
)
;
Assert
.
ok
(
!
!
(
await
gUpdateManager
.
getReadyUpdate
(
)
)
"
the
ready
update
should
be
defined
"
)
;
}
async
function
stageUpdate
(
aStateAfterStage
aCheckSvcLog
aUpdateRemoved
=
false
)
{
debugDump
(
"
start
-
attempting
to
stage
update
"
)
;
let
svcLogOriginalContents
;
if
(
gIsServiceTest
&
&
aCheckSvcLog
)
{
svcLogOriginalContents
=
readServiceLogFile
(
)
;
}
setAppBundleModTime
(
)
;
setEnvironment
(
)
;
try
{
Cc
[
"
mozilla
.
org
/
updates
/
update
-
processor
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdateProcessor
)
.
processUpdate
(
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
"
error
thrown
while
calling
processUpdate
Exception
:
"
+
e
)
;
}
await
waitForEvent
(
"
update
-
staged
"
aStateAfterStage
)
;
resetEnvironment
(
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
if
(
gIsServiceTest
)
{
waitForServiceStop
(
false
)
;
}
else
{
let
updater
=
getApplyDirFile
(
FILE_UPDATER_BIN
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
isFileInUse
(
updater
)
"
Waiting
for
the
file
tp
not
be
in
use
Path
:
"
+
updater
.
path
)
;
}
}
if
(
!
aUpdateRemoved
)
{
Assert
.
equal
(
readStatusState
(
)
aStateAfterStage
"
the
status
file
state
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
(
await
gUpdateManager
.
getReadyUpdate
(
)
)
.
state
aStateAfterStage
"
the
update
state
"
+
MSG_SHOULD_EQUAL
)
;
}
let
log
=
getUpdateDirFile
(
FILE_LAST_UPDATE_LOG
)
;
Assert
.
ok
(
log
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
log
.
path
)
)
;
log
=
getUpdateDirFile
(
FILE_UPDATE_LOG
)
;
Assert
.
ok
(
!
log
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
log
.
path
)
)
;
log
=
getUpdateDirFile
(
FILE_BACKUP_UPDATE_LOG
)
;
Assert
.
ok
(
!
log
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
log
.
path
)
)
;
let
stageDir
=
getStageDirFile
(
)
;
if
(
aStateAfterStage
=
=
STATE_APPLIED
|
|
aStateAfterStage
=
=
STATE_APPLIED_SVC
)
{
Assert
.
ok
(
stageDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
stageDir
.
path
)
)
;
}
else
{
Assert
.
ok
(
!
stageDir
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
stageDir
.
path
)
)
;
}
if
(
gIsServiceTest
&
&
aCheckSvcLog
)
{
let
contents
=
readServiceLogFile
(
)
;
Assert
.
notEqual
(
contents
svcLogOriginalContents
"
the
contents
of
the
maintenanceservice
.
log
should
not
"
+
"
be
the
same
as
the
original
contents
"
)
;
Assert
.
notEqual
(
contents
.
indexOf
(
LOG_SVC_SUCCESSFUL_LAUNCH
)
-
1
"
the
contents
of
the
maintenanceservice
.
log
should
"
+
"
contain
the
successful
launch
string
"
)
;
}
debugDump
(
"
finish
-
attempting
to
stage
update
"
)
;
}
function
shouldRunServiceTest
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
let
binDir
=
getGREBinDir
(
)
;
let
updaterBin
=
binDir
.
clone
(
)
;
updaterBin
.
append
(
FILE_UPDATER_BIN
)
;
Assert
.
ok
(
updaterBin
.
exists
(
)
MSG_SHOULD_EXIST
+
"
leafName
:
"
+
updaterBin
.
leafName
)
;
let
updaterBinPath
=
updaterBin
.
path
;
if
(
/
/
.
test
(
updaterBinPath
)
)
{
updaterBinPath
=
'
"
'
+
updaterBinPath
+
'
"
'
;
}
let
isBinSigned
=
isBinarySigned
(
updaterBinPath
)
;
const
REG_PATH
=
"
SOFTWARE
\
\
Mozilla
\
\
MaintenanceService
\
\
"
+
"
3932ecacee736d366d6436db0f55bce4
"
;
let
key
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
try
{
key
.
open
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_LOCAL_MACHINE
REG_PATH
Ci
.
nsIWindowsRegKey
.
ACCESS_READ
|
key
.
WOW64_64
)
;
}
catch
(
e
)
{
if
(
IS_AUTHENTICODE_CHECK_ENABLED
)
{
Assert
.
ok
(
!
isBinSigned
"
the
updater
.
exe
binary
should
not
be
signed
when
the
test
"
+
"
registry
key
doesn
'
t
exist
(
if
it
is
build
system
"
+
"
configuration
bug
?
)
"
)
;
}
logTestInfo
(
"
this
test
can
only
run
on
the
buildbot
build
system
at
this
time
"
)
;
return
false
;
}
let
args
=
[
"
wait
-
for
-
service
-
stop
"
"
MozillaMaintenance
"
"
10
"
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
notEqual
(
exitValue
0xee
"
the
maintenance
service
should
be
"
+
"
installed
(
if
not
build
system
configuration
bug
?
)
"
)
;
if
(
IS_AUTHENTICODE_CHECK_ENABLED
)
{
Assert
.
ok
(
isBinSigned
"
the
updater
.
exe
binary
should
be
signed
(
if
not
build
system
"
+
"
configuration
bug
?
)
"
)
;
}
return
attemptServiceInstall
(
)
;
}
function
isBinarySigned
(
aBinPath
)
{
let
args
=
[
"
check
-
signature
"
aBinPath
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
if
(
exitValue
!
=
0
)
{
logTestInfo
(
"
binary
is
not
signed
.
"
+
FILE_HELPER_BIN
+
"
returned
"
+
exitValue
+
"
for
file
"
+
aBinPath
)
;
return
false
;
}
return
true
;
}
function
setupAppFiles
(
{
requiresOmnijar
=
false
}
=
{
}
)
{
debugDump
(
"
start
-
copying
or
creating
symlinks
to
application
files
"
+
"
for
the
test
"
)
;
let
destDir
=
getApplyDirFile
(
)
;
if
(
!
destDir
.
exists
(
)
)
{
try
{
destDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
PERMS_DIRECTORY
)
;
}
catch
(
e
)
{
logTestInfo
(
"
unable
to
create
directory
!
Path
:
"
+
destDir
.
path
+
"
Exception
:
"
+
e
)
;
do_throw
(
e
)
;
}
}
let
appFiles
=
[
{
relPath
:
FILE_APP_BIN
inDir
:
DIR_MACOS
}
{
relPath
:
FILE_APPLICATION_INI
inDir
:
DIR_RESOURCES
}
{
relPath
:
"
dependentlibs
.
list
"
inDir
:
DIR_RESOURCES
}
]
;
if
(
requiresOmnijar
)
{
appFiles
.
push
(
{
relPath
:
AppConstants
.
OMNIJAR_NAME
inDir
:
DIR_RESOURCES
}
)
;
if
(
AppConstants
.
MOZ_BUILD_APP
=
=
"
browser
"
)
{
appFiles
.
push
(
{
relPath
:
"
browser
/
"
+
AppConstants
.
OMNIJAR_NAME
inDir
:
DIR_RESOURCES
}
)
;
}
}
if
(
AppConstants
.
platform
=
=
"
linux
"
)
{
appFiles
.
push
(
{
relPath
:
"
icons
/
updater
.
png
"
inDir
:
DIR_RESOURCES
}
{
relPath
:
"
libsoftokn3
.
so
"
inDir
:
DIR_RESOURCES
}
)
;
}
let
deplibsFile
=
gGREDirOrig
.
clone
(
)
;
deplibsFile
.
append
(
"
dependentlibs
.
list
"
)
;
let
fis
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fis
.
init
(
deplibsFile
0x01
0o444
Ci
.
nsIFileInputStream
.
CLOSE_ON_EOF
)
;
fis
.
QueryInterface
(
Ci
.
nsILineInputStream
)
;
let
hasMore
;
let
line
=
{
}
;
do
{
hasMore
=
fis
.
readLine
(
line
)
;
appFiles
.
push
(
{
relPath
:
line
.
value
inDir
:
DIR_MACOS
}
)
;
}
while
(
hasMore
)
;
fis
.
close
(
)
;
appFiles
.
forEach
(
function
CMAF_FLN_FE
(
aAppFile
)
{
copyFileToTestAppDir
(
aAppFile
.
relPath
aAppFile
.
inDir
)
;
}
)
;
copyTestUpdaterToBinDir
(
)
;
debugDump
(
"
finish
-
copying
or
creating
symlinks
to
application
files
"
+
"
for
the
test
"
)
;
}
function
copyFileToTestAppDir
(
aFileRelPath
aDir
)
{
let
srcFile
;
let
destFile
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
switch
(
aDir
)
{
case
DIR_RESOURCES
:
srcFile
=
gGREDirOrig
.
clone
(
)
;
destFile
=
getGREDir
(
)
;
break
;
case
DIR_MACOS
:
srcFile
=
gGREBinDirOrig
.
clone
(
)
;
destFile
=
getGREBinDir
(
)
;
break
;
case
DIR_CONTENTS
:
srcFile
=
gGREBinDirOrig
.
parent
.
clone
(
)
;
destFile
=
getGREBinDir
(
)
.
parent
;
break
;
default
:
debugDump
(
"
invalid
path
given
.
Path
:
"
+
aDir
)
;
break
;
}
}
else
{
srcFile
=
gGREDirOrig
.
clone
(
)
;
destFile
=
getGREDir
(
)
;
}
let
fileRelPath
=
aFileRelPath
;
let
pathParts
=
fileRelPath
.
split
(
"
/
"
)
;
for
(
let
i
=
0
;
i
<
pathParts
.
length
;
i
+
+
)
{
if
(
pathParts
[
i
]
)
{
srcFile
.
append
(
pathParts
[
i
]
)
;
destFile
.
append
(
pathParts
[
i
]
)
;
}
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
!
srcFile
.
exists
(
)
)
{
debugDump
(
"
unable
to
copy
file
since
it
doesn
'
t
exist
!
Checking
if
"
+
fileRelPath
+
"
.
app
exists
.
Path
:
"
+
srcFile
.
path
)
;
for
(
let
i
=
0
;
i
<
pathParts
.
length
;
i
+
+
)
{
if
(
pathParts
[
i
]
)
{
srcFile
.
append
(
pathParts
[
i
]
+
(
pathParts
.
length
-
1
=
=
i
?
"
.
app
"
:
"
"
)
)
;
destFile
.
append
(
pathParts
[
i
]
+
(
pathParts
.
length
-
1
=
=
i
?
"
.
app
"
:
"
"
)
)
;
}
}
fileRelPath
=
fileRelPath
+
"
.
app
"
;
}
Assert
.
ok
(
srcFile
.
exists
(
)
MSG_SHOULD_EXIST
+
"
leafName
:
"
+
srcFile
.
leafName
)
;
let
shouldSymlink
=
pathParts
[
pathParts
.
length
-
1
]
=
=
"
XUL
"
|
|
fileRelPath
.
substr
(
fileRelPath
.
length
-
3
)
=
=
"
.
so
"
|
|
fileRelPath
.
substr
(
fileRelPath
.
length
-
6
)
=
=
"
.
dylib
"
;
if
(
!
shouldSymlink
)
{
if
(
!
destFile
.
exists
(
)
)
{
try
{
srcFile
.
copyToFollowingLinks
(
destFile
.
parent
destFile
.
leafName
)
;
}
catch
(
e
)
{
if
(
destFile
.
exists
(
)
)
{
try
{
destFile
.
remove
(
true
)
;
}
catch
(
ex
)
{
logTestInfo
(
"
unable
to
remove
file
that
failed
to
copy
!
Path
:
"
+
destFile
.
path
+
"
Exception
:
"
+
ex
)
;
}
}
do_throw
(
"
Unable
to
copy
file
!
Path
:
"
+
srcFile
.
path
+
"
Exception
:
"
+
e
)
;
}
}
}
else
{
try
{
if
(
destFile
.
exists
(
)
)
{
destFile
.
remove
(
false
)
;
}
let
ln
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
ln
.
initWithPath
(
"
/
bin
/
ln
"
)
;
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
process
.
init
(
ln
)
;
let
args
=
[
"
-
s
"
srcFile
.
path
destFile
.
path
]
;
process
.
run
(
true
args
args
.
length
)
;
Assert
.
ok
(
destFile
.
isSymlink
(
)
destFile
.
leafName
+
"
should
be
a
symlink
"
)
;
}
catch
(
e
)
{
do_throw
(
"
Unable
to
create
symlink
for
file
!
Path
:
"
+
srcFile
.
path
+
"
Exception
:
"
+
e
)
;
}
}
}
function
attemptServiceInstall
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
let
maintSvcDir
=
getMaintSvcDir
(
)
;
Assert
.
ok
(
maintSvcDir
.
exists
(
)
MSG_SHOULD_EXIST
+
"
leafName
:
"
+
maintSvcDir
.
leafName
)
;
let
oldMaintSvcBin
=
maintSvcDir
.
clone
(
)
;
oldMaintSvcBin
.
append
(
FILE_MAINTENANCE_SERVICE_BIN
)
;
Assert
.
ok
(
oldMaintSvcBin
.
exists
(
)
MSG_SHOULD_EXIST
+
"
leafName
:
"
+
oldMaintSvcBin
.
leafName
)
;
let
buildMaintSvcBin
=
getGREBinDir
(
)
;
buildMaintSvcBin
.
append
(
FILE_MAINTENANCE_SERVICE_BIN
)
;
if
(
readFileBytes
(
oldMaintSvcBin
)
=
=
readFileBytes
(
buildMaintSvcBin
)
)
{
debugDump
(
"
installed
maintenance
service
binary
is
the
same
as
the
"
+
"
build
'
s
maintenance
service
binary
"
)
;
return
true
;
}
let
backupMaintSvcBin
=
maintSvcDir
.
clone
(
)
;
backupMaintSvcBin
.
append
(
FILE_MAINTENANCE_SERVICE_BIN
+
"
.
backup
"
)
;
try
{
if
(
backupMaintSvcBin
.
exists
(
)
)
{
backupMaintSvcBin
.
remove
(
false
)
;
}
oldMaintSvcBin
.
moveTo
(
maintSvcDir
FILE_MAINTENANCE_SERVICE_BIN
+
"
.
backup
"
)
;
buildMaintSvcBin
.
copyTo
(
maintSvcDir
FILE_MAINTENANCE_SERVICE_BIN
)
;
backupMaintSvcBin
.
remove
(
false
)
;
}
catch
(
e
)
{
if
(
backupMaintSvcBin
.
exists
(
)
)
{
oldMaintSvcBin
=
maintSvcDir
.
clone
(
)
;
oldMaintSvcBin
.
append
(
FILE_MAINTENANCE_SERVICE_BIN
)
;
if
(
!
oldMaintSvcBin
.
exists
(
)
)
{
backupMaintSvcBin
.
moveTo
(
maintSvcDir
FILE_MAINTENANCE_SERVICE_BIN
)
;
}
}
Assert
.
ok
(
false
"
should
be
able
copy
the
test
maintenance
service
to
"
+
"
the
maintenance
service
directory
(
if
not
build
system
"
+
"
configuration
bug
?
)
path
:
"
+
maintSvcDir
.
path
)
;
}
return
true
;
}
function
waitServiceApps
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
waitForApplicationStop
(
"
maintenanceservice_installer
.
exe
"
)
;
waitForApplicationStop
(
"
maintenanceservice_tmp
.
exe
"
)
;
waitForApplicationStop
(
"
maintenanceservice
.
exe
"
)
;
}
function
waitForServiceStop
(
aFailTest
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
waitServiceApps
(
)
;
debugDump
(
"
waiting
for
the
maintenance
service
to
stop
if
necessary
"
)
;
let
args
=
[
"
wait
-
for
-
service
-
stop
"
"
MozillaMaintenance
"
"
120
"
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
notEqual
(
exitValue
0xee
"
the
maintenance
service
should
exist
"
)
;
if
(
exitValue
!
=
0
)
{
if
(
aFailTest
)
{
Assert
.
ok
(
false
"
the
maintenance
service
should
stop
process
exit
"
+
"
value
:
"
+
exitValue
)
;
}
logTestInfo
(
"
maintenance
service
did
not
stop
which
may
cause
test
"
+
"
failures
later
process
exit
value
:
"
+
exitValue
)
;
}
else
{
debugDump
(
"
service
stopped
"
)
;
}
waitServiceApps
(
)
;
}
function
waitForApplicationStop
(
aApplication
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
debugDump
(
"
waiting
for
"
+
aApplication
+
"
to
stop
if
necessary
"
)
;
let
args
=
[
"
wait
-
for
-
application
-
exit
"
aApplication
"
120
"
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
equal
(
exitValue
0
"
the
process
should
have
stopped
process
name
:
"
+
aApplication
)
;
}
function
getLaunchBin
(
)
{
let
launchBin
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
launchBin
=
Services
.
dirsvc
.
get
(
"
WinD
"
Ci
.
nsIFile
)
;
launchBin
.
append
(
"
System32
"
)
;
launchBin
.
append
(
"
cmd
.
exe
"
)
;
}
else
{
launchBin
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
launchBin
.
initWithPath
(
"
/
bin
/
sh
"
)
;
}
Assert
.
ok
(
launchBin
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
launchBin
.
path
)
)
;
return
launchBin
;
}
function
lockDirectory
(
aDirPath
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
debugDump
(
"
start
-
locking
installation
directory
"
)
;
const
LPCWSTR
=
ctypes
.
char16_t
.
ptr
;
const
DWORD
=
ctypes
.
uint32_t
;
const
LPVOID
=
ctypes
.
voidptr_t
;
const
GENERIC_READ
=
0x80000000
;
const
FILE_SHARE_READ
=
1
;
const
FILE_SHARE_WRITE
=
2
;
const
OPEN_EXISTING
=
3
;
const
FILE_FLAG_BACKUP_SEMANTICS
=
0x02000000
;
const
INVALID_HANDLE_VALUE
=
LPVOID
(
0xffffffff
)
;
let
kernel32
=
ctypes
.
open
(
"
kernel32
"
)
;
let
CreateFile
=
kernel32
.
declare
(
"
CreateFileW
"
ctypes
.
winapi_abi
LPVOID
LPCWSTR
DWORD
DWORD
LPVOID
DWORD
DWORD
LPVOID
)
;
gHandle
=
CreateFile
(
aDirPath
GENERIC_READ
FILE_SHARE_READ
|
FILE_SHARE_WRITE
LPVOID
(
0
)
OPEN_EXISTING
FILE_FLAG_BACKUP_SEMANTICS
LPVOID
(
0
)
)
;
Assert
.
notEqual
(
gHandle
.
toString
(
)
INVALID_HANDLE_VALUE
.
toString
(
)
"
the
handle
should
not
equal
INVALID_HANDLE_VALUE
"
)
;
kernel32
.
close
(
)
;
debugDump
(
"
finish
-
locking
installation
directory
"
)
;
}
async
function
runHelperFileInUse
(
aRelPath
aCopyTestHelper
)
{
debugDump
(
"
aRelPath
:
"
+
aRelPath
)
;
let
helperBin
=
getTestDirFile
(
FILE_HELPER_BIN
)
;
let
fileInUseBin
=
getApplyDirFile
(
aRelPath
)
;
if
(
aCopyTestHelper
)
{
if
(
fileInUseBin
.
exists
(
)
)
{
fileInUseBin
.
remove
(
false
)
;
}
helperBin
.
copyTo
(
fileInUseBin
.
parent
fileInUseBin
.
leafName
)
;
}
fileInUseBin
.
permissions
=
PERMS_DIRECTORY
;
let
args
=
[
getApplyDirPath
(
)
+
DIR_RESOURCES
"
input
"
"
output
"
"
-
s
"
HELPER_SLEEP_TIMEOUT
]
;
let
fileInUseProcess
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
fileInUseProcess
.
init
(
fileInUseBin
)
;
fileInUseProcess
.
run
(
false
args
args
.
length
)
;
await
waitForHelperSleep
(
)
;
}
async
function
runHelperPIDPersists
(
aRelPath
aCopyTestHelper
)
{
debugDump
(
"
aRelPath
:
"
+
aRelPath
)
;
let
helperBin
=
getTestDirFile
(
FILE_HELPER_BIN
)
;
let
pidPersistsBin
=
getApplyDirFile
(
aRelPath
)
;
if
(
aCopyTestHelper
)
{
if
(
pidPersistsBin
.
exists
(
)
)
{
pidPersistsBin
.
remove
(
false
)
;
}
helperBin
.
copyTo
(
pidPersistsBin
.
parent
pidPersistsBin
.
leafName
)
;
}
pidPersistsBin
.
permissions
=
PERMS_DIRECTORY
;
let
args
=
[
getApplyDirPath
(
)
+
DIR_RESOURCES
"
input
"
"
output
"
"
-
s
"
HELPER_SLEEP_TIMEOUT
]
;
gPIDPersistProcess
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
gPIDPersistProcess
.
init
(
pidPersistsBin
)
;
gPIDPersistProcess
.
run
(
false
args
args
.
length
)
;
await
waitForHelperSleep
(
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
!
gPIDPersistProcess
.
pid
"
Waiting
for
the
process
pid
"
)
;
}
async
function
runHelperLockFile
(
aTestFile
)
{
let
helperBin
=
getTestDirFile
(
FILE_HELPER_BIN
)
;
let
helperDestDir
=
getApplyDirFile
(
DIR_RESOURCES
)
;
helperBin
.
copyTo
(
helperDestDir
FILE_HELPER_BIN
)
;
helperBin
=
getApplyDirFile
(
DIR_RESOURCES
+
FILE_HELPER_BIN
)
;
let
lockFileRelPath
=
aTestFile
.
relPathDir
.
split
(
"
/
"
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
lockFileRelPath
=
lockFileRelPath
.
slice
(
2
)
;
}
lockFileRelPath
=
lockFileRelPath
.
join
(
"
/
"
)
+
"
/
"
+
aTestFile
.
fileName
;
let
args
=
[
getApplyDirPath
(
)
+
DIR_RESOURCES
"
input
"
"
output
"
"
-
s
"
HELPER_SLEEP_TIMEOUT
lockFileRelPath
]
;
let
helperProcess
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
helperProcess
.
init
(
helperBin
)
;
helperProcess
.
run
(
false
args
args
.
length
)
;
await
waitForHelperSleep
(
)
;
}
async
function
waitForHelperSleep
(
)
{
let
file
=
getApplyDirFile
(
DIR_RESOURCES
+
"
output
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
file
.
exists
(
)
"
Waiting
for
file
to
exist
path
:
"
+
file
.
path
)
;
let
expectedContents
=
"
sleeping
\
n
"
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
readFile
(
file
)
=
=
expectedContents
"
Waiting
for
expected
file
contents
:
"
+
expectedContents
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
try
{
file
.
remove
(
false
)
;
}
catch
(
e
)
{
debugDump
(
"
failed
to
remove
file
.
Path
:
"
+
file
.
path
+
"
Exception
:
"
+
e
)
;
}
return
!
file
.
exists
(
)
;
}
"
Waiting
for
file
to
be
removed
Path
:
"
+
file
.
path
)
;
}
async
function
waitForHelperExit
(
)
{
let
file
=
getApplyDirFile
(
DIR_RESOURCES
+
"
input
"
)
;
writeFile
(
file
"
finish
\
n
"
)
;
file
=
getApplyDirFile
(
DIR_RESOURCES
+
"
output
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
file
.
exists
(
)
"
Waiting
for
file
to
exist
Path
:
"
+
file
.
path
)
;
let
expectedContents
=
"
finished
\
n
"
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
readFile
(
file
)
=
=
expectedContents
"
Waiting
for
expected
file
contents
:
"
+
expectedContents
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
try
{
file
.
remove
(
false
)
;
}
catch
(
e
)
{
debugDump
(
"
failed
to
remove
file
.
Path
:
"
+
file
.
path
+
"
Exception
:
"
+
e
)
;
}
return
!
file
.
exists
(
)
;
}
"
Waiting
for
file
to
be
removed
Path
:
"
+
file
.
path
)
;
file
=
getApplyDirFile
(
DIR_RESOURCES
+
"
input
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
try
{
file
.
remove
(
false
)
;
}
catch
(
e
)
{
debugDump
(
"
failed
to
remove
file
.
Path
:
"
+
file
.
path
+
"
Exception
:
"
+
e
)
;
}
return
!
file
.
exists
(
)
;
}
"
Waiting
for
file
to
be
removed
Path
:
"
+
file
.
path
)
;
}
async
function
setupUpdaterTest
(
aMarFile
aPostUpdateAsync
aPostUpdateExeRelPathPrefix
=
"
"
aSetupActiveUpdate
=
true
{
requiresOmnijar
=
false
asyncExeArg
=
"
post
-
update
-
async
"
}
=
{
}
)
{
debugDump
(
"
start
-
updater
test
setup
"
)
;
await
gAUS
.
init
(
)
;
let
updatesPatchDir
=
getUpdateDirFile
(
DIR_PATCH
)
;
if
(
!
updatesPatchDir
.
exists
(
)
)
{
updatesPatchDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
PERMS_DIRECTORY
)
;
}
let
mar
=
getTestDirFile
(
aMarFile
)
;
mar
.
copyToFollowingLinks
(
updatesPatchDir
FILE_UPDATE_MAR
)
;
let
helperApp
=
getTestDirFile
(
FILE_HELPER_APP
)
;
let
helperBin
=
getTestDirFile
(
FILE_HELPER_BIN
)
;
helperApp
.
permissions
=
PERMS_DIRECTORY
;
helperBin
.
permissions
=
PERMS_DIRECTORY
;
let
afterApplyBinDir
=
getApplyDirFile
(
DIR_MACOS
)
;
helperBin
.
copyToFollowingLinks
(
afterApplyBinDir
gPostUpdateBinFile
)
;
helperApp
.
copyToFollowingLinks
(
afterApplyBinDir
gCallbackApp
)
;
if
(
!
gUpdateBin
)
{
gUpdateBin
=
copyTestUpdaterToBinDir
(
)
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
stripQuarantineBitFromPath
(
afterApplyBinDir
.
parent
.
parent
.
path
)
;
}
gTestFiles
.
forEach
(
function
SUT_TF_FE
(
aTestFile
)
{
debugDump
(
"
start
-
setup
test
file
:
"
+
aTestFile
.
fileName
)
;
if
(
aTestFile
.
originalFile
|
|
aTestFile
.
originalContents
)
{
let
testDir
=
getApplyDirFile
(
aTestFile
.
relPathDir
)
;
try
{
testDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
PERMS_DIRECTORY
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_FILE_ALREADY_EXISTS
)
{
throw
e
;
}
}
let
testFile
;
if
(
aTestFile
.
originalFile
)
{
testFile
=
getTestDirFile
(
aTestFile
.
originalFile
)
;
testFile
.
copyToFollowingLinks
(
testDir
aTestFile
.
fileName
)
;
testFile
=
getApplyDirFile
(
aTestFile
.
relPathDir
+
aTestFile
.
fileName
)
;
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
+
"
path
:
"
+
testFile
.
path
)
;
}
else
{
testFile
=
getApplyDirFile
(
aTestFile
.
relPathDir
+
aTestFile
.
fileName
)
;
writeFile
(
testFile
aTestFile
.
originalContents
)
;
}
if
(
AppConstants
.
platform
!
=
"
win
"
&
&
aTestFile
.
originalPerms
)
{
testFile
.
permissions
=
aTestFile
.
originalPerms
;
if
(
!
aTestFile
.
comparePerms
)
{
aTestFile
.
comparePerms
=
testFile
.
permissions
;
}
}
}
else
if
(
aTestFile
.
existingFile
)
{
const
testFile
=
getApplyDirFile
(
aTestFile
.
relPathDir
+
aTestFile
.
fileName
)
;
if
(
aTestFile
.
removeOriginalFile
)
{
testFile
.
remove
(
false
)
;
}
else
{
const
fileContents
=
readFileBytes
(
testFile
)
;
if
(
!
aTestFile
.
originalContents
&
&
!
aTestFile
.
originalFile
)
{
aTestFile
.
originalContents
=
fileContents
;
}
if
(
!
aTestFile
.
compareContents
&
&
!
aTestFile
.
compareFile
)
{
aTestFile
.
compareContents
=
fileContents
;
}
if
(
!
aTestFile
.
comparePerms
)
{
aTestFile
.
comparePerms
=
testFile
.
permissions
;
}
}
}
debugDump
(
"
finish
-
setup
test
file
:
"
+
aTestFile
.
fileName
)
;
}
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
await
IOUtils
.
setMacXAttr
(
getApplyDirFile
(
)
.
path
MAC_APP_XATTR_KEY
new
TextEncoder
(
)
.
encode
(
MAC_APP_XATTR_VALUE
)
)
;
}
gTestDirs
.
forEach
(
function
SUT_TD_FE
(
aTestDir
)
{
debugDump
(
"
start
-
setup
test
directory
:
"
+
aTestDir
.
relPathDir
)
;
let
testDir
=
getApplyDirFile
(
aTestDir
.
relPathDir
)
;
try
{
testDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
PERMS_DIRECTORY
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_FILE_ALREADY_EXISTS
)
{
throw
e
;
}
}
if
(
aTestDir
.
files
)
{
aTestDir
.
files
.
forEach
(
function
SUT_TD_F_FE
(
aTestFile
)
{
let
testFile
=
getApplyDirFile
(
aTestDir
.
relPathDir
+
aTestFile
)
;
if
(
!
testFile
.
exists
(
)
)
{
testFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
PERMS_FILE
)
;
}
}
)
;
}
if
(
aTestDir
.
subDirs
)
{
aTestDir
.
subDirs
.
forEach
(
function
SUT_TD_SD_FE
(
aSubDir
)
{
let
testSubDir
=
getApplyDirFile
(
aTestDir
.
relPathDir
+
aSubDir
)
;
if
(
!
testSubDir
.
exists
(
)
)
{
testSubDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
PERMS_DIRECTORY
)
;
}
if
(
aTestDir
.
subDirFiles
)
{
aTestDir
.
subDirFiles
.
forEach
(
function
SUT_TD_SDF_FE
(
aTestFile
)
{
let
testFile
=
getApplyDirFile
(
aTestDir
.
relPathDir
+
aSubDir
+
aTestFile
)
;
if
(
!
testFile
.
exists
(
)
)
{
testFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
PERMS_FILE
)
;
}
}
)
;
}
}
)
;
}
debugDump
(
"
finish
-
setup
test
directory
:
"
+
aTestDir
.
relPathDir
)
;
}
)
;
if
(
aSetupActiveUpdate
)
{
await
setupActiveUpdate
(
)
;
}
if
(
aPostUpdateAsync
!
=
=
null
)
{
createUpdaterINI
(
aPostUpdateAsync
aPostUpdateExeRelPathPrefix
{
asyncExeArg
}
)
;
}
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
try
{
setupAppFiles
(
{
requiresOmnijar
}
)
;
return
true
;
}
catch
(
e
)
{
logTestInfo
(
"
exception
when
calling
setupAppFiles
Exception
:
"
+
e
)
;
}
return
false
;
}
"
Waiting
to
setup
app
files
"
)
;
debugDump
(
"
finish
-
updater
test
setup
"
)
;
}
function
createUpdaterINI
(
aIsExeAsync
aExeRelPathPrefix
{
asyncExeArg
=
"
post
-
update
-
async
"
}
=
{
}
)
{
let
exeArg
=
ExeArg
=
{
asyncExeArg
}
\
n
;
let
exeAsync
=
"
"
;
if
(
aIsExeAsync
!
=
=
undefined
)
{
if
(
aIsExeAsync
)
{
exeAsync
=
"
ExeAsync
=
true
\
n
"
;
}
else
{
exeArg
=
"
ExeArg
=
post
-
update
-
sync
\
n
"
;
exeAsync
=
"
ExeAsync
=
false
\
n
"
;
}
}
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
aExeRelPathPrefix
)
{
aExeRelPathPrefix
=
aExeRelPathPrefix
.
replace
(
"
/
"
"
\
\
"
)
;
}
let
exeRelPathMac
=
"
ExeRelPath
=
"
+
aExeRelPathPrefix
+
DIR_MACOS
+
gPostUpdateBinFile
+
"
\
n
"
;
let
exeRelPathWin
=
"
ExeRelPath
=
"
+
aExeRelPathPrefix
+
gPostUpdateBinFile
+
"
\
n
"
;
let
updaterIniContents
=
"
[
Strings
]
\
n
"
+
"
Title
=
Update
Test
\
n
"
+
"
Info
=
Running
update
test
"
+
gTestID
+
"
\
n
\
n
"
+
"
[
PostUpdateMac
]
\
n
"
+
exeRelPathMac
+
exeArg
+
exeAsync
+
"
\
n
"
+
"
[
PostUpdateWin
]
\
n
"
+
exeRelPathWin
+
exeArg
+
exeAsync
;
let
updaterIni
=
getApplyDirFile
(
DIR_RESOURCES
+
FILE_UPDATER_INI
)
;
writeFile
(
updaterIni
updaterIniContents
)
;
}
function
getMsgPath
(
aPath
)
{
return
"
path
:
"
+
replaceLogPaths
(
aPath
)
;
}
function
replaceLogPaths
(
aLogContents
)
{
let
logContents
=
aLogContents
;
let
testDirPath
=
getApplyDirFile
(
)
.
parent
.
path
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
testDirPath
=
testDirPath
.
replace
(
/
\
\
/
g
"
\
\
\
\
"
)
;
}
logContents
=
logContents
.
replace
(
new
RegExp
(
testDirPath
"
g
"
)
"
<
test_dir_path
>
/
"
+
gTestID
)
;
let
updatesDirPath
=
getMockUpdRootD
(
)
.
path
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
updatesDirPath
=
updatesDirPath
.
replace
(
/
\
\
/
g
"
\
\
\
\
"
)
;
}
logContents
=
logContents
.
replace
(
new
RegExp
(
updatesDirPath
"
g
"
)
"
<
update_dir_path
>
/
"
+
gTestID
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
logContents
=
logContents
.
replace
(
/
\
\
/
g
"
/
"
)
;
}
return
logContents
;
}
function
removeTimeStamps
(
aLogContents
)
{
return
aLogContents
.
replace
(
/
^
\
d
{
4
}
-
\
d
{
2
}
-
\
d
{
2
}
\
d
{
2
}
:
\
d
{
2
}
:
\
d
{
2
}
[
+
-
]
\
d
{
4
}
:
/
gm
"
"
)
;
}
function
getLogFileContents
(
)
{
let
updateLog
=
getUpdateDirFile
(
FILE_LAST_UPDATE_ELEVATED_LOG
)
;
let
updateLogContents
;
try
{
updateLogContents
=
readFileBytes
(
updateLog
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
{
throw
ex
;
}
updateLog
=
getUpdateDirFile
(
FILE_LAST_UPDATE_LOG
)
;
updateLogContents
=
readFileBytes
(
updateLog
)
;
}
return
updateLogContents
;
}
function
checkUpdateLogContents
(
aCompareLogFile
aStaged
=
false
aReplace
=
false
aExcludeDistDir
=
false
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
|
|
AppConstants
.
platform
=
=
"
linux
"
)
{
return
;
}
let
updateLogContents
=
getLogFileContents
(
)
;
updateLogContents
=
removeTimeStamps
(
updateLogContents
)
;
const
channelPrefs
=
getTestFileByName
(
FILE_CHANNEL_PREFS
)
;
if
(
channelPrefs
&
&
!
channelPrefs
.
originalContents
)
{
updateLogContents
=
updateLogContents
.
replace
(
/
.
*
defaults
\
/
.
*
/
g
"
"
)
;
}
const
updateSettings
=
getTestFileByName
(
FILE_UPDATE_SETTINGS_INI
)
;
if
(
updateSettings
&
&
!
updateSettings
.
originalContents
)
{
updateLogContents
=
updateLogContents
.
replace
(
/
.
*
update
-
settings
.
ini
.
*
/
g
"
"
)
;
}
updateLogContents
=
updateLogContents
.
replace
(
/
PATCH
DIRECTORY
.
*
/
g
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
INSTALLATION
DIRECTORY
.
*
/
g
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
WORKING
DIRECTORY
.
*
/
g
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
NS_main
:
callback
app
file
.
*
/
g
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
\
r
/
g
"
"
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
re
=
new
RegExp
(
"
(
[
^
\
n
]
*
7
/
7text1
[
^
\
n
]
*
)
\
n
(
[
^
\
n
]
*
7
/
7text0
[
^
\
n
]
*
)
\
n
"
"
g
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
re
"
2
\
n
1
\
n
"
)
;
}
if
(
aReplace
)
{
updateLogContents
=
updateLogContents
.
replace
(
/
^
Begin
moving
.
*
/
gm
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
^
ensure_remove
:
failed
to
remove
file
:
.
*
/
gm
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
^
ensure_remove_recursive
:
unable
to
remove
directory
:
.
*
/
gm
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
^
Removing
tmpDir
failed
err
:
-
1
/
gm
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
^
remove_recursive_on_reboot
:
.
*
/
gm
"
"
)
;
let
re
=
new
RegExp
(
ERR_RENAME_FILE
+
"
[
^
\
n
]
*
\
n
"
+
"
PerformReplaceRequest
:
destDir
rename
[
^
\
n
]
*
\
n
"
+
"
rename_file
:
proceeding
to
rename
the
directory
\
n
"
"
g
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
re
"
"
)
;
}
updateLogContents
=
updateLogContents
.
replace
(
/
err
:
.
*
\
n
/
g
"
\
n
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
non
-
fatal
error
/
g
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
\
n
+
/
g
"
\
n
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
^
\
n
|
\
n
/
g
"
"
)
;
updateLogContents
=
replaceLogPaths
(
updateLogContents
)
;
let
compareLogContents
=
"
"
;
if
(
aCompareLogFile
)
{
compareLogContents
=
readFileBytes
(
getTestDirFile
(
aCompareLogFile
)
)
;
}
if
(
aStaged
)
{
compareLogContents
=
PERFORMING_STAGED_UPDATE
+
"
\
n
"
+
compareLogContents
;
}
compareLogContents
=
removeTimeStamps
(
compareLogContents
)
;
if
(
channelPrefs
&
&
!
channelPrefs
.
originalContents
)
{
compareLogContents
=
compareLogContents
.
replace
(
/
.
*
defaults
\
/
.
*
/
g
"
"
)
;
}
if
(
updateSettings
&
&
!
updateSettings
.
originalContents
)
{
compareLogContents
=
compareLogContents
.
replace
(
/
.
*
update
-
settings
.
ini
.
*
/
g
"
"
)
;
}
if
(
aExcludeDistDir
)
{
compareLogContents
=
compareLogContents
.
replace
(
/
.
*
distribution
\
/
.
*
/
g
"
"
)
;
}
compareLogContents
=
compareLogContents
.
replace
(
/
\
n
+
/
g
"
\
n
"
)
;
compareLogContents
=
compareLogContents
.
replace
(
/
^
\
n
|
\
n
/
g
"
"
)
;
let
compareLogContentsArray
=
compareLogContents
.
split
(
"
\
n
"
)
;
let
updateLogContentsArray
=
updateLogContents
.
split
(
"
\
n
"
)
;
while
(
updateLogContentsArray
.
length
&
&
compareLogContentsArray
.
length
)
{
if
(
updateLogContentsArray
[
0
]
=
=
compareLogContentsArray
[
0
]
)
{
compareLogContentsArray
.
shift
(
)
;
}
updateLogContentsArray
.
shift
(
)
;
}
if
(
!
compareLogContentsArray
.
length
)
{
Assert
.
ok
(
true
"
the
update
log
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
else
{
Assert
.
ok
(
false
the
update
log
is
missing
the
line
:
'
{
compareLogContentsArray
[
0
]
}
'
)
;
}
}
function
checkUpdateLogContains
(
aCheckString
)
{
let
updateLogContents
=
getLogFileContents
(
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
\
r
\
n
/
g
"
\
n
"
)
;
updateLogContents
=
removeTimeStamps
(
updateLogContents
)
;
updateLogContents
=
replaceLogPaths
(
updateLogContents
)
;
let
isFirstCompareLine
=
true
;
let
compareLogContentsArray
=
aCheckString
.
split
(
"
\
n
"
)
;
let
updateLogContentsArray
=
updateLogContents
.
split
(
"
\
n
"
)
;
while
(
updateLogContentsArray
.
length
&
&
compareLogContentsArray
.
length
)
{
let
isLastCompareLine
=
compareLogContentsArray
.
length
=
=
1
;
if
(
isFirstCompareLine
&
&
isLastCompareLine
)
{
if
(
updateLogContentsArray
[
0
]
.
includes
(
compareLogContentsArray
[
0
]
)
)
{
compareLogContentsArray
.
shift
(
)
;
isFirstCompareLine
=
false
;
}
}
else
if
(
isFirstCompareLine
)
{
if
(
updateLogContentsArray
[
0
]
.
endsWith
(
compareLogContentsArray
[
0
]
)
)
{
compareLogContentsArray
.
shift
(
)
;
isFirstCompareLine
=
false
;
}
}
else
if
(
isLastCompareLine
)
{
if
(
updateLogContentsArray
[
0
]
.
startsWith
(
compareLogContentsArray
[
0
]
)
)
{
compareLogContentsArray
.
shift
(
)
;
}
}
else
if
(
updateLogContentsArray
[
0
]
=
=
compareLogContentsArray
[
0
]
)
{
compareLogContentsArray
.
shift
(
)
;
}
updateLogContentsArray
.
shift
(
)
;
}
if
(
!
compareLogContentsArray
.
length
)
{
Assert
.
ok
(
true
"
the
update
log
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
else
{
Assert
.
ok
(
false
the
update
log
is
missing
the
line
:
'
{
compareLogContentsArray
[
0
]
}
'
)
;
}
}
function
checkFilesAfterUpdateSuccess
(
aGetFileFunc
aStageDirExists
=
false
aToBeDeletedDirExists
=
false
)
{
debugDump
(
"
testing
contents
of
files
after
a
successful
update
"
)
;
gTestFiles
.
forEach
(
function
CFAUS_TF_FE
(
aTestFile
)
{
let
testFile
=
aGetFileFunc
(
aTestFile
.
relPathDir
+
aTestFile
.
fileName
true
)
;
debugDump
(
"
testing
file
:
"
+
testFile
.
path
)
;
if
(
aTestFile
.
compareFile
|
|
aTestFile
.
compareContents
)
{
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
if
(
AppConstants
.
platform
!
=
"
win
"
&
&
aTestFile
.
comparePerms
)
{
Assert
.
equal
(
"
0o
"
+
(
testFile
.
permissions
&
0xfff
)
.
toString
(
8
)
"
0o
"
+
(
aTestFile
.
comparePerms
&
0xfff
)
.
toString
(
8
)
"
the
file
permissions
"
+
MSG_SHOULD_EQUAL
)
;
}
let
fileContents1
=
readFileBytes
(
testFile
)
;
let
fileContents2
=
aTestFile
.
compareFile
?
readFileBytes
(
getTestDirFile
(
aTestFile
.
compareFile
)
)
:
aTestFile
.
compareContents
;
if
(
fileContents1
=
=
fileContents2
)
{
Assert
.
ok
(
true
"
the
file
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
else
{
Assert
.
equal
(
fileContents1
fileContents2
"
the
file
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
}
else
{
Assert
.
ok
(
!
testFile
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
}
)
;
debugDump
(
"
testing
operations
specified
in
removed
-
files
were
performed
"
+
"
after
a
successful
update
"
)
;
gTestDirs
.
forEach
(
function
CFAUS_TD_FE
(
aTestDir
)
{
let
testDir
=
aGetFileFunc
(
aTestDir
.
relPathDir
true
)
;
debugDump
(
"
testing
directory
:
"
+
testDir
.
path
)
;
if
(
aTestDir
.
dirRemoved
)
{
Assert
.
ok
(
!
testDir
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
testDir
.
path
)
)
;
}
else
{
Assert
.
ok
(
testDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testDir
.
path
)
)
;
if
(
aTestDir
.
files
)
{
aTestDir
.
files
.
forEach
(
function
CFAUS_TD_F_FE
(
aTestFile
)
{
let
testFile
=
aGetFileFunc
(
aTestDir
.
relPathDir
+
aTestFile
true
)
;
if
(
aTestDir
.
filesRemoved
)
{
Assert
.
ok
(
!
testFile
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
else
{
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
}
)
;
}
if
(
aTestDir
.
subDirs
)
{
aTestDir
.
subDirs
.
forEach
(
function
CFAUS_TD_SD_FE
(
aSubDir
)
{
let
testSubDir
=
aGetFileFunc
(
aTestDir
.
relPathDir
+
aSubDir
true
)
;
Assert
.
ok
(
testSubDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testSubDir
.
path
)
)
;
if
(
aTestDir
.
subDirFiles
)
{
aTestDir
.
subDirFiles
.
forEach
(
function
CFAUS_TD_SDF_FE
(
aTestFile
)
{
let
testFile
=
aGetFileFunc
(
aTestDir
.
relPathDir
+
aSubDir
+
aTestFile
true
)
;
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
)
;
}
}
)
;
}
}
}
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
debugDump
(
"
testing
that
xattrs
were
preserved
after
a
successful
update
"
)
;
IOUtils
.
getMacXAttr
(
getApplyDirFile
(
)
.
path
MAC_APP_XATTR_KEY
)
.
then
(
bytes
=
>
{
Assert
.
equal
(
new
TextDecoder
(
)
.
decode
(
bytes
)
MAC_APP_XATTR_VALUE
"
xattr
value
changed
"
)
;
}
_reason
=
>
{
Assert
.
fail
(
MAC_APP_XATTR_KEY
+
"
xattr
is
missing
!
"
)
;
}
)
;
}
checkFilesAfterUpdateCommon
(
aStageDirExists
aToBeDeletedDirExists
)
;
}
function
checkFilesAfterUpdateFailure
(
aGetFileFunc
aStageDirExists
=
false
aToBeDeletedDirExists
=
false
)
{
debugDump
(
"
testing
contents
of
files
after
a
failed
update
"
)
;
gTestFiles
.
forEach
(
function
CFAUF_TF_FE
(
aTestFile
)
{
let
testFile
=
aGetFileFunc
(
aTestFile
.
relPathDir
+
aTestFile
.
fileName
true
)
;
debugDump
(
"
testing
file
:
"
+
testFile
.
path
)
;
if
(
aTestFile
.
compareFile
|
|
aTestFile
.
compareContents
)
{
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
if
(
AppConstants
.
platform
!
=
"
win
"
&
&
aTestFile
.
comparePerms
)
{
Assert
.
equal
(
testFile
.
permissions
&
0xfff
aTestFile
.
comparePerms
&
0xfff
"
the
file
permissions
"
+
MSG_SHOULD_EQUAL
)
;
}
let
fileContents1
=
readFileBytes
(
testFile
)
;
let
fileContents2
=
aTestFile
.
compareFile
?
readFileBytes
(
getTestDirFile
(
aTestFile
.
compareFile
)
)
:
aTestFile
.
compareContents
;
if
(
fileContents1
=
=
fileContents2
)
{
Assert
.
ok
(
true
"
the
file
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
else
{
Assert
.
equal
(
fileContents1
fileContents2
"
the
file
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
}
else
{
Assert
.
ok
(
!
testFile
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
}
)
;
debugDump
(
"
testing
operations
specified
in
removed
-
files
were
not
"
+
"
performed
after
a
failed
update
"
)
;
gTestDirs
.
forEach
(
function
CFAUF_TD_FE
(
aTestDir
)
{
let
testDir
=
aGetFileFunc
(
aTestDir
.
relPathDir
true
)
;
Assert
.
ok
(
testDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testDir
.
path
)
)
;
if
(
aTestDir
.
files
)
{
aTestDir
.
files
.
forEach
(
function
CFAUS_TD_F_FE
(
aTestFile
)
{
let
testFile
=
aGetFileFunc
(
aTestDir
.
relPathDir
+
aTestFile
true
)
;
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
)
;
}
if
(
aTestDir
.
subDirs
)
{
aTestDir
.
subDirs
.
forEach
(
function
CFAUS_TD_SD_FE
(
aSubDir
)
{
let
testSubDir
=
aGetFileFunc
(
aTestDir
.
relPathDir
+
aSubDir
true
)
;
Assert
.
ok
(
testSubDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testSubDir
.
path
)
)
;
if
(
aTestDir
.
subDirFiles
)
{
aTestDir
.
subDirFiles
.
forEach
(
function
CFAUS_TD_SDF_FE
(
aTestFile
)
{
let
testFile
=
aGetFileFunc
(
aTestDir
.
relPathDir
+
aSubDir
+
aTestFile
true
)
;
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
)
;
}
}
)
;
}
}
)
;
checkFilesAfterUpdateCommon
(
aStageDirExists
aToBeDeletedDirExists
)
;
}
function
checkFilesAfterUpdateCommon
(
aStageDirExists
aToBeDeletedDirExists
)
{
debugDump
(
"
testing
extra
directories
"
)
;
let
stageDir
=
getStageDirFile
(
)
;
if
(
aStageDirExists
)
{
Assert
.
ok
(
stageDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
stageDir
.
path
)
)
;
}
else
{
Assert
.
ok
(
!
stageDir
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
stageDir
.
path
)
)
;
}
let
toBeDeletedDirExists
=
AppConstants
.
platform
=
=
"
win
"
?
aToBeDeletedDirExists
:
false
;
let
toBeDeletedDir
=
getApplyDirFile
(
DIR_TOBEDELETED
)
;
if
(
toBeDeletedDirExists
)
{
Assert
.
ok
(
toBeDeletedDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
toBeDeletedDir
.
path
)
)
;
}
else
{
Assert
.
ok
(
!
toBeDeletedDir
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
toBeDeletedDir
.
path
)
)
;
}
let
updatingDir
=
getApplyDirFile
(
"
updating
"
)
;
Assert
.
ok
(
!
updatingDir
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
updatingDir
.
path
)
)
;
if
(
stageDir
.
exists
(
)
)
{
updatingDir
=
stageDir
.
clone
(
)
;
updatingDir
.
append
(
"
updating
"
)
;
Assert
.
ok
(
!
updatingDir
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
updatingDir
.
path
)
)
;
}
debugDump
(
"
testing
backup
files
should
not
be
left
behind
in
the
"
+
"
application
directory
"
)
;
let
applyToDir
=
getApplyDirFile
(
)
;
checkFilesInDirRecursive
(
applyToDir
checkForBackupFiles
)
;
if
(
stageDir
.
exists
(
)
)
{
debugDump
(
"
testing
backup
files
should
not
be
left
behind
in
the
"
+
"
staging
directory
"
)
;
checkFilesInDirRecursive
(
stageDir
checkForBackupFiles
)
;
}
}
function
checkCallbackLog
(
appLaunchLog
=
getApplyDirFile
(
DIR_MACOS
+
gCallbackArgs
[
1
]
)
)
{
if
(
!
appLaunchLog
.
exists
(
)
)
{
debugDump
(
"
Callback
log
does
not
exist
yet
.
Path
:
"
+
appLaunchLog
.
path
)
;
do_timeout
(
FILE_IN_USE_TIMEOUT_MS
checkCallbackLog
)
;
return
;
}
let
expectedLogContents
=
gCallbackArgs
.
join
(
"
\
n
"
)
+
"
\
n
"
;
let
logContents
=
readFile
(
appLaunchLog
)
;
const
MAX_TIMEOUT_RUNS
=
20000
;
if
(
logContents
!
=
expectedLogContents
)
{
gTimeoutRuns
+
+
;
if
(
gTimeoutRuns
>
MAX_TIMEOUT_RUNS
)
{
logTestInfo
(
"
callback
log
contents
are
not
correct
"
)
;
let
aryLog
=
logContents
.
split
(
"
\
n
"
)
;
let
aryCompare
=
expectedLogContents
.
split
(
"
\
n
"
)
;
aryLog
.
push
(
"
"
)
;
aryCompare
.
push
(
"
"
)
;
for
(
let
i
=
0
;
i
<
aryLog
.
length
;
+
+
i
)
{
if
(
aryLog
[
i
]
!
=
aryCompare
[
i
]
)
{
logTestInfo
(
"
the
first
incorrect
line
in
the
callback
log
is
:
"
+
aryLog
[
i
]
)
;
Assert
.
equal
(
aryLog
[
i
]
aryCompare
[
i
]
"
the
callback
log
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
}
do_throw
(
"
Unable
to
find
incorrect
callback
log
contents
!
"
)
;
}
do_timeout
(
FILE_IN_USE_TIMEOUT_MS
checkCallbackLog
)
;
return
;
}
Assert
.
ok
(
true
"
the
callback
log
contents
"
+
MSG_SHOULD_EQUAL
)
;
waitForFilesInUse
(
)
;
}
function
getPostUpdateFile
(
aSuffix
)
{
return
getApplyDirFile
(
DIR_MACOS
+
gPostUpdateBinFile
+
aSuffix
)
;
}
async
function
checkPostUpdateAppLog
(
{
expectedContents
=
"
post
-
update
\
n
"
}
=
{
}
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
|
|
AppConstants
.
platform
=
=
"
win
"
)
{
let
file
=
getPostUpdateFile
(
"
.
log
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
file
.
exists
(
)
"
Waiting
for
file
to
exist
path
:
"
+
file
.
path
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
readFile
(
file
)
=
=
expectedContents
"
Waiting
for
expected
file
contents
:
"
+
expectedContents
+
"
first
read
:
"
+
readFile
(
file
)
)
;
Assert
.
equal
(
readFile
(
file
)
expectedContents
"
the
post
update
log
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
}
function
isFileInUse
(
aFile
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
if
(
!
aFile
.
exists
(
)
)
{
debugDump
(
"
file
does
not
exist
path
:
"
+
aFile
.
path
)
;
return
false
;
}
let
fileBak
=
aFile
.
parent
;
fileBak
.
append
(
aFile
.
leafName
+
"
.
bak
"
)
;
try
{
if
(
fileBak
.
exists
(
)
)
{
fileBak
.
remove
(
false
)
;
}
aFile
.
copyTo
(
aFile
.
parent
fileBak
.
leafName
)
;
aFile
.
remove
(
false
)
;
fileBak
.
moveTo
(
aFile
.
parent
aFile
.
leafName
)
;
debugDump
(
"
file
is
not
in
use
path
:
"
+
aFile
.
path
)
;
return
false
;
}
catch
(
e
)
{
debugDump
(
"
file
in
use
path
:
"
+
aFile
.
path
+
"
Exception
:
"
+
e
)
;
try
{
if
(
fileBak
.
exists
(
)
)
{
fileBak
.
remove
(
false
)
;
}
}
catch
(
ex
)
{
logTestInfo
(
"
unable
to
remove
backup
file
path
:
"
+
fileBak
.
path
+
"
Exception
:
"
+
ex
)
;
}
}
return
true
;
}
async
function
waitForFilesInUse
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
fileNames
=
[
FILE_APP_BIN
FILE_UPDATER_BIN
FILE_MAINTENANCE_SERVICE_INSTALLER_BIN
]
;
for
(
let
i
=
0
;
i
<
fileNames
.
length
;
+
+
i
)
{
let
file
=
getApplyDirFile
(
fileNames
[
i
]
)
;
if
(
isFileInUse
(
file
)
)
{
do_timeout
(
FILE_IN_USE_TIMEOUT_MS
waitForFilesInUse
)
;
return
;
}
}
}
debugDump
(
"
calling
doTestFinish
"
)
;
await
doTestFinish
(
)
;
}
function
checkForBackupFiles
(
aFile
)
{
Assert
.
notEqual
(
getFileExtension
(
aFile
)
"
moz
-
backup
"
"
the
file
'
s
extension
should
not
equal
moz
-
backup
"
+
getMsgPath
(
aFile
.
path
)
)
;
}
function
checkFilesInDirRecursive
(
aDir
aCallback
)
{
if
(
!
aDir
.
exists
(
)
)
{
do_throw
(
"
Directory
must
exist
!
"
)
;
}
let
dirEntries
=
aDir
.
directoryEntries
;
while
(
dirEntries
.
hasMoreElements
(
)
)
{
let
entry
=
dirEntries
.
nextFile
;
if
(
entry
.
exists
(
)
)
{
if
(
entry
.
isDirectory
(
)
)
{
checkFilesInDirRecursive
(
entry
aCallback
)
;
}
else
{
aCallback
(
entry
)
;
}
}
}
}
async
function
waitForUpdateCheck
(
aSuccess
aExpectedValues
=
{
}
)
{
let
check
=
gUpdateChecker
.
checkForUpdates
(
gUpdateChecker
.
FOREGROUND_CHECK
)
;
let
result
=
await
check
.
result
;
Assert
.
ok
(
result
.
checksAllowed
"
We
should
be
able
to
check
for
updates
"
)
;
Assert
.
equal
(
result
.
succeeded
aSuccess
"
the
update
check
should
"
+
(
aSuccess
?
"
succeed
"
:
"
error
"
)
)
;
if
(
aExpectedValues
.
updateCount
)
{
Assert
.
equal
(
aExpectedValues
.
updateCount
result
.
updates
.
length
"
the
update
count
"
+
MSG_SHOULD_EQUAL
)
;
}
if
(
aExpectedValues
.
url
)
{
Assert
.
equal
(
aExpectedValues
.
url
result
.
request
.
channel
.
originalURI
.
spec
"
the
url
"
+
MSG_SHOULD_EQUAL
)
;
}
return
result
;
}
async
function
waitForUpdateDownload
(
aUpdates
aExpectedStatus
)
{
let
bestUpdate
=
await
gAUS
.
selectUpdate
(
aUpdates
)
;
let
result
=
await
gAUS
.
downloadUpdate
(
bestUpdate
false
)
;
if
(
result
!
=
Ci
.
nsIApplicationUpdateService
.
DOWNLOAD_SUCCESS
)
{
do_throw
(
"
nsIApplicationUpdateService
:
downloadUpdate
returned
"
+
result
)
;
}
return
new
Promise
(
resolve
=
>
gAUS
.
addDownloadListener
(
{
onStartRequest
:
_aRequest
=
>
{
}
onProgress
:
(
_aRequest
_aContext
_aProgress
_aMaxProgress
)
=
>
{
}
onStatus
:
(
_aRequest
_aStatus
_aStatusText
)
=
>
{
}
onStopRequest
(
request
status
)
{
gAUS
.
removeDownloadListener
(
this
)
;
Assert
.
equal
(
aExpectedStatus
status
"
the
download
status
"
+
MSG_SHOULD_EQUAL
)
;
resolve
(
request
status
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIRequestObserver
"
"
nsIProgressEventSink
"
]
)
}
)
)
;
}
function
start_httpserver
(
)
{
let
dir
=
getTestDirFile
(
)
;
debugDump
(
"
http
server
directory
path
:
"
+
dir
.
path
)
;
if
(
!
dir
.
isDirectory
(
)
)
{
do_throw
(
"
A
file
instead
of
a
directory
was
specified
for
HttpServer
"
+
"
registerDirectory
!
Path
:
"
+
dir
.
path
)
;
}
let
{
HttpServer
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
httpd
.
sys
.
mjs
"
)
;
gTestserver
=
new
HttpServer
(
)
;
gTestserver
.
registerDirectory
(
"
/
"
dir
)
;
gTestserver
.
registerPathHandler
(
"
/
"
+
gHTTPHandlerPath
pathHandler
)
;
gTestserver
.
start
(
-
1
)
;
let
testserverPort
=
gTestserver
.
identity
.
primaryPort
;
gURLData
=
URL_HOST
+
"
:
"
+
testserverPort
+
"
/
"
;
debugDump
(
"
http
server
port
=
"
+
testserverPort
)
;
}
function
pathHandler
(
aMetadata
aResponse
)
{
gUpdateCheckCount
+
=
1
;
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
xml
"
false
)
;
aResponse
.
setStatusLine
(
aMetadata
.
httpVersion
200
"
OK
"
)
;
aResponse
.
bodyOutputStream
.
write
(
gResponseBody
gResponseBody
.
length
)
;
}
function
stop_httpserver
(
aCallback
)
{
Assert
.
ok
(
!
!
aCallback
"
the
aCallback
parameter
should
be
defined
"
)
;
gTestserver
.
stop
(
aCallback
)
;
}
function
createAppInfo
(
aID
aName
aVersion
aPlatformVersion
)
{
updateAppInfo
(
{
vendor
:
APP_INFO_VENDOR
name
:
aName
ID
:
aID
version
:
aVersion
appBuildID
:
"
2007010101
"
platformVersion
:
aPlatformVersion
platformBuildID
:
"
2007010101
"
inSafeMode
:
false
logConsoleErrors
:
true
OS
:
"
XPCShell
"
XPCOMABI
:
"
noarch
-
spidermonkey
"
}
)
;
}
function
getProcessArgs
(
aExtraArgs
)
{
if
(
!
aExtraArgs
)
{
aExtraArgs
=
[
]
;
}
let
appBin
=
getApplyDirFile
(
DIR_MACOS
+
FILE_APP_BIN
)
;
Assert
.
ok
(
appBin
.
exists
(
)
MSG_SHOULD_EXIST
+
"
path
:
"
+
appBin
.
path
)
;
let
appBinPath
=
appBin
.
path
;
let
profileDir
=
appBin
.
parent
.
parent
;
if
(
gIsServiceTest
&
&
IS_AUTHENTICODE_CHECK_ENABLED
)
{
profileDir
=
do_get_tempdir
(
)
;
}
profileDir
.
append
(
"
profile
"
)
;
let
profilePath
=
profileDir
.
path
;
let
args
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
|
|
AppConstants
.
platform
=
=
"
linux
"
)
{
let
launchScript
=
getLaunchScript
(
)
;
launchScript
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
PERMS_DIRECTORY
)
;
let
scriptContents
=
"
#
!
/
bin
/
sh
\
n
"
;
scriptContents
+
=
"
export
XRE_PROFILE_PATH
=
"
+
profilePath
+
"
\
n
"
;
scriptContents
+
=
appBinPath
+
"
-
test
-
process
-
updates
"
+
aExtraArgs
.
join
(
"
"
)
+
"
"
+
PIPE_TO_NULL
;
writeFile
(
launchScript
scriptContents
)
;
debugDump
(
"
created
"
+
launchScript
.
path
+
"
containing
:
\
n
"
+
scriptContents
)
;
args
=
[
launchScript
.
path
]
;
}
else
{
args
=
[
"
/
D
"
"
/
Q
"
"
/
C
"
appBinPath
"
-
profile
"
profilePath
"
-
test
-
process
-
updates
"
"
-
wait
-
for
-
browser
"
]
.
concat
(
aExtraArgs
)
.
concat
(
[
PIPE_TO_NULL
]
)
;
}
return
args
;
}
function
getAppArgsLogPath
(
)
{
let
appArgsLog
=
do_get_file
(
"
/
"
+
gTestID
+
"
_app_args_log
"
true
)
;
if
(
appArgsLog
.
exists
(
)
)
{
appArgsLog
.
remove
(
false
)
;
}
let
appArgsLogPath
=
appArgsLog
.
path
;
if
(
/
/
.
test
(
appArgsLogPath
)
)
{
appArgsLogPath
=
'
"
'
+
appArgsLogPath
+
'
"
'
;
}
return
appArgsLogPath
;
}
function
getLaunchScript
(
)
{
let
launchScript
=
do_get_file
(
"
/
"
+
gTestID
+
"
_launch
.
sh
"
true
)
;
if
(
launchScript
.
exists
(
)
)
{
launchScript
.
remove
(
false
)
;
}
return
launchScript
;
}
function
adjustGeneralPaths
(
)
{
let
dirProvider
=
{
getFile
:
function
AGP_DP_getFile
(
aProp
aPersistent
)
{
aPersistent
.
value
=
false
;
switch
(
aProp
)
{
case
NS_GRE_DIR
:
return
getApplyDirFile
(
DIR_RESOURCES
)
;
case
NS_GRE_BIN_DIR
:
return
getApplyDirFile
(
DIR_MACOS
)
;
case
XRE_EXECUTABLE_FILE
:
return
getApplyDirFile
(
DIR_MACOS
+
FILE_APP_BIN
)
;
case
XRE_UPDATE_ROOT_DIR
:
return
getMockUpdRootD
(
)
;
case
XRE_OLD_UPDATE_ROOT_DIR
:
return
getMockUpdRootD
(
true
)
;
}
return
null
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIDirectoryServiceProvider
"
]
)
}
;
let
ds
=
Services
.
dirsvc
.
QueryInterface
(
Ci
.
nsIDirectoryService
)
;
ds
.
QueryInterface
(
Ci
.
nsIProperties
)
.
undefine
(
NS_GRE_DIR
)
;
ds
.
QueryInterface
(
Ci
.
nsIProperties
)
.
undefine
(
NS_GRE_BIN_DIR
)
;
ds
.
QueryInterface
(
Ci
.
nsIProperties
)
.
undefine
(
XRE_EXECUTABLE_FILE
)
;
ds
.
registerProvider
(
dirProvider
)
;
registerCleanupFunction
(
function
AGP_cleanup
(
)
{
debugDump
(
"
start
-
unregistering
directory
provider
"
)
;
if
(
gAppTimer
)
{
debugDump
(
"
start
-
cancel
app
timer
"
)
;
gAppTimer
.
cancel
(
)
;
gAppTimer
=
null
;
debugDump
(
"
finish
-
cancel
app
timer
"
)
;
}
if
(
gProcess
&
&
gProcess
.
isRunning
)
{
debugDump
(
"
start
-
kill
process
"
)
;
try
{
gProcess
.
kill
(
)
;
}
catch
(
e
)
{
debugDump
(
"
kill
process
failed
Exception
:
"
+
e
)
;
}
gProcess
=
null
;
debugDump
(
"
finish
-
kill
process
"
)
;
}
if
(
gPIDPersistProcess
&
&
gPIDPersistProcess
.
isRunning
)
{
debugDump
(
"
start
-
kill
pid
persist
process
"
)
;
try
{
gPIDPersistProcess
.
kill
(
)
;
}
catch
(
e
)
{
debugDump
(
"
kill
pid
persist
process
failed
Exception
:
"
+
e
)
;
}
gPIDPersistProcess
=
null
;
debugDump
(
"
finish
-
kill
pid
persist
process
"
)
;
}
if
(
gHandle
)
{
try
{
debugDump
(
"
start
-
closing
handle
"
)
;
let
kernel32
=
ctypes
.
open
(
"
kernel32
"
)
;
let
CloseHandle
=
kernel32
.
declare
(
"
CloseHandle
"
ctypes
.
winapi_abi
ctypes
.
bool
ctypes
.
voidptr_t
)
;
if
(
!
CloseHandle
(
gHandle
)
)
{
debugDump
(
"
call
to
CloseHandle
failed
"
)
;
}
kernel32
.
close
(
)
;
gHandle
=
null
;
debugDump
(
"
finish
-
closing
handle
"
)
;
}
catch
(
e
)
{
debugDump
(
"
call
to
CloseHandle
failed
Exception
:
"
+
e
)
;
}
}
ds
.
unregisterProvider
(
dirProvider
)
;
cleanupTestCommon
(
)
;
let
syncManager
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
sync
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateSyncManager
)
;
syncManager
.
resetLock
(
)
;
debugDump
(
"
finish
-
unregistering
directory
provider
"
)
;
}
)
;
}
const
gAppTimerCallback
=
{
notify
:
function
TC_notify
(
_aTimer
)
{
gAppTimer
=
null
;
if
(
gProcess
.
isRunning
)
{
logTestInfo
(
"
attempting
to
kill
process
"
)
;
gProcess
.
kill
(
)
;
}
Assert
.
ok
(
false
"
launch
application
timer
expired
"
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsITimerCallback
"
]
)
}
;
async
function
runUpdateUsingApp
(
aExpectedStatus
)
{
debugDump
(
"
start
-
launching
application
to
apply
update
"
)
;
const
APP_TIMER_TIMEOUT
=
120000
;
let
launchBin
=
getLaunchBin
(
)
;
let
args
=
getProcessArgs
(
)
;
debugDump
(
"
launching
"
+
launchBin
.
path
+
"
"
+
args
.
join
(
"
"
)
)
;
gProcess
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
gProcess
.
init
(
launchBin
)
;
gAppTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
gAppTimer
.
initWithCallback
(
gAppTimerCallback
APP_TIMER_TIMEOUT
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
setEnvironment
(
)
;
debugDump
(
"
launching
application
"
)
;
gProcess
.
run
(
true
args
args
.
length
)
;
debugDump
(
"
launched
application
exited
"
)
;
resetEnvironment
(
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
waitForApplicationStop
(
FILE_UPDATER_BIN
)
;
}
let
file
=
getUpdateDirFile
(
FILE_UPDATE_STATUS
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
file
.
exists
(
)
"
Waiting
for
file
to
exist
path
:
"
+
file
.
path
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
readStatusFile
(
)
=
=
aExpectedStatus
"
Waiting
for
expected
status
file
contents
:
"
+
aExpectedStatus
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
Assert
.
equal
(
readStatusFile
(
)
aExpectedStatus
"
the
status
file
state
"
+
MSG_SHOULD_EQUAL
)
;
if
(
aExpectedStatus
!
=
STATE_PENDING
&
&
aExpectedStatus
!
=
STATE_PENDING_SVC
&
&
aExpectedStatus
!
=
STATE_APPLIED
&
&
aExpectedStatus
!
=
STATE_APPLIED_SVC
)
{
file
=
getUpdateDirFile
(
FILE_UPDATE_LOG
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
file
.
exists
(
)
"
Waiting
for
file
to
exist
path
:
"
+
file
.
path
)
;
}
debugDump
(
"
finish
-
launching
application
to
apply
update
"
)
;
}
function
initMockIncrementalDownload
(
)
{
const
INC_CONTRACT_ID
=
"
mozilla
.
org
/
network
/
incremental
-
download
;
1
"
;
let
incrementalDownloadCID
=
MockRegistrar
.
register
(
INC_CONTRACT_ID
IncrementalDownload
)
;
registerCleanupFunction
(
(
)
=
>
{
MockRegistrar
.
unregister
(
incrementalDownloadCID
)
;
}
)
;
}
function
IncrementalDownload
(
)
{
this
.
wrappedJSObject
=
this
;
}
IncrementalDownload
.
prototype
=
{
init
(
uri
file
_chunkSize
_intervalInSeconds
)
{
this
.
_destination
=
file
;
this
.
_URI
=
uri
;
this
.
_finalURI
=
uri
;
}
start
(
observer
ctxt
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
this
.
_observer
=
observer
.
QueryInterface
(
Ci
.
nsIRequestObserver
)
;
this
.
_ctxt
=
ctxt
;
this
.
_observer
.
onStartRequest
(
this
)
;
let
mar
=
getTestDirFile
(
FILE_SIMPLE_MAR
)
;
mar
.
copyTo
(
this
.
_destination
.
parent
this
.
_destination
.
leafName
)
;
let
status
=
Cr
.
NS_OK
;
switch
(
gIncrementalDownloadErrorType
+
+
)
{
case
0
:
status
=
Cr
.
NS_ERROR_NET_RESET
;
break
;
case
1
:
status
=
Cr
.
NS_ERROR_CONNECTION_REFUSED
;
break
;
case
2
:
status
=
Cr
.
NS_ERROR_NET_RESET
;
break
;
case
3
:
status
=
Cr
.
NS_OK
;
break
;
case
4
:
status
=
Cr
.
NS_ERROR_OFFLINE
;
Services
.
tm
.
dispatchToMainThread
(
function
(
)
{
Services
.
obs
.
notifyObservers
(
gAUS
"
network
:
offline
-
status
-
changed
"
"
online
"
)
;
}
)
;
break
;
}
this
.
_observer
.
onStopRequest
(
this
status
)
;
}
)
;
}
get
URI
(
)
{
return
this
.
_URI
;
}
get
currentSize
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
get
destination
(
)
{
return
this
.
_destination
;
}
get
finalURI
(
)
{
return
this
.
_finalURI
;
}
get
totalSize
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
cancel
(
_aStatus
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
suspend
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
isPending
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
_loadFlags
:
0
get
loadFlags
(
)
{
return
this
.
_loadFlags
;
}
set
loadFlags
(
val
)
{
this
.
_loadFlags
=
val
;
}
_loadGroup
:
null
get
loadGroup
(
)
{
return
this
.
_loadGroup
;
}
set
loadGroup
(
val
)
{
this
.
_loadGroup
=
val
;
}
_name
:
"
"
get
name
(
)
{
return
this
.
_name
;
}
_status
:
0
get
status
(
)
{
return
this
.
_status
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIIncrementalDownload
"
]
)
}
;
function
setEnvironment
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
Services
.
env
.
set
(
"
CURWORKDIRPATH
"
getApplyDirFile
(
)
.
path
)
;
}
if
(
gShouldResetEnv
!
=
=
undefined
)
{
return
;
}
gShouldResetEnv
=
true
;
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
!
Services
.
env
.
exists
(
"
XRE_NO_WINDOWS_CRASH_DIALOG
"
)
)
{
gAddedEnvXRENoWindowsCrashDialog
=
true
;
debugDump
(
"
setting
the
XRE_NO_WINDOWS_CRASH_DIALOG
environment
"
+
"
variable
to
1
.
.
.
previously
it
didn
'
t
exist
"
)
;
Services
.
env
.
set
(
"
XRE_NO_WINDOWS_CRASH_DIALOG
"
"
1
"
)
;
}
if
(
Services
.
env
.
exists
(
"
XPCOM_MEM_LEAK_LOG
"
)
)
{
gEnvXPCOMMemLeakLog
=
Services
.
env
.
get
(
"
XPCOM_MEM_LEAK_LOG
"
)
;
debugDump
(
"
removing
the
XPCOM_MEM_LEAK_LOG
environment
variable
.
.
.
"
+
"
previous
value
"
+
gEnvXPCOMMemLeakLog
)
;
Services
.
env
.
set
(
"
XPCOM_MEM_LEAK_LOG
"
"
"
)
;
}
if
(
Services
.
env
.
exists
(
"
XPCOM_DEBUG_BREAK
"
)
)
{
gEnvXPCOMDebugBreak
=
Services
.
env
.
get
(
"
XPCOM_DEBUG_BREAK
"
)
;
debugDump
(
"
setting
the
XPCOM_DEBUG_BREAK
environment
variable
to
"
+
"
warn
.
.
.
previous
value
"
+
gEnvXPCOMDebugBreak
)
;
}
else
{
debugDump
(
"
setting
the
XPCOM_DEBUG_BREAK
environment
variable
to
"
+
"
warn
.
.
.
previously
it
didn
'
t
exist
"
)
;
}
Services
.
env
.
set
(
"
XPCOM_DEBUG_BREAK
"
"
warn
"
)
;
if
(
gEnvForceServiceFallback
)
{
debugDump
(
"
setting
MOZ_FORCE_SERVICE_FALLBACK
environment
variable
to
1
"
)
;
Services
.
env
.
set
(
"
MOZ_FORCE_SERVICE_FALLBACK
"
"
1
"
)
;
}
else
if
(
gIsServiceTest
)
{
debugDump
(
"
setting
MOZ_NO_SERVICE_FALLBACK
environment
variable
to
1
"
)
;
Services
.
env
.
set
(
"
MOZ_NO_SERVICE_FALLBACK
"
"
1
"
)
;
}
}
function
resetEnvironment
(
)
{
if
(
gShouldResetEnv
!
=
=
true
)
{
return
;
}
gShouldResetEnv
=
false
;
if
(
gEnvXPCOMMemLeakLog
)
{
debugDump
(
"
setting
the
XPCOM_MEM_LEAK_LOG
environment
variable
back
to
"
+
gEnvXPCOMMemLeakLog
)
;
Services
.
env
.
set
(
"
XPCOM_MEM_LEAK_LOG
"
gEnvXPCOMMemLeakLog
)
;
}
if
(
gEnvXPCOMDebugBreak
)
{
debugDump
(
"
setting
the
XPCOM_DEBUG_BREAK
environment
variable
back
to
"
+
gEnvXPCOMDebugBreak
)
;
Services
.
env
.
set
(
"
XPCOM_DEBUG_BREAK
"
gEnvXPCOMDebugBreak
)
;
}
else
if
(
Services
.
env
.
exists
(
"
XPCOM_DEBUG_BREAK
"
)
)
{
debugDump
(
"
clearing
the
XPCOM_DEBUG_BREAK
environment
variable
"
)
;
Services
.
env
.
set
(
"
XPCOM_DEBUG_BREAK
"
"
"
)
;
}
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
gAddedEnvXRENoWindowsCrashDialog
)
{
debugDump
(
"
removing
the
XRE_NO_WINDOWS_CRASH_DIALOG
environment
variable
"
)
;
Services
.
env
.
set
(
"
XRE_NO_WINDOWS_CRASH_DIALOG
"
"
"
)
;
}
if
(
gEnvForceServiceFallback
)
{
debugDump
(
"
removing
MOZ_FORCE_SERVICE_FALLBACK
environment
variable
"
)
;
Services
.
env
.
set
(
"
MOZ_FORCE_SERVICE_FALLBACK
"
"
"
)
;
}
else
if
(
gIsServiceTest
)
{
debugDump
(
"
removing
MOZ_NO_SERVICE_FALLBACK
environment
variable
"
)
;
Services
.
env
.
set
(
"
MOZ_NO_SERVICE_FALLBACK
"
"
"
)
;
}
}
function
setUpdateSettingsUseWrongChannel
(
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
replacementUpdateSettings
=
Services
.
dirsvc
.
get
(
"
CurWorkD
"
Ci
.
nsIFile
)
;
replacementUpdateSettings
=
replacementUpdateSettings
.
parent
;
replacementUpdateSettings
.
append
(
"
UpdateSettings
-
WrongChannel
"
)
;
const
updateSettings
=
getTestFileByName
(
FILE_UPDATE_SETTINGS_FRAMEWORK
)
;
if
(
!
updateSettings
)
{
throw
new
Error
(
"
gTestFiles
does
not
contain
the
update
settings
framework
"
)
;
}
updateSettings
.
existingFile
=
false
;
updateSettings
.
originalContents
=
readFileBytes
(
replacementUpdateSettings
)
;
}
else
{
const
updateSettings
=
getTestFileByName
(
FILE_UPDATE_SETTINGS_INI
)
;
if
(
!
updateSettings
)
{
throw
new
Error
(
"
gTestFiles
does
not
contain
the
update
settings
INI
"
)
;
}
updateSettings
.
originalContents
=
UPDATE_SETTINGS_CONTENTS
.
replace
(
"
xpcshell
-
test
"
"
wrong
-
channel
"
)
;
}
}
