'
use
strict
'
;
const
{
classes
:
Cc
interfaces
:
Ci
manager
:
Cm
results
:
Cr
utils
:
Cu
}
=
Components
;
load
(
"
.
.
/
data
/
xpcshellConstantsPP
.
js
"
)
;
function
getLogSuffix
(
)
{
if
(
IS_WIN
)
{
return
"
_win
"
;
}
if
(
IS_MACOSX
)
{
return
"
_mac
"
;
}
if
(
IS_TOOLKIT_GONK
)
{
return
"
_gonk
"
;
}
return
"
_linux
"
;
}
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
this
)
;
const
DIR_MACOS
=
IS_MACOSX
?
"
Contents
/
MacOS
/
"
:
"
"
;
const
DIR_RESOURCES
=
IS_MACOSX
?
"
Contents
/
Resources
/
"
:
"
"
;
const
TEST_FILE_SUFFIX
=
IS_MACOSX
?
"
_mac
"
:
"
"
;
const
FILE_COMPLETE_MAR
=
"
complete
"
+
TEST_FILE_SUFFIX
+
"
.
mar
"
;
const
FILE_PARTIAL_MAR
=
"
partial
"
+
TEST_FILE_SUFFIX
+
"
.
mar
"
;
const
FILE_COMPLETE_PRECOMPLETE
=
"
complete_precomplete
"
+
TEST_FILE_SUFFIX
;
const
FILE_PARTIAL_PRECOMPLETE
=
"
partial_precomplete
"
+
TEST_FILE_SUFFIX
;
const
FILE_COMPLETE_REMOVEDFILES
=
"
complete_removed
-
files
"
+
TEST_FILE_SUFFIX
;
const
FILE_PARTIAL_REMOVEDFILES
=
"
partial_removed
-
files
"
+
TEST_FILE_SUFFIX
;
const
FILE_UPDATE_IN_PROGRESS_LOCK
=
"
updated
.
update_in_progress
.
lock
"
;
const
COMPARE_LOG_SUFFIX
=
getLogSuffix
(
)
;
const
LOG_COMPLETE_SUCCESS
=
"
complete_log_success
"
+
COMPARE_LOG_SUFFIX
;
const
LOG_PARTIAL_SUCCESS
=
"
partial_log_success
"
+
COMPARE_LOG_SUFFIX
;
const
LOG_PARTIAL_FAILURE
=
"
partial_log_failure
"
+
COMPARE_LOG_SUFFIX
;
const
LOG_COMPLETE_SUCCESS_STAGE
=
LOG_COMPLETE_SUCCESS
+
(
IS_TOOLKIT_GONK
?
"
_stage
"
:
"
"
)
;
const
LOG_PARTIAL_SUCCESS_STAGE
=
LOG_PARTIAL_SUCCESS
+
(
IS_TOOLKIT_GONK
?
"
_stage
"
:
"
"
)
;
const
LOG_REPLACE_SUCCESS
=
"
replace_log_success
"
;
const
USE_EXECV
=
IS_UNIX
&
&
!
IS_MACOSX
;
const
URL_HOST
=
"
http
:
/
/
localhost
"
;
const
FILE_APP_BIN
=
MOZ_APP_NAME
+
APP_BIN_SUFFIX
;
const
FILE_COMPLETE_EXE
=
"
complete
.
exe
"
;
const
FILE_HELPER_BIN
=
"
TestAUSHelper
"
+
BIN_SUFFIX
;
const
FILE_MAINTENANCE_SERVICE_BIN
=
"
maintenanceservice
.
exe
"
;
const
FILE_MAINTENANCE_SERVICE_INSTALLER_BIN
=
"
maintenanceservice_installer
.
exe
"
;
const
FILE_OLD_VERSION_MAR
=
"
old_version
.
mar
"
;
const
FILE_PARTIAL_EXE
=
"
partial
.
exe
"
;
const
FILE_UPDATER_BIN
=
"
updater
"
+
BIN_SUFFIX
;
const
FILE_WRONG_CHANNEL_MAR
=
"
wrong_product_channel
.
mar
"
;
const
PERFORMING_STAGED_UPDATE
=
"
Performing
a
staged
update
"
;
const
CALL_QUIT
=
"
calling
QuitProgressUI
"
;
const
REMOVE_OLD_DIST_DIR
=
"
removing
old
distribution
directory
"
;
const
MOVE_OLD_DIST_DIR
=
"
Moving
old
distribution
directory
to
new
location
"
;
const
ERR_UPDATE_IN_PROGRESS
=
"
Update
already
in
progress
!
Exiting
"
;
const
ERR_RENAME_FILE
=
"
rename_file
:
failed
to
rename
file
"
;
const
ERR_ENSURE_COPY
=
"
ensure_copy
:
failed
to
copy
the
file
"
;
const
ERR_UNABLE_OPEN_DEST
=
"
unable
to
open
destination
file
"
;
const
ERR_BACKUP_DISCARD
=
"
backup_discard
:
unable
to
remove
"
;
const
ERR_MOVE_DESTDIR_7
=
"
Moving
destDir
to
tmpDir
failed
err
:
7
"
;
const
ERR_BACKUP_CREATE_7
=
"
backup_create
failed
:
7
"
;
const
ERR_LOADSOURCEFILE_FAILED
=
"
LoadSourceFile
failed
"
;
const
LOG_SVC_SUCCESSFUL_LAUNCH
=
"
Process
was
started
.
.
.
waiting
on
result
.
"
;
const
MSG_SHOULD_EQUAL
=
"
should
equal
the
expected
value
"
;
const
MSG_SHOULD_EXIST
=
"
the
file
or
directory
should
exist
"
;
const
MSG_SHOULD_NOT_EXIST
=
"
the
file
or
directory
should
not
exist
"
;
const
MAC_MAX_TIME_DIFFERENCE
=
60000
;
const
MAX_TIMEOUT_RUNS
=
20000
;
const
HELPER_SLEEP_TIMEOUT
=
180
;
const
APP_TIMER_TIMEOUT
=
120000
;
const
PIPE_TO_NULL
=
IS_WIN
?
"
>
nul
"
:
"
>
/
dev
/
null
2
>
&
1
"
;
const
LOG_FUNCTION
=
do_print
;
var
gURLData
=
URL_HOST
+
"
/
"
;
var
gTestID
;
var
gTestserver
;
var
gRegisteredServiceCleanup
;
var
gCheckFunc
;
var
gResponseBody
;
var
gResponseStatusCode
=
200
;
var
gRequestURL
;
var
gUpdateCount
;
var
gUpdates
;
var
gStatusCode
;
var
gStatusText
;
var
gStatusResult
;
var
gProcess
;
var
gAppTimer
;
var
gHandle
;
var
gGREDirOrig
;
var
gGREBinDirOrig
;
var
gAppDirOrig
;
var
gServiceLaunchedCallbackLog
=
null
;
var
gServiceLaunchedCallbackArgs
=
null
;
var
gCallbackBinFile
=
"
callback_app
"
+
BIN_SUFFIX
;
var
gCallbackArgs
=
[
"
.
/
"
"
callback
.
log
"
"
Test
Arg
2
"
"
Test
Arg
3
"
]
;
var
gPostUpdateBinFile
=
"
postup_app
"
+
BIN_SUFFIX
;
var
gUseTestAppDir
=
true
;
var
gStagingRemovedUpdate
=
false
;
var
gTimeoutRuns
=
0
;
var
gShouldResetEnv
=
undefined
;
var
gAddedEnvXRENoWindowsCrashDialog
=
false
;
var
gEnvXPCOMDebugBreak
;
var
gEnvXPCOMMemLeakLog
;
var
gEnvDyldLibraryPath
;
var
gEnvLdLibraryPath
;
var
DEBUG_AUS_TEST
=
true
;
var
DEBUG_TEST_LOG
=
false
;
var
gDeleteLogFile
=
true
;
var
gRealDump
;
var
gTestLogText
=
"
"
;
var
gPassed
;
const
DATA_URI_SPEC
=
Services
.
io
.
newFileURI
(
do_get_file
(
"
.
.
/
data
"
false
)
)
.
spec
;
Services
.
scriptloader
.
loadSubScript
(
DATA_URI_SPEC
+
"
shared
.
js
"
this
)
;
var
gTestFiles
=
[
]
;
var
gTestDirs
=
[
]
;
var
gTestFilesCommon
=
[
{
description
:
"
Should
never
change
"
fileName
:
FILE_UPDATE_SETTINGS_INI
relPathDir
:
DIR_RESOURCES
originalContents
:
UPDATE_SETTINGS_CONTENTS
compareContents
:
UPDATE_SETTINGS_CONTENTS
originalFile
:
null
compareFile
:
null
originalPerms
:
0o767
comparePerms
:
0o767
}
{
description
:
"
Should
never
change
"
fileName
:
"
channel
-
prefs
.
js
"
relPathDir
:
DIR_RESOURCES
+
"
defaults
/
pref
/
"
originalContents
:
"
ShouldNotBeReplaced
\
n
"
compareContents
:
"
ShouldNotBeReplaced
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o767
comparePerms
:
0o767
}
]
;
var
gTestFilesCompleteSuccess
=
[
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
precomplete
"
relPathDir
:
DIR_RESOURCES
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_PARTIAL_PRECOMPLETE
compareFile
:
FILE_COMPLETE_PRECOMPLETE
originalPerms
:
0o666
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
searchpluginstext0
"
relPathDir
:
DIR_RESOURCES
+
"
searchplugins
/
"
originalContents
:
"
ToBeReplacedWithFromComplete
\
n
"
compareContents
:
"
FromComplete
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o775
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
searchpluginspng1
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
searchplugins
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
"
complete
.
png
"
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
searchpluginspng0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
searchplugins
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
partial
.
png
"
compareFile
:
"
complete
.
png
"
originalPerms
:
0o666
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
removed
-
files
"
relPathDir
:
DIR_RESOURCES
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_PARTIAL_REMOVEDFILES
compareFile
:
FILE_COMPLETE_REMOVEDFILES
originalPerms
:
0o666
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
"
+
"
exists
(
add
-
if
)
"
fileName
:
"
extensions1text0
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions1
/
"
originalContents
:
null
compareContents
:
"
FromComplete
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
"
+
"
exists
(
add
-
if
)
"
fileName
:
"
extensions1png1
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions1
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
partial
.
png
"
compareFile
:
"
complete
.
png
"
originalPerms
:
0o666
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
"
+
"
exists
(
add
-
if
)
"
fileName
:
"
extensions1png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions1
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
"
complete
.
png
"
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
"
+
"
exists
(
add
-
if
)
"
fileName
:
"
extensions0text0
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions0
/
"
originalContents
:
"
ToBeReplacedWithFromComplete
\
n
"
compareContents
:
"
FromComplete
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
"
+
"
exists
(
add
-
if
)
"
fileName
:
"
extensions0png1
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions0
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
"
complete
.
png
"
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
"
+
"
exists
(
add
-
if
)
"
fileName
:
"
extensions0png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions0
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
"
complete
.
png
"
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
exe0
.
exe
"
relPathDir
:
DIR_MACOS
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_HELPER_BIN
compareFile
:
FILE_COMPLETE_EXE
originalPerms
:
0o777
comparePerms
:
0o755
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
10text0
"
relPathDir
:
DIR_RESOURCES
+
"
1
/
10
/
"
originalContents
:
"
ToBeReplacedWithFromComplete
\
n
"
compareContents
:
"
FromComplete
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o767
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
0exe0
.
exe
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_HELPER_BIN
compareFile
:
FILE_COMPLETE_EXE
originalPerms
:
0o777
comparePerms
:
0o755
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
00text1
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
"
ToBeReplacedWithFromComplete
\
n
"
compareContents
:
"
FromComplete
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o677
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
00text0
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
"
ToBeReplacedWithFromComplete
\
n
"
compareContents
:
"
FromComplete
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o775
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
00png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
"
complete
.
png
"
originalPerms
:
0o776
comparePerms
:
0o644
}
{
description
:
"
Removed
by
precomplete
(
remove
)
"
fileName
:
"
20text0
"
relPathDir
:
DIR_RESOURCES
+
"
2
/
20
/
"
originalContents
:
"
ToBeDeleted
\
n
"
compareContents
:
null
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
null
}
{
description
:
"
Removed
by
precomplete
(
remove
)
"
fileName
:
"
20png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
2
/
20
/
"
originalContents
:
"
ToBeDeleted
\
n
"
compareContents
:
null
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
null
}
]
;
gTestFilesCompleteSuccess
=
gTestFilesCompleteSuccess
.
concat
(
gTestFilesCommon
)
;
var
gTestFilesPartialSuccess
=
[
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
precomplete
"
relPathDir
:
DIR_RESOURCES
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_COMPLETE_PRECOMPLETE
compareFile
:
FILE_PARTIAL_PRECOMPLETE
originalPerms
:
0o666
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
searchpluginstext0
"
relPathDir
:
DIR_RESOURCES
+
"
searchplugins
/
"
originalContents
:
"
ToBeReplacedWithFromPartial
\
n
"
compareContents
:
"
FromPartial
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o775
comparePerms
:
0o644
}
{
description
:
"
Patched
by
update
.
manifest
if
the
file
exists
"
+
"
(
patch
-
if
)
"
fileName
:
"
searchpluginspng1
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
searchplugins
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o666
comparePerms
:
0o666
}
{
description
:
"
Patched
by
update
.
manifest
if
the
file
exists
"
+
"
(
patch
-
if
)
"
fileName
:
"
searchpluginspng0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
searchplugins
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o666
comparePerms
:
0o666
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
"
+
"
exists
(
add
-
if
)
"
fileName
:
"
extensions1text0
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions1
/
"
originalContents
:
null
compareContents
:
"
FromPartial
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Patched
by
update
.
manifest
if
the
parent
directory
"
+
"
exists
(
patch
-
if
)
"
fileName
:
"
extensions1png1
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions1
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o666
comparePerms
:
0o666
}
{
description
:
"
Patched
by
update
.
manifest
if
the
parent
directory
"
+
"
exists
(
patch
-
if
)
"
fileName
:
"
extensions1png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions1
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o666
comparePerms
:
0o666
}
{
description
:
"
Added
by
update
.
manifest
if
the
parent
directory
"
+
"
exists
(
add
-
if
)
"
fileName
:
"
extensions0text0
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions0
/
"
originalContents
:
"
ToBeReplacedWithFromPartial
\
n
"
compareContents
:
"
FromPartial
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o644
comparePerms
:
0o644
}
{
description
:
"
Patched
by
update
.
manifest
if
the
parent
directory
"
+
"
exists
(
patch
-
if
)
"
fileName
:
"
extensions0png1
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions0
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o644
comparePerms
:
0o644
}
{
description
:
"
Patched
by
update
.
manifest
if
the
parent
directory
"
+
"
exists
(
patch
-
if
)
"
fileName
:
"
extensions0png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
distribution
/
extensions
/
extensions0
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o644
comparePerms
:
0o644
}
{
description
:
"
Patched
by
update
.
manifest
(
patch
)
"
fileName
:
"
exe0
.
exe
"
relPathDir
:
DIR_MACOS
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_COMPLETE_EXE
compareFile
:
FILE_PARTIAL_EXE
originalPerms
:
0o755
comparePerms
:
0o755
}
{
description
:
"
Patched
by
update
.
manifest
(
patch
)
"
fileName
:
"
0exe0
.
exe
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
FILE_COMPLETE_EXE
compareFile
:
FILE_PARTIAL_EXE
originalPerms
:
0o755
comparePerms
:
0o755
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
00text0
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
"
ToBeReplacedWithFromPartial
\
n
"
compareContents
:
"
FromPartial
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
0o644
comparePerms
:
0o644
}
{
description
:
"
Patched
by
update
.
manifest
(
patch
)
"
fileName
:
"
00png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
"
complete
.
png
"
compareFile
:
"
partial
.
png
"
originalPerms
:
0o666
comparePerms
:
0o666
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
20text0
"
relPathDir
:
DIR_RESOURCES
+
"
2
/
20
/
"
originalContents
:
null
compareContents
:
"
FromPartial
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
20png0
.
png
"
relPathDir
:
DIR_RESOURCES
+
"
2
/
20
/
"
originalContents
:
null
compareContents
:
null
originalFile
:
null
compareFile
:
"
partial
.
png
"
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Added
by
update
.
manifest
(
add
)
"
fileName
:
"
00text2
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
null
compareContents
:
"
FromPartial
\
n
"
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
0o644
}
{
description
:
"
Removed
by
update
.
manifest
(
remove
)
"
fileName
:
"
10text0
"
relPathDir
:
DIR_RESOURCES
+
"
1
/
10
/
"
originalContents
:
"
ToBeDeleted
\
n
"
compareContents
:
null
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
null
}
{
description
:
"
Removed
by
update
.
manifest
(
remove
)
"
fileName
:
"
00text1
"
relPathDir
:
DIR_RESOURCES
+
"
0
/
00
/
"
originalContents
:
"
ToBeDeleted
\
n
"
compareContents
:
null
originalFile
:
null
compareFile
:
null
originalPerms
:
null
comparePerms
:
null
}
]
;
gTestFilesPartialSuccess
=
gTestFilesPartialSuccess
.
concat
(
gTestFilesCommon
)
;
var
gTestDirsCommon
=
[
{
relPathDir
:
DIR_RESOURCES
+
"
3
/
"
dirRemoved
:
false
files
:
[
"
3text0
"
"
3text1
"
]
filesRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
4
/
"
dirRemoved
:
true
files
:
[
"
4text0
"
"
4text1
"
]
filesRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
5
/
"
dirRemoved
:
true
files
:
[
"
5test
.
exe
"
"
5text0
"
"
5text1
"
]
filesRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
6
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
7
/
"
dirRemoved
:
true
files
:
[
"
7text0
"
"
7text1
"
]
subDirs
:
[
"
70
/
"
"
71
/
"
]
subDirFiles
:
[
"
7xtest
.
exe
"
"
7xtext0
"
"
7xtext1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
"
dirRemoved
:
false
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
80
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
81
/
"
dirRemoved
:
false
files
:
[
"
81text0
"
"
81text1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
82
/
"
dirRemoved
:
false
subDirs
:
[
"
820
/
"
"
821
/
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
83
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
84
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
85
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
86
/
"
dirRemoved
:
true
files
:
[
"
86text0
"
"
86text1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
87
/
"
dirRemoved
:
true
subDirs
:
[
"
870
/
"
"
871
/
"
]
subDirFiles
:
[
"
87xtext0
"
"
87xtext1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
88
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
8
/
89
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
90
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
91
/
"
dirRemoved
:
false
files
:
[
"
91text0
"
"
91text1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
92
/
"
dirRemoved
:
false
subDirs
:
[
"
920
/
"
"
921
/
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
93
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
94
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
95
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
96
/
"
dirRemoved
:
true
files
:
[
"
96text0
"
"
96text1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
97
/
"
dirRemoved
:
true
subDirs
:
[
"
970
/
"
"
971
/
"
]
subDirFiles
:
[
"
97xtext0
"
"
97xtext1
"
]
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
98
/
"
dirRemoved
:
true
}
{
relPathDir
:
DIR_RESOURCES
+
"
9
/
99
/
"
dirRemoved
:
true
}
]
;
var
gTestDirsCompleteSuccess
=
[
{
description
:
"
Removed
by
precomplete
(
rmdir
)
"
relPathDir
:
DIR_RESOURCES
+
"
2
/
20
/
"
dirRemoved
:
true
}
{
description
:
"
Removed
by
precomplete
(
rmdir
)
"
relPathDir
:
DIR_RESOURCES
+
"
2
/
"
dirRemoved
:
true
}
]
;
gTestDirsCompleteSuccess
=
gTestDirsCommon
.
concat
(
gTestDirsCompleteSuccess
)
;
var
gTestDirsPartialSuccess
=
[
{
description
:
"
Removed
by
update
.
manifest
(
rmdir
)
"
relPathDir
:
DIR_RESOURCES
+
"
1
/
10
/
"
dirRemoved
:
true
}
{
description
:
"
Removed
by
update
.
manifest
(
rmdir
)
"
relPathDir
:
DIR_RESOURCES
+
"
1
/
"
dirRemoved
:
true
}
]
;
gTestDirsPartialSuccess
=
gTestDirsCommon
.
concat
(
gTestDirsPartialSuccess
)
;
if
(
MOZ_APP_NAME
=
=
"
xulrunner
"
)
{
try
{
gDefaultPrefBranch
.
getCharPref
(
PREF_APP_UPDATE_CHANNEL
)
;
}
catch
(
e
)
{
setUpdateChannel
(
"
test_channel
"
)
;
}
}
function
setupTestCommon
(
)
{
debugDump
(
"
start
-
general
test
setup
"
)
;
Assert
.
strictEqual
(
gTestID
undefined
"
gTestID
should
be
'
undefined
'
(
setupTestCommon
should
"
+
"
only
be
called
once
)
"
)
;
let
caller
=
Components
.
stack
.
caller
;
gTestID
=
caller
.
filename
.
toString
(
)
.
split
(
"
/
"
)
.
pop
(
)
.
split
(
"
.
"
)
[
0
]
;
const
XUL_RUNNER_INCOMPATIBLE
=
[
"
marAppApplyUpdateAppBinInUseStageSuccess_win
"
"
marAppApplyUpdateStageSuccess
"
"
marAppApplyUpdateSuccess
"
"
marAppApplyUpdateAppBinInUseStageSuccessSvc_win
"
"
marAppApplyUpdateStageSuccessSvc
"
"
marAppApplyUpdateSuccessSvc
"
]
;
if
(
MOZ_APP_NAME
=
=
"
xulrunner
"
&
&
XUL_RUNNER_INCOMPATIBLE
.
indexOf
(
gTestID
)
!
=
-
1
)
{
logTestInfo
(
"
Unable
to
run
this
test
on
xulrunner
"
)
;
return
false
;
}
if
(
IS_SERVICE_TEST
&
&
!
shouldRunServiceTest
(
)
)
{
return
false
;
}
do_test_pending
(
)
;
setDefaultPrefs
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_SILENT
true
)
;
gGREDirOrig
=
getGREDir
(
)
;
gGREBinDirOrig
=
getGREBinDir
(
)
;
gAppDirOrig
=
getAppBaseDir
(
)
;
let
applyDir
=
getApplyDirFile
(
null
true
)
.
parent
;
if
(
applyDir
.
exists
(
)
)
{
debugDump
(
"
attempting
to
remove
directory
.
Path
:
"
+
applyDir
.
path
)
;
try
{
removeDirRecursive
(
applyDir
)
;
}
catch
(
e
)
{
logTestInfo
(
"
non
-
fatal
error
removing
directory
.
Path
:
"
+
applyDir
.
path
+
"
Exception
:
"
+
e
)
;
gTestID
+
=
"
_new
"
;
logTestInfo
(
"
using
a
new
directory
for
the
test
by
changing
gTestID
"
+
"
since
there
is
an
existing
test
directory
that
can
'
t
be
"
+
"
removed
gTestID
:
"
+
gTestID
)
;
}
}
if
(
DEBUG_TEST_LOG
)
{
let
logFile
=
do_get_file
(
gTestID
+
"
.
log
"
true
)
;
if
(
logFile
.
exists
(
)
)
{
gPassed
=
false
;
logTestInfo
(
"
start
-
dumping
previous
test
run
log
"
)
;
logTestInfo
(
"
\
n
"
+
readFile
(
logFile
)
+
"
\
n
"
)
;
logTestInfo
(
"
finish
-
dumping
previous
test
run
log
"
)
;
if
(
gDeleteLogFile
)
{
logFile
.
remove
(
false
)
;
}
do_throw
(
"
The
parallel
run
of
this
test
failed
.
Failing
non
-
parallel
"
+
"
test
so
the
log
from
the
parallel
run
can
be
displayed
in
"
+
"
non
-
parallel
log
.
"
)
;
}
else
{
gRealDump
=
dump
;
dump
=
dumpOverride
;
}
}
if
(
IS_WIN
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_SERVICE_ENABLED
IS_SERVICE_TEST
?
true
:
false
)
;
}
adjustGeneralPaths
(
)
;
let
grePrefsFile
=
getGREDir
(
)
;
if
(
!
grePrefsFile
.
exists
(
)
)
{
grePrefsFile
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
PERMS_DIRECTORY
)
;
}
grePrefsFile
.
append
(
"
greprefs
.
js
"
)
;
if
(
!
grePrefsFile
.
exists
(
)
)
{
grePrefsFile
.
create
(
Ci
.
nsILocalFile
.
NORMAL_FILE_TYPE
PERMS_FILE
)
;
}
if
(
IS_WIN
|
|
IS_MACOSX
)
{
let
updatesDir
=
getMockUpdRootD
(
)
;
if
(
updatesDir
.
exists
(
)
)
{
debugDump
(
"
attempting
to
remove
directory
.
Path
:
"
+
updatesDir
.
path
)
;
try
{
removeDirRecursive
(
updatesDir
)
;
}
catch
(
e
)
{
logTestInfo
(
"
non
-
fatal
error
removing
directory
.
Path
:
"
+
updatesDir
.
path
+
"
Exception
:
"
+
e
)
;
}
}
}
debugDump
(
"
finish
-
general
test
setup
"
)
;
return
true
;
}
function
cleanupTestCommon
(
)
{
debugDump
(
"
start
-
general
test
cleanup
"
)
;
reloadUpdateManagerData
(
)
;
if
(
gChannel
)
{
gPrefRoot
.
removeObserver
(
PREF_APP_UPDATE_CHANNEL
observer
)
;
}
gAUS
.
observe
(
null
"
xpcom
-
shutdown
"
"
"
)
;
gTestserver
=
null
;
if
(
IS_UNIX
)
{
getLaunchScript
(
)
;
}
if
(
IS_WIN
&
&
MOZ_APP_BASENAME
)
{
let
appDir
=
getApplyDirFile
(
null
true
)
;
let
vendor
=
MOZ_APP_VENDOR
?
MOZ_APP_VENDOR
:
"
Mozilla
"
;
const
REG_PATH
=
"
SOFTWARE
\
\
"
+
vendor
+
"
\
\
"
+
MOZ_APP_BASENAME
+
"
\
\
TaskBarIDs
"
;
let
key
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
try
{
key
.
open
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_LOCAL_MACHINE
REG_PATH
Ci
.
nsIWindowsRegKey
.
ACCESS_ALL
)
;
if
(
key
.
hasValue
(
appDir
.
path
)
)
{
key
.
removeValue
(
appDir
.
path
)
;
}
}
catch
(
e
)
{
}
try
{
key
.
open
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
REG_PATH
Ci
.
nsIWindowsRegKey
.
ACCESS_ALL
)
;
if
(
key
.
hasValue
(
appDir
.
path
)
)
{
key
.
removeValue
(
appDir
.
path
)
;
}
}
catch
(
e
)
{
}
}
if
(
IS_WIN
|
|
IS_MACOSX
|
|
IS_TOOLKIT_GONK
)
{
let
updatesDir
=
getMockUpdRootD
(
)
;
if
(
updatesDir
.
exists
(
)
)
{
debugDump
(
"
attempting
to
remove
directory
.
Path
:
"
+
updatesDir
.
path
)
;
try
{
removeDirRecursive
(
updatesDir
)
;
}
catch
(
e
)
{
logTestInfo
(
"
non
-
fatal
error
removing
directory
.
Path
:
"
+
updatesDir
.
path
+
"
Exception
:
"
+
e
)
;
}
if
(
IS_MACOSX
)
{
let
updatesRootDir
=
gUpdatesRootDir
.
clone
(
)
;
while
(
updatesRootDir
.
path
!
=
updatesDir
.
path
)
{
if
(
updatesDir
.
exists
(
)
)
{
debugDump
(
"
attempting
to
remove
directory
.
Path
:
"
+
updatesDir
.
path
)
;
try
{
updatesDir
.
remove
(
false
)
;
}
catch
(
e
)
{
logTestInfo
(
"
non
-
fatal
error
removing
directory
.
Path
:
"
+
updatesDir
.
path
+
"
Exception
:
"
+
e
)
;
if
(
e
=
=
Cr
.
NS_ERROR_FILE_DIR_NOT_EMPTY
)
{
break
;
}
}
}
updatesDir
=
updatesDir
.
parent
;
}
}
}
}
let
applyDir
=
getApplyDirFile
(
null
true
)
.
parent
;
if
(
applyDir
.
exists
(
)
)
{
debugDump
(
"
attempting
to
remove
directory
.
Path
:
"
+
applyDir
.
path
)
;
try
{
removeDirRecursive
(
applyDir
)
;
}
catch
(
e
)
{
logTestInfo
(
"
non
-
fatal
error
removing
directory
.
Path
:
"
+
applyDir
.
path
+
"
Exception
:
"
+
e
)
;
}
}
resetEnvironment
(
)
;
debugDump
(
"
finish
-
general
test
cleanup
"
)
;
if
(
gRealDump
)
{
dump
=
gRealDump
;
gRealDump
=
null
;
}
if
(
DEBUG_TEST_LOG
&
&
!
gPassed
)
{
let
fos
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
let
logFile
=
do_get_file
(
gTestID
+
"
.
log
"
true
)
;
if
(
!
logFile
.
exists
(
)
)
{
logFile
.
create
(
Ci
.
nsILocalFile
.
NORMAL_FILE_TYPE
PERMS_FILE
)
;
}
fos
.
init
(
logFile
MODE_WRONLY
|
MODE_CREATE
|
MODE_APPEND
PERMS_FILE
0
)
;
fos
.
write
(
gTestLogText
gTestLogText
.
length
)
;
fos
.
close
(
)
;
}
if
(
DEBUG_TEST_LOG
)
{
gTestLogText
=
null
;
}
else
{
let
logFile
=
do_get_file
(
gTestID
+
"
.
log
"
true
)
;
if
(
logFile
.
exists
(
)
)
{
logFile
.
remove
(
false
)
;
}
}
}
function
dumpOverride
(
aText
)
{
gTestLogText
+
=
aText
;
gRealDump
(
aText
)
;
}
function
doTestFinish
(
)
{
if
(
gPassed
=
=
=
undefined
)
{
gPassed
=
true
;
}
if
(
DEBUG_AUS_TEST
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_LOG
false
)
;
gAUS
.
observe
(
null
"
nsPref
:
changed
"
PREF_APP_UPDATE_LOG
)
;
}
do_execute_soon
(
do_test_finished
)
;
}
function
setDefaultPrefs
(
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_ENABLED
true
)
;
if
(
DEBUG_AUS_TEST
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_LOG
true
)
;
}
else
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_LOG
false
)
;
}
Services
.
prefs
.
setBoolPref
(
PREF_TOOLKIT_TELEMETRY_ENABLED
false
)
;
}
function
setTestFilesAndDirsForFailure
(
)
{
gTestFiles
.
forEach
(
function
STFADFF_Files
(
aTestFile
)
{
aTestFile
.
compareContents
=
aTestFile
.
originalContents
;
aTestFile
.
compareFile
=
aTestFile
.
originalFile
;
aTestFile
.
comparePerms
=
aTestFile
.
originalPerms
;
}
)
;
gTestDirs
.
forEach
(
function
STFADFF_Dirs
(
aTestDir
)
{
aTestDir
.
dirRemoved
=
false
;
if
(
aTestDir
.
filesRemoved
)
{
aTestDir
.
filesRemoved
=
false
;
}
}
)
;
}
function
preventDistributionFiles
(
)
{
gTestFiles
=
gTestFiles
.
filter
(
function
(
aTestFile
)
{
return
aTestFile
.
relPathDir
.
indexOf
(
"
distribution
/
"
)
=
=
-
1
;
}
)
;
gTestDirs
=
gTestDirs
.
filter
(
function
(
aTestDir
)
{
return
aTestDir
.
relPathDir
.
indexOf
(
"
distribution
/
"
)
=
=
-
1
;
}
)
;
}
function
setAppBundleModTime
(
)
{
if
(
!
IS_MACOSX
)
{
return
;
}
let
now
=
Date
.
now
(
)
;
let
yesterday
=
now
-
(
1000
*
60
*
60
*
24
)
;
let
applyToDir
=
getApplyDirFile
(
)
;
applyToDir
.
lastModifiedTime
=
yesterday
;
}
function
checkAppBundleModTime
(
)
{
if
(
!
IS_MACOSX
)
{
return
;
}
let
now
=
Date
.
now
(
)
;
let
applyToDir
=
getApplyDirFile
(
)
;
let
timeDiff
=
Math
.
abs
(
applyToDir
.
lastModifiedTime
-
now
)
;
Assert
.
ok
(
timeDiff
<
MAC_MAX_TIME_DIFFERENCE
"
the
last
modified
time
on
the
apply
to
directory
should
"
+
"
change
after
a
successful
update
"
)
;
}
function
checkPostUpdateRunningFile
(
aShouldExist
)
{
if
(
!
IS_WIN
&
&
!
IS_MACOSX
)
{
return
;
}
let
postUpdateRunningFile
=
getPostUpdateFile
(
"
.
running
"
)
;
if
(
aShouldExist
)
{
Assert
.
ok
(
postUpdateRunningFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
postUpdateRunningFile
.
path
)
)
;
}
else
{
Assert
.
ok
(
!
postUpdateRunningFile
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
postUpdateRunningFile
.
path
)
)
;
}
}
function
standardInit
(
)
{
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
APP_INFO_NAME
"
1
.
0
"
"
2
.
0
"
)
;
initUpdateServiceStub
(
)
;
}
function
pathHandler
(
aMetadata
aResponse
)
{
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
xml
"
false
)
;
aResponse
.
setStatusLine
(
aMetadata
.
httpVersion
gResponseStatusCode
"
OK
"
)
;
aResponse
.
bodyOutputStream
.
write
(
gResponseBody
gResponseBody
.
length
)
;
}
function
getAppVersion
(
)
{
let
iniFile
=
gGREDirOrig
.
clone
(
)
;
iniFile
.
append
(
FILE_APPLICATION_INI
)
;
if
(
!
iniFile
.
exists
(
)
)
{
iniFile
=
gGREBinDirOrig
.
clone
(
)
;
iniFile
.
append
(
FILE_APPLICATION_INI
)
;
}
Assert
.
ok
(
iniFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
iniFile
.
path
)
)
;
let
iniParser
=
Cc
[
"
mozilla
.
org
/
xpcom
/
ini
-
parser
-
factory
;
1
"
]
.
getService
(
Ci
.
nsIINIParserFactory
)
.
createINIParser
(
iniFile
)
;
return
iniParser
.
getString
(
"
App
"
"
Version
"
)
;
}
function
getApplyDirPath
(
)
{
return
gTestID
+
"
/
dir
.
app
/
"
;
}
function
getApplyDirFile
(
aRelPath
aAllowNonexistent
)
{
let
relpath
=
getApplyDirPath
(
)
+
(
aRelPath
?
aRelPath
:
"
"
)
;
return
do_get_file
(
relpath
aAllowNonexistent
)
;
}
function
getStageDirFile
(
aRelPath
aAllowNonexistent
)
{
if
(
IS_MACOSX
)
{
let
file
=
getMockUpdRootD
(
)
;
file
.
append
(
DIR_UPDATES
)
;
file
.
append
(
DIR_PATCH
)
;
file
.
append
(
DIR_UPDATED
)
;
if
(
aRelPath
)
{
let
pathParts
=
aRelPath
.
split
(
"
/
"
)
;
for
(
let
i
=
0
;
i
<
pathParts
.
length
;
i
+
+
)
{
if
(
pathParts
[
i
]
)
{
file
.
append
(
pathParts
[
i
]
)
;
}
}
}
if
(
!
aAllowNonexistent
)
{
Assert
.
ok
(
file
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
file
.
path
)
)
;
}
return
file
;
}
let
relpath
=
getApplyDirPath
(
)
+
DIR_UPDATED
+
"
/
"
+
(
aRelPath
?
aRelPath
:
"
"
)
;
return
do_get_file
(
relpath
aAllowNonexistent
)
;
}
function
getTestDirPath
(
)
{
return
"
.
.
/
data
/
"
;
}
function
getTestDirFile
(
aRelPath
aAllowNonExists
)
{
let
relpath
=
getTestDirPath
(
)
+
(
aRelPath
?
aRelPath
:
"
"
)
;
return
do_get_file
(
relpath
!
!
aAllowNonExists
)
;
}
function
getMaintSvcDir
(
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
const
CSIDL_PROGRAM_FILES
=
0x26
;
const
CSIDL_PROGRAM_FILESX86
=
0x2A
;
let
maintSvcDir
=
getSpecialFolderDir
(
CSIDL_PROGRAM_FILESX86
)
;
if
(
maintSvcDir
)
{
maintSvcDir
.
append
(
"
Mozilla
Maintenance
Service
"
)
;
debugDump
(
"
using
CSIDL_PROGRAM_FILESX86
-
maintenance
service
install
"
+
"
directory
path
:
"
+
maintSvcDir
.
path
)
;
}
if
(
!
maintSvcDir
|
|
!
maintSvcDir
.
exists
(
)
)
{
maintSvcDir
=
getSpecialFolderDir
(
CSIDL_PROGRAM_FILES
)
;
if
(
maintSvcDir
)
{
maintSvcDir
.
append
(
"
Mozilla
Maintenance
Service
"
)
;
debugDump
(
"
using
CSIDL_PROGRAM_FILES
-
maintenance
service
install
"
+
"
directory
path
:
"
+
maintSvcDir
.
path
)
;
}
}
if
(
!
maintSvcDir
)
{
do_throw
(
"
Unable
to
find
the
maintenance
service
install
directory
"
)
;
}
return
maintSvcDir
;
}
function
getSpecialFolderDir
(
aCSIDL
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
let
lib
=
ctypes
.
open
(
"
shell32
"
)
;
let
SHGetSpecialFolderPath
=
lib
.
declare
(
"
SHGetSpecialFolderPathW
"
ctypes
.
winapi_abi
ctypes
.
bool
ctypes
.
int32_t
ctypes
.
char16_t
.
ptr
ctypes
.
int32_t
ctypes
.
bool
)
;
let
aryPath
=
ctypes
.
char16_t
.
array
(
)
(
260
)
;
let
rv
=
SHGetSpecialFolderPath
(
0
aryPath
aCSIDL
false
)
;
lib
.
close
(
)
;
let
path
=
aryPath
.
readString
(
)
;
if
(
!
path
)
{
return
null
;
}
debugDump
(
"
SHGetSpecialFolderPath
returned
path
:
"
+
path
)
;
let
dir
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsILocalFile
)
;
dir
.
initWithPath
(
path
)
;
return
dir
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
gInstallDirPathHash
"
function
test_gInstallDirPathHash
(
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
if
(
!
MOZ_APP_BASENAME
)
{
return
null
;
}
let
vendor
=
MOZ_APP_VENDOR
?
MOZ_APP_VENDOR
:
"
Mozilla
"
;
let
appDir
=
getApplyDirFile
(
null
true
)
;
const
REG_PATH
=
"
SOFTWARE
\
\
"
+
vendor
+
"
\
\
"
+
MOZ_APP_BASENAME
+
"
\
\
TaskBarIDs
"
;
let
regKey
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
try
{
regKey
.
open
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_LOCAL_MACHINE
REG_PATH
Ci
.
nsIWindowsRegKey
.
ACCESS_ALL
)
;
regKey
.
writeStringValue
(
appDir
.
path
gTestID
)
;
return
gTestID
;
}
catch
(
e
)
{
}
try
{
regKey
.
create
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
REG_PATH
Ci
.
nsIWindowsRegKey
.
ACCESS_ALL
)
;
regKey
.
writeStringValue
(
appDir
.
path
gTestID
)
;
return
gTestID
;
}
catch
(
e
)
{
logTestInfo
(
"
failed
to
create
registry
key
.
Registry
Path
:
"
+
REG_PATH
+
"
Key
Name
:
"
+
appDir
.
path
+
"
Key
Value
:
"
+
gTestID
+
"
Exception
"
+
e
)
;
}
return
null
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gLocalAppDataDir
"
function
test_gLocalAppDataDir
(
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
const
CSIDL_LOCAL_APPDATA
=
0x1c
;
return
getSpecialFolderDir
(
CSIDL_LOCAL_APPDATA
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gProgFilesDir
"
function
test_gProgFilesDir
(
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
const
CSIDL_PROGRAM_FILES
=
0x26
;
return
getSpecialFolderDir
(
CSIDL_PROGRAM_FILES
)
;
}
)
;
function
getMockUpdRootD
(
)
{
if
(
IS_WIN
)
{
return
getMockUpdRootDWin
(
)
;
}
if
(
IS_MACOSX
)
{
return
getMockUpdRootDMac
(
)
;
}
if
(
IS_TOOLKIT_GONK
)
{
return
do_get_file
(
gTestID
+
"
/
"
true
)
;
}
return
getApplyDirFile
(
DIR_MACOS
true
)
;
}
function
getMockUpdRootDWin
(
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
let
localAppDataDir
=
gLocalAppDataDir
.
clone
(
)
;
let
progFilesDir
=
gProgFilesDir
.
clone
(
)
;
let
appDir
=
Services
.
dirsvc
.
get
(
XRE_EXECUTABLE_FILE
Ci
.
nsIFile
)
.
parent
;
let
appDirPath
=
appDir
.
path
;
let
relPathUpdates
=
"
"
;
if
(
gInstallDirPathHash
&
&
(
MOZ_APP_VENDOR
|
|
MOZ_APP_BASENAME
)
)
{
relPathUpdates
+
=
(
MOZ_APP_VENDOR
?
MOZ_APP_VENDOR
:
MOZ_APP_BASENAME
)
+
"
\
\
"
+
DIR_UPDATES
+
"
\
\
"
+
gInstallDirPathHash
;
}
if
(
!
relPathUpdates
&
&
progFilesDir
)
{
if
(
appDirPath
.
length
>
progFilesDir
.
path
.
length
)
{
if
(
appDirPath
.
substr
(
0
progFilesDir
.
path
.
length
)
=
=
progFilesDir
.
path
)
{
if
(
MOZ_APP_VENDOR
&
&
MOZ_APP_BASENAME
)
{
relPathUpdates
+
=
MOZ_APP_VENDOR
+
"
\
\
"
+
MOZ_APP_BASENAME
;
}
else
{
relPathUpdates
+
=
MOZ_APP_BASENAME
;
}
relPathUpdates
+
=
appDirPath
.
substr
(
progFilesDir
.
path
.
length
)
;
}
}
}
if
(
!
relPathUpdates
)
{
if
(
MOZ_APP_VENDOR
&
&
MOZ_APP_BASENAME
)
{
relPathUpdates
+
=
MOZ_APP_VENDOR
+
"
\
\
"
+
MOZ_APP_BASENAME
;
}
else
{
relPathUpdates
+
=
MOZ_APP_BASENAME
;
}
relPathUpdates
+
=
"
\
\
"
+
MOZ_APP_NAME
;
}
let
updatesDir
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsILocalFile
)
;
updatesDir
.
initWithPath
(
localAppDataDir
.
path
+
"
\
\
"
+
relPathUpdates
)
;
debugDump
(
"
returning
UpdRootD
Path
:
"
+
updatesDir
.
path
)
;
return
updatesDir
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
gUpdatesRootDir
"
function
test_gUpdatesRootDir
(
)
{
if
(
!
IS_MACOSX
)
{
do_throw
(
"
Mac
OS
X
only
function
called
by
a
different
platform
!
"
)
;
}
let
dir
=
Services
.
dirsvc
.
get
(
"
ULibDir
"
Ci
.
nsILocalFile
)
;
dir
.
append
(
"
Caches
"
)
;
if
(
MOZ_APP_VENDOR
|
|
MOZ_APP_BASENAME
)
{
dir
.
append
(
MOZ_APP_VENDOR
?
MOZ_APP_VENDOR
:
MOZ_APP_BASENAME
)
;
}
else
{
dir
.
append
(
"
Mozilla
"
)
;
}
dir
.
append
(
DIR_UPDATES
)
;
return
dir
;
}
)
;
function
getMockUpdRootDMac
(
)
{
if
(
!
IS_MACOSX
)
{
do_throw
(
"
Mac
OS
X
only
function
called
by
a
different
platform
!
"
)
;
}
let
appDir
=
Services
.
dirsvc
.
get
(
XRE_EXECUTABLE_FILE
Ci
.
nsIFile
)
.
parent
.
parent
.
parent
;
let
appDirPath
=
appDir
.
path
;
appDirPath
=
appDirPath
.
substr
(
0
appDirPath
.
length
-
4
)
;
let
pathUpdates
=
gUpdatesRootDir
.
path
+
appDirPath
;
let
updatesDir
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsILocalFile
)
;
updatesDir
.
initWithPath
(
pathUpdates
)
;
debugDump
(
"
returning
UpdRootD
Path
:
"
+
updatesDir
.
path
)
;
return
updatesDir
;
}
function
createUpdateInProgressLockFile
(
aDir
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
let
file
=
aDir
.
clone
(
)
;
file
.
append
(
FILE_UPDATE_IN_PROGRESS_LOCK
)
;
file
.
create
(
file
.
NORMAL_FILE_TYPE
0o444
)
;
file
.
QueryInterface
(
Ci
.
nsILocalFileWin
)
;
file
.
fileAttributesWin
|
=
file
.
WFA_READONLY
;
file
.
fileAttributesWin
&
=
~
file
.
WFA_READWRITE
;
Assert
.
ok
(
file
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
file
.
path
)
)
;
Assert
.
ok
(
!
file
.
isWritable
(
)
"
the
lock
file
should
not
be
writeable
"
)
;
}
function
removeUpdateInProgressLockFile
(
aDir
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
let
file
=
aDir
.
clone
(
)
;
file
.
append
(
FILE_UPDATE_IN_PROGRESS_LOCK
)
;
file
.
QueryInterface
(
Ci
.
nsILocalFileWin
)
;
file
.
fileAttributesWin
|
=
file
.
WFA_READWRITE
;
file
.
fileAttributesWin
&
=
~
file
.
WFA_READONLY
;
file
.
remove
(
false
)
;
Assert
.
ok
(
!
file
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
file
.
path
)
)
;
}
function
getTestUpdater
(
)
{
let
updater
=
getTestDirFile
(
"
updater
.
app
"
true
)
;
if
(
!
updater
.
exists
(
)
)
{
updater
=
getTestDirFile
(
FILE_UPDATER_BIN
)
;
if
(
!
updater
.
exists
(
)
)
{
do_throw
(
"
Unable
to
find
the
updater
binary
!
"
)
;
}
}
Assert
.
ok
(
updater
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
updater
.
path
)
)
;
return
updater
;
}
function
copyTestUpdaterToBinDir
(
)
{
let
testUpdater
=
getTestUpdater
(
)
;
let
updater
=
getGREBinDir
(
)
;
updater
.
append
(
testUpdater
.
leafName
)
;
if
(
!
updater
.
exists
(
)
)
{
testUpdater
.
copyToFollowingLinks
(
updater
.
parent
updater
.
leafName
)
;
}
return
updater
;
}
function
copyTestUpdaterForRunUsingUpdater
(
)
{
if
(
IS_WIN
)
{
return
copyTestUpdaterToBinDir
(
)
;
}
let
testUpdater
=
getTestUpdater
(
)
;
let
updater
=
getUpdatesPatchDir
(
)
;
updater
.
append
(
testUpdater
.
leafName
)
;
if
(
!
updater
.
exists
(
)
)
{
testUpdater
.
copyToFollowingLinks
(
updater
.
parent
updater
.
leafName
)
;
}
if
(
IS_MACOSX
)
{
updater
.
append
(
"
Contents
"
)
;
updater
.
append
(
"
MacOS
"
)
;
updater
.
append
(
"
org
.
mozilla
.
updater
"
)
;
}
return
updater
;
}
function
logUpdateLog
(
aLogLeafName
)
{
let
updateLog
=
getUpdateLog
(
aLogLeafName
)
;
if
(
updateLog
.
exists
(
)
)
{
let
updateLogContents
=
readFileBytes
(
updateLog
)
.
replace
(
/
\
r
\
n
/
g
"
\
n
"
)
;
updateLogContents
=
replaceLogPaths
(
updateLogContents
)
;
let
aryLogContents
=
updateLogContents
.
split
(
"
\
n
"
)
;
logTestInfo
(
"
contents
of
"
+
updateLog
.
path
+
"
:
"
)
;
aryLogContents
.
forEach
(
function
RU_LC_FE
(
aLine
)
{
logTestInfo
(
aLine
)
;
}
)
;
}
else
{
logTestInfo
(
"
update
log
doesn
'
t
exist
path
:
"
+
updateLog
.
path
)
;
}
}
function
runUpdate
(
aExpectedStatus
aSwitchApp
aExpectedExitValue
aCheckSvcLog
)
{
if
(
IS_SERVICE_TEST
)
{
let
expectedStatus
=
aExpectedStatus
;
if
(
aExpectedStatus
=
=
STATE_PENDING
)
{
expectedStatus
=
STATE_PENDING_SVC
;
}
else
if
(
aExpectedStatus
=
=
STATE_APPLIED
)
{
expectedStatus
=
STATE_APPLIED_SVC
;
}
runUpdateUsingService
(
expectedStatus
aSwitchApp
aCheckSvcLog
)
;
}
else
{
runUpdateUsingUpdater
(
aExpectedStatus
aSwitchApp
aExpectedExitValue
)
;
}
}
function
runUpdateUsingUpdater
(
aExpectedStatus
aSwitchApp
aExpectedExitValue
)
{
let
updateBin
=
copyTestUpdaterForRunUsingUpdater
(
)
;
Assert
.
ok
(
updateBin
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
updateBin
.
path
)
)
;
let
updatesDir
=
getUpdatesPatchDir
(
)
;
let
updatesDirPath
=
updatesDir
.
path
;
let
applyToDir
=
getApplyDirFile
(
null
true
)
;
let
applyToDirPath
=
applyToDir
.
path
;
let
stageDir
=
getStageDirFile
(
null
true
)
;
let
stageDirPath
=
stageDir
.
path
;
if
(
IS_WIN
)
{
updatesDirPath
=
updatesDirPath
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
applyToDirPath
=
applyToDirPath
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
stageDirPath
=
stageDirPath
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
let
callbackApp
=
getApplyDirFile
(
DIR_RESOURCES
+
gCallbackBinFile
)
;
callbackApp
.
permissions
=
PERMS_DIRECTORY
;
setAppBundleModTime
(
)
;
let
args
=
[
updatesDirPath
applyToDirPath
]
;
if
(
aSwitchApp
)
{
args
[
2
]
=
stageDirPath
;
args
[
3
]
=
"
0
/
replace
"
;
}
else
{
args
[
2
]
=
applyToDirPath
;
args
[
3
]
=
"
0
"
;
}
args
=
args
.
concat
(
[
callbackApp
.
parent
.
path
callbackApp
.
path
]
)
;
args
=
args
.
concat
(
gCallbackArgs
)
;
debugDump
(
"
running
the
updater
:
"
+
updateBin
.
path
+
"
"
+
args
.
join
(
"
"
)
)
;
let
asan_options
=
null
;
if
(
gEnv
.
exists
(
"
ASAN_OPTIONS
"
)
)
{
asan_options
=
gEnv
.
get
(
"
ASAN_OPTIONS
"
)
;
gEnv
.
set
(
"
ASAN_OPTIONS
"
asan_options
+
"
:
detect_leaks
=
0
"
)
}
else
{
gEnv
.
set
(
"
ASAN_OPTIONS
"
"
detect_leaks
=
0
"
)
}
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
process
.
init
(
updateBin
)
;
process
.
run
(
true
args
args
.
length
)
;
gEnv
.
set
(
"
ASAN_OPTIONS
"
asan_options
?
asan_options
:
"
"
)
;
let
status
=
readStatusFile
(
)
;
if
(
process
.
exitValue
!
=
aExpectedExitValue
|
|
status
!
=
aExpectedStatus
)
{
if
(
process
.
exitValue
!
=
aExpectedExitValue
)
{
logTestInfo
(
"
updater
exited
with
unexpected
value
!
Got
:
"
+
process
.
exitValue
+
"
Expected
:
"
+
aExpectedExitValue
)
;
}
if
(
status
!
=
aExpectedStatus
)
{
logTestInfo
(
"
update
status
is
not
the
expected
status
!
Got
:
"
+
status
+
"
Expected
:
"
+
aExpectedStatus
)
;
}
logUpdateLog
(
FILE_LAST_UPDATE_LOG
)
;
}
Assert
.
equal
(
process
.
exitValue
aExpectedExitValue
"
the
process
exit
value
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
status
aExpectedStatus
"
the
update
status
"
+
MSG_SHOULD_EQUAL
)
;
do_execute_soon
(
runUpdateFinished
)
;
}
function
runTestHelperSync
(
aArgs
)
{
let
helperBin
=
getTestDirFile
(
FILE_HELPER_BIN
)
;
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
process
.
init
(
helperBin
)
;
debugDump
(
"
Running
"
+
helperBin
.
path
+
"
"
+
aArgs
.
join
(
"
"
)
)
;
process
.
run
(
true
aArgs
aArgs
.
length
)
;
return
process
.
exitValue
;
}
function
createSymlink
(
)
{
let
args
=
[
"
setup
-
symlink
"
"
moz
-
foo
"
"
moz
-
bar
"
"
target
"
getApplyDirFile
(
)
.
path
+
"
/
"
+
DIR_RESOURCES
+
"
link
"
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
equal
(
exitValue
0
"
the
helper
process
exit
value
should
be
0
"
)
;
getApplyDirFile
(
DIR_RESOURCES
+
"
link
"
false
)
.
permissions
=
0o666
;
args
=
[
"
setup
-
symlink
"
"
moz
-
foo2
"
"
moz
-
bar2
"
"
target2
"
getApplyDirFile
(
)
.
path
+
"
/
"
+
DIR_RESOURCES
+
"
link2
"
"
change
-
perm
"
]
;
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
equal
(
exitValue
0
"
the
helper
process
exit
value
should
be
0
"
)
;
}
function
removeSymlink
(
)
{
let
args
=
[
"
remove
-
symlink
"
"
moz
-
foo
"
"
moz
-
bar
"
"
target
"
getApplyDirFile
(
)
.
path
+
"
/
"
+
DIR_RESOURCES
+
"
link
"
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
equal
(
exitValue
0
"
the
helper
process
exit
value
should
be
0
"
)
;
args
=
[
"
remove
-
symlink
"
"
moz
-
foo2
"
"
moz
-
bar2
"
"
target2
"
getApplyDirFile
(
)
.
path
+
"
/
"
+
DIR_RESOURCES
+
"
link2
"
]
;
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
equal
(
exitValue
0
"
the
helper
process
exit
value
should
be
0
"
)
;
}
function
checkSymlink
(
)
{
let
args
=
[
"
check
-
symlink
"
getApplyDirFile
(
)
.
path
+
"
/
"
+
DIR_RESOURCES
+
"
link
"
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
equal
(
exitValue
0
"
the
helper
process
exit
value
should
be
0
"
)
;
}
function
setupActiveUpdate
(
)
{
let
state
=
IS_SERVICE_TEST
?
STATE_PENDING_SVC
:
STATE_PENDING
;
let
channel
=
gDefaultPrefBranch
.
getCharPref
(
PREF_APP_UPDATE_CHANNEL
)
;
let
patches
=
getLocalPatchString
(
null
null
null
null
null
"
true
"
state
)
;
let
updates
=
getLocalUpdateString
(
patches
null
null
null
null
null
null
null
null
null
null
null
"
true
"
channel
)
;
writeUpdatesToXMLFile
(
getLocalUpdatesXMLString
(
updates
)
true
)
;
writeVersionFile
(
DEFAULT_UPDATE_VERSION
)
;
writeStatusFile
(
state
)
;
reloadUpdateManagerData
(
)
;
Assert
.
ok
(
!
!
gUpdateManager
.
activeUpdate
"
the
active
update
should
be
defined
"
)
;
}
function
getUpdateLog
(
aLogLeafName
)
{
let
updateLog
=
getUpdatesDir
(
)
;
if
(
aLogLeafName
=
=
FILE_UPDATE_LOG
)
{
updateLog
.
append
(
DIR_PATCH
)
;
}
updateLog
.
append
(
aLogLeafName
)
;
return
updateLog
;
}
function
stageUpdate
(
)
{
debugDump
(
"
start
-
attempting
to
stage
update
"
)
;
if
(
IS_TOOLKIT_GONK
)
{
copyTestUpdaterToBinDir
(
)
;
}
Services
.
obs
.
addObserver
(
gUpdateStagedObserver
"
update
-
staged
"
false
)
;
setAppBundleModTime
(
)
;
setEnvironment
(
)
;
Cc
[
"
mozilla
.
org
/
updates
/
update
-
processor
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdateProcessor
)
.
processUpdate
(
gUpdateManager
.
activeUpdate
)
;
debugDump
(
"
finish
-
attempting
to
stage
update
"
)
;
}
function
checkUpdateStagedState
(
aUpdateState
)
{
if
(
IS_WIN
)
{
waitForApplicationStop
(
FILE_UPDATER_BIN
)
;
}
Assert
.
equal
(
aUpdateState
STATE_AFTER_STAGE
"
the
notified
state
"
+
MSG_SHOULD_EQUAL
)
;
if
(
!
gStagingRemovedUpdate
)
{
Assert
.
equal
(
readStatusState
(
)
STATE_AFTER_STAGE
"
the
status
file
state
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
gUpdateManager
.
activeUpdate
.
state
STATE_AFTER_STAGE
"
the
update
state
"
+
MSG_SHOULD_EQUAL
)
;
}
Assert
.
equal
(
gUpdateManager
.
updateCount
1
"
the
update
manager
updateCount
attribute
"
+
MSG_SHOULD_EQUAL
)
;
Assert
.
equal
(
gUpdateManager
.
getUpdateAt
(
0
)
.
state
STATE_AFTER_STAGE
"
the
update
state
"
+
MSG_SHOULD_EQUAL
)
;
let
log
=
getUpdateLog
(
FILE_LAST_UPDATE_LOG
)
;
Assert
.
ok
(
log
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
log
.
path
)
)
;
log
=
getUpdateLog
(
FILE_UPDATE_LOG
)
;
Assert
.
ok
(
!
log
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
log
.
path
)
)
;
log
=
getUpdateLog
(
FILE_BACKUP_UPDATE_LOG
)
;
Assert
.
ok
(
!
log
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
log
.
path
)
)
;
let
stageDir
=
getStageDirFile
(
null
true
)
;
if
(
STATE_AFTER_STAGE
=
=
STATE_APPLIED
|
|
STATE_AFTER_STAGE
=
=
STATE_APPLIED_SVC
)
{
Assert
.
ok
(
stageDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
stageDir
.
path
)
)
;
}
else
{
Assert
.
ok
(
!
stageDir
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
stageDir
.
path
)
)
;
}
do_execute_soon
(
stageUpdateFinished
)
;
}
function
shouldRunServiceTest
(
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
let
binDir
=
getGREBinDir
(
)
;
let
updaterBin
=
binDir
.
clone
(
)
;
updaterBin
.
append
(
FILE_UPDATER_BIN
)
;
Assert
.
ok
(
updaterBin
.
exists
(
)
MSG_SHOULD_EXIST
+
"
leafName
:
"
+
updaterBin
.
leafName
)
;
let
updaterBinPath
=
updaterBin
.
path
;
if
(
/
/
.
test
(
updaterBinPath
)
)
{
updaterBinPath
=
'
"
'
+
updaterBinPath
+
'
"
'
;
}
let
isBinSigned
=
isBinarySigned
(
updaterBinPath
)
;
const
REG_PATH
=
"
SOFTWARE
\
\
Mozilla
\
\
MaintenanceService
\
\
"
+
"
3932ecacee736d366d6436db0f55bce4
"
;
let
key
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
try
{
key
.
open
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_LOCAL_MACHINE
REG_PATH
Ci
.
nsIWindowsRegKey
.
ACCESS_READ
|
key
.
WOW64_64
)
;
}
catch
(
e
)
{
if
(
IS_AUTHENTICODE_CHECK_ENABLED
)
{
Assert
.
ok
(
!
isBinSigned
"
the
updater
.
exe
binary
should
not
be
signed
when
the
test
"
+
"
registry
key
doesn
'
t
exist
(
if
it
is
build
system
"
+
"
configuration
bug
?
)
"
)
;
}
logTestInfo
(
"
this
test
can
only
run
on
the
buildbot
build
system
at
this
"
+
"
time
"
)
;
return
false
;
}
let
args
=
[
"
wait
-
for
-
service
-
stop
"
"
MozillaMaintenance
"
"
10
"
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
notEqual
(
exitValue
0xEE
"
the
maintenance
service
should
be
"
+
"
installed
(
if
not
build
system
configuration
bug
?
)
"
)
;
if
(
IS_AUTHENTICODE_CHECK_ENABLED
)
{
Assert
.
ok
(
isBinSigned
"
the
updater
.
exe
binary
should
be
signed
(
if
not
build
system
"
+
"
configuration
bug
?
)
"
)
;
}
return
attemptServiceInstall
(
)
;
}
function
isBinarySigned
(
aBinPath
)
{
let
args
=
[
"
check
-
signature
"
aBinPath
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
if
(
exitValue
!
=
0
)
{
logTestInfo
(
"
binary
is
not
signed
.
"
+
FILE_HELPER_BIN
+
"
returned
"
+
exitValue
+
"
for
file
"
+
aBinPath
)
;
return
false
;
}
return
true
;
}
function
setupAppFilesAsync
(
)
{
gTimeoutRuns
+
+
;
try
{
setupAppFiles
(
)
;
}
catch
(
e
)
{
if
(
gTimeoutRuns
>
MAX_TIMEOUT_RUNS
)
{
do_throw
(
"
Exceeded
MAX_TIMEOUT_RUNS
while
trying
to
setup
application
"
+
"
files
!
Exception
:
"
+
e
)
;
}
do_execute_soon
(
setupAppFilesAsync
)
;
return
;
}
do_execute_soon
(
setupUpdaterTestFinished
)
;
}
function
setupAppFiles
(
)
{
debugDump
(
"
start
-
copying
or
creating
symlinks
to
application
files
"
+
"
for
the
test
"
)
;
let
destDir
=
getApplyDirFile
(
null
true
)
;
if
(
!
destDir
.
exists
(
)
)
{
try
{
destDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
PERMS_DIRECTORY
)
;
}
catch
(
e
)
{
logTestInfo
(
"
unable
to
create
directory
!
Path
:
"
+
destDir
.
path
+
"
Exception
:
"
+
e
)
;
do_throw
(
e
)
;
}
}
let
appFiles
=
[
{
relPath
:
FILE_APP_BIN
inGreDir
:
false
}
{
relPath
:
FILE_APPLICATION_INI
inGreDir
:
true
}
{
relPath
:
"
dependentlibs
.
list
"
inGreDir
:
true
}
]
;
if
(
IS_UNIX
&
&
!
IS_MACOSX
&
&
!
IS_TOOLKIT_GONK
)
{
appFiles
.
push
(
{
relPath
:
"
icons
/
updater
.
png
"
inGreDir
:
true
}
)
;
}
let
deplibsFile
=
gGREDirOrig
.
clone
(
)
;
deplibsFile
.
append
(
"
dependentlibs
.
list
"
)
;
let
fis
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fis
.
init
(
deplibsFile
0x01
0o444
Ci
.
nsIFileInputStream
.
CLOSE_ON_EOF
)
;
fis
.
QueryInterface
(
Ci
.
nsILineInputStream
)
;
let
hasMore
;
let
line
=
{
}
;
do
{
hasMore
=
fis
.
readLine
(
line
)
;
appFiles
.
push
(
{
relPath
:
line
.
value
inGreDir
:
false
}
)
;
}
while
(
hasMore
)
;
fis
.
close
(
)
;
appFiles
.
forEach
(
function
CMAF_FLN_FE
(
aAppFile
)
{
copyFileToTestAppDir
(
aAppFile
.
relPath
aAppFile
.
inGreDir
)
;
}
)
;
copyTestUpdaterToBinDir
(
)
;
debugDump
(
"
finish
-
copying
or
creating
symlinks
to
application
files
"
+
"
for
the
test
"
)
;
}
function
copyFileToTestAppDir
(
aFileRelPath
aInGreDir
)
{
let
srcFile
=
aInGreDir
?
gGREDirOrig
.
clone
(
)
:
gGREBinDirOrig
.
clone
(
)
;
let
destFile
=
aInGreDir
?
getGREDir
(
)
:
getGREBinDir
(
)
;
let
fileRelPath
=
aFileRelPath
;
let
pathParts
=
fileRelPath
.
split
(
"
/
"
)
;
for
(
let
i
=
0
;
i
<
pathParts
.
length
;
i
+
+
)
{
if
(
pathParts
[
i
]
)
{
srcFile
.
append
(
pathParts
[
i
]
)
;
destFile
.
append
(
pathParts
[
i
]
)
;
}
}
if
(
IS_MACOSX
&
&
!
srcFile
.
exists
(
)
)
{
debugDump
(
"
unable
to
copy
file
since
it
doesn
'
t
exist
!
Checking
if
"
+
fileRelPath
+
"
.
app
exists
.
Path
:
"
+
srcFile
.
path
)
;
srcFile
=
aInGreDir
?
gGREDirOrig
.
clone
(
)
:
gGREBinDirOrig
.
clone
(
)
;
destFile
=
aInGreDir
?
getGREDir
(
)
:
getGREBinDir
(
)
;
for
(
let
i
=
0
;
i
<
pathParts
.
length
;
i
+
+
)
{
if
(
pathParts
[
i
]
)
{
srcFile
.
append
(
pathParts
[
i
]
+
(
pathParts
.
length
-
1
=
=
i
?
"
.
app
"
:
"
"
)
)
;
destFile
.
append
(
pathParts
[
i
]
+
(
pathParts
.
length
-
1
=
=
i
?
"
.
app
"
:
"
"
)
)
;
}
}
fileRelPath
=
fileRelPath
+
"
.
app
"
;
}
Assert
.
ok
(
srcFile
.
exists
(
)
MSG_SHOULD_EXIST
+
"
leafName
:
"
+
srcFile
.
leafName
)
;
let
shouldSymlink
=
(
pathParts
[
pathParts
.
length
-
1
]
=
=
"
XUL
"
|
|
fileRelPath
.
substr
(
fileRelPath
.
length
-
3
)
=
=
"
.
so
"
|
|
fileRelPath
.
substr
(
fileRelPath
.
length
-
6
)
=
=
"
.
dylib
"
)
;
if
(
!
shouldSymlink
|
|
IS_TOOLKIT_GONK
)
{
if
(
!
destFile
.
exists
(
)
)
{
try
{
srcFile
.
copyToFollowingLinks
(
destFile
.
parent
destFile
.
leafName
)
;
}
catch
(
e
)
{
if
(
destFile
.
exists
(
)
)
{
try
{
destFile
.
remove
(
true
)
;
}
catch
(
e
)
{
logTestInfo
(
"
unable
to
remove
file
that
failed
to
copy
!
Path
:
"
+
destFile
.
path
)
;
}
}
do_throw
(
"
Unable
to
copy
file
!
Path
:
"
+
srcFile
.
path
+
"
Exception
:
"
+
e
)
;
}
}
}
else
{
try
{
if
(
destFile
.
exists
(
)
)
{
destFile
.
remove
(
false
)
;
}
let
ln
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsILocalFile
)
;
ln
.
initWithPath
(
"
/
bin
/
ln
"
)
;
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
process
.
init
(
ln
)
;
let
args
=
[
"
-
s
"
srcFile
.
path
destFile
.
path
]
;
process
.
run
(
true
args
args
.
length
)
;
Assert
.
ok
(
destFile
.
isSymlink
(
)
destFile
.
leafName
+
"
should
be
a
symlink
"
)
;
}
catch
(
e
)
{
do_throw
(
"
Unable
to
create
symlink
for
file
!
Path
:
"
+
srcFile
.
path
+
"
Exception
:
"
+
e
)
;
}
}
}
function
attemptServiceInstall
(
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
let
maintSvcDir
=
getMaintSvcDir
(
)
;
Assert
.
ok
(
maintSvcDir
.
exists
(
)
MSG_SHOULD_EXIST
+
"
leafName
:
"
+
maintSvcDir
.
leafName
)
;
let
oldMaintSvcBin
=
maintSvcDir
.
clone
(
)
;
oldMaintSvcBin
.
append
(
FILE_MAINTENANCE_SERVICE_BIN
)
;
Assert
.
ok
(
oldMaintSvcBin
.
exists
(
)
MSG_SHOULD_EXIST
+
"
leafName
:
"
+
oldMaintSvcBin
.
leafName
)
;
let
buildMaintSvcBin
=
getGREBinDir
(
)
;
buildMaintSvcBin
.
append
(
FILE_MAINTENANCE_SERVICE_BIN
)
;
if
(
readFileBytes
(
oldMaintSvcBin
)
=
=
readFileBytes
(
buildMaintSvcBin
)
)
{
debugDump
(
"
installed
maintenance
service
binary
is
the
same
as
the
"
+
"
build
'
s
maintenance
service
binary
"
)
;
return
true
;
}
let
backupMaintSvcBin
=
maintSvcDir
.
clone
(
)
;
backupMaintSvcBin
.
append
(
FILE_MAINTENANCE_SERVICE_BIN
+
"
.
backup
"
)
;
try
{
if
(
backupMaintSvcBin
.
exists
(
)
)
{
backupMaintSvcBin
.
remove
(
false
)
;
}
oldMaintSvcBin
.
moveTo
(
maintSvcDir
FILE_MAINTENANCE_SERVICE_BIN
+
"
.
backup
"
)
;
buildMaintSvcBin
.
copyTo
(
maintSvcDir
FILE_MAINTENANCE_SERVICE_BIN
)
;
backupMaintSvcBin
.
remove
(
false
)
;
}
catch
(
e
)
{
if
(
backupMaintSvcBin
.
exists
(
)
)
{
oldMaintSvcBin
=
maintSvcDir
.
clone
(
)
;
oldMaintSvcBin
.
append
(
FILE_MAINTENANCE_SERVICE_BIN
)
;
if
(
!
oldMaintSvcBin
.
exists
(
)
)
{
backupMaintSvcBin
.
moveTo
(
maintSvcDir
FILE_MAINTENANCE_SERVICE_BIN
)
;
}
}
Assert
.
ok
(
false
"
should
be
able
copy
the
test
maintenance
service
to
"
+
"
the
maintenance
service
directory
(
if
not
build
system
"
+
"
configuration
bug
?
)
path
:
"
+
maintSvcDir
.
path
)
;
}
return
true
;
}
function
waitServiceApps
(
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
waitForApplicationStop
(
"
maintenanceservice_installer
.
exe
"
)
;
waitForApplicationStop
(
"
maintenanceservice_tmp
.
exe
"
)
;
waitForApplicationStop
(
"
maintenanceservice
.
exe
"
)
;
}
function
waitForServiceStop
(
aFailTest
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
waitServiceApps
(
)
;
debugDump
(
"
waiting
for
the
maintenance
service
to
stop
if
necessary
"
)
;
let
args
=
[
"
wait
-
for
-
service
-
stop
"
"
MozillaMaintenance
"
"
120
"
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
notEqual
(
exitValue
0xEE
"
the
maintenance
service
should
exist
"
)
;
if
(
exitValue
!
=
0
)
{
if
(
aFailTest
)
{
Assert
.
ok
(
false
"
the
maintenance
service
should
stop
process
exit
"
+
"
value
:
"
+
exitValue
)
;
}
logTestInfo
(
"
maintenance
service
did
not
stop
which
may
cause
test
"
+
"
failures
later
process
exit
value
:
"
+
exitValue
)
;
}
else
{
debugDump
(
"
service
stopped
"
)
;
}
waitServiceApps
(
)
;
}
function
waitForApplicationStop
(
aApplication
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
debugDump
(
"
waiting
for
"
+
aApplication
+
"
to
stop
if
necessary
"
)
;
let
args
=
[
"
wait
-
for
-
application
-
exit
"
aApplication
"
120
"
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
Assert
.
equal
(
exitValue
0
"
the
process
should
have
stopped
process
name
:
"
+
aApplication
)
;
}
function
isProcessRunning
(
aApplication
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
debugDump
(
"
checking
if
"
+
aApplication
+
"
is
running
"
)
;
let
args
=
[
"
is
-
process
-
running
"
aApplication
]
;
let
exitValue
=
runTestHelperSync
(
args
)
;
return
exitValue
;
}
function
runUpdateUsingService
(
aExpectedStatus
aSwitchApp
aCheckSvcLog
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
function
checkServiceLogs
(
aOriginalContents
)
{
let
contents
=
readServiceLogFile
(
)
;
Assert
.
notEqual
(
contents
aOriginalContents
"
the
contents
of
the
maintenanceservice
.
log
should
not
"
+
"
be
the
same
as
the
original
contents
"
)
;
Assert
.
notEqual
(
contents
.
indexOf
(
LOG_SVC_SUCCESSFUL_LAUNCH
)
-
1
"
the
contents
of
the
maintenanceservice
.
log
should
"
+
"
contain
the
successful
launch
string
"
)
;
}
function
readServiceLogFile
(
)
{
let
file
=
getMaintSvcDir
(
)
;
file
.
append
(
"
logs
"
)
;
file
.
append
(
"
maintenanceservice
.
log
"
)
;
return
readFile
(
file
)
;
}
function
checkServiceUpdateFinished
(
)
{
if
(
isProcessRunning
(
FILE_MAINTENANCE_SERVICE_BIN
)
)
{
do_execute_soon
(
checkServiceUpdateFinished
)
;
return
;
}
if
(
isProcessRunning
(
FILE_UPDATER_BIN
)
)
{
do_execute_soon
(
checkServiceUpdateFinished
)
;
return
;
}
let
status
;
try
{
status
=
readStatusFile
(
)
;
}
catch
(
e
)
{
do_execute_soon
(
checkServiceUpdateFinished
)
;
return
;
}
if
(
status
=
=
STATE_APPLYING
)
{
debugDump
(
"
still
waiting
to
see
the
"
+
aExpectedStatus
+
"
status
got
"
+
status
+
"
for
now
.
.
.
"
)
;
do_execute_soon
(
checkServiceUpdateFinished
)
;
return
;
}
waitForServiceStop
(
false
)
;
resetEnvironment
(
)
;
if
(
status
!
=
aExpectedStatus
)
{
logTestInfo
(
"
update
status
is
not
the
expected
status
!
Got
:
"
+
status
+
"
Expected
:
"
+
aExpectedStatus
)
;
logTestInfo
(
"
update
.
status
contents
:
"
+
readStatusFile
(
)
)
;
logUpdateLog
(
FILE_UPDATE_LOG
)
;
}
Assert
.
equal
(
status
aExpectedStatus
"
the
update
status
"
+
MSG_SHOULD_EQUAL
)
;
if
(
aCheckSvcLog
)
{
checkServiceLogs
(
svcOriginalLog
)
;
}
do_execute_soon
(
runUpdateFinished
)
;
}
waitForServiceStop
(
true
)
;
if
(
gRegisteredServiceCleanup
=
=
=
undefined
)
{
gRegisteredServiceCleanup
=
true
;
do_register_cleanup
(
function
RUUS_cleanup
(
)
{
resetEnvironment
(
)
;
try
{
getAppArgsLogPath
(
)
;
}
catch
(
e
)
{
logTestInfo
(
"
unable
to
remove
file
during
cleanup
.
Exception
:
"
+
e
)
;
}
}
)
;
}
let
svcOriginalLog
;
if
(
aCheckSvcLog
)
{
svcOriginalLog
=
readServiceLogFile
(
)
;
}
let
appArgsLogPath
=
getAppArgsLogPath
(
)
;
gServiceLaunchedCallbackLog
=
appArgsLogPath
.
replace
(
/
^
"
|
"
/
g
"
"
)
;
gServiceLaunchedCallbackArgs
=
[
"
-
no
-
remote
"
"
-
test
-
process
-
updates
"
"
-
dump
-
args
"
appArgsLogPath
]
;
if
(
aSwitchApp
)
{
gShouldResetEnv
=
undefined
;
}
setEnvironment
(
)
;
let
updater
=
getTestDirFile
(
FILE_UPDATER_BIN
)
;
if
(
!
updater
.
exists
(
)
)
{
do_throw
(
"
Unable
to
find
the
updater
binary
!
"
)
;
}
let
testBinDir
=
getGREBinDir
(
)
;
updater
.
copyToFollowingLinks
(
testBinDir
updater
.
leafName
)
;
copyFileToTestAppDir
(
FILE_MAINTENANCE_SERVICE_BIN
false
)
;
copyFileToTestAppDir
(
FILE_MAINTENANCE_SERVICE_INSTALLER_BIN
false
)
;
let
launchBin
=
getLaunchBin
(
)
;
let
args
=
getProcessArgs
(
[
"
-
dump
-
args
"
appArgsLogPath
]
)
;
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
process
.
init
(
launchBin
)
;
debugDump
(
"
launching
"
+
launchBin
.
path
+
"
"
+
args
.
join
(
"
"
)
)
;
process
.
run
(
true
args
args
.
length
)
;
do_execute_soon
(
checkServiceUpdateFinished
)
;
}
function
getLaunchBin
(
)
{
let
launchBin
;
if
(
IS_WIN
)
{
launchBin
=
Services
.
dirsvc
.
get
(
"
WinD
"
Ci
.
nsIFile
)
;
launchBin
.
append
(
"
System32
"
)
;
launchBin
.
append
(
"
cmd
.
exe
"
)
;
}
else
{
launchBin
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsILocalFile
)
;
launchBin
.
initWithPath
(
"
/
bin
/
sh
"
)
;
}
Assert
.
ok
(
launchBin
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
launchBin
.
path
)
)
;
return
launchBin
;
}
function
lockDirectory
(
aDirPath
)
{
if
(
!
IS_WIN
)
{
do_throw
(
"
Windows
only
function
called
by
a
different
platform
!
"
)
;
}
debugDump
(
"
start
-
locking
installation
directory
"
)
;
const
LPCWSTR
=
ctypes
.
char16_t
.
ptr
;
const
DWORD
=
ctypes
.
uint32_t
;
const
LPVOID
=
ctypes
.
voidptr_t
;
const
GENERIC_READ
=
0x80000000
;
const
FILE_SHARE_READ
=
1
;
const
FILE_SHARE_WRITE
=
2
;
const
OPEN_EXISTING
=
3
;
const
FILE_FLAG_BACKUP_SEMANTICS
=
0x02000000
;
const
INVALID_HANDLE_VALUE
=
LPVOID
(
0xffffffff
)
;
let
kernel32
=
ctypes
.
open
(
"
kernel32
"
)
;
let
CreateFile
=
kernel32
.
declare
(
"
CreateFileW
"
ctypes
.
default_abi
LPVOID
LPCWSTR
DWORD
DWORD
LPVOID
DWORD
DWORD
LPVOID
)
;
gHandle
=
CreateFile
(
aDirPath
GENERIC_READ
FILE_SHARE_READ
|
FILE_SHARE_WRITE
LPVOID
(
0
)
OPEN_EXISTING
FILE_FLAG_BACKUP_SEMANTICS
LPVOID
(
0
)
)
;
Assert
.
notEqual
(
gHandle
.
toString
(
)
INVALID_HANDLE_VALUE
.
toString
(
)
"
the
handle
should
not
equal
INVALID_HANDLE_VALUE
"
)
;
kernel32
.
close
(
)
;
debugDump
(
"
finish
-
locking
installation
directory
"
)
;
}
function
runHelperFileInUse
(
aRelPath
aCopyTestHelper
)
{
logTestInfo
(
"
aRelPath
:
"
+
aRelPath
)
;
let
helperBin
=
getTestDirFile
(
FILE_HELPER_BIN
)
;
let
fileInUseBin
=
getApplyDirFile
(
aRelPath
)
;
if
(
aCopyTestHelper
)
{
fileInUseBin
.
remove
(
false
)
;
helperBin
.
copyTo
(
fileInUseBin
.
parent
fileInUseBin
.
leafName
)
;
}
fileInUseBin
.
permissions
=
PERMS_DIRECTORY
;
let
args
=
[
getApplyDirPath
(
)
+
DIR_RESOURCES
"
input
"
"
output
"
"
-
s
"
HELPER_SLEEP_TIMEOUT
]
;
let
fileInUseProcess
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
fileInUseProcess
.
init
(
fileInUseBin
)
;
fileInUseProcess
.
run
(
false
args
args
.
length
)
;
do_execute_soon
(
waitForHelperSleep
)
;
}
function
runHelperLockFile
(
aTestFile
)
{
let
helperBin
=
getTestDirFile
(
FILE_HELPER_BIN
)
;
let
helperDestDir
=
getApplyDirFile
(
DIR_RESOURCES
)
;
helperBin
.
copyTo
(
helperDestDir
FILE_HELPER_BIN
)
;
helperBin
=
getApplyDirFile
(
DIR_RESOURCES
+
FILE_HELPER_BIN
)
;
let
lockFileRelPath
=
aTestFile
.
relPathDir
.
split
(
"
/
"
)
;
if
(
IS_MACOSX
)
{
lockFileRelPath
=
lockFileRelPath
.
slice
(
2
)
;
}
lockFileRelPath
=
lockFileRelPath
.
join
(
"
/
"
)
+
"
/
"
+
aTestFile
.
fileName
;
let
args
=
[
getApplyDirPath
(
)
+
DIR_RESOURCES
"
input
"
"
output
"
"
-
s
"
HELPER_SLEEP_TIMEOUT
lockFileRelPath
]
;
let
helperProcess
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
helperProcess
.
init
(
helperBin
)
;
helperProcess
.
run
(
false
args
args
.
length
)
;
do_execute_soon
(
waitForHelperSleep
)
;
}
function
waitForHelperSleep
(
)
{
gTimeoutRuns
+
+
;
let
output
=
getApplyDirFile
(
DIR_RESOURCES
+
"
output
"
true
)
;
if
(
readFile
(
output
)
!
=
"
sleeping
\
n
"
)
{
if
(
gTimeoutRuns
>
MAX_TIMEOUT_RUNS
)
{
do_throw
(
"
Exceeded
MAX_TIMEOUT_RUNS
while
waiting
for
the
helper
to
"
+
"
finish
its
operation
.
Path
:
"
+
output
.
path
)
;
}
do_execute_soon
(
waitForHelperSleep
)
;
return
;
}
try
{
output
.
remove
(
false
)
;
}
catch
(
e
)
{
if
(
gTimeoutRuns
>
MAX_TIMEOUT_RUNS
)
{
do_throw
(
"
Exceeded
MAX_TIMEOUT_RUNS
while
waiting
for
the
helper
"
+
"
message
file
to
no
longer
be
in
use
.
Path
:
"
+
output
.
path
)
;
}
debugDump
(
"
failed
to
remove
file
.
Path
:
"
+
output
.
path
)
;
do_execute_soon
(
waitForHelperSleep
)
;
return
;
}
waitForHelperSleepFinished
(
)
;
}
function
waitForHelperFinished
(
)
{
let
output
=
getApplyDirFile
(
DIR_RESOURCES
+
"
output
"
true
)
;
if
(
readFile
(
output
)
!
=
"
finished
\
n
"
)
{
do_execute_soon
(
waitForHelperFinished
)
;
return
;
}
waitForHelperFinishFileUnlock
(
)
;
}
function
waitForHelperFinishFileUnlock
(
)
{
try
{
let
output
=
getApplyDirFile
(
DIR_RESOURCES
+
"
output
"
true
)
;
if
(
output
.
exists
(
)
)
{
output
.
remove
(
false
)
;
}
let
input
=
getApplyDirFile
(
DIR_RESOURCES
+
"
input
"
true
)
;
if
(
input
.
exists
(
)
)
{
input
.
remove
(
false
)
;
}
}
catch
(
e
)
{
do_execute_soon
(
waitForHelperFinishFileUnlock
)
;
return
;
}
do_execute_soon
(
waitForHelperExitFinished
)
;
}
function
waitForHelperExit
(
)
{
let
input
=
getApplyDirFile
(
DIR_RESOURCES
+
"
input
"
true
)
;
writeFile
(
input
"
finish
\
n
"
)
;
waitForHelperFinished
(
)
;
}
function
setupUpdaterTest
(
aMarFile
aPostUpdateAsync
)
{
let
updatesPatchDir
=
getUpdatesPatchDir
(
)
;
if
(
!
updatesPatchDir
.
exists
(
)
)
{
updatesPatchDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
PERMS_DIRECTORY
)
;
}
let
mar
=
getTestDirFile
(
aMarFile
)
;
mar
.
copyToFollowingLinks
(
updatesPatchDir
FILE_UPDATE_MAR
)
;
let
helperBin
=
getTestDirFile
(
FILE_HELPER_BIN
)
;
helperBin
.
permissions
=
PERMS_DIRECTORY
;
let
afterApplyBinDir
=
getApplyDirFile
(
DIR_RESOURCES
true
)
;
helperBin
.
copyToFollowingLinks
(
afterApplyBinDir
gCallbackBinFile
)
;
helperBin
.
copyToFollowingLinks
(
afterApplyBinDir
gPostUpdateBinFile
)
;
gTestFiles
.
forEach
(
function
SUT_TF_FE
(
aTestFile
)
{
if
(
aTestFile
.
originalFile
|
|
aTestFile
.
originalContents
)
{
let
testDir
=
getApplyDirFile
(
aTestFile
.
relPathDir
true
)
;
if
(
!
testDir
.
exists
(
)
)
{
testDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
PERMS_DIRECTORY
)
;
}
let
testFile
;
if
(
aTestFile
.
originalFile
)
{
testFile
=
getTestDirFile
(
aTestFile
.
originalFile
)
;
testFile
.
copyToFollowingLinks
(
testDir
aTestFile
.
fileName
)
;
testFile
=
getApplyDirFile
(
aTestFile
.
relPathDir
+
aTestFile
.
fileName
)
;
}
else
{
testFile
=
getApplyDirFile
(
aTestFile
.
relPathDir
+
aTestFile
.
fileName
true
)
;
writeFile
(
testFile
aTestFile
.
originalContents
)
;
}
if
(
!
IS_WIN
&
&
aTestFile
.
originalPerms
)
{
testFile
.
permissions
=
aTestFile
.
originalPerms
;
if
(
!
aTestFile
.
comparePerms
)
{
aTestFile
.
comparePerms
=
testFile
.
permissions
;
}
}
}
}
)
;
gTestDirs
.
forEach
(
function
SUT_TD_FE
(
aTestDir
)
{
let
testDir
=
getApplyDirFile
(
aTestDir
.
relPathDir
true
)
;
if
(
!
testDir
.
exists
(
)
)
{
testDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
PERMS_DIRECTORY
)
;
}
if
(
aTestDir
.
files
)
{
aTestDir
.
files
.
forEach
(
function
SUT_TD_F_FE
(
aTestFile
)
{
let
testFile
=
getApplyDirFile
(
aTestDir
.
relPathDir
+
aTestFile
true
)
;
if
(
!
testFile
.
exists
(
)
)
{
testFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
PERMS_FILE
)
;
}
}
)
;
}
if
(
aTestDir
.
subDirs
)
{
aTestDir
.
subDirs
.
forEach
(
function
SUT_TD_SD_FE
(
aSubDir
)
{
let
testSubDir
=
getApplyDirFile
(
aTestDir
.
relPathDir
+
aSubDir
true
)
;
if
(
!
testSubDir
.
exists
(
)
)
{
testSubDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
PERMS_DIRECTORY
)
;
}
if
(
aTestDir
.
subDirFiles
)
{
aTestDir
.
subDirFiles
.
forEach
(
function
SUT_TD_SDF_FE
(
aTestFile
)
{
let
testFile
=
getApplyDirFile
(
aTestDir
.
relPathDir
+
aSubDir
+
aTestFile
true
)
;
if
(
!
testFile
.
exists
(
)
)
{
testFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
PERMS_FILE
)
;
}
}
)
;
}
}
)
;
}
}
)
;
setupActiveUpdate
(
)
;
if
(
aPostUpdateAsync
!
=
=
null
)
{
createUpdaterINI
(
aPostUpdateAsync
)
;
}
if
(
IS_TOOLKIT_GONK
)
{
do_execute_soon
(
setupUpdaterTestFinished
)
;
}
else
{
setupAppFilesAsync
(
)
;
}
}
function
createUpdateSettingsINI
(
)
{
let
ini
=
getApplyDirFile
(
DIR_RESOURCES
+
FILE_UPDATE_SETTINGS_INI
true
)
;
writeFile
(
ini
UPDATE_SETTINGS_CONTENTS
)
;
}
function
createUpdaterINI
(
aIsExeAsync
)
{
let
exeArg
=
"
ExeArg
=
post
-
update
-
async
\
n
"
;
let
exeAsync
=
"
"
;
if
(
aIsExeAsync
!
=
=
undefined
)
{
if
(
aIsExeAsync
)
{
exeAsync
=
"
ExeAsync
=
true
\
n
"
;
}
else
{
exeArg
=
"
ExeArg
=
post
-
update
-
sync
\
n
"
;
exeAsync
=
"
ExeAsync
=
false
\
n
"
;
}
}
let
updaterIniContents
=
"
[
Strings
]
\
n
"
+
"
Title
=
Update
Test
\
n
"
+
"
Info
=
Running
update
test
"
+
gTestID
+
"
\
n
\
n
"
+
"
[
PostUpdateMac
]
\
n
"
+
"
ExeRelPath
=
"
+
DIR_RESOURCES
+
gPostUpdateBinFile
+
"
\
n
"
+
exeArg
+
exeAsync
+
"
\
n
"
+
"
[
PostUpdateWin
]
\
n
"
+
"
ExeRelPath
=
"
+
gPostUpdateBinFile
+
"
\
n
"
+
exeArg
+
exeAsync
;
let
updaterIni
=
getApplyDirFile
(
DIR_RESOURCES
+
FILE_UPDATER_INI
true
)
;
writeFile
(
updaterIni
updaterIniContents
)
;
}
function
getMsgPath
(
aPath
)
{
return
"
path
:
"
+
replaceLogPaths
(
aPath
)
;
}
function
replaceLogPaths
(
aLogContents
)
{
let
logContents
=
aLogContents
;
let
testDirPath
=
do_get_file
(
gTestID
false
)
.
path
;
if
(
IS_WIN
)
{
testDirPath
=
testDirPath
.
replace
(
/
\
\
/
g
"
\
\
\
\
"
)
;
}
logContents
=
logContents
.
replace
(
new
RegExp
(
testDirPath
"
g
"
)
"
<
test_dir_path
>
/
"
+
gTestID
)
;
let
updatesDirPath
=
getMockUpdRootD
(
)
.
path
;
if
(
IS_WIN
)
{
updatesDirPath
=
updatesDirPath
.
replace
(
/
\
\
/
g
"
\
\
\
\
"
)
;
}
logContents
=
logContents
.
replace
(
new
RegExp
(
updatesDirPath
"
g
"
)
"
<
update_dir_path
>
/
"
+
gTestID
)
;
if
(
IS_WIN
)
{
logContents
=
logContents
.
replace
(
/
\
\
/
g
"
/
"
)
;
}
return
logContents
;
}
function
checkUpdateLogContents
(
aCompareLogFile
aStaged
=
false
aReplace
=
false
aExcludeDistDir
=
false
)
{
if
(
IS_UNIX
&
&
!
IS_MACOSX
)
{
return
;
}
let
updateLog
=
getUpdateLog
(
FILE_LAST_UPDATE_LOG
)
;
let
updateLogContents
=
readFileBytes
(
updateLog
)
;
if
(
gTestFiles
.
length
>
1
&
&
gTestFiles
[
gTestFiles
.
length
-
1
]
.
fileName
=
=
"
channel
-
prefs
.
js
"
&
&
!
gTestFiles
[
gTestFiles
.
length
-
1
]
.
originalContents
)
{
updateLogContents
=
updateLogContents
.
replace
(
/
.
*
defaults
\
/
.
*
/
g
"
"
)
;
}
if
(
gTestFiles
.
length
>
2
&
&
gTestFiles
[
gTestFiles
.
length
-
2
]
.
fileName
=
=
FILE_UPDATE_SETTINGS_INI
&
&
!
gTestFiles
[
gTestFiles
.
length
-
2
]
.
originalContents
)
{
updateLogContents
=
updateLogContents
.
replace
(
/
.
*
update
-
settings
.
ini
.
*
/
g
"
"
)
;
}
updateLogContents
=
updateLogContents
.
replace
(
/
PATCH
DIRECTORY
.
*
/
g
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
INSTALLATION
DIRECTORY
.
*
/
g
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
WORKING
DIRECTORY
.
*
/
g
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
NS_main
:
callback
app
file
.
*
/
g
"
"
)
;
if
(
IS_MACOSX
)
{
updateLogContents
=
updateLogContents
.
replace
(
/
Moving
old
[
^
\
n
]
*
\
nrename_file
:
.
*
/
g
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
New
distribution
directory
.
*
/
g
"
"
)
;
}
if
(
IS_WIN
)
{
let
re
=
new
RegExp
(
"
(
[
^
\
n
]
*
7
\
/
7text1
[
^
\
n
]
*
)
\
n
"
+
"
(
[
^
\
n
]
*
7
\
/
7text0
[
^
\
n
]
*
)
\
n
"
"
g
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
re
"
2
\
n
1
\
n
"
)
;
}
if
(
aReplace
)
{
updateLogContents
=
updateLogContents
.
replace
(
/
^
Begin
moving
.
*
/
mg
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
^
ensure_remove
:
failed
to
remove
file
:
.
*
/
mg
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
^
ensure_remove_recursive
:
unable
to
remove
directory
:
.
*
/
mg
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
^
Removing
tmpDir
failed
err
:
-
1
/
mg
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
^
remove_recursive_on_reboot
:
.
*
/
mg
"
"
)
;
}
updateLogContents
=
updateLogContents
.
replace
(
/
\
r
/
g
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
err
:
.
*
\
n
/
g
"
\
n
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
non
-
fatal
error
/
g
"
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
\
n
+
/
g
"
\
n
"
)
;
updateLogContents
=
updateLogContents
.
replace
(
/
^
\
n
|
\
n
/
g
"
"
)
;
updateLogContents
=
replaceLogPaths
(
updateLogContents
)
;
let
compareLogContents
=
"
"
;
if
(
aCompareLogFile
)
{
compareLogContents
=
readFileBytes
(
getTestDirFile
(
aCompareLogFile
)
)
;
}
if
(
aStaged
)
{
compareLogContents
=
PERFORMING_STAGED_UPDATE
+
"
\
n
"
+
compareLogContents
;
}
if
(
gTestFiles
.
length
>
1
&
&
gTestFiles
[
gTestFiles
.
length
-
1
]
.
fileName
=
=
"
channel
-
prefs
.
js
"
&
&
!
gTestFiles
[
gTestFiles
.
length
-
1
]
.
originalContents
)
{
compareLogContents
=
compareLogContents
.
replace
(
/
.
*
defaults
\
/
.
*
/
g
"
"
)
;
}
if
(
gTestFiles
.
length
>
2
&
&
gTestFiles
[
gTestFiles
.
length
-
2
]
.
fileName
=
=
FILE_UPDATE_SETTINGS_INI
&
&
!
gTestFiles
[
gTestFiles
.
length
-
2
]
.
originalContents
)
{
compareLogContents
=
compareLogContents
.
replace
(
/
.
*
update
-
settings
.
ini
.
*
/
g
"
"
)
;
}
if
(
aExcludeDistDir
)
{
compareLogContents
=
compareLogContents
.
replace
(
/
.
*
distribution
\
/
.
*
/
g
"
"
)
;
}
compareLogContents
=
compareLogContents
.
replace
(
/
\
n
+
/
g
"
\
n
"
)
;
compareLogContents
=
compareLogContents
.
replace
(
/
^
\
n
|
\
n
/
g
"
"
)
;
if
(
compareLogContents
=
=
updateLogContents
)
{
Assert
.
ok
(
true
"
the
update
log
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
else
{
logTestInfo
(
"
the
update
log
contents
are
not
correct
"
)
;
logUpdateLog
(
FILE_LAST_UPDATE_LOG
)
;
let
aryLog
=
updateLogContents
.
split
(
"
\
n
"
)
;
let
aryCompare
=
compareLogContents
.
split
(
"
\
n
"
)
;
aryLog
.
push
(
"
"
)
;
aryCompare
.
push
(
"
"
)
;
for
(
let
i
=
0
;
i
<
aryLog
.
length
;
+
+
i
)
{
if
(
aryLog
[
i
]
!
=
aryCompare
[
i
]
)
{
logTestInfo
(
"
the
first
incorrect
line
in
the
update
log
is
:
"
+
aryLog
[
i
]
)
;
Assert
.
equal
(
aryLog
[
i
]
aryCompare
[
i
]
"
the
update
log
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
}
do_throw
(
"
Unable
to
find
incorrect
update
log
contents
!
"
)
;
}
}
function
checkUpdateLogContains
(
aCheckString
)
{
let
updateLog
=
getUpdateLog
(
FILE_LAST_UPDATE_LOG
)
;
let
updateLogContents
=
readFileBytes
(
updateLog
)
.
replace
(
/
\
r
\
n
/
g
"
\
n
"
)
;
updateLogContents
=
replaceLogPaths
(
updateLogContents
)
;
Assert
.
notEqual
(
updateLogContents
.
indexOf
(
aCheckString
)
-
1
"
the
update
log
contents
should
contain
value
:
"
+
aCheckString
)
;
}
function
checkFilesAfterUpdateSuccess
(
aGetFileFunc
aStageDirExists
=
false
aToBeDeletedDirExists
=
false
)
{
debugDump
(
"
testing
contents
of
files
after
a
successful
update
"
)
;
gTestFiles
.
forEach
(
function
CFAUS_TF_FE
(
aTestFile
)
{
let
testFile
=
aGetFileFunc
(
aTestFile
.
relPathDir
+
aTestFile
.
fileName
true
)
;
debugDump
(
"
testing
file
:
"
+
testFile
.
path
)
;
if
(
aTestFile
.
compareFile
|
|
aTestFile
.
compareContents
)
{
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
if
(
!
IS_WIN
&
&
aTestFile
.
comparePerms
)
{
Assert
.
equal
(
testFile
.
permissions
&
0xfff
aTestFile
.
comparePerms
&
0xfff
"
the
file
permissions
"
+
MSG_SHOULD_EQUAL
)
;
}
let
fileContents1
=
readFileBytes
(
testFile
)
;
let
fileContents2
=
aTestFile
.
compareFile
?
readFileBytes
(
getTestDirFile
(
aTestFile
.
compareFile
)
)
:
aTestFile
.
compareContents
;
if
(
fileContents1
=
=
fileContents2
)
{
Assert
.
ok
(
true
"
the
file
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
else
{
Assert
.
equal
(
fileContents1
fileContents2
"
the
file
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
}
else
{
Assert
.
ok
(
!
testFile
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
}
)
;
debugDump
(
"
testing
operations
specified
in
removed
-
files
were
performed
"
+
"
after
a
successful
update
"
)
;
gTestDirs
.
forEach
(
function
CFAUS_TD_FE
(
aTestDir
)
{
let
testDir
=
aGetFileFunc
(
aTestDir
.
relPathDir
true
)
;
debugDump
(
"
testing
directory
:
"
+
testDir
.
path
)
;
if
(
aTestDir
.
dirRemoved
)
{
Assert
.
ok
(
!
testDir
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
testDir
.
path
)
)
;
}
else
{
Assert
.
ok
(
testDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testDir
.
path
)
)
;
if
(
aTestDir
.
files
)
{
aTestDir
.
files
.
forEach
(
function
CFAUS_TD_F_FE
(
aTestFile
)
{
let
testFile
=
aGetFileFunc
(
aTestDir
.
relPathDir
+
aTestFile
true
)
;
if
(
aTestDir
.
filesRemoved
)
{
Assert
.
ok
(
!
testFile
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
else
{
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
}
)
;
}
if
(
aTestDir
.
subDirs
)
{
aTestDir
.
subDirs
.
forEach
(
function
CFAUS_TD_SD_FE
(
aSubDir
)
{
let
testSubDir
=
aGetFileFunc
(
aTestDir
.
relPathDir
+
aSubDir
true
)
;
Assert
.
ok
(
testSubDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testSubDir
.
path
)
)
;
if
(
aTestDir
.
subDirFiles
)
{
aTestDir
.
subDirFiles
.
forEach
(
function
CFAUS_TD_SDF_FE
(
aTestFile
)
{
let
testFile
=
aGetFileFunc
(
aTestDir
.
relPathDir
+
aSubDir
+
aTestFile
true
)
;
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
)
;
}
}
)
;
}
}
}
)
;
checkFilesAfterUpdateCommon
(
aGetFileFunc
aStageDirExists
aToBeDeletedDirExists
)
;
}
function
checkFilesAfterUpdateFailure
(
aGetFileFunc
aStageDirExists
=
false
aToBeDeletedDirExists
=
false
)
{
debugDump
(
"
testing
contents
of
files
after
a
failed
update
"
)
;
gTestFiles
.
forEach
(
function
CFAUF_TF_FE
(
aTestFile
)
{
let
testFile
=
aGetFileFunc
(
aTestFile
.
relPathDir
+
aTestFile
.
fileName
true
)
;
debugDump
(
"
testing
file
:
"
+
testFile
.
path
)
;
if
(
aTestFile
.
compareFile
|
|
aTestFile
.
compareContents
)
{
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
if
(
!
IS_WIN
&
&
aTestFile
.
comparePerms
)
{
Assert
.
equal
(
testFile
.
permissions
&
0xfff
aTestFile
.
comparePerms
&
0xfff
"
the
file
permissions
"
+
MSG_SHOULD_EQUAL
)
;
}
let
fileContents1
=
readFileBytes
(
testFile
)
;
let
fileContents2
=
aTestFile
.
compareFile
?
readFileBytes
(
getTestDirFile
(
aTestFile
.
compareFile
)
)
:
aTestFile
.
compareContents
;
if
(
fileContents1
=
=
fileContents2
)
{
Assert
.
ok
(
true
"
the
file
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
else
{
Assert
.
equal
(
fileContents1
fileContents2
"
the
file
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
}
else
{
Assert
.
ok
(
!
testFile
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
}
)
;
debugDump
(
"
testing
operations
specified
in
removed
-
files
were
not
"
+
"
performed
after
a
failed
update
"
)
;
gTestDirs
.
forEach
(
function
CFAUF_TD_FE
(
aTestDir
)
{
let
testDir
=
aGetFileFunc
(
aTestDir
.
relPathDir
true
)
;
Assert
.
ok
(
testDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testDir
.
path
)
)
;
if
(
aTestDir
.
files
)
{
aTestDir
.
files
.
forEach
(
function
CFAUS_TD_F_FE
(
aTestFile
)
{
let
testFile
=
aGetFileFunc
(
aTestDir
.
relPathDir
+
aTestFile
true
)
;
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
)
;
}
if
(
aTestDir
.
subDirs
)
{
aTestDir
.
subDirs
.
forEach
(
function
CFAUS_TD_SD_FE
(
aSubDir
)
{
let
testSubDir
=
aGetFileFunc
(
aTestDir
.
relPathDir
+
aSubDir
true
)
;
Assert
.
ok
(
testSubDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testSubDir
.
path
)
)
;
if
(
aTestDir
.
subDirFiles
)
{
aTestDir
.
subDirFiles
.
forEach
(
function
CFAUS_TD_SDF_FE
(
aTestFile
)
{
let
testFile
=
aGetFileFunc
(
aTestDir
.
relPathDir
+
aSubDir
+
aTestFile
true
)
;
Assert
.
ok
(
testFile
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
testFile
.
path
)
)
;
}
)
;
}
}
)
;
}
}
)
;
checkFilesAfterUpdateCommon
(
aGetFileFunc
aStageDirExists
aToBeDeletedDirExists
)
;
}
function
checkFilesAfterUpdateCommon
(
aGetFileFunc
aStageDirExists
aToBeDeletedDirExists
)
{
debugDump
(
"
testing
extra
directories
"
)
;
let
stageDir
=
getStageDirFile
(
null
true
)
;
if
(
aStageDirExists
)
{
Assert
.
ok
(
stageDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
stageDir
.
path
)
)
;
}
else
{
Assert
.
ok
(
!
stageDir
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
stageDir
.
path
)
)
;
}
let
toBeDeletedDirExists
=
IS_WIN
?
aToBeDeletedDirExists
:
false
;
let
toBeDeletedDir
=
getApplyDirFile
(
DIR_TOBEDELETED
true
)
;
if
(
toBeDeletedDirExists
)
{
Assert
.
ok
(
toBeDeletedDir
.
exists
(
)
MSG_SHOULD_EXIST
+
getMsgPath
(
toBeDeletedDir
.
path
)
)
;
}
else
{
Assert
.
ok
(
!
toBeDeletedDir
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
toBeDeletedDir
.
path
)
)
;
}
let
updatingDir
=
getApplyDirFile
(
"
updating
"
true
)
;
Assert
.
ok
(
!
updatingDir
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
updatingDir
.
path
)
)
;
if
(
stageDir
.
exists
(
)
)
{
updatingDir
=
stageDir
.
clone
(
)
;
updatingDir
.
append
(
"
updating
"
)
;
Assert
.
ok
(
!
updatingDir
.
exists
(
)
MSG_SHOULD_NOT_EXIST
+
getMsgPath
(
updatingDir
.
path
)
)
;
}
debugDump
(
"
testing
backup
files
should
not
be
left
behind
in
the
"
+
"
application
directory
"
)
;
let
applyToDir
=
getApplyDirFile
(
null
true
)
;
checkFilesInDirRecursive
(
applyToDir
checkForBackupFiles
)
;
if
(
stageDir
.
exists
(
)
)
{
debugDump
(
"
testing
backup
files
should
not
be
left
behind
in
the
"
+
"
staging
directory
"
)
;
let
applyToDir
=
getApplyDirFile
(
null
true
)
;
checkFilesInDirRecursive
(
stageDir
checkForBackupFiles
)
;
}
debugDump
(
"
testing
patch
files
should
not
be
left
behind
"
)
;
let
updatesDir
=
getUpdatesPatchDir
(
)
;
let
entries
=
updatesDir
.
QueryInterface
(
Ci
.
nsIFile
)
.
directoryEntries
;
while
(
entries
.
hasMoreElements
(
)
)
{
let
entry
=
entries
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIFile
)
;
Assert
.
notEqual
(
getFileExtension
(
entry
)
"
patch
"
"
the
file
'
s
extension
should
not
equal
patch
"
+
getMsgPath
(
entry
.
path
)
)
;
}
}
function
checkCallbackLog
(
)
{
if
(
IS_SERVICE_TEST
)
{
checkCallbackServiceLog
(
)
;
}
else
{
checkCallbackAppLog
(
)
;
}
}
function
checkCallbackAppLog
(
)
{
let
appLaunchLog
=
getApplyDirFile
(
DIR_RESOURCES
+
gCallbackArgs
[
1
]
true
)
;
if
(
!
appLaunchLog
.
exists
(
)
)
{
do_execute_soon
(
checkCallbackAppLog
)
;
return
;
}
let
expectedLogContents
=
gCallbackArgs
.
join
(
"
\
n
"
)
+
"
\
n
"
;
let
logContents
=
readFile
(
appLaunchLog
)
;
if
(
logContents
!
=
expectedLogContents
)
{
gTimeoutRuns
+
+
;
if
(
gTimeoutRuns
>
MAX_TIMEOUT_RUNS
)
{
logTestInfo
(
"
callback
log
contents
are
not
correct
"
)
;
let
aryLog
=
logContents
.
split
(
"
\
n
"
)
;
let
aryCompare
=
expectedLogContents
.
split
(
"
\
n
"
)
;
aryLog
.
push
(
"
"
)
;
aryCompare
.
push
(
"
"
)
;
for
(
let
i
=
0
;
i
<
aryLog
.
length
;
+
+
i
)
{
if
(
aryLog
[
i
]
!
=
aryCompare
[
i
]
)
{
logTestInfo
(
"
the
first
incorrect
line
in
the
callback
log
is
:
"
+
aryLog
[
i
]
)
;
Assert
.
equal
(
aryLog
[
i
]
aryCompare
[
i
]
"
the
callback
log
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
}
do_throw
(
"
Unable
to
find
incorrect
callback
log
contents
!
"
)
;
}
do_execute_soon
(
checkCallbackAppLog
)
;
return
;
}
Assert
.
ok
(
true
"
the
callback
log
contents
"
+
MSG_SHOULD_EQUAL
)
;
waitForFilesInUse
(
)
;
}
function
getPostUpdateFile
(
aSuffix
)
{
return
getApplyDirFile
(
DIR_RESOURCES
+
gPostUpdateBinFile
+
aSuffix
true
)
;
}
function
checkPostUpdateAppLog
(
)
{
if
(
IS_MACOSX
|
|
IS_WIN
)
{
gTimeoutRuns
+
+
;
let
postUpdateLog
=
getPostUpdateFile
(
"
.
log
"
)
;
if
(
!
postUpdateLog
.
exists
(
)
)
{
debugDump
(
"
postUpdateLog
does
not
exist
.
Path
:
"
+
postUpdateLog
.
path
)
;
if
(
gTimeoutRuns
>
MAX_TIMEOUT_RUNS
)
{
do_throw
(
"
Exceeded
MAX_TIMEOUT_RUNS
while
waiting
for
the
post
update
"
+
"
process
to
create
the
post
update
log
.
Path
:
"
+
postUpdateLog
.
path
)
;
}
do_execute_soon
(
checkPostUpdateAppLog
)
;
return
;
}
let
logContents
=
readFile
(
postUpdateLog
)
;
if
(
logContents
!
=
"
post
-
update
\
n
"
)
{
if
(
gTimeoutRuns
>
MAX_TIMEOUT_RUNS
)
{
do_throw
(
"
Exceeded
MAX_TIMEOUT_RUNS
while
waiting
for
the
post
update
"
+
"
process
to
create
the
expected
contents
in
the
post
update
log
.
Path
:
"
+
postUpdateLog
.
path
)
;
}
do_execute_soon
(
checkPostUpdateAppLog
)
;
return
;
}
Assert
.
ok
(
true
"
the
post
update
log
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
do_execute_soon
(
checkPostUpdateAppLogFinished
)
;
}
function
checkCallbackServiceLog
(
)
{
Assert
.
ok
(
!
!
gServiceLaunchedCallbackLog
"
gServiceLaunchedCallbackLog
should
be
defined
"
)
;
let
expectedLogContents
=
gServiceLaunchedCallbackArgs
.
join
(
"
\
n
"
)
+
"
\
n
"
;
let
logFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsILocalFile
)
;
logFile
.
initWithPath
(
gServiceLaunchedCallbackLog
)
;
let
logContents
=
readFile
(
logFile
)
;
if
(
logContents
!
=
expectedLogContents
)
{
gTimeoutRuns
+
+
;
if
(
gTimeoutRuns
>
MAX_TIMEOUT_RUNS
)
{
logTestInfo
(
"
callback
service
log
contents
are
not
correct
"
)
;
let
aryLog
=
logContents
.
split
(
"
\
n
"
)
;
let
aryCompare
=
expectedLogContents
.
split
(
"
\
n
"
)
;
aryLog
.
push
(
"
"
)
;
aryCompare
.
push
(
"
"
)
;
for
(
let
i
=
0
;
i
<
aryLog
.
length
;
+
+
i
)
{
if
(
aryLog
[
i
]
!
=
aryCompare
[
i
]
)
{
logTestInfo
(
"
the
first
incorrect
line
in
the
service
callback
log
"
+
"
is
:
"
+
aryLog
[
i
]
)
;
Assert
.
equal
(
aryLog
[
i
]
aryCompare
[
i
]
"
the
service
callback
log
contents
"
+
MSG_SHOULD_EQUAL
)
;
}
}
do_throw
(
"
Unable
to
find
incorrect
service
callback
log
contents
!
"
)
;
}
do_execute_soon
(
checkCallbackServiceLog
)
;
return
;
}
Assert
.
ok
(
true
"
the
callback
service
log
contents
"
+
MSG_SHOULD_EQUAL
)
;
waitForFilesInUse
(
)
;
}
function
waitForFilesInUse
(
)
{
if
(
IS_WIN
)
{
if
(
isProcessRunning
(
FILE_UPDATER_BIN
)
)
{
do_execute_soon
(
waitForFilesInUse
)
;
return
;
}
if
(
isProcessRunning
(
FILE_MAINTENANCE_SERVICE_INSTALLER_BIN
)
)
{
do_execute_soon
(
waitForFilesInUse
)
;
return
;
}
let
appBin
=
getApplyDirFile
(
FILE_APP_BIN
true
)
;
let
maintSvcInstaller
=
getApplyDirFile
(
FILE_MAINTENANCE_SERVICE_INSTALLER_BIN
true
)
;
let
helper
=
getApplyDirFile
(
"
uninstall
/
helper
.
exe
"
true
)
;
let
updater
=
getApplyDirFile
(
FILE_UPDATER_BIN
true
)
;
let
files
=
[
appBin
updater
maintSvcInstaller
helper
]
;
for
(
let
i
=
0
;
i
<
files
.
length
;
+
+
i
)
{
let
file
=
files
[
i
]
;
let
fileBak
=
file
.
parent
.
clone
(
)
;
if
(
file
.
exists
(
)
)
{
fileBak
.
append
(
file
.
leafName
+
"
.
bak
"
)
;
try
{
if
(
fileBak
.
exists
(
)
)
{
fileBak
.
remove
(
false
)
;
}
file
.
copyTo
(
fileBak
.
parent
fileBak
.
leafName
)
;
file
.
remove
(
false
)
;
fileBak
.
moveTo
(
file
.
parent
file
.
leafName
)
;
debugDump
(
"
file
is
not
in
use
path
:
"
+
file
.
path
)
;
}
catch
(
e
)
{
debugDump
(
"
will
try
again
to
remove
file
in
use
path
:
"
+
file
.
path
+
"
exception
:
"
+
e
)
;
try
{
if
(
fileBak
.
exists
(
)
)
{
fileBak
.
remove
(
false
)
;
}
}
catch
(
e
)
{
logTestInfo
(
"
unable
to
remove
backup
file
path
:
"
+
fileBak
.
path
+
"
exception
:
"
+
e
)
;
}
do_execute_soon
(
waitForFilesInUse
)
;
return
;
}
}
}
}
debugDump
(
"
calling
doTestFinish
"
)
;
doTestFinish
(
)
;
}
function
checkForBackupFiles
(
aFile
)
{
Assert
.
notEqual
(
getFileExtension
(
aFile
)
"
moz
-
backup
"
"
the
file
'
s
extension
should
not
equal
moz
-
backup
"
+
getMsgPath
(
aFile
.
path
)
)
;
}
function
checkFilesInDirRecursive
(
aDir
aCallback
)
{
if
(
!
aDir
.
exists
(
)
)
{
do_throw
(
"
Directory
must
exist
!
"
)
;
}
let
dirEntries
=
aDir
.
directoryEntries
;
while
(
dirEntries
.
hasMoreElements
(
)
)
{
let
entry
=
dirEntries
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIFile
)
;
if
(
entry
.
exists
(
)
)
{
if
(
entry
.
isDirectory
(
)
)
{
checkFilesInDirRecursive
(
entry
aCallback
)
;
}
else
{
aCallback
(
entry
)
;
}
}
}
}
function
overrideXHR
(
aCallback
)
{
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
jsm
"
)
;
MockRegistrar
.
register
(
"
mozilla
.
org
/
xmlextras
/
xmlhttprequest
;
1
"
xhr
[
aCallback
]
)
;
}
function
makeHandler
(
aVal
)
{
if
(
typeof
aVal
=
=
"
function
"
)
{
return
{
handleEvent
:
aVal
}
;
}
return
aVal
;
}
function
xhr
(
aCallback
)
{
this
.
_callback
=
aCallback
;
}
xhr
.
prototype
=
{
overrideMimeType
:
function
(
aMimetype
)
{
}
setRequestHeader
:
function
(
aHeader
aValue
)
{
}
status
:
null
channel
:
{
set
notificationCallbacks
(
aVal
)
{
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIChannel
]
)
}
_url
:
null
_method
:
null
open
:
function
(
aMethod
aUrl
)
{
this
.
channel
.
originalURI
=
Services
.
io
.
newURI
(
aUrl
null
null
)
;
this
.
_method
=
aMethod
;
this
.
_url
=
aUrl
;
}
responseXML
:
null
responseText
:
null
send
:
function
(
aBody
)
{
do_execute_soon
(
function
(
)
{
this
.
_callback
(
this
)
;
}
.
bind
(
this
)
)
;
}
_onprogress
:
null
set
onprogress
(
aValue
)
{
this
.
_onprogress
=
makeHandler
(
aValue
)
;
}
get
onprogress
(
)
{
return
this
.
_onprogress
;
}
_onerror
:
null
set
onerror
(
aValue
)
{
this
.
_onerror
=
makeHandler
(
aValue
)
;
}
get
onerror
(
)
{
return
this
.
_onerror
;
}
_onload
:
null
set
onload
(
aValue
)
{
this
.
_onload
=
makeHandler
(
aValue
)
;
}
get
onload
(
)
{
return
this
.
_onload
;
}
addEventListener
:
function
(
aEvent
aValue
aCapturing
)
{
eval
(
"
this
.
_on
"
+
aEvent
+
"
=
aValue
"
)
;
}
flags
:
Ci
.
nsIClassInfo
.
SINGLETON
getScriptableHelper
:
(
)
=
>
null
getInterfaces
:
function
(
aCount
)
{
let
interfaces
=
[
Ci
.
nsISupports
]
;
aCount
.
value
=
interfaces
.
length
;
return
interfaces
;
}
get
wrappedJSObject
(
)
{
return
this
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIClassInfo
]
)
}
;
function
overrideUpdatePrompt
(
aCallback
)
{
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
jsm
"
)
;
MockRegistrar
.
register
(
"
mozilla
.
org
/
updates
/
update
-
prompt
;
1
"
UpdatePrompt
[
aCallback
]
)
;
}
function
UpdatePrompt
(
aCallback
)
{
this
.
_callback
=
aCallback
;
let
fns
=
[
"
checkForUpdates
"
"
showUpdateAvailable
"
"
showUpdateDownloaded
"
"
showUpdateError
"
"
showUpdateHistory
"
"
showUpdateInstalled
"
]
;
fns
.
forEach
(
function
UP_fns
(
aPromptFn
)
{
UpdatePrompt
.
prototype
[
aPromptFn
]
=
function
(
)
{
if
(
!
this
.
_callback
)
{
return
;
}
let
callback
=
this
.
_callback
[
aPromptFn
]
;
if
(
!
callback
)
{
return
;
}
callback
.
apply
(
this
.
_callback
Array
.
prototype
.
slice
.
call
(
arguments
)
)
;
}
}
)
;
}
UpdatePrompt
.
prototype
=
{
flags
:
Ci
.
nsIClassInfo
.
SINGLETON
getScriptableHelper
:
(
)
=
>
null
getInterfaces
:
function
(
aCount
)
{
let
interfaces
=
[
Ci
.
nsISupports
Ci
.
nsIUpdatePrompt
]
;
aCount
.
value
=
interfaces
.
length
;
return
interfaces
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIClassInfo
Ci
.
nsIUpdatePrompt
]
)
}
;
const
updateCheckListener
=
{
onProgress
:
function
UCL_onProgress
(
aRequest
aPosition
aTotalSize
)
{
}
onCheckComplete
:
function
UCL_onCheckComplete
(
aRequest
aUpdates
aUpdateCount
)
{
gRequestURL
=
aRequest
.
channel
.
originalURI
.
spec
;
gUpdateCount
=
aUpdateCount
;
gUpdates
=
aUpdates
;
debugDump
(
"
url
=
"
+
gRequestURL
+
"
"
+
"
request
.
status
=
"
+
aRequest
.
status
+
"
"
+
"
updateCount
=
"
+
aUpdateCount
)
;
do_execute_soon
(
gCheckFunc
)
;
}
onError
:
function
UCL_onError
(
aRequest
aUpdate
)
{
gRequestURL
=
aRequest
.
channel
.
originalURI
.
spec
;
gStatusCode
=
aRequest
.
status
;
gStatusText
=
aUpdate
.
statusText
?
aUpdate
.
statusText
:
null
;
debugDump
(
"
url
=
"
+
gRequestURL
+
"
"
+
"
request
.
status
=
"
+
gStatusCode
+
"
"
+
"
update
.
statusText
=
"
+
gStatusText
)
;
do_execute_soon
(
gCheckFunc
.
bind
(
null
aRequest
aUpdate
)
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIUpdateCheckListener
]
)
}
;
const
downloadListener
=
{
onStartRequest
:
function
DL_onStartRequest
(
aRequest
aContext
)
{
}
onProgress
:
function
DL_onProgress
(
aRequest
aContext
aProgress
aMaxProgress
)
{
}
onStatus
:
function
DL_onStatus
(
aRequest
aContext
aStatus
aStatusText
)
{
}
onStopRequest
:
function
DL_onStopRequest
(
aRequest
aContext
aStatus
)
{
gStatusResult
=
aStatus
;
do_execute_soon
(
gCheckFunc
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIRequestObserver
Ci
.
nsIProgressEventSink
]
)
}
;
function
start_httpserver
(
)
{
let
dir
=
getTestDirFile
(
)
;
debugDump
(
"
http
server
directory
path
:
"
+
dir
.
path
)
;
if
(
!
dir
.
isDirectory
(
)
)
{
do_throw
(
"
A
file
instead
of
a
directory
was
specified
for
HttpServer
"
+
"
registerDirectory
!
Path
:
"
+
dir
.
path
)
;
}
let
{
HttpServer
}
=
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
{
}
)
;
gTestserver
=
new
HttpServer
(
)
;
gTestserver
.
registerDirectory
(
"
/
"
dir
)
;
gTestserver
.
start
(
-
1
)
;
let
testserverPort
=
gTestserver
.
identity
.
primaryPort
;
gURLData
=
URL_HOST
+
"
:
"
+
testserverPort
+
"
/
"
;
debugDump
(
"
http
server
port
=
"
+
testserverPort
)
;
}
function
stop_httpserver
(
aCallback
)
{
Assert
.
ok
(
!
!
aCallback
"
the
aCallback
parameter
should
be
defined
"
)
;
gTestserver
.
stop
(
aCallback
)
;
}
function
createAppInfo
(
aID
aName
aVersion
aPlatformVersion
)
{
const
XULAPPINFO_CONTRACTID
=
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
;
const
XULAPPINFO_CID
=
Components
.
ID
(
"
{
c763b610
-
9d49
-
455a
-
bbd2
-
ede71682a1ac
}
"
)
;
let
ifaces
=
[
Ci
.
nsIXULAppInfo
Ci
.
nsIXULRuntime
]
;
if
(
IS_WIN
)
{
ifaces
.
push
(
Ci
.
nsIWinAppHelper
)
;
}
const
XULAppInfo
=
{
vendor
:
APP_INFO_VENDOR
name
:
aName
ID
:
aID
version
:
aVersion
appBuildID
:
"
2007010101
"
platformVersion
:
aPlatformVersion
platformBuildID
:
"
2007010101
"
inSafeMode
:
false
logConsoleErrors
:
true
OS
:
"
XPCShell
"
XPCOMABI
:
"
noarch
-
spidermonkey
"
QueryInterface
:
XPCOMUtils
.
generateQI
(
ifaces
)
}
;
const
XULAppInfoFactory
=
{
createInstance
:
function
(
aOuter
aIID
)
{
if
(
aOuter
=
=
null
)
{
return
XULAppInfo
.
QueryInterface
(
aIID
)
;
}
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
}
}
;
let
registrar
=
Cm
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
registrar
.
registerFactory
(
XULAPPINFO_CID
"
XULAppInfo
"
XULAPPINFO_CONTRACTID
XULAppInfoFactory
)
;
}
function
getProcessArgs
(
aExtraArgs
)
{
if
(
!
aExtraArgs
)
{
aExtraArgs
=
[
]
;
}
let
appBinPath
=
getApplyDirFile
(
DIR_MACOS
+
FILE_APP_BIN
false
)
.
path
;
if
(
/
/
.
test
(
appBinPath
)
)
{
appBinPath
=
'
"
'
+
appBinPath
+
'
"
'
;
}
let
args
;
if
(
IS_UNIX
)
{
let
launchScript
=
getLaunchScript
(
)
;
launchScript
.
create
(
Ci
.
nsILocalFile
.
NORMAL_FILE_TYPE
PERMS_DIRECTORY
)
;
let
scriptContents
=
"
#
!
/
bin
/
sh
\
n
"
;
scriptContents
+
=
appBinPath
+
"
-
no
-
remote
-
test
-
process
-
updates
"
+
aExtraArgs
.
join
(
"
"
)
+
"
"
+
PIPE_TO_NULL
;
writeFile
(
launchScript
scriptContents
)
;
debugDump
(
"
created
"
+
launchScript
.
path
+
"
containing
:
\
n
"
+
scriptContents
)
;
args
=
[
launchScript
.
path
]
;
}
else
{
args
=
[
"
/
D
"
"
/
Q
"
"
/
C
"
appBinPath
"
-
no
-
remote
"
"
-
test
-
process
-
updates
"
]
.
concat
(
aExtraArgs
)
.
concat
(
[
PIPE_TO_NULL
]
)
;
}
return
args
;
}
function
getAppArgsLogPath
(
)
{
let
appArgsLog
=
do_get_file
(
"
/
"
+
gTestID
+
"
_app_args_log
"
true
)
;
if
(
appArgsLog
.
exists
(
)
)
{
appArgsLog
.
remove
(
false
)
;
}
let
appArgsLogPath
=
appArgsLog
.
path
;
if
(
/
/
.
test
(
appArgsLogPath
)
)
{
appArgsLogPath
=
'
"
'
+
appArgsLogPath
+
'
"
'
;
}
return
appArgsLogPath
;
}
function
getLaunchScript
(
)
{
let
launchScript
=
do_get_file
(
"
/
"
+
gTestID
+
"
_launch
.
sh
"
true
)
;
if
(
launchScript
.
exists
(
)
)
{
launchScript
.
remove
(
false
)
;
}
return
launchScript
;
}
function
adjustGeneralPaths
(
)
{
let
dirProvider
=
{
getFile
:
function
AGP_DP_getFile
(
aProp
aPersistent
)
{
aPersistent
.
value
=
true
;
switch
(
aProp
)
{
case
NS_GRE_DIR
:
if
(
gUseTestAppDir
)
{
return
getApplyDirFile
(
DIR_RESOURCES
true
)
;
}
break
;
case
NS_GRE_BIN_DIR
:
if
(
gUseTestAppDir
)
{
return
getApplyDirFile
(
DIR_MACOS
true
)
;
}
break
;
case
XRE_EXECUTABLE_FILE
:
if
(
gUseTestAppDir
)
{
return
getApplyDirFile
(
DIR_MACOS
+
FILE_APP_BIN
true
)
;
}
break
;
case
XRE_UPDATE_ROOT_DIR
:
return
getMockUpdRootD
(
)
;
}
return
null
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIDirectoryServiceProvider
]
)
}
;
let
ds
=
Services
.
dirsvc
.
QueryInterface
(
Ci
.
nsIDirectoryService
)
;
ds
.
QueryInterface
(
Ci
.
nsIProperties
)
.
undefine
(
NS_GRE_DIR
)
;
ds
.
QueryInterface
(
Ci
.
nsIProperties
)
.
undefine
(
NS_GRE_BIN_DIR
)
;
ds
.
QueryInterface
(
Ci
.
nsIProperties
)
.
undefine
(
XRE_EXECUTABLE_FILE
)
;
ds
.
registerProvider
(
dirProvider
)
;
do_register_cleanup
(
function
AGP_cleanup
(
)
{
debugDump
(
"
start
-
unregistering
directory
provider
"
)
;
if
(
gAppTimer
)
{
debugDump
(
"
start
-
cancel
app
timer
"
)
;
gAppTimer
.
cancel
(
)
;
gAppTimer
=
null
;
debugDump
(
"
finish
-
cancel
app
timer
"
)
;
}
if
(
gProcess
&
&
gProcess
.
isRunning
)
{
debugDump
(
"
start
-
kill
process
"
)
;
try
{
gProcess
.
kill
(
)
;
}
catch
(
e
)
{
debugDump
(
"
kill
process
failed
.
Exception
:
"
+
e
)
;
}
gProcess
=
null
;
debugDump
(
"
finish
-
kill
process
"
)
;
}
if
(
gHandle
)
{
try
{
debugDump
(
"
start
-
closing
handle
"
)
;
let
kernel32
=
ctypes
.
open
(
"
kernel32
"
)
;
let
CloseHandle
=
kernel32
.
declare
(
"
CloseHandle
"
ctypes
.
default_abi
ctypes
.
bool
ctypes
.
voidptr_t
)
;
if
(
!
CloseHandle
(
gHandle
)
)
{
debugDump
(
"
call
to
CloseHandle
failed
"
)
;
}
kernel32
.
close
(
)
;
gHandle
=
null
;
debugDump
(
"
finish
-
closing
handle
"
)
;
}
catch
(
e
)
{
debugDump
(
"
call
to
CloseHandle
failed
.
Exception
:
"
+
e
)
;
}
}
if
(
typeof
(
end_test
)
=
=
typeof
(
Function
)
)
{
debugDump
(
"
calling
end_test
"
)
;
end_test
(
)
;
}
ds
.
unregisterProvider
(
dirProvider
)
;
cleanupTestCommon
(
)
;
debugDump
(
"
finish
-
unregistering
directory
provider
"
)
;
}
)
;
}
function
runUpdateUsingApp
(
aExpectedStatus
)
{
const
processObserver
=
{
observe
:
function
PO_observe
(
aSubject
aTopic
aData
)
{
debugDump
(
"
topic
:
"
+
aTopic
+
"
process
exitValue
:
"
+
gProcess
.
exitValue
)
;
resetEnvironment
(
)
;
if
(
gAppTimer
)
{
gAppTimer
.
cancel
(
)
;
gAppTimer
=
null
;
}
Assert
.
equal
(
gProcess
.
exitValue
0
"
the
application
process
exit
value
should
be
0
"
)
;
Assert
.
equal
(
aTopic
"
process
-
finished
"
"
the
application
process
observer
topic
should
be
"
+
"
process
-
finished
"
)
;
if
(
IS_SERVICE_TEST
)
{
waitForServiceStop
(
)
;
}
do_execute_soon
(
afterAppExits
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
}
;
function
afterAppExits
(
)
{
gTimeoutRuns
+
+
;
if
(
IS_WIN
)
{
waitForApplicationStop
(
FILE_UPDATER_BIN
)
;
}
let
status
;
try
{
status
=
readStatusFile
(
)
;
}
catch
(
e
)
{
logTestInfo
(
"
error
reading
status
file
exception
:
"
+
e
)
;
}
if
(
status
!
=
aExpectedStatus
)
{
if
(
gTimeoutRuns
>
MAX_TIMEOUT_RUNS
)
{
logUpdateLog
(
FILE_UPDATE_LOG
)
;
do_throw
(
"
Exceeded
MAX_TIMEOUT_RUNS
while
waiting
for
the
update
"
+
"
status
to
equal
:
"
+
aExpectedStatus
+
"
current
status
:
"
+
status
)
;
}
else
{
do_execute_soon
(
afterAppExits
)
;
}
return
;
}
let
log
=
getUpdateLog
(
FILE_UPDATE_LOG
)
;
if
(
!
log
.
exists
(
)
)
{
if
(
gTimeoutRuns
>
MAX_TIMEOUT_RUNS
)
{
do_throw
(
"
Exceeded
MAX_TIMEOUT_RUNS
while
waiting
for
the
update
log
"
+
"
to
be
created
.
Path
:
"
+
log
.
path
)
;
}
do_execute_soon
(
afterAppExits
)
;
return
;
}
do_execute_soon
(
runUpdateFinished
)
;
}
debugDump
(
"
start
-
launching
application
to
apply
update
"
)
;
let
appBin
=
getApplyDirFile
(
DIR_MACOS
+
FILE_APP_BIN
false
)
;
let
launchBin
=
getLaunchBin
(
)
;
let
args
=
getProcessArgs
(
)
;
debugDump
(
"
launching
"
+
launchBin
.
path
+
"
"
+
args
.
join
(
"
"
)
)
;
gProcess
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
gProcess
.
init
(
launchBin
)
;
gAppTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
gAppTimer
.
initWithCallback
(
gAppTimerCallback
APP_TIMER_TIMEOUT
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
setEnvironment
(
)
;
debugDump
(
"
launching
application
"
)
;
gProcess
.
runAsync
(
args
args
.
length
processObserver
)
;
debugDump
(
"
finish
-
launching
application
to
apply
update
"
)
;
}
const
gAppTimerCallback
=
{
notify
:
function
TC_notify
(
aTimer
)
{
gAppTimer
=
null
;
if
(
gProcess
.
isRunning
)
{
logTestInfo
(
"
attempting
to
kill
process
"
)
;
gProcess
.
kill
(
)
;
}
Assert
.
ok
(
false
"
launch
application
timer
expired
"
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsITimerCallback
]
)
}
;
const
gUpdateStagedObserver
=
{
observe
:
function
(
aSubject
aTopic
aData
)
{
debugDump
(
"
observe
called
with
topic
:
"
+
aTopic
+
"
data
:
"
+
aData
)
;
if
(
aTopic
=
=
"
update
-
staged
"
)
{
resetEnvironment
(
)
;
Services
.
obs
.
removeObserver
(
gUpdateStagedObserver
"
update
-
staged
"
)
;
checkUpdateStagedState
(
aData
)
;
}
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
}
;
function
setEnvironment
(
)
{
if
(
gShouldResetEnv
!
=
=
undefined
)
{
return
;
}
gShouldResetEnv
=
true
;
if
(
IS_WIN
&
&
!
gEnv
.
exists
(
"
XRE_NO_WINDOWS_CRASH_DIALOG
"
)
)
{
gAddedEnvXRENoWindowsCrashDialog
=
true
;
debugDump
(
"
setting
the
XRE_NO_WINDOWS_CRASH_DIALOG
environment
"
+
"
variable
to
1
.
.
.
previously
it
didn
'
t
exist
"
)
;
gEnv
.
set
(
"
XRE_NO_WINDOWS_CRASH_DIALOG
"
"
1
"
)
;
}
if
(
IS_UNIX
)
{
let
appGreBinDir
=
gGREBinDirOrig
.
clone
(
)
;
let
envGreBinDir
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsILocalFile
)
;
let
shouldSetEnv
=
true
;
if
(
IS_MACOSX
)
{
if
(
gEnv
.
exists
(
"
DYLD_LIBRARY_PATH
"
)
)
{
gEnvDyldLibraryPath
=
gEnv
.
get
(
"
DYLD_LIBRARY_PATH
"
)
;
envGreBinDir
.
initWithPath
(
gEnvDyldLibraryPath
)
;
if
(
envGreBinDir
.
path
=
=
appGreBinDir
.
path
)
{
gEnvDyldLibraryPath
=
null
;
shouldSetEnv
=
false
;
}
}
if
(
shouldSetEnv
)
{
debugDump
(
"
setting
DYLD_LIBRARY_PATH
environment
variable
value
to
"
+
appGreBinDir
.
path
)
;
gEnv
.
set
(
"
DYLD_LIBRARY_PATH
"
appGreBinDir
.
path
)
;
}
}
else
{
if
(
gEnv
.
exists
(
"
LD_LIBRARY_PATH
"
)
)
{
gEnvLdLibraryPath
=
gEnv
.
get
(
"
LD_LIBRARY_PATH
"
)
;
envGreBinDir
.
initWithPath
(
gEnvLdLibraryPath
)
;
if
(
envGreBinDir
.
path
=
=
appGreBinDir
.
path
)
{
gEnvLdLibraryPath
=
null
;
shouldSetEnv
=
false
;
}
}
if
(
shouldSetEnv
)
{
debugDump
(
"
setting
LD_LIBRARY_PATH
environment
variable
value
to
"
+
appGreBinDir
.
path
)
;
gEnv
.
set
(
"
LD_LIBRARY_PATH
"
appGreBinDir
.
path
)
;
}
}
}
if
(
gEnv
.
exists
(
"
XPCOM_MEM_LEAK_LOG
"
)
)
{
gEnvXPCOMMemLeakLog
=
gEnv
.
get
(
"
XPCOM_MEM_LEAK_LOG
"
)
;
debugDump
(
"
removing
the
XPCOM_MEM_LEAK_LOG
environment
variable
.
.
.
"
+
"
previous
value
"
+
gEnvXPCOMMemLeakLog
)
;
gEnv
.
set
(
"
XPCOM_MEM_LEAK_LOG
"
"
"
)
;
}
if
(
gEnv
.
exists
(
"
XPCOM_DEBUG_BREAK
"
)
)
{
gEnvXPCOMDebugBreak
=
gEnv
.
get
(
"
XPCOM_DEBUG_BREAK
"
)
;
debugDump
(
"
setting
the
XPCOM_DEBUG_BREAK
environment
variable
to
"
+
"
warn
.
.
.
previous
value
"
+
gEnvXPCOMDebugBreak
)
;
}
else
{
debugDump
(
"
setting
the
XPCOM_DEBUG_BREAK
environment
variable
to
"
+
"
warn
.
.
.
previously
it
didn
'
t
exist
"
)
;
}
gEnv
.
set
(
"
XPCOM_DEBUG_BREAK
"
"
warn
"
)
;
debugDump
(
"
setting
MOZ_NO_SERVICE_FALLBACK
environment
variable
to
1
"
)
;
gEnv
.
set
(
"
MOZ_NO_SERVICE_FALLBACK
"
"
1
"
)
;
}
function
resetEnvironment
(
)
{
if
(
gShouldResetEnv
!
=
=
true
)
{
return
;
}
gShouldResetEnv
=
false
;
if
(
gEnvXPCOMMemLeakLog
)
{
debugDump
(
"
setting
the
XPCOM_MEM_LEAK_LOG
environment
variable
back
to
"
+
gEnvXPCOMMemLeakLog
)
;
gEnv
.
set
(
"
XPCOM_MEM_LEAK_LOG
"
gEnvXPCOMMemLeakLog
)
;
}
if
(
gEnvXPCOMDebugBreak
)
{
debugDump
(
"
setting
the
XPCOM_DEBUG_BREAK
environment
variable
back
to
"
+
gEnvXPCOMDebugBreak
)
;
gEnv
.
set
(
"
XPCOM_DEBUG_BREAK
"
gEnvXPCOMDebugBreak
)
;
}
else
if
(
gEnv
.
exists
(
"
XPCOM_DEBUG_BREAK
"
)
)
{
debugDump
(
"
clearing
the
XPCOM_DEBUG_BREAK
environment
variable
"
)
;
gEnv
.
set
(
"
XPCOM_DEBUG_BREAK
"
"
"
)
;
}
if
(
IS_UNIX
)
{
if
(
IS_MACOSX
)
{
if
(
gEnvDyldLibraryPath
)
{
debugDump
(
"
setting
DYLD_LIBRARY_PATH
environment
variable
value
"
+
"
back
to
"
+
gEnvDyldLibraryPath
)
;
gEnv
.
set
(
"
DYLD_LIBRARY_PATH
"
gEnvDyldLibraryPath
)
;
}
else
if
(
gEnvDyldLibraryPath
!
=
=
null
)
{
debugDump
(
"
removing
DYLD_LIBRARY_PATH
environment
variable
"
)
;
gEnv
.
set
(
"
DYLD_LIBRARY_PATH
"
"
"
)
;
}
}
else
if
(
gEnvLdLibraryPath
)
{
debugDump
(
"
setting
LD_LIBRARY_PATH
environment
variable
value
back
"
+
"
to
"
+
gEnvLdLibraryPath
)
;
gEnv
.
set
(
"
LD_LIBRARY_PATH
"
gEnvLdLibraryPath
)
;
}
else
if
(
gEnvLdLibraryPath
!
=
=
null
)
{
debugDump
(
"
removing
LD_LIBRARY_PATH
environment
variable
"
)
;
gEnv
.
set
(
"
LD_LIBRARY_PATH
"
"
"
)
;
}
}
if
(
IS_WIN
&
&
gAddedEnvXRENoWindowsCrashDialog
)
{
debugDump
(
"
removing
the
XRE_NO_WINDOWS_CRASH_DIALOG
environment
"
+
"
variable
"
)
;
gEnv
.
set
(
"
XRE_NO_WINDOWS_CRASH_DIALOG
"
"
"
)
;
}
debugDump
(
"
removing
MOZ_NO_SERVICE_FALLBACK
environment
variable
"
)
;
gEnv
.
set
(
"
MOZ_NO_SERVICE_FALLBACK
"
"
"
)
;
}
