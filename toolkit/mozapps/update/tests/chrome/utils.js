"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
DATA_URI_SPEC
=
"
chrome
:
/
/
mochitests
/
content
/
chrome
/
toolkit
/
mozapps
/
update
/
tests
/
chrome
/
"
;
Services
.
scriptloader
.
loadSubScript
(
DATA_URI_SPEC
+
"
testConstants
.
js
"
this
)
;
const
PAGEID_DUMMY
=
"
dummy
"
;
const
PAGEID_CHECKING
=
"
checking
"
;
const
PAGEID_NO_UPDATES_FOUND
=
"
noupdatesfound
"
;
const
PAGEID_MANUAL_UPDATE
=
"
manualUpdate
"
;
const
PAGEID_UNSUPPORTED
=
"
unsupported
"
;
const
PAGEID_FOUND_BASIC
=
"
updatesfoundbasic
"
;
const
PAGEID_DOWNLOADING
=
"
downloading
"
;
const
PAGEID_ERRORS
=
"
errors
"
;
const
PAGEID_ERROR_EXTRA
=
"
errorextra
"
;
const
PAGEID_ERROR_PATCHING
=
"
errorpatching
"
;
const
PAGEID_FINISHED
=
"
finished
"
;
const
PAGEID_FINISHED_BKGRD
=
"
finishedBackground
"
;
const
UPDATE_WINDOW_NAME
=
"
Update
:
Wizard
"
;
const
URL_HTTP_UPDATE_XML
=
URL_HTTP_UPDATE_SJS
;
const
URL_HTTPS_UPDATE_XML
=
"
https
:
/
/
example
.
com
"
+
URL_PATH_UPDATE_XML
;
const
URI_UPDATE_PROMPT_DIALOG
=
"
chrome
:
/
/
mozapps
/
content
/
update
/
updates
.
xul
"
;
const
LOG_FUNCTION
=
info
;
const
BIN_SUFFIX
=
(
AppConstants
.
platform
=
=
"
win
"
?
"
.
exe
"
:
"
"
)
;
const
FILE_UPDATER_BIN
=
"
updater
"
+
(
AppConstants
.
platform
=
=
"
macosx
"
?
"
.
app
"
:
BIN_SUFFIX
)
;
const
FILE_UPDATER_BIN_BAK
=
FILE_UPDATER_BIN
+
"
.
bak
"
;
var
gURLData
=
URL_HOST
+
"
/
"
+
REL_PATH_DATA
+
"
/
"
;
var
gTestTimeout
=
240000
;
var
gTimeoutTimer
;
const
CLOSE_WINDOW_TIMEOUT_MAXCOUNT
=
10
;
var
gCloseWindowTimeoutCounter
=
0
;
var
gAppUpdateAuto
;
var
gAppUpdateDisabled
;
var
gAppUpdateServiceEnabled
;
var
gAppUpdateStagingEnabled
;
var
gAppUpdateURLDefault
;
var
gTestCounter
=
-
1
;
var
gWin
;
var
gDocElem
;
var
gPrefToCheck
;
var
gUseTestUpdater
=
false
;
var
DEBUG_AUS_TEST
=
true
;
Services
.
scriptloader
.
loadSubScript
(
DATA_URI_SPEC
+
"
shared
.
js
"
this
)
;
this
.
__defineGetter__
(
"
gTest
"
function
(
)
{
return
TESTS
[
gTestCounter
]
;
}
)
;
this
.
__defineGetter__
(
"
gCallback
"
function
(
)
{
return
gTest
.
overrideCallback
?
gTest
.
overrideCallback
:
defaultCallback
;
}
)
;
const
gWindowObserver
=
{
observe
:
function
WO_observe
(
aSubject
aTopic
aData
)
{
let
win
=
aSubject
;
if
(
aTopic
=
=
"
domwindowclosed
"
)
{
if
(
win
.
location
!
=
URI_UPDATE_PROMPT_DIALOG
)
{
debugDump
(
"
domwindowclosed
event
for
window
not
being
tested
-
"
+
"
location
:
"
+
win
.
location
+
"
.
.
.
returning
early
"
)
;
return
;
}
try
{
finishTest
(
)
;
}
catch
(
e
)
{
finishTestDefault
(
)
;
}
return
;
}
win
.
addEventListener
(
"
load
"
function
(
)
{
if
(
win
.
location
!
=
URI_UPDATE_PROMPT_DIALOG
)
{
debugDump
(
"
load
event
for
window
not
being
tested
-
location
:
"
+
win
.
location
+
"
.
.
.
returning
early
"
)
;
return
;
}
let
pageid
=
win
.
document
.
documentElement
.
currentPage
.
pageid
;
if
(
pageid
!
=
PAGEID_DUMMY
)
{
ok
(
false
"
Unexpected
load
event
-
pageid
got
:
"
+
pageid
+
"
expected
:
"
+
PAGEID_DUMMY
+
"
.
.
.
returning
early
"
)
;
return
;
}
gWin
=
win
;
gDocElem
=
gWin
.
document
.
documentElement
;
gDocElem
.
addEventListener
(
"
pageshow
"
onPageShowDefault
)
;
}
{
once
:
true
}
)
;
}
}
;
function
runTestDefault
(
)
{
debugDump
(
"
entering
"
)
;
SimpleTest
.
waitForExplicitFinish
(
)
;
runTestDefaultWaitForWindowClosed
(
)
;
}
function
runTestDefaultWaitForWindowClosed
(
)
{
gCloseWindowTimeoutCounter
+
+
;
if
(
gCloseWindowTimeoutCounter
>
CLOSE_WINDOW_TIMEOUT_MAXCOUNT
)
{
try
{
finishTest
(
)
;
}
catch
(
e
)
{
finishTestDefault
(
)
;
}
return
;
}
if
(
closeUpdateWindow
(
)
)
{
SimpleTest
.
executeSoon
(
runTestDefaultWaitForWindowClosed
)
;
}
else
{
Services
.
ww
.
registerNotification
(
gWindowObserver
)
;
gCloseWindowTimeoutCounter
=
0
;
setupPrefs
(
)
;
gEnv
.
set
(
"
MOZ_TEST_SKIP_UPDATE_STAGE
"
"
1
"
)
;
removeUpdateDirsAndFiles
(
)
;
setupTimer
(
gTestTimeout
)
;
SimpleTest
.
executeSoon
(
setupTestUpdater
)
;
}
}
function
finishTestDefault
(
)
{
debugDump
(
"
entering
"
)
;
if
(
gTimeoutTimer
)
{
gTimeoutTimer
.
cancel
(
)
;
gTimeoutTimer
=
null
;
}
if
(
gChannel
)
{
debugDump
(
"
channel
=
"
+
gChannel
)
;
gChannel
=
null
;
gPrefRoot
.
removeObserver
(
PREF_APP_UPDATE_CHANNEL
observer
)
;
}
verifyTestsRan
(
)
;
resetPrefs
(
)
;
gEnv
.
set
(
"
MOZ_TEST_SKIP_UPDATE_STAGE
"
"
"
)
;
resetFiles
(
)
;
removeUpdateDirsAndFiles
(
)
;
reloadUpdateManagerData
(
true
)
;
Services
.
ww
.
unregisterNotification
(
gWindowObserver
)
;
if
(
gDocElem
)
{
gDocElem
.
removeEventListener
(
"
pageshow
"
onPageShowDefault
)
;
}
finishTestRestoreUpdaterBackup
(
)
;
}
function
finishTestTimeout
(
aTimer
)
{
ok
(
false
"
Test
timed
out
.
Maximum
time
allowed
is
"
+
(
gTestTimeout
/
1000
)
+
"
seconds
"
)
;
try
{
finishTest
(
)
;
}
catch
(
e
)
{
finishTestDefault
(
)
;
}
}
function
finishTestRestoreUpdaterBackup
(
)
{
if
(
gUseTestUpdater
)
{
try
{
restoreUpdaterBackup
(
)
;
}
catch
(
e
)
{
logTestInfo
(
"
Attempt
to
restore
the
backed
up
updater
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
SimpleTest
.
executeSoon
(
finishTestRestoreUpdaterBackup
)
;
return
;
}
}
finishTestDefaultWaitForWindowClosed
(
)
;
}
function
finishTestDefaultWaitForWindowClosed
(
)
{
gCloseWindowTimeoutCounter
+
+
;
if
(
gCloseWindowTimeoutCounter
>
CLOSE_WINDOW_TIMEOUT_MAXCOUNT
)
{
SimpleTest
.
requestCompleteLog
(
)
;
SimpleTest
.
finish
(
)
;
return
;
}
if
(
closeUpdateWindow
(
)
)
{
SimpleTest
.
executeSoon
(
finishTestDefaultWaitForWindowClosed
)
;
}
else
{
SimpleTest
.
finish
(
)
;
}
}
function
onPageShowDefault
(
aEvent
)
{
if
(
!
gTimeoutTimer
)
{
debugDump
(
"
gTimeoutTimer
is
null
.
.
.
returning
early
"
)
;
return
;
}
if
(
aEvent
.
originalTarget
.
nodeName
!
=
"
wizardpage
"
)
{
debugDump
(
"
only
handles
events
with
an
originalTarget
nodeName
of
"
+
"
|
wizardpage
|
.
aEvent
.
originalTarget
.
nodeName
=
"
+
aEvent
.
originalTarget
.
nodeName
+
"
.
.
.
returning
early
"
)
;
return
;
}
gTestCounter
+
+
;
gCallback
(
aEvent
)
;
}
function
defaultCallback
(
aEvent
)
{
if
(
!
gTimeoutTimer
)
{
debugDump
(
"
gTimeoutTimer
is
null
.
.
.
returning
early
"
)
;
return
;
}
debugDump
(
"
entering
-
TESTS
[
"
+
gTestCounter
+
"
]
pageid
:
"
+
gTest
.
pageid
+
"
aEvent
.
originalTarget
.
nodeName
:
"
+
aEvent
.
originalTarget
.
nodeName
)
;
if
(
gTest
&
&
gTest
.
extraStartFunction
)
{
debugDump
(
"
calling
extraStartFunction
"
+
gTest
.
extraStartFunction
.
name
)
;
if
(
gTest
.
extraStartFunction
(
aEvent
)
)
{
debugDump
(
"
extraStartFunction
early
return
"
)
;
return
;
}
}
is
(
gDocElem
.
currentPage
.
pageid
gTest
.
pageid
"
Checking
currentPage
.
pageid
equals
"
+
gTest
.
pageid
+
"
in
pageshow
"
)
;
if
(
gTest
.
extraCheckFunction
)
{
debugDump
(
"
calling
extraCheckFunction
"
+
gTest
.
extraCheckFunction
.
name
)
;
gTest
.
extraCheckFunction
(
)
;
}
SimpleTest
.
executeSoon
(
delayedDefaultCallback
)
;
}
function
delayedDefaultCallback
(
)
{
if
(
!
gTimeoutTimer
)
{
debugDump
(
"
gTimeoutTimer
is
null
.
.
.
returning
early
"
)
;
return
;
}
if
(
!
gTest
)
{
debugDump
(
"
gTest
is
null
.
.
.
returning
early
"
)
;
return
;
}
debugDump
(
"
entering
-
TESTS
[
"
+
gTestCounter
+
"
]
pageid
:
"
+
gTest
.
pageid
)
;
is
(
gDocElem
.
currentPage
.
pageid
gTest
.
pageid
"
Checking
currentPage
.
pageid
equals
"
+
gTest
.
pageid
+
"
after
"
+
"
executeSoon
"
)
;
checkButtonStates
(
)
;
if
(
gTest
.
extraDelayedCheckFunction
)
{
debugDump
(
"
calling
extraDelayedCheckFunction
"
+
gTest
.
extraDelayedCheckFunction
.
name
)
;
gTest
.
extraDelayedCheckFunction
(
)
;
}
gTest
.
ranTest
=
true
;
if
(
gTest
.
buttonClick
)
{
debugDump
(
"
clicking
"
+
gTest
.
buttonClick
+
"
button
"
)
;
if
(
gTest
.
extraDelayedFinishFunction
)
{
throw
(
"
Tests
cannot
have
a
buttonClick
and
an
extraDelayedFinishFunction
property
"
)
;
}
gDocElem
.
getButton
(
gTest
.
buttonClick
)
.
click
(
)
;
}
else
if
(
gTest
.
extraDelayedFinishFunction
)
{
debugDump
(
"
calling
extraDelayedFinishFunction
"
+
gTest
.
extraDelayedFinishFunction
.
name
)
;
gTest
.
extraDelayedFinishFunction
(
)
;
}
}
function
getContinueFile
(
)
{
let
continueFile
=
Services
.
dirsvc
.
get
(
"
CurWorkD
"
Ci
.
nsIFile
)
;
let
continuePath
=
REL_PATH_DATA
+
"
continue
"
;
let
continuePathParts
=
continuePath
.
split
(
"
/
"
)
;
for
(
let
i
=
0
;
i
<
continuePathParts
.
length
;
+
+
i
)
{
continueFile
.
append
(
continuePathParts
[
i
]
)
;
}
return
continueFile
;
}
function
createContinueFile
(
)
{
debugDump
(
"
creating
'
continue
'
file
for
slow
mar
downloads
"
)
;
writeFile
(
getContinueFile
(
)
"
"
)
;
}
function
removeContinueFile
(
)
{
let
continueFile
=
getContinueFile
(
)
;
if
(
continueFile
.
exists
(
)
)
{
debugDump
(
"
removing
'
continue
'
file
for
slow
mar
downloads
"
)
;
continueFile
.
remove
(
false
)
;
}
}
function
checkButtonStates
(
)
{
debugDump
(
"
entering
-
TESTS
[
"
+
gTestCounter
+
"
]
pageid
:
"
+
gTest
.
pageid
)
;
const
buttonNames
=
[
"
extra1
"
"
extra2
"
"
back
"
"
next
"
"
finish
"
"
cancel
"
]
;
let
buttonStates
=
getExpectedButtonStates
(
)
;
buttonNames
.
forEach
(
function
(
aButtonName
)
{
let
button
=
gDocElem
.
getButton
(
aButtonName
)
;
let
hasHidden
=
aButtonName
in
buttonStates
&
&
"
hidden
"
in
buttonStates
[
aButtonName
]
;
let
hidden
=
hasHidden
?
buttonStates
[
aButtonName
]
.
hidden
:
true
;
let
hasDisabled
=
aButtonName
in
buttonStates
&
&
"
disabled
"
in
buttonStates
[
aButtonName
]
;
let
disabled
=
hasDisabled
?
buttonStates
[
aButtonName
]
.
disabled
:
true
;
is
(
button
.
hidden
hidden
"
Checking
"
+
aButtonName
+
"
button
"
+
"
hidden
attribute
value
equals
"
+
(
hidden
?
"
true
"
:
"
false
"
)
)
;
is
(
button
.
disabled
disabled
"
Checking
"
+
aButtonName
+
"
button
"
+
"
disabled
attribute
value
equals
"
+
(
disabled
?
"
true
"
:
"
false
"
)
)
;
}
)
;
}
function
getExpectedButtonStates
(
)
{
if
(
gTest
.
buttonStates
)
{
return
gTest
.
buttonStates
;
}
switch
(
gTest
.
pageid
)
{
case
PAGEID_CHECKING
:
return
{
cancel
:
{
disabled
:
false
hidden
:
false
}
}
;
case
PAGEID_FOUND_BASIC
:
if
(
gTest
.
neverButton
)
{
return
{
extra1
:
{
disabled
:
false
hidden
:
false
}
extra2
:
{
disabled
:
false
hidden
:
false
}
next
:
{
disabled
:
false
hidden
:
false
}
}
;
}
return
{
extra1
:
{
disabled
:
false
hidden
:
false
}
next
:
{
disabled
:
false
hidden
:
false
}
}
;
case
PAGEID_DOWNLOADING
:
return
{
extra1
:
{
disabled
:
false
hidden
:
false
}
}
;
case
PAGEID_NO_UPDATES_FOUND
:
case
PAGEID_MANUAL_UPDATE
:
case
PAGEID_UNSUPPORTED
:
case
PAGEID_ERRORS
:
case
PAGEID_ERROR_EXTRA
:
return
{
finish
:
{
disabled
:
false
hidden
:
false
}
}
;
case
PAGEID_ERROR_PATCHING
:
return
{
next
:
{
disabled
:
false
hidden
:
false
}
}
;
case
PAGEID_FINISHED
:
case
PAGEID_FINISHED_BKGRD
:
return
{
extra1
:
{
disabled
:
false
hidden
:
false
}
finish
:
{
disabled
:
false
hidden
:
false
}
}
;
}
return
null
;
}
function
checkPrefHasUserValue
(
aPrefHasValue
)
{
let
prefHasUserValue
=
aPrefHasValue
=
=
=
undefined
?
gTest
.
prefHasUserValue
:
aPrefHasValue
;
is
(
Services
.
prefs
.
prefHasUserValue
(
gPrefToCheck
)
prefHasUserValue
"
Checking
prefHasUserValue
for
preference
"
+
gPrefToCheck
+
"
equals
"
+
(
prefHasUserValue
?
"
true
"
:
"
false
"
)
)
;
}
function
checkErrorExtraPage
(
aShouldBeHidden
)
{
let
shouldBeHidden
=
aShouldBeHidden
=
=
=
undefined
?
gTest
.
shouldBeHidden
:
aShouldBeHidden
;
is
(
gWin
.
document
.
getElementById
(
"
errorExtraLinkLabel
"
)
.
hidden
shouldBeHidden
"
Checking
errorExtraLinkLabel
hidden
attribute
equals
"
+
(
shouldBeHidden
?
"
true
"
:
"
false
"
)
)
;
is
(
gWin
.
document
.
getElementById
(
gTest
.
displayedTextElem
)
.
hidden
false
"
Checking
"
+
gTest
.
displayedTextElem
+
"
should
not
be
hidden
"
)
;
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_BACKGROUNDERRORS
)
"
Preference
"
+
PREF_APP_UPDATE_BACKGROUNDERRORS
+
"
should
not
have
a
"
+
"
user
value
"
)
;
}
function
getVersionParams
(
aAppVersion
)
{
let
appInfo
=
Services
.
appinfo
;
return
"
&
appVersion
=
"
+
(
aAppVersion
?
aAppVersion
:
appInfo
.
version
)
;
}
function
verifyTestsRan
(
)
{
debugDump
(
"
entering
"
)
;
if
(
!
TESTS
)
{
return
;
}
gTestCounter
=
-
1
;
for
(
let
i
=
0
;
i
<
TESTS
.
length
;
+
+
i
)
{
gTestCounter
+
+
;
let
test
=
TESTS
[
i
]
;
let
msg
=
"
Checking
if
TESTS
[
"
+
i
+
"
]
test
was
performed
.
.
.
"
+
"
callback
function
name
=
"
+
gCallback
.
name
+
"
"
+
"
pageid
=
"
+
test
.
pageid
;
ok
(
test
.
ranTest
msg
)
;
}
}
function
setupTestUpdater
(
)
{
if
(
!
gUseTestUpdater
)
{
runTest
(
)
;
return
;
}
try
{
restoreUpdaterBackup
(
)
;
}
catch
(
e
)
{
logTestInfo
(
"
Attempt
to
restore
the
backed
up
updater
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
SimpleTest
.
executeSoon
(
setupTestUpdater
)
;
return
;
}
moveRealUpdater
(
)
;
}
function
moveRealUpdater
(
)
{
try
{
let
greBinDir
=
getGREBinDir
(
)
;
let
updater
=
greBinDir
.
clone
(
)
;
updater
.
append
(
FILE_UPDATER_BIN
)
;
updater
.
moveTo
(
greBinDir
FILE_UPDATER_BIN_BAK
)
;
let
greDir
=
getGREDir
(
)
;
let
updateSettingsIni
=
greDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI
)
;
if
(
updateSettingsIni
.
exists
(
)
)
{
updateSettingsIni
.
moveTo
(
greDir
FILE_UPDATE_SETTINGS_INI_BAK
)
;
}
let
precomplete
=
greDir
.
clone
(
)
;
precomplete
.
append
(
FILE_PRECOMPLETE
)
;
if
(
precomplete
.
exists
(
)
)
{
precomplete
.
moveTo
(
greDir
FILE_PRECOMPLETE_BAK
)
;
}
}
catch
(
e
)
{
logTestInfo
(
"
Attempt
to
move
the
real
updater
out
of
the
way
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
SimpleTest
.
executeSoon
(
moveRealUpdater
)
;
return
;
}
copyTestUpdater
(
)
;
}
function
copyTestUpdater
(
)
{
try
{
let
greBinDir
=
getGREBinDir
(
)
;
let
testUpdaterDir
=
Services
.
dirsvc
.
get
(
"
CurWorkD
"
Ci
.
nsIFile
)
;
let
relPath
=
REL_PATH_DATA
;
let
pathParts
=
relPath
.
split
(
"
/
"
)
;
for
(
let
i
=
0
;
i
<
pathParts
.
length
;
+
+
i
)
{
testUpdaterDir
.
append
(
pathParts
[
i
]
)
;
}
let
testUpdater
=
testUpdaterDir
.
clone
(
)
;
testUpdater
.
append
(
FILE_UPDATER_BIN
)
;
testUpdater
.
copyToFollowingLinks
(
greBinDir
FILE_UPDATER_BIN
)
;
let
greDir
=
getGREDir
(
)
;
let
updateSettingsIni
=
greDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI
)
;
writeFile
(
updateSettingsIni
UPDATE_SETTINGS_CONTENTS
)
;
let
precomplete
=
greDir
.
clone
(
)
;
precomplete
.
append
(
FILE_PRECOMPLETE
)
;
writeFile
(
precomplete
PRECOMPLETE_CONTENTS
)
;
}
catch
(
e
)
{
logTestInfo
(
"
Attempt
to
copy
the
test
updater
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
SimpleTest
.
executeSoon
(
copyTestUpdater
)
;
return
;
}
runTest
(
)
;
}
function
restoreUpdaterBackup
(
)
{
let
greBinDir
=
getGREBinDir
(
)
;
let
updater
=
greBinDir
.
clone
(
)
;
let
updaterBackup
=
greBinDir
.
clone
(
)
;
updater
.
append
(
FILE_UPDATER_BIN
)
;
updaterBackup
.
append
(
FILE_UPDATER_BIN_BAK
)
;
if
(
updaterBackup
.
exists
(
)
)
{
if
(
updater
.
exists
(
)
)
{
updater
.
remove
(
true
)
;
}
updaterBackup
.
moveTo
(
greBinDir
FILE_UPDATER_BIN
)
;
}
let
greDir
=
getGREDir
(
)
;
let
updateSettingsIniBackup
=
greDir
.
clone
(
)
;
updateSettingsIniBackup
.
append
(
FILE_UPDATE_SETTINGS_INI_BAK
)
;
if
(
updateSettingsIniBackup
.
exists
(
)
)
{
let
updateSettingsIni
=
greDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI
)
;
if
(
updateSettingsIni
.
exists
(
)
)
{
updateSettingsIni
.
remove
(
false
)
;
}
updateSettingsIniBackup
.
moveTo
(
greDir
FILE_UPDATE_SETTINGS_INI
)
;
}
let
precomplete
=
greDir
.
clone
(
)
;
let
precompleteBackup
=
greDir
.
clone
(
)
;
precomplete
.
append
(
FILE_PRECOMPLETE
)
;
precompleteBackup
.
append
(
FILE_PRECOMPLETE_BAK
)
;
if
(
precompleteBackup
.
exists
(
)
)
{
if
(
precomplete
.
exists
(
)
)
{
precomplete
.
remove
(
false
)
;
}
precompleteBackup
.
moveTo
(
greDir
FILE_PRECOMPLETE
)
;
}
else
if
(
precomplete
.
exists
(
)
)
{
if
(
readFile
(
precomplete
)
=
=
PRECOMPLETE_CONTENTS
)
{
precomplete
.
remove
(
false
)
;
}
}
}
function
setupPrefs
(
)
{
if
(
DEBUG_AUS_TEST
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_LOG
true
)
;
}
let
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
-
60
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_LASTUPDATETIME
now
)
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_INTERVAL
43200
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_DISABLEDFORTESTING
)
)
{
gAppUpdateDisabled
=
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_DISABLEDFORTESTING
)
;
}
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_DISABLEDFORTESTING
false
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
configFile
=
getUpdateConfigFile
(
)
;
if
(
configFile
.
exists
(
)
)
{
let
configData
=
JSON
.
parse
(
readFileBytes
(
configFile
)
)
;
gAppUpdateAuto
=
!
!
configData
[
CONFIG_APP_UPDATE_AUTO
]
;
}
}
else
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_AUTO
)
)
{
gAppUpdateAuto
=
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_AUTO
)
;
}
if
(
gAppUpdateAuto
!
=
=
true
)
{
setAppUpdateAutoSync
(
true
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_SERVICE_ENABLED
)
)
{
gAppUpdateServiceEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_SERVICE_ENABLED
)
;
}
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_SERVICE_ENABLED
false
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_STAGING_ENABLED
)
)
{
gAppUpdateStagingEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
)
;
}
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
false
)
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_IDLETIME
0
)
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_PROMPTWAITTIME
0
)
;
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_SILENT
false
)
;
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_DOORHANGER
false
)
;
}
function
resetFiles
(
)
{
let
updatedDir
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
updatedDir
=
getUpdatesDir
(
)
;
updatedDir
.
append
(
DIR_PATCH
)
;
}
else
{
updatedDir
=
getAppBaseDir
(
)
;
}
updatedDir
.
append
(
DIR_UPDATED
)
;
if
(
updatedDir
.
exists
(
)
)
{
try
{
removeDirRecursive
(
updatedDir
)
;
}
catch
(
e
)
{
logTestInfo
(
"
Unable
to
remove
directory
.
Path
:
"
+
updatedDir
.
path
+
"
Exception
:
"
+
e
)
;
}
}
}
function
resetPrefs
(
)
{
if
(
gAppUpdateURLDefault
)
{
gDefaultPrefBranch
.
setCharPref
(
PREF_APP_UPDATE_URL
gAppUpdateURLDefault
)
;
}
if
(
gAppUpdateDisabled
!
=
=
undefined
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_DISABLEDFORTESTING
gAppUpdateDisabled
)
;
}
else
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_DISABLEDFORTESTING
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_DISABLEDFORTESTING
)
;
}
setAppUpdateAutoSync
(
gAppUpdateAuto
)
;
if
(
gAppUpdateServiceEnabled
!
=
=
undefined
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_SERVICE_ENABLED
gAppUpdateServiceEnabled
)
;
}
else
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_SERVICE_ENABLED
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_SERVICE_ENABLED
)
;
}
if
(
gAppUpdateStagingEnabled
!
=
=
undefined
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
gAppUpdateStagingEnabled
)
;
}
else
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_STAGING_ENABLED
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_STAGING_ENABLED
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_IDLETIME
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_IDLETIME
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_PROMPTWAITTIME
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_PROMPTWAITTIME
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_URL_DETAILS
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_URL_DETAILS
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_NOTIFIEDUNSUPPORTED
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_NOTIFIEDUNSUPPORTED
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_LOG
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_LOG
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_SILENT
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_SILENT
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_BACKGROUNDERRORS
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_BACKGROUNDERRORS
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_BACKGROUNDMAXERRORS
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_BACKGROUNDMAXERRORS
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_DOORHANGER
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_DOORHANGER
)
;
}
}
function
setupTimer
(
aTestTimeout
)
{
gTestTimeout
=
aTestTimeout
;
if
(
gTimeoutTimer
)
{
gTimeoutTimer
.
cancel
(
)
;
gTimeoutTimer
=
null
;
}
gTimeoutTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
gTimeoutTimer
.
initWithCallback
(
finishTestTimeout
gTestTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
function
closeUpdateWindow
(
)
{
let
updateWindow
=
getUpdateWindow
(
)
;
if
(
!
updateWindow
)
{
return
false
;
}
ok
(
false
"
Found
an
existing
Update
Window
from
the
current
or
a
previous
"
+
"
test
.
.
.
attempting
to
close
it
.
"
)
;
updateWindow
.
close
(
)
;
return
true
;
}
function
getUpdateWindow
(
)
{
return
Services
.
wm
.
getMostRecentWindow
(
UPDATE_WINDOW_NAME
)
;
}
const
errorsPrefObserver
=
{
observedPref
:
null
maxErrorPref
:
null
init
(
aObservePref
aMaxErrorPref
aMaxErrorCount
)
{
this
.
observedPref
=
aObservePref
;
this
.
maxErrorPref
=
aMaxErrorPref
;
let
maxErrors
=
aMaxErrorCount
?
aMaxErrorCount
:
2
;
Services
.
prefs
.
setIntPref
(
aMaxErrorPref
maxErrors
)
;
Services
.
prefs
.
addObserver
(
aObservePref
this
)
;
}
observe
:
function
XPI_observe
(
aSubject
aTopic
aData
)
{
if
(
aData
=
=
this
.
observedPref
)
{
let
errCount
=
Services
.
prefs
.
getIntPref
(
this
.
observedPref
)
;
let
errMax
=
Services
.
prefs
.
getIntPref
(
this
.
maxErrorPref
)
;
if
(
errCount
>
=
errMax
)
{
debugDump
(
"
removing
pref
observer
"
)
;
Services
.
prefs
.
removeObserver
(
this
.
observedPref
this
)
;
}
else
{
debugDump
(
"
notifying
AUS
"
)
;
SimpleTest
.
executeSoon
(
function
(
)
{
gAUS
.
notify
(
null
)
;
}
)
;
}
}
}
}
;
