"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
AppMenuNotifications
:
"
resource
:
/
/
gre
/
modules
/
AppMenuNotifications
.
sys
.
mjs
"
DownloadUtils
:
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
sys
.
mjs
"
UpdateListener
:
"
resource
:
/
/
gre
/
modules
/
UpdateListener
.
sys
.
mjs
"
}
)
;
const
{
XPIExports
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIExports
.
sys
.
mjs
"
)
;
const
BIN_SUFFIX
=
AppConstants
.
platform
=
=
"
win
"
?
"
.
exe
"
:
"
"
;
const
FILE_UPDATER_BIN
=
"
updater
"
+
(
AppConstants
.
platform
=
=
"
macosx
"
?
"
.
app
"
:
BIN_SUFFIX
)
;
const
FILE_UPDATER_BIN_BAK
=
FILE_UPDATER_BIN
+
"
.
bak
"
;
const
LOG_FUNCTION
=
info
;
const
MAX_UPDATE_COPY_ATTEMPTS
=
10
;
const
DATA_URI_SPEC
=
"
chrome
:
/
/
mochitests
/
content
/
browser
/
toolkit
/
mozapps
/
update
/
tests
/
browser
/
"
;
Services
.
scriptloader
.
loadSubScript
(
DATA_URI_SPEC
+
"
testConstants
.
js
"
this
)
;
var
gURLData
=
URL_HOST
+
"
/
"
+
REL_PATH_DATA
;
const
URL_MANUAL_UPDATE
=
gURLData
+
"
downloadPage
.
html
"
;
const
gBadSizeResult
=
Cr
.
NS_ERROR_UNEXPECTED
.
toString
(
)
;
Services
.
scriptloader
.
loadSubScript
(
DATA_URI_SPEC
+
"
shared
.
js
"
this
)
;
let
gOriginalUpdateAutoValue
=
null
;
const
gDetailsURL
=
URL_HOST
+
"
/
"
;
gDebugTest
=
false
;
requestLongerTimeout
(
10
)
;
add_setup
(
async
function
setupTestCommon
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_BADGEWAITTIME
1800
]
[
PREF_APP_UPDATE_DOWNLOAD_ATTEMPTS
0
]
[
PREF_APP_UPDATE_DOWNLOAD_MAXATTEMPTS
2
]
[
PREF_APP_UPDATE_LOG
gDebugTest
]
[
PREF_APP_UPDATE_PROMPTWAITTIME
3600
]
[
PREF_APP_UPDATE_SERVICE_ENABLED
false
]
]
}
)
;
let
exePath
=
Services
.
dirsvc
.
get
(
XRE_EXECUTABLE_FILE
Ci
.
nsIFile
)
;
let
dirProvider
=
{
getFile
:
function
AGP_DP_getFile
(
aProp
aPersistent
)
{
aPersistent
.
value
=
false
;
switch
(
aProp
)
{
case
XRE_EXECUTABLE_FILE
:
exePath
.
append
(
"
browser
-
test
"
)
;
return
exePath
;
}
return
null
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIDirectoryServiceProvider
"
]
)
}
;
let
ds
=
Services
.
dirsvc
.
QueryInterface
(
Ci
.
nsIDirectoryService
)
;
ds
.
QueryInterface
(
Ci
.
nsIProperties
)
.
undefine
(
XRE_EXECUTABLE_FILE
)
;
ds
.
registerProvider
(
dirProvider
)
;
let
syncManager
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
sync
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateSyncManager
)
;
syncManager
.
resetLock
(
)
;
ds
.
unregisterProvider
(
dirProvider
)
;
setUpdateTimerPrefs
(
)
;
await
reloadUpdateManagerData
(
true
)
;
removeUpdateFiles
(
true
)
;
UpdateListener
.
reset
(
)
;
AppMenuNotifications
.
removeNotification
(
/
.
*
/
)
;
await
setAppUpdateAutoEnabledHelper
(
true
)
;
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
AppMenuNotifications
.
removeNotification
(
/
.
*
/
)
;
Services
.
env
.
set
(
"
MOZ_TEST_SKIP_UPDATE_STAGE
"
"
"
)
;
Services
.
env
.
set
(
"
MOZ_TEST_SLOW_SKIP_UPDATE_STAGE
"
"
"
)
;
Services
.
env
.
set
(
"
MOZ_TEST_STAGING_ERROR
"
"
"
)
;
UpdateListener
.
reset
(
)
;
AppMenuNotifications
.
removeNotification
(
/
.
*
/
)
;
await
reloadUpdateManagerData
(
true
)
;
removeUpdateFiles
(
true
)
;
await
finishTestRestoreUpdaterBackup
(
)
;
let
syncManager
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
sync
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateSyncManager
)
;
syncManager
.
resetLock
(
)
;
}
)
;
function
mockLangpackInstall
(
)
{
let
original
=
XPIExports
.
XPIInstall
.
stageLangpacksForAppUpdate
;
registerCleanupFunction
(
(
)
=
>
{
XPIExports
.
XPIInstall
.
stageLangpacksForAppUpdate
=
original
;
}
)
;
let
stagingCall
=
Promise
.
withResolvers
(
)
;
XPIExports
.
XPIInstall
.
stageLangpacksForAppUpdate
=
(
appVersion
platformVersion
)
=
>
{
let
result
=
Promise
.
withResolvers
(
)
;
stagingCall
.
resolve
(
{
appVersion
platformVersion
resolve
:
result
.
resolve
reject
:
result
.
reject
}
)
;
return
result
.
promise
;
}
;
return
stagingCall
.
promise
;
}
function
lockWriteTestFile
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
throw
new
Error
(
"
Windows
only
test
function
called
"
)
;
}
let
file
=
getUpdateDirFile
(
FILE_UPDATE_TEST
)
.
QueryInterface
(
Ci
.
nsILocalFileWin
)
;
if
(
file
.
exists
(
)
)
{
file
.
readOnly
=
false
;
file
.
remove
(
false
)
;
}
file
.
create
(
file
.
NORMAL_FILE_TYPE
0o444
)
;
file
.
readOnly
=
true
;
registerCleanupFunction
(
(
)
=
>
{
file
.
readOnly
=
false
;
file
.
remove
(
false
)
;
}
)
;
}
function
setOtherInstanceHandlingUpdates
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
throw
new
Error
(
"
Windows
only
test
function
called
"
)
;
}
gAUS
.
observe
(
null
"
test
-
close
-
handle
-
update
-
mutex
"
"
"
)
;
let
handle
=
createMutex
(
getPerInstallationMutexName
(
)
)
;
registerCleanupFunction
(
(
)
=
>
{
closeHandle
(
handle
)
;
}
)
;
}
function
getVersionParams
(
aAppVersion
)
{
let
appInfo
=
Services
.
appinfo
;
return
"
&
appVersion
=
"
+
(
aAppVersion
?
aAppVersion
:
appInfo
.
version
)
;
}
function
setUpdateTimerPrefs
(
)
{
let
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
-
60
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_LASTUPDATETIME
now
)
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_INTERVAL
43200
)
;
}
async
function
setAppUpdateAutoEnabledHelper
(
enabled
)
{
if
(
gOriginalUpdateAutoValue
=
=
null
)
{
gOriginalUpdateAutoValue
=
await
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
gOriginalUpdateAutoValue
)
;
}
)
;
}
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
enabled
)
;
}
function
getNotificationButton
(
win
notificationId
button
)
{
let
notification
=
win
.
document
.
getElementById
(
appMenu
-
{
notificationId
}
-
notification
)
;
ok
(
!
notification
.
hidden
{
notificationId
}
notification
is
showing
)
;
if
(
typeof
button
=
=
=
"
function
"
)
{
return
button
(
notification
)
;
}
return
notification
[
button
]
;
}
function
setupTestUpdater
(
)
{
return
(
async
function
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
)
)
{
try
{
restoreUpdaterBackup
(
)
;
}
catch
(
e
)
{
logTestInfo
(
"
Attempt
to
restore
the
backed
up
updater
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
await
TestUtils
.
waitForTick
(
)
;
await
setupTestUpdater
(
)
;
return
;
}
await
moveRealUpdater
(
)
;
}
}
)
(
)
;
}
function
moveRealUpdater
(
)
{
return
(
async
function
(
)
{
try
{
let
greBinDir
=
getGREBinDir
(
)
;
let
updater
=
greBinDir
.
clone
(
)
;
updater
.
append
(
FILE_UPDATER_BIN
)
;
updater
.
moveTo
(
greBinDir
FILE_UPDATER_BIN_BAK
)
;
let
greDir
=
getGREDir
(
)
;
let
updateSettingsIni
=
greDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI
)
;
if
(
updateSettingsIni
.
exists
(
)
)
{
updateSettingsIni
.
moveTo
(
greDir
FILE_UPDATE_SETTINGS_INI_BAK
)
;
}
let
precomplete
=
greDir
.
clone
(
)
;
precomplete
.
append
(
FILE_PRECOMPLETE
)
;
if
(
precomplete
.
exists
(
)
)
{
precomplete
.
moveTo
(
greDir
FILE_PRECOMPLETE_BAK
)
;
}
}
catch
(
e
)
{
logTestInfo
(
"
Attempt
to
move
the
real
updater
out
of
the
way
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
await
TestUtils
.
waitForTick
(
)
;
await
moveRealUpdater
(
)
;
return
;
}
await
copyTestUpdater
(
)
;
}
)
(
)
;
}
function
copyTestUpdater
(
attempt
=
0
)
{
return
(
async
function
(
)
{
try
{
let
greBinDir
=
getGREBinDir
(
)
;
let
testUpdaterDir
=
Services
.
dirsvc
.
get
(
"
CurWorkD
"
Ci
.
nsIFile
)
;
let
relPath
=
REL_PATH_DATA
;
let
pathParts
=
relPath
.
split
(
"
/
"
)
;
for
(
let
i
=
0
;
i
<
pathParts
.
length
;
+
+
i
)
{
testUpdaterDir
.
append
(
pathParts
[
i
]
)
;
}
let
testUpdater
=
testUpdaterDir
.
clone
(
)
;
testUpdater
.
append
(
FILE_UPDATER_BIN
)
;
testUpdater
.
copyToFollowingLinks
(
greBinDir
FILE_UPDATER_BIN
)
;
let
greDir
=
getGREDir
(
)
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
let
updateSettingsIni
=
greDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI
)
;
writeFile
(
updateSettingsIni
UPDATE_SETTINGS_CONTENTS
)
;
}
let
precomplete
=
greDir
.
clone
(
)
;
precomplete
.
append
(
FILE_PRECOMPLETE
)
;
writeFile
(
precomplete
PRECOMPLETE_CONTENTS
)
;
}
catch
(
e
)
{
if
(
attempt
<
MAX_UPDATE_COPY_ATTEMPTS
)
{
logTestInfo
(
"
Attempt
to
copy
the
test
updater
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
await
TestUtils
.
waitForTick
(
)
;
await
copyTestUpdater
(
attempt
+
+
)
;
}
}
}
)
(
)
;
}
function
restoreUpdaterBackup
(
)
{
let
greBinDir
=
getGREBinDir
(
)
;
let
updater
=
greBinDir
.
clone
(
)
;
let
updaterBackup
=
greBinDir
.
clone
(
)
;
updater
.
append
(
FILE_UPDATER_BIN
)
;
updaterBackup
.
append
(
FILE_UPDATER_BIN_BAK
)
;
if
(
updaterBackup
.
exists
(
)
)
{
if
(
updater
.
exists
(
)
)
{
updater
.
remove
(
true
)
;
}
updaterBackup
.
moveTo
(
greBinDir
FILE_UPDATER_BIN
)
;
}
let
greDir
=
getGREDir
(
)
;
let
updateSettingsIniBackup
=
greDir
.
clone
(
)
;
updateSettingsIniBackup
.
append
(
FILE_UPDATE_SETTINGS_INI_BAK
)
;
if
(
updateSettingsIniBackup
.
exists
(
)
)
{
let
updateSettingsIni
=
greDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI
)
;
if
(
updateSettingsIni
.
exists
(
)
)
{
updateSettingsIni
.
remove
(
false
)
;
}
updateSettingsIniBackup
.
moveTo
(
greDir
FILE_UPDATE_SETTINGS_INI
)
;
}
let
precomplete
=
greDir
.
clone
(
)
;
let
precompleteBackup
=
greDir
.
clone
(
)
;
precomplete
.
append
(
FILE_PRECOMPLETE
)
;
precompleteBackup
.
append
(
FILE_PRECOMPLETE_BAK
)
;
if
(
precompleteBackup
.
exists
(
)
)
{
if
(
precomplete
.
exists
(
)
)
{
precomplete
.
remove
(
false
)
;
}
precompleteBackup
.
moveTo
(
greDir
FILE_PRECOMPLETE
)
;
}
else
if
(
precomplete
.
exists
(
)
)
{
if
(
readFile
(
precomplete
)
=
=
PRECOMPLETE_CONTENTS
)
{
precomplete
.
remove
(
false
)
;
}
}
}
function
finishTestRestoreUpdaterBackup
(
)
{
return
(
async
function
(
)
{
try
{
restoreUpdaterBackup
(
)
;
}
catch
(
e
)
{
logTestInfo
(
"
Attempt
to
restore
the
backed
up
updater
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
await
TestUtils
.
waitForTick
(
)
;
await
finishTestRestoreUpdaterBackup
(
)
;
}
}
)
(
)
;
}
function
waitForAboutDialog
(
)
{
return
new
Promise
(
resolve
=
>
{
var
listener
=
{
onOpenWindow
:
aXULWindow
=
>
{
debugDump
(
"
About
dialog
shown
.
.
.
"
)
;
Services
.
wm
.
removeListener
(
listener
)
;
async
function
aboutDialogOnLoad
(
)
{
domwindow
.
removeEventListener
(
"
load
"
aboutDialogOnLoad
true
)
;
let
chromeURI
=
"
chrome
:
/
/
browser
/
content
/
aboutDialog
.
xhtml
"
;
is
(
domwindow
.
document
.
location
.
href
chromeURI
"
About
dialog
appeared
"
)
;
resolve
(
domwindow
)
;
}
var
domwindow
=
aXULWindow
.
docShell
.
domWindow
;
domwindow
.
addEventListener
(
"
load
"
aboutDialogOnLoad
true
)
;
}
onCloseWindow
:
_aXULWindow
=
>
{
}
}
;
Services
.
wm
.
addListener
(
listener
)
;
openAboutDialog
(
)
;
}
)
;
}
function
getPatchOfType
(
type
update
)
{
if
(
update
)
{
for
(
let
i
=
0
;
i
<
update
.
patchCount
;
+
+
i
)
{
let
patch
=
update
.
getPatchAt
(
i
)
;
if
(
patch
&
&
patch
.
type
=
=
type
)
{
return
patch
;
}
}
}
return
null
;
}
function
runDoorhangerUpdateTest
(
params
steps
)
{
function
processDoorhangerStep
(
step
)
{
if
(
typeof
step
=
=
"
function
"
)
{
return
step
(
)
;
}
const
{
notificationId
button
checkActiveUpdate
pageURLs
expectedStateOverride
}
=
step
;
return
(
async
function
(
)
{
if
(
!
params
.
popupShown
&
&
!
PanelUI
.
isNotificationPanelOpen
)
{
await
BrowserTestUtils
.
waitForEvent
(
PanelUI
.
notificationPanel
"
popupshown
"
)
;
}
const
shownNotificationId
=
AppMenuNotifications
.
activeNotification
.
id
;
is
(
shownNotificationId
notificationId
"
The
right
notification
showed
up
.
"
)
;
let
expectedState
=
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
;
if
(
expectedStateOverride
)
{
expectedState
=
expectedStateOverride
;
}
else
if
(
notificationId
=
=
"
update
-
restart
"
)
{
expectedState
=
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
;
}
let
actualState
=
gAUS
.
currentState
;
is
(
actualState
expectedState
The
current
update
state
should
be
+
"
{
gAUS
.
getStateName
(
expectedState
)
}
"
.
Actual
:
+
"
{
gAUS
.
getStateName
(
actualState
)
}
"
)
;
if
(
checkActiveUpdate
)
{
let
activeUpdate
=
await
(
checkActiveUpdate
.
state
=
=
STATE_DOWNLOADING
?
gUpdateManager
.
getDownloadingUpdate
(
)
:
gUpdateManager
.
getReadyUpdate
(
)
)
;
ok
(
!
!
activeUpdate
"
There
should
be
an
active
update
"
)
;
is
(
activeUpdate
.
state
checkActiveUpdate
.
state
The
active
update
state
should
equal
{
checkActiveUpdate
.
state
}
)
;
}
else
{
ok
(
!
(
await
gUpdateManager
.
getDownloadingUpdate
(
)
)
"
There
should
not
be
a
downloading
update
"
)
;
ok
(
!
(
await
gUpdateManager
.
getReadyUpdate
(
)
)
"
There
should
not
be
a
ready
update
"
)
;
}
let
buttonEl
=
getNotificationButton
(
window
notificationId
button
)
;
buttonEl
.
click
(
)
;
if
(
pageURLs
&
&
pageURLs
.
manual
!
=
=
undefined
)
{
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
is
(
gBrowser
.
selectedBrowser
.
currentURI
.
spec
pageURLs
.
manual
The
page
'
s
url
should
equal
{
pageURLs
.
manual
}
)
;
gBrowser
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
}
)
(
)
;
}
return
(
async
function
(
)
{
if
(
params
.
slowStaging
)
{
Services
.
env
.
set
(
"
MOZ_TEST_SLOW_SKIP_UPDATE_STAGE
"
"
1
"
)
;
}
else
{
Services
.
env
.
set
(
"
MOZ_TEST_SKIP_UPDATE_STAGE
"
"
1
"
)
;
}
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_DISABLEDFORTESTING
false
]
[
PREF_APP_UPDATE_URL_DETAILS
gDetailsURL
]
[
PREF_APP_UPDATE_URL_MANUAL
URL_MANUAL_UPDATE
]
]
}
)
;
await
setupTestUpdater
(
)
;
let
baseURL
=
URL_HTTP_UPDATE_SJS
;
if
(
params
.
baseURL
)
{
baseURL
=
params
.
baseURL
;
}
let
queryString
=
params
.
queryString
?
params
.
queryString
:
"
"
;
let
updateURL
=
baseURL
+
"
?
detailsURL
=
"
+
gDetailsURL
+
queryString
+
getVersionParams
(
params
.
version
)
;
setUpdateURL
(
updateURL
)
;
if
(
params
.
checkAttempts
)
{
executeSoon
(
(
)
=
>
{
(
async
function
(
)
{
gAUS
.
checkForBackgroundUpdates
(
)
;
for
(
var
i
=
0
;
i
<
params
.
checkAttempts
-
1
;
i
+
+
)
{
await
waitForEvent
(
"
update
-
error
"
"
check
-
attempt
-
failed
"
)
;
gAUS
.
checkForBackgroundUpdates
(
)
;
}
}
)
(
)
;
}
)
;
}
else
{
writeStatusFile
(
STATE_FAILED_CRC_ERROR
)
;
writeUpdatesToXMLFile
(
getLocalUpdatesXMLString
(
params
.
updates
)
true
)
;
await
reloadUpdateManagerData
(
)
;
await
testPostUpdateProcessing
(
)
;
}
for
(
let
step
of
steps
)
{
await
processDoorhangerStep
(
step
)
;
}
}
)
(
)
;
}
function
runAboutDialogUpdateTest
(
params
steps
)
{
let
aboutDialog
;
function
processAboutDialogStep
(
step
)
{
if
(
typeof
step
=
=
"
function
"
)
{
return
step
(
aboutDialog
)
;
}
const
{
panelId
checkActiveUpdate
continueFile
downloadInfo
forceApply
noContinue
expectedStateOverride
}
=
step
;
return
(
async
function
(
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
aboutDialog
.
gAppUpdater
&
&
aboutDialog
.
gAppUpdater
.
selectedPanel
?
.
id
=
=
panelId
"
Waiting
for
the
expected
panel
ID
:
"
+
panelId
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
let
{
selectedPanel
}
=
aboutDialog
.
gAppUpdater
;
is
(
selectedPanel
.
id
panelId
"
The
panel
ID
should
equal
"
+
panelId
)
;
ok
(
BrowserTestUtils
.
isVisible
(
selectedPanel
)
"
The
panel
should
be
visible
"
)
;
if
(
panelId
=
=
"
downloading
"
&
&
gAUS
.
currentState
=
=
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
)
{
debugDump
(
"
Waiting
for
downloading
state
to
actually
start
"
)
;
await
gAUS
.
stateTransition
;
selectedPanel
=
aboutDialog
.
gAppUpdater
.
selectedPanel
;
is
(
selectedPanel
.
id
panelId
"
The
panel
ID
should
equal
"
+
panelId
)
;
ok
(
BrowserTestUtils
.
isVisible
(
selectedPanel
)
"
The
panel
should
be
visible
"
)
;
}
let
expectedState
=
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
;
if
(
expectedStateOverride
)
{
expectedState
=
expectedStateOverride
;
}
else
if
(
panelId
=
=
"
apply
"
)
{
expectedState
=
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
;
}
else
if
(
panelId
=
=
"
downloading
"
)
{
expectedState
=
Ci
.
nsIApplicationUpdateService
.
STATE_DOWNLOADING
;
}
else
if
(
panelId
=
=
"
applying
"
)
{
expectedState
=
Ci
.
nsIApplicationUpdateService
.
STATE_STAGING
;
}
let
actualState
=
gAUS
.
currentState
;
is
(
actualState
expectedState
The
current
update
state
should
be
+
"
{
gAUS
.
getStateName
(
expectedState
)
}
"
.
Actual
:
+
"
{
gAUS
.
getStateName
(
actualState
)
}
"
)
;
if
(
checkActiveUpdate
)
{
let
activeUpdate
=
await
(
checkActiveUpdate
.
state
=
=
STATE_DOWNLOADING
?
gUpdateManager
.
getDownloadingUpdate
(
)
:
gUpdateManager
.
getReadyUpdate
(
)
)
;
ok
(
!
!
activeUpdate
"
There
should
be
an
active
update
"
)
;
is
(
activeUpdate
.
state
checkActiveUpdate
.
state
"
The
active
update
state
should
equal
"
+
checkActiveUpdate
.
state
)
;
}
else
{
ok
(
!
(
await
gUpdateManager
.
getDownloadingUpdate
(
)
)
"
There
should
not
be
a
downloading
update
"
)
;
ok
(
!
(
await
gUpdateManager
.
getReadyUpdate
(
)
)
"
There
should
not
be
a
ready
update
"
)
;
}
if
(
panelId
=
=
"
downloading
"
&
&
continueFile
)
{
for
(
let
i
=
0
;
i
<
downloadInfo
.
length
;
+
+
i
)
{
let
data
=
downloadInfo
[
i
]
;
await
continueFileHandler
(
continueFile
)
;
let
patch
=
getPatchOfType
(
data
.
patchType
await
gUpdateManager
.
getDownloadingUpdate
(
)
)
;
let
isLastPatch
=
i
=
=
downloadInfo
.
length
-
1
;
if
(
!
isLastPatch
|
|
patch
)
{
let
resultName
=
data
.
bitsResult
?
"
bitsResult
"
:
"
internalResult
"
;
patch
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
patch
.
getProperty
(
resultName
)
=
=
data
[
resultName
]
"
Waiting
for
expected
patch
property
"
+
resultName
+
"
value
:
"
+
data
[
resultName
]
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
is
(
"
"
+
patch
.
getProperty
(
resultName
)
data
[
resultName
]
"
The
patch
property
"
+
resultName
+
"
value
should
equal
"
+
data
[
resultName
]
)
;
let
expectedText
=
DownloadUtils
.
getTransferTotal
(
data
[
resultName
]
=
=
gBadSizeResult
?
0
:
patch
.
size
patch
.
size
)
;
Assert
.
ok
(
expectedText
"
Sanity
check
:
Expected
download
status
text
should
be
non
-
empty
"
)
;
if
(
aboutDialog
.
document
.
hasPendingL10nMutations
)
{
await
BrowserTestUtils
.
waitForEvent
(
aboutDialog
.
document
"
L10nMutationsFinished
"
)
;
}
Assert
.
equal
(
aboutDialog
.
document
.
querySelector
(
#
downloading
label
[
data
-
l10n
-
name
=
"
download
-
status
"
]
)
.
textContent
expectedText
"
Download
status
text
should
be
correct
"
)
;
}
}
}
else
if
(
continueFile
)
{
await
continueFileHandler
(
continueFile
)
;
}
let
linkPanels
=
[
"
downloadFailed
"
"
manualUpdate
"
"
unsupportedSystem
"
"
internalError
"
]
;
if
(
linkPanels
.
includes
(
panelId
)
)
{
let
selector
=
"
label
.
text
-
link
"
;
if
(
selectedPanel
.
ownerDocument
.
hasPendingL10nMutations
)
{
await
BrowserTestUtils
.
waitForEvent
(
selectedPanel
.
ownerDocument
"
L10nMutationsFinished
"
)
;
}
let
link
=
selectedPanel
.
querySelector
(
selector
)
;
is
(
link
.
href
gDetailsURL
The
panel
'
s
link
href
should
equal
{
gDetailsURL
}
)
;
const
assertNonEmptyText
=
(
node
description
)
=
>
{
let
textContent
=
node
.
textContent
.
trim
(
)
;
ok
(
textContent
{
description
}
got
"
{
textContent
}
"
)
;
}
;
assertNonEmptyText
(
link
The
panel
'
s
link
should
have
non
-
empty
textContent
)
;
let
linkWrapperClone
=
link
.
parentNode
.
cloneNode
(
true
)
;
linkWrapperClone
.
querySelector
(
selector
)
.
remove
(
)
;
assertNonEmptyText
(
linkWrapperClone
The
panel
'
s
link
should
have
text
around
the
link
)
;
}
let
buttonPanels
=
[
"
downloadAndInstall
"
"
apply
"
]
;
if
(
buttonPanels
.
includes
(
panelId
)
&
&
!
noContinue
)
{
let
buttonEl
=
selectedPanel
.
querySelector
(
"
button
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
aboutDialog
.
document
.
activeElement
=
=
buttonEl
"
The
button
should
receive
focus
"
)
;
ok
(
!
buttonEl
.
disabled
"
The
button
should
be
enabled
"
)
;
if
(
panelId
!
=
"
apply
"
|
|
forceApply
)
{
buttonEl
.
click
(
)
;
}
}
}
)
(
)
;
}
return
(
async
function
(
)
{
Services
.
env
.
set
(
"
MOZ_TEST_SLOW_SKIP_UPDATE_STAGE
"
"
1
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_DISABLEDFORTESTING
false
]
[
PREF_APP_UPDATE_URL_MANUAL
gDetailsURL
]
]
}
)
;
await
setupTestUpdater
(
)
;
let
baseURL
=
URL_HTTP_UPDATE_SJS
;
if
(
params
.
baseURL
)
{
baseURL
=
params
.
baseURL
;
}
let
queryString
=
params
.
queryString
?
params
.
queryString
:
"
"
;
let
updateURL
=
baseURL
+
"
?
detailsURL
=
"
+
gDetailsURL
+
queryString
+
getVersionParams
(
params
.
version
)
;
if
(
params
.
backgroundUpdate
)
{
setUpdateURL
(
updateURL
)
;
await
gAUS
.
checkForBackgroundUpdates
(
)
;
if
(
params
.
continueFile
)
{
await
continueFileHandler
(
params
.
continueFile
)
;
}
if
(
params
.
waitForUpdateState
)
{
let
whichUpdateFn
=
params
.
waitForUpdateState
=
=
STATE_DOWNLOADING
?
"
getDownloadingUpdate
"
:
"
getReadyUpdate
"
;
let
update
;
await
TestUtils
.
waitForCondition
(
async
(
)
=
>
{
update
=
await
gUpdateManager
[
whichUpdateFn
]
(
)
;
return
update
&
&
update
.
state
=
=
params
.
waitForUpdateState
;
}
"
Waiting
for
update
state
:
"
+
params
.
waitForUpdateState
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
is
(
update
.
state
params
.
waitForUpdateState
"
The
update
state
value
should
equal
"
+
params
.
waitForUpdateState
)
;
}
}
else
{
updateURL
+
=
"
&
slowUpdateCheck
=
1
&
useSlowDownloadMar
=
1
"
;
setUpdateURL
(
updateURL
)
;
}
aboutDialog
=
await
waitForAboutDialog
(
)
;
registerCleanupFunction
(
(
)
=
>
{
aboutDialog
.
close
(
)
;
}
)
;
for
(
let
step
of
steps
)
{
await
processAboutDialogStep
(
step
)
;
}
}
)
(
)
;
}
function
runAboutPrefsUpdateTest
(
params
steps
)
{
let
tab
;
function
processAboutPrefsStep
(
step
)
{
if
(
typeof
step
=
=
"
function
"
)
{
return
step
(
tab
)
;
}
const
{
panelId
checkActiveUpdate
continueFile
downloadInfo
forceApply
expectedStateOverride
}
=
step
;
return
(
async
function
(
)
{
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
{
panelId
}
]
async
(
{
panelId
}
)
=
>
{
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
content
.
gAppUpdater
.
selectedPanel
?
.
id
=
=
panelId
"
Waiting
for
the
expected
panel
ID
:
"
+
panelId
undefined
200
)
.
catch
(
e
=
>
{
info
(
e
)
;
}
)
;
is
(
content
.
gAppUpdater
.
selectedPanel
.
id
panelId
"
The
panel
ID
should
equal
"
+
panelId
)
;
}
)
;
if
(
panelId
=
=
"
downloading
"
&
&
gAUS
.
currentState
=
=
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
)
{
debugDump
(
"
Waiting
for
downloading
state
to
actually
start
"
)
;
await
gAUS
.
stateTransition
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
{
panelId
}
]
(
{
panelId
}
)
=
>
{
is
(
content
.
gAppUpdater
.
selectedPanel
.
id
panelId
"
The
panel
ID
should
equal
"
+
panelId
)
;
}
)
;
}
let
expectedState
=
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
;
if
(
expectedStateOverride
)
{
expectedState
=
expectedStateOverride
;
}
else
if
(
panelId
=
=
"
apply
"
)
{
expectedState
=
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
;
}
else
if
(
panelId
=
=
"
downloading
"
)
{
expectedState
=
Ci
.
nsIApplicationUpdateService
.
STATE_DOWNLOADING
;
}
else
if
(
panelId
=
=
"
applying
"
)
{
expectedState
=
Ci
.
nsIApplicationUpdateService
.
STATE_STAGING
;
}
let
actualState
=
gAUS
.
currentState
;
is
(
actualState
expectedState
The
current
update
state
should
be
+
"
{
gAUS
.
getStateName
(
expectedState
)
}
"
.
Actual
:
+
"
{
gAUS
.
getStateName
(
actualState
)
}
"
)
;
if
(
checkActiveUpdate
)
{
let
activeUpdate
=
await
(
checkActiveUpdate
.
state
=
=
STATE_DOWNLOADING
?
gUpdateManager
.
getDownloadingUpdate
(
)
:
gUpdateManager
.
getReadyUpdate
(
)
)
;
ok
(
!
!
activeUpdate
"
There
should
be
an
active
update
"
)
;
is
(
activeUpdate
.
state
checkActiveUpdate
.
state
"
The
active
update
state
should
equal
"
+
checkActiveUpdate
.
state
)
;
}
else
{
ok
(
!
(
await
gUpdateManager
.
getDownloadingUpdate
(
)
)
"
There
should
not
be
a
downloading
update
"
)
;
ok
(
!
(
await
gUpdateManager
.
getReadyUpdate
(
)
)
"
There
should
not
be
a
ready
update
"
)
;
}
if
(
panelId
=
=
"
downloading
"
)
{
if
(
!
downloadInfo
)
{
logTestInfo
(
"
no
downloadinfo
possible
error
?
"
)
;
}
for
(
let
i
=
0
;
i
<
downloadInfo
.
length
;
+
+
i
)
{
let
data
=
downloadInfo
[
i
]
;
await
continueFileHandler
(
continueFile
)
;
let
patch
=
getPatchOfType
(
data
.
patchType
await
gUpdateManager
.
getDownloadingUpdate
(
)
)
;
let
isLastPatch
=
i
=
=
downloadInfo
.
length
-
1
;
if
(
!
isLastPatch
|
|
patch
)
{
let
resultName
=
data
.
bitsResult
?
"
bitsResult
"
:
"
internalResult
"
;
patch
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
patch
.
getProperty
(
resultName
)
=
=
data
[
resultName
]
"
Waiting
for
expected
patch
property
"
+
resultName
+
"
value
:
"
+
data
[
resultName
]
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
is
(
"
"
+
patch
.
getProperty
(
resultName
)
data
[
resultName
]
"
The
patch
property
"
+
resultName
+
"
value
should
equal
"
+
data
[
resultName
]
)
;
let
actualText
=
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
const
{
document
}
=
content
;
if
(
document
.
hasPendingL10nMutations
)
{
await
ContentTaskUtils
.
waitForEvent
(
document
"
L10nMutationsFinished
"
)
;
}
return
document
.
getElementById
(
"
downloading
"
)
.
textContent
;
}
)
;
let
expectedSuffix
=
DownloadUtils
.
getTransferTotal
(
data
[
resultName
]
=
=
gBadSizeResult
?
0
:
patch
.
size
patch
.
size
)
;
Assert
.
ok
(
expectedSuffix
"
Sanity
check
:
Expected
download
status
text
should
be
non
-
empty
"
)
;
Assert
.
ok
(
actualText
.
endsWith
(
expectedSuffix
)
"
Download
status
text
should
end
as
expected
:
"
+
JSON
.
stringify
(
{
actualText
expectedSuffix
}
)
)
;
}
}
}
else
if
(
continueFile
)
{
await
continueFileHandler
(
continueFile
)
;
}
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
{
panelId
gDetailsURL
forceApply
}
]
async
(
{
panelId
gDetailsURL
forceApply
}
)
=
>
{
let
linkPanels
=
[
"
downloadFailed
"
"
manualUpdate
"
"
unsupportedSystem
"
"
internalError
"
]
;
if
(
linkPanels
.
includes
(
panelId
)
)
{
let
{
selectedPanel
}
=
content
.
gAppUpdater
;
let
selector
=
"
label
.
text
-
link
"
;
if
(
selectedPanel
.
id
=
=
"
downloadFailed
"
)
{
selector
=
"
a
.
text
-
link
"
;
}
if
(
selectedPanel
.
id
=
=
"
manualUpdate
"
)
{
selector
=
"
a
.
manualLink
"
;
}
if
(
selectedPanel
.
ownerDocument
.
hasPendingL10nMutations
)
{
await
ContentTaskUtils
.
waitForEvent
(
selectedPanel
.
ownerDocument
"
L10nMutationsFinished
"
)
;
}
let
link
=
selectedPanel
.
querySelector
(
selector
)
;
is
(
link
.
href
gDetailsURL
The
panel
'
s
link
href
should
equal
{
gDetailsURL
}
)
;
const
assertNonEmptyText
=
(
node
description
)
=
>
{
let
textContent
=
node
.
textContent
.
trim
(
)
;
ok
(
textContent
{
description
}
got
"
{
textContent
}
"
)
;
}
;
assertNonEmptyText
(
link
The
panel
'
s
link
should
have
non
-
empty
textContent
)
;
let
linkWrapperClone
=
link
.
parentNode
.
cloneNode
(
true
)
;
linkWrapperClone
.
querySelector
(
selector
)
.
remove
(
)
;
assertNonEmptyText
(
linkWrapperClone
The
panel
'
s
link
should
have
text
around
the
link
)
;
}
let
buttonPanels
=
[
"
downloadAndInstall
"
"
apply
"
]
;
if
(
buttonPanels
.
includes
(
panelId
)
)
{
let
{
selectedPanel
}
=
content
.
gAppUpdater
;
let
buttonEl
=
selectedPanel
.
querySelector
(
"
button
"
)
;
ok
(
!
buttonEl
.
disabled
"
The
button
should
be
enabled
"
)
;
if
(
selectedPanel
.
id
!
=
"
apply
"
|
|
forceApply
)
{
buttonEl
.
click
(
)
;
}
}
}
)
;
}
)
(
)
;
}
return
(
async
function
(
)
{
Services
.
env
.
set
(
"
MOZ_TEST_SLOW_SKIP_UPDATE_STAGE
"
"
1
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_DISABLEDFORTESTING
false
]
[
PREF_APP_UPDATE_URL_MANUAL
gDetailsURL
]
]
}
)
;
await
setupTestUpdater
(
)
;
let
baseURL
=
URL_HTTP_UPDATE_SJS
;
if
(
params
.
baseURL
)
{
baseURL
=
params
.
baseURL
;
}
let
queryString
=
params
.
queryString
?
params
.
queryString
:
"
"
;
let
updateURL
=
baseURL
+
"
?
detailsURL
=
"
+
gDetailsURL
+
queryString
+
getVersionParams
(
params
.
version
)
;
if
(
params
.
backgroundUpdate
)
{
setUpdateURL
(
updateURL
)
;
await
gAUS
.
checkForBackgroundUpdates
(
)
;
if
(
params
.
continueFile
)
{
await
continueFileHandler
(
params
.
continueFile
)
;
}
if
(
params
.
waitForUpdateState
)
{
let
whichUpdateFn
=
params
.
waitForUpdateState
=
=
STATE_DOWNLOADING
?
"
getDownloadingUpdate
"
:
"
getReadyUpdate
"
;
let
update
;
await
TestUtils
.
waitForCondition
(
async
(
)
=
>
{
update
=
await
gUpdateManager
[
whichUpdateFn
]
(
)
;
return
update
&
&
update
.
state
=
=
params
.
waitForUpdateState
;
}
"
Waiting
for
update
state
:
"
+
params
.
waitForUpdateState
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
is
(
update
.
state
params
.
waitForUpdateState
"
The
update
state
value
should
equal
"
+
params
.
waitForUpdateState
)
;
}
}
else
{
updateURL
+
=
"
&
slowUpdateCheck
=
1
&
useSlowDownloadMar
=
1
"
;
setUpdateURL
(
updateURL
)
;
}
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
preferences
"
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
content
.
document
.
getElementById
(
"
updatesCategory
"
)
.
scrollIntoView
(
)
;
}
)
;
for
(
let
step
of
steps
)
{
await
processAboutPrefsStep
(
step
)
;
}
}
)
(
)
;
}
function
removeUpdateSettingsIni
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
)
)
{
let
greDir
=
getGREDir
(
)
;
let
updateSettingsIniBak
=
greDir
.
clone
(
)
;
updateSettingsIniBak
.
append
(
FILE_UPDATE_SETTINGS_INI_BAK
)
;
if
(
updateSettingsIniBak
.
exists
(
)
)
{
let
updateSettingsIni
=
greDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI
)
;
updateSettingsIni
.
remove
(
false
)
;
}
}
}
function
runTelemetryUpdateTest
(
updateParams
event
stageFailure
=
false
)
{
return
(
async
function
(
)
{
Services
.
telemetry
.
clearScalars
(
)
;
Services
.
env
.
set
(
"
MOZ_TEST_SKIP_UPDATE_STAGE
"
"
1
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_DISABLEDFORTESTING
false
]
]
}
)
;
await
setupTestUpdater
(
)
;
if
(
stageFailure
)
{
removeUpdateSettingsIni
(
)
;
}
let
updateURL
=
URL_HTTP_UPDATE_SJS
+
"
?
detailsURL
=
"
+
gDetailsURL
+
updateParams
+
getVersionParams
(
)
;
setUpdateURL
(
updateURL
)
;
gAUS
.
checkForBackgroundUpdates
(
)
;
await
waitForEvent
(
event
)
;
}
)
(
)
;
}
