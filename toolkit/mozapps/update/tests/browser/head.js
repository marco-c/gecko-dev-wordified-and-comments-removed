ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppMenuNotifications
"
"
resource
:
/
/
gre
/
modules
/
AppMenuNotifications
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateListener
"
"
resource
:
/
/
gre
/
modules
/
UpdateListener
.
jsm
"
)
;
const
IS_MACOSX
=
(
"
nsILocalFileMac
"
in
Ci
)
;
const
IS_WIN
=
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
in
Cc
)
;
const
BIN_SUFFIX
=
(
IS_WIN
?
"
.
exe
"
:
"
"
)
;
const
FILE_UPDATER_BIN
=
"
updater
"
+
(
IS_MACOSX
?
"
.
app
"
:
BIN_SUFFIX
)
;
const
FILE_UPDATER_BIN_BAK
=
FILE_UPDATER_BIN
+
"
.
bak
"
;
const
PREF_APP_UPDATE_INTERVAL
=
"
app
.
update
.
interval
"
;
const
PREF_APP_UPDATE_LASTUPDATETIME
=
"
app
.
update
.
lastUpdateTime
.
background
-
update
-
timer
"
;
const
DATA_URI_SPEC
=
"
chrome
:
/
/
mochitests
/
content
/
browser
/
toolkit
/
mozapps
/
update
/
tests
/
browser
/
"
;
var
DEBUG_AUS_TEST
=
true
;
const
LOG_FUNCTION
=
info
;
const
MAX_UPDATE_COPY_ATTEMPTS
=
10
;
Services
.
scriptloader
.
loadSubScript
(
DATA_URI_SPEC
+
"
testConstants
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
DATA_URI_SPEC
+
"
shared
.
js
"
this
)
;
var
gURLData
=
URL_HOST
+
"
/
"
+
REL_PATH_DATA
;
const
URL_MANUAL_UPDATE
=
gURLData
+
"
downloadPage
.
html
"
;
const
gEnv
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
let
gOriginalUpdateAutoValue
=
null
;
async
function
continueFileHandler
(
leafName
)
{
let
retries
=
undefined
;
let
continueFile
;
if
(
leafName
=
=
CONTINUE_STAGING
)
{
debugDump
(
"
creating
"
+
leafName
+
"
file
for
slow
update
staging
"
)
;
retries
=
100
;
continueFile
=
getUpdatesPatchDir
(
)
;
continueFile
.
append
(
leafName
)
;
}
else
{
debugDump
(
"
creating
"
+
leafName
+
"
file
for
slow
http
server
requests
"
)
;
continueFile
=
Services
.
dirsvc
.
get
(
"
CurWorkD
"
Ci
.
nsIFile
)
;
let
continuePath
=
REL_PATH_DATA
+
leafName
;
let
continuePathParts
=
continuePath
.
split
(
"
/
"
)
;
for
(
let
i
=
0
;
i
<
continuePathParts
.
length
;
+
+
i
)
{
continueFile
.
append
(
continuePathParts
[
i
]
)
;
}
}
if
(
continueFile
.
exists
(
)
)
{
throw
new
Error
(
"
The
continue
file
should
not
exist
path
:
"
+
continueFile
.
path
)
;
}
continueFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
PERMS_FILE
)
;
return
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
(
!
continueFile
.
exists
(
)
)
"
Waiting
for
file
to
be
deleted
path
:
"
+
continueFile
.
path
undefined
retries
)
;
}
function
lockWriteTestFile
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
throw
new
Error
(
"
Windows
only
test
function
called
"
)
;
}
let
file
=
getUpdatesRootDir
(
)
;
file
.
append
(
FILE_UPDATE_TEST
)
;
file
.
QueryInterface
(
Ci
.
nsILocalFileWin
)
;
if
(
file
.
exists
(
)
)
{
file
.
fileAttributesWin
|
=
file
.
WFA_READWRITE
;
file
.
fileAttributesWin
&
=
~
file
.
WFA_READONLY
;
file
.
remove
(
false
)
;
}
file
.
create
(
file
.
NORMAL_FILE_TYPE
0o444
)
;
file
.
fileAttributesWin
|
=
file
.
WFA_READONLY
;
file
.
fileAttributesWin
&
=
~
file
.
WFA_READWRITE
;
registerCleanupFunction
(
(
)
=
>
{
file
.
fileAttributesWin
|
=
file
.
WFA_READWRITE
;
file
.
fileAttributesWin
&
=
~
file
.
WFA_READONLY
;
file
.
remove
(
false
)
;
}
)
;
}
function
getVersionParams
(
aAppVersion
)
{
let
appInfo
=
Services
.
appinfo
;
return
"
&
appVersion
=
"
+
(
aAppVersion
?
aAppVersion
:
appInfo
.
version
)
;
}
function
cleanUpUpdates
(
)
{
reloadUpdateManagerData
(
true
)
;
removeUpdateDirsAndFiles
(
)
;
}
function
setUpdateTimerPrefs
(
)
{
let
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
-
60
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_LASTUPDATETIME
now
)
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_INTERVAL
43200
)
;
}
async
function
setAppUpdateAutoEnabledHelper
(
enabled
)
{
if
(
gOriginalUpdateAutoValue
=
=
null
)
{
gOriginalUpdateAutoValue
=
await
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
gOriginalUpdateAutoValue
)
;
}
)
;
}
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
enabled
)
;
}
add_task
(
async
function
setDefaults
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_LOG
DEBUG_AUS_TEST
]
[
"
services
.
sync
.
autoconnectDelay
"
600000
]
]
}
)
;
await
setAppUpdateAutoEnabledHelper
(
true
)
;
}
)
;
function
runUpdateTest
(
updateParams
checkAttempts
steps
)
{
return
(
async
function
(
)
{
registerCleanupFunction
(
(
)
=
>
{
gEnv
.
set
(
"
MOZ_TEST_SKIP_UPDATE_STAGE
"
"
"
)
;
UpdateListener
.
reset
(
)
;
cleanUpUpdates
(
)
;
}
)
;
gEnv
.
set
(
"
MOZ_TEST_SKIP_UPDATE_STAGE
"
"
1
"
)
;
setUpdateTimerPrefs
(
)
;
removeUpdateDirsAndFiles
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_DOWNLOADPROMPTATTEMPTS
0
]
[
PREF_APP_UPDATE_DISABLEDFORTESTING
false
]
[
PREF_APP_UPDATE_IDLETIME
0
]
[
PREF_APP_UPDATE_URL_MANUAL
URL_MANUAL_UPDATE
]
]
}
)
;
await
setupTestUpdater
(
)
;
let
url
=
URL_HTTP_UPDATE_SJS
+
"
?
"
+
updateParams
+
getVersionParams
(
)
;
setUpdateURL
(
url
)
;
executeSoon
(
(
)
=
>
{
(
async
function
(
)
{
gAUS
.
checkForBackgroundUpdates
(
)
;
for
(
var
i
=
0
;
i
<
checkAttempts
-
1
;
i
+
+
)
{
await
waitForEvent
(
"
update
-
error
"
"
check
-
attempt
-
failed
"
)
;
gAUS
.
checkForBackgroundUpdates
(
)
;
}
}
)
(
)
;
}
)
;
for
(
let
step
of
steps
)
{
await
processStep
(
step
)
;
}
await
finishTestRestoreUpdaterBackup
(
)
;
}
)
(
)
;
}
function
runUpdateProcessingTest
(
updates
steps
)
{
return
(
async
function
(
)
{
registerCleanupFunction
(
(
)
=
>
{
gEnv
.
set
(
"
MOZ_TEST_SKIP_UPDATE_STAGE
"
"
"
)
;
UpdateListener
.
reset
(
)
;
cleanUpUpdates
(
)
;
}
)
;
gEnv
.
set
(
"
MOZ_TEST_SKIP_UPDATE_STAGE
"
"
1
"
)
;
setUpdateTimerPrefs
(
)
;
removeUpdateDirsAndFiles
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_DOWNLOADPROMPTATTEMPTS
0
]
[
PREF_APP_UPDATE_DISABLEDFORTESTING
false
]
[
PREF_APP_UPDATE_IDLETIME
0
]
[
PREF_APP_UPDATE_URL_MANUAL
URL_MANUAL_UPDATE
]
]
}
)
;
await
setupTestUpdater
(
)
;
writeUpdatesToXMLFile
(
getLocalUpdatesXMLString
(
updates
)
true
)
;
writeUpdatesToXMLFile
(
getLocalUpdatesXMLString
(
"
"
)
false
)
;
writeStatusFile
(
STATE_FAILED_CRC_ERROR
)
;
reloadUpdateManagerData
(
)
;
testPostUpdateProcessing
(
)
;
for
(
let
step
of
steps
)
{
await
processStep
(
step
)
;
}
await
finishTestRestoreUpdaterBackup
(
)
;
}
)
(
)
;
}
function
processStep
(
step
)
{
if
(
typeof
(
step
)
=
=
"
function
"
)
{
return
step
(
)
;
}
const
{
notificationId
button
beforeClick
cleanup
}
=
step
;
return
(
async
function
(
)
{
await
BrowserTestUtils
.
waitForEvent
(
PanelUI
.
notificationPanel
"
popupshown
"
)
;
const
shownNotification
=
AppMenuNotifications
.
activeNotification
.
id
;
is
(
shownNotification
notificationId
"
The
right
notification
showed
up
.
"
)
;
if
(
shownNotification
!
=
notificationId
)
{
if
(
cleanup
)
{
await
cleanup
(
)
;
}
return
;
}
let
buttonEl
=
getNotificationButton
(
window
notificationId
button
)
;
if
(
beforeClick
)
{
await
beforeClick
(
)
;
}
buttonEl
.
click
(
)
;
if
(
cleanup
)
{
await
cleanup
(
)
;
}
}
)
(
)
;
}
function
waitForEvent
(
topic
status
=
null
)
{
return
new
Promise
(
resolve
=
>
Services
.
obs
.
addObserver
(
{
observe
(
subject
innerTopic
innerStatus
)
{
if
(
!
status
|
|
status
=
=
innerStatus
)
{
Services
.
obs
.
removeObserver
(
this
topic
)
;
resolve
(
innerStatus
)
;
}
}
}
topic
)
)
;
}
function
getNotificationButton
(
win
notificationId
button
)
{
let
notification
=
win
.
document
.
getElementById
(
appMenu
-
{
notificationId
}
-
notification
)
;
is
(
notification
.
hidden
false
{
notificationId
}
notification
is
showing
)
;
return
win
.
document
.
getAnonymousElementByAttribute
(
notification
"
anonid
"
button
)
;
}
function
checkWhatsNewLink
(
win
id
url
)
{
let
whatsNewLink
=
win
.
document
.
getElementById
(
id
)
;
is
(
whatsNewLink
.
href
url
|
|
URL_HTTP_UPDATE_SJS
+
"
?
uiURL
=
DETAILS
"
"
What
'
s
new
link
points
to
the
test_details
URL
"
)
;
is
(
whatsNewLink
.
hidden
false
"
What
'
s
new
link
is
not
hidden
.
"
)
;
}
function
setupTestUpdater
(
)
{
return
(
async
function
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
)
)
{
try
{
restoreUpdaterBackup
(
)
;
}
catch
(
e
)
{
logTestInfo
(
"
Attempt
to
restore
the
backed
up
updater
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
await
TestUtils
.
waitForTick
(
)
;
await
setupTestUpdater
(
)
;
return
;
}
await
moveRealUpdater
(
)
;
}
}
)
(
)
;
}
function
moveRealUpdater
(
)
{
return
(
async
function
(
)
{
try
{
let
baseAppDir
=
getAppBaseDir
(
)
;
let
updater
=
baseAppDir
.
clone
(
)
;
updater
.
append
(
FILE_UPDATER_BIN
)
;
updater
.
moveTo
(
baseAppDir
FILE_UPDATER_BIN_BAK
)
;
}
catch
(
e
)
{
logTestInfo
(
"
Attempt
to
move
the
real
updater
out
of
the
way
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
await
TestUtils
.
waitForTick
(
)
;
await
moveRealUpdater
(
)
;
return
;
}
await
copyTestUpdater
(
)
;
}
)
(
)
;
}
function
copyTestUpdater
(
attempt
=
0
)
{
return
(
async
function
(
)
{
try
{
let
baseAppDir
=
getAppBaseDir
(
)
;
let
testUpdaterDir
=
Services
.
dirsvc
.
get
(
"
CurWorkD
"
Ci
.
nsIFile
)
;
let
relPath
=
REL_PATH_DATA
;
let
pathParts
=
relPath
.
split
(
"
/
"
)
;
for
(
let
i
=
0
;
i
<
pathParts
.
length
;
+
+
i
)
{
testUpdaterDir
.
append
(
pathParts
[
i
]
)
;
}
let
testUpdater
=
testUpdaterDir
.
clone
(
)
;
testUpdater
.
append
(
FILE_UPDATER_BIN
)
;
testUpdater
.
copyToFollowingLinks
(
baseAppDir
FILE_UPDATER_BIN
)
;
}
catch
(
e
)
{
if
(
attempt
<
MAX_UPDATE_COPY_ATTEMPTS
)
{
logTestInfo
(
"
Attempt
to
copy
the
test
updater
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
await
TestUtils
.
waitForTick
(
)
;
await
copyTestUpdater
(
attempt
+
1
)
;
}
}
}
)
(
)
;
}
function
restoreUpdaterBackup
(
)
{
let
baseAppDir
=
getAppBaseDir
(
)
;
let
updater
=
baseAppDir
.
clone
(
)
;
let
updaterBackup
=
baseAppDir
.
clone
(
)
;
updater
.
append
(
FILE_UPDATER_BIN
)
;
updaterBackup
.
append
(
FILE_UPDATER_BIN_BAK
)
;
if
(
updaterBackup
.
exists
(
)
)
{
if
(
updater
.
exists
(
)
)
{
updater
.
remove
(
true
)
;
}
updaterBackup
.
moveTo
(
baseAppDir
FILE_UPDATER_BIN
)
;
}
}
function
finishTestRestoreUpdaterBackup
(
)
{
return
(
async
function
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
)
)
{
try
{
restoreUpdaterBackup
(
)
;
}
catch
(
e
)
{
logTestInfo
(
"
Attempt
to
restore
the
backed
up
updater
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
await
TestUtils
.
waitForTick
(
)
;
await
finishTestRestoreUpdaterBackup
(
)
;
}
}
}
)
(
)
;
}
function
waitForAboutDialog
(
)
{
return
new
Promise
(
resolve
=
>
{
var
listener
=
{
onOpenWindow
:
aXULWindow
=
>
{
debugDump
(
"
About
dialog
shown
.
.
.
"
)
;
Services
.
wm
.
removeListener
(
listener
)
;
async
function
aboutDialogOnLoad
(
)
{
domwindow
.
removeEventListener
(
"
load
"
aboutDialogOnLoad
true
)
;
let
chromeURI
=
"
chrome
:
/
/
browser
/
content
/
aboutDialog
.
xul
"
;
is
(
domwindow
.
document
.
location
.
href
chromeURI
"
About
dialog
appeared
"
)
;
resolve
(
domwindow
)
;
}
var
domwindow
=
aXULWindow
.
docShell
.
domWindow
;
domwindow
.
addEventListener
(
"
load
"
aboutDialogOnLoad
true
)
;
}
onCloseWindow
:
aXULWindow
=
>
{
}
}
;
Services
.
wm
.
addListener
(
listener
)
;
openAboutDialog
(
)
;
}
)
;
}
function
runAboutDialogUpdateTest
(
updateParams
backgroundUpdate
steps
)
{
let
aboutDialog
;
function
processAboutDialogStep
(
step
)
{
if
(
typeof
(
step
)
=
=
"
function
"
)
{
return
step
(
)
;
}
function
getSelectedPanel
(
)
{
return
aboutDialog
.
document
.
getElementById
(
"
updateDeck
"
)
.
selectedPanel
;
}
function
getSelectedPanelButton
(
)
{
return
getSelectedPanel
(
)
.
querySelector
(
"
button
"
)
;
}
function
getSelectedLabelLink
(
)
{
return
getSelectedPanel
(
)
.
querySelector
(
"
label
.
text
-
link
"
)
;
}
const
{
panelId
checkActiveUpdate
continueFile
}
=
step
;
return
(
async
function
(
)
{
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
(
getSelectedPanel
(
)
&
&
getSelectedPanel
(
)
.
id
=
=
panelId
)
"
Waiting
for
expected
panel
ID
-
expected
\
"
"
+
panelId
+
"
\
"
"
)
;
if
(
checkActiveUpdate
)
{
ok
(
!
!
gUpdateManager
.
activeUpdate
"
There
should
be
an
active
update
"
)
;
is
(
gUpdateManager
.
activeUpdate
.
state
checkActiveUpdate
.
state
"
The
active
update
state
should
equal
"
+
checkActiveUpdate
.
state
)
;
}
else
{
ok
(
!
gUpdateManager
.
activeUpdate
"
There
should
not
be
an
active
update
"
)
;
}
if
(
continueFile
)
{
await
continueFileHandler
(
continueFile
)
;
}
let
linkPanels
=
[
"
downloadFailed
"
"
manualUpdate
"
"
unsupportedSystem
"
]
;
if
(
linkPanels
.
includes
(
panelId
)
)
{
let
labelLink
=
getSelectedLabelLink
(
)
;
is
(
labelLink
.
href
URL_HOST
"
The
panel
'
s
link
href
should
equal
the
expected
value
"
)
;
}
let
buttonPanels
=
[
"
downloadAndInstall
"
"
apply
"
]
;
if
(
buttonPanels
.
includes
(
panelId
)
)
{
let
buttonEl
=
getSelectedPanelButton
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
(
aboutDialog
.
document
.
activeElement
=
=
buttonEl
)
"
The
button
should
receive
focus
"
)
;
ok
(
!
buttonEl
.
disabled
"
The
button
should
be
enabled
"
)
;
if
(
panelId
!
=
"
apply
"
)
{
buttonEl
.
click
(
)
;
}
}
}
)
(
)
;
}
return
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_SERVICE_ENABLED
false
]
[
PREF_APP_UPDATE_DISABLEDFORTESTING
false
]
[
PREF_APP_UPDATE_URL_MANUAL
URL_HOST
]
]
}
)
;
registerCleanupFunction
(
(
)
=
>
{
gEnv
.
set
(
"
MOZ_TEST_SLOW_SKIP_UPDATE_STAGE
"
"
"
)
;
UpdateListener
.
reset
(
)
;
cleanUpUpdates
(
)
;
}
)
;
gEnv
.
set
(
"
MOZ_TEST_SLOW_SKIP_UPDATE_STAGE
"
"
1
"
)
;
setUpdateTimerPrefs
(
)
;
removeUpdateDirsAndFiles
(
)
;
await
setupTestUpdater
(
)
;
let
url
=
URL_HTTP_UPDATE_SJS
+
"
?
detailsURL
=
"
+
URL_HOST
+
updateParams
+
getVersionParams
(
)
;
if
(
backgroundUpdate
)
{
setUpdateURL
(
url
)
;
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
)
)
{
continueFileHandler
(
CONTINUE_STAGING
)
;
}
gAUS
.
checkForBackgroundUpdates
(
)
;
await
waitForEvent
(
"
update
-
downloaded
"
)
;
}
else
{
url
+
=
"
&
slowUpdateCheck
=
1
&
useSlowDownloadMar
=
1
"
;
setUpdateURL
(
url
)
;
}
aboutDialog
=
await
waitForAboutDialog
(
)
;
for
(
let
step
of
steps
)
{
await
processAboutDialogStep
(
step
)
;
}
aboutDialog
.
close
(
)
;
await
finishTestRestoreUpdaterBackup
(
)
;
}
)
(
)
;
}
