"
use
strict
"
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppMenuNotifications
"
"
resource
:
/
/
gre
/
modules
/
AppMenuNotifications
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateListener
"
"
resource
:
/
/
gre
/
modules
/
UpdateListener
.
jsm
"
)
;
const
BIN_SUFFIX
=
AppConstants
.
platform
=
=
"
win
"
?
"
.
exe
"
:
"
"
;
const
FILE_UPDATER_BIN
=
"
updater
"
+
(
AppConstants
.
platform
=
=
"
macosx
"
?
"
.
app
"
:
BIN_SUFFIX
)
;
const
FILE_UPDATER_BIN_BAK
=
FILE_UPDATER_BIN
+
"
.
bak
"
;
const
LOG_FUNCTION
=
info
;
const
MAX_UPDATE_COPY_ATTEMPTS
=
10
;
const
DATA_URI_SPEC
=
"
chrome
:
/
/
mochitests
/
content
/
browser
/
toolkit
/
mozapps
/
update
/
tests
/
browser
/
"
;
Services
.
scriptloader
.
loadSubScript
(
DATA_URI_SPEC
+
"
testConstants
.
js
"
this
)
;
var
gURLData
=
URL_HOST
+
"
/
"
+
REL_PATH_DATA
;
const
URL_MANUAL_UPDATE
=
gURLData
+
"
downloadPage
.
html
"
;
const
gBadSizeResult
=
Cr
.
NS_ERROR_UNEXPECTED
.
toString
(
)
;
Services
.
scriptloader
.
loadSubScript
(
DATA_URI_SPEC
+
"
shared
.
js
"
this
)
;
let
gOriginalUpdateAutoValue
=
null
;
const
gDetailsURL
=
URL_HOST
+
"
/
"
;
const
gDefaultWhatsNewURL
=
URL_HTTP_UPDATE_SJS
+
"
?
uiURL
=
DETAILS
"
;
gDebugTest
=
false
;
requestLongerTimeout
(
10
)
;
add_task
(
async
function
setupTestCommon
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_BADGEWAITTIME
1800
]
[
PREF_APP_UPDATE_DOWNLOAD_ATTEMPTS
0
]
[
PREF_APP_UPDATE_DOWNLOAD_MAXATTEMPTS
2
]
[
PREF_APP_UPDATE_LOG
gDebugTest
]
[
PREF_APP_UPDATE_PROMPTWAITTIME
3600
]
[
PREF_APP_UPDATE_SERVICE_ENABLED
false
]
[
"
browser
.
library
.
activity
-
stream
.
enabled
"
false
]
]
}
)
;
setUpdateTimerPrefs
(
)
;
reloadUpdateManagerData
(
true
)
;
removeUpdateFiles
(
true
)
;
UpdateListener
.
reset
(
)
;
AppMenuNotifications
.
removeNotification
(
/
.
*
/
)
;
await
setAppUpdateAutoEnabledHelper
(
true
)
;
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
AppMenuNotifications
.
removeNotification
(
/
.
*
/
)
;
gEnv
.
set
(
"
MOZ_TEST_SKIP_UPDATE_STAGE
"
"
"
)
;
gEnv
.
set
(
"
MOZ_TEST_SLOW_SKIP_UPDATE_STAGE
"
"
"
)
;
gEnv
.
set
(
"
MOZ_TEST_STAGING_ERROR
"
"
"
)
;
UpdateListener
.
reset
(
)
;
AppMenuNotifications
.
removeNotification
(
/
.
*
/
)
;
reloadUpdateManagerData
(
true
)
;
removeUpdateFiles
(
true
)
;
await
finishTestRestoreUpdaterBackup
(
)
;
}
)
;
async
function
continueFileHandler
(
leafName
)
{
let
interval
=
100
;
let
retries
=
300
;
let
continueFile
;
if
(
leafName
=
=
CONTINUE_STAGING
)
{
interval
=
200
;
retries
=
600
;
continueFile
=
getGREBinDir
(
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
continueFile
=
continueFile
.
parent
.
parent
;
}
continueFile
.
append
(
leafName
)
;
}
else
{
continueFile
=
Services
.
dirsvc
.
get
(
"
CurWorkD
"
Ci
.
nsIFile
)
;
let
continuePath
=
REL_PATH_DATA
+
leafName
;
let
continuePathParts
=
continuePath
.
split
(
"
/
"
)
;
for
(
let
i
=
0
;
i
<
continuePathParts
.
length
;
+
+
i
)
{
continueFile
.
append
(
continuePathParts
[
i
]
)
;
}
}
if
(
continueFile
.
exists
(
)
)
{
logTestInfo
(
"
The
continue
file
should
not
exist
path
:
"
+
continueFile
.
path
)
;
continueFile
.
remove
(
false
)
;
}
debugDump
(
"
Creating
continue
file
path
:
"
+
continueFile
.
path
)
;
continueFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
PERMS_FILE
)
;
registerCleanupFunction
(
(
)
=
>
{
if
(
continueFile
.
exists
(
)
)
{
logTestInfo
(
"
Removing
continue
file
during
test
cleanup
path
:
"
+
continueFile
.
path
)
;
continueFile
.
remove
(
false
)
;
}
}
)
;
return
TestUtils
.
waitForCondition
(
(
)
=
>
!
continueFile
.
exists
(
)
"
Waiting
for
file
to
be
deleted
path
:
"
+
continueFile
.
path
interval
retries
)
.
catch
(
e
=
>
{
logTestInfo
(
"
Continue
file
was
not
removed
after
checking
"
+
retries
+
"
times
path
:
"
+
continueFile
.
path
)
;
}
)
;
}
function
lockWriteTestFile
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
throw
new
Error
(
"
Windows
only
test
function
called
"
)
;
}
let
file
=
getUpdateDirFile
(
FILE_UPDATE_TEST
)
.
QueryInterface
(
Ci
.
nsILocalFileWin
)
;
if
(
file
.
exists
(
)
)
{
file
.
fileAttributesWin
|
=
file
.
WFA_READWRITE
;
file
.
fileAttributesWin
&
=
~
file
.
WFA_READONLY
;
file
.
remove
(
false
)
;
}
file
.
create
(
file
.
NORMAL_FILE_TYPE
0o444
)
;
file
.
fileAttributesWin
|
=
file
.
WFA_READONLY
;
file
.
fileAttributesWin
&
=
~
file
.
WFA_READWRITE
;
registerCleanupFunction
(
(
)
=
>
{
file
.
fileAttributesWin
|
=
file
.
WFA_READWRITE
;
file
.
fileAttributesWin
&
=
~
file
.
WFA_READONLY
;
file
.
remove
(
false
)
;
}
)
;
}
function
setOtherInstanceHandlingUpdates
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
throw
new
Error
(
"
Windows
only
test
function
called
"
)
;
}
gAUS
.
observe
(
null
"
test
-
close
-
handle
-
update
-
mutex
"
"
"
)
;
let
handle
=
createMutex
(
getPerInstallationMutexName
(
)
)
;
registerCleanupFunction
(
(
)
=
>
{
closeHandle
(
handle
)
;
}
)
;
}
function
getVersionParams
(
aAppVersion
)
{
let
appInfo
=
Services
.
appinfo
;
return
"
&
appVersion
=
"
+
(
aAppVersion
?
aAppVersion
:
appInfo
.
version
)
;
}
function
setUpdateTimerPrefs
(
)
{
let
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
-
60
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_LASTUPDATETIME
now
)
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_INTERVAL
43200
)
;
}
async
function
setAppUpdateAutoEnabledHelper
(
enabled
)
{
if
(
gOriginalUpdateAutoValue
=
=
null
)
{
gOriginalUpdateAutoValue
=
await
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
gOriginalUpdateAutoValue
)
;
}
)
;
}
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
enabled
)
;
}
function
getNotificationButton
(
win
notificationId
button
)
{
let
notification
=
win
.
document
.
getElementById
(
appMenu
-
{
notificationId
}
-
notification
)
;
ok
(
!
notification
.
hidden
{
notificationId
}
notification
is
showing
)
;
return
notification
[
button
]
;
}
function
checkWhatsNewLink
(
win
id
url
)
{
let
whatsNewLink
=
win
.
document
.
getElementById
(
id
)
;
ok
(
!
whatsNewLink
.
hidden
"
What
'
s
new
link
is
not
hidden
.
"
)
;
is
(
whatsNewLink
.
href
url
What
'
s
new
link
href
should
equal
{
url
}
)
;
}
function
setupTestUpdater
(
)
{
return
(
async
function
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
)
)
{
try
{
restoreUpdaterBackup
(
)
;
}
catch
(
e
)
{
logTestInfo
(
"
Attempt
to
restore
the
backed
up
updater
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
await
TestUtils
.
waitForTick
(
)
;
await
setupTestUpdater
(
)
;
return
;
}
await
moveRealUpdater
(
)
;
}
}
)
(
)
;
}
function
moveRealUpdater
(
)
{
return
(
async
function
(
)
{
try
{
let
greBinDir
=
getGREBinDir
(
)
;
let
updater
=
greBinDir
.
clone
(
)
;
updater
.
append
(
FILE_UPDATER_BIN
)
;
updater
.
moveTo
(
greBinDir
FILE_UPDATER_BIN_BAK
)
;
let
greDir
=
getGREDir
(
)
;
let
updateSettingsIni
=
greDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI
)
;
if
(
updateSettingsIni
.
exists
(
)
)
{
updateSettingsIni
.
moveTo
(
greDir
FILE_UPDATE_SETTINGS_INI_BAK
)
;
}
let
precomplete
=
greDir
.
clone
(
)
;
precomplete
.
append
(
FILE_PRECOMPLETE
)
;
if
(
precomplete
.
exists
(
)
)
{
precomplete
.
moveTo
(
greDir
FILE_PRECOMPLETE_BAK
)
;
}
}
catch
(
e
)
{
logTestInfo
(
"
Attempt
to
move
the
real
updater
out
of
the
way
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
await
TestUtils
.
waitForTick
(
)
;
await
moveRealUpdater
(
)
;
return
;
}
await
copyTestUpdater
(
)
;
}
)
(
)
;
}
function
copyTestUpdater
(
attempt
=
0
)
{
return
(
async
function
(
)
{
try
{
let
greBinDir
=
getGREBinDir
(
)
;
let
testUpdaterDir
=
Services
.
dirsvc
.
get
(
"
CurWorkD
"
Ci
.
nsIFile
)
;
let
relPath
=
REL_PATH_DATA
;
let
pathParts
=
relPath
.
split
(
"
/
"
)
;
for
(
let
i
=
0
;
i
<
pathParts
.
length
;
+
+
i
)
{
testUpdaterDir
.
append
(
pathParts
[
i
]
)
;
}
let
testUpdater
=
testUpdaterDir
.
clone
(
)
;
testUpdater
.
append
(
FILE_UPDATER_BIN
)
;
testUpdater
.
copyToFollowingLinks
(
greBinDir
FILE_UPDATER_BIN
)
;
let
greDir
=
getGREDir
(
)
;
let
updateSettingsIni
=
greDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI
)
;
writeFile
(
updateSettingsIni
UPDATE_SETTINGS_CONTENTS
)
;
let
precomplete
=
greDir
.
clone
(
)
;
precomplete
.
append
(
FILE_PRECOMPLETE
)
;
writeFile
(
precomplete
PRECOMPLETE_CONTENTS
)
;
}
catch
(
e
)
{
if
(
attempt
<
MAX_UPDATE_COPY_ATTEMPTS
)
{
logTestInfo
(
"
Attempt
to
copy
the
test
updater
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
await
TestUtils
.
waitForTick
(
)
;
await
copyTestUpdater
(
attempt
+
+
)
;
}
}
}
)
(
)
;
}
function
restoreUpdaterBackup
(
)
{
let
greBinDir
=
getGREBinDir
(
)
;
let
updater
=
greBinDir
.
clone
(
)
;
let
updaterBackup
=
greBinDir
.
clone
(
)
;
updater
.
append
(
FILE_UPDATER_BIN
)
;
updaterBackup
.
append
(
FILE_UPDATER_BIN_BAK
)
;
if
(
updaterBackup
.
exists
(
)
)
{
if
(
updater
.
exists
(
)
)
{
updater
.
remove
(
true
)
;
}
updaterBackup
.
moveTo
(
greBinDir
FILE_UPDATER_BIN
)
;
}
let
greDir
=
getGREDir
(
)
;
let
updateSettingsIniBackup
=
greDir
.
clone
(
)
;
updateSettingsIniBackup
.
append
(
FILE_UPDATE_SETTINGS_INI_BAK
)
;
if
(
updateSettingsIniBackup
.
exists
(
)
)
{
let
updateSettingsIni
=
greDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI
)
;
if
(
updateSettingsIni
.
exists
(
)
)
{
updateSettingsIni
.
remove
(
false
)
;
}
updateSettingsIniBackup
.
moveTo
(
greDir
FILE_UPDATE_SETTINGS_INI
)
;
}
let
precomplete
=
greDir
.
clone
(
)
;
let
precompleteBackup
=
greDir
.
clone
(
)
;
precomplete
.
append
(
FILE_PRECOMPLETE
)
;
precompleteBackup
.
append
(
FILE_PRECOMPLETE_BAK
)
;
if
(
precompleteBackup
.
exists
(
)
)
{
if
(
precomplete
.
exists
(
)
)
{
precomplete
.
remove
(
false
)
;
}
precompleteBackup
.
moveTo
(
greDir
FILE_PRECOMPLETE
)
;
}
else
if
(
precomplete
.
exists
(
)
)
{
if
(
readFile
(
precomplete
)
=
=
PRECOMPLETE_CONTENTS
)
{
precomplete
.
remove
(
false
)
;
}
}
}
function
finishTestRestoreUpdaterBackup
(
)
{
return
(
async
function
(
)
{
try
{
restoreUpdaterBackup
(
)
;
}
catch
(
e
)
{
logTestInfo
(
"
Attempt
to
restore
the
backed
up
updater
failed
.
.
.
"
+
"
will
try
again
Exception
:
"
+
e
)
;
await
TestUtils
.
waitForTick
(
)
;
await
finishTestRestoreUpdaterBackup
(
)
;
}
}
)
(
)
;
}
function
waitForAboutDialog
(
)
{
return
new
Promise
(
resolve
=
>
{
var
listener
=
{
onOpenWindow
:
aXULWindow
=
>
{
debugDump
(
"
About
dialog
shown
.
.
.
"
)
;
Services
.
wm
.
removeListener
(
listener
)
;
async
function
aboutDialogOnLoad
(
)
{
domwindow
.
removeEventListener
(
"
load
"
aboutDialogOnLoad
true
)
;
let
chromeURI
=
"
chrome
:
/
/
browser
/
content
/
aboutDialog
.
xul
"
;
is
(
domwindow
.
document
.
location
.
href
chromeURI
"
About
dialog
appeared
"
)
;
resolve
(
domwindow
)
;
}
var
domwindow
=
aXULWindow
.
docShell
.
domWindow
;
domwindow
.
addEventListener
(
"
load
"
aboutDialogOnLoad
true
)
;
}
onCloseWindow
:
aXULWindow
=
>
{
}
}
;
Services
.
wm
.
addListener
(
listener
)
;
openAboutDialog
(
)
;
}
)
;
}
function
getPatchOfType
(
type
)
{
let
update
=
gUpdateManager
.
activeUpdate
;
if
(
update
)
{
for
(
let
i
=
0
;
i
<
update
.
patchCount
;
+
+
i
)
{
let
patch
=
update
.
getPatchAt
(
i
)
;
if
(
patch
&
&
patch
.
type
=
=
type
)
{
return
patch
;
}
}
}
return
null
;
}
function
runDoorhangerUpdateTest
(
params
steps
)
{
function
processDoorhangerStep
(
step
)
{
if
(
typeof
step
=
=
"
function
"
)
{
return
step
(
)
;
}
const
{
notificationId
button
checkActiveUpdate
pageURLs
}
=
step
;
return
(
async
function
(
)
{
await
BrowserTestUtils
.
waitForEvent
(
PanelUI
.
notificationPanel
"
popupshown
"
)
;
const
shownNotificationId
=
AppMenuNotifications
.
activeNotification
.
id
;
is
(
shownNotificationId
notificationId
"
The
right
notification
showed
up
.
"
)
;
if
(
checkActiveUpdate
)
{
ok
(
!
!
gUpdateManager
.
activeUpdate
"
There
should
be
an
active
update
"
)
;
is
(
gUpdateManager
.
activeUpdate
.
state
checkActiveUpdate
.
state
The
active
update
state
should
equal
{
checkActiveUpdate
.
state
}
)
;
}
else
{
ok
(
!
gUpdateManager
.
activeUpdate
"
There
should
not
be
an
active
update
"
)
;
}
if
(
pageURLs
&
&
pageURLs
.
whatsNew
!
=
=
undefined
)
{
checkWhatsNewLink
(
window
{
notificationId
}
-
whats
-
new
pageURLs
.
whatsNew
)
;
}
let
buttonEl
=
getNotificationButton
(
window
notificationId
button
)
;
buttonEl
.
click
(
)
;
if
(
pageURLs
&
&
pageURLs
.
manual
!
=
=
undefined
)
{
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
is
(
gBrowser
.
selectedBrowser
.
currentURI
.
spec
pageURLs
.
manual
The
page
'
s
url
should
equal
{
pageURLs
.
manual
}
)
;
gBrowser
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
}
)
(
)
;
}
return
(
async
function
(
)
{
gEnv
.
set
(
"
MOZ_TEST_SKIP_UPDATE_STAGE
"
"
1
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_DISABLEDFORTESTING
false
]
[
PREF_APP_UPDATE_URL_DETAILS
gDetailsURL
]
[
PREF_APP_UPDATE_URL_MANUAL
URL_MANUAL_UPDATE
]
]
}
)
;
await
setupTestUpdater
(
)
;
let
queryString
=
params
.
queryString
?
params
.
queryString
:
"
"
;
let
updateURL
=
URL_HTTP_UPDATE_SJS
+
"
?
detailsURL
=
"
+
gDetailsURL
+
queryString
+
getVersionParams
(
)
;
setUpdateURL
(
updateURL
)
;
if
(
params
.
checkAttempts
)
{
executeSoon
(
(
)
=
>
{
(
async
function
(
)
{
gAUS
.
checkForBackgroundUpdates
(
)
;
for
(
var
i
=
0
;
i
<
params
.
checkAttempts
-
1
;
i
+
+
)
{
await
waitForEvent
(
"
update
-
error
"
"
check
-
attempt
-
failed
"
)
;
gAUS
.
checkForBackgroundUpdates
(
)
;
}
}
)
(
)
;
}
)
;
}
else
{
writeStatusFile
(
STATE_FAILED_CRC_ERROR
)
;
writeUpdatesToXMLFile
(
getLocalUpdatesXMLString
(
params
.
updates
)
true
)
;
reloadUpdateManagerData
(
)
;
testPostUpdateProcessing
(
)
;
}
for
(
let
step
of
steps
)
{
await
processDoorhangerStep
(
step
)
;
}
}
)
(
)
;
}
function
runAboutDialogUpdateTest
(
params
steps
)
{
let
aboutDialog
;
function
processAboutDialogStep
(
step
)
{
if
(
typeof
step
=
=
"
function
"
)
{
return
step
(
)
;
}
const
{
panelId
checkActiveUpdate
continueFile
downloadInfo
}
=
step
;
return
(
async
function
(
)
{
let
updateDeck
=
aboutDialog
.
document
.
getElementById
(
"
updateDeck
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
updateDeck
.
selectedPanel
&
&
(
updateDeck
.
selectedPanel
.
id
=
=
panelId
|
|
updateDeck
.
selectedPanel
.
id
=
=
"
apply
"
)
"
Waiting
for
the
expected
panel
ID
:
"
+
panelId
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
let
selectedPanel
=
updateDeck
.
selectedPanel
;
is
(
selectedPanel
.
id
panelId
"
The
panel
ID
should
equal
"
+
panelId
)
;
if
(
checkActiveUpdate
)
{
ok
(
!
!
gUpdateManager
.
activeUpdate
"
There
should
be
an
active
update
"
)
;
is
(
gUpdateManager
.
activeUpdate
.
state
checkActiveUpdate
.
state
"
The
active
update
state
should
equal
"
+
checkActiveUpdate
.
state
)
;
}
else
{
ok
(
!
gUpdateManager
.
activeUpdate
"
There
should
not
be
an
active
update
"
)
;
}
if
(
panelId
=
=
"
downloading
"
)
{
for
(
let
i
=
0
;
i
<
downloadInfo
.
length
;
+
+
i
)
{
let
data
=
downloadInfo
[
i
]
;
await
continueFileHandler
(
continueFile
)
;
let
patch
=
getPatchOfType
(
data
.
patchType
)
;
let
isLastPatch
=
i
=
=
downloadInfo
.
length
-
1
;
if
(
!
isLastPatch
|
|
patch
)
{
let
resultName
=
data
.
bitsResult
?
"
bitsResult
"
:
"
internalResult
"
;
patch
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
patch
.
getProperty
(
resultName
)
=
=
data
[
resultName
]
"
Waiting
for
expected
patch
property
"
+
resultName
+
"
value
:
"
+
data
[
resultName
]
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
is
(
patch
.
getProperty
(
resultName
)
data
[
resultName
]
"
The
patch
property
"
+
resultName
+
"
value
should
equal
"
+
data
[
resultName
]
)
;
}
}
}
else
if
(
continueFile
)
{
await
continueFileHandler
(
continueFile
)
;
}
let
linkPanels
=
[
"
downloadFailed
"
"
manualUpdate
"
"
unsupportedSystem
"
]
;
if
(
linkPanels
.
includes
(
panelId
)
)
{
let
link
=
selectedPanel
.
querySelector
(
"
label
.
text
-
link
"
)
;
is
(
link
.
href
gDetailsURL
The
panel
'
s
link
href
should
equal
{
gDetailsURL
}
)
;
}
let
buttonPanels
=
[
"
downloadAndInstall
"
"
apply
"
]
;
if
(
buttonPanels
.
includes
(
panelId
)
)
{
let
buttonEl
=
selectedPanel
.
querySelector
(
"
button
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
aboutDialog
.
document
.
activeElement
=
=
buttonEl
"
The
button
should
receive
focus
"
)
;
ok
(
!
buttonEl
.
disabled
"
The
button
should
be
enabled
"
)
;
if
(
panelId
!
=
"
apply
"
)
{
buttonEl
.
click
(
)
;
}
}
}
)
(
)
;
}
return
(
async
function
(
)
{
gEnv
.
set
(
"
MOZ_TEST_SLOW_SKIP_UPDATE_STAGE
"
"
1
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_DISABLEDFORTESTING
false
]
[
PREF_APP_UPDATE_URL_MANUAL
gDetailsURL
]
]
}
)
;
await
setupTestUpdater
(
)
;
let
queryString
=
params
.
queryString
?
params
.
queryString
:
"
"
;
let
updateURL
=
URL_HTTP_UPDATE_SJS
+
"
?
detailsURL
=
"
+
gDetailsURL
+
queryString
+
getVersionParams
(
)
;
if
(
params
.
backgroundUpdate
)
{
setUpdateURL
(
updateURL
)
;
gAUS
.
checkForBackgroundUpdates
(
)
;
if
(
params
.
continueFile
)
{
await
continueFileHandler
(
params
.
continueFile
)
;
}
if
(
params
.
waitForUpdateState
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
gUpdateManager
.
activeUpdate
&
&
gUpdateManager
.
activeUpdate
.
state
=
=
params
.
waitForUpdateState
"
Waiting
for
update
state
:
"
+
params
.
waitForUpdateState
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
is
(
gUpdateManager
.
activeUpdate
.
state
params
.
waitForUpdateState
"
The
update
state
value
should
equal
"
+
params
.
waitForUpdateState
)
;
}
}
else
{
updateURL
+
=
"
&
slowUpdateCheck
=
1
&
useSlowDownloadMar
=
1
"
;
setUpdateURL
(
updateURL
)
;
}
aboutDialog
=
await
waitForAboutDialog
(
)
;
registerCleanupFunction
(
(
)
=
>
{
aboutDialog
.
close
(
)
;
}
)
;
for
(
let
step
of
steps
)
{
await
processAboutDialogStep
(
step
)
;
}
}
)
(
)
;
}
function
runAboutPrefsUpdateTest
(
params
steps
)
{
let
tab
;
function
processAboutPrefsStep
(
step
)
{
if
(
typeof
step
=
=
"
function
"
)
{
return
step
(
)
;
}
const
{
panelId
checkActiveUpdate
continueFile
downloadInfo
}
=
step
;
return
(
async
function
(
)
{
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
panelId
}
async
(
{
panelId
}
)
=
>
{
let
updateDeck
=
content
.
document
.
getElementById
(
"
updateDeck
"
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
updateDeck
.
selectedPanel
&
&
(
updateDeck
.
selectedPanel
.
id
=
=
panelId
|
|
updateDeck
.
selectedPanel
.
id
=
=
"
apply
"
)
"
Waiting
for
the
expected
panel
ID
:
"
+
panelId
undefined
200
)
.
catch
(
e
=
>
{
info
(
e
)
;
}
)
;
is
(
updateDeck
.
selectedPanel
.
id
panelId
"
The
panel
ID
should
equal
"
+
panelId
)
;
}
)
;
if
(
checkActiveUpdate
)
{
ok
(
!
!
gUpdateManager
.
activeUpdate
"
There
should
be
an
active
update
"
)
;
is
(
gUpdateManager
.
activeUpdate
.
state
checkActiveUpdate
.
state
"
The
active
update
state
should
equal
"
+
checkActiveUpdate
.
state
)
;
}
else
{
ok
(
!
gUpdateManager
.
activeUpdate
"
There
should
not
be
an
active
update
"
)
;
}
if
(
panelId
=
=
"
downloading
"
)
{
for
(
let
i
=
0
;
i
<
downloadInfo
.
length
;
+
+
i
)
{
let
data
=
downloadInfo
[
i
]
;
await
continueFileHandler
(
continueFile
)
;
let
patch
=
getPatchOfType
(
data
.
patchType
)
;
let
isLastPatch
=
i
=
=
downloadInfo
.
length
-
1
;
if
(
!
isLastPatch
|
|
patch
)
{
let
resultName
=
data
.
bitsResult
?
"
bitsResult
"
:
"
internalResult
"
;
patch
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
patch
.
getProperty
(
resultName
)
=
=
data
[
resultName
]
"
Waiting
for
expected
patch
property
"
+
resultName
+
"
value
:
"
+
data
[
resultName
]
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
is
(
patch
.
getProperty
(
resultName
)
data
[
resultName
]
"
The
patch
property
"
+
resultName
+
"
value
should
equal
"
+
data
[
resultName
]
)
;
}
}
}
else
if
(
continueFile
)
{
await
continueFileHandler
(
continueFile
)
;
}
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
panelId
gDetailsURL
}
async
(
{
panelId
gDetailsURL
}
)
=
>
{
let
linkPanels
=
[
"
downloadFailed
"
"
manualUpdate
"
"
unsupportedSystem
"
]
;
if
(
linkPanels
.
includes
(
panelId
)
)
{
let
selectedPanel
=
content
.
document
.
getElementById
(
"
updateDeck
"
)
.
selectedPanel
;
let
selector
=
"
label
.
text
-
link
"
;
if
(
selectedPanel
.
id
=
=
"
downloadFailed
"
)
{
selector
=
"
a
.
text
-
link
"
;
}
let
link
=
selectedPanel
.
querySelector
(
selector
)
;
is
(
link
.
href
gDetailsURL
The
panel
'
s
link
href
should
equal
{
gDetailsURL
}
)
;
}
let
buttonPanels
=
[
"
downloadAndInstall
"
"
apply
"
]
;
if
(
buttonPanels
.
includes
(
panelId
)
)
{
let
selectedPanel
=
content
.
document
.
getElementById
(
"
updateDeck
"
)
.
selectedPanel
;
let
buttonEl
=
selectedPanel
.
querySelector
(
"
button
"
)
;
ok
(
!
buttonEl
.
disabled
"
The
button
should
be
enabled
"
)
;
if
(
selectedPanel
.
id
!
=
"
apply
"
)
{
buttonEl
.
click
(
)
;
}
}
}
)
;
}
)
(
)
;
}
return
(
async
function
(
)
{
gEnv
.
set
(
"
MOZ_TEST_SLOW_SKIP_UPDATE_STAGE
"
"
1
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_DISABLEDFORTESTING
false
]
[
PREF_APP_UPDATE_URL_MANUAL
gDetailsURL
]
]
}
)
;
await
setupTestUpdater
(
)
;
let
queryString
=
params
.
queryString
?
params
.
queryString
:
"
"
;
let
updateURL
=
URL_HTTP_UPDATE_SJS
+
"
?
detailsURL
=
"
+
gDetailsURL
+
queryString
+
getVersionParams
(
)
;
if
(
params
.
backgroundUpdate
)
{
setUpdateURL
(
updateURL
)
;
gAUS
.
checkForBackgroundUpdates
(
)
;
if
(
params
.
continueFile
)
{
await
continueFileHandler
(
params
.
continueFile
)
;
}
if
(
params
.
waitForUpdateState
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
gUpdateManager
.
activeUpdate
&
&
gUpdateManager
.
activeUpdate
.
state
=
=
params
.
waitForUpdateState
"
Waiting
for
update
state
:
"
+
params
.
waitForUpdateState
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
is
(
gUpdateManager
.
activeUpdate
.
state
params
.
waitForUpdateState
"
The
update
state
value
should
equal
"
+
params
.
waitForUpdateState
)
;
}
}
else
{
updateURL
+
=
"
&
slowUpdateCheck
=
1
&
useSlowDownloadMar
=
1
"
;
setUpdateURL
(
updateURL
)
;
}
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
preferences
"
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
null
async
(
)
=
>
{
content
.
document
.
getElementById
(
"
updatesCategory
"
)
.
scrollIntoView
(
)
;
}
)
;
for
(
let
step
of
steps
)
{
await
processAboutPrefsStep
(
step
)
;
}
}
)
(
)
;
}
function
removeUpdateSettingsIni
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
)
)
{
let
greDir
=
getGREDir
(
)
;
let
updateSettingsIniBak
=
greDir
.
clone
(
)
;
updateSettingsIniBak
.
append
(
FILE_UPDATE_SETTINGS_INI_BAK
)
;
if
(
updateSettingsIniBak
.
exists
(
)
)
{
let
updateSettingsIni
=
greDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI
)
;
updateSettingsIni
.
remove
(
false
)
;
}
}
}
function
runTelemetryUpdateTest
(
updateParams
event
stageFailure
=
false
)
{
return
(
async
function
(
)
{
Services
.
telemetry
.
clearScalars
(
)
;
gEnv
.
set
(
"
MOZ_TEST_SKIP_UPDATE_STAGE
"
"
1
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_DISABLEDFORTESTING
false
]
]
}
)
;
await
setupTestUpdater
(
)
;
if
(
stageFailure
)
{
removeUpdateSettingsIni
(
)
;
}
let
updateURL
=
URL_HTTP_UPDATE_SJS
+
"
?
detailsURL
=
"
+
gDetailsURL
+
updateParams
+
getVersionParams
(
)
;
setUpdateURL
(
updateURL
)
;
gAUS
.
checkForBackgroundUpdates
(
)
;
await
waitForEvent
(
event
)
;
}
)
(
)
;
}
function
getTelemetryUpdatePhaseValues
(
overrides
)
{
let
bitsEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_BITS_ENABLED
)
;
if
(
overrides
.
noPartialPatch
)
{
if
(
!
overrides
.
noInternalPartial
)
{
overrides
.
noInternalPartial
=
true
;
}
if
(
!
overrides
.
noBitsPartial
)
{
overrides
.
noBitsPartial
=
true
;
}
}
if
(
overrides
.
noCompletePatch
)
{
if
(
!
overrides
.
noInternalComplete
)
{
overrides
.
noInternalComplete
=
true
;
}
if
(
!
overrides
.
noBitsComplete
)
{
overrides
.
noBitsComplete
=
true
;
}
}
if
(
overrides
.
noPartialPatch
|
|
overrides
.
partialBadSize
|
|
overrides
.
noInternalPartial
|
|
overrides
.
noBitsPartial
)
{
if
(
!
overrides
.
noStagePartial
)
{
overrides
.
noStagePartial
=
true
;
}
if
(
!
overrides
.
noApplyPartial
)
{
overrides
.
noApplyPartial
=
true
;
}
}
if
(
overrides
.
noCompletePatch
|
|
overrides
.
completeBadSize
|
|
overrides
.
noInternalComplete
|
|
overrides
.
noBitsComplete
)
{
if
(
!
overrides
.
noStageComplete
)
{
overrides
.
noStageComplete
=
true
;
}
if
(
!
overrides
.
noApplyComplete
)
{
overrides
.
noApplyComplete
=
true
;
}
}
if
(
!
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
)
)
{
if
(
!
overrides
.
noStagePartial
)
{
overrides
.
noStagePartial
=
true
;
}
if
(
!
overrides
.
noStageComplete
)
{
overrides
.
noStageComplete
=
true
;
}
}
let
marSize
=
parseInt
(
SIZE_SIMPLE_MAR
)
;
let
partialSize
=
overrides
.
partialBadSize
?
parseInt
(
SIZE_SIMPLE_MAR
+
"
1
"
)
:
marSize
;
let
completeSize
=
overrides
.
completeBadSize
?
parseInt
(
SIZE_SIMPLE_MAR
+
"
1
"
)
:
marSize
;
let
partialDownloadBytes
=
overrides
.
partialBadSize
?
1
:
marSize
;
let
completeDownloadBytes
=
overrides
.
completeBadSize
?
1
:
marSize
;
let
obj
=
{
}
;
obj
.
basePrefix
=
overrides
.
forSession
?
"
update
.
session
.
"
:
"
update
.
startup
.
"
;
obj
.
from_app_version
=
Services
.
appinfo
.
version
;
obj
.
mars
=
{
}
;
obj
.
mars
.
mar_partial_size_bytes
=
overrides
.
noPartialPatch
?
null
:
partialSize
;
obj
.
mars
.
mar_complete_size_bytes
=
overrides
.
noCompletePatch
?
null
:
completeSize
;
obj
.
intervals
=
{
}
;
obj
.
intervals
.
check
=
1
;
if
(
bitsEnabled
)
{
obj
.
intervals
.
download_bits_partial
=
overrides
.
noBitsPartial
?
null
:
1
;
obj
.
intervals
.
download_bits_complete
=
overrides
.
noBitsComplete
?
null
:
1
;
if
(
overrides
.
partialBadSize
)
{
obj
.
intervals
.
download_internal_partial
=
overrides
.
noInternalPartial
?
null
:
1
;
}
else
{
obj
.
intervals
.
download_internal_partial
=
null
;
}
if
(
overrides
.
completeBadSize
)
{
obj
.
intervals
.
download_internal_complete
=
overrides
.
noInternalComplete
?
null
:
1
;
}
else
{
obj
.
intervals
.
download_internal_complete
=
null
;
}
}
else
{
obj
.
intervals
.
download_bits_partial
=
null
;
obj
.
intervals
.
download_bits_complete
=
null
;
obj
.
intervals
.
download_internal_partial
=
overrides
.
noInternalPartial
?
null
:
1
;
obj
.
intervals
.
download_internal_complete
=
overrides
.
noInternalComplete
?
null
:
1
;
}
obj
.
intervals
.
stage_partial
=
overrides
.
noStagePartial
?
null
:
1
;
obj
.
intervals
.
stage_complete
=
overrides
.
noStageComplete
?
null
:
1
;
obj
.
intervals
.
apply_partial
=
overrides
.
noApplyPartial
?
null
:
1
;
obj
.
intervals
.
apply_complete
=
overrides
.
noApplyComplete
?
null
:
1
;
obj
.
downloads
=
{
}
;
obj
.
downloads
.
bits_partial_
=
{
}
;
obj
.
downloads
.
bits_complete_
=
{
}
;
obj
.
downloads
.
internal_partial_
=
{
}
;
obj
.
downloads
.
internal_complete_
=
{
}
;
if
(
bitsEnabled
)
{
obj
.
downloads
.
bits_partial_
.
bytes
=
overrides
.
noBitsPartial
?
null
:
partialDownloadBytes
;
obj
.
downloads
.
bits_partial_
.
seconds
=
overrides
.
noBitsPartial
?
null
:
1
;
obj
.
downloads
.
bits_complete_
.
bytes
=
overrides
.
noBitsComplete
?
null
:
completeDownloadBytes
;
obj
.
downloads
.
bits_complete_
.
seconds
=
overrides
.
noBitsComplete
?
null
:
1
;
if
(
overrides
.
partialBadSize
)
{
obj
.
downloads
.
internal_partial_
.
seconds
=
overrides
.
noInternalPartial
?
null
:
1
;
obj
.
downloads
.
internal_partial_
.
bytes
=
overrides
.
noInternalPartial
?
null
:
partialDownloadBytes
;
}
else
{
obj
.
downloads
.
internal_partial_
.
bytes
=
null
;
obj
.
downloads
.
internal_partial_
.
seconds
=
null
;
}
if
(
overrides
.
completeBadSize
)
{
obj
.
downloads
.
internal_complete_
.
seconds
=
overrides
.
noInternalComplete
?
null
:
1
;
obj
.
downloads
.
internal_complete_
.
bytes
=
overrides
.
noInternalComplete
?
null
:
completeDownloadBytes
;
}
else
{
obj
.
downloads
.
internal_complete_
.
bytes
=
null
;
obj
.
downloads
.
internal_complete_
.
seconds
=
null
;
}
}
else
{
obj
.
downloads
.
bits_partial_
.
bytes
=
null
;
obj
.
downloads
.
bits_partial_
.
seconds
=
null
;
obj
.
downloads
.
bits_complete_
.
bytes
=
null
;
obj
.
downloads
.
bits_complete_
.
seconds
=
null
;
obj
.
downloads
.
internal_partial_
.
bytes
=
overrides
.
noInternalPartial
?
null
:
partialDownloadBytes
;
obj
.
downloads
.
internal_partial_
.
seconds
=
overrides
.
noInternalPartial
?
null
:
1
;
obj
.
downloads
.
internal_complete_
.
bytes
=
overrides
.
noInternalComplete
?
null
:
completeDownloadBytes
;
obj
.
downloads
.
internal_complete_
.
seconds
=
overrides
.
noInternalComplete
?
null
:
1
;
}
return
obj
;
}
function
checkTelemetryUpdatePhases
(
expected
)
{
let
scalars
=
TelemetryTestUtils
.
getProcessScalars
(
"
parent
"
)
;
let
basePrefix
=
expected
.
basePrefix
;
let
namePrefix
=
basePrefix
;
{
let
name
=
namePrefix
+
"
from_app_version
"
;
if
(
expected
.
from_app_version
)
{
Assert
.
ok
(
!
!
scalars
[
name
]
"
The
"
+
name
+
"
value
should
exist
.
"
)
;
Assert
.
equal
(
scalars
[
name
]
expected
.
from_app_version
"
The
"
+
name
+
"
value
should
equal
the
expected
value
.
"
)
;
}
else
{
Assert
.
ok
(
!
scalars
[
name
]
"
The
"
+
name
+
"
value
should
not
exist
.
"
)
;
}
}
for
(
let
[
nameSuffix
value
]
of
Object
.
entries
(
expected
.
mars
)
)
{
let
name
=
namePrefix
+
nameSuffix
;
if
(
value
)
{
Assert
.
ok
(
!
!
scalars
[
name
]
"
The
"
+
name
+
"
value
should
exist
.
"
)
;
Assert
.
equal
(
scalars
[
name
]
value
"
The
"
+
name
+
"
value
should
equal
the
expected
value
.
"
)
;
}
else
{
Assert
.
ok
(
!
scalars
[
name
]
"
The
"
+
name
+
"
value
should
not
exist
.
"
)
;
}
}
namePrefix
=
basePrefix
+
"
intervals
.
"
;
for
(
let
[
suffix
value
]
of
Object
.
entries
(
expected
.
intervals
)
)
{
let
name
=
namePrefix
+
suffix
;
if
(
value
)
{
Assert
.
ok
(
!
!
scalars
[
name
]
"
The
"
+
name
+
"
value
should
exist
.
"
)
;
Assert
.
greaterOrEqual
(
scalars
[
name
]
value
"
The
"
+
name
+
"
value
should
be
equal
to
or
"
+
"
greater
than
"
+
value
+
"
.
"
)
;
}
else
{
Assert
.
ok
(
!
scalars
[
name
]
"
The
"
+
name
+
"
value
should
not
exist
.
"
)
;
}
}
namePrefix
=
basePrefix
+
"
downloads
.
"
;
for
(
let
[
nameMid
values
]
of
Object
.
entries
(
expected
.
downloads
)
)
{
let
name
=
namePrefix
+
nameMid
+
"
bytes
"
;
if
(
values
.
bytes
)
{
Assert
.
ok
(
!
!
scalars
[
name
]
"
The
"
+
name
+
"
value
should
exist
.
"
)
;
Assert
.
greaterOrEqual
(
scalars
[
name
]
values
.
bytes
"
The
"
+
name
+
"
value
should
be
equal
to
or
"
+
"
greater
than
"
+
values
.
bytes
+
"
.
"
)
;
}
else
{
Assert
.
ok
(
!
scalars
[
name
]
"
The
"
+
name
+
"
value
should
not
exist
.
"
)
;
}
name
=
namePrefix
+
nameMid
+
"
seconds
"
;
if
(
values
.
seconds
)
{
Assert
.
ok
(
!
!
scalars
[
name
]
"
The
"
+
name
+
"
value
should
exist
.
"
)
;
Assert
.
greaterOrEqual
(
scalars
[
name
]
values
.
seconds
"
The
"
+
name
+
"
value
should
be
equal
to
or
"
+
"
greater
than
"
+
values
.
seconds
+
"
.
"
)
;
}
else
{
Assert
.
ok
(
!
scalars
[
name
]
"
The
"
+
name
+
"
value
should
not
exist
.
"
)
;
}
}
}
function
checkTelemetryUpdatePhaseEmpty
(
isStartup
)
{
let
scalars
=
TelemetryTestUtils
.
getProcessScalars
(
"
parent
"
)
;
let
name
=
"
update
.
"
+
(
isStartup
?
"
startup
"
:
"
session
"
)
+
"
.
from_app_version
"
;
Assert
.
ok
(
!
scalars
[
name
]
"
The
"
+
name
+
"
value
should
not
exist
.
"
)
;
}
