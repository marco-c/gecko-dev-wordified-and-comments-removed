"
use
strict
"
;
const
FIRST_UPDATE_VERSION
=
"
999998
.
0
"
;
const
SECOND_UPDATE_VERSION
=
"
999999
.
0
"
;
function
prepareToDownloadVersion
(
version
)
{
setUpdateURL
(
URL_HTTP_UPDATE_SJS
+
?
detailsURL
=
{
gDetailsURL
}
&
promptWaitTime
=
0
&
appVersion
=
{
version
}
)
;
}
add_task
(
async
function
doorhanger_bc_multiUpdate
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_STAGING_ENABLED
true
]
]
}
)
;
let
params
=
{
checkAttempts
:
1
queryString
:
"
&
promptWaitTime
=
0
"
version
:
FIRST_UPDATE_VERSION
slowStaging
:
true
}
;
await
runDoorhangerUpdateTest
(
params
[
(
)
=
>
{
return
continueFileHandler
(
CONTINUE_STAGING
)
;
}
{
notificationId
:
"
update
-
restart
"
button
:
"
secondaryButton
"
checkActiveUpdate
:
{
state
:
STATE_APPLIED
}
}
async
(
)
=
>
{
is
(
PanelUI
.
menuButton
.
getAttribute
(
"
badge
-
status
"
)
"
update
-
restart
"
"
Should
have
restart
badge
"
)
;
prepareToDownloadVersion
(
SECOND_UPDATE_VERSION
)
;
let
updateSwapped
=
waitForEvent
(
"
update
-
swap
"
)
;
gAUS
.
checkForBackgroundUpdates
(
)
;
await
updateSwapped
;
await
TestUtils
.
waitForTick
(
)
;
is
(
PanelUI
.
menuButton
.
getAttribute
(
"
badge
-
status
"
)
null
"
Should
not
have
restart
badge
during
staging
"
)
;
await
continueFileHandler
(
CONTINUE_STAGING
)
;
try
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
PanelUI
.
menuButton
.
getAttribute
(
"
badge
-
status
"
)
=
=
"
update
-
restart
"
"
Waiting
for
update
restart
badge
to
return
after
staging
"
)
;
}
catch
(
ex
)
{
}
is
(
PanelUI
.
menuButton
.
getAttribute
(
"
badge
-
status
"
)
"
update
-
restart
"
"
Restart
badge
should
be
restored
after
staging
completes
"
)
;
is
(
PanelUI
.
notificationPanel
.
state
"
closed
"
"
Should
not
open
a
second
doorhanger
"
)
;
}
]
)
;
}
)
;
