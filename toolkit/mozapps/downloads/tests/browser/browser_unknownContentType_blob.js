"
use
strict
"
;
const
UCT_URI
=
"
chrome
:
/
/
mozapps
/
content
/
downloads
/
unknownContentType
.
xhtml
"
;
async
function
promiseDownloadFinished
(
list
)
{
return
new
Promise
(
resolve
=
>
{
list
.
addView
(
{
onDownloadChanged
(
download
)
{
info
(
"
Download
changed
!
"
)
;
if
(
download
.
succeeded
|
|
download
.
error
)
{
info
(
"
Download
succeeded
or
errored
"
)
;
list
.
removeView
(
this
)
;
resolve
(
download
)
;
}
}
}
)
;
}
)
;
}
add_task
(
async
function
test_check_blob_origin_representation
(
)
{
forcePromptForFiles
(
"
text
/
plain
"
"
txt
"
)
;
await
check_blob_origin
(
"
https
:
/
/
example
.
org
/
1
"
"
https
:
/
/
example
.
org
"
"
example
.
org
"
)
;
await
check_blob_origin
(
"
data
:
text
/
html
<
body
>
Some
Text
<
br
>
"
"
blob
:
"
"
blob
"
)
;
}
)
;
async
function
check_blob_origin
(
pageURL
expectedSource
expectedListOrigin
)
{
await
BrowserTestUtils
.
withNewTab
(
pageURL
async
browser
=
>
{
let
downloadList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
downloadPromise
=
promiseDownloadFinished
(
downloadList
)
;
let
dialogPromise
=
BrowserTestUtils
.
domWindowOpenedAndLoaded
(
null
win
=
>
win
.
document
.
documentURI
=
=
UCT_URI
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
(
)
=
>
{
let
url
=
content
.
eval
(
window
.
foo
=
new
Blob
(
[
"
Hello
"
]
{
type
:
"
text
/
plain
"
}
)
;
URL
.
createObjectURL
(
window
.
foo
)
)
;
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
href
=
url
;
link
.
textContent
=
"
Click
me
click
me
me
me
me
"
;
link
.
download
=
"
my
-
file
.
txt
"
;
content
.
document
.
body
.
append
(
link
)
;
link
.
click
(
)
;
}
)
;
let
dialogWin
=
await
dialogPromise
;
let
source
=
dialogWin
.
document
.
getElementById
(
"
source
"
)
;
is
(
source
.
value
expectedSource
"
Should
list
origin
as
source
if
available
.
"
)
;
let
closedPromise
=
BrowserTestUtils
.
windowClosed
(
dialogWin
)
;
dialogWin
.
document
.
getElementById
(
"
save
"
)
.
click
(
)
;
let
dialogNode
=
dialogWin
.
document
.
querySelector
(
"
dialog
"
)
;
dialogNode
.
getButton
(
"
accept
"
)
.
disabled
=
false
;
dialogNode
.
acceptDialog
(
)
;
await
closedPromise
;
let
download
=
await
downloadPromise
;
registerCleanupFunction
(
async
(
)
=
>
{
let
target
=
download
.
target
.
path
;
await
download
.
finalize
(
)
;
await
IOUtils
.
remove
(
target
)
;
}
)
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
downloads
"
async
dlBrowser
=
>
{
let
doc
=
dlBrowser
.
contentDocument
;
let
listNode
=
doc
.
getElementById
(
"
downloadsRichListBox
"
)
;
await
BrowserTestUtils
.
waitForMutationCondition
(
listNode
{
childList
:
true
subtree
:
true
attributeFilter
:
[
"
value
"
]
}
(
)
=
>
listNode
.
firstElementChild
?
.
querySelector
(
"
.
downloadDetailsNormal
"
)
?
.
getAttribute
(
"
value
"
)
)
;
let
download
=
listNode
.
firstElementChild
;
let
detailString
=
download
.
querySelector
(
"
.
downloadDetailsNormal
"
)
.
value
;
Assert
.
stringContains
(
detailString
expectedListOrigin
"
Should
list
origin
in
download
list
if
available
.
"
)
;
}
)
;
}
)
;
}
