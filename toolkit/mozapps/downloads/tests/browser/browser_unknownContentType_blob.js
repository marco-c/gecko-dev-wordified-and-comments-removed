"
use
strict
"
;
const
UCT_URI
=
"
chrome
:
/
/
mozapps
/
content
/
downloads
/
unknownContentType
.
xhtml
"
;
async
function
promiseDownloadFinished
(
list
)
{
return
new
Promise
(
resolve
=
>
{
list
.
addView
(
{
onDownloadChanged
(
download
)
{
info
(
"
Download
changed
!
"
)
;
if
(
download
.
succeeded
|
|
download
.
error
)
{
info
(
"
Download
succeeded
or
errored
"
)
;
list
.
removeView
(
this
)
;
resolve
(
download
)
;
}
}
}
)
;
}
)
;
}
add_task
(
async
function
test_check_blob_origin_representation
(
)
{
const
handlerSvc
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
const
mimeSvc
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
;
let
txtHandlerInfo
=
mimeSvc
.
getFromTypeAndExtension
(
"
text
/
plain
"
"
txt
"
)
;
txtHandlerInfo
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
alwaysAsk
;
txtHandlerInfo
.
alwaysAskBeforeHandling
=
true
;
handlerSvc
.
store
(
txtHandlerInfo
)
;
registerCleanupFunction
(
(
)
=
>
handlerSvc
.
remove
(
txtHandlerInfo
)
)
;
await
BrowserTestUtils
.
withNewTab
(
"
https
:
/
/
example
.
org
/
1
"
async
browser
=
>
{
let
downloadList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
downloadPromise
=
promiseDownloadFinished
(
downloadList
)
;
let
dialogPromise
=
BrowserTestUtils
.
domWindowOpenedAndLoaded
(
null
win
=
>
win
.
document
.
documentURI
=
=
UCT_URI
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
(
)
=
>
{
let
url
=
content
.
eval
(
window
.
foo
=
new
Blob
(
[
"
Hello
"
]
{
type
:
"
text
/
plain
"
}
)
;
URL
.
createObjectURL
(
window
.
foo
)
)
;
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
href
=
url
;
link
.
textContent
=
"
Click
me
click
me
me
me
me
"
;
link
.
download
=
"
my
-
file
.
txt
"
;
content
.
document
.
body
.
append
(
link
)
;
link
.
click
(
)
;
}
)
;
let
dialogWin
=
await
dialogPromise
;
let
source
=
dialogWin
.
document
.
getElementById
(
"
source
"
)
;
is
(
source
.
value
"
https
:
/
/
example
.
org
"
"
Should
not
list
blob
as
source
.
"
)
;
let
closedPromise
=
BrowserTestUtils
.
windowClosed
(
dialogWin
)
;
let
dialogNode
=
dialogWin
.
document
.
querySelector
(
"
dialog
"
)
;
dialogNode
.
getButton
(
"
accept
"
)
.
disabled
=
false
;
dialogNode
.
acceptDialog
(
)
;
await
closedPromise
;
let
download
=
await
downloadPromise
;
registerCleanupFunction
(
async
(
)
=
>
{
let
target
=
download
.
target
.
path
;
await
download
.
finalize
(
)
;
await
IOUtils
.
remove
(
target
)
;
}
)
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
downloads
"
async
dlBrowser
=
>
{
let
doc
=
dlBrowser
.
contentDocument
;
let
listNode
=
doc
.
getElementById
(
"
downloadsRichListBox
"
)
;
await
BrowserTestUtils
.
waitForMutationCondition
(
listNode
{
childList
:
true
subtree
:
true
attributeFilter
:
[
"
value
"
]
}
(
)
=
>
listNode
.
firstElementChild
?
.
querySelector
(
"
.
downloadDetailsNormal
"
)
?
.
getAttribute
(
"
value
"
)
)
;
let
download
=
listNode
.
firstElementChild
;
let
detailString
=
download
.
querySelector
(
"
.
downloadDetailsNormal
"
)
.
value
;
Assert
.
stringContains
(
detailString
"
example
.
org
"
"
Should
list
origin
in
download
list
.
"
)
;
}
)
;
}
)
;
}
)
;
