"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DownloadUtils
"
]
;
const
MS_PER_DAY
=
24
*
60
*
60
*
1000
;
const
BYTE_UNITS
=
[
"
download
-
utils
-
bytes
"
"
download
-
utils
-
kilobyte
"
"
download
-
utils
-
megabyte
"
"
download
-
utils
-
gigabyte
"
]
;
const
TIME_UNITS
=
[
"
download
-
utils
-
short
-
seconds
"
"
download
-
utils
-
short
-
minutes
"
"
download
-
utils
-
short
-
hours
"
"
download
-
utils
-
short
-
days
"
]
;
const
TIME_SIZES
=
[
60
60
24
]
;
var
localeNumberFormatCache
=
new
Map
(
)
;
function
getLocaleNumberFormat
(
fractionDigits
)
{
if
(
!
localeNumberFormatCache
.
has
(
fractionDigits
)
)
{
localeNumberFormatCache
.
set
(
fractionDigits
new
Services
.
intl
.
NumberFormat
(
undefined
{
maximumFractionDigits
:
fractionDigits
minimumFractionDigits
:
fractionDigits
}
)
)
;
}
return
localeNumberFormatCache
.
get
(
fractionDigits
)
;
}
const
l10n
=
new
Localization
(
[
"
toolkit
/
downloads
/
downloadUtils
.
ftl
"
]
true
)
;
const
kCachedLastMaxSize
=
10
;
var
gCachedLast
=
[
]
;
var
DownloadUtils
=
{
getDownloadStatus
:
function
DU_getDownloadStatus
(
aCurrBytes
aMaxBytes
aSpeed
aLastSec
)
{
let
[
transfer
timeLeft
newLast
normalizedSpeed
]
=
this
.
_deriveTransferRate
(
aCurrBytes
aMaxBytes
aSpeed
aLastSec
)
;
let
[
rate
unit
]
=
DownloadUtils
.
convertByteUnits
(
normalizedSpeed
)
;
let
status
;
if
(
rate
=
=
=
"
Infinity
"
)
{
status
=
l10n
.
formatValueSync
(
"
download
-
utils
-
status
-
infinite
-
rate
"
{
transfer
timeLeft
}
)
;
}
else
{
status
=
l10n
.
formatValueSync
(
"
download
-
utils
-
status
"
{
transfer
rate
unit
timeLeft
}
)
;
}
return
[
status
newLast
]
;
}
getDownloadStatusNoRate
:
function
DU_getDownloadStatusNoRate
(
aCurrBytes
aMaxBytes
aSpeed
aLastSec
)
{
let
[
transfer
timeLeft
newLast
]
=
this
.
_deriveTransferRate
(
aCurrBytes
aMaxBytes
aSpeed
aLastSec
)
;
let
status
=
l10n
.
formatValueSync
(
"
download
-
utils
-
status
-
no
-
rate
"
{
transfer
timeLeft
}
)
;
return
[
status
newLast
]
;
}
_deriveTransferRate
:
function
DU__deriveTransferRate
(
aCurrBytes
aMaxBytes
aSpeed
aLastSec
)
{
if
(
aMaxBytes
=
=
null
)
{
aMaxBytes
=
-
1
;
}
if
(
aSpeed
=
=
null
)
{
aSpeed
=
-
1
;
}
if
(
aLastSec
=
=
null
)
{
aLastSec
=
Infinity
;
}
let
seconds
=
aSpeed
>
0
&
&
aMaxBytes
>
0
?
(
aMaxBytes
-
aCurrBytes
)
/
aSpeed
:
-
1
;
let
transfer
=
DownloadUtils
.
getTransferTotal
(
aCurrBytes
aMaxBytes
)
;
let
[
timeLeft
newLast
]
=
DownloadUtils
.
getTimeLeft
(
seconds
aLastSec
)
;
return
[
transfer
timeLeft
newLast
aSpeed
]
;
}
getTransferTotal
:
function
DU_getTransferTotal
(
aCurrBytes
aMaxBytes
)
{
if
(
aMaxBytes
=
=
null
)
{
aMaxBytes
=
-
1
;
}
let
[
progress
progressUnits
]
=
DownloadUtils
.
convertByteUnits
(
aCurrBytes
)
;
let
[
total
totalUnits
]
=
DownloadUtils
.
convertByteUnits
(
aMaxBytes
)
;
let
name
;
if
(
aMaxBytes
<
0
)
{
name
=
"
download
-
utils
-
transfer
-
no
-
total
"
;
}
else
if
(
progressUnits
=
=
totalUnits
)
{
name
=
"
download
-
utils
-
transfer
-
same
-
units
"
;
}
else
{
name
=
"
download
-
utils
-
transfer
-
diff
-
units
"
;
}
return
l10n
.
formatValueSync
(
name
{
progress
progressUnits
total
totalUnits
}
)
;
}
getTimeLeft
:
function
DU_getTimeLeft
(
aSeconds
aLastSec
)
{
let
nf
=
new
Services
.
intl
.
NumberFormat
(
)
;
if
(
aLastSec
=
=
null
)
{
aLastSec
=
Infinity
;
}
if
(
aSeconds
<
0
)
{
return
[
l10n
.
formatValueSync
(
"
download
-
utils
-
time
-
unknown
"
)
aLastSec
]
;
}
aLastSec
=
gCachedLast
.
reduce
(
(
aResult
aItem
)
=
>
(
aItem
[
0
]
=
=
aSeconds
?
aItem
[
1
]
:
aResult
)
aLastSec
)
;
gCachedLast
.
push
(
[
aSeconds
aLastSec
]
)
;
if
(
gCachedLast
.
length
>
kCachedLastMaxSize
)
{
gCachedLast
.
shift
(
)
;
}
if
(
aSeconds
>
aLastSec
/
2
)
{
let
diff
=
aSeconds
-
aLastSec
;
aSeconds
=
aLastSec
+
(
diff
<
0
?
0
.
3
:
0
.
1
)
*
diff
;
let
diffPct
=
(
diff
/
aLastSec
)
*
100
;
if
(
Math
.
abs
(
diff
)
<
5
|
|
Math
.
abs
(
diffPct
)
<
5
)
{
aSeconds
=
aLastSec
-
(
diff
<
0
?
0
.
4
:
0
.
2
)
;
}
}
let
timeLeft
;
if
(
aSeconds
<
4
)
{
timeLeft
=
l10n
.
formatValueSync
(
"
download
-
utils
-
time
-
few
-
seconds
"
)
;
}
else
{
let
[
time1
unit1
time2
unit2
]
=
DownloadUtils
.
convertTimeUnits
(
aSeconds
)
;
const
pair1
=
l10n
.
formatValueSync
(
"
download
-
utils
-
time
-
pair
"
{
time
:
nf
.
format
(
time1
)
unit
:
unit1
}
)
;
if
(
(
aSeconds
<
3600
&
&
time1
>
=
4
)
|
|
time2
=
=
0
)
{
timeLeft
=
l10n
.
formatValueSync
(
"
download
-
utils
-
time
-
left
-
single
"
{
time
:
pair1
}
)
;
}
else
{
const
pair2
=
l10n
.
formatValueSync
(
"
download
-
utils
-
time
-
pair
"
{
time
:
nf
.
format
(
time2
)
unit
:
unit2
}
)
;
timeLeft
=
l10n
.
formatValueSync
(
"
download
-
utils
-
time
-
left
-
double
"
{
time1
:
pair1
time2
:
pair2
}
)
;
}
}
return
[
timeLeft
aSeconds
]
;
}
getReadableDates
:
function
DU_getReadableDates
(
aDate
aNow
)
{
if
(
!
aNow
)
{
aNow
=
new
Date
(
)
;
}
let
today
=
new
Date
(
aNow
.
getFullYear
(
)
aNow
.
getMonth
(
)
aNow
.
getDate
(
)
)
;
let
dateTimeCompact
;
let
dateTimeFull
;
if
(
aDate
>
=
today
)
{
let
dts
=
new
Services
.
intl
.
DateTimeFormat
(
undefined
{
timeStyle
:
"
short
"
}
)
;
dateTimeCompact
=
dts
.
format
(
aDate
)
;
}
else
if
(
today
-
aDate
<
MS_PER_DAY
)
{
dateTimeCompact
=
l10n
.
formatValueSync
(
"
download
-
utils
-
yesterday
"
)
;
}
else
if
(
today
-
aDate
<
6
*
MS_PER_DAY
)
{
dateTimeCompact
=
aDate
.
toLocaleDateString
(
undefined
{
weekday
:
"
long
"
}
)
;
}
else
{
dateTimeCompact
=
aDate
.
toLocaleString
(
undefined
{
month
:
"
long
"
day
:
"
numeric
"
}
)
;
}
const
dtOptions
=
{
dateStyle
:
"
long
"
timeStyle
:
"
short
"
}
;
dateTimeFull
=
new
Services
.
intl
.
DateTimeFormat
(
undefined
dtOptions
)
.
format
(
aDate
)
;
return
[
dateTimeCompact
dateTimeFull
]
;
}
getURIHost
:
function
DU_getURIHost
(
aURIString
)
{
let
idnService
=
Cc
[
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIDNService
)
;
let
uri
;
try
{
uri
=
Services
.
io
.
newURI
(
aURIString
)
;
}
catch
(
ex
)
{
return
[
"
"
"
"
]
;
}
if
(
uri
instanceof
Ci
.
nsINestedURI
)
{
uri
=
uri
.
innermostURI
;
}
if
(
uri
.
scheme
=
=
"
blob
"
)
{
let
origin
=
new
URL
(
uri
.
spec
)
.
origin
;
if
(
origin
!
=
"
null
"
)
{
try
{
uri
=
Services
.
io
.
newURI
(
origin
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
}
}
let
fullHost
;
try
{
fullHost
=
uri
.
host
;
}
catch
(
e
)
{
fullHost
=
"
"
;
}
let
displayHost
;
try
{
let
baseDomain
=
Services
.
eTLD
.
getBaseDomain
(
uri
)
;
displayHost
=
idnService
.
convertToDisplayIDN
(
baseDomain
{
}
)
;
}
catch
(
e
)
{
displayHost
=
fullHost
;
}
if
(
uri
.
scheme
=
=
"
file
"
)
{
displayHost
=
l10n
.
formatValueSync
(
"
download
-
utils
-
done
-
file
-
scheme
"
)
;
fullHost
=
displayHost
;
}
else
if
(
!
displayHost
.
length
)
{
displayHost
=
l10n
.
formatValueSync
(
"
download
-
utils
-
done
-
scheme
"
{
scheme
:
uri
.
scheme
}
)
;
fullHost
=
displayHost
;
}
else
if
(
uri
.
port
!
=
-
1
)
{
let
port
=
"
:
"
+
uri
.
port
;
displayHost
+
=
port
;
fullHost
+
=
port
;
}
return
[
displayHost
fullHost
]
;
}
convertByteUnits
:
function
DU_convertByteUnits
(
aBytes
)
{
let
unitIndex
=
0
;
while
(
aBytes
>
=
999
.
5
&
&
unitIndex
<
BYTE_UNITS
.
length
-
1
)
{
aBytes
/
=
1024
;
unitIndex
+
+
;
}
let
fractionDigits
=
aBytes
>
0
&
&
aBytes
<
100
&
&
unitIndex
!
=
0
?
1
:
0
;
if
(
aBytes
=
=
=
Infinity
)
{
aBytes
=
"
Infinity
"
;
}
else
{
aBytes
=
getLocaleNumberFormat
(
fractionDigits
)
.
format
(
aBytes
)
;
}
return
[
aBytes
l10n
.
formatValueSync
(
BYTE_UNITS
[
unitIndex
]
)
]
;
}
convertTimeUnits
:
function
DU_convertTimeUnits
(
aSecs
)
{
let
time
=
aSecs
;
let
scale
=
1
;
let
unitIndex
=
0
;
while
(
unitIndex
<
TIME_SIZES
.
length
&
&
time
>
=
TIME_SIZES
[
unitIndex
]
)
{
time
/
=
TIME_SIZES
[
unitIndex
]
;
scale
*
=
TIME_SIZES
[
unitIndex
]
;
unitIndex
+
+
;
}
let
value
=
convertTimeUnitsValue
(
time
)
;
let
units
=
convertTimeUnitsUnits
(
value
unitIndex
)
;
let
extra
=
aSecs
-
value
*
scale
;
let
nextIndex
=
unitIndex
-
1
;
for
(
let
index
=
0
;
index
<
nextIndex
;
index
+
+
)
{
extra
/
=
TIME_SIZES
[
index
]
;
}
let
value2
=
convertTimeUnitsValue
(
extra
)
;
let
units2
=
convertTimeUnitsUnits
(
value2
nextIndex
)
;
return
[
value
units
value2
units2
]
;
}
getFormattedTimeStatus
:
function
DU_getFormattedTimeStatus
(
aSeconds
)
{
aSeconds
=
Math
.
floor
(
aSeconds
)
;
let
l10n
;
if
(
!
isFinite
(
aSeconds
)
|
|
aSeconds
<
0
)
{
l10n
=
{
id
:
"
downloading
-
file
-
opens
-
in
-
some
-
time
"
}
;
}
else
if
(
aSeconds
<
60
)
{
l10n
=
{
id
:
"
downloading
-
file
-
opens
-
in
-
seconds
"
args
:
{
seconds
:
aSeconds
}
}
;
}
else
if
(
aSeconds
<
3600
)
{
let
minutes
=
Math
.
floor
(
aSeconds
/
60
)
;
let
seconds
=
aSeconds
%
60
;
l10n
=
seconds
?
{
args
:
{
seconds
minutes
}
id
:
"
downloading
-
file
-
opens
-
in
-
minutes
-
and
-
seconds
"
}
:
{
args
:
{
minutes
}
id
:
"
downloading
-
file
-
opens
-
in
-
minutes
"
}
;
}
else
{
let
hours
=
Math
.
floor
(
aSeconds
/
3600
)
;
let
minutes
=
Math
.
floor
(
(
aSeconds
%
3600
)
/
60
)
;
l10n
=
{
args
:
{
hours
minutes
}
id
:
"
downloading
-
file
-
opens
-
in
-
hours
-
and
-
minutes
"
}
;
}
return
{
l10n
}
;
}
}
;
function
convertTimeUnitsValue
(
aTime
)
{
return
Math
.
floor
(
aTime
)
;
}
function
convertTimeUnitsUnits
(
timeValue
aIndex
)
{
if
(
aIndex
<
0
)
{
return
"
"
;
}
return
l10n
.
formatValueSync
(
TIME_UNITS
[
aIndex
]
{
timeValue
}
)
;
}
