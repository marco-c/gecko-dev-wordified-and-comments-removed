const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
EnableDelayHelper
"
"
resource
:
/
/
gre
/
modules
/
SharedPromptUtils
.
jsm
"
)
;
function
isUsableDirectory
(
aDirectory
)
{
return
aDirectory
.
exists
(
)
&
&
aDirectory
.
isDirectory
(
)
&
&
aDirectory
.
isWritable
(
)
;
}
function
nsUnknownContentTypeDialogProgressListener
(
aHelperAppDialog
)
{
this
.
helperAppDlg
=
aHelperAppDialog
;
}
nsUnknownContentTypeDialogProgressListener
.
prototype
=
{
onStatusChange
(
aWebProgress
aRequest
aStatus
aMessage
)
{
if
(
aStatus
!
=
Cr
.
NS_OK
)
{
Services
.
prompt
.
alert
(
this
.
dialog
this
.
helperAppDlg
.
mTitle
aMessage
)
;
this
.
helperAppDlg
.
onCancel
(
)
;
if
(
this
.
helperAppDlg
.
mDialog
)
{
this
.
helperAppDlg
.
mDialog
.
close
(
)
;
}
}
}
onProgressChange
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
{
}
onProgressChange64
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
{
}
onStateChange
(
aWebProgress
aRequest
aStateFlags
aStatus
)
{
}
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
}
onSecurityChange
(
aWebProgress
aRequest
aState
)
{
}
onContentBlockingEvent
(
aWebProgress
aRequest
aEvent
)
{
}
onRefreshAttempted
(
aWebProgress
aURI
aDelay
aSameURI
)
{
return
true
;
}
}
;
const
PREF_BD_USEDOWNLOADDIR
=
"
browser
.
download
.
useDownloadDir
"
;
const
nsITimer
=
Ci
.
nsITimer
;
var
downloadModule
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadLastDir
.
jsm
"
)
;
const
{
DownloadPaths
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadPaths
.
jsm
"
)
;
const
{
DownloadUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
jsm
"
)
;
const
{
Downloads
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
const
{
FileUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
function
nsUnknownContentTypeDialog
(
)
{
this
.
mLauncher
=
null
;
this
.
mContext
=
null
;
this
.
mReason
=
null
;
this
.
chosenApp
=
null
;
this
.
givenDefaultApp
=
false
;
this
.
updateSelf
=
true
;
this
.
mTitle
=
"
"
;
}
nsUnknownContentTypeDialog
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
F68578EB
-
6EC2
-
4169
-
AE19
-
8C6243F0ABE1
}
"
)
nsIMIMEInfo
:
Ci
.
nsIMIMEInfo
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIHelperAppLauncherDialog
"
"
nsITimerCallback
"
]
)
show
(
aLauncher
aContext
aReason
)
{
this
.
mLauncher
=
aLauncher
;
this
.
mContext
=
aContext
;
this
.
mReason
=
aReason
;
try
{
let
parent
=
aContext
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
this
.
_mDownloadDir
=
new
downloadModule
.
DownloadLastDir
(
parent
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Missing
window
information
when
showing
nsIHelperAppLauncherDialog
:
"
+
ex
)
;
}
const
nsITimer
=
Ci
.
nsITimer
;
this
.
_showTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
nsITimer
)
;
this
.
_showTimer
.
initWithCallback
(
this
0
nsITimer
.
TYPE_ONE_SHOT
)
;
}
reallyShow
(
)
{
try
{
let
ir
=
this
.
mContext
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
let
docShell
=
ir
.
getInterface
(
Ci
.
nsIDocShell
)
;
let
rootWin
=
docShell
.
rootTreeItem
.
domWindow
;
this
.
mDialog
=
Services
.
ww
.
openWindow
(
rootWin
"
chrome
:
/
/
mozapps
/
content
/
downloads
/
unknownContentType
.
xul
"
null
"
chrome
centerscreen
titlebar
dialog
=
yes
dependent
"
null
)
;
}
catch
(
ex
)
{
this
.
mLauncher
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
return
;
}
this
.
mDialog
.
dialog
=
this
;
this
.
getSpecialFolderKey
=
this
.
mDialog
.
getSpecialFolderKey
;
var
progressListener
=
new
nsUnknownContentTypeDialogProgressListener
(
this
)
;
this
.
mLauncher
.
setWebProgressListener
(
progressListener
)
;
}
displayBadPermissionAlert
(
)
{
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
mozapps
/
locale
/
downloads
/
unknownContentType
.
properties
"
)
;
Services
.
prompt
.
alert
(
this
.
dialog
bundle
.
GetStringFromName
(
"
badPermissions
.
title
"
)
bundle
.
GetStringFromName
(
"
badPermissions
"
)
)
;
}
promptForSaveToFileAsync
(
aLauncher
aContext
aDefaultFileName
aSuggestedFileExtension
aForcePrompt
)
{
var
result
=
null
;
this
.
mLauncher
=
aLauncher
;
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
mozapps
/
locale
/
downloads
/
unknownContentType
.
properties
"
)
;
let
parent
;
let
gDownloadLastDir
;
try
{
parent
=
aContext
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
catch
(
ex
)
{
}
if
(
parent
)
{
gDownloadLastDir
=
new
downloadModule
.
DownloadLastDir
(
parent
)
;
}
else
{
gDownloadLastDir
=
this
.
_mDownloadDir
;
for
(
let
someWin
of
Services
.
wm
.
getEnumerator
(
"
"
)
)
{
if
(
someWin
!
=
this
.
mDialog
)
{
parent
=
someWin
;
}
}
if
(
!
parent
)
{
Cu
.
reportError
(
"
No
candidate
parent
windows
were
found
for
the
save
filepicker
.
"
+
"
This
should
never
happen
.
"
)
;
}
}
(
async
(
)
=
>
{
if
(
!
aForcePrompt
)
{
let
autodownload
=
Services
.
prefs
.
getBoolPref
(
PREF_BD_USEDOWNLOADDIR
false
)
;
if
(
autodownload
)
{
let
preferredDir
=
await
Downloads
.
getPreferredDownloadsDirectory
(
)
;
let
defaultFolder
=
new
FileUtils
.
File
(
preferredDir
)
;
try
{
result
=
this
.
validateLeafName
(
defaultFolder
aDefaultFileName
aSuggestedFileExtension
)
;
}
catch
(
ex
)
{
}
if
(
result
)
{
Services
.
obs
.
notifyObservers
(
null
"
cloudstorage
-
prompt
-
notification
"
result
.
path
)
;
aLauncher
.
saveDestinationAvailable
(
result
)
;
return
;
}
}
}
var
nsIFilePicker
=
Ci
.
nsIFilePicker
;
var
picker
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
nsIFilePicker
)
;
var
windowTitle
=
bundle
.
GetStringFromName
(
"
saveDialogTitle
"
)
;
picker
.
init
(
parent
windowTitle
nsIFilePicker
.
modeSave
)
;
if
(
aDefaultFileName
)
{
picker
.
defaultString
=
this
.
getFinalLeafName
(
aDefaultFileName
)
;
}
if
(
aSuggestedFileExtension
)
{
picker
.
defaultExtension
=
aSuggestedFileExtension
.
substring
(
1
)
;
}
else
{
try
{
picker
.
defaultExtension
=
this
.
mLauncher
.
MIMEInfo
.
primaryExtension
;
}
catch
(
ex
)
{
}
}
var
wildCardExtension
=
"
*
"
;
if
(
aSuggestedFileExtension
)
{
wildCardExtension
+
=
aSuggestedFileExtension
;
picker
.
appendFilter
(
this
.
mLauncher
.
MIMEInfo
.
description
wildCardExtension
)
;
}
picker
.
appendFilters
(
nsIFilePicker
.
filterAll
)
;
let
preferredDir
=
await
Downloads
.
getPreferredDownloadsDirectory
(
)
;
picker
.
displayDirectory
=
new
FileUtils
.
File
(
preferredDir
)
;
gDownloadLastDir
.
getFileAsync
(
aLauncher
.
source
lastDir
=
>
{
if
(
lastDir
&
&
isUsableDirectory
(
lastDir
)
)
picker
.
displayDirectory
=
lastDir
;
picker
.
open
(
returnValue
=
>
{
if
(
returnValue
=
=
nsIFilePicker
.
returnCancel
)
{
aLauncher
.
saveDestinationAvailable
(
null
)
;
return
;
}
result
=
picker
.
file
;
if
(
result
)
{
try
{
if
(
result
.
exists
(
)
&
&
this
.
getFinalLeafName
(
result
.
leafName
)
=
=
result
.
leafName
)
result
.
remove
(
false
)
;
}
catch
(
ex
)
{
}
var
newDir
=
result
.
parent
.
QueryInterface
(
Ci
.
nsIFile
)
;
gDownloadLastDir
.
setFile
(
aLauncher
.
source
newDir
)
;
try
{
result
=
this
.
validateLeafName
(
newDir
result
.
leafName
null
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_FILE_ACCESS_DENIED
)
{
this
.
displayBadPermissionAlert
(
)
;
aLauncher
.
saveDestinationAvailable
(
null
)
;
return
;
}
}
}
aLauncher
.
saveDestinationAvailable
(
result
)
;
}
)
;
}
)
;
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
}
getFinalLeafName
(
aLeafName
aFileExt
)
{
return
DownloadPaths
.
sanitize
(
aLeafName
)
|
|
"
unnamed
"
+
(
aFileExt
?
"
.
"
+
aFileExt
:
"
"
)
;
}
validateLeafName
(
aLocalFolder
aLeafName
aFileExt
)
{
if
(
!
(
aLocalFolder
&
&
isUsableDirectory
(
aLocalFolder
)
)
)
{
throw
new
Components
.
Exception
(
"
Destination
directory
non
-
existing
or
permission
error
"
Cr
.
NS_ERROR_FILE_ACCESS_DENIED
)
;
}
aLeafName
=
this
.
getFinalLeafName
(
aLeafName
aFileExt
)
;
aLocalFolder
.
append
(
aLeafName
)
;
var
createdFile
=
DownloadPaths
.
createNiceUniqueFile
(
aLocalFolder
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
ext
;
try
{
ext
=
"
.
"
+
this
.
mLauncher
.
MIMEInfo
.
primaryExtension
;
}
catch
(
e
)
{
}
let
leaf
=
createdFile
.
leafName
;
if
(
ext
&
&
leaf
.
slice
(
-
ext
.
length
)
!
=
ext
&
&
createdFile
.
isExecutable
(
)
)
{
createdFile
.
remove
(
false
)
;
aLocalFolder
.
leafName
=
leaf
+
ext
;
createdFile
=
DownloadPaths
.
createNiceUniqueFile
(
aLocalFolder
)
;
}
}
return
createdFile
;
}
initDialog
(
)
{
var
suggestedFileName
=
this
.
mLauncher
.
suggestedFileName
;
var
url
=
this
.
mLauncher
.
source
;
if
(
url
instanceof
Ci
.
nsINestedURI
)
url
=
url
.
innermostURI
;
var
fname
=
"
"
;
var
iconPath
=
"
goat
"
;
this
.
mSourcePath
=
url
.
prePath
;
if
(
url
instanceof
Ci
.
nsIURL
)
{
fname
=
iconPath
=
url
.
fileName
;
this
.
mSourcePath
+
=
url
.
directory
;
}
else
{
fname
=
url
.
pathQueryRef
;
this
.
mSourcePath
+
=
url
.
pathQueryRef
;
}
if
(
suggestedFileName
)
fname
=
iconPath
=
suggestedFileName
;
var
displayName
=
fname
.
replace
(
/
+
/
g
"
"
)
;
this
.
mTitle
=
this
.
dialogElement
(
"
strings
"
)
.
getFormattedString
(
"
title
"
[
displayName
]
)
;
this
.
mDialog
.
document
.
title
=
this
.
mTitle
;
this
.
initIntro
(
url
fname
displayName
)
;
var
iconString
=
"
moz
-
icon
:
/
/
"
+
iconPath
+
"
?
size
=
16
&
contentType
=
"
+
this
.
mLauncher
.
MIMEInfo
.
MIMEType
;
this
.
dialogElement
(
"
contentTypeImage
"
)
.
setAttribute
(
"
src
"
iconString
)
;
var
mimeType
=
this
.
mLauncher
.
MIMEInfo
.
MIMEType
;
var
shouldntRememberChoice
=
(
mimeType
=
=
"
application
/
octet
-
stream
"
|
|
mimeType
=
=
"
application
/
x
-
msdownload
"
|
|
this
.
mLauncher
.
targetFileIsExecutable
)
;
if
(
(
shouldntRememberChoice
&
&
!
this
.
openWithDefaultOK
(
)
)
|
|
Services
.
prefs
.
getBoolPref
(
"
browser
.
download
.
forbid_open_with
"
)
)
{
this
.
dialogElement
(
"
normalBox
"
)
.
collapsed
=
true
;
this
.
dialogElement
(
"
basicBox
"
)
.
collapsed
=
false
;
let
acceptButton
=
this
.
mDialog
.
document
.
documentElement
.
getButton
(
"
accept
"
)
;
acceptButton
.
label
=
this
.
dialogElement
(
"
strings
"
)
.
getString
(
"
unknownAccept
.
label
"
)
;
acceptButton
.
setAttribute
(
"
icon
"
"
save
"
)
;
this
.
mDialog
.
document
.
documentElement
.
getButton
(
"
cancel
"
)
.
label
=
this
.
dialogElement
(
"
strings
"
)
.
getString
(
"
unknownCancel
.
label
"
)
;
this
.
dialogElement
(
"
openHandler
"
)
.
collapsed
=
true
;
this
.
dialogElement
(
"
mode
"
)
.
selectedItem
=
this
.
dialogElement
(
"
save
"
)
;
}
else
{
this
.
initAppAndSaveToDiskValues
(
)
;
var
rememberChoice
=
this
.
dialogElement
(
"
rememberChoice
"
)
;
if
(
shouldntRememberChoice
)
{
rememberChoice
.
checked
=
false
;
rememberChoice
.
disabled
=
true
;
}
else
{
rememberChoice
.
checked
=
!
this
.
mLauncher
.
MIMEInfo
.
alwaysAskBeforeHandling
&
&
this
.
mLauncher
.
MIMEInfo
.
preferredAction
!
=
this
.
nsIMIMEInfo
.
handleInternally
;
}
this
.
toggleRememberChoice
(
rememberChoice
)
;
var
openHandler
=
this
.
dialogElement
(
"
openHandler
"
)
;
openHandler
.
remove
(
)
;
var
openHandlerBox
=
this
.
dialogElement
(
"
openHandlerBox
"
)
;
openHandlerBox
.
appendChild
(
openHandler
)
;
}
this
.
mDialog
.
setTimeout
(
"
dialog
.
postShowCallback
(
)
"
0
)
;
this
.
delayHelper
=
new
EnableDelayHelper
(
{
disableDialog
:
(
)
=
>
{
this
.
mDialog
.
document
.
documentElement
.
getButton
(
"
accept
"
)
.
disabled
=
true
;
}
enableDialog
:
(
)
=
>
{
this
.
mDialog
.
document
.
documentElement
.
getButton
(
"
accept
"
)
.
disabled
=
false
;
}
focusTarget
:
this
.
mDialog
}
)
;
}
notify
(
aTimer
)
{
if
(
aTimer
=
=
this
.
_showTimer
)
{
if
(
!
this
.
mDialog
)
{
this
.
reallyShow
(
)
;
}
this
.
_showTimer
=
null
;
}
else
if
(
aTimer
=
=
this
.
_saveToDiskTimer
)
{
this
.
mLauncher
.
saveToDisk
(
null
false
)
;
this
.
_saveToDiskTimer
=
null
;
}
}
postShowCallback
(
)
{
this
.
mDialog
.
sizeToContent
(
)
;
this
.
dialogElement
(
"
mode
"
)
.
focus
(
)
;
}
initIntro
(
url
filename
displayname
)
{
this
.
dialogElement
(
"
location
"
)
.
value
=
displayname
;
this
.
dialogElement
(
"
location
"
)
.
setAttribute
(
"
realname
"
filename
)
;
this
.
dialogElement
(
"
location
"
)
.
setAttribute
(
"
tooltiptext
"
displayname
)
;
var
pathString
;
if
(
url
instanceof
Ci
.
nsIFileURL
)
{
try
{
pathString
=
url
.
file
.
parent
.
path
;
}
catch
(
ex
)
{
}
}
if
(
!
pathString
)
{
var
tmpurl
=
url
;
try
{
tmpurl
=
tmpurl
.
mutate
(
)
.
setUserPass
(
"
"
)
.
finalize
(
)
;
}
catch
(
ex
)
{
}
pathString
=
tmpurl
.
prePath
;
}
var
location
=
this
.
dialogElement
(
"
source
"
)
;
location
.
value
=
pathString
;
location
.
setAttribute
(
"
tooltiptext
"
this
.
mSourcePath
)
;
var
type
=
this
.
dialogElement
(
"
type
"
)
;
var
mimeInfo
=
this
.
mLauncher
.
MIMEInfo
;
var
typeString
=
mimeInfo
.
description
;
if
(
typeString
=
=
"
"
)
{
var
primaryExtension
=
"
"
;
try
{
primaryExtension
=
mimeInfo
.
primaryExtension
;
}
catch
(
ex
)
{
}
if
(
primaryExtension
!
=
"
"
)
typeString
=
this
.
dialogElement
(
"
strings
"
)
.
getFormattedString
(
"
fileType
"
[
primaryExtension
.
toUpperCase
(
)
]
)
;
else
typeString
=
mimeInfo
.
MIMEType
;
}
if
(
this
.
mLauncher
.
contentLength
>
=
0
)
{
let
[
size
unit
]
=
DownloadUtils
.
convertByteUnits
(
this
.
mLauncher
.
contentLength
)
;
type
.
value
=
this
.
dialogElement
(
"
strings
"
)
.
getFormattedString
(
"
orderedFileSizeWithType
"
[
typeString
size
unit
]
)
;
}
else
{
type
.
value
=
typeString
;
}
}
openWithDefaultOK
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
return
!
this
.
mLauncher
.
targetFileIsExecutable
;
}
return
this
.
mLauncher
.
MIMEInfo
.
hasDefaultHandler
;
}
initDefaultApp
(
)
{
var
desc
=
this
.
mLauncher
.
MIMEInfo
.
defaultDescription
;
if
(
desc
)
{
var
defaultApp
=
this
.
dialogElement
(
"
strings
"
)
.
getFormattedString
(
"
defaultApp
"
[
desc
]
)
;
this
.
dialogElement
(
"
defaultHandler
"
)
.
label
=
defaultApp
;
}
else
{
this
.
dialogElement
(
"
modeDeck
"
)
.
setAttribute
(
"
selectedIndex
"
"
1
"
)
;
this
.
dialogElement
(
"
defaultHandler
"
)
.
hidden
=
true
;
}
}
getPath
(
aFile
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
return
aFile
.
leafName
|
|
aFile
.
path
;
}
return
aFile
.
path
;
}
initAppAndSaveToDiskValues
(
)
{
var
modeGroup
=
this
.
dialogElement
(
"
mode
"
)
;
var
openWithDefaultOK
=
this
.
openWithDefaultOK
(
)
;
var
mimeType
=
this
.
mLauncher
.
MIMEInfo
.
MIMEType
;
var
openHandler
=
this
.
dialogElement
(
"
openHandler
"
)
;
if
(
this
.
mLauncher
.
targetFileIsExecutable
|
|
(
(
mimeType
=
=
"
application
/
octet
-
stream
"
|
|
mimeType
=
=
"
application
/
x
-
msdownload
"
)
&
&
!
openWithDefaultOK
)
)
{
this
.
dialogElement
(
"
open
"
)
.
disabled
=
true
;
openHandler
.
disabled
=
true
;
openHandler
.
selectedItem
=
null
;
modeGroup
.
selectedItem
=
this
.
dialogElement
(
"
save
"
)
;
return
;
}
try
{
this
.
chosenApp
=
this
.
mLauncher
.
MIMEInfo
.
preferredApplicationHandler
.
QueryInterface
(
Ci
.
nsILocalHandlerApp
)
;
}
catch
(
e
)
{
this
.
chosenApp
=
null
;
}
this
.
initDefaultApp
(
)
;
var
otherHandler
=
this
.
dialogElement
(
"
otherHandler
"
)
;
if
(
this
.
chosenApp
&
&
this
.
chosenApp
.
executable
&
&
this
.
chosenApp
.
executable
.
path
)
{
otherHandler
.
setAttribute
(
"
path
"
this
.
getPath
(
this
.
chosenApp
.
executable
)
)
;
otherHandler
.
label
=
this
.
getFileDisplayName
(
this
.
chosenApp
.
executable
)
;
otherHandler
.
hidden
=
false
;
}
openHandler
.
selectedIndex
=
0
;
var
defaultOpenHandler
=
this
.
dialogElement
(
"
defaultHandler
"
)
;
if
(
this
.
mLauncher
.
MIMEInfo
.
preferredAction
=
=
this
.
nsIMIMEInfo
.
useSystemDefault
)
{
modeGroup
.
selectedItem
=
this
.
dialogElement
(
"
open
"
)
;
}
else
if
(
this
.
mLauncher
.
MIMEInfo
.
preferredAction
=
=
this
.
nsIMIMEInfo
.
useHelperApp
)
{
modeGroup
.
selectedItem
=
this
.
dialogElement
(
"
open
"
)
;
openHandler
.
selectedItem
=
(
otherHandler
&
&
!
otherHandler
.
hidden
)
?
otherHandler
:
defaultOpenHandler
;
}
else
{
modeGroup
.
selectedItem
=
this
.
dialogElement
(
"
save
"
)
;
}
if
(
!
openWithDefaultOK
)
{
var
isSelected
=
defaultOpenHandler
.
selected
;
defaultOpenHandler
.
hidden
=
true
;
if
(
isSelected
)
{
openHandler
.
selectedIndex
=
1
;
modeGroup
.
selectedItem
=
this
.
dialogElement
(
"
save
"
)
;
}
}
otherHandler
.
nextSibling
.
hidden
=
otherHandler
.
nextSibling
.
nextSibling
.
hidden
=
false
;
this
.
updateOKButton
(
)
;
}
helperAppChoice
(
)
{
return
this
.
chosenApp
;
}
get
saveToDisk
(
)
{
return
this
.
dialogElement
(
"
save
"
)
.
selected
;
}
get
useOtherHandler
(
)
{
return
this
.
dialogElement
(
"
open
"
)
.
selected
&
&
this
.
dialogElement
(
"
openHandler
"
)
.
selectedIndex
=
=
1
;
}
get
useSystemDefault
(
)
{
return
this
.
dialogElement
(
"
open
"
)
.
selected
&
&
this
.
dialogElement
(
"
openHandler
"
)
.
selectedIndex
=
=
0
;
}
toggleRememberChoice
(
aCheckbox
)
{
this
.
dialogElement
(
"
settingsChange
"
)
.
hidden
=
!
aCheckbox
.
checked
;
this
.
mDialog
.
sizeToContent
(
)
;
}
openHandlerCommand
(
)
{
var
openHandler
=
this
.
dialogElement
(
"
openHandler
"
)
;
if
(
openHandler
.
selectedItem
.
id
=
=
"
choose
"
)
this
.
chooseApp
(
)
;
else
openHandler
.
setAttribute
(
"
lastSelectedItemID
"
openHandler
.
selectedItem
.
id
)
;
}
updateOKButton
(
)
{
var
ok
=
false
;
if
(
this
.
dialogElement
(
"
save
"
)
.
selected
)
{
ok
=
true
;
}
else
if
(
this
.
dialogElement
(
"
open
"
)
.
selected
)
{
switch
(
this
.
dialogElement
(
"
openHandler
"
)
.
selectedIndex
)
{
case
0
:
ok
=
true
;
break
;
case
1
:
ok
=
this
.
chosenApp
|
|
/
\
S
/
.
test
(
this
.
dialogElement
(
"
otherHandler
"
)
.
getAttribute
(
"
path
"
)
)
;
break
;
}
}
this
.
mDialog
.
document
.
documentElement
.
getButton
(
"
accept
"
)
.
disabled
=
!
ok
;
}
appChanged
(
)
{
return
this
.
helperAppChoice
(
)
!
=
this
.
mLauncher
.
MIMEInfo
.
preferredApplicationHandler
;
}
updateMIMEInfo
(
)
{
var
discardUpdate
=
this
.
mLauncher
.
MIMEInfo
.
preferredAction
=
=
this
.
nsIMIMEInfo
.
handleInternally
&
&
!
this
.
dialogElement
(
"
rememberChoice
"
)
.
checked
;
var
needUpdate
=
false
;
if
(
this
.
saveToDisk
)
{
needUpdate
=
this
.
mLauncher
.
MIMEInfo
.
preferredAction
!
=
this
.
nsIMIMEInfo
.
saveToDisk
;
if
(
needUpdate
)
this
.
mLauncher
.
MIMEInfo
.
preferredAction
=
this
.
nsIMIMEInfo
.
saveToDisk
;
}
else
if
(
this
.
useSystemDefault
)
{
needUpdate
=
this
.
mLauncher
.
MIMEInfo
.
preferredAction
!
=
this
.
nsIMIMEInfo
.
useSystemDefault
;
if
(
needUpdate
)
this
.
mLauncher
.
MIMEInfo
.
preferredAction
=
this
.
nsIMIMEInfo
.
useSystemDefault
;
}
else
{
needUpdate
=
this
.
mLauncher
.
MIMEInfo
.
preferredAction
!
=
this
.
nsIMIMEInfo
.
useHelperApp
|
|
this
.
appChanged
(
)
;
if
(
needUpdate
)
{
this
.
mLauncher
.
MIMEInfo
.
preferredAction
=
this
.
nsIMIMEInfo
.
useHelperApp
;
var
app
=
this
.
helperAppChoice
(
)
;
this
.
mLauncher
.
MIMEInfo
.
preferredApplicationHandler
=
app
;
}
}
needUpdate
=
needUpdate
|
|
this
.
mLauncher
.
MIMEInfo
.
alwaysAskBeforeHandling
!
=
(
!
this
.
dialogElement
(
"
rememberChoice
"
)
.
checked
)
;
needUpdate
=
needUpdate
|
|
!
this
.
mLauncher
.
MIMEInfo
.
alwaysAskBeforeHandling
;
this
.
mLauncher
.
MIMEInfo
.
alwaysAskBeforeHandling
=
!
this
.
dialogElement
(
"
rememberChoice
"
)
.
checked
;
return
needUpdate
&
&
!
discardUpdate
;
}
updateHelperAppPref
(
)
{
var
handlerInfo
=
this
.
mLauncher
.
MIMEInfo
;
var
hs
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
hs
.
store
(
handlerInfo
)
;
}
onOK
(
)
{
if
(
this
.
useOtherHandler
)
{
var
helperApp
=
this
.
helperAppChoice
(
)
;
if
(
!
helperApp
|
|
!
helperApp
.
executable
|
|
!
helperApp
.
executable
.
exists
(
)
)
{
var
bundle
=
this
.
dialogElement
(
"
strings
"
)
;
var
msg
=
bundle
.
getFormattedString
(
"
badApp
"
[
this
.
dialogElement
(
"
otherHandler
"
)
.
getAttribute
(
"
path
"
)
]
)
;
Services
.
prompt
.
alert
(
this
.
mDialog
bundle
.
getString
(
"
badApp
.
title
"
)
msg
)
;
this
.
mDialog
.
document
.
documentElement
.
getButton
(
"
accept
"
)
.
disabled
=
true
;
this
.
dialogElement
(
"
mode
"
)
.
focus
(
)
;
this
.
chosenApp
=
null
;
return
false
;
}
}
this
.
mLauncher
.
setWebProgressListener
(
null
)
;
try
{
var
needUpdate
=
this
.
updateMIMEInfo
(
)
;
if
(
this
.
dialogElement
(
"
save
"
)
.
selected
)
{
this
.
_saveToDiskTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
nsITimer
)
;
this
.
_saveToDiskTimer
.
initWithCallback
(
this
0
nsITimer
.
TYPE_ONE_SHOT
)
;
}
else
this
.
mLauncher
.
launchWithApplication
(
null
false
)
;
if
(
needUpdate
&
&
this
.
mLauncher
.
MIMEInfo
.
MIMEType
!
=
"
application
/
octet
-
stream
"
)
this
.
updateHelperAppPref
(
)
;
}
catch
(
e
)
{
}
this
.
mDialog
.
dialog
=
null
;
return
true
;
}
onCancel
(
)
{
this
.
mLauncher
.
setWebProgressListener
(
null
)
;
try
{
this
.
mLauncher
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
}
catch
(
exception
)
{
}
this
.
mDialog
.
dialog
=
null
;
return
true
;
}
dialogElement
(
id
)
{
return
this
.
mDialog
.
document
.
getElementById
(
id
)
;
}
getFileDisplayName
:
function
getFileDisplayName
(
file
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
if
(
file
instanceof
Ci
.
nsILocalFileWin
)
{
try
{
return
file
.
getVersionInfoField
(
"
FileDescription
"
)
;
}
catch
(
e
)
{
}
}
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
if
(
file
instanceof
Ci
.
nsILocalFileMac
)
{
try
{
return
file
.
bundleDisplayName
;
}
catch
(
e
)
{
}
}
}
return
file
.
leafName
;
}
finishChooseApp
(
)
{
if
(
this
.
chosenApp
)
{
this
.
dialogElement
(
"
modeDeck
"
)
.
setAttribute
(
"
selectedIndex
"
"
0
"
)
;
var
otherHandler
=
this
.
dialogElement
(
"
otherHandler
"
)
;
otherHandler
.
removeAttribute
(
"
hidden
"
)
;
otherHandler
.
setAttribute
(
"
path
"
this
.
getPath
(
this
.
chosenApp
.
executable
)
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
otherHandler
.
label
=
this
.
getFileDisplayName
(
this
.
chosenApp
.
executable
)
;
else
otherHandler
.
label
=
this
.
chosenApp
.
name
;
this
.
dialogElement
(
"
openHandler
"
)
.
selectedIndex
=
1
;
this
.
dialogElement
(
"
openHandler
"
)
.
setAttribute
(
"
lastSelectedItemID
"
"
otherHandler
"
)
;
this
.
dialogElement
(
"
mode
"
)
.
selectedItem
=
this
.
dialogElement
(
"
open
"
)
;
}
else
{
var
openHandler
=
this
.
dialogElement
(
"
openHandler
"
)
;
var
lastSelectedID
=
openHandler
.
getAttribute
(
"
lastSelectedItemID
"
)
;
if
(
!
lastSelectedID
)
lastSelectedID
=
"
defaultHandler
"
;
openHandler
.
selectedItem
=
this
.
dialogElement
(
lastSelectedID
)
;
}
}
chooseApp
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
var
fileExtension
=
"
"
;
try
{
fileExtension
=
this
.
mLauncher
.
MIMEInfo
.
primaryExtension
;
}
catch
(
ex
)
{
}
var
typeString
=
this
.
mLauncher
.
MIMEInfo
.
description
;
if
(
!
typeString
)
{
if
(
fileExtension
)
{
typeString
=
this
.
dialogElement
(
"
strings
"
)
.
getFormattedString
(
"
fileType
"
[
fileExtension
.
toUpperCase
(
)
]
)
;
}
else
{
typeString
=
this
.
mLauncher
.
MIMEInfo
.
MIMEType
;
}
}
var
params
=
{
}
;
params
.
title
=
this
.
dialogElement
(
"
strings
"
)
.
getString
(
"
chooseAppFilePickerTitle
"
)
;
params
.
description
=
typeString
;
params
.
filename
=
this
.
mLauncher
.
suggestedFileName
;
params
.
mimeInfo
=
this
.
mLauncher
.
MIMEInfo
;
params
.
handlerApp
=
null
;
this
.
mDialog
.
openDialog
(
"
chrome
:
/
/
global
/
content
/
appPicker
.
xul
"
null
"
chrome
modal
centerscreen
titlebar
dialog
=
yes
"
params
)
;
if
(
params
.
handlerApp
&
&
params
.
handlerApp
.
executable
&
&
params
.
handlerApp
.
executable
.
isFile
(
)
)
{
this
.
chosenApp
=
params
.
handlerApp
;
}
}
else
if
(
"
mozilla
.
org
/
applicationchooser
;
1
"
in
Cc
)
{
var
nsIApplicationChooser
=
Ci
.
nsIApplicationChooser
;
var
appChooser
=
Cc
[
"
mozilla
.
org
/
applicationchooser
;
1
"
]
.
createInstance
(
nsIApplicationChooser
)
;
appChooser
.
init
(
this
.
mDialog
this
.
dialogElement
(
"
strings
"
)
.
getString
(
"
chooseAppFilePickerTitle
"
)
)
;
var
contentTypeDialogObj
=
this
;
let
appChooserCallback
=
function
appChooserCallback_done
(
aResult
)
{
if
(
aResult
)
{
contentTypeDialogObj
.
chosenApp
=
aResult
.
QueryInterface
(
Ci
.
nsILocalHandlerApp
)
;
}
contentTypeDialogObj
.
finishChooseApp
(
)
;
}
;
appChooser
.
open
(
this
.
mLauncher
.
MIMEInfo
.
MIMEType
appChooserCallback
)
;
return
;
}
else
{
var
nsIFilePicker
=
Ci
.
nsIFilePicker
;
var
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
nsIFilePicker
)
;
fp
.
init
(
this
.
mDialog
this
.
dialogElement
(
"
strings
"
)
.
getString
(
"
chooseAppFilePickerTitle
"
)
nsIFilePicker
.
modeOpen
)
;
fp
.
appendFilters
(
nsIFilePicker
.
filterApps
)
;
fp
.
open
(
aResult
=
>
{
if
(
aResult
=
=
nsIFilePicker
.
returnOK
&
&
fp
.
file
)
{
var
localHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
localHandlerApp
.
executable
=
fp
.
file
;
this
.
chosenApp
=
localHandlerApp
;
}
this
.
finishChooseApp
(
)
;
}
)
;
return
;
}
this
.
finishChooseApp
(
)
;
}
debug
:
false
dump
(
text
)
{
if
(
this
.
debug
)
{
dump
(
text
)
;
}
}
}
;
var
EXPORTED_SYMBOLS
=
[
"
nsUnknownContentTypeDialog
"
]
;
