const
{
AddonTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
)
;
AddonTestUtils
.
initMochitest
(
this
)
;
add_task
(
async
function
setup
(
)
{
Services
.
telemetry
.
clearEvents
(
)
;
}
)
;
function
loadDetailView
(
win
id
)
{
let
doc
=
win
.
document
;
let
card
=
doc
.
querySelector
(
addon
-
card
[
addon
-
id
=
"
{
id
}
"
]
)
;
let
loaded
=
waitForViewLoad
(
win
)
;
EventUtils
.
synthesizeMouseAtCenter
(
card
{
clickCount
:
1
}
win
)
;
return
loaded
;
}
add_task
(
async
function
testChangeAutoUpdates
(
)
{
let
id
=
"
test
mochi
.
test
"
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
name
:
"
Test
"
applications
:
{
gecko
:
{
id
}
}
}
useAddonManager
:
"
permanent
"
}
)
;
await
extension
.
startup
(
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
let
win
=
await
loadInitialView
(
"
extension
"
)
;
let
doc
=
win
.
document
;
let
getInputs
=
updateRow
=
>
(
{
default
:
updatesRow
.
querySelector
(
'
input
[
value
=
"
1
"
]
'
)
on
:
updatesRow
.
querySelector
(
'
input
[
value
=
"
2
"
]
'
)
off
:
updatesRow
.
querySelector
(
'
input
[
value
=
"
0
"
]
'
)
checkForUpdate
:
updatesRow
.
querySelector
(
'
[
action
=
"
update
-
check
"
]
'
)
}
)
;
await
loadDetailView
(
win
id
)
;
let
card
=
doc
.
querySelector
(
addon
-
card
[
addon
-
id
=
"
{
id
}
"
]
)
;
ok
(
card
.
querySelector
(
"
addon
-
details
"
)
"
The
card
now
has
details
"
)
;
let
updatesRow
=
card
.
querySelector
(
"
.
addon
-
detail
-
row
-
updates
"
)
;
let
inputs
=
getInputs
(
updatesRow
)
;
is
(
addon
.
applyBackgroundUpdates
1
"
Default
is
set
"
)
;
ok
(
inputs
.
default
.
checked
"
The
default
option
is
selected
"
)
;
ok
(
inputs
.
checkForUpdate
.
hidden
"
Update
check
is
hidden
"
)
;
inputs
.
on
.
click
(
)
;
is
(
addon
.
applyBackgroundUpdates
2
"
Updates
are
now
enabled
"
)
;
ok
(
inputs
.
on
.
checked
"
The
on
option
is
selected
"
)
;
ok
(
inputs
.
checkForUpdate
.
hidden
"
Update
check
is
hidden
"
)
;
inputs
.
off
.
click
(
)
;
is
(
addon
.
applyBackgroundUpdates
0
"
Updates
are
now
disabled
"
)
;
ok
(
inputs
.
off
.
checked
"
The
off
option
is
selected
"
)
;
ok
(
!
inputs
.
checkForUpdate
.
hidden
"
Update
check
is
visible
"
)
;
let
loaded
=
waitForViewLoad
(
win
)
;
doc
.
querySelector
(
"
.
back
-
button
"
)
.
click
(
)
;
await
loaded
;
await
loadDetailView
(
win
id
)
;
card
=
doc
.
querySelector
(
addon
-
card
[
addon
-
id
=
"
{
id
}
"
]
)
;
updatesRow
=
card
.
querySelector
(
"
.
addon
-
detail
-
row
-
updates
"
)
;
inputs
=
getInputs
(
updatesRow
)
;
ok
(
inputs
.
off
.
checked
"
Off
is
still
selected
"
)
;
let
updated
=
BrowserTestUtils
.
waitForEvent
(
card
"
update
"
)
;
AddonManager
.
autoUpdateDefault
=
false
;
await
updated
;
is
(
addon
.
applyBackgroundUpdates
0
"
Updates
are
now
disabled
"
)
;
ok
(
inputs
.
off
.
checked
"
The
off
option
is
selected
"
)
;
ok
(
!
inputs
.
checkForUpdate
.
hidden
"
Update
check
is
visible
"
)
;
inputs
.
default
.
click
(
)
;
is
(
addon
.
applyBackgroundUpdates
1
"
Default
is
set
"
)
;
ok
(
inputs
.
default
.
checked
"
The
default
option
is
selected
"
)
;
ok
(
!
inputs
.
checkForUpdate
.
hidden
"
Update
check
is
visible
"
)
;
inputs
.
on
.
click
(
)
;
is
(
addon
.
applyBackgroundUpdates
2
"
Updates
are
now
enabled
"
)
;
ok
(
inputs
.
on
.
checked
"
The
on
option
is
selected
"
)
;
ok
(
inputs
.
checkForUpdate
.
hidden
"
Update
check
is
hidden
"
)
;
updated
=
BrowserTestUtils
.
waitForEvent
(
card
"
update
"
)
;
AddonManager
.
autoUpdateDefault
=
true
;
await
updated
;
await
closeView
(
win
)
;
await
extension
.
unload
(
)
;
assertAboutAddonsTelemetryEvents
(
[
[
"
addonsManager
"
"
view
"
"
aboutAddons
"
"
list
"
{
type
:
"
extension
"
}
]
[
"
addonsManager
"
"
view
"
"
aboutAddons
"
"
detail
"
{
type
:
"
extension
"
addonId
:
id
}
]
[
"
addonsManager
"
"
action
"
"
aboutAddons
"
"
enabled
"
{
type
:
"
extension
"
addonId
:
id
action
:
"
setAddonUpdate
"
}
]
[
"
addonsManager
"
"
action
"
"
aboutAddons
"
"
"
{
type
:
"
extension
"
addonId
:
id
action
:
"
setAddonUpdate
"
}
]
[
"
addonsManager
"
"
view
"
"
aboutAddons
"
"
list
"
{
type
:
"
extension
"
}
]
[
"
addonsManager
"
"
view
"
"
aboutAddons
"
"
detail
"
{
type
:
"
extension
"
addonId
:
id
}
]
[
"
addonsManager
"
"
action
"
"
aboutAddons
"
"
default
"
{
type
:
"
extension
"
addonId
:
id
action
:
"
setAddonUpdate
"
}
]
[
"
addonsManager
"
"
action
"
"
aboutAddons
"
"
enabled
"
{
type
:
"
extension
"
addonId
:
id
action
:
"
setAddonUpdate
"
}
]
]
)
;
}
)
;
async
function
setupExtensionWithUpdate
(
id
{
releaseNotes
}
=
{
}
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
extensions
.
checkUpdateSecurity
"
false
]
]
}
)
;
let
server
=
AddonTestUtils
.
createHttpServer
(
)
;
let
serverHost
=
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
;
let
updatesPath
=
/
ext
-
updates
-
{
id
}
.
json
;
let
baseManifest
=
{
name
:
"
Updates
"
applications
:
{
gecko
:
{
id
update_url
:
serverHost
+
updatesPath
}
}
}
;
let
updateXpi
=
AddonTestUtils
.
createTempWebExtensionFile
(
{
manifest
:
{
.
.
.
baseManifest
version
:
"
2
"
}
}
)
;
let
releaseNotesExtra
=
{
}
;
if
(
releaseNotes
)
{
let
notesPath
=
"
/
notes
.
txt
"
;
server
.
registerPathHandler
(
notesPath
(
request
response
)
=
>
{
if
(
releaseNotes
=
=
"
ERROR
"
)
{
response
.
setStatusLine
(
null
404
"
Not
Found
"
)
;
}
else
{
response
.
setStatusLine
(
null
200
"
OK
"
)
;
response
.
write
(
releaseNotes
)
;
}
response
.
processAsync
(
)
;
response
.
finish
(
)
;
}
)
;
releaseNotesExtra
.
update_info_url
=
serverHost
+
notesPath
;
}
let
xpiFilename
=
/
update
-
{
id
}
.
xpi
;
server
.
registerFile
(
xpiFilename
updateXpi
)
;
AddonTestUtils
.
registerJSON
(
server
updatesPath
{
addons
:
{
[
id
]
:
{
updates
:
[
{
version
:
"
2
"
update_link
:
serverHost
+
xpiFilename
.
.
.
releaseNotesExtra
}
]
}
}
}
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
.
.
.
baseManifest
version
:
"
1
"
}
useAddonManager
:
"
permanent
"
}
)
;
await
extension
.
startup
(
)
;
return
extension
;
}
function
disableAutoUpdates
(
card
)
{
let
updateCheckButton
=
card
.
querySelector
(
'
button
[
action
=
"
update
-
check
"
]
'
)
;
ok
(
updateCheckButton
.
hidden
"
The
button
is
initially
hidden
"
)
;
card
.
querySelector
(
'
input
[
name
=
"
autoupdate
"
]
[
value
=
"
0
"
]
'
)
.
click
(
)
;
ok
(
!
updateCheckButton
.
hidden
"
The
button
is
now
visible
"
)
;
assertUpdateState
(
{
card
shown
:
false
}
)
;
}
function
checkForUpdate
(
card
expected
)
{
let
updateCheckButton
=
card
.
querySelector
(
'
button
[
action
=
"
update
-
check
"
]
'
)
;
let
updateFound
=
BrowserTestUtils
.
waitForEvent
(
card
expected
)
;
updateCheckButton
.
click
(
)
;
return
updateFound
;
}
function
installUpdate
(
card
expected
)
{
let
updateInstalled
=
BrowserTestUtils
.
waitForEvent
(
card
expected
)
;
let
updated
=
BrowserTestUtils
.
waitForEvent
(
card
"
update
"
)
;
card
.
querySelector
(
'
panel
-
item
[
action
=
"
install
-
update
"
]
'
)
.
click
(
)
;
return
Promise
.
all
(
[
updateInstalled
updated
]
)
;
}
function
assertUpdateState
(
{
card
shown
expanded
=
true
releaseNotes
=
false
}
)
{
let
menuButton
=
card
.
querySelector
(
"
.
more
-
options
-
button
"
)
;
ok
(
menuButton
.
classList
.
contains
(
"
more
-
options
-
button
-
badged
"
)
=
=
shown
"
The
menu
button
is
badged
"
)
;
let
installButton
=
card
.
querySelector
(
'
panel
-
item
[
action
=
"
install
-
update
"
]
'
)
;
ok
(
installButton
.
hidden
!
=
shown
The
install
button
is
{
shown
?
"
hidden
"
:
"
shown
"
}
)
;
if
(
expanded
)
{
let
updateCheckButton
=
card
.
querySelector
(
'
button
[
action
=
"
update
-
check
"
]
'
)
;
ok
(
updateCheckButton
.
hidden
=
=
shown
The
update
check
button
is
{
shown
?
"
hidden
"
:
"
shown
"
}
)
;
let
{
tabGroup
}
=
card
.
details
;
is
(
tabGroup
.
hidden
false
"
The
tab
group
is
shown
"
)
;
let
notesBtn
=
tabGroup
.
querySelector
(
'
[
name
=
"
release
-
notes
"
]
'
)
;
is
(
notesBtn
.
hidden
!
releaseNotes
The
release
notes
button
is
{
releaseNotes
?
"
shown
"
:
"
hidden
"
}
)
;
}
}
add_task
(
async
function
testUpdateAvailable
(
)
{
let
id
=
"
update
mochi
.
test
"
;
let
extension
=
await
setupExtensionWithUpdate
(
id
)
;
let
win
=
await
loadInitialView
(
"
extension
"
)
;
let
doc
=
win
.
document
;
await
loadDetailView
(
win
id
)
;
let
card
=
doc
.
querySelector
(
"
addon
-
card
"
)
;
disableAutoUpdates
(
card
)
;
await
checkForUpdate
(
card
"
update
-
found
"
)
;
assertUpdateState
(
{
card
shown
:
true
}
)
;
let
versionRow
=
card
.
querySelector
(
"
.
addon
-
detail
-
row
-
version
"
)
;
is
(
versionRow
.
lastChild
.
textContent
"
1
"
"
The
version
started
as
1
"
)
;
await
installUpdate
(
card
"
update
-
installed
"
)
;
versionRow
=
card
.
querySelector
(
"
.
addon
-
detail
-
row
-
version
"
)
;
is
(
versionRow
.
lastChild
.
textContent
"
2
"
"
The
version
has
updated
"
)
;
assertUpdateState
(
{
card
shown
:
false
}
)
;
await
checkForUpdate
(
card
"
no
-
update
"
)
;
await
closeView
(
win
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
testReleaseNotesLoad
(
)
{
Services
.
telemetry
.
clearEvents
(
)
;
let
id
=
"
update
-
with
-
notes
mochi
.
test
"
;
let
extension
=
await
setupExtensionWithUpdate
(
id
{
releaseNotes
:
<
html
xmlns
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
>
<
head
>
<
link
rel
=
"
stylesheet
"
href
=
"
remove
-
me
.
css
"
/
>
<
/
head
>
<
body
>
<
script
src
=
"
no
-
scripts
.
js
"
>
<
/
script
>
<
h1
>
My
release
notes
<
/
h1
>
<
img
src
=
"
http
:
/
/
example
.
com
/
tracker
.
png
"
/
>
<
ul
>
<
li
onclick
=
"
alert
(
'
hi
'
)
"
>
A
thing
<
/
li
>
<
/
ul
>
<
a
href
=
"
http
:
/
/
example
.
com
/
"
>
Go
somewhere
<
/
a
>
<
/
body
>
<
/
html
>
}
)
;
let
win
=
await
loadInitialView
(
"
extension
"
)
;
let
doc
=
win
.
document
;
await
loadDetailView
(
win
id
)
;
let
card
=
doc
.
querySelector
(
"
addon
-
card
"
)
;
let
{
deck
tabGroup
}
=
card
.
details
;
disableAutoUpdates
(
card
)
;
await
checkForUpdate
(
card
"
update
-
found
"
)
;
assertUpdateState
(
{
card
shown
:
true
releaseNotes
:
true
}
)
;
info
(
"
Check
release
notes
"
)
;
let
notesBtn
=
tabGroup
.
querySelector
(
'
[
name
=
"
release
-
notes
"
]
'
)
;
let
notes
=
card
.
querySelector
(
"
update
-
release
-
notes
"
)
;
let
loading
=
BrowserTestUtils
.
waitForEvent
(
notes
"
release
-
notes
-
loading
"
)
;
let
loaded
=
BrowserTestUtils
.
waitForEvent
(
notes
"
release
-
notes
-
loaded
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
notesBtn
{
}
win
)
;
await
loading
;
is
(
doc
.
l10n
.
getAttributes
(
notes
.
firstElementChild
)
.
id
"
release
-
notes
-
loading
"
"
The
loading
message
is
shown
"
)
;
await
loaded
;
info
(
"
Checking
HTML
release
notes
"
)
;
let
[
h1
ul
a
]
=
notes
.
children
;
is
(
h1
.
tagName
"
H1
"
"
There
'
s
a
heading
"
)
;
is
(
h1
.
textContent
"
My
release
notes
"
"
The
heading
has
content
"
)
;
is
(
ul
.
tagName
"
UL
"
"
There
'
s
a
list
"
)
;
is
(
ul
.
children
.
length
1
"
There
'
s
one
item
in
the
list
"
)
;
let
[
li
]
=
ul
.
children
;
is
(
li
.
tagName
"
LI
"
"
There
'
s
a
list
item
"
)
;
is
(
li
.
textContent
"
A
thing
"
"
The
text
is
set
"
)
;
ok
(
!
li
.
hasAttribute
(
"
onclick
"
)
"
The
onclick
was
removed
"
)
;
ok
(
!
notes
.
querySelector
(
"
link
"
)
"
The
link
tag
was
removed
"
)
;
ok
(
!
notes
.
querySelector
(
"
script
"
)
"
The
script
tag
was
removed
"
)
;
is
(
a
.
textContent
"
Go
somewhere
"
"
The
link
text
is
preserved
"
)
;
is
(
a
.
href
"
http
:
/
/
example
.
com
/
"
"
The
link
href
is
preserved
"
)
;
info
(
"
Verify
the
link
opened
in
a
new
tab
"
)
;
let
tabOpened
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
a
.
href
)
;
a
.
click
(
)
;
let
tab
=
await
tabOpened
;
BrowserTestUtils
.
removeTab
(
tab
)
;
let
originalContent
=
notes
.
innerHTML
;
info
(
"
Switch
away
and
back
to
release
notes
"
)
;
let
detailsBtn
=
tabGroup
.
querySelector
(
'
named
-
deck
-
button
[
name
=
"
details
"
]
'
)
;
let
viewChanged
=
BrowserTestUtils
.
waitForEvent
(
deck
"
view
-
changed
"
)
;
detailsBtn
.
click
(
)
;
await
viewChanged
;
viewChanged
=
BrowserTestUtils
.
waitForEvent
(
deck
"
view
-
changed
"
)
;
let
notesCached
=
BrowserTestUtils
.
waitForEvent
(
notes
"
release
-
notes
-
cached
"
)
;
notesBtn
.
click
(
)
;
await
viewChanged
;
await
notesCached
;
is
(
notes
.
innerHTML
originalContent
"
The
content
didn
'
t
change
"
)
;
info
(
"
Install
the
update
to
clean
it
up
"
)
;
await
installUpdate
(
card
"
update
-
installed
"
)
;
assertUpdateState
(
{
card
shown
:
false
releaseNotes
:
true
}
)
;
await
closeView
(
win
)
;
await
extension
.
unload
(
)
;
assertAboutAddonsTelemetryEvents
(
[
[
"
addonsManager
"
"
view
"
"
aboutAddons
"
"
list
"
{
type
:
"
extension
"
}
]
[
"
addonsManager
"
"
view
"
"
aboutAddons
"
"
detail
"
{
type
:
"
extension
"
addonId
:
id
}
]
[
"
addonsManager
"
"
action
"
"
aboutAddons
"
"
"
{
type
:
"
extension
"
addonId
:
id
action
:
"
setAddonUpdate
"
}
]
[
"
addonsManager
"
"
action
"
"
aboutAddons
"
null
{
type
:
"
extension
"
addonId
:
id
action
:
"
checkForUpdate
"
}
]
[
"
addonsManager
"
"
action
"
"
aboutAddons
"
null
{
type
:
"
extension
"
addonId
:
id
action
:
"
releaseNotes
"
}
]
[
"
addonsManager
"
"
action
"
"
aboutAddons
"
null
{
type
:
"
extension
"
addonId
:
id
action
:
"
releaseNotes
"
}
]
]
)
;
}
)
;
add_task
(
async
function
testReleaseNotesError
(
)
{
let
id
=
"
update
-
with
-
notes
-
error
mochi
.
test
"
;
let
extension
=
await
setupExtensionWithUpdate
(
id
{
releaseNotes
:
"
ERROR
"
}
)
;
let
win
=
await
loadInitialView
(
"
extension
"
)
;
let
doc
=
win
.
document
;
await
loadDetailView
(
win
id
)
;
let
card
=
doc
.
querySelector
(
"
addon
-
card
"
)
;
let
{
deck
tabGroup
}
=
card
.
details
;
disableAutoUpdates
(
card
)
;
await
checkForUpdate
(
card
"
update
-
found
"
)
;
assertUpdateState
(
{
card
shown
:
true
releaseNotes
:
true
}
)
;
info
(
"
Check
release
notes
"
)
;
let
notesBtn
=
tabGroup
.
querySelector
(
'
[
name
=
"
release
-
notes
"
]
'
)
;
let
notes
=
card
.
querySelector
(
"
update
-
release
-
notes
"
)
;
let
loading
=
BrowserTestUtils
.
waitForEvent
(
notes
"
release
-
notes
-
loading
"
)
;
let
errored
=
BrowserTestUtils
.
waitForEvent
(
notes
"
release
-
notes
-
error
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
notesBtn
{
}
win
)
;
await
loading
;
is
(
doc
.
l10n
.
getAttributes
(
notes
.
firstElementChild
)
.
id
"
release
-
notes
-
loading
"
"
The
loading
message
is
shown
"
)
;
await
errored
;
is
(
doc
.
l10n
.
getAttributes
(
notes
.
firstElementChild
)
.
id
"
release
-
notes
-
error
"
"
The
error
message
is
shown
"
)
;
info
(
"
Switch
away
and
back
to
release
notes
"
)
;
let
detailsBtn
=
tabGroup
.
querySelector
(
'
named
-
deck
-
button
[
name
=
"
details
"
]
'
)
;
let
viewChanged
=
BrowserTestUtils
.
waitForEvent
(
deck
"
view
-
changed
"
)
;
detailsBtn
.
click
(
)
;
await
viewChanged
;
viewChanged
=
BrowserTestUtils
.
waitForEvent
(
deck
"
view
-
changed
"
)
;
let
notesCached
=
BrowserTestUtils
.
waitForEvent
(
notes
"
release
-
notes
-
cached
"
)
;
notesBtn
.
click
(
)
;
await
viewChanged
;
await
notesCached
;
info
(
"
Install
the
update
to
clean
it
up
"
)
;
await
installUpdate
(
card
"
update
-
installed
"
)
;
await
closeView
(
win
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
testUpdateCancelled
(
)
{
let
id
=
"
update
mochi
.
test
"
;
let
extension
=
await
setupExtensionWithUpdate
(
id
)
;
let
win
=
await
loadInitialView
(
"
extension
"
)
;
let
doc
=
win
.
document
;
await
loadDetailView
(
win
"
update
mochi
.
test
"
)
;
let
card
=
doc
.
querySelector
(
"
addon
-
card
"
)
;
disableAutoUpdates
(
card
)
;
await
checkForUpdate
(
card
"
update
-
found
"
)
;
assertUpdateState
(
{
card
shown
:
true
}
)
;
let
versionRow
=
card
.
querySelector
(
"
.
addon
-
detail
-
row
-
version
"
)
;
is
(
versionRow
.
lastChild
.
textContent
"
1
"
"
The
version
started
as
1
"
)
;
let
install
=
card
.
updateInstall
;
ok
(
install
"
There
was
an
install
found
"
)
;
install
.
promptHandler
=
Promise
.
reject
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
installUpdate
(
card
"
update
-
cancelled
"
)
;
versionRow
=
card
.
querySelector
(
"
.
addon
-
detail
-
row
-
version
"
)
;
is
(
versionRow
.
lastChild
.
textContent
"
1
"
"
The
version
hasn
'
t
changed
"
)
;
assertUpdateState
(
{
card
shown
:
false
}
)
;
await
closeView
(
win
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
testAvailableUpdates
(
)
{
let
ids
=
[
"
update1
mochi
.
test
"
"
update2
mochi
.
test
"
"
update3
mochi
.
test
"
]
;
let
addons
=
await
Promise
.
all
(
ids
.
map
(
id
=
>
setupExtensionWithUpdate
(
id
)
)
)
;
AddonManager
.
autoUpdateDefault
=
false
;
let
win
=
await
loadInitialView
(
"
extension
"
)
;
let
doc
=
win
.
document
;
let
{
gCategories
}
=
win
.
managerWindow
;
let
availableCat
=
gCategories
.
get
(
"
addons
:
/
/
updates
/
available
"
)
;
ok
(
availableCat
.
hidden
"
Available
updates
is
hidden
"
)
;
is
(
availableCat
.
badgeCount
0
"
There
are
no
updates
"
)
;
let
updatesFound
=
TestUtils
.
topicObserved
(
"
EM
-
update
-
check
-
finished
"
)
;
doc
.
querySelector
(
'
#
page
-
options
[
action
=
"
check
-
for
-
updates
"
]
'
)
.
click
(
)
;
await
updatesFound
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
availableCat
.
badgeCount
=
=
3
)
;
ok
(
!
availableCat
.
hidden
"
Available
updates
is
visible
"
)
;
is
(
availableCat
.
badgeCount
3
"
There
are
3
updates
"
)
;
let
loaded
=
waitForViewLoad
(
win
)
;
availableCat
.
click
(
)
;
await
loaded
;
let
cards
=
doc
.
querySelectorAll
(
"
addon
-
card
"
)
;
is
(
cards
.
length
3
"
There
are
3
cards
"
)
;
for
(
let
card
of
cards
)
{
assertUpdateState
(
{
card
shown
:
true
expanded
:
false
}
)
;
}
await
loadDetailView
(
win
ids
[
0
]
)
;
is
(
gCategories
.
selected
"
addons
:
/
/
list
/
extension
"
"
The
extensions
category
is
selected
"
)
;
loaded
=
waitForViewLoad
(
win
)
;
doc
.
querySelector
(
"
.
back
-
button
"
)
.
click
(
)
;
await
loaded
;
is
(
gCategories
.
selected
"
addons
:
/
/
updates
/
available
"
"
The
available
updates
category
is
selected
"
)
;
cards
=
doc
.
querySelectorAll
(
"
addon
-
card
"
)
;
is
(
cards
.
length
3
"
There
are
3
cards
"
)
;
await
installUpdate
(
cards
[
0
]
"
update
-
installed
"
)
;
assertUpdateState
(
{
card
:
cards
[
0
]
shown
:
false
expanded
:
false
}
)
;
is
(
availableCat
.
badgeCount
2
"
There
are
only
2
updates
now
"
)
;
is
(
doc
.
querySelectorAll
(
"
addon
-
card
"
)
.
length
3
"
All
3
cards
are
still
visible
on
the
updates
page
"
)
;
await
installUpdate
(
cards
[
1
]
"
update
-
installed
"
)
;
assertUpdateState
(
{
card
:
cards
[
1
]
shown
:
false
expanded
:
false
}
)
;
await
installUpdate
(
cards
[
2
]
"
update
-
installed
"
)
;
assertUpdateState
(
{
card
:
cards
[
2
]
shown
:
false
expanded
:
false
}
)
;
is
(
availableCat
.
badgeCount
0
"
There
are
no
more
updates
"
)
;
is
(
doc
.
querySelectorAll
(
"
addon
-
card
"
)
.
length
3
"
All
3
cards
are
still
visible
on
the
updates
page
"
)
;
AddonManager
.
autoUpdateDefault
=
true
;
await
closeView
(
win
)
;
await
Promise
.
all
(
addons
.
map
(
addon
=
>
addon
.
unload
(
)
)
)
;
}
)
;
