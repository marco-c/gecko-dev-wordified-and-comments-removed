"
use
strict
"
;
const
{
AddonTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
)
;
const
{
ExtensionUtils
:
{
promiseEvent
promiseObserved
}
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
API_RESPONSE_FILE
=
RELATIVE_DIR
+
"
discovery
/
api_response
.
json
"
;
const
AMO_TEST_HOST
=
"
rewritten
-
for
-
testing
.
addons
.
allizom
.
org
"
;
const
ArrayBufferInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
io
/
arraybuffer
-
input
-
stream
;
1
"
"
nsIArrayBufferInputStream
"
"
setData
"
)
;
AddonTestUtils
.
initMochitest
(
this
)
;
const
amoServer
=
AddonTestUtils
.
createHttpServer
(
{
hosts
:
[
AMO_TEST_HOST
]
}
)
;
amoServer
.
registerFile
(
"
/
png
"
FileUtils
.
getFile
(
"
CurWorkD
"
{
RELATIVE_DIR
}
discovery
/
small
-
1x1
.
png
.
split
(
"
/
"
)
)
)
;
amoServer
.
registerPathHandler
(
"
/
dummy
"
(
request
response
)
=
>
{
response
.
write
(
"
Dummy
"
)
;
}
)
;
function
getTestExpectationFromApiResult
(
result
)
{
return
{
typeIsTheme
:
result
.
addon
.
type
=
=
=
"
statictheme
"
addonName
:
result
.
addon
.
name
authorName
:
result
.
addon
.
authors
[
0
]
.
name
editorialHead
:
result
.
heading_text
editorialBody
:
result
.
description_text
dailyUsers
:
result
.
addon
.
average_daily_users
rating
:
result
.
addon
.
ratings
.
average
}
;
}
async
function
readAPIResponseFixture
(
)
{
let
apiText
=
await
OS
.
File
.
read
(
API_RESPONSE_FILE
{
encoding
:
"
utf
-
8
"
}
)
;
apiText
=
apiText
.
replace
(
/
\
bhttps
?
:
\
/
\
/
[
^
"
]
+
(
?
=
"
)
/
g
url
=
>
{
try
{
url
=
new
URL
(
url
)
;
}
catch
(
e
)
{
return
url
;
}
let
ext
=
url
.
pathname
.
split
(
"
.
"
)
.
pop
(
)
;
return
http
:
/
/
{
AMO_TEST_HOST
}
/
{
ext
}
?
{
url
.
pathname
}
{
url
.
search
}
;
}
)
;
return
apiText
;
}
class
DiscoveryAPIHandler
{
constructor
(
responseText
)
{
this
.
setResponseText
(
responseText
)
;
this
.
requestCount
=
0
;
amoServer
.
registerPathHandler
(
"
/
discoapi
"
this
)
;
}
setResponseText
(
responseText
)
{
this
.
responseBody
=
new
TextEncoder
(
)
.
encode
(
responseText
)
.
buffer
;
}
blockNextResponses
(
)
{
this
.
_unblockPromise
=
new
Promise
(
resolve
=
>
{
this
.
unblockResponses
=
resolve
;
}
)
;
}
unblockResponses
(
responseText
)
{
throw
new
Error
(
"
You
need
to
call
blockNextResponses
first
!
"
)
;
}
async
handle
(
request
response
)
{
+
+
this
.
requestCount
;
response
.
setHeader
(
"
Cache
-
Control
"
"
no
-
cache
"
false
)
;
response
.
processAsync
(
)
;
await
this
.
_unblockPromise
;
let
body
=
this
.
responseBody
;
let
binStream
=
new
ArrayBufferInputStream
(
body
0
body
.
byteLength
)
;
response
.
bodyOutputStream
.
writeFrom
(
binStream
body
.
byteLength
)
;
response
.
finish
(
)
;
}
}
function
getVisibleActions
(
documentOrElement
)
{
return
Array
.
from
(
documentOrElement
.
querySelectorAll
(
"
[
action
]
"
)
)
.
filter
(
elem
=
>
elem
.
getAttribute
(
"
action
"
)
!
=
=
"
page
-
options
"
&
&
elem
.
offsetWidth
&
&
elem
.
offsetHeight
)
;
}
function
getActionName
(
actionElement
)
{
return
actionElement
.
getAttribute
(
"
action
"
)
;
}
function
getDiscoveryElement
(
win
)
{
return
win
.
document
.
querySelector
(
"
discovery
-
pane
"
)
;
}
function
getCardContainer
(
win
)
{
return
getDiscoveryElement
(
win
)
.
querySelector
(
"
recommended
-
addon
-
list
"
)
;
}
function
getCardByAddonId
(
win
addonId
)
{
for
(
let
card
of
win
.
document
.
querySelectorAll
(
"
recommended
-
addon
-
card
"
)
)
{
if
(
card
.
addonId
=
=
=
addonId
)
{
return
card
;
}
}
return
null
;
}
function
promiseDiscopaneUpdate
(
win
)
{
let
{
cardsReady
}
=
getCardContainer
(
win
)
;
ok
(
cardsReady
"
Discovery
cards
should
have
started
to
initialize
"
)
;
return
cardsReady
;
}
async
function
switchToNonDiscoView
(
win
)
{
win
.
managerWindow
.
gViewController
.
loadView
(
"
addons
:
/
/
list
/
extension
"
)
;
await
wait_for_view_load
(
win
.
managerWindow
)
;
ok
(
win
.
document
.
querySelector
(
"
addon
-
list
"
)
"
Should
be
at
the
extension
list
view
"
)
;
}
async
function
switchToDiscoView
(
win
)
{
is
(
getDiscoveryElement
(
win
)
null
"
Cannot
switch
to
discopane
when
the
discopane
is
already
shown
"
)
;
win
.
managerWindow
.
gViewController
.
loadView
(
"
addons
:
/
/
discover
/
"
)
;
await
wait_for_view_load
(
win
.
managerWindow
)
;
await
promiseDiscopaneUpdate
(
win
)
;
}
async
function
waitForAllImagesLoaded
(
win
)
{
let
imgs
=
Array
.
from
(
win
.
document
.
querySelectorAll
(
"
discovery
-
pane
img
[
src
]
"
)
)
;
function
areAllImagesLoaded
(
)
{
let
loadCount
=
imgs
.
filter
(
img
=
>
img
.
naturalWidth
)
.
length
;
info
(
Loaded
{
loadCount
}
out
of
{
imgs
.
length
}
images
)
;
return
loadCount
=
=
=
imgs
.
length
;
}
if
(
!
areAllImagesLoaded
(
)
)
{
await
promiseEvent
(
win
.
document
"
load
"
true
areAllImagesLoaded
)
;
}
return
imgs
.
length
;
}
async
function
promiseAddonInstall
(
amoServer
extensionData
)
{
let
description
=
extensionData
.
manifest
.
description
;
let
xpiFile
=
AddonTestUtils
.
createTempWebExtensionFile
(
extensionData
)
;
amoServer
.
registerFile
(
"
/
xpi
"
xpiFile
)
;
let
addonId
=
extensionData
.
manifest
.
applications
.
gecko
.
id
;
let
installedPromise
=
waitAppMenuNotificationShown
(
"
addon
-
installed
"
addonId
true
)
;
if
(
!
extensionData
.
manifest
.
theme
)
{
info
(
{
description
}
:
Waiting
for
permission
prompt
)
;
let
panel
=
await
promisePopupNotificationShown
(
"
addon
-
webext
-
permissions
"
)
;
panel
.
button
.
click
(
)
;
}
else
{
info
(
{
description
}
:
Waiting
for
install
prompt
)
;
let
panel
=
await
promisePopupNotificationShown
(
"
addon
-
install
-
confirmation
"
)
;
panel
.
button
.
click
(
)
;
}
info
(
"
Waiting
for
post
-
install
doorhanger
"
)
;
await
installedPromise
;
let
addon
=
await
AddonManager
.
getAddonByID
(
addonId
)
;
Assert
.
deepEqual
(
addon
.
installTelemetryInfo
{
source
:
"
disco
"
}
"
The
installed
add
-
on
should
have
the
expected
telemetry
info
"
)
;
}
async
function
testCardInstall
(
card
)
{
Assert
.
deepEqual
(
getVisibleActions
(
card
)
.
map
(
getActionName
)
[
"
install
-
addon
"
]
"
Should
have
an
Install
button
before
install
"
)
;
let
installButton
=
card
.
querySelector
(
"
[
data
-
l10n
-
id
=
'
install
-
extension
-
button
'
]
"
)
|
|
card
.
querySelector
(
"
[
data
-
l10n
-
id
=
'
install
-
theme
-
button
'
]
"
)
;
let
updatePromise
=
promiseEvent
(
card
"
disco
-
card
-
updated
"
)
;
installButton
.
click
(
)
;
await
updatePromise
;
Assert
.
deepEqual
(
getVisibleActions
(
card
)
.
map
(
getActionName
)
[
"
manage
-
addon
"
]
"
Should
have
a
Manage
button
after
install
"
)
;
}
async
function
testAddonUninstall
(
card
)
{
Assert
.
deepEqual
(
getVisibleActions
(
card
)
.
map
(
getActionName
)
[
"
manage
-
addon
"
]
"
Should
have
a
Manage
button
before
uninstall
"
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
card
.
addonId
)
;
let
updatePromise
=
promiseEvent
(
card
"
disco
-
card
-
updated
"
)
;
await
addon
.
uninstall
(
)
;
await
updatePromise
;
Assert
.
deepEqual
(
getVisibleActions
(
card
)
.
map
(
getActionName
)
[
"
install
-
addon
"
]
"
Should
have
an
Install
button
after
uninstall
"
)
;
}
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
extensions
.
getAddons
.
discovery
.
api_url
"
http
:
/
/
{
AMO_TEST_HOST
}
/
discoapi
]
[
"
extensions
.
htmlaboutaddons
.
recommendations
.
enabled
"
false
]
[
"
browser
.
discovery
.
enabled
"
false
]
]
}
)
;
}
)
;
add_task
(
async
function
discopane_with_real_api_data
(
)
{
const
apiText
=
await
readAPIResponseFixture
(
)
;
let
apiHandler
=
new
DiscoveryAPIHandler
(
apiText
)
;
const
apiResultArray
=
JSON
.
parse
(
apiText
)
.
results
;
ok
(
apiResultArray
.
length
Mock
has
{
Array
.
length
}
results
)
;
apiHandler
.
blockNextResponses
(
)
;
let
win
=
await
loadInitialView
(
"
discover
"
)
;
Assert
.
deepEqual
(
getVisibleActions
(
win
.
document
)
.
map
(
getActionName
)
[
]
"
The
AMO
button
should
be
invisible
when
the
AMO
API
hasn
'
t
responded
"
)
;
apiHandler
.
unblockResponses
(
)
;
await
promiseDiscopaneUpdate
(
win
)
;
let
actionElements
=
getVisibleActions
(
win
.
document
)
;
Assert
.
deepEqual
(
actionElements
.
map
(
getActionName
)
[
.
.
.
new
Array
(
apiResultArray
.
length
)
.
fill
(
"
install
-
addon
"
)
"
open
-
amo
"
]
"
All
add
-
on
cards
should
be
rendered
with
AMO
button
at
the
end
.
"
)
;
let
imgCount
=
await
waitForAllImagesLoaded
(
win
)
;
is
(
imgCount
apiResultArray
.
length
"
Expected
an
image
for
every
result
"
)
;
let
cards
=
Array
.
from
(
win
.
document
.
querySelectorAll
(
"
recommended
-
addon
-
card
"
)
)
;
is
(
cards
.
length
apiResultArray
.
length
"
Every
API
result
has
a
card
"
)
;
for
(
let
[
i
card
]
of
cards
.
entries
(
)
)
{
let
expectations
=
getTestExpectationFromApiResult
(
apiResultArray
[
i
]
)
;
info
(
Expectations
for
card
{
i
}
:
{
JSON
.
stringify
(
expectations
)
}
)
;
let
checkContent
=
(
selector
expectation
)
=
>
{
let
text
=
card
.
querySelector
(
selector
)
.
textContent
;
is
(
text
expectation
Content
of
selector
"
{
selector
}
"
)
;
}
;
checkContent
(
"
.
disco
-
addon
-
name
"
expectations
.
addonName
)
;
await
win
.
document
.
l10n
.
translateFragment
(
card
)
;
checkContent
(
"
.
disco
-
addon
-
author
[
data
-
l10n
-
name
=
'
author
'
]
"
expectations
.
authorName
)
;
let
amoListingLink
=
card
.
querySelector
(
"
.
disco
-
addon
-
author
a
"
)
;
ok
(
amoListingLink
.
search
.
includes
(
"
utm_source
=
firefox
-
browser
"
)
Listing
link
should
have
attribution
parameter
url
=
{
amoListingLink
}
)
;
let
actions
=
getVisibleActions
(
card
)
;
is
(
actions
.
length
1
"
Card
should
only
have
one
install
button
"
)
;
let
installButton
=
actions
[
0
]
;
if
(
expectations
.
typeIsTheme
)
{
ok
(
installButton
.
matches
(
"
[
data
-
l10n
-
id
=
'
install
-
theme
-
button
'
"
)
"
Has
theme
install
button
"
)
;
ok
(
card
.
querySelector
(
"
.
card
-
heading
-
image
"
)
.
offsetWidth
"
Preview
image
must
be
visible
"
)
;
}
else
{
ok
(
installButton
.
matches
(
"
[
data
-
l10n
-
id
=
'
install
-
extension
-
button
'
"
)
"
Has
extension
install
button
"
)
;
checkContent
(
"
.
disco
-
description
-
intro
"
expectations
.
editorialHead
)
;
checkContent
(
"
.
disco
-
description
-
main
"
expectations
.
editorialBody
)
;
let
ratingElem
=
card
.
querySelector
(
"
five
-
star
-
rating
"
)
;
if
(
expectations
.
rating
)
{
is
(
ratingElem
.
rating
expectations
.
rating
"
Expected
rating
value
"
)
;
ok
(
ratingElem
.
offsetWidth
"
Rating
element
is
visible
"
)
;
}
else
{
is
(
ratingElem
.
offsetWidth
0
"
Rating
element
is
not
visible
"
)
;
}
let
userCountElem
=
card
.
querySelector
(
"
.
disco
-
user
-
count
"
)
;
if
(
expectations
.
dailyUsers
)
{
Assert
.
deepEqual
(
win
.
document
.
l10n
.
getAttributes
(
userCountElem
)
{
id
:
"
user
-
count
"
args
:
{
dailyUsers
:
expectations
.
dailyUsers
}
}
"
Card
count
should
be
rendered
"
)
;
}
else
{
is
(
userCountElem
.
offsetWidth
0
"
User
count
element
is
not
visible
"
)
;
}
}
}
is
(
apiHandler
.
requestCount
1
"
Discovery
API
should
be
fetched
once
"
)
;
await
closeView
(
win
)
;
}
)
;
add_task
(
async
function
install_from_discopane
(
)
{
const
apiText
=
await
readAPIResponseFixture
(
)
;
const
apiResultArray
=
JSON
.
parse
(
apiText
)
.
results
;
let
getAddonIdByAMOAddonType
=
type
=
>
apiResultArray
.
find
(
r
=
>
r
.
addon
.
type
=
=
=
type
)
.
addon
.
guid
;
const
FIRST_EXTENSION_ID
=
getAddonIdByAMOAddonType
(
"
extension
"
)
;
const
FIRST_THEME_ID
=
getAddonIdByAMOAddonType
(
"
statictheme
"
)
;
let
apiHandler
=
new
DiscoveryAPIHandler
(
apiText
)
;
let
win
=
await
loadInitialView
(
"
discover
"
)
;
await
promiseDiscopaneUpdate
(
win
)
;
await
waitForAllImagesLoaded
(
win
)
;
Services
.
telemetry
.
clearEvents
(
)
;
let
installExtensionPromise
=
promiseAddonInstall
(
amoServer
{
manifest
:
{
name
:
"
My
Awesome
Add
-
on
"
description
:
"
Test
extension
install
button
"
applications
:
{
gecko
:
{
id
:
FIRST_EXTENSION_ID
}
}
permissions
:
[
"
<
all_urls
>
"
]
}
}
)
;
await
testCardInstall
(
getCardByAddonId
(
win
FIRST_EXTENSION_ID
)
)
;
await
installExtensionPromise
;
let
installThemePromise
=
promiseAddonInstall
(
amoServer
{
manifest
:
{
name
:
"
My
Fancy
Theme
"
description
:
"
Test
theme
install
button
"
applications
:
{
gecko
:
{
id
:
FIRST_THEME_ID
}
}
theme
:
{
colors
:
{
tab_selected
:
"
red
"
}
}
}
}
)
;
let
promiseThemeChange
=
promiseObserved
(
"
lightweight
-
theme
-
styling
-
update
"
)
;
await
testCardInstall
(
getCardByAddonId
(
win
FIRST_THEME_ID
)
)
;
await
installThemePromise
;
await
promiseThemeChange
;
Assert
.
deepEqual
(
getVisibleActions
(
win
.
document
)
.
map
(
getActionName
)
[
"
manage
-
addon
"
"
manage
-
addon
"
.
.
.
new
Array
(
apiResultArray
.
length
-
2
)
.
fill
(
"
install
-
addon
"
)
"
open
-
amo
"
]
"
The
Install
buttons
should
be
replaced
with
Manage
buttons
"
)
;
assertAboutAddonsTelemetryEvents
(
[
[
"
addonsManager
"
"
action
"
"
aboutAddons
"
null
{
action
:
"
installFromRecommendation
"
view
:
"
discover
"
addonId
:
FIRST_EXTENSION_ID
type
:
"
extension
"
}
]
[
"
addonsManager
"
"
action
"
"
aboutAddons
"
null
{
action
:
"
installFromRecommendation
"
view
:
"
discover
"
addonId
:
FIRST_THEME_ID
type
:
"
theme
"
}
]
]
)
;
let
loaded
=
waitForViewLoad
(
win
)
;
getCardByAddonId
(
win
FIRST_EXTENSION_ID
)
.
querySelector
(
"
[
action
=
'
manage
-
addon
'
]
"
)
.
click
(
)
;
await
loaded
;
{
let
addonCard
=
win
.
document
.
querySelector
(
addon
-
card
[
addon
-
id
=
"
{
FIRST_EXTENSION_ID
}
"
]
)
;
ok
(
addonCard
"
Add
-
on
details
should
be
shown
"
)
;
ok
(
addonCard
.
expanded
"
The
card
should
have
been
expanded
"
)
;
}
assertAboutAddonsTelemetryEvents
(
[
[
"
addonsManager
"
"
action
"
"
aboutAddons
"
null
{
action
:
"
manage
"
view
:
"
discover
"
addonId
:
FIRST_EXTENSION_ID
type
:
"
extension
"
}
]
]
{
methods
:
[
"
action
"
]
}
)
;
await
switchToDiscoView
(
win
)
;
await
waitForAllImagesLoaded
(
win
)
;
Assert
.
deepEqual
(
getVisibleActions
(
win
.
document
)
.
map
(
getActionName
)
[
.
.
.
new
Array
(
apiResultArray
.
length
-
2
)
.
fill
(
"
install
-
addon
"
)
"
manage
-
addon
"
"
manage
-
addon
"
"
open
-
amo
"
]
"
Already
-
installed
add
-
ons
should
be
rendered
at
the
end
of
the
list
"
)
;
promiseThemeChange
=
promiseObserved
(
"
lightweight
-
theme
-
styling
-
update
"
)
;
await
testAddonUninstall
(
getCardByAddonId
(
win
FIRST_THEME_ID
)
)
;
await
promiseThemeChange
;
await
testAddonUninstall
(
getCardByAddonId
(
win
FIRST_EXTENSION_ID
)
)
;
is
(
apiHandler
.
requestCount
1
"
Discovery
API
should
be
fetched
once
"
)
;
await
closeView
(
win
)
;
}
)
;
add_task
(
async
function
discopane_navigate_while_loading
(
)
{
let
apiHandler
=
new
DiscoveryAPIHandler
(
{
"
results
"
:
[
]
}
)
;
apiHandler
.
blockNextResponses
(
)
;
let
win
=
await
loadInitialView
(
"
discover
"
)
;
let
updatePromise
=
promiseDiscopaneUpdate
(
win
)
;
let
didUpdateDiscopane
=
false
;
updatePromise
.
then
(
(
)
=
>
{
didUpdateDiscopane
=
true
;
}
)
;
await
switchToNonDiscoView
(
win
)
;
is
(
didUpdateDiscopane
false
"
discopane
should
still
not
be
updated
because
the
request
is
blocked
"
)
;
is
(
getDiscoveryElement
(
win
)
null
"
Discopane
should
be
removed
after
switching
to
the
extension
list
"
)
;
apiHandler
.
unblockResponses
(
)
;
await
updatePromise
;
ok
(
win
.
document
.
querySelector
(
"
addon
-
list
"
)
"
Should
still
be
at
the
extension
list
view
"
)
;
is
(
getDiscoveryElement
(
win
)
null
"
Discopane
should
not
be
in
the
document
when
it
is
not
the
active
view
"
)
;
is
(
apiHandler
.
requestCount
1
"
Discovery
API
should
be
fetched
once
"
)
;
await
closeView
(
win
)
;
}
)
;
add_task
(
async
function
discopane_cache_api_responses
(
)
{
const
INVALID_RESPONSE_BODY
=
{
"
This
is
some
"
:
invalid
}
JSON
;
let
apiHandler
=
new
DiscoveryAPIHandler
(
INVALID_RESPONSE_BODY
)
;
let
expectedErrMsg
;
try
{
JSON
.
parse
(
INVALID_RESPONSE_BODY
)
;
ok
(
false
"
JSON
.
parse
should
have
thrown
"
)
;
}
catch
(
e
)
{
expectedErrMsg
=
e
.
message
;
}
let
invalidResponseHandledPromise
=
new
Promise
(
resolve
=
>
{
Services
.
console
.
registerListener
(
function
listener
(
msg
)
{
if
(
msg
.
message
.
includes
(
expectedErrMsg
)
)
{
resolve
(
)
;
Services
.
console
.
unregisterListener
(
listener
)
;
}
}
)
;
}
)
;
let
win
=
await
loadInitialView
(
"
discover
"
)
;
await
promiseDiscopaneUpdate
(
win
)
;
info
(
"
Waiting
for
expected
error
"
)
;
await
invalidResponseHandledPromise
;
is
(
apiHandler
.
requestCount
1
"
Discovery
API
should
be
fetched
once
"
)
;
Assert
.
deepEqual
(
getVisibleActions
(
win
.
document
)
.
map
(
getActionName
)
[
"
open
-
amo
"
]
"
The
AMO
button
should
be
visible
even
when
the
response
was
invalid
"
)
;
apiHandler
.
setResponseText
(
{
"
results
"
:
[
]
}
)
;
await
switchToNonDiscoView
(
win
)
;
await
switchToDiscoView
(
win
)
;
is
(
apiHandler
.
requestCount
2
"
Should
fetch
new
data
because
an
invalid
response
should
not
be
cached
"
)
;
await
switchToNonDiscoView
(
win
)
;
await
switchToDiscoView
(
win
)
;
await
closeView
(
win
)
;
is
(
apiHandler
.
requestCount
2
"
The
previous
response
was
valid
and
should
have
been
reused
"
)
;
let
anotherWin
=
await
loadInitialView
(
"
discover
"
)
;
await
promiseDiscopaneUpdate
(
anotherWin
)
;
await
closeView
(
anotherWin
)
;
is
(
apiHandler
.
requestCount
3
"
discovery
API
should
be
requested
again
"
)
;
}
)
;
add_task
(
async
function
discopane_no_cookies
(
)
{
let
requestPromise
=
new
Promise
(
resolve
=
>
{
amoServer
.
registerPathHandler
(
"
/
discoapi
"
resolve
)
;
}
)
;
Services
.
cookies
.
add
(
AMO_TEST_HOST
"
/
"
"
name
"
"
value
"
false
false
false
Date
.
now
(
)
/
1000
+
600
{
}
Ci
.
nsICookie
.
SAMESITE_NONE
Ci
.
nsICookie
.
SCHEME_HTTP
)
;
let
win
=
await
loadInitialView
(
"
discover
"
)
;
let
request
=
await
requestPromise
;
ok
(
!
request
.
hasHeader
(
"
Cookie
"
)
"
discovery
API
should
not
receive
cookies
"
)
;
await
closeView
(
win
)
;
}
)
;
add_task
(
async
function
discopane_interaction_telemetry
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
extensions
.
getAddons
.
link
.
url
"
http
:
/
/
{
AMO_TEST_HOST
}
/
dummy
]
]
}
)
;
const
DUMMY_EXTENSION_ID
=
"
dummy
extensionid
"
;
const
apiResponse
=
{
results
:
[
{
addon
:
{
guid
:
DUMMY_EXTENSION_ID
type
:
"
extension
"
authors
:
[
{
name
:
"
Some
author
"
}
]
url
:
http
:
/
/
{
AMO_TEST_HOST
}
/
dummy
icon_url
:
http
:
/
/
{
AMO_TEST_HOST
}
/
png
}
}
]
}
;
let
apiHandler
=
new
DiscoveryAPIHandler
(
JSON
.
stringify
(
apiResponse
)
)
;
let
expectedAmoUrlFor
=
where
=
>
{
return
http
:
/
/
{
AMO_TEST_HOST
}
/
dummy
?
utm_source
=
firefox
-
browser
&
utm_medium
=
firefox
-
browser
&
utm_content
=
{
where
}
;
}
;
let
testClickInDiscoCard
=
async
(
selector
utmContentParam
)
=
>
{
let
tabbrowser
=
win
.
windowRoot
.
ownerGlobal
.
gBrowser
;
let
tabPromise
=
BrowserTestUtils
.
waitForNewTab
(
tabbrowser
)
;
getDiscoveryElement
(
win
)
.
querySelector
(
selector
)
.
click
(
)
;
let
tab
=
await
tabPromise
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
expectedAmoUrlFor
(
utmContentParam
)
"
Expected
URL
of
new
tab
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
;
let
win
=
await
loadInitialView
(
"
discover
"
)
;
await
promiseDiscopaneUpdate
(
win
)
;
is
(
await
waitForAllImagesLoaded
(
win
)
1
"
One
recommendation
in
results
"
)
;
Services
.
telemetry
.
clearEvents
(
)
;
await
testClickInDiscoCard
(
"
[
action
=
'
open
-
amo
'
]
"
"
find
-
more
-
link
-
bottom
"
)
;
await
testClickInDiscoCard
(
"
.
disco
-
addon
-
author
a
"
"
discopane
-
entry
-
link
"
)
;
assertAboutAddonsTelemetryEvents
(
[
[
"
addonsManager
"
"
link
"
"
aboutAddons
"
"
discomore
"
{
view
:
"
discover
"
}
]
[
"
addonsManager
"
"
link
"
"
aboutAddons
"
"
discohome
"
{
view
:
"
discover
"
}
]
]
)
;
is
(
apiHandler
.
requestCount
1
"
Discovery
API
should
be
fetched
once
"
)
;
await
closeView
(
win
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
csp_img_src
(
)
{
const
RED_DATA_IMAGE
=
"
data
:
image
/
png
;
base64
iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAA
"
+
"
AHElEQVQI12P4
/
/
8
/
w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg
=
=
"
;
const
DUMMY_EXTENSION_ID
=
"
dummy
-
csp
extensionid
"
;
const
apiResponse
=
{
results
:
[
{
addon
:
{
guid
:
DUMMY_EXTENSION_ID
type
:
"
extension
"
authors
:
[
{
name
:
"
Some
CSP
author
"
}
]
url
:
http
:
/
/
{
AMO_TEST_HOST
}
/
dummy
icon_url
:
RED_DATA_IMAGE
}
}
]
}
;
let
apiHandler
=
new
DiscoveryAPIHandler
(
JSON
.
stringify
(
apiResponse
)
)
;
apiHandler
.
blockNextResponses
(
)
;
let
win
=
await
loadInitialView
(
"
discover
"
)
;
let
cspPromise
=
new
Promise
(
resolve
=
>
{
win
.
addEventListener
(
"
securitypolicyviolation
"
e
=
>
{
is
(
e
.
blockedURI
"
data
"
"
CSP
:
blocked
URI
"
)
;
is
(
e
.
violatedDirective
"
img
-
src
"
"
CSP
:
violated
directive
"
)
;
resolve
(
)
;
}
)
;
}
)
;
apiHandler
.
unblockResponses
(
)
;
await
cspPromise
;
await
closeView
(
win
)
;
}
)
;
add_task
(
async
function
checkDiscopaneNotice
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
discovery
.
enabled
"
true
]
[
"
datareporting
.
healthreport
.
uploadEnabled
"
true
]
[
"
extensions
.
htmlaboutaddons
.
recommendations
.
enabled
"
true
]
[
"
extensions
.
recommendations
.
hideNotice
"
false
]
]
}
)
;
let
win
=
await
loadInitialView
(
"
extension
"
)
;
let
messageBar
=
win
.
document
.
querySelector
(
"
message
-
bar
.
discopane
-
notice
"
)
;
ok
(
messageBar
"
Recommended
notice
should
exist
in
extensions
view
"
)
;
await
switchToDiscoView
(
win
)
;
messageBar
=
win
.
document
.
querySelector
(
"
message
-
bar
.
discopane
-
notice
"
)
;
ok
(
messageBar
"
Recommended
notice
should
exist
in
disco
view
"
)
;
messageBar
.
closeButton
.
click
(
)
;
messageBar
=
win
.
document
.
querySelector
(
"
message
-
bar
.
discopane
-
notice
"
)
;
ok
(
!
messageBar
"
Recommended
notice
should
not
exist
in
disco
view
"
)
;
await
switchToNonDiscoView
(
win
)
;
messageBar
=
win
.
document
.
querySelector
(
"
message
-
bar
.
discopane
-
notice
"
)
;
ok
(
!
messageBar
"
Recommended
notice
should
not
exist
in
extensions
view
"
)
;
await
closeView
(
win
)
;
}
)
;
