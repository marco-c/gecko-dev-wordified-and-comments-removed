registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
extensions
.
webapi
.
testing
"
)
;
}
)
;
function
check_frame_availability
(
browser
)
{
return
check_availability
(
browser
.
browsingContext
.
getChildren
(
)
[
0
]
)
;
}
function
check_availability
(
browser
)
{
return
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
return
content
.
document
.
getElementById
(
"
result
"
)
.
textContent
=
=
"
true
"
;
}
)
;
}
add_task
(
async
function
test_not_available
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
SECURE_TESTROOT
}
webapi_checkavailable
.
html
async
function
test_not_available
(
browser
)
{
let
available
=
await
check_availability
(
browser
)
;
ok
(
!
available
"
API
should
not
be
available
.
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_available
(
)
{
Services
.
prefs
.
setBoolPref
(
"
extensions
.
webapi
.
testing
"
true
)
;
await
BrowserTestUtils
.
withNewTab
(
{
SECURE_TESTROOT
}
webapi_checkavailable
.
html
async
function
test_not_available
(
browser
)
{
let
available
=
await
check_availability
(
browser
)
;
ok
(
available
"
API
should
be
available
.
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_bad_domain
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
SECURE_TESTROOT2
}
webapi_checkavailable
.
html
async
function
test_not_available
(
browser
)
{
let
available
=
await
check_availability
(
browser
)
;
ok
(
!
available
"
API
should
not
be
available
.
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_not_available_http
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
TESTROOT
}
webapi_checkavailable
.
html
async
function
test_not_available
(
browser
)
{
let
available
=
await
check_availability
(
browser
)
;
ok
(
!
available
"
API
should
not
be
available
.
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_available_framed
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
SECURE_TESTROOT
}
webapi_checkframed
.
html
async
function
test_available
(
browser
)
{
let
available
=
await
check_frame_availability
(
browser
)
;
ok
(
available
"
API
should
be
available
.
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_not_available_http_framed
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
TESTROOT
}
webapi_checkframed
.
html
async
function
test_not_available
(
browser
)
{
let
available
=
await
check_frame_availability
(
browser
)
;
ok
(
!
available
"
API
should
not
be
available
.
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_not_available_framed
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
SECURE_TESTROOT2
}
webapi_checkframed
.
html
async
function
test_not_available
(
browser
)
{
let
available
=
await
check_frame_availability
(
browser
)
;
ok
(
!
available
"
API
should
not
be
available
.
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_navigated_window
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
SECURE_TESTROOT2
}
webapi_checknavigatedwindow
.
html
async
function
test_available
(
browser
)
{
let
tabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
await
content
.
wrappedJSObject
.
openWindow
(
)
;
}
)
;
let
tab
=
await
tabPromise
;
let
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
getBrowserForTab
(
tab
)
)
;
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
content
.
wrappedJSObject
.
navigate
(
)
;
}
)
;
await
loadPromise
;
let
available
=
await
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
return
content
.
wrappedJSObject
.
check
(
)
;
}
)
;
ok
(
!
available
"
API
should
not
be
available
.
"
)
;
gBrowser
.
removeTab
(
tab
)
;
}
)
;
}
)
;
add_task
(
async
function
test_chrome_frame
(
)
{
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
security
.
allow_unsafe_parent_loads
"
true
]
]
}
)
;
await
BrowserTestUtils
.
withNewTab
(
{
CHROMEROOT
}
webapi_checkchromeframe
.
xhtml
async
function
test_available
(
browser
)
{
let
available
=
await
check_frame_availability
(
browser
)
;
ok
(
available
"
API
should
be
available
.
"
)
;
}
)
;
}
)
;
