const
TESTPAGE
=
{
SECURE_TESTROOT
}
webapi_checkavailable
.
html
;
const
XPI_URL
=
{
SECURE_TESTROOT
}
addons
/
browser_webapi_install
.
xpi
;
const
ID
=
"
webapi_install
tests
.
mozilla
.
org
"
;
const
XPI_LEN
=
4782
;
function
waitForClear
(
)
{
const
MSG
=
"
WebAPICleanup
"
;
return
new
Promise
(
resolve
=
>
{
let
listener
=
{
receiveMessage
:
function
(
msg
)
{
if
(
msg
.
name
=
=
MSG
)
{
Services
.
ppmm
.
removeMessageListener
(
MSG
listener
)
;
resolve
(
)
;
}
}
}
;
Services
.
ppmm
.
addMessageListener
(
MSG
listener
)
;
}
)
;
}
add_task
(
function
*
setup
(
)
{
yield
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
extensions
.
webapi
.
testing
"
true
]
[
"
extensions
.
install
.
requireBuiltInCerts
"
false
]
]
}
)
;
info
(
"
added
preferences
"
)
;
}
)
;
function
*
testInstall
(
browser
url
steps
description
)
{
let
success
=
yield
ContentTask
.
spawn
(
browser
{
url
steps
}
function
*
(
opts
)
{
let
{
url
steps
}
=
opts
;
let
install
=
yield
content
.
navigator
.
mozAddonManager
.
createInstall
(
{
url
}
)
;
if
(
!
install
)
{
yield
Promise
.
reject
(
"
createInstall
(
)
did
not
return
an
install
object
"
)
;
}
if
(
install
.
state
!
=
"
STATE_AVAILABLE
"
)
{
yield
Promise
.
reject
(
"
new
install
should
be
in
STATE_AVAILABLE
"
)
;
}
if
(
install
.
error
!
=
null
)
{
yield
Promise
.
reject
(
"
new
install
should
have
null
error
"
)
;
}
const
events
=
[
"
onDownloadStarted
"
"
onDownloadProgress
"
"
onDownloadEnded
"
"
onDownloadCancelled
"
"
onDownloadFailed
"
"
onInstallStarted
"
"
onInstallEnded
"
"
onInstallCancelled
"
"
onInstallFailed
"
]
;
let
eventWaiter
=
null
;
let
receivedEvents
=
[
]
;
events
.
forEach
(
event
=
>
{
install
.
addEventListener
(
event
e
=
>
{
receivedEvents
.
push
(
{
event
state
:
install
.
state
error
:
install
.
error
progress
:
install
.
progress
maxProgress
:
install
.
maxProgress
}
)
;
if
(
eventWaiter
)
{
eventWaiter
(
)
;
}
}
)
;
}
)
;
function
expectEvent
(
event
props
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
function
check
(
)
{
let
received
=
receivedEvents
.
shift
(
)
;
if
(
received
.
event
!
=
event
)
{
let
err
=
new
Error
(
expected
{
event
}
but
got
{
received
.
event
}
)
;
reject
(
err
)
;
}
if
(
props
)
{
for
(
let
key
of
Object
.
keys
(
props
)
)
{
if
(
received
[
key
]
!
=
props
[
key
]
)
{
throw
new
Error
(
AddonInstall
property
{
key
}
was
{
received
[
key
]
}
but
expected
{
props
[
key
]
}
)
;
}
}
}
resolve
(
)
;
}
if
(
receivedEvents
.
length
>
0
)
{
check
(
)
;
}
else
{
eventWaiter
=
(
)
=
>
{
eventWaiter
=
null
;
check
(
)
;
}
}
}
)
;
}
while
(
steps
.
length
>
0
)
{
let
nextStep
=
steps
.
shift
(
)
;
if
(
nextStep
.
action
)
{
if
(
nextStep
.
action
=
=
"
install
"
)
{
yield
install
.
install
(
)
;
}
else
if
(
nextStep
.
action
=
=
"
cancel
"
)
{
yield
install
.
cancel
(
)
;
}
else
{
throw
new
Error
(
unknown
action
{
nextStep
.
action
}
)
;
}
}
else
{
yield
expectEvent
(
nextStep
.
event
nextStep
.
props
)
;
}
}
return
true
;
}
)
;
is
(
success
true
description
)
;
}
function
makeInstallTest
(
task
)
{
return
function
*
(
)
{
let
clearPromise
=
waitForClear
(
)
;
yield
BrowserTestUtils
.
withNewTab
(
TESTPAGE
task
)
;
yield
clearPromise
;
is
(
AddonManager
.
webAPI
.
installs
.
size
0
"
AddonInstall
was
cleaned
up
"
)
;
}
;
}
add_task
(
makeInstallTest
(
function
*
(
browser
)
{
let
steps
=
[
{
action
:
"
install
"
}
{
event
:
"
onDownloadStarted
"
props
:
{
state
:
"
STATE_DOWNLOADING
"
}
}
{
event
:
"
onDownloadProgress
"
props
:
{
maxProgress
:
XPI_LEN
}
}
{
event
:
"
onDownloadEnded
"
props
:
{
state
:
"
STATE_DOWNLOADED
"
progress
:
XPI_LEN
maxProgress
:
XPI_LEN
}
}
{
event
:
"
onInstallStarted
"
props
:
{
state
:
"
STATE_INSTALLING
"
}
}
{
event
:
"
onInstallEnded
"
props
:
{
state
:
"
STATE_INSTALLED
"
}
}
]
;
yield
testInstall
(
browser
XPI_URL
steps
"
a
basic
install
works
"
)
;
let
version
=
Services
.
prefs
.
getIntPref
(
"
webapitest
.
active_version
"
)
;
is
(
version
1
"
the
install
really
did
work
"
)
;
ok
(
AddonManager
.
webAPI
.
installs
.
size
>
0
"
webAPI
is
tracking
the
AddonInstall
"
)
;
let
addons
=
yield
promiseAddonsByIDs
(
[
ID
]
)
;
isnot
(
addons
[
0
]
null
"
Found
the
addon
"
)
;
yield
addons
[
0
]
.
uninstall
(
)
;
addons
=
yield
promiseAddonsByIDs
(
[
ID
]
)
;
is
(
addons
[
0
]
null
"
Addon
was
uninstalled
"
)
;
}
)
)
;
add_task
(
makeInstallTest
(
function
*
(
browser
)
{
let
steps
=
[
{
action
:
"
cancel
"
}
{
event
:
"
onDownloadCancelled
"
props
:
{
state
:
"
STATE_CANCELLED
"
error
:
null
}
}
]
;
yield
testInstall
(
browser
XPI_URL
steps
"
canceling
an
install
works
"
)
;
let
addons
=
yield
promiseAddonsByIDs
(
[
ID
]
)
;
is
(
addons
[
0
]
null
"
The
addon
was
not
installed
"
)
;
ok
(
AddonManager
.
webAPI
.
installs
.
size
>
0
"
webAPI
is
tracking
the
AddonInstall
"
)
;
}
)
)
;
add_task
(
makeInstallTest
(
function
*
(
browser
)
{
let
steps
=
[
{
action
:
"
install
"
}
{
event
:
"
onDownloadStarted
"
props
:
{
state
:
"
STATE_DOWNLOADING
"
}
}
{
event
:
"
onDownloadProgress
"
}
{
event
:
"
onDownloadFailed
"
props
:
{
state
:
"
STATE_DOWNLOAD_FAILED
"
error
:
"
ERROR_NETWORK_FAILURE
"
}
}
]
;
yield
testInstall
(
browser
XPI_URL
+
"
bogus
"
steps
"
install
of
a
bad
url
fails
"
)
;
let
addons
=
yield
promiseAddonsByIDs
(
[
ID
]
)
;
is
(
addons
[
0
]
null
"
The
addon
was
not
installed
"
)
;
ok
(
AddonManager
.
webAPI
.
installs
.
size
>
0
"
webAPI
is
tracking
the
AddonInstall
"
)
;
}
)
)
;
add_task
(
function
*
test_permissions
(
)
{
function
testBadUrl
(
url
pattern
successMessage
)
{
return
BrowserTestUtils
.
withNewTab
(
TESTPAGE
function
*
(
browser
)
{
let
result
=
yield
ContentTask
.
spawn
(
browser
{
url
pattern
}
function
(
opts
)
{
return
new
Promise
(
resolve
=
>
{
content
.
navigator
.
mozAddonManager
.
createInstall
(
{
url
:
opts
.
url
}
)
.
then
(
(
)
=
>
{
resolve
(
{
success
:
false
message
:
"
createInstall
should
not
have
succeeded
"
}
)
;
}
err
=
>
{
if
(
err
.
message
.
match
(
new
RegExp
(
opts
.
pattern
)
)
)
{
resolve
(
{
success
:
true
}
)
;
}
resolve
(
{
success
:
false
message
:
Wrong
error
message
:
{
err
.
message
}
}
)
;
}
)
;
}
)
;
}
)
;
is
(
result
.
success
true
result
.
message
|
|
successMessage
)
;
}
)
;
}
yield
testBadUrl
(
"
i
am
not
a
url
"
"
NS_ERROR_MALFORMED_URI
"
"
Installing
from
an
unparseable
URL
fails
"
)
;
yield
testBadUrl
(
"
https
:
/
/
addons
.
not
-
really
-
mozilla
.
org
/
impostor
.
xpi
"
"
not
permitted
"
"
Installing
from
non
-
approved
URL
fails
"
)
;
}
)
;
