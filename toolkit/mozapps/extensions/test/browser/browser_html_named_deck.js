"
use
strict
"
;
const
DEFAULT_SECTION_NAMES
=
[
"
one
"
"
two
"
"
three
"
]
;
function
makeButton
(
{
doc
name
deckId
}
)
{
let
button
=
doc
.
createElement
(
"
named
-
deck
-
button
"
)
;
button
.
setAttribute
(
"
name
"
name
)
;
button
.
deckId
=
deckId
;
button
.
textContent
=
name
.
toUpperCase
(
)
;
return
button
;
}
function
makeSection
(
{
doc
name
}
)
{
let
view
=
doc
.
createElement
(
"
section
"
)
;
view
.
setAttribute
(
"
name
"
name
)
;
view
.
textContent
=
name
+
name
;
return
view
;
}
function
addSection
(
{
name
deck
buttons
}
)
{
let
doc
=
deck
.
ownerDocument
;
let
button
=
makeButton
(
{
doc
name
deckId
:
deck
.
id
}
)
;
buttons
.
appendChild
(
button
)
;
let
view
=
makeSection
(
{
doc
name
}
)
;
deck
.
appendChild
(
view
)
;
return
{
button
view
}
;
}
async
function
runTests
(
{
deck
buttons
}
)
{
const
selectedSlot
=
deck
.
shadowRoot
.
querySelector
(
'
slot
[
name
=
"
selected
"
]
'
)
;
const
getButtonByName
=
name
=
>
buttons
.
querySelector
(
[
name
=
"
{
name
}
"
]
)
;
function
checkState
(
name
count
empty
=
false
)
{
is
(
deck
.
selectedViewName
name
"
The
right
view
is
selected
"
)
;
let
slottedEls
=
selectedSlot
.
assignedElements
(
)
;
if
(
empty
)
{
is
(
slottedEls
.
length
0
"
The
deck
is
empty
"
)
;
}
else
{
is
(
slottedEls
.
length
1
"
There
'
s
one
visible
view
"
)
;
is
(
slottedEls
[
0
]
.
getAttribute
(
"
name
"
)
name
"
The
correct
view
is
in
the
slot
"
)
;
}
let
sections
=
deck
.
querySelectorAll
(
"
section
"
)
;
is
(
sections
.
length
count
"
There
are
the
right
number
of
sections
"
)
;
for
(
let
section
of
sections
)
{
let
sectionName
=
section
.
getAttribute
(
"
name
"
)
;
if
(
sectionName
=
=
name
)
{
is
(
section
.
slot
"
selected
"
{
sectionName
}
is
visible
)
;
}
else
{
is
(
section
.
slot
"
"
{
sectionName
}
is
hidden
)
;
}
}
is
(
buttons
.
children
.
length
count
"
There
are
the
right
number
of
buttons
"
)
;
for
(
let
button
of
buttons
.
children
)
{
let
buttonName
=
button
.
getAttribute
(
"
name
"
)
;
let
selected
=
buttonName
=
=
name
;
is
(
button
.
hasAttribute
(
"
selected
"
)
selected
{
buttonName
}
is
{
selected
?
"
selected
"
:
"
not
selected
"
}
)
;
}
}
checkState
(
"
one
"
3
)
;
info
(
"
Switch
to
section
three
"
)
;
getButtonByName
(
"
three
"
)
.
click
(
)
;
checkState
(
"
three
"
3
)
;
info
(
"
Add
section
last
"
)
;
let
last
=
addSection
(
{
name
:
"
last
"
deck
buttons
}
)
;
checkState
(
"
three
"
4
)
;
last
.
button
.
click
(
)
;
info
(
"
Switch
to
section
last
"
)
;
checkState
(
"
last
"
4
)
;
info
(
"
Switch
view
with
selectedViewName
"
)
;
let
shown
=
BrowserTestUtils
.
waitForEvent
(
deck
"
view
-
changed
"
)
;
deck
.
selectedViewName
=
"
two
"
;
await
shown
;
checkState
(
"
two
"
4
)
;
info
(
"
Switch
back
to
the
last
view
to
test
removing
selected
view
"
)
;
shown
=
BrowserTestUtils
.
waitForEvent
(
deck
"
view
-
changed
"
)
;
deck
.
setAttribute
(
"
selected
-
view
"
"
last
"
)
;
await
shown
;
checkState
(
"
last
"
4
)
;
info
(
"
Remove
section
last
"
)
;
last
.
button
.
remove
(
)
;
last
.
view
.
remove
(
)
;
info
(
"
Should
not
have
any
selected
views
"
)
;
checkState
(
"
last
"
3
true
)
;
info
(
"
Set
view
to
a
missing
name
"
)
;
let
hidden
=
BrowserTestUtils
.
waitForEvent
(
deck
"
view
-
changed
"
)
;
deck
.
selectedViewName
=
"
missing
"
;
await
hidden
;
checkState
(
"
missing
"
3
true
)
;
info
(
"
Add
the
missing
view
it
should
be
shown
"
)
;
shown
=
BrowserTestUtils
.
waitForEvent
(
selectedSlot
"
slotchange
"
)
;
let
viewChangedEvent
=
false
;
let
viewChangedFn
=
(
)
=
>
{
viewChangedEvent
=
true
;
}
;
deck
.
addEventListener
(
"
view
-
changed
"
viewChangedFn
)
;
addSection
(
{
name
:
"
missing
"
deck
buttons
}
)
;
await
shown
;
deck
.
removeEventListener
(
"
view
-
changed
"
viewChangedFn
)
;
ok
(
!
viewChangedEvent
"
The
view
-
changed
event
didn
'
t
fire
"
)
;
checkState
(
"
missing
"
4
)
;
}
async
function
setup
(
{
doc
beAsync
first
}
)
{
const
deckId
=
{
first
}
-
first
-
{
beAsync
}
;
const
deck
=
doc
.
createElement
(
"
named
-
deck
"
)
;
deck
.
id
=
deckId
;
for
(
let
name
of
DEFAULT_SECTION_NAMES
)
{
deck
.
appendChild
(
makeSection
(
{
doc
name
}
)
)
;
}
const
buttons
=
doc
.
createElement
(
"
div
"
)
;
for
(
let
name
of
DEFAULT_SECTION_NAMES
)
{
buttons
.
appendChild
(
makeButton
(
{
doc
name
deckId
}
)
)
;
}
let
ordered
;
if
(
first
=
=
"
deck
"
)
{
ordered
=
[
deck
buttons
]
;
}
else
if
(
first
=
=
"
buttons
"
)
{
ordered
=
[
buttons
deck
]
;
}
else
{
throw
new
Error
(
"
Invalid
order
"
)
;
}
doc
.
body
.
appendChild
(
ordered
.
shift
(
)
)
;
if
(
beAsync
)
{
await
new
Promise
(
resolve
=
>
requestAnimationFrame
(
resolve
)
)
;
}
doc
.
body
.
appendChild
(
ordered
.
shift
(
)
)
;
return
{
deck
buttons
}
;
}
add_task
(
async
function
testNamedDeckAndButtons
(
)
{
const
win
=
await
loadInitialView
(
"
extension
"
)
;
const
doc
=
win
.
document
;
dump
(
"
Running
deck
first
tests
synchronously
"
)
;
await
runTests
(
await
setup
(
{
doc
beAsync
:
false
first
:
"
deck
"
}
)
)
;
dump
(
"
Running
deck
first
tests
asynchronously
"
)
;
await
runTests
(
await
setup
(
{
doc
beAsync
:
true
first
:
"
deck
"
}
)
)
;
dump
(
"
Running
buttons
first
tests
synchronously
"
)
;
await
runTests
(
await
setup
(
{
doc
beAsync
:
false
first
:
"
buttons
"
}
)
)
;
dump
(
"
Running
buttons
first
tests
asynchronously
"
)
;
await
runTests
(
await
setup
(
{
doc
beAsync
:
true
first
:
"
buttons
"
}
)
)
;
await
closeView
(
win
)
;
}
)
;
