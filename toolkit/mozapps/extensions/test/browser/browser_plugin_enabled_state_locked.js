const
gIsWindows
=
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
in
Cc
;
const
gIsLinux
=
"
mozilla
.
org
/
gnome
-
gconf
-
service
;
1
"
in
Cc
|
|
"
mozilla
.
org
/
gio
-
service
;
1
"
in
Cc
;
var
gManagerWindow
;
var
gCategoryUtilities
;
var
gPluginElement
;
function
getTestPluginPref
(
)
{
let
prefix
=
"
plugin
.
state
.
"
;
if
(
gIsWindows
)
{
return
{
prefix
}
nptest
;
}
if
(
gIsLinux
)
{
return
{
prefix
}
libnptest
;
}
return
{
prefix
}
test
;
}
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
extensions
.
htmlaboutaddons
.
enabled
"
false
]
]
}
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
unlockPref
(
getTestPluginPref
(
)
)
;
Services
.
prefs
.
clearUserPref
(
getTestPluginPref
(
)
)
;
}
)
;
function
getPlugins
(
)
{
return
AddonManager
.
getAddonsByTypes
(
[
"
plugin
"
]
)
;
}
function
getTestPlugin
(
aPlugins
)
{
let
testPluginId
;
for
(
let
plugin
of
aPlugins
)
{
if
(
plugin
.
name
=
=
"
Test
Plug
-
in
"
)
{
testPluginId
=
plugin
.
id
;
break
;
}
}
Assert
.
ok
(
testPluginId
"
Test
Plug
-
in
should
exist
"
)
;
let
pluginElement
=
get_addon_element
(
gManagerWindow
testPluginId
)
;
pluginElement
.
parentNode
.
ensureElementIsVisible
(
pluginElement
)
;
return
pluginElement
;
}
function
checkStateMenu
(
locked
)
{
Assert
.
equal
(
Services
.
prefs
.
prefIsLocked
(
getTestPluginPref
(
)
)
locked
"
Preference
lock
state
should
be
correct
.
"
)
;
let
menuList
=
gManagerWindow
.
document
.
getAnonymousElementByAttribute
(
gPluginElement
"
anonid
"
"
state
-
menulist
"
)
;
let
selectedMenuItem
=
menuList
.
querySelector
(
'
.
addon
-
control
[
selected
=
"
true
"
]
'
)
;
is_element_visible
(
menuList
"
State
menu
should
be
visible
.
"
)
;
Assert
.
equal
(
menuList
.
disabled
locked
"
State
menu
should
"
+
(
locked
=
=
=
true
?
"
"
:
"
not
"
)
+
"
be
disabled
.
"
)
;
is_element_visible
(
selectedMenuItem
"
State
menu
'
s
selected
item
should
be
visible
.
"
)
;
}
function
checkStateMenuDetail
(
locked
)
{
Assert
.
equal
(
Services
.
prefs
.
prefIsLocked
(
getTestPluginPref
(
)
)
locked
"
Preference
should
be
"
+
(
locked
=
=
=
true
?
"
"
:
"
un
"
)
+
"
locked
.
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
gPluginElement
{
}
gManagerWindow
)
;
return
new
Promise
(
async
resolve
=
>
{
await
wait_for_view_load
(
gManagerWindow
)
;
let
menuList
=
gManagerWindow
.
document
.
getElementById
(
"
detail
-
state
-
menulist
"
)
;
is_element_visible
(
menuList
"
Details
state
menu
should
be
visible
.
"
)
;
Assert
.
equal
(
menuList
.
disabled
locked
"
Details
state
menu
enabled
state
should
be
correct
.
"
)
;
resolve
(
)
;
}
)
;
}
add_task
(
async
function
initializeState
(
)
{
Services
.
prefs
.
setIntPref
(
getTestPluginPref
(
)
Ci
.
nsIPluginTag
.
STATE_ENABLED
)
;
Services
.
prefs
.
unlockPref
(
getTestPluginPref
(
)
)
;
gManagerWindow
=
await
open_manager
(
)
;
gCategoryUtilities
=
new
CategoryUtilities
(
gManagerWindow
)
;
await
gCategoryUtilities
.
openType
(
"
plugin
"
)
;
let
plugins
=
await
getPlugins
(
)
;
gPluginElement
=
getTestPlugin
(
plugins
)
;
}
)
;
add_task
(
async
function
taskCheckStateMenuIsEnabled
(
)
{
checkStateMenu
(
false
)
;
await
checkStateMenuDetail
(
false
)
;
}
)
;
add_task
(
async
function
reinitializeState
(
)
{
Services
.
prefs
.
lockPref
(
getTestPluginPref
(
)
)
;
await
gCategoryUtilities
.
openType
(
"
plugin
"
)
;
let
plugins
=
await
getPlugins
(
)
;
gPluginElement
=
getTestPlugin
(
plugins
)
;
}
)
;
add_task
(
async
function
taskCheckStateMenuIsDisabled
(
)
{
checkStateMenu
(
true
)
;
await
checkStateMenuDetail
(
true
)
;
}
)
;
add_task
(
async
function
testCleanup
(
)
{
await
close_manager
(
gManagerWindow
)
;
}
)
;
