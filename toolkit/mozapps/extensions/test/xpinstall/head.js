const
RELATIVE_DIR
=
"
toolkit
/
mozapps
/
extensions
/
test
/
xpinstall
/
"
;
const
TESTROOT
=
"
http
:
/
/
example
.
com
/
browser
/
"
+
RELATIVE_DIR
;
const
TESTROOT2
=
"
http
:
/
/
example
.
org
/
browser
/
"
+
RELATIVE_DIR
;
const
XPINSTALL_URL
=
"
chrome
:
/
/
mozapps
/
content
/
xpinstall
/
xpinstallConfirm
.
xul
"
;
const
PROMPT_URL
=
"
chrome
:
/
/
global
/
content
/
commonDialog
.
xul
"
;
const
ADDONS_URL
=
"
chrome
:
/
/
mozapps
/
content
/
extensions
/
extensions
.
xul
"
;
const
PREF_LOGGING_ENABLED
=
"
extensions
.
logging
.
enabled
"
;
const
PREF_INSTALL_REQUIREBUILTINCERTS
=
"
extensions
.
install
.
requireBuiltInCerts
"
;
const
PREF_INSTALL_REQUIRESECUREORIGIN
=
"
extensions
.
install
.
requireSecureOrigin
"
;
const
PREF_CUSTOM_CONFIRMATION_UI
=
"
xpinstall
.
customConfirmationUI
"
;
const
CHROME_NAME
=
"
mochikit
"
;
function
getChromeRoot
(
path
)
{
if
(
path
=
=
=
undefined
)
{
return
"
chrome
:
/
/
"
+
CHROME_NAME
+
"
/
content
/
browser
/
"
+
RELATIVE_DIR
;
}
return
getRootDirectory
(
path
)
;
}
function
extractChromeRoot
(
path
)
{
var
chromeRootPath
=
getChromeRoot
(
path
)
;
var
jar
=
getJar
(
chromeRootPath
)
;
if
(
jar
)
{
var
tmpdir
=
extractJarToTmp
(
jar
)
;
return
"
file
:
/
/
"
+
tmpdir
.
path
+
"
/
"
;
}
return
chromeRootPath
;
}
Services
.
prefs
.
setBoolPref
(
PREF_CUSTOM_CONFIRMATION_UI
false
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
PREF_CUSTOM_CONFIRMATION_UI
)
;
}
)
;
var
Harness
=
{
installDisabledCallback
:
null
installCancelledCallback
:
null
installOriginBlockedCallback
:
null
installBlockedCallback
:
null
authenticationCallback
:
null
installConfirmCallback
:
null
downloadStartedCallback
:
null
downloadProgressCallback
:
null
downloadFailedCallback
:
null
downloadCancelledCallback
:
null
downloadEndedCallback
:
null
installStartedCallback
:
null
installFailedCallback
:
null
installEndedCallback
:
null
installsCompletedCallback
:
null
finalContentEvent
:
null
waitingForEvent
:
false
pendingCount
:
null
installCount
:
null
runningInstalls
:
null
waitingForFinish
:
false
leaveOpen
:
{
}
setup
(
)
{
if
(
!
this
.
waitingForFinish
)
{
waitForExplicitFinish
(
)
;
this
.
waitingForFinish
=
true
;
Services
.
prefs
.
setBoolPref
(
PREF_INSTALL_REQUIRESECUREORIGIN
false
)
;
Services
.
prefs
.
setBoolPref
(
PREF_LOGGING_ENABLED
true
)
;
Services
.
obs
.
addObserver
(
this
"
addon
-
install
-
started
"
)
;
Services
.
obs
.
addObserver
(
this
"
addon
-
install
-
disabled
"
)
;
Services
.
obs
.
addObserver
(
this
"
addon
-
install
-
origin
-
blocked
"
)
;
Services
.
obs
.
addObserver
(
this
"
addon
-
install
-
blocked
"
)
;
Services
.
obs
.
addObserver
(
this
"
addon
-
install
-
failed
"
)
;
Services
.
obs
.
addObserver
(
this
"
addon
-
install
-
complete
"
)
;
AddonManager
.
addInstallListener
(
this
)
;
Services
.
wm
.
addListener
(
this
)
;
window
.
addEventListener
(
"
popupshown
"
this
)
;
var
self
=
this
;
registerCleanupFunction
(
async
function
(
)
{
Services
.
prefs
.
clearUserPref
(
PREF_LOGGING_ENABLED
)
;
Services
.
prefs
.
clearUserPref
(
PREF_INSTALL_REQUIRESECUREORIGIN
)
;
Services
.
obs
.
removeObserver
(
self
"
addon
-
install
-
started
"
)
;
Services
.
obs
.
removeObserver
(
self
"
addon
-
install
-
disabled
"
)
;
Services
.
obs
.
removeObserver
(
self
"
addon
-
install
-
origin
-
blocked
"
)
;
Services
.
obs
.
removeObserver
(
self
"
addon
-
install
-
blocked
"
)
;
Services
.
obs
.
removeObserver
(
self
"
addon
-
install
-
failed
"
)
;
Services
.
obs
.
removeObserver
(
self
"
addon
-
install
-
complete
"
)
;
AddonManager
.
removeInstallListener
(
self
)
;
Services
.
wm
.
removeListener
(
self
)
;
window
.
removeEventListener
(
"
popupshown
"
self
)
;
let
aInstalls
=
await
AddonManager
.
getAllInstalls
(
)
;
is
(
aInstalls
.
length
0
"
Should
be
no
active
installs
at
the
end
of
the
test
"
)
;
aInstalls
.
forEach
(
function
(
aInstall
)
{
info
(
"
Install
for
"
+
aInstall
.
sourceURI
+
"
is
in
state
"
+
aInstall
.
state
)
;
aInstall
.
cancel
(
)
;
}
)
;
}
)
;
}
this
.
installCount
=
0
;
this
.
pendingCount
=
0
;
this
.
runningInstalls
=
[
]
;
}
finish
(
)
{
finish
(
)
;
}
endTest
(
)
{
let
callback
=
this
.
installsCompletedCallback
;
let
count
=
this
.
installCount
;
is
(
this
.
runningInstalls
.
length
0
"
Should
be
no
running
installs
left
"
)
;
this
.
runningInstalls
.
forEach
(
function
(
aInstall
)
{
info
(
"
Install
for
"
+
aInstall
.
sourceURI
+
"
is
in
state
"
+
aInstall
.
state
)
;
}
)
;
this
.
installOriginBlockedCallback
=
null
;
this
.
installBlockedCallback
=
null
;
this
.
authenticationCallback
=
null
;
this
.
installConfirmCallback
=
null
;
this
.
downloadStartedCallback
=
null
;
this
.
downloadProgressCallback
=
null
;
this
.
downloadCancelledCallback
=
null
;
this
.
downloadFailedCallback
=
null
;
this
.
downloadEndedCallback
=
null
;
this
.
installStartedCallback
=
null
;
this
.
installFailedCallback
=
null
;
this
.
installEndedCallback
=
null
;
this
.
installsCompletedCallback
=
null
;
this
.
runningInstalls
=
null
;
if
(
callback
)
executeSoon
(
(
)
=
>
callback
(
count
)
)
;
}
windowReady
(
window
)
{
if
(
window
.
document
.
location
.
href
=
=
XPINSTALL_URL
)
{
if
(
this
.
installBlockedCallback
)
ok
(
false
"
Should
have
been
blocked
by
the
whitelist
"
)
;
this
.
pendingCount
=
window
.
document
.
getElementById
(
"
itemList
"
)
.
childNodes
.
length
;
let
result
=
true
;
if
(
this
.
installConfirmCallback
)
{
result
=
this
.
installConfirmCallback
(
window
)
;
if
(
result
=
=
=
this
.
leaveOpen
)
return
;
}
if
(
!
result
)
{
window
.
document
.
documentElement
.
cancelDialog
(
)
;
}
else
{
var
button
=
window
.
document
.
documentElement
.
getButton
(
"
accept
"
)
;
button
.
disabled
=
false
;
window
.
document
.
documentElement
.
acceptDialog
(
)
;
}
}
else
if
(
window
.
document
.
location
.
href
=
=
PROMPT_URL
)
{
var
promptType
=
window
.
args
.
promptType
;
switch
(
promptType
)
{
case
"
alert
"
:
case
"
alertCheck
"
:
case
"
confirmCheck
"
:
case
"
confirm
"
:
case
"
confirmEx
"
:
window
.
document
.
documentElement
.
acceptDialog
(
)
;
break
;
case
"
promptUserAndPass
"
:
if
(
this
.
authenticationCallback
)
{
var
auth
=
this
.
authenticationCallback
(
)
;
if
(
auth
&
&
auth
.
length
=
=
2
)
{
window
.
document
.
getElementById
(
"
loginTextbox
"
)
.
value
=
auth
[
0
]
;
window
.
document
.
getElementById
(
"
password1Textbox
"
)
.
value
=
auth
[
1
]
;
window
.
document
.
documentElement
.
acceptDialog
(
)
;
}
else
{
window
.
document
.
documentElement
.
cancelDialog
(
)
;
}
}
else
{
window
.
document
.
documentElement
.
cancelDialog
(
)
;
}
break
;
default
:
ok
(
false
"
prompt
type
"
+
promptType
+
"
not
handled
in
test
.
"
)
;
break
;
}
}
}
popupReady
(
panel
)
{
if
(
this
.
installBlockedCallback
)
ok
(
false
"
Should
have
been
blocked
by
the
whitelist
"
)
;
this
.
pendingCount
+
+
;
let
result
=
true
;
if
(
this
.
installConfirmCallback
)
{
result
=
this
.
installConfirmCallback
(
panel
)
;
if
(
result
=
=
=
this
.
leaveOpen
)
return
;
}
if
(
!
result
)
{
panel
.
secondaryButton
.
click
(
)
;
}
else
{
panel
.
button
.
click
(
)
;
}
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
=
"
popupshown
"
)
{
if
(
event
.
target
.
firstChild
)
{
let
popupId
=
event
.
target
.
getAttribute
(
"
popupid
"
)
;
if
(
popupId
=
=
=
"
addon
-
webext
-
permissions
"
)
{
this
.
popupReady
(
event
.
target
.
firstChild
)
;
}
else
if
(
popupId
=
=
=
"
addon
-
installed
"
|
|
popupId
=
=
=
"
addon
-
install
-
failed
"
)
{
event
.
target
.
firstChild
.
button
.
click
(
)
;
}
}
}
}
installDisabled
(
installInfo
)
{
ok
(
!
!
this
.
installDisabledCallback
"
Installation
shouldn
'
t
have
been
disabled
"
)
;
if
(
this
.
installDisabledCallback
)
this
.
installDisabledCallback
(
installInfo
)
;
this
.
expectingCancelled
=
true
;
this
.
expectingCancelled
=
false
;
this
.
endTest
(
)
;
}
installCancelled
(
installInfo
)
{
if
(
this
.
expectingCancelled
)
return
;
ok
(
!
!
this
.
installCancelledCallback
"
Installation
shouldn
'
t
have
been
cancelled
"
)
;
if
(
this
.
installCancelledCallback
)
this
.
installCancelledCallback
(
installInfo
)
;
this
.
endTest
(
)
;
}
installOriginBlocked
(
installInfo
)
{
ok
(
!
!
this
.
installOriginBlockedCallback
"
Shouldn
'
t
have
been
blocked
"
)
;
if
(
this
.
installOriginBlockedCallback
)
this
.
installOriginBlockedCallback
(
installInfo
)
;
this
.
endTest
(
)
;
}
installBlocked
(
installInfo
)
{
ok
(
!
!
this
.
installBlockedCallback
"
Shouldn
'
t
have
been
blocked
by
the
whitelist
"
)
;
if
(
this
.
installBlockedCallback
&
&
this
.
installBlockedCallback
(
installInfo
)
)
{
this
.
installBlockedCallback
=
null
;
installInfo
.
install
(
)
;
}
else
{
this
.
expectingCancelled
=
true
;
installInfo
.
installs
.
forEach
(
function
(
install
)
{
install
.
cancel
(
)
;
}
)
;
this
.
expectingCancelled
=
false
;
this
.
endTest
(
)
;
}
}
onOpenWindow
(
xulWin
)
{
var
domwindow
=
xulWin
.
docShell
.
domWindow
;
var
self
=
this
;
waitForFocus
(
function
(
)
{
self
.
windowReady
(
domwindow
)
;
}
domwindow
)
;
}
onCloseWindow
(
window
)
{
}
onNewInstall
(
install
)
{
this
.
runningInstalls
.
push
(
install
)
;
if
(
this
.
finalContentEvent
&
&
!
this
.
waitingForEvent
)
{
this
.
waitingForEvent
=
true
;
info
(
"
Waiting
for
"
+
this
.
finalContentEvent
)
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
mm
.
loadFrameScript
(
data
:
content
.
addEventListener
(
"
{
this
.
finalContentEvent
}
"
(
)
=
>
{
sendAsyncMessage
(
"
Test
:
GotNewInstallEvent
"
)
;
}
)
;
false
)
;
let
listener
=
(
)
=
>
{
info
(
"
Saw
"
+
this
.
finalContentEvent
)
;
mm
.
removeMessageListener
(
"
Test
:
GotNewInstallEvent
"
listener
)
;
this
.
waitingForEvent
=
false
;
if
(
this
.
pendingCount
=
=
0
)
this
.
endTest
(
)
;
}
;
mm
.
addMessageListener
(
"
Test
:
GotNewInstallEvent
"
listener
)
;
}
}
onDownloadStarted
(
install
)
{
this
.
pendingCount
+
+
;
if
(
this
.
downloadStartedCallback
)
this
.
downloadStartedCallback
(
install
)
;
}
onDownloadProgress
(
install
)
{
if
(
this
.
downloadProgressCallback
)
this
.
downloadProgressCallback
(
install
)
;
}
onDownloadEnded
(
install
)
{
if
(
this
.
downloadEndedCallback
)
this
.
downloadEndedCallback
(
install
)
;
}
onDownloadCancelled
(
install
)
{
isnot
(
this
.
runningInstalls
.
indexOf
(
install
)
-
1
"
Should
only
see
cancelations
for
started
installs
"
)
;
this
.
runningInstalls
.
splice
(
this
.
runningInstalls
.
indexOf
(
install
)
1
)
;
if
(
this
.
downloadCancelledCallback
)
this
.
downloadCancelledCallback
(
install
)
;
this
.
checkTestEnded
(
)
;
}
onDownloadFailed
(
install
)
{
if
(
this
.
downloadFailedCallback
)
this
.
downloadFailedCallback
(
install
)
;
this
.
checkTestEnded
(
)
;
}
onInstallStarted
(
install
)
{
if
(
this
.
installStartedCallback
)
this
.
installStartedCallback
(
install
)
;
}
onInstallEnded
(
install
addon
)
{
this
.
installCount
+
+
;
if
(
this
.
installEndedCallback
)
this
.
installEndedCallback
(
install
addon
)
;
this
.
checkTestEnded
(
)
;
}
onInstallFailed
(
install
)
{
if
(
this
.
installFailedCallback
)
this
.
installFailedCallback
(
install
)
;
this
.
checkTestEnded
(
)
;
}
onInstallCancelled
(
install
)
{
let
idx
=
this
.
runningInstalls
.
indexOf
(
install
)
;
if
(
idx
!
=
-
1
)
{
this
.
runningInstalls
.
splice
(
this
.
runningInstalls
.
indexOf
(
install
)
1
)
;
this
.
checkTestEnded
(
)
;
}
}
checkTestEnded
(
)
{
if
(
-
-
this
.
pendingCount
=
=
0
&
&
!
this
.
waitingForEvent
)
this
.
endTest
(
)
;
}
observe
(
subject
topic
data
)
{
var
installInfo
=
subject
.
wrappedJSObject
;
switch
(
topic
)
{
case
"
addon
-
install
-
started
"
:
is
(
this
.
runningInstalls
.
length
installInfo
.
installs
.
length
"
Should
have
seen
the
expected
number
of
installs
started
"
)
;
break
;
case
"
addon
-
install
-
disabled
"
:
this
.
installDisabled
(
installInfo
)
;
break
;
case
"
addon
-
install
-
cancelled
"
:
this
.
installCancelled
(
installInfo
)
;
break
;
case
"
addon
-
install
-
origin
-
blocked
"
:
this
.
installOriginBlocked
(
installInfo
)
;
break
;
case
"
addon
-
install
-
blocked
"
:
this
.
installBlocked
(
installInfo
)
;
break
;
case
"
addon
-
install
-
failed
"
:
installInfo
.
installs
.
forEach
(
function
(
aInstall
)
{
isnot
(
this
.
runningInstalls
.
indexOf
(
aInstall
)
-
1
"
Should
only
see
failures
for
started
installs
"
)
;
ok
(
aInstall
.
error
!
=
0
|
|
aInstall
.
addon
.
appDisabled
"
Failed
installs
should
have
an
error
or
be
appDisabled
"
)
;
this
.
runningInstalls
.
splice
(
this
.
runningInstalls
.
indexOf
(
aInstall
)
1
)
;
}
this
)
;
break
;
case
"
addon
-
install
-
complete
"
:
installInfo
.
installs
.
forEach
(
function
(
aInstall
)
{
isnot
(
this
.
runningInstalls
.
indexOf
(
aInstall
)
-
1
"
Should
only
see
completed
events
for
started
installs
"
)
;
is
(
aInstall
.
error
0
"
Completed
installs
should
have
no
error
"
)
;
ok
(
!
aInstall
.
appDisabled
"
Completed
installs
should
not
be
appDisabled
"
)
;
ok
(
aInstall
.
state
=
=
AddonManager
.
STATE_INSTALLED
|
|
aInstall
.
state
=
=
AddonManager
.
STATE_CANCELLED
"
Completed
installs
should
be
in
the
right
state
"
)
;
this
.
runningInstalls
.
splice
(
this
.
runningInstalls
.
indexOf
(
aInstall
)
1
)
;
}
this
)
;
break
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsIWindowMediatorListener
]
)
}
;
