Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
var
ADDONS
=
[
{
id
:
"
proxy1
tests
.
mozilla
.
org
"
dirId
:
"
proxy1
tests
.
mozilla
.
com
"
type
:
"
proxy
"
}
{
id
:
"
proxy2
tests
.
mozilla
.
org
"
type
:
"
proxy
"
}
{
id
:
"
symlink1
tests
.
mozilla
.
org
"
dirId
:
"
symlink1
tests
.
mozilla
.
com
"
type
:
"
symlink
"
}
{
id
:
"
symlink2
tests
.
mozilla
.
org
"
type
:
"
symlink
"
}
]
;
var
METADATA
=
{
version
:
"
2
.
0
"
targetApplications
:
[
{
id
:
"
xpcshell
tests
.
mozilla
.
org
"
minVersion
:
"
2
"
maxVersion
:
"
2
"
}
]
}
const
ios
=
AM_Cc
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
AM_Ci
.
nsIIOService
)
;
const
gHaveSymlinks
=
AppConstants
.
platform
!
=
"
win
"
;
function
createSymlink
(
aSource
aDest
)
{
if
(
aSource
instanceof
AM_Ci
.
nsIFile
)
aSource
=
aSource
.
path
;
if
(
aDest
instanceof
AM_Ci
.
nsIFile
)
aDest
=
aDest
.
path
;
return
OS
.
File
.
unixSymLink
(
aSource
aDest
)
;
}
function
writeFile
(
aData
aFile
)
{
if
(
!
aFile
.
parent
.
exists
(
)
)
aFile
.
parent
.
create
(
AM_Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
var
fos
=
AM_Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
AM_Ci
.
nsIFileOutputStream
)
;
fos
.
init
(
aFile
FileUtils
.
MODE_WRONLY
|
FileUtils
.
MODE_CREATE
|
FileUtils
.
MODE_TRUNCATE
FileUtils
.
PERMS_FILE
0
)
;
fos
.
write
(
aData
aData
.
length
)
;
fos
.
close
(
)
;
}
function
checkAddonsExist
(
)
{
for
(
let
addon
of
ADDONS
)
{
let
file
=
addon
.
directory
.
clone
(
)
;
file
.
append
(
"
install
.
rdf
"
)
;
do_check_true
(
file
.
exists
(
)
Components
.
stack
.
caller
)
;
}
}
const
profileDir
=
gProfD
.
clone
(
)
;
profileDir
.
append
(
"
extensions
"
)
;
function
run_test
(
)
{
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
2
"
"
2
"
)
;
add_task
(
run_proxy_tests
)
;
if
(
gHaveSymlinks
)
add_task
(
run_symlink_tests
)
;
run_next_test
(
)
;
}
function
*
run_proxy_tests
(
)
{
if
(
!
gHaveSymlinks
)
{
ADDONS
=
ADDONS
.
filter
(
a
=
>
a
.
type
!
=
"
symlink
"
)
;
}
for
(
let
addon
of
ADDONS
)
{
addon
.
directory
=
gTmpD
.
clone
(
)
;
addon
.
directory
.
append
(
addon
.
id
)
;
addon
.
proxyFile
=
profileDir
.
clone
(
)
;
addon
.
proxyFile
.
append
(
addon
.
dirId
|
|
addon
.
id
)
;
METADATA
.
id
=
addon
.
id
;
METADATA
.
name
=
addon
.
id
;
writeInstallRDFToDir
(
METADATA
gTmpD
)
;
if
(
addon
.
type
=
=
"
proxy
"
)
{
writeFile
(
addon
.
directory
.
path
addon
.
proxyFile
)
}
else
if
(
addon
.
type
=
=
"
symlink
"
)
{
yield
createSymlink
(
addon
.
directory
addon
.
proxyFile
)
}
}
startupManager
(
)
;
checkAddonsExist
(
)
;
return
new
Promise
(
resolve
=
>
{
AddonManager
.
getAddonsByIDs
(
ADDONS
.
map
(
addon
=
>
addon
.
id
)
resolve
)
;
}
)
.
then
(
addons
=
>
{
try
{
for
(
let
[
i
addon
]
of
addons
.
entries
(
)
)
{
print
(
ADDONS
[
i
]
.
id
ADDONS
[
i
]
.
dirId
ADDONS
[
i
]
.
dirId
!
=
null
ADDONS
[
i
]
.
type
=
=
"
symlink
"
)
;
do_check_eq
(
addon
=
=
null
ADDONS
[
i
]
.
dirId
!
=
null
)
;
if
(
addon
!
=
null
)
{
let
fixURL
=
url
=
>
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
return
url
.
replace
(
RegExp
(
^
file
:
/
/
/
private
/
)
"
file
:
/
/
/
"
)
;
return
url
;
}
;
do_check_eq
(
addon
.
permissions
&
AddonManager
.
PERM_CAN_UPGRADE
0
)
;
do_check_eq
(
ios
.
newFileURI
(
ADDONS
[
i
]
.
directory
)
.
spec
fixURL
(
addon
.
getResourceURI
(
)
.
spec
)
Base
resource
URL
resolves
as
expected
)
;
let
file
=
ADDONS
[
i
]
.
directory
.
clone
(
)
;
file
.
append
(
"
install
.
rdf
"
)
;
do_check_eq
(
ios
.
newFileURI
(
file
)
.
spec
fixURL
(
addon
.
getResourceURI
(
"
install
.
rdf
"
)
.
spec
)
Resource
URLs
resolve
as
expected
)
;
addon
.
uninstall
(
)
;
}
}
restartManager
(
)
;
checkAddonsExist
(
)
;
shutdownManager
(
)
;
for
(
let
addon
of
ADDONS
)
{
equal
(
addon
.
proxyFile
.
exists
(
)
addon
.
dirId
!
=
null
Proxy
file
{
addon
.
proxyFile
.
path
}
should
exist
?
)
;
addon
.
directory
.
remove
(
true
)
;
try
{
addon
.
proxyFile
.
remove
(
false
)
;
}
catch
(
e
)
{
}
}
}
catch
(
e
)
{
do_throw
(
e
)
;
}
}
)
;
}
function
*
run_symlink_tests
(
)
{
METADATA
.
id
=
"
unpacked
test
.
mozilla
.
org
"
;
METADATA
.
name
=
METADATA
.
id
;
METADATA
.
unpack
=
"
true
"
;
let
tempDirectory
=
gTmpD
.
clone
(
)
;
tempDirectory
.
append
(
METADATA
.
id
)
;
let
tempFile
=
tempDirectory
.
clone
(
)
;
tempFile
.
append
(
"
test
.
txt
"
)
;
tempFile
.
create
(
AM_Ci
.
nsIFile
.
NORMAL_FILE_TYPE
0o644
)
;
let
addonDirectory
=
profileDir
.
clone
(
)
;
addonDirectory
.
append
(
METADATA
.
id
)
;
writeInstallRDFToDir
(
METADATA
profileDir
)
;
let
symlink
=
addonDirectory
.
clone
(
)
;
symlink
.
append
(
tempDirectory
.
leafName
)
;
yield
createSymlink
(
tempDirectory
symlink
)
;
let
file
=
symlink
.
clone
(
)
;
file
.
append
(
tempFile
.
leafName
)
;
file
.
normalize
(
)
;
do_check_eq
(
file
.
path
.
replace
(
/
^
\
/
private
\
/
/
"
/
"
)
tempFile
.
path
)
;
startupManager
(
)
;
return
new
Promise
(
resolve
=
>
{
AddonManager
.
getAddonByID
(
METADATA
.
id
resolve
)
;
}
)
.
then
(
addon
=
>
{
do_check_neq
(
addon
null
)
;
addon
.
uninstall
(
)
;
restartManager
(
)
;
shutdownManager
(
)
;
do_check_false
(
addonDirectory
.
exists
(
)
)
;
do_check_true
(
tempFile
.
exists
(
)
)
;
tempDirectory
.
remove
(
true
)
;
}
)
;
}
