const
{
ADDON_SIGNING
}
=
AM_Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonConstants
.
jsm
"
{
}
)
;
function
run_test
(
)
{
run_next_test
(
)
;
}
let
profileDir
;
add_task
(
function
*
setup
(
)
{
profileDir
=
gProfD
.
clone
(
)
;
profileDir
.
append
(
"
extensions
"
)
;
if
(
!
profileDir
.
exists
(
)
)
profileDir
.
create
(
AM_Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
.
9
.
2
"
)
;
startupManager
(
)
;
}
)
;
const
IMPLICIT_ID_XPI
=
"
data
/
webext
-
implicit
-
id
.
xpi
"
;
const
IMPLICIT_ID_ID
=
"
webext_implicit_id
tests
.
mozilla
.
org
"
;
add_task
(
function
*
test_implicit_id
(
)
{
ok
(
ADDON_SIGNING
"
Addon
signing
is
enabled
"
)
;
let
addon
=
yield
promiseAddonByID
(
IMPLICIT_ID_ID
)
;
do_check_eq
(
addon
null
)
;
let
xpifile
=
do_get_file
(
IMPLICIT_ID_XPI
)
;
yield
promiseInstallAllFiles
(
[
xpifile
]
)
;
addon
=
yield
promiseAddonByID
(
IMPLICIT_ID_ID
)
;
do_check_neq
(
addon
null
)
;
addon
.
uninstall
(
)
;
}
)
;
add_task
(
function
*
test_implicit_id_temp
(
)
{
ok
(
ADDON_SIGNING
"
Addon
signing
is
enabled
"
)
;
let
addon
=
yield
promiseAddonByID
(
IMPLICIT_ID_ID
)
;
do_check_eq
(
addon
null
)
;
let
xpifile
=
do_get_file
(
IMPLICIT_ID_XPI
)
;
yield
AddonManager
.
installTemporaryAddon
(
xpifile
)
;
addon
=
yield
promiseAddonByID
(
IMPLICIT_ID_ID
)
;
do_check_neq
(
addon
null
)
;
do_check_eq
(
addon
.
sourceURI
&
&
addon
.
sourceURI
.
spec
Services
.
io
.
newFileURI
(
xpifile
)
.
spec
)
;
addon
.
uninstall
(
)
;
}
)
;
add_task
(
function
*
test_unsigned_no_id_temp_install
(
)
{
if
(
!
TEST_UNPACKED
)
{
do_print
(
"
This
test
does
not
apply
when
using
packed
extensions
"
)
;
return
;
}
const
manifest
=
{
name
:
"
no
ID
"
description
:
"
extension
without
an
ID
"
manifest_version
:
2
version
:
"
1
.
0
"
}
;
const
addonDir
=
writeWebManifestForExtension
(
manifest
gTmpD
"
the
-
addon
-
sub
-
dir
"
)
;
const
addon
=
yield
AddonManager
.
installTemporaryAddon
(
addonDir
)
;
ok
(
addon
.
id
"
ID
should
have
been
auto
-
generated
"
)
;
do_check_eq
(
addon
.
sourceURI
&
&
addon
.
sourceURI
.
spec
Services
.
io
.
newFileURI
(
addonDir
)
.
spec
)
;
const
secondAddon
=
yield
AddonManager
.
installTemporaryAddon
(
addonDir
)
;
equal
(
secondAddon
.
id
addon
.
id
)
;
secondAddon
.
uninstall
(
)
;
addonDir
.
remove
(
true
)
;
}
)
;
add_task
(
function
*
test_multiple_no_id_extensions
(
)
{
if
(
!
TEST_UNPACKED
)
{
do_print
(
"
This
test
does
not
apply
when
using
packed
extensions
"
)
;
return
;
}
const
manifest
=
{
name
:
"
no
ID
"
description
:
"
extension
without
an
ID
"
manifest_version
:
2
version
:
"
1
.
0
"
}
;
const
firstAddonDir
=
writeWebManifestForExtension
(
manifest
gTmpD
"
addon
-
sub
-
dir
-
one
"
)
;
const
secondAddonDir
=
writeWebManifestForExtension
(
manifest
gTmpD
"
addon
-
sub
-
dir
-
two
"
)
;
const
[
firstAddon
secondAddon
]
=
yield
Promise
.
all
(
[
AddonManager
.
installTemporaryAddon
(
firstAddonDir
)
AddonManager
.
installTemporaryAddon
(
secondAddonDir
)
]
)
;
const
allAddons
=
yield
new
Promise
(
resolve
=
>
{
AddonManager
.
getAllAddons
(
addons
=
>
resolve
(
addons
)
)
;
}
)
;
do_print
(
Found
these
add
-
ons
:
{
allAddons
.
map
(
a
=
>
a
.
name
)
.
join
(
"
"
)
}
)
;
const
filtered
=
allAddons
.
filter
(
addon
=
>
addon
.
name
=
=
=
manifest
.
name
)
;
equal
(
filtered
.
length
2
)
;
firstAddon
.
uninstall
(
)
;
firstAddonDir
.
remove
(
true
)
;
secondAddon
.
uninstall
(
)
;
secondAddonDir
.
remove
(
true
)
;
}
)
;
add_task
(
function
*
test_bss_id
(
)
{
const
ID
=
"
webext_bss_id
tests
.
mozilla
.
org
"
;
let
manifest
=
{
name
:
"
bss
test
"
description
:
"
test
that
ID
may
be
in
browser_specific_settings
"
manifest_version
:
2
version
:
"
1
.
0
"
browser_specific_settings
:
{
gecko
:
{
id
:
ID
}
}
}
;
let
addon
=
yield
promiseAddonByID
(
ID
)
;
do_check_eq
(
addon
null
)
;
writeWebManifestForExtension
(
manifest
profileDir
ID
)
;
yield
promiseRestartManager
(
)
;
addon
=
yield
promiseAddonByID
(
ID
)
;
do_check_neq
(
addon
null
)
;
addon
.
uninstall
(
)
;
}
)
;
add_task
(
function
*
test_two_ids
(
)
{
const
GOOD_ID
=
"
two_ids
tests
.
mozilla
.
org
"
;
const
BAD_ID
=
"
i_am_obsolete
tests
.
mozilla
.
org
"
;
let
manifest
=
{
name
:
"
two
id
test
"
description
:
"
test
a
web
extension
with
ids
in
both
applications
and
browser_specific_settings
"
manifest_version
:
2
version
:
"
1
.
0
"
applications
:
{
gecko
:
{
id
:
BAD_ID
}
}
browser_specific_settings
:
{
gecko
:
{
id
:
GOOD_ID
}
}
}
writeWebManifestForExtension
(
manifest
profileDir
GOOD_ID
)
;
yield
promiseRestartManager
(
)
;
let
addon
=
yield
promiseAddonByID
(
BAD_ID
)
;
do_check_eq
(
addon
null
)
;
addon
=
yield
promiseAddonByID
(
GOOD_ID
)
;
do_check_neq
(
addon
null
)
;
addon
.
uninstall
(
)
;
}
)
;
add_task
(
function
*
test_strict_min_max
(
)
{
const
addonId
=
"
strict_min_max
tests
.
mozilla
.
org
"
;
const
MANIFEST
=
{
name
:
"
strict
min
max
test
"
description
:
"
test
strict
min
and
max
with
temporary
loading
"
manifest_version
:
2
version
:
"
1
.
0
"
}
;
let
apps
=
{
applications
:
{
gecko
:
{
id
:
addonId
strict_min_version
:
"
1
"
strict_max_version
:
"
1
"
}
}
}
let
testManifest
=
Object
.
assign
(
apps
MANIFEST
)
;
let
addonDir
=
writeWebManifestForExtension
(
testManifest
gTmpD
"
the
-
addon
-
sub
-
dir
"
)
;
let
expectedMsg
=
new
RegExp
(
"
Add
-
on
strict_min_max
tests
.
mozilla
.
org
is
not
compatible
with
application
version
.
"
+
"
add
-
on
minVersion
:
1
add
-
on
maxVersion
:
1
"
)
;
yield
Assert
.
rejects
(
AddonManager
.
installTemporaryAddon
(
addonDir
)
expectedMsg
"
Install
rejects
when
specified
maxVersion
is
not
valid
"
)
;
let
addon
=
yield
promiseAddonByID
(
addonId
)
;
do_check_eq
(
addon
null
)
;
apps
=
{
applications
:
{
gecko
:
{
id
:
addonId
strict_min_version
:
"
2
"
strict_max_version
:
"
2
"
}
}
}
testManifest
=
Object
.
assign
(
apps
MANIFEST
)
;
addonDir
=
writeWebManifestForExtension
(
testManifest
gTmpD
"
the
-
addon
-
sub
-
dir
"
)
;
expectedMsg
=
new
RegExp
(
"
Add
-
on
strict_min_max
tests
.
mozilla
.
org
is
not
compatible
with
application
version
.
"
+
"
add
-
on
minVersion
:
2
add
-
on
maxVersion
:
2
"
)
;
yield
Assert
.
rejects
(
AddonManager
.
installTemporaryAddon
(
addonDir
)
expectedMsg
"
Install
rejects
when
specified
minVersion
is
not
valid
"
)
;
addon
=
yield
promiseAddonByID
(
addonId
)
;
do_check_eq
(
addon
null
)
;
apps
=
{
applications
:
{
gecko
:
{
id
:
addonId
strict_min_version
:
"
2
"
strict_max_version
:
"
1
"
}
}
}
testManifest
=
Object
.
assign
(
apps
MANIFEST
)
;
addonDir
=
writeWebManifestForExtension
(
testManifest
gTmpD
"
the
-
addon
-
sub
-
dir
"
)
;
expectedMsg
=
new
RegExp
(
"
Add
-
on
strict_min_max
tests
.
mozilla
.
org
is
not
compatible
with
application
version
.
"
+
"
add
-
on
minVersion
:
2
add
-
on
maxVersion
:
1
"
)
;
yield
Assert
.
rejects
(
AddonManager
.
installTemporaryAddon
(
addonDir
)
expectedMsg
"
Install
rejects
when
specified
minVersion
and
maxVersion
are
not
valid
"
)
;
addon
=
yield
promiseAddonByID
(
addonId
)
;
do_check_eq
(
addon
null
)
;
addonDir
.
remove
(
true
)
;
apps
=
{
applications
:
{
gecko
:
{
id
:
addonId
strict_min_version
:
"
1
"
strict_max_version
:
"
2
"
}
}
}
testManifest
=
Object
.
assign
(
apps
MANIFEST
)
;
addonDir
=
writeWebManifestForExtension
(
testManifest
gTmpD
"
strict_min_max
"
)
;
yield
AddonManager
.
installTemporaryAddon
(
addonDir
)
;
addon
=
yield
promiseAddonByID
(
addonId
)
;
do_check_neq
(
addon
null
)
;
do_check_eq
(
addon
.
id
addonId
)
;
addon
.
uninstall
(
)
;
addonDir
.
remove
(
true
)
;
let
newId
=
"
strict_min_only
tests
.
mozilla
.
org
"
;
apps
=
{
applications
:
{
gecko
:
{
id
:
newId
strict_min_version
:
"
1
"
}
}
}
testManifest
=
Object
.
assign
(
apps
MANIFEST
)
;
addonDir
=
writeWebManifestForExtension
(
testManifest
gTmpD
"
strict_min_only
"
)
;
yield
AddonManager
.
installTemporaryAddon
(
addonDir
)
;
addon
=
yield
promiseAddonByID
(
newId
)
;
do_check_neq
(
addon
null
)
;
do_check_eq
(
addon
.
id
newId
)
;
addon
.
uninstall
(
)
;
addonDir
.
remove
(
true
)
;
newId
=
"
strict_max_only
tests
.
mozilla
.
org
"
;
apps
=
{
applications
:
{
gecko
:
{
id
:
newId
strict_max_version
:
"
2
"
}
}
}
testManifest
=
Object
.
assign
(
apps
MANIFEST
)
;
addonDir
=
writeWebManifestForExtension
(
testManifest
gTmpD
"
strict_max_only
"
)
;
yield
AddonManager
.
installTemporaryAddon
(
addonDir
)
;
addon
=
yield
promiseAddonByID
(
newId
)
;
do_check_neq
(
addon
null
)
;
do_check_eq
(
addon
.
id
newId
)
;
addon
.
uninstall
(
)
;
addonDir
.
remove
(
true
)
;
}
)
;
