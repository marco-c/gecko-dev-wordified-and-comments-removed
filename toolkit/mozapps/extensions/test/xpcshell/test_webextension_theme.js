"
use
strict
"
;
const
THEME_IDS
=
[
"
theme3
tests
.
mozilla
.
org
"
"
theme2
personas
.
mozilla
.
org
"
"
default
-
theme
mozilla
.
org
"
]
;
const
REAL_THEME_IDS
=
[
THEME_IDS
[
0
]
THEME_IDS
[
2
]
]
;
const
DEFAULT_THEME
=
THEME_IDS
[
2
]
;
const
profileDir
=
gProfD
.
clone
(
)
;
profileDir
.
append
(
"
extensions
"
)
;
Services
.
prefs
.
setIntPref
(
"
extensions
.
enabledScopes
"
AddonManager
.
SCOPE_PROFILE
|
AddonManager
.
SCOPE_APPLICATION
)
;
var
gActiveTheme
=
null
;
add_task
(
async
function
setup_to_default_browserish_state
(
)
{
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
.
9
.
2
"
)
;
await
promiseWriteWebManifestForExtension
(
{
author
:
"
Some
author
"
manifest_version
:
2
name
:
"
Web
Extension
Name
"
version
:
"
1
.
0
"
theme
:
{
images
:
{
headerURL
:
"
example
.
png
"
}
}
applications
:
{
gecko
:
{
id
:
THEME_IDS
[
0
]
}
}
}
profileDir
)
;
await
promiseStartupManager
(
)
;
if
(
AppConstants
.
MOZ_DEV_EDITION
)
{
let
defaultTheme
=
await
AddonManager
.
getAddonByID
(
"
default
-
theme
mozilla
.
org
"
)
;
await
defaultTheme
.
enable
(
)
;
}
let
[
t1
t2
d
]
=
await
promiseAddonsByIDs
(
THEME_IDS
)
;
Assert
.
ok
(
t1
"
Theme
addon
should
exist
"
)
;
Assert
.
equal
(
t2
null
"
Theme
addon
is
not
a
thing
anymore
"
)
;
Assert
.
ok
(
d
"
Theme
addon
should
exist
"
)
;
await
t1
.
disable
(
)
;
await
new
Promise
(
executeSoon
)
;
Assert
.
ok
(
!
t1
.
isActive
"
Theme
should
be
disabled
"
)
;
Assert
.
ok
(
d
.
isActive
"
Default
theme
should
be
active
"
)
;
await
promiseRestartManager
(
)
;
[
t1
t2
d
]
=
await
promiseAddonsByIDs
(
THEME_IDS
)
;
Assert
.
ok
(
!
t1
.
isActive
"
Theme
should
still
be
disabled
"
)
;
Assert
.
ok
(
d
.
isActive
"
Default
theme
should
still
be
active
"
)
;
gActiveTheme
=
d
.
id
;
}
)
;
async
function
setDisabledStateAndCheck
(
which
disabled
=
false
)
{
if
(
disabled
)
{
Assert
.
equal
(
which
gActiveTheme
"
Only
the
active
theme
can
be
disabled
"
)
;
}
let
themeToDisable
=
disabled
?
which
:
gActiveTheme
;
let
themeToEnable
=
disabled
?
DEFAULT_THEME
:
which
;
let
expectedStates
=
{
[
themeToDisable
]
:
true
[
themeToEnable
]
:
false
}
;
let
addonEvents
=
{
[
themeToDisable
]
:
[
{
event
:
"
onDisabling
"
}
{
event
:
"
onDisabled
"
}
]
[
themeToEnable
]
:
[
{
event
:
"
onEnabling
"
}
{
event
:
"
onEnabled
"
}
]
}
;
let
theme
=
await
promiseAddonByID
(
which
)
;
await
expectEvents
(
{
addonEvents
}
(
)
=
>
{
if
(
disabled
)
{
theme
.
disable
(
)
;
}
else
{
theme
.
enable
(
)
;
}
}
)
;
let
isDisabled
;
for
(
theme
of
await
promiseAddonsByIDs
(
REAL_THEME_IDS
)
)
{
isDisabled
=
theme
.
id
in
expectedStates
?
expectedStates
[
theme
.
id
]
:
true
;
Assert
.
equal
(
theme
.
userDisabled
isDisabled
Theme
'
{
theme
.
id
}
'
should
be
{
isDisabled
?
"
dis
"
:
"
en
"
}
abled
)
;
Assert
.
equal
(
theme
.
pendingOperations
AddonManager
.
PENDING_NONE
"
There
should
be
no
pending
operations
when
no
restart
is
expected
"
)
;
Assert
.
equal
(
theme
.
isActive
!
isDisabled
Theme
'
{
theme
.
id
}
should
be
{
isDisabled
?
"
in
"
:
"
"
}
active
)
;
}
await
promiseRestartManager
(
)
;
for
(
theme
of
await
promiseAddonsByIDs
(
REAL_THEME_IDS
)
)
{
isDisabled
=
theme
.
id
in
expectedStates
?
expectedStates
[
theme
.
id
]
:
true
;
Assert
.
equal
(
theme
.
userDisabled
isDisabled
Theme
'
{
theme
.
id
}
'
should
be
{
isDisabled
?
"
dis
"
:
"
en
"
}
abled
)
;
Assert
.
equal
(
theme
.
isActive
!
isDisabled
Theme
'
{
theme
.
id
}
'
should
be
{
isDisabled
?
"
in
"
:
"
"
}
active
)
;
Assert
.
equal
(
theme
.
pendingOperations
AddonManager
.
PENDING_NONE
"
There
should
be
no
pending
operations
left
"
)
;
if
(
!
isDisabled
)
{
gActiveTheme
=
theme
.
id
;
}
}
}
add_task
(
async
function
test_WebExtension_themes
(
)
{
await
setDisabledStateAndCheck
(
THEME_IDS
[
0
]
)
;
await
setDisabledStateAndCheck
(
THEME_IDS
[
0
]
true
)
;
await
setDisabledStateAndCheck
(
THEME_IDS
[
0
]
)
;
}
)
;
add_task
(
async
function
test_default_theme
(
)
{
await
setDisabledStateAndCheck
(
DEFAULT_THEME
)
;
await
setDisabledStateAndCheck
(
THEME_IDS
[
0
]
)
;
await
setDisabledStateAndCheck
(
DEFAULT_THEME
)
;
}
)
;
add_task
(
async
function
uninstall_offers_undo
(
)
{
const
ID
=
THEME_IDS
[
0
]
;
let
theme
=
await
promiseAddonByID
(
ID
)
;
Assert
.
ok
(
theme
"
Webextension
theme
is
present
"
)
;
Assert
.
ok
(
!
theme
.
isActive
"
Webextension
theme
is
not
active
"
)
;
function
promiseAddonEvent
(
event
id
)
{
return
new
Promise
(
resolve
=
>
{
let
listener
=
{
[
event
]
:
function
(
addon
)
{
if
(
id
)
{
Assert
.
equal
(
addon
.
id
id
"
Got
event
for
expected
addon
"
)
;
}
AddonManager
.
removeAddonListener
(
listener
)
;
resolve
(
)
;
}
}
;
AddonManager
.
addAddonListener
(
listener
)
;
}
)
;
}
let
uninstallingPromise
=
promiseAddonEvent
(
"
onUninstalling
"
ID
)
;
await
theme
.
uninstall
(
true
)
;
await
uninstallingPromise
;
Assert
.
ok
(
hasFlag
(
theme
.
pendingOperations
AddonManager
.
PENDING_UNINSTALL
)
"
Theme
being
uninstalled
has
PENDING_UNINSTALL
flag
"
)
;
let
cancelPromise
=
promiseAddonEvent
(
"
onOperationCancelled
"
ID
)
;
theme
.
cancelUninstall
(
)
;
await
cancelPromise
;
Assert
.
equal
(
theme
.
pendingOperations
AddonManager
.
PENDING_NONE
"
PENDING_UNINSTALL
flag
is
cleared
when
uninstall
is
canceled
"
)
;
await
theme
.
uninstall
(
)
;
await
promiseRestartManager
(
)
;
}
)
;
add_task
(
async
function
default_locale_themes
(
)
{
let
addon
=
await
promiseInstallWebExtension
(
{
manifest
:
{
default_locale
:
"
en
"
name
:
"
__MSG_name__
"
description
:
"
__MSG_description__
"
theme
:
{
colors
:
{
accentcolor
:
"
black
"
textcolor
:
"
white
"
}
}
}
files
:
{
"
_locales
/
en
/
messages
.
json
"
:
{
"
name
"
:
{
"
message
"
:
"
the
name
"
}
"
description
"
:
{
"
message
"
:
"
the
description
"
}
}
}
}
)
;
addon
=
await
promiseAddonByID
(
addon
.
id
)
;
equal
(
addon
.
name
"
the
name
"
)
;
equal
(
addon
.
description
"
the
description
"
)
;
equal
(
addon
.
type
"
theme
"
)
;
await
addon
.
uninstall
(
)
;
}
)
;
