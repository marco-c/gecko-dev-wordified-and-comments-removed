"
use
strict
"
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
resourceProtocol
"
(
)
=
>
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
)
;
Services
.
prefs
.
setBoolPref
(
PREF_EM_CHECK_UPDATE_SECURITY
false
)
;
const
ID
=
"
langpack
-
und
test
.
mozilla
.
org
"
;
const
profileDir
=
gProfD
.
clone
(
)
;
profileDir
.
append
(
"
extensions
"
)
;
var
server
=
AddonTestUtils
.
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
]
}
)
;
AddonTestUtils
.
registerJSON
(
server
"
/
test_update_langpack
.
json
"
{
addons
:
{
"
langpack
-
und
test
.
mozilla
.
org
"
:
{
updates
:
[
{
version
:
"
58
.
0
.
20230105
.
121014
"
applications
:
{
gecko
:
{
strict_min_version
:
"
58
.
0
"
strict_max_version
:
"
58
.
*
"
}
}
}
{
version
:
"
60
.
0
.
20230207
.
112555
"
update_link
:
"
http
:
/
/
example
.
com
/
addons
/
langpack
-
und
test
.
mozilla
.
org
.
xpi
"
applications
:
{
gecko
:
{
strict_min_version
:
"
60
.
0
"
strict_max_version
:
"
60
.
*
"
}
}
}
{
version
:
"
60
.
1
.
20230309
.
91233
"
update_link
:
"
http
:
/
/
example
.
com
/
addons
/
dotrelease
/
langpack
-
und
test
.
mozilla
.
org
.
xpi
"
applications
:
{
gecko
:
{
strict_min_version
:
"
60
.
0
"
strict_max_version
:
"
60
.
*
"
}
}
}
]
}
}
}
)
;
AddonTestUtils
.
registerJSON
(
server
"
/
test_update_langpack2
.
json
"
{
addons
:
{
"
langpack
-
und
test
.
mozilla
.
org
"
:
{
updates
:
[
{
version
:
"
60
.
2
.
20230319
.
94511
"
update_link
:
"
http
:
/
/
example
.
com
/
addons
/
dotrelease2
/
langpack
-
und
test
.
mozilla
.
org
.
xpi
"
applications
:
{
gecko
:
{
strict_min_version
:
"
60
.
0
"
strict_max_version
:
"
60
.
*
"
}
}
}
]
}
}
}
)
;
function
promisePostponeInstall
(
install
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
listener
=
{
onDownloadEnded
:
(
)
=
>
{
install
.
postpone
(
)
;
}
onInstallFailed
:
(
)
=
>
{
install
.
removeListener
(
listener
)
;
reject
(
new
Error
(
"
extension
installation
should
not
have
failed
"
)
)
;
}
onInstallEnded
:
(
)
=
>
{
install
.
removeListener
(
listener
)
;
reject
(
new
Error
(
extension
installation
should
not
have
ended
for
{
install
.
addon
.
id
}
)
)
;
}
onInstallPostponed
:
(
)
=
>
{
install
.
removeListener
(
listener
)
;
resolve
(
)
;
}
}
;
install
.
addListener
(
listener
)
;
}
)
;
}
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
58
"
)
;
const
ADDONS
=
{
langpack_1
:
{
"
browser
/
localization
/
und
/
browser
.
ftl
"
:
"
message
-
browser
=
Value
from
Browser
\
n
"
"
localization
/
und
/
toolkit_test
.
ftl
"
:
"
message
-
id1
=
Value
1
\
n
"
"
chrome
/
und
/
locale
/
und
/
global
/
test
.
properties
"
:
"
message
=
Value
from
.
properties
\
n
"
"
manifest
.
json
"
:
{
name
:
"
und
Language
Pack
"
version
:
"
58
.
0
.
20230105
.
121014
"
manifest_version
:
2
browser_specific_settings
:
{
gecko
:
{
id
:
ID
strict_min_version
:
"
58
.
0
"
strict_max_version
:
"
58
.
*
"
update_url
:
"
http
:
/
/
example
.
com
/
test_update_langpack
.
json
"
}
}
sources
:
{
browser
:
{
base_path
:
"
browser
/
"
}
}
langpack_id
:
"
und
"
languages
:
{
und
:
{
chrome_resources
:
{
global
:
"
chrome
/
und
/
locale
/
und
/
global
/
"
}
version
:
"
20171001190118
"
}
}
author
:
"
Mozilla
Localization
Task
Force
"
description
:
"
Language
pack
for
Testy
for
und
"
}
}
}
;
const
langpack_update
=
JSON
.
parse
(
JSON
.
stringify
(
ADDONS
.
langpack_1
)
)
;
langpack_update
[
"
manifest
.
json
"
]
.
version
=
"
60
.
0
.
20230207
.
112555
"
;
langpack_update
[
"
manifest
.
json
"
]
.
browser_specific_settings
.
gecko
=
{
id
:
ID
strict_min_version
:
"
60
.
0
"
strict_max_version
:
"
60
.
*
"
update_url
:
"
http
:
/
/
example
.
com
/
test_update_langpack
.
json
"
}
;
const
langpack_update_dotrelease
=
JSON
.
parse
(
JSON
.
stringify
(
ADDONS
.
langpack_1
)
)
;
langpack_update_dotrelease
[
"
manifest
.
json
"
]
.
version
=
"
60
.
1
.
20230309
.
91233
"
;
langpack_update_dotrelease
[
"
manifest
.
json
"
]
.
browser_specific_settings
.
gecko
=
{
id
:
ID
strict_min_version
:
"
60
.
0
"
strict_max_version
:
"
60
.
*
"
update_url
:
"
http
:
/
/
example
.
com
/
test_update_langpack2
.
json
"
}
;
const
langpack_update_dotrelease2
=
JSON
.
parse
(
JSON
.
stringify
(
ADDONS
.
langpack_1
)
)
;
langpack_update_dotrelease2
[
"
manifest
.
json
"
]
.
version
=
"
60
.
2
.
20230319
.
94511
"
;
langpack_update_dotrelease2
[
"
manifest
.
json
"
]
.
browser_specific_settings
.
gecko
=
{
id
:
ID
strict_min_version
:
"
60
.
0
"
strict_max_version
:
"
60
.
*
"
update_url
:
"
http
:
/
/
example
.
com
/
test_update_langpack2
.
json
"
}
;
let
xpi
=
AddonTestUtils
.
createTempXPIFile
(
langpack_update
)
;
server
.
registerFile
(
/
addons
/
{
ID
}
.
xpi
xpi
)
;
let
xpiDotRelease
=
AddonTestUtils
.
createTempXPIFile
(
langpack_update_dotrelease
)
;
server
.
registerFile
(
/
addons
/
dotrelease
/
{
ID
}
.
xpi
xpiDotRelease
)
;
let
xpiDotRelease2
=
AddonTestUtils
.
createTempXPIFile
(
langpack_update_dotrelease2
)
;
server
.
registerFile
(
/
addons
/
dotrelease2
/
{
ID
}
.
xpi
xpiDotRelease2
)
;
function
promiseLangpackStartup
(
)
{
return
new
Promise
(
resolve
=
>
{
const
EVENT
=
"
webextension
-
langpack
-
startup
"
;
Services
.
obs
.
addObserver
(
function
observer
(
)
{
Services
.
obs
.
removeObserver
(
observer
EVENT
)
;
resolve
(
)
;
}
EVENT
)
;
}
)
;
}
add_task
(
async
function
setup
(
)
{
Services
.
prefs
.
clearUserPref
(
"
extensions
.
startupScanScopes
"
)
;
}
)
;
add_task
(
async
function
test_basic_lifecycle
(
)
{
await
promiseStartupManager
(
)
;
equal
(
L10nRegistry
.
getInstance
(
)
.
getAvailableLocales
(
)
.
includes
(
"
und
"
)
false
"
und
not
installed
"
)
;
equal
(
Services
.
locale
.
availableLocales
.
includes
(
"
und
"
)
false
"
und
not
available
"
)
;
let
[
{
addon
}
]
=
await
Promise
.
all
(
[
promiseLangpackStartup
(
)
AddonTestUtils
.
promiseInstallXPI
(
ADDONS
.
langpack_1
)
]
)
;
equal
(
L10nRegistry
.
getInstance
(
)
.
getAvailableLocales
(
)
.
includes
(
"
und
"
)
true
"
und
is
installed
"
)
;
equal
(
Services
.
locale
.
availableLocales
.
includes
(
"
und
"
)
true
"
und
is
available
"
)
;
await
addon
.
disable
(
)
;
equal
(
L10nRegistry
.
getInstance
(
)
.
getAvailableLocales
(
)
.
includes
(
"
und
"
)
false
"
und
not
installed
"
)
;
equal
(
Services
.
locale
.
availableLocales
.
includes
(
"
und
"
)
false
"
und
not
available
"
)
;
await
Promise
.
all
(
[
promiseLangpackStartup
(
)
addon
.
enable
(
)
]
)
;
equal
(
L10nRegistry
.
getInstance
(
)
.
getAvailableLocales
(
)
.
includes
(
"
und
"
)
true
"
und
is
installed
"
)
;
equal
(
Services
.
locale
.
availableLocales
.
includes
(
"
und
"
)
true
"
und
is
available
"
)
;
await
addon
.
uninstall
(
)
;
equal
(
L10nRegistry
.
getInstance
(
)
.
getAvailableLocales
(
)
.
includes
(
"
und
"
)
false
"
und
not
installed
"
)
;
equal
(
Services
.
locale
.
availableLocales
.
includes
(
"
und
"
)
false
"
und
not
available
"
)
;
}
)
;
add_task
(
async
function
test_locale_registries
(
)
{
let
[
{
addon
}
]
=
await
Promise
.
all
(
[
promiseLangpackStartup
(
)
AddonTestUtils
.
promiseInstallXPI
(
ADDONS
.
langpack_1
)
]
)
;
{
let
bundles
=
L10nRegistry
.
getInstance
(
)
.
generateBundlesSync
(
[
"
und
"
]
[
"
toolkit_test
.
ftl
"
]
)
;
let
bundle0
=
bundles
.
next
(
)
.
value
;
ok
(
bundle0
)
;
equal
(
bundle0
.
hasMessage
(
"
message
-
id1
"
)
true
)
;
}
{
let
bundles
=
L10nRegistry
.
getInstance
(
)
.
generateBundlesSync
(
[
"
und
"
]
[
"
browser
.
ftl
"
]
)
;
let
bundle0
=
bundles
.
next
(
)
.
value
;
ok
(
bundle0
)
;
equal
(
bundle0
.
hasMessage
(
"
message
-
browser
"
)
true
)
;
}
{
let
reqLocs
=
Services
.
locale
.
requestedLocales
;
Services
.
locale
.
requestedLocales
=
[
"
und
"
]
;
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
test
.
properties
"
)
;
let
entry
=
bundle
.
GetStringFromName
(
"
message
"
)
;
equal
(
entry
"
Value
from
.
properties
"
)
;
Services
.
locale
.
requestedLocales
=
reqLocs
;
}
await
addon
.
uninstall
(
)
;
}
)
;
add_task
(
async
function
test_locale_registries_async
(
)
{
let
[
{
addon
}
]
=
await
Promise
.
all
(
[
promiseLangpackStartup
(
)
AddonTestUtils
.
promiseInstallXPI
(
ADDONS
.
langpack_1
)
]
)
;
{
let
bundles
=
L10nRegistry
.
getInstance
(
)
.
generateBundles
(
[
"
und
"
]
[
"
toolkit_test
.
ftl
"
]
)
;
let
bundle0
=
(
await
bundles
.
next
(
)
)
.
value
;
equal
(
bundle0
.
hasMessage
(
"
message
-
id1
"
)
true
)
;
}
{
let
bundles
=
L10nRegistry
.
getInstance
(
)
.
generateBundles
(
[
"
und
"
]
[
"
browser
.
ftl
"
]
)
;
let
bundle0
=
(
await
bundles
.
next
(
)
)
.
value
;
equal
(
bundle0
.
hasMessage
(
"
message
-
browser
"
)
true
)
;
}
await
addon
.
uninstall
(
)
;
await
promiseShutdownManager
(
)
;
}
)
;
add_task
(
async
function
test_langpack_app_shutdown
(
)
{
let
langpackId
=
langpack
-
und
-
{
AppConstants
.
MOZ_BUILD_APP
.
replace
(
"
/
"
"
-
"
)
}
;
let
check
=
(
yes
msg
)
=
>
{
equal
(
resourceProtocol
.
hasSubstitution
(
langpackId
)
yes
msg
)
;
}
;
await
promiseStartupManager
(
)
;
check
(
false
"
no
initial
resource
substitution
"
)
;
await
Promise
.
all
(
[
promiseLangpackStartup
(
)
AddonTestUtils
.
promiseInstallXPI
(
ADDONS
.
langpack_1
)
]
)
;
check
(
true
"
langpack
resource
available
after
startup
"
)
;
await
promiseShutdownManager
(
)
;
check
(
true
"
langpack
resource
available
after
app
shutdown
"
)
;
await
promiseStartupManager
(
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
ID
)
;
await
addon
.
uninstall
(
)
;
check
(
false
"
langpack
resource
removed
during
shutdown
for
uninstall
"
)
;
await
promiseShutdownManager
(
)
;
}
)
;
add_task
(
async
function
test_amazing_disappearing_langpacks
(
)
{
let
check
=
yes
=
>
{
equal
(
L10nRegistry
.
getInstance
(
)
.
getAvailableLocales
(
)
.
includes
(
"
und
"
)
yes
"
check
L10nRegistry
"
)
;
equal
(
Services
.
locale
.
availableLocales
.
includes
(
"
und
"
)
yes
"
check
availableLocales
"
)
;
}
;
await
promiseStartupManager
(
)
;
check
(
false
)
;
await
Promise
.
all
(
[
promiseLangpackStartup
(
)
AddonTestUtils
.
promiseInstallXPI
(
ADDONS
.
langpack_1
)
]
)
;
check
(
true
)
;
await
promiseShutdownManager
(
)
;
check
(
false
)
;
await
AddonTestUtils
.
manuallyUninstall
(
AddonTestUtils
.
profileExtensions
ID
)
;
await
promiseStartupManager
(
)
;
check
(
false
)
;
}
)
;
add_task
(
async
function
test_disable_after_app_update
(
)
{
let
[
{
addon
}
]
=
await
Promise
.
all
(
[
promiseLangpackStartup
(
)
AddonTestUtils
.
promiseInstallXPI
(
ADDONS
.
langpack_1
)
]
)
;
Assert
.
ok
(
addon
.
isActive
)
;
await
promiseRestartManager
(
"
59
"
)
;
addon
=
await
promiseAddonByID
(
ID
)
;
Assert
.
ok
(
!
addon
.
isActive
)
;
Assert
.
ok
(
addon
.
appDisabled
)
;
await
addon
.
uninstall
(
)
;
await
promiseShutdownManager
(
)
;
}
)
;
add_task
(
async
function
test_after_app_update
(
)
{
await
promiseStartupManager
(
"
58
"
)
;
let
[
{
addon
}
]
=
await
Promise
.
all
(
[
promiseLangpackStartup
(
)
AddonTestUtils
.
promiseInstallXPI
(
ADDONS
.
langpack_1
)
]
)
;
Assert
.
ok
(
addon
.
isActive
)
;
await
promiseRestartManager
(
"
60
"
)
;
addon
=
await
promiseAddonByID
(
ID
)
;
Assert
.
ok
(
!
addon
.
isActive
)
;
Assert
.
ok
(
addon
.
appDisabled
)
;
Assert
.
equal
(
addon
.
version
"
58
.
0
.
20230105
.
121014
"
)
;
let
update
=
await
promiseFindAddonUpdates
(
addon
)
;
Assert
.
ok
(
update
.
updateAvailable
"
update
is
available
"
)
;
let
install
=
update
.
updateAvailable
;
let
postponed
=
promisePostponeInstall
(
install
)
;
install
.
install
(
)
;
await
postponed
;
Assert
.
equal
(
install
.
state
AddonManager
.
STATE_POSTPONED
"
install
postponed
"
)
;
await
promiseRestartManager
(
)
;
addon
=
await
promiseAddonByID
(
ID
)
;
Assert
.
ok
(
addon
.
isActive
)
;
Assert
.
equal
(
addon
.
version
"
60
.
1
.
20230309
.
91233
"
)
;
await
addon
.
uninstall
(
)
;
await
promiseShutdownManager
(
)
;
}
)
;
function
promiseLocaleChanged
(
requestedLocales
)
{
let
changed
=
ExtensionUtils
.
promiseObserved
(
"
intl
:
requested
-
locales
-
changed
"
)
;
Services
.
locale
.
requestedLocales
=
requestedLocales
;
return
changed
;
}
add_task
(
async
function
test_staged_langpack_for_app_update
(
)
{
let
originalLocales
=
Services
.
locale
.
requestedLocales
;
await
promiseStartupManager
(
"
58
"
)
;
let
[
{
addon
}
]
=
await
Promise
.
all
(
[
promiseLangpackStartup
(
)
AddonTestUtils
.
promiseInstallXPI
(
ADDONS
.
langpack_1
)
]
)
;
Assert
.
ok
(
addon
.
isActive
)
;
await
promiseLocaleChanged
(
[
"
und
"
]
)
;
await
AddonManager
.
stageLangpacksForAppUpdate
(
"
60
"
)
;
await
promiseRestartManager
(
"
60
"
)
;
addon
=
await
promiseAddonByID
(
ID
)
;
Assert
.
ok
(
addon
.
isActive
)
;
Assert
.
equal
(
addon
.
version
"
60
.
1
.
20230309
.
91233
"
)
;
await
promiseRestartManager
(
"
60
.
1
"
)
;
await
AddonManager
.
stageLangpacksForAppUpdate
(
"
60
.
2
"
)
;
await
promiseRestartManager
(
"
60
.
2
"
)
;
addon
=
await
promiseAddonByID
(
ID
)
;
Assert
.
ok
(
addon
.
isActive
)
;
Assert
.
equal
(
addon
.
version
"
60
.
2
.
20230319
.
94511
"
)
;
await
addon
.
uninstall
(
)
;
await
promiseShutdownManager
(
)
;
Services
.
locale
.
requestedLocales
=
originalLocales
;
}
)
;
add_task
(
async
function
test_staged_langpack_for_app_update_fail
(
)
{
let
originalLocales
=
Services
.
locale
.
requestedLocales
;
await
promiseStartupManager
(
"
58
"
)
;
let
[
{
addon
}
]
=
await
Promise
.
all
(
[
promiseLangpackStartup
(
)
AddonTestUtils
.
promiseInstallXPI
(
ADDONS
.
langpack_1
)
]
)
;
Assert
.
ok
(
addon
.
isActive
)
;
await
promiseLocaleChanged
(
[
"
und
"
]
)
;
await
AddonManager
.
stageLangpacksForAppUpdate
(
"
60
"
)
;
await
promiseRestartManager
(
)
;
addon
=
await
promiseAddonByID
(
ID
)
;
Assert
.
ok
(
addon
.
isActive
)
;
Assert
.
equal
(
addon
.
version
"
58
.
0
.
20230105
.
121014
"
)
;
await
addon
.
uninstall
(
)
;
await
promiseShutdownManager
(
)
;
Services
.
locale
.
requestedLocales
=
originalLocales
;
}
)
;
add_task
(
async
function
test_staged_langpack_for_app_update_not_found
(
)
{
let
originalLocales
=
Services
.
locale
.
requestedLocales
;
await
promiseStartupManager
(
"
58
"
)
;
let
[
{
addon
}
]
=
await
Promise
.
all
(
[
promiseLangpackStartup
(
)
AddonTestUtils
.
promiseInstallXPI
(
ADDONS
.
langpack_1
)
]
)
;
Assert
.
ok
(
addon
.
isActive
)
;
await
promiseLocaleChanged
(
[
"
und
"
]
)
;
await
AddonManager
.
stageLangpacksForAppUpdate
(
"
59
"
)
;
await
promiseRestartManager
(
"
59
"
)
;
addon
=
await
promiseAddonByID
(
ID
)
;
Assert
.
ok
(
!
addon
.
isActive
)
;
Assert
.
equal
(
addon
.
version
"
58
.
0
.
20230105
.
121014
"
)
;
await
addon
.
uninstall
(
)
;
await
promiseShutdownManager
(
)
;
Services
.
locale
.
requestedLocales
=
originalLocales
;
}
)
;
add_task
(
async
function
test_staged_langpack_compat_startup
(
)
{
let
originalLocales
=
Services
.
locale
.
requestedLocales
;
await
promiseStartupManager
(
"
58
"
)
;
let
[
{
addon
}
]
=
await
Promise
.
all
(
[
promiseLangpackStartup
(
)
AddonTestUtils
.
promiseInstallXPI
(
ADDONS
.
langpack_1
)
]
)
;
Assert
.
ok
(
addon
.
isActive
)
;
await
promiseLocaleChanged
(
[
"
und
"
]
)
;
let
compatUpdate
=
{
targetApplications
:
[
{
id
:
"
toolkit
mozilla
.
org
"
minVersion
:
"
58
"
maxVersion
:
"
*
"
}
]
}
;
addon
.
__AddonInternal__
.
applyCompatibilityUpdate
(
compatUpdate
)
;
await
promiseRestartManager
(
"
59
"
)
;
addon
=
await
promiseAddonByID
(
ID
)
;
Assert
.
ok
(
!
addon
.
isActive
"
addon
is
not
active
after
upgrade
"
)
;
ok
(
!
addon
.
isCompatible
"
compatibility
update
fixed
"
)
;
await
promiseRestartManager
(
"
58
"
)
;
addon
=
await
promiseAddonByID
(
ID
)
;
Assert
.
ok
(
addon
.
isActive
"
addon
is
active
after
downgrade
"
)
;
ok
(
addon
.
isCompatible
"
compatibility
update
fixed
"
)
;
await
addon
.
uninstall
(
)
;
await
promiseShutdownManager
(
)
;
Services
.
locale
.
requestedLocales
=
originalLocales
;
}
)
;
