Services
.
prefs
.
setBoolPref
(
PREF_EM_CHECK_UPDATE_SECURITY
false
)
;
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
.
9
.
2
"
)
;
function
makeCancelListener
(
)
{
let
resolve
reject
;
let
promise
=
new
Promise
(
(
_resolve
_reject
)
=
>
{
resolve
=
_resolve
;
reject
=
_reject
;
}
)
;
return
{
onUpdateAvailable
(
addon
install
)
{
reject
(
"
Should
not
have
seen
onUpdateAvailable
notification
"
)
;
}
onUpdateFinished
(
aAddon
aError
)
{
info
(
"
onUpdateCheckFinished
:
"
+
aAddon
.
id
+
"
"
+
aError
)
;
resolve
(
aError
)
;
}
promise
}
;
}
let
testserver
=
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
]
}
)
;
let
_httpResolve
;
function
resetUpdateListener
(
)
{
return
new
Promise
(
resolve
=
>
{
_httpResolve
=
resolve
;
}
)
;
}
testserver
.
registerPathHandler
(
"
/
data
/
test_update
.
json
"
(
req
resp
)
=
>
{
resp
.
processAsync
(
)
;
_httpResolve
(
[
req
resp
]
)
;
}
)
;
const
UPDATE_RESPONSE
=
{
addons
:
{
"
addon1
tests
.
mozilla
.
org
"
:
{
updates
:
[
{
version
:
"
2
.
0
"
update_link
:
"
http
:
/
/
example
.
com
/
addons
/
test_update
.
xpi
"
applications
:
{
gecko
:
{
strict_min_version
:
"
1
"
strict_max_version
:
"
1
"
}
}
}
]
}
}
}
;
add_task
(
async
function
cancel_during_check
(
)
{
await
promiseStartupManager
(
)
;
await
promiseInstallWebExtension
(
{
manifest
:
{
name
:
"
Test
Addon
1
"
version
:
"
1
.
0
"
browser_specific_settings
:
{
gecko
:
{
id
:
"
addon1
tests
.
mozilla
.
org
"
update_url
:
"
http
:
/
/
example
.
com
/
data
/
test_update
.
json
"
}
}
}
}
)
;
let
a1
=
await
promiseAddonByID
(
"
addon1
tests
.
mozilla
.
org
"
)
;
Assert
.
notEqual
(
a1
null
)
;
let
requestPromise
=
resetUpdateListener
(
)
;
let
listener
=
makeCancelListener
(
)
;
a1
.
findUpdates
(
listener
AddonManager
.
UPDATE_WHEN_USER_REQUESTED
)
;
let
[
response
]
=
await
requestPromise
;
Assert
.
ok
(
a1
.
cancelUpdate
(
)
)
;
let
updateResult
=
await
listener
.
promise
;
Assert
.
equal
(
AddonManager
.
UPDATE_STATUS_CANCELLED
updateResult
)
;
response
.
write
(
JSON
.
stringify
(
UPDATE_RESPONSE
)
)
;
response
.
finish
(
)
;
Assert
.
ok
(
!
a1
.
cancelUpdate
(
)
)
;
}
)
;
add_task
(
async
function
shutdown_during_check
(
)
{
let
requestPromise
=
resetUpdateListener
(
)
;
let
a1
=
await
promiseAddonByID
(
"
addon1
tests
.
mozilla
.
org
"
)
;
Assert
.
notEqual
(
a1
null
)
;
let
listener
=
makeCancelListener
(
)
;
a1
.
findUpdates
(
listener
AddonManager
.
UPDATE_WHEN_USER_REQUESTED
)
;
let
[
response
]
=
await
requestPromise
;
await
promiseShutdownManager
(
)
;
let
updateResult
=
await
listener
.
promise
;
Assert
.
equal
(
AddonManager
.
UPDATE_STATUS_CANCELLED
updateResult
)
;
response
.
write
(
JSON
.
stringify
(
UPDATE_RESPONSE
)
)
;
response
.
finish
(
)
;
}
)
;
