ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
Services
.
prefs
.
setBoolPref
(
PREF_EM_CHECK_UPDATE_SECURITY
false
)
;
Services
.
prefs
.
setBoolPref
(
PREF_EM_STRICT_COMPATIBILITY
false
)
;
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
.
9
.
2
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
const
profileDir
=
gProfD
.
clone
(
)
;
profileDir
.
append
(
"
extensions
"
)
;
function
makeCancelListener
(
)
{
let
updated
=
PromiseUtils
.
defer
(
)
;
return
{
onUpdateAvailable
(
addon
install
)
{
updated
.
reject
(
"
Should
not
have
seen
onUpdateAvailable
notification
"
)
;
}
onUpdateFinished
(
aAddon
aError
)
{
info
(
"
onUpdateCheckFinished
:
"
+
aAddon
.
id
+
"
"
+
aError
)
;
updated
.
resolve
(
aError
)
;
}
promise
:
updated
.
promise
}
;
}
var
httpReceived
=
PromiseUtils
.
defer
(
)
;
function
dataHandler
(
aRequest
aResponse
)
{
aResponse
.
processAsync
(
)
;
httpReceived
.
resolve
(
[
aRequest
aResponse
]
)
;
}
var
testserver
=
new
HttpServer
(
)
;
testserver
.
registerPathHandler
(
"
/
data
/
test_update
.
json
"
dataHandler
)
;
testserver
.
start
(
-
1
)
;
gPort
=
testserver
.
identity
.
primaryPort
;
add_task
(
async
function
setup
(
)
{
await
promiseWriteInstallRDFForExtension
(
{
id
:
"
addon1
tests
.
mozilla
.
org
"
version
:
"
1
.
0
"
bootstrap
:
true
updateURL
:
"
http
:
/
/
localhost
:
"
+
gPort
+
"
/
data
/
test_update
.
json
"
targetApplications
:
[
{
id
:
"
xpcshell
tests
.
mozilla
.
org
"
minVersion
:
"
1
"
maxVersion
:
"
1
"
}
]
name
:
"
Test
Addon
1
"
}
profileDir
)
;
}
)
;
add_task
(
async
function
cancel_during_check
(
)
{
await
promiseStartupManager
(
)
;
let
a1
=
await
promiseAddonByID
(
"
addon1
tests
.
mozilla
.
org
"
)
;
Assert
.
notEqual
(
a1
null
)
;
let
listener
=
makeCancelListener
(
)
;
a1
.
findUpdates
(
listener
AddonManager
.
UPDATE_WHEN_USER_REQUESTED
)
;
let
[
response
]
=
await
httpReceived
.
promise
;
Assert
.
ok
(
a1
.
cancelUpdate
(
)
)
;
let
updateResult
=
await
listener
.
promise
;
Assert
.
equal
(
AddonManager
.
UPDATE_STATUS_CANCELLED
updateResult
)
;
let
file
=
do_get_cwd
(
)
;
file
.
append
(
"
data
"
)
;
file
.
append
(
"
test_update
.
json
"
)
;
let
data
=
new
TextDecoder
(
)
.
decode
(
await
OS
.
File
.
read
(
file
.
path
)
)
;
response
.
write
(
data
)
;
response
.
finish
(
)
;
Assert
.
ok
(
!
a1
.
cancelUpdate
(
)
)
;
await
true
;
}
)
;
add_task
(
async
function
shutdown_during_check
(
)
{
httpReceived
=
PromiseUtils
.
defer
(
)
;
let
a1
=
await
promiseAddonByID
(
"
addon1
tests
.
mozilla
.
org
"
)
;
Assert
.
notEqual
(
a1
null
)
;
let
listener
=
makeCancelListener
(
)
;
a1
.
findUpdates
(
listener
AddonManager
.
UPDATE_WHEN_USER_REQUESTED
)
;
let
[
response
]
=
await
httpReceived
.
promise
;
await
promiseShutdownManager
(
)
;
let
updateResult
=
await
listener
.
promise
;
Assert
.
equal
(
AddonManager
.
UPDATE_STATUS_CANCELLED
updateResult
)
;
let
file
=
do_get_cwd
(
)
;
file
.
append
(
"
data
"
)
;
file
.
append
(
"
test_update
.
json
"
)
;
let
data
=
await
loadFile
(
file
.
path
)
;
response
.
write
(
data
)
;
response
.
finish
(
)
;
await
testserver
.
stop
(
)
;
}
)
;
