"
use
strict
"
;
const
{
AMBrowserExtensionsImport
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
sys
.
mjs
"
)
;
const
mockAddonRepository
=
(
{
addons
=
[
]
expectedBrowserID
=
null
expectedExtensionIDs
=
null
}
)
=
>
{
return
{
async
getMappedAddons
(
browserID
extensionIDs
)
{
if
(
expectedBrowserID
)
{
Assert
.
equal
(
browserID
expectedBrowserID
"
expected
browser
ID
"
)
;
}
if
(
expectedExtensionIDs
)
{
Assert
.
deepEqual
(
extensionIDs
expectedExtensionIDs
"
expected
extension
IDs
"
)
;
}
return
Promise
.
resolve
(
addons
)
;
}
}
;
}
;
const
assertStageInstallsResult
=
(
result
importedAddonIDs
)
=
>
{
result
.
importedAddonIDs
.
sort
(
)
;
Assert
.
deepEqual
(
result
{
importedAddonIDs
}
"
expected
results
"
)
;
Assert
.
ok
(
AMBrowserExtensionsImport
.
hasPendingImportedAddons
"
expected
pending
imported
add
-
ons
"
)
;
}
;
const
cancelInstalls
=
async
importedAddonIDs
=
>
{
const
promiseTopic
=
TestUtils
.
topicObserved
(
"
webextension
-
imported
-
addons
-
cancelled
"
)
;
const
cancelledPromises
=
importedAddonIDs
.
map
(
id
=
>
AddonTestUtils
.
promiseInstallEvent
(
"
onInstallCancelled
"
(
install
cancelledByUser
)
=
>
{
Assert
.
equal
(
cancelledByUser
false
"
Not
user
-
cancelled
"
)
;
return
install
.
addon
.
id
=
=
id
;
}
)
)
;
await
AMBrowserExtensionsImport
.
cancelInstalls
(
)
;
await
Promise
.
all
(
[
promiseTopic
.
.
.
cancelledPromises
]
)
;
Assert
.
ok
(
!
AMBrowserExtensionsImport
.
hasPendingImportedAddons
"
expected
no
pending
imported
add
-
ons
"
)
;
}
;
const
TEST_SERVER
=
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
]
}
)
;
const
ADDONS
=
{
ext1
:
{
manifest
:
{
name
:
"
Ext
1
"
version
:
"
1
.
0
"
browser_specific_settings
:
{
gecko
:
{
id
:
"
ff
ext
-
1
"
}
}
}
}
ext2
:
{
manifest
:
{
name
:
"
Ext
2
"
version
:
"
1
.
0
"
browser_specific_settings
:
{
gecko
:
{
id
:
"
ff
ext
-
2
"
}
}
}
}
}
;
const
XPIS
=
{
}
;
const
ADDON_SEARCH_RESULTS
=
{
}
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
42
"
"
42
"
)
;
add_setup
(
async
function
setup
(
)
{
for
(
const
[
name
data
]
of
Object
.
entries
(
ADDONS
)
)
{
XPIS
[
name
]
=
AddonTestUtils
.
createTempWebExtensionFile
(
data
)
;
TEST_SERVER
.
registerFile
(
/
addons
/
{
name
}
.
xpi
XPIS
[
name
]
)
;
ADDON_SEARCH_RESULTS
[
name
]
=
{
id
:
data
.
manifest
.
browser_specific_settings
.
gecko
.
id
name
:
data
.
name
version
:
data
.
version
sourceURI
:
Services
.
io
.
newURI
(
http
:
/
/
example
.
com
/
addons
/
{
name
}
.
xpi
)
icons
:
{
}
}
;
}
await
AddonTestUtils
.
promiseStartupManager
(
)
;
registerCleanupFunction
(
(
)
=
>
{
const
profileDir
=
do_get_profile
(
)
;
const
stagingDir
=
profileDir
.
clone
(
)
;
stagingDir
.
append
(
"
extensions
"
)
;
stagingDir
.
append
(
"
staged
"
)
;
stagingDir
.
exists
(
)
&
&
stagingDir
.
remove
(
false
)
;
AMBrowserExtensionsImport
.
_addonRepository
=
null
;
}
)
;
}
)
;
add_task
(
async
function
test_stage_and_complete_installs
(
)
{
const
browserID
=
"
some
-
browser
-
id
"
;
const
extensionIDs
=
[
"
ext
-
1
"
"
ext
-
2
"
]
;
AMBrowserExtensionsImport
.
_addonRepository
=
mockAddonRepository
(
{
addons
:
Object
.
values
(
ADDON_SEARCH_RESULTS
)
expectedBrowserID
:
browserID
expectedExtensionIDs
:
extensionIDs
}
)
;
const
importedAddonIDs
=
[
"
ff
ext
-
1
"
"
ff
ext
-
2
"
]
;
let
promiseTopic
=
TestUtils
.
topicObserved
(
"
webextension
-
imported
-
addons
-
pending
"
)
;
const
result
=
await
AMBrowserExtensionsImport
.
stageInstalls
(
browserID
extensionIDs
)
;
await
promiseTopic
;
assertStageInstallsResult
(
result
importedAddonIDs
)
;
for
(
const
install
of
AMBrowserExtensionsImport
.
_pendingInstallsMap
.
values
(
)
)
{
Assert
.
equal
(
install
.
promptHandler
AMBrowserExtensionsImport
.
_installPromptHandler
"
expected
prompt
handler
to
be
the
one
set
by
AMBrowserExtensionsImport
"
)
;
}
promiseTopic
=
TestUtils
.
topicObserved
(
"
webextension
-
imported
-
addons
-
complete
"
)
;
const
endedPromises
=
importedAddonIDs
.
map
(
id
=
>
AddonTestUtils
.
promiseInstallEvent
(
"
onInstallEnded
"
install
=
>
install
.
addon
.
id
=
=
id
)
)
;
await
AMBrowserExtensionsImport
.
completeInstalls
(
)
;
await
Promise
.
all
(
[
promiseTopic
.
.
.
endedPromises
]
)
;
Assert
.
ok
(
!
AMBrowserExtensionsImport
.
hasPendingImportedAddons
"
expected
no
pending
imported
add
-
ons
"
)
;
Assert
.
ok
(
!
AMBrowserExtensionsImport
.
_canCompleteOrCancelInstalls
&
&
!
AMBrowserExtensionsImport
.
_importInProgress
"
expected
internal
state
to
be
consistent
"
)
;
for
(
const
id
of
importedAddonIDs
)
{
const
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
Assert
.
ok
(
addon
.
isActive
expected
add
-
on
"
{
id
}
"
to
be
enabled
)
;
await
addon
.
uninstall
(
)
;
}
}
)
;
add_task
(
async
function
test_stage_and_cancel_installs
(
)
{
const
browserID
=
"
some
-
browser
-
id
"
;
const
extensionIDs
=
[
"
ext
-
1
"
"
ext
-
2
"
]
;
AMBrowserExtensionsImport
.
_addonRepository
=
mockAddonRepository
(
{
addons
:
Object
.
values
(
ADDON_SEARCH_RESULTS
)
expectedBrowserID
:
browserID
expectedExtensionIDs
:
extensionIDs
}
)
;
const
importedAddonIDs
=
[
"
ff
ext
-
1
"
"
ff
ext
-
2
"
]
;
const
promiseTopic
=
TestUtils
.
topicObserved
(
"
webextension
-
imported
-
addons
-
pending
"
)
;
const
result
=
await
AMBrowserExtensionsImport
.
stageInstalls
(
browserID
extensionIDs
)
;
await
promiseTopic
;
assertStageInstallsResult
(
result
importedAddonIDs
)
;
await
cancelInstalls
(
importedAddonIDs
)
;
}
)
;
add_task
(
async
function
test_call_stageInstalls_twice
(
)
{
const
browserID
=
"
some
-
browser
-
id
"
;
const
extensionIDs
=
[
"
ext
-
1
"
]
;
AMBrowserExtensionsImport
.
_addonRepository
=
mockAddonRepository
(
{
addons
:
Object
.
values
(
ADDON_SEARCH_RESULTS
)
.
slice
(
0
1
)
expectedBrowserID
:
browserID
expectedExtensionIDs
:
extensionIDs
}
)
;
const
importedAddonIDs
=
[
"
ff
ext
-
1
"
]
;
const
promiseTopic
=
TestUtils
.
topicObserved
(
"
webextension
-
imported
-
addons
-
pending
"
)
;
let
result
=
await
AMBrowserExtensionsImport
.
stageInstalls
(
browserID
extensionIDs
)
;
await
promiseTopic
;
assertStageInstallsResult
(
result
importedAddonIDs
)
;
await
Assert
.
rejects
(
AMBrowserExtensionsImport
.
stageInstalls
(
browserID
[
]
)
/
Cannot
stage
installs
because
there
are
pending
imported
add
-
ons
/
"
expected
rejection
because
there
are
pending
imported
add
-
ons
"
)
;
await
cancelInstalls
(
importedAddonIDs
)
;
result
=
await
AMBrowserExtensionsImport
.
stageInstalls
(
browserID
extensionIDs
)
;
assertStageInstallsResult
(
result
importedAddonIDs
)
;
await
cancelInstalls
(
importedAddonIDs
)
;
}
)
;
add_task
(
async
function
test_call_stageInstalls_no_addons
(
)
{
const
browserID
=
"
some
-
browser
-
id
"
;
const
extensionIDs
=
[
"
ext
-
123456
"
]
;
AMBrowserExtensionsImport
.
_addonRepository
=
mockAddonRepository
(
{
addons
:
[
]
expectedBrowserID
:
browserID
expectedExtensionIDs
:
extensionIDs
}
)
;
const
result
=
await
AMBrowserExtensionsImport
.
stageInstalls
(
browserID
extensionIDs
)
;
Assert
.
deepEqual
(
result
{
importedAddonIDs
:
[
]
}
"
expected
result
"
)
;
Assert
.
ok
(
!
AMBrowserExtensionsImport
.
hasPendingImportedAddons
"
expected
no
pending
imported
add
-
ons
"
)
;
Assert
.
ok
(
!
AMBrowserExtensionsImport
.
_canCompleteOrCancelInstalls
&
&
!
AMBrowserExtensionsImport
.
_importInProgress
"
expected
internal
state
to
be
consistent
"
)
;
}
)
;
add_task
(
async
function
test_import_twice
(
)
{
const
browserID
=
"
some
-
browser
-
id
"
;
const
extensionIDs
=
[
"
ext
-
1
"
"
ext
-
2
"
]
;
AMBrowserExtensionsImport
.
_addonRepository
=
mockAddonRepository
(
{
addons
:
Object
.
values
(
ADDON_SEARCH_RESULTS
)
expectedBrowserID
:
browserID
expectedExtensionIDs
:
extensionIDs
}
)
;
const
importedAddonIDs
=
[
"
ff
ext
-
1
"
"
ff
ext
-
2
"
]
;
let
promiseTopic
=
TestUtils
.
topicObserved
(
"
webextension
-
imported
-
addons
-
pending
"
)
;
let
result
=
await
AMBrowserExtensionsImport
.
stageInstalls
(
browserID
extensionIDs
)
;
await
promiseTopic
;
assertStageInstallsResult
(
result
importedAddonIDs
)
;
promiseTopic
=
TestUtils
.
topicObserved
(
"
webextension
-
imported
-
addons
-
complete
"
)
;
const
endedPromises
=
importedAddonIDs
.
map
(
id
=
>
AddonTestUtils
.
promiseInstallEvent
(
"
onInstallEnded
"
install
=
>
install
.
addon
.
id
=
=
id
)
)
;
await
AMBrowserExtensionsImport
.
completeInstalls
(
)
;
await
Promise
.
all
(
[
promiseTopic
.
.
.
endedPromises
]
)
;
result
=
await
AMBrowserExtensionsImport
.
stageInstalls
(
browserID
extensionIDs
)
;
Assert
.
deepEqual
(
result
{
importedAddonIDs
:
[
]
}
"
expected
result
"
)
;
Assert
.
ok
(
!
AMBrowserExtensionsImport
.
hasPendingImportedAddons
"
expected
no
pending
imported
add
-
ons
"
)
;
Assert
.
ok
(
!
AMBrowserExtensionsImport
.
_canCompleteOrCancelInstalls
&
&
!
AMBrowserExtensionsImport
.
_importInProgress
"
expected
internal
state
to
be
consistent
"
)
;
for
(
const
id
of
importedAddonIDs
)
{
const
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
Assert
.
ok
(
addon
.
isActive
expected
add
-
on
"
{
id
}
"
to
be
enabled
)
;
await
addon
.
uninstall
(
)
;
}
}
)
;
add_task
(
async
function
test_call_cancelInstalls_without_pending_import
(
)
{
await
Assert
.
rejects
(
AMBrowserExtensionsImport
.
cancelInstalls
(
)
/
No
import
in
progress
/
"
expected
an
error
"
)
;
}
)
;
add_task
(
async
function
test_call_completeInstalls_without_pending_import
(
)
{
await
Assert
.
rejects
(
AMBrowserExtensionsImport
.
completeInstalls
(
)
/
No
import
in
progress
/
"
expected
an
error
"
)
;
}
)
;
add_task
(
async
function
test_stage_installs_with_download_aborted
(
)
{
const
browserID
=
"
some
-
browser
-
id
"
;
const
extensionIDs
=
[
"
ext
-
1
"
"
ext
-
2
"
]
;
AMBrowserExtensionsImport
.
_addonRepository
=
mockAddonRepository
(
{
addons
:
Object
.
values
(
ADDON_SEARCH_RESULTS
)
expectedBrowserID
:
browserID
expectedExtensionIDs
:
extensionIDs
}
)
;
const
importedAddonIDs
=
[
"
ff
ext
-
2
"
]
;
const
onNewInstall
=
AddonTestUtils
.
promiseInstallEvent
(
"
onNewInstall
"
install
=
>
{
install
.
addListener
(
{
onDownloadStarted
:
(
)
=
>
false
}
)
;
return
true
;
}
)
;
const
promiseTopic
=
TestUtils
.
topicObserved
(
"
webextension
-
imported
-
addons
-
pending
"
)
;
const
result
=
await
AMBrowserExtensionsImport
.
stageInstalls
(
browserID
extensionIDs
)
;
await
Promise
.
all
(
[
onNewInstall
promiseTopic
]
)
;
assertStageInstallsResult
(
result
importedAddonIDs
)
;
Assert
.
ok
(
AMBrowserExtensionsImport
.
hasPendingImportedAddons
"
expected
pending
imported
add
-
ons
"
)
;
Assert
.
ok
(
AMBrowserExtensionsImport
.
_canCompleteOrCancelInstalls
&
&
AMBrowserExtensionsImport
.
_importInProgress
"
expected
internal
state
to
be
consistent
"
)
;
await
cancelInstalls
(
importedAddonIDs
)
;
}
)
;
add_task
(
async
function
test_stageInstalls_then_restart_addonManager
(
)
{
const
browserID
=
"
some
-
browser
-
id
"
;
const
extensionIDs
=
[
"
ext
-
1
"
"
ext
-
2
"
]
;
const
EXPECTED_SOURCE_URI_SPECS
=
{
[
"
ff
ext
-
1
"
]
:
"
http
:
/
/
example
.
com
/
addons
/
ext1
.
xpi
"
[
"
ff
ext
-
2
"
]
:
"
http
:
/
/
example
.
com
/
addons
/
ext2
.
xpi
"
}
;
AMBrowserExtensionsImport
.
_addonRepository
=
mockAddonRepository
(
{
addons
:
Object
.
values
(
ADDON_SEARCH_RESULTS
)
expectedBrowserID
:
browserID
expectedExtensionIDs
:
extensionIDs
}
)
;
const
importedAddonIDs
=
[
"
ff
ext
-
1
"
"
ff
ext
-
2
"
]
;
let
promiseTopic
=
TestUtils
.
topicObserved
(
"
webextension
-
imported
-
addons
-
pending
"
)
;
let
result
=
await
AMBrowserExtensionsImport
.
stageInstalls
(
browserID
extensionIDs
)
;
await
promiseTopic
;
assertStageInstallsResult
(
result
importedAddonIDs
)
;
await
AddonTestUtils
.
promiseRestartManager
(
)
;
for
(
const
id
of
importedAddonIDs
)
{
const
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
Assert
.
ok
(
addon
.
isActive
expected
add
-
on
"
{
id
}
"
to
be
enabled
)
;
Assert
.
deepEqual
(
{
id
:
addon
.
id
sourceURI
:
addon
.
sourceURI
?
.
spec
installTelemetryInfo
:
addon
.
installTelemetryInfo
}
{
id
sourceURI
:
EXPECTED_SOURCE_URI_SPECS
[
id
]
installTelemetryInfo
:
{
source
:
AMBrowserExtensionsImport
.
TELEMETRY_SOURCE
}
}
"
Got
the
expected
AddonWrapper
properties
"
)
;
await
addon
.
uninstall
(
)
;
}
}
)
;
