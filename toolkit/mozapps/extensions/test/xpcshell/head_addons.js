var
AM_Cc
=
Components
.
classes
;
var
AM_Ci
=
Components
.
interfaces
;
var
AM_Cu
=
Components
.
utils
;
AM_Cu
.
importGlobalProperties
(
[
"
TextEncoder
"
]
)
;
const
CERTDB_CONTRACTID
=
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
;
const
CERTDB_CID
=
Components
.
ID
(
"
{
fb0bbc5c
-
452e
-
4783
-
b32c
-
80124693d871
}
"
)
;
const
PREF_EM_CHECK_UPDATE_SECURITY
=
"
extensions
.
checkUpdateSecurity
"
;
const
PREF_EM_STRICT_COMPATIBILITY
=
"
extensions
.
strictCompatibility
"
;
const
PREF_EM_MIN_COMPAT_APP_VERSION
=
"
extensions
.
minCompatibleAppVersion
"
;
const
PREF_EM_MIN_COMPAT_PLATFORM_VERSION
=
"
extensions
.
minCompatiblePlatformVersion
"
;
const
PREF_GETADDONS_BYIDS
=
"
extensions
.
getAddons
.
get
.
url
"
;
const
PREF_GETADDONS_BYIDS_PERFORMANCE
=
"
extensions
.
getAddons
.
getWithPerformance
.
url
"
;
const
PREF_XPI_SIGNATURES_REQUIRED
=
"
xpinstall
.
signatures
.
required
"
;
const
PREF_SYSTEM_ADDON_SET
=
"
extensions
.
systemAddonSet
"
;
const
PREF_SYSTEM_ADDON_UPDATE_URL
=
"
extensions
.
systemAddon
.
update
.
url
"
;
const
PREF_APP_UPDATE_ENABLED
=
"
app
.
update
.
enabled
"
;
const
PREF_ALLOW_NON_MPC
=
"
extensions
.
allow
-
non
-
mpc
-
extensions
"
;
const
PREF_DISABLE_SECURITY
=
(
"
security
.
turn_off_all_security_so_that_
"
+
"
viruses_can_take_over_this_computer
"
)
;
const
TIMEOUT_MS
=
900000
;
const
MAX_TIME_DIFFERENCE
=
3000
;
const
MAKE_FILE_OLD_DIFFERENCE
=
10
*
3600
*
1000
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonRepository
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
{
OS
}
=
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
{
}
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Extension
"
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionTestUtils
"
"
resource
:
/
/
testing
-
common
/
ExtensionXPCShellUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionTestCommon
"
"
resource
:
/
/
testing
-
common
/
ExtensionTestCommon
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
HttpServer
"
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MockAsyncShutdown
"
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MockRegistrar
"
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MockRegistry
"
"
resource
:
/
/
testing
-
common
/
MockRegistry
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
aomStartup
"
"
mozilla
.
org
/
addons
/
addon
-
manager
-
startup
;
1
"
"
amIAddonManagerStartup
"
)
;
const
{
awaitPromise
createAppInfo
createInstallRDF
createTempWebExtensionFile
createUpdateRDF
getFileForAddon
manuallyUninstall
overrideBuiltIns
promiseAddonEvent
promiseCompleteAllInstalls
promiseCompleteInstall
promiseConsoleOutput
promiseFindAddonUpdates
promiseInstallAllFiles
promiseInstallFile
promiseRestartManager
promiseSetExtensionModifiedTime
promiseShutdownManager
promiseStartupManager
promiseWebExtensionStartup
promiseWriteProxyFileToDir
registerDirectory
setExtensionModifiedTime
writeFilesToZip
}
=
AddonTestUtils
;
function
manuallyInstall
(
.
.
.
args
)
{
return
AddonTestUtils
.
awaitPromise
(
AddonTestUtils
.
manuallyInstall
(
.
.
.
args
)
)
;
}
ExtensionTestUtils
.
init
(
this
)
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
Object
.
defineProperty
(
this
"
gAppInfo
"
{
get
(
)
{
return
AddonTestUtils
.
appInfo
;
}
}
)
;
Object
.
defineProperty
(
this
"
gAddonStartup
"
{
get
(
)
{
return
AddonTestUtils
.
addonStartup
.
clone
(
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gInternalManager
"
{
get
(
)
{
return
AddonTestUtils
.
addonIntegrationService
.
QueryInterface
(
AM_Ci
.
nsITimerCallback
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gProfD
"
{
get
(
)
{
return
AddonTestUtils
.
profileDir
.
clone
(
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gTmpD
"
{
get
(
)
{
return
AddonTestUtils
.
tempDir
.
clone
(
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gUseRealCertChecks
"
{
get
(
)
{
return
AddonTestUtils
.
useRealCertChecks
;
}
set
(
val
)
{
return
AddonTestUtils
.
useRealCertChecks
=
val
;
}
}
)
;
Object
.
defineProperty
(
this
"
TEST_UNPACKED
"
{
get
(
)
{
return
AddonTestUtils
.
testUnpacked
;
}
set
(
val
)
{
return
AddonTestUtils
.
testUnpacked
=
val
;
}
}
)
;
var
AMscope
=
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
{
}
)
;
var
{
AddonManager
AddonManagerInternal
AddonManagerPrivate
}
=
AMscope
;
const
promiseAddonByID
=
AddonManager
.
getAddonByID
;
const
promiseAddonsByIDs
=
AddonManager
.
getAddonsByIDs
;
const
promiseAddonsWithOperationsByTypes
=
AddonManager
.
getAddonsWithOperationsByTypes
;
let
gStartup
=
null
;
var
gPort
=
null
;
var
gUrlToFileMap
=
{
}
;
var
resHandler
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
AM_Ci
.
nsISubstitutingProtocolHandler
)
;
var
dataURI
=
NetUtil
.
newURI
(
do_get_file
(
"
data
"
true
)
)
;
resHandler
.
setSubstitution
(
"
xpcshell
-
data
"
dataURI
)
;
function
isManifestRegistered
(
file
)
{
let
manifests
=
Components
.
manager
.
getManifestLocations
(
)
;
for
(
let
i
=
0
;
i
<
manifests
.
length
;
i
+
+
)
{
let
manifest
=
manifests
.
queryElementAt
(
i
AM_Ci
.
nsIURI
)
;
if
(
manifest
instanceof
AM_Ci
.
nsIJARURI
)
{
manifest
=
manifest
.
JARFile
.
QueryInterface
(
AM_Ci
.
nsIFileURL
)
.
file
;
}
else
if
(
manifest
instanceof
AM_Ci
.
nsIFileURL
)
{
manifest
=
manifest
.
file
.
parent
;
}
else
{
continue
;
}
if
(
manifest
.
equals
(
file
)
)
return
true
;
}
return
false
;
}
this
.
BootstrapMonitor
=
{
inited
:
false
installed
:
new
Map
(
)
started
:
new
Map
(
)
stopped
:
new
Map
(
)
uninstalled
:
new
Map
(
)
startupPromises
:
[
]
installPromises
:
[
]
restartfulIds
:
new
Set
(
)
init
(
)
{
this
.
inited
=
true
;
Services
.
obs
.
addObserver
(
this
"
bootstrapmonitor
-
event
"
)
;
}
shutdownCheck
(
)
{
if
(
!
this
.
inited
)
return
;
do_check_eq
(
this
.
started
.
size
0
)
;
}
clear
(
id
)
{
this
.
installed
.
delete
(
id
)
;
this
.
started
.
delete
(
id
)
;
this
.
stopped
.
delete
(
id
)
;
this
.
uninstalled
.
delete
(
id
)
;
}
promiseAddonStartup
(
id
)
{
return
new
Promise
(
resolve
=
>
{
this
.
startupPromises
.
push
(
resolve
)
;
}
)
;
}
promiseAddonInstall
(
id
)
{
return
new
Promise
(
resolve
=
>
{
this
.
installPromises
.
push
(
resolve
)
;
}
)
;
}
checkMatches
(
cached
current
)
{
do_check_neq
(
cached
undefined
)
;
do_check_eq
(
current
.
data
.
version
cached
.
data
.
version
)
;
do_check_eq
(
current
.
data
.
installPath
cached
.
data
.
installPath
)
;
do_check_eq
(
current
.
data
.
resourceURI
cached
.
data
.
resourceURI
)
;
}
checkAddonStarted
(
id
version
=
undefined
)
{
let
started
=
this
.
started
.
get
(
id
)
;
do_check_neq
(
started
undefined
)
;
if
(
version
!
=
undefined
)
do_check_eq
(
started
.
data
.
version
version
)
;
let
installPath
=
new
FileUtils
.
File
(
started
.
data
.
installPath
)
;
let
isRegistered
=
isManifestRegistered
(
installPath
)
;
do_check_true
(
isRegistered
)
;
}
checkAddonNotStarted
(
id
)
{
do_check_false
(
this
.
started
.
has
(
id
)
)
;
}
checkAddonInstalled
(
id
version
=
undefined
)
{
const
installed
=
this
.
installed
.
get
(
id
)
;
notEqual
(
installed
undefined
)
;
if
(
version
!
=
=
undefined
)
{
equal
(
installed
.
data
.
version
version
)
;
}
return
installed
;
}
checkAddonNotInstalled
(
id
)
{
do_check_false
(
this
.
installed
.
has
(
id
)
)
;
}
observe
(
subject
topic
data
)
{
let
info
=
JSON
.
parse
(
data
)
;
let
id
=
info
.
data
.
id
;
let
installPath
=
new
FileUtils
.
File
(
info
.
data
.
installPath
)
;
if
(
subject
&
&
subject
.
wrappedJSObject
)
{
info
.
data
=
Object
.
assign
(
{
}
subject
.
wrappedJSObject
.
data
{
installPath
:
info
.
data
.
installPath
resourceURI
:
info
.
data
.
resourceURI
}
)
;
}
if
(
info
.
event
=
=
"
install
"
)
{
this
.
checkAddonNotInstalled
(
id
)
;
this
.
installed
.
set
(
id
info
)
;
for
(
let
resolve
of
this
.
installPromises
)
resolve
(
)
;
this
.
installPromises
=
[
]
;
}
else
{
this
.
checkMatches
(
this
.
installed
.
get
(
id
)
info
)
;
}
if
(
info
.
event
=
=
"
shutdown
"
)
{
this
.
checkMatches
(
this
.
started
.
get
(
id
)
info
)
;
this
.
started
.
delete
(
id
)
;
this
.
stopped
.
set
(
id
info
)
;
let
isRegistered
=
isManifestRegistered
(
installPath
)
;
do_check_true
(
isRegistered
)
;
if
(
info
.
reason
=
=
2
)
Components
.
manager
.
removeBootstrappedManifestLocation
(
installPath
)
;
}
else
{
this
.
checkAddonNotStarted
(
id
)
;
}
if
(
info
.
event
=
=
"
uninstall
"
)
{
if
(
!
this
.
restartfulIds
.
has
(
id
)
)
{
let
isRegistered
=
isManifestRegistered
(
installPath
)
;
do_check_false
(
isRegistered
)
;
}
this
.
installed
.
delete
(
id
)
;
this
.
uninstalled
.
set
(
id
info
)
}
else
if
(
info
.
event
=
=
"
startup
"
)
{
this
.
started
.
set
(
id
info
)
;
let
isRegistered
=
isManifestRegistered
(
installPath
)
;
do_check_true
(
isRegistered
)
;
for
(
let
resolve
of
this
.
startupPromises
)
resolve
(
)
;
this
.
startupPromises
=
[
]
;
}
}
}
AddonTestUtils
.
on
(
"
addon
-
manager
-
shutdown
"
(
)
=
>
BootstrapMonitor
.
shutdownCheck
(
)
)
;
function
isNightlyChannel
(
)
{
var
channel
=
Services
.
prefs
.
getCharPref
(
"
app
.
update
.
channel
"
"
default
"
)
;
return
channel
!
=
"
aurora
"
&
&
channel
!
=
"
beta
"
&
&
channel
!
=
"
release
"
&
&
channel
!
=
"
esr
"
;
}
function
do_check_in_crash_annotation
(
aId
aVersion
)
{
if
(
!
(
"
nsICrashReporter
"
in
AM_Ci
)
)
return
;
if
(
!
(
"
Add
-
ons
"
in
gAppInfo
.
annotations
)
)
{
do_check_false
(
true
)
;
return
;
}
let
addons
=
gAppInfo
.
annotations
[
"
Add
-
ons
"
]
.
split
(
"
"
)
;
do_check_true
(
addons
.
includes
(
{
encodeURIComponent
(
aId
)
}
:
{
encodeURIComponent
(
aVersion
)
}
)
)
;
}
function
do_check_not_in_crash_annotation
(
aId
aVersion
)
{
if
(
!
(
"
nsICrashReporter
"
in
AM_Ci
)
)
return
;
if
(
!
(
"
Add
-
ons
"
in
gAppInfo
.
annotations
)
)
{
do_check_true
(
true
)
;
return
;
}
let
addons
=
gAppInfo
.
annotations
[
"
Add
-
ons
"
]
.
split
(
"
"
)
;
do_check_false
(
addons
.
includes
(
{
encodeURIComponent
(
aId
)
}
:
{
encodeURIComponent
(
aVersion
)
}
)
)
;
}
function
do_get_addon
(
aName
)
{
return
do_get_file
(
"
addons
/
"
+
aName
+
"
.
xpi
"
)
;
}
function
do_get_addon_hash
(
aName
aAlgorithm
)
{
let
file
=
do_get_addon
(
aName
)
;
return
do_get_file_hash
(
file
)
;
}
function
do_get_file_hash
(
aFile
aAlgorithm
)
{
if
(
!
aAlgorithm
)
aAlgorithm
=
"
sha1
"
;
let
crypto
=
AM_Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
AM_Ci
.
nsICryptoHash
)
;
crypto
.
initWithString
(
aAlgorithm
)
;
let
fis
=
AM_Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
AM_Ci
.
nsIFileInputStream
)
;
fis
.
init
(
aFile
-
1
-
1
false
)
;
crypto
.
updateFromStream
(
fis
aFile
.
fileSize
)
;
let
toHexString
=
charCode
=
>
(
"
0
"
+
charCode
.
toString
(
16
)
)
.
slice
(
-
2
)
;
let
binary
=
crypto
.
finish
(
false
)
;
let
hash
=
Array
.
from
(
binary
c
=
>
toHexString
(
c
.
charCodeAt
(
0
)
)
)
;
return
aAlgorithm
+
"
:
"
+
hash
.
join
(
"
"
)
;
}
function
do_get_addon_root_uri
(
aProfileDir
aId
)
{
let
path
=
aProfileDir
.
clone
(
)
;
path
.
append
(
aId
)
;
if
(
!
path
.
exists
(
)
)
{
path
.
leafName
+
=
"
.
xpi
"
;
return
"
jar
:
"
+
Services
.
io
.
newFileURI
(
path
)
.
spec
+
"
!
/
"
;
}
return
Services
.
io
.
newFileURI
(
path
)
.
spec
;
}
function
do_get_expected_addon_name
(
aId
)
{
if
(
TEST_UNPACKED
)
return
aId
;
return
aId
+
"
.
xpi
"
;
}
function
do_check_addons
(
aActualAddons
aExpectedAddons
aProperties
)
{
do_check_neq
(
aActualAddons
null
)
;
do_check_eq
(
aActualAddons
.
length
aExpectedAddons
.
length
)
;
for
(
let
i
=
0
;
i
<
aActualAddons
.
length
;
i
+
+
)
do_check_addon
(
aActualAddons
[
i
]
aExpectedAddons
[
i
]
aProperties
)
;
}
function
do_check_addon
(
aActualAddon
aExpectedAddon
aProperties
)
{
do_check_neq
(
aActualAddon
null
)
;
aProperties
.
forEach
(
function
(
aProperty
)
{
let
actualValue
=
aActualAddon
[
aProperty
]
;
let
expectedValue
=
aExpectedAddon
[
aProperty
]
;
if
(
!
(
aProperty
in
aExpectedAddon
)
)
{
if
(
actualValue
!
=
=
undefined
&
&
actualValue
!
=
=
null
)
{
do_throw
(
"
Unexpected
defined
/
non
-
null
property
for
add
-
on
"
+
aExpectedAddon
.
id
+
"
(
addon
[
"
+
aProperty
+
"
]
=
"
+
actualValue
.
toSource
(
)
+
"
)
"
)
;
}
return
;
}
else
if
(
expectedValue
&
&
!
actualValue
)
{
do_throw
(
"
Missing
property
for
add
-
on
"
+
aExpectedAddon
.
id
+
"
:
expected
addon
[
"
+
aProperty
+
"
]
=
"
+
expectedValue
)
;
return
;
}
switch
(
aProperty
)
{
case
"
creator
"
:
do_check_author
(
actualValue
expectedValue
)
;
break
;
case
"
developers
"
:
case
"
translators
"
:
case
"
contributors
"
:
do_check_eq
(
actualValue
.
length
expectedValue
.
length
)
;
for
(
let
i
=
0
;
i
<
actualValue
.
length
;
i
+
+
)
do_check_author
(
actualValue
[
i
]
expectedValue
[
i
]
)
;
break
;
case
"
screenshots
"
:
do_check_eq
(
actualValue
.
length
expectedValue
.
length
)
;
for
(
let
i
=
0
;
i
<
actualValue
.
length
;
i
+
+
)
do_check_screenshot
(
actualValue
[
i
]
expectedValue
[
i
]
)
;
break
;
case
"
sourceURI
"
:
do_check_eq
(
actualValue
.
spec
expectedValue
)
;
break
;
case
"
updateDate
"
:
do_check_eq
(
actualValue
.
getTime
(
)
expectedValue
.
getTime
(
)
)
;
break
;
case
"
compatibilityOverrides
"
:
do_check_eq
(
actualValue
.
length
expectedValue
.
length
)
;
for
(
let
i
=
0
;
i
<
actualValue
.
length
;
i
+
+
)
do_check_compatibilityoverride
(
actualValue
[
i
]
expectedValue
[
i
]
)
;
break
;
case
"
icons
"
:
do_check_icons
(
actualValue
expectedValue
)
;
break
;
default
:
if
(
remove_port
(
actualValue
)
!
=
=
remove_port
(
expectedValue
)
)
do_throw
(
"
Failed
for
"
+
aProperty
+
"
for
add
-
on
"
+
aExpectedAddon
.
id
+
"
(
"
+
actualValue
+
"
=
=
=
"
+
expectedValue
+
"
)
"
)
;
}
}
)
;
}
function
do_check_author
(
aActual
aExpected
)
{
do_check_eq
(
aActual
.
toString
(
)
aExpected
.
name
)
;
do_check_eq
(
aActual
.
name
aExpected
.
name
)
;
do_check_eq
(
aActual
.
url
aExpected
.
url
)
;
}
function
do_check_screenshot
(
aActual
aExpected
)
{
do_check_eq
(
aActual
.
toString
(
)
aExpected
.
url
)
;
do_check_eq
(
aActual
.
url
aExpected
.
url
)
;
do_check_eq
(
aActual
.
width
aExpected
.
width
)
;
do_check_eq
(
aActual
.
height
aExpected
.
height
)
;
do_check_eq
(
aActual
.
thumbnailURL
aExpected
.
thumbnailURL
)
;
do_check_eq
(
aActual
.
thumbnailWidth
aExpected
.
thumbnailWidth
)
;
do_check_eq
(
aActual
.
thumbnailHeight
aExpected
.
thumbnailHeight
)
;
do_check_eq
(
aActual
.
caption
aExpected
.
caption
)
;
}
function
do_check_compatibilityoverride
(
aActual
aExpected
)
{
do_check_eq
(
aActual
.
type
aExpected
.
type
)
;
do_check_eq
(
aActual
.
minVersion
aExpected
.
minVersion
)
;
do_check_eq
(
aActual
.
maxVersion
aExpected
.
maxVersion
)
;
do_check_eq
(
aActual
.
appID
aExpected
.
appID
)
;
do_check_eq
(
aActual
.
appMinVersion
aExpected
.
appMinVersion
)
;
do_check_eq
(
aActual
.
appMaxVersion
aExpected
.
appMaxVersion
)
;
}
function
do_check_icons
(
aActual
aExpected
)
{
for
(
var
size
in
aExpected
)
{
do_check_eq
(
remove_port
(
aActual
[
size
]
)
remove_port
(
aExpected
[
size
]
)
)
;
}
}
function
startupManager
(
aAppChanged
)
{
promiseStartupManager
(
aAppChanged
)
;
}
function
restartManager
(
aNewVersion
)
{
awaitPromise
(
promiseRestartManager
(
aNewVersion
)
)
;
}
function
shutdownManager
(
)
{
awaitPromise
(
promiseShutdownManager
(
)
)
;
}
function
isItemMarkedMPIncompatible
(
aId
)
{
return
AddonTestUtils
.
addonsList
.
isMultiprocessIncompatible
(
aId
)
;
}
function
isThemeInAddonsList
(
aDir
aId
)
{
return
AddonTestUtils
.
addonsList
.
hasTheme
(
aDir
aId
)
;
}
function
isExtensionInAddonsList
(
aDir
aId
)
{
return
AddonTestUtils
.
addonsList
.
hasExtension
(
aDir
aId
)
;
}
function
check_startup_changes
(
aType
aIds
)
{
var
ids
=
aIds
.
slice
(
0
)
;
ids
.
sort
(
)
;
var
changes
=
AddonManager
.
getStartupChanges
(
aType
)
;
changes
=
changes
.
filter
(
aEl
=
>
/
tests
.
mozilla
.
org
/
.
test
(
aEl
)
)
;
changes
.
sort
(
)
;
do_check_eq
(
JSON
.
stringify
(
ids
)
JSON
.
stringify
(
changes
)
)
;
}
function
writeInstallRDFToDir
(
aData
aDir
aId
=
aData
.
id
aExtraFile
=
null
)
{
let
files
=
{
"
install
.
rdf
"
:
AddonTestUtils
.
createInstallRDF
(
aData
)
}
;
if
(
aExtraFile
)
files
[
aExtraFile
]
=
"
"
;
let
dir
=
aDir
.
clone
(
)
;
dir
.
append
(
aId
)
;
awaitPromise
(
AddonTestUtils
.
promiseWriteFilesToDir
(
dir
.
path
files
)
)
;
return
dir
;
}
function
writeInstallRDFToXPI
(
aData
aDir
aId
=
aData
.
id
aExtraFile
=
null
)
{
let
files
=
{
"
install
.
rdf
"
:
AddonTestUtils
.
createInstallRDF
(
aData
)
}
;
if
(
aExtraFile
)
files
[
aExtraFile
]
=
"
"
;
if
(
!
aDir
.
exists
(
)
)
aDir
.
create
(
AM_Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
var
file
=
aDir
.
clone
(
)
;
file
.
append
(
{
aId
}
.
xpi
)
;
AddonTestUtils
.
writeFilesToZip
(
file
.
path
files
)
;
return
file
;
}
function
writeInstallRDFForExtension
(
aData
aDir
aId
aExtraFile
)
{
if
(
TEST_UNPACKED
)
{
return
writeInstallRDFToDir
(
aData
aDir
aId
aExtraFile
)
;
}
return
writeInstallRDFToXPI
(
aData
aDir
aId
aExtraFile
)
;
}
function
promiseWriteWebManifestForExtension
(
aData
aDir
aId
=
aData
.
applications
.
gecko
.
id
)
{
let
files
=
{
"
manifest
.
json
"
:
JSON
.
stringify
(
aData
)
}
return
AddonTestUtils
.
promiseWriteFilesToExtension
(
aDir
.
path
aId
files
)
;
}
function
createTempXPIFile
(
aData
aExtraFile
)
{
let
files
=
{
"
install
.
rdf
"
:
aData
}
;
if
(
typeof
aExtraFile
=
=
"
object
"
)
Object
.
assign
(
files
aExtraFile
)
;
else
if
(
aExtraFile
)
files
[
aExtraFile
]
=
"
"
;
return
AddonTestUtils
.
createTempXPIFile
(
files
)
;
}
var
gExpectedEvents
=
{
}
;
var
gExpectedInstalls
=
[
]
;
var
gNext
=
null
;
function
getExpectedEvent
(
aId
)
{
if
(
!
(
aId
in
gExpectedEvents
)
)
do_throw
(
"
Wasn
'
t
expecting
events
for
"
+
aId
)
;
if
(
gExpectedEvents
[
aId
]
.
length
=
=
0
)
do_throw
(
"
Too
many
events
for
"
+
aId
)
;
let
event
=
gExpectedEvents
[
aId
]
.
shift
(
)
;
if
(
event
instanceof
Array
)
return
event
;
return
[
event
true
]
;
}
function
getExpectedInstall
(
aAddon
)
{
if
(
gExpectedInstalls
instanceof
Array
)
return
gExpectedInstalls
.
shift
(
)
;
if
(
!
aAddon
|
|
!
aAddon
.
id
)
return
gExpectedInstalls
.
NO_ID
.
shift
(
)
;
let
id
=
aAddon
.
id
;
if
(
!
(
id
in
gExpectedInstalls
)
|
|
!
(
gExpectedInstalls
[
id
]
instanceof
Array
)
)
do_throw
(
"
Wasn
'
t
expecting
events
for
"
+
id
)
;
if
(
gExpectedInstalls
[
id
]
.
length
=
=
0
)
do_throw
(
"
Too
many
events
for
"
+
id
)
;
return
gExpectedInstalls
[
id
]
.
shift
(
)
;
}
const
AddonListener
=
{
onPropertyChanged
(
aAddon
aProperties
)
{
do_print
(
Got
onPropertyChanged
event
for
{
aAddon
.
id
}
)
;
let
[
event
properties
]
=
getExpectedEvent
(
aAddon
.
id
)
;
do_check_eq
(
"
onPropertyChanged
"
event
)
;
do_check_eq
(
aProperties
.
length
properties
.
length
)
;
properties
.
forEach
(
function
(
aProperty
)
{
if
(
aProperties
.
indexOf
(
aProperty
)
=
=
-
1
)
do_throw
(
"
Did
not
see
property
change
for
"
+
aProperty
)
;
}
)
;
return
check_test_completed
(
arguments
)
;
}
onEnabling
(
aAddon
aRequiresRestart
)
{
do_print
(
Got
onEnabling
event
for
{
aAddon
.
id
}
)
;
let
[
event
expectedRestart
]
=
getExpectedEvent
(
aAddon
.
id
)
;
do_check_eq
(
"
onEnabling
"
event
)
;
do_check_eq
(
aRequiresRestart
expectedRestart
)
;
if
(
expectedRestart
)
do_check_true
(
hasFlag
(
aAddon
.
pendingOperations
AddonManager
.
PENDING_ENABLE
)
)
;
do_check_false
(
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_ENABLE
)
)
;
return
check_test_completed
(
arguments
)
;
}
onEnabled
(
aAddon
)
{
do_print
(
Got
onEnabled
event
for
{
aAddon
.
id
}
)
;
let
[
event
]
=
getExpectedEvent
(
aAddon
.
id
)
;
do_check_eq
(
"
onEnabled
"
event
)
;
do_check_false
(
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_ENABLE
)
)
;
return
check_test_completed
(
arguments
)
;
}
onDisabling
(
aAddon
aRequiresRestart
)
{
do_print
(
Got
onDisabling
event
for
{
aAddon
.
id
}
)
;
let
[
event
expectedRestart
]
=
getExpectedEvent
(
aAddon
.
id
)
;
do_check_eq
(
"
onDisabling
"
event
)
;
do_check_eq
(
aRequiresRestart
expectedRestart
)
;
if
(
expectedRestart
)
do_check_true
(
hasFlag
(
aAddon
.
pendingOperations
AddonManager
.
PENDING_DISABLE
)
)
;
do_check_false
(
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_DISABLE
)
)
;
return
check_test_completed
(
arguments
)
;
}
onDisabled
(
aAddon
)
{
do_print
(
Got
onDisabled
event
for
{
aAddon
.
id
}
)
;
let
[
event
]
=
getExpectedEvent
(
aAddon
.
id
)
;
do_check_eq
(
"
onDisabled
"
event
)
;
do_check_false
(
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_DISABLE
)
)
;
return
check_test_completed
(
arguments
)
;
}
onInstalling
(
aAddon
aRequiresRestart
)
{
do_print
(
Got
onInstalling
event
for
{
aAddon
.
id
}
)
;
let
[
event
expectedRestart
]
=
getExpectedEvent
(
aAddon
.
id
)
;
do_check_eq
(
"
onInstalling
"
event
)
;
do_check_eq
(
aRequiresRestart
expectedRestart
)
;
if
(
expectedRestart
)
do_check_true
(
hasFlag
(
aAddon
.
pendingOperations
AddonManager
.
PENDING_INSTALL
)
)
;
return
check_test_completed
(
arguments
)
;
}
onInstalled
(
aAddon
)
{
do_print
(
Got
onInstalled
event
for
{
aAddon
.
id
}
)
;
let
[
event
]
=
getExpectedEvent
(
aAddon
.
id
)
;
do_check_eq
(
"
onInstalled
"
event
)
;
return
check_test_completed
(
arguments
)
;
}
onUninstalling
(
aAddon
aRequiresRestart
)
{
do_print
(
Got
onUninstalling
event
for
{
aAddon
.
id
}
)
;
let
[
event
expectedRestart
]
=
getExpectedEvent
(
aAddon
.
id
)
;
do_check_eq
(
"
onUninstalling
"
event
)
;
do_check_eq
(
aRequiresRestart
expectedRestart
)
;
if
(
expectedRestart
)
do_check_true
(
hasFlag
(
aAddon
.
pendingOperations
AddonManager
.
PENDING_UNINSTALL
)
)
;
return
check_test_completed
(
arguments
)
;
}
onUninstalled
(
aAddon
)
{
do_print
(
Got
onUninstalled
event
for
{
aAddon
.
id
}
)
;
let
[
event
]
=
getExpectedEvent
(
aAddon
.
id
)
;
do_check_eq
(
"
onUninstalled
"
event
)
;
return
check_test_completed
(
arguments
)
;
}
onOperationCancelled
(
aAddon
)
{
do_print
(
Got
onOperationCancelled
event
for
{
aAddon
.
id
}
)
;
let
[
event
]
=
getExpectedEvent
(
aAddon
.
id
)
;
do_check_eq
(
"
onOperationCancelled
"
event
)
;
return
check_test_completed
(
arguments
)
;
}
}
;
const
InstallListener
=
{
onNewInstall
(
install
)
{
if
(
install
.
state
!
=
AddonManager
.
STATE_DOWNLOADED
&
&
install
.
state
!
=
AddonManager
.
STATE_DOWNLOAD_FAILED
&
&
install
.
state
!
=
AddonManager
.
STATE_AVAILABLE
)
do_throw
(
"
Bad
install
state
"
+
install
.
state
)
;
if
(
install
.
state
!
=
AddonManager
.
STATE_DOWNLOAD_FAILED
)
do_check_eq
(
install
.
error
0
)
;
else
do_check_neq
(
install
.
error
0
)
;
do_check_eq
(
"
onNewInstall
"
getExpectedInstall
(
)
)
;
return
check_test_completed
(
arguments
)
;
}
onDownloadStarted
(
install
)
{
do_check_eq
(
install
.
state
AddonManager
.
STATE_DOWNLOADING
)
;
do_check_eq
(
install
.
error
0
)
;
do_check_eq
(
"
onDownloadStarted
"
getExpectedInstall
(
)
)
;
return
check_test_completed
(
arguments
)
;
}
onDownloadEnded
(
install
)
{
do_check_eq
(
install
.
state
AddonManager
.
STATE_DOWNLOADED
)
;
do_check_eq
(
install
.
error
0
)
;
do_check_eq
(
"
onDownloadEnded
"
getExpectedInstall
(
)
)
;
return
check_test_completed
(
arguments
)
;
}
onDownloadFailed
(
install
)
{
do_check_eq
(
install
.
state
AddonManager
.
STATE_DOWNLOAD_FAILED
)
;
do_check_eq
(
"
onDownloadFailed
"
getExpectedInstall
(
)
)
;
return
check_test_completed
(
arguments
)
;
}
onDownloadCancelled
(
install
)
{
do_check_eq
(
install
.
state
AddonManager
.
STATE_CANCELLED
)
;
do_check_eq
(
install
.
error
0
)
;
do_check_eq
(
"
onDownloadCancelled
"
getExpectedInstall
(
)
)
;
return
check_test_completed
(
arguments
)
;
}
onInstallStarted
(
install
)
{
do_check_eq
(
install
.
state
AddonManager
.
STATE_INSTALLING
)
;
do_check_eq
(
install
.
error
0
)
;
do_check_eq
(
"
onInstallStarted
"
getExpectedInstall
(
install
.
addon
)
)
;
return
check_test_completed
(
arguments
)
;
}
onInstallEnded
(
install
newAddon
)
{
do_check_eq
(
install
.
state
AddonManager
.
STATE_INSTALLED
)
;
do_check_eq
(
install
.
error
0
)
;
do_check_eq
(
"
onInstallEnded
"
getExpectedInstall
(
install
.
addon
)
)
;
return
check_test_completed
(
arguments
)
;
}
onInstallFailed
(
install
)
{
do_check_eq
(
install
.
state
AddonManager
.
STATE_INSTALL_FAILED
)
;
do_check_eq
(
"
onInstallFailed
"
getExpectedInstall
(
install
.
addon
)
)
;
return
check_test_completed
(
arguments
)
;
}
onInstallCancelled
(
install
)
{
let
possibleStates
=
[
AddonManager
.
STATE_CANCELLED
AddonManager
.
STATE_DOWNLOADED
]
;
do_check_true
(
possibleStates
.
indexOf
(
install
.
state
)
!
=
-
1
)
;
do_check_eq
(
install
.
error
0
)
;
do_check_eq
(
"
onInstallCancelled
"
getExpectedInstall
(
install
.
addon
)
)
;
return
check_test_completed
(
arguments
)
;
}
onExternalInstall
(
aAddon
existingAddon
aRequiresRestart
)
{
do_check_eq
(
"
onExternalInstall
"
getExpectedInstall
(
aAddon
)
)
;
do_check_false
(
aRequiresRestart
)
;
return
check_test_completed
(
arguments
)
;
}
}
;
function
hasFlag
(
aBits
aFlag
)
{
return
(
aBits
&
aFlag
)
!
=
0
;
}
function
prepare_test
(
aExpectedEvents
aExpectedInstalls
aNext
)
{
AddonManager
.
addAddonListener
(
AddonListener
)
;
AddonManager
.
addInstallListener
(
InstallListener
)
;
gExpectedInstalls
=
aExpectedInstalls
;
gExpectedEvents
=
aExpectedEvents
;
gNext
=
aNext
;
}
function
check_test_completed
(
aArgs
)
{
if
(
!
gNext
)
return
undefined
;
if
(
gExpectedInstalls
instanceof
Array
&
&
gExpectedInstalls
.
length
>
0
)
return
undefined
;
for
(
let
id
in
gExpectedInstalls
)
{
let
installList
=
gExpectedInstalls
[
id
]
;
if
(
installList
.
length
>
0
)
return
undefined
;
}
for
(
let
id
in
gExpectedEvents
)
{
if
(
gExpectedEvents
[
id
]
.
length
>
0
)
return
undefined
;
}
return
gNext
.
apply
(
null
aArgs
)
;
}
function
ensure_test_completed
(
)
{
for
(
let
i
in
gExpectedEvents
)
{
if
(
gExpectedEvents
[
i
]
.
length
>
0
)
do_throw
(
"
Didn
'
t
see
all
the
expected
events
for
"
+
i
)
;
}
gExpectedEvents
=
{
}
;
if
(
gExpectedInstalls
)
do_check_eq
(
gExpectedInstalls
.
length
0
)
;
}
function
completeAllInstalls
(
aInstalls
aCallback
)
{
promiseCompleteAllInstalls
(
aInstalls
)
.
then
(
aCallback
)
;
}
function
installAllFiles
(
aFiles
aCallback
aIgnoreIncompatible
)
{
promiseInstallAllFiles
(
aFiles
aIgnoreIncompatible
)
.
then
(
aCallback
)
;
}
const
EXTENSIONS_DB
=
"
extensions
.
json
"
;
var
gExtensionsJSON
=
gProfD
.
clone
(
)
;
gExtensionsJSON
.
append
(
EXTENSIONS_DB
)
;
function
promiseInstallWebExtension
(
aData
)
{
let
addonFile
=
createTempWebExtensionFile
(
aData
)
;
return
promiseInstallAllFiles
(
[
addonFile
]
)
.
then
(
installs
=
>
{
Services
.
obs
.
notifyObservers
(
addonFile
"
flush
-
cache
-
entry
"
)
;
if
(
aData
.
manifest
.
theme
)
return
installs
[
0
]
.
addon
;
return
promiseWebExtensionStartup
(
)
;
}
)
;
}
Services
.
prefs
.
setBoolPref
(
"
extensions
.
strictCompatibility
"
true
)
;
Services
.
prefs
.
setCharPref
(
PREF_EM_MIN_COMPAT_APP_VERSION
"
0
"
)
;
Services
.
prefs
.
setCharPref
(
PREF_EM_MIN_COMPAT_PLATFORM_VERSION
"
0
"
)
;
Services
.
prefs
.
setBoolPref
(
PREF_XPI_SIGNATURES_REQUIRED
true
)
;
Services
.
prefs
.
setBoolPref
(
PREF_ALLOW_NON_MPC
true
)
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
legacy
.
enabled
"
true
)
;
function
copyBlocklistToProfile
(
blocklistFile
)
{
var
dest
=
gProfD
.
clone
(
)
;
dest
.
append
(
"
blocklist
.
xml
"
)
;
if
(
dest
.
exists
(
)
)
dest
.
remove
(
false
)
;
blocklistFile
.
copyTo
(
gProfD
"
blocklist
.
xml
"
)
;
dest
.
lastModifiedTime
=
Date
.
now
(
)
;
}
function
timeout
(
)
{
timer
=
null
;
do_throw
(
"
Test
ran
longer
than
"
+
TIMEOUT_MS
+
"
ms
"
)
;
do_test_finished
(
)
;
}
var
timer
=
AM_Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
AM_Ci
.
nsITimer
)
;
timer
.
init
(
timeout
TIMEOUT_MS
AM_Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
function
pathShouldntExist
(
file
)
{
if
(
file
.
exists
(
)
)
{
do_throw
(
Test
cleanup
:
path
{
file
.
path
}
exists
when
it
should
not
)
;
}
}
do_register_cleanup
(
function
addon_cleanup
(
)
{
if
(
timer
)
timer
.
cancel
(
)
;
}
)
;
function
createHttpServer
(
port
=
-
1
)
{
let
server
=
new
HttpServer
(
)
;
server
.
start
(
port
)
;
do_register_cleanup
(
(
)
=
>
{
return
new
Promise
(
resolve
=
>
{
server
.
stop
(
resolve
)
;
}
)
;
}
)
;
return
server
;
}
function
interpolateAndServeFile
(
request
response
)
{
try
{
let
file
=
gUrlToFileMap
[
request
.
path
]
;
var
data
=
"
"
;
var
fstream
=
Components
.
classes
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIFileInputStream
)
;
var
cstream
=
Components
.
classes
[
"
mozilla
.
org
/
intl
/
converter
-
input
-
stream
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIConverterInputStream
)
;
fstream
.
init
(
file
-
1
0
0
)
;
cstream
.
init
(
fstream
"
UTF
-
8
"
0
0
)
;
let
str
=
{
}
;
let
read
=
0
;
do
{
read
=
cstream
.
readString
(
0xffffffff
str
)
;
data
+
=
str
.
value
;
}
while
(
read
!
=
0
)
;
data
=
data
.
replace
(
/
%
PORT
%
/
g
gPort
)
;
response
.
write
(
data
)
;
}
catch
(
e
)
{
do_throw
(
Exception
while
serving
interpolated
file
:
{
e
}
\
n
{
e
.
stack
}
)
;
}
finally
{
cstream
.
close
(
)
;
}
}
function
mapUrlToFile
(
url
file
server
)
{
server
.
registerPathHandler
(
url
interpolateAndServeFile
)
;
gUrlToFileMap
[
url
]
=
file
;
}
function
mapFile
(
path
server
)
{
mapUrlToFile
(
path
do_get_file
(
path
)
server
)
;
}
function
remove_port
(
url
)
{
if
(
typeof
url
=
=
=
"
string
"
)
return
url
.
replace
(
/
:
\
d
+
/
"
"
)
;
return
url
;
}
function
do_exception_wrap
(
func
)
{
return
function
(
)
{
try
{
func
.
apply
(
null
arguments
)
;
}
catch
(
e
)
{
do_report_unexpected_exception
(
e
)
;
}
}
;
}
function
changeXPIDBVersion
(
aNewVersion
aMutator
=
undefined
)
{
let
jData
=
loadJSON
(
gExtensionsJSON
)
;
jData
.
schemaVersion
=
aNewVersion
;
if
(
aMutator
)
aMutator
(
jData
)
;
saveJSON
(
jData
gExtensionsJSON
)
;
}
function
loadFile
(
aFile
)
{
let
data
=
"
"
;
let
fstream
=
Components
.
classes
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIFileInputStream
)
;
let
cstream
=
Components
.
classes
[
"
mozilla
.
org
/
intl
/
converter
-
input
-
stream
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIConverterInputStream
)
;
fstream
.
init
(
aFile
-
1
0
0
)
;
cstream
.
init
(
fstream
"
UTF
-
8
"
0
0
)
;
let
str
=
{
}
;
let
read
=
0
;
do
{
read
=
cstream
.
readString
(
0xffffffff
str
)
;
data
+
=
str
.
value
;
}
while
(
read
!
=
0
)
;
cstream
.
close
(
)
;
return
data
;
}
function
loadJSON
(
aFile
)
{
let
data
=
loadFile
(
aFile
)
;
do_print
(
"
Loaded
JSON
file
"
+
aFile
.
path
)
;
return
(
JSON
.
parse
(
data
)
)
;
}
function
saveJSON
(
aData
aFile
)
{
do_print
(
"
Starting
to
save
JSON
file
"
+
aFile
.
path
)
;
let
stream
=
FileUtils
.
openSafeFileOutputStream
(
aFile
)
;
let
converter
=
AM_Cc
[
"
mozilla
.
org
/
intl
/
converter
-
output
-
stream
;
1
"
]
.
createInstance
(
AM_Ci
.
nsIConverterOutputStream
)
;
converter
.
init
(
stream
"
UTF
-
8
"
)
;
converter
.
writeString
(
JSON
.
stringify
(
aData
null
2
)
)
;
converter
.
flush
(
)
;
FileUtils
.
closeSafeFileOutputStream
(
stream
)
;
converter
.
close
(
)
;
do_print
(
"
Done
saving
JSON
file
"
+
aFile
.
path
)
;
}
function
callback_soon
(
aFunction
)
{
return
function
(
.
.
.
args
)
{
do_execute_soon
(
function
(
)
{
aFunction
.
apply
(
null
args
)
;
}
aFunction
.
name
?
"
delayed
callback
"
+
aFunction
.
name
:
"
delayed
callback
"
)
;
}
}
function
writeProxyFileToDir
(
aDir
aAddon
aId
)
{
awaitPromise
(
promiseWriteProxyFileToDir
(
aDir
aAddon
aId
)
)
;
let
file
=
aDir
.
clone
(
)
;
file
.
append
(
aId
)
;
return
file
}
async
function
serveSystemUpdate
(
xml
perform_update
testserver
)
{
testserver
.
registerPathHandler
(
"
/
data
/
update
.
xml
"
(
request
response
)
=
>
{
response
.
write
(
xml
)
;
}
)
;
try
{
await
perform_update
(
)
;
}
finally
{
testserver
.
registerPathHandler
(
"
/
data
/
update
.
xml
"
null
)
;
}
}
async
function
installSystemAddons
(
xml
testserver
)
{
do_print
(
"
Triggering
system
add
-
on
update
check
.
"
)
;
await
serveSystemUpdate
(
xml
async
function
(
)
{
let
{
XPIProvider
}
=
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIProvider
.
jsm
"
{
}
)
;
await
XPIProvider
.
updateSystemAddons
(
)
;
}
testserver
)
;
}
async
function
updateAllSystemAddons
(
xml
testserver
)
{
do_print
(
"
Triggering
full
add
-
on
update
check
.
"
)
;
await
serveSystemUpdate
(
xml
function
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observer
(
)
{
Services
.
obs
.
removeObserver
(
observer
"
addons
-
background
-
update
-
complete
"
)
;
resolve
(
)
;
}
"
addons
-
background
-
update
-
complete
"
)
;
gInternalManager
.
notify
(
null
)
;
}
)
;
}
testserver
)
;
}
function
buildSystemAddonUpdates
(
addons
root
)
{
let
xml
=
<
?
xml
version
=
"
1
.
0
"
encoding
=
"
UTF
-
8
"
?
>
\
n
\
n
<
updates
>
\
n
;
if
(
addons
)
{
xml
+
=
<
addons
>
\
n
;
for
(
let
addon
of
addons
)
{
xml
+
=
<
addon
id
=
"
{
addon
.
id
}
"
URL
=
"
{
root
+
addon
.
path
}
"
version
=
"
{
addon
.
version
}
"
;
if
(
addon
.
size
)
xml
+
=
size
=
"
{
addon
.
size
}
"
;
if
(
addon
.
hashFunction
)
xml
+
=
hashFunction
=
"
{
addon
.
hashFunction
}
"
;
if
(
addon
.
hashValue
)
xml
+
=
hashValue
=
"
{
addon
.
hashValue
}
"
;
xml
+
=
/
>
\
n
;
}
xml
+
=
<
/
addons
>
\
n
;
}
xml
+
=
<
/
updates
>
\
n
;
return
xml
;
}
function
initSystemAddonDirs
(
)
{
let
hiddenSystemAddonDir
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
sysfeatures
"
"
hidden
"
]
true
)
;
do_get_file
(
"
data
/
system_addons
/
system1_1
.
xpi
"
)
.
copyTo
(
hiddenSystemAddonDir
"
system1
tests
.
mozilla
.
org
.
xpi
"
)
;
do_get_file
(
"
data
/
system_addons
/
system2_1
.
xpi
"
)
.
copyTo
(
hiddenSystemAddonDir
"
system2
tests
.
mozilla
.
org
.
xpi
"
)
;
let
prefilledSystemAddonDir
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
sysfeatures
"
"
prefilled
"
]
true
)
;
do_get_file
(
"
data
/
system_addons
/
system2_2
.
xpi
"
)
.
copyTo
(
prefilledSystemAddonDir
"
system2
tests
.
mozilla
.
org
.
xpi
"
)
;
do_get_file
(
"
data
/
system_addons
/
system3_2
.
xpi
"
)
.
copyTo
(
prefilledSystemAddonDir
"
system3
tests
.
mozilla
.
org
.
xpi
"
)
;
}
function
getCurrentSystemAddonUpdatesDir
(
)
{
const
updatesDir
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
features
"
]
false
)
;
let
dir
=
updatesDir
.
clone
(
)
;
let
set
=
JSON
.
parse
(
Services
.
prefs
.
getCharPref
(
PREF_SYSTEM_ADDON_SET
)
)
;
dir
.
append
(
set
.
directory
)
;
return
dir
;
}
function
clearSystemAddonUpdatesDir
(
)
{
const
updatesDir
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
features
"
]
false
)
;
if
(
updatesDir
.
exists
(
)
)
updatesDir
.
remove
(
true
)
;
Services
.
prefs
.
clearUserPref
(
PREF_SYSTEM_ADDON_SET
)
;
}
function
buildPrefilledUpdatesDir
(
)
{
clearSystemAddonUpdatesDir
(
)
;
let
dir
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
features
"
"
prefilled
"
]
true
)
;
do_get_file
(
"
data
/
system_addons
/
system2_2
.
xpi
"
)
.
copyTo
(
dir
"
system2
tests
.
mozilla
.
org
.
xpi
"
)
;
do_get_file
(
"
data
/
system_addons
/
system3_2
.
xpi
"
)
.
copyTo
(
dir
"
system3
tests
.
mozilla
.
org
.
xpi
"
)
;
FileUtils
.
getFile
(
"
ProfD
"
[
"
features
"
"
prefilled
"
"
system2
tests
.
mozilla
.
org
.
xpi
"
]
)
.
lastModifiedTime
-
=
10000
;
FileUtils
.
getFile
(
"
ProfD
"
[
"
features
"
"
prefilled
"
"
system3
tests
.
mozilla
.
org
.
xpi
"
]
)
.
lastModifiedTime
-
=
10000
;
Services
.
prefs
.
setCharPref
(
PREF_SYSTEM_ADDON_SET
JSON
.
stringify
(
{
schema
:
1
directory
:
dir
.
leafName
addons
:
{
"
system2
tests
.
mozilla
.
org
"
:
{
version
:
"
2
.
0
"
}
"
system3
tests
.
mozilla
.
org
"
:
{
version
:
"
2
.
0
"
}
}
}
)
)
;
}
async
function
checkInstalledSystemAddons
(
conditions
distroDir
)
{
for
(
let
i
=
0
;
i
<
conditions
.
length
;
i
+
+
)
{
let
condition
=
conditions
[
i
]
;
let
id
=
"
system
"
+
(
i
+
1
)
+
"
tests
.
mozilla
.
org
"
;
let
addon
=
await
promiseAddonByID
(
id
)
;
if
(
!
(
"
isUpgrade
"
in
condition
)
|
|
!
(
"
version
"
in
condition
)
)
{
throw
Error
(
"
condition
must
contain
isUpgrade
and
version
"
)
;
}
let
isUpgrade
=
conditions
[
i
]
.
isUpgrade
;
let
version
=
conditions
[
i
]
.
version
;
let
expectedDir
=
isUpgrade
?
getCurrentSystemAddonUpdatesDir
(
)
:
distroDir
;
if
(
version
)
{
do_print
(
Checking
state
of
add
-
on
{
id
}
expecting
version
{
version
}
)
;
do_check_neq
(
addon
null
)
;
do_check_eq
(
addon
.
version
version
)
;
do_check_true
(
addon
.
isActive
)
;
do_check_false
(
addon
.
foreignInstall
)
;
do_check_true
(
addon
.
hidden
)
;
do_check_true
(
addon
.
isSystem
)
;
let
file
=
expectedDir
.
clone
(
)
;
file
.
append
(
id
+
"
.
xpi
"
)
;
do_check_true
(
file
.
exists
(
)
)
;
do_check_true
(
file
.
isFile
(
)
)
;
let
uri
=
addon
.
getResourceURI
(
null
)
;
do_check_true
(
uri
instanceof
AM_Ci
.
nsIFileURL
)
;
do_check_eq
(
uri
.
file
.
path
file
.
path
)
;
if
(
isUpgrade
)
{
do_check_eq
(
addon
.
signedState
AddonManager
.
SIGNEDSTATE_SYSTEM
)
;
}
BootstrapMonitor
.
checkAddonStarted
(
id
version
)
;
}
else
{
do_print
(
Checking
state
of
add
-
on
{
id
}
expecting
it
to
be
missing
)
;
if
(
isUpgrade
)
{
do_check_eq
(
addon
null
)
;
}
BootstrapMonitor
.
checkAddonNotStarted
(
id
)
;
if
(
addon
)
BootstrapMonitor
.
checkAddonInstalled
(
id
)
;
else
BootstrapMonitor
.
checkAddonNotInstalled
(
id
)
;
}
}
}
async
function
getSystemAddonDirectories
(
)
{
const
updatesDir
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
features
"
]
false
)
;
let
subdirs
=
[
]
;
if
(
await
OS
.
File
.
exists
(
updatesDir
.
path
)
)
{
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
updatesDir
.
path
)
;
await
iterator
.
forEach
(
entry
=
>
{
if
(
entry
.
isDir
)
{
subdirs
.
push
(
entry
)
;
}
}
)
;
iterator
.
close
(
)
;
}
return
subdirs
;
}
async
function
setupSystemAddonConditions
(
setup
distroDir
)
{
do_print
(
"
Clearing
existing
database
.
"
)
;
Services
.
prefs
.
clearUserPref
(
PREF_SYSTEM_ADDON_SET
)
;
distroDir
.
leafName
=
"
empty
"
;
await
overrideBuiltIns
(
{
"
system
"
:
[
"
system1
tests
.
mozilla
.
org
"
"
system2
tests
.
mozilla
.
org
"
"
system3
tests
.
mozilla
.
org
"
"
system4
tests
.
mozilla
.
org
"
"
system5
tests
.
mozilla
.
org
"
]
}
)
;
startupManager
(
false
)
;
await
promiseShutdownManager
(
)
;
do_print
(
"
Setting
up
conditions
.
"
)
;
await
setup
.
setup
(
)
;
await
overrideBuiltIns
(
{
"
system
"
:
[
"
system1
tests
.
mozilla
.
org
"
"
system2
tests
.
mozilla
.
org
"
"
system3
tests
.
mozilla
.
org
"
"
system4
tests
.
mozilla
.
org
"
"
system5
tests
.
mozilla
.
org
"
]
}
)
;
startupManager
(
false
)
;
do_print
(
"
Checking
initial
state
.
"
)
;
await
checkInstalledSystemAddons
(
setup
.
initialState
distroDir
)
;
}
async
function
verifySystemAddonState
(
initialState
finalState
=
undefined
alreadyUpgraded
=
false
distroDir
)
{
let
expectedDirs
=
0
;
if
(
initialState
.
some
(
a
=
>
a
.
isUpgrade
)
)
{
expectedDirs
+
+
;
}
if
(
finalState
=
=
undefined
)
{
finalState
=
initialState
;
}
else
if
(
finalState
.
some
(
a
=
>
a
.
isUpgrade
)
)
{
expectedDirs
+
+
;
}
if
(
alreadyUpgraded
)
{
expectedDirs
+
+
;
}
do_print
(
"
Checking
final
state
.
"
)
;
let
dirs
=
await
getSystemAddonDirectories
(
)
;
do_check_eq
(
dirs
.
length
expectedDirs
)
;
await
checkInstalledSystemAddons
(
.
.
.
finalState
distroDir
)
;
shutdownManager
(
)
;
await
overrideBuiltIns
(
{
"
system
"
:
[
"
system1
tests
.
mozilla
.
org
"
"
system2
tests
.
mozilla
.
org
"
"
system3
tests
.
mozilla
.
org
"
"
system4
tests
.
mozilla
.
org
"
"
system5
tests
.
mozilla
.
org
"
]
}
)
;
await
promiseStartupManager
(
)
;
await
checkInstalledSystemAddons
(
finalState
distroDir
)
;
}
async
function
execSystemAddonTest
(
setupName
setup
test
distroDir
root
testserver
)
{
await
setupSystemAddonConditions
(
setup
distroDir
)
;
try
{
if
(
"
test
"
in
test
)
{
await
test
.
test
(
)
;
}
else
{
await
installSystemAddons
(
await
buildSystemAddonUpdates
(
test
.
updateList
root
)
testserver
)
;
}
if
(
test
.
fails
)
{
do_throw
(
"
Expected
this
test
to
fail
"
)
;
}
}
catch
(
e
)
{
if
(
!
test
.
fails
)
{
do_throw
(
e
)
;
}
}
if
(
test
.
finalState
&
&
setupName
in
test
.
finalState
)
{
await
verifySystemAddonState
(
setup
.
initialState
test
.
finalState
[
setupName
]
false
distroDir
)
;
}
else
{
await
verifySystemAddonState
(
setup
.
initialState
undefined
false
distroDir
)
;
}
await
promiseShutdownManager
(
)
;
}
