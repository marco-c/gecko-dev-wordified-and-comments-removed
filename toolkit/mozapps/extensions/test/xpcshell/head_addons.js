if
(
!
_TEST_FILE
[
0
]
.
includes
(
"
toolkit
/
mozapps
/
extensions
/
test
/
xpcshell
/
"
)
)
{
ok
(
false
"
head_addons
.
js
may
not
be
loaded
by
tests
outside
of
"
+
"
the
add
-
on
manager
component
.
"
)
;
}
const
PREF_EM_CHECK_UPDATE_SECURITY
=
"
extensions
.
checkUpdateSecurity
"
;
const
PREF_EM_STRICT_COMPATIBILITY
=
"
extensions
.
strictCompatibility
"
;
const
PREF_GETADDONS_BYIDS
=
"
extensions
.
getAddons
.
get
.
url
"
;
const
PREF_COMPAT_OVERRIDES
=
"
extensions
.
getAddons
.
compatOverides
.
url
"
;
const
PREF_XPI_SIGNATURES_REQUIRED
=
"
xpinstall
.
signatures
.
required
"
;
const
PREF_DISABLE_SECURITY
=
"
security
.
turn_off_all_security_so_that_
"
+
"
viruses_can_take_over_this_computer
"
;
const
MAX_TIME_DIFFERENCE
=
3000
;
const
MAKE_FILE_OLD_DIFFERENCE
=
10
*
3600
*
1000
;
var
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
var
{
FileUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
var
{
NetUtil
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
var
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
var
{
AddonRepository
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonRepository
.
jsm
"
)
;
var
{
OS
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
var
{
AddonTestUtils
MockAsyncShutdown
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Blocklist
"
"
resource
:
/
/
gre
/
modules
/
Blocklist
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Extension
"
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionTestUtils
"
"
resource
:
/
/
testing
-
common
/
ExtensionXPCShellUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionTestCommon
"
"
resource
:
/
/
testing
-
common
/
ExtensionTestCommon
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
HttpServer
"
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MockRegistrar
"
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MockRegistry
"
"
resource
:
/
/
testing
-
common
/
MockRegistry
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromiseTestUtils
"
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
RemoteSettings
"
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TestUtils
"
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
aomStartup
"
"
mozilla
.
org
/
addons
/
addon
-
manager
-
startup
;
1
"
"
amIAddonManagerStartup
"
)
;
const
{
createAppInfo
createHttpServer
createTempWebExtensionFile
getFileForAddon
manuallyInstall
manuallyUninstall
overrideBuiltIns
promiseAddonEvent
promiseCompleteAllInstalls
promiseCompleteInstall
promiseConsoleOutput
promiseFindAddonUpdates
promiseInstallAllFiles
promiseInstallFile
promiseRestartManager
promiseSetExtensionModifiedTime
promiseShutdownManager
promiseStartupManager
promiseWebExtensionStartup
promiseWriteProxyFileToDir
registerDirectory
setExtensionModifiedTime
writeFilesToZip
}
=
AddonTestUtils
;
ExtensionTestUtils
.
init
(
this
)
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
BOOTSTRAP_REASONS
"
(
)
=
>
AddonManagerPrivate
.
BOOTSTRAP_REASONS
)
;
function
getReasonName
(
reason
)
{
for
(
let
key
of
Object
.
keys
(
BOOTSTRAP_REASONS
)
)
{
if
(
BOOTSTRAP_REASONS
[
key
]
=
=
reason
)
{
return
key
;
}
}
throw
new
Error
(
"
This
shouldn
'
t
happen
.
"
)
;
}
Object
.
defineProperty
(
this
"
gAppInfo
"
{
get
(
)
{
return
AddonTestUtils
.
appInfo
;
}
}
)
;
Object
.
defineProperty
(
this
"
gAddonStartup
"
{
get
(
)
{
return
AddonTestUtils
.
addonStartup
.
clone
(
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gInternalManager
"
{
get
(
)
{
return
AddonTestUtils
.
addonIntegrationService
.
QueryInterface
(
Ci
.
nsITimerCallback
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gProfD
"
{
get
(
)
{
return
AddonTestUtils
.
profileDir
.
clone
(
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gTmpD
"
{
get
(
)
{
return
AddonTestUtils
.
tempDir
.
clone
(
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gUseRealCertChecks
"
{
get
(
)
{
return
AddonTestUtils
.
useRealCertChecks
;
}
set
(
val
)
{
return
(
AddonTestUtils
.
useRealCertChecks
=
val
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
TEST_UNPACKED
"
{
get
(
)
{
return
AddonTestUtils
.
testUnpacked
;
}
set
(
val
)
{
return
(
AddonTestUtils
.
testUnpacked
=
val
)
;
}
}
)
;
var
AMscope
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
null
)
;
var
{
AddonManager
AddonManagerInternal
AddonManagerPrivate
}
=
AMscope
;
const
promiseAddonByID
=
AddonManager
.
getAddonByID
;
const
promiseAddonsByIDs
=
AddonManager
.
getAddonsByIDs
;
var
gPort
=
null
;
var
BootstrapMonitor
=
{
started
:
new
Map
(
)
stopped
:
new
Map
(
)
installed
:
new
Map
(
)
uninstalled
:
new
Map
(
)
init
(
)
{
this
.
onEvent
=
this
.
onEvent
.
bind
(
this
)
;
AddonTestUtils
.
on
(
"
addon
-
manager
-
shutdown
"
this
.
onEvent
)
;
AddonTestUtils
.
on
(
"
bootstrap
-
method
"
this
.
onEvent
)
;
}
shutdownCheck
(
)
{
equal
(
this
.
started
.
size
0
"
Should
have
no
add
-
ons
that
were
started
but
not
shutdown
"
)
;
}
onEvent
(
msg
data
)
{
switch
(
msg
)
{
case
"
addon
-
manager
-
shutdown
"
:
this
.
shutdownCheck
(
)
;
break
;
case
"
bootstrap
-
method
"
:
this
.
onBootstrapMethod
(
data
.
method
data
.
params
data
.
reason
)
;
break
;
}
}
onBootstrapMethod
(
method
params
reason
)
{
let
{
id
}
=
params
;
info
(
Bootstrap
method
{
method
}
for
{
params
.
id
}
version
{
params
.
version
}
)
;
if
(
method
!
=
=
"
install
"
)
{
this
.
checkInstalled
(
id
)
;
}
switch
(
method
)
{
case
"
install
"
:
this
.
checkNotInstalled
(
id
)
;
this
.
installed
.
set
(
id
{
reason
params
}
)
;
this
.
uninstalled
.
delete
(
id
)
;
break
;
case
"
startup
"
:
this
.
checkNotStarted
(
id
)
;
this
.
started
.
set
(
id
{
reason
params
}
)
;
this
.
stopped
.
delete
(
id
)
;
break
;
case
"
shutdown
"
:
this
.
checkMatches
(
"
shutdown
"
"
startup
"
params
this
.
started
.
get
(
id
)
)
;
this
.
checkStarted
(
id
)
;
this
.
stopped
.
set
(
id
{
reason
params
}
)
;
this
.
started
.
delete
(
id
)
;
break
;
case
"
uninstall
"
:
this
.
checkMatches
(
"
uninstall
"
"
install
"
params
this
.
installed
.
get
(
id
)
)
;
this
.
uninstalled
.
set
(
id
{
reason
params
}
)
;
this
.
installed
.
delete
(
id
)
;
break
;
case
"
update
"
:
this
.
checkMatches
(
"
update
"
"
install
"
params
this
.
installed
.
get
(
id
)
)
;
this
.
installed
.
set
(
id
{
reason
params
}
)
;
break
;
}
}
clear
(
id
)
{
this
.
installed
.
delete
(
id
)
;
this
.
started
.
delete
(
id
)
;
this
.
stopped
.
delete
(
id
)
;
this
.
uninstalled
.
delete
(
id
)
;
}
checkMatches
(
method
lastMethod
params
{
params
:
lastParams
}
=
{
}
)
{
ok
(
lastParams
Expecting
matching
{
lastMethod
}
call
for
add
-
on
{
params
.
id
}
{
method
}
call
)
;
if
(
method
=
=
"
update
"
)
{
equal
(
params
.
oldVersion
lastParams
.
version
"
params
.
version
should
match
last
call
"
)
;
}
else
{
equal
(
params
.
version
lastParams
.
version
"
params
.
version
should
match
last
call
"
)
;
}
if
(
method
!
=
=
"
update
"
&
&
method
!
=
=
"
uninstall
"
)
{
equal
(
params
.
resourceURI
.
spec
lastParams
.
resourceURI
.
spec
params
.
resourceURI
should
match
last
call
)
;
ok
(
params
.
resourceURI
.
equals
(
lastParams
.
resourceURI
)
params
.
resourceURI
should
match
:
"
{
params
.
resourceURI
.
spec
}
"
=
=
"
{
lastParams
.
resourceURI
.
spec
}
"
)
;
}
}
checkStarted
(
id
version
=
undefined
)
{
let
started
=
this
.
started
.
get
(
id
)
;
ok
(
started
Should
have
seen
startup
method
call
for
{
id
}
)
;
if
(
version
!
=
=
undefined
)
{
equal
(
started
.
params
.
version
version
"
Expected
version
number
"
)
;
}
}
checkNotStarted
(
id
)
{
ok
(
!
this
.
started
.
has
(
id
)
Should
not
have
seen
startup
method
call
for
{
id
}
)
;
}
checkInstalled
(
id
version
=
undefined
)
{
const
installed
=
this
.
installed
.
get
(
id
)
;
ok
(
installed
Should
have
seen
install
call
for
{
id
}
)
;
if
(
version
!
=
=
undefined
)
{
equal
(
installed
.
params
.
version
version
"
Expected
version
number
"
)
;
}
return
installed
;
}
checkNotInstalled
(
id
)
{
ok
(
!
this
.
installed
.
has
(
id
)
Should
not
have
seen
install
method
call
for
{
id
}
)
;
}
}
;
function
isNightlyChannel
(
)
{
var
channel
=
Services
.
prefs
.
getCharPref
(
"
app
.
update
.
channel
"
"
default
"
)
;
return
(
channel
!
=
"
aurora
"
&
&
channel
!
=
"
beta
"
&
&
channel
!
=
"
release
"
&
&
channel
!
=
"
esr
"
)
;
}
async
function
restartWithLocales
(
locales
)
{
Services
.
locale
.
requestedLocales
=
locales
;
await
promiseRestartManager
(
)
;
}
function
delay
(
msec
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
msec
)
;
}
)
;
}
async
function
getAddons
(
ids
)
{
let
addons
=
new
Map
(
)
;
for
(
let
addon
of
await
AddonManager
.
getAddonsByIDs
(
ids
)
)
{
if
(
addon
)
{
addons
.
set
(
addon
.
id
addon
)
;
}
}
return
addons
;
}
function
checkAddon
(
id
addon
expected
)
{
info
(
Checking
state
of
addon
{
id
}
)
;
if
(
expected
=
=
=
null
)
{
ok
(
!
addon
Addon
{
id
}
should
not
exist
)
;
}
else
{
ok
(
addon
Addon
{
id
}
should
exist
)
;
for
(
let
[
key
value
]
of
Object
.
entries
(
expected
)
)
{
if
(
value
instanceof
Ci
.
nsIURI
)
{
equal
(
addon
[
key
]
&
&
addon
[
key
]
.
spec
value
.
spec
Expected
value
of
addon
.
{
key
}
)
;
}
else
{
deepEqual
(
addon
[
key
]
value
Expected
value
of
addon
.
{
key
}
)
;
}
}
}
}
function
do_check_in_crash_annotation
(
aId
aVersion
)
{
if
(
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
;
}
if
(
!
(
"
Add
-
ons
"
in
gAppInfo
.
annotations
)
)
{
Assert
.
ok
(
false
"
Cannot
find
Add
-
ons
entry
in
crash
annotations
"
)
;
return
;
}
let
addons
=
gAppInfo
.
annotations
[
"
Add
-
ons
"
]
.
split
(
"
"
)
;
Assert
.
ok
(
addons
.
includes
(
{
encodeURIComponent
(
aId
)
}
:
{
encodeURIComponent
(
aVersion
)
}
)
)
;
}
function
do_check_not_in_crash_annotation
(
aId
aVersion
)
{
if
(
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
;
}
if
(
!
(
"
Add
-
ons
"
in
gAppInfo
.
annotations
)
)
{
Assert
.
ok
(
true
)
;
return
;
}
let
addons
=
gAppInfo
.
annotations
[
"
Add
-
ons
"
]
.
split
(
"
"
)
;
Assert
.
ok
(
!
addons
.
includes
(
{
encodeURIComponent
(
aId
)
}
:
{
encodeURIComponent
(
aVersion
)
}
)
)
;
}
function
do_get_file_hash
(
aFile
aAlgorithm
)
{
if
(
!
aAlgorithm
)
{
aAlgorithm
=
"
sha1
"
;
}
let
crypto
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
crypto
.
initWithString
(
aAlgorithm
)
;
let
fis
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fis
.
init
(
aFile
-
1
-
1
false
)
;
crypto
.
updateFromStream
(
fis
aFile
.
fileSize
)
;
let
toHexString
=
charCode
=
>
(
"
0
"
+
charCode
.
toString
(
16
)
)
.
slice
(
-
2
)
;
let
binary
=
crypto
.
finish
(
false
)
;
let
hash
=
Array
.
from
(
binary
c
=
>
toHexString
(
c
.
charCodeAt
(
0
)
)
)
;
return
aAlgorithm
+
"
:
"
+
hash
.
join
(
"
"
)
;
}
function
do_get_addon_root_uri
(
aProfileDir
aId
)
{
let
path
=
aProfileDir
.
clone
(
)
;
path
.
append
(
aId
)
;
if
(
!
path
.
exists
(
)
)
{
path
.
leafName
+
=
"
.
xpi
"
;
return
"
jar
:
"
+
Services
.
io
.
newFileURI
(
path
)
.
spec
+
"
!
/
"
;
}
return
Services
.
io
.
newFileURI
(
path
)
.
spec
;
}
function
do_get_expected_addon_name
(
aId
)
{
if
(
TEST_UNPACKED
)
{
return
aId
;
}
return
aId
+
"
.
xpi
"
;
}
function
getAddonFile
(
addon
)
{
let
uri
=
addon
.
getResourceURI
(
"
"
)
;
if
(
uri
instanceof
Ci
.
nsIJARURI
)
{
uri
=
uri
.
JARFile
;
}
return
uri
.
QueryInterface
(
Ci
.
nsIFileURL
)
.
file
;
}
function
do_check_addons
(
aActualAddons
aExpectedAddons
aProperties
)
{
Assert
.
notEqual
(
aActualAddons
null
)
;
Assert
.
equal
(
aActualAddons
.
length
aExpectedAddons
.
length
)
;
for
(
let
i
=
0
;
i
<
aActualAddons
.
length
;
i
+
+
)
{
do_check_addon
(
aActualAddons
[
i
]
aExpectedAddons
[
i
]
aProperties
)
;
}
}
function
do_check_addon
(
aActualAddon
aExpectedAddon
aProperties
)
{
Assert
.
notEqual
(
aActualAddon
null
)
;
aProperties
.
forEach
(
function
(
aProperty
)
{
let
actualValue
=
aActualAddon
[
aProperty
]
;
let
expectedValue
=
aExpectedAddon
[
aProperty
]
;
if
(
!
(
aProperty
in
aExpectedAddon
)
)
{
if
(
actualValue
!
=
=
undefined
&
&
actualValue
!
=
=
null
)
{
do_throw
(
"
Unexpected
defined
/
non
-
null
property
for
add
-
on
"
+
aExpectedAddon
.
id
+
"
(
addon
[
"
+
aProperty
+
"
]
=
"
+
actualValue
.
toSource
(
)
+
"
)
"
)
;
}
return
;
}
else
if
(
expectedValue
&
&
!
actualValue
)
{
do_throw
(
"
Missing
property
for
add
-
on
"
+
aExpectedAddon
.
id
+
"
:
expected
addon
[
"
+
aProperty
+
"
]
=
"
+
expectedValue
)
;
return
;
}
switch
(
aProperty
)
{
case
"
creator
"
:
do_check_author
(
actualValue
expectedValue
)
;
break
;
case
"
developers
"
:
Assert
.
equal
(
actualValue
.
length
expectedValue
.
length
)
;
for
(
let
i
=
0
;
i
<
actualValue
.
length
;
i
+
+
)
{
do_check_author
(
actualValue
[
i
]
expectedValue
[
i
]
)
;
}
break
;
case
"
screenshots
"
:
Assert
.
equal
(
actualValue
.
length
expectedValue
.
length
)
;
for
(
let
i
=
0
;
i
<
actualValue
.
length
;
i
+
+
)
{
do_check_screenshot
(
actualValue
[
i
]
expectedValue
[
i
]
)
;
}
break
;
case
"
sourceURI
"
:
Assert
.
equal
(
actualValue
.
spec
expectedValue
)
;
break
;
case
"
updateDate
"
:
Assert
.
equal
(
actualValue
.
getTime
(
)
expectedValue
.
getTime
(
)
)
;
break
;
case
"
compatibilityOverrides
"
:
Assert
.
equal
(
actualValue
.
length
expectedValue
.
length
)
;
for
(
let
i
=
0
;
i
<
actualValue
.
length
;
i
+
+
)
{
do_check_compatibilityoverride
(
actualValue
[
i
]
expectedValue
[
i
]
)
;
}
break
;
case
"
icons
"
:
do_check_icons
(
actualValue
expectedValue
)
;
break
;
default
:
if
(
actualValue
!
=
=
expectedValue
)
{
do_throw
(
"
Failed
for
"
+
aProperty
+
"
for
add
-
on
"
+
aExpectedAddon
.
id
+
"
(
"
+
actualValue
+
"
=
=
=
"
+
expectedValue
+
"
)
"
)
;
}
}
}
)
;
}
function
do_check_author
(
aActual
aExpected
)
{
Assert
.
equal
(
aActual
.
toString
(
)
aExpected
.
name
)
;
Assert
.
equal
(
aActual
.
name
aExpected
.
name
)
;
Assert
.
equal
(
aActual
.
url
aExpected
.
url
)
;
}
function
do_check_screenshot
(
aActual
aExpected
)
{
Assert
.
equal
(
aActual
.
toString
(
)
aExpected
.
url
)
;
Assert
.
equal
(
aActual
.
url
aExpected
.
url
)
;
Assert
.
equal
(
aActual
.
width
aExpected
.
width
)
;
Assert
.
equal
(
aActual
.
height
aExpected
.
height
)
;
Assert
.
equal
(
aActual
.
thumbnailURL
aExpected
.
thumbnailURL
)
;
Assert
.
equal
(
aActual
.
thumbnailWidth
aExpected
.
thumbnailWidth
)
;
Assert
.
equal
(
aActual
.
thumbnailHeight
aExpected
.
thumbnailHeight
)
;
Assert
.
equal
(
aActual
.
caption
aExpected
.
caption
)
;
}
function
do_check_compatibilityoverride
(
aActual
aExpected
)
{
Assert
.
equal
(
aActual
.
type
aExpected
.
type
)
;
Assert
.
equal
(
aActual
.
minVersion
aExpected
.
minVersion
)
;
Assert
.
equal
(
aActual
.
maxVersion
aExpected
.
maxVersion
)
;
Assert
.
equal
(
aActual
.
appID
aExpected
.
appID
)
;
Assert
.
equal
(
aActual
.
appMinVersion
aExpected
.
appMinVersion
)
;
Assert
.
equal
(
aActual
.
appMaxVersion
aExpected
.
appMaxVersion
)
;
}
function
do_check_icons
(
aActual
aExpected
)
{
for
(
var
size
in
aExpected
)
{
Assert
.
equal
(
aActual
[
size
]
aExpected
[
size
]
)
;
}
}
function
isThemeInAddonsList
(
aDir
aId
)
{
return
AddonTestUtils
.
addonsList
.
hasTheme
(
aDir
aId
)
;
}
function
isExtensionInBootstrappedList
(
aDir
aId
)
{
return
AddonTestUtils
.
addonsList
.
hasExtension
(
aDir
aId
)
;
}
function
promiseWriteWebManifestForExtension
(
aData
aDir
aId
=
aData
.
applications
.
gecko
.
id
)
{
let
files
=
{
"
manifest
.
json
"
:
JSON
.
stringify
(
aData
)
}
;
return
AddonTestUtils
.
promiseWriteFilesToExtension
(
aDir
.
path
aId
files
)
;
}
function
hasFlag
(
aBits
aFlag
)
{
return
(
aBits
&
aFlag
)
!
=
0
;
}
class
EventChecker
{
constructor
(
options
)
{
this
.
expectedEvents
=
options
.
addonEvents
|
|
{
}
;
this
.
expectedInstalls
=
options
.
installEvents
|
|
null
;
this
.
ignorePlugins
=
options
.
ignorePlugins
|
|
false
;
this
.
finished
=
new
Promise
(
resolve
=
>
{
this
.
resolveFinished
=
resolve
;
}
)
;
AddonManager
.
addAddonListener
(
this
)
;
if
(
this
.
expectedInstalls
)
{
AddonManager
.
addInstallListener
(
this
)
;
}
}
cleanup
(
)
{
AddonManager
.
removeAddonListener
(
this
)
;
if
(
this
.
expectedInstalls
)
{
AddonManager
.
removeInstallListener
(
this
)
;
}
}
checkValue
(
prop
value
flagName
)
{
if
(
Array
.
isArray
(
flagName
)
)
{
let
names
=
flagName
.
map
(
name
=
>
AddonManager
.
{
name
}
)
;
Assert
.
ok
(
flagName
.
map
(
name
=
>
AddonManager
[
name
]
)
.
includes
(
value
)
{
prop
}
value
\
{
value
}
\
should
be
one
of
[
{
names
.
join
(
"
"
)
}
)
;
}
else
{
Assert
.
equal
(
value
AddonManager
[
flagName
]
{
prop
}
should
have
value
AddonManager
.
{
flagName
}
)
;
}
}
checkFlag
(
prop
value
flagName
)
{
Assert
.
equal
(
value
&
AddonManager
[
flagName
]
AddonManager
[
flagName
]
{
prop
}
should
have
flag
AddonManager
.
{
flagName
}
)
;
}
checkNoFlag
(
prop
value
flagName
)
{
Assert
.
ok
(
!
(
value
&
AddonManager
[
flagName
]
)
{
prop
}
should
not
have
flag
AddonManager
.
{
flagName
}
)
;
}
checkComplete
(
)
{
if
(
this
.
expectedInstalls
&
&
this
.
expectedInstalls
.
length
)
{
return
;
}
if
(
Object
.
values
(
this
.
expectedEvents
)
.
some
(
events
=
>
events
.
length
)
)
{
return
;
}
info
(
"
Test
complete
"
)
;
this
.
cleanup
(
)
;
this
.
resolveFinished
(
)
;
}
ensureComplete
(
)
{
this
.
cleanup
(
)
;
for
(
let
[
id
events
]
of
Object
.
entries
(
this
.
expectedEvents
)
)
{
Assert
.
equal
(
events
.
length
0
Should
have
no
remaining
events
for
{
id
}
)
;
}
if
(
this
.
expectedInstalls
)
{
Assert
.
deepEqual
(
this
.
expectedInstalls
[
]
"
Should
have
no
remaining
install
events
"
)
;
}
}
getExpectedEvent
(
aId
)
{
if
(
!
(
aId
in
this
.
expectedEvents
)
)
{
return
null
;
}
let
events
=
this
.
expectedEvents
[
aId
]
;
Assert
.
ok
(
!
!
events
.
length
Should
be
expecting
events
for
{
aId
}
)
;
return
events
.
shift
(
)
;
}
checkAddonEvent
(
event
addon
details
=
{
}
)
{
info
(
Got
event
"
{
event
}
"
for
add
-
on
{
addon
.
id
}
)
;
if
(
"
requiresRestart
"
in
details
)
{
Assert
.
equal
(
details
.
requiresRestart
false
"
requiresRestart
should
always
be
false
"
)
;
}
let
expected
=
this
.
getExpectedEvent
(
addon
.
id
)
;
if
(
!
expected
)
{
return
undefined
;
}
Assert
.
equal
(
expected
.
event
event
Expecting
event
"
{
expected
.
event
}
"
got
"
{
event
}
"
)
;
for
(
let
prop
of
[
"
properties
"
]
)
{
if
(
prop
in
expected
)
{
Assert
.
deepEqual
(
expected
[
prop
]
details
[
prop
]
Expected
value
for
{
prop
}
)
;
}
}
this
.
checkComplete
(
)
;
if
(
"
returnValue
"
in
expected
)
{
return
expected
.
returnValue
;
}
return
undefined
;
}
onPropertyChanged
(
addon
properties
)
{
return
this
.
checkAddonEvent
(
"
onPropertyChanged
"
addon
{
properties
}
)
;
}
onEnabling
(
addon
requiresRestart
)
{
let
result
=
this
.
checkAddonEvent
(
"
onEnabling
"
addon
{
requiresRestart
}
)
;
this
.
checkNoFlag
(
"
addon
.
permissions
"
addon
.
permissions
"
PERM_CAN_ENABLE
"
)
;
return
result
;
}
onEnabled
(
addon
)
{
let
result
=
this
.
checkAddonEvent
(
"
onEnabled
"
addon
)
;
this
.
checkNoFlag
(
"
addon
.
permissions
"
addon
.
permissions
"
PERM_CAN_ENABLE
"
)
;
return
result
;
}
onDisabling
(
addon
requiresRestart
)
{
let
result
=
this
.
checkAddonEvent
(
"
onDisabling
"
addon
{
requiresRestart
}
)
;
this
.
checkNoFlag
(
"
addon
.
permissions
"
addon
.
permissions
"
PERM_CAN_DISABLE
"
)
;
return
result
;
}
onDisabled
(
addon
)
{
let
result
=
this
.
checkAddonEvent
(
"
onDisabled
"
addon
)
;
this
.
checkNoFlag
(
"
addon
.
permissions
"
addon
.
permissions
"
PERM_CAN_DISABLE
"
)
;
return
result
;
}
onInstalling
(
addon
requiresRestart
)
{
return
this
.
checkAddonEvent
(
"
onInstalling
"
addon
{
requiresRestart
}
)
;
}
onInstalled
(
addon
)
{
return
this
.
checkAddonEvent
(
"
onInstalled
"
addon
)
;
}
onUninstalling
(
addon
requiresRestart
)
{
return
this
.
checkAddonEvent
(
"
onUninstalling
"
addon
)
;
}
onUninstalled
(
addon
)
{
return
this
.
checkAddonEvent
(
"
onUninstalled
"
addon
)
;
}
onOperationCancelled
(
addon
)
{
return
this
.
checkAddonEvent
(
"
onOperationCancelled
"
addon
)
;
}
checkInstall
(
event
install
details
=
{
}
)
{
if
(
this
.
ignorePlugins
&
&
install
.
type
=
=
"
plugin
"
)
{
info
(
Ignoring
install
event
for
plugin
{
install
.
id
}
)
;
return
undefined
;
}
info
(
Got
install
event
"
{
event
}
"
)
;
let
expected
=
this
.
expectedInstalls
.
shift
(
)
;
Assert
.
ok
(
expected
"
Should
be
expecting
install
event
"
)
;
Assert
.
equal
(
expected
.
event
event
"
Should
be
expecting
onExternalInstall
event
"
)
;
if
(
"
state
"
in
details
)
{
this
.
checkValue
(
"
install
.
state
"
install
.
state
details
.
state
)
;
}
this
.
checkComplete
(
)
;
if
(
"
callback
"
in
expected
)
{
expected
.
callback
(
install
)
;
}
if
(
"
returnValue
"
in
expected
)
{
return
expected
.
returnValue
;
}
return
undefined
;
}
onNewInstall
(
install
)
{
let
result
=
this
.
checkInstall
(
"
onNewInstall
"
install
{
state
:
[
"
STATE_DOWNLOADED
"
"
STATE_DOWNLOAD_FAILED
"
"
STATE_AVAILABLE
"
]
}
)
;
if
(
install
.
state
!
=
AddonManager
.
STATE_DOWNLOAD_FAILED
)
{
Assert
.
equal
(
install
.
error
0
"
Should
have
no
error
"
)
;
}
else
{
Assert
.
notEqual
(
install
.
error
0
"
Should
have
error
"
)
;
}
return
result
;
}
onDownloadStarted
(
install
)
{
return
this
.
checkInstall
(
"
onDownloadStarted
"
install
{
state
:
"
STATE_DOWNLOADING
"
error
:
0
}
)
;
}
onDownloadEnded
(
install
)
{
return
this
.
checkInstall
(
"
onDownloadEnded
"
install
{
state
:
"
STATE_DOWNLOADED
"
error
:
0
}
)
;
}
onDownloadFailed
(
install
)
{
return
this
.
checkInstall
(
"
onDownloadFailed
"
install
{
state
:
"
STATE_FAILED
"
}
)
;
}
onDownloadCancelled
(
install
)
{
return
this
.
checkInstall
(
"
onDownloadCancelled
"
install
{
state
:
"
STATE_CANCELLED
"
error
:
0
}
)
;
}
onInstallStarted
(
install
)
{
return
this
.
checkInstall
(
"
onInstallStarted
"
install
{
state
:
"
STATE_INSTALLING
"
error
:
0
}
)
;
}
onInstallEnded
(
install
newAddon
)
{
return
this
.
checkInstall
(
"
onInstallEnded
"
install
{
state
:
"
STATE_INSTALLED
"
error
:
0
}
)
;
}
onInstallFailed
(
install
)
{
return
this
.
checkInstall
(
"
onInstallFailed
"
install
{
state
:
"
STATE_FAILED
"
}
)
;
}
onInstallCancelled
(
install
)
{
return
this
.
checkInstall
(
"
onInstallCancelled
"
install
{
state
:
[
"
STATE_CANCELED
"
"
STATE_DOWNLOADED
"
]
error
:
0
}
)
;
}
onExternalInstall
(
addon
existingAddon
requiresRestart
)
{
if
(
this
.
ignorePlugins
&
&
addon
.
type
=
=
"
plugin
"
)
{
info
(
Ignoring
install
event
for
plugin
{
addon
.
id
}
)
;
return
undefined
;
}
let
expected
=
this
.
expectedInstalls
.
shift
(
)
;
Assert
.
ok
(
expected
"
Should
be
expecting
install
event
"
)
;
Assert
.
equal
(
expected
.
event
"
onExternalInstall
"
"
Should
be
expecting
onExternalInstall
event
"
)
;
Assert
.
ok
(
!
requiresRestart
"
Should
never
require
restart
"
)
;
this
.
checkComplete
(
)
;
if
(
"
returnValue
"
in
expected
)
{
return
expected
.
returnValue
;
}
return
undefined
;
}
}
async
function
expectEvents
(
details
callback
)
{
let
checker
=
new
EventChecker
(
details
)
;
try
{
let
result
=
callback
(
)
;
if
(
result
&
&
typeof
result
=
=
=
"
object
"
&
&
typeof
result
.
then
=
=
=
"
function
"
)
{
result
=
await
result
;
checker
.
ensureComplete
(
)
;
}
else
{
await
checker
.
finished
;
}
return
result
;
}
catch
(
e
)
{
do_throw
(
e
)
;
return
undefined
;
}
}
const
EXTENSIONS_DB
=
"
extensions
.
json
"
;
var
gExtensionsJSON
=
gProfD
.
clone
(
)
;
gExtensionsJSON
.
append
(
EXTENSIONS_DB
)
;
async
function
promiseInstallWebExtension
(
aData
)
{
let
addonFile
=
createTempWebExtensionFile
(
aData
)
;
let
{
addon
}
=
await
promiseInstallFile
(
addonFile
)
;
return
addon
;
}
Services
.
prefs
.
setBoolPref
(
"
extensions
.
strictCompatibility
"
true
)
;
Services
.
prefs
.
setBoolPref
(
PREF_XPI_SIGNATURES_REQUIRED
true
)
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
legacy
.
enabled
"
true
)
;
function
copyBlocklistToProfile
(
blocklistFile
)
{
var
dest
=
gProfD
.
clone
(
)
;
dest
.
append
(
"
blocklist
.
xml
"
)
;
if
(
dest
.
exists
(
)
)
{
dest
.
remove
(
false
)
;
}
blocklistFile
.
copyTo
(
gProfD
"
blocklist
.
xml
"
)
;
dest
.
lastModifiedTime
=
Date
.
now
(
)
;
}
async
function
mockGfxBlocklistItemsFromDisk
(
path
)
{
Cu
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
let
response
=
await
fetch
(
Services
.
io
.
newFileURI
(
do_get_file
(
path
)
)
.
spec
)
;
let
json
=
await
response
.
json
(
)
;
return
mockGfxBlocklistItems
(
json
)
;
}
async
function
mockGfxBlocklistItems
(
items
)
{
const
{
generateUUID
}
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
let
bsPass
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Blocklist
.
jsm
"
null
)
;
const
client
=
RemoteSettings
(
Services
.
prefs
.
getCharPref
(
"
services
.
blocklist
.
gfx
.
collection
"
)
{
bucketNamePref
:
"
services
.
blocklist
.
bucket
"
}
)
;
const
collection
=
await
client
.
openCollection
(
)
;
await
collection
.
clear
(
)
;
await
collection
.
loadDump
(
items
.
map
(
item
=
>
{
if
(
item
.
id
&
&
item
.
last_modified
)
{
return
item
;
}
return
Object
.
assign
(
{
id
:
generateUUID
(
)
.
toString
(
)
.
replace
(
/
[
{
}
]
/
g
"
"
)
last_modified
:
Date
.
now
(
)
}
item
)
;
}
)
)
;
let
rv
=
await
bsPass
.
GfxBlocklistRS
.
checkForEntries
(
)
;
return
rv
;
}
async
function
changeXPIDBVersion
(
aNewVersion
)
{
let
json
=
await
loadJSON
(
gExtensionsJSON
.
path
)
;
json
.
schemaVersion
=
aNewVersion
;
await
saveJSON
(
json
gExtensionsJSON
.
path
)
;
}
async
function
loadFile
(
aFile
)
{
let
buffer
=
await
OS
.
File
.
read
(
aFile
)
;
return
new
TextDecoder
(
)
.
decode
(
buffer
)
;
}
async
function
loadJSON
(
aFile
)
{
let
data
=
await
loadFile
(
aFile
)
;
info
(
"
Loaded
JSON
file
"
+
aFile
)
;
return
JSON
.
parse
(
data
)
;
}
async
function
saveJSON
(
aData
aFile
)
{
info
(
"
Starting
to
save
JSON
file
"
+
aFile
)
;
await
OS
.
File
.
writeAtomic
(
aFile
new
TextEncoder
(
)
.
encode
(
JSON
.
stringify
(
aData
null
2
)
)
)
;
info
(
"
Done
saving
JSON
file
"
+
aFile
.
path
)
;
}
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
pluginHost
"
"
mozilla
.
org
/
plugin
/
host
;
1
"
"
nsIPluginHost
"
)
;
class
MockPluginTag
{
constructor
(
opts
enabledState
=
Ci
.
nsIPluginTag
.
STATE_ENABLED
)
{
this
.
pluginTag
=
pluginHost
.
createFakePlugin
(
{
handlerURI
:
"
resource
:
/
/
fake
-
plugin
/
{
Math
.
random
(
)
}
.
xhtml
"
mimeEntries
:
[
{
type
:
"
application
/
x
-
fake
-
plugin
"
}
]
fileName
:
{
opts
.
name
}
.
so
.
.
.
opts
}
)
;
this
.
pluginTag
.
enabledState
=
enabledState
;
this
.
name
=
opts
.
name
;
this
.
version
=
opts
.
version
;
}
async
isBlocklisted
(
)
{
let
state
=
await
Blocklist
.
getPluginBlocklistState
(
this
.
pluginTag
)
;
return
state
=
=
Services
.
blocklist
.
STATE_BLOCKED
;
}
get
disabled
(
)
{
return
this
.
pluginTag
.
enabledState
=
=
Ci
.
nsIPluginTag
.
STATE_DISABLED
;
}
set
disabled
(
val
)
{
this
.
enabledState
=
Ci
.
nsIPluginTag
[
val
?
"
STATE_DISABLED
"
:
"
STATE_ENABLED
"
]
;
}
get
enabledState
(
)
{
return
this
.
pluginTag
.
enabledState
;
}
set
enabledState
(
val
)
{
this
.
pluginTag
.
enabledState
=
val
;
}
}
function
mockPluginHost
(
plugins
)
{
let
PluginHost
=
{
getPluginTags
(
)
{
return
plugins
.
map
(
p
=
>
p
.
pluginTag
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIPluginHost
"
]
)
}
;
MockRegistrar
.
register
(
"
mozilla
.
org
/
plugin
/
host
;
1
"
PluginHost
)
;
}
async
function
setInitialState
(
addon
initialState
)
{
if
(
initialState
.
userDisabled
)
{
await
addon
.
disable
(
)
;
}
else
if
(
initialState
.
userDisabled
=
=
=
false
)
{
await
addon
.
enable
(
)
;
}
}
async
function
installBuiltinExtension
(
extensionData
)
{
let
xpi
=
await
AddonTestUtils
.
createTempWebExtensionFile
(
extensionData
)
;
let
base
=
Services
.
io
.
newURI
(
jar
:
file
:
{
xpi
.
path
}
!
/
)
;
let
resProto
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
resProto
.
setSubstitution
(
"
ext
-
test
"
base
)
;
let
id
=
extensionData
.
manifest
.
applications
.
gecko
.
id
;
let
wrapper
=
ExtensionTestUtils
.
expectExtension
(
id
)
;
await
AddonManager
.
installBuiltinAddon
(
"
resource
:
/
/
ext
-
test
/
"
)
;
await
wrapper
.
awaitStartup
(
)
;
return
wrapper
;
}
