if
(
!
_TEST_FILE
[
0
]
.
includes
(
"
toolkit
/
mozapps
/
extensions
/
test
/
xpcshell
/
"
)
)
{
ok
(
false
(
"
head_addons
.
js
may
not
be
loaded
by
tests
outside
of
"
+
"
the
add
-
on
manager
component
.
"
)
)
;
}
Cu
.
importGlobalProperties
(
[
"
TextEncoder
"
]
)
;
const
PREF_EM_CHECK_UPDATE_SECURITY
=
"
extensions
.
checkUpdateSecurity
"
;
const
PREF_EM_STRICT_COMPATIBILITY
=
"
extensions
.
strictCompatibility
"
;
const
PREF_GETADDONS_BYIDS
=
"
extensions
.
getAddons
.
get
.
url
"
;
const
PREF_COMPAT_OVERRIDES
=
"
extensions
.
getAddons
.
compatOverides
.
url
"
;
const
PREF_XPI_SIGNATURES_REQUIRED
=
"
xpinstall
.
signatures
.
required
"
;
const
PREF_SYSTEM_ADDON_SET
=
"
extensions
.
systemAddonSet
"
;
const
PREF_SYSTEM_ADDON_UPDATE_URL
=
"
extensions
.
systemAddon
.
update
.
url
"
;
const
PREF_SYSTEM_ADDON_UPDATE_ENABLED
=
"
extensions
.
systemAddon
.
update
.
enabled
"
;
const
PREF_DISABLE_SECURITY
=
(
"
security
.
turn_off_all_security_so_that_
"
+
"
viruses_can_take_over_this_computer
"
)
;
const
TIMEOUT_MS
=
900000
;
const
MAX_TIME_DIFFERENCE
=
3000
;
const
MAKE_FILE_OLD_DIFFERENCE
=
10
*
3600
*
1000
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonRepository
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Blocklist
"
"
resource
:
/
/
gre
/
modules
/
Blocklist
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Extension
"
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionTestUtils
"
"
resource
:
/
/
testing
-
common
/
ExtensionXPCShellUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionTestCommon
"
"
resource
:
/
/
testing
-
common
/
ExtensionTestCommon
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
HttpServer
"
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MockAsyncShutdown
"
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MockCrashReporter
"
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MockRegistrar
"
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MockRegistry
"
"
resource
:
/
/
testing
-
common
/
MockRegistry
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromiseTestUtils
"
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TestUtils
"
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
aomStartup
"
"
mozilla
.
org
/
addons
/
addon
-
manager
-
startup
;
1
"
"
amIAddonManagerStartup
"
)
;
const
{
createAppInfo
createHttpServer
createInstallRDF
createTempWebExtensionFile
createUpdateRDF
getFileForAddon
manuallyInstall
manuallyUninstall
overrideBuiltIns
promiseAddonEvent
promiseCompleteAllInstalls
promiseCompleteInstall
promiseConsoleOutput
promiseFindAddonUpdates
promiseInstallAllFiles
promiseInstallFile
promiseRestartManager
promiseSetExtensionModifiedTime
promiseShutdownManager
promiseStartupManager
promiseWebExtensionStartup
promiseWriteProxyFileToDir
registerDirectory
setExtensionModifiedTime
writeFilesToZip
}
=
AddonTestUtils
;
ExtensionTestUtils
.
init
(
this
)
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
BOOTSTRAP_REASONS
"
(
)
=
>
AddonManagerPrivate
.
BOOTSTRAP_REASONS
)
;
function
getReasonName
(
reason
)
{
for
(
let
key
of
Object
.
keys
(
BOOTSTRAP_REASONS
)
)
{
if
(
BOOTSTRAP_REASONS
[
key
]
=
=
reason
)
{
return
key
;
}
}
throw
new
Error
(
"
This
shouldn
'
t
happen
.
"
)
;
}
Object
.
defineProperty
(
this
"
gAppInfo
"
{
get
(
)
{
return
AddonTestUtils
.
appInfo
;
}
}
)
;
Object
.
defineProperty
(
this
"
gAddonStartup
"
{
get
(
)
{
return
AddonTestUtils
.
addonStartup
.
clone
(
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gInternalManager
"
{
get
(
)
{
return
AddonTestUtils
.
addonIntegrationService
.
QueryInterface
(
Ci
.
nsITimerCallback
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gProfD
"
{
get
(
)
{
return
AddonTestUtils
.
profileDir
.
clone
(
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gTmpD
"
{
get
(
)
{
return
AddonTestUtils
.
tempDir
.
clone
(
)
;
}
}
)
;
Object
.
defineProperty
(
this
"
gUseRealCertChecks
"
{
get
(
)
{
return
AddonTestUtils
.
useRealCertChecks
;
}
set
(
val
)
{
return
AddonTestUtils
.
useRealCertChecks
=
val
;
}
}
)
;
Object
.
defineProperty
(
this
"
TEST_UNPACKED
"
{
get
(
)
{
return
AddonTestUtils
.
testUnpacked
;
}
set
(
val
)
{
return
AddonTestUtils
.
testUnpacked
=
val
;
}
}
)
;
var
AMscope
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
{
}
)
;
var
{
AddonManager
AddonManagerInternal
AddonManagerPrivate
}
=
AMscope
;
const
promiseAddonByID
=
AddonManager
.
getAddonByID
;
const
promiseAddonsByIDs
=
AddonManager
.
getAddonsByIDs
;
var
gPort
=
null
;
var
gUrlToFileMap
=
{
}
;
var
resHandler
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsISubstitutingProtocolHandler
)
;
var
dataURI
=
NetUtil
.
newURI
(
do_get_file
(
"
data
"
true
)
)
;
resHandler
.
setSubstitution
(
"
xpcshell
-
data
"
dataURI
)
;
function
isManifestRegistered
(
file
)
{
let
manifests
=
Components
.
manager
.
getManifestLocations
(
)
;
for
(
let
i
=
0
;
i
<
manifests
.
length
;
i
+
+
)
{
let
manifest
=
manifests
.
queryElementAt
(
i
Ci
.
nsIURI
)
;
if
(
manifest
instanceof
Ci
.
nsIJARURI
)
{
manifest
=
manifest
.
JARFile
.
QueryInterface
(
Ci
.
nsIFileURL
)
.
file
;
}
else
if
(
manifest
instanceof
Ci
.
nsIFileURL
)
{
manifest
=
manifest
.
file
.
parent
;
}
else
{
continue
;
}
if
(
manifest
.
equals
(
file
)
)
return
true
;
}
return
false
;
}
const
BOOTSTRAP_MONITOR_BOOTSTRAP_JS
=
ChromeUtils
.
import
(
"
resource
:
/
/
xpcshell
-
data
/
BootstrapMonitor
.
jsm
"
)
.
monitor
(
this
)
;
;
const
EMPTY_BOOTSTRAP_JS
=
function
startup
(
)
{
}
function
shutdown
(
)
{
}
function
install
(
)
{
}
function
uninstall
(
)
{
}
;
this
.
BootstrapMonitor
=
{
inited
:
false
installed
:
new
Map
(
)
started
:
new
Map
(
)
stopped
:
new
Map
(
)
uninstalled
:
new
Map
(
)
startupPromises
:
[
]
installPromises
:
[
]
restartfulIds
:
new
Set
(
)
init
(
)
{
this
.
inited
=
true
;
Services
.
obs
.
addObserver
(
this
"
bootstrapmonitor
-
event
"
)
;
}
shutdownCheck
(
)
{
if
(
!
this
.
inited
)
return
;
Assert
.
equal
(
this
.
started
.
size
0
)
;
}
clear
(
id
)
{
this
.
installed
.
delete
(
id
)
;
this
.
started
.
delete
(
id
)
;
this
.
stopped
.
delete
(
id
)
;
this
.
uninstalled
.
delete
(
id
)
;
}
promiseAddonStartup
(
id
)
{
return
new
Promise
(
resolve
=
>
{
this
.
startupPromises
.
push
(
resolve
)
;
}
)
;
}
promiseAddonInstall
(
id
)
{
return
new
Promise
(
resolve
=
>
{
this
.
installPromises
.
push
(
resolve
)
;
}
)
;
}
checkMatches
(
cached
current
)
{
Assert
.
notEqual
(
cached
undefined
)
;
Assert
.
equal
(
current
.
data
.
version
cached
.
data
.
version
)
;
Assert
.
equal
(
current
.
data
.
installPath
cached
.
data
.
installPath
)
;
Assert
.
ok
(
Services
.
io
.
newURI
(
current
.
data
.
resourceURI
)
.
equals
(
Services
.
io
.
newURI
(
cached
.
data
.
resourceURI
)
)
Resource
URIs
match
:
"
{
current
.
data
.
resourceURI
}
"
=
=
"
{
cached
.
data
.
resourceURI
}
"
)
;
}
checkAddonStarted
(
id
version
=
undefined
)
{
let
started
=
this
.
started
.
get
(
id
)
;
Assert
.
notEqual
(
started
undefined
)
;
if
(
version
!
=
undefined
)
Assert
.
equal
(
started
.
data
.
version
version
)
;
let
installPath
=
new
FileUtils
.
File
(
started
.
data
.
installPath
)
;
let
isRegistered
=
isManifestRegistered
(
installPath
)
;
Assert
.
ok
(
isRegistered
)
;
}
checkAddonNotStarted
(
id
)
{
Assert
.
ok
(
!
this
.
started
.
has
(
id
)
)
;
}
checkAddonInstalled
(
id
version
=
undefined
)
{
const
installed
=
this
.
installed
.
get
(
id
)
;
notEqual
(
installed
undefined
)
;
if
(
version
!
=
=
undefined
)
{
equal
(
installed
.
data
.
version
version
)
;
}
return
installed
;
}
checkAddonNotInstalled
(
id
)
{
Assert
.
ok
(
!
this
.
installed
.
has
(
id
)
)
;
}
observe
(
subject
topic
data
)
{
let
info
=
JSON
.
parse
(
data
)
;
let
id
=
info
.
data
.
id
;
let
installPath
=
new
FileUtils
.
File
(
info
.
data
.
installPath
)
;
if
(
subject
&
&
subject
.
wrappedJSObject
)
{
info
.
data
=
Object
.
assign
(
{
}
subject
.
wrappedJSObject
.
data
{
installPath
:
info
.
data
.
installPath
resourceURI
:
info
.
data
.
resourceURI
}
)
;
}
if
(
info
.
event
=
=
"
install
"
)
{
this
.
checkAddonNotInstalled
(
id
)
;
this
.
installed
.
set
(
id
info
)
;
for
(
let
resolve
of
this
.
installPromises
)
resolve
(
)
;
this
.
installPromises
=
[
]
;
}
else
{
this
.
checkMatches
(
this
.
installed
.
get
(
id
)
info
)
;
}
if
(
info
.
event
=
=
"
shutdown
"
)
{
this
.
checkMatches
(
this
.
started
.
get
(
id
)
info
)
;
this
.
started
.
delete
(
id
)
;
this
.
stopped
.
set
(
id
info
)
;
let
isRegistered
=
isManifestRegistered
(
installPath
)
;
Assert
.
ok
(
isRegistered
)
;
if
(
info
.
reason
=
=
2
)
Components
.
manager
.
removeBootstrappedManifestLocation
(
installPath
)
;
}
else
{
this
.
checkAddonNotStarted
(
id
)
;
}
if
(
info
.
event
=
=
"
uninstall
"
)
{
if
(
!
this
.
restartfulIds
.
has
(
id
)
)
{
let
isRegistered
=
isManifestRegistered
(
installPath
)
;
Assert
.
ok
(
!
isRegistered
)
;
}
this
.
installed
.
delete
(
id
)
;
this
.
uninstalled
.
set
(
id
info
)
;
}
else
if
(
info
.
event
=
=
"
startup
"
)
{
this
.
started
.
set
(
id
info
)
;
let
isRegistered
=
isManifestRegistered
(
installPath
)
;
Assert
.
ok
(
isRegistered
)
;
for
(
let
resolve
of
this
.
startupPromises
)
resolve
(
)
;
this
.
startupPromises
=
[
]
;
}
}
}
;
AddonTestUtils
.
on
(
"
addon
-
manager
-
shutdown
"
(
)
=
>
BootstrapMonitor
.
shutdownCheck
(
)
)
;
var
SlightlyLessDodgyBootstrapMonitor
=
{
started
:
new
Map
(
)
stopped
:
new
Map
(
)
installed
:
new
Map
(
)
uninstalled
:
new
Map
(
)
init
(
)
{
this
.
onEvent
=
this
.
onEvent
.
bind
(
this
)
;
AddonTestUtils
.
on
(
"
addon
-
manager
-
shutdown
"
this
.
onEvent
)
;
AddonTestUtils
.
on
(
"
bootstrap
-
method
"
this
.
onEvent
)
;
}
shutdownCheck
(
)
{
equal
(
this
.
started
.
size
0
"
Should
have
no
add
-
ons
that
were
started
but
not
shutdown
"
)
;
}
onEvent
(
msg
data
)
{
switch
(
msg
)
{
case
"
addon
-
manager
-
shutdown
"
:
this
.
shutdownCheck
(
)
;
break
;
case
"
bootstrap
-
method
"
:
this
.
onBootstrapMethod
(
data
.
method
data
.
params
data
.
reason
)
;
break
;
}
}
onBootstrapMethod
(
method
params
reason
)
{
let
{
id
}
=
params
;
info
(
Bootstrap
method
{
method
}
for
{
params
.
id
}
version
{
params
.
version
}
)
;
if
(
method
!
=
=
"
install
"
)
{
this
.
checkInstalled
(
id
)
;
}
switch
(
method
)
{
case
"
install
"
:
this
.
checkNotInstalled
(
id
)
;
this
.
installed
.
set
(
id
{
reason
params
}
)
;
this
.
uninstalled
.
delete
(
id
)
;
break
;
case
"
startup
"
:
this
.
checkNotStarted
(
id
)
;
this
.
started
.
set
(
id
{
reason
params
}
)
;
this
.
stopped
.
delete
(
id
)
;
break
;
case
"
shutdown
"
:
this
.
checkMatches
(
"
shutdown
"
"
startup
"
params
this
.
started
.
get
(
id
)
)
;
this
.
checkStarted
(
id
)
;
this
.
stopped
.
set
(
id
{
reason
params
}
)
;
this
.
started
.
delete
(
id
)
;
break
;
case
"
uninstall
"
:
this
.
checkMatches
(
"
uninstall
"
"
install
"
params
this
.
installed
.
get
(
id
)
)
;
this
.
uninstalled
.
set
(
id
{
reason
params
}
)
;
this
.
installed
.
delete
(
id
)
;
break
;
case
"
update
"
:
this
.
checkMatches
(
"
update
"
"
install
"
params
this
.
installed
.
get
(
id
)
)
;
this
.
installed
.
set
(
id
{
reason
params
}
)
;
break
;
}
}
clear
(
id
)
{
this
.
installed
.
delete
(
id
)
;
this
.
started
.
delete
(
id
)
;
this
.
stopped
.
delete
(
id
)
;
this
.
uninstalled
.
delete
(
id
)
;
}
checkMatches
(
method
lastMethod
params
{
params
:
lastParams
}
=
{
}
)
{
ok
(
lastParams
Expecting
matching
{
lastMethod
}
call
for
add
-
on
{
params
.
id
}
{
method
}
call
)
;
if
(
method
=
=
"
update
"
)
{
equal
(
params
.
oldVersion
lastParams
.
version
"
params
.
version
should
match
last
call
"
)
;
}
else
{
equal
(
params
.
version
lastParams
.
version
"
params
.
version
should
match
last
call
"
)
;
}
if
(
method
!
=
=
"
update
"
&
&
method
!
=
=
"
uninstall
"
)
{
equal
(
params
.
installPath
.
path
lastParams
.
installPath
.
path
params
.
installPath
should
match
last
call
)
;
ok
(
params
.
resourceURI
.
equals
(
lastParams
.
resourceURI
)
params
.
resourceURI
should
match
:
"
{
params
.
resourceURI
.
spec
}
"
=
=
"
{
lastParams
.
resourceURI
.
spec
}
"
)
;
}
}
checkStarted
(
id
version
=
undefined
)
{
let
started
=
this
.
started
.
get
(
id
)
;
ok
(
started
Should
have
seen
startup
method
call
for
{
id
}
)
;
if
(
version
!
=
=
undefined
)
equal
(
started
.
params
.
version
version
"
Expected
version
number
"
)
;
}
checkNotStarted
(
id
)
{
ok
(
!
this
.
started
.
has
(
id
)
Should
not
have
seen
startup
method
call
for
{
id
}
)
;
}
checkInstalled
(
id
version
=
undefined
)
{
const
installed
=
this
.
installed
.
get
(
id
)
;
ok
(
installed
Should
have
seen
install
call
for
{
id
}
)
;
if
(
version
!
=
=
undefined
)
equal
(
installed
.
params
.
version
version
"
Expected
version
number
"
)
;
return
installed
;
}
checkNotInstalled
(
id
)
{
ok
(
!
this
.
installed
.
has
(
id
)
Should
not
have
seen
install
method
call
for
{
id
}
)
;
}
}
;
function
isNightlyChannel
(
)
{
var
channel
=
Services
.
prefs
.
getCharPref
(
"
app
.
update
.
channel
"
"
default
"
)
;
return
channel
!
=
"
aurora
"
&
&
channel
!
=
"
beta
"
&
&
channel
!
=
"
release
"
&
&
channel
!
=
"
esr
"
;
}
async
function
restartWithLocales
(
locales
)
{
Services
.
locale
.
setRequestedLocales
(
locales
)
;
await
promiseRestartManager
(
)
;
}
async
function
getAddons
(
ids
)
{
let
addons
=
new
Map
(
)
;
for
(
let
addon
of
await
AddonManager
.
getAddonsByIDs
(
ids
)
)
{
if
(
addon
)
{
addons
.
set
(
addon
.
id
addon
)
;
}
}
return
addons
;
}
function
checkAddon
(
id
addon
expected
)
{
info
(
Checking
state
of
addon
{
id
}
)
;
if
(
expected
=
=
=
null
)
{
ok
(
!
addon
Addon
{
id
}
should
not
exist
)
;
}
else
{
ok
(
addon
Addon
{
id
}
should
exist
)
;
for
(
let
[
key
value
]
of
Object
.
entries
(
expected
)
)
{
if
(
value
instanceof
Ci
.
nsIURI
)
{
equal
(
addon
[
key
]
&
&
addon
[
key
]
.
spec
value
.
spec
Expected
value
of
addon
.
{
key
}
)
;
}
else
{
deepEqual
(
addon
[
key
]
value
Expected
value
of
addon
.
{
key
}
)
;
}
}
}
}
function
do_check_in_crash_annotation
(
aId
aVersion
)
{
if
(
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
;
}
const
annotation
=
MockCrashReporter
.
annotations
.
Addons
;
if
(
!
(
annotation
in
MockCrashReporter
.
currentAnnotations
)
)
{
Assert
.
equal
(
false
true
)
;
return
;
}
let
addons
=
MockCrashReporter
.
currentAnnotations
[
annotation
]
.
split
(
"
"
)
;
Assert
.
ok
(
addons
.
includes
(
{
encodeURIComponent
(
aId
)
}
:
{
encodeURIComponent
(
aVersion
)
}
)
)
;
}
function
do_check_not_in_crash_annotation
(
aId
aVersion
)
{
if
(
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
;
}
const
annotation
=
MockCrashReporter
.
annotations
.
Addons
;
if
(
!
(
annotation
in
MockCrashReporter
.
currentAnnotations
)
)
{
Assert
.
ok
(
true
)
;
return
;
}
let
addons
=
MockCrashReporter
.
currentAnnotations
[
annotation
]
.
split
(
"
"
)
;
Assert
.
ok
(
!
addons
.
includes
(
{
encodeURIComponent
(
aId
)
}
:
{
encodeURIComponent
(
aVersion
)
}
)
)
;
}
function
do_get_file_hash
(
aFile
aAlgorithm
)
{
if
(
!
aAlgorithm
)
aAlgorithm
=
"
sha1
"
;
let
crypto
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
crypto
.
initWithString
(
aAlgorithm
)
;
let
fis
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fis
.
init
(
aFile
-
1
-
1
false
)
;
crypto
.
updateFromStream
(
fis
aFile
.
fileSize
)
;
let
toHexString
=
charCode
=
>
(
"
0
"
+
charCode
.
toString
(
16
)
)
.
slice
(
-
2
)
;
let
binary
=
crypto
.
finish
(
false
)
;
let
hash
=
Array
.
from
(
binary
c
=
>
toHexString
(
c
.
charCodeAt
(
0
)
)
)
;
return
aAlgorithm
+
"
:
"
+
hash
.
join
(
"
"
)
;
}
function
do_get_addon_root_uri
(
aProfileDir
aId
)
{
let
path
=
aProfileDir
.
clone
(
)
;
path
.
append
(
aId
)
;
if
(
!
path
.
exists
(
)
)
{
path
.
leafName
+
=
"
.
xpi
"
;
return
"
jar
:
"
+
Services
.
io
.
newFileURI
(
path
)
.
spec
+
"
!
/
"
;
}
return
Services
.
io
.
newFileURI
(
path
)
.
spec
;
}
function
do_get_expected_addon_name
(
aId
)
{
if
(
TEST_UNPACKED
)
return
aId
;
return
aId
+
"
.
xpi
"
;
}
function
do_check_addons
(
aActualAddons
aExpectedAddons
aProperties
)
{
Assert
.
notEqual
(
aActualAddons
null
)
;
Assert
.
equal
(
aActualAddons
.
length
aExpectedAddons
.
length
)
;
for
(
let
i
=
0
;
i
<
aActualAddons
.
length
;
i
+
+
)
do_check_addon
(
aActualAddons
[
i
]
aExpectedAddons
[
i
]
aProperties
)
;
}
function
do_check_addon
(
aActualAddon
aExpectedAddon
aProperties
)
{
Assert
.
notEqual
(
aActualAddon
null
)
;
aProperties
.
forEach
(
function
(
aProperty
)
{
let
actualValue
=
aActualAddon
[
aProperty
]
;
let
expectedValue
=
aExpectedAddon
[
aProperty
]
;
if
(
!
(
aProperty
in
aExpectedAddon
)
)
{
if
(
actualValue
!
=
=
undefined
&
&
actualValue
!
=
=
null
)
{
do_throw
(
"
Unexpected
defined
/
non
-
null
property
for
add
-
on
"
+
aExpectedAddon
.
id
+
"
(
addon
[
"
+
aProperty
+
"
]
=
"
+
actualValue
.
toSource
(
)
+
"
)
"
)
;
}
return
;
}
else
if
(
expectedValue
&
&
!
actualValue
)
{
do_throw
(
"
Missing
property
for
add
-
on
"
+
aExpectedAddon
.
id
+
"
:
expected
addon
[
"
+
aProperty
+
"
]
=
"
+
expectedValue
)
;
return
;
}
switch
(
aProperty
)
{
case
"
creator
"
:
do_check_author
(
actualValue
expectedValue
)
;
break
;
case
"
developers
"
:
case
"
translators
"
:
case
"
contributors
"
:
Assert
.
equal
(
actualValue
.
length
expectedValue
.
length
)
;
for
(
let
i
=
0
;
i
<
actualValue
.
length
;
i
+
+
)
do_check_author
(
actualValue
[
i
]
expectedValue
[
i
]
)
;
break
;
case
"
screenshots
"
:
Assert
.
equal
(
actualValue
.
length
expectedValue
.
length
)
;
for
(
let
i
=
0
;
i
<
actualValue
.
length
;
i
+
+
)
do_check_screenshot
(
actualValue
[
i
]
expectedValue
[
i
]
)
;
break
;
case
"
sourceURI
"
:
Assert
.
equal
(
actualValue
.
spec
expectedValue
)
;
break
;
case
"
updateDate
"
:
Assert
.
equal
(
actualValue
.
getTime
(
)
expectedValue
.
getTime
(
)
)
;
break
;
case
"
compatibilityOverrides
"
:
Assert
.
equal
(
actualValue
.
length
expectedValue
.
length
)
;
for
(
let
i
=
0
;
i
<
actualValue
.
length
;
i
+
+
)
do_check_compatibilityoverride
(
actualValue
[
i
]
expectedValue
[
i
]
)
;
break
;
case
"
icons
"
:
do_check_icons
(
actualValue
expectedValue
)
;
break
;
default
:
if
(
actualValue
!
=
=
expectedValue
)
do_throw
(
"
Failed
for
"
+
aProperty
+
"
for
add
-
on
"
+
aExpectedAddon
.
id
+
"
(
"
+
actualValue
+
"
=
=
=
"
+
expectedValue
+
"
)
"
)
;
}
}
)
;
}
function
do_check_author
(
aActual
aExpected
)
{
Assert
.
equal
(
aActual
.
toString
(
)
aExpected
.
name
)
;
Assert
.
equal
(
aActual
.
name
aExpected
.
name
)
;
Assert
.
equal
(
aActual
.
url
aExpected
.
url
)
;
}
function
do_check_screenshot
(
aActual
aExpected
)
{
Assert
.
equal
(
aActual
.
toString
(
)
aExpected
.
url
)
;
Assert
.
equal
(
aActual
.
url
aExpected
.
url
)
;
Assert
.
equal
(
aActual
.
width
aExpected
.
width
)
;
Assert
.
equal
(
aActual
.
height
aExpected
.
height
)
;
Assert
.
equal
(
aActual
.
thumbnailURL
aExpected
.
thumbnailURL
)
;
Assert
.
equal
(
aActual
.
thumbnailWidth
aExpected
.
thumbnailWidth
)
;
Assert
.
equal
(
aActual
.
thumbnailHeight
aExpected
.
thumbnailHeight
)
;
Assert
.
equal
(
aActual
.
caption
aExpected
.
caption
)
;
}
function
do_check_compatibilityoverride
(
aActual
aExpected
)
{
Assert
.
equal
(
aActual
.
type
aExpected
.
type
)
;
Assert
.
equal
(
aActual
.
minVersion
aExpected
.
minVersion
)
;
Assert
.
equal
(
aActual
.
maxVersion
aExpected
.
maxVersion
)
;
Assert
.
equal
(
aActual
.
appID
aExpected
.
appID
)
;
Assert
.
equal
(
aActual
.
appMinVersion
aExpected
.
appMinVersion
)
;
Assert
.
equal
(
aActual
.
appMaxVersion
aExpected
.
appMaxVersion
)
;
}
function
do_check_icons
(
aActual
aExpected
)
{
for
(
var
size
in
aExpected
)
{
Assert
.
equal
(
aActual
[
size
]
aExpected
[
size
]
)
;
}
}
function
isThemeInAddonsList
(
aDir
aId
)
{
return
AddonTestUtils
.
addonsList
.
hasTheme
(
aDir
aId
)
;
}
function
isExtensionInBootstrappedList
(
aDir
aId
)
{
return
AddonTestUtils
.
addonsList
.
hasExtension
(
aDir
aId
)
;
}
function
check_startup_changes
(
aType
aIds
)
{
var
ids
=
aIds
.
slice
(
0
)
;
ids
.
sort
(
)
;
var
changes
=
AddonManager
.
getStartupChanges
(
aType
)
;
changes
=
changes
.
filter
(
aEl
=
>
/
tests
.
mozilla
.
org
/
.
test
(
aEl
)
)
;
changes
.
sort
(
)
;
Assert
.
equal
(
JSON
.
stringify
(
ids
)
JSON
.
stringify
(
changes
)
)
;
}
async
function
promiseWriteInstallRDFToDir
(
aData
aDir
aId
=
aData
.
id
aExtraFile
=
null
)
{
let
files
=
{
"
install
.
rdf
"
:
AddonTestUtils
.
createInstallRDF
(
aData
)
}
;
if
(
typeof
aExtraFile
=
=
=
"
object
"
)
Object
.
assign
(
files
aExtraFile
)
;
else
files
[
aExtraFile
]
=
"
"
;
let
dir
=
aDir
.
clone
(
)
;
dir
.
append
(
aId
)
;
await
AddonTestUtils
.
promiseWriteFilesToDir
(
dir
.
path
files
)
;
return
dir
;
}
async
function
promiseWriteInstallRDFToXPI
(
aData
aDir
aId
=
aData
.
id
aExtraFile
=
null
)
{
let
files
=
{
"
install
.
rdf
"
:
AddonTestUtils
.
createInstallRDF
(
aData
)
}
;
if
(
typeof
aExtraFile
=
=
=
"
object
"
)
Object
.
assign
(
files
aExtraFile
)
;
else
if
(
aExtraFile
)
files
[
aExtraFile
]
=
"
"
;
if
(
!
aDir
.
exists
(
)
)
aDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
var
file
=
aDir
.
clone
(
)
;
file
.
append
(
{
aId
}
.
xpi
)
;
AddonTestUtils
.
writeFilesToZip
(
file
.
path
files
)
;
return
file
;
}
function
promiseWriteInstallRDFForExtension
(
aData
aDir
aId
aExtraFile
)
{
if
(
TEST_UNPACKED
)
{
return
promiseWriteInstallRDFToDir
(
aData
aDir
aId
aExtraFile
)
;
}
return
promiseWriteInstallRDFToXPI
(
aData
aDir
aId
aExtraFile
)
;
}
function
promiseWriteWebManifestForExtension
(
aData
aDir
aId
=
aData
.
applications
.
gecko
.
id
)
{
let
files
=
{
"
manifest
.
json
"
:
JSON
.
stringify
(
aData
)
}
;
return
AddonTestUtils
.
promiseWriteFilesToExtension
(
aDir
.
path
aId
files
)
;
}
function
createTempXPIFile
(
aData
aExtraFile
)
{
let
files
=
{
"
install
.
rdf
"
:
aData
}
;
if
(
typeof
aExtraFile
=
=
"
object
"
)
Object
.
assign
(
files
aExtraFile
)
;
else
if
(
aExtraFile
)
files
[
aExtraFile
]
=
"
"
;
return
AddonTestUtils
.
createTempXPIFile
(
files
)
;
}
function
promiseInstallXPI
(
installRDF
)
{
return
AddonTestUtils
.
promiseInstallXPI
(
{
"
install
.
rdf
"
:
installRDF
}
)
;
}
var
gExpectedEvents
=
{
}
;
var
gExpectedInstalls
=
[
]
;
var
gNext
=
null
;
function
getExpectedEvent
(
aId
)
{
if
(
!
(
aId
in
gExpectedEvents
)
)
do_throw
(
"
Wasn
'
t
expecting
events
for
"
+
aId
)
;
if
(
gExpectedEvents
[
aId
]
.
length
=
=
0
)
do_throw
(
"
Too
many
events
for
"
+
aId
)
;
let
event
=
gExpectedEvents
[
aId
]
.
shift
(
)
;
if
(
event
instanceof
Array
)
return
event
;
return
[
event
true
]
;
}
function
getExpectedInstall
(
aAddon
)
{
if
(
gExpectedInstalls
instanceof
Array
)
return
gExpectedInstalls
.
shift
(
)
;
if
(
!
aAddon
|
|
!
aAddon
.
id
)
return
gExpectedInstalls
.
NO_ID
.
shift
(
)
;
let
id
=
aAddon
.
id
;
if
(
!
(
id
in
gExpectedInstalls
)
|
|
!
(
gExpectedInstalls
[
id
]
instanceof
Array
)
)
do_throw
(
"
Wasn
'
t
expecting
events
for
"
+
id
)
;
if
(
gExpectedInstalls
[
id
]
.
length
=
=
0
)
do_throw
(
"
Too
many
events
for
"
+
id
)
;
return
gExpectedInstalls
[
id
]
.
shift
(
)
;
}
const
AddonListener
=
{
onPropertyChanged
(
aAddon
aProperties
)
{
info
(
Got
onPropertyChanged
event
for
{
aAddon
.
id
}
)
;
let
[
event
properties
]
=
getExpectedEvent
(
aAddon
.
id
)
;
Assert
.
equal
(
"
onPropertyChanged
"
event
)
;
Assert
.
equal
(
aProperties
.
length
properties
.
length
)
;
properties
.
forEach
(
function
(
aProperty
)
{
if
(
!
aProperties
.
includes
(
aProperty
)
)
do_throw
(
"
Did
not
see
property
change
for
"
+
aProperty
)
;
}
)
;
return
check_test_completed
(
arguments
)
;
}
onEnabling
(
aAddon
aRequiresRestart
)
{
info
(
Got
onEnabling
event
for
{
aAddon
.
id
}
)
;
let
[
event
expectedRestart
]
=
getExpectedEvent
(
aAddon
.
id
)
;
Assert
.
equal
(
"
onEnabling
"
event
)
;
Assert
.
equal
(
aRequiresRestart
expectedRestart
)
;
if
(
expectedRestart
)
Assert
.
ok
(
hasFlag
(
aAddon
.
pendingOperations
AddonManager
.
PENDING_ENABLE
)
)
;
Assert
.
ok
(
!
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_ENABLE
)
)
;
return
check_test_completed
(
arguments
)
;
}
onEnabled
(
aAddon
)
{
info
(
Got
onEnabled
event
for
{
aAddon
.
id
}
)
;
let
[
event
]
=
getExpectedEvent
(
aAddon
.
id
)
;
Assert
.
equal
(
"
onEnabled
"
event
)
;
Assert
.
ok
(
!
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_ENABLE
)
)
;
return
check_test_completed
(
arguments
)
;
}
onDisabling
(
aAddon
aRequiresRestart
)
{
info
(
Got
onDisabling
event
for
{
aAddon
.
id
}
)
;
let
[
event
expectedRestart
]
=
getExpectedEvent
(
aAddon
.
id
)
;
Assert
.
equal
(
"
onDisabling
"
event
)
;
Assert
.
equal
(
aRequiresRestart
expectedRestart
)
;
if
(
expectedRestart
)
Assert
.
ok
(
hasFlag
(
aAddon
.
pendingOperations
AddonManager
.
PENDING_DISABLE
)
)
;
Assert
.
ok
(
!
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_DISABLE
)
)
;
return
check_test_completed
(
arguments
)
;
}
onDisabled
(
aAddon
)
{
info
(
Got
onDisabled
event
for
{
aAddon
.
id
}
)
;
let
[
event
]
=
getExpectedEvent
(
aAddon
.
id
)
;
Assert
.
equal
(
"
onDisabled
"
event
)
;
Assert
.
ok
(
!
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_DISABLE
)
)
;
return
check_test_completed
(
arguments
)
;
}
onInstalling
(
aAddon
aRequiresRestart
)
{
info
(
Got
onInstalling
event
for
{
aAddon
.
id
}
)
;
let
[
event
expectedRestart
]
=
getExpectedEvent
(
aAddon
.
id
)
;
Assert
.
equal
(
"
onInstalling
"
event
)
;
Assert
.
equal
(
aRequiresRestart
expectedRestart
)
;
if
(
expectedRestart
)
Assert
.
ok
(
hasFlag
(
aAddon
.
pendingOperations
AddonManager
.
PENDING_INSTALL
)
)
;
return
check_test_completed
(
arguments
)
;
}
onInstalled
(
aAddon
)
{
info
(
Got
onInstalled
event
for
{
aAddon
.
id
}
)
;
let
[
event
]
=
getExpectedEvent
(
aAddon
.
id
)
;
Assert
.
equal
(
"
onInstalled
"
event
)
;
return
check_test_completed
(
arguments
)
;
}
onUninstalling
(
aAddon
aRequiresRestart
)
{
info
(
Got
onUninstalling
event
for
{
aAddon
.
id
}
)
;
let
[
event
expectedRestart
]
=
getExpectedEvent
(
aAddon
.
id
)
;
Assert
.
equal
(
"
onUninstalling
"
event
)
;
Assert
.
equal
(
aRequiresRestart
expectedRestart
)
;
if
(
expectedRestart
)
Assert
.
ok
(
hasFlag
(
aAddon
.
pendingOperations
AddonManager
.
PENDING_UNINSTALL
)
)
;
return
check_test_completed
(
arguments
)
;
}
onUninstalled
(
aAddon
)
{
info
(
Got
onUninstalled
event
for
{
aAddon
.
id
}
)
;
let
[
event
]
=
getExpectedEvent
(
aAddon
.
id
)
;
Assert
.
equal
(
"
onUninstalled
"
event
)
;
return
check_test_completed
(
arguments
)
;
}
onOperationCancelled
(
aAddon
)
{
info
(
Got
onOperationCancelled
event
for
{
aAddon
.
id
}
)
;
let
[
event
]
=
getExpectedEvent
(
aAddon
.
id
)
;
Assert
.
equal
(
"
onOperationCancelled
"
event
)
;
return
check_test_completed
(
arguments
)
;
}
}
;
const
InstallListener
=
{
onNewInstall
(
install
)
{
if
(
install
.
state
!
=
AddonManager
.
STATE_DOWNLOADED
&
&
install
.
state
!
=
AddonManager
.
STATE_DOWNLOAD_FAILED
&
&
install
.
state
!
=
AddonManager
.
STATE_AVAILABLE
)
do_throw
(
"
Bad
install
state
"
+
install
.
state
)
;
if
(
install
.
state
!
=
AddonManager
.
STATE_DOWNLOAD_FAILED
)
Assert
.
equal
(
install
.
error
0
)
;
else
Assert
.
notEqual
(
install
.
error
0
)
;
Assert
.
equal
(
"
onNewInstall
"
getExpectedInstall
(
)
)
;
return
check_test_completed
(
arguments
)
;
}
onDownloadStarted
(
install
)
{
Assert
.
equal
(
install
.
state
AddonManager
.
STATE_DOWNLOADING
)
;
Assert
.
equal
(
install
.
error
0
)
;
Assert
.
equal
(
"
onDownloadStarted
"
getExpectedInstall
(
)
)
;
return
check_test_completed
(
arguments
)
;
}
onDownloadEnded
(
install
)
{
Assert
.
equal
(
install
.
state
AddonManager
.
STATE_DOWNLOADED
)
;
Assert
.
equal
(
install
.
error
0
)
;
Assert
.
equal
(
"
onDownloadEnded
"
getExpectedInstall
(
)
)
;
return
check_test_completed
(
arguments
)
;
}
onDownloadFailed
(
install
)
{
Assert
.
equal
(
install
.
state
AddonManager
.
STATE_DOWNLOAD_FAILED
)
;
Assert
.
equal
(
"
onDownloadFailed
"
getExpectedInstall
(
)
)
;
return
check_test_completed
(
arguments
)
;
}
onDownloadCancelled
(
install
)
{
Assert
.
equal
(
install
.
state
AddonManager
.
STATE_CANCELLED
)
;
Assert
.
equal
(
install
.
error
0
)
;
Assert
.
equal
(
"
onDownloadCancelled
"
getExpectedInstall
(
)
)
;
return
check_test_completed
(
arguments
)
;
}
onInstallStarted
(
install
)
{
Assert
.
equal
(
install
.
state
AddonManager
.
STATE_INSTALLING
)
;
Assert
.
equal
(
install
.
error
0
)
;
Assert
.
equal
(
"
onInstallStarted
"
getExpectedInstall
(
install
.
addon
)
)
;
return
check_test_completed
(
arguments
)
;
}
onInstallEnded
(
install
newAddon
)
{
Assert
.
equal
(
install
.
state
AddonManager
.
STATE_INSTALLED
)
;
Assert
.
equal
(
install
.
error
0
)
;
Assert
.
equal
(
"
onInstallEnded
"
getExpectedInstall
(
install
.
addon
)
)
;
return
check_test_completed
(
arguments
)
;
}
onInstallFailed
(
install
)
{
Assert
.
equal
(
install
.
state
AddonManager
.
STATE_INSTALL_FAILED
)
;
Assert
.
equal
(
"
onInstallFailed
"
getExpectedInstall
(
install
.
addon
)
)
;
return
check_test_completed
(
arguments
)
;
}
onInstallCancelled
(
install
)
{
let
possibleStates
=
[
AddonManager
.
STATE_CANCELLED
AddonManager
.
STATE_DOWNLOADED
]
;
Assert
.
ok
(
possibleStates
.
includes
(
install
.
state
)
)
;
Assert
.
equal
(
install
.
error
0
)
;
Assert
.
equal
(
"
onInstallCancelled
"
getExpectedInstall
(
install
.
addon
)
)
;
return
check_test_completed
(
arguments
)
;
}
onExternalInstall
(
aAddon
existingAddon
aRequiresRestart
)
{
Assert
.
equal
(
"
onExternalInstall
"
getExpectedInstall
(
aAddon
)
)
;
Assert
.
ok
(
!
aRequiresRestart
)
;
return
check_test_completed
(
arguments
)
;
}
}
;
function
hasFlag
(
aBits
aFlag
)
{
return
(
aBits
&
aFlag
)
!
=
0
;
}
function
prepare_test
(
aExpectedEvents
aExpectedInstalls
aNext
)
{
AddonManager
.
addAddonListener
(
AddonListener
)
;
AddonManager
.
addInstallListener
(
InstallListener
)
;
gExpectedInstalls
=
aExpectedInstalls
;
gExpectedEvents
=
aExpectedEvents
;
gNext
=
aNext
;
}
function
end_test
(
)
{
AddonManager
.
removeAddonListener
(
AddonListener
)
;
AddonManager
.
removeInstallListener
(
InstallListener
)
;
}
function
check_test_completed
(
aArgs
)
{
if
(
!
gNext
)
return
undefined
;
if
(
gExpectedInstalls
instanceof
Array
&
&
gExpectedInstalls
.
length
>
0
)
return
undefined
;
for
(
let
id
in
gExpectedInstalls
)
{
let
installList
=
gExpectedInstalls
[
id
]
;
if
(
installList
.
length
>
0
)
return
undefined
;
}
for
(
let
id
in
gExpectedEvents
)
{
if
(
gExpectedEvents
[
id
]
.
length
>
0
)
return
undefined
;
}
return
gNext
.
apply
(
null
aArgs
)
;
}
function
ensure_test_completed
(
)
{
for
(
let
i
in
gExpectedEvents
)
{
if
(
gExpectedEvents
[
i
]
.
length
>
0
)
do_throw
(
Didn
'
t
see
all
the
expected
events
for
{
i
}
:
Still
expecting
{
gExpectedEvents
[
i
]
}
)
;
}
gExpectedEvents
=
{
}
;
if
(
gExpectedInstalls
)
Assert
.
equal
(
gExpectedInstalls
.
length
0
)
;
}
function
completeAllInstalls
(
aInstalls
aCallback
)
{
promiseCompleteAllInstalls
(
aInstalls
)
.
then
(
aCallback
)
;
}
function
installAllFiles
(
aFiles
aCallback
aIgnoreIncompatible
)
{
promiseInstallAllFiles
(
aFiles
aIgnoreIncompatible
)
.
then
(
aCallback
)
;
}
const
EXTENSIONS_DB
=
"
extensions
.
json
"
;
var
gExtensionsJSON
=
gProfD
.
clone
(
)
;
gExtensionsJSON
.
append
(
EXTENSIONS_DB
)
;
async
function
promiseInstallWebExtension
(
aData
)
{
let
addonFile
=
createTempWebExtensionFile
(
aData
)
;
let
{
addon
}
=
await
promiseInstallFile
(
addonFile
)
;
return
addon
;
}
Services
.
prefs
.
setBoolPref
(
"
extensions
.
strictCompatibility
"
true
)
;
Services
.
prefs
.
setBoolPref
(
PREF_XPI_SIGNATURES_REQUIRED
true
)
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
legacy
.
enabled
"
true
)
;
function
copyBlocklistToProfile
(
blocklistFile
)
{
var
dest
=
gProfD
.
clone
(
)
;
dest
.
append
(
"
blocklist
.
xml
"
)
;
if
(
dest
.
exists
(
)
)
dest
.
remove
(
false
)
;
blocklistFile
.
copyTo
(
gProfD
"
blocklist
.
xml
"
)
;
dest
.
lastModifiedTime
=
Date
.
now
(
)
;
}
function
timeout
(
)
{
timer
=
null
;
do_throw
(
"
Test
ran
longer
than
"
+
TIMEOUT_MS
+
"
ms
"
)
;
do_test_finished
(
)
;
}
var
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
init
(
timeout
TIMEOUT_MS
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
function
pathShouldntExist
(
file
)
{
if
(
file
.
exists
(
)
)
{
do_throw
(
Test
cleanup
:
path
{
file
.
path
}
exists
when
it
should
not
)
;
}
}
registerCleanupFunction
(
function
addon_cleanup
(
)
{
if
(
timer
)
timer
.
cancel
(
)
;
}
)
;
function
do_exception_wrap
(
func
)
{
return
function
(
)
{
try
{
func
.
apply
(
null
arguments
)
;
}
catch
(
e
)
{
do_report_unexpected_exception
(
e
)
;
}
}
;
}
async
function
changeXPIDBVersion
(
aNewVersion
)
{
let
json
=
await
loadJSON
(
gExtensionsJSON
.
path
)
;
json
.
schemaVersion
=
aNewVersion
;
await
saveJSON
(
json
gExtensionsJSON
.
path
)
;
}
async
function
loadFile
(
aFile
)
{
let
buffer
=
await
OS
.
File
.
read
(
aFile
)
;
return
new
TextDecoder
(
)
.
decode
(
buffer
)
;
}
async
function
loadJSON
(
aFile
)
{
let
data
=
await
loadFile
(
aFile
)
;
info
(
"
Loaded
JSON
file
"
+
aFile
)
;
return
JSON
.
parse
(
data
)
;
}
async
function
saveJSON
(
aData
aFile
)
{
info
(
"
Starting
to
save
JSON
file
"
+
aFile
)
;
await
OS
.
File
.
writeAtomic
(
aFile
new
TextEncoder
(
)
.
encode
(
JSON
.
stringify
(
aData
null
2
)
)
)
;
info
(
"
Done
saving
JSON
file
"
+
aFile
.
path
)
;
}
function
callback_soon
(
aFunction
)
{
return
function
(
.
.
.
args
)
{
executeSoon
(
function
(
)
{
aFunction
.
apply
(
null
args
)
;
}
aFunction
.
name
?
"
delayed
callback
"
+
aFunction
.
name
:
"
delayed
callback
"
)
;
}
;
}
async
function
serveSystemUpdate
(
xml
perform_update
testserver
)
{
testserver
.
registerPathHandler
(
"
/
data
/
update
.
xml
"
(
request
response
)
=
>
{
response
.
write
(
xml
)
;
}
)
;
try
{
await
perform_update
(
)
;
}
finally
{
testserver
.
registerPathHandler
(
"
/
data
/
update
.
xml
"
null
)
;
}
}
async
function
installSystemAddons
(
xml
testserver
)
{
info
(
"
Triggering
system
add
-
on
update
check
.
"
)
;
await
serveSystemUpdate
(
xml
async
function
(
)
{
let
{
XPIProvider
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIProvider
.
jsm
"
{
}
)
;
await
XPIProvider
.
updateSystemAddons
(
)
;
}
testserver
)
;
}
async
function
updateAllSystemAddons
(
xml
testserver
)
{
info
(
"
Triggering
full
add
-
on
update
check
.
"
)
;
await
serveSystemUpdate
(
xml
function
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observer
(
)
{
Services
.
obs
.
removeObserver
(
observer
"
addons
-
background
-
update
-
complete
"
)
;
resolve
(
)
;
}
"
addons
-
background
-
update
-
complete
"
)
;
gInternalManager
.
notify
(
null
)
;
}
)
;
}
testserver
)
;
}
function
buildSystemAddonUpdates
(
addons
root
)
{
let
xml
=
<
?
xml
version
=
"
1
.
0
"
encoding
=
"
UTF
-
8
"
?
>
\
n
\
n
<
updates
>
\
n
;
if
(
addons
)
{
xml
+
=
<
addons
>
\
n
;
for
(
let
addon
of
addons
)
{
xml
+
=
<
addon
id
=
"
{
addon
.
id
}
"
URL
=
"
{
root
+
addon
.
path
}
"
version
=
"
{
addon
.
version
}
"
;
if
(
addon
.
hashFunction
)
xml
+
=
hashFunction
=
"
{
addon
.
hashFunction
}
"
;
if
(
addon
.
hashValue
)
xml
+
=
hashValue
=
"
{
addon
.
hashValue
}
"
;
xml
+
=
/
>
\
n
;
}
xml
+
=
<
/
addons
>
\
n
;
}
xml
+
=
<
/
updates
>
\
n
;
return
xml
;
}
function
initSystemAddonDirs
(
)
{
let
hiddenSystemAddonDir
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
sysfeatures
"
"
hidden
"
]
true
)
;
do_get_file
(
"
data
/
system_addons
/
system1_1
.
xpi
"
)
.
copyTo
(
hiddenSystemAddonDir
"
system1
tests
.
mozilla
.
org
.
xpi
"
)
;
do_get_file
(
"
data
/
system_addons
/
system2_1
.
xpi
"
)
.
copyTo
(
hiddenSystemAddonDir
"
system2
tests
.
mozilla
.
org
.
xpi
"
)
;
let
prefilledSystemAddonDir
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
sysfeatures
"
"
prefilled
"
]
true
)
;
do_get_file
(
"
data
/
system_addons
/
system2_2
.
xpi
"
)
.
copyTo
(
prefilledSystemAddonDir
"
system2
tests
.
mozilla
.
org
.
xpi
"
)
;
do_get_file
(
"
data
/
system_addons
/
system3_2
.
xpi
"
)
.
copyTo
(
prefilledSystemAddonDir
"
system3
tests
.
mozilla
.
org
.
xpi
"
)
;
}
function
getCurrentSystemAddonUpdatesDir
(
)
{
const
updatesDir
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
features
"
]
false
)
;
let
dir
=
updatesDir
.
clone
(
)
;
let
set
=
JSON
.
parse
(
Services
.
prefs
.
getCharPref
(
PREF_SYSTEM_ADDON_SET
)
)
;
dir
.
append
(
set
.
directory
)
;
return
dir
;
}
function
clearSystemAddonUpdatesDir
(
)
{
const
updatesDir
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
features
"
]
false
)
;
if
(
updatesDir
.
exists
(
)
)
updatesDir
.
remove
(
true
)
;
Services
.
prefs
.
clearUserPref
(
PREF_SYSTEM_ADDON_SET
)
;
}
function
buildPrefilledUpdatesDir
(
)
{
clearSystemAddonUpdatesDir
(
)
;
let
dir
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
features
"
"
prefilled
"
]
true
)
;
do_get_file
(
"
data
/
system_addons
/
system2_2
.
xpi
"
)
.
copyTo
(
dir
"
system2
tests
.
mozilla
.
org
.
xpi
"
)
;
do_get_file
(
"
data
/
system_addons
/
system3_2
.
xpi
"
)
.
copyTo
(
dir
"
system3
tests
.
mozilla
.
org
.
xpi
"
)
;
FileUtils
.
getFile
(
"
ProfD
"
[
"
features
"
"
prefilled
"
"
system2
tests
.
mozilla
.
org
.
xpi
"
]
)
.
lastModifiedTime
-
=
10000
;
FileUtils
.
getFile
(
"
ProfD
"
[
"
features
"
"
prefilled
"
"
system3
tests
.
mozilla
.
org
.
xpi
"
]
)
.
lastModifiedTime
-
=
10000
;
Services
.
prefs
.
setCharPref
(
PREF_SYSTEM_ADDON_SET
JSON
.
stringify
(
{
schema
:
1
directory
:
dir
.
leafName
addons
:
{
"
system2
tests
.
mozilla
.
org
"
:
{
version
:
"
2
.
0
"
}
"
system3
tests
.
mozilla
.
org
"
:
{
version
:
"
2
.
0
"
}
}
}
)
)
;
}
async
function
checkInstalledSystemAddons
(
conditions
distroDir
)
{
for
(
let
i
=
0
;
i
<
conditions
.
length
;
i
+
+
)
{
let
condition
=
conditions
[
i
]
;
let
id
=
"
system
"
+
(
i
+
1
)
+
"
tests
.
mozilla
.
org
"
;
let
addon
=
await
promiseAddonByID
(
id
)
;
if
(
!
(
"
isUpgrade
"
in
condition
)
|
|
!
(
"
version
"
in
condition
)
)
{
throw
Error
(
"
condition
must
contain
isUpgrade
and
version
"
)
;
}
let
isUpgrade
=
conditions
[
i
]
.
isUpgrade
;
let
version
=
conditions
[
i
]
.
version
;
let
expectedDir
=
isUpgrade
?
getCurrentSystemAddonUpdatesDir
(
)
:
distroDir
;
if
(
version
)
{
info
(
Checking
state
of
add
-
on
{
id
}
expecting
version
{
version
}
)
;
Assert
.
notEqual
(
addon
null
)
;
Assert
.
equal
(
addon
.
version
version
)
;
Assert
.
ok
(
addon
.
isActive
)
;
Assert
.
ok
(
!
addon
.
foreignInstall
)
;
Assert
.
ok
(
addon
.
hidden
)
;
Assert
.
ok
(
addon
.
isSystem
)
;
let
file
=
expectedDir
.
clone
(
)
;
file
.
append
(
id
+
"
.
xpi
"
)
;
Assert
.
ok
(
file
.
exists
(
)
)
;
Assert
.
ok
(
file
.
isFile
(
)
)
;
let
uri
=
addon
.
getResourceURI
(
null
)
;
Assert
.
ok
(
uri
instanceof
Ci
.
nsIFileURL
)
;
Assert
.
equal
(
uri
.
file
.
path
file
.
path
)
;
if
(
isUpgrade
)
{
Assert
.
equal
(
addon
.
signedState
AddonManager
.
SIGNEDSTATE_SYSTEM
)
;
}
BootstrapMonitor
.
checkAddonStarted
(
id
version
)
;
}
else
{
info
(
Checking
state
of
add
-
on
{
id
}
expecting
it
to
be
missing
)
;
if
(
isUpgrade
)
{
Assert
.
equal
(
addon
null
)
;
}
BootstrapMonitor
.
checkAddonNotStarted
(
id
)
;
if
(
addon
)
BootstrapMonitor
.
checkAddonInstalled
(
id
)
;
else
BootstrapMonitor
.
checkAddonNotInstalled
(
id
)
;
}
}
}
async
function
getSystemAddonDirectories
(
)
{
const
updatesDir
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
features
"
]
false
)
;
let
subdirs
=
[
]
;
if
(
await
OS
.
File
.
exists
(
updatesDir
.
path
)
)
{
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
updatesDir
.
path
)
;
await
iterator
.
forEach
(
entry
=
>
{
if
(
entry
.
isDir
)
{
subdirs
.
push
(
entry
)
;
}
}
)
;
iterator
.
close
(
)
;
}
return
subdirs
;
}
async
function
setupSystemAddonConditions
(
setup
distroDir
)
{
info
(
"
Clearing
existing
database
.
"
)
;
Services
.
prefs
.
clearUserPref
(
PREF_SYSTEM_ADDON_SET
)
;
distroDir
.
leafName
=
"
empty
"
;
let
updateList
=
[
]
;
await
overrideBuiltIns
(
{
"
system
"
:
updateList
}
)
;
await
promiseStartupManager
(
)
;
await
promiseShutdownManager
(
)
;
info
(
"
Setting
up
conditions
.
"
)
;
await
setup
.
setup
(
)
;
if
(
distroDir
)
{
if
(
distroDir
.
path
.
endsWith
(
"
hidden
"
)
)
{
updateList
=
[
"
system1
tests
.
mozilla
.
org
"
"
system2
tests
.
mozilla
.
org
"
]
;
}
else
if
(
distroDir
.
path
.
endsWith
(
"
prefilled
"
)
)
{
updateList
=
[
"
system2
tests
.
mozilla
.
org
"
"
system3
tests
.
mozilla
.
org
"
]
;
}
}
await
overrideBuiltIns
(
{
"
system
"
:
updateList
}
)
;
await
promiseStartupManager
(
)
;
info
(
"
Checking
initial
state
.
"
)
;
await
checkInstalledSystemAddons
(
setup
.
initialState
distroDir
)
;
}
async
function
verifySystemAddonState
(
initialState
finalState
=
undefined
alreadyUpgraded
=
false
distroDir
)
{
let
expectedDirs
=
0
;
if
(
initialState
.
some
(
a
=
>
a
.
isUpgrade
)
)
{
expectedDirs
+
+
;
}
if
(
finalState
=
=
undefined
)
{
finalState
=
initialState
;
}
else
if
(
finalState
.
some
(
a
=
>
a
.
isUpgrade
)
)
{
expectedDirs
+
+
;
}
if
(
alreadyUpgraded
)
{
expectedDirs
+
+
;
}
info
(
"
Checking
final
state
.
"
)
;
let
dirs
=
await
getSystemAddonDirectories
(
)
;
Assert
.
equal
(
dirs
.
length
expectedDirs
)
;
await
checkInstalledSystemAddons
(
.
.
.
finalState
distroDir
)
;
await
promiseShutdownManager
(
)
;
let
updateList
=
[
]
;
if
(
distroDir
)
{
if
(
distroDir
.
path
.
endsWith
(
"
hidden
"
)
)
{
updateList
=
[
"
system1
tests
.
mozilla
.
org
"
"
system2
tests
.
mozilla
.
org
"
]
;
}
else
if
(
distroDir
.
path
.
endsWith
(
"
prefilled
"
)
)
{
updateList
=
[
"
system2
tests
.
mozilla
.
org
"
"
system3
tests
.
mozilla
.
org
"
]
;
}
}
await
overrideBuiltIns
(
{
"
system
"
:
updateList
}
)
;
await
promiseStartupManager
(
)
;
await
checkInstalledSystemAddons
(
finalState
distroDir
)
;
}
async
function
execSystemAddonTest
(
setupName
setup
test
distroDir
root
testserver
)
{
await
setupSystemAddonConditions
(
setup
distroDir
)
;
try
{
if
(
"
test
"
in
test
)
{
await
test
.
test
(
)
;
}
else
{
await
installSystemAddons
(
await
buildSystemAddonUpdates
(
test
.
updateList
root
)
testserver
)
;
}
if
(
test
.
fails
)
{
do_throw
(
"
Expected
this
test
to
fail
"
)
;
}
}
catch
(
e
)
{
if
(
!
test
.
fails
)
{
do_throw
(
e
)
;
}
}
if
(
test
.
finalState
&
&
setupName
in
test
.
finalState
)
{
await
verifySystemAddonState
(
setup
.
initialState
test
.
finalState
[
setupName
]
false
distroDir
)
;
}
else
{
await
verifySystemAddonState
(
setup
.
initialState
undefined
false
distroDir
)
;
}
await
promiseShutdownManager
(
)
;
}
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
pluginHost
"
"
mozilla
.
org
/
plugin
/
host
;
1
"
"
nsIPluginHost
"
)
;
class
MockPluginTag
{
constructor
(
opts
enabledState
=
Ci
.
nsIPluginTag
.
STATE_ENABLED
)
{
this
.
pluginTag
=
pluginHost
.
createFakePlugin
(
{
handlerURI
:
"
resource
:
/
/
fake
-
plugin
/
{
Math
.
random
(
)
}
.
xhtml
"
mimeEntries
:
[
{
type
:
"
application
/
x
-
fake
-
plugin
"
}
]
fileName
:
{
opts
.
name
}
.
so
.
.
.
opts
}
)
;
this
.
pluginTag
.
enabledState
=
enabledState
;
this
.
name
=
opts
.
name
;
this
.
version
=
opts
.
version
;
}
async
isBlocklisted
(
)
{
let
state
=
await
Blocklist
.
getPluginBlocklistState
(
this
.
pluginTag
)
;
return
state
=
=
Services
.
blocklist
.
STATE_BLOCKED
;
}
get
disabled
(
)
{
return
this
.
pluginTag
.
enabledState
=
=
Ci
.
nsIPluginTag
.
STATE_DISABLED
;
}
set
disabled
(
val
)
{
this
.
enabledState
=
Ci
.
nsIPluginTag
[
val
?
"
STATE_DISABLED
"
:
"
STATE_ENABLED
"
]
;
}
get
enabledState
(
)
{
return
this
.
pluginTag
.
enabledState
;
}
set
enabledState
(
val
)
{
this
.
pluginTag
.
enabledState
=
val
;
}
}
function
mockPluginHost
(
plugins
)
{
let
PluginHost
=
{
getPluginTags
(
count
)
{
count
.
value
=
plugins
.
length
;
return
plugins
.
map
(
p
=
>
p
.
pluginTag
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIPluginHost
"
]
)
}
;
MockRegistrar
.
register
(
"
mozilla
.
org
/
plugin
/
host
;
1
"
PluginHost
)
;
}
async
function
setInitialState
(
addon
initialState
)
{
if
(
initialState
.
userDisabled
)
{
await
addon
.
disable
(
)
;
}
else
if
(
initialState
.
userDisabled
=
=
=
false
)
{
await
addon
.
enable
(
)
;
}
}
