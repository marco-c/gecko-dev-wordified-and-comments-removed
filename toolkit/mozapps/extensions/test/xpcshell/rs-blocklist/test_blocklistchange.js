const
URI_EXTENSION_BLOCKLIST_DIALOG
=
"
chrome
:
/
/
mozapps
/
content
/
extensions
/
blocklist
.
xhtml
"
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
checkUpdateSecurity
"
false
)
;
const
IS_ANDROID_WITH_BLOCKLIST_V2
=
AppConstants
.
platform
=
=
"
android
"
&
&
!
AppConstants
.
NIGHTLY_BUILD
;
if
(
IS_ANDROID_WITH_BLOCKLIST_V2
)
{
Assert
.
ok
(
_TEST_NAME
.
includes
(
"
test_blocklistchange
"
)
Expected
_TEST_NAME
to
be
test_blocklistchange
{
_v2
}
.
js
)
;
if
(
_TEST_NAME
.
includes
(
"
test_blocklistchange
.
js
"
)
)
{
Assert
.
equal
(
Services
.
prefs
.
getBoolPref
(
"
extensions
.
blocklist
.
useMLBF
"
)
false
"
Blocklist
v3
disabled
by
default
on
Android
"
)
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
blocklist
.
useMLBF
"
true
)
;
}
}
const
useMLBF
=
Services
.
prefs
.
getBoolPref
(
"
extensions
.
blocklist
.
useMLBF
"
true
)
;
var
testserver
=
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
]
}
)
;
function
permissionPromptHandler
(
subject
topic
data
)
{
ok
(
subject
?
.
wrappedJSObject
?
.
info
?
.
resolve
"
Got
a
permission
prompt
notification
as
expected
"
)
;
subject
.
wrappedJSObject
.
info
.
resolve
(
)
;
}
Services
.
obs
.
addObserver
(
permissionPromptHandler
"
webextension
-
permission
-
prompt
"
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
obs
.
removeObserver
(
permissionPromptHandler
"
webextension
-
permission
-
prompt
"
)
;
}
)
;
const
XPIS
=
{
}
;
const
ADDON_IDS
=
[
"
softblock1
tests
.
mozilla
.
org
"
"
softblock2
tests
.
mozilla
.
org
"
"
softblock3
tests
.
mozilla
.
org
"
"
softblock4
tests
.
mozilla
.
org
"
"
hardblock
tests
.
mozilla
.
org
"
"
regexpblock
tests
.
mozilla
.
org
"
]
;
const
BLOCK_APP
=
[
{
guid
:
"
xpcshell
tests
.
mozilla
.
org
"
maxVersion
:
"
2
.
*
"
minVersion
:
"
2
"
}
]
;
const
BLOCK_APP_FILTER_EXPRESSION
=
env
.
appinfo
.
ID
=
=
"
xpcshell
tests
.
mozilla
.
org
"
&
&
env
.
appinfo
.
version
>
=
"
2
"
&
&
env
.
appinfo
.
version
<
"
3
"
;
function
softBlockApp
(
id
)
{
return
{
guid
:
{
id
}
tests
.
mozilla
.
org
versionRange
:
[
{
severity
:
"
1
"
targetApplication
:
BLOCK_APP
}
]
}
;
}
function
softBlockAddonChange
(
id
)
{
return
{
guid
:
{
id
}
tests
.
mozilla
.
org
versionRange
:
[
{
severity
:
"
1
"
minVersion
:
"
2
"
maxVersion
:
"
3
"
}
]
}
;
}
function
softBlockUpdate2
(
id
)
{
return
{
guid
:
{
id
}
tests
.
mozilla
.
org
versionRange
:
[
{
severity
:
"
1
"
}
]
}
;
}
function
softBlockManual
(
id
)
{
return
{
guid
:
{
id
}
tests
.
mozilla
.
org
versionRange
:
[
{
maxVersion
:
"
2
"
minVersion
:
"
1
"
severity
:
"
1
"
}
]
}
;
}
const
BLOCKLIST_DATA
=
{
empty_blocklist
:
[
]
app_update
:
[
softBlockApp
(
"
softblock1
"
)
softBlockApp
(
"
softblock2
"
)
softBlockApp
(
"
softblock3
"
)
softBlockApp
(
"
softblock4
"
)
{
guid
:
"
hardblock
tests
.
mozilla
.
org
"
versionRange
:
[
{
targetApplication
:
BLOCK_APP
}
]
}
{
guid
:
"
/
^
RegExp
/
"
versionRange
:
[
{
severity
:
"
1
"
targetApplication
:
BLOCK_APP
}
]
}
{
guid
:
"
/
^
RegExp
/
i
"
versionRange
:
[
{
targetApplication
:
BLOCK_APP
}
]
}
]
addon_change
:
[
softBlockAddonChange
(
"
softblock1
"
)
softBlockAddonChange
(
"
softblock2
"
)
softBlockAddonChange
(
"
softblock3
"
)
softBlockAddonChange
(
"
softblock4
"
)
{
guid
:
"
hardblock
tests
.
mozilla
.
org
"
versionRange
:
[
{
maxVersion
:
"
3
"
minVersion
:
"
2
"
}
]
}
{
_comment
:
"
Two
RegExp
matches
so
test
flags
work
-
first
shouldn
'
t
match
.
"
guid
:
"
/
^
RegExp
/
"
versionRange
:
[
{
maxVersion
:
"
3
"
minVersion
:
"
2
"
severity
:
"
1
"
}
]
}
{
guid
:
"
/
^
RegExp
/
i
"
versionRange
:
[
{
maxVersion
:
"
3
"
minVersion
:
"
2
"
severity
:
"
2
"
}
]
}
]
blocklist_update2
:
[
softBlockUpdate2
(
"
softblock1
"
)
softBlockUpdate2
(
"
softblock2
"
)
softBlockUpdate2
(
"
softblock3
"
)
softBlockUpdate2
(
"
softblock4
"
)
{
guid
:
"
hardblock
tests
.
mozilla
.
org
"
versionRange
:
[
]
}
{
guid
:
"
/
^
RegExp
/
"
versionRange
:
[
{
severity
:
"
1
"
}
]
}
{
guid
:
"
/
^
RegExp
/
i
"
versionRange
:
[
]
}
]
manual_update
:
[
softBlockManual
(
"
softblock1
"
)
softBlockManual
(
"
softblock2
"
)
softBlockManual
(
"
softblock3
"
)
softBlockManual
(
"
softblock4
"
)
{
guid
:
"
hardblock
tests
.
mozilla
.
org
"
versionRange
:
[
{
maxVersion
:
"
2
"
minVersion
:
"
1
"
}
]
}
{
guid
:
"
/
^
RegExp
/
i
"
versionRange
:
[
{
maxVersion
:
"
2
"
minVersion
:
"
1
"
}
]
}
]
}
;
if
(
useMLBF
)
{
for
(
let
[
key
blocks
]
of
Object
.
entries
(
BLOCKLIST_DATA
)
)
{
BLOCKLIST_DATA
[
key
]
=
[
]
;
for
(
let
block
of
blocks
)
{
let
{
guid
}
=
block
;
if
(
guid
.
includes
(
"
RegExp
"
)
)
{
guid
=
"
regexpblock
tests
.
mozilla
.
org
"
;
}
else
if
(
!
guid
.
startsWith
(
"
soft
"
)
&
&
!
guid
.
startsWith
(
"
hard
"
)
)
{
throw
new
Error
(
Unexpected
mock
addon
ID
:
{
guid
}
)
;
}
const
{
minVersion
=
"
1
"
maxVersion
=
"
3
"
targetApplication
}
=
block
.
versionRange
?
.
[
0
]
|
|
{
}
;
for
(
let
v
=
minVersion
;
v
<
=
maxVersion
;
+
+
v
)
{
BLOCKLIST_DATA
[
key
]
.
push
(
{
filter_expression
:
targetApplication
&
&
BLOCK_APP_FILTER_EXPRESSION
stash
:
{
blocked
:
[
{
guid
}
:
{
v
}
.
0
{
guid
}
:
{
v
}
]
unblocked
:
[
]
}
}
)
;
}
}
}
}
var
WindowWatcher
=
{
openWindow
(
parent
url
name
features
openArgs
)
{
Assert
.
equal
(
url
URI_EXTENSION_BLOCKLIST_DIALOG
)
;
var
list
=
openArgs
.
wrappedJSObject
.
list
;
list
.
forEach
(
function
(
aItem
)
{
if
(
!
aItem
.
blocked
)
{
aItem
.
disable
=
true
;
}
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
addon
-
blocklist
-
closed
"
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWindowWatcher
"
]
)
}
;
MockRegistrar
.
register
(
"
mozilla
.
org
/
embedcomp
/
window
-
watcher
;
1
"
WindowWatcher
)
;
var
InstallConfirm
=
{
confirm
(
aWindow
aUrl
aInstalls
)
{
aInstalls
.
forEach
(
function
(
aInstall
)
{
aInstall
.
install
(
)
;
}
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
amIWebInstallPrompt
"
]
)
}
;
var
InstallConfirmFactory
=
{
createInstance
:
function
createInstance
(
iid
)
{
return
InstallConfirm
.
QueryInterface
(
iid
)
;
}
}
;
var
registrar
=
Components
.
manager
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
registrar
.
registerFactory
(
Components
.
ID
(
"
{
f0863905
-
4dde
-
42e2
-
991c
-
2dc8209bc9ca
}
"
)
"
Fake
Install
Prompt
"
"
mozilla
.
org
/
addons
/
web
-
install
-
prompt
;
1
"
InstallConfirmFactory
)
;
function
Pload_blocklist
(
aId
)
{
return
AddonTestUtils
.
loadBlocklistRawData
(
{
[
useMLBF
?
"
extensionsMLBF
"
:
"
extensions
"
]
:
BLOCKLIST_DATA
[
aId
]
}
)
;
}
function
Pbackground_update
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
installCount
=
0
;
let
backgroundCheckCompleted
=
false
;
AddonManager
.
addInstallListener
(
{
onNewInstall
(
aInstall
)
{
installCount
+
+
;
}
onInstallEnded
(
aInstall
)
{
installCount
-
-
;
if
(
installCount
)
{
return
;
}
AddonManager
.
removeInstallListener
(
this
)
;
if
(
!
backgroundCheckCompleted
)
{
return
;
}
resolve
(
)
;
}
}
)
;
Services
.
obs
.
addObserver
(
function
observer
(
)
{
Services
.
obs
.
removeObserver
(
observer
"
addons
-
background
-
update
-
complete
"
)
;
backgroundCheckCompleted
=
true
;
if
(
installCount
)
{
return
;
}
resolve
(
)
;
}
"
addons
-
background
-
update
-
complete
"
)
;
AddonManagerPrivate
.
backgroundUpdateCheck
(
)
;
}
)
;
}
function
Pmanual_update
(
aVersion
)
{
const
names
=
[
"
soft1
"
"
soft2
"
"
soft3
"
"
soft4
"
"
hard
"
"
regexp
"
]
;
return
Promise
.
all
(
names
.
map
(
async
name
=
>
{
let
url
=
http
:
/
/
example
.
com
/
addons
/
blocklist_
{
name
}
_
{
aVersion
}
.
xpi
;
let
install
=
await
AddonManager
.
getInstallForURL
(
url
)
;
return
new
Promise
(
resolve
=
>
{
install
.
addListener
(
{
onDownloadCancelled
:
resolve
onInstallEnded
:
resolve
}
)
;
AddonManager
.
installAddonFromAOM
(
null
null
install
)
;
}
)
;
}
)
)
;
}
function
check_addon
(
aAddon
aExpectedVersion
aExpectedUserDisabled
aExpectedSoftDisabled
aExpectedState
)
{
if
(
useMLBF
)
{
if
(
aAddon
.
id
.
startsWith
(
"
soft
"
)
)
{
if
(
aExpectedState
=
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
{
aExpectedUserDisabled
=
aAddon
.
userDisabled
;
aExpectedSoftDisabled
=
false
;
aExpectedState
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
;
}
}
}
Assert
.
notEqual
(
aAddon
null
)
;
info
(
"
Testing
"
+
aAddon
.
id
+
"
version
"
+
aAddon
.
version
+
"
user
"
+
aAddon
.
userDisabled
+
"
soft
"
+
aAddon
.
softDisabled
+
"
perms
"
+
aAddon
.
permissions
)
;
Assert
.
equal
(
aAddon
.
version
aExpectedVersion
)
;
Assert
.
equal
(
aAddon
.
blocklistState
aExpectedState
)
;
Assert
.
equal
(
aAddon
.
userDisabled
aExpectedUserDisabled
)
;
Assert
.
equal
(
aAddon
.
softDisabled
aExpectedSoftDisabled
)
;
if
(
aAddon
.
softDisabled
)
{
Assert
.
ok
(
aAddon
.
userDisabled
)
;
}
if
(
aExpectedState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
info
(
"
blocked
PERM_CAN_ENABLE
"
+
aAddon
.
id
)
;
Assert
.
ok
(
!
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_ENABLE
)
)
;
info
(
"
blocked
PERM_CAN_DISABLE
"
+
aAddon
.
id
)
;
Assert
.
ok
(
!
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_DISABLE
)
)
;
}
else
if
(
aAddon
.
userDisabled
)
{
info
(
"
userDisabled
PERM_CAN_ENABLE
"
+
aAddon
.
id
)
;
Assert
.
ok
(
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_ENABLE
)
)
;
info
(
"
userDisabled
PERM_CAN_DISABLE
"
+
aAddon
.
id
)
;
Assert
.
ok
(
!
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_DISABLE
)
)
;
}
else
{
info
(
"
other
PERM_CAN_ENABLE
"
+
aAddon
.
id
)
;
Assert
.
ok
(
!
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_ENABLE
)
)
;
if
(
aAddon
.
type
!
=
"
theme
"
)
{
info
(
"
other
PERM_CAN_DISABLE
"
+
aAddon
.
id
)
;
Assert
.
ok
(
hasFlag
(
aAddon
.
permissions
AddonManager
.
PERM_CAN_DISABLE
)
)
;
}
}
Assert
.
equal
(
aAddon
.
appDisabled
aExpectedState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
let
willBeActive
=
aAddon
.
isActive
;
if
(
hasFlag
(
aAddon
.
pendingOperations
AddonManager
.
PENDING_DISABLE
)
)
{
willBeActive
=
false
;
}
else
if
(
hasFlag
(
aAddon
.
pendingOperations
AddonManager
.
PENDING_ENABLE
)
)
{
willBeActive
=
true
;
}
if
(
aExpectedUserDisabled
|
|
aExpectedState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
Assert
.
ok
(
!
willBeActive
)
;
}
else
{
Assert
.
ok
(
willBeActive
)
;
}
}
async
function
promiseRestartManagerWithAppChange
(
version
)
{
await
promiseShutdownManager
(
)
;
await
promiseStartupManagerWithAppChange
(
version
)
;
}
async
function
promiseStartupManagerWithAppChange
(
version
)
{
if
(
version
)
{
AddonTestUtils
.
appInfo
.
version
=
version
;
}
if
(
useMLBF
)
{
await
Blocklist
.
ExtensionBlocklist
.
_updateMLBF
(
)
;
}
await
promiseStartupManager
(
)
;
}
add_task
(
async
function
setup
(
)
{
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
"
)
;
if
(
useMLBF
)
{
const
{
ClientEnvironmentBase
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
ClientEnvironment
.
sys
.
mjs
"
)
;
Object
.
defineProperty
(
ClientEnvironmentBase
"
appinfo
"
{
configurable
:
true
get
(
)
{
return
gAppInfo
;
}
}
)
;
}
function
getxpibasename
(
id
version
)
{
let
pattern
=
/
^
(
soft
|
hard
|
regexp
)
block
(
[
1
-
9
]
*
)
/
;
let
match
=
id
.
match
(
pattern
)
;
return
blocklist_
{
match
[
1
]
}
{
match
[
2
]
}
_
{
version
}
;
}
for
(
let
id
of
ADDON_IDS
)
{
for
(
let
version
of
[
1
2
3
4
]
)
{
let
name
=
getxpibasename
(
id
version
)
;
let
xpi
=
createTempWebExtensionFile
(
{
manifest
:
{
name
:
"
Test
"
version
:
{
version
}
.
0
browser_specific_settings
:
{
gecko
:
{
id
update_url
:
http
:
/
/
example
.
com
/
addon_update
{
version
}
.
json
}
}
}
}
)
;
if
(
version
!
=
4
)
{
XPIS
[
name
]
=
xpi
;
}
if
(
version
!
=
1
)
{
testserver
.
registerFile
(
/
addons
/
{
name
}
.
xpi
xpi
)
;
}
}
}
for
(
let
version
of
[
1
2
3
]
)
{
let
updateJson
=
{
addons
:
{
}
}
;
for
(
let
id
of
ADDON_IDS
)
{
let
nextversion
=
version
+
1
;
let
name
=
getxpibasename
(
id
nextversion
)
;
updateJson
.
addons
[
id
]
=
{
updates
:
[
{
applications
:
{
gecko
:
{
strict_min_version
:
"
0
"
advisory_max_version
:
"
*
"
}
}
version
:
{
nextversion
}
.
0
update_link
:
http
:
/
/
example
.
com
/
addons
/
{
name
}
.
xpi
}
]
}
;
}
AddonTestUtils
.
registerJSON
(
testserver
/
addon_update
{
version
}
.
json
updateJson
)
;
}
await
promiseStartupManager
(
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft1_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft2_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft3_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft4_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_hard_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_regexp_1
)
;
let
s4
=
await
promiseAddonByID
(
"
softblock4
tests
.
mozilla
.
org
"
)
;
await
s4
.
disable
(
)
;
}
)
;
add_task
(
async
function
run_app_update_test
(
)
{
await
Pload_blocklist
(
"
app_update
"
)
;
await
promiseRestartManager
(
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
}
)
;
add_task
(
async
function
app_update_step_2
(
)
{
await
promiseRestartManagerWithAppChange
(
"
2
"
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
await
s2
.
enable
(
)
;
await
s2
.
disable
(
)
;
check_addon
(
s2
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
await
s3
.
enable
(
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
}
)
;
add_task
(
async
function
app_update_step_3
(
)
{
await
promiseRestartManager
(
)
;
await
promiseRestartManagerWithAppChange
(
"
2
.
5
"
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
}
)
;
add_task
(
async
function
app_update_step_4
(
)
{
await
promiseRestartManagerWithAppChange
(
"
1
"
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
await
s1
.
enable
(
)
;
await
s2
.
enable
(
)
;
}
)
;
add_task
(
async
function
run_app_update_schema_test
(
)
{
await
promiseRestartManager
(
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
}
)
;
add_task
(
async
function
update_schema_2
(
)
{
await
promiseShutdownManager
(
)
;
await
changeXPIDBVersion
(
100
)
;
gAppInfo
.
version
=
"
2
"
;
await
promiseStartupManagerWithAppChange
(
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
await
s2
.
enable
(
)
;
await
s2
.
disable
(
)
;
check_addon
(
s2
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
await
s3
.
enable
(
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
}
)
;
add_task
(
async
function
update_schema_3
(
)
{
await
promiseRestartManager
(
)
;
await
promiseShutdownManager
(
)
;
await
changeXPIDBVersion
(
100
)
;
gAppInfo
.
version
=
"
2
.
5
"
;
await
promiseStartupManagerWithAppChange
(
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
}
)
;
add_task
(
async
function
update_schema_4
(
)
{
await
promiseShutdownManager
(
)
;
await
changeXPIDBVersion
(
100
)
;
await
promiseStartupManager
(
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
}
)
;
add_task
(
async
function
update_schema_5
(
)
{
await
promiseShutdownManager
(
)
;
await
changeXPIDBVersion
(
100
)
;
gAppInfo
.
version
=
"
1
"
;
await
promiseStartupManagerWithAppChange
(
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
await
s1
.
enable
(
)
;
await
s2
.
enable
(
)
;
}
)
;
add_task
(
async
function
run_blocklist_update_test
(
)
{
await
Pload_blocklist
(
"
empty_blocklist
"
)
;
await
promiseRestartManager
(
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
await
Pload_blocklist
(
"
blocklist_update2
"
)
;
await
promiseRestartManager
(
)
;
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
await
s2
.
enable
(
)
;
await
s2
.
disable
(
)
;
check_addon
(
s2
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
await
s3
.
enable
(
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
await
promiseRestartManager
(
)
;
await
Pload_blocklist
(
"
blocklist_update2
"
)
;
await
promiseRestartManager
(
)
;
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
await
Pload_blocklist
(
"
empty_blocklist
"
)
;
await
promiseRestartManager
(
)
;
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
await
s1
.
enable
(
)
;
await
s2
.
enable
(
)
;
}
)
;
add_task
(
async
function
run_addon_change_test
(
)
{
await
Pload_blocklist
(
"
addon_change
"
)
;
await
promiseRestartManager
(
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
}
)
;
add_task
(
async
function
run_addon_change_2
(
)
{
await
promiseInstallFile
(
XPIS
.
blocklist_soft1_2
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft2_2
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft3_2
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft4_2
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_hard_2
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_regexp_2
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
2
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
"
2
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
"
2
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s4
"
2
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
2
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
2
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
await
s2
.
enable
(
)
;
await
s2
.
disable
(
)
;
check_addon
(
s2
"
2
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
await
s3
.
enable
(
)
;
check_addon
(
s3
"
2
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
}
)
;
add_task
(
async
function
run_addon_change_3
(
)
{
await
promiseInstallFile
(
XPIS
.
blocklist_soft1_3
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft2_3
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft3_3
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft4_3
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_hard_3
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_regexp_3
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
3
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
"
3
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s4
"
3
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
}
)
;
add_task
(
async
function
run_addon_change_4
(
)
{
await
promiseInstallFile
(
XPIS
.
blocklist_soft1_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft2_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft3_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft4_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_hard_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_regexp_1
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
await
s1
.
enable
(
)
;
await
s2
.
enable
(
)
;
}
)
;
add_task
(
async
function
run_background_update_test
(
)
{
await
promiseRestartManager
(
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
await
Pbackground_update
(
)
;
await
promiseRestartManager
(
)
;
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
}
)
;
add_task
(
async
function
run_background_update_2_test
(
)
{
await
promiseInstallFile
(
XPIS
.
blocklist_soft1_3
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft2_3
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft3_3
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft4_3
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_hard_3
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_regexp_3
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
3
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
"
3
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
"
3
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
await
s2
.
enable
(
)
;
await
s2
.
disable
(
)
;
check_addon
(
s2
"
3
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
await
s3
.
enable
(
)
;
check_addon
(
s3
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
await
Pbackground_update
(
)
;
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
4
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s2
"
4
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s3
"
4
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
h
"
4
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
r
"
4
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
await
s1
.
enable
(
)
;
await
s2
.
enable
(
)
;
await
s4
.
disable
(
)
;
}
)
;
add_task
(
async
function
reset_addons_to_version_1_instead_of_4
(
)
{
await
promiseInstallFile
(
XPIS
.
blocklist_soft1_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft2_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft3_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft4_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_hard_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_regexp_1
)
;
}
)
;
add_task
(
async
function
run_manual_update_test
(
)
{
await
Pload_blocklist
(
"
manual_update
"
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s4
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
await
s2
.
enable
(
)
;
await
s2
.
disable
(
)
;
check_addon
(
s2
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
await
s3
.
enable
(
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
await
Pmanual_update
(
"
2
"
)
;
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
const
sv2
=
useMLBF
?
"
1
.
0
"
:
"
2
.
0
"
;
check_addon
(
s1
sv2
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
sv2
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
sv2
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s4
sv2
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
await
Pmanual_update
(
"
3
"
)
;
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s2
"
3
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s3
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s4
"
3
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
h
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
r
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
}
)
;
add_task
(
async
function
run_manual_update_2_test
(
)
{
let
addons
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
await
Promise
.
all
(
addons
.
map
(
addon
=
>
addon
.
uninstall
(
)
)
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft1_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft2_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft3_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_soft4_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_hard_1
)
;
await
promiseInstallFile
(
XPIS
.
blocklist_regexp_1
)
;
let
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
await
s2
.
enable
(
)
;
await
s2
.
disable
(
)
;
check_addon
(
s2
"
1
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
await
s3
.
enable
(
)
;
check_addon
(
s3
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
await
Pmanual_update
(
"
2
"
)
;
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
const
sv2
=
useMLBF
?
"
1
.
0
"
:
"
2
.
0
"
;
check_addon
(
s1
sv2
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
sv2
true
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
sv2
false
false
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
await
Pmanual_update
(
"
3
"
)
;
[
s1
s2
s3
s4
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s2
"
3
.
0
"
true
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
s3
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
h
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
check_addon
(
r
"
3
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
await
s1
.
enable
(
)
;
await
s2
.
enable
(
)
;
await
s4
.
disable
(
)
;
}
)
;
add_task
(
async
function
run_local_install_test
(
)
{
let
addons
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
await
Promise
.
all
(
addons
.
map
(
addon
=
>
addon
.
uninstall
(
)
)
)
;
await
promiseInstallAllFiles
(
[
XPIS
.
blocklist_soft1_1
XPIS
.
blocklist_soft2_1
XPIS
.
blocklist_soft3_1
XPIS
.
blocklist_soft4_1
XPIS
.
blocklist_hard_1
XPIS
.
blocklist_regexp_1
]
)
;
let
installs
=
await
AddonManager
.
getAllInstalls
(
)
;
Assert
.
equal
(
installs
.
length
0
)
;
let
[
s1
s2
s3
h
r
]
=
await
promiseAddonsByIDs
(
ADDON_IDS
)
;
check_addon
(
s1
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s2
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
s3
"
1
.
0
"
true
true
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
;
check_addon
(
h
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
check_addon
(
r
"
1
.
0
"
false
false
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
}
)
;
