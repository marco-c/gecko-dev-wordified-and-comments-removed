"
use
strict
"
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
blocklist
.
useMLBF
"
true
)
;
const
ExtensionBlocklistMLBF
=
getExtensionBlocklistMLBF
(
)
;
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
"
)
;
AddonTestUtils
.
useRealCertChecks
=
true
;
const
SIGNED_ADDON_XPI_FILE
=
do_get_file
(
"
.
.
/
data
/
webext
-
implicit
-
id
.
xpi
"
)
;
const
SIGNED_ADDON_ID
=
"
webext_implicit_id
tests
.
mozilla
.
org
"
;
const
SIGNED_ADDON_VERSION
=
"
1
.
0
"
;
const
SIGNED_ADDON_KEY
=
{
SIGNED_ADDON_ID
}
:
{
SIGNED_ADDON_VERSION
}
;
const
SIGNED_ADDON_SIGN_TIME
=
1459980789000
;
function
mockMLBF
(
{
blocked
=
[
]
notblocked
=
[
]
generationTime
}
)
{
ExtensionBlocklistMLBF
.
_fetchMLBF
=
async
(
)
=
>
{
return
{
cascadeFilter
:
{
has
(
blockKey
)
{
if
(
blocked
.
includes
(
blockKey
)
)
{
return
true
;
}
if
(
notblocked
.
includes
(
blockKey
)
)
{
return
false
;
}
throw
new
Error
(
Block
entry
must
explicitly
be
listed
:
{
blockKey
}
)
;
}
}
generationTime
}
;
}
;
}
add_task
(
async
function
setup
(
)
{
await
promiseStartupManager
(
)
;
mockMLBF
(
{
}
)
;
await
AddonTestUtils
.
loadBlocklistRawData
(
{
extensionsMLBF
:
[
MLBF_RECORD
]
}
)
;
}
)
;
add_task
(
async
function
signed_xpi_initially_unblocked
(
)
{
mockMLBF
(
{
blocked
:
[
]
notblocked
:
[
SIGNED_ADDON_KEY
]
generationTime
:
SIGNED_ADDON_SIGN_TIME
+
1
}
)
;
await
ExtensionBlocklistMLBF
.
_onUpdate
(
)
;
await
promiseInstallFile
(
SIGNED_ADDON_XPI_FILE
)
;
let
addon
=
await
promiseAddonByID
(
SIGNED_ADDON_ID
)
;
Assert
.
equal
(
addon
.
blocklistState
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
mockMLBF
(
{
blocked
:
[
SIGNED_ADDON_KEY
]
notblocked
:
[
]
generationTime
:
SIGNED_ADDON_SIGN_TIME
+
1
}
)
;
await
ExtensionBlocklistMLBF
.
_onUpdate
(
)
;
Assert
.
equal
(
addon
.
blocklistState
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
Assert
.
deepEqual
(
await
Blocklist
.
getAddonBlocklistEntry
(
addon
)
{
state
:
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
url
:
"
https
:
/
/
addons
.
mozilla
.
org
/
en
-
US
/
xpcshell
/
blocked
-
addon
/
webext_implicit_id
tests
.
mozilla
.
org
/
1
.
0
/
"
}
"
Blocked
addon
should
have
blocked
entry
"
)
;
mockMLBF
(
{
blocked
:
[
SIGNED_ADDON_KEY
]
notblocked
:
[
]
generationTime
:
SIGNED_ADDON_SIGN_TIME
-
1
}
)
;
await
ExtensionBlocklistMLBF
.
_onUpdate
(
)
;
Assert
.
equal
(
addon
.
blocklistState
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
await
addon
.
uninstall
(
)
;
}
)
;
add_task
(
async
function
signed_xpi_blocked_on_install
(
)
{
mockMLBF
(
{
blocked
:
[
SIGNED_ADDON_KEY
]
notblocked
:
[
]
generationTime
:
SIGNED_ADDON_SIGN_TIME
+
1
}
)
;
await
ExtensionBlocklistMLBF
.
_onUpdate
(
)
;
await
promiseInstallFile
(
SIGNED_ADDON_XPI_FILE
)
;
let
addon
=
await
promiseAddonByID
(
SIGNED_ADDON_ID
)
;
Assert
.
equal
(
addon
.
blocklistState
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
;
Assert
.
ok
(
addon
.
appDisabled
"
Blocked
add
-
on
is
disabled
on
install
"
)
;
mockMLBF
(
{
blocked
:
[
]
notblocked
:
[
SIGNED_ADDON_KEY
]
generationTime
:
SIGNED_ADDON_SIGN_TIME
-
1
}
)
;
await
ExtensionBlocklistMLBF
.
_onUpdate
(
)
;
Assert
.
equal
(
addon
.
blocklistState
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
Assert
.
ok
(
!
addon
.
appDisabled
"
Re
-
enabled
after
unblock
"
)
;
await
addon
.
uninstall
(
)
;
}
)
;
add_task
(
async
function
unsigned_not_blocked
(
)
{
const
UNSIGNED_ADDON_ID
=
"
not
-
signed
tests
.
mozilla
.
org
"
;
const
UNSIGNED_ADDON_VERSION
=
"
1
.
0
"
;
const
UNSIGNED_ADDON_KEY
=
{
UNSIGNED_ADDON_ID
}
:
{
UNSIGNED_ADDON_VERSION
}
;
mockMLBF
(
{
blocked
:
[
UNSIGNED_ADDON_KEY
]
notblocked
:
[
]
generationTime
:
SIGNED_ADDON_SIGN_TIME
+
1
}
)
;
await
ExtensionBlocklistMLBF
.
_onUpdate
(
)
;
let
unsignedAddonFile
=
createTempWebExtensionFile
(
{
manifest
:
{
version
:
UNSIGNED_ADDON_VERSION
applications
:
{
gecko
:
{
id
:
UNSIGNED_ADDON_ID
}
}
}
}
)
;
let
[
addon
]
=
await
Promise
.
all
(
[
AddonManager
.
installTemporaryAddon
(
unsignedAddonFile
)
promiseWebExtensionStartup
(
UNSIGNED_ADDON_ID
)
]
)
;
Assert
.
equal
(
addon
.
signedState
AddonManager
.
SIGNEDSTATE_MISSING
)
;
Assert
.
equal
(
addon
.
signedDate
null
)
;
Assert
.
equal
(
addon
.
blocklistState
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
addon
)
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
"
Unsigned
temporary
add
-
on
is
not
blocked
"
)
;
await
addon
.
uninstall
(
)
;
}
)
;
add_task
(
async
function
signed_temporary
(
)
{
mockMLBF
(
{
blocked
:
[
SIGNED_ADDON_KEY
]
notblocked
:
[
]
generationTime
:
SIGNED_ADDON_SIGN_TIME
+
1
}
)
;
await
ExtensionBlocklistMLBF
.
_onUpdate
(
)
;
await
Assert
.
rejects
(
AddonManager
.
installTemporaryAddon
(
SIGNED_ADDON_XPI_FILE
)
/
Add
-
on
webext_implicit_id
tests
.
mozilla
.
org
is
not
compatible
with
application
version
/
"
Blocklisted
add
-
on
cannot
be
installed
"
)
;
}
)
;
