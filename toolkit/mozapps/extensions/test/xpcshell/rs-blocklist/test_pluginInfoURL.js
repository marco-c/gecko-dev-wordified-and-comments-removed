function
MockPlugin
(
name
version
enabledState
)
{
this
.
name
=
name
;
this
.
version
=
version
;
this
.
enabledState
=
enabledState
;
}
MockPlugin
.
prototype
=
{
get
disabled
(
)
{
return
this
.
enabledState
=
=
Ci
.
nsIPluginTag
.
STATE_DISABLED
;
}
}
;
const
PLUGINS
=
[
new
MockPlugin
(
"
test_with_infoURL
"
"
5
"
Ci
.
nsIPluginTag
.
STATE_ENABLED
)
new
MockPlugin
(
"
test_with_altInfoURL
"
"
5
"
Ci
.
nsIPluginTag
.
STATE_ENABLED
)
new
MockPlugin
(
"
test_no_infoURL
"
"
5
"
Ci
.
nsIPluginTag
.
STATE_ENABLED
)
new
MockPlugin
(
"
test_newVersion
"
"
1
"
Ci
.
nsIPluginTag
.
STATE_ENABLED
)
new
MockPlugin
(
"
test_newVersion
"
"
3
"
Ci
.
nsIPluginTag
.
STATE_ENABLED
)
]
;
const
BLOCKLIST_DATA
=
[
{
matchName
:
"
^
test_with_infoURL
"
matchVersion
:
"
^
5
"
versionRange
:
[
{
targetApplication
:
[
{
guid
:
"
xpcshell
tests
.
mozilla
.
org
"
maxVersion
:
"
*
"
minVersion
:
"
1
"
}
]
}
]
blockID
:
"
test_plugin_wInfoURL
"
infoURL
:
"
http
:
/
/
test
.
url
.
com
/
"
}
{
matchName
:
"
^
test_with_altInfoURL
"
matchVersion
:
"
^
5
"
versionRange
:
[
{
targetApplication
:
[
{
guid
:
"
xpcshell
tests
.
mozilla
.
org
"
maxVersion
:
"
*
"
minVersion
:
"
1
"
}
]
}
]
blockID
:
"
test_plugin_wAltInfoURL
"
infoURL
:
"
http
:
/
/
alt
.
test
.
url
.
com
/
"
}
{
matchName
:
"
^
test_no_infoURL
"
versionRange
:
[
{
targetApplication
:
[
{
guid
:
"
xpcshell
tests
.
mozilla
.
org
"
maxVersion
:
"
*
"
minVersion
:
"
1
"
}
]
}
]
blockID
:
"
test_plugin_noInfoURL
"
}
{
matchName
:
"
^
test_newVersion
"
versionRange
:
[
{
maxVersion
:
"
2
"
minVersion
:
"
1
"
targetApplication
:
[
{
guid
:
"
xpcshell
tests
.
mozilla
.
org
"
maxVersion
:
"
*
"
minVersion
:
"
1
"
}
]
}
]
blockID
:
"
test_plugin_newVersion
"
infoURL
:
"
http
:
/
/
test
.
url2
.
com
/
"
}
]
;
add_task
(
async
function
setup
(
)
{
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
3
"
"
8
"
)
;
await
promiseStartupManager
(
)
;
await
AddonTestUtils
.
loadBlocklistRawData
(
{
plugins
:
BLOCKLIST_DATA
}
)
;
}
)
;
add_task
(
async
function
test_infoURL
(
)
{
let
testInfoURL
=
"
http
:
/
/
test
.
url
.
com
/
"
;
Assert
.
strictEqual
(
await
Blocklist
.
getPluginBlockURL
(
PLUGINS
[
0
]
)
testInfoURL
"
Should
be
the
provided
url
when
an
infoURL
tag
is
available
"
)
;
}
)
;
add_task
(
async
function
test_altInfoURL
(
)
{
let
altTestInfoURL
=
"
http
:
/
/
alt
.
test
.
url
.
com
/
"
;
Assert
.
strictEqual
(
await
Blocklist
.
getPluginBlockURL
(
PLUGINS
[
1
]
)
altTestInfoURL
"
Should
be
the
alternative
infoURL
"
)
;
}
)
;
add_task
(
async
function
test_infoURL_missing
(
)
{
let
fallback_URL
=
Services
.
prefs
.
getStringPref
(
"
extensions
.
blocklist
.
detailsURL
"
)
+
"
test_plugin_noInfoURL
.
html
"
;
Assert
.
strictEqual
(
await
Blocklist
.
getPluginBlockURL
(
PLUGINS
[
2
]
)
fallback_URL
"
Should
be
using
fallback
when
no
infoURL
tag
is
available
.
"
)
;
}
)
;
add_task
(
async
function
test_intoURL_newVersion
(
)
{
let
testInfoURL
=
"
http
:
/
/
test
.
url2
.
com
/
"
;
Assert
.
strictEqual
(
await
Blocklist
.
getPluginBlockURL
(
PLUGINS
[
3
]
)
testInfoURL
"
Old
plugin
should
match
"
)
;
Assert
.
strictEqual
(
await
Blocklist
.
getPluginBlockURL
(
PLUGINS
[
4
]
)
null
"
New
plugin
should
not
match
"
)
;
}
)
;
