"
use
strict
"
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
blocklist
.
useMLBF
"
true
)
;
const
ExtensionBlocklistMLBF
=
getExtensionBlocklistMLBF
(
)
;
const
blockedAddon
=
{
id
:
"
{
6f62927a
-
e380
-
401a
-
8c9e
-
c485b7d87f0d
}
"
version
:
"
9
.
2
.
0
"
signedDate
:
new
Date
(
1588098908496
)
signedState
:
AddonManager
.
SIGNEDSTATE_SIGNED
}
;
const
nonBlockedAddon
=
{
id
:
"
disable
-
ctrl
-
q
-
and
-
cmd
-
q
robwu
.
nl
"
version
:
"
1
"
signedDate
:
new
Date
(
1482430349000
)
signedState
:
AddonManager
.
SIGNEDSTATE_SIGNED
}
;
async
function
sha256
(
arrayBuffer
)
{
Cu
.
importGlobalProperties
(
[
"
crypto
"
]
)
;
let
hash
=
await
crypto
.
subtle
.
digest
(
"
SHA
-
256
"
arrayBuffer
)
;
const
toHex
=
b
=
>
b
.
toString
(
16
)
.
padStart
(
2
"
0
"
)
;
return
Array
.
from
(
new
Uint8Array
(
hash
)
toHex
)
.
join
(
"
"
)
;
}
const
observed
=
[
]
;
add_task
(
async
function
setup
(
)
{
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
"
)
;
ExtensionBlocklistMLBF
.
ensureInitialized
(
)
;
const
originalImpl
=
ExtensionBlocklistMLBF
.
_client
.
attachments
.
download
;
ExtensionBlocklistMLBF
.
_client
.
attachments
.
download
=
function
(
record
)
{
let
downloadPromise
=
originalImpl
.
apply
(
this
arguments
)
;
observed
.
push
(
{
inputRecord
:
record
downloadPromise
}
)
;
return
downloadPromise
;
}
;
await
promiseStartupManager
(
)
;
}
)
;
async
function
verifyBlocklistWorksWithDump
(
)
{
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
"
A
add
-
on
that
is
known
to
be
on
the
blocklist
should
be
blocked
"
)
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
nonBlockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
"
A
known
non
-
blocked
add
-
on
should
not
be
blocked
"
)
;
}
add_task
(
async
function
verify_dump_first_run
(
)
{
await
verifyBlocklistWorksWithDump
(
)
;
Assert
.
equal
(
observed
.
length
1
"
expected
number
of
MLBF
download
requests
"
)
;
const
{
inputRecord
downloadPromise
}
=
observed
.
pop
(
)
;
Assert
.
ok
(
inputRecord
"
addons
-
bloomfilters
collection
dump
exists
"
)
;
const
downloadResult
=
await
downloadPromise
;
Assert
.
equal
(
downloadResult
.
_source
"
dump_match
"
"
MLBF
attachment
should
match
the
RemoteSettings
collection
"
)
;
Assert
.
equal
(
await
sha256
(
downloadResult
.
buffer
)
inputRecord
.
attachment
.
hash
"
The
content
of
the
attachment
should
actually
matches
the
record
"
)
;
}
)
;
add_task
(
async
function
use_dump_fallback_when_collection_is_out_of_sync
(
)
{
await
AddonTestUtils
.
loadBlocklistRawData
(
{
extensionsMLBF
:
[
{
last_modified
:
Date
.
now
(
)
}
]
}
)
;
Assert
.
equal
(
observed
.
length
1
"
Expected
new
download
on
update
"
)
;
const
{
inputRecord
downloadPromise
}
=
observed
.
pop
(
)
;
Assert
.
equal
(
inputRecord
null
"
No
MLBF
record
found
"
)
;
const
downloadResult
=
await
downloadPromise
;
Assert
.
equal
(
downloadResult
.
_source
"
dump_fallback
"
"
should
have
used
fallback
despite
the
absence
of
a
MLBF
record
"
)
;
await
verifyBlocklistWorksWithDump
(
)
;
Assert
.
equal
(
observed
.
length
0
"
Blocklist
uses
cached
result
"
)
;
}
)
;
add_task
(
async
function
verify_dump_supersedes_old_dump
(
)
{
delete
ExtensionBlocklistMLBF
.
_mlbfData
;
await
AddonTestUtils
.
loadBlocklistRawData
(
{
extensionsMLBF
:
[
{
last_modified
:
1
}
]
}
)
;
Assert
.
equal
(
observed
.
length
1
"
Expected
new
download
on
update
"
)
;
const
{
inputRecord
downloadPromise
}
=
observed
.
pop
(
)
;
Assert
.
ok
(
inputRecord
"
should
have
read
from
addons
-
bloomfilters
dump
"
)
;
const
downloadResult
=
await
downloadPromise
;
Assert
.
equal
(
downloadResult
.
_source
"
dump_match
"
"
Should
have
replaced
outdated
collection
records
with
dump
"
)
;
await
verifyBlocklistWorksWithDump
(
)
;
Assert
.
equal
(
observed
.
length
0
"
Blocklist
uses
cached
result
"
)
;
}
)
;
