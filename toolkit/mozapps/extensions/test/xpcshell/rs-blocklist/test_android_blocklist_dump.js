"
use
strict
"
;
const
IS_USING_BLOCKLIST_V3
=
AppConstants
.
NIGHTLY_BUILD
;
const
blockedAddon
=
{
id
:
"
{
6f62927a
-
e380
-
401a
-
8c9e
-
c485b7d87f0d
}
"
version
:
"
9
.
2
.
0
"
signedDate
:
new
Date
(
1588098908496
)
signedState
:
AddonManager
.
SIGNEDSTATE_SIGNED
}
;
const
blockedAddonV3only
=
{
id
:
"
{
011f65f0
-
7143
-
470a
-
83ca
-
20ec4297f3f4
}
"
version
:
"
1
.
0
"
}
;
const
nonBlockedAddon
=
{
id
:
"
disable
-
ctrl
-
q
-
and
-
cmd
-
q
robwu
.
nl
"
version
:
"
1
"
signedDate
:
new
Date
(
1482430349000
)
signedState
:
AddonManager
.
SIGNEDSTATE_SIGNED
}
;
add_task
(
{
skip_if
:
(
)
=
>
IS_USING_BLOCKLIST_V3
}
async
function
verify_blocklistv2_dump_first_run
(
)
{
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
"
)
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
"
A
add
-
on
that
is
known
to
be
on
the
v2
blocklist
should
be
blocked
"
)
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddonV3only
)
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
"
An
add
-
on
that
is
not
part
of
the
v2
blocklist
should
not
be
blocked
"
)
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
nonBlockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
"
A
known
non
-
blocked
add
-
on
should
not
be
blocked
"
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
IS_USING_BLOCKLIST_V3
}
async
function
verify_a_known_blocked_add_on_is_not_detected_as_blocked_at_first_run
(
)
{
const
MLBF_LOAD_RESULTS
=
[
]
;
const
MLBF_LOAD_ATTEMPTS
=
[
]
;
const
onLoadAttempts
=
record
=
>
MLBF_LOAD_ATTEMPTS
.
push
(
record
)
;
const
onLoadResult
=
promise
=
>
MLBF_LOAD_RESULTS
.
push
(
promise
)
;
spyOnExtensionBlocklistMLBF
(
onLoadAttempts
onLoadResult
)
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
"
A
known
blocked
add
-
on
should
not
be
blocked
at
first
"
)
;
await
Assert
.
rejects
(
MLBF_LOAD_RESULTS
[
0
]
/
DownloadError
:
Could
not
download
addons
-
mlbf
.
bin
/
"
Should
not
find
any
packaged
attachment
"
)
;
MLBF_LOAD_ATTEMPTS
.
length
=
0
;
MLBF_LOAD_RESULTS
.
length
=
0
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
"
Blocklist
is
still
not
populated
"
)
;
Assert
.
deepEqual
(
MLBF_LOAD_ATTEMPTS
[
]
"
MLBF
is
not
fetched
again
after
the
first
lookup
"
)
;
}
)
;
function
spyOnExtensionBlocklistMLBF
(
onLoadAttempts
onLoadResult
)
{
const
ExtensionBlocklistMLBF
=
getExtensionBlocklistMLBF
(
)
;
const
originalFetchMLBF
=
ExtensionBlocklistMLBF
.
_fetchMLBF
;
ExtensionBlocklistMLBF
.
_fetchMLBF
=
async
function
(
record
)
{
onLoadAttempts
(
record
)
;
let
promise
=
originalFetchMLBF
.
apply
(
this
arguments
)
;
onLoadResult
(
promise
)
;
return
promise
;
}
;
registerCleanupFunction
(
(
)
=
>
(
ExtensionBlocklistMLBF
.
_fetchMLBF
=
originalFetchMLBF
)
)
;
return
ExtensionBlocklistMLBF
;
}
