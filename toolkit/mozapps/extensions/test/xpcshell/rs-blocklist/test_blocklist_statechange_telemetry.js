"
use
strict
"
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
blocklist
.
useMLBF
"
true
)
;
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
42
.
0
"
"
42
.
0
"
)
;
AddonTestUtils
.
usePrivilegedSignatures
=
false
;
const
{
Downloader
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
services
-
settings
/
Attachments
.
sys
.
mjs
"
)
;
const
{
TelemetryController
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
sys
.
mjs
"
)
;
const
{
TelemetryTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
)
;
const
ExtensionBlocklistMLBF
=
getExtensionBlocklistMLBF
(
)
;
const
EXT_ID
=
"
maybeblockme
tests
.
mozilla
.
org
"
;
const
EXT_BLOCKED_ID
=
"
blocked
"
;
const
EXT_BLOCKED_VERSION
=
"
1
"
;
const
EXT_BLOCKED_SIGN_TIME
=
12345
;
const
server
=
AddonTestUtils
.
createHttpServer
(
)
;
const
SERVER_BASE_URL
=
http
:
/
/
127
.
0
.
0
.
1
:
{
server
.
identity
.
primaryPort
}
;
const
SERVER_UPDATE_PATH
=
"
/
update
.
json
"
;
const
SERVER_UPDATE_URL
=
{
SERVER_BASE_URL
}
{
SERVER_UPDATE_PATH
}
;
Services
.
prefs
.
setBoolPref
(
PREF_EM_CHECK_UPDATE_SECURITY
false
)
;
async
function
assertEventDetails
(
expectedExtras
)
{
if
(
!
IS_ANDROID_BUILD
)
{
const
expectedEvents
=
expectedExtras
.
map
(
expectedExtra
=
>
{
let
{
object
value
.
.
.
extra
}
=
expectedExtra
;
return
[
"
blocklist
"
"
addonBlockChange
"
object
value
extra
]
;
}
)
;
await
TelemetryTestUtils
.
assertEvents
(
expectedEvents
{
category
:
"
blocklist
"
method
:
"
addonBlockChange
"
}
)
;
}
else
{
info
(
Skip
assertions
on
collected
samples
for
addonBlockChange
on
android
builds
)
;
}
assertGleanEventDetails
(
expectedExtras
)
;
}
async
function
assertGleanEventDetails
(
expectedExtras
)
{
const
snapshot
=
testGetValue
(
Glean
.
blocklist
.
addonBlockChange
)
;
if
(
expectedExtras
.
length
=
=
=
0
)
{
Assert
.
deepEqual
(
undefined
snapshot
"
Expected
zero
addonBlockChange
"
)
;
return
;
}
Assert
.
equal
(
expectedExtras
.
length
snapshot
?
.
length
"
Number
of
addonBlockChange
records
"
)
;
for
(
let
i
of
expectedExtras
.
keys
(
)
)
{
let
actual
=
snapshot
[
i
]
.
extra
;
let
{
blocklistState
.
.
.
expected
}
=
expectedExtras
[
i
]
;
expected
.
blocklist_state
=
blocklistState
;
Assert
.
deepEqual
(
expected
actual
Expected
addonBlockChange
(
{
i
}
)
)
;
}
}
function
setupAddonUpdate
(
addonId
addonVersion
)
{
let
updateXpi
=
AddonTestUtils
.
createTempWebExtensionFile
(
{
manifest
:
{
version
:
addonVersion
browser_specific_settings
:
{
gecko
:
{
id
:
addonId
update_url
:
SERVER_UPDATE_URL
}
}
}
}
)
;
let
updateXpiPath
=
/
update
-
{
addonId
}
-
{
addonVersion
}
.
xpi
;
server
.
registerFile
(
updateXpiPath
updateXpi
)
;
AddonTestUtils
.
registerJSON
(
server
SERVER_UPDATE_PATH
{
addons
:
{
[
addonId
]
:
{
updates
:
[
{
version
:
addonVersion
update_link
:
{
SERVER_BASE_URL
}
{
updateXpiPath
}
}
]
}
}
}
)
;
}
async
function
tryAddonInstall
(
addonId
addonVersion
)
{
let
xpiFile
=
AddonTestUtils
.
createTempWebExtensionFile
(
{
manifest
:
{
version
:
addonVersion
browser_specific_settings
:
{
gecko
:
{
id
:
addonId
update_url
:
SERVER_UPDATE_URL
}
}
}
}
)
;
const
install
=
await
promiseInstallFile
(
xpiFile
true
)
;
return
install
?
.
addon
;
}
add_task
(
async
function
setup
(
)
{
if
(
!
IS_ANDROID_BUILD
)
{
do_get_profile
(
)
;
Services
.
fog
.
initializeFOG
(
)
;
}
await
TelemetryController
.
testSetup
(
)
;
Downloader
.
_RESOURCE_BASE_URL
=
"
invalid
:
/
/
bogus
"
;
await
promiseStartupManager
(
)
;
}
)
;
add_task
(
async
function
install_update_not_blocked_is_no_events
(
)
{
resetBlocklistTelemetry
(
)
;
let
addon
=
await
tryAddonInstall
(
EXT_ID
"
0
.
1
"
)
;
setupAddonUpdate
(
EXT_ID
"
1
"
)
;
let
update
=
await
AddonTestUtils
.
promiseFindAddonUpdates
(
addon
)
;
await
promiseCompleteInstall
(
update
.
updateAvailable
)
;
addon
=
await
AddonManager
.
getAddonByID
(
EXT_ID
)
;
equal
(
addon
.
version
"
1
"
"
Add
-
on
was
updated
"
)
;
await
assertEventDetails
(
[
]
)
;
}
)
;
add_task
(
async
function
blocklist_update_events
(
)
{
resetBlocklistTelemetry
(
)
;
const
EXT_HOURS_SINCE_INSTALL
=
4321
;
const
addon
=
await
AddonManager
.
getAddonByID
(
EXT_ID
)
;
addon
.
__AddonInternal__
.
installDate
=
addon
.
installDate
.
getTime
(
)
-
3600000
*
EXT_HOURS_SINCE_INSTALL
;
await
AddonTestUtils
.
loadBlocklistRawData
(
{
extensionsMLBF
:
[
{
stash
:
{
blocked
:
[
{
EXT_ID
}
:
1
]
unblocked
:
[
]
}
stash_time
:
123
}
{
stash
:
{
blocked
:
[
{
EXT_ID
}
:
2
]
unblocked
:
[
]
}
stash_time
:
456
}
]
}
)
;
await
assertEventDetails
(
[
{
object
:
"
blocklist_update
"
value
:
EXT_ID
blocklistState
:
"
2
"
addon_version
:
"
1
"
signed_date
:
"
0
"
hours_since
:
{
EXT_HOURS_SINCE_INSTALL
}
mlbf_last_time
:
"
456
"
mlbf_generation
:
"
0
"
mlbf_source
:
"
unknown
"
}
]
)
;
}
)
;
add_task
(
async
function
update_check_blocked_by_stash
(
)
{
resetBlocklistTelemetry
(
)
;
setupAddonUpdate
(
EXT_ID
"
2
"
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
EXT_ID
)
;
let
update
=
await
AddonTestUtils
.
promiseFindAddonUpdates
(
addon
)
;
equal
(
update
.
updateAvailable
false
"
Update
was
blocked
by
stash
"
)
;
await
assertEventDetails
(
[
{
object
:
"
addon_update_check
"
value
:
EXT_ID
blocklistState
:
"
2
"
addon_version
:
"
2
"
signed_date
:
"
0
"
hours_since
:
"
-
1
"
mlbf_last_time
:
"
456
"
mlbf_generation
:
"
0
"
mlbf_source
:
"
unknown
"
}
]
)
;
}
)
;
add_task
(
async
function
reinstall_blocked_addon
(
)
{
resetBlocklistTelemetry
(
)
;
let
blockedAddon
=
await
AddonManager
.
getAddonByID
(
EXT_ID
)
;
equal
(
blockedAddon
.
blocklistState
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
"
Addon
was
initially
blocked
"
)
;
let
addon
=
await
tryAddonInstall
(
EXT_ID
"
2
"
)
;
ok
(
!
addon
"
Add
-
on
install
should
be
blocked
by
a
stash
"
)
;
await
assertEventDetails
(
[
{
object
:
"
addon_install
"
value
:
EXT_ID
blocklistState
:
"
2
"
addon_version
:
"
2
"
signed_date
:
"
0
"
hours_since
:
"
-
1
"
mlbf_last_time
:
"
456
"
mlbf_generation
:
"
0
"
mlbf_source
:
"
unknown
"
}
]
)
;
}
)
;
add_task
(
async
function
regular_restart_no_event
(
)
{
resetBlocklistTelemetry
(
)
;
await
promiseRestartManager
(
"
90
.
0
"
)
;
await
assertEventDetails
(
[
]
)
;
await
promiseRestartManager
(
)
;
await
assertEventDetails
(
[
]
)
;
}
)
;
add_task
(
async
function
database_modified
(
)
{
resetBlocklistTelemetry
(
)
;
const
EXT_HOURS_SINCE_INSTALL
=
3
;
await
promiseShutdownManager
(
)
;
let
addonDB
=
await
IOUtils
.
readJSON
(
gExtensionsJSON
.
path
)
;
let
rawAddon
=
addonDB
.
addons
[
0
]
;
equal
(
rawAddon
.
id
EXT_ID
"
Expected
entry
in
addonDB
"
)
;
equal
(
rawAddon
.
blocklistState
2
"
Expected
STATE_BLOCKED
"
)
;
rawAddon
.
blocklistState
=
0
;
rawAddon
.
installDate
=
Date
.
now
(
)
-
3600000
*
EXT_HOURS_SINCE_INSTALL
;
await
IOUtils
.
writeJSON
(
gExtensionsJSON
.
path
addonDB
)
;
await
promiseStartupManager
(
"
91
.
0
"
)
;
await
promiseShutdownManager
(
)
;
await
assertEventDetails
(
[
{
object
:
"
addon_db_modified
"
value
:
EXT_ID
blocklistState
:
"
2
"
addon_version
:
"
1
"
signed_date
:
"
0
"
hours_since
:
{
EXT_HOURS_SINCE_INSTALL
}
mlbf_last_time
:
"
456
"
mlbf_generation
:
"
0
"
mlbf_source
:
"
unknown
"
}
]
)
;
resetBlocklistTelemetry
(
)
;
await
promiseStartupManager
(
)
;
await
assertEventDetails
(
[
]
)
;
}
)
;
add_task
(
async
function
install_replaces_blocked_addon
(
)
{
resetBlocklistTelemetry
(
)
;
let
addon
=
await
tryAddonInstall
(
EXT_ID
"
3
"
)
;
ok
(
addon
"
Update
supersedes
blocked
add
-
on
"
)
;
await
assertEventDetails
(
[
{
object
:
"
addon_install
"
value
:
EXT_ID
blocklistState
:
"
0
"
addon_version
:
"
3
"
signed_date
:
"
0
"
hours_since
:
"
-
1
"
mlbf_last_time
:
"
456
"
mlbf_generation
:
"
0
"
mlbf_source
:
"
unknown
"
}
]
)
;
}
)
;
add_task
(
async
function
install_blocked_by_mlbf
(
)
{
resetBlocklistTelemetry
(
)
;
await
ExtensionBlocklistMLBF
.
_client
.
db
.
saveAttachment
(
ExtensionBlocklistMLBF
.
RS_ATTACHMENT_ID
{
record
:
MLBF_RECORD
blob
:
await
load_mlbf_record_as_blob
(
)
}
)
;
await
AddonTestUtils
.
loadBlocklistRawData
(
{
extensionsMLBF
:
[
MLBF_RECORD
]
}
)
;
AddonTestUtils
.
certSignatureDate
=
EXT_BLOCKED_SIGN_TIME
;
let
addon
=
await
tryAddonInstall
(
EXT_BLOCKED_ID
EXT_BLOCKED_VERSION
)
;
AddonTestUtils
.
certSignatureDate
=
null
;
ok
(
!
addon
"
Add
-
on
install
should
be
blocked
by
the
MLBF
"
)
;
await
assertEventDetails
(
[
{
object
:
"
addon_install
"
value
:
EXT_BLOCKED_ID
blocklistState
:
"
2
"
addon_version
:
EXT_BLOCKED_VERSION
signed_date
:
{
EXT_BLOCKED_SIGN_TIME
}
hours_since
:
"
-
1
"
mlbf_last_time
:
{
MLBF_RECORD
.
generation_time
}
mlbf_generation
:
{
MLBF_RECORD
.
generation_time
}
mlbf_source
:
"
cache_match
"
}
]
)
;
}
)
;
add_task
(
async
function
update_check_blocked_by_mlbf
(
)
{
resetBlocklistTelemetry
(
)
;
let
addon
=
await
tryAddonInstall
(
EXT_BLOCKED_ID
"
0
.
1
"
)
;
setupAddonUpdate
(
EXT_BLOCKED_ID
EXT_BLOCKED_VERSION
)
;
AddonTestUtils
.
certSignatureDate
=
EXT_BLOCKED_SIGN_TIME
;
let
update
=
await
AddonTestUtils
.
promiseFindAddonUpdates
(
addon
)
;
ok
(
update
.
updateAvailable
"
Update
was
not
blocked
by
stash
"
)
;
await
promiseCompleteInstall
(
update
.
updateAvailable
)
;
AddonTestUtils
.
certSignatureDate
=
null
;
addon
=
await
AddonManager
.
getAddonByID
(
EXT_BLOCKED_ID
)
;
equal
(
addon
.
version
EXT_BLOCKED_VERSION
"
Add
-
on
was
updated
"
)
;
equal
(
addon
.
blocklistState
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
"
Add
-
on
is
blocked
"
)
;
equal
(
addon
.
appDisabled
true
"
Add
-
on
was
disabled
because
of
the
block
"
)
;
await
assertEventDetails
(
[
{
object
:
"
addon_update
"
value
:
EXT_BLOCKED_ID
blocklistState
:
"
2
"
addon_version
:
EXT_BLOCKED_VERSION
signed_date
:
{
EXT_BLOCKED_SIGN_TIME
}
hours_since
:
"
-
1
"
mlbf_last_time
:
{
MLBF_RECORD
.
generation_time
}
mlbf_generation
:
{
MLBF_RECORD
.
generation_time
}
mlbf_source
:
"
cache_match
"
}
]
)
;
}
)
;
add_task
(
async
function
update_blocked_to_unblocked
(
)
{
resetBlocklistTelemetry
(
)
;
let
blockedAddon
=
await
AddonManager
.
getAddonByID
(
EXT_BLOCKED_ID
)
;
setupAddonUpdate
(
EXT_BLOCKED_ID
"
3
"
)
;
AddonTestUtils
.
certSignatureDate
=
EXT_BLOCKED_SIGN_TIME
;
let
update
=
await
AddonTestUtils
.
promiseFindAddonUpdates
(
blockedAddon
)
;
ok
(
update
.
updateAvailable
"
Found
an
update
"
)
;
await
promiseCompleteInstall
(
update
.
updateAvailable
)
;
AddonTestUtils
.
certSignatureDate
=
null
;
let
addon
=
await
AddonManager
.
getAddonByID
(
EXT_BLOCKED_ID
)
;
equal
(
addon
.
appDisabled
false
"
Add
-
on
was
re
-
enabled
after
unblock
"
)
;
await
assertEventDetails
(
[
{
object
:
"
addon_update
"
value
:
EXT_BLOCKED_ID
blocklistState
:
"
0
"
addon_version
:
"
3
"
signed_date
:
{
EXT_BLOCKED_SIGN_TIME
}
hours_since
:
"
-
1
"
mlbf_last_time
:
{
MLBF_RECORD
.
generation_time
}
mlbf_generation
:
{
MLBF_RECORD
.
generation_time
}
mlbf_source
:
"
cache_match
"
}
]
)
;
}
)
;
