"
use
strict
"
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
blocklist
.
useMLBF
"
true
)
;
const
{
Downloader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
settings
/
Attachments
.
jsm
"
)
;
const
{
ExtensionBlocklistMLBF
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Blocklist
.
jsm
"
null
)
;
ExtensionBlocklistMLBF
.
ensureInitialized
(
)
;
add_task
(
async
function
fetch_invalid_mlbf_record
(
)
{
let
invalidRecord
=
{
attachment
:
{
size
:
1
hash
:
"
definitely
not
valid
"
}
generation_time
:
1
}
;
let
resultPromise
=
ExtensionBlocklistMLBF
.
_fetchMLBF
(
invalidRecord
)
;
await
Assert
.
rejects
(
resultPromise
/
NetworkError
/
"
record
not
found
"
)
;
Downloader
.
_RESOURCE_BASE_URL
=
"
invalid
:
/
/
bogus
"
;
await
Assert
.
rejects
(
ExtensionBlocklistMLBF
.
_fetchMLBF
(
invalidRecord
)
/
NetworkError
|
SyntaxError
:
JSON
\
.
parse
/
"
record
not
found
when
there
is
no
packaged
MLBF
"
)
;
}
)
;
add_task
(
async
function
fetch_valid_mlbf
(
)
{
const
url
=
Services
.
io
.
newFileURI
(
do_get_file
(
"
.
.
/
data
/
mlbf
-
blocked1
-
unblocked2
.
bin
"
)
)
.
spec
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
const
blob
=
await
(
await
fetch
(
url
)
)
.
blob
(
)
;
await
ExtensionBlocklistMLBF
.
_client
.
db
.
saveAttachment
(
ExtensionBlocklistMLBF
.
RS_ATTACHMENT_ID
{
record
:
JSON
.
parse
(
JSON
.
stringify
(
MLBF_RECORD
)
)
blob
}
)
;
const
result
=
await
ExtensionBlocklistMLBF
.
_fetchMLBF
(
MLBF_RECORD
)
;
Assert
.
equal
(
result
.
cascadeHash
MLBF_RECORD
.
attachment
.
hash
"
hash
OK
"
)
;
Assert
.
equal
(
result
.
generationTime
MLBF_RECORD
.
generation_time
"
time
OK
"
)
;
Assert
.
ok
(
result
.
cascadeFilter
.
has
(
"
blocked
:
1
"
)
"
item
blocked
"
)
;
Assert
.
ok
(
!
result
.
cascadeFilter
.
has
(
"
unblocked
:
2
"
)
"
item
not
blocked
"
)
;
const
result2
=
await
ExtensionBlocklistMLBF
.
_fetchMLBF
(
{
attachment
:
{
size
:
1
hash
:
"
invalid
"
}
generation_time
:
Date
.
now
(
)
}
)
;
Assert
.
equal
(
result2
.
cascadeHash
MLBF_RECORD
.
attachment
.
hash
"
The
cached
MLBF
should
be
used
when
the
attachment
is
invalid
"
)
;
}
)
;
add_task
(
async
function
public_api_uses_mlbf
(
)
{
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
"
)
;
await
promiseStartupManager
(
)
;
const
blockedAddon
=
{
id
:
"
blocked
"
version
:
"
1
"
signedState
:
2
signedDate
:
0
}
;
const
nonBlockedAddon
=
{
id
:
"
unblocked
"
version
:
"
2
"
signedState
:
2
signedDate
:
0
}
;
await
AddonTestUtils
.
loadBlocklistRawData
(
{
extensionsMLBF
:
[
MLBF_RECORD
]
}
)
;
Assert
.
deepEqual
(
await
Blocklist
.
getAddonBlocklistEntry
(
blockedAddon
)
{
state
:
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
url
:
"
https
:
/
/
addons
.
mozilla
.
org
/
en
-
US
/
xpcshell
/
blocked
-
addon
/
blocked
/
1
/
"
}
"
Blocked
addon
should
have
blocked
entry
"
)
;
Assert
.
deepEqual
(
await
Blocklist
.
getAddonBlocklistEntry
(
nonBlockedAddon
)
null
"
Non
-
blocked
addon
should
not
be
blocked
"
)
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
"
Blocked
entry
should
have
blocked
state
"
)
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
nonBlockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
"
Non
-
blocked
entry
should
have
unblocked
state
"
)
;
}
)
;
add_task
(
async
function
handle_database_corruption
(
)
{
const
blockedAddon
=
{
id
:
"
blocked
"
version
:
"
1
"
signedState
:
2
signedDate
:
0
}
;
async
function
checkBlocklistWorks
(
)
{
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
"
Add
-
on
should
be
blocked
by
the
blocklist
"
)
;
}
await
AddonTestUtils
.
loadBlocklistRawData
(
{
extensionsMLBF
:
[
]
}
)
;
await
checkBlocklistWorks
(
)
;
await
ExtensionBlocklistMLBF
.
_client
.
db
.
saveAttachment
(
ExtensionBlocklistMLBF
.
RS_ATTACHMENT_ID
null
)
;
await
checkBlocklistWorks
(
)
;
await
ExtensionBlocklistMLBF
.
_onUpdate
(
)
;
await
checkBlocklistWorks
(
)
;
delete
ExtensionBlocklistMLBF
.
_mlbfData
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
"
Blocklist
can
'
t
work
if
all
blocklist
data
is
gone
"
)
;
}
)
;
