"
use
strict
"
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
blocklist
.
useMLBF
"
true
)
;
const
{
Downloader
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
services
-
settings
/
Attachments
.
sys
.
mjs
"
)
;
const
ExtensionBlocklistMLBF
=
getExtensionBlocklistMLBF
(
)
;
ExtensionBlocklistMLBF
.
ensureInitialized
(
)
;
add_task
(
async
function
fetch_invalid_mlbf_record
(
)
{
let
invalidRecord
=
{
attachment
:
{
size
:
1
hash
:
"
definitely
not
valid
"
}
generation_time
:
1
}
;
Downloader
.
_RESOURCE_BASE_URL
=
"
invalid
:
/
/
bogus
"
;
await
Assert
.
rejects
(
ExtensionBlocklistMLBF
.
_fetchMLBF
(
invalidRecord
)
/
NetworkError
|
SyntaxError
:
JSON
\
.
parse
/
"
record
not
found
when
there
is
no
packaged
MLBF
"
)
;
}
)
;
add_task
(
async
function
fetch_valid_mlbf
(
)
{
await
ExtensionBlocklistMLBF
.
_client
.
db
.
saveAttachment
(
ExtensionBlocklistMLBF
.
RS_ATTACHMENT_ID
{
record
:
MLBF_RECORD
blob
:
await
load_mlbf_record_as_blob
(
)
}
)
;
const
result
=
await
ExtensionBlocklistMLBF
.
_fetchMLBF
(
MLBF_RECORD
)
;
Assert
.
equal
(
result
.
cascadeHash
MLBF_RECORD
.
attachment
.
hash
"
hash
OK
"
)
;
Assert
.
equal
(
result
.
generationTime
MLBF_RECORD
.
generation_time
"
time
OK
"
)
;
Assert
.
ok
(
result
.
cascadeFilter
.
has
(
"
blocked
:
1
"
)
"
item
blocked
"
)
;
Assert
.
ok
(
!
result
.
cascadeFilter
.
has
(
"
unblocked
:
2
"
)
"
item
not
blocked
"
)
;
const
result2
=
await
ExtensionBlocklistMLBF
.
_fetchMLBF
(
{
attachment
:
{
size
:
1
hash
:
"
invalid
"
}
generation_time
:
Date
.
now
(
)
}
)
;
Assert
.
equal
(
result2
.
cascadeHash
MLBF_RECORD
.
attachment
.
hash
"
The
cached
MLBF
should
be
used
when
the
attachment
is
invalid
"
)
;
}
)
;
add_task
(
async
function
public_api_uses_mlbf
(
)
{
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
"
)
;
await
promiseStartupManager
(
)
;
const
blockedAddon
=
{
id
:
"
blocked
"
version
:
"
1
"
signedDate
:
new
Date
(
0
)
signedState
:
AddonManager
.
SIGNEDSTATE_SIGNED
}
;
const
nonBlockedAddon
=
{
id
:
"
unblocked
"
version
:
"
2
"
signedDate
:
new
Date
(
0
)
signedState
:
AddonManager
.
SIGNEDSTATE_SIGNED
}
;
await
AddonTestUtils
.
loadBlocklistRawData
(
{
extensionsMLBF
:
[
MLBF_RECORD
]
}
)
;
Assert
.
deepEqual
(
await
Blocklist
.
getAddonBlocklistEntry
(
blockedAddon
)
{
state
:
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
url
:
"
https
:
/
/
addons
.
mozilla
.
org
/
en
-
US
/
firefox
/
blocked
-
addon
/
blocked
/
1
/
"
}
"
Blocked
addon
should
have
blocked
entry
"
)
;
Assert
.
deepEqual
(
await
Blocklist
.
getAddonBlocklistEntry
(
nonBlockedAddon
)
null
"
Non
-
blocked
addon
should
not
be
blocked
"
)
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
"
Blocked
entry
should
have
blocked
state
"
)
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
nonBlockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
"
Non
-
blocked
entry
should
have
unblocked
state
"
)
;
}
)
;
add_task
(
async
function
fetch_updated_mlbf_same_hash
(
)
{
const
recordUpdate
=
{
.
.
.
MLBF_RECORD
generation_time
:
MLBF_RECORD
.
generation_time
+
1
}
;
const
blockedAddonUpdate
=
{
id
:
"
blocked
"
version
:
"
1
"
signedDate
:
new
Date
(
recordUpdate
.
generation_time
)
signedState
:
AddonManager
.
SIGNEDSTATE_SIGNED
}
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddonUpdate
)
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
"
Add
-
on
not
blocked
before
blocklist
update
"
)
;
await
AddonTestUtils
.
loadBlocklistRawData
(
{
extensionsMLBF
:
[
recordUpdate
]
}
)
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddonUpdate
)
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
"
Add
-
on
blocked
after
update
"
)
;
}
)
;
add_task
(
async
function
handle_database_corruption
(
)
{
const
blockedAddon
=
{
id
:
"
blocked
"
version
:
"
1
"
signedDate
:
new
Date
(
0
)
signedState
:
AddonManager
.
SIGNEDSTATE_SIGNED
}
;
async
function
checkBlocklistWorks
(
)
{
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
"
Add
-
on
should
be
blocked
by
the
blocklist
"
)
;
}
let
fetchCount
=
0
;
const
originalFetchMLBF
=
ExtensionBlocklistMLBF
.
_fetchMLBF
;
ExtensionBlocklistMLBF
.
_fetchMLBF
=
function
(
)
{
+
+
fetchCount
;
return
originalFetchMLBF
.
apply
(
this
arguments
)
;
}
;
await
AddonTestUtils
.
loadBlocklistRawData
(
{
extensionsMLBF
:
[
{
}
]
}
)
;
Assert
.
equal
(
fetchCount
1
"
MLBF
read
once
despite
bad
record
"
)
;
await
checkBlocklistWorks
(
)
;
Assert
.
equal
(
fetchCount
1
"
MLBF
not
read
again
by
blocklist
query
"
)
;
await
ExtensionBlocklistMLBF
.
_client
.
db
.
saveAttachment
(
ExtensionBlocklistMLBF
.
RS_ATTACHMENT_ID
null
)
;
Assert
.
equal
(
fetchCount
1
"
MLBF
not
read
again
after
attachment
deletion
"
)
;
await
checkBlocklistWorks
(
)
;
Assert
.
equal
(
fetchCount
1
"
MLBF
not
read
again
by
blocklist
query
2
"
)
;
await
ExtensionBlocklistMLBF
.
_onUpdate
(
)
;
Assert
.
equal
(
fetchCount
2
"
MLBF
read
again
at
forced
update
"
)
;
await
checkBlocklistWorks
(
)
;
Assert
.
equal
(
fetchCount
2
"
MLBF
not
read
again
by
blocklist
query
3
"
)
;
delete
ExtensionBlocklistMLBF
.
_mlbfData
;
delete
ExtensionBlocklistMLBF
.
_stashes
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
"
Blocklist
can
'
t
work
if
all
blocklist
data
is
gone
"
)
;
Assert
.
equal
(
fetchCount
3
"
MLBF
read
again
after
restart
/
cleared
cache
"
)
;
Assert
.
equal
(
await
Blocklist
.
getAddonBlocklistState
(
blockedAddon
)
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
"
Blocklist
can
still
not
work
if
all
blocklist
data
is
gone
"
)
;
Assert
.
equal
(
fetchCount
3
"
MLBF
not
read
again
despite
absence
of
MLBF
"
)
;
ExtensionBlocklistMLBF
.
_fetchMLBF
=
originalFetchMLBF
;
}
)
;
