gUseRealCertChecks
=
true
;
const
DATA
=
"
data
/
signing_checks
"
;
const
ID
=
"
test
somewhere
.
com
"
;
const
profileDir
=
gProfD
.
clone
(
)
;
profileDir
.
append
(
"
extensions
"
)
;
function
verifySignatures
(
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
Services
.
obs
.
removeObserver
(
observer
"
xpi
-
signature
-
changed
"
)
;
resolve
(
JSON
.
parse
(
data
)
)
;
}
;
Services
.
obs
.
addObserver
(
observer
"
xpi
-
signature
-
changed
"
)
;
info
(
"
Verifying
signatures
"
)
;
const
{
XPIExports
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIExports
.
sys
.
mjs
"
)
;
XPIExports
.
XPIDatabase
.
verifySignatures
(
)
;
}
)
;
}
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
4
"
"
4
"
)
;
add_setup
(
async
(
)
=
>
{
await
promiseStartupManager
(
)
;
}
)
;
add_task
(
function
test_hasStrongSignature_helper
(
)
{
const
{
hasStrongSignature
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
addons
/
crypto
-
utils
.
sys
.
mjs
"
)
;
const
{
PKCS7_WITH_SHA1
PKCS7_WITH_SHA256
COSE_WITH_SHA256
}
=
Ci
.
nsIAppSignatureInfo
;
const
testCases
=
[
[
false
"
SHA1
only
"
[
PKCS7_WITH_SHA1
]
]
[
true
"
SHA256
only
"
[
PKCS7_WITH_SHA256
]
]
[
true
"
COSE
only
"
[
COSE_WITH_SHA256
]
]
[
true
"
SHA1
and
SHA256
"
[
PKCS7_WITH_SHA1
PKCS7_WITH_SHA256
]
]
[
true
"
SHA1
and
COSE
"
[
PKCS7_WITH_SHA1
COSE_WITH_SHA256
]
]
[
true
"
SHA256
and
COSE
"
[
PKCS7_WITH_SHA256
COSE_WITH_SHA256
]
]
]
;
for
(
const
[
expect
msg
signedTypes
]
of
testCases
)
{
Assert
.
equal
(
hasStrongSignature
(
{
signedTypes
}
)
expect
msg
)
;
}
}
)
;
add_task
(
async
function
test_addon_signedTypes
(
)
{
const
resetWeakSignaturePref
=
AddonTestUtils
.
setWeakSignatureInstallAllowed
(
true
)
;
const
{
PKCS7_WITH_SHA1
COSE_WITH_SHA256
}
=
Ci
.
nsIAppSignatureInfo
;
const
{
addon
:
addonSignedCOSE
}
=
await
promiseInstallFile
(
do_get_file
(
"
amosigned
-
mv3
-
cose
.
xpi
"
)
)
;
const
{
addon
:
addonSignedSHA1
}
=
await
promiseInstallFile
(
do_get_file
(
"
amosigned
-
sha1only
.
xpi
"
)
)
;
Assert
.
deepEqual
(
addonSignedCOSE
.
signedTypes
.
sort
(
)
[
COSE_WITH_SHA256
PKCS7_WITH_SHA1
]
.
sort
(
)
Expect
{
addonSignedCOSE
.
id
}
to
be
signed
with
both
COSE
and
SHA1
)
;
Assert
.
deepEqual
(
addonSignedSHA1
.
signedTypes
[
PKCS7_WITH_SHA1
]
Expect
{
addonSignedSHA1
.
id
}
to
be
signed
with
SHA1
only
)
;
await
addonSignedSHA1
.
uninstall
(
)
;
await
addonSignedCOSE
.
uninstall
(
)
;
resetWeakSignaturePref
(
)
;
}
)
;
add_task
(
async
function
test_install_error_on_new_install_with_weak_signature
(
)
{
const
resetWeakSignaturePref
=
AddonTestUtils
.
setWeakSignatureInstallAllowed
(
false
)
;
const
{
messages
}
=
await
AddonTestUtils
.
promiseConsoleOutput
(
async
(
)
=
>
{
let
install
=
await
AddonManager
.
getInstallForFile
(
do_get_file
(
"
amosigned
-
sha1only
.
xpi
"
)
)
;
await
Assert
.
equal
(
install
.
state
AddonManager
.
STATE_DOWNLOAD_FAILED
"
Expect
install
state
to
be
STATE_DOWNLOAD_FAILED
"
)
;
await
Assert
.
rejects
(
install
.
install
(
)
/
Install
failed
:
onDownloadFailed
/
"
Expected
install
to
fail
"
)
;
}
)
;
resetWeakSignaturePref
(
)
;
AddonTestUtils
.
checkMessages
(
messages
{
expected
:
[
{
message
:
/
Invalid
XPI
:
install
rejected
due
to
the
package
not
including
a
strong
cryptographic
signature
/
}
]
}
)
;
}
)
;
add_task
(
async
function
test_weak_install_over_weak_existing
(
)
{
let
resetWeakSignaturePref
=
AddonTestUtils
.
setWeakSignatureInstallAllowed
(
true
)
;
const
{
addon
:
addonFirstInstall
}
=
await
promiseInstallFile
(
do_get_file
(
"
amosigned
-
sha1only
.
xpi
"
)
)
;
const
addonId
=
addonFirstInstall
.
id
;
resetWeakSignaturePref
(
)
;
resetWeakSignaturePref
=
AddonTestUtils
.
setWeakSignatureInstallAllowed
(
false
)
;
info
(
"
Install
over
the
existing
installed
addon
"
)
;
let
addonInstalledOver
;
const
{
messages
}
=
await
AddonTestUtils
.
promiseConsoleOutput
(
async
(
)
=
>
{
const
fileURL
=
Services
.
io
.
newFileURI
(
do_get_file
(
"
amosigned
-
sha1only
.
xpi
"
)
)
.
spec
;
let
install
=
await
AddonManager
.
getInstallForURL
(
fileURL
{
existingAddon
:
addonFirstInstall
version
:
"
2
.
1
"
}
)
;
addonInstalledOver
=
await
install
.
install
(
)
;
}
)
;
resetWeakSignaturePref
(
)
;
Assert
.
equal
(
addonInstalledOver
.
id
addonFirstInstall
.
id
"
Expect
addon
id
to
be
the
same
"
)
;
await
addonInstalledOver
.
uninstall
(
)
;
Assert
.
equal
(
await
AddonManager
.
getAddonByID
(
addonId
)
undefined
"
Expect
the
test
addon
to
be
fully
uninstalled
"
)
;
AddonTestUtils
.
checkMessages
(
messages
{
expected
:
[
{
message
:
new
RegExp
(
Allow
weak
signature
install
over
existing
"
{
addonId
}
"
XPI
)
}
]
}
)
;
}
)
;
add_task
(
async
function
test_signedTypes_stored_in_addonDB
(
)
{
const
{
addon
:
addonAfterInstalled
}
=
await
promiseInstallFile
(
do_get_file
(
"
amosigned
-
mv3
-
cose
.
xpi
"
)
)
;
const
addonId
=
addonAfterInstalled
.
id
;
const
{
PKCS7_WITH_SHA1
COSE_WITH_SHA256
}
=
Ci
.
nsIAppSignatureInfo
;
const
expectedSignedTypes
=
[
COSE_WITH_SHA256
PKCS7_WITH_SHA1
]
.
sort
(
)
;
Assert
.
deepEqual
(
addonAfterInstalled
.
signedTypes
.
sort
(
)
expectedSignedTypes
Got
expected
{
addonId
}
signedTyped
after
install
)
;
await
promiseRestartManager
(
)
;
const
addonAfterAOMRestart
=
await
AddonManager
.
getAddonByID
(
addonId
)
;
Assert
.
deepEqual
(
addonAfterAOMRestart
.
signedTypes
.
sort
(
)
expectedSignedTypes
Got
expected
{
addonId
}
signedTyped
after
AOM
restart
)
;
const
removeSignedStateFromAddonDB
=
async
(
)
=
>
{
const
addon_db_file
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
addon_db_file
.
append
(
"
extensions
.
json
"
)
;
const
addon_db_data
=
await
IOUtils
.
readJSON
(
addon_db_file
.
path
)
;
const
addon_db_data_tampered
=
{
.
.
.
addon_db_data
addons
:
addon_db_data
.
addons
.
map
(
addonData
=
>
{
delete
addonData
.
signedTypes
;
return
addonData
;
}
)
}
;
await
IOUtils
.
writeJSON
(
addon_db_file
.
path
addon_db_data_tampered
)
;
}
;
info
(
"
Check
that
XPIProvider
.
checkForChanges
(
true
)
will
recompute
missing
signedTypes
properties
"
)
;
await
promiseShutdownManager
(
)
;
await
removeSignedStateFromAddonDB
(
)
;
await
promiseStartupManager
(
)
;
const
addonAfterAppUpgrade
=
await
AddonManager
.
getAddonByID
(
addonId
)
;
Assert
.
deepEqual
(
addonAfterAppUpgrade
.
signedTypes
undefined
Got
empty
{
addonId
}
signedTyped
set
to
undefied
after
AddonDB
data
tampered
)
;
AddonTestUtils
.
getXPIExports
(
)
.
XPIProvider
.
checkForChanges
(
true
)
;
Assert
.
deepEqual
(
addonAfterAppUpgrade
.
signedTypes
?
.
sort
(
)
expectedSignedTypes
.
sort
(
)
Got
expected
{
addonId
}
signedTyped
after
XPIProvider
.
checkForChanges
recomputed
it
)
;
info
(
"
Check
that
XPIDatabase
.
updateCompatibility
will
recompute
missing
signedTypes
properties
"
)
;
await
promiseShutdownManager
(
)
;
await
removeSignedStateFromAddonDB
(
)
;
await
promiseStartupManager
(
)
;
const
addonAfterUpdateCompatibility
=
await
AddonManager
.
getAddonByID
(
addonId
)
;
Assert
.
deepEqual
(
addonAfterUpdateCompatibility
.
signedTypes
undefined
Got
empty
{
addonId
}
signedTyped
set
to
undefied
after
AddonDB
data
tampered
)
;
AddonTestUtils
.
getXPIExports
(
)
.
XPIDatabaseReconcile
.
processFileChanges
(
{
}
true
)
;
Assert
.
deepEqual
(
addonAfterUpdateCompatibility
.
signedTypes
?
.
sort
(
)
expectedSignedTypes
.
sort
(
)
Got
expected
{
addonId
}
signedTyped
after
XPIDatabase
.
updateCompatibility
recomputed
it
)
;
info
(
"
Check
that
XPIDatabase
.
updateCompatibility
will
recompute
missing
signedTypes
properties
"
)
;
await
promiseRestartManager
(
)
;
let
listener
=
{
onPropertyChanged
(
_addon
properties
)
{
Assert
.
deepEqual
(
properties
[
]
No
properties
should
have
been
changed
for
{
_addon
.
id
}
)
;
Assert
.
ok
(
false
onPropertyChanged
should
have
not
been
called
for
{
_addon
.
id
}
)
;
}
}
;
AddonManager
.
addAddonListener
(
listener
)
;
await
verifySignatures
(
)
;
AddonManager
.
removeAddonListener
(
listener
)
;
info
(
"
Check
that
XPIDatabase
.
verifySignatures
does
not
fail
when
signedTypes
is
undefined
"
)
;
await
promiseShutdownManager
(
)
;
await
removeSignedStateFromAddonDB
(
)
;
await
promiseStartupManager
(
)
;
const
addonUndefinedSignedTypes
=
await
AddonManager
.
getAddonByID
(
addonId
)
;
Assert
.
deepEqual
(
addonUndefinedSignedTypes
.
signedTypes
undefined
Got
empty
{
addonId
}
signedTyped
set
to
undefied
after
AddonDB
data
tampered
)
;
await
verifySignatures
(
)
;
Assert
.
deepEqual
(
addonUndefinedSignedTypes
.
signedTypes
?
.
sort
(
)
expectedSignedTypes
.
sort
(
)
Got
expected
{
addonId
}
signedTyped
after
XPIDatabase
.
verifySignatures
recomputed
it
)
;
await
addonUndefinedSignedTypes
.
uninstall
(
)
;
}
)
;
add_task
(
{
pref_set
:
[
[
"
xpinstall
.
signatures
.
required
"
false
]
]
skip_if
:
(
)
=
>
AppConstants
.
MOZ_REQUIRE_SIGNING
}
async
function
test_weak_signature_not_restricted_on_disabled_signature_checks
(
)
{
let
resetWeakSignaturePref
=
AddonTestUtils
.
setWeakSignatureInstallAllowed
(
false
)
;
const
{
addon
}
=
await
promiseInstallFile
(
do_get_file
(
"
amosigned
-
sha1only
.
xpi
"
)
)
;
Assert
.
notEqual
(
addon
null
"
Expect
addon
to
be
installed
"
)
;
resetWeakSignaturePref
(
)
;
await
addon
.
uninstall
(
)
;
}
)
;
add_task
(
async
function
test_no_change
(
)
{
await
promiseInstallFile
(
do_get_file
(
{
DATA
}
/
signed1
.
xpi
)
)
;
let
addon
=
await
promiseAddonByID
(
ID
)
;
Assert
.
notEqual
(
addon
null
)
;
Assert
.
equal
(
addon
.
appDisabled
false
)
;
Assert
.
equal
(
addon
.
isActive
true
)
;
Assert
.
equal
(
addon
.
pendingOperations
AddonManager
.
PENDING_NONE
)
;
Assert
.
equal
(
addon
.
signedState
AddonManager
.
SIGNEDSTATE_SIGNED
)
;
manuallyUninstall
(
profileDir
ID
)
;
await
manuallyInstall
(
do_get_file
(
{
DATA
}
/
signed2
.
xpi
)
profileDir
ID
)
;
let
listener
=
{
onPropertyChanged
(
_addon
)
{
Assert
.
ok
(
false
Got
unexpected
onPropertyChanged
for
{
_addon
.
id
}
)
;
}
}
;
AddonManager
.
addAddonListener
(
listener
)
;
let
changes
=
await
verifySignatures
(
)
;
Assert
.
equal
(
changes
.
enabled
.
length
0
)
;
Assert
.
equal
(
changes
.
disabled
.
length
0
)
;
Assert
.
equal
(
addon
.
appDisabled
false
)
;
Assert
.
equal
(
addon
.
isActive
true
)
;
Assert
.
equal
(
addon
.
signedState
AddonManager
.
SIGNEDSTATE_SIGNED
)
;
await
addon
.
uninstall
(
)
;
AddonManager
.
removeAddonListener
(
listener
)
;
}
)
;
add_task
(
async
function
test_disable
(
)
{
await
promiseInstallFile
(
do_get_file
(
{
DATA
}
/
signed1
.
xpi
)
)
;
let
addon
=
await
promiseAddonByID
(
ID
)
;
Assert
.
notEqual
(
addon
null
)
;
Assert
.
ok
(
addon
.
isActive
)
;
Assert
.
equal
(
addon
.
signedState
AddonManager
.
SIGNEDSTATE_SIGNED
)
;
manuallyUninstall
(
profileDir
ID
)
;
await
manuallyInstall
(
do_get_file
(
{
DATA
}
/
unsigned
.
xpi
)
profileDir
ID
)
;
let
changedProperties
=
[
]
;
let
listener
=
{
onPropertyChanged
(
_
properties
)
{
changedProperties
.
push
(
.
.
.
properties
)
;
}
}
;
AddonManager
.
addAddonListener
(
listener
)
;
let
[
changes
]
=
await
Promise
.
all
(
[
verifySignatures
(
)
promiseAddonEvent
(
"
onDisabling
"
)
]
)
;
Assert
.
equal
(
changes
.
enabled
.
length
0
)
;
Assert
.
equal
(
changes
.
disabled
.
length
1
)
;
Assert
.
equal
(
changes
.
disabled
[
0
]
ID
)
;
Assert
.
deepEqual
(
changedProperties
[
"
signedState
"
"
signedTypes
"
"
appDisabled
"
]
"
Got
onPropertyChanged
events
for
signedState
and
appDisabled
"
)
;
Assert
.
ok
(
addon
.
appDisabled
)
;
Assert
.
ok
(
!
addon
.
isActive
)
;
Assert
.
equal
(
addon
.
signedState
AddonManager
.
SIGNEDSTATE_MISSING
)
;
await
addon
.
uninstall
(
)
;
AddonManager
.
removeAddonListener
(
listener
)
;
}
)
;
