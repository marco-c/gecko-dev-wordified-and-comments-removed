"
use
strict
"
;
gUseRealCertChecks
=
true
;
ExtensionTestUtils
.
mockAppInfo
(
)
;
const
XPI_SIGNATURE_CHECK_PERIOD
=
24
*
60
*
60
;
const
PREF_LAST_TIME
=
"
app
.
update
.
lastUpdateTime
.
xpi
-
signature
-
verification
"
;
const
PREF_LAST_SIGNATURE_CHECKPOINT
=
"
extensions
.
signatureCheckpoint
"
;
const
CLOCK_SKEW
=
2
;
function
nowSecs
(
)
{
return
Math
.
floor
(
Date
.
now
(
)
/
1000
)
;
}
const
gUTM
=
Cc
[
"
mozilla
.
org
/
updates
/
timer
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateTimerManager
)
;
function
skewTimestampForVisibilityInTest
(
)
{
let
time
=
Services
.
prefs
.
getIntPref
(
PREF_LAST_TIME
)
;
time
-
=
1
;
Services
.
prefs
.
setIntPref
(
PREF_LAST_TIME
time
)
;
return
time
;
}
add_setup
(
async
(
)
=
>
{
Services
.
prefs
.
setBoolPref
(
"
app
.
update
.
log
"
true
)
;
for
(
const
{
value
}
of
Services
.
catMan
.
enumerateCategory
(
"
update
-
timer
"
)
)
{
const
timerID
=
value
.
split
(
"
"
)
[
2
]
;
Services
.
prefs
.
setIntPref
(
app
.
update
.
lastUpdateTime
.
{
timerID
}
nowSecs
(
)
-
CLOCK_SKEW
)
;
}
Services
.
prefs
.
setIntPref
(
"
app
.
update
.
timerMinimumDelay
"
1
)
;
Services
.
prefs
.
setIntPref
(
"
app
.
update
.
timerFirstInterval
"
1000
)
;
gUTM
.
registerTimer
(
"
test
-
dummy
-
ensure
-
quick
-
progress
"
(
)
=
>
{
}
1
)
;
AddonTestUtils
.
on
(
"
addon
-
manager
-
shutdown
"
(
)
=
>
{
gUTM
.
unregisterTimer
(
"
xpi
-
signature
-
verification
"
)
;
}
)
;
gUTM
.
QueryInterface
(
Ci
.
nsIObserver
)
.
observe
(
null
"
utm
-
test
-
init
"
"
"
)
;
}
)
;
add_task
(
useAMOStageCert
(
)
async
function
test_scheduled_signature_checks
(
)
{
const
FIRST_RUN_VERIFICATION_TIME
=
nowSecs
(
)
-
CLOCK_SKEW
;
Services
.
prefs
.
setIntPref
(
PREF_LAST_TIME
FIRST_RUN_VERIFICATION_TIME
)
;
info
(
"
Simulating
first
run
with
new
profile
"
)
;
Assert
.
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
PREF_LAST_SIGNATURE_CHECKPOINT
)
"
Checkpoint
not
set
before
first
run
"
)
;
await
promiseStartupManager
(
)
;
Assert
.
ok
(
Services
.
prefs
.
prefHasUserValue
(
PREF_LAST_SIGNATURE_CHECKPOINT
)
"
Checkpoint
set
after
first
run
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getIntPref
(
PREF_LAST_TIME
)
FIRST_RUN_VERIFICATION_TIME
"
On
startup
of
new
profile
checkpoint
is
set
without
forced
verification
"
)
;
await
promiseInstallFile
(
do_get_file
(
"
data
/
signing_checks
/
signed1
.
xpi
"
)
)
;
async
function
getSignedState
(
)
{
let
addon
=
await
promiseAddonByID
(
"
test
somewhere
.
com
"
)
;
return
addon
.
signedState
;
}
Assert
.
equal
(
await
getSignedState
(
)
AddonManager
.
SIGNEDSTATE_SIGNED
"
Signature
correct
after
install
"
)
;
await
promiseRestartManager
(
)
;
Assert
.
equal
(
Services
.
prefs
.
getIntPref
(
PREF_LAST_TIME
)
FIRST_RUN_VERIFICATION_TIME
"
Signature
verification
not
scheduled
yet
"
)
;
info
(
"
Simulating
that
the
add
-
on
should
be
considered
signed
incorrectly
"
)
;
Services
.
prefs
.
setBoolPref
(
"
xpinstall
.
signatures
.
dev
-
root
"
false
)
;
await
promiseRestartManager
(
)
;
Assert
.
equal
(
Services
.
prefs
.
getIntPref
(
PREF_LAST_TIME
)
FIRST_RUN_VERIFICATION_TIME
"
Signature
verification
not
scheduled
yet
"
)
;
Assert
.
equal
(
await
getSignedState
(
)
AddonManager
.
SIGNEDSTATE_SIGNED
"
Signature
still
correct
despite
different
root
(
not
verified
yet
)
"
)
;
await
promiseShutdownManager
(
)
;
info
(
"
Simulating
that
update
check
has
happened
too
long
ago
"
)
;
const
TOO_LONG_AGO_TIME
=
nowSecs
(
)
-
XPI_SIGNATURE_CHECK_PERIOD
-
CLOCK_SKEW
;
Services
.
prefs
.
setIntPref
(
PREF_LAST_TIME
TOO_LONG_AGO_TIME
)
;
let
verifiedPromise
=
TestUtils
.
topicObserved
(
"
xpi
-
signature
-
changed
"
)
;
await
promiseStartupManager
(
)
;
Assert
.
notEqual
(
Services
.
prefs
.
getIntPref
(
PREF_LAST_TIME
)
FIRST_RUN_VERIFICATION_TIME
"
Signature
verification
happens
when
the
last
check
was
too
long
ago
"
)
;
await
verifiedPromise
;
Assert
.
equal
(
await
getSignedState
(
)
AddonManager
.
SIGNEDSTATE_UNKNOWN
"
Detected
signature
invalidation
(
due
to
bad
root
)
after
verification
"
)
;
const
LAST_TIMER_TRIGGERED_TIME
=
skewTimestampForVisibilityInTest
(
)
;
info
(
"
Simulating
that
the
add
-
on
should
be
considered
signed
correctly
"
)
;
Services
.
prefs
.
setBoolPref
(
"
xpinstall
.
signatures
.
dev
-
root
"
true
)
;
await
promiseRestartManager
(
)
;
Assert
.
equal
(
Services
.
prefs
.
getIntPref
(
PREF_LAST_TIME
)
LAST_TIMER_TRIGGERED_TIME
"
Signature
verification
skipped
because
it
happened
recently
"
)
;
Assert
.
equal
(
await
getSignedState
(
)
AddonManager
.
SIGNEDSTATE_UNKNOWN
"
Signature
out
of
date
because
verification
was
skipped
"
)
;
await
promiseShutdownManager
(
)
;
info
(
"
Simulating
browser
update
with
forced
signature
change
"
)
;
Services
.
prefs
.
clearUserPref
(
PREF_LAST_SIGNATURE_CHECKPOINT
)
;
let
verifiedPromise2
=
TestUtils
.
topicObserved
(
"
xpi
-
signature
-
changed
"
)
;
await
promiseStartupManager
(
)
;
Assert
.
notEqual
(
Services
.
prefs
.
getIntPref
(
PREF_LAST_TIME
)
LAST_TIMER_TRIGGERED_TIME
"
Signature
verification
timer
should
be
reset
when
verification
is
forced
"
)
;
await
verifiedPromise2
;
Assert
.
equal
(
await
getSignedState
(
)
AddonManager
.
SIGNEDSTATE_SIGNED
"
Signature
is
up
to
date
again
after
forced
verification
on
startup
"
)
;
await
promiseShutdownManager
(
)
;
}
)
;
