"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Blocklist
"
"
BlocklistPrivate
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
AddonManagerPrivate
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
RemoteSettings
"
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
jexlFilterFunc
"
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
const
CascadeFilter
=
Components
.
Constructor
(
"
mozilla
.
org
/
cascade
-
filter
;
1
"
"
nsICascadeFilter
"
"
setFilterData
"
)
;
const
kIdSubRegex
=
"
\
\
(
[
"
+
"
\
\
\
\
"
+
"
\
\
w
.
{
}
-
]
+
\
\
)
"
;
const
kIsMultipleIds
=
new
RegExp
(
"
^
/
\
\
^
\
\
(
?
"
+
kIdSubRegex
+
"
(
?
:
\
\
|
"
+
kIdSubRegex
+
"
)
*
"
+
"
\
\
)
?
\
\
/
"
)
;
const
kEscapeSequences
=
/
\
\
[
^
.
{
}
]
/
;
const
kRegExpRemovalRegExp
=
/
^
\
/
\
^
\
(
\
(
?
|
\
\
|
\
)
\
)
?
\
\
/
/
g
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
kXPIAddonTypes
"
(
)
=
>
{
return
lazy
.
AddonManagerPrivate
.
getAddonTypesByProvider
(
"
XPIProvider
"
)
;
}
)
;
function
processMatcher
(
str
)
{
if
(
!
str
.
startsWith
(
"
/
"
)
)
{
return
str
;
}
if
(
kIsMultipleIds
.
test
(
str
)
&
&
!
kEscapeSequences
.
test
(
str
)
)
{
return
new
Set
(
str
.
replace
(
kRegExpRemovalRegExp
"
"
)
.
split
(
"
)
|
(
"
)
)
;
}
let
lastSlash
=
str
.
lastIndexOf
(
"
/
"
)
;
let
pattern
=
str
.
slice
(
1
lastSlash
)
;
let
flags
=
str
.
slice
(
lastSlash
+
1
)
;
return
new
RegExp
(
pattern
flags
)
;
}
function
doesAddonEntryMatch
(
matches
addonProps
)
{
for
(
let
[
key
value
]
of
Object
.
entries
(
matches
)
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
continue
;
}
if
(
addonProps
[
key
]
)
{
if
(
value
.
has
&
&
value
.
has
(
addonProps
[
key
]
)
)
{
continue
;
}
if
(
value
.
test
&
&
value
.
test
(
addonProps
[
key
]
)
)
{
continue
;
}
if
(
typeof
value
=
=
"
string
"
&
&
value
=
=
=
addonProps
[
key
]
)
{
continue
;
}
}
return
false
;
}
return
true
;
}
const
TOOLKIT_ID
=
"
toolkit
mozilla
.
org
"
;
const
PREF_BLOCKLIST_ITEM_URL
=
"
extensions
.
blocklist
.
itemURL
"
;
const
PREF_BLOCKLIST_ADDONITEM_URL
=
"
extensions
.
blocklist
.
addonItemURL
"
;
const
PREF_BLOCKLIST_ENABLED
=
"
extensions
.
blocklist
.
enabled
"
;
const
PREF_BLOCKLIST_LEVEL
=
"
extensions
.
blocklist
.
level
"
;
const
PREF_BLOCKLIST_USE_MLBF
=
"
extensions
.
blocklist
.
useMLBF
"
;
const
PREF_EM_LOGGING_ENABLED
=
"
extensions
.
logging
.
enabled
"
;
const
DEFAULT_SEVERITY
=
3
;
const
DEFAULT_LEVEL
=
2
;
const
MAX_BLOCK_LEVEL
=
3
;
const
BLOCKLIST_BUCKET
=
"
blocklists
"
;
const
BlocklistTelemetry
=
{
init
(
)
{
Services
.
telemetry
.
setEventRecordingEnabled
(
"
blocklist
"
true
)
;
}
async
recordRSBlocklistLastModified
(
blocklistType
remoteSettingsClient
)
{
if
(
!
remoteSettingsClient
)
{
return
;
}
let
lastModified
=
await
remoteSettingsClient
.
getLastModified
(
)
;
BlocklistTelemetry
.
recordTimeScalar
(
"
lastModified_rs_
"
+
blocklistType
lastModified
)
;
}
recordTimeScalar
(
telemetryKey
time
)
{
if
(
time
>
0
)
{
let
dateString
=
new
Date
(
time
)
.
toUTCString
(
)
;
Services
.
telemetry
.
scalarSet
(
"
blocklist
.
"
+
telemetryKey
dateString
)
;
}
else
{
Services
.
telemetry
.
scalarSet
(
"
blocklist
.
"
+
telemetryKey
"
Missing
Date
"
)
;
}
}
recordAddonBlockChangeTelemetry
(
addon
reason
)
{
let
hoursSinceInstall
=
-
1
;
if
(
reason
=
=
=
"
blocklist_update
"
|
|
reason
=
=
=
"
addon_db_modified
"
)
{
hoursSinceInstall
=
Math
.
round
(
(
Date
.
now
(
)
-
addon
.
installDate
.
getTime
(
)
)
/
3600000
)
;
}
const
value
=
addon
.
id
;
const
extra
=
{
blocklistState
:
{
addon
.
blocklistState
}
addon_version
:
addon
.
version
signed_date
:
{
addon
.
signedDate
?
.
getTime
(
)
|
|
0
}
hours_since
:
{
hoursSinceInstall
}
.
.
.
ExtensionBlocklistMLBF
.
getBlocklistMetadataForTelemetry
(
)
}
;
Services
.
telemetry
.
recordEvent
(
"
blocklist
"
"
addonBlockChange
"
reason
value
extra
)
;
}
}
;
const
Utils
=
{
matchesOSABI
(
item
)
{
if
(
item
.
os
)
{
let
os
=
item
.
os
.
split
(
"
"
)
;
if
(
!
os
.
includes
(
lazy
.
gAppOS
)
)
{
return
false
;
}
}
if
(
item
.
xpcomabi
)
{
let
xpcomabi
=
item
.
xpcomabi
.
split
(
"
"
)
;
if
(
!
xpcomabi
.
includes
(
lazy
.
gApp
.
XPCOMABI
)
)
{
return
false
;
}
}
return
true
;
}
versionInRange
(
version
minVersion
maxVersion
)
{
if
(
minVersion
&
&
Services
.
vc
.
compare
(
version
minVersion
)
<
0
)
{
return
false
;
}
if
(
maxVersion
&
&
Services
.
vc
.
compare
(
version
maxVersion
)
>
0
)
{
return
false
;
}
return
true
;
}
versionsMatch
(
versionRange
itemVersion
appVersion
toolkitVersion
)
{
if
(
!
itemVersion
&
&
(
versionRange
.
minVersion
|
|
versionRange
.
maxVersion
)
)
{
return
false
;
}
if
(
!
this
.
versionInRange
(
itemVersion
versionRange
.
minVersion
versionRange
.
maxVersion
)
)
{
return
false
;
}
for
(
let
tA
of
versionRange
.
targetApplication
)
{
if
(
tA
.
guid
=
=
lazy
.
gAppID
&
&
this
.
versionInRange
(
appVersion
tA
.
minVersion
tA
.
maxVersion
)
)
{
return
true
;
}
if
(
tA
.
guid
=
=
TOOLKIT_ID
&
&
this
.
versionInRange
(
toolkitVersion
tA
.
minVersion
tA
.
maxVersion
)
)
{
return
true
;
}
}
return
false
;
}
ensureVersionRangeIsSane
(
entry
)
{
if
(
!
entry
.
versionRange
.
length
)
{
entry
.
versionRange
.
push
(
{
}
)
;
}
for
(
let
vr
of
entry
.
versionRange
)
{
if
(
!
vr
.
hasOwnProperty
(
"
severity
"
)
)
{
vr
.
severity
=
DEFAULT_SEVERITY
;
}
if
(
!
Array
.
isArray
(
vr
.
targetApplication
)
)
{
vr
.
targetApplication
=
[
]
;
}
if
(
!
vr
.
targetApplication
.
length
)
{
vr
.
targetApplication
.
push
(
{
minVersion
:
null
maxVersion
:
null
}
)
;
}
vr
.
targetApplication
.
forEach
(
tA
=
>
{
if
(
!
tA
.
guid
)
{
tA
.
guid
=
lazy
.
gAppID
;
}
}
)
;
}
}
_createBlocklistURL
(
id
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_BLOCKLIST_ITEM_URL
)
;
return
url
.
replace
(
/
%
blockID
%
/
g
id
)
;
}
}
;
async
function
targetAppFilter
(
entry
environment
)
{
const
{
filter_expression
}
=
entry
;
if
(
filter_expression
)
{
return
lazy
.
jexlFilterFunc
(
entry
environment
)
;
}
if
(
!
(
"
versionRange
"
in
entry
)
)
{
return
entry
;
}
const
{
versionRange
}
=
entry
;
if
(
!
Array
.
isArray
(
versionRange
)
)
{
const
{
maxVersion
=
"
*
"
}
=
versionRange
;
const
matchesRange
=
Services
.
vc
.
compare
(
lazy
.
gApp
.
version
maxVersion
)
<
=
0
;
return
matchesRange
?
entry
:
null
;
}
if
(
!
versionRange
.
length
)
{
return
entry
;
}
for
(
const
vr
of
versionRange
)
{
const
{
targetApplication
=
[
]
}
=
vr
;
if
(
!
targetApplication
.
length
)
{
return
entry
;
}
for
(
const
ta
of
targetApplication
)
{
const
{
guid
}
=
ta
;
if
(
!
guid
)
{
return
entry
;
}
const
{
maxVersion
=
"
*
"
}
=
ta
;
if
(
guid
=
=
lazy
.
gAppID
&
&
Services
.
vc
.
compare
(
lazy
.
gApp
.
version
maxVersion
)
<
=
0
)
{
return
entry
;
}
if
(
guid
=
=
"
toolkit
mozilla
.
org
"
&
&
Services
.
vc
.
compare
(
Services
.
appinfo
.
platformVersion
maxVersion
)
<
=
0
)
{
return
entry
;
}
}
}
return
null
;
}
const
GfxBlocklistRS
=
{
_ensureInitialized
(
)
{
if
(
this
.
_initialized
|
|
!
gBlocklistEnabled
)
{
return
;
}
this
.
_initialized
=
true
;
this
.
_client
=
lazy
.
RemoteSettings
(
"
gfx
"
{
bucketName
:
BLOCKLIST_BUCKET
filterFunc
:
targetAppFilter
}
)
;
this
.
checkForEntries
=
this
.
checkForEntries
.
bind
(
this
)
;
this
.
_client
.
on
(
"
sync
"
this
.
checkForEntries
)
;
}
shutdown
(
)
{
if
(
this
.
_client
)
{
this
.
_client
.
off
(
"
sync
"
this
.
checkForEntries
)
;
}
}
sync
(
)
{
this
.
_ensureInitialized
(
)
;
return
this
.
_client
.
sync
(
)
;
}
async
checkForEntries
(
)
{
this
.
_ensureInitialized
(
)
;
if
(
!
gBlocklistEnabled
)
{
return
[
]
;
}
let
entries
=
await
this
.
_client
.
get
(
)
.
catch
(
ex
=
>
Cu
.
reportError
(
ex
)
)
;
if
(
!
entries
)
{
return
[
]
;
}
const
trim
=
s
=
>
(
s
|
|
"
"
)
.
replace
(
/
(
^
[
\
s
\
uFEFF
\
xA0
]
+
)
|
(
[
\
s
\
uFEFF
\
xA0
]
+
)
/
g
"
"
)
;
entries
=
entries
.
map
(
entry
=
>
{
let
props
=
[
"
blockID
"
"
driverVersion
"
"
driverVersionMax
"
"
driverVersionComparator
"
"
feature
"
"
featureStatus
"
"
os
"
"
vendor
"
"
devices
"
]
;
let
rv
=
{
}
;
for
(
let
p
of
props
)
{
let
val
=
entry
[
p
]
;
if
(
!
val
|
|
(
Array
.
isArray
(
val
)
&
&
!
val
.
length
)
)
{
continue
;
}
if
(
typeof
val
=
=
"
string
"
)
{
val
=
trim
(
val
)
;
}
else
if
(
p
=
=
"
devices
"
)
{
let
invalidDevices
=
[
]
;
let
validDevices
=
[
]
;
val
.
forEach
(
v
=
>
v
.
includes
(
"
"
)
?
invalidDevices
.
push
(
v
)
:
validDevices
.
push
(
v
)
)
;
for
(
let
dev
of
invalidDevices
)
{
const
e
=
new
Error
(
Block
{
entry
.
blockID
}
contains
unsupported
device
:
{
dev
}
)
;
Cu
.
reportError
(
e
)
;
}
if
(
!
validDevices
)
{
continue
;
}
val
=
validDevices
;
}
rv
[
p
]
=
val
;
}
if
(
entry
.
versionRange
)
{
rv
.
versionRange
=
{
minVersion
:
trim
(
entry
.
versionRange
.
minVersion
)
|
|
"
0
"
maxVersion
:
trim
(
entry
.
versionRange
.
maxVersion
)
|
|
"
*
"
}
;
}
return
rv
;
}
)
;
if
(
entries
.
length
)
{
let
sortedProps
=
[
"
blockID
"
"
devices
"
"
driverVersion
"
"
driverVersionComparator
"
"
driverVersionMax
"
"
feature
"
"
featureStatus
"
"
hardware
"
"
manufacturer
"
"
model
"
"
os
"
"
osversion
"
"
product
"
"
vendor
"
"
versionRange
"
]
;
let
payload
=
[
]
;
for
(
let
gfxEntry
of
entries
)
{
let
entryLines
=
[
]
;
for
(
let
key
of
sortedProps
)
{
if
(
gfxEntry
[
key
]
)
{
let
value
=
gfxEntry
[
key
]
;
if
(
Array
.
isArray
(
value
)
)
{
value
=
value
.
join
(
"
"
)
;
}
else
if
(
value
.
maxVersion
)
{
value
=
value
.
minVersion
+
"
"
+
value
.
maxVersion
;
}
entryLines
.
push
(
key
+
"
:
"
+
value
)
;
}
}
payload
.
push
(
entryLines
.
join
(
"
\
t
"
)
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
blocklist
-
data
-
gfxItems
"
payload
.
join
(
"
\
n
"
)
)
;
}
return
entries
;
}
}
;
const
ExtensionBlocklistRS
=
{
async
_ensureEntries
(
)
{
this
.
ensureInitialized
(
)
;
if
(
!
this
.
_entries
&
&
gBlocklistEnabled
)
{
await
this
.
_updateEntries
(
)
;
}
}
async
_updateEntries
(
)
{
if
(
!
gBlocklistEnabled
)
{
this
.
_entries
=
[
]
;
return
;
}
this
.
_entries
=
await
this
.
_client
.
get
(
)
.
catch
(
ex
=
>
Cu
.
reportError
(
ex
)
)
;
if
(
!
this
.
_entries
)
{
this
.
_entries
=
[
]
;
return
;
}
this
.
_entries
.
forEach
(
entry
=
>
{
entry
.
matches
=
{
}
;
if
(
entry
.
guid
)
{
entry
.
matches
.
id
=
processMatcher
(
entry
.
guid
)
;
}
for
(
let
key
of
EXTENSION_BLOCK_FILTERS
)
{
if
(
key
=
=
"
id
"
|
|
!
entry
[
key
]
)
{
continue
;
}
entry
.
matches
[
key
]
=
processMatcher
(
entry
[
key
]
)
;
}
Utils
.
ensureVersionRangeIsSane
(
entry
)
;
}
)
;
BlocklistTelemetry
.
recordRSBlocklistLastModified
(
"
addons
"
this
.
_client
)
;
}
async
_filterItem
(
entry
environment
)
{
if
(
!
(
await
targetAppFilter
(
entry
environment
)
)
)
{
return
null
;
}
if
(
!
Utils
.
matchesOSABI
(
entry
)
)
{
return
null
;
}
if
(
!
entry
.
guid
&
&
!
entry
.
name
)
{
let
blockID
=
entry
.
blockID
|
|
entry
.
id
;
Cu
.
reportError
(
new
Error
(
Nothing
to
filter
add
-
on
item
{
blockID
}
on
)
)
;
return
null
;
}
return
entry
;
}
sync
(
)
{
this
.
ensureInitialized
(
)
;
return
this
.
_client
.
sync
(
)
;
}
ensureInitialized
(
)
{
if
(
!
gBlocklistEnabled
|
|
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
this
.
_client
=
lazy
.
RemoteSettings
(
"
addons
"
{
bucketName
:
BLOCKLIST_BUCKET
filterFunc
:
this
.
_filterItem
}
)
;
this
.
_onUpdate
=
this
.
_onUpdate
.
bind
(
this
)
;
this
.
_client
.
on
(
"
sync
"
this
.
_onUpdate
)
;
}
shutdown
(
)
{
if
(
this
.
_client
)
{
this
.
_client
.
off
(
"
sync
"
this
.
_onUpdate
)
;
this
.
_didShutdown
=
true
;
}
}
undoShutdown
(
)
{
if
(
this
.
_didShutdown
)
{
this
.
_client
.
on
(
"
sync
"
this
.
_onUpdate
)
;
this
.
_didShutdown
=
false
;
}
}
async
_onUpdate
(
)
{
let
oldEntries
=
this
.
_entries
|
|
[
]
;
await
this
.
ensureInitialized
(
)
;
await
this
.
_updateEntries
(
)
;
let
addons
=
await
lazy
.
AddonManager
.
getAddonsByTypes
(
lazy
.
kXPIAddonTypes
)
;
for
(
let
addon
of
addons
)
{
let
oldState
=
addon
.
blocklistState
;
if
(
addon
.
updateBlocklistState
)
{
await
addon
.
updateBlocklistState
(
false
)
;
}
else
if
(
oldEntries
)
{
let
oldEntry
=
this
.
_getEntry
(
addon
oldEntries
)
;
oldState
=
oldEntry
?
oldEntry
.
state
:
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
else
{
oldState
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
let
state
=
addon
.
blocklistState
;
LOG
(
"
Blocklist
state
for
"
+
addon
.
id
+
"
changed
from
"
+
oldState
+
"
to
"
+
state
)
;
if
(
state
=
=
oldState
)
{
continue
;
}
if
(
state
!
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
{
await
addon
.
setSoftDisabled
(
false
)
;
}
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
&
&
oldState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
await
addon
.
setSoftDisabled
(
true
)
;
}
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
|
|
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
{
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
&
&
!
addon
.
userDisabled
)
{
await
addon
.
setSoftDisabled
(
true
)
;
}
let
entry
=
this
.
_getEntry
(
addon
this
.
_entries
)
;
if
(
entry
.
prefs
&
&
entry
.
prefs
.
length
)
{
for
(
let
pref
of
entry
.
prefs
)
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
}
}
}
lazy
.
AddonManagerPrivate
.
updateAddonAppDisabledStates
(
)
;
}
async
getState
(
addon
appVersion
toolkitVersion
)
{
let
entry
=
await
this
.
getEntry
(
addon
appVersion
toolkitVersion
)
;
return
entry
?
entry
.
state
:
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
async
getEntry
(
addon
appVersion
toolkitVersion
)
{
await
this
.
_ensureEntries
(
)
;
return
this
.
_getEntry
(
addon
this
.
_entries
appVersion
toolkitVersion
)
;
}
_getEntry
(
addon
addonEntries
appVersion
toolkitVersion
)
{
if
(
!
gBlocklistEnabled
|
|
!
addon
)
{
return
null
;
}
if
(
!
appVersion
&
&
!
lazy
.
gApp
.
version
)
{
return
null
;
}
if
(
!
appVersion
)
{
appVersion
=
lazy
.
gApp
.
version
;
}
if
(
!
toolkitVersion
)
{
toolkitVersion
=
lazy
.
gApp
.
platformVersion
;
}
let
addonProps
=
{
}
;
for
(
let
key
of
EXTENSION_BLOCK_FILTERS
)
{
addonProps
[
key
]
=
addon
[
key
]
;
}
if
(
addonProps
.
creator
)
{
addonProps
.
creator
=
addonProps
.
creator
.
name
;
}
for
(
let
entry
of
addonEntries
)
{
if
(
!
doesAddonEntryMatch
(
entry
.
matches
addonProps
)
)
{
continue
;
}
for
(
let
versionRange
of
entry
.
versionRange
)
{
if
(
Utils
.
versionsMatch
(
versionRange
addon
.
version
appVersion
toolkitVersion
)
)
{
let
blockID
=
entry
.
blockID
|
|
entry
.
id
;
return
{
state
:
versionRange
.
severity
>
=
gBlocklistLevel
?
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
:
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
url
:
Utils
.
_createBlocklistURL
(
blockID
)
prefs
:
entry
.
prefs
|
|
[
]
}
;
}
}
}
return
null
;
}
}
;
const
ExtensionBlocklistMLBF
=
{
RS_ATTACHMENT_ID
:
"
addons
-
mlbf
.
bin
"
async
_fetchMLBF
(
record
)
{
let
hash
=
record
?
.
attachment
.
hash
;
if
(
this
.
_mlbfData
&
&
hash
&
&
this
.
_mlbfData
.
cascadeHash
=
=
=
hash
)
{
if
(
record
.
generation_time
>
this
.
_mlbfData
.
generationTime
)
{
this
.
_mlbfData
.
generationTime
=
record
.
generation_time
;
}
return
this
.
_mlbfData
;
}
const
{
buffer
record
:
actualRecord
_source
:
rsAttachmentSource
}
=
await
this
.
_client
.
attachments
.
download
(
record
{
attachmentId
:
this
.
RS_ATTACHMENT_ID
fallbackToCache
:
true
fallbackToDump
:
true
}
)
;
return
{
cascadeHash
:
actualRecord
.
attachment
.
hash
cascadeFilter
:
new
CascadeFilter
(
new
Uint8Array
(
buffer
)
)
generationTime
:
actualRecord
.
generation_time
rsAttachmentSource
}
;
}
async
_updateMLBF
(
forceUpdate
=
false
)
{
if
(
!
forceUpdate
&
&
this
.
_updatePromise
)
{
return
this
.
_updatePromise
;
}
const
isUpdateReplaced
=
(
)
=
>
this
.
_updatePromise
!
=
updatePromise
;
const
updatePromise
=
(
async
(
)
=
>
{
if
(
!
gBlocklistEnabled
)
{
this
.
_mlbfData
=
null
;
this
.
_stashes
=
null
;
return
;
}
let
records
=
await
this
.
_client
.
get
(
)
;
if
(
isUpdateReplaced
(
)
)
{
return
;
}
let
mlbfRecords
=
records
.
filter
(
r
=
>
r
.
attachment
)
.
sort
(
(
a
b
)
=
>
b
.
generation_time
-
a
.
generation_time
)
;
const
mlbfRecord
=
mlbfRecords
.
find
(
r
=
>
r
.
attachment_type
=
=
"
bloomfilter
-
base
"
)
;
this
.
_stashes
=
records
.
filter
(
(
{
stash
}
)
=
>
{
return
(
stash
&
&
Array
.
isArray
(
stash
.
blocked
)
&
&
Array
.
isArray
(
stash
.
unblocked
)
)
;
}
)
.
sort
(
(
a
b
)
=
>
b
.
stash_time
-
a
.
stash_time
)
.
map
(
(
{
stash
stash_time
}
)
=
>
(
{
blocked
:
new
Set
(
stash
.
blocked
)
unblocked
:
new
Set
(
stash
.
unblocked
)
stash_time
}
)
)
;
let
mlbf
=
await
this
.
_fetchMLBF
(
mlbfRecord
)
;
if
(
isUpdateReplaced
(
)
)
{
return
;
}
this
.
_mlbfData
=
mlbf
;
}
)
(
)
.
catch
(
e
=
>
{
Cu
.
reportError
(
e
)
;
}
)
.
then
(
(
)
=
>
{
if
(
!
isUpdateReplaced
(
)
)
{
this
.
_updatePromise
=
null
;
this
.
_recordPostUpdateTelemetry
(
)
;
}
return
this
.
_updatePromise
;
}
)
;
this
.
_updatePromise
=
updatePromise
;
return
updatePromise
;
}
_recordPostUpdateTelemetry
(
)
{
BlocklistTelemetry
.
recordRSBlocklistLastModified
(
"
addons_mlbf
"
this
.
_client
)
;
Services
.
telemetry
.
scalarSet
(
"
blocklist
.
mlbf_source
"
this
.
_mlbfData
?
.
rsAttachmentSource
|
|
"
unknown
"
)
;
BlocklistTelemetry
.
recordTimeScalar
(
"
mlbf_generation_time
"
this
.
_mlbfData
?
.
generationTime
)
;
let
stashes
=
this
.
_stashes
|
|
[
]
;
BlocklistTelemetry
.
recordTimeScalar
(
"
mlbf_stash_time_oldest
"
stashes
[
stashes
.
length
-
1
]
?
.
stash_time
)
;
BlocklistTelemetry
.
recordTimeScalar
(
"
mlbf_stash_time_newest
"
stashes
[
0
]
?
.
stash_time
)
;
}
getBlocklistMetadataForTelemetry
(
)
{
const
generationTime
=
this
.
_mlbfData
?
.
generationTime
?
?
0
;
return
{
mlbf_last_time
:
{
this
.
_stashes
?
.
[
0
]
?
.
stash_time
?
?
generationTime
}
mlbf_generation
:
{
generationTime
}
mlbf_source
:
this
.
_mlbfData
?
.
rsAttachmentSource
?
?
"
unknown
"
}
;
}
ensureInitialized
(
)
{
if
(
!
gBlocklistEnabled
|
|
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
this
.
_client
=
lazy
.
RemoteSettings
(
"
addons
-
bloomfilters
"
{
bucketName
:
BLOCKLIST_BUCKET
}
)
;
this
.
_onUpdate
=
this
.
_onUpdate
.
bind
(
this
)
;
this
.
_client
.
on
(
"
sync
"
this
.
_onUpdate
)
;
}
shutdown
(
)
{
if
(
this
.
_client
)
{
this
.
_client
.
off
(
"
sync
"
this
.
_onUpdate
)
;
this
.
_didShutdown
=
true
;
}
}
undoShutdown
(
)
{
if
(
this
.
_didShutdown
)
{
this
.
_client
.
on
(
"
sync
"
this
.
_onUpdate
)
;
this
.
_didShutdown
=
false
;
}
}
async
_onUpdate
(
)
{
this
.
ensureInitialized
(
)
;
await
this
.
_updateMLBF
(
true
)
;
let
addons
=
await
lazy
.
AddonManager
.
getAddonsByTypes
(
lazy
.
kXPIAddonTypes
)
;
for
(
let
addon
of
addons
)
{
let
oldState
=
addon
.
blocklistState
;
await
addon
.
updateBlocklistState
(
false
)
;
let
state
=
addon
.
blocklistState
;
LOG
(
"
Blocklist
state
for
"
+
addon
.
id
+
"
changed
from
"
+
oldState
+
"
to
"
+
state
)
;
if
(
state
=
=
oldState
)
{
continue
;
}
if
(
state
!
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
{
await
addon
.
setSoftDisabled
(
false
)
;
}
BlocklistTelemetry
.
recordAddonBlockChangeTelemetry
(
addon
"
blocklist_update
"
)
;
}
lazy
.
AddonManagerPrivate
.
updateAddonAppDisabledStates
(
)
;
}
async
getState
(
addon
)
{
let
state
=
await
this
.
getEntry
(
addon
)
;
return
state
?
state
.
state
:
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
async
getEntry
(
addon
)
{
if
(
!
this
.
_stashes
)
{
this
.
ensureInitialized
(
)
;
await
this
.
_updateMLBF
(
false
)
;
}
else
if
(
this
.
_updatePromise
)
{
await
this
.
_updatePromise
;
}
let
blockKey
=
addon
.
id
+
"
:
"
+
addon
.
version
;
if
(
this
.
_stashes
)
{
for
(
let
stash
of
this
.
_stashes
)
{
if
(
stash
.
blocked
.
has
(
blockKey
)
)
{
return
this
.
_createBlockEntry
(
addon
)
;
}
if
(
stash
.
unblocked
.
has
(
blockKey
)
)
{
return
null
;
}
}
}
let
{
signedDate
}
=
addon
;
if
(
!
signedDate
)
{
return
null
;
}
if
(
!
this
.
_mlbfData
)
{
return
null
;
}
let
{
cascadeFilter
generationTime
}
=
this
.
_mlbfData
;
if
(
!
cascadeFilter
.
has
(
blockKey
)
)
{
return
null
;
}
let
{
signedState
}
=
addon
;
if
(
signedState
!
=
=
lazy
.
AddonManager
.
SIGNEDSTATE_PRELIMINARY
&
&
signedState
!
=
=
lazy
.
AddonManager
.
SIGNEDSTATE_SIGNED
)
{
return
null
;
}
if
(
signedDate
.
getTime
(
)
>
generationTime
)
{
return
null
;
}
if
(
AppConstants
.
NIGHTLY_BUILD
&
&
addon
.
type
=
=
=
"
locale
"
)
{
return
null
;
}
return
this
.
_createBlockEntry
(
addon
)
;
}
_createBlockEntry
(
addon
)
{
return
{
state
:
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
url
:
this
.
createBlocklistURL
(
addon
.
id
addon
.
version
)
}
;
}
createBlocklistURL
(
id
version
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_BLOCKLIST_ADDONITEM_URL
)
;
return
url
.
replace
(
/
%
addonID
%
/
g
id
)
.
replace
(
/
%
addonVersion
%
/
g
version
)
;
}
}
;
const
EXTENSION_BLOCK_FILTERS
=
[
"
id
"
"
name
"
"
creator
"
"
homepageURL
"
"
updateURL
"
]
;
var
gLoggingEnabled
=
null
;
var
gBlocklistEnabled
=
true
;
var
gBlocklistLevel
=
DEFAULT_LEVEL
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gApp
"
function
(
)
{
let
appinfo
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
try
{
appinfo
.
QueryInterface
(
Ci
.
nsIXULAppInfo
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Components
.
Exception
)
|
|
ex
.
result
!
=
Cr
.
NS_NOINTERFACE
)
{
throw
ex
;
}
}
return
appinfo
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gAppID
"
function
(
)
{
return
lazy
.
gApp
.
ID
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gAppOS
"
function
(
)
{
return
lazy
.
gApp
.
OS
;
}
)
;
function
LOG
(
string
)
{
if
(
gLoggingEnabled
)
{
dump
(
"
*
*
*
"
+
string
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
string
)
;
}
}
let
Blocklist
=
{
_init
(
)
{
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
)
;
gLoggingEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_LOGGING_ENABLED
false
)
;
gBlocklistEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_ENABLED
true
)
;
gBlocklistLevel
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_LEVEL
DEFAULT_LEVEL
)
MAX_BLOCK_LEVEL
)
;
this
.
_chooseExtensionBlocklistImplementationFromPref
(
)
;
Services
.
prefs
.
addObserver
(
"
extensions
.
blocklist
.
"
this
)
;
Services
.
prefs
.
addObserver
(
PREF_EM_LOGGING_ENABLED
this
)
;
BlocklistTelemetry
.
init
(
)
;
}
isLoaded
:
true
shutdown
(
)
{
GfxBlocklistRS
.
shutdown
(
)
;
this
.
ExtensionBlocklist
.
shutdown
(
)
;
Services
.
obs
.
removeObserver
(
this
"
xpcom
-
shutdown
"
)
;
Services
.
prefs
.
removeObserver
(
"
extensions
.
blocklist
.
"
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_EM_LOGGING_ENABLED
this
)
;
}
observe
(
subject
topic
prefName
)
{
switch
(
topic
)
{
case
"
xpcom
-
shutdown
"
:
this
.
shutdown
(
)
;
break
;
case
"
nsPref
:
changed
"
:
switch
(
prefName
)
{
case
PREF_EM_LOGGING_ENABLED
:
gLoggingEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_LOGGING_ENABLED
false
)
;
break
;
case
PREF_BLOCKLIST_ENABLED
:
gBlocklistEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_ENABLED
true
)
;
this
.
_blocklistUpdated
(
)
;
break
;
case
PREF_BLOCKLIST_LEVEL
:
gBlocklistLevel
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_LEVEL
DEFAULT_LEVEL
)
MAX_BLOCK_LEVEL
)
;
this
.
_blocklistUpdated
(
)
;
break
;
case
PREF_BLOCKLIST_USE_MLBF
:
let
oldImpl
=
this
.
ExtensionBlocklist
;
this
.
_chooseExtensionBlocklistImplementationFromPref
(
)
;
if
(
oldImpl
!
=
this
.
ExtensionBlocklist
&
&
oldImpl
.
_initialized
)
{
oldImpl
.
shutdown
(
)
;
this
.
ExtensionBlocklist
.
undoShutdown
(
)
;
this
.
ExtensionBlocklist
.
_onUpdate
(
)
;
}
break
;
}
break
;
}
}
loadBlocklistAsync
(
)
{
if
(
!
GfxBlocklistRS
.
_initialized
)
{
GfxBlocklistRS
.
checkForEntries
(
)
;
}
this
.
ExtensionBlocklist
.
ensureInitialized
(
)
;
}
getAddonBlocklistState
(
addon
appVersion
toolkitVersion
)
{
return
this
.
ExtensionBlocklist
.
getState
(
addon
appVersion
toolkitVersion
)
;
}
getAddonBlocklistEntry
(
addon
appVersion
toolkitVersion
)
{
return
this
.
ExtensionBlocklist
.
getEntry
(
addon
appVersion
toolkitVersion
)
;
}
recordAddonBlockChangeTelemetry
(
addon
reason
)
{
BlocklistTelemetry
.
recordAddonBlockChangeTelemetry
(
addon
reason
)
;
}
allowDeprecatedBlocklistV2
:
AppConstants
.
platform
=
=
=
"
android
"
_chooseExtensionBlocklistImplementationFromPref
(
)
{
if
(
this
.
allowDeprecatedBlocklistV2
&
&
!
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_USE_MLBF
false
)
)
{
this
.
ExtensionBlocklist
=
ExtensionBlocklistRS
;
Services
.
telemetry
.
scalarSet
(
"
blocklist
.
mlbf_enabled
"
false
)
;
}
else
{
this
.
ExtensionBlocklist
=
ExtensionBlocklistMLBF
;
Services
.
telemetry
.
scalarSet
(
"
blocklist
.
mlbf_enabled
"
true
)
;
}
}
_blocklistUpdated
(
)
{
this
.
ExtensionBlocklist
.
_onUpdate
(
)
;
}
}
;
Blocklist
.
_init
(
)
;
const
BlocklistPrivate
=
{
BlocklistTelemetry
ExtensionBlocklistMLBF
ExtensionBlocklistRS
GfxBlocklistRS
}
;
