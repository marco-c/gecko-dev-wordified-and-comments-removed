"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Blocklist
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
XMLHttpRequest
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AddonManagerPrivate
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CertUtils
"
"
resource
:
/
/
gre
/
modules
/
CertUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
RemoteSettings
"
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
jexlFilterFunc
"
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ServiceRequest
"
"
resource
:
/
/
gre
/
modules
/
ServiceRequest
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
const
TOOLKIT_ID
=
"
toolkit
mozilla
.
org
"
;
const
KEY_PROFILEDIR
=
"
ProfD
"
;
const
KEY_APPDIR
=
"
XCurProcD
"
;
const
FILE_BLOCKLIST
=
"
blocklist
.
xml
"
;
const
PREF_BLOCKLIST_LASTUPDATETIME
=
"
app
.
update
.
lastUpdateTime
.
blocklist
-
background
-
update
-
timer
"
;
const
PREF_BLOCKLIST_URL
=
"
extensions
.
blocklist
.
url
"
;
const
PREF_BLOCKLIST_ITEM_URL
=
"
extensions
.
blocklist
.
itemURL
"
;
const
PREF_BLOCKLIST_ENABLED
=
"
extensions
.
blocklist
.
enabled
"
;
const
PREF_BLOCKLIST_LAST_MODIFIED
=
"
extensions
.
blocklist
.
lastModified
"
;
const
PREF_BLOCKLIST_LEVEL
=
"
extensions
.
blocklist
.
level
"
;
const
PREF_BLOCKLIST_PINGCOUNTTOTAL
=
"
extensions
.
blocklist
.
pingCountTotal
"
;
const
PREF_BLOCKLIST_PINGCOUNTVERSION
=
"
extensions
.
blocklist
.
pingCountVersion
"
;
const
PREF_BLOCKLIST_SUPPRESSUI
=
"
extensions
.
blocklist
.
suppressUI
"
;
const
PREF_APP_DISTRIBUTION
=
"
distribution
.
id
"
;
const
PREF_APP_DISTRIBUTION_VERSION
=
"
distribution
.
version
"
;
const
PREF_EM_LOGGING_ENABLED
=
"
extensions
.
logging
.
enabled
"
;
const
XMLURI_BLOCKLIST
=
"
http
:
/
/
www
.
mozilla
.
org
/
2006
/
addons
-
blocklist
"
;
const
XMLURI_PARSE_ERROR
=
"
http
:
/
/
www
.
mozilla
.
org
/
newlayout
/
xml
/
parsererror
.
xml
"
;
const
URI_BLOCKLIST_DIALOG
=
"
chrome
:
/
/
mozapps
/
content
/
extensions
/
blocklist
.
xul
"
;
const
DEFAULT_SEVERITY
=
3
;
const
DEFAULT_LEVEL
=
2
;
const
MAX_BLOCK_LEVEL
=
3
;
const
SEVERITY_OUTDATED
=
0
;
const
VULNERABILITYSTATUS_NONE
=
0
;
const
VULNERABILITYSTATUS_UPDATE_AVAILABLE
=
1
;
const
VULNERABILITYSTATUS_NO_UPDATE
=
2
;
const
PREF_BLOCKLIST_BUCKET
=
"
services
.
blocklist
.
bucket
"
;
const
PREF_BLOCKLIST_GFX_COLLECTION
=
"
services
.
blocklist
.
gfx
.
collection
"
;
const
PREF_BLOCKLIST_GFX_CHECKED_SECONDS
=
"
services
.
blocklist
.
gfx
.
checked
"
;
const
PREF_BLOCKLIST_GFX_SIGNER
=
"
services
.
blocklist
.
gfx
.
signer
"
;
const
PREF_BLOCKLIST_PLUGINS_COLLECTION
=
"
services
.
blocklist
.
plugins
.
collection
"
;
const
PREF_BLOCKLIST_PLUGINS_CHECKED_SECONDS
=
"
services
.
blocklist
.
plugins
.
checked
"
;
const
PREF_BLOCKLIST_PLUGINS_SIGNER
=
"
services
.
blocklist
.
plugins
.
signer
"
;
const
PREF_BLOCKLIST_ADDONS_COLLECTION
=
"
services
.
blocklist
.
addons
.
collection
"
;
const
PREF_BLOCKLIST_ADDONS_CHECKED_SECONDS
=
"
services
.
blocklist
.
addons
.
checked
"
;
const
PREF_BLOCKLIST_ADDONS_SIGNER
=
"
services
.
blocklist
.
addons
.
signer
"
;
const
BlocklistTelemetry
=
{
recordUseXML
(
)
{
Services
.
telemetry
.
scalarSet
(
"
blocklist
.
useXML
"
Blocklist
.
useXML
)
;
}
recordXMLBlocklistLastModified
(
xmlDoc
)
{
const
lastUpdate
=
xmlDoc
&
&
xmlDoc
.
documentElement
.
getAttribute
(
"
lastupdate
"
)
;
if
(
lastUpdate
)
{
Services
.
telemetry
.
scalarSet
(
"
blocklist
.
lastModified_xml
"
new
Date
(
parseInt
(
lastUpdate
10
)
)
.
toUTCString
(
)
)
;
}
else
{
Services
.
telemetry
.
scalarSet
(
"
blocklist
.
lastModified_xml
"
"
Missing
Date
"
)
;
}
}
async
recordRSBlocklistLastModified
(
blocklistType
remoteSettingsClient
)
{
if
(
!
remoteSettingsClient
)
{
return
;
}
let
lastModified
=
await
remoteSettingsClient
.
getLastModified
(
)
;
if
(
lastModified
>
0
)
{
lastModified
=
new
Date
(
lastModified
)
.
toUTCString
(
)
;
Services
.
telemetry
.
scalarSet
(
blocklist
.
lastModified_rs_
{
blocklistType
}
lastModified
)
;
}
else
{
Services
.
telemetry
.
scalarSet
(
blocklist
.
lastModified_rs_
{
blocklistType
}
"
Missing
Date
"
)
;
}
}
recordXMLBlocklistUpdateError
(
errorType
{
status_code
}
=
{
}
)
{
const
extra
=
{
}
;
if
(
typeof
status_code
=
=
=
"
number
"
)
{
extra
.
status_code
=
String
(
status_code
)
;
}
Services
.
telemetry
.
recordEvent
(
"
addonsManager
"
"
blocklistUpdateError
"
"
xml
"
errorType
extra
)
;
}
}
;
this
.
BlocklistTelemetry
=
BlocklistTelemetry
;
const
Utils
=
{
matchesOSABI
(
item
)
{
if
(
item
.
os
)
{
let
os
=
item
.
os
.
split
(
"
"
)
;
if
(
!
os
.
includes
(
gAppOS
)
)
{
return
false
;
}
}
if
(
item
.
xpcomabi
)
{
let
xpcomabi
=
item
.
xpcomabi
.
split
(
"
"
)
;
if
(
!
xpcomabi
.
includes
(
gApp
.
XPCOMABI
)
)
{
return
false
;
}
}
return
true
;
}
versionInRange
(
version
minVersion
maxVersion
)
{
if
(
minVersion
&
&
Services
.
vc
.
compare
(
version
minVersion
)
<
0
)
{
return
false
;
}
if
(
maxVersion
&
&
Services
.
vc
.
compare
(
version
maxVersion
)
>
0
)
{
return
false
;
}
return
true
;
}
versionsMatch
(
versionRange
itemVersion
appVersion
toolkitVersion
)
{
if
(
!
itemVersion
&
&
(
versionRange
.
minVersion
|
|
versionRange
.
maxVersion
)
)
{
return
false
;
}
if
(
!
this
.
versionInRange
(
itemVersion
versionRange
.
minVersion
versionRange
.
maxVersion
)
)
{
return
false
;
}
for
(
let
tA
of
versionRange
.
targetApplication
)
{
if
(
tA
.
guid
=
=
gAppID
&
&
this
.
versionInRange
(
appVersion
tA
.
minVersion
tA
.
maxVersion
)
)
{
return
true
;
}
if
(
tA
.
guid
=
=
TOOLKIT_ID
&
&
this
.
versionInRange
(
toolkitVersion
tA
.
minVersion
tA
.
maxVersion
)
)
{
return
true
;
}
}
return
false
;
}
ensureVersionRangeIsSane
(
entry
)
{
if
(
!
entry
.
versionRange
.
length
)
{
entry
.
versionRange
.
push
(
{
}
)
;
}
for
(
let
vr
of
entry
.
versionRange
)
{
if
(
!
vr
.
hasOwnProperty
(
"
severity
"
)
)
{
vr
.
severity
=
DEFAULT_SEVERITY
;
}
if
(
!
vr
.
hasOwnProperty
(
"
vulnerabilityStatus
"
)
)
{
vr
.
vulnerabilityStatus
=
VULNERABILITYSTATUS_NONE
;
}
if
(
!
Array
.
isArray
(
vr
.
targetApplication
)
)
{
vr
.
targetApplication
=
[
]
;
}
if
(
!
vr
.
targetApplication
.
length
)
{
vr
.
targetApplication
.
push
(
{
minVersion
:
null
maxVersion
:
null
}
)
;
}
vr
.
targetApplication
.
forEach
(
tA
=
>
{
if
(
!
tA
.
guid
)
{
tA
.
guid
=
gAppID
;
}
}
)
;
}
}
_createBlocklistURL
(
id
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_BLOCKLIST_ITEM_URL
)
;
return
url
.
replace
(
/
%
blockID
%
/
g
id
)
;
}
}
;
async
function
targetAppFilter
(
entry
environment
)
{
const
{
filter_expression
}
=
entry
;
if
(
filter_expression
)
{
return
jexlFilterFunc
(
entry
environment
)
;
}
if
(
!
(
"
versionRange
"
in
entry
)
)
{
return
entry
;
}
const
{
appID
version
:
appVersion
toolkitVersion
}
=
environment
;
const
{
versionRange
}
=
entry
;
if
(
!
Array
.
isArray
(
versionRange
)
)
{
const
{
maxVersion
=
"
*
"
}
=
versionRange
;
const
matchesRange
=
Services
.
vc
.
compare
(
appVersion
maxVersion
)
<
=
0
;
return
matchesRange
?
entry
:
null
;
}
if
(
!
versionRange
.
length
)
{
return
entry
;
}
for
(
const
vr
of
versionRange
)
{
const
{
targetApplication
=
[
]
}
=
vr
;
if
(
!
targetApplication
.
length
)
{
return
entry
;
}
for
(
const
ta
of
targetApplication
)
{
const
{
guid
}
=
ta
;
if
(
!
guid
)
{
return
entry
;
}
const
{
maxVersion
=
"
*
"
}
=
ta
;
if
(
guid
=
=
appID
&
&
Services
.
vc
.
compare
(
appVersion
maxVersion
)
<
=
0
)
{
return
entry
;
}
if
(
guid
=
=
"
toolkit
mozilla
.
org
"
&
&
Services
.
vc
.
compare
(
toolkitVersion
maxVersion
)
<
=
0
)
{
return
entry
;
}
}
}
return
null
;
}
this
.
GfxBlocklistRS
=
{
_ensureInitialized
(
)
{
if
(
this
.
_initialized
|
|
!
gBlocklistEnabled
)
{
return
;
}
this
.
_initialized
=
true
;
this
.
_client
=
RemoteSettings
(
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_GFX_COLLECTION
)
{
bucketNamePref
:
PREF_BLOCKLIST_BUCKET
lastCheckTimePref
:
PREF_BLOCKLIST_GFX_CHECKED_SECONDS
signerName
:
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_GFX_SIGNER
)
filterFunc
:
targetAppFilter
}
)
;
this
.
checkForEntries
=
this
.
checkForEntries
.
bind
(
this
)
;
this
.
_client
.
on
(
"
sync
"
this
.
checkForEntries
)
;
}
shutdown
(
)
{
if
(
this
.
_client
)
{
this
.
_client
.
off
(
"
sync
"
this
.
checkForEntries
)
;
}
}
sync
(
)
{
this
.
_ensureInitialized
(
)
;
return
this
.
_client
.
sync
(
)
;
}
async
checkForEntries
(
)
{
this
.
_ensureInitialized
(
)
;
if
(
!
gBlocklistEnabled
)
{
return
[
]
;
}
let
entries
=
await
this
.
_client
.
get
(
)
;
const
trim
=
s
=
>
(
s
|
|
"
"
)
.
replace
(
/
(
^
[
\
s
\
uFEFF
\
xA0
]
+
)
|
(
[
\
s
\
uFEFF
\
xA0
]
+
)
/
g
"
"
)
;
entries
=
entries
.
map
(
entry
=
>
{
let
props
=
[
"
blockID
"
"
driverVersion
"
"
driverVersionMax
"
"
driverVersionComparator
"
"
feature
"
"
featureStatus
"
"
os
"
"
vendor
"
"
devices
"
]
;
let
rv
=
{
}
;
for
(
let
p
of
props
)
{
let
val
=
entry
[
p
]
;
if
(
!
val
|
|
(
Array
.
isArray
(
val
)
&
&
!
val
.
length
)
)
{
continue
;
}
if
(
typeof
val
=
=
"
string
"
)
{
val
=
trim
(
val
)
;
}
else
if
(
p
=
=
"
devices
"
)
{
let
invalidDevices
=
[
]
;
let
validDevices
=
[
]
;
val
.
forEach
(
v
=
>
v
.
includes
(
"
"
)
?
invalidDevices
.
push
(
v
)
:
validDevices
.
push
(
v
)
)
;
for
(
let
dev
of
invalidDevices
)
{
const
e
=
new
Error
(
Block
{
entry
.
blockID
}
contains
unsupported
device
:
{
dev
}
)
;
Cu
.
reportError
(
e
)
;
}
if
(
!
validDevices
)
{
continue
;
}
val
=
validDevices
;
}
rv
[
p
]
=
val
;
}
if
(
entry
.
versionRange
)
{
rv
.
versionRange
=
{
minVersion
:
trim
(
entry
.
versionRange
.
minVersion
)
|
|
"
0
"
maxVersion
:
trim
(
entry
.
versionRange
.
maxVersion
)
|
|
"
*
"
}
;
}
return
rv
;
}
)
;
if
(
entries
.
length
)
{
let
sortedProps
=
[
"
blockID
"
"
devices
"
"
driverVersion
"
"
driverVersionComparator
"
"
driverVersionMax
"
"
feature
"
"
featureStatus
"
"
hardware
"
"
manufacturer
"
"
model
"
"
os
"
"
osversion
"
"
product
"
"
vendor
"
"
versionRange
"
]
;
let
payload
=
[
]
;
for
(
let
gfxEntry
of
entries
)
{
let
entryLines
=
[
]
;
for
(
let
key
of
sortedProps
)
{
if
(
gfxEntry
[
key
]
)
{
let
value
=
gfxEntry
[
key
]
;
if
(
Array
.
isArray
(
value
)
)
{
value
=
value
.
join
(
"
"
)
;
}
else
if
(
value
.
maxVersion
)
{
value
=
value
.
minVersion
+
"
"
+
value
.
maxVersion
;
}
entryLines
.
push
(
key
+
"
:
"
+
value
)
;
}
}
payload
.
push
(
entryLines
.
join
(
"
\
t
"
)
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
blocklist
-
data
-
gfxItems
"
payload
.
join
(
"
\
n
"
)
)
;
}
return
entries
;
}
}
;
this
.
PluginBlocklistRS
=
{
_matchProps
:
{
matchDescription
:
"
description
"
matchFilename
:
"
filename
"
matchName
:
"
name
"
}
async
_ensureEntries
(
)
{
await
this
.
ensureInitialized
(
)
;
if
(
!
this
.
_entries
&
&
gBlocklistEnabled
)
{
await
this
.
_updateEntries
(
)
;
Services
.
tm
.
dispatchToMainThread
(
function
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
plugin
-
blocklist
-
loaded
"
)
;
}
)
;
}
}
async
_updateEntries
(
)
{
if
(
!
gBlocklistEnabled
)
{
this
.
_entries
=
[
]
;
return
;
}
this
.
_entries
=
await
this
.
_client
.
get
(
)
.
catch
(
ex
=
>
Cu
.
reportError
(
ex
)
)
;
if
(
!
this
.
_entries
)
{
this
.
_entries
=
[
]
;
return
;
}
this
.
_entries
.
forEach
(
entry
=
>
{
entry
.
matches
=
{
}
;
for
(
let
k
of
Object
.
keys
(
this
.
_matchProps
)
)
{
if
(
entry
[
k
]
)
{
try
{
entry
.
matches
[
this
.
_matchProps
[
k
]
]
=
new
RegExp
(
entry
[
k
]
"
m
"
)
;
}
catch
(
ex
)
{
}
}
}
Utils
.
ensureVersionRangeIsSane
(
entry
)
;
}
)
;
BlocklistTelemetry
.
recordRSBlocklistLastModified
(
"
plugins
"
this
.
_client
)
;
}
async
_filterItem
(
entry
)
{
if
(
!
(
await
targetAppFilter
(
entry
{
appID
:
gAppID
version
:
gApp
.
version
}
)
)
)
{
return
null
;
}
if
(
!
Utils
.
matchesOSABI
(
entry
)
)
{
return
null
;
}
if
(
!
entry
.
matchFilename
&
&
!
entry
.
matchName
&
&
!
entry
.
matchDescription
)
{
let
blockID
=
entry
.
blockID
|
|
entry
.
id
;
Cu
.
reportError
(
new
Error
(
Nothing
to
filter
plugin
item
{
blockID
}
)
)
;
return
null
;
}
return
entry
;
}
sync
(
)
{
this
.
ensureInitialized
(
)
;
return
this
.
_client
.
sync
(
)
;
}
ensureInitialized
(
)
{
if
(
!
gBlocklistEnabled
|
|
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
this
.
_client
=
RemoteSettings
(
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_PLUGINS_COLLECTION
)
{
bucketNamePref
:
PREF_BLOCKLIST_BUCKET
lastCheckTimePref
:
PREF_BLOCKLIST_PLUGINS_CHECKED_SECONDS
signerName
:
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_PLUGINS_SIGNER
)
filterFunc
:
this
.
_filterItem
}
)
;
this
.
_onUpdate
=
this
.
_onUpdate
.
bind
(
this
)
;
this
.
_client
.
on
(
"
sync
"
this
.
_onUpdate
)
;
}
shutdown
(
)
{
if
(
this
.
_client
)
{
this
.
_client
.
off
(
"
sync
"
this
.
_onUpdate
)
;
}
}
async
_onUpdate
(
)
{
let
oldEntries
=
this
.
_entries
|
|
[
]
;
this
.
ensureInitialized
(
)
;
await
this
.
_updateEntries
(
)
;
const
pluginHost
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
const
plugins
=
pluginHost
.
getPluginTags
(
)
;
let
blockedItems
=
[
]
;
for
(
let
plugin
of
plugins
)
{
let
oldState
=
this
.
_getState
(
plugin
oldEntries
)
;
let
state
=
this
.
_getState
(
plugin
this
.
_entries
)
;
LOG
(
"
Blocklist
state
for
"
+
plugin
.
name
+
"
changed
from
"
+
oldState
+
"
to
"
+
state
)
;
if
(
state
=
=
oldState
)
{
continue
;
}
if
(
oldState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
{
plugin
.
enabledState
=
Ci
.
nsIPluginTag
.
STATE_DISABLED
;
}
}
else
if
(
!
plugin
.
disabled
&
&
state
!
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
{
if
(
state
!
=
Ci
.
nsIBlocklistService
.
STATE_OUTDATED
&
&
state
!
=
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_UPDATE_AVAILABLE
&
&
state
!
=
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_NO_UPDATE
)
{
blockedItems
.
push
(
{
name
:
plugin
.
name
version
:
plugin
.
version
icon
:
"
chrome
:
/
/
mozapps
/
skin
/
plugins
/
pluginGeneric
.
svg
"
disable
:
false
blocked
:
state
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
item
:
plugin
url
:
await
this
.
getURL
(
plugin
)
}
)
;
}
}
}
if
(
blockedItems
.
length
)
{
this
.
_showBlockedPluginsPrompt
(
blockedItems
)
;
}
else
{
this
.
_notifyUpdate
(
)
;
}
}
_showBlockedPluginsPrompt
(
blockedPlugins
)
{
if
(
"
mozilla
.
org
/
addons
/
blocklist
-
prompt
;
1
"
in
Cc
)
{
try
{
let
blockedPrompter
=
Cc
[
"
mozilla
.
org
/
addons
/
blocklist
-
prompt
;
1
"
]
.
getService
(
)
.
wrappedJSObject
;
blockedPrompter
.
prompt
(
blockedPlugins
)
;
}
catch
(
e
)
{
LOG
(
e
)
;
}
this
.
_notifyUpdate
(
)
;
return
;
}
let
args
=
{
restart
:
false
list
:
blockedPlugins
}
;
args
.
wrappedJSObject
=
args
;
let
applyBlocklistChanges
=
async
(
)
=
>
{
Services
.
obs
.
removeObserver
(
applyBlocklistChanges
"
addon
-
blocklist
-
closed
"
)
;
for
(
let
blockedData
of
blockedPlugins
)
{
if
(
!
blockedData
.
disable
)
{
continue
;
}
if
(
blockedData
.
item
instanceof
Ci
.
nsIPluginTag
)
{
blockedData
.
item
.
enabledState
=
Ci
.
nsIPluginTag
.
STATE_DISABLED
;
}
}
if
(
!
args
.
restart
)
{
this
.
_notifyUpdate
(
)
;
return
;
}
let
pluginUpdatesFinishedPromise
=
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
updatesFinished
(
)
{
Services
.
obs
.
removeObserver
(
updatesFinished
"
plugin
-
blocklist
-
updates
-
finished
"
)
;
resolve
(
)
;
}
"
plugin
-
blocklist
-
updates
-
finished
"
)
;
}
)
;
this
.
_notifyUpdate
(
)
;
await
pluginUpdatesFinishedPromise
;
var
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
)
;
if
(
cancelQuit
.
data
)
{
return
;
}
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eRestart
|
Ci
.
nsIAppStartup
.
eAttemptQuit
)
;
}
;
Services
.
obs
.
addObserver
(
applyBlocklistChanges
"
addon
-
blocklist
-
closed
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_SUPPRESSUI
false
)
)
{
applyBlocklistChanges
(
)
;
return
;
}
function
blocklistUnloadHandler
(
event
)
{
if
(
event
.
target
.
location
=
=
URI_BLOCKLIST_DIALOG
)
{
applyBlocklistChanges
(
)
;
blocklistWindow
.
removeEventListener
(
"
unload
"
blocklistUnloadHandler
)
;
}
}
let
blocklistWindow
=
Services
.
ww
.
openWindow
(
null
URI_BLOCKLIST_DIALOG
"
"
"
chrome
centerscreen
dialog
titlebar
"
args
)
;
if
(
blocklistWindow
)
{
blocklistWindow
.
addEventListener
(
"
unload
"
blocklistUnloadHandler
)
;
}
}
_notifyUpdate
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
plugin
-
blocklist
-
updated
"
)
;
}
async
getURL
(
plugin
)
{
await
this
.
_ensureEntries
(
)
;
let
r
=
this
.
_getEntry
(
plugin
this
.
_entries
)
;
if
(
!
r
)
{
return
null
;
}
let
blockEntry
=
r
.
entry
;
let
blockID
=
blockEntry
.
blockID
|
|
blockEntry
.
id
;
return
blockEntry
.
infoURL
|
|
Utils
.
_createBlocklistURL
(
blockID
)
;
}
async
getState
(
plugin
appVersion
toolkitVersion
)
{
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
await
this
.
_ensureEntries
(
)
;
return
this
.
_getState
(
plugin
this
.
_entries
appVersion
toolkitVersion
)
;
}
_getEntry
(
plugin
pluginEntries
appVersion
toolkitVersion
)
{
if
(
!
gBlocklistEnabled
)
{
return
null
;
}
if
(
!
appVersion
&
&
!
gApp
.
version
)
{
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
if
(
!
appVersion
)
{
appVersion
=
gApp
.
version
;
}
if
(
!
toolkitVersion
)
{
toolkitVersion
=
gApp
.
platformVersion
;
}
const
pluginProperties
=
{
description
:
plugin
.
description
filename
:
plugin
.
filename
name
:
plugin
.
name
version
:
plugin
.
version
}
;
if
(
!
pluginEntries
)
{
Cu
.
reportError
(
new
Error
(
"
There
are
no
plugin
entries
.
This
should
never
happen
.
"
)
)
;
}
for
(
let
blockEntry
of
pluginEntries
)
{
var
matchFailed
=
false
;
for
(
var
name
in
blockEntry
.
matches
)
{
let
pluginProperty
=
pluginProperties
[
name
]
;
if
(
typeof
pluginProperty
!
=
"
string
"
|
|
!
blockEntry
.
matches
[
name
]
.
test
(
pluginProperty
)
)
{
matchFailed
=
true
;
break
;
}
}
if
(
matchFailed
)
{
continue
;
}
for
(
let
versionRange
of
blockEntry
.
versionRange
)
{
if
(
Utils
.
versionsMatch
(
versionRange
pluginProperties
.
version
appVersion
toolkitVersion
)
)
{
return
{
entry
:
blockEntry
version
:
versionRange
}
;
}
}
}
return
null
;
}
_getState
(
plugin
pluginEntries
appVersion
toolkitVersion
)
{
let
r
=
this
.
_getEntry
(
plugin
pluginEntries
appVersion
toolkitVersion
)
;
if
(
!
r
)
{
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
let
{
version
:
versionRange
}
=
r
;
if
(
versionRange
.
severity
>
=
gBlocklistLevel
)
{
return
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
;
}
if
(
versionRange
.
severity
=
=
SEVERITY_OUTDATED
)
{
let
vulnerabilityStatus
=
versionRange
.
vulnerabilityStatus
;
if
(
vulnerabilityStatus
=
=
VULNERABILITYSTATUS_UPDATE_AVAILABLE
)
{
return
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_UPDATE_AVAILABLE
;
}
if
(
vulnerabilityStatus
=
=
VULNERABILITYSTATUS_NO_UPDATE
)
{
return
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_NO_UPDATE
;
}
return
Ci
.
nsIBlocklistService
.
STATE_OUTDATED
;
}
return
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
;
}
}
;
this
.
ExtensionBlocklistRS
=
{
async
_ensureEntries
(
)
{
this
.
ensureInitialized
(
)
;
if
(
!
this
.
_entries
&
&
gBlocklistEnabled
)
{
await
this
.
_updateEntries
(
)
;
}
}
async
_updateEntries
(
)
{
if
(
!
gBlocklistEnabled
)
{
this
.
_entries
=
[
]
;
return
;
}
this
.
_entries
=
await
this
.
_client
.
get
(
)
.
catch
(
ex
=
>
Cu
.
reportError
(
ex
)
)
;
if
(
!
this
.
_entries
)
{
this
.
_entries
=
[
]
;
return
;
}
this
.
_entries
.
forEach
(
entry
=
>
{
function
getCriteria
(
str
)
{
if
(
!
str
.
startsWith
(
"
/
"
)
)
{
return
str
;
}
let
lastSlash
=
str
.
lastIndexOf
(
"
/
"
)
;
let
pattern
=
str
.
slice
(
1
lastSlash
)
;
let
flags
=
str
.
slice
(
lastSlash
+
1
)
;
return
new
RegExp
(
pattern
flags
)
;
}
entry
.
matches
=
{
}
;
if
(
entry
.
guid
)
{
entry
.
matches
.
id
=
getCriteria
(
entry
.
guid
)
;
}
for
(
let
key
of
EXTENSION_BLOCK_FILTERS
)
{
if
(
key
=
=
"
id
"
|
|
!
entry
[
key
]
)
{
continue
;
}
entry
.
matches
[
key
]
=
getCriteria
(
entry
[
key
]
)
;
}
Utils
.
ensureVersionRangeIsSane
(
entry
)
;
}
)
;
BlocklistTelemetry
.
recordRSBlocklistLastModified
(
"
addons
"
this
.
_client
)
;
}
async
_filterItem
(
entry
)
{
if
(
!
(
await
targetAppFilter
(
entry
{
appID
:
gAppID
version
:
gApp
.
version
}
)
)
)
{
return
null
;
}
if
(
!
Utils
.
matchesOSABI
(
entry
)
)
{
return
null
;
}
if
(
!
entry
.
guid
&
&
!
entry
.
name
)
{
let
blockID
=
entry
.
blockID
|
|
entry
.
id
;
Cu
.
reportError
(
new
Error
(
Nothing
to
filter
add
-
on
item
{
blockID
}
on
)
)
;
return
null
;
}
return
entry
;
}
sync
(
)
{
this
.
ensureInitialized
(
)
;
return
this
.
_client
.
sync
(
)
;
}
ensureInitialized
(
)
{
if
(
!
gBlocklistEnabled
|
|
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
this
.
_client
=
RemoteSettings
(
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_ADDONS_COLLECTION
)
{
bucketNamePref
:
PREF_BLOCKLIST_BUCKET
lastCheckTimePref
:
PREF_BLOCKLIST_ADDONS_CHECKED_SECONDS
signerName
:
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_ADDONS_SIGNER
)
filterFunc
:
this
.
_filterItem
}
)
;
this
.
_onUpdate
=
this
.
_onUpdate
.
bind
(
this
)
;
this
.
_client
.
on
(
"
sync
"
this
.
_onUpdate
)
;
}
shutdown
(
)
{
if
(
this
.
_client
)
{
this
.
_client
.
off
(
"
sync
"
this
.
_onUpdate
)
;
}
}
async
_onUpdate
(
)
{
let
oldEntries
=
this
.
_entries
|
|
[
]
;
await
this
.
ensureInitialized
(
)
;
await
this
.
_updateEntries
(
)
;
const
types
=
[
"
extension
"
"
theme
"
"
locale
"
"
dictionary
"
"
service
"
]
;
let
addons
=
await
AddonManager
.
getAddonsByTypes
(
types
)
;
for
(
let
addon
of
addons
)
{
let
oldState
=
addon
.
blocklistState
;
if
(
addon
.
updateBlocklistState
)
{
await
addon
.
updateBlocklistState
(
false
)
;
}
else
if
(
oldEntries
)
{
let
oldEntry
=
this
.
_getEntry
(
addon
oldEntries
)
;
oldState
=
oldEntry
?
oldEntry
.
state
:
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
else
{
oldState
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
let
state
=
addon
.
blocklistState
;
LOG
(
"
Blocklist
state
for
"
+
addon
.
id
+
"
changed
from
"
+
oldState
+
"
to
"
+
state
)
;
if
(
state
=
=
oldState
)
{
continue
;
}
if
(
state
!
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
{
addon
.
softDisabled
=
false
;
}
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
&
&
oldState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
addon
.
softDisabled
=
true
;
}
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
|
|
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
{
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
&
&
!
addon
.
userDisabled
)
{
addon
.
softDisabled
=
true
;
}
let
entry
=
this
.
_getEntry
(
addon
this
.
_entries
)
;
if
(
entry
.
prefs
&
&
entry
.
prefs
.
length
)
{
for
(
let
pref
of
entry
.
prefs
)
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
}
}
}
AddonManagerPrivate
.
updateAddonAppDisabledStates
(
)
;
}
async
getState
(
addon
appVersion
toolkitVersion
)
{
let
entry
=
await
this
.
getEntry
(
addon
appVersion
toolkitVersion
)
;
return
entry
?
entry
.
state
:
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
async
getEntry
(
addon
appVersion
toolkitVersion
)
{
await
this
.
_ensureEntries
(
)
;
return
this
.
_getEntry
(
addon
this
.
_entries
appVersion
toolkitVersion
)
;
}
_getEntry
(
addon
addonEntries
appVersion
toolkitVersion
)
{
if
(
!
gBlocklistEnabled
|
|
!
addon
)
{
return
null
;
}
if
(
!
appVersion
&
&
!
gApp
.
version
)
{
return
null
;
}
if
(
!
appVersion
)
{
appVersion
=
gApp
.
version
;
}
if
(
!
toolkitVersion
)
{
toolkitVersion
=
gApp
.
platformVersion
;
}
let
addonProps
=
{
}
;
for
(
let
key
of
EXTENSION_BLOCK_FILTERS
)
{
addonProps
[
key
]
=
addon
[
key
]
;
}
if
(
addonProps
.
creator
)
{
addonProps
.
creator
=
addonProps
.
creator
.
name
;
}
let
propMatches
=
(
[
k
v
]
)
=
>
{
return
(
!
v
|
|
addonProps
[
k
]
=
=
v
|
|
(
v
instanceof
RegExp
&
&
v
.
test
(
addonProps
[
k
]
)
)
)
;
}
;
for
(
let
entry
of
addonEntries
)
{
if
(
!
Object
.
entries
(
entry
.
matches
)
.
every
(
propMatches
)
)
{
continue
;
}
for
(
let
versionRange
of
entry
.
versionRange
)
{
if
(
Utils
.
versionsMatch
(
versionRange
addon
.
version
appVersion
toolkitVersion
)
)
{
let
blockID
=
entry
.
blockID
|
|
entry
.
id
;
return
{
state
:
versionRange
.
severity
>
=
gBlocklistLevel
?
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
:
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
url
:
Utils
.
_createBlocklistURL
(
blockID
)
prefs
:
entry
.
prefs
|
|
[
]
}
;
}
}
}
return
null
;
}
}
;
const
EXTENSION_BLOCK_FILTERS
=
[
"
id
"
"
name
"
"
creator
"
"
homepageURL
"
"
updateURL
"
]
;
var
gLoggingEnabled
=
null
;
var
gBlocklistEnabled
=
true
;
var
gBlocklistLevel
=
DEFAULT_LEVEL
;
class
BlocklistError
extends
Error
{
}
XPCOMUtils
.
defineLazyGetter
(
this
"
gApp
"
function
(
)
{
let
appinfo
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
try
{
appinfo
.
QueryInterface
(
Ci
.
nsIXULAppInfo
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Components
.
Exception
)
|
|
ex
.
result
!
=
Cr
.
NS_NOINTERFACE
)
{
throw
ex
;
}
}
return
appinfo
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gAppID
"
function
(
)
{
return
gApp
.
ID
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gAppVersion
"
function
(
)
{
return
gApp
.
version
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gAppOS
"
function
(
)
{
return
gApp
.
OS
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gABI
"
function
(
)
{
let
abi
=
null
;
try
{
abi
=
gApp
.
XPCOMABI
;
}
catch
(
e
)
{
LOG
(
"
BlockList
Global
gABI
:
XPCOM
ABI
unknown
.
"
)
;
}
return
abi
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gOSVersion
"
function
(
)
{
let
osVersion
;
try
{
osVersion
=
Services
.
sysinfo
.
getProperty
(
"
name
"
)
+
"
"
+
Services
.
sysinfo
.
getProperty
(
"
version
"
)
;
}
catch
(
e
)
{
LOG
(
"
BlockList
Global
gOSVersion
:
OS
Version
unknown
.
"
)
;
}
if
(
osVersion
)
{
try
{
osVersion
+
=
"
(
"
+
Services
.
sysinfo
.
getProperty
(
"
secondaryLibrary
"
)
+
"
)
"
;
}
catch
(
e
)
{
}
osVersion
=
encodeURIComponent
(
osVersion
)
;
}
return
osVersion
;
}
)
;
function
LOG
(
string
)
{
if
(
gLoggingEnabled
)
{
dump
(
"
*
*
*
"
+
string
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
string
)
;
}
}
function
restartApp
(
)
{
var
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
)
;
if
(
cancelQuit
.
data
)
{
return
;
}
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eRestart
|
Ci
.
nsIAppStartup
.
eAttemptQuit
)
;
}
function
matchesOSABI
(
blocklistElement
)
{
let
os
=
blocklistElement
.
getAttribute
(
"
os
"
)
;
if
(
os
)
{
let
choices
=
os
.
split
(
"
"
)
;
if
(
choices
.
length
&
&
!
choices
.
includes
(
gApp
.
OS
)
)
{
return
false
;
}
}
let
xpcomabi
=
blocklistElement
.
getAttribute
(
"
xpcomabi
"
)
;
if
(
xpcomabi
)
{
let
choices
=
xpcomabi
.
split
(
"
"
)
;
if
(
choices
.
length
&
&
!
choices
.
includes
(
gApp
.
XPCOMABI
)
)
{
return
false
;
}
}
return
true
;
}
function
getDistributionPrefValue
(
aPrefName
)
{
return
Services
.
prefs
.
getDefaultBranch
(
null
)
.
getCharPref
(
aPrefName
"
default
"
)
;
}
let
gLoadingWasTriggered
=
false
;
var
BlocklistXML
=
{
_init
(
)
{
if
(
gLoadingWasTriggered
)
{
this
.
loadBlocklistAsync
(
)
;
}
}
STATE_NOT_BLOCKED
:
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
STATE_SOFTBLOCKED
:
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
STATE_BLOCKED
:
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
STATE_OUTDATED
:
Ci
.
nsIBlocklistService
.
STATE_OUTDATED
STATE_VULNERABLE_UPDATE_AVAILABLE
:
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_UPDATE_AVAILABLE
STATE_VULNERABLE_NO_UPDATE
:
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_NO_UPDATE
_addonEntries
:
null
_gfxEntries
:
null
_pluginEntries
:
null
get
profileBlocklistPath
(
)
{
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FILE_BLOCKLIST
)
;
Object
.
defineProperty
(
this
"
profileBlocklistPath
"
{
value
:
path
}
)
;
return
path
;
}
shutdown
(
)
{
}
_onBlocklistEnabledToggle
(
)
{
let
lastUpdate
=
this
.
_lastUpdate
|
|
undefined
;
let
newUpdate
=
(
this
.
_lastUpdate
=
(
async
(
)
=
>
{
await
lastUpdate
;
this
.
_clear
(
)
;
await
this
.
loadBlocklistAsync
(
)
;
await
this
.
_blocklistUpdated
(
null
null
)
;
if
(
newUpdate
=
=
this
.
_lastUpdate
)
{
delete
this
.
_lastUpdate
;
}
}
)
(
)
.
catch
(
Cu
.
reportError
)
)
;
}
async
getAddonBlocklistState
(
addon
appVersion
toolkitVersion
)
{
await
this
.
loadBlocklistAsync
(
)
;
return
this
.
_getAddonBlocklistState
(
addon
this
.
_addonEntries
appVersion
toolkitVersion
)
;
}
_getAddonBlocklistEntry
(
addon
addonEntries
appVersion
toolkitVersion
)
{
if
(
!
gBlocklistEnabled
)
{
return
null
;
}
if
(
!
appVersion
&
&
!
gAppVersion
)
{
return
null
;
}
if
(
!
appVersion
)
{
appVersion
=
gAppVersion
;
}
if
(
!
toolkitVersion
)
{
toolkitVersion
=
gApp
.
platformVersion
;
}
var
blItem
=
this
.
_findMatchingAddonEntry
(
addonEntries
addon
)
;
if
(
!
blItem
)
{
return
null
;
}
for
(
let
currentblItem
of
blItem
.
versions
)
{
if
(
currentblItem
.
includesItem
(
addon
.
version
appVersion
toolkitVersion
)
)
{
return
{
state
:
currentblItem
.
severity
>
=
gBlocklistLevel
?
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
:
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
url
:
blItem
.
blockID
&
&
this
.
_createBlocklistURL
(
blItem
.
blockID
)
}
;
}
}
return
null
;
}
async
getAddonBlocklistEntry
(
addon
appVersion
toolkitVersion
)
{
await
this
.
loadBlocklistAsync
(
)
;
return
this
.
_getAddonBlocklistEntry
(
addon
this
.
_addonEntries
appVersion
toolkitVersion
)
;
}
_getAddonBlocklistState
(
addon
addonEntries
appVersion
toolkitVersion
)
{
let
entry
=
this
.
_getAddonBlocklistEntry
(
addon
addonEntries
appVersion
toolkitVersion
)
;
if
(
entry
)
{
return
entry
.
state
;
}
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
_getAddonPrefs
(
addon
)
{
let
entry
=
this
.
_findMatchingAddonEntry
(
this
.
_addonEntries
addon
)
;
return
entry
.
prefs
.
slice
(
0
)
;
}
_findMatchingAddonEntry
(
aAddonEntries
aAddon
)
{
if
(
!
aAddon
)
{
return
null
;
}
function
checkEntry
(
entry
params
)
{
for
(
let
[
key
value
]
of
Object
.
entries
(
entry
)
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
continue
;
}
if
(
params
[
key
]
)
{
if
(
value
instanceof
RegExp
)
{
if
(
!
value
.
test
(
params
[
key
]
)
)
{
return
false
;
}
}
else
if
(
value
!
=
=
params
[
key
]
)
{
return
false
;
}
}
else
{
return
false
;
}
}
return
true
;
}
let
params
=
{
}
;
for
(
let
filter
of
EXTENSION_BLOCK_FILTERS
)
{
params
[
filter
]
=
aAddon
[
filter
]
;
}
if
(
params
.
creator
)
{
params
.
creator
=
params
.
creator
.
name
;
}
for
(
let
entry
of
aAddonEntries
)
{
if
(
checkEntry
(
entry
.
attributes
params
)
)
{
return
entry
;
}
}
return
null
;
}
_createBlocklistURL
(
id
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_BLOCKLIST_ITEM_URL
)
;
return
url
.
replace
(
/
%
blockID
%
/
g
id
)
;
}
_getBlocklistServerURL
(
)
{
return
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_URL
)
;
}
notify
(
aTimer
)
{
if
(
!
gBlocklistEnabled
)
{
return
;
}
try
{
var
dsURI
=
this
.
_getBlocklistServerURL
(
)
;
}
catch
(
e
)
{
BlocklistTelemetry
.
recordXMLBlocklistUpdateError
(
"
MISSING_BLOCKLIST_SERVER_URL
"
)
;
LOG
(
"
Blocklist
:
:
notify
:
The
"
+
PREF_BLOCKLIST_URL
+
"
preference
"
+
"
is
missing
!
"
)
;
return
;
}
var
pingCountVersion
=
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_PINGCOUNTVERSION
0
)
;
var
pingCountTotal
=
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_PINGCOUNTTOTAL
1
)
;
var
daysSinceLastPing
=
0
;
if
(
pingCountVersion
=
=
0
)
{
daysSinceLastPing
=
"
new
"
;
}
else
{
let
secondsInDay
=
60
*
60
*
24
;
let
lastUpdateTime
=
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_LASTUPDATETIME
0
)
;
if
(
lastUpdateTime
=
=
0
)
{
daysSinceLastPing
=
"
invalid
"
;
}
else
{
let
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
daysSinceLastPing
=
Math
.
floor
(
(
now
-
lastUpdateTime
)
/
secondsInDay
)
;
}
if
(
daysSinceLastPing
=
=
0
|
|
daysSinceLastPing
=
=
"
invalid
"
)
{
pingCountVersion
=
pingCountTotal
=
"
invalid
"
;
}
}
if
(
pingCountVersion
<
1
)
{
pingCountVersion
=
1
;
}
if
(
pingCountTotal
<
1
)
{
pingCountTotal
=
1
;
}
let
replacements
=
{
APP_ID
:
gAppID
PRODUCT
:
gApp
.
name
BUILD_ID
:
gApp
.
appBuildID
BUILD_TARGET
:
gApp
.
OS
+
"
_
"
+
gABI
OS_VERSION
:
gOSVersion
LOCALE
:
Services
.
locale
.
requestedLocale
CHANNEL
:
UpdateUtils
.
UpdateChannel
PLATFORM_VERSION
:
gApp
.
platformVersion
DISTRIBUTION
:
getDistributionPrefValue
(
PREF_APP_DISTRIBUTION
)
DISTRIBUTION_VERSION
:
getDistributionPrefValue
(
PREF_APP_DISTRIBUTION_VERSION
)
PING_COUNT
:
pingCountVersion
TOTAL_PING_COUNT
:
pingCountTotal
DAYS_SINCE_LAST_PING
:
daysSinceLastPing
}
;
dsURI
=
dsURI
.
replace
(
/
%
(
[
A
-
Z_
]
+
)
%
/
g
function
(
fullMatch
name
)
{
if
(
gAppVersion
&
&
(
name
=
=
"
APP_VERSION
"
|
|
name
=
=
"
VERSION
"
)
)
{
return
gAppVersion
;
}
if
(
!
replacements
.
hasOwnProperty
(
name
)
)
{
return
fullMatch
;
}
return
replacements
[
name
]
;
}
)
;
dsURI
=
dsURI
.
replace
(
/
\
+
/
g
"
%
2B
"
)
;
if
(
pingCountVersion
!
=
"
invalid
"
)
{
pingCountVersion
+
+
;
if
(
pingCountVersion
>
2147483647
)
{
pingCountVersion
=
-
1
;
}
Services
.
prefs
.
setIntPref
(
PREF_BLOCKLIST_PINGCOUNTVERSION
pingCountVersion
)
;
}
if
(
pingCountTotal
!
=
"
invalid
"
)
{
pingCountTotal
+
+
;
if
(
pingCountTotal
>
2147483647
)
{
pingCountTotal
=
-
1
;
}
Services
.
prefs
.
setIntPref
(
PREF_BLOCKLIST_PINGCOUNTTOTAL
pingCountTotal
)
;
}
try
{
var
uri
=
Services
.
io
.
newURI
(
dsURI
)
;
}
catch
(
e
)
{
BlocklistTelemetry
.
recordXMLBlocklistUpdateError
(
"
INVALID_BLOCKLIST_URL
"
)
;
LOG
(
"
Blocklist
:
:
notify
:
There
was
an
error
creating
the
blocklist
URI
\
r
\
n
"
+
"
for
:
"
+
dsURI
+
"
error
:
"
+
e
)
;
return
;
}
LOG
(
"
Blocklist
:
:
notify
:
Requesting
"
+
uri
.
spec
)
;
let
request
=
new
ServiceRequest
(
{
mozAnon
:
true
}
)
;
request
.
open
(
"
GET
"
uri
.
spec
true
)
;
request
.
channel
.
notificationCallbacks
=
new
CertUtils
.
BadCertHandler
(
)
;
request
.
overrideMimeType
(
"
text
/
xml
"
)
;
const
lastModified
=
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_LAST_MODIFIED
"
"
)
;
if
(
lastModified
)
{
request
.
setRequestHeader
(
"
If
-
Modified
-
Since
"
lastModified
)
;
}
else
{
request
.
setRequestHeader
(
"
Cache
-
Control
"
"
no
-
cache
"
)
;
}
request
.
addEventListener
(
"
error
"
event
=
>
this
.
onXMLError
(
event
)
)
;
request
.
addEventListener
(
"
load
"
event
=
>
this
.
onXMLLoad
(
event
)
)
;
request
.
send
(
null
)
;
}
async
onXMLLoad
(
aEvent
)
{
let
request
=
aEvent
.
target
;
try
{
CertUtils
.
checkCert
(
request
.
channel
)
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
"
+
e
)
;
BlocklistTelemetry
.
recordXMLBlocklistUpdateError
(
"
CHECK_CERT_ERROR
"
)
;
return
;
}
let
{
status
}
=
request
;
if
(
status
=
=
304
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
up
to
date
.
"
)
;
return
;
}
if
(
status
!
=
200
&
&
status
!
=
0
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
there
was
an
error
during
load
got
status
:
"
+
status
)
;
BlocklistTelemetry
.
recordXMLBlocklistUpdateError
(
"
UNEXPECTED_STATUS_CODE
"
{
status_code
:
status
}
)
;
return
;
}
let
{
responseXML
}
=
request
;
if
(
!
responseXML
|
|
responseXML
.
documentElement
.
namespaceURI
=
=
XMLURI_PARSE_ERROR
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
there
was
an
error
during
load
we
got
invalid
XML
"
)
;
BlocklistTelemetry
.
recordXMLBlocklistUpdateError
(
"
INVALID_XML_ERROR
"
)
;
return
;
}
const
lastModified
=
request
.
getResponseHeader
(
"
Last
-
Modified
"
)
|
|
"
"
;
Services
.
prefs
.
setCharPref
(
PREF_BLOCKLIST_LAST_MODIFIED
lastModified
)
;
if
(
!
this
.
isLoaded
)
{
await
this
.
loadBlocklistAsync
(
)
;
}
var
oldAddonEntries
=
this
.
_addonEntries
;
var
oldPluginEntries
=
this
.
_pluginEntries
;
await
this
.
_loadBlocklistFromXML
(
responseXML
)
;
this
.
_blocklistUpdated
(
oldAddonEntries
oldPluginEntries
)
;
try
{
let
path
=
this
.
profileBlocklistPath
;
await
OS
.
File
.
writeAtomic
(
path
request
.
responseText
{
tmpPath
:
path
+
"
.
tmp
"
}
)
;
}
catch
(
e
)
{
BlocklistTelemetry
.
recordXMLBlocklistUpdateError
(
"
WRITE_FILE_ERROR
"
)
;
LOG
(
"
Blocklist
:
:
onXMLLoad
:
"
+
e
)
;
}
}
onXMLError
(
aEvent
)
{
try
{
var
request
=
aEvent
.
target
;
var
status
=
request
.
status
;
}
catch
(
e
)
{
request
=
aEvent
.
target
.
channel
.
QueryInterface
(
Ci
.
nsIRequest
)
;
status
=
request
.
status
;
}
var
statusText
=
"
XMLHttpRequest
channel
unavailable
"
;
if
(
status
!
=
0
)
{
try
{
statusText
=
request
.
statusText
;
}
catch
(
e
)
{
}
}
BlocklistTelemetry
.
recordXMLBlocklistUpdateError
(
"
DOWNLOAD_ERROR
"
{
status_code
:
status
}
)
;
LOG
(
"
Blocklist
:
onError
:
There
was
an
error
loading
the
blocklist
file
\
r
\
n
"
+
statusText
)
;
}
get
isLoaded
(
)
{
return
(
this
.
_addonEntries
!
=
null
&
&
this
.
_gfxEntries
!
=
null
&
&
this
.
_pluginEntries
!
=
null
)
;
}
_clear
(
)
{
this
.
_addonEntries
=
null
;
this
.
_gfxEntries
=
null
;
this
.
_pluginEntries
=
null
;
delete
this
.
_loadPromise
;
}
async
loadBlocklistAsync
(
)
{
if
(
this
.
isLoaded
)
{
return
;
}
if
(
!
this
.
_loadPromise
)
{
this
.
_loadPromise
=
this
.
_loadBlocklistAsyncInternal
(
)
;
}
await
this
.
_loadPromise
;
}
async
_loadBlocklistAsyncInternal
(
)
{
if
(
this
.
isLoaded
)
{
return
;
}
if
(
!
gBlocklistEnabled
)
{
LOG
(
"
Blocklist
:
:
loadBlocklist
:
blocklist
is
disabled
"
)
;
return
;
}
let
xmlDoc
;
try
{
let
profFile
=
FileUtils
.
getFile
(
KEY_PROFILEDIR
[
FILE_BLOCKLIST
]
)
;
xmlDoc
=
await
this
.
_loadFile
(
profFile
)
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
loadBlocklistAsync
:
Failed
to
load
XML
file
"
+
e
)
;
}
if
(
!
xmlDoc
|
|
AddonManagerPrivate
.
browserUpdated
)
{
var
appFile
=
FileUtils
.
getFile
(
KEY_APPDIR
[
FILE_BLOCKLIST
]
)
;
let
appDoc
;
try
{
appDoc
=
await
this
.
_loadFile
(
appFile
)
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
loadBlocklistAsync
:
Failed
to
load
XML
file
"
+
e
)
;
}
if
(
xmlDoc
&
&
appDoc
)
{
let
clearProfile
=
false
;
if
(
!
xmlDoc
.
documentElement
.
hasAttribute
(
"
lastupdate
"
)
)
{
clearProfile
=
true
;
}
else
{
let
profileTS
=
parseInt
(
xmlDoc
.
documentElement
.
getAttribute
(
"
lastupdate
"
)
10
)
;
let
appTS
=
parseInt
(
appDoc
.
documentElement
.
getAttribute
(
"
lastupdate
"
)
10
)
;
if
(
appTS
>
profileTS
)
{
clearProfile
=
true
;
}
}
if
(
clearProfile
)
{
await
OS
.
File
.
remove
(
this
.
profileBlocklistPath
)
;
xmlDoc
=
null
;
}
}
if
(
!
xmlDoc
)
{
xmlDoc
=
appDoc
;
}
}
if
(
xmlDoc
)
{
await
new
Promise
(
resolve
=
>
{
ChromeUtils
.
idleDispatch
(
async
(
)
=
>
{
if
(
!
this
.
isLoaded
)
{
await
this
.
_loadBlocklistFromXML
(
xmlDoc
)
;
}
resolve
(
)
;
}
)
;
}
)
;
return
;
}
LOG
(
"
Blocklist
:
:
loadBlocklistAsync
:
no
XML
File
found
"
)
;
this
.
_addonEntries
=
[
]
;
this
.
_gfxEntries
=
[
]
;
this
.
_pluginEntries
=
[
]
;
}
_loadFile
(
file
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
request
=
new
XMLHttpRequest
(
)
;
request
.
open
(
"
GET
"
Services
.
io
.
newFileURI
(
file
)
.
spec
true
)
;
request
.
overrideMimeType
(
"
text
/
xml
"
)
;
request
.
addEventListener
(
"
error
"
reject
)
;
request
.
addEventListener
(
"
load
"
function
(
)
{
let
{
status
}
=
request
;
if
(
status
!
=
200
&
&
status
!
=
0
)
{
LOG
(
"
_loadFile
:
there
was
an
error
during
load
got
status
:
"
+
status
)
;
reject
(
new
BlocklistError
(
"
Couldn
'
t
load
blocklist
file
"
)
)
;
return
;
}
let
doc
=
request
.
responseXML
;
if
(
!
doc
)
{
LOG
(
"
_loadFile
:
aborting
due
to
empty
XML
file
.
"
)
;
reject
(
new
BlocklistError
(
"
Local
blocklist
file
is
empty
"
)
)
;
return
;
}
if
(
doc
.
documentElement
.
namespaceURI
!
=
XMLURI_BLOCKLIST
)
{
LOG
(
"
_loadFile
:
aborting
due
to
incorrect
XML
Namespace
.
\
n
"
+
Expected
:
{
XMLURI_BLOCKLIST
}
\
n
+
Received
:
{
doc
.
documentElement
.
namespaceURI
}
)
;
reject
(
new
BlocklistError
(
"
Local
blocklist
file
has
the
wrong
namespace
!
"
)
)
;
return
;
}
resolve
(
doc
)
;
}
)
;
request
.
send
(
null
)
;
}
)
;
}
async
_loadBlocklistFromXML
(
doc
)
{
this
.
_addonEntries
=
[
]
;
this
.
_gfxEntries
=
[
]
;
this
.
_pluginEntries
=
[
]
;
try
{
var
children
=
doc
.
documentElement
.
children
;
for
(
let
element
of
children
)
{
switch
(
element
.
localName
)
{
case
"
emItems
"
:
this
.
_addonEntries
=
await
this
.
_processItemNodes
(
element
.
children
"
emItem
"
this
.
_handleEmItemNode
)
;
break
;
case
"
pluginItems
"
:
this
.
_pluginEntries
=
await
this
.
_processItemNodes
(
element
.
children
"
pluginItem
"
this
.
_handlePluginItemNode
)
;
break
;
case
"
gfxItems
"
:
this
.
_gfxEntries
=
await
this
.
_processItemNodes
(
element
.
children
"
gfxBlacklistEntry
"
this
.
_handleGfxBlacklistNode
)
;
break
;
default
:
LOG
(
"
Blocklist
:
:
_loadBlocklistFromXML
:
ignored
entries
"
+
element
.
localName
)
;
}
}
if
(
this
.
_gfxEntries
.
length
)
{
this
.
_notifyObserversBlocklistGFX
(
)
;
}
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
_loadBlocklistFromXML
:
Error
constructing
blocklist
"
+
e
)
;
}
BlocklistTelemetry
.
recordXMLBlocklistLastModified
(
doc
)
;
Services
.
tm
.
dispatchToMainThread
(
function
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
blocklist
-
loaded
"
)
;
}
)
;
}
async
_processItemNodes
(
items
itemName
handler
)
{
var
result
=
[
]
;
let
deadline
=
await
new
Promise
(
ChromeUtils
.
idleDispatch
)
;
for
(
let
item
of
items
)
{
if
(
item
.
localName
=
=
itemName
)
{
handler
(
item
result
)
;
}
if
(
!
deadline
|
|
deadline
.
didTimeout
|
|
deadline
.
timeRemaining
(
)
<
1
)
{
deadline
=
await
new
Promise
(
ChromeUtils
.
idleDispatch
)
;
}
}
return
result
;
}
_handleEmItemNode
(
blocklistElement
result
)
{
if
(
!
matchesOSABI
(
blocklistElement
)
)
{
return
;
}
let
blockEntry
=
{
versions
:
[
]
prefs
:
[
]
blockID
:
null
attributes
:
{
}
}
;
for
(
let
filter
of
EXTENSION_BLOCK_FILTERS
)
{
let
attr
=
blocklistElement
.
getAttribute
(
filter
)
;
if
(
attr
)
{
if
(
attr
.
startsWith
(
"
/
"
)
)
{
let
lastSlash
=
attr
.
lastIndexOf
(
"
/
"
)
;
let
pattern
=
attr
.
slice
(
1
lastSlash
)
;
let
flags
=
attr
.
slice
(
lastSlash
+
1
)
;
blockEntry
.
attributes
[
filter
]
=
new
RegExp
(
pattern
flags
)
;
}
else
{
blockEntry
.
attributes
[
filter
]
=
attr
;
}
}
}
var
children
=
blocklistElement
.
children
;
for
(
let
childElement
of
children
)
{
let
localName
=
childElement
.
localName
;
if
(
localName
=
=
"
prefs
"
&
&
childElement
.
hasChildNodes
)
{
let
prefElements
=
childElement
.
children
;
for
(
let
prefElement
of
prefElements
)
{
if
(
prefElement
.
localName
=
=
"
pref
"
)
{
blockEntry
.
prefs
.
push
(
prefElement
.
textContent
)
;
}
}
}
else
if
(
localName
=
=
"
versionRange
"
)
{
blockEntry
.
versions
.
push
(
new
BlocklistItemData
(
childElement
)
)
;
}
}
if
(
!
blockEntry
.
versions
.
length
)
{
blockEntry
.
versions
.
push
(
new
BlocklistItemData
(
null
)
)
;
}
blockEntry
.
blockID
=
blocklistElement
.
getAttribute
(
"
blockID
"
)
;
result
.
push
(
blockEntry
)
;
}
_handlePluginItemNode
(
blocklistElement
result
)
{
if
(
!
matchesOSABI
(
blocklistElement
)
)
{
return
;
}
let
children
=
blocklistElement
.
children
;
var
blockEntry
=
{
matches
:
{
}
versions
:
[
]
blockID
:
null
infoURL
:
null
}
;
var
hasMatch
=
false
;
for
(
let
childElement
of
children
)
{
switch
(
childElement
.
localName
)
{
case
"
match
"
:
var
name
=
childElement
.
getAttribute
(
"
name
"
)
;
var
exp
=
childElement
.
getAttribute
(
"
exp
"
)
;
try
{
blockEntry
.
matches
[
name
]
=
new
RegExp
(
exp
"
m
"
)
;
hasMatch
=
true
;
}
catch
(
e
)
{
}
break
;
case
"
versionRange
"
:
blockEntry
.
versions
.
push
(
new
BlocklistItemData
(
childElement
)
)
;
break
;
case
"
infoURL
"
:
blockEntry
.
infoURL
=
childElement
.
textContent
;
break
;
}
}
if
(
!
hasMatch
)
{
return
;
}
if
(
!
blockEntry
.
versions
.
length
)
{
blockEntry
.
versions
.
push
(
new
BlocklistItemData
(
null
)
)
;
}
blockEntry
.
blockID
=
blocklistElement
.
getAttribute
(
"
blockID
"
)
;
result
.
push
(
blockEntry
)
;
}
_handleGfxBlacklistNode
(
blocklistElement
result
)
{
const
blockEntry
=
{
}
;
if
(
blocklistElement
.
hasAttribute
(
"
blockID
"
)
)
{
blockEntry
.
blockID
=
blocklistElement
.
getAttribute
(
"
blockID
"
)
;
}
for
(
let
matchElement
of
blocklistElement
.
children
)
{
let
value
;
if
(
matchElement
.
localName
=
=
"
devices
"
)
{
value
=
[
]
;
for
(
let
childElement
of
matchElement
.
children
)
{
const
childValue
=
(
childElement
.
textContent
|
|
"
"
)
.
trim
(
)
;
if
(
childValue
)
{
if
(
/
/
.
test
(
childValue
)
)
{
const
e
=
new
Error
(
Unsupported
device
name
{
childValue
}
)
;
Cu
.
reportError
(
e
)
;
}
else
{
value
.
push
(
childValue
)
;
}
}
}
}
else
if
(
matchElement
.
localName
=
=
"
versionRange
"
)
{
value
=
{
minVersion
:
(
matchElement
.
getAttribute
(
"
minVersion
"
)
|
|
"
"
)
.
trim
(
)
|
|
"
0
"
maxVersion
:
(
matchElement
.
getAttribute
(
"
maxVersion
"
)
|
|
"
"
)
.
trim
(
)
|
|
"
*
"
}
;
}
else
{
value
=
(
matchElement
.
textContent
|
|
"
"
)
.
trim
(
)
;
}
if
(
value
)
{
blockEntry
[
matchElement
.
localName
]
=
value
;
}
}
result
.
push
(
blockEntry
)
;
}
async
getPluginBlocklistState
(
plugin
appVersion
toolkitVersion
)
{
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
await
this
.
loadBlocklistAsync
(
)
;
return
this
.
_getPluginBlocklistState
(
plugin
this
.
_pluginEntries
appVersion
toolkitVersion
)
;
}
_getPluginBlocklistEntry
(
plugin
pluginEntries
appVersion
toolkitVersion
)
{
if
(
!
gBlocklistEnabled
)
{
return
null
;
}
if
(
!
appVersion
&
&
!
gAppVersion
)
{
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
if
(
!
appVersion
)
{
appVersion
=
gAppVersion
;
}
if
(
!
toolkitVersion
)
{
toolkitVersion
=
gApp
.
platformVersion
;
}
const
pluginProperties
=
{
description
:
plugin
.
description
filename
:
plugin
.
filename
name
:
plugin
.
name
version
:
plugin
.
version
}
;
for
(
var
blockEntry
of
pluginEntries
)
{
var
matchFailed
=
false
;
for
(
var
name
in
blockEntry
.
matches
)
{
let
pluginProperty
=
pluginProperties
[
name
]
;
if
(
typeof
pluginProperty
!
=
=
"
string
"
|
|
!
blockEntry
.
matches
[
name
]
.
test
(
pluginProperty
)
)
{
matchFailed
=
true
;
break
;
}
}
if
(
matchFailed
)
{
continue
;
}
for
(
let
blockEntryVersion
of
blockEntry
.
versions
)
{
if
(
blockEntryVersion
.
includesItem
(
pluginProperties
.
version
appVersion
toolkitVersion
)
)
{
return
{
entry
:
blockEntry
version
:
blockEntryVersion
}
;
}
}
}
return
null
;
}
_getPluginBlocklistState
(
plugin
pluginEntries
appVersion
toolkitVersion
)
{
let
r
=
this
.
_getPluginBlocklistEntry
(
plugin
pluginEntries
appVersion
toolkitVersion
)
;
if
(
!
r
)
{
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
let
{
version
:
blockEntryVersion
}
=
r
;
if
(
blockEntryVersion
.
severity
>
=
gBlocklistLevel
)
{
return
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
;
}
if
(
blockEntryVersion
.
severity
=
=
SEVERITY_OUTDATED
)
{
let
vulnerabilityStatus
=
blockEntryVersion
.
vulnerabilityStatus
;
if
(
vulnerabilityStatus
=
=
VULNERABILITYSTATUS_UPDATE_AVAILABLE
)
{
return
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_UPDATE_AVAILABLE
;
}
if
(
vulnerabilityStatus
=
=
VULNERABILITYSTATUS_NO_UPDATE
)
{
return
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_NO_UPDATE
;
}
return
Ci
.
nsIBlocklistService
.
STATE_OUTDATED
;
}
return
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
;
}
async
getPluginBlockURL
(
plugin
)
{
await
this
.
loadBlocklistAsync
(
)
;
let
r
=
this
.
_getPluginBlocklistEntry
(
plugin
this
.
_pluginEntries
)
;
if
(
!
r
)
{
return
null
;
}
let
blockEntry
=
r
.
entry
;
if
(
!
blockEntry
.
blockID
)
{
return
null
;
}
return
blockEntry
.
infoURL
|
|
this
.
_createBlocklistURL
(
blockEntry
.
blockID
)
;
}
_notifyObserversBlocklistGFX
(
)
{
let
sortedProps
=
[
"
blockID
"
"
devices
"
"
driverVersion
"
"
driverVersionComparator
"
"
driverVersionMax
"
"
feature
"
"
featureStatus
"
"
hardware
"
"
manufacturer
"
"
model
"
"
os
"
"
osversion
"
"
product
"
"
vendor
"
"
versionRange
"
]
;
let
payload
=
[
]
;
for
(
let
gfxEntry
of
this
.
_gfxEntries
)
{
let
entryLines
=
[
]
;
for
(
let
key
of
sortedProps
)
{
if
(
gfxEntry
[
key
]
)
{
let
value
=
gfxEntry
[
key
]
;
if
(
Array
.
isArray
(
value
)
)
{
value
=
value
.
join
(
"
"
)
;
}
else
if
(
value
.
maxVersion
)
{
value
=
value
.
minVersion
+
"
"
+
value
.
maxVersion
;
}
entryLines
.
push
(
key
+
"
:
"
+
value
)
;
}
}
payload
.
push
(
entryLines
.
join
(
"
\
t
"
)
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
blocklist
-
data
-
gfxItems
"
payload
.
join
(
"
\
n
"
)
)
;
}
_notifyObserversBlocklistUpdated
(
)
{
Services
.
obs
.
notifyObservers
(
this
"
addon
-
blocklist
-
updated
"
)
;
Services
.
obs
.
notifyObservers
(
this
"
plugin
-
blocklist
-
updated
"
)
;
}
async
_blocklistUpdated
(
oldAddonEntries
oldPluginEntries
)
{
var
addonList
=
[
]
;
function
resetPrefs
(
prefs
)
{
for
(
let
pref
of
prefs
)
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
}
const
types
=
[
"
extension
"
"
theme
"
"
locale
"
"
dictionary
"
"
service
"
]
;
let
addons
=
await
AddonManager
.
getAddonsByTypes
(
types
)
;
for
(
let
addon
of
addons
)
{
let
oldState
=
addon
.
blocklistState
;
if
(
addon
.
updateBlocklistState
)
{
await
addon
.
updateBlocklistState
(
false
)
;
}
else
if
(
oldAddonEntries
)
{
oldState
=
this
.
_getAddonBlocklistState
(
addon
oldAddonEntries
)
;
}
else
{
oldState
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
let
state
=
addon
.
blocklistState
;
LOG
(
"
Blocklist
state
for
"
+
addon
.
id
+
"
changed
from
"
+
oldState
+
"
to
"
+
state
)
;
if
(
state
=
=
oldState
)
{
continue
;
}
if
(
state
=
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
let
prefs
=
this
.
_getAddonPrefs
(
addon
)
;
resetPrefs
(
prefs
)
;
}
if
(
state
!
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
{
addon
.
softDisabled
=
false
;
}
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
{
continue
;
}
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
&
&
oldState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
addon
.
softDisabled
=
true
;
continue
;
}
if
(
!
addon
.
isActive
)
{
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
&
&
!
addon
.
userDisabled
)
{
addon
.
softDisabled
=
true
;
}
continue
;
}
let
entry
=
this
.
_getAddonBlocklistEntry
(
addon
this
.
_addonEntries
)
;
addonList
.
push
(
{
name
:
addon
.
name
version
:
addon
.
version
icon
:
addon
.
iconURL
disable
:
false
blocked
:
state
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
item
:
addon
url
:
entry
&
&
entry
.
url
}
)
;
}
AddonManagerPrivate
.
updateAddonAppDisabledStates
(
)
;
var
phs
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
var
plugins
=
phs
.
getPluginTags
(
)
;
for
(
let
plugin
of
plugins
)
{
let
oldState
=
-
1
;
if
(
oldPluginEntries
)
{
oldState
=
this
.
_getPluginBlocklistState
(
plugin
oldPluginEntries
)
;
}
let
state
=
this
.
_getPluginBlocklistState
(
plugin
this
.
_pluginEntries
)
;
LOG
(
"
Blocklist
state
for
"
+
plugin
.
name
+
"
changed
from
"
+
oldState
+
"
to
"
+
state
)
;
if
(
state
=
=
oldState
)
{
continue
;
}
if
(
oldState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
{
plugin
.
enabledState
=
Ci
.
nsIPluginTag
.
STATE_DISABLED
;
}
}
else
if
(
!
plugin
.
disabled
&
&
state
!
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
{
if
(
state
!
=
Ci
.
nsIBlocklistService
.
STATE_OUTDATED
&
&
state
!
=
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_UPDATE_AVAILABLE
&
&
state
!
=
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_NO_UPDATE
)
{
addonList
.
push
(
{
name
:
plugin
.
name
version
:
plugin
.
version
icon
:
"
chrome
:
/
/
global
/
skin
/
plugins
/
pluginGeneric
.
svg
"
disable
:
false
blocked
:
state
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
item
:
plugin
url
:
await
this
.
getPluginBlockURL
(
plugin
)
}
)
;
}
}
}
if
(
!
addonList
.
length
)
{
this
.
_notifyObserversBlocklistUpdated
(
)
;
return
;
}
if
(
"
mozilla
.
org
/
addons
/
blocklist
-
prompt
;
1
"
in
Cc
)
{
try
{
let
blockedPrompter
=
Cc
[
"
mozilla
.
org
/
addons
/
blocklist
-
prompt
;
1
"
]
.
getService
(
)
.
wrappedJSObject
;
blockedPrompter
.
prompt
(
addonList
)
;
}
catch
(
e
)
{
LOG
(
e
)
;
}
this
.
_notifyObserversBlocklistUpdated
(
)
;
return
;
}
var
args
=
{
restart
:
false
list
:
addonList
}
;
args
.
wrappedJSObject
=
args
;
let
applyBlocklistChanges
=
(
)
=
>
{
for
(
let
addon
of
addonList
)
{
if
(
!
addon
.
disable
)
{
continue
;
}
if
(
addon
.
item
instanceof
Ci
.
nsIPluginTag
)
{
addon
.
item
.
enabledState
=
Ci
.
nsIPluginTag
.
STATE_DISABLED
;
}
else
{
addon
.
item
.
softDisabled
=
true
;
let
prefs
=
this
.
_getAddonPrefs
(
addon
.
item
)
;
resetPrefs
(
prefs
)
;
}
}
if
(
args
.
restart
)
{
restartApp
(
)
;
}
this
.
_notifyObserversBlocklistUpdated
(
)
;
Services
.
obs
.
removeObserver
(
applyBlocklistChanges
"
addon
-
blocklist
-
closed
"
)
;
}
;
Services
.
obs
.
addObserver
(
applyBlocklistChanges
"
addon
-
blocklist
-
closed
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_SUPPRESSUI
false
)
)
{
applyBlocklistChanges
(
)
;
return
;
}
function
blocklistUnloadHandler
(
event
)
{
if
(
event
.
target
.
location
=
=
URI_BLOCKLIST_DIALOG
)
{
applyBlocklistChanges
(
)
;
blocklistWindow
.
removeEventListener
(
"
unload
"
blocklistUnloadHandler
)
;
}
}
let
blocklistWindow
=
Services
.
ww
.
openWindow
(
null
URI_BLOCKLIST_DIALOG
"
"
"
chrome
centerscreen
dialog
titlebar
"
args
)
;
if
(
blocklistWindow
)
{
blocklistWindow
.
addEventListener
(
"
unload
"
blocklistUnloadHandler
)
;
}
}
}
;
function
BlocklistItemData
(
versionRangeElement
)
{
this
.
targetApps
=
{
}
;
let
foundTarget
=
false
;
this
.
severity
=
DEFAULT_SEVERITY
;
this
.
vulnerabilityStatus
=
VULNERABILITYSTATUS_NONE
;
if
(
versionRangeElement
)
{
let
versionRange
=
this
.
getBlocklistVersionRange
(
versionRangeElement
)
;
this
.
minVersion
=
versionRange
.
minVersion
;
this
.
maxVersion
=
versionRange
.
maxVersion
;
if
(
versionRangeElement
.
hasAttribute
(
"
severity
"
)
)
{
this
.
severity
=
versionRangeElement
.
getAttribute
(
"
severity
"
)
;
}
if
(
versionRangeElement
.
hasAttribute
(
"
vulnerabilitystatus
"
)
)
{
this
.
vulnerabilityStatus
=
versionRangeElement
.
getAttribute
(
"
vulnerabilitystatus
"
)
;
}
for
(
let
targetAppElement
of
versionRangeElement
.
children
)
{
if
(
targetAppElement
.
localName
=
=
"
targetApplication
"
)
{
foundTarget
=
true
;
let
appID
=
targetAppElement
.
id
|
|
gAppID
;
this
.
targetApps
[
appID
]
=
this
.
getBlocklistAppVersions
(
targetAppElement
)
;
}
}
}
else
{
this
.
minVersion
=
this
.
maxVersion
=
null
;
}
if
(
!
foundTarget
)
{
this
.
targetApps
[
gAppID
]
=
[
{
minVersion
:
null
maxVersion
:
null
}
]
;
}
}
BlocklistItemData
.
prototype
=
{
includesItem
(
version
appVersion
toolkitVersion
)
{
if
(
!
version
&
&
(
this
.
minVersion
|
|
this
.
maxVersion
)
)
{
return
false
;
}
if
(
!
this
.
matchesRange
(
version
this
.
minVersion
this
.
maxVersion
)
)
{
return
false
;
}
if
(
this
.
matchesTargetRange
(
gAppID
appVersion
)
)
{
return
true
;
}
return
this
.
matchesTargetRange
(
TOOLKIT_ID
toolkitVersion
)
;
}
matchesRange
(
version
minVersion
maxVersion
)
{
if
(
minVersion
&
&
Services
.
vc
.
compare
(
version
minVersion
)
<
0
)
{
return
false
;
}
if
(
maxVersion
&
&
Services
.
vc
.
compare
(
version
maxVersion
)
>
0
)
{
return
false
;
}
return
true
;
}
matchesTargetRange
(
appID
appVersion
)
{
var
blTargetApp
=
this
.
targetApps
[
appID
]
;
if
(
!
blTargetApp
)
{
return
false
;
}
for
(
let
app
of
blTargetApp
)
{
if
(
this
.
matchesRange
(
appVersion
app
.
minVersion
app
.
maxVersion
)
)
{
return
true
;
}
}
return
false
;
}
getBlocklistAppVersions
(
targetAppElement
)
{
var
appVersions
=
[
]
;
if
(
targetAppElement
)
{
for
(
let
versionRangeElement
of
targetAppElement
.
children
)
{
if
(
versionRangeElement
.
localName
=
=
"
versionRange
"
)
{
appVersions
.
push
(
this
.
getBlocklistVersionRange
(
versionRangeElement
)
)
;
}
}
}
if
(
!
appVersions
.
length
)
{
appVersions
.
push
(
{
minVersion
:
null
maxVersion
:
null
}
)
;
}
return
appVersions
;
}
getBlocklistVersionRange
(
versionRangeElement
)
{
let
minVersion
=
versionRangeElement
.
getAttribute
(
"
minVersion
"
)
;
let
maxVersion
=
versionRangeElement
.
getAttribute
(
"
maxVersion
"
)
;
return
{
minVersion
maxVersion
}
;
}
}
;
let
BlocklistRS
=
{
_init
(
)
{
}
shutdown
(
)
{
GfxBlocklistRS
.
shutdown
(
)
;
PluginBlocklistRS
.
shutdown
(
)
;
ExtensionBlocklistRS
.
shutdown
(
)
;
}
isLoaded
:
true
notify
(
)
{
}
forceUpdate
(
)
{
for
(
let
blocklist
of
[
GfxBlocklistRS
ExtensionBlocklistRS
PluginBlocklistRS
]
)
{
blocklist
.
sync
(
)
.
catch
(
Cu
.
reportError
)
;
}
}
loadBlocklistAsync
(
)
{
GfxBlocklistRS
.
checkForEntries
(
)
;
ExtensionBlocklistRS
.
ensureInitialized
(
)
;
PluginBlocklistRS
.
ensureInitialized
(
)
;
gLoadingWasTriggered
=
true
;
}
getPluginBlocklistState
(
plugin
appVersion
toolkitVersion
)
{
return
PluginBlocklistRS
.
getState
(
plugin
appVersion
toolkitVersion
)
;
}
getPluginBlockURL
(
plugin
)
{
return
PluginBlocklistRS
.
getURL
(
plugin
)
;
}
getAddonBlocklistState
(
addon
appVersion
toolkitVersion
)
{
return
ExtensionBlocklistRS
.
getState
(
addon
appVersion
toolkitVersion
)
;
}
getAddonBlocklistEntry
(
addon
appVersion
toolkitVersion
)
{
return
ExtensionBlocklistRS
.
getEntry
(
addon
appVersion
toolkitVersion
)
;
}
_blocklistUpdated
(
)
{
ExtensionBlocklistRS
.
_onUpdate
(
)
;
PluginBlocklistRS
.
_onUpdate
(
)
;
}
}
;
const
kSharedAPIs
=
[
"
notify
"
"
loadBlocklistAsync
"
"
getPluginBlockURL
"
"
getPluginBlocklistState
"
"
getAddonBlocklistState
"
"
getAddonBlocklistEntry
"
"
_blocklistUpdated
"
]
;
let
Blocklist
=
{
_init
(
)
{
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
)
;
gLoggingEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_LOGGING_ENABLED
false
)
;
gBlocklistEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_ENABLED
true
)
;
gBlocklistLevel
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_LEVEL
DEFAULT_LEVEL
)
MAX_BLOCK_LEVEL
)
;
Services
.
prefs
.
addObserver
(
"
extensions
.
blocklist
.
"
this
)
;
Services
.
prefs
.
addObserver
(
PREF_EM_LOGGING_ENABLED
this
)
;
for
(
let
k
of
kSharedAPIs
)
{
this
[
k
]
=
(
.
.
.
args
)
=
>
this
.
_impl
[
k
]
(
.
.
.
args
)
;
}
this
.
onUpdateImplementation
(
)
;
for
(
let
entry
of
Services
.
blocklist
.
pluginQueries
.
splice
(
0
)
)
{
entry
.
resolve
(
this
.
getPluginBlocklistState
(
entry
.
plugin
entry
.
appVersion
entry
.
toolkitVersion
)
)
;
}
}
get
isLoaded
(
)
{
return
this
.
_impl
.
isLoaded
;
}
onUpdateImplementation
(
shouldCheckForUpdates
=
false
)
{
this
.
_impl
=
this
.
useXML
?
BlocklistXML
:
BlocklistRS
;
this
.
_impl
.
_init
(
)
;
if
(
shouldCheckForUpdates
)
{
if
(
this
.
useXML
)
{
this
.
_impl
.
notify
(
)
;
}
else
{
this
.
_impl
.
forceUpdate
(
)
;
}
}
BlocklistTelemetry
.
recordUseXML
(
)
;
}
shutdown
(
)
{
this
.
_impl
.
shutdown
(
)
;
Services
.
obs
.
removeObserver
(
this
"
xpcom
-
shutdown
"
)
;
Services
.
prefs
.
removeObserver
(
"
extensions
.
blocklist
.
"
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_EM_LOGGING_ENABLED
this
)
;
}
observe
(
subject
topic
prefName
)
{
switch
(
topic
)
{
case
"
xpcom
-
shutdown
"
:
this
.
shutdown
(
)
;
break
;
case
"
profile
-
after
-
change
"
:
this
.
loadBlocklistAsync
(
)
;
break
;
case
"
nsPref
:
changed
"
:
switch
(
prefName
)
{
case
PREF_EM_LOGGING_ENABLED
:
gLoggingEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_LOGGING_ENABLED
false
)
;
break
;
case
PREF_BLOCKLIST_ENABLED
:
gBlocklistEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_ENABLED
true
)
;
if
(
this
.
_impl
=
=
BlocklistXML
)
{
this
.
_impl
.
_onBlocklistEnabledToggle
(
)
;
}
else
{
this
.
_impl
.
_blocklistUpdated
(
)
;
}
break
;
case
PREF_BLOCKLIST_LEVEL
:
gBlocklistLevel
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_LEVEL
DEFAULT_LEVEL
)
MAX_BLOCK_LEVEL
)
;
this
.
_blocklistUpdated
(
null
null
)
;
break
;
}
break
;
}
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
Blocklist
"
useXML
"
"
extensions
.
blocklist
.
useXML
"
false
(
)
=
>
Blocklist
.
onUpdateImplementation
(
true
)
)
;
Blocklist
.
_init
(
)
;
