"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Blocklist
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
XMLHttpRequest
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AddonManagerPrivate
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CertUtils
"
"
resource
:
/
/
gre
/
modules
/
CertUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ServiceRequest
"
"
resource
:
/
/
gre
/
modules
/
ServiceRequest
.
jsm
"
)
;
const
BlocklistClients
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
BlocklistClients
"
initialize
"
"
resource
:
/
/
services
-
common
/
blocklist
-
clients
.
js
"
)
;
const
TOOLKIT_ID
=
"
toolkit
mozilla
.
org
"
;
const
KEY_PROFILEDIR
=
"
ProfD
"
;
const
KEY_APPDIR
=
"
XCurProcD
"
;
const
FILE_BLOCKLIST
=
"
blocklist
.
xml
"
;
const
PREF_BLOCKLIST_LASTUPDATETIME
=
"
app
.
update
.
lastUpdateTime
.
blocklist
-
background
-
update
-
timer
"
;
const
PREF_BLOCKLIST_URL
=
"
extensions
.
blocklist
.
url
"
;
const
PREF_BLOCKLIST_ITEM_URL
=
"
extensions
.
blocklist
.
itemURL
"
;
const
PREF_BLOCKLIST_ENABLED
=
"
extensions
.
blocklist
.
enabled
"
;
const
PREF_BLOCKLIST_LAST_MODIFIED
=
"
extensions
.
blocklist
.
lastModified
"
;
const
PREF_BLOCKLIST_LEVEL
=
"
extensions
.
blocklist
.
level
"
;
const
PREF_BLOCKLIST_PINGCOUNTTOTAL
=
"
extensions
.
blocklist
.
pingCountTotal
"
;
const
PREF_BLOCKLIST_PINGCOUNTVERSION
=
"
extensions
.
blocklist
.
pingCountVersion
"
;
const
PREF_BLOCKLIST_SUPPRESSUI
=
"
extensions
.
blocklist
.
suppressUI
"
;
const
PREF_APP_DISTRIBUTION
=
"
distribution
.
id
"
;
const
PREF_APP_DISTRIBUTION_VERSION
=
"
distribution
.
version
"
;
const
PREF_EM_LOGGING_ENABLED
=
"
extensions
.
logging
.
enabled
"
;
const
XMLURI_BLOCKLIST
=
"
http
:
/
/
www
.
mozilla
.
org
/
2006
/
addons
-
blocklist
"
;
const
XMLURI_PARSE_ERROR
=
"
http
:
/
/
www
.
mozilla
.
org
/
newlayout
/
xml
/
parsererror
.
xml
"
;
const
URI_BLOCKLIST_DIALOG
=
"
chrome
:
/
/
mozapps
/
content
/
extensions
/
blocklist
.
xul
"
;
const
DEFAULT_SEVERITY
=
3
;
const
DEFAULT_LEVEL
=
2
;
const
MAX_BLOCK_LEVEL
=
3
;
const
SEVERITY_OUTDATED
=
0
;
const
VULNERABILITYSTATUS_NONE
=
0
;
const
VULNERABILITYSTATUS_UPDATE_AVAILABLE
=
1
;
const
VULNERABILITYSTATUS_NO_UPDATE
=
2
;
const
EXTENSION_BLOCK_FILTERS
=
[
"
id
"
"
name
"
"
creator
"
"
homepageURL
"
"
updateURL
"
]
;
var
gLoggingEnabled
=
null
;
var
gBlocklistEnabled
=
true
;
var
gBlocklistLevel
=
DEFAULT_LEVEL
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gApp
"
function
(
)
{
let
appinfo
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
try
{
appinfo
.
QueryInterface
(
Ci
.
nsIXULAppInfo
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Components
.
Exception
)
|
|
ex
.
result
!
=
Cr
.
NS_NOINTERFACE
)
throw
ex
;
}
return
appinfo
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gAppID
"
function
(
)
{
return
gApp
.
ID
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gAppVersion
"
function
(
)
{
return
gApp
.
version
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gABI
"
function
(
)
{
let
abi
=
null
;
try
{
abi
=
gApp
.
XPCOMABI
;
}
catch
(
e
)
{
LOG
(
"
BlockList
Global
gABI
:
XPCOM
ABI
unknown
.
"
)
;
}
return
abi
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gOSVersion
"
function
(
)
{
let
osVersion
;
try
{
osVersion
=
Services
.
sysinfo
.
getProperty
(
"
name
"
)
+
"
"
+
Services
.
sysinfo
.
getProperty
(
"
version
"
)
;
}
catch
(
e
)
{
LOG
(
"
BlockList
Global
gOSVersion
:
OS
Version
unknown
.
"
)
;
}
if
(
osVersion
)
{
try
{
osVersion
+
=
"
(
"
+
Services
.
sysinfo
.
getProperty
(
"
secondaryLibrary
"
)
+
"
)
"
;
}
catch
(
e
)
{
}
osVersion
=
encodeURIComponent
(
osVersion
)
;
}
return
osVersion
;
}
)
;
function
LOG
(
string
)
{
if
(
gLoggingEnabled
)
{
dump
(
"
*
*
*
"
+
string
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
string
)
;
}
}
function
restartApp
(
)
{
var
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
)
;
if
(
cancelQuit
.
data
)
return
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eRestart
|
Ci
.
nsIAppStartup
.
eAttemptQuit
)
;
}
function
matchesOSABI
(
blocklistElement
)
{
let
os
=
blocklistElement
.
getAttribute
(
"
os
"
)
;
if
(
os
)
{
let
choices
=
os
.
split
(
"
"
)
;
if
(
choices
.
length
>
0
&
&
!
choices
.
includes
(
gApp
.
OS
)
)
return
false
;
}
let
xpcomabi
=
blocklistElement
.
getAttribute
(
"
xpcomabi
"
)
;
if
(
xpcomabi
)
{
let
choices
=
xpcomabi
.
split
(
"
"
)
;
if
(
choices
.
length
>
0
&
&
!
choices
.
includes
(
gApp
.
XPCOMABI
)
)
return
false
;
}
return
true
;
}
function
getLocale
(
)
{
return
Services
.
locale
.
getRequestedLocale
(
)
;
}
function
getDistributionPrefValue
(
aPrefName
)
{
return
Services
.
prefs
.
getDefaultBranch
(
null
)
.
getCharPref
(
aPrefName
"
default
"
)
;
}
var
Blocklist
=
{
_init
(
)
{
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
)
;
gLoggingEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_LOGGING_ENABLED
false
)
;
gBlocklistEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_ENABLED
true
)
;
gBlocklistLevel
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_LEVEL
DEFAULT_LEVEL
)
MAX_BLOCK_LEVEL
)
;
Services
.
prefs
.
addObserver
(
"
extensions
.
blocklist
.
"
this
)
;
Services
.
prefs
.
addObserver
(
PREF_EM_LOGGING_ENABLED
this
)
;
BlocklistClients
.
initialize
(
)
;
for
(
let
entry
of
Services
.
blocklist
.
pluginQueries
.
splice
(
0
)
)
{
entry
.
resolve
(
this
.
getPluginBlocklistState
(
entry
.
plugin
entry
.
appVersion
entry
.
toolkitVersion
)
)
;
}
}
STATE_NOT_BLOCKED
:
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
STATE_SOFTBLOCKED
:
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
STATE_BLOCKED
:
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
STATE_OUTDATED
:
Ci
.
nsIBlocklistService
.
STATE_OUTDATED
STATE_VULNERABLE_UPDATE_AVAILABLE
:
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_UPDATE_AVAILABLE
STATE_VULNERABLE_NO_UPDATE
:
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_NO_UPDATE
_addonEntries
:
null
_gfxEntries
:
null
_pluginEntries
:
null
shutdown
(
)
{
Services
.
obs
.
removeObserver
(
this
"
xpcom
-
shutdown
"
)
;
Services
.
prefs
.
removeObserver
(
"
extensions
.
blocklist
.
"
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_EM_LOGGING_ENABLED
this
)
;
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
xpcom
-
shutdown
"
:
this
.
shutdown
(
)
;
break
;
case
"
profile
-
after
-
change
"
:
this
.
loadBlocklistAsync
(
)
;
break
;
case
"
nsPref
:
changed
"
:
switch
(
aData
)
{
case
PREF_EM_LOGGING_ENABLED
:
gLoggingEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_LOGGING_ENABLED
false
)
;
break
;
case
PREF_BLOCKLIST_ENABLED
:
gBlocklistEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_ENABLED
true
)
;
let
lastUpdate
=
this
.
_lastUpdate
|
|
undefined
;
let
newUpdate
=
this
.
_lastUpdate
=
(
async
(
)
=
>
{
await
lastUpdate
;
this
.
_clear
(
)
;
await
this
.
loadBlocklistAsync
(
)
;
await
this
.
_blocklistUpdated
(
null
null
)
;
if
(
newUpdate
=
=
this
.
_lastUpdate
)
{
delete
this
.
_lastUpdate
;
}
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
break
;
case
PREF_BLOCKLIST_LEVEL
:
gBlocklistLevel
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_LEVEL
DEFAULT_LEVEL
)
MAX_BLOCK_LEVEL
)
;
this
.
_blocklistUpdated
(
null
null
)
;
break
;
}
break
;
}
}
async
getAddonBlocklistState
(
addon
appVersion
toolkitVersion
)
{
await
this
.
loadBlocklistAsync
(
)
;
return
this
.
_getAddonBlocklistState
(
addon
this
.
_addonEntries
appVersion
toolkitVersion
)
;
}
_getAddonBlocklistEntry
(
addon
addonEntries
appVersion
toolkitVersion
)
{
if
(
!
gBlocklistEnabled
)
return
null
;
if
(
!
appVersion
&
&
!
gAppVersion
)
return
null
;
if
(
!
appVersion
)
appVersion
=
gAppVersion
;
if
(
!
toolkitVersion
)
toolkitVersion
=
gApp
.
platformVersion
;
var
blItem
=
this
.
_findMatchingAddonEntry
(
addonEntries
addon
)
;
if
(
!
blItem
)
return
null
;
for
(
let
currentblItem
of
blItem
.
versions
)
{
if
(
currentblItem
.
includesItem
(
addon
.
version
appVersion
toolkitVersion
)
)
{
return
{
state
:
(
currentblItem
.
severity
>
=
gBlocklistLevel
?
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
:
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
url
:
blItem
.
blockID
&
&
this
.
_createBlocklistURL
(
blItem
.
blockID
)
}
;
}
}
return
null
;
}
async
getAddonBlocklistEntry
(
addon
appVersion
toolkitVersion
)
{
await
this
.
loadBlocklistAsync
(
)
;
return
this
.
_getAddonBlocklistEntry
(
addon
this
.
_addonEntries
appVersion
toolkitVersion
)
;
}
_getAddonBlocklistState
(
addon
addonEntries
appVersion
toolkitVersion
)
{
let
entry
=
this
.
_getAddonBlocklistEntry
(
addon
addonEntries
appVersion
toolkitVersion
)
;
if
(
entry
)
return
entry
.
state
;
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
_getAddonPrefs
(
addon
)
{
let
entry
=
this
.
_findMatchingAddonEntry
(
this
.
_addonEntries
addon
)
;
return
entry
.
prefs
.
slice
(
0
)
;
}
_findMatchingAddonEntry
(
aAddonEntries
aAddon
)
{
if
(
!
aAddon
)
return
null
;
function
checkEntry
(
entry
params
)
{
for
(
let
[
key
value
]
of
Object
.
entries
(
entry
)
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
continue
;
if
(
params
[
key
]
)
{
if
(
value
instanceof
RegExp
)
{
if
(
!
value
.
test
(
params
[
key
]
)
)
{
return
false
;
}
}
else
if
(
value
!
=
=
params
[
key
]
)
{
return
false
;
}
}
else
{
return
false
;
}
}
return
true
;
}
let
params
=
{
}
;
for
(
let
filter
of
EXTENSION_BLOCK_FILTERS
)
{
params
[
filter
]
=
aAddon
[
filter
]
;
}
if
(
params
.
creator
)
params
.
creator
=
params
.
creator
.
name
;
for
(
let
entry
of
aAddonEntries
)
{
if
(
checkEntry
(
entry
.
attributes
params
)
)
{
return
entry
;
}
}
return
null
;
}
_createBlocklistURL
(
id
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_BLOCKLIST_ITEM_URL
)
;
return
url
.
replace
(
/
%
blockID
%
/
g
id
)
;
}
notify
(
aTimer
)
{
if
(
!
gBlocklistEnabled
)
return
;
try
{
var
dsURI
=
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_URL
)
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
notify
:
The
"
+
PREF_BLOCKLIST_URL
+
"
preference
"
+
"
is
missing
!
"
)
;
return
;
}
var
pingCountVersion
=
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_PINGCOUNTVERSION
0
)
;
var
pingCountTotal
=
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_PINGCOUNTTOTAL
1
)
;
var
daysSinceLastPing
=
0
;
if
(
pingCountVersion
=
=
0
)
{
daysSinceLastPing
=
"
new
"
;
}
else
{
let
secondsInDay
=
60
*
60
*
24
;
let
lastUpdateTime
=
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_LASTUPDATETIME
0
)
;
if
(
lastUpdateTime
=
=
0
)
{
daysSinceLastPing
=
"
invalid
"
;
}
else
{
let
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
daysSinceLastPing
=
Math
.
floor
(
(
now
-
lastUpdateTime
)
/
secondsInDay
)
;
}
if
(
daysSinceLastPing
=
=
0
|
|
daysSinceLastPing
=
=
"
invalid
"
)
{
pingCountVersion
=
pingCountTotal
=
"
invalid
"
;
}
}
if
(
pingCountVersion
<
1
)
pingCountVersion
=
1
;
if
(
pingCountTotal
<
1
)
pingCountTotal
=
1
;
let
replacements
=
{
APP_ID
:
gAppID
PRODUCT
:
gApp
.
name
BUILD_ID
:
gApp
.
appBuildID
BUILD_TARGET
:
gApp
.
OS
+
"
_
"
+
gABI
OS_VERSION
:
gOSVersion
LOCALE
:
getLocale
(
)
CHANNEL
:
UpdateUtils
.
UpdateChannel
PLATFORM_VERSION
:
gApp
.
platformVersion
DISTRIBUTION
:
getDistributionPrefValue
(
PREF_APP_DISTRIBUTION
)
DISTRIBUTION_VERSION
:
getDistributionPrefValue
(
PREF_APP_DISTRIBUTION_VERSION
)
PING_COUNT
:
pingCountVersion
TOTAL_PING_COUNT
:
pingCountTotal
DAYS_SINCE_LAST_PING
:
daysSinceLastPing
}
;
dsURI
=
dsURI
.
replace
(
/
%
(
[
A
-
Z_
]
+
)
%
/
g
function
(
fullMatch
name
)
{
if
(
gAppVersion
&
&
(
name
=
=
"
APP_VERSION
"
|
|
name
=
=
"
VERSION
"
)
)
{
return
gAppVersion
;
}
if
(
!
replacements
.
hasOwnProperty
(
name
)
)
{
return
fullMatch
;
}
return
replacements
[
name
]
;
}
)
;
dsURI
=
dsURI
.
replace
(
/
\
+
/
g
"
%
2B
"
)
;
if
(
pingCountVersion
!
=
"
invalid
"
)
{
pingCountVersion
+
+
;
if
(
pingCountVersion
>
2147483647
)
{
pingCountVersion
=
-
1
;
}
Services
.
prefs
.
setIntPref
(
PREF_BLOCKLIST_PINGCOUNTVERSION
pingCountVersion
)
;
}
if
(
pingCountTotal
!
=
"
invalid
"
)
{
pingCountTotal
+
+
;
if
(
pingCountTotal
>
2147483647
)
{
pingCountTotal
=
-
1
;
}
Services
.
prefs
.
setIntPref
(
PREF_BLOCKLIST_PINGCOUNTTOTAL
pingCountTotal
)
;
}
try
{
var
uri
=
Services
.
io
.
newURI
(
dsURI
)
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
notify
:
There
was
an
error
creating
the
blocklist
URI
\
r
\
n
"
+
"
for
:
"
+
dsURI
+
"
error
:
"
+
e
)
;
return
;
}
LOG
(
"
Blocklist
:
:
notify
:
Requesting
"
+
uri
.
spec
)
;
let
request
=
new
ServiceRequest
(
)
;
request
.
open
(
"
GET
"
uri
.
spec
true
)
;
request
.
channel
.
notificationCallbacks
=
new
CertUtils
.
BadCertHandler
(
)
;
request
.
overrideMimeType
(
"
text
/
xml
"
)
;
const
lastModified
=
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_LAST_MODIFIED
"
"
)
;
if
(
lastModified
)
{
request
.
setRequestHeader
(
"
If
-
Modified
-
Since
"
lastModified
)
;
}
else
{
request
.
setRequestHeader
(
"
Cache
-
Control
"
"
no
-
cache
"
)
;
}
request
.
addEventListener
(
"
error
"
event
=
>
this
.
onXMLError
(
event
)
)
;
request
.
addEventListener
(
"
load
"
event
=
>
this
.
onXMLLoad
(
event
)
)
;
request
.
send
(
null
)
;
}
async
onXMLLoad
(
aEvent
)
{
let
request
=
aEvent
.
target
;
try
{
CertUtils
.
checkCert
(
request
.
channel
)
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
"
+
e
)
;
return
;
}
let
{
status
}
=
request
;
if
(
status
=
=
304
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
up
to
date
.
"
)
;
return
;
}
if
(
status
!
=
200
&
&
status
!
=
0
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
there
was
an
error
during
load
got
status
:
"
+
status
)
;
return
;
}
let
{
responseXML
}
=
request
;
if
(
!
responseXML
|
|
responseXML
.
documentElement
.
namespaceURI
=
=
XMLURI_PARSE_ERROR
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
there
was
an
error
during
load
we
got
invalid
XML
"
)
;
return
;
}
const
lastModified
=
request
.
getResponseHeader
(
"
Last
-
Modified
"
)
|
|
"
"
;
Services
.
prefs
.
setCharPref
(
PREF_BLOCKLIST_LAST_MODIFIED
lastModified
)
;
if
(
!
this
.
isLoaded
)
{
await
this
.
loadBlocklistAsync
(
)
;
}
var
oldAddonEntries
=
this
.
_addonEntries
;
var
oldPluginEntries
=
this
.
_pluginEntries
;
await
this
.
_loadBlocklistFromXML
(
responseXML
)
;
this
.
_blocklistUpdated
(
oldAddonEntries
oldPluginEntries
)
;
try
{
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FILE_BLOCKLIST
)
;
await
OS
.
File
.
writeAtomic
(
path
request
.
responseText
{
tmpPath
:
path
+
"
.
tmp
"
}
)
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
"
+
e
)
;
}
}
onXMLError
(
aEvent
)
{
try
{
var
request
=
aEvent
.
target
;
var
status
=
request
.
status
;
}
catch
(
e
)
{
request
=
aEvent
.
target
.
channel
.
QueryInterface
(
Ci
.
nsIRequest
)
;
status
=
request
.
status
;
}
var
statusText
=
"
XMLHttpRequest
channel
unavailable
"
;
if
(
status
!
=
0
)
{
try
{
statusText
=
request
.
statusText
;
}
catch
(
e
)
{
}
}
LOG
(
"
Blocklist
:
onError
:
There
was
an
error
loading
the
blocklist
file
\
r
\
n
"
+
statusText
)
;
}
get
isLoaded
(
)
{
return
this
.
_addonEntries
!
=
null
&
&
this
.
_gfxEntries
!
=
null
&
&
this
.
_pluginEntries
!
=
null
;
}
_clear
(
)
{
this
.
_addonEntries
=
null
;
this
.
_gfxEntries
=
null
;
this
.
_pluginEntries
=
null
;
delete
this
.
_loadPromise
;
}
async
loadBlocklistAsync
(
)
{
if
(
this
.
isLoaded
)
{
return
;
}
if
(
!
this
.
_loadPromise
)
{
this
.
_loadPromise
=
this
.
_loadBlocklistAsyncInternal
(
)
;
}
await
this
.
_loadPromise
;
}
async
_loadBlocklistAsyncInternal
(
)
{
try
{
let
profFile
=
FileUtils
.
getFile
(
KEY_PROFILEDIR
[
FILE_BLOCKLIST
]
)
;
await
this
.
_loadFileInternal
(
profFile
)
;
return
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
loadBlocklistAsync
:
Failed
to
load
XML
file
"
+
e
)
;
}
var
appFile
=
FileUtils
.
getFile
(
KEY_APPDIR
[
FILE_BLOCKLIST
]
)
;
try
{
await
this
.
_loadFileInternal
(
appFile
)
;
return
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
loadBlocklistAsync
:
Failed
to
load
XML
file
"
+
e
)
;
}
LOG
(
"
Blocklist
:
:
loadBlocklistAsync
:
no
XML
File
found
"
)
;
this
.
_addonEntries
=
[
]
;
this
.
_gfxEntries
=
[
]
;
this
.
_pluginEntries
=
[
]
;
}
async
_loadFileInternal
(
file
)
{
if
(
this
.
isLoaded
)
{
return
;
}
if
(
!
gBlocklistEnabled
)
{
LOG
(
"
Blocklist
:
:
_loadFileInternal
:
blocklist
is
disabled
"
)
;
return
;
}
let
xmlDoc
=
await
new
Promise
(
(
resolve
reject
)
=
>
{
let
request
=
new
XMLHttpRequest
(
)
;
request
.
open
(
"
GET
"
Services
.
io
.
newFileURI
(
file
)
.
spec
true
)
;
request
.
overrideMimeType
(
"
text
/
xml
"
)
;
request
.
addEventListener
(
"
error
"
reject
)
;
request
.
addEventListener
(
"
load
"
function
(
)
{
let
{
status
}
=
request
;
if
(
status
!
=
200
&
&
status
!
=
0
)
{
LOG
(
"
_loadFileInternal
:
there
was
an
error
during
load
got
status
:
"
+
status
)
;
reject
(
new
Error
(
"
Couldn
'
t
load
blocklist
file
"
)
)
;
return
;
}
let
doc
=
request
.
responseXML
;
if
(
doc
.
documentElement
.
namespaceURI
!
=
XMLURI_BLOCKLIST
)
{
LOG
(
"
Blocklist
:
:
_loadBlocklistFromString
:
aborting
due
to
incorrect
"
+
"
XML
Namespace
.
\
nExpected
:
"
+
XMLURI_BLOCKLIST
+
"
\
n
"
+
"
Received
:
"
+
doc
.
documentElement
.
namespaceURI
)
;
reject
(
new
Error
(
"
Local
blocklist
file
has
the
wrong
namespace
!
"
)
)
;
return
;
}
resolve
(
doc
)
;
}
)
;
request
.
send
(
null
)
;
}
)
;
await
new
Promise
(
resolve
=
>
{
ChromeUtils
.
idleDispatch
(
async
(
)
=
>
{
if
(
!
this
.
isLoaded
)
{
await
this
.
_loadBlocklistFromXML
(
xmlDoc
)
;
}
resolve
(
)
;
}
)
;
}
)
;
}
async
_loadBlocklistFromXML
(
doc
)
{
this
.
_addonEntries
=
[
]
;
this
.
_gfxEntries
=
[
]
;
this
.
_pluginEntries
=
[
]
;
try
{
var
children
=
doc
.
documentElement
.
children
;
for
(
let
element
of
children
)
{
switch
(
element
.
localName
)
{
case
"
emItems
"
:
this
.
_addonEntries
=
await
this
.
_processItemNodes
(
element
.
children
"
emItem
"
this
.
_handleEmItemNode
)
;
break
;
case
"
pluginItems
"
:
this
.
_pluginEntries
=
await
this
.
_processItemNodes
(
element
.
children
"
pluginItem
"
this
.
_handlePluginItemNode
)
;
break
;
case
"
gfxItems
"
:
this
.
_gfxEntries
=
await
this
.
_processItemNodes
(
element
.
children
"
gfxBlacklistEntry
"
this
.
_handleGfxBlacklistNode
)
;
break
;
default
:
LOG
(
"
Blocklist
:
:
_loadBlocklistFromXML
:
ignored
entries
"
+
element
.
localName
)
;
}
}
if
(
this
.
_gfxEntries
.
length
>
0
)
{
this
.
_notifyObserversBlocklistGFX
(
)
;
}
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
_loadBlocklistFromXML
:
Error
constructing
blocklist
"
+
e
)
;
}
Services
.
tm
.
dispatchToMainThread
(
function
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
blocklist
-
loaded
"
)
;
}
)
;
}
async
_processItemNodes
(
items
itemName
handler
)
{
var
result
=
[
]
;
let
deadline
=
await
new
Promise
(
ChromeUtils
.
idleDispatch
)
;
for
(
let
item
of
items
)
{
if
(
item
.
localName
=
=
itemName
)
{
handler
(
item
result
)
;
}
if
(
!
deadline
|
|
deadline
.
didTimeout
|
|
deadline
.
timeRemaining
(
)
<
1
)
{
deadline
=
await
new
Promise
(
ChromeUtils
.
idleDispatch
)
;
}
}
return
result
;
}
_handleEmItemNode
(
blocklistElement
result
)
{
if
(
!
matchesOSABI
(
blocklistElement
)
)
return
;
let
blockEntry
=
{
versions
:
[
]
prefs
:
[
]
blockID
:
null
attributes
:
{
}
}
;
for
(
let
filter
of
EXTENSION_BLOCK_FILTERS
)
{
let
attr
=
blocklistElement
.
getAttribute
(
filter
)
;
if
(
attr
)
{
if
(
attr
.
startsWith
(
"
/
"
)
)
{
let
lastSlash
=
attr
.
lastIndexOf
(
"
/
"
)
;
let
pattern
=
attr
.
slice
(
1
lastSlash
)
;
let
flags
=
attr
.
slice
(
lastSlash
+
1
)
;
blockEntry
.
attributes
[
filter
]
=
new
RegExp
(
pattern
flags
)
;
}
else
{
blockEntry
.
attributes
[
filter
]
=
attr
;
}
}
}
var
children
=
blocklistElement
.
children
;
for
(
let
childElement
of
children
)
{
let
localName
=
childElement
.
localName
;
if
(
localName
=
=
"
prefs
"
&
&
childElement
.
hasChildNodes
)
{
let
prefElements
=
childElement
.
children
;
for
(
let
prefElement
of
prefElements
)
{
if
(
prefElement
.
localName
=
=
"
pref
"
)
{
blockEntry
.
prefs
.
push
(
prefElement
.
textContent
)
;
}
}
}
else
if
(
localName
=
=
"
versionRange
"
)
{
blockEntry
.
versions
.
push
(
new
BlocklistItemData
(
childElement
)
)
;
}
}
if
(
blockEntry
.
versions
.
length
=
=
0
)
blockEntry
.
versions
.
push
(
new
BlocklistItemData
(
null
)
)
;
blockEntry
.
blockID
=
blocklistElement
.
getAttribute
(
"
blockID
"
)
;
result
.
push
(
blockEntry
)
;
}
_handlePluginItemNode
(
blocklistElement
result
)
{
if
(
!
matchesOSABI
(
blocklistElement
)
)
return
;
let
children
=
blocklistElement
.
children
;
var
blockEntry
=
{
matches
:
{
}
versions
:
[
]
blockID
:
null
infoURL
:
null
}
;
var
hasMatch
=
false
;
for
(
let
childElement
of
children
)
{
switch
(
childElement
.
localName
)
{
case
"
match
"
:
var
name
=
childElement
.
getAttribute
(
"
name
"
)
;
var
exp
=
childElement
.
getAttribute
(
"
exp
"
)
;
try
{
blockEntry
.
matches
[
name
]
=
new
RegExp
(
exp
"
m
"
)
;
hasMatch
=
true
;
}
catch
(
e
)
{
}
break
;
case
"
versionRange
"
:
blockEntry
.
versions
.
push
(
new
BlocklistItemData
(
childElement
)
)
;
break
;
case
"
infoURL
"
:
blockEntry
.
infoURL
=
childElement
.
textContent
;
break
;
}
}
if
(
!
hasMatch
)
return
;
if
(
blockEntry
.
versions
.
length
=
=
0
)
blockEntry
.
versions
.
push
(
new
BlocklistItemData
(
null
)
)
;
blockEntry
.
blockID
=
blocklistElement
.
getAttribute
(
"
blockID
"
)
;
result
.
push
(
blockEntry
)
;
}
_handleGfxBlacklistNode
(
blocklistElement
result
)
{
const
blockEntry
=
{
}
;
if
(
blocklistElement
.
hasAttribute
(
"
blockID
"
)
)
{
blockEntry
.
blockID
=
blocklistElement
.
getAttribute
(
"
blockID
"
)
;
}
for
(
let
matchElement
of
blocklistElement
.
children
)
{
let
value
;
if
(
matchElement
.
localName
=
=
"
devices
"
)
{
value
=
[
]
;
for
(
let
childElement
of
matchElement
.
children
)
{
const
childValue
=
(
childElement
.
textContent
|
|
"
"
)
.
trim
(
)
;
if
(
childValue
)
{
if
(
/
/
.
test
(
childValue
)
)
{
const
e
=
new
Error
(
Unsupported
device
name
{
childValue
}
)
;
Cu
.
reportError
(
e
)
;
}
else
{
value
.
push
(
childValue
)
;
}
}
}
}
else
if
(
matchElement
.
localName
=
=
"
versionRange
"
)
{
value
=
{
minVersion
:
(
matchElement
.
getAttribute
(
"
minVersion
"
)
|
|
"
"
)
.
trim
(
)
|
|
"
0
"
maxVersion
:
(
matchElement
.
getAttribute
(
"
maxVersion
"
)
|
|
"
"
)
.
trim
(
)
|
|
"
*
"
}
;
}
else
{
value
=
(
matchElement
.
textContent
|
|
"
"
)
.
trim
(
)
;
}
if
(
value
)
{
blockEntry
[
matchElement
.
localName
]
=
value
;
}
}
result
.
push
(
blockEntry
)
;
}
async
getPluginBlocklistState
(
plugin
appVersion
toolkitVersion
)
{
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
await
this
.
loadBlocklistAsync
(
)
;
return
this
.
_getPluginBlocklistState
(
plugin
this
.
_pluginEntries
appVersion
toolkitVersion
)
;
}
_getPluginBlocklistEntry
(
plugin
pluginEntries
appVersion
toolkitVersion
)
{
if
(
!
gBlocklistEnabled
)
return
null
;
if
(
!
appVersion
&
&
!
gAppVersion
)
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
if
(
!
appVersion
)
appVersion
=
gAppVersion
;
if
(
!
toolkitVersion
)
toolkitVersion
=
gApp
.
platformVersion
;
const
pluginProperties
=
{
description
:
plugin
.
description
filename
:
plugin
.
filename
name
:
plugin
.
name
version
:
plugin
.
version
}
;
for
(
var
blockEntry
of
pluginEntries
)
{
var
matchFailed
=
false
;
for
(
var
name
in
blockEntry
.
matches
)
{
let
pluginProperty
=
pluginProperties
[
name
]
;
if
(
typeof
(
pluginProperty
)
!
=
=
"
string
"
|
|
!
blockEntry
.
matches
[
name
]
.
test
(
pluginProperty
)
)
{
matchFailed
=
true
;
break
;
}
}
if
(
matchFailed
)
continue
;
for
(
let
blockEntryVersion
of
blockEntry
.
versions
)
{
if
(
blockEntryVersion
.
includesItem
(
pluginProperties
.
version
appVersion
toolkitVersion
)
)
{
return
{
entry
:
blockEntry
version
:
blockEntryVersion
}
;
}
}
}
return
null
;
}
_getPluginBlocklistState
(
plugin
pluginEntries
appVersion
toolkitVersion
)
{
let
r
=
this
.
_getPluginBlocklistEntry
(
plugin
pluginEntries
appVersion
toolkitVersion
)
;
if
(
!
r
)
{
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
let
{
version
:
blockEntryVersion
}
=
r
;
if
(
blockEntryVersion
.
severity
>
=
gBlocklistLevel
)
return
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
;
if
(
blockEntryVersion
.
severity
=
=
SEVERITY_OUTDATED
)
{
let
vulnerabilityStatus
=
blockEntryVersion
.
vulnerabilityStatus
;
if
(
vulnerabilityStatus
=
=
VULNERABILITYSTATUS_UPDATE_AVAILABLE
)
return
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_UPDATE_AVAILABLE
;
if
(
vulnerabilityStatus
=
=
VULNERABILITYSTATUS_NO_UPDATE
)
return
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_NO_UPDATE
;
return
Ci
.
nsIBlocklistService
.
STATE_OUTDATED
;
}
return
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
;
}
async
getPluginBlockURL
(
plugin
)
{
await
this
.
loadBlocklistAsync
(
)
;
let
r
=
this
.
_getPluginBlocklistEntry
(
plugin
this
.
_pluginEntries
)
;
if
(
!
r
)
{
return
null
;
}
let
blockEntry
=
r
.
entry
;
if
(
!
blockEntry
.
blockID
)
{
return
null
;
}
return
blockEntry
.
infoURL
|
|
this
.
_createBlocklistURL
(
blockEntry
.
blockID
)
;
}
_notifyObserversBlocklistGFX
(
)
{
let
sortedProps
=
[
"
blockID
"
"
devices
"
"
driverVersion
"
"
driverVersionComparator
"
"
driverVersionMax
"
"
feature
"
"
featureStatus
"
"
hardware
"
"
manufacturer
"
"
model
"
"
os
"
"
osversion
"
"
product
"
"
vendor
"
"
versionRange
"
]
;
let
payload
=
[
]
;
for
(
let
gfxEntry
of
this
.
_gfxEntries
)
{
let
entryLines
=
[
]
;
for
(
let
key
of
sortedProps
)
{
if
(
gfxEntry
[
key
]
)
{
let
value
=
gfxEntry
[
key
]
;
if
(
Array
.
isArray
(
value
)
)
{
value
=
value
.
join
(
"
"
)
;
}
else
if
(
value
.
maxVersion
)
{
value
=
value
.
minVersion
+
"
"
+
value
.
maxVersion
;
}
entryLines
.
push
(
key
+
"
:
"
+
value
)
;
}
}
payload
.
push
(
entryLines
.
join
(
"
\
t
"
)
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
blocklist
-
data
-
gfxItems
"
payload
.
join
(
"
\
n
"
)
)
;
}
_notifyObserversBlocklistUpdated
(
)
{
Services
.
obs
.
notifyObservers
(
this
"
blocklist
-
updated
"
)
;
}
async
_blocklistUpdated
(
oldAddonEntries
oldPluginEntries
)
{
var
addonList
=
[
]
;
function
resetPrefs
(
prefs
)
{
for
(
let
pref
of
prefs
)
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
const
types
=
[
"
extension
"
"
theme
"
"
locale
"
"
dictionary
"
"
service
"
]
;
let
addons
=
await
AddonManager
.
getAddonsByTypes
(
types
)
;
for
(
let
addon
of
addons
)
{
let
oldState
=
addon
.
blocklistState
;
if
(
addon
.
updateBlocklistState
)
{
await
addon
.
updateBlocklistState
(
false
)
;
}
else
if
(
oldAddonEntries
)
{
oldState
=
this
.
_getAddonBlocklistState
(
addon
oldAddonEntries
)
;
}
else
{
oldState
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
let
state
=
addon
.
blocklistState
;
LOG
(
"
Blocklist
state
for
"
+
addon
.
id
+
"
changed
from
"
+
oldState
+
"
to
"
+
state
)
;
if
(
state
=
=
oldState
)
continue
;
if
(
state
=
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
let
prefs
=
this
.
_getAddonPrefs
(
addon
)
;
resetPrefs
(
prefs
)
;
}
if
(
state
!
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
addon
.
softDisabled
=
false
;
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
continue
;
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
&
&
oldState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
addon
.
softDisabled
=
true
;
continue
;
}
if
(
!
addon
.
isActive
)
{
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
&
&
!
addon
.
userDisabled
)
addon
.
softDisabled
=
true
;
continue
;
}
let
entry
=
this
.
_getAddonBlocklistEntry
(
addon
this
.
_addonEntries
)
;
addonList
.
push
(
{
name
:
addon
.
name
version
:
addon
.
version
icon
:
addon
.
iconURL
disable
:
false
blocked
:
state
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
item
:
addon
url
:
entry
&
&
entry
.
url
}
)
;
}
AddonManagerPrivate
.
updateAddonAppDisabledStates
(
)
;
var
phs
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
var
plugins
=
phs
.
getPluginTags
(
)
;
for
(
let
plugin
of
plugins
)
{
let
oldState
=
-
1
;
if
(
oldPluginEntries
)
oldState
=
this
.
_getPluginBlocklistState
(
plugin
oldPluginEntries
)
;
let
state
=
this
.
_getPluginBlocklistState
(
plugin
this
.
_pluginEntries
)
;
LOG
(
"
Blocklist
state
for
"
+
plugin
.
name
+
"
changed
from
"
+
oldState
+
"
to
"
+
state
)
;
if
(
state
=
=
oldState
)
continue
;
if
(
oldState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
plugin
.
enabledState
=
Ci
.
nsIPluginTag
.
STATE_DISABLED
;
}
else
if
(
!
plugin
.
disabled
&
&
state
!
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
{
if
(
state
!
=
Ci
.
nsIBlocklistService
.
STATE_OUTDATED
&
&
state
!
=
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_UPDATE_AVAILABLE
&
&
state
!
=
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_NO_UPDATE
)
{
addonList
.
push
(
{
name
:
plugin
.
name
version
:
plugin
.
version
icon
:
"
chrome
:
/
/
mozapps
/
skin
/
plugins
/
pluginGeneric
.
svg
"
disable
:
false
blocked
:
state
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
item
:
plugin
url
:
await
this
.
getPluginBlockURL
(
plugin
)
}
)
;
}
}
}
if
(
addonList
.
length
=
=
0
)
{
this
.
_notifyObserversBlocklistUpdated
(
)
;
return
;
}
if
(
"
mozilla
.
org
/
addons
/
blocklist
-
prompt
;
1
"
in
Cc
)
{
try
{
let
blockedPrompter
=
Cc
[
"
mozilla
.
org
/
addons
/
blocklist
-
prompt
;
1
"
]
.
getService
(
)
.
wrappedJSObject
;
blockedPrompter
.
prompt
(
addonList
)
;
}
catch
(
e
)
{
LOG
(
e
)
;
}
this
.
_notifyObserversBlocklistUpdated
(
)
;
return
;
}
var
args
=
{
restart
:
false
list
:
addonList
}
;
args
.
wrappedJSObject
=
args
;
let
applyBlocklistChanges
=
(
)
=
>
{
for
(
let
addon
of
addonList
)
{
if
(
!
addon
.
disable
)
continue
;
if
(
addon
.
item
instanceof
Ci
.
nsIPluginTag
)
addon
.
item
.
enabledState
=
Ci
.
nsIPluginTag
.
STATE_DISABLED
;
else
{
addon
.
item
.
softDisabled
=
true
;
let
prefs
=
this
.
_getAddonPrefs
(
addon
.
item
)
;
resetPrefs
(
prefs
)
;
}
}
if
(
args
.
restart
)
restartApp
(
)
;
this
.
_notifyObserversBlocklistUpdated
(
)
;
Services
.
obs
.
removeObserver
(
applyBlocklistChanges
"
addon
-
blocklist
-
closed
"
)
;
}
;
Services
.
obs
.
addObserver
(
applyBlocklistChanges
"
addon
-
blocklist
-
closed
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_SUPPRESSUI
false
)
)
{
applyBlocklistChanges
(
)
;
return
;
}
function
blocklistUnloadHandler
(
event
)
{
if
(
event
.
target
.
location
=
=
URI_BLOCKLIST_DIALOG
)
{
applyBlocklistChanges
(
)
;
blocklistWindow
.
removeEventListener
(
"
unload
"
blocklistUnloadHandler
)
;
}
}
let
blocklistWindow
=
Services
.
ww
.
openWindow
(
null
URI_BLOCKLIST_DIALOG
"
"
"
chrome
centerscreen
dialog
titlebar
"
args
)
;
if
(
blocklistWindow
)
blocklistWindow
.
addEventListener
(
"
unload
"
blocklistUnloadHandler
)
;
}
}
;
function
BlocklistItemData
(
versionRangeElement
)
{
this
.
targetApps
=
{
}
;
let
foundTarget
=
false
;
this
.
severity
=
DEFAULT_SEVERITY
;
this
.
vulnerabilityStatus
=
VULNERABILITYSTATUS_NONE
;
if
(
versionRangeElement
)
{
let
versionRange
=
this
.
getBlocklistVersionRange
(
versionRangeElement
)
;
this
.
minVersion
=
versionRange
.
minVersion
;
this
.
maxVersion
=
versionRange
.
maxVersion
;
if
(
versionRangeElement
.
hasAttribute
(
"
severity
"
)
)
this
.
severity
=
versionRangeElement
.
getAttribute
(
"
severity
"
)
;
if
(
versionRangeElement
.
hasAttribute
(
"
vulnerabilitystatus
"
)
)
{
this
.
vulnerabilityStatus
=
versionRangeElement
.
getAttribute
(
"
vulnerabilitystatus
"
)
;
}
for
(
let
targetAppElement
of
versionRangeElement
.
children
)
{
if
(
targetAppElement
.
localName
=
=
"
targetApplication
"
)
{
foundTarget
=
true
;
let
appID
=
targetAppElement
.
id
|
|
gAppID
;
this
.
targetApps
[
appID
]
=
this
.
getBlocklistAppVersions
(
targetAppElement
)
;
}
}
}
else
{
this
.
minVersion
=
this
.
maxVersion
=
null
;
}
if
(
!
foundTarget
)
this
.
targetApps
[
gAppID
]
=
[
{
minVersion
:
null
maxVersion
:
null
}
]
;
}
BlocklistItemData
.
prototype
=
{
includesItem
(
version
appVersion
toolkitVersion
)
{
if
(
!
version
&
&
(
this
.
minVersion
|
|
this
.
maxVersion
)
)
return
false
;
if
(
!
this
.
matchesRange
(
version
this
.
minVersion
this
.
maxVersion
)
)
return
false
;
if
(
this
.
matchesTargetRange
(
gAppID
appVersion
)
)
return
true
;
return
this
.
matchesTargetRange
(
TOOLKIT_ID
toolkitVersion
)
;
}
matchesRange
(
version
minVersion
maxVersion
)
{
if
(
minVersion
&
&
Services
.
vc
.
compare
(
version
minVersion
)
<
0
)
return
false
;
if
(
maxVersion
&
&
Services
.
vc
.
compare
(
version
maxVersion
)
>
0
)
return
false
;
return
true
;
}
matchesTargetRange
(
appID
appVersion
)
{
var
blTargetApp
=
this
.
targetApps
[
appID
]
;
if
(
!
blTargetApp
)
return
false
;
for
(
let
app
of
blTargetApp
)
{
if
(
this
.
matchesRange
(
appVersion
app
.
minVersion
app
.
maxVersion
)
)
return
true
;
}
return
false
;
}
getBlocklistAppVersions
(
targetAppElement
)
{
var
appVersions
=
[
]
;
if
(
targetAppElement
)
{
for
(
let
versionRangeElement
of
targetAppElement
.
children
)
{
if
(
versionRangeElement
.
localName
=
=
"
versionRange
"
)
{
appVersions
.
push
(
this
.
getBlocklistVersionRange
(
versionRangeElement
)
)
;
}
}
}
if
(
appVersions
.
length
=
=
0
)
appVersions
.
push
(
{
minVersion
:
null
maxVersion
:
null
}
)
;
return
appVersions
;
}
getBlocklistVersionRange
(
versionRangeElement
)
{
let
minVersion
=
versionRangeElement
.
getAttribute
(
"
minVersion
"
)
;
let
maxVersion
=
versionRangeElement
.
getAttribute
(
"
maxVersion
"
)
;
return
{
minVersion
maxVersion
}
;
}
}
;
Blocklist
.
_init
(
)
;
