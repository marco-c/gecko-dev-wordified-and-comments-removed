"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
try
{
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
}
catch
(
e
)
{
}
ChromeUtils
.
defineModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ServiceRequest
"
"
resource
:
/
/
gre
/
modules
/
ServiceRequest
.
jsm
"
)
;
const
BlocklistClients
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
blocklist
-
clients
.
js
"
{
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
RemoteSettings
"
function
(
)
{
BlocklistClients
.
initialize
(
)
;
return
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
remote
-
settings
.
js
"
{
}
)
;
}
)
;
const
TOOLKIT_ID
=
"
toolkit
mozilla
.
org
"
;
const
KEY_PROFILEDIR
=
"
ProfD
"
;
const
KEY_APPDIR
=
"
XCurProcD
"
;
const
FILE_BLOCKLIST
=
"
blocklist
.
xml
"
;
const
PREF_BLOCKLIST_LASTUPDATETIME
=
"
app
.
update
.
lastUpdateTime
.
blocklist
-
background
-
update
-
timer
"
;
const
PREF_BLOCKLIST_URL
=
"
extensions
.
blocklist
.
url
"
;
const
PREF_BLOCKLIST_ITEM_URL
=
"
extensions
.
blocklist
.
itemURL
"
;
const
PREF_BLOCKLIST_ENABLED
=
"
extensions
.
blocklist
.
enabled
"
;
const
PREF_BLOCKLIST_LAST_MODIFIED
=
"
extensions
.
blocklist
.
lastModified
"
;
const
PREF_BLOCKLIST_LEVEL
=
"
extensions
.
blocklist
.
level
"
;
const
PREF_BLOCKLIST_PINGCOUNTTOTAL
=
"
extensions
.
blocklist
.
pingCountTotal
"
;
const
PREF_BLOCKLIST_PINGCOUNTVERSION
=
"
extensions
.
blocklist
.
pingCountVersion
"
;
const
PREF_BLOCKLIST_SUPPRESSUI
=
"
extensions
.
blocklist
.
suppressUI
"
;
const
PREF_BLOCKLIST_UPDATE_ENABLED
=
"
services
.
blocklist
.
update_enabled
"
;
const
PREF_APP_DISTRIBUTION
=
"
distribution
.
id
"
;
const
PREF_APP_DISTRIBUTION_VERSION
=
"
distribution
.
version
"
;
const
PREF_EM_LOGGING_ENABLED
=
"
extensions
.
logging
.
enabled
"
;
const
XMLURI_BLOCKLIST
=
"
http
:
/
/
www
.
mozilla
.
org
/
2006
/
addons
-
blocklist
"
;
const
XMLURI_PARSE_ERROR
=
"
http
:
/
/
www
.
mozilla
.
org
/
newlayout
/
xml
/
parsererror
.
xml
"
;
const
URI_BLOCKLIST_DIALOG
=
"
chrome
:
/
/
mozapps
/
content
/
extensions
/
blocklist
.
xul
"
;
const
DEFAULT_SEVERITY
=
3
;
const
DEFAULT_LEVEL
=
2
;
const
MAX_BLOCK_LEVEL
=
3
;
const
SEVERITY_OUTDATED
=
0
;
const
VULNERABILITYSTATUS_NONE
=
0
;
const
VULNERABILITYSTATUS_UPDATE_AVAILABLE
=
1
;
const
VULNERABILITYSTATUS_NO_UPDATE
=
2
;
const
EXTENSION_BLOCK_FILTERS
=
[
"
id
"
"
name
"
"
creator
"
"
homepageURL
"
"
updateURL
"
]
;
var
gLoggingEnabled
=
null
;
var
gBlocklistEnabled
=
true
;
var
gBlocklistLevel
=
DEFAULT_LEVEL
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gApp
"
function
(
)
{
let
appinfo
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
try
{
appinfo
.
QueryInterface
(
Ci
.
nsIXULAppInfo
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Components
.
Exception
)
|
|
ex
.
result
!
=
Cr
.
NS_NOINTERFACE
)
throw
ex
;
}
return
appinfo
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gABI
"
function
(
)
{
let
abi
=
null
;
try
{
abi
=
gApp
.
XPCOMABI
;
}
catch
(
e
)
{
LOG
(
"
BlockList
Global
gABI
:
XPCOM
ABI
unknown
.
"
)
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
macutils
=
Cc
[
"
mozilla
.
org
/
xpcom
/
mac
-
utils
;
1
"
]
.
getService
(
Ci
.
nsIMacUtils
)
;
if
(
macutils
.
isUniversalBinary
)
abi
+
=
"
-
u
-
"
+
macutils
.
architecturesInBinary
;
}
return
abi
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gOSVersion
"
function
(
)
{
let
osVersion
;
try
{
osVersion
=
Services
.
sysinfo
.
getProperty
(
"
name
"
)
+
"
"
+
Services
.
sysinfo
.
getProperty
(
"
version
"
)
;
}
catch
(
e
)
{
LOG
(
"
BlockList
Global
gOSVersion
:
OS
Version
unknown
.
"
)
;
}
if
(
osVersion
)
{
try
{
osVersion
+
=
"
(
"
+
Services
.
sysinfo
.
getProperty
(
"
secondaryLibrary
"
)
+
"
)
"
;
}
catch
(
e
)
{
}
osVersion
=
encodeURIComponent
(
osVersion
)
;
}
return
osVersion
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gCertUtils
"
function
(
)
{
let
temp
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
CertUtils
.
jsm
"
temp
)
;
return
temp
;
}
)
;
function
LOG
(
string
)
{
if
(
gLoggingEnabled
)
{
dump
(
"
*
*
*
"
+
string
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
string
)
;
}
}
function
restartApp
(
)
{
var
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
)
;
if
(
cancelQuit
.
data
)
return
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eRestart
|
Ci
.
nsIAppStartup
.
eAttemptQuit
)
;
}
function
matchesOSABI
(
blocklistElement
)
{
if
(
blocklistElement
.
hasAttribute
(
"
os
"
)
)
{
var
choices
=
blocklistElement
.
getAttribute
(
"
os
"
)
.
split
(
"
"
)
;
if
(
choices
.
length
>
0
&
&
!
choices
.
includes
(
gApp
.
OS
)
)
return
false
;
}
if
(
blocklistElement
.
hasAttribute
(
"
xpcomabi
"
)
)
{
choices
=
blocklistElement
.
getAttribute
(
"
xpcomabi
"
)
.
split
(
"
"
)
;
if
(
choices
.
length
>
0
&
&
!
choices
.
includes
(
gApp
.
XPCOMABI
)
)
return
false
;
}
return
true
;
}
function
getLocale
(
)
{
return
Services
.
locale
.
getRequestedLocale
(
)
;
}
function
getDistributionPrefValue
(
aPrefName
)
{
return
Services
.
prefs
.
getDefaultBranch
(
null
)
.
getCharPref
(
aPrefName
"
default
"
)
;
}
function
parseRegExp
(
aStr
)
{
let
lastSlash
=
aStr
.
lastIndexOf
(
"
/
"
)
;
let
pattern
=
aStr
.
slice
(
1
lastSlash
)
;
let
flags
=
aStr
.
slice
(
lastSlash
+
1
)
;
return
new
RegExp
(
pattern
flags
)
;
}
function
Blocklist
(
)
{
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
)
;
gLoggingEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_LOGGING_ENABLED
false
)
;
gBlocklistEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_ENABLED
true
)
;
gBlocklistLevel
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_LEVEL
DEFAULT_LEVEL
)
MAX_BLOCK_LEVEL
)
;
Services
.
prefs
.
addObserver
(
"
extensions
.
blocklist
.
"
this
)
;
Services
.
prefs
.
addObserver
(
PREF_EM_LOGGING_ENABLED
this
)
;
this
.
wrappedJSObject
=
this
;
}
Blocklist
.
prototype
=
{
_addonEntries
:
null
_gfxEntries
:
null
_pluginEntries
:
null
shutdown
(
)
{
Services
.
obs
.
removeObserver
(
this
"
xpcom
-
shutdown
"
)
;
Services
.
prefs
.
removeObserver
(
"
extensions
.
blocklist
.
"
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_EM_LOGGING_ENABLED
this
)
;
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
xpcom
-
shutdown
"
:
this
.
shutdown
(
)
;
break
;
case
"
profile
-
after
-
change
"
:
this
.
loadBlocklistAsync
(
)
;
break
;
case
"
nsPref
:
changed
"
:
switch
(
aData
)
{
case
PREF_EM_LOGGING_ENABLED
:
gLoggingEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_LOGGING_ENABLED
false
)
;
break
;
case
PREF_BLOCKLIST_ENABLED
:
gBlocklistEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_ENABLED
true
)
;
this
.
_loadBlocklist
(
)
;
this
.
_blocklistUpdated
(
null
null
)
;
break
;
case
PREF_BLOCKLIST_LEVEL
:
gBlocklistLevel
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_LEVEL
DEFAULT_LEVEL
)
MAX_BLOCK_LEVEL
)
;
this
.
_blocklistUpdated
(
null
null
)
;
break
;
}
break
;
}
}
getAddonBlocklistState
(
addon
appVersion
toolkitVersion
)
{
if
(
!
this
.
isLoaded
)
this
.
_loadBlocklist
(
)
;
return
this
.
_getAddonBlocklistState
(
addon
this
.
_addonEntries
appVersion
toolkitVersion
)
;
}
_getAddonBlocklistEntry
(
addon
addonEntries
appVersion
toolkitVersion
)
{
if
(
!
gBlocklistEnabled
)
return
null
;
if
(
!
appVersion
&
&
!
gApp
.
version
)
return
null
;
if
(
!
appVersion
)
appVersion
=
gApp
.
version
;
if
(
!
toolkitVersion
)
toolkitVersion
=
gApp
.
platformVersion
;
var
blItem
=
this
.
_findMatchingAddonEntry
(
addonEntries
addon
)
;
if
(
!
blItem
)
return
null
;
for
(
let
currentblItem
of
blItem
.
versions
)
{
if
(
currentblItem
.
includesItem
(
addon
.
version
appVersion
toolkitVersion
)
)
{
return
{
state
:
(
currentblItem
.
severity
>
=
gBlocklistLevel
?
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
:
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
url
:
blItem
.
blockID
&
&
this
.
_createBlocklistURL
(
blItem
.
blockID
)
}
;
}
}
return
null
;
}
getAddonBlocklistEntry
(
addon
appVersion
toolkitVersion
)
{
if
(
!
this
.
isLoaded
)
this
.
_loadBlocklist
(
)
;
return
this
.
_getAddonBlocklistEntry
(
addon
this
.
_addonEntries
appVersion
toolkitVersion
)
;
}
_getAddonBlocklistState
(
addon
addonEntries
appVersion
toolkitVersion
)
{
let
entry
=
this
.
_getAddonBlocklistEntry
(
addon
addonEntries
appVersion
toolkitVersion
)
;
if
(
entry
)
return
entry
.
state
;
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
_getAddonPrefs
(
addon
)
{
let
entry
=
this
.
_findMatchingAddonEntry
(
this
.
_addonEntries
addon
)
;
return
entry
.
prefs
.
slice
(
0
)
;
}
_findMatchingAddonEntry
(
aAddonEntries
aAddon
)
{
if
(
!
aAddon
)
return
null
;
function
checkEntry
(
entry
params
)
{
for
(
let
[
key
value
]
of
entry
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
continue
;
if
(
params
[
key
]
)
{
if
(
value
instanceof
RegExp
)
{
if
(
!
value
.
test
(
params
[
key
]
)
)
{
return
false
;
}
}
else
if
(
value
!
=
=
params
[
key
]
)
{
return
false
;
}
}
else
{
return
false
;
}
}
return
true
;
}
let
params
=
{
}
;
for
(
let
filter
of
EXTENSION_BLOCK_FILTERS
)
{
params
[
filter
]
=
aAddon
[
filter
]
;
}
if
(
params
.
creator
)
params
.
creator
=
params
.
creator
.
name
;
for
(
let
entry
of
aAddonEntries
)
{
if
(
checkEntry
(
entry
.
attributes
params
)
)
{
return
entry
;
}
}
return
null
;
}
getAddonBlocklistURL
(
addon
appVersion
toolkitVersion
)
{
if
(
!
this
.
isLoaded
)
this
.
_loadBlocklist
(
)
;
let
entry
=
this
.
_getAddonBlocklistEntry
(
addon
this
.
_addonEntries
)
;
return
entry
&
&
entry
.
url
;
}
_createBlocklistURL
(
id
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_BLOCKLIST_ITEM_URL
)
;
url
=
url
.
replace
(
/
%
blockID
%
/
g
id
)
;
return
url
;
}
notify
(
aTimer
)
{
if
(
!
gBlocklistEnabled
)
return
;
try
{
var
dsURI
=
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_URL
)
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
notify
:
The
"
+
PREF_BLOCKLIST_URL
+
"
preference
"
+
"
is
missing
!
"
)
;
return
;
}
var
pingCountVersion
=
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_PINGCOUNTVERSION
0
)
;
var
pingCountTotal
=
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_PINGCOUNTTOTAL
1
)
;
var
daysSinceLastPing
=
0
;
if
(
pingCountVersion
=
=
0
)
{
daysSinceLastPing
=
"
new
"
;
}
else
{
let
secondsInDay
=
60
*
60
*
24
;
let
lastUpdateTime
=
Services
.
prefs
.
getIntPref
(
PREF_BLOCKLIST_LASTUPDATETIME
0
)
;
if
(
lastUpdateTime
=
=
0
)
{
daysSinceLastPing
=
"
invalid
"
;
}
else
{
let
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
daysSinceLastPing
=
Math
.
floor
(
(
now
-
lastUpdateTime
)
/
secondsInDay
)
;
}
if
(
daysSinceLastPing
=
=
0
|
|
daysSinceLastPing
=
=
"
invalid
"
)
{
pingCountVersion
=
pingCountTotal
=
"
invalid
"
;
}
}
if
(
pingCountVersion
<
1
)
pingCountVersion
=
1
;
if
(
pingCountTotal
<
1
)
pingCountTotal
=
1
;
dsURI
=
dsURI
.
replace
(
/
%
APP_ID
%
/
g
gApp
.
ID
)
;
if
(
gApp
.
version
)
dsURI
=
dsURI
.
replace
(
/
%
APP_VERSION
%
/
g
gApp
.
version
)
;
dsURI
=
dsURI
.
replace
(
/
%
PRODUCT
%
/
g
gApp
.
name
)
;
if
(
gApp
.
version
)
dsURI
=
dsURI
.
replace
(
/
%
VERSION
%
/
g
gApp
.
version
)
;
dsURI
=
dsURI
.
replace
(
/
%
BUILD_ID
%
/
g
gApp
.
appBuildID
)
;
dsURI
=
dsURI
.
replace
(
/
%
BUILD_TARGET
%
/
g
gApp
.
OS
+
"
_
"
+
gABI
)
;
dsURI
=
dsURI
.
replace
(
/
%
OS_VERSION
%
/
g
gOSVersion
)
;
dsURI
=
dsURI
.
replace
(
/
%
LOCALE
%
/
g
getLocale
(
)
)
;
dsURI
=
dsURI
.
replace
(
/
%
CHANNEL
%
/
g
UpdateUtils
.
UpdateChannel
)
;
dsURI
=
dsURI
.
replace
(
/
%
PLATFORM_VERSION
%
/
g
gApp
.
platformVersion
)
;
dsURI
=
dsURI
.
replace
(
/
%
DISTRIBUTION
%
/
g
getDistributionPrefValue
(
PREF_APP_DISTRIBUTION
)
)
;
dsURI
=
dsURI
.
replace
(
/
%
DISTRIBUTION_VERSION
%
/
g
getDistributionPrefValue
(
PREF_APP_DISTRIBUTION_VERSION
)
)
;
dsURI
=
dsURI
.
replace
(
/
%
PING_COUNT
%
/
g
pingCountVersion
)
;
dsURI
=
dsURI
.
replace
(
/
%
TOTAL_PING_COUNT
%
/
g
pingCountTotal
)
;
dsURI
=
dsURI
.
replace
(
/
%
DAYS_SINCE_LAST_PING
%
/
g
daysSinceLastPing
)
;
dsURI
=
dsURI
.
replace
(
/
\
+
/
g
"
%
2B
"
)
;
if
(
pingCountVersion
!
=
"
invalid
"
)
{
pingCountVersion
+
+
;
if
(
pingCountVersion
>
2147483647
)
{
pingCountVersion
=
-
1
;
}
Services
.
prefs
.
setIntPref
(
PREF_BLOCKLIST_PINGCOUNTVERSION
pingCountVersion
)
;
}
if
(
pingCountTotal
!
=
"
invalid
"
)
{
pingCountTotal
+
+
;
if
(
pingCountTotal
>
2147483647
)
{
pingCountTotal
=
-
1
;
}
Services
.
prefs
.
setIntPref
(
PREF_BLOCKLIST_PINGCOUNTTOTAL
pingCountTotal
)
;
}
try
{
var
uri
=
Services
.
io
.
newURI
(
dsURI
)
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
notify
:
There
was
an
error
creating
the
blocklist
URI
\
r
\
n
"
+
"
for
:
"
+
dsURI
+
"
error
:
"
+
e
)
;
return
;
}
LOG
(
"
Blocklist
:
:
notify
:
Requesting
"
+
uri
.
spec
)
;
let
request
=
new
ServiceRequest
(
)
;
request
.
open
(
"
GET
"
uri
.
spec
true
)
;
request
.
channel
.
notificationCallbacks
=
new
gCertUtils
.
BadCertHandler
(
)
;
request
.
overrideMimeType
(
"
text
/
xml
"
)
;
const
lastModified
=
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_LAST_MODIFIED
"
"
)
;
if
(
lastModified
)
{
request
.
setRequestHeader
(
"
If
-
Modified
-
Since
"
lastModified
)
;
}
else
{
request
.
setRequestHeader
(
"
Cache
-
Control
"
"
no
-
cache
"
)
;
}
request
.
addEventListener
(
"
error
"
event
=
>
this
.
onXMLError
(
event
)
)
;
request
.
addEventListener
(
"
load
"
event
=
>
this
.
onXMLLoad
(
event
)
)
;
request
.
send
(
null
)
;
if
(
!
this
.
isLoaded
)
this
.
_loadBlocklist
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_UPDATE_ENABLED
)
)
{
RemoteSettings
.
pollChanges
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
}
async
onXMLLoad
(
aEvent
)
{
let
request
=
aEvent
.
target
;
try
{
gCertUtils
.
checkCert
(
request
.
channel
)
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
"
+
e
)
;
return
;
}
let
{
status
}
=
request
;
if
(
status
=
=
304
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
up
to
date
.
"
)
;
return
;
}
if
(
status
!
=
200
&
&
status
!
=
0
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
there
was
an
error
during
load
got
status
:
"
+
status
)
;
return
;
}
let
{
responseXML
}
=
request
;
if
(
!
responseXML
|
|
responseXML
.
documentElement
.
namespaceURI
=
=
XMLURI_PARSE_ERROR
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
there
was
an
error
during
load
we
got
invalid
XML
"
)
;
return
;
}
const
lastModified
=
request
.
getResponseHeader
(
"
Last
-
Modified
"
)
|
|
"
"
;
Services
.
prefs
.
setCharPref
(
PREF_BLOCKLIST_LAST_MODIFIED
lastModified
)
;
var
oldAddonEntries
=
this
.
_addonEntries
;
var
oldPluginEntries
=
this
.
_pluginEntries
;
this
.
_loadBlocklistFromXML
(
responseXML
)
;
this
.
_blocklistUpdated
(
oldAddonEntries
oldPluginEntries
)
;
try
{
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FILE_BLOCKLIST
)
;
await
OS
.
File
.
writeAtomic
(
path
request
.
responseText
{
tmpPath
:
path
+
"
.
tmp
"
}
)
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
onXMLLoad
:
"
+
e
)
;
}
}
onXMLError
(
aEvent
)
{
try
{
var
request
=
aEvent
.
target
;
var
status
=
request
.
status
;
}
catch
(
e
)
{
request
=
aEvent
.
target
.
channel
.
QueryInterface
(
Ci
.
nsIRequest
)
;
status
=
request
.
status
;
}
var
statusText
=
"
XMLHttpRequest
channel
unavailable
"
;
if
(
status
!
=
0
)
{
try
{
statusText
=
request
.
statusText
;
}
catch
(
e
)
{
}
}
LOG
(
"
Blocklist
:
onError
:
There
was
an
error
loading
the
blocklist
file
\
r
\
n
"
+
statusText
)
;
}
_loadBlocklist
(
)
{
this
.
_addonEntries
=
[
]
;
this
.
_gfxEntries
=
[
]
;
this
.
_pluginEntries
=
[
]
;
Services
.
telemetry
.
getHistogramById
(
"
BLOCKLIST_SYNC_FILE_LOAD
"
)
.
add
(
true
)
;
var
profFile
=
FileUtils
.
getFile
(
KEY_PROFILEDIR
[
FILE_BLOCKLIST
]
)
;
try
{
this
.
_loadBlocklistFromFile
(
profFile
)
;
}
catch
(
ex
)
{
LOG
(
"
Blocklist
:
:
_loadBlocklist
:
couldn
'
t
load
file
from
profile
trying
app
dir
"
)
;
try
{
var
appFile
=
FileUtils
.
getFile
(
KEY_APPDIR
[
FILE_BLOCKLIST
]
)
;
this
.
_loadBlocklistFromFile
(
appFile
)
;
}
catch
(
ex
)
{
LOG
(
"
Blocklist
:
:
_loadBlocklist
:
no
XML
File
found
"
)
;
}
}
}
_loadBlocklistFromFile
(
file
)
{
if
(
!
gBlocklistEnabled
)
{
LOG
(
"
Blocklist
:
:
_loadBlocklistFromFile
:
blocklist
is
disabled
"
)
;
return
;
}
let
text
=
"
"
;
let
fstream
=
null
;
let
cstream
=
null
;
try
{
fstream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
cstream
=
Cc
[
"
mozilla
.
org
/
intl
/
converter
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIConverterInputStream
)
;
fstream
.
init
(
file
FileUtils
.
MODE_RDONLY
FileUtils
.
PERMS_FILE
0
)
;
cstream
.
init
(
fstream
"
UTF
-
8
"
0
0
)
;
let
str
=
{
}
;
let
read
=
0
;
do
{
read
=
cstream
.
readString
(
0xffffffff
str
)
;
text
+
=
str
.
value
;
}
while
(
read
!
=
0
)
;
}
finally
{
if
(
cstream
)
{
try
{
cstream
.
close
(
)
;
}
catch
(
ex
)
{
}
}
if
(
fstream
)
{
try
{
fstream
.
close
(
)
;
}
catch
(
ex
)
{
}
}
}
if
(
text
)
this
.
_loadBlocklistFromString
(
text
)
;
}
get
isLoaded
(
)
{
return
this
.
_addonEntries
!
=
null
&
&
this
.
_gfxEntries
!
=
null
&
&
this
.
_pluginEntries
!
=
null
;
}
_clear
(
)
{
this
.
_addonEntries
=
null
;
this
.
_gfxEntries
=
null
;
this
.
_pluginEntries
=
null
;
}
async
loadBlocklistAsync
(
)
{
let
profPath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FILE_BLOCKLIST
)
;
try
{
await
this
.
_preloadBlocklistFile
(
profPath
)
;
return
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
loadBlocklistAsync
:
Failed
to
load
XML
file
"
+
e
)
;
}
var
appFile
=
FileUtils
.
getFile
(
KEY_APPDIR
[
FILE_BLOCKLIST
]
)
;
try
{
await
this
.
_preloadBlocklistFile
(
appFile
.
path
)
;
return
;
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
loadBlocklistAsync
:
Failed
to
load
XML
file
"
+
e
)
;
}
LOG
(
"
Blocklist
:
:
loadBlocklistAsync
:
no
XML
File
found
"
)
;
}
async
_preloadBlocklistFile
(
path
)
{
if
(
this
.
_addonEntries
)
{
return
;
}
if
(
!
gBlocklistEnabled
)
{
LOG
(
"
Blocklist
:
:
_preloadBlocklistFile
:
blocklist
is
disabled
"
)
;
return
;
}
let
text
=
await
OS
.
File
.
read
(
path
{
encoding
:
"
utf
-
8
"
}
)
;
await
new
Promise
(
resolve
=
>
{
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
if
(
!
this
.
isLoaded
)
{
Services
.
telemetry
.
getHistogramById
(
"
BLOCKLIST_SYNC_FILE_LOAD
"
)
.
add
(
false
)
;
this
.
_loadBlocklistFromString
(
text
)
;
}
resolve
(
)
;
}
)
;
}
)
;
}
_loadBlocklistFromString
(
text
)
{
try
{
var
parser
=
Cc
[
"
mozilla
.
org
/
xmlextras
/
domparser
;
1
"
]
.
createInstance
(
Ci
.
nsIDOMParser
)
;
var
doc
=
parser
.
parseFromString
(
text
"
text
/
xml
"
)
;
if
(
doc
.
documentElement
.
namespaceURI
!
=
XMLURI_BLOCKLIST
)
{
LOG
(
"
Blocklist
:
:
_loadBlocklistFromString
:
aborting
due
to
incorrect
"
+
"
XML
Namespace
.
\
r
\
nExpected
:
"
+
XMLURI_BLOCKLIST
+
"
\
r
\
n
"
+
"
Received
:
"
+
doc
.
documentElement
.
namespaceURI
)
;
return
;
}
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
_loadBlocklistFromString
:
Error
constructing
blocklist
"
+
e
)
;
return
;
}
this
.
_loadBlocklistFromXML
(
doc
)
;
}
_loadBlocklistFromXML
(
doc
)
{
this
.
_addonEntries
=
[
]
;
this
.
_gfxEntries
=
[
]
;
this
.
_pluginEntries
=
[
]
;
try
{
var
childNodes
=
doc
.
documentElement
.
childNodes
;
for
(
let
element
of
childNodes
)
{
if
(
!
(
element
instanceof
Ci
.
nsIDOMElement
)
)
continue
;
switch
(
element
.
localName
)
{
case
"
emItems
"
:
this
.
_addonEntries
=
this
.
_processItemNodes
(
element
.
childNodes
"
emItem
"
this
.
_handleEmItemNode
)
;
break
;
case
"
pluginItems
"
:
this
.
_pluginEntries
=
this
.
_processItemNodes
(
element
.
childNodes
"
pluginItem
"
this
.
_handlePluginItemNode
)
;
break
;
case
"
gfxItems
"
:
this
.
_gfxEntries
=
this
.
_processItemNodes
(
element
.
childNodes
"
gfxBlacklistEntry
"
this
.
_handleGfxBlacklistNode
)
;
break
;
default
:
LOG
(
"
Blocklist
:
:
_loadBlocklistFromXML
:
ignored
entries
"
+
element
.
localName
)
;
}
}
if
(
this
.
_gfxEntries
.
length
>
0
)
{
this
.
_notifyObserversBlocklistGFX
(
)
;
}
}
catch
(
e
)
{
LOG
(
"
Blocklist
:
:
_loadBlocklistFromXML
:
Error
constructing
blocklist
"
+
e
)
;
}
Services
.
tm
.
dispatchToMainThread
(
function
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
blocklist
-
loaded
"
)
;
}
)
;
}
_processItemNodes
(
itemNodes
itemName
handler
)
{
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
itemNodes
.
length
;
+
+
i
)
{
var
blocklistElement
=
itemNodes
.
item
(
i
)
;
if
(
!
(
blocklistElement
instanceof
Ci
.
nsIDOMElement
)
|
|
blocklistElement
.
localName
!
=
itemName
)
continue
;
handler
(
blocklistElement
result
)
;
}
return
result
;
}
_handleEmItemNode
(
blocklistElement
result
)
{
if
(
!
matchesOSABI
(
blocklistElement
)
)
return
;
let
blockEntry
=
{
versions
:
[
]
prefs
:
[
]
blockID
:
null
attributes
:
new
Map
(
)
}
;
function
regExpCheck
(
attr
)
{
return
attr
.
startsWith
(
"
/
"
)
?
parseRegExp
(
attr
)
:
attr
;
}
for
(
let
filter
of
EXTENSION_BLOCK_FILTERS
)
{
let
attr
=
blocklistElement
.
getAttribute
(
filter
)
;
if
(
attr
)
blockEntry
.
attributes
.
set
(
filter
regExpCheck
(
attr
)
)
;
}
var
childNodes
=
blocklistElement
.
childNodes
;
for
(
let
x
=
0
;
x
<
childNodes
.
length
;
x
+
+
)
{
var
childElement
=
childNodes
.
item
(
x
)
;
if
(
!
(
childElement
instanceof
Ci
.
nsIDOMElement
)
)
continue
;
if
(
childElement
.
localName
=
=
=
"
prefs
"
)
{
let
prefElements
=
childElement
.
childNodes
;
for
(
let
i
=
0
;
i
<
prefElements
.
length
;
i
+
+
)
{
let
prefElement
=
prefElements
.
item
(
i
)
;
if
(
!
(
prefElement
instanceof
Ci
.
nsIDOMElement
)
|
|
prefElement
.
localName
!
=
=
"
pref
"
)
continue
;
blockEntry
.
prefs
.
push
(
prefElement
.
textContent
)
;
}
}
else
if
(
childElement
.
localName
=
=
=
"
versionRange
"
)
blockEntry
.
versions
.
push
(
new
BlocklistItemData
(
childElement
)
)
;
}
if
(
blockEntry
.
versions
.
length
=
=
0
)
blockEntry
.
versions
.
push
(
new
BlocklistItemData
(
null
)
)
;
blockEntry
.
blockID
=
blocklistElement
.
getAttribute
(
"
blockID
"
)
;
result
.
push
(
blockEntry
)
;
}
_handlePluginItemNode
(
blocklistElement
result
)
{
if
(
!
matchesOSABI
(
blocklistElement
)
)
return
;
var
matchNodes
=
blocklistElement
.
childNodes
;
var
blockEntry
=
{
matches
:
{
}
versions
:
[
]
blockID
:
null
infoURL
:
null
}
;
var
hasMatch
=
false
;
for
(
var
x
=
0
;
x
<
matchNodes
.
length
;
+
+
x
)
{
var
matchElement
=
matchNodes
.
item
(
x
)
;
if
(
!
(
matchElement
instanceof
Ci
.
nsIDOMElement
)
)
continue
;
if
(
matchElement
.
localName
=
=
"
match
"
)
{
var
name
=
matchElement
.
getAttribute
(
"
name
"
)
;
var
exp
=
matchElement
.
getAttribute
(
"
exp
"
)
;
try
{
blockEntry
.
matches
[
name
]
=
new
RegExp
(
exp
"
m
"
)
;
hasMatch
=
true
;
}
catch
(
e
)
{
}
}
if
(
matchElement
.
localName
=
=
"
versionRange
"
)
{
blockEntry
.
versions
.
push
(
new
BlocklistItemData
(
matchElement
)
)
;
}
else
if
(
matchElement
.
localName
=
=
"
infoURL
"
)
{
blockEntry
.
infoURL
=
matchElement
.
textContent
;
}
}
if
(
!
hasMatch
)
return
;
if
(
blockEntry
.
versions
.
length
=
=
0
)
blockEntry
.
versions
.
push
(
new
BlocklistItemData
(
null
)
)
;
blockEntry
.
blockID
=
blocklistElement
.
getAttribute
(
"
blockID
"
)
;
result
.
push
(
blockEntry
)
;
}
_handleGfxBlacklistNode
(
blocklistElement
result
)
{
const
blockEntry
=
{
}
;
if
(
blocklistElement
.
hasAttribute
(
"
blockID
"
)
)
{
blockEntry
.
blockID
=
blocklistElement
.
getAttribute
(
"
blockID
"
)
;
}
const
trim
=
(
s
)
=
>
(
s
|
|
"
"
)
.
replace
(
/
(
^
[
\
s
\
uFEFF
\
xA0
]
+
)
|
(
[
\
s
\
uFEFF
\
xA0
]
+
)
/
g
"
"
)
;
for
(
let
i
=
0
;
i
<
blocklistElement
.
childNodes
.
length
;
+
+
i
)
{
var
matchElement
=
blocklistElement
.
childNodes
.
item
(
i
)
;
if
(
!
(
matchElement
instanceof
Ci
.
nsIDOMElement
)
)
continue
;
let
value
;
if
(
matchElement
.
localName
=
=
"
devices
"
)
{
value
=
[
]
;
for
(
let
j
=
0
;
j
<
matchElement
.
childNodes
.
length
;
j
+
+
)
{
const
childElement
=
matchElement
.
childNodes
.
item
(
j
)
;
const
childValue
=
trim
(
childElement
.
textContent
)
;
if
(
childValue
)
{
if
(
/
/
.
test
(
childValue
)
)
{
const
e
=
new
Error
(
Unsupported
device
name
{
childValue
}
)
;
Cu
.
reportError
(
e
)
;
}
else
{
value
.
push
(
childValue
)
;
}
}
}
}
else
if
(
matchElement
.
localName
=
=
"
versionRange
"
)
{
value
=
{
minVersion
:
trim
(
matchElement
.
getAttribute
(
"
minVersion
"
)
)
|
|
"
0
"
maxVersion
:
trim
(
matchElement
.
getAttribute
(
"
maxVersion
"
)
)
|
|
"
*
"
}
;
}
else
{
value
=
trim
(
matchElement
.
textContent
)
;
}
if
(
value
)
{
blockEntry
[
matchElement
.
localName
]
=
value
;
}
}
result
.
push
(
blockEntry
)
;
}
getPluginBlocklistState
(
plugin
appVersion
toolkitVersion
)
{
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
if
(
!
this
.
isLoaded
)
this
.
_loadBlocklist
(
)
;
return
this
.
_getPluginBlocklistState
(
plugin
this
.
_pluginEntries
appVersion
toolkitVersion
)
;
}
_getPluginBlocklistEntry
(
plugin
pluginEntries
appVersion
toolkitVersion
)
{
if
(
!
gBlocklistEnabled
)
return
null
;
if
(
!
appVersion
&
&
!
gApp
.
version
)
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
if
(
!
appVersion
)
appVersion
=
gApp
.
version
;
if
(
!
toolkitVersion
)
toolkitVersion
=
gApp
.
platformVersion
;
const
pluginProperties
=
{
description
:
plugin
.
description
filename
:
plugin
.
filename
name
:
plugin
.
name
version
:
plugin
.
version
}
;
for
(
var
blockEntry
of
pluginEntries
)
{
var
matchFailed
=
false
;
for
(
var
name
in
blockEntry
.
matches
)
{
let
pluginProperty
=
pluginProperties
[
name
]
;
if
(
typeof
(
pluginProperty
)
!
=
=
"
string
"
|
|
!
blockEntry
.
matches
[
name
]
.
test
(
pluginProperty
)
)
{
matchFailed
=
true
;
break
;
}
}
if
(
matchFailed
)
continue
;
for
(
let
blockEntryVersion
of
blockEntry
.
versions
)
{
if
(
blockEntryVersion
.
includesItem
(
pluginProperties
.
version
appVersion
toolkitVersion
)
)
{
return
{
entry
:
blockEntry
version
:
blockEntryVersion
}
;
}
}
}
return
null
;
}
_getPluginBlocklistState
(
plugin
pluginEntries
appVersion
toolkitVersion
)
{
let
r
=
this
.
_getPluginBlocklistEntry
(
plugin
pluginEntries
appVersion
toolkitVersion
)
;
if
(
!
r
)
{
return
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
}
let
{
version
:
blockEntryVersion
}
=
r
;
if
(
blockEntryVersion
.
severity
>
=
gBlocklistLevel
)
return
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
;
if
(
blockEntryVersion
.
severity
=
=
SEVERITY_OUTDATED
)
{
let
vulnerabilityStatus
=
blockEntryVersion
.
vulnerabilityStatus
;
if
(
vulnerabilityStatus
=
=
VULNERABILITYSTATUS_UPDATE_AVAILABLE
)
return
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_UPDATE_AVAILABLE
;
if
(
vulnerabilityStatus
=
=
VULNERABILITYSTATUS_NO_UPDATE
)
return
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_NO_UPDATE
;
return
Ci
.
nsIBlocklistService
.
STATE_OUTDATED
;
}
return
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
;
}
getPluginBlocklistURL
(
plugin
)
{
if
(
!
this
.
isLoaded
)
this
.
_loadBlocklist
(
)
;
let
r
=
this
.
_getPluginBlocklistEntry
(
plugin
this
.
_pluginEntries
)
;
if
(
!
r
)
{
return
null
;
}
let
{
entry
:
blockEntry
}
=
r
;
if
(
!
blockEntry
.
blockID
)
{
return
null
;
}
return
this
.
_createBlocklistURL
(
blockEntry
.
blockID
)
;
}
getPluginInfoURL
(
plugin
)
{
if
(
!
this
.
isLoaded
)
this
.
_loadBlocklist
(
)
;
let
r
=
this
.
_getPluginBlocklistEntry
(
plugin
this
.
_pluginEntries
)
;
if
(
!
r
)
{
return
null
;
}
let
{
entry
:
blockEntry
}
=
r
;
if
(
!
blockEntry
.
blockID
)
{
return
null
;
}
return
blockEntry
.
infoURL
;
}
_notifyObserversBlocklistGFX
(
)
{
const
payload
=
this
.
_gfxEntries
.
map
(
(
r
)
=
>
{
return
Object
.
keys
(
r
)
.
sort
(
)
.
filter
(
(
k
)
=
>
!
/
id
|
last_modified
/
.
test
(
k
)
)
.
map
(
(
key
)
=
>
{
let
value
=
r
[
key
]
;
if
(
Array
.
isArray
(
value
)
)
{
value
=
value
.
join
(
"
"
)
;
}
else
if
(
value
.
hasOwnProperty
(
"
minVersion
"
)
)
{
value
=
{
value
.
minVersion
}
{
value
.
maxVersion
}
;
}
return
{
key
}
:
{
value
}
;
}
)
.
join
(
"
\
t
"
)
;
}
)
.
join
(
"
\
n
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
blocklist
-
data
-
gfxItems
"
payload
)
;
}
_notifyObserversBlocklistUpdated
(
)
{
Services
.
obs
.
notifyObservers
(
this
"
blocklist
-
updated
"
)
;
Services
.
ppmm
.
broadcastAsyncMessage
(
"
Blocklist
:
blocklistInvalidated
"
{
}
)
;
}
_blocklistUpdated
(
oldAddonEntries
oldPluginEntries
)
{
var
addonList
=
[
]
;
function
resetPrefs
(
prefs
)
{
for
(
let
pref
of
prefs
)
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
const
types
=
[
"
extension
"
"
theme
"
"
locale
"
"
dictionary
"
"
service
"
]
;
AddonManager
.
getAddonsByTypes
(
types
addons
=
>
{
for
(
let
addon
of
addons
)
{
let
oldState
=
addon
.
blocklistState
;
if
(
addon
.
updateBlocklistState
)
{
addon
.
updateBlocklistState
(
false
)
;
}
else
if
(
oldAddonEntries
)
{
oldState
=
this
.
_getAddonBlocklistState
(
addon
oldAddonEntries
)
;
}
else
{
oldState
=
Ci
.
nsIBlocklistService
.
STATE_NOTBLOCKED
;
}
let
state
=
addon
.
blocklistState
;
LOG
(
"
Blocklist
state
for
"
+
addon
.
id
+
"
changed
from
"
+
oldState
+
"
to
"
+
state
)
;
if
(
state
=
=
oldState
)
continue
;
if
(
state
=
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
let
prefs
=
this
.
_getAddonPrefs
(
addon
)
;
resetPrefs
(
prefs
)
;
}
if
(
state
!
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
addon
.
softDisabled
=
false
;
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
continue
;
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
&
&
oldState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
addon
.
softDisabled
=
true
;
continue
;
}
if
(
!
addon
.
isActive
)
{
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
&
&
!
addon
.
userDisabled
)
addon
.
softDisabled
=
true
;
continue
;
}
addonList
.
push
(
{
name
:
addon
.
name
version
:
addon
.
version
icon
:
addon
.
iconURL
disable
:
false
blocked
:
state
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
item
:
addon
url
:
this
.
getAddonBlocklistURL
(
addon
)
}
)
;
}
AddonManagerPrivate
.
updateAddonAppDisabledStates
(
)
;
var
phs
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
var
plugins
=
phs
.
getPluginTags
(
)
;
for
(
let
plugin
of
plugins
)
{
let
oldState
=
-
1
;
if
(
oldPluginEntries
)
oldState
=
this
.
_getPluginBlocklistState
(
plugin
oldPluginEntries
)
;
let
state
=
this
.
getPluginBlocklistState
(
plugin
)
;
LOG
(
"
Blocklist
state
for
"
+
plugin
.
name
+
"
changed
from
"
+
oldState
+
"
to
"
+
state
)
;
if
(
state
=
=
oldState
)
continue
;
if
(
oldState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
if
(
state
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
plugin
.
enabledState
=
Ci
.
nsIPluginTag
.
STATE_DISABLED
;
}
else
if
(
!
plugin
.
disabled
&
&
state
!
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
{
if
(
state
!
=
Ci
.
nsIBlocklistService
.
STATE_OUTDATED
&
&
state
!
=
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_UPDATE_AVAILABLE
&
&
state
!
=
Ci
.
nsIBlocklistService
.
STATE_VULNERABLE_NO_UPDATE
)
{
addonList
.
push
(
{
name
:
plugin
.
name
version
:
plugin
.
version
icon
:
"
chrome
:
/
/
mozapps
/
skin
/
plugins
/
pluginGeneric
.
svg
"
disable
:
false
blocked
:
state
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
item
:
plugin
url
:
this
.
getPluginBlocklistURL
(
plugin
)
}
)
;
}
}
}
if
(
addonList
.
length
=
=
0
)
{
this
.
_notifyObserversBlocklistUpdated
(
)
;
return
;
}
if
(
"
mozilla
.
org
/
addons
/
blocklist
-
prompt
;
1
"
in
Cc
)
{
try
{
let
blockedPrompter
=
Cc
[
"
mozilla
.
org
/
addons
/
blocklist
-
prompt
;
1
"
]
.
getService
(
Ci
.
nsIBlocklistPrompt
)
;
blockedPrompter
.
prompt
(
addonList
)
;
}
catch
(
e
)
{
LOG
(
e
)
;
}
this
.
_notifyObserversBlocklistUpdated
(
)
;
return
;
}
var
args
=
{
restart
:
false
list
:
addonList
}
;
args
.
wrappedJSObject
=
args
;
let
applyBlocklistChanges
=
(
)
=
>
{
for
(
let
addon
of
addonList
)
{
if
(
!
addon
.
disable
)
continue
;
if
(
addon
.
item
instanceof
Ci
.
nsIPluginTag
)
addon
.
item
.
enabledState
=
Ci
.
nsIPluginTag
.
STATE_DISABLED
;
else
{
addon
.
item
.
softDisabled
=
true
;
let
prefs
=
this
.
_getAddonPrefs
(
addon
.
item
)
;
resetPrefs
(
prefs
)
;
}
}
if
(
args
.
restart
)
restartApp
(
)
;
this
.
_notifyObserversBlocklistUpdated
(
)
;
Services
.
obs
.
removeObserver
(
applyBlocklistChanges
"
addon
-
blocklist
-
closed
"
)
;
}
;
Services
.
obs
.
addObserver
(
applyBlocklistChanges
"
addon
-
blocklist
-
closed
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_SUPPRESSUI
false
)
)
{
applyBlocklistChanges
(
)
;
return
;
}
function
blocklistUnloadHandler
(
event
)
{
if
(
event
.
target
.
location
=
=
URI_BLOCKLIST_DIALOG
)
{
applyBlocklistChanges
(
)
;
blocklistWindow
.
removeEventListener
(
"
unload
"
blocklistUnloadHandler
)
;
}
}
let
blocklistWindow
=
Services
.
ww
.
openWindow
(
null
URI_BLOCKLIST_DIALOG
"
"
"
chrome
centerscreen
dialog
titlebar
"
args
)
;
if
(
blocklistWindow
)
blocklistWindow
.
addEventListener
(
"
unload
"
blocklistUnloadHandler
)
;
}
)
;
}
classID
:
Components
.
ID
(
"
{
66354bc9
-
7ed1
-
4692
-
ae1d
-
8da97d6b205e
}
"
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsIBlocklistService
Ci
.
nsITimerCallback
]
)
}
;
function
BlocklistItemData
(
versionRangeElement
)
{
var
versionRange
=
this
.
getBlocklistVersionRange
(
versionRangeElement
)
;
this
.
minVersion
=
versionRange
.
minVersion
;
this
.
maxVersion
=
versionRange
.
maxVersion
;
if
(
versionRangeElement
&
&
versionRangeElement
.
hasAttribute
(
"
severity
"
)
)
this
.
severity
=
versionRangeElement
.
getAttribute
(
"
severity
"
)
;
else
this
.
severity
=
DEFAULT_SEVERITY
;
if
(
versionRangeElement
&
&
versionRangeElement
.
hasAttribute
(
"
vulnerabilitystatus
"
)
)
{
this
.
vulnerabilityStatus
=
versionRangeElement
.
getAttribute
(
"
vulnerabilitystatus
"
)
;
}
else
{
this
.
vulnerabilityStatus
=
VULNERABILITYSTATUS_NONE
;
}
this
.
targetApps
=
{
}
;
var
found
=
false
;
if
(
versionRangeElement
)
{
for
(
var
i
=
0
;
i
<
versionRangeElement
.
childNodes
.
length
;
+
+
i
)
{
var
targetAppElement
=
versionRangeElement
.
childNodes
.
item
(
i
)
;
if
(
!
(
targetAppElement
instanceof
Ci
.
nsIDOMElement
)
|
|
targetAppElement
.
localName
!
=
"
targetApplication
"
)
continue
;
found
=
true
;
var
appID
=
targetAppElement
.
hasAttribute
(
"
id
"
)
?
targetAppElement
.
getAttribute
(
"
id
"
)
:
gApp
.
ID
;
this
.
targetApps
[
appID
]
=
this
.
getBlocklistAppVersions
(
targetAppElement
)
;
}
}
if
(
!
found
)
this
.
targetApps
[
gApp
.
ID
]
=
this
.
getBlocklistAppVersions
(
null
)
;
}
BlocklistItemData
.
prototype
=
{
includesItem
(
version
appVersion
toolkitVersion
)
{
if
(
!
version
&
&
(
this
.
minVersion
|
|
this
.
maxVersion
)
)
return
false
;
if
(
!
this
.
matchesRange
(
version
this
.
minVersion
this
.
maxVersion
)
)
return
false
;
if
(
this
.
matchesTargetRange
(
gApp
.
ID
appVersion
)
)
return
true
;
return
this
.
matchesTargetRange
(
TOOLKIT_ID
toolkitVersion
)
;
}
matchesRange
(
version
minVersion
maxVersion
)
{
if
(
minVersion
&
&
Services
.
vc
.
compare
(
version
minVersion
)
<
0
)
return
false
;
if
(
maxVersion
&
&
Services
.
vc
.
compare
(
version
maxVersion
)
>
0
)
return
false
;
return
true
;
}
matchesTargetRange
(
appID
appVersion
)
{
var
blTargetApp
=
this
.
targetApps
[
appID
]
;
if
(
!
blTargetApp
)
return
false
;
for
(
let
app
of
blTargetApp
)
{
if
(
this
.
matchesRange
(
appVersion
app
.
minVersion
app
.
maxVersion
)
)
return
true
;
}
return
false
;
}
getBlocklistAppVersions
(
targetAppElement
)
{
var
appVersions
=
[
]
;
if
(
targetAppElement
)
{
for
(
var
i
=
0
;
i
<
targetAppElement
.
childNodes
.
length
;
+
+
i
)
{
var
versionRangeElement
=
targetAppElement
.
childNodes
.
item
(
i
)
;
if
(
!
(
versionRangeElement
instanceof
Ci
.
nsIDOMElement
)
|
|
versionRangeElement
.
localName
!
=
"
versionRange
"
)
continue
;
appVersions
.
push
(
this
.
getBlocklistVersionRange
(
versionRangeElement
)
)
;
}
}
if
(
appVersions
.
length
=
=
0
)
appVersions
.
push
(
this
.
getBlocklistVersionRange
(
null
)
)
;
return
appVersions
;
}
getBlocklistVersionRange
(
versionRangeElement
)
{
var
minVersion
=
null
;
var
maxVersion
=
null
;
if
(
!
versionRangeElement
)
return
{
minVersion
maxVersion
}
;
if
(
versionRangeElement
.
hasAttribute
(
"
minVersion
"
)
)
minVersion
=
versionRangeElement
.
getAttribute
(
"
minVersion
"
)
;
if
(
versionRangeElement
.
hasAttribute
(
"
maxVersion
"
)
)
maxVersion
=
versionRangeElement
.
getAttribute
(
"
maxVersion
"
)
;
return
{
minVersion
maxVersion
}
;
}
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
Blocklist
]
)
;
