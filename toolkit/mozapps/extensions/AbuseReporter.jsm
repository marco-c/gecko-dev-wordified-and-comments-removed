const
EXPORTED_SYMBOLS
=
[
"
AbuseReporter
"
"
AbuseReportError
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
const
PREF_ABUSE_REPORT_URL
=
"
extensions
.
abuseReport
.
url
"
;
const
PREF_AMO_DETAILS_API_URL
=
"
extensions
.
abuseReport
.
amoDetailsURL
"
;
const
DIALOG_WINDOW_NAME
=
"
addons
-
abuse
-
report
-
dialog
"
;
const
MAX_STRING_LENGTH
=
255
;
const
MIN_MS_BETWEEN_SUBMITS
=
30000
;
const
SUPPORTED_ADDON_TYPES
=
[
"
extension
"
"
theme
"
]
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AMTelemetry
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
ClientID
:
"
resource
:
/
/
gre
/
modules
/
ClientID
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
ABUSE_REPORT_URL
"
PREF_ABUSE_REPORT_URL
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
AMO_DETAILS_API_URL
"
PREF_AMO_DETAILS_API_URL
)
;
const
PRIVATE_REPORT_PROPS
=
Symbol
(
"
privateReportProps
"
)
;
const
ERROR_TYPES
=
Object
.
freeze
(
[
"
ERROR_ABORTED_SUBMIT
"
"
ERROR_ADDON_NOTFOUND
"
"
ERROR_CLIENT
"
"
ERROR_NETWORK
"
"
ERROR_UNKNOWN
"
"
ERROR_RECENT_SUBMIT
"
"
ERROR_SERVER
"
"
ERROR_AMODETAILS_NOTFOUND
"
"
ERROR_AMODETAILS_FAILURE
"
]
)
;
class
AbuseReportError
extends
Error
{
constructor
(
errorType
errorInfo
=
undefined
)
{
if
(
!
ERROR_TYPES
.
includes
(
errorType
)
)
{
throw
new
Error
(
Unknown
AbuseReportError
type
"
{
errorType
}
"
)
;
}
let
message
=
errorInfo
?
{
errorType
}
-
{
errorInfo
}
:
errorType
;
super
(
message
)
;
this
.
name
=
"
AbuseReportError
"
;
this
.
errorType
=
errorType
;
this
.
errorInfo
=
errorInfo
;
}
}
async
function
responseToErrorInfo
(
response
)
{
return
JSON
.
stringify
(
{
status
:
response
.
status
responseText
:
await
response
.
text
(
)
.
catch
(
err
=
>
"
"
)
}
)
;
}
const
AbuseReporter
=
{
_lastReportTimestamp
:
null
updateLastReportTimestamp
(
)
{
this
.
_lastReportTimestamp
=
Date
.
now
(
)
;
}
getTimeFromLastReport
(
)
{
const
currentTimestamp
=
Date
.
now
(
)
;
if
(
this
.
_lastReportTimestamp
>
currentTimestamp
)
{
this
.
_lastReportTimestamp
=
null
;
}
if
(
!
this
.
_lastReportTimestamp
)
{
return
Infinity
;
}
return
currentTimestamp
-
this
.
_lastReportTimestamp
;
}
isSupportedAddonType
(
addonType
)
{
return
SUPPORTED_ADDON_TYPES
.
includes
(
addonType
)
;
}
async
createAbuseReport
(
addonId
{
reportEntryPoint
}
=
{
}
)
{
let
addon
=
await
AddonManager
.
getAddonByID
(
addonId
)
;
if
(
!
addon
)
{
addon
=
await
this
.
queryAMOAddonDetails
(
addonId
reportEntryPoint
)
;
}
if
(
!
addon
)
{
AMTelemetry
.
recordReportEvent
(
{
addonId
errorType
:
"
ERROR_ADDON_NOTFOUND
"
reportEntryPoint
}
)
;
throw
new
AbuseReportError
(
"
ERROR_ADDON_NOTFOUND
"
)
;
}
const
reportData
=
await
this
.
getReportData
(
addon
)
;
return
new
AbuseReport
(
{
addon
reportData
reportEntryPoint
}
)
;
}
async
queryAMOAddonDetails
(
addonId
reportEntryPoint
)
{
let
details
;
try
{
details
=
await
fetch
(
{
AMO_DETAILS_API_URL
}
/
{
addonId
}
{
credentials
:
"
omit
"
referrerPolicy
:
"
no
-
referrer
"
headers
:
{
"
Content
-
Type
"
:
"
application
/
json
"
}
}
)
.
then
(
async
response
=
>
{
if
(
response
.
status
=
=
=
200
)
{
return
response
.
json
(
)
;
}
let
errorInfo
=
await
responseToErrorInfo
(
response
)
.
catch
(
err
=
>
undefined
)
;
if
(
response
.
status
=
=
=
404
)
{
throw
new
AbuseReportError
(
"
ERROR_AMODETAILS_NOTFOUND
"
errorInfo
)
;
}
throw
new
AbuseReportError
(
"
ERROR_AMODETAILS_FAILURE
"
errorInfo
)
;
}
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
AMTelemetry
.
recordReportEvent
(
{
addonId
errorType
:
err
.
errorType
|
|
"
ERROR_AMODETAILS_FAILURE
"
reportEntryPoint
}
)
;
return
null
;
}
const
locale
=
Services
.
locale
.
appLocaleAsBCP47
;
const
getTranslatedValue
=
value
=
>
{
if
(
typeof
value
=
=
=
"
string
"
)
{
return
value
;
}
return
value
&
&
(
value
[
locale
]
|
|
value
[
"
en
-
US
"
]
)
;
}
;
const
getAuthorField
=
fieldName
=
>
details
.
authors
&
&
details
.
authors
[
0
]
&
&
details
.
authors
[
0
]
[
fieldName
]
;
const
addonType
=
details
.
type
=
=
=
"
statictheme
"
?
"
theme
"
:
details
.
type
;
return
{
id
:
addonId
name
:
getTranslatedValue
(
details
.
name
)
version
:
details
.
current_version
.
version
description
:
getTranslatedValue
(
details
.
summary
)
type
:
addonType
iconURL
:
details
.
icon_url
homepageURL
:
getTranslatedValue
(
details
.
homepage
)
supportURL
:
getTranslatedValue
(
details
.
support_url
)
creator
:
{
name
:
getAuthorField
(
"
name
"
)
url
:
getAuthorField
(
"
url
"
)
}
isRecommended
:
details
.
is_recommended
signedState
:
AddonManager
.
SIGNEDSTATE_UNKNOWN
installTelemetryInfo
:
{
source
:
"
not_installed
"
}
}
;
}
async
getReportData
(
addon
)
{
const
truncateString
=
text
=
>
typeof
text
=
=
"
string
"
?
text
.
slice
(
0
MAX_STRING_LENGTH
)
:
text
;
const
normalizeValue
=
text
=
>
typeof
text
=
=
"
string
"
?
text
.
toLowerCase
(
)
.
replace
(
/
[
-
:
]
/
g
"
_
"
)
:
null
;
const
installInfo
=
addon
.
installTelemetryInfo
|
|
{
}
;
const
data
=
{
addon
:
addon
.
id
addon_version
:
addon
.
version
addon_name
:
truncateString
(
addon
.
name
)
addon_summary
:
truncateString
(
addon
.
description
)
addon_install_origin
:
addon
.
sourceURI
&
&
truncateString
(
addon
.
sourceURI
.
spec
)
install_date
:
addon
.
installDate
&
&
addon
.
installDate
.
toISOString
(
)
addon_install_source
:
normalizeValue
(
installInfo
.
source
)
addon_install_source_url
:
installInfo
.
sourceURL
&
&
truncateString
(
installInfo
.
sourceURL
)
addon_install_method
:
normalizeValue
(
installInfo
.
method
)
}
;
switch
(
addon
.
signedState
)
{
case
AddonManager
.
SIGNEDSTATE_BROKEN
:
data
.
addon_signature
=
"
broken
"
;
break
;
case
AddonManager
.
SIGNEDSTATE_UNKNOWN
:
data
.
addon_signature
=
"
unknown
"
;
break
;
case
AddonManager
.
SIGNEDSTATE_MISSING
:
data
.
addon_signature
=
"
missing
"
;
break
;
case
AddonManager
.
SIGNEDSTATE_PRELIMINARY
:
data
.
addon_signature
=
"
preliminary
"
;
break
;
case
AddonManager
.
SIGNEDSTATE_SIGNED
:
data
.
addon_signature
=
"
signed
"
;
break
;
case
AddonManager
.
SIGNEDSTATE_SYSTEM
:
data
.
addon_signature
=
"
system
"
;
break
;
case
AddonManager
.
SIGNEDSTATE_PRIVILEGED
:
data
.
addon_signature
=
"
privileged
"
;
break
;
default
:
data
.
addon_signature
=
unknown
:
{
addon
.
signedState
}
;
}
if
(
addon
.
isRecommended
)
{
data
.
addon_signature
=
"
curated
"
;
}
data
.
client_id
=
await
ClientID
.
getClientIdHash
(
)
;
data
.
app
=
Services
.
appinfo
.
name
.
toLowerCase
(
)
;
data
.
appversion
=
Services
.
appinfo
.
version
;
data
.
lang
=
Services
.
locale
.
appLocaleAsBCP47
;
data
.
operating_system
=
AppConstants
.
platform
;
data
.
operating_system_version
=
Services
.
sysinfo
.
getProperty
(
"
version
"
)
;
return
data
;
}
getOpenDialog
(
)
{
return
Services
.
ww
.
getWindowByName
(
DIALOG_WINDOW_NAME
null
)
;
}
async
openDialog
(
addonId
reportEntryPoint
browser
)
{
const
chromeWin
=
browser
&
&
browser
.
ownerGlobal
;
if
(
!
chromeWin
)
{
throw
new
Error
(
"
Abuse
Reporter
dialog
cancelled
opener
tab
closed
"
)
;
}
const
dialogWin
=
this
.
getOpenDialog
(
)
;
if
(
dialogWin
)
{
const
{
deferredReport
promiseReport
}
=
dialogWin
.
arguments
[
0
]
.
wrappedJSObject
;
deferredReport
.
resolve
(
{
userCancelled
:
true
}
)
;
await
promiseReport
;
}
const
report
=
await
AbuseReporter
.
createAbuseReport
(
addonId
{
reportEntryPoint
}
)
;
if
(
!
SUPPORTED_ADDON_TYPES
.
includes
(
report
.
addon
.
type
)
)
{
throw
new
Error
(
Addon
type
"
{
report
.
addon
.
type
}
"
is
not
currently
supported
by
the
integrated
abuse
reporting
feature
)
;
}
const
params
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
const
dialogInit
=
{
report
openWebLink
(
url
)
{
chromeWin
.
openWebLinkIn
(
url
"
tab
"
{
relatedToCurrent
:
true
}
)
;
}
}
;
params
.
appendElement
(
dialogInit
)
;
let
win
;
function
closeDialog
(
)
{
if
(
win
&
&
!
win
.
closed
)
{
win
.
close
(
)
;
}
}
const
promiseReport
=
new
Promise
(
(
resolve
reject
)
=
>
{
dialogInit
.
deferredReport
=
{
resolve
reject
}
;
}
)
.
then
(
(
{
userCancelled
}
)
=
>
{
closeDialog
(
)
;
return
userCancelled
?
undefined
:
report
;
}
err
=
>
{
Cu
.
reportError
(
Unexpected
abuse
report
panel
error
:
{
err
}
:
:
{
err
.
stack
}
)
;
closeDialog
(
)
;
return
Promise
.
reject
(
{
message
:
"
Unexpected
abuse
report
panel
error
"
}
)
;
}
)
;
const
promiseReportPanel
=
new
Promise
(
(
resolve
reject
)
=
>
{
dialogInit
.
deferredReportPanel
=
{
resolve
reject
}
;
}
)
;
dialogInit
.
promiseReport
=
promiseReport
;
dialogInit
.
promiseReportPanel
=
promiseReportPanel
;
win
=
Services
.
ww
.
openWindow
(
chromeWin
"
chrome
:
/
/
mozapps
/
content
/
extensions
/
abuse
-
report
-
frame
.
html
"
DIALOG_WINDOW_NAME
"
dialog
centerscreen
height
=
700
"
params
)
;
return
{
close
:
closeDialog
promiseReport
promiseReportPanel
window
:
win
}
;
}
}
;
class
AbuseReport
{
constructor
(
{
addon
createErrorType
reportData
reportEntryPoint
}
)
{
this
[
PRIVATE_REPORT_PROPS
]
=
{
aborted
:
false
abortController
:
new
AbortController
(
)
addon
reportData
reportEntryPoint
message
:
null
reason
:
null
}
;
}
recordTelemetry
(
errorType
)
{
const
{
addon
reportEntryPoint
}
=
this
;
AMTelemetry
.
recordReportEvent
(
{
addonId
:
addon
.
id
addonType
:
addon
.
type
errorType
reportEntryPoint
}
)
;
}
async
submit
(
)
{
const
{
aborted
abortController
message
reason
reportData
reportEntryPoint
}
=
this
[
PRIVATE_REPORT_PROPS
]
;
const
rejectReportError
=
async
(
errorType
{
response
}
=
{
}
)
=
>
{
this
.
recordTelemetry
(
errorType
)
;
const
errorInfo
=
response
?
await
responseToErrorInfo
(
response
)
.
catch
(
err
=
>
undefined
)
:
undefined
;
throw
new
AbuseReportError
(
errorType
errorInfo
)
;
}
;
if
(
aborted
)
{
return
rejectReportError
(
"
ERROR_ABORTED_SUBMIT
"
)
;
}
let
msFromLastReport
=
AbuseReporter
.
getTimeFromLastReport
(
)
;
if
(
msFromLastReport
<
MIN_MS_BETWEEN_SUBMITS
)
{
return
rejectReportError
(
"
ERROR_RECENT_SUBMIT
"
)
;
}
let
response
;
try
{
response
=
await
fetch
(
ABUSE_REPORT_URL
{
signal
:
abortController
.
signal
method
:
"
POST
"
credentials
:
"
omit
"
referrerPolicy
:
"
no
-
referrer
"
headers
:
{
"
Content
-
Type
"
:
"
application
/
json
"
}
body
:
JSON
.
stringify
(
{
.
.
.
reportData
report_entry_point
:
reportEntryPoint
message
reason
}
)
}
)
;
}
catch
(
err
)
{
if
(
err
.
name
=
=
=
"
AbortError
"
)
{
return
rejectReportError
(
"
ERROR_ABORTED_SUBMIT
"
)
;
}
Cu
.
reportError
(
err
)
;
return
rejectReportError
(
"
ERROR_NETWORK
"
)
;
}
if
(
response
.
ok
&
&
response
.
status
>
=
200
&
&
response
.
status
<
400
)
{
try
{
await
response
.
json
(
)
;
}
catch
(
err
)
{
this
.
recordTelemetry
(
"
ERROR_UNKNOWN
"
)
;
throw
err
;
}
AbuseReporter
.
updateLastReportTimestamp
(
)
;
this
.
recordTelemetry
(
)
;
return
undefined
;
}
if
(
response
.
status
>
=
400
&
&
response
.
status
<
500
)
{
return
rejectReportError
(
"
ERROR_CLIENT
"
{
response
}
)
;
}
if
(
response
.
status
>
=
500
&
&
response
.
status
<
600
)
{
return
rejectReportError
(
"
ERROR_SERVER
"
{
response
}
)
;
}
return
rejectReportError
(
"
ERROR_UNKNOWN
"
{
response
}
)
;
}
abort
(
)
{
const
{
abortController
}
=
this
[
PRIVATE_REPORT_PROPS
]
;
abortController
.
abort
(
)
;
this
[
PRIVATE_REPORT_PROPS
]
.
aborted
=
true
;
}
get
addon
(
)
{
return
this
[
PRIVATE_REPORT_PROPS
]
.
addon
;
}
get
reportEntryPoint
(
)
{
return
this
[
PRIVATE_REPORT_PROPS
]
.
reportEntryPoint
;
}
setMessage
(
message
)
{
this
[
PRIVATE_REPORT_PROPS
]
.
message
=
message
;
}
setReason
(
reason
)
{
this
[
PRIVATE_REPORT_PROPS
]
.
reason
=
reason
;
}
}
