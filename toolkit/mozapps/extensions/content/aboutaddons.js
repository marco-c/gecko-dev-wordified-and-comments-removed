"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
}
)
;
const
PLUGIN_ICON_URL
=
"
chrome
:
/
/
global
/
skin
/
plugins
/
pluginGeneric
.
svg
"
;
const
PERMISSION_MASKS
=
{
enable
:
AddonManager
.
PERM_CAN_ENABLE
disable
:
AddonManager
.
PERM_CAN_DISABLE
uninstall
:
AddonManager
.
PERM_CAN_UNINSTALL
}
;
function
hasPermission
(
addon
permission
)
{
return
!
!
(
addon
.
permissions
&
PERMISSION_MASKS
[
permission
]
)
;
}
let
_templates
=
{
}
;
function
importTemplate
(
name
)
{
if
(
!
_templates
.
hasOwnProperty
(
name
)
)
{
_templates
[
name
]
=
document
.
querySelector
(
template
[
name
=
"
{
name
}
"
]
)
;
}
let
template
=
_templates
[
name
]
;
if
(
template
)
{
return
document
.
importNode
(
template
.
content
true
)
;
}
throw
new
Error
(
Unknown
template
:
{
name
}
)
;
}
class
PanelList
extends
HTMLElement
{
static
get
observedAttributes
(
)
{
return
[
"
open
"
]
;
}
constructor
(
)
{
super
(
)
;
this
.
attachShadow
(
{
mode
:
"
open
"
}
)
;
this
.
shadowRoot
.
appendChild
(
importTemplate
(
"
panel
-
list
"
)
)
;
}
attributeChangedCallback
(
name
oldVal
newVal
)
{
if
(
name
=
=
"
open
"
&
&
newVal
!
=
oldVal
)
{
if
(
this
.
open
)
{
this
.
onShow
(
)
;
}
else
{
this
.
onHide
(
)
;
}
}
}
get
open
(
)
{
return
this
.
hasAttribute
(
"
open
"
)
;
}
set
open
(
val
)
{
if
(
val
)
{
this
.
setAttribute
(
"
open
"
"
true
"
)
;
}
else
{
this
.
removeAttribute
(
"
open
"
)
;
}
}
show
(
triggeringEvent
)
{
this
.
open
=
true
;
this
.
triggeringEvent
=
triggeringEvent
;
}
hide
(
triggeringEvent
)
{
this
.
open
=
false
;
this
.
triggeringEvent
=
triggeringEvent
;
}
toggle
(
triggeringEvent
)
{
if
(
this
.
open
)
{
this
.
hide
(
triggeringEvent
)
;
}
else
{
this
.
show
(
triggeringEvent
)
;
}
}
async
setAlign
(
)
{
this
.
setAttribute
(
"
showing
"
"
true
"
)
;
this
.
parentNode
.
style
.
overflow
=
"
hidden
"
;
let
{
height
width
y
left
right
winHeight
winWidth
}
=
await
new
Promise
(
resolve
=
>
{
requestAnimationFrame
(
(
)
=
>
setTimeout
(
(
)
=
>
{
let
{
y
left
right
}
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
parentNode
)
;
let
{
height
width
}
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
)
;
resolve
(
{
height
width
y
left
right
winHeight
:
innerHeight
winWidth
:
innerWidth
}
)
;
}
0
)
)
;
}
)
;
let
align
;
if
(
Services
.
locale
.
isAppLocaleRTL
)
{
align
=
right
-
width
+
14
<
0
?
"
left
"
:
"
right
"
;
}
else
{
align
=
left
+
width
-
14
>
winWidth
?
"
right
"
:
"
left
"
;
}
let
valign
=
y
+
height
+
30
>
winHeight
?
"
top
"
:
"
bottom
"
;
this
.
setAttribute
(
"
align
"
align
)
;
this
.
setAttribute
(
"
valign
"
valign
)
;
this
.
parentNode
.
style
.
overflow
=
"
"
;
this
.
removeAttribute
(
"
showing
"
)
;
requestAnimationFrame
(
(
)
=
>
this
.
sendEvent
(
"
shown
"
)
)
;
}
addHideListeners
(
)
{
this
.
addEventListener
(
"
click
"
this
)
;
document
.
addEventListener
(
"
mousedown
"
this
)
;
document
.
addEventListener
(
"
focusin
"
this
)
;
window
.
addEventListener
(
"
resize
"
this
)
;
window
.
addEventListener
(
"
scroll
"
this
)
;
window
.
addEventListener
(
"
blur
"
this
)
;
}
removeHideListeners
(
)
{
this
.
removeEventListener
(
"
click
"
this
)
;
document
.
removeEventListener
(
"
mousedown
"
this
)
;
document
.
removeEventListener
(
"
focusin
"
this
)
;
window
.
removeEventListener
(
"
resize
"
this
)
;
window
.
removeEventListener
(
"
scroll
"
this
)
;
window
.
removeEventListener
(
"
blur
"
this
)
;
}
handleEvent
(
e
)
{
if
(
e
=
=
this
.
triggeringEvent
)
{
return
;
}
switch
(
e
.
type
)
{
case
"
resize
"
:
case
"
scroll
"
:
case
"
blur
"
:
this
.
hide
(
)
;
break
;
case
"
click
"
:
if
(
e
.
target
.
tagName
=
=
"
PANEL
-
ITEM
"
)
{
this
.
hide
(
)
;
}
break
;
case
"
mousedown
"
:
case
"
focusin
"
:
if
(
!
e
.
target
|
|
e
.
target
.
closest
(
"
panel
-
list
"
)
!
=
this
)
{
this
.
hide
(
)
;
}
break
;
}
}
onShow
(
)
{
this
.
setAlign
(
)
;
this
.
addHideListeners
(
)
;
}
onHide
(
)
{
this
.
removeHideListeners
(
)
;
}
sendEvent
(
name
detail
)
{
this
.
dispatchEvent
(
new
CustomEvent
(
name
{
detail
}
)
)
;
}
}
customElements
.
define
(
"
panel
-
list
"
PanelList
)
;
class
PanelItem
extends
HTMLElement
{
constructor
(
)
{
super
(
)
;
this
.
attachShadow
(
{
mode
:
"
open
"
}
)
;
this
.
shadowRoot
.
appendChild
(
importTemplate
(
"
panel
-
item
"
)
)
;
}
}
customElements
.
define
(
"
panel
-
item
"
PanelItem
)
;
class
AddonCard
extends
HTMLElement
{
constructor
(
)
{
super
(
)
;
this
.
connected
=
false
;
}
connectedCallback
(
)
{
if
(
this
.
connected
)
{
return
;
}
this
.
connected
=
true
;
this
.
render
(
)
;
}
setAddon
(
addon
)
{
this
.
addon
=
addon
;
}
update
(
)
{
let
{
addon
card
}
=
this
;
let
icon
;
if
(
addon
.
type
=
=
"
plugin
"
)
{
icon
=
PLUGIN_ICON_URL
;
}
else
{
icon
=
AddonManager
.
getPreferredIconURL
(
addon
32
window
)
;
}
card
.
querySelector
(
"
.
addon
-
icon
"
)
.
src
=
icon
;
card
.
querySelector
(
"
.
addon
-
name
"
)
.
textContent
=
addon
.
name
;
card
.
querySelector
(
"
.
addon
-
description
"
)
.
textContent
=
addon
.
description
;
let
removeButton
=
card
.
querySelector
(
'
[
action
=
"
remove
"
]
'
)
;
removeButton
.
hidden
=
!
hasPermission
(
addon
"
uninstall
"
)
;
let
disableButton
=
card
.
querySelector
(
'
[
action
=
"
toggle
-
disabled
"
]
'
)
;
let
disableAction
=
addon
.
userDisabled
?
"
enable
"
:
"
disable
"
;
document
.
l10n
.
setAttributes
(
disableButton
{
disableAction
}
-
addon
-
button
)
;
disableButton
.
hidden
=
!
hasPermission
(
addon
disableAction
)
;
let
separator
=
card
.
querySelector
(
"
panel
-
item
-
separator
"
)
;
separator
.
hidden
=
removeButton
.
hidden
&
&
disableButton
.
hidden
;
}
render
(
)
{
this
.
textContent
=
"
"
;
let
{
addon
}
=
this
;
if
(
!
addon
)
{
throw
new
Error
(
"
addon
-
card
must
be
initialized
with
setAddon
(
)
"
)
;
}
this
.
card
=
importTemplate
(
"
card
"
)
.
firstElementChild
;
this
.
setAttribute
(
"
addon
-
id
"
addon
.
id
)
;
this
.
update
(
)
;
let
panel
=
this
.
card
.
querySelector
(
"
panel
-
list
"
)
;
let
moreOptionsButton
=
this
.
card
.
querySelector
(
'
[
action
=
"
more
-
options
"
]
'
)
;
moreOptionsButton
.
addEventListener
(
"
mousedown
"
(
e
)
=
>
{
panel
.
toggle
(
e
)
;
}
)
;
moreOptionsButton
.
addEventListener
(
"
click
"
(
e
)
=
>
{
if
(
e
.
mozInputSource
=
=
MouseEvent
.
MOZ_SOURCE_KEYBOARD
)
{
panel
.
toggle
(
e
)
;
}
}
)
;
panel
.
addEventListener
(
"
click
"
async
(
e
)
=
>
{
let
action
=
e
.
target
.
getAttribute
(
"
action
"
)
;
switch
(
action
)
{
case
"
toggle
-
disabled
"
:
if
(
addon
.
userDisabled
)
{
await
addon
.
enable
(
)
;
}
else
{
await
addon
.
disable
(
)
;
}
if
(
e
.
mozInputSource
=
=
MouseEvent
.
MOZ_SOURCE_KEYBOARD
)
{
this
.
querySelector
(
'
[
action
=
"
more
-
options
"
]
'
)
.
focus
(
)
;
}
break
;
case
"
remove
"
:
await
addon
.
uninstall
(
)
;
break
;
}
}
)
;
this
.
appendChild
(
this
.
card
)
;
}
}
customElements
.
define
(
"
addon
-
card
"
AddonCard
)
;
class
AddonList
extends
HTMLElement
{
constructor
(
)
{
super
(
)
;
this
.
connected
=
false
;
this
.
sections
=
[
]
;
}
async
connectedCallback
(
)
{
if
(
this
.
connected
)
{
return
;
}
this
.
connected
=
true
;
this
.
registerListener
(
)
;
this
.
render
(
await
this
.
getAddons
(
)
)
;
}
disconnectedCallback
(
)
{
this
.
connected
=
false
;
this
.
textContent
=
"
"
;
this
.
removeListener
(
)
;
}
setSections
(
sections
)
{
this
.
sections
=
sections
.
map
(
section
=
>
Object
.
assign
(
{
}
section
)
)
;
}
set
type
(
val
)
{
this
.
setAttribute
(
"
type
"
val
)
;
}
get
type
(
)
{
return
this
.
getAttribute
(
"
type
"
)
;
}
getSection
(
index
)
{
return
this
.
sections
[
index
]
.
node
;
}
getCards
(
section
)
{
return
section
.
querySelectorAll
(
"
addon
-
card
"
)
;
}
getCard
(
addon
)
{
return
this
.
querySelector
(
addon
-
card
[
addon
-
id
=
"
{
addon
.
id
}
"
]
)
;
}
sortByFn
(
aAddon
bAddon
)
{
return
aAddon
.
name
.
localeCompare
(
bAddon
.
name
)
;
}
async
getAddons
(
)
{
if
(
!
this
.
type
)
{
throw
new
Error
(
type
must
be
set
to
find
add
-
ons
)
;
}
let
addons
=
await
AddonManager
.
getAddonsByTypes
(
[
this
.
type
]
)
;
addons
.
sort
(
this
.
sortByFn
)
;
let
sectionedAddons
=
this
.
sections
.
map
(
(
)
=
>
[
]
)
;
for
(
let
addon
of
addons
)
{
let
index
=
this
.
sections
.
findIndex
(
(
{
filterFn
}
)
=
>
filterFn
(
addon
)
)
;
if
(
index
!
=
-
1
)
{
sectionedAddons
[
index
]
.
push
(
addon
)
;
}
}
return
sectionedAddons
;
}
createSectionHeading
(
headingIndex
)
{
let
{
headingId
}
=
this
.
sections
[
headingIndex
]
;
let
heading
=
document
.
createElement
(
"
h2
"
)
;
heading
.
classList
.
add
(
"
list
-
section
-
heading
"
)
;
document
.
l10n
.
setAttributes
(
heading
headingId
)
;
return
heading
;
}
updateSectionIfEmpty
(
section
)
{
if
(
section
.
children
.
length
=
=
1
)
{
section
.
textContent
=
"
"
;
}
}
insertCardInto
(
card
sectionIndex
)
{
let
section
=
this
.
getSection
(
sectionIndex
)
;
let
sectionCards
=
this
.
getCards
(
section
)
;
if
(
sectionCards
.
length
=
=
0
)
{
section
.
appendChild
(
this
.
createSectionHeading
(
sectionIndex
)
)
;
}
let
insertBefore
=
Array
.
from
(
sectionCards
)
.
find
(
otherCard
=
>
this
.
sortByFn
(
card
.
addon
otherCard
.
addon
)
<
0
)
;
section
.
insertBefore
(
card
insertBefore
|
|
null
)
;
}
addAddon
(
addon
)
{
if
(
addon
.
type
!
=
this
.
type
)
{
this
.
sendEvent
(
"
skip
-
add
"
"
type
-
mismatch
"
)
;
return
;
}
let
insertSection
=
this
.
sections
.
findIndex
(
(
{
filterFn
}
)
=
>
filterFn
(
addon
)
)
;
if
(
insertSection
=
=
-
1
)
{
return
;
}
let
card
=
document
.
createElement
(
"
addon
-
card
"
)
;
card
.
setAddon
(
addon
)
;
this
.
insertCardInto
(
card
insertSection
)
;
this
.
sendEvent
(
"
add
"
{
id
:
addon
.
id
}
)
;
}
sendEvent
(
name
detail
)
{
this
.
dispatchEvent
(
new
CustomEvent
(
name
{
detail
}
)
)
;
}
removeAddon
(
addon
)
{
let
card
=
this
.
getCard
(
addon
)
;
if
(
card
)
{
let
section
=
card
.
parentNode
;
card
.
remove
(
)
;
this
.
updateSectionIfEmpty
(
section
)
;
this
.
sendEvent
(
"
remove
"
{
id
:
addon
.
id
}
)
;
}
}
updateAddon
(
addon
)
{
let
card
=
this
.
getCard
(
addon
)
;
if
(
card
)
{
let
sectionIndex
=
this
.
sections
.
findIndex
(
s
=
>
s
.
filterFn
(
addon
)
)
;
if
(
sectionIndex
!
=
-
1
)
{
card
.
update
(
)
;
if
(
card
.
parentNode
.
getAttribute
(
"
section
"
)
!
=
sectionIndex
)
{
let
oldSection
=
card
.
parentNode
;
this
.
insertCardInto
(
card
sectionIndex
)
;
this
.
updateSectionIfEmpty
(
oldSection
)
;
this
.
sendEvent
(
"
move
"
{
id
:
addon
.
id
}
)
;
}
else
{
this
.
sendEvent
(
"
update
"
{
id
:
addon
.
id
}
)
;
}
}
else
{
this
.
removeAddon
(
addon
)
;
}
}
else
{
this
.
addAddon
(
addon
)
;
}
}
renderSection
(
addons
index
)
{
let
section
=
document
.
createElement
(
"
section
"
)
;
section
.
setAttribute
(
"
section
"
index
)
;
if
(
addons
.
length
>
0
)
{
section
.
appendChild
(
this
.
createSectionHeading
(
index
)
)
;
for
(
let
addon
of
addons
)
{
let
card
=
document
.
createElement
(
"
addon
-
card
"
)
;
card
.
setAddon
(
addon
)
;
section
.
appendChild
(
card
)
;
}
}
return
section
;
}
render
(
sectionedAddons
)
{
this
.
textContent
=
"
"
;
let
frag
=
document
.
createDocumentFragment
(
)
;
for
(
let
i
=
0
;
i
<
sectionedAddons
.
length
;
i
+
+
)
{
this
.
sections
[
i
]
.
node
=
this
.
renderSection
(
sectionedAddons
[
i
]
i
)
;
frag
.
appendChild
(
this
.
sections
[
i
]
.
node
)
;
}
this
.
appendChild
(
frag
)
;
this
.
sendEvent
(
"
rendered
"
)
;
}
registerListener
(
)
{
AddonManager
.
addAddonListener
(
this
)
;
}
removeListener
(
)
{
AddonManager
.
removeAddonListener
(
this
)
;
}
onEnabled
(
addon
)
{
this
.
updateAddon
(
addon
)
;
}
onDisabled
(
addon
)
{
this
.
updateAddon
(
addon
)
;
}
onInstalled
(
addon
)
{
this
.
addAddon
(
addon
)
;
}
onUninstalled
(
addon
)
{
this
.
removeAddon
(
addon
)
;
}
}
customElements
.
define
(
"
addon
-
list
"
AddonList
)
;
class
ListView
{
constructor
(
{
param
root
}
)
{
this
.
type
=
param
;
this
.
root
=
root
;
}
async
render
(
)
{
let
list
=
document
.
createElement
(
"
addon
-
list
"
)
;
list
.
type
=
this
.
type
;
list
.
setSections
(
[
{
headingId
:
"
addons
-
enabled
-
heading
"
filterFn
:
addon
=
>
!
addon
.
hidden
&
&
addon
.
isActive
}
{
headingId
:
"
addons
-
disabled
-
heading
"
filterFn
:
addon
=
>
!
addon
.
hidden
&
&
!
addon
.
isActive
}
]
)
;
await
new
Promise
(
resolve
=
>
{
list
.
addEventListener
(
"
rendered
"
resolve
{
once
:
true
}
)
;
this
.
root
.
textContent
=
"
"
;
this
.
root
.
appendChild
(
list
)
;
}
)
;
}
}
let
root
=
null
;
function
initialize
(
)
{
root
=
document
.
getElementById
(
"
main
"
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
root
.
textContent
=
"
"
;
}
{
once
:
true
}
)
;
}
async
function
show
(
type
param
)
{
if
(
type
=
=
"
list
"
)
{
await
new
ListView
(
{
param
root
}
)
.
render
(
)
;
}
}
function
hide
(
)
{
root
.
textContent
=
"
"
;
}
