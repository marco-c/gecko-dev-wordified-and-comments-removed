"
use
strict
"
;
function
loadView
(
viewId
)
{
if
(
!
gViewController
.
readyForLoadView
)
{
throw
new
Error
(
"
loadView
called
before
about
:
addons
is
initialized
"
)
;
}
gViewController
.
loadView
(
viewId
)
;
}
var
ScrollOffsets
=
{
_key
:
null
_offsets
:
new
Map
(
)
canRestore
:
true
setView
(
historyEntryId
)
{
this
.
_key
=
historyEntryId
;
this
.
canRestore
=
true
;
}
getPosition
(
)
{
if
(
!
this
.
canRestore
)
{
return
{
top
:
0
left
:
0
}
;
}
let
{
scrollTop
:
top
scrollLeft
:
left
}
=
document
.
documentElement
;
return
{
top
left
}
;
}
save
(
)
{
if
(
this
.
_key
)
{
this
.
_offsets
.
set
(
this
.
_key
this
.
getPosition
(
)
)
;
}
}
restore
(
)
{
let
{
top
=
0
left
=
0
}
=
this
.
_offsets
.
get
(
this
.
_key
)
|
|
{
}
;
window
.
scrollTo
(
{
top
left
behavior
:
"
auto
"
}
)
;
}
}
;
var
gViewController
=
{
currentViewId
:
null
readyForLoadView
:
false
get
defaultViewId
(
)
{
if
(
!
isDiscoverEnabled
(
)
)
{
return
"
addons
:
/
/
list
/
extension
"
;
}
return
"
addons
:
/
/
discover
/
"
;
}
isLoading
:
true
nextHistoryEntryId
:
Math
.
floor
(
Math
.
random
(
)
*
2
*
*
32
)
views
:
{
}
initialize
(
container
)
{
this
.
container
=
container
;
window
.
addEventListener
(
"
popstate
"
this
)
;
window
.
addEventListener
(
"
unload
"
this
{
once
:
true
}
)
;
Services
.
obs
.
addObserver
(
this
"
EM
-
ping
"
)
;
}
handleEvent
(
e
)
{
if
(
e
.
type
=
=
"
popstate
"
)
{
this
.
renderState
(
e
.
state
)
;
return
;
}
if
(
e
.
type
=
=
"
unload
"
)
{
Services
.
obs
.
removeObserver
(
this
"
EM
-
ping
"
)
;
return
;
}
}
observe
(
subject
topic
)
{
if
(
topic
=
=
"
EM
-
ping
"
)
{
this
.
readyForLoadView
=
true
;
Services
.
obs
.
notifyObservers
(
window
"
EM
-
pong
"
)
;
}
}
notifyEMLoaded
(
)
{
this
.
readyForLoadView
=
true
;
Services
.
obs
.
notifyObservers
(
window
"
EM
-
loaded
"
)
;
}
notifyEMUpdateCheckFinished
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
EM
-
update
-
check
-
finished
"
)
;
}
defineView
(
viewName
renderFunction
)
{
if
(
this
.
views
[
viewName
]
)
{
throw
new
Error
(
about
:
addons
view
{
viewName
}
should
not
be
defined
twice
)
;
}
this
.
views
[
viewName
]
=
renderFunction
;
}
parseViewId
(
viewId
)
{
const
matchRegex
=
/
^
addons
:
\
/
\
/
(
[
^
\
/
]
+
)
\
/
(
.
*
)
/
;
const
[
viewType
viewParam
]
=
viewId
.
match
(
matchRegex
)
|
|
[
]
;
return
{
type
:
viewType
param
:
decodeURIComponent
(
viewParam
)
}
;
}
loadView
(
viewId
replace
=
false
)
{
viewId
=
viewId
.
startsWith
(
"
addons
:
/
/
"
)
?
viewId
:
addons
:
/
/
{
viewId
}
;
if
(
viewId
=
=
this
.
currentViewId
)
{
return
Promise
.
resolve
(
)
;
}
replace
=
replace
|
|
!
this
.
currentViewId
;
const
state
=
{
view
:
viewId
previousView
:
replace
?
null
:
this
.
currentViewId
historyEntryId
:
+
+
this
.
nextHistoryEntryId
}
;
if
(
replace
)
{
history
.
replaceState
(
state
"
"
)
;
}
else
{
history
.
pushState
(
state
"
"
)
;
}
return
this
.
renderState
(
state
)
;
}
async
renderState
(
state
)
{
let
{
param
type
}
=
this
.
parseViewId
(
state
.
view
)
;
if
(
!
type
|
|
this
.
views
[
type
]
=
=
null
)
{
console
.
warn
(
No
view
for
{
type
}
{
param
}
switching
to
default
)
;
this
.
resetState
(
)
;
return
;
}
ScrollOffsets
.
save
(
)
;
ScrollOffsets
.
setView
(
state
.
historyEntryId
)
;
this
.
currentViewId
=
state
.
view
;
this
.
isLoading
=
true
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
view
-
selected
"
{
detail
:
{
id
:
state
.
view
param
type
}
}
)
)
;
this
.
container
.
setAttribute
(
"
current
-
view
"
type
)
;
let
fragment
=
await
this
.
views
[
type
]
(
param
)
;
if
(
fragment
)
{
this
.
container
.
textContent
=
"
"
;
this
.
container
.
append
(
fragment
)
;
await
new
Promise
(
resolve
=
>
{
window
.
requestAnimationFrame
(
(
)
=
>
{
window
.
requestAnimationFrame
(
async
(
)
=
>
{
if
(
document
.
hasPendingL10nMutations
)
{
await
new
Promise
(
r
=
>
{
document
.
addEventListener
(
"
L10nMutationsFinished
"
r
{
once
:
true
}
)
;
}
)
;
}
ScrollOffsets
.
restore
(
)
;
resolve
(
)
;
}
)
;
}
)
;
}
)
;
}
else
{
this
.
resetState
(
)
;
return
;
}
this
.
isLoading
=
false
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
view
-
loaded
"
)
)
;
}
resetState
(
)
{
return
this
.
loadView
(
this
.
defaultViewId
true
)
;
}
}
;
