"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AddonManagerPrivate
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AddonRepository
:
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonRepository
.
jsm
"
DeferredTask
:
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
Blocklist
"
"
mozilla
.
org
/
extensions
/
blocklist
;
1
"
Ci
.
nsIBlocklistService
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
LOGGER_ID
=
"
addons
.
xpi
-
utils
"
;
const
nsIFile
=
Components
.
Constructor
(
"
mozilla
.
org
/
file
/
local
;
1
"
"
nsIFile
"
"
initWithPath
"
)
;
var
logger
=
Log
.
repository
.
getLogger
(
LOGGER_ID
)
;
const
KEY_PROFILEDIR
=
"
ProfD
"
;
const
FILE_JSON_DB
=
"
extensions
.
json
"
;
const
LAST_SQLITE_DB_SCHEMA
=
14
;
const
PREF_DB_SCHEMA
=
"
extensions
.
databaseSchema
"
;
const
PREF_PENDING_OPERATIONS
=
"
extensions
.
pendingOperations
"
;
const
PREF_EM_AUTO_DISABLED_SCOPES
=
"
extensions
.
autoDisableScopes
"
;
const
KEY_APP_SYSTEM_ADDONS
=
"
app
-
system
-
addons
"
;
const
KEY_APP_SYSTEM_DEFAULTS
=
"
app
-
system
-
defaults
"
;
const
KEY_APP_GLOBAL
=
"
app
-
global
"
;
const
KEY_APP_TEMPORARY
=
"
app
-
temporary
"
;
const
PROP_JSON_FIELDS
=
[
"
id
"
"
syncGUID
"
"
location
"
"
version
"
"
type
"
"
internalName
"
"
updateURL
"
"
updateKey
"
"
optionsURL
"
"
optionsType
"
"
optionsBrowserStyle
"
"
aboutURL
"
"
defaultLocale
"
"
visible
"
"
active
"
"
userDisabled
"
"
appDisabled
"
"
pendingUninstall
"
"
installDate
"
"
updateDate
"
"
applyBackgroundUpdates
"
"
bootstrap
"
"
path
"
"
skinnable
"
"
size
"
"
sourceURI
"
"
releaseNotesURI
"
"
softDisabled
"
"
foreignInstall
"
"
hasBinaryComponents
"
"
strictCompatibility
"
"
locales
"
"
targetApplications
"
"
targetPlatforms
"
"
multiprocessCompatible
"
"
signedState
"
"
seen
"
"
dependencies
"
"
hasEmbeddedWebExtension
"
"
mpcOptedOut
"
"
userPermissions
"
"
icons
"
"
iconURL
"
"
icon64URL
"
"
blocklistState
"
"
blocklistURL
"
"
startupData
"
]
;
const
ASYNC_SAVE_DELAY_MS
=
20
;
function
getRepositoryAddon
(
aAddon
aCallback
)
{
if
(
!
aAddon
)
{
aCallback
(
aAddon
)
;
return
;
}
AddonRepository
.
getCachedAddonByID
(
aAddon
.
id
repoAddon
=
>
{
aAddon
.
_repositoryAddon
=
repoAddon
;
aCallback
(
aAddon
)
;
}
)
;
}
function
makeSafe
(
aCallback
)
{
return
function
(
.
.
.
aArgs
)
{
try
{
aCallback
(
.
.
.
aArgs
)
;
}
catch
(
ex
)
{
logger
.
warn
(
"
XPI
Database
callback
failed
"
ex
)
;
}
}
;
}
function
asyncMap
(
aObjects
aMethod
)
{
let
methodCalls
=
aObjects
.
map
(
obj
=
>
{
return
new
Promise
(
resolve
=
>
{
try
{
aMethod
(
obj
resolve
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Async
map
function
failed
"
e
)
;
resolve
(
undefined
)
;
}
}
)
;
}
)
;
return
Promise
.
all
(
methodCalls
)
;
}
function
copyProperties
(
aObject
aProperties
aTarget
)
{
if
(
!
aTarget
)
aTarget
=
{
}
;
aProperties
.
forEach
(
function
(
aProp
)
{
if
(
aProp
in
aObject
)
aTarget
[
aProp
]
=
aObject
[
aProp
]
;
}
)
;
return
aTarget
;
}
function
DBAddonInternal
(
aLoaded
)
{
AddonInternal
.
call
(
this
)
;
if
(
aLoaded
.
descriptor
)
{
if
(
!
aLoaded
.
path
)
{
aLoaded
.
path
=
descriptorToPath
(
aLoaded
.
descriptor
)
;
}
delete
aLoaded
.
descriptor
;
}
copyProperties
(
aLoaded
PROP_JSON_FIELDS
this
)
;
if
(
!
this
.
dependencies
)
this
.
dependencies
=
[
]
;
Object
.
freeze
(
this
.
dependencies
)
;
if
(
aLoaded
.
_installLocation
)
{
this
.
_installLocation
=
aLoaded
.
_installLocation
;
this
.
location
=
aLoaded
.
_installLocation
.
name
;
}
else
if
(
aLoaded
.
location
)
{
this
.
_installLocation
=
XPIProvider
.
installLocationsByName
[
this
.
location
]
;
}
this
.
_key
=
this
.
location
+
"
:
"
+
this
.
id
;
if
(
!
aLoaded
.
_sourceBundle
)
{
throw
new
Error
(
"
Expected
passed
argument
to
contain
a
path
"
)
;
}
this
.
_sourceBundle
=
aLoaded
.
_sourceBundle
;
XPCOMUtils
.
defineLazyGetter
(
this
"
pendingUpgrade
"
function
(
)
{
for
(
let
install
of
XPIProvider
.
installs
)
{
if
(
install
.
state
=
=
AddonManager
.
STATE_INSTALLED
&
&
!
(
install
.
addon
.
inDatabase
)
&
&
install
.
addon
.
id
=
=
this
.
id
&
&
install
.
installLocation
=
=
this
.
_installLocation
)
{
delete
this
.
pendingUpgrade
;
return
this
.
pendingUpgrade
=
install
.
addon
;
}
}
return
null
;
}
)
;
}
DBAddonInternal
.
prototype
=
Object
.
create
(
AddonInternal
.
prototype
)
;
Object
.
assign
(
DBAddonInternal
.
prototype
{
applyCompatibilityUpdate
(
aUpdate
aSyncCompatibility
)
{
let
wasCompatible
=
this
.
isCompatible
;
this
.
targetApplications
.
forEach
(
function
(
aTargetApp
)
{
aUpdate
.
targetApplications
.
forEach
(
function
(
aUpdateTarget
)
{
if
(
aTargetApp
.
id
=
=
aUpdateTarget
.
id
&
&
(
aSyncCompatibility
|
|
Services
.
vc
.
compare
(
aTargetApp
.
maxVersion
aUpdateTarget
.
maxVersion
)
<
0
)
)
{
aTargetApp
.
minVersion
=
aUpdateTarget
.
minVersion
;
aTargetApp
.
maxVersion
=
aUpdateTarget
.
maxVersion
;
XPIDatabase
.
saveChanges
(
)
;
}
}
)
;
}
)
;
if
(
aUpdate
.
multiprocessCompatible
!
=
=
undefined
&
&
aUpdate
.
multiprocessCompatible
!
=
this
.
multiprocessCompatible
)
{
this
.
multiprocessCompatible
=
aUpdate
.
multiprocessCompatible
;
XPIDatabase
.
saveChanges
(
)
;
}
if
(
wasCompatible
!
=
this
.
isCompatible
)
XPIProvider
.
updateAddonDisabledState
(
this
)
;
}
toJSON
(
)
{
let
jsonData
=
copyProperties
(
this
PROP_JSON_FIELDS
)
;
if
(
this
.
type
=
=
"
experiment
"
)
{
jsonData
.
userDisabled
=
true
;
jsonData
.
active
=
false
;
}
return
jsonData
;
}
get
inDatabase
(
)
{
return
true
;
}
}
)
;
function
_findAddon
(
addonDB
aFilter
)
{
for
(
let
addon
of
addonDB
.
values
(
)
)
{
if
(
aFilter
(
addon
)
)
{
return
addon
;
}
}
return
null
;
}
function
_filterDB
(
addonDB
aFilter
)
{
return
Array
.
from
(
addonDB
.
values
(
)
)
.
filter
(
aFilter
)
;
}
this
.
XPIDatabase
=
{
initialized
:
false
jsonFile
:
FileUtils
.
getFile
(
KEY_PROFILEDIR
[
FILE_JSON_DB
]
true
)
migrateData
:
null
activeBundles
:
null
_saveTask
:
null
_loadError
:
null
_saveError
:
null
get
lastError
(
)
{
if
(
this
.
_loadError
)
return
this
.
_loadError
;
if
(
this
.
_saveError
)
return
this
.
_saveError
;
return
null
;
}
async
_saveNow
(
)
{
try
{
let
json
=
JSON
.
stringify
(
this
)
;
let
path
=
this
.
jsonFile
.
path
;
await
OS
.
File
.
writeAtomic
(
path
json
{
tmpPath
:
{
path
}
.
tmp
}
)
;
if
(
!
this
.
_schemaVersionSet
)
{
logger
.
debug
(
"
XPI
Database
saved
setting
schema
version
preference
to
"
+
DB_SCHEMA
)
;
Services
.
prefs
.
setIntPref
(
PREF_DB_SCHEMA
DB_SCHEMA
)
;
this
.
_schemaVersionSet
=
true
;
this
.
_loadError
=
null
;
}
}
catch
(
error
)
{
logger
.
warn
(
"
Failed
to
save
XPI
database
"
error
)
;
this
.
_saveError
=
error
;
throw
error
;
}
}
saveChanges
(
)
{
if
(
!
this
.
initialized
)
{
throw
new
Error
(
"
Attempt
to
use
XPI
database
when
it
is
not
initialized
"
)
;
}
if
(
XPIProvider
.
_closing
)
{
let
err
=
new
Error
(
"
XPI
database
modified
after
shutdown
began
"
)
;
logger
.
warn
(
err
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_late_stack
"
Log
.
stackTrace
(
err
)
)
;
}
if
(
!
this
.
_saveTask
)
{
this
.
_saveTask
=
new
DeferredTask
(
(
)
=
>
this
.
_saveNow
(
)
ASYNC_SAVE_DELAY_MS
)
;
}
this
.
_saveTask
.
arm
(
)
;
}
async
finalize
(
)
{
if
(
!
this
.
_saveTask
)
{
return
;
}
await
this
.
_saveTask
.
finalize
(
)
;
}
toJSON
(
)
{
if
(
!
this
.
addonDB
)
{
throw
new
Error
(
"
Attempt
to
save
database
without
loading
it
first
"
)
;
}
let
toSave
=
{
schemaVersion
:
DB_SCHEMA
addons
:
Array
.
from
(
this
.
addonDB
.
values
(
)
)
.
filter
(
addon
=
>
addon
.
location
!
=
KEY_APP_TEMPORARY
)
}
;
return
toSave
;
}
syncLoadDB
(
aRebuildOnError
)
{
this
.
migrateData
=
null
;
let
fstream
=
null
;
let
data
=
"
"
;
try
{
let
readTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_syncRead_MS
"
)
;
logger
.
debug
(
"
Opening
XPI
database
"
+
this
.
jsonFile
.
path
)
;
fstream
=
Components
.
classes
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIFileInputStream
)
;
fstream
.
init
(
this
.
jsonFile
-
1
0
0
)
;
let
cstream
=
null
;
try
{
cstream
=
Components
.
classes
[
"
mozilla
.
org
/
intl
/
converter
-
input
-
stream
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIConverterInputStream
)
;
cstream
.
init
(
fstream
"
UTF
-
8
"
0
0
)
;
let
str
=
{
}
;
let
read
=
0
;
do
{
read
=
cstream
.
readString
(
0xffffffff
str
)
;
data
+
=
str
.
value
;
}
while
(
read
!
=
0
)
;
readTimer
.
done
(
)
;
this
.
parseDB
(
data
aRebuildOnError
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
load
XPI
JSON
data
from
profile
"
e
)
;
let
rebuildTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_rebuildReadFailed_MS
"
)
;
this
.
rebuildDatabase
(
aRebuildOnError
)
;
rebuildTimer
.
done
(
)
;
}
finally
{
if
(
cstream
)
cstream
.
close
(
)
;
}
}
catch
(
e
)
{
if
(
e
.
result
=
=
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
{
this
.
upgradeDB
(
aRebuildOnError
)
;
}
else
{
this
.
rebuildUnreadableDB
(
e
aRebuildOnError
)
;
}
}
finally
{
if
(
fstream
)
fstream
.
close
(
)
;
}
if
(
this
.
_dbPromise
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_overlapped_load
"
1
)
;
}
this
.
_dbPromise
=
Promise
.
resolve
(
this
.
addonDB
)
;
Services
.
obs
.
notifyObservers
(
this
.
addonDB
"
xpi
-
database
-
loaded
"
)
;
}
parseDB
(
aData
aRebuildOnError
)
{
let
parseTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_parseDB_MS
"
)
;
try
{
let
inputAddons
=
JSON
.
parse
(
aData
)
;
if
(
!
(
"
schemaVersion
"
in
inputAddons
)
|
|
!
(
"
addons
"
in
inputAddons
)
)
{
parseTimer
.
done
(
)
;
logger
.
error
(
"
bad
JSON
file
contents
"
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startupError
"
"
badJSON
"
)
;
let
rebuildTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_rebuildBadJSON_MS
"
)
;
this
.
rebuildDatabase
(
aRebuildOnError
)
;
rebuildTimer
.
done
(
)
;
return
;
}
if
(
inputAddons
.
schemaVersion
!
=
DB_SCHEMA
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startupError
"
"
schemaMismatch
-
"
+
inputAddons
.
schemaVersion
)
;
logger
.
debug
(
"
JSON
schema
mismatch
:
expected
"
+
DB_SCHEMA
+
"
actual
"
+
inputAddons
.
schemaVersion
)
;
}
let
addonDB
=
new
Map
(
)
;
for
(
let
loadedAddon
of
inputAddons
.
addons
)
{
try
{
if
(
!
loadedAddon
.
path
)
{
loadedAddon
.
path
=
descriptorToPath
(
loadedAddon
.
descriptor
)
;
}
loadedAddon
.
_sourceBundle
=
new
nsIFile
(
loadedAddon
.
path
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Could
not
find
source
bundle
for
add
-
on
"
+
loadedAddon
.
id
e
)
;
}
let
newAddon
=
new
DBAddonInternal
(
loadedAddon
)
;
addonDB
.
set
(
newAddon
.
_key
newAddon
)
;
}
parseTimer
.
done
(
)
;
this
.
addonDB
=
addonDB
;
logger
.
debug
(
"
Successfully
read
XPI
database
"
)
;
this
.
initialized
=
true
;
}
catch
(
e
)
{
parseTimer
.
done
(
)
;
if
(
e
.
name
=
=
"
SyntaxError
"
)
{
logger
.
error
(
"
Syntax
error
parsing
saved
XPI
JSON
data
"
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startupError
"
"
syntax
"
)
;
}
else
{
logger
.
error
(
"
Failed
to
load
XPI
JSON
data
from
profile
"
e
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startupError
"
"
other
"
)
;
}
let
rebuildTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_rebuildReadFailed_MS
"
)
;
this
.
rebuildDatabase
(
aRebuildOnError
)
;
rebuildTimer
.
done
(
)
;
}
}
upgradeDB
(
aRebuildOnError
)
{
let
upgradeTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_upgradeDB_MS
"
)
;
let
schemaVersion
=
Services
.
prefs
.
getIntPref
(
PREF_DB_SCHEMA
0
)
;
if
(
schemaVersion
>
LAST_SQLITE_DB_SCHEMA
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startupError
"
"
dbMissing
"
)
;
}
this
.
rebuildDatabase
(
aRebuildOnError
)
;
upgradeTimer
.
done
(
)
;
}
rebuildUnreadableDB
(
aError
aRebuildOnError
)
{
let
rebuildTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_rebuildUnreadableDB_MS
"
)
;
logger
.
warn
(
"
Extensions
database
"
+
this
.
jsonFile
.
path
+
"
exists
but
is
not
readable
;
rebuilding
"
aError
)
;
this
.
_loadError
=
aError
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startupError
"
"
unreadable
"
)
;
this
.
rebuildDatabase
(
aRebuildOnError
)
;
rebuildTimer
.
done
(
)
;
}
asyncLoadDB
(
)
{
if
(
this
.
_dbPromise
)
{
return
this
.
_dbPromise
;
}
logger
.
debug
(
"
Starting
async
load
of
XPI
database
"
+
this
.
jsonFile
.
path
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_async_load
"
XPIProvider
.
runPhase
)
;
let
readOptions
=
{
outExecutionDuration
:
0
}
;
this
.
_dbPromise
=
OS
.
File
.
read
(
this
.
jsonFile
.
path
null
readOptions
)
.
then
(
byteArray
=
>
{
logger
.
debug
(
"
Async
JSON
file
read
took
"
+
readOptions
.
outExecutionDuration
+
"
MS
"
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_asyncRead_MS
"
readOptions
.
outExecutionDuration
)
;
if
(
this
.
addonDB
)
{
logger
.
debug
(
"
Synchronous
load
completed
while
waiting
for
async
load
"
)
;
return
this
.
addonDB
;
}
logger
.
debug
(
"
Finished
async
read
of
XPI
database
parsing
.
.
.
"
)
;
let
decodeTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_decode_MS
"
)
;
let
decoder
=
new
TextDecoder
(
)
;
let
data
=
decoder
.
decode
(
byteArray
)
;
decodeTimer
.
done
(
)
;
this
.
parseDB
(
data
true
)
;
return
this
.
addonDB
;
}
)
.
catch
(
error
=
>
{
if
(
this
.
addonDB
)
{
logger
.
debug
(
"
Synchronous
load
completed
while
waiting
for
async
load
"
)
;
return
this
.
addonDB
;
}
if
(
error
.
becauseNoSuchFile
)
{
this
.
upgradeDB
(
true
)
;
}
else
{
this
.
rebuildUnreadableDB
(
error
true
)
;
}
return
this
.
addonDB
;
}
)
;
this
.
_dbPromise
.
then
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
this
.
addonDB
"
xpi
-
database
-
loaded
"
)
;
}
)
;
return
this
.
_dbPromise
;
}
rebuildDatabase
(
aRebuildOnError
)
{
this
.
addonDB
=
new
Map
(
)
;
this
.
initialized
=
true
;
if
(
XPIStates
.
size
=
=
0
)
{
logger
.
debug
(
"
Rebuilding
XPI
database
with
no
extensions
"
)
;
return
;
}
if
(
!
this
.
migrateData
)
{
this
.
activeBundles
=
Array
.
from
(
XPIStates
.
initialEnabledAddons
(
)
addon
=
>
addon
.
path
)
;
if
(
!
this
.
activeBundles
.
length
)
this
.
activeBundles
=
null
;
}
if
(
aRebuildOnError
)
{
logger
.
warn
(
"
Rebuilding
add
-
ons
database
from
installed
extensions
.
"
)
;
try
{
XPIDatabaseReconcile
.
processFileChanges
(
{
}
false
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
rebuild
XPI
database
from
installed
extensions
"
e
)
;
}
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
true
)
;
}
}
async
shutdown
(
)
{
logger
.
debug
(
"
shutdown
"
)
;
if
(
this
.
initialized
)
{
if
(
this
.
lastError
)
this
.
saveChanges
(
)
;
this
.
initialized
=
false
;
if
(
this
.
_dbPromise
)
{
await
this
.
_dbPromise
;
}
await
this
.
finalize
(
)
;
if
(
this
.
_saveError
)
{
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
true
)
;
}
delete
this
.
addonDB
;
delete
this
.
_dbPromise
;
delete
this
.
_saveTask
;
delete
this
.
_schemaVersionSet
;
}
}
async
getAddonList
(
aFilter
aCallback
)
{
try
{
let
addonDB
=
await
this
.
asyncLoadDB
(
)
;
let
addonList
=
_filterDB
(
addonDB
aFilter
)
;
let
addons
=
await
asyncMap
(
addonList
getRepositoryAddon
)
;
if
(
aCallback
)
{
makeSafe
(
aCallback
)
(
addons
)
;
}
return
addons
;
}
catch
(
error
)
{
logger
.
error
(
"
getAddonList
failed
"
error
)
;
if
(
aCallback
)
{
makeSafe
(
aCallback
)
(
[
]
)
;
}
return
[
]
;
}
}
getAddon
(
aFilter
aCallback
)
{
return
this
.
asyncLoadDB
(
)
.
then
(
addonDB
=
>
{
getRepositoryAddon
(
_findAddon
(
addonDB
aFilter
)
makeSafe
(
aCallback
)
)
;
}
)
.
catch
(
error
=
>
{
logger
.
error
(
"
getAddon
failed
"
error
)
;
makeSafe
(
aCallback
)
(
null
)
;
}
)
;
}
getAddonInLocation
(
aId
aLocation
aCallback
)
{
this
.
asyncLoadDB
(
)
.
then
(
addonDB
=
>
getRepositoryAddon
(
addonDB
.
get
(
aLocation
+
"
:
"
+
aId
)
makeSafe
(
aCallback
)
)
)
;
}
getAddonsInLocation
(
aLocation
aCallback
)
{
this
.
getAddonList
(
aAddon
=
>
aAddon
.
_installLocation
.
name
=
=
aLocation
aCallback
)
;
}
getVisibleAddonForID
(
aId
aCallback
)
{
this
.
getAddon
(
aAddon
=
>
(
(
aAddon
.
id
=
=
aId
)
&
&
aAddon
.
visible
)
aCallback
)
;
}
getVisibleAddons
(
aTypes
aCallback
)
{
this
.
getAddonList
(
aAddon
=
>
(
aAddon
.
visible
&
&
(
!
aTypes
|
|
(
aTypes
.
length
=
=
0
)
|
|
(
aTypes
.
indexOf
(
aAddon
.
type
)
>
-
1
)
)
)
aCallback
)
;
}
getAddonsByType
(
.
.
.
aTypes
)
{
if
(
!
this
.
addonDB
)
{
logger
.
warn
(
Synchronous
load
of
XPI
database
due
to
+
getAddonsByType
(
[
{
aTypes
.
join
(
"
"
)
}
]
)
+
Stack
:
{
Error
(
)
.
stack
}
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_lateOpen_byType
"
XPIProvider
.
runPhase
)
;
this
.
syncLoadDB
(
true
)
;
}
return
_filterDB
(
this
.
addonDB
aAddon
=
>
aTypes
.
includes
(
aAddon
.
type
)
)
;
}
getVisibleAddonForInternalName
(
aInternalName
)
{
if
(
!
this
.
addonDB
)
{
logger
.
warn
(
Synchronous
load
of
XPI
database
due
to
+
getVisibleAddonForInternalName
.
Stack
:
{
Error
(
)
.
stack
}
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_lateOpen_forInternalName
"
XPIProvider
.
runPhase
)
;
this
.
syncLoadDB
(
true
)
;
}
return
_findAddon
(
this
.
addonDB
aAddon
=
>
aAddon
.
visible
&
&
(
aAddon
.
internalName
=
=
aInternalName
)
)
;
}
getVisibleAddonsWithPendingOperations
(
aTypes
aCallback
)
{
this
.
getAddonList
(
aAddon
=
>
(
aAddon
.
visible
&
&
(
aAddon
.
pendingUninstall
|
|
(
aAddon
.
active
=
=
aAddon
.
disabled
)
)
&
&
(
!
aTypes
|
|
(
aTypes
.
length
=
=
0
)
|
|
(
aTypes
.
indexOf
(
aAddon
.
type
)
>
-
1
)
)
)
aCallback
)
;
}
getAddonBySyncGUID
(
aGUID
aCallback
)
{
this
.
getAddon
(
aAddon
=
>
aAddon
.
syncGUID
=
=
aGUID
aCallback
)
;
}
getAddons
(
)
{
if
(
!
this
.
addonDB
)
{
return
[
]
;
}
return
_filterDB
(
this
.
addonDB
aAddon
=
>
true
)
;
}
addAddonMetadata
(
aAddon
aPath
)
{
if
(
!
this
.
addonDB
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_lateOpen_addMetadata
"
XPIProvider
.
runPhase
)
;
this
.
syncLoadDB
(
false
)
;
}
let
newAddon
=
new
DBAddonInternal
(
aAddon
)
;
newAddon
.
path
=
aPath
;
this
.
addonDB
.
set
(
newAddon
.
_key
newAddon
)
;
if
(
newAddon
.
visible
)
{
this
.
makeAddonVisible
(
newAddon
)
;
}
this
.
saveChanges
(
)
;
return
newAddon
;
}
updateAddonMetadata
(
aOldAddon
aNewAddon
aPath
)
{
this
.
removeAddonMetadata
(
aOldAddon
)
;
aNewAddon
.
syncGUID
=
aOldAddon
.
syncGUID
;
aNewAddon
.
installDate
=
aOldAddon
.
installDate
;
aNewAddon
.
applyBackgroundUpdates
=
aOldAddon
.
applyBackgroundUpdates
;
aNewAddon
.
foreignInstall
=
aOldAddon
.
foreignInstall
;
aNewAddon
.
seen
=
aOldAddon
.
seen
;
aNewAddon
.
active
=
(
aNewAddon
.
visible
&
&
!
aNewAddon
.
disabled
&
&
!
aNewAddon
.
pendingUninstall
)
;
return
this
.
addAddonMetadata
(
aNewAddon
aPath
)
;
}
removeAddonMetadata
(
aAddon
)
{
this
.
addonDB
.
delete
(
aAddon
.
_key
)
;
this
.
saveChanges
(
)
;
}
updateXPIStates
(
addon
)
{
let
xpiState
=
XPIStates
.
getAddon
(
addon
.
location
addon
.
id
)
;
if
(
xpiState
)
{
xpiState
.
syncWithDB
(
addon
)
;
XPIStates
.
save
(
)
;
}
}
makeAddonVisible
(
aAddon
)
{
logger
.
debug
(
"
Make
addon
"
+
aAddon
.
_key
+
"
visible
"
)
;
for
(
let
[
otherAddon
]
of
this
.
addonDB
)
{
if
(
(
otherAddon
.
id
=
=
aAddon
.
id
)
&
&
(
otherAddon
.
_key
!
=
aAddon
.
_key
)
)
{
logger
.
debug
(
"
Hide
addon
"
+
otherAddon
.
_key
)
;
otherAddon
.
visible
=
false
;
otherAddon
.
active
=
false
;
this
.
updateXPIStates
(
otherAddon
)
;
}
}
aAddon
.
visible
=
true
;
this
.
updateXPIStates
(
aAddon
)
;
this
.
saveChanges
(
)
;
}
makeAddonLocationVisible
(
aId
aLocation
)
{
logger
.
debug
(
Make
addon
{
aId
}
visible
in
location
{
aLocation
}
)
;
let
result
;
for
(
let
[
addon
]
of
this
.
addonDB
)
{
if
(
addon
.
id
!
=
aId
)
{
continue
;
}
if
(
addon
.
location
=
=
aLocation
)
{
logger
.
debug
(
"
Reveal
addon
"
+
addon
.
_key
)
;
addon
.
visible
=
true
;
addon
.
active
=
true
;
this
.
updateXPIStates
(
addon
)
;
result
=
addon
;
}
else
{
logger
.
debug
(
"
Hide
addon
"
+
addon
.
_key
)
;
addon
.
visible
=
false
;
addon
.
active
=
false
;
this
.
updateXPIStates
(
addon
)
;
}
}
this
.
saveChanges
(
)
;
return
result
;
}
setAddonProperties
(
aAddon
aProperties
)
{
for
(
let
key
in
aProperties
)
{
aAddon
[
key
]
=
aProperties
[
key
]
;
}
this
.
saveChanges
(
)
;
}
setAddonSyncGUID
(
aAddon
aGUID
)
{
function
excludeSyncGUID
(
otherAddon
)
{
return
(
otherAddon
.
_key
!
=
aAddon
.
_key
)
&
&
(
otherAddon
.
syncGUID
=
=
aGUID
)
;
}
let
otherAddon
=
_findAddon
(
this
.
addonDB
excludeSyncGUID
)
;
if
(
otherAddon
)
{
throw
new
Error
(
"
Addon
sync
GUID
conflict
for
addon
"
+
aAddon
.
_key
+
"
:
"
+
otherAddon
.
_key
+
"
already
has
GUID
"
+
aGUID
)
;
}
aAddon
.
syncGUID
=
aGUID
;
this
.
saveChanges
(
)
;
}
updateAddonActive
(
aAddon
aActive
)
{
logger
.
debug
(
"
Updating
active
state
for
add
-
on
"
+
aAddon
.
id
+
"
to
"
+
aActive
)
;
aAddon
.
active
=
aActive
;
this
.
saveChanges
(
)
;
}
updateActiveAddons
(
)
{
if
(
!
this
.
addonDB
)
{
logger
.
warn
(
"
updateActiveAddons
called
when
DB
isn
'
t
loaded
"
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_lateOpen_updateActive
"
XPIProvider
.
runPhase
)
;
this
.
syncLoadDB
(
true
)
;
}
logger
.
debug
(
"
Updating
add
-
on
states
"
)
;
for
(
let
[
addon
]
of
this
.
addonDB
)
{
let
newActive
=
(
addon
.
visible
&
&
!
addon
.
disabled
&
&
!
addon
.
pendingUninstall
)
;
if
(
newActive
!
=
addon
.
active
)
{
addon
.
active
=
newActive
;
this
.
saveChanges
(
)
;
}
}
}
}
;
this
.
XPIDatabaseReconcile
=
{
flattenByID
(
addonMap
hideLocation
)
{
let
map
=
new
Map
(
)
;
for
(
let
installLocation
of
XPIProvider
.
installLocations
)
{
if
(
installLocation
.
name
=
=
hideLocation
)
continue
;
let
locationMap
=
addonMap
.
get
(
installLocation
.
name
)
;
if
(
!
locationMap
)
continue
;
for
(
let
[
id
addon
]
of
locationMap
)
{
if
(
!
map
.
has
(
id
)
)
map
.
set
(
id
addon
)
;
}
}
return
map
;
}
getVisibleAddons
(
addonMap
)
{
let
map
=
new
Map
(
)
;
for
(
let
addons
of
addonMap
.
values
(
)
)
{
for
(
let
[
id
addon
]
of
addons
)
{
if
(
!
addon
.
visible
)
continue
;
if
(
map
.
has
(
id
)
)
{
logger
.
warn
(
"
Previous
database
listed
more
than
one
visible
add
-
on
with
id
"
+
id
)
;
continue
;
}
map
.
set
(
id
addon
)
;
}
}
return
map
;
}
addMetadata
(
aInstallLocation
aId
aAddonState
aNewAddon
aOldAppVersion
aOldPlatformVersion
)
{
logger
.
debug
(
"
New
add
-
on
"
+
aId
+
"
installed
in
"
+
aInstallLocation
.
name
)
;
let
isNewInstall
=
!
!
aNewAddon
|
|
!
XPIDatabase
.
activeBundles
;
let
isDetectedInstall
=
isNewInstall
&
&
!
aNewAddon
;
try
{
if
(
!
aNewAddon
)
{
let
file
=
new
nsIFile
(
aAddonState
.
path
)
;
aNewAddon
=
syncLoadManifestFromFile
(
file
aInstallLocation
)
;
}
if
(
aNewAddon
.
id
!
=
aId
)
{
throw
new
Error
(
"
Invalid
addon
ID
:
expected
addon
ID
"
+
aId
+
"
found
"
+
aNewAddon
.
id
+
"
in
manifest
"
)
;
}
}
catch
(
e
)
{
logger
.
warn
(
"
addMetadata
:
Add
-
on
"
+
aId
+
"
is
invalid
"
e
)
;
if
(
aInstallLocation
.
isLinkedAddon
(
aId
)
)
logger
.
warn
(
"
Not
uninstalling
invalid
item
because
it
is
a
proxy
file
"
)
;
else
if
(
aInstallLocation
.
locked
)
logger
.
warn
(
"
Could
not
uninstall
invalid
item
from
locked
install
location
"
)
;
else
aInstallLocation
.
uninstallAddon
(
aId
)
;
return
null
;
}
aNewAddon
.
installDate
=
aAddonState
.
mtime
;
aNewAddon
.
updateDate
=
aAddonState
.
mtime
;
aNewAddon
.
foreignInstall
=
isDetectedInstall
&
&
aInstallLocation
.
name
!
=
KEY_APP_SYSTEM_ADDONS
&
&
aInstallLocation
.
name
!
=
KEY_APP_SYSTEM_DEFAULTS
;
aNewAddon
.
appDisabled
=
!
isUsableAddon
(
aNewAddon
)
;
if
(
aNewAddon
.
type
=
=
"
theme
"
&
&
aNewAddon
.
internalName
=
=
XPIProvider
.
defaultSkin
)
aNewAddon
.
foreignInstall
=
false
;
if
(
isDetectedInstall
&
&
aNewAddon
.
foreignInstall
)
{
let
disablingScopes
=
Services
.
prefs
.
getIntPref
(
PREF_EM_AUTO_DISABLED_SCOPES
0
)
;
if
(
aInstallLocation
.
scope
&
disablingScopes
)
{
logger
.
warn
(
"
Disabling
foreign
installed
add
-
on
"
+
aNewAddon
.
id
+
"
in
"
+
aInstallLocation
.
name
)
;
aNewAddon
.
userDisabled
=
true
;
aNewAddon
.
seen
=
false
;
}
}
return
XPIDatabase
.
addAddonMetadata
(
aNewAddon
aAddonState
.
path
)
;
}
removeMetadata
(
aOldAddon
)
{
logger
.
debug
(
"
Add
-
on
"
+
aOldAddon
.
id
+
"
removed
from
"
+
aOldAddon
.
location
)
;
XPIDatabase
.
removeAddonMetadata
(
aOldAddon
)
;
}
updateMetadata
(
aInstallLocation
aOldAddon
aAddonState
aNewAddon
)
{
logger
.
debug
(
"
Add
-
on
"
+
aOldAddon
.
id
+
"
modified
in
"
+
aInstallLocation
.
name
)
;
try
{
if
(
!
aNewAddon
)
{
let
file
=
new
nsIFile
(
aAddonState
.
path
)
;
aNewAddon
=
syncLoadManifestFromFile
(
file
aInstallLocation
)
;
aNewAddon
.
pendingUninstall
=
aOldAddon
.
pendingUninstall
;
aNewAddon
.
updateBlocklistState
(
{
oldAddon
:
aOldAddon
}
)
;
}
if
(
aNewAddon
.
id
!
=
aOldAddon
.
id
)
throw
new
Error
(
"
Incorrect
id
in
install
manifest
for
existing
add
-
on
"
+
aOldAddon
.
id
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
updateMetadata
:
Add
-
on
"
+
aOldAddon
.
id
+
"
is
invalid
"
e
)
;
XPIDatabase
.
removeAddonMetadata
(
aOldAddon
)
;
XPIStates
.
removeAddon
(
aOldAddon
.
location
aOldAddon
.
id
)
;
if
(
!
aInstallLocation
.
locked
)
aInstallLocation
.
uninstallAddon
(
aOldAddon
.
id
)
;
else
logger
.
warn
(
"
Could
not
uninstall
invalid
item
from
locked
install
location
"
)
;
return
null
;
}
aNewAddon
.
updateDate
=
aAddonState
.
mtime
;
return
XPIDatabase
.
updateAddonMetadata
(
aOldAddon
aNewAddon
aAddonState
.
path
)
;
}
updatePath
(
aInstallLocation
aOldAddon
aAddonState
)
{
logger
.
debug
(
"
Add
-
on
"
+
aOldAddon
.
id
+
"
moved
to
"
+
aAddonState
.
path
)
;
aOldAddon
.
path
=
aAddonState
.
path
;
aOldAddon
.
_sourceBundle
=
new
nsIFile
(
aAddonState
.
path
)
;
return
aOldAddon
;
}
updateCompatibility
(
aInstallLocation
aOldAddon
aAddonState
aOldAppVersion
aOldPlatformVersion
aReloadMetadata
)
{
logger
.
debug
(
"
Updating
compatibility
for
add
-
on
"
+
aOldAddon
.
id
+
"
in
"
+
aInstallLocation
.
name
)
;
if
(
aOldAddon
.
signedState
=
=
=
undefined
&
&
ADDON_SIGNING
&
&
SIGNED_TYPES
.
has
(
aOldAddon
.
type
)
)
{
let
file
=
new
nsIFile
(
aAddonState
.
path
)
;
let
manifest
=
syncLoadManifestFromFile
(
file
aInstallLocation
)
;
aOldAddon
.
signedState
=
manifest
.
signedState
;
}
if
(
aReloadMetadata
)
{
let
file
=
new
nsIFile
(
aAddonState
.
path
)
;
let
manifest
=
syncLoadManifestFromFile
(
file
aInstallLocation
)
;
let
remove
=
[
"
syncGUID
"
"
foreignInstall
"
"
visible
"
"
active
"
"
userDisabled
"
"
applyBackgroundUpdates
"
"
sourceURI
"
"
releaseNotesURI
"
"
targetApplications
"
]
;
let
props
=
PROP_JSON_FIELDS
.
filter
(
a
=
>
!
remove
.
includes
(
a
)
)
;
copyProperties
(
manifest
props
aOldAddon
)
;
}
aOldAddon
.
updateBlocklistState
(
{
updateDatabase
:
false
}
)
;
aOldAddon
.
appDisabled
=
!
isUsableAddon
(
aOldAddon
)
;
return
aOldAddon
;
}
processFileChanges
(
aManifests
aUpdateCompatibility
aOldAppVersion
aOldPlatformVersion
aSchemaChange
)
{
let
loadedManifest
=
(
aInstallLocation
aId
)
=
>
{
if
(
!
(
aInstallLocation
.
name
in
aManifests
)
)
return
null
;
if
(
!
(
aId
in
aManifests
[
aInstallLocation
.
name
]
)
)
return
null
;
return
aManifests
[
aInstallLocation
.
name
]
[
aId
]
;
}
;
let
exists
=
(
aAddon
)
=
>
{
try
{
return
aAddon
.
_sourceBundle
.
exists
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_NOT_INITIALIZED
)
return
false
;
throw
e
;
}
}
;
let
previousAddons
=
new
Map
(
)
;
for
(
let
a
of
XPIDatabase
.
getAddons
(
)
)
{
let
locationAddonMap
=
previousAddons
.
get
(
a
.
location
)
;
if
(
!
locationAddonMap
)
{
locationAddonMap
=
new
Map
(
)
;
previousAddons
.
set
(
a
.
location
locationAddonMap
)
;
}
locationAddonMap
.
set
(
a
.
id
a
)
;
}
let
currentAddons
=
new
Map
(
)
;
for
(
let
installLocation
of
XPIProvider
.
installLocations
)
{
let
locationAddonMap
=
new
Map
(
)
;
currentAddons
.
set
(
installLocation
.
name
locationAddonMap
)
;
let
states
=
XPIStates
.
getLocation
(
installLocation
.
name
)
;
let
dbAddons
=
previousAddons
.
get
(
installLocation
.
name
)
;
if
(
dbAddons
)
{
for
(
let
[
id
oldAddon
]
of
dbAddons
)
{
let
xpiState
=
states
&
&
states
.
get
(
id
)
;
if
(
xpiState
)
{
recordAddonTelemetry
(
oldAddon
)
;
if
(
oldAddon
.
updateDate
!
=
xpiState
.
mtime
)
{
if
(
xpiState
.
mtime
<
oldAddon
.
updateDate
)
{
XPIProvider
.
setTelemetry
(
oldAddon
.
id
"
olderFile
"
{
mtime
:
xpiState
.
mtime
oldtime
:
oldAddon
.
updateDate
}
)
;
}
}
let
oldPath
=
oldAddon
.
path
|
|
descriptorToPath
(
oldAddon
.
descriptor
)
;
let
newAddon
=
loadedManifest
(
installLocation
id
)
;
if
(
newAddon
|
|
oldAddon
.
updateDate
!
=
xpiState
.
mtime
|
|
(
aUpdateCompatibility
&
&
(
installLocation
.
name
=
=
KEY_APP_GLOBAL
|
|
installLocation
.
name
=
=
KEY_APP_SYSTEM_DEFAULTS
)
)
)
{
newAddon
=
this
.
updateMetadata
(
installLocation
oldAddon
xpiState
newAddon
)
;
}
else
if
(
oldPath
!
=
xpiState
.
path
)
{
newAddon
=
this
.
updatePath
(
installLocation
oldAddon
xpiState
)
;
}
else
if
(
aUpdateCompatibility
|
|
aSchemaChange
)
{
newAddon
=
this
.
updateCompatibility
(
installLocation
oldAddon
xpiState
aOldAppVersion
aOldPlatformVersion
aSchemaChange
)
;
}
else
{
newAddon
=
oldAddon
;
}
if
(
newAddon
)
locationAddonMap
.
set
(
newAddon
.
id
newAddon
)
;
}
else
{
this
.
removeMetadata
(
oldAddon
)
;
}
}
}
let
locMigrateData
=
{
}
;
if
(
XPIDatabase
.
migrateData
&
&
installLocation
.
name
in
XPIDatabase
.
migrateData
)
locMigrateData
=
XPIDatabase
.
migrateData
[
installLocation
.
name
]
;
if
(
states
)
{
for
(
let
[
id
xpiState
]
of
states
)
{
if
(
locationAddonMap
.
has
(
id
)
)
continue
;
let
migrateData
=
id
in
locMigrateData
?
locMigrateData
[
id
]
:
null
;
let
newAddon
=
loadedManifest
(
installLocation
id
)
;
let
addon
=
this
.
addMetadata
(
installLocation
id
xpiState
newAddon
aOldAppVersion
aOldPlatformVersion
migrateData
)
;
if
(
addon
)
locationAddonMap
.
set
(
addon
.
id
addon
)
;
}
}
}
for
(
let
[
locationName
addons
]
of
previousAddons
)
{
if
(
!
currentAddons
.
has
(
locationName
)
)
{
for
(
let
oldAddon
of
addons
.
values
(
)
)
this
.
removeMetadata
(
oldAddon
)
;
}
}
let
systemAddonLocation
=
XPIProvider
.
installLocationsByName
[
KEY_APP_SYSTEM_ADDONS
]
;
let
addons
=
currentAddons
.
get
(
KEY_APP_SYSTEM_ADDONS
)
|
|
new
Map
(
)
;
let
hideLocation
;
if
(
!
systemAddonLocation
.
isValid
(
addons
)
)
{
logger
.
info
(
"
One
or
more
updated
system
add
-
ons
invalid
falling
back
to
defaults
.
"
)
;
hideLocation
=
KEY_APP_SYSTEM_ADDONS
;
}
let
previousVisible
=
this
.
getVisibleAddons
(
previousAddons
)
;
let
currentVisible
=
this
.
flattenByID
(
currentAddons
hideLocation
)
;
let
sawActiveTheme
=
false
;
for
(
let
[
id
currentAddon
]
of
currentVisible
)
{
let
previousAddon
=
previousVisible
.
get
(
id
)
;
if
(
currentAddon
.
_installLocation
.
name
!
=
KEY_APP_GLOBAL
)
XPIProvider
.
allAppGlobal
=
false
;
let
isActive
=
!
currentAddon
.
disabled
&
&
!
currentAddon
.
pendingUninstall
;
let
wasActive
=
previousAddon
?
previousAddon
.
active
:
currentAddon
.
active
;
if
(
!
previousAddon
)
{
let
wasStaged
=
!
!
loadedManifest
(
currentAddon
.
_installLocation
id
)
;
if
(
!
wasStaged
&
&
XPIDatabase
.
activeBundles
)
{
if
(
currentAddon
.
type
=
=
"
theme
"
)
isActive
=
currentAddon
.
internalName
=
=
XPIProvider
.
currentSkin
;
else
isActive
=
XPIDatabase
.
activeBundles
.
includes
(
currentAddon
.
path
)
;
if
(
!
isActive
&
&
!
currentAddon
.
disabled
)
{
if
(
currentAddon
.
blocklistState
=
=
Blocklist
.
STATE_SOFTBLOCKED
)
currentAddon
.
softDisabled
=
true
;
else
currentAddon
.
userDisabled
=
true
;
}
}
else
{
if
(
currentAddon
.
foreignInstall
)
AddonManagerPrivate
.
addStartupChange
(
AddonManager
.
STARTUP_CHANGE_INSTALLED
id
)
;
if
(
currentAddon
.
bootstrap
)
{
AddonManagerPrivate
.
addStartupChange
(
AddonManager
.
STARTUP_CHANGE_INSTALLED
id
)
;
XPIProvider
.
callBootstrapMethod
(
currentAddon
currentAddon
.
_sourceBundle
"
install
"
BOOTSTRAP_REASONS
.
ADDON_INSTALL
)
;
if
(
!
isActive
)
XPIProvider
.
unloadBootstrapScope
(
currentAddon
.
id
)
;
}
}
}
else
{
if
(
previousAddon
!
=
=
currentAddon
)
{
AddonManagerPrivate
.
addStartupChange
(
AddonManager
.
STARTUP_CHANGE_CHANGED
id
)
;
let
installReason
=
Services
.
vc
.
compare
(
previousAddon
.
version
currentAddon
.
version
)
<
0
?
BOOTSTRAP_REASONS
.
ADDON_UPGRADE
:
BOOTSTRAP_REASONS
.
ADDON_DOWNGRADE
;
if
(
previousAddon
.
bootstrap
&
&
previousAddon
.
_installLocation
&
&
exists
(
previousAddon
)
&
&
currentAddon
.
_sourceBundle
.
path
!
=
previousAddon
.
_sourceBundle
.
path
)
{
XPIProvider
.
callBootstrapMethod
(
previousAddon
previousAddon
.
_sourceBundle
"
uninstall
"
installReason
{
newVersion
:
currentAddon
.
version
}
)
;
XPIProvider
.
unloadBootstrapScope
(
previousAddon
.
id
)
;
}
flushChromeCaches
(
)
;
if
(
currentAddon
.
bootstrap
)
{
let
file
=
currentAddon
.
_sourceBundle
.
clone
(
)
;
XPIProvider
.
callBootstrapMethod
(
currentAddon
file
"
install
"
installReason
{
oldVersion
:
previousAddon
.
version
}
)
;
if
(
currentAddon
.
disabled
)
XPIProvider
.
unloadBootstrapScope
(
currentAddon
.
id
)
;
}
}
if
(
isActive
!
=
wasActive
)
{
let
change
=
isActive
?
AddonManager
.
STARTUP_CHANGE_ENABLED
:
AddonManager
.
STARTUP_CHANGE_DISABLED
;
AddonManagerPrivate
.
addStartupChange
(
change
id
)
;
}
}
XPIDatabase
.
makeAddonVisible
(
currentAddon
)
;
currentAddon
.
active
=
isActive
;
if
(
currentAddon
.
active
&
&
currentAddon
.
internalName
=
=
XPIProvider
.
selectedSkin
)
sawActiveTheme
=
true
;
}
for
(
let
[
id
previousAddon
]
of
previousVisible
)
{
if
(
currentVisible
.
has
(
id
)
)
continue
;
if
(
previousAddon
.
bootstrap
&
&
exists
(
previousAddon
)
)
{
XPIProvider
.
callBootstrapMethod
(
previousAddon
previousAddon
.
_sourceBundle
"
uninstall
"
BOOTSTRAP_REASONS
.
ADDON_UNINSTALL
)
;
XPIProvider
.
unloadBootstrapScope
(
previousAddon
.
id
)
;
}
AddonManagerPrivate
.
addStartupChange
(
AddonManager
.
STARTUP_CHANGE_UNINSTALLED
id
)
;
XPIStates
.
removeAddon
(
previousAddon
.
location
id
)
;
flushChromeCaches
(
)
;
}
let
locationAddonMap
=
currentAddons
.
get
(
hideLocation
)
;
if
(
locationAddonMap
)
{
for
(
let
addon
of
locationAddonMap
.
values
(
)
)
{
addon
.
visible
=
false
;
addon
.
active
=
false
;
}
}
if
(
XPIProvider
.
selectedSkin
!
=
XPIProvider
.
defaultSkin
&
&
!
sawActiveTheme
)
{
logger
.
info
(
"
Didn
'
t
see
selected
skin
"
+
XPIProvider
.
selectedSkin
)
;
XPIProvider
.
enableDefaultTheme
(
)
;
}
for
(
let
[
locationName
locationAddonMap
]
of
currentAddons
)
{
for
(
let
[
id
addon
]
of
locationAddonMap
)
{
let
xpiState
=
XPIStates
.
getAddon
(
locationName
id
)
;
xpiState
.
syncWithDB
(
addon
)
;
}
}
XPIStates
.
save
(
)
;
XPIDatabase
.
migrateData
=
null
;
XPIDatabase
.
saveChanges
(
)
;
return
true
;
}
}
;
