var
EXPORTED_SYMBOLS
=
[
"
AddonTestUtils
"
"
MockAsyncShutdown
"
]
;
const
CERTDB_CONTRACTID
=
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
;
const
{
AddonManager
AddonManagerPrivate
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
const
{
AsyncShutdown
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
sys
.
mjs
"
)
;
const
{
FileUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
)
;
const
{
NetUtil
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
sys
.
mjs
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
EventEmitter
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
FileTestUtils
:
"
resource
:
/
/
testing
-
common
/
FileTestUtils
.
sys
.
mjs
"
MockRegistrar
:
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
sys
.
mjs
"
XPCShellContentUtils
:
"
resource
:
/
/
testing
-
common
/
XPCShellContentUtils
.
sys
.
mjs
"
getAppInfo
:
"
resource
:
/
/
testing
-
common
/
AppInfo
.
sys
.
mjs
"
updateAppInfo
:
"
resource
:
/
/
testing
-
common
/
AppInfo
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
ExtensionTestCommon
:
"
resource
:
/
/
testing
-
common
/
ExtensionTestCommon
.
jsm
"
Management
:
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
ExtensionAddonObserver
:
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
lazy
{
aomStartup
:
[
"
mozilla
.
org
/
addons
/
addon
-
manager
-
startup
;
1
"
"
amIAddonManagerStartup
"
]
}
)
;
const
PREF_DISABLE_SECURITY
=
"
security
.
turn_off_all_security_so_that_
"
+
"
viruses_can_take_over_this_computer
"
;
const
ArrayBufferInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
io
/
arraybuffer
-
input
-
stream
;
1
"
"
nsIArrayBufferInputStream
"
"
setData
"
)
;
const
nsFile
=
Components
.
Constructor
(
"
mozilla
.
org
/
file
/
local
;
1
"
"
nsIFile
"
"
initWithPath
"
)
;
const
ZipReader
=
Components
.
Constructor
(
"
mozilla
.
org
/
libjar
/
zip
-
reader
;
1
"
"
nsIZipReader
"
"
open
"
)
;
const
ZipWriter
=
Components
.
Constructor
(
"
mozilla
.
org
/
zipwriter
;
1
"
"
nsIZipWriter
"
"
open
"
)
;
function
isRegExp
(
val
)
{
return
val
&
&
typeof
val
=
=
=
"
object
"
&
&
typeof
val
.
test
=
=
=
"
function
"
;
}
class
MockBarrier
{
constructor
(
name
)
{
this
.
name
=
name
;
this
.
blockers
=
[
]
;
}
addBlocker
(
name
blocker
options
)
{
this
.
blockers
.
push
(
{
name
blocker
options
}
)
;
}
async
trigger
(
)
{
await
Promise
.
all
(
this
.
blockers
.
map
(
async
(
{
blocker
name
}
)
=
>
{
try
{
if
(
typeof
blocker
=
=
"
function
"
)
{
await
blocker
(
)
;
}
else
{
await
blocker
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
Shutdown
blocker
'
{
name
}
'
for
{
this
.
name
}
threw
error
:
{
e
}
:
:
{
e
.
stack
}
\
n
)
;
}
}
)
)
;
this
.
blockers
=
[
]
;
}
}
var
MockAsyncShutdown
=
{
profileBeforeChange
:
new
MockBarrier
(
"
profileBeforeChange
"
)
profileChangeTeardown
:
new
MockBarrier
(
"
profileChangeTeardown
"
)
quitApplicationGranted
:
new
MockBarrier
(
"
quitApplicationGranted
"
)
Barrier
:
AsyncShutdown
.
Barrier
}
;
AddonManagerPrivate
.
overrideAsyncShutdown
(
MockAsyncShutdown
)
;
class
AddonsList
{
constructor
(
file
)
{
this
.
extensions
=
[
]
;
this
.
themes
=
[
]
;
this
.
xpis
=
[
]
;
if
(
!
file
.
exists
(
)
)
{
return
;
}
let
data
=
lazy
.
aomStartup
.
readStartupData
(
)
;
for
(
let
loc
of
Object
.
values
(
data
)
)
{
let
dir
=
loc
.
path
&
&
new
nsFile
(
loc
.
path
)
;
for
(
let
addon
of
Object
.
values
(
loc
.
addons
)
)
{
let
file
;
if
(
dir
)
{
file
=
dir
.
clone
(
)
;
try
{
file
.
appendRelativePath
(
addon
.
path
)
;
}
catch
(
e
)
{
file
=
new
nsFile
(
addon
.
path
)
;
}
}
else
if
(
addon
.
path
)
{
file
=
new
nsFile
(
addon
.
path
)
;
}
if
(
!
file
)
{
continue
;
}
this
.
xpis
.
push
(
file
)
;
if
(
addon
.
enabled
)
{
addon
.
type
=
addon
.
type
|
|
"
extension
"
;
if
(
addon
.
type
=
=
"
theme
"
)
{
this
.
themes
.
push
(
file
)
;
}
else
{
this
.
extensions
.
push
(
file
)
;
}
}
}
}
}
hasItem
(
type
dir
id
)
{
var
path
=
dir
.
clone
(
)
;
path
.
append
(
id
)
;
var
xpiPath
=
dir
.
clone
(
)
;
xpiPath
.
append
(
{
id
}
.
xpi
)
;
return
this
[
type
]
.
some
(
file
=
>
{
if
(
!
file
.
exists
(
)
)
{
throw
new
Error
(
Non
-
existent
path
found
in
addonStartup
.
json
:
{
file
.
path
}
)
;
}
if
(
file
.
isDirectory
(
)
)
{
return
file
.
equals
(
path
)
;
}
if
(
file
.
isFile
(
)
)
{
return
file
.
equals
(
xpiPath
)
;
}
return
false
;
}
)
;
}
hasTheme
(
dir
id
)
{
return
this
.
hasItem
(
"
themes
"
dir
id
)
;
}
hasExtension
(
dir
id
)
{
return
this
.
hasItem
(
"
extensions
"
dir
id
)
;
}
}
var
AddonTestUtils
=
{
addonIntegrationService
:
null
addonsList
:
null
appInfo
:
null
addonStartup
:
null
collectedTelemetryEvents
:
[
]
testScope
:
null
testUnpacked
:
false
useRealCertChecks
:
false
usePrivilegedSignatures
:
true
certSignatureDate
:
null
overrideEntry
:
null
maybeInit
(
testScope
)
{
if
(
this
.
testScope
!
=
testScope
)
{
this
.
init
(
testScope
)
;
}
}
init
(
testScope
enableLogging
=
true
)
{
if
(
this
.
testScope
=
=
=
testScope
)
{
return
;
}
this
.
testScope
=
testScope
;
this
.
profileDir
=
testScope
.
do_get_profile
(
)
;
this
.
profileExtensions
=
this
.
profileDir
.
clone
(
)
;
this
.
profileExtensions
.
append
(
"
extensions
"
)
;
this
.
addonStartup
=
this
.
profileDir
.
clone
(
)
;
this
.
addonStartup
.
append
(
"
addonStartup
.
json
.
lz4
"
)
;
this
.
tempDir
=
this
.
profileDir
.
clone
(
)
;
this
.
tempDir
.
append
(
"
temp
"
)
;
this
.
tempDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
this
.
registerDirectory
(
"
TmpD
"
this
.
tempDir
)
;
const
appDirForAddons
=
this
.
profileDir
.
clone
(
)
;
appDirForAddons
.
append
(
"
appdir
-
addons
"
)
;
appDirForAddons
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
this
.
registerDirectory
(
"
XREAddonAppDir
"
appDirForAddons
)
;
if
(
enableLogging
)
{
Services
.
prefs
.
setBoolPref
(
"
extensions
.
logging
.
enabled
"
true
)
;
}
Services
.
prefs
.
setIntPref
(
"
extensions
.
enabledScopes
"
AddonManager
.
SCOPE_PROFILE
)
;
Services
.
prefs
.
setIntPref
(
"
extensions
.
autoDisableScopes
"
0
)
;
Services
.
prefs
.
setIntPref
(
"
extensions
.
startupScanScopes
"
15
)
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
getAddons
.
cache
.
enabled
"
false
)
;
Services
.
prefs
.
setCharPref
(
"
extensions
.
update
.
url
"
"
http
:
/
/
127
.
0
.
0
.
1
/
updateURL
"
)
;
Services
.
prefs
.
setCharPref
(
"
extensions
.
update
.
background
.
url
"
"
http
:
/
/
127
.
0
.
0
.
1
/
updateBackgroundURL
"
)
;
Services
.
prefs
.
setCharPref
(
"
services
.
settings
.
server
"
"
data
:
#
remote
-
settings
-
dummy
/
v1
"
)
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
installDistroAddons
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
xpinstall
.
signatures
.
required
"
true
)
;
function
pathShouldntExist
(
file
)
{
if
(
file
.
exists
(
)
)
{
throw
new
Error
(
Test
cleanup
:
path
{
file
.
path
}
exists
when
it
should
not
)
;
}
}
testScope
.
registerCleanupFunction
(
(
)
=
>
{
this
.
info
(
Force
a
GC
)
;
Cu
.
forceGC
(
)
;
this
.
cleanupTempXPIs
(
)
;
let
ignoreEntries
=
new
Set
(
)
;
{
let
{
value
}
=
Object
.
getOwnPropertyDescriptor
(
lazy
.
FileTestUtils
"
_globalTemporaryDirectory
"
)
;
if
(
value
)
{
ignoreEntries
.
add
(
value
.
leafName
)
;
}
}
var
entries
=
[
]
;
for
(
let
{
leafName
}
of
this
.
iterDirectory
(
this
.
tempDir
)
)
{
if
(
!
ignoreEntries
.
has
(
leafName
)
)
{
entries
.
push
(
leafName
)
;
}
}
if
(
entries
.
length
)
{
throw
new
Error
(
Found
unexpected
files
in
temporary
directory
:
{
entries
.
join
(
"
"
)
}
)
;
}
try
{
appDirForAddons
.
remove
(
true
)
;
}
catch
(
ex
)
{
testScope
.
info
(
Got
exception
removing
addon
app
dir
:
{
ex
}
)
;
}
let
featuresDir
=
this
.
profileDir
.
clone
(
)
;
featuresDir
.
append
(
"
features
"
)
;
for
(
let
dir
of
this
.
iterDirectory
(
featuresDir
)
)
{
dir
.
append
(
"
stage
"
)
;
pathShouldntExist
(
dir
)
;
}
let
testDir
=
this
.
profileDir
.
clone
(
)
;
testDir
.
append
(
"
extensions
"
)
;
testDir
.
append
(
"
trash
"
)
;
pathShouldntExist
(
testDir
)
;
testDir
.
leafName
=
"
staged
"
;
pathShouldntExist
(
testDir
)
;
return
this
.
promiseShutdownManager
(
)
;
}
)
;
}
initMochitest
(
testScope
)
{
if
(
this
.
testScope
=
=
=
testScope
)
{
return
;
}
this
.
testScope
=
testScope
;
this
.
profileDir
=
FileUtils
.
getDir
(
"
ProfD
"
[
]
)
;
this
.
profileExtensions
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
extensions
"
]
)
;
this
.
tempDir
=
FileUtils
.
getDir
(
"
TmpD
"
[
]
)
;
this
.
tempDir
.
append
(
"
addons
-
mochitest
"
)
;
this
.
tempDir
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
testScope
.
registerCleanupFunction
(
(
)
=
>
{
testScope
.
registerCleanupFunction
(
(
)
=
>
{
this
.
testScope
=
null
;
}
)
;
this
.
cleanupTempXPIs
(
)
;
try
{
this
.
tempDir
.
remove
(
true
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
)
;
}
*
iterDirectory
(
dir
)
{
let
dirEnum
;
try
{
dirEnum
=
dir
.
directoryEntries
;
let
file
;
while
(
(
file
=
dirEnum
.
nextFile
)
)
{
yield
file
;
}
}
catch
(
e
)
{
if
(
dir
.
exists
(
)
)
{
Cu
.
reportError
(
e
)
;
}
}
finally
{
if
(
dirEnum
)
{
dirEnum
.
close
(
)
;
}
}
}
createHttpServer
(
.
.
.
args
)
{
lazy
.
XPCShellContentUtils
.
ensureInitialized
(
this
.
testScope
)
;
return
lazy
.
XPCShellContentUtils
.
createHttpServer
(
.
.
.
args
)
;
}
registerJSON
(
.
.
.
args
)
{
return
lazy
.
XPCShellContentUtils
.
registerJSON
(
.
.
.
args
)
;
}
info
(
msg
)
{
let
print
=
this
.
testScope
.
info
|
|
this
.
testScope
.
do_print
;
print
(
msg
)
;
}
cleanupTempXPIs
(
)
{
let
didGC
=
false
;
for
(
let
file
of
this
.
tempXPIs
.
splice
(
0
)
)
{
if
(
file
.
exists
(
)
)
{
try
{
Services
.
obs
.
notifyObservers
(
file
"
flush
-
cache
-
entry
"
)
;
file
.
remove
(
false
)
;
}
catch
(
e
)
{
if
(
didGC
)
{
Cu
.
reportError
(
Failed
to
remove
{
file
.
path
}
:
{
e
}
)
;
}
else
{
this
.
info
(
Force
a
GC
)
;
Cu
.
forceGC
(
)
;
didGC
=
true
;
try
{
file
.
remove
(
false
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
Failed
to
remove
{
file
.
path
}
after
GC
:
{
e
}
)
;
}
}
}
}
}
}
createAppInfo
(
ID
name
version
platformVersion
=
"
1
.
0
"
)
{
lazy
.
updateAppInfo
(
{
ID
name
version
platformVersion
crashReporter
:
true
}
)
;
this
.
appInfo
=
lazy
.
getAppInfo
(
)
;
}
getManifestURI
(
file
)
{
if
(
file
.
isDirectory
(
)
)
{
file
.
leafName
=
"
manifest
.
json
"
;
if
(
file
.
exists
(
)
)
{
return
NetUtil
.
newURI
(
file
)
;
}
throw
new
Error
(
"
No
manifest
file
present
"
)
;
}
let
zip
=
ZipReader
(
file
)
;
try
{
let
uri
=
NetUtil
.
newURI
(
file
)
;
if
(
zip
.
hasEntry
(
"
manifest
.
json
"
)
)
{
return
NetUtil
.
newURI
(
jar
:
{
uri
.
spec
}
!
/
manifest
.
json
)
;
}
throw
new
Error
(
"
No
manifest
file
present
"
)
;
}
finally
{
zip
.
close
(
)
;
}
}
getIDFromExtension
(
file
)
{
return
this
.
getIDFromManifest
(
this
.
getManifestURI
(
file
)
)
;
}
async
getIDFromManifest
(
manifestURI
)
{
let
body
=
await
fetch
(
manifestURI
.
spec
)
;
let
manifest
=
await
body
.
json
(
)
;
try
{
if
(
manifest
.
browser_specific_settings
?
.
gecko
?
.
id
)
{
return
manifest
.
browser_specific_settings
.
gecko
.
id
;
}
return
manifest
.
applications
.
gecko
.
id
;
}
catch
(
e
)
{
return
Services
.
uuid
.
generateUUID
(
)
.
number
;
}
}
overrideCertDB
(
)
{
let
verifyCert
=
async
(
file
result
cert
callback
)
=
>
{
if
(
result
=
=
Cr
.
NS_ERROR_SIGNED_JAR_NOT_SIGNED
&
&
!
this
.
useRealCertChecks
&
&
callback
.
wrappedJSObject
)
{
callback
=
callback
.
wrappedJSObject
;
try
{
let
id
;
try
{
let
manifestURI
=
this
.
getManifestURI
(
file
)
;
id
=
await
this
.
getIDFromManifest
(
manifestURI
)
;
}
catch
(
err
)
{
if
(
file
.
leafName
.
endsWith
(
"
.
xpi
"
)
)
{
id
=
file
.
leafName
.
slice
(
0
-
4
)
;
}
}
let
fakeCert
=
{
commonName
:
id
}
;
if
(
this
.
usePrivilegedSignatures
)
{
let
privileged
=
typeof
this
.
usePrivilegedSignatures
=
=
"
function
"
?
this
.
usePrivilegedSignatures
(
id
)
:
this
.
usePrivilegedSignatures
;
if
(
privileged
=
=
=
"
system
"
)
{
fakeCert
.
organizationalUnit
=
"
Mozilla
Components
"
;
}
else
if
(
privileged
)
{
fakeCert
.
organizationalUnit
=
"
Mozilla
Extensions
"
;
}
}
if
(
this
.
certSignatureDate
)
{
fakeCert
.
validity
=
{
notBefore
:
this
.
certSignatureDate
*
1000
}
;
}
return
[
callback
Cr
.
NS_OK
fakeCert
]
;
}
catch
(
e
)
{
}
finally
{
if
(
file
.
isFile
(
)
)
{
Services
.
obs
.
notifyObservers
(
file
"
flush
-
cache
-
entry
"
"
cert
-
override
"
)
;
}
}
}
return
[
callback
result
cert
]
;
}
;
let
FakeCertDB
=
{
init
(
)
{
for
(
let
property
of
Object
.
keys
(
this
.
_genuine
.
QueryInterface
(
Ci
.
nsIX509CertDB
)
)
)
{
if
(
property
in
this
)
{
continue
;
}
if
(
typeof
this
.
_genuine
[
property
]
=
=
"
function
"
)
{
this
[
property
]
=
this
.
_genuine
[
property
]
.
bind
(
this
.
_genuine
)
;
}
}
}
openSignedAppFileAsync
(
root
file
callback
)
{
this
.
_genuine
.
openSignedAppFileAsync
(
root
file
(
result
zipReader
cert
)
=
>
{
verifyCert
(
file
.
clone
(
)
result
cert
callback
)
.
then
(
(
[
callback
result
cert
]
)
=
>
{
callback
.
openSignedAppFileFinished
(
result
zipReader
cert
)
;
}
)
;
}
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIX509CertDB
"
]
)
}
;
lazy
.
MockRegistrar
.
register
(
CERTDB_CONTRACTID
FakeCertDB
)
;
Cc
[
CERTDB_CONTRACTID
]
.
getService
(
)
;
FakeCertDB
.
init
(
)
;
}
async
loadBlocklistData
(
dir
prefix
)
{
let
loadedData
=
{
}
;
let
fileSuffix
=
"
extensions
"
;
const
fileName
=
{
prefix
}
-
{
fileSuffix
}
.
json
;
try
{
loadedData
[
fileSuffix
]
=
await
IOUtils
.
readJSON
(
PathUtils
.
join
(
dir
.
path
fileName
)
)
;
this
.
info
(
Loaded
{
fileName
}
)
;
}
catch
(
e
)
{
}
return
this
.
loadBlocklistRawData
(
loadedData
)
;
}
async
loadBlocklistRawData
(
data
)
{
const
{
BlocklistPrivate
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Blocklist
.
jsm
"
)
;
const
blocklistMapping
=
{
extensions
:
BlocklistPrivate
.
ExtensionBlocklistRS
extensionsMLBF
:
BlocklistPrivate
.
ExtensionBlocklistMLBF
}
;
for
(
const
[
dataProp
blocklistObj
]
of
Object
.
entries
(
blocklistMapping
)
)
{
let
newData
=
data
[
dataProp
]
;
if
(
!
newData
)
{
continue
;
}
if
(
!
Array
.
isArray
(
newData
)
)
{
throw
new
Error
(
"
Expected
an
array
of
new
items
to
put
in
the
"
+
dataProp
+
"
blocklist
!
"
)
;
}
for
(
let
item
of
newData
)
{
if
(
!
item
.
id
)
{
item
.
id
=
Services
.
uuid
.
generateUUID
(
)
.
number
.
slice
(
1
-
1
)
;
}
if
(
!
item
.
last_modified
)
{
item
.
last_modified
=
Date
.
now
(
)
;
}
}
blocklistObj
.
ensureInitialized
(
)
;
let
db
=
await
blocklistObj
.
_client
.
db
;
const
collectionTimestamp
=
Math
.
max
(
.
.
.
newData
.
map
(
r
=
>
r
.
last_modified
)
)
;
await
db
.
importChanges
(
{
}
collectionTimestamp
newData
{
clear
:
true
}
)
;
await
blocklistObj
.
_onUpdate
(
)
;
}
}
async
promiseStartupManager
(
params
)
{
if
(
this
.
addonIntegrationService
)
{
throw
new
Error
(
"
Attempting
to
startup
manager
that
was
already
started
.
"
)
;
}
if
(
typeof
params
!
=
"
object
"
)
{
params
=
{
newVersion
:
arguments
[
0
]
}
;
}
let
{
earlyStartup
=
true
lateStartup
=
true
newVersion
}
=
params
;
lateStartup
=
earlyStartup
&
&
lateStartup
;
if
(
newVersion
)
{
this
.
appInfo
.
version
=
newVersion
;
this
.
appInfo
.
platformVersion
=
newVersion
;
}
lazy
.
ExtensionAddonObserver
.
init
(
)
;
const
{
XPIInternal
XPIProvider
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIProvider
.
jsm
"
)
;
XPIInternal
.
overrideAsyncShutdown
(
MockAsyncShutdown
)
;
XPIInternal
.
BootstrapScope
.
prototype
.
_beforeCallBootstrapMethod
=
(
method
params
reason
)
=
>
{
try
{
this
.
emit
(
"
bootstrap
-
method
"
{
method
params
reason
}
)
;
}
catch
(
e
)
{
try
{
this
.
testScope
.
do_throw
(
e
)
;
}
catch
(
e
)
{
}
}
}
;
this
.
addonIntegrationService
=
Cc
[
"
mozilla
.
org
/
addons
/
integration
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
;
this
.
addonIntegrationService
.
observe
(
null
"
addons
-
startup
"
null
)
;
this
.
emit
(
"
addon
-
manager
-
started
"
)
;
await
Promise
.
all
(
XPIProvider
.
startupPromises
)
;
await
this
.
loadAddonsList
(
true
)
;
await
Promise
.
all
(
Array
.
from
(
XPIProvider
.
activeAddons
.
values
(
)
addon
=
>
addon
.
startupPromise
)
)
;
if
(
earlyStartup
)
{
lazy
.
ExtensionTestCommon
.
notifyEarlyStartup
(
)
;
}
if
(
lateStartup
)
{
lazy
.
ExtensionTestCommon
.
notifyLateStartup
(
)
;
}
}
async
promiseShutdownManager
(
{
clearOverrides
=
true
clearL10nRegistry
=
true
}
=
{
}
)
{
if
(
!
this
.
addonIntegrationService
)
{
return
false
;
}
if
(
this
.
overrideEntry
&
&
clearOverrides
)
{
this
.
overrideEntry
.
destruct
(
)
;
this
.
overrideEntry
=
null
;
}
const
{
XPIProvider
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIProvider
.
jsm
"
)
;
const
{
XPIDatabase
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIDatabase
.
jsm
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
test
-
load
-
xpi
-
database
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
quit
-
application
-
granted
"
)
;
await
MockAsyncShutdown
.
quitApplicationGranted
.
trigger
(
)
;
await
XPIDatabase
.
_dbPromise
;
await
MockAsyncShutdown
.
profileBeforeChange
.
trigger
(
)
;
await
MockAsyncShutdown
.
profileChangeTeardown
.
trigger
(
)
;
this
.
emit
(
"
addon
-
manager
-
shutdown
"
)
;
this
.
addonIntegrationService
=
null
;
await
this
.
loadAddonsList
(
)
;
for
(
let
file
of
this
.
addonsList
.
xpis
)
{
Services
.
obs
.
notifyObservers
(
file
"
flush
-
cache
-
entry
"
)
;
}
if
(
clearL10nRegistry
)
{
L10nRegistry
.
getInstance
(
)
.
clearSources
(
)
;
}
this
.
appInfo
.
annotations
=
{
}
;
let
shutdownError
=
XPIDatabase
.
_saveError
;
AddonManagerPrivate
.
unregisterProvider
(
XPIProvider
)
;
Cu
.
unload
(
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIProvider
.
jsm
"
)
;
Cu
.
unload
(
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIDatabase
.
jsm
"
)
;
Cu
.
unload
(
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIInstall
.
jsm
"
)
;
lazy
.
ExtensionAddonObserver
.
uninit
(
)
;
lazy
.
ExtensionTestCommon
.
resetStartupPromises
(
)
;
if
(
shutdownError
)
{
throw
shutdownError
;
}
return
true
;
}
async
promiseRestartManager
(
params
)
{
await
this
.
promiseShutdownManager
(
{
clearOverrides
:
false
}
)
;
await
this
.
promiseStartupManager
(
params
)
;
}
notifyEarlyStartup
(
)
{
return
lazy
.
ExtensionTestCommon
.
notifyEarlyStartup
(
)
;
}
notifyLateStartup
(
)
{
return
lazy
.
ExtensionTestCommon
.
notifyLateStartup
(
)
;
}
async
loadAddonsList
(
flush
=
false
)
{
if
(
flush
)
{
const
{
XPIInternal
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIProvider
.
jsm
"
)
;
XPIInternal
.
XPIStates
.
save
(
)
;
await
XPIInternal
.
XPIStates
.
_jsonFile
.
_save
(
)
;
}
this
.
addonsList
=
new
AddonsList
(
this
.
addonStartup
)
;
}
writeFilesToZip
(
zipFile
files
flags
=
0
)
{
if
(
typeof
zipFile
=
=
"
string
"
)
{
zipFile
=
nsFile
(
zipFile
)
;
}
var
zipW
=
ZipWriter
(
zipFile
FileUtils
.
MODE_WRONLY
|
FileUtils
.
MODE_CREATE
|
flags
)
;
for
(
let
[
path
data
]
of
Object
.
entries
(
files
)
)
{
if
(
typeof
data
=
=
=
"
object
"
&
&
ChromeUtils
.
getClassName
(
data
)
=
=
=
"
Object
"
)
{
data
=
JSON
.
stringify
(
data
)
;
}
if
(
!
(
data
instanceof
ArrayBuffer
)
)
{
data
=
new
TextEncoder
(
)
.
encode
(
data
)
.
buffer
;
}
let
stream
=
ArrayBufferInputStream
(
data
0
data
.
byteLength
)
;
zipW
.
addEntryStream
(
path
Math
.
pow
(
2
49
)
Ci
.
nsIZipWriter
.
COMPRESSION_NONE
stream
false
)
;
}
zipW
.
close
(
)
;
}
async
promiseWriteFilesToZip
(
zip
files
flags
)
{
await
IOUtils
.
makeDirectory
(
PathUtils
.
parent
(
zip
)
)
;
this
.
writeFilesToZip
(
zip
files
flags
)
;
return
Promise
.
resolve
(
nsFile
(
zip
)
)
;
}
async
promiseWriteFilesToDir
(
dir
files
)
{
await
IOUtils
.
makeDirectory
(
dir
)
;
for
(
let
[
path
data
]
of
Object
.
entries
(
files
)
)
{
path
=
path
.
split
(
"
/
"
)
;
let
leafName
=
path
.
pop
(
)
;
let
dirPath
=
dir
;
for
(
let
subDir
of
path
)
{
dirPath
=
PathUtils
.
join
(
dirPath
subDir
)
;
await
PathUtils
.
makeDirectory
(
dirPath
)
;
}
const
leafPath
=
PathUtils
.
join
(
dirPath
leafName
)
;
if
(
typeof
data
=
=
"
object
"
&
&
ChromeUtils
.
getClassName
(
data
)
=
=
"
Object
"
)
{
await
IOUtils
.
writeJSON
(
leafPath
data
)
;
}
else
if
(
typeof
data
=
=
"
string
"
)
{
await
IOUtils
.
writeUTF8
(
leafPath
data
)
;
}
}
return
nsFile
(
dir
)
;
}
promiseWriteFilesToExtension
(
dir
id
files
unpacked
=
this
.
testUnpacked
)
{
if
(
unpacked
)
{
let
path
=
PathUtils
.
join
(
dir
id
)
;
return
this
.
promiseWriteFilesToDir
(
path
files
)
;
}
let
xpi
=
PathUtils
.
join
(
dir
{
id
}
.
xpi
)
;
return
this
.
promiseWriteFilesToZip
(
xpi
files
)
;
}
tempXPIs
:
[
]
allocTempXPIFile
(
)
{
let
file
=
this
.
tempDir
.
clone
(
)
;
let
uuid
=
Services
.
uuid
.
generateUUID
(
)
.
number
.
slice
(
1
-
1
)
;
file
.
append
(
{
uuid
}
.
xpi
)
;
this
.
tempXPIs
.
push
(
file
)
;
return
file
;
}
createTempXPIFile
(
files
)
{
let
file
=
this
.
allocTempXPIFile
(
)
;
this
.
writeFilesToZip
(
file
.
path
files
)
;
return
file
;
}
createTempWebExtensionFile
(
data
)
{
let
file
=
lazy
.
ExtensionTestCommon
.
generateXPI
(
data
)
;
this
.
tempXPIs
.
push
(
file
)
;
return
file
;
}
promiseInstallXPI
(
files
)
{
return
this
.
promiseInstallFile
(
this
.
createTempXPIFile
(
files
)
)
;
}
promiseWriteProxyFileToDir
(
dir
addon
id
)
{
let
files
=
{
[
id
]
:
addon
.
path
}
;
return
this
.
promiseWriteFilesToDir
(
dir
.
path
files
)
;
}
async
manuallyInstall
(
xpiFile
installLocation
=
this
.
profileExtensions
id
=
null
unpacked
=
this
.
testUnpacked
)
{
if
(
id
=
=
null
)
{
id
=
await
this
.
getIDFromExtension
(
xpiFile
)
;
}
if
(
unpacked
)
{
let
dir
=
installLocation
.
clone
(
)
;
dir
.
append
(
id
)
;
dir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
let
zip
=
ZipReader
(
xpiFile
)
;
for
(
let
entry
of
zip
.
findEntries
(
null
)
)
{
let
target
=
dir
.
clone
(
)
;
for
(
let
part
of
entry
.
split
(
"
/
"
)
)
{
target
.
append
(
part
)
;
}
if
(
!
target
.
parent
.
exists
(
)
)
{
target
.
parent
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
}
try
{
zip
.
extract
(
entry
target
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_FILE_DIR_NOT_EMPTY
&
&
!
(
target
.
exists
(
)
&
&
target
.
isDirectory
(
)
)
)
{
throw
e
;
}
}
target
.
permissions
|
=
FileUtils
.
PERMS_FILE
;
}
zip
.
close
(
)
;
return
dir
;
}
let
target
=
installLocation
.
clone
(
)
;
target
.
append
(
{
id
}
.
xpi
)
;
xpiFile
.
copyTo
(
target
.
parent
target
.
leafName
)
;
return
target
;
}
manuallyUninstall
(
installLocation
id
unpacked
=
this
.
testUnpacked
)
{
let
file
=
this
.
getFileForAddon
(
installLocation
id
unpacked
)
;
if
(
file
.
isFile
(
)
)
{
Services
.
obs
.
notifyObservers
(
file
"
flush
-
cache
-
entry
"
)
;
}
file
.
remove
(
true
)
;
}
getFileForAddon
(
dir
id
unpacked
=
this
.
testUnpacked
)
{
dir
=
dir
.
clone
(
)
;
if
(
unpacked
)
{
dir
.
append
(
id
)
;
}
else
{
dir
.
append
(
{
id
}
.
xpi
)
;
}
return
dir
;
}
setExtensionModifiedTime
(
ext
time
)
{
ext
.
lastModifiedTime
=
time
;
if
(
ext
.
isDirectory
(
)
)
{
for
(
let
file
of
this
.
iterDirectory
(
ext
)
)
{
this
.
setExtensionModifiedTime
(
file
time
)
;
}
}
}
async
promiseSetExtensionModifiedTime
(
path
time
)
{
await
IOUtils
.
setModificationTime
(
path
time
)
;
const
stat
=
await
IOUtils
.
stat
(
path
)
;
if
(
stat
.
type
!
=
=
"
directory
"
)
{
return
;
}
const
children
=
await
IOUtils
.
getChildren
(
path
)
;
try
{
await
Promise
.
all
(
children
.
map
(
entry
=
>
this
.
promiseSetExtensionModifiedTime
(
entry
time
)
)
)
;
}
catch
(
ex
)
{
if
(
DOMException
.
isInstance
(
ex
)
)
{
return
;
}
throw
ex
;
}
}
registerDirectory
(
key
dir
)
{
var
dirProvider
=
{
getFile
(
prop
persistent
)
{
persistent
.
value
=
false
;
if
(
prop
=
=
key
)
{
return
dir
.
clone
(
)
;
}
return
null
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIDirectoryServiceProvider
"
]
)
}
;
Services
.
dirsvc
.
registerProvider
(
dirProvider
)
;
try
{
Services
.
dirsvc
.
undefine
(
key
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_FAILURE
)
{
throw
e
;
}
}
}
promiseAddonEvent
(
event
checkFn
)
{
return
new
Promise
(
resolve
=
>
{
let
listener
=
{
[
event
]
(
.
.
.
args
)
{
if
(
typeof
checkFn
=
=
"
function
"
&
&
!
checkFn
(
.
.
.
args
)
)
{
return
;
}
AddonManager
.
removeAddonListener
(
listener
)
;
resolve
(
args
)
;
}
}
;
AddonManager
.
addAddonListener
(
listener
)
;
}
)
;
}
promiseInstallEvent
(
event
)
{
return
new
Promise
(
resolve
=
>
{
let
listener
=
{
[
event
]
(
.
.
.
args
)
{
AddonManager
.
removeInstallListener
(
listener
)
;
resolve
(
args
)
;
}
}
;
AddonManager
.
addInstallListener
(
listener
)
;
}
)
;
}
promiseCompleteInstall
(
install
)
{
let
listener
;
return
new
Promise
(
resolve
=
>
{
let
installPromise
;
listener
=
{
onDownloadFailed
:
resolve
onDownloadCancelled
:
resolve
onInstallFailed
:
resolve
onInstallCancelled
:
resolve
onInstallEnded
(
)
{
resolve
(
installPromise
)
;
}
onInstallPostponed
:
resolve
}
;
install
.
addListener
(
listener
)
;
installPromise
=
install
.
install
(
)
;
}
)
.
then
(
(
)
=
>
{
install
.
removeListener
(
listener
)
;
return
install
;
}
)
;
}
async
promiseInstallFile
(
file
ignoreIncompatible
=
false
installTelemetryInfo
)
{
let
install
=
await
AddonManager
.
getInstallForFile
(
file
null
installTelemetryInfo
)
;
if
(
!
install
)
{
throw
new
Error
(
No
AddonInstall
created
for
{
file
.
path
}
)
;
}
if
(
install
.
state
!
=
AddonManager
.
STATE_DOWNLOADED
)
{
throw
new
Error
(
Expected
file
to
be
downloaded
for
install
of
{
file
.
path
}
)
;
}
if
(
ignoreIncompatible
&
&
install
.
addon
.
appDisabled
)
{
return
null
;
}
await
install
.
install
(
)
;
return
install
;
}
promiseInstallAllFiles
(
files
ignoreIncompatible
=
false
)
{
return
Promise
.
all
(
Array
.
from
(
files
file
=
>
this
.
promiseInstallFile
(
file
ignoreIncompatible
)
)
)
;
}
promiseCompleteAllInstalls
(
installs
)
{
return
Promise
.
all
(
Array
.
from
(
installs
this
.
promiseCompleteInstall
)
)
;
}
updateReason
:
AddonManager
.
UPDATE_WHEN_PERIODIC_UPDATE
promiseFindAddonUpdates
(
addon
reason
=
AddonTestUtils
.
updateReason
.
.
.
args
)
{
let
equal
=
this
.
testScope
.
equal
|
|
this
.
testScope
.
is
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
result
=
{
}
;
addon
.
findUpdates
(
{
onNoCompatibilityUpdateAvailable
(
addon2
)
{
if
(
"
compatibilityUpdate
"
in
result
)
{
throw
new
Error
(
"
Saw
multiple
compatibility
update
events
"
)
;
}
equal
(
addon
addon2
"
onNoCompatibilityUpdateAvailable
"
)
;
result
.
compatibilityUpdate
=
false
;
}
onCompatibilityUpdateAvailable
(
addon2
)
{
if
(
"
compatibilityUpdate
"
in
result
)
{
throw
new
Error
(
"
Saw
multiple
compatibility
update
events
"
)
;
}
equal
(
addon
addon2
"
onCompatibilityUpdateAvailable
"
)
;
result
.
compatibilityUpdate
=
true
;
}
onNoUpdateAvailable
(
addon2
)
{
if
(
"
updateAvailable
"
in
result
)
{
throw
new
Error
(
"
Saw
multiple
update
available
events
"
)
;
}
equal
(
addon
addon2
"
onNoUpdateAvailable
"
)
;
result
.
updateAvailable
=
false
;
}
onUpdateAvailable
(
addon2
install
)
{
if
(
"
updateAvailable
"
in
result
)
{
throw
new
Error
(
"
Saw
multiple
update
available
events
"
)
;
}
equal
(
addon
addon2
"
onUpdateAvailable
"
)
;
result
.
updateAvailable
=
install
;
}
onUpdateFinished
(
addon2
error
)
{
equal
(
addon
addon2
"
onUpdateFinished
"
)
;
if
(
error
=
=
AddonManager
.
UPDATE_STATUS_NO_ERROR
)
{
resolve
(
result
)
;
}
else
{
result
.
error
=
error
;
reject
(
result
)
;
}
}
}
reason
.
.
.
args
)
;
}
)
;
}
async
promiseConsoleOutput
(
task
)
{
const
DONE
=
"
=
=
=
xpcshell
test
console
listener
done
=
=
=
"
;
let
listener
messages
=
[
]
;
let
awaitListener
=
new
Promise
(
resolve
=
>
{
listener
=
msg
=
>
{
if
(
msg
=
=
DONE
)
{
resolve
(
)
;
}
else
{
msg
instanceof
Ci
.
nsIScriptError
;
messages
.
push
(
msg
)
;
}
}
;
}
)
;
Services
.
console
.
registerListener
(
listener
)
;
try
{
let
result
=
await
task
(
)
;
Services
.
console
.
logStringMessage
(
DONE
)
;
await
awaitListener
;
return
{
messages
result
}
;
}
finally
{
Services
.
console
.
unregisterListener
(
listener
)
;
}
}
checkMessages
(
messages
{
expected
=
[
]
forbidden
=
[
]
forbidUnexpected
=
false
}
)
{
function
msgMatches
(
msg
expectedMsg
)
{
for
(
let
[
prop
pattern
]
of
Object
.
entries
(
expectedMsg
)
)
{
if
(
isRegExp
(
pattern
)
&
&
typeof
msg
[
prop
]
=
=
=
"
string
"
)
{
if
(
!
pattern
.
test
(
msg
[
prop
]
)
)
{
return
false
;
}
}
else
if
(
msg
[
prop
]
!
=
=
pattern
)
{
return
false
;
}
}
return
true
;
}
function
validateOptionFormat
(
optionName
optionValue
)
{
for
(
let
item
of
optionValue
)
{
if
(
!
item
|
|
typeof
item
!
=
=
"
object
"
|
|
isRegExp
(
item
)
)
{
throw
new
Error
(
Unexpected
format
in
AddonTestUtils
.
checkMessages
"
{
optionName
}
"
parameter
)
;
}
}
}
validateOptionFormat
(
"
expected
"
expected
)
;
validateOptionFormat
(
"
forbidden
"
forbidden
)
;
let
i
=
0
;
for
(
let
msg
of
messages
)
{
if
(
forbidden
.
some
(
pat
=
>
msgMatches
(
msg
pat
)
)
)
{
this
.
testScope
.
ok
(
false
Got
forbidden
console
message
:
{
msg
}
)
;
continue
;
}
if
(
i
<
expected
.
length
&
&
msgMatches
(
msg
expected
[
i
]
)
)
{
this
.
info
(
Matched
expected
console
message
:
{
msg
}
)
;
i
+
+
;
}
else
if
(
forbidUnexpected
)
{
this
.
testScope
.
ok
(
false
Got
unexpected
console
message
:
{
msg
}
)
;
}
}
for
(
let
pat
of
expected
.
slice
(
i
)
)
{
this
.
testScope
.
ok
(
false
Did
not
get
expected
console
message
:
{
uneval
(
pat
)
}
)
;
}
}
checkInstallInfo
(
addonOrInstall
expectedInstallInfo
msg
=
undefined
)
{
const
installInfo
=
addonOrInstall
.
installTelemetryInfo
;
const
{
Assert
}
=
this
.
testScope
;
msg
=
msg
?
{
msg
}
:
"
"
;
for
(
const
key
of
Object
.
keys
(
expectedInstallInfo
)
)
{
const
actual
=
installInfo
[
key
]
;
let
expected
=
expectedInstallInfo
[
key
]
;
if
(
expected
&
&
typeof
expected
.
test
=
=
"
function
"
)
{
Assert
.
ok
(
expected
.
test
(
actual
)
{
key
}
value
"
{
actual
}
"
has
the
value
expected
"
{
expected
}
"
{
msg
}
)
;
}
else
{
Assert
.
deepEqual
(
actual
expected
Got
the
expected
value
for
{
key
}
{
msg
}
)
;
}
}
}
promiseWebExtensionStartup
(
id
)
{
return
new
Promise
(
resolve
=
>
{
lazy
.
Management
.
on
(
"
ready
"
function
listener
(
event
extension
)
{
if
(
!
id
|
|
extension
.
id
=
=
id
)
{
lazy
.
Management
.
off
(
"
ready
"
listener
)
;
resolve
(
extension
)
;
}
}
)
;
}
)
;
}
async
waitForSearchProviderStartup
(
extension
{
expectPending
=
false
}
=
{
}
)
{
let
{
equal
ok
}
=
this
.
testScope
;
if
(
!
equal
|
|
!
ok
)
{
let
{
Assert
}
=
this
.
testScope
;
equal
=
Assert
.
equal
.
bind
(
Assert
)
;
ok
=
Assert
.
ok
.
bind
(
Assert
)
;
}
equal
(
extension
.
state
"
running
"
"
Search
provider
extension
should
be
running
"
)
;
ok
(
extension
.
id
"
Extension
ID
of
search
provider
should
be
set
"
)
;
let
{
pendingSearchSetupTasks
}
=
lazy
.
Management
.
global
;
let
searchStartupPromise
=
pendingSearchSetupTasks
.
get
(
extension
.
id
)
;
if
(
expectPending
)
{
ok
(
searchStartupPromise
"
Search
provider
registration
should
be
in
progress
"
)
;
}
return
searchStartupPromise
;
}
initializeURLPreloader
(
)
{
Services
.
prefs
.
setBoolPref
(
PREF_DISABLE_SECURITY
true
)
;
lazy
.
aomStartup
.
initializeURLPreloader
(
)
;
}
async
overrideBuiltIns
(
data
)
{
let
prevPrefVal
=
Services
.
prefs
.
getBoolPref
(
PREF_DISABLE_SECURITY
false
)
;
this
.
initializeURLPreloader
(
)
;
let
file
=
this
.
tempDir
.
clone
(
)
;
file
.
append
(
"
override
.
txt
"
)
;
this
.
tempXPIs
.
push
(
file
)
;
let
manifest
=
Services
.
io
.
newFileURI
(
file
)
;
await
IOUtils
.
writeJSON
(
file
.
path
data
)
;
this
.
overrideEntry
=
lazy
.
aomStartup
.
registerChrome
(
manifest
[
[
"
override
"
"
chrome
:
/
/
browser
/
content
/
built_in_addons
.
json
"
Services
.
io
.
newFileURI
(
file
)
.
spec
]
]
)
;
Services
.
prefs
.
setBoolPref
(
PREF_DISABLE_SECURITY
prevPrefVal
)
;
}
hookAMTelemetryEvents
(
)
{
this
.
testScope
.
registerCleanupFunction
(
(
)
=
>
{
this
.
testScope
.
Assert
.
deepEqual
(
[
]
this
.
getAMTelemetryEvents
(
)
"
No
unexamined
telemetry
events
after
test
is
finished
"
)
;
}
)
;
}
getAMTelemetryEvents
(
)
{
let
snapshots
=
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
true
)
;
let
events
=
(
snapshots
.
parent
?
?
[
]
)
.
filter
(
entry
=
>
entry
[
1
]
=
=
"
addonsManager
"
)
.
map
(
entry
=
>
(
{
method
:
entry
[
2
]
object
:
entry
[
3
]
value
:
entry
[
4
]
extra
:
entry
[
5
]
}
)
)
;
return
events
;
}
}
;
for
(
let
[
key
val
]
of
Object
.
entries
(
AddonTestUtils
)
)
{
if
(
typeof
val
=
=
"
function
"
)
{
AddonTestUtils
[
key
]
=
val
.
bind
(
AddonTestUtils
)
;
}
}
EventEmitter
.
decorate
(
AddonTestUtils
)
;
