"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AddonInternal
"
"
XPIDatabase
"
"
XPIDatabaseReconcile
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AddonManagerPrivate
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AddonRepository
:
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonRepository
.
jsm
"
AddonSettings
:
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonSettings
.
jsm
"
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
DeferredTask
:
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
Blocklist
:
"
resource
:
/
/
gre
/
modules
/
Blocklist
.
jsm
"
UpdateChecker
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIInstall
.
jsm
"
XPIInstall
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIInstall
.
jsm
"
XPIInternal
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIProvider
.
jsm
"
}
)
;
const
{
nsIBlocklistService
}
=
Ci
;
for
(
let
sym
of
[
"
BOOTSTRAP_REASONS
"
"
DB_SCHEMA
"
"
SIGNED_TYPES
"
"
XPIProvider
"
"
XPIStates
"
"
descriptorToPath
"
"
isTheme
"
"
isWebExtension
"
"
recordAddonTelemetry
"
]
)
{
XPCOMUtils
.
defineLazyGetter
(
this
sym
(
)
=
>
XPIInternal
[
sym
]
)
;
}
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
LOGGER_ID
=
"
addons
.
xpi
-
utils
"
;
const
nsIFile
=
Components
.
Constructor
(
"
mozilla
.
org
/
file
/
local
;
1
"
"
nsIFile
"
"
initWithPath
"
)
;
var
logger
=
Log
.
repository
.
getLogger
(
LOGGER_ID
)
;
const
KEY_PROFILEDIR
=
"
ProfD
"
;
const
FILE_JSON_DB
=
"
extensions
.
json
"
;
const
LAST_SQLITE_DB_SCHEMA
=
14
;
const
PREF_BLOCKLIST_ITEM_URL
=
"
extensions
.
blocklist
.
itemURL
"
;
const
PREF_DB_SCHEMA
=
"
extensions
.
databaseSchema
"
;
const
PREF_EM_AUTO_DISABLED_SCOPES
=
"
extensions
.
autoDisableScopes
"
;
const
PREF_EM_EXTENSION_FORMAT
=
"
extensions
.
"
;
const
PREF_PENDING_OPERATIONS
=
"
extensions
.
pendingOperations
"
;
const
PREF_XPI_SIGNATURES_DEV_ROOT
=
"
xpinstall
.
signatures
.
dev
-
root
"
;
const
TOOLKIT_ID
=
"
toolkit
mozilla
.
org
"
;
const
KEY_APP_SYSTEM_ADDONS
=
"
app
-
system
-
addons
"
;
const
KEY_APP_SYSTEM_DEFAULTS
=
"
app
-
system
-
defaults
"
;
const
KEY_APP_SYSTEM_LOCAL
=
"
app
-
system
-
local
"
;
const
KEY_APP_SYSTEM_SHARE
=
"
app
-
system
-
share
"
;
const
KEY_APP_GLOBAL
=
"
app
-
global
"
;
const
KEY_APP_PROFILE
=
"
app
-
profile
"
;
const
KEY_APP_TEMPORARY
=
"
app
-
temporary
"
;
const
PENDING_INSTALL_METADATA
=
[
"
syncGUID
"
"
targetApplications
"
"
userDisabled
"
"
softDisabled
"
"
existingAddonID
"
"
sourceURI
"
"
releaseNotesURI
"
"
installDate
"
"
updateDate
"
"
applyBackgroundUpdates
"
"
compatibilityOverrides
"
]
;
const
COMPATIBLE_BY_DEFAULT_TYPES
=
{
extension
:
true
dictionary
:
true
}
;
const
PROP_LOCALE_SINGLE
=
[
"
name
"
"
description
"
"
creator
"
"
homepageURL
"
]
;
const
PROP_LOCALE_MULTI
=
[
"
developers
"
"
translators
"
"
contributors
"
]
;
const
PROP_JSON_FIELDS
=
[
"
id
"
"
syncGUID
"
"
location
"
"
version
"
"
type
"
"
updateURL
"
"
optionsURL
"
"
optionsType
"
"
optionsBrowserStyle
"
"
aboutURL
"
"
defaultLocale
"
"
visible
"
"
active
"
"
userDisabled
"
"
appDisabled
"
"
pendingUninstall
"
"
installDate
"
"
updateDate
"
"
applyBackgroundUpdates
"
"
bootstrap
"
"
path
"
"
skinnable
"
"
size
"
"
sourceURI
"
"
releaseNotesURI
"
"
softDisabled
"
"
foreignInstall
"
"
strictCompatibility
"
"
locales
"
"
targetApplications
"
"
targetPlatforms
"
"
signedState
"
"
seen
"
"
dependencies
"
"
hasEmbeddedWebExtension
"
"
userPermissions
"
"
icons
"
"
iconURL
"
"
icon64URL
"
"
blocklistState
"
"
blocklistURL
"
"
startupData
"
]
;
const
LEGACY_TYPES
=
new
Set
(
[
"
extension
"
]
)
;
const
ASYNC_SAVE_DELAY_MS
=
20
;
const
STATIC_BLOCKLIST_PATTERNS
=
[
{
creator
:
"
Mozilla
Corp
.
"
level
:
nsIBlocklistService
.
STATE_BLOCKED
blockID
:
"
i162
"
}
{
creator
:
"
Mozilla
.
org
"
level
:
nsIBlocklistService
.
STATE_BLOCKED
blockID
:
"
i162
"
}
]
;
function
findMatchingStaticBlocklistItem
(
aAddon
)
{
for
(
let
item
of
STATIC_BLOCKLIST_PATTERNS
)
{
if
(
"
creator
"
in
item
&
&
typeof
item
.
creator
=
=
"
string
"
)
{
if
(
(
aAddon
.
defaultLocale
&
&
aAddon
.
defaultLocale
.
creator
=
=
item
.
creator
)
|
|
(
aAddon
.
selectedLocale
&
&
aAddon
.
selectedLocale
.
creator
=
=
item
.
creator
)
)
{
return
item
;
}
}
}
return
null
;
}
async
function
getRepositoryAddon
(
aAddon
)
{
if
(
aAddon
)
{
aAddon
.
_repositoryAddon
=
await
AddonRepository
.
getCachedAddonByID
(
aAddon
.
id
)
;
}
return
aAddon
;
}
function
copyProperties
(
aObject
aProperties
aTarget
)
{
if
(
!
aTarget
)
aTarget
=
{
}
;
aProperties
.
forEach
(
function
(
aProp
)
{
if
(
aProp
in
aObject
)
aTarget
[
aProp
]
=
aObject
[
aProp
]
;
}
)
;
return
aTarget
;
}
const
wrapperMap
=
new
WeakMap
(
)
;
let
addonFor
=
wrapper
=
>
wrapperMap
.
get
(
wrapper
)
;
const
EMPTY_ARRAY
=
Object
.
freeze
(
[
]
)
;
let
AddonWrapper
;
class
AddonInternal
{
constructor
(
)
{
this
.
_hasResourceCache
=
new
Map
(
)
;
this
.
_wrapper
=
null
;
this
.
_selectedLocale
=
null
;
this
.
active
=
false
;
this
.
visible
=
false
;
this
.
userDisabled
=
false
;
this
.
appDisabled
=
false
;
this
.
softDisabled
=
false
;
this
.
blocklistState
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
;
this
.
blocklistURL
=
null
;
this
.
sourceURI
=
null
;
this
.
releaseNotesURI
=
null
;
this
.
foreignInstall
=
false
;
this
.
seen
=
true
;
this
.
skinnable
=
false
;
this
.
startupData
=
null
;
this
.
dependencies
=
EMPTY_ARRAY
;
this
.
hasEmbeddedWebExtension
=
false
;
}
get
wrapper
(
)
{
if
(
!
this
.
_wrapper
)
{
this
.
_wrapper
=
new
AddonWrapper
(
this
)
;
}
return
this
.
_wrapper
;
}
get
selectedLocale
(
)
{
if
(
this
.
_selectedLocale
)
return
this
.
_selectedLocale
;
const
locales
=
[
]
.
concat
(
.
.
.
this
.
locales
.
map
(
loc
=
>
loc
.
locales
)
)
;
let
requestedLocales
=
Services
.
locale
.
getRequestedLocales
(
)
;
if
(
!
requestedLocales
.
includes
(
"
en
-
US
"
)
)
{
requestedLocales
.
push
(
"
en
-
US
"
)
;
}
let
bestLocale
=
Services
.
locale
.
negotiateLanguages
(
requestedLocales
locales
"
und
"
Services
.
locale
.
langNegStrategyLookup
)
[
0
]
;
if
(
bestLocale
=
=
=
"
und
"
)
{
this
.
_selectedLocale
=
this
.
defaultLocale
;
}
else
{
this
.
_selectedLocale
=
this
.
locales
.
find
(
loc
=
>
loc
.
locales
.
includes
(
bestLocale
)
)
;
}
return
this
.
_selectedLocale
;
}
get
providesUpdatesSecurely
(
)
{
return
!
this
.
updateURL
|
|
this
.
updateURL
.
startsWith
(
"
https
:
"
)
;
}
get
isCorrectlySigned
(
)
{
switch
(
this
.
_installLocation
.
name
)
{
case
KEY_APP_SYSTEM_ADDONS
:
return
this
.
signedState
=
=
AddonManager
.
SIGNEDSTATE_SYSTEM
;
case
KEY_APP_SYSTEM_DEFAULTS
:
case
KEY_APP_TEMPORARY
:
return
true
;
case
KEY_APP_SYSTEM_SHARE
:
case
KEY_APP_SYSTEM_LOCAL
:
if
(
Services
.
appinfo
.
OS
!
=
"
Darwin
"
)
return
true
;
break
;
}
if
(
this
.
signedState
=
=
=
AddonManager
.
SIGNEDSTATE_NOT_REQUIRED
)
return
true
;
return
this
.
signedState
>
AddonManager
.
SIGNEDSTATE_MISSING
;
}
get
isCompatible
(
)
{
return
this
.
isCompatibleWith
(
)
;
}
get
disabled
(
)
{
return
(
this
.
userDisabled
|
|
this
.
appDisabled
|
|
this
.
softDisabled
)
;
}
get
isPlatformCompatible
(
)
{
if
(
this
.
targetPlatforms
.
length
=
=
0
)
return
true
;
let
matchedOS
=
false
;
let
needsABI
=
false
;
let
abi
=
null
;
try
{
abi
=
Services
.
appinfo
.
XPCOMABI
;
}
catch
(
e
)
{
}
try
{
for
(
let
platform
of
this
.
targetPlatforms
)
{
if
(
platform
.
os
=
=
Services
.
appinfo
.
OS
)
{
if
(
platform
.
abi
)
{
needsABI
=
true
;
if
(
platform
.
abi
=
=
=
abi
)
return
true
;
}
else
{
matchedOS
=
true
;
}
}
}
}
catch
(
e
)
{
let
message
=
"
Problem
with
addon
"
+
this
.
id
+
"
targetPlatforms
"
+
JSON
.
stringify
(
this
.
targetPlatforms
)
;
logger
.
error
(
message
e
)
;
AddonManagerPrivate
.
recordException
(
"
XPI
"
message
e
)
;
return
false
;
}
return
matchedOS
&
&
!
needsABI
;
}
isCompatibleWith
(
aAppVersion
aPlatformVersion
)
{
let
app
=
this
.
matchingTargetApplication
;
if
(
!
app
)
return
false
;
let
minVersion
=
app
.
minVersion
|
|
"
0
"
;
let
maxVersion
=
app
.
maxVersion
|
|
"
*
"
;
if
(
!
aAppVersion
)
aAppVersion
=
Services
.
appinfo
.
version
;
if
(
!
aPlatformVersion
)
aPlatformVersion
=
Services
.
appinfo
.
platformVersion
;
let
version
;
if
(
app
.
id
=
=
Services
.
appinfo
.
ID
)
version
=
aAppVersion
;
else
if
(
app
.
id
=
=
TOOLKIT_ID
)
version
=
aPlatformVersion
;
if
(
this
.
type
in
COMPATIBLE_BY_DEFAULT_TYPES
&
&
!
AddonManager
.
strictCompatibility
&
&
!
this
.
strictCompatibility
)
{
let
overrides
=
AddonRepository
.
getCompatibilityOverridesSync
(
this
.
id
)
;
if
(
overrides
)
{
let
override
=
AddonRepository
.
findMatchingCompatOverride
(
this
.
version
overrides
)
;
if
(
override
)
{
return
false
;
}
}
let
minCompatVersion
;
if
(
app
.
id
=
=
Services
.
appinfo
.
ID
)
minCompatVersion
=
XPIProvider
.
minCompatibleAppVersion
;
else
if
(
app
.
id
=
=
TOOLKIT_ID
)
minCompatVersion
=
XPIProvider
.
minCompatiblePlatformVersion
;
if
(
minCompatVersion
&
&
Services
.
vc
.
compare
(
minCompatVersion
maxVersion
)
>
0
)
return
false
;
return
Services
.
vc
.
compare
(
version
minVersion
)
>
=
0
;
}
return
(
Services
.
vc
.
compare
(
version
minVersion
)
>
=
0
)
&
&
(
Services
.
vc
.
compare
(
version
maxVersion
)
<
=
0
)
;
}
get
matchingTargetApplication
(
)
{
let
app
=
null
;
for
(
let
targetApp
of
this
.
targetApplications
)
{
if
(
targetApp
.
id
=
=
Services
.
appinfo
.
ID
)
return
targetApp
;
if
(
targetApp
.
id
=
=
TOOLKIT_ID
)
app
=
targetApp
;
}
return
app
;
}
async
findBlocklistEntry
(
)
{
let
staticItem
=
findMatchingStaticBlocklistItem
(
this
)
;
if
(
staticItem
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_BLOCKLIST_ITEM_URL
)
;
return
{
state
:
staticItem
.
level
url
:
url
.
replace
(
/
%
blockID
%
/
g
staticItem
.
blockID
)
}
;
}
return
Blocklist
.
getAddonBlocklistEntry
(
this
.
wrapper
)
;
}
async
updateBlocklistState
(
options
=
{
}
)
{
let
{
applySoftBlock
=
true
oldAddon
=
null
updateDatabase
=
true
}
=
options
;
if
(
oldAddon
)
{
this
.
userDisabled
=
oldAddon
.
userDisabled
;
this
.
softDisabled
=
oldAddon
.
softDisabled
;
this
.
blocklistState
=
oldAddon
.
blocklistState
;
}
let
oldState
=
this
.
blocklistState
;
let
entry
=
await
this
.
findBlocklistEntry
(
)
;
let
newState
=
entry
?
entry
.
state
:
Services
.
blocklist
.
STATE_NOT_BLOCKED
;
this
.
blocklistState
=
newState
;
this
.
blocklistURL
=
entry
&
&
entry
.
url
;
let
userDisabled
softDisabled
;
if
(
applySoftBlock
&
&
oldState
!
=
newState
)
{
if
(
newState
=
=
Services
.
blocklist
.
STATE_SOFTBLOCKED
)
{
if
(
this
.
type
=
=
"
theme
"
)
{
userDisabled
=
true
;
}
else
{
softDisabled
=
!
this
.
userDisabled
;
}
}
else
{
softDisabled
=
false
;
}
}
if
(
this
.
inDatabase
&
&
updateDatabase
)
{
XPIDatabase
.
updateAddonDisabledState
(
this
userDisabled
softDisabled
)
;
XPIDatabase
.
saveChanges
(
)
;
}
else
{
this
.
appDisabled
=
!
XPIDatabase
.
isUsableAddon
(
this
)
;
if
(
userDisabled
!
=
=
undefined
)
{
this
.
userDisabled
=
userDisabled
;
}
if
(
softDisabled
!
=
=
undefined
)
{
this
.
softDisabled
=
softDisabled
;
}
}
}
applyCompatibilityUpdate
(
aUpdate
aSyncCompatibility
)
{
for
(
let
targetApp
of
this
.
targetApplications
)
{
for
(
let
updateTarget
of
aUpdate
.
targetApplications
)
{
if
(
targetApp
.
id
=
=
updateTarget
.
id
&
&
(
aSyncCompatibility
|
|
Services
.
vc
.
compare
(
targetApp
.
maxVersion
updateTarget
.
maxVersion
)
<
0
)
)
{
targetApp
.
minVersion
=
updateTarget
.
minVersion
;
targetApp
.
maxVersion
=
updateTarget
.
maxVersion
;
}
}
}
this
.
appDisabled
=
!
XPIDatabase
.
isUsableAddon
(
this
)
;
}
toJSON
(
)
{
let
obj
=
{
}
;
for
(
let
prop
in
this
)
{
if
(
prop
=
=
"
wrapper
"
)
continue
;
if
(
prop
.
substring
(
0
1
)
=
=
"
_
"
)
continue
;
if
(
this
.
__lookupGetter__
(
prop
)
)
continue
;
if
(
this
.
__lookupSetter__
(
prop
)
)
continue
;
if
(
typeof
this
[
prop
]
=
=
"
function
"
)
continue
;
obj
[
prop
]
=
this
[
prop
]
;
}
return
obj
;
}
importMetadata
(
aObj
)
{
for
(
let
prop
of
PENDING_INSTALL_METADATA
)
{
if
(
!
(
prop
in
aObj
)
)
continue
;
this
[
prop
]
=
aObj
[
prop
]
;
}
this
.
appDisabled
=
!
XPIDatabase
.
isUsableAddon
(
this
)
;
}
permissions
(
)
{
let
permissions
=
0
;
if
(
!
(
this
.
inDatabase
)
)
return
permissions
;
if
(
!
this
.
appDisabled
)
{
if
(
this
.
userDisabled
|
|
this
.
softDisabled
)
{
permissions
|
=
AddonManager
.
PERM_CAN_ENABLE
;
}
else
if
(
this
.
type
!
=
"
theme
"
)
{
permissions
|
=
AddonManager
.
PERM_CAN_DISABLE
;
}
}
if
(
!
this
.
_installLocation
.
locked
&
&
!
this
.
pendingUninstall
)
{
let
isSystem
=
this
.
_installLocation
.
isSystem
;
if
(
!
this
.
_installLocation
.
isLinkedAddon
(
this
.
id
)
&
&
!
isSystem
)
{
permissions
|
=
AddonManager
.
PERM_CAN_UPGRADE
;
}
permissions
|
=
AddonManager
.
PERM_CAN_UNINSTALL
;
}
if
(
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
modify
-
extension
:
{
this
.
id
}
)
)
{
permissions
&
=
~
AddonManager
.
PERM_CAN_UNINSTALL
;
permissions
&
=
~
AddonManager
.
PERM_CAN_DISABLE
;
}
return
permissions
;
}
}
AddonWrapper
=
class
{
constructor
(
aAddon
)
{
wrapperMap
.
set
(
this
aAddon
)
;
}
get
__AddonInternal__
(
)
{
return
AppConstants
.
DEBUG
?
addonFor
(
this
)
:
undefined
;
}
get
seen
(
)
{
return
addonFor
(
this
)
.
seen
;
}
get
hasEmbeddedWebExtension
(
)
{
return
addonFor
(
this
)
.
hasEmbeddedWebExtension
;
}
markAsSeen
(
)
{
addonFor
(
this
)
.
seen
=
true
;
XPIDatabase
.
saveChanges
(
)
;
}
get
type
(
)
{
return
XPIInternal
.
getExternalType
(
addonFor
(
this
)
.
type
)
;
}
get
isWebExtension
(
)
{
return
isWebExtension
(
addonFor
(
this
)
.
type
)
;
}
get
temporarilyInstalled
(
)
{
return
addonFor
(
this
)
.
_installLocation
=
=
XPIInternal
.
TemporaryInstallLocation
;
}
get
aboutURL
(
)
{
return
this
.
isActive
?
addonFor
(
this
)
.
aboutURL
:
null
;
}
get
optionsURL
(
)
{
if
(
!
this
.
isActive
)
{
return
null
;
}
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
optionsURL
)
{
if
(
this
.
isWebExtension
|
|
this
.
hasEmbeddedWebExtension
)
{
let
policy
=
WebExtensionPolicy
.
getByID
(
addon
.
id
)
;
if
(
!
policy
)
{
return
null
;
}
let
base
=
policy
.
getURL
(
)
;
return
new
URL
(
addon
.
optionsURL
base
)
.
href
;
}
return
addon
.
optionsURL
;
}
return
null
;
}
get
optionsType
(
)
{
if
(
!
this
.
isActive
)
return
null
;
let
addon
=
addonFor
(
this
)
;
let
hasOptionsURL
=
!
!
this
.
optionsURL
;
if
(
addon
.
optionsType
)
{
switch
(
parseInt
(
addon
.
optionsType
10
)
)
{
case
AddonManager
.
OPTIONS_TYPE_TAB
:
case
AddonManager
.
OPTIONS_TYPE_INLINE_BROWSER
:
return
hasOptionsURL
?
addon
.
optionsType
:
null
;
}
return
null
;
}
return
null
;
}
get
optionsBrowserStyle
(
)
{
let
addon
=
addonFor
(
this
)
;
return
addon
.
optionsBrowserStyle
;
}
async
getBlocklistURL
(
)
{
return
addonFor
(
this
)
.
blocklistURL
;
}
get
iconURL
(
)
{
return
AddonManager
.
getPreferredIconURL
(
this
48
)
;
}
get
icon64URL
(
)
{
return
AddonManager
.
getPreferredIconURL
(
this
64
)
;
}
get
icons
(
)
{
let
addon
=
addonFor
(
this
)
;
let
icons
=
{
}
;
if
(
addon
.
_repositoryAddon
)
{
for
(
let
size
in
addon
.
_repositoryAddon
.
icons
)
{
icons
[
size
]
=
addon
.
_repositoryAddon
.
icons
[
size
]
;
}
}
if
(
addon
.
icons
)
{
for
(
let
size
in
addon
.
icons
)
{
icons
[
size
]
=
this
.
getResourceURI
(
addon
.
icons
[
size
]
)
.
spec
;
}
}
else
{
if
(
this
.
hasResource
(
"
icon
.
png
"
)
)
{
icons
[
32
]
=
icons
[
48
]
=
this
.
getResourceURI
(
"
icon
.
png
"
)
.
spec
;
}
if
(
this
.
hasResource
(
"
icon64
.
png
"
)
)
{
icons
[
64
]
=
this
.
getResourceURI
(
"
icon64
.
png
"
)
.
spec
;
}
}
let
canUseIconURLs
=
this
.
isActive
;
if
(
canUseIconURLs
&
&
addon
.
iconURL
)
{
icons
[
32
]
=
addon
.
iconURL
;
icons
[
48
]
=
addon
.
iconURL
;
}
if
(
canUseIconURLs
&
&
addon
.
icon64URL
)
{
icons
[
64
]
=
addon
.
icon64URL
;
}
Object
.
freeze
(
icons
)
;
return
icons
;
}
get
screenshots
(
)
{
let
addon
=
addonFor
(
this
)
;
let
repositoryAddon
=
addon
.
_repositoryAddon
;
if
(
repositoryAddon
&
&
(
"
screenshots
"
in
repositoryAddon
)
)
{
let
repositoryScreenshots
=
repositoryAddon
.
screenshots
;
if
(
repositoryScreenshots
&
&
repositoryScreenshots
.
length
>
0
)
return
repositoryScreenshots
;
}
if
(
isTheme
(
addon
.
type
)
&
&
this
.
hasResource
(
"
preview
.
png
"
)
)
{
let
url
=
this
.
getResourceURI
(
"
preview
.
png
"
)
.
spec
;
return
[
new
AddonManagerPrivate
.
AddonScreenshot
(
url
)
]
;
}
return
null
;
}
get
applyBackgroundUpdates
(
)
{
return
addonFor
(
this
)
.
applyBackgroundUpdates
;
}
set
applyBackgroundUpdates
(
val
)
{
let
addon
=
addonFor
(
this
)
;
if
(
val
!
=
AddonManager
.
AUTOUPDATE_DEFAULT
&
&
val
!
=
AddonManager
.
AUTOUPDATE_DISABLE
&
&
val
!
=
AddonManager
.
AUTOUPDATE_ENABLE
)
{
val
=
val
?
AddonManager
.
AUTOUPDATE_DEFAULT
:
AddonManager
.
AUTOUPDATE_DISABLE
;
}
if
(
val
=
=
addon
.
applyBackgroundUpdates
)
return
val
;
XPIDatabase
.
setAddonProperties
(
addon
{
applyBackgroundUpdates
:
val
}
)
;
AddonManagerPrivate
.
callAddonListeners
(
"
onPropertyChanged
"
this
[
"
applyBackgroundUpdates
"
]
)
;
return
val
;
}
set
syncGUID
(
val
)
{
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
syncGUID
=
=
val
)
return
val
;
if
(
addon
.
inDatabase
)
XPIDatabase
.
setAddonSyncGUID
(
addon
val
)
;
addon
.
syncGUID
=
val
;
return
val
;
}
get
install
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
!
(
"
_install
"
in
addon
)
|
|
!
addon
.
_install
)
return
null
;
return
addon
.
_install
.
wrapper
;
}
get
pendingUpgrade
(
)
{
let
addon
=
addonFor
(
this
)
;
return
addon
.
pendingUpgrade
?
addon
.
pendingUpgrade
.
wrapper
:
null
;
}
get
scope
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
_installLocation
)
return
addon
.
_installLocation
.
scope
;
return
AddonManager
.
SCOPE_PROFILE
;
}
get
pendingOperations
(
)
{
let
addon
=
addonFor
(
this
)
;
let
pending
=
0
;
if
(
!
(
addon
.
inDatabase
)
)
{
if
(
!
addon
.
_install
|
|
addon
.
_install
.
state
=
=
AddonManager
.
STATE_INSTALLING
|
|
addon
.
_install
.
state
=
=
AddonManager
.
STATE_INSTALLED
)
return
AddonManager
.
PENDING_INSTALL
;
}
else
if
(
addon
.
pendingUninstall
)
{
return
AddonManager
.
PENDING_UNINSTALL
;
}
if
(
addon
.
active
&
&
addon
.
disabled
)
pending
|
=
AddonManager
.
PENDING_DISABLE
;
else
if
(
!
addon
.
active
&
&
!
addon
.
disabled
)
pending
|
=
AddonManager
.
PENDING_ENABLE
;
if
(
addon
.
pendingUpgrade
)
pending
|
=
AddonManager
.
PENDING_UPGRADE
;
return
pending
;
}
get
operationsRequiringRestart
(
)
{
return
0
;
}
get
isDebuggable
(
)
{
return
this
.
isActive
&
&
addonFor
(
this
)
.
bootstrap
;
}
get
permissions
(
)
{
return
addonFor
(
this
)
.
permissions
(
)
;
}
get
isActive
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
!
addon
.
active
)
return
false
;
if
(
!
Services
.
appinfo
.
inSafeMode
)
return
true
;
return
addon
.
bootstrap
&
&
XPIInternal
.
canRunInSafeMode
(
addon
)
;
}
get
startupPromise
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
!
addon
.
bootstrap
|
|
!
this
.
isActive
)
return
null
;
let
activeAddon
=
XPIProvider
.
activeAddons
.
get
(
addon
.
id
)
;
if
(
activeAddon
)
return
activeAddon
.
startupPromise
|
|
null
;
return
null
;
}
updateBlocklistState
(
applySoftBlock
=
true
)
{
return
addonFor
(
this
)
.
updateBlocklistState
(
{
applySoftBlock
}
)
;
}
get
userDisabled
(
)
{
let
addon
=
addonFor
(
this
)
;
return
addon
.
softDisabled
|
|
addon
.
userDisabled
;
}
set
userDisabled
(
val
)
{
let
addon
=
addonFor
(
this
)
;
if
(
val
=
=
this
.
userDisabled
)
{
return
val
;
}
if
(
addon
.
inDatabase
)
{
if
(
this
.
hidden
)
{
throw
new
Error
(
Cannot
disable
hidden
add
-
on
{
addon
.
id
}
)
;
}
XPIDatabase
.
updateAddonDisabledState
(
addon
val
)
;
}
else
{
addon
.
userDisabled
=
val
;
if
(
!
val
)
addon
.
softDisabled
=
false
;
}
return
val
;
}
set
softDisabled
(
val
)
{
let
addon
=
addonFor
(
this
)
;
if
(
val
=
=
addon
.
softDisabled
)
return
val
;
if
(
addon
.
inDatabase
)
{
if
(
isTheme
(
addon
.
type
)
&
&
val
&
&
!
addon
.
userDisabled
)
{
if
(
isWebExtension
(
addon
.
type
)
)
XPIDatabase
.
updateAddonDisabledState
(
addon
undefined
val
)
;
}
else
{
XPIDatabase
.
updateAddonDisabledState
(
addon
undefined
val
)
;
}
}
else
if
(
!
addon
.
userDisabled
)
{
addon
.
softDisabled
=
val
;
}
return
val
;
}
get
hidden
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
_installLocation
.
name
=
=
KEY_APP_TEMPORARY
)
return
false
;
return
addon
.
_installLocation
.
isSystem
;
}
get
isSystem
(
)
{
let
addon
=
addonFor
(
this
)
;
return
addon
.
_installLocation
.
isSystem
;
}
get
isSyncable
(
)
{
let
addon
=
addonFor
(
this
)
;
return
(
addon
.
_installLocation
.
name
=
=
KEY_APP_PROFILE
)
;
}
get
userPermissions
(
)
{
return
addonFor
(
this
)
.
userPermissions
;
}
isCompatibleWith
(
aAppVersion
aPlatformVersion
)
{
return
addonFor
(
this
)
.
isCompatibleWith
(
aAppVersion
aPlatformVersion
)
;
}
uninstall
(
alwaysAllowUndo
)
{
let
addon
=
addonFor
(
this
)
;
XPIProvider
.
uninstallAddon
(
addon
alwaysAllowUndo
)
;
}
cancelUninstall
(
)
{
let
addon
=
addonFor
(
this
)
;
XPIProvider
.
cancelUninstallAddon
(
addon
)
;
}
findUpdates
(
aListener
aReason
aAppVersion
aPlatformVersion
)
{
new
UpdateChecker
(
addonFor
(
this
)
aListener
aReason
aAppVersion
aPlatformVersion
)
;
}
cancelUpdate
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
_updateCheck
)
{
addon
.
_updateCheck
.
cancel
(
)
;
return
true
;
}
return
false
;
}
hasResource
(
aPath
)
{
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
_hasResourceCache
.
has
(
aPath
)
)
return
addon
.
_hasResourceCache
.
get
(
aPath
)
;
let
bundle
=
addon
.
_sourceBundle
.
clone
(
)
;
try
{
var
isDir
=
bundle
.
isDirectory
(
)
;
}
catch
(
e
)
{
addon
.
_hasResourceCache
.
set
(
aPath
false
)
;
return
false
;
}
if
(
isDir
)
{
if
(
aPath
)
aPath
.
split
(
"
/
"
)
.
forEach
(
part
=
>
bundle
.
append
(
part
)
)
;
let
result
=
bundle
.
exists
(
)
;
addon
.
_hasResourceCache
.
set
(
aPath
result
)
;
return
result
;
}
let
zipReader
=
Cc
[
"
mozilla
.
org
/
libjar
/
zip
-
reader
;
1
"
]
.
createInstance
(
Ci
.
nsIZipReader
)
;
try
{
zipReader
.
open
(
bundle
)
;
let
result
=
zipReader
.
hasEntry
(
aPath
)
;
addon
.
_hasResourceCache
.
set
(
aPath
result
)
;
return
result
;
}
catch
(
e
)
{
addon
.
_hasResourceCache
.
set
(
aPath
false
)
;
return
false
;
}
finally
{
zipReader
.
close
(
)
;
}
}
reload
(
)
{
return
new
Promise
(
(
resolve
)
=
>
{
const
addon
=
addonFor
(
this
)
;
logger
.
debug
(
reloading
add
-
on
{
addon
.
id
}
)
;
if
(
!
this
.
temporarilyInstalled
)
{
let
addonFile
=
addon
.
getResourceURI
;
XPIDatabase
.
updateAddonDisabledState
(
addon
true
)
;
Services
.
obs
.
notifyObservers
(
addonFile
"
flush
-
cache
-
entry
"
)
;
XPIDatabase
.
updateAddonDisabledState
(
addon
false
)
;
resolve
(
)
;
}
else
{
resolve
(
AddonManager
.
installTemporaryAddon
(
addon
.
_sourceBundle
)
)
;
}
}
)
;
}
getResourceURI
(
aPath
)
{
let
addon
=
addonFor
(
this
)
;
if
(
!
aPath
)
return
Services
.
io
.
newFileURI
(
addon
.
_sourceBundle
)
;
return
XPIInternal
.
getURIForResourceInFile
(
addon
.
_sourceBundle
aPath
)
;
}
}
;
function
chooseValue
(
aAddon
aObj
aProp
)
{
let
repositoryAddon
=
aAddon
.
_repositoryAddon
;
let
objValue
=
aObj
[
aProp
]
;
if
(
repositoryAddon
&
&
(
aProp
in
repositoryAddon
)
&
&
(
objValue
=
=
=
undefined
|
|
objValue
=
=
=
null
)
)
{
return
[
repositoryAddon
[
aProp
]
true
]
;
}
return
[
objValue
false
]
;
}
function
defineAddonWrapperProperty
(
name
getter
)
{
Object
.
defineProperty
(
AddonWrapper
.
prototype
name
{
get
:
getter
enumerable
:
true
}
)
;
}
[
"
id
"
"
syncGUID
"
"
version
"
"
isCompatible
"
"
isPlatformCompatible
"
"
providesUpdatesSecurely
"
"
blocklistState
"
"
appDisabled
"
"
softDisabled
"
"
skinnable
"
"
size
"
"
foreignInstall
"
"
strictCompatibility
"
"
updateURL
"
"
dependencies
"
"
signedState
"
"
isCorrectlySigned
"
]
.
forEach
(
function
(
aProp
)
{
defineAddonWrapperProperty
(
aProp
function
(
)
{
let
addon
=
addonFor
(
this
)
;
return
(
aProp
in
addon
)
?
addon
[
aProp
]
:
undefined
;
}
)
;
}
)
;
[
"
fullDescription
"
"
developerComments
"
"
supportURL
"
"
contributionURL
"
"
averageRating
"
"
reviewCount
"
"
reviewURL
"
"
weeklyDownloads
"
]
.
forEach
(
function
(
aProp
)
{
defineAddonWrapperProperty
(
aProp
function
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
_repositoryAddon
)
return
addon
.
_repositoryAddon
[
aProp
]
;
return
null
;
}
)
;
}
)
;
[
"
installDate
"
"
updateDate
"
]
.
forEach
(
function
(
aProp
)
{
defineAddonWrapperProperty
(
aProp
function
(
)
{
return
new
Date
(
addonFor
(
this
)
[
aProp
]
)
;
}
)
;
}
)
;
[
"
sourceURI
"
"
releaseNotesURI
"
]
.
forEach
(
function
(
aProp
)
{
defineAddonWrapperProperty
(
aProp
function
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
aProp
=
=
"
sourceURI
"
&
&
this
.
temporarilyInstalled
)
{
return
Services
.
io
.
newFileURI
(
addon
.
_sourceBundle
)
;
}
let
[
target
fromRepo
]
=
chooseValue
(
addon
addon
aProp
)
;
if
(
!
target
)
return
null
;
if
(
fromRepo
)
return
target
;
return
Services
.
io
.
newURI
(
target
)
;
}
)
;
}
)
;
PROP_LOCALE_SINGLE
.
forEach
(
function
(
aProp
)
{
defineAddonWrapperProperty
(
aProp
function
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
aProp
=
=
"
creator
"
&
&
addon
.
_repositoryAddon
&
&
addon
.
_repositoryAddon
.
creator
)
{
return
addon
.
_repositoryAddon
.
creator
;
}
let
result
=
null
;
if
(
addon
.
active
)
{
try
{
let
pref
=
PREF_EM_EXTENSION_FORMAT
+
addon
.
id
+
"
.
"
+
aProp
;
let
value
=
Services
.
prefs
.
getPrefType
(
pref
)
!
=
Ci
.
nsIPrefBranch
.
PREF_INVALID
?
Services
.
prefs
.
getComplexValue
(
pref
Ci
.
nsIPrefLocalizedString
)
.
data
:
null
;
if
(
value
)
result
=
value
;
}
catch
(
e
)
{
}
}
if
(
result
=
=
null
)
[
result
]
=
chooseValue
(
addon
addon
.
selectedLocale
aProp
)
;
if
(
aProp
=
=
"
creator
"
)
return
result
?
new
AddonManagerPrivate
.
AddonAuthor
(
result
)
:
null
;
return
result
;
}
)
;
}
)
;
PROP_LOCALE_MULTI
.
forEach
(
function
(
aProp
)
{
defineAddonWrapperProperty
(
aProp
function
(
)
{
let
addon
=
addonFor
(
this
)
;
let
results
=
null
;
let
usedRepository
=
false
;
if
(
addon
.
active
)
{
let
pref
=
PREF_EM_EXTENSION_FORMAT
+
addon
.
id
+
"
.
"
+
aProp
.
substring
(
0
aProp
.
length
-
1
)
;
let
list
=
Services
.
prefs
.
getChildList
(
pref
{
}
)
;
if
(
list
.
length
>
0
)
{
list
.
sort
(
)
;
results
=
[
]
;
for
(
let
childPref
of
list
)
{
let
value
=
Services
.
prefs
.
getPrefType
(
childPref
)
!
=
Ci
.
nsIPrefBranch
.
PREF_INVALID
?
Services
.
prefs
.
getComplexValue
(
childPref
Ci
.
nsIPrefLocalizedString
)
.
data
:
null
;
if
(
value
)
results
.
push
(
value
)
;
}
}
}
if
(
results
=
=
null
)
[
results
usedRepository
]
=
chooseValue
(
addon
addon
.
selectedLocale
aProp
)
;
if
(
results
&
&
!
usedRepository
)
{
results
=
results
.
map
(
function
(
aResult
)
{
return
new
AddonManagerPrivate
.
AddonAuthor
(
aResult
)
;
}
)
;
}
return
results
;
}
)
;
}
)
;
class
DBAddonInternal
extends
AddonInternal
{
constructor
(
aLoaded
)
{
super
(
)
;
if
(
aLoaded
.
descriptor
)
{
if
(
!
aLoaded
.
path
)
{
aLoaded
.
path
=
descriptorToPath
(
aLoaded
.
descriptor
)
;
}
delete
aLoaded
.
descriptor
;
}
copyProperties
(
aLoaded
PROP_JSON_FIELDS
this
)
;
if
(
!
this
.
dependencies
)
this
.
dependencies
=
[
]
;
Object
.
freeze
(
this
.
dependencies
)
;
if
(
aLoaded
.
_installLocation
)
{
this
.
_installLocation
=
aLoaded
.
_installLocation
;
this
.
location
=
aLoaded
.
_installLocation
.
name
;
}
else
if
(
aLoaded
.
location
)
{
this
.
_installLocation
=
XPIProvider
.
installLocationsByName
[
this
.
location
]
;
}
this
.
_key
=
this
.
location
+
"
:
"
+
this
.
id
;
if
(
!
aLoaded
.
_sourceBundle
)
{
throw
new
Error
(
"
Expected
passed
argument
to
contain
a
path
"
)
;
}
this
.
_sourceBundle
=
aLoaded
.
_sourceBundle
;
}
applyCompatibilityUpdate
(
aUpdate
aSyncCompatibility
)
{
let
wasCompatible
=
this
.
isCompatible
;
this
.
targetApplications
.
forEach
(
function
(
aTargetApp
)
{
aUpdate
.
targetApplications
.
forEach
(
function
(
aUpdateTarget
)
{
if
(
aTargetApp
.
id
=
=
aUpdateTarget
.
id
&
&
(
aSyncCompatibility
|
|
Services
.
vc
.
compare
(
aTargetApp
.
maxVersion
aUpdateTarget
.
maxVersion
)
<
0
)
)
{
aTargetApp
.
minVersion
=
aUpdateTarget
.
minVersion
;
aTargetApp
.
maxVersion
=
aUpdateTarget
.
maxVersion
;
XPIDatabase
.
saveChanges
(
)
;
}
}
)
;
}
)
;
if
(
wasCompatible
!
=
this
.
isCompatible
)
XPIDatabase
.
updateAddonDisabledState
(
this
)
;
}
toJSON
(
)
{
return
copyProperties
(
this
PROP_JSON_FIELDS
)
;
}
get
inDatabase
(
)
{
return
true
;
}
}
function
_findAddon
(
addonDB
aFilter
)
{
for
(
let
addon
of
addonDB
.
values
(
)
)
{
if
(
aFilter
(
addon
)
)
{
return
addon
;
}
}
return
null
;
}
function
_filterDB
(
addonDB
aFilter
)
{
return
Array
.
from
(
addonDB
.
values
(
)
)
.
filter
(
aFilter
)
;
}
this
.
XPIDatabase
=
{
initialized
:
false
jsonFile
:
FileUtils
.
getFile
(
KEY_PROFILEDIR
[
FILE_JSON_DB
]
true
)
migrateData
:
null
activeBundles
:
null
_saveTask
:
null
_loadError
:
null
_saveError
:
null
get
lastError
(
)
{
if
(
this
.
_loadError
)
return
this
.
_loadError
;
if
(
this
.
_saveError
)
return
this
.
_saveError
;
return
null
;
}
async
_saveNow
(
)
{
try
{
let
json
=
JSON
.
stringify
(
this
)
;
let
path
=
this
.
jsonFile
.
path
;
await
OS
.
File
.
writeAtomic
(
path
json
{
tmpPath
:
{
path
}
.
tmp
}
)
;
if
(
!
this
.
_schemaVersionSet
)
{
logger
.
debug
(
"
XPI
Database
saved
setting
schema
version
preference
to
"
+
DB_SCHEMA
)
;
Services
.
prefs
.
setIntPref
(
PREF_DB_SCHEMA
DB_SCHEMA
)
;
this
.
_schemaVersionSet
=
true
;
this
.
_loadError
=
null
;
}
}
catch
(
error
)
{
logger
.
warn
(
"
Failed
to
save
XPI
database
"
error
)
;
this
.
_saveError
=
error
;
throw
error
;
}
}
saveChanges
(
)
{
if
(
!
this
.
initialized
)
{
throw
new
Error
(
"
Attempt
to
use
XPI
database
when
it
is
not
initialized
"
)
;
}
if
(
XPIProvider
.
_closing
)
{
let
err
=
new
Error
(
"
XPI
database
modified
after
shutdown
began
"
)
;
logger
.
warn
(
err
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_late_stack
"
Log
.
stackTrace
(
err
)
)
;
}
if
(
!
this
.
_saveTask
)
{
this
.
_saveTask
=
new
DeferredTask
(
(
)
=
>
this
.
_saveNow
(
)
ASYNC_SAVE_DELAY_MS
)
;
}
this
.
_saveTask
.
arm
(
)
;
}
async
finalize
(
)
{
if
(
!
this
.
_saveTask
)
{
return
;
}
await
this
.
_saveTask
.
finalize
(
)
;
}
toJSON
(
)
{
if
(
!
this
.
addonDB
)
{
throw
new
Error
(
"
Attempt
to
save
database
without
loading
it
first
"
)
;
}
let
toSave
=
{
schemaVersion
:
DB_SCHEMA
addons
:
Array
.
from
(
this
.
addonDB
.
values
(
)
)
.
filter
(
addon
=
>
addon
.
location
!
=
KEY_APP_TEMPORARY
)
}
;
return
toSave
;
}
syncLoadDB
(
aRebuildOnError
)
{
this
.
migrateData
=
null
;
let
fstream
=
null
;
let
data
=
"
"
;
try
{
let
readTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_syncRead_MS
"
)
;
logger
.
debug
(
"
Opening
XPI
database
"
+
this
.
jsonFile
.
path
)
;
fstream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fstream
.
init
(
this
.
jsonFile
-
1
0
0
)
;
let
cstream
=
null
;
try
{
cstream
=
Cc
[
"
mozilla
.
org
/
intl
/
converter
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIConverterInputStream
)
;
cstream
.
init
(
fstream
"
UTF
-
8
"
0
0
)
;
let
str
=
{
}
;
let
read
=
0
;
do
{
read
=
cstream
.
readString
(
0xffffffff
str
)
;
data
+
=
str
.
value
;
}
while
(
read
!
=
0
)
;
readTimer
.
done
(
)
;
this
.
parseDB
(
data
aRebuildOnError
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
load
XPI
JSON
data
from
profile
"
e
)
;
let
rebuildTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_rebuildReadFailed_MS
"
)
;
this
.
rebuildDatabase
(
aRebuildOnError
)
;
rebuildTimer
.
done
(
)
;
}
finally
{
if
(
cstream
)
cstream
.
close
(
)
;
}
}
catch
(
e
)
{
if
(
e
.
result
=
=
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
{
this
.
upgradeDB
(
aRebuildOnError
)
;
}
else
{
this
.
rebuildUnreadableDB
(
e
aRebuildOnError
)
;
}
}
finally
{
if
(
fstream
)
fstream
.
close
(
)
;
}
if
(
this
.
_dbPromise
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_overlapped_load
"
1
)
;
}
this
.
_dbPromise
=
Promise
.
resolve
(
this
.
addonDB
)
;
Services
.
obs
.
notifyObservers
(
this
.
addonDB
"
xpi
-
database
-
loaded
"
)
;
}
parseDB
(
aData
aRebuildOnError
)
{
let
parseTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_parseDB_MS
"
)
;
try
{
let
inputAddons
=
JSON
.
parse
(
aData
)
;
if
(
!
(
"
schemaVersion
"
in
inputAddons
)
|
|
!
(
"
addons
"
in
inputAddons
)
)
{
parseTimer
.
done
(
)
;
logger
.
error
(
"
bad
JSON
file
contents
"
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startupError
"
"
badJSON
"
)
;
let
rebuildTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_rebuildBadJSON_MS
"
)
;
this
.
rebuildDatabase
(
aRebuildOnError
)
;
rebuildTimer
.
done
(
)
;
return
;
}
if
(
inputAddons
.
schemaVersion
!
=
DB_SCHEMA
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startupError
"
"
schemaMismatch
-
"
+
inputAddons
.
schemaVersion
)
;
logger
.
debug
(
"
JSON
schema
mismatch
:
expected
"
+
DB_SCHEMA
+
"
actual
"
+
inputAddons
.
schemaVersion
)
;
}
let
addonDB
=
new
Map
(
)
;
for
(
let
loadedAddon
of
inputAddons
.
addons
)
{
try
{
if
(
!
loadedAddon
.
path
)
{
loadedAddon
.
path
=
descriptorToPath
(
loadedAddon
.
descriptor
)
;
}
loadedAddon
.
_sourceBundle
=
new
nsIFile
(
loadedAddon
.
path
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Could
not
find
source
bundle
for
add
-
on
"
+
loadedAddon
.
id
e
)
;
}
let
newAddon
=
new
DBAddonInternal
(
loadedAddon
)
;
addonDB
.
set
(
newAddon
.
_key
newAddon
)
;
}
parseTimer
.
done
(
)
;
this
.
addonDB
=
addonDB
;
logger
.
debug
(
"
Successfully
read
XPI
database
"
)
;
this
.
initialized
=
true
;
}
catch
(
e
)
{
parseTimer
.
done
(
)
;
if
(
e
.
name
=
=
"
SyntaxError
"
)
{
logger
.
error
(
"
Syntax
error
parsing
saved
XPI
JSON
data
"
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startupError
"
"
syntax
"
)
;
}
else
{
logger
.
error
(
"
Failed
to
load
XPI
JSON
data
from
profile
"
e
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startupError
"
"
other
"
)
;
}
let
rebuildTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_rebuildReadFailed_MS
"
)
;
this
.
rebuildDatabase
(
aRebuildOnError
)
;
rebuildTimer
.
done
(
)
;
}
}
upgradeDB
(
aRebuildOnError
)
{
let
upgradeTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_upgradeDB_MS
"
)
;
let
schemaVersion
=
Services
.
prefs
.
getIntPref
(
PREF_DB_SCHEMA
0
)
;
if
(
schemaVersion
>
LAST_SQLITE_DB_SCHEMA
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startupError
"
"
dbMissing
"
)
;
}
this
.
rebuildDatabase
(
aRebuildOnError
)
;
upgradeTimer
.
done
(
)
;
}
rebuildUnreadableDB
(
aError
aRebuildOnError
)
{
let
rebuildTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_rebuildUnreadableDB_MS
"
)
;
logger
.
warn
(
"
Extensions
database
"
+
this
.
jsonFile
.
path
+
"
exists
but
is
not
readable
;
rebuilding
"
aError
)
;
this
.
_loadError
=
aError
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startupError
"
"
unreadable
"
)
;
this
.
rebuildDatabase
(
aRebuildOnError
)
;
rebuildTimer
.
done
(
)
;
}
asyncLoadDB
(
)
{
if
(
this
.
_dbPromise
)
{
return
this
.
_dbPromise
;
}
logger
.
debug
(
"
Starting
async
load
of
XPI
database
"
+
this
.
jsonFile
.
path
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_async_load
"
XPIProvider
.
runPhase
)
;
let
readOptions
=
{
outExecutionDuration
:
0
}
;
this
.
_dbPromise
=
OS
.
File
.
read
(
this
.
jsonFile
.
path
null
readOptions
)
.
then
(
byteArray
=
>
{
logger
.
debug
(
"
Async
JSON
file
read
took
"
+
readOptions
.
outExecutionDuration
+
"
MS
"
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_asyncRead_MS
"
readOptions
.
outExecutionDuration
)
;
if
(
this
.
addonDB
)
{
logger
.
debug
(
"
Synchronous
load
completed
while
waiting
for
async
load
"
)
;
return
this
.
addonDB
;
}
logger
.
debug
(
"
Finished
async
read
of
XPI
database
parsing
.
.
.
"
)
;
let
decodeTimer
=
AddonManagerPrivate
.
simpleTimer
(
"
XPIDB_decode_MS
"
)
;
let
decoder
=
new
TextDecoder
(
)
;
let
data
=
decoder
.
decode
(
byteArray
)
;
decodeTimer
.
done
(
)
;
this
.
parseDB
(
data
true
)
;
return
this
.
addonDB
;
}
)
.
catch
(
error
=
>
{
if
(
this
.
addonDB
)
{
logger
.
debug
(
"
Synchronous
load
completed
while
waiting
for
async
load
"
)
;
return
this
.
addonDB
;
}
if
(
error
.
becauseNoSuchFile
)
{
this
.
upgradeDB
(
true
)
;
}
else
{
this
.
rebuildUnreadableDB
(
error
true
)
;
}
return
this
.
addonDB
;
}
)
;
this
.
_dbPromise
.
then
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
this
.
addonDB
"
xpi
-
database
-
loaded
"
)
;
}
)
;
return
this
.
_dbPromise
;
}
rebuildDatabase
(
aRebuildOnError
)
{
this
.
addonDB
=
new
Map
(
)
;
this
.
initialized
=
true
;
if
(
XPIStates
.
size
=
=
0
)
{
logger
.
debug
(
"
Rebuilding
XPI
database
with
no
extensions
"
)
;
return
;
}
if
(
!
this
.
migrateData
)
{
this
.
activeBundles
=
Array
.
from
(
XPIStates
.
initialEnabledAddons
(
)
addon
=
>
addon
.
path
)
;
if
(
!
this
.
activeBundles
.
length
)
this
.
activeBundles
=
null
;
}
if
(
aRebuildOnError
)
{
logger
.
warn
(
"
Rebuilding
add
-
ons
database
from
installed
extensions
.
"
)
;
try
{
XPIDatabaseReconcile
.
processFileChanges
(
{
}
false
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
rebuild
XPI
database
from
installed
extensions
"
e
)
;
}
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
true
)
;
}
}
async
shutdown
(
)
{
logger
.
debug
(
"
shutdown
"
)
;
if
(
this
.
initialized
)
{
if
(
this
.
lastError
)
this
.
saveChanges
(
)
;
this
.
initialized
=
false
;
if
(
this
.
_dbPromise
)
{
await
this
.
_dbPromise
;
}
await
this
.
finalize
(
)
;
if
(
this
.
_saveError
)
{
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
true
)
;
}
delete
this
.
addonDB
;
delete
this
.
_dbPromise
;
delete
this
.
_saveTask
;
delete
this
.
_schemaVersionSet
;
}
}
async
getAddonList
(
aFilter
)
{
try
{
let
addonDB
=
await
this
.
asyncLoadDB
(
)
;
let
addonList
=
_filterDB
(
addonDB
aFilter
)
;
let
addons
=
await
Promise
.
all
(
addonList
.
map
(
addon
=
>
getRepositoryAddon
(
addon
)
)
)
;
return
addons
;
}
catch
(
error
)
{
logger
.
error
(
"
getAddonList
failed
"
error
)
;
return
[
]
;
}
}
getAddon
(
aFilter
)
{
return
this
.
asyncLoadDB
(
)
.
then
(
addonDB
=
>
getRepositoryAddon
(
_findAddon
(
addonDB
aFilter
)
)
)
.
catch
(
error
=
>
{
logger
.
error
(
"
getAddon
failed
"
error
)
;
}
)
;
}
syncGetAddon
(
aFilter
)
{
return
_findAddon
(
this
.
addonDB
aFilter
)
;
}
getAddonInLocation
(
aId
aLocation
)
{
return
this
.
asyncLoadDB
(
)
.
then
(
addonDB
=
>
getRepositoryAddon
(
addonDB
.
get
(
aLocation
+
"
:
"
+
aId
)
)
)
;
}
getAddonsInLocation
(
aLocation
)
{
return
this
.
getAddonList
(
aAddon
=
>
aAddon
.
_installLocation
.
name
=
=
aLocation
)
;
}
getVisibleAddonForID
(
aId
)
{
return
this
.
getAddon
(
aAddon
=
>
(
(
aAddon
.
id
=
=
aId
)
&
&
aAddon
.
visible
)
)
;
}
syncGetVisibleAddonForID
(
aId
)
{
return
this
.
syncGetAddon
(
aAddon
=
>
(
(
aAddon
.
id
=
=
aId
)
&
&
aAddon
.
visible
)
)
;
}
getVisibleAddons
(
aTypes
)
{
return
this
.
getAddonList
(
aAddon
=
>
(
aAddon
.
visible
&
&
(
!
aTypes
|
|
(
aTypes
.
length
=
=
0
)
|
|
(
aTypes
.
indexOf
(
aAddon
.
type
)
>
-
1
)
)
)
)
;
}
getAddonsByType
(
.
.
.
aTypes
)
{
if
(
!
this
.
addonDB
)
{
logger
.
warn
(
Synchronous
load
of
XPI
database
due
to
+
getAddonsByType
(
[
{
aTypes
.
join
(
"
"
)
}
]
)
+
Stack
:
{
Error
(
)
.
stack
}
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_lateOpen_byType
"
XPIProvider
.
runPhase
)
;
this
.
syncLoadDB
(
true
)
;
}
return
_filterDB
(
this
.
addonDB
aAddon
=
>
aTypes
.
includes
(
aAddon
.
type
)
)
;
}
getVisibleAddonsWithPendingOperations
(
aTypes
)
{
return
this
.
getAddonList
(
aAddon
=
>
(
aAddon
.
visible
&
&
aAddon
.
pendingUninstall
&
&
(
!
aTypes
|
|
(
aTypes
.
length
=
=
0
)
|
|
(
aTypes
.
indexOf
(
aAddon
.
type
)
>
-
1
)
)
)
)
;
}
getAddonBySyncGUID
(
aGUID
)
{
return
this
.
getAddon
(
aAddon
=
>
aAddon
.
syncGUID
=
=
aGUID
)
;
}
getAddons
(
)
{
if
(
!
this
.
addonDB
)
{
return
[
]
;
}
return
_filterDB
(
this
.
addonDB
aAddon
=
>
true
)
;
}
mustSign
(
aType
)
{
if
(
!
SIGNED_TYPES
.
has
(
aType
)
)
return
false
;
if
(
aType
=
=
"
webextension
-
langpack
"
)
{
return
AddonSettings
.
LANGPACKS_REQUIRE_SIGNING
;
}
return
AddonSettings
.
REQUIRE_SIGNING
;
}
isDisabledLegacy
(
addon
)
{
return
(
!
AddonSettings
.
ALLOW_LEGACY_EXTENSIONS
&
&
LEGACY_TYPES
.
has
(
addon
.
type
)
&
&
!
addon
.
_installLocation
.
isSystem
&
&
!
(
AppConstants
.
MOZ_ALLOW_LEGACY_EXTENSIONS
&
&
addon
.
_installLocation
.
name
=
=
KEY_APP_TEMPORARY
)
&
&
addon
.
signedState
!
=
=
AddonManager
.
SIGNEDSTATE_PRIVILEGED
)
;
}
isUsableAddon
(
aAddon
)
{
if
(
this
.
mustSign
(
aAddon
.
type
)
&
&
!
aAddon
.
isCorrectlySigned
)
{
logger
.
warn
(
Add
-
on
{
aAddon
.
id
}
is
not
correctly
signed
.
)
;
if
(
Services
.
prefs
.
getBoolPref
(
PREF_XPI_SIGNATURES_DEV_ROOT
false
)
)
{
logger
.
warn
(
Preference
{
PREF_XPI_SIGNATURES_DEV_ROOT
}
is
set
.
)
;
}
return
false
;
}
if
(
aAddon
.
blocklistState
=
=
nsIBlocklistService
.
STATE_BLOCKED
)
{
logger
.
warn
(
Add
-
on
{
aAddon
.
id
}
is
blocklisted
.
)
;
return
false
;
}
if
(
aAddon
.
brokenManifest
)
{
return
false
;
}
if
(
AddonManager
.
checkUpdateSecurity
&
&
!
aAddon
.
providesUpdatesSecurely
)
{
logger
.
warn
(
Updates
for
add
-
on
{
aAddon
.
id
}
must
be
provided
over
HTTPS
.
)
;
return
false
;
}
if
(
!
aAddon
.
isPlatformCompatible
)
{
logger
.
warn
(
Add
-
on
{
aAddon
.
id
}
is
not
compatible
with
platform
.
)
;
return
false
;
}
if
(
aAddon
.
dependencies
.
length
)
{
let
isActive
=
id
=
>
{
let
active
=
XPIProvider
.
activeAddons
.
get
(
id
)
;
return
active
&
&
!
active
.
disable
;
}
;
if
(
aAddon
.
dependencies
.
some
(
id
=
>
!
isActive
(
id
)
)
)
return
false
;
}
if
(
this
.
isDisabledLegacy
(
aAddon
)
)
{
logger
.
warn
(
disabling
legacy
extension
{
aAddon
.
id
}
)
;
return
false
;
}
if
(
AddonManager
.
checkCompatibility
)
{
if
(
!
aAddon
.
isCompatible
)
{
logger
.
warn
(
Add
-
on
{
aAddon
.
id
}
is
not
compatible
with
application
version
.
)
;
return
false
;
}
}
else
{
let
app
=
aAddon
.
matchingTargetApplication
;
if
(
!
app
)
{
logger
.
warn
(
Add
-
on
{
aAddon
.
id
}
is
not
compatible
with
target
application
.
)
;
return
false
;
}
}
return
true
;
}
addAddonMetadata
(
aAddon
aPath
)
{
if
(
!
this
.
addonDB
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_lateOpen_addMetadata
"
XPIProvider
.
runPhase
)
;
this
.
syncLoadDB
(
false
)
;
}
let
newAddon
=
new
DBAddonInternal
(
aAddon
)
;
newAddon
.
path
=
aPath
;
this
.
addonDB
.
set
(
newAddon
.
_key
newAddon
)
;
if
(
newAddon
.
visible
)
{
this
.
makeAddonVisible
(
newAddon
)
;
}
this
.
saveChanges
(
)
;
return
newAddon
;
}
updateAddonMetadata
(
aOldAddon
aNewAddon
aPath
)
{
this
.
removeAddonMetadata
(
aOldAddon
)
;
aNewAddon
.
syncGUID
=
aOldAddon
.
syncGUID
;
aNewAddon
.
installDate
=
aOldAddon
.
installDate
;
aNewAddon
.
applyBackgroundUpdates
=
aOldAddon
.
applyBackgroundUpdates
;
aNewAddon
.
foreignInstall
=
aOldAddon
.
foreignInstall
;
aNewAddon
.
seen
=
aOldAddon
.
seen
;
aNewAddon
.
active
=
(
aNewAddon
.
visible
&
&
!
aNewAddon
.
disabled
&
&
!
aNewAddon
.
pendingUninstall
)
;
return
this
.
addAddonMetadata
(
aNewAddon
aPath
)
;
}
removeAddonMetadata
(
aAddon
)
{
this
.
addonDB
.
delete
(
aAddon
.
_key
)
;
this
.
saveChanges
(
)
;
}
updateXPIStates
(
addon
)
{
let
xpiState
=
XPIStates
.
getAddon
(
addon
.
location
addon
.
id
)
;
if
(
xpiState
)
{
xpiState
.
syncWithDB
(
addon
)
;
XPIStates
.
save
(
)
;
}
}
makeAddonVisible
(
aAddon
)
{
logger
.
debug
(
"
Make
addon
"
+
aAddon
.
_key
+
"
visible
"
)
;
for
(
let
[
otherAddon
]
of
this
.
addonDB
)
{
if
(
(
otherAddon
.
id
=
=
aAddon
.
id
)
&
&
(
otherAddon
.
_key
!
=
aAddon
.
_key
)
)
{
logger
.
debug
(
"
Hide
addon
"
+
otherAddon
.
_key
)
;
otherAddon
.
visible
=
false
;
otherAddon
.
active
=
false
;
this
.
updateXPIStates
(
otherAddon
)
;
}
}
aAddon
.
visible
=
true
;
this
.
updateXPIStates
(
aAddon
)
;
this
.
saveChanges
(
)
;
}
makeAddonLocationVisible
(
aId
aLocation
)
{
logger
.
debug
(
Make
addon
{
aId
}
visible
in
location
{
aLocation
}
)
;
let
result
;
for
(
let
[
addon
]
of
this
.
addonDB
)
{
if
(
addon
.
id
!
=
aId
)
{
continue
;
}
if
(
addon
.
location
=
=
aLocation
)
{
logger
.
debug
(
"
Reveal
addon
"
+
addon
.
_key
)
;
addon
.
visible
=
true
;
addon
.
active
=
true
;
this
.
updateXPIStates
(
addon
)
;
result
=
addon
;
}
else
{
logger
.
debug
(
"
Hide
addon
"
+
addon
.
_key
)
;
addon
.
visible
=
false
;
addon
.
active
=
false
;
this
.
updateXPIStates
(
addon
)
;
}
}
this
.
saveChanges
(
)
;
return
result
;
}
setAddonProperties
(
aAddon
aProperties
)
{
for
(
let
key
in
aProperties
)
{
aAddon
[
key
]
=
aProperties
[
key
]
;
}
this
.
saveChanges
(
)
;
}
setAddonSyncGUID
(
aAddon
aGUID
)
{
function
excludeSyncGUID
(
otherAddon
)
{
return
(
otherAddon
.
_key
!
=
aAddon
.
_key
)
&
&
(
otherAddon
.
syncGUID
=
=
aGUID
)
;
}
let
otherAddon
=
_findAddon
(
this
.
addonDB
excludeSyncGUID
)
;
if
(
otherAddon
)
{
throw
new
Error
(
"
Addon
sync
GUID
conflict
for
addon
"
+
aAddon
.
_key
+
"
:
"
+
otherAddon
.
_key
+
"
already
has
GUID
"
+
aGUID
)
;
}
aAddon
.
syncGUID
=
aGUID
;
this
.
saveChanges
(
)
;
}
updateAddonActive
(
aAddon
aActive
)
{
logger
.
debug
(
"
Updating
active
state
for
add
-
on
"
+
aAddon
.
id
+
"
to
"
+
aActive
)
;
aAddon
.
active
=
aActive
;
this
.
saveChanges
(
)
;
}
updateActiveAddons
(
)
{
if
(
!
this
.
addonDB
)
{
logger
.
warn
(
"
updateActiveAddons
called
when
DB
isn
'
t
loaded
"
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_lateOpen_updateActive
"
XPIProvider
.
runPhase
)
;
this
.
syncLoadDB
(
true
)
;
}
logger
.
debug
(
"
Updating
add
-
on
states
"
)
;
for
(
let
[
addon
]
of
this
.
addonDB
)
{
let
newActive
=
(
addon
.
visible
&
&
!
addon
.
disabled
&
&
!
addon
.
pendingUninstall
)
;
if
(
newActive
!
=
addon
.
active
)
{
addon
.
active
=
newActive
;
this
.
saveChanges
(
)
;
}
}
}
updateAddonDisabledState
(
aAddon
aUserDisabled
aSoftDisabled
aBecauseSelecting
)
{
if
(
!
(
aAddon
.
inDatabase
)
)
throw
new
Error
(
"
Can
only
update
addon
states
for
installed
addons
.
"
)
;
if
(
aUserDisabled
!
=
=
undefined
&
&
aSoftDisabled
!
=
=
undefined
)
{
throw
new
Error
(
"
Cannot
change
userDisabled
and
softDisabled
at
the
"
+
"
same
time
"
)
;
}
if
(
aUserDisabled
=
=
=
undefined
)
{
aUserDisabled
=
aAddon
.
userDisabled
;
}
else
if
(
!
aUserDisabled
)
{
aSoftDisabled
=
false
;
}
if
(
aSoftDisabled
=
=
=
undefined
|
|
aUserDisabled
)
aSoftDisabled
=
aAddon
.
softDisabled
;
let
appDisabled
=
!
this
.
isUsableAddon
(
aAddon
)
;
if
(
aAddon
.
userDisabled
=
=
aUserDisabled
&
&
aAddon
.
appDisabled
=
=
appDisabled
&
&
aAddon
.
softDisabled
=
=
aSoftDisabled
)
return
undefined
;
let
wasDisabled
=
aAddon
.
disabled
;
let
isDisabled
=
aUserDisabled
|
|
aSoftDisabled
|
|
appDisabled
;
let
appDisabledChanged
=
aAddon
.
appDisabled
!
=
appDisabled
;
this
.
setAddonProperties
(
aAddon
{
userDisabled
:
aUserDisabled
appDisabled
softDisabled
:
aSoftDisabled
}
)
;
let
wrapper
=
aAddon
.
wrapper
;
if
(
appDisabledChanged
)
{
AddonManagerPrivate
.
callAddonListeners
(
"
onPropertyChanged
"
wrapper
[
"
appDisabled
"
]
)
;
}
if
(
!
aAddon
.
visible
|
|
(
wasDisabled
=
=
isDisabled
)
)
return
undefined
;
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
true
)
;
let
xpiState
=
XPIStates
.
getAddon
(
aAddon
.
location
aAddon
.
id
)
;
if
(
xpiState
)
{
xpiState
.
syncWithDB
(
aAddon
)
;
XPIStates
.
save
(
)
;
}
else
{
logger
.
warn
(
"
No
XPIState
for
{
id
}
in
{
location
}
"
aAddon
)
;
}
if
(
isDisabled
!
=
aAddon
.
active
)
{
AddonManagerPrivate
.
callAddonListeners
(
"
onOperationCancelled
"
wrapper
)
;
}
else
{
if
(
isDisabled
)
{
AddonManagerPrivate
.
callAddonListeners
(
"
onDisabling
"
wrapper
false
)
;
}
else
{
AddonManagerPrivate
.
callAddonListeners
(
"
onEnabling
"
wrapper
false
)
;
}
this
.
updateAddonActive
(
aAddon
!
isDisabled
)
;
if
(
isDisabled
)
{
if
(
aAddon
.
bootstrap
&
&
XPIProvider
.
activeAddons
.
has
(
aAddon
.
id
)
)
{
XPIProvider
.
callBootstrapMethod
(
aAddon
aAddon
.
_sourceBundle
"
shutdown
"
BOOTSTRAP_REASONS
.
ADDON_DISABLE
)
;
XPIProvider
.
unloadBootstrapScope
(
aAddon
.
id
)
;
}
AddonManagerPrivate
.
callAddonListeners
(
"
onDisabled
"
wrapper
)
;
}
else
{
if
(
aAddon
.
bootstrap
)
{
XPIProvider
.
callBootstrapMethod
(
aAddon
aAddon
.
_sourceBundle
"
startup
"
BOOTSTRAP_REASONS
.
ADDON_ENABLE
)
;
}
AddonManagerPrivate
.
callAddonListeners
(
"
onEnabled
"
wrapper
)
;
}
}
if
(
isTheme
(
aAddon
.
type
)
)
{
if
(
!
isDisabled
)
{
AddonManagerPrivate
.
notifyAddonChanged
(
aAddon
.
id
aAddon
.
type
)
;
if
(
xpiState
)
{
xpiState
.
syncWithDB
(
aAddon
)
;
XPIStates
.
save
(
)
;
}
}
else
if
(
isDisabled
&
&
!
aBecauseSelecting
)
{
AddonManagerPrivate
.
notifyAddonChanged
(
null
"
theme
"
)
;
}
}
return
isDisabled
;
}
recordAddonTelemetry
(
aAddon
)
{
let
locale
=
aAddon
.
defaultLocale
;
if
(
locale
)
{
if
(
locale
.
name
)
XPIProvider
.
setTelemetry
(
aAddon
.
id
"
name
"
locale
.
name
)
;
if
(
locale
.
creator
)
XPIProvider
.
setTelemetry
(
aAddon
.
id
"
creator
"
locale
.
creator
)
;
}
}
}
;
this
.
XPIDatabaseReconcile
=
{
flattenByID
(
addonMap
hideLocation
)
{
let
map
=
new
Map
(
)
;
for
(
let
installLocation
of
XPIProvider
.
installLocations
)
{
if
(
installLocation
.
name
=
=
hideLocation
)
continue
;
let
locationMap
=
addonMap
.
get
(
installLocation
.
name
)
;
if
(
!
locationMap
)
continue
;
for
(
let
[
id
addon
]
of
locationMap
)
{
if
(
!
map
.
has
(
id
)
)
map
.
set
(
id
addon
)
;
}
}
return
map
;
}
getVisibleAddons
(
addonMap
)
{
let
map
=
new
Map
(
)
;
for
(
let
addons
of
addonMap
.
values
(
)
)
{
for
(
let
[
id
addon
]
of
addons
)
{
if
(
!
addon
.
visible
)
continue
;
if
(
map
.
has
(
id
)
)
{
logger
.
warn
(
"
Previous
database
listed
more
than
one
visible
add
-
on
with
id
"
+
id
)
;
continue
;
}
map
.
set
(
id
addon
)
;
}
}
return
map
;
}
addMetadata
(
aInstallLocation
aId
aAddonState
aNewAddon
aOldAppVersion
aOldPlatformVersion
)
{
logger
.
debug
(
"
New
add
-
on
"
+
aId
+
"
installed
in
"
+
aInstallLocation
.
name
)
;
let
isNewInstall
=
!
!
aNewAddon
|
|
!
XPIDatabase
.
activeBundles
;
let
isDetectedInstall
=
isNewInstall
&
&
!
aNewAddon
;
try
{
if
(
!
aNewAddon
)
{
let
file
=
new
nsIFile
(
aAddonState
.
path
)
;
aNewAddon
=
XPIInstall
.
syncLoadManifestFromFile
(
file
aInstallLocation
)
;
}
if
(
aNewAddon
.
id
!
=
aId
)
{
throw
new
Error
(
"
Invalid
addon
ID
:
expected
addon
ID
"
+
aId
+
"
found
"
+
aNewAddon
.
id
+
"
in
manifest
"
)
;
}
}
catch
(
e
)
{
logger
.
warn
(
"
addMetadata
:
Add
-
on
"
+
aId
+
"
is
invalid
"
e
)
;
if
(
aInstallLocation
.
isLinkedAddon
(
aId
)
)
logger
.
warn
(
"
Not
uninstalling
invalid
item
because
it
is
a
proxy
file
"
)
;
else
if
(
aInstallLocation
.
locked
)
logger
.
warn
(
"
Could
not
uninstall
invalid
item
from
locked
install
location
"
)
;
else
aInstallLocation
.
uninstallAddon
(
aId
)
;
return
null
;
}
aNewAddon
.
installDate
=
aAddonState
.
mtime
;
aNewAddon
.
updateDate
=
aAddonState
.
mtime
;
aNewAddon
.
foreignInstall
=
isDetectedInstall
&
&
aInstallLocation
.
name
!
=
KEY_APP_SYSTEM_ADDONS
&
&
aInstallLocation
.
name
!
=
KEY_APP_SYSTEM_DEFAULTS
;
aNewAddon
.
appDisabled
=
!
XPIDatabase
.
isUsableAddon
(
aNewAddon
)
;
if
(
isDetectedInstall
&
&
aNewAddon
.
foreignInstall
)
{
let
disablingScopes
=
Services
.
prefs
.
getIntPref
(
PREF_EM_AUTO_DISABLED_SCOPES
0
)
;
if
(
aInstallLocation
.
scope
&
disablingScopes
)
{
logger
.
warn
(
"
Disabling
foreign
installed
add
-
on
"
+
aNewAddon
.
id
+
"
in
"
+
aInstallLocation
.
name
)
;
aNewAddon
.
userDisabled
=
true
;
aNewAddon
.
seen
=
false
;
}
}
return
XPIDatabase
.
addAddonMetadata
(
aNewAddon
aAddonState
.
path
)
;
}
removeMetadata
(
aOldAddon
)
{
logger
.
debug
(
"
Add
-
on
"
+
aOldAddon
.
id
+
"
removed
from
"
+
aOldAddon
.
location
)
;
XPIDatabase
.
removeAddonMetadata
(
aOldAddon
)
;
}
updateMetadata
(
aInstallLocation
aOldAddon
aAddonState
aNewAddon
)
{
logger
.
debug
(
"
Add
-
on
"
+
aOldAddon
.
id
+
"
modified
in
"
+
aInstallLocation
.
name
)
;
try
{
if
(
!
aNewAddon
)
{
let
file
=
new
nsIFile
(
aAddonState
.
path
)
;
aNewAddon
=
XPIInstall
.
syncLoadManifestFromFile
(
file
aInstallLocation
aOldAddon
)
;
}
if
(
aNewAddon
.
id
!
=
aOldAddon
.
id
)
throw
new
Error
(
"
Incorrect
id
in
install
manifest
for
existing
add
-
on
"
+
aOldAddon
.
id
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
updateMetadata
:
Add
-
on
"
+
aOldAddon
.
id
+
"
is
invalid
"
e
)
;
XPIDatabase
.
removeAddonMetadata
(
aOldAddon
)
;
XPIStates
.
removeAddon
(
aOldAddon
.
location
aOldAddon
.
id
)
;
if
(
!
aInstallLocation
.
locked
)
aInstallLocation
.
uninstallAddon
(
aOldAddon
.
id
)
;
else
logger
.
warn
(
"
Could
not
uninstall
invalid
item
from
locked
install
location
"
)
;
return
null
;
}
aNewAddon
.
updateDate
=
aAddonState
.
mtime
;
return
XPIDatabase
.
updateAddonMetadata
(
aOldAddon
aNewAddon
aAddonState
.
path
)
;
}
updatePath
(
aInstallLocation
aOldAddon
aAddonState
)
{
logger
.
debug
(
"
Add
-
on
"
+
aOldAddon
.
id
+
"
moved
to
"
+
aAddonState
.
path
)
;
aOldAddon
.
path
=
aAddonState
.
path
;
aOldAddon
.
_sourceBundle
=
new
nsIFile
(
aAddonState
.
path
)
;
return
aOldAddon
;
}
updateCompatibility
(
aInstallLocation
aOldAddon
aAddonState
aReloadMetadata
)
{
logger
.
debug
(
"
Updating
compatibility
for
add
-
on
"
+
aOldAddon
.
id
+
"
in
"
+
aInstallLocation
.
name
)
;
let
checkSigning
=
(
aOldAddon
.
signedState
=
=
=
undefined
&
&
AddonSettings
.
ADDON_SIGNING
&
&
SIGNED_TYPES
.
has
(
aOldAddon
.
type
)
)
;
let
manifest
=
null
;
if
(
checkSigning
|
|
aReloadMetadata
)
{
try
{
let
file
=
new
nsIFile
(
aAddonState
.
path
)
;
manifest
=
XPIInstall
.
syncLoadManifestFromFile
(
file
aInstallLocation
)
;
}
catch
(
err
)
{
aOldAddon
.
brokenManifest
=
true
;
aOldAddon
.
appDisabled
=
true
;
return
aOldAddon
;
}
}
if
(
checkSigning
)
{
aOldAddon
.
signedState
=
manifest
.
signedState
;
}
if
(
aReloadMetadata
)
{
let
remove
=
[
"
syncGUID
"
"
foreignInstall
"
"
visible
"
"
active
"
"
userDisabled
"
"
applyBackgroundUpdates
"
"
sourceURI
"
"
releaseNotesURI
"
"
targetApplications
"
]
;
let
props
=
PROP_JSON_FIELDS
.
filter
(
a
=
>
!
remove
.
includes
(
a
)
)
;
copyProperties
(
manifest
props
aOldAddon
)
;
}
aOldAddon
.
appDisabled
=
!
XPIDatabase
.
isUsableAddon
(
aOldAddon
)
;
return
aOldAddon
;
}
processFileChanges
(
aManifests
aUpdateCompatibility
aOldAppVersion
aOldPlatformVersion
aSchemaChange
)
{
let
loadedManifest
=
(
aInstallLocation
aId
)
=
>
{
if
(
!
(
aInstallLocation
.
name
in
aManifests
)
)
return
null
;
if
(
!
(
aId
in
aManifests
[
aInstallLocation
.
name
]
)
)
return
null
;
return
aManifests
[
aInstallLocation
.
name
]
[
aId
]
;
}
;
let
exists
=
(
aAddon
)
=
>
{
try
{
return
aAddon
.
_sourceBundle
.
exists
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_NOT_INITIALIZED
)
return
false
;
throw
e
;
}
}
;
let
previousAddons
=
new
Map
(
)
;
for
(
let
a
of
XPIDatabase
.
getAddons
(
)
)
{
let
locationAddonMap
=
previousAddons
.
get
(
a
.
location
)
;
if
(
!
locationAddonMap
)
{
locationAddonMap
=
new
Map
(
)
;
previousAddons
.
set
(
a
.
location
locationAddonMap
)
;
}
locationAddonMap
.
set
(
a
.
id
a
)
;
}
let
addonsToCheckAgainstBlocklist
=
[
]
;
let
currentAddons
=
new
Map
(
)
;
for
(
let
installLocation
of
XPIProvider
.
installLocations
)
{
let
locationAddonMap
=
new
Map
(
)
;
currentAddons
.
set
(
installLocation
.
name
locationAddonMap
)
;
let
states
=
XPIStates
.
getLocation
(
installLocation
.
name
)
;
let
dbAddons
=
previousAddons
.
get
(
installLocation
.
name
)
;
if
(
dbAddons
)
{
for
(
let
[
id
oldAddon
]
of
dbAddons
)
{
let
xpiState
=
states
&
&
states
.
get
(
id
)
;
if
(
xpiState
)
{
XPIDatabase
.
recordAddonTelemetry
(
oldAddon
)
;
if
(
oldAddon
.
updateDate
!
=
xpiState
.
mtime
)
{
if
(
xpiState
.
mtime
<
oldAddon
.
updateDate
)
{
XPIProvider
.
setTelemetry
(
oldAddon
.
id
"
olderFile
"
{
mtime
:
xpiState
.
mtime
oldtime
:
oldAddon
.
updateDate
}
)
;
}
}
let
oldPath
=
oldAddon
.
path
|
|
descriptorToPath
(
oldAddon
.
descriptor
)
;
let
newAddon
=
loadedManifest
(
installLocation
id
)
;
if
(
newAddon
|
|
oldAddon
.
updateDate
!
=
xpiState
.
mtime
|
|
(
aUpdateCompatibility
&
&
(
installLocation
.
name
=
=
KEY_APP_GLOBAL
|
|
installLocation
.
name
=
=
KEY_APP_SYSTEM_DEFAULTS
)
)
)
{
newAddon
=
this
.
updateMetadata
(
installLocation
oldAddon
xpiState
newAddon
)
;
}
else
if
(
oldPath
!
=
xpiState
.
path
)
{
newAddon
=
this
.
updatePath
(
installLocation
oldAddon
xpiState
)
;
}
else
if
(
aUpdateCompatibility
|
|
aSchemaChange
)
{
newAddon
=
this
.
updateCompatibility
(
installLocation
oldAddon
xpiState
aSchemaChange
)
;
addonsToCheckAgainstBlocklist
.
push
(
newAddon
.
id
)
;
}
else
{
newAddon
=
oldAddon
;
}
if
(
newAddon
)
locationAddonMap
.
set
(
newAddon
.
id
newAddon
)
;
}
else
{
this
.
removeMetadata
(
oldAddon
)
;
}
}
}
let
locMigrateData
=
{
}
;
if
(
XPIDatabase
.
migrateData
&
&
installLocation
.
name
in
XPIDatabase
.
migrateData
)
locMigrateData
=
XPIDatabase
.
migrateData
[
installLocation
.
name
]
;
if
(
states
)
{
for
(
let
[
id
xpiState
]
of
states
)
{
if
(
locationAddonMap
.
has
(
id
)
)
continue
;
let
migrateData
=
id
in
locMigrateData
?
locMigrateData
[
id
]
:
null
;
let
newAddon
=
loadedManifest
(
installLocation
id
)
;
let
addon
=
this
.
addMetadata
(
installLocation
id
xpiState
newAddon
aOldAppVersion
aOldPlatformVersion
migrateData
)
;
if
(
addon
)
locationAddonMap
.
set
(
addon
.
id
addon
)
;
}
}
}
for
(
let
[
locationName
addons
]
of
previousAddons
)
{
if
(
!
currentAddons
.
has
(
locationName
)
)
{
for
(
let
oldAddon
of
addons
.
values
(
)
)
this
.
removeMetadata
(
oldAddon
)
;
}
}
let
systemAddonLocation
=
XPIProvider
.
installLocationsByName
[
KEY_APP_SYSTEM_ADDONS
]
;
let
addons
=
currentAddons
.
get
(
KEY_APP_SYSTEM_ADDONS
)
|
|
new
Map
(
)
;
let
hideLocation
;
if
(
!
systemAddonLocation
.
isValid
(
addons
)
)
{
logger
.
info
(
"
One
or
more
updated
system
add
-
ons
invalid
falling
back
to
defaults
.
"
)
;
hideLocation
=
KEY_APP_SYSTEM_ADDONS
;
}
let
previousVisible
=
this
.
getVisibleAddons
(
previousAddons
)
;
let
currentVisible
=
this
.
flattenByID
(
currentAddons
hideLocation
)
;
for
(
let
[
id
currentAddon
]
of
currentVisible
)
{
let
previousAddon
=
previousVisible
.
get
(
id
)
;
let
isActive
=
!
currentAddon
.
disabled
&
&
!
currentAddon
.
pendingUninstall
;
let
wasActive
=
previousAddon
?
previousAddon
.
active
:
currentAddon
.
active
;
if
(
!
previousAddon
)
{
let
wasStaged
=
!
!
loadedManifest
(
currentAddon
.
_installLocation
id
)
;
if
(
!
wasStaged
&
&
XPIDatabase
.
activeBundles
)
{
isActive
=
XPIDatabase
.
activeBundles
.
includes
(
currentAddon
.
path
)
;
if
(
currentAddon
.
type
=
=
"
webextension
-
theme
"
)
currentAddon
.
userDisabled
=
!
isActive
;
if
(
!
isActive
&
&
!
currentAddon
.
disabled
)
{
if
(
currentAddon
.
blocklistState
=
=
Services
.
blocklist
.
STATE_SOFTBLOCKED
)
currentAddon
.
softDisabled
=
true
;
else
currentAddon
.
userDisabled
=
true
;
}
}
else
{
if
(
currentAddon
.
foreignInstall
)
AddonManagerPrivate
.
addStartupChange
(
AddonManager
.
STARTUP_CHANGE_INSTALLED
id
)
;
if
(
currentAddon
.
bootstrap
)
{
AddonManagerPrivate
.
addStartupChange
(
AddonManager
.
STARTUP_CHANGE_INSTALLED
id
)
;
XPIProvider
.
callBootstrapMethod
(
currentAddon
currentAddon
.
_sourceBundle
"
install
"
BOOTSTRAP_REASONS
.
ADDON_INSTALL
)
;
if
(
!
isActive
)
XPIProvider
.
unloadBootstrapScope
(
currentAddon
.
id
)
;
}
}
}
else
{
if
(
previousAddon
!
=
=
currentAddon
)
{
AddonManagerPrivate
.
addStartupChange
(
AddonManager
.
STARTUP_CHANGE_CHANGED
id
)
;
let
installReason
=
Services
.
vc
.
compare
(
previousAddon
.
version
currentAddon
.
version
)
<
0
?
BOOTSTRAP_REASONS
.
ADDON_UPGRADE
:
BOOTSTRAP_REASONS
.
ADDON_DOWNGRADE
;
if
(
previousAddon
.
bootstrap
&
&
previousAddon
.
_installLocation
&
&
exists
(
previousAddon
)
&
&
currentAddon
.
_sourceBundle
.
path
!
=
previousAddon
.
_sourceBundle
.
path
)
{
XPIProvider
.
callBootstrapMethod
(
previousAddon
previousAddon
.
_sourceBundle
"
uninstall
"
installReason
{
newVersion
:
currentAddon
.
version
}
)
;
XPIProvider
.
unloadBootstrapScope
(
previousAddon
.
id
)
;
}
XPIInstall
.
flushChromeCaches
(
)
;
if
(
currentAddon
.
bootstrap
)
{
let
file
=
currentAddon
.
_sourceBundle
.
clone
(
)
;
XPIProvider
.
callBootstrapMethod
(
currentAddon
file
"
install
"
installReason
{
oldVersion
:
previousAddon
.
version
}
)
;
if
(
currentAddon
.
disabled
)
XPIProvider
.
unloadBootstrapScope
(
currentAddon
.
id
)
;
}
}
if
(
isActive
!
=
wasActive
)
{
let
change
=
isActive
?
AddonManager
.
STARTUP_CHANGE_ENABLED
:
AddonManager
.
STARTUP_CHANGE_DISABLED
;
AddonManagerPrivate
.
addStartupChange
(
change
id
)
;
}
}
XPIDatabase
.
makeAddonVisible
(
currentAddon
)
;
currentAddon
.
active
=
isActive
;
}
for
(
let
[
id
previousAddon
]
of
previousVisible
)
{
if
(
currentVisible
.
has
(
id
)
)
continue
;
if
(
previousAddon
.
bootstrap
&
&
exists
(
previousAddon
)
)
{
XPIProvider
.
callBootstrapMethod
(
previousAddon
previousAddon
.
_sourceBundle
"
uninstall
"
BOOTSTRAP_REASONS
.
ADDON_UNINSTALL
)
;
XPIProvider
.
unloadBootstrapScope
(
previousAddon
.
id
)
;
}
AddonManagerPrivate
.
addStartupChange
(
AddonManager
.
STARTUP_CHANGE_UNINSTALLED
id
)
;
XPIStates
.
removeAddon
(
previousAddon
.
location
id
)
;
XPIInstall
.
flushChromeCaches
(
)
;
}
let
locationAddonMap
=
currentAddons
.
get
(
hideLocation
)
;
if
(
locationAddonMap
)
{
for
(
let
addon
of
locationAddonMap
.
values
(
)
)
{
addon
.
visible
=
false
;
addon
.
active
=
false
;
}
}
for
(
let
[
locationName
locationAddonMap
]
of
currentAddons
)
{
for
(
let
[
id
addon
]
of
locationAddonMap
)
{
let
xpiState
=
XPIStates
.
getAddon
(
locationName
id
)
;
xpiState
.
syncWithDB
(
addon
)
;
}
}
XPIStates
.
save
(
)
;
XPIDatabase
.
migrateData
=
null
;
XPIDatabase
.
saveChanges
(
)
;
AddonManager
.
shutdown
.
addBlocker
(
"
Update
add
-
on
blocklist
state
into
add
-
on
DB
"
(
async
(
)
=
>
{
await
Promise
.
resolve
(
)
;
let
addons
=
await
AddonManager
.
getAddonsByIDs
(
addonsToCheckAgainstBlocklist
)
;
await
Promise
.
all
(
addons
.
map
(
addon
=
>
{
if
(
addon
)
{
return
addon
.
updateBlocklistState
(
{
updateDatabase
:
false
}
)
;
}
return
null
;
}
)
)
;
XPIDatabase
.
saveChanges
(
)
;
}
)
(
)
.
catch
(
Cu
.
reportError
)
)
;
return
true
;
}
}
;
