"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AddonManagerPrivate
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
DeferredTask
:
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
ServiceRequest
:
"
resource
:
/
/
gre
/
modules
/
ServiceRequest
.
jsm
"
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
Preferences
:
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
PLATFORM
"
(
)
=
>
{
let
platform
=
Services
.
appinfo
.
OS
;
switch
(
platform
)
{
case
"
Darwin
"
:
return
"
mac
"
;
case
"
Linux
"
:
return
"
linux
"
;
case
"
Android
"
:
return
"
android
"
;
case
"
WINNT
"
:
return
"
windows
"
;
}
return
platform
;
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
AddonRepository
"
]
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
const
PREF_GETADDONS_CACHE_ENABLED
=
"
extensions
.
getAddons
.
cache
.
enabled
"
;
const
PREF_GETADDONS_CACHE_TYPES
=
"
extensions
.
getAddons
.
cache
.
types
"
;
const
PREF_GETADDONS_CACHE_ID_ENABLED
=
"
extensions
.
%
ID
%
.
getAddons
.
cache
.
enabled
"
;
const
PREF_GETADDONS_BROWSEADDONS
=
"
extensions
.
getAddons
.
browseAddons
"
;
const
PREF_GETADDONS_BYIDS
=
"
extensions
.
getAddons
.
get
.
url
"
;
const
PREF_COMPAT_OVERRIDES
=
"
extensions
.
getAddons
.
compatOverides
.
url
"
;
const
PREF_GETADDONS_BROWSESEARCHRESULTS
=
"
extensions
.
getAddons
.
search
.
browseURL
"
;
const
PREF_GETADDONS_DB_SCHEMA
=
"
extensions
.
getAddons
.
databaseSchema
"
;
const
PREF_GET_LANGPACKS
=
"
extensions
.
getAddons
.
langpacks
.
url
"
;
const
PREF_METADATA_LASTUPDATE
=
"
extensions
.
getAddons
.
cache
.
lastUpdate
"
;
const
PREF_METADATA_UPDATETHRESHOLD_SEC
=
"
extensions
.
getAddons
.
cache
.
updateThreshold
"
;
const
DEFAULT_METADATA_UPDATETHRESHOLD_SEC
=
172800
;
const
DEFAULT_CACHE_TYPES
=
"
extension
theme
locale
dictionary
"
;
const
FILE_DATABASE
=
"
addons
.
json
"
;
const
DB_SCHEMA
=
5
;
const
DB_MIN_JSON_SCHEMA
=
5
;
const
DB_BATCH_TIMEOUT_MS
=
50
;
const
BLANK_DB
=
function
(
)
{
return
{
addons
:
new
Map
(
)
compatOverrides
:
new
Map
(
)
schema
:
DB_SCHEMA
}
;
}
;
const
TOOLKIT_ID
=
"
toolkit
mozilla
.
org
"
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
LOGGER_ID
=
"
addons
.
repository
"
;
var
logger
=
Log
.
repository
.
getLogger
(
LOGGER_ID
)
;
function
convertHTMLToPlainText
(
html
)
{
if
(
!
html
)
return
html
;
var
converter
=
Cc
[
"
mozilla
.
org
/
widget
/
htmlformatconverter
;
1
"
]
.
createInstance
(
Ci
.
nsIFormatConverter
)
;
var
input
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
input
.
data
=
html
.
replace
(
/
\
n
/
g
"
<
br
>
"
)
;
var
output
=
{
}
;
converter
.
convert
(
"
text
/
html
"
input
"
text
/
unicode
"
output
)
;
if
(
output
.
value
instanceof
Ci
.
nsISupportsString
)
return
output
.
value
.
data
.
replace
(
/
\
r
\
n
/
g
"
\
n
"
)
;
return
html
;
}
async
function
getAddonsToCache
(
aIds
)
{
let
types
=
Preferences
.
get
(
PREF_GETADDONS_CACHE_TYPES
)
|
|
DEFAULT_CACHE_TYPES
;
types
=
types
.
split
(
"
"
)
;
let
addons
=
await
AddonManager
.
getAddonsByIDs
(
aIds
)
;
let
enabledIds
=
[
]
;
for
(
let
[
i
addon
]
of
addons
.
entries
(
)
)
{
var
preference
=
PREF_GETADDONS_CACHE_ID_ENABLED
.
replace
(
"
%
ID
%
"
aIds
[
i
]
)
;
if
(
!
Preferences
.
get
(
preference
true
)
)
continue
;
if
(
addon
&
&
!
types
.
includes
(
addon
.
type
)
)
{
continue
;
}
if
(
addon
&
&
addon
.
isSystem
)
{
continue
;
}
enabledIds
.
push
(
aIds
[
i
]
)
;
}
return
enabledIds
;
}
function
AddonSearchResult
(
aId
)
{
this
.
id
=
aId
;
this
.
icons
=
{
}
;
this
.
_unsupportedProperties
=
{
}
;
}
AddonSearchResult
.
prototype
=
{
id
:
null
type
:
null
name
:
null
version
:
null
creator
:
null
developers
:
null
description
:
null
fullDescription
:
null
eula
:
null
get
iconURL
(
)
{
return
this
.
icons
&
&
this
.
icons
[
32
]
;
}
icons
:
null
screenshots
:
null
homepageURL
:
null
supportURL
:
null
contributionURL
:
null
averageRating
:
null
reviewCount
:
null
reviewURL
:
null
weeklyDownloads
:
null
install
:
null
sourceURI
:
null
updateDate
:
null
toJSON
(
)
{
let
json
=
{
}
;
for
(
let
property
of
Object
.
keys
(
this
)
)
{
let
value
=
this
[
property
]
;
if
(
property
.
startsWith
(
"
_
"
)
|
|
typeof
(
value
)
=
=
=
"
function
"
)
continue
;
try
{
switch
(
property
)
{
case
"
sourceURI
"
:
json
.
sourceURI
=
value
?
value
.
spec
:
"
"
;
break
;
case
"
updateDate
"
:
json
.
updateDate
=
value
?
value
.
getTime
(
)
:
"
"
;
break
;
default
:
json
[
property
]
=
value
;
}
}
catch
(
ex
)
{
logger
.
warn
(
"
Error
writing
property
value
for
"
+
property
)
;
}
}
for
(
let
property
of
Object
.
keys
(
this
.
_unsupportedProperties
)
)
{
let
value
=
this
.
_unsupportedProperties
[
property
]
;
if
(
!
property
.
startsWith
(
"
_
"
)
)
json
[
property
]
=
value
;
}
return
json
;
}
}
;
var
AddonRepository
=
{
get
homepageURL
(
)
{
let
url
=
this
.
_formatURLPref
(
PREF_GETADDONS_BROWSEADDONS
{
}
)
;
return
(
url
!
=
null
)
?
url
:
"
about
:
blank
"
;
}
getSearchURL
(
aSearchTerms
)
{
let
url
=
this
.
_formatURLPref
(
PREF_GETADDONS_BROWSESEARCHRESULTS
{
TERMS
:
aSearchTerms
}
)
;
return
(
url
!
=
null
)
?
url
:
"
about
:
blank
"
;
}
get
cacheEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_GETADDONS_CACHE_ENABLED
false
)
;
}
shutdown
(
)
{
return
AddonDatabase
.
shutdown
(
false
)
;
}
metadataAge
(
)
{
let
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
let
lastUpdate
=
Services
.
prefs
.
getIntPref
(
PREF_METADATA_LASTUPDATE
0
)
;
return
Math
.
max
(
0
now
-
lastUpdate
)
;
}
isMetadataStale
(
)
{
let
threshold
=
Services
.
prefs
.
getIntPref
(
PREF_METADATA_UPDATETHRESHOLD_SEC
DEFAULT_METADATA_UPDATETHRESHOLD_SEC
)
;
return
(
this
.
metadataAge
(
)
>
threshold
)
;
}
async
getCompatibilityOverrides
(
aId
)
{
await
AddonDatabase
.
openConnection
(
)
;
return
AddonDatabase
.
getCompatOverrides
(
aId
)
;
}
getCompatibilityOverridesSync
(
aId
)
{
return
AddonDatabase
.
getCompatOverrides
(
aId
)
;
}
async
getCachedAddonByID
(
aId
aCallback
)
{
if
(
!
aId
|
|
!
this
.
cacheEnabled
)
{
if
(
aCallback
)
{
aCallback
(
null
)
;
}
return
null
;
}
if
(
aCallback
&
&
AddonDatabase
.
_loaded
)
{
let
addon
=
AddonDatabase
.
getAddon
(
aId
)
;
aCallback
(
addon
)
;
return
addon
;
}
await
AddonDatabase
.
openConnection
(
)
;
let
addon
=
AddonDatabase
.
getAddon
(
aId
)
;
if
(
aCallback
)
{
aCallback
(
addon
)
;
}
return
addon
;
}
_clearCache
(
)
{
return
AddonDatabase
.
delete
(
)
.
then
(
(
)
=
>
AddonManagerPrivate
.
updateAddonRepositoryData
(
)
)
;
}
_fetchPaged
(
ids
pref
handler
)
{
let
startURL
=
this
.
_formatURLPref
(
pref
{
IDS
:
ids
.
join
(
"
"
)
}
)
;
let
results
=
[
]
;
const
fetchNextPage
=
(
url
)
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
request
=
new
ServiceRequest
(
{
mozAnon
:
true
}
)
;
request
.
mozBackgroundRequest
=
true
;
request
.
open
(
"
GET
"
url
true
)
;
request
.
responseType
=
"
json
"
;
request
.
addEventListener
(
"
error
"
aEvent
=
>
{
reject
(
new
Error
(
GET
{
url
}
failed
)
)
;
}
)
;
request
.
addEventListener
(
"
timeout
"
aEvent
=
>
{
reject
(
new
Error
(
GET
{
url
}
timed
out
)
)
;
}
)
;
request
.
addEventListener
(
"
load
"
aEvent
=
>
{
let
response
=
request
.
response
;
if
(
!
response
|
|
(
request
.
status
!
=
200
&
&
request
.
status
!
=
0
)
)
{
reject
(
new
Error
(
GET
{
url
}
failed
(
status
{
request
.
status
}
)
)
)
;
return
;
}
try
{
let
newResults
=
handler
(
response
.
results
)
.
filter
(
e
=
>
ids
.
includes
(
e
.
id
)
)
;
results
.
push
(
.
.
.
newResults
)
;
}
catch
(
err
)
{
reject
(
err
)
;
}
if
(
response
.
next
)
{
resolve
(
fetchNextPage
(
response
.
next
)
)
;
}
resolve
(
results
)
;
}
)
;
request
.
send
(
null
)
;
}
)
;
}
;
return
fetchNextPage
(
startURL
)
;
}
async
getAddonsByIDs
(
aIDs
)
{
return
this
.
_fetchPaged
(
aIDs
PREF_GETADDONS_BYIDS
results
=
>
results
.
map
(
entry
=
>
this
.
_parseAddon
(
entry
)
)
)
;
}
async
_getFullData
(
aIDs
)
{
let
metadataPromise
=
this
.
getAddonsByIDs
(
aIDs
false
)
;
let
overridesPromise
=
this
.
_fetchPaged
(
aIDs
PREF_COMPAT_OVERRIDES
results
=
>
results
.
map
(
entry
=
>
this
.
_parseCompatEntry
(
entry
)
)
)
;
let
addons
=
[
]
overrides
=
[
]
;
try
{
[
addons
overrides
]
=
await
Promise
.
all
(
[
metadataPromise
overridesPromise
]
)
;
}
catch
(
err
)
{
logger
.
error
(
Error
in
addon
metadata
check
:
{
err
.
message
}
)
;
}
return
{
addons
overrides
}
;
}
async
cacheAddons
(
aIds
)
{
logger
.
debug
(
"
cacheAddons
:
enabled
"
+
this
.
cacheEnabled
+
"
IDs
"
+
aIds
.
toSource
(
)
)
;
if
(
!
this
.
cacheEnabled
)
{
return
[
]
;
}
let
ids
=
await
getAddonsToCache
(
aIds
)
;
if
(
ids
.
length
=
=
0
)
{
return
[
]
;
}
let
{
addons
overrides
}
=
await
this
.
_getFullData
(
ids
)
;
await
AddonDatabase
.
update
(
addons
overrides
)
;
return
Array
.
from
(
addons
.
values
(
)
)
;
}
async
backgroundUpdateCheck
(
)
{
let
allAddons
=
await
AddonManager
.
getAllAddons
(
)
;
if
(
!
this
.
cacheEnabled
)
{
logger
.
debug
(
"
Clearing
cache
because
it
is
disabled
"
)
;
await
this
.
_clearCache
(
)
;
return
;
}
let
ids
=
allAddons
.
map
(
a
=
>
a
.
id
)
;
logger
.
debug
(
"
Repopulate
add
-
on
cache
with
"
+
ids
.
toSource
(
)
)
;
let
addonsToCache
=
await
getAddonsToCache
(
ids
)
;
if
(
addonsToCache
.
length
=
=
0
)
{
logger
.
debug
(
"
Clearing
cache
because
0
add
-
ons
were
requested
"
)
;
await
this
.
_clearCache
(
)
;
return
;
}
let
{
addons
overrides
}
=
await
this
.
_getFullData
(
addonsToCache
)
;
AddonDatabase
.
repopulate
(
addons
overrides
)
;
await
AddonManagerPrivate
.
updateAddonRepositoryData
(
)
;
}
_parseAddon
(
aEntry
)
{
let
addon
=
new
AddonSearchResult
(
aEntry
.
guid
)
;
addon
.
name
=
aEntry
.
name
;
if
(
typeof
aEntry
.
current_version
=
=
"
object
"
)
{
addon
.
version
=
String
(
aEntry
.
current_version
.
version
)
;
if
(
Array
.
isArray
(
aEntry
.
current_version
.
files
)
)
{
for
(
let
file
of
aEntry
.
current_version
.
files
)
{
if
(
file
.
platform
=
=
"
all
"
|
|
file
.
platform
=
=
PLATFORM
)
{
if
(
file
.
url
)
{
addon
.
sourceURI
=
NetUtil
.
newURI
(
file
.
url
)
;
}
break
;
}
}
}
}
addon
.
homepageURL
=
aEntry
.
homepage
;
addon
.
supportURL
=
aEntry
.
support_url
;
addon
.
description
=
convertHTMLToPlainText
(
aEntry
.
summary
)
;
addon
.
fullDescription
=
convertHTMLToPlainText
(
aEntry
.
description
)
;
addon
.
weeklyDownloads
=
aEntry
.
weekly_downloads
;
switch
(
aEntry
.
type
)
{
case
"
persona
"
:
addon
.
type
=
"
theme
"
;
break
;
case
"
language
"
:
addon
.
type
=
"
locale
"
;
break
;
default
:
addon
.
type
=
aEntry
.
type
;
break
;
}
if
(
Array
.
isArray
(
aEntry
.
authors
)
)
{
let
authors
=
aEntry
.
authors
.
map
(
author
=
>
new
AddonManagerPrivate
.
AddonAuthor
(
author
.
name
author
.
url
)
)
;
if
(
authors
.
length
>
0
)
{
addon
.
creator
=
authors
[
0
]
;
addon
.
developers
=
authors
.
slice
(
1
)
;
}
}
if
(
typeof
aEntry
.
previews
=
=
"
object
"
)
{
addon
.
screenshots
=
aEntry
.
previews
.
map
(
shot
=
>
{
let
safeSize
=
orig
=
>
Array
.
isArray
(
orig
)
&
&
orig
.
length
>
=
2
?
orig
:
[
null
null
]
;
let
imageSize
=
safeSize
(
shot
.
image_size
)
;
let
thumbSize
=
safeSize
(
shot
.
thumbnail_size
)
;
return
new
AddonManagerPrivate
.
AddonScreenshot
(
shot
.
image_url
imageSize
[
0
]
imageSize
[
1
]
shot
.
thumbnail_url
thumbSize
[
0
]
thumbSize
[
1
]
shot
.
caption
)
;
}
)
;
}
addon
.
contributionURL
=
aEntry
.
contributions_url
;
if
(
typeof
aEntry
.
ratings
=
=
"
object
"
)
{
addon
.
averageRating
=
Math
.
min
(
5
aEntry
.
ratings
.
average
)
;
addon
.
reviewCount
=
aEntry
.
ratings
.
text_count
;
}
addon
.
reviewURL
=
aEntry
.
ratings_url
;
if
(
aEntry
.
last_updated
)
{
addon
.
updateDate
=
new
Date
(
aEntry
.
last_updated
)
;
}
addon
.
icons
=
aEntry
.
icons
|
|
{
}
;
return
addon
;
}
_parseCompatEntry
(
aEntry
)
{
let
compat
=
{
id
:
aEntry
.
addon_guid
compatRanges
:
null
}
;
for
(
let
range
of
aEntry
.
version_ranges
)
{
if
(
!
range
.
addon_min_version
)
{
logger
.
debug
(
"
Compatibility
override
is
missing
min_version
.
"
)
;
continue
;
}
if
(
!
range
.
addon_max_version
)
{
logger
.
debug
(
"
Compatibility
override
is
missing
max_version
.
"
)
;
return
null
;
}
let
override
=
new
AddonManagerPrivate
.
AddonCompatibilityOverride
(
"
incompatible
"
)
;
override
.
minVersion
=
range
.
addon_min_version
;
override
.
maxVersion
=
range
.
addon_max_version
;
for
(
let
app
of
range
.
applications
)
{
if
(
app
.
guid
!
=
Services
.
appinfo
.
ID
&
&
app
.
guid
!
=
TOOLKIT_ID
)
{
continue
;
}
if
(
!
app
.
min_version
|
|
!
app
.
max_version
)
{
continue
;
}
override
.
appID
=
app
.
guid
;
override
.
appMinVersion
=
app
.
min_version
;
override
.
appMaxVersion
=
app
.
max_version
;
if
(
app
.
id
!
=
TOOLKIT_ID
)
{
break
;
}
}
if
(
!
override
.
appID
)
{
logger
.
debug
(
"
Compatibility
override
is
missing
a
valid
application
range
.
"
)
;
continue
;
}
if
(
compat
.
compatRanges
=
=
=
null
)
{
compat
.
compatRanges
=
[
]
;
}
compat
.
compatRanges
.
push
(
override
)
;
}
return
compat
;
}
_formatURLPref
(
aPreference
aSubstitutions
=
{
}
)
{
let
url
=
Services
.
prefs
.
getCharPref
(
aPreference
"
"
)
;
if
(
!
url
)
{
logger
.
warn
(
"
_formatURLPref
:
Couldn
'
t
get
pref
:
"
+
aPreference
)
;
return
null
;
}
url
=
url
.
replace
(
/
%
(
[
A
-
Z_
]
+
)
%
/
g
function
(
aMatch
aKey
)
{
return
(
aKey
in
aSubstitutions
)
?
encodeURIComponent
(
aSubstitutions
[
aKey
]
)
:
aMatch
;
}
)
;
return
Services
.
urlFormatter
.
formatURL
(
url
)
;
}
findMatchingCompatOverride
(
aAddonVersion
aCompatOverrides
aAppVersion
aPlatformVersion
)
{
for
(
let
override
of
aCompatOverrides
)
{
let
appVersion
=
null
;
if
(
override
.
appID
=
=
TOOLKIT_ID
)
appVersion
=
aPlatformVersion
|
|
Services
.
appinfo
.
platformVersion
;
else
appVersion
=
aAppVersion
|
|
Services
.
appinfo
.
version
;
if
(
Services
.
vc
.
compare
(
override
.
minVersion
aAddonVersion
)
<
=
0
&
&
Services
.
vc
.
compare
(
aAddonVersion
override
.
maxVersion
)
<
=
0
&
&
Services
.
vc
.
compare
(
override
.
appMinVersion
appVersion
)
<
=
0
&
&
Services
.
vc
.
compare
(
appVersion
override
.
appMaxVersion
)
<
=
0
)
{
return
override
;
}
}
return
null
;
}
flush
(
)
{
return
AddonDatabase
.
flush
(
)
;
}
async
getAvailableLangpacks
(
)
{
let
url
=
this
.
_formatURLPref
(
PREF_GET_LANGPACKS
)
;
let
response
=
await
fetch
(
url
)
;
if
(
!
response
.
ok
)
{
throw
new
Error
(
"
fetching
available
language
packs
failed
"
)
;
}
let
data
=
await
response
.
json
(
)
;
let
result
=
[
]
;
for
(
let
entry
of
data
.
results
)
{
if
(
!
entry
.
current_compatible_version
|
|
!
entry
.
current_compatible_version
.
files
)
{
continue
;
}
for
(
let
file
of
entry
.
current_compatible_version
.
files
)
{
if
(
file
.
platform
=
=
"
all
"
|
|
file
.
platform
=
=
Services
.
appinfo
.
OS
.
toLowerCase
(
)
)
{
result
.
push
(
{
target_locale
:
entry
.
target_locale
url
:
file
.
url
hash
:
file
.
hash
}
)
;
}
}
}
return
result
;
}
}
;
var
AddonDatabase
=
{
connectionPromise
:
null
_loaded
:
false
_saveTask
:
null
_blockerAdded
:
false
DB
:
BLANK_DB
(
)
get
jsonFile
(
)
{
return
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FILE_DATABASE
)
;
}
openConnection
(
)
{
if
(
!
this
.
connectionPromise
)
{
this
.
connectionPromise
=
(
async
(
)
=
>
{
let
inputDB
schema
;
try
{
let
data
=
await
OS
.
File
.
read
(
this
.
jsonFile
{
encoding
:
"
utf
-
8
"
}
)
;
inputDB
=
JSON
.
parse
(
data
)
;
if
(
!
inputDB
.
hasOwnProperty
(
"
addons
"
)
|
|
!
Array
.
isArray
(
inputDB
.
addons
)
)
{
throw
new
Error
(
"
No
addons
array
.
"
)
;
}
if
(
!
inputDB
.
hasOwnProperty
(
"
schema
"
)
)
{
throw
new
Error
(
"
No
schema
specified
.
"
)
;
}
schema
=
parseInt
(
inputDB
.
schema
10
)
;
if
(
!
Number
.
isInteger
(
schema
)
|
|
schema
<
DB_MIN_JSON_SCHEMA
)
{
throw
new
Error
(
"
Invalid
schema
value
.
"
)
;
}
}
catch
(
e
)
{
if
(
e
instanceof
OS
.
File
.
Error
&
&
e
.
becauseNoSuchFile
)
{
logger
.
debug
(
"
No
"
+
FILE_DATABASE
+
"
found
.
"
)
;
}
else
{
logger
.
error
(
Malformed
{
FILE_DATABASE
}
:
{
e
}
-
resetting
to
empty
)
;
}
this
.
save
(
)
;
Services
.
prefs
.
setIntPref
(
PREF_GETADDONS_DB_SCHEMA
DB_SCHEMA
)
;
this
.
_loaded
=
true
;
return
this
.
DB
;
}
Services
.
prefs
.
setIntPref
(
PREF_GETADDONS_DB_SCHEMA
DB_SCHEMA
)
;
for
(
let
addon
of
inputDB
.
addons
)
{
let
id
=
addon
.
id
;
let
entry
=
this
.
_parseAddon
(
addon
)
;
this
.
DB
.
addons
.
set
(
id
entry
)
;
if
(
entry
.
compatibilityOverrides
)
{
this
.
DB
.
compatOverrides
.
set
(
id
entry
.
compatibilityOverrides
)
;
}
}
if
(
inputDB
.
compatOverrides
)
{
for
(
let
entry
of
inputDB
.
compatOverrides
)
{
this
.
DB
.
compatOverrides
.
set
(
entry
.
id
entry
.
compatRanges
)
;
}
}
this
.
_loaded
=
true
;
return
this
.
DB
;
}
)
(
)
;
}
return
this
.
connectionPromise
;
}
shutdown
(
aSkipFlush
)
{
if
(
!
this
.
connectionPromise
)
{
return
Promise
.
resolve
(
)
;
}
this
.
connectionPromise
=
null
;
this
.
_loaded
=
false
;
if
(
aSkipFlush
)
{
return
Promise
.
resolve
(
)
;
}
return
this
.
flush
(
)
;
}
delete
(
aCallback
)
{
this
.
DB
=
BLANK_DB
(
)
;
if
(
this
.
_saveTask
)
{
this
.
_saveTask
.
disarm
(
)
;
this
.
_saveTask
=
null
;
}
this
.
_deleting
=
this
.
shutdown
(
true
)
.
then
(
(
)
=
>
OS
.
File
.
remove
(
this
.
jsonFile
{
}
)
)
.
catch
(
error
=
>
logger
.
error
(
"
Unable
to
delete
Addon
Repository
file
"
+
this
.
jsonFile
error
)
)
.
then
(
(
)
=
>
this
.
_deleting
=
null
)
.
then
(
aCallback
)
;
return
this
.
_deleting
;
}
async
_saveNow
(
)
{
let
json
=
{
schema
:
this
.
DB
.
schema
addons
:
Array
.
from
(
this
.
DB
.
addons
.
values
(
)
)
compatOverrides
:
[
]
}
;
for
(
let
[
id
overrides
]
of
this
.
DB
.
compatOverrides
.
entries
(
)
)
{
json
.
compatOverrides
.
push
(
{
id
compatRanges
:
overrides
}
)
;
}
await
OS
.
File
.
writeAtomic
(
this
.
jsonFile
JSON
.
stringify
(
json
)
{
tmpPath
:
{
this
.
jsonFile
}
.
tmp
}
)
;
}
save
(
)
{
if
(
!
this
.
_saveTask
)
{
this
.
_saveTask
=
new
DeferredTask
(
(
)
=
>
this
.
_saveNow
(
)
DB_BATCH_TIMEOUT_MS
)
;
if
(
!
this
.
_blockerAdded
)
{
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
Flush
AddonRepository
"
(
)
=
>
this
.
flush
(
)
)
;
this
.
_blockerAdded
=
true
;
}
}
this
.
_saveTask
.
arm
(
)
;
}
flush
(
)
{
if
(
this
.
_deleting
)
{
return
this
.
_deleting
;
}
if
(
this
.
_saveTask
)
{
let
promise
=
this
.
_saveTask
.
finalize
(
)
;
this
.
_saveTask
=
null
;
return
promise
;
}
return
Promise
.
resolve
(
)
;
}
getAddon
(
aId
)
{
return
this
.
DB
.
addons
.
get
(
aId
)
;
}
getCompatOverrides
(
aId
)
{
return
this
.
DB
.
compatOverrides
.
get
(
aId
)
;
}
repopulate
(
aAddons
aCompatOverrides
)
{
this
.
DB
=
BLANK_DB
(
)
;
this
.
_update
(
aAddons
aCompatOverrides
)
;
let
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
logger
.
debug
(
"
Cache
repopulated
setting
"
+
PREF_METADATA_LASTUPDATE
+
"
to
"
+
now
)
;
Services
.
prefs
.
setIntPref
(
PREF_METADATA_LASTUPDATE
now
)
;
}
async
update
(
aAddons
aCompatOverrides
)
{
await
this
.
openConnection
(
)
;
this
.
_update
(
aAddons
aCompatOverrides
)
;
this
.
save
(
)
;
}
_update
(
aAddons
aCompatOverrides
)
{
for
(
let
addon
of
aAddons
)
{
this
.
DB
.
addons
.
set
(
addon
.
id
this
.
_parseAddon
(
addon
)
)
;
}
for
(
let
entry
of
aCompatOverrides
)
{
this
.
DB
.
compatOverrides
.
set
(
entry
.
id
entry
.
compatRanges
)
;
}
this
.
save
(
)
;
}
_parseAddon
(
aObj
)
{
if
(
aObj
instanceof
AddonSearchResult
)
return
aObj
;
let
id
=
aObj
.
id
;
if
(
!
aObj
.
id
)
return
null
;
let
addon
=
new
AddonSearchResult
(
id
)
;
for
(
let
expectedProperty
of
Object
.
keys
(
AddonSearchResult
.
prototype
)
)
{
if
(
!
(
expectedProperty
in
aObj
)
|
|
typeof
(
aObj
[
expectedProperty
]
)
=
=
=
"
function
"
)
continue
;
let
value
=
aObj
[
expectedProperty
]
;
try
{
switch
(
expectedProperty
)
{
case
"
sourceURI
"
:
addon
.
sourceURI
=
value
?
NetUtil
.
newURI
(
value
)
:
null
;
break
;
case
"
creator
"
:
addon
.
creator
=
value
?
this
.
_makeDeveloper
(
value
)
:
null
;
break
;
case
"
updateDate
"
:
addon
.
updateDate
=
value
?
new
Date
(
value
)
:
null
;
break
;
case
"
developers
"
:
if
(
!
addon
.
developers
)
addon
.
developers
=
[
]
;
for
(
let
developer
of
value
)
{
addon
.
developers
.
push
(
this
.
_makeDeveloper
(
developer
)
)
;
}
break
;
case
"
screenshots
"
:
if
(
!
addon
.
screenshots
)
addon
.
screenshots
=
[
]
;
for
(
let
screenshot
of
value
)
{
addon
.
screenshots
.
push
(
this
.
_makeScreenshot
(
screenshot
)
)
;
}
break
;
case
"
icons
"
:
if
(
!
addon
.
icons
)
addon
.
icons
=
{
}
;
for
(
let
size
of
Object
.
keys
(
aObj
.
icons
)
)
{
addon
.
icons
[
size
]
=
aObj
.
icons
[
size
]
;
}
break
;
case
"
iconURL
"
:
break
;
default
:
addon
[
expectedProperty
]
=
value
;
}
}
catch
(
ex
)
{
logger
.
warn
(
"
Error
in
parsing
property
value
for
"
+
expectedProperty
+
"
|
"
+
ex
)
;
}
delete
aObj
[
expectedProperty
]
;
}
for
(
let
remainingProperty
of
Object
.
keys
(
aObj
)
)
{
switch
(
typeof
(
aObj
[
remainingProperty
]
)
)
{
case
"
boolean
"
:
case
"
number
"
:
case
"
string
"
:
case
"
object
"
:
break
;
default
:
continue
;
}
if
(
!
remainingProperty
.
startsWith
(
"
_
"
)
)
addon
.
_unsupportedProperties
[
remainingProperty
]
=
aObj
[
remainingProperty
]
;
}
return
addon
;
}
_makeDeveloper
(
aObj
)
{
let
name
=
aObj
.
name
;
let
url
=
aObj
.
url
;
return
new
AddonManagerPrivate
.
AddonAuthor
(
name
url
)
;
}
_makeScreenshot
(
aObj
)
{
let
url
=
aObj
.
url
;
let
width
=
aObj
.
width
;
let
height
=
aObj
.
height
;
let
thumbnailURL
=
aObj
.
thumbnailURL
;
let
thumbnailWidth
=
aObj
.
thumbnailWidth
;
let
thumbnailHeight
=
aObj
.
thumbnailHeight
;
let
caption
=
aObj
.
caption
;
return
new
AddonManagerPrivate
.
AddonScreenshot
(
url
width
height
thumbnailURL
thumbnailWidth
thumbnailHeight
caption
)
;
}
}
;
