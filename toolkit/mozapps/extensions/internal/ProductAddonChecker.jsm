"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
this
.
EXPORTED_SYMBOLS
=
[
"
ProductAddonChecker
"
]
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
CertUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
let
logger
=
Log
.
repository
.
getLogger
(
"
addons
.
productaddons
"
)
;
const
TIMEOUT_DELAY_MS
=
20000
;
const
DOWNLOAD_CHUNK_BYTES_SIZE
=
300000
;
const
DOWNLOAD_INTERVAL
=
0
;
const
HASH_CHUNK_SIZE
=
8192
;
function
getRequestStatus
(
request
)
{
let
status
=
null
;
try
{
status
=
request
.
status
;
}
catch
(
e
)
{
}
if
(
status
!
=
null
)
{
return
status
;
}
return
request
.
channel
.
QueryInterface
(
Ci
.
nsIRequest
)
.
status
;
}
function
downloadXML
(
url
allowNonBuiltIn
=
false
allowedCerts
=
null
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
request
=
Cc
[
"
mozilla
.
org
/
xmlextras
/
xmlhttprequest
;
1
"
]
.
createInstance
(
Ci
.
nsISupports
)
;
if
(
request
.
wrappedJSObject
)
{
request
=
request
.
wrappedJSObject
;
}
request
.
open
(
"
GET
"
url
true
)
;
request
.
channel
.
notificationCallbacks
=
new
BadCertHandler
(
allowNonBuiltIn
)
;
request
.
channel
.
loadFlags
|
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
;
request
.
channel
.
loadFlags
|
=
Ci
.
nsIRequest
.
INHIBIT_CACHING
;
request
.
timeout
=
TIMEOUT_DELAY_MS
;
request
.
overrideMimeType
(
"
text
/
xml
"
)
;
request
.
setRequestHeader
(
"
Cache
-
Control
"
"
no
-
cache
"
)
;
request
.
setRequestHeader
(
"
Pragma
"
"
no
-
cache
"
)
;
let
fail
=
(
event
)
=
>
{
let
request
=
event
.
target
;
let
status
=
getRequestStatus
(
request
)
;
let
message
=
"
Failed
downloading
XML
status
:
"
+
status
+
"
reason
:
"
+
event
.
type
;
logger
.
warn
(
message
)
;
let
ex
=
new
Error
(
message
)
;
ex
.
status
=
status
;
reject
(
ex
)
;
}
;
let
success
=
(
event
)
=
>
{
logger
.
info
(
"
Completed
downloading
document
"
)
;
let
request
=
event
.
target
;
try
{
checkCert
(
request
.
channel
allowNonBuiltIn
allowedCerts
)
;
}
catch
(
ex
)
{
logger
.
error
(
"
Request
failed
certificate
checks
:
"
+
ex
)
;
ex
.
status
=
getRequestStatus
(
request
)
;
reject
(
ex
)
;
return
;
}
resolve
(
request
.
responseXML
)
;
}
;
request
.
addEventListener
(
"
error
"
fail
false
)
;
request
.
addEventListener
(
"
abort
"
fail
false
)
;
request
.
addEventListener
(
"
timeout
"
fail
false
)
;
request
.
addEventListener
(
"
load
"
success
false
)
;
logger
.
info
(
"
sending
request
to
:
"
+
url
)
;
request
.
send
(
null
)
;
}
)
;
}
function
parseXML
(
document
)
{
if
(
document
.
documentElement
.
localName
!
=
"
updates
"
)
{
throw
new
Error
(
"
got
node
name
:
"
+
document
.
documentElement
.
localName
+
"
expected
:
updates
"
)
;
}
let
addons
=
document
.
querySelector
(
"
updates
:
root
>
addons
"
)
;
if
(
!
addons
)
{
return
null
;
}
let
results
=
[
]
;
let
addonList
=
document
.
querySelectorAll
(
"
updates
:
root
>
addons
>
addon
"
)
;
for
(
let
addonElement
of
addonList
)
{
let
addon
=
{
}
;
for
(
let
name
of
[
"
id
"
"
URL
"
"
hashFunction
"
"
hashValue
"
"
version
"
"
size
"
]
)
{
if
(
addonElement
.
hasAttribute
(
name
)
)
{
addon
[
name
]
=
addonElement
.
getAttribute
(
name
)
;
}
}
addon
.
size
=
Number
(
addon
.
size
)
|
|
undefined
;
results
.
push
(
addon
)
;
}
return
results
;
}
function
downloadFile
(
url
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
observer
=
{
onStartRequest
:
function
(
)
{
}
onStopRequest
:
function
(
request
context
status
)
{
if
(
!
Components
.
isSuccessCode
(
status
)
)
{
logger
.
warn
(
"
File
download
failed
:
0x
"
+
status
.
toString
(
16
)
)
;
tmpFile
.
remove
(
true
)
;
reject
(
Components
.
Exception
(
"
File
download
failed
"
status
)
)
;
return
;
}
resolve
(
tmpFile
.
path
)
;
}
}
;
let
uri
=
NetUtil
.
newURI
(
url
)
;
let
request
=
Cc
[
"
mozilla
.
org
/
network
/
incremental
-
download
;
1
"
]
.
createInstance
(
Ci
.
nsIIncrementalDownload
)
;
let
tmpFile
=
FileUtils
.
getFile
(
"
TmpD
"
[
"
tmpaddon
"
]
)
;
tmpFile
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
FileUtils
.
PERMS_FILE
)
;
logger
.
info
(
"
Downloading
from
"
+
uri
.
spec
+
"
to
"
+
tmpFile
.
path
)
;
request
.
init
(
uri
tmpFile
DOWNLOAD_CHUNK_BYTES_SIZE
DOWNLOAD_INTERVAL
)
;
request
.
start
(
observer
null
)
;
}
)
;
}
function
binaryToHex
(
input
)
{
let
result
=
"
"
;
for
(
let
i
=
0
;
i
<
input
.
length
;
+
+
i
)
{
let
hex
=
input
.
charCodeAt
(
i
)
.
toString
(
16
)
;
if
(
hex
.
length
=
=
1
)
{
hex
=
"
0
"
+
hex
;
}
result
+
=
hex
;
}
return
result
;
}
let
computeHash
=
Task
.
async
(
function
*
(
hashFunction
path
)
{
let
file
=
yield
OS
.
File
.
open
(
path
{
existing
:
true
read
:
true
}
)
;
try
{
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
initWithString
(
hashFunction
)
;
let
bytes
;
do
{
bytes
=
yield
file
.
read
(
HASH_CHUNK_SIZE
)
;
hasher
.
update
(
bytes
bytes
.
length
)
;
}
while
(
bytes
.
length
=
=
HASH_CHUNK_SIZE
)
;
return
binaryToHex
(
hasher
.
finish
(
false
)
)
;
}
finally
{
yield
file
.
close
(
)
;
}
}
)
;
let
verifyFile
=
Task
.
async
(
function
*
(
properties
path
)
{
if
(
properties
.
size
!
=
=
undefined
)
{
let
stat
=
yield
OS
.
File
.
stat
(
path
)
;
if
(
stat
.
size
!
=
properties
.
size
)
{
throw
new
Error
(
"
Downloaded
file
was
"
+
stat
.
size
+
"
bytes
but
expected
"
+
properties
.
size
+
"
bytes
.
"
)
;
}
}
if
(
properties
.
hashFunction
!
=
=
undefined
)
{
let
expectedDigest
=
properties
.
hashValue
.
toLowerCase
(
)
;
let
digest
=
yield
computeHash
(
properties
.
hashFunction
path
)
;
if
(
digest
!
=
expectedDigest
)
{
throw
new
Error
(
"
Hash
was
"
+
digest
+
"
but
expected
"
+
expectedDigest
+
"
.
"
)
;
}
}
}
)
;
const
ProductAddonChecker
=
{
getProductAddonList
:
function
(
url
allowNonBuiltIn
=
false
allowedCerts
=
null
)
{
return
downloadXML
(
url
allowNonBuiltIn
allowedCerts
)
.
then
(
parseXML
)
;
}
downloadAddon
:
Task
.
async
(
function
*
(
addon
)
{
let
path
=
yield
downloadFile
(
addon
.
URL
)
;
try
{
yield
verifyFile
(
addon
path
)
;
return
path
;
}
catch
(
e
)
{
yield
OS
.
File
.
remove
(
path
)
;
throw
e
;
}
}
)
}
