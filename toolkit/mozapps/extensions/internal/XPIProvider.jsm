"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
XPIProvider
"
"
XPIInternal
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonRepository
:
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonRepository
.
jsm
"
AddonSettings
:
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonSettings
.
jsm
"
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
Extension
:
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
Langpack
:
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
LightweightThemeManager
:
"
resource
:
/
/
gre
/
modules
/
LightweightThemeManager
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
PermissionsUtils
:
"
resource
:
/
/
gre
/
modules
/
PermissionsUtils
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
ConsoleAPI
:
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
JSONFile
:
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
LegacyExtensionsUtils
:
"
resource
:
/
/
gre
/
modules
/
LegacyExtensionsUtils
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
XPIDatabase
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIDatabase
.
jsm
"
XPIDatabaseReconcile
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIDatabase
.
jsm
"
XPIInstall
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIInstall
.
jsm
"
verifyBundleSignedState
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIInstall
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
aomStartup
"
"
mozilla
.
org
/
addons
/
addon
-
manager
-
startup
;
1
"
"
amIAddonManagerStartup
"
)
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
const
nsIFile
=
Components
.
Constructor
(
"
mozilla
.
org
/
file
/
local
;
1
"
"
nsIFile
"
"
initWithPath
"
)
;
const
PREF_DB_SCHEMA
=
"
extensions
.
databaseSchema
"
;
const
PREF_XPI_STATE
=
"
extensions
.
xpiState
"
;
const
PREF_BOOTSTRAP_ADDONS
=
"
extensions
.
bootstrappedAddons
"
;
const
PREF_PENDING_OPERATIONS
=
"
extensions
.
pendingOperations
"
;
const
PREF_EM_ENABLED_SCOPES
=
"
extensions
.
enabledScopes
"
;
const
PREF_EM_STARTUP_SCAN_SCOPES
=
"
extensions
.
startupScanScopes
"
;
const
PREF_EM_SHOW_MISMATCH_UI
=
"
extensions
.
showMismatchUI
"
;
const
PREF_XPI_SIGNATURES_REQUIRED
=
"
xpinstall
.
signatures
.
required
"
;
const
PREF_LANGPACK_SIGNATURES
=
"
extensions
.
langpacks
.
signatures
.
required
"
;
const
PREF_XPI_PERMISSIONS_BRANCH
=
"
xpinstall
.
"
;
const
PREF_INSTALL_DISTRO_ADDONS
=
"
extensions
.
installDistroAddons
"
;
const
PREF_BRANCH_INSTALLED_ADDON
=
"
extensions
.
installedDistroAddon
.
"
;
const
PREF_SYSTEM_ADDON_SET
=
"
extensions
.
systemAddonSet
"
;
const
PREF_ALLOW_LEGACY
=
"
extensions
.
legacy
.
enabled
"
;
const
PREF_EM_MIN_COMPAT_APP_VERSION
=
"
extensions
.
minCompatibleAppVersion
"
;
const
PREF_EM_MIN_COMPAT_PLATFORM_VERSION
=
"
extensions
.
minCompatiblePlatformVersion
"
;
const
PREF_EM_LAST_APP_BUILD_ID
=
"
extensions
.
lastAppBuildId
"
;
const
BUILT_IN_ADDONS_URI
=
"
chrome
:
/
/
browser
/
content
/
built_in_addons
.
json
"
;
const
OBSOLETE_PREFERENCES
=
[
"
extensions
.
bootstrappedAddons
"
"
extensions
.
enabledAddons
"
"
extensions
.
xpiState
"
"
extensions
.
installCache
"
]
;
const
URI_EXTENSION_STRINGS
=
"
chrome
:
/
/
mozapps
/
locale
/
extensions
/
extensions
.
properties
"
;
const
DIR_EXTENSIONS
=
"
extensions
"
;
const
DIR_SYSTEM_ADDONS
=
"
features
"
;
const
DIR_STAGE
=
"
staged
"
;
const
DIR_TRASH
=
"
trash
"
;
const
FILE_XPI_STATES
=
"
addonStartup
.
json
.
lz4
"
;
const
FILE_DATABASE
=
"
extensions
.
json
"
;
const
FILE_RDF_MANIFEST
=
"
install
.
rdf
"
;
const
FILE_WEB_MANIFEST
=
"
manifest
.
json
"
;
const
FILE_XPI_ADDONS_LIST
=
"
extensions
.
ini
"
;
const
KEY_PROFILEDIR
=
"
ProfD
"
;
const
KEY_ADDON_APP_DIR
=
"
XREAddonAppDir
"
;
const
KEY_APP_DISTRIBUTION
=
"
XREAppDist
"
;
const
KEY_APP_FEATURES
=
"
XREAppFeat
"
;
const
KEY_APP_PROFILE
=
"
app
-
profile
"
;
const
KEY_APP_SYSTEM_ADDONS
=
"
app
-
system
-
addons
"
;
const
KEY_APP_SYSTEM_DEFAULTS
=
"
app
-
system
-
defaults
"
;
const
KEY_APP_GLOBAL
=
"
app
-
global
"
;
const
KEY_APP_SYSTEM_LOCAL
=
"
app
-
system
-
local
"
;
const
KEY_APP_SYSTEM_SHARE
=
"
app
-
system
-
share
"
;
const
KEY_APP_SYSTEM_USER
=
"
app
-
system
-
user
"
;
const
KEY_APP_TEMPORARY
=
"
app
-
temporary
"
;
const
DEFAULT_THEME_ID
=
"
default
-
theme
mozilla
.
org
"
;
const
TEMPORARY_ADDON_SUFFIX
=
"
temporary
-
addon
"
;
const
STARTUP_MTIME_SCOPES
=
[
KEY_APP_GLOBAL
KEY_APP_SYSTEM_LOCAL
KEY_APP_SYSTEM_SHARE
KEY_APP_SYSTEM_USER
]
;
const
NOTIFICATION_FLUSH_PERMISSIONS
=
"
flush
-
pending
-
permissions
"
;
const
XPI_PERMISSION
=
"
install
"
;
const
TOOLKIT_ID
=
"
toolkit
mozilla
.
org
"
;
const
XPI_SIGNATURE_CHECK_PERIOD
=
24
*
60
*
60
;
XPCOMUtils
.
defineConstant
(
this
"
DB_SCHEMA
"
25
)
;
const
NOTIFICATION_TOOLBOX_CONNECTION_CHANGE
=
"
toolbox
-
connection
-
change
"
;
function
encoded
(
strings
.
.
.
values
)
{
let
result
=
[
]
;
for
(
let
[
i
string
]
of
strings
.
entries
(
)
)
{
result
.
push
(
string
)
;
if
(
i
<
values
.
length
)
result
.
push
(
encodeURIComponent
(
values
[
i
]
)
)
;
}
return
result
.
join
(
"
"
)
;
}
const
BOOTSTRAP_REASONS
=
{
APP_STARTUP
:
1
APP_SHUTDOWN
:
2
ADDON_ENABLE
:
3
ADDON_DISABLE
:
4
ADDON_INSTALL
:
5
ADDON_UNINSTALL
:
6
ADDON_UPGRADE
:
7
ADDON_DOWNGRADE
:
8
}
;
const
TYPE_ALIASES
=
{
"
webextension
"
:
"
extension
"
"
webextension
-
theme
"
:
"
theme
"
"
webextension
-
langpack
"
:
"
locale
"
}
;
const
CHROME_TYPES
=
new
Set
(
[
"
extension
"
]
)
;
const
SIGNED_TYPES
=
new
Set
(
[
"
extension
"
"
webextension
"
"
webextension
-
langpack
"
"
webextension
-
theme
"
]
)
;
const
ALL_EXTERNAL_TYPES
=
new
Set
(
[
"
dictionary
"
"
extension
"
"
locale
"
"
theme
"
]
)
;
const
XPI_STARTING
=
"
XPIStarting
"
;
const
XPI_BEFORE_UI_STARTUP
=
"
BeforeFinalUIStartup
"
;
const
XPI_AFTER_UI_STARTUP
=
"
AfterFinalUIStartup
"
;
var
gGlobalScope
=
this
;
var
gIDTest
=
/
^
(
\
{
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
\
}
|
[
a
-
z0
-
9
-
\
.
_
]
*
\
[
a
-
z0
-
9
-
\
.
_
]
+
)
/
i
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
LOGGER_ID
=
"
addons
.
xpi
"
;
var
logger
=
Log
.
repository
.
getLogger
(
LOGGER_ID
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gStartupScanScopes
"
(
)
=
>
{
let
appBuildID
=
Services
.
appinfo
.
appBuildID
;
let
oldAppBuildID
=
Services
.
prefs
.
getCharPref
(
PREF_EM_LAST_APP_BUILD_ID
"
"
)
;
Services
.
prefs
.
setCharPref
(
PREF_EM_LAST_APP_BUILD_ID
appBuildID
)
;
if
(
appBuildID
!
=
=
oldAppBuildID
)
{
return
AddonManager
.
SCOPE_ALL
;
}
return
Services
.
prefs
.
getIntPref
(
PREF_EM_STARTUP_SCAN_SCOPES
0
)
;
}
)
;
function
awaitPromise
(
promise
)
{
let
success
=
undefined
;
let
result
=
null
;
promise
.
then
(
val
=
>
{
success
=
true
;
result
=
val
;
}
val
=
>
{
success
=
false
;
result
=
val
;
}
)
;
Services
.
tm
.
spinEventLoopUntil
(
(
)
=
>
success
!
=
=
undefined
)
;
if
(
!
success
)
throw
result
;
return
result
;
}
function
getFile
(
path
base
=
null
)
{
try
{
return
new
nsIFile
(
path
)
;
}
catch
(
e
)
{
}
let
file
=
base
.
clone
(
)
;
file
.
appendRelativePath
(
path
)
;
return
file
;
}
function
tryGetMtime
(
file
)
{
try
{
return
file
.
clone
(
)
.
lastModifiedTime
;
}
catch
(
e
)
{
return
0
;
}
}
function
getRelativePath
(
file
dir
)
{
if
(
dir
&
&
dir
.
contains
(
file
)
)
{
let
path
=
file
.
getRelativePath
(
dir
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
path
=
path
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
return
path
;
}
return
file
.
path
;
}
function
descriptorToPath
(
descriptor
dir
)
{
try
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
persistentDescriptor
=
descriptor
;
return
getRelativePath
(
file
dir
)
;
}
catch
(
e
)
{
return
null
;
}
}
function
isWebExtension
(
type
)
{
return
type
=
=
"
webextension
"
|
|
type
=
=
"
webextension
-
theme
"
;
}
var
gThemeAliases
=
null
;
function
isTheme
(
type
)
{
if
(
!
gThemeAliases
)
gThemeAliases
=
getAllAliasesForTypes
(
[
"
theme
"
]
)
;
return
gThemeAliases
.
includes
(
type
)
;
}
function
canRunInSafeMode
(
aAddon
)
{
let
location
=
aAddon
.
_installLocation
|
|
null
;
if
(
!
location
)
{
return
false
;
}
if
(
location
.
name
=
=
KEY_APP_TEMPORARY
)
return
true
;
return
location
.
isSystem
;
}
function
getExternalType
(
aType
)
{
if
(
aType
in
TYPE_ALIASES
)
return
TYPE_ALIASES
[
aType
]
;
return
aType
;
}
function
getManifestFileForDir
(
aDir
)
{
let
file
=
getFile
(
FILE_RDF_MANIFEST
aDir
)
;
if
(
file
.
exists
(
)
&
&
file
.
isFile
(
)
)
return
file
;
file
.
leafName
=
FILE_WEB_MANIFEST
;
if
(
file
.
exists
(
)
&
&
file
.
isFile
(
)
)
return
file
;
return
null
;
}
function
getAllAliasesForTypes
(
aTypes
)
{
if
(
!
aTypes
)
return
null
;
let
typeset
=
new
Set
(
aTypes
)
;
for
(
let
alias
of
Object
.
keys
(
TYPE_ALIASES
)
)
{
typeset
.
delete
(
alias
)
;
if
(
typeset
.
has
(
TYPE_ALIASES
[
alias
]
)
)
typeset
.
add
(
alias
)
;
}
return
[
.
.
.
typeset
]
;
}
function
getURIForResourceInFile
(
aFile
aPath
)
{
if
(
aFile
.
exists
(
)
&
&
aFile
.
isDirectory
(
)
)
{
let
resource
=
aFile
.
clone
(
)
;
if
(
aPath
)
aPath
.
split
(
"
/
"
)
.
forEach
(
part
=
>
resource
.
append
(
part
)
)
;
return
Services
.
io
.
newFileURI
(
resource
)
;
}
return
buildJarURI
(
aFile
aPath
)
;
}
function
buildJarURI
(
aJarfile
aPath
)
{
let
uri
=
Services
.
io
.
newFileURI
(
aJarfile
)
;
uri
=
"
jar
:
"
+
uri
.
spec
+
"
!
/
"
+
aPath
;
return
Services
.
io
.
newURI
(
uri
)
;
}
function
getDirectoryEntries
(
aDir
aSortEntries
)
{
let
dirEnum
;
try
{
dirEnum
=
aDir
.
directoryEntries
.
QueryInterface
(
Ci
.
nsIDirectoryEnumerator
)
;
let
entries
=
[
]
;
while
(
dirEnum
.
hasMoreElements
(
)
)
entries
.
push
(
dirEnum
.
nextFile
)
;
if
(
aSortEntries
)
{
entries
.
sort
(
function
(
a
b
)
{
return
a
.
path
>
b
.
path
?
-
1
:
1
;
}
)
;
}
return
entries
;
}
catch
(
e
)
{
if
(
aDir
.
exists
(
)
)
{
logger
.
warn
(
"
Can
'
t
iterate
directory
"
+
aDir
.
path
e
)
;
}
return
[
]
;
}
finally
{
if
(
dirEnum
)
{
dirEnum
.
close
(
)
;
}
}
}
const
JSON_FIELDS
=
Object
.
freeze
(
[
"
bootstrapped
"
"
changed
"
"
dependencies
"
"
enabled
"
"
file
"
"
hasEmbeddedWebExtension
"
"
lastModifiedTime
"
"
path
"
"
runInSafeMode
"
"
startupData
"
"
type
"
"
version
"
]
)
;
const
BOOTSTRAPPED_FIELDS
=
Object
.
freeze
(
[
"
dependencies
"
"
hasEmbeddedWebExtension
"
"
runInSafeMode
"
"
type
"
"
version
"
]
)
;
class
XPIState
{
constructor
(
location
id
saved
=
{
}
)
{
this
.
location
=
location
;
this
.
id
=
id
;
this
.
type
=
"
extension
"
;
this
.
bootstrapped
=
false
;
for
(
let
prop
of
JSON_FIELDS
)
{
if
(
prop
in
saved
)
{
this
[
prop
]
=
saved
[
prop
]
;
}
}
if
(
saved
.
currentModifiedTime
&
&
saved
.
currentModifiedTime
!
=
this
.
lastModifiedTime
)
{
this
.
lastModifiedTime
=
saved
.
currentModifiedTime
;
this
.
changed
=
true
;
}
}
static
migrate
(
location
id
saved
bootstrapped
)
{
let
data
=
{
enabled
:
saved
.
e
path
:
descriptorToPath
(
saved
.
d
location
.
dir
)
lastModifiedTime
:
saved
.
mt
|
|
saved
.
st
version
:
saved
.
v
}
;
if
(
bootstrapped
)
{
data
.
bootstrapped
=
true
;
data
.
enabled
=
true
;
data
.
path
=
descriptorToPath
(
bootstrapped
.
descriptor
location
.
dir
)
;
for
(
let
field
of
BOOTSTRAPPED_FIELDS
)
{
if
(
field
in
bootstrapped
)
{
data
[
field
]
=
bootstrapped
[
field
]
;
}
}
}
return
new
XPIState
(
location
id
data
)
;
}
get
mtime
(
)
{
return
this
.
lastModifiedTime
;
}
get
active
(
)
{
return
this
.
enabled
;
}
get
path
(
)
{
return
this
.
file
&
&
this
.
file
.
path
;
}
set
path
(
path
)
{
this
.
file
=
getFile
(
path
this
.
location
.
dir
)
;
}
get
relativePath
(
)
{
if
(
this
.
location
.
dir
&
&
this
.
location
.
dir
.
contains
(
this
.
file
)
)
{
let
path
=
this
.
file
.
getRelativePath
(
this
.
location
.
dir
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
path
=
path
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
return
path
;
}
return
this
.
path
;
}
toJSON
(
)
{
let
json
=
{
enabled
:
this
.
enabled
lastModifiedTime
:
this
.
lastModifiedTime
path
:
this
.
relativePath
version
:
this
.
version
}
;
if
(
this
.
type
!
=
"
extension
"
)
{
json
.
type
=
this
.
type
;
}
if
(
this
.
bootstrapped
)
{
json
.
bootstrapped
=
true
;
json
.
dependencies
=
this
.
dependencies
;
json
.
runInSafeMode
=
this
.
runInSafeMode
;
json
.
hasEmbeddedWebExtension
=
this
.
hasEmbeddedWebExtension
;
}
if
(
this
.
startupData
)
{
json
.
startupData
=
this
.
startupData
;
}
return
json
;
}
getModTime
(
aFile
aId
)
{
let
mtime
=
(
tryGetMtime
(
getManifestFileForDir
(
aFile
)
)
|
|
tryGetMtime
(
aFile
)
)
;
if
(
!
mtime
)
{
logger
.
warn
(
"
Can
'
t
get
modified
time
of
{
file
}
"
{
file
:
aFile
.
path
}
)
;
}
this
.
changed
=
mtime
!
=
this
.
lastModifiedTime
;
this
.
lastModifiedTime
=
mtime
;
return
this
.
changed
;
}
syncWithDB
(
aDBAddon
aUpdated
=
false
)
{
logger
.
debug
(
"
Updating
XPIState
for
"
+
JSON
.
stringify
(
aDBAddon
)
)
;
let
mustGetMod
=
(
aDBAddon
.
visible
&
&
!
aDBAddon
.
disabled
&
&
!
this
.
enabled
)
;
this
.
enabled
=
aDBAddon
.
visible
&
&
!
aDBAddon
.
disabled
;
this
.
version
=
aDBAddon
.
version
;
this
.
type
=
aDBAddon
.
type
;
if
(
aDBAddon
.
startupData
)
{
this
.
startupData
=
aDBAddon
.
startupData
;
}
this
.
bootstrapped
=
!
!
aDBAddon
.
bootstrap
;
if
(
this
.
bootstrapped
)
{
this
.
hasEmbeddedWebExtension
=
aDBAddon
.
hasEmbeddedWebExtension
;
this
.
dependencies
=
aDBAddon
.
dependencies
;
this
.
runInSafeMode
=
canRunInSafeMode
(
aDBAddon
)
;
}
if
(
aUpdated
|
|
mustGetMod
)
{
this
.
getModTime
(
this
.
file
aDBAddon
.
id
)
;
if
(
this
.
lastModifiedTime
!
=
aDBAddon
.
updateDate
)
{
aDBAddon
.
updateDate
=
this
.
lastModifiedTime
;
if
(
XPIDatabase
.
initialized
)
{
XPIDatabase
.
saveChanges
(
)
;
}
}
}
}
}
class
XPIStateLocation
extends
Map
{
constructor
(
name
path
saved
=
{
}
)
{
super
(
)
;
this
.
name
=
name
;
this
.
path
=
path
|
|
saved
.
path
|
|
null
;
this
.
staged
=
saved
.
staged
|
|
{
}
;
this
.
changed
=
saved
.
changed
|
|
false
;
this
.
dir
=
this
.
path
&
&
new
nsIFile
(
this
.
path
)
;
for
(
let
[
id
data
]
of
Object
.
entries
(
saved
.
addons
|
|
{
}
)
)
{
let
xpiState
=
this
.
_addState
(
id
data
)
;
xpiState
.
wasRestored
=
true
;
}
}
toJSON
(
)
{
let
json
=
{
addons
:
{
}
staged
:
this
.
staged
}
;
if
(
this
.
path
)
{
json
.
path
=
this
.
path
;
}
if
(
STARTUP_MTIME_SCOPES
.
includes
(
this
.
name
)
)
{
json
.
checkStartupModifications
=
true
;
}
for
(
let
[
id
addon
]
of
this
.
entries
(
)
)
{
json
.
addons
[
id
]
=
addon
;
}
return
json
;
}
get
hasStaged
(
)
{
for
(
let
key
in
this
.
staged
)
{
return
true
;
}
return
false
;
}
_addState
(
addonId
saved
)
{
let
xpiState
=
new
XPIState
(
this
addonId
saved
)
;
this
.
set
(
addonId
xpiState
)
;
return
xpiState
;
}
addAddon
(
addon
)
{
logger
.
debug
(
"
XPIStates
adding
add
-
on
{
id
}
in
{
location
}
:
{
path
}
"
addon
)
;
let
xpiState
=
this
.
_addState
(
addon
.
id
{
file
:
addon
.
_sourceBundle
}
)
;
xpiState
.
syncWithDB
(
addon
true
)
;
XPIProvider
.
setTelemetry
(
addon
.
id
"
location
"
this
.
name
)
;
}
addFile
(
addonId
file
)
{
let
xpiState
=
this
.
_addState
(
addonId
{
enabled
:
false
file
:
file
.
clone
(
)
}
)
;
xpiState
.
getModTime
(
xpiState
.
file
addonId
)
;
return
xpiState
;
}
stageAddon
(
addonId
metadata
)
{
this
.
staged
[
addonId
]
=
metadata
;
XPIStates
.
save
(
)
;
}
unstageAddon
(
addonId
)
{
if
(
addonId
in
this
.
staged
)
{
delete
this
.
staged
[
addonId
]
;
XPIStates
.
save
(
)
;
}
}
*
getStagedAddons
(
)
{
for
(
let
[
id
metadata
]
of
Object
.
entries
(
this
.
staged
)
)
{
yield
[
id
metadata
]
;
}
}
migrateAddon
(
id
state
bootstrapped
)
{
this
.
set
(
id
XPIState
.
migrate
(
this
id
state
bootstrapped
)
)
;
}
}
var
XPIStates
=
{
db
:
null
_jsonFile
:
null
sideLoadedAddons
:
new
Map
(
)
get
size
(
)
{
let
count
=
0
;
if
(
this
.
db
)
{
for
(
let
location
of
this
.
db
.
values
(
)
)
{
count
+
=
location
.
size
;
}
}
return
count
;
}
migrateStateFromPrefs
(
)
{
logger
.
info
(
"
No
addonStartup
.
json
found
.
Attempting
to
migrate
data
from
preferences
"
)
;
let
state
;
let
bootstrappedAddons
;
try
{
state
=
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
PREF_XPI_STATE
)
)
;
bootstrappedAddons
=
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
PREF_BOOTSTRAP_ADDONS
"
{
}
"
)
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Error
parsing
extensions
.
xpiState
and
"
+
"
extensions
.
bootstrappedAddons
:
{
error
}
"
{
error
:
e
}
)
;
}
for
(
let
[
locName
addons
]
of
Object
.
entries
(
state
)
)
{
for
(
let
[
id
addon
]
of
Object
.
entries
(
addons
)
)
{
let
loc
=
this
.
getLocation
(
locName
)
;
if
(
loc
)
{
loc
.
migrateAddon
(
id
addon
bootstrappedAddons
[
id
]
|
|
null
)
;
}
}
}
for
(
let
pref
of
OBSOLETE_PREFERENCES
)
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
OS
.
File
.
remove
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FILE_XPI_ADDONS_LIST
)
)
;
let
data
=
JSON
.
parse
(
JSON
.
stringify
(
this
)
)
;
logger
.
debug
(
"
Migrated
data
:
{
}
"
data
)
;
return
data
;
}
loadExtensionState
(
)
{
let
state
;
try
{
state
=
aomStartup
.
readStartupData
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Error
parsing
extensions
state
:
{
error
}
"
{
error
:
e
}
)
;
}
if
(
!
state
&
&
Services
.
prefs
.
getPrefType
(
PREF_XPI_STATE
)
!
=
Ci
.
nsIPrefBranch
.
PREF_INVALID
)
{
try
{
state
=
this
.
migrateStateFromPrefs
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Error
migrating
extensions
.
xpiState
and
"
+
"
extensions
.
bootstrappedAddons
:
{
error
}
"
{
error
:
e
}
)
;
}
}
logger
.
debug
(
"
Loaded
add
-
on
state
:
{
}
"
state
)
;
return
state
|
|
{
}
;
}
getInstallState
(
ignoreSideloads
=
true
)
{
if
(
!
this
.
db
)
{
this
.
db
=
new
Map
(
)
;
}
let
oldState
=
this
.
initialStateData
|
|
this
.
loadExtensionState
(
)
;
this
.
initialStateData
=
oldState
;
let
changed
=
false
;
let
oldLocations
=
new
Set
(
Object
.
keys
(
oldState
)
)
;
for
(
let
location
of
XPIProvider
.
installLocations
)
{
oldLocations
.
delete
(
location
.
name
)
;
let
loc
=
this
.
getLocation
(
location
.
name
location
.
path
|
|
null
oldState
[
location
.
name
]
|
|
undefined
)
;
changed
=
changed
|
|
loc
.
changed
;
if
(
ignoreSideloads
&
&
!
(
location
.
scope
&
gStartupScanScopes
)
)
{
continue
;
}
if
(
location
.
name
=
=
KEY_APP_TEMPORARY
)
{
continue
;
}
let
knownIds
=
new
Set
(
loc
.
keys
(
)
)
;
for
(
let
[
id
file
]
of
location
.
getAddonLocations
(
true
)
)
{
knownIds
.
delete
(
id
)
;
let
xpiState
=
loc
.
get
(
id
)
;
if
(
!
xpiState
)
{
logger
.
debug
(
"
New
add
-
on
{
id
}
in
{
location
}
"
{
id
location
:
location
.
name
}
)
;
changed
=
true
;
xpiState
=
loc
.
addFile
(
id
file
)
;
if
(
!
location
.
isSystem
)
{
this
.
sideLoadedAddons
.
set
(
id
xpiState
)
;
}
}
else
{
let
addonChanged
=
(
xpiState
.
getModTime
(
file
id
)
|
|
file
.
path
!
=
xpiState
.
path
)
;
xpiState
.
file
=
file
.
clone
(
)
;
if
(
addonChanged
)
{
changed
=
true
;
logger
.
debug
(
"
Changed
add
-
on
{
id
}
in
{
location
}
"
{
id
location
:
location
.
name
}
)
;
}
else
{
logger
.
debug
(
"
Existing
add
-
on
{
id
}
in
{
location
}
"
{
id
location
:
location
.
name
}
)
;
}
}
XPIProvider
.
setTelemetry
(
id
"
location
"
location
.
name
)
;
}
for
(
let
id
of
knownIds
)
{
loc
.
delete
(
id
)
;
changed
=
true
;
}
}
changed
=
changed
|
|
oldLocations
.
size
>
0
;
logger
.
debug
(
"
getInstallState
changed
:
{
rv
}
state
:
{
state
}
"
{
rv
:
changed
state
:
this
.
db
}
)
;
return
changed
;
}
getLocation
(
name
path
saved
)
{
let
location
=
this
.
db
.
get
(
name
)
;
if
(
path
&
&
location
&
&
location
.
path
!
=
path
)
{
location
=
null
;
saved
=
null
;
}
if
(
!
location
|
|
(
path
&
&
location
.
path
!
=
path
)
)
{
let
loc
=
XPIProvider
.
installLocationsByName
[
name
]
;
if
(
loc
)
{
location
=
new
XPIStateLocation
(
name
path
|
|
loc
.
path
|
|
null
saved
)
;
this
.
db
.
set
(
name
location
)
;
}
}
return
location
;
}
getAddon
(
aLocation
aId
)
{
let
location
=
this
.
db
.
get
(
aLocation
)
;
return
location
&
&
location
.
get
(
aId
)
;
}
findAddon
(
aId
aFilter
=
location
=
>
true
)
{
for
(
let
location
of
this
.
db
.
values
(
)
)
{
if
(
!
aFilter
(
location
)
)
{
continue
;
}
if
(
location
.
has
(
aId
)
)
{
return
location
.
get
(
aId
)
;
}
}
return
undefined
;
}
*
enabledAddons
(
)
{
for
(
let
location
of
this
.
db
.
values
(
)
)
{
for
(
let
entry
of
location
.
values
(
)
)
{
if
(
entry
.
enabled
)
{
yield
entry
;
}
}
}
}
*
initialEnabledAddons
(
)
{
for
(
let
addon
of
this
.
enabledAddons
(
)
)
{
if
(
addon
.
wasRestored
)
{
yield
addon
;
}
}
}
*
bootstrappedAddons
(
)
{
for
(
let
addon
of
this
.
enabledAddons
(
)
)
{
if
(
addon
.
bootstrapped
)
{
yield
addon
;
}
}
}
addAddon
(
aAddon
)
{
let
location
=
this
.
getLocation
(
aAddon
.
_installLocation
.
name
)
;
location
.
addAddon
(
aAddon
)
;
}
save
(
)
{
if
(
!
this
.
_jsonFile
)
{
this
.
_jsonFile
=
new
JSONFile
(
{
path
:
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FILE_XPI_STATES
)
finalizeAt
:
AddonManager
.
shutdown
compression
:
"
lz4
"
}
)
;
this
.
_jsonFile
.
data
=
this
;
}
this
.
_jsonFile
.
saveSoon
(
)
;
}
toJSON
(
)
{
let
data
=
{
}
;
for
(
let
[
key
loc
]
of
this
.
db
.
entries
(
)
)
{
if
(
key
!
=
TemporaryInstallLocation
.
name
&
&
(
loc
.
size
|
|
loc
.
hasStaged
)
)
{
data
[
key
]
=
loc
;
}
}
return
data
;
}
removeAddon
(
aLocation
aId
)
{
logger
.
debug
(
"
Removing
XPIState
for
"
+
aLocation
+
"
:
"
+
aId
)
;
let
location
=
this
.
db
.
get
(
aLocation
)
;
if
(
location
)
{
location
.
delete
(
aId
)
;
if
(
location
.
size
=
=
0
)
{
this
.
db
.
delete
(
aLocation
)
;
}
this
.
save
(
)
;
}
}
disableAddon
(
aId
)
{
logger
.
debug
(
Disabling
XPIState
for
{
aId
}
)
;
let
state
=
this
.
findAddon
(
aId
)
;
if
(
state
)
{
state
.
enabled
=
false
;
}
}
}
;
var
XPIProvider
=
{
get
name
(
)
{
return
"
XPIProvider
"
;
}
BOOTSTRAP_REASONS
:
Object
.
freeze
(
BOOTSTRAP_REASONS
)
installLocations
:
null
installLocationsByName
:
null
installs
:
null
minCompatibleAppVersion
:
null
minCompatiblePlatformVersion
:
null
activeAddons
:
new
Map
(
)
extensionsActive
:
false
allAppGlobal
:
true
newDistroAddons
:
null
runPhase
:
XPI_STARTING
_telemetryDetails
:
{
}
_closing
:
false
get
isDBLoaded
(
)
{
return
(
Object
.
getOwnPropertyDescriptor
(
gGlobalScope
"
XPIDatabase
"
)
.
value
&
&
XPIDatabase
.
initialized
)
;
}
addonIsActive
(
addonId
)
{
let
state
=
XPIStates
.
findAddon
(
addonId
)
;
return
state
&
&
state
.
enabled
;
}
sortBootstrappedAddons
(
)
{
function
compare
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
0
;
}
return
(
a
<
b
)
?
-
1
:
1
;
}
let
list
=
Array
.
from
(
XPIStates
.
bootstrappedAddons
(
)
)
;
list
.
sort
(
(
a
b
)
=
>
compare
(
a
.
id
b
.
id
)
)
;
let
addons
=
{
}
;
for
(
let
entry
of
list
)
{
addons
[
entry
.
id
]
=
entry
;
}
let
res
=
new
Set
(
)
;
let
seen
=
new
Set
(
)
;
let
add
=
addon
=
>
{
seen
.
add
(
addon
.
id
)
;
for
(
let
id
of
addon
.
dependencies
|
|
[
]
)
{
if
(
id
in
addons
&
&
!
seen
.
has
(
id
)
)
{
add
(
addons
[
id
]
)
;
}
}
res
.
add
(
addon
.
id
)
;
}
;
Object
.
values
(
addons
)
.
forEach
(
add
)
;
return
Array
.
from
(
res
id
=
>
addons
[
id
]
)
;
}
setTelemetry
(
aId
aName
aValue
)
{
if
(
!
this
.
_telemetryDetails
[
aId
]
)
this
.
_telemetryDetails
[
aId
]
=
{
}
;
this
.
_telemetryDetails
[
aId
]
[
aName
]
=
aValue
;
}
_inProgress
:
[
]
doing
(
aCancellable
)
{
this
.
_inProgress
.
push
(
aCancellable
)
;
}
done
(
aCancellable
)
{
let
i
=
this
.
_inProgress
.
indexOf
(
aCancellable
)
;
if
(
i
!
=
-
1
)
{
this
.
_inProgress
.
splice
(
i
1
)
;
return
true
;
}
return
false
;
}
cancelAll
(
)
{
while
(
this
.
_inProgress
.
length
>
0
)
{
let
c
=
this
.
_inProgress
.
shift
(
)
;
try
{
c
.
cancel
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Cancel
failed
"
e
)
;
}
}
}
startup
(
aAppChanged
aOldAppVersion
aOldPlatformVersion
)
{
function
addDirectoryInstallLocation
(
aName
aKey
aPaths
aScope
aLocked
)
{
try
{
var
dir
=
FileUtils
.
getDir
(
aKey
aPaths
)
;
}
catch
(
e
)
{
logger
.
debug
(
"
Skipping
unavailable
install
location
"
+
aName
)
;
return
;
}
try
{
var
location
=
aLocked
?
new
DirectoryInstallLocation
(
aName
dir
aScope
)
:
new
MutableDirectoryInstallLocation
(
aName
dir
aScope
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
add
directory
install
location
"
+
aName
e
)
;
return
;
}
XPIProvider
.
installLocations
.
push
(
location
)
;
XPIProvider
.
installLocationsByName
[
location
.
name
]
=
location
;
}
function
addBuiltInInstallLocation
(
name
key
paths
scope
)
{
let
dir
;
try
{
dir
=
FileUtils
.
getDir
(
key
paths
)
;
}
catch
(
e
)
{
return
;
}
try
{
let
location
=
new
BuiltInInstallLocation
(
name
dir
scope
)
;
XPIProvider
.
installLocations
.
push
(
location
)
;
XPIProvider
.
installLocationsByName
[
location
.
name
]
=
location
;
}
catch
(
e
)
{
logger
.
warn
(
Failed
to
add
built
-
in
install
location
{
name
}
e
)
;
}
}
function
addSystemAddonInstallLocation
(
aName
aKey
aPaths
aScope
)
{
try
{
var
dir
=
FileUtils
.
getDir
(
aKey
aPaths
)
;
}
catch
(
e
)
{
logger
.
debug
(
"
Skipping
unavailable
install
location
"
+
aName
)
;
return
;
}
try
{
var
location
=
new
SystemAddonInstallLocation
(
aName
dir
aScope
aAppChanged
!
=
=
false
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
add
system
add
-
on
install
location
"
+
aName
e
)
;
return
;
}
XPIProvider
.
installLocations
.
push
(
location
)
;
XPIProvider
.
installLocationsByName
[
location
.
name
]
=
location
;
}
function
addRegistryInstallLocation
(
aName
aRootkey
aScope
)
{
try
{
var
location
=
new
WinRegInstallLocation
(
aName
aRootkey
aScope
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
add
registry
install
location
"
+
aName
e
)
;
return
;
}
XPIProvider
.
installLocations
.
push
(
location
)
;
XPIProvider
.
installLocationsByName
[
location
.
name
]
=
location
;
}
try
{
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_startup_begin
"
)
;
logger
.
debug
(
"
startup
"
)
;
this
.
runPhase
=
XPI_STARTING
;
this
.
installs
=
new
Set
(
)
;
this
.
installLocations
=
[
]
;
this
.
installLocationsByName
=
{
}
;
this
.
_telemetryDetails
=
{
}
;
AddonManagerPrivate
.
setTelemetryDetails
(
"
XPI
"
this
.
_telemetryDetails
)
;
let
hasRegistry
=
(
"
nsIWindowsRegKey
"
in
Ci
)
;
let
enabledScopes
=
Services
.
prefs
.
getIntPref
(
PREF_EM_ENABLED_SCOPES
AddonManager
.
SCOPE_ALL
)
;
XPIProvider
.
installLocations
.
push
(
TemporaryInstallLocation
)
;
XPIProvider
.
installLocationsByName
[
TemporaryInstallLocation
.
name
]
=
TemporaryInstallLocation
;
addDirectoryInstallLocation
(
KEY_APP_PROFILE
KEY_PROFILEDIR
[
DIR_EXTENSIONS
]
AddonManager
.
SCOPE_PROFILE
false
)
;
addSystemAddonInstallLocation
(
KEY_APP_SYSTEM_ADDONS
KEY_PROFILEDIR
[
DIR_SYSTEM_ADDONS
]
AddonManager
.
SCOPE_PROFILE
)
;
addBuiltInInstallLocation
(
KEY_APP_SYSTEM_DEFAULTS
KEY_APP_FEATURES
[
]
AddonManager
.
SCOPE_PROFILE
)
;
if
(
enabledScopes
&
AddonManager
.
SCOPE_USER
)
{
addDirectoryInstallLocation
(
KEY_APP_SYSTEM_USER
"
XREUSysExt
"
[
Services
.
appinfo
.
ID
]
AddonManager
.
SCOPE_USER
true
)
;
if
(
hasRegistry
)
{
addRegistryInstallLocation
(
"
winreg
-
app
-
user
"
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
AddonManager
.
SCOPE_USER
)
;
}
}
addDirectoryInstallLocation
(
KEY_APP_GLOBAL
KEY_ADDON_APP_DIR
[
DIR_EXTENSIONS
]
AddonManager
.
SCOPE_APPLICATION
true
)
;
if
(
enabledScopes
&
AddonManager
.
SCOPE_SYSTEM
)
{
addDirectoryInstallLocation
(
KEY_APP_SYSTEM_SHARE
"
XRESysSExtPD
"
[
Services
.
appinfo
.
ID
]
AddonManager
.
SCOPE_SYSTEM
true
)
;
addDirectoryInstallLocation
(
KEY_APP_SYSTEM_LOCAL
"
XRESysLExtPD
"
[
Services
.
appinfo
.
ID
]
AddonManager
.
SCOPE_SYSTEM
true
)
;
if
(
hasRegistry
)
{
addRegistryInstallLocation
(
"
winreg
-
app
-
global
"
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_LOCAL_MACHINE
AddonManager
.
SCOPE_SYSTEM
)
;
}
}
this
.
minCompatibleAppVersion
=
Services
.
prefs
.
getStringPref
(
PREF_EM_MIN_COMPAT_APP_VERSION
null
)
;
this
.
minCompatiblePlatformVersion
=
Services
.
prefs
.
getStringPref
(
PREF_EM_MIN_COMPAT_PLATFORM_VERSION
null
)
;
Services
.
prefs
.
addObserver
(
PREF_EM_MIN_COMPAT_APP_VERSION
this
)
;
Services
.
prefs
.
addObserver
(
PREF_EM_MIN_COMPAT_PLATFORM_VERSION
this
)
;
if
(
!
AppConstants
.
MOZ_REQUIRE_SIGNING
|
|
Cu
.
isInAutomation
)
Services
.
prefs
.
addObserver
(
PREF_XPI_SIGNATURES_REQUIRED
this
)
;
Services
.
prefs
.
addObserver
(
PREF_LANGPACK_SIGNATURES
this
)
;
Services
.
prefs
.
addObserver
(
PREF_ALLOW_LEGACY
this
)
;
Services
.
obs
.
addObserver
(
this
NOTIFICATION_FLUSH_PERMISSIONS
)
;
Services
.
obs
.
addObserver
(
this
NOTIFICATION_TOOLBOX_CONNECTION_CHANGE
)
;
let
flushCaches
=
this
.
checkForChanges
(
aAppChanged
aOldAppVersion
aOldPlatformVersion
)
;
AddonManagerPrivate
.
markProviderSafe
(
this
)
;
if
(
aAppChanged
&
&
!
this
.
allAppGlobal
&
&
Services
.
prefs
.
getBoolPref
(
PREF_EM_SHOW_MISMATCH_UI
true
)
&
&
AddonManager
.
updateEnabled
)
{
let
addonsToUpdate
=
this
.
shouldForceUpdateCheck
(
aAppChanged
)
;
if
(
addonsToUpdate
)
{
this
.
noLegacyStartupCheck
(
addonsToUpdate
)
;
flushCaches
=
true
;
}
}
if
(
flushCaches
)
{
Services
.
obs
.
notifyObservers
(
null
"
startupcache
-
invalidate
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
chrome
-
flush
-
skin
-
caches
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
chrome
-
flush
-
caches
"
)
;
}
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
try
{
Services
.
appinfo
.
annotateCrashReport
(
"
EMCheckCompatibility
"
AddonManager
.
checkCompatibility
)
;
}
catch
(
e
)
{
}
this
.
addAddonsToCrashReporter
(
)
;
}
try
{
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_bootstrap_addons_begin
"
)
;
for
(
let
addon
of
this
.
sortBootstrappedAddons
(
)
)
{
let
activeAddon
=
this
.
activeAddons
.
get
(
addon
.
id
)
;
if
(
activeAddon
&
&
activeAddon
.
started
)
{
continue
;
}
try
{
let
reason
=
BOOTSTRAP_REASONS
.
APP_STARTUP
;
if
(
AddonManager
.
getStartupChanges
(
AddonManager
.
STARTUP_CHANGE_INSTALLED
)
.
includes
(
addon
.
id
)
)
reason
=
BOOTSTRAP_REASONS
.
ADDON_INSTALL
;
this
.
callBootstrapMethod
(
addon
addon
.
file
"
startup
"
reason
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
load
bootstrap
addon
"
+
addon
.
id
+
"
from
"
+
addon
.
descriptor
e
)
;
}
}
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_bootstrap_addons_end
"
)
;
}
catch
(
e
)
{
logger
.
error
(
"
bootstrap
startup
failed
"
e
)
;
AddonManagerPrivate
.
recordException
(
"
XPI
-
BOOTSTRAP
"
"
startup
failed
"
e
)
;
}
Services
.
obs
.
addObserver
(
{
observe
(
aSubject
aTopic
aData
)
{
XPIProvider
.
cleanupTemporaryAddons
(
)
;
XPIProvider
.
_closing
=
true
;
for
(
let
addon
of
XPIProvider
.
sortBootstrappedAddons
(
)
.
reverse
(
)
)
{
let
activeAddon
=
XPIProvider
.
activeAddons
.
get
(
addon
.
id
)
;
if
(
!
activeAddon
|
|
!
activeAddon
.
started
)
{
continue
;
}
let
reason
=
BOOTSTRAP_REASONS
.
APP_SHUTDOWN
;
if
(
addon
.
disable
)
{
reason
=
BOOTSTRAP_REASONS
.
ADDON_DISABLE
;
}
else
if
(
addon
.
location
.
name
=
=
KEY_APP_TEMPORARY
)
{
reason
=
BOOTSTRAP_REASONS
.
ADDON_UNINSTALL
;
let
existing
=
XPIStates
.
findAddon
(
addon
.
id
loc
=
>
loc
.
name
!
=
TemporaryInstallLocation
.
name
)
;
if
(
existing
)
{
reason
=
XPIInstall
.
newVersionReason
(
addon
.
version
existing
.
version
)
;
}
}
XPIProvider
.
callBootstrapMethod
(
addon
addon
.
file
"
shutdown
"
reason
)
;
}
Services
.
obs
.
removeObserver
(
this
"
quit
-
application
-
granted
"
)
;
}
}
"
quit
-
application
-
granted
"
)
;
Services
.
obs
.
addObserver
(
{
observe
(
aSubject
aTopic
aData
)
{
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_finalUIStartup
"
)
;
XPIProvider
.
runPhase
=
XPI_AFTER_UI_STARTUP
;
Services
.
obs
.
removeObserver
(
this
"
final
-
ui
-
startup
"
)
;
}
}
"
final
-
ui
-
startup
"
)
;
if
(
!
this
.
isDBLoaded
)
{
const
EVENTS
=
[
"
sessionstore
-
windows
-
restored
"
"
xul
-
window
-
visible
"
"
test
-
load
-
xpi
-
database
"
]
;
let
observer
=
{
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
xul
-
window
-
visible
"
&
&
!
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
toolbox
"
)
)
{
return
;
}
for
(
let
event
of
EVENTS
)
{
Services
.
obs
.
removeObserver
(
observer
event
)
;
}
XPIDatabase
.
asyncLoadDB
(
)
;
}
}
;
for
(
let
event
of
EVENTS
)
{
Services
.
obs
.
addObserver
(
observer
event
)
;
}
}
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_startup_end
"
)
;
this
.
extensionsActive
=
true
;
this
.
runPhase
=
XPI_BEFORE_UI_STARTUP
;
let
timerManager
=
Cc
[
"
mozilla
.
org
/
updates
/
timer
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateTimerManager
)
;
timerManager
.
registerTimer
(
"
xpi
-
signature
-
verification
"
(
)
=
>
{
this
.
verifySignatures
(
)
;
}
XPI_SIGNATURE_CHECK_PERIOD
)
;
}
catch
(
e
)
{
logger
.
error
(
"
startup
failed
"
e
)
;
AddonManagerPrivate
.
recordException
(
"
XPI
"
"
startup
failed
"
e
)
;
}
}
async
shutdown
(
)
{
logger
.
debug
(
"
shutdown
"
)
;
this
.
cancelAll
(
)
;
this
.
activeAddons
.
clear
(
)
;
this
.
allAppGlobal
=
true
;
for
(
let
install
of
this
.
installs
)
{
if
(
install
.
onShutdown
(
)
)
{
install
.
onShutdown
(
)
;
}
}
if
(
Services
.
prefs
.
getBoolPref
(
PREF_PENDING_OPERATIONS
false
)
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_pending_ops
"
1
)
;
XPIDatabase
.
updateActiveAddons
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
false
)
;
}
if
(
!
XPIDatabase
.
initialized
)
{
await
XPIDatabase
.
asyncLoadDB
(
)
;
}
this
.
installs
=
null
;
this
.
installLocations
=
null
;
this
.
installLocationsByName
=
null
;
this
.
extensionsActive
=
false
;
await
XPIDatabase
.
shutdown
(
)
;
}
cleanupTemporaryAddons
(
)
{
let
tempLocation
=
XPIStates
.
getLocation
(
TemporaryInstallLocation
.
name
)
;
if
(
tempLocation
)
{
for
(
let
[
id
addon
]
of
tempLocation
.
entries
(
)
)
{
tempLocation
.
delete
(
id
)
;
let
reason
=
BOOTSTRAP_REASONS
.
ADDON_UNINSTALL
;
let
existing
=
XPIStates
.
findAddon
(
id
loc
=
>
loc
!
=
tempLocation
)
;
let
callUpdate
=
false
;
if
(
existing
)
{
reason
=
XPIInstall
.
newVersionReason
(
addon
.
version
existing
.
version
)
;
callUpdate
=
(
isWebExtension
(
addon
.
type
)
&
&
isWebExtension
(
existing
.
type
)
)
;
}
this
.
callBootstrapMethod
(
addon
addon
.
file
"
shutdown
"
reason
)
;
if
(
!
callUpdate
)
{
this
.
callBootstrapMethod
(
addon
addon
.
file
"
uninstall
"
reason
)
;
}
this
.
unloadBootstrapScope
(
id
)
;
TemporaryInstallLocation
.
uninstallAddon
(
id
)
;
XPIStates
.
removeAddon
(
TemporaryInstallLocation
.
name
id
)
;
if
(
existing
)
{
let
newAddon
=
XPIDatabase
.
makeAddonLocationVisible
(
id
existing
.
location
.
name
)
;
let
file
=
new
nsIFile
(
newAddon
.
path
)
;
let
data
=
{
oldVersion
:
addon
.
version
}
;
let
method
=
callUpdate
?
"
update
"
:
"
install
"
;
this
.
callBootstrapMethod
(
newAddon
file
method
reason
data
)
;
}
}
}
}
shouldForceUpdateCheck
(
aAppChanged
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_metadata_age
"
AddonRepository
.
metadataAge
(
)
)
;
let
startupChanges
=
AddonManager
.
getStartupChanges
(
AddonManager
.
STARTUP_CHANGE_DISABLED
)
;
logger
.
debug
(
"
shouldForceUpdateCheck
startupChanges
:
"
+
startupChanges
.
toSource
(
)
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startup_disabled
"
startupChanges
.
length
)
;
let
forceUpdate
=
[
]
;
if
(
startupChanges
.
length
>
0
)
{
let
addons
=
XPIDatabase
.
getAddons
(
)
;
for
(
let
addon
of
addons
)
{
if
(
(
startupChanges
.
includes
(
addon
.
id
)
)
&
&
(
addon
.
permissions
(
)
&
AddonManager
.
PERM_CAN_UPGRADE
)
&
&
(
!
addon
.
isCompatible
|
|
isDisabledLegacy
(
addon
)
)
)
{
logger
.
debug
(
"
shouldForceUpdateCheck
:
can
upgrade
disabled
add
-
on
"
+
addon
.
id
)
;
forceUpdate
.
push
(
addon
.
id
)
;
}
}
}
if
(
forceUpdate
.
length
>
0
)
{
return
forceUpdate
;
}
return
null
;
}
noLegacyStartupCheck
(
ids
)
{
let
started
=
new
Set
(
)
;
const
DIALOG
=
"
chrome
:
/
/
mozapps
/
content
/
extensions
/
update
.
html
"
;
const
SHOW_DIALOG_DELAY
=
1000
;
const
SHOW_CANCEL_DELAY
=
30000
;
let
updateProgress
=
val
=
>
{
}
;
let
progressByID
=
new
Map
(
)
;
function
setProgress
(
id
val
)
{
progressByID
.
set
(
id
val
)
;
updateProgress
(
Array
.
from
(
progressByID
.
values
(
)
)
.
reduce
(
(
a
b
)
=
>
a
+
b
)
/
progressByID
.
size
)
;
}
let
checkOne
=
async
(
id
)
=
>
{
logger
.
debug
(
Checking
for
updates
to
disabled
addon
{
id
}
\
n
)
;
setProgress
(
id
0
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
let
install
=
await
new
Promise
(
resolve
=
>
addon
.
findUpdates
(
{
onUpdateFinished
(
)
{
resolve
(
null
)
;
}
onUpdateAvailable
(
addon
install
)
{
resolve
(
install
)
;
}
}
AddonManager
.
UPDATE_WHEN_NEW_APP_INSTALLED
)
)
;
if
(
!
install
)
{
setProgress
(
id
1
)
;
return
;
}
setProgress
(
id
0
.
1
)
;
let
installPromise
=
new
Promise
(
resolve
=
>
{
let
finish
=
(
)
=
>
{
setProgress
(
id
1
)
;
resolve
(
)
;
}
;
install
.
addListener
(
{
onDownloadProgress
(
)
{
if
(
install
.
maxProgress
!
=
0
)
{
setProgress
(
id
0
.
1
+
0
.
8
*
install
.
progress
/
install
.
maxProgress
)
;
}
}
onDownloadEnded
(
)
{
setProgress
(
id
0
.
9
)
;
}
onDownloadFailed
:
finish
onInstallFailed
:
finish
onInstallEnded
(
)
{
started
.
add
(
id
)
;
AddonManagerPrivate
.
addStartupChange
(
AddonManager
.
STARTUP_CHANGE_CHANGED
id
)
;
finish
(
)
;
}
}
)
;
}
)
;
install
.
install
(
)
;
await
installPromise
;
}
;
let
finished
=
false
;
Promise
.
all
(
ids
.
map
(
checkOne
)
)
.
then
(
(
)
=
>
{
finished
=
true
;
}
)
;
let
window
;
let
timer
=
setTimeout
(
(
)
=
>
{
const
FEATURES
=
"
chrome
dialog
centerscreen
scrollbars
=
no
"
;
window
=
Services
.
ww
.
openWindow
(
null
DIALOG
"
"
FEATURES
null
)
;
let
cancelDiv
;
window
.
addEventListener
(
"
DOMContentLoaded
"
e
=
>
{
let
progress
=
window
.
document
.
getElementById
(
"
progress
"
)
;
updateProgress
=
val
=
>
{
progress
.
value
=
val
;
}
;
cancelDiv
=
window
.
document
.
getElementById
(
"
cancel
-
section
"
)
;
cancelDiv
.
setAttribute
(
"
style
"
"
display
:
none
;
"
)
;
let
cancelBtn
=
window
.
document
.
getElementById
(
"
cancel
-
btn
"
)
;
cancelBtn
.
addEventListener
(
"
click
"
e
=
>
{
finished
=
true
;
}
)
;
}
)
;
timer
=
setTimeout
(
(
)
=
>
{
cancelDiv
.
removeAttribute
(
"
style
"
)
;
window
.
sizeToContent
(
)
;
}
SHOW_CANCEL_DELAY
-
SHOW_DIALOG_DELAY
)
;
}
SHOW_DIALOG_DELAY
)
;
Services
.
tm
.
spinEventLoopUntil
(
(
)
=
>
finished
)
;
clearTimeout
(
timer
)
;
if
(
window
)
{
window
.
close
(
)
;
}
return
started
;
}
async
verifySignatures
(
)
{
try
{
let
addons
=
await
XPIDatabase
.
getAddonList
(
a
=
>
true
)
;
let
changes
=
{
enabled
:
[
]
disabled
:
[
]
}
;
for
(
let
addon
of
addons
)
{
if
(
!
addon
.
_sourceBundle
.
exists
(
)
)
continue
;
let
signedState
=
await
verifyBundleSignedState
(
addon
.
_sourceBundle
addon
)
;
if
(
signedState
!
=
addon
.
signedState
)
{
addon
.
signedState
=
signedState
;
AddonManagerPrivate
.
callAddonListeners
(
"
onPropertyChanged
"
addon
.
wrapper
[
"
signedState
"
]
)
;
}
let
disabled
=
XPIProvider
.
updateAddonDisabledState
(
addon
)
;
if
(
disabled
!
=
=
undefined
)
changes
[
disabled
?
"
disabled
"
:
"
enabled
"
]
.
push
(
addon
.
id
)
;
}
XPIDatabase
.
saveChanges
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
xpi
-
signature
-
changed
"
JSON
.
stringify
(
changes
)
)
;
}
catch
(
err
)
{
logger
.
error
(
"
XPI_verifySignature
:
"
+
err
)
;
}
}
addAddonsToCrashReporter
(
)
{
if
(
!
(
Services
.
appinfo
instanceof
Ci
.
nsICrashReporter
)
|
|
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
;
}
if
(
Services
.
appinfo
.
inSafeMode
)
{
return
;
}
let
data
=
Array
.
from
(
XPIStates
.
enabledAddons
(
)
a
=
>
encoded
{
a
.
id
}
:
{
a
.
version
}
)
.
join
(
"
"
)
;
try
{
Services
.
appinfo
.
annotateCrashReport
(
"
Add
-
ons
"
data
)
;
}
catch
(
e
)
{
}
let
TelemetrySession
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySession
.
jsm
"
{
}
)
.
TelemetrySession
;
TelemetrySession
.
setAddOns
(
data
)
;
}
processPendingFileChanges
(
aManifests
)
{
let
changed
=
false
;
for
(
let
location
of
this
.
installLocations
)
{
aManifests
[
location
.
name
]
=
{
}
;
if
(
location
.
locked
)
{
continue
;
}
let
state
=
XPIStates
.
getLocation
(
location
.
name
)
;
let
cleanNames
=
[
]
;
let
promises
=
[
]
;
for
(
let
[
id
metadata
]
of
state
.
getStagedAddons
(
)
)
{
state
.
unstageAddon
(
id
)
;
aManifests
[
location
.
name
]
[
id
]
=
null
;
promises
.
push
(
XPIInstall
.
installStagedAddon
(
id
metadata
location
)
.
then
(
addon
=
>
{
aManifests
[
location
.
name
]
[
id
]
=
addon
;
}
error
=
>
{
delete
aManifests
[
location
.
name
]
[
id
]
;
cleanNames
.
push
(
{
id
}
.
xpi
)
;
logger
.
error
(
Failed
to
install
staged
add
-
on
{
id
}
in
{
location
.
name
}
error
)
;
}
)
)
;
}
if
(
promises
.
length
)
{
changed
=
true
;
awaitPromise
(
Promise
.
all
(
promises
)
)
;
}
try
{
if
(
cleanNames
.
length
)
{
location
.
cleanStagingDir
(
cleanNames
)
;
}
}
catch
(
e
)
{
logger
.
debug
(
"
Error
cleaning
staging
dir
"
e
)
;
}
}
return
changed
;
}
installDistributionAddons
(
aManifests
aAppChanged
)
{
let
distroDir
;
try
{
distroDir
=
FileUtils
.
getDir
(
KEY_APP_DISTRIBUTION
[
DIR_EXTENSIONS
]
)
;
}
catch
(
e
)
{
return
false
;
}
if
(
!
distroDir
.
exists
(
)
)
return
false
;
if
(
!
distroDir
.
isDirectory
(
)
)
return
false
;
let
changed
=
false
;
let
profileLocation
=
this
.
installLocationsByName
[
KEY_APP_PROFILE
]
;
let
entries
=
distroDir
.
directoryEntries
.
QueryInterface
(
Ci
.
nsIDirectoryEnumerator
)
;
let
entry
;
while
(
(
entry
=
entries
.
nextFile
)
)
{
let
id
=
entry
.
leafName
;
if
(
entry
.
isFile
(
)
)
{
if
(
id
.
endsWith
(
"
.
xpi
"
)
)
{
id
=
id
.
slice
(
0
-
4
)
;
}
else
{
logger
.
debug
(
"
Ignoring
distribution
add
-
on
that
isn
'
t
an
XPI
:
"
+
entry
.
path
)
;
continue
;
}
}
else
if
(
!
entry
.
isDirectory
(
)
)
{
logger
.
debug
(
"
Ignoring
distribution
add
-
on
that
isn
'
t
a
file
or
directory
:
"
+
entry
.
path
)
;
continue
;
}
if
(
!
gIDTest
.
test
(
id
)
)
{
logger
.
debug
(
"
Ignoring
distribution
add
-
on
whose
name
is
not
a
valid
add
-
on
ID
:
"
+
entry
.
path
)
;
continue
;
}
if
(
!
aAppChanged
&
&
Services
.
prefs
.
prefHasUserValue
(
PREF_BRANCH_INSTALLED_ADDON
+
id
)
)
{
continue
;
}
try
{
let
addon
=
awaitPromise
(
XPIInstall
.
installDistributionAddon
(
id
entry
profileLocation
)
)
;
if
(
addon
)
{
if
(
!
(
KEY_APP_PROFILE
in
aManifests
)
)
aManifests
[
KEY_APP_PROFILE
]
=
{
}
;
aManifests
[
KEY_APP_PROFILE
]
[
id
]
=
addon
;
changed
=
true
;
}
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
install
distribution
add
-
on
"
+
entry
.
path
e
)
;
}
}
entries
.
close
(
)
;
return
changed
;
}
getNewDistroAddons
(
)
{
let
addons
=
this
.
newDistroAddons
;
this
.
newDistroAddons
=
null
;
return
addons
;
}
importPermissions
(
)
{
PermissionsUtils
.
importFromPrefs
(
PREF_XPI_PERMISSIONS_BRANCH
XPI_PERMISSION
)
;
}
getDependentAddons
(
aAddon
)
{
return
Array
.
from
(
XPIDatabase
.
getAddons
(
)
)
.
filter
(
addon
=
>
addon
.
dependencies
.
includes
(
aAddon
.
id
)
)
;
}
checkForChanges
(
aAppChanged
aOldAppVersion
aOldPlatformVersion
)
{
logger
.
debug
(
"
checkForChanges
"
)
;
let
updateReasons
=
[
]
;
if
(
aAppChanged
)
{
updateReasons
.
push
(
"
appChanged
"
)
;
}
let
installChanged
=
XPIStates
.
getInstallState
(
aAppChanged
=
=
=
false
)
;
if
(
installChanged
)
{
updateReasons
.
push
(
"
directoryState
"
)
;
}
let
manifests
=
{
}
;
let
updated
=
this
.
processPendingFileChanges
(
manifests
)
;
if
(
updated
)
{
updateReasons
.
push
(
"
pendingFileChanges
"
)
;
}
let
hasPendingChanges
=
Services
.
prefs
.
getBoolPref
(
PREF_PENDING_OPERATIONS
false
)
;
if
(
hasPendingChanges
)
{
updateReasons
.
push
(
"
hasPendingChanges
"
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
PREF_INSTALL_DISTRO_ADDONS
true
)
)
{
updated
=
this
.
installDistributionAddons
(
manifests
aAppChanged
)
;
if
(
updated
)
{
updateReasons
.
push
(
"
installDistributionAddons
"
)
;
}
}
let
haveAnyAddons
=
(
XPIStates
.
size
>
0
)
;
if
(
DB_SCHEMA
!
=
Services
.
prefs
.
getIntPref
(
PREF_DB_SCHEMA
0
)
)
{
if
(
!
haveAnyAddons
)
{
logger
.
debug
(
"
Empty
XPI
database
setting
schema
version
preference
to
"
+
DB_SCHEMA
)
;
Services
.
prefs
.
setIntPref
(
PREF_DB_SCHEMA
DB_SCHEMA
)
;
}
else
{
updateReasons
.
push
(
"
schemaChanged
"
)
;
}
}
let
dbFile
=
FileUtils
.
getFile
(
KEY_PROFILEDIR
[
FILE_DATABASE
]
true
)
;
if
(
!
dbFile
.
exists
(
)
&
&
haveAnyAddons
)
{
updateReasons
.
push
(
"
needNewDatabase
"
)
;
}
try
{
let
extensionListChanged
=
false
;
if
(
updateReasons
.
length
>
0
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startup_load_reasons
"
updateReasons
)
;
XPIDatabase
.
syncLoadDB
(
false
)
;
try
{
extensionListChanged
=
XPIDatabaseReconcile
.
processFileChanges
(
manifests
aAppChanged
aOldAppVersion
aOldPlatformVersion
updateReasons
.
includes
(
"
schemaChanged
"
)
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
process
extension
changes
at
startup
"
e
)
;
}
}
if
(
extensionListChanged
|
|
hasPendingChanges
)
{
this
.
_updateActiveAddons
(
)
;
return
true
;
}
logger
.
debug
(
"
No
changes
found
"
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Error
during
startup
file
checks
"
e
)
;
}
return
false
;
}
_updateActiveAddons
(
)
{
logger
.
debug
(
"
Updating
database
with
changes
to
installed
add
-
ons
"
)
;
XPIDatabase
.
updateActiveAddons
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
false
)
;
}
async
getNewSideloads
(
)
{
if
(
XPIStates
.
getInstallState
(
false
)
)
{
await
XPIDatabase
.
asyncLoadDB
(
false
)
;
XPIDatabaseReconcile
.
processFileChanges
(
{
}
false
)
;
this
.
_updateActiveAddons
(
)
;
}
let
addons
=
await
Promise
.
all
(
Array
.
from
(
XPIStates
.
sideLoadedAddons
.
keys
(
)
id
=
>
AddonManager
.
getAddonByID
(
id
)
)
)
;
return
addons
.
filter
(
addon
=
>
(
addon
.
seen
=
=
=
false
&
&
addon
.
permissions
&
AddonManager
.
PERM_CAN_ENABLE
)
)
;
}
supportsMimetype
(
aMimetype
)
{
return
aMimetype
=
=
"
application
/
x
-
xpinstall
"
;
}
isTemporaryInstallID
(
id
)
{
return
id
.
endsWith
(
TEMPORARY_ADDON_SUFFIX
)
;
}
setStartupData
(
aID
aData
)
{
let
state
=
XPIStates
.
findAddon
(
aID
)
;
state
.
startupData
=
aData
;
XPIStates
.
save
(
)
;
}
getAddonByInstanceID
(
aInstanceID
)
{
let
id
=
this
.
getAddonIDByInstanceID
(
aInstanceID
)
;
if
(
id
)
{
return
this
.
syncGetAddonByID
(
id
)
;
}
return
null
;
}
getAddonIDByInstanceID
(
aInstanceID
)
{
if
(
!
aInstanceID
|
|
typeof
aInstanceID
!
=
"
symbol
"
)
throw
Components
.
Exception
(
"
aInstanceID
must
be
a
Symbol
(
)
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
for
(
let
[
id
val
]
of
this
.
activeAddons
)
{
if
(
aInstanceID
=
=
val
.
instanceID
)
{
return
id
;
}
}
return
null
;
}
removeActiveInstall
(
aInstall
)
{
this
.
installs
.
delete
(
aInstall
)
;
}
async
getAddonByID
(
aId
)
{
let
aAddon
=
await
XPIDatabase
.
getVisibleAddonForID
(
aId
)
;
return
aAddon
?
aAddon
.
wrapper
:
null
;
}
syncGetAddonByID
(
aId
)
{
let
aAddon
=
XPIDatabase
.
syncGetVisibleAddonForID
(
aId
)
;
return
aAddon
?
aAddon
.
wrapper
:
null
;
}
async
getAddonsByTypes
(
aTypes
)
{
let
typesToGet
=
getAllAliasesForTypes
(
aTypes
)
;
if
(
typesToGet
&
&
!
typesToGet
.
some
(
type
=
>
ALL_EXTERNAL_TYPES
.
has
(
type
)
)
)
{
return
[
]
;
}
let
addons
=
await
XPIDatabase
.
getVisibleAddons
(
typesToGet
)
;
return
addons
.
map
(
a
=
>
a
.
wrapper
)
;
}
async
getActiveAddons
(
aTypes
)
{
if
(
this
.
isDBLoaded
)
{
let
addons
=
await
this
.
getAddonsByTypes
(
aTypes
)
;
return
{
addons
:
addons
.
filter
(
addon
=
>
addon
.
isActive
)
fullData
:
true
}
;
}
if
(
!
XPIStates
.
db
)
{
throw
new
Error
(
"
XPIStates
not
yet
initialized
"
)
;
}
let
result
=
[
]
;
for
(
let
addon
of
XPIStates
.
enabledAddons
(
)
)
{
if
(
aTypes
&
&
!
aTypes
.
includes
(
addon
.
type
)
)
{
continue
;
}
let
location
=
this
.
installLocationsByName
[
addon
.
location
.
name
]
;
let
scope
isSystem
;
if
(
location
)
{
(
{
scope
isSystem
}
=
location
)
;
}
result
.
push
(
{
id
:
addon
.
id
version
:
addon
.
version
type
:
addon
.
type
updateDate
:
addon
.
lastModifiedTime
scope
isSystem
isWebExtension
:
isWebExtension
(
addon
)
}
)
;
}
return
{
addons
:
result
fullData
:
false
}
;
}
async
getAddonBySyncGUID
(
aGUID
)
{
let
addon
=
await
XPIDatabase
.
getAddonBySyncGUID
(
aGUID
)
;
return
addon
?
addon
.
wrapper
:
null
;
}
async
getAddonsWithOperationsByTypes
(
aTypes
)
{
let
typesToGet
=
getAllAliasesForTypes
(
aTypes
)
;
let
aAddons
=
await
XPIDatabase
.
getVisibleAddonsWithPendingOperations
(
typesToGet
)
;
let
results
=
aAddons
.
map
(
a
=
>
a
.
wrapper
)
;
for
(
let
install
of
XPIProvider
.
installs
)
{
if
(
install
.
state
=
=
AddonManager
.
STATE_INSTALLED
&
&
!
(
install
.
addon
.
inDatabase
)
)
results
.
push
(
install
.
addon
.
wrapper
)
;
}
return
results
;
}
getInstallsByTypes
(
aTypes
)
{
let
results
=
[
.
.
.
this
.
installs
]
;
if
(
aTypes
)
{
results
=
results
.
filter
(
install
=
>
{
return
aTypes
.
includes
(
getExternalType
(
install
.
type
)
)
;
}
)
;
}
return
results
.
map
(
install
=
>
install
.
wrapper
)
;
}
addonChanged
(
aId
aType
)
{
if
(
!
isTheme
(
aType
)
)
return
;
let
addons
=
XPIDatabase
.
getAddonsByType
(
"
webextension
-
theme
"
)
;
for
(
let
theme
of
addons
)
{
if
(
theme
.
visible
&
&
theme
.
id
!
=
aId
)
this
.
updateAddonDisabledState
(
theme
true
undefined
true
)
;
}
if
(
!
aId
&
&
(
!
LightweightThemeManager
.
currentTheme
|
|
LightweightThemeManager
.
currentTheme
!
=
=
DEFAULT_THEME_ID
)
)
{
let
theme
=
LightweightThemeManager
.
getUsedTheme
(
DEFAULT_THEME_ID
)
;
if
(
theme
)
{
LightweightThemeManager
.
currentTheme
=
theme
;
}
}
}
updateAddonAppDisabledStates
(
)
{
let
addons
=
XPIDatabase
.
getAddons
(
)
;
for
(
let
addon
of
addons
)
{
this
.
updateAddonDisabledState
(
addon
)
;
}
}
async
updateAddonRepositoryData
(
)
{
let
addons
=
await
XPIDatabase
.
getVisibleAddons
(
null
)
;
logger
.
debug
(
"
updateAddonRepositoryData
found
"
+
addons
.
length
+
"
visible
add
-
ons
"
)
;
await
Promise
.
all
(
addons
.
map
(
addon
=
>
AddonRepository
.
getCachedAddonByID
(
addon
.
id
)
.
then
(
aRepoAddon
=
>
{
if
(
aRepoAddon
|
|
AddonRepository
.
getCompatibilityOverridesSync
(
addon
.
id
)
)
{
logger
.
debug
(
"
updateAddonRepositoryData
got
info
for
"
+
addon
.
id
)
;
addon
.
_repositoryAddon
=
aRepoAddon
;
this
.
updateAddonDisabledState
(
addon
)
;
}
}
)
)
)
;
}
onDebugConnectionChange
(
{
what
connection
}
)
{
if
(
what
!
=
"
opened
"
)
return
;
for
(
let
[
id
val
]
of
this
.
activeAddons
)
{
connection
.
setAddonOptions
(
id
{
global
:
val
.
bootstrapScope
}
)
;
}
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
NOTIFICATION_FLUSH_PERMISSIONS
)
{
if
(
!
aData
|
|
aData
=
=
XPI_PERMISSION
)
{
this
.
importPermissions
(
)
;
}
return
;
}
else
if
(
aTopic
=
=
NOTIFICATION_TOOLBOX_CONNECTION_CHANGE
)
{
this
.
onDebugConnectionChange
(
aSubject
.
wrappedJSObject
)
;
return
;
}
if
(
aTopic
=
=
"
nsPref
:
changed
"
)
{
switch
(
aData
)
{
case
PREF_EM_MIN_COMPAT_APP_VERSION
:
this
.
minCompatibleAppVersion
=
Services
.
prefs
.
getStringPref
(
PREF_EM_MIN_COMPAT_APP_VERSION
null
)
;
this
.
updateAddonAppDisabledStates
(
)
;
break
;
case
PREF_EM_MIN_COMPAT_PLATFORM_VERSION
:
this
.
minCompatiblePlatformVersion
=
Services
.
prefs
.
getStringPref
(
PREF_EM_MIN_COMPAT_PLATFORM_VERSION
null
)
;
this
.
updateAddonAppDisabledStates
(
)
;
break
;
case
PREF_XPI_SIGNATURES_REQUIRED
:
case
PREF_LANGPACK_SIGNATURES
:
case
PREF_ALLOW_LEGACY
:
this
.
updateAddonAppDisabledStates
(
)
;
break
;
}
}
}
loadBootstrapScope
(
aId
aFile
aVersion
aType
aRunInSafeMode
aDependencies
hasEmbeddedWebExtension
)
{
this
.
activeAddons
.
set
(
aId
{
bootstrapScope
:
null
instanceID
:
Symbol
(
aId
)
started
:
false
}
)
;
this
.
addAddonsToCrashReporter
(
)
;
let
activeAddon
=
this
.
activeAddons
.
get
(
aId
)
;
logger
.
debug
(
"
Loading
bootstrap
scope
from
"
+
aFile
.
path
)
;
let
principal
=
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
;
if
(
!
aFile
.
exists
(
)
)
{
activeAddon
.
bootstrapScope
=
new
Cu
.
Sandbox
(
principal
{
sandboxName
:
aFile
.
path
addonId
:
aId
wantGlobalProperties
:
[
"
ChromeUtils
"
]
metadata
:
{
addonID
:
aId
}
}
)
;
logger
.
error
(
"
Attempted
to
load
bootstrap
scope
from
missing
directory
"
+
aFile
.
path
)
;
return
;
}
if
(
isWebExtension
(
aType
)
)
{
activeAddon
.
bootstrapScope
=
Extension
.
getBootstrapScope
(
aId
aFile
)
;
}
else
if
(
aType
=
=
=
"
webextension
-
langpack
"
)
{
activeAddon
.
bootstrapScope
=
Langpack
.
getBootstrapScope
(
aId
aFile
)
;
}
else
{
let
uri
=
getURIForResourceInFile
(
aFile
"
bootstrap
.
js
"
)
.
spec
;
if
(
aType
=
=
"
dictionary
"
)
uri
=
"
resource
:
/
/
gre
/
modules
/
addons
/
SpellCheckDictionaryBootstrap
.
js
"
;
activeAddon
.
bootstrapScope
=
new
Cu
.
Sandbox
(
principal
{
sandboxName
:
uri
addonId
:
aId
wantGlobalProperties
:
[
"
ChromeUtils
"
]
metadata
:
{
addonID
:
aId
URI
:
uri
}
}
)
;
try
{
for
(
let
name
in
BOOTSTRAP_REASONS
)
activeAddon
.
bootstrapScope
[
name
]
=
BOOTSTRAP_REASONS
[
name
]
;
Object
.
assign
(
activeAddon
.
bootstrapScope
{
Worker
ChromeWorker
}
)
;
XPCOMUtils
.
defineLazyGetter
(
activeAddon
.
bootstrapScope
"
console
"
(
)
=
>
new
ConsoleAPI
(
{
consoleID
:
"
addon
/
"
+
aId
}
)
)
;
activeAddon
.
bootstrapScope
.
__SCRIPT_URI_SPEC__
=
uri
;
Services
.
scriptloader
.
loadSubScript
(
uri
activeAddon
.
bootstrapScope
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Error
loading
bootstrap
.
js
for
"
+
aId
e
)
;
}
}
let
wrappedJSObject
=
{
id
:
aId
options
:
{
global
:
activeAddon
.
bootstrapScope
}
}
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
}
"
toolbox
-
update
-
addon
-
options
"
)
;
}
unloadBootstrapScope
(
aId
)
{
this
.
activeAddons
.
delete
(
aId
)
;
this
.
addAddonsToCrashReporter
(
)
;
let
wrappedJSObject
=
{
id
:
aId
options
:
{
global
:
null
}
}
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
}
"
toolbox
-
update
-
addon
-
options
"
)
;
}
callBootstrapMethod
(
aAddon
aFile
aMethod
aReason
aExtraParams
)
{
if
(
!
aAddon
.
id
|
|
!
aAddon
.
version
|
|
!
aAddon
.
type
)
{
throw
new
Error
(
"
aAddon
must
include
an
id
version
and
type
"
)
;
}
let
runInSafeMode
=
"
runInSafeMode
"
in
aAddon
?
aAddon
.
runInSafeMode
:
canRunInSafeMode
(
aAddon
)
;
if
(
Services
.
appinfo
.
inSafeMode
&
&
!
runInSafeMode
)
return
;
let
timeStart
=
new
Date
(
)
;
if
(
CHROME_TYPES
.
has
(
aAddon
.
type
)
&
&
aMethod
=
=
"
startup
"
)
{
logger
.
debug
(
"
Registering
manifest
for
"
+
aFile
.
path
)
;
Components
.
manager
.
addBootstrappedManifestLocation
(
aFile
)
;
}
try
{
let
activeAddon
=
this
.
activeAddons
.
get
(
aAddon
.
id
)
;
if
(
!
activeAddon
)
{
this
.
loadBootstrapScope
(
aAddon
.
id
aFile
aAddon
.
version
aAddon
.
type
runInSafeMode
aAddon
.
dependencies
aAddon
.
hasEmbeddedWebExtension
|
|
false
)
;
activeAddon
=
this
.
activeAddons
.
get
(
aAddon
.
id
)
;
}
if
(
aMethod
=
=
"
startup
"
|
|
aMethod
=
=
"
shutdown
"
)
{
if
(
!
aExtraParams
)
{
aExtraParams
=
{
}
;
}
aExtraParams
.
instanceID
=
this
.
activeAddons
.
get
(
aAddon
.
id
)
.
instanceID
;
}
let
method
=
undefined
;
let
scope
=
activeAddon
.
bootstrapScope
;
try
{
method
=
scope
[
aMethod
]
|
|
Cu
.
evalInSandbox
(
{
aMethod
}
;
scope
)
;
}
catch
(
e
)
{
}
if
(
aMethod
=
=
"
startup
"
)
{
activeAddon
.
started
=
true
;
}
else
if
(
aMethod
=
=
"
shutdown
"
)
{
activeAddon
.
started
=
false
;
if
(
aReason
!
=
BOOTSTRAP_REASONS
.
APP_SHUTDOWN
)
{
activeAddon
.
disable
=
true
;
for
(
let
addon
of
this
.
getDependentAddons
(
aAddon
)
)
{
if
(
addon
.
active
)
this
.
updateAddonDisabledState
(
addon
)
;
}
}
}
let
installLocation
=
aAddon
.
_installLocation
|
|
null
;
let
params
=
{
id
:
aAddon
.
id
version
:
aAddon
.
version
installPath
:
aFile
.
clone
(
)
resourceURI
:
getURIForResourceInFile
(
aFile
"
"
)
signedState
:
aAddon
.
signedState
temporarilyInstalled
:
installLocation
=
=
TemporaryInstallLocation
}
;
if
(
aMethod
=
=
"
startup
"
&
&
aAddon
.
startupData
)
{
params
.
startupData
=
aAddon
.
startupData
;
}
if
(
aExtraParams
)
{
for
(
let
key
in
aExtraParams
)
{
params
[
key
]
=
aExtraParams
[
key
]
;
}
}
if
(
aAddon
.
hasEmbeddedWebExtension
)
{
let
reason
=
Object
.
keys
(
BOOTSTRAP_REASONS
)
.
find
(
key
=
>
BOOTSTRAP_REASONS
[
key
]
=
=
aReason
)
;
if
(
aMethod
=
=
"
startup
"
)
{
const
webExtension
=
LegacyExtensionsUtils
.
getEmbeddedExtensionFor
(
params
)
;
params
.
webExtension
=
{
startup
:
(
)
=
>
webExtension
.
startup
(
reason
)
}
;
}
else
if
(
aMethod
=
=
"
shutdown
"
)
{
LegacyExtensionsUtils
.
getEmbeddedExtensionFor
(
params
)
.
shutdown
(
reason
)
;
}
}
if
(
!
method
)
{
logger
.
warn
(
"
Add
-
on
"
+
aAddon
.
id
+
"
is
missing
bootstrap
method
"
+
aMethod
)
;
}
else
{
logger
.
debug
(
"
Calling
bootstrap
method
"
+
aMethod
+
"
on
"
+
aAddon
.
id
+
"
version
"
+
aAddon
.
version
)
;
let
result
;
try
{
result
=
method
.
call
(
scope
params
aReason
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Exception
running
bootstrap
method
"
+
aMethod
+
"
on
"
+
aAddon
.
id
e
)
;
}
if
(
aMethod
=
=
"
startup
"
)
{
activeAddon
.
startupPromise
=
Promise
.
resolve
(
result
)
;
activeAddon
.
startupPromise
.
catch
(
Cu
.
reportError
)
;
}
}
}
finally
{
if
(
aMethod
=
=
"
startup
"
&
&
aReason
!
=
BOOTSTRAP_REASONS
.
APP_STARTUP
)
{
for
(
let
addon
of
this
.
getDependentAddons
(
aAddon
)
)
this
.
updateAddonDisabledState
(
addon
)
;
}
if
(
CHROME_TYPES
.
has
(
aAddon
.
type
)
&
&
aMethod
=
=
"
shutdown
"
&
&
aReason
!
=
BOOTSTRAP_REASONS
.
APP_SHUTDOWN
)
{
logger
.
debug
(
"
Removing
manifest
for
"
+
aFile
.
path
)
;
Components
.
manager
.
removeBootstrappedManifestLocation
(
aFile
)
;
}
this
.
setTelemetry
(
aAddon
.
id
aMethod
+
"
_MS
"
new
Date
(
)
-
timeStart
)
;
}
}
updateAddonDisabledState
(
aAddon
aUserDisabled
aSoftDisabled
aBecauseSelecting
)
{
if
(
!
(
aAddon
.
inDatabase
)
)
throw
new
Error
(
"
Can
only
update
addon
states
for
installed
addons
.
"
)
;
if
(
aUserDisabled
!
=
=
undefined
&
&
aSoftDisabled
!
=
=
undefined
)
{
throw
new
Error
(
"
Cannot
change
userDisabled
and
softDisabled
at
the
"
+
"
same
time
"
)
;
}
if
(
aUserDisabled
=
=
=
undefined
)
{
aUserDisabled
=
aAddon
.
userDisabled
;
}
else
if
(
!
aUserDisabled
)
{
aSoftDisabled
=
false
;
}
if
(
aSoftDisabled
=
=
=
undefined
|
|
aUserDisabled
)
aSoftDisabled
=
aAddon
.
softDisabled
;
let
appDisabled
=
!
XPIDatabase
.
isUsableAddon
(
aAddon
)
;
if
(
aAddon
.
userDisabled
=
=
aUserDisabled
&
&
aAddon
.
appDisabled
=
=
appDisabled
&
&
aAddon
.
softDisabled
=
=
aSoftDisabled
)
return
undefined
;
let
wasDisabled
=
aAddon
.
disabled
;
let
isDisabled
=
aUserDisabled
|
|
aSoftDisabled
|
|
appDisabled
;
let
appDisabledChanged
=
aAddon
.
appDisabled
!
=
appDisabled
;
XPIDatabase
.
setAddonProperties
(
aAddon
{
userDisabled
:
aUserDisabled
appDisabled
softDisabled
:
aSoftDisabled
}
)
;
let
wrapper
=
aAddon
.
wrapper
;
if
(
appDisabledChanged
)
{
AddonManagerPrivate
.
callAddonListeners
(
"
onPropertyChanged
"
wrapper
[
"
appDisabled
"
]
)
;
}
if
(
!
aAddon
.
visible
|
|
(
wasDisabled
=
=
isDisabled
)
)
return
undefined
;
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
true
)
;
let
xpiState
=
XPIStates
.
getAddon
(
aAddon
.
location
aAddon
.
id
)
;
if
(
xpiState
)
{
xpiState
.
syncWithDB
(
aAddon
)
;
XPIStates
.
save
(
)
;
}
else
{
logger
.
warn
(
"
No
XPIState
for
{
id
}
in
{
location
}
"
aAddon
)
;
}
if
(
isDisabled
!
=
aAddon
.
active
)
{
AddonManagerPrivate
.
callAddonListeners
(
"
onOperationCancelled
"
wrapper
)
;
}
else
{
if
(
isDisabled
)
{
AddonManagerPrivate
.
callAddonListeners
(
"
onDisabling
"
wrapper
false
)
;
}
else
{
AddonManagerPrivate
.
callAddonListeners
(
"
onEnabling
"
wrapper
false
)
;
}
XPIDatabase
.
updateAddonActive
(
aAddon
!
isDisabled
)
;
if
(
isDisabled
)
{
if
(
aAddon
.
bootstrap
&
&
this
.
activeAddons
.
has
(
aAddon
.
id
)
)
{
this
.
callBootstrapMethod
(
aAddon
aAddon
.
_sourceBundle
"
shutdown
"
BOOTSTRAP_REASONS
.
ADDON_DISABLE
)
;
this
.
unloadBootstrapScope
(
aAddon
.
id
)
;
}
AddonManagerPrivate
.
callAddonListeners
(
"
onDisabled
"
wrapper
)
;
}
else
{
if
(
aAddon
.
bootstrap
)
{
this
.
callBootstrapMethod
(
aAddon
aAddon
.
_sourceBundle
"
startup
"
BOOTSTRAP_REASONS
.
ADDON_ENABLE
)
;
}
AddonManagerPrivate
.
callAddonListeners
(
"
onEnabled
"
wrapper
)
;
}
}
if
(
isTheme
(
aAddon
.
type
)
)
{
if
(
!
isDisabled
)
{
AddonManagerPrivate
.
notifyAddonChanged
(
aAddon
.
id
aAddon
.
type
)
;
if
(
xpiState
)
{
xpiState
.
syncWithDB
(
aAddon
)
;
XPIStates
.
save
(
)
;
}
}
else
if
(
isDisabled
&
&
!
aBecauseSelecting
)
{
AddonManagerPrivate
.
notifyAddonChanged
(
null
"
theme
"
)
;
}
}
return
isDisabled
;
}
}
;
for
(
let
meth
of
[
"
cancelUninstallAddon
"
"
getInstallForFile
"
"
getInstallForURL
"
"
installAddonFromLocation
"
"
installAddonFromSources
"
"
installTemporaryAddon
"
"
isInstallAllowed
"
"
uninstallAddon
"
"
updateSystemAddons
"
]
)
{
XPIProvider
[
meth
]
=
function
(
)
{
return
XPIInstall
[
meth
]
(
.
.
.
arguments
)
;
}
;
}
function
forwardInstallMethods
(
cls
methods
)
{
for
(
let
meth
of
methods
)
{
cls
.
prototype
[
meth
]
=
function
(
)
{
return
XPIInstall
[
cls
.
name
]
.
prototype
[
meth
]
.
apply
(
this
arguments
)
;
}
;
}
}
class
DirectoryInstallLocation
{
constructor
(
aName
aDirectory
aScope
)
{
this
.
_name
=
aName
;
this
.
locked
=
true
;
this
.
_directory
=
aDirectory
;
this
.
_scope
=
aScope
;
this
.
_IDToFileMap
=
{
}
;
this
.
_linkedAddons
=
[
]
;
this
.
isSystem
=
(
aName
=
=
KEY_APP_SYSTEM_ADDONS
|
|
aName
=
=
KEY_APP_SYSTEM_DEFAULTS
)
;
if
(
!
aDirectory
|
|
!
aDirectory
.
exists
(
)
)
return
;
if
(
!
aDirectory
.
isDirectory
(
)
)
throw
new
Error
(
"
Location
must
be
a
directory
.
"
)
;
this
.
initialized
=
false
;
}
get
path
(
)
{
return
this
.
_directory
&
&
this
.
_directory
.
path
;
}
_readDirectoryFromFile
(
aFile
)
{
let
linkedDirectory
;
if
(
aFile
.
isSymlink
(
)
)
{
linkedDirectory
=
aFile
.
clone
(
)
;
try
{
linkedDirectory
.
normalize
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Symbolic
link
"
+
aFile
.
path
+
"
points
to
a
path
"
+
"
which
does
not
exist
"
)
;
return
null
;
}
}
else
{
let
fis
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fis
.
init
(
aFile
-
1
-
1
false
)
;
let
line
=
{
value
:
"
"
}
;
if
(
fis
instanceof
Ci
.
nsILineInputStream
)
fis
.
readLine
(
line
)
;
fis
.
close
(
)
;
if
(
line
.
value
)
{
linkedDirectory
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
try
{
linkedDirectory
.
initWithPath
(
line
.
value
)
;
}
catch
(
e
)
{
linkedDirectory
.
setRelativeDescriptor
(
aFile
.
parent
line
.
value
)
;
}
}
}
if
(
linkedDirectory
)
{
if
(
!
linkedDirectory
.
exists
(
)
)
{
logger
.
warn
(
"
File
pointer
"
+
aFile
.
path
+
"
points
to
"
+
linkedDirectory
.
path
+
"
which
does
not
exist
"
)
;
return
null
;
}
if
(
!
linkedDirectory
.
isDirectory
(
)
)
{
logger
.
warn
(
"
File
pointer
"
+
aFile
.
path
+
"
points
to
"
+
linkedDirectory
.
path
+
"
which
is
not
a
directory
"
)
;
return
null
;
}
return
linkedDirectory
;
}
logger
.
warn
(
"
File
pointer
"
+
aFile
.
path
+
"
does
not
contain
a
path
"
)
;
return
null
;
}
_readAddons
(
rescan
=
false
)
{
if
(
(
this
.
initialized
&
&
!
rescan
)
|
|
!
this
.
_directory
)
{
return
;
}
this
.
initialized
=
true
;
let
entries
=
getDirectoryEntries
(
this
.
_directory
)
;
for
(
let
entry
of
entries
)
{
let
id
=
entry
.
leafName
;
if
(
id
=
=
DIR_STAGE
|
|
id
=
=
DIR_TRASH
)
continue
;
let
directLoad
=
false
;
if
(
entry
.
isFile
(
)
&
&
id
.
substring
(
id
.
length
-
4
)
.
toLowerCase
(
)
=
=
"
.
xpi
"
)
{
directLoad
=
true
;
id
=
id
.
substring
(
0
id
.
length
-
4
)
;
}
if
(
!
gIDTest
.
test
(
id
)
)
{
logger
.
debug
(
"
Ignoring
file
entry
whose
name
is
not
a
valid
add
-
on
ID
:
"
+
entry
.
path
)
;
continue
;
}
if
(
!
directLoad
&
&
(
entry
.
isFile
(
)
|
|
entry
.
isSymlink
(
)
)
)
{
let
newEntry
=
this
.
_readDirectoryFromFile
(
entry
)
;
if
(
!
newEntry
)
{
logger
.
debug
(
"
Deleting
stale
pointer
file
"
+
entry
.
path
)
;
try
{
entry
.
remove
(
true
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
remove
stale
pointer
file
"
+
entry
.
path
e
)
;
}
continue
;
}
entry
=
newEntry
;
this
.
_linkedAddons
.
push
(
id
)
;
}
this
.
_IDToFileMap
[
id
]
=
entry
;
}
}
get
name
(
)
{
return
this
.
_name
;
}
get
scope
(
)
{
return
this
.
_scope
;
}
getAddonLocations
(
rescan
=
false
)
{
this
.
_readAddons
(
rescan
)
;
let
locations
=
new
Map
(
)
;
for
(
let
id
in
this
.
_IDToFileMap
)
{
locations
.
set
(
id
this
.
_IDToFileMap
[
id
]
.
clone
(
)
)
;
}
return
locations
;
}
getLocationForID
(
aId
)
{
if
(
!
(
aId
in
this
.
_IDToFileMap
)
)
this
.
_readAddons
(
)
;
if
(
aId
in
this
.
_IDToFileMap
)
return
this
.
_IDToFileMap
[
aId
]
.
clone
(
)
;
throw
new
Error
(
"
Unknown
add
-
on
ID
"
+
aId
)
;
}
isLinkedAddon
(
aId
)
{
return
this
.
_linkedAddons
.
includes
(
aId
)
;
}
}
class
MutableDirectoryInstallLocation
extends
DirectoryInstallLocation
{
constructor
(
aName
aDirectory
aScope
)
{
super
(
aName
aDirectory
aScope
)
;
this
.
locked
=
false
;
this
.
_stagingDirLock
=
0
;
}
}
forwardInstallMethods
(
MutableDirectoryInstallLocation
[
"
cleanStagingDir
"
"
getStagingDir
"
"
getTrashDir
"
"
installAddon
"
"
releaseStagingDir
"
"
requestStagingDir
"
"
uninstallAddon
"
]
)
;
class
BuiltInInstallLocation
extends
DirectoryInstallLocation
{
_readAddons
(
)
{
let
manifest
;
try
{
let
url
=
Services
.
io
.
newURI
(
BUILT_IN_ADDONS_URI
)
;
let
data
=
Cu
.
readUTF8URI
(
url
)
;
manifest
=
JSON
.
parse
(
data
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
List
of
valid
built
-
in
add
-
ons
could
not
be
parsed
.
"
e
)
;
return
;
}
if
(
!
(
"
system
"
in
manifest
)
)
{
logger
.
warn
(
"
No
list
of
valid
system
add
-
ons
found
.
"
)
;
return
;
}
for
(
let
id
of
manifest
.
system
)
{
let
file
=
new
FileUtils
.
File
(
this
.
_directory
.
path
)
;
file
.
append
(
{
id
}
.
xpi
)
;
if
(
!
AppConstants
.
MOZILLA_OFFICIAL
&
&
!
file
.
exists
(
)
)
{
file
=
new
FileUtils
.
File
(
this
.
_directory
.
path
)
;
file
.
append
(
{
id
}
)
;
}
this
.
_IDToFileMap
[
id
]
=
file
;
}
}
}
class
SystemAddonInstallLocation
extends
MutableDirectoryInstallLocation
{
constructor
(
aName
aDirectory
aScope
aResetSet
)
{
let
addonSet
=
SystemAddonInstallLocation
.
_loadAddonSet
(
)
;
let
directory
=
null
;
if
(
addonSet
.
directory
)
{
directory
=
getFile
(
addonSet
.
directory
aDirectory
)
;
logger
.
info
(
"
SystemAddonInstallLocation
scanning
directory
"
+
directory
.
path
)
;
}
else
{
logger
.
info
(
"
SystemAddonInstallLocation
directory
is
missing
"
)
;
}
super
(
aName
directory
aScope
)
;
this
.
_addonSet
=
addonSet
;
this
.
_baseDir
=
aDirectory
;
this
.
_nextDir
=
null
;
this
.
_directory
=
directory
;
this
.
_stagingDirLock
=
0
;
if
(
aResetSet
)
{
this
.
resetAddonSet
(
)
;
}
this
.
locked
=
false
;
}
static
_loadAddonSet
(
)
{
try
{
let
setStr
=
Services
.
prefs
.
getStringPref
(
PREF_SYSTEM_ADDON_SET
null
)
;
if
(
setStr
)
{
let
addonSet
=
JSON
.
parse
(
setStr
)
;
if
(
(
typeof
addonSet
=
=
"
object
"
)
&
&
addonSet
.
schema
=
=
1
)
{
return
addonSet
;
}
}
}
catch
(
e
)
{
logger
.
error
(
"
Malformed
system
add
-
on
set
resetting
.
"
)
;
}
return
{
schema
:
1
addons
:
{
}
}
;
}
getAddonLocations
(
)
{
if
(
Services
.
appinfo
.
inSafeMode
)
{
return
new
Map
(
)
;
}
let
addons
=
super
.
getAddonLocations
(
)
;
for
(
let
id
of
addons
.
keys
(
)
)
{
if
(
!
(
id
in
this
.
_addonSet
.
addons
)
)
{
addons
.
delete
(
id
)
;
}
}
return
addons
;
}
isActive
(
)
{
return
this
.
_directory
!
=
null
;
}
}
forwardInstallMethods
(
SystemAddonInstallLocation
[
"
cleanDirectories
"
"
cleanStagingDir
"
"
getStagingDir
"
"
getTrashDir
"
"
installAddon
"
"
installAddon
"
"
installAddonSet
"
"
isValid
"
"
isValidAddon
"
"
releaseStagingDir
"
"
requestStagingDir
"
"
resetAddonSet
"
"
resumeAddonSet
"
"
uninstallAddon
"
"
uninstallAddon
"
]
)
;
const
TemporaryInstallLocation
=
{
locked
:
false
name
:
KEY_APP_TEMPORARY
scope
:
AddonManager
.
SCOPE_TEMPORARY
getAddonLocations
:
(
)
=
>
[
]
isLinkedAddon
:
(
)
=
>
false
installAddon
:
(
)
=
>
{
}
uninstallAddon
:
(
aAddon
)
=
>
{
}
getStagingDir
:
(
)
=
>
{
}
}
;
class
WinRegInstallLocation
extends
DirectoryInstallLocation
{
constructor
(
aName
aRootKey
aScope
)
{
super
(
aName
undefined
aScope
)
;
this
.
locked
=
true
;
this
.
_name
=
aName
;
this
.
_rootKey
=
aRootKey
;
this
.
_scope
=
aScope
;
this
.
_IDToFileMap
=
{
}
;
let
path
=
this
.
_appKeyPath
+
"
\
\
Extensions
"
;
let
key
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
try
{
key
.
open
(
this
.
_rootKey
path
Ci
.
nsIWindowsRegKey
.
ACCESS_READ
)
;
}
catch
(
e
)
{
return
;
}
this
.
_readAddons
(
key
)
;
key
.
close
(
)
;
}
get
_appKeyPath
(
)
{
let
appVendor
=
Services
.
appinfo
.
vendor
;
let
appName
=
Services
.
appinfo
.
name
;
if
(
AppConstants
.
MOZ_APP_NAME
=
=
"
thunderbird
"
&
&
appVendor
=
=
"
"
)
appVendor
=
"
Mozilla
"
;
if
(
appVendor
!
=
"
"
)
appVendor
+
=
"
\
\
"
;
return
"
SOFTWARE
\
\
"
+
appVendor
+
appName
;
}
_readAddons
(
aKey
)
{
let
count
=
aKey
.
valueCount
;
for
(
let
i
=
0
;
i
<
count
;
+
+
i
)
{
let
id
=
aKey
.
getValueName
(
i
)
;
let
file
=
new
nsIFile
(
aKey
.
readStringValue
(
id
)
)
;
if
(
!
file
.
exists
(
)
)
{
logger
.
warn
(
"
Ignoring
missing
add
-
on
in
"
+
file
.
path
)
;
continue
;
}
this
.
_IDToFileMap
[
id
]
=
file
;
}
}
get
name
(
)
{
return
this
.
_name
;
}
isLinkedAddon
(
aId
)
{
return
true
;
}
}
var
XPIInternal
=
{
BOOTSTRAP_REASONS
DB_SCHEMA
KEY_APP_SYSTEM_ADDONS
KEY_APP_SYSTEM_DEFAULTS
KEY_APP_TEMPORARY
PREF_BRANCH_INSTALLED_ADDON
PREF_SYSTEM_ADDON_SET
SIGNED_TYPES
SystemAddonInstallLocation
TEMPORARY_ADDON_SUFFIX
TOOLKIT_ID
TemporaryInstallLocation
XPIProvider
XPIStates
XPI_PERMISSION
awaitPromise
canRunInSafeMode
descriptorToPath
getExternalType
getURIForResourceInFile
isTheme
isWebExtension
}
;
var
addonTypes
=
[
new
AddonManagerPrivate
.
AddonType
(
"
extension
"
URI_EXTENSION_STRINGS
"
type
.
extension
.
name
"
AddonManager
.
VIEW_TYPE_LIST
4000
AddonManager
.
TYPE_SUPPORTS_UNDO_RESTARTLESS_UNINSTALL
)
new
AddonManagerPrivate
.
AddonType
(
"
theme
"
URI_EXTENSION_STRINGS
"
type
.
themes
.
name
"
AddonManager
.
VIEW_TYPE_LIST
5000
)
new
AddonManagerPrivate
.
AddonType
(
"
dictionary
"
URI_EXTENSION_STRINGS
"
type
.
dictionary
.
name
"
AddonManager
.
VIEW_TYPE_LIST
7000
AddonManager
.
TYPE_UI_HIDE_EMPTY
|
AddonManager
.
TYPE_SUPPORTS_UNDO_RESTARTLESS_UNINSTALL
)
new
AddonManagerPrivate
.
AddonType
(
"
locale
"
URI_EXTENSION_STRINGS
"
type
.
locale
.
name
"
AddonManager
.
VIEW_TYPE_LIST
8000
AddonManager
.
TYPE_UI_HIDE_EMPTY
|
AddonManager
.
TYPE_SUPPORTS_UNDO_RESTARTLESS_UNINSTALL
)
]
;
AddonManagerPrivate
.
registerProvider
(
XPIProvider
addonTypes
)
;
