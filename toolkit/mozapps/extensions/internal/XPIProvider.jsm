"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
XPIProvider
"
"
XPIInternal
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonRepository
:
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonRepository
.
jsm
"
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
Dictionary
:
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
Extension
:
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
Langpack
:
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
PermissionsUtils
:
"
resource
:
/
/
gre
/
modules
/
PermissionsUtils
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
ConsoleAPI
:
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
JSONFile
:
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
LegacyExtensionsUtils
:
"
resource
:
/
/
gre
/
modules
/
LegacyExtensionsUtils
.
jsm
"
TelemetrySession
:
"
resource
:
/
/
gre
/
modules
/
TelemetrySession
.
jsm
"
XPIDatabase
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIDatabase
.
jsm
"
XPIDatabaseReconcile
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIDatabase
.
jsm
"
XPIInstall
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIInstall
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
aomStartup
:
[
"
mozilla
.
org
/
addons
/
addon
-
manager
-
startup
;
1
"
"
amIAddonManagerStartup
"
]
timerManager
:
[
"
mozilla
.
org
/
updates
/
timer
-
manager
;
1
"
"
nsIUpdateTimerManager
"
]
}
)
;
const
nsIFile
=
Components
.
Constructor
(
"
mozilla
.
org
/
file
/
local
;
1
"
"
nsIFile
"
"
initWithPath
"
)
;
const
FileInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
"
nsIFileInputStream
"
"
init
"
)
;
const
PREF_DB_SCHEMA
=
"
extensions
.
databaseSchema
"
;
const
PREF_XPI_STATE
=
"
extensions
.
xpiState
"
;
const
PREF_BOOTSTRAP_ADDONS
=
"
extensions
.
bootstrappedAddons
"
;
const
PREF_PENDING_OPERATIONS
=
"
extensions
.
pendingOperations
"
;
const
PREF_EM_ENABLED_SCOPES
=
"
extensions
.
enabledScopes
"
;
const
PREF_EM_STARTUP_SCAN_SCOPES
=
"
extensions
.
startupScanScopes
"
;
const
PREF_XPI_SIGNATURES_REQUIRED
=
"
xpinstall
.
signatures
.
required
"
;
const
PREF_LANGPACK_SIGNATURES
=
"
extensions
.
langpacks
.
signatures
.
required
"
;
const
PREF_XPI_PERMISSIONS_BRANCH
=
"
xpinstall
.
"
;
const
PREF_INSTALL_DISTRO_ADDONS
=
"
extensions
.
installDistroAddons
"
;
const
PREF_BRANCH_INSTALLED_ADDON
=
"
extensions
.
installedDistroAddon
.
"
;
const
PREF_SYSTEM_ADDON_SET
=
"
extensions
.
systemAddonSet
"
;
const
PREF_ALLOW_LEGACY
=
"
extensions
.
legacy
.
enabled
"
;
const
PREF_EM_LAST_APP_BUILD_ID
=
"
extensions
.
lastAppBuildId
"
;
const
BUILT_IN_ADDONS_URI
=
"
chrome
:
/
/
browser
/
content
/
built_in_addons
.
json
"
;
const
OBSOLETE_PREFERENCES
=
[
"
extensions
.
bootstrappedAddons
"
"
extensions
.
enabledAddons
"
"
extensions
.
xpiState
"
"
extensions
.
installCache
"
]
;
const
URI_EXTENSION_STRINGS
=
"
chrome
:
/
/
mozapps
/
locale
/
extensions
/
extensions
.
properties
"
;
const
DIR_EXTENSIONS
=
"
extensions
"
;
const
DIR_SYSTEM_ADDONS
=
"
features
"
;
const
DIR_STAGE
=
"
staged
"
;
const
DIR_TRASH
=
"
trash
"
;
const
FILE_XPI_STATES
=
"
addonStartup
.
json
.
lz4
"
;
const
FILE_DATABASE
=
"
extensions
.
json
"
;
const
FILE_RDF_MANIFEST
=
"
install
.
rdf
"
;
const
FILE_WEB_MANIFEST
=
"
manifest
.
json
"
;
const
FILE_XPI_ADDONS_LIST
=
"
extensions
.
ini
"
;
const
KEY_PROFILEDIR
=
"
ProfD
"
;
const
KEY_ADDON_APP_DIR
=
"
XREAddonAppDir
"
;
const
KEY_APP_DISTRIBUTION
=
"
XREAppDist
"
;
const
KEY_APP_FEATURES
=
"
XREAppFeat
"
;
const
KEY_APP_PROFILE
=
"
app
-
profile
"
;
const
KEY_APP_SYSTEM_ADDONS
=
"
app
-
system
-
addons
"
;
const
KEY_APP_SYSTEM_DEFAULTS
=
"
app
-
system
-
defaults
"
;
const
KEY_APP_GLOBAL
=
"
app
-
global
"
;
const
KEY_APP_SYSTEM_LOCAL
=
"
app
-
system
-
local
"
;
const
KEY_APP_SYSTEM_SHARE
=
"
app
-
system
-
share
"
;
const
KEY_APP_SYSTEM_USER
=
"
app
-
system
-
user
"
;
const
KEY_APP_TEMPORARY
=
"
app
-
temporary
"
;
const
TEMPORARY_ADDON_SUFFIX
=
"
temporary
-
addon
"
;
const
STARTUP_MTIME_SCOPES
=
[
KEY_APP_GLOBAL
KEY_APP_SYSTEM_LOCAL
KEY_APP_SYSTEM_SHARE
KEY_APP_SYSTEM_USER
]
;
const
NOTIFICATION_FLUSH_PERMISSIONS
=
"
flush
-
pending
-
permissions
"
;
const
XPI_PERMISSION
=
"
install
"
;
const
TOOLKIT_ID
=
"
toolkit
mozilla
.
org
"
;
const
XPI_SIGNATURE_CHECK_PERIOD
=
24
*
60
*
60
;
XPCOMUtils
.
defineConstant
(
this
"
DB_SCHEMA
"
25
)
;
const
NOTIFICATION_TOOLBOX_CONNECTION_CHANGE
=
"
toolbox
-
connection
-
change
"
;
function
encoded
(
strings
.
.
.
values
)
{
let
result
=
[
]
;
for
(
let
[
i
string
]
of
strings
.
entries
(
)
)
{
result
.
push
(
string
)
;
if
(
i
<
values
.
length
)
result
.
push
(
encodeURIComponent
(
values
[
i
]
)
)
;
}
return
result
.
join
(
"
"
)
;
}
const
BOOTSTRAP_REASONS
=
{
APP_STARTUP
:
1
APP_SHUTDOWN
:
2
ADDON_ENABLE
:
3
ADDON_DISABLE
:
4
ADDON_INSTALL
:
5
ADDON_UNINSTALL
:
6
ADDON_UPGRADE
:
7
ADDON_DOWNGRADE
:
8
}
;
const
TYPE_ALIASES
=
{
"
webextension
"
:
"
extension
"
"
webextension
-
dictionary
"
:
"
dictionary
"
"
webextension
-
langpack
"
:
"
locale
"
"
webextension
-
theme
"
:
"
theme
"
}
;
const
SIGNED_TYPES
=
new
Set
(
[
"
extension
"
"
webextension
"
"
webextension
-
langpack
"
"
webextension
-
theme
"
]
)
;
const
ALL_EXTERNAL_TYPES
=
new
Set
(
[
"
dictionary
"
"
extension
"
"
locale
"
"
theme
"
]
)
;
const
XPI_STARTING
=
"
XPIStarting
"
;
const
XPI_BEFORE_UI_STARTUP
=
"
BeforeFinalUIStartup
"
;
const
XPI_AFTER_UI_STARTUP
=
"
AfterFinalUIStartup
"
;
var
gGlobalScope
=
this
;
var
gIDTest
=
/
^
(
\
{
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
\
}
|
[
a
-
z0
-
9
-
\
.
_
]
*
\
[
a
-
z0
-
9
-
\
.
_
]
+
)
/
i
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
LOGGER_ID
=
"
addons
.
xpi
"
;
var
logger
=
Log
.
repository
.
getLogger
(
LOGGER_ID
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gStartupScanScopes
"
(
)
=
>
{
let
appBuildID
=
Services
.
appinfo
.
appBuildID
;
let
oldAppBuildID
=
Services
.
prefs
.
getCharPref
(
PREF_EM_LAST_APP_BUILD_ID
"
"
)
;
Services
.
prefs
.
setCharPref
(
PREF_EM_LAST_APP_BUILD_ID
appBuildID
)
;
if
(
appBuildID
!
=
=
oldAppBuildID
)
{
return
AddonManager
.
SCOPE_ALL
;
}
return
Services
.
prefs
.
getIntPref
(
PREF_EM_STARTUP_SCAN_SCOPES
0
)
;
}
)
;
function
awaitPromise
(
promise
)
{
let
success
=
undefined
;
let
result
=
null
;
promise
.
then
(
val
=
>
{
success
=
true
;
result
=
val
;
}
val
=
>
{
success
=
false
;
result
=
val
;
}
)
;
Services
.
tm
.
spinEventLoopUntil
(
(
)
=
>
success
!
=
=
undefined
)
;
if
(
!
success
)
throw
result
;
return
result
;
}
function
getFile
(
path
base
=
null
)
{
try
{
return
new
nsIFile
(
path
)
;
}
catch
(
e
)
{
}
let
file
=
base
.
clone
(
)
;
file
.
appendRelativePath
(
path
)
;
return
file
;
}
function
tryGetMtime
(
file
)
{
try
{
return
file
.
clone
(
)
.
lastModifiedTime
;
}
catch
(
e
)
{
return
0
;
}
}
function
getRelativePath
(
file
dir
)
{
if
(
dir
&
&
dir
.
contains
(
file
)
)
{
let
path
=
file
.
getRelativePath
(
dir
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
path
=
path
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
return
path
;
}
return
file
.
path
;
}
function
descriptorToPath
(
descriptor
dir
)
{
try
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
persistentDescriptor
=
descriptor
;
return
getRelativePath
(
file
dir
)
;
}
catch
(
e
)
{
return
null
;
}
}
function
isWebExtension
(
type
)
{
return
type
=
=
"
webextension
"
|
|
type
=
=
"
webextension
-
theme
"
;
}
function
isTheme
(
type
)
{
return
type
=
=
"
theme
"
|
|
TYPE_ALIASES
[
type
]
=
=
"
theme
"
;
}
function
canRunInSafeMode
(
aAddon
)
{
let
location
=
aAddon
.
location
|
|
null
;
if
(
!
location
)
{
return
false
;
}
return
location
.
isTemporary
|
|
location
.
isSystem
;
}
function
getExternalType
(
aType
)
{
if
(
aType
in
TYPE_ALIASES
)
return
TYPE_ALIASES
[
aType
]
;
return
aType
;
}
function
getManifestFileForDir
(
aDir
)
{
let
file
=
getFile
(
FILE_RDF_MANIFEST
aDir
)
;
if
(
file
.
exists
(
)
&
&
file
.
isFile
(
)
)
return
file
;
file
.
leafName
=
FILE_WEB_MANIFEST
;
if
(
file
.
exists
(
)
&
&
file
.
isFile
(
)
)
return
file
;
return
null
;
}
function
getAllAliasesForTypes
(
aTypes
)
{
if
(
!
aTypes
)
return
null
;
let
typeset
=
new
Set
(
aTypes
)
;
for
(
let
alias
of
Object
.
keys
(
TYPE_ALIASES
)
)
{
typeset
.
delete
(
alias
)
;
if
(
typeset
.
has
(
TYPE_ALIASES
[
alias
]
)
)
typeset
.
add
(
alias
)
;
}
return
[
.
.
.
typeset
]
;
}
function
getURIForResourceInFile
(
aFile
aPath
)
{
if
(
!
aFile
.
leafName
.
toLowerCase
(
)
.
endsWith
(
"
.
xpi
"
)
)
{
let
resource
=
aFile
.
clone
(
)
;
if
(
aPath
)
aPath
.
split
(
"
/
"
)
.
forEach
(
part
=
>
resource
.
append
(
part
)
)
;
return
Services
.
io
.
newFileURI
(
resource
)
;
}
return
buildJarURI
(
aFile
aPath
)
;
}
function
buildJarURI
(
aJarfile
aPath
)
{
let
uri
=
Services
.
io
.
newFileURI
(
aJarfile
)
;
uri
=
"
jar
:
"
+
uri
.
spec
+
"
!
/
"
+
aPath
;
return
Services
.
io
.
newURI
(
uri
)
;
}
function
getDirectoryEntries
(
aDir
aSortEntries
)
{
let
dirEnum
;
try
{
dirEnum
=
aDir
.
directoryEntries
.
QueryInterface
(
Ci
.
nsIDirectoryEnumerator
)
;
let
entries
=
[
]
;
while
(
dirEnum
.
hasMoreElements
(
)
)
entries
.
push
(
dirEnum
.
nextFile
)
;
if
(
aSortEntries
)
{
entries
.
sort
(
function
(
a
b
)
{
return
a
.
path
>
b
.
path
?
-
1
:
1
;
}
)
;
}
return
entries
;
}
catch
(
e
)
{
if
(
aDir
.
exists
(
)
)
{
logger
.
warn
(
"
Can
'
t
iterate
directory
"
+
aDir
.
path
e
)
;
}
return
[
]
;
}
finally
{
if
(
dirEnum
)
{
dirEnum
.
close
(
)
;
}
}
}
const
JSON_FIELDS
=
Object
.
freeze
(
[
"
changed
"
"
dependencies
"
"
enabled
"
"
file
"
"
hasEmbeddedWebExtension
"
"
lastModifiedTime
"
"
path
"
"
runInSafeMode
"
"
startupData
"
"
telemetryKey
"
"
type
"
"
version
"
]
)
;
const
BOOTSTRAPPED_FIELDS
=
Object
.
freeze
(
[
"
dependencies
"
"
hasEmbeddedWebExtension
"
"
runInSafeMode
"
"
type
"
"
version
"
]
)
;
class
XPIState
{
constructor
(
location
id
saved
=
{
}
)
{
this
.
location
=
location
;
this
.
id
=
id
;
this
.
type
=
"
extension
"
;
for
(
let
prop
of
JSON_FIELDS
)
{
if
(
prop
in
saved
)
{
this
[
prop
]
=
saved
[
prop
]
;
}
}
if
(
!
this
.
telemetryKey
)
{
this
.
telemetryKey
=
this
.
getTelemetryKey
(
)
;
}
if
(
saved
.
currentModifiedTime
&
&
saved
.
currentModifiedTime
!
=
this
.
lastModifiedTime
)
{
this
.
lastModifiedTime
=
saved
.
currentModifiedTime
;
this
.
changed
=
true
;
}
}
static
migrate
(
location
id
saved
bootstrapped
)
{
let
data
=
{
enabled
:
saved
.
e
path
:
descriptorToPath
(
saved
.
d
location
.
dir
)
lastModifiedTime
:
saved
.
mt
|
|
saved
.
st
version
:
saved
.
v
}
;
if
(
bootstrapped
)
{
data
.
enabled
=
true
;
data
.
path
=
descriptorToPath
(
bootstrapped
.
descriptor
location
.
dir
)
;
for
(
let
field
of
BOOTSTRAPPED_FIELDS
)
{
if
(
field
in
bootstrapped
)
{
data
[
field
]
=
bootstrapped
[
field
]
;
}
}
}
return
new
XPIState
(
location
id
data
)
;
}
get
mtime
(
)
{
return
this
.
lastModifiedTime
;
}
get
active
(
)
{
return
this
.
enabled
;
}
get
path
(
)
{
return
this
.
file
&
&
this
.
file
.
path
;
}
set
path
(
path
)
{
this
.
file
=
getFile
(
path
this
.
location
.
dir
)
;
}
get
relativePath
(
)
{
if
(
this
.
location
.
dir
&
&
this
.
location
.
dir
.
contains
(
this
.
file
)
)
{
let
path
=
this
.
file
.
getRelativePath
(
this
.
location
.
dir
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
path
=
path
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
return
path
;
}
return
this
.
path
;
}
toJSON
(
)
{
let
json
=
{
enabled
:
this
.
enabled
lastModifiedTime
:
this
.
lastModifiedTime
path
:
this
.
relativePath
version
:
this
.
version
telemetryKey
:
this
.
telemetryKey
}
;
if
(
this
.
type
!
=
"
extension
"
)
{
json
.
type
=
this
.
type
;
}
json
.
dependencies
=
this
.
dependencies
;
json
.
runInSafeMode
=
this
.
runInSafeMode
;
json
.
hasEmbeddedWebExtension
=
this
.
hasEmbeddedWebExtension
;
if
(
this
.
startupData
)
{
json
.
startupData
=
this
.
startupData
;
}
return
json
;
}
getModTime
(
aFile
aId
)
{
let
mtime
=
(
aFile
.
leafName
.
toLowerCase
(
)
.
endsWith
(
"
.
xpi
"
)
?
tryGetMtime
(
aFile
)
:
tryGetMtime
(
getManifestFileForDir
(
aFile
)
)
)
;
if
(
!
mtime
)
{
logger
.
warn
(
"
Can
'
t
get
modified
time
of
{
file
}
"
{
file
:
aFile
.
path
}
)
;
}
this
.
changed
=
mtime
!
=
this
.
lastModifiedTime
;
this
.
lastModifiedTime
=
mtime
;
return
this
.
changed
;
}
getTelemetryKey
(
)
{
return
encoded
{
this
.
id
}
:
{
this
.
version
}
;
}
syncWithDB
(
aDBAddon
aUpdated
=
false
)
{
logger
.
debug
(
"
Updating
XPIState
for
"
+
JSON
.
stringify
(
aDBAddon
)
)
;
let
mustGetMod
=
(
aDBAddon
.
visible
&
&
!
aDBAddon
.
disabled
&
&
!
this
.
enabled
)
;
this
.
enabled
=
aDBAddon
.
visible
&
&
!
aDBAddon
.
disabled
;
this
.
version
=
aDBAddon
.
version
;
this
.
type
=
aDBAddon
.
type
;
if
(
aDBAddon
.
startupData
)
{
this
.
startupData
=
aDBAddon
.
startupData
;
}
this
.
telemetryKey
=
this
.
getTelemetryKey
(
)
;
this
.
hasEmbeddedWebExtension
=
aDBAddon
.
hasEmbeddedWebExtension
;
this
.
dependencies
=
aDBAddon
.
dependencies
;
this
.
runInSafeMode
=
canRunInSafeMode
(
aDBAddon
)
;
if
(
aUpdated
|
|
mustGetMod
)
{
this
.
getModTime
(
this
.
file
aDBAddon
.
id
)
;
if
(
this
.
lastModifiedTime
!
=
aDBAddon
.
updateDate
)
{
aDBAddon
.
updateDate
=
this
.
lastModifiedTime
;
if
(
XPIDatabase
.
initialized
)
{
XPIDatabase
.
saveChanges
(
)
;
}
}
}
}
}
class
XPIStateLocation
extends
Map
{
constructor
(
name
path
scope
saved
)
{
super
(
)
;
this
.
name
=
name
;
this
.
scope
=
scope
;
if
(
path
instanceof
Ci
.
nsIFile
)
{
this
.
dir
=
path
;
this
.
path
=
path
.
path
;
}
else
{
this
.
path
=
path
;
this
.
dir
=
this
.
path
&
&
new
nsIFile
(
this
.
path
)
;
}
this
.
staged
=
{
}
;
this
.
changed
=
false
;
if
(
saved
)
{
this
.
restore
(
saved
)
;
}
this
.
_installler
=
undefined
;
}
get
installer
(
)
{
if
(
this
.
_installer
=
=
=
undefined
)
{
this
.
_installer
=
this
.
makeInstaller
(
)
;
}
return
this
.
_installer
;
}
makeInstaller
(
)
{
return
null
;
}
restore
(
saved
)
{
if
(
!
this
.
path
&
&
saved
.
path
)
{
this
.
path
=
saved
.
path
;
this
.
dir
=
new
nsIFile
(
this
.
path
)
;
}
this
.
staged
=
saved
.
staged
|
|
{
}
;
this
.
changed
=
saved
.
changed
|
|
false
;
for
(
let
[
id
data
]
of
Object
.
entries
(
saved
.
addons
|
|
{
}
)
)
{
let
xpiState
=
this
.
_addState
(
id
data
)
;
if
(
!
this
.
path
|
|
this
.
path
=
=
saved
.
path
)
{
xpiState
.
wasRestored
=
true
;
}
}
}
toJSON
(
)
{
let
json
=
{
addons
:
{
}
staged
:
this
.
staged
}
;
if
(
this
.
path
)
{
json
.
path
=
this
.
path
;
}
if
(
STARTUP_MTIME_SCOPES
.
includes
(
this
.
name
)
)
{
json
.
checkStartupModifications
=
true
;
}
for
(
let
[
id
addon
]
of
this
.
entries
(
)
)
{
json
.
addons
[
id
]
=
addon
;
}
return
json
;
}
get
hasStaged
(
)
{
for
(
let
key
in
this
.
staged
)
{
return
true
;
}
return
false
;
}
_addState
(
addonId
saved
)
{
let
xpiState
=
new
XPIState
(
this
addonId
saved
)
;
this
.
set
(
addonId
xpiState
)
;
return
xpiState
;
}
addAddon
(
addon
)
{
logger
.
debug
(
"
XPIStates
adding
add
-
on
{
id
}
in
{
location
}
:
{
path
}
"
addon
)
;
let
xpiState
=
this
.
_addState
(
addon
.
id
{
file
:
addon
.
_sourceBundle
}
)
;
xpiState
.
syncWithDB
(
addon
true
)
;
XPIProvider
.
setTelemetry
(
addon
.
id
"
location
"
this
.
name
)
;
}
removeAddon
(
aId
)
{
if
(
this
.
has
(
aId
)
)
{
this
.
delete
(
aId
)
;
XPIStates
.
save
(
)
;
}
}
addFile
(
addonId
file
)
{
let
xpiState
=
this
.
_addState
(
addonId
{
enabled
:
false
file
:
file
.
clone
(
)
}
)
;
xpiState
.
getModTime
(
xpiState
.
file
addonId
)
;
return
xpiState
;
}
stageAddon
(
addonId
metadata
)
{
this
.
staged
[
addonId
]
=
metadata
;
XPIStates
.
save
(
)
;
}
unstageAddon
(
addonId
)
{
if
(
addonId
in
this
.
staged
)
{
delete
this
.
staged
[
addonId
]
;
XPIStates
.
save
(
)
;
}
}
*
getStagedAddons
(
)
{
for
(
let
[
id
metadata
]
of
Object
.
entries
(
this
.
staged
)
)
{
yield
[
id
metadata
]
;
}
}
migrateAddon
(
id
state
bootstrapped
)
{
this
.
set
(
id
XPIState
.
migrate
(
this
id
state
bootstrapped
)
)
;
}
isLinkedAddon
(
aId
)
{
if
(
!
this
.
dir
)
{
return
true
;
}
return
this
.
has
(
aId
)
&
&
!
this
.
dir
.
contains
(
this
.
get
(
aId
)
.
file
)
;
}
get
isTemporary
(
)
{
return
false
;
}
get
isSystem
(
)
{
return
false
;
}
}
class
TemporaryLocation
extends
XPIStateLocation
{
constructor
(
name
)
{
super
(
name
null
null
)
;
this
.
locked
=
false
;
}
makeInstaller
(
)
{
return
{
installAddon
(
)
{
}
uninstallAddon
(
)
{
}
}
;
}
toJSON
(
)
{
return
{
}
;
}
readAddons
(
)
{
return
new
Map
(
)
;
}
get
isTemporary
(
)
{
return
true
;
}
}
var
TemporaryInstallLocation
=
new
TemporaryLocation
(
KEY_APP_TEMPORARY
)
;
class
DirectoryLocation
extends
XPIStateLocation
{
constructor
(
name
dir
scope
locked
=
true
)
{
super
(
name
dir
scope
)
;
this
.
locked
=
locked
;
this
.
initialized
=
false
;
}
makeInstaller
(
)
{
if
(
this
.
locked
)
{
return
null
;
}
return
new
XPIInstall
.
DirectoryInstaller
(
this
)
;
}
_readLinkFile
(
aFile
)
{
let
linkedDirectory
;
if
(
aFile
.
isSymlink
(
)
)
{
linkedDirectory
=
aFile
.
clone
(
)
;
try
{
linkedDirectory
.
normalize
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
Symbolic
link
{
aFile
.
path
}
points
to
a
path
+
which
does
not
exist
)
;
return
null
;
}
}
else
{
let
fis
=
new
FileInputStream
(
aFile
-
1
-
1
false
)
;
let
line
=
{
}
;
fis
.
QueryInterface
(
Ci
.
nsILineInputStream
)
.
readLine
(
line
)
;
fis
.
close
(
)
;
if
(
line
.
value
)
{
linkedDirectory
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
try
{
linkedDirectory
.
initWithPath
(
line
.
value
)
;
}
catch
(
e
)
{
linkedDirectory
.
setRelativeDescriptor
(
aFile
.
parent
line
.
value
)
;
}
}
}
if
(
linkedDirectory
)
{
if
(
!
linkedDirectory
.
exists
(
)
)
{
logger
.
warn
(
File
pointer
{
aFile
.
path
}
points
to
{
linkedDirectory
.
path
}
+
"
which
does
not
exist
"
)
;
return
null
;
}
if
(
!
linkedDirectory
.
isDirectory
(
)
)
{
logger
.
warn
(
File
pointer
{
aFile
.
path
}
points
to
{
linkedDirectory
.
path
}
+
"
which
is
not
a
directory
"
)
;
return
null
;
}
return
linkedDirectory
;
}
logger
.
warn
(
File
pointer
{
aFile
.
path
}
does
not
contain
a
path
)
;
return
null
;
}
readAddons
(
)
{
let
addons
=
new
Map
(
)
;
if
(
!
this
.
dir
)
{
return
addons
;
}
this
.
initialized
=
true
;
let
entries
=
getDirectoryEntries
(
this
.
dir
)
;
for
(
let
entry
of
entries
)
{
let
id
=
entry
.
leafName
;
if
(
id
=
=
DIR_STAGE
|
|
id
=
=
DIR_TRASH
)
continue
;
let
isFile
=
id
.
toLowerCase
(
)
.
endsWith
(
"
.
xpi
"
)
;
if
(
isFile
)
{
id
=
id
.
substring
(
0
id
.
length
-
4
)
;
}
if
(
!
gIDTest
.
test
(
id
)
)
{
logger
.
debug
(
"
Ignoring
file
entry
whose
name
is
not
a
valid
add
-
on
ID
:
"
+
entry
.
path
)
;
continue
;
}
if
(
!
isFile
&
&
(
entry
.
isFile
(
)
|
|
entry
.
isSymlink
(
)
)
)
{
let
newEntry
=
this
.
_readLinkFile
(
entry
)
;
if
(
!
newEntry
)
{
logger
.
debug
(
Deleting
stale
pointer
file
{
entry
.
path
}
)
;
try
{
entry
.
remove
(
true
)
;
}
catch
(
e
)
{
logger
.
warn
(
Failed
to
remove
stale
pointer
file
{
entry
.
path
}
e
)
;
}
continue
;
}
entry
=
newEntry
;
}
addons
.
set
(
id
entry
)
;
}
return
addons
;
}
}
class
BuiltInLocation
extends
DirectoryLocation
{
readAddons
(
)
{
let
addons
=
new
Map
(
)
;
let
manifest
;
try
{
let
url
=
Services
.
io
.
newURI
(
BUILT_IN_ADDONS_URI
)
;
let
data
=
Cu
.
readUTF8URI
(
url
)
;
manifest
=
JSON
.
parse
(
data
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
List
of
valid
built
-
in
add
-
ons
could
not
be
parsed
.
"
e
)
;
return
addons
;
}
if
(
!
(
"
system
"
in
manifest
)
)
{
logger
.
warn
(
"
No
list
of
valid
system
add
-
ons
found
.
"
)
;
return
addons
;
}
for
(
let
id
of
manifest
.
system
)
{
let
file
=
this
.
dir
.
clone
(
)
;
file
.
append
(
{
id
}
.
xpi
)
;
if
(
!
AppConstants
.
MOZILLA_OFFICIAL
&
&
!
file
.
exists
(
)
)
{
file
=
this
.
dir
.
clone
(
)
;
file
.
append
(
{
id
}
)
;
}
addons
.
set
(
id
file
)
;
}
return
addons
;
}
get
isSystem
(
)
{
return
true
;
}
}
class
SystemAddonLocation
extends
DirectoryLocation
{
constructor
(
name
dir
scope
resetSet
)
{
let
addonSet
=
SystemAddonLocation
.
_loadAddonSet
(
)
;
let
directory
=
null
;
if
(
addonSet
.
directory
)
{
directory
=
getFile
(
addonSet
.
directory
dir
)
;
logger
.
info
(
SystemAddonLocation
scanning
directory
{
directory
.
path
}
)
;
}
else
{
logger
.
info
(
"
SystemAddonLocation
directory
is
missing
"
)
;
}
super
(
name
directory
scope
false
)
;
this
.
_addonSet
=
addonSet
;
this
.
_baseDir
=
dir
;
if
(
resetSet
)
{
this
.
installer
.
resetAddonSet
(
)
;
}
}
makeInstaller
(
)
{
if
(
this
.
locked
)
{
return
null
;
}
return
new
XPIInstall
.
SystemAddonInstaller
(
this
)
;
}
static
_loadAddonSet
(
)
{
try
{
let
setStr
=
Services
.
prefs
.
getStringPref
(
PREF_SYSTEM_ADDON_SET
null
)
;
if
(
setStr
)
{
let
addonSet
=
JSON
.
parse
(
setStr
)
;
if
(
(
typeof
addonSet
=
=
"
object
"
)
&
&
addonSet
.
schema
=
=
1
)
{
return
addonSet
;
}
}
}
catch
(
e
)
{
logger
.
error
(
"
Malformed
system
add
-
on
set
resetting
.
"
)
;
}
return
{
schema
:
1
addons
:
{
}
}
;
}
readAddons
(
)
{
if
(
Services
.
appinfo
.
inSafeMode
)
{
return
new
Map
(
)
;
}
let
addons
=
super
.
readAddons
(
)
;
for
(
let
id
of
addons
.
keys
(
)
)
{
if
(
!
(
id
in
this
.
_addonSet
.
addons
)
)
{
addons
.
delete
(
id
)
;
}
}
return
addons
;
}
isActive
(
)
{
return
this
.
dir
!
=
null
;
}
get
isSystem
(
)
{
return
true
;
}
}
class
WinRegLocation
extends
XPIStateLocation
{
constructor
(
name
rootKey
scope
)
{
super
(
name
undefined
scope
)
;
this
.
locked
=
true
;
this
.
_rootKey
=
rootKey
;
}
get
_appKeyPath
(
)
{
let
appVendor
=
Services
.
appinfo
.
vendor
;
let
appName
=
Services
.
appinfo
.
name
;
if
(
appVendor
=
=
"
"
&
&
AppConstants
.
MOZ_APP_NAME
=
=
"
thunderbird
"
)
appVendor
=
"
Mozilla
"
;
return
SOFTWARE
\
\
{
appVendor
}
\
\
{
appName
}
;
}
readAddons
(
)
{
let
addons
=
new
Map
(
)
;
let
path
=
{
this
.
_appKeyPath
}
\
\
Extensions
;
let
key
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
try
{
key
.
open
(
this
.
_rootKey
path
Ci
.
nsIWindowsRegKey
.
ACCESS_READ
)
;
}
catch
(
e
)
{
return
addons
;
}
try
{
let
count
=
key
.
valueCount
;
for
(
let
i
=
0
;
i
<
count
;
+
+
i
)
{
let
id
=
key
.
getValueName
(
i
)
;
let
file
=
new
nsIFile
(
key
.
readStringValue
(
id
)
)
;
if
(
!
file
.
exists
(
)
)
{
logger
.
warn
(
Ignoring
missing
add
-
on
in
{
file
.
path
}
)
;
continue
;
}
addons
.
set
(
id
file
)
;
}
}
finally
{
key
.
close
(
)
;
}
return
addons
;
}
}
var
XPIStates
=
{
db
:
new
Map
(
)
_jsonFile
:
null
sideLoadedAddons
:
new
Map
(
)
get
size
(
)
{
let
count
=
0
;
for
(
let
location
of
this
.
locations
(
)
)
{
count
+
=
location
.
size
;
}
return
count
;
}
migrateStateFromPrefs
(
)
{
logger
.
info
(
"
No
addonStartup
.
json
found
.
Attempting
to
migrate
data
from
preferences
"
)
;
let
state
;
let
bootstrappedAddons
;
try
{
state
=
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
PREF_XPI_STATE
)
)
;
bootstrappedAddons
=
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
PREF_BOOTSTRAP_ADDONS
"
{
}
"
)
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Error
parsing
extensions
.
xpiState
and
"
+
"
extensions
.
bootstrappedAddons
:
{
error
}
"
{
error
:
e
}
)
;
}
for
(
let
[
locName
addons
]
of
Object
.
entries
(
state
)
)
{
for
(
let
[
id
addon
]
of
Object
.
entries
(
addons
)
)
{
let
loc
=
this
.
getLocation
(
locName
)
;
if
(
loc
)
{
loc
.
migrateAddon
(
id
addon
bootstrappedAddons
[
id
]
|
|
null
)
;
}
}
}
for
(
let
pref
of
OBSOLETE_PREFERENCES
)
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
OS
.
File
.
remove
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FILE_XPI_ADDONS_LIST
)
)
;
let
data
=
JSON
.
parse
(
JSON
.
stringify
(
this
)
)
;
logger
.
debug
(
"
Migrated
data
:
{
}
"
data
)
;
return
data
;
}
loadExtensionState
(
)
{
let
state
;
try
{
state
=
aomStartup
.
readStartupData
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Error
parsing
extensions
state
:
{
error
}
"
{
error
:
e
}
)
;
}
if
(
!
state
&
&
Services
.
prefs
.
getPrefType
(
PREF_XPI_STATE
)
!
=
Ci
.
nsIPrefBranch
.
PREF_INVALID
)
{
try
{
state
=
this
.
migrateStateFromPrefs
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Error
migrating
extensions
.
xpiState
and
"
+
"
extensions
.
bootstrappedAddons
:
{
error
}
"
{
error
:
e
}
)
;
}
}
logger
.
debug
(
"
Loaded
add
-
on
state
:
{
}
"
state
)
;
return
state
|
|
{
}
;
}
scanForChanges
(
ignoreSideloads
=
true
)
{
let
oldState
=
this
.
initialStateData
|
|
this
.
loadExtensionState
(
)
;
this
.
initialStateData
=
oldState
;
let
changed
=
false
;
let
oldLocations
=
new
Set
(
Object
.
keys
(
oldState
)
)
;
for
(
let
loc
of
XPIStates
.
locations
(
)
)
{
oldLocations
.
delete
(
loc
.
name
)
;
if
(
oldState
[
loc
.
name
]
)
{
loc
.
restore
(
oldState
[
loc
.
name
]
)
;
}
changed
=
changed
|
|
loc
.
changed
;
if
(
ignoreSideloads
&
&
!
(
loc
.
scope
&
gStartupScanScopes
)
)
{
continue
;
}
if
(
loc
.
isTemporary
)
{
continue
;
}
let
knownIds
=
new
Set
(
loc
.
keys
(
)
)
;
for
(
let
[
id
file
]
of
loc
.
readAddons
(
)
)
{
knownIds
.
delete
(
id
)
;
let
xpiState
=
loc
.
get
(
id
)
;
if
(
!
xpiState
)
{
logger
.
debug
(
"
New
add
-
on
{
id
}
in
{
loc
}
"
{
id
loc
:
loc
.
name
}
)
;
changed
=
true
;
xpiState
=
loc
.
addFile
(
id
file
)
;
if
(
!
loc
.
isSystem
)
{
this
.
sideLoadedAddons
.
set
(
id
xpiState
)
;
}
}
else
{
let
addonChanged
=
(
xpiState
.
getModTime
(
file
id
)
|
|
file
.
path
!
=
xpiState
.
path
)
;
xpiState
.
file
=
file
.
clone
(
)
;
if
(
addonChanged
)
{
changed
=
true
;
logger
.
debug
(
"
Changed
add
-
on
{
id
}
in
{
loc
}
"
{
id
loc
:
loc
.
name
}
)
;
}
else
{
logger
.
debug
(
"
Existing
add
-
on
{
id
}
in
{
loc
}
"
{
id
loc
:
loc
.
name
}
)
;
}
}
XPIProvider
.
setTelemetry
(
id
"
location
"
loc
.
name
)
;
}
for
(
let
id
of
knownIds
)
{
loc
.
delete
(
id
)
;
changed
=
true
;
}
}
changed
=
changed
|
|
oldLocations
.
size
>
0
;
logger
.
debug
(
"
scanForChanges
changed
:
{
rv
}
state
:
{
state
}
"
{
rv
:
changed
state
:
this
.
db
}
)
;
return
changed
;
}
locations
(
)
{
return
this
.
db
.
values
(
)
;
}
addLocation
(
name
location
)
{
if
(
this
.
db
.
has
(
name
)
)
{
throw
new
Error
(
Trying
to
add
duplicate
location
:
{
name
}
)
;
}
this
.
db
.
set
(
name
location
)
;
}
getLocation
(
name
)
{
return
this
.
db
.
get
(
name
)
;
}
getAddon
(
aLocation
aId
)
{
let
location
=
this
.
db
.
get
(
aLocation
)
;
return
location
&
&
location
.
get
(
aId
)
;
}
findAddon
(
aId
aFilter
=
location
=
>
true
)
{
for
(
let
location
of
this
.
locations
(
)
)
{
if
(
!
aFilter
(
location
)
)
{
continue
;
}
if
(
location
.
has
(
aId
)
)
{
return
location
.
get
(
aId
)
;
}
}
return
undefined
;
}
*
enabledAddons
(
)
{
for
(
let
location
of
this
.
locations
(
)
)
{
for
(
let
entry
of
location
.
values
(
)
)
{
if
(
entry
.
enabled
)
{
yield
entry
;
}
}
}
}
addAddon
(
aAddon
)
{
aAddon
.
location
.
addAddon
(
aAddon
)
;
}
save
(
)
{
if
(
!
this
.
_jsonFile
)
{
this
.
_jsonFile
=
new
JSONFile
(
{
path
:
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FILE_XPI_STATES
)
finalizeAt
:
AddonManager
.
shutdown
compression
:
"
lz4
"
}
)
;
this
.
_jsonFile
.
data
=
this
;
}
this
.
_jsonFile
.
saveSoon
(
)
;
}
toJSON
(
)
{
let
data
=
{
}
;
for
(
let
[
key
loc
]
of
this
.
db
.
entries
(
)
)
{
if
(
!
loc
.
isTemporary
&
&
(
loc
.
size
|
|
loc
.
hasStaged
)
)
{
data
[
key
]
=
loc
;
}
}
return
data
;
}
removeAddon
(
aLocation
aId
)
{
logger
.
debug
(
Removing
XPIState
for
{
aLocation
}
:
{
aId
}
)
;
let
location
=
this
.
db
.
get
(
aLocation
)
;
if
(
location
)
{
location
.
removeAddon
(
aId
)
;
this
.
save
(
)
;
}
}
disableAddon
(
aId
)
{
logger
.
debug
(
Disabling
XPIState
for
{
aId
}
)
;
let
state
=
this
.
findAddon
(
aId
)
;
if
(
state
)
{
state
.
enabled
=
false
;
}
}
}
;
class
BootstrapScope
{
constructor
(
addon
)
{
if
(
!
addon
.
id
|
|
!
addon
.
version
|
|
!
addon
.
type
)
{
throw
new
Error
(
"
Addon
must
include
an
id
version
and
type
"
)
;
}
this
.
addon
=
addon
;
this
.
instanceID
=
null
;
this
.
scope
=
null
;
this
.
started
=
false
;
}
static
get
(
addon
)
{
let
scope
=
XPIProvider
.
activeAddons
.
get
(
addon
.
id
)
;
if
(
!
scope
)
{
scope
=
new
this
(
addon
)
;
}
return
scope
;
}
get
file
(
)
{
return
this
.
addon
.
file
|
|
this
.
addon
.
_sourceBundle
;
}
get
runInSafeMode
(
)
{
return
"
runInSafeMode
"
in
this
.
addon
?
this
.
addon
.
runInSafeMode
:
canRunInSafeMode
(
this
.
addon
)
;
}
callBootstrapMethod
(
aMethod
aReason
aExtraParams
=
{
}
)
{
let
{
addon
runInSafeMode
}
=
this
;
if
(
Services
.
appinfo
.
inSafeMode
&
&
!
runInSafeMode
)
return
;
let
timeStart
=
new
Date
(
)
;
if
(
addon
.
type
=
=
"
extension
"
&
&
aMethod
=
=
"
startup
"
)
{
logger
.
debug
(
Registering
manifest
for
{
this
.
file
.
path
}
)
;
Components
.
manager
.
addBootstrappedManifestLocation
(
this
.
file
)
;
}
try
{
if
(
!
this
.
scope
)
{
this
.
loadBootstrapScope
(
aReason
)
;
}
if
(
aMethod
=
=
"
startup
"
|
|
aMethod
=
=
"
shutdown
"
)
{
aExtraParams
.
instanceID
=
this
.
instanceID
;
}
let
method
=
undefined
;
let
{
scope
}
=
this
;
try
{
method
=
scope
[
aMethod
]
|
|
Cu
.
evalInSandbox
(
{
aMethod
}
;
scope
)
;
}
catch
(
e
)
{
}
if
(
aMethod
=
=
"
startup
"
)
{
this
.
started
=
true
;
}
else
if
(
aMethod
=
=
"
shutdown
"
)
{
this
.
started
=
false
;
if
(
aReason
!
=
BOOTSTRAP_REASONS
.
APP_SHUTDOWN
)
{
this
.
_pendingDisable
=
true
;
for
(
let
addon
of
XPIProvider
.
getDependentAddons
(
this
.
addon
)
)
{
if
(
addon
.
active
)
XPIDatabase
.
updateAddonDisabledState
(
addon
)
;
}
}
}
let
params
=
{
id
:
addon
.
id
version
:
addon
.
version
installPath
:
this
.
file
.
clone
(
)
resourceURI
:
getURIForResourceInFile
(
this
.
file
"
"
)
signedState
:
addon
.
signedState
temporarilyInstalled
:
addon
.
location
.
isTemporary
builtIn
:
addon
.
location
instanceof
BuiltInLocation
}
;
if
(
aMethod
=
=
"
startup
"
&
&
addon
.
startupData
)
{
params
.
startupData
=
addon
.
startupData
;
}
Object
.
assign
(
params
aExtraParams
)
;
if
(
addon
.
hasEmbeddedWebExtension
)
{
let
reason
=
Object
.
keys
(
BOOTSTRAP_REASONS
)
.
find
(
key
=
>
BOOTSTRAP_REASONS
[
key
]
=
=
aReason
)
;
if
(
aMethod
=
=
"
startup
"
)
{
const
webExtension
=
LegacyExtensionsUtils
.
getEmbeddedExtensionFor
(
params
)
;
params
.
webExtension
=
{
startup
:
(
)
=
>
webExtension
.
startup
(
reason
)
}
;
}
else
if
(
aMethod
=
=
"
shutdown
"
)
{
LegacyExtensionsUtils
.
getEmbeddedExtensionFor
(
params
)
.
shutdown
(
reason
)
;
}
}
if
(
!
method
)
{
logger
.
warn
(
Add
-
on
{
addon
.
id
}
is
missing
bootstrap
method
{
aMethod
}
)
;
}
else
{
logger
.
debug
(
Calling
bootstrap
method
{
aMethod
}
on
{
addon
.
id
}
version
{
addon
.
version
}
)
;
let
result
;
try
{
result
=
method
.
call
(
scope
params
aReason
)
;
}
catch
(
e
)
{
logger
.
warn
(
Exception
running
bootstrap
method
{
aMethod
}
on
{
addon
.
id
}
e
)
;
}
if
(
aMethod
=
=
"
startup
"
)
{
this
.
startupPromise
=
Promise
.
resolve
(
result
)
;
this
.
startupPromise
.
catch
(
Cu
.
reportError
)
;
}
}
}
finally
{
if
(
aMethod
=
=
"
startup
"
&
&
aReason
!
=
BOOTSTRAP_REASONS
.
APP_STARTUP
)
{
for
(
let
addon
of
XPIProvider
.
getDependentAddons
(
this
.
addon
)
)
{
XPIDatabase
.
updateAddonDisabledState
(
addon
)
;
}
}
if
(
addon
.
type
=
=
"
extension
"
&
&
aMethod
=
=
"
shutdown
"
&
&
aReason
!
=
BOOTSTRAP_REASONS
.
APP_SHUTDOWN
)
{
logger
.
debug
(
Removing
manifest
for
{
this
.
file
.
path
}
)
;
Components
.
manager
.
removeBootstrappedManifestLocation
(
this
.
file
)
;
}
XPIProvider
.
setTelemetry
(
addon
.
id
{
aMethod
}
_MS
new
Date
(
)
-
timeStart
)
;
}
}
loadBootstrapScope
(
aReason
)
{
this
.
instanceID
=
Symbol
(
this
.
addon
.
id
)
;
this
.
_pendingDisable
=
false
;
XPIProvider
.
activeAddons
.
set
(
this
.
addon
.
id
this
)
;
if
(
aReason
!
=
=
BOOTSTRAP_REASONS
.
APP_STARTUP
)
{
XPIProvider
.
addAddonsToCrashReporter
(
)
;
}
logger
.
debug
(
Loading
bootstrap
scope
from
{
this
.
file
.
path
}
)
;
let
principal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
if
(
!
this
.
file
.
exists
(
)
)
{
this
.
scope
=
new
Cu
.
Sandbox
(
principal
{
sandboxName
:
this
.
file
.
path
addonId
:
this
.
addon
.
id
wantGlobalProperties
:
[
"
ChromeUtils
"
]
metadata
:
{
addonID
:
this
.
addon
.
id
}
}
)
;
logger
.
error
(
Attempted
to
load
bootstrap
scope
from
missing
directory
{
this
.
file
.
path
}
)
;
return
;
}
if
(
isWebExtension
(
this
.
addon
.
type
)
)
{
this
.
scope
=
Extension
.
getBootstrapScope
(
this
.
addon
.
id
this
.
file
)
;
}
else
if
(
this
.
addon
.
type
=
=
=
"
webextension
-
langpack
"
)
{
this
.
scope
=
Langpack
.
getBootstrapScope
(
this
.
addon
.
id
this
.
file
)
;
}
else
if
(
this
.
addon
.
type
=
=
=
"
webextension
-
dictionary
"
)
{
this
.
scope
=
Dictionary
.
getBootstrapScope
(
this
.
addon
.
id
this
.
file
)
;
}
else
{
let
uri
=
getURIForResourceInFile
(
this
.
file
"
bootstrap
.
js
"
)
.
spec
;
this
.
scope
=
new
Cu
.
Sandbox
(
principal
{
sandboxName
:
uri
addonId
:
this
.
addon
.
id
wantGlobalProperties
:
[
"
ChromeUtils
"
]
metadata
:
{
addonID
:
this
.
addon
.
id
URI
:
uri
}
}
)
;
try
{
for
(
let
name
in
BOOTSTRAP_REASONS
)
this
.
scope
[
name
]
=
BOOTSTRAP_REASONS
[
name
]
;
Object
.
assign
(
this
.
scope
{
Worker
ChromeWorker
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
.
scope
"
console
"
(
)
=
>
new
ConsoleAPI
(
{
consoleID
:
addon
/
{
this
.
addon
.
id
}
}
)
)
;
this
.
scope
.
__SCRIPT_URI_SPEC__
=
uri
;
Services
.
scriptloader
.
loadSubScript
(
uri
this
.
scope
)
;
}
catch
(
e
)
{
logger
.
warn
(
Error
loading
bootstrap
.
js
for
{
this
.
addon
.
id
}
e
)
;
}
}
let
wrappedJSObject
=
{
id
:
this
.
addon
.
id
options
:
{
global
:
this
.
scope
}
}
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
}
"
toolbox
-
update
-
addon
-
options
"
)
;
}
unloadBootstrapScope
(
)
{
XPIProvider
.
activeAddons
.
delete
(
this
.
addon
.
id
)
;
XPIProvider
.
addAddonsToCrashReporter
(
)
;
this
.
scope
=
null
;
this
.
startupPromise
=
null
;
this
.
instanceID
=
null
;
let
wrappedJSObject
=
{
id
:
this
.
addon
.
id
options
:
{
global
:
null
}
}
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
}
"
toolbox
-
update
-
addon
-
options
"
)
;
}
startup
(
reason
aExtraParams
)
{
this
.
callBootstrapMethod
(
"
startup
"
reason
aExtraParams
)
;
}
shutdown
(
reason
aExtraParams
)
{
this
.
callBootstrapMethod
(
"
shutdown
"
reason
aExtraParams
)
;
}
disable
(
)
{
if
(
this
.
started
)
{
this
.
shutdown
(
BOOTSTRAP_REASONS
.
ADDON_DISABLE
)
;
this
.
unloadBootstrapScope
(
)
;
}
}
install
(
reason
=
BOOTSTRAP_REASONS
.
ADDON_INSTALL
startup
extraArgs
)
{
this
.
_install
(
reason
false
startup
extraArgs
)
;
}
_install
(
reason
callUpdate
startup
extraArgs
)
{
if
(
callUpdate
)
{
this
.
callBootstrapMethod
(
"
update
"
reason
extraArgs
)
;
}
else
{
this
.
callBootstrapMethod
(
"
install
"
reason
extraArgs
)
;
}
if
(
startup
&
&
this
.
addon
.
active
)
{
this
.
startup
(
reason
extraArgs
)
;
}
else
if
(
this
.
addon
.
disabled
)
{
this
.
unloadBootstrapScope
(
)
;
}
}
uninstall
(
reason
=
BOOTSTRAP_REASONS
.
ADDON_UNINSTALL
extraArgs
)
{
this
.
_uninstall
(
reason
false
extraArgs
)
;
}
_uninstall
(
reason
callUpdate
extraArgs
)
{
if
(
this
.
started
)
{
this
.
shutdown
(
reason
extraArgs
)
;
}
if
(
!
callUpdate
)
{
this
.
callBootstrapMethod
(
"
uninstall
"
reason
extraArgs
)
;
}
this
.
unloadBootstrapScope
(
)
;
XPIInstall
.
flushJarCache
(
this
.
file
)
;
XPIInstall
.
flushChromeCaches
(
)
;
}
update
(
newAddon
startup
=
false
updateCallback
)
{
let
reason
=
XPIInstall
.
newVersionReason
(
this
.
addon
.
version
newAddon
.
version
)
;
let
extraArgs
=
{
oldVersion
:
this
.
addon
.
version
newVersion
:
newAddon
.
version
}
;
let
callUpdate
=
isWebExtension
(
this
.
addon
.
type
)
&
&
isWebExtension
(
newAddon
.
type
)
;
this
.
_uninstall
(
reason
callUpdate
extraArgs
)
;
if
(
updateCallback
)
{
updateCallback
(
)
;
}
this
.
addon
=
newAddon
;
this
.
_install
(
reason
callUpdate
startup
extraArgs
)
;
}
}
var
XPIProvider
=
{
get
name
(
)
{
return
"
XPIProvider
"
;
}
BOOTSTRAP_REASONS
:
Object
.
freeze
(
BOOTSTRAP_REASONS
)
activeAddons
:
new
Map
(
)
extensionsActive
:
false
newDistroAddons
:
null
runPhase
:
XPI_STARTING
_telemetryDetails
:
{
}
_closing
:
false
get
isDBLoaded
(
)
{
return
(
Object
.
getOwnPropertyDescriptor
(
gGlobalScope
"
XPIDatabase
"
)
.
value
&
&
XPIDatabase
.
initialized
)
|
|
false
;
}
addonIsActive
(
addonId
)
{
let
state
=
XPIStates
.
findAddon
(
addonId
)
;
return
state
&
&
state
.
enabled
;
}
sortBootstrappedAddons
(
)
{
function
compare
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
0
;
}
return
(
a
<
b
)
?
-
1
:
1
;
}
let
list
=
Array
.
from
(
XPIStates
.
enabledAddons
(
)
)
;
list
.
sort
(
(
a
b
)
=
>
compare
(
a
.
id
b
.
id
)
)
;
let
addons
=
{
}
;
for
(
let
entry
of
list
)
{
addons
[
entry
.
id
]
=
entry
;
}
let
res
=
new
Set
(
)
;
let
seen
=
new
Set
(
)
;
let
add
=
addon
=
>
{
seen
.
add
(
addon
.
id
)
;
for
(
let
id
of
addon
.
dependencies
|
|
[
]
)
{
if
(
id
in
addons
&
&
!
seen
.
has
(
id
)
)
{
add
(
addons
[
id
]
)
;
}
}
res
.
add
(
addon
.
id
)
;
}
;
Object
.
values
(
addons
)
.
forEach
(
add
)
;
return
Array
.
from
(
res
id
=
>
addons
[
id
]
)
;
}
setTelemetry
(
aId
aName
aValue
)
{
if
(
!
this
.
_telemetryDetails
[
aId
]
)
this
.
_telemetryDetails
[
aId
]
=
{
}
;
this
.
_telemetryDetails
[
aId
]
[
aName
]
=
aValue
;
}
_inProgress
:
[
]
doing
(
aCancellable
)
{
this
.
_inProgress
.
push
(
aCancellable
)
;
}
done
(
aCancellable
)
{
let
i
=
this
.
_inProgress
.
indexOf
(
aCancellable
)
;
if
(
i
!
=
-
1
)
{
this
.
_inProgress
.
splice
(
i
1
)
;
return
true
;
}
return
false
;
}
cancelAll
(
)
{
while
(
this
.
_inProgress
.
length
>
0
)
{
let
c
=
this
.
_inProgress
.
shift
(
)
;
try
{
c
.
cancel
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Cancel
failed
"
e
)
;
}
}
}
setupInstallLocations
(
aAppChanged
)
{
function
DirectoryLoc
(
aName
aScope
aKey
aPaths
aLocked
)
{
try
{
var
dir
=
FileUtils
.
getDir
(
aKey
aPaths
)
;
}
catch
(
e
)
{
return
null
;
}
return
new
DirectoryLocation
(
aName
dir
aScope
aLocked
)
;
}
function
BuiltInLoc
(
name
scope
key
paths
)
{
try
{
var
dir
=
FileUtils
.
getDir
(
key
paths
)
;
}
catch
(
e
)
{
return
null
;
}
return
new
BuiltInLocation
(
name
dir
scope
)
;
}
function
SystemLoc
(
aName
aScope
aKey
aPaths
)
{
try
{
var
dir
=
FileUtils
.
getDir
(
aKey
aPaths
)
;
}
catch
(
e
)
{
return
null
;
}
return
new
SystemAddonLocation
(
aName
dir
aScope
aAppChanged
!
=
=
false
)
;
}
function
RegistryLoc
(
aName
aScope
aKey
)
{
if
(
"
nsIWindowsRegKey
"
in
Ci
)
{
return
new
WinRegLocation
(
aName
Ci
.
nsIWindowsRegKey
[
aKey
]
aScope
)
;
}
}
let
enabledScopes
=
Services
.
prefs
.
getIntPref
(
PREF_EM_ENABLED_SCOPES
AddonManager
.
SCOPE_ALL
)
;
enabledScopes
|
=
AddonManager
.
SCOPE_PROFILE
;
let
locations
=
[
[
(
)
=
>
TemporaryInstallLocation
TemporaryInstallLocation
.
name
null
]
[
DirectoryLoc
KEY_APP_PROFILE
AddonManager
.
SCOPE_PROFILE
KEY_PROFILEDIR
[
DIR_EXTENSIONS
]
false
]
[
SystemLoc
KEY_APP_SYSTEM_ADDONS
AddonManager
.
SCOPE_PROFILE
KEY_PROFILEDIR
[
DIR_SYSTEM_ADDONS
]
]
[
BuiltInLoc
KEY_APP_SYSTEM_DEFAULTS
AddonManager
.
SCOPE_PROFILE
KEY_APP_FEATURES
[
]
]
[
DirectoryLoc
KEY_APP_SYSTEM_USER
AddonManager
.
SCOPE_USER
"
XREUSysExt
"
[
Services
.
appinfo
.
ID
]
true
]
[
RegistryLoc
"
winreg
-
app
-
user
"
AddonManager
.
SCOPE_USER
"
ROOT_KEY_CURRENT_USER
"
]
[
DirectoryLoc
KEY_APP_GLOBAL
AddonManager
.
SCOPE_APPLICATION
KEY_ADDON_APP_DIR
[
DIR_EXTENSIONS
]
true
]
[
DirectoryLoc
KEY_APP_SYSTEM_SHARE
AddonManager
.
SCOPE_SYSTEM
"
XRESysSExtPD
"
[
Services
.
appinfo
.
ID
]
true
]
[
DirectoryLoc
KEY_APP_SYSTEM_LOCAL
AddonManager
.
SCOPE_SYSTEM
"
XRESysLExtPD
"
[
Services
.
appinfo
.
ID
]
true
]
[
RegistryLoc
"
winreg
-
app
-
global
"
AddonManager
.
SCOPE_SYSTEM
"
ROOT_KEY_LOCAL_MACHINE
"
]
]
;
for
(
let
[
constructor
name
scope
.
.
.
args
]
of
locations
)
{
if
(
!
scope
|
|
enabledScopes
&
scope
)
{
try
{
let
loc
=
constructor
(
name
scope
.
.
.
args
)
;
if
(
loc
)
{
XPIStates
.
addLocation
(
name
loc
)
;
}
}
catch
(
e
)
{
logger
.
warn
(
Failed
to
add
{
constructor
.
name
}
install
location
{
name
}
e
)
;
}
}
}
}
startup
(
aAppChanged
aOldAppVersion
aOldPlatformVersion
)
{
try
{
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_startup_begin
"
)
;
logger
.
debug
(
"
startup
"
)
;
this
.
runPhase
=
XPI_STARTING
;
this
.
_telemetryDetails
=
{
}
;
AddonManagerPrivate
.
setTelemetryDetails
(
"
XPI
"
this
.
_telemetryDetails
)
;
this
.
setupInstallLocations
(
aAppChanged
)
;
if
(
!
AppConstants
.
MOZ_REQUIRE_SIGNING
|
|
Cu
.
isInAutomation
)
Services
.
prefs
.
addObserver
(
PREF_XPI_SIGNATURES_REQUIRED
this
)
;
Services
.
prefs
.
addObserver
(
PREF_LANGPACK_SIGNATURES
this
)
;
Services
.
prefs
.
addObserver
(
PREF_ALLOW_LEGACY
this
)
;
Services
.
obs
.
addObserver
(
this
NOTIFICATION_FLUSH_PERMISSIONS
)
;
Services
.
obs
.
addObserver
(
this
NOTIFICATION_TOOLBOX_CONNECTION_CHANGE
)
;
let
flushCaches
=
this
.
checkForChanges
(
aAppChanged
aOldAppVersion
aOldPlatformVersion
)
;
if
(
flushCaches
)
{
Services
.
obs
.
notifyObservers
(
null
"
startupcache
-
invalidate
"
)
;
}
AddonManagerPrivate
.
markProviderSafe
(
this
)
;
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
try
{
Services
.
appinfo
.
annotateCrashReport
(
"
EMCheckCompatibility
"
AddonManager
.
checkCompatibility
)
;
}
catch
(
e
)
{
}
this
.
addAddonsToCrashReporter
(
)
;
}
try
{
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_bootstrap_addons_begin
"
)
;
for
(
let
addon
of
this
.
sortBootstrappedAddons
(
)
)
{
let
activeAddon
=
this
.
activeAddons
.
get
(
addon
.
id
)
;
if
(
activeAddon
&
&
activeAddon
.
started
)
{
continue
;
}
try
{
let
reason
=
BOOTSTRAP_REASONS
.
APP_STARTUP
;
if
(
AddonManager
.
getStartupChanges
(
AddonManager
.
STARTUP_CHANGE_INSTALLED
)
.
includes
(
addon
.
id
)
)
reason
=
BOOTSTRAP_REASONS
.
ADDON_INSTALL
;
BootstrapScope
.
get
(
addon
)
.
startup
(
reason
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
load
bootstrap
addon
"
+
addon
.
id
+
"
from
"
+
addon
.
descriptor
e
)
;
}
}
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_bootstrap_addons_end
"
)
;
}
catch
(
e
)
{
logger
.
error
(
"
bootstrap
startup
failed
"
e
)
;
AddonManagerPrivate
.
recordException
(
"
XPI
-
BOOTSTRAP
"
"
startup
failed
"
e
)
;
}
Services
.
obs
.
addObserver
(
function
observer
(
)
{
XPIProvider
.
cleanupTemporaryAddons
(
)
;
XPIProvider
.
_closing
=
true
;
for
(
let
addon
of
XPIProvider
.
sortBootstrappedAddons
(
)
.
reverse
(
)
)
{
let
activeAddon
=
XPIProvider
.
activeAddons
.
get
(
addon
.
id
)
;
if
(
!
activeAddon
|
|
!
activeAddon
.
started
)
{
continue
;
}
let
reason
=
BOOTSTRAP_REASONS
.
APP_SHUTDOWN
;
if
(
addon
.
_pendingDisable
)
{
reason
=
BOOTSTRAP_REASONS
.
ADDON_DISABLE
;
}
else
if
(
addon
.
location
.
isTemporary
)
{
reason
=
BOOTSTRAP_REASONS
.
ADDON_UNINSTALL
;
let
existing
=
XPIStates
.
findAddon
(
addon
.
id
loc
=
>
!
loc
.
isTemporary
)
;
if
(
existing
)
{
reason
=
XPIInstall
.
newVersionReason
(
addon
.
version
existing
.
version
)
;
}
}
BootstrapScope
.
get
(
addon
)
.
shutdown
(
reason
)
;
}
Services
.
obs
.
removeObserver
(
observer
"
quit
-
application
-
granted
"
)
;
}
"
quit
-
application
-
granted
"
)
;
Services
.
obs
.
addObserver
(
function
observer
(
)
{
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_finalUIStartup
"
)
;
XPIProvider
.
runPhase
=
XPI_AFTER_UI_STARTUP
;
Services
.
obs
.
removeObserver
(
observer
"
final
-
ui
-
startup
"
)
;
}
"
final
-
ui
-
startup
"
)
;
if
(
!
this
.
isDBLoaded
)
{
const
EVENTS
=
[
"
sessionstore
-
windows
-
restored
"
"
xul
-
window
-
visible
"
"
test
-
load
-
xpi
-
database
"
]
;
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
topic
=
=
"
xul
-
window
-
visible
"
&
&
!
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
toolbox
"
)
)
{
return
;
}
for
(
let
event
of
EVENTS
)
{
Services
.
obs
.
removeObserver
(
observer
event
)
;
}
XPIDatabase
.
asyncLoadDB
(
)
;
}
;
for
(
let
event
of
EVENTS
)
{
Services
.
obs
.
addObserver
(
observer
event
)
;
}
}
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_startup_end
"
)
;
this
.
extensionsActive
=
true
;
this
.
runPhase
=
XPI_BEFORE_UI_STARTUP
;
timerManager
.
registerTimer
(
"
xpi
-
signature
-
verification
"
(
)
=
>
{
XPIDatabase
.
verifySignatures
(
)
;
}
XPI_SIGNATURE_CHECK_PERIOD
)
;
}
catch
(
e
)
{
logger
.
error
(
"
startup
failed
"
e
)
;
AddonManagerPrivate
.
recordException
(
"
XPI
"
"
startup
failed
"
e
)
;
}
}
async
shutdown
(
)
{
logger
.
debug
(
"
shutdown
"
)
;
this
.
cancelAll
(
)
;
this
.
activeAddons
.
clear
(
)
;
this
.
allAppGlobal
=
true
;
for
(
let
install
of
XPIInstall
.
installs
)
{
if
(
install
.
onShutdown
(
)
)
{
install
.
onShutdown
(
)
;
}
}
if
(
Services
.
prefs
.
getBoolPref
(
PREF_PENDING_OPERATIONS
false
)
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_pending_ops
"
1
)
;
XPIDatabase
.
updateActiveAddons
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
false
)
;
}
if
(
!
XPIDatabase
.
initialized
)
{
await
XPIDatabase
.
asyncLoadDB
(
)
;
}
this
.
extensionsActive
=
false
;
await
XPIDatabase
.
shutdown
(
)
;
}
cleanupTemporaryAddons
(
)
{
let
tempLocation
=
TemporaryInstallLocation
;
for
(
let
[
id
addon
]
of
tempLocation
.
entries
(
)
)
{
tempLocation
.
delete
(
id
)
;
let
bootstrap
=
BootstrapScope
.
get
(
addon
)
;
let
existing
=
XPIStates
.
findAddon
(
id
loc
=
>
!
loc
.
isTemporary
)
;
let
cleanup
=
(
)
=
>
{
tempLocation
.
installer
.
uninstallAddon
(
id
)
;
tempLocation
.
removeAddon
(
id
)
;
}
;
if
(
existing
)
{
bootstrap
.
update
(
existing
false
(
)
=
>
{
cleanup
(
)
;
XPIDatabase
.
makeAddonLocationVisible
(
id
existing
.
location
)
;
}
)
;
}
else
{
bootstrap
.
uninstall
(
)
;
cleanup
(
)
;
}
}
}
addAddonsToCrashReporter
(
)
{
if
(
!
(
Services
.
appinfo
instanceof
Ci
.
nsICrashReporter
)
|
|
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
;
}
if
(
Services
.
appinfo
.
inSafeMode
)
{
return
;
}
let
data
=
Array
.
from
(
XPIStates
.
enabledAddons
(
)
a
=
>
a
.
telemetryKey
)
.
join
(
"
"
)
;
try
{
Services
.
appinfo
.
annotateCrashReport
(
"
Add
-
ons
"
data
)
;
}
catch
(
e
)
{
}
TelemetrySession
.
setAddOns
(
data
)
;
}
processPendingFileChanges
(
aManifests
)
{
let
changed
=
false
;
for
(
let
loc
of
XPIStates
.
locations
(
)
)
{
aManifests
[
loc
.
name
]
=
{
}
;
if
(
loc
.
locked
)
{
continue
;
}
let
cleanNames
=
[
]
;
let
promises
=
[
]
;
for
(
let
[
id
metadata
]
of
loc
.
getStagedAddons
(
)
)
{
loc
.
unstageAddon
(
id
)
;
aManifests
[
loc
.
name
]
[
id
]
=
null
;
promises
.
push
(
XPIInstall
.
installStagedAddon
(
id
metadata
loc
)
.
then
(
addon
=
>
{
aManifests
[
loc
.
name
]
[
id
]
=
addon
;
}
error
=
>
{
delete
aManifests
[
loc
.
name
]
[
id
]
;
cleanNames
.
push
(
{
id
}
.
xpi
)
;
logger
.
error
(
Failed
to
install
staged
add
-
on
{
id
}
in
{
loc
.
name
}
error
)
;
}
)
)
;
}
if
(
promises
.
length
)
{
changed
=
true
;
awaitPromise
(
Promise
.
all
(
promises
)
)
;
}
try
{
if
(
cleanNames
.
length
)
{
loc
.
installer
.
cleanStagingDir
(
cleanNames
)
;
}
}
catch
(
e
)
{
logger
.
debug
(
"
Error
cleaning
staging
dir
"
e
)
;
}
}
return
changed
;
}
installDistributionAddons
(
aManifests
aAppChanged
)
{
let
distroDir
;
try
{
distroDir
=
FileUtils
.
getDir
(
KEY_APP_DISTRIBUTION
[
DIR_EXTENSIONS
]
)
;
if
(
!
distroDir
.
isDirectory
(
)
)
return
false
;
}
catch
(
e
)
{
return
false
;
}
let
changed
=
false
;
let
profileLocation
=
XPIStates
.
getLocation
(
KEY_APP_PROFILE
)
;
let
entries
=
distroDir
.
directoryEntries
.
QueryInterface
(
Ci
.
nsIDirectoryEnumerator
)
;
let
entry
;
while
(
(
entry
=
entries
.
nextFile
)
)
{
let
id
=
entry
.
leafName
;
if
(
id
.
endsWith
(
"
.
xpi
"
)
)
{
id
=
id
.
slice
(
0
-
4
)
;
}
else
{
logger
.
debug
(
"
Ignoring
distribution
add
-
on
that
isn
'
t
an
XPI
:
"
+
entry
.
path
)
;
continue
;
}
if
(
!
gIDTest
.
test
(
id
)
)
{
logger
.
debug
(
"
Ignoring
distribution
add
-
on
whose
name
is
not
a
valid
add
-
on
ID
:
"
+
entry
.
path
)
;
continue
;
}
if
(
!
aAppChanged
&
&
Services
.
prefs
.
prefHasUserValue
(
PREF_BRANCH_INSTALLED_ADDON
+
id
)
)
{
continue
;
}
try
{
let
addon
=
awaitPromise
(
XPIInstall
.
installDistributionAddon
(
id
entry
profileLocation
)
)
;
if
(
addon
)
{
if
(
!
(
KEY_APP_PROFILE
in
aManifests
)
)
aManifests
[
KEY_APP_PROFILE
]
=
{
}
;
aManifests
[
KEY_APP_PROFILE
]
[
id
]
=
addon
;
changed
=
true
;
}
}
catch
(
e
)
{
logger
.
error
(
Failed
to
install
distribution
add
-
on
{
entry
.
path
}
e
)
;
}
}
entries
.
close
(
)
;
return
changed
;
}
getNewDistroAddons
(
)
{
let
addons
=
this
.
newDistroAddons
;
this
.
newDistroAddons
=
null
;
return
addons
;
}
importPermissions
(
)
{
PermissionsUtils
.
importFromPrefs
(
PREF_XPI_PERMISSIONS_BRANCH
XPI_PERMISSION
)
;
}
getDependentAddons
(
aAddon
)
{
return
Array
.
from
(
XPIDatabase
.
getAddons
(
)
)
.
filter
(
addon
=
>
addon
.
dependencies
.
includes
(
aAddon
.
id
)
)
;
}
checkForChanges
(
aAppChanged
aOldAppVersion
aOldPlatformVersion
)
{
logger
.
debug
(
"
checkForChanges
"
)
;
let
updateReasons
=
[
]
;
if
(
aAppChanged
)
{
updateReasons
.
push
(
"
appChanged
"
)
;
}
let
installChanged
=
XPIStates
.
scanForChanges
(
aAppChanged
=
=
=
false
)
;
if
(
installChanged
)
{
updateReasons
.
push
(
"
directoryState
"
)
;
}
let
manifests
=
{
}
;
let
updated
=
this
.
processPendingFileChanges
(
manifests
)
;
if
(
updated
)
{
updateReasons
.
push
(
"
pendingFileChanges
"
)
;
}
let
hasPendingChanges
=
Services
.
prefs
.
getBoolPref
(
PREF_PENDING_OPERATIONS
false
)
;
if
(
hasPendingChanges
)
{
updateReasons
.
push
(
"
hasPendingChanges
"
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
PREF_INSTALL_DISTRO_ADDONS
true
)
)
{
updated
=
this
.
installDistributionAddons
(
manifests
aAppChanged
)
;
if
(
updated
)
{
updateReasons
.
push
(
"
installDistributionAddons
"
)
;
}
}
let
haveAnyAddons
=
(
XPIStates
.
size
>
0
)
;
if
(
DB_SCHEMA
!
=
Services
.
prefs
.
getIntPref
(
PREF_DB_SCHEMA
0
)
)
{
if
(
!
haveAnyAddons
)
{
logger
.
debug
(
"
Empty
XPI
database
setting
schema
version
preference
to
"
+
DB_SCHEMA
)
;
Services
.
prefs
.
setIntPref
(
PREF_DB_SCHEMA
DB_SCHEMA
)
;
}
else
{
updateReasons
.
push
(
"
schemaChanged
"
)
;
}
}
let
dbFile
=
FileUtils
.
getFile
(
KEY_PROFILEDIR
[
FILE_DATABASE
]
true
)
;
if
(
!
dbFile
.
exists
(
)
&
&
haveAnyAddons
)
{
updateReasons
.
push
(
"
needNewDatabase
"
)
;
}
try
{
let
extensionListChanged
=
false
;
if
(
updateReasons
.
length
>
0
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startup_load_reasons
"
updateReasons
)
;
XPIDatabase
.
syncLoadDB
(
false
)
;
try
{
extensionListChanged
=
XPIDatabaseReconcile
.
processFileChanges
(
manifests
aAppChanged
aOldAppVersion
aOldPlatformVersion
updateReasons
.
includes
(
"
schemaChanged
"
)
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
process
extension
changes
at
startup
"
e
)
;
}
}
if
(
extensionListChanged
|
|
hasPendingChanges
)
{
this
.
_updateActiveAddons
(
)
;
return
true
;
}
logger
.
debug
(
"
No
changes
found
"
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Error
during
startup
file
checks
"
e
)
;
}
return
false
;
}
_updateActiveAddons
(
)
{
logger
.
debug
(
"
Updating
database
with
changes
to
installed
add
-
ons
"
)
;
XPIDatabase
.
updateActiveAddons
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
false
)
;
}
async
getNewSideloads
(
)
{
if
(
XPIStates
.
scanForChanges
(
false
)
)
{
await
XPIDatabase
.
asyncLoadDB
(
false
)
;
XPIDatabaseReconcile
.
processFileChanges
(
{
}
false
)
;
this
.
_updateActiveAddons
(
)
;
}
let
addons
=
await
Promise
.
all
(
Array
.
from
(
XPIStates
.
sideLoadedAddons
.
keys
(
)
id
=
>
AddonManager
.
getAddonByID
(
id
)
)
)
;
return
addons
.
filter
(
addon
=
>
(
addon
.
seen
=
=
=
false
&
&
addon
.
permissions
&
AddonManager
.
PERM_CAN_ENABLE
)
)
;
}
supportsMimetype
(
aMimetype
)
{
return
aMimetype
=
=
"
application
/
x
-
xpinstall
"
;
}
isTemporaryInstallID
(
id
)
{
return
id
.
endsWith
(
TEMPORARY_ADDON_SUFFIX
)
;
}
setStartupData
(
aID
aData
)
{
let
state
=
XPIStates
.
findAddon
(
aID
)
;
state
.
startupData
=
aData
;
XPIStates
.
save
(
)
;
}
getAddonByInstanceID
(
aInstanceID
)
{
let
id
=
this
.
getAddonIDByInstanceID
(
aInstanceID
)
;
if
(
id
)
{
return
this
.
syncGetAddonByID
(
id
)
;
}
return
null
;
}
getAddonIDByInstanceID
(
aInstanceID
)
{
if
(
!
aInstanceID
|
|
typeof
aInstanceID
!
=
"
symbol
"
)
throw
Components
.
Exception
(
"
aInstanceID
must
be
a
Symbol
(
)
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
for
(
let
[
id
val
]
of
this
.
activeAddons
)
{
if
(
aInstanceID
=
=
val
.
instanceID
)
{
return
id
;
}
}
return
null
;
}
async
getAddonByID
(
aId
)
{
let
aAddon
=
await
XPIDatabase
.
getVisibleAddonForID
(
aId
)
;
return
aAddon
?
aAddon
.
wrapper
:
null
;
}
syncGetAddonByID
(
aId
)
{
let
aAddon
=
XPIDatabase
.
syncGetVisibleAddonForID
(
aId
)
;
return
aAddon
?
aAddon
.
wrapper
:
null
;
}
async
getAddonsByTypes
(
aTypes
)
{
let
typesToGet
=
getAllAliasesForTypes
(
aTypes
)
;
if
(
typesToGet
&
&
!
typesToGet
.
some
(
type
=
>
ALL_EXTERNAL_TYPES
.
has
(
type
)
)
)
{
return
[
]
;
}
let
addons
=
await
XPIDatabase
.
getVisibleAddons
(
typesToGet
)
;
return
addons
.
map
(
a
=
>
a
.
wrapper
)
;
}
async
getActiveAddons
(
aTypes
)
{
if
(
this
.
isDBLoaded
)
{
let
addons
=
await
this
.
getAddonsByTypes
(
aTypes
)
;
return
{
addons
:
addons
.
filter
(
addon
=
>
addon
.
isActive
)
fullData
:
true
}
;
}
if
(
!
XPIStates
.
db
)
{
throw
new
Error
(
"
XPIStates
not
yet
initialized
"
)
;
}
let
result
=
[
]
;
for
(
let
addon
of
XPIStates
.
enabledAddons
(
)
)
{
if
(
aTypes
&
&
!
aTypes
.
includes
(
addon
.
type
)
)
{
continue
;
}
let
{
location
}
=
addon
;
let
scope
isSystem
;
if
(
location
)
{
(
{
scope
isSystem
}
=
location
)
;
}
result
.
push
(
{
id
:
addon
.
id
version
:
addon
.
version
type
:
addon
.
type
updateDate
:
addon
.
lastModifiedTime
scope
isSystem
isWebExtension
:
isWebExtension
(
addon
)
}
)
;
}
return
{
addons
:
result
fullData
:
false
}
;
}
async
getAddonBySyncGUID
(
aGUID
)
{
let
addon
=
await
XPIDatabase
.
getAddonBySyncGUID
(
aGUID
)
;
return
addon
?
addon
.
wrapper
:
null
;
}
async
getAddonsWithOperationsByTypes
(
aTypes
)
{
let
typesToGet
=
getAllAliasesForTypes
(
aTypes
)
;
let
aAddons
=
await
XPIDatabase
.
getVisibleAddonsWithPendingOperations
(
typesToGet
)
;
let
results
=
aAddons
.
map
(
a
=
>
a
.
wrapper
)
;
for
(
let
install
of
XPIInstall
.
installs
)
{
if
(
install
.
state
=
=
AddonManager
.
STATE_INSTALLED
&
&
!
(
install
.
addon
.
inDatabase
)
)
results
.
push
(
install
.
addon
.
wrapper
)
;
}
return
results
;
}
addonChanged
(
id
type
)
{
XPIDatabase
.
addonChanged
(
id
type
)
;
}
updateAddonAppDisabledStates
(
)
{
let
addons
=
XPIDatabase
.
getAddons
(
)
;
for
(
let
addon
of
addons
)
{
XPIDatabase
.
updateAddonDisabledState
(
addon
)
;
}
}
async
updateAddonRepositoryData
(
)
{
let
addons
=
await
XPIDatabase
.
getVisibleAddons
(
null
)
;
logger
.
debug
(
"
updateAddonRepositoryData
found
"
+
addons
.
length
+
"
visible
add
-
ons
"
)
;
await
Promise
.
all
(
addons
.
map
(
addon
=
>
AddonRepository
.
getCachedAddonByID
(
addon
.
id
)
.
then
(
aRepoAddon
=
>
{
if
(
aRepoAddon
|
|
AddonRepository
.
getCompatibilityOverridesSync
(
addon
.
id
)
)
{
logger
.
debug
(
"
updateAddonRepositoryData
got
info
for
"
+
addon
.
id
)
;
addon
.
_repositoryAddon
=
aRepoAddon
;
XPIDatabase
.
updateAddonDisabledState
(
addon
)
;
}
}
)
)
)
;
}
onDebugConnectionChange
(
{
what
connection
}
)
{
if
(
what
!
=
"
opened
"
)
return
;
for
(
let
[
id
val
]
of
this
.
activeAddons
)
{
connection
.
setAddonOptions
(
id
{
global
:
val
.
scope
}
)
;
}
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
NOTIFICATION_FLUSH_PERMISSIONS
)
{
if
(
!
aData
|
|
aData
=
=
XPI_PERMISSION
)
{
this
.
importPermissions
(
)
;
}
return
;
}
else
if
(
aTopic
=
=
NOTIFICATION_TOOLBOX_CONNECTION_CHANGE
)
{
this
.
onDebugConnectionChange
(
aSubject
.
wrappedJSObject
)
;
return
;
}
if
(
aTopic
=
=
"
nsPref
:
changed
"
)
{
switch
(
aData
)
{
case
PREF_XPI_SIGNATURES_REQUIRED
:
case
PREF_LANGPACK_SIGNATURES
:
case
PREF_ALLOW_LEGACY
:
this
.
updateAddonAppDisabledStates
(
)
;
break
;
}
}
}
}
;
for
(
let
meth
of
[
"
getInstallForFile
"
"
getInstallForURL
"
"
getInstallsByTypes
"
"
installTemporaryAddon
"
"
isInstallAllowed
"
"
isInstallEnabled
"
"
updateSystemAddons
"
]
)
{
XPIProvider
[
meth
]
=
function
(
)
{
return
XPIInstall
[
meth
]
(
.
.
.
arguments
)
;
}
;
}
var
XPIInternal
=
{
BOOTSTRAP_REASONS
BootstrapScope
DB_SCHEMA
KEY_APP_SYSTEM_ADDONS
KEY_APP_SYSTEM_DEFAULTS
PREF_BRANCH_INSTALLED_ADDON
PREF_SYSTEM_ADDON_SET
SIGNED_TYPES
SystemAddonLocation
TEMPORARY_ADDON_SUFFIX
TOOLKIT_ID
TemporaryInstallLocation
XPIProvider
XPIStates
XPI_PERMISSION
awaitPromise
canRunInSafeMode
descriptorToPath
getExternalType
getURIForResourceInFile
isTheme
isWebExtension
}
;
var
addonTypes
=
[
new
AddonManagerPrivate
.
AddonType
(
"
extension
"
URI_EXTENSION_STRINGS
"
type
.
extension
.
name
"
AddonManager
.
VIEW_TYPE_LIST
4000
AddonManager
.
TYPE_SUPPORTS_UNDO_RESTARTLESS_UNINSTALL
)
new
AddonManagerPrivate
.
AddonType
(
"
theme
"
URI_EXTENSION_STRINGS
"
type
.
themes
.
name
"
AddonManager
.
VIEW_TYPE_LIST
5000
)
new
AddonManagerPrivate
.
AddonType
(
"
dictionary
"
URI_EXTENSION_STRINGS
"
type
.
dictionary
.
name
"
AddonManager
.
VIEW_TYPE_LIST
7000
AddonManager
.
TYPE_UI_HIDE_EMPTY
|
AddonManager
.
TYPE_SUPPORTS_UNDO_RESTARTLESS_UNINSTALL
)
new
AddonManagerPrivate
.
AddonType
(
"
locale
"
URI_EXTENSION_STRINGS
"
type
.
locale
.
name
"
AddonManager
.
VIEW_TYPE_LIST
8000
AddonManager
.
TYPE_UI_HIDE_EMPTY
|
AddonManager
.
TYPE_SUPPORTS_UNDO_RESTARTLESS_UNINSTALL
)
]
;
AddonManagerPrivate
.
registerProvider
(
XPIProvider
addonTypes
)
;
