"
use
strict
"
;
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
Cr
=
Components
.
results
;
const
Cu
=
Components
.
utils
;
this
.
EXPORTED_SYMBOLS
=
[
"
XPIProvider
"
"
XPIInternal
"
]
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonRepository
:
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonRepository
.
jsm
"
AddonSettings
:
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonSettings
.
jsm
"
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
ChromeManifestParser
:
"
resource
:
/
/
gre
/
modules
/
ChromeManifestParser
.
jsm
"
Extension
:
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
Langpack
:
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
LightweightThemeManager
:
"
resource
:
/
/
gre
/
modules
/
LightweightThemeManager
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
ZipUtils
:
"
resource
:
/
/
gre
/
modules
/
ZipUtils
.
jsm
"
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
PermissionsUtils
:
"
resource
:
/
/
gre
/
modules
/
PermissionsUtils
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
ConsoleAPI
:
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
ProductAddonChecker
:
"
resource
:
/
/
gre
/
modules
/
addons
/
ProductAddonChecker
.
jsm
"
UpdateUtils
:
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
JSONFile
:
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
LegacyExtensionsUtils
:
"
resource
:
/
/
gre
/
modules
/
LegacyExtensionsUtils
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
DownloadAddonInstall
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIInstall
.
jsm
"
LocalAddonInstall
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIInstall
.
jsm
"
StagedAddonInstall
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIInstall
.
jsm
"
UpdateChecker
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIInstall
.
jsm
"
loadManifestFromFile
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIInstall
.
jsm
"
verifyBundleSignedState
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIInstall
.
jsm
"
}
)
;
const
{
nsIBlocklistService
}
=
Ci
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
Blocklist
:
[
"
mozilla
.
org
/
extensions
/
blocklist
;
1
"
"
nsIBlocklistService
"
]
ChromeRegistry
:
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
"
nsIChromeRegistry
"
]
ResProtocolHandler
:
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
resource
"
"
nsIResProtocolHandler
"
]
AddonPolicyService
:
[
"
mozilla
.
org
/
addons
/
policy
-
service
;
1
"
"
nsIAddonPolicyService
"
]
AddonPathService
:
[
"
mozilla
.
org
/
addon
-
path
-
service
;
1
"
"
amIAddonPathService
"
]
aomStartup
:
[
"
mozilla
.
org
/
addons
/
addon
-
manager
-
startup
;
1
"
"
amIAddonManagerStartup
"
]
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gTextDecoder
"
(
)
=
>
{
return
new
TextDecoder
(
)
;
}
)
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
const
nsIFile
=
Components
.
Constructor
(
"
mozilla
.
org
/
file
/
local
;
1
"
"
nsIFile
"
"
initWithPath
"
)
;
const
PREF_DB_SCHEMA
=
"
extensions
.
databaseSchema
"
;
const
PREF_XPI_STATE
=
"
extensions
.
xpiState
"
;
const
PREF_BLOCKLIST_ITEM_URL
=
"
extensions
.
blocklist
.
itemURL
"
;
const
PREF_BOOTSTRAP_ADDONS
=
"
extensions
.
bootstrappedAddons
"
;
const
PREF_PENDING_OPERATIONS
=
"
extensions
.
pendingOperations
"
;
const
PREF_SKIN_SWITCHPENDING
=
"
extensions
.
dss
.
switchPending
"
;
const
PREF_SKIN_TO_SELECT
=
"
extensions
.
lastSelectedSkin
"
;
const
PREF_GENERAL_SKINS_SELECTEDSKIN
=
"
general
.
skins
.
selectedSkin
"
;
const
PREF_EM_EXTENSION_FORMAT
=
"
extensions
.
"
;
const
PREF_EM_ENABLED_SCOPES
=
"
extensions
.
enabledScopes
"
;
const
PREF_EM_STARTUP_SCAN_SCOPES
=
"
extensions
.
startupScanScopes
"
;
const
PREF_EM_SHOW_MISMATCH_UI
=
"
extensions
.
showMismatchUI
"
;
const
PREF_XPI_ENABLED
=
"
xpinstall
.
enabled
"
;
const
PREF_XPI_WHITELIST_REQUIRED
=
"
xpinstall
.
whitelist
.
required
"
;
const
PREF_XPI_DIRECT_WHITELISTED
=
"
xpinstall
.
whitelist
.
directRequest
"
;
const
PREF_XPI_FILE_WHITELISTED
=
"
xpinstall
.
whitelist
.
fileRequest
"
;
const
PREF_XPI_SIGNATURES_REQUIRED
=
"
xpinstall
.
signatures
.
required
"
;
const
PREF_XPI_SIGNATURES_DEV_ROOT
=
"
xpinstall
.
signatures
.
dev
-
root
"
;
const
PREF_XPI_PERMISSIONS_BRANCH
=
"
xpinstall
.
"
;
const
PREF_INSTALL_REQUIRESECUREORIGIN
=
"
extensions
.
install
.
requireSecureOrigin
"
;
const
PREF_INSTALL_DISTRO_ADDONS
=
"
extensions
.
installDistroAddons
"
;
const
PREF_BRANCH_INSTALLED_ADDON
=
"
extensions
.
installedDistroAddon
.
"
;
const
PREF_INTERPOSITION_ENABLED
=
"
extensions
.
interposition
.
enabled
"
;
const
PREF_SYSTEM_ADDON_SET
=
"
extensions
.
systemAddonSet
"
;
const
PREF_SYSTEM_ADDON_UPDATE_URL
=
"
extensions
.
systemAddon
.
update
.
url
"
;
const
PREF_ALLOW_LEGACY
=
"
extensions
.
legacy
.
enabled
"
;
const
PREF_ALLOW_NON_MPC
=
"
extensions
.
allow
-
non
-
mpc
-
extensions
"
;
const
PREF_EM_MIN_COMPAT_APP_VERSION
=
"
extensions
.
minCompatibleAppVersion
"
;
const
PREF_EM_MIN_COMPAT_PLATFORM_VERSION
=
"
extensions
.
minCompatiblePlatformVersion
"
;
const
PREF_EM_HOTFIX_ID
=
"
extensions
.
hotfix
.
id
"
;
const
PREF_EM_LAST_APP_BUILD_ID
=
"
extensions
.
lastAppBuildId
"
;
const
BUILT_IN_ADDONS_URI
=
"
chrome
:
/
/
browser
/
content
/
built_in_addons
.
json
"
;
const
OBSOLETE_PREFERENCES
=
[
"
extensions
.
bootstrappedAddons
"
"
extensions
.
enabledAddons
"
"
extensions
.
xpiState
"
"
extensions
.
installCache
"
]
;
const
URI_EXTENSION_STRINGS
=
"
chrome
:
/
/
mozapps
/
locale
/
extensions
/
extensions
.
properties
"
;
const
DIR_EXTENSIONS
=
"
extensions
"
;
const
DIR_SYSTEM_ADDONS
=
"
features
"
;
const
DIR_STAGE
=
"
staged
"
;
const
DIR_TRASH
=
"
trash
"
;
const
FILE_XPI_STATES
=
"
addonStartup
.
json
.
lz4
"
;
const
FILE_DATABASE
=
"
extensions
.
json
"
;
const
FILE_OLD_CACHE
=
"
extensions
.
cache
"
;
const
FILE_RDF_MANIFEST
=
"
install
.
rdf
"
;
const
FILE_WEB_MANIFEST
=
"
manifest
.
json
"
;
const
FILE_XPI_ADDONS_LIST
=
"
extensions
.
ini
"
;
const
ADDON_ID_DEFAULT_THEME
=
"
{
972ce4c6
-
7e08
-
4474
-
a285
-
3208198ce6fd
}
"
;
const
KEY_PROFILEDIR
=
"
ProfD
"
;
const
KEY_ADDON_APP_DIR
=
"
XREAddonAppDir
"
;
const
KEY_APP_DISTRIBUTION
=
"
XREAppDist
"
;
const
KEY_APP_FEATURES
=
"
XREAppFeat
"
;
const
KEY_APP_PROFILE
=
"
app
-
profile
"
;
const
KEY_APP_SYSTEM_ADDONS
=
"
app
-
system
-
addons
"
;
const
KEY_APP_SYSTEM_DEFAULTS
=
"
app
-
system
-
defaults
"
;
const
KEY_APP_GLOBAL
=
"
app
-
global
"
;
const
KEY_APP_SYSTEM_LOCAL
=
"
app
-
system
-
local
"
;
const
KEY_APP_SYSTEM_SHARE
=
"
app
-
system
-
share
"
;
const
KEY_APP_SYSTEM_USER
=
"
app
-
system
-
user
"
;
const
KEY_APP_TEMPORARY
=
"
app
-
temporary
"
;
const
TEMPORARY_ADDON_SUFFIX
=
"
temporary
-
addon
"
;
const
STARTUP_MTIME_SCOPES
=
[
KEY_APP_GLOBAL
KEY_APP_SYSTEM_LOCAL
KEY_APP_SYSTEM_SHARE
KEY_APP_SYSTEM_USER
]
;
const
NOTIFICATION_FLUSH_PERMISSIONS
=
"
flush
-
pending
-
permissions
"
;
const
XPI_PERMISSION
=
"
install
"
;
const
TOOLKIT_ID
=
"
toolkit
mozilla
.
org
"
;
const
XPI_SIGNATURE_CHECK_PERIOD
=
24
*
60
*
60
;
XPCOMUtils
.
defineConstant
(
this
"
DB_SCHEMA
"
24
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
ALLOW_NON_MPC
"
PREF_ALLOW_NON_MPC
)
;
const
NOTIFICATION_TOOLBOX_CONNECTION_CHANGE
=
"
toolbox
-
connection
-
change
"
;
const
PROP_LOCALE_SINGLE
=
[
"
name
"
"
description
"
"
creator
"
"
homepageURL
"
]
;
const
PROP_LOCALE_MULTI
=
[
"
developers
"
"
translators
"
"
contributors
"
]
;
const
PENDING_INSTALL_METADATA
=
[
"
syncGUID
"
"
targetApplications
"
"
userDisabled
"
"
softDisabled
"
"
existingAddonID
"
"
sourceURI
"
"
releaseNotesURI
"
"
installDate
"
"
updateDate
"
"
applyBackgroundUpdates
"
"
compatibilityOverrides
"
]
;
const
STATIC_BLOCKLIST_PATTERNS
=
[
{
creator
:
"
Mozilla
Corp
.
"
level
:
nsIBlocklistService
.
STATE_BLOCKED
blockID
:
"
i162
"
}
{
creator
:
"
Mozilla
.
org
"
level
:
nsIBlocklistService
.
STATE_BLOCKED
blockID
:
"
i162
"
}
]
;
function
encoded
(
strings
.
.
.
values
)
{
let
result
=
[
]
;
for
(
let
[
i
string
]
of
strings
.
entries
(
)
)
{
result
.
push
(
string
)
;
if
(
i
<
values
.
length
)
result
.
push
(
encodeURIComponent
(
values
[
i
]
)
)
;
}
return
result
.
join
(
"
"
)
;
}
const
BOOTSTRAP_REASONS
=
{
APP_STARTUP
:
1
APP_SHUTDOWN
:
2
ADDON_ENABLE
:
3
ADDON_DISABLE
:
4
ADDON_INSTALL
:
5
ADDON_UNINSTALL
:
6
ADDON_UPGRADE
:
7
ADDON_DOWNGRADE
:
8
}
;
const
TYPE_ALIASES
=
{
"
apiextension
"
:
"
extension
"
"
webextension
"
:
"
extension
"
"
webextension
-
theme
"
:
"
theme
"
"
webextension
-
langpack
"
:
"
locale
"
}
;
const
CHROME_TYPES
=
new
Set
(
[
"
extension
"
"
experiment
"
]
)
;
const
SIGNED_TYPES
=
new
Set
(
[
"
apiextension
"
"
extension
"
"
experiment
"
"
webextension
"
"
webextension
-
theme
"
]
)
;
const
LEGACY_TYPES
=
new
Set
(
[
"
apiextension
"
"
extension
"
"
theme
"
]
)
;
const
ALL_EXTERNAL_TYPES
=
new
Set
(
[
"
dictionary
"
"
extension
"
"
experiment
"
"
locale
"
"
theme
"
]
)
;
function
mustSign
(
aType
)
{
if
(
!
SIGNED_TYPES
.
has
(
aType
)
)
return
false
;
return
AddonSettings
.
REQUIRE_SIGNING
;
}
const
XPI_STARTING
=
"
XPIStarting
"
;
const
XPI_BEFORE_UI_STARTUP
=
"
BeforeFinalUIStartup
"
;
const
XPI_AFTER_UI_STARTUP
=
"
AfterFinalUIStartup
"
;
const
COMPATIBLE_BY_DEFAULT_TYPES
=
{
extension
:
true
dictionary
:
true
}
;
const
MSG_JAR_FLUSH
=
"
AddonJarFlush
"
;
const
MSG_MESSAGE_MANAGER_CACHES_FLUSH
=
"
AddonMessageManagerCachesFlush
"
;
var
gGlobalScope
=
this
;
var
gIDTest
=
/
^
(
\
{
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
\
}
|
[
a
-
z0
-
9
-
\
.
_
]
*
\
[
a
-
z0
-
9
-
\
.
_
]
+
)
/
i
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
LOGGER_ID
=
"
addons
.
xpi
"
;
var
logger
=
Log
.
repository
.
getLogger
(
LOGGER_ID
)
;
const
LAZY_OBJECTS
=
[
"
XPIDatabase
"
"
XPIDatabaseReconcile
"
]
;
var
gLazyObjectsLoaded
=
false
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gStartupScanScopes
"
(
)
=
>
{
let
appBuildID
=
Services
.
appinfo
.
appBuildID
;
let
oldAppBuildID
=
Services
.
prefs
.
getCharPref
(
PREF_EM_LAST_APP_BUILD_ID
"
"
)
;
Services
.
prefs
.
setCharPref
(
PREF_EM_LAST_APP_BUILD_ID
appBuildID
)
;
if
(
appBuildID
!
=
=
oldAppBuildID
)
{
return
AddonManager
.
SCOPE_ALL
;
}
return
Services
.
prefs
.
getIntPref
(
PREF_EM_STARTUP_SCAN_SCOPES
0
)
;
}
)
;
function
loadLazyObjects
(
)
{
let
uri
=
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIProviderUtils
.
js
"
;
let
scope
=
Cu
.
Sandbox
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
{
sandboxName
:
uri
wantGlobalProperties
:
[
"
ChromeUtils
"
"
TextDecoder
"
]
}
)
;
Object
.
assign
(
scope
{
ADDON_SIGNING
:
AddonSettings
.
ADDON_SIGNING
SIGNED_TYPES
BOOTSTRAP_REASONS
DB_SCHEMA
AddonInternal
XPIProvider
XPIStates
syncLoadManifestFromFile
isUsableAddon
recordAddonTelemetry
flushChromeCaches
descriptorToPath
}
)
;
Services
.
scriptloader
.
loadSubScript
(
uri
scope
)
;
for
(
let
name
of
LAZY_OBJECTS
)
{
delete
gGlobalScope
[
name
]
;
gGlobalScope
[
name
]
=
scope
[
name
]
;
}
gLazyObjectsLoaded
=
true
;
return
scope
;
}
LAZY_OBJECTS
.
forEach
(
name
=
>
{
Object
.
defineProperty
(
gGlobalScope
name
{
get
(
)
{
let
objs
=
loadLazyObjects
(
)
;
return
objs
[
name
]
;
}
configurable
:
true
}
)
;
}
)
;
function
getFile
(
path
base
=
null
)
{
try
{
return
new
nsIFile
(
path
)
;
}
catch
(
e
)
{
}
let
file
=
base
.
clone
(
)
;
file
.
appendRelativePath
(
path
)
;
return
file
;
}
function
tryGetMtime
(
file
)
{
try
{
return
file
.
lastModifiedTime
;
}
catch
(
e
)
{
return
0
;
}
}
function
getRelativePath
(
file
dir
)
{
if
(
dir
&
&
dir
.
contains
(
file
)
)
{
let
path
=
file
.
getRelativePath
(
dir
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
path
=
path
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
return
path
;
}
return
file
.
path
;
}
function
descriptorToPath
(
descriptor
dir
)
{
try
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
persistentDescriptor
=
descriptor
;
return
getRelativePath
(
file
dir
)
;
}
catch
(
e
)
{
return
null
;
}
}
function
waitForAllPromises
(
promises
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
shouldReject
=
false
;
let
rejectValue
=
null
;
let
newPromises
=
promises
.
map
(
p
=
>
p
.
catch
(
value
=
>
{
shouldReject
=
true
;
rejectValue
=
value
;
}
)
)
;
Promise
.
all
(
newPromises
)
.
then
(
(
results
)
=
>
shouldReject
?
reject
(
rejectValue
)
:
resolve
(
results
)
)
;
}
)
;
}
function
findMatchingStaticBlocklistItem
(
aAddon
)
{
for
(
let
item
of
STATIC_BLOCKLIST_PATTERNS
)
{
if
(
"
creator
"
in
item
&
&
typeof
item
.
creator
=
=
"
string
"
)
{
if
(
(
aAddon
.
defaultLocale
&
&
aAddon
.
defaultLocale
.
creator
=
=
item
.
creator
)
|
|
(
aAddon
.
selectedLocale
&
&
aAddon
.
selectedLocale
.
creator
=
=
item
.
creator
)
)
{
return
item
;
}
}
}
return
null
;
}
function
newVersionReason
(
oldVersion
newVersion
)
{
return
Services
.
vc
.
compare
(
oldVersion
newVersion
)
<
=
0
?
BOOTSTRAP_REASONS
.
ADDON_UPGRADE
:
BOOTSTRAP_REASONS
.
ADDON_DOWNGRADE
;
}
function
addonMap
(
addons
)
{
return
new
Map
(
addons
.
map
(
a
=
>
[
a
.
id
a
]
)
)
;
}
function
isWebExtension
(
type
)
{
return
type
=
=
"
webextension
"
|
|
type
=
=
"
webextension
-
theme
"
;
}
var
gThemeAliases
=
null
;
function
isTheme
(
type
)
{
if
(
!
gThemeAliases
)
gThemeAliases
=
getAllAliasesForTypes
(
[
"
theme
"
]
)
;
return
gThemeAliases
.
includes
(
type
)
;
}
function
setFilePermissions
(
aFile
aPermissions
)
{
try
{
aFile
.
permissions
=
aPermissions
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
set
permissions
"
+
aPermissions
.
toString
(
8
)
+
"
on
"
+
aFile
.
path
e
)
;
}
}
function
writeStringToFile
(
file
string
)
{
let
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
converter
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIConverterOutputStream
)
;
try
{
stream
.
init
(
file
FileUtils
.
MODE_WRONLY
|
FileUtils
.
MODE_CREATE
|
FileUtils
.
MODE_TRUNCATE
FileUtils
.
PERMS_FILE
0
)
;
converter
.
init
(
stream
"
UTF
-
8
"
)
;
converter
.
writeString
(
string
)
;
}
finally
{
converter
.
close
(
)
;
stream
.
close
(
)
;
}
}
function
SafeInstallOperation
(
)
{
this
.
_installedFiles
=
[
]
;
this
.
_createdDirs
=
[
]
;
}
SafeInstallOperation
.
prototype
=
{
_installedFiles
:
null
_createdDirs
:
null
_installFile
(
aFile
aTargetDirectory
aCopy
)
{
let
oldFile
=
aCopy
?
null
:
aFile
.
clone
(
)
;
let
newFile
=
aFile
.
clone
(
)
;
try
{
if
(
aCopy
)
{
newFile
.
copyTo
(
aTargetDirectory
null
)
;
newFile
=
getFile
(
aFile
.
leafName
aTargetDirectory
)
;
newFile
.
lastModifiedTime
=
Date
.
now
(
)
;
}
else
{
newFile
.
moveTo
(
aTargetDirectory
null
)
;
}
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
"
+
(
aCopy
?
"
copy
"
:
"
move
"
)
+
"
file
"
+
aFile
.
path
+
"
to
"
+
aTargetDirectory
.
path
e
)
;
throw
e
;
}
this
.
_installedFiles
.
push
(
{
oldFile
newFile
}
)
;
}
_installDirectory
(
aDirectory
aTargetDirectory
aCopy
)
{
if
(
aDirectory
.
contains
(
aTargetDirectory
)
)
{
let
err
=
new
Error
(
Not
installing
{
aDirectory
}
into
its
own
descendent
{
aTargetDirectory
}
)
;
logger
.
error
(
err
)
;
throw
err
;
}
let
newDir
=
getFile
(
aDirectory
.
leafName
aTargetDirectory
)
;
try
{
newDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
create
directory
"
+
newDir
.
path
e
)
;
throw
e
;
}
this
.
_createdDirs
.
push
(
newDir
)
;
let
entries
=
getDirectoryEntries
(
aDirectory
true
)
;
for
(
let
entry
of
entries
)
{
try
{
this
.
_installDirEntry
(
entry
newDir
aCopy
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
"
+
(
aCopy
?
"
copy
"
:
"
move
"
)
+
"
entry
"
+
entry
.
path
e
)
;
throw
e
;
}
}
if
(
aCopy
)
return
;
try
{
setFilePermissions
(
aDirectory
FileUtils
.
PERMS_DIRECTORY
)
;
aDirectory
.
remove
(
false
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
remove
directory
"
+
aDirectory
.
path
e
)
;
throw
e
;
}
this
.
_installedFiles
.
push
(
{
oldFile
:
aDirectory
newFile
:
newDir
}
)
;
}
_installDirEntry
(
aDirEntry
aTargetDirectory
aCopy
)
{
let
isDir
=
null
;
try
{
isDir
=
aDirEntry
.
isDirectory
(
)
&
&
!
aDirEntry
.
isSymlink
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
)
return
;
logger
.
error
(
"
Failure
"
+
(
aCopy
?
"
copying
"
:
"
moving
"
)
+
"
"
+
aDirEntry
.
path
+
"
to
"
+
aTargetDirectory
.
path
)
;
throw
e
;
}
try
{
if
(
isDir
)
this
.
_installDirectory
(
aDirEntry
aTargetDirectory
aCopy
)
;
else
this
.
_installFile
(
aDirEntry
aTargetDirectory
aCopy
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failure
"
+
(
aCopy
?
"
copying
"
:
"
moving
"
)
+
"
"
+
aDirEntry
.
path
+
"
to
"
+
aTargetDirectory
.
path
)
;
throw
e
;
}
}
moveUnder
(
aFile
aTargetDirectory
)
{
try
{
this
.
_installDirEntry
(
aFile
aTargetDirectory
false
)
;
}
catch
(
e
)
{
this
.
rollback
(
)
;
throw
e
;
}
}
moveTo
(
aOldLocation
aNewLocation
)
{
try
{
let
oldFile
=
aOldLocation
.
clone
(
)
newFile
=
aNewLocation
.
clone
(
)
;
oldFile
.
moveTo
(
newFile
.
parent
newFile
.
leafName
)
;
this
.
_installedFiles
.
push
(
{
oldFile
newFile
isMoveTo
:
true
}
)
;
}
catch
(
e
)
{
this
.
rollback
(
)
;
throw
e
;
}
}
copy
(
aFile
aTargetDirectory
)
{
try
{
this
.
_installDirEntry
(
aFile
aTargetDirectory
true
)
;
}
catch
(
e
)
{
this
.
rollback
(
)
;
throw
e
;
}
}
rollback
(
)
{
while
(
this
.
_installedFiles
.
length
>
0
)
{
let
move
=
this
.
_installedFiles
.
pop
(
)
;
if
(
move
.
isMoveTo
)
{
move
.
newFile
.
moveTo
(
move
.
oldDir
.
parent
move
.
oldDir
.
leafName
)
;
}
else
if
(
move
.
newFile
.
isDirectory
(
)
&
&
!
move
.
newFile
.
isSymlink
(
)
)
{
let
oldDir
=
getFile
(
move
.
oldFile
.
leafName
move
.
oldFile
.
parent
)
;
oldDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
}
else
if
(
!
move
.
oldFile
)
{
move
.
newFile
.
remove
(
true
)
;
}
else
{
move
.
newFile
.
moveTo
(
move
.
oldFile
.
parent
null
)
;
}
}
while
(
this
.
_createdDirs
.
length
>
0
)
recursiveRemove
(
this
.
_createdDirs
.
pop
(
)
)
;
}
}
;
function
canRunInSafeMode
(
aAddon
)
{
if
(
aAddon
.
_installLocation
.
name
=
=
KEY_APP_TEMPORARY
)
return
true
;
return
aAddon
.
_installLocation
.
isSystem
;
}
function
isDisabledLegacy
(
addon
)
{
return
(
!
AddonSettings
.
ALLOW_LEGACY_EXTENSIONS
&
&
LEGACY_TYPES
.
has
(
addon
.
type
)
&
&
!
addon
.
_installLocation
.
isSystem
&
&
!
(
AppConstants
.
MOZ_ALLOW_LEGACY_EXTENSIONS
&
&
addon
.
_installLocation
.
name
=
=
KEY_APP_TEMPORARY
)
&
&
addon
.
signedState
!
=
=
AddonManager
.
SIGNEDSTATE_PRIVILEGED
)
;
}
function
isUsableAddon
(
aAddon
)
{
if
(
aAddon
.
type
=
=
"
theme
"
&
&
aAddon
.
internalName
=
=
XPIProvider
.
defaultSkin
)
return
true
;
if
(
mustSign
(
aAddon
.
type
)
&
&
!
aAddon
.
isCorrectlySigned
)
{
logger
.
warn
(
Add
-
on
{
aAddon
.
id
}
is
not
correctly
signed
.
)
;
if
(
Services
.
prefs
.
getBoolPref
(
PREF_XPI_SIGNATURES_DEV_ROOT
false
)
)
{
logger
.
warn
(
Preference
{
PREF_XPI_SIGNATURES_DEV_ROOT
}
is
set
.
)
;
}
return
false
;
}
if
(
aAddon
.
blocklistState
=
=
nsIBlocklistService
.
STATE_BLOCKED
)
{
logger
.
warn
(
Add
-
on
{
aAddon
.
id
}
is
blocklisted
.
)
;
return
false
;
}
if
(
aAddon
.
type
=
=
"
experiment
"
)
return
true
;
if
(
AddonManager
.
checkUpdateSecurity
&
&
!
aAddon
.
providesUpdatesSecurely
)
{
logger
.
warn
(
Updates
for
add
-
on
{
aAddon
.
id
}
must
be
provided
over
HTTPS
.
)
;
return
false
;
}
if
(
!
aAddon
.
isPlatformCompatible
)
{
logger
.
warn
(
Add
-
on
{
aAddon
.
id
}
is
not
compatible
with
platform
.
)
;
return
false
;
}
if
(
aAddon
.
dependencies
.
length
)
{
let
isActive
=
id
=
>
{
let
active
=
XPIProvider
.
activeAddons
.
get
(
id
)
;
return
active
&
&
!
active
.
disable
;
}
;
if
(
aAddon
.
dependencies
.
some
(
id
=
>
!
isActive
(
id
)
)
)
return
false
;
}
if
(
isDisabledLegacy
(
aAddon
)
)
{
logger
.
warn
(
disabling
legacy
extension
{
aAddon
.
id
}
)
;
return
false
;
}
if
(
!
ALLOW_NON_MPC
&
&
aAddon
.
type
=
=
"
extension
"
&
&
aAddon
.
multiprocessCompatible
!
=
=
true
)
{
logger
.
warn
(
disabling
{
aAddon
.
id
}
since
it
is
not
multiprocess
compatible
)
;
return
false
;
}
if
(
AddonManager
.
checkCompatibility
)
{
if
(
!
aAddon
.
isCompatible
)
{
logger
.
warn
(
Add
-
on
{
aAddon
.
id
}
is
not
compatible
with
application
version
.
)
;
return
false
;
}
}
else
{
let
app
=
aAddon
.
matchingTargetApplication
;
if
(
!
app
)
{
logger
.
warn
(
Add
-
on
{
aAddon
.
id
}
is
not
compatible
with
target
application
.
)
;
return
false
;
}
}
return
true
;
}
function
getExternalType
(
aType
)
{
if
(
aType
in
TYPE_ALIASES
)
return
TYPE_ALIASES
[
aType
]
;
return
aType
;
}
function
getManifestFileForDir
(
aDir
)
{
let
file
=
getFile
(
FILE_RDF_MANIFEST
aDir
)
;
if
(
file
.
exists
(
)
&
&
file
.
isFile
(
)
)
return
file
;
file
.
leafName
=
FILE_WEB_MANIFEST
;
if
(
file
.
exists
(
)
&
&
file
.
isFile
(
)
)
return
file
;
return
null
;
}
function
getAllAliasesForTypes
(
aTypes
)
{
if
(
!
aTypes
)
return
null
;
let
typeset
=
new
Set
(
aTypes
)
;
for
(
let
alias
of
Object
.
keys
(
TYPE_ALIASES
)
)
{
typeset
.
delete
(
alias
)
;
if
(
typeset
.
has
(
TYPE_ALIASES
[
alias
]
)
)
typeset
.
add
(
alias
)
;
}
return
[
.
.
.
typeset
]
;
}
function
syncLoadManifestFromFile
(
aFile
aInstallLocation
)
{
let
success
=
undefined
;
let
result
=
null
;
loadManifestFromFile
(
aFile
aInstallLocation
)
.
then
(
val
=
>
{
success
=
true
;
result
=
val
;
}
val
=
>
{
success
=
false
;
result
=
val
;
}
)
;
Services
.
tm
.
spinEventLoopUntil
(
(
)
=
>
success
!
=
=
undefined
)
;
if
(
!
success
)
throw
result
;
return
result
;
}
function
getURIForResourceInFile
(
aFile
aPath
)
{
if
(
aFile
.
exists
(
)
&
&
aFile
.
isDirectory
(
)
)
{
let
resource
=
aFile
.
clone
(
)
;
if
(
aPath
)
aPath
.
split
(
"
/
"
)
.
forEach
(
part
=
>
resource
.
append
(
part
)
)
;
return
Services
.
io
.
newFileURI
(
resource
)
;
}
return
buildJarURI
(
aFile
aPath
)
;
}
function
buildJarURI
(
aJarfile
aPath
)
{
let
uri
=
Services
.
io
.
newFileURI
(
aJarfile
)
;
uri
=
"
jar
:
"
+
uri
.
spec
+
"
!
/
"
+
aPath
;
return
Services
.
io
.
newURI
(
uri
)
;
}
function
flushJarCache
(
aJarFile
)
{
Services
.
obs
.
notifyObservers
(
aJarFile
"
flush
-
cache
-
entry
"
)
;
Services
.
mm
.
broadcastAsyncMessage
(
MSG_JAR_FLUSH
aJarFile
.
path
)
;
}
function
flushChromeCaches
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
startupcache
-
invalidate
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
message
-
manager
-
flush
-
caches
"
)
;
Services
.
mm
.
broadcastAsyncMessage
(
MSG_MESSAGE_MANAGER_CACHES_FLUSH
null
)
;
}
function
recursiveRemove
(
aFile
)
{
let
isDir
=
null
;
try
{
isDir
=
aFile
.
isDirectory
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
)
return
;
if
(
e
.
result
=
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
return
;
throw
e
;
}
setFilePermissions
(
aFile
isDir
?
FileUtils
.
PERMS_DIRECTORY
:
FileUtils
.
PERMS_FILE
)
;
try
{
aFile
.
remove
(
true
)
;
return
;
}
catch
(
e
)
{
if
(
!
aFile
.
isDirectory
(
)
|
|
aFile
.
isSymlink
(
)
)
{
logger
.
error
(
"
Failed
to
remove
file
"
+
aFile
.
path
e
)
;
throw
e
;
}
}
let
entries
=
getDirectoryEntries
(
aFile
true
)
;
entries
.
forEach
(
recursiveRemove
)
;
try
{
aFile
.
remove
(
true
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
remove
empty
directory
"
+
aFile
.
path
e
)
;
throw
e
;
}
}
function
getDirectoryEntries
(
aDir
aSortEntries
)
{
let
dirEnum
;
try
{
dirEnum
=
aDir
.
directoryEntries
.
QueryInterface
(
Ci
.
nsIDirectoryEnumerator
)
;
let
entries
=
[
]
;
while
(
dirEnum
.
hasMoreElements
(
)
)
entries
.
push
(
dirEnum
.
nextFile
)
;
if
(
aSortEntries
)
{
entries
.
sort
(
function
(
a
b
)
{
return
a
.
path
>
b
.
path
?
-
1
:
1
;
}
)
;
}
return
entries
;
}
catch
(
e
)
{
if
(
aDir
.
exists
(
)
)
{
logger
.
warn
(
"
Can
'
t
iterate
directory
"
+
aDir
.
path
e
)
;
}
return
[
]
;
}
finally
{
if
(
dirEnum
)
{
dirEnum
.
close
(
)
;
}
}
}
function
recordAddonTelemetry
(
aAddon
)
{
let
locale
=
aAddon
.
defaultLocale
;
if
(
locale
)
{
if
(
locale
.
name
)
XPIProvider
.
setTelemetry
(
aAddon
.
id
"
name
"
locale
.
name
)
;
if
(
locale
.
creator
)
XPIProvider
.
setTelemetry
(
aAddon
.
id
"
creator
"
locale
.
creator
)
;
}
}
const
JSON_FIELDS
=
Object
.
freeze
(
[
"
bootstrapped
"
"
changed
"
"
dependencies
"
"
enabled
"
"
enableShims
"
"
file
"
"
hasEmbeddedWebExtension
"
"
lastModifiedTime
"
"
path
"
"
runInSafeMode
"
"
startupData
"
"
type
"
"
version
"
]
)
;
const
BOOTSTRAPPED_FIELDS
=
Object
.
freeze
(
[
"
dependencies
"
"
hasEmbeddedWebExtension
"
"
runInSafeMode
"
"
type
"
"
version
"
]
)
;
class
XPIState
{
constructor
(
location
id
saved
=
{
}
)
{
this
.
location
=
location
;
this
.
id
=
id
;
this
.
type
=
"
extension
"
;
this
.
bootstrapped
=
false
;
this
.
enableShims
=
false
;
for
(
let
prop
of
JSON_FIELDS
)
{
if
(
prop
in
saved
)
{
this
[
prop
]
=
saved
[
prop
]
;
}
}
if
(
saved
.
currentModifiedTime
&
&
saved
.
currentModifiedTime
!
=
this
.
lastModifiedTime
)
{
this
.
lastModifiedTime
=
saved
.
currentModifiedTime
;
this
.
changed
=
true
;
}
if
(
this
.
enabled
)
{
XPIProvider
.
_addURIMapping
(
id
this
.
file
)
;
}
}
static
migrate
(
location
id
saved
bootstrapped
)
{
let
data
=
{
enabled
:
saved
.
e
path
:
descriptorToPath
(
saved
.
d
location
.
dir
)
lastModifiedTime
:
saved
.
mt
|
|
saved
.
st
version
:
saved
.
v
enableShims
:
false
}
;
if
(
bootstrapped
)
{
data
.
bootstrapped
=
true
;
data
.
enabled
=
true
;
data
.
enableShims
=
!
bootstrapped
.
multiprocessCompatible
;
data
.
path
=
descriptorToPath
(
bootstrapped
.
descriptor
location
.
dir
)
;
for
(
let
field
of
BOOTSTRAPPED_FIELDS
)
{
if
(
field
in
bootstrapped
)
{
data
[
field
]
=
bootstrapped
[
field
]
;
}
}
}
return
new
XPIState
(
location
id
data
)
;
}
get
mtime
(
)
{
return
this
.
lastModifiedTime
;
}
get
active
(
)
{
return
this
.
enabled
;
}
get
multiprocessCompatible
(
)
{
return
!
this
.
enableShims
;
}
get
path
(
)
{
return
this
.
file
&
&
this
.
file
.
path
;
}
set
path
(
path
)
{
this
.
file
=
getFile
(
path
this
.
location
.
dir
)
;
}
get
relativePath
(
)
{
if
(
this
.
location
.
dir
&
&
this
.
location
.
dir
.
contains
(
this
.
file
)
)
{
let
path
=
this
.
file
.
getRelativePath
(
this
.
location
.
dir
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
path
=
path
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
return
path
;
}
return
this
.
path
;
}
toJSON
(
)
{
let
json
=
{
enabled
:
this
.
enabled
lastModifiedTime
:
this
.
lastModifiedTime
path
:
this
.
relativePath
version
:
this
.
version
}
;
if
(
this
.
type
!
=
"
extension
"
)
{
json
.
type
=
this
.
type
;
}
if
(
this
.
enableShims
)
{
json
.
enableShims
=
true
;
}
if
(
this
.
bootstrapped
)
{
json
.
bootstrapped
=
true
;
json
.
dependencies
=
this
.
dependencies
;
json
.
runInSafeMode
=
this
.
runInSafeMode
;
json
.
hasEmbeddedWebExtension
=
this
.
hasEmbeddedWebExtension
;
}
if
(
this
.
startupData
)
{
json
.
startupData
=
this
.
startupData
;
}
return
json
;
}
getModTime
(
aFile
aId
)
{
let
mtime
=
(
tryGetMtime
(
getManifestFileForDir
(
aFile
)
)
|
|
tryGetMtime
(
aFile
)
)
;
if
(
!
mtime
)
{
logger
.
warn
(
"
Can
'
t
get
modified
time
of
{
file
}
"
{
file
:
aFile
.
path
}
)
;
}
this
.
changed
=
mtime
!
=
this
.
lastModifiedTime
;
this
.
lastModifiedTime
=
mtime
;
return
this
.
changed
;
}
syncWithDB
(
aDBAddon
aUpdated
=
false
)
{
logger
.
debug
(
"
Updating
XPIState
for
"
+
JSON
.
stringify
(
aDBAddon
)
)
;
let
mustGetMod
=
(
aDBAddon
.
visible
&
&
!
aDBAddon
.
disabled
&
&
!
this
.
enabled
)
;
if
(
aDBAddon
.
type
=
=
"
theme
"
)
{
this
.
enabled
=
aDBAddon
.
internalName
=
=
XPIProvider
.
selectedSkin
;
}
else
{
this
.
enabled
=
aDBAddon
.
visible
&
&
!
aDBAddon
.
disabled
;
}
this
.
version
=
aDBAddon
.
version
;
this
.
type
=
aDBAddon
.
type
;
this
.
enableShims
=
this
.
type
=
=
"
extension
"
&
&
!
aDBAddon
.
multiprocessCompatible
;
this
.
startupData
=
aDBAddon
.
startupData
;
this
.
bootstrapped
=
!
!
aDBAddon
.
bootstrap
;
if
(
this
.
bootstrapped
)
{
this
.
hasEmbeddedWebExtension
=
aDBAddon
.
hasEmbeddedWebExtension
;
this
.
dependencies
=
aDBAddon
.
dependencies
;
this
.
runInSafeMode
=
canRunInSafeMode
(
aDBAddon
)
;
}
if
(
aUpdated
|
|
mustGetMod
)
{
this
.
getModTime
(
this
.
file
aDBAddon
.
id
)
;
if
(
this
.
lastModifiedTime
!
=
aDBAddon
.
updateDate
)
{
aDBAddon
.
updateDate
=
this
.
lastModifiedTime
;
if
(
XPIDatabase
.
initialized
)
{
XPIDatabase
.
saveChanges
(
)
;
}
}
}
}
}
class
XPIStateLocation
extends
Map
{
constructor
(
name
path
saved
=
{
}
)
{
super
(
)
;
this
.
name
=
name
;
this
.
path
=
path
|
|
saved
.
path
|
|
null
;
this
.
dir
=
this
.
path
&
&
new
nsIFile
(
this
.
path
)
;
for
(
let
[
id
data
]
of
Object
.
entries
(
saved
.
addons
|
|
{
}
)
)
{
let
xpiState
=
this
.
_addState
(
id
data
)
;
xpiState
.
wasRestored
=
true
;
}
}
toJSON
(
)
{
let
json
=
{
addons
:
{
}
}
;
if
(
this
.
path
)
{
json
.
path
=
this
.
path
;
}
if
(
STARTUP_MTIME_SCOPES
.
includes
(
this
.
name
)
)
{
json
.
checkStartupModifications
=
true
;
}
for
(
let
[
id
addon
]
of
this
.
entries
(
)
)
{
if
(
addon
.
type
!
=
"
experiment
"
)
{
json
.
addons
[
id
]
=
addon
;
}
}
return
json
;
}
_addState
(
addonId
saved
)
{
let
xpiState
=
new
XPIState
(
this
addonId
saved
)
;
this
.
set
(
addonId
xpiState
)
;
return
xpiState
;
}
addAddon
(
addon
)
{
logger
.
debug
(
"
XPIStates
adding
add
-
on
{
id
}
in
{
location
}
:
{
path
}
"
addon
)
;
let
xpiState
=
this
.
_addState
(
addon
.
id
{
file
:
addon
.
_sourceBundle
}
)
;
xpiState
.
syncWithDB
(
addon
true
)
;
XPIProvider
.
setTelemetry
(
addon
.
id
"
location
"
this
.
name
)
;
}
addFile
(
addonId
file
)
{
let
xpiState
=
this
.
_addState
(
addonId
{
enabled
:
false
file
:
file
.
clone
(
)
}
)
;
xpiState
.
getModTime
(
xpiState
.
file
addonId
)
;
return
xpiState
;
}
migrateAddon
(
id
state
bootstrapped
)
{
this
.
set
(
id
XPIState
.
migrate
(
this
id
state
bootstrapped
)
)
;
}
}
this
.
XPIStates
=
{
db
:
null
_jsonFile
:
null
sideLoadedAddons
:
new
Map
(
)
get
size
(
)
{
let
count
=
0
;
if
(
this
.
db
)
{
for
(
let
location
of
this
.
db
.
values
(
)
)
{
count
+
=
location
.
size
;
}
}
return
count
;
}
migrateStateFromPrefs
(
)
{
logger
.
info
(
"
No
addonStartup
.
json
found
.
Attempting
to
migrate
data
from
preferences
"
)
;
let
state
;
let
bootstrappedAddons
;
try
{
state
=
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
PREF_XPI_STATE
)
)
;
bootstrappedAddons
=
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
PREF_BOOTSTRAP_ADDONS
"
{
}
"
)
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Error
parsing
extensions
.
xpiState
and
"
+
"
extensions
.
bootstrappedAddons
:
{
error
}
"
{
error
:
e
}
)
;
}
for
(
let
[
locName
addons
]
of
Object
.
entries
(
state
)
)
{
for
(
let
[
id
addon
]
of
Object
.
entries
(
addons
)
)
{
let
loc
=
this
.
getLocation
(
locName
)
;
if
(
loc
)
{
loc
.
migrateAddon
(
id
addon
bootstrappedAddons
[
id
]
|
|
null
)
;
}
}
}
for
(
let
pref
of
OBSOLETE_PREFERENCES
)
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
OS
.
File
.
remove
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FILE_XPI_ADDONS_LIST
)
)
;
let
data
=
JSON
.
parse
(
JSON
.
stringify
(
this
)
)
;
logger
.
debug
(
"
Migrated
data
:
{
}
"
data
)
;
return
data
;
}
loadExtensionState
(
)
{
let
state
;
try
{
state
=
aomStartup
.
readStartupData
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Error
parsing
extensions
state
:
{
error
}
"
{
error
:
e
}
)
;
}
if
(
!
state
&
&
Services
.
prefs
.
getPrefType
(
PREF_XPI_STATE
)
!
=
Ci
.
nsIPrefBranch
.
PREF_INVALID
)
{
try
{
state
=
this
.
migrateStateFromPrefs
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Error
migrating
extensions
.
xpiState
and
"
+
"
extensions
.
bootstrappedAddons
:
{
error
}
"
{
error
:
e
}
)
;
}
}
logger
.
debug
(
"
Loaded
add
-
on
state
:
{
}
"
state
)
;
return
state
|
|
{
}
;
}
getInstallState
(
ignoreSideloads
=
true
)
{
if
(
!
this
.
db
)
{
this
.
db
=
new
Map
(
)
;
}
let
oldState
=
this
.
initialStateData
|
|
this
.
loadExtensionState
(
)
;
this
.
initialStateData
=
oldState
;
let
changed
=
false
;
let
oldLocations
=
new
Set
(
Object
.
keys
(
oldState
)
)
;
for
(
let
location
of
XPIProvider
.
installLocations
)
{
oldLocations
.
delete
(
location
.
name
)
;
let
loc
=
this
.
getLocation
(
location
.
name
location
.
path
|
|
null
oldState
[
location
.
name
]
|
|
undefined
)
;
changed
=
changed
|
|
loc
.
changed
;
if
(
ignoreSideloads
&
&
!
(
location
.
scope
&
gStartupScanScopes
)
)
{
continue
;
}
if
(
location
.
name
=
=
KEY_APP_TEMPORARY
)
{
continue
;
}
let
knownIds
=
new
Set
(
loc
.
keys
(
)
)
;
for
(
let
[
id
file
]
of
location
.
getAddonLocations
(
true
)
)
{
knownIds
.
delete
(
id
)
;
let
xpiState
=
loc
.
get
(
id
)
;
if
(
!
xpiState
)
{
logger
.
debug
(
"
New
add
-
on
{
id
}
in
{
location
}
"
{
id
location
:
location
.
name
}
)
;
changed
=
true
;
xpiState
=
loc
.
addFile
(
id
file
)
;
if
(
!
location
.
isSystem
)
{
this
.
sideLoadedAddons
.
set
(
id
xpiState
)
;
}
}
else
{
let
addonChanged
=
(
xpiState
.
getModTime
(
file
id
)
|
|
file
.
path
!
=
xpiState
.
path
)
;
xpiState
.
file
=
file
.
clone
(
)
;
if
(
addonChanged
)
{
changed
=
true
;
logger
.
debug
(
"
Changed
add
-
on
{
id
}
in
{
location
}
"
{
id
location
:
location
.
name
}
)
;
}
else
{
logger
.
debug
(
"
Existing
add
-
on
{
id
}
in
{
location
}
"
{
id
location
:
location
.
name
}
)
;
}
}
XPIProvider
.
setTelemetry
(
id
"
location
"
location
.
name
)
;
}
for
(
let
id
of
knownIds
)
{
loc
.
delete
(
id
)
;
changed
=
true
;
}
}
changed
=
changed
|
|
oldLocations
.
size
>
0
;
logger
.
debug
(
"
getInstallState
changed
:
{
rv
}
state
:
{
state
}
"
{
rv
:
changed
state
:
this
.
db
}
)
;
return
changed
;
}
getLocation
(
name
path
saved
)
{
let
location
=
this
.
db
.
get
(
name
)
;
if
(
path
&
&
location
&
&
location
.
path
!
=
path
)
{
location
=
null
;
saved
=
null
;
}
if
(
!
location
|
|
(
path
&
&
location
.
path
!
=
path
)
)
{
let
loc
=
XPIProvider
.
installLocationsByName
[
name
]
;
if
(
loc
)
{
location
=
new
XPIStateLocation
(
name
path
|
|
loc
.
path
|
|
null
saved
)
;
this
.
db
.
set
(
name
location
)
;
}
}
return
location
;
}
getAddon
(
aLocation
aId
)
{
let
location
=
this
.
db
.
get
(
aLocation
)
;
return
location
&
&
location
.
get
(
aId
)
;
}
findAddon
(
aId
aFilter
=
location
=
>
true
)
{
for
(
let
location
of
this
.
db
.
values
(
)
)
{
if
(
!
aFilter
(
location
)
)
{
continue
;
}
if
(
location
.
has
(
aId
)
)
{
return
location
.
get
(
aId
)
;
}
}
return
undefined
;
}
*
enabledAddons
(
)
{
for
(
let
location
of
this
.
db
.
values
(
)
)
{
for
(
let
entry
of
location
.
values
(
)
)
{
if
(
entry
.
enabled
)
{
yield
entry
;
}
}
}
}
*
initialEnabledAddons
(
)
{
for
(
let
addon
of
this
.
enabledAddons
(
)
)
{
if
(
addon
.
wasRestored
)
{
yield
addon
;
}
}
}
*
bootstrappedAddons
(
)
{
for
(
let
addon
of
this
.
enabledAddons
(
)
)
{
if
(
addon
.
bootstrapped
)
{
yield
addon
;
}
}
}
addAddon
(
aAddon
)
{
let
location
=
this
.
getLocation
(
aAddon
.
_installLocation
.
name
)
;
location
.
addAddon
(
aAddon
)
;
}
save
(
)
{
if
(
!
this
.
_jsonFile
)
{
this
.
_jsonFile
=
new
JSONFile
(
{
path
:
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FILE_XPI_STATES
)
finalizeAt
:
AddonManager
.
shutdown
compression
:
"
lz4
"
}
)
;
this
.
_jsonFile
.
data
=
this
;
}
this
.
_jsonFile
.
saveSoon
(
)
;
}
toJSON
(
)
{
let
data
=
{
}
;
for
(
let
[
key
loc
]
of
this
.
db
.
entries
(
)
)
{
if
(
key
!
=
TemporaryInstallLocation
.
name
&
&
loc
.
size
)
{
data
[
key
]
=
loc
;
}
}
return
data
;
}
removeAddon
(
aLocation
aId
)
{
logger
.
debug
(
"
Removing
XPIState
for
"
+
aLocation
+
"
:
"
+
aId
)
;
let
location
=
this
.
db
.
get
(
aLocation
)
;
if
(
location
)
{
location
.
delete
(
aId
)
;
if
(
location
.
size
=
=
0
)
{
this
.
db
.
delete
(
aLocation
)
;
}
this
.
save
(
)
;
}
}
disableAddon
(
aId
)
{
logger
.
debug
(
Disabling
XPIState
for
{
aId
}
)
;
let
state
=
this
.
findAddon
(
aId
)
;
if
(
state
)
{
state
.
enabled
=
false
;
}
}
}
;
this
.
XPIProvider
=
{
get
name
(
)
{
return
"
XPIProvider
"
;
}
BOOTSTRAP_REASONS
:
Object
.
freeze
(
BOOTSTRAP_REASONS
)
installLocations
:
null
installLocationsByName
:
null
installs
:
null
defaultSkin
:
"
classic
/
1
.
0
"
currentSkin
:
null
selectedSkin
:
null
minCompatibleAppVersion
:
null
minCompatiblePlatformVersion
:
null
activeAddons
:
new
Map
(
)
extensionsActive
:
false
allAppGlobal
:
true
runPhase
:
XPI_STARTING
_telemetryDetails
:
{
}
_addonFileMap
:
new
Map
(
)
_closing
:
false
get
isDBLoaded
(
)
{
return
gLazyObjectsLoaded
&
&
XPIDatabase
.
initialized
;
}
addonIsActive
(
addonId
)
{
let
state
=
XPIStates
.
findAddon
(
addonId
)
;
return
state
&
&
state
.
enabled
;
}
sortBootstrappedAddons
(
)
{
function
compare
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
0
;
}
return
(
a
<
b
)
?
-
1
:
1
;
}
let
list
=
Array
.
from
(
XPIStates
.
bootstrappedAddons
(
)
)
;
list
.
sort
(
(
a
b
)
=
>
compare
(
a
.
id
b
.
id
)
)
;
let
addons
=
{
}
;
for
(
let
entry
of
list
)
{
addons
[
entry
.
id
]
=
entry
;
}
let
res
=
new
Set
(
)
;
let
seen
=
new
Set
(
)
;
let
add
=
addon
=
>
{
seen
.
add
(
addon
.
id
)
;
for
(
let
id
of
addon
.
dependencies
|
|
[
]
)
{
if
(
id
in
addons
&
&
!
seen
.
has
(
id
)
)
{
add
(
addons
[
id
]
)
;
}
}
res
.
add
(
addon
.
id
)
;
}
;
Object
.
values
(
addons
)
.
forEach
(
add
)
;
return
Array
.
from
(
res
id
=
>
addons
[
id
]
)
;
}
setTelemetry
(
aId
aName
aValue
)
{
if
(
!
this
.
_telemetryDetails
[
aId
]
)
this
.
_telemetryDetails
[
aId
]
=
{
}
;
this
.
_telemetryDetails
[
aId
]
[
aName
]
=
aValue
;
}
_inProgress
:
[
]
doing
(
aCancellable
)
{
this
.
_inProgress
.
push
(
aCancellable
)
;
}
done
(
aCancellable
)
{
let
i
=
this
.
_inProgress
.
indexOf
(
aCancellable
)
;
if
(
i
!
=
-
1
)
{
this
.
_inProgress
.
splice
(
i
1
)
;
return
true
;
}
return
false
;
}
cancelAll
(
)
{
while
(
this
.
_inProgress
.
length
>
0
)
{
let
c
=
this
.
_inProgress
.
shift
(
)
;
try
{
c
.
cancel
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Cancel
failed
"
e
)
;
}
}
}
_addURIMapping
(
aID
aFile
)
{
logger
.
info
(
"
Mapping
"
+
aID
+
"
to
"
+
aFile
.
path
)
;
this
.
_addonFileMap
.
set
(
aID
aFile
.
path
)
;
AddonPathService
.
insertPath
(
aFile
.
path
aID
)
;
}
_resolveURIToFile
(
aURI
)
{
switch
(
aURI
.
scheme
)
{
case
"
jar
"
:
case
"
file
"
:
if
(
aURI
instanceof
Ci
.
nsIJARURI
)
{
return
this
.
_resolveURIToFile
(
aURI
.
JARFile
)
;
}
return
aURI
;
case
"
chrome
"
:
aURI
=
ChromeRegistry
.
convertChromeURL
(
aURI
)
;
return
this
.
_resolveURIToFile
(
aURI
)
;
case
"
resource
"
:
aURI
=
Services
.
io
.
newURI
(
ResProtocolHandler
.
resolveURI
(
aURI
)
)
;
return
this
.
_resolveURIToFile
(
aURI
)
;
case
"
view
-
source
"
:
aURI
=
Services
.
io
.
newURI
(
aURI
.
pathQueryRef
)
;
return
this
.
_resolveURIToFile
(
aURI
)
;
case
"
about
"
:
if
(
aURI
.
spec
=
=
"
about
:
blank
"
)
{
return
null
;
}
let
chan
;
try
{
chan
=
NetUtil
.
newChannel
(
{
uri
:
aURI
loadUsingSystemPrincipal
:
true
}
)
;
}
catch
(
ex
)
{
return
null
;
}
if
(
chan
.
URI
.
equals
(
aURI
)
)
{
return
null
;
}
return
this
.
_resolveURIToFile
(
chan
.
URI
.
clone
(
)
)
;
default
:
return
null
;
}
}
startup
(
aAppChanged
aOldAppVersion
aOldPlatformVersion
)
{
function
addDirectoryInstallLocation
(
aName
aKey
aPaths
aScope
aLocked
)
{
try
{
var
dir
=
FileUtils
.
getDir
(
aKey
aPaths
)
;
}
catch
(
e
)
{
logger
.
debug
(
"
Skipping
unavailable
install
location
"
+
aName
)
;
return
;
}
try
{
var
location
=
aLocked
?
new
DirectoryInstallLocation
(
aName
dir
aScope
)
:
new
MutableDirectoryInstallLocation
(
aName
dir
aScope
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
add
directory
install
location
"
+
aName
e
)
;
return
;
}
XPIProvider
.
installLocations
.
push
(
location
)
;
XPIProvider
.
installLocationsByName
[
location
.
name
]
=
location
;
}
function
addBuiltInInstallLocation
(
name
key
paths
scope
)
{
try
{
let
dir
=
FileUtils
.
getDir
(
key
paths
)
;
let
location
=
new
BuiltInInstallLocation
(
name
dir
scope
)
;
XPIProvider
.
installLocations
.
push
(
location
)
;
XPIProvider
.
installLocationsByName
[
location
.
name
]
=
location
;
}
catch
(
e
)
{
logger
.
warn
(
Failed
to
add
built
-
in
install
location
{
name
}
e
)
;
}
}
function
addSystemAddonInstallLocation
(
aName
aKey
aPaths
aScope
)
{
try
{
var
dir
=
FileUtils
.
getDir
(
aKey
aPaths
)
;
}
catch
(
e
)
{
logger
.
debug
(
"
Skipping
unavailable
install
location
"
+
aName
)
;
return
;
}
try
{
var
location
=
new
SystemAddonInstallLocation
(
aName
dir
aScope
aAppChanged
!
=
=
false
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
add
system
add
-
on
install
location
"
+
aName
e
)
;
return
;
}
XPIProvider
.
installLocations
.
push
(
location
)
;
XPIProvider
.
installLocationsByName
[
location
.
name
]
=
location
;
}
function
addRegistryInstallLocation
(
aName
aRootkey
aScope
)
{
try
{
var
location
=
new
WinRegInstallLocation
(
aName
aRootkey
aScope
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
add
registry
install
location
"
+
aName
e
)
;
return
;
}
XPIProvider
.
installLocations
.
push
(
location
)
;
XPIProvider
.
installLocationsByName
[
location
.
name
]
=
location
;
}
try
{
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_startup_begin
"
)
;
logger
.
debug
(
"
startup
"
)
;
this
.
runPhase
=
XPI_STARTING
;
this
.
installs
=
new
Set
(
)
;
this
.
installLocations
=
[
]
;
this
.
installLocationsByName
=
{
}
;
this
.
_telemetryDetails
=
{
}
;
AddonManagerPrivate
.
setTelemetryDetails
(
"
XPI
"
this
.
_telemetryDetails
)
;
let
hasRegistry
=
(
"
nsIWindowsRegKey
"
in
Ci
)
;
let
enabledScopes
=
Services
.
prefs
.
getIntPref
(
PREF_EM_ENABLED_SCOPES
AddonManager
.
SCOPE_ALL
)
;
XPIProvider
.
installLocations
.
push
(
TemporaryInstallLocation
)
;
XPIProvider
.
installLocationsByName
[
TemporaryInstallLocation
.
name
]
=
TemporaryInstallLocation
;
addDirectoryInstallLocation
(
KEY_APP_PROFILE
KEY_PROFILEDIR
[
DIR_EXTENSIONS
]
AddonManager
.
SCOPE_PROFILE
false
)
;
addSystemAddonInstallLocation
(
KEY_APP_SYSTEM_ADDONS
KEY_PROFILEDIR
[
DIR_SYSTEM_ADDONS
]
AddonManager
.
SCOPE_PROFILE
)
;
addBuiltInInstallLocation
(
KEY_APP_SYSTEM_DEFAULTS
KEY_APP_FEATURES
[
]
AddonManager
.
SCOPE_PROFILE
)
;
if
(
enabledScopes
&
AddonManager
.
SCOPE_USER
)
{
addDirectoryInstallLocation
(
KEY_APP_SYSTEM_USER
"
XREUSysExt
"
[
Services
.
appinfo
.
ID
]
AddonManager
.
SCOPE_USER
true
)
;
if
(
hasRegistry
)
{
addRegistryInstallLocation
(
"
winreg
-
app
-
user
"
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
AddonManager
.
SCOPE_USER
)
;
}
}
addDirectoryInstallLocation
(
KEY_APP_GLOBAL
KEY_ADDON_APP_DIR
[
DIR_EXTENSIONS
]
AddonManager
.
SCOPE_APPLICATION
true
)
;
if
(
enabledScopes
&
AddonManager
.
SCOPE_SYSTEM
)
{
addDirectoryInstallLocation
(
KEY_APP_SYSTEM_SHARE
"
XRESysSExtPD
"
[
Services
.
appinfo
.
ID
]
AddonManager
.
SCOPE_SYSTEM
true
)
;
addDirectoryInstallLocation
(
KEY_APP_SYSTEM_LOCAL
"
XRESysLExtPD
"
[
Services
.
appinfo
.
ID
]
AddonManager
.
SCOPE_SYSTEM
true
)
;
if
(
hasRegistry
)
{
addRegistryInstallLocation
(
"
winreg
-
app
-
global
"
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_LOCAL_MACHINE
AddonManager
.
SCOPE_SYSTEM
)
;
}
}
let
defaultPrefs
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
this
.
defaultSkin
=
defaultPrefs
.
getStringPref
(
PREF_GENERAL_SKINS_SELECTEDSKIN
"
classic
/
1
.
0
"
)
;
this
.
currentSkin
=
Services
.
prefs
.
getStringPref
(
PREF_GENERAL_SKINS_SELECTEDSKIN
this
.
defaultSkin
)
;
this
.
selectedSkin
=
this
.
currentSkin
;
this
.
applyThemeChange
(
)
;
this
.
minCompatibleAppVersion
=
Services
.
prefs
.
getStringPref
(
PREF_EM_MIN_COMPAT_APP_VERSION
null
)
;
this
.
minCompatiblePlatformVersion
=
Services
.
prefs
.
getStringPref
(
PREF_EM_MIN_COMPAT_PLATFORM_VERSION
null
)
;
Services
.
prefs
.
addObserver
(
PREF_EM_MIN_COMPAT_APP_VERSION
this
)
;
Services
.
prefs
.
addObserver
(
PREF_EM_MIN_COMPAT_PLATFORM_VERSION
this
)
;
if
(
!
AppConstants
.
MOZ_REQUIRE_SIGNING
|
|
Cu
.
isInAutomation
)
Services
.
prefs
.
addObserver
(
PREF_XPI_SIGNATURES_REQUIRED
this
)
;
Services
.
prefs
.
addObserver
(
PREF_ALLOW_LEGACY
this
)
;
Services
.
prefs
.
addObserver
(
PREF_ALLOW_NON_MPC
this
)
;
Services
.
obs
.
addObserver
(
this
NOTIFICATION_FLUSH_PERMISSIONS
)
;
Services
.
obs
.
addObserver
(
this
NOTIFICATION_TOOLBOX_CONNECTION_CHANGE
)
;
let
flushCaches
=
this
.
checkForChanges
(
aAppChanged
aOldAppVersion
aOldPlatformVersion
)
;
this
.
applyThemeChange
(
)
;
AddonManagerPrivate
.
markProviderSafe
(
this
)
;
if
(
aAppChanged
&
&
!
this
.
allAppGlobal
&
&
Services
.
prefs
.
getBoolPref
(
PREF_EM_SHOW_MISMATCH_UI
true
)
&
&
AddonManager
.
updateEnabled
)
{
let
addonsToUpdate
=
this
.
shouldForceUpdateCheck
(
aAppChanged
)
;
if
(
addonsToUpdate
)
{
this
.
noLegacyStartupCheck
(
addonsToUpdate
)
;
flushCaches
=
true
;
}
}
if
(
flushCaches
)
{
Services
.
obs
.
notifyObservers
(
null
"
startupcache
-
invalidate
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
chrome
-
flush
-
skin
-
caches
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
chrome
-
flush
-
caches
"
)
;
}
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
try
{
Services
.
appinfo
.
annotateCrashReport
(
"
Theme
"
this
.
currentSkin
)
;
}
catch
(
e
)
{
}
try
{
Services
.
appinfo
.
annotateCrashReport
(
"
EMCheckCompatibility
"
AddonManager
.
checkCompatibility
)
;
}
catch
(
e
)
{
}
this
.
addAddonsToCrashReporter
(
)
;
}
try
{
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_bootstrap_addons_begin
"
)
;
for
(
let
addon
of
this
.
sortBootstrappedAddons
(
)
)
{
let
activeAddon
=
this
.
activeAddons
.
get
(
addon
.
id
)
;
if
(
activeAddon
&
&
activeAddon
.
started
)
{
continue
;
}
try
{
let
reason
=
BOOTSTRAP_REASONS
.
APP_STARTUP
;
if
(
AddonManager
.
getStartupChanges
(
AddonManager
.
STARTUP_CHANGE_INSTALLED
)
.
indexOf
(
addon
.
id
)
!
=
=
-
1
)
reason
=
BOOTSTRAP_REASONS
.
ADDON_INSTALL
;
this
.
callBootstrapMethod
(
addon
addon
.
file
"
startup
"
reason
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
load
bootstrap
addon
"
+
addon
.
id
+
"
from
"
+
addon
.
descriptor
e
)
;
}
}
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_bootstrap_addons_end
"
)
;
}
catch
(
e
)
{
logger
.
error
(
"
bootstrap
startup
failed
"
e
)
;
AddonManagerPrivate
.
recordException
(
"
XPI
-
BOOTSTRAP
"
"
startup
failed
"
e
)
;
}
Services
.
obs
.
addObserver
(
{
observe
(
aSubject
aTopic
aData
)
{
XPIProvider
.
cleanupTemporaryAddons
(
)
;
XPIProvider
.
_closing
=
true
;
for
(
let
addon
of
XPIProvider
.
sortBootstrappedAddons
(
)
.
reverse
(
)
)
{
let
activeAddon
=
XPIProvider
.
activeAddons
.
get
(
addon
.
id
)
;
if
(
!
activeAddon
|
|
!
activeAddon
.
started
)
{
continue
;
}
let
reason
=
BOOTSTRAP_REASONS
.
APP_SHUTDOWN
;
if
(
addon
.
disable
)
{
reason
=
BOOTSTRAP_REASONS
.
ADDON_DISABLE
;
}
else
if
(
addon
.
location
.
name
=
=
KEY_APP_TEMPORARY
)
{
reason
=
BOOTSTRAP_REASONS
.
ADDON_UNINSTALL
;
let
existing
=
XPIStates
.
findAddon
(
addon
.
id
loc
=
>
loc
.
name
!
=
TemporaryInstallLocation
.
name
)
;
if
(
existing
)
{
reason
=
newVersionReason
(
addon
.
version
existing
.
version
)
;
}
}
XPIProvider
.
callBootstrapMethod
(
addon
addon
.
file
"
shutdown
"
reason
)
;
}
Services
.
obs
.
removeObserver
(
this
"
quit
-
application
-
granted
"
)
;
}
}
"
quit
-
application
-
granted
"
)
;
Services
.
obs
.
addObserver
(
{
observe
(
aSubject
aTopic
aData
)
{
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_finalUIStartup
"
)
;
XPIProvider
.
runPhase
=
XPI_AFTER_UI_STARTUP
;
Services
.
obs
.
removeObserver
(
this
"
final
-
ui
-
startup
"
)
;
}
}
"
final
-
ui
-
startup
"
)
;
if
(
!
this
.
isDBLoaded
)
{
const
EVENTS
=
[
"
sessionstore
-
windows
-
restored
"
"
xul
-
window
-
visible
"
"
test
-
load
-
xpi
-
database
"
]
;
let
observer
=
{
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
xul
-
window
-
visible
"
&
&
!
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
toolbox
"
)
)
{
return
;
}
for
(
let
event
of
EVENTS
)
{
Services
.
obs
.
removeObserver
(
observer
event
)
;
}
XPIDatabase
.
asyncLoadDB
(
)
;
}
}
;
for
(
let
event
of
EVENTS
)
{
Services
.
obs
.
addObserver
(
observer
event
)
;
}
}
AddonManagerPrivate
.
recordTimestamp
(
"
XPI_startup_end
"
)
;
this
.
extensionsActive
=
true
;
this
.
runPhase
=
XPI_BEFORE_UI_STARTUP
;
let
timerManager
=
Cc
[
"
mozilla
.
org
/
updates
/
timer
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateTimerManager
)
;
timerManager
.
registerTimer
(
"
xpi
-
signature
-
verification
"
(
)
=
>
{
this
.
verifySignatures
(
)
;
}
XPI_SIGNATURE_CHECK_PERIOD
)
;
}
catch
(
e
)
{
logger
.
error
(
"
startup
failed
"
e
)
;
AddonManagerPrivate
.
recordException
(
"
XPI
"
"
startup
failed
"
e
)
;
}
}
async
shutdown
(
)
{
logger
.
debug
(
"
shutdown
"
)
;
this
.
cancelAll
(
)
;
this
.
activeAddons
.
clear
(
)
;
this
.
allAppGlobal
=
true
;
if
(
Services
.
prefs
.
getBoolPref
(
PREF_PENDING_OPERATIONS
false
)
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_pending_ops
"
1
)
;
XPIDatabase
.
updateActiveAddons
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
false
)
;
}
if
(
!
XPIDatabase
.
initialized
)
{
await
XPIDatabase
.
asyncLoadDB
(
)
;
}
this
.
installs
=
null
;
this
.
installLocations
=
null
;
this
.
installLocationsByName
=
null
;
this
.
extensionsActive
=
false
;
this
.
_addonFileMap
.
clear
(
)
;
await
XPIDatabase
.
shutdown
(
)
;
}
cleanupTemporaryAddons
(
)
{
let
tempLocation
=
XPIStates
.
getLocation
(
TemporaryInstallLocation
.
name
)
;
if
(
tempLocation
)
{
for
(
let
[
id
addon
]
of
tempLocation
.
entries
(
)
)
{
tempLocation
.
delete
(
id
)
;
let
reason
=
BOOTSTRAP_REASONS
.
ADDON_UNINSTALL
;
let
existing
=
XPIStates
.
findAddon
(
id
loc
=
>
loc
!
=
tempLocation
)
;
let
callUpdate
=
false
;
if
(
existing
)
{
reason
=
newVersionReason
(
addon
.
version
existing
.
version
)
;
callUpdate
=
(
isWebExtension
(
addon
.
type
)
&
&
isWebExtension
(
existing
.
type
)
)
;
}
this
.
callBootstrapMethod
(
addon
addon
.
file
"
shutdown
"
reason
)
;
if
(
!
callUpdate
)
{
this
.
callBootstrapMethod
(
addon
addon
.
file
"
uninstall
"
reason
)
;
}
this
.
unloadBootstrapScope
(
id
)
;
TemporaryInstallLocation
.
uninstallAddon
(
id
)
;
XPIStates
.
removeAddon
(
TemporaryInstallLocation
.
name
id
)
;
if
(
existing
)
{
let
newAddon
=
XPIDatabase
.
makeAddonLocationVisible
(
id
existing
.
location
.
name
)
;
let
file
=
new
nsIFile
(
newAddon
.
path
)
;
let
data
=
{
oldVersion
:
addon
.
version
}
;
let
method
=
callUpdate
?
"
update
"
:
"
install
"
;
this
.
callBootstrapMethod
(
newAddon
file
method
reason
data
)
;
}
}
}
}
applyThemeChange
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
PREF_SKIN_SWITCHPENDING
false
)
)
return
;
try
{
this
.
selectedSkin
=
Services
.
prefs
.
getCharPref
(
PREF_SKIN_TO_SELECT
)
;
Services
.
prefs
.
setCharPref
(
PREF_GENERAL_SKINS_SELECTEDSKIN
this
.
selectedSkin
)
;
Services
.
prefs
.
clearUserPref
(
PREF_SKIN_TO_SELECT
)
;
logger
.
debug
(
"
Changed
skin
to
"
+
this
.
selectedSkin
)
;
this
.
currentSkin
=
this
.
selectedSkin
;
}
catch
(
e
)
{
logger
.
error
(
"
Error
applying
theme
change
"
e
)
;
}
Services
.
prefs
.
clearUserPref
(
PREF_SKIN_SWITCHPENDING
)
;
}
shouldForceUpdateCheck
(
aAppChanged
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_metadata_age
"
AddonRepository
.
metadataAge
(
)
)
;
let
startupChanges
=
AddonManager
.
getStartupChanges
(
AddonManager
.
STARTUP_CHANGE_DISABLED
)
;
logger
.
debug
(
"
shouldForceUpdateCheck
startupChanges
:
"
+
startupChanges
.
toSource
(
)
)
;
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startup_disabled
"
startupChanges
.
length
)
;
let
forceUpdate
=
[
]
;
if
(
startupChanges
.
length
>
0
)
{
let
addons
=
XPIDatabase
.
getAddons
(
)
;
for
(
let
addon
of
addons
)
{
if
(
(
startupChanges
.
indexOf
(
addon
.
id
)
!
=
-
1
)
&
&
(
addon
.
permissions
(
)
&
AddonManager
.
PERM_CAN_UPGRADE
)
&
&
(
!
addon
.
isCompatible
|
|
isDisabledLegacy
(
addon
)
)
)
{
logger
.
debug
(
"
shouldForceUpdateCheck
:
can
upgrade
disabled
add
-
on
"
+
addon
.
id
)
;
forceUpdate
.
push
(
addon
.
id
)
;
}
}
}
if
(
forceUpdate
.
length
>
0
)
{
return
forceUpdate
;
}
return
null
;
}
noLegacyStartupCheck
(
ids
)
{
let
started
=
new
Set
(
)
;
const
DIALOG
=
"
chrome
:
/
/
mozapps
/
content
/
extensions
/
update
.
html
"
;
const
SHOW_DIALOG_DELAY
=
1000
;
const
SHOW_CANCEL_DELAY
=
30000
;
let
updateProgress
=
val
=
>
{
}
;
let
progressByID
=
new
Map
(
)
;
function
setProgress
(
id
val
)
{
progressByID
.
set
(
id
val
)
;
updateProgress
(
Array
.
from
(
progressByID
.
values
(
)
)
.
reduce
(
(
a
b
)
=
>
a
+
b
)
/
progressByID
.
size
)
;
}
let
checkOne
=
async
(
id
)
=
>
{
logger
.
debug
(
Checking
for
updates
to
disabled
addon
{
id
}
\
n
)
;
setProgress
(
id
0
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
let
install
=
await
new
Promise
(
resolve
=
>
addon
.
findUpdates
(
{
onUpdateFinished
(
)
{
resolve
(
null
)
;
}
onUpdateAvailable
(
addon
install
)
{
resolve
(
install
)
;
}
}
AddonManager
.
UPDATE_WHEN_NEW_APP_INSTALLED
)
)
;
if
(
!
install
)
{
setProgress
(
id
1
)
;
return
;
}
setProgress
(
id
0
.
1
)
;
let
installPromise
=
new
Promise
(
resolve
=
>
{
let
finish
=
(
)
=
>
{
setProgress
(
id
1
)
;
resolve
(
)
;
}
;
install
.
addListener
(
{
onDownloadProgress
(
)
{
if
(
install
.
maxProgress
!
=
0
)
{
setProgress
(
id
0
.
1
+
0
.
8
*
install
.
progress
/
install
.
maxProgress
)
;
}
}
onDownloadEnded
(
)
{
setProgress
(
id
0
.
9
)
;
}
onDownloadFailed
:
finish
onInstallFailed
:
finish
onInstallEnded
(
)
{
started
.
add
(
id
)
;
AddonManagerPrivate
.
addStartupChange
(
AddonManager
.
STARTUP_CHANGE_CHANGED
id
)
;
finish
(
)
;
}
}
)
;
}
)
;
install
.
install
(
)
;
await
installPromise
;
}
;
let
finished
=
false
;
Promise
.
all
(
ids
.
map
(
checkOne
)
)
.
then
(
(
)
=
>
{
finished
=
true
;
}
)
;
let
window
;
let
timer
=
setTimeout
(
(
)
=
>
{
const
FEATURES
=
"
chrome
dialog
centerscreen
scrollbars
=
no
"
;
window
=
Services
.
ww
.
openWindow
(
null
DIALOG
"
"
FEATURES
null
)
;
let
cancelDiv
;
window
.
addEventListener
(
"
DOMContentLoaded
"
e
=
>
{
let
progress
=
window
.
document
.
getElementById
(
"
progress
"
)
;
updateProgress
=
val
=
>
{
progress
.
value
=
val
;
}
;
cancelDiv
=
window
.
document
.
getElementById
(
"
cancel
-
section
"
)
;
cancelDiv
.
setAttribute
(
"
style
"
"
display
:
none
;
"
)
;
let
cancelBtn
=
window
.
document
.
getElementById
(
"
cancel
-
btn
"
)
;
cancelBtn
.
addEventListener
(
"
click
"
e
=
>
{
finished
=
true
;
}
)
;
}
)
;
timer
=
setTimeout
(
(
)
=
>
{
cancelDiv
.
removeAttribute
(
"
style
"
)
;
window
.
sizeToContent
(
)
;
}
SHOW_CANCEL_DELAY
-
SHOW_DIALOG_DELAY
)
;
}
SHOW_DIALOG_DELAY
)
;
Services
.
tm
.
spinEventLoopUntil
(
(
)
=
>
finished
)
;
clearTimeout
(
timer
)
;
if
(
window
)
{
window
.
close
(
)
;
}
return
started
;
}
async
updateSystemAddons
(
)
{
let
systemAddonLocation
=
XPIProvider
.
installLocationsByName
[
KEY_APP_SYSTEM_ADDONS
]
;
if
(
!
systemAddonLocation
)
return
;
if
(
Services
.
appinfo
.
inSafeMode
)
return
;
let
url
=
Services
.
prefs
.
getStringPref
(
PREF_SYSTEM_ADDON_UPDATE_URL
null
)
;
if
(
!
url
)
{
await
systemAddonLocation
.
cleanDirectories
(
)
;
return
;
}
url
=
await
UpdateUtils
.
formatUpdateURL
(
url
)
;
logger
.
info
(
Starting
system
add
-
on
update
check
from
{
url
}
.
)
;
let
res
=
await
ProductAddonChecker
.
getProductAddonList
(
url
)
;
if
(
!
res
|
|
!
res
.
gmpAddons
)
{
logger
.
info
(
"
No
system
add
-
ons
list
was
returned
.
"
)
;
await
systemAddonLocation
.
cleanDirectories
(
)
;
return
;
}
let
addonList
=
new
Map
(
res
.
gmpAddons
.
map
(
spec
=
>
[
spec
.
id
{
spec
path
:
null
addon
:
null
}
]
)
)
;
let
getAddonsInLocation
=
(
location
)
=
>
{
return
new
Promise
(
resolve
=
>
{
XPIDatabase
.
getAddonsInLocation
(
location
resolve
)
;
}
)
;
}
;
let
setMatches
=
(
wanted
existing
)
=
>
{
if
(
wanted
.
size
!
=
existing
.
size
)
return
false
;
for
(
let
[
id
addon
]
of
existing
)
{
let
wantedInfo
=
wanted
.
get
(
id
)
;
if
(
!
wantedInfo
)
return
false
;
if
(
wantedInfo
.
spec
.
version
!
=
addon
.
version
)
return
false
;
}
return
true
;
}
;
let
updatedAddons
=
addonMap
(
await
getAddonsInLocation
(
KEY_APP_SYSTEM_ADDONS
)
)
;
if
(
setMatches
(
addonList
updatedAddons
)
)
{
logger
.
info
(
"
Retaining
existing
updated
system
add
-
ons
.
"
)
;
await
systemAddonLocation
.
cleanDirectories
(
)
;
return
;
}
let
defaultAddons
=
addonMap
(
await
getAddonsInLocation
(
KEY_APP_SYSTEM_DEFAULTS
)
)
;
if
(
setMatches
(
addonList
defaultAddons
)
)
{
logger
.
info
(
"
Resetting
system
add
-
ons
.
"
)
;
systemAddonLocation
.
resetAddonSet
(
)
;
await
systemAddonLocation
.
cleanDirectories
(
)
;
return
;
}
async
function
downloadAddon
(
item
)
{
try
{
let
sourceAddon
=
updatedAddons
.
get
(
item
.
spec
.
id
)
;
if
(
sourceAddon
&
&
sourceAddon
.
version
=
=
item
.
spec
.
version
)
{
try
{
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
tmpDir
"
tmpaddon
"
)
;
let
unique
=
await
OS
.
File
.
openUnique
(
path
)
;
unique
.
file
.
close
(
)
;
await
OS
.
File
.
copy
(
sourceAddon
.
_sourceBundle
.
path
unique
.
path
)
;
await
OS
.
File
.
setDates
(
unique
.
path
)
;
item
.
path
=
unique
.
path
;
}
catch
(
e
)
{
logger
.
warn
(
Failed
make
temporary
copy
of
{
sourceAddon
.
_sourceBundle
.
path
}
.
e
)
;
}
}
if
(
!
item
.
path
)
{
item
.
path
=
await
ProductAddonChecker
.
downloadAddon
(
item
.
spec
)
;
}
item
.
addon
=
await
loadManifestFromFile
(
nsIFile
(
item
.
path
)
systemAddonLocation
)
;
}
catch
(
e
)
{
logger
.
error
(
Failed
to
download
system
add
-
on
{
item
.
spec
.
id
}
e
)
;
}
}
await
Promise
.
all
(
Array
.
from
(
addonList
.
values
(
)
)
.
map
(
downloadAddon
)
)
;
let
validateAddon
=
(
item
)
=
>
{
if
(
item
.
spec
.
id
!
=
item
.
addon
.
id
)
{
logger
.
warn
(
Downloaded
system
add
-
on
expected
to
be
{
item
.
spec
.
id
}
but
was
{
item
.
addon
.
id
}
.
)
;
return
false
;
}
if
(
item
.
spec
.
version
!
=
item
.
addon
.
version
)
{
logger
.
warn
(
Expected
system
add
-
on
{
item
.
spec
.
id
}
to
be
version
{
item
.
spec
.
version
}
but
was
{
item
.
addon
.
version
}
.
)
;
return
false
;
}
if
(
!
systemAddonLocation
.
isValidAddon
(
item
.
addon
)
)
return
false
;
return
true
;
}
;
if
(
!
Array
.
from
(
addonList
.
values
(
)
)
.
every
(
item
=
>
item
.
path
&
&
item
.
addon
&
&
validateAddon
(
item
)
)
)
{
throw
new
Error
(
"
Rejecting
updated
system
add
-
on
set
that
either
could
not
"
+
"
be
downloaded
or
contained
unusable
add
-
ons
.
"
)
;
}
logger
.
info
(
"
Installing
new
system
add
-
on
set
"
)
;
await
systemAddonLocation
.
installAddonSet
(
Array
.
from
(
addonList
.
values
(
)
)
.
map
(
a
=
>
a
.
addon
)
)
;
}
async
verifySignatures
(
)
{
try
{
let
addons
=
await
XPIDatabase
.
getAddonList
(
a
=
>
true
)
;
let
changes
=
{
enabled
:
[
]
disabled
:
[
]
}
;
for
(
let
addon
of
addons
)
{
if
(
!
addon
.
_sourceBundle
.
exists
(
)
)
continue
;
let
signedState
=
await
verifyBundleSignedState
(
addon
.
_sourceBundle
addon
)
;
if
(
signedState
!
=
addon
.
signedState
)
{
addon
.
signedState
=
signedState
;
AddonManagerPrivate
.
callAddonListeners
(
"
onPropertyChanged
"
addon
.
wrapper
[
"
signedState
"
]
)
;
}
let
disabled
=
XPIProvider
.
updateAddonDisabledState
(
addon
)
;
if
(
disabled
!
=
=
undefined
)
changes
[
disabled
?
"
disabled
"
:
"
enabled
"
]
.
push
(
addon
.
id
)
;
}
XPIDatabase
.
saveChanges
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
xpi
-
signature
-
changed
"
JSON
.
stringify
(
changes
)
)
;
}
catch
(
err
)
{
logger
.
error
(
"
XPI_verifySignature
:
"
+
err
)
;
}
}
addAddonsToCrashReporter
(
)
{
if
(
!
(
Services
.
appinfo
instanceof
Ci
.
nsICrashReporter
)
|
|
!
AppConstants
.
MOZ_CRASHREPORTER
)
{
return
;
}
if
(
Services
.
appinfo
.
inSafeMode
)
{
return
;
}
let
data
=
Array
.
from
(
XPIStates
.
enabledAddons
(
)
a
=
>
encoded
{
a
.
id
}
:
{
a
.
version
}
)
.
join
(
"
"
)
;
try
{
Services
.
appinfo
.
annotateCrashReport
(
"
Add
-
ons
"
data
)
;
}
catch
(
e
)
{
}
let
TelemetrySession
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySession
.
jsm
"
{
}
)
.
TelemetrySession
;
TelemetrySession
.
setAddOns
(
data
)
;
}
processPendingFileChanges
(
aManifests
)
{
let
changed
=
false
;
for
(
let
location
of
this
.
installLocations
)
{
aManifests
[
location
.
name
]
=
{
}
;
if
(
location
.
locked
)
{
continue
;
}
let
stagingDir
=
location
.
getStagingDir
(
)
;
try
{
if
(
!
stagingDir
|
|
!
stagingDir
.
exists
(
)
|
|
!
stagingDir
.
isDirectory
(
)
)
continue
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
find
staging
directory
"
e
)
;
continue
;
}
let
seenFiles
=
[
]
;
let
stagingDirEntries
=
getDirectoryEntries
(
stagingDir
true
)
;
for
(
let
stageDirEntry
of
stagingDirEntries
)
{
let
id
=
stageDirEntry
.
leafName
;
let
isDir
;
try
{
isDir
=
stageDirEntry
.
isDirectory
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
)
throw
e
;
continue
;
}
if
(
!
isDir
)
{
if
(
id
.
substring
(
id
.
length
-
4
)
.
toLowerCase
(
)
=
=
"
.
xpi
"
)
{
id
=
id
.
substring
(
0
id
.
length
-
4
)
;
}
else
{
if
(
id
.
substring
(
id
.
length
-
5
)
.
toLowerCase
(
)
!
=
"
.
json
"
)
{
logger
.
warn
(
"
Ignoring
file
:
"
+
stageDirEntry
.
path
)
;
seenFiles
.
push
(
stageDirEntry
.
leafName
)
;
}
continue
;
}
}
if
(
!
gIDTest
.
test
(
id
)
)
{
logger
.
warn
(
"
Ignoring
directory
whose
name
is
not
a
valid
add
-
on
ID
:
"
+
stageDirEntry
.
path
)
;
seenFiles
.
push
(
stageDirEntry
.
leafName
)
;
continue
;
}
changed
=
true
;
if
(
isDir
)
{
let
manifest
=
getManifestFileForDir
(
stageDirEntry
)
;
if
(
!
manifest
)
{
logger
.
debug
(
"
Processing
uninstall
of
"
+
id
+
"
in
"
+
location
.
name
)
;
try
{
let
addonFile
=
location
.
getLocationForID
(
id
)
;
let
addonToUninstall
=
syncLoadManifestFromFile
(
addonFile
location
)
;
if
(
addonToUninstall
.
bootstrap
)
{
this
.
callBootstrapMethod
(
addonToUninstall
addonToUninstall
.
_sourceBundle
"
uninstall
"
BOOTSTRAP_REASONS
.
ADDON_UNINSTALL
)
;
}
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
call
uninstall
for
"
+
id
e
)
;
}
try
{
location
.
uninstallAddon
(
id
)
;
XPIStates
.
removeAddon
(
location
.
name
id
)
;
seenFiles
.
push
(
stageDirEntry
.
leafName
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
uninstall
add
-
on
"
+
id
+
"
in
"
+
location
.
name
e
)
;
}
continue
;
}
}
aManifests
[
location
.
name
]
[
id
]
=
null
;
let
existingAddonID
=
id
;
let
jsonfile
=
getFile
(
{
id
}
.
json
stagingDir
)
;
let
foreignInstall
=
!
jsonfile
.
exists
(
)
;
let
addon
;
try
{
addon
=
syncLoadManifestFromFile
(
stageDirEntry
location
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Unable
to
read
add
-
on
manifest
from
"
+
stageDirEntry
.
path
e
)
;
seenFiles
.
push
(
stageDirEntry
.
leafName
)
;
seenFiles
.
push
(
jsonfile
.
leafName
)
;
continue
;
}
if
(
mustSign
(
addon
.
type
)
&
&
addon
.
signedState
<
=
AddonManager
.
SIGNEDSTATE_MISSING
)
{
logger
.
warn
(
"
Refusing
to
install
staged
add
-
on
"
+
id
+
"
with
signed
state
"
+
addon
.
signedState
)
;
seenFiles
.
push
(
stageDirEntry
.
leafName
)
;
seenFiles
.
push
(
jsonfile
.
leafName
)
;
continue
;
}
if
(
!
foreignInstall
)
{
logger
.
debug
(
"
Found
updated
metadata
for
"
+
id
+
"
in
"
+
location
.
name
)
;
let
fis
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
try
{
fis
.
init
(
jsonfile
-
1
0
0
)
;
let
bytes
=
NetUtil
.
readInputStream
(
fis
jsonfile
.
fileSize
)
;
let
metadata
=
JSON
.
parse
(
gTextDecoder
.
decode
(
bytes
)
)
;
addon
.
importMetadata
(
metadata
)
;
aManifests
[
location
.
name
]
[
id
]
=
addon
;
}
catch
(
e
)
{
logger
.
error
(
"
Unable
to
read
metadata
from
"
+
jsonfile
.
path
e
)
;
}
finally
{
fis
.
close
(
)
;
}
}
seenFiles
.
push
(
jsonfile
.
leafName
)
;
existingAddonID
=
addon
.
existingAddonID
|
|
id
;
var
oldBootstrap
=
null
;
logger
.
debug
(
"
Processing
install
of
"
+
id
+
"
in
"
+
location
.
name
)
;
let
existingAddon
=
XPIStates
.
findAddon
(
existingAddonID
)
;
if
(
existingAddon
&
&
existingAddon
.
bootstrapped
)
{
try
{
var
file
=
existingAddon
.
file
;
if
(
file
.
exists
(
)
)
{
oldBootstrap
=
existingAddon
;
let
newVersion
=
addon
.
version
;
let
oldVersion
=
existingAddon
;
let
uninstallReason
=
newVersionReason
(
oldVersion
newVersion
)
;
this
.
callBootstrapMethod
(
existingAddon
file
"
uninstall
"
uninstallReason
{
newVersion
}
)
;
this
.
unloadBootstrapScope
(
existingAddonID
)
;
flushChromeCaches
(
)
;
}
}
catch
(
e
)
{
}
}
try
{
addon
.
_sourceBundle
=
location
.
installAddon
(
{
id
source
:
stageDirEntry
existingAddonID
}
)
;
XPIStates
.
addAddon
(
addon
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
install
staged
add
-
on
"
+
id
+
"
in
"
+
location
.
name
e
)
;
new
StagedAddonInstall
(
location
stageDirEntry
addon
)
;
seenFiles
.
pop
(
)
;
delete
aManifests
[
location
.
name
]
[
id
]
;
if
(
oldBootstrap
)
{
this
.
callBootstrapMethod
(
oldBootstrap
existingAddon
"
install
"
BOOTSTRAP_REASONS
.
ADDON_INSTALL
)
;
}
continue
;
}
}
try
{
location
.
cleanStagingDir
(
seenFiles
)
;
}
catch
(
e
)
{
logger
.
debug
(
"
Error
cleaning
staging
dir
"
+
stagingDir
.
path
e
)
;
}
}
return
changed
;
}
installDistributionAddons
(
aManifests
aAppChanged
)
{
let
distroDir
;
try
{
distroDir
=
FileUtils
.
getDir
(
KEY_APP_DISTRIBUTION
[
DIR_EXTENSIONS
]
)
;
}
catch
(
e
)
{
return
false
;
}
if
(
!
distroDir
.
exists
(
)
)
return
false
;
if
(
!
distroDir
.
isDirectory
(
)
)
return
false
;
let
changed
=
false
;
let
profileLocation
=
this
.
installLocationsByName
[
KEY_APP_PROFILE
]
;
let
entries
=
distroDir
.
directoryEntries
.
QueryInterface
(
Ci
.
nsIDirectoryEnumerator
)
;
let
entry
;
while
(
(
entry
=
entries
.
nextFile
)
)
{
let
id
=
entry
.
leafName
;
if
(
entry
.
isFile
(
)
)
{
if
(
id
.
substring
(
id
.
length
-
4
)
.
toLowerCase
(
)
=
=
"
.
xpi
"
)
{
id
=
id
.
substring
(
0
id
.
length
-
4
)
;
}
else
{
logger
.
debug
(
"
Ignoring
distribution
add
-
on
that
isn
'
t
an
XPI
:
"
+
entry
.
path
)
;
continue
;
}
}
else
if
(
!
entry
.
isDirectory
(
)
)
{
logger
.
debug
(
"
Ignoring
distribution
add
-
on
that
isn
'
t
a
file
or
directory
:
"
+
entry
.
path
)
;
continue
;
}
if
(
!
gIDTest
.
test
(
id
)
)
{
logger
.
debug
(
"
Ignoring
distribution
add
-
on
whose
name
is
not
a
valid
add
-
on
ID
:
"
+
entry
.
path
)
;
continue
;
}
if
(
!
aAppChanged
&
&
Services
.
prefs
.
prefHasUserValue
(
PREF_BRANCH_INSTALLED_ADDON
+
id
)
)
{
continue
;
}
let
addon
;
try
{
addon
=
syncLoadManifestFromFile
(
entry
profileLocation
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
File
entry
"
+
entry
.
path
+
"
contains
an
invalid
add
-
on
"
e
)
;
continue
;
}
if
(
addon
.
id
!
=
id
)
{
logger
.
warn
(
"
File
entry
"
+
entry
.
path
+
"
contains
an
add
-
on
with
an
"
+
"
incorrect
ID
"
)
;
continue
;
}
let
existingEntry
=
null
;
try
{
existingEntry
=
profileLocation
.
getLocationForID
(
id
)
;
}
catch
(
e
)
{
}
if
(
existingEntry
)
{
let
existingAddon
;
try
{
existingAddon
=
syncLoadManifestFromFile
(
existingEntry
profileLocation
)
;
if
(
Services
.
vc
.
compare
(
addon
.
version
existingAddon
.
version
)
<
=
0
)
continue
;
}
catch
(
e
)
{
logger
.
warn
(
"
Profile
contains
an
add
-
on
with
a
bad
or
missing
install
"
+
"
manifest
at
"
+
existingEntry
.
path
+
"
overwriting
"
e
)
;
}
}
else
if
(
Services
.
prefs
.
getBoolPref
(
PREF_BRANCH_INSTALLED_ADDON
+
id
false
)
)
{
continue
;
}
try
{
addon
.
_sourceBundle
=
profileLocation
.
installAddon
(
{
id
source
:
entry
action
:
"
copy
"
}
)
;
XPIStates
.
addAddon
(
addon
)
;
logger
.
debug
(
"
Installed
distribution
add
-
on
"
+
id
)
;
Services
.
prefs
.
setBoolPref
(
PREF_BRANCH_INSTALLED_ADDON
+
id
true
)
;
if
(
!
(
KEY_APP_PROFILE
in
aManifests
)
)
aManifests
[
KEY_APP_PROFILE
]
=
{
}
;
aManifests
[
KEY_APP_PROFILE
]
[
id
]
=
addon
;
changed
=
true
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
install
distribution
add
-
on
"
+
entry
.
path
e
)
;
}
}
entries
.
close
(
)
;
return
changed
;
}
importPermissions
(
)
{
PermissionsUtils
.
importFromPrefs
(
PREF_XPI_PERMISSIONS_BRANCH
XPI_PERMISSION
)
;
}
getDependentAddons
(
aAddon
)
{
return
Array
.
from
(
XPIDatabase
.
getAddons
(
)
)
.
filter
(
addon
=
>
addon
.
dependencies
.
includes
(
aAddon
.
id
)
)
;
}
getSafeModeExtensions
(
)
{
let
loc
=
XPIStates
.
getLocation
(
KEY_APP_GLOBAL
)
;
let
state
=
loc
.
get
(
ADDON_ID_DEFAULT_THEME
)
;
let
addonData
=
state
.
toJSON
(
)
;
addonData
.
enabled
=
true
;
return
{
[
KEY_APP_GLOBAL
]
:
{
path
:
loc
.
path
addons
:
{
[
ADDON_ID_DEFAULT_THEME
]
:
addonData
}
}
}
;
}
checkForChanges
(
aAppChanged
aOldAppVersion
aOldPlatformVersion
)
{
logger
.
debug
(
"
checkForChanges
"
)
;
let
updateReasons
=
[
]
;
if
(
aAppChanged
)
{
updateReasons
.
push
(
"
appChanged
"
)
;
}
let
installChanged
=
XPIStates
.
getInstallState
(
aAppChanged
=
=
=
false
)
;
if
(
installChanged
)
{
updateReasons
.
push
(
"
directoryState
"
)
;
}
let
manifests
=
{
}
;
let
updated
=
this
.
processPendingFileChanges
(
manifests
)
;
if
(
updated
)
{
updateReasons
.
push
(
"
pendingFileChanges
"
)
;
}
let
hasPendingChanges
=
Services
.
prefs
.
getBoolPref
(
PREF_PENDING_OPERATIONS
false
)
;
if
(
hasPendingChanges
)
{
updateReasons
.
push
(
"
hasPendingChanges
"
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
PREF_INSTALL_DISTRO_ADDONS
true
)
)
{
updated
=
this
.
installDistributionAddons
(
manifests
aAppChanged
)
;
if
(
updated
)
{
updateReasons
.
push
(
"
installDistributionAddons
"
)
;
}
}
let
haveAnyAddons
=
(
XPIStates
.
size
>
0
)
;
if
(
DB_SCHEMA
!
=
Services
.
prefs
.
getIntPref
(
PREF_DB_SCHEMA
0
)
)
{
if
(
!
haveAnyAddons
)
{
logger
.
debug
(
"
Empty
XPI
database
setting
schema
version
preference
to
"
+
DB_SCHEMA
)
;
Services
.
prefs
.
setIntPref
(
PREF_DB_SCHEMA
DB_SCHEMA
)
;
}
else
{
updateReasons
.
push
(
"
schemaChanged
"
)
;
}
}
let
dbFile
=
FileUtils
.
getFile
(
KEY_PROFILEDIR
[
FILE_DATABASE
]
true
)
;
if
(
!
dbFile
.
exists
(
)
&
&
haveAnyAddons
)
{
updateReasons
.
push
(
"
needNewDatabase
"
)
;
}
try
{
let
extensionListChanged
=
false
;
if
(
updateReasons
.
length
>
0
)
{
AddonManagerPrivate
.
recordSimpleMeasure
(
"
XPIDB_startup_load_reasons
"
updateReasons
)
;
XPIDatabase
.
syncLoadDB
(
false
)
;
try
{
extensionListChanged
=
XPIDatabaseReconcile
.
processFileChanges
(
manifests
aAppChanged
aOldAppVersion
aOldPlatformVersion
updateReasons
.
includes
(
"
schemaChanged
"
)
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
process
extension
changes
at
startup
"
e
)
;
}
}
if
(
aAppChanged
)
{
if
(
this
.
currentSkin
!
=
this
.
defaultSkin
)
{
let
oldSkin
=
XPIDatabase
.
getVisibleAddonForInternalName
(
this
.
currentSkin
)
;
if
(
!
oldSkin
|
|
oldSkin
.
disabled
)
this
.
enableDefaultTheme
(
)
;
}
let
oldCache
=
FileUtils
.
getFile
(
KEY_PROFILEDIR
[
FILE_OLD_CACHE
]
true
)
;
try
{
if
(
oldCache
.
exists
(
)
)
oldCache
.
remove
(
true
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Unable
to
remove
old
extension
cache
"
+
oldCache
.
path
e
)
;
}
}
if
(
Services
.
appinfo
.
inSafeMode
)
{
aomStartup
.
initializeExtensions
(
this
.
getSafeModeExtensions
(
)
)
;
logger
.
debug
(
"
Initialized
safe
mode
add
-
ons
"
)
;
return
false
;
}
if
(
extensionListChanged
|
|
hasPendingChanges
)
{
this
.
_updateActiveAddons
(
)
;
let
state
=
JSON
.
parse
(
JSON
.
stringify
(
XPIStates
)
)
;
aomStartup
.
initializeExtensions
(
state
)
;
return
true
;
}
aomStartup
.
initializeExtensions
(
XPIStates
.
initialStateData
)
;
logger
.
debug
(
"
No
changes
found
"
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Error
during
startup
file
checks
"
e
)
;
}
return
false
;
}
_updateActiveAddons
(
)
{
logger
.
debug
(
"
Updating
database
with
changes
to
installed
add
-
ons
"
)
;
XPIDatabase
.
updateActiveAddons
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
false
)
;
}
async
getNewSideloads
(
)
{
if
(
XPIStates
.
getInstallState
(
false
)
)
{
await
XPIDatabase
.
asyncLoadDB
(
false
)
;
XPIDatabaseReconcile
.
processFileChanges
(
{
}
false
)
;
this
.
_updateActiveAddons
(
)
;
}
let
addons
=
await
Promise
.
all
(
Array
.
from
(
XPIStates
.
sideLoadedAddons
.
keys
(
)
id
=
>
AddonManager
.
getAddonByID
(
id
)
)
)
;
return
addons
.
filter
(
addon
=
>
(
addon
.
seen
=
=
=
false
&
&
addon
.
permissions
&
AddonManager
.
PERM_CAN_ENABLE
)
)
;
}
supportsMimetype
(
aMimetype
)
{
return
aMimetype
=
=
"
application
/
x
-
xpinstall
"
;
}
isInstallEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_XPI_ENABLED
true
)
;
}
isDirectRequestWhitelisted
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_XPI_DIRECT_WHITELISTED
true
)
;
}
isFileRequestWhitelisted
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_XPI_FILE_WHITELISTED
true
)
;
}
isInstallAllowed
(
aInstallingPrincipal
)
{
if
(
!
this
.
isInstallEnabled
(
)
)
return
false
;
let
uri
=
aInstallingPrincipal
.
URI
;
if
(
!
uri
)
return
this
.
isDirectRequestWhitelisted
(
)
;
if
(
this
.
isFileRequestWhitelisted
(
)
&
&
(
uri
.
schemeIs
(
"
chrome
"
)
|
|
uri
.
schemeIs
(
"
file
"
)
)
)
return
true
;
this
.
importPermissions
(
)
;
let
permission
=
Services
.
perms
.
testPermissionFromPrincipal
(
aInstallingPrincipal
XPI_PERMISSION
)
;
if
(
permission
=
=
Ci
.
nsIPermissionManager
.
DENY_ACTION
)
return
false
;
let
requireWhitelist
=
Services
.
prefs
.
getBoolPref
(
PREF_XPI_WHITELIST_REQUIRED
true
)
;
if
(
requireWhitelist
&
&
(
permission
!
=
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
)
)
return
false
;
let
requireSecureOrigin
=
Services
.
prefs
.
getBoolPref
(
PREF_INSTALL_REQUIRESECUREORIGIN
true
)
;
let
safeSchemes
=
[
"
https
"
"
chrome
"
"
file
"
]
;
if
(
requireSecureOrigin
&
&
safeSchemes
.
indexOf
(
uri
.
scheme
)
=
=
-
1
)
return
false
;
return
true
;
}
isTemporaryInstallID
(
id
)
{
return
id
.
endsWith
(
TEMPORARY_ADDON_SUFFIX
)
;
}
getInstallForURL
(
aUrl
aHash
aName
aIcons
aVersion
aBrowser
aCallback
)
{
let
location
=
XPIProvider
.
installLocationsByName
[
KEY_APP_PROFILE
]
;
let
url
=
Services
.
io
.
newURI
(
aUrl
)
;
let
options
=
{
hash
:
aHash
browser
:
aBrowser
name
:
aName
icons
:
aIcons
version
:
aVersion
}
;
if
(
url
instanceof
Ci
.
nsIFileURL
)
{
let
install
=
new
LocalAddonInstall
(
location
url
options
)
;
install
.
init
(
)
.
then
(
(
)
=
>
{
aCallback
(
install
.
wrapper
)
;
}
)
;
}
else
{
let
install
=
new
DownloadAddonInstall
(
location
url
options
)
;
aCallback
(
install
.
wrapper
)
;
}
}
getInstallForFile
(
aFile
aCallback
)
{
createLocalInstall
(
aFile
)
.
then
(
install
=
>
{
aCallback
(
install
?
install
.
wrapper
:
null
)
;
}
)
;
}
installTemporaryAddon
(
aFile
)
{
return
this
.
installAddonFromLocation
(
aFile
TemporaryInstallLocation
)
;
}
async
installAddonFromSources
(
aFile
)
{
let
location
=
XPIProvider
.
installLocationsByName
[
KEY_APP_PROFILE
]
;
return
this
.
installAddonFromLocation
(
aFile
location
"
proxy
"
)
;
}
async
installAddonFromLocation
(
aFile
aInstallLocation
aInstallAction
)
{
if
(
aFile
.
exists
(
)
&
&
aFile
.
isFile
(
)
)
{
flushJarCache
(
aFile
)
;
}
let
addon
=
await
loadManifestFromFile
(
aFile
aInstallLocation
)
;
aInstallLocation
.
installAddon
(
{
id
:
addon
.
id
source
:
aFile
action
:
aInstallAction
}
)
;
if
(
addon
.
appDisabled
)
{
let
message
=
Add
-
on
{
addon
.
id
}
is
not
compatible
with
application
version
.
;
let
app
=
addon
.
matchingTargetApplication
;
if
(
app
)
{
if
(
app
.
minVersion
)
{
message
+
=
add
-
on
minVersion
:
{
app
.
minVersion
}
.
;
}
if
(
app
.
maxVersion
)
{
message
+
=
add
-
on
maxVersion
:
{
app
.
maxVersion
}
.
;
}
}
throw
new
Error
(
message
)
;
}
if
(
!
addon
.
bootstrap
)
{
throw
new
Error
(
"
Only
restartless
(
bootstrap
)
add
-
ons
"
+
"
can
be
installed
from
sources
:
"
addon
.
id
)
;
}
let
installReason
=
BOOTSTRAP_REASONS
.
ADDON_INSTALL
;
let
oldAddon
=
await
new
Promise
(
resolve
=
>
XPIDatabase
.
getVisibleAddonForID
(
addon
.
id
resolve
)
)
;
let
callUpdate
=
false
;
let
extraParams
=
{
}
;
extraParams
.
temporarilyInstalled
=
aInstallLocation
=
=
=
TemporaryInstallLocation
;
if
(
oldAddon
)
{
if
(
!
oldAddon
.
bootstrap
)
{
logger
.
warn
(
"
Non
-
restartless
Add
-
on
is
already
installed
"
addon
.
id
)
;
throw
new
Error
(
"
Non
-
restartless
add
-
on
with
ID
"
+
oldAddon
.
id
+
"
is
already
installed
"
)
;
}
else
{
logger
.
warn
(
"
Addon
with
ID
"
+
oldAddon
.
id
+
"
already
installed
"
+
"
older
version
will
be
disabled
"
)
;
addon
.
installDate
=
oldAddon
.
installDate
;
let
existingAddonID
=
oldAddon
.
id
;
let
existingAddon
=
oldAddon
.
_sourceBundle
;
let
newVersion
=
addon
.
version
;
let
oldVersion
=
oldAddon
.
version
;
installReason
=
newVersionReason
(
oldVersion
newVersion
)
;
let
uninstallReason
=
installReason
;
extraParams
.
newVersion
=
newVersion
;
extraParams
.
oldVersion
=
oldVersion
;
callUpdate
=
isWebExtension
(
oldAddon
.
type
)
&
&
isWebExtension
(
addon
.
type
)
;
if
(
oldAddon
.
active
)
{
XPIProvider
.
callBootstrapMethod
(
oldAddon
existingAddon
"
shutdown
"
uninstallReason
extraParams
)
;
}
if
(
!
callUpdate
)
{
this
.
callBootstrapMethod
(
oldAddon
existingAddon
"
uninstall
"
uninstallReason
extraParams
)
;
}
this
.
unloadBootstrapScope
(
existingAddonID
)
;
flushChromeCaches
(
)
;
}
}
else
{
addon
.
installDate
=
Date
.
now
(
)
;
}
let
file
=
addon
.
_sourceBundle
;
XPIProvider
.
_addURIMapping
(
addon
.
id
file
)
;
let
method
=
callUpdate
?
"
update
"
:
"
install
"
;
XPIProvider
.
callBootstrapMethod
(
addon
file
method
installReason
extraParams
)
;
addon
.
state
=
AddonManager
.
STATE_INSTALLED
;
logger
.
debug
(
"
Install
of
temporary
addon
in
"
+
aFile
.
path
+
"
completed
.
"
)
;
addon
.
visible
=
true
;
addon
.
enabled
=
true
;
addon
.
active
=
true
;
addon
.
userDisabled
=
false
;
addon
=
XPIDatabase
.
addAddonMetadata
(
addon
file
.
path
)
;
XPIStates
.
addAddon
(
addon
)
;
XPIDatabase
.
saveChanges
(
)
;
XPIStates
.
save
(
)
;
AddonManagerPrivate
.
callAddonListeners
(
"
onInstalling
"
addon
.
wrapper
false
)
;
XPIProvider
.
callBootstrapMethod
(
addon
file
"
startup
"
installReason
extraParams
)
;
AddonManagerPrivate
.
callInstallListeners
(
"
onExternalInstall
"
null
addon
.
wrapper
oldAddon
?
oldAddon
.
wrapper
:
null
false
)
;
AddonManagerPrivate
.
callAddonListeners
(
"
onInstalled
"
addon
.
wrapper
)
;
if
(
isTheme
(
addon
.
type
)
)
AddonManagerPrivate
.
notifyAddonChanged
(
addon
.
id
addon
.
type
false
)
;
return
addon
.
wrapper
;
}
getAddonByInstanceID
(
aInstanceID
)
{
if
(
!
aInstanceID
|
|
typeof
aInstanceID
!
=
"
symbol
"
)
throw
Components
.
Exception
(
"
aInstanceID
must
be
a
Symbol
(
)
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
for
(
let
[
id
val
]
of
this
.
activeAddons
)
{
if
(
aInstanceID
=
=
val
.
instanceID
)
{
return
new
Promise
(
resolve
=
>
this
.
getAddonByID
(
id
resolve
)
)
;
}
}
return
Promise
.
resolve
(
null
)
;
}
removeActiveInstall
(
aInstall
)
{
this
.
installs
.
delete
(
aInstall
)
;
}
getAddonByID
(
aId
aCallback
)
{
XPIDatabase
.
getVisibleAddonForID
(
aId
function
(
aAddon
)
{
aCallback
(
aAddon
?
aAddon
.
wrapper
:
null
)
;
}
)
;
}
getAddonsByTypes
(
aTypes
aCallback
)
{
let
typesToGet
=
getAllAliasesForTypes
(
aTypes
)
;
if
(
typesToGet
&
&
!
typesToGet
.
some
(
type
=
>
ALL_EXTERNAL_TYPES
.
has
(
type
)
)
)
{
aCallback
(
[
]
)
;
return
;
}
XPIDatabase
.
getVisibleAddons
(
typesToGet
function
(
aAddons
)
{
aCallback
(
aAddons
.
map
(
a
=
>
a
.
wrapper
)
)
;
}
)
;
}
getActiveAddons
(
aTypes
)
{
if
(
this
.
isDBLoaded
)
{
return
new
Promise
(
resolve
=
>
{
this
.
getAddonsByTypes
(
aTypes
addons
=
>
{
resolve
(
{
addons
:
addons
.
filter
(
addon
=
>
addon
.
isActive
|
|
(
addon
.
type
=
=
"
experiment
"
&
&
!
addon
.
appDisabled
)
)
fullData
:
true
}
)
;
}
)
;
}
)
;
}
if
(
!
XPIStates
.
db
)
{
return
Promise
.
reject
(
new
Error
(
"
XPIStates
not
yet
initialized
"
)
)
;
}
let
result
=
[
]
;
for
(
let
addon
of
XPIStates
.
enabledAddons
(
)
)
{
if
(
aTypes
&
&
!
aTypes
.
includes
(
addon
.
type
)
)
{
continue
;
}
let
location
=
this
.
installLocationsByName
[
addon
.
location
.
name
]
;
let
scope
isSystem
;
if
(
location
)
{
(
{
scope
isSystem
}
=
location
)
;
}
result
.
push
(
{
id
:
addon
.
id
version
:
addon
.
version
type
:
addon
.
type
updateDate
:
addon
.
lastModifiedTime
scope
isSystem
isWebExtension
:
isWebExtension
(
addon
)
multiprocessCompatible
:
addon
.
multiprocessCompatible
}
)
;
}
return
Promise
.
resolve
(
{
addons
:
result
fullData
:
false
}
)
;
}
getAddonBySyncGUID
(
aGUID
aCallback
)
{
XPIDatabase
.
getAddonBySyncGUID
(
aGUID
function
(
aAddon
)
{
aCallback
(
aAddon
?
aAddon
.
wrapper
:
null
)
;
}
)
;
}
getAddonsWithOperationsByTypes
(
aTypes
aCallback
)
{
let
typesToGet
=
getAllAliasesForTypes
(
aTypes
)
;
XPIDatabase
.
getVisibleAddonsWithPendingOperations
(
typesToGet
function
(
aAddons
)
{
let
results
=
aAddons
.
map
(
a
=
>
a
.
wrapper
)
;
for
(
let
install
of
XPIProvider
.
installs
)
{
if
(
install
.
state
=
=
AddonManager
.
STATE_INSTALLED
&
&
!
(
install
.
addon
.
inDatabase
)
)
results
.
push
(
install
.
addon
.
wrapper
)
;
}
aCallback
(
results
)
;
}
)
;
}
getInstallsByTypes
(
aTypes
aCallback
)
{
let
results
=
[
.
.
.
this
.
installs
]
;
if
(
aTypes
)
{
results
=
results
.
filter
(
install
=
>
{
return
aTypes
.
includes
(
getExternalType
(
install
.
type
)
)
;
}
)
;
}
aCallback
(
results
.
map
(
install
=
>
install
.
wrapper
)
)
;
}
mapURIToAddonID
(
aURI
)
{
return
AddonPathService
.
mapURIToAddonId
(
aURI
)
|
|
null
;
}
addonChanged
(
aId
aType
aPendingRestart
)
{
if
(
!
isTheme
(
aType
)
)
return
;
if
(
!
aId
)
{
this
.
enableDefaultTheme
(
)
;
return
;
}
let
previousTheme
=
null
;
let
newSkin
=
this
.
defaultSkin
;
let
addons
=
XPIDatabase
.
getAddonsByType
(
"
theme
"
"
webextension
-
theme
"
)
;
for
(
let
theme
of
addons
)
{
if
(
!
theme
.
visible
)
return
;
let
isChangedAddon
=
(
theme
.
id
=
=
aId
)
;
if
(
isWebExtension
(
theme
.
type
)
)
{
if
(
!
isChangedAddon
)
this
.
updateAddonDisabledState
(
theme
true
undefined
aPendingRestart
)
;
}
else
if
(
isChangedAddon
)
{
newSkin
=
theme
.
internalName
;
}
else
if
(
theme
.
userDisabled
=
=
false
&
&
!
theme
.
pendingUninstall
)
{
previousTheme
=
theme
;
}
}
if
(
aPendingRestart
)
{
Services
.
prefs
.
setBoolPref
(
PREF_SKIN_SWITCHPENDING
true
)
;
Services
.
prefs
.
setCharPref
(
PREF_SKIN_TO_SELECT
newSkin
)
;
}
else
if
(
newSkin
=
=
this
.
currentSkin
)
{
try
{
Services
.
prefs
.
clearUserPref
(
PREF_SKIN_SWITCHPENDING
)
;
}
catch
(
e
)
{
}
try
{
Services
.
prefs
.
clearUserPref
(
PREF_SKIN_TO_SELECT
)
;
}
catch
(
e
)
{
}
}
else
{
Services
.
prefs
.
setCharPref
(
PREF_GENERAL_SKINS_SELECTEDSKIN
newSkin
)
;
this
.
currentSkin
=
newSkin
;
}
this
.
selectedSkin
=
newSkin
;
Services
.
prefs
.
savePrefFile
(
null
)
;
if
(
previousTheme
)
this
.
updateAddonDisabledState
(
previousTheme
true
undefined
aPendingRestart
)
;
}
updateAddonAppDisabledStates
(
)
{
let
addons
=
XPIDatabase
.
getAddons
(
)
;
for
(
let
addon
of
addons
)
{
this
.
updateAddonDisabledState
(
addon
)
;
}
}
updateAddonRepositoryData
(
aCallback
)
{
XPIDatabase
.
getVisibleAddons
(
null
aAddons
=
>
{
let
pending
=
aAddons
.
length
;
logger
.
debug
(
"
updateAddonRepositoryData
found
"
+
pending
+
"
visible
add
-
ons
"
)
;
if
(
pending
=
=
0
)
{
aCallback
(
)
;
return
;
}
function
notifyComplete
(
)
{
if
(
-
-
pending
=
=
0
)
aCallback
(
)
;
}
for
(
let
addon
of
aAddons
)
{
AddonRepository
.
getCachedAddonByID
(
addon
.
id
aRepoAddon
=
>
{
if
(
aRepoAddon
)
{
logger
.
debug
(
"
updateAddonRepositoryData
got
info
for
"
+
addon
.
id
)
;
addon
.
_repositoryAddon
=
aRepoAddon
;
addon
.
compatibilityOverrides
=
aRepoAddon
.
compatibilityOverrides
;
this
.
updateAddonDisabledState
(
addon
)
;
}
notifyComplete
(
)
;
}
)
;
}
}
)
;
}
enableDefaultTheme
(
)
{
logger
.
debug
(
"
Activating
default
theme
"
)
;
let
addon
=
XPIDatabase
.
getVisibleAddonForInternalName
(
this
.
defaultSkin
)
;
if
(
addon
)
{
if
(
addon
.
userDisabled
)
{
this
.
updateAddonDisabledState
(
addon
false
)
;
}
else
if
(
!
this
.
extensionsActive
)
{
Services
.
prefs
.
setCharPref
(
PREF_GENERAL_SKINS_SELECTEDSKIN
addon
.
internalName
)
;
this
.
currentSkin
=
this
.
selectedSkin
=
addon
.
internalName
;
Services
.
prefs
.
clearUserPref
(
PREF_SKIN_TO_SELECT
)
;
Services
.
prefs
.
clearUserPref
(
PREF_SKIN_SWITCHPENDING
)
;
}
else
{
logger
.
warn
(
"
Attempting
to
activate
an
already
active
default
theme
"
)
;
}
}
else
{
logger
.
warn
(
"
Unable
to
activate
the
default
theme
"
)
;
}
}
onDebugConnectionChange
(
{
what
connection
}
)
{
if
(
what
!
=
"
opened
"
)
return
;
for
(
let
[
id
val
]
of
this
.
activeAddons
)
{
connection
.
setAddonOptions
(
id
{
global
:
val
.
bootstrapScope
}
)
;
}
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
NOTIFICATION_FLUSH_PERMISSIONS
)
{
if
(
!
aData
|
|
aData
=
=
XPI_PERMISSION
)
{
this
.
importPermissions
(
)
;
}
return
;
}
else
if
(
aTopic
=
=
NOTIFICATION_TOOLBOX_CONNECTION_CHANGE
)
{
this
.
onDebugConnectionChange
(
aSubject
.
wrappedJSObject
)
;
return
;
}
if
(
aTopic
=
=
"
nsPref
:
changed
"
)
{
switch
(
aData
)
{
case
PREF_EM_MIN_COMPAT_APP_VERSION
:
this
.
minCompatibleAppVersion
=
Services
.
prefs
.
getStringPref
(
PREF_EM_MIN_COMPAT_APP_VERSION
null
)
;
this
.
updateAddonAppDisabledStates
(
)
;
break
;
case
PREF_EM_MIN_COMPAT_PLATFORM_VERSION
:
this
.
minCompatiblePlatformVersion
=
Services
.
prefs
.
getStringPref
(
PREF_EM_MIN_COMPAT_PLATFORM_VERSION
null
)
;
this
.
updateAddonAppDisabledStates
(
)
;
break
;
case
PREF_XPI_SIGNATURES_REQUIRED
:
case
PREF_ALLOW_LEGACY
:
case
PREF_ALLOW_NON_MPC
:
this
.
updateAddonAppDisabledStates
(
)
;
break
;
}
}
}
enableRequiresRestart
(
aAddon
)
{
if
(
!
this
.
extensionsActive
)
return
false
;
if
(
Services
.
appinfo
.
inSafeMode
)
return
false
;
if
(
aAddon
.
active
)
return
false
;
if
(
isTheme
(
aAddon
.
type
)
)
{
if
(
isWebExtension
(
aAddon
.
type
)
)
{
let
theme
=
XPIDatabase
.
getVisibleAddonForInternalName
(
this
.
currentSkin
)
;
return
!
theme
|
|
this
.
disableRequiresRestart
(
theme
)
;
}
return
aAddon
.
internalName
!
=
this
.
currentSkin
;
}
return
!
aAddon
.
bootstrap
;
}
disableRequiresRestart
(
aAddon
)
{
if
(
!
this
.
extensionsActive
)
return
false
;
if
(
Services
.
appinfo
.
inSafeMode
)
return
false
;
if
(
!
aAddon
.
active
)
return
false
;
if
(
aAddon
.
type
=
=
"
theme
"
)
{
if
(
aAddon
.
internalName
!
=
this
.
defaultSkin
)
return
true
;
return
this
.
selectedSkin
!
=
this
.
currentSkin
;
}
return
!
aAddon
.
bootstrap
;
}
installRequiresRestart
(
aAddon
)
{
if
(
!
this
.
extensionsActive
)
return
false
;
if
(
Services
.
appinfo
.
inSafeMode
)
return
false
;
if
(
aAddon
.
inDatabase
)
return
false
;
if
(
"
_install
"
in
aAddon
&
&
aAddon
.
_install
)
{
let
existingAddon
=
aAddon
.
_install
.
existingAddon
;
if
(
existingAddon
&
&
this
.
uninstallRequiresRestart
(
existingAddon
)
)
return
true
;
}
if
(
aAddon
.
disabled
)
return
false
;
return
aAddon
.
type
=
=
"
theme
"
|
|
!
aAddon
.
bootstrap
;
}
uninstallRequiresRestart
(
aAddon
)
{
if
(
!
this
.
extensionsActive
)
return
false
;
if
(
Services
.
appinfo
.
inSafeMode
)
return
false
;
return
this
.
disableRequiresRestart
(
aAddon
)
;
}
loadBootstrapScope
(
aId
aFile
aVersion
aType
aMultiprocessCompatible
aRunInSafeMode
aDependencies
hasEmbeddedWebExtension
)
{
this
.
activeAddons
.
set
(
aId
{
bootstrapScope
:
null
instanceID
:
Symbol
(
aId
)
started
:
false
}
)
;
this
.
addAddonsToCrashReporter
(
)
;
let
activeAddon
=
this
.
activeAddons
.
get
(
aId
)
;
logger
.
debug
(
"
Loading
bootstrap
scope
from
"
+
aFile
.
path
)
;
let
principal
=
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
;
if
(
!
aMultiprocessCompatible
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_INTERPOSITION_ENABLED
false
)
)
{
let
interposition
=
Cc
[
"
mozilla
.
org
/
addons
/
multiprocess
-
shims
;
1
"
]
.
getService
(
Ci
.
nsIAddonInterposition
)
;
Cu
.
setAddonInterposition
(
aId
interposition
)
;
}
Cu
.
allowCPOWsInAddon
(
aId
true
)
;
}
if
(
!
aFile
.
exists
(
)
)
{
activeAddon
.
bootstrapScope
=
new
Cu
.
Sandbox
(
principal
{
sandboxName
:
aFile
.
path
addonId
:
aId
wantGlobalProperties
:
[
"
ChromeUtils
"
]
metadata
:
{
addonID
:
aId
}
}
)
;
logger
.
error
(
"
Attempted
to
load
bootstrap
scope
from
missing
directory
"
+
aFile
.
path
)
;
return
;
}
if
(
isWebExtension
(
aType
)
)
{
activeAddon
.
bootstrapScope
=
Extension
.
getBootstrapScope
(
aId
aFile
)
;
}
else
if
(
aType
=
=
=
"
webextension
-
langpack
"
)
{
activeAddon
.
bootstrapScope
=
Langpack
.
getBootstrapScope
(
aId
aFile
)
;
}
else
{
let
uri
=
getURIForResourceInFile
(
aFile
"
bootstrap
.
js
"
)
.
spec
;
if
(
aType
=
=
"
dictionary
"
)
uri
=
"
resource
:
/
/
gre
/
modules
/
addons
/
SpellCheckDictionaryBootstrap
.
js
"
;
else
if
(
aType
=
=
"
apiextension
"
)
uri
=
"
resource
:
/
/
gre
/
modules
/
addons
/
APIExtensionBootstrap
.
js
"
;
activeAddon
.
bootstrapScope
=
new
Cu
.
Sandbox
(
principal
{
sandboxName
:
uri
addonId
:
aId
wantGlobalProperties
:
[
"
ChromeUtils
"
]
metadata
:
{
addonID
:
aId
URI
:
uri
}
}
)
;
try
{
for
(
let
name
in
BOOTSTRAP_REASONS
)
activeAddon
.
bootstrapScope
[
name
]
=
BOOTSTRAP_REASONS
[
name
]
;
Object
.
assign
(
activeAddon
.
bootstrapScope
{
Worker
ChromeWorker
}
)
;
XPCOMUtils
.
defineLazyGetter
(
activeAddon
.
bootstrapScope
"
console
"
(
)
=
>
new
ConsoleAPI
(
{
consoleID
:
"
addon
/
"
+
aId
}
)
)
;
activeAddon
.
bootstrapScope
.
__SCRIPT_URI_SPEC__
=
uri
;
Services
.
scriptloader
.
loadSubScript
(
uri
activeAddon
.
bootstrapScope
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Error
loading
bootstrap
.
js
for
"
+
aId
e
)
;
}
}
let
wrappedJSObject
=
{
id
:
aId
options
:
{
global
:
activeAddon
.
bootstrapScope
}
}
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
}
"
toolbox
-
update
-
addon
-
options
"
)
;
}
unloadBootstrapScope
(
aId
)
{
Cu
.
setAddonInterposition
(
aId
null
)
;
Cu
.
allowCPOWsInAddon
(
aId
false
)
;
this
.
activeAddons
.
delete
(
aId
)
;
this
.
addAddonsToCrashReporter
(
)
;
let
wrappedJSObject
=
{
id
:
aId
options
:
{
global
:
null
}
}
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
}
"
toolbox
-
update
-
addon
-
options
"
)
;
}
callBootstrapMethod
(
aAddon
aFile
aMethod
aReason
aExtraParams
)
{
if
(
!
aAddon
.
id
|
|
!
aAddon
.
version
|
|
!
aAddon
.
type
)
{
throw
new
Error
(
"
aAddon
must
include
an
id
version
and
type
"
)
;
}
let
runInSafeMode
=
"
runInSafeMode
"
in
aAddon
?
aAddon
.
runInSafeMode
:
canRunInSafeMode
(
aAddon
)
;
if
(
Services
.
appinfo
.
inSafeMode
&
&
!
runInSafeMode
)
return
;
let
timeStart
=
new
Date
(
)
;
if
(
CHROME_TYPES
.
has
(
aAddon
.
type
)
&
&
aMethod
=
=
"
startup
"
)
{
logger
.
debug
(
"
Registering
manifest
for
"
+
aFile
.
path
)
;
Components
.
manager
.
addBootstrappedManifestLocation
(
aFile
)
;
}
try
{
let
activeAddon
=
this
.
activeAddons
.
get
(
aAddon
.
id
)
;
if
(
!
activeAddon
)
{
this
.
loadBootstrapScope
(
aAddon
.
id
aFile
aAddon
.
version
aAddon
.
type
aAddon
.
multiprocessCompatible
|
|
false
runInSafeMode
aAddon
.
dependencies
aAddon
.
hasEmbeddedWebExtension
|
|
false
)
;
activeAddon
=
this
.
activeAddons
.
get
(
aAddon
.
id
)
;
}
if
(
aMethod
=
=
"
startup
"
|
|
aMethod
=
=
"
shutdown
"
)
{
if
(
!
aExtraParams
)
{
aExtraParams
=
{
}
;
}
aExtraParams
.
instanceID
=
this
.
activeAddons
.
get
(
aAddon
.
id
)
.
instanceID
;
}
let
method
=
undefined
;
let
scope
=
activeAddon
.
bootstrapScope
;
try
{
method
=
scope
[
aMethod
]
|
|
Cu
.
evalInSandbox
(
{
aMethod
}
;
scope
)
;
}
catch
(
e
)
{
}
if
(
aMethod
=
=
"
startup
"
)
{
activeAddon
.
started
=
true
;
}
else
if
(
aMethod
=
=
"
shutdown
"
)
{
activeAddon
.
started
=
false
;
if
(
aReason
!
=
BOOTSTRAP_REASONS
.
APP_SHUTDOWN
)
{
activeAddon
.
disable
=
true
;
for
(
let
addon
of
this
.
getDependentAddons
(
aAddon
)
)
{
if
(
addon
.
active
)
this
.
updateAddonDisabledState
(
addon
)
;
}
}
}
let
params
=
{
id
:
aAddon
.
id
version
:
aAddon
.
version
installPath
:
aFile
.
clone
(
)
resourceURI
:
getURIForResourceInFile
(
aFile
"
"
)
signedState
:
aAddon
.
signedState
temporarilyInstalled
:
aAddon
.
_installLocation
=
=
TemporaryInstallLocation
}
;
if
(
aMethod
=
=
"
startup
"
&
&
aAddon
.
startupData
)
{
params
.
startupData
=
aAddon
.
startupData
;
}
if
(
aExtraParams
)
{
for
(
let
key
in
aExtraParams
)
{
params
[
key
]
=
aExtraParams
[
key
]
;
}
}
if
(
aAddon
.
hasEmbeddedWebExtension
)
{
let
reason
=
Object
.
keys
(
BOOTSTRAP_REASONS
)
.
find
(
key
=
>
BOOTSTRAP_REASONS
[
key
]
=
=
aReason
)
;
if
(
aMethod
=
=
"
startup
"
)
{
const
webExtension
=
LegacyExtensionsUtils
.
getEmbeddedExtensionFor
(
params
)
;
params
.
webExtension
=
{
startup
:
(
)
=
>
webExtension
.
startup
(
reason
)
}
;
}
else
if
(
aMethod
=
=
"
shutdown
"
)
{
LegacyExtensionsUtils
.
getEmbeddedExtensionFor
(
params
)
.
shutdown
(
reason
)
;
}
}
if
(
!
method
)
{
logger
.
warn
(
"
Add
-
on
"
+
aAddon
.
id
+
"
is
missing
bootstrap
method
"
+
aMethod
)
;
}
else
{
logger
.
debug
(
"
Calling
bootstrap
method
"
+
aMethod
+
"
on
"
+
aAddon
.
id
+
"
version
"
+
aAddon
.
version
)
;
let
result
;
try
{
result
=
method
.
call
(
scope
params
aReason
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Exception
running
bootstrap
method
"
+
aMethod
+
"
on
"
+
aAddon
.
id
e
)
;
}
if
(
aMethod
=
=
"
startup
"
)
{
activeAddon
.
startupPromise
=
Promise
.
resolve
(
result
)
;
activeAddon
.
startupPromise
.
catch
(
Cu
.
reportError
)
;
}
}
}
finally
{
if
(
aMethod
=
=
"
startup
"
&
&
aReason
!
=
BOOTSTRAP_REASONS
.
APP_STARTUP
)
{
for
(
let
addon
of
this
.
getDependentAddons
(
aAddon
)
)
this
.
updateAddonDisabledState
(
addon
)
;
}
if
(
CHROME_TYPES
.
has
(
aAddon
.
type
)
&
&
aMethod
=
=
"
shutdown
"
&
&
aReason
!
=
BOOTSTRAP_REASONS
.
APP_SHUTDOWN
)
{
logger
.
debug
(
"
Removing
manifest
for
"
+
aFile
.
path
)
;
Components
.
manager
.
removeBootstrappedManifestLocation
(
aFile
)
;
let
manifest
=
getURIForResourceInFile
(
aFile
"
chrome
.
manifest
"
)
;
for
(
let
line
of
ChromeManifestParser
.
parseSync
(
manifest
)
)
{
if
(
line
.
type
=
=
"
resource
"
)
{
ResProtocolHandler
.
setSubstitution
(
line
.
args
[
0
]
null
)
;
}
}
}
this
.
setTelemetry
(
aAddon
.
id
aMethod
+
"
_MS
"
new
Date
(
)
-
timeStart
)
;
}
}
updateAddonDisabledState
(
aAddon
aUserDisabled
aSoftDisabled
aPendingRestart
=
false
)
{
if
(
!
(
aAddon
.
inDatabase
)
)
throw
new
Error
(
"
Can
only
update
addon
states
for
installed
addons
.
"
)
;
if
(
aUserDisabled
!
=
=
undefined
&
&
aSoftDisabled
!
=
=
undefined
)
{
throw
new
Error
(
"
Cannot
change
userDisabled
and
softDisabled
at
the
"
+
"
same
time
"
)
;
}
if
(
aUserDisabled
=
=
=
undefined
)
{
aUserDisabled
=
aAddon
.
userDisabled
;
}
else
if
(
!
aUserDisabled
)
{
aSoftDisabled
=
false
;
}
if
(
aSoftDisabled
=
=
=
undefined
|
|
aUserDisabled
)
aSoftDisabled
=
aAddon
.
softDisabled
;
let
appDisabled
=
!
isUsableAddon
(
aAddon
)
;
if
(
aAddon
.
userDisabled
=
=
aUserDisabled
&
&
aAddon
.
appDisabled
=
=
appDisabled
&
&
aAddon
.
softDisabled
=
=
aSoftDisabled
)
return
undefined
;
let
wasDisabled
=
aAddon
.
disabled
;
let
isDisabled
=
aUserDisabled
|
|
aSoftDisabled
|
|
appDisabled
;
let
appDisabledChanged
=
aAddon
.
appDisabled
!
=
appDisabled
;
XPIDatabase
.
setAddonProperties
(
aAddon
{
userDisabled
:
aUserDisabled
appDisabled
softDisabled
:
aSoftDisabled
}
)
;
let
wrapper
=
aAddon
.
wrapper
;
if
(
appDisabledChanged
)
{
AddonManagerPrivate
.
callAddonListeners
(
"
onPropertyChanged
"
wrapper
[
"
appDisabled
"
]
)
;
}
if
(
!
aAddon
.
visible
|
|
(
wasDisabled
=
=
isDisabled
)
)
return
undefined
;
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
true
)
;
let
xpiState
=
XPIStates
.
getAddon
(
aAddon
.
location
aAddon
.
id
)
;
if
(
xpiState
)
{
xpiState
.
syncWithDB
(
aAddon
)
;
XPIStates
.
save
(
)
;
}
else
{
logger
.
warn
(
"
No
XPIState
for
{
id
}
in
{
location
}
"
aAddon
)
;
}
if
(
isDisabled
!
=
aAddon
.
active
)
{
AddonManagerPrivate
.
callAddonListeners
(
"
onOperationCancelled
"
wrapper
)
;
}
else
{
if
(
isDisabled
)
{
var
needsRestart
=
aPendingRestart
|
|
this
.
disableRequiresRestart
(
aAddon
)
;
AddonManagerPrivate
.
callAddonListeners
(
"
onDisabling
"
wrapper
needsRestart
)
;
}
else
{
needsRestart
=
this
.
enableRequiresRestart
(
aAddon
)
;
AddonManagerPrivate
.
callAddonListeners
(
"
onEnabling
"
wrapper
needsRestart
)
;
}
if
(
!
needsRestart
)
{
XPIDatabase
.
updateAddonActive
(
aAddon
!
isDisabled
)
;
if
(
isDisabled
)
{
if
(
aAddon
.
bootstrap
&
&
this
.
activeAddons
.
has
(
aAddon
.
id
)
)
{
this
.
callBootstrapMethod
(
aAddon
aAddon
.
_sourceBundle
"
shutdown
"
BOOTSTRAP_REASONS
.
ADDON_DISABLE
)
;
this
.
unloadBootstrapScope
(
aAddon
.
id
)
;
}
AddonManagerPrivate
.
callAddonListeners
(
"
onDisabled
"
wrapper
)
;
}
else
{
if
(
aAddon
.
bootstrap
)
{
this
.
callBootstrapMethod
(
aAddon
aAddon
.
_sourceBundle
"
startup
"
BOOTSTRAP_REASONS
.
ADDON_ENABLE
)
;
}
AddonManagerPrivate
.
callAddonListeners
(
"
onEnabled
"
wrapper
)
;
}
}
}
if
(
isTheme
(
aAddon
.
type
)
&
&
!
isDisabled
)
{
AddonManagerPrivate
.
notifyAddonChanged
(
aAddon
.
id
aAddon
.
type
needsRestart
)
;
if
(
xpiState
)
{
xpiState
.
syncWithDB
(
aAddon
)
;
XPIStates
.
save
(
)
;
}
}
return
isDisabled
;
}
uninstallAddon
(
aAddon
aForcePending
)
{
if
(
!
(
aAddon
.
inDatabase
)
)
throw
new
Error
(
"
Cannot
uninstall
addon
"
+
aAddon
.
id
+
"
because
it
is
not
installed
"
)
;
if
(
aAddon
.
_installLocation
.
locked
)
throw
new
Error
(
"
Cannot
uninstall
addon
"
+
aAddon
.
id
+
"
from
locked
install
location
"
+
aAddon
.
_installLocation
.
name
)
;
let
requiresRestart
=
this
.
uninstallRequiresRestart
(
aAddon
)
;
let
makePending
=
aForcePending
|
|
requiresRestart
;
if
(
makePending
&
&
aAddon
.
pendingUninstall
)
throw
new
Error
(
"
Add
-
on
is
already
marked
to
be
uninstalled
"
)
;
aAddon
.
_hasResourceCache
.
clear
(
)
;
if
(
aAddon
.
_updateCheck
)
{
logger
.
debug
(
"
Cancel
in
-
progress
update
check
for
"
+
aAddon
.
id
)
;
aAddon
.
_updateCheck
.
cancel
(
)
;
}
let
wasPending
=
aAddon
.
pendingUninstall
;
if
(
makePending
)
{
if
(
aAddon
.
_installLocation
.
name
!
=
KEY_APP_TEMPORARY
)
{
let
stage
=
getFile
(
aAddon
.
id
aAddon
.
_installLocation
.
getStagingDir
(
)
)
;
if
(
!
stage
.
exists
(
)
)
stage
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
}
XPIDatabase
.
setAddonProperties
(
aAddon
{
pendingUninstall
:
true
}
)
;
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
true
)
;
let
xpiState
=
XPIStates
.
getAddon
(
aAddon
.
location
aAddon
.
id
)
;
if
(
xpiState
)
{
xpiState
.
enabled
=
false
;
XPIStates
.
save
(
)
;
}
else
{
logger
.
warn
(
"
Can
'
t
find
XPI
state
while
uninstalling
{
id
}
from
{
location
}
"
aAddon
)
;
}
}
if
(
!
aAddon
.
visible
)
return
;
let
wrapper
=
aAddon
.
wrapper
;
if
(
!
wasPending
)
{
AddonManagerPrivate
.
callAddonListeners
(
"
onUninstalling
"
wrapper
makePending
)
;
}
let
reason
=
BOOTSTRAP_REASONS
.
ADDON_UNINSTALL
;
let
callUpdate
=
false
;
let
existingAddon
=
XPIStates
.
findAddon
(
aAddon
.
id
loc
=
>
loc
.
name
!
=
aAddon
.
_installLocation
.
name
)
;
if
(
existingAddon
)
{
reason
=
newVersionReason
(
aAddon
.
version
existingAddon
.
version
)
;
callUpdate
=
isWebExtension
(
aAddon
.
type
)
&
&
isWebExtension
(
existingAddon
.
type
)
;
}
if
(
!
makePending
)
{
if
(
aAddon
.
bootstrap
)
{
if
(
aAddon
.
active
)
{
this
.
callBootstrapMethod
(
aAddon
aAddon
.
_sourceBundle
"
shutdown
"
reason
)
;
}
if
(
!
callUpdate
)
{
this
.
callBootstrapMethod
(
aAddon
aAddon
.
_sourceBundle
"
uninstall
"
reason
)
;
}
XPIStates
.
disableAddon
(
aAddon
.
id
)
;
this
.
unloadBootstrapScope
(
aAddon
.
id
)
;
flushChromeCaches
(
)
;
}
aAddon
.
_installLocation
.
uninstallAddon
(
aAddon
.
id
)
;
XPIDatabase
.
removeAddonMetadata
(
aAddon
)
;
XPIStates
.
removeAddon
(
aAddon
.
location
aAddon
.
id
)
;
AddonManagerPrivate
.
callAddonListeners
(
"
onUninstalled
"
wrapper
)
;
if
(
existingAddon
)
{
XPIDatabase
.
getAddonInLocation
(
aAddon
.
id
existingAddon
.
location
.
name
existing
=
>
{
XPIDatabase
.
makeAddonVisible
(
existing
)
;
let
wrappedAddon
=
existing
.
wrapper
;
AddonManagerPrivate
.
callAddonListeners
(
"
onInstalling
"
wrappedAddon
false
)
;
if
(
!
existing
.
disabled
&
&
!
XPIProvider
.
enableRequiresRestart
(
existing
)
)
{
XPIDatabase
.
updateAddonActive
(
existing
true
)
;
}
if
(
aAddon
.
bootstrap
)
{
let
method
=
callUpdate
?
"
update
"
:
"
install
"
;
XPIProvider
.
callBootstrapMethod
(
existing
existing
.
_sourceBundle
method
reason
)
;
if
(
existing
.
active
)
{
XPIProvider
.
callBootstrapMethod
(
existing
existing
.
_sourceBundle
"
startup
"
reason
)
;
}
else
{
XPIProvider
.
unloadBootstrapScope
(
existing
.
id
)
;
}
}
AddonManagerPrivate
.
callAddonListeners
(
"
onInstalled
"
wrappedAddon
)
;
}
)
;
}
}
else
if
(
aAddon
.
bootstrap
&
&
aAddon
.
active
&
&
!
this
.
disableRequiresRestart
(
aAddon
)
)
{
this
.
callBootstrapMethod
(
aAddon
aAddon
.
_sourceBundle
"
shutdown
"
reason
)
;
XPIStates
.
disableAddon
(
aAddon
.
id
)
;
this
.
unloadBootstrapScope
(
aAddon
.
id
)
;
XPIDatabase
.
updateAddonActive
(
aAddon
false
)
;
}
if
(
isTheme
(
aAddon
.
type
)
&
&
aAddon
.
active
)
AddonManagerPrivate
.
notifyAddonChanged
(
null
aAddon
.
type
requiresRestart
)
;
}
cancelUninstallAddon
(
aAddon
)
{
if
(
!
(
aAddon
.
inDatabase
)
)
throw
new
Error
(
"
Can
only
cancel
uninstall
for
installed
addons
.
"
)
;
if
(
!
aAddon
.
pendingUninstall
)
throw
new
Error
(
"
Add
-
on
is
not
marked
to
be
uninstalled
"
)
;
if
(
aAddon
.
_installLocation
.
name
!
=
KEY_APP_TEMPORARY
)
aAddon
.
_installLocation
.
cleanStagingDir
(
[
aAddon
.
id
]
)
;
XPIDatabase
.
setAddonProperties
(
aAddon
{
pendingUninstall
:
false
}
)
;
if
(
!
aAddon
.
visible
)
return
;
XPIStates
.
getAddon
(
aAddon
.
location
aAddon
.
id
)
.
syncWithDB
(
aAddon
)
;
XPIStates
.
save
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_PENDING_OPERATIONS
true
)
;
let
wrapper
=
aAddon
.
wrapper
;
AddonManagerPrivate
.
callAddonListeners
(
"
onOperationCancelled
"
wrapper
)
;
if
(
aAddon
.
bootstrap
&
&
!
aAddon
.
disabled
&
&
!
this
.
enableRequiresRestart
(
aAddon
)
)
{
this
.
callBootstrapMethod
(
aAddon
aAddon
.
_sourceBundle
"
startup
"
BOOTSTRAP_REASONS
.
ADDON_INSTALL
)
;
XPIDatabase
.
updateAddonActive
(
aAddon
true
)
;
}
if
(
isTheme
(
aAddon
.
type
)
&
&
aAddon
.
active
)
AddonManagerPrivate
.
notifyAddonChanged
(
aAddon
.
id
aAddon
.
type
false
)
;
}
}
;
function
createLocalInstall
(
file
location
)
{
if
(
!
location
)
{
location
=
XPIProvider
.
installLocationsByName
[
KEY_APP_PROFILE
]
;
}
let
url
=
Services
.
io
.
newFileURI
(
file
)
;
try
{
let
install
=
new
LocalAddonInstall
(
location
url
)
;
return
install
.
init
(
)
.
then
(
(
)
=
>
install
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Error
creating
install
"
e
)
;
XPIProvider
.
removeActiveInstall
(
this
)
;
return
Promise
.
resolve
(
null
)
;
}
}
const
wrapperMap
=
new
WeakMap
(
)
;
let
addonFor
=
wrapper
=
>
wrapperMap
.
get
(
wrapper
)
;
function
AddonInternal
(
)
{
this
.
_hasResourceCache
=
new
Map
(
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
wrapper
"
(
)
=
>
{
return
new
AddonWrapper
(
this
)
;
}
)
;
}
AddonInternal
.
prototype
=
{
_selectedLocale
:
null
_hasResourceCache
:
null
active
:
false
visible
:
false
userDisabled
:
false
appDisabled
:
false
softDisabled
:
false
blocklistState
:
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
blocklistURL
:
null
sourceURI
:
null
releaseNotesURI
:
null
foreignInstall
:
false
seen
:
true
skinnable
:
false
startupData
:
null
dependencies
:
Object
.
freeze
(
[
]
)
hasEmbeddedWebExtension
:
false
get
selectedLocale
(
)
{
if
(
this
.
_selectedLocale
)
return
this
.
_selectedLocale
;
const
locales
=
[
]
.
concat
(
.
.
.
this
.
locales
.
map
(
loc
=
>
loc
.
locales
)
)
;
let
requestedLocales
=
Services
.
locale
.
getRequestedLocales
(
)
;
if
(
!
requestedLocales
.
includes
(
"
en
-
US
"
)
)
{
requestedLocales
.
push
(
"
en
-
US
"
)
;
}
let
bestLocale
=
Services
.
locale
.
negotiateLanguages
(
requestedLocales
locales
"
und
"
Services
.
locale
.
langNegStrategyLookup
)
[
0
]
;
if
(
bestLocale
=
=
=
"
und
"
)
{
this
.
_selectedLocale
=
this
.
defaultLocale
;
}
else
{
this
.
_selectedLocale
=
this
.
locales
.
find
(
loc
=
>
loc
.
locales
.
includes
(
bestLocale
)
)
;
}
return
this
.
_selectedLocale
;
}
get
providesUpdatesSecurely
(
)
{
return
!
!
(
this
.
updateKey
|
|
!
this
.
updateURL
|
|
this
.
updateURL
.
substring
(
0
6
)
=
=
"
https
:
"
)
;
}
get
isCorrectlySigned
(
)
{
switch
(
this
.
_installLocation
.
name
)
{
case
KEY_APP_SYSTEM_ADDONS
:
return
this
.
signedState
=
=
AddonManager
.
SIGNEDSTATE_SYSTEM
;
case
KEY_APP_SYSTEM_DEFAULTS
:
case
KEY_APP_TEMPORARY
:
return
true
;
case
KEY_APP_SYSTEM_SHARE
:
case
KEY_APP_SYSTEM_LOCAL
:
if
(
Services
.
appinfo
.
OS
!
=
"
Darwin
"
)
return
true
;
break
;
}
if
(
this
.
signedState
=
=
=
AddonManager
.
SIGNEDSTATE_NOT_REQUIRED
)
return
true
;
return
this
.
signedState
>
AddonManager
.
SIGNEDSTATE_MISSING
;
}
get
isCompatible
(
)
{
return
this
.
isCompatibleWith
(
)
;
}
get
disabled
(
)
{
return
(
this
.
userDisabled
|
|
this
.
appDisabled
|
|
this
.
softDisabled
)
;
}
get
isPlatformCompatible
(
)
{
if
(
this
.
targetPlatforms
.
length
=
=
0
)
return
true
;
let
matchedOS
=
false
;
let
needsABI
=
false
;
let
abi
=
null
;
try
{
abi
=
Services
.
appinfo
.
XPCOMABI
;
}
catch
(
e
)
{
}
try
{
for
(
let
platform
of
this
.
targetPlatforms
)
{
if
(
platform
.
os
=
=
Services
.
appinfo
.
OS
)
{
if
(
platform
.
abi
)
{
needsABI
=
true
;
if
(
platform
.
abi
=
=
=
abi
)
return
true
;
}
else
{
matchedOS
=
true
;
}
}
}
}
catch
(
e
)
{
let
message
=
"
Problem
with
addon
"
+
this
.
id
+
"
targetPlatforms
"
+
JSON
.
stringify
(
this
.
targetPlatforms
)
;
logger
.
error
(
message
e
)
;
AddonManagerPrivate
.
recordException
(
"
XPI
"
message
e
)
;
return
false
;
}
return
matchedOS
&
&
!
needsABI
;
}
isCompatibleWith
(
aAppVersion
aPlatformVersion
)
{
let
app
=
this
.
matchingTargetApplication
;
if
(
!
app
)
return
false
;
let
minVersion
=
app
.
minVersion
|
|
"
0
"
;
let
maxVersion
=
app
.
maxVersion
|
|
"
*
"
;
if
(
!
aAppVersion
)
aAppVersion
=
Services
.
appinfo
.
version
;
if
(
!
aPlatformVersion
)
aPlatformVersion
=
Services
.
appinfo
.
platformVersion
;
let
version
;
if
(
app
.
id
=
=
Services
.
appinfo
.
ID
)
version
=
aAppVersion
;
else
if
(
app
.
id
=
=
TOOLKIT_ID
)
version
=
aPlatformVersion
;
if
(
this
.
type
in
COMPATIBLE_BY_DEFAULT_TYPES
&
&
!
AddonManager
.
strictCompatibility
&
&
!
this
.
strictCompatibility
&
&
!
this
.
hasBinaryComponents
)
{
if
(
this
.
_repositoryAddon
&
&
this
.
_repositoryAddon
.
compatibilityOverrides
)
{
let
overrides
=
this
.
_repositoryAddon
.
compatibilityOverrides
;
let
override
=
AddonRepository
.
findMatchingCompatOverride
(
this
.
version
overrides
)
;
if
(
override
&
&
override
.
type
=
=
"
incompatible
"
)
return
false
;
}
let
minCompatVersion
;
if
(
app
.
id
=
=
Services
.
appinfo
.
ID
)
minCompatVersion
=
XPIProvider
.
minCompatibleAppVersion
;
else
if
(
app
.
id
=
=
TOOLKIT_ID
)
minCompatVersion
=
XPIProvider
.
minCompatiblePlatformVersion
;
if
(
minCompatVersion
&
&
Services
.
vc
.
compare
(
minCompatVersion
maxVersion
)
>
0
)
return
false
;
return
Services
.
vc
.
compare
(
version
minVersion
)
>
=
0
;
}
return
(
Services
.
vc
.
compare
(
version
minVersion
)
>
=
0
)
&
&
(
Services
.
vc
.
compare
(
version
maxVersion
)
<
=
0
)
;
}
get
matchingTargetApplication
(
)
{
let
app
=
null
;
for
(
let
targetApp
of
this
.
targetApplications
)
{
if
(
targetApp
.
id
=
=
Services
.
appinfo
.
ID
)
return
targetApp
;
if
(
targetApp
.
id
=
=
TOOLKIT_ID
)
app
=
targetApp
;
}
return
app
;
}
findBlocklistEntry
(
)
{
let
staticItem
=
findMatchingStaticBlocklistItem
(
this
)
;
if
(
staticItem
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_BLOCKLIST_ITEM_URL
)
;
return
{
state
:
staticItem
.
level
url
:
url
.
replace
(
/
%
blockID
%
/
g
staticItem
.
blockID
)
}
;
}
return
Blocklist
.
getAddonBlocklistEntry
(
this
.
wrapper
)
;
}
updateBlocklistState
(
options
=
{
}
)
{
let
{
applySoftBlock
=
true
oldAddon
=
null
updateDatabase
=
true
}
=
options
;
if
(
oldAddon
)
{
this
.
userDisabled
=
oldAddon
.
userDisabled
;
this
.
softDisabled
=
oldAddon
.
softDisabled
;
this
.
blocklistState
=
oldAddon
.
blocklistState
;
}
let
oldState
=
this
.
blocklistState
;
let
entry
=
this
.
findBlocklistEntry
(
)
;
let
newState
=
entry
?
entry
.
state
:
Blocklist
.
STATE_NOT_BLOCKED
;
this
.
blocklistState
=
newState
;
this
.
blocklistURL
=
entry
&
&
entry
.
url
;
let
userDisabled
softDisabled
;
if
(
applySoftBlock
&
&
oldState
!
=
newState
)
{
if
(
newState
=
=
Blocklist
.
STATE_SOFTBLOCKED
)
{
if
(
this
.
type
=
=
"
theme
"
)
{
userDisabled
=
true
;
}
else
{
softDisabled
=
!
this
.
userDisabled
;
}
}
else
{
softDisabled
=
false
;
}
}
if
(
this
.
inDatabase
&
&
updateDatabase
)
{
XPIProvider
.
updateAddonDisabledState
(
this
userDisabled
softDisabled
)
;
XPIDatabase
.
saveChanges
(
)
;
}
else
{
this
.
appDisabled
=
!
isUsableAddon
(
this
)
;
if
(
userDisabled
!
=
=
undefined
)
{
this
.
userDisabled
=
userDisabled
;
}
if
(
softDisabled
!
=
=
undefined
)
{
this
.
softDisabled
=
softDisabled
;
}
}
}
applyCompatibilityUpdate
(
aUpdate
aSyncCompatibility
)
{
for
(
let
targetApp
of
this
.
targetApplications
)
{
for
(
let
updateTarget
of
aUpdate
.
targetApplications
)
{
if
(
targetApp
.
id
=
=
updateTarget
.
id
&
&
(
aSyncCompatibility
|
|
Services
.
vc
.
compare
(
targetApp
.
maxVersion
updateTarget
.
maxVersion
)
<
0
)
)
{
targetApp
.
minVersion
=
updateTarget
.
minVersion
;
targetApp
.
maxVersion
=
updateTarget
.
maxVersion
;
}
}
}
if
(
aUpdate
.
multiprocessCompatible
!
=
=
undefined
)
this
.
multiprocessCompatible
=
aUpdate
.
multiprocessCompatible
;
this
.
appDisabled
=
!
isUsableAddon
(
this
)
;
}
getDataDirectory
(
callback
)
{
let
parentPath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
extension
-
data
"
)
;
let
dirPath
=
OS
.
Path
.
join
(
parentPath
this
.
id
)
;
(
async
function
(
)
{
await
OS
.
File
.
makeDir
(
parentPath
{
ignoreExisting
:
true
}
)
;
await
OS
.
File
.
makeDir
(
dirPath
{
ignoreExisting
:
true
}
)
;
}
)
(
)
.
then
(
(
)
=
>
callback
(
dirPath
null
)
e
=
>
callback
(
dirPath
e
)
)
;
}
toJSON
(
aKey
)
{
let
obj
=
{
}
;
for
(
let
prop
in
this
)
{
if
(
prop
=
=
"
wrapper
"
)
continue
;
if
(
prop
.
substring
(
0
1
)
=
=
"
_
"
)
continue
;
if
(
this
.
__lookupGetter__
(
prop
)
)
continue
;
if
(
this
.
__lookupSetter__
(
prop
)
)
continue
;
if
(
typeof
this
[
prop
]
=
=
"
function
"
)
continue
;
obj
[
prop
]
=
this
[
prop
]
;
}
return
obj
;
}
importMetadata
(
aObj
)
{
for
(
let
prop
of
PENDING_INSTALL_METADATA
)
{
if
(
!
(
prop
in
aObj
)
)
continue
;
this
[
prop
]
=
aObj
[
prop
]
;
}
this
.
appDisabled
=
!
isUsableAddon
(
this
)
;
}
permissions
(
)
{
let
permissions
=
0
;
if
(
!
(
this
.
inDatabase
)
)
return
permissions
;
if
(
!
this
.
appDisabled
)
{
if
(
this
.
userDisabled
|
|
this
.
softDisabled
)
{
permissions
|
=
AddonManager
.
PERM_CAN_ENABLE
;
}
else
if
(
this
.
type
!
=
"
theme
"
)
{
permissions
|
=
AddonManager
.
PERM_CAN_DISABLE
;
}
}
if
(
!
this
.
_installLocation
.
locked
&
&
!
this
.
pendingUninstall
)
{
let
isSystem
=
this
.
_installLocation
.
isSystem
;
if
(
this
.
type
!
=
"
experiment
"
&
&
!
this
.
_installLocation
.
isLinkedAddon
(
this
.
id
)
&
&
!
isSystem
)
{
permissions
|
=
AddonManager
.
PERM_CAN_UPGRADE
;
}
permissions
|
=
AddonManager
.
PERM_CAN_UNINSTALL
;
}
return
permissions
;
}
}
;
function
AddonWrapper
(
aAddon
)
{
wrapperMap
.
set
(
this
aAddon
)
;
}
AddonWrapper
.
prototype
=
{
get
__AddonInternal__
(
)
{
return
AppConstants
.
DEBUG
?
addonFor
(
this
)
:
undefined
;
}
get
seen
(
)
{
return
addonFor
(
this
)
.
seen
;
}
get
hasEmbeddedWebExtension
(
)
{
return
addonFor
(
this
)
.
hasEmbeddedWebExtension
;
}
markAsSeen
(
)
{
addonFor
(
this
)
.
seen
=
true
;
XPIDatabase
.
saveChanges
(
)
;
}
get
type
(
)
{
return
getExternalType
(
addonFor
(
this
)
.
type
)
;
}
get
isWebExtension
(
)
{
return
isWebExtension
(
addonFor
(
this
)
.
type
)
;
}
get
isAPIExtension
(
)
{
return
addonFor
(
this
)
.
type
=
=
"
apiextension
"
;
}
get
temporarilyInstalled
(
)
{
return
addonFor
(
this
)
.
_installLocation
=
=
TemporaryInstallLocation
;
}
get
aboutURL
(
)
{
return
this
.
isActive
?
addonFor
(
this
)
.
aboutURL
:
null
;
}
get
optionsURL
(
)
{
if
(
!
this
.
isActive
)
{
return
null
;
}
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
optionsURL
)
{
if
(
this
.
isWebExtension
|
|
this
.
hasEmbeddedWebExtension
)
{
let
policy
=
WebExtensionPolicy
.
getByID
(
addon
.
id
)
;
if
(
!
policy
)
{
return
null
;
}
let
base
=
policy
.
getURL
(
)
;
return
new
URL
(
addon
.
optionsURL
base
)
.
href
;
}
return
addon
.
optionsURL
;
}
return
null
;
}
get
optionsType
(
)
{
if
(
!
this
.
isActive
)
return
null
;
let
addon
=
addonFor
(
this
)
;
let
hasOptionsURL
=
!
!
this
.
optionsURL
;
if
(
addon
.
optionsType
)
{
switch
(
parseInt
(
addon
.
optionsType
10
)
)
{
case
AddonManager
.
OPTIONS_TYPE_TAB
:
case
AddonManager
.
OPTIONS_TYPE_INLINE_BROWSER
:
return
hasOptionsURL
?
addon
.
optionsType
:
null
;
}
return
null
;
}
return
null
;
}
get
optionsBrowserStyle
(
)
{
let
addon
=
addonFor
(
this
)
;
return
addon
.
optionsBrowserStyle
;
}
get
iconURL
(
)
{
return
AddonManager
.
getPreferredIconURL
(
this
48
)
;
}
get
icon64URL
(
)
{
return
AddonManager
.
getPreferredIconURL
(
this
64
)
;
}
get
icons
(
)
{
let
addon
=
addonFor
(
this
)
;
let
icons
=
{
}
;
if
(
addon
.
_repositoryAddon
)
{
for
(
let
size
in
addon
.
_repositoryAddon
.
icons
)
{
icons
[
size
]
=
addon
.
_repositoryAddon
.
icons
[
size
]
;
}
}
if
(
addon
.
icons
)
{
for
(
let
size
in
addon
.
icons
)
{
icons
[
size
]
=
this
.
getResourceURI
(
addon
.
icons
[
size
]
)
.
spec
;
}
}
else
{
if
(
this
.
hasResource
(
"
icon
.
png
"
)
)
{
icons
[
32
]
=
icons
[
48
]
=
this
.
getResourceURI
(
"
icon
.
png
"
)
.
spec
;
}
if
(
this
.
hasResource
(
"
icon64
.
png
"
)
)
{
icons
[
64
]
=
this
.
getResourceURI
(
"
icon64
.
png
"
)
.
spec
;
}
}
let
canUseIconURLs
=
this
.
isActive
|
|
(
addon
.
type
=
=
"
theme
"
&
&
addon
.
internalName
=
=
XPIProvider
.
defaultSkin
)
;
if
(
canUseIconURLs
&
&
addon
.
iconURL
)
{
icons
[
32
]
=
addon
.
iconURL
;
icons
[
48
]
=
addon
.
iconURL
;
}
if
(
canUseIconURLs
&
&
addon
.
icon64URL
)
{
icons
[
64
]
=
addon
.
icon64URL
;
}
Object
.
freeze
(
icons
)
;
return
icons
;
}
get
screenshots
(
)
{
let
addon
=
addonFor
(
this
)
;
let
repositoryAddon
=
addon
.
_repositoryAddon
;
if
(
repositoryAddon
&
&
(
"
screenshots
"
in
repositoryAddon
)
)
{
let
repositoryScreenshots
=
repositoryAddon
.
screenshots
;
if
(
repositoryScreenshots
&
&
repositoryScreenshots
.
length
>
0
)
return
repositoryScreenshots
;
}
if
(
isTheme
(
addon
.
type
)
&
&
this
.
hasResource
(
"
preview
.
png
"
)
)
{
let
url
=
this
.
getResourceURI
(
"
preview
.
png
"
)
.
spec
;
return
[
new
AddonManagerPrivate
.
AddonScreenshot
(
url
)
]
;
}
return
null
;
}
get
applyBackgroundUpdates
(
)
{
return
addonFor
(
this
)
.
applyBackgroundUpdates
;
}
set
applyBackgroundUpdates
(
val
)
{
let
addon
=
addonFor
(
this
)
;
if
(
this
.
type
=
=
"
experiment
"
)
{
logger
.
warn
(
"
Setting
applyBackgroundUpdates
on
an
experiment
is
not
supported
.
"
)
;
return
addon
.
applyBackgroundUpdates
;
}
if
(
val
!
=
AddonManager
.
AUTOUPDATE_DEFAULT
&
&
val
!
=
AddonManager
.
AUTOUPDATE_DISABLE
&
&
val
!
=
AddonManager
.
AUTOUPDATE_ENABLE
)
{
val
=
val
?
AddonManager
.
AUTOUPDATE_DEFAULT
:
AddonManager
.
AUTOUPDATE_DISABLE
;
}
if
(
val
=
=
addon
.
applyBackgroundUpdates
)
return
val
;
XPIDatabase
.
setAddonProperties
(
addon
{
applyBackgroundUpdates
:
val
}
)
;
AddonManagerPrivate
.
callAddonListeners
(
"
onPropertyChanged
"
this
[
"
applyBackgroundUpdates
"
]
)
;
return
val
;
}
set
syncGUID
(
val
)
{
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
syncGUID
=
=
val
)
return
val
;
if
(
addon
.
inDatabase
)
XPIDatabase
.
setAddonSyncGUID
(
addon
val
)
;
addon
.
syncGUID
=
val
;
return
val
;
}
get
install
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
!
(
"
_install
"
in
addon
)
|
|
!
addon
.
_install
)
return
null
;
return
addon
.
_install
.
wrapper
;
}
get
pendingUpgrade
(
)
{
let
addon
=
addonFor
(
this
)
;
return
addon
.
pendingUpgrade
?
addon
.
pendingUpgrade
.
wrapper
:
null
;
}
get
scope
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
_installLocation
)
return
addon
.
_installLocation
.
scope
;
return
AddonManager
.
SCOPE_PROFILE
;
}
get
pendingOperations
(
)
{
let
addon
=
addonFor
(
this
)
;
let
pending
=
0
;
if
(
!
(
addon
.
inDatabase
)
)
{
if
(
!
addon
.
_install
|
|
addon
.
_install
.
state
=
=
AddonManager
.
STATE_INSTALLING
|
|
addon
.
_install
.
state
=
=
AddonManager
.
STATE_INSTALLED
)
return
AddonManager
.
PENDING_INSTALL
;
}
else
if
(
addon
.
pendingUninstall
)
{
return
AddonManager
.
PENDING_UNINSTALL
;
}
if
(
addon
.
active
&
&
addon
.
disabled
)
pending
|
=
AddonManager
.
PENDING_DISABLE
;
else
if
(
!
addon
.
active
&
&
!
addon
.
disabled
)
pending
|
=
AddonManager
.
PENDING_ENABLE
;
if
(
addon
.
pendingUpgrade
)
pending
|
=
AddonManager
.
PENDING_UPGRADE
;
return
pending
;
}
get
operationsRequiringRestart
(
)
{
let
addon
=
addonFor
(
this
)
;
let
ops
=
0
;
if
(
XPIProvider
.
installRequiresRestart
(
addon
)
)
ops
|
=
AddonManager
.
OP_NEEDS_RESTART_INSTALL
;
if
(
XPIProvider
.
uninstallRequiresRestart
(
addon
)
)
ops
|
=
AddonManager
.
OP_NEEDS_RESTART_UNINSTALL
;
if
(
XPIProvider
.
enableRequiresRestart
(
addon
)
)
ops
|
=
AddonManager
.
OP_NEEDS_RESTART_ENABLE
;
if
(
XPIProvider
.
disableRequiresRestart
(
addon
)
)
ops
|
=
AddonManager
.
OP_NEEDS_RESTART_DISABLE
;
return
ops
;
}
get
isDebuggable
(
)
{
return
this
.
isActive
&
&
addonFor
(
this
)
.
bootstrap
;
}
get
permissions
(
)
{
return
addonFor
(
this
)
.
permissions
(
)
;
}
get
isActive
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
!
addon
.
active
)
return
false
;
if
(
!
Services
.
appinfo
.
inSafeMode
)
return
true
;
return
addon
.
bootstrap
&
&
canRunInSafeMode
(
addon
)
;
}
get
startupPromise
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
!
addon
.
bootstrap
|
|
!
this
.
isActive
)
return
null
;
let
activeAddon
=
XPIProvider
.
activeAddons
.
get
(
addon
.
id
)
;
if
(
activeAddon
)
return
activeAddon
.
startupPromise
|
|
null
;
return
null
;
}
updateBlocklistState
(
applySoftBlock
=
true
)
{
addonFor
(
this
)
.
updateBlocklistState
(
{
applySoftBlock
}
)
;
}
get
userDisabled
(
)
{
let
addon
=
addonFor
(
this
)
;
return
addon
.
softDisabled
|
|
addon
.
userDisabled
;
}
set
userDisabled
(
val
)
{
let
addon
=
addonFor
(
this
)
;
if
(
val
=
=
this
.
userDisabled
)
{
return
val
;
}
if
(
addon
.
inDatabase
)
{
let
theme
=
isTheme
(
addon
.
type
)
;
if
(
theme
&
&
val
)
{
if
(
addon
.
internalName
=
=
XPIProvider
.
defaultSkin
)
throw
new
Error
(
"
Cannot
disable
the
default
theme
"
)
;
XPIProvider
.
enableDefaultTheme
(
)
;
}
if
(
!
(
theme
&
&
val
)
|
|
isWebExtension
(
addon
.
type
)
)
{
if
(
this
.
hidden
)
{
throw
new
Error
(
Cannot
disable
hidden
add
-
on
{
addon
.
id
}
)
;
}
XPIProvider
.
updateAddonDisabledState
(
addon
val
)
;
}
}
else
{
addon
.
userDisabled
=
val
;
if
(
!
val
)
addon
.
softDisabled
=
false
;
}
return
val
;
}
set
softDisabled
(
val
)
{
let
addon
=
addonFor
(
this
)
;
if
(
val
=
=
addon
.
softDisabled
)
return
val
;
if
(
addon
.
inDatabase
)
{
if
(
isTheme
(
addon
.
type
)
&
&
val
&
&
!
addon
.
userDisabled
)
{
if
(
addon
.
internalName
=
=
XPIProvider
.
defaultSkin
)
throw
new
Error
(
"
Cannot
disable
the
default
theme
"
)
;
XPIProvider
.
enableDefaultTheme
(
)
;
if
(
isWebExtension
(
addon
.
type
)
)
XPIProvider
.
updateAddonDisabledState
(
addon
undefined
val
)
;
}
else
{
XPIProvider
.
updateAddonDisabledState
(
addon
undefined
val
)
;
}
}
else
if
(
!
addon
.
userDisabled
)
{
addon
.
softDisabled
=
val
;
}
return
val
;
}
get
hidden
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
_installLocation
.
name
=
=
KEY_APP_TEMPORARY
)
return
false
;
return
addon
.
_installLocation
.
isSystem
;
}
get
isSystem
(
)
{
let
addon
=
addonFor
(
this
)
;
return
addon
.
_installLocation
.
isSystem
;
}
get
isSyncable
(
)
{
let
addon
=
addonFor
(
this
)
;
let
hotfixID
=
Services
.
prefs
.
getStringPref
(
PREF_EM_HOTFIX_ID
undefined
)
;
if
(
hotfixID
&
&
hotfixID
=
=
addon
.
id
)
{
return
false
;
}
return
(
addon
.
_installLocation
.
name
=
=
KEY_APP_PROFILE
)
;
}
get
userPermissions
(
)
{
return
addonFor
(
this
)
.
userPermissions
;
}
isCompatibleWith
(
aAppVersion
aPlatformVersion
)
{
return
addonFor
(
this
)
.
isCompatibleWith
(
aAppVersion
aPlatformVersion
)
;
}
uninstall
(
alwaysAllowUndo
)
{
let
addon
=
addonFor
(
this
)
;
XPIProvider
.
uninstallAddon
(
addon
alwaysAllowUndo
)
;
}
cancelUninstall
(
)
{
let
addon
=
addonFor
(
this
)
;
XPIProvider
.
cancelUninstallAddon
(
addon
)
;
}
findUpdates
(
aListener
aReason
aAppVersion
aPlatformVersion
)
{
if
(
this
.
type
=
=
"
experiment
"
)
{
AddonManagerPrivate
.
callNoUpdateListeners
(
this
aListener
aReason
aAppVersion
aPlatformVersion
)
;
return
;
}
new
UpdateChecker
(
addonFor
(
this
)
aListener
aReason
aAppVersion
aPlatformVersion
)
;
}
cancelUpdate
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
_updateCheck
)
{
addon
.
_updateCheck
.
cancel
(
)
;
return
true
;
}
return
false
;
}
hasResource
(
aPath
)
{
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
_hasResourceCache
.
has
(
aPath
)
)
return
addon
.
_hasResourceCache
.
get
(
aPath
)
;
let
bundle
=
addon
.
_sourceBundle
.
clone
(
)
;
try
{
var
isDir
=
bundle
.
isDirectory
(
)
;
}
catch
(
e
)
{
addon
.
_hasResourceCache
.
set
(
aPath
false
)
;
return
false
;
}
if
(
isDir
)
{
if
(
aPath
)
aPath
.
split
(
"
/
"
)
.
forEach
(
part
=
>
bundle
.
append
(
part
)
)
;
let
result
=
bundle
.
exists
(
)
;
addon
.
_hasResourceCache
.
set
(
aPath
result
)
;
return
result
;
}
let
zipReader
=
Cc
[
"
mozilla
.
org
/
libjar
/
zip
-
reader
;
1
"
]
.
createInstance
(
Ci
.
nsIZipReader
)
;
try
{
zipReader
.
open
(
bundle
)
;
let
result
=
zipReader
.
hasEntry
(
aPath
)
;
addon
.
_hasResourceCache
.
set
(
aPath
result
)
;
return
result
;
}
catch
(
e
)
{
addon
.
_hasResourceCache
.
set
(
aPath
false
)
;
return
false
;
}
finally
{
zipReader
.
close
(
)
;
}
}
reload
(
)
{
return
new
Promise
(
(
resolve
)
=
>
{
const
addon
=
addonFor
(
this
)
;
logger
.
debug
(
reloading
add
-
on
{
addon
.
id
}
)
;
if
(
!
this
.
temporarilyInstalled
)
{
let
addonFile
=
addon
.
getResourceURI
;
XPIProvider
.
updateAddonDisabledState
(
addon
true
)
;
Services
.
obs
.
notifyObservers
(
addonFile
"
flush
-
cache
-
entry
"
)
;
XPIProvider
.
updateAddonDisabledState
(
addon
false
)
;
resolve
(
)
;
}
else
{
resolve
(
AddonManager
.
installTemporaryAddon
(
addon
.
_sourceBundle
)
)
;
}
}
)
;
}
getResourceURI
(
aPath
)
{
let
addon
=
addonFor
(
this
)
;
if
(
!
aPath
)
return
Services
.
io
.
newFileURI
(
addon
.
_sourceBundle
)
;
return
getURIForResourceInFile
(
addon
.
_sourceBundle
aPath
)
;
}
}
;
function
chooseValue
(
aAddon
aObj
aProp
)
{
let
repositoryAddon
=
aAddon
.
_repositoryAddon
;
let
objValue
=
aObj
[
aProp
]
;
if
(
repositoryAddon
&
&
(
aProp
in
repositoryAddon
)
&
&
(
objValue
=
=
=
undefined
|
|
objValue
=
=
=
null
)
)
{
return
[
repositoryAddon
[
aProp
]
true
]
;
}
return
[
objValue
false
]
;
}
function
defineAddonWrapperProperty
(
name
getter
)
{
Object
.
defineProperty
(
AddonWrapper
.
prototype
name
{
get
:
getter
enumerable
:
true
}
)
;
}
[
"
id
"
"
syncGUID
"
"
version
"
"
isCompatible
"
"
isPlatformCompatible
"
"
providesUpdatesSecurely
"
"
blocklistState
"
"
blocklistURL
"
"
appDisabled
"
"
softDisabled
"
"
skinnable
"
"
size
"
"
foreignInstall
"
"
hasBinaryComponents
"
"
strictCompatibility
"
"
compatibilityOverrides
"
"
updateURL
"
"
dependencies
"
"
getDataDirectory
"
"
multiprocessCompatible
"
"
signedState
"
"
mpcOptedOut
"
"
isCorrectlySigned
"
]
.
forEach
(
function
(
aProp
)
{
defineAddonWrapperProperty
(
aProp
function
(
)
{
let
addon
=
addonFor
(
this
)
;
return
(
aProp
in
addon
)
?
addon
[
aProp
]
:
undefined
;
}
)
;
}
)
;
[
"
fullDescription
"
"
developerComments
"
"
eula
"
"
supportURL
"
"
contributionURL
"
"
contributionAmount
"
"
averageRating
"
"
reviewCount
"
"
reviewURL
"
"
totalDownloads
"
"
weeklyDownloads
"
"
dailyUsers
"
"
repositoryStatus
"
]
.
forEach
(
function
(
aProp
)
{
defineAddonWrapperProperty
(
aProp
function
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
addon
.
_repositoryAddon
)
return
addon
.
_repositoryAddon
[
aProp
]
;
return
null
;
}
)
;
}
)
;
[
"
installDate
"
"
updateDate
"
]
.
forEach
(
function
(
aProp
)
{
defineAddonWrapperProperty
(
aProp
function
(
)
{
return
new
Date
(
addonFor
(
this
)
[
aProp
]
)
;
}
)
;
}
)
;
[
"
sourceURI
"
"
releaseNotesURI
"
]
.
forEach
(
function
(
aProp
)
{
defineAddonWrapperProperty
(
aProp
function
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
aProp
=
=
"
sourceURI
"
&
&
this
.
temporarilyInstalled
)
{
return
Services
.
io
.
newFileURI
(
addon
.
_sourceBundle
)
;
}
let
[
target
fromRepo
]
=
chooseValue
(
addon
addon
aProp
)
;
if
(
!
target
)
return
null
;
if
(
fromRepo
)
return
target
;
return
Services
.
io
.
newURI
(
target
)
;
}
)
;
}
)
;
PROP_LOCALE_SINGLE
.
forEach
(
function
(
aProp
)
{
defineAddonWrapperProperty
(
aProp
function
(
)
{
let
addon
=
addonFor
(
this
)
;
if
(
aProp
=
=
"
creator
"
&
&
addon
.
_repositoryAddon
&
&
addon
.
_repositoryAddon
.
creator
)
{
return
addon
.
_repositoryAddon
.
creator
;
}
let
result
=
null
;
if
(
addon
.
active
)
{
try
{
let
pref
=
PREF_EM_EXTENSION_FORMAT
+
addon
.
id
+
"
.
"
+
aProp
;
let
value
=
Services
.
prefs
.
getPrefType
(
pref
)
!
=
Ci
.
nsIPrefBranch
.
PREF_INVALID
?
Services
.
prefs
.
getComplexValue
(
pref
Ci
.
nsIPrefLocalizedString
)
.
data
:
null
;
if
(
value
)
result
=
value
;
}
catch
(
e
)
{
}
}
if
(
result
=
=
null
)
[
result
]
=
chooseValue
(
addon
addon
.
selectedLocale
aProp
)
;
if
(
aProp
=
=
"
creator
"
)
return
result
?
new
AddonManagerPrivate
.
AddonAuthor
(
result
)
:
null
;
return
result
;
}
)
;
}
)
;
PROP_LOCALE_MULTI
.
forEach
(
function
(
aProp
)
{
defineAddonWrapperProperty
(
aProp
function
(
)
{
let
addon
=
addonFor
(
this
)
;
let
results
=
null
;
let
usedRepository
=
false
;
if
(
addon
.
active
)
{
let
pref
=
PREF_EM_EXTENSION_FORMAT
+
addon
.
id
+
"
.
"
+
aProp
.
substring
(
0
aProp
.
length
-
1
)
;
let
list
=
Services
.
prefs
.
getChildList
(
pref
{
}
)
;
if
(
list
.
length
>
0
)
{
list
.
sort
(
)
;
results
=
[
]
;
for
(
let
childPref
of
list
)
{
let
value
=
Services
.
prefs
.
getPrefType
(
childPref
)
!
=
Ci
.
nsIPrefBranch
.
PREF_INVALID
?
Services
.
prefs
.
getComplexValue
(
childPref
Ci
.
nsIPrefLocalizedString
)
.
data
:
null
;
if
(
value
)
results
.
push
(
value
)
;
}
}
}
if
(
results
=
=
null
)
[
results
usedRepository
]
=
chooseValue
(
addon
addon
.
selectedLocale
aProp
)
;
if
(
results
&
&
!
usedRepository
)
{
results
=
results
.
map
(
function
(
aResult
)
{
return
new
AddonManagerPrivate
.
AddonAuthor
(
aResult
)
;
}
)
;
}
return
results
;
}
)
;
}
)
;
class
DirectoryInstallLocation
{
constructor
(
aName
aDirectory
aScope
)
{
this
.
_name
=
aName
;
this
.
locked
=
true
;
this
.
_directory
=
aDirectory
;
this
.
_scope
=
aScope
;
this
.
_IDToFileMap
=
{
}
;
this
.
_linkedAddons
=
[
]
;
this
.
isSystem
=
(
aName
=
=
KEY_APP_SYSTEM_ADDONS
|
|
aName
=
=
KEY_APP_SYSTEM_DEFAULTS
)
;
if
(
!
aDirectory
|
|
!
aDirectory
.
exists
(
)
)
return
;
if
(
!
aDirectory
.
isDirectory
(
)
)
throw
new
Error
(
"
Location
must
be
a
directory
.
"
)
;
this
.
initialized
=
false
;
}
get
path
(
)
{
return
this
.
_directory
&
&
this
.
_directory
.
path
;
}
_readDirectoryFromFile
(
aFile
)
{
let
linkedDirectory
;
if
(
aFile
.
isSymlink
(
)
)
{
linkedDirectory
=
aFile
.
clone
(
)
;
try
{
linkedDirectory
.
normalize
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Symbolic
link
"
+
aFile
.
path
+
"
points
to
a
path
"
+
"
which
does
not
exist
"
)
;
return
null
;
}
}
else
{
let
fis
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fis
.
init
(
aFile
-
1
-
1
false
)
;
let
line
=
{
value
:
"
"
}
;
if
(
fis
instanceof
Ci
.
nsILineInputStream
)
fis
.
readLine
(
line
)
;
fis
.
close
(
)
;
if
(
line
.
value
)
{
linkedDirectory
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
try
{
linkedDirectory
.
initWithPath
(
line
.
value
)
;
}
catch
(
e
)
{
linkedDirectory
.
setRelativeDescriptor
(
aFile
.
parent
line
.
value
)
;
}
}
}
if
(
linkedDirectory
)
{
if
(
!
linkedDirectory
.
exists
(
)
)
{
logger
.
warn
(
"
File
pointer
"
+
aFile
.
path
+
"
points
to
"
+
linkedDirectory
.
path
+
"
which
does
not
exist
"
)
;
return
null
;
}
if
(
!
linkedDirectory
.
isDirectory
(
)
)
{
logger
.
warn
(
"
File
pointer
"
+
aFile
.
path
+
"
points
to
"
+
linkedDirectory
.
path
+
"
which
is
not
a
directory
"
)
;
return
null
;
}
return
linkedDirectory
;
}
logger
.
warn
(
"
File
pointer
"
+
aFile
.
path
+
"
does
not
contain
a
path
"
)
;
return
null
;
}
_readAddons
(
rescan
=
false
)
{
if
(
(
this
.
initialized
&
&
!
rescan
)
|
|
!
this
.
_directory
)
{
return
;
}
this
.
initialized
=
true
;
let
entries
=
getDirectoryEntries
(
this
.
_directory
)
;
for
(
let
entry
of
entries
)
{
let
id
=
entry
.
leafName
;
if
(
id
=
=
DIR_STAGE
|
|
id
=
=
DIR_TRASH
)
continue
;
let
directLoad
=
false
;
if
(
entry
.
isFile
(
)
&
&
id
.
substring
(
id
.
length
-
4
)
.
toLowerCase
(
)
=
=
"
.
xpi
"
)
{
directLoad
=
true
;
id
=
id
.
substring
(
0
id
.
length
-
4
)
;
}
if
(
!
gIDTest
.
test
(
id
)
)
{
logger
.
debug
(
"
Ignoring
file
entry
whose
name
is
not
a
valid
add
-
on
ID
:
"
+
entry
.
path
)
;
continue
;
}
if
(
!
directLoad
&
&
(
entry
.
isFile
(
)
|
|
entry
.
isSymlink
(
)
)
)
{
let
newEntry
=
this
.
_readDirectoryFromFile
(
entry
)
;
if
(
!
newEntry
)
{
logger
.
debug
(
"
Deleting
stale
pointer
file
"
+
entry
.
path
)
;
try
{
entry
.
remove
(
true
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
remove
stale
pointer
file
"
+
entry
.
path
e
)
;
}
continue
;
}
entry
=
newEntry
;
this
.
_linkedAddons
.
push
(
id
)
;
}
this
.
_IDToFileMap
[
id
]
=
entry
;
XPIProvider
.
_addURIMapping
(
id
entry
)
;
}
}
get
name
(
)
{
return
this
.
_name
;
}
get
scope
(
)
{
return
this
.
_scope
;
}
getAddonLocations
(
rescan
=
false
)
{
this
.
_readAddons
(
rescan
)
;
let
locations
=
new
Map
(
)
;
for
(
let
id
in
this
.
_IDToFileMap
)
{
locations
.
set
(
id
this
.
_IDToFileMap
[
id
]
.
clone
(
)
)
;
}
return
locations
;
}
getLocationForID
(
aId
)
{
if
(
!
(
aId
in
this
.
_IDToFileMap
)
)
this
.
_readAddons
(
)
;
if
(
aId
in
this
.
_IDToFileMap
)
return
this
.
_IDToFileMap
[
aId
]
.
clone
(
)
;
throw
new
Error
(
"
Unknown
add
-
on
ID
"
+
aId
)
;
}
isLinkedAddon
(
aId
)
{
return
this
.
_linkedAddons
.
indexOf
(
aId
)
!
=
-
1
;
}
}
class
MutableDirectoryInstallLocation
extends
DirectoryInstallLocation
{
constructor
(
aName
aDirectory
aScope
)
{
super
(
aName
aDirectory
aScope
)
;
this
.
locked
=
false
;
this
.
_stagingDirLock
=
0
;
}
getStagingDir
(
)
{
return
getFile
(
DIR_STAGE
this
.
_directory
)
;
}
requestStagingDir
(
)
{
this
.
_stagingDirLock
+
+
;
if
(
this
.
_stagingDirPromise
)
return
this
.
_stagingDirPromise
;
OS
.
File
.
makeDir
(
this
.
_directory
.
path
)
;
let
stagepath
=
OS
.
Path
.
join
(
this
.
_directory
.
path
DIR_STAGE
)
;
return
this
.
_stagingDirPromise
=
OS
.
File
.
makeDir
(
stagepath
)
.
catch
(
(
e
)
=
>
{
if
(
e
instanceof
OS
.
File
.
Error
&
&
e
.
becauseExists
)
return
;
logger
.
error
(
"
Failed
to
create
staging
directory
"
e
)
;
throw
e
;
}
)
;
}
releaseStagingDir
(
)
{
this
.
_stagingDirLock
-
-
;
if
(
this
.
_stagingDirLock
=
=
0
)
{
this
.
_stagingDirPromise
=
null
;
this
.
cleanStagingDir
(
)
;
}
return
Promise
.
resolve
(
)
;
}
cleanStagingDir
(
aLeafNames
=
[
]
)
{
let
dir
=
this
.
getStagingDir
(
)
;
for
(
let
name
of
aLeafNames
)
{
let
file
=
getFile
(
name
dir
)
;
recursiveRemove
(
file
)
;
}
if
(
this
.
_stagingDirLock
>
0
)
return
;
let
dirEntries
=
dir
.
directoryEntries
.
QueryInterface
(
Ci
.
nsIDirectoryEnumerator
)
;
try
{
if
(
dirEntries
.
nextFile
)
return
;
}
finally
{
dirEntries
.
close
(
)
;
}
try
{
setFilePermissions
(
dir
FileUtils
.
PERMS_DIRECTORY
)
;
dir
.
remove
(
false
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
remove
staging
dir
"
e
)
;
}
}
getTrashDir
(
)
{
let
trashDir
=
getFile
(
DIR_TRASH
this
.
_directory
)
;
let
trashDirExists
=
trashDir
.
exists
(
)
;
try
{
if
(
trashDirExists
)
recursiveRemove
(
trashDir
)
;
trashDirExists
=
false
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
remove
trash
directory
"
e
)
;
}
if
(
!
trashDirExists
)
trashDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
return
trashDir
;
}
installAddon
(
{
id
source
existingAddonID
action
=
"
move
"
}
)
{
let
trashDir
=
this
.
getTrashDir
(
)
;
let
transaction
=
new
SafeInstallOperation
(
)
;
let
moveOldAddon
=
aId
=
>
{
let
file
=
getFile
(
aId
this
.
_directory
)
;
if
(
file
.
exists
(
)
)
transaction
.
moveUnder
(
file
trashDir
)
;
file
=
getFile
(
{
aId
}
.
xpi
this
.
_directory
)
;
if
(
file
.
exists
(
)
)
{
flushJarCache
(
file
)
;
transaction
.
moveUnder
(
file
trashDir
)
;
}
}
;
try
{
moveOldAddon
(
id
)
;
if
(
existingAddonID
&
&
existingAddonID
!
=
id
)
{
moveOldAddon
(
existingAddonID
)
;
{
let
oldDataDir
=
FileUtils
.
getDir
(
KEY_PROFILEDIR
[
"
extension
-
data
"
existingAddonID
]
false
true
)
;
if
(
oldDataDir
.
exists
(
)
)
{
let
newDataDir
=
FileUtils
.
getDir
(
KEY_PROFILEDIR
[
"
extension
-
data
"
id
]
false
true
)
;
if
(
newDataDir
.
exists
(
)
)
{
let
trashData
=
getFile
(
"
data
-
directory
"
trashDir
)
;
transaction
.
moveUnder
(
newDataDir
trashData
)
;
}
transaction
.
moveTo
(
oldDataDir
newDataDir
)
;
}
}
}
if
(
action
=
=
"
copy
"
)
{
transaction
.
copy
(
source
this
.
_directory
)
;
}
else
if
(
action
=
=
"
move
"
)
{
if
(
source
.
isFile
(
)
)
flushJarCache
(
source
)
;
transaction
.
moveUnder
(
source
this
.
_directory
)
;
}
}
finally
{
try
{
recursiveRemove
(
trashDir
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
remove
trash
directory
when
installing
"
+
id
e
)
;
}
}
let
newFile
=
this
.
_directory
.
clone
(
)
;
if
(
action
=
=
"
proxy
"
)
{
newFile
.
append
(
id
)
;
writeStringToFile
(
newFile
source
.
path
)
;
}
else
{
newFile
.
append
(
source
.
leafName
)
;
}
try
{
newFile
.
lastModifiedTime
=
Date
.
now
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
failed
to
set
lastModifiedTime
on
"
+
newFile
.
path
e
)
;
}
this
.
_IDToFileMap
[
id
]
=
newFile
;
XPIProvider
.
_addURIMapping
(
id
newFile
)
;
if
(
existingAddonID
&
&
existingAddonID
!
=
id
&
&
existingAddonID
in
this
.
_IDToFileMap
)
{
delete
this
.
_IDToFileMap
[
existingAddonID
]
;
}
return
newFile
;
}
uninstallAddon
(
aId
)
{
let
file
=
this
.
_IDToFileMap
[
aId
]
;
if
(
!
file
)
{
logger
.
warn
(
"
Attempted
to
remove
"
+
aId
+
"
from
"
+
this
.
_name
+
"
but
it
was
already
gone
"
)
;
return
;
}
file
=
getFile
(
aId
this
.
_directory
)
;
if
(
!
file
.
exists
(
)
)
file
.
leafName
+
=
"
.
xpi
"
;
if
(
!
file
.
exists
(
)
)
{
logger
.
warn
(
"
Attempted
to
remove
"
+
aId
+
"
from
"
+
this
.
_name
+
"
but
it
was
already
gone
"
)
;
delete
this
.
_IDToFileMap
[
aId
]
;
return
;
}
let
trashDir
=
this
.
getTrashDir
(
)
;
if
(
file
.
leafName
!
=
aId
)
{
logger
.
debug
(
"
uninstallAddon
:
flushing
jar
cache
"
+
file
.
path
+
"
for
addon
"
+
aId
)
;
flushJarCache
(
file
)
;
}
let
transaction
=
new
SafeInstallOperation
(
)
;
try
{
transaction
.
moveUnder
(
file
trashDir
)
;
}
finally
{
try
{
recursiveRemove
(
trashDir
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
remove
trash
directory
when
uninstalling
"
+
aId
e
)
;
}
}
XPIStates
.
removeAddon
(
this
.
name
aId
)
;
delete
this
.
_IDToFileMap
[
aId
]
;
}
}
class
BuiltInInstallLocation
extends
DirectoryInstallLocation
{
_readAddons
(
)
{
let
manifest
;
try
{
let
url
=
Services
.
io
.
newURI
(
BUILT_IN_ADDONS_URI
)
;
let
data
=
Cu
.
readUTF8URI
(
url
)
;
manifest
=
JSON
.
parse
(
data
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
List
of
valid
built
-
in
add
-
ons
could
not
be
parsed
.
"
e
)
;
return
;
}
if
(
!
(
"
system
"
in
manifest
)
)
{
logger
.
warn
(
"
No
list
of
valid
system
add
-
ons
found
.
"
)
;
return
;
}
for
(
let
id
of
manifest
.
system
)
{
let
file
=
new
FileUtils
.
File
(
this
.
_directory
.
path
)
;
file
.
append
(
{
id
}
.
xpi
)
;
if
(
!
AppConstants
.
MOZILLA_OFFICIAL
&
&
!
file
.
exists
(
)
)
{
file
=
new
FileUtils
.
File
(
this
.
_directory
.
path
)
;
file
.
append
(
{
id
}
)
;
}
this
.
_IDToFileMap
[
id
]
=
file
;
XPIProvider
.
_addURIMapping
(
id
file
)
;
}
}
}
class
SystemAddonInstallLocation
extends
MutableDirectoryInstallLocation
{
constructor
(
aName
aDirectory
aScope
aResetSet
)
{
let
addonSet
=
SystemAddonInstallLocation
.
_loadAddonSet
(
)
;
let
directory
=
null
;
if
(
addonSet
.
directory
)
{
directory
=
getFile
(
addonSet
.
directory
aDirectory
)
;
logger
.
info
(
"
SystemAddonInstallLocation
scanning
directory
"
+
directory
.
path
)
;
}
else
{
logger
.
info
(
"
SystemAddonInstallLocation
directory
is
missing
"
)
;
}
super
(
aName
directory
aScope
)
;
this
.
_addonSet
=
addonSet
;
this
.
_baseDir
=
aDirectory
;
this
.
_nextDir
=
null
;
this
.
_directory
=
directory
;
this
.
_stagingDirLock
=
0
;
if
(
aResetSet
)
{
this
.
resetAddonSet
(
)
;
}
this
.
locked
=
false
;
}
getStagingDir
(
)
{
this
.
_addonSet
=
SystemAddonInstallLocation
.
_loadAddonSet
(
)
;
let
dir
=
null
;
if
(
this
.
_addonSet
.
directory
)
{
this
.
_directory
=
getFile
(
this
.
_addonSet
.
directory
this
.
_baseDir
)
;
dir
=
getFile
(
DIR_STAGE
this
.
_directory
)
;
}
else
{
logger
.
info
(
"
SystemAddonInstallLocation
directory
is
missing
"
)
;
}
return
dir
;
}
requestStagingDir
(
)
{
this
.
_addonSet
=
SystemAddonInstallLocation
.
_loadAddonSet
(
)
;
if
(
this
.
_addonSet
.
directory
)
{
this
.
_directory
=
getFile
(
this
.
_addonSet
.
directory
this
.
_baseDir
)
;
}
return
super
.
requestStagingDir
(
)
;
}
static
_loadAddonSet
(
)
{
try
{
let
setStr
=
Services
.
prefs
.
getStringPref
(
PREF_SYSTEM_ADDON_SET
null
)
;
if
(
setStr
)
{
let
addonSet
=
JSON
.
parse
(
setStr
)
;
if
(
(
typeof
addonSet
=
=
"
object
"
)
&
&
addonSet
.
schema
=
=
1
)
{
return
addonSet
;
}
}
}
catch
(
e
)
{
logger
.
error
(
"
Malformed
system
add
-
on
set
resetting
.
"
)
;
}
return
{
schema
:
1
addons
:
{
}
}
;
}
static
_saveAddonSet
(
aAddonSet
)
{
Services
.
prefs
.
setStringPref
(
PREF_SYSTEM_ADDON_SET
JSON
.
stringify
(
aAddonSet
)
)
;
}
getAddonLocations
(
)
{
if
(
Services
.
appinfo
.
inSafeMode
)
{
return
new
Map
(
)
;
}
let
addons
=
super
.
getAddonLocations
(
)
;
for
(
let
id
of
addons
.
keys
(
)
)
{
if
(
!
(
id
in
this
.
_addonSet
.
addons
)
)
{
addons
.
delete
(
id
)
;
}
}
return
addons
;
}
isActive
(
)
{
return
this
.
_directory
!
=
null
;
}
isValidAddon
(
aAddon
)
{
if
(
aAddon
.
appDisabled
)
{
logger
.
warn
(
System
add
-
on
{
aAddon
.
id
}
isn
'
t
compatible
with
the
application
.
)
;
return
false
;
}
if
(
aAddon
.
unpack
)
{
logger
.
warn
(
System
add
-
on
{
aAddon
.
id
}
isn
'
t
a
packed
add
-
on
.
)
;
return
false
;
}
if
(
!
aAddon
.
bootstrap
)
{
logger
.
warn
(
System
add
-
on
{
aAddon
.
id
}
isn
'
t
restartless
.
)
;
return
false
;
}
if
(
!
aAddon
.
multiprocessCompatible
)
{
logger
.
warn
(
System
add
-
on
{
aAddon
.
id
}
isn
'
t
multiprocess
compatible
.
)
;
return
false
;
}
return
true
;
}
isValid
(
aAddons
)
{
for
(
let
id
of
Object
.
keys
(
this
.
_addonSet
.
addons
)
)
{
if
(
!
aAddons
.
has
(
id
)
)
{
logger
.
warn
(
Expected
add
-
on
{
id
}
is
missing
from
the
system
add
-
on
location
.
)
;
return
false
;
}
let
addon
=
aAddons
.
get
(
id
)
;
if
(
addon
.
version
!
=
this
.
_addonSet
.
addons
[
id
]
.
version
)
{
logger
.
warn
(
Expected
system
add
-
on
{
id
}
to
be
version
{
this
.
_addonSet
.
addons
[
id
]
.
version
}
but
was
{
addon
.
version
}
.
)
;
return
false
;
}
if
(
!
this
.
isValidAddon
(
addon
)
)
return
false
;
}
return
true
;
}
resetAddonSet
(
)
{
logger
.
info
(
"
Removing
all
system
add
-
on
upgrades
.
"
)
;
this
.
_addonSet
=
{
schema
:
1
addons
:
{
}
}
;
SystemAddonInstallLocation
.
_saveAddonSet
(
this
.
_addonSet
)
;
if
(
this
.
_addonSet
)
{
for
(
let
id
of
Object
.
keys
(
this
.
_addonSet
.
addons
)
)
{
AddonManager
.
getAddonByID
(
id
addon
=
>
{
if
(
addon
)
{
addon
.
uninstall
(
)
;
}
}
)
;
}
}
}
async
cleanDirectories
(
)
{
if
(
!
(
await
OS
.
File
.
exists
(
this
.
_baseDir
.
path
)
)
)
{
return
;
}
let
iterator
;
try
{
iterator
=
new
OS
.
File
.
DirectoryIterator
(
this
.
_baseDir
.
path
)
;
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
clean
updated
system
add
-
ons
directories
.
"
e
)
;
return
;
}
try
{
for
(
;
;
)
{
let
{
value
:
entry
done
}
=
await
iterator
.
next
(
)
;
if
(
done
)
{
break
;
}
if
(
this
.
_directory
&
&
this
.
_directory
.
path
=
=
entry
.
path
)
{
continue
;
}
if
(
this
.
_nextDir
&
&
this
.
_nextDir
.
path
=
=
entry
.
path
)
{
continue
;
}
if
(
entry
.
isDir
)
{
await
OS
.
File
.
removeDir
(
entry
.
path
{
ignoreAbsent
:
true
ignorePermissions
:
true
}
)
;
}
else
{
await
OS
.
File
.
remove
(
entry
.
path
{
ignoreAbsent
:
true
}
)
;
}
}
}
catch
(
e
)
{
logger
.
error
(
"
Failed
to
clean
updated
system
add
-
ons
directories
.
"
e
)
;
}
finally
{
iterator
.
close
(
)
;
}
}
async
installAddonSet
(
aAddons
)
{
await
OS
.
File
.
makeDir
(
this
.
_baseDir
.
path
{
ignoreExisting
:
true
}
)
;
let
addonSet
=
SystemAddonInstallLocation
.
_loadAddonSet
(
)
;
for
(
let
addonID
of
Object
.
keys
(
addonSet
.
addons
)
)
{
if
(
!
aAddons
.
includes
(
addonID
)
)
{
AddonManager
.
getAddonByID
(
addonID
a
=
>
a
.
uninstall
(
)
)
;
}
}
let
newDir
=
this
.
_baseDir
.
clone
(
)
;
let
uuidGen
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
newDir
.
append
(
"
blank
"
)
;
while
(
true
)
{
newDir
.
leafName
=
uuidGen
.
generateUUID
(
)
.
toString
(
)
;
try
{
await
OS
.
File
.
makeDir
(
newDir
.
path
{
ignoreExisting
:
false
}
)
;
break
;
}
catch
(
e
)
{
logger
.
debug
(
"
Could
not
create
new
system
add
-
on
updates
dir
retrying
"
e
)
;
}
}
let
state
=
{
schema
:
1
directory
:
newDir
.
leafName
addons
:
{
}
}
;
SystemAddonInstallLocation
.
_saveAddonSet
(
state
)
;
this
.
_nextDir
=
newDir
;
let
location
=
this
;
let
installs
=
[
]
;
for
(
let
addon
of
aAddons
)
{
let
install
=
await
createLocalInstall
(
addon
.
_sourceBundle
location
)
;
installs
.
push
(
install
)
;
}
async
function
installAddon
(
install
)
{
install
.
ownsTempFile
=
true
;
install
.
install
(
)
;
}
async
function
postponeAddon
(
install
)
{
let
resumeFn
;
if
(
AddonManagerPrivate
.
hasUpgradeListener
(
install
.
addon
.
id
)
)
{
logger
.
info
(
system
add
-
on
{
install
.
addon
.
id
}
has
an
upgrade
listener
postponing
upgrade
set
until
restart
)
;
resumeFn
=
(
)
=
>
{
logger
.
info
(
{
install
.
addon
.
id
}
has
resumed
a
previously
postponed
addon
set
)
;
install
.
installLocation
.
resumeAddonSet
(
installs
)
;
}
;
}
await
install
.
postpone
(
resumeFn
)
;
}
let
previousState
;
try
{
state
=
{
schema
:
1
directory
:
newDir
.
leafName
addons
:
{
}
}
;
for
(
let
addon
of
aAddons
)
{
state
.
addons
[
addon
.
id
]
=
{
version
:
addon
.
version
}
;
}
previousState
=
SystemAddonInstallLocation
.
_loadAddonSet
(
)
;
SystemAddonInstallLocation
.
_saveAddonSet
(
state
)
;
let
blockers
=
aAddons
.
filter
(
addon
=
>
AddonManagerPrivate
.
hasUpgradeListener
(
addon
.
id
)
)
;
if
(
blockers
.
length
>
0
)
{
await
waitForAllPromises
(
installs
.
map
(
postponeAddon
)
)
;
}
else
{
await
waitForAllPromises
(
installs
.
map
(
installAddon
)
)
;
}
}
catch
(
e
)
{
if
(
previousState
)
{
SystemAddonInstallLocation
.
_saveAddonSet
(
previousState
)
;
}
this
.
resetAddonSet
(
)
;
try
{
await
OS
.
File
.
removeDir
(
newDir
.
path
{
ignorePermissions
:
true
}
)
;
}
catch
(
e
)
{
logger
.
warn
(
Failed
to
remove
failed
system
add
-
on
directory
{
newDir
.
path
}
.
e
)
;
}
throw
e
;
}
}
async
resumeAddonSet
(
installs
)
{
async
function
resumeAddon
(
install
)
{
install
.
state
=
AddonManager
.
STATE_DOWNLOADED
;
install
.
installLocation
.
releaseStagingDir
(
)
;
install
.
install
(
)
;
}
let
blockers
=
installs
.
filter
(
install
=
>
AddonManagerPrivate
.
hasUpgradeListener
(
install
.
addon
.
id
)
)
;
if
(
blockers
.
length
>
1
)
{
logger
.
warn
(
"
Attempted
to
resume
system
add
-
on
install
but
upgrade
blockers
are
still
present
"
)
;
}
else
{
await
waitForAllPromises
(
installs
.
map
(
resumeAddon
)
)
;
}
}
getTrashDir
(
)
{
let
trashDir
=
getFile
(
DIR_TRASH
this
.
_directory
)
;
let
trashDirExists
=
trashDir
.
exists
(
)
;
try
{
if
(
trashDirExists
)
recursiveRemove
(
trashDir
)
;
trashDirExists
=
false
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
remove
trash
directory
"
e
)
;
}
if
(
!
trashDirExists
)
trashDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
return
trashDir
;
}
installAddon
(
{
id
source
}
)
{
let
trashDir
=
this
.
getTrashDir
(
)
;
let
transaction
=
new
SafeInstallOperation
(
)
;
try
{
if
(
source
.
isFile
(
)
)
{
flushJarCache
(
source
)
;
}
transaction
.
moveUnder
(
source
this
.
_directory
)
;
}
finally
{
try
{
recursiveRemove
(
trashDir
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
remove
trash
directory
when
installing
"
+
id
e
)
;
}
}
let
newFile
=
getFile
(
source
.
leafName
this
.
_directory
)
;
try
{
newFile
.
lastModifiedTime
=
Date
.
now
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
failed
to
set
lastModifiedTime
on
"
+
newFile
.
path
e
)
;
}
this
.
_IDToFileMap
[
id
]
=
newFile
;
XPIProvider
.
_addURIMapping
(
id
newFile
)
;
return
newFile
;
}
uninstallAddon
(
aAddon
)
{
}
}
const
TemporaryInstallLocation
=
{
locked
:
false
name
:
KEY_APP_TEMPORARY
scope
:
AddonManager
.
SCOPE_TEMPORARY
getAddonLocations
:
(
)
=
>
[
]
isLinkedAddon
:
(
)
=
>
false
installAddon
:
(
)
=
>
{
}
uninstallAddon
:
(
aAddon
)
=
>
{
}
getStagingDir
:
(
)
=
>
{
}
}
;
class
WinRegInstallLocation
extends
DirectoryInstallLocation
{
constructor
(
aName
aRootKey
aScope
)
{
super
(
aName
undefined
aScope
)
;
this
.
locked
=
true
;
this
.
_name
=
aName
;
this
.
_rootKey
=
aRootKey
;
this
.
_scope
=
aScope
;
this
.
_IDToFileMap
=
{
}
;
let
path
=
this
.
_appKeyPath
+
"
\
\
Extensions
"
;
let
key
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
try
{
key
.
open
(
this
.
_rootKey
path
Ci
.
nsIWindowsRegKey
.
ACCESS_READ
)
;
}
catch
(
e
)
{
return
;
}
this
.
_readAddons
(
key
)
;
key
.
close
(
)
;
}
get
_appKeyPath
(
)
{
let
appVendor
=
Services
.
appinfo
.
vendor
;
let
appName
=
Services
.
appinfo
.
name
;
if
(
AppConstants
.
MOZ_APP_NAME
=
=
"
thunderbird
"
&
&
appVendor
=
=
"
"
)
appVendor
=
"
Mozilla
"
;
if
(
appVendor
!
=
"
"
)
appVendor
+
=
"
\
\
"
;
return
"
SOFTWARE
\
\
"
+
appVendor
+
appName
;
}
_readAddons
(
aKey
)
{
let
count
=
aKey
.
valueCount
;
for
(
let
i
=
0
;
i
<
count
;
+
+
i
)
{
let
id
=
aKey
.
getValueName
(
i
)
;
let
file
=
new
nsIFile
(
aKey
.
readStringValue
(
id
)
)
;
if
(
!
file
.
exists
(
)
)
{
logger
.
warn
(
"
Ignoring
missing
add
-
on
in
"
+
file
.
path
)
;
continue
;
}
this
.
_IDToFileMap
[
id
]
=
file
;
XPIProvider
.
_addURIMapping
(
id
file
)
;
}
}
get
name
(
)
{
return
this
.
_name
;
}
isLinkedAddon
(
aId
)
{
return
true
;
}
}
this
.
XPIInternal
=
{
AddonInternal
BOOTSTRAP_REASONS
KEY_APP_SYSTEM_ADDONS
KEY_APP_SYSTEM_DEFAULTS
KEY_APP_TEMPORARY
TEMPORARY_ADDON_SUFFIX
TOOLKIT_ID
XPIStates
getExternalType
isTheme
isUsableAddon
isWebExtension
recordAddonTelemetry
get
XPIDatabase
(
)
{
return
gGlobalScope
.
XPIDatabase
;
}
}
;
var
addonTypes
=
[
new
AddonManagerPrivate
.
AddonType
(
"
extension
"
URI_EXTENSION_STRINGS
"
type
.
extension
.
name
"
AddonManager
.
VIEW_TYPE_LIST
4000
AddonManager
.
TYPE_SUPPORTS_UNDO_RESTARTLESS_UNINSTALL
)
new
AddonManagerPrivate
.
AddonType
(
"
theme
"
URI_EXTENSION_STRINGS
"
type
.
themes
.
name
"
AddonManager
.
VIEW_TYPE_LIST
5000
)
new
AddonManagerPrivate
.
AddonType
(
"
dictionary
"
URI_EXTENSION_STRINGS
"
type
.
dictionary
.
name
"
AddonManager
.
VIEW_TYPE_LIST
7000
AddonManager
.
TYPE_UI_HIDE_EMPTY
|
AddonManager
.
TYPE_SUPPORTS_UNDO_RESTARTLESS_UNINSTALL
)
new
AddonManagerPrivate
.
AddonType
(
"
locale
"
URI_EXTENSION_STRINGS
"
type
.
locale
.
name
"
AddonManager
.
VIEW_TYPE_LIST
8000
AddonManager
.
TYPE_UI_HIDE_EMPTY
|
AddonManager
.
TYPE_SUPPORTS_UNDO_RESTARTLESS_UNINSTALL
)
]
;
if
(
Services
.
prefs
.
getBoolPref
(
"
experiments
.
supported
"
false
)
)
{
addonTypes
.
push
(
new
AddonManagerPrivate
.
AddonType
(
"
experiment
"
URI_EXTENSION_STRINGS
"
type
.
experiment
.
name
"
AddonManager
.
VIEW_TYPE_LIST
11000
AddonManager
.
TYPE_UI_HIDE_EMPTY
|
AddonManager
.
TYPE_SUPPORTS_UNDO_RESTARTLESS_UNINSTALL
)
)
;
}
AddonManagerPrivate
.
registerProvider
(
XPIProvider
addonTypes
)
;
