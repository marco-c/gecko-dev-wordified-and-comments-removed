"
use
strict
"
;
if
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
in
Cc
)
{
let
runtime
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
if
(
runtime
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
You
cannot
use
the
AddonManager
in
child
processes
!
"
)
;
}
}
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
MOZ_COMPATIBILITY_NIGHTLY
=
!
[
"
aurora
"
"
beta
"
"
release
"
"
esr
"
]
.
includes
(
AppConstants
.
MOZ_UPDATE_CHANNEL
)
;
const
INTL_LOCALES_CHANGED
=
"
intl
:
app
-
locales
-
changed
"
;
const
PREF_AMO_ABUSEREPORT
=
"
extensions
.
abuseReport
.
amWebAPI
.
enabled
"
;
const
PREF_BLOCKLIST_PINGCOUNTVERSION
=
"
extensions
.
blocklist
.
pingCountVersion
"
;
const
PREF_EM_UPDATE_ENABLED
=
"
extensions
.
update
.
enabled
"
;
const
PREF_EM_LAST_APP_VERSION
=
"
extensions
.
lastAppVersion
"
;
const
PREF_EM_LAST_PLATFORM_VERSION
=
"
extensions
.
lastPlatformVersion
"
;
const
PREF_EM_AUTOUPDATE_DEFAULT
=
"
extensions
.
update
.
autoUpdateDefault
"
;
const
PREF_EM_STRICT_COMPATIBILITY
=
"
extensions
.
strictCompatibility
"
;
const
PREF_EM_CHECK_UPDATE_SECURITY
=
"
extensions
.
checkUpdateSecurity
"
;
const
PREF_SYS_ADDON_UPDATE_ENABLED
=
"
extensions
.
systemAddon
.
update
.
enabled
"
;
const
PREF_REMOTESETTINGS_DISABLED
=
"
extensions
.
remoteSettings
.
disabled
"
;
const
PREF_MIN_WEBEXT_PLATFORM_VERSION
=
"
extensions
.
webExtensionsMinPlatformVersion
"
;
const
PREF_WEBAPI_TESTING
=
"
extensions
.
webapi
.
testing
"
;
const
PREF_EM_POSTDOWNLOAD_THIRD_PARTY
=
"
extensions
.
postDownloadThirdPartyPrompt
"
;
const
UPDATE_REQUEST_VERSION
=
2
;
const
BRANCH_REGEXP
=
/
^
(
[
^
\
.
]
+
\
.
[
0
-
9
]
+
[
a
-
z
]
*
)
.
*
/
gi
;
const
PREF_EM_CHECK_COMPATIBILITY_BASE
=
"
extensions
.
checkCompatibility
"
;
var
PREF_EM_CHECK_COMPATIBILITY
=
MOZ_COMPATIBILITY_NIGHTLY
?
PREF_EM_CHECK_COMPATIBILITY_BASE
+
"
.
nightly
"
:
undefined
;
const
WEBAPI_INSTALL_HOSTS
=
[
"
addons
.
mozilla
.
org
"
]
;
const
WEBAPI_TEST_INSTALL_HOSTS
=
[
"
addons
.
allizom
.
org
"
"
addons
-
dev
.
allizom
.
org
"
"
example
.
com
"
]
;
const
AMO_ATTRIBUTION_ALLOWED_SOURCES
=
[
"
amo
"
"
disco
"
]
;
const
AMO_ATTRIBUTION_DATA_KEYS
=
[
"
utm_campaign
"
"
utm_content
"
"
utm_medium
"
"
utm_source
"
]
;
const
AMO_ATTRIBUTION_DATA_MAX_LENGTH
=
40
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
var
{
AsyncShutdown
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
AddonRepository
:
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonRepository
.
jsm
"
AbuseReporter
:
"
resource
:
/
/
gre
/
modules
/
AbuseReporter
.
jsm
"
Extension
:
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
TelemetryTimestamps
:
"
resource
:
/
/
gre
/
modules
/
TelemetryTimestamps
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
WEBEXT_POSTDOWNLOAD_THIRD_PARTY
"
PREF_EM_POSTDOWNLOAD_THIRD_PARTY
false
)
;
Services
.
ppmm
.
loadProcessScript
(
"
resource
:
/
/
gre
/
modules
/
extensionProcessScriptLoader
.
js
"
true
)
;
const
INTEGER
=
/
^
[
1
-
9
]
\
d
*
/
;
var
EXPORTED_SYMBOLS
=
[
"
AddonManager
"
"
AddonManagerPrivate
"
"
AMTelemetry
"
"
AMRemoteSettings
"
]
;
const
CATEGORY_PROVIDER_MODULE
=
"
addon
-
provider
-
module
"
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
PARENT_LOGGER_ID
=
"
addons
"
;
var
parentLogger
=
Log
.
repository
.
getLogger
(
PARENT_LOGGER_ID
)
;
parentLogger
.
level
=
Log
.
Level
.
Warn
;
var
formatter
=
new
Log
.
BasicFormatter
(
)
;
parentLogger
.
addAppender
(
new
Log
.
ConsoleAppender
(
formatter
)
)
;
const
LOGGER_ID
=
"
addons
.
manager
"
;
var
logger
=
Log
.
repository
.
getLogger
(
LOGGER_ID
)
;
const
PREF_LOGGING_ENABLED
=
"
extensions
.
logging
.
enabled
"
;
const
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
=
"
nsPref
:
changed
"
;
const
UNNAMED_PROVIDER
=
"
<
unnamed
-
provider
>
"
;
function
providerName
(
aProvider
)
{
return
aProvider
.
name
|
|
UNNAMED_PROVIDER
;
}
var
gXPIProvider
;
var
PrefObserver
=
{
init
(
)
{
Services
.
prefs
.
addObserver
(
PREF_LOGGING_ENABLED
this
)
;
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
)
;
this
.
observe
(
null
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
PREF_LOGGING_ENABLED
)
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
xpcom
-
shutdown
"
)
{
Services
.
prefs
.
removeObserver
(
PREF_LOGGING_ENABLED
this
)
;
Services
.
obs
.
removeObserver
(
this
"
xpcom
-
shutdown
"
)
;
}
else
if
(
aTopic
=
=
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
{
let
debugLogEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_LOGGING_ENABLED
false
)
;
if
(
debugLogEnabled
)
{
parentLogger
.
level
=
Log
.
Level
.
Debug
;
}
else
{
parentLogger
.
level
=
Log
.
Level
.
Warn
;
}
}
}
}
;
PrefObserver
.
init
(
)
;
function
safeCall
(
aCallback
.
.
.
aArgs
)
{
try
{
aCallback
.
apply
(
null
aArgs
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Exception
calling
callback
"
e
)
;
}
}
function
reportProviderError
(
aProvider
aMethod
aError
)
{
let
method
=
provider
{
providerName
(
aProvider
)
}
.
{
aMethod
}
;
AddonManagerPrivate
.
recordException
(
"
AMI
"
method
aError
)
;
logger
.
error
(
"
Exception
calling
"
+
method
aError
)
;
}
function
callProvider
(
aProvider
aMethod
aDefault
.
.
.
aArgs
)
{
if
(
!
(
aMethod
in
aProvider
)
)
{
return
aDefault
;
}
try
{
return
aProvider
[
aMethod
]
.
apply
(
aProvider
aArgs
)
;
}
catch
(
e
)
{
reportProviderError
(
aProvider
aMethod
e
)
;
return
aDefault
;
}
}
async
function
promiseCallProvider
(
aProvider
aMethod
.
.
.
aArgs
)
{
if
(
!
(
aMethod
in
aProvider
)
)
{
return
undefined
;
}
try
{
return
aProvider
[
aMethod
]
.
apply
(
aProvider
aArgs
)
;
}
catch
(
e
)
{
reportProviderError
(
aProvider
aMethod
e
)
;
return
undefined
;
}
}
function
getLocale
(
)
{
return
Services
.
locale
.
requestedLocale
|
|
"
en
-
US
"
;
}
const
WEB_EXPOSED_ADDON_PROPERTIES
=
[
"
id
"
"
version
"
"
type
"
"
name
"
"
description
"
"
isActive
"
]
;
function
webAPIForAddon
(
addon
)
{
if
(
!
addon
)
{
return
null
;
}
let
result
=
{
}
;
for
(
let
prop
of
WEB_EXPOSED_ADDON_PROPERTIES
)
{
result
[
prop
]
=
addon
[
prop
]
;
}
result
.
isEnabled
=
!
addon
.
userDisabled
;
result
.
canUninstall
=
Boolean
(
addon
.
permissions
&
AddonManager
.
PERM_CAN_UNINSTALL
)
;
return
result
;
}
function
BrowserListener
(
aBrowser
aInstallingPrincipal
aInstall
)
{
this
.
browser
=
aBrowser
;
this
.
messageManager
=
this
.
browser
.
messageManager
;
this
.
principal
=
aInstallingPrincipal
;
this
.
install
=
aInstall
;
aBrowser
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
close
"
true
)
;
aInstall
.
addListener
(
this
)
;
this
.
registered
=
true
;
}
BrowserListener
.
prototype
=
{
browser
:
null
install
:
null
registered
:
false
unregister
(
)
{
if
(
!
this
.
registered
)
{
return
;
}
this
.
registered
=
false
;
Services
.
obs
.
removeObserver
(
this
"
message
-
manager
-
close
"
)
;
if
(
this
.
browser
.
removeProgressListener
)
{
this
.
browser
.
removeProgressListener
(
this
)
;
}
this
.
install
.
removeListener
(
this
)
;
this
.
install
=
null
;
}
cancelInstall
(
)
{
try
{
this
.
install
.
cancel
(
)
;
}
catch
(
e
)
{
}
}
observe
(
subject
topic
data
)
{
if
(
subject
!
=
this
.
messageManager
)
{
return
;
}
this
.
cancelInstall
(
)
;
}
onLocationChange
(
webProgress
request
location
)
{
if
(
this
.
browser
.
contentPrincipal
&
&
this
.
principal
.
subsumes
(
this
.
browser
.
contentPrincipal
)
)
{
return
;
}
this
.
cancelInstall
(
)
;
}
onDownloadCancelled
(
install
)
{
this
.
unregister
(
)
;
}
onDownloadFailed
(
install
)
{
this
.
unregister
(
)
;
}
onInstallFailed
(
install
)
{
this
.
unregister
(
)
;
}
onInstallEnded
(
install
)
{
this
.
unregister
(
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsISupportsWeakReference
"
"
nsIWebProgressListener
"
"
nsIObserver
"
]
)
}
;
function
AddonAuthor
(
aName
aURL
)
{
this
.
name
=
aName
;
this
.
url
=
aURL
;
}
AddonAuthor
.
prototype
=
{
name
:
null
url
:
null
toString
(
)
{
return
this
.
name
|
|
"
"
;
}
}
;
function
AddonScreenshot
(
aURL
aWidth
aHeight
aThumbnailURL
aThumbnailWidth
aThumbnailHeight
aCaption
)
{
this
.
url
=
aURL
;
if
(
aWidth
)
{
this
.
width
=
aWidth
;
}
if
(
aHeight
)
{
this
.
height
=
aHeight
;
}
if
(
aThumbnailURL
)
{
this
.
thumbnailURL
=
aThumbnailURL
;
}
if
(
aThumbnailWidth
)
{
this
.
thumbnailWidth
=
aThumbnailWidth
;
}
if
(
aThumbnailHeight
)
{
this
.
thumbnailHeight
=
aThumbnailHeight
;
}
if
(
aCaption
)
{
this
.
caption
=
aCaption
;
}
}
AddonScreenshot
.
prototype
=
{
url
:
null
width
:
null
height
:
null
thumbnailURL
:
null
thumbnailWidth
:
null
thumbnailHeight
:
null
caption
:
null
toString
(
)
{
return
this
.
url
|
|
"
"
;
}
}
;
var
gStarted
=
false
;
var
gStartedPromise
=
PromiseUtils
.
defer
(
)
;
var
gStartupComplete
=
false
;
var
gCheckCompatibility
=
true
;
var
gStrictCompatibility
=
true
;
var
gCheckUpdateSecurityDefault
=
true
;
var
gCheckUpdateSecurity
=
gCheckUpdateSecurityDefault
;
var
gUpdateEnabled
=
true
;
var
gAutoUpdateDefault
=
true
;
var
gWebExtensionsMinPlatformVersion
=
"
"
;
var
gFinalShutdownBarrier
=
null
;
var
gBeforeShutdownBarrier
=
null
;
var
gRepoShutdownState
=
"
"
;
var
gShutdownInProgress
=
false
;
var
gBrowserUpdated
=
null
;
var
AMTelemetry
;
var
AMRemoteSettings
;
var
AddonManagerInternal
=
{
managerListeners
:
new
Set
(
)
installListeners
:
new
Set
(
)
addonListeners
:
new
Set
(
)
pendingProviders
:
new
Set
(
)
providers
:
new
Set
(
)
providerShutdowns
:
new
Map
(
)
typesByProvider
:
new
Map
(
)
startupChanges
:
{
}
telemetryDetails
:
{
}
upgradeListeners
:
new
Map
(
)
externalExtensionLoaders
:
new
Map
(
)
recordTimestamp
(
name
value
)
{
lazy
.
TelemetryTimestamps
.
add
(
name
value
)
;
}
_startProvider
(
aProvider
aAppChanged
aOldAppVersion
aOldPlatformVersion
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
logger
.
debug
(
Starting
provider
:
{
providerName
(
aProvider
)
}
)
;
callProvider
(
aProvider
"
startup
"
null
aAppChanged
aOldAppVersion
aOldPlatformVersion
)
;
if
(
"
shutdown
"
in
aProvider
)
{
let
name
=
providerName
(
aProvider
)
;
let
AMProviderShutdown
=
(
)
=
>
{
if
(
this
.
providers
.
has
(
aProvider
)
)
{
this
.
providers
.
delete
(
aProvider
)
;
this
.
pendingProviders
.
add
(
aProvider
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
logger
.
debug
(
"
Calling
shutdown
blocker
for
"
+
name
)
;
resolve
(
aProvider
.
shutdown
(
)
)
;
}
)
.
catch
(
err
=
>
{
logger
.
warn
(
"
Failure
during
shutdown
of
"
+
name
err
)
;
AddonManagerPrivate
.
recordException
(
"
AMI
"
"
Async
shutdown
of
"
+
name
err
)
;
}
)
;
}
;
logger
.
debug
(
"
Registering
shutdown
blocker
for
"
+
name
)
;
this
.
providerShutdowns
.
set
(
aProvider
AMProviderShutdown
)
;
AddonManagerPrivate
.
finalShutdown
.
addBlocker
(
name
AMProviderShutdown
)
;
}
this
.
pendingProviders
.
delete
(
aProvider
)
;
this
.
providers
.
add
(
aProvider
)
;
logger
.
debug
(
Provider
finished
startup
:
{
providerName
(
aProvider
)
}
)
;
}
_getProviderByName
(
aName
)
{
for
(
let
provider
of
this
.
providers
)
{
if
(
providerName
(
provider
)
=
=
aName
)
{
return
provider
;
}
}
return
undefined
;
}
startup
(
)
{
try
{
if
(
gStarted
)
{
return
;
}
this
.
recordTimestamp
(
"
AMI_startup_begin
"
)
;
AMTelemetry
.
init
(
)
;
AMRemoteSettings
.
init
(
)
;
for
(
let
provider
in
this
.
telemetryDetails
)
{
delete
this
.
telemetryDetails
[
provider
]
;
}
let
appChanged
=
undefined
;
let
oldAppVersion
=
null
;
try
{
oldAppVersion
=
Services
.
prefs
.
getCharPref
(
PREF_EM_LAST_APP_VERSION
)
;
appChanged
=
Services
.
appinfo
.
version
!
=
oldAppVersion
;
}
catch
(
e
)
{
}
gBrowserUpdated
=
appChanged
;
let
oldPlatformVersion
=
Services
.
prefs
.
getCharPref
(
PREF_EM_LAST_PLATFORM_VERSION
"
"
)
;
if
(
appChanged
!
=
=
false
)
{
logger
.
debug
(
"
Application
has
been
upgraded
"
)
;
Services
.
prefs
.
setCharPref
(
PREF_EM_LAST_APP_VERSION
Services
.
appinfo
.
version
)
;
Services
.
prefs
.
setCharPref
(
PREF_EM_LAST_PLATFORM_VERSION
Services
.
appinfo
.
platformVersion
)
;
Services
.
prefs
.
setIntPref
(
PREF_BLOCKLIST_PINGCOUNTVERSION
appChanged
=
=
=
undefined
?
0
:
-
1
)
;
}
if
(
!
MOZ_COMPATIBILITY_NIGHTLY
)
{
PREF_EM_CHECK_COMPATIBILITY
=
PREF_EM_CHECK_COMPATIBILITY_BASE
+
"
.
"
+
Services
.
appinfo
.
version
.
replace
(
BRANCH_REGEXP
"
1
"
)
;
}
gCheckCompatibility
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_CHECK_COMPATIBILITY
gCheckCompatibility
)
;
Services
.
prefs
.
addObserver
(
PREF_EM_CHECK_COMPATIBILITY
this
)
;
gStrictCompatibility
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_STRICT_COMPATIBILITY
gStrictCompatibility
)
;
Services
.
prefs
.
addObserver
(
PREF_EM_STRICT_COMPATIBILITY
this
)
;
let
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
gCheckUpdateSecurityDefault
=
defaultBranch
.
getBoolPref
(
PREF_EM_CHECK_UPDATE_SECURITY
gCheckUpdateSecurityDefault
)
;
gCheckUpdateSecurity
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_CHECK_UPDATE_SECURITY
gCheckUpdateSecurity
)
;
Services
.
prefs
.
addObserver
(
PREF_EM_CHECK_UPDATE_SECURITY
this
)
;
gUpdateEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_UPDATE_ENABLED
gUpdateEnabled
)
;
Services
.
prefs
.
addObserver
(
PREF_EM_UPDATE_ENABLED
this
)
;
gAutoUpdateDefault
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_AUTOUPDATE_DEFAULT
gAutoUpdateDefault
)
;
Services
.
prefs
.
addObserver
(
PREF_EM_AUTOUPDATE_DEFAULT
this
)
;
gWebExtensionsMinPlatformVersion
=
Services
.
prefs
.
getCharPref
(
PREF_MIN_WEBEXT_PLATFORM_VERSION
gWebExtensionsMinPlatformVersion
)
;
Services
.
prefs
.
addObserver
(
PREF_MIN_WEBEXT_PLATFORM_VERSION
this
)
;
Services
.
prefs
.
addObserver
(
PREF_REMOTESETTINGS_DISABLED
this
)
;
Services
.
obs
.
addObserver
(
this
INTL_LOCALES_CHANGED
)
;
(
{
XPIProvider
:
gXPIProvider
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIProvider
.
jsm
"
)
)
;
for
(
let
{
entry
value
:
url
}
of
Services
.
catMan
.
enumerateCategory
(
CATEGORY_PROVIDER_MODULE
)
)
{
try
{
ChromeUtils
.
importESModule
(
url
)
;
logger
.
debug
(
Loaded
provider
scope
for
{
url
}
)
;
}
catch
(
e
)
{
AddonManagerPrivate
.
recordException
(
"
AMI
"
"
provider
"
+
url
+
"
load
failed
"
e
)
;
logger
.
error
(
"
Exception
loading
provider
"
+
entry
+
'
from
category
"
'
+
url
+
'
"
'
e
)
;
}
}
gBeforeShutdownBarrier
=
new
AsyncShutdown
.
Barrier
(
"
AddonManager
:
Waiting
to
start
provider
shutdown
.
"
)
;
gFinalShutdownBarrier
=
new
AsyncShutdown
.
Barrier
(
"
AddonManager
:
Waiting
for
providers
to
shut
down
.
"
)
;
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
AddonManager
:
shutting
down
.
"
this
.
shutdownManager
.
bind
(
this
)
{
fetchState
:
this
.
shutdownState
.
bind
(
this
)
}
)
;
gStarted
=
true
;
for
(
let
provider
of
this
.
pendingProviders
)
{
this
.
_startProvider
(
provider
appChanged
oldAppVersion
oldPlatformVersion
)
;
}
if
(
appChanged
=
=
=
undefined
)
{
for
(
let
type
in
this
.
startupChanges
)
{
delete
this
.
startupChanges
[
type
]
;
}
}
gStartupComplete
=
true
;
gStartedPromise
.
resolve
(
)
;
this
.
recordTimestamp
(
"
AMI_startup_end
"
)
;
}
catch
(
e
)
{
logger
.
error
(
"
startup
failed
"
e
)
;
AddonManagerPrivate
.
recordException
(
"
AMI
"
"
startup
failed
"
e
)
;
gStartedPromise
.
reject
(
"
startup
failed
"
)
;
}
logger
.
debug
(
"
Completed
startup
sequence
"
)
;
this
.
callManagerListeners
(
"
onStartup
"
)
;
}
registerProvider
(
aProvider
aTypes
)
{
if
(
!
aProvider
|
|
typeof
aProvider
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
aProvider
must
be
specified
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
aTypes
&
&
!
Array
.
isArray
(
aTypes
)
)
{
throw
Components
.
Exception
(
"
aTypes
must
be
an
array
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
pendingProviders
.
add
(
aProvider
)
;
if
(
aTypes
)
{
this
.
typesByProvider
.
set
(
aProvider
new
Set
(
aTypes
)
)
;
}
if
(
gStarted
)
{
this
.
_startProvider
(
aProvider
)
;
}
}
unregisterProvider
(
aProvider
)
{
if
(
!
aProvider
|
|
typeof
aProvider
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
aProvider
must
be
specified
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
providers
.
delete
(
aProvider
)
;
this
.
pendingProviders
.
delete
(
aProvider
)
;
this
.
typesByProvider
.
delete
(
aProvider
)
;
if
(
gStarted
&
&
!
gShutdownInProgress
)
{
logger
.
debug
(
"
Unregistering
shutdown
blocker
for
"
+
providerName
(
aProvider
)
)
;
let
shutter
=
this
.
providerShutdowns
.
get
(
aProvider
)
;
if
(
shutter
)
{
this
.
providerShutdowns
.
delete
(
aProvider
)
;
gFinalShutdownBarrier
.
client
.
removeBlocker
(
shutter
)
;
return
shutter
(
)
;
}
}
return
undefined
;
}
markProviderSafe
(
aProvider
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
aProvider
|
|
typeof
aProvider
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
aProvider
must
be
specified
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
this
.
pendingProviders
.
has
(
aProvider
)
)
{
return
;
}
this
.
pendingProviders
.
delete
(
aProvider
)
;
this
.
providers
.
add
(
aProvider
)
;
}
callProviders
(
aMethod
.
.
.
aArgs
)
{
if
(
!
aMethod
|
|
typeof
aMethod
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aMethod
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
providers
=
[
.
.
.
this
.
providers
]
;
for
(
let
provider
of
providers
)
{
try
{
if
(
aMethod
in
provider
)
{
provider
[
aMethod
]
.
apply
(
provider
aArgs
)
;
}
}
catch
(
e
)
{
reportProviderError
(
provider
aMethod
e
)
;
}
}
}
shutdownState
(
)
{
let
state
=
[
]
;
for
(
let
barrier
of
[
gBeforeShutdownBarrier
gFinalShutdownBarrier
]
)
{
if
(
barrier
)
{
state
.
push
(
{
name
:
barrier
.
client
.
name
state
:
barrier
.
state
}
)
;
}
}
state
.
push
(
{
name
:
"
AddonRepository
:
async
shutdown
"
state
:
gRepoShutdownState
}
)
;
return
state
;
}
async
shutdownManager
(
)
{
logger
.
debug
(
"
before
shutdown
"
)
;
try
{
await
gBeforeShutdownBarrier
.
wait
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
logger
.
debug
(
"
shutdown
"
)
;
this
.
callManagerListeners
(
"
onShutdown
"
)
;
if
(
!
gStartupComplete
)
{
gStartedPromise
.
reject
(
"
shutting
down
"
)
;
}
gRepoShutdownState
=
"
pending
"
;
gShutdownInProgress
=
true
;
Services
.
prefs
.
removeObserver
(
PREF_EM_CHECK_COMPATIBILITY
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_EM_STRICT_COMPATIBILITY
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_EM_CHECK_UPDATE_SECURITY
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_EM_UPDATE_ENABLED
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_EM_AUTOUPDATE_DEFAULT
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_REMOTESETTINGS_DISABLED
this
)
;
Services
.
obs
.
removeObserver
(
this
INTL_LOCALES_CHANGED
)
;
AMRemoteSettings
.
shutdown
(
)
;
let
savedError
=
null
;
if
(
gStarted
)
{
try
{
await
gFinalShutdownBarrier
.
wait
(
)
;
}
catch
(
err
)
{
savedError
=
err
;
logger
.
error
(
"
Failure
during
wait
for
shutdown
barrier
"
err
)
;
AddonManagerPrivate
.
recordException
(
"
AMI
"
"
Async
shutdown
of
AddonManager
providers
"
err
)
;
}
}
gXPIProvider
=
null
;
try
{
gRepoShutdownState
=
"
in
progress
"
;
await
lazy
.
AddonRepository
.
shutdown
(
)
;
gRepoShutdownState
=
"
done
"
;
}
catch
(
err
)
{
savedError
=
err
;
logger
.
error
(
"
Failure
during
AddonRepository
shutdown
"
err
)
;
AddonManagerPrivate
.
recordException
(
"
AMI
"
"
Async
shutdown
of
AddonRepository
"
err
)
;
}
logger
.
debug
(
"
Async
provider
shutdown
done
"
)
;
this
.
managerListeners
.
clear
(
)
;
this
.
installListeners
.
clear
(
)
;
this
.
addonListeners
.
clear
(
)
;
this
.
providerShutdowns
.
clear
(
)
;
for
(
let
type
in
this
.
startupChanges
)
{
delete
this
.
startupChanges
[
type
]
;
}
gStarted
=
false
;
gStartedPromise
=
PromiseUtils
.
defer
(
)
;
gStartupComplete
=
false
;
gFinalShutdownBarrier
=
null
;
gBeforeShutdownBarrier
=
null
;
gShutdownInProgress
=
false
;
if
(
savedError
)
{
throw
savedError
;
}
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
INTL_LOCALES_CHANGED
:
{
lazy
.
AddonRepository
.
backgroundUpdateCheck
(
)
;
return
;
}
}
switch
(
aData
)
{
case
PREF_EM_CHECK_COMPATIBILITY
:
{
let
oldValue
=
gCheckCompatibility
;
gCheckCompatibility
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_CHECK_COMPATIBILITY
true
)
;
this
.
callManagerListeners
(
"
onCompatibilityModeChanged
"
)
;
if
(
gCheckCompatibility
!
=
oldValue
)
{
this
.
updateAddonAppDisabledStates
(
)
;
}
break
;
}
case
PREF_EM_STRICT_COMPATIBILITY
:
{
let
oldValue
=
gStrictCompatibility
;
gStrictCompatibility
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_STRICT_COMPATIBILITY
true
)
;
this
.
callManagerListeners
(
"
onCompatibilityModeChanged
"
)
;
if
(
gStrictCompatibility
!
=
oldValue
)
{
this
.
updateAddonAppDisabledStates
(
)
;
}
break
;
}
case
PREF_EM_CHECK_UPDATE_SECURITY
:
{
let
oldValue
=
gCheckUpdateSecurity
;
gCheckUpdateSecurity
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_CHECK_UPDATE_SECURITY
true
)
;
this
.
callManagerListeners
(
"
onCheckUpdateSecurityChanged
"
)
;
if
(
gCheckUpdateSecurity
!
=
oldValue
)
{
this
.
updateAddonAppDisabledStates
(
)
;
}
break
;
}
case
PREF_EM_UPDATE_ENABLED
:
{
gUpdateEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_UPDATE_ENABLED
true
)
;
this
.
callManagerListeners
(
"
onUpdateModeChanged
"
)
;
break
;
}
case
PREF_EM_AUTOUPDATE_DEFAULT
:
{
gAutoUpdateDefault
=
Services
.
prefs
.
getBoolPref
(
PREF_EM_AUTOUPDATE_DEFAULT
true
)
;
this
.
callManagerListeners
(
"
onUpdateModeChanged
"
)
;
break
;
}
case
PREF_MIN_WEBEXT_PLATFORM_VERSION
:
{
gWebExtensionsMinPlatformVersion
=
Services
.
prefs
.
getCharPref
(
PREF_MIN_WEBEXT_PLATFORM_VERSION
)
;
break
;
}
case
PREF_REMOTESETTINGS_DISABLED
:
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_REMOTESETTINGS_DISABLED
false
)
)
{
AMRemoteSettings
.
shutdown
(
)
;
}
else
{
AMRemoteSettings
.
init
(
)
;
}
break
;
}
}
}
escapeAddonURI
(
aAddon
aUri
aAppVersion
)
{
if
(
!
aAddon
|
|
typeof
aAddon
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
aAddon
must
be
an
Addon
object
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aUri
|
|
typeof
aUri
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aUri
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
aAppVersion
&
&
typeof
aAppVersion
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aAppVersion
must
be
a
string
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
var
addonStatus
=
aAddon
.
userDisabled
|
|
aAddon
.
softDisabled
?
"
userDisabled
"
:
"
userEnabled
"
;
if
(
!
aAddon
.
isCompatible
)
{
addonStatus
+
=
"
incompatible
"
;
}
let
{
blocklistState
}
=
aAddon
;
if
(
blocklistState
=
=
Ci
.
nsIBlocklistService
.
STATE_BLOCKED
)
{
addonStatus
+
=
"
blocklisted
"
;
}
if
(
blocklistState
=
=
Ci
.
nsIBlocklistService
.
STATE_SOFTBLOCKED
)
{
addonStatus
+
=
"
softblocked
"
;
}
let
params
=
new
Map
(
Object
.
entries
(
{
ITEM_ID
:
aAddon
.
id
ITEM_VERSION
:
aAddon
.
version
ITEM_STATUS
:
addonStatus
APP_ID
:
Services
.
appinfo
.
ID
APP_VERSION
:
aAppVersion
?
aAppVersion
:
Services
.
appinfo
.
version
REQ_VERSION
:
UPDATE_REQUEST_VERSION
APP_OS
:
Services
.
appinfo
.
OS
APP_ABI
:
Services
.
appinfo
.
XPCOMABI
APP_LOCALE
:
getLocale
(
)
CURRENT_APP_VERSION
:
Services
.
appinfo
.
version
}
)
)
;
let
uri
=
aUri
.
replace
(
/
%
(
[
A
-
Z_
]
+
)
%
/
g
(
m0
m1
)
=
>
params
.
get
(
m1
)
|
|
m0
)
;
return
uri
.
replace
(
/
\
+
/
g
"
%
2B
"
)
;
}
_updatePromptHandler
(
info
)
{
let
oldPerms
=
info
.
existingAddon
.
userPermissions
;
if
(
!
oldPerms
)
{
return
Promise
.
resolve
(
)
;
}
let
newPerms
=
info
.
addon
.
userPermissions
;
let
difference
=
lazy
.
Extension
.
comparePermissions
(
oldPerms
newPerms
)
;
if
(
!
difference
.
origins
.
length
&
&
!
difference
.
permissions
.
length
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
subject
=
{
wrappedJSObject
:
{
addon
:
info
.
addon
permissions
:
difference
resolve
reject
install
:
info
.
install
}
}
;
Services
.
obs
.
notifyObservers
(
subject
"
webextension
-
update
-
permissions
"
)
;
}
)
;
}
systemUpdateEnabled
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
PREF_SYS_ADDON_UPDATE_ENABLED
)
)
{
return
false
;
}
if
(
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
SysAddonUpdate
"
)
)
{
return
false
;
}
return
true
;
}
backgroundUpdateCheck
(
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
let
buPromise
=
(
async
(
)
=
>
{
logger
.
debug
(
"
Background
update
check
beginning
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
addons
-
background
-
update
-
start
"
)
;
if
(
this
.
updateEnabled
)
{
let
updates
=
[
]
;
let
allAddons
=
await
this
.
getAllAddons
(
)
;
await
lazy
.
AddonRepository
.
backgroundUpdateCheck
(
)
;
for
(
let
addon
of
allAddons
)
{
if
(
!
(
addon
.
permissions
&
AddonManager
.
PERM_CAN_UPGRADE
)
)
{
continue
;
}
updates
.
push
(
new
Promise
(
(
resolve
reject
)
=
>
{
addon
.
findUpdates
(
{
onUpdateAvailable
(
aAddon
aInstall
)
{
logger
.
debug
(
"
Found
update
for
add
-
on
{
id
}
"
aAddon
)
;
if
(
AddonManager
.
shouldAutoUpdate
(
aAddon
)
)
{
logger
.
debug
(
Starting
upgrade
install
of
{
aAddon
.
id
}
)
;
aInstall
.
promptHandler
=
(
.
.
.
args
)
=
>
AddonManagerInternal
.
_updatePromptHandler
(
.
.
.
args
)
;
aInstall
.
install
(
)
;
}
}
onUpdateFinished
:
aAddon
=
>
{
logger
.
debug
(
"
onUpdateFinished
for
{
id
}
"
aAddon
)
;
resolve
(
)
;
}
}
AddonManager
.
UPDATE_WHEN_PERIODIC_UPDATE
)
;
}
)
)
;
}
await
Promise
.
all
(
updates
)
;
}
if
(
AddonManagerInternal
.
systemUpdateEnabled
(
)
)
{
try
{
await
AddonManagerInternal
.
_getProviderByName
(
"
XPIProvider
"
)
.
updateSystemAddons
(
)
;
}
catch
(
e
)
{
logger
.
warn
(
"
Failed
to
update
system
addons
"
e
)
;
}
}
logger
.
debug
(
"
Background
update
check
complete
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
addons
-
background
-
update
-
complete
"
)
;
}
)
(
)
;
buPromise
.
catch
(
e
=
>
logger
.
warn
(
"
Error
in
background
update
"
e
)
)
;
return
buPromise
;
}
addStartupChange
(
aType
aID
)
{
if
(
!
aType
|
|
typeof
aType
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aType
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aID
|
|
typeof
aID
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aID
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
gStartupComplete
)
{
return
;
}
logger
.
debug
(
"
Registering
startup
change
'
"
+
aType
+
"
'
for
"
+
aID
)
;
for
(
let
type
in
this
.
startupChanges
)
{
this
.
removeStartupChange
(
type
aID
)
;
}
if
(
!
(
aType
in
this
.
startupChanges
)
)
{
this
.
startupChanges
[
aType
]
=
[
]
;
}
this
.
startupChanges
[
aType
]
.
push
(
aID
)
;
}
removeStartupChange
(
aType
aID
)
{
if
(
!
aType
|
|
typeof
aType
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aType
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aID
|
|
typeof
aID
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aID
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
gStartupComplete
)
{
return
;
}
if
(
!
(
aType
in
this
.
startupChanges
)
)
{
return
;
}
this
.
startupChanges
[
aType
]
=
this
.
startupChanges
[
aType
]
.
filter
(
aItem
=
>
aItem
!
=
aID
)
;
}
callManagerListeners
(
aMethod
.
.
.
aArgs
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
aMethod
|
|
typeof
aMethod
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aMethod
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
managerListeners
=
new
Set
(
this
.
managerListeners
)
;
for
(
let
listener
of
managerListeners
)
{
try
{
if
(
aMethod
in
listener
)
{
listener
[
aMethod
]
.
apply
(
listener
aArgs
)
;
}
}
catch
(
e
)
{
logger
.
warn
(
"
AddonManagerListener
threw
exception
when
calling
"
+
aMethod
e
)
;
}
}
}
callInstallListeners
(
aMethod
aExtraListeners
.
.
.
aArgs
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
aMethod
|
|
typeof
aMethod
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aMethod
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
aExtraListeners
&
&
!
Array
.
isArray
(
aExtraListeners
)
)
{
throw
Components
.
Exception
(
"
aExtraListeners
must
be
an
array
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
result
=
true
;
let
listeners
;
if
(
aExtraListeners
)
{
listeners
=
new
Set
(
aExtraListeners
.
concat
(
Array
.
from
(
this
.
installListeners
)
)
)
;
}
else
{
listeners
=
new
Set
(
this
.
installListeners
)
;
}
for
(
let
listener
of
listeners
)
{
try
{
if
(
aMethod
in
listener
)
{
if
(
listener
[
aMethod
]
.
apply
(
listener
aArgs
)
=
=
=
false
)
{
result
=
false
;
}
}
}
catch
(
e
)
{
logger
.
warn
(
"
InstallListener
threw
exception
when
calling
"
+
aMethod
e
)
;
}
}
return
result
;
}
callAddonListeners
(
aMethod
.
.
.
aArgs
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
aMethod
|
|
typeof
aMethod
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aMethod
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
addonListeners
=
new
Set
(
this
.
addonListeners
)
;
for
(
let
listener
of
addonListeners
)
{
try
{
if
(
aMethod
in
listener
)
{
listener
[
aMethod
]
.
apply
(
listener
aArgs
)
;
}
}
catch
(
e
)
{
logger
.
warn
(
"
AddonListener
threw
exception
when
calling
"
+
aMethod
e
)
;
}
}
}
async
notifyAddonChanged
(
aID
aType
aPendingRestart
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
aID
&
&
typeof
aID
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aID
must
be
a
string
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aType
|
|
typeof
aType
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aType
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
providers
=
[
.
.
.
this
.
providers
.
.
.
this
.
pendingProviders
]
;
for
(
let
provider
of
providers
)
{
let
result
=
callProvider
(
provider
"
addonChanged
"
null
aID
aType
aPendingRestart
)
;
if
(
result
)
{
await
result
;
}
}
}
updateAddonAppDisabledStates
(
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
this
.
callProviders
(
"
updateAddonAppDisabledStates
"
)
;
}
updateAddonRepositoryData
(
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
return
(
async
(
)
=
>
{
for
(
let
provider
of
this
.
providers
)
{
await
promiseCallProvider
(
provider
"
updateAddonRepositoryData
"
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
TEST
:
addon
-
repository
-
data
-
updated
"
)
;
}
)
(
)
;
}
async
getInstallForURL
(
aUrl
aOptions
=
{
}
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
aUrl
|
|
typeof
aUrl
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aURL
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
aOptions
.
hash
&
&
typeof
aOptions
.
hash
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
hash
must
be
a
string
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
aOptions
.
name
&
&
typeof
aOptions
.
name
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
name
must
be
a
string
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
aOptions
.
icons
)
{
if
(
typeof
aOptions
.
icons
=
=
"
string
"
)
{
aOptions
.
icons
=
{
"
32
"
:
aOptions
.
icons
}
;
}
else
if
(
typeof
aOptions
.
icons
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
icons
must
be
a
string
an
object
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
}
else
{
aOptions
.
icons
=
{
}
;
}
if
(
aOptions
.
version
&
&
typeof
aOptions
.
version
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
version
must
be
a
string
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
aOptions
.
browser
&
&
!
Element
.
isInstance
(
aOptions
.
browser
)
)
{
throw
Components
.
Exception
(
"
aOptions
.
browser
must
be
an
Element
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
for
(
let
provider
of
this
.
providers
)
{
let
install
=
await
promiseCallProvider
(
provider
"
getInstallForURL
"
aUrl
aOptions
)
;
if
(
install
)
{
return
install
;
}
}
return
null
;
}
getInstallForFile
(
aFile
aMimetype
aTelemetryInfo
aUseSystemLocation
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
(
aFile
instanceof
Ci
.
nsIFile
)
)
{
throw
Components
.
Exception
(
"
aFile
must
be
a
nsIFile
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
aMimetype
&
&
typeof
aMimetype
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aMimetype
must
be
a
string
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
return
(
async
(
)
=
>
{
for
(
let
provider
of
this
.
providers
)
{
let
install
=
await
promiseCallProvider
(
provider
"
getInstallForFile
"
aFile
aTelemetryInfo
aUseSystemLocation
)
;
if
(
install
)
{
return
install
;
}
}
return
null
;
}
)
(
)
;
}
uninstallSystemProfileAddon
(
aID
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
return
AddonManagerInternal
.
_getProviderByName
(
"
XPIProvider
"
)
.
uninstallSystemProfileAddon
(
aID
)
;
}
getInstallsByTypes
(
aTypes
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
aTypes
&
&
!
Array
.
isArray
(
aTypes
)
)
{
throw
Components
.
Exception
(
"
aTypes
must
be
an
array
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
return
(
async
(
)
=
>
{
let
installs
=
[
]
;
for
(
let
provider
of
this
.
providers
)
{
let
providerInstalls
=
await
promiseCallProvider
(
provider
"
getInstallsByTypes
"
aTypes
)
;
if
(
providerInstalls
)
{
installs
.
push
(
.
.
.
providerInstalls
)
;
}
}
return
installs
;
}
)
(
)
;
}
getAllInstalls
(
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
return
this
.
getInstallsByTypes
(
null
)
;
}
isInstallEnabled
(
aMimetype
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
aMimetype
|
|
typeof
aMimetype
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aMimetype
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
providers
=
[
.
.
.
this
.
providers
]
;
for
(
let
provider
of
providers
)
{
if
(
callProvider
(
provider
"
supportsMimetype
"
false
aMimetype
)
&
&
callProvider
(
provider
"
isInstallEnabled
"
)
)
{
return
true
;
}
}
return
false
;
}
isInstallAllowed
(
aMimetype
aInstallingPrincipal
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
aMimetype
|
|
typeof
aMimetype
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aMimetype
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aInstallingPrincipal
|
|
!
(
aInstallingPrincipal
instanceof
Ci
.
nsIPrincipal
)
)
{
throw
Components
.
Exception
(
"
aInstallingPrincipal
must
be
a
nsIPrincipal
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
this
.
isInstallAllowedByPolicy
(
aInstallingPrincipal
null
true
)
)
{
return
true
;
}
let
providers
=
[
.
.
.
this
.
providers
]
;
for
(
let
provider
of
providers
)
{
if
(
callProvider
(
provider
"
supportsMimetype
"
false
aMimetype
)
&
&
callProvider
(
provider
"
isInstallAllowed
"
null
aInstallingPrincipal
)
)
{
return
true
;
}
}
return
false
;
}
isInstallAllowedByPolicy
(
aInstallingPrincipal
aInstall
explicit
)
{
if
(
Services
.
policies
)
{
let
extensionSettings
=
Services
.
policies
.
getExtensionSettings
(
"
*
"
)
;
if
(
extensionSettings
&
&
extensionSettings
.
install_sources
)
{
if
(
(
!
aInstall
|
|
Services
.
policies
.
allowedInstallSource
(
aInstall
.
sourceURI
)
)
&
&
(
!
aInstallingPrincipal
|
|
!
aInstallingPrincipal
.
URI
|
|
Services
.
policies
.
allowedInstallSource
(
aInstallingPrincipal
.
URI
)
)
)
{
return
true
;
}
return
false
;
}
}
return
!
explicit
;
}
installNotifyObservers
(
aTopic
aBrowser
aUri
aInstall
aInstallFn
aCancelFn
)
{
let
info
=
{
wrappedJSObject
:
{
browser
:
aBrowser
originatingURI
:
aUri
installs
:
[
aInstall
]
install
:
aInstallFn
cancel
:
aCancelFn
}
}
;
Services
.
obs
.
notifyObservers
(
info
aTopic
)
;
}
startInstall
(
browser
url
install
)
{
this
.
installNotifyObservers
(
"
addon
-
install
-
started
"
browser
url
install
)
;
if
(
install
.
state
=
=
AddonManager
.
STATE_DOWNLOADED
&
&
install
.
addon
.
appDisabled
)
{
install
.
cancel
(
)
;
this
.
installNotifyObservers
(
"
addon
-
install
-
failed
"
browser
url
install
)
;
return
;
}
let
self
=
this
;
let
listener
=
{
onDownloadCancelled
(
)
{
install
.
removeListener
(
listener
)
;
}
onDownloadFailed
(
)
{
install
.
removeListener
(
listener
)
;
self
.
installNotifyObservers
(
"
addon
-
install
-
failed
"
browser
url
install
)
;
}
onDownloadEnded
(
)
{
if
(
install
.
addon
.
appDisabled
)
{
install
.
removeListener
(
listener
)
;
install
.
cancel
(
)
;
self
.
installNotifyObservers
(
"
addon
-
install
-
failed
"
browser
url
install
)
;
}
}
onInstallCancelled
(
)
{
install
.
removeListener
(
listener
)
;
}
onInstallFailed
(
)
{
install
.
removeListener
(
listener
)
;
self
.
installNotifyObservers
(
"
addon
-
install
-
failed
"
browser
url
install
)
;
}
onInstallEnded
(
)
{
install
.
removeListener
(
listener
)
;
if
(
install
.
addon
.
type
=
=
"
theme
"
&
&
!
!
install
.
addon
.
userDisabled
&
&
!
install
.
addon
.
appDisabled
)
{
install
.
addon
.
enable
(
)
;
}
let
needsRestart
=
install
.
addon
.
pendingOperations
!
=
AddonManager
.
PENDING_NONE
;
if
(
!
needsRestart
)
{
let
subject
=
{
wrappedJSObject
:
{
target
:
browser
addon
:
install
.
addon
}
}
;
Services
.
obs
.
notifyObservers
(
subject
"
webextension
-
install
-
notify
"
)
;
}
else
{
self
.
installNotifyObservers
(
"
addon
-
install
-
complete
"
browser
url
install
)
;
}
}
}
;
install
.
addListener
(
listener
)
;
install
.
install
(
)
;
}
installAddonFromWebpage
(
aMimetype
aBrowser
aInstallingPrincipal
aInstall
aDetails
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
aMimetype
|
|
typeof
aMimetype
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aMimetype
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
aBrowser
&
&
!
Element
.
isInstance
(
aBrowser
)
)
{
throw
Components
.
Exception
(
"
aSource
must
be
an
Element
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aInstallingPrincipal
|
|
!
(
aInstallingPrincipal
instanceof
Ci
.
nsIPrincipal
)
)
{
throw
Components
.
Exception
(
"
aInstallingPrincipal
must
be
a
nsIPrincipal
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
topBrowser
=
aBrowser
;
if
(
aBrowser
)
{
let
docShell
=
aBrowser
.
ownerGlobal
.
docShell
;
if
(
docShell
.
itemType
=
=
Ci
.
nsIDocShellTreeItem
.
typeContent
)
{
topBrowser
=
docShell
.
chromeEventHandler
;
}
}
try
{
if
(
topBrowser
&
&
topBrowser
.
ownerDocument
.
fullscreenElement
)
{
aInstall
.
cancel
(
)
;
this
.
installNotifyObservers
(
"
addon
-
install
-
fullscreen
-
blocked
"
topBrowser
aInstallingPrincipal
.
URI
aInstall
)
;
return
;
}
else
if
(
!
this
.
isInstallEnabled
(
aMimetype
)
)
{
aInstall
.
cancel
(
)
;
this
.
installNotifyObservers
(
"
addon
-
install
-
disabled
"
topBrowser
aInstallingPrincipal
.
URI
aInstall
)
;
return
;
}
else
if
(
!
this
.
isInstallAllowedByPolicy
(
aInstallingPrincipal
aInstall
false
)
)
{
aInstall
.
cancel
(
)
;
this
.
installNotifyObservers
(
"
addon
-
install
-
policy
-
blocked
"
topBrowser
aInstallingPrincipal
.
URI
aInstall
)
;
return
;
}
else
if
(
aDetails
?
.
hasCrossOriginAncestor
|
|
aInstallingPrincipal
.
isNullPrincipal
|
|
(
aBrowser
&
&
(
!
aBrowser
.
contentPrincipal
|
|
!
(
aBrowser
.
contentPrincipal
.
isNullPrincipal
|
|
aInstallingPrincipal
.
subsumes
(
aBrowser
.
contentPrincipal
)
)
)
)
)
{
aInstall
.
cancel
(
)
;
this
.
installNotifyObservers
(
"
addon
-
install
-
origin
-
blocked
"
topBrowser
aInstallingPrincipal
.
URI
aInstall
)
;
return
;
}
if
(
aBrowser
)
{
new
BrowserListener
(
aBrowser
aInstallingPrincipal
aInstall
)
;
}
let
startInstall
=
source
=
>
{
AddonManagerInternal
.
setupPromptHandler
(
aBrowser
aInstallingPrincipal
.
URI
aInstall
true
source
)
;
AddonManagerInternal
.
startInstall
(
aBrowser
aInstallingPrincipal
.
URI
aInstall
)
;
}
;
let
installAllowed
=
this
.
isInstallAllowed
(
aMimetype
aInstallingPrincipal
)
;
let
installPerm
=
Services
.
perms
.
testPermissionFromPrincipal
(
aInstallingPrincipal
"
install
"
)
;
if
(
installAllowed
)
{
startInstall
(
"
AMO
"
)
;
}
else
if
(
installPerm
=
=
=
Ci
.
nsIPermissionManager
.
DENY_ACTION
)
{
aInstall
.
cancel
(
)
;
this
.
installNotifyObservers
(
"
addon
-
install
-
blocked
-
silent
"
topBrowser
aInstallingPrincipal
.
URI
aInstall
)
;
}
else
if
(
!
lazy
.
WEBEXT_POSTDOWNLOAD_THIRD_PARTY
)
{
this
.
installNotifyObservers
(
"
addon
-
install
-
blocked
"
topBrowser
aInstallingPrincipal
.
URI
aInstall
(
)
=
>
startInstall
(
"
other
"
)
(
)
=
>
aInstall
.
cancel
(
)
)
;
}
else
{
logger
.
info
(
Addon
download
before
validation
.
)
;
startInstall
(
"
other
"
)
;
}
}
catch
(
e
)
{
logger
.
warn
(
"
Failure
calling
web
installer
"
e
)
;
aInstall
.
cancel
(
)
;
}
}
installAddonFromAOM
(
browser
uri
install
)
{
if
(
!
this
.
isInstallAllowedByPolicy
(
null
install
)
)
{
install
.
cancel
(
)
;
this
.
installNotifyObservers
(
"
addon
-
install
-
policy
-
blocked
"
browser
install
.
sourceURI
install
)
;
return
;
}
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
AddonManagerInternal
.
setupPromptHandler
(
browser
uri
install
true
"
local
"
)
;
AddonManagerInternal
.
startInstall
(
browser
uri
install
)
;
}
addInstallListener
(
aListener
)
{
if
(
!
aListener
|
|
typeof
aListener
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
aListener
must
be
a
InstallListener
object
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
installListeners
.
add
(
aListener
)
;
}
removeInstallListener
(
aListener
)
{
if
(
!
aListener
|
|
typeof
aListener
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
aListener
must
be
a
InstallListener
object
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
installListeners
.
delete
(
aListener
)
;
}
addUpgradeListener
(
aInstanceID
aCallback
)
{
if
(
!
aInstanceID
|
|
typeof
aInstanceID
!
=
"
symbol
"
)
{
throw
Components
.
Exception
(
"
aInstanceID
must
be
a
symbol
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aCallback
|
|
typeof
aCallback
!
=
"
function
"
)
{
throw
Components
.
Exception
(
"
aCallback
must
be
a
function
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
addonId
=
this
.
syncGetAddonIDByInstanceID
(
aInstanceID
)
;
if
(
!
addonId
)
{
throw
Error
(
No
addon
matching
instanceID
:
{
String
(
aInstanceID
)
}
)
;
}
logger
.
debug
(
Registering
upgrade
listener
for
{
addonId
}
)
;
this
.
upgradeListeners
.
set
(
addonId
aCallback
)
;
}
removeUpgradeListener
(
aInstanceID
)
{
if
(
!
aInstanceID
|
|
typeof
aInstanceID
!
=
"
symbol
"
)
{
throw
Components
.
Exception
(
"
aInstanceID
must
be
a
symbol
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
addonId
=
this
.
syncGetAddonIDByInstanceID
(
aInstanceID
)
;
if
(
!
addonId
)
{
throw
Error
(
No
addon
for
instanceID
:
{
aInstanceID
}
)
;
}
if
(
this
.
upgradeListeners
.
has
(
addonId
)
)
{
this
.
upgradeListeners
.
delete
(
addonId
)
;
}
else
{
throw
Error
(
No
upgrade
listener
registered
for
addon
ID
:
{
addonId
}
)
;
}
}
addExternalExtensionLoader
(
loader
)
{
this
.
externalExtensionLoaders
.
set
(
loader
.
name
loader
)
;
}
installTemporaryAddon
(
aFile
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
(
aFile
instanceof
Ci
.
nsIFile
)
)
{
throw
Components
.
Exception
(
"
aFile
must
be
a
nsIFile
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
return
AddonManagerInternal
.
_getProviderByName
(
"
XPIProvider
"
)
.
installTemporaryAddon
(
aFile
)
;
}
installBuiltinAddon
(
aBase
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
return
AddonManagerInternal
.
_getProviderByName
(
"
XPIProvider
"
)
.
installBuiltinAddon
(
aBase
)
;
}
maybeInstallBuiltinAddon
(
aID
aVersion
aBase
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
return
AddonManagerInternal
.
_getProviderByName
(
"
XPIProvider
"
)
.
maybeInstallBuiltinAddon
(
aID
aVersion
aBase
)
;
}
syncGetAddonIDByInstanceID
(
aInstanceID
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
aInstanceID
|
|
typeof
aInstanceID
!
=
"
symbol
"
)
{
throw
Components
.
Exception
(
"
aInstanceID
must
be
a
Symbol
(
)
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
return
AddonManagerInternal
.
_getProviderByName
(
"
XPIProvider
"
)
.
getAddonIDByInstanceID
(
aInstanceID
)
;
}
getPreferredIconURL
(
aAddon
aSize
aWindow
=
undefined
)
{
if
(
aWindow
&
&
aWindow
.
devicePixelRatio
)
{
aSize
*
=
aWindow
.
devicePixelRatio
;
}
let
icons
=
aAddon
.
icons
;
if
(
!
icons
)
{
icons
=
{
}
;
if
(
aAddon
.
iconURL
)
{
icons
[
32
]
=
aAddon
.
iconURL
;
icons
[
48
]
=
aAddon
.
iconURL
;
}
}
if
(
icons
[
aSize
]
)
{
return
icons
[
aSize
]
;
}
let
bestSize
=
null
;
for
(
let
size
of
Object
.
keys
(
icons
)
)
{
if
(
!
INTEGER
.
test
(
size
)
)
{
throw
Components
.
Exception
(
"
Invalid
icon
size
must
be
an
integer
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
size
=
parseInt
(
size
10
)
;
if
(
!
bestSize
)
{
bestSize
=
size
;
continue
;
}
if
(
size
>
aSize
&
&
bestSize
>
aSize
)
{
bestSize
=
Math
.
min
(
bestSize
size
)
;
}
else
{
bestSize
=
Math
.
max
(
bestSize
size
)
;
}
}
return
icons
[
bestSize
]
|
|
null
;
}
getAddonByID
(
aID
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
aID
|
|
typeof
aID
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aID
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
promises
=
Array
.
from
(
this
.
providers
p
=
>
promiseCallProvider
(
p
"
getAddonByID
"
aID
)
)
;
return
Promise
.
all
(
promises
)
.
then
(
aAddons
=
>
{
return
aAddons
.
find
(
a
=
>
!
!
a
)
|
|
null
;
}
)
;
}
getAddonBySyncGUID
(
aGUID
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
aGUID
|
|
typeof
aGUID
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
aGUID
must
be
a
non
-
empty
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
return
(
async
(
)
=
>
{
for
(
let
provider
of
this
.
providers
)
{
let
addon
=
await
promiseCallProvider
(
provider
"
getAddonBySyncGUID
"
aGUID
)
;
if
(
addon
)
{
return
addon
;
}
}
return
null
;
}
)
(
)
;
}
getAddonsByIDs
(
aIDs
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
Array
.
isArray
(
aIDs
)
)
{
throw
Components
.
Exception
(
"
aIDs
must
be
an
array
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
promises
=
aIDs
.
map
(
a
=
>
AddonManagerInternal
.
getAddonByID
(
a
)
)
;
return
Promise
.
all
(
promises
)
;
}
getAddonsByTypes
(
aTypes
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
aTypes
&
&
!
Array
.
isArray
(
aTypes
)
)
{
throw
Components
.
Exception
(
"
aTypes
must
be
an
array
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
return
(
async
(
)
=
>
{
let
addons
=
[
]
;
for
(
let
provider
of
this
.
providers
)
{
let
providerAddons
=
await
promiseCallProvider
(
provider
"
getAddonsByTypes
"
aTypes
)
;
if
(
providerAddons
)
{
addons
.
push
(
.
.
.
providerAddons
)
;
}
}
return
addons
;
}
)
(
)
;
}
async
getActiveAddons
(
aTypes
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
aTypes
&
&
!
Array
.
isArray
(
aTypes
)
)
{
throw
Components
.
Exception
(
"
aTypes
must
be
an
array
or
null
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
addons
=
[
]
fullData
=
true
;
for
(
let
provider
of
this
.
providers
)
{
let
providerAddons
providerFullData
;
if
(
"
getActiveAddons
"
in
provider
)
{
(
{
addons
:
providerAddons
fullData
:
providerFullData
}
=
await
callProvider
(
provider
"
getActiveAddons
"
null
aTypes
)
)
;
}
else
{
providerAddons
=
await
promiseCallProvider
(
provider
"
getAddonsByTypes
"
aTypes
)
;
providerAddons
=
providerAddons
.
filter
(
a
=
>
a
.
isActive
)
;
providerFullData
=
true
;
}
if
(
providerAddons
)
{
addons
.
push
(
.
.
.
providerAddons
)
;
fullData
=
fullData
&
&
providerFullData
;
}
}
return
{
addons
fullData
}
;
}
getAllAddons
(
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
return
this
.
getAddonsByTypes
(
null
)
;
}
addManagerListener
(
aListener
)
{
if
(
!
aListener
|
|
typeof
aListener
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
aListener
must
be
an
AddonManagerListener
object
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
managerListeners
.
add
(
aListener
)
;
}
removeManagerListener
(
aListener
)
{
if
(
!
aListener
|
|
typeof
aListener
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
aListener
must
be
an
AddonManagerListener
object
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
managerListeners
.
delete
(
aListener
)
;
}
addAddonListener
(
aListener
)
{
if
(
!
aListener
|
|
typeof
aListener
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
aListener
must
be
an
AddonListener
object
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
addonListeners
.
add
(
aListener
)
;
}
removeAddonListener
(
aListener
)
{
if
(
!
aListener
|
|
typeof
aListener
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
aListener
must
be
an
AddonListener
object
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
addonListeners
.
delete
(
aListener
)
;
}
hasAddonType
(
addonType
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
for
(
let
addonTypes
of
this
.
typesByProvider
.
values
(
)
)
{
if
(
addonTypes
.
has
(
addonType
)
)
{
return
true
;
}
}
return
false
;
}
get
autoUpdateDefault
(
)
{
return
gAutoUpdateDefault
;
}
set
autoUpdateDefault
(
aValue
)
{
aValue
=
!
!
aValue
;
if
(
aValue
!
=
gAutoUpdateDefault
)
{
Services
.
prefs
.
setBoolPref
(
PREF_EM_AUTOUPDATE_DEFAULT
aValue
)
;
}
}
get
checkCompatibility
(
)
{
return
gCheckCompatibility
;
}
set
checkCompatibility
(
aValue
)
{
aValue
=
!
!
aValue
;
if
(
aValue
!
=
gCheckCompatibility
)
{
if
(
!
aValue
)
{
Services
.
prefs
.
setBoolPref
(
PREF_EM_CHECK_COMPATIBILITY
false
)
;
}
else
{
Services
.
prefs
.
clearUserPref
(
PREF_EM_CHECK_COMPATIBILITY
)
;
}
}
}
get
strictCompatibility
(
)
{
return
gStrictCompatibility
;
}
set
strictCompatibility
(
aValue
)
{
aValue
=
!
!
aValue
;
if
(
aValue
!
=
gStrictCompatibility
)
{
Services
.
prefs
.
setBoolPref
(
PREF_EM_STRICT_COMPATIBILITY
aValue
)
;
}
}
get
checkUpdateSecurityDefault
(
)
{
return
gCheckUpdateSecurityDefault
;
}
get
checkUpdateSecurity
(
)
{
return
gCheckUpdateSecurity
;
}
set
checkUpdateSecurity
(
aValue
)
{
aValue
=
!
!
aValue
;
if
(
aValue
!
=
gCheckUpdateSecurity
)
{
if
(
aValue
!
=
gCheckUpdateSecurityDefault
)
{
Services
.
prefs
.
setBoolPref
(
PREF_EM_CHECK_UPDATE_SECURITY
aValue
)
;
}
else
{
Services
.
prefs
.
clearUserPref
(
PREF_EM_CHECK_UPDATE_SECURITY
)
;
}
}
}
get
updateEnabled
(
)
{
return
gUpdateEnabled
;
}
set
updateEnabled
(
aValue
)
{
aValue
=
!
!
aValue
;
if
(
aValue
!
=
gUpdateEnabled
)
{
Services
.
prefs
.
setBoolPref
(
PREF_EM_UPDATE_ENABLED
aValue
)
;
}
}
_verifyThirdPartyInstall
(
browser
url
install
info
source
)
{
if
(
!
lazy
.
WEBEXT_POSTDOWNLOAD_THIRD_PARTY
|
|
[
"
AMO
"
"
local
"
]
.
includes
(
source
)
)
{
return
Promise
.
resolve
(
)
;
}
if
(
!
info
.
addon
.
validInstallOrigins
(
{
installFrom
:
url
source
:
install
.
sourceURI
}
)
)
{
install
.
error
=
AddonManager
.
ERROR_INVALID_DOMAIN
;
return
Promise
.
reject
(
)
;
}
if
(
info
.
addon
.
canBypassThirdParyInstallPrompt
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
installNotifyObservers
(
"
addon
-
install
-
blocked
"
browser
url
install
resolve
reject
)
;
}
)
;
}
setupPromptHandler
(
browser
url
install
requireConfirm
source
)
{
install
.
promptHandler
=
info
=
>
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_verifyThirdPartyInstall
(
browser
url
install
info
source
)
.
then
(
(
)
=
>
{
if
(
info
.
addon
.
userPermissions
)
{
let
subject
=
{
wrappedJSObject
:
{
target
:
browser
info
:
Object
.
assign
(
{
resolve
reject
source
}
info
)
}
}
;
subject
.
wrappedJSObject
.
info
.
permissions
=
info
.
addon
.
userPermissions
;
Services
.
obs
.
notifyObservers
(
subject
"
webextension
-
permission
-
prompt
"
)
;
}
else
if
(
info
.
addon
.
sitePermissions
)
{
let
{
sitePermissions
siteOrigin
}
=
info
.
addon
;
let
subject
=
{
wrappedJSObject
:
{
target
:
browser
info
:
Object
.
assign
(
{
resolve
reject
source
sitePermissions
siteOrigin
}
info
)
}
}
;
Services
.
obs
.
notifyObservers
(
subject
"
webextension
-
permission
-
prompt
"
)
;
}
else
if
(
requireConfirm
)
{
let
proxy
=
new
Proxy
(
install
{
get
(
target
property
)
{
if
(
property
=
=
"
install
"
)
{
return
resolve
;
}
else
if
(
property
=
=
"
cancel
"
)
{
return
reject
;
}
else
if
(
property
=
=
"
wrapped
"
)
{
return
target
;
}
let
result
=
target
[
property
]
;
return
typeof
result
=
=
"
function
"
?
result
.
bind
(
target
)
:
result
;
}
}
)
;
if
(
"
mozilla
.
org
/
addons
/
web
-
install
-
prompt
;
1
"
in
Cc
)
{
try
{
let
prompt
=
Cc
[
"
mozilla
.
org
/
addons
/
web
-
install
-
prompt
;
1
"
]
.
getService
(
Ci
.
amIWebInstallPrompt
)
;
prompt
.
confirm
(
browser
url
[
proxy
]
)
;
return
;
}
catch
(
e
)
{
}
}
this
.
installNotifyObservers
(
"
addon
-
install
-
confirmation
"
browser
url
proxy
)
;
}
else
{
resolve
(
)
;
}
}
)
.
catch
(
e
=
>
{
if
(
e
)
{
Cu
.
reportError
(
Install
prompt
handler
error
:
{
e
}
)
;
}
reject
(
)
;
}
)
;
}
)
;
}
webAPI
:
{
installs
:
new
Map
(
)
nextInstall
:
0
sendEvent
:
null
setEventHandler
(
fn
)
{
this
.
sendEvent
=
fn
;
}
async
getAddonByID
(
target
id
)
{
return
webAPIForAddon
(
await
AddonManager
.
getAddonByID
(
id
)
)
;
}
copyProps
(
install
obj
)
{
obj
.
state
=
AddonManager
.
stateToString
(
install
.
state
)
;
obj
.
error
=
AddonManager
.
errorToString
(
install
.
error
)
;
obj
.
progress
=
install
.
progress
;
obj
.
maxProgress
=
install
.
maxProgress
;
}
forgetInstall
(
id
)
{
let
info
=
this
.
installs
.
get
(
id
)
;
if
(
!
info
)
{
throw
new
Error
(
forgetInstall
cannot
find
{
id
}
)
;
}
info
.
install
.
removeListener
(
info
.
listener
)
;
this
.
installs
.
delete
(
id
)
;
}
createInstall
(
target
options
)
{
function
checkInstallUri
(
uri
)
{
if
(
!
Services
.
policies
.
allowedInstallSource
(
uri
)
)
{
return
{
success
:
false
code
:
"
addon
-
install
-
policy
-
blocked
"
message
:
Install
from
{
uri
.
spec
}
not
permitted
by
policy
}
;
}
if
(
WEBAPI_INSTALL_HOSTS
.
includes
(
uri
.
host
)
)
{
return
{
success
:
true
}
;
}
if
(
Services
.
prefs
.
getBoolPref
(
PREF_WEBAPI_TESTING
false
)
&
&
WEBAPI_TEST_INSTALL_HOSTS
.
includes
(
uri
.
host
)
)
{
return
{
success
:
true
}
;
}
return
{
success
:
false
code
:
"
addon
-
install
-
webapi
-
blocked
"
message
:
Install
from
{
uri
.
host
}
not
permitted
}
;
}
const
makeListener
=
(
id
mm
)
=
>
{
const
events
=
[
"
onDownloadStarted
"
"
onDownloadProgress
"
"
onDownloadEnded
"
"
onDownloadCancelled
"
"
onDownloadFailed
"
"
onInstallStarted
"
"
onInstallEnded
"
"
onInstallCancelled
"
"
onInstallFailed
"
]
;
let
listener
=
{
}
;
let
installPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
events
.
forEach
(
event
=
>
{
listener
[
event
]
=
(
install
addon
)
=
>
{
let
data
=
{
event
id
}
;
AddonManager
.
webAPI
.
copyProps
(
install
data
)
;
this
.
sendEvent
(
mm
data
)
;
if
(
event
=
=
"
onInstallEnded
"
)
{
resolve
(
addon
)
;
}
else
if
(
event
=
=
"
onDownloadFailed
"
|
|
event
=
=
"
onInstallFailed
"
)
{
reject
(
{
message
:
"
install
failed
"
}
)
;
}
else
if
(
event
=
=
"
onDownloadCancelled
"
|
|
event
=
=
"
onInstallCancelled
"
)
{
reject
(
{
message
:
"
install
cancelled
"
}
)
;
}
else
if
(
event
=
=
"
onDownloadEnded
"
)
{
if
(
install
.
addon
.
appDisabled
)
{
install
.
cancel
(
)
;
AddonManagerInternal
.
installNotifyObservers
(
"
addon
-
install
-
failed
"
target
Services
.
io
.
newURI
(
options
.
url
)
install
)
;
}
}
}
;
}
)
;
}
)
;
installPromise
.
catch
(
(
)
=
>
{
}
)
;
return
{
listener
installPromise
}
;
}
;
let
uri
;
try
{
uri
=
Services
.
io
.
newURI
(
options
.
url
)
;
const
{
success
code
message
}
=
checkInstallUri
(
uri
)
;
if
(
!
success
)
{
let
info
=
{
wrappedJSObject
:
{
browser
:
target
originatingURI
:
uri
installs
:
[
]
}
}
;
Cu
.
reportError
(
{
code
}
:
{
message
}
)
;
Services
.
obs
.
notifyObservers
(
info
code
)
;
return
Promise
.
reject
(
{
code
message
}
)
;
}
}
catch
(
err
)
{
if
(
err
instanceof
Components
.
Exception
)
{
return
Promise
.
reject
(
{
message
:
err
.
message
}
)
;
}
return
Promise
.
reject
(
{
message
:
"
Install
Failed
on
unexpected
error
"
}
)
;
}
return
AddonManagerInternal
.
getInstallForURL
(
options
.
url
{
browser
:
target
triggeringPrincipal
:
options
.
triggeringPrincipal
hash
:
options
.
hash
telemetryInfo
:
{
source
:
AddonManager
.
getInstallSourceFromHost
(
options
.
sourceHost
)
sourceURL
:
options
.
sourceURL
method
:
"
amWebAPI
"
}
}
)
.
then
(
install
=
>
{
let
requireConfirm
=
true
;
if
(
target
.
contentDocument
&
&
target
.
contentDocument
.
nodePrincipal
.
isSystemPrincipal
)
{
requireConfirm
=
false
;
}
AddonManagerInternal
.
setupPromptHandler
(
target
null
install
requireConfirm
"
AMO
"
)
;
let
id
=
this
.
nextInstall
+
+
;
let
{
listener
installPromise
}
=
makeListener
(
id
target
.
messageManager
)
;
install
.
addListener
(
listener
)
;
this
.
installs
.
set
(
id
{
install
target
listener
installPromise
messageManager
:
target
.
messageManager
}
)
;
let
result
=
{
id
}
;
this
.
copyProps
(
install
result
)
;
return
result
;
}
)
;
}
async
addonUninstall
(
target
id
)
{
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
if
(
!
addon
)
{
return
false
;
}
if
(
!
(
addon
.
permissions
&
AddonManager
.
PERM_CAN_UNINSTALL
)
)
{
return
Promise
.
reject
(
{
message
:
"
Addon
cannot
be
uninstalled
"
}
)
;
}
try
{
addon
.
uninstall
(
)
;
return
true
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
return
false
;
}
}
async
addonSetEnabled
(
target
id
value
)
{
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
if
(
!
addon
)
{
throw
new
Error
(
No
such
addon
{
id
}
)
;
}
if
(
value
)
{
await
addon
.
enable
(
)
;
}
else
{
await
addon
.
disable
(
)
;
}
}
async
addonInstallDoInstall
(
target
id
)
{
let
state
=
this
.
installs
.
get
(
id
)
;
if
(
!
state
)
{
throw
new
Error
(
invalid
id
{
id
}
)
;
}
let
addon
=
await
state
.
install
.
install
(
)
;
if
(
addon
.
type
=
=
"
theme
"
&
&
!
addon
.
appDisabled
)
{
await
addon
.
enable
(
)
;
}
await
new
Promise
(
resolve
=
>
{
let
subject
=
{
wrappedJSObject
:
{
target
addon
callback
:
resolve
}
}
;
Services
.
obs
.
notifyObservers
(
subject
"
webextension
-
install
-
notify
"
)
;
}
)
;
}
addonInstallCancel
(
target
id
)
{
let
state
=
this
.
installs
.
get
(
id
)
;
if
(
!
state
)
{
return
Promise
.
reject
(
invalid
id
{
id
}
)
;
}
return
Promise
.
resolve
(
state
.
install
.
cancel
(
)
)
;
}
clearInstalls
(
ids
)
{
for
(
let
id
of
ids
)
{
this
.
forgetInstall
(
id
)
;
}
}
clearInstallsFrom
(
mm
)
{
for
(
let
[
id
info
]
of
this
.
installs
)
{
if
(
info
.
messageManager
=
=
mm
)
{
this
.
forgetInstall
(
id
)
;
}
}
}
async
addonReportAbuse
(
target
id
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
PREF_AMO_ABUSEREPORT
false
)
)
{
return
Promise
.
reject
(
{
message
:
"
amWebAPI
reportAbuse
not
supported
"
}
)
;
}
let
existingDialog
=
lazy
.
AbuseReporter
.
getOpenDialog
(
)
;
if
(
existingDialog
)
{
existingDialog
.
close
(
)
;
}
const
dialog
=
await
lazy
.
AbuseReporter
.
openDialog
(
id
"
amo
"
target
)
.
catch
(
err
=
>
{
Cu
.
reportError
(
err
)
;
return
Promise
.
reject
(
{
message
:
"
Error
creating
abuse
report
"
}
)
;
}
)
;
return
dialog
.
promiseReport
.
then
(
async
report
=
>
{
if
(
!
report
)
{
return
false
;
}
await
report
.
submit
(
)
.
catch
(
err
=
>
{
Cu
.
reportError
(
err
)
;
return
Promise
.
reject
(
{
message
:
"
Error
submitting
abuse
report
"
}
)
;
}
)
;
return
true
;
}
err
=
>
{
Cu
.
reportError
(
err
)
;
dialog
.
close
(
)
;
return
Promise
.
reject
(
{
message
:
"
Error
creating
abuse
report
"
}
)
;
}
)
;
}
}
}
;
var
AddonManagerPrivate
=
{
startup
(
)
{
AddonManagerInternal
.
startup
(
)
;
}
addonIsActive
(
addonId
)
{
return
AddonManagerInternal
.
_getProviderByName
(
"
XPIProvider
"
)
.
addonIsActive
(
addonId
)
;
}
getNewSideloads
(
)
{
return
AddonManagerInternal
.
_getProviderByName
(
"
XPIProvider
"
)
.
getNewSideloads
(
)
;
}
get
browserUpdated
(
)
{
return
gBrowserUpdated
;
}
registerProvider
(
aProvider
aTypes
)
{
AddonManagerInternal
.
registerProvider
(
aProvider
aTypes
)
;
}
unregisterProvider
(
aProvider
)
{
AddonManagerInternal
.
unregisterProvider
(
aProvider
)
;
}
getAddonTypesByProvider
(
aProviderName
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
for
(
let
[
provider
addonTypes
]
of
AddonManagerInternal
.
typesByProvider
)
{
if
(
providerName
(
provider
)
=
=
=
aProviderName
)
{
return
Array
.
from
(
addonTypes
)
;
}
}
throw
Components
.
Exception
(
No
addonTypes
found
for
provider
:
{
aProviderName
}
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
markProviderSafe
(
aProvider
)
{
AddonManagerInternal
.
markProviderSafe
(
aProvider
)
;
}
backgroundUpdateCheck
(
)
{
return
AddonManagerInternal
.
backgroundUpdateCheck
(
)
;
}
backgroundUpdateTimerHandler
(
)
{
AddonManagerInternal
.
backgroundUpdateCheck
(
)
;
}
addStartupChange
(
aType
aID
)
{
AddonManagerInternal
.
addStartupChange
(
aType
aID
)
;
}
removeStartupChange
(
aType
aID
)
{
AddonManagerInternal
.
removeStartupChange
(
aType
aID
)
;
}
notifyAddonChanged
(
aID
aType
aPendingRestart
)
{
return
AddonManagerInternal
.
notifyAddonChanged
(
aID
aType
aPendingRestart
)
;
}
updateAddonAppDisabledStates
(
)
{
AddonManagerInternal
.
updateAddonAppDisabledStates
(
)
;
}
updateAddonRepositoryData
(
)
{
return
AddonManagerInternal
.
updateAddonRepositoryData
(
)
;
}
callInstallListeners
(
.
.
.
aArgs
)
{
return
AddonManagerInternal
.
callInstallListeners
.
apply
(
AddonManagerInternal
aArgs
)
;
}
callAddonListeners
(
.
.
.
aArgs
)
{
AddonManagerInternal
.
callAddonListeners
.
apply
(
AddonManagerInternal
aArgs
)
;
}
AddonAuthor
AddonScreenshot
get
BOOTSTRAP_REASONS
(
)
{
return
gXPIProvider
.
BOOTSTRAP_REASONS
;
}
setAddonStartupData
(
addonId
startupData
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
gXPIProvider
.
setStartupData
(
addonId
startupData
)
;
}
unregisterDictionaries
(
aDicts
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
gXPIProvider
.
unregisterDictionaries
(
aDicts
)
;
}
recordTimestamp
(
name
value
)
{
AddonManagerInternal
.
recordTimestamp
(
name
value
)
;
}
_simpleMeasures
:
{
}
recordSimpleMeasure
(
name
value
)
{
this
.
_simpleMeasures
[
name
]
=
value
;
}
recordException
(
aModule
aContext
aException
)
{
let
report
=
{
module
:
aModule
context
:
aContext
}
;
if
(
typeof
aException
=
=
"
number
"
)
{
report
.
message
=
Components
.
Exception
(
"
"
aException
)
.
name
;
}
else
{
report
.
message
=
aException
.
toString
(
)
;
if
(
aException
.
fileName
)
{
report
.
file
=
aException
.
fileName
;
report
.
line
=
aException
.
lineNumber
;
}
}
this
.
_simpleMeasures
.
exception
=
report
;
}
getSimpleMeasures
(
)
{
return
this
.
_simpleMeasures
;
}
getTelemetryDetails
(
)
{
return
AddonManagerInternal
.
telemetryDetails
;
}
setTelemetryDetails
(
aProvider
aDetails
)
{
AddonManagerInternal
.
telemetryDetails
[
aProvider
]
=
aDetails
;
}
simpleTimer
(
aName
)
{
let
startTime
=
Cu
.
now
(
)
;
return
{
done
:
(
)
=
>
this
.
recordSimpleMeasure
(
aName
Math
.
round
(
Cu
.
now
(
)
-
startTime
)
)
}
;
}
async
recordTiming
(
name
task
)
{
let
timer
=
this
.
simpleTimer
(
name
)
;
try
{
return
await
task
(
)
;
}
finally
{
timer
.
done
(
)
;
}
}
callNoUpdateListeners
(
addon
listener
reason
appVersion
platformVersion
)
{
if
(
"
onNoCompatibilityUpdateAvailable
"
in
listener
)
{
safeCall
(
listener
.
onNoCompatibilityUpdateAvailable
.
bind
(
listener
)
addon
)
;
}
if
(
"
onNoUpdateAvailable
"
in
listener
)
{
safeCall
(
listener
.
onNoUpdateAvailable
.
bind
(
listener
)
addon
)
;
}
if
(
"
onUpdateFinished
"
in
listener
)
{
safeCall
(
listener
.
onUpdateFinished
.
bind
(
listener
)
addon
)
;
}
}
get
webExtensionsMinPlatformVersion
(
)
{
return
gWebExtensionsMinPlatformVersion
;
}
hasUpgradeListener
(
aId
)
{
return
AddonManagerInternal
.
upgradeListeners
.
has
(
aId
)
;
}
getUpgradeListener
(
aId
)
{
return
AddonManagerInternal
.
upgradeListeners
.
get
(
aId
)
;
}
get
externalExtensionLoaders
(
)
{
return
AddonManagerInternal
.
externalExtensionLoaders
;
}
isTemporaryInstallID
(
extensionId
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
!
extensionId
|
|
typeof
extensionId
!
=
"
string
"
)
{
throw
Components
.
Exception
(
"
extensionId
must
be
a
string
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
return
AddonManagerInternal
.
_getProviderByName
(
"
XPIProvider
"
)
.
isTemporaryInstallID
(
extensionId
)
;
}
isDBLoaded
(
)
{
let
provider
=
AddonManagerInternal
.
_getProviderByName
(
"
XPIProvider
"
)
;
return
provider
?
provider
.
isDBLoaded
:
false
;
}
get
databaseReady
(
)
{
let
provider
=
AddonManagerInternal
.
_getProviderByName
(
"
XPIProvider
"
)
;
return
provider
?
provider
.
databaseReady
:
new
Promise
(
(
)
=
>
{
}
)
;
}
get
finalShutdown
(
)
{
return
gFinalShutdownBarrier
.
client
;
}
overrideAddonRepository
(
mockRepo
)
{
lazy
.
AddonRepository
=
mockRepo
;
}
overrideAsyncShutdown
(
mockAsyncShutdown
)
{
AsyncShutdown
=
mockAsyncShutdown
;
}
}
;
var
AddonManager
=
{
_installHostSource
:
new
Map
(
[
[
"
addons
.
mozilla
.
org
"
"
amo
"
]
[
"
discovery
.
addons
.
mozilla
.
org
"
"
disco
"
]
]
)
_states
:
new
Map
(
[
[
"
STATE_AVAILABLE
"
0
]
[
"
STATE_DOWNLOADING
"
1
]
[
"
STATE_CHECKING_UPDATE
"
2
]
[
"
STATE_DOWNLOADED
"
3
]
[
"
STATE_DOWNLOAD_FAILED
"
4
]
[
"
STATE_AWAITING_PROMPT
"
5
]
[
"
STATE_PROMPTS_DONE
"
6
]
[
"
STATE_POSTPONED
"
7
]
[
"
STATE_READY
"
8
]
[
"
STATE_INSTALLING
"
9
]
[
"
STATE_INSTALLED
"
10
]
[
"
STATE_INSTALL_FAILED
"
11
]
[
"
STATE_CANCELLED
"
12
]
]
)
_errors
:
new
Map
(
[
[
"
ERROR_NETWORK_FAILURE
"
-
1
]
[
"
ERROR_INCORRECT_HASH
"
-
2
]
[
"
ERROR_CORRUPT_FILE
"
-
3
]
[
"
ERROR_FILE_ACCESS
"
-
4
]
[
"
ERROR_SIGNEDSTATE_REQUIRED
"
-
5
]
[
"
ERROR_UNEXPECTED_ADDON_TYPE
"
-
6
]
[
"
ERROR_INCORRECT_ID
"
-
7
]
[
"
ERROR_INVALID_DOMAIN
"
-
8
]
[
"
ERROR_UNEXPECTED_ADDON_VERSION
"
-
9
]
]
)
ERROR_TIMEOUT
:
-
1
ERROR_DOWNLOAD_ERROR
:
-
2
ERROR_PARSE_ERROR
:
-
3
ERROR_UNKNOWN_FORMAT
:
-
4
ERROR_SECURITY_ERROR
:
-
5
ERROR_CANCELLED
:
-
6
UPDATE_STATUS_NO_ERROR
:
0
UPDATE_STATUS_TIMEOUT
:
-
1
UPDATE_STATUS_DOWNLOAD_ERROR
:
-
2
UPDATE_STATUS_PARSE_ERROR
:
-
3
UPDATE_STATUS_UNKNOWN_FORMAT
:
-
4
UPDATE_STATUS_SECURITY_ERROR
:
-
5
UPDATE_STATUS_CANCELLED
:
-
6
UPDATE_WHEN_USER_REQUESTED
:
1
UPDATE_WHEN_NEW_APP_DETECTED
:
2
UPDATE_WHEN_NEW_APP_INSTALLED
:
3
UPDATE_WHEN_PERIODIC_UPDATE
:
16
UPDATE_WHEN_ADDON_INSTALLED
:
17
PENDING_NONE
:
0
PENDING_ENABLE
:
1
PENDING_DISABLE
:
2
PENDING_UNINSTALL
:
4
PENDING_INSTALL
:
8
PENDING_UPGRADE
:
16
OP_NEEDS_RESTART_NONE
:
0
OP_NEEDS_RESTART_ENABLE
:
1
OP_NEEDS_RESTART_DISABLE
:
2
OP_NEEDS_RESTART_UNINSTALL
:
4
OP_NEEDS_RESTART_INSTALL
:
8
PERM_CAN_UNINSTALL
:
1
PERM_CAN_ENABLE
:
2
PERM_CAN_DISABLE
:
4
PERM_CAN_UPGRADE
:
8
PERM_CAN_CHANGE_PRIVATEBROWSING_ACCESS
:
32
PERM_API_CAN_UNINSTALL
:
64
SCOPE_PROFILE
:
1
SCOPE_USER
:
2
SCOPE_APPLICATION
:
4
SCOPE_SYSTEM
:
8
SCOPE_TEMPORARY
:
16
SCOPE_ALL
:
31
AUTOUPDATE_DISABLE
:
0
AUTOUPDATE_DEFAULT
:
1
AUTOUPDATE_ENABLE
:
2
OPTIONS_TYPE_TAB
:
3
OPTIONS_TYPE_INLINE_BROWSER
:
5
OPTIONS_NOTIFICATION_DISPLAYED
:
"
addon
-
options
-
displayed
"
OPTIONS_NOTIFICATION_HIDDEN
:
"
addon
-
options
-
hidden
"
STARTUP_CHANGE_INSTALLED
:
"
installed
"
STARTUP_CHANGE_CHANGED
:
"
changed
"
STARTUP_CHANGE_UNINSTALLED
:
"
uninstalled
"
STARTUP_CHANGE_DISABLED
:
"
disabled
"
STARTUP_CHANGE_ENABLED
:
"
enabled
"
SIGNEDSTATE_NOT_REQUIRED
:
undefined
SIGNEDSTATE_BROKEN
:
-
2
SIGNEDSTATE_UNKNOWN
:
-
1
SIGNEDSTATE_MISSING
:
0
SIGNEDSTATE_PRELIMINARY
:
1
SIGNEDSTATE_SIGNED
:
2
SIGNEDSTATE_SYSTEM
:
3
SIGNEDSTATE_PRIVILEGED
:
4
get
__AddonManagerInternal__
(
)
{
return
AppConstants
.
DEBUG
?
AddonManagerInternal
:
undefined
;
}
get
isReady
(
)
{
return
gStartupComplete
&
&
!
gShutdownInProgress
;
}
get
readyPromise
(
)
{
return
gStartedPromise
.
promise
;
}
init
(
)
{
this
.
_stateToString
=
new
Map
(
)
;
for
(
let
[
name
value
]
of
this
.
_states
)
{
this
[
name
]
=
value
;
this
.
_stateToString
.
set
(
value
name
)
;
}
this
.
_errorToString
=
new
Map
(
)
;
for
(
let
[
name
value
]
of
this
.
_errors
)
{
this
[
name
]
=
value
;
this
.
_errorToString
.
set
(
value
name
)
;
}
}
stateToString
(
state
)
{
return
this
.
_stateToString
.
get
(
state
)
;
}
errorToString
(
err
)
{
return
err
?
this
.
_errorToString
.
get
(
err
)
:
null
;
}
getInstallSourceFromHost
(
host
)
{
if
(
this
.
_installHostSource
.
has
(
host
)
)
{
return
this
.
_installHostSource
.
get
(
host
)
;
}
if
(
WEBAPI_TEST_INSTALL_HOSTS
.
includes
(
host
)
)
{
return
"
test
-
host
"
;
}
return
"
unknown
"
;
}
getInstallForURL
(
aUrl
aOptions
)
{
return
AddonManagerInternal
.
getInstallForURL
(
aUrl
aOptions
)
;
}
getInstallForFile
(
aFile
aMimetype
aTelemetryInfo
aUseSystemLocation
=
false
)
{
return
AddonManagerInternal
.
getInstallForFile
(
aFile
aMimetype
aTelemetryInfo
aUseSystemLocation
)
;
}
uninstallSystemProfileAddon
(
aID
)
{
return
AddonManagerInternal
.
uninstallSystemProfileAddon
(
aID
)
;
}
stageLangpacksForAppUpdate
(
appVersion
platformVersion
)
{
return
AddonManagerInternal
.
_getProviderByName
(
"
XPIProvider
"
)
.
stageLangpacksForAppUpdate
(
appVersion
platformVersion
)
;
}
getStartupChanges
(
aType
)
{
if
(
!
(
aType
in
AddonManagerInternal
.
startupChanges
)
)
{
return
[
]
;
}
return
AddonManagerInternal
.
startupChanges
[
aType
]
.
slice
(
0
)
;
}
getAddonByID
(
aID
)
{
return
AddonManagerInternal
.
getAddonByID
(
aID
)
;
}
getAddonBySyncGUID
(
aGUID
)
{
return
AddonManagerInternal
.
getAddonBySyncGUID
(
aGUID
)
;
}
getAddonsByIDs
(
aIDs
)
{
return
AddonManagerInternal
.
getAddonsByIDs
(
aIDs
)
;
}
getAddonsByTypes
(
aTypes
)
{
return
AddonManagerInternal
.
getAddonsByTypes
(
aTypes
)
;
}
getActiveAddons
(
aTypes
)
{
return
AddonManagerInternal
.
getActiveAddons
(
aTypes
)
;
}
getAllAddons
(
)
{
return
AddonManagerInternal
.
getAllAddons
(
)
;
}
getInstallsByTypes
(
aTypes
)
{
return
AddonManagerInternal
.
getInstallsByTypes
(
aTypes
)
;
}
getAllInstalls
(
)
{
return
AddonManagerInternal
.
getAllInstalls
(
)
;
}
isInstallEnabled
(
aType
)
{
return
AddonManagerInternal
.
isInstallEnabled
(
aType
)
;
}
isInstallAllowed
(
aType
aInstallingPrincipal
)
{
return
AddonManagerInternal
.
isInstallAllowed
(
aType
aInstallingPrincipal
)
;
}
installAddonFromWebpage
(
aType
aBrowser
aInstallingPrincipal
aInstall
details
)
{
AddonManagerInternal
.
installAddonFromWebpage
(
aType
aBrowser
aInstallingPrincipal
aInstall
details
)
;
}
installAddonFromAOM
(
aBrowser
aUri
aInstall
)
{
AddonManagerInternal
.
installAddonFromAOM
(
aBrowser
aUri
aInstall
)
;
}
installTemporaryAddon
(
aDirectory
)
{
return
AddonManagerInternal
.
installTemporaryAddon
(
aDirectory
)
;
}
installBuiltinAddon
(
aBase
)
{
return
AddonManagerInternal
.
installBuiltinAddon
(
aBase
)
;
}
maybeInstallBuiltinAddon
(
aID
aVersion
aBase
)
{
return
AddonManagerInternal
.
maybeInstallBuiltinAddon
(
aID
aVersion
aBase
)
;
}
addManagerListener
(
aListener
)
{
AddonManagerInternal
.
addManagerListener
(
aListener
)
;
}
removeManagerListener
(
aListener
)
{
AddonManagerInternal
.
removeManagerListener
(
aListener
)
;
}
addInstallListener
(
aListener
)
{
AddonManagerInternal
.
addInstallListener
(
aListener
)
;
}
removeInstallListener
(
aListener
)
{
AddonManagerInternal
.
removeInstallListener
(
aListener
)
;
}
getUpgradeListener
(
aId
)
{
return
AddonManagerInternal
.
upgradeListeners
.
get
(
aId
)
;
}
addUpgradeListener
(
aInstanceID
aCallback
)
{
AddonManagerInternal
.
addUpgradeListener
(
aInstanceID
aCallback
)
;
}
removeUpgradeListener
(
aInstanceID
)
{
return
AddonManagerInternal
.
removeUpgradeListener
(
aInstanceID
)
;
}
addExternalExtensionLoader
(
loader
)
{
return
AddonManagerInternal
.
addExternalExtensionLoader
(
loader
)
;
}
addAddonListener
(
aListener
)
{
AddonManagerInternal
.
addAddonListener
(
aListener
)
;
}
removeAddonListener
(
aListener
)
{
AddonManagerInternal
.
removeAddonListener
(
aListener
)
;
}
hasAddonType
(
addonType
)
{
return
AddonManagerInternal
.
hasAddonType
(
addonType
)
;
}
hasProvider
(
name
)
{
if
(
!
gStarted
)
{
throw
Components
.
Exception
(
"
AddonManager
is
not
initialized
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
return
!
!
AddonManagerInternal
.
_getProviderByName
(
name
)
;
}
shouldAutoUpdate
(
aAddon
)
{
if
(
!
aAddon
|
|
typeof
aAddon
!
=
"
object
"
)
{
throw
Components
.
Exception
(
"
aAddon
must
be
specified
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
(
"
applyBackgroundUpdates
"
in
aAddon
)
)
{
return
false
;
}
if
(
!
(
aAddon
.
permissions
&
AddonManager
.
PERM_CAN_UPGRADE
)
)
{
return
false
;
}
if
(
aAddon
.
applyBackgroundUpdates
=
=
AddonManager
.
AUTOUPDATE_ENABLE
)
{
return
true
;
}
if
(
aAddon
.
applyBackgroundUpdates
=
=
AddonManager
.
AUTOUPDATE_DISABLE
)
{
return
false
;
}
return
this
.
autoUpdateDefault
;
}
get
checkCompatibility
(
)
{
return
AddonManagerInternal
.
checkCompatibility
;
}
set
checkCompatibility
(
aValue
)
{
AddonManagerInternal
.
checkCompatibility
=
aValue
;
}
get
strictCompatibility
(
)
{
return
AddonManagerInternal
.
strictCompatibility
;
}
set
strictCompatibility
(
aValue
)
{
AddonManagerInternal
.
strictCompatibility
=
aValue
;
}
get
checkUpdateSecurityDefault
(
)
{
return
AddonManagerInternal
.
checkUpdateSecurityDefault
;
}
get
checkUpdateSecurity
(
)
{
return
AddonManagerInternal
.
checkUpdateSecurity
;
}
set
checkUpdateSecurity
(
aValue
)
{
AddonManagerInternal
.
checkUpdateSecurity
=
aValue
;
}
get
updateEnabled
(
)
{
return
AddonManagerInternal
.
updateEnabled
;
}
set
updateEnabled
(
aValue
)
{
AddonManagerInternal
.
updateEnabled
=
aValue
;
}
get
autoUpdateDefault
(
)
{
return
AddonManagerInternal
.
autoUpdateDefault
;
}
set
autoUpdateDefault
(
aValue
)
{
AddonManagerInternal
.
autoUpdateDefault
=
aValue
;
}
escapeAddonURI
(
aAddon
aUri
aAppVersion
)
{
return
AddonManagerInternal
.
escapeAddonURI
(
aAddon
aUri
aAppVersion
)
;
}
getPreferredIconURL
(
aAddon
aSize
aWindow
=
undefined
)
{
return
AddonManagerInternal
.
getPreferredIconURL
(
aAddon
aSize
aWindow
)
;
}
get
webAPI
(
)
{
return
AddonManagerInternal
.
webAPI
;
}
get
beforeShutdown
(
)
{
return
gBeforeShutdownBarrier
.
client
;
}
}
;
AMRemoteSettings
=
{
RS_COLLECTION
:
"
addons
-
manager
-
settings
"
RS_ENTRIES_MAP
:
{
installTriggerDeprecation
:
[
"
extensions
.
InstallTriggerImpl
.
enabled
"
"
extensions
.
InstallTrigger
.
enabled
"
]
}
client
:
null
onSync
:
null
promiseStartup
:
null
init
(
)
{
try
{
if
(
!
this
.
promiseStartup
)
{
this
.
promiseStartup
=
new
Promise
(
resolve
=
>
{
function
observer
(
)
{
resolve
(
)
;
Services
.
obs
.
removeObserver
(
observer
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
Services
.
obs
.
addObserver
(
observer
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
PREF_REMOTESETTINGS_DISABLED
false
)
)
{
return
;
}
if
(
!
this
.
client
)
{
this
.
client
=
lazy
.
RemoteSettings
(
this
.
RS_COLLECTION
)
;
this
.
onSync
=
this
.
processEntries
.
bind
(
this
)
;
this
.
client
.
on
(
"
sync
"
this
.
onSync
)
;
this
.
promiseStartup
.
then
(
(
)
=
>
this
.
processEntries
(
)
)
;
}
}
catch
(
err
)
{
logger
.
error
(
"
Failure
to
initialize
AddonManager
RemoteSettings
"
err
)
;
}
}
shutdown
(
)
{
try
{
if
(
this
.
client
)
{
this
.
client
.
off
(
"
sync
"
this
.
onSync
)
;
this
.
client
=
null
;
this
.
onSync
=
null
;
}
this
.
promiseStartup
=
null
;
}
catch
(
err
)
{
logger
.
error
(
"
Failure
on
shutdown
AddonManager
RemoteSettings
"
err
)
;
}
}
async
processEntries
(
)
{
const
entries
=
await
this
.
client
.
get
(
{
syncIfEmpty
:
false
}
)
.
catch
(
err
=
>
{
logger
.
error
(
"
Failure
to
process
AddonManager
RemoteSettings
"
err
)
;
return
[
]
;
}
)
;
for
(
const
entry
of
entries
)
{
logger
.
debug
(
Processing
AddonManager
RemoteSettings
"
{
entry
.
id
}
"
)
;
for
(
const
[
groupName
prefs
]
of
Object
.
entries
(
this
.
RS_ENTRIES_MAP
)
)
{
const
data
=
entry
[
groupName
]
;
if
(
!
data
)
{
continue
;
}
for
(
const
pref
of
prefs
)
{
if
(
!
(
pref
in
data
)
)
{
continue
;
}
try
{
if
(
typeof
data
[
pref
]
=
=
"
boolean
"
)
{
logger
.
debug
(
Process
AddonManager
RemoteSettings
"
{
entry
.
id
}
"
-
"
{
groupName
}
"
:
{
pref
}
=
{
data
[
pref
]
}
)
;
Services
.
prefs
.
setBoolPref
(
pref
data
[
pref
]
)
;
}
}
catch
(
e
)
{
logger
.
error
(
Failed
to
process
AddonManager
RemoteSettings
"
{
entry
.
id
}
"
-
"
{
groupName
}
"
:
{
pref
}
e
)
;
}
}
}
}
}
}
;
AMTelemetry
=
{
telemetrySetupDone
:
false
init
(
)
{
Services
.
telemetry
.
setEventRecordingEnabled
(
"
addonsManager
"
true
)
;
}
onStartup
(
)
{
if
(
this
.
telemetrySetupDone
)
{
return
;
}
this
.
telemetrySetupDone
=
true
;
Services
.
obs
.
addObserver
(
this
"
addon
-
install
-
origin
-
blocked
"
)
;
Services
.
obs
.
addObserver
(
this
"
addon
-
install
-
disabled
"
)
;
Services
.
obs
.
addObserver
(
this
"
addon
-
install
-
blocked
"
)
;
AddonManager
.
addInstallListener
(
this
)
;
AddonManager
.
addAddonListener
(
this
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
addon
-
install
-
blocked
"
:
{
const
{
installs
}
=
subject
.
wrappedJSObject
;
this
.
recordInstallEvent
(
installs
[
0
]
{
step
:
"
site_warning
"
}
)
;
break
;
}
case
"
addon
-
install
-
origin
-
blocked
"
:
{
const
{
installs
}
=
subject
.
wrappedJSObject
;
this
.
recordInstallEvent
(
installs
[
0
]
{
step
:
"
site_blocked
"
}
)
;
break
;
}
case
"
addon
-
install
-
disabled
"
:
{
const
{
installs
}
=
subject
.
wrappedJSObject
;
this
.
recordInstallEvent
(
installs
[
0
]
{
step
:
"
install_disabled_warning
"
}
)
;
break
;
}
}
}
onNewInstall
(
install
)
{
this
.
recordInstallEvent
(
install
{
step
:
"
started
"
}
)
;
}
onInstallCancelled
(
install
)
{
this
.
recordInstallEvent
(
install
{
step
:
"
cancelled
"
}
)
;
}
onInstallPostponed
(
install
)
{
this
.
recordInstallEvent
(
install
{
step
:
"
postponed
"
}
)
;
}
onInstallFailed
(
install
)
{
this
.
recordInstallEvent
(
install
{
step
:
"
failed
"
}
)
;
}
onInstallEnded
(
install
)
{
this
.
recordInstallEvent
(
install
{
step
:
"
completed
"
}
)
;
if
(
!
install
.
existingAddon
)
{
this
.
recordInstallStatsEvent
(
install
)
;
}
}
onDownloadStarted
(
install
)
{
this
.
recordInstallEvent
(
install
{
step
:
"
download_started
"
}
)
;
}
onDownloadCancelled
(
install
)
{
this
.
recordInstallEvent
(
install
{
step
:
"
cancelled
"
}
)
;
}
onDownloadEnded
(
install
)
{
let
download_time
=
Math
.
round
(
Cu
.
now
(
)
-
install
.
downloadStartedAt
)
;
this
.
recordInstallEvent
(
install
{
step
:
"
download_completed
"
download_time
}
)
;
}
onDownloadFailed
(
install
)
{
let
download_time
=
Math
.
round
(
Cu
.
now
(
)
-
install
.
downloadStartedAt
)
;
this
.
recordInstallEvent
(
install
{
step
:
"
download_failed
"
download_time
}
)
;
}
onUninstalled
(
addon
)
{
this
.
recordManageEvent
(
addon
"
uninstall
"
)
;
}
onEnabled
(
addon
)
{
this
.
recordManageEvent
(
addon
"
enable
"
)
;
}
onDisabled
(
addon
)
{
this
.
recordManageEvent
(
addon
"
disable
"
)
;
}
getTrimmedString
(
str
)
{
if
(
str
.
length
<
=
80
)
{
return
str
;
}
const
length
=
str
.
length
;
return
{
str
.
slice
(
0
40
)
}
.
.
.
{
str
.
slice
(
length
-
37
length
)
}
;
}
getAddonIdFromInstall
(
install
)
{
if
(
install
.
addon
)
{
return
install
.
addon
.
id
;
}
if
(
install
.
existingAddon
)
{
return
install
.
existingAddon
.
id
;
}
return
null
;
}
getEventObjectFromInstall
(
install
)
{
let
addonType
;
if
(
install
.
type
)
{
addonType
=
install
.
type
;
}
else
if
(
install
.
addon
)
{
addonType
=
install
.
addon
.
type
;
}
else
if
(
install
.
existingAddon
)
{
addonType
=
install
.
existingAddon
.
type
;
}
return
this
.
getEventObjectFromAddonType
(
addonType
)
;
}
getInstallTelemetryInfo
(
install
)
{
if
(
install
.
installTelemetryInfo
)
{
return
install
.
installTelemetryInfo
;
}
else
if
(
install
.
existingAddon
&
&
install
.
existingAddon
.
installTelemetryInfo
)
{
return
install
.
existingAddon
.
installTelemetryInfo
;
}
return
null
;
}
getEventObjectFromAddonType
(
addonType
)
{
switch
(
addonType
)
{
case
undefined
:
return
"
unknown
"
;
case
"
extension
"
:
case
"
theme
"
:
case
"
locale
"
:
case
"
dictionary
"
:
case
"
sitepermission
"
:
return
addonType
;
default
:
return
"
other
"
;
}
}
convertToString
(
value
)
{
if
(
value
=
=
null
)
{
return
"
"
;
}
switch
(
typeof
value
)
{
case
"
string
"
:
return
value
;
case
"
boolean
"
:
return
value
?
"
1
"
:
"
0
"
;
}
return
String
(
value
)
;
}
parseAttributionDataForAMO
(
sourceURL
)
{
let
searchParams
;
try
{
searchParams
=
new
URL
(
sourceURL
)
.
searchParams
;
}
catch
{
return
{
}
;
}
const
utmKeys
=
[
.
.
.
searchParams
.
keys
(
)
]
.
filter
(
key
=
>
AMO_ATTRIBUTION_DATA_KEYS
.
includes
(
key
)
)
;
return
utmKeys
.
reduce
(
(
params
key
)
=
>
{
let
value
=
searchParams
.
get
(
key
)
;
if
(
typeof
value
=
=
=
"
string
"
)
{
value
=
value
.
slice
(
0
AMO_ATTRIBUTION_DATA_MAX_LENGTH
)
;
}
return
{
.
.
.
params
[
key
]
:
value
}
;
}
{
}
)
;
}
recordInstallStatsEvent
(
install
)
{
const
telemetryInfo
=
this
.
getInstallTelemetryInfo
(
install
)
;
if
(
!
AMO_ATTRIBUTION_ALLOWED_SOURCES
.
includes
(
telemetryInfo
?
.
source
)
)
{
return
;
}
const
method
=
"
install_stats
"
;
const
object
=
this
.
getEventObjectFromInstall
(
install
)
;
const
addonId
=
this
.
getAddonIdFromInstall
(
install
)
;
if
(
!
addonId
)
{
Cu
.
reportError
(
"
Missing
addonId
when
trying
to
record
an
install_stats
event
"
)
;
return
;
}
let
extra
=
{
addon_id
:
this
.
getTrimmedString
(
addonId
)
}
;
if
(
telemetryInfo
?
.
source
=
=
=
"
amo
"
&
&
typeof
telemetryInfo
?
.
sourceURL
=
=
=
"
string
"
)
{
extra
=
{
.
.
.
extra
.
.
.
this
.
parseAttributionDataForAMO
(
telemetryInfo
.
sourceURL
)
}
;
}
if
(
telemetryInfo
?
.
source
=
=
=
"
disco
"
&
&
typeof
telemetryInfo
?
.
taarRecommended
=
=
=
"
boolean
"
)
{
extra
=
{
.
.
.
extra
taar_based
:
this
.
convertToString
(
telemetryInfo
.
taarRecommended
)
}
;
}
this
.
recordEvent
(
{
method
object
value
:
install
.
hashedAddonId
extra
}
)
;
}
formatExtraVars
(
{
addon
.
.
.
extraVars
}
)
{
if
(
addon
)
{
extraVars
.
addonId
=
addon
.
id
;
extraVars
.
type
=
addon
.
type
;
}
for
(
var
[
key
value
]
of
Object
.
entries
(
extraVars
)
)
{
if
(
value
=
=
undefined
)
{
delete
extraVars
[
key
]
;
}
else
{
extraVars
[
key
]
=
this
.
convertToString
(
value
)
;
}
}
if
(
extraVars
.
addonId
)
{
extraVars
.
addonId
=
this
.
getTrimmedString
(
extraVars
.
addonId
)
;
}
return
extraVars
;
}
recordInstallEvent
(
install
extraVars
)
{
if
(
!
this
.
telemetrySetupDone
)
{
return
;
}
let
extra
=
{
}
;
let
telemetryInfo
=
this
.
getInstallTelemetryInfo
(
install
)
;
if
(
telemetryInfo
&
&
typeof
telemetryInfo
.
source
=
=
=
"
string
"
)
{
extra
.
source
=
telemetryInfo
.
source
;
}
if
(
extra
.
source
=
=
=
"
internal
"
)
{
return
;
}
if
(
telemetryInfo
&
&
typeof
telemetryInfo
.
method
=
=
=
"
string
"
)
{
extra
.
method
=
telemetryInfo
.
method
;
}
let
addonId
=
this
.
getAddonIdFromInstall
(
install
)
;
let
object
=
this
.
getEventObjectFromInstall
(
install
)
;
let
installId
=
String
(
install
.
installId
)
;
let
eventMethod
=
install
.
existingAddon
?
"
update
"
:
"
install
"
;
if
(
addonId
)
{
extra
.
addon_id
=
this
.
getTrimmedString
(
addonId
)
;
}
if
(
install
.
error
)
{
extra
.
error
=
AddonManager
.
errorToString
(
install
.
error
)
;
}
if
(
eventMethod
=
=
=
"
install
"
&
&
Services
.
prefs
.
getBoolPref
(
"
extensions
.
install_origins
.
enabled
"
true
)
)
{
extra
.
install_origins
=
Array
.
isArray
(
install
.
addon
?
.
installOrigins
)
;
}
if
(
eventMethod
=
=
=
"
update
"
)
{
extra
.
updated_from
=
install
.
isUserRequestedUpdate
?
"
user
"
:
"
app
"
;
}
extra
=
this
.
formatExtraVars
(
{
.
.
.
extraVars
.
.
.
extra
}
)
;
this
.
recordEvent
(
{
method
:
eventMethod
object
value
:
installId
extra
}
)
;
}
recordManageEvent
(
addon
method
extraVars
)
{
if
(
!
this
.
telemetrySetupDone
)
{
return
;
}
let
extra
=
{
}
;
if
(
addon
.
installTelemetryInfo
)
{
if
(
"
source
"
in
addon
.
installTelemetryInfo
)
{
extra
.
source
=
addon
.
installTelemetryInfo
.
source
;
}
if
(
"
method
"
in
addon
.
installTelemetryInfo
)
{
extra
.
method
=
addon
.
installTelemetryInfo
.
method
;
}
}
if
(
extra
.
source
=
=
=
"
internal
"
)
{
return
;
}
let
object
=
this
.
getEventObjectFromAddonType
(
addon
.
type
)
;
let
value
=
this
.
getTrimmedString
(
addon
.
id
)
;
extra
=
{
.
.
.
extraVars
.
.
.
extra
}
;
let
hasExtraVars
=
!
!
Object
.
keys
(
extra
)
.
length
;
extra
=
this
.
formatExtraVars
(
extra
)
;
this
.
recordEvent
(
{
method
object
value
extra
:
hasExtraVars
?
extra
:
null
}
)
;
}
recordLinkEvent
(
{
object
value
extra
=
null
}
)
{
this
.
recordEvent
(
{
method
:
"
link
"
object
value
extra
}
)
;
}
recordActionEvent
(
{
object
action
value
addon
view
extra
}
)
{
extra
=
{
.
.
.
extra
action
addon
view
}
;
if
(
action
=
=
=
"
installFromRecommendation
"
)
{
extra
.
taar_based
=
!
!
addon
.
taarRecommended
;
}
this
.
recordEvent
(
{
method
:
"
action
"
object
value
:
value
=
=
null
?
null
:
this
.
convertToString
(
value
)
extra
:
this
.
formatExtraVars
(
extra
)
}
)
;
}
recordViewEvent
(
{
view
addon
type
taarEnabled
}
)
{
this
.
recordEvent
(
{
method
:
"
view
"
object
:
"
aboutAddons
"
value
:
view
extra
:
this
.
formatExtraVars
(
{
type
addon
taar_enabled
:
taarEnabled
}
)
}
)
;
}
recordReportEvent
(
{
addonId
addonType
errorType
reportEntryPoint
}
)
{
this
.
recordEvent
(
{
method
:
"
report
"
object
:
reportEntryPoint
value
:
addonId
extra
:
this
.
formatExtraVars
(
{
addon_type
:
addonType
error_type
:
errorType
}
)
}
)
;
}
recordEvent
(
{
method
object
value
extra
}
)
{
if
(
typeof
value
!
=
"
string
"
)
{
value
=
null
;
}
try
{
Services
.
telemetry
.
recordEvent
(
"
addonsManager
"
method
object
value
extra
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
}
;
AddonManager
.
init
(
)
;
AddonManager
.
addManagerListener
(
AMTelemetry
)
;
Object
.
freeze
(
AddonManagerInternal
)
;
Object
.
freeze
(
AddonManagerPrivate
)
;
Object
.
freeze
(
AddonManager
)
;
