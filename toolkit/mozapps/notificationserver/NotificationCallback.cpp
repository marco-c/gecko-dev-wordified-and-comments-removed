#
include
"
EventLog
.
h
"
#
include
"
NotificationCallback
.
h
"
#
include
<
sstream
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
mozilla
/
CmdLineAndEnvUtils
.
h
"
#
define
NOTIFICATION_SERVER_EVENT_TIMEOUT_MS
(
10
*
1000
)
HRESULT
STDMETHODCALLTYPE
NotificationCallback
:
:
QueryInterface
(
REFIID
riid
void
*
*
ppvObject
)
{
if
(
!
ppvObject
)
{
return
E_POINTER
;
}
*
ppvObject
=
nullptr
;
if
(
!
(
riid
=
=
guid
|
|
riid
=
=
__uuidof
(
INotificationActivationCallback
)
|
|
riid
=
=
__uuidof
(
IUnknown
)
)
)
{
return
E_NOINTERFACE
;
}
AddRef
(
)
;
*
ppvObject
=
reinterpret_cast
<
void
*
>
(
this
)
;
return
S_OK
;
}
HRESULT
STDMETHODCALLTYPE
NotificationCallback
:
:
Activate
(
LPCWSTR
appUserModelId
LPCWSTR
invokedArgs
const
NOTIFICATION_USER_INPUT_DATA
*
data
ULONG
dataCount
)
{
HandleActivation
(
invokedArgs
)
;
return
S_OK
;
}
void
NotificationCallback
:
:
HandleActivation
(
LPCWSTR
invokedArgs
)
{
LOG_ERROR_MESSAGE
(
L
"
Invoked
with
arguments
:
'
%
s
'
"
invokedArgs
)
;
auto
maybeArgs
=
ParseToastArguments
(
invokedArgs
)
;
if
(
!
maybeArgs
)
{
LOG_ERROR_MESSAGE
(
L
"
COM
server
disabled
for
toast
"
)
;
return
;
}
const
auto
&
args
=
maybeArgs
.
value
(
)
;
auto
[
programPath
cmdLine
]
=
BuildRunCommand
(
args
)
;
std
:
:
wstring
eventName
(
args
.
windowsTag
)
;
nsAutoHandle
event
;
if
(
!
eventName
.
empty
(
)
)
{
event
.
own
(
CreateEventW
(
nullptr
TRUE
FALSE
eventName
.
c_str
(
)
)
)
;
}
STARTUPINFOW
si
=
{
}
;
si
.
cb
=
sizeof
(
STARTUPINFOW
)
;
PROCESS_INFORMATION
pi
=
{
}
;
CreateProcessW
(
programPath
.
c_str
(
)
cmdLine
.
get
(
)
nullptr
nullptr
false
DETACHED_PROCESS
|
NORMAL_PRIORITY_CLASS
nullptr
nullptr
&
si
&
pi
)
;
LOG_ERROR_MESSAGE
(
L
"
Invoked
%
s
"
cmdLine
.
get
(
)
)
;
if
(
event
.
get
(
)
)
{
LOG_ERROR_MESSAGE
(
(
L
"
Waiting
on
event
with
name
'
%
s
'
"
)
eventName
.
c_str
(
)
)
;
DWORD
result
=
WaitForSingleObject
(
event
NOTIFICATION_SERVER_EVENT_TIMEOUT_MS
)
;
if
(
result
=
=
WAIT_TIMEOUT
)
{
LOG_ERROR_MESSAGE
(
L
"
Wait
timed
out
"
)
;
}
else
if
(
result
=
=
WAIT_FAILED
)
{
LOG_ERROR_MESSAGE
(
(
L
"
Wait
failed
:
%
#
X
"
)
GetLastError
(
)
)
;
}
else
if
(
result
=
=
WAIT_ABANDONED
)
{
LOG_ERROR_MESSAGE
(
(
L
"
Wait
abandoned
"
)
)
;
}
else
{
LOG_ERROR_MESSAGE
(
(
L
"
Wait
succeeded
!
"
)
)
;
}
}
else
{
LOG_ERROR_MESSAGE
(
(
L
"
Failed
to
create
event
with
name
'
%
s
'
"
)
eventName
.
c_str
(
)
)
;
}
}
mozilla
:
:
Maybe
<
ToastArgs
>
NotificationCallback
:
:
ParseToastArguments
(
LPCWSTR
invokedArgs
)
{
ToastArgs
parsedArgs
;
std
:
:
wistringstream
args
(
invokedArgs
)
;
bool
serverDisabled
=
true
;
for
(
std
:
:
wstring
key
value
;
std
:
:
getline
(
args
key
)
&
&
std
:
:
getline
(
args
value
)
;
)
{
if
(
key
=
=
L
"
program
"
)
{
serverDisabled
=
false
;
}
else
if
(
key
=
=
L
"
profile
"
)
{
parsedArgs
.
profile
=
value
;
}
else
if
(
key
=
=
L
"
windowsTag
"
)
{
parsedArgs
.
windowsTag
=
value
;
}
else
if
(
key
=
=
L
"
action
"
)
{
break
;
}
}
if
(
serverDisabled
)
{
return
mozilla
:
:
Nothing
(
)
;
}
return
mozilla
:
:
Some
(
parsedArgs
)
;
}
std
:
:
tuple
<
path
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
>
NotificationCallback
:
:
BuildRunCommand
(
const
ToastArgs
&
args
)
{
path
programPath
=
installDir
/
L
"
"
MOZ_APP_NAME
;
programPath
+
=
L
"
.
exe
"
;
std
:
:
vector
<
const
wchar_t
*
>
childArgv
;
childArgv
.
push_back
(
programPath
.
c_str
(
)
)
;
if
(
!
args
.
profile
.
empty
(
)
)
{
childArgv
.
push_back
(
L
"
-
-
profile
"
)
;
childArgv
.
push_back
(
args
.
profile
.
c_str
(
)
)
;
}
else
{
LOG_ERROR_MESSAGE
(
L
"
No
profile
;
invocation
will
choose
default
profile
"
)
;
}
if
(
!
args
.
windowsTag
.
empty
(
)
)
{
childArgv
.
push_back
(
L
"
-
-
notification
-
windowsTag
"
)
;
childArgv
.
push_back
(
args
.
windowsTag
.
c_str
(
)
)
;
}
else
{
LOG_ERROR_MESSAGE
(
L
"
No
windowsTag
;
invoking
anyway
"
)
;
}
return
{
programPath
mozilla
:
:
MakeCommandLine
(
childArgv
.
size
(
)
childArgv
.
data
(
)
)
}
;
}
