var
FontBuilder
=
{
_enumerator
:
null
get
enumerator
(
)
{
if
(
!
this
.
_enumerator
)
{
this
.
_enumerator
=
Components
.
classes
[
"
mozilla
.
org
/
gfx
/
fontenumerator
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIFontEnumerator
)
;
}
return
this
.
_enumerator
;
}
_allFonts
:
null
_langGroupSupported
:
false
async
buildFontList
(
aLanguage
aFontType
aMenuList
)
{
while
(
aMenuList
.
hasChildNodes
(
)
)
aMenuList
.
firstChild
.
remove
(
)
;
let
defaultFont
=
null
;
let
fonts
=
await
this
.
enumerator
.
EnumerateFontsAsync
(
aLanguage
aFontType
)
;
if
(
fonts
.
length
>
0
)
defaultFont
=
this
.
enumerator
.
getDefaultFont
(
aLanguage
aFontType
)
;
else
{
fonts
=
await
this
.
enumerator
.
EnumerateFontsAsync
(
aLanguage
"
"
)
;
if
(
fonts
.
length
>
0
)
defaultFont
=
this
.
enumerator
.
getDefaultFont
(
aLanguage
"
"
)
;
}
if
(
!
this
.
_allFonts
)
this
.
_allFonts
=
await
this
.
enumerator
.
EnumerateAllFontsAsync
(
{
}
)
;
const
popup
=
document
.
createElement
(
"
menupopup
"
)
;
let
separator
;
if
(
fonts
.
length
>
0
)
{
const
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
defaultLabel
=
defaultFont
?
bundlePreferences
.
getFormattedString
(
"
labelDefaultFont
"
[
defaultFont
]
)
:
bundlePreferences
.
getString
(
"
labelDefaultFontUnnamed
"
)
;
let
menuitem
=
document
.
createElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
label
"
defaultLabel
)
;
menuitem
.
setAttribute
(
"
value
"
"
"
)
;
popup
.
appendChild
(
menuitem
)
;
separator
=
document
.
createElement
(
"
menuseparator
"
)
;
popup
.
appendChild
(
separator
)
;
for
(
let
font
of
fonts
)
{
menuitem
=
document
.
createElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
value
"
font
)
;
menuitem
.
setAttribute
(
"
label
"
font
)
;
popup
.
appendChild
(
menuitem
)
;
}
}
if
(
this
.
_allFonts
.
length
>
fonts
.
length
)
{
this
.
_langGroupSupported
=
true
;
let
builtItem
=
separator
?
separator
.
nextSibling
:
popup
.
firstChild
;
let
builtItemValue
=
builtItem
?
builtItem
.
getAttribute
(
"
value
"
)
:
null
;
separator
=
document
.
createElement
(
"
menuseparator
"
)
;
popup
.
appendChild
(
separator
)
;
for
(
let
font
of
this
.
_allFonts
)
{
if
(
font
!
=
builtItemValue
)
{
const
menuitem
=
document
.
createElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
value
"
font
)
;
menuitem
.
setAttribute
(
"
label
"
font
)
;
popup
.
appendChild
(
menuitem
)
;
}
else
{
builtItem
=
builtItem
.
nextSibling
;
builtItemValue
=
builtItem
?
builtItem
.
getAttribute
(
"
value
"
)
:
null
;
}
}
}
aMenuList
.
appendChild
(
popup
)
;
}
readFontSelection
(
aElement
)
{
const
preference
=
document
.
getElementById
(
aElement
.
getAttribute
(
"
preference
"
)
)
;
if
(
preference
.
value
)
{
const
fontItems
=
aElement
.
getElementsByAttribute
(
"
value
"
preference
.
value
)
;
if
(
fontItems
.
length
)
return
undefined
;
}
return
"
"
;
}
}
;
