#
include
"
ScheduledTask
.
h
"
#
include
<
string
>
#
include
<
time
.
h
>
#
include
<
comutil
.
h
>
#
include
<
taskschd
.
h
>
#
include
"
readstrings
.
h
"
#
include
"
updatererrors
.
h
"
#
include
"
EventLog
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
WindowsDefaultBrowser
.
h
"
#
include
"
DefaultBrowser
.
h
"
namespace
mozilla
:
:
default_agent
{
const
wchar_t
*
kTaskVendor
=
L
"
"
MOZ_APP_VENDOR
;
const
wchar_t
*
kTaskName
=
L
"
"
MOZ_APP_DISPLAYNAME
"
Default
Browser
Agent
"
;
const
wchar_t
*
kTimeFormat
=
L
"
%
Y
-
%
m
-
%
dT
%
H
:
%
M
:
%
SZ
"
;
const
size_t
kTimeStrMaxLen
=
20
;
#
define
ENSURE
(
x
)
\
if
(
FAILED
(
hr
=
(
x
)
)
)
{
\
LOG_ERROR
(
hr
)
;
\
return
hr
;
\
}
struct
SysFreeStringDeleter
{
void
operator
(
)
(
BSTR
aPtr
)
{
:
:
SysFreeString
(
aPtr
)
;
}
}
;
using
BStrPtr
=
mozilla
:
:
UniquePtr
<
OLECHAR
SysFreeStringDeleter
>
;
bool
GetTaskDescription
(
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
description
)
{
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
installPath
;
bool
success
=
GetInstallDirectory
(
installPath
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
get
install
directory
"
)
;
return
false
;
}
const
wchar_t
*
iniFormat
=
L
"
%
s
\
\
defaultagent_localized
.
ini
"
;
int
bufferSize
=
_scwprintf
(
iniFormat
installPath
.
get
(
)
)
;
+
+
bufferSize
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
iniPath
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
bufferSize
)
;
_snwprintf_s
(
iniPath
.
get
(
)
bufferSize
_TRUNCATE
iniFormat
installPath
.
get
(
)
)
;
IniReader
reader
(
iniPath
.
get
(
)
)
;
reader
.
AddKey
(
"
DefaultBrowserAgentTaskDescription
"
&
description
)
;
int
status
=
reader
.
Read
(
)
;
if
(
status
!
=
OK
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
read
task
description
:
%
d
"
status
)
;
return
false
;
}
return
true
;
}
HRESULT
RegisterTask
(
const
wchar_t
*
uniqueToken
BSTR
startTime
)
{
MaybeMigrateCurrentDefault
(
)
;
RemoveTasks
(
uniqueToken
WhichTasks
:
:
WdbaTaskOnly
)
;
bool
createdFolder
=
false
;
HRESULT
hr
=
S_OK
;
RefPtr
<
ITaskService
>
scheduler
;
ENSURE
(
CoCreateInstance
(
CLSID_TaskScheduler
nullptr
CLSCTX_INPROC_SERVER
IID_ITaskService
getter_AddRefs
(
scheduler
)
)
)
;
ENSURE
(
scheduler
-
>
Connect
(
VARIANT
{
}
VARIANT
{
}
VARIANT
{
}
VARIANT
{
}
)
)
;
RefPtr
<
ITaskFolder
>
rootFolder
;
BStrPtr
rootFolderBStr
=
BStrPtr
(
SysAllocString
(
L
"
\
\
"
)
)
;
ENSURE
(
scheduler
-
>
GetFolder
(
rootFolderBStr
.
get
(
)
getter_AddRefs
(
rootFolder
)
)
)
;
RefPtr
<
ITaskFolder
>
taskFolder
;
BStrPtr
vendorBStr
=
BStrPtr
(
SysAllocString
(
kTaskVendor
)
)
;
if
(
FAILED
(
rootFolder
-
>
GetFolder
(
vendorBStr
.
get
(
)
getter_AddRefs
(
taskFolder
)
)
)
)
{
hr
=
rootFolder
-
>
CreateFolder
(
vendorBStr
.
get
(
)
VARIANT
{
}
getter_AddRefs
(
taskFolder
)
)
;
if
(
SUCCEEDED
(
hr
)
)
{
createdFolder
=
true
;
}
else
if
(
hr
!
=
HRESULT_FROM_WIN32
(
ERROR_ALREADY_EXISTS
)
)
{
LOG_ERROR
(
hr
)
;
return
hr
;
}
}
auto
cleanupFolder
=
mozilla
:
:
MakeScopeExit
(
[
hr
createdFolder
&
rootFolder
&
vendorBStr
]
{
if
(
createdFolder
&
&
FAILED
(
hr
)
)
{
rootFolder
-
>
DeleteFolder
(
vendorBStr
.
get
(
)
0
)
;
}
}
)
;
RefPtr
<
ITaskDefinition
>
newTask
;
ENSURE
(
scheduler
-
>
NewTask
(
0
getter_AddRefs
(
newTask
)
)
)
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
description
;
if
(
!
GetTaskDescription
(
description
)
)
{
return
E_FAIL
;
}
BStrPtr
descriptionBstr
=
BStrPtr
(
SysAllocString
(
description
.
get
(
)
)
)
;
RefPtr
<
IRegistrationInfo
>
taskRegistration
;
ENSURE
(
newTask
-
>
get_RegistrationInfo
(
getter_AddRefs
(
taskRegistration
)
)
)
;
ENSURE
(
taskRegistration
-
>
put_Description
(
descriptionBstr
.
get
(
)
)
)
;
RefPtr
<
ITaskSettings
>
taskSettings
;
ENSURE
(
newTask
-
>
get_Settings
(
getter_AddRefs
(
taskSettings
)
)
)
;
ENSURE
(
taskSettings
-
>
put_DisallowStartIfOnBatteries
(
VARIANT_FALSE
)
)
;
ENSURE
(
taskSettings
-
>
put_MultipleInstances
(
TASK_INSTANCES_IGNORE_NEW
)
)
;
ENSURE
(
taskSettings
-
>
put_StartWhenAvailable
(
VARIANT_TRUE
)
)
;
ENSURE
(
taskSettings
-
>
put_StopIfGoingOnBatteries
(
VARIANT_FALSE
)
)
;
BStrPtr
execTimeLimitBStr
=
BStrPtr
(
SysAllocString
(
L
"
PT12H5M
"
)
)
;
ENSURE
(
taskSettings
-
>
put_ExecutionTimeLimit
(
execTimeLimitBStr
.
get
(
)
)
)
;
RefPtr
<
IRegistrationInfo
>
regInfo
;
ENSURE
(
newTask
-
>
get_RegistrationInfo
(
getter_AddRefs
(
regInfo
)
)
)
;
ENSURE
(
regInfo
-
>
put_Author
(
vendorBStr
.
get
(
)
)
)
;
RefPtr
<
ITriggerCollection
>
triggers
;
ENSURE
(
newTask
-
>
get_Triggers
(
getter_AddRefs
(
triggers
)
)
)
;
RefPtr
<
ITrigger
>
newTrigger
;
ENSURE
(
triggers
-
>
Create
(
TASK_TRIGGER_DAILY
getter_AddRefs
(
newTrigger
)
)
)
;
RefPtr
<
IDailyTrigger
>
dailyTrigger
;
ENSURE
(
newTrigger
-
>
QueryInterface
(
IID_IDailyTrigger
getter_AddRefs
(
dailyTrigger
)
)
)
;
if
(
startTime
)
{
ENSURE
(
dailyTrigger
-
>
put_StartBoundary
(
startTime
)
)
;
}
else
{
time_t
now_t
=
time
(
nullptr
)
;
now_t
-
=
60
;
tm
now_tm
;
errno_t
errno_rv
=
gmtime_s
(
&
now_tm
&
now_t
)
;
if
(
errno_rv
!
=
0
)
{
hr
=
HRESULT_FROM_WIN32
(
ERROR_INVALID_TIME
)
;
LOG_ERROR
(
hr
)
;
return
hr
;
}
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
timeStr
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
kTimeStrMaxLen
+
1
)
;
if
(
wcsftime
(
timeStr
.
get
(
)
kTimeStrMaxLen
+
1
kTimeFormat
&
now_tm
)
=
=
0
)
{
hr
=
E_NOT_SUFFICIENT_BUFFER
;
LOG_ERROR
(
hr
)
;
return
hr
;
}
BStrPtr
startTimeBStr
=
BStrPtr
(
SysAllocString
(
timeStr
.
get
(
)
)
)
;
ENSURE
(
dailyTrigger
-
>
put_StartBoundary
(
startTimeBStr
.
get
(
)
)
)
;
}
ENSURE
(
dailyTrigger
-
>
put_DaysInterval
(
1
)
)
;
RefPtr
<
IActionCollection
>
actions
;
ENSURE
(
newTask
-
>
get_Actions
(
getter_AddRefs
(
actions
)
)
)
;
RefPtr
<
IAction
>
action
;
ENSURE
(
actions
-
>
Create
(
TASK_ACTION_EXEC
getter_AddRefs
(
action
)
)
)
;
RefPtr
<
IExecAction
>
execAction
;
ENSURE
(
action
-
>
QueryInterface
(
IID_IExecAction
getter_AddRefs
(
execAction
)
)
)
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
installPath
=
mozilla
:
:
GetFullBinaryPath
(
)
;
if
(
!
PathRemoveFileSpecW
(
installPath
.
get
(
)
)
)
{
return
E_FAIL
;
}
std
:
:
wstring
proxyPath
(
installPath
.
get
(
)
)
;
proxyPath
+
=
L
"
\
\
default
-
browser
-
agent
.
exe
"
;
BStrPtr
binaryPathBStr
=
BStrPtr
(
SysAllocString
(
proxyPath
.
c_str
(
)
)
)
;
ENSURE
(
execAction
-
>
put_Path
(
binaryPathBStr
.
get
(
)
)
)
;
std
:
:
wstring
taskArgs
=
L
"
do
-
task
\
"
"
;
taskArgs
+
=
uniqueToken
;
taskArgs
+
=
L
"
\
"
"
;
BStrPtr
argsBStr
=
BStrPtr
(
SysAllocString
(
taskArgs
.
c_str
(
)
)
)
;
ENSURE
(
execAction
-
>
put_Arguments
(
argsBStr
.
get
(
)
)
)
;
std
:
:
wstring
taskName
(
kTaskName
)
;
taskName
+
=
uniqueToken
;
BStrPtr
taskNameBStr
=
BStrPtr
(
SysAllocString
(
taskName
.
c_str
(
)
)
)
;
RefPtr
<
IRegisteredTask
>
registeredTask
;
ENSURE
(
taskFolder
-
>
RegisterTaskDefinition
(
taskNameBStr
.
get
(
)
newTask
TASK_CREATE_OR_UPDATE
VARIANT
{
}
VARIANT
{
}
TASK_LOGON_INTERACTIVE_TOKEN
VARIANT
{
}
getter_AddRefs
(
registeredTask
)
)
)
;
return
hr
;
}
HRESULT
UpdateTask
(
const
wchar_t
*
uniqueToken
)
{
RefPtr
<
ITaskService
>
scheduler
;
HRESULT
hr
=
S_OK
;
ENSURE
(
CoCreateInstance
(
CLSID_TaskScheduler
nullptr
CLSCTX_INPROC_SERVER
IID_ITaskService
getter_AddRefs
(
scheduler
)
)
)
;
ENSURE
(
scheduler
-
>
Connect
(
VARIANT
{
}
VARIANT
{
}
VARIANT
{
}
VARIANT
{
}
)
)
;
RefPtr
<
ITaskFolder
>
taskFolder
;
BStrPtr
folderBStr
=
BStrPtr
(
SysAllocString
(
kTaskVendor
)
)
;
if
(
FAILED
(
scheduler
-
>
GetFolder
(
folderBStr
.
get
(
)
getter_AddRefs
(
taskFolder
)
)
)
)
{
return
RegisterTask
(
uniqueToken
)
;
}
std
:
:
wstring
taskName
(
kTaskName
)
;
taskName
+
=
uniqueToken
;
BStrPtr
taskNameBStr
=
BStrPtr
(
SysAllocString
(
taskName
.
c_str
(
)
)
)
;
RefPtr
<
IRegisteredTask
>
task
;
if
(
FAILED
(
taskFolder
-
>
GetTask
(
taskNameBStr
.
get
(
)
getter_AddRefs
(
task
)
)
)
)
{
return
RegisterTask
(
uniqueToken
)
;
}
RefPtr
<
ITaskDefinition
>
definition
;
if
(
FAILED
(
task
-
>
get_Definition
(
getter_AddRefs
(
definition
)
)
)
)
{
return
RegisterTask
(
uniqueToken
)
;
}
RefPtr
<
ITriggerCollection
>
triggerList
;
if
(
FAILED
(
definition
-
>
get_Triggers
(
getter_AddRefs
(
triggerList
)
)
)
)
{
return
RegisterTask
(
uniqueToken
)
;
}
RefPtr
<
ITrigger
>
trigger
;
if
(
FAILED
(
triggerList
-
>
get_Item
(
1
getter_AddRefs
(
trigger
)
)
)
)
{
return
RegisterTask
(
uniqueToken
)
;
}
BSTR
startTimeBstr
;
if
(
FAILED
(
trigger
-
>
get_StartBoundary
(
&
startTimeBstr
)
)
)
{
return
RegisterTask
(
uniqueToken
)
;
}
BStrPtr
startTime
(
startTimeBstr
)
;
return
RegisterTask
(
uniqueToken
startTime
.
get
(
)
)
;
}
bool
EndsWith
(
const
wchar_t
*
string
const
wchar_t
*
suffix
)
{
size_t
string_len
=
wcslen
(
string
)
;
size_t
suffix_len
=
wcslen
(
suffix
)
;
if
(
suffix_len
>
string_len
)
{
return
false
;
}
const
wchar_t
*
substring
=
string
+
string_len
-
suffix_len
;
return
wcscmp
(
substring
suffix
)
=
=
0
;
}
HRESULT
RemoveTasks
(
const
wchar_t
*
uniqueToken
WhichTasks
tasksToRemove
)
{
if
(
!
uniqueToken
|
|
wcslen
(
uniqueToken
)
=
=
0
)
{
return
E_INVALIDARG
;
}
RefPtr
<
ITaskService
>
scheduler
;
HRESULT
hr
=
S_OK
;
ENSURE
(
CoCreateInstance
(
CLSID_TaskScheduler
nullptr
CLSCTX_INPROC_SERVER
IID_ITaskService
getter_AddRefs
(
scheduler
)
)
)
;
ENSURE
(
scheduler
-
>
Connect
(
VARIANT
{
}
VARIANT
{
}
VARIANT
{
}
VARIANT
{
}
)
)
;
RefPtr
<
ITaskFolder
>
taskFolder
;
BStrPtr
folderBStr
(
SysAllocString
(
kTaskVendor
)
)
;
hr
=
scheduler
-
>
GetFolder
(
folderBStr
.
get
(
)
getter_AddRefs
(
taskFolder
)
)
;
if
(
FAILED
(
hr
)
)
{
if
(
hr
=
=
HRESULT_FROM_WIN32
(
ERROR_FILE_NOT_FOUND
)
)
{
return
S_OK
;
}
else
{
return
hr
;
}
}
RefPtr
<
IRegisteredTaskCollection
>
tasksInFolder
;
ENSURE
(
taskFolder
-
>
GetTasks
(
TASK_ENUM_HIDDEN
getter_AddRefs
(
tasksInFolder
)
)
)
;
LONG
numTasks
=
0
;
ENSURE
(
tasksInFolder
-
>
get_Count
(
&
numTasks
)
)
;
std
:
:
wstring
WdbaTaskName
(
kTaskName
)
;
WdbaTaskName
+
=
uniqueToken
;
HRESULT
deleteResult
=
S_OK
;
bool
tasksSkipped
=
false
;
for
(
LONG
i
=
0
;
i
<
numTasks
;
+
+
i
)
{
RefPtr
<
IRegisteredTask
>
task
;
hr
=
tasksInFolder
-
>
get_Item
(
_variant_t
(
i
+
1
)
getter_AddRefs
(
task
)
)
;
if
(
FAILED
(
hr
)
)
{
deleteResult
=
hr
;
continue
;
}
BSTR
taskName
;
hr
=
task
-
>
get_Name
(
&
taskName
)
;
if
(
FAILED
(
hr
)
)
{
deleteResult
=
hr
;
continue
;
}
BStrPtr
uniqueTaskName
(
taskName
)
;
if
(
tasksToRemove
=
=
WhichTasks
:
:
WdbaTaskOnly
)
{
if
(
WdbaTaskName
.
compare
(
taskName
)
!
=
0
)
{
tasksSkipped
=
true
;
continue
;
}
}
else
{
if
(
!
EndsWith
(
taskName
uniqueToken
)
)
{
tasksSkipped
=
true
;
continue
;
}
}
hr
=
taskFolder
-
>
DeleteTask
(
taskName
0
)
;
if
(
FAILED
(
hr
)
)
{
deleteResult
=
hr
;
}
}
if
(
!
tasksSkipped
&
&
SUCCEEDED
(
deleteResult
)
)
{
RefPtr
<
ITaskFolder
>
rootFolder
;
BStrPtr
rootFolderBStr
=
BStrPtr
(
SysAllocString
(
L
"
\
\
"
)
)
;
ENSURE
(
scheduler
-
>
GetFolder
(
rootFolderBStr
.
get
(
)
getter_AddRefs
(
rootFolder
)
)
)
;
ENSURE
(
rootFolder
-
>
DeleteFolder
(
folderBStr
.
get
(
)
0
)
)
;
}
return
deleteResult
;
}
}
