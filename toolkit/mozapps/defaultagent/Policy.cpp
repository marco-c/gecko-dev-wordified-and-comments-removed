#
include
"
Policy
.
h
"
#
include
<
windows
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
fstream
>
#
include
"
common
.
h
"
#
include
"
Registry
.
h
"
#
include
"
UtfConvert
.
h
"
#
include
"
json
/
json
.
h
"
#
include
"
mozilla
/
HelperMacros
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
define
AGENT_POLICY_NAME
"
DisableDefaultBrowserAgent
"
#
define
TELEMETRY_POLICY_NAME
"
DisableTelemetry
"
#
define
POLICY_REGKEY_NAME
L
"
SOFTWARE
\
\
Policies
\
\
Mozilla
\
\
"
MOZ_APP_BASENAME
enum
class
PolicyState
{
Enabled
Disabled
NoPolicy
}
;
static
PolicyState
FindPolicyInRegistry
(
HKEY
rootKey
const
wchar_t
*
policyName
)
{
HKEY
rawRegKey
=
nullptr
;
RegOpenKeyExW
(
rootKey
POLICY_REGKEY_NAME
0
KEY_READ
&
rawRegKey
)
;
nsAutoRegKey
regKey
(
rawRegKey
)
;
if
(
!
regKey
)
{
return
PolicyState
:
:
NoPolicy
;
}
DWORD
numSubKeys
=
0
numValues
=
0
;
LSTATUS
ls
=
RegQueryInfoKeyW
(
regKey
.
get
(
)
nullptr
nullptr
nullptr
&
numSubKeys
nullptr
nullptr
&
numValues
nullptr
nullptr
nullptr
nullptr
)
;
if
(
ls
!
=
ERROR_SUCCESS
)
{
return
PolicyState
:
:
NoPolicy
;
}
DWORD
policyValue
=
UINT32_MAX
;
DWORD
policyValueSize
=
sizeof
(
policyValue
)
;
ls
=
RegGetValueW
(
regKey
.
get
(
)
nullptr
policyName
RRF_RT_REG_DWORD
nullptr
&
policyValue
&
policyValueSize
)
;
if
(
ls
!
=
ERROR_SUCCESS
)
{
return
PolicyState
:
:
NoPolicy
;
}
return
policyValue
=
=
0
?
PolicyState
:
:
Disabled
:
PolicyState
:
:
Enabled
;
}
static
PolicyState
FindPolicyInFile
(
const
char
*
policyName
)
{
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
thisBinaryPath
=
mozilla
:
:
GetFullBinaryPath
(
)
;
if
(
!
PathRemoveFileSpecW
(
thisBinaryPath
.
get
(
)
)
)
{
return
PolicyState
:
:
NoPolicy
;
}
wchar_t
policiesFilePath
[
MAX_PATH
]
=
L
"
"
;
if
(
!
PathCombineW
(
policiesFilePath
thisBinaryPath
.
get
(
)
L
"
distribution
"
)
)
{
return
PolicyState
:
:
NoPolicy
;
}
if
(
!
PathAppendW
(
policiesFilePath
L
"
policies
.
json
"
)
)
{
return
PolicyState
:
:
NoPolicy
;
}
Utf16ToUtf8Result
policiesFilePathToUtf8
=
Utf16ToUtf8
(
policiesFilePath
)
;
if
(
policiesFilePathToUtf8
.
isErr
(
)
)
{
return
PolicyState
:
:
NoPolicy
;
}
std
:
:
string
policiesFilePathA
=
policiesFilePathToUtf8
.
unwrap
(
)
;
Json
:
:
Value
jsonRoot
;
std
:
:
ifstream
stream
(
policiesFilePathA
)
;
Json
:
:
Reader
(
)
.
parse
(
stream
jsonRoot
)
;
if
(
jsonRoot
.
isObject
(
)
&
&
jsonRoot
.
isMember
(
"
Policies
"
)
&
&
jsonRoot
[
"
Policies
"
]
.
isObject
(
)
)
{
if
(
jsonRoot
[
"
Policies
"
]
.
isMember
(
policyName
)
&
&
jsonRoot
[
"
Policies
"
]
[
policyName
]
.
isBool
(
)
)
{
return
jsonRoot
[
"
Policies
"
]
[
policyName
]
.
asBool
(
)
?
PolicyState
:
:
Enabled
:
PolicyState
:
:
Disabled
;
}
else
{
return
PolicyState
:
:
NoPolicy
;
}
}
return
PolicyState
:
:
NoPolicy
;
}
static
PolicyState
IsDisabledByPref
(
const
wchar_t
*
prefRegValue
)
{
auto
prefValueResult
=
RegistryGetValueBool
(
IsPrefixed
:
:
Prefixed
prefRegValue
)
;
if
(
prefValueResult
.
isErr
(
)
)
{
return
PolicyState
:
:
NoPolicy
;
}
auto
prefValue
=
prefValueResult
.
unwrap
(
)
;
if
(
prefValue
.
isNothing
(
)
)
{
return
PolicyState
:
:
NoPolicy
;
}
return
prefValue
.
value
(
)
?
PolicyState
:
:
Enabled
:
PolicyState
:
:
Disabled
;
}
static
bool
IsThingDisabled
(
const
char
*
thing
const
wchar_t
*
wideThing
)
{
PolicyState
state
=
FindPolicyInRegistry
(
HKEY_LOCAL_MACHINE
wideThing
)
;
if
(
state
=
=
PolicyState
:
:
NoPolicy
)
{
state
=
FindPolicyInRegistry
(
HKEY_CURRENT_USER
wideThing
)
;
}
if
(
state
=
=
PolicyState
:
:
NoPolicy
)
{
state
=
FindPolicyInFile
(
thing
)
;
}
if
(
state
=
=
PolicyState
:
:
NoPolicy
)
{
state
=
IsDisabledByPref
(
wideThing
)
;
}
return
state
=
=
PolicyState
:
:
Enabled
?
true
:
false
;
}
bool
IsAgentDisabled
(
)
{
return
IsThingDisabled
(
AGENT_POLICY_NAME
L
"
"
AGENT_POLICY_NAME
)
;
}
bool
IsTelemetryDisabled
(
)
{
return
IsThingDisabled
(
TELEMETRY_POLICY_NAME
L
"
"
TELEMETRY_POLICY_NAME
)
;
}
