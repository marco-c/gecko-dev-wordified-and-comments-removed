#
include
<
windows
.
h
>
#
include
<
appmodel
.
h
>
#
include
<
shlobj
.
h
>
#
include
<
timeapi
.
h
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
CmdLineAndEnvUtils
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
WindowsUserChoice
.
h
"
#
include
"
EventLog
.
h
"
#
include
"
SetDefaultBrowser
.
h
"
namespace
mozilla
:
:
default_agent
{
static
nsresult
SetDefaultExtensionHandlersUserChoiceImpl
(
const
wchar_t
*
aAumi
const
wchar_t
*
const
aSid
const
bool
aRegRename
const
nsTArray
<
nsString
>
&
aFileExtensions
)
;
static
bool
AddMillisecondsToSystemTime
(
SYSTEMTIME
&
aSystemTime
ULONGLONG
aIncrementMS
)
{
FILETIME
fileTime
;
ULARGE_INTEGER
fileTimeInt
;
if
(
!
:
:
SystemTimeToFileTime
(
&
aSystemTime
&
fileTime
)
)
{
return
false
;
}
fileTimeInt
.
LowPart
=
fileTime
.
dwLowDateTime
;
fileTimeInt
.
HighPart
=
fileTime
.
dwHighDateTime
;
fileTimeInt
.
QuadPart
+
=
aIncrementMS
*
1000
*
10
;
fileTime
.
dwLowDateTime
=
fileTimeInt
.
LowPart
;
fileTime
.
dwHighDateTime
=
fileTimeInt
.
HighPart
;
SYSTEMTIME
tmpSystemTime
;
if
(
!
:
:
FileTimeToSystemTime
(
&
fileTime
&
tmpSystemTime
)
)
{
return
false
;
}
aSystemTime
=
tmpSystemTime
;
return
true
;
}
static
WORD
GetMillisecondsToNextMinute
(
SYSTEMTIME
operationStartTime
SYSTEMTIME
currentTime
)
{
SYSTEMTIME
operationStartTimeMinute
=
operationStartTime
;
SYSTEMTIME
currentTimeMinute
=
currentTime
;
operationStartTimeMinute
.
wSecond
=
0
;
operationStartTimeMinute
.
wMilliseconds
=
0
;
currentTimeMinute
.
wSecond
=
0
;
currentTimeMinute
.
wMilliseconds
=
0
;
FILETIME
fileTime1
;
FILETIME
fileTime2
;
if
(
!
:
:
SystemTimeToFileTime
(
&
operationStartTimeMinute
&
fileTime1
)
|
|
!
:
:
SystemTimeToFileTime
(
&
currentTimeMinute
&
fileTime2
)
)
{
return
0
;
}
if
(
(
fileTime1
.
dwLowDateTime
!
=
fileTime2
.
dwLowDateTime
)
|
|
(
fileTime1
.
dwHighDateTime
!
=
fileTime2
.
dwHighDateTime
)
)
{
return
0
;
}
const
WORD
secondsToMilliseconds
=
1000
;
const
WORD
minutesToSeconds
=
60
;
return
(
1
*
minutesToSeconds
*
secondsToMilliseconds
)
-
(
(
currentTime
.
wSecond
*
secondsToMilliseconds
)
+
currentTime
.
wMilliseconds
)
;
}
static
bool
CheckEqualMinutes
(
SYSTEMTIME
aSystemTime1
SYSTEMTIME
aSystemTime2
)
{
aSystemTime1
.
wSecond
=
0
;
aSystemTime1
.
wMilliseconds
=
0
;
aSystemTime2
.
wSecond
=
0
;
aSystemTime2
.
wMilliseconds
=
0
;
FILETIME
fileTime1
;
FILETIME
fileTime2
;
if
(
!
:
:
SystemTimeToFileTime
(
&
aSystemTime1
&
fileTime1
)
|
|
!
:
:
SystemTimeToFileTime
(
&
aSystemTime2
&
fileTime2
)
)
{
return
false
;
}
return
(
fileTime1
.
dwLowDateTime
=
=
fileTime2
.
dwLowDateTime
)
&
&
(
fileTime1
.
dwHighDateTime
=
=
fileTime2
.
dwHighDateTime
)
;
}
static
bool
SetUserChoiceRegistry
(
const
wchar_t
*
aExt
const
wchar_t
*
aProgID
const
bool
aRegRename
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
aHash
)
{
auto
assocKeyPath
=
GetAssociationKeyPath
(
aExt
)
;
if
(
!
assocKeyPath
)
{
return
false
;
}
LSTATUS
ls
;
HKEY
rawAssocKey
;
ls
=
:
:
RegOpenKeyExW
(
HKEY_CURRENT_USER
assocKeyPath
.
get
(
)
0
KEY_READ
|
KEY_WRITE
&
rawAssocKey
)
;
if
(
ls
!
=
ERROR_SUCCESS
)
{
LOG_ERROR
(
HRESULT_FROM_WIN32
(
ls
)
)
;
return
false
;
}
nsAutoRegKey
assocKey
(
rawAssocKey
)
;
if
(
aRegRename
)
{
nsAutoString
tempName
=
NS_ConvertASCIItoUTF16
(
nsID
:
:
GenerateUUID
(
)
.
ToString
(
)
.
get
(
)
)
;
ls
=
:
:
RegRenameKey
(
assocKey
.
get
(
)
nullptr
tempName
.
get
(
)
)
;
if
(
ls
!
=
ERROR_SUCCESS
)
{
LOG_ERROR
(
HRESULT_FROM_WIN32
(
ls
)
)
;
return
false
;
}
}
auto
subkeysUpdated
=
[
&
]
{
if
(
aExt
&
&
aExt
[
0
]
=
=
'
.
'
)
{
ls
=
:
:
RegDeleteKeyW
(
assocKey
.
get
(
)
L
"
UserChoice
"
)
;
if
(
ls
!
=
ERROR_SUCCESS
)
{
LOG_ERROR
(
HRESULT_FROM_WIN32
(
ls
)
)
;
return
false
;
}
}
HKEY
rawUserChoiceKey
;
ls
=
:
:
RegCreateKeyExW
(
assocKey
.
get
(
)
L
"
UserChoice
"
0
nullptr
0
KEY_READ
|
KEY_WRITE
0
&
rawUserChoiceKey
nullptr
)
;
if
(
ls
!
=
ERROR_SUCCESS
)
{
LOG_ERROR
(
HRESULT_FROM_WIN32
(
ls
)
)
;
return
false
;
}
nsAutoRegKey
userChoiceKey
(
rawUserChoiceKey
)
;
DWORD
progIdByteCount
=
(
:
:
lstrlenW
(
aProgID
)
+
1
)
*
sizeof
(
wchar_t
)
;
ls
=
:
:
RegSetValueExW
(
userChoiceKey
.
get
(
)
L
"
ProgID
"
0
REG_SZ
reinterpret_cast
<
const
unsigned
char
*
>
(
aProgID
)
progIdByteCount
)
;
if
(
ls
!
=
ERROR_SUCCESS
)
{
LOG_ERROR
(
HRESULT_FROM_WIN32
(
ls
)
)
;
return
false
;
}
DWORD
hashByteCount
=
(
:
:
lstrlenW
(
aHash
.
get
(
)
)
+
1
)
*
sizeof
(
wchar_t
)
;
ls
=
:
:
RegSetValueExW
(
userChoiceKey
.
get
(
)
L
"
Hash
"
0
REG_SZ
reinterpret_cast
<
const
unsigned
char
*
>
(
aHash
.
get
(
)
)
hashByteCount
)
;
if
(
ls
!
=
ERROR_SUCCESS
)
{
LOG_ERROR
(
HRESULT_FROM_WIN32
(
ls
)
)
;
return
false
;
}
return
true
;
}
(
)
;
if
(
aRegRename
)
{
ls
=
:
:
RegRenameKey
(
assocKey
.
get
(
)
nullptr
aExt
)
;
if
(
ls
!
=
ERROR_SUCCESS
)
{
LOG_ERROR
(
HRESULT_FROM_WIN32
(
ls
)
)
;
return
false
;
}
}
return
subkeysUpdated
;
}
struct
LaunchExeErr
{
}
;
using
LaunchExeResult
=
mozilla
:
:
Result
<
std
:
:
tuple
<
DWORD
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
>
LaunchExeErr
>
;
static
LaunchExeResult
LaunchExecutable
(
const
wchar_t
*
exePath
int
aArgsLength
const
wchar_t
*
const
*
aArgs
)
{
const
wchar_t
*
args
[
]
=
{
exePath
}
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
cmdLine
(
mozilla
:
:
MakeCommandLine
(
std
:
:
size
(
args
)
const_cast
<
wchar_t
*
*
>
(
args
)
aArgsLength
const_cast
<
wchar_t
*
*
>
(
aArgs
)
)
)
;
PROCESS_INFORMATION
pi
;
STARTUPINFOW
si
=
{
sizeof
(
si
)
}
;
si
.
dwFlags
=
STARTF_USESHOWWINDOW
;
si
.
wShowWindow
=
SW_HIDE
;
if
(
!
:
:
CreateProcessW
(
exePath
cmdLine
.
get
(
)
nullptr
nullptr
FALSE
0
nullptr
nullptr
&
si
&
pi
)
)
{
HRESULT
hr
=
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
LOG_ERROR
(
hr
)
;
return
Err
(
LaunchExeErr
(
)
)
;
}
nsAutoHandle
process
(
pi
.
hProcess
)
;
nsAutoHandle
mainThread
(
pi
.
hThread
)
;
DWORD
exitCode
;
if
(
:
:
WaitForSingleObject
(
process
.
get
(
)
INFINITE
)
=
=
WAIT_OBJECT_0
&
&
:
:
GetExitCodeProcess
(
process
.
get
(
)
&
exitCode
)
)
{
return
std
:
:
make_tuple
(
exitCode
std
:
:
move
(
cmdLine
)
)
;
}
return
Err
(
LaunchExeErr
(
)
)
;
}
static
bool
LaunchPowershell
(
const
wchar_t
*
command
const
wchar_t
*
powershellPath
)
{
const
wchar_t
*
args
[
]
=
{
L
"
-
NoProfile
"
L
"
-
c
"
command
}
;
return
LaunchExecutable
(
powershellPath
std
:
:
size
(
args
)
args
)
.
map
(
[
]
(
auto
result
)
{
auto
&
[
exitCode
regCmdLine
]
=
result
;
bool
success
=
(
exitCode
=
=
0
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
%
s
returned
failure
exitCode
%
d
"
regCmdLine
.
get
(
)
exitCode
)
;
}
return
success
;
}
)
.
unwrapOr
(
false
)
;
}
static
bool
FindPowershell
(
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
powershellPath
)
{
auto
exePath
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
MAX_PATH
+
1
)
;
if
(
!
ConstructSystem32Path
(
L
"
WindowsPowershell
\
\
v1
.
0
\
\
powershell
.
exe
"
exePath
.
get
(
)
MAX_PATH
+
1
)
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
construct
path
to
powershell
.
exe
"
)
;
return
false
;
}
powershellPath
.
swap
(
exePath
)
;
return
true
;
}
static
bool
SetUserChoice
(
const
wchar_t
*
aExt
const
wchar_t
*
aSid
const
wchar_t
*
aProgID
bool
inMsix
const
bool
aRegRename
)
{
if
(
inMsix
)
{
LOG_ERROR_MESSAGE
(
L
"
SetUserChoice
should
not
be
called
on
MSIX
builds
.
Call
"
L
"
SetDefaultExtensionHandlersUserChoiceImplMsix
instead
.
"
)
;
return
false
;
}
SYSTEMTIME
hashTimestamp
;
:
:
GetSystemTime
(
&
hashTimestamp
)
;
auto
hash
=
GenerateUserChoiceHash
(
aExt
aSid
aProgID
hashTimestamp
)
;
if
(
!
hash
)
{
return
false
;
}
const
ULONGLONG
kWriteTimingThresholdMilliseconds
=
1000
;
SYSTEMTIME
writeEndTimestamp
;
:
:
GetSystemTime
(
&
writeEndTimestamp
)
;
if
(
!
AddMillisecondsToSystemTime
(
writeEndTimestamp
kWriteTimingThresholdMilliseconds
)
)
{
return
false
;
}
if
(
!
CheckEqualMinutes
(
hashTimestamp
writeEndTimestamp
)
)
{
LOG_ERROR_MESSAGE
(
L
"
Hash
is
too
close
to
expiration
sleeping
until
next
hash
.
"
)
;
:
:
Sleep
(
kWriteTimingThresholdMilliseconds
*
2
)
;
:
:
GetSystemTime
(
&
hashTimestamp
)
;
hash
=
GenerateUserChoiceHash
(
aExt
aSid
aProgID
hashTimestamp
)
;
if
(
!
hash
)
{
return
false
;
}
}
return
SetUserChoiceRegistry
(
aExt
aProgID
aRegRename
std
:
:
move
(
hash
)
)
;
}
static
bool
VerifyUserDefault
(
const
wchar_t
*
aExt
const
wchar_t
*
aProgID
)
{
RefPtr
<
IApplicationAssociationRegistration
>
pAAR
;
HRESULT
hr
=
:
:
CoCreateInstance
(
CLSID_ApplicationAssociationRegistration
nullptr
CLSCTX_INPROC
IID_IApplicationAssociationRegistration
getter_AddRefs
(
pAAR
)
)
;
if
(
FAILED
(
hr
)
)
{
LOG_ERROR
(
hr
)
;
return
false
;
}
wchar_t
*
rawRegisteredApp
;
bool
isProtocol
=
aExt
[
0
]
!
=
L
'
.
'
;
hr
=
pAAR
-
>
QueryCurrentDefault
(
aExt
isProtocol
?
AT_URLPROTOCOL
:
AT_FILEEXTENSION
AL_USER
&
rawRegisteredApp
)
;
if
(
FAILED
(
hr
)
)
{
if
(
hr
=
=
HRESULT_FROM_WIN32
(
ERROR_NO_ASSOCIATION
)
)
{
LOG_ERROR_MESSAGE
(
L
"
UserChoice
ProgID
%
s
for
%
s
was
rejected
"
aProgID
aExt
)
;
}
else
{
LOG_ERROR
(
hr
)
;
}
return
false
;
}
mozilla
:
:
UniquePtr
<
wchar_t
mozilla
:
:
CoTaskMemFreeDeleter
>
registeredApp
(
rawRegisteredApp
)
;
if
(
:
:
CompareStringOrdinal
(
registeredApp
.
get
(
)
-
1
aProgID
-
1
FALSE
)
!
=
CSTR_EQUAL
)
{
LOG_ERROR_MESSAGE
(
L
"
Default
was
%
s
after
writing
ProgID
%
s
to
UserChoice
for
%
s
"
registeredApp
.
get
(
)
aProgID
aExt
)
;
return
false
;
}
return
true
;
}
nsresult
SetDefaultBrowserUserChoice
(
const
wchar_t
*
aAumi
const
bool
aRegRename
const
nsTArray
<
nsString
>
&
aExtraFileExtensions
)
{
if
(
!
CheckBrowserUserChoiceHashes
(
)
)
{
LOG_ERROR_MESSAGE
(
L
"
UserChoice
Hash
mismatch
"
)
;
return
NS_ERROR_WDBA_HASH_CHECK
;
}
if
(
!
mozilla
:
:
IsWin10CreatorsUpdateOrLater
(
)
)
{
LOG_ERROR_MESSAGE
(
L
"
UserChoice
hash
matched
but
Windows
build
is
too
old
"
)
;
return
NS_ERROR_WDBA_BUILD
;
}
auto
sid
=
GetCurrentUserStringSid
(
)
;
if
(
!
sid
)
{
return
NS_ERROR_FAILURE
;
}
nsTArray
<
nsString
>
browserDefaults
=
{
u
"
https
"
_ns
u
"
FirefoxURL
"
_ns
u
"
http
"
_ns
u
"
FirefoxURL
"
_ns
u
"
.
html
"
_ns
u
"
FirefoxHTML
"
_ns
u
"
.
htm
"
_ns
u
"
FirefoxHTML
"
_ns
}
;
browserDefaults
.
AppendElements
(
aExtraFileExtensions
)
;
nsresult
rv
=
SetDefaultExtensionHandlersUserChoiceImpl
(
aAumi
sid
.
get
(
)
aRegRename
browserDefaults
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
setting
default
with
%
s
"
aAumi
)
;
}
:
:
SHChangeNotify
(
SHCNE_ASSOCCHANGED
SHCNF_IDLIST
nullptr
nullptr
)
;
return
rv
;
}
nsresult
SetDefaultExtensionHandlersUserChoice
(
const
wchar_t
*
aAumi
const
bool
aRegRename
const
nsTArray
<
nsString
>
&
aFileExtensions
)
{
auto
sid
=
GetCurrentUserStringSid
(
)
;
if
(
!
sid
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
SetDefaultExtensionHandlersUserChoiceImpl
(
aAumi
sid
.
get
(
)
aRegRename
aFileExtensions
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
setting
default
with
%
s
"
aAumi
)
;
}
:
:
SHChangeNotify
(
SHCNE_ASSOCCHANGED
SHCNF_IDLIST
nullptr
nullptr
)
;
return
rv
;
}
static
nsresult
GenerateProgramIDs
(
const
nsTArray
<
nsString
>
&
aFileExtensions
nsTArray
<
nsString
>
&
progIDs
)
{
for
(
size_t
i
=
0
;
i
+
1
<
aFileExtensions
.
Length
(
)
;
i
+
=
2
)
{
const
wchar_t
*
fileExtension
=
aFileExtensions
[
i
]
.
get
(
)
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
progID
;
nsresult
rv
=
GetMsixProgId
(
fileExtension
progID
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
retrieve
MSIX
progID
for
%
s
"
fileExtension
)
;
return
rv
;
}
progIDs
.
AppendElement
(
nsString
(
progID
.
get
(
)
)
)
;
}
return
NS_OK
;
}
static
nsresult
VerifyUserDefaults
(
const
nsTArray
<
nsString
>
&
aFileExtensions
const
nsTArray
<
nsString
>
&
aProgIDs
)
{
for
(
size_t
i
=
0
;
i
+
1
<
aFileExtensions
.
Length
(
)
;
i
+
=
2
)
{
const
wchar_t
*
fileExtension
=
aFileExtensions
[
i
]
.
get
(
)
;
if
(
!
VerifyUserDefault
(
fileExtension
aProgIDs
[
i
/
2
]
.
get
(
)
)
)
{
return
NS_ERROR_WDBA_REJECTED
;
}
}
return
NS_OK
;
}
static
UINT
GetSystemSleepIntervalInMilliseconds
(
UINT
defaultValue
)
{
TIMECAPS
timeCapabilities
;
bool
timeCapsFetchSuccessful
=
(
MMSYSERR_NOERROR
=
=
timeGetDevCaps
(
&
timeCapabilities
sizeof
(
timeCapabilities
)
)
)
;
if
(
!
timeCapsFetchSuccessful
)
{
return
defaultValue
;
}
return
timeCapabilities
.
wPeriodMin
>
0
?
timeCapabilities
.
wPeriodMin
:
defaultValue
;
}
static
nsresult
SetDefaultExtensionHandlersUserChoiceImplMsix
(
const
wchar_t
*
aAumi
const
wchar_t
*
const
aSid
const
bool
aRegRename
const
nsTArray
<
nsString
>
&
aFileExtensions
)
{
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
exePath
;
if
(
!
FindPowershell
(
exePath
)
)
{
LOG_ERROR_MESSAGE
(
L
"
Could
not
locate
Powershell
"
)
;
return
NS_ERROR_FAILURE
;
}
auto
startScript
=
uR
"
(
#
Force
exceptions
to
stop
execution
ErrorActionPreference
=
'
Stop
'
Add
-
Type
-
TypeDefinition
"
using
System
;
using
System
.
Runtime
.
InteropServices
;
public
static
class
WinReg
{
[
DllImport
(
"
Advapi32
.
dll
"
)
]
public
static
extern
Int32
RegRenameKey
(
IntPtr
hKey
[
MarshalAs
(
UnmanagedType
.
LPWStr
)
]
string
lpSubKeyName
[
MarshalAs
(
UnmanagedType
.
LPWStr
)
]
string
lpNewKeyName
)
;
}
"
function
Set
-
DefaultHandlerRegistry
(
Association
Path
ProgID
Hash
RegRename
)
{
RootKey
=
[
Microsoft
.
Win32
.
Registry
]
:
:
CurrentUser
.
CreateSubKey
(
Path
)
if
(
RegRename
)
{
#
Rename
the
registry
key
.
TempName
=
New
-
Guid
Handle
=
RootKey
.
Handle
.
DangerousGetHandle
(
)
result
=
[
WinReg
]
:
:
RegRenameKey
(
Handle
null
TempName
.
ToString
(
)
)
if
(
result
-
ne
0
)
{
throw
"
Error
renaming
key
to
temporary
value
.
"
}
}
#
DeleteSubKey
throws
if
we
don
'
t
have
sufficient
permissions
to
delete
key
#
signaling
failure
to
launching
process
.
#
#
Note
:
DeleteSubKeyTree
fails
when
DENY
permissions
are
set
on
key
whereas
#
DeleteSubKey
succeeds
.
RootKey
.
DeleteSubKey
(
"
UserChoice
"
false
)
UserChoice
=
RootKey
.
CreateSubKey
(
"
UserChoice
"
)
StringType
=
[
Microsoft
.
Win32
.
RegistryValueKind
]
:
:
String
UserChoice
.
SetValue
(
'
ProgID
'
ProgID
StringType
)
UserChoice
.
SetValue
(
'
Hash
'
Hash
StringType
)
if
(
RegRename
)
{
result
=
[
WinReg
]
:
:
RegRenameKey
(
Handle
null
Association
)
if
(
result
-
ne
0
)
{
throw
"
Error
renaming
key
to
association
value
.
"
}
}
}
)
"
_ns
;
if
(
aFileExtensions
.
Length
(
)
>
=
70
)
{
LOG_ERROR_MESSAGE
(
L
"
SetDefaultExtensionHandlersUserChoiceImplMsix
can
'
t
cope
with
70
or
"
L
"
more
file
extensions
at
once
.
Please
break
it
up
into
multiple
calls
"
L
"
with
fewer
extensions
per
call
.
"
)
;
return
NS_ERROR_FAILURE
;
}
nsTArray
<
nsString
>
progIDs
;
nsresult
rv
=
GenerateProgramIDs
(
aFileExtensions
progIDs
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsString
scriptBuffer
;
for
(
int
i
=
0
;
i
<
10
;
i
+
+
)
{
const
int
scriptBufferCapacity
=
16
*
1024
;
scriptBuffer
=
startScript
;
scriptBuffer
.
SetCapacity
(
scriptBufferCapacity
)
;
SYSTEMTIME
hashTimestamp
;
:
:
GetSystemTime
(
&
hashTimestamp
)
;
for
(
size_t
i
=
0
;
i
+
1
<
aFileExtensions
.
Length
(
)
;
i
+
=
2
)
{
const
wchar_t
*
fileExtension
=
aFileExtensions
[
i
]
.
get
(
)
;
auto
association
=
nsDependentString
(
fileExtension
)
;
nsAutoString
keyPath
;
AppendAssociationKeyPath
(
fileExtension
keyPath
)
;
auto
hashWchar
=
GenerateUserChoiceHash
(
fileExtension
aSid
progIDs
[
i
/
2
]
.
get
(
)
hashTimestamp
)
;
if
(
!
hashWchar
)
{
return
NS_ERROR_FAILURE
;
}
auto
hash
=
nsDependentString
(
hashWchar
.
get
(
)
)
;
auto
regRename
=
aRegRename
?
u
"
TRUE
"
_ns
:
u
"
FALSE
"
_ns
;
scriptBuffer
+
=
u
"
Set
-
DefaultHandlerRegistry
"
_ns
+
association
+
u
"
"
_ns
+
keyPath
+
u
"
"
_ns
+
progIDs
[
i
/
2
]
+
u
"
"
_ns
+
hash
+
u
"
"
_ns
+
regRename
+
u
"
\
n
"
_ns
;
}
const
ULONGLONG
kWriteTimingThresholdMilliseconds
=
2000
;
SYSTEMTIME
writeEndTimestamp
;
:
:
GetSystemTime
(
&
writeEndTimestamp
)
;
auto
millisecondsLeftUntilNextMinute
=
GetMillisecondsToNextMinute
(
hashTimestamp
writeEndTimestamp
)
;
if
(
millisecondsLeftUntilNextMinute
>
=
kWriteTimingThresholdMilliseconds
)
{
break
;
}
LOG_ERROR_MESSAGE
(
L
"
Hash
is
too
close
to
next
minute
sleeping
until
next
minute
to
"
L
"
ensure
that
hash
generation
matches
write
to
registry
.
"
)
;
UINT
sleepUntilNextMinuteBufferMilliseconds
=
GetSystemSleepIntervalInMilliseconds
(
50
)
;
:
:
Sleep
(
millisecondsLeftUntilNextMinute
+
(
sleepUntilNextMinuteBufferMilliseconds
*
2
)
)
;
}
bool
powershellSuccessful
=
LaunchPowershell
(
scriptBuffer
.
get
(
)
exePath
.
get
(
)
)
;
if
(
!
powershellSuccessful
)
{
return
NS_ERROR_FAILURE
;
}
return
VerifyUserDefaults
(
aFileExtensions
progIDs
)
;
}
nsresult
SetDefaultExtensionHandlersUserChoiceImpl
(
const
wchar_t
*
aAumi
const
wchar_t
*
const
aSid
const
bool
aRegRename
const
nsTArray
<
nsString
>
&
aFileExtensions
)
{
UINT32
pfnLen
=
0
;
bool
inMsix
=
GetCurrentPackageFullName
(
&
pfnLen
nullptr
)
!
=
APPMODEL_ERROR_NO_PACKAGE
;
if
(
inMsix
)
{
return
SetDefaultExtensionHandlersUserChoiceImplMsix
(
aAumi
aSid
aRegRename
aFileExtensions
)
;
}
for
(
size_t
i
=
0
;
i
+
1
<
aFileExtensions
.
Length
(
)
;
i
+
=
2
)
{
const
wchar_t
*
extraFileExtension
=
aFileExtensions
[
i
]
.
get
(
)
;
const
wchar_t
*
extraProgIDRoot
=
aFileExtensions
[
i
+
1
]
.
get
(
)
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
extraProgID
;
if
(
inMsix
)
{
nsresult
rv
=
GetMsixProgId
(
extraFileExtension
extraProgID
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
retrieve
MSIX
progID
for
%
s
"
extraFileExtension
)
;
return
rv
;
}
}
else
{
extraProgID
=
FormatProgID
(
extraProgIDRoot
aAumi
)
;
if
(
!
CheckProgIDExists
(
extraProgID
.
get
(
)
)
)
{
LOG_ERROR_MESSAGE
(
L
"
ProgID
%
s
not
found
"
extraProgID
.
get
(
)
)
;
return
NS_ERROR_WDBA_NO_PROGID
;
}
}
if
(
!
SetUserChoice
(
extraFileExtension
aSid
extraProgID
.
get
(
)
inMsix
aRegRename
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
VerifyUserDefault
(
extraFileExtension
extraProgID
.
get
(
)
)
)
{
return
NS_ERROR_WDBA_REJECTED
;
}
}
return
NS_OK
;
}
}
