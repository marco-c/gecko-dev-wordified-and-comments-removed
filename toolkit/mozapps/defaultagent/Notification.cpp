#
include
"
Notification
.
h
"
#
include
<
shlwapi
.
h
>
#
include
<
wchar
.
h
>
#
include
<
windows
.
h
>
#
include
<
winnt
.
h
>
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
readstrings
.
h
"
#
include
"
updatererrors
.
h
"
#
include
"
WindowsDefaultBrowser
.
h
"
#
include
"
common
.
h
"
#
include
"
DefaultBrowser
.
h
"
#
include
"
EventLog
.
h
"
#
include
"
Registry
.
h
"
#
include
"
wintoastlib
.
h
"
#
define
SEVEN_DAYS_IN_SECONDS
(
7
*
24
*
60
*
60
)
#
define
NOTIFICATION_WAIT_TIMEOUT_MS
(
30
*
60
*
1000
)
#
define
MUTEX_TIMEOUT_MS
(
10
*
60
*
1000
)
bool
FirefoxInstallIsEnglish
(
)
;
static
bool
SetInitialNotificationShown
(
bool
wasShown
)
{
return
!
RegistrySetValueBool
(
IsPrefixed
:
:
Unprefixed
L
"
InitialNotificationShown
"
wasShown
)
.
isErr
(
)
;
}
static
bool
GetInitialNotificationShown
(
)
{
return
RegistryGetValueBool
(
IsPrefixed
:
:
Unprefixed
L
"
InitialNotificationShown
"
)
.
unwrapOr
(
mozilla
:
:
Some
(
false
)
)
.
valueOr
(
false
)
;
}
static
bool
SetFollowupNotificationShown
(
bool
wasShown
)
{
return
!
RegistrySetValueBool
(
IsPrefixed
:
:
Unprefixed
L
"
FollowupNotificationShown
"
wasShown
)
.
isErr
(
)
;
}
static
bool
GetFollowupNotificationShown
(
)
{
return
RegistryGetValueBool
(
IsPrefixed
:
:
Unprefixed
L
"
FollowupNotificationShown
"
)
.
unwrapOr
(
mozilla
:
:
Some
(
false
)
)
.
valueOr
(
false
)
;
}
static
bool
SetFollowupNotificationSuppressed
(
bool
value
)
{
return
!
RegistrySetValueBool
(
IsPrefixed
:
:
Unprefixed
L
"
FollowupNotificationSuppressed
"
value
)
.
isErr
(
)
;
}
static
bool
GetFollowupNotificationSuppressed
(
)
{
return
RegistryGetValueBool
(
IsPrefixed
:
:
Unprefixed
L
"
FollowupNotificationSuppressed
"
)
.
unwrapOr
(
mozilla
:
:
Some
(
false
)
)
.
valueOr
(
false
)
;
}
static
bool
SetFollowupNotificationRequestTime
(
ULONGLONG
time
)
{
return
!
RegistrySetValueQword
(
IsPrefixed
:
:
Unprefixed
L
"
FollowupRequestTime
"
time
)
.
isErr
(
)
;
}
static
ULONGLONG
GetFollowupNotificationRequestTime
(
)
{
return
RegistryGetValueQword
(
IsPrefixed
:
:
Unprefixed
L
"
FollowupRequestTime
"
)
.
unwrapOr
(
mozilla
:
:
Some
(
0
)
)
.
valueOr
(
0
)
;
}
struct
ToastStrings
{
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
text1
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
text2
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
action1
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
action2
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
relImagePath
;
}
;
struct
Strings
{
ToastStrings
initialToast
;
ToastStrings
followupToast
;
ToastStrings
localizedToast
;
const
ToastStrings
*
GetToastStrings
(
NotificationType
whichToast
bool
englishStrings
)
const
{
if
(
!
englishStrings
)
{
return
&
localizedToast
;
}
if
(
whichToast
=
=
NotificationType
:
:
Initial
)
{
return
&
initialToast
;
}
return
&
followupToast
;
}
}
;
static
bool
GetString
(
const
wchar_t
*
iniPath
const
char
*
section
const
char
*
key
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
toastString
)
{
IniReader
reader
(
iniPath
section
)
;
reader
.
AddKey
(
key
&
toastString
)
;
int
result
=
reader
.
Read
(
)
;
if
(
result
!
=
OK
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
retrieve
INI
string
:
section
=
%
S
key
=
%
S
result
=
%
d
"
section
key
result
)
;
return
false
;
}
return
true
;
}
static
bool
GetStrings
(
Strings
&
strings
)
{
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
installPath
;
bool
success
=
GetInstallDirectory
(
installPath
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
get
install
directory
when
getting
strings
"
)
;
return
false
;
}
const
wchar_t
*
iniFormat
=
L
"
%
s
\
\
defaultagent
.
ini
"
;
int
bufferSize
=
_scwprintf
(
iniFormat
installPath
.
get
(
)
)
;
+
+
bufferSize
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
iniPath
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
bufferSize
)
;
_snwprintf_s
(
iniPath
.
get
(
)
bufferSize
_TRUNCATE
iniFormat
installPath
.
get
(
)
)
;
IniReader
stringsReader
(
iniPath
.
get
(
)
)
;
stringsReader
.
AddKey
(
"
DefaultBrowserNotificationTitle
"
&
strings
.
initialToast
.
text1
)
;
stringsReader
.
AddKey
(
"
DefaultBrowserNotificationTitle
"
&
strings
.
followupToast
.
text1
)
;
stringsReader
.
AddKey
(
"
DefaultBrowserNotificationText
"
&
strings
.
initialToast
.
text2
)
;
stringsReader
.
AddKey
(
"
DefaultBrowserNotificationText
"
&
strings
.
followupToast
.
text2
)
;
stringsReader
.
AddKey
(
"
DefaultBrowserNotificationRemindMeLater
"
&
strings
.
initialToast
.
action1
)
;
stringsReader
.
AddKey
(
"
DefaultBrowserNotificationDontShowAgain
"
&
strings
.
followupToast
.
action1
)
;
stringsReader
.
AddKey
(
"
DefaultBrowserNotificationMakeFirefoxDefault
"
&
strings
.
initialToast
.
action2
)
;
stringsReader
.
AddKey
(
"
DefaultBrowserNotificationMakeFirefoxDefault
"
&
strings
.
followupToast
.
action2
)
;
int
result
=
stringsReader
.
Read
(
)
;
if
(
result
!
=
OK
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
read
English
strings
:
%
d
"
result
)
;
return
false
;
}
const
wchar_t
*
localizedIniFormat
=
L
"
%
s
\
\
defaultagent_localized
.
ini
"
;
bufferSize
=
_scwprintf
(
localizedIniFormat
installPath
.
get
(
)
)
;
+
+
bufferSize
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
localizedIniPath
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
bufferSize
)
;
_snwprintf_s
(
localizedIniPath
.
get
(
)
bufferSize
_TRUNCATE
localizedIniFormat
installPath
.
get
(
)
)
;
IniReader
localizedReader
(
localizedIniPath
.
get
(
)
)
;
localizedReader
.
AddKey
(
"
DefaultBrowserNotificationTitle
"
&
strings
.
localizedToast
.
text1
)
;
localizedReader
.
AddKey
(
"
DefaultBrowserNotificationText
"
&
strings
.
localizedToast
.
text2
)
;
localizedReader
.
AddKey
(
"
DefaultBrowserNotificationYesButtonText
"
&
strings
.
localizedToast
.
action1
)
;
localizedReader
.
AddKey
(
"
DefaultBrowserNotificationNoButtonText
"
&
strings
.
localizedToast
.
action2
)
;
result
=
localizedReader
.
Read
(
)
;
if
(
result
!
=
OK
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
read
localized
strings
:
%
d
"
result
)
;
return
false
;
}
IniReader
nonlocalizedReader
(
iniPath
.
get
(
)
"
Nonlocalized
"
)
;
nonlocalizedReader
.
AddKey
(
"
InitialToastRelativeImagePath
"
&
strings
.
initialToast
.
relImagePath
)
;
nonlocalizedReader
.
AddKey
(
"
FollowupToastRelativeImagePath
"
&
strings
.
followupToast
.
relImagePath
)
;
nonlocalizedReader
.
AddKey
(
"
LocalizedToastRelativeImagePath
"
&
strings
.
localizedToast
.
relImagePath
)
;
result
=
nonlocalizedReader
.
Read
(
)
;
if
(
result
!
=
OK
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
read
non
-
localized
strings
:
%
d
"
result
)
;
return
false
;
}
return
true
;
}
struct
HandlerData
{
NotificationActivities
activitiesPerformed
;
bool
handlerDataHasBeenSet
;
}
;
static
HandlerData
gHandlerReturnData
;
static
HANDLE
gHandlerMutex
=
INVALID_HANDLE_VALUE
;
class
ToastHandler
:
public
WinToastLib
:
:
IWinToastHandler
{
private
:
NotificationType
mWhichNotification
;
bool
mIsLocalizedNotification
;
HANDLE
mEvent
;
public
:
ToastHandler
(
NotificationType
whichNotification
bool
isEnglishInstall
HANDLE
event
)
{
mWhichNotification
=
whichNotification
;
mIsLocalizedNotification
=
!
isEnglishInstall
;
mEvent
=
event
;
}
void
FinishHandler
(
NotificationActivities
&
returnData
)
const
{
SetReturnData
(
returnData
)
;
BOOL
success
=
SetEvent
(
mEvent
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Event
could
not
be
set
:
%
#
X
"
GetLastError
(
)
)
;
}
}
void
SetReturnData
(
NotificationActivities
&
toSet
)
const
{
DWORD
result
=
WaitForSingleObject
(
gHandlerMutex
MUTEX_TIMEOUT_MS
)
;
if
(
result
=
=
WAIT_TIMEOUT
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
obtain
mutex
ownership
"
)
;
return
;
}
else
if
(
result
=
=
WAIT_FAILED
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
wait
on
mutex
:
%
#
X
"
GetLastError
(
)
)
;
return
;
}
else
if
(
result
=
=
WAIT_ABANDONED
)
{
LOG_ERROR_MESSAGE
(
L
"
Found
abandoned
mutex
"
)
;
ReleaseMutex
(
gHandlerMutex
)
;
return
;
}
if
(
!
gHandlerReturnData
.
handlerDataHasBeenSet
)
{
gHandlerReturnData
.
activitiesPerformed
=
toSet
;
gHandlerReturnData
.
handlerDataHasBeenSet
=
true
;
}
BOOL
success
=
ReleaseMutex
(
gHandlerMutex
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
release
mutex
ownership
:
%
#
X
"
GetLastError
(
)
)
;
}
}
void
toastActivated
(
)
const
override
{
NotificationActivities
activitiesPerformed
;
activitiesPerformed
.
type
=
mWhichNotification
;
activitiesPerformed
.
shown
=
NotificationShown
:
:
Shown
;
activitiesPerformed
.
action
=
NotificationAction
:
:
ToastClicked
;
LaunchModernSettingsDialogDefaultApps
(
)
;
FinishHandler
(
activitiesPerformed
)
;
}
void
toastActivated
(
int
actionIndex
)
const
override
{
NotificationActivities
activitiesPerformed
;
activitiesPerformed
.
type
=
mWhichNotification
;
activitiesPerformed
.
shown
=
NotificationShown
:
:
Shown
;
activitiesPerformed
.
action
=
NotificationAction
:
:
NoAction
;
if
(
(
actionIndex
=
=
0
&
&
!
mIsLocalizedNotification
)
|
|
(
actionIndex
=
=
1
&
&
mIsLocalizedNotification
)
)
{
if
(
mWhichNotification
=
=
NotificationType
:
:
Initial
&
&
!
mIsLocalizedNotification
)
{
activitiesPerformed
.
action
=
NotificationAction
:
:
RemindMeLater
;
if
(
!
SetFollowupNotificationRequestTime
(
GetCurrentTimestamp
(
)
)
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
schedule
followup
notification
"
)
;
}
}
else
{
activitiesPerformed
.
action
=
NotificationAction
:
:
DismissedByButton
;
}
}
else
if
(
(
actionIndex
=
=
1
&
&
!
mIsLocalizedNotification
)
|
|
(
actionIndex
=
=
0
&
&
mIsLocalizedNotification
)
)
{
activitiesPerformed
.
action
=
NotificationAction
:
:
MakeFirefoxDefaultButton
;
LaunchModernSettingsDialogDefaultApps
(
)
;
}
FinishHandler
(
activitiesPerformed
)
;
}
void
toastDismissed
(
WinToastDismissalReason
state
)
const
override
{
NotificationActivities
activitiesPerformed
;
activitiesPerformed
.
type
=
mWhichNotification
;
activitiesPerformed
.
shown
=
NotificationShown
:
:
Shown
;
activitiesPerformed
.
action
=
NotificationAction
:
:
NoAction
;
if
(
state
=
=
WinToastDismissalReason
:
:
TimedOut
)
{
activitiesPerformed
.
action
=
NotificationAction
:
:
DismissedByTimeout
;
}
else
if
(
state
=
=
WinToastDismissalReason
:
:
ApplicationHidden
)
{
activitiesPerformed
.
action
=
NotificationAction
:
:
DismissedByApplicationHidden
;
}
else
if
(
state
=
=
WinToastDismissalReason
:
:
UserCanceled
)
{
activitiesPerformed
.
action
=
NotificationAction
:
:
DismissedToActionCenter
;
}
FinishHandler
(
activitiesPerformed
)
;
}
void
toastFailed
(
)
const
override
{
NotificationActivities
activitiesPerformed
;
activitiesPerformed
.
type
=
mWhichNotification
;
activitiesPerformed
.
shown
=
NotificationShown
:
:
Error
;
activitiesPerformed
.
action
=
NotificationAction
:
:
NoAction
;
LOG_ERROR_MESSAGE
(
L
"
Toast
notification
failed
to
display
"
)
;
FinishHandler
(
activitiesPerformed
)
;
}
}
;
static
NotificationActivities
ShowNotification
(
NotificationType
whichNotification
const
wchar_t
*
aumi
)
{
NotificationActivities
activitiesPerformed
=
{
whichNotification
NotificationShown
:
:
Error
NotificationAction
:
:
NoAction
}
;
using
namespace
WinToastLib
;
if
(
!
WinToast
:
:
isCompatible
(
)
)
{
LOG_ERROR_MESSAGE
(
L
"
System
is
not
compatible
with
WinToast
"
)
;
return
activitiesPerformed
;
}
WinToast
:
:
instance
(
)
-
>
setAppName
(
L
"
"
MOZ_APP_BASENAME
)
;
std
:
:
wstring
aumiStr
=
aumi
;
WinToast
:
:
instance
(
)
-
>
setAppUserModelId
(
aumiStr
)
;
WinToast
:
:
WinToastError
error
;
if
(
!
WinToast
:
:
instance
(
)
-
>
initialize
(
&
error
)
)
{
LOG_ERROR_MESSAGE
(
WinToast
:
:
strerror
(
error
)
.
c_str
(
)
)
;
return
activitiesPerformed
;
}
bool
isEnglishInstall
=
FirefoxInstallIsEnglish
(
)
;
Strings
strings
;
if
(
!
GetStrings
(
strings
)
)
{
return
activitiesPerformed
;
}
const
ToastStrings
*
toastStrings
=
strings
.
GetToastStrings
(
whichNotification
isEnglishInstall
)
;
nsAutoHandle
event
(
CreateEventW
(
nullptr
TRUE
FALSE
nullptr
)
)
;
if
(
event
.
get
(
)
=
=
nullptr
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
create
event
object
:
%
#
X
"
GetLastError
(
)
)
;
return
activitiesPerformed
;
}
bool
success
=
false
;
if
(
whichNotification
=
=
NotificationType
:
:
Initial
)
{
success
=
SetInitialNotificationShown
(
true
)
;
}
else
{
success
=
SetFollowupNotificationShown
(
true
)
;
}
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
set
notification
as
displayed
"
)
;
return
activitiesPerformed
;
}
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
installPath
;
success
=
GetInstallDirectory
(
installPath
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
get
install
directory
for
the
image
path
"
)
;
return
activitiesPerformed
;
}
const
wchar_t
*
absPathFormat
=
L
"
%
s
\
\
%
s
"
;
int
bufferSize
=
_scwprintf
(
absPathFormat
installPath
.
get
(
)
toastStrings
-
>
relImagePath
.
get
(
)
)
;
+
+
bufferSize
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
absImagePath
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
bufferSize
)
;
_snwprintf_s
(
absImagePath
.
get
(
)
bufferSize
_TRUNCATE
absPathFormat
installPath
.
get
(
)
toastStrings
-
>
relImagePath
.
get
(
)
)
;
gHandlerMutex
=
CreateMutexW
(
nullptr
TRUE
nullptr
)
;
if
(
gHandlerMutex
=
=
nullptr
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
create
mutex
:
%
#
X
"
GetLastError
(
)
)
;
return
activitiesPerformed
;
}
nsAutoHandle
autoMutex
(
gHandlerMutex
)
;
gHandlerReturnData
.
handlerDataHasBeenSet
=
false
;
success
=
ReleaseMutex
(
gHandlerMutex
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
release
mutex
ownership
:
%
#
X
"
GetLastError
(
)
)
;
}
WinToastTemplate
toastTemplate
=
WinToastTemplate
(
WinToastTemplate
:
:
ImageAndText02
)
;
toastTemplate
.
setTextField
(
toastStrings
-
>
text1
.
get
(
)
WinToastTemplate
:
:
FirstLine
)
;
toastTemplate
.
setTextField
(
toastStrings
-
>
text2
.
get
(
)
WinToastTemplate
:
:
SecondLine
)
;
toastTemplate
.
addAction
(
toastStrings
-
>
action1
.
get
(
)
)
;
toastTemplate
.
addAction
(
toastStrings
-
>
action2
.
get
(
)
)
;
toastTemplate
.
setImagePath
(
absImagePath
.
get
(
)
)
;
ToastHandler
*
handler
=
new
ToastHandler
(
whichNotification
isEnglishInstall
event
.
get
(
)
)
;
INT64
id
=
WinToast
:
:
instance
(
)
-
>
showToast
(
toastTemplate
handler
&
error
)
;
if
(
id
<
0
)
{
LOG_ERROR_MESSAGE
(
WinToast
:
:
strerror
(
error
)
.
c_str
(
)
)
;
return
activitiesPerformed
;
}
DWORD
result
=
WaitForSingleObject
(
event
.
get
(
)
NOTIFICATION_WAIT_TIMEOUT_MS
)
;
if
(
result
=
=
WAIT_FAILED
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
wait
on
event
object
:
%
#
X
"
GetLastError
(
)
)
;
}
else
if
(
result
=
=
WAIT_TIMEOUT
)
{
LOG_ERROR_MESSAGE
(
L
"
Timed
out
waiting
for
event
object
"
)
;
}
else
{
result
=
WaitForSingleObject
(
gHandlerMutex
MUTEX_TIMEOUT_MS
)
;
if
(
result
=
=
WAIT_TIMEOUT
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
obtain
mutex
ownership
"
)
;
}
else
if
(
result
=
=
WAIT_FAILED
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
wait
on
mutex
:
%
#
X
"
GetLastError
(
)
)
;
}
else
if
(
result
=
=
WAIT_ABANDONED
)
{
LOG_ERROR_MESSAGE
(
L
"
Found
abandoned
mutex
"
)
;
ReleaseMutex
(
gHandlerMutex
)
;
}
else
{
if
(
gHandlerReturnData
.
handlerDataHasBeenSet
)
{
activitiesPerformed
=
gHandlerReturnData
.
activitiesPerformed
;
}
success
=
ReleaseMutex
(
gHandlerMutex
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
release
mutex
ownership
:
%
#
X
"
GetLastError
(
)
)
;
}
}
}
if
(
!
WinToast
:
:
instance
(
)
-
>
hideToast
(
id
)
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
hide
notification
"
)
;
}
return
activitiesPerformed
;
}
bool
FirefoxInstallIsEnglish
(
)
{
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
installPath
;
bool
success
=
GetInstallDirectory
(
installPath
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
get
install
directory
when
getting
strings
"
)
;
return
false
;
}
const
wchar_t
*
iniFormat
=
L
"
%
s
\
\
locale
.
ini
"
;
int
bufferSize
=
_scwprintf
(
iniFormat
installPath
.
get
(
)
)
;
+
+
bufferSize
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
iniPath
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
bufferSize
)
;
_snwprintf_s
(
iniPath
.
get
(
)
bufferSize
_TRUNCATE
iniFormat
installPath
.
get
(
)
)
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
firefoxLocale
;
if
(
!
GetString
(
iniPath
.
get
(
)
"
locale
"
"
locale
"
firefoxLocale
)
)
{
return
false
;
}
return
_wcsnicmp
(
firefoxLocale
.
get
(
)
L
"
en
-
"
3
)
=
=
0
;
}
NotificationActivities
MaybeShowNotification
(
const
DefaultBrowserInfo
&
browserInfo
const
wchar_t
*
aumi
)
{
NotificationActivities
activitiesPerformed
=
{
NotificationType
:
:
Initial
NotificationShown
:
:
NotShown
NotificationAction
:
:
NoAction
}
;
if
(
!
mozilla
:
:
IsWin10OrLater
(
)
)
{
return
activitiesPerformed
;
}
bool
initialNotificationShown
=
GetInitialNotificationShown
(
)
;
if
(
!
initialNotificationShown
)
{
if
(
browserInfo
.
currentDefaultBrowser
=
=
Browser
:
:
EdgeWithBlink
&
&
browserInfo
.
previousDefaultBrowser
=
=
Browser
:
:
Firefox
)
{
return
ShowNotification
(
NotificationType
:
:
Initial
aumi
)
;
}
return
activitiesPerformed
;
}
activitiesPerformed
.
type
=
NotificationType
:
:
Followup
;
ULONGLONG
followupNotificationRequestTime
=
GetFollowupNotificationRequestTime
(
)
;
bool
followupNotificationRequested
=
followupNotificationRequestTime
!
=
0
;
bool
followupNotificationShown
=
GetFollowupNotificationShown
(
)
;
if
(
followupNotificationRequested
&
&
!
followupNotificationShown
&
&
!
GetFollowupNotificationSuppressed
(
)
)
{
ULONGLONG
secondsSinceRequestTime
=
SecondsPassedSince
(
followupNotificationRequestTime
)
;
if
(
secondsSinceRequestTime
>
=
SEVEN_DAYS_IN_SECONDS
)
{
if
(
browserInfo
.
currentDefaultBrowser
=
=
Browser
:
:
EdgeWithBlink
)
{
return
ShowNotification
(
NotificationType
:
:
Followup
aumi
)
;
}
else
{
SetFollowupNotificationSuppressed
(
true
)
;
}
}
}
return
activitiesPerformed
;
}
std
:
:
string
GetStringForNotificationType
(
NotificationType
type
)
{
switch
(
type
)
{
case
NotificationType
:
:
Initial
:
return
std
:
:
string
(
"
initial
"
)
;
case
NotificationType
:
:
Followup
:
return
std
:
:
string
(
"
followup
"
)
;
}
}
std
:
:
string
GetStringForNotificationShown
(
NotificationShown
shown
)
{
switch
(
shown
)
{
case
NotificationShown
:
:
NotShown
:
return
std
:
:
string
(
"
not
-
shown
"
)
;
case
NotificationShown
:
:
Shown
:
return
std
:
:
string
(
"
shown
"
)
;
case
NotificationShown
:
:
Error
:
return
std
:
:
string
(
"
error
"
)
;
}
}
std
:
:
string
GetStringForNotificationAction
(
NotificationAction
action
)
{
switch
(
action
)
{
case
NotificationAction
:
:
DismissedByTimeout
:
return
std
:
:
string
(
"
dismissed
-
by
-
timeout
"
)
;
case
NotificationAction
:
:
DismissedToActionCenter
:
return
std
:
:
string
(
"
dismissed
-
to
-
action
-
center
"
)
;
case
NotificationAction
:
:
DismissedByButton
:
return
std
:
:
string
(
"
dismissed
-
by
-
button
"
)
;
case
NotificationAction
:
:
DismissedByApplicationHidden
:
return
std
:
:
string
(
"
dismissed
-
by
-
application
-
hidden
"
)
;
case
NotificationAction
:
:
RemindMeLater
:
return
std
:
:
string
(
"
remind
-
me
-
later
"
)
;
case
NotificationAction
:
:
MakeFirefoxDefaultButton
:
return
std
:
:
string
(
"
make
-
firefox
-
default
-
button
"
)
;
case
NotificationAction
:
:
ToastClicked
:
return
std
:
:
string
(
"
toast
-
clicked
"
)
;
case
NotificationAction
:
:
NoAction
:
return
std
:
:
string
(
"
no
-
action
"
)
;
}
}
