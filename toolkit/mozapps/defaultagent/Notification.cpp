#
include
"
Notification
.
h
"
#
include
<
shlwapi
.
h
>
#
include
<
wchar
.
h
>
#
include
<
windows
.
h
>
#
include
<
winnt
.
h
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
CmdLineAndEnvUtils
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
mscom
/
EnsureMTA
.
h
"
#
include
"
mozilla
/
intl
/
FileSource
.
h
"
#
include
"
mozilla
/
intl
/
Localization
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
readstrings
.
h
"
#
include
"
updatererrors
.
h
"
#
include
"
WindowsDefaultBrowser
.
h
"
#
include
"
common
.
h
"
#
include
"
DefaultBrowser
.
h
"
#
include
"
EventLog
.
h
"
#
include
"
Registry
.
h
"
#
include
"
SetDefaultBrowser
.
h
"
#
include
"
wintoastlib
.
h
"
using
mozilla
:
:
intl
:
:
Localization
;
#
define
SEVEN_DAYS_IN_SECONDS
(
7
*
24
*
60
*
60
)
#
define
NOTIFICATION_WAIT_TIMEOUT_MS
(
12
*
60
*
60
*
1000
)
#
define
MUTEX_TIMEOUT_MS
(
10
*
60
*
1000
)
namespace
mozilla
:
:
default_agent
{
bool
FirefoxInstallIsEnglish
(
)
;
static
bool
SetInitialNotificationShown
(
bool
wasShown
)
{
return
!
RegistrySetValueBool
(
IsPrefixed
:
:
Unprefixed
L
"
InitialNotificationShown
"
wasShown
)
.
isErr
(
)
;
}
static
bool
GetInitialNotificationShown
(
)
{
return
RegistryGetValueBool
(
IsPrefixed
:
:
Unprefixed
L
"
InitialNotificationShown
"
)
.
unwrapOr
(
mozilla
:
:
Some
(
false
)
)
.
valueOr
(
false
)
;
}
static
bool
ResetInitialNotificationShown
(
)
{
return
RegistryDeleteValue
(
IsPrefixed
:
:
Unprefixed
L
"
InitialNotificationShown
"
)
.
isOk
(
)
;
}
static
bool
SetFollowupNotificationShown
(
bool
wasShown
)
{
return
!
RegistrySetValueBool
(
IsPrefixed
:
:
Unprefixed
L
"
FollowupNotificationShown
"
wasShown
)
.
isErr
(
)
;
}
static
bool
GetFollowupNotificationShown
(
)
{
return
RegistryGetValueBool
(
IsPrefixed
:
:
Unprefixed
L
"
FollowupNotificationShown
"
)
.
unwrapOr
(
mozilla
:
:
Some
(
false
)
)
.
valueOr
(
false
)
;
}
static
bool
SetFollowupNotificationSuppressed
(
bool
value
)
{
return
!
RegistrySetValueBool
(
IsPrefixed
:
:
Unprefixed
L
"
FollowupNotificationSuppressed
"
value
)
.
isErr
(
)
;
}
static
bool
GetFollowupNotificationSuppressed
(
)
{
return
RegistryGetValueBool
(
IsPrefixed
:
:
Unprefixed
L
"
FollowupNotificationSuppressed
"
)
.
unwrapOr
(
mozilla
:
:
Some
(
false
)
)
.
valueOr
(
false
)
;
}
static
ULONGLONG
GetFollowupNotificationRequestTime
(
)
{
return
RegistryGetValueQword
(
IsPrefixed
:
:
Unprefixed
L
"
FollowupRequestTime
"
)
.
unwrapOr
(
mozilla
:
:
Some
(
0
)
)
.
valueOr
(
0
)
;
}
static
bool
GetPrefSetDefaultBrowserUserChoice
(
)
{
return
RegistryGetValueBool
(
IsPrefixed
:
:
Prefixed
L
"
SetDefaultBrowserUserChoice
"
)
.
unwrapOr
(
mozilla
:
:
Some
(
false
)
)
.
valueOr
(
false
)
;
}
struct
ToastStrings
{
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
text1
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
text2
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
action1
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
action2
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
relImagePath
;
}
;
struct
Strings
{
ToastStrings
initialToast
;
ToastStrings
followupToast
;
ToastStrings
localizedToast
;
const
ToastStrings
*
GetToastStrings
(
NotificationType
whichToast
bool
englishStrings
)
const
{
if
(
!
englishStrings
)
{
return
&
localizedToast
;
}
if
(
whichToast
=
=
NotificationType
:
:
Initial
)
{
return
&
initialToast
;
}
return
&
followupToast
;
}
}
;
static
bool
GetStrings
(
Strings
&
strings
)
{
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
installPath
;
bool
success
=
GetInstallDirectory
(
installPath
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
get
install
directory
when
getting
strings
"
)
;
return
false
;
}
nsTArray
<
nsCString
>
resIds
=
{
"
branding
/
brand
.
ftl
"
_ns
"
browser
/
backgroundtasks
/
defaultagent
.
ftl
"
_ns
}
;
RefPtr
<
Localization
>
l10n
=
Localization
:
:
Create
(
resIds
true
)
;
nsAutoCString
daHeaderText
daBodyText
daYesButton
daNoButton
;
mozilla
:
:
ErrorResult
daRv
;
l10n
-
>
FormatValueSync
(
"
default
-
browser
-
notification
-
header
-
text
"
_ns
{
}
daHeaderText
daRv
)
;
ENSURE_SUCCESS
(
daRv
false
)
;
l10n
-
>
FormatValueSync
(
"
default
-
browser
-
notification
-
body
-
text
"
_ns
{
}
daBodyText
daRv
)
;
ENSURE_SUCCESS
(
daRv
false
)
;
l10n
-
>
FormatValueSync
(
"
default
-
browser
-
notification
-
yes
-
button
-
text
"
_ns
{
}
daYesButton
daRv
)
;
ENSURE_SUCCESS
(
daRv
false
)
;
l10n
-
>
FormatValueSync
(
"
default
-
browser
-
notification
-
no
-
button
-
text
"
_ns
{
}
daNoButton
daRv
)
;
ENSURE_SUCCESS
(
daRv
false
)
;
NS_ConvertUTF8toUTF16
daHeaderTextW
(
daHeaderText
)
daBodyTextW
(
daBodyText
)
daYesButtonW
(
daYesButton
)
daNoButtonW
(
daNoButton
)
;
strings
.
localizedToast
.
text1
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
daHeaderTextW
.
Length
(
)
+
1
)
;
wcsncpy
(
strings
.
localizedToast
.
text1
.
get
(
)
daHeaderTextW
.
get
(
)
daHeaderTextW
.
Length
(
)
+
1
)
;
strings
.
localizedToast
.
text2
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
daBodyTextW
.
Length
(
)
+
1
)
;
wcsncpy
(
strings
.
localizedToast
.
text2
.
get
(
)
daBodyTextW
.
get
(
)
daBodyTextW
.
Length
(
)
+
1
)
;
strings
.
localizedToast
.
action1
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
daYesButtonW
.
Length
(
)
+
1
)
;
wcsncpy
(
strings
.
localizedToast
.
action1
.
get
(
)
daYesButtonW
.
get
(
)
daYesButtonW
.
Length
(
)
+
1
)
;
strings
.
localizedToast
.
action2
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
daNoButtonW
.
Length
(
)
+
1
)
;
wcsncpy
(
strings
.
localizedToast
.
action2
.
get
(
)
daNoButtonW
.
get
(
)
daNoButtonW
.
Length
(
)
+
1
)
;
const
wchar_t
*
iniFormat
=
L
"
%
s
\
\
defaultagent
.
ini
"
;
int
bufferSize
=
_scwprintf
(
iniFormat
installPath
.
get
(
)
)
;
+
+
bufferSize
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
iniPath
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
bufferSize
)
;
_snwprintf_s
(
iniPath
.
get
(
)
bufferSize
_TRUNCATE
iniFormat
installPath
.
get
(
)
)
;
IniReader
nonlocalizedReader
(
iniPath
.
get
(
)
"
Nonlocalized
"
)
;
nonlocalizedReader
.
AddKey
(
"
InitialToastRelativeImagePath
"
&
strings
.
initialToast
.
relImagePath
)
;
nonlocalizedReader
.
AddKey
(
"
FollowupToastRelativeImagePath
"
&
strings
.
followupToast
.
relImagePath
)
;
nonlocalizedReader
.
AddKey
(
"
LocalizedToastRelativeImagePath
"
&
strings
.
localizedToast
.
relImagePath
)
;
int
result
=
nonlocalizedReader
.
Read
(
)
;
if
(
result
!
=
OK
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
read
non
-
localized
strings
:
%
d
"
result
)
;
return
false
;
}
return
true
;
}
static
mozilla
:
:
WindowsError
LaunchFirefoxToHandleDefaultBrowserAgent
(
)
{
FilePathResult
firefoxPathResult
=
GetRelativeBinaryPath
(
L
"
firefox
.
exe
"
)
;
if
(
firefoxPathResult
.
isErr
(
)
)
{
return
firefoxPathResult
.
unwrapErr
(
)
;
}
std
:
:
wstring
firefoxPath
=
firefoxPathResult
.
unwrap
(
)
;
const
wchar_t
*
firefoxArgs
[
]
=
{
firefoxPath
.
c_str
(
)
L
"
-
to
-
handle
-
default
-
browser
-
agent
"
}
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
firefoxCmdLine
(
mozilla
:
:
MakeCommandLine
(
mozilla
:
:
ArrayLength
(
firefoxArgs
)
const_cast
<
wchar_t
*
*
>
(
firefoxArgs
)
)
)
;
PROCESS_INFORMATION
pi
;
STARTUPINFOW
si
=
{
sizeof
(
si
)
}
;
if
(
!
:
:
CreateProcessW
(
firefoxPath
.
c_str
(
)
firefoxCmdLine
.
get
(
)
nullptr
nullptr
false
DETACHED_PROCESS
|
NORMAL_PRIORITY_CLASS
nullptr
nullptr
&
si
&
pi
)
)
{
HRESULT
hr
=
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
LOG_ERROR
(
hr
)
;
return
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
;
}
CloseHandle
(
pi
.
hThread
)
;
CloseHandle
(
pi
.
hProcess
)
;
return
mozilla
:
:
WindowsError
:
:
CreateSuccess
(
)
;
}
static
void
SetDefaultBrowserFromNotification
(
const
wchar_t
*
aumi
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
if
(
GetPrefSetDefaultBrowserUserChoice
(
)
)
{
rv
=
SetDefaultBrowserUserChoice
(
aumi
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
mozilla
:
:
Unused
<
<
LaunchFirefoxToHandleDefaultBrowserAgent
(
)
;
}
else
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
SetDefaultBrowserUserChoice
:
%
#
X
"
GetLastError
(
)
)
;
LaunchModernSettingsDialogDefaultApps
(
)
;
}
}
struct
HandlerData
{
NotificationActivities
activitiesPerformed
;
bool
handlerDataHasBeenSet
;
}
;
static
HandlerData
gHandlerReturnData
;
static
HANDLE
gHandlerMutex
=
INVALID_HANDLE_VALUE
;
class
ToastHandler
:
public
WinToastLib
:
:
IWinToastHandler
{
private
:
NotificationType
mWhichNotification
;
HANDLE
mEvent
;
const
std
:
:
wstring
mAumiStr
;
public
:
ToastHandler
(
NotificationType
whichNotification
HANDLE
event
const
wchar_t
*
aumi
)
:
mWhichNotification
(
whichNotification
)
mEvent
(
event
)
mAumiStr
(
aumi
)
{
}
void
FinishHandler
(
NotificationActivities
&
returnData
)
const
{
SetReturnData
(
returnData
)
;
BOOL
success
=
SetEvent
(
mEvent
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Event
could
not
be
set
:
%
#
X
"
GetLastError
(
)
)
;
}
}
void
SetReturnData
(
NotificationActivities
&
toSet
)
const
{
DWORD
result
=
WaitForSingleObject
(
gHandlerMutex
MUTEX_TIMEOUT_MS
)
;
if
(
result
=
=
WAIT_TIMEOUT
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
obtain
mutex
ownership
"
)
;
return
;
}
else
if
(
result
=
=
WAIT_FAILED
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
wait
on
mutex
:
%
#
X
"
GetLastError
(
)
)
;
return
;
}
else
if
(
result
=
=
WAIT_ABANDONED
)
{
LOG_ERROR_MESSAGE
(
L
"
Found
abandoned
mutex
"
)
;
ReleaseMutex
(
gHandlerMutex
)
;
return
;
}
if
(
!
gHandlerReturnData
.
handlerDataHasBeenSet
)
{
gHandlerReturnData
.
activitiesPerformed
=
toSet
;
gHandlerReturnData
.
handlerDataHasBeenSet
=
true
;
}
BOOL
success
=
ReleaseMutex
(
gHandlerMutex
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
release
mutex
ownership
:
%
#
X
"
GetLastError
(
)
)
;
}
}
void
toastActivated
(
)
const
override
{
NotificationActivities
activitiesPerformed
;
activitiesPerformed
.
type
=
mWhichNotification
;
activitiesPerformed
.
shown
=
NotificationShown
:
:
Shown
;
activitiesPerformed
.
action
=
NotificationAction
:
:
ToastClicked
;
SetDefaultBrowserFromNotification
(
mAumiStr
.
c_str
(
)
)
;
FinishHandler
(
activitiesPerformed
)
;
}
void
toastActivated
(
int
actionIndex
)
const
override
{
NotificationActivities
activitiesPerformed
;
activitiesPerformed
.
type
=
mWhichNotification
;
activitiesPerformed
.
shown
=
NotificationShown
:
:
Shown
;
activitiesPerformed
.
action
=
NotificationAction
:
:
NoAction
;
if
(
actionIndex
=
=
0
)
{
activitiesPerformed
.
action
=
NotificationAction
:
:
MakeFirefoxDefaultButton
;
SetDefaultBrowserFromNotification
(
mAumiStr
.
c_str
(
)
)
;
}
else
if
(
actionIndex
=
=
1
)
{
activitiesPerformed
.
action
=
NotificationAction
:
:
DismissedByButton
;
}
FinishHandler
(
activitiesPerformed
)
;
}
void
toastDismissed
(
WinToastDismissalReason
state
)
const
override
{
NotificationActivities
activitiesPerformed
;
activitiesPerformed
.
type
=
mWhichNotification
;
activitiesPerformed
.
shown
=
NotificationShown
:
:
Shown
;
activitiesPerformed
.
action
=
NotificationAction
:
:
NoAction
;
if
(
state
=
=
WinToastDismissalReason
:
:
TimedOut
)
{
activitiesPerformed
.
action
=
NotificationAction
:
:
DismissedByTimeout
;
}
else
if
(
state
=
=
WinToastDismissalReason
:
:
ApplicationHidden
)
{
activitiesPerformed
.
action
=
NotificationAction
:
:
DismissedByApplicationHidden
;
}
else
if
(
state
=
=
WinToastDismissalReason
:
:
UserCanceled
)
{
activitiesPerformed
.
action
=
NotificationAction
:
:
DismissedToActionCenter
;
}
FinishHandler
(
activitiesPerformed
)
;
}
void
toastFailed
(
)
const
override
{
NotificationActivities
activitiesPerformed
;
activitiesPerformed
.
type
=
mWhichNotification
;
activitiesPerformed
.
shown
=
NotificationShown
:
:
Error
;
activitiesPerformed
.
action
=
NotificationAction
:
:
NoAction
;
LOG_ERROR_MESSAGE
(
L
"
Toast
notification
failed
to
display
"
)
;
FinishHandler
(
activitiesPerformed
)
;
}
}
;
static
NotificationActivities
ShowNotification
(
NotificationType
whichNotification
const
wchar_t
*
aumi
)
{
NotificationActivities
activitiesPerformed
=
{
whichNotification
NotificationShown
:
:
Error
NotificationAction
:
:
NoAction
}
;
bool
isEnglishInstall
=
FirefoxInstallIsEnglish
(
)
;
Strings
strings
;
if
(
!
GetStrings
(
strings
)
)
{
return
activitiesPerformed
;
}
const
ToastStrings
*
toastStrings
=
strings
.
GetToastStrings
(
whichNotification
isEnglishInstall
)
;
mozilla
:
:
mscom
:
:
EnsureMTA
(
[
&
]
{
using
namespace
WinToastLib
;
if
(
!
WinToast
:
:
isCompatible
(
)
)
{
LOG_ERROR_MESSAGE
(
L
"
System
is
not
compatible
with
WinToast
"
)
;
return
;
}
WinToast
:
:
instance
(
)
-
>
setAppName
(
L
"
"
MOZ_APP_DISPLAYNAME
)
;
std
:
:
wstring
aumiStr
=
aumi
;
WinToast
:
:
instance
(
)
-
>
setAppUserModelId
(
aumiStr
)
;
WinToast
:
:
instance
(
)
-
>
setShortcutPolicy
(
WinToastLib
:
:
WinToast
:
:
SHORTCUT_POLICY_REQUIRE_NO_CREATE
)
;
WinToast
:
:
WinToastError
error
;
if
(
!
WinToast
:
:
instance
(
)
-
>
initialize
(
&
error
)
)
{
LOG_ERROR_MESSAGE
(
WinToast
:
:
strerror
(
error
)
.
c_str
(
)
)
;
return
;
}
nsAutoHandle
event
(
CreateEventW
(
nullptr
TRUE
FALSE
nullptr
)
)
;
if
(
event
.
get
(
)
=
=
nullptr
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
create
event
object
:
%
#
X
"
GetLastError
(
)
)
;
return
;
}
bool
success
=
false
;
if
(
whichNotification
=
=
NotificationType
:
:
Initial
)
{
success
=
SetInitialNotificationShown
(
true
)
;
}
else
{
success
=
SetFollowupNotificationShown
(
true
)
;
}
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
set
notification
as
displayed
"
)
;
return
;
}
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
installPath
;
success
=
GetInstallDirectory
(
installPath
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
get
install
directory
for
the
image
path
"
)
;
return
;
}
const
wchar_t
*
absPathFormat
=
L
"
%
s
\
\
%
s
"
;
int
bufferSize
=
_scwprintf
(
absPathFormat
installPath
.
get
(
)
toastStrings
-
>
relImagePath
.
get
(
)
)
;
+
+
bufferSize
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
absImagePath
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
bufferSize
)
;
_snwprintf_s
(
absImagePath
.
get
(
)
bufferSize
_TRUNCATE
absPathFormat
installPath
.
get
(
)
toastStrings
-
>
relImagePath
.
get
(
)
)
;
gHandlerMutex
=
CreateMutexW
(
nullptr
TRUE
nullptr
)
;
if
(
gHandlerMutex
=
=
nullptr
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
create
mutex
:
%
#
X
"
GetLastError
(
)
)
;
return
;
}
nsAutoHandle
autoMutex
(
gHandlerMutex
)
;
gHandlerReturnData
.
handlerDataHasBeenSet
=
false
;
success
=
ReleaseMutex
(
gHandlerMutex
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
release
mutex
ownership
:
%
#
X
"
GetLastError
(
)
)
;
}
WinToastTemplate
toastTemplate
=
WinToastTemplate
(
WinToastTemplate
:
:
ImageAndText02
)
;
toastTemplate
.
setTextField
(
toastStrings
-
>
text1
.
get
(
)
WinToastTemplate
:
:
FirstLine
)
;
toastTemplate
.
setTextField
(
toastStrings
-
>
text2
.
get
(
)
WinToastTemplate
:
:
SecondLine
)
;
toastTemplate
.
addAction
(
toastStrings
-
>
action1
.
get
(
)
)
;
toastTemplate
.
addAction
(
toastStrings
-
>
action2
.
get
(
)
)
;
toastTemplate
.
setImagePath
(
absImagePath
.
get
(
)
)
;
toastTemplate
.
setScenario
(
WinToastTemplate
:
:
Scenario
:
:
Reminder
)
;
ToastHandler
*
handler
=
new
ToastHandler
(
whichNotification
event
.
get
(
)
aumi
)
;
INT64
id
=
WinToast
:
:
instance
(
)
-
>
showToast
(
toastTemplate
handler
&
error
)
;
if
(
id
<
0
)
{
LOG_ERROR_MESSAGE
(
WinToast
:
:
strerror
(
error
)
.
c_str
(
)
)
;
return
;
}
DWORD
result
=
WaitForSingleObject
(
event
.
get
(
)
NOTIFICATION_WAIT_TIMEOUT_MS
)
;
if
(
result
=
=
WAIT_FAILED
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
wait
on
event
object
:
%
#
X
"
GetLastError
(
)
)
;
}
else
if
(
result
=
=
WAIT_TIMEOUT
)
{
LOG_ERROR_MESSAGE
(
L
"
Timed
out
waiting
for
event
object
"
)
;
}
else
{
result
=
WaitForSingleObject
(
gHandlerMutex
MUTEX_TIMEOUT_MS
)
;
if
(
result
=
=
WAIT_TIMEOUT
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
obtain
mutex
ownership
"
)
;
}
else
if
(
result
=
=
WAIT_FAILED
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
wait
on
mutex
:
%
#
X
"
GetLastError
(
)
)
;
}
else
if
(
result
=
=
WAIT_ABANDONED
)
{
LOG_ERROR_MESSAGE
(
L
"
Found
abandoned
mutex
"
)
;
ReleaseMutex
(
gHandlerMutex
)
;
}
else
{
if
(
gHandlerReturnData
.
handlerDataHasBeenSet
)
{
activitiesPerformed
=
gHandlerReturnData
.
activitiesPerformed
;
}
success
=
ReleaseMutex
(
gHandlerMutex
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Unable
to
release
mutex
ownership
:
%
#
X
"
GetLastError
(
)
)
;
}
}
}
if
(
!
WinToast
:
:
instance
(
)
-
>
hideToast
(
id
)
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
hide
notification
"
)
;
}
}
)
;
return
activitiesPerformed
;
}
bool
FirefoxInstallIsEnglish
(
)
{
return
false
;
}
NotificationActivities
MaybeShowNotification
(
const
DefaultBrowserInfo
&
browserInfo
const
wchar_t
*
aumi
bool
force
)
{
NotificationActivities
activitiesPerformed
=
{
NotificationType
:
:
Initial
NotificationShown
:
:
NotShown
NotificationAction
:
:
NoAction
}
;
if
(
browserInfo
.
currentDefaultBrowser
=
=
Browser
:
:
Firefox
)
{
ResetInitialNotificationShown
(
)
;
}
bool
initialNotificationShown
=
GetInitialNotificationShown
(
)
;
if
(
!
initialNotificationShown
|
|
force
)
{
if
(
(
browserInfo
.
currentDefaultBrowser
=
=
Browser
:
:
EdgeWithBlink
&
&
browserInfo
.
previousDefaultBrowser
=
=
Browser
:
:
Firefox
)
|
|
force
)
{
return
ShowNotification
(
NotificationType
:
:
Initial
aumi
)
;
}
return
activitiesPerformed
;
}
activitiesPerformed
.
type
=
NotificationType
:
:
Followup
;
ULONGLONG
followupNotificationRequestTime
=
GetFollowupNotificationRequestTime
(
)
;
bool
followupNotificationRequested
=
followupNotificationRequestTime
!
=
0
;
bool
followupNotificationShown
=
GetFollowupNotificationShown
(
)
;
if
(
followupNotificationRequested
&
&
!
followupNotificationShown
&
&
!
GetFollowupNotificationSuppressed
(
)
)
{
ULONGLONG
secondsSinceRequestTime
=
SecondsPassedSince
(
followupNotificationRequestTime
)
;
if
(
secondsSinceRequestTime
>
=
SEVEN_DAYS_IN_SECONDS
)
{
if
(
browserInfo
.
currentDefaultBrowser
=
=
Browser
:
:
EdgeWithBlink
)
{
return
ShowNotification
(
NotificationType
:
:
Followup
aumi
)
;
}
else
{
SetFollowupNotificationSuppressed
(
true
)
;
}
}
}
return
activitiesPerformed
;
}
std
:
:
string
GetStringForNotificationType
(
NotificationType
type
)
{
switch
(
type
)
{
case
NotificationType
:
:
Initial
:
return
std
:
:
string
(
"
initial
"
)
;
case
NotificationType
:
:
Followup
:
return
std
:
:
string
(
"
followup
"
)
;
}
}
std
:
:
string
GetStringForNotificationShown
(
NotificationShown
shown
)
{
switch
(
shown
)
{
case
NotificationShown
:
:
NotShown
:
return
std
:
:
string
(
"
not
-
shown
"
)
;
case
NotificationShown
:
:
Shown
:
return
std
:
:
string
(
"
shown
"
)
;
case
NotificationShown
:
:
Error
:
return
std
:
:
string
(
"
error
"
)
;
}
}
std
:
:
string
GetStringForNotificationAction
(
NotificationAction
action
)
{
switch
(
action
)
{
case
NotificationAction
:
:
DismissedByTimeout
:
return
std
:
:
string
(
"
dismissed
-
by
-
timeout
"
)
;
case
NotificationAction
:
:
DismissedToActionCenter
:
return
std
:
:
string
(
"
dismissed
-
to
-
action
-
center
"
)
;
case
NotificationAction
:
:
DismissedByButton
:
return
std
:
:
string
(
"
dismissed
-
by
-
button
"
)
;
case
NotificationAction
:
:
DismissedByApplicationHidden
:
return
std
:
:
string
(
"
dismissed
-
by
-
application
-
hidden
"
)
;
case
NotificationAction
:
:
RemindMeLater
:
return
std
:
:
string
(
"
remind
-
me
-
later
"
)
;
case
NotificationAction
:
:
MakeFirefoxDefaultButton
:
return
std
:
:
string
(
"
make
-
firefox
-
default
-
button
"
)
;
case
NotificationAction
:
:
ToastClicked
:
return
std
:
:
string
(
"
toast
-
clicked
"
)
;
case
NotificationAction
:
:
NoAction
:
return
std
:
:
string
(
"
no
-
action
"
)
;
}
}
void
EnsureValidNotificationAction
(
std
:
:
string
&
actionString
)
{
if
(
actionString
!
=
"
dismissed
-
by
-
timeout
"
&
&
actionString
!
=
"
dismissed
-
to
-
action
-
center
"
&
&
actionString
!
=
"
dismissed
-
by
-
button
"
&
&
actionString
!
=
"
dismissed
-
by
-
application
-
hidden
"
&
&
actionString
!
=
"
remind
-
me
-
later
"
&
&
actionString
!
=
"
make
-
firefox
-
default
-
button
"
&
&
actionString
!
=
"
toast
-
clicked
"
&
&
actionString
!
=
"
no
-
action
"
)
{
actionString
=
"
no
-
action
"
;
}
}
}
