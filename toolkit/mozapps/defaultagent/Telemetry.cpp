#
include
"
Telemetry
.
h
"
#
include
<
fstream
>
#
include
<
string
>
#
include
<
windows
.
h
>
#
include
"
common
.
h
"
#
include
"
EventLog
.
h
"
#
include
"
Notification
.
h
"
#
include
"
Policy
.
h
"
#
include
"
UtfConvert
.
h
"
#
include
"
json
/
json
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
CmdLineAndEnvUtils
.
h
"
#
include
"
mozilla
/
HelperMacros
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
define
TELEMETRY_BASE_URL
"
https
:
/
/
incoming
.
telemetry
.
mozilla
.
org
/
submit
"
#
define
TELEMETRY_NAMESPACE
"
default
-
browser
-
agent
"
#
define
TELEMETRY_PING_VERSION
"
1
"
#
define
TELEMETRY_PING_DOCTYPE
"
default
-
browser
"
#
define
TELEMETRY_PING_URL
\
TELEMETRY_BASE_URL
"
/
"
TELEMETRY_NAMESPACE
"
/
"
TELEMETRY_PING_DOCTYPE
\
"
/
"
TELEMETRY_PING_VERSION
"
/
"
#
define
MINIMUM_PING_PERIOD_SEC
(
(
23
*
60
*
60
)
+
(
45
*
60
)
)
#
define
PREV_NOTIFICATION_ACTION_REG_NAME
L
"
PrevNotificationAction
"
#
if
!
defined
(
RRF_SUBKEY_WOW6464KEY
)
#
define
RRF_SUBKEY_WOW6464KEY
0x00010000
#
endif
using
TelemetryFieldResult
=
mozilla
:
:
WindowsErrorResult
<
std
:
:
string
>
;
using
BoolResult
=
mozilla
:
:
WindowsErrorResult
<
bool
>
;
static
bool
IsOfficialTelemetry
(
)
{
#
if
defined
(
MOZILLA_OFFICIAL
)
&
&
defined
(
MOZ_TELEMETRY_REPORTING
)
&
&
\
!
defined
(
DEBUG
)
return
true
;
#
else
return
false
;
#
endif
}
static
TelemetryFieldResult
GetOSVersion
(
)
{
OSVERSIONINFOEXW
osv
=
{
sizeof
(
osv
)
}
;
if
(
:
:
GetVersionExW
(
reinterpret_cast
<
OSVERSIONINFOW
*
>
(
&
osv
)
)
)
{
std
:
:
ostringstream
oss
;
oss
<
<
osv
.
dwMajorVersion
<
<
"
.
"
<
<
osv
.
dwMinorVersion
<
<
"
.
"
<
<
osv
.
dwBuildNumber
;
if
(
osv
.
dwMajorVersion
=
=
10
&
&
osv
.
dwMinorVersion
=
=
0
)
{
DWORD
ubrValue
;
DWORD
ubrValueLen
=
sizeof
(
ubrValue
)
;
LSTATUS
ubrOk
=
:
:
RegGetValueW
(
HKEY_LOCAL_MACHINE
L
"
SOFTWARE
\
\
Microsoft
\
\
Windows
NT
\
\
CurrentVersion
"
L
"
UBR
"
RRF_RT_DWORD
|
RRF_SUBKEY_WOW6464KEY
nullptr
&
ubrValue
&
ubrValueLen
)
;
if
(
ubrOk
=
=
ERROR_SUCCESS
)
{
oss
<
<
"
.
"
<
<
ubrValue
;
}
}
return
oss
.
str
(
)
;
}
HRESULT
hr
=
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
LOG_ERROR
(
hr
)
;
return
TelemetryFieldResult
(
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
)
;
}
static
TelemetryFieldResult
GetOSLocale
(
)
{
wchar_t
localeName
[
LOCALE_NAME_MAX_LENGTH
]
=
L
"
"
;
if
(
!
GetUserDefaultLocaleName
(
localeName
LOCALE_NAME_MAX_LENGTH
)
)
{
HRESULT
hr
=
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
LOG_ERROR
(
hr
)
;
return
TelemetryFieldResult
(
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
)
;
}
Utf16ToUtf8Result
narrowLocaleName
=
Utf16ToUtf8
(
localeName
)
;
return
narrowLocaleName
.
unwrapOr
(
"
"
)
;
}
static
FilePathResult
GetPingFilePath
(
std
:
:
wstring
&
uuid
)
{
wchar_t
*
rawAppDataPath
;
HRESULT
hr
=
SHGetKnownFolderPath
(
FOLDERID_RoamingAppData
0
nullptr
&
rawAppDataPath
)
;
if
(
FAILED
(
hr
)
)
{
LOG_ERROR
(
hr
)
;
return
FilePathResult
(
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
)
;
}
mozilla
:
:
UniquePtr
<
wchar_t
mozilla
:
:
CoTaskMemFreeDeleter
>
appDataPath
(
rawAppDataPath
)
;
hr
=
HRESULT_FROM_WIN32
(
ERROR_INSUFFICIENT_BUFFER
)
;
wchar_t
pingFilePath
[
MAX_PATH
]
=
L
"
"
;
if
(
!
PathCombineW
(
pingFilePath
appDataPath
.
get
(
)
L
"
"
MOZ_APP_VENDOR
)
)
{
LOG_ERROR
(
hr
)
;
return
FilePathResult
(
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
)
;
}
if
(
!
PathAppendW
(
pingFilePath
L
"
"
MOZ_APP_BASENAME
)
)
{
LOG_ERROR
(
hr
)
;
return
FilePathResult
(
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
)
;
}
if
(
!
PathAppendW
(
pingFilePath
L
"
Pending
Pings
"
)
)
{
LOG_ERROR
(
hr
)
;
return
FilePathResult
(
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
)
;
}
if
(
!
PathAppendW
(
pingFilePath
uuid
.
c_str
(
)
)
)
{
LOG_ERROR
(
hr
)
;
return
FilePathResult
(
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
)
;
}
return
std
:
:
wstring
(
pingFilePath
)
;
}
static
FilePathResult
GetPingsenderPath
(
)
{
HRESULT
hr
=
HRESULT_FROM_WIN32
(
ERROR_INSUFFICIENT_BUFFER
)
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
thisBinaryPath
=
mozilla
:
:
GetFullBinaryPath
(
)
;
if
(
!
PathRemoveFileSpecW
(
thisBinaryPath
.
get
(
)
)
)
{
LOG_ERROR
(
hr
)
;
return
FilePathResult
(
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
)
;
}
wchar_t
pingsenderPath
[
MAX_PATH
]
=
L
"
"
;
if
(
!
PathCombineW
(
pingsenderPath
thisBinaryPath
.
get
(
)
L
"
pingsender
.
exe
"
)
)
{
LOG_ERROR
(
hr
)
;
return
FilePathResult
(
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
)
;
}
return
std
:
:
wstring
(
pingsenderPath
)
;
}
static
mozilla
:
:
WindowsError
SendPing
(
const
std
:
:
string
defaultBrowser
const
std
:
:
string
previousDefaultBrowser
const
std
:
:
string
defaultPdf
const
std
:
:
string
osVersion
const
std
:
:
string
osLocale
const
std
:
:
string
notificationType
const
std
:
:
string
notificationShown
const
std
:
:
string
notificationAction
const
std
:
:
string
notificationNotShownReason
const
std
:
:
string
prevNotificationAction
)
{
Json
:
:
Value
ping
;
ping
[
"
build_channel
"
]
=
MOZ_STRINGIFY
(
MOZ_UPDATE_CHANNEL
)
;
ping
[
"
build_version
"
]
=
MOZILLA_VERSION
;
ping
[
"
default_browser
"
]
=
defaultBrowser
;
ping
[
"
previous_default_browser
"
]
=
previousDefaultBrowser
;
ping
[
"
default_pdf_viewer_raw
"
]
=
defaultPdf
;
ping
[
"
os_version
"
]
=
osVersion
;
ping
[
"
os_locale
"
]
=
osLocale
;
ping
[
"
notification_type
"
]
=
notificationType
;
ping
[
"
notification_shown
"
]
=
notificationShown
;
ping
[
"
notification_action
"
]
=
notificationAction
;
ping
[
"
notification_not_shown_reason
"
]
=
notificationNotShownReason
;
ping
[
"
previous_notification_action
"
]
=
prevNotificationAction
;
Json
:
:
StreamWriterBuilder
jsonStream
;
jsonStream
[
"
indentation
"
]
=
"
"
;
std
:
:
string
pingStr
=
Json
:
:
writeString
(
jsonStream
ping
)
;
FilePathResult
uuidResult
=
GenerateUUIDStr
(
)
;
if
(
uuidResult
.
isErr
(
)
)
{
return
uuidResult
.
unwrapErr
(
)
;
}
std
:
:
wstring
uuid
=
uuidResult
.
unwrap
(
)
;
FilePathResult
pingFilePathResult
=
GetPingFilePath
(
uuid
)
;
if
(
pingFilePathResult
.
isErr
(
)
)
{
return
pingFilePathResult
.
unwrapErr
(
)
;
}
std
:
:
wstring
pingFilePath
=
pingFilePathResult
.
unwrap
(
)
;
{
std
:
:
ofstream
outFile
(
pingFilePath
)
;
outFile
<
<
pingStr
;
if
(
outFile
.
fail
(
)
)
{
HRESULT
hr
=
HRESULT_FROM_WIN32
(
ERROR_IO_DEVICE
)
;
LOG_ERROR
(
hr
)
;
return
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
;
}
}
FilePathResult
pingsenderPathResult
=
GetPingsenderPath
(
)
;
if
(
pingsenderPathResult
.
isErr
(
)
)
{
return
pingsenderPathResult
.
unwrapErr
(
)
;
}
std
:
:
wstring
pingsenderPath
=
pingsenderPathResult
.
unwrap
(
)
;
std
:
:
wstring
url
(
L
"
"
TELEMETRY_PING_URL
)
;
url
.
append
(
uuid
)
;
const
wchar_t
*
pingsenderArgs
[
]
=
{
pingsenderPath
.
c_str
(
)
url
.
c_str
(
)
pingFilePath
.
c_str
(
)
}
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
pingsenderCmdLine
(
mozilla
:
:
MakeCommandLine
(
mozilla
:
:
ArrayLength
(
pingsenderArgs
)
const_cast
<
wchar_t
*
*
>
(
pingsenderArgs
)
)
)
;
PROCESS_INFORMATION
pi
;
STARTUPINFOW
si
=
{
sizeof
(
si
)
}
;
si
.
dwFlags
=
STARTF_USESHOWWINDOW
;
si
.
wShowWindow
=
SW_HIDE
;
if
(
!
:
:
CreateProcessW
(
pingsenderPath
.
c_str
(
)
pingsenderCmdLine
.
get
(
)
nullptr
nullptr
FALSE
0
nullptr
nullptr
&
si
&
pi
)
)
{
HRESULT
hr
=
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
LOG_ERROR
(
hr
)
;
return
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
;
}
CloseHandle
(
pi
.
hThread
)
;
CloseHandle
(
pi
.
hProcess
)
;
return
mozilla
:
:
WindowsError
:
:
CreateSuccess
(
)
;
}
static
BoolResult
GetPingAlreadySentToday
(
)
{
const
wchar_t
*
valueName
=
L
"
LastPingSentAt
"
;
MaybeQwordResult
readResult
=
RegistryGetValueQword
(
IsPrefixed
:
:
Unprefixed
valueName
)
;
if
(
readResult
.
isErr
(
)
)
{
HRESULT
hr
=
readResult
.
unwrapErr
(
)
.
AsHResult
(
)
;
LOG_ERROR_MESSAGE
(
L
"
Unable
to
read
registry
:
%
#
X
"
hr
)
;
return
BoolResult
(
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
)
;
}
mozilla
:
:
Maybe
<
ULONGLONG
>
maybeValue
=
readResult
.
unwrap
(
)
;
ULONGLONG
now
=
GetCurrentTimestamp
(
)
;
if
(
maybeValue
.
isSome
(
)
)
{
ULONGLONG
lastPingTime
=
maybeValue
.
value
(
)
;
if
(
SecondsPassedSince
(
lastPingTime
now
)
<
MINIMUM_PING_PERIOD_SEC
)
{
return
true
;
}
}
mozilla
:
:
WindowsErrorResult
<
mozilla
:
:
Ok
>
writeResult
=
RegistrySetValueQword
(
IsPrefixed
:
:
Unprefixed
valueName
now
)
;
if
(
writeResult
.
isErr
(
)
)
{
HRESULT
hr
=
readResult
.
unwrapErr
(
)
.
AsHResult
(
)
;
LOG_ERROR_MESSAGE
(
L
"
Unable
to
write
registry
:
%
#
X
"
hr
)
;
return
BoolResult
(
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
)
;
}
return
false
;
}
static
TelemetryFieldResult
GetAndUpdatePreviousDefaultBrowser
(
const
std
:
:
string
&
currentDefault
Browser
prevDefault
)
{
const
wchar_t
*
registryValueName
=
L
"
PingCurrentDefault
"
;
MaybeStringResult
readResult
=
RegistryGetValueString
(
IsPrefixed
:
:
Unprefixed
registryValueName
)
;
if
(
readResult
.
isErr
(
)
)
{
HRESULT
hr
=
readResult
.
unwrapErr
(
)
.
AsHResult
(
)
;
LOG_ERROR_MESSAGE
(
L
"
Unable
to
read
registry
:
%
#
X
"
hr
)
;
return
TelemetryFieldResult
(
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
)
;
}
mozilla
:
:
Maybe
<
std
:
:
string
>
maybeValue
=
readResult
.
unwrap
(
)
;
std
:
:
string
oldCurrentDefault
;
if
(
maybeValue
.
isSome
(
)
)
{
oldCurrentDefault
=
maybeValue
.
value
(
)
;
}
else
{
oldCurrentDefault
=
GetStringForBrowser
(
prevDefault
)
;
}
mozilla
:
:
WindowsErrorResult
<
mozilla
:
:
Ok
>
writeResult
=
RegistrySetValueString
(
IsPrefixed
:
:
Unprefixed
registryValueName
currentDefault
.
c_str
(
)
)
;
if
(
writeResult
.
isErr
(
)
)
{
HRESULT
hr
=
writeResult
.
unwrapErr
(
)
.
AsHResult
(
)
;
LOG_ERROR_MESSAGE
(
L
"
Unable
to
write
registry
:
%
#
X
"
hr
)
;
return
TelemetryFieldResult
(
mozilla
:
:
WindowsError
:
:
FromHResult
(
hr
)
)
;
}
return
oldCurrentDefault
;
}
HRESULT
MaybeCache
(
Cache
&
cache
const
std
:
:
string
&
notificationType
const
std
:
:
string
&
notificationShown
const
std
:
:
string
&
notificationAction
const
std
:
:
string
&
prevNotificationAction
)
{
std
:
:
string
notShown
=
GetStringForNotificationShown
(
NotificationShown
:
:
NotShown
)
;
if
(
notificationShown
=
=
notShown
)
{
return
S_OK
;
}
Cache
:
:
Entry
entry
{
.
notificationType
=
notificationType
.
notificationShown
=
notificationShown
.
notificationAction
=
notificationAction
.
prevNotificationAction
=
prevNotificationAction
}
;
VoidResult
result
=
cache
.
Enqueue
(
entry
)
;
if
(
result
.
isErr
(
)
)
{
return
result
.
unwrapErr
(
)
.
AsHResult
(
)
;
}
return
S_OK
;
}
HRESULT
MaybeSwapForCached
(
Cache
&
cache
std
:
:
string
&
notificationType
std
:
:
string
&
notificationShown
std
:
:
string
&
notificationAction
std
:
:
string
&
notificationNotShownReason
std
:
:
string
&
prevNotificationAction
)
{
Cache
:
:
MaybeEntryResult
result
=
cache
.
Dequeue
(
)
;
if
(
result
.
isErr
(
)
)
{
HRESULT
hr
=
result
.
unwrapErr
(
)
.
AsHResult
(
)
;
LOG_ERROR_MESSAGE
(
L
"
Failed
to
read
cache
:
%
#
X
"
hr
)
;
return
hr
;
}
Cache
:
:
MaybeEntry
maybeEntry
=
result
.
unwrap
(
)
;
if
(
maybeEntry
.
isNothing
(
)
)
{
return
S_OK
;
}
MaybeCache
(
cache
notificationType
notificationShown
notificationAction
prevNotificationAction
)
;
notificationType
=
maybeEntry
.
value
(
)
.
notificationType
;
notificationShown
=
maybeEntry
.
value
(
)
.
notificationShown
;
notificationAction
=
maybeEntry
.
value
(
)
.
notificationAction
;
notificationNotShownReason
=
GetStringForNotificationNotShownReason
(
NotificationNotShownReason
:
:
NotApplicable
)
;
if
(
maybeEntry
.
value
(
)
.
prevNotificationAction
.
isSome
(
)
)
{
prevNotificationAction
=
maybeEntry
.
value
(
)
.
prevNotificationAction
.
value
(
)
;
}
else
{
prevNotificationAction
=
GetStringForNotificationAction
(
NotificationAction
:
:
NoAction
)
;
}
return
S_OK
;
}
HRESULT
ReadPreviousNotificationAction
(
std
:
:
string
&
prevAction
)
{
MaybeStringResult
maybePrevActionResult
=
RegistryGetValueString
(
IsPrefixed
:
:
Unprefixed
PREV_NOTIFICATION_ACTION_REG_NAME
)
;
if
(
maybePrevActionResult
.
isErr
(
)
)
{
HRESULT
hr
=
maybePrevActionResult
.
unwrapErr
(
)
.
AsHResult
(
)
;
LOG_ERROR_MESSAGE
(
L
"
Unable
to
read
prev
action
from
registry
:
%
#
X
"
hr
)
;
return
hr
;
}
mozilla
:
:
Maybe
<
std
:
:
string
>
maybePrevAction
=
maybePrevActionResult
.
unwrap
(
)
;
if
(
maybePrevAction
.
isNothing
(
)
)
{
prevAction
=
GetStringForNotificationAction
(
NotificationAction
:
:
NoAction
)
;
}
else
{
prevAction
=
maybePrevAction
.
value
(
)
;
EnsureValidNotificationAction
(
prevAction
)
;
}
return
S_OK
;
}
HRESULT
MaybeWritePreviousNotificationAction
(
const
NotificationActivities
&
activitiesPerformed
)
{
if
(
activitiesPerformed
.
shown
!
=
NotificationShown
:
:
Shown
)
{
return
S_OK
;
}
std
:
:
string
notificationAction
=
GetStringForNotificationAction
(
activitiesPerformed
.
action
)
;
mozilla
:
:
WindowsErrorResult
<
mozilla
:
:
Ok
>
result
=
RegistrySetValueString
(
IsPrefixed
:
:
Unprefixed
PREV_NOTIFICATION_ACTION_REG_NAME
notificationAction
.
c_str
(
)
)
;
if
(
result
.
isErr
(
)
)
{
HRESULT
hr
=
result
.
unwrapErr
(
)
.
AsHResult
(
)
;
LOG_ERROR_MESSAGE
(
L
"
Unable
to
write
prev
action
to
registry
:
%
#
X
"
hr
)
;
return
hr
;
}
return
S_OK
;
}
HRESULT
SendDefaultBrowserPing
(
const
DefaultBrowserInfo
&
browserInfo
const
DefaultPdfInfo
&
pdfInfo
const
NotificationActivities
&
activitiesPerformed
)
{
std
:
:
string
currentDefaultBrowser
=
GetStringForBrowser
(
browserInfo
.
currentDefaultBrowser
)
;
std
:
:
string
currentDefaultPdf
=
pdfInfo
.
currentDefaultPdf
;
std
:
:
string
notificationType
=
GetStringForNotificationType
(
activitiesPerformed
.
type
)
;
std
:
:
string
notificationShown
=
GetStringForNotificationShown
(
activitiesPerformed
.
shown
)
;
std
:
:
string
notificationAction
=
GetStringForNotificationAction
(
activitiesPerformed
.
action
)
;
std
:
:
string
notificationNotShownReason
=
GetStringForNotificationNotShownReason
(
activitiesPerformed
.
notShownReason
)
;
TelemetryFieldResult
osVersionResult
=
GetOSVersion
(
)
;
if
(
osVersionResult
.
isErr
(
)
)
{
return
osVersionResult
.
unwrapErr
(
)
.
AsHResult
(
)
;
}
std
:
:
string
osVersion
=
osVersionResult
.
unwrap
(
)
;
TelemetryFieldResult
osLocaleResult
=
GetOSLocale
(
)
;
if
(
osLocaleResult
.
isErr
(
)
)
{
return
osLocaleResult
.
unwrapErr
(
)
.
AsHResult
(
)
;
}
std
:
:
string
osLocale
=
osLocaleResult
.
unwrap
(
)
;
std
:
:
string
prevNotificationAction
;
HRESULT
hr
=
ReadPreviousNotificationAction
(
prevNotificationAction
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
MaybeWritePreviousNotificationAction
(
activitiesPerformed
)
;
Cache
cache
;
if
(
!
IsOfficialTelemetry
(
)
|
|
IsTelemetryDisabled
(
)
)
{
return
MaybeCache
(
cache
notificationType
notificationShown
notificationAction
prevNotificationAction
)
;
}
BoolResult
pingAlreadySentResult
=
GetPingAlreadySentToday
(
)
;
if
(
pingAlreadySentResult
.
isErr
(
)
)
{
return
pingAlreadySentResult
.
unwrapErr
(
)
.
AsHResult
(
)
;
}
bool
pingAlreadySent
=
pingAlreadySentResult
.
unwrap
(
)
;
if
(
pingAlreadySent
)
{
return
MaybeCache
(
cache
notificationType
notificationShown
notificationAction
prevNotificationAction
)
;
}
hr
=
MaybeSwapForCached
(
cache
notificationType
notificationShown
notificationAction
notificationNotShownReason
prevNotificationAction
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
TelemetryFieldResult
previousDefaultBrowserResult
=
GetAndUpdatePreviousDefaultBrowser
(
currentDefaultBrowser
browserInfo
.
previousDefaultBrowser
)
;
if
(
previousDefaultBrowserResult
.
isErr
(
)
)
{
return
previousDefaultBrowserResult
.
unwrapErr
(
)
.
AsHResult
(
)
;
}
std
:
:
string
previousDefaultBrowser
=
previousDefaultBrowserResult
.
unwrap
(
)
;
return
SendPing
(
currentDefaultBrowser
previousDefaultBrowser
currentDefaultPdf
osVersion
osLocale
notificationType
notificationShown
notificationAction
notificationNotShownReason
prevNotificationAction
)
.
AsHResult
(
)
;
}
