#
include
<
windows
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
objbase
.
h
>
#
include
<
string
.
h
>
#
include
<
vector
>
#
include
"
mozilla
/
mscom
/
EnsureMTA
.
h
"
#
include
"
nsAutoRef
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
nsICommandLine
.
h
"
#
include
"
nsString
.
h
"
#
include
"
common
.
h
"
#
include
"
DefaultBrowser
.
h
"
#
include
"
DefaultPDF
.
h
"
#
include
"
EventLog
.
h
"
#
include
"
Notification
.
h
"
#
include
"
Policy
.
h
"
#
include
"
Registry
.
h
"
#
include
"
ScheduledTask
.
h
"
#
include
"
SetDefaultBrowser
.
h
"
#
include
"
Telemetry
.
h
"
#
include
"
DefaultAgent
.
h
"
#
define
REGISTRY_MUTEX_NAME
\
L
"
"
MOZ_APP_VENDOR
MOZ_APP_BASENAME
L
"
DefaultBrowserAgentRegistryMutex
"
#
define
REGISTRY_MUTEX_TIMEOUT_MS
(
3
*
1000
)
namespace
mozilla
:
:
default_agent
{
class
RegistryMutex
{
private
:
nsAutoHandle
mMutex
;
bool
mLocked
;
public
:
RegistryMutex
(
)
:
mMutex
(
nullptr
)
mLocked
(
false
)
{
}
~
RegistryMutex
(
)
{
Release
(
)
;
}
bool
Acquire
(
)
{
if
(
mLocked
)
{
return
true
;
}
if
(
mMutex
.
get
(
)
=
=
nullptr
)
{
mMutex
.
own
(
CreateMutexW
(
nullptr
FALSE
REGISTRY_MUTEX_NAME
)
)
;
if
(
mMutex
.
get
(
)
=
=
nullptr
)
{
LOG_ERROR_MESSAGE
(
L
"
Couldn
'
t
open
registry
mutex
:
%
#
X
"
GetLastError
(
)
)
;
return
false
;
}
}
DWORD
mutexStatus
=
WaitForSingleObject
(
mMutex
.
get
(
)
REGISTRY_MUTEX_TIMEOUT_MS
)
;
if
(
mutexStatus
=
=
WAIT_OBJECT_0
)
{
mLocked
=
true
;
}
else
if
(
mutexStatus
=
=
WAIT_TIMEOUT
)
{
LOG_ERROR_MESSAGE
(
L
"
Timed
out
waiting
for
registry
mutex
"
)
;
}
else
if
(
mutexStatus
=
=
WAIT_ABANDONED
)
{
LOG_ERROR_MESSAGE
(
L
"
Found
abandoned
registry
mutex
.
Continuing
.
.
.
"
)
;
mLocked
=
true
;
}
else
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
wait
on
registry
mutex
:
%
#
X
"
GetLastError
(
)
)
;
}
return
mLocked
;
}
bool
IsLocked
(
)
{
return
mLocked
;
}
void
Release
(
)
{
if
(
mLocked
)
{
if
(
mMutex
.
get
(
)
=
=
nullptr
)
{
LOG_ERROR_MESSAGE
(
L
"
Unexpectedly
missing
registry
mutex
"
)
;
return
;
}
BOOL
success
=
ReleaseMutex
(
mMutex
.
get
(
)
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
release
registry
mutex
"
)
;
}
mLocked
=
false
;
}
}
}
;
static
bool
IsPrefixedValueName
(
const
wchar_t
*
valueName
)
{
return
wcschr
(
valueName
L
'
|
'
)
!
=
nullptr
;
}
static
void
RemoveAllRegistryEntries
(
)
{
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
installPath
=
mozilla
:
:
GetFullBinaryPath
(
)
;
if
(
!
PathRemoveFileSpecW
(
installPath
.
get
(
)
)
)
{
return
;
}
HKEY
rawRegKey
=
nullptr
;
if
(
ERROR_SUCCESS
!
=
RegOpenKeyExW
(
HKEY_CURRENT_USER
AGENT_REGKEY_NAME
0
KEY_WRITE
|
KEY_QUERY_VALUE
|
KEY_WOW64_64KEY
&
rawRegKey
)
)
{
return
;
}
nsAutoRegKey
regKey
(
rawRegKey
)
;
DWORD
maxValueNameLen
=
0
;
if
(
ERROR_SUCCESS
!
=
RegQueryInfoKeyW
(
regKey
.
get
(
)
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
&
maxValueNameLen
nullptr
nullptr
nullptr
)
)
{
return
;
}
maxValueNameLen
+
=
1
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
valueName
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
maxValueNameLen
)
;
DWORD
valueIndex
=
0
;
bool
keyStillInUse
=
false
;
while
(
true
)
{
DWORD
valueNameLen
=
maxValueNameLen
;
LSTATUS
ls
=
RegEnumValueW
(
regKey
.
get
(
)
valueIndex
valueName
.
get
(
)
&
valueNameLen
nullptr
nullptr
nullptr
nullptr
)
;
if
(
ls
!
=
ERROR_SUCCESS
)
{
break
;
}
if
(
!
wcsnicmp
(
valueName
.
get
(
)
installPath
.
get
(
)
wcslen
(
installPath
.
get
(
)
)
)
)
{
RegDeleteValueW
(
regKey
.
get
(
)
valueName
.
get
(
)
)
;
}
else
{
valueIndex
+
+
;
if
(
IsPrefixedValueName
(
valueName
.
get
(
)
)
)
{
keyStillInUse
=
true
;
}
}
}
regKey
.
reset
(
)
;
if
(
!
keyStillInUse
)
{
RegDeleteTreeW
(
HKEY_CURRENT_USER
AGENT_REGKEY_NAME
)
;
}
}
static
void
WriteInstallationRegistryEntry
(
)
{
mozilla
:
:
WindowsErrorResult
<
mozilla
:
:
Ok
>
result
=
RegistrySetValueBool
(
IsPrefixed
:
:
Prefixed
L
"
Installed
"
true
)
;
if
(
result
.
isErr
(
)
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
write
installation
registry
entry
:
%
#
X
"
result
.
unwrapErr
(
)
.
AsHResult
(
)
)
;
}
}
static
bool
CheckIfAppRanRecently
(
bool
*
aResult
)
{
const
ULONGLONG
kTaskExpirationDays
=
90
;
const
ULONGLONG
kTaskExpirationSeconds
=
kTaskExpirationDays
*
24
*
60
*
60
;
MaybeQwordResult
lastRunTimeResult
=
RegistryGetValueQword
(
IsPrefixed
:
:
Prefixed
L
"
AppLastRunTime
"
)
;
if
(
lastRunTimeResult
.
isErr
(
)
)
{
return
false
;
}
mozilla
:
:
Maybe
<
ULONGLONG
>
lastRunTimeMaybe
=
lastRunTimeResult
.
unwrap
(
)
;
if
(
!
lastRunTimeMaybe
.
isSome
(
)
)
{
return
false
;
}
ULONGLONG
secondsSinceLastRunTime
=
SecondsPassedSince
(
lastRunTimeMaybe
.
value
(
)
)
;
*
aResult
=
secondsSinceLastRunTime
<
kTaskExpirationSeconds
;
return
true
;
}
NS_IMPL_ISUPPORTS
(
DefaultAgent
nsIDefaultAgent
)
NS_IMETHODIMP
DefaultAgent
:
:
RegisterTask
(
const
nsAString
&
aUniqueToken
)
{
RegistryMutex
regMutex
;
regMutex
.
Acquire
(
)
;
WriteInstallationRegistryEntry
(
)
;
HRESULT
hr
=
default_agent
:
:
RegisterTask
(
PromiseFlatString
(
aUniqueToken
)
.
get
(
)
)
;
return
SUCCEEDED
(
hr
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
DefaultAgent
:
:
UpdateTask
(
const
nsAString
&
aUniqueToken
)
{
RegistryMutex
regMutex
;
regMutex
.
Acquire
(
)
;
WriteInstallationRegistryEntry
(
)
;
HRESULT
hr
=
default_agent
:
:
UpdateTask
(
PromiseFlatString
(
aUniqueToken
)
.
get
(
)
)
;
return
SUCCEEDED
(
hr
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
DefaultAgent
:
:
UnregisterTask
(
const
nsAString
&
aUniqueToken
)
{
HRESULT
hr
=
RemoveTasks
(
PromiseFlatString
(
aUniqueToken
)
.
get
(
)
WhichTasks
:
:
WdbaTaskOnly
)
;
return
SUCCEEDED
(
hr
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
DefaultAgent
:
:
Uninstall
(
const
nsAString
&
aUniqueToken
)
{
RegistryMutex
regMutex
;
regMutex
.
Acquire
(
)
;
RemoveAllRegistryEntries
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DefaultAgent
:
:
DoTask
(
const
nsAString
&
aUniqueToken
const
bool
aForce
)
{
RegistryMutex
regMutex
;
if
(
!
regMutex
.
Acquire
(
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
ranRecently
=
false
;
if
(
!
aForce
&
&
(
!
CheckIfAppRanRecently
(
&
ranRecently
)
|
|
!
ranRecently
)
)
{
return
NS_ERROR_FAILURE
;
}
DefaultBrowserResult
defaultBrowserResult
=
GetDefaultBrowserInfo
(
)
;
DefaultBrowserInfo
browserInfo
{
}
;
if
(
defaultBrowserResult
.
isOk
(
)
)
{
browserInfo
=
defaultBrowserResult
.
unwrap
(
)
;
}
else
{
browserInfo
.
currentDefaultBrowser
=
Browser
:
:
Error
;
browserInfo
.
previousDefaultBrowser
=
Browser
:
:
Error
;
}
DefaultPdfResult
defaultPdfResult
=
GetDefaultPdfInfo
(
)
;
DefaultPdfInfo
pdfInfo
{
}
;
if
(
defaultPdfResult
.
isOk
(
)
)
{
pdfInfo
=
defaultPdfResult
.
unwrap
(
)
;
}
else
{
pdfInfo
.
currentDefaultPdf
=
"
error
"
;
}
NotificationActivities
activitiesPerformed
;
mozilla
:
:
mscom
:
:
EnsureMTA
(
[
&
]
{
activitiesPerformed
=
MaybeShowNotification
(
browserInfo
PromiseFlatString
(
aUniqueToken
)
.
get
(
)
aForce
)
;
}
)
;
HRESULT
hr
=
SendDefaultAgentPing
(
browserInfo
pdfInfo
activitiesPerformed
)
;
return
SUCCEEDED
(
hr
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
DefaultAgent
:
:
SetDefaultBrowserUserChoice
(
const
nsAString
&
aAumid
const
nsTArray
<
nsString
>
&
aExtraFileExtensions
)
{
return
default_agent
:
:
SetDefaultBrowserUserChoice
(
PromiseFlatString
(
aAumid
)
.
get
(
)
aExtraFileExtensions
)
;
}
NS_IMETHODIMP
DefaultAgent
:
:
SetDefaultExtensionHandlersUserChoice
(
const
nsAString
&
aAumid
const
nsTArray
<
nsString
>
&
aFileExtensions
)
{
return
default_agent
:
:
SetDefaultExtensionHandlersUserChoice
(
PromiseFlatString
(
aAumid
)
.
get
(
)
aFileExtensions
)
;
}
NS_IMETHODIMP
DefaultAgent
:
:
AgentDisabled
(
bool
*
aDisabled
)
{
*
aDisabled
=
IsAgentDisabled
(
)
;
return
NS_OK
;
}
}
