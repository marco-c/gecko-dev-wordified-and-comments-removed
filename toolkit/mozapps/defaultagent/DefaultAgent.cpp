#
include
<
windows
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
objbase
.
h
>
#
include
"
nsAutoRef
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
nsString
.
h
"
#
include
"
common
.
h
"
#
include
"
DefaultBrowser
.
h
"
#
include
"
DefaultPDF
.
h
"
#
include
"
EventLog
.
h
"
#
include
"
Notification
.
h
"
#
include
"
Policy
.
h
"
#
include
"
Registry
.
h
"
#
include
"
ScheduledTask
.
h
"
#
include
"
ScheduledTaskRemove
.
h
"
#
include
"
SetDefaultBrowser
.
h
"
#
include
"
Telemetry
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
DefaultAgent
.
h
"
#
define
REGISTRY_MUTEX_NAME
\
L
"
"
MOZ_APP_VENDOR
MOZ_APP_BASENAME
L
"
DefaultBrowserAgentRegistryMutex
"
#
define
REGISTRY_MUTEX_TIMEOUT_MS
(
3
*
1000
)
namespace
mozilla
:
:
default_agent
{
class
RegistryMutex
{
private
:
nsAutoHandle
mMutex
;
bool
mLocked
;
public
:
RegistryMutex
(
)
:
mMutex
(
nullptr
)
mLocked
(
false
)
{
}
~
RegistryMutex
(
)
{
Release
(
)
;
}
bool
Acquire
(
)
{
if
(
mLocked
)
{
return
true
;
}
if
(
mMutex
.
get
(
)
=
=
nullptr
)
{
mMutex
.
own
(
CreateMutexW
(
nullptr
FALSE
REGISTRY_MUTEX_NAME
)
)
;
if
(
mMutex
.
get
(
)
=
=
nullptr
)
{
LOG_ERROR_MESSAGE
(
L
"
Couldn
'
t
open
registry
mutex
:
%
#
X
"
GetLastError
(
)
)
;
return
false
;
}
}
DWORD
mutexStatus
=
WaitForSingleObject
(
mMutex
.
get
(
)
REGISTRY_MUTEX_TIMEOUT_MS
)
;
if
(
mutexStatus
=
=
WAIT_OBJECT_0
)
{
mLocked
=
true
;
}
else
if
(
mutexStatus
=
=
WAIT_TIMEOUT
)
{
LOG_ERROR_MESSAGE
(
L
"
Timed
out
waiting
for
registry
mutex
"
)
;
}
else
if
(
mutexStatus
=
=
WAIT_ABANDONED
)
{
LOG_ERROR_MESSAGE
(
L
"
Found
abandoned
registry
mutex
.
Continuing
.
.
.
"
)
;
mLocked
=
true
;
}
else
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
wait
on
registry
mutex
:
%
#
X
"
GetLastError
(
)
)
;
}
return
mLocked
;
}
bool
IsLocked
(
)
{
return
mLocked
;
}
void
Release
(
)
{
if
(
mLocked
)
{
if
(
mMutex
.
get
(
)
=
=
nullptr
)
{
LOG_ERROR_MESSAGE
(
L
"
Unexpectedly
missing
registry
mutex
"
)
;
return
;
}
BOOL
success
=
ReleaseMutex
(
mMutex
.
get
(
)
)
;
if
(
!
success
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
release
registry
mutex
"
)
;
}
mLocked
=
false
;
}
}
}
;
static
bool
IsPrefixedValueName
(
const
wchar_t
*
valueName
)
{
return
wcschr
(
valueName
L
'
|
'
)
!
=
nullptr
;
}
static
void
RemoveAllRegistryEntries
(
)
{
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
installPath
=
mozilla
:
:
GetFullBinaryPath
(
)
;
if
(
!
PathRemoveFileSpecW
(
installPath
.
get
(
)
)
)
{
return
;
}
HKEY
rawRegKey
=
nullptr
;
if
(
ERROR_SUCCESS
!
=
RegOpenKeyExW
(
HKEY_CURRENT_USER
AGENT_REGKEY_NAME
0
KEY_WRITE
|
KEY_QUERY_VALUE
|
KEY_WOW64_64KEY
&
rawRegKey
)
)
{
return
;
}
nsAutoRegKey
regKey
(
rawRegKey
)
;
DWORD
maxValueNameLen
=
0
;
if
(
ERROR_SUCCESS
!
=
RegQueryInfoKeyW
(
regKey
.
get
(
)
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
&
maxValueNameLen
nullptr
nullptr
nullptr
)
)
{
return
;
}
maxValueNameLen
+
=
1
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
valueName
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
maxValueNameLen
)
;
DWORD
valueIndex
=
0
;
bool
keyStillInUse
=
false
;
while
(
true
)
{
DWORD
valueNameLen
=
maxValueNameLen
;
LSTATUS
ls
=
RegEnumValueW
(
regKey
.
get
(
)
valueIndex
valueName
.
get
(
)
&
valueNameLen
nullptr
nullptr
nullptr
nullptr
)
;
if
(
ls
!
=
ERROR_SUCCESS
)
{
break
;
}
if
(
!
wcsnicmp
(
valueName
.
get
(
)
installPath
.
get
(
)
wcslen
(
installPath
.
get
(
)
)
)
)
{
RegDeleteValueW
(
regKey
.
get
(
)
valueName
.
get
(
)
)
;
}
else
{
valueIndex
+
+
;
if
(
IsPrefixedValueName
(
valueName
.
get
(
)
)
)
{
keyStillInUse
=
true
;
}
}
}
regKey
.
reset
(
)
;
if
(
!
keyStillInUse
)
{
RegDeleteTreeW
(
HKEY_CURRENT_USER
AGENT_REGKEY_NAME
)
;
}
}
static
void
WriteInstallationRegistryEntry
(
)
{
mozilla
:
:
WindowsErrorResult
<
mozilla
:
:
Ok
>
result
=
RegistrySetValueBool
(
IsPrefixed
:
:
Prefixed
L
"
Installed
"
true
)
;
if
(
result
.
isErr
(
)
)
{
LOG_ERROR_MESSAGE
(
L
"
Failed
to
write
installation
registry
entry
:
%
#
X
"
result
.
unwrapErr
(
)
.
AsHResult
(
)
)
;
}
}
static
bool
CheckIfAppRanRecently
(
bool
*
aResult
)
{
const
ULONGLONG
kTaskExpirationDays
=
90
;
const
ULONGLONG
kTaskExpirationSeconds
=
kTaskExpirationDays
*
24
*
60
*
60
;
MaybeQwordResult
lastRunTimeResult
=
RegistryGetValueQword
(
IsPrefixed
:
:
Prefixed
L
"
AppLastRunTime
"
)
;
if
(
lastRunTimeResult
.
isErr
(
)
)
{
return
false
;
}
mozilla
:
:
Maybe
<
ULONGLONG
>
lastRunTimeMaybe
=
lastRunTimeResult
.
unwrap
(
)
;
if
(
!
lastRunTimeMaybe
.
isSome
(
)
)
{
return
false
;
}
ULONGLONG
secondsSinceLastRunTime
=
SecondsPassedSince
(
lastRunTimeMaybe
.
value
(
)
)
;
*
aResult
=
secondsSinceLastRunTime
<
kTaskExpirationSeconds
;
return
true
;
}
NS_IMPL_ISUPPORTS
(
DefaultAgent
nsIDefaultAgent
)
NS_IMETHODIMP
DefaultAgent
:
:
RegisterTask
(
const
nsAString
&
aUniqueToken
)
{
RegistryMutex
regMutex
;
regMutex
.
Acquire
(
)
;
WriteInstallationRegistryEntry
(
)
;
HRESULT
hr
=
default_agent
:
:
RegisterTask
(
PromiseFlatString
(
aUniqueToken
)
.
get
(
)
)
;
return
SUCCEEDED
(
hr
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
DefaultAgent
:
:
UpdateTask
(
const
nsAString
&
aUniqueToken
)
{
RegistryMutex
regMutex
;
regMutex
.
Acquire
(
)
;
WriteInstallationRegistryEntry
(
)
;
HRESULT
hr
=
default_agent
:
:
UpdateTask
(
PromiseFlatString
(
aUniqueToken
)
.
get
(
)
)
;
return
SUCCEEDED
(
hr
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
DefaultAgent
:
:
UnregisterTask
(
const
nsAString
&
aUniqueToken
)
{
HRESULT
hr
=
RemoveTasks
(
PromiseFlatString
(
aUniqueToken
)
.
get
(
)
WhichTasks
:
:
WdbaTaskOnly
)
;
return
SUCCEEDED
(
hr
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
DefaultAgent
:
:
Uninstall
(
const
nsAString
&
aUniqueToken
)
{
RegistryMutex
regMutex
;
regMutex
.
Acquire
(
)
;
RemoveAllRegistryEntries
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DefaultAgent
:
:
AppRanRecently
(
bool
*
aRanRecently
)
{
bool
ranRecently
=
false
;
*
aRanRecently
=
CheckIfAppRanRecently
(
&
ranRecently
)
&
&
ranRecently
;
return
NS_OK
;
}
NS_IMETHODIMP
DefaultAgent
:
:
GetDefaultBrowser
(
nsAString
&
aDefaultBrowser
)
{
Browser
browser
=
default_agent
:
:
GetDefaultBrowser
(
)
;
aDefaultBrowser
=
NS_ConvertUTF8toUTF16
(
GetStringForBrowser
(
browser
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DefaultAgent
:
:
GetReplacePreviousDefaultBrowser
(
const
nsAString
&
aDefaultBrowser
nsAString
&
aPreviousDefaultBrowser
)
{
Browser
browser
=
GetBrowserFromString
(
std
:
:
string
(
NS_ConvertUTF16toUTF8
(
aDefaultBrowser
)
)
)
;
Browser
previousBrowser
=
default_agent
:
:
GetReplacePreviousDefaultBrowser
(
browser
)
;
aPreviousDefaultBrowser
=
NS_ConvertUTF8toUTF16
(
GetStringForBrowser
(
previousBrowser
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DefaultAgent
:
:
GetDefaultPdfHandler
(
nsAString
&
aDefaultPdfHandler
)
{
PDFHandler
pdf
=
default_agent
:
:
GetDefaultPdfInfo
(
)
.
unwrapOr
(
{
PDFHandler
:
:
Error
}
)
.
currentDefaultPdf
;
aDefaultPdfHandler
=
NS_ConvertUTF8toUTF16
(
GetStringForPDFHandler
(
pdf
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DefaultAgent
:
:
SendPing
(
const
nsAString
&
aDefaultBrowser
const
nsAString
&
aPreviousDefaultBrowser
const
nsAString
&
aDefaultPdfHandler
const
nsAString
&
aNotificationShown
const
nsAString
&
aNotificationAction
)
{
DefaultBrowserInfo
browserInfo
=
{
GetBrowserFromString
(
std
:
:
string
(
NS_ConvertUTF16toUTF8
(
aDefaultBrowser
)
)
)
GetBrowserFromString
(
std
:
:
string
(
NS_ConvertUTF16toUTF8
(
aPreviousDefaultBrowser
)
)
)
}
;
DefaultPdfInfo
pdfInfo
=
{
GetPDFHandlerFromString
(
std
:
:
string
(
NS_ConvertUTF16toUTF8
(
aDefaultPdfHandler
)
)
)
}
;
NotificationShown
shown
=
GetNotificationShownFromString
(
aNotificationShown
)
;
NotificationAction
action
=
GetNotificationActionFromString
(
aNotificationAction
)
;
NotificationActivities
activitiesPerformed
=
{
NotificationType
:
:
Initial
shown
action
}
;
HRESULT
hr
=
SendDefaultAgentPing
(
browserInfo
pdfInfo
activitiesPerformed
)
;
return
SUCCEEDED
(
hr
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
DefaultAgent
:
:
SetDefaultBrowserUserChoice
(
const
nsAString
&
aAumid
const
nsTArray
<
nsString
>
&
aExtraFileExtensions
)
{
const
bool
regRename
=
Preferences
:
:
GetBool
(
"
browser
.
shell
.
setDefaultBrowserUserChoice
.
regRename
"
)
;
return
default_agent
:
:
SetDefaultBrowserUserChoice
(
PromiseFlatString
(
aAumid
)
.
get
(
)
regRename
aExtraFileExtensions
)
;
}
NS_IMETHODIMP
DefaultAgent
:
:
SetDefaultBrowserUserChoiceAsync
(
const
nsAString
&
aAumid
const
nsTArray
<
nsString
>
&
aExtraFileExtensions
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
SetDefaultBrowserUserChoiceAsync
promise
"
promise
)
;
const
bool
regRename
=
Preferences
:
:
GetBool
(
"
browser
.
shell
.
setDefaultBrowserUserChoice
.
regRename
"
)
;
nsresult
result
=
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
SetDefaultBrowserUserChoiceAsync
"
[
aumid
=
nsString
(
aAumid
)
promiseHolder
=
std
:
:
move
(
promiseHolder
)
aExtraFileExtensions
=
CopyableTArray
<
nsString
>
(
aExtraFileExtensions
)
regRename
]
{
nsresult
rv
=
default_agent
:
:
SetDefaultBrowserUserChoice
(
PromiseFlatString
(
aumid
)
.
get
(
)
regRename
aExtraFileExtensions
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
SetDefaultBrowserUserChoiceAsync
callback
"
[
rv
promiseHolder
=
std
:
:
move
(
promiseHolder
)
]
{
dom
:
:
Promise
*
promise
=
promiseHolder
.
get
(
)
-
>
get
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
else
{
promise
-
>
MaybeReject
(
rv
)
;
}
}
)
)
;
}
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
promise
.
forget
(
aPromise
)
;
return
result
;
}
NS_IMETHODIMP
DefaultAgent
:
:
SetDefaultExtensionHandlersUserChoice
(
const
nsAString
&
aAumid
const
nsTArray
<
nsString
>
&
aFileExtensions
)
{
const
bool
regRename
=
Preferences
:
:
GetBool
(
"
browser
.
shell
.
setDefaultBrowserUserChoice
.
regRename
"
)
;
return
default_agent
:
:
SetDefaultExtensionHandlersUserChoice
(
PromiseFlatString
(
aAumid
)
.
get
(
)
regRename
aFileExtensions
)
;
}
NS_IMETHODIMP
DefaultAgent
:
:
AgentDisabled
(
bool
*
aDisabled
)
{
*
aDisabled
=
IsAgentDisabled
(
)
;
return
NS_OK
;
}
}
