#
ifndef
mozilla_devtools_DeserializedNode__
#
define
mozilla_devtools_DeserializedNode__
#
include
"
js
/
UbiNode
.
h
"
#
include
"
mozilla
/
devtools
/
CoreDump
.
pb
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
namespace
mozilla
{
namespace
devtools
{
class
HeapSnapshot
;
using
NodeId
=
uint64_t
;
using
StackFrameId
=
uint64_t
;
struct
DeserializedEdge
{
NodeId
referent
;
const
char16_t
*
name
;
explicit
DeserializedEdge
(
)
;
DeserializedEdge
(
DeserializedEdge
&
&
rhs
)
;
DeserializedEdge
&
operator
=
(
DeserializedEdge
&
&
rhs
)
;
bool
init
(
const
protobuf
:
:
Edge
&
edge
HeapSnapshot
&
owner
)
;
private
:
DeserializedEdge
(
const
DeserializedEdge
&
)
=
delete
;
DeserializedEdge
&
operator
=
(
const
DeserializedEdge
&
)
=
delete
;
}
;
struct
DeserializedNode
{
using
EdgeVector
=
Vector
<
DeserializedEdge
>
;
using
UniqueStringPtr
=
UniquePtr
<
char16_t
[
]
>
;
NodeId
id
;
const
char16_t
*
typeName
;
uint64_t
size
;
EdgeVector
edges
;
Maybe
<
StackFrameId
>
allocationStack
;
UniquePtr
<
char
[
]
>
jsObjectClassName
;
HeapSnapshot
*
owner
;
DeserializedNode
(
NodeId
id
const
char16_t
*
typeName
uint64_t
size
EdgeVector
&
&
edges
Maybe
<
StackFrameId
>
allocationStack
UniquePtr
<
char
[
]
>
&
&
className
HeapSnapshot
&
owner
)
:
id
(
id
)
typeName
(
typeName
)
size
(
size
)
edges
(
Move
(
edges
)
)
allocationStack
(
allocationStack
)
jsObjectClassName
(
Move
(
className
)
)
owner
(
&
owner
)
{
}
virtual
~
DeserializedNode
(
)
{
}
DeserializedNode
(
DeserializedNode
&
&
rhs
)
;
DeserializedNode
&
operator
=
(
DeserializedNode
&
&
rhs
)
;
virtual
JS
:
:
ubi
:
:
Node
getEdgeReferent
(
const
DeserializedEdge
&
edge
)
;
struct
HashPolicy
;
protected
:
DeserializedNode
(
NodeId
id
const
char16_t
*
typeName
uint64_t
size
)
;
private
:
DeserializedNode
(
const
DeserializedNode
&
)
=
delete
;
DeserializedNode
&
operator
=
(
const
DeserializedNode
&
)
=
delete
;
}
;
static
inline
js
:
:
HashNumber
hashIdDerivedFromPtr
(
uint64_t
id
)
{
id
>
>
=
3
;
return
js
:
:
HashNumber
(
(
id
>
>
32
)
^
id
)
;
}
struct
DeserializedNode
:
:
HashPolicy
{
using
Lookup
=
NodeId
;
static
js
:
:
HashNumber
hash
(
const
Lookup
&
lookup
)
{
return
hashIdDerivedFromPtr
(
lookup
)
;
}
static
bool
match
(
const
DeserializedNode
&
existing
const
Lookup
&
lookup
)
{
return
existing
.
id
=
=
lookup
;
}
}
;
struct
DeserializedStackFrame
{
StackFrameId
id
;
Maybe
<
StackFrameId
>
parent
;
uint32_t
line
;
uint32_t
column
;
const
char16_t
*
source
;
const
char16_t
*
functionDisplayName
;
bool
isSystem
;
bool
isSelfHosted
;
HeapSnapshot
*
owner
;
explicit
DeserializedStackFrame
(
StackFrameId
id
const
Maybe
<
StackFrameId
>
&
parent
uint32_t
line
uint32_t
column
const
char16_t
*
source
const
char16_t
*
functionDisplayName
bool
isSystem
bool
isSelfHosted
HeapSnapshot
&
owner
)
:
id
(
id
)
parent
(
parent
)
line
(
line
)
column
(
column
)
source
(
source
)
functionDisplayName
(
functionDisplayName
)
isSystem
(
isSystem
)
isSelfHosted
(
isSelfHosted
)
owner
(
&
owner
)
{
MOZ_ASSERT
(
source
)
;
}
JS
:
:
ubi
:
:
StackFrame
getParentStackFrame
(
)
const
;
struct
HashPolicy
;
protected
:
explicit
DeserializedStackFrame
(
)
:
id
(
0
)
parent
(
Nothing
(
)
)
line
(
0
)
column
(
0
)
source
(
nullptr
)
functionDisplayName
(
nullptr
)
isSystem
(
false
)
isSelfHosted
(
false
)
owner
(
nullptr
)
{
}
;
}
;
struct
DeserializedStackFrame
:
:
HashPolicy
{
using
Lookup
=
StackFrameId
;
static
js
:
:
HashNumber
hash
(
const
Lookup
&
lookup
)
{
return
hashIdDerivedFromPtr
(
lookup
)
;
}
static
bool
match
(
const
DeserializedStackFrame
&
existing
const
Lookup
&
lookup
)
{
return
existing
.
id
=
=
lookup
;
}
}
;
}
}
namespace
JS
{
namespace
ubi
{
using
mozilla
:
:
devtools
:
:
DeserializedNode
;
using
mozilla
:
:
devtools
:
:
DeserializedStackFrame
;
using
mozilla
:
:
UniquePtr
;
template
<
>
struct
Concrete
<
DeserializedNode
>
:
public
Base
{
protected
:
explicit
Concrete
(
DeserializedNode
*
ptr
)
:
Base
(
ptr
)
{
}
DeserializedNode
&
get
(
)
const
{
return
*
static_cast
<
DeserializedNode
*
>
(
ptr
)
;
}
public
:
static
const
char16_t
concreteTypeName
[
]
;
static
void
construct
(
void
*
storage
DeserializedNode
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
Id
identifier
(
)
const
override
{
return
get
(
)
.
id
;
}
bool
isLive
(
)
const
override
{
return
false
;
}
const
char16_t
*
typeName
(
)
const
override
;
Node
:
:
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeof
)
const
override
;
const
char
*
jsObjectClassName
(
)
const
override
{
return
get
(
)
.
jsObjectClassName
.
get
(
)
;
}
bool
hasAllocationStack
(
)
const
override
{
return
get
(
)
.
allocationStack
.
isSome
(
)
;
}
StackFrame
allocationStack
(
)
const
override
;
UniquePtr
<
EdgeRange
>
edges
(
JSContext
*
cx
bool
)
const
override
;
}
;
template
<
>
class
ConcreteStackFrame
<
DeserializedStackFrame
>
:
public
BaseStackFrame
{
protected
:
explicit
ConcreteStackFrame
(
DeserializedStackFrame
*
ptr
)
:
BaseStackFrame
(
ptr
)
{
}
DeserializedStackFrame
&
get
(
)
const
{
return
*
static_cast
<
DeserializedStackFrame
*
>
(
ptr
)
;
}
public
:
static
void
construct
(
void
*
storage
DeserializedStackFrame
*
ptr
)
{
new
(
storage
)
ConcreteStackFrame
(
ptr
)
;
}
uint64_t
identifier
(
)
const
override
{
return
get
(
)
.
id
;
}
uint32_t
line
(
)
const
override
{
return
get
(
)
.
line
;
}
uint32_t
column
(
)
const
override
{
return
get
(
)
.
column
;
}
bool
isSystem
(
)
const
override
{
return
get
(
)
.
isSystem
;
}
bool
isSelfHosted
(
)
const
override
{
return
get
(
)
.
isSelfHosted
;
}
void
trace
(
JSTracer
*
trc
)
override
{
}
AtomOrTwoByteChars
source
(
)
const
override
{
return
AtomOrTwoByteChars
(
get
(
)
.
source
)
;
}
AtomOrTwoByteChars
functionDisplayName
(
)
const
override
{
return
AtomOrTwoByteChars
(
get
(
)
.
functionDisplayName
)
;
}
StackFrame
parent
(
)
const
override
;
bool
constructSavedFrameStack
(
JSContext
*
cx
MutableHandleObject
outSavedFrameStack
)
const
override
;
}
;
}
}
#
endif
