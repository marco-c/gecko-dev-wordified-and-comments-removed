ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ForgetAboutSite
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesTestUtils
"
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
jsm
"
)
;
const
COOKIE_EXPIRY
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
+
60
;
const
COOKIE_NAME
=
"
testcookie
"
;
const
COOKIE_PATH
=
"
/
"
;
const
LOGIN_USERNAME
=
"
username
"
;
const
LOGIN_PASSWORD
=
"
password
"
;
const
LOGIN_USERNAME_FIELD
=
"
username_field
"
;
const
LOGIN_PASSWORD_FIELD
=
"
password_field
"
;
const
PERMISSION_TYPE
=
"
test
-
perm
"
;
const
PERMISSION_VALUE
=
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
;
const
PREFERENCE_NAME
=
"
test
-
pref
"
;
function
add_cookie
(
aDomain
)
{
check_cookie_exists
(
aDomain
false
)
;
Services
.
cookies
.
add
(
aDomain
COOKIE_PATH
COOKIE_NAME
"
"
false
false
false
COOKIE_EXPIRY
{
}
)
;
check_cookie_exists
(
aDomain
true
)
;
}
function
check_cookie_exists
(
aDomain
aExists
)
{
let
cookie
=
{
host
:
aDomain
name
:
COOKIE_NAME
path
:
COOKIE_PATH
}
;
Assert
.
equal
(
aExists
Services
.
cookies
.
cookieExists
(
cookie
)
)
;
}
function
add_disabled_host
(
aHost
)
{
check_disabled_host
(
aHost
false
)
;
Services
.
logins
.
setLoginSavingEnabled
(
aHost
false
)
;
check_disabled_host
(
aHost
true
)
;
}
function
check_disabled_host
(
aHost
aIsDisabled
)
{
Assert
.
equal
(
!
aIsDisabled
Services
.
logins
.
getLoginSavingEnabled
(
aHost
)
)
;
}
function
add_login
(
aHost
)
{
check_login_exists
(
aHost
false
)
;
let
login
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
login
.
init
(
aHost
"
"
null
LOGIN_USERNAME
LOGIN_PASSWORD
LOGIN_USERNAME_FIELD
LOGIN_PASSWORD_FIELD
)
;
Services
.
logins
.
addLogin
(
login
)
;
check_login_exists
(
aHost
true
)
;
}
function
check_login_exists
(
aHost
aExists
)
{
let
count
=
{
value
:
0
}
;
Services
.
logins
.
findLogins
(
count
aHost
"
"
null
)
;
Assert
.
equal
(
count
.
value
aExists
?
1
:
0
)
;
}
function
add_permission
(
aURI
)
{
check_permission_exists
(
aURI
false
)
;
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
aURI
{
}
)
;
Services
.
perms
.
addFromPrincipal
(
principal
PERMISSION_TYPE
PERMISSION_VALUE
)
;
check_permission_exists
(
aURI
true
)
;
}
function
check_permission_exists
(
aURI
aExists
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
aURI
{
}
)
;
let
perm
=
Services
.
perms
.
testExactPermissionFromPrincipal
(
principal
PERMISSION_TYPE
)
;
let
checker
=
aExists
?
"
equal
"
:
"
notEqual
"
;
Assert
[
checker
]
(
perm
PERMISSION_VALUE
)
;
}
function
add_preference
(
aURI
)
{
return
new
Promise
(
resolve
=
>
{
let
cp
=
Cc
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
]
.
getService
(
Ci
.
nsIContentPrefService2
)
;
cp
.
set
(
aURI
.
spec
PREFERENCE_NAME
"
foo
"
null
{
handleCompletion
:
(
)
=
>
resolve
(
)
}
)
;
}
)
;
}
function
preference_exists
(
aURI
)
{
return
new
Promise
(
resolve
=
>
{
let
cp
=
Cc
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
]
.
getService
(
Ci
.
nsIContentPrefService2
)
;
let
exists
=
false
;
cp
.
getByDomainAndName
(
aURI
.
spec
PREFERENCE_NAME
null
{
handleResult
:
(
)
=
>
exists
=
true
handleCompletion
:
(
)
=
>
resolve
(
exists
)
}
)
;
}
)
;
}
async
function
test_history_cleared_with_direct_match
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
mozilla
.
org
/
foo
"
)
;
Assert
.
equal
(
false
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
PlacesTestUtils
.
addVisits
(
TEST_URI
)
;
Assert
.
ok
(
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
Assert
.
equal
(
false
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
}
async
function
test_history_cleared_with_subdomain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
foo
"
)
;
Assert
.
equal
(
false
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
PlacesTestUtils
.
addVisits
(
TEST_URI
)
;
Assert
.
ok
(
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
Assert
.
equal
(
false
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
}
async
function
test_history_not_cleared_with_uri_contains_domain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
ilovemozilla
.
org
/
foo
"
)
;
Assert
.
equal
(
false
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
PlacesTestUtils
.
addVisits
(
TEST_URI
)
;
Assert
.
ok
(
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
Assert
.
ok
(
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
async
function
test_cookie_cleared_with_direct_match
(
)
{
const
TEST_DOMAIN
=
"
mozilla
.
org
"
;
add_cookie
(
TEST_DOMAIN
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_cookie_exists
(
TEST_DOMAIN
false
)
;
}
async
function
test_cookie_cleared_with_subdomain
(
)
{
const
TEST_DOMAIN
=
"
www
.
mozilla
.
org
"
;
add_cookie
(
TEST_DOMAIN
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_cookie_exists
(
TEST_DOMAIN
false
)
;
}
async
function
test_cookie_not_cleared_with_uri_contains_domain
(
)
{
const
TEST_DOMAIN
=
"
ilovemozilla
.
org
"
;
add_cookie
(
TEST_DOMAIN
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_cookie_exists
(
TEST_DOMAIN
true
)
;
}
async
function
test_login_manager_disabled_hosts_cleared_with_direct_match
(
)
{
const
TEST_HOST
=
"
http
:
/
/
mozilla
.
org
"
;
add_disabled_host
(
TEST_HOST
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_disabled_host
(
TEST_HOST
false
)
;
}
async
function
test_login_manager_disabled_hosts_cleared_with_subdomain
(
)
{
const
TEST_HOST
=
"
http
:
/
/
www
.
mozilla
.
org
"
;
add_disabled_host
(
TEST_HOST
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_disabled_host
(
TEST_HOST
false
)
;
}
async
function
test_login_manager_disabled_hosts_not_cleared_with_uri_contains_domain
(
)
{
const
TEST_HOST
=
"
http
:
/
/
ilovemozilla
.
org
"
;
add_disabled_host
(
TEST_HOST
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_disabled_host
(
TEST_HOST
true
)
;
Services
.
logins
.
setLoginSavingEnabled
(
TEST_HOST
true
)
;
check_disabled_host
(
TEST_HOST
false
)
;
}
async
function
test_login_manager_logins_cleared_with_direct_match
(
)
{
const
TEST_HOST
=
"
http
:
/
/
mozilla
.
org
"
;
add_login
(
TEST_HOST
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_login_exists
(
TEST_HOST
false
)
;
}
async
function
test_login_manager_logins_cleared_with_subdomain
(
)
{
const
TEST_HOST
=
"
http
:
/
/
www
.
mozilla
.
org
"
;
add_login
(
TEST_HOST
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_login_exists
(
TEST_HOST
false
)
;
}
async
function
test_login_manager_logins_not_cleared_with_uri_contains_domain
(
)
{
const
TEST_HOST
=
"
http
:
/
/
ilovemozilla
.
org
"
;
add_login
(
TEST_HOST
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_login_exists
(
TEST_HOST
true
)
;
Services
.
logins
.
removeAllLogins
(
)
;
check_login_exists
(
TEST_HOST
false
)
;
}
async
function
test_permission_manager_cleared_with_direct_match
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
mozilla
.
org
"
)
;
add_permission
(
TEST_URI
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_permission_exists
(
TEST_URI
false
)
;
}
async
function
test_permission_manager_cleared_with_subdomain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
"
)
;
add_permission
(
TEST_URI
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_permission_exists
(
TEST_URI
false
)
;
}
async
function
test_permission_manager_not_cleared_with_uri_contains_domain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
ilovemozilla
.
org
"
)
;
add_permission
(
TEST_URI
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_permission_exists
(
TEST_URI
true
)
;
Services
.
perms
.
removeAll
(
)
;
check_permission_exists
(
TEST_URI
false
)
;
}
function
waitForPurgeNotification
(
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
Services
.
obs
.
removeObserver
(
observer
"
browser
:
purge
-
domain
-
data
"
)
;
Services
.
tm
.
dispatchToMainThread
(
function
(
)
{
resolve
(
)
;
}
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
"
browser
:
purge
-
domain
-
data
"
)
;
}
)
;
}
async
function
test_content_preferences_cleared_with_direct_match
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
mozilla
.
org
"
)
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
await
add_preference
(
TEST_URI
)
;
Assert
.
ok
(
await
preference_exists
(
TEST_URI
)
)
;
let
promisePurgeNotification
=
waitForPurgeNotification
(
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
await
promisePurgeNotification
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
}
async
function
test_content_preferences_cleared_with_subdomain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
"
)
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
await
add_preference
(
TEST_URI
)
;
Assert
.
ok
(
await
preference_exists
(
TEST_URI
)
)
;
let
promisePurgeNotification
=
waitForPurgeNotification
(
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
await
promisePurgeNotification
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
}
async
function
test_content_preferences_not_cleared_with_uri_contains_domain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
ilovemozilla
.
org
"
)
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
await
add_preference
(
TEST_URI
)
;
Assert
.
ok
(
await
preference_exists
(
TEST_URI
)
)
;
let
promisePurgeNotification
=
waitForPurgeNotification
(
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
await
promisePurgeNotification
;
Assert
.
ok
(
await
preference_exists
(
TEST_URI
)
)
;
promisePurgeNotification
=
waitForPurgeNotification
(
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
ilovemozilla
.
org
"
)
;
await
promisePurgeNotification
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
}
function
push_registration_exists
(
aURL
ps
)
{
return
new
Promise
(
resolve
=
>
{
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
aURL
)
;
return
ps
.
getSubscription
(
aURL
principal
(
status
record
)
=
>
{
if
(
!
Components
.
isSuccessCode
(
status
)
)
{
resolve
(
false
)
;
}
else
{
resolve
(
!
!
record
)
;
}
}
)
;
}
)
;
}
async
function
test_push_cleared
(
)
{
let
ps
;
try
{
ps
=
Cc
[
"
mozilla
.
org
/
push
/
Service
;
1
"
]
.
getService
(
Ci
.
nsIPushService
)
;
}
catch
(
e
)
{
return
;
}
do_get_profile
(
)
;
setPrefs
(
)
;
const
{
PushService
PushServiceWebSocket
}
=
serviceExports
;
const
userAgentID
=
"
bd744428
-
f125
-
436a
-
b6d0
-
dd0c9845837f
"
;
const
channelID
=
"
0ef2ad4a
-
6c49
-
41ad
-
af6e
-
95d2425276bf
"
;
let
db
=
PushServiceWebSocket
.
newPushDB
(
)
;
try
{
PushService
.
init
(
{
serverURI
:
"
wss
:
/
/
push
.
example
.
org
/
"
db
makeWebSocket
(
uriObj
)
{
return
new
MockWebSocket
(
uriObj
{
onHello
(
request
)
{
this
.
serverSendMsg
(
JSON
.
stringify
(
{
messageType
:
"
hello
"
status
:
200
uaid
:
userAgentID
}
)
)
;
}
}
)
;
}
}
)
;
const
TEST_URL
=
"
https
:
/
/
www
.
mozilla
.
org
/
scope
/
"
;
Assert
.
equal
(
false
await
push_registration_exists
(
TEST_URL
ps
)
)
;
await
db
.
put
(
{
channelID
pushEndpoint
:
"
https
:
/
/
example
.
org
/
update
/
clear
-
success
"
scope
:
TEST_URL
version
:
1
originAttributes
:
"
"
quota
:
Infinity
}
)
;
Assert
.
ok
(
await
push_registration_exists
(
TEST_URL
ps
)
)
;
let
promisePurgeNotification
=
waitForPurgeNotification
(
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
await
promisePurgeNotification
;
Assert
.
equal
(
false
await
push_registration_exists
(
TEST_URL
ps
)
)
;
}
finally
{
await
PushService
.
_shutdownService
(
)
;
}
}
async
function
test_cache_cleared
(
)
{
Assert
.
ok
(
tests
[
tests
.
length
-
1
]
=
=
test_cache_cleared
)
;
let
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
Services
.
obs
.
removeObserver
(
observer
"
cacheservice
:
empty
-
cache
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
quit
-
application
"
)
;
do_test_finished
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
"
cacheservice
:
empty
-
cache
"
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
do_test_pending
(
)
;
}
async
function
test_storage_cleared
(
)
{
function
getStorageForURI
(
aURI
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
aURI
{
}
)
;
return
Services
.
domStorageManager
.
createStorage
(
null
principal
"
"
)
;
}
let
s
=
[
getStorageForURI
(
Services
.
io
.
newURI
(
"
http
:
/
/
mozilla
.
org
"
)
)
getStorageForURI
(
Services
.
io
.
newURI
(
"
http
:
/
/
my
.
mozilla
.
org
"
)
)
getStorageForURI
(
Services
.
io
.
newURI
(
"
http
:
/
/
ilovemozilla
.
org
"
)
)
]
;
for
(
let
i
=
0
;
i
<
s
.
length
;
+
+
i
)
{
let
storage
=
s
[
i
]
;
storage
.
setItem
(
"
test
"
"
value
"
+
i
)
;
Assert
.
equal
(
storage
.
length
1
)
;
Assert
.
equal
(
storage
.
key
(
0
)
"
test
"
)
;
Assert
.
equal
(
storage
.
getItem
(
"
test
"
)
"
value
"
+
i
)
;
}
let
promisePurgeNotification
=
waitForPurgeNotification
(
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
await
promisePurgeNotification
;
Assert
.
equal
(
s
[
0
]
.
getItem
(
"
test
"
)
null
)
;
Assert
.
equal
(
s
[
0
]
.
length
0
)
;
Assert
.
equal
(
s
[
1
]
.
getItem
(
"
test
"
)
null
)
;
Assert
.
equal
(
s
[
1
]
.
length
0
)
;
Assert
.
equal
(
s
[
2
]
.
getItem
(
"
test
"
)
"
value2
"
)
;
Assert
.
equal
(
s
[
2
]
.
length
1
)
;
}
var
tests
=
[
test_history_cleared_with_direct_match
test_history_cleared_with_subdomain
test_history_not_cleared_with_uri_contains_domain
test_cookie_cleared_with_direct_match
test_cookie_cleared_with_subdomain
test_cookie_not_cleared_with_uri_contains_domain
test_login_manager_disabled_hosts_cleared_with_direct_match
test_login_manager_disabled_hosts_cleared_with_subdomain
test_login_manager_disabled_hosts_not_cleared_with_uri_contains_domain
test_login_manager_logins_cleared_with_direct_match
test_login_manager_logins_cleared_with_subdomain
test_login_manager_logins_not_cleared_with_uri_contains_domain
test_permission_manager_cleared_with_direct_match
test_permission_manager_cleared_with_subdomain
test_permission_manager_not_cleared_with_uri_contains_domain
test_content_preferences_cleared_with_direct_match
test_content_preferences_cleared_with_subdomain
test_content_preferences_not_cleared_with_uri_contains_domain
test_push_cleared
test_storage_cleared
test_cache_cleared
]
;
function
run_test
(
)
{
for
(
let
i
=
0
;
i
<
tests
.
length
;
i
+
+
)
add_task
(
tests
[
i
]
)
;
run_next_test
(
)
;
}
