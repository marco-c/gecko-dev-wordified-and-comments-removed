#
ifdef
nsWindowsRestart_cpp
#
error
\
"
nsWindowsRestart
.
cpp
is
not
a
header
file
and
must
only
be
included
once
.
"
#
else
#
define
nsWindowsRestart_cpp
#
endif
#
include
"
mozilla
/
CmdLineAndEnvUtils
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
<
shellapi
.
h
>
#
include
<
userenv
.
h
>
#
ifndef
__MINGW32__
#
pragma
comment
(
lib
"
userenv
.
lib
"
)
#
endif
static
char16_t
*
AllocConvertUTF8toUTF16
(
const
char
*
arg
)
{
size_t
len
=
strlen
(
arg
)
;
char16_t
*
s
=
new
char16_t
[
(
len
+
1
)
*
sizeof
(
char16_t
)
]
;
if
(
!
s
)
return
nullptr
;
size_t
dstLen
=
:
:
MultiByteToWideChar
(
CP_UTF8
0
arg
len
reinterpret_cast
<
wchar_t
*
>
(
s
)
len
)
;
s
[
dstLen
]
=
0
;
return
s
;
}
static
void
FreeAllocStrings
(
int
argc
wchar_t
*
*
argv
)
{
while
(
argc
)
{
-
-
argc
;
delete
[
]
argv
[
argc
]
;
}
delete
[
]
argv
;
}
static
wchar_t
*
*
AllocConvertUTF8toUTF16Strings
(
int
argc
char
*
*
argv
)
{
wchar_t
*
*
argvConverted
=
new
wchar_t
*
[
argc
]
;
if
(
!
argvConverted
)
return
nullptr
;
for
(
int
i
=
0
;
i
<
argc
;
+
+
i
)
{
argvConverted
[
i
]
=
reinterpret_cast
<
wchar_t
*
>
(
AllocConvertUTF8toUTF16
(
argv
[
i
]
)
)
;
if
(
!
argvConverted
[
i
]
)
{
FreeAllocStrings
(
i
argvConverted
)
;
return
nullptr
;
}
}
return
argvConverted
;
}
static
bool
NeedToBreakAwayFromJob
(
)
{
BOOL
inJob
=
FALSE
;
if
(
!
:
:
IsProcessInJob
(
:
:
GetCurrentProcess
(
)
nullptr
&
inJob
)
)
{
return
false
;
}
if
(
!
inJob
)
{
return
false
;
}
JOBOBJECT_EXTENDED_LIMIT_INFORMATION
job_info
=
{
}
;
if
(
!
:
:
QueryInformationJobObject
(
nullptr
JobObjectExtendedLimitInformation
&
job_info
sizeof
(
job_info
)
nullptr
)
)
{
return
false
;
}
if
(
!
(
job_info
.
BasicLimitInformation
.
LimitFlags
&
JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE
)
)
{
return
false
;
}
if
(
!
(
job_info
.
BasicLimitInformation
.
LimitFlags
&
JOB_OBJECT_LIMIT_BREAKAWAY_OK
)
)
{
return
false
;
}
return
true
;
}
BOOL
WinLaunchChild
(
const
wchar_t
*
exePath
int
argc
wchar_t
*
*
argv
HANDLE
userToken
=
nullptr
HANDLE
*
hProcess
=
nullptr
)
;
BOOL
WinLaunchChild
(
const
wchar_t
*
exePath
int
argc
char
*
*
argv
HANDLE
userToken
HANDLE
*
hProcess
)
{
wchar_t
*
*
argvConverted
=
AllocConvertUTF8toUTF16Strings
(
argc
argv
)
;
if
(
!
argvConverted
)
return
FALSE
;
BOOL
ok
=
WinLaunchChild
(
exePath
argc
argvConverted
userToken
hProcess
)
;
FreeAllocStrings
(
argc
argvConverted
)
;
return
ok
;
}
BOOL
WinLaunchChild
(
const
wchar_t
*
exePath
int
argc
wchar_t
*
*
argv
HANDLE
userToken
HANDLE
*
hProcess
)
{
BOOL
ok
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
cl
(
mozilla
:
:
MakeCommandLine
(
argc
argv
)
)
;
if
(
!
cl
)
{
return
FALSE
;
}
DWORD
creationFlags
=
NeedToBreakAwayFromJob
(
)
?
CREATE_BREAKAWAY_FROM_JOB
:
0
;
STARTUPINFOW
si
=
{
0
}
;
si
.
cb
=
sizeof
(
STARTUPINFOW
)
;
si
.
lpDesktop
=
const_cast
<
LPWSTR
>
(
L
"
winsta0
\
\
Default
"
)
;
PROCESS_INFORMATION
pi
=
{
0
}
;
if
(
userToken
=
=
nullptr
)
{
ok
=
CreateProcessW
(
exePath
cl
.
get
(
)
nullptr
nullptr
FALSE
creationFlags
nullptr
nullptr
&
si
&
pi
)
;
}
else
{
LPVOID
environmentBlock
=
nullptr
;
if
(
!
CreateEnvironmentBlock
(
&
environmentBlock
userToken
TRUE
)
)
{
environmentBlock
=
nullptr
;
}
ok
=
CreateProcessAsUserW
(
userToken
exePath
cl
.
get
(
)
nullptr
nullptr
FALSE
creationFlags
environmentBlock
nullptr
&
si
&
pi
)
;
if
(
environmentBlock
)
{
DestroyEnvironmentBlock
(
environmentBlock
)
;
}
}
if
(
ok
)
{
if
(
hProcess
)
{
*
hProcess
=
pi
.
hProcess
;
}
else
{
CloseHandle
(
pi
.
hProcess
)
;
}
CloseHandle
(
pi
.
hThread
)
;
}
else
{
LPVOID
lpMsgBuf
=
nullptr
;
FormatMessage
(
FORMAT_MESSAGE_ALLOCATE_BUFFER
|
FORMAT_MESSAGE_FROM_SYSTEM
|
FORMAT_MESSAGE_IGNORE_INSERTS
nullptr
GetLastError
(
)
MAKELANGID
(
LANG_NEUTRAL
SUBLANG_DEFAULT
)
(
LPTSTR
)
&
lpMsgBuf
0
nullptr
)
;
wprintf
(
L
"
Error
restarting
:
%
s
\
n
"
lpMsgBuf
?
static_cast
<
const
wchar_t
*
>
(
lpMsgBuf
)
:
L
"
(
null
)
"
)
;
if
(
lpMsgBuf
)
LocalFree
(
lpMsgBuf
)
;
}
return
ok
;
}
