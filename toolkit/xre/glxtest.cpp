#
include
<
cstdio
>
#
include
<
cstdlib
>
#
include
<
unistd
.
h
>
#
include
<
dlfcn
.
h
>
#
include
"
nscore
.
h
"
#
include
<
fcntl
.
h
>
#
include
"
stdint
.
h
"
#
ifdef
__SUNPRO_CC
#
include
<
stdio
.
h
>
#
endif
#
include
"
X11
/
Xlib
.
h
"
#
include
"
X11
/
Xutil
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
ifdef
MOZ_WAYLAND
#
include
"
nsAppRunner
.
h
"
#
include
"
mozilla
/
widget
/
mozwayland
.
h
"
#
endif
typedef
struct
__GLXcontextRec
*
GLXContext
;
typedef
XID
GLXPixmap
;
typedef
XID
GLXDrawable
;
typedef
struct
__GLXFBConfigRec
*
GLXFBConfig
;
typedef
XID
GLXFBConfigID
;
typedef
XID
GLXContextID
;
typedef
XID
GLXWindow
;
typedef
XID
GLXPbuffer
;
#
define
GLX_RGBA
4
#
define
GLX_RED_SIZE
8
#
define
GLX_GREEN_SIZE
9
#
define
GLX_BLUE_SIZE
10
typedef
uint8_t
GLubyte
;
typedef
uint32_t
GLenum
;
#
define
GL_VENDOR
0x1F00
#
define
GL_RENDERER
0x1F01
#
define
GL_VERSION
0x1F02
#
define
GLX_RENDERER_VENDOR_ID_MESA
0x8183
#
define
GLX_RENDERER_DEVICE_ID_MESA
0x8184
#
define
GLX_RENDERER_VERSION_MESA
0x8185
#
define
GLX_RENDERER_ACCELERATED_MESA
0x8186
#
define
GLX_RENDERER_VIDEO_MEMORY_MESA
0x8187
#
define
GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA
0x8188
#
define
GLX_RENDERER_PREFERRED_PROFILE_MESA
0x8189
#
define
GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA
0x818A
#
define
GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA
0x818B
#
define
GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA
0x818C
#
define
GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA
0x818D
#
define
GLX_RENDERER_ID_MESA
0x818E
#
define
EGL_BLUE_SIZE
0x3022
#
define
EGL_GREEN_SIZE
0x3023
#
define
EGL_RED_SIZE
0x3024
#
define
EGL_NONE
0x3038
#
define
EGL_VENDOR
0x3053
#
define
EGL_CONTEXT_CLIENT_VERSION
0x3098
#
define
EGL_NO_CONTEXT
nullptr
#
define
EXIT_FAILURE_BUFFER_TOO_SMALL
2
namespace
mozilla
{
namespace
widget
{
extern
int
glxtest_pipe
;
extern
pid_t
glxtest_pid
;
}
}
static
int
write_end_of_the_pipe
=
-
1
;
static
char
*
glxtest_buf
=
nullptr
;
static
int
glxtest_bufsize
=
0
;
static
int
glxtest_length
=
0
;
template
<
typename
func_ptr_type
>
static
func_ptr_type
cast
(
void
*
ptr
)
{
return
reinterpret_cast
<
func_ptr_type
>
(
reinterpret_cast
<
size_t
>
(
ptr
)
)
;
}
static
void
record_value
(
const
char
*
format
.
.
.
)
{
if
(
glxtest_bufsize
<
=
glxtest_length
)
{
return
;
}
int
remaining
=
glxtest_bufsize
-
glxtest_length
;
va_list
args
;
va_start
(
args
format
)
;
int
max_added
=
vsnprintf
(
glxtest_buf
+
glxtest_length
remaining
format
args
)
;
va_end
(
args
)
;
if
(
max_added
>
remaining
)
{
glxtest_length
+
=
remaining
;
}
else
{
glxtest_length
+
=
max_added
;
}
}
static
void
record_error
(
const
char
*
str
)
{
record_value
(
"
ERROR
\
n
%
s
\
n
"
str
)
;
}
static
void
record_warning
(
const
char
*
str
)
{
record_value
(
"
WARNING
\
n
%
s
\
n
"
str
)
;
}
static
void
record_flush
(
)
{
mozilla
:
:
Unused
<
<
write
(
write_end_of_the_pipe
glxtest_buf
glxtest_length
)
;
}
static
int
x_error_handler
(
Display
*
XErrorEvent
*
ev
)
{
record_value
(
"
ERROR
\
nX
error
error_code
=
%
d
"
"
request_code
=
%
d
minor_code
=
%
d
\
n
"
ev
-
>
error_code
ev
-
>
request_code
ev
-
>
minor_code
)
;
record_flush
(
)
;
_exit
(
EXIT_FAILURE
)
;
return
0
;
}
extern
"
C
"
{
#
define
PCI_FILL_IDENT
0x0001
#
define
PCI_FILL_CLASS
0x0020
#
define
PCI_BASE_CLASS_DISPLAY
0x03
static
void
get_pci_status
(
)
{
void
*
libpci
=
dlopen
(
"
libpci
.
so
.
3
"
RTLD_LAZY
)
;
if
(
!
libpci
)
{
libpci
=
dlopen
(
"
libpci
.
so
"
RTLD_LAZY
)
;
}
if
(
!
libpci
)
{
record_warning
(
"
libpci
missing
"
)
;
return
;
}
typedef
struct
pci_dev
{
struct
pci_dev
*
next
;
uint16_t
domain_16
;
uint8_t
bus
dev
func
;
unsigned
int
known_fields
;
uint16_t
vendor_id
device_id
;
uint16_t
device_class
;
}
pci_dev
;
typedef
struct
pci_access
{
unsigned
int
method
;
int
writeable
;
int
buscentric
;
char
*
id_file_name
;
int
free_id_name
;
int
numeric_ids
;
unsigned
int
id_lookup_mode
;
int
debugging
;
void
*
error
;
void
*
warning
;
void
*
debug
;
pci_dev
*
devices
;
}
pci_access
;
typedef
pci_access
*
(
*
PCIALLOC
)
(
void
)
;
PCIALLOC
pci_alloc
=
cast
<
PCIALLOC
>
(
dlsym
(
libpci
"
pci_alloc
"
)
)
;
typedef
void
(
*
PCIINIT
)
(
pci_access
*
)
;
PCIINIT
pci_init
=
cast
<
PCIINIT
>
(
dlsym
(
libpci
"
pci_init
"
)
)
;
typedef
void
(
*
PCICLEANUP
)
(
pci_access
*
)
;
PCICLEANUP
pci_cleanup
=
cast
<
PCICLEANUP
>
(
dlsym
(
libpci
"
pci_cleanup
"
)
)
;
typedef
void
(
*
PCISCANBUS
)
(
pci_access
*
)
;
PCISCANBUS
pci_scan_bus
=
cast
<
PCISCANBUS
>
(
dlsym
(
libpci
"
pci_scan_bus
"
)
)
;
typedef
void
(
*
PCIFILLINFO
)
(
pci_dev
*
int
)
;
PCIFILLINFO
pci_fill_info
=
cast
<
PCIFILLINFO
>
(
dlsym
(
libpci
"
pci_fill_info
"
)
)
;
if
(
!
pci_alloc
|
|
!
pci_cleanup
|
|
!
pci_scan_bus
|
|
!
pci_fill_info
)
{
dlclose
(
libpci
)
;
record_warning
(
"
libpci
missing
methods
"
)
;
return
;
}
pci_access
*
pacc
=
pci_alloc
(
)
;
if
(
!
pacc
)
{
dlclose
(
libpci
)
;
record_warning
(
"
libpci
alloc
failed
"
)
;
return
;
}
pci_init
(
pacc
)
;
pci_scan_bus
(
pacc
)
;
for
(
pci_dev
*
dev
=
pacc
-
>
devices
;
dev
;
dev
=
dev
-
>
next
)
{
pci_fill_info
(
dev
PCI_FILL_IDENT
|
PCI_FILL_CLASS
)
;
if
(
dev
-
>
device_class
>
>
8
=
=
PCI_BASE_CLASS_DISPLAY
&
&
dev
-
>
vendor_id
&
&
dev
-
>
device_id
)
{
record_value
(
"
PCI_VENDOR_ID
\
n0x
%
04x
\
nPCI_DEVICE_ID
\
n0x
%
04x
\
n
"
dev
-
>
vendor_id
dev
-
>
device_id
)
;
}
}
pci_cleanup
(
pacc
)
;
dlclose
(
libpci
)
;
}
typedef
void
*
EGLNativeDisplayType
;
typedef
void
*
EGLDisplay
;
typedef
int
EGLBoolean
;
typedef
int
EGLint
;
typedef
void
*
(
*
PFNEGLGETPROCADDRESS
)
(
const
char
*
)
;
static
void
get_gles_status
(
EGLDisplay
dpy
PFNEGLGETPROCADDRESS
eglGetProcAddress
)
{
typedef
void
*
EGLConfig
;
typedef
void
*
EGLContext
;
typedef
void
*
EGLSurface
;
typedef
EGLBoolean
(
*
PFNEGLCHOOSECONFIGPROC
)
(
EGLDisplay
dpy
EGLint
const
*
attrib_list
EGLConfig
*
configs
EGLint
config_size
EGLint
*
num_config
)
;
PFNEGLCHOOSECONFIGPROC
eglChooseConfig
=
cast
<
PFNEGLCHOOSECONFIGPROC
>
(
eglGetProcAddress
(
"
eglChooseConfig
"
)
)
;
typedef
EGLContext
(
*
PFNEGLCREATECONTEXTPROC
)
(
EGLDisplay
dpy
EGLConfig
config
EGLContext
share_context
EGLint
const
*
attrib_list
)
;
PFNEGLCREATECONTEXTPROC
eglCreateContext
=
cast
<
PFNEGLCREATECONTEXTPROC
>
(
eglGetProcAddress
(
"
eglCreateContext
"
)
)
;
typedef
EGLSurface
(
*
PFNEGLCREATEPBUFFERSURFACEPROC
)
(
EGLDisplay
dpy
EGLConfig
config
EGLint
const
*
attrib_list
)
;
PFNEGLCREATEPBUFFERSURFACEPROC
eglCreatePbufferSurface
=
cast
<
PFNEGLCREATEPBUFFERSURFACEPROC
>
(
eglGetProcAddress
(
"
eglCreatePbufferSurface
"
)
)
;
typedef
EGLBoolean
(
*
PFNEGLMAKECURRENTPROC
)
(
EGLDisplay
dpy
EGLSurface
draw
EGLSurface
read
EGLContext
context
)
;
PFNEGLMAKECURRENTPROC
eglMakeCurrent
=
cast
<
PFNEGLMAKECURRENTPROC
>
(
eglGetProcAddress
(
"
eglMakeCurrent
"
)
)
;
if
(
!
eglChooseConfig
|
|
!
eglCreateContext
|
|
!
eglCreatePbufferSurface
|
|
!
eglMakeCurrent
)
{
record_error
(
"
libEGL
missing
methods
for
GLES
test
"
)
;
return
;
}
void
*
libgles
=
dlopen
(
"
libGLESv2
.
so
.
2
"
RTLD_LAZY
)
;
if
(
!
libgles
)
{
libgles
=
dlopen
(
"
libGLESv2
.
so
"
RTLD_LAZY
)
;
}
if
(
!
libgles
)
{
record_error
(
"
libGLESv2
missing
"
)
;
return
;
}
typedef
GLubyte
*
(
*
PFNGLGETSTRING
)
(
GLenum
)
;
PFNGLGETSTRING
glGetString
=
cast
<
PFNGLGETSTRING
>
(
eglGetProcAddress
(
"
glGetString
"
)
)
;
if
(
!
glGetString
)
{
glGetString
=
cast
<
PFNGLGETSTRING
>
(
dlsym
(
libgles
"
glGetString
"
)
)
;
}
if
(
!
glGetString
)
{
dlclose
(
libgles
)
;
record_error
(
"
libGLESv2
glGetString
missing
"
)
;
return
;
}
EGLint
config_attrs
[
]
=
{
EGL_RED_SIZE
8
EGL_GREEN_SIZE
8
EGL_BLUE_SIZE
8
EGL_NONE
}
;
EGLConfig
config
;
EGLint
num_config
;
eglChooseConfig
(
dpy
config_attrs
&
config
1
&
num_config
)
;
EGLint
ctx_attrs
[
]
=
{
EGL_CONTEXT_CLIENT_VERSION
3
EGL_NONE
}
;
EGLContext
ectx
=
eglCreateContext
(
dpy
config
EGL_NO_CONTEXT
ctx_attrs
)
;
EGLSurface
pbuf
=
eglCreatePbufferSurface
(
dpy
config
nullptr
)
;
eglMakeCurrent
(
dpy
pbuf
pbuf
ectx
)
;
const
GLubyte
*
versionString
=
glGetString
(
GL_VERSION
)
;
const
GLubyte
*
vendorString
=
glGetString
(
GL_VENDOR
)
;
const
GLubyte
*
rendererString
=
glGetString
(
GL_RENDERER
)
;
if
(
versionString
&
&
vendorString
&
&
rendererString
)
{
record_value
(
"
VENDOR
\
n
%
s
\
nRENDERER
\
n
%
s
\
nVERSION
\
n
%
s
\
nTFP
\
nTRUE
\
n
"
vendorString
rendererString
versionString
)
;
}
else
{
record_error
(
"
libGLESv2
glGetString
returned
null
"
)
;
}
dlclose
(
libgles
)
;
}
static
void
get_egl_status
(
EGLNativeDisplayType
native_dpy
bool
gles_test
)
{
void
*
libegl
=
dlopen
(
"
libEGL
.
so
.
1
"
RTLD_LAZY
)
;
if
(
!
libegl
)
{
libegl
=
dlopen
(
"
libEGL
.
so
"
RTLD_LAZY
)
;
}
if
(
!
libegl
)
{
record_warning
(
"
libEGL
missing
"
)
;
return
;
}
PFNEGLGETPROCADDRESS
eglGetProcAddress
=
cast
<
PFNEGLGETPROCADDRESS
>
(
dlsym
(
libegl
"
eglGetProcAddress
"
)
)
;
if
(
!
eglGetProcAddress
)
{
dlclose
(
libegl
)
;
record_error
(
"
no
eglGetProcAddress
"
)
;
return
;
}
typedef
EGLDisplay
(
*
PFNEGLGETDISPLAYPROC
)
(
void
*
native_display
)
;
PFNEGLGETDISPLAYPROC
eglGetDisplay
=
cast
<
PFNEGLGETDISPLAYPROC
>
(
eglGetProcAddress
(
"
eglGetDisplay
"
)
)
;
typedef
EGLBoolean
(
*
PFNEGLINITIALIZEPROC
)
(
EGLDisplay
dpy
EGLint
*
major
EGLint
*
minor
)
;
PFNEGLINITIALIZEPROC
eglInitialize
=
cast
<
PFNEGLINITIALIZEPROC
>
(
eglGetProcAddress
(
"
eglInitialize
"
)
)
;
typedef
EGLBoolean
(
*
PFNEGLTERMINATEPROC
)
(
EGLDisplay
dpy
)
;
PFNEGLTERMINATEPROC
eglTerminate
=
cast
<
PFNEGLTERMINATEPROC
>
(
eglGetProcAddress
(
"
eglTerminate
"
)
)
;
if
(
!
eglGetDisplay
|
|
!
eglInitialize
|
|
!
eglTerminate
)
{
dlclose
(
libegl
)
;
record_error
(
"
libEGL
missing
methods
"
)
;
return
;
}
EGLDisplay
dpy
=
eglGetDisplay
(
native_dpy
)
;
if
(
!
dpy
)
{
dlclose
(
libegl
)
;
record_warning
(
"
libEGL
no
display
"
)
;
return
;
}
EGLint
major
minor
;
if
(
!
eglInitialize
(
dpy
&
major
&
minor
)
)
{
dlclose
(
libegl
)
;
record_warning
(
"
libEGL
initialize
failed
"
)
;
return
;
}
if
(
gles_test
)
{
get_gles_status
(
dpy
eglGetProcAddress
)
;
}
typedef
const
char
*
(
*
PFNEGLGETDISPLAYDRIVERNAMEPROC
)
(
EGLDisplay
dpy
)
;
PFNEGLGETDISPLAYDRIVERNAMEPROC
eglGetDisplayDriverName
=
cast
<
PFNEGLGETDISPLAYDRIVERNAMEPROC
>
(
eglGetProcAddress
(
"
eglGetDisplayDriverName
"
)
)
;
if
(
eglGetDisplayDriverName
)
{
const
char
*
driDriver
=
eglGetDisplayDriverName
(
dpy
)
;
if
(
driDriver
)
{
record_value
(
"
DRI_DRIVER
\
n
%
s
\
n
"
driDriver
)
;
}
}
eglTerminate
(
dpy
)
;
dlclose
(
libegl
)
;
}
static
void
get_glx_status
(
int
*
gotGlxInfo
int
*
gotDriDriver
)
{
#
if
defined
(
__OpenBSD__
)
|
|
defined
(
__NetBSD__
)
#
define
LIBGL_FILENAME
"
libGL
.
so
"
#
else
#
define
LIBGL_FILENAME
"
libGL
.
so
.
1
"
#
endif
void
*
libgl
=
dlopen
(
LIBGL_FILENAME
RTLD_LAZY
)
;
if
(
!
libgl
)
{
record_error
(
LIBGL_FILENAME
"
missing
"
)
;
return
;
}
typedef
void
*
(
*
PFNGLXGETPROCADDRESS
)
(
const
char
*
)
;
PFNGLXGETPROCADDRESS
glXGetProcAddress
=
cast
<
PFNGLXGETPROCADDRESS
>
(
dlsym
(
libgl
"
glXGetProcAddress
"
)
)
;
if
(
!
glXGetProcAddress
)
{
record_error
(
"
no
glXGetProcAddress
"
)
;
return
;
}
typedef
GLXFBConfig
*
(
*
PFNGLXQUERYEXTENSION
)
(
Display
*
int
*
int
*
)
;
PFNGLXQUERYEXTENSION
glXQueryExtension
=
cast
<
PFNGLXQUERYEXTENSION
>
(
glXGetProcAddress
(
"
glXQueryExtension
"
)
)
;
typedef
GLXFBConfig
*
(
*
PFNGLXQUERYVERSION
)
(
Display
*
int
*
int
*
)
;
PFNGLXQUERYVERSION
glXQueryVersion
=
cast
<
PFNGLXQUERYVERSION
>
(
dlsym
(
libgl
"
glXQueryVersion
"
)
)
;
typedef
XVisualInfo
*
(
*
PFNGLXCHOOSEVISUAL
)
(
Display
*
int
int
*
)
;
PFNGLXCHOOSEVISUAL
glXChooseVisual
=
cast
<
PFNGLXCHOOSEVISUAL
>
(
glXGetProcAddress
(
"
glXChooseVisual
"
)
)
;
typedef
GLXContext
(
*
PFNGLXCREATECONTEXT
)
(
Display
*
XVisualInfo
*
GLXContext
Bool
)
;
PFNGLXCREATECONTEXT
glXCreateContext
=
cast
<
PFNGLXCREATECONTEXT
>
(
glXGetProcAddress
(
"
glXCreateContext
"
)
)
;
typedef
Bool
(
*
PFNGLXMAKECURRENT
)
(
Display
*
GLXDrawable
GLXContext
)
;
PFNGLXMAKECURRENT
glXMakeCurrent
=
cast
<
PFNGLXMAKECURRENT
>
(
glXGetProcAddress
(
"
glXMakeCurrent
"
)
)
;
typedef
void
(
*
PFNGLXDESTROYCONTEXT
)
(
Display
*
GLXContext
)
;
PFNGLXDESTROYCONTEXT
glXDestroyContext
=
cast
<
PFNGLXDESTROYCONTEXT
>
(
glXGetProcAddress
(
"
glXDestroyContext
"
)
)
;
typedef
GLubyte
*
(
*
PFNGLGETSTRING
)
(
GLenum
)
;
PFNGLGETSTRING
glGetString
=
cast
<
PFNGLGETSTRING
>
(
glXGetProcAddress
(
"
glGetString
"
)
)
;
if
(
!
glXQueryExtension
|
|
!
glXQueryVersion
|
|
!
glXChooseVisual
|
|
!
glXCreateContext
|
|
!
glXMakeCurrent
|
|
!
glXDestroyContext
|
|
!
glGetString
)
{
record_error
(
LIBGL_FILENAME
"
missing
methods
"
)
;
return
;
}
Display
*
dpy
=
XOpenDisplay
(
nullptr
)
;
if
(
!
dpy
)
{
record_error
(
"
Unable
to
open
a
connection
to
the
X
server
"
)
;
return
;
}
if
(
!
glXQueryExtension
(
dpy
nullptr
nullptr
)
)
{
record_error
(
"
GLX
extension
missing
"
)
;
return
;
}
XSetErrorHandler
(
x_error_handler
)
;
int
attribs
[
]
=
{
GLX_RGBA
GLX_RED_SIZE
1
GLX_GREEN_SIZE
1
GLX_BLUE_SIZE
1
None
}
;
XVisualInfo
*
vInfo
=
glXChooseVisual
(
dpy
DefaultScreen
(
dpy
)
attribs
)
;
if
(
!
vInfo
)
{
record_error
(
"
No
visuals
found
"
)
;
return
;
}
Window
window
;
XSetWindowAttributes
swa
;
swa
.
colormap
=
XCreateColormap
(
dpy
RootWindow
(
dpy
vInfo
-
>
screen
)
vInfo
-
>
visual
AllocNone
)
;
swa
.
border_pixel
=
0
;
window
=
XCreateWindow
(
dpy
RootWindow
(
dpy
vInfo
-
>
screen
)
0
0
16
16
0
vInfo
-
>
depth
InputOutput
vInfo
-
>
visual
CWBorderPixel
|
CWColormap
&
swa
)
;
GLXContext
context
=
glXCreateContext
(
dpy
vInfo
nullptr
True
)
;
glXMakeCurrent
(
dpy
window
context
)
;
void
*
glXBindTexImageEXT
=
glXGetProcAddress
(
"
glXBindTexImageEXT
"
)
;
const
GLubyte
*
versionString
=
glGetString
(
GL_VERSION
)
;
const
GLubyte
*
vendorString
=
glGetString
(
GL_VENDOR
)
;
const
GLubyte
*
rendererString
=
glGetString
(
GL_RENDERER
)
;
if
(
versionString
&
&
vendorString
&
&
rendererString
)
{
record_value
(
"
VENDOR
\
n
%
s
\
nRENDERER
\
n
%
s
\
nVERSION
\
n
%
s
\
nTFP
\
n
%
s
\
n
"
vendorString
rendererString
versionString
glXBindTexImageEXT
?
"
TRUE
"
:
"
FALSE
"
)
;
*
gotGlxInfo
=
1
;
}
else
{
record_error
(
"
glGetString
returned
null
"
)
;
}
typedef
Bool
(
*
PFNGLXQUERYCURRENTRENDERERINTEGERMESAPROC
)
(
int
attribute
unsigned
int
*
value
)
;
PFNGLXQUERYCURRENTRENDERERINTEGERMESAPROC
glXQueryCurrentRendererIntegerMESAProc
=
cast
<
PFNGLXQUERYCURRENTRENDERERINTEGERMESAPROC
>
(
glXGetProcAddress
(
"
glXQueryCurrentRendererIntegerMESA
"
)
)
;
if
(
glXQueryCurrentRendererIntegerMESAProc
)
{
unsigned
int
vendorId
deviceId
accelerated
videoMemoryMB
;
glXQueryCurrentRendererIntegerMESAProc
(
GLX_RENDERER_VENDOR_ID_MESA
&
vendorId
)
;
glXQueryCurrentRendererIntegerMESAProc
(
GLX_RENDERER_DEVICE_ID_MESA
&
deviceId
)
;
glXQueryCurrentRendererIntegerMESAProc
(
GLX_RENDERER_ACCELERATED_MESA
&
accelerated
)
;
glXQueryCurrentRendererIntegerMESAProc
(
GLX_RENDERER_VIDEO_MEMORY_MESA
&
videoMemoryMB
)
;
vendorId
&
=
0xFFFF
;
deviceId
&
=
0xFFFF
;
record_value
(
"
MESA_VENDOR_ID
\
n0x
%
04x
\
n
"
"
MESA_DEVICE_ID
\
n0x
%
04x
\
n
"
"
MESA_ACCELERATED
\
n
%
s
\
n
"
"
MESA_VRAM
\
n
%
dMB
\
n
"
vendorId
deviceId
accelerated
?
"
TRUE
"
:
"
FALSE
"
videoMemoryMB
)
;
}
typedef
const
char
*
(
*
PFNGLXGETSCREENDRIVERPROC
)
(
Display
*
dpy
int
scrNum
)
;
PFNGLXGETSCREENDRIVERPROC
glXGetScreenDriverProc
=
cast
<
PFNGLXGETSCREENDRIVERPROC
>
(
glXGetProcAddress
(
"
glXGetScreenDriver
"
)
)
;
if
(
glXGetScreenDriverProc
)
{
const
char
*
driDriver
=
glXGetScreenDriverProc
(
dpy
DefaultScreen
(
dpy
)
)
;
if
(
driDriver
)
{
*
gotDriDriver
=
1
;
record_value
(
"
DRI_DRIVER
\
n
%
s
\
n
"
driDriver
)
;
}
}
int
screenCount
=
ScreenCount
(
dpy
)
;
int
defaultScreen
=
DefaultScreen
(
dpy
)
;
if
(
screenCount
!
=
0
)
{
record_value
(
"
SCREEN_INFO
\
n
"
)
;
for
(
int
idx
=
0
;
idx
<
screenCount
;
idx
+
+
)
{
Screen
*
scrn
=
ScreenOfDisplay
(
dpy
idx
)
;
int
current_height
=
scrn
-
>
height
;
int
current_width
=
scrn
-
>
width
;
record_value
(
"
%
dx
%
d
:
%
d
%
s
"
current_width
current_height
idx
=
=
defaultScreen
?
1
:
0
idx
=
=
screenCount
-
1
?
"
;
\
n
"
:
"
;
"
)
;
}
}
glXMakeCurrent
(
dpy
None
nullptr
)
;
glXDestroyContext
(
dpy
context
)
;
XDestroyWindow
(
dpy
window
)
;
XFreeColormap
(
dpy
swa
.
colormap
)
;
#
ifdef
NS_FREE_PERMANENT_DATA
XCloseDisplay
(
dpy
)
;
#
else
XSync
(
dpy
False
)
;
#
endif
dlclose
(
libgl
)
;
}
static
void
close_logging
(
)
{
int
fd
=
open
(
"
/
dev
/
null
"
O_WRONLY
)
;
for
(
int
i
=
1
;
i
<
fd
;
i
+
+
)
dup2
(
fd
i
)
;
close
(
fd
)
;
if
(
getenv
(
"
MOZ_AVOID_OPENGL_ALTOGETHER
"
)
)
{
const
char
*
msg
=
"
ERROR
\
nMOZ_AVOID_OPENGL_ALTOGETHER
envvar
set
"
;
mozilla
:
:
Unused
<
<
write
(
write_end_of_the_pipe
msg
strlen
(
msg
)
)
;
exit
(
EXIT_FAILURE
)
;
}
}
#
ifdef
MOZ_WAYLAND
static
bool
wayland_egltest
(
)
{
struct
wl_display
*
dpy
=
wl_display_connect
(
nullptr
)
;
if
(
!
dpy
)
{
return
false
;
}
get_egl_status
(
(
EGLNativeDisplayType
)
dpy
true
)
;
return
true
;
}
#
endif
static
void
glxtest
(
)
{
int
gotGlxInfo
=
0
;
int
gotDriDriver
=
0
;
get_glx_status
(
&
gotGlxInfo
&
gotDriDriver
)
;
if
(
!
gotGlxInfo
)
{
get_egl_status
(
nullptr
true
)
;
}
else
if
(
!
gotDriDriver
)
{
get_egl_status
(
nullptr
false
)
;
}
}
int
childgltest
(
)
{
enum
{
bufsize
=
2048
}
;
char
buf
[
bufsize
]
;
glxtest_buf
=
buf
;
glxtest_bufsize
=
bufsize
;
get_pci_status
(
)
;
#
ifdef
MOZ_WAYLAND
if
(
IsWaylandDisabled
(
)
|
|
getenv
(
"
DISPLAY
"
)
|
|
!
wayland_egltest
(
)
)
#
endif
{
glxtest
(
)
;
}
record_flush
(
)
;
if
(
glxtest_length
>
=
glxtest_bufsize
)
{
return
EXIT_FAILURE_BUFFER_TOO_SMALL
;
}
return
EXIT_SUCCESS
;
}
}
bool
fire_glxtest_process
(
)
{
int
pfd
[
2
]
;
if
(
pipe
(
pfd
)
=
=
-
1
)
{
perror
(
"
pipe
"
)
;
return
false
;
}
pid_t
pid
=
fork
(
)
;
if
(
pid
<
0
)
{
perror
(
"
fork
"
)
;
close
(
pfd
[
0
]
)
;
close
(
pfd
[
1
]
)
;
return
false
;
}
if
(
pid
=
=
0
)
{
close
(
pfd
[
0
]
)
;
write_end_of_the_pipe
=
pfd
[
1
]
;
close_logging
(
)
;
int
rv
=
childgltest
(
)
;
close
(
pfd
[
1
]
)
;
_exit
(
rv
)
;
}
close
(
pfd
[
1
]
)
;
mozilla
:
:
widget
:
:
glxtest_pipe
=
pfd
[
0
]
;
mozilla
:
:
widget
:
:
glxtest_pid
=
pid
;
return
false
;
}
