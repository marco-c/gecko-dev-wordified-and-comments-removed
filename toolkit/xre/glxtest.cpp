#
include
<
cstdio
>
#
include
<
cstdlib
>
#
include
<
dlfcn
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
unistd
.
h
>
#
if
defined
(
MOZ_ASAN
)
|
|
defined
(
FUZZING
)
#
include
<
signal
.
h
>
#
endif
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
stdint
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
ifdef
__SUNPRO_CC
#
include
<
stdio
.
h
>
#
endif
#
ifdef
MOZ_X11
#
include
"
X11
/
Xlib
.
h
"
#
include
"
X11
/
Xutil
.
h
"
#
include
<
X11
/
extensions
/
Xrandr
.
h
>
#
endif
#
ifdef
MOZ_WAYLAND
#
include
"
mozilla
/
widget
/
mozwayland
.
h
"
#
include
"
prlink
.
h
"
#
endif
#
include
<
vector
>
#
include
<
sys
/
wait
.
h
>
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
ifdef
MOZ_X11
typedef
struct
__GLXcontextRec
*
GLXContext
;
typedef
XID
GLXPixmap
;
typedef
XID
GLXDrawable
;
typedef
struct
__GLXFBConfigRec
*
GLXFBConfig
;
typedef
XID
GLXFBConfigID
;
typedef
XID
GLXContextID
;
typedef
XID
GLXWindow
;
typedef
XID
GLXPbuffer
;
#
define
GLX_RGBA
4
#
define
GLX_RED_SIZE
8
#
define
GLX_GREEN_SIZE
9
#
define
GLX_BLUE_SIZE
10
#
define
GLX_DOUBLEBUFFER
5
#
endif
typedef
uint8_t
GLubyte
;
typedef
uint32_t
GLenum
;
#
define
GL_VENDOR
0x1F00
#
define
GL_RENDERER
0x1F01
#
define
GL_VERSION
0x1F02
#
define
GLX_RENDERER_VENDOR_ID_MESA
0x8183
#
define
GLX_RENDERER_DEVICE_ID_MESA
0x8184
#
define
GLX_RENDERER_VERSION_MESA
0x8185
#
define
GLX_RENDERER_ACCELERATED_MESA
0x8186
#
define
GLX_RENDERER_VIDEO_MEMORY_MESA
0x8187
#
define
GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA
0x8188
#
define
GLX_RENDERER_PREFERRED_PROFILE_MESA
0x8189
#
define
GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA
0x818A
#
define
GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA
0x818B
#
define
GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA
0x818C
#
define
GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA
0x818D
#
define
GLX_RENDERER_ID_MESA
0x818E
typedef
intptr_t
EGLAttrib
;
typedef
int
EGLBoolean
;
typedef
void
*
EGLConfig
;
typedef
void
*
EGLContext
;
typedef
void
*
EGLDeviceEXT
;
typedef
void
*
EGLDisplay
;
typedef
unsigned
int
EGLenum
;
typedef
int
EGLint
;
typedef
void
*
EGLNativeDisplayType
;
typedef
void
*
EGLSurface
;
typedef
void
*
(
*
PFNEGLGETPROCADDRESS
)
(
const
char
*
)
;
#
define
EGL_NO_CONTEXT
nullptr
#
define
EGL_NO_SURFACE
nullptr
#
define
EGL_FALSE
0
#
define
EGL_TRUE
1
#
define
EGL_OPENGL_ES2_BIT
0x0004
#
define
EGL_BLUE_SIZE
0x3022
#
define
EGL_GREEN_SIZE
0x3023
#
define
EGL_RED_SIZE
0x3024
#
define
EGL_NONE
0x3038
#
define
EGL_RENDERABLE_TYPE
0x3040
#
define
EGL_VENDOR
0x3053
#
define
EGL_EXTENSIONS
0x3055
#
define
EGL_CONTEXT_MAJOR_VERSION
0x3098
#
define
EGL_OPENGL_ES_API
0x30A0
#
define
EGL_OPENGL_API
0x30A2
#
define
EGL_DEVICE_EXT
0x322C
#
define
EGL_DRM_DEVICE_FILE_EXT
0x3233
#
define
EGL_DRM_RENDER_NODE_FILE_EXT
0x3377
#
define
DRM_NODE_RENDER
2
#
define
DRM_NODE_MAX
3
typedef
struct
_drmPciDeviceInfo
{
uint16_t
vendor_id
;
uint16_t
device_id
;
uint16_t
subvendor_id
;
uint16_t
subdevice_id
;
uint8_t
revision_id
;
}
drmPciDeviceInfo
*
drmPciDeviceInfoPtr
;
typedef
struct
_drmDevice
{
char
*
*
nodes
;
int
available_nodes
;
int
bustype
;
union
{
void
*
pci
;
void
*
usb
;
void
*
platform
;
void
*
host1x
;
}
businfo
;
union
{
drmPciDeviceInfoPtr
pci
;
void
*
usb
;
void
*
platform
;
void
*
host1x
;
}
deviceinfo
;
}
drmDevice
*
drmDevicePtr
;
#
if
defined
(
__OpenBSD__
)
|
|
defined
(
__NetBSD__
)
#
define
LIBGL_FILENAME
"
libGL
.
so
"
#
define
LIBGLES_FILENAME
"
libGLESv2
.
so
"
#
define
LIBEGL_FILENAME
"
libEGL
.
so
"
#
define
LIBDRM_FILENAME
"
libdrm
.
so
"
#
else
#
define
LIBGL_FILENAME
"
libGL
.
so
.
1
"
#
define
LIBGLES_FILENAME
"
libGLESv2
.
so
.
2
"
#
define
LIBEGL_FILENAME
"
libEGL
.
so
.
1
"
#
define
LIBDRM_FILENAME
"
libdrm
.
so
.
2
"
#
endif
#
define
EXIT_FAILURE_BUFFER_TOO_SMALL
2
namespace
mozilla
{
namespace
widget
{
extern
int
glxtest_pipe
;
extern
pid_t
glxtest_pid
;
}
}
static
int
write_end_of_the_pipe
=
-
1
;
static
char
*
glxtest_buf
=
nullptr
;
static
int
glxtest_bufsize
=
0
;
static
int
glxtest_length
=
0
;
static
char
*
glxtest_render_device_path
=
nullptr
;
template
<
typename
func_ptr_type
>
static
func_ptr_type
cast
(
void
*
ptr
)
{
return
reinterpret_cast
<
func_ptr_type
>
(
reinterpret_cast
<
size_t
>
(
ptr
)
)
;
}
static
void
record_value
(
const
char
*
format
.
.
.
)
{
if
(
glxtest_bufsize
<
=
glxtest_length
)
{
return
;
}
int
remaining
=
glxtest_bufsize
-
glxtest_length
;
va_list
args
;
va_start
(
args
format
)
;
int
max_added
=
vsnprintf
(
glxtest_buf
+
glxtest_length
remaining
format
args
)
;
va_end
(
args
)
;
if
(
max_added
>
remaining
)
{
glxtest_length
+
=
remaining
;
}
else
{
glxtest_length
+
=
max_added
;
}
}
static
void
record_error
(
const
char
*
str
)
{
record_value
(
"
ERROR
\
n
%
s
\
n
"
str
)
;
}
static
void
record_warning
(
const
char
*
str
)
{
record_value
(
"
WARNING
\
n
%
s
\
n
"
str
)
;
}
static
void
record_flush
(
)
{
mozilla
:
:
Unused
<
<
write
(
write_end_of_the_pipe
glxtest_buf
glxtest_length
)
;
if
(
auto
*
debugFile
=
getenv
(
"
MOZ_GFX_DEBUG_FILE
"
)
)
{
auto
fd
=
open
(
debugFile
O_CREAT
|
O_WRONLY
|
O_TRUNC
S_IRUSR
|
S_IRGRP
|
S_IROTH
)
;
if
(
fd
!
=
-
1
)
{
mozilla
:
:
Unused
<
<
write
(
fd
glxtest_buf
glxtest_length
)
;
close
(
fd
)
;
}
}
}
#
ifdef
MOZ_X11
static
int
x_error_handler
(
Display
*
XErrorEvent
*
ev
)
{
record_value
(
"
ERROR
\
nX
error
error_code
=
%
d
"
"
request_code
=
%
d
minor_code
=
%
d
\
n
"
ev
-
>
error_code
ev
-
>
request_code
ev
-
>
minor_code
)
;
record_flush
(
)
;
_exit
(
EXIT_FAILURE
)
;
}
#
endif
extern
"
C
"
{
static
void
close_logging
(
)
{
int
fd
=
open
(
"
/
dev
/
null
"
O_WRONLY
)
;
for
(
int
i
=
1
;
i
<
fd
;
i
+
+
)
{
dup2
(
fd
i
)
;
}
close
(
fd
)
;
if
(
getenv
(
"
MOZ_AVOID_OPENGL_ALTOGETHER
"
)
)
{
const
char
*
msg
=
"
ERROR
\
nMOZ_AVOID_OPENGL_ALTOGETHER
envvar
set
"
;
mozilla
:
:
Unused
<
<
write
(
write_end_of_the_pipe
msg
strlen
(
msg
)
)
;
exit
(
EXIT_FAILURE
)
;
}
}
#
define
PCI_FILL_IDENT
0x0001
#
define
PCI_FILL_CLASS
0x0020
#
define
PCI_BASE_CLASS_DISPLAY
0x03
static
void
get_pci_status
(
)
{
if
(
access
(
"
/
sys
/
bus
/
pci
/
"
F_OK
)
!
=
0
&
&
access
(
"
/
sys
/
bus
/
pci_express
/
"
F_OK
)
!
=
0
)
{
record_warning
(
"
cannot
access
/
sys
/
bus
/
pci
"
)
;
return
;
}
void
*
libpci
=
dlopen
(
"
libpci
.
so
.
3
"
RTLD_LAZY
)
;
if
(
!
libpci
)
{
libpci
=
dlopen
(
"
libpci
.
so
"
RTLD_LAZY
)
;
}
if
(
!
libpci
)
{
record_warning
(
"
libpci
missing
"
)
;
return
;
}
typedef
struct
pci_dev
{
struct
pci_dev
*
next
;
uint16_t
domain_16
;
uint8_t
bus
dev
func
;
unsigned
int
known_fields
;
uint16_t
vendor_id
device_id
;
uint16_t
device_class
;
}
pci_dev
;
typedef
struct
pci_access
{
unsigned
int
method
;
int
writeable
;
int
buscentric
;
char
*
id_file_name
;
int
free_id_name
;
int
numeric_ids
;
unsigned
int
id_lookup_mode
;
int
debugging
;
void
*
error
;
void
*
warning
;
void
*
debug
;
pci_dev
*
devices
;
}
pci_access
;
typedef
pci_access
*
(
*
PCIALLOC
)
(
void
)
;
PCIALLOC
pci_alloc
=
cast
<
PCIALLOC
>
(
dlsym
(
libpci
"
pci_alloc
"
)
)
;
typedef
void
(
*
PCIINIT
)
(
pci_access
*
)
;
PCIINIT
pci_init
=
cast
<
PCIINIT
>
(
dlsym
(
libpci
"
pci_init
"
)
)
;
typedef
void
(
*
PCICLEANUP
)
(
pci_access
*
)
;
PCICLEANUP
pci_cleanup
=
cast
<
PCICLEANUP
>
(
dlsym
(
libpci
"
pci_cleanup
"
)
)
;
typedef
void
(
*
PCISCANBUS
)
(
pci_access
*
)
;
PCISCANBUS
pci_scan_bus
=
cast
<
PCISCANBUS
>
(
dlsym
(
libpci
"
pci_scan_bus
"
)
)
;
typedef
void
(
*
PCIFILLINFO
)
(
pci_dev
*
int
)
;
PCIFILLINFO
pci_fill_info
=
cast
<
PCIFILLINFO
>
(
dlsym
(
libpci
"
pci_fill_info
"
)
)
;
if
(
!
pci_alloc
|
|
!
pci_cleanup
|
|
!
pci_scan_bus
|
|
!
pci_fill_info
)
{
dlclose
(
libpci
)
;
record_warning
(
"
libpci
missing
methods
"
)
;
return
;
}
pci_access
*
pacc
=
pci_alloc
(
)
;
if
(
!
pacc
)
{
dlclose
(
libpci
)
;
record_warning
(
"
libpci
alloc
failed
"
)
;
return
;
}
pci_init
(
pacc
)
;
pci_scan_bus
(
pacc
)
;
for
(
pci_dev
*
dev
=
pacc
-
>
devices
;
dev
;
dev
=
dev
-
>
next
)
{
pci_fill_info
(
dev
PCI_FILL_IDENT
|
PCI_FILL_CLASS
)
;
if
(
dev
-
>
device_class
>
>
8
=
=
PCI_BASE_CLASS_DISPLAY
&
&
dev
-
>
vendor_id
&
&
dev
-
>
device_id
)
{
record_value
(
"
PCI_VENDOR_ID
\
n0x
%
04x
\
nPCI_DEVICE_ID
\
n0x
%
04x
\
n
"
dev
-
>
vendor_id
dev
-
>
device_id
)
;
}
}
pci_cleanup
(
pacc
)
;
dlclose
(
libpci
)
;
}
#
ifdef
MOZ_WAYLAND
static
void
set_render_device_path
(
const
char
*
render_device_path
)
{
record_value
(
"
DRM_RENDERDEVICE
\
n
%
s
\
n
"
render_device_path
)
;
glxtest_render_device_path
=
strdup
(
render_device_path
)
;
}
static
bool
device_has_name
(
const
drmDevice
*
device
const
char
*
name
)
{
for
(
size_t
i
=
0
;
i
<
DRM_NODE_MAX
;
i
+
+
)
{
if
(
!
(
device
-
>
available_nodes
&
(
1
<
<
i
)
)
)
{
continue
;
}
if
(
strcmp
(
device
-
>
nodes
[
i
]
name
)
=
=
0
)
{
return
true
;
}
}
return
false
;
}
static
bool
get_render_name
(
const
char
*
name
)
{
void
*
libdrm
=
dlopen
(
LIBDRM_FILENAME
RTLD_LAZY
)
;
if
(
!
libdrm
)
{
record_warning
(
"
Failed
to
open
libdrm
"
)
;
return
false
;
}
typedef
int
(
*
DRMGETDEVICES2
)
(
uint32_t
drmDevicePtr
*
int
)
;
DRMGETDEVICES2
drmGetDevices2
=
cast
<
DRMGETDEVICES2
>
(
dlsym
(
libdrm
"
drmGetDevices2
"
)
)
;
typedef
void
(
*
DRMFREEDEVICE
)
(
drmDevicePtr
*
)
;
DRMFREEDEVICE
drmFreeDevice
=
cast
<
DRMFREEDEVICE
>
(
dlsym
(
libdrm
"
drmFreeDevice
"
)
)
;
if
(
!
drmGetDevices2
|
|
!
drmFreeDevice
)
{
record_warning
(
"
libdrm
missing
methods
for
drmGetDevices2
or
drmFreeDevice
"
)
;
dlclose
(
libdrm
)
;
return
false
;
}
uint32_t
flags
=
0
;
int
devices_len
=
drmGetDevices2
(
flags
nullptr
0
)
;
if
(
devices_len
<
0
)
{
record_warning
(
"
drmGetDevices2
failed
"
)
;
dlclose
(
libdrm
)
;
return
false
;
}
drmDevice
*
*
devices
=
(
drmDevice
*
*
)
calloc
(
devices_len
sizeof
(
drmDevice
*
)
)
;
if
(
!
devices
)
{
record_warning
(
"
Allocation
error
"
)
;
dlclose
(
libdrm
)
;
return
false
;
}
devices_len
=
drmGetDevices2
(
flags
devices
devices_len
)
;
if
(
devices_len
<
0
)
{
free
(
devices
)
;
record_warning
(
"
drmGetDevices2
failed
"
)
;
dlclose
(
libdrm
)
;
return
false
;
}
const
drmDevice
*
match
=
nullptr
;
for
(
int
i
=
0
;
i
<
devices_len
;
i
+
+
)
{
if
(
device_has_name
(
devices
[
i
]
name
)
)
{
match
=
devices
[
i
]
;
break
;
}
}
if
(
match
&
&
!
(
match
-
>
available_nodes
&
(
1
<
<
DRM_NODE_RENDER
)
)
)
{
match
=
nullptr
;
for
(
int
i
=
0
;
i
<
devices_len
;
i
+
+
)
{
if
(
devices
[
i
]
-
>
available_nodes
&
(
1
<
<
DRM_NODE_RENDER
)
)
{
if
(
!
match
)
{
match
=
devices
[
i
]
;
}
else
{
match
=
nullptr
;
break
;
}
}
}
if
(
match
)
{
record_warning
(
"
DRM
render
node
not
clearly
detectable
.
Falling
back
to
using
the
"
"
only
one
that
was
found
.
"
)
;
}
else
{
record_warning
(
"
DRM
device
has
no
render
node
"
)
;
}
}
bool
result
=
false
;
if
(
!
match
)
{
record_warning
(
"
Cannot
find
DRM
device
"
)
;
}
else
{
set_render_device_path
(
match
-
>
nodes
[
DRM_NODE_RENDER
]
)
;
record_value
(
"
MESA_VENDOR_ID
\
n0x
%
04x
\
n
"
"
MESA_DEVICE_ID
\
n0x
%
04x
\
n
"
match
-
>
deviceinfo
.
pci
-
>
vendor_id
match
-
>
deviceinfo
.
pci
-
>
device_id
)
;
result
=
true
;
}
for
(
int
i
=
0
;
i
<
devices_len
;
i
+
+
)
{
drmFreeDevice
(
&
devices
[
i
]
)
;
}
free
(
devices
)
;
dlclose
(
libdrm
)
;
return
result
;
}
#
endif
static
bool
get_egl_gl_status
(
EGLDisplay
dpy
PFNEGLGETPROCADDRESS
eglGetProcAddress
)
{
typedef
EGLBoolean
(
*
PFNEGLCHOOSECONFIGPROC
)
(
EGLDisplay
dpy
EGLint
const
*
attrib_list
EGLConfig
*
configs
EGLint
config_size
EGLint
*
num_config
)
;
PFNEGLCHOOSECONFIGPROC
eglChooseConfig
=
cast
<
PFNEGLCHOOSECONFIGPROC
>
(
eglGetProcAddress
(
"
eglChooseConfig
"
)
)
;
typedef
EGLBoolean
(
*
PFNEGLBINDAPIPROC
)
(
EGLint
api
)
;
PFNEGLBINDAPIPROC
eglBindAPI
=
cast
<
PFNEGLBINDAPIPROC
>
(
eglGetProcAddress
(
"
eglBindAPI
"
)
)
;
typedef
EGLContext
(
*
PFNEGLCREATECONTEXTPROC
)
(
EGLDisplay
dpy
EGLConfig
config
EGLContext
share_context
EGLint
const
*
attrib_list
)
;
PFNEGLCREATECONTEXTPROC
eglCreateContext
=
cast
<
PFNEGLCREATECONTEXTPROC
>
(
eglGetProcAddress
(
"
eglCreateContext
"
)
)
;
typedef
EGLBoolean
(
*
PFNEGLMAKECURRENTPROC
)
(
EGLDisplay
dpy
EGLSurface
draw
EGLSurface
read
EGLContext
context
)
;
PFNEGLMAKECURRENTPROC
eglMakeCurrent
=
cast
<
PFNEGLMAKECURRENTPROC
>
(
eglGetProcAddress
(
"
eglMakeCurrent
"
)
)
;
typedef
const
char
*
(
*
PFNEGLQUERYDEVICESTRINGEXTPROC
)
(
EGLDeviceEXT
device
EGLint
name
)
;
PFNEGLQUERYDEVICESTRINGEXTPROC
eglQueryDeviceStringEXT
=
cast
<
PFNEGLQUERYDEVICESTRINGEXTPROC
>
(
eglGetProcAddress
(
"
eglQueryDeviceStringEXT
"
)
)
;
typedef
EGLBoolean
(
*
PFNEGLQUERYDISPLAYATTRIBEXTPROC
)
(
EGLDisplay
dpy
EGLint
name
EGLAttrib
*
value
)
;
PFNEGLQUERYDISPLAYATTRIBEXTPROC
eglQueryDisplayAttribEXT
=
cast
<
PFNEGLQUERYDISPLAYATTRIBEXTPROC
>
(
eglGetProcAddress
(
"
eglQueryDisplayAttribEXT
"
)
)
;
if
(
!
eglChooseConfig
|
|
!
eglCreateContext
|
|
!
eglMakeCurrent
|
|
!
eglQueryDeviceStringEXT
)
{
record_warning
(
"
libEGL
missing
methods
for
GL
test
"
)
;
return
false
;
}
typedef
GLubyte
*
(
*
PFNGLGETSTRING
)
(
GLenum
)
;
PFNGLGETSTRING
glGetString
=
cast
<
PFNGLGETSTRING
>
(
eglGetProcAddress
(
"
glGetString
"
)
)
;
#
if
defined
(
__arm__
)
|
|
defined
(
__aarch64__
)
bool
useGles
=
true
;
#
else
bool
useGles
=
false
;
#
endif
std
:
:
vector
<
EGLint
>
attribs
;
attribs
.
push_back
(
EGL_RED_SIZE
)
;
attribs
.
push_back
(
8
)
;
attribs
.
push_back
(
EGL_GREEN_SIZE
)
;
attribs
.
push_back
(
8
)
;
attribs
.
push_back
(
EGL_BLUE_SIZE
)
;
attribs
.
push_back
(
8
)
;
if
(
useGles
)
{
attribs
.
push_back
(
EGL_RENDERABLE_TYPE
)
;
attribs
.
push_back
(
EGL_OPENGL_ES2_BIT
)
;
}
attribs
.
push_back
(
EGL_NONE
)
;
EGLConfig
config
;
EGLint
num_config
;
if
(
eglChooseConfig
(
dpy
attribs
.
data
(
)
&
config
1
&
num_config
)
=
=
EGL_FALSE
)
{
record_warning
(
"
eglChooseConfig
returned
an
error
"
)
;
return
false
;
}
EGLenum
api
=
useGles
?
EGL_OPENGL_ES_API
:
EGL_OPENGL_API
;
if
(
eglBindAPI
(
api
)
=
=
EGL_FALSE
)
{
record_warning
(
"
eglBindAPI
returned
an
error
"
)
;
return
false
;
}
EGLint
ctx_attrs
[
]
=
{
EGL_CONTEXT_MAJOR_VERSION
3
EGL_NONE
}
;
EGLContext
ectx
=
eglCreateContext
(
dpy
config
EGL_NO_CONTEXT
ctx_attrs
)
;
if
(
!
ectx
)
{
EGLint
ctx_attrs_fallback
[
]
=
{
EGL_CONTEXT_MAJOR_VERSION
2
EGL_NONE
}
;
ectx
=
eglCreateContext
(
dpy
config
EGL_NO_CONTEXT
ctx_attrs_fallback
)
;
if
(
!
ectx
)
{
record_warning
(
"
eglCreateContext
returned
an
error
"
)
;
return
false
;
}
}
if
(
eglMakeCurrent
(
dpy
EGL_NO_SURFACE
EGL_NO_SURFACE
ectx
)
=
=
EGL_FALSE
)
{
record_warning
(
"
eglMakeCurrent
returned
an
error
"
)
;
return
false
;
}
void
*
libgl
=
nullptr
;
if
(
!
glGetString
)
{
libgl
=
dlopen
(
LIBGL_FILENAME
RTLD_LAZY
)
;
if
(
!
libgl
)
{
libgl
=
dlopen
(
LIBGLES_FILENAME
RTLD_LAZY
)
;
if
(
!
libgl
)
{
record_warning
(
LIBGL_FILENAME
"
and
"
LIBGLES_FILENAME
"
missing
"
)
;
return
false
;
}
}
glGetString
=
cast
<
PFNGLGETSTRING
>
(
dlsym
(
libgl
"
glGetString
"
)
)
;
if
(
!
glGetString
)
{
dlclose
(
libgl
)
;
record_warning
(
"
libEGL
libGL
and
libGLESv2
are
missing
glGetString
"
)
;
return
false
;
}
}
const
GLubyte
*
versionString
=
glGetString
(
GL_VERSION
)
;
const
GLubyte
*
vendorString
=
glGetString
(
GL_VENDOR
)
;
const
GLubyte
*
rendererString
=
glGetString
(
GL_RENDERER
)
;
if
(
versionString
&
&
vendorString
&
&
rendererString
)
{
record_value
(
"
VENDOR
\
n
%
s
\
nRENDERER
\
n
%
s
\
nVERSION
\
n
%
s
\
nTFP
\
nTRUE
\
n
"
vendorString
rendererString
versionString
)
;
}
else
{
record_warning
(
"
EGL
glGetString
returned
null
"
)
;
if
(
libgl
)
{
dlclose
(
libgl
)
;
}
return
false
;
}
EGLDeviceEXT
device
;
if
(
eglQueryDisplayAttribEXT
(
dpy
EGL_DEVICE_EXT
(
EGLAttrib
*
)
&
device
)
=
=
EGL_TRUE
)
{
const
char
*
deviceExtensions
=
eglQueryDeviceStringEXT
(
device
EGL_EXTENSIONS
)
;
if
(
deviceExtensions
&
&
strstr
(
deviceExtensions
"
EGL_MESA_device_software
"
)
)
{
record_value
(
"
MESA_ACCELERATED
\
nFALSE
\
n
"
)
;
}
else
{
#
ifdef
MOZ_WAYLAND
const
char
*
deviceString
=
eglQueryDeviceStringEXT
(
device
EGL_DRM_DEVICE_FILE_EXT
)
;
if
(
!
deviceString
|
|
!
get_render_name
(
deviceString
)
)
{
const
char
*
renderNodeString
=
eglQueryDeviceStringEXT
(
device
EGL_DRM_RENDER_NODE_FILE_EXT
)
;
if
(
renderNodeString
)
{
set_render_device_path
(
renderNodeString
)
;
}
}
#
endif
}
}
if
(
libgl
)
{
dlclose
(
libgl
)
;
}
return
true
;
}
static
bool
get_egl_status
(
EGLNativeDisplayType
native_dpy
)
{
void
*
libegl
=
dlopen
(
LIBEGL_FILENAME
RTLD_LAZY
)
;
if
(
!
libegl
)
{
record_warning
(
"
libEGL
missing
"
)
;
return
false
;
}
PFNEGLGETPROCADDRESS
eglGetProcAddress
=
cast
<
PFNEGLGETPROCADDRESS
>
(
dlsym
(
libegl
"
eglGetProcAddress
"
)
)
;
if
(
!
eglGetProcAddress
)
{
dlclose
(
libegl
)
;
record_warning
(
"
no
eglGetProcAddress
"
)
;
return
false
;
}
typedef
EGLDisplay
(
*
PFNEGLGETDISPLAYPROC
)
(
void
*
native_display
)
;
PFNEGLGETDISPLAYPROC
eglGetDisplay
=
cast
<
PFNEGLGETDISPLAYPROC
>
(
eglGetProcAddress
(
"
eglGetDisplay
"
)
)
;
typedef
EGLBoolean
(
*
PFNEGLINITIALIZEPROC
)
(
EGLDisplay
dpy
EGLint
*
major
EGLint
*
minor
)
;
PFNEGLINITIALIZEPROC
eglInitialize
=
cast
<
PFNEGLINITIALIZEPROC
>
(
eglGetProcAddress
(
"
eglInitialize
"
)
)
;
typedef
EGLBoolean
(
*
PFNEGLTERMINATEPROC
)
(
EGLDisplay
dpy
)
;
PFNEGLTERMINATEPROC
eglTerminate
=
cast
<
PFNEGLTERMINATEPROC
>
(
eglGetProcAddress
(
"
eglTerminate
"
)
)
;
if
(
!
eglGetDisplay
|
|
!
eglInitialize
|
|
!
eglTerminate
)
{
dlclose
(
libegl
)
;
record_warning
(
"
libEGL
missing
methods
"
)
;
return
false
;
}
EGLDisplay
dpy
=
eglGetDisplay
(
native_dpy
)
;
if
(
!
dpy
)
{
dlclose
(
libegl
)
;
record_warning
(
"
libEGL
no
display
"
)
;
return
false
;
}
EGLint
major
minor
;
if
(
!
eglInitialize
(
dpy
&
major
&
minor
)
)
{
dlclose
(
libegl
)
;
record_warning
(
"
libEGL
initialize
failed
"
)
;
return
false
;
}
typedef
const
char
*
(
*
PFNEGLGETDISPLAYDRIVERNAMEPROC
)
(
EGLDisplay
dpy
)
;
PFNEGLGETDISPLAYDRIVERNAMEPROC
eglGetDisplayDriverName
=
cast
<
PFNEGLGETDISPLAYDRIVERNAMEPROC
>
(
eglGetProcAddress
(
"
eglGetDisplayDriverName
"
)
)
;
if
(
eglGetDisplayDriverName
)
{
const
char
*
driDriver
=
eglGetDisplayDriverName
(
dpy
)
;
if
(
driDriver
)
{
record_value
(
"
DRI_DRIVER
\
n
%
s
\
n
"
driDriver
)
;
}
}
if
(
!
get_egl_gl_status
(
dpy
eglGetProcAddress
)
)
{
eglTerminate
(
dpy
)
;
dlclose
(
libegl
)
;
return
false
;
}
eglTerminate
(
dpy
)
;
dlclose
(
libegl
)
;
return
true
;
}
#
ifdef
MOZ_X11
static
void
get_xrandr_info
(
Display
*
dpy
)
{
int
eventBase
errorBase
major
minor
;
if
(
!
XRRQueryExtension
(
dpy
&
eventBase
&
errorBase
)
|
|
!
XRRQueryVersion
(
dpy
&
major
&
minor
)
|
|
!
(
major
>
1
|
|
(
major
=
=
1
&
&
minor
>
=
4
)
)
)
{
return
;
}
Window
root
=
RootWindow
(
dpy
DefaultScreen
(
dpy
)
)
;
XRRProviderResources
*
pr
=
XRRGetProviderResources
(
dpy
root
)
;
XRRScreenResources
*
res
=
XRRGetScreenResourcesCurrent
(
dpy
root
)
;
if
(
pr
-
>
nproviders
!
=
0
)
{
record_value
(
"
DDX_DRIVER
\
n
"
)
;
for
(
int
i
=
0
;
i
<
pr
-
>
nproviders
;
i
+
+
)
{
XRRProviderInfo
*
info
=
XRRGetProviderInfo
(
dpy
res
pr
-
>
providers
[
i
]
)
;
record_value
(
"
%
s
%
s
"
info
-
>
name
i
=
=
pr
-
>
nproviders
-
1
?
"
;
\
n
"
:
"
;
"
)
;
}
}
}
static
void
glxtest
(
)
{
void
*
libgl
=
dlopen
(
LIBGL_FILENAME
RTLD_LAZY
)
;
if
(
!
libgl
)
{
record_error
(
LIBGL_FILENAME
"
missing
"
)
;
return
;
}
typedef
void
*
(
*
PFNGLXGETPROCADDRESS
)
(
const
char
*
)
;
PFNGLXGETPROCADDRESS
glXGetProcAddress
=
cast
<
PFNGLXGETPROCADDRESS
>
(
dlsym
(
libgl
"
glXGetProcAddress
"
)
)
;
if
(
!
glXGetProcAddress
)
{
record_error
(
"
no
glXGetProcAddress
"
)
;
return
;
}
typedef
GLXFBConfig
*
(
*
PFNGLXQUERYEXTENSION
)
(
Display
*
int
*
int
*
)
;
PFNGLXQUERYEXTENSION
glXQueryExtension
=
cast
<
PFNGLXQUERYEXTENSION
>
(
glXGetProcAddress
(
"
glXQueryExtension
"
)
)
;
typedef
GLXFBConfig
*
(
*
PFNGLXQUERYVERSION
)
(
Display
*
int
*
int
*
)
;
PFNGLXQUERYVERSION
glXQueryVersion
=
cast
<
PFNGLXQUERYVERSION
>
(
dlsym
(
libgl
"
glXQueryVersion
"
)
)
;
typedef
XVisualInfo
*
(
*
PFNGLXCHOOSEVISUAL
)
(
Display
*
int
int
*
)
;
PFNGLXCHOOSEVISUAL
glXChooseVisual
=
cast
<
PFNGLXCHOOSEVISUAL
>
(
glXGetProcAddress
(
"
glXChooseVisual
"
)
)
;
typedef
GLXContext
(
*
PFNGLXCREATECONTEXT
)
(
Display
*
XVisualInfo
*
GLXContext
Bool
)
;
PFNGLXCREATECONTEXT
glXCreateContext
=
cast
<
PFNGLXCREATECONTEXT
>
(
glXGetProcAddress
(
"
glXCreateContext
"
)
)
;
typedef
Bool
(
*
PFNGLXMAKECURRENT
)
(
Display
*
GLXDrawable
GLXContext
)
;
PFNGLXMAKECURRENT
glXMakeCurrent
=
cast
<
PFNGLXMAKECURRENT
>
(
glXGetProcAddress
(
"
glXMakeCurrent
"
)
)
;
typedef
void
(
*
PFNGLXDESTROYCONTEXT
)
(
Display
*
GLXContext
)
;
PFNGLXDESTROYCONTEXT
glXDestroyContext
=
cast
<
PFNGLXDESTROYCONTEXT
>
(
glXGetProcAddress
(
"
glXDestroyContext
"
)
)
;
typedef
GLubyte
*
(
*
PFNGLGETSTRING
)
(
GLenum
)
;
PFNGLGETSTRING
glGetString
=
cast
<
PFNGLGETSTRING
>
(
glXGetProcAddress
(
"
glGetString
"
)
)
;
if
(
!
glXQueryExtension
|
|
!
glXQueryVersion
|
|
!
glXChooseVisual
|
|
!
glXCreateContext
|
|
!
glXMakeCurrent
|
|
!
glXDestroyContext
|
|
!
glGetString
)
{
record_error
(
LIBGL_FILENAME
"
missing
methods
"
)
;
return
;
}
Display
*
dpy
=
XOpenDisplay
(
nullptr
)
;
if
(
!
dpy
)
{
record_error
(
"
Unable
to
open
a
connection
to
the
X
server
"
)
;
return
;
}
if
(
!
glXQueryExtension
(
dpy
nullptr
nullptr
)
)
{
record_error
(
"
GLX
extension
missing
"
)
;
return
;
}
XSetErrorHandler
(
x_error_handler
)
;
int
attribs
[
]
=
{
GLX_RGBA
GLX_RED_SIZE
1
GLX_GREEN_SIZE
1
GLX_BLUE_SIZE
1
None
}
;
XVisualInfo
*
vInfo
=
glXChooseVisual
(
dpy
DefaultScreen
(
dpy
)
attribs
)
;
if
(
!
vInfo
)
{
int
attribs2
[
]
=
{
GLX_RGBA
GLX_RED_SIZE
1
GLX_GREEN_SIZE
1
GLX_BLUE_SIZE
1
GLX_DOUBLEBUFFER
None
}
;
vInfo
=
glXChooseVisual
(
dpy
DefaultScreen
(
dpy
)
attribs2
)
;
if
(
!
vInfo
)
{
record_error
(
"
No
visuals
found
"
)
;
return
;
}
}
Window
window
;
XSetWindowAttributes
swa
;
swa
.
colormap
=
XCreateColormap
(
dpy
RootWindow
(
dpy
vInfo
-
>
screen
)
vInfo
-
>
visual
AllocNone
)
;
swa
.
border_pixel
=
0
;
window
=
XCreateWindow
(
dpy
RootWindow
(
dpy
vInfo
-
>
screen
)
0
0
16
16
0
vInfo
-
>
depth
InputOutput
vInfo
-
>
visual
CWBorderPixel
|
CWColormap
&
swa
)
;
GLXContext
context
=
glXCreateContext
(
dpy
vInfo
nullptr
True
)
;
glXMakeCurrent
(
dpy
window
context
)
;
void
*
glXBindTexImageEXT
=
glXGetProcAddress
(
"
glXBindTexImageEXT
"
)
;
const
GLubyte
*
versionString
=
glGetString
(
GL_VERSION
)
;
const
GLubyte
*
vendorString
=
glGetString
(
GL_VENDOR
)
;
const
GLubyte
*
rendererString
=
glGetString
(
GL_RENDERER
)
;
if
(
versionString
&
&
vendorString
&
&
rendererString
)
{
record_value
(
"
VENDOR
\
n
%
s
\
nRENDERER
\
n
%
s
\
nVERSION
\
n
%
s
\
nTFP
\
n
%
s
\
n
"
vendorString
rendererString
versionString
glXBindTexImageEXT
?
"
TRUE
"
:
"
FALSE
"
)
;
}
else
{
record_error
(
"
glGetString
returned
null
"
)
;
}
typedef
Bool
(
*
PFNGLXQUERYCURRENTRENDERERINTEGERMESAPROC
)
(
int
attribute
unsigned
int
*
value
)
;
PFNGLXQUERYCURRENTRENDERERINTEGERMESAPROC
glXQueryCurrentRendererIntegerMESAProc
=
cast
<
PFNGLXQUERYCURRENTRENDERERINTEGERMESAPROC
>
(
glXGetProcAddress
(
"
glXQueryCurrentRendererIntegerMESA
"
)
)
;
if
(
glXQueryCurrentRendererIntegerMESAProc
)
{
unsigned
int
vendorId
deviceId
accelerated
videoMemoryMB
;
glXQueryCurrentRendererIntegerMESAProc
(
GLX_RENDERER_VENDOR_ID_MESA
&
vendorId
)
;
glXQueryCurrentRendererIntegerMESAProc
(
GLX_RENDERER_DEVICE_ID_MESA
&
deviceId
)
;
glXQueryCurrentRendererIntegerMESAProc
(
GLX_RENDERER_ACCELERATED_MESA
&
accelerated
)
;
glXQueryCurrentRendererIntegerMESAProc
(
GLX_RENDERER_VIDEO_MEMORY_MESA
&
videoMemoryMB
)
;
vendorId
&
=
0xFFFF
;
deviceId
&
=
0xFFFF
;
record_value
(
"
MESA_VENDOR_ID
\
n0x
%
04x
\
n
"
"
MESA_DEVICE_ID
\
n0x
%
04x
\
n
"
"
MESA_ACCELERATED
\
n
%
s
\
n
"
"
MESA_VRAM
\
n
%
dMB
\
n
"
vendorId
deviceId
accelerated
?
"
TRUE
"
:
"
FALSE
"
videoMemoryMB
)
;
}
typedef
const
char
*
(
*
PFNGLXGETSCREENDRIVERPROC
)
(
Display
*
dpy
int
scrNum
)
;
PFNGLXGETSCREENDRIVERPROC
glXGetScreenDriverProc
=
cast
<
PFNGLXGETSCREENDRIVERPROC
>
(
glXGetProcAddress
(
"
glXGetScreenDriver
"
)
)
;
if
(
glXGetScreenDriverProc
)
{
const
char
*
driDriver
=
glXGetScreenDriverProc
(
dpy
DefaultScreen
(
dpy
)
)
;
if
(
driDriver
)
{
record_value
(
"
DRI_DRIVER
\
n
%
s
\
n
"
driDriver
)
;
}
}
get_xrandr_info
(
dpy
)
;
glXMakeCurrent
(
dpy
None
nullptr
)
;
glXDestroyContext
(
dpy
context
)
;
XDestroyWindow
(
dpy
window
)
;
XFreeColormap
(
dpy
swa
.
colormap
)
;
#
ifdef
NS_FREE_PERMANENT_DATA
XCloseDisplay
(
dpy
)
;
#
else
XSync
(
dpy
False
)
;
#
endif
dlclose
(
libgl
)
;
record_value
(
"
TEST_TYPE
\
nGLX
\
n
"
)
;
}
static
bool
x11_egltest
(
)
{
Display
*
dpy
=
XOpenDisplay
(
nullptr
)
;
if
(
!
dpy
)
{
return
false
;
}
XSetErrorHandler
(
x_error_handler
)
;
if
(
!
get_egl_status
(
dpy
)
)
{
return
false
;
}
int
screenCount
=
ScreenCount
(
dpy
)
;
for
(
int
idx
=
0
;
idx
<
screenCount
;
idx
+
+
)
{
if
(
DefaultDepth
(
dpy
idx
)
!
=
24
)
{
return
false
;
}
}
get_xrandr_info
(
dpy
)
;
record_value
(
"
TEST_TYPE
\
nEGL
\
n
"
)
;
return
true
;
}
#
endif
#
ifdef
MOZ_WAYLAND
static
void
wayland_egltest
(
)
{
struct
wl_display
*
dpy
=
wl_display_connect
(
nullptr
)
;
if
(
!
dpy
)
{
record_error
(
"
Could
not
connect
to
wayland
socket
"
)
;
return
;
}
if
(
!
get_egl_status
(
(
EGLNativeDisplayType
)
dpy
)
)
{
record_error
(
"
EGL
test
failed
"
)
;
}
wl_display_roundtrip
(
dpy
)
;
wl_display_disconnect
(
dpy
)
;
record_value
(
"
TEST_TYPE
\
nEGL
\
n
"
)
;
}
#
endif
int
childgltest
(
)
{
enum
{
bufsize
=
2048
}
;
char
buf
[
bufsize
]
;
glxtest_buf
=
buf
;
glxtest_bufsize
=
bufsize
;
get_pci_status
(
)
;
#
ifdef
MOZ_WAYLAND
if
(
IsWaylandEnabled
(
)
)
{
wayland_egltest
(
)
;
}
else
#
endif
{
#
ifdef
MOZ_X11
if
(
!
x11_egltest
(
)
)
{
glxtest
(
)
;
}
#
endif
}
record_flush
(
)
;
if
(
glxtest_length
>
=
glxtest_bufsize
)
{
return
EXIT_FAILURE_BUFFER_TOO_SMALL
;
}
return
EXIT_SUCCESS
;
}
}
bool
fire_glxtest_process
(
)
{
int
pfd
[
2
]
;
if
(
pipe
(
pfd
)
=
=
-
1
)
{
perror
(
"
pipe
"
)
;
return
false
;
}
pid_t
pid
=
fork
(
)
;
if
(
pid
<
0
)
{
perror
(
"
fork
"
)
;
close
(
pfd
[
0
]
)
;
close
(
pfd
[
1
]
)
;
return
false
;
}
if
(
pid
=
=
0
)
{
close
(
pfd
[
0
]
)
;
write_end_of_the_pipe
=
pfd
[
1
]
;
close_logging
(
)
;
if
(
CrashReporter
:
:
GetEnabled
(
)
)
{
CrashReporter
:
:
UnsetExceptionHandler
(
)
;
}
#
if
defined
(
MOZ_ASAN
)
|
|
defined
(
FUZZING
)
signal
(
SIGSEGV
SIG_DFL
)
;
#
endif
int
rv
=
childgltest
(
)
;
close
(
pfd
[
1
]
)
;
_exit
(
rv
)
;
}
close
(
pfd
[
1
]
)
;
mozilla
:
:
widget
:
:
glxtest_pipe
=
pfd
[
0
]
;
mozilla
:
:
widget
:
:
glxtest_pid
=
pid
;
return
false
;
}
