#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozmemory
.
h
"
#
include
<
stdlib
.
h
>
#
if
defined
(
MOZ_WIDGET_GTK
)
#
include
<
glib
.
h
>
#
endif
#
include
"
prenv
.
h
"
#
include
"
nsIAppShell
.
h
"
#
include
"
nsAppStartupNotifier
.
h
"
#
include
"
nsIToolkitProfile
.
h
"
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
include
<
shobjidl
.
h
>
#
include
"
mozilla
/
ipc
/
WindowsMessageLoop
.
h
"
#
ifdef
MOZ_SANDBOX
#
include
"
mozilla
/
RandomNum
.
h
"
#
endif
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
WinDllServices
.
h
"
#
include
"
WinUtils
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
mozilla
/
GeckoArgs
.
h
"
#
include
"
mozilla
/
mscom
/
ActCtxResource
.
h
"
#
endif
#
endif
#
include
"
nsAppRunner
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
mozilla
/
RuntimeExceptionModule
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsXREDirProvider
.
h
"
#
ifdef
MOZ_ASAN_REPORTER
#
include
"
CmdLineAndEnvUtils
.
h
"
#
include
"
nsIFile
.
h
"
#
endif
#
include
"
mozilla
/
Omnijar
.
h
"
#
if
defined
(
XP_MACOSX
)
#
include
<
mach
/
mach
.
h
>
#
include
<
servers
/
bootstrap
.
h
>
#
include
"
nsVersionComparator
.
h
"
#
include
"
chrome
/
common
/
mach_ipc_mac
.
h
"
#
include
"
gfxPlatformMac
.
h
"
#
endif
#
include
"
nsX11ErrorHandler
.
h
"
#
include
"
nsGDKErrorHandler
.
h
"
#
include
"
base
/
at_exit
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
process_util
.
h
"
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
chrome
/
common
/
ipc_channel
.
h
"
#
include
"
mozilla
/
jni
/
Utils
.
h
"
#
include
"
mozilla
/
ipc
/
ProcessUtils
.
h
"
#
endif
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
FilePreferences
.
h
"
#
include
"
mozilla
/
IOInterposer
.
h
"
#
include
"
mozilla
/
ProcessType
.
h
"
#
include
"
mozilla
/
RDDProcessImpl
.
h
"
#
include
"
mozilla
/
ipc
/
UtilityProcessImpl
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
ipc
/
BrowserProcessSubThread
.
h
"
#
include
"
mozilla
/
ipc
/
IOThreadChild
.
h
"
#
include
"
mozilla
/
ipc
/
ProcessChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentProcess
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
ipc
/
TestShellParent
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
WindowsConsole
.
h
"
#
include
"
mozilla
/
WindowsDllBlocklist
.
h
"
#
endif
#
include
"
GMPProcessChild
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessImpl
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessImpl
.
h
"
#
include
"
ProfilerControl
.
h
"
#
if
defined
(
MOZ_SANDBOX
)
&
&
defined
(
XP_WIN
)
#
include
"
mozilla
/
sandboxTarget
.
h
"
#
include
"
mozilla
/
sandboxing
/
loggingCallbacks
.
h
"
#
include
"
mozilla
/
RemoteSandboxBrokerProcessChild
.
h
"
#
endif
#
if
defined
(
MOZ_SANDBOX
)
#
include
"
XREChildData
.
h
"
#
include
"
mozilla
/
SandboxSettings
.
h
"
#
endif
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
Sandbox
.
h
"
#
endif
#
if
defined
(
XP_LINUX
)
#
include
<
sys
/
prctl
.
h
>
#
ifndef
PR_SET_PTRACER
#
define
PR_SET_PTRACER
0x59616d61
#
endif
#
ifndef
PR_SET_PTRACER_ANY
#
define
PR_SET_PTRACER_ANY
(
(
unsigned
long
)
-
1
)
#
endif
#
endif
#
ifdef
MOZ_JPROF
#
include
"
jprof
.
h
"
#
endif
#
if
defined
(
XP_WIN
)
&
&
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
sandboxing
/
SandboxInitialization
.
h
"
#
include
"
mozilla
/
sandboxing
/
sandboxLogging
.
h
"
#
endif
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
#
include
"
mozilla
/
ipc
/
ForkServer
.
h
"
#
endif
#
if
defined
(
MOZ_X11
)
#
include
<
X11
/
Xlib
.
h
>
#
endif
#
include
"
VRProcessChild
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
ipc
:
:
BrowserProcessSubThread
;
using
mozilla
:
:
ipc
:
:
GeckoChildProcessHost
;
using
mozilla
:
:
ipc
:
:
IOThreadChild
;
using
mozilla
:
:
ipc
:
:
ProcessChild
;
using
mozilla
:
:
ipc
:
:
ScopedXREEmbed
;
using
mozilla
:
:
dom
:
:
ContentParent
;
using
mozilla
:
:
dom
:
:
ContentProcess
;
using
mozilla
:
:
gmp
:
:
GMPProcessChild
;
using
mozilla
:
:
ipc
:
:
TestShellCommandParent
;
using
mozilla
:
:
ipc
:
:
TestShellParent
;
using
mozilla
:
:
startup
:
:
sChildProcessType
;
namespace
mozilla
:
:
_ipdltest
{
UniquePtr
<
mozilla
:
:
ipc
:
:
ProcessChild
>
(
*
gMakeIPDLUnitTestProcessChild
)
(
base
:
:
ProcessId
const
nsID
&
)
=
nullptr
;
}
static
NS_DEFINE_CID
(
kAppShellCID
NS_APPSHELL_CID
)
;
nsresult
XRE_LockProfileDirectory
(
nsIFile
*
aDirectory
nsISupports
*
*
aLockObject
)
{
nsCOMPtr
<
nsIProfileLock
>
lock
;
nsresult
rv
=
NS_LockProfilePath
(
aDirectory
nullptr
nullptr
getter_AddRefs
(
lock
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
NS_ADDREF
(
*
aLockObject
=
lock
)
;
return
rv
;
}
static
int32_t
sInitCounter
;
nsresult
XRE_InitEmbedding2
(
nsIFile
*
aLibXULDirectory
nsIFile
*
aAppDirectory
nsIDirectoryServiceProvider
*
aAppDirProvider
)
{
static
char
*
kNullCommandLine
[
]
=
{
nullptr
}
;
gArgv
=
kNullCommandLine
;
gArgc
=
0
;
NS_ENSURE_ARG
(
aLibXULDirectory
)
;
if
(
+
+
sInitCounter
>
1
)
return
NS_OK
;
if
(
!
aAppDirectory
)
aAppDirectory
=
aLibXULDirectory
;
nsresult
rv
;
new
nsXREDirProvider
;
if
(
!
gDirServiceProvider
)
return
NS_ERROR_OUT_OF_MEMORY
;
rv
=
gDirServiceProvider
-
>
Initialize
(
aAppDirectory
aLibXULDirectory
aAppDirProvider
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
NS_InitXPCOM
(
nullptr
aAppDirectory
gDirServiceProvider
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsAppStartupNotifier
:
:
NotifyObservers
(
APPSTARTUP_CATEGORY
)
;
return
NS_OK
;
}
void
XRE_NotifyProfile
(
)
{
NS_ASSERTION
(
gDirServiceProvider
"
XRE_InitEmbedding
was
not
called
!
"
)
;
gDirServiceProvider
-
>
DoStartup
(
)
;
}
void
XRE_TermEmbedding
(
)
{
if
(
-
-
sInitCounter
!
=
0
)
return
;
NS_ASSERTION
(
gDirServiceProvider
"
XRE_TermEmbedding
without
XRE_InitEmbedding
"
)
;
gDirServiceProvider
-
>
DoShutdown
(
)
;
NS_ShutdownXPCOM
(
nullptr
)
;
delete
gDirServiceProvider
;
}
const
char
*
XRE_GeckoProcessTypeToString
(
GeckoProcessType
aProcessType
)
{
switch
(
aProcessType
)
{
#
define
GECKO_PROCESS_TYPE
(
enum_value
enum_name
string_name
proc_typename
\
process_bin_type
procinfo_typename
\
webidl_typename
allcaps_name
)
\
case
GeckoProcessType
:
:
GeckoProcessType_
#
#
enum_name
:
\
return
string_name
;
#
include
"
mozilla
/
GeckoProcessTypes
.
h
"
#
undef
GECKO_PROCESS_TYPE
default
:
return
"
invalid
"
;
}
}
const
char
*
XRE_ChildProcessTypeToAnnotation
(
GeckoProcessType
aProcessType
)
{
switch
(
aProcessType
)
{
case
GeckoProcessType_GMPlugin
:
return
"
plugin
"
;
case
GeckoProcessType_Default
:
return
"
"
;
case
GeckoProcessType_Content
:
return
"
content
"
;
default
:
return
XRE_GeckoProcessTypeToString
(
aProcessType
)
;
}
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
void
XRE_SetAndroidChildFds
(
JNIEnv
*
env
const
XRE_AndroidChildFds
&
fds
)
{
mozilla
:
:
jni
:
:
SetGeckoThreadEnv
(
env
)
;
mozilla
:
:
ipc
:
:
SetPrefsFd
(
fds
.
mPrefsFd
)
;
mozilla
:
:
ipc
:
:
SetPrefMapFd
(
fds
.
mPrefMapFd
)
;
IPC
:
:
Channel
:
:
SetClientChannelFd
(
fds
.
mIpcFd
)
;
CrashReporter
:
:
SetNotificationPipeForChild
(
fds
.
mCrashFd
)
;
CrashReporter
:
:
SetCrashAnnotationPipeForChild
(
fds
.
mCrashAnnotationFd
)
;
}
#
endif
void
XRE_SetProcessType
(
const
char
*
aProcessTypeString
)
{
SetGeckoProcessType
(
aProcessTypeString
)
;
#
ifdef
MOZ_MEMORY
mozjemalloc_experiment_set_always_stall
(
sChildProcessType
=
=
GeckoProcessType_Default
)
;
#
endif
}
#
if
defined
(
XP_WIN
)
void
SetTaskbarGroupId
(
const
nsString
&
aId
)
{
if
(
FAILED
(
SetCurrentProcessExplicitAppUserModelID
(
aId
.
get
(
)
)
)
)
{
NS_WARNING
(
"
SetCurrentProcessExplicitAppUserModelID
failed
for
child
process
.
"
)
;
}
}
#
endif
#
if
defined
(
MOZ_SANDBOX
)
void
AddContentSandboxLevelAnnotation
(
)
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Content
)
{
int
level
=
GetEffectiveContentSandboxLevel
(
)
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
ContentSandboxLevel
level
)
;
}
}
#
endif
namespace
{
int
GetDebugChildPauseTime
(
)
{
auto
pauseStr
=
PR_GetEnv
(
"
MOZ_DEBUG_CHILD_PAUSE
"
)
;
if
(
pauseStr
&
&
*
pauseStr
)
{
int
pause
=
atoi
(
pauseStr
)
;
if
(
pause
!
=
1
)
{
#
if
defined
(
OS_WIN
)
pause
*
=
1000
;
#
endif
return
pause
;
}
}
#
ifdef
OS_POSIX
return
30
;
#
elif
defined
(
OS_WIN
)
return
10000
;
#
else
return
0
;
#
endif
}
static
bool
IsCrashReporterEnabled
(
const
char
*
aArg
)
{
#
if
defined
(
XP_MACOSX
)
|
|
defined
(
XP_WIN
)
return
0
!
=
strcmp
(
"
-
"
aArg
)
;
#
else
return
0
!
=
strcmp
(
"
false
"
aArg
)
;
#
endif
}
}
nsresult
XRE_InitChildProcess
(
int
aArgc
char
*
aArgv
[
]
const
XREChildData
*
aChildData
)
{
NS_ENSURE_ARG_MIN
(
aArgc
2
)
;
NS_ENSURE_ARG_POINTER
(
aArgv
)
;
NS_ENSURE_ARG_POINTER
(
aArgv
[
0
]
)
;
MOZ_ASSERT
(
aChildData
)
;
NS_SetCurrentThreadName
(
"
MainThread
"
)
;
#
ifdef
MOZ_ASAN_REPORTER
if
(
!
PR_GetEnv
(
"
MOZ_DISABLE_ASAN_REPORTER
"
)
&
&
!
PR_GetEnv
(
"
MOZ_RUN_GTEST
"
)
)
{
nsCOMPtr
<
nsIFile
>
asanReporterPath
=
GetFileFromEnv
(
"
ASAN_REPORTER_PATH
"
)
;
if
(
!
asanReporterPath
)
{
MOZ_CRASH
(
"
Child
did
not
receive
ASAN_REPORTER_PATH
!
"
)
;
}
setASanReporterPath
(
asanReporterPath
)
;
}
#
endif
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
mozilla
:
:
SandboxEarlyInit
(
)
;
mozilla
:
:
GetNumberOfProcessors
(
)
;
#
endif
#
ifdef
MOZ_JPROF
setupProfilingStuff
(
)
;
#
endif
#
if
defined
(
XP_WIN
)
UseParentConsole
(
)
;
#
if
defined
(
MOZ_SANDBOX
)
if
(
aChildData
-
>
sandboxTargetServices
)
{
SandboxTarget
:
:
Instance
(
)
-
>
SetTargetServices
(
aChildData
-
>
sandboxTargetServices
)
;
}
#
endif
#
endif
ScopedLogging
logger
;
mozilla
:
:
LogModule
:
:
Init
(
aArgc
aArgv
)
;
AUTO_BASE_PROFILER_LABEL
(
"
XRE_InitChildProcess
(
around
Gecko
Profiler
)
"
OTHER
)
;
AUTO_PROFILER_INIT
;
AUTO_PROFILER_LABEL
(
"
XRE_InitChildProcess
"
OTHER
)
;
#
ifdef
XP_MACOSX
gfxPlatformMac
:
:
RegisterSupplementalFonts
(
)
;
#
endif
AbstractThread
:
:
InitTLS
(
)
;
#
ifdef
XP_MACOSX
if
(
aArgc
<
1
)
return
NS_ERROR_FAILURE
;
#
if
defined
(
MOZ_SANDBOX
)
int
allArgc
=
aArgc
;
#
endif
const
char
*
const
mach_port_name
=
aArgv
[
-
-
aArgc
]
;
const
int
kTimeoutMs
=
1000
;
UniqueMachSendRight
task_sender
;
kern_return_t
kr
=
bootstrap_look_up
(
bootstrap_port
mach_port_name
getter_Transfers
(
task_sender
)
)
;
if
(
kr
!
=
KERN_SUCCESS
)
{
NS_WARNING
(
nsPrintfCString
(
"
child
bootstrap_look_up
failed
:
%
s
"
mach_error_string
(
kr
)
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
kr
=
MachSendPortSendRight
(
task_sender
.
get
(
)
mach_task_self
(
)
Some
(
kTimeoutMs
)
)
;
if
(
kr
!
=
KERN_SUCCESS
)
{
NS_WARNING
(
nsPrintfCString
(
"
child
MachSendPortSendRight
failed
:
%
s
"
mach_error_string
(
kr
)
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
#
if
defined
(
MOZ_SANDBOX
)
std
:
:
string
sandboxError
;
if
(
!
GeckoChildProcessHost
:
:
StartMacSandbox
(
allArgc
aArgv
sandboxError
)
)
{
printf_stderr
(
"
Sandbox
error
:
%
s
\
n
"
sandboxError
.
c_str
(
)
)
;
MOZ_CRASH
(
"
Sandbox
initialization
failed
"
)
;
}
#
endif
#
endif
SetupErrorHandling
(
aArgv
[
0
]
)
;
bool
exceptionHandlerIsSet
=
false
;
if
(
!
CrashReporter
:
:
IsDummy
(
)
)
{
CrashReporter
:
:
FileHandle
crashTimeAnnotationFile
=
CrashReporter
:
:
kInvalidFileHandle
;
#
if
defined
(
XP_WIN
)
if
(
aArgc
<
1
)
{
return
NS_ERROR_FAILURE
;
}
-
-
aArgc
;
const
char
*
const
crashTimeAnnotationArg
=
aArgv
[
-
-
aArgc
]
;
crashTimeAnnotationFile
=
reinterpret_cast
<
CrashReporter
:
:
FileHandle
>
(
std
:
:
stoul
(
std
:
:
string
(
crashTimeAnnotationArg
)
)
)
;
#
endif
if
(
aArgc
<
1
)
return
NS_ERROR_FAILURE
;
const
char
*
const
crashReporterArg
=
aArgv
[
-
-
aArgc
]
;
if
(
IsCrashReporterEnabled
(
crashReporterArg
)
)
{
exceptionHandlerIsSet
=
CrashReporter
:
:
SetRemoteExceptionHandler
(
crashReporterArg
crashTimeAnnotationFile
)
;
if
(
!
exceptionHandlerIsSet
)
{
NS_WARNING
(
"
Could
not
setup
crash
reporting
\
n
"
)
;
}
}
else
{
CrashReporter
:
:
UnregisterRuntimeExceptionModule
(
)
;
}
}
gArgv
=
aArgv
;
gArgc
=
aArgc
;
#
ifdef
MOZ_X11
XInitThreads
(
)
;
#
endif
#
ifdef
MOZ_WIDGET_GTK
g_set_prgname
(
aArgv
[
0
]
)
;
#
endif
#
ifdef
OS_POSIX
if
(
PR_GetEnv
(
"
MOZ_DEBUG_CHILD_PROCESS
"
)
|
|
PR_GetEnv
(
"
MOZ_DEBUG_CHILD_PAUSE
"
)
)
{
#
if
defined
(
XP_LINUX
)
&
&
defined
(
DEBUG
)
if
(
prctl
(
PR_SET_PTRACER
PR_SET_PTRACER_ANY
0
0
0
)
!
=
0
)
{
printf_stderr
(
"
Could
not
allow
ptrace
from
any
process
.
\
n
"
)
;
}
#
endif
printf_stderr
(
"
\
n
\
nCHILDCHILDCHILDCHILD
(
process
type
%
s
)
\
n
debug
me
%
d
\
n
\
n
"
XRE_GetProcessTypeString
(
)
base
:
:
GetCurrentProcId
(
)
)
;
sleep
(
GetDebugChildPauseTime
(
)
)
;
}
#
elif
defined
(
OS_WIN
)
if
(
PR_GetEnv
(
"
MOZ_DEBUG_CHILD_PROCESS
"
)
)
{
NS_DebugBreak
(
NS_DEBUG_BREAK
"
Invoking
NS_DebugBreak
(
)
to
debug
child
process
"
nullptr
__FILE__
__LINE__
)
;
}
else
if
(
PR_GetEnv
(
"
MOZ_DEBUG_CHILD_PAUSE
"
)
)
{
printf_stderr
(
"
\
n
\
nCHILDCHILDCHILDCHILD
(
process
type
%
s
)
\
n
debug
me
%
lu
\
n
\
n
"
XRE_GetProcessTypeString
(
)
base
:
:
GetCurrentProcId
(
)
)
;
:
:
Sleep
(
GetDebugChildPauseTime
(
)
)
;
}
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
mozilla
:
:
startup
:
:
IncreaseDescriptorLimits
(
)
;
#
endif
const
char
*
const
parentPIDString
=
aArgv
[
aArgc
-
1
]
;
MOZ_ASSERT
(
parentPIDString
"
NULL
parent
PID
"
)
;
-
-
aArgc
;
char
*
end
=
0
;
base
:
:
ProcessId
parentPID
=
strtol
(
parentPIDString
&
end
10
)
;
MOZ_ASSERT
(
!
*
end
"
invalid
parent
PID
"
)
;
const
char
*
const
messageChannelIdString
=
aArgv
[
aArgc
-
1
]
;
MOZ_ASSERT
(
messageChannelIdString
"
NULL
MessageChannel
Id
"
)
;
-
-
aArgc
;
nsID
messageChannelId
{
}
;
if
(
!
messageChannelId
.
Parse
(
messageChannelIdString
)
)
{
return
NS_ERROR_FAILURE
;
}
#
if
defined
(
XP_WIN
)
const
char
*
const
appModelUserId
=
aArgv
[
-
-
aArgc
]
;
if
(
appModelUserId
&
&
!
mozilla
:
:
widget
:
:
WinUtils
:
:
HasPackageIdentity
(
)
)
{
if
(
*
appModelUserId
!
=
'
-
'
)
{
nsString
appId
;
CopyASCIItoUTF16
(
nsDependentCString
(
appModelUserId
)
appId
)
;
appId
.
Trim
(
"
\
"
"
)
;
SetTaskbarGroupId
(
appId
)
;
}
}
#
endif
base
:
:
AtExitManager
exitManager
;
nsresult
rv
=
XRE_InitCommandLine
(
aArgc
aArgv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
MessageLoop
:
:
Type
uiLoopType
;
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Content
:
case
GeckoProcessType_GPU
:
case
GeckoProcessType_IPDLUnitTest
:
case
GeckoProcessType_VR
:
case
GeckoProcessType_RDD
:
case
GeckoProcessType_Socket
:
case
GeckoProcessType_Utility
:
uiLoopType
=
MessageLoop
:
:
TYPE_MOZILLA_CHILD
;
break
;
case
GeckoProcessType_GMPlugin
:
case
GeckoProcessType_RemoteSandboxBroker
:
uiLoopType
=
MessageLoop
:
:
TYPE_DEFAULT
;
break
;
default
:
uiLoopType
=
MessageLoop
:
:
TYPE_UI
;
break
;
}
#
if
defined
(
MOZ_SANDBOX
)
&
&
defined
(
XP_WIN
)
if
(
aChildData
-
>
sandboxBrokerServices
)
{
SandboxBroker
:
:
Initialize
(
aChildData
-
>
sandboxBrokerServices
)
;
SandboxBroker
:
:
GeckoDependentInitialize
(
)
;
}
UCHAR
buffer
[
32
]
;
NTSTATUS
status
=
BCryptGenRandom
(
NULL
buffer
sizeof
(
buffer
)
BCRYPT_USE_SYSTEM_PREFERRED_RNG
)
;
MOZ_RELEASE_ASSERT
(
status
=
=
STATUS_SUCCESS
)
;
#
endif
{
Maybe
<
IOInterposerInit
>
ioInterposerGuard
;
MessageLoop
uiMessageLoop
(
uiLoopType
)
;
{
#
if
defined
(
XP_WIN
)
&
&
defined
(
ACCESSIBILITY
)
auto
a11yResourceId
=
geckoargs
:
:
sA11yResourceId
.
Get
(
aArgc
aArgv
)
;
if
(
a11yResourceId
.
isSome
(
)
)
{
mscom
:
:
ActCtxResource
:
:
SetAccessibilityResourceId
(
*
a11yResourceId
)
;
}
#
endif
UniquePtr
<
ProcessChild
>
process
;
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Default
:
MOZ_CRASH
(
"
This
makes
no
sense
"
)
;
break
;
case
GeckoProcessType_Content
:
ioInterposerGuard
.
emplace
(
)
;
process
=
MakeUnique
<
ContentProcess
>
(
parentPID
messageChannelId
)
;
break
;
case
GeckoProcessType_IPDLUnitTest
:
MOZ_RELEASE_ASSERT
(
mozilla
:
:
_ipdltest
:
:
gMakeIPDLUnitTestProcessChild
"
xul
-
gtest
not
loaded
!
"
)
;
process
=
mozilla
:
:
_ipdltest
:
:
gMakeIPDLUnitTestProcessChild
(
parentPID
messageChannelId
)
;
break
;
case
GeckoProcessType_GMPlugin
:
process
=
MakeUnique
<
gmp
:
:
GMPProcessChild
>
(
parentPID
messageChannelId
)
;
break
;
case
GeckoProcessType_GPU
:
process
=
MakeUnique
<
gfx
:
:
GPUProcessImpl
>
(
parentPID
messageChannelId
)
;
break
;
case
GeckoProcessType_VR
:
process
=
MakeUnique
<
gfx
:
:
VRProcessChild
>
(
parentPID
messageChannelId
)
;
break
;
case
GeckoProcessType_RDD
:
process
=
MakeUnique
<
RDDProcessImpl
>
(
parentPID
messageChannelId
)
;
break
;
case
GeckoProcessType_Socket
:
ioInterposerGuard
.
emplace
(
)
;
process
=
MakeUnique
<
net
:
:
SocketProcessImpl
>
(
parentPID
messageChannelId
)
;
break
;
case
GeckoProcessType_Utility
:
process
=
MakeUnique
<
ipc
:
:
UtilityProcessImpl
>
(
parentPID
messageChannelId
)
;
break
;
#
if
defined
(
MOZ_SANDBOX
)
&
&
defined
(
XP_WIN
)
case
GeckoProcessType_RemoteSandboxBroker
:
process
=
MakeUnique
<
RemoteSandboxBrokerProcessChild
>
(
parentPID
messageChannelId
)
;
break
;
#
endif
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
case
GeckoProcessType_ForkServer
:
MOZ_CRASH
(
"
Fork
server
should
not
go
here
"
)
;
break
;
#
endif
default
:
MOZ_CRASH
(
"
Unknown
main
thread
class
"
)
;
}
if
(
!
process
-
>
Init
(
aArgc
aArgv
)
)
{
return
NS_ERROR_FAILURE
;
}
#
if
defined
(
XP_WIN
)
:
:
SetProcessShutdownParameters
(
0x280
-
1
SHUTDOWN_NORETRY
)
;
RefPtr
<
DllServices
>
dllSvc
(
DllServices
:
:
Get
(
)
)
;
auto
dllSvcDisable
=
MakeScopeExit
(
[
&
dllSvc
]
(
)
{
dllSvc
-
>
DisableFull
(
)
;
}
)
;
#
endif
#
if
defined
(
MOZ_SANDBOX
)
&
&
defined
(
XP_WIN
)
mozilla
:
:
sandboxing
:
:
InitLoggingIfRequired
(
aChildData
-
>
ProvideLogFunction
)
;
#
endif
if
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_RemoteSandboxBroker
)
{
mozilla
:
:
FilePreferences
:
:
InitDirectoriesAllowlist
(
)
;
mozilla
:
:
FilePreferences
:
:
InitPrefs
(
)
;
OverrideDefaultLocaleIfNeeded
(
)
;
}
#
if
defined
(
MOZ_SANDBOX
)
AddContentSandboxLevelAnnotation
(
)
;
#
endif
uiMessageLoop
.
MessageLoop
:
:
Run
(
)
;
process
-
>
CleanUp
(
)
;
mozilla
:
:
Omnijar
:
:
CleanUp
(
)
;
}
}
if
(
exceptionHandlerIsSet
)
{
CrashReporter
:
:
UnsetRemoteExceptionHandler
(
)
;
}
return
XRE_DeinitCommandLine
(
)
;
}
MessageLoop
*
XRE_GetIOMessageLoop
(
)
{
if
(
sChildProcessType
=
=
GeckoProcessType_Default
)
{
return
BrowserProcessSubThread
:
:
GetMessageLoop
(
BrowserProcessSubThread
:
:
IO
)
;
}
return
IOThreadChild
:
:
message_loop
(
)
;
}
namespace
{
class
MainFunctionRunnable
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
MainFunctionRunnable
(
MainFunction
aFunction
void
*
aData
)
:
mozilla
:
:
Runnable
(
"
MainFunctionRunnable
"
)
mFunction
(
aFunction
)
mData
(
aData
)
{
NS_ASSERTION
(
aFunction
"
Don
'
t
give
me
a
null
pointer
!
"
)
;
}
private
:
MainFunction
mFunction
;
void
*
mData
;
}
;
}
NS_IMETHODIMP
MainFunctionRunnable
:
:
Run
(
)
{
mFunction
(
mData
)
;
return
NS_OK
;
}
nsresult
XRE_InitParentProcess
(
int
aArgc
char
*
aArgv
[
]
MainFunction
aMainFunction
void
*
aMainFunctionData
)
{
NS_ENSURE_ARG_MIN
(
aArgc
1
)
;
NS_ENSURE_ARG_POINTER
(
aArgv
)
;
NS_ENSURE_ARG_POINTER
(
aArgv
[
0
]
)
;
NS_SetMainThread
(
)
;
mozilla
:
:
LogModule
:
:
Init
(
aArgc
aArgv
)
;
AUTO_BASE_PROFILER_LABEL
(
"
XRE_InitParentProcess
(
around
Gecko
Profiler
)
"
OTHER
)
;
AUTO_PROFILER_INIT
;
AUTO_PROFILER_LABEL
(
"
XRE_InitParentProcess
"
OTHER
)
;
ScopedXREEmbed
embed
;
gArgc
=
aArgc
;
gArgv
=
aArgv
;
nsresult
rv
=
XRE_InitCommandLine
(
gArgc
gArgv
)
;
if
(
NS_FAILED
(
rv
)
)
return
NS_ERROR_FAILURE
;
{
embed
.
Start
(
)
;
nsCOMPtr
<
nsIAppShell
>
appShell
(
do_GetService
(
kAppShellCID
)
)
;
NS_ENSURE_TRUE
(
appShell
NS_ERROR_FAILURE
)
;
if
(
aMainFunction
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
MainFunctionRunnable
(
aMainFunction
aMainFunctionData
)
;
nsresult
rv
=
NS_DispatchToCurrentThread
(
runnable
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
NS_FAILED
(
appShell
-
>
Run
(
)
)
)
{
NS_WARNING
(
"
Failed
to
run
appshell
"
)
;
return
NS_ERROR_FAILURE
;
}
}
return
XRE_DeinitCommandLine
(
)
;
}
nsresult
XRE_RunAppShell
(
)
{
nsCOMPtr
<
nsIAppShell
>
appShell
(
do_GetService
(
kAppShellCID
)
)
;
NS_ENSURE_TRUE
(
appShell
NS_ERROR_FAILURE
)
;
#
if
defined
(
XP_MACOSX
)
if
(
XRE_UseNativeEventProcessing
(
)
)
{
MessageLoop
*
loop
=
MessageLoop
:
:
current
(
)
;
bool
couldNest
=
loop
-
>
NestableTasksAllowed
(
)
;
loop
-
>
SetNestableTasksAllowed
(
true
)
;
RefPtr
<
Runnable
>
task
=
new
MessageLoop
:
:
QuitTask
(
)
;
loop
-
>
PostTask
(
task
.
forget
(
)
)
;
loop
-
>
Run
(
)
;
loop
-
>
SetNestableTasksAllowed
(
couldNest
)
;
}
#
endif
return
appShell
-
>
Run
(
)
;
}
void
XRE_ShutdownChildProcess
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
mozilla
:
:
DebugOnly
<
MessageLoop
*
>
ioLoop
=
XRE_GetIOMessageLoop
(
)
;
MOZ_ASSERT
(
!
!
ioLoop
"
Bad
shutdown
order
"
)
;
MessageLoop
:
:
current
(
)
-
>
Quit
(
)
;
#
if
defined
(
XP_MACOSX
)
nsCOMPtr
<
nsIAppShell
>
appShell
(
do_GetService
(
kAppShellCID
)
)
;
if
(
appShell
)
{
appShell
-
>
Exit
(
)
;
}
#
endif
}
namespace
{
ContentParent
*
gContentParent
;
TestShellParent
*
GetOrCreateTestShellParent
(
)
{
if
(
!
gContentParent
)
{
RefPtr
<
ContentParent
>
parent
=
ContentParent
:
:
GetNewOrUsedBrowserProcess
(
DEFAULT_REMOTE_TYPE
)
;
parent
.
forget
(
&
gContentParent
)
;
}
else
if
(
!
gContentParent
-
>
IsAlive
(
)
)
{
return
nullptr
;
}
TestShellParent
*
tsp
=
gContentParent
-
>
GetTestShellSingleton
(
)
;
if
(
!
tsp
)
{
tsp
=
gContentParent
-
>
CreateTestShell
(
)
;
}
return
tsp
;
}
}
bool
XRE_SendTestShellCommand
(
JSContext
*
aCx
JSString
*
aCommand
JS
:
:
Value
*
aCallback
)
{
JS
:
:
Rooted
<
JSString
*
>
cmd
(
aCx
aCommand
)
;
TestShellParent
*
tsp
=
GetOrCreateTestShellParent
(
)
;
NS_ENSURE_TRUE
(
tsp
false
)
;
nsAutoJSString
command
;
NS_ENSURE_TRUE
(
command
.
init
(
aCx
cmd
)
false
)
;
if
(
!
aCallback
)
{
return
tsp
-
>
SendExecuteCommand
(
command
)
;
}
TestShellCommandParent
*
callback
=
static_cast
<
TestShellCommandParent
*
>
(
tsp
-
>
SendPTestShellCommandConstructor
(
command
)
)
;
NS_ENSURE_TRUE
(
callback
false
)
;
NS_ENSURE_TRUE
(
callback
-
>
SetCallback
(
aCx
*
aCallback
)
false
)
;
return
true
;
}
bool
XRE_ShutdownTestShell
(
)
{
if
(
!
gContentParent
)
{
return
true
;
}
bool
ret
=
true
;
if
(
gContentParent
-
>
IsAlive
(
)
)
{
ret
=
gContentParent
-
>
DestroyTestShell
(
gContentParent
-
>
GetTestShellSingleton
(
)
)
;
}
NS_RELEASE
(
gContentParent
)
;
return
ret
;
}
#
ifdef
MOZ_X11
void
XRE_InstallX11ErrorHandler
(
)
{
#
ifdef
MOZ_WIDGET_GTK
InstallGdkErrorHandler
(
)
;
#
endif
InstallX11ErrorHandler
(
)
;
}
void
XRE_CleanupX11ErrorHandler
(
)
{
CleanupX11ErrorHandler
(
)
;
}
#
endif
#
ifdef
MOZ_ENABLE_FORKSERVER
int
XRE_ForkServer
(
int
*
aArgc
char
*
*
*
aArgv
)
{
return
mozilla
:
:
ipc
:
:
ForkServer
:
:
RunForkServer
(
aArgc
aArgv
)
?
1
:
0
;
}
#
endif
