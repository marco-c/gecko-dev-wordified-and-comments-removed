#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
UntrustedModulesProcessor
.
h
"
#
include
"
mozilla
/
WinDllServices
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
TelemetryFixture
.
h
"
class
ModuleLoadCounter
final
{
nsDataHashtable
<
nsStringCaseInsensitiveHashKey
int
>
mCounters
;
public
:
template
<
int
N
>
ModuleLoadCounter
(
const
nsString
(
&
aNames
)
[
N
]
const
int
(
&
aCounts
)
[
N
]
)
:
mCounters
(
N
)
{
for
(
int
i
=
0
;
i
<
N
;
+
+
i
)
{
mCounters
.
Put
(
aNames
[
i
]
aCounts
[
i
]
)
;
}
}
template
<
int
N
>
bool
Remains
(
const
nsString
(
&
aNames
)
[
N
]
const
int
(
&
aCounts
)
[
N
]
)
{
EXPECT_EQ
(
mCounters
.
Count
(
)
N
)
;
if
(
mCounters
.
Count
(
)
!
=
N
)
{
return
false
;
}
bool
result
=
true
;
for
(
int
i
=
0
;
i
<
N
;
+
+
i
)
{
int
*
entry
=
mCounters
.
GetValue
(
aNames
[
i
]
)
;
if
(
!
entry
)
{
wprintf
(
L
"
%
s
is
not
registered
.
\
n
"
aNames
[
i
]
.
get
(
)
)
;
result
=
false
;
}
else
if
(
*
entry
!
=
aCounts
[
i
]
)
{
wprintf
(
L
"
%
s
:
%
4d
\
n
"
aNames
[
i
]
.
get
(
)
*
entry
)
;
result
=
false
;
}
}
return
result
;
}
bool
IsDone
(
)
const
{
bool
allZero
=
true
;
for
(
auto
iter
=
mCounters
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
Data
(
)
<
0
)
{
return
true
;
}
if
(
iter
.
Data
(
)
>
0
)
{
allZero
=
false
;
}
}
return
allZero
;
}
void
Decrement
(
const
nsString
&
aName
)
{
if
(
int
*
entry
=
mCounters
.
GetValue
(
aName
)
)
{
-
-
(
*
entry
)
;
}
}
}
;
class
UntrustedModulesCollector
{
static
constexpr
int
kMaximumPendingQueries
=
200
;
Vector
<
UntrustedModulesData
>
mData
;
public
:
const
Vector
<
UntrustedModulesData
>
&
Data
(
)
const
{
return
mData
;
}
nsresult
Collect
(
ModuleLoadCounter
&
aChecker
)
{
nsresult
rv
=
NS_OK
;
mData
.
clear
(
)
;
int
pendingQueries
=
0
;
EXPECT_TRUE
(
SpinEventLoopUntil
(
[
this
&
pendingQueries
&
aChecker
&
rv
]
(
)
{
if
(
pendingQueries
>
=
kMaximumPendingQueries
)
{
rv
=
NS_ERROR_ABORT
;
return
true
;
}
+
+
pendingQueries
;
RefPtr
<
DllServices
>
dllSvc
(
DllServices
:
:
Get
(
)
)
;
dllSvc
-
>
GetUntrustedModulesData
(
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
this
&
pendingQueries
&
aChecker
]
(
Maybe
<
UntrustedModulesData
>
&
&
aResult
)
{
EXPECT_GT
(
pendingQueries
0
)
;
-
-
pendingQueries
;
if
(
aResult
.
isSome
(
)
)
{
wprintf
(
L
"
Received
data
.
(
pendingQueries
=
%
d
)
\
n
"
pendingQueries
)
;
for
(
const
auto
&
evt
:
aResult
.
ref
(
)
.
mEvents
)
{
aChecker
.
Decrement
(
evt
.
mRequestedDllName
)
;
}
EXPECT_TRUE
(
mData
.
emplaceBack
(
std
:
:
move
(
aResult
.
ref
(
)
)
)
)
;
}
}
[
&
pendingQueries
&
rv
]
(
nsresult
aReason
)
{
EXPECT_GT
(
pendingQueries
0
)
;
-
-
pendingQueries
;
wprintf
(
L
"
GetUntrustedModulesData
(
)
failed
-
%
08x
\
n
"
aReason
)
;
EXPECT_TRUE
(
false
)
;
rv
=
aReason
;
}
)
;
return
aChecker
.
IsDone
(
)
;
}
)
)
;
EXPECT_TRUE
(
SpinEventLoopUntil
(
[
&
pendingQueries
]
(
)
{
return
pendingQueries
<
=
0
;
}
)
)
;
return
rv
;
}
}
;
static
void
ValidateUntrustedModules
(
const
UntrustedModulesData
&
aData
)
{
EXPECT_EQ
(
aData
.
mProcessType
GeckoProcessType_Default
)
;
EXPECT_EQ
(
aData
.
mPid
:
:
GetCurrentProcessId
(
)
)
;
nsTHashtable
<
nsPtrHashKey
<
void
>
>
moduleSet
;
for
(
auto
iter
=
aData
.
mModules
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
RefPtr
<
ModuleRecord
>
&
module
=
iter
.
Data
(
)
;
moduleSet
.
PutEntry
(
module
)
;
}
for
(
const
auto
&
evt
:
aData
.
mEvents
)
{
EXPECT_EQ
(
evt
.
mThreadId
:
:
GetCurrentThreadId
(
)
)
;
EXPECT_TRUE
(
moduleSet
.
Contains
(
evt
.
mModule
)
)
;
EXPECT_FALSE
(
evt
.
mIsDependent
)
;
}
EXPECT_GT
(
aData
.
mEvents
.
length
(
)
0
)
;
EXPECT_GT
(
aData
.
mStacks
.
GetModuleCount
(
)
0
)
;
EXPECT_TRUE
(
aData
.
mXULLoadDurationMS
.
isNothing
(
)
)
;
EXPECT_EQ
(
aData
.
mSanitizationFailures
0
)
;
EXPECT_EQ
(
aData
.
mTrustTestFailures
0
)
;
}
class
UntrustedModulesFixture
:
public
TelemetryTestFixture
{
static
constexpr
int
kLoadCountBeforeDllServices
=
5
;
static
constexpr
int
kLoadCountAfterDllServices
=
5
;
static
INIT_ONCE
sInitLoadOnce
;
static
UntrustedModulesCollector
sInitLoadDataCollector
;
static
nsString
PrependWorkingDir
(
const
nsAString
&
aLeaf
)
{
nsCOMPtr
<
nsIFile
>
file
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
NS_GetSpecialDirectory
(
NS_OS_CURRENT_WORKING_DIR
getter_AddRefs
(
file
)
)
)
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
file
-
>
Append
(
aLeaf
)
)
)
;
bool
exists
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
file
-
>
Exists
(
&
exists
)
)
&
&
exists
)
;
nsString
fullPath
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
file
-
>
GetPath
(
fullPath
)
)
)
;
return
fullPath
;
}
static
BOOL
CALLBACK
InitialModuleLoadOnce
(
PINIT_ONCE
void
*
void
*
*
)
;
protected
:
static
constexpr
int
kInitLoadCount
=
kLoadCountBeforeDllServices
+
kLoadCountAfterDllServices
;
static
const
nsString
kTestModules
[
]
;
static
void
LoadAndFree
(
const
nsAString
&
aLeaf
)
{
nsModuleHandle
dll
(
:
:
LoadLibraryW
(
PrependWorkingDir
(
aLeaf
)
.
get
(
)
)
)
;
EXPECT_TRUE
(
!
!
dll
)
;
}
virtual
void
SetUp
(
)
override
{
TelemetryTestFixture
:
:
SetUp
(
)
;
:
:
InitOnceExecuteOnce
(
&
sInitLoadOnce
InitialModuleLoadOnce
nullptr
nullptr
)
;
}
static
const
Vector
<
UntrustedModulesData
>
&
GetInitLoadData
(
)
{
return
sInitLoadDataCollector
.
Data
(
)
;
}
}
;
const
nsString
UntrustedModulesFixture
:
:
kTestModules
[
]
=
{
u
"
TestUntrustedModules_Dll1
.
dll
"
_ns
u
"
TestUntrustedModules_Dll2
.
dll
"
_ns
}
;
INIT_ONCE
UntrustedModulesFixture
:
:
sInitLoadOnce
=
INIT_ONCE_STATIC_INIT
;
UntrustedModulesCollector
UntrustedModulesFixture
:
:
sInitLoadDataCollector
;
BOOL
CALLBACK
UntrustedModulesFixture
:
:
InitialModuleLoadOnce
(
PINIT_ONCE
void
*
void
*
*
)
{
for
(
int
i
=
0
;
i
<
kLoadCountBeforeDllServices
;
+
+
i
)
{
for
(
const
auto
&
mod
:
kTestModules
)
{
LoadAndFree
(
mod
)
;
}
}
RefPtr
<
DllServices
>
dllSvc
(
DllServices
:
:
Get
(
)
)
;
dllSvc
-
>
StartUntrustedModulesProcessor
(
)
;
for
(
int
i
=
0
;
i
<
kLoadCountAfterDllServices
;
+
+
i
)
{
for
(
const
auto
&
mod
:
kTestModules
)
{
LoadAndFree
(
mod
)
;
}
}
ModuleLoadCounter
waitForTwo
(
kTestModules
{
kInitLoadCount
kInitLoadCount
}
)
;
EXPECT_EQ
(
sInitLoadDataCollector
.
Collect
(
waitForTwo
)
NS_OK
)
;
EXPECT_TRUE
(
waitForTwo
.
Remains
(
kTestModules
{
0
0
}
)
)
;
for
(
const
auto
&
event
:
GetInitLoadData
(
)
)
{
ValidateUntrustedModules
(
event
)
;
}
UntrustedModulesCollector
collector
;
ModuleLoadCounter
waitOnceForEach
(
kTestModules
{
1
1
}
)
;
EXPECT_EQ
(
collector
.
Collect
(
waitOnceForEach
)
NS_ERROR_ABORT
)
;
EXPECT_TRUE
(
waitOnceForEach
.
Remains
(
kTestModules
{
1
1
}
)
)
;
return
TRUE
;
}
TEST_F
(
UntrustedModulesFixture
Main
)
{
}
