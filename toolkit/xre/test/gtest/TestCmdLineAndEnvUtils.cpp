#
include
<
memory
>
#
include
<
ostream
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
vector
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
CmdLineAndEnvUtils
.
h
"
namespace
testzilla
{
template
<
typename
CharT
>
struct
AcceptableArgs
;
template
<
>
struct
AcceptableArgs
<
char
>
{
constexpr
static
const
char
*
value
[
]
=
{
"
aleph
"
"
beth
"
nullptr
}
;
}
;
template
<
>
struct
AcceptableArgs
<
wchar_t
>
{
constexpr
static
const
wchar_t
*
value
[
]
=
{
L
"
aleph
"
L
"
beth
"
nullptr
}
;
}
;
class
CommandLine
{
const
size_t
size
;
std
:
:
vector
<
std
:
:
string
>
_data_8
;
std
:
:
vector
<
std
:
:
wstring
>
_data_16
;
char
const
*
*
argv_8
;
wchar_t
const
*
*
argv_16
;
public
:
inline
int
argc
(
)
const
{
return
(
int
)
(
unsigned
int
)
(
size
)
;
}
template
<
typename
CharT
>
CharT
const
*
*
argv
(
)
const
;
CommandLine
(
CommandLine
const
&
)
=
delete
;
CommandLine
(
CommandLine
&
&
that
)
=
delete
;
template
<
typename
Container
>
explicit
CommandLine
(
Container
const
&
container
)
:
size
{
std
:
:
size
(
container
)
+
1
}
argv_8
(
new
const
char
*
[
size
+
1
]
)
argv_16
(
new
const
wchar_t
*
[
size
+
1
]
)
{
_data_8
.
reserve
(
size
+
1
)
;
_data_16
.
reserve
(
size
+
1
)
;
size_t
pos
=
0
;
const
auto
append
=
[
&
]
(
const
char
*
val
)
{
size_t
const
len
=
:
:
strlen
(
val
)
;
_data_8
.
emplace_back
(
val
val
+
len
)
;
_data_16
.
emplace_back
(
val
val
+
len
)
;
argv_8
[
pos
]
=
_data_8
.
back
(
)
.
data
(
)
;
argv_16
[
pos
]
=
_data_16
.
back
(
)
.
data
(
)
;
+
+
pos
;
}
;
append
(
"
GECKOAPP
.
COM
"
)
;
for
(
const
char
*
item
:
container
)
{
append
(
item
)
;
}
assert
(
pos
=
=
size
)
;
argv_8
[
pos
]
=
nullptr
;
argv_16
[
pos
]
=
nullptr
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
o
CommandLine
const
&
cl
)
{
for
(
const
auto
&
item
:
cl
.
_data_8
)
{
o
<
<
'
"
'
;
for
(
const
char
c
:
item
)
{
if
(
c
=
=
'
"
'
)
{
o
<
<
"
\
\
\
"
"
;
}
else
{
o
<
<
c
;
}
}
o
<
<
"
\
"
"
;
}
return
o
;
}
}
;
template
<
>
char
const
*
*
CommandLine
:
:
argv
<
char
>
(
)
const
{
return
argv_8
;
}
template
<
>
wchar_t
const
*
*
CommandLine
:
:
argv
<
wchar_t
>
(
)
const
{
return
argv_16
;
}
enum
TestCaseState
:
bool
{
FAIL
=
false
PASS
=
true
}
;
constexpr
TestCaseState
operator
!
(
TestCaseState
s
)
{
return
TestCaseState
(
!
bool
(
s
)
)
;
}
#
ifdef
XP_WIN
constexpr
static
const
TestCaseState
WIN_ONLY
=
PASS
;
#
else
constexpr
static
const
TestCaseState
WIN_ONLY
=
FAIL
;
#
endif
std
:
:
pair
<
TestCaseState
std
:
:
vector
<
const
char
*
>
>
const
kCommandLines
[
]
=
{
{
PASS
{
"
-
osint
"
"
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
PASS
{
"
-
osint
"
"
-
beth
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
PASS
{
"
-
-
osint
"
"
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
PASS
{
"
-
-
osint
"
"
-
beth
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
PASS
{
"
-
-
osint
"
"
-
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
PASS
{
"
-
-
osint
"
"
-
-
beth
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
WIN_ONLY
{
"
-
osint
"
"
/
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
WIN_ONLY
{
"
-
-
osint
"
"
/
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
PASS
{
"
/
osint
"
"
/
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
PASS
{
"
/
osint
"
"
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
PASS
{
"
/
osint
"
"
-
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
FAIL
{
"
-
osint
"
"
-
aleph
"
"
-
anything
"
}
}
{
FAIL
{
"
-
osint
"
"
-
aleph
"
"
-
-
anything
"
}
}
{
!
WIN_ONLY
{
"
-
osint
"
"
-
aleph
"
"
/
anything
"
}
}
{
FAIL
{
"
-
osint
"
"
http
:
/
/
www
.
example
.
com
/
"
"
-
aleph
"
}
}
{
FAIL
{
"
-
aleph
"
"
-
osint
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
FAIL
{
"
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
"
-
osint
"
}
}
{
FAIL
{
"
http
:
/
/
www
.
example
.
com
/
"
"
-
osint
"
"
-
aleph
"
}
}
{
FAIL
{
"
http
:
/
/
www
.
example
.
com
/
"
"
-
aleph
"
"
-
osint
"
}
}
{
FAIL
{
"
-
osint
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
FAIL
{
"
-
osint
"
"
-
aleph
"
}
}
{
FAIL
{
"
-
osint
"
}
}
{
FAIL
{
"
-
osint
"
"
-
other
-
argument
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
FAIL
{
"
-
osint
"
"
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
FAIL
{
"
-
osint
"
"
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
"
-
other
-
argument
"
}
}
{
FAIL
{
"
-
osint
"
"
-
other
-
argument
"
"
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
FAIL
{
"
-
osint
"
"
-
aleph
"
"
-
other
-
argument
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
FAIL
{
"
-
osint
"
"
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
"
-
a
"
"
-
b
"
}
}
{
FAIL
{
"
-
osint
"
"
-
aleph
"
"
-
a
"
"
http
:
/
/
www
.
example
.
com
/
"
"
-
b
"
}
}
{
FAIL
{
"
-
osint
"
"
-
a
"
"
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
"
-
b
"
}
}
{
FAIL
{
"
-
osint
"
"
-
aleph
"
"
-
beth
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
FAIL
{
"
-
osint
"
"
-
aleph
"
"
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
PASS
{
}
}
{
PASS
{
"
http
:
/
/
www
.
example
.
com
"
}
}
{
PASS
{
"
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
PASS
{
"
-
beth
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
{
PASS
{
"
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
"
-
other
-
argument
"
}
}
{
PASS
{
"
-
aleph
"
"
-
aleph
"
"
http
:
/
/
www
.
example
.
com
/
"
}
}
}
;
template
<
typename
CharT
>
bool
TestCommandLineImpl
(
CommandLine
const
&
cl
)
{
int
argc
=
cl
.
argc
(
)
;
CharT
*
*
argv
=
const_cast
<
CharT
*
*
>
(
cl
.
argv
<
CharT
>
(
)
)
;
return
mozilla
:
:
EnsureCommandlineSafeImpl
<
CharT
>
(
argc
argv
AcceptableArgs
<
CharT
>
:
:
value
)
;
}
void
TestCommandLine
(
TestCaseState
expectation
CommandLine
const
&
cl
)
{
EXPECT_EQ
(
TestCommandLineImpl
<
char
>
(
cl
)
expectation
)
<
<
"
cl
is
:
"
<
<
cl
;
#
ifdef
XP_WIN
EXPECT_EQ
(
TestCommandLineImpl
<
wchar_t
>
(
cl
)
expectation
)
<
<
"
cl
is
:
"
<
<
cl
;
#
endif
}
}
TEST
(
CmdLineAndEnvUtils
ensureSafe
)
{
using
namespace
testzilla
;
for
(
auto
const
&
[
result
data
]
:
kCommandLines
)
{
CommandLine
const
cl
(
data
)
;
TestCommandLine
(
result
cl
)
;
}
}
