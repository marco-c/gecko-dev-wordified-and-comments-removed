#
include
"
GlobalSemaphore
.
h
"
#
include
"
commonupdatedir
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
updatedefines
.
h
"
#
ifndef
XP_WIN
#
include
<
fcntl
.
h
>
#
include
<
sys
/
stat
.
h
>
#
else
#
include
<
limits
.
h
>
#
endif
#
ifdef
XP_WIN
#
define
SEMAPHORE_NAME_PREFIX
"
Global
\
\
"
#
else
#
define
SEMAPHORE_NAME_PREFIX
"
/
"
#
endif
namespace
mozilla
{
#
ifndef
XP_MACOSX
static
bool
GetSemaphoreName
(
const
char
*
nameToken
const
char16_t
*
installPath
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
&
semName
)
{
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
pathHash
;
if
(
!
GetInstallHash
(
installPath
MOZ_APP_VENDOR
pathHash
)
)
{
return
false
;
}
size_t
semNameLen
=
strlen
(
SEMAPHORE_NAME_PREFIX
)
+
strlen
(
nameToken
)
+
NS_tstrlen
(
pathHash
.
get
(
)
)
+
1
;
semName
=
mozilla
:
:
MakeUnique
<
NS_tchar
[
]
>
(
semNameLen
+
1
)
;
if
(
!
semName
)
{
return
false
;
}
#
ifdef
XP_WIN
const
NS_tchar
*
kSemaphoreNameFormat
=
NS_T
(
SEMAPHORE_NAME_PREFIX
"
%
S
-
%
s
"
)
;
#
else
const
NS_tchar
*
kSemaphoreNameFormat
=
NS_T
(
SEMAPHORE_NAME_PREFIX
"
%
s
-
%
s
"
)
;
#
endif
NS_tsnprintf
(
semName
.
get
(
)
semNameLen
+
1
kSemaphoreNameFormat
nameToken
pathHash
.
get
(
)
)
;
return
true
;
}
#
endif
#
ifdef
XP_WIN
GlobalSemHandle
OpenGlobalSemaphore
(
const
char
*
nameToken
const
char16_t
*
installPath
)
{
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
semName
;
if
(
!
GetSemaphoreName
(
nameToken
installPath
semName
)
)
{
return
nullptr
;
}
GlobalSemHandle
sem
=
:
:
CreateSemaphoreW
(
nullptr
LONG_MAX
LONG_MAX
semName
.
get
(
)
)
;
if
(
sem
)
{
if
(
:
:
WaitForSingleObject
(
sem
0
)
!
=
WAIT_OBJECT_0
)
{
:
:
CloseHandle
(
sem
)
;
sem
=
nullptr
;
}
}
return
sem
;
}
void
ReleaseGlobalSemaphore
(
GlobalSemHandle
sem
)
{
if
(
sem
)
{
:
:
ReleaseSemaphore
(
sem
1
nullptr
)
;
:
:
CloseHandle
(
sem
)
;
}
}
bool
IsOtherInstanceRunning
(
GlobalSemHandle
sem
bool
*
aResult
)
{
if
(
sem
&
&
:
:
WaitForSingleObject
(
sem
0
)
=
=
WAIT_OBJECT_0
)
{
LONG
count
=
0
;
if
(
:
:
ReleaseSemaphore
(
sem
1
&
count
)
)
{
*
aResult
=
(
count
!
=
(
LONG_MAX
-
2
)
)
;
return
true
;
}
}
return
false
;
}
#
elif
defined
(
XP_MACOSX
)
GlobalSemHandle
OpenGlobalSemaphore
(
const
char
*
const
char16_t
*
)
{
return
(
GlobalSemHandle
)
1
;
}
void
ReleaseGlobalSemaphore
(
GlobalSemHandle
)
{
}
bool
IsOtherInstanceRunning
(
GlobalSemHandle
bool
*
aResult
)
{
*
aResult
=
false
;
return
true
;
}
#
else
GlobalSemHandle
OpenGlobalSemaphore
(
const
char
*
nameToken
const
char16_t
*
installPath
)
{
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
semName
;
if
(
!
GetSemaphoreName
(
nameToken
installPath
semName
)
)
{
return
nullptr
;
}
GlobalSemHandle
sem
=
sem_open
(
semName
.
get
(
)
O_CREAT
S_IRWXU
|
S_IRWXG
|
S_IRWXO
SEM_VALUE_MAX
)
;
if
(
sem
=
=
SEM_FAILED
)
{
return
nullptr
;
}
if
(
sem_trywait
(
sem
)
)
{
sem_close
(
sem
)
;
return
nullptr
;
}
return
sem
;
}
void
ReleaseGlobalSemaphore
(
GlobalSemHandle
sem
)
{
if
(
sem
)
{
sem_post
(
sem
)
;
sem_close
(
sem
)
;
}
}
bool
IsOtherInstanceRunning
(
GlobalSemHandle
sem
bool
*
aResult
)
{
int
value
=
0
;
if
(
sem
&
&
!
sem_getvalue
(
sem
&
value
)
)
{
if
(
value
<
=
0
)
{
return
false
;
}
*
aResult
=
(
value
!
=
(
SEM_VALUE_MAX
-
1
)
)
;
return
true
;
}
return
false
;
}
#
endif
}
;
