#
ifndef
mozilla_AssembleCmdLine_h
#
define
mozilla_AssembleCmdLine_h
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
windows
.
h
>
#
ifdef
MOZILLA_INTERNAL_API
#
include
"
nsString
.
h
"
#
endif
namespace
mozilla
{
inline
int
assembleCmdLine
(
const
char
*
const
*
aArgv
wchar_t
*
*
aWideCmdLine
UINT
aCodePage
)
{
const
char
*
const
*
arg
;
char
*
p
;
const
char
*
q
;
char
*
cmdLine
;
int
cmdLineSize
;
int
numBackslashes
;
int
i
;
int
argNeedQuotes
;
cmdLineSize
=
0
;
for
(
arg
=
aArgv
;
*
arg
;
+
+
arg
)
{
cmdLineSize
+
=
2
*
strlen
(
*
arg
)
+
2
+
1
;
}
p
=
cmdLine
=
(
char
*
)
malloc
(
cmdLineSize
*
sizeof
(
char
)
)
;
if
(
!
p
)
{
return
-
1
;
}
for
(
arg
=
aArgv
;
*
arg
;
+
+
arg
)
{
if
(
arg
!
=
aArgv
)
{
*
p
+
+
=
'
'
;
}
q
=
*
arg
;
numBackslashes
=
0
;
argNeedQuotes
=
0
;
if
(
strpbrk
(
*
arg
"
\
f
\
n
\
r
\
t
\
v
"
)
)
{
argNeedQuotes
=
1
;
}
if
(
argNeedQuotes
)
{
*
p
+
+
=
'
"
'
;
}
while
(
*
q
)
{
if
(
*
q
=
=
'
\
\
'
)
{
numBackslashes
+
+
;
q
+
+
;
}
else
if
(
*
q
=
=
'
"
'
)
{
if
(
numBackslashes
)
{
for
(
i
=
0
;
i
<
2
*
numBackslashes
;
i
+
+
)
{
*
p
+
+
=
'
\
\
'
;
}
numBackslashes
=
0
;
}
*
p
+
+
=
'
\
\
'
;
*
p
+
+
=
*
q
+
+
;
}
else
{
if
(
numBackslashes
)
{
for
(
i
=
0
;
i
<
numBackslashes
;
i
+
+
)
{
*
p
+
+
=
'
\
\
'
;
}
numBackslashes
=
0
;
}
*
p
+
+
=
*
q
+
+
;
}
}
if
(
numBackslashes
)
{
if
(
argNeedQuotes
)
{
numBackslashes
*
=
2
;
}
for
(
i
=
0
;
i
<
numBackslashes
;
i
+
+
)
{
*
p
+
+
=
'
\
\
'
;
}
}
if
(
argNeedQuotes
)
{
*
p
+
+
=
'
"
'
;
}
}
*
p
=
'
\
0
'
;
int
numChars
=
MultiByteToWideChar
(
aCodePage
0
cmdLine
-
1
nullptr
0
)
;
*
aWideCmdLine
=
(
wchar_t
*
)
malloc
(
numChars
*
sizeof
(
wchar_t
)
)
;
MultiByteToWideChar
(
aCodePage
0
cmdLine
-
1
*
aWideCmdLine
numChars
)
;
free
(
cmdLine
)
;
return
0
;
}
#
ifdef
MOZILLA_INTERNAL_API
inline
UniquePtr
<
wchar_t
[
]
>
assembleSingleArgument
(
const
nsString
&
aArg
)
{
static_assert
(
sizeof
(
char16_t
)
=
=
sizeof
(
wchar_t
)
"
char16_t
and
wchar_t
sizes
differ
"
)
;
int
cmdLineSize
=
2
*
aArg
.
Length
(
)
+
2
+
1
;
auto
assembledArg
=
MakeUnique
<
wchar_t
[
]
>
(
cmdLineSize
)
;
if
(
!
assembledArg
)
{
return
nullptr
;
}
int
argNeedQuotes
=
0
;
if
(
aArg
.
FindCharInSet
(
u
"
\
f
\
n
\
r
\
t
\
v
"
)
!
=
kNotFound
)
{
argNeedQuotes
=
1
;
}
wchar_t
*
p
=
assembledArg
.
get
(
)
;
if
(
argNeedQuotes
)
{
*
p
+
+
=
'
"
'
;
}
const
char16_t
*
q
=
aArg
.
get
(
)
;
int
numBackslashes
=
0
;
while
(
*
q
)
{
if
(
*
q
=
=
'
\
\
'
)
{
numBackslashes
+
+
;
q
+
+
;
}
else
if
(
*
q
=
=
'
"
'
)
{
if
(
numBackslashes
)
{
for
(
int
i
=
0
;
i
<
2
*
numBackslashes
;
i
+
+
)
{
*
p
+
+
=
'
\
\
'
;
}
numBackslashes
=
0
;
}
*
p
+
+
=
'
\
\
'
;
*
p
+
+
=
*
q
+
+
;
}
else
{
if
(
numBackslashes
)
{
for
(
int
i
=
0
;
i
<
numBackslashes
;
i
+
+
)
{
*
p
+
+
=
'
\
\
'
;
}
numBackslashes
=
0
;
}
*
p
+
+
=
*
q
+
+
;
}
}
if
(
numBackslashes
)
{
if
(
argNeedQuotes
)
{
numBackslashes
*
=
2
;
}
for
(
int
i
=
0
;
i
<
numBackslashes
;
i
+
+
)
{
*
p
+
+
=
'
\
\
'
;
}
}
if
(
argNeedQuotes
)
{
*
p
+
+
=
'
"
'
;
}
*
p
=
'
\
0
'
;
return
assembledArg
;
}
#
endif
}
#
endif
#
endif
