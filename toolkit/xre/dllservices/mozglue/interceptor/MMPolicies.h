#
ifndef
mozilla_interceptor_MMPolicies_h
#
define
mozilla_interceptor_MMPolicies_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DynamicallyLinkedFunctionPtr
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
WindowsMapRemoteView
.
h
"
#
include
"
mozilla
/
WindowsUnwindInfo
.
h
"
#
include
<
windows
.
h
>
#
if
(
NTDDI_VERSION
<
NTDDI_WIN10_RS4
)
|
|
defined
(
__MINGW32__
)
WINBASEAPI
PVOID
WINAPI
VirtualAlloc2
(
HANDLE
Process
PVOID
BaseAddress
SIZE_T
Size
ULONG
AllocationType
ULONG
PageProtection
MEM_EXTENDED_PARAMETER
*
ExtendedParameters
ULONG
ParameterCount
)
;
WINBASEAPI
PVOID
WINAPI
MapViewOfFile3
(
HANDLE
FileMapping
HANDLE
Process
PVOID
BaseAddress
ULONG64
Offset
SIZE_T
ViewSize
ULONG
AllocationType
ULONG
PageProtection
MEM_EXTENDED_PARAMETER
*
ExtendedParameters
ULONG
ParameterCount
)
;
#
endif
#
if
!
defined
(
_CRT_RAND_S
)
extern
"
C
"
errno_t
rand_s
(
unsigned
int
*
randomValue
)
;
#
endif
namespace
mozilla
{
namespace
nt
{
SIZE_T
WINAPI
VirtualQueryEx
(
HANDLE
aProcess
LPCVOID
aAddress
PMEMORY_BASIC_INFORMATION
aMemInfo
SIZE_T
aMemInfoLen
)
;
SIZE_T
WINAPI
VirtualQuery
(
LPCVOID
aAddress
PMEMORY_BASIC_INFORMATION
aMemInfo
SIZE_T
aMemInfoLen
)
;
}
}
namespace
mozilla
{
namespace
interceptor
{
class
MOZ_TRIVIAL_CTOR_DTOR
MMPolicyInProcessPrimitive
{
protected
:
bool
ProtectInternal
(
decltype
(
&
:
:
VirtualProtect
)
aVirtualProtect
void
*
aVAddress
size_t
aSize
uint32_t
aProtFlags
uint32_t
*
aPrevProtFlags
)
const
{
MOZ_ASSERT
(
aPrevProtFlags
)
;
BOOL
ok
=
aVirtualProtect
(
aVAddress
aSize
aProtFlags
reinterpret_cast
<
PDWORD
>
(
aPrevProtFlags
)
)
;
if
(
!
ok
&
&
aPrevProtFlags
)
{
*
aPrevProtFlags
=
0
;
}
return
!
!
ok
;
}
public
:
bool
Read
(
void
*
aToPtr
const
void
*
aFromPtr
size_t
aLen
)
const
{
:
:
memcpy
(
aToPtr
aFromPtr
aLen
)
;
return
true
;
}
bool
Write
(
void
*
aToPtr
const
void
*
aFromPtr
size_t
aLen
)
const
{
:
:
memcpy
(
aToPtr
aFromPtr
aLen
)
;
return
true
;
}
bool
IsPageAccessible
(
uintptr_t
aVAddress
)
const
{
MEMORY_BASIC_INFORMATION
mbi
;
SIZE_T
result
=
nt
:
:
VirtualQuery
(
reinterpret_cast
<
LPCVOID
>
(
aVAddress
)
&
mbi
sizeof
(
mbi
)
)
;
return
result
&
&
mbi
.
AllocationProtect
&
&
mbi
.
State
=
=
MEM_COMMIT
&
&
mbi
.
Protect
!
=
PAGE_NOACCESS
;
}
}
;
class
MOZ_TRIVIAL_CTOR_DTOR
MMPolicyBase
{
protected
:
static
uintptr_t
AlignDown
(
const
uintptr_t
aUnaligned
const
uintptr_t
aAlignTo
)
{
MOZ_ASSERT
(
IsPowerOfTwo
(
aAlignTo
)
)
;
#
pragma
warning
(
suppress
:
4146
)
return
aUnaligned
&
(
-
aAlignTo
)
;
}
static
uintptr_t
AlignUp
(
const
uintptr_t
aUnaligned
const
uintptr_t
aAlignTo
)
{
MOZ_ASSERT
(
IsPowerOfTwo
(
aAlignTo
)
)
;
#
pragma
warning
(
suppress
:
4146
)
return
aUnaligned
+
(
(
-
aUnaligned
)
&
(
aAlignTo
-
1
)
)
;
}
static
PVOID
AlignUpToRegion
(
PVOID
aUnaligned
uintptr_t
aAlignTo
size_t
aLen
size_t
aDesiredLen
)
{
uintptr_t
unaligned
=
reinterpret_cast
<
uintptr_t
>
(
aUnaligned
)
;
uintptr_t
aligned
=
AlignUp
(
unaligned
aAlignTo
)
;
MOZ_ASSERT
(
aligned
>
=
unaligned
)
;
if
(
aLen
<
aligned
-
unaligned
)
{
return
nullptr
;
}
aLen
-
=
(
aligned
-
unaligned
)
;
return
reinterpret_cast
<
PVOID
>
(
(
aLen
>
=
aDesiredLen
)
?
aligned
:
0
)
;
}
public
:
#
if
defined
(
NIGHTLY_BUILD
)
Maybe
<
DetourError
>
mLastError
;
const
Maybe
<
DetourError
>
&
GetLastDetourError
(
)
const
{
return
mLastError
;
}
template
<
typename
.
.
.
Args
>
void
SetLastDetourError
(
Args
&
&
.
.
.
aArgs
)
{
mLastError
=
Some
(
DetourError
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
#
else
template
<
typename
.
.
.
Args
>
void
SetLastDetourError
(
Args
&
&
.
.
.
aArgs
)
{
}
#
endif
DWORD
ComputeAllocationSize
(
const
uint32_t
aRequestedSize
)
const
{
MOZ_ASSERT
(
aRequestedSize
)
;
DWORD
result
=
aRequestedSize
;
const
uint32_t
granularity
=
GetAllocGranularity
(
)
;
uint32_t
mod
=
aRequestedSize
%
granularity
;
if
(
mod
)
{
result
+
=
(
granularity
-
mod
)
;
}
return
result
;
}
DWORD
GetAllocGranularity
(
)
const
{
static
const
DWORD
kAllocGranularity
=
[
]
(
)
-
>
DWORD
{
SYSTEM_INFO
sysInfo
;
:
:
GetSystemInfo
(
&
sysInfo
)
;
return
sysInfo
.
dwAllocationGranularity
;
}
(
)
;
return
kAllocGranularity
;
}
DWORD
GetPageSize
(
)
const
{
static
const
DWORD
kPageSize
=
[
]
(
)
-
>
DWORD
{
SYSTEM_INFO
sysInfo
;
:
:
GetSystemInfo
(
&
sysInfo
)
;
return
sysInfo
.
dwPageSize
;
}
(
)
;
return
kPageSize
;
}
uintptr_t
GetMaxUserModeAddress
(
)
const
{
static
const
uintptr_t
kMaxUserModeAddr
=
[
]
(
)
-
>
uintptr_t
{
SYSTEM_INFO
sysInfo
;
:
:
GetSystemInfo
(
&
sysInfo
)
;
return
reinterpret_cast
<
uintptr_t
>
(
sysInfo
.
lpMaximumApplicationAddress
)
;
}
(
)
;
return
kMaxUserModeAddr
;
}
static
const
uint8_t
*
GetLowerBound
(
const
Span
<
const
uint8_t
>
&
aBounds
)
{
return
&
(
*
aBounds
.
cbegin
(
)
)
;
}
static
const
uint8_t
*
GetUpperBoundIncl
(
const
Span
<
const
uint8_t
>
&
aBounds
)
{
return
&
(
*
(
aBounds
.
cend
(
)
-
1
)
)
;
}
static
const
uint8_t
*
GetUpperBoundExcl
(
const
Span
<
const
uint8_t
>
&
aBounds
)
{
return
GetUpperBoundIncl
(
aBounds
)
+
1
;
}
Maybe
<
Span
<
const
uint8_t
>
>
SpanFromPivotAndDistance
(
const
uint32_t
aSize
const
uintptr_t
aPivotAddr
const
uint32_t
aMaxDistanceFromPivot
)
const
{
if
(
!
aPivotAddr
|
|
!
aMaxDistanceFromPivot
)
{
return
Nothing
(
)
;
}
const
uintptr_t
kMinAllowableAddress
=
0x100000
;
const
uintptr_t
kGranularity
(
GetAllocGranularity
(
)
)
;
CheckedInt
<
uintptr_t
>
lowerBound
(
aPivotAddr
)
;
lowerBound
-
=
aMaxDistanceFromPivot
;
if
(
lowerBound
.
isValid
(
)
)
{
lowerBound
=
std
:
:
max
(
lowerBound
.
value
(
)
kMinAllowableAddress
)
;
}
else
{
lowerBound
=
CheckedInt
<
uintptr_t
>
(
kMinAllowableAddress
)
;
}
lowerBound
=
AlignUp
(
lowerBound
.
value
(
)
kGranularity
)
;
MOZ_ASSERT
(
lowerBound
.
isValid
(
)
)
;
if
(
!
lowerBound
.
isValid
(
)
)
{
return
Nothing
(
)
;
}
const
uintptr_t
kMaxUserModeAddr
=
GetMaxUserModeAddress
(
)
;
CheckedInt
<
uintptr_t
>
upperBound
(
aPivotAddr
)
;
upperBound
+
=
aMaxDistanceFromPivot
;
if
(
upperBound
.
isValid
(
)
)
{
upperBound
=
std
:
:
min
(
upperBound
.
value
(
)
kMaxUserModeAddr
)
;
}
else
{
upperBound
=
CheckedInt
<
uintptr_t
>
(
kMaxUserModeAddr
)
;
}
upperBound
-
=
aSize
;
if
(
!
upperBound
.
isValid
(
)
)
{
return
Nothing
(
)
;
}
upperBound
=
AlignDown
(
upperBound
.
value
(
)
kGranularity
)
;
if
(
!
upperBound
.
isValid
(
)
)
{
return
Nothing
(
)
;
}
MOZ_ASSERT
(
lowerBound
.
value
(
)
<
upperBound
.
value
(
)
)
;
if
(
lowerBound
.
value
(
)
>
=
upperBound
.
value
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
Span
(
reinterpret_cast
<
const
uint8_t
*
>
(
lowerBound
.
value
(
)
)
upperBound
.
value
(
)
-
lowerBound
.
value
(
)
)
)
;
}
PVOID
FindRegion
(
HANDLE
aProcess
const
size_t
aDesiredBytesLen
const
uint8_t
*
aRangeMin
const
uint8_t
*
aRangeMax
)
{
uintptr_t
rangeMin
=
reinterpret_cast
<
uintptr_t
>
(
aRangeMin
)
;
uintptr_t
rangeMax
=
reinterpret_cast
<
uintptr_t
>
(
aRangeMax
)
;
const
DWORD
kGranularity
=
GetAllocGranularity
(
)
;
if
(
!
aDesiredBytesLen
)
{
SetLastDetourError
(
MMPOLICY_RESERVE_FINDREGION_INVALIDLEN
)
;
return
nullptr
;
}
MOZ_ASSERT
(
rangeMin
<
rangeMax
)
;
if
(
rangeMin
>
=
rangeMax
)
{
SetLastDetourError
(
MMPOLICY_RESERVE_FINDREGION_INVALIDRANGE
)
;
return
nullptr
;
}
unsigned
int
rnd
=
0
;
rand_s
(
&
rnd
)
;
uintptr_t
maxOffset
=
(
rangeMax
-
rangeMin
-
aDesiredBytesLen
)
/
kGranularity
;
uintptr_t
offset
=
(
uintptr_t
(
rnd
)
%
(
maxOffset
+
1
)
)
*
kGranularity
;
const
uintptr_t
searchStart
=
rangeMin
+
offset
;
const
uintptr_t
kMaxPtr
=
rangeMax
-
aDesiredBytesLen
;
MOZ_DIAGNOSTIC_ASSERT
(
searchStart
<
=
kMaxPtr
)
;
MEMORY_BASIC_INFORMATION
mbi
;
SIZE_T
len
=
sizeof
(
mbi
)
;
for
(
uintptr_t
address
=
searchStart
;
address
<
=
kMaxPtr
;
)
{
if
(
nt
:
:
VirtualQueryEx
(
aProcess
reinterpret_cast
<
uint8_t
*
>
(
address
)
&
mbi
len
)
!
=
len
)
{
SetLastDetourError
(
MMPOLICY_RESERVE_FINDREGION_VIRTUALQUERY_ERROR
:
:
GetLastError
(
)
)
;
return
nullptr
;
}
if
(
mbi
.
State
=
=
MEM_FREE
)
{
PVOID
regionStart
=
AlignUpToRegion
(
mbi
.
BaseAddress
kGranularity
mbi
.
RegionSize
aDesiredBytesLen
)
;
if
(
regionStart
)
{
return
regionStart
;
}
}
address
=
reinterpret_cast
<
uintptr_t
>
(
mbi
.
BaseAddress
)
+
mbi
.
RegionSize
;
}
for
(
uintptr_t
address
=
rangeMin
;
address
<
searchStart
;
)
{
if
(
nt
:
:
VirtualQueryEx
(
aProcess
reinterpret_cast
<
uint8_t
*
>
(
address
)
&
mbi
len
)
!
=
len
)
{
SetLastDetourError
(
MMPOLICY_RESERVE_FINDREGION_VIRTUALQUERY_ERROR
:
:
GetLastError
(
)
)
;
return
nullptr
;
}
if
(
mbi
.
State
=
=
MEM_FREE
)
{
PVOID
regionStart
=
AlignUpToRegion
(
mbi
.
BaseAddress
kGranularity
mbi
.
RegionSize
aDesiredBytesLen
)
;
if
(
regionStart
)
{
return
regionStart
;
}
}
address
=
reinterpret_cast
<
uintptr_t
>
(
mbi
.
BaseAddress
)
+
mbi
.
RegionSize
;
}
SetLastDetourError
(
MMPOLICY_RESERVE_FINDREGION_NO_FREE_REGION
:
:
GetLastError
(
)
)
;
return
nullptr
;
}
template
<
typename
ReserveFnT
typename
ReserveRangeFnT
>
PVOID
Reserve
(
HANDLE
aProcess
const
uint32_t
aSize
const
ReserveFnT
&
aReserveFn
const
ReserveRangeFnT
&
aReserveRangeFn
const
Maybe
<
Span
<
const
uint8_t
>
>
&
aBounds
)
{
if
(
!
aBounds
)
{
PVOID
ret
=
aReserveFn
(
aProcess
nullptr
aSize
)
;
if
(
!
ret
)
{
SetLastDetourError
(
MMPOLICY_RESERVE_NOBOUND_RESERVE_ERROR
:
:
GetLastError
(
)
)
;
}
return
ret
;
}
const
uint8_t
*
lowerBound
=
GetLowerBound
(
aBounds
.
ref
(
)
)
;
const
uint8_t
*
upperBoundExcl
=
GetUpperBoundExcl
(
aBounds
.
ref
(
)
)
;
Maybe
<
PVOID
>
result
=
aReserveRangeFn
(
aProcess
aSize
lowerBound
upperBoundExcl
)
;
if
(
result
)
{
return
result
.
value
(
)
;
}
size_t
curAttempt
=
0
;
const
size_t
kMaxAttempts
=
8
;
while
(
curAttempt
<
kMaxAttempts
)
{
PVOID
base
=
FindRegion
(
aProcess
aSize
lowerBound
upperBoundExcl
)
;
if
(
!
base
)
{
return
nullptr
;
}
result
=
Some
(
aReserveFn
(
aProcess
base
aSize
)
)
;
if
(
result
.
value
(
)
)
{
return
result
.
value
(
)
;
}
+
+
curAttempt
;
}
PVOID
ret
=
aReserveFn
(
aProcess
nullptr
aSize
)
;
if
(
!
ret
)
{
SetLastDetourError
(
MMPOLICY_RESERVE_FINAL_RESERVE_ERROR
:
:
GetLastError
(
)
)
;
}
return
ret
;
}
}
;
class
MOZ_TRIVIAL_CTOR_DTOR
MMPolicyInProcess
:
public
MMPolicyInProcessPrimitive
public
MMPolicyBase
{
public
:
typedef
MMPolicyInProcess
MMPolicyT
;
constexpr
MMPolicyInProcess
(
)
:
mBase
(
nullptr
)
mReservationSize
(
0
)
mCommitOffset
(
0
)
{
}
MMPolicyInProcess
(
const
MMPolicyInProcess
&
)
=
delete
;
MMPolicyInProcess
&
operator
=
(
const
MMPolicyInProcess
&
)
=
delete
;
MMPolicyInProcess
(
MMPolicyInProcess
&
&
aOther
)
:
mBase
(
nullptr
)
mReservationSize
(
0
)
mCommitOffset
(
0
)
{
*
this
=
std
:
:
move
(
aOther
)
;
}
MMPolicyInProcess
&
operator
=
(
MMPolicyInProcess
&
&
aOther
)
{
mBase
=
aOther
.
mBase
;
aOther
.
mBase
=
nullptr
;
mCommitOffset
=
aOther
.
mCommitOffset
;
aOther
.
mCommitOffset
=
0
;
mReservationSize
=
aOther
.
mReservationSize
;
aOther
.
mReservationSize
=
0
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mBase
;
}
bool
ShouldUnhookUponDestruction
(
)
const
{
return
true
;
}
#
if
defined
(
_M_IX86
)
bool
WriteAtomic
(
void
*
aDestPtr
const
uint16_t
aValue
)
const
{
*
static_cast
<
uint16_t
*
>
(
aDestPtr
)
=
aValue
;
return
true
;
}
#
endif
bool
Protect
(
void
*
aVAddress
size_t
aSize
uint32_t
aProtFlags
uint32_t
*
aPrevProtFlags
)
const
{
return
ProtectInternal
(
:
:
VirtualProtect
aVAddress
aSize
aProtFlags
aPrevProtFlags
)
;
}
bool
FlushInstructionCache
(
)
const
{
return
!
!
:
:
FlushInstructionCache
(
:
:
GetCurrentProcess
(
)
nullptr
0
)
;
}
static
DWORD
GetTrampWriteProtFlags
(
)
{
return
PAGE_EXECUTE_READWRITE
;
}
#
if
defined
(
_M_X64
)
bool
IsTrampolineSpaceInLowest2GB
(
)
const
{
return
(
mBase
+
mReservationSize
)
<
=
reinterpret_cast
<
uint8_t
*
>
(
0x0000000080000000ULL
)
;
}
static
constexpr
bool
kSupportsUnwindInfo
=
true
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
LookupUnwindInfo
(
uintptr_t
aOrigFuncAddr
uint32_t
*
aOffsetFromBeginAddr
uint32_t
*
aOffsetToEndAddr
uintptr_t
*
aOrigImageBase
)
const
{
DWORD64
origImageBase
=
0
;
auto
origFuncEntry
=
RtlLookupFunctionEntry
(
aOrigFuncAddr
&
origImageBase
nullptr
)
;
if
(
!
origFuncEntry
)
{
return
nullptr
;
}
if
(
aOffsetFromBeginAddr
)
{
*
aOffsetFromBeginAddr
=
aOrigFuncAddr
-
(
origImageBase
+
origFuncEntry
-
>
BeginAddress
)
;
}
if
(
aOffsetToEndAddr
)
{
*
aOffsetToEndAddr
=
(
origImageBase
+
origFuncEntry
-
>
EndAddress
)
-
aOrigFuncAddr
;
}
if
(
aOrigImageBase
)
{
*
aOrigImageBase
=
origImageBase
;
}
return
reinterpret_cast
<
const
UnwindInfo
*
>
(
origImageBase
+
origFuncEntry
-
>
UnwindData
)
-
>
Copy
(
)
;
}
bool
AddFunctionTable
(
uintptr_t
aFunctionTable
uint32_t
aEntryCount
uintptr_t
aBaseAddress
)
const
{
return
bool
(
RtlAddFunctionTable
(
reinterpret_cast
<
PRUNTIME_FUNCTION
>
(
aFunctionTable
)
aEntryCount
aBaseAddress
)
)
;
}
#
endif
protected
:
uint8_t
*
GetLocalView
(
)
const
{
return
mBase
;
}
uintptr_t
GetRemoteView
(
)
const
{
return
reinterpret_cast
<
uintptr_t
>
(
mBase
)
;
}
uint32_t
Reserve
(
const
uint32_t
aSize
const
Maybe
<
Span
<
const
uint8_t
>
>
&
aBounds
)
{
if
(
!
aSize
)
{
return
0
;
}
if
(
mBase
)
{
MOZ_ASSERT
(
mReservationSize
>
=
aSize
)
;
return
mReservationSize
;
}
mReservationSize
=
ComputeAllocationSize
(
aSize
)
;
auto
reserveFn
=
[
]
(
HANDLE
aProcess
PVOID
aBase
uint32_t
aSize
)
-
>
PVOID
{
return
:
:
VirtualAlloc
(
aBase
aSize
MEM_RESERVE
PAGE_NOACCESS
)
;
}
;
auto
reserveWithinRangeFn
=
[
]
(
HANDLE
aProcess
uint32_t
aSize
const
uint8_t
*
aRangeMin
const
uint8_t
*
aRangeMaxExcl
)
-
>
Maybe
<
PVOID
>
{
static
const
StaticDynamicallyLinkedFunctionPtr
<
decltype
(
&
:
:
VirtualAlloc2
)
>
pVirtualAlloc2
(
L
"
kernelbase
.
dll
"
"
VirtualAlloc2
"
)
;
if
(
!
pVirtualAlloc2
)
{
return
Nothing
(
)
;
}
MEM_ADDRESS_REQUIREMENTS
memReq
=
{
const_cast
<
uint8_t
*
>
(
aRangeMin
)
const_cast
<
uint8_t
*
>
(
aRangeMaxExcl
-
1
)
}
;
MEM_EXTENDED_PARAMETER
memParam
=
{
}
;
memParam
.
Type
=
MemExtendedParameterAddressRequirements
;
memParam
.
Pointer
=
&
memReq
;
return
Some
(
pVirtualAlloc2
(
aProcess
nullptr
aSize
MEM_RESERVE
PAGE_NOACCESS
&
memParam
1
)
)
;
}
;
mBase
=
static_cast
<
uint8_t
*
>
(
MMPolicyBase
:
:
Reserve
(
:
:
GetCurrentProcess
(
)
mReservationSize
reserveFn
reserveWithinRangeFn
aBounds
)
)
;
if
(
!
mBase
)
{
return
0
;
}
return
mReservationSize
;
}
bool
MaybeCommitNextPage
(
const
uint32_t
aRequestedOffset
const
uint32_t
aRequestedLength
)
{
if
(
!
(
*
this
)
)
{
return
false
;
}
uint32_t
limit
=
aRequestedOffset
+
aRequestedLength
-
1
;
if
(
limit
<
mCommitOffset
)
{
return
true
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mCommitOffset
<
mReservationSize
)
;
if
(
mCommitOffset
>
=
mReservationSize
)
{
return
false
;
}
PVOID
local
=
:
:
VirtualAlloc
(
mBase
+
mCommitOffset
GetPageSize
(
)
MEM_COMMIT
PAGE_EXECUTE_READ
)
;
if
(
!
local
)
{
return
false
;
}
mCommitOffset
+
=
GetPageSize
(
)
;
return
true
;
}
private
:
uint8_t
*
mBase
;
uint32_t
mReservationSize
;
uint32_t
mCommitOffset
;
}
;
class
MMPolicyInProcessEarlyStage
:
public
MMPolicyInProcessPrimitive
{
public
:
struct
Kernel32Exports
{
decltype
(
&
:
:
FlushInstructionCache
)
mFlushInstructionCache
;
decltype
(
&
:
:
GetModuleHandleW
)
mGetModuleHandleW
;
decltype
(
&
:
:
GetSystemInfo
)
mGetSystemInfo
;
decltype
(
&
:
:
VirtualProtect
)
mVirtualProtect
;
}
;
private
:
static
DWORD
GetPageSize
(
const
Kernel32Exports
&
aK32Exports
)
{
SYSTEM_INFO
sysInfo
;
aK32Exports
.
mGetSystemInfo
(
&
sysInfo
)
;
return
sysInfo
.
dwPageSize
;
}
const
Kernel32Exports
&
mK32Exports
;
const
DWORD
mPageSize
;
public
:
explicit
MMPolicyInProcessEarlyStage
(
const
Kernel32Exports
&
aK32Exports
)
:
mK32Exports
(
aK32Exports
)
mPageSize
(
GetPageSize
(
mK32Exports
)
)
{
}
DWORD
GetPageSize
(
)
const
{
return
mPageSize
;
}
bool
Protect
(
void
*
aVAddress
size_t
aSize
uint32_t
aProtFlags
uint32_t
*
aPrevProtFlags
)
const
{
return
ProtectInternal
(
mK32Exports
.
mVirtualProtect
aVAddress
aSize
aProtFlags
aPrevProtFlags
)
;
}
bool
FlushInstructionCache
(
)
const
{
const
HANDLE
kCurrentProcess
=
reinterpret_cast
<
HANDLE
>
(
-
1
)
;
return
!
!
mK32Exports
.
mFlushInstructionCache
(
kCurrentProcess
nullptr
0
)
;
}
}
;
class
MMPolicyOutOfProcess
:
public
MMPolicyBase
{
public
:
typedef
MMPolicyOutOfProcess
MMPolicyT
;
explicit
MMPolicyOutOfProcess
(
HANDLE
aProcess
)
:
mProcess
(
nullptr
)
mMapping
(
nullptr
)
mLocalView
(
nullptr
)
mRemoteView
(
nullptr
)
mReservationSize
(
0
)
mCommitOffset
(
0
)
{
MOZ_ASSERT
(
aProcess
)
;
:
:
DuplicateHandle
(
:
:
GetCurrentProcess
(
)
aProcess
:
:
GetCurrentProcess
(
)
&
mProcess
kAccessFlags
FALSE
0
)
;
MOZ_ASSERT
(
mProcess
)
;
}
explicit
MMPolicyOutOfProcess
(
DWORD
aPid
)
:
mProcess
(
:
:
OpenProcess
(
kAccessFlags
FALSE
aPid
)
)
mMapping
(
nullptr
)
mLocalView
(
nullptr
)
mRemoteView
(
nullptr
)
mReservationSize
(
0
)
mCommitOffset
(
0
)
{
MOZ_ASSERT
(
mProcess
)
;
}
~
MMPolicyOutOfProcess
(
)
{
Destroy
(
)
;
}
MMPolicyOutOfProcess
(
MMPolicyOutOfProcess
&
&
aOther
)
:
mProcess
(
nullptr
)
mMapping
(
nullptr
)
mLocalView
(
nullptr
)
mRemoteView
(
nullptr
)
mReservationSize
(
0
)
mCommitOffset
(
0
)
{
*
this
=
std
:
:
move
(
aOther
)
;
}
MMPolicyOutOfProcess
(
const
MMPolicyOutOfProcess
&
aOther
)
=
delete
;
MMPolicyOutOfProcess
&
operator
=
(
const
MMPolicyOutOfProcess
&
)
=
delete
;
MMPolicyOutOfProcess
&
operator
=
(
MMPolicyOutOfProcess
&
&
aOther
)
{
Destroy
(
)
;
mProcess
=
aOther
.
mProcess
;
aOther
.
mProcess
=
nullptr
;
mMapping
=
aOther
.
mMapping
;
aOther
.
mMapping
=
nullptr
;
mLocalView
=
aOther
.
mLocalView
;
aOther
.
mLocalView
=
nullptr
;
mRemoteView
=
aOther
.
mRemoteView
;
aOther
.
mRemoteView
=
nullptr
;
mReservationSize
=
aOther
.
mReservationSize
;
aOther
.
mReservationSize
=
0
;
mCommitOffset
=
aOther
.
mCommitOffset
;
aOther
.
mCommitOffset
=
0
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
mProcess
&
&
mMapping
&
&
mLocalView
&
&
mRemoteView
;
}
bool
ShouldUnhookUponDestruction
(
)
const
{
return
false
;
}
bool
Read
(
void
*
aToPtr
const
void
*
aFromPtr
size_t
aLen
)
const
{
MOZ_ASSERT
(
mProcess
)
;
if
(
!
mProcess
)
{
return
false
;
}
SIZE_T
numBytes
=
0
;
BOOL
ok
=
:
:
ReadProcessMemory
(
mProcess
aFromPtr
aToPtr
aLen
&
numBytes
)
;
return
ok
&
&
numBytes
=
=
aLen
;
}
size_t
TryRead
(
void
*
aToPtr
const
void
*
aFromPtr
size_t
aLen
)
const
{
MOZ_ASSERT
(
mProcess
)
;
if
(
!
mProcess
)
{
return
0
;
}
uint32_t
pageSize
=
GetPageSize
(
)
;
uintptr_t
pageMask
=
pageSize
-
1
;
auto
rangeStart
=
reinterpret_cast
<
uintptr_t
>
(
aFromPtr
)
;
auto
rangeEnd
=
rangeStart
+
aLen
;
while
(
rangeStart
<
rangeEnd
)
{
SIZE_T
numBytes
=
0
;
BOOL
ok
=
:
:
ReadProcessMemory
(
mProcess
aFromPtr
aToPtr
rangeEnd
-
rangeStart
&
numBytes
)
;
if
(
ok
)
{
return
numBytes
;
}
if
(
rangeEnd
&
pageMask
)
{
rangeEnd
&
=
~
pageMask
;
}
else
{
rangeEnd
-
=
pageSize
;
}
}
return
0
;
}
bool
Write
(
void
*
aToPtr
const
void
*
aFromPtr
size_t
aLen
)
const
{
MOZ_ASSERT
(
mProcess
)
;
if
(
!
mProcess
)
{
return
false
;
}
SIZE_T
numBytes
=
0
;
BOOL
ok
=
:
:
WriteProcessMemory
(
mProcess
aToPtr
aFromPtr
aLen
&
numBytes
)
;
return
ok
&
&
numBytes
=
=
aLen
;
}
bool
Protect
(
void
*
aVAddress
size_t
aSize
uint32_t
aProtFlags
uint32_t
*
aPrevProtFlags
)
const
{
MOZ_ASSERT
(
mProcess
)
;
if
(
!
mProcess
)
{
return
false
;
}
MOZ_ASSERT
(
aPrevProtFlags
)
;
BOOL
ok
=
:
:
VirtualProtectEx
(
mProcess
aVAddress
aSize
aProtFlags
reinterpret_cast
<
PDWORD
>
(
aPrevProtFlags
)
)
;
if
(
!
ok
&
&
aPrevProtFlags
)
{
*
aPrevProtFlags
=
0
;
}
return
!
!
ok
;
}
bool
IsPageAccessible
(
uintptr_t
aVAddress
)
const
{
MEMORY_BASIC_INFORMATION
mbi
;
SIZE_T
result
=
nt
:
:
VirtualQueryEx
(
mProcess
reinterpret_cast
<
LPCVOID
>
(
aVAddress
)
&
mbi
sizeof
(
mbi
)
)
;
return
result
&
&
mbi
.
AllocationProtect
&
&
mbi
.
State
=
=
MEM_COMMIT
&
&
mbi
.
Protect
!
=
PAGE_NOACCESS
;
}
bool
FlushInstructionCache
(
)
const
{
return
!
!
:
:
FlushInstructionCache
(
mProcess
nullptr
0
)
;
}
static
DWORD
GetTrampWriteProtFlags
(
)
{
return
PAGE_READWRITE
;
}
#
if
defined
(
_M_X64
)
bool
IsTrampolineSpaceInLowest2GB
(
)
const
{
return
(
GetRemoteView
(
)
+
mReservationSize
)
<
=
0x0000000080000000ULL
;
}
static
constexpr
bool
kSupportsUnwindInfo
=
false
;
inline
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
LookupUnwindInfo
(
uintptr_t
aOrigFuncAddr
uint32_t
*
aOffsetFromBeginAddr
uint32_t
*
aOffsetToEndAddr
uintptr_t
*
aOrigImageBase
)
const
{
return
nullptr
;
}
inline
bool
AddFunctionTable
(
uintptr_t
aNewTable
uint32_t
aEntryCount
uintptr_t
aBaseAddress
)
const
{
return
false
;
}
#
endif
protected
:
uint8_t
*
GetLocalView
(
)
const
{
return
mLocalView
;
}
uintptr_t
GetRemoteView
(
)
const
{
return
reinterpret_cast
<
uintptr_t
>
(
mRemoteView
)
;
}
uint32_t
Reserve
(
const
uint32_t
aSize
const
Maybe
<
Span
<
const
uint8_t
>
>
&
aBounds
)
{
if
(
!
aSize
|
|
!
mProcess
)
{
SetLastDetourError
(
MMPOLICY_RESERVE_INVALIDARG
)
;
return
0
;
}
if
(
mRemoteView
)
{
MOZ_ASSERT
(
mReservationSize
>
=
aSize
)
;
SetLastDetourError
(
MMPOLICY_RESERVE_ZERO_RESERVATIONSIZE
)
;
return
mReservationSize
;
}
mReservationSize
=
ComputeAllocationSize
(
aSize
)
;
mMapping
=
:
:
CreateFileMappingW
(
INVALID_HANDLE_VALUE
nullptr
PAGE_EXECUTE_READWRITE
|
SEC_RESERVE
0
mReservationSize
nullptr
)
;
if
(
!
mMapping
)
{
SetLastDetourError
(
MMPOLICY_RESERVE_CREATEFILEMAPPING
:
:
GetLastError
(
)
)
;
return
0
;
}
mLocalView
=
static_cast
<
uint8_t
*
>
(
:
:
MapViewOfFile
(
mMapping
FILE_MAP_WRITE
0
0
0
)
)
;
if
(
!
mLocalView
)
{
SetLastDetourError
(
MMPOLICY_RESERVE_MAPVIEWOFFILE
:
:
GetLastError
(
)
)
;
return
0
;
}
auto
reserveFn
=
[
mapping
=
mMapping
]
(
HANDLE
aProcess
PVOID
aBase
uint32_t
aSize
)
-
>
PVOID
{
return
mozilla
:
:
MapRemoteViewOfFile
(
mapping
aProcess
0ULL
aBase
0
0
PAGE_EXECUTE_READ
)
;
}
;
auto
reserveWithinRangeFn
=
[
mapping
=
mMapping
]
(
HANDLE
aProcess
uint32_t
aSize
const
uint8_t
*
aRangeMin
const
uint8_t
*
aRangeMaxExcl
)
-
>
Maybe
<
PVOID
>
{
static
const
StaticDynamicallyLinkedFunctionPtr
<
decltype
(
&
:
:
MapViewOfFile3
)
>
pMapViewOfFile3
(
L
"
kernelbase
.
dll
"
"
MapViewOfFile3
"
)
;
if
(
!
pMapViewOfFile3
)
{
return
Nothing
(
)
;
}
MEM_ADDRESS_REQUIREMENTS
memReq
=
{
const_cast
<
uint8_t
*
>
(
aRangeMin
)
const_cast
<
uint8_t
*
>
(
aRangeMaxExcl
-
1
)
}
;
MEM_EXTENDED_PARAMETER
memParam
=
{
}
;
memParam
.
Type
=
MemExtendedParameterAddressRequirements
;
memParam
.
Pointer
=
&
memReq
;
return
Some
(
pMapViewOfFile3
(
mapping
aProcess
nullptr
0
aSize
0
PAGE_EXECUTE_READ
&
memParam
1
)
)
;
}
;
mRemoteView
=
MMPolicyBase
:
:
Reserve
(
mProcess
mReservationSize
reserveFn
reserveWithinRangeFn
aBounds
)
;
if
(
!
mRemoteView
)
{
return
0
;
}
return
mReservationSize
;
}
bool
MaybeCommitNextPage
(
const
uint32_t
aRequestedOffset
const
uint32_t
aRequestedLength
)
{
if
(
!
(
*
this
)
)
{
return
false
;
}
uint32_t
limit
=
aRequestedOffset
+
aRequestedLength
-
1
;
if
(
limit
<
mCommitOffset
)
{
return
true
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mCommitOffset
<
mReservationSize
)
;
if
(
mCommitOffset
>
=
mReservationSize
)
{
return
false
;
}
PVOID
local
=
:
:
VirtualAlloc
(
mLocalView
+
mCommitOffset
GetPageSize
(
)
MEM_COMMIT
PAGE_READWRITE
)
;
if
(
!
local
)
{
return
false
;
}
PVOID
remote
=
:
:
VirtualAllocEx
(
mProcess
static_cast
<
uint8_t
*
>
(
mRemoteView
)
+
mCommitOffset
GetPageSize
(
)
MEM_COMMIT
PAGE_EXECUTE_READ
)
;
if
(
!
remote
)
{
return
false
;
}
mCommitOffset
+
=
GetPageSize
(
)
;
return
true
;
}
private
:
void
Destroy
(
)
{
if
(
mLocalView
)
{
:
:
UnmapViewOfFile
(
mLocalView
)
;
mLocalView
=
nullptr
;
}
if
(
mMapping
)
{
:
:
CloseHandle
(
mMapping
)
;
mMapping
=
nullptr
;
}
if
(
mProcess
)
{
:
:
CloseHandle
(
mProcess
)
;
mProcess
=
nullptr
;
}
}
private
:
HANDLE
mProcess
;
HANDLE
mMapping
;
uint8_t
*
mLocalView
;
PVOID
mRemoteView
;
uint32_t
mReservationSize
;
uint32_t
mCommitOffset
;
static
const
DWORD
kAccessFlags
=
PROCESS_QUERY_INFORMATION
|
PROCESS_VM_OPERATION
|
PROCESS_VM_READ
|
PROCESS_VM_WRITE
;
}
;
}
}
#
endif
