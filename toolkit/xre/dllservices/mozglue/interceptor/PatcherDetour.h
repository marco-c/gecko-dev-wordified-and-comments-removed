#
ifndef
mozilla_interceptor_PatcherDetour_h
#
define
mozilla_interceptor_PatcherDetour_h
#
if
defined
(
_M_ARM64
)
#
include
"
mozilla
/
interceptor
/
Arm64
.
h
"
#
endif
#
include
<
utility
>
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
NativeNt
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
interceptor
/
PatcherBase
.
h
"
#
include
"
mozilla
/
interceptor
/
Trampoline
.
h
"
#
include
"
mozilla
/
interceptor
/
VMSharingPolicies
.
h
"
#
define
COPY_CODES
(
NBYTES
)
\
do
{
\
tramp
.
CopyCodes
(
origBytes
.
GetAddress
(
)
NBYTES
)
;
\
origBytes
+
=
NBYTES
;
\
}
while
(
0
)
namespace
mozilla
{
namespace
interceptor
{
enum
class
DetourFlags
:
uint32_t
{
eDefault
=
0
eEnable10BytePatch
=
1
eTestOnlyForceShortPatch
=
2
eDontResolveRedirection
=
4
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
DetourFlags
)
template
<
typename
MMPolicyT
>
class
WindowsDllDetourPatcherPrimitive
{
protected
:
#
if
defined
(
_M_ARM64
)
static
const
uint32_t
kLdrX16Plus8
=
0x58000050U
;
#
endif
static
void
ApplyDefaultPatch
(
WritableTargetFunction
<
MMPolicyT
>
&
target
intptr_t
aDest
)
{
#
if
defined
(
_M_IX86
)
target
.
WriteByte
(
0xe9
)
;
target
.
WriteDisp32
(
aDest
)
;
while
(
target
.
GetOffset
(
)
<
target
.
GetNumBytes
(
)
)
{
target
.
WriteByte
(
0x90
)
;
}
#
elif
defined
(
_M_X64
)
target
.
WriteByte
(
0x49
)
;
target
.
WriteByte
(
0xbb
)
;
target
.
WritePointer
(
aDest
)
;
target
.
WriteByte
(
0x41
)
;
target
.
WriteByte
(
0xff
)
;
target
.
WriteByte
(
0xe3
)
;
while
(
target
.
GetOffset
(
)
<
target
.
GetNumBytes
(
)
)
{
target
.
WriteByte
(
0x90
)
;
}
#
elif
defined
(
_M_ARM64
)
target
.
WriteLong
(
kLdrX16Plus8
)
;
target
.
WriteLong
(
arm64
:
:
BuildUnconditionalBranchToRegister
(
16
)
)
;
target
.
WritePointer
(
aDest
)
;
#
else
#
error
"
Unsupported
processor
architecture
"
#
endif
}
public
:
constexpr
static
uint32_t
GetWorstCaseRequiredBytesToPatch
(
)
{
#
if
defined
(
_M_IX86
)
return
5
;
#
elif
defined
(
_M_X64
)
return
13
;
#
elif
defined
(
_M_ARM64
)
return
16
;
#
else
#
error
"
Unsupported
processor
architecture
"
#
endif
}
WindowsDllDetourPatcherPrimitive
(
)
=
default
;
WindowsDllDetourPatcherPrimitive
(
const
WindowsDllDetourPatcherPrimitive
&
)
=
delete
;
WindowsDllDetourPatcherPrimitive
(
WindowsDllDetourPatcherPrimitive
&
&
)
=
delete
;
WindowsDllDetourPatcherPrimitive
&
operator
=
(
const
WindowsDllDetourPatcherPrimitive
&
)
=
delete
;
WindowsDllDetourPatcherPrimitive
&
operator
=
(
WindowsDllDetourPatcherPrimitive
&
&
)
=
delete
;
bool
AddIrreversibleHook
(
const
MMPolicyT
&
aMMPolicy
FARPROC
aTargetFn
intptr_t
aHookDest
)
{
ReadOnlyTargetFunction
<
MMPolicyT
>
targetReadOnly
(
aMMPolicy
aTargetFn
)
;
WritableTargetFunction
<
MMPolicyT
>
targetWritable
(
targetReadOnly
.
Promote
(
GetWorstCaseRequiredBytesToPatch
(
)
)
)
;
if
(
!
targetWritable
)
{
return
false
;
}
ApplyDefaultPatch
(
targetWritable
aHookDest
)
;
return
targetWritable
.
Commit
(
)
;
}
}
;
template
<
typename
VMPolicy
>
class
WindowsDllDetourPatcher
final
:
public
WindowsDllDetourPatcherPrimitive
<
typename
VMPolicy
:
:
MMPolicyT
>
public
WindowsDllPatcherBase
<
VMPolicy
>
{
using
MMPolicyT
=
typename
VMPolicy
:
:
MMPolicyT
;
using
TrampPoolT
=
typename
VMPolicy
:
:
PoolType
;
using
PrimitiveT
=
WindowsDllDetourPatcherPrimitive
<
MMPolicyT
>
;
Maybe
<
DetourFlags
>
mFlags
;
public
:
template
<
typename
.
.
.
Args
>
explicit
WindowsDllDetourPatcher
(
Args
&
&
.
.
.
aArgs
)
:
WindowsDllPatcherBase
<
VMPolicy
>
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
{
}
~
WindowsDllDetourPatcher
(
)
{
Clear
(
)
;
}
WindowsDllDetourPatcher
(
const
WindowsDllDetourPatcher
&
)
=
delete
;
WindowsDllDetourPatcher
(
WindowsDllDetourPatcher
&
&
)
=
delete
;
WindowsDllDetourPatcher
&
operator
=
(
const
WindowsDllDetourPatcher
&
)
=
delete
;
WindowsDllDetourPatcher
&
operator
=
(
WindowsDllDetourPatcher
&
&
)
=
delete
;
void
Clear
(
)
{
if
(
!
this
-
>
mVMPolicy
.
ShouldUnhookUponDestruction
(
)
)
{
return
;
}
#
if
defined
(
_M_IX86
)
size_t
nBytes
=
1
+
sizeof
(
intptr_t
)
;
#
elif
defined
(
_M_X64
)
size_t
nBytes
=
2
+
sizeof
(
intptr_t
)
;
#
elif
defined
(
_M_ARM64
)
size_t
nBytes
=
2
*
sizeof
(
uint32_t
)
+
sizeof
(
uintptr_t
)
;
#
else
#
error
"
Unknown
processor
type
"
#
endif
const
auto
&
tramps
=
this
-
>
mVMPolicy
.
Items
(
)
;
for
(
auto
&
&
tramp
:
tramps
)
{
Maybe
<
uintptr_t
>
instance
=
tramp
.
ReadEncodedPointer
(
)
;
if
(
!
instance
)
{
continue
;
}
if
(
instance
.
value
(
)
!
=
reinterpret_cast
<
uintptr_t
>
(
this
)
)
{
continue
;
}
auto
clearInstance
=
MakeScopeExit
(
[
&
tramp
]
(
)
-
>
void
{
tramp
.
Rewind
(
)
;
tramp
.
WriteEncodedPointer
(
nullptr
)
;
}
)
;
Maybe
<
uintptr_t
>
interceptedFn
=
tramp
.
ReadEncodedPointer
(
)
;
if
(
!
interceptedFn
)
{
continue
;
}
WritableTargetFunction
<
MMPolicyT
>
origBytes
(
this
-
>
mVMPolicy
interceptedFn
.
value
(
)
nBytes
)
;
if
(
!
origBytes
)
{
continue
;
}
#
if
defined
(
_M_IX86
)
|
|
defined
(
_M_X64
)
Maybe
<
uint8_t
>
maybeOpcode1
=
origBytes
.
ReadByte
(
)
;
if
(
!
maybeOpcode1
)
{
continue
;
}
uint8_t
opcode1
=
maybeOpcode1
.
value
(
)
;
#
if
defined
(
_M_IX86
)
MOZ_ASSERT
(
opcode1
=
=
0xE9
)
;
if
(
opcode1
!
=
0xE9
)
{
continue
;
}
intptr_t
startOfTrampInstructions
=
static_cast
<
intptr_t
>
(
tramp
.
GetCurrentRemoteAddress
(
)
)
;
origBytes
.
WriteDisp32
(
startOfTrampInstructions
)
;
if
(
!
origBytes
)
{
continue
;
}
origBytes
.
Commit
(
)
;
#
elif
defined
(
_M_X64
)
if
(
opcode1
=
=
0x49
)
{
if
(
!
Clear13BytePatch
(
origBytes
tramp
.
GetCurrentRemoteAddress
(
)
)
)
{
continue
;
}
}
else
if
(
opcode1
=
=
0xB8
)
{
if
(
!
Clear10BytePatch
(
origBytes
)
)
{
continue
;
}
}
else
if
(
opcode1
=
=
0x48
)
{
if
(
!
ClearTrampolinePatch
(
origBytes
tramp
.
GetCurrentRemoteAddress
(
)
)
)
{
continue
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
patch
!
"
)
;
continue
;
}
#
endif
#
elif
defined
(
_M_ARM64
)
Maybe
<
uint32_t
>
inst1
=
origBytes
.
ReadLong
(
)
;
if
(
!
inst1
)
{
continue
;
}
if
(
inst1
.
value
(
)
=
=
this
-
>
kLdrX16Plus8
)
{
if
(
!
Clear16BytePatch
(
origBytes
tramp
.
GetCurrentRemoteAddress
(
)
)
)
{
continue
;
}
}
else
if
(
arm64
:
:
IsUnconditionalBranchImm
(
inst1
.
value
(
)
)
)
{
if
(
!
Clear4BytePatch
(
inst1
.
value
(
)
origBytes
)
)
{
continue
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
patch
!
"
)
;
continue
;
}
#
else
#
error
"
Unknown
processor
type
"
#
endif
}
this
-
>
mVMPolicy
.
Clear
(
)
;
}
#
if
defined
(
_M_X64
)
bool
Clear13BytePatch
(
WritableTargetFunction
<
MMPolicyT
>
&
aOrigBytes
const
uintptr_t
aResetToAddress
)
{
Maybe
<
uint8_t
>
maybeOpcode2
=
aOrigBytes
.
ReadByte
(
)
;
if
(
!
maybeOpcode2
)
{
return
false
;
}
uint8_t
opcode2
=
maybeOpcode2
.
value
(
)
;
if
(
opcode2
!
=
0xBB
)
{
return
false
;
}
aOrigBytes
.
WritePointer
(
aResetToAddress
)
;
if
(
!
aOrigBytes
)
{
return
false
;
}
return
aOrigBytes
.
Commit
(
)
;
}
bool
ClearTrampolinePatch
(
WritableTargetFunction
<
MMPolicyT
>
&
aOrigBytes
const
uintptr_t
aPtrToResetToAddress
)
{
Maybe
<
uint8_t
>
maybeOpcode2
=
aOrigBytes
.
ReadByte
(
)
;
if
(
!
maybeOpcode2
)
{
return
false
;
}
uint8_t
opcode2
=
maybeOpcode2
.
value
(
)
;
if
(
opcode2
!
=
0xB8
)
{
return
false
;
}
auto
oldPtr
=
*
(
reinterpret_cast
<
const
uintptr_t
*
>
(
aPtrToResetToAddress
)
)
;
aOrigBytes
.
WritePointer
(
oldPtr
)
;
if
(
!
aOrigBytes
)
{
return
false
;
}
return
aOrigBytes
.
Commit
(
)
;
}
bool
Clear10BytePatch
(
WritableTargetFunction
<
MMPolicyT
>
&
aOrigBytes
)
{
Maybe
<
uint32_t
>
maybePtr32
=
aOrigBytes
.
ReadLong
(
)
;
if
(
!
maybePtr32
)
{
return
false
;
}
uint32_t
ptr32
=
maybePtr32
.
value
(
)
;
if
(
ptr32
&
0x80000000
)
{
return
false
;
}
uintptr_t
trampPtr
=
ptr32
;
WritableTargetFunction
<
MMPolicyT
>
writableIntermediate
(
this
-
>
mVMPolicy
trampPtr
-
sizeof
(
uintptr_t
)
13
+
sizeof
(
uintptr_t
)
)
;
if
(
!
writableIntermediate
)
{
return
false
;
}
Maybe
<
uintptr_t
>
stubTramp
=
writableIntermediate
.
ReadEncodedPtr
(
)
;
if
(
!
stubTramp
|
|
!
stubTramp
.
value
(
)
)
{
return
false
;
}
Maybe
<
uint8_t
>
maybeOpcode1
=
writableIntermediate
.
ReadByte
(
)
;
if
(
!
maybeOpcode1
)
{
return
false
;
}
uint8_t
opcode1
=
maybeOpcode1
.
value
(
)
;
if
(
opcode1
!
=
0x49
)
{
return
false
;
}
return
Clear13BytePatch
(
writableIntermediate
stubTramp
.
value
(
)
)
;
}
#
endif
#
if
defined
(
_M_ARM64
)
bool
Clear4BytePatch
(
const
uint32_t
aBranchImm
WritableTargetFunction
<
MMPolicyT
>
&
aOrigBytes
)
{
MOZ_ASSERT
(
arm64
:
:
IsUnconditionalBranchImm
(
aBranchImm
)
)
;
arm64
:
:
LoadOrBranch
decoded
=
arm64
:
:
BUncondImmDecode
(
aOrigBytes
.
GetCurrentAddress
(
)
-
sizeof
(
uint32_t
)
aBranchImm
)
;
uintptr_t
trampPtr
=
decoded
.
mAbsAddress
;
size_t
trampLen
=
16
+
sizeof
(
uintptr_t
)
;
WritableTargetFunction
<
MMPolicyT
>
writableIntermediate
(
this
-
>
mVMPolicy
trampPtr
-
sizeof
(
uintptr_t
)
trampLen
)
;
if
(
!
writableIntermediate
)
{
return
false
;
}
Maybe
<
uintptr_t
>
stubTramp
=
writableIntermediate
.
ReadEncodedPtr
(
)
;
if
(
!
stubTramp
|
|
!
stubTramp
.
value
(
)
)
{
return
false
;
}
Maybe
<
uint32_t
>
inst1
=
writableIntermediate
.
ReadLong
(
)
;
if
(
!
inst1
|
|
inst1
.
value
(
)
!
=
this
-
>
kLdrX16Plus8
)
{
return
false
;
}
return
Clear16BytePatch
(
writableIntermediate
stubTramp
.
value
(
)
)
;
}
bool
Clear16BytePatch
(
WritableTargetFunction
<
MMPolicyT
>
&
aOrigBytes
const
uintptr_t
aResetToAddress
)
{
Maybe
<
uint32_t
>
inst2
=
aOrigBytes
.
ReadLong
(
)
;
if
(
!
inst2
)
{
return
false
;
}
if
(
inst2
.
value
(
)
!
=
arm64
:
:
BuildUnconditionalBranchToRegister
(
16
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
patch
!
"
)
;
return
false
;
}
aOrigBytes
.
WritePointer
(
aResetToAddress
)
;
aOrigBytes
.
Commit
(
)
;
return
true
;
}
#
endif
void
Init
(
DetourFlags
aFlags
=
DetourFlags
:
:
eDefault
)
{
if
(
Initialized
(
)
)
{
return
;
}
#
if
defined
(
_M_X64
)
if
(
aFlags
&
DetourFlags
:
:
eTestOnlyForceShortPatch
)
{
aFlags
|
=
DetourFlags
:
:
eEnable10BytePatch
;
}
#
endif
mFlags
=
Some
(
aFlags
)
;
}
bool
Initialized
(
)
const
{
return
mFlags
.
isSome
(
)
;
}
bool
AddHook
(
FARPROC
aTargetFn
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
ReadOnlyTargetFunction
<
MMPolicyT
>
target
(
(
mFlags
.
value
(
)
&
DetourFlags
:
:
eDontResolveRedirection
)
?
ReadOnlyTargetFunction
<
MMPolicyT
>
(
this
-
>
mVMPolicy
reinterpret_cast
<
uintptr_t
>
(
aTargetFn
)
)
:
this
-
>
ResolveRedirectedAddress
(
aTargetFn
)
)
;
TrampPoolT
*
trampPool
=
nullptr
;
#
if
defined
(
_M_ARM64
)
Trampoline
<
MMPolicyT
>
tramp
(
nullptr
)
;
#
else
Maybe
<
TrampPoolT
>
maybeTrampPool
=
DoReserve
(
)
;
MOZ_ASSERT
(
maybeTrampPool
)
;
if
(
!
maybeTrampPool
)
{
return
false
;
}
trampPool
=
maybeTrampPool
.
ptr
(
)
;
Maybe
<
Trampoline
<
MMPolicyT
>
>
maybeTramp
(
trampPool
-
>
GetNextTrampoline
(
)
)
;
if
(
!
maybeTramp
)
{
this
-
>
SetLastDetourError
(
DetourResultCode
:
:
DETOUR_PATCHER_NEXT_TRAMPOLINE_ERROR
)
;
return
false
;
}
Trampoline
<
MMPolicyT
>
tramp
(
std
:
:
move
(
maybeTramp
.
ref
(
)
)
)
;
#
endif
CreateTrampoline
(
target
trampPool
tramp
aHookDest
aOrigFunc
)
;
if
(
!
*
aOrigFunc
)
{
return
false
;
}
return
true
;
}
private
:
static
uint32_t
GetDefaultPivotDistance
(
)
{
#
if
defined
(
_M_ARM64
)
return
0x08000000U
;
#
elif
defined
(
_M_IX86
)
|
|
defined
(
_M_X64
)
return
0x80000000U
;
#
else
#
error
"
Not
defined
for
this
processor
arch
"
#
endif
}
Maybe
<
TrampPoolT
>
ReserveForModule
(
HMODULE
aModule
)
{
nt
:
:
PEHeaders
moduleHeaders
(
aModule
)
;
if
(
!
moduleHeaders
)
{
this
-
>
SetLastDetourError
(
DetourResultCode
:
:
DETOUR_PATCHER_RESERVE_FOR_MODULE_PE_ERROR
)
;
return
Nothing
(
)
;
}
Maybe
<
Span
<
const
uint8_t
>
>
textSectionInfo
=
moduleHeaders
.
GetTextSectionInfo
(
)
;
if
(
!
textSectionInfo
)
{
this
-
>
SetLastDetourError
(
DetourResultCode
:
:
DETOUR_PATCHER_RESERVE_FOR_MODULE_TEXT_ERROR
)
;
return
Nothing
(
)
;
}
const
uint8_t
*
median
=
textSectionInfo
.
value
(
)
.
data
(
)
+
(
textSectionInfo
.
value
(
)
.
LengthBytes
(
)
/
2
)
;
Maybe
<
TrampPoolT
>
maybeTrampPool
=
this
-
>
mVMPolicy
.
Reserve
(
reinterpret_cast
<
uintptr_t
>
(
median
)
GetDefaultPivotDistance
(
)
)
;
if
(
!
maybeTrampPool
)
{
this
-
>
SetLastDetourError
(
DetourResultCode
:
:
DETOUR_PATCHER_RESERVE_FOR_MODULE_RESERVE_ERROR
)
;
}
return
maybeTrampPool
;
}
Maybe
<
TrampPoolT
>
DoReserve
(
HMODULE
aModule
=
nullptr
)
{
if
(
aModule
)
{
return
ReserveForModule
(
aModule
)
;
}
uintptr_t
pivot
=
0
;
uint32_t
distance
=
0
;
#
if
defined
(
_M_X64
)
if
(
mFlags
.
value
(
)
&
DetourFlags
:
:
eEnable10BytePatch
)
{
pivot
=
0x40000000U
;
distance
=
0x40000000U
;
}
#
endif
Maybe
<
TrampPoolT
>
maybeTrampPool
=
this
-
>
mVMPolicy
.
Reserve
(
pivot
distance
)
;
#
if
defined
(
NIGHTLY_BUILD
)
if
(
!
maybeTrampPool
&
&
this
-
>
GetLastDetourError
(
)
.
isNothing
(
)
)
{
this
-
>
SetLastDetourError
(
DetourResultCode
:
:
DETOUR_PATCHER_DO_RESERVE_ERROR
)
;
}
#
endif
return
maybeTrampPool
;
}
protected
:
#
if
!
defined
(
_M_ARM64
)
const
static
int
kPageSize
=
4096
;
static
const
BYTE
kMaskHighNibble
=
0xF0
;
static
const
BYTE
kRexOpcode
=
0x40
;
static
const
BYTE
kMaskRexW
=
0x08
;
static
const
BYTE
kMaskRexR
=
0x04
;
static
const
BYTE
kMaskRexX
=
0x02
;
static
const
BYTE
kMaskRexB
=
0x01
;
static
const
BYTE
kRegFieldShift
=
3
;
static
const
BYTE
kMaskMod
=
0xC0
;
static
const
BYTE
kMaskReg
=
0x38
;
static
const
BYTE
kMaskRm
=
0x07
;
static
const
BYTE
kRmNeedSib
=
0x04
;
static
const
BYTE
kModReg
=
0xC0
;
static
const
BYTE
kModDisp32
=
0x80
;
static
const
BYTE
kModDisp8
=
0x40
;
static
const
BYTE
kModNoRegDisp
=
0x00
;
static
const
BYTE
kRmNoRegDispDisp32
=
0x05
;
static
const
BYTE
kMaskSibScale
=
0xC0
;
static
const
BYTE
kMaskSibIndex
=
0x38
;
static
const
BYTE
kMaskSibBase
=
0x07
;
static
const
BYTE
kSibBaseEbp
=
0x05
;
static
const
BYTE
kRegAx
=
0x0
;
static
const
BYTE
kRegCx
=
0x1
;
static
const
BYTE
kRegDx
=
0x2
;
static
const
BYTE
kRegBx
=
0x3
;
static
const
BYTE
kRegSp
=
0x4
;
static
const
BYTE
kRegBp
=
0x5
;
static
const
BYTE
kRegSi
=
0x6
;
static
const
BYTE
kRegDi
=
0x7
;
static
const
int
kModOperand64
=
-
2
;
static
const
int
kModUnknown
=
-
1
;
int
CountModRmSib
(
const
ReadOnlyTargetFunction
<
MMPolicyT
>
&
aModRm
BYTE
*
aSubOpcode
=
nullptr
)
{
int
numBytes
=
1
;
switch
(
*
aModRm
&
kMaskMod
)
{
case
kModReg
:
return
numBytes
;
case
kModDisp8
:
numBytes
+
=
1
;
break
;
case
kModDisp32
:
numBytes
+
=
4
;
break
;
case
kModNoRegDisp
:
if
(
(
*
aModRm
&
kMaskRm
)
=
=
kRmNoRegDispDisp32
)
{
#
if
defined
(
_M_X64
)
if
(
aSubOpcode
)
{
*
aSubOpcode
=
(
*
aModRm
&
kMaskReg
)
>
>
kRegFieldShift
;
}
return
kModOperand64
;
#
else
numBytes
+
=
4
;
#
endif
}
else
if
(
(
(
*
aModRm
&
kMaskRm
)
=
=
kRmNeedSib
&
&
(
*
(
aModRm
+
1
)
&
kMaskSibBase
)
=
=
kSibBaseEbp
)
)
{
numBytes
+
=
4
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Impossible
value
for
modr
/
m
byte
mod
bits
"
)
;
return
kModUnknown
;
}
if
(
(
*
aModRm
&
kMaskRm
)
=
=
kRmNeedSib
)
{
numBytes
+
=
1
;
}
if
(
aSubOpcode
)
{
*
aSubOpcode
=
(
*
aModRm
&
kMaskReg
)
>
>
kRegFieldShift
;
}
return
numBytes
;
}
#
if
defined
(
_M_X64
)
enum
class
JumpType
{
Je
Jne
Jae
Jmp
Call
}
;
static
bool
GenerateJump
(
Trampoline
<
MMPolicyT
>
&
aTramp
uintptr_t
aAbsTargetAddress
const
JumpType
aType
)
{
if
(
aType
=
=
JumpType
:
:
Call
)
{
aTramp
.
WriteByte
(
0xff
)
;
aTramp
.
WriteByte
(
0x15
)
;
aTramp
.
WriteInteger
(
2
)
;
aTramp
.
WriteByte
(
0xeb
)
;
aTramp
.
WriteByte
(
8
)
;
aTramp
.
WritePointer
(
aAbsTargetAddress
)
;
return
!
!
aTramp
;
}
if
(
aType
=
=
JumpType
:
:
Je
)
{
aTramp
.
WriteByte
(
0x75
)
;
aTramp
.
WriteByte
(
14
)
;
}
else
if
(
aType
=
=
JumpType
:
:
Jne
)
{
aTramp
.
WriteByte
(
0x74
)
;
aTramp
.
WriteByte
(
14
)
;
}
else
if
(
aType
=
=
JumpType
:
:
Jae
)
{
aTramp
.
WriteByte
(
0x72
)
;
aTramp
.
WriteByte
(
14
)
;
}
aTramp
.
WriteByte
(
0xff
)
;
aTramp
.
WriteByte
(
0x25
)
;
aTramp
.
WriteInteger
(
0
)
;
aTramp
.
WritePointer
(
aAbsTargetAddress
)
;
return
!
!
aTramp
;
}
#
endif
enum
ePrefixGroupBits
{
eNoPrefixes
=
0
ePrefixGroup1
=
(
1
<
<
0
)
ePrefixGroup2
=
(
1
<
<
1
)
ePrefixGroup3
=
(
1
<
<
2
)
ePrefixGroup4
=
(
1
<
<
3
)
}
;
int
CountPrefixBytes
(
const
ReadOnlyTargetFunction
<
MMPolicyT
>
&
aBytes
unsigned
char
*
aOutGroupBits
)
{
unsigned
char
&
groupBits
=
*
aOutGroupBits
;
groupBits
=
eNoPrefixes
;
int
index
=
0
;
while
(
true
)
{
switch
(
aBytes
[
index
]
)
{
case
0xF0
:
case
0xF2
:
case
0xF3
:
if
(
groupBits
&
ePrefixGroup1
)
{
return
-
1
;
}
groupBits
|
=
ePrefixGroup1
;
+
+
index
;
break
;
case
0x2E
:
case
0x36
:
case
0x3E
:
case
0x64
:
case
0x65
:
if
(
groupBits
&
ePrefixGroup2
)
{
return
-
1
;
}
groupBits
|
=
ePrefixGroup2
;
+
+
index
;
break
;
case
0x66
:
if
(
groupBits
&
ePrefixGroup3
)
{
return
-
1
;
}
groupBits
|
=
ePrefixGroup3
;
+
+
index
;
break
;
case
0x67
:
if
(
groupBits
&
ePrefixGroup4
)
{
return
-
1
;
}
groupBits
|
=
ePrefixGroup4
;
+
+
index
;
break
;
default
:
return
index
;
}
}
}
BYTE
BuildModRmByte
(
BYTE
aModBits
BYTE
aReg
BYTE
aRm
)
{
MOZ_ASSERT
(
(
aRm
&
kMaskRm
)
=
=
aRm
)
;
MOZ_ASSERT
(
(
aModBits
&
kMaskMod
)
=
=
aModBits
)
;
MOZ_ASSERT
(
(
(
aReg
<
<
kRegFieldShift
)
&
kMaskReg
)
=
=
(
aReg
<
<
kRegFieldShift
)
)
;
return
aModBits
|
(
aReg
<
<
kRegFieldShift
)
|
aRm
;
}
#
endif
bool
PatchIfTargetIsRecognizedTrampoline
(
Trampoline
<
MMPolicyT
>
&
aTramp
ReadOnlyTargetFunction
<
MMPolicyT
>
&
aOriginalFn
intptr_t
aDest
void
*
*
aOutTramp
)
{
#
if
defined
(
_M_X64
)
if
(
(
aOriginalFn
[
0
]
=
=
0x48
)
&
&
(
aOriginalFn
[
1
]
=
=
0xB8
)
&
&
(
(
aOriginalFn
[
10
]
=
=
0xFF
&
&
aOriginalFn
[
11
]
=
=
0xE0
)
|
|
(
aOriginalFn
[
10
]
=
=
0x50
&
&
aOriginalFn
[
11
]
=
=
0xC3
)
)
)
{
uintptr_t
originalTarget
=
(
aOriginalFn
+
2
)
.
template
ChasePointer
<
uintptr_t
>
(
)
;
WritableTargetFunction
<
MMPolicyT
>
target
(
aOriginalFn
.
Promote
(
8
2
)
)
;
if
(
!
target
)
{
return
false
;
}
target
.
WritePointer
(
aDest
)
;
if
(
!
target
.
Commit
(
)
)
{
return
false
;
}
aTramp
.
WritePointer
(
originalTarget
)
;
if
(
!
aTramp
)
{
return
false
;
}
*
aOutTramp
=
reinterpret_cast
<
void
*
>
(
originalTarget
)
;
return
true
;
}
#
endif
return
false
;
}
#
if
defined
(
_M_ARM64
)
bool
Apply4BytePatch
(
TrampPoolT
*
aTrampPool
void
*
aTrampPtr
WritableTargetFunction
<
MMPolicyT
>
&
target
intptr_t
aDest
)
{
MOZ_ASSERT
(
aTrampPool
)
;
if
(
!
aTrampPool
)
{
return
false
;
}
uintptr_t
hookDest
=
arm64
:
:
MakeVeneer
(
*
aTrampPool
aTrampPtr
aDest
)
;
if
(
!
hookDest
)
{
return
false
;
}
Maybe
<
uint32_t
>
branchImm
=
arm64
:
:
BuildUnconditionalBranchImm
(
target
.
GetCurrentAddress
(
)
hookDest
)
;
if
(
!
branchImm
)
{
return
false
;
}
target
.
WriteLong
(
branchImm
.
value
(
)
)
;
return
true
;
}
#
endif
#
if
defined
(
_M_X64
)
bool
Apply10BytePatch
(
TrampPoolT
*
aTrampPool
void
*
aTrampPtr
WritableTargetFunction
<
MMPolicyT
>
&
target
intptr_t
aDest
)
{
Maybe
<
Trampoline
<
MMPolicyT
>
>
maybeCallTramp
(
aTrampPool
-
>
GetNextTrampoline
(
)
)
;
if
(
!
maybeCallTramp
)
{
return
false
;
}
Trampoline
<
MMPolicyT
>
callTramp
(
std
:
:
move
(
maybeCallTramp
.
ref
(
)
)
)
;
callTramp
.
WriteEncodedPointer
(
nullptr
)
;
callTramp
.
WriteEncodedPointer
(
aTrampPtr
)
;
callTramp
.
StartExecutableCode
(
)
;
callTramp
.
WriteByte
(
0x49
)
;
callTramp
.
WriteByte
(
0xbb
)
;
callTramp
.
WritePointer
(
aDest
)
;
callTramp
.
WriteByte
(
0x41
)
;
callTramp
.
WriteByte
(
0xff
)
;
callTramp
.
WriteByte
(
0xe3
)
;
void
*
callTrampStart
=
callTramp
.
EndExecutableCode
(
)
;
if
(
!
callTrampStart
)
{
return
false
;
}
target
.
WriteByte
(
0xB8
)
;
MOZ_ASSERT
(
!
(
reinterpret_cast
<
uintptr_t
>
(
callTrampStart
)
&
(
~
0x7FFFFFFFULL
)
)
)
;
target
.
WriteLong
(
static_cast
<
uint32_t
>
(
reinterpret_cast
<
uintptr_t
>
(
callTrampStart
)
&
0x7FFFFFFFU
)
)
;
target
.
WriteByte
(
0x48
)
;
target
.
WriteByte
(
0x63
)
;
target
.
WriteByte
(
BuildModRmByte
(
kModReg
kRegAx
kRegAx
)
)
;
target
.
WriteByte
(
0xFF
)
;
target
.
WriteByte
(
BuildModRmByte
(
kModReg
4
kRegAx
)
)
;
while
(
target
.
GetOffset
(
)
<
target
.
GetNumBytes
(
)
)
{
target
.
WriteByte
(
0x90
)
;
}
return
true
;
}
#
endif
void
CreateTrampoline
(
ReadOnlyTargetFunction
<
MMPolicyT
>
&
origBytes
TrampPoolT
*
aTrampPool
Trampoline
<
MMPolicyT
>
&
aTramp
intptr_t
aDest
void
*
*
aOutTramp
)
{
*
aOutTramp
=
nullptr
;
Trampoline
<
MMPolicyT
>
&
tramp
=
aTramp
;
if
(
!
tramp
)
{
this
-
>
SetLastDetourError
(
DetourResultCode
:
:
DETOUR_PATCHER_INVALID_TRAMPOLINE
)
;
return
;
}
tramp
.
WriteEncodedPointer
(
this
)
;
if
(
!
tramp
)
{
this
-
>
SetLastDetourError
(
DetourResultCode
:
:
DETOUR_PATCHER_WRITE_POINTER_ERROR
)
;
return
;
}
auto
clearInstanceOnFailure
=
MakeScopeExit
(
[
this
aOutTramp
&
tramp
&
origBytes
]
(
)
-
>
void
{
if
(
*
aOutTramp
)
{
return
;
}
tramp
.
Rewind
(
)
;
tramp
.
WriteEncodedPointer
(
nullptr
)
;
#
if
defined
(
NIGHTLY_BUILD
)
origBytes
.
Rewind
(
)
;
this
-
>
SetLastDetourError
(
DetourResultCode
:
:
DETOUR_PATCHER_CREATE_TRAMPOLINE_ERROR
)
;
DetourError
&
lastError
=
*
this
-
>
mVMPolicy
.
mLastError
;
size_t
bytesToCapture
=
std
:
:
min
(
ArrayLength
(
lastError
.
mOrigBytes
)
static_cast
<
size_t
>
(
PrimitiveT
:
:
GetWorstCaseRequiredBytesToPatch
(
)
)
)
;
#
if
defined
(
_M_ARM64
)
size_t
numInstructionsToCapture
=
bytesToCapture
/
sizeof
(
uint32_t
)
;
auto
origBytesDst
=
reinterpret_cast
<
uint32_t
*
>
(
lastError
.
mOrigBytes
)
;
for
(
size_t
i
=
0
;
i
<
numInstructionsToCapture
;
+
+
i
)
{
origBytesDst
[
i
]
=
origBytes
.
ReadNextInstruction
(
)
;
}
#
else
for
(
size_t
i
=
0
;
i
<
bytesToCapture
;
+
+
i
)
{
lastError
.
mOrigBytes
[
i
]
=
origBytes
[
i
]
;
}
#
endif
#
else
Unused
<
<
this
;
Unused
<
<
origBytes
;
#
endif
}
)
;
tramp
.
WritePointer
(
origBytes
.
AsEncodedPtr
(
)
)
;
if
(
!
tramp
)
{
return
;
}
if
(
PatchIfTargetIsRecognizedTrampoline
(
tramp
origBytes
aDest
aOutTramp
)
)
{
return
;
}
tramp
.
StartExecutableCode
(
)
;
constexpr
uint32_t
kWorstCaseBytesRequired
=
PrimitiveT
:
:
GetWorstCaseRequiredBytesToPatch
(
)
;
#
if
defined
(
_M_IX86
)
int
pJmp32
=
-
1
;
while
(
origBytes
.
GetOffset
(
)
<
kWorstCaseBytesRequired
)
{
unsigned
char
prefixGroups
;
int
numPrefixBytes
=
CountPrefixBytes
(
origBytes
&
prefixGroups
)
;
if
(
numPrefixBytes
<
0
|
|
(
prefixGroups
&
(
ePrefixGroup3
|
ePrefixGroup4
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
origBytes
+
=
numPrefixBytes
;
if
(
*
origBytes
>
=
0x88
&
&
*
origBytes
<
=
0x8B
)
{
+
+
origBytes
;
int
len
=
CountModRmSib
(
origBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
MOV
opcode
sequence
"
)
;
return
;
}
origBytes
+
=
len
;
}
else
if
(
*
origBytes
=
=
0x0f
&
&
(
origBytes
[
1
]
=
=
0x10
|
|
origBytes
[
1
]
=
=
0x11
)
)
{
origBytes
+
=
2
;
int
len
=
CountModRmSib
(
origBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
MOV
opcode
sequence
"
)
;
return
;
}
origBytes
+
=
len
;
}
else
if
(
*
origBytes
=
=
0xA1
)
{
origBytes
+
=
5
;
}
else
if
(
*
origBytes
=
=
0xB8
)
{
origBytes
+
=
5
;
}
else
if
(
*
origBytes
=
=
0x33
&
&
(
origBytes
[
1
]
&
kMaskMod
)
=
=
kModReg
)
{
origBytes
+
=
2
;
}
else
if
(
(
*
origBytes
&
0xf8
)
=
=
0x40
)
{
origBytes
+
=
1
;
}
else
if
(
*
origBytes
=
=
0x83
)
{
uint8_t
mod
=
static_cast
<
uint8_t
>
(
origBytes
[
1
]
)
&
kMaskMod
;
uint8_t
rm
=
static_cast
<
uint8_t
>
(
origBytes
[
1
]
)
&
kMaskRm
;
if
(
mod
=
=
kModReg
)
{
origBytes
+
=
3
;
}
else
if
(
mod
=
=
kModDisp8
&
&
rm
!
=
kRmNeedSib
)
{
origBytes
+
=
4
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
bit
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x68
)
{
origBytes
+
=
5
;
}
else
if
(
(
*
origBytes
&
0xf0
)
=
=
0x50
)
{
+
+
origBytes
;
}
else
if
(
*
origBytes
=
=
0x6A
)
{
origBytes
+
=
2
;
}
else
if
(
*
origBytes
=
=
0xe9
)
{
pJmp32
=
origBytes
.
GetOffset
(
)
;
origBytes
+
=
5
;
}
else
if
(
*
origBytes
=
=
0xff
&
&
origBytes
[
1
]
=
=
0x25
)
{
origBytes
+
=
6
;
}
else
if
(
*
origBytes
=
=
0xc2
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
NS_WARNING
(
"
Cannot
hook
method
-
-
RET
opcode
found
"
)
;
#
endif
return
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
tramp
.
CopyFrom
(
origBytes
.
GetBaseAddress
(
)
origBytes
.
GetOffset
(
)
)
;
if
(
!
tramp
)
{
return
;
}
#
elif
defined
(
_M_X64
)
bool
foundJmp
=
false
;
bool
use10BytePatch
=
(
mFlags
.
value
(
)
&
DetourFlags
:
:
eTestOnlyForceShortPatch
)
=
=
DetourFlags
:
:
eTestOnlyForceShortPatch
;
const
uint32_t
bytesRequired
=
use10BytePatch
?
10
:
kWorstCaseBytesRequired
;
while
(
origBytes
.
GetOffset
(
)
<
bytesRequired
)
{
if
(
foundJmp
)
{
if
(
*
origBytes
=
=
0x90
|
|
*
origBytes
=
=
0xcc
)
{
+
+
origBytes
;
continue
;
}
if
(
aTrampPool
&
&
aTrampPool
-
>
IsInLowest2GB
(
)
&
&
origBytes
.
GetOffset
(
)
>
=
10
)
{
use10BytePatch
=
true
;
break
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Opcode
sequence
includes
commands
after
JMP
"
)
;
return
;
}
if
(
*
origBytes
=
=
0x0f
)
{
COPY_CODES
(
1
)
;
if
(
*
origBytes
=
=
0x1f
)
{
COPY_CODES
(
1
)
;
if
(
(
*
origBytes
&
0xc0
)
=
=
0x40
&
&
(
*
origBytes
&
0x7
)
=
=
0x04
)
{
COPY_CODES
(
3
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x05
)
{
COPY_CODES
(
1
)
;
}
else
if
(
*
origBytes
=
=
0x10
|
|
*
origBytes
=
=
0x11
)
{
COPY_CODES
(
1
)
;
int
nModRmSibBytes
=
CountModRmSib
(
origBytes
)
;
if
(
nModRmSibBytes
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
else
{
COPY_CODES
(
nModRmSibBytes
)
;
}
}
else
if
(
*
origBytes
>
=
0x83
&
&
*
origBytes
<
=
0x85
)
{
const
JumpType
kJumpTypes
[
]
=
{
JumpType
:
:
Jae
JumpType
:
:
Je
JumpType
:
:
Jne
}
;
auto
jumpType
=
kJumpTypes
[
*
origBytes
-
0x83
]
;
+
+
origBytes
;
-
-
tramp
;
if
(
!
GenerateJump
(
tramp
origBytes
.
ReadDisp32AsAbsolute
(
)
jumpType
)
)
{
return
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
>
=
0x88
&
&
*
origBytes
<
=
0x8B
)
{
COPY_CODES
(
1
)
;
int
len
=
CountModRmSib
(
origBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
MOV
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
len
)
;
}
else
if
(
*
origBytes
=
=
0x40
&
&
origBytes
[
1
]
=
=
0x38
&
&
(
origBytes
[
2
]
&
(
kMaskMod
|
kMaskRm
)
)
=
=
(
kModNoRegDisp
|
kRmNoRegDispDisp32
)
)
{
int
reg
=
origBytes
[
2
]
&
kMaskReg
;
origBytes
+
=
3
;
tramp
.
WriteByte
(
0x49
)
;
tramp
.
WriteByte
(
0x53
)
;
uintptr_t
absAddr
=
origBytes
.
ReadDisp32AsAbsolute
(
)
;
tramp
.
WriteByte
(
0x49
)
;
tramp
.
WriteByte
(
0xbb
)
;
tramp
.
WritePointer
(
absAddr
)
;
tramp
.
WriteByte
(
0x41
)
;
tramp
.
WriteByte
(
0x38
)
;
tramp
.
WriteByte
(
kModNoRegDisp
|
reg
|
kRegBx
)
;
tramp
.
WriteByte
(
0x49
)
;
tramp
.
WriteByte
(
0x5b
)
;
}
else
if
(
*
origBytes
=
=
0x40
|
|
*
origBytes
=
=
0x41
)
{
COPY_CODES
(
1
)
;
if
(
(
*
origBytes
&
0xf0
)
=
=
0x50
)
{
COPY_CODES
(
1
)
;
}
else
if
(
*
origBytes
>
=
0xb8
&
&
*
origBytes
<
=
0xbf
)
{
COPY_CODES
(
5
)
;
}
else
if
(
*
origBytes
=
=
0x8b
&
&
(
origBytes
[
1
]
&
kMaskMod
)
=
=
kModReg
)
{
COPY_CODES
(
2
)
;
}
else
if
(
*
origBytes
=
=
0xf7
&
&
(
origBytes
[
1
]
&
(
kMaskMod
|
kMaskReg
)
)
=
=
(
kModReg
|
(
0
<
<
kRegFieldShift
)
)
)
{
COPY_CODES
(
6
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x44
)
{
COPY_CODES
(
1
)
;
if
(
*
origBytes
=
=
0x89
)
{
COPY_CODES
(
1
)
;
int
len
=
CountModRmSib
(
origBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
len
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x45
)
{
COPY_CODES
(
1
)
;
if
(
*
origBytes
=
=
0x33
)
{
COPY_CODES
(
2
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
(
*
origBytes
&
0xfa
)
=
=
0x48
)
{
COPY_CODES
(
1
)
;
if
(
*
origBytes
=
=
0x81
&
&
(
origBytes
[
1
]
&
0xf8
)
=
=
0xe8
)
{
COPY_CODES
(
6
)
;
}
else
if
(
*
origBytes
=
=
0x83
&
&
(
origBytes
[
1
]
&
0xf8
)
=
=
0xe8
)
{
COPY_CODES
(
3
)
;
}
else
if
(
*
origBytes
=
=
0x83
&
&
(
origBytes
[
1
]
&
(
kMaskMod
|
kMaskReg
)
)
=
=
kModReg
)
{
COPY_CODES
(
3
)
;
}
else
if
(
*
origBytes
=
=
0x83
&
&
(
origBytes
[
1
]
&
0xf8
)
=
=
0x60
)
{
COPY_CODES
(
5
)
;
}
else
if
(
*
origBytes
=
=
0x2b
&
&
(
origBytes
[
1
]
&
kMaskMod
)
=
=
kModReg
)
{
COPY_CODES
(
2
)
;
}
else
if
(
*
origBytes
=
=
0x85
)
{
if
(
(
origBytes
[
1
]
&
0xc0
)
=
=
0xc0
)
{
COPY_CODES
(
2
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
(
*
origBytes
&
0xfd
)
=
=
0x89
)
{
BYTE
reg
;
int
len
=
CountModRmSib
(
origBytes
+
1
&
reg
)
;
if
(
len
<
0
)
{
MOZ_ASSERT
(
len
=
=
kModOperand64
)
;
if
(
len
!
=
kModOperand64
)
{
return
;
}
origBytes
+
=
2
;
uintptr_t
absAddr
=
origBytes
.
ReadDisp32AsAbsolute
(
)
;
if
(
reg
=
=
kRegAx
)
{
tramp
.
WriteByte
(
0xa1
)
;
tramp
.
WritePointer
(
absAddr
)
;
}
else
{
tramp
.
WriteByte
(
0xb8
+
reg
)
;
tramp
.
WritePointer
(
absAddr
)
;
tramp
.
WriteByte
(
0x48
)
;
tramp
.
WriteByte
(
0x8b
)
;
tramp
.
WriteByte
(
BuildModRmByte
(
kModNoRegDisp
reg
reg
)
)
;
}
}
else
{
COPY_CODES
(
len
+
1
)
;
}
}
else
if
(
(
*
origBytes
&
0xf8
)
=
=
0xb8
)
{
COPY_CODES
(
9
)
;
}
else
if
(
*
origBytes
=
=
0xc7
)
{
if
(
origBytes
[
1
]
=
=
0x44
)
{
COPY_CODES
(
8
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0xff
)
{
if
(
(
origBytes
[
1
]
&
0xc0
)
=
=
0x0
&
&
(
origBytes
[
1
]
&
0x07
)
=
=
0x5
&
&
(
(
origBytes
[
1
]
&
0x38
)
=
=
0x20
|
|
(
origBytes
[
1
]
&
0x38
)
=
=
0x10
)
)
{
origBytes
+
=
2
;
-
-
tramp
;
foundJmp
=
(
origBytes
[
1
]
&
0x38
)
=
=
0x20
;
if
(
!
GenerateJump
(
tramp
origBytes
.
ChasePointerFromDisp
(
)
foundJmp
?
JumpType
:
:
Jmp
:
JumpType
:
:
Call
)
)
{
return
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x8d
)
{
if
(
(
origBytes
[
1
]
&
kMaskMod
)
=
=
0x0
&
&
(
origBytes
[
1
]
&
kMaskRm
)
=
=
0x5
)
{
BYTE
reg
=
(
origBytes
[
1
]
&
kMaskReg
)
>
>
kRegFieldShift
;
origBytes
+
=
2
;
uintptr_t
absAddr
=
origBytes
.
ReadDisp32AsAbsolute
(
)
;
tramp
.
WriteByte
(
0xb8
+
reg
)
;
tramp
.
WritePointer
(
absAddr
)
;
}
else
{
int
len
=
CountModRmSib
(
origBytes
+
1
)
;
MOZ_ASSERT
(
len
>
0
)
;
COPY_CODES
(
len
+
1
)
;
}
}
else
if
(
*
origBytes
=
=
0x63
&
&
(
origBytes
[
1
]
&
kMaskMod
)
=
=
kModReg
)
{
COPY_CODES
(
2
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x66
)
{
COPY_CODES
(
1
)
;
if
(
*
origBytes
>
=
0x88
&
&
*
origBytes
<
=
0x8B
)
{
unsigned
char
b
=
origBytes
[
1
]
;
if
(
(
(
b
&
0xc0
)
=
=
0xc0
)
|
|
(
(
(
b
&
0xc0
)
=
=
0x00
)
&
&
(
(
b
&
0x07
)
!
=
0x04
)
&
&
(
(
b
&
0x07
)
!
=
0x05
)
)
)
{
COPY_CODES
(
2
)
;
}
else
if
(
(
b
&
0xc0
)
=
=
0x40
)
{
if
(
(
b
&
0x07
)
=
=
0x04
)
{
COPY_CODES
(
4
)
;
}
else
{
COPY_CODES
(
3
)
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
MOV
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x44
&
&
origBytes
[
1
]
=
=
0x89
)
{
COPY_CODES
(
2
)
;
int
len
=
CountModRmSib
(
origBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
len
)
;
}
}
else
if
(
(
*
origBytes
&
0xf0
)
=
=
0x50
)
{
COPY_CODES
(
1
)
;
}
else
if
(
*
origBytes
=
=
0x65
)
{
if
(
origBytes
[
1
]
=
=
0x48
&
&
(
origBytes
[
2
]
>
=
0x88
&
&
origBytes
[
2
]
<
=
0x8b
)
)
{
COPY_CODES
(
3
)
;
int
len
=
CountModRmSib
(
origBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
len
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x80
&
&
origBytes
[
1
]
=
=
0x3d
)
{
origBytes
+
=
2
;
tramp
.
WriteByte
(
0x49
)
;
tramp
.
WriteByte
(
0x53
)
;
uintptr_t
absAddr
=
origBytes
.
ReadDisp32AsAbsolute
(
)
;
tramp
.
WriteByte
(
0x49
)
;
tramp
.
WriteByte
(
0xbb
)
;
tramp
.
WritePointer
(
absAddr
)
;
tramp
.
WriteByte
(
0x41
)
;
tramp
.
WriteByte
(
0x80
)
;
tramp
.
WriteByte
(
0x3b
)
;
COPY_CODES
(
1
)
;
tramp
.
WriteByte
(
0x49
)
;
tramp
.
WriteByte
(
0x5b
)
;
}
else
if
(
*
origBytes
=
=
0x90
)
{
COPY_CODES
(
1
)
;
}
else
if
(
(
*
origBytes
&
0xf8
)
=
=
0xb8
)
{
COPY_CODES
(
5
)
;
}
else
if
(
*
origBytes
=
=
0x31
|
|
*
origBytes
=
=
0x33
)
{
COPY_CODES
(
2
)
;
}
else
if
(
*
origBytes
=
=
0xf6
)
{
BYTE
subOpcode
=
0
;
int
nModRmSibBytes
=
CountModRmSib
(
origBytes
+
1
&
subOpcode
)
;
if
(
nModRmSibBytes
<
0
|
|
subOpcode
!
=
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
2
+
nModRmSibBytes
)
;
}
else
if
(
*
origBytes
=
=
0x85
)
{
int
nModRmSibBytes
=
CountModRmSib
(
origBytes
+
1
)
;
if
(
nModRmSibBytes
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
1
+
nModRmSibBytes
)
;
}
else
if
(
*
origBytes
=
=
0xd1
&
&
(
origBytes
[
1
]
&
kMaskMod
)
=
=
kModReg
)
{
COPY_CODES
(
2
)
;
}
else
if
(
*
origBytes
=
=
0x83
&
&
(
origBytes
[
1
]
&
kMaskMod
)
=
=
kModReg
)
{
COPY_CODES
(
3
)
;
}
else
if
(
*
origBytes
=
=
0xc3
)
{
COPY_CODES
(
1
)
;
}
else
if
(
*
origBytes
=
=
0xcc
)
{
COPY_CODES
(
1
)
;
}
else
if
(
*
origBytes
=
=
0xe8
|
|
*
origBytes
=
=
0xe9
)
{
foundJmp
=
*
origBytes
=
=
0xe9
;
+
+
origBytes
;
if
(
!
GenerateJump
(
tramp
origBytes
.
ReadDisp32AsAbsolute
(
)
foundJmp
?
JumpType
:
:
Jmp
:
JumpType
:
:
Call
)
)
{
return
;
}
}
else
if
(
*
origBytes
>
=
0x73
&
&
*
origBytes
<
=
0x75
)
{
const
JumpType
kJumpTypes
[
]
=
{
JumpType
:
:
Jae
JumpType
:
:
Je
JumpType
:
:
Jne
}
;
auto
jumpType
=
kJumpTypes
[
*
origBytes
-
0x73
]
;
uint8_t
offset
=
origBytes
[
1
]
;
origBytes
+
=
2
;
if
(
!
GenerateJump
(
tramp
origBytes
.
OffsetToAbsolute
(
offset
)
jumpType
)
)
{
return
;
}
}
else
if
(
*
origBytes
=
=
0xff
)
{
uint8_t
mod
=
origBytes
[
1
]
&
kMaskMod
;
uint8_t
reg
=
(
origBytes
[
1
]
&
kMaskReg
)
>
>
kRegFieldShift
;
uint8_t
rm
=
origBytes
[
1
]
&
kMaskRm
;
if
(
mod
=
=
kModReg
&
&
(
reg
=
=
0
|
|
reg
=
=
1
|
|
reg
=
=
2
|
|
reg
=
=
6
)
)
{
COPY_CODES
(
2
)
;
}
else
if
(
mod
=
=
kModNoRegDisp
&
&
reg
=
=
2
&
&
rm
=
=
kRmNoRegDispDisp32
)
{
origBytes
+
=
2
;
if
(
!
GenerateJump
(
tramp
origBytes
.
ChasePointerFromDisp
(
)
JumpType
:
:
Call
)
)
{
return
;
}
}
else
if
(
reg
=
=
4
)
{
if
(
mod
=
=
kModNoRegDisp
&
&
rm
=
=
kRmNoRegDispDisp32
)
{
foundJmp
=
true
;
origBytes
+
=
2
;
uintptr_t
jmpDest
=
origBytes
.
ChasePointerFromDisp
(
)
;
if
(
!
GenerateJump
(
tramp
jmpDest
JumpType
:
:
Jmp
)
)
{
return
;
}
}
else
{
int
len
=
CountModRmSib
(
origBytes
+
1
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
len
+
1
)
;
foundJmp
=
true
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
*
origBytes
=
=
0x83
&
&
(
origBytes
[
1
]
&
0xf8
)
=
=
0x60
)
{
COPY_CODES
(
5
)
;
}
else
if
(
*
origBytes
=
=
0xc6
)
{
int
len
=
CountModRmSib
(
origBytes
+
1
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
len
+
2
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
#
elif
defined
(
_M_ARM64
)
const
uint32_t
bytesRequiredFromDecode
=
(
mFlags
.
value
(
)
&
DetourFlags
:
:
eTestOnlyForceShortPatch
)
?
4
:
kWorstCaseBytesRequired
;
while
(
origBytes
.
GetOffset
(
)
<
bytesRequiredFromDecode
)
{
uintptr_t
curPC
=
origBytes
.
GetCurrentAbsolute
(
)
;
uint32_t
curInst
=
origBytes
.
ReadNextInstruction
(
)
;
Result
<
arm64
:
:
LoadOrBranch
arm64
:
:
PCRelCheckError
>
pcRelInfo
=
arm64
:
:
CheckForPCRel
(
curPC
curInst
)
;
if
(
pcRelInfo
.
isErr
(
)
)
{
if
(
pcRelInfo
.
unwrapErr
(
)
=
=
arm64
:
:
PCRelCheckError
:
:
InstructionNotPCRel
)
{
tramp
.
WriteInstruction
(
curInst
)
;
continue
;
}
if
(
!
origBytes
.
BackUpOneInstruction
(
)
)
{
return
;
}
break
;
}
tramp
.
WriteLoadLiteral
(
pcRelInfo
.
inspect
(
)
.
mAbsAddress
pcRelInfo
.
inspect
(
)
.
mDestReg
)
;
}
#
else
#
error
"
Unknown
processor
type
"
#
endif
if
(
origBytes
.
GetOffset
(
)
>
100
)
{
return
;
}
#
if
defined
(
_M_IX86
)
if
(
pJmp32
>
=
0
)
{
tramp
.
AdjustDisp32AtOffset
(
pJmp32
+
1
origBytes
.
GetBaseAddress
(
)
)
;
}
else
{
tramp
.
WriteByte
(
0xe9
)
;
tramp
.
WriteDisp32
(
origBytes
.
GetAddress
(
)
)
;
}
#
elif
defined
(
_M_X64
)
if
(
!
foundJmp
)
{
if
(
!
GenerateJump
(
tramp
origBytes
.
GetAddress
(
)
JumpType
:
:
Jmp
)
)
{
return
;
}
}
#
elif
defined
(
_M_ARM64
)
uint32_t
numBytesForPatching
=
tramp
.
GetCurrentExecutableCodeLen
(
)
;
if
(
!
numBytesForPatching
)
{
return
;
}
if
(
tramp
.
IsNull
(
)
)
{
HMODULE
targetModule
=
nullptr
;
if
(
numBytesForPatching
<
kWorstCaseBytesRequired
)
{
if
(
!
:
:
GetModuleHandleExW
(
GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
|
GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
reinterpret_cast
<
LPCWSTR
>
(
origBytes
.
GetBaseAddress
(
)
)
&
targetModule
)
)
{
return
;
}
}
Maybe
<
TrampPoolT
>
maybeTrampPool
=
DoReserve
(
targetModule
)
;
MOZ_ASSERT
(
maybeTrampPool
)
;
if
(
!
maybeTrampPool
)
{
return
;
}
Maybe
<
Trampoline
<
MMPolicyT
>
>
maybeRealTramp
(
maybeTrampPool
.
ref
(
)
.
GetNextTrampoline
(
)
)
;
if
(
!
maybeRealTramp
)
{
return
;
}
origBytes
.
Rewind
(
)
;
CreateTrampoline
(
origBytes
maybeTrampPool
.
ptr
(
)
maybeRealTramp
.
ref
(
)
aDest
aOutTramp
)
;
return
;
}
tramp
.
WriteLoadLiteral
(
origBytes
.
GetAddress
(
)
16
)
;
tramp
.
WriteInstruction
(
arm64
:
:
BuildUnconditionalBranchToRegister
(
16
)
)
;
#
else
#
error
"
Unsupported
processor
architecture
"
#
endif
void
*
trampPtr
=
tramp
.
EndExecutableCode
(
)
;
if
(
!
trampPtr
)
{
return
;
}
#
ifdef
_M_X64
if
constexpr
(
MMPolicyT
:
:
kSupportsUnwindInfo
)
{
DebugOnly
<
bool
>
unwindInfoAdded
=
tramp
.
AddUnwindInfo
(
origBytes
.
GetBaseAddress
(
)
origBytes
.
GetOffset
(
)
)
;
MOZ_ASSERT
(
unwindInfoAdded
)
;
}
#
endif
WritableTargetFunction
<
MMPolicyT
>
target
(
origBytes
.
Promote
(
)
)
;
if
(
!
target
)
{
return
;
}
do
{
#
if
defined
(
_M_X64
)
if
(
use10BytePatch
)
{
if
(
!
Apply10BytePatch
(
aTrampPool
trampPtr
target
aDest
)
)
{
return
;
}
break
;
}
#
elif
defined
(
_M_ARM64
)
if
(
numBytesForPatching
<
kWorstCaseBytesRequired
)
{
if
(
!
Apply4BytePatch
(
aTrampPool
trampPtr
target
aDest
)
)
{
return
;
}
break
;
}
#
endif
PrimitiveT
:
:
ApplyDefaultPatch
(
target
aDest
)
;
}
while
(
false
)
;
*
aOutTramp
=
trampPtr
;
if
(
!
target
.
Commit
(
)
)
{
*
aOutTramp
=
nullptr
;
}
}
}
;
}
}
#
endif
