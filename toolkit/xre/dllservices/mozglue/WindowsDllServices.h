#
ifndef
mozilla_glue_WindowsDllServices_h
#
define
mozilla_glue_WindowsDllServices_h
#
include
<
utility
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Authenticode
.
h
"
#
include
"
mozilla
/
LoaderAPIInterfaces
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
mozilla
/
WindowsDllBlocklist
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
prthread
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
endif
#
include
<
winternl
.
h
>
namespace
mozilla
{
namespace
glue
{
namespace
detail
{
class
DllServicesBase
:
public
Authenticode
{
public
:
virtual
void
DispatchDllLoadNotification
(
ModuleLoadInfo
&
&
aModLoadInfo
)
=
0
;
virtual
void
DispatchModuleLoadBacklogNotification
(
ModuleLoadInfoVec
&
&
aEvents
)
=
0
;
void
SetAuthenticodeImpl
(
Authenticode
*
aAuthenticode
)
{
mAuthenticode
=
aAuthenticode
;
}
void
SetWinLauncherServices
(
const
nt
:
:
WinLauncherServices
&
aWinLauncher
)
{
mWinLauncher
=
aWinLauncher
;
}
template
<
typename
.
.
.
Args
>
LauncherVoidResultWithLineInfo
InitDllBlocklistOOP
(
Args
&
&
.
.
.
aArgs
)
{
MOZ_RELEASE_ASSERT
(
mWinLauncher
.
mInitDllBlocklistOOP
)
;
return
mWinLauncher
.
mInitDllBlocklistOOP
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
void
HandleLauncherError
(
Args
&
&
.
.
.
aArgs
)
{
MOZ_RELEASE_ASSERT
(
mWinLauncher
.
mHandleLauncherError
)
;
mWinLauncher
.
mHandleLauncherError
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
nt
:
:
SharedSection
*
GetSharedSection
(
)
{
return
mWinLauncher
.
mSharedSection
;
}
#
if
defined
(
DEBUG
)
UniquePtr
<
wchar_t
[
]
>
GetBinaryOrgName
(
const
wchar_t
*
aFilePath
AuthenticodeFlags
aFlags
=
AuthenticodeFlags
:
:
Default
)
override
#
else
UniquePtr
<
wchar_t
[
]
>
GetBinaryOrgName
(
const
wchar_t
*
aFilePath
AuthenticodeFlags
aFlags
=
AuthenticodeFlags
:
:
Default
)
final
#
endif
{
if
(
!
mAuthenticode
)
{
return
nullptr
;
}
return
mAuthenticode
-
>
GetBinaryOrgName
(
aFilePath
aFlags
)
;
}
virtual
void
DisableFull
(
)
{
DllBlocklist_SetFullDllServices
(
nullptr
)
;
}
DllServicesBase
(
const
DllServicesBase
&
)
=
delete
;
DllServicesBase
(
DllServicesBase
&
&
)
=
delete
;
DllServicesBase
&
operator
=
(
const
DllServicesBase
&
)
=
delete
;
DllServicesBase
&
operator
=
(
DllServicesBase
&
&
)
=
delete
;
protected
:
DllServicesBase
(
)
:
mAuthenticode
(
nullptr
)
{
}
virtual
~
DllServicesBase
(
)
=
default
;
void
EnableFull
(
)
{
DllBlocklist_SetFullDllServices
(
this
)
;
}
void
EnableBasic
(
)
{
DllBlocklist_SetBasicDllServices
(
this
)
;
}
private
:
Authenticode
*
mAuthenticode
;
nt
:
:
WinLauncherServices
mWinLauncher
;
}
;
}
#
if
defined
(
MOZILLA_INTERNAL_API
)
struct
EnhancedModuleLoadInfo
final
{
explicit
EnhancedModuleLoadInfo
(
ModuleLoadInfo
&
&
aModLoadInfo
)
:
mNtLoadInfo
(
std
:
:
move
(
aModLoadInfo
)
)
{
if
(
mNtLoadInfo
.
mThreadId
=
=
:
:
GetCurrentThreadId
(
)
)
{
mThreadName
=
PR_GetThreadName
(
PR_GetCurrentThread
(
)
)
;
}
MOZ_ASSERT
(
!
mNtLoadInfo
.
mSectionName
.
IsEmpty
(
)
)
;
}
EnhancedModuleLoadInfo
(
EnhancedModuleLoadInfo
&
&
)
=
default
;
EnhancedModuleLoadInfo
&
operator
=
(
EnhancedModuleLoadInfo
&
&
)
=
default
;
EnhancedModuleLoadInfo
(
const
EnhancedModuleLoadInfo
&
)
=
delete
;
EnhancedModuleLoadInfo
&
operator
=
(
const
EnhancedModuleLoadInfo
&
)
=
delete
;
nsDependentString
GetSectionName
(
)
const
{
return
mNtLoadInfo
.
mSectionName
.
AsString
(
)
;
}
using
BacktraceType
=
decltype
(
ModuleLoadInfo
:
:
mBacktrace
)
;
ModuleLoadInfo
mNtLoadInfo
;
nsCString
mThreadName
;
}
;
class
DllServices
:
public
detail
:
:
DllServicesBase
{
public
:
void
DispatchDllLoadNotification
(
ModuleLoadInfo
&
&
aModLoadInfo
)
final
{
if
(
aModLoadInfo
.
WasBlocked
(
)
&
&
NS_IsMainThread
(
)
)
{
nsDependentString
sectionName
(
aModLoadInfo
.
mSectionName
.
AsString
(
)
)
;
for
(
const
auto
&
blockedModule
:
mMainThreadBlockedModules
)
{
if
(
sectionName
=
=
blockedModule
)
{
return
;
}
}
MOZ_ALWAYS_TRUE
(
mMainThreadBlockedModules
.
append
(
sectionName
)
)
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
(
NewRunnableMethod
<
StoreCopyPassByRRef
<
EnhancedModuleLoadInfo
>
>
(
"
DllServices
:
:
NotifyDllLoad
"
this
&
DllServices
:
:
NotifyDllLoad
std
:
:
move
(
aModLoadInfo
)
)
)
;
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
void
DispatchModuleLoadBacklogNotification
(
ModuleLoadInfoVec
&
&
aEvents
)
final
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
NewRunnableMethod
<
StoreCopyPassByRRef
<
ModuleLoadInfoVec
>
>
(
"
DllServices
:
:
NotifyModuleLoadBacklog
"
this
&
DllServices
:
:
NotifyModuleLoadBacklog
std
:
:
move
(
aEvents
)
)
)
;
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
#
if
defined
(
DEBUG
)
UniquePtr
<
wchar_t
[
]
>
GetBinaryOrgName
(
const
wchar_t
*
aFilePath
AuthenticodeFlags
aFlags
=
AuthenticodeFlags
:
:
Default
)
final
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
return
detail
:
:
DllServicesBase
:
:
GetBinaryOrgName
(
aFilePath
aFlags
)
;
}
#
endif
NS_INLINE_DECL_THREADSAFE_VIRTUAL_REFCOUNTING
(
DllServices
)
protected
:
DllServices
(
)
=
default
;
~
DllServices
(
)
=
default
;
virtual
void
NotifyDllLoad
(
EnhancedModuleLoadInfo
&
&
aModLoadInfo
)
=
0
;
virtual
void
NotifyModuleLoadBacklog
(
ModuleLoadInfoVec
&
&
aEvents
)
=
0
;
private
:
Vector
<
nsString
>
mMainThreadBlockedModules
;
}
;
#
else
class
BasicDllServices
final
:
public
detail
:
:
DllServicesBase
{
public
:
BasicDllServices
(
)
{
EnableBasic
(
)
;
}
~
BasicDllServices
(
)
=
default
;
virtual
void
DispatchDllLoadNotification
(
ModuleLoadInfo
&
&
aModLoadInfo
)
override
{
}
virtual
void
DispatchModuleLoadBacklogNotification
(
ModuleLoadInfoVec
&
&
aEvents
)
override
{
}
}
;
#
endif
}
}
#
endif
