#
include
"
mozilla
/
WindowsStackWalkInitialization
.
h
"
#
include
"
nsWindowsDllInterceptor
.
h
"
#
include
"
mozilla
/
NativeNt
.
h
"
#
include
"
mozilla
/
StackWalk_windows
.
h
"
#
include
"
mozilla
/
WindowsDiagnostics
.
h
"
namespace
mozilla
{
#
if
defined
(
_M_AMD64
)
|
|
defined
(
_M_ARM64
)
MOZ_RUNINIT
static
WindowsDllInterceptor
NtDllIntercept
;
typedef
NTSTATUS
(
NTAPI
*
LdrUnloadDll_func
)
(
HMODULE
module
)
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
LdrUnloadDll_func
>
stub_LdrUnloadDll
;
static
NTSTATUS
NTAPI
patched_LdrUnloadDll
(
HMODULE
module
)
{
AutoSuppressStackWalking
suppress
;
return
stub_LdrUnloadDll
(
module
)
;
}
typedef
PVOID
(
WINAPI
*
LdrResolveDelayLoadedAPI_func
)
(
PVOID
ParentModuleBase
PVOID
DelayloadDescriptor
PVOID
FailureDllHook
PVOID
FailureSystemHook
PVOID
ThunkAddress
ULONG
Flags
)
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
LdrResolveDelayLoadedAPI_func
>
stub_LdrResolveDelayLoadedAPI
;
static
PVOID
WINAPI
patched_LdrResolveDelayLoadedAPI
(
PVOID
ParentModuleBase
PVOID
DelayloadDescriptor
PVOID
FailureDllHook
PVOID
FailureSystemHook
PVOID
ThunkAddress
ULONG
Flags
)
{
AutoSuppressStackWalking
suppress
;
return
stub_LdrResolveDelayLoadedAPI
(
ParentModuleBase
DelayloadDescriptor
FailureDllHook
FailureSystemHook
ThunkAddress
Flags
)
;
}
void
WindowsStackWalkInitialization
(
)
{
static
bool
ran
=
false
;
if
(
ran
)
{
return
;
}
ran
=
true
;
Array
<
void
*
2
>
stackWalkLocks
;
if
(
CollectStackWalkLocks
(
stackWalkLocks
)
)
{
bool
locksArePlausible
=
ValidateStackWalkLocks
(
stackWalkLocks
)
;
MOZ_ASSERT
(
locksArePlausible
)
;
if
(
locksArePlausible
)
{
InitializeStackWalkLocks
(
stackWalkLocks
)
;
return
;
}
}
NtDllIntercept
.
Init
(
"
ntdll
.
dll
"
)
;
stub_LdrUnloadDll
.
Set
(
NtDllIntercept
"
LdrUnloadDll
"
&
patched_LdrUnloadDll
)
;
stub_LdrResolveDelayLoadedAPI
.
Set
(
NtDllIntercept
"
LdrResolveDelayLoadedAPI
"
&
patched_LdrResolveDelayLoadedAPI
)
;
}
[
[
clang
:
:
optnone
]
]
void
UnoptimizedLookup
(
)
{
DWORD64
imageBase
;
:
:
RtlLookupFunctionEntry
(
0
&
imageBase
nullptr
)
;
}
MFBT_API
bool
CollectStackWalkLocks
(
Array
<
void
*
2
>
&
aStackWalkLocks
)
{
#
if
defined
(
_M_AMD64
)
struct
LockCollectionData
{
Array
<
void
*
2
>
mCollectedLocks
;
int
mCollectedLocksCount
;
DebugOnly
<
bool
>
mLookupCalled
;
}
;
LockCollectionData
data
{
}
;
WindowsDiagnosticsError
error
=
CollectSingleStepData
(
UnoptimizedLookup
[
]
(
void
*
aState
CONTEXT
*
aContext
)
{
LockCollectionData
&
data
=
*
reinterpret_cast
<
LockCollectionData
*
>
(
aState
)
;
#
ifdef
DEBUG
if
(
aContext
-
>
Rip
=
=
reinterpret_cast
<
DWORD64
>
(
:
:
RtlLookupFunctionEntry
)
)
{
data
.
mLookupCalled
=
true
;
}
#
endif
void
*
lock
=
ExtractLockFromCurrentCpuContext
(
aContext
)
;
if
(
lock
)
{
bool
alreadyCollected
=
false
;
for
(
auto
collectedLock
:
data
.
mCollectedLocks
)
{
if
(
collectedLock
=
=
lock
)
{
alreadyCollected
=
true
;
break
;
}
}
if
(
!
alreadyCollected
)
{
if
(
data
.
mCollectedLocksCount
<
std
:
:
numeric_limits
<
decltype
(
data
.
mCollectedLocksCount
)
>
:
:
max
(
)
)
{
+
+
data
.
mCollectedLocksCount
;
}
if
(
data
.
mCollectedLocksCount
<
=
2
)
{
data
.
mCollectedLocks
[
data
.
mCollectedLocksCount
-
1
]
=
lock
;
}
}
}
return
true
;
}
&
data
)
;
MOZ_ASSERT
(
error
=
=
WindowsDiagnosticsError
:
:
None
|
|
error
=
=
WindowsDiagnosticsError
:
:
DebuggerPresent
)
;
if
(
error
!
=
WindowsDiagnosticsError
:
:
None
)
{
return
false
;
}
MOZ_ASSERT
(
data
.
mLookupCalled
)
;
bool
isAcquisitionSuccessful
=
data
.
mCollectedLocksCount
=
=
2
;
MOZ_ASSERT
(
isAcquisitionSuccessful
)
;
if
(
!
isAcquisitionSuccessful
)
{
return
false
;
}
aStackWalkLocks
[
0
]
=
data
.
mCollectedLocks
[
0
]
;
aStackWalkLocks
[
1
]
=
data
.
mCollectedLocks
[
1
]
;
return
true
;
#
else
return
false
;
#
endif
}
MFBT_API
void
*
ExtractLockFromCurrentCpuContext
(
void
*
aContext
)
{
#
if
defined
(
_M_AMD64
)
constexpr
BYTE
kMaskHighNibble
=
0xF0
;
constexpr
BYTE
kRexOpcode
=
0x40
;
constexpr
BYTE
kMaskRexW
=
0x08
;
constexpr
BYTE
kMaskRexB
=
0x01
;
constexpr
BYTE
kMaskMod
=
0xC0
;
constexpr
BYTE
kMaskRm
=
0x07
;
constexpr
BYTE
kModNoRegDisp
=
0x00
;
constexpr
BYTE
kRmNeedSib
=
0x04
;
constexpr
BYTE
kRmNoRegDispDisp32
=
0x05
;
auto
context
=
reinterpret_cast
<
CONTEXT
*
>
(
aContext
)
;
auto
opcode
=
reinterpret_cast
<
uint8_t
*
>
(
context
-
>
Rip
)
;
if
(
opcode
[
0
]
=
=
0xf0
&
&
(
opcode
[
1
]
&
(
kMaskHighNibble
|
kMaskRexW
)
)
=
=
(
kRexOpcode
|
kMaskRexW
)
&
&
opcode
[
2
]
=
=
0x0f
&
&
opcode
[
3
]
=
=
0xb1
)
{
if
(
(
opcode
[
4
]
&
kMaskMod
)
=
=
kModNoRegDisp
)
{
BYTE
const
rm
=
opcode
[
4
]
&
kMaskRm
;
if
(
rm
=
=
kRmNeedSib
)
{
return
nullptr
;
}
if
(
rm
=
=
kRmNoRegDispDisp32
)
{
return
reinterpret_cast
<
void
*
>
(
static_cast
<
int64_t
>
(
context
-
>
Rip
)
+
9i64
+
static_cast
<
int64_t
>
(
*
reinterpret_cast
<
int32_t
*
>
(
opcode
+
5
)
)
)
;
}
BYTE
const
regIndex
=
(
(
opcode
[
1
]
&
kMaskRexB
)
<
<
3
)
|
rm
;
DWORD64
const
regValue
=
(
&
context
-
>
Rax
)
[
regIndex
]
;
return
reinterpret_cast
<
void
*
>
(
regValue
)
;
}
}
return
nullptr
;
#
else
return
nullptr
;
#
endif
}
MFBT_API
bool
ValidateStackWalkLocks
(
const
Array
<
void
*
2
>
&
aStackWalkLocks
)
{
if
(
!
aStackWalkLocks
[
0
]
|
|
!
aStackWalkLocks
[
1
]
)
{
return
false
;
}
mozilla
:
:
nt
:
:
PEHeaders
ntdllImage
(
:
:
GetModuleHandleW
(
L
"
ntdll
.
dll
"
)
)
;
if
(
!
ntdllImage
)
{
return
false
;
}
auto
dataSection
=
ntdllImage
.
GetDataSectionInfo
(
)
;
if
(
dataSection
.
isNothing
(
)
)
{
return
false
;
}
return
dataSection
.
isSome
(
)
&
&
&
*
dataSection
-
>
cbegin
(
)
<
=
aStackWalkLocks
[
0
]
&
&
aStackWalkLocks
[
0
]
<
=
&
*
(
dataSection
-
>
cend
(
)
-
1
)
&
&
&
*
dataSection
-
>
cbegin
(
)
<
=
aStackWalkLocks
[
1
]
&
&
aStackWalkLocks
[
1
]
<
=
&
*
(
dataSection
-
>
cend
(
)
-
1
)
;
}
#
endif
}
