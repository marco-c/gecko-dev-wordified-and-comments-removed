#
ifndef
mozilla_UntrustedModulesProcessor_h
#
define
mozilla_UntrustedModulesProcessor_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
glue
/
WindowsDllServices
.
h
"
#
include
"
mozilla
/
LazyIdleThread
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UntrustedModulesData
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
class
ModuleEvaluator
;
using
UntrustedModulesPromise
=
MozPromise
<
Maybe
<
UntrustedModulesData
>
nsresult
true
>
;
using
ModulesTrustPromise
=
MozPromise
<
ModulesMapResult
nsresult
true
>
;
using
GetModulesTrustIpcPromise
=
MozPromise
<
Maybe
<
ModulesMapResult
>
ipc
:
:
ResponseRejectReason
true
>
;
struct
UnprocessedModuleLoadInfoContainer
final
:
public
LinkedListElement
<
UnprocessedModuleLoadInfoContainer
>
{
glue
:
:
EnhancedModuleLoadInfo
mInfo
;
template
<
typename
T
>
explicit
UnprocessedModuleLoadInfoContainer
(
T
&
&
aInfo
)
:
mInfo
(
std
:
:
move
(
aInfo
)
)
{
}
UnprocessedModuleLoadInfoContainer
(
const
UnprocessedModuleLoadInfoContainer
&
)
=
delete
;
UnprocessedModuleLoadInfoContainer
&
operator
=
(
const
UnprocessedModuleLoadInfoContainer
&
)
=
delete
;
}
;
using
UnprocessedModuleLoads
=
AutoCleanLinkedList
<
UnprocessedModuleLoadInfoContainer
>
;
class
UntrustedModulesProcessor
final
:
public
nsIObserver
public
nsIThreadPoolListener
{
public
:
static
RefPtr
<
UntrustedModulesProcessor
>
Create
(
bool
aIsReadyForBackgroundProcessing
)
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSITHREADPOOLLISTENER
bool
IsReadyForBackgroundProcessing
(
)
const
;
void
Disable
(
)
;
void
Enqueue
(
glue
:
:
EnhancedModuleLoadInfo
&
&
aModLoadInfo
)
;
void
Enqueue
(
ModuleLoadInfoVec
&
&
aEvents
)
;
RefPtr
<
UntrustedModulesPromise
>
GetProcessedData
(
)
;
RefPtr
<
ModulesTrustPromise
>
GetModulesTrust
(
ModulePaths
&
&
aModPaths
bool
aRunAtNormalPriority
)
;
UntrustedModulesProcessor
(
const
UntrustedModulesProcessor
&
)
=
delete
;
UntrustedModulesProcessor
(
UntrustedModulesProcessor
&
&
)
=
delete
;
UntrustedModulesProcessor
&
operator
=
(
const
UntrustedModulesProcessor
&
)
=
delete
;
UntrustedModulesProcessor
&
operator
=
(
UntrustedModulesProcessor
&
&
)
=
delete
;
private
:
~
UntrustedModulesProcessor
(
)
=
default
;
explicit
UntrustedModulesProcessor
(
bool
aIsReadyForBackgroundProcessing
)
;
static
bool
IsSupportedProcessType
(
)
;
void
AddObservers
(
)
;
void
RemoveObservers
(
)
;
void
ScheduleNonEmptyQueueProcessing
(
const
MutexAutoLock
&
aProofOfLock
)
MOZ_REQUIRES
(
mUnprocessedMutex
)
;
void
CancelScheduledProcessing
(
const
MutexAutoLock
&
aProofOfLock
)
MOZ_REQUIRES
(
mUnprocessedMutex
)
;
void
DispatchBackgroundProcessing
(
)
;
void
BackgroundProcessModuleLoadQueue
(
)
;
void
ProcessModuleLoadQueue
(
)
;
UnprocessedModuleLoads
ExtractLoadingEventsToProcess
(
size_t
aMaxLength
)
;
class
ModulesMapResultWithLoads
final
{
public
:
ModulesMapResultWithLoads
(
Maybe
<
ModulesMapResult
>
&
&
aModMapResult
UnprocessedModuleLoads
&
&
aLoads
)
:
mModMapResult
(
std
:
:
move
(
aModMapResult
)
)
mLoads
(
std
:
:
move
(
aLoads
)
)
{
}
Maybe
<
ModulesMapResult
>
mModMapResult
;
UnprocessedModuleLoads
mLoads
;
}
;
using
GetModulesTrustPromise
=
MozPromise
<
Maybe
<
ModulesMapResultWithLoads
>
nsresult
true
>
;
enum
class
Priority
{
Default
Background
}
;
RefPtr
<
GetModulesTrustPromise
>
ProcessModuleLoadQueueChildProcess
(
Priority
aPriority
)
;
void
BackgroundProcessModuleLoadQueueChildProcess
(
)
;
void
AssertRunningOnLazyIdleThread
(
)
;
RefPtr
<
UntrustedModulesPromise
>
GetProcessedDataInternal
(
)
;
RefPtr
<
UntrustedModulesPromise
>
GetProcessedDataInternalChildProcess
(
)
;
RefPtr
<
ModulesTrustPromise
>
GetModulesTrustInternal
(
ModulePaths
&
&
aModPaths
bool
aRunAtNormalPriority
)
;
RefPtr
<
ModulesTrustPromise
>
GetModulesTrustInternal
(
ModulePaths
&
&
aModPaths
)
;
RefPtr
<
ModuleRecord
>
GetOrAddModuleRecord
(
const
ModuleEvaluator
&
aModEval
const
nsAString
&
aResolvedNtPath
)
;
RefPtr
<
ModuleRecord
>
GetModuleRecord
(
const
ModulesMap
&
aModules
const
glue
:
:
EnhancedModuleLoadInfo
&
aModuleLoadInfo
)
;
RefPtr
<
GetModulesTrustIpcPromise
>
SendGetModulesTrust
(
ModulePaths
&
&
aModules
Priority
aPriority
)
;
void
CompleteProcessing
(
ModulesMapResultWithLoads
&
&
aModulesAndLoads
)
;
RefPtr
<
UntrustedModulesPromise
>
GetAllProcessedData
(
StaticString
aSource
)
;
private
:
RefPtr
<
LazyIdleThread
>
mThread
;
Mutex
mThreadHandleMutex
;
Mutex
mUnprocessedMutex
;
Mutex
mModuleCacheMutex
;
nsAutoHandle
mThreadHandle
MOZ_GUARDED_BY
(
mThreadHandleMutex
)
;
UnprocessedModuleLoads
mUnprocessedModuleLoads
MOZ_GUARDED_BY
(
mUnprocessedMutex
)
;
nsCOMPtr
<
nsIRunnable
>
mIdleRunnable
MOZ_GUARDED_BY
(
mUnprocessedMutex
)
;
UntrustedModulesData
mProcessedModuleLoads
;
enum
class
Status
{
StartingUp
Allowed
ShuttingDown
}
;
Atomic
<
Status
>
mStatus
;
ModulesMap
mGlobalModuleCache
MOZ_GUARDED_BY
(
mModuleCacheMutex
)
;
}
;
}
#
endif
