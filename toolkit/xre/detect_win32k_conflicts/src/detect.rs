use
super
:
:
error
:
:
DetectConflictError
;
use
super
:
:
registry
:
:
{
RegKey
RegValue
}
;
use
std
:
:
ffi
:
:
OsStr
;
const
EXPLOIT_PROTECTION_SUBKEY
:
&
str
=
"
SOFTWARE
\
\
Microsoft
\
\
Windows
NT
\
\
CurrentVersion
\
\
Image
File
Execution
Options
"
;
const
MITIGATION_VALUE_NAME
:
&
str
=
"
MitigationOptions
"
;
const
STACK_PIVOT_BIT
:
usize
=
80
;
const
CALLER_CHECK_BIT
:
usize
=
84
;
const
SIM_EXEC_BIT
:
usize
=
88
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
PartialEq
)
]
pub
struct
ConflictingMitigationStatus
{
caller_check
:
bool
sim_exec
:
bool
stack_pivot
:
bool
}
impl
std
:
:
fmt
:
:
Display
for
ConflictingMitigationStatus
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
Result
<
(
)
std
:
:
fmt
:
:
Error
>
{
use
std
:
:
fmt
:
:
Write
;
write_status
(
f
"
CallerCheck
"
self
.
caller_check
)
?
;
f
.
write_char
(
'
'
)
?
;
write_status
(
f
"
SimExec
"
self
.
sim_exec
)
?
;
f
.
write_char
(
'
'
)
?
;
write_status
(
f
"
StackPivot
"
self
.
stack_pivot
)
}
}
pub
fn
get_conflicting_mitigations
(
process_name
:
impl
AsRef
<
OsStr
>
)
-
>
Result
<
ConflictingMitigationStatus
DetectConflictError
>
{
let
process_name
=
process_name
.
as_ref
(
)
;
let
key
=
RegKey
:
:
root_local_machine
(
)
.
try_open_subkey
(
EXPLOIT_PROTECTION_SUBKEY
)
?
.
ok_or
(
DetectConflictError
:
:
ExploitProtectionKeyMissing
)
?
;
let
process_key
=
match
key
.
try_open_subkey
(
process_name
)
?
{
Some
(
key
)
=
>
key
None
=
>
{
log
:
:
info
!
(
"
process
name
{
:
?
}
not
found
in
exploit
protection
"
process_name
)
;
return
Ok
(
ConflictingMitigationStatus
:
:
default
(
)
)
;
}
}
;
let
mut
status
=
get_conflicting_mitigations_for_key
(
&
process_key
)
?
;
for
subkey_name
in
process_key
.
subkey_names
(
)
{
let
subkey_name
=
subkey_name
?
;
let
subkey
=
process_key
.
try_open_subkey
(
subkey_name
)
?
.
expect
(
"
a
subkey
somehow
doesn
'
t
exist
after
enumerating
it
"
)
;
let
subkey_status
=
get_conflicting_mitigations_for_key
(
&
subkey
)
?
;
status
.
caller_check
|
=
subkey_status
.
caller_check
;
status
.
sim_exec
|
=
subkey_status
.
sim_exec
;
status
.
stack_pivot
|
=
subkey_status
.
stack_pivot
;
}
log
:
:
info
!
(
"
process
name
{
:
?
}
has
mitigation
status
{
:
?
}
"
process_name
status
)
;
Ok
(
status
)
}
fn
get_conflicting_mitigations_for_key
(
key
:
&
RegKey
)
-
>
Result
<
ConflictingMitigationStatus
DetectConflictError
>
{
let
value
=
match
key
.
try_get_value
(
MITIGATION_VALUE_NAME
)
?
{
Some
(
value
)
=
>
value
None
=
>
return
Ok
(
ConflictingMitigationStatus
:
:
default
(
)
)
}
;
let
bits
=
match
value
{
RegValue
:
:
Binary
(
bits
)
=
>
bits
_
=
>
return
Ok
(
ConflictingMitigationStatus
:
:
default
(
)
)
}
;
Ok
(
ConflictingMitigationStatus
{
caller_check
:
get_bit
(
&
bits
CALLER_CHECK_BIT
)
?
sim_exec
:
get_bit
(
&
bits
SIM_EXEC_BIT
)
?
stack_pivot
:
get_bit
(
&
bits
STACK_PIVOT_BIT
)
?
}
)
}
fn
get_bit
(
bytes
:
&
[
u8
]
bit_idx
:
usize
)
-
>
Result
<
bool
DetectConflictError
>
{
let
byte
=
bytes
.
get
(
bit_idx
/
8
)
.
ok_or
(
DetectConflictError
:
:
RegValueTooShort
)
?
;
Ok
(
if
byte
&
(
1
<
<
(
bit_idx
%
8
)
)
!
=
0
{
true
}
else
{
false
}
)
}
fn
write_status
(
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
name
:
&
str
bit
:
bool
)
-
>
Result
<
(
)
std
:
:
fmt
:
:
Error
>
{
let
status_str
=
if
bit
{
"
enabled
"
}
else
{
"
disabled
"
}
;
write
!
(
f
"
{
}
is
{
}
.
"
name
status_str
)
}
