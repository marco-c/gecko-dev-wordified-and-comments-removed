#
include
"
nsUpdateSyncManager
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIProperties
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
ifdef
XP_WIN
#
include
"
WinUtils
.
h
"
#
endif
#
define
UPDATE_LOCK_NAME_TOKEN
"
UpdateLock
"
nsUpdateSyncManager
*
gUpdateSyncManager
=
nullptr
;
NS_IMPL_ISUPPORTS
(
nsUpdateSyncManager
nsIUpdateSyncManager
nsIObserver
)
nsUpdateSyncManager
:
:
nsUpdateSyncManager
(
nsIFile
*
anAppFile
)
{
gUpdateSyncManager
=
this
;
OpenLock
(
anAppFile
)
;
}
nsUpdateSyncManager
:
:
~
nsUpdateSyncManager
(
)
{
ReleaseLock
(
)
;
gUpdateSyncManager
=
nullptr
;
}
already_AddRefed
<
nsUpdateSyncManager
>
nsUpdateSyncManager
:
:
GetSingleton
(
)
{
if
(
!
gUpdateSyncManager
)
{
new
nsUpdateSyncManager
(
)
;
}
return
do_AddRef
(
gUpdateSyncManager
)
;
}
NS_IMETHODIMP
nsUpdateSyncManager
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
mozilla
:
:
Unused
<
<
aSubject
;
mozilla
:
:
Unused
<
<
aData
;
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_XPCOM_STARTUP_OBSERVER_ID
)
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
return
observerService
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
}
return
NS_ERROR_SERVICE_NOT_AVAILABLE
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
{
ReleaseLock
(
)
;
}
return
NS_OK
;
}
nsresult
nsUpdateSyncManager
:
:
OpenLock
(
nsIFile
*
anAppFile
)
{
if
(
mLock
!
=
MULTI_INSTANCE_LOCK_HANDLE_ERROR
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
)
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
appFile
;
if
(
anAppFile
)
{
rv
=
anAppFile
-
>
Clone
(
getter_AddRefs
(
appFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
nsIProperties
>
dirSvc
=
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
)
;
NS_ENSURE_TRUE
(
dirSvc
NS_ERROR_SERVICE_NOT_AVAILABLE
)
;
rv
=
dirSvc
-
>
Get
(
XRE_EXECUTABLE_FILE
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
appFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
#
ifdef
XP_WIN
if
(
!
mozilla
:
:
widget
:
:
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
appFile
)
)
{
NS_WARNING
(
"
Failed
to
resolve
install
directory
.
"
)
;
}
#
elif
defined
(
MOZ_WIDGET_COCOA
)
FSRef
ref
;
nsCOMPtr
<
nsILocalFileMac
>
macFile
=
do_QueryInterface
(
appFile
)
;
if
(
macFile
&
&
NS_SUCCEEDED
(
macFile
-
>
GetFSRef
(
&
ref
)
)
&
&
NS_SUCCEEDED
(
NS_NewLocalFileWithFSRef
(
&
ref
true
getter_AddRefs
(
macFile
)
)
)
)
{
appFile
=
static_cast
<
nsIFile
*
>
(
macFile
)
;
}
else
{
NS_WARNING
(
"
Failed
to
resolve
install
directory
.
"
)
;
}
#
endif
nsCOMPtr
<
nsIFile
>
appDirFile
;
rv
=
appFile
-
>
GetParent
(
getter_AddRefs
(
appDirFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
appDirPath
;
rv
=
appDirFile
-
>
GetPath
(
appDirPath
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mLock
=
mozilla
:
:
OpenMultiInstanceLock
(
UPDATE_LOCK_NAME_TOKEN
PromiseFlatString
(
appDirPath
)
.
get
(
)
)
;
NS_ENSURE_TRUE
(
mLock
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
void
nsUpdateSyncManager
:
:
ReleaseLock
(
)
{
if
(
mLock
=
=
MULTI_INSTANCE_LOCK_HANDLE_ERROR
)
{
return
;
}
mozilla
:
:
ReleaseMultiInstanceLock
(
mLock
)
;
mLock
=
MULTI_INSTANCE_LOCK_HANDLE_ERROR
;
}
NS_IMETHODIMP
nsUpdateSyncManager
:
:
IsOtherInstanceRunning
(
bool
*
aResult
)
{
if
(
NS_WARN_IF
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
)
)
{
return
NS_ERROR_SERVICE_NOT_AVAILABLE
;
}
if
(
mLock
=
=
MULTI_INSTANCE_LOCK_HANDLE_ERROR
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
bool
rv
=
mozilla
:
:
IsOtherInstanceRunning
(
mLock
aResult
)
;
NS_ENSURE_TRUE
(
rv
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsUpdateSyncManager
:
:
ResetLock
(
nsIFile
*
anAppFile
=
nullptr
)
{
ReleaseLock
(
)
;
return
OpenLock
(
anAppFile
)
;
}
