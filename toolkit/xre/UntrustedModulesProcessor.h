#
ifndef
mozilla_UntrustedModulesProcessor_h
#
define
mozilla_UntrustedModulesProcessor_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
glue
/
WindowsDllServices
.
h
"
#
include
"
mozilla
/
LazyIdleThread
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UntrustedModulesData
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
class
ModuleEvaluator
;
using
UntrustedModulesPromise
=
MozPromise
<
Maybe
<
UntrustedModulesData
>
nsresult
true
>
;
class
UntrustedModulesProcessor
final
:
public
nsIObserver
{
public
:
static
RefPtr
<
UntrustedModulesProcessor
>
Create
(
)
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
void
Enqueue
(
glue
:
:
EnhancedModuleLoadInfo
&
&
aModLoadInfo
)
;
void
Enqueue
(
ModuleLoadInfoVec
&
&
aEvents
)
;
RefPtr
<
UntrustedModulesPromise
>
GetProcessedData
(
)
;
UntrustedModulesProcessor
(
const
UntrustedModulesProcessor
&
)
=
delete
;
UntrustedModulesProcessor
(
UntrustedModulesProcessor
&
&
)
=
delete
;
UntrustedModulesProcessor
&
operator
=
(
const
UntrustedModulesProcessor
&
)
=
delete
;
UntrustedModulesProcessor
&
operator
=
(
UntrustedModulesProcessor
&
&
)
=
delete
;
private
:
~
UntrustedModulesProcessor
(
)
=
default
;
UntrustedModulesProcessor
(
)
;
void
AddObservers
(
)
;
void
RemoveObservers
(
)
;
void
ScheduleNonEmptyQueueProcessing
(
const
char
*
aSource
const
MutexAutoLock
&
aProofOfLock
)
;
void
CancelScheduledProcessing
(
const
MutexAutoLock
&
aProofOfLock
)
;
void
DispatchBackgroundProcessing
(
const
char
*
aSource
)
;
void
BackgroundProcessModuleLoadQueue
(
const
char
*
aSource
)
;
void
ProcessModuleLoadQueue
(
const
char
*
aSource
)
;
void
AssertRunningOnLazyIdleThread
(
)
;
RefPtr
<
UntrustedModulesPromise
>
GetProcessedDataInternal
(
)
;
RefPtr
<
ModuleRecord
>
GetModuleRecord
(
UntrustedModulesData
:
:
ModulesMap
&
aModules
const
ModuleEvaluator
&
aModEval
const
nsAString
&
aResolvedNtPath
)
;
RefPtr
<
LazyIdleThread
>
mThread
;
Mutex
mUnprocessedMutex
;
Vector
<
glue
:
:
EnhancedModuleLoadInfo
>
mUnprocessedModuleLoads
;
nsCOMPtr
<
nsIRunnable
>
mIdleRunnable
;
UntrustedModulesData
mProcessedModuleLoads
;
Atomic
<
bool
>
mAllowProcessing
;
}
;
}
#
endif
