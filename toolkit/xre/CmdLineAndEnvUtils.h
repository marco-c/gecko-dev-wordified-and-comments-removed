#
ifndef
mozilla_CmdLineAndEnvUtils_h
#
define
mozilla_CmdLineAndEnvUtils_h
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
include
"
prenv
.
h
"
#
include
"
prprf
.
h
"
#
include
<
string
.
h
>
#
endif
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
<
wchar
.
h
>
#
include
<
windows
.
h
>
#
endif
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
<
ctype
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
ifndef
NS_NO_XPCOM
#
include
"
nsIFile
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
endif
#
undef
None
namespace
mozilla
{
enum
ArgResult
{
ARG_NONE
=
0
ARG_FOUND
=
1
ARG_BAD
=
2
}
;
template
<
typename
CharT
>
inline
void
RemoveArg
(
int
&
argc
CharT
*
*
argv
)
{
do
{
*
argv
=
*
(
argv
+
1
)
;
+
+
argv
;
}
while
(
*
argv
)
;
-
-
argc
;
}
namespace
internal
{
#
if
'
a
'
=
=
'
\
x61
'
static
inline
constexpr
bool
isValidOptionCharacter
(
char
c
)
{
return
(
'
0
'
<
=
c
&
&
c
<
=
'
9
'
)
|
|
(
'
a
'
<
=
c
&
&
c
<
=
'
z
'
)
|
|
c
=
=
'
-
'
;
}
;
static
inline
constexpr
char
toLowercase
(
char
c
)
{
return
(
'
A
'
<
=
c
&
&
c
<
=
'
Z
'
)
?
char
(
c
|
'
'
)
:
c
;
}
;
template
<
typename
CharT
>
static
inline
constexpr
char
toNarrow
(
CharT
c
)
{
return
(
c
&
static_cast
<
CharT
>
(
0xff
)
)
=
=
c
?
c
:
0xff
;
}
;
#
else
#
error
Character
conversion
functions
not
implemented
for
this
platform
.
#
endif
template
<
typename
CharT
>
static
inline
bool
strimatch
(
const
char
*
lowerstr
const
CharT
*
mixedstr
)
{
while
(
*
lowerstr
)
{
if
(
!
*
mixedstr
)
return
false
;
if
(
!
isValidOptionCharacter
(
*
lowerstr
)
)
return
false
;
if
(
toLowercase
(
toNarrow
(
*
mixedstr
)
)
!
=
*
lowerstr
)
{
return
false
;
}
+
+
lowerstr
;
+
+
mixedstr
;
}
if
(
*
mixedstr
)
return
false
;
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Maybe
<
const
CharT
*
>
ReadAsOption
(
const
CharT
*
str
)
{
if
(
!
str
)
{
return
Nothing
(
)
;
}
if
(
*
str
=
=
'
-
'
)
{
str
+
+
;
if
(
*
str
=
=
'
-
'
)
{
str
+
+
;
}
return
Some
(
str
)
;
}
#
ifdef
XP_WIN
if
(
*
str
=
=
'
/
'
)
{
return
Some
(
str
+
1
)
;
}
#
endif
return
Nothing
(
)
;
}
}
using
internal
:
:
strimatch
;
const
wchar_t
kCommandLineDelimiter
[
]
=
L
"
\
t
"
;
enum
class
CheckArgFlag
:
uint32_t
{
None
=
0
RemoveArg
=
(
1
<
<
1
)
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
CheckArgFlag
)
template
<
typename
CharT
>
inline
ArgResult
CheckArg
(
int
&
aArgc
CharT
*
*
aArgv
const
char
*
aArg
const
CharT
*
*
aParam
=
nullptr
CheckArgFlag
aFlags
=
CheckArgFlag
:
:
RemoveArg
)
{
using
internal
:
:
ReadAsOption
;
MOZ_ASSERT
(
aArgv
&
&
aArg
)
;
CharT
*
*
curarg
=
aArgv
+
1
;
ArgResult
ar
=
ARG_NONE
;
while
(
*
curarg
)
{
if
(
const
auto
arg
=
ReadAsOption
(
*
curarg
)
)
{
if
(
strimatch
(
aArg
arg
.
value
(
)
)
)
{
if
(
aFlags
&
CheckArgFlag
:
:
RemoveArg
)
{
RemoveArg
(
aArgc
curarg
)
;
}
else
{
+
+
curarg
;
}
if
(
!
aParam
)
{
ar
=
ARG_FOUND
;
break
;
}
if
(
*
curarg
)
{
if
(
ReadAsOption
(
*
curarg
)
)
{
return
ARG_BAD
;
}
*
aParam
=
*
curarg
;
if
(
aFlags
&
CheckArgFlag
:
:
RemoveArg
)
{
RemoveArg
(
aArgc
curarg
)
;
}
ar
=
ARG_FOUND
;
break
;
}
return
ARG_BAD
;
}
}
+
+
curarg
;
}
return
ar
;
}
template
<
typename
CharT
>
inline
ArgResult
CheckArg
(
int
&
aArgc
CharT
*
*
aArgv
const
char
*
aArg
std
:
:
nullptr_t
CheckArgFlag
aFlags
=
CheckArgFlag
:
:
RemoveArg
)
{
return
CheckArg
<
CharT
>
(
aArgc
aArgv
aArg
static_cast
<
const
CharT
*
*
>
(
nullptr
)
aFlags
)
;
}
namespace
internal
{
template
<
typename
CharT
typename
ListT
>
static
bool
MatchesAnyOf
(
CharT
const
*
unknown
ListT
const
&
known
)
{
for
(
const
char
*
k
:
known
)
{
if
(
strimatch
(
k
unknown
)
)
{
return
true
;
}
}
return
false
;
}
template
<
typename
CharT
typename
ReqContainerT
typename
OptContainerT
>
inline
bool
EnsureCommandlineSafeImpl
(
int
aArgc
CharT
*
*
aArgv
ReqContainerT
const
&
requiredParams
OptContainerT
const
&
optionalParams
)
{
static
constexpr
const
char
*
osintLit
=
"
osint
"
;
if
(
CheckArg
(
aArgc
aArgv
osintLit
nullptr
CheckArgFlag
:
:
None
)
!
=
ARG_FOUND
)
{
return
true
;
}
if
(
aArgc
<
4
)
{
return
false
;
}
const
auto
arg1
=
ReadAsOption
(
aArgv
[
1
]
)
;
if
(
!
arg1
)
return
false
;
if
(
!
strimatch
(
osintLit
arg1
.
value
(
)
)
)
{
return
false
;
}
int
pos
=
2
;
while
(
true
)
{
if
(
pos
>
=
aArgc
)
return
false
;
auto
const
arg
=
ReadAsOption
(
aArgv
[
pos
]
)
;
if
(
!
arg
)
return
false
;
if
(
MatchesAnyOf
(
arg
.
value
(
)
optionalParams
)
)
{
+
+
pos
;
continue
;
}
if
(
MatchesAnyOf
(
arg
.
value
(
)
requiredParams
)
)
{
+
+
pos
;
break
;
}
return
false
;
}
if
(
pos
+
1
!
=
aArgc
)
return
false
;
if
(
ReadAsOption
(
aArgv
[
pos
]
)
)
{
return
false
;
}
return
true
;
}
template
<
typename
CharT
typename
ReqContainerT
>
inline
bool
EnsureCommandlineSafeImpl
(
int
aArgc
CharT
*
*
aArgv
ReqContainerT
const
&
requiredParams
std
:
:
nullptr_t
_
=
nullptr
)
{
struct
{
inline
const
char
*
*
begin
(
)
const
{
return
nullptr
;
}
inline
const
char
*
*
end
(
)
const
{
return
nullptr
;
}
}
emptyContainer
;
return
EnsureCommandlineSafeImpl
(
aArgc
aArgv
requiredParams
emptyContainer
)
;
}
}
template
<
typename
CharT
typename
ReqContainerT
typename
OptContainerT
=
std
:
:
nullptr_t
>
inline
void
EnsureCommandlineSafe
(
int
aArgc
CharT
*
*
aArgv
ReqContainerT
const
&
requiredParams
OptContainerT
const
&
optionalParams
=
nullptr
)
{
if
(
!
internal
:
:
EnsureCommandlineSafeImpl
(
aArgc
aArgv
requiredParams
optionalParams
)
)
{
exit
(
127
)
;
}
}
#
if
defined
(
XP_WIN
)
namespace
internal
{
inline
int
ArgStrLen
(
const
wchar_t
*
s
)
{
int
backslashes
=
0
;
int
i
=
wcslen
(
s
)
;
bool
hasDoubleQuote
=
wcschr
(
s
L
'
"
'
)
!
=
nullptr
;
bool
addDoubleQuotes
=
wcspbrk
(
s
kCommandLineDelimiter
)
!
=
nullptr
;
if
(
addDoubleQuotes
)
{
i
+
=
2
;
}
if
(
hasDoubleQuote
)
{
while
(
*
s
)
{
if
(
*
s
=
=
'
\
\
'
)
{
+
+
backslashes
;
}
else
{
if
(
*
s
=
=
'
"
'
)
{
i
+
=
backslashes
+
1
;
}
backslashes
=
0
;
}
+
+
s
;
}
}
return
i
;
}
inline
wchar_t
*
ArgToString
(
wchar_t
*
d
const
wchar_t
*
s
)
{
int
backslashes
=
0
;
bool
hasDoubleQuote
=
wcschr
(
s
L
'
"
'
)
!
=
nullptr
;
bool
addDoubleQuotes
=
wcspbrk
(
s
kCommandLineDelimiter
)
!
=
nullptr
;
if
(
addDoubleQuotes
)
{
*
d
=
'
"
'
;
+
+
d
;
}
if
(
hasDoubleQuote
)
{
int
i
;
while
(
*
s
)
{
if
(
*
s
=
=
'
\
\
'
)
{
+
+
backslashes
;
}
else
{
if
(
*
s
=
=
'
"
'
)
{
for
(
i
=
0
;
i
<
=
backslashes
;
+
+
i
)
{
*
d
=
'
\
\
'
;
+
+
d
;
}
}
backslashes
=
0
;
}
*
d
=
*
s
;
+
+
d
;
+
+
s
;
}
}
else
{
wcscpy
(
d
s
)
;
d
+
=
wcslen
(
s
)
;
}
if
(
addDoubleQuotes
)
{
*
d
=
'
"
'
;
+
+
d
;
}
return
d
;
}
}
inline
UniquePtr
<
wchar_t
[
]
>
MakeCommandLine
(
int
argc
const
wchar_t
*
const
*
argv
int
aArgcExtra
=
0
const
wchar_t
*
const
*
aArgvExtra
=
nullptr
)
{
int
i
;
int
len
=
0
;
for
(
i
=
0
;
i
<
argc
;
+
+
i
)
{
len
+
=
internal
:
:
ArgStrLen
(
argv
[
i
]
)
+
1
;
}
for
(
i
=
0
;
i
<
aArgcExtra
;
+
+
i
)
{
len
+
=
internal
:
:
ArgStrLen
(
aArgvExtra
[
i
]
)
+
1
;
}
if
(
len
=
=
0
)
{
len
=
1
;
}
auto
s
=
MakeUnique
<
wchar_t
[
]
>
(
len
)
;
int
totalArgc
=
argc
+
aArgcExtra
;
wchar_t
*
c
=
s
.
get
(
)
;
for
(
i
=
0
;
i
<
argc
;
+
+
i
)
{
c
=
internal
:
:
ArgToString
(
c
argv
[
i
]
)
;
if
(
i
+
1
!
=
totalArgc
)
{
*
c
=
'
'
;
+
+
c
;
}
}
for
(
i
=
0
;
i
<
aArgcExtra
;
+
+
i
)
{
c
=
internal
:
:
ArgToString
(
c
aArgvExtra
[
i
]
)
;
if
(
i
+
1
!
=
aArgcExtra
)
{
*
c
=
'
'
;
+
+
c
;
}
}
*
c
=
'
\
0
'
;
return
s
;
}
inline
bool
SetArgv0ToFullBinaryPath
(
wchar_t
*
aArgv
[
]
)
{
if
(
!
aArgv
)
{
return
false
;
}
UniquePtr
<
wchar_t
[
]
>
newArgv_0
(
GetFullBinaryPath
(
)
)
;
if
(
!
newArgv_0
)
{
return
false
;
}
aArgv
[
0
]
=
newArgv_0
.
release
(
)
;
MOZ_LSAN_INTENTIONALLY_LEAK_OBJECT
(
aArgv
[
0
]
)
;
return
true
;
}
#
if
defined
(
MOZILLA_INTERNAL_API
)
template
<
typename
T
>
class
CommandLineParserWin
final
{
int
mArgc
;
T
*
*
mArgv
;
void
Release
(
)
{
if
(
mArgv
)
{
while
(
mArgc
)
{
delete
[
]
mArgv
[
-
-
mArgc
]
;
}
delete
[
]
mArgv
;
mArgv
=
nullptr
;
}
}
public
:
CommandLineParserWin
(
)
:
mArgc
(
0
)
mArgv
(
nullptr
)
{
}
~
CommandLineParserWin
(
)
{
Release
(
)
;
}
CommandLineParserWin
(
const
CommandLineParserWin
&
)
=
delete
;
CommandLineParserWin
(
CommandLineParserWin
&
&
)
=
delete
;
CommandLineParserWin
&
operator
=
(
const
CommandLineParserWin
&
)
=
delete
;
CommandLineParserWin
&
operator
=
(
CommandLineParserWin
&
&
)
=
delete
;
int
Argc
(
)
const
{
return
mArgc
;
}
const
T
*
const
*
Argv
(
)
const
{
return
mArgv
;
}
int
HandleCommandLine
(
const
nsTSubstring
<
T
>
&
aCmdLineString
)
{
Release
(
)
;
if
(
aCmdLineString
.
IsEmpty
(
)
)
{
return
0
;
}
int
justCounting
=
1
;
int
init
=
1
;
int
between
quoted
bSlashCount
;
const
T
*
p
;
const
T
*
const
pEnd
=
aCmdLineString
.
EndReading
(
)
;
nsTAutoString
<
T
>
arg
;
while
(
1
)
{
if
(
init
)
{
p
=
aCmdLineString
.
BeginReading
(
)
;
between
=
1
;
mArgc
=
quoted
=
bSlashCount
=
0
;
init
=
0
;
}
const
T
charCurr
=
(
p
<
pEnd
)
?
*
p
:
0
;
const
T
charNext
=
(
p
+
1
<
pEnd
)
?
*
(
p
+
1
)
:
0
;
if
(
between
)
{
if
(
charCurr
!
=
0
&
&
!
wcschr
(
kCommandLineDelimiter
charCurr
)
)
{
between
=
0
;
arg
.
Truncate
(
)
;
switch
(
charCurr
)
{
case
'
\
\
'
:
bSlashCount
=
1
;
break
;
case
'
"
'
:
quoted
=
1
;
break
;
default
:
arg
+
=
charCurr
;
break
;
}
}
else
{
}
}
else
{
if
(
charCurr
=
=
0
|
|
(
!
quoted
&
&
wcschr
(
kCommandLineDelimiter
charCurr
)
)
)
{
while
(
bSlashCount
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
-
;
}
if
(
!
justCounting
)
{
mArgv
[
mArgc
]
=
new
T
[
arg
.
Length
(
)
+
1
]
;
memcpy
(
mArgv
[
mArgc
]
arg
.
get
(
)
(
arg
.
Length
(
)
+
1
)
*
sizeof
(
T
)
)
;
}
mArgc
+
+
;
between
=
1
;
}
else
{
switch
(
charCurr
)
{
case
'
"
'
:
while
(
bSlashCount
>
1
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
=
2
;
}
if
(
bSlashCount
)
{
arg
+
=
'
"
'
;
bSlashCount
=
0
;
}
else
{
if
(
quoted
)
{
if
(
charNext
=
=
'
"
'
)
{
bSlashCount
=
1
;
}
else
{
quoted
=
0
;
}
}
else
{
quoted
=
1
;
}
}
break
;
case
'
\
\
'
:
bSlashCount
+
+
;
break
;
default
:
while
(
bSlashCount
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
-
;
}
arg
+
=
charCurr
;
break
;
}
}
}
if
(
charCurr
)
{
p
+
+
;
}
else
{
if
(
justCounting
)
{
mArgv
=
new
T
*
[
mArgc
]
;
justCounting
=
0
;
init
=
1
;
}
else
{
break
;
}
}
}
return
p
-
aCmdLineString
.
BeginReading
(
)
;
}
}
;
#
endif
#
endif
#
if
defined
(
MOZILLA_INTERNAL_API
)
|
|
defined
(
XP_WIN
)
MOZ_NEVER_INLINE
inline
void
SaveToEnv
(
const
char
*
aEnvString
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
char
*
expr
=
strdup
(
aEnvString
)
;
if
(
expr
)
{
PR_SetEnv
(
expr
)
;
}
MOZ_LSAN_INTENTIONALLY_LEAK_OBJECT
(
expr
)
;
#
elif
defined
(
XP_WIN
)
_putenv
(
aEnvString
)
;
#
endif
}
inline
bool
EnvHasValue
(
const
char
*
aVarName
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
const
char
*
val
=
PR_GetEnv
(
aVarName
)
;
return
val
&
&
*
val
;
#
elif
defined
(
XP_WIN
)
const
char
*
val
=
getenv
(
aVarName
)
;
return
val
&
&
*
val
;
#
endif
}
#
endif
#
ifndef
NS_NO_XPCOM
already_AddRefed
<
nsIFile
>
GetFileFromEnv
(
const
char
*
name
)
;
#
endif
}
#
endif
