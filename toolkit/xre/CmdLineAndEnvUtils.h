#
ifndef
mozilla_CmdLineAndEnvUtils_h
#
define
mozilla_CmdLineAndEnvUtils_h
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
include
"
prenv
.
h
"
#
include
"
prprf
.
h
"
#
include
<
string
.
h
>
#
elif
defined
(
XP_WIN
)
#
include
<
stdlib
.
h
>
#
endif
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
<
wchar
.
h
>
#
include
<
windows
.
h
>
#
endif
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
<
ctype
.
h
>
#
include
<
stdint
.
h
>
#
undef
None
namespace
mozilla
{
enum
ArgResult
{
ARG_NONE
=
0
ARG_FOUND
=
1
ARG_BAD
=
2
}
;
template
<
typename
CharT
>
inline
void
RemoveArg
(
int
&
argc
CharT
*
*
argv
)
{
do
{
*
argv
=
*
(
argv
+
1
)
;
+
+
argv
;
}
while
(
*
argv
)
;
-
-
argc
;
}
namespace
internal
{
template
<
typename
FuncT
typename
CharT
>
static
inline
bool
strimatch
(
FuncT
aToLowerFn
const
CharT
*
lowerstr
const
CharT
*
mixedstr
)
{
while
(
*
lowerstr
)
{
if
(
!
*
mixedstr
)
return
false
;
if
(
static_cast
<
CharT
>
(
aToLowerFn
(
*
mixedstr
)
)
!
=
*
lowerstr
)
return
false
;
+
+
lowerstr
;
+
+
mixedstr
;
}
if
(
*
mixedstr
)
return
false
;
return
true
;
}
}
inline
bool
strimatch
(
const
char
*
lowerstr
const
char
*
mixedstr
)
{
return
internal
:
:
strimatch
(
&
tolower
lowerstr
mixedstr
)
;
}
inline
bool
strimatch
(
const
wchar_t
*
lowerstr
const
wchar_t
*
mixedstr
)
{
return
internal
:
:
strimatch
(
&
towlower
lowerstr
mixedstr
)
;
}
enum
class
FlagLiteral
{
osint
safemode
}
;
template
<
typename
CharT
FlagLiteral
Literal
>
inline
const
CharT
*
GetLiteral
(
)
;
#
define
DECLARE_FLAG_LITERAL
(
enum_name
literal
)
\
template
<
>
inline
\
const
char
*
GetLiteral
<
char
FlagLiteral
:
:
enum_name
>
(
)
\
{
\
return
literal
;
\
}
\
\
template
<
>
inline
\
const
wchar_t
*
GetLiteral
<
wchar_t
FlagLiteral
:
:
enum_name
>
(
)
\
{
\
return
L
#
#
literal
;
\
}
DECLARE_FLAG_LITERAL
(
osint
"
osint
"
)
DECLARE_FLAG_LITERAL
(
safemode
"
safe
-
mode
"
)
enum
class
CheckArgFlag
:
uint32_t
{
None
=
0
CheckOSInt
=
(
1
<
<
0
)
RemoveArg
=
(
1
<
<
1
)
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
CheckArgFlag
)
template
<
typename
CharT
>
inline
ArgResult
CheckArg
(
int
&
aArgc
CharT
*
*
aArgv
const
CharT
*
aArg
const
CharT
*
*
aParam
CheckArgFlag
aFlags
)
{
MOZ_ASSERT
(
aArgv
&
&
aArg
)
;
CharT
*
*
curarg
=
aArgv
+
1
;
ArgResult
ar
=
ARG_NONE
;
while
(
*
curarg
)
{
CharT
*
arg
=
curarg
[
0
]
;
if
(
arg
[
0
]
=
=
'
-
'
#
if
defined
(
XP_WIN
)
|
|
*
arg
=
=
'
/
'
#
endif
)
{
+
+
arg
;
if
(
*
arg
=
=
'
-
'
)
{
+
+
arg
;
}
if
(
strimatch
(
aArg
arg
)
)
{
if
(
aFlags
&
CheckArgFlag
:
:
RemoveArg
)
{
RemoveArg
(
aArgc
curarg
)
;
}
else
{
+
+
curarg
;
}
if
(
!
aParam
)
{
ar
=
ARG_FOUND
;
break
;
}
if
(
*
curarg
)
{
if
(
*
*
curarg
=
=
'
-
'
#
if
defined
(
XP_WIN
)
|
|
*
*
curarg
=
=
'
/
'
#
endif
)
{
return
ARG_BAD
;
}
*
aParam
=
*
curarg
;
if
(
aFlags
&
CheckArgFlag
:
:
RemoveArg
)
{
RemoveArg
(
aArgc
curarg
)
;
}
ar
=
ARG_FOUND
;
break
;
}
return
ARG_BAD
;
}
}
+
+
curarg
;
}
if
(
(
aFlags
&
CheckArgFlag
:
:
CheckOSInt
)
&
&
ar
=
=
ARG_FOUND
)
{
ArgResult
arOSInt
=
CheckArg
(
aArgc
aArgv
GetLiteral
<
CharT
FlagLiteral
:
:
osint
>
(
)
static_cast
<
const
CharT
*
*
>
(
nullptr
)
CheckArgFlag
:
:
None
)
;
if
(
arOSInt
=
=
ARG_FOUND
)
{
ar
=
ARG_BAD
;
#
if
defined
(
MOZILLA_INTERNAL_API
)
PR_fprintf
(
PR_STDERR
"
Error
:
argument
-
-
osint
is
invalid
\
n
"
)
;
#
endif
}
}
return
ar
;
}
#
if
defined
(
XP_WIN
)
namespace
internal
{
inline
int
ArgStrLen
(
const
wchar_t
*
s
)
{
int
backslashes
=
0
;
int
i
=
wcslen
(
s
)
;
bool
hasDoubleQuote
=
wcschr
(
s
L
'
"
'
)
!
=
nullptr
;
bool
addDoubleQuotes
=
wcspbrk
(
s
L
"
\
t
"
)
!
=
nullptr
;
if
(
addDoubleQuotes
)
{
i
+
=
2
;
}
if
(
hasDoubleQuote
)
{
while
(
*
s
)
{
if
(
*
s
=
=
'
\
\
'
)
{
+
+
backslashes
;
}
else
{
if
(
*
s
=
=
'
"
'
)
{
i
+
=
backslashes
+
1
;
}
backslashes
=
0
;
}
+
+
s
;
}
}
return
i
;
}
inline
wchar_t
*
ArgToString
(
wchar_t
*
d
const
wchar_t
*
s
)
{
int
backslashes
=
0
;
bool
hasDoubleQuote
=
wcschr
(
s
L
'
"
'
)
!
=
nullptr
;
bool
addDoubleQuotes
=
wcspbrk
(
s
L
"
\
t
"
)
!
=
nullptr
;
if
(
addDoubleQuotes
)
{
*
d
=
'
"
'
;
+
+
d
;
}
if
(
hasDoubleQuote
)
{
int
i
;
while
(
*
s
)
{
if
(
*
s
=
=
'
\
\
'
)
{
+
+
backslashes
;
}
else
{
if
(
*
s
=
=
'
"
'
)
{
for
(
i
=
0
;
i
<
=
backslashes
;
+
+
i
)
{
*
d
=
'
\
\
'
;
+
+
d
;
}
}
backslashes
=
0
;
}
*
d
=
*
s
;
+
+
d
;
+
+
s
;
}
}
else
{
wcscpy
(
d
s
)
;
d
+
=
wcslen
(
s
)
;
}
if
(
addDoubleQuotes
)
{
*
d
=
'
"
'
;
+
+
d
;
}
return
d
;
}
}
inline
UniquePtr
<
wchar_t
[
]
>
MakeCommandLine
(
int
argc
wchar_t
*
*
argv
)
{
int
i
;
int
len
=
0
;
for
(
i
=
0
;
i
<
argc
;
+
+
i
)
{
len
+
=
internal
:
:
ArgStrLen
(
argv
[
i
]
)
+
1
;
}
if
(
len
=
=
0
)
{
len
=
1
;
}
auto
s
=
MakeUnique
<
wchar_t
[
]
>
(
len
)
;
if
(
!
s
)
{
return
nullptr
;
}
wchar_t
*
c
=
s
.
get
(
)
;
for
(
i
=
0
;
i
<
argc
;
+
+
i
)
{
c
=
internal
:
:
ArgToString
(
c
argv
[
i
]
)
;
if
(
i
+
1
!
=
argc
)
{
*
c
=
'
'
;
+
+
c
;
}
}
*
c
=
'
\
0
'
;
return
std
:
:
move
(
s
)
;
}
inline
bool
SetArgv0ToFullBinaryPath
(
wchar_t
*
aArgv
[
]
)
{
if
(
!
aArgv
)
{
return
false
;
}
DWORD
bufLen
=
MAX_PATH
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
buf
;
DWORD
retLen
;
while
(
true
)
{
buf
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
bufLen
)
;
retLen
=
:
:
GetModuleFileNameW
(
nullptr
buf
.
get
(
)
bufLen
)
;
if
(
!
retLen
)
{
return
false
;
}
if
(
retLen
=
=
bufLen
&
&
:
:
GetLastError
(
)
=
=
ERROR_INSUFFICIENT_BUFFER
)
{
bufLen
*
=
2
;
continue
;
}
break
;
}
+
+
retLen
;
auto
newArgv_0
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
retLen
)
;
if
(
wcscpy_s
(
newArgv_0
.
get
(
)
retLen
buf
.
get
(
)
)
)
{
return
false
;
}
aArgv
[
0
]
=
newArgv_0
.
release
(
)
;
MOZ_LSAN_INTENTIONALLY_LEAK_OBJECT
(
aArgv
[
0
]
)
;
return
true
;
}
#
endif
inline
void
SaveToEnv
(
const
char
*
aEnvString
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
char
*
expr
=
strdup
(
aEnvString
)
;
if
(
expr
)
{
PR_SetEnv
(
expr
)
;
}
MOZ_LSAN_INTENTIONALLY_LEAK_OBJECT
(
expr
)
;
#
elif
defined
(
XP_WIN
)
_putenv
(
aEnvString
)
;
#
else
#
error
"
Not
implemented
for
this
configuration
"
#
endif
}
inline
bool
EnvHasValue
(
const
char
*
aVarName
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
const
char
*
val
=
PR_GetEnv
(
aVarName
)
;
return
val
&
&
*
val
;
#
elif
defined
(
XP_WIN
)
const
char
*
val
=
getenv
(
aVarName
)
;
return
val
&
&
*
val
;
#
else
#
error
"
Not
implemented
for
this
configuration
"
#
endif
}
}
#
endif
