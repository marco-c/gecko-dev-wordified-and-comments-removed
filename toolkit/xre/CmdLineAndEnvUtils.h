#
ifndef
mozilla_CmdLineAndEnvUtils_h
#
define
mozilla_CmdLineAndEnvUtils_h
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
include
"
prenv
.
h
"
#
include
"
prprf
.
h
"
#
include
<
string
.
h
>
#
endif
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
<
wchar
.
h
>
#
include
<
windows
.
h
>
#
endif
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
<
ctype
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
ifndef
NS_NO_XPCOM
#
include
"
nsIFile
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
endif
#
undef
None
namespace
mozilla
{
enum
ArgResult
{
ARG_NONE
=
0
ARG_FOUND
=
1
ARG_BAD
=
2
}
;
template
<
typename
CharT
>
inline
void
RemoveArg
(
int
&
argc
CharT
*
*
argv
)
{
do
{
*
argv
=
*
(
argv
+
1
)
;
+
+
argv
;
}
while
(
*
argv
)
;
-
-
argc
;
}
namespace
internal
{
template
<
typename
FuncT
typename
CharT
>
static
inline
bool
strimatch
(
FuncT
aToLowerFn
const
CharT
*
lowerstr
const
CharT
*
mixedstr
)
{
while
(
*
lowerstr
)
{
if
(
!
*
mixedstr
)
return
false
;
if
(
static_cast
<
CharT
>
(
aToLowerFn
(
*
mixedstr
)
)
!
=
*
lowerstr
)
return
false
;
+
+
lowerstr
;
+
+
mixedstr
;
}
if
(
*
mixedstr
)
return
false
;
return
true
;
}
}
inline
bool
strimatch
(
const
char
*
lowerstr
const
char
*
mixedstr
)
{
return
internal
:
:
strimatch
(
&
tolower
lowerstr
mixedstr
)
;
}
inline
bool
strimatch
(
const
wchar_t
*
lowerstr
const
wchar_t
*
mixedstr
)
{
return
internal
:
:
strimatch
(
&
towlower
lowerstr
mixedstr
)
;
}
const
wchar_t
kCommandLineDelimiter
[
]
=
L
"
\
t
"
;
enum
class
FlagLiteral
{
osint
safemode
}
;
template
<
typename
CharT
FlagLiteral
Literal
>
inline
const
CharT
*
GetLiteral
(
)
;
#
define
DECLARE_FLAG_LITERAL
(
enum_name
literal
)
\
template
<
>
\
inline
const
char
*
GetLiteral
<
char
FlagLiteral
:
:
enum_name
>
(
)
{
\
return
literal
;
\
}
\
\
template
<
>
\
inline
const
wchar_t
*
GetLiteral
<
wchar_t
FlagLiteral
:
:
enum_name
>
(
)
{
\
return
L
#
#
literal
;
\
}
DECLARE_FLAG_LITERAL
(
osint
"
osint
"
)
DECLARE_FLAG_LITERAL
(
safemode
"
safe
-
mode
"
)
enum
class
CheckArgFlag
:
uint32_t
{
None
=
0
RemoveArg
=
(
1
<
<
1
)
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
CheckArgFlag
)
template
<
typename
CharT
>
inline
ArgResult
CheckArg
(
int
&
aArgc
CharT
*
*
aArgv
const
CharT
*
aArg
const
CharT
*
*
aParam
=
nullptr
CheckArgFlag
aFlags
=
CheckArgFlag
:
:
RemoveArg
)
{
MOZ_ASSERT
(
aArgv
&
&
aArg
)
;
CharT
*
*
curarg
=
aArgv
+
1
;
ArgResult
ar
=
ARG_NONE
;
while
(
*
curarg
)
{
CharT
*
arg
=
curarg
[
0
]
;
if
(
arg
[
0
]
=
=
'
-
'
#
if
defined
(
XP_WIN
)
|
|
*
arg
=
=
'
/
'
#
endif
)
{
+
+
arg
;
if
(
*
arg
=
=
'
-
'
)
{
+
+
arg
;
}
if
(
strimatch
(
aArg
arg
)
)
{
if
(
aFlags
&
CheckArgFlag
:
:
RemoveArg
)
{
RemoveArg
(
aArgc
curarg
)
;
}
else
{
+
+
curarg
;
}
if
(
!
aParam
)
{
ar
=
ARG_FOUND
;
break
;
}
if
(
*
curarg
)
{
if
(
*
*
curarg
=
=
'
-
'
#
if
defined
(
XP_WIN
)
|
|
*
*
curarg
=
=
'
/
'
#
endif
)
{
return
ARG_BAD
;
}
*
aParam
=
*
curarg
;
if
(
aFlags
&
CheckArgFlag
:
:
RemoveArg
)
{
RemoveArg
(
aArgc
curarg
)
;
}
ar
=
ARG_FOUND
;
break
;
}
return
ARG_BAD
;
}
}
+
+
curarg
;
}
return
ar
;
}
template
<
typename
CharT
>
inline
bool
EnsureCommandlineSafeImpl
(
int
aArgc
CharT
*
*
aArgv
CharT
const
*
const
*
aAcceptableArgs
)
{
const
CharT
*
osintLit
=
GetLiteral
<
CharT
FlagLiteral
:
:
osint
>
(
)
;
if
(
CheckArg
(
aArgc
aArgv
osintLit
static_cast
<
const
CharT
*
*
>
(
nullptr
)
CheckArgFlag
:
:
None
)
=
=
ARG_FOUND
)
{
if
(
aArgc
!
=
4
)
{
return
false
;
}
CharT
*
arg
=
aArgv
[
1
]
;
if
(
*
arg
!
=
'
-
'
#
ifdef
XP_WIN
&
&
*
arg
!
=
'
/
'
#
endif
)
{
return
false
;
}
+
+
arg
;
if
(
*
arg
=
=
'
-
'
)
{
+
+
arg
;
}
if
(
!
strimatch
(
osintLit
arg
)
)
{
return
false
;
}
arg
=
aArgv
[
2
]
;
if
(
*
arg
!
=
'
-
'
#
ifdef
XP_WIN
&
&
*
arg
!
=
'
/
'
#
endif
)
{
return
false
;
}
+
+
arg
;
if
(
*
arg
=
=
'
-
'
)
{
+
+
arg
;
}
bool
haveAcceptableArg
=
false
;
const
CharT
*
const
*
acceptableArg
=
aAcceptableArgs
;
while
(
*
acceptableArg
)
{
if
(
strimatch
(
*
acceptableArg
arg
)
)
{
haveAcceptableArg
=
true
;
break
;
}
acceptableArg
+
+
;
}
if
(
!
haveAcceptableArg
)
{
return
false
;
}
arg
=
aArgv
[
3
]
;
if
(
*
arg
=
=
'
-
'
#
ifdef
XP_WIN
|
|
*
arg
=
=
'
/
'
#
endif
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
CharT
>
inline
void
EnsureCommandlineSafe
(
int
aArgc
CharT
*
*
aArgv
CharT
const
*
const
*
aAcceptableArgs
)
{
if
(
!
EnsureCommandlineSafeImpl
(
aArgc
aArgv
aAcceptableArgs
)
)
{
exit
(
127
)
;
}
}
#
if
defined
(
XP_WIN
)
namespace
internal
{
inline
int
ArgStrLen
(
const
wchar_t
*
s
)
{
int
backslashes
=
0
;
int
i
=
wcslen
(
s
)
;
bool
hasDoubleQuote
=
wcschr
(
s
L
'
"
'
)
!
=
nullptr
;
bool
addDoubleQuotes
=
wcspbrk
(
s
kCommandLineDelimiter
)
!
=
nullptr
;
if
(
addDoubleQuotes
)
{
i
+
=
2
;
}
if
(
hasDoubleQuote
)
{
while
(
*
s
)
{
if
(
*
s
=
=
'
\
\
'
)
{
+
+
backslashes
;
}
else
{
if
(
*
s
=
=
'
"
'
)
{
i
+
=
backslashes
+
1
;
}
backslashes
=
0
;
}
+
+
s
;
}
}
return
i
;
}
inline
wchar_t
*
ArgToString
(
wchar_t
*
d
const
wchar_t
*
s
)
{
int
backslashes
=
0
;
bool
hasDoubleQuote
=
wcschr
(
s
L
'
"
'
)
!
=
nullptr
;
bool
addDoubleQuotes
=
wcspbrk
(
s
kCommandLineDelimiter
)
!
=
nullptr
;
if
(
addDoubleQuotes
)
{
*
d
=
'
"
'
;
+
+
d
;
}
if
(
hasDoubleQuote
)
{
int
i
;
while
(
*
s
)
{
if
(
*
s
=
=
'
\
\
'
)
{
+
+
backslashes
;
}
else
{
if
(
*
s
=
=
'
"
'
)
{
for
(
i
=
0
;
i
<
=
backslashes
;
+
+
i
)
{
*
d
=
'
\
\
'
;
+
+
d
;
}
}
backslashes
=
0
;
}
*
d
=
*
s
;
+
+
d
;
+
+
s
;
}
}
else
{
wcscpy
(
d
s
)
;
d
+
=
wcslen
(
s
)
;
}
if
(
addDoubleQuotes
)
{
*
d
=
'
"
'
;
+
+
d
;
}
return
d
;
}
}
inline
UniquePtr
<
wchar_t
[
]
>
MakeCommandLine
(
int
argc
const
wchar_t
*
const
*
argv
int
aArgcExtra
=
0
const
wchar_t
*
const
*
aArgvExtra
=
nullptr
)
{
int
i
;
int
len
=
0
;
for
(
i
=
0
;
i
<
argc
;
+
+
i
)
{
len
+
=
internal
:
:
ArgStrLen
(
argv
[
i
]
)
+
1
;
}
for
(
i
=
0
;
i
<
aArgcExtra
;
+
+
i
)
{
len
+
=
internal
:
:
ArgStrLen
(
aArgvExtra
[
i
]
)
+
1
;
}
if
(
len
=
=
0
)
{
len
=
1
;
}
auto
s
=
MakeUnique
<
wchar_t
[
]
>
(
len
)
;
int
totalArgc
=
argc
+
aArgcExtra
;
wchar_t
*
c
=
s
.
get
(
)
;
for
(
i
=
0
;
i
<
argc
;
+
+
i
)
{
c
=
internal
:
:
ArgToString
(
c
argv
[
i
]
)
;
if
(
i
+
1
!
=
totalArgc
)
{
*
c
=
'
'
;
+
+
c
;
}
}
for
(
i
=
0
;
i
<
aArgcExtra
;
+
+
i
)
{
c
=
internal
:
:
ArgToString
(
c
aArgvExtra
[
i
]
)
;
if
(
i
+
1
!
=
aArgcExtra
)
{
*
c
=
'
'
;
+
+
c
;
}
}
*
c
=
'
\
0
'
;
return
s
;
}
inline
bool
SetArgv0ToFullBinaryPath
(
wchar_t
*
aArgv
[
]
)
{
if
(
!
aArgv
)
{
return
false
;
}
UniquePtr
<
wchar_t
[
]
>
newArgv_0
(
GetFullBinaryPath
(
)
)
;
if
(
!
newArgv_0
)
{
return
false
;
}
aArgv
[
0
]
=
newArgv_0
.
release
(
)
;
MOZ_LSAN_INTENTIONALLY_LEAK_OBJECT
(
aArgv
[
0
]
)
;
return
true
;
}
#
if
defined
(
MOZILLA_INTERNAL_API
)
template
<
typename
T
>
class
CommandLineParserWin
final
{
int
mArgc
;
T
*
*
mArgv
;
void
Release
(
)
{
if
(
mArgv
)
{
while
(
mArgc
)
{
delete
[
]
mArgv
[
-
-
mArgc
]
;
}
delete
[
]
mArgv
;
mArgv
=
nullptr
;
}
}
public
:
CommandLineParserWin
(
)
:
mArgc
(
0
)
mArgv
(
nullptr
)
{
}
~
CommandLineParserWin
(
)
{
Release
(
)
;
}
CommandLineParserWin
(
const
CommandLineParserWin
&
)
=
delete
;
CommandLineParserWin
(
CommandLineParserWin
&
&
)
=
delete
;
CommandLineParserWin
&
operator
=
(
const
CommandLineParserWin
&
)
=
delete
;
CommandLineParserWin
&
operator
=
(
CommandLineParserWin
&
&
)
=
delete
;
int
Argc
(
)
const
{
return
mArgc
;
}
const
T
*
const
*
Argv
(
)
const
{
return
mArgv
;
}
int
HandleCommandLine
(
const
nsTSubstring
<
T
>
&
aCmdLineString
)
{
Release
(
)
;
if
(
aCmdLineString
.
IsEmpty
(
)
)
{
return
0
;
}
int
justCounting
=
1
;
int
init
=
1
;
int
between
quoted
bSlashCount
;
const
T
*
p
;
const
T
*
const
pEnd
=
aCmdLineString
.
EndReading
(
)
;
nsTAutoString
<
T
>
arg
;
while
(
1
)
{
if
(
init
)
{
p
=
aCmdLineString
.
BeginReading
(
)
;
between
=
1
;
mArgc
=
quoted
=
bSlashCount
=
0
;
init
=
0
;
}
const
T
charCurr
=
(
p
<
pEnd
)
?
*
p
:
0
;
const
T
charNext
=
(
p
+
1
<
pEnd
)
?
*
(
p
+
1
)
:
0
;
if
(
between
)
{
if
(
charCurr
!
=
0
&
&
!
wcschr
(
kCommandLineDelimiter
charCurr
)
)
{
between
=
0
;
arg
.
Truncate
(
)
;
switch
(
charCurr
)
{
case
'
\
\
'
:
bSlashCount
=
1
;
break
;
case
'
"
'
:
quoted
=
1
;
break
;
default
:
arg
+
=
charCurr
;
break
;
}
}
else
{
}
}
else
{
if
(
charCurr
=
=
0
|
|
(
!
quoted
&
&
wcschr
(
kCommandLineDelimiter
charCurr
)
)
)
{
while
(
bSlashCount
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
-
;
}
if
(
!
justCounting
)
{
mArgv
[
mArgc
]
=
new
T
[
arg
.
Length
(
)
+
1
]
;
memcpy
(
mArgv
[
mArgc
]
arg
.
get
(
)
(
arg
.
Length
(
)
+
1
)
*
sizeof
(
T
)
)
;
}
mArgc
+
+
;
between
=
1
;
}
else
{
switch
(
charCurr
)
{
case
'
"
'
:
while
(
bSlashCount
>
1
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
=
2
;
}
if
(
bSlashCount
)
{
arg
+
=
'
"
'
;
bSlashCount
=
0
;
}
else
{
if
(
quoted
)
{
if
(
charNext
=
=
'
"
'
)
{
bSlashCount
=
1
;
}
else
{
quoted
=
0
;
}
}
else
{
quoted
=
1
;
}
}
break
;
case
'
\
\
'
:
bSlashCount
+
+
;
break
;
default
:
while
(
bSlashCount
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
-
;
}
arg
+
=
charCurr
;
break
;
}
}
}
if
(
charCurr
)
{
p
+
+
;
}
else
{
if
(
justCounting
)
{
mArgv
=
new
T
*
[
mArgc
]
;
justCounting
=
0
;
init
=
1
;
}
else
{
break
;
}
}
}
return
p
-
aCmdLineString
.
BeginReading
(
)
;
}
}
;
#
endif
#
endif
#
if
defined
(
MOZILLA_INTERNAL_API
)
|
|
defined
(
XP_WIN
)
MOZ_NEVER_INLINE
inline
void
SaveToEnv
(
const
char
*
aEnvString
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
char
*
expr
=
strdup
(
aEnvString
)
;
if
(
expr
)
{
PR_SetEnv
(
expr
)
;
}
MOZ_LSAN_INTENTIONALLY_LEAK_OBJECT
(
expr
)
;
#
elif
defined
(
XP_WIN
)
_putenv
(
aEnvString
)
;
#
endif
}
inline
bool
EnvHasValue
(
const
char
*
aVarName
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
const
char
*
val
=
PR_GetEnv
(
aVarName
)
;
return
val
&
&
*
val
;
#
elif
defined
(
XP_WIN
)
const
char
*
val
=
getenv
(
aVarName
)
;
return
val
&
&
*
val
;
#
endif
}
#
endif
#
ifndef
NS_NO_XPCOM
already_AddRefed
<
nsIFile
>
GetFileFromEnv
(
const
char
*
name
)
;
#
endif
}
#
endif
