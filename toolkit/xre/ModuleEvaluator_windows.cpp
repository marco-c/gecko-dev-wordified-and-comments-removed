#
include
"
ModuleEvaluator_windows
.
h
"
#
include
<
windows
.
h
>
#
include
<
algorithm
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
CmdLineAndEnvUtils
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
WinUtils
.
h
"
namespace
mozilla
{
static
bool
GetDirectoryName
(
const
nsCOMPtr
<
nsIFile
>
aFile
nsAString
&
aParent
)
{
nsCOMPtr
<
nsIFile
>
parentDir
;
if
(
NS_FAILED
(
aFile
-
>
GetParent
(
getter_AddRefs
(
parentDir
)
)
)
|
|
!
parentDir
)
{
return
false
;
}
if
(
NS_FAILED
(
parentDir
-
>
GetPath
(
aParent
)
)
)
{
return
false
;
}
return
true
;
}
ModuleLoadEvent
:
:
ModuleInfo
:
:
ModuleInfo
(
uintptr_t
aBase
)
:
mBase
(
aBase
)
mTrustFlags
(
ModuleTrustFlags
:
:
None
)
{
}
ModuleLoadEvent
:
:
ModuleInfo
:
:
ModuleInfo
(
const
glue
:
:
ModuleLoadEvent
:
:
ModuleInfo
&
aOther
)
:
mBase
(
aOther
.
mBase
)
mLoadDurationMS
(
Some
(
aOther
.
mLoadDurationMS
)
)
mTrustFlags
(
ModuleTrustFlags
:
:
None
)
{
if
(
aOther
.
mLdrName
)
{
mLdrName
.
Assign
(
aOther
.
mLdrName
.
get
(
)
)
;
}
if
(
aOther
.
mFullPath
)
{
nsDependentString
tempPath
(
aOther
.
mFullPath
.
get
(
)
)
;
DebugOnly
<
nsresult
>
rv
=
NS_NewLocalFile
(
tempPath
false
getter_AddRefs
(
mFile
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
bool
ModuleLoadEvent
:
:
ModuleInfo
:
:
PopulatePathInfo
(
)
{
MOZ_ASSERT
(
mBase
&
&
mLdrName
.
IsEmpty
(
)
&
&
!
mFile
)
;
if
(
!
widget
:
:
WinUtils
:
:
GetModuleFullPath
(
reinterpret_cast
<
HMODULE
>
(
mBase
)
mLdrName
)
)
{
return
false
;
}
return
NS_SUCCEEDED
(
NS_NewLocalFile
(
mLdrName
false
getter_AddRefs
(
mFile
)
)
)
;
}
bool
ModuleLoadEvent
:
:
ModuleInfo
:
:
PrepForTelemetry
(
)
{
MOZ_ASSERT
(
!
mLdrName
.
IsEmpty
(
)
&
&
mFile
)
;
if
(
mLdrName
.
IsEmpty
(
)
|
|
!
mFile
)
{
return
false
;
}
using
PathTransformFlags
=
widget
:
:
WinUtils
:
:
PathTransformFlags
;
if
(
!
widget
:
:
WinUtils
:
:
PreparePathForTelemetry
(
mLdrName
PathTransformFlags
:
:
Default
&
~
PathTransformFlags
:
:
Canonicalize
)
)
{
return
false
;
}
nsAutoString
dllFullPath
;
if
(
NS_FAILED
(
mFile
-
>
GetPath
(
dllFullPath
)
)
)
{
return
false
;
}
if
(
!
widget
:
:
WinUtils
:
:
MakeLongPath
(
dllFullPath
)
)
{
return
false
;
}
if
(
NS_FAILED
(
NS_NewLocalFile
(
dllFullPath
false
getter_AddRefs
(
mFile
)
)
)
)
{
return
false
;
}
nsAutoString
sanitized
(
dllFullPath
)
;
if
(
!
widget
:
:
WinUtils
:
:
PreparePathForTelemetry
(
sanitized
PathTransformFlags
:
:
Default
&
~
(
PathTransformFlags
:
:
Canonicalize
|
PathTransformFlags
:
:
Lengthen
)
)
)
{
return
false
;
}
mFilePathClean
=
std
:
:
move
(
sanitized
)
;
return
true
;
}
ModuleLoadEvent
:
:
ModuleLoadEvent
(
const
ModuleLoadEvent
&
aOther
CopyOption
aOption
)
:
mIsStartup
(
aOther
.
mIsStartup
)
mThreadID
(
aOther
.
mThreadID
)
mThreadName
(
aOther
.
mThreadName
)
mProcessUptimeMS
(
aOther
.
mProcessUptimeMS
)
{
Unused
<
<
mStack
.
reserve
(
aOther
.
mStack
.
length
(
)
)
;
for
(
auto
&
x
:
aOther
.
mStack
)
{
Unused
<
<
mStack
.
append
(
x
)
;
}
if
(
aOption
!
=
CopyOption
:
:
CopyWithoutModules
)
{
Unused
<
<
mModules
.
reserve
(
aOther
.
mModules
.
length
(
)
)
;
for
(
auto
&
x
:
aOther
.
mModules
)
{
Unused
<
<
mModules
.
append
(
x
)
;
}
}
}
ModuleLoadEvent
:
:
ModuleLoadEvent
(
const
glue
:
:
ModuleLoadEvent
&
aOther
)
:
mIsStartup
(
false
)
mThreadID
(
aOther
.
mThreadID
)
mProcessUptimeMS
(
aOther
.
mProcessUptimeMS
)
{
for
(
auto
&
frame
:
aOther
.
mStack
)
{
Unused
<
<
mStack
.
append
(
frame
)
;
}
for
(
auto
&
module
:
aOther
.
mModules
)
{
Unused
<
<
mModules
.
append
(
ModuleInfo
(
module
)
)
;
}
}
static
void
GetKeyboardLayoutDlls
(
Vector
<
nsString
0
InfallibleAllocPolicy
>
&
aOut
)
{
HKEY
rawKey
;
if
(
:
:
RegOpenKeyExW
(
HKEY_LOCAL_MACHINE
L
"
SYSTEM
\
\
CurrentControlSet
\
\
Control
\
\
Keyboard
Layouts
"
0
KEY_ENUMERATE_SUB_KEYS
&
rawKey
)
!
=
ERROR_SUCCESS
)
{
return
;
}
nsAutoRegKey
key
(
rawKey
)
;
DWORD
iKey
=
0
;
wchar_t
strTemp
[
MAX_PATH
]
=
{
0
}
;
while
(
true
)
{
DWORD
strTempSize
=
ArrayLength
(
strTemp
)
;
if
(
RegEnumKeyExW
(
rawKey
iKey
strTemp
&
strTempSize
nullptr
nullptr
nullptr
nullptr
)
!
=
ERROR_SUCCESS
)
{
return
;
}
iKey
+
+
;
strTempSize
=
sizeof
(
strTemp
)
;
if
(
:
:
RegGetValueW
(
rawKey
strTemp
L
"
Layout
File
"
RRF_RT_REG_SZ
nullptr
strTemp
&
strTempSize
)
=
=
ERROR_SUCCESS
)
{
nsString
ws
(
strTemp
(
strTempSize
/
sizeof
(
wchar_t
)
)
-
1
)
;
ToLowerCase
(
ws
)
;
Unused
<
<
aOut
.
emplaceBack
(
ws
)
;
}
}
}
ModuleEvaluator
:
:
ModuleEvaluator
(
)
{
GetKeyboardLayoutDlls
(
mKeyboardLayoutDlls
)
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_OS_SYSTEM_DIR
getter_AddRefs
(
mSysDirectory
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsCOMPtr
<
nsIFile
>
winSxSDir
;
rv
=
NS_GetSpecialDirectory
(
NS_WIN_WINDOWS_DIR
getter_AddRefs
(
winSxSDir
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
winSxSDir
-
>
Append
(
NS_LITERAL_STRING
(
"
WinSxS
"
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mWinSxSDirectory
=
std
:
:
move
(
winSxSDir
)
;
}
}
#
ifdef
_M_IX86
WCHAR
sysWow64Buf
[
MAX_PATH
+
1
]
=
{
}
;
UINT
sysWowLen
=
:
:
GetSystemWow64DirectoryW
(
sysWow64Buf
ArrayLength
(
sysWow64Buf
)
)
;
if
(
sysWowLen
>
0
&
&
sysWowLen
<
ArrayLength
(
sysWow64Buf
)
)
{
rv
=
NS_NewLocalFile
(
nsDependentString
(
sysWow64Buf
sysWowLen
)
false
getter_AddRefs
(
mSysWOW64Directory
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
#
endif
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
mExeDirectory
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsCOMPtr
<
nsIFile
>
exeFile
;
rv
=
XRE_GetBinaryPath
(
getter_AddRefs
(
exeFile
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoString
exePath
;
rv
=
exeFile
-
>
GetPath
(
exePath
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
ModuleVersionInfo
exeVi
;
if
(
exeVi
.
GetFromImage
(
exePath
)
)
{
mExeVersion
=
Some
(
exeVi
.
mFileVersion
.
Version64
(
)
)
;
}
}
}
}
Maybe
<
bool
>
ModuleEvaluator
:
:
IsModuleTrusted
(
ModuleLoadEvent
:
:
ModuleInfo
&
aDllInfo
const
ModuleLoadEvent
&
aEvent
Authenticode
*
aSvc
)
const
{
MOZ_ASSERT
(
aDllInfo
.
mTrustFlags
=
=
ModuleTrustFlags
:
:
None
)
;
MOZ_ASSERT
(
aDllInfo
.
mFile
)
;
nsAutoString
dllFullPath
;
if
(
NS_FAILED
(
aDllInfo
.
mFile
-
>
GetPath
(
dllFullPath
)
)
)
{
return
Nothing
(
)
;
}
if
(
aSvc
)
{
UniquePtr
<
wchar_t
[
]
>
szSignedBy
=
aSvc
-
>
GetBinaryOrgName
(
dllFullPath
.
get
(
)
)
;
if
(
szSignedBy
)
{
nsDependentString
signedBy
(
szSignedBy
.
get
(
)
)
;
if
(
signedBy
.
EqualsLiteral
(
"
Microsoft
Windows
"
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
MicrosoftWindowsSignature
;
return
Some
(
true
)
;
}
else
if
(
signedBy
.
EqualsLiteral
(
"
Microsoft
Corporation
"
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
MicrosoftWindowsSignature
;
return
Some
(
true
)
;
}
else
if
(
signedBy
.
EqualsLiteral
(
"
Mozilla
Corporation
"
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
MozillaSignature
;
return
Some
(
true
)
;
}
else
{
aDllInfo
.
mTrustFlags
=
ModuleTrustFlags
:
:
None
;
return
Some
(
false
)
;
}
}
}
nsAutoString
dllDirectory
;
if
(
!
GetDirectoryName
(
aDllInfo
.
mFile
dllDirectory
)
)
{
return
Nothing
(
)
;
}
nsAutoString
dllLeafLower
;
if
(
NS_FAILED
(
aDllInfo
.
mFile
-
>
GetLeafName
(
dllLeafLower
)
)
)
{
return
Nothing
(
)
;
}
ToLowerCase
(
dllLeafLower
)
;
if
(
dllLeafLower
.
EqualsLiteral
(
"
jitpi
.
dll
"
)
)
{
aDllInfo
.
mTrustFlags
=
ModuleTrustFlags
:
:
JitPI
;
return
Some
(
true
)
;
}
uint32_t
scoreThreshold
=
100
;
#
ifdef
ENABLE_TESTS
if
(
mozilla
:
:
EnvHasValue
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
)
{
if
(
dllLeafLower
.
EqualsLiteral
(
"
untrusted
-
startup
-
test
-
dll
.
dll
"
)
|
|
dllLeafLower
.
EqualsLiteral
(
"
modules
-
test
.
dll
"
)
)
{
scoreThreshold
=
99999
;
}
}
#
endif
nsresult
rv
;
bool
contained
;
uint32_t
score
=
0
;
if
(
score
<
scoreThreshold
)
{
rv
=
mSysDirectory
-
>
Contains
(
aDllInfo
.
mFile
&
contained
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
contained
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
SystemDirectory
;
score
+
=
50
;
}
}
#
ifdef
_M_IX86
if
(
mSysWOW64Directory
)
{
rv
=
mSysWOW64Directory
-
>
Contains
(
aDllInfo
.
mFile
&
contained
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
contained
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
SysWOW64Directory
;
score
+
=
50
;
}
}
#
endif
rv
=
mWinSxSDirectory
-
>
Contains
(
aDllInfo
.
mFile
&
contained
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
contained
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
WinSxSDirectory
;
score
+
=
50
;
}
if
(
std
:
:
find
(
mKeyboardLayoutDlls
.
begin
(
)
mKeyboardLayoutDlls
.
end
(
)
dllLeafLower
)
!
=
mKeyboardLayoutDlls
.
end
(
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
KeyboardLayout
;
score
+
=
50
;
}
if
(
score
<
scoreThreshold
)
{
ModuleVersionInfo
vi
;
if
(
vi
.
GetFromImage
(
dllFullPath
)
)
{
aDllInfo
.
mFileVersion
=
vi
.
mFileVersion
.
ToString
(
)
;
if
(
vi
.
mCompanyName
.
EqualsLiteral
(
"
Microsoft
Corporation
"
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
MicrosoftVersion
;
score
+
=
50
;
}
rv
=
mExeDirectory
-
>
Contains
(
aDllInfo
.
mFile
&
contained
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
contained
)
{
score
+
=
50
;
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
FirefoxDirectory
;
if
(
dllLeafLower
.
EqualsLiteral
(
"
xul
.
dll
"
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
Xul
;
}
if
(
mExeVersion
.
isSome
(
)
&
&
(
vi
.
mFileVersion
.
Version64
(
)
=
=
mExeVersion
.
value
(
)
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
FirefoxDirectoryAndVersion
;
score
+
=
50
;
}
}
}
}
return
Some
(
score
>
=
scoreThreshold
)
;
}
}
