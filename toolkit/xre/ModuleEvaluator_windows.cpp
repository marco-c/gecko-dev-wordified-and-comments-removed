#
include
"
ModuleEvaluator_windows
.
h
"
#
include
<
windows
.
h
>
#
include
<
algorithm
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
WinUtils
.
h
"
namespace
mozilla
{
static
bool
GetDirectoryName
(
const
nsCOMPtr
<
nsIFile
>
aFile
nsAString
&
aParent
)
{
nsCOMPtr
<
nsIFile
>
parentDir
;
if
(
NS_FAILED
(
aFile
-
>
GetParent
(
getter_AddRefs
(
parentDir
)
)
)
|
|
!
parentDir
)
{
return
false
;
}
if
(
NS_FAILED
(
parentDir
-
>
GetPath
(
aParent
)
)
)
{
return
false
;
}
return
true
;
}
ModuleLoadEvent
:
:
ModuleInfo
:
:
ModuleInfo
(
const
glue
:
:
ModuleLoadEvent
:
:
ModuleInfo
&
aOther
)
:
mBase
(
aOther
.
mBase
)
{
if
(
aOther
.
mLdrName
)
{
mLdrName
.
Assign
(
aOther
.
mLdrName
.
get
(
)
)
;
}
if
(
aOther
.
mFullPath
)
{
nsDependentString
tempPath
(
aOther
.
mFullPath
.
get
(
)
)
;
Unused
<
<
NS_NewLocalFile
(
tempPath
false
getter_AddRefs
(
mFile
)
)
;
}
}
ModuleLoadEvent
:
:
ModuleLoadEvent
(
const
ModuleLoadEvent
&
aOther
CopyOption
aOption
)
:
mIsStartup
(
aOther
.
mIsStartup
)
mThreadID
(
aOther
.
mThreadID
)
mThreadName
(
aOther
.
mThreadName
)
mProcessUptimeMS
(
aOther
.
mProcessUptimeMS
)
{
Unused
<
<
mStack
.
reserve
(
aOther
.
mStack
.
length
(
)
)
;
for
(
auto
&
x
:
aOther
.
mStack
)
{
Unused
<
<
mStack
.
append
(
x
)
;
}
if
(
aOption
!
=
CopyOption
:
:
CopyWithoutModules
)
{
Unused
<
<
mModules
.
reserve
(
aOther
.
mModules
.
length
(
)
)
;
for
(
auto
&
x
:
aOther
.
mModules
)
{
Unused
<
<
mModules
.
append
(
x
)
;
}
}
}
ModuleLoadEvent
:
:
ModuleLoadEvent
(
const
glue
:
:
ModuleLoadEvent
&
aOther
)
:
mIsStartup
(
false
)
mThreadID
(
aOther
.
mThreadID
)
mProcessUptimeMS
(
aOther
.
mProcessUptimeMS
)
{
for
(
auto
&
frame
:
aOther
.
mStack
)
{
Unused
<
<
mStack
.
append
(
frame
)
;
}
for
(
auto
&
module
:
aOther
.
mModules
)
{
Unused
<
<
mModules
.
append
(
ModuleInfo
(
module
)
)
;
}
}
static
void
GetKeyboardLayoutDlls
(
Vector
<
nsString
0
InfallibleAllocPolicy
>
&
aOut
)
{
HKEY
rawKey
;
if
(
:
:
RegOpenKeyExW
(
HKEY_LOCAL_MACHINE
L
"
SYSTEM
\
\
CurrentControlSet
\
\
Control
\
\
Keyboard
Layouts
"
0
KEY_ENUMERATE_SUB_KEYS
&
rawKey
)
!
=
ERROR_SUCCESS
)
{
return
;
}
nsAutoRegKey
key
(
rawKey
)
;
DWORD
iKey
=
0
;
wchar_t
strTemp
[
MAX_PATH
]
=
{
0
}
;
while
(
true
)
{
DWORD
strTempSize
=
ArrayLength
(
strTemp
)
;
if
(
RegEnumKeyExW
(
rawKey
iKey
strTemp
&
strTempSize
nullptr
nullptr
nullptr
nullptr
)
!
=
ERROR_SUCCESS
)
{
return
;
}
iKey
+
+
;
strTempSize
=
sizeof
(
strTemp
)
;
if
(
:
:
RegGetValueW
(
rawKey
strTemp
L
"
Layout
File
"
RRF_RT_REG_SZ
nullptr
strTemp
&
strTempSize
)
=
=
ERROR_SUCCESS
)
{
nsString
ws
(
strTemp
(
strTempSize
/
sizeof
(
wchar_t
)
)
-
1
)
;
ToLowerCase
(
ws
)
;
Unused
<
<
aOut
.
emplaceBack
(
ws
)
;
}
}
}
ModuleEvaluator
:
:
ModuleEvaluator
(
)
{
GetKeyboardLayoutDlls
(
mKeyboardLayoutDlls
)
;
nsCOMPtr
<
nsIFile
>
sysDir
;
if
(
NS_SUCCEEDED
(
NS_GetSpecialDirectory
(
NS_OS_SYSTEM_DIR
getter_AddRefs
(
sysDir
)
)
)
)
{
sysDir
-
>
GetPath
(
mSysDirectory
)
;
}
nsCOMPtr
<
nsIFile
>
exeDir
;
if
(
NS_SUCCEEDED
(
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
exeDir
)
)
)
)
{
exeDir
-
>
GetPath
(
mExeDirectory
)
;
}
nsCOMPtr
<
nsIFile
>
exeFile
;
if
(
NS_SUCCEEDED
(
XRE_GetBinaryPath
(
getter_AddRefs
(
exeFile
)
)
)
)
{
nsAutoString
exePath
;
if
(
NS_SUCCEEDED
(
exeFile
-
>
GetPath
(
exePath
)
)
)
{
ModuleVersionInfo
exeVi
;
if
(
exeVi
.
GetFromImage
(
exePath
)
)
{
mExeVersion
=
Some
(
exeVi
.
mFileVersion
.
Version64
(
)
)
;
}
}
}
}
Maybe
<
bool
>
ModuleEvaluator
:
:
IsModuleTrusted
(
ModuleLoadEvent
:
:
ModuleInfo
&
aDllInfo
const
ModuleLoadEvent
&
aEvent
Authenticode
*
aSvc
)
const
{
if
(
aDllInfo
.
mLdrName
.
EqualsLiteral
(
"
JitPI
.
dll
"
)
)
{
aDllInfo
.
mTrustFlags
=
ModuleTrustFlags
:
:
JitPI
;
return
Some
(
true
)
;
}
aDllInfo
.
mTrustFlags
=
ModuleTrustFlags
:
:
None
;
if
(
!
aDllInfo
.
mFile
)
{
return
Nothing
(
)
;
}
using
PathTransformFlags
=
widget
:
:
WinUtils
:
:
PathTransformFlags
;
Unused
<
<
widget
:
:
WinUtils
:
:
PreparePathForTelemetry
(
aDllInfo
.
mLdrName
PathTransformFlags
:
:
Default
&
~
PathTransformFlags
:
:
Canonicalize
)
;
nsAutoString
dllFullPath
;
if
(
NS_FAILED
(
aDllInfo
.
mFile
-
>
GetPath
(
dllFullPath
)
)
)
{
return
Nothing
(
)
;
}
widget
:
:
WinUtils
:
:
MakeLongPath
(
dllFullPath
)
;
aDllInfo
.
mFilePathClean
=
dllFullPath
;
if
(
!
widget
:
:
WinUtils
:
:
PreparePathForTelemetry
(
aDllInfo
.
mFilePathClean
PathTransformFlags
:
:
Default
&
~
(
PathTransformFlags
:
:
Canonicalize
|
PathTransformFlags
:
:
Lengthen
)
)
)
{
return
Nothing
(
)
;
}
if
(
NS_FAILED
(
NS_NewLocalFile
(
dllFullPath
false
getter_AddRefs
(
aDllInfo
.
mFile
)
)
)
)
{
return
Nothing
(
)
;
}
nsAutoString
dllDirectory
;
if
(
!
GetDirectoryName
(
aDllInfo
.
mFile
dllDirectory
)
)
{
return
Nothing
(
)
;
}
nsAutoString
dllLeafLower
;
if
(
NS_FAILED
(
aDllInfo
.
mFile
-
>
GetLeafName
(
dllLeafLower
)
)
)
{
return
Nothing
(
)
;
}
ToLowerCase
(
dllLeafLower
)
;
static
const
int
kScoreThreshold
=
100
;
int
score
=
0
;
if
(
!
mSysDirectory
.
IsEmpty
(
)
&
&
StringBeginsWith
(
dllFullPath
mSysDirectory
nsCaseInsensitiveStringComparator
(
)
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
SystemDirectory
;
score
+
=
50
;
}
if
(
std
:
:
find
(
mKeyboardLayoutDlls
.
begin
(
)
mKeyboardLayoutDlls
.
end
(
)
dllLeafLower
)
!
=
mKeyboardLayoutDlls
.
end
(
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
KeyboardLayout
;
score
+
=
50
;
}
if
(
score
<
kScoreThreshold
)
{
ModuleVersionInfo
vi
;
if
(
vi
.
GetFromImage
(
dllFullPath
)
)
{
aDllInfo
.
mFileVersion
=
vi
.
mFileVersion
.
ToString
(
)
;
if
(
vi
.
mCompanyName
.
EqualsLiteral
(
"
Microsoft
Corporation
"
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
MicrosoftVersion
;
score
+
=
50
;
}
if
(
!
mExeDirectory
.
IsEmpty
(
)
&
&
StringBeginsWith
(
dllFullPath
mExeDirectory
nsCaseInsensitiveStringComparator
(
)
)
)
{
score
+
=
50
;
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
FirefoxDirectory
;
if
(
mExeVersion
.
isSome
(
)
&
&
(
vi
.
mFileVersion
.
Version64
(
)
=
=
mExeVersion
.
value
(
)
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
FirefoxDirectoryAndVersion
;
score
+
=
50
;
}
}
}
}
if
(
score
<
kScoreThreshold
)
{
if
(
aSvc
)
{
UniquePtr
<
wchar_t
[
]
>
szSignedBy
=
aSvc
-
>
GetBinaryOrgName
(
dllFullPath
.
get
(
)
)
;
if
(
szSignedBy
)
{
nsAutoString
signedBy
(
szSignedBy
.
get
(
)
)
;
if
(
signedBy
.
EqualsLiteral
(
"
Microsoft
Windows
"
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
MicrosoftWindowsSignature
;
score
=
100
;
}
else
if
(
signedBy
.
EqualsLiteral
(
"
Microsoft
Corporation
"
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
MicrosoftWindowsSignature
;
score
=
100
;
}
else
if
(
signedBy
.
EqualsLiteral
(
"
Mozilla
Corporation
"
)
)
{
aDllInfo
.
mTrustFlags
|
=
ModuleTrustFlags
:
:
MozillaSignature
;
score
=
100
;
}
}
}
}
return
Some
(
score
>
=
kScoreThreshold
)
;
}
}
