#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
"
nsUpdateDriver
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsIWritablePropertyBag
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
prproces
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsVersionComparator
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Printf
.
h
"
#
ifdef
XP_MACOSX
#
include
"
nsILocalFileMac
.
h
"
#
include
"
nsCommandLineServiceMac
.
h
"
#
include
"
MacLaunchHelper
.
h
"
#
include
"
updaterfileutils_osx
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
endif
#
if
defined
(
XP_WIN
)
#
include
<
direct
.
h
>
#
include
<
process
.
h
>
#
include
<
windows
.
h
>
#
include
<
shlwapi
.
h
>
#
define
getcwd
(
path
size
)
_getcwd
(
path
size
)
#
define
getpid
(
)
GetCurrentProcessId
(
)
#
elif
defined
(
XP_UNIX
)
#
include
<
unistd
.
h
>
#
include
<
sys
/
wait
.
h
>
#
endif
using
namespace
mozilla
;
static
LazyLogModule
sUpdateLog
(
"
updatedriver
"
)
;
#
define
LOG
(
args
)
MOZ_LOG
(
sUpdateLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
ifdef
XP_WIN
#
define
UPDATER_BIN
"
updater
.
exe
"
#
elif
XP_MACOSX
#
define
UPDATER_BIN
"
org
.
mozilla
.
updater
"
#
else
#
define
UPDATER_BIN
"
updater
"
#
endif
#
define
UPDATER_INI
"
updater
.
ini
"
#
ifdef
XP_MACOSX
#
define
UPDATER_APP
"
updater
.
app
"
#
endif
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
XP_MACOSX
)
#
define
UPDATER_PNG
"
updater
.
png
"
#
endif
#
ifdef
XP_MACOSX
static
void
UpdateDriverSetupMacCommandLine
(
int
&
argc
char
*
*
&
argv
bool
restart
)
{
if
(
NS_IsMainThread
(
)
)
{
CommandLineServiceMac
:
:
SetupMacCommandLine
(
argc
argv
restart
)
;
return
;
}
Monitor
monitor
(
"
nsUpdateDriver
SetupMacCommandLine
"
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
[
&
argc
&
argv
restart
&
monitor
]
(
)
-
>
void
{
CommandLineServiceMac
:
:
SetupMacCommandLine
(
argc
argv
restart
)
;
MonitorAutoLock
(
monitor
)
.
Notify
(
)
;
}
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Update
driver
error
dispatching
SetupMacCommandLine
to
main
thread
:
%
d
\
n
"
rv
)
)
;
return
;
}
rv
=
MonitorAutoLock
(
monitor
)
.
Wait
(
PR_SecondsToInterval
(
60
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Update
driver
timed
out
waiting
for
SetupMacCommandLine
:
%
d
\
n
"
rv
)
)
;
}
}
#
endif
static
nsresult
GetCurrentWorkingDir
(
char
*
buf
size_t
size
)
{
#
if
defined
(
XP_WIN
)
wchar_t
wpath
[
MAX_PATH
]
;
if
(
!
_wgetcwd
(
wpath
size
)
)
return
NS_ERROR_FAILURE
;
NS_ConvertUTF16toUTF8
path
(
wpath
)
;
strncpy
(
buf
path
.
get
(
)
size
)
;
#
else
if
(
!
getcwd
(
buf
size
)
)
return
NS_ERROR_FAILURE
;
#
endif
return
NS_OK
;
}
static
nsresult
GetInstallDirPath
(
nsIFile
*
appDir
nsACString
&
installDirPath
)
{
nsresult
rv
;
#
ifdef
XP_MACOSX
nsCOMPtr
<
nsIFile
>
parentDir1
parentDir2
;
rv
=
appDir
-
>
GetParent
(
getter_AddRefs
(
parentDir1
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
parentDir1
-
>
GetParent
(
getter_AddRefs
(
parentDir2
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
parentDir2
-
>
GetNativePath
(
installDirPath
)
;
#
elif
XP_WIN
nsAutoString
installDirPathW
;
rv
=
appDir
-
>
GetPath
(
installDirPathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
installDirPath
=
NS_ConvertUTF16toUTF8
(
installDirPathW
)
;
#
else
rv
=
appDir
-
>
GetNativePath
(
installDirPath
)
;
#
endif
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
#
if
defined
(
XP_MACOSX
)
static
nsresult
GetXULRunnerStubPath
(
const
char
*
argv0
nsIFile
*
*
aResult
)
{
CFBundleRef
appBundle
=
:
:
CFBundleGetMainBundle
(
)
;
if
(
!
appBundle
)
return
NS_ERROR_FAILURE
;
CFURLRef
bundleURL
=
:
:
CFBundleCopyExecutableURL
(
appBundle
)
;
if
(
!
bundleURL
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsILocalFileMac
>
lfm
;
nsresult
rv
=
NS_NewLocalFileWithCFURL
(
bundleURL
true
getter_AddRefs
(
lfm
)
)
;
:
:
CFRelease
(
bundleURL
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
lfm
.
forget
(
aResult
)
;
return
NS_OK
;
}
#
endif
static
bool
GetFile
(
nsIFile
*
dir
const
nsCSubstring
&
name
nsCOMPtr
<
nsIFile
>
&
result
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
file
;
rv
=
dir
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
rv
=
file
-
>
AppendNative
(
name
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
result
=
do_QueryInterface
(
file
&
rv
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
static
bool
GetStatusFile
(
nsIFile
*
dir
nsCOMPtr
<
nsIFile
>
&
result
)
{
return
GetFile
(
dir
NS_LITERAL_CSTRING
(
"
update
.
status
"
)
result
)
;
}
template
<
size_t
Size
>
static
bool
GetStatusFileContents
(
nsIFile
*
statusFile
char
(
&
buf
)
[
Size
]
)
{
static_assert
(
Size
>
16
"
Buffer
needs
to
be
large
enough
to
hold
the
known
status
codes
"
)
;
PRFileDesc
*
fd
=
nullptr
;
nsresult
rv
=
statusFile
-
>
OpenNSPRFileDesc
(
PR_RDONLY
0660
&
fd
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
const
int32_t
n
=
PR_Read
(
fd
buf
Size
)
;
PR_Close
(
fd
)
;
return
(
n
>
=
0
)
;
}
typedef
enum
{
eNoUpdateAction
ePendingUpdate
ePendingService
ePendingElevate
eAppliedUpdate
eAppliedService
}
UpdateStatus
;
static
UpdateStatus
GetUpdateStatus
(
nsIFile
*
dir
nsCOMPtr
<
nsIFile
>
&
statusFile
)
{
if
(
GetStatusFile
(
dir
statusFile
)
)
{
char
buf
[
32
]
;
if
(
GetStatusFileContents
(
statusFile
buf
)
)
{
const
char
kPending
[
]
=
"
pending
"
;
const
char
kPendingService
[
]
=
"
pending
-
service
"
;
const
char
kPendingElevate
[
]
=
"
pending
-
elevate
"
;
const
char
kApplied
[
]
=
"
applied
"
;
const
char
kAppliedService
[
]
=
"
applied
-
service
"
;
if
(
!
strncmp
(
buf
kPendingElevate
sizeof
(
kPendingElevate
)
-
1
)
)
{
return
ePendingElevate
;
}
if
(
!
strncmp
(
buf
kPendingService
sizeof
(
kPendingService
)
-
1
)
)
{
return
ePendingService
;
}
if
(
!
strncmp
(
buf
kPending
sizeof
(
kPending
)
-
1
)
)
{
return
ePendingUpdate
;
}
if
(
!
strncmp
(
buf
kAppliedService
sizeof
(
kAppliedService
)
-
1
)
)
{
return
eAppliedService
;
}
if
(
!
strncmp
(
buf
kApplied
sizeof
(
kApplied
)
-
1
)
)
{
return
eAppliedUpdate
;
}
}
}
return
eNoUpdateAction
;
}
static
bool
GetVersionFile
(
nsIFile
*
dir
nsCOMPtr
<
nsIFile
>
&
result
)
{
return
GetFile
(
dir
NS_LITERAL_CSTRING
(
"
update
.
version
"
)
result
)
;
}
static
bool
IsOlderVersion
(
nsIFile
*
versionFile
const
char
*
appVersion
)
{
PRFileDesc
*
fd
=
nullptr
;
nsresult
rv
=
versionFile
-
>
OpenNSPRFileDesc
(
PR_RDONLY
0660
&
fd
)
;
if
(
NS_FAILED
(
rv
)
)
return
true
;
char
buf
[
32
]
;
const
int32_t
n
=
PR_Read
(
fd
buf
sizeof
(
buf
)
)
;
PR_Close
(
fd
)
;
if
(
n
<
0
)
return
false
;
if
(
buf
[
n
-
1
]
=
=
'
\
n
'
)
buf
[
n
-
1
]
=
'
\
0
'
;
const
char
kNull
[
]
=
"
null
"
;
if
(
strncmp
(
buf
kNull
sizeof
(
kNull
)
-
1
)
=
=
0
)
return
false
;
if
(
mozilla
:
:
Version
(
appVersion
)
>
buf
)
return
true
;
return
false
;
}
static
bool
CopyFileIntoUpdateDir
(
nsIFile
*
parentDir
const
nsACString
&
leaf
nsIFile
*
updateDir
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
updateDir
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
rv
=
file
-
>
AppendNative
(
leaf
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
file
-
>
Remove
(
true
)
;
rv
=
parentDir
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
rv
=
file
-
>
AppendNative
(
leaf
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
rv
=
file
-
>
CopyToNative
(
updateDir
EmptyCString
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
return
true
;
}
static
bool
CopyUpdaterIntoUpdateDir
(
nsIFile
*
greDir
nsIFile
*
appDir
nsIFile
*
updateDir
nsCOMPtr
<
nsIFile
>
&
updater
)
{
#
if
defined
(
XP_MACOSX
)
if
(
!
CopyFileIntoUpdateDir
(
appDir
NS_LITERAL_CSTRING
(
UPDATER_APP
)
updateDir
)
)
return
false
;
CopyFileIntoUpdateDir
(
greDir
NS_LITERAL_CSTRING
(
UPDATER_INI
)
updateDir
)
;
#
else
if
(
!
CopyFileIntoUpdateDir
(
greDir
NS_LITERAL_CSTRING
(
UPDATER_BIN
)
updateDir
)
)
return
false
;
CopyFileIntoUpdateDir
(
appDir
NS_LITERAL_CSTRING
(
UPDATER_INI
)
updateDir
)
;
#
endif
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
XP_MACOSX
)
&
&
!
defined
(
ANDROID
)
nsCOMPtr
<
nsIFile
>
iconDir
;
appDir
-
>
Clone
(
getter_AddRefs
(
iconDir
)
)
;
iconDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
icons
"
)
)
;
if
(
!
CopyFileIntoUpdateDir
(
iconDir
NS_LITERAL_CSTRING
(
UPDATER_PNG
)
updateDir
)
)
return
false
;
#
endif
nsresult
rv
=
updateDir
-
>
Clone
(
getter_AddRefs
(
updater
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
#
if
defined
(
XP_MACOSX
)
rv
=
updater
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
UPDATER_APP
)
)
;
nsresult
tmp
=
updater
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
Contents
"
)
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
tmp
=
updater
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
MacOS
"
)
)
;
if
(
NS_FAILED
(
tmp
)
|
|
NS_FAILED
(
rv
)
)
return
false
;
#
endif
rv
=
updater
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
UPDATER_BIN
)
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
#
if
defined
(
MOZ_VERIFY_MAR_SIGNATURE
)
&
&
!
defined
(
XP_WIN
)
&
&
!
defined
(
XP_MACOSX
)
#
include
"
prprf
.
h
"
#
define
PATH_SEPARATOR
"
:
"
#
define
LD_LIBRARY_PATH_ENVVAR_NAME
"
LD_LIBRARY_PATH
"
static
void
AppendToLibPath
(
const
char
*
pathToAppend
)
{
char
*
pathValue
=
getenv
(
LD_LIBRARY_PATH_ENVVAR_NAME
)
;
if
(
nullptr
=
=
pathValue
|
|
'
\
0
'
=
=
*
pathValue
)
{
char
*
s
=
Smprintf
(
"
%
s
=
%
s
"
LD_LIBRARY_PATH_ENVVAR_NAME
pathToAppend
)
.
release
(
)
;
PR_SetEnv
(
s
)
;
}
else
if
(
!
strstr
(
pathValue
pathToAppend
)
)
{
char
*
s
=
Smprintf
(
"
%
s
=
%
s
"
PATH_SEPARATOR
"
%
s
"
LD_LIBRARY_PATH_ENVVAR_NAME
pathToAppend
pathValue
)
.
release
(
)
;
PR_SetEnv
(
s
)
;
}
}
#
endif
static
void
ApplyUpdate
(
nsIFile
*
greDir
nsIFile
*
updateDir
nsIFile
*
appDir
int
appArgc
char
*
*
appArgv
bool
restart
bool
isStaged
ProcessType
*
outpid
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
updater
;
nsAutoCString
updaterPath
;
nsAutoCString
updateDirPath
;
#
if
defined
(
XP_WIN
)
if
(
!
GetFile
(
greDir
NS_LITERAL_CSTRING
(
UPDATER_BIN
)
updater
)
)
{
return
;
}
nsAutoString
updaterPathW
;
rv
=
updater
-
>
GetPath
(
updaterPathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
updaterPath
=
NS_ConvertUTF16toUTF8
(
updaterPathW
)
;
nsAutoString
updateDirPathW
;
rv
=
updateDir
-
>
GetPath
(
updateDirPathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
updateDirPath
=
NS_ConvertUTF16toUTF8
(
updateDirPathW
)
;
#
else
if
(
isStaged
)
{
nsCOMPtr
<
nsIFile
>
mozUpdaterDir
;
rv
=
updateDir
-
>
Clone
(
getter_AddRefs
(
mozUpdaterDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
failed
cloning
update
dir
\
n
"
)
)
;
return
;
}
mozUpdaterDir
-
>
Append
(
NS_LITERAL_STRING
(
"
MozUpdater
"
)
)
;
mozUpdaterDir
-
>
Append
(
NS_LITERAL_STRING
(
"
bgupdate
"
)
)
;
rv
=
mozUpdaterDir
-
>
CreateUnique
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
failed
creating
unique
dir
\
n
"
)
)
;
return
;
}
if
(
!
CopyUpdaterIntoUpdateDir
(
greDir
appDir
mozUpdaterDir
updater
)
)
{
LOG
(
(
"
failed
copying
updater
\
n
"
)
)
;
return
;
}
}
else
{
if
(
!
CopyUpdaterIntoUpdateDir
(
greDir
appDir
updateDir
updater
)
)
{
LOG
(
(
"
failed
copying
updater
\
n
"
)
)
;
return
;
}
}
rv
=
updater
-
>
GetNativePath
(
updaterPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
updateDir
-
>
GetNativePath
(
updateDirPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
#
endif
nsAutoCString
appFilePath
;
char
workingDirPath
[
MAXPATHLEN
]
;
if
(
restart
)
{
rv
=
GetCurrentWorkingDir
(
workingDirPath
sizeof
(
workingDirPath
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsIFile
>
appFile
;
#
if
defined
(
XP_MACOSX
)
GetXULRunnerStubPath
(
appArgv
[
0
]
getter_AddRefs
(
appFile
)
)
;
#
else
XRE_GetBinaryPath
(
appArgv
[
0
]
getter_AddRefs
(
appFile
)
)
;
#
endif
if
(
!
appFile
)
{
return
;
}
#
if
defined
(
XP_WIN
)
nsAutoString
appFilePathW
;
rv
=
appFile
-
>
GetPath
(
appFilePathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
appFilePath
=
NS_ConvertUTF16toUTF8
(
appFilePathW
)
;
#
else
rv
=
appFile
-
>
GetNativePath
(
appFilePath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
#
endif
}
nsAutoCString
installDirPath
;
rv
=
GetInstallDirPath
(
appDir
installDirPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsAutoCString
applyToDirPath
;
nsCOMPtr
<
nsIFile
>
updatedDir
;
if
(
restart
&
&
!
isStaged
)
{
applyToDirPath
.
Assign
(
installDirPath
)
;
}
else
{
#
if
defined
(
XP_MACOSX
)
if
(
!
GetFile
(
updateDir
NS_LITERAL_CSTRING
(
"
Updated
.
app
"
)
updatedDir
)
)
{
#
else
if
(
!
GetFile
(
appDir
NS_LITERAL_CSTRING
(
"
updated
"
)
updatedDir
)
)
{
#
endif
return
;
}
#
if
defined
(
XP_WIN
)
nsAutoString
applyToDirPathW
;
rv
=
updatedDir
-
>
GetPath
(
applyToDirPathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
applyToDirPath
=
NS_ConvertUTF16toUTF8
(
applyToDirPathW
)
;
rv
=
updatedDir
-
>
GetNativePath
(
applyToDirPath
)
;
#
else
rv
=
updatedDir
-
>
GetNativePath
(
applyToDirPath
)
;
#
endif
}
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
restart
&
&
isStaged
)
{
bool
updatedDirExists
=
false
;
if
(
NS_FAILED
(
updatedDir
-
>
Exists
(
&
updatedDirExists
)
)
|
|
!
updatedDirExists
)
{
return
;
}
}
nsAutoCString
pid
;
if
(
restart
)
{
#
if
defined
(
XP_UNIX
)
&
!
defined
(
XP_MACOSX
)
pid
.
AssignASCII
(
"
0
"
)
;
#
else
pid
.
AppendInt
(
(
int32_t
)
getpid
(
)
)
;
#
endif
if
(
isStaged
)
{
pid
.
AppendLiteral
(
"
/
replace
"
)
;
}
}
else
{
pid
.
AssignASCII
(
"
-
1
"
)
;
}
int
argc
=
5
;
if
(
restart
)
{
argc
=
appArgc
+
6
;
}
char
*
*
argv
=
new
char
*
[
argc
+
1
]
;
if
(
!
argv
)
{
return
;
}
argv
[
0
]
=
(
char
*
)
updaterPath
.
get
(
)
;
argv
[
1
]
=
(
char
*
)
updateDirPath
.
get
(
)
;
argv
[
2
]
=
(
char
*
)
installDirPath
.
get
(
)
;
argv
[
3
]
=
(
char
*
)
applyToDirPath
.
get
(
)
;
argv
[
4
]
=
(
char
*
)
pid
.
get
(
)
;
if
(
restart
&
&
appArgc
)
{
argv
[
5
]
=
workingDirPath
;
argv
[
6
]
=
(
char
*
)
appFilePath
.
get
(
)
;
for
(
int
i
=
1
;
i
<
appArgc
;
+
+
i
)
{
argv
[
6
+
i
]
=
appArgv
[
i
]
;
}
argv
[
argc
]
=
nullptr
;
}
else
{
argv
[
5
]
=
nullptr
;
}
if
(
restart
&
&
gSafeMode
)
{
PR_SetEnv
(
"
MOZ_SAFE_MODE_RESTART
=
1
"
)
;
}
#
if
defined
(
MOZ_VERIFY_MAR_SIGNATURE
)
&
&
!
defined
(
XP_WIN
)
&
&
!
defined
(
XP_MACOSX
)
AppendToLibPath
(
installDirPath
.
get
(
)
)
;
#
endif
LOG
(
(
"
spawning
updater
process
[
%
s
]
\
n
"
updaterPath
.
get
(
)
)
)
;
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
XP_MACOSX
)
if
(
restart
)
{
exit
(
execv
(
updaterPath
.
get
(
)
argv
)
)
;
}
*
outpid
=
fork
(
)
;
if
(
*
outpid
=
=
-
1
)
{
return
;
}
else
if
(
*
outpid
=
=
0
)
{
exit
(
execv
(
updaterPath
.
get
(
)
argv
)
)
;
}
#
elif
defined
(
XP_WIN
)
if
(
isStaged
)
{
if
(
!
WinLaunchChild
(
updaterPathW
.
get
(
)
argc
argv
)
)
{
return
;
}
}
else
{
if
(
!
WinLaunchChild
(
updaterPathW
.
get
(
)
argc
argv
nullptr
outpid
)
)
{
return
;
}
}
#
elif
defined
(
XP_MACOSX
)
UpdateDriverSetupMacCommandLine
(
argc
argv
restart
)
;
if
(
isStaged
)
{
LaunchChildMac
(
argc
argv
)
;
}
else
{
LaunchChildMac
(
argc
argv
outpid
)
;
}
#
else
if
(
isStaged
)
{
PR_CreateProcessDetached
(
updaterPath
.
get
(
)
argv
nullptr
nullptr
)
;
}
else
{
*
outpid
=
PR_CreateProcess
(
updaterPath
.
get
(
)
argv
nullptr
nullptr
)
;
}
#
endif
#
if
!
defined
(
USE_EXECV
)
if
(
restart
)
{
exit
(
0
)
;
}
#
endif
}
static
bool
ProcessHasTerminated
(
ProcessType
pt
)
{
#
if
defined
(
XP_WIN
)
if
(
WaitForSingleObject
(
pt
1000
)
)
{
return
false
;
}
CloseHandle
(
pt
)
;
return
true
;
#
elif
defined
(
XP_MACOSX
)
return
true
;
#
elif
defined
(
XP_UNIX
)
int
exitStatus
;
pid_t
exited
=
waitpid
(
pt
&
exitStatus
WNOHANG
)
;
if
(
exited
=
=
0
)
{
sleep
(
1
)
;
return
false
;
}
if
(
exited
=
=
-
1
)
{
LOG
(
(
"
Error
while
checking
if
the
updater
process
is
finished
"
)
)
;
return
true
;
}
if
(
WIFEXITED
(
exitStatus
)
&
&
(
WEXITSTATUS
(
exitStatus
)
!
=
0
)
)
{
LOG
(
(
"
Error
while
running
the
updater
process
check
update
.
log
"
)
)
;
}
return
true
;
#
else
int32_t
exitCode
;
PR_WaitProcess
(
pt
&
exitCode
)
;
if
(
exitCode
!
=
0
)
{
LOG
(
(
"
Error
while
running
the
updater
process
check
update
.
log
"
)
)
;
}
return
true
;
#
endif
}
nsresult
ProcessUpdates
(
nsIFile
*
greDir
nsIFile
*
appDir
nsIFile
*
updRootDir
int
argc
char
*
*
argv
const
char
*
appVersion
bool
restart
ProcessType
*
pid
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
updatesDir
;
rv
=
updRootDir
-
>
Clone
(
getter_AddRefs
(
updatesDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
updatesDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
updates
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
updatesDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
0
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
versionFile
;
if
(
!
GetVersionFile
(
updatesDir
versionFile
)
|
|
IsOlderVersion
(
versionFile
appVersion
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
statusFile
;
UpdateStatus
status
=
GetUpdateStatus
(
updatesDir
statusFile
)
;
switch
(
status
)
{
case
ePendingElevate
:
{
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIUpdatePrompt
>
up
=
do_GetService
(
"
mozilla
.
org
/
updates
/
update
-
prompt
;
1
"
)
;
if
(
up
)
{
up
-
>
ShowUpdateElevationRequired
(
)
;
}
break
;
}
MOZ_FALLTHROUGH
;
}
case
ePendingUpdate
:
case
ePendingService
:
{
ApplyUpdate
(
greDir
updatesDir
appDir
argc
argv
restart
false
pid
)
;
break
;
}
case
eAppliedUpdate
:
case
eAppliedService
:
ApplyUpdate
(
greDir
updatesDir
appDir
argc
argv
restart
true
pid
)
;
break
;
case
eNoUpdateAction
:
break
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsUpdateProcessor
nsIUpdateProcessor
)
nsUpdateProcessor
:
:
nsUpdateProcessor
(
)
:
mUpdaterPID
(
0
)
{
}
nsUpdateProcessor
:
:
~
nsUpdateProcessor
(
)
{
}
NS_IMETHODIMP
nsUpdateProcessor
:
:
ProcessUpdate
(
nsIUpdate
*
aUpdate
)
{
nsresult
rv
;
nsCOMPtr
<
nsIProperties
>
ds
=
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
exeFile
;
rv
=
ds
-
>
Get
(
XRE_EXECUTABLE_FILE
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
exeFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
appDir
;
rv
=
exeFile
-
>
GetParent
(
getter_AddRefs
(
appDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
greDir
;
rv
=
ds
-
>
Get
(
NS_GRE_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
greDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
updRoot
;
rv
=
ds
-
>
Get
(
XRE_UPDATE_ROOT_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
updRoot
)
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Can
'
t
get
the
UpdRootD
dir
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
appDir
-
>
Clone
(
getter_AddRefs
(
updRoot
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
appVersion
;
rv
=
appInfo
-
>
GetVersion
(
appVersion
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mInfo
.
mGREDir
=
greDir
;
mInfo
.
mAppDir
=
appDir
;
mInfo
.
mUpdateRoot
=
updRoot
;
mInfo
.
mArgc
=
0
;
mInfo
.
mArgv
=
nullptr
;
mInfo
.
mAppVersion
=
appVersion
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
not
main
thread
"
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NewRunnableMethod
(
this
&
nsUpdateProcessor
:
:
StartStagedUpdate
)
;
return
NS_NewNamedThread
(
"
Update
Watcher
"
getter_AddRefs
(
mProcessWatcher
)
r
)
;
}
void
nsUpdateProcessor
:
:
StartStagedUpdate
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
main
thread
"
)
;
nsresult
rv
=
ProcessUpdates
(
mInfo
.
mGREDir
mInfo
.
mAppDir
mInfo
.
mUpdateRoot
mInfo
.
mArgc
mInfo
.
mArgv
mInfo
.
mAppVersion
.
get
(
)
false
&
mUpdaterPID
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
mUpdaterPID
)
{
rv
=
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
this
&
nsUpdateProcessor
:
:
WaitForProcess
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
else
{
rv
=
NS_DispatchToMainThread
(
NewRunnableMethod
(
this
&
nsUpdateProcessor
:
:
ShutdownWatcherThread
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
}
void
nsUpdateProcessor
:
:
ShutdownWatcherThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
not
main
thread
"
)
;
mProcessWatcher
-
>
Shutdown
(
)
;
mProcessWatcher
=
nullptr
;
}
void
nsUpdateProcessor
:
:
WaitForProcess
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
main
thread
"
)
;
if
(
ProcessHasTerminated
(
mUpdaterPID
)
)
{
NS_DispatchToMainThread
(
NewRunnableMethod
(
this
&
nsUpdateProcessor
:
:
UpdateDone
)
)
;
}
else
{
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
this
&
nsUpdateProcessor
:
:
WaitForProcess
)
)
;
}
}
void
nsUpdateProcessor
:
:
UpdateDone
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
not
main
thread
"
)
;
nsCOMPtr
<
nsIUpdateManager
>
um
=
do_GetService
(
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
)
;
if
(
um
)
{
um
-
>
RefreshUpdateStatus
(
)
;
}
ShutdownWatcherThread
(
)
;
}
