#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
"
nsUpdateDriver
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsIWritablePropertyBag
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
prproces
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsVersionComparator
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Printf
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
ifdef
XP_MACOSX
#
include
"
nsILocalFileMac
.
h
"
#
include
"
nsCommandLineServiceMac
.
h
"
#
include
"
MacLaunchHelper
.
h
"
#
include
"
updaterfileutils_osx
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
endif
#
if
defined
(
XP_WIN
)
#
include
<
direct
.
h
>
#
include
<
process
.
h
>
#
include
<
windows
.
h
>
#
include
<
shlwapi
.
h
>
#
include
"
commonupdatedir
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
define
getcwd
(
path
size
)
_getcwd
(
path
size
)
#
define
getpid
(
)
GetCurrentProcessId
(
)
#
elif
defined
(
XP_UNIX
)
#
include
<
unistd
.
h
>
#
include
<
sys
/
wait
.
h
>
#
endif
using
namespace
mozilla
;
static
LazyLogModule
sUpdateLog
(
"
updatedriver
"
)
;
#
define
LOG
(
args
)
MOZ_LOG
(
sUpdateLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
ifdef
XP_WIN
#
define
UPDATER_BIN
"
updater
.
exe
"
#
define
MAINTENANCE_SVC_NAME
L
"
MozillaMaintenance
"
#
elif
XP_MACOSX
#
define
UPDATER_BIN
"
org
.
mozilla
.
updater
"
#
else
#
define
UPDATER_BIN
"
updater
"
#
endif
#
define
UPDATER_INI
"
updater
.
ini
"
#
ifdef
XP_MACOSX
#
define
UPDATER_APP
"
updater
.
app
"
#
endif
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
XP_MACOSX
)
#
define
UPDATER_PNG
"
updater
.
png
"
#
endif
#
ifdef
XP_MACOSX
static
void
UpdateDriverSetupMacCommandLine
(
int
&
argc
char
*
*
&
argv
bool
restart
)
{
if
(
NS_IsMainThread
(
)
)
{
CommandLineServiceMac
:
:
SetupMacCommandLine
(
argc
argv
restart
)
;
return
;
}
Monitor
monitor
(
"
nsUpdateDriver
SetupMacCommandLine
"
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
UpdateDriverSetupMacCommandLine
"
[
&
argc
&
argv
restart
&
monitor
]
(
)
-
>
void
{
CommandLineServiceMac
:
:
SetupMacCommandLine
(
argc
argv
restart
)
;
MonitorAutoLock
(
monitor
)
.
Notify
(
)
;
}
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Update
driver
error
dispatching
SetupMacCommandLine
to
main
thread
:
"
"
%
d
\
n
"
rv
)
)
;
return
;
}
CVStatus
status
=
MonitorAutoLock
(
monitor
)
.
Wait
(
TimeDuration
:
:
FromSeconds
(
60
)
)
;
if
(
status
=
=
CVStatus
:
:
Timeout
)
{
LOG
(
(
"
Update
driver
timed
out
waiting
for
SetupMacCommandLine
\
n
"
)
)
;
}
}
#
endif
static
nsresult
GetCurrentWorkingDir
(
char
*
buf
size_t
size
)
{
#
if
defined
(
XP_WIN
)
wchar_t
wpath
[
MAX_PATH
]
;
if
(
!
_wgetcwd
(
wpath
size
)
)
return
NS_ERROR_FAILURE
;
NS_ConvertUTF16toUTF8
path
(
wpath
)
;
strncpy
(
buf
path
.
get
(
)
size
)
;
#
else
if
(
!
getcwd
(
buf
size
)
)
return
NS_ERROR_FAILURE
;
#
endif
return
NS_OK
;
}
static
nsresult
GetInstallDirPath
(
nsIFile
*
appDir
nsACString
&
installDirPath
)
{
nsresult
rv
;
#
ifdef
XP_MACOSX
nsCOMPtr
<
nsIFile
>
parentDir1
parentDir2
;
rv
=
appDir
-
>
GetParent
(
getter_AddRefs
(
parentDir1
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
parentDir1
-
>
GetParent
(
getter_AddRefs
(
parentDir2
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
parentDir2
-
>
GetNativePath
(
installDirPath
)
;
#
elif
XP_WIN
nsAutoString
installDirPathW
;
rv
=
appDir
-
>
GetPath
(
installDirPathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
installDirPath
=
NS_ConvertUTF16toUTF8
(
installDirPathW
)
;
#
else
rv
=
appDir
-
>
GetNativePath
(
installDirPath
)
;
#
endif
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
static
bool
GetFile
(
nsIFile
*
dir
const
nsACString
&
name
nsCOMPtr
<
nsIFile
>
&
result
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
file
;
rv
=
dir
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
rv
=
file
-
>
AppendNative
(
name
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
result
=
file
;
return
true
;
}
static
bool
GetStatusFile
(
nsIFile
*
dir
nsCOMPtr
<
nsIFile
>
&
result
)
{
return
GetFile
(
dir
NS_LITERAL_CSTRING
(
"
update
.
status
"
)
result
)
;
}
template
<
size_t
Size
>
static
bool
GetStatusFileContents
(
nsIFile
*
statusFile
char
(
&
buf
)
[
Size
]
)
{
static_assert
(
Size
>
16
"
Buffer
needs
to
be
large
enough
to
hold
the
known
status
codes
"
)
;
PRFileDesc
*
fd
=
nullptr
;
nsresult
rv
=
statusFile
-
>
OpenNSPRFileDesc
(
PR_RDONLY
0660
&
fd
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
const
int32_t
n
=
PR_Read
(
fd
buf
Size
)
;
PR_Close
(
fd
)
;
return
(
n
>
=
0
)
;
}
typedef
enum
{
eNoUpdateAction
ePendingUpdate
ePendingService
ePendingElevate
eAppliedUpdate
eAppliedService
}
UpdateStatus
;
static
UpdateStatus
GetUpdateStatus
(
nsIFile
*
dir
nsCOMPtr
<
nsIFile
>
&
statusFile
)
{
if
(
GetStatusFile
(
dir
statusFile
)
)
{
char
buf
[
32
]
;
if
(
GetStatusFileContents
(
statusFile
buf
)
)
{
const
char
kPending
[
]
=
"
pending
"
;
const
char
kPendingService
[
]
=
"
pending
-
service
"
;
const
char
kPendingElevate
[
]
=
"
pending
-
elevate
"
;
const
char
kApplied
[
]
=
"
applied
"
;
const
char
kAppliedService
[
]
=
"
applied
-
service
"
;
if
(
!
strncmp
(
buf
kPendingElevate
sizeof
(
kPendingElevate
)
-
1
)
)
{
return
ePendingElevate
;
}
if
(
!
strncmp
(
buf
kPendingService
sizeof
(
kPendingService
)
-
1
)
)
{
return
ePendingService
;
}
if
(
!
strncmp
(
buf
kPending
sizeof
(
kPending
)
-
1
)
)
{
return
ePendingUpdate
;
}
if
(
!
strncmp
(
buf
kAppliedService
sizeof
(
kAppliedService
)
-
1
)
)
{
return
eAppliedService
;
}
if
(
!
strncmp
(
buf
kApplied
sizeof
(
kApplied
)
-
1
)
)
{
return
eAppliedUpdate
;
}
}
}
return
eNoUpdateAction
;
}
static
bool
GetVersionFile
(
nsIFile
*
dir
nsCOMPtr
<
nsIFile
>
&
result
)
{
return
GetFile
(
dir
NS_LITERAL_CSTRING
(
"
update
.
version
"
)
result
)
;
}
static
bool
IsOlderVersion
(
nsIFile
*
versionFile
const
char
*
appVersion
)
{
PRFileDesc
*
fd
=
nullptr
;
nsresult
rv
=
versionFile
-
>
OpenNSPRFileDesc
(
PR_RDONLY
0660
&
fd
)
;
if
(
NS_FAILED
(
rv
)
)
return
true
;
char
buf
[
32
]
;
const
int32_t
n
=
PR_Read
(
fd
buf
sizeof
(
buf
)
)
;
PR_Close
(
fd
)
;
if
(
n
<
0
)
return
false
;
if
(
buf
[
n
-
1
]
=
=
'
\
n
'
)
buf
[
n
-
1
]
=
'
\
0
'
;
const
char
kNull
[
]
=
"
null
"
;
if
(
strncmp
(
buf
kNull
sizeof
(
kNull
)
-
1
)
=
=
0
)
return
false
;
if
(
mozilla
:
:
Version
(
appVersion
)
>
buf
)
return
true
;
return
false
;
}
#
if
!
defined
(
XP_WIN
)
static
bool
CopyFileIntoUpdateDir
(
nsIFile
*
parentDir
const
nsACString
&
leaf
nsIFile
*
updateDir
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
updateDir
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
rv
=
file
-
>
AppendNative
(
leaf
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
file
-
>
Remove
(
true
)
;
rv
=
parentDir
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
rv
=
file
-
>
AppendNative
(
leaf
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
rv
=
file
-
>
CopyToNative
(
updateDir
EmptyCString
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
return
true
;
}
static
bool
CopyUpdaterIntoUpdateDir
(
nsIFile
*
greDir
nsIFile
*
appDir
nsIFile
*
updateDir
nsCOMPtr
<
nsIFile
>
&
updater
)
{
#
if
defined
(
XP_MACOSX
)
if
(
!
CopyFileIntoUpdateDir
(
appDir
NS_LITERAL_CSTRING
(
UPDATER_APP
)
updateDir
)
)
return
false
;
CopyFileIntoUpdateDir
(
greDir
NS_LITERAL_CSTRING
(
UPDATER_INI
)
updateDir
)
;
#
else
if
(
!
CopyFileIntoUpdateDir
(
greDir
NS_LITERAL_CSTRING
(
UPDATER_BIN
)
updateDir
)
)
return
false
;
CopyFileIntoUpdateDir
(
appDir
NS_LITERAL_CSTRING
(
UPDATER_INI
)
updateDir
)
;
#
endif
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
XP_MACOSX
)
&
&
!
defined
(
ANDROID
)
nsCOMPtr
<
nsIFile
>
iconDir
;
appDir
-
>
Clone
(
getter_AddRefs
(
iconDir
)
)
;
iconDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
icons
"
)
)
;
if
(
!
CopyFileIntoUpdateDir
(
iconDir
NS_LITERAL_CSTRING
(
UPDATER_PNG
)
updateDir
)
)
return
false
;
#
endif
nsresult
rv
=
updateDir
-
>
Clone
(
getter_AddRefs
(
updater
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
#
if
defined
(
XP_MACOSX
)
rv
=
updater
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
UPDATER_APP
)
)
;
nsresult
tmp
=
updater
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
Contents
"
)
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
tmp
=
updater
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
MacOS
"
)
)
;
if
(
NS_FAILED
(
tmp
)
|
|
NS_FAILED
(
rv
)
)
return
false
;
#
endif
rv
=
updater
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
UPDATER_BIN
)
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
#
endif
#
if
defined
(
MOZ_VERIFY_MAR_SIGNATURE
)
&
&
!
defined
(
XP_WIN
)
&
&
!
defined
(
XP_MACOSX
)
#
include
"
prprf
.
h
"
#
define
PATH_SEPARATOR
"
:
"
#
define
LD_LIBRARY_PATH_ENVVAR_NAME
"
LD_LIBRARY_PATH
"
static
void
AppendToLibPath
(
const
char
*
pathToAppend
)
{
char
*
pathValue
=
getenv
(
LD_LIBRARY_PATH_ENVVAR_NAME
)
;
if
(
nullptr
=
=
pathValue
|
|
'
\
0
'
=
=
*
pathValue
)
{
char
*
s
=
Smprintf
(
"
%
s
=
%
s
"
LD_LIBRARY_PATH_ENVVAR_NAME
pathToAppend
)
.
release
(
)
;
PR_SetEnv
(
s
)
;
}
else
if
(
!
strstr
(
pathValue
pathToAppend
)
)
{
char
*
s
=
Smprintf
(
"
%
s
=
%
s
"
PATH_SEPARATOR
"
%
s
"
LD_LIBRARY_PATH_ENVVAR_NAME
pathToAppend
pathValue
)
.
release
(
)
;
PR_SetEnv
(
s
)
;
}
}
#
endif
static
void
ApplyUpdate
(
nsIFile
*
greDir
nsIFile
*
updateDir
nsIFile
*
appDir
int
appArgc
char
*
*
appArgv
bool
restart
bool
isStaged
ProcessType
*
outpid
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
updater
;
nsAutoCString
updaterPath
;
nsAutoCString
updateDirPath
;
#
if
defined
(
XP_WIN
)
if
(
!
GetFile
(
greDir
NS_LITERAL_CSTRING
(
UPDATER_BIN
)
updater
)
)
{
return
;
}
nsAutoString
updaterPathW
;
rv
=
updater
-
>
GetPath
(
updaterPathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
updaterPath
=
NS_ConvertUTF16toUTF8
(
updaterPathW
)
;
nsAutoString
updateDirPathW
;
rv
=
updateDir
-
>
GetPath
(
updateDirPathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
updateDirPath
=
NS_ConvertUTF16toUTF8
(
updateDirPathW
)
;
#
else
if
(
isStaged
)
{
nsCOMPtr
<
nsIFile
>
mozUpdaterDir
;
rv
=
updateDir
-
>
Clone
(
getter_AddRefs
(
mozUpdaterDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
failed
cloning
update
dir
\
n
"
)
)
;
return
;
}
mozUpdaterDir
-
>
Append
(
NS_LITERAL_STRING
(
"
MozUpdater
"
)
)
;
mozUpdaterDir
-
>
Append
(
NS_LITERAL_STRING
(
"
bgupdate
"
)
)
;
rv
=
mozUpdaterDir
-
>
CreateUnique
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
failed
creating
unique
dir
\
n
"
)
)
;
return
;
}
if
(
!
CopyUpdaterIntoUpdateDir
(
greDir
appDir
mozUpdaterDir
updater
)
)
{
LOG
(
(
"
failed
copying
updater
\
n
"
)
)
;
return
;
}
}
else
{
if
(
!
CopyUpdaterIntoUpdateDir
(
greDir
appDir
updateDir
updater
)
)
{
LOG
(
(
"
failed
copying
updater
\
n
"
)
)
;
return
;
}
}
rv
=
updater
-
>
GetNativePath
(
updaterPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
updateDir
-
>
GetNativePath
(
updateDirPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
#
endif
nsAutoCString
appFilePath
;
char
workingDirPath
[
MAXPATHLEN
]
;
if
(
restart
)
{
rv
=
GetCurrentWorkingDir
(
workingDirPath
sizeof
(
workingDirPath
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsIFile
>
appFile
;
XRE_GetBinaryPath
(
getter_AddRefs
(
appFile
)
)
;
if
(
!
appFile
)
{
return
;
}
#
if
defined
(
XP_WIN
)
nsAutoString
appFilePathW
;
rv
=
appFile
-
>
GetPath
(
appFilePathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
appFilePath
=
NS_ConvertUTF16toUTF8
(
appFilePathW
)
;
#
else
rv
=
appFile
-
>
GetNativePath
(
appFilePath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
#
endif
}
nsAutoCString
installDirPath
;
rv
=
GetInstallDirPath
(
appDir
installDirPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsAutoCString
applyToDirPath
;
nsCOMPtr
<
nsIFile
>
updatedDir
;
if
(
restart
&
&
!
isStaged
)
{
applyToDirPath
.
Assign
(
installDirPath
)
;
}
else
{
#
if
defined
(
XP_MACOSX
)
if
(
!
GetFile
(
updateDir
NS_LITERAL_CSTRING
(
"
Updated
.
app
"
)
updatedDir
)
)
{
#
else
if
(
!
GetFile
(
appDir
NS_LITERAL_CSTRING
(
"
updated
"
)
updatedDir
)
)
{
#
endif
return
;
}
#
if
defined
(
XP_WIN
)
nsAutoString
applyToDirPathW
;
rv
=
updatedDir
-
>
GetPath
(
applyToDirPathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
applyToDirPath
=
NS_ConvertUTF16toUTF8
(
applyToDirPathW
)
;
#
else
rv
=
updatedDir
-
>
GetNativePath
(
applyToDirPath
)
;
#
endif
}
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
restart
&
&
isStaged
)
{
bool
updatedDirExists
=
false
;
if
(
NS_FAILED
(
updatedDir
-
>
Exists
(
&
updatedDirExists
)
)
|
|
!
updatedDirExists
)
{
return
;
}
}
nsAutoCString
pid
;
if
(
restart
)
{
#
if
defined
(
XP_UNIX
)
&
!
defined
(
XP_MACOSX
)
pid
.
AssignLiteral
(
"
0
"
)
;
#
else
pid
.
AppendInt
(
(
int32_t
)
getpid
(
)
)
;
#
endif
if
(
isStaged
)
{
pid
.
AppendLiteral
(
"
/
replace
"
)
;
}
}
else
{
pid
.
AssignLiteral
(
"
-
1
"
)
;
}
int
argc
=
5
;
if
(
restart
)
{
argc
=
appArgc
+
6
;
if
(
gRestartedByOS
)
{
argc
+
=
1
;
}
}
char
*
*
argv
=
new
char
*
[
argc
+
1
]
;
if
(
!
argv
)
{
return
;
}
argv
[
0
]
=
(
char
*
)
updaterPath
.
get
(
)
;
argv
[
1
]
=
(
char
*
)
updateDirPath
.
get
(
)
;
argv
[
2
]
=
(
char
*
)
installDirPath
.
get
(
)
;
argv
[
3
]
=
(
char
*
)
applyToDirPath
.
get
(
)
;
argv
[
4
]
=
(
char
*
)
pid
.
get
(
)
;
if
(
restart
&
&
appArgc
)
{
argv
[
5
]
=
workingDirPath
;
argv
[
6
]
=
(
char
*
)
appFilePath
.
get
(
)
;
for
(
int
i
=
1
;
i
<
appArgc
;
+
+
i
)
{
argv
[
6
+
i
]
=
appArgv
[
i
]
;
}
if
(
gRestartedByOS
)
{
argv
[
6
+
appArgc
]
=
const_cast
<
char
*
>
(
"
-
os
-
restarted
"
)
;
}
}
argv
[
argc
]
=
nullptr
;
if
(
restart
&
&
gSafeMode
)
{
PR_SetEnv
(
"
MOZ_SAFE_MODE_RESTART
=
1
"
)
;
}
#
if
defined
(
MOZ_VERIFY_MAR_SIGNATURE
)
&
&
!
defined
(
XP_WIN
)
&
&
!
defined
(
XP_MACOSX
)
AppendToLibPath
(
installDirPath
.
get
(
)
)
;
#
endif
LOG
(
(
"
spawning
updater
process
[
%
s
]
\
n
"
updaterPath
.
get
(
)
)
)
;
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
XP_MACOSX
)
if
(
restart
)
{
exit
(
execv
(
updaterPath
.
get
(
)
argv
)
)
;
}
*
outpid
=
fork
(
)
;
if
(
*
outpid
=
=
-
1
)
{
return
;
}
else
if
(
*
outpid
=
=
0
)
{
exit
(
execv
(
updaterPath
.
get
(
)
argv
)
)
;
}
#
elif
defined
(
XP_WIN
)
if
(
isStaged
)
{
if
(
!
WinLaunchChild
(
updaterPathW
.
get
(
)
argc
argv
)
)
{
return
;
}
}
else
{
if
(
!
WinLaunchChild
(
updaterPathW
.
get
(
)
argc
argv
nullptr
outpid
)
)
{
return
;
}
}
#
elif
defined
(
XP_MACOSX
)
UpdateDriverSetupMacCommandLine
(
argc
argv
restart
)
;
if
(
restart
&
&
!
IsRecursivelyWritable
(
installDirPath
.
get
(
)
)
)
{
if
(
!
LaunchElevatedUpdate
(
argc
argv
outpid
)
)
{
LOG
(
(
"
Failed
to
launch
elevated
update
!
"
)
)
;
exit
(
1
)
;
}
exit
(
0
)
;
}
if
(
isStaged
)
{
LaunchChildMac
(
argc
argv
)
;
}
else
{
LaunchChildMac
(
argc
argv
outpid
)
;
}
if
(
restart
)
{
exit
(
0
)
;
}
#
else
if
(
isStaged
)
{
PR_CreateProcessDetached
(
updaterPath
.
get
(
)
argv
nullptr
nullptr
)
;
}
else
{
*
outpid
=
PR_CreateProcess
(
updaterPath
.
get
(
)
argv
nullptr
nullptr
)
;
}
#
endif
#
if
!
defined
(
USE_EXECV
)
if
(
restart
)
{
exit
(
0
)
;
}
#
endif
}
static
bool
ProcessHasTerminated
(
ProcessType
pt
)
{
#
if
defined
(
XP_WIN
)
if
(
WaitForSingleObject
(
pt
1000
)
)
{
return
false
;
}
CloseHandle
(
pt
)
;
return
true
;
#
elif
defined
(
XP_MACOSX
)
return
true
;
#
elif
defined
(
XP_UNIX
)
int
exitStatus
;
pid_t
exited
=
waitpid
(
pt
&
exitStatus
WNOHANG
)
;
if
(
exited
=
=
0
)
{
sleep
(
1
)
;
return
false
;
}
if
(
exited
=
=
-
1
)
{
LOG
(
(
"
Error
while
checking
if
the
updater
process
is
finished
"
)
)
;
return
true
;
}
if
(
WIFEXITED
(
exitStatus
)
&
&
(
WEXITSTATUS
(
exitStatus
)
!
=
0
)
)
{
LOG
(
(
"
Error
while
running
the
updater
process
check
update
.
log
"
)
)
;
}
return
true
;
#
else
int32_t
exitCode
;
PR_WaitProcess
(
pt
&
exitCode
)
;
if
(
exitCode
!
=
0
)
{
LOG
(
(
"
Error
while
running
the
updater
process
check
update
.
log
"
)
)
;
}
return
true
;
#
endif
}
nsresult
ProcessUpdates
(
nsIFile
*
greDir
nsIFile
*
appDir
nsIFile
*
updRootDir
int
argc
char
*
*
argv
const
char
*
appVersion
bool
restart
ProcessType
*
pid
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
updatesDir
;
rv
=
updRootDir
-
>
Clone
(
getter_AddRefs
(
updatesDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
updatesDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
updates
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
updatesDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
0
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
versionFile
;
if
(
!
GetVersionFile
(
updatesDir
versionFile
)
|
|
IsOlderVersion
(
versionFile
appVersion
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
statusFile
;
UpdateStatus
status
=
GetUpdateStatus
(
updatesDir
statusFile
)
;
switch
(
status
)
{
case
ePendingElevate
:
{
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIUpdatePrompt
>
up
=
do_GetService
(
"
mozilla
.
org
/
updates
/
update
-
prompt
;
1
"
)
;
if
(
up
)
{
up
-
>
ShowUpdateElevationRequired
(
)
;
}
break
;
}
MOZ_FALLTHROUGH
;
}
case
ePendingUpdate
:
case
ePendingService
:
{
ApplyUpdate
(
greDir
updatesDir
appDir
argc
argv
restart
false
pid
)
;
break
;
}
case
eAppliedUpdate
:
case
eAppliedService
:
ApplyUpdate
(
greDir
updatesDir
appDir
argc
argv
restart
true
pid
)
;
break
;
case
eNoUpdateAction
:
break
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsUpdateProcessor
nsIUpdateProcessor
)
nsUpdateProcessor
:
:
nsUpdateProcessor
(
)
:
mUpdaterPID
(
0
)
{
}
nsUpdateProcessor
:
:
~
nsUpdateProcessor
(
)
{
}
NS_IMETHODIMP
nsUpdateProcessor
:
:
ProcessUpdate
(
nsIUpdate
*
aUpdate
)
{
nsresult
rv
;
nsCOMPtr
<
nsIProperties
>
ds
=
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
exeFile
;
rv
=
ds
-
>
Get
(
XRE_EXECUTABLE_FILE
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
exeFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
appDir
;
rv
=
exeFile
-
>
GetParent
(
getter_AddRefs
(
appDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
greDir
;
rv
=
ds
-
>
Get
(
NS_GRE_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
greDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
updRoot
;
rv
=
ds
-
>
Get
(
XRE_UPDATE_ROOT_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
updRoot
)
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Can
'
t
get
the
UpdRootD
dir
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
appDir
-
>
Clone
(
getter_AddRefs
(
updRoot
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
appVersion
;
rv
=
appInfo
-
>
GetVersion
(
appVersion
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mInfo
.
mGREDir
=
greDir
;
mInfo
.
mAppDir
=
appDir
;
mInfo
.
mUpdateRoot
=
updRoot
;
mInfo
.
mArgc
=
0
;
mInfo
.
mArgv
=
nullptr
;
mInfo
.
mAppVersion
=
appVersion
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
not
main
thread
"
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NewRunnableMethod
(
"
nsUpdateProcessor
:
:
StartStagedUpdate
"
this
&
nsUpdateProcessor
:
:
StartStagedUpdate
)
;
return
NS_NewNamedThread
(
"
Update
Watcher
"
getter_AddRefs
(
mProcessWatcher
)
r
)
;
}
NS_IMETHODIMP
nsUpdateProcessor
:
:
FixUpdateDirectoryPerms
(
bool
aShouldUseService
)
{
#
ifndef
XP_WIN
return
NS_ERROR_NOT_IMPLEMENTED
;
#
else
enum
class
State
{
Initializing
WaitingToStart
Starting
WaitingForFinish
}
;
class
FixUpdateDirectoryPermsRunnable
final
:
public
mozilla
:
:
Runnable
{
public
:
FixUpdateDirectoryPermsRunnable
(
const
char
*
aName
bool
aShouldUseService
const
nsAutoString
&
aInstallPath
)
:
Runnable
(
aName
)
mShouldUseService
(
aShouldUseService
)
mState
(
State
:
:
Initializing
)
{
size_t
installPathSize
=
aInstallPath
.
Length
(
)
+
1
;
mInstallPath
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
installPathSize
)
;
if
(
mInstallPath
)
{
HRESULT
hrv
=
StringCchCopyW
(
mInstallPath
.
get
(
)
installPathSize
PromiseFlatString
(
aInstallPath
)
.
get
(
)
)
;
if
(
FAILED
(
hrv
)
)
{
mInstallPath
.
reset
(
)
;
}
}
}
NS_IMETHOD
Run
(
)
override
{
const
unsigned
int
kMaxQueries
=
2400
;
const
unsigned
int
kQueryIntervalMS
=
200
;
const
unsigned
int
kMaxStartAttempts
=
50
;
const
unsigned
int
kStartAttemptIntervalMS
=
100
;
if
(
mState
=
=
State
:
:
Initializing
)
{
if
(
!
mInstallPath
)
{
LOG
(
(
"
Warning
:
No
install
path
available
in
"
"
FixUpdateDirectoryPermsRunnable
\
n
"
)
)
;
}
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
updateDir
;
HRESULT
permResult
=
GetCommonUpdateDirectory
(
mInstallPath
.
get
(
)
SetPermissionsOf
:
:
AllFilesAndDirs
updateDir
)
;
if
(
SUCCEEDED
(
permResult
)
)
{
LOG
(
(
"
Successfully
fixed
permissions
from
within
Firefox
\
n
"
)
)
;
return
NS_OK
;
}
else
if
(
!
mShouldUseService
)
{
LOG
(
(
"
Error
:
Unable
to
fix
permissions
within
Firefox
and
"
"
maintenance
service
is
disabled
\
n
"
)
)
;
return
ReportUpdateError
(
)
;
}
SC_HANDLE
serviceManager
=
OpenSCManager
(
nullptr
nullptr
SC_MANAGER_CONNECT
|
SC_MANAGER_ENUMERATE_SERVICE
)
;
mServiceManager
.
own
(
serviceManager
)
;
if
(
!
serviceManager
)
{
LOG
(
(
"
Error
:
Unable
to
get
the
service
manager
.
Cannot
fix
"
"
permissions
.
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
SC_HANDLE
service
=
OpenServiceW
(
serviceManager
MAINTENANCE_SVC_NAME
SERVICE_QUERY_STATUS
|
SERVICE_START
)
;
mService
.
own
(
service
)
;
if
(
!
service
)
{
LOG
(
(
"
Error
:
Unable
to
get
the
maintenance
service
.
Unable
fix
"
"
permissions
without
it
.
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
mStartServiceArgCount
=
mInstallPath
?
3
:
2
;
mStartServiceArgs
=
mozilla
:
:
MakeUnique
<
LPCWSTR
[
]
>
(
mStartServiceArgCount
)
;
if
(
!
mStartServiceArgs
)
{
LOG
(
(
"
Error
:
Unable
to
allocate
memory
for
argument
pointers
.
Cannot
"
"
fix
permissions
.
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
mStartServiceArgs
[
0
]
=
L
"
MozillaMaintenance
"
;
mStartServiceArgs
[
1
]
=
L
"
fix
-
update
-
directory
-
perms
"
;
if
(
mInstallPath
)
{
mStartServiceArgs
[
2
]
=
mInstallPath
.
get
(
)
;
}
mState
=
State
:
:
WaitingToStart
;
mCurrentTry
=
1
;
}
if
(
mState
=
=
State
:
:
WaitingToStart
|
|
mState
=
=
State
:
:
WaitingForFinish
)
{
SERVICE_STATUS_PROCESS
ssp
;
DWORD
bytesNeeded
;
BOOL
success
=
QueryServiceStatusEx
(
mService
SC_STATUS_PROCESS_INFO
(
LPBYTE
)
&
ssp
sizeof
(
SERVICE_STATUS_PROCESS
)
&
bytesNeeded
)
;
if
(
!
success
)
{
DWORD
lastError
=
GetLastError
(
)
;
if
(
lastError
!
=
ERROR_INVALID_SERVICE_CONTROL
&
&
lastError
!
=
ERROR_SERVICE_CANNOT_ACCEPT_CTRL
&
&
lastError
!
=
ERROR_SERVICE_NOT_ACTIVE
)
{
LOG
(
(
"
Error
:
Unable
to
query
service
when
fixing
permissions
.
Got
"
"
an
error
that
cannot
be
fixed
by
waiting
:
0x
%
lx
\
n
"
lastError
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mCurrentTry
>
=
kMaxQueries
)
{
LOG
(
(
"
Error
:
Unable
to
query
service
when
fixing
permissions
:
"
"
Timed
out
after
%
u
attempts
.
\
n
"
mCurrentTry
)
)
;
return
NS_ERROR_FAILURE
;
}
return
RetryInMS
(
kQueryIntervalMS
)
;
}
else
{
if
(
ssp
.
dwCurrentState
!
=
SERVICE_STOPPED
)
{
return
RetryInMS
(
kQueryIntervalMS
)
;
}
if
(
mState
=
=
State
:
:
WaitingForFinish
)
{
if
(
ssp
.
dwWin32ExitCode
!
=
NO_ERROR
)
{
LOG
(
(
"
Error
:
Maintenance
Service
was
unable
to
fix
update
"
"
directory
permissions
\
n
"
)
)
;
return
ReportUpdateError
(
)
;
}
LOG
(
(
"
Maintenance
service
successully
fixed
update
directory
"
"
permissions
\
n
"
)
)
;
return
NS_OK
;
}
mState
=
State
:
:
Starting
;
mCurrentTry
=
1
;
}
}
if
(
mState
=
=
State
:
:
Starting
)
{
BOOL
success
=
StartServiceW
(
mService
mStartServiceArgCount
mStartServiceArgs
.
get
(
)
)
;
if
(
success
)
{
mState
=
State
:
:
WaitingForFinish
;
mCurrentTry
=
1
;
return
RetryInMS
(
kQueryIntervalMS
)
;
}
else
if
(
mCurrentTry
>
=
kMaxStartAttempts
)
{
LOG
(
(
"
Error
:
Unable
to
fix
permissions
:
Timed
out
after
%
u
attempts
"
"
to
start
the
maintenance
service
\
n
"
mCurrentTry
)
)
;
return
NS_ERROR_FAILURE
;
}
return
RetryInMS
(
kStartAttemptIntervalMS
)
;
}
LOG
(
(
"
Error
:
Reached
logically
unreachable
code
when
correcting
update
"
"
directory
permissions
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
private
:
bool
mShouldUseService
;
unsigned
int
mCurrentTry
;
State
mState
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
mInstallPath
;
nsAutoServiceHandle
mServiceManager
;
nsAutoServiceHandle
mService
;
DWORD
mStartServiceArgCount
;
mozilla
:
:
UniquePtr
<
LPCWSTR
[
]
>
mStartServiceArgs
;
nsresult
RetryInMS
(
unsigned
int
aDelayMS
)
{
+
+
mCurrentTry
;
nsCOMPtr
<
nsIRunnable
>
runnable
(
this
)
;
return
NS_DelayedDispatchToCurrentThread
(
runnable
.
forget
(
)
aDelayMS
)
;
}
nsresult
ReportUpdateError
(
)
{
return
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
nsUpdateProcessor
:
:
FixUpdateDirectoryPerms
:
:
"
"
FixUpdateDirectoryPermsRunnable
:
:
ReportUpdateError
"
[
]
(
)
-
>
void
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
observerService
)
)
{
return
;
}
observerService
-
>
NotifyObservers
(
nullptr
"
update
-
error
"
u
"
bad
-
perms
"
)
;
}
)
)
;
}
}
;
nsCOMPtr
<
nsIProperties
>
dirSvc
(
do_GetService
(
"
mozilla
.
org
/
file
/
directory_service
;
1
"
)
)
;
NS_ENSURE_TRUE
(
dirSvc
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIFile
>
appPath
;
nsresult
rv
=
dirSvc
-
>
Get
(
XRE_EXECUTABLE_FILE
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
appPath
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
installDir
;
rv
=
appPath
-
>
GetParent
(
getter_AddRefs
(
installDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
installPath
;
rv
=
installDir
-
>
GetPath
(
installPath
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIEventTarget
>
eventTarget
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
;
NS_ENSURE_TRUE
(
eventTarget
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
FixUpdateDirectoryPermsRunnable
(
"
FixUpdateDirectoryPermsRunnable
"
aShouldUseService
installPath
)
;
rv
=
eventTarget
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
#
endif
return
NS_OK
;
}
void
nsUpdateProcessor
:
:
StartStagedUpdate
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
main
thread
"
)
;
nsresult
rv
=
ProcessUpdates
(
mInfo
.
mGREDir
mInfo
.
mAppDir
mInfo
.
mUpdateRoot
mInfo
.
mArgc
mInfo
.
mArgv
mInfo
.
mAppVersion
.
get
(
)
false
&
mUpdaterPID
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
mUpdaterPID
)
{
rv
=
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
nsUpdateProcessor
:
:
WaitForProcess
"
this
&
nsUpdateProcessor
:
:
WaitForProcess
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
else
{
rv
=
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
nsUpdateProcessor
:
:
ShutdownWatcherThread
"
this
&
nsUpdateProcessor
:
:
ShutdownWatcherThread
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
}
void
nsUpdateProcessor
:
:
ShutdownWatcherThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
not
main
thread
"
)
;
mProcessWatcher
-
>
Shutdown
(
)
;
mProcessWatcher
=
nullptr
;
}
void
nsUpdateProcessor
:
:
WaitForProcess
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
main
thread
"
)
;
if
(
ProcessHasTerminated
(
mUpdaterPID
)
)
{
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
nsUpdateProcessor
:
:
UpdateDone
"
this
&
nsUpdateProcessor
:
:
UpdateDone
)
)
;
}
else
{
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
nsUpdateProcessor
:
:
WaitForProcess
"
this
&
nsUpdateProcessor
:
:
WaitForProcess
)
)
;
}
}
void
nsUpdateProcessor
:
:
UpdateDone
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
not
main
thread
"
)
;
nsCOMPtr
<
nsIUpdateManager
>
um
=
do_GetService
(
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
)
;
if
(
um
)
{
um
-
>
RefreshUpdateStatus
(
)
;
}
ShutdownWatcherThread
(
)
;
}
