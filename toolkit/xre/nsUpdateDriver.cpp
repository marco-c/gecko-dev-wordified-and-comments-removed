#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
"
nsUpdateDriver
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
prproces
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsVersionComparator
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
ErrorNames
.
h
"
#
include
"
mozilla
/
Printf
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
CmdLineAndEnvUtils
.
h
"
#
ifdef
XP_MACOSX
#
include
"
nsILocalFileMac
.
h
"
#
include
"
nsCommandLineServiceMac
.
h
"
#
include
"
MacLaunchHelper
.
h
"
#
include
"
updaterfileutils_osx
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
gfxPlatformMac
.
h
"
#
endif
#
if
defined
(
XP_WIN
)
#
include
<
direct
.
h
>
#
include
<
process
.
h
>
#
include
<
windows
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
strsafe
.
h
>
#
include
<
shellapi
.
h
>
#
include
"
commonupdatedir
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
pathhash
.
h
"
#
include
"
WinUtils
.
h
"
#
define
getcwd
(
path
size
)
_getcwd
(
path
size
)
#
define
getpid
(
)
GetCurrentProcessId
(
)
#
elif
defined
(
XP_UNIX
)
#
include
<
unistd
.
h
>
#
include
<
sys
/
wait
.
h
>
#
endif
using
namespace
mozilla
;
static
LazyLogModule
sUpdateLog
(
"
updatedriver
"
)
;
#
ifdef
LOG
#
undef
LOG
#
endif
#
define
LOG
(
args
)
MOZ_LOG
(
sUpdateLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
static
nsresult
GetCurrentWorkingDir
(
nsACString
&
aOutPath
)
{
aOutPath
.
Truncate
(
)
;
#
if
defined
(
XP_WIN
)
wchar_t
wpath
[
MAX_PATH
]
;
if
(
!
_wgetcwd
(
wpath
ArrayLength
(
wpath
)
)
)
{
return
NS_ERROR_FAILURE
;
}
CopyUTF16toUTF8
(
nsDependentString
(
wpath
)
aOutPath
)
;
#
else
char
path
[
MAXPATHLEN
]
;
if
(
!
getcwd
(
path
ArrayLength
(
path
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aOutPath
=
path
;
#
endif
return
NS_OK
;
}
static
nsresult
GetInstallDirPath
(
nsIFile
*
appDir
nsACString
&
installDirPath
)
{
nsresult
rv
;
#
ifdef
XP_MACOSX
nsCOMPtr
<
nsIFile
>
parentDir1
parentDir2
;
rv
=
appDir
-
>
GetParent
(
getter_AddRefs
(
parentDir1
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
parentDir1
-
>
GetParent
(
getter_AddRefs
(
parentDir2
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
parentDir2
-
>
GetNativePath
(
installDirPath
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
#
elif
XP_WIN
nsAutoString
installDirPathW
;
rv
=
appDir
-
>
GetPath
(
installDirPathW
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyUTF16toUTF8
(
installDirPathW
installDirPath
)
;
#
else
rv
=
appDir
-
>
GetNativePath
(
installDirPath
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
#
endif
return
NS_OK
;
}
static
bool
GetFile
(
nsIFile
*
dir
const
nsACString
&
name
nsCOMPtr
<
nsIFile
>
&
result
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
file
;
rv
=
dir
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
rv
=
file
-
>
AppendNative
(
name
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
result
=
file
;
return
true
;
}
static
bool
GetStatusFile
(
nsIFile
*
dir
nsCOMPtr
<
nsIFile
>
&
result
)
{
return
GetFile
(
dir
"
update
.
status
"
_ns
result
)
;
}
template
<
size_t
Size
>
static
bool
GetStatusFileContents
(
nsIFile
*
statusFile
char
(
&
buf
)
[
Size
]
)
{
static_assert
(
Size
>
16
"
Buffer
needs
to
be
large
enough
to
hold
the
known
status
codes
"
)
;
PRFileDesc
*
fd
=
nullptr
;
nsresult
rv
=
statusFile
-
>
OpenNSPRFileDesc
(
PR_RDWR
0660
&
fd
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
const
int32_t
n
=
PR_Read
(
fd
buf
Size
)
;
PR_Close
(
fd
)
;
return
(
n
>
=
0
)
;
}
enum
UpdateStatus
{
eNoUpdateAction
ePendingUpdate
ePendingService
ePendingElevate
eAppliedUpdate
eAppliedService
}
;
static
UpdateStatus
GetUpdateStatus
(
nsIFile
*
dir
nsCOMPtr
<
nsIFile
>
&
statusFile
)
{
if
(
GetStatusFile
(
dir
statusFile
)
)
{
char
buf
[
32
]
;
if
(
GetStatusFileContents
(
statusFile
buf
)
)
{
const
char
kPending
[
]
=
"
pending
"
;
const
char
kPendingService
[
]
=
"
pending
-
service
"
;
const
char
kPendingElevate
[
]
=
"
pending
-
elevate
"
;
const
char
kApplied
[
]
=
"
applied
"
;
const
char
kAppliedService
[
]
=
"
applied
-
service
"
;
if
(
!
strncmp
(
buf
kPendingElevate
sizeof
(
kPendingElevate
)
-
1
)
)
{
return
ePendingElevate
;
}
if
(
!
strncmp
(
buf
kPendingService
sizeof
(
kPendingService
)
-
1
)
)
{
return
ePendingService
;
}
if
(
!
strncmp
(
buf
kPending
sizeof
(
kPending
)
-
1
)
)
{
return
ePendingUpdate
;
}
if
(
!
strncmp
(
buf
kAppliedService
sizeof
(
kAppliedService
)
-
1
)
)
{
return
eAppliedService
;
}
if
(
!
strncmp
(
buf
kApplied
sizeof
(
kApplied
)
-
1
)
)
{
return
eAppliedUpdate
;
}
}
}
return
eNoUpdateAction
;
}
static
bool
GetVersionFile
(
nsIFile
*
dir
nsCOMPtr
<
nsIFile
>
&
result
)
{
return
GetFile
(
dir
"
update
.
version
"
_ns
result
)
;
}
static
bool
IsOlderVersion
(
nsIFile
*
versionFile
const
char
*
appVersion
)
{
PRFileDesc
*
fd
=
nullptr
;
nsresult
rv
=
versionFile
-
>
OpenNSPRFileDesc
(
PR_RDONLY
0660
&
fd
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
true
;
}
char
buf
[
32
]
;
const
int32_t
n
=
PR_Read
(
fd
buf
sizeof
(
buf
)
)
;
PR_Close
(
fd
)
;
if
(
n
<
0
)
{
return
false
;
}
if
(
buf
[
n
-
1
]
=
=
'
\
n
'
)
{
buf
[
n
-
1
]
=
'
\
0
'
;
}
const
char
kNull
[
]
=
"
null
"
;
if
(
strncmp
(
buf
kNull
sizeof
(
kNull
)
-
1
)
=
=
0
)
{
return
false
;
}
return
mozilla
:
:
Version
(
appVersion
)
>
buf
;
}
static
void
ApplyUpdate
(
nsIFile
*
greDir
nsIFile
*
updateDir
nsIFile
*
appDir
int
appArgc
char
*
*
appArgv
bool
restart
bool
isStaged
ProcessType
*
outpid
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
restart
|
|
NS_IsMainThread
(
)
"
restart
may
only
be
set
when
called
on
the
main
thread
"
)
;
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
updater
;
nsAutoCString
updaterPath
;
nsAutoCString
updateDirPath
;
#
if
defined
(
XP_WIN
)
if
(
!
GetFile
(
greDir
nsLiteralCString
(
UPDATER_BIN
)
updater
)
)
{
return
;
}
nsAutoString
updaterPathW
;
rv
=
updater
-
>
GetPath
(
updaterPathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
CopyUTF16toUTF8
(
updaterPathW
updaterPath
)
;
nsAutoString
updateDirPathW
;
rv
=
updateDir
-
>
GetPath
(
updateDirPathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
CopyUTF16toUTF8
(
updateDirPathW
updateDirPath
)
;
#
elif
defined
(
XP_MACOSX
)
if
(
!
GetFile
(
appDir
nsLiteralCString
(
UPDATER_APP
)
updater
)
)
{
return
;
}
rv
=
updater
-
>
AppendNative
(
"
Contents
"
_ns
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
updater
-
>
AppendNative
(
"
MacOS
"
_ns
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
updater
-
>
AppendNative
(
nsLiteralCString
(
UPDATER_BIN
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
updater
-
>
GetNativePath
(
updaterPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
updateDir
-
>
GetNativePath
(
updateDirPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
#
else
if
(
!
GetFile
(
greDir
nsLiteralCString
(
UPDATER_BIN
)
updater
)
)
{
return
;
}
rv
=
updater
-
>
GetNativePath
(
updaterPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
updateDir
-
>
GetNativePath
(
updateDirPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
#
endif
#
ifndef
XP_MACOSX
nsAutoCString
appFilePath
;
#
endif
nsAutoCString
workingDirPath
;
if
(
restart
)
{
rv
=
GetCurrentWorkingDir
(
workingDirPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsIFile
>
appFile
;
XRE_GetBinaryPath
(
getter_AddRefs
(
appFile
)
)
;
if
(
!
appFile
)
{
return
;
}
#
if
defined
(
XP_WIN
)
nsAutoString
appFilePathW
;
rv
=
appFile
-
>
GetPath
(
appFilePathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
CopyUTF16toUTF8
(
appFilePathW
appFilePath
)
;
#
elif
!
defined
(
XP_MACOSX
)
rv
=
appFile
-
>
GetNativePath
(
appFilePath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
#
endif
}
nsAutoCString
installDirPath
;
rv
=
GetInstallDirPath
(
appDir
installDirPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
#
if
defined
(
XP_MACOSX
)
if
(
restart
)
{
gfxPlatformMac
:
:
WaitForFontRegistration
(
)
;
}
bool
needElevation
=
false
;
if
(
restart
)
{
needElevation
=
!
IsRecursivelyWritable
(
installDirPath
.
get
(
)
)
;
if
(
needElevation
)
{
char
*
mozAppSilentStart
=
PR_GetEnv
(
"
MOZ_APP_SILENT_START
"
)
;
bool
wasSilentlyStarted
=
mozAppSilentStart
&
&
(
strcmp
(
mozAppSilentStart
"
"
)
!
=
0
)
;
if
(
wasSilentlyStarted
)
{
return
;
}
}
}
#
endif
nsAutoCString
applyToDirPath
;
nsCOMPtr
<
nsIFile
>
updatedDir
;
if
(
restart
&
&
!
isStaged
)
{
applyToDirPath
.
Assign
(
installDirPath
)
;
}
else
{
#
if
defined
(
XP_MACOSX
)
if
(
!
GetFile
(
updateDir
"
Updated
.
app
"
_ns
updatedDir
)
)
{
#
else
if
(
!
GetFile
(
appDir
"
updated
"
_ns
updatedDir
)
)
{
#
endif
return
;
}
#
if
defined
(
XP_WIN
)
nsAutoString
applyToDirPathW
;
rv
=
updatedDir
-
>
GetPath
(
applyToDirPathW
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
CopyUTF16toUTF8
(
applyToDirPathW
applyToDirPath
)
;
#
else
rv
=
updatedDir
-
>
GetNativePath
(
applyToDirPath
)
;
#
endif
}
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
restart
&
&
isStaged
)
{
bool
updatedDirExists
=
false
;
if
(
NS_FAILED
(
updatedDir
-
>
Exists
(
&
updatedDirExists
)
)
|
|
!
updatedDirExists
)
{
return
;
}
}
nsAutoCString
pid
;
if
(
restart
)
{
#
if
defined
(
XP_UNIX
)
&
!
defined
(
XP_MACOSX
)
pid
.
AssignLiteral
(
"
0
"
)
;
#
else
pid
.
AppendInt
(
(
int32_t
)
getpid
(
)
)
;
#
endif
if
(
isStaged
)
{
pid
.
AppendLiteral
(
"
/
replace
"
)
;
}
}
else
{
pid
.
AssignLiteral
(
"
-
1
"
)
;
}
int
argc
=
5
;
if
(
restart
)
{
argc
=
appArgc
+
6
;
if
(
gRestartedByOS
)
{
argc
+
=
1
;
}
}
char
*
*
argv
=
static_cast
<
char
*
*
>
(
malloc
(
(
argc
+
1
)
*
sizeof
(
char
*
)
)
)
;
if
(
!
argv
)
{
return
;
}
argv
[
0
]
=
(
char
*
)
updaterPath
.
get
(
)
;
argv
[
1
]
=
(
char
*
)
updateDirPath
.
get
(
)
;
argv
[
2
]
=
(
char
*
)
installDirPath
.
get
(
)
;
argv
[
3
]
=
(
char
*
)
applyToDirPath
.
get
(
)
;
argv
[
4
]
=
(
char
*
)
pid
.
get
(
)
;
if
(
restart
&
&
appArgc
)
{
argv
[
5
]
=
(
char
*
)
workingDirPath
.
get
(
)
;
#
if
defined
(
XP_MACOSX
)
argv
[
6
]
=
(
char
*
)
installDirPath
.
get
(
)
;
#
else
argv
[
6
]
=
(
char
*
)
appFilePath
.
get
(
)
;
#
endif
for
(
int
i
=
1
;
i
<
appArgc
;
+
+
i
)
{
argv
[
6
+
i
]
=
appArgv
[
i
]
;
}
if
(
gRestartedByOS
)
{
argv
[
6
+
appArgc
]
=
const_cast
<
char
*
>
(
"
-
os
-
restarted
"
)
;
}
}
argv
[
argc
]
=
nullptr
;
if
(
restart
&
&
gSafeMode
)
{
PR_SetEnv
(
"
MOZ_SAFE_MODE_RESTART
=
1
"
)
;
}
LOG
(
(
"
spawning
updater
process
[
%
s
]
\
n
"
updaterPath
.
get
(
)
)
)
;
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
XP_MACOSX
)
if
(
restart
)
{
int
execResult
=
execv
(
updaterPath
.
get
(
)
argv
)
;
free
(
argv
)
;
exit
(
execResult
)
;
}
*
outpid
=
fork
(
)
;
if
(
*
outpid
=
=
-
1
)
{
free
(
argv
)
;
return
;
}
if
(
*
outpid
=
=
0
)
{
int
execResult
=
execv
(
updaterPath
.
get
(
)
argv
)
;
free
(
argv
)
;
exit
(
execResult
)
;
}
#
elif
defined
(
XP_WIN
)
if
(
isStaged
)
{
if
(
!
WinLaunchChild
(
updaterPathW
.
get
(
)
argc
argv
)
)
{
free
(
argv
)
;
return
;
}
}
else
{
if
(
!
WinLaunchChild
(
updaterPathW
.
get
(
)
argc
argv
nullptr
outpid
)
)
{
free
(
argv
)
;
return
;
}
}
#
elif
defined
(
XP_MACOSX
)
if
(
restart
)
{
CommandLineServiceMac
:
:
SetupMacCommandLine
(
argc
argv
restart
)
;
if
(
needElevation
)
{
bool
hasLaunched
=
LaunchElevatedUpdate
(
argc
argv
outpid
)
;
free
(
argv
)
;
if
(
!
hasLaunched
)
{
LOG
(
(
"
Failed
to
launch
elevated
update
!
"
)
)
;
exit
(
1
)
;
}
exit
(
0
)
;
}
}
if
(
isStaged
)
{
LaunchChildMac
(
argc
argv
)
;
}
else
{
LaunchChildMac
(
argc
argv
outpid
)
;
}
#
else
if
(
isStaged
)
{
PR_CreateProcessDetached
(
updaterPath
.
get
(
)
argv
nullptr
nullptr
)
;
}
else
{
*
outpid
=
PR_CreateProcess
(
updaterPath
.
get
(
)
argv
nullptr
nullptr
)
;
}
#
endif
free
(
argv
)
;
if
(
restart
)
{
exit
(
0
)
;
}
}
#
if
!
defined
(
XP_WIN
)
static
bool
ProcessHasTerminated
(
ProcessType
pt
)
{
#
if
defined
(
XP_MACOSX
)
return
true
;
#
elif
defined
(
XP_UNIX
)
int
exitStatus
;
pid_t
exited
=
waitpid
(
pt
&
exitStatus
WNOHANG
)
;
if
(
exited
=
=
0
)
{
sleep
(
1
)
;
return
false
;
}
if
(
exited
=
=
-
1
)
{
LOG
(
(
"
Error
while
checking
if
the
updater
process
is
finished
"
)
)
;
return
true
;
}
if
(
WIFEXITED
(
exitStatus
)
&
&
(
WEXITSTATUS
(
exitStatus
)
!
=
0
)
)
{
LOG
(
(
"
Error
while
running
the
updater
process
check
update
.
log
"
)
)
;
}
return
true
;
#
else
int32_t
exitCode
;
PR_WaitProcess
(
pt
&
exitCode
)
;
if
(
exitCode
!
=
0
)
{
LOG
(
(
"
Error
while
running
the
updater
process
check
update
.
log
"
)
)
;
}
return
true
;
#
endif
}
#
endif
nsresult
ProcessUpdates
(
nsIFile
*
greDir
nsIFile
*
appDir
nsIFile
*
updRootDir
int
argc
char
*
*
argv
const
char
*
appVersion
bool
restart
ProcessType
*
pid
)
{
nsresult
rv
;
#
ifdef
XP_WIN
if
(
mozilla
:
:
widget
:
:
WinUtils
:
:
HasPackageIdentity
(
)
)
{
return
NS_OK
;
}
#
endif
nsCOMPtr
<
nsIFile
>
updatesDir
;
rv
=
updRootDir
-
>
Clone
(
getter_AddRefs
(
updatesDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updatesDir
-
>
AppendNative
(
"
updates
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updatesDir
-
>
AppendNative
(
"
0
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
versionFile
;
if
(
!
GetVersionFile
(
updatesDir
versionFile
)
|
|
IsOlderVersion
(
versionFile
appVersion
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
statusFile
;
UpdateStatus
status
=
GetUpdateStatus
(
updatesDir
statusFile
)
;
switch
(
status
)
{
case
ePendingUpdate
:
case
ePendingService
:
{
ApplyUpdate
(
greDir
updatesDir
appDir
argc
argv
restart
false
pid
)
;
break
;
}
case
eAppliedUpdate
:
case
eAppliedService
:
ApplyUpdate
(
greDir
updatesDir
appDir
argc
argv
restart
true
pid
)
;
break
;
case
ePendingElevate
:
case
eNoUpdateAction
:
break
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsUpdateProcessor
nsIUpdateProcessor
)
nsUpdateProcessor
:
:
nsUpdateProcessor
(
)
:
mUpdaterPID
(
0
)
{
}
#
ifdef
XP_WIN
nsUpdateProcessor
:
:
~
nsUpdateProcessor
(
)
{
mProcessWatcher
.
Stop
(
)
;
}
#
else
nsUpdateProcessor
:
:
~
nsUpdateProcessor
(
)
=
default
;
#
endif
NS_IMETHODIMP
nsUpdateProcessor
:
:
ProcessUpdate
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIProperties
>
ds
=
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
exeFile
;
rv
=
ds
-
>
Get
(
XRE_EXECUTABLE_FILE
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
exeFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
appDir
;
rv
=
exeFile
-
>
GetParent
(
getter_AddRefs
(
appDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
greDir
;
rv
=
ds
-
>
Get
(
NS_GRE_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
greDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
updRoot
;
rv
=
ds
-
>
Get
(
XRE_UPDATE_ROOT_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
updRoot
)
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Can
'
t
get
the
UpdRootD
dir
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
appDir
-
>
Clone
(
getter_AddRefs
(
updRoot
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
appVersion
;
rv
=
appInfo
-
>
GetVersion
(
appVersion
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mInfo
.
mGREDir
=
greDir
;
mInfo
.
mAppDir
=
appDir
;
mInfo
.
mUpdateRoot
=
updRoot
;
mInfo
.
mArgc
=
0
;
mInfo
.
mArgv
=
nullptr
;
mInfo
.
mAppVersion
=
appVersion
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
not
main
thread
"
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NewRunnableMethod
(
"
nsUpdateProcessor
:
:
StartStagedUpdate
"
this
&
nsUpdateProcessor
:
:
StartStagedUpdate
)
;
return
NS_NewNamedThread
(
"
UpdateProcessor
"
getter_AddRefs
(
mWorkerThread
)
r
)
;
}
void
nsUpdateProcessor
:
:
StartStagedUpdate
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
main
thread
"
)
;
auto
onExitStopThread
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
nsresult
rv
=
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
nsUpdateProcessor
:
:
ShutdownWorkerThread
"
this
&
nsUpdateProcessor
:
:
ShutdownWorkerThread
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
)
;
nsresult
rv
=
ProcessUpdates
(
mInfo
.
mGREDir
mInfo
.
mAppDir
mInfo
.
mUpdateRoot
mInfo
.
mArgc
mInfo
.
mArgv
mInfo
.
mAppVersion
.
get
(
)
false
&
mUpdaterPID
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
sUpdateLog
mozilla
:
:
LogLevel
:
:
Error
(
"
could
not
start
updater
process
:
%
s
"
GetStaticErrorName
(
rv
)
)
)
;
return
;
}
if
(
!
mUpdaterPID
)
{
MOZ_LOG
(
sUpdateLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
ProcessUpdates
(
)
indicated
nothing
to
do
"
)
)
;
return
;
}
#
ifdef
WIN32
RefPtr
<
nsIThread
>
mainThread
;
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
mProcessWatcher
.
Watch
(
mUpdaterPID
mainThread
NewRunnableMethod
(
"
nsUpdateProcessor
:
:
UpdateDone
"
this
&
nsUpdateProcessor
:
:
UpdateDone
)
)
;
#
else
rv
=
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
nsUpdateProcessor
:
:
WaitForProcess
"
this
&
nsUpdateProcessor
:
:
WaitForProcess
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
sUpdateLog
mozilla
:
:
LogLevel
:
:
Error
(
"
could
not
start
updater
process
poll
:
error
%
s
"
GetStaticErrorName
(
rv
)
)
)
;
return
;
}
onExitStopThread
.
release
(
)
;
#
endif
}
void
nsUpdateProcessor
:
:
ShutdownWorkerThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
not
main
thread
"
)
;
mWorkerThread
-
>
Shutdown
(
)
;
mWorkerThread
=
nullptr
;
}
#
ifndef
WIN32
void
nsUpdateProcessor
:
:
WaitForProcess
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
main
thread
"
)
;
if
(
ProcessHasTerminated
(
mUpdaterPID
)
)
{
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
nsUpdateProcessor
:
:
UpdateDone
"
this
&
nsUpdateProcessor
:
:
UpdateDone
)
)
;
}
else
{
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
nsUpdateProcessor
:
:
WaitForProcess
"
this
&
nsUpdateProcessor
:
:
WaitForProcess
)
)
;
}
}
#
endif
void
nsUpdateProcessor
:
:
UpdateDone
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
not
main
thread
"
)
;
nsCOMPtr
<
nsIUpdateManager
>
um
=
do_GetService
(
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
)
;
if
(
um
)
{
RefPtr
<
mozilla
:
:
dom
:
:
Promise
>
outPromise
;
um
-
>
RefreshUpdateStatus
(
getter_AddRefs
(
outPromise
)
)
;
}
#
ifndef
XP_WIN
ShutdownWorkerThread
(
)
;
#
endif
}
NS_IMETHODIMP
nsUpdateProcessor
:
:
GetServiceRegKeyExists
(
bool
*
aResult
)
{
#
ifndef
XP_WIN
return
NS_ERROR_NOT_IMPLEMENTED
;
#
else
nsCOMPtr
<
nsIProperties
>
dirSvc
(
do_GetService
(
"
mozilla
.
org
/
file
/
directory_service
;
1
"
)
)
;
NS_ENSURE_TRUE
(
dirSvc
NS_ERROR_SERVICE_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsIFile
>
installBin
;
nsresult
rv
=
dirSvc
-
>
Get
(
XRE_EXECUTABLE_FILE
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
installBin
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
installDir
;
rv
=
installBin
-
>
GetParent
(
getter_AddRefs
(
installDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
installPath
;
rv
=
installDir
-
>
GetPath
(
installPath
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
wchar_t
maintenanceServiceKey
[
MAX_PATH
+
1
]
;
BOOL
success
=
CalculateRegistryPathFromFilePath
(
PromiseFlatString
(
installPath
)
.
get
(
)
maintenanceServiceKey
)
;
NS_ENSURE_TRUE
(
success
NS_ERROR_FAILURE
)
;
HKEY
regHandle
;
LSTATUS
ls
=
RegOpenKeyExW
(
HKEY_LOCAL_MACHINE
maintenanceServiceKey
0
KEY_QUERY_VALUE
|
KEY_WOW64_64KEY
&
regHandle
)
;
if
(
ls
=
=
ERROR_SUCCESS
)
{
RegCloseKey
(
regHandle
)
;
*
aResult
=
true
;
return
NS_OK
;
}
if
(
ls
=
=
ERROR_FILE_NOT_FOUND
)
{
*
aResult
=
false
;
return
NS_OK
;
}
return
NS_ERROR_NOT_AVAILABLE
;
#
endif
}
NS_IMETHODIMP
nsUpdateProcessor
:
:
AttemptAutomaticApplicationRestartWithLaunchArgs
(
const
nsTArray
<
nsString
>
&
argvExtra
int32_t
*
pidRet
)
{
#
ifndef
XP_WIN
return
NS_ERROR_NOT_IMPLEMENTED
;
#
else
LPWSTR
currentCommandLine
=
GetCommandLineW
(
)
;
if
(
currentCommandLine
)
{
int
currentArgc
=
0
;
UniquePtr
<
LPWSTR
LocalFreeDeleter
>
currentArgv
(
CommandLineToArgvW
(
currentCommandLine
&
currentArgc
)
)
;
nsTArray
<
wchar_t
*
>
restartCommandLineArgv
(
currentArgc
+
argvExtra
.
Length
(
)
+
2
)
;
for
(
int
i
=
0
;
i
<
currentArgc
;
i
+
+
)
{
restartCommandLineArgv
.
AppendElement
(
currentArgv
.
get
(
)
[
i
]
)
;
}
for
(
const
nsString
&
arg
:
argvExtra
)
{
restartCommandLineArgv
.
AppendElement
(
static_cast
<
wchar_t
*
>
(
arg
.
get
(
)
)
)
;
}
DWORD
pidCurrent
=
GetCurrentProcessId
(
)
;
nsString
pid
;
pid
.
AppendInt
(
static_cast
<
uint32_t
>
(
pidCurrent
)
)
;
nsString
pidFlag
=
u
"
-
restart
-
pid
"
_ns
;
restartCommandLineArgv
.
AppendElement
(
pidFlag
.
get
(
)
)
;
restartCommandLineArgv
.
AppendElement
(
pid
.
get
(
)
)
;
wchar_t
exeName
[
MAX_PATH
]
;
GetModuleFileNameW
(
NULL
exeName
MAX_PATH
)
;
HANDLE
childHandle
;
WinLaunchChild
(
exeName
restartCommandLineArgv
.
Length
(
)
restartCommandLineArgv
.
Elements
(
)
nullptr
&
childHandle
)
;
*
pidRet
=
GetProcessId
(
childHandle
)
;
CloseHandle
(
childHandle
)
;
if
(
!
*
pidRet
)
{
printf_stderr
(
"
*
*
*
ApplyUpdate
:
!
pidRet
*
*
*
\
n
"
)
;
return
NS_ERROR_ABORT
;
}
printf_stderr
(
"
*
*
*
ApplyUpdate
:
launched
pidRet
=
%
d
*
*
*
\
n
"
*
pidRet
)
;
MOZ_LOG
(
sUpdateLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
register
application
restart
succeeded
"
)
)
;
}
else
{
MOZ_LOG
(
sUpdateLog
mozilla
:
:
LogLevel
:
:
Error
(
"
could
not
register
application
restart
"
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
return
NS_OK
;
#
endif
}
NS_IMETHODIMP
nsUpdateProcessor
:
:
WaitForProcessExit
(
uint32_t
pid
uint32_t
timeoutMS
)
{
#
ifndef
XP_WIN
return
NS_ERROR_NOT_IMPLEMENTED
;
#
else
nsAutoHandle
hProcess
(
OpenProcess
(
SYNCHRONIZE
FALSE
pid
)
)
;
if
(
!
hProcess
)
{
MOZ_LOG
(
sUpdateLog
mozilla
:
:
LogLevel
:
:
Warning
(
"
WaitForProcessExit
(
%
d
)
:
failed
to
OpenProcess
"
pid
)
)
;
return
NS_OK
;
}
DWORD
waitRv
=
WaitForSingleObjectEx
(
hProcess
timeoutMS
FALSE
)
;
if
(
waitRv
!
=
WAIT_OBJECT_0
)
{
if
(
waitRv
=
=
WAIT_TIMEOUT
)
{
MOZ_LOG
(
sUpdateLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
WaitForProcessExit
(
%
d
)
:
timed
out
after
%
d
MS
"
pid
timeoutMS
)
)
;
return
NS_ERROR_ABORT
;
}
MOZ_LOG
(
sUpdateLog
mozilla
:
:
LogLevel
:
:
Warning
(
"
WaitForProcessExit
(
%
d
)
:
unexpected
error
%
lx
"
pid
waitRv
)
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_LOG
(
sUpdateLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
WaitForProcessExit
(
%
d
)
:
success
"
pid
)
)
;
return
NS_OK
;
#
endif
}
