#
include
"
nsNativeAppSupportBase
.
h
"
#
include
"
nsNativeAppSupportWin
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIBrowserDOMWindow
.
h
"
#
include
"
nsCommandLine
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIAppShellService
.
h
"
#
include
"
nsIXULWindow
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIPromptService
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIWindowMediator
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nsIAppStartup
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
dom
/
Location
.
h
"
#
include
<
windows
.
h
>
#
include
<
shellapi
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
<
io
.
h
>
#
include
<
direct
.
h
>
#
include
<
fcntl
.
h
>
using
namespace
mozilla
;
static
HWND
hwndForDOMWindow
(
mozIDOMWindowProxy
*
)
;
static
nsresult
GetMostRecentWindow
(
const
char16_t
*
aType
mozIDOMWindowProxy
*
*
aWindow
)
{
nsresult
rv
;
nsCOMPtr
<
nsIWindowMediator
>
med
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
med
)
return
med
-
>
GetMostRecentWindow
(
aType
aWindow
)
;
return
NS_ERROR_FAILURE
;
}
struct
Win32Mutex
{
explicit
Win32Mutex
(
const
char16_t
*
name
)
:
mName
(
name
)
mHandle
(
0
)
mState
(
-
1
)
{
mHandle
=
CreateMutexW
(
0
FALSE
mName
.
get
(
)
)
;
}
~
Win32Mutex
(
)
{
if
(
mHandle
)
{
Unlock
(
)
;
BOOL
rc
MOZ_MAYBE_UNUSED
=
CloseHandle
(
mHandle
)
;
}
}
BOOL
Lock
(
DWORD
timeout
)
{
if
(
mHandle
)
{
mState
=
WaitForSingleObject
(
mHandle
timeout
)
;
return
mState
=
=
WAIT_OBJECT_0
|
|
mState
=
=
WAIT_ABANDONED
;
}
else
{
return
FALSE
;
}
}
void
Unlock
(
)
{
if
(
mHandle
&
&
mState
=
=
WAIT_OBJECT_0
)
{
ReleaseMutex
(
mHandle
)
;
mState
=
-
1
;
}
}
private
:
nsString
mName
;
HANDLE
mHandle
;
DWORD
mState
;
}
;
class
MessageWindow
;
class
nsNativeAppSupportWin
:
public
nsNativeAppSupportBase
public
nsIObserver
{
public
:
NS_DECL_NSIOBSERVER
NS_DECL_ISUPPORTS_INHERITED
NS_IMETHOD
Start
(
bool
*
aResult
)
override
;
NS_IMETHOD
Quit
(
)
override
;
NS_IMETHOD
Enable
(
)
override
;
void
CheckConsole
(
)
;
private
:
~
nsNativeAppSupportWin
(
)
{
}
static
void
HandleCommandLine
(
const
char
*
aCmdLineString
nsIFile
*
aWorkingDir
uint32_t
aState
)
;
static
bool
mCanHandleRequests
;
static
char16_t
mMutexName
[
]
;
friend
class
MessageWindow
;
static
MessageWindow
*
mMsgWindow
;
}
;
NS_INTERFACE_MAP_BEGIN
(
nsNativeAppSupportWin
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_END_INHERITING
(
nsNativeAppSupportBase
)
NS_IMPL_ADDREF_INHERITED
(
nsNativeAppSupportWin
nsNativeAppSupportBase
)
NS_IMPL_RELEASE_INHERITED
(
nsNativeAppSupportWin
nsNativeAppSupportBase
)
void
UseParentConsole
(
)
{
if
(
AttachConsole
(
ATTACH_PARENT_PROCESS
)
)
{
if
(
_fileno
(
stdout
)
=
=
-
2
)
{
freopen
(
"
CONOUT
"
"
w
"
stdout
)
;
}
if
(
_fileno
(
stderr
)
=
=
-
2
)
{
freopen
(
"
CONOUT
"
"
w
"
stderr
)
;
}
if
(
_fileno
(
stdin
)
=
=
-
2
)
{
freopen
(
"
CONIN
"
"
r
"
stdin
)
;
}
}
}
void
nsNativeAppSupportWin
:
:
CheckConsole
(
)
{
for
(
int
i
=
1
;
i
<
gArgc
;
+
+
i
)
{
if
(
strcmp
(
"
-
console
"
gArgv
[
i
]
)
=
=
0
|
|
strcmp
(
"
-
-
console
"
gArgv
[
i
]
)
=
=
0
|
|
strcmp
(
"
/
console
"
gArgv
[
i
]
)
=
=
0
)
{
if
(
AllocConsole
(
)
)
{
if
(
_fileno
(
stdout
)
=
=
-
2
)
{
freopen
(
"
CONOUT
"
"
w
"
stdout
)
;
}
if
(
_fileno
(
stderr
)
=
=
-
2
)
{
freopen
(
"
CONOUT
"
"
w
"
stderr
)
;
}
if
(
_fileno
(
stdin
)
=
=
-
2
)
{
freopen
(
"
CONIN
"
"
r
"
stdin
)
;
}
}
}
else
if
(
strcmp
(
"
-
attach
-
console
"
gArgv
[
i
]
)
=
=
0
|
|
strcmp
(
"
-
-
attach
-
console
"
gArgv
[
i
]
)
=
=
0
|
|
strcmp
(
"
/
attach
-
console
"
gArgv
[
i
]
)
=
=
0
)
{
UseParentConsole
(
)
;
}
}
}
nsresult
NS_CreateNativeAppSupport
(
nsINativeAppSupport
*
*
aResult
)
{
nsNativeAppSupportWin
*
pNative
=
new
nsNativeAppSupportWin
;
if
(
!
pNative
)
return
NS_ERROR_OUT_OF_MEMORY
;
pNative
-
>
CheckConsole
(
)
;
*
aResult
=
pNative
;
NS_ADDREF
(
*
aResult
)
;
return
NS_OK
;
}
#
define
MOZ_MUTEX_NAMESPACE
L
"
Local
\
\
"
#
define
MOZ_STARTUP_MUTEX_NAME
L
"
StartupMutex
"
#
define
MOZ_MUTEX_START_TIMEOUT
30000
char16_t
nsNativeAppSupportWin
:
:
mMutexName
[
128
]
=
{
0
}
;
bool
nsNativeAppSupportWin
:
:
mCanHandleRequests
=
false
;
MessageWindow
*
nsNativeAppSupportWin
:
:
mMsgWindow
=
nullptr
;
class
MessageWindow
final
{
public
:
MessageWindow
(
)
{
mHandle
=
:
:
FindWindowW
(
className
(
)
0
)
;
}
~
MessageWindow
(
)
=
default
;
HWND
handle
(
)
{
return
mHandle
;
}
static
const
wchar_t
*
className
(
)
{
static
wchar_t
classNameBuffer
[
128
]
;
static
wchar_t
*
mClassName
=
0
;
if
(
!
mClassName
)
{
:
:
_snwprintf
(
classNameBuffer
128
L
"
%
s
%
s
"
static_cast
<
const
wchar_t
*
>
(
NS_ConvertUTF8toUTF16
(
gAppData
-
>
remotingName
)
.
get
(
)
)
L
"
MessageWindow
"
)
;
mClassName
=
classNameBuffer
;
}
return
mClassName
;
}
NS_IMETHOD
Create
(
)
{
WNDCLASSW
classStruct
=
{
0
&
MessageWindow
:
:
WindowProc
0
0
0
0
0
0
0
className
(
)
}
;
NS_ENSURE_TRUE
(
:
:
RegisterClassW
(
&
classStruct
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_TRUE
(
(
mHandle
=
:
:
CreateWindowW
(
className
(
)
0
WS_CAPTION
0
0
0
0
0
0
0
0
)
)
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
NS_IMETHOD
Destroy
(
)
{
nsresult
retval
=
NS_OK
;
if
(
mHandle
)
{
BOOL
desRes
=
DestroyWindow
(
mHandle
)
;
if
(
FALSE
!
=
desRes
)
{
mHandle
=
nullptr
;
}
else
{
retval
=
NS_ERROR_FAILURE
;
}
}
return
retval
;
}
NS_IMETHOD
SendRequest
(
)
{
WCHAR
*
cmd
=
:
:
GetCommandLineW
(
)
;
WCHAR
cwd
[
MAX_PATH
]
;
_wgetcwd
(
cwd
MAX_PATH
)
;
NS_ConvertUTF16toUTF8
utf8buffer
(
cmd
)
;
utf8buffer
.
Append
(
'
\
0
'
)
;
WCHAR
*
cwdPtr
=
cwd
;
AppendUTF16toUTF8
(
MakeStringSpan
(
reinterpret_cast
<
char16_t
*
>
(
cwdPtr
)
)
utf8buffer
)
;
utf8buffer
.
Append
(
'
\
0
'
)
;
COPYDATASTRUCT
cds
=
{
1
utf8buffer
.
Length
(
)
(
void
*
)
utf8buffer
.
get
(
)
}
;
:
:
SetForegroundWindow
(
mHandle
)
;
:
:
SendMessage
(
mHandle
WM_COPYDATA
0
(
LPARAM
)
&
cds
)
;
return
NS_OK
;
}
static
LRESULT
CALLBACK
WindowProc
(
HWND
msgWindow
UINT
msg
WPARAM
wp
LPARAM
lp
)
{
if
(
msg
=
=
WM_COPYDATA
)
{
if
(
!
nsNativeAppSupportWin
:
:
mCanHandleRequests
)
return
FALSE
;
COPYDATASTRUCT
*
cds
=
(
COPYDATASTRUCT
*
)
lp
;
nsCOMPtr
<
nsIFile
>
workingDir
;
if
(
1
>
=
cds
-
>
dwData
)
{
char
*
wdpath
=
(
char
*
)
cds
-
>
lpData
;
while
(
*
wdpath
)
+
+
wdpath
;
+
+
wdpath
;
NS_NewLocalFile
(
NS_ConvertUTF8toUTF16
(
wdpath
)
false
getter_AddRefs
(
workingDir
)
)
;
}
(
void
)
nsNativeAppSupportWin
:
:
HandleCommandLine
(
(
char
*
)
cds
-
>
lpData
workingDir
nsICommandLine
:
:
STATE_REMOTE_AUTO
)
;
nsCOMPtr
<
mozIDOMWindowProxy
>
win
;
GetMostRecentWindow
(
0
getter_AddRefs
(
win
)
)
;
return
win
?
(
LRESULT
)
hwndForDOMWindow
(
win
)
:
0
;
}
return
DefWindowProc
(
msgWindow
msg
wp
lp
)
;
}
private
:
HWND
mHandle
;
}
;
NS_IMETHODIMP
nsNativeAppSupportWin
:
:
Start
(
bool
*
aResult
)
{
NS_ENSURE_ARG
(
aResult
)
;
NS_ENSURE_STATE
(
gAppData
)
;
if
(
getenv
(
"
MOZ_NO_REMOTE
"
)
)
{
*
aResult
=
true
;
return
NS_OK
;
}
nsresult
rv
=
NS_ERROR_FAILURE
;
*
aResult
=
false
;
:
:
_snwprintf
(
reinterpret_cast
<
wchar_t
*
>
(
mMutexName
)
sizeof
mMutexName
/
sizeof
(
char16_t
)
L
"
%
s
%
s
%
s
"
MOZ_MUTEX_NAMESPACE
static_cast
<
const
wchar_t
*
>
(
NS_ConvertUTF8toUTF16
(
gAppData
-
>
name
)
.
get
(
)
)
MOZ_STARTUP_MUTEX_NAME
)
;
Win32Mutex
startupLock
=
Win32Mutex
(
mMutexName
)
;
NS_ENSURE_TRUE
(
startupLock
.
Lock
(
MOZ_MUTEX_START_TIMEOUT
)
NS_ERROR_FAILURE
)
;
mMsgWindow
=
new
MessageWindow
(
)
;
if
(
mMsgWindow
-
>
handle
(
)
)
{
rv
=
mMsgWindow
-
>
SendRequest
(
)
;
}
else
{
rv
=
mMsgWindow
-
>
Create
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aResult
=
true
;
}
}
startupLock
.
Unlock
(
)
;
return
rv
;
}
NS_IMETHODIMP
nsNativeAppSupportWin
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
strcmp
(
aTopic
"
quit
-
application
"
)
=
=
0
)
{
Quit
(
)
;
}
else
{
NS_ERROR
(
"
Unexpected
observer
topic
.
"
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNativeAppSupportWin
:
:
Quit
(
)
{
if
(
!
mMsgWindow
)
{
return
NS_OK
;
}
Win32Mutex
mutexLock
(
mMutexName
)
;
NS_ENSURE_TRUE
(
mutexLock
.
Lock
(
MOZ_MUTEX_START_TIMEOUT
)
NS_ERROR_FAILURE
)
;
mMsgWindow
-
>
Destroy
(
)
;
delete
mMsgWindow
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNativeAppSupportWin
:
:
Enable
(
)
{
mCanHandleRequests
=
true
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
this
"
quit
-
application
"
false
)
;
}
else
{
NS_ERROR
(
"
No
observer
service
?
"
)
;
}
return
NS_OK
;
}
void
nsNativeAppSupportWin
:
:
HandleCommandLine
(
const
char
*
aCmdLineString
nsIFile
*
aWorkingDir
uint32_t
aState
)
{
nsresult
rv
;
int
justCounting
=
1
;
char
*
*
argv
=
0
;
int
init
=
1
;
int
between
quoted
bSlashCount
;
int
argc
;
const
char
*
p
;
nsAutoCString
arg
;
nsCOMPtr
<
nsICommandLineRunner
>
cmdLine
(
new
nsCommandLine
(
)
)
;
while
(
1
)
{
if
(
init
)
{
p
=
aCmdLineString
;
between
=
1
;
argc
=
quoted
=
bSlashCount
=
0
;
init
=
0
;
}
if
(
between
)
{
if
(
*
p
!
=
0
&
&
!
isspace
(
*
p
)
)
{
between
=
0
;
arg
=
"
"
;
switch
(
*
p
)
{
case
'
\
\
'
:
bSlashCount
=
1
;
break
;
case
'
"
'
:
quoted
=
1
;
break
;
default
:
arg
+
=
*
p
;
break
;
}
}
else
{
}
}
else
{
if
(
*
p
=
=
0
|
|
(
!
quoted
&
&
isspace
(
*
p
)
)
)
{
while
(
bSlashCount
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
-
;
}
if
(
!
justCounting
)
{
argv
[
argc
]
=
new
char
[
arg
.
Length
(
)
+
1
]
;
strcpy
(
argv
[
argc
]
arg
.
get
(
)
)
;
}
argc
+
+
;
between
=
1
;
}
else
{
switch
(
*
p
)
{
case
'
"
'
:
while
(
bSlashCount
>
1
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
=
2
;
}
if
(
bSlashCount
)
{
arg
+
=
'
"
'
;
bSlashCount
=
0
;
}
else
{
if
(
quoted
)
{
if
(
*
(
p
+
1
)
=
=
'
"
'
)
{
bSlashCount
=
1
;
}
else
{
quoted
=
0
;
}
}
else
{
quoted
=
1
;
}
}
break
;
case
'
\
\
'
:
bSlashCount
+
+
;
break
;
default
:
while
(
bSlashCount
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
-
;
}
arg
+
=
*
p
;
break
;
}
}
}
if
(
*
p
)
{
p
+
+
;
}
else
{
if
(
justCounting
)
{
argv
=
new
char
*
[
argc
]
;
justCounting
=
0
;
init
=
1
;
}
else
{
break
;
}
}
}
rv
=
cmdLine
-
>
Init
(
argc
argv
aWorkingDir
aState
)
;
while
(
argc
)
{
delete
[
]
argv
[
-
-
argc
]
;
}
delete
[
]
argv
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
Error
initializing
command
line
.
"
)
;
return
;
}
cmdLine
-
>
Run
(
)
;
}
HWND
hwndForDOMWindow
(
mozIDOMWindowProxy
*
window
)
{
if
(
!
window
)
{
return
0
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
pidomwindow
=
nsPIDOMWindowOuter
:
:
From
(
window
)
;
nsCOMPtr
<
nsIBaseWindow
>
ppBaseWindow
=
do_QueryInterface
(
pidomwindow
-
>
GetDocShell
(
)
)
;
if
(
!
ppBaseWindow
)
{
return
0
;
}
nsCOMPtr
<
nsIWidget
>
ppWidget
;
ppBaseWindow
-
>
GetMainWidget
(
getter_AddRefs
(
ppWidget
)
)
;
return
(
HWND
)
(
ppWidget
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
)
;
}
