#
include
<
AppKit
/
AppKit
.
h
>
#
include
<
ApplicationServices
/
ApplicationServices
.
h
>
#
include
<
CoreFoundation
/
CoreFoundation
.
h
>
#
include
<
CoreServices
/
CoreServices
.
h
>
#
include
<
IOKit
/
IOKitLib
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
sys
/
mount
.
h
>
#
include
<
sys
/
param
.
h
>
#
include
"
MacLaunchHelper
.
h
"
#
include
"
MacRunFromDmgUtils
.
h
"
#
include
"
MacUtils
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
glean
/
GleanMetrics
.
h
"
#
include
"
mozilla
/
intl
/
Localization
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsCommandLine
.
h
"
#
include
"
nsCommandLineServiceMac
.
h
"
#
include
"
nsILocalFileMac
.
h
"
#
include
"
nsIMacDockSupport
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsString
.
h
"
#
ifdef
MOZ_UPDATER
#
include
"
nsUpdateDriver
.
h
"
#
endif
using
namespace
mozilla
:
:
MacUtils
;
using
namespace
mozilla
:
:
MacLaunchHelper
;
namespace
mozilla
:
:
MacRunFromDmgUtils
{
static
bool
AskUserIfWeShouldLaunchExistingInstall
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsTArray
<
nsCString
>
resIds
=
{
"
branding
/
brand
.
ftl
"
_ns
"
toolkit
/
global
/
run
-
from
-
dmg
.
ftl
"
_ns
}
;
RefPtr
<
intl
:
:
Localization
>
l10n
=
intl
:
:
Localization
:
:
Create
(
resIds
true
)
;
ErrorResult
rv
;
nsAutoCString
mozTitle
mozMessage
mozLaunchExisting
mozLaunchFromDMG
;
l10n
-
>
FormatValueSync
(
"
prompt
-
to
-
launch
-
existing
-
app
-
title
"
_ns
{
}
mozTitle
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
false
;
}
l10n
-
>
FormatValueSync
(
"
prompt
-
to
-
launch
-
existing
-
app
-
message
"
_ns
{
}
mozMessage
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
false
;
}
l10n
-
>
FormatValueSync
(
"
prompt
-
to
-
launch
-
existing
-
app
-
yes
-
button
"
_ns
{
}
mozLaunchExisting
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
false
;
}
l10n
-
>
FormatValueSync
(
"
prompt
-
to
-
launch
-
existing
-
app
-
no
-
button
"
_ns
{
}
mozLaunchFromDMG
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
false
;
}
NSString
*
title
=
[
NSString
stringWithUTF8String
:
reinterpret_cast
<
const
char
*
>
(
mozTitle
.
get
(
)
)
]
;
NSString
*
message
=
[
NSString
stringWithUTF8String
:
reinterpret_cast
<
const
char
*
>
(
mozMessage
.
get
(
)
)
]
;
NSString
*
launchExisting
=
[
NSString
stringWithUTF8String
:
reinterpret_cast
<
const
char
*
>
(
mozLaunchExisting
.
get
(
)
)
]
;
NSString
*
launchFromDMG
=
[
NSString
stringWithUTF8String
:
reinterpret_cast
<
const
char
*
>
(
mozLaunchFromDMG
.
get
(
)
)
]
;
NSAlert
*
alert
=
[
[
[
NSAlert
alloc
]
init
]
autorelease
]
;
[
alert
setAlertStyle
:
NSAlertStyleInformational
]
;
[
alert
setMessageText
:
title
]
;
[
alert
setInformativeText
:
message
]
;
[
alert
addButtonWithTitle
:
launchExisting
]
;
NSButton
*
launchFromDMGButton
=
[
alert
addButtonWithTitle
:
launchFromDMG
]
;
[
launchFromDMGButton
setKeyEquivalent
:
"
\
e
"
]
;
__block
NSInteger
result
=
-
1
;
dispatch_async
(
dispatch_get_main_queue
(
)
^
{
result
=
[
alert
runModal
]
;
[
NSApp
stop
:
nil
]
;
}
)
;
[
NSApp
run
]
;
MOZ_ASSERT
(
result
!
=
-
1
)
;
return
result
=
=
NSAlertFirstButtonReturn
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
false
)
;
}
static
bool
AskUserIfWeShouldInstall
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsTArray
<
nsCString
>
resIds
=
{
"
branding
/
brand
.
ftl
"
_ns
"
toolkit
/
global
/
run
-
from
-
dmg
.
ftl
"
_ns
}
;
RefPtr
<
intl
:
:
Localization
>
l10n
=
intl
:
:
Localization
:
:
Create
(
resIds
true
)
;
ErrorResult
rv
;
nsAutoCString
mozTitle
mozMessage
mozInstall
mozDontInstall
;
l10n
-
>
FormatValueSync
(
"
prompt
-
to
-
install
-
title
"
_ns
{
}
mozTitle
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
false
;
}
l10n
-
>
FormatValueSync
(
"
prompt
-
to
-
install
-
message
"
_ns
{
}
mozMessage
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
false
;
}
l10n
-
>
FormatValueSync
(
"
prompt
-
to
-
install
-
yes
-
button
"
_ns
{
}
mozInstall
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
false
;
}
l10n
-
>
FormatValueSync
(
"
prompt
-
to
-
install
-
no
-
button
"
_ns
{
}
mozDontInstall
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
false
;
}
NSString
*
title
=
[
NSString
stringWithUTF8String
:
reinterpret_cast
<
const
char
*
>
(
mozTitle
.
get
(
)
)
]
;
NSString
*
message
=
[
NSString
stringWithUTF8String
:
reinterpret_cast
<
const
char
*
>
(
mozMessage
.
get
(
)
)
]
;
NSString
*
install
=
[
NSString
stringWithUTF8String
:
reinterpret_cast
<
const
char
*
>
(
mozInstall
.
get
(
)
)
]
;
NSString
*
dontInstall
=
[
NSString
stringWithUTF8String
:
reinterpret_cast
<
const
char
*
>
(
mozDontInstall
.
get
(
)
)
]
;
NSAlert
*
alert
=
[
[
[
NSAlert
alloc
]
init
]
autorelease
]
;
[
alert
setAlertStyle
:
NSAlertStyleInformational
]
;
[
alert
setMessageText
:
title
]
;
[
alert
setInformativeText
:
message
]
;
[
alert
addButtonWithTitle
:
install
]
;
NSButton
*
dontInstallButton
=
[
alert
addButtonWithTitle
:
dontInstall
]
;
[
dontInstallButton
setKeyEquivalent
:
"
\
e
"
]
;
__block
NSInteger
result
=
-
1
;
dispatch_async
(
dispatch_get_main_queue
(
)
^
{
result
=
[
alert
runModal
]
;
[
NSApp
stop
:
nil
]
;
}
)
;
[
NSApp
run
]
;
MOZ_ASSERT
(
result
!
=
-
1
)
;
return
result
=
=
NSAlertFirstButtonReturn
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
false
)
;
}
static
void
ShowInstallFailedDialog
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
nsTArray
<
nsCString
>
resIds
=
{
"
branding
/
brand
.
ftl
"
_ns
"
toolkit
/
global
/
run
-
from
-
dmg
.
ftl
"
_ns
}
;
RefPtr
<
intl
:
:
Localization
>
l10n
=
intl
:
:
Localization
:
:
Create
(
resIds
true
)
;
ErrorResult
rv
;
nsAutoCString
mozTitle
mozMessage
;
l10n
-
>
FormatValueSync
(
"
install
-
failed
-
title
"
_ns
{
}
mozTitle
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
;
}
l10n
-
>
FormatValueSync
(
"
install
-
failed
-
message
"
_ns
{
}
mozMessage
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
;
}
NSString
*
title
=
[
NSString
stringWithUTF8String
:
reinterpret_cast
<
const
char
*
>
(
mozTitle
.
get
(
)
)
]
;
NSString
*
message
=
[
NSString
stringWithUTF8String
:
reinterpret_cast
<
const
char
*
>
(
mozMessage
.
get
(
)
)
]
;
NSAlert
*
alert
=
[
[
[
NSAlert
alloc
]
init
]
autorelease
]
;
[
alert
setAlertStyle
:
NSAlertStyleWarning
]
;
[
alert
setMessageText
:
title
]
;
[
alert
setInformativeText
:
message
]
;
__block
NSInteger
result
=
-
1
;
dispatch_async
(
dispatch_get_main_queue
(
)
^
{
result
=
[
alert
runModal
]
;
[
NSApp
stop
:
nil
]
;
}
)
;
[
NSApp
run
]
;
MOZ_ASSERT
(
result
!
=
-
1
)
;
(
void
)
result
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
#
ifdef
MOZ_UPDATER
bool
LaunchElevatedDmgInstall
(
NSString
*
aBundlePath
NSArray
*
aArguments
)
{
NSTask
*
task
=
[
[
NSTask
alloc
]
init
]
;
[
task
setExecutableURL
:
[
NSURL
fileURLWithPath
:
aBundlePath
]
]
;
if
(
aArguments
)
{
[
task
setArguments
:
aArguments
]
;
}
[
task
launchAndReturnError
:
nil
]
;
bool
didSucceed
=
InstallPrivilegedHelper
(
)
;
[
task
waitUntilExit
]
;
[
task
release
]
;
if
(
!
didSucceed
)
{
AbortElevatedUpdate
(
)
;
}
return
didSucceed
;
}
#
endif
static
bool
InstallFromPath
(
NSString
*
aBundlePath
NSString
*
aDestPath
)
{
bool
installSuccessful
=
false
;
NSFileManager
*
fileManager
=
[
NSFileManager
defaultManager
]
;
if
(
[
fileManager
copyItemAtPath
:
aBundlePath
toPath
:
aDestPath
error
:
nil
]
)
{
installSuccessful
=
true
;
}
#
ifdef
MOZ_UPDATER
NSString
*
destDir
=
[
aDestPath
stringByDeletingLastPathComponent
]
;
if
(
!
installSuccessful
&
&
!
[
fileManager
isWritableFileAtPath
:
destDir
]
)
{
NSString
*
updaterBinPath
=
[
NSString
pathWithComponents
:
[
aBundlePath
"
Contents
"
"
MacOS
"
[
NSString
stringWithUTF8String
:
UPDATER_APP
]
"
Contents
"
"
MacOS
"
[
NSString
stringWithUTF8String
:
UPDATER_BIN
]
]
]
;
NSArray
*
arguments
=
[
"
-
dmgInstall
"
aBundlePath
aDestPath
]
;
LaunchElevatedDmgInstall
(
updaterBinPath
arguments
)
;
installSuccessful
=
[
fileManager
fileExistsAtPath
:
aDestPath
]
;
}
#
endif
if
(
!
installSuccessful
)
{
return
false
;
}
nsresult
rv
;
nsCOMPtr
<
nsIMacDockSupport
>
dockSupport
=
do_GetService
(
"
mozilla
.
org
/
widget
/
macdocksupport
;
1
"
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
dockSupport
)
{
bool
isInDock
;
nsAutoString
appPath
appToReplacePath
;
nsCocoaUtils
:
:
GetStringForNSString
(
aDestPath
appPath
)
;
nsCocoaUtils
:
:
GetStringForNSString
(
aBundlePath
appToReplacePath
)
;
dockSupport
-
>
EnsureAppIsPinnedToDock
(
appPath
appToReplacePath
&
isInDock
)
;
}
return
true
;
}
bool
IsAppRunningFromDmg
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
const
char
*
path
=
[
[
[
NSBundle
mainBundle
]
bundlePath
]
fileSystemRepresentation
]
;
struct
statfs
statfsBuf
;
if
(
statfs
(
path
&
statfsBuf
)
!
=
0
)
{
return
false
;
}
if
(
!
(
statfsBuf
.
f_flags
&
MNT_RDONLY
)
)
{
return
false
;
}
const
char
devDirPath
[
]
=
"
/
dev
/
"
;
const
int
devDirPathLength
=
strlen
(
devDirPath
)
;
if
(
strncmp
(
statfsBuf
.
f_mntfromname
devDirPath
devDirPathLength
)
!
=
0
)
{
nsCString
volumesPath
(
statfsBuf
.
f_mntfromname
)
;
if
(
statfs
(
volumesPath
.
get
(
)
&
statfsBuf
)
!
=
0
)
{
return
false
;
}
if
(
strncmp
(
statfsBuf
.
f_mntfromname
devDirPath
devDirPathLength
)
!
=
0
)
{
return
false
;
}
}
const
char
*
bsdDeviceName
=
statfsBuf
.
f_mntfromname
+
devDirPathLength
;
CFMutableDictionaryRef
serviceDict
=
IOBSDNameMatching
(
kIOMasterPortDefault
0
bsdDeviceName
)
;
if
(
!
serviceDict
)
{
return
false
;
}
io_service_t
media
=
IOServiceGetMatchingService
(
kIOMasterPortDefault
serviceDict
)
;
if
(
!
media
|
|
!
IOObjectConformsTo
(
media
"
IOMedia
"
)
)
{
return
false
;
}
io_service_t
imageDrive
=
IO_OBJECT_NULL
;
io_iterator_t
iter
;
if
(
IORegistryEntryCreateIterator
(
media
kIOServicePlane
kIORegistryIterateRecursively
|
kIORegistryIterateParents
&
iter
)
!
=
KERN_SUCCESS
)
{
IOObjectRelease
(
media
)
;
return
false
;
}
const
char
*
imageClass
=
nsCocoaFeatures
:
:
OnMontereyOrLater
(
)
?
"
AppleDiskImageDevice
"
:
"
IOHDIXHDDrive
"
;
for
(
imageDrive
=
media
;
imageDrive
;
imageDrive
=
IOIteratorNext
(
iter
)
)
{
if
(
IOObjectConformsTo
(
imageDrive
imageClass
)
)
{
break
;
}
IOObjectRelease
(
imageDrive
)
;
}
IOObjectRelease
(
iter
)
;
if
(
imageDrive
)
{
IOObjectRelease
(
imageDrive
)
;
return
true
;
}
return
false
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
false
)
;
}
bool
MaybeInstallAndRelaunch
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
autoreleasepool
{
bool
isFromDmg
=
IsAppRunningFromDmg
(
)
;
bool
isTranslocated
=
false
;
if
(
!
isFromDmg
)
{
NSString
*
bundlePath
=
[
[
NSBundle
mainBundle
]
bundlePath
]
;
if
(
[
bundlePath
containsString
:
"
/
AppTranslocation
/
"
]
)
{
isTranslocated
=
true
;
}
}
if
(
!
isFromDmg
&
&
!
isTranslocated
)
{
return
false
;
}
NSArray
*
applicationsDirs
=
NSSearchPathForDirectoriesInDomains
(
NSApplicationDirectory
NSLocalDomainMask
YES
)
;
NSString
*
applicationsDir
=
applicationsDirs
[
0
]
;
NSFileManager
*
fileManager
=
[
NSFileManager
defaultManager
]
;
BOOL
isDir
;
if
(
!
[
fileManager
fileExistsAtPath
:
applicationsDir
isDirectory
:
&
isDir
]
|
|
!
isDir
)
{
return
false
;
}
NSString
*
bundlePath
=
[
[
NSBundle
mainBundle
]
bundlePath
]
;
NSString
*
appName
=
[
bundlePath
lastPathComponent
]
;
NSString
*
destPath
=
[
applicationsDir
stringByAppendingPathComponent
:
appName
]
;
if
(
[
fileManager
fileExistsAtPath
:
destPath
]
)
{
if
(
AskUserIfWeShouldLaunchExistingInstall
(
)
)
{
LaunchMacAppWithBundle
(
destPath
)
;
return
true
;
}
return
false
;
}
if
(
!
AskUserIfWeShouldInstall
(
)
)
{
return
false
;
}
if
(
!
InstallFromPath
(
bundlePath
destPath
)
)
{
ShowInstallFailedDialog
(
)
;
return
false
;
}
LaunchMacAppWithBundle
(
destPath
)
;
return
true
;
}
NS_OBJC_END_TRY_BLOCK_RETURN
(
false
)
;
}
}
