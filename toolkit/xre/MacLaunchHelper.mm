#
include
"
MacLaunchHelper
.
h
"
#
include
"
MacAutoreleasePool
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
Cocoa
/
Cocoa
.
h
>
#
include
<
crt_externs
.
h
>
#
include
<
ServiceManagement
/
ServiceManagement
.
h
>
#
include
<
Security
/
Authorization
.
h
>
#
include
<
spawn
.
h
>
#
include
<
stdio
.
h
>
using
namespace
mozilla
;
void
LaunchChildMac
(
int
aArgc
char
*
*
aArgv
pid_t
*
aPid
)
{
MacAutoreleasePool
pool
;
try
{
NSString
*
launchPath
=
[
NSString
stringWithUTF8String
:
aArgv
[
0
]
]
;
NSMutableArray
*
arguments
=
[
NSMutableArray
arrayWithCapacity
:
aArgc
-
1
]
;
for
(
int
i
=
1
;
i
<
aArgc
;
i
+
+
)
{
[
arguments
addObject
:
[
NSString
stringWithUTF8String
:
aArgv
[
i
]
]
]
;
}
__block
dispatch_semaphore_t
semaphore
=
dispatch_semaphore_create
(
0
)
;
NSWorkspaceOpenConfiguration
*
config
=
[
NSWorkspaceOpenConfiguration
configuration
]
;
[
config
setArguments
:
arguments
]
;
[
config
setCreatesNewApplicationInstance
:
YES
]
;
[
[
NSWorkspace
sharedWorkspace
]
openApplicationAtURL
:
[
NSURL
URLWithString
:
launchPath
]
configuration
:
config
completionHandler
:
^
(
NSRunningApplication
*
child
NSError
*
error
)
{
if
(
error
)
{
NSLog
(
"
Failed
to
run
:
%
"
error
)
;
}
if
(
aPid
)
{
*
aPid
=
[
child
processIdentifier
]
;
}
dispatch_semaphore_signal
(
semaphore
)
;
}
]
;
dispatch_semaphore_wait
(
semaphore
DISPATCH_TIME_FOREVER
)
;
}
catch
(
NSException
*
e
)
{
NSLog
(
"
%
:
%
"
e
.
name
e
.
reason
)
;
}
}
bool
InstallPrivilegedHelper
(
)
{
AuthorizationRef
authRef
=
NULL
;
OSStatus
status
=
AuthorizationCreate
(
NULL
kAuthorizationEmptyEnvironment
kAuthorizationFlagDefaults
|
kAuthorizationFlagInteractionAllowed
&
authRef
)
;
if
(
status
!
=
errAuthorizationSuccess
)
{
NSLog
(
"
AuthorizationCreate
failed
!
NSOSStatusErrorDomain
/
%
d
"
(
int
)
status
)
;
return
NO
;
}
BOOL
result
=
NO
;
AuthorizationItem
authItem
=
{
kSMRightBlessPrivilegedHelper
0
NULL
0
}
;
AuthorizationRights
authRights
=
{
1
&
authItem
}
;
AuthorizationFlags
flags
=
kAuthorizationFlagDefaults
|
kAuthorizationFlagInteractionAllowed
|
kAuthorizationFlagPreAuthorize
|
kAuthorizationFlagExtendRights
;
status
=
AuthorizationCopyRights
(
authRef
&
authRights
kAuthorizationEmptyEnvironment
flags
NULL
)
;
if
(
status
!
=
errAuthorizationSuccess
)
{
NSLog
(
"
AuthorizationCopyRights
failed
!
NSOSStatusErrorDomain
/
%
d
"
(
int
)
status
)
;
}
else
{
CFErrorRef
cfError
;
result
=
(
BOOL
)
SMJobBless
(
kSMDomainSystemLaunchd
(
CFStringRef
)
"
org
.
mozilla
.
updater
"
authRef
&
cfError
)
;
if
(
!
result
)
{
NSLog
(
"
Unable
to
install
helper
!
"
)
;
CFRelease
(
cfError
)
;
}
}
return
result
;
}
void
AbortElevatedUpdate
(
)
{
mozilla
:
:
MacAutoreleasePool
pool
;
id
updateServer
=
nil
;
int
currTry
=
0
;
const
int
numRetries
=
10
;
while
(
currTry
<
numRetries
)
{
try
{
updateServer
=
(
id
)
[
NSConnection
rootProxyForConnectionWithRegisteredName
:
"
org
.
mozilla
.
updater
.
server
"
host
:
nil
usingNameServer
:
[
NSSocketPortNameServer
sharedInstance
]
]
;
if
(
updateServer
&
&
[
updateServer
respondsToSelector
:
selector
(
abort
)
]
)
{
[
updateServer
performSelector
:
selector
(
abort
)
]
;
return
;
}
NSLog
(
"
Server
doesn
'
t
exist
or
doesn
'
t
provide
correct
selectors
.
"
)
;
sleep
(
1
)
;
currTry
+
+
;
}
catch
(
NSException
*
e
)
{
NSLog
(
"
Encountered
exception
retrying
:
%
:
%
"
e
.
name
e
.
reason
)
;
sleep
(
1
)
;
currTry
+
+
;
}
}
NSLog
(
"
Unable
to
clean
up
updater
.
"
)
;
}
bool
LaunchElevatedUpdate
(
int
aArgc
char
*
*
aArgv
pid_t
*
aPid
)
{
LaunchChildMac
(
aArgc
aArgv
aPid
)
;
bool
didSucceed
=
InstallPrivilegedHelper
(
)
;
if
(
!
didSucceed
)
{
AbortElevatedUpdate
(
)
;
}
return
didSucceed
;
}
