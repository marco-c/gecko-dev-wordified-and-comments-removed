#
include
<
AppKit
/
AppKit
.
h
>
#
import
<
Cocoa
/
Cocoa
.
h
>
#
include
"
NativeMenuMac
.
h
"
#
import
<
Carbon
/
Carbon
.
h
>
#
include
"
CustomCocoaEvents
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsINativeAppSupport
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsAppShell
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIAppStartup
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsCommandLine
.
h
"
#
include
"
nsIMacDockSupport
.
h
"
#
include
"
nsIStandaloneNativeMenu
.
h
"
#
include
"
nsILocalFileMac
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCommandLineServiceMac
.
h
"
#
include
"
nsCommandLine
.
h
"
#
include
"
nsStandaloneNativeMenu
.
h
"
#
include
"
nsCocoaUtils
.
h
"
class
AutoAutoreleasePool
{
public
:
AutoAutoreleasePool
(
)
{
mLocalPool
=
[
[
NSAutoreleasePool
alloc
]
init
]
;
}
~
AutoAutoreleasePool
(
)
{
[
mLocalPool
release
]
;
}
private
:
NSAutoreleasePool
*
mLocalPool
;
}
;
interface
MacApplicationDelegate
:
NSObject
<
NSApplicationDelegate
>
{
}
end
enum
class
LaunchStatus
{
Initial
DelegateIsSetup
ProcessingURLs
ProcessedURLs
}
;
static
LaunchStatus
sLaunchStatus
=
LaunchStatus
:
:
Initial
;
void
EnsureUseCocoaDockAPI
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
GeckoNSApplication
sharedApplication
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
DisableAppNap
(
)
{
[
[
NSUserDefaults
standardUserDefaults
]
registerDefaults
:
{
"
NSAppSleepDisabled
"
:
YES
}
]
;
}
void
SetupMacApplicationDelegate
(
bool
*
gRestartedByOS
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
AutoAutoreleasePool
pool
;
[
GeckoNSApplication
sharedApplication
]
;
[
[
NSUserDefaults
standardUserDefaults
]
setObject
:
"
NO
"
forKey
:
"
NSTreatUnknownArgumentsAsOpen
"
]
;
id
<
NSApplicationDelegate
>
delegate
=
[
[
MacApplicationDelegate
alloc
]
init
]
;
[
[
GeckoNSApplication
sharedApplication
]
setDelegate
:
delegate
]
;
*
gRestartedByOS
=
!
!
nsCocoaUtils
:
:
ShouldRestoreStateDueToLaunchAtLogin
(
)
;
MOZ_ASSERT
(
sLaunchStatus
=
=
LaunchStatus
:
:
Initial
"
Launch
status
should
be
in
intial
state
when
setting
up
delegate
"
)
;
sLaunchStatus
=
LaunchStatus
:
:
DelegateIsSetup
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
ProcessPendingGetURLAppleEvents
(
)
{
if
(
sLaunchStatus
!
=
LaunchStatus
:
:
DelegateIsSetup
)
{
return
;
}
sLaunchStatus
=
LaunchStatus
:
:
ProcessingURLs
;
[
NSApp
run
]
;
sLaunchStatus
=
LaunchStatus
:
:
ProcessedURLs
;
}
implementation
MacApplicationDelegate
-
(
id
)
init
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
(
self
=
[
super
init
]
)
)
{
if
(
!
[
NSApp
windowsMenu
]
)
{
NSMenu
*
windowsMenu
=
[
[
NSMenu
alloc
]
initWithTitle
:
"
Window
"
]
;
[
NSApp
setWindowsMenu
:
windowsMenu
]
;
[
windowsMenu
release
]
;
}
}
return
self
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
BOOL
)
applicationShouldHandleReopen
:
(
NSApplication
*
)
theApp
hasVisibleWindows
:
(
BOOL
)
flag
{
nsCOMPtr
<
nsINativeAppSupport
>
nas
=
NS_GetNativeAppSupport
(
)
;
NS_ENSURE_TRUE
(
nas
NO
)
;
nsresult
rv
=
nas
-
>
ReOpen
(
)
;
NS_ENSURE_SUCCESS
(
rv
NO
)
;
return
NO
;
}
-
(
BOOL
)
application
:
(
NSApplication
*
)
theApplication
printFile
:
(
NSString
*
)
filename
{
return
NO
;
}
-
(
BOOL
)
applicationSupportsSecureRestorableState
:
(
NSApplication
*
)
app
{
return
YES
;
}
-
(
NSMenu
*
)
applicationDockMenu
:
(
NSApplication
*
)
sender
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSMenu
*
menu
=
[
[
[
NSMenu
alloc
]
initWithTitle
:
"
"
]
autorelease
]
;
[
menu
setAutoenablesItems
:
NO
]
;
nsresult
rv
;
nsCOMPtr
<
nsIMacDockSupport
>
dockSupport
=
do_GetService
(
"
mozilla
.
org
/
widget
/
macdocksupport
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
dockSupport
)
return
menu
;
nsCOMPtr
<
nsIStandaloneNativeMenu
>
dockMenuInterface
;
rv
=
dockSupport
-
>
GetDockMenu
(
getter_AddRefs
(
dockMenuInterface
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
dockMenuInterface
)
return
menu
;
RefPtr
<
mozilla
:
:
widget
:
:
NativeMenuMac
>
dockMenu
=
static_cast
<
nsStandaloneNativeMenu
*
>
(
dockMenuInterface
.
get
(
)
)
-
>
GetNativeMenu
(
)
;
dockMenu
-
>
MenuWillOpen
(
)
;
NSMenu
*
nativeDockMenu
=
dockMenu
-
>
NativeNSMenu
(
)
;
if
(
!
nativeDockMenu
)
{
return
menu
;
}
int
numDockMenuItems
=
[
nativeDockMenu
numberOfItems
]
;
if
(
numDockMenuItems
>
0
)
{
if
(
[
menu
numberOfItems
]
>
0
)
[
menu
addItem
:
[
NSMenuItem
separatorItem
]
]
;
for
(
int
i
=
0
;
i
<
numDockMenuItems
;
i
+
+
)
{
NSMenuItem
*
itemCopy
=
[
[
nativeDockMenu
itemAtIndex
:
i
]
copy
]
;
[
menu
addItem
:
itemCopy
]
;
[
itemCopy
release
]
;
}
}
return
menu
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
void
)
applicationWillFinishLaunching
:
(
NSNotification
*
)
notification
{
[
[
NSUserDefaults
standardUserDefaults
]
setBool
:
NO
forKey
:
"
NSFullScreenMenuItemEverywhere
"
]
;
}
-
(
void
)
applicationDidFinishLaunching
:
(
NSNotification
*
)
notification
{
if
(
sLaunchStatus
=
=
LaunchStatus
:
:
ProcessingURLs
)
{
[
NSApp
stop
:
self
]
;
[
NSApp
postEvent
:
[
NSEvent
otherEventWithType
:
NSEventTypeApplicationDefined
location
:
NSMakePoint
(
0
0
)
modifierFlags
:
0
timestamp
:
0
windowNumber
:
0
context
:
NULL
subtype
:
kEventSubtypeNone
data1
:
0
data2
:
0
]
atStart
:
NO
]
;
}
}
-
(
NSApplicationTerminateReply
)
applicationShouldTerminate
:
(
NSApplication
*
)
sender
{
nsCOMPtr
<
nsIObserverService
>
obsServ
=
do_GetService
(
"
mozilla
.
org
/
observer
-
service
;
1
"
)
;
if
(
!
obsServ
)
return
NSTerminateNow
;
nsCOMPtr
<
nsISupportsPRBool
>
cancelQuit
=
do_CreateInstance
(
NS_SUPPORTS_PRBOOL_CONTRACTID
)
;
if
(
!
cancelQuit
)
return
NSTerminateNow
;
cancelQuit
-
>
SetData
(
false
)
;
obsServ
-
>
NotifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
nullptr
)
;
bool
abortQuit
;
cancelQuit
-
>
GetData
(
&
abortQuit
)
;
if
(
abortQuit
)
return
NSTerminateCancel
;
nsCOMPtr
<
nsIAppStartup
>
appService
=
do_GetService
(
"
mozilla
.
org
/
toolkit
/
app
-
startup
;
1
"
)
;
if
(
appService
)
{
bool
userAllowedQuit
=
true
;
appService
-
>
Quit
(
nsIAppStartup
:
:
eForceQuit
0
&
userAllowedQuit
)
;
if
(
!
userAllowedQuit
)
{
return
NSTerminateCancel
;
}
}
return
NSTerminateNow
;
}
-
(
void
)
application
:
(
NSApplication
*
)
application
openURLs
:
(
NSArray
<
NSURL
*
>
*
)
urls
{
[
self
openURLs
:
urls
]
;
}
-
(
BOOL
)
application
:
(
NSApplication
*
)
application
willContinueUserActivityWithType
:
(
NSString
*
)
userActivityType
{
return
[
userActivityType
isEqualToString
:
NSUserActivityTypeBrowsingWeb
]
;
}
-
(
BOOL
)
application
:
(
NSApplication
*
)
application
continueUserActivity
:
(
NSUserActivity
*
)
userActivity
restorationHandler
:
(
void
(
^
)
(
NSArray
<
id
<
NSUserActivityRestoring
>
>
*
)
)
restorationHandler
{
if
(
!
[
userActivity
.
activityType
isEqualToString
:
NSUserActivityTypeBrowsingWeb
]
)
{
return
NO
;
}
return
[
self
openURLs
:
[
userActivity
.
webpageURL
]
]
;
}
-
(
void
)
application
:
(
NSApplication
*
)
application
didFailToContinueUserActivityWithType
:
(
NSString
*
)
userActivityType
error
:
(
NSError
*
)
error
{
NSLog
(
"
Failed
to
continue
user
activity
%
:
%
"
userActivityType
error
)
;
}
-
(
BOOL
)
openURLs
:
(
NSArray
<
NSURL
*
>
*
)
urls
{
nsTArray
<
const
char
*
>
args
(
[
urls
count
]
*
2
+
2
)
;
args
.
AppendElement
(
nullptr
)
;
for
(
NSURL
*
url
in
urls
)
{
if
(
!
url
|
|
!
url
.
scheme
|
|
[
url
.
scheme
caseInsensitiveCompare
:
"
chrome
"
]
=
=
NSOrderedSame
)
{
continue
;
}
const
char
*
const
urlString
=
[
[
url
absoluteString
]
UTF8String
]
;
if
(
CommandLineServiceMac
:
:
AddURLToCurrentCommandLine
(
urlString
)
)
{
continue
;
}
args
.
AppendElement
(
"
-
url
"
)
;
args
.
AppendElement
(
urlString
)
;
}
if
(
args
.
Length
(
)
<
=
1
)
{
return
NO
;
}
nsCOMPtr
<
nsICommandLineRunner
>
cmdLine
(
new
nsCommandLine
(
)
)
;
nsCOMPtr
<
nsIFile
>
workingDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_OS_CURRENT_WORKING_DIR
getter_AddRefs
(
workingDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
workingDir
=
nullptr
;
}
rv
=
cmdLine
-
>
Init
(
args
.
Length
(
)
args
.
Elements
(
)
workingDir
nsICommandLine
:
:
STATE_REMOTE_EXPLICIT
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NO
;
}
rv
=
cmdLine
-
>
Run
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NO
;
}
return
YES
;
}
end
