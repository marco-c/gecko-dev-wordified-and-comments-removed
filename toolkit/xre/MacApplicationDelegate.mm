#
import
<
Cocoa
/
Cocoa
.
h
>
#
import
<
Carbon
/
Carbon
.
h
>
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsINativeAppSupport
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsAppShell
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIAppStartup
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsCommandLine
.
h
"
#
include
"
nsIMacDockSupport
.
h
"
#
include
"
nsIStandaloneNativeMenu
.
h
"
#
include
"
nsILocalFileMac
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCommandLineServiceMac
.
h
"
#
include
"
nsCommandLine
.
h
"
class
AutoAutoreleasePool
{
public
:
AutoAutoreleasePool
(
)
{
mLocalPool
=
[
[
NSAutoreleasePool
alloc
]
init
]
;
}
~
AutoAutoreleasePool
(
)
{
[
mLocalPool
release
]
;
}
private
:
NSAutoreleasePool
*
mLocalPool
;
}
;
interface
MacApplicationDelegate
:
NSObject
<
NSApplicationDelegate
>
{
}
end
static
bool
sProcessedGetURLEvent
=
false
;
void
EnsureUseCocoaDockAPI
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
GeckoNSApplication
sharedApplication
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
DisableAppNap
(
)
{
[
[
NSUserDefaults
standardUserDefaults
]
registerDefaults
:
{
"
NSAppSleepDisabled
"
:
YES
}
]
;
}
void
SetupMacApplicationDelegate
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
AutoAutoreleasePool
pool
;
[
GeckoNSApplication
sharedApplication
]
;
[
[
NSUserDefaults
standardUserDefaults
]
setObject
:
"
NO
"
forKey
:
"
NSTreatUnknownArgumentsAsOpen
"
]
;
id
<
NSApplicationDelegate
>
delegate
=
[
[
MacApplicationDelegate
alloc
]
init
]
;
[
[
GeckoNSApplication
sharedApplication
]
setDelegate
:
delegate
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
ProcessPendingGetURLAppleEvents
(
)
{
AutoAutoreleasePool
pool
;
bool
keepSpinning
=
true
;
while
(
keepSpinning
)
{
sProcessedGetURLEvent
=
false
;
NSEvent
*
event
=
[
NSApp
nextEventMatchingMask
:
NSAnyEventMask
untilDate
:
nil
inMode
:
NSDefaultRunLoopMode
dequeue
:
YES
]
;
if
(
event
)
[
NSApp
sendEvent
:
event
]
;
keepSpinning
=
sProcessedGetURLEvent
;
}
}
implementation
MacApplicationDelegate
-
(
id
)
init
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
if
(
(
self
=
[
super
init
]
)
)
{
NSAppleEventManager
*
aeMgr
=
[
NSAppleEventManager
sharedAppleEventManager
]
;
[
aeMgr
setEventHandler
:
self
andSelector
:
selector
(
handleAppleEvent
:
withReplyEvent
:
)
forEventClass
:
kInternetEventClass
andEventID
:
kAEGetURL
]
;
[
aeMgr
setEventHandler
:
self
andSelector
:
selector
(
handleAppleEvent
:
withReplyEvent
:
)
forEventClass
:
'
WWW
!
'
andEventID
:
'
OURL
'
]
;
[
aeMgr
setEventHandler
:
self
andSelector
:
selector
(
handleAppleEvent
:
withReplyEvent
:
)
forEventClass
:
kCoreEventClass
andEventID
:
kAEOpenDocuments
]
;
if
(
!
[
NSApp
windowsMenu
]
)
{
NSMenu
*
windowsMenu
=
[
[
NSMenu
alloc
]
initWithTitle
:
"
Window
"
]
;
[
NSApp
setWindowsMenu
:
windowsMenu
]
;
[
windowsMenu
release
]
;
}
}
return
self
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
nil
)
;
}
-
(
void
)
dealloc
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSAppleEventManager
*
aeMgr
=
[
NSAppleEventManager
sharedAppleEventManager
]
;
[
aeMgr
removeEventHandlerForEventClass
:
kInternetEventClass
andEventID
:
kAEGetURL
]
;
[
aeMgr
removeEventHandlerForEventClass
:
'
WWW
!
'
andEventID
:
'
OURL
'
]
;
[
aeMgr
removeEventHandlerForEventClass
:
kCoreEventClass
andEventID
:
kAEOpenDocuments
]
;
[
super
dealloc
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
BOOL
)
applicationShouldHandleReopen
:
(
NSApplication
*
)
theApp
hasVisibleWindows
:
(
BOOL
)
flag
{
nsCOMPtr
<
nsINativeAppSupport
>
nas
=
NS_GetNativeAppSupport
(
)
;
NS_ENSURE_TRUE
(
nas
NO
)
;
nsresult
rv
=
nas
-
>
ReOpen
(
)
;
NS_ENSURE_SUCCESS
(
rv
NO
)
;
return
NO
;
}
-
(
BOOL
)
application
:
(
NSApplication
*
)
theApplication
openFile
:
(
NSString
*
)
filename
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
NSURL
*
url
=
[
NSURL
fileURLWithPath
:
filename
]
;
if
(
!
url
)
return
NO
;
NSString
*
urlString
=
[
url
absoluteString
]
;
if
(
!
urlString
)
return
NO
;
if
(
CommandLineServiceMac
:
:
AddURLToCurrentCommandLine
(
[
urlString
UTF8String
]
)
)
return
YES
;
nsCOMPtr
<
nsILocalFileMac
>
inFile
;
nsresult
rv
=
NS_NewLocalFileWithCFURL
(
(
CFURLRef
)
url
true
getter_AddRefs
(
inFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
NO
;
nsCOMPtr
<
nsICommandLineRunner
>
cmdLine
(
new
nsCommandLine
(
)
)
;
nsCString
filePath
;
rv
=
inFile
-
>
GetNativePath
(
filePath
)
;
if
(
NS_FAILED
(
rv
)
)
return
NO
;
nsCOMPtr
<
nsIFile
>
workingDir
;
rv
=
NS_GetSpecialDirectory
(
NS_OS_CURRENT_WORKING_DIR
getter_AddRefs
(
workingDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
workingDir
=
nullptr
;
}
const
char
*
argv
[
3
]
=
{
nullptr
"
-
file
"
filePath
.
get
(
)
}
;
rv
=
cmdLine
-
>
Init
(
3
argv
workingDir
nsICommandLine
:
:
STATE_REMOTE_EXPLICIT
)
;
if
(
NS_FAILED
(
rv
)
)
return
NO
;
if
(
NS_SUCCEEDED
(
cmdLine
-
>
Run
(
)
)
)
return
YES
;
return
NO
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
NO
)
;
}
-
(
BOOL
)
application
:
(
NSApplication
*
)
theApplication
printFile
:
(
NSString
*
)
filename
{
return
NO
;
}
-
(
NSMenu
*
)
applicationDockMenu
:
(
NSApplication
*
)
sender
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
NSMenu
*
menu
=
[
[
[
NSMenu
alloc
]
initWithTitle
:
"
"
]
autorelease
]
;
[
menu
setAutoenablesItems
:
NO
]
;
nsresult
rv
;
nsCOMPtr
<
nsIMacDockSupport
>
dockSupport
=
do_GetService
(
"
mozilla
.
org
/
widget
/
macdocksupport
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
dockSupport
)
return
menu
;
nsCOMPtr
<
nsIStandaloneNativeMenu
>
dockMenu
;
rv
=
dockSupport
-
>
GetDockMenu
(
getter_AddRefs
(
dockMenu
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
dockMenu
)
return
menu
;
bool
shouldShowItems
;
rv
=
dockMenu
-
>
MenuWillOpen
(
&
shouldShowItems
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
shouldShowItems
)
return
menu
;
NSMenu
*
nativeDockMenu
;
rv
=
dockMenu
-
>
GetNativeMenu
(
reinterpret_cast
<
void
*
*
>
(
&
nativeDockMenu
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
nativeDockMenu
)
return
menu
;
int
numDockMenuItems
=
[
nativeDockMenu
numberOfItems
]
;
if
(
numDockMenuItems
>
0
)
{
if
(
[
menu
numberOfItems
]
>
0
)
[
menu
addItem
:
[
NSMenuItem
separatorItem
]
]
;
for
(
int
i
=
0
;
i
<
numDockMenuItems
;
i
+
+
)
{
NSMenuItem
*
itemCopy
=
[
[
nativeDockMenu
itemAtIndex
:
i
]
copy
]
;
[
menu
addItem
:
itemCopy
]
;
[
itemCopy
release
]
;
}
}
return
menu
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
void
)
applicationWillFinishLaunching
:
(
NSNotification
*
)
notification
{
[
[
NSUserDefaults
standardUserDefaults
]
setBool
:
NO
forKey
:
"
NSFullScreenMenuItemEverywhere
"
]
;
}
-
(
NSApplicationTerminateReply
)
applicationShouldTerminate
:
(
NSApplication
*
)
sender
{
nsCOMPtr
<
nsIObserverService
>
obsServ
=
do_GetService
(
"
mozilla
.
org
/
observer
-
service
;
1
"
)
;
if
(
!
obsServ
)
return
NSTerminateNow
;
nsCOMPtr
<
nsISupportsPRBool
>
cancelQuit
=
do_CreateInstance
(
NS_SUPPORTS_PRBOOL_CONTRACTID
)
;
if
(
!
cancelQuit
)
return
NSTerminateNow
;
cancelQuit
-
>
SetData
(
false
)
;
obsServ
-
>
NotifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
nullptr
)
;
bool
abortQuit
;
cancelQuit
-
>
GetData
(
&
abortQuit
)
;
if
(
abortQuit
)
return
NSTerminateCancel
;
nsCOMPtr
<
nsIAppStartup
>
appService
=
do_GetService
(
"
mozilla
.
org
/
toolkit
/
app
-
startup
;
1
"
)
;
if
(
appService
)
{
bool
userAllowedQuit
=
true
;
appService
-
>
Quit
(
nsIAppStartup
:
:
eForceQuit
0
&
userAllowedQuit
)
;
if
(
!
userAllowedQuit
)
{
return
NSTerminateCancel
;
}
}
return
NSTerminateNow
;
}
-
(
void
)
handleAppleEvent
:
(
NSAppleEventDescriptor
*
)
event
withReplyEvent
:
(
NSAppleEventDescriptor
*
)
replyEvent
{
if
(
!
event
)
return
;
AutoAutoreleasePool
pool
;
bool
isGetURLEvent
=
(
[
event
eventClass
]
=
=
kInternetEventClass
&
&
[
event
eventID
]
=
=
kAEGetURL
)
;
if
(
isGetURLEvent
)
sProcessedGetURLEvent
=
true
;
if
(
isGetURLEvent
|
|
(
[
event
eventClass
]
=
=
'
WWW
!
'
&
&
[
event
eventID
]
=
=
'
OURL
'
)
)
{
NSString
*
urlString
=
[
[
event
paramDescriptorForKeyword
:
keyDirectObject
]
stringValue
]
;
NSURL
*
url
=
[
NSURL
URLWithString
:
urlString
]
;
[
self
openURL
:
url
]
;
}
else
if
(
[
event
eventClass
]
=
=
kCoreEventClass
&
&
[
event
eventID
]
=
=
kAEOpenDocuments
)
{
NSAppleEventDescriptor
*
fileListDescriptor
=
[
event
paramDescriptorForKeyword
:
keyDirectObject
]
;
if
(
!
fileListDescriptor
)
return
;
NSInteger
numberOfFiles
=
[
fileListDescriptor
numberOfItems
]
;
for
(
NSInteger
i
=
1
;
i
<
=
numberOfFiles
;
i
+
+
)
{
NSString
*
urlString
=
[
[
fileListDescriptor
descriptorAtIndex
:
i
]
stringValue
]
;
if
(
!
urlString
)
continue
;
NSURL
*
url
=
[
NSURL
URLWithString
:
urlString
]
;
if
(
!
url
)
continue
;
[
self
application
:
NSApp
openFile
:
[
url
path
]
]
;
}
}
}
-
(
BOOL
)
application
:
(
NSApplication
*
)
application
willContinueUserActivityWithType
:
(
NSString
*
)
userActivityType
{
return
[
userActivityType
isEqualToString
:
NSUserActivityTypeBrowsingWeb
]
;
}
-
(
BOOL
)
application
:
(
NSApplication
*
)
application
continueUserActivity
:
(
NSUserActivity
*
)
userActivity
#
if
defined
(
MAC_OS_X_VERSION_10_14
)
&
&
MAC_OS_X_VERSION_MAX_ALLOWED
>
=
MAC_OS_X_VERSION_10_14
restorationHandler
:
(
void
(
^
)
(
NSArray
<
id
<
NSUserActivityRestoring
>
>
*
)
)
restorationHandler
{
#
else
restorationHandler
:
(
void
(
^
)
(
NSArray
*
)
)
restorationHandler
{
#
endif
if
(
!
[
userActivity
.
activityType
isEqualToString
:
NSUserActivityTypeBrowsingWeb
]
)
{
return
NO
;
}
return
[
self
openURL
:
userActivity
.
webpageURL
]
;
}
-
(
void
)
application
:
(
NSApplication
*
)
application
didFailToContinueUserActivityWithType
:
(
NSString
*
)
userActivityType
error
:
(
NSError
*
)
error
{
NSLog
(
"
Failed
to
continue
user
activity
%
:
%
"
userActivityType
error
)
;
}
-
(
BOOL
)
openURL
:
(
NSURL
*
)
url
{
if
(
!
url
|
|
!
url
.
scheme
|
|
[
url
.
scheme
caseInsensitiveCompare
:
"
chrome
"
]
=
=
NSOrderedSame
)
{
return
NO
;
}
const
char
*
const
urlString
=
[
[
url
absoluteString
]
UTF8String
]
;
if
(
CommandLineServiceMac
:
:
AddURLToCurrentCommandLine
(
urlString
)
)
{
return
NO
;
}
nsCOMPtr
<
nsICommandLineRunner
>
cmdLine
(
new
nsCommandLine
(
)
)
;
nsCOMPtr
<
nsIFile
>
workingDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_OS_CURRENT_WORKING_DIR
getter_AddRefs
(
workingDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
workingDir
=
nullptr
;
}
const
char
*
argv
[
3
]
=
{
nullptr
"
-
url
"
urlString
}
;
rv
=
cmdLine
-
>
Init
(
3
argv
workingDir
nsICommandLine
:
:
STATE_REMOTE_EXPLICIT
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NO
;
}
rv
=
cmdLine
-
>
Run
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NO
;
}
return
YES
;
}
end
