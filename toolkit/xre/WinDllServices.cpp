#
include
"
mozilla
/
WinDllServices
.
h
"
#
include
<
windows
.
h
>
#
include
<
psapi
.
h
>
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsString
.
h
"
#
include
"
WinUtils
.
h
"
namespace
mozilla
{
static
Vector
<
uintptr_t
0
InfallibleAllocPolicy
>
GetProcessModuleBases
(
)
{
Vector
<
uintptr_t
0
InfallibleAllocPolicy
>
ret
;
static
const
int
kProcessModulesInitialCapacity
=
100
;
Unused
<
<
ret
.
resize
(
kProcessModulesInitialCapacity
)
;
DWORD
cbNeeded
=
0
;
while
(
true
)
{
if
(
!
EnumProcessModulesEx
(
GetCurrentProcess
(
)
(
HMODULE
*
)
ret
.
begin
(
)
ret
.
length
(
)
*
sizeof
(
uintptr_t
)
&
cbNeeded
LIST_MODULES_ALL
)
)
{
return
Vector
<
uintptr_t
0
InfallibleAllocPolicy
>
(
)
;
}
size_t
elementsNeeded
=
cbNeeded
/
sizeof
(
HMODULE
)
;
if
(
elementsNeeded
<
=
ret
.
length
(
)
)
{
Unused
<
<
ret
.
resize
(
elementsNeeded
)
;
return
ret
;
}
Unused
<
<
ret
.
resize
(
elementsNeeded
)
;
}
}
class
UntrustedModulesManager
{
Mutex
mMutex
;
bool
mHasProcessedStartupModules
=
false
;
ModuleEvaluator
mEvaluator
;
int
mErrorModules
=
0
;
Maybe
<
double
>
mXULLoadDurationMS
;
HashSet
<
uintptr_t
DefaultHasher
<
uintptr_t
>
InfallibleAllocPolicy
>
mTrustedModuleHistory
;
Vector
<
ModuleLoadEvent
0
InfallibleAllocPolicy
>
mQueuedEvents
;
Vector
<
ModuleLoadEvent
0
InfallibleAllocPolicy
>
mProcessedEvents
;
Telemetry
:
:
CombinedStacks
mProcessedStacks
;
public
:
UntrustedModulesManager
(
)
:
mMutex
(
"
UntrustedModulesManager
:
:
mMutex
"
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
widget
:
:
WinUtils
:
:
GetWhitelistedPaths
(
)
;
}
void
OnNewEvents
(
const
Vector
<
glue
:
:
ModuleLoadEvent
0
InfallibleAllocPolicy
>
&
aEvents
)
{
RefPtr
<
DllServices
>
dllSvcRef
(
DllServices
:
:
Get
(
)
)
;
if
(
!
dllSvcRef
)
{
return
;
}
Unused
<
<
dllSvcRef
;
const
char
*
thisThreadName
=
PR_GetThreadName
(
PR_GetCurrentThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
for
(
auto
&
event
:
aEvents
)
{
Unused
<
<
mQueuedEvents
.
emplaceBack
(
ModuleLoadEvent
(
event
)
)
;
if
(
thisThreadName
&
&
(
event
.
mThreadID
=
=
:
:
GetCurrentThreadId
(
)
)
)
{
mQueuedEvents
.
back
(
)
.
mThreadName
=
thisThreadName
;
}
}
}
void
ProcessQueuedEvents
(
bool
&
aHasProcessedStartupModules
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
DllServices
>
dllSvcRef
(
DllServices
:
:
Get
(
)
)
;
if
(
!
dllSvcRef
)
{
return
;
}
Telemetry
:
:
BatchProcessedStackGenerator
stackProcessor
;
Vector
<
ModuleLoadEvent
0
InfallibleAllocPolicy
>
queuedEvents
;
aHasProcessedStartupModules
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
aHasProcessedStartupModules
=
mHasProcessedStartupModules
;
mQueuedEvents
.
swap
(
queuedEvents
)
;
}
Vector
<
ModuleLoadEvent
0
InfallibleAllocPolicy
>
processedEvents
;
int
errorModules
=
0
;
HashSet
<
uintptr_t
DefaultHasher
<
uintptr_t
>
InfallibleAllocPolicy
>
newTrustedModuleBases
;
for
(
auto
&
e
:
queuedEvents
)
{
ModuleLoadEvent
eventCopy
(
e
ModuleLoadEvent
:
:
CopyOption
:
:
CopyWithoutModules
)
;
for
(
auto
&
m
:
e
.
mModules
)
{
Maybe
<
bool
>
maybeIsTrusted
=
mEvaluator
.
IsModuleTrusted
(
m
eventCopy
dllSvcRef
.
get
(
)
)
;
if
(
(
m
.
mTrustFlags
&
ModuleTrustFlags
:
:
Xul
)
&
&
mXULLoadDurationMS
.
isNothing
(
)
)
{
mXULLoadDurationMS
=
m
.
mLoadDurationMS
;
}
if
(
maybeIsTrusted
.
isNothing
(
)
)
{
errorModules
+
+
;
}
else
if
(
maybeIsTrusted
.
value
(
)
)
{
if
(
!
aHasProcessedStartupModules
)
{
Unused
<
<
newTrustedModuleBases
.
put
(
m
.
mBase
)
;
}
}
else
{
Unused
<
<
eventCopy
.
mModules
.
append
(
std
:
:
move
(
m
)
)
;
}
}
if
(
eventCopy
.
mModules
.
empty
(
)
)
{
continue
;
}
Unused
<
<
processedEvents
.
emplaceBack
(
std
:
:
move
(
eventCopy
)
)
;
}
Vector
<
Telemetry
:
:
ProcessedStack
0
InfallibleAllocPolicy
>
processedStacks
;
for
(
auto
&
&
eventCopy
:
processedEvents
)
{
std
:
:
vector
<
uintptr_t
>
stdCopy
;
for
(
auto
&
&
f
:
eventCopy
.
mStack
)
{
stdCopy
.
emplace_back
(
std
:
:
move
(
f
)
)
;
}
Unused
<
<
processedStacks
.
emplaceBack
(
stackProcessor
.
GetStackAndModules
(
stdCopy
)
)
;
}
{
MutexAutoLock
lock
(
mMutex
)
;
for
(
auto
it
=
newTrustedModuleBases
.
iter
(
)
;
!
it
.
done
(
)
;
it
.
next
(
)
)
{
Unused
<
<
mTrustedModuleHistory
.
put
(
it
.
get
(
)
)
;
}
mErrorModules
+
=
errorModules
;
for
(
size_t
i
=
0
;
i
<
processedEvents
.
length
(
)
;
+
+
i
)
{
auto
&
&
processedEvent
=
processedEvents
[
i
]
;
size_t
newIndex
=
mProcessedStacks
.
AddStack
(
processedStacks
[
i
]
)
;
if
(
(
newIndex
+
1
)
>
mProcessedEvents
.
length
(
)
)
{
Unused
<
<
mProcessedEvents
.
append
(
std
:
:
move
(
processedEvent
)
)
;
}
else
{
mProcessedEvents
[
newIndex
]
=
std
:
:
move
(
processedEvent
)
;
}
}
}
}
bool
ProcessStartupModules
(
bool
aHasProcessedStartupModules
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
DllServices
>
dllSvcRef
(
DllServices
:
:
Get
(
)
)
;
if
(
!
dllSvcRef
)
{
return
false
;
}
Unused
<
<
dllSvcRef
;
if
(
aHasProcessedStartupModules
)
{
return
false
;
}
Vector
<
uintptr_t
0
InfallibleAllocPolicy
>
allModuleBases
=
GetProcessModuleBases
(
)
;
Vector
<
ModuleLoadEvent
0
InfallibleAllocPolicy
>
startupEvents
;
{
MutexAutoLock
lock
(
mMutex
)
;
mHasProcessedStartupModules
=
true
;
for
(
auto
&
base
:
allModuleBases
)
{
if
(
mTrustedModuleHistory
.
has
(
base
)
)
{
continue
;
}
bool
wasFound
=
false
;
for
(
auto
&
e
:
mProcessedEvents
)
{
for
(
auto
&
m
:
e
.
mModules
)
{
if
(
m
.
mBase
=
=
base
)
{
wasFound
=
true
;
}
}
}
if
(
wasFound
)
{
continue
;
}
ModuleLoadEvent
:
:
ModuleInfo
mi
;
mi
.
mBase
=
base
;
mi
.
mLoadDurationMS
=
Nothing
(
)
;
ModuleLoadEvent
e
;
e
.
mIsStartup
=
true
;
e
.
mProcessUptimeMS
=
0
;
Unused
<
<
e
.
mModules
.
emplaceBack
(
std
:
:
move
(
mi
)
)
;
Unused
<
<
startupEvents
.
emplaceBack
(
std
:
:
move
(
e
)
)
;
}
mTrustedModuleHistory
.
clearAndCompact
(
)
;
}
if
(
startupEvents
.
empty
(
)
)
{
return
false
;
}
for
(
auto
&
e
:
startupEvents
)
{
MOZ_ASSERT
(
e
.
mModules
.
length
(
)
=
=
1
)
;
ModuleLoadEvent
:
:
ModuleInfo
&
mi
(
e
.
mModules
[
0
]
)
;
widget
:
:
WinUtils
:
:
GetModuleFullPath
(
(
HMODULE
)
mi
.
mBase
mi
.
mLdrName
)
;
Unused
<
<
NS_NewLocalFile
(
mi
.
mLdrName
false
getter_AddRefs
(
mi
.
mFile
)
)
;
}
MutexAutoLock
lock
(
mMutex
)
;
for
(
auto
&
&
e
:
startupEvents
)
{
Unused
<
<
mQueuedEvents
.
emplaceBack
(
std
:
:
move
(
e
)
)
;
}
return
true
;
}
bool
GetTelemetryData
(
UntrustedModuleLoadTelemetryData
&
aOut
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
DllServices
>
dllSvcRef
(
DllServices
:
:
Get
(
)
)
;
if
(
!
dllSvcRef
)
{
return
false
;
}
Unused
<
<
dllSvcRef
;
bool
hasProcessedStartupModules
=
false
;
ProcessQueuedEvents
(
hasProcessedStartupModules
)
;
if
(
ProcessStartupModules
(
hasProcessedStartupModules
)
)
{
ProcessQueuedEvents
(
hasProcessedStartupModules
)
;
}
aOut
.
mErrorModules
=
mErrorModules
;
aOut
.
mXULLoadDurationMS
=
mXULLoadDurationMS
;
MutexAutoLock
lock
(
mMutex
)
;
aOut
.
mStacks
=
mProcessedStacks
;
for
(
auto
&
e
:
mProcessedEvents
)
{
Unused
<
<
aOut
.
mEvents
.
append
(
e
)
;
}
return
true
;
}
}
;
const
char
*
DllServices
:
:
kTopicDllLoadedMainThread
=
"
dll
-
loaded
-
main
-
thread
"
;
const
char
*
DllServices
:
:
kTopicDllLoadedNonMainThread
=
"
dll
-
loaded
-
non
-
main
-
thread
"
;
static
Atomic
<
bool
>
sDllServicesHasBeenSet
;
static
StaticRefPtr
<
DllServices
>
sInstance
;
DllServices
*
DllServices
:
:
Get
(
)
{
if
(
sDllServicesHasBeenSet
)
{
return
sInstance
;
}
sInstance
=
new
DllServices
(
)
;
sDllServicesHasBeenSet
=
true
;
sInstance
-
>
EnableFull
(
)
;
ClearOnShutdown
(
&
sInstance
)
;
return
sInstance
;
}
DllServices
:
:
DllServices
(
)
:
mUntrustedModulesManager
(
new
UntrustedModulesManager
(
)
)
{
}
bool
DllServices
:
:
GetUntrustedModuleTelemetryData
(
UntrustedModuleLoadTelemetryData
&
aOut
)
{
return
mUntrustedModulesManager
-
>
GetTelemetryData
(
aOut
)
;
}
void
DllServices
:
:
NotifyDllLoad
(
const
bool
aIsMainThread
const
nsString
&
aDllName
)
{
const
char
*
topic
;
if
(
aIsMainThread
)
{
topic
=
kTopicDllLoadedMainThread
;
}
else
{
topic
=
kTopicDllLoadedNonMainThread
;
}
nsCOMPtr
<
nsIObserverService
>
obsServ
(
mozilla
:
:
services
:
:
GetObserverService
(
)
)
;
obsServ
-
>
NotifyObservers
(
nullptr
topic
aDllName
.
get
(
)
)
;
}
void
DllServices
:
:
NotifyUntrustedModuleLoads
(
const
Vector
<
glue
:
:
ModuleLoadEvent
0
InfallibleAllocPolicy
>
&
aEvents
)
{
mUntrustedModulesManager
-
>
OnNewEvents
(
aEvents
)
;
}
}
