#
include
"
MultiInstanceLock
.
h
"
#
include
"
commonupdatedir
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsPromiseFlatString
.
h
"
#
include
"
updatedefines
.
h
"
#
ifndef
XP_WIN
#
include
<
fcntl
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
types
.
h
>
#
endif
namespace
mozilla
{
static
bool
GetLockFileName
(
const
char
*
nameToken
const
char16_t
*
installPath
nsCString
&
filePath
)
{
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
pathHash
;
if
(
!
GetInstallHash
(
installPath
MOZ_APP_VENDOR
pathHash
)
)
{
return
false
;
}
#
ifdef
XP_WIN
PWSTR
programDataPath
;
HRESULT
hr
=
SHGetKnownFolderPath
(
FOLDERID_ProgramData
KF_FLAG_CREATE
nullptr
&
programDataPath
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
mozilla
:
:
UniquePtr
<
wchar_t
CoTaskMemFreeDeleter
>
programDataPathUnique
(
programDataPath
)
;
filePath
=
nsPrintfCString
(
"
%
S
\
\
%
s
\
\
%
s
-
%
S
"
programDataPath
MOZ_APP_VENDOR
nameToken
pathHash
.
get
(
)
)
;
#
else
filePath
=
nsPrintfCString
(
"
/
tmp
/
%
s
%
s
-
%
s
"
MOZ_APP_VENDOR
nameToken
pathHash
.
get
(
)
)
;
#
endif
return
true
;
}
MultiInstLockHandle
OpenMultiInstanceLock
(
const
char
*
nameToken
const
char16_t
*
installPath
)
{
nsCString
filePath
;
GetLockFileName
(
nameToken
installPath
filePath
)
;
#
ifdef
XP_WIN
HANDLE
h
=
:
:
CreateFileW
(
PromiseFlatString
(
NS_ConvertUTF8toUTF16
(
filePath
)
)
.
get
(
)
GENERIC_READ
|
GENERIC_WRITE
FILE_SHARE_READ
|
FILE_SHARE_WRITE
|
FILE_SHARE_DELETE
nullptr
OPEN_ALWAYS
0
nullptr
)
;
if
(
h
!
=
INVALID_HANDLE_VALUE
)
{
OVERLAPPED
o
=
{
0
}
;
if
(
!
:
:
LockFileEx
(
h
LOCKFILE_FAIL_IMMEDIATELY
0
1
0
&
o
)
)
{
CloseHandle
(
h
)
;
h
=
INVALID_HANDLE_VALUE
;
}
}
return
h
;
#
else
int
fd
=
:
:
open
(
PromiseFlatCString
(
filePath
)
.
get
(
)
O_CLOEXEC
|
O_CREAT
|
O_NOFOLLOW
S_IRUSR
|
S_IWUSR
|
S_IRGRP
|
S_IWGRP
|
S_IROTH
|
S_IWOTH
)
;
if
(
fd
!
=
-
1
)
{
struct
flock
l
=
{
0
}
;
l
.
l_start
=
0
;
l
.
l_len
=
0
;
l
.
l_type
=
F_RDLCK
;
if
(
:
:
fcntl
(
fd
F_SETLK
&
l
)
)
{
:
:
close
(
fd
)
;
fd
=
-
1
;
}
}
return
fd
;
#
endif
}
void
ReleaseMultiInstanceLock
(
MultiInstLockHandle
lock
)
{
if
(
lock
!
=
MULTI_INSTANCE_LOCK_HANDLE_ERROR
)
{
#
ifdef
XP_WIN
OVERLAPPED
o
=
{
0
}
;
:
:
UnlockFileEx
(
lock
0
1
0
&
o
)
;
:
:
CloseHandle
(
lock
)
;
#
else
bool
otherInstance
=
true
;
if
(
IsOtherInstanceRunning
(
lock
&
otherInstance
)
&
&
!
otherInstance
)
{
UniquePtr
<
NS_tchar
[
]
>
linkPath
=
MakeUnique
<
NS_tchar
[
]
>
(
MAXPATHLEN
+
1
)
;
NS_tsnprintf
(
linkPath
.
get
(
)
MAXPATHLEN
+
1
"
/
proc
/
self
/
fd
/
%
d
"
lock
)
;
UniquePtr
<
NS_tchar
[
]
>
lockFilePath
=
MakeUnique
<
NS_tchar
[
]
>
(
MAXPATHLEN
+
1
)
;
if
(
:
:
readlink
(
linkPath
.
get
(
)
lockFilePath
.
get
(
)
MAXPATHLEN
+
1
)
!
=
-
1
)
{
:
:
unlink
(
lockFilePath
.
get
(
)
)
;
}
}
:
:
close
(
lock
)
;
#
endif
}
}
bool
IsOtherInstanceRunning
(
MultiInstLockHandle
lock
bool
*
aResult
)
{
if
(
lock
=
=
MULTI_INSTANCE_LOCK_HANDLE_ERROR
)
{
return
false
;
}
#
ifdef
XP_WIN
OVERLAPPED
o
=
{
0
}
;
if
(
!
:
:
UnlockFileEx
(
lock
0
1
0
&
o
)
)
{
return
false
;
}
bool
rv
=
false
;
if
(
:
:
LockFileEx
(
lock
LOCKFILE_EXCLUSIVE_LOCK
|
LOCKFILE_FAIL_IMMEDIATELY
0
1
0
&
o
)
)
{
:
:
UnlockFileEx
(
lock
0
1
0
&
o
)
;
*
aResult
=
false
;
rv
=
true
;
}
else
if
(
:
:
GetLastError
(
)
=
=
ERROR_LOCK_VIOLATION
)
{
*
aResult
=
true
;
rv
=
true
;
}
if
(
!
:
:
LockFileEx
(
lock
LOCKFILE_FAIL_IMMEDIATELY
0
1
0
&
o
)
)
{
rv
=
false
;
}
return
rv
;
#
else
struct
flock
l
=
{
0
}
;
l
.
l_start
=
0
;
l
.
l_len
=
0
;
l
.
l_type
=
F_WRLCK
;
if
(
:
:
fcntl
(
lock
F_GETLK
&
l
)
)
{
return
false
;
}
*
aResult
=
l
.
l_type
!
=
F_UNLCK
;
return
true
;
#
endif
}
}
;
