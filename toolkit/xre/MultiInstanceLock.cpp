#
include
"
MultiInstanceLock
.
h
"
#
include
"
commonupdatedir
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsPromiseFlatString
.
h
"
#
include
"
updatedefines
.
h
"
#
ifndef
XP_WIN
#
include
<
fcntl
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
types
.
h
>
#
endif
namespace
mozilla
{
static
bool
GetLockFileName
(
const
char
*
nameToken
const
char16_t
*
installPath
nsCString
&
filePath
)
{
#
ifdef
XP_WIN
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
updateDir
;
HRESULT
hr
=
GetCommonUpdateDirectory
(
reinterpret_cast
<
const
wchar_t
*
>
(
installPath
)
updateDir
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
size_t
len
=
wcslen
(
updateDir
.
get
(
)
)
;
if
(
len
=
=
0
)
{
return
false
;
}
if
(
updateDir
.
get
(
)
[
len
-
1
]
=
=
'
/
'
|
|
updateDir
.
get
(
)
[
len
-
1
]
=
=
'
\
\
'
)
{
updateDir
.
get
(
)
[
len
-
1
]
=
'
\
0
'
;
}
wchar_t
*
hashPtr
=
PathFindFileNameW
(
updateDir
.
get
(
)
)
;
if
(
hashPtr
=
=
updateDir
.
get
(
)
)
{
return
false
;
}
size_t
hashSize
=
wcslen
(
hashPtr
)
+
1
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
hash
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
hashSize
)
;
errno_t
error
=
wcscpy_s
(
hash
.
get
(
)
hashSize
hashPtr
)
;
if
(
error
!
=
0
)
{
return
false
;
}
BOOL
success
=
PathRemoveFileSpecW
(
updateDir
.
get
(
)
)
;
if
(
!
success
)
{
return
false
;
}
success
=
PathRemoveFileSpecW
(
updateDir
.
get
(
)
)
;
if
(
!
success
)
{
return
false
;
}
filePath
=
nsPrintfCString
(
"
%
s
\
\
%
s
-
%
s
"
NS_ConvertUTF16toUTF8
(
updateDir
.
get
(
)
)
.
get
(
)
nameToken
NS_ConvertUTF16toUTF8
(
hash
.
get
(
)
)
.
get
(
)
)
;
#
else
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
pathHash
;
if
(
!
GetInstallHash
(
installPath
pathHash
)
)
{
return
false
;
}
filePath
=
nsPrintfCString
(
"
/
tmp
/
%
s
%
s
-
%
s
"
MOZ_APP_VENDOR
nameToken
pathHash
.
get
(
)
)
;
#
endif
return
true
;
}
MultiInstLockHandle
OpenMultiInstanceLock
(
const
char
*
nameToken
const
char16_t
*
installPath
)
{
nsCString
filePath
;
if
(
!
GetLockFileName
(
nameToken
installPath
filePath
)
)
{
return
MULTI_INSTANCE_LOCK_HANDLE_ERROR
;
}
#
ifdef
XP_WIN
HANDLE
h
=
:
:
CreateFileW
(
PromiseFlatString
(
NS_ConvertUTF8toUTF16
(
filePath
)
)
.
get
(
)
GENERIC_READ
|
GENERIC_WRITE
FILE_SHARE_READ
|
FILE_SHARE_WRITE
|
FILE_SHARE_DELETE
nullptr
OPEN_ALWAYS
0
nullptr
)
;
if
(
h
!
=
INVALID_HANDLE_VALUE
)
{
OVERLAPPED
o
=
{
0
}
;
if
(
!
:
:
LockFileEx
(
h
LOCKFILE_FAIL_IMMEDIATELY
0
1
0
&
o
)
)
{
CloseHandle
(
h
)
;
h
=
INVALID_HANDLE_VALUE
;
}
}
return
h
;
#
else
int
fd
=
:
:
open
(
PromiseFlatCString
(
filePath
)
.
get
(
)
O_CLOEXEC
|
O_CREAT
|
O_NOFOLLOW
S_IRUSR
|
S_IWUSR
|
S_IRGRP
|
S_IWGRP
|
S_IROTH
|
S_IWOTH
)
;
if
(
fd
!
=
-
1
)
{
struct
flock
l
=
{
0
}
;
l
.
l_start
=
0
;
l
.
l_len
=
0
;
l
.
l_type
=
F_RDLCK
;
if
(
:
:
fcntl
(
fd
F_SETLK
&
l
)
)
{
:
:
close
(
fd
)
;
fd
=
-
1
;
}
}
return
fd
;
#
endif
}
void
ReleaseMultiInstanceLock
(
MultiInstLockHandle
lock
)
{
if
(
lock
!
=
MULTI_INSTANCE_LOCK_HANDLE_ERROR
)
{
#
ifdef
XP_WIN
OVERLAPPED
o
=
{
0
}
;
:
:
UnlockFileEx
(
lock
0
1
0
&
o
)
;
:
:
CloseHandle
(
lock
)
;
#
else
bool
otherInstance
=
true
;
if
(
IsOtherInstanceRunning
(
lock
&
otherInstance
)
&
&
!
otherInstance
)
{
UniquePtr
<
NS_tchar
[
]
>
linkPath
=
MakeUnique
<
NS_tchar
[
]
>
(
MAXPATHLEN
+
1
)
;
NS_tsnprintf
(
linkPath
.
get
(
)
MAXPATHLEN
+
1
"
/
proc
/
self
/
fd
/
%
d
"
lock
)
;
UniquePtr
<
NS_tchar
[
]
>
lockFilePath
=
MakeUnique
<
NS_tchar
[
]
>
(
MAXPATHLEN
+
1
)
;
if
(
:
:
readlink
(
linkPath
.
get
(
)
lockFilePath
.
get
(
)
MAXPATHLEN
+
1
)
!
=
-
1
)
{
:
:
unlink
(
lockFilePath
.
get
(
)
)
;
}
}
:
:
close
(
lock
)
;
#
endif
}
}
bool
IsOtherInstanceRunning
(
MultiInstLockHandle
lock
bool
*
aResult
)
{
if
(
lock
=
=
MULTI_INSTANCE_LOCK_HANDLE_ERROR
)
{
return
false
;
}
#
ifdef
XP_WIN
OVERLAPPED
o
=
{
0
}
;
if
(
!
:
:
UnlockFileEx
(
lock
0
1
0
&
o
)
)
{
return
false
;
}
bool
rv
=
false
;
if
(
:
:
LockFileEx
(
lock
LOCKFILE_EXCLUSIVE_LOCK
|
LOCKFILE_FAIL_IMMEDIATELY
0
1
0
&
o
)
)
{
:
:
UnlockFileEx
(
lock
0
1
0
&
o
)
;
*
aResult
=
false
;
rv
=
true
;
}
else
if
(
:
:
GetLastError
(
)
=
=
ERROR_LOCK_VIOLATION
)
{
*
aResult
=
true
;
rv
=
true
;
}
if
(
!
:
:
LockFileEx
(
lock
LOCKFILE_FAIL_IMMEDIATELY
0
1
0
&
o
)
)
{
rv
=
false
;
}
return
rv
;
#
else
struct
flock
l
=
{
0
}
;
l
.
l_start
=
0
;
l
.
l_len
=
0
;
l
.
l_type
=
F_WRLCK
;
if
(
:
:
fcntl
(
lock
F_GETLK
&
l
)
)
{
return
false
;
}
*
aResult
=
l
.
l_type
!
=
F_UNLCK
;
return
true
;
#
endif
}
}
;
