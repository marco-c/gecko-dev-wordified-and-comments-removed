"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SubDialog
"
"
SubDialogManager
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
function
SubDialog
(
{
template
parentElement
id
dialogOptions
:
{
styleSheets
=
[
]
consumeOutsideClicks
=
true
resizeCallback
}
=
{
}
}
)
{
this
.
_id
=
id
;
this
.
_injectedStyleSheets
=
this
.
_injectedStyleSheets
.
concat
(
styleSheets
)
;
this
.
_consumeOutsideClicks
=
consumeOutsideClicks
;
this
.
_resizeCallback
=
resizeCallback
;
this
.
_overlay
=
template
.
cloneNode
(
true
)
;
this
.
_box
=
this
.
_overlay
.
querySelector
(
"
.
dialogBox
"
)
;
this
.
_titleBar
=
this
.
_overlay
.
querySelector
(
"
.
dialogTitleBar
"
)
;
this
.
_titleElement
=
this
.
_overlay
.
querySelector
(
"
.
dialogTitle
"
)
;
this
.
_closeButton
=
this
.
_overlay
.
querySelector
(
"
.
dialogClose
"
)
;
this
.
_frame
=
this
.
_overlay
.
querySelector
(
"
.
dialogFrame
"
)
;
this
.
_overlay
.
classList
.
add
(
dialogOverlay
-
{
id
}
)
;
this
.
_frame
.
setAttribute
(
"
name
"
dialogFrame
-
{
id
}
)
;
this
.
_frameCreated
=
new
Promise
(
resolve
=
>
{
this
.
_frame
.
addEventListener
(
"
load
"
resolve
{
once
:
true
capture
:
true
}
)
;
}
)
;
parentElement
.
appendChild
(
this
.
_overlay
)
;
this
.
_overlay
.
hidden
=
false
;
}
SubDialog
.
prototype
=
{
_closingCallback
:
null
_closingEvent
:
null
_isClosing
:
false
_frame
:
null
_frameCreated
:
null
_overlay
:
null
_box
:
null
_openedURL
:
null
_injectedStyleSheets
:
[
"
chrome
:
/
/
global
/
skin
/
in
-
content
/
common
.
css
"
]
_resizeObserver
:
null
_template
:
null
_id
:
null
_titleElement
:
null
_closeButton
:
null
get
_window
(
)
{
return
this
.
_overlay
?
.
ownerGlobal
;
}
updateTitle
(
aEvent
)
{
if
(
aEvent
.
target
!
=
this
.
_frame
.
contentDocument
)
{
return
;
}
this
.
_titleElement
.
textContent
=
this
.
_frame
.
contentDocument
.
title
;
}
injectXMLStylesheet
(
aStylesheetURL
)
{
const
doc
=
this
.
_frame
.
contentDocument
;
if
(
[
.
.
.
doc
.
styleSheets
]
.
find
(
s
=
>
s
.
href
=
=
=
aStylesheetURL
)
)
{
return
;
}
let
contentStylesheet
=
doc
.
createProcessingInstruction
(
"
xml
-
stylesheet
"
'
href
=
"
'
+
aStylesheetURL
+
'
"
type
=
"
text
/
css
"
'
)
;
doc
.
insertBefore
(
contentStylesheet
doc
.
documentElement
)
;
}
async
open
(
aURL
aFeatures
=
null
aParams
=
null
aClosingCallback
=
null
aClosedCallback
=
null
aOptions
=
{
}
)
{
if
(
aOptions
.
sizeTo
=
=
"
available
"
)
{
this
.
_box
.
setAttribute
(
"
sizeto
"
"
available
"
)
;
}
this
.
_dialogReady
=
new
Promise
(
resolve
=
>
{
this
.
_resolveDialogReady
=
resolve
;
}
)
;
this
.
_frame
.
_dialogReady
=
this
.
_dialogReady
;
await
this
.
_frameCreated
;
if
(
!
this
.
_frame
.
contentWindow
)
{
this
.
_frame
.
getBoundingClientRect
(
)
;
}
if
(
this
.
_openedURL
|
|
this
.
_isClosing
)
{
if
(
!
this
.
_isClosing
)
{
this
.
close
(
)
;
}
let
args
=
Array
.
from
(
arguments
)
;
this
.
_closingPromise
.
then
(
(
)
=
>
{
this
.
open
.
apply
(
this
args
)
;
}
)
;
return
;
}
this
.
_addDialogEventListeners
(
)
;
let
features
=
resizable
dialog
=
no
centerscreen
chrome
=
{
this
.
_window
?
.
isChromeWindow
?
"
yes
"
:
"
no
"
}
;
if
(
aFeatures
)
{
features
=
{
aFeatures
}
{
features
}
;
}
let
dialog
=
this
.
_window
.
openDialog
(
aURL
dialogFrame
-
{
this
.
_id
}
features
aParams
)
;
if
(
aClosingCallback
)
{
this
.
_closingCallback
=
aClosingCallback
.
bind
(
dialog
)
;
}
if
(
aClosedCallback
)
{
this
.
_closedCallback
=
aClosedCallback
.
bind
(
dialog
)
;
}
this
.
_closingEvent
=
null
;
this
.
_isClosing
=
false
;
this
.
_openedURL
=
aURL
;
features
=
features
.
replace
(
/
/
g
"
&
"
)
;
let
featureParams
=
new
URLSearchParams
(
features
.
toLowerCase
(
)
)
;
this
.
_box
.
setAttribute
(
"
resizable
"
featureParams
.
has
(
"
resizable
"
)
&
&
featureParams
.
get
(
"
resizable
"
)
!
=
"
no
"
&
&
featureParams
.
get
(
"
resizable
"
)
!
=
"
0
"
)
;
}
abort
(
)
{
this
.
_closingEvent
=
new
CustomEvent
(
"
dialogclosing
"
{
bubbles
:
true
detail
:
{
dialog
:
this
abort
:
true
}
}
)
;
this
.
_frame
.
contentWindow
.
close
(
)
;
}
close
(
aEvent
=
null
)
{
if
(
this
.
_isClosing
)
{
return
;
}
this
.
_isClosing
=
true
;
this
.
_closingPromise
=
new
Promise
(
resolve
=
>
{
this
.
_resolveClosePromise
=
resolve
;
}
)
;
if
(
this
.
_closingCallback
)
{
try
{
this
.
_closingCallback
.
call
(
null
aEvent
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
this
.
_closingCallback
=
null
;
}
this
.
_removeDialogEventListeners
(
)
;
this
.
_overlay
.
style
.
visibility
=
"
"
;
this
.
_frame
.
removeAttribute
(
"
style
"
)
;
this
.
_box
.
removeAttribute
(
"
width
"
)
;
this
.
_box
.
removeAttribute
(
"
height
"
)
;
this
.
_box
.
style
.
removeProperty
(
"
min
-
height
"
)
;
this
.
_box
.
style
.
removeProperty
(
"
min
-
width
"
)
;
let
onClosed
=
(
)
=
>
{
this
.
_openedURL
=
null
;
this
.
_isClosing
=
false
;
this
.
_resolveClosePromise
(
)
;
if
(
this
.
_closedCallback
)
{
try
{
this
.
_closedCallback
.
call
(
null
aEvent
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
this
.
_closedCallback
=
null
;
}
}
;
if
(
this
.
_frame
.
contentWindow
)
{
this
.
_frame
.
contentWindow
.
addEventListener
(
"
unload
"
onClosed
{
once
:
true
}
)
;
}
else
{
onClosed
(
)
;
}
this
.
_overlay
.
dispatchEvent
(
new
CustomEvent
(
"
dialogclose
"
{
bubbles
:
true
detail
:
{
dialog
:
this
}
}
)
)
;
this
.
_window
.
setTimeout
(
(
)
=
>
{
this
.
_overlay
.
remove
(
)
;
}
0
)
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
click
"
:
if
(
aEvent
.
target
!
=
=
this
.
_overlay
)
{
break
;
}
if
(
this
.
_consumeOutsideClicks
)
{
this
.
_frame
.
contentWindow
.
close
(
)
;
break
;
}
this
.
_frame
.
focus
(
)
;
break
;
case
"
command
"
:
this
.
_frame
.
contentWindow
.
close
(
)
;
break
;
case
"
dialogclosing
"
:
this
.
_onDialogClosing
(
aEvent
)
;
break
;
case
"
DOMTitleChanged
"
:
this
.
updateTitle
(
aEvent
)
;
break
;
case
"
DOMFrameContentLoaded
"
:
this
.
_onContentLoaded
(
aEvent
)
;
break
;
case
"
load
"
:
this
.
_onLoad
(
aEvent
)
;
break
;
case
"
unload
"
:
this
.
_onUnload
(
aEvent
)
;
break
;
case
"
keydown
"
:
this
.
_onKeyDown
(
aEvent
)
;
break
;
case
"
focus
"
:
this
.
_onParentWinFocus
(
aEvent
)
;
break
;
}
}
_onUnload
(
aEvent
)
{
if
(
aEvent
.
target
!
=
=
this
.
_frame
?
.
contentDocument
|
|
aEvent
.
target
.
location
.
href
!
=
=
this
.
_openedURL
)
{
return
;
}
this
.
abort
(
)
;
}
_onContentLoaded
(
aEvent
)
{
if
(
aEvent
.
target
!
=
this
.
_frame
|
|
aEvent
.
target
.
contentWindow
.
location
=
=
"
about
:
blank
"
)
{
return
;
}
for
(
let
styleSheetURL
of
this
.
_injectedStyleSheets
)
{
this
.
injectXMLStylesheet
(
styleSheetURL
)
;
}
for
(
let
dialog
of
this
.
_frame
.
contentDocument
.
querySelectorAll
(
"
dialog
"
)
)
{
dialog
.
setAttribute
(
"
subdialog
"
"
true
"
)
;
}
this
.
_frame
.
contentWindow
.
addEventListener
(
"
dialogclosing
"
this
)
;
let
oldResizeBy
=
this
.
_frame
.
contentWindow
.
resizeBy
;
this
.
_frame
.
contentWindow
.
resizeBy
=
(
resizeByWidth
resizeByHeight
)
=
>
{
let
frameHeight
=
this
.
_frame
.
clientHeight
;
let
boxMinHeight
=
parseFloat
(
this
.
_window
.
getComputedStyle
(
this
.
_box
)
.
minHeight
10
)
;
this
.
_frame
.
style
.
height
=
frameHeight
+
resizeByHeight
+
"
px
"
;
this
.
_box
.
style
.
minHeight
=
boxMinHeight
+
resizeByHeight
+
"
px
"
;
oldResizeBy
.
call
(
this
.
_frame
.
contentWindow
resizeByWidth
resizeByHeight
)
;
}
;
let
oldClose
=
this
.
_frame
.
contentWindow
.
close
;
this
.
_frame
.
contentWindow
.
close
=
(
)
=
>
{
var
closingEvent
=
this
.
_closingEvent
;
if
(
!
closingEvent
)
{
closingEvent
=
new
CustomEvent
(
"
dialogclosing
"
{
bubbles
:
true
detail
:
{
button
:
null
}
}
)
;
this
.
_frame
.
contentWindow
.
dispatchEvent
(
closingEvent
)
;
}
else
if
(
this
.
_closingEvent
.
detail
?
.
abort
)
{
this
.
_frame
.
contentWindow
.
dispatchEvent
(
closingEvent
)
;
}
this
.
close
(
closingEvent
)
;
oldClose
.
call
(
this
.
_frame
.
contentWindow
)
;
}
;
this
.
_overlay
.
style
.
visibility
=
"
visible
"
;
this
.
_overlay
.
style
.
opacity
=
"
0
.
01
"
;
const
a11yDoc
=
this
.
_frame
.
contentDocument
.
body
|
|
this
.
_frame
.
contentDocument
.
documentElement
;
a11yDoc
.
setAttribute
(
"
role
"
"
dialog
"
)
;
}
async
_onLoad
(
aEvent
)
{
let
target
=
aEvent
.
currentTarget
;
if
(
target
.
contentWindow
.
location
=
=
"
about
:
blank
"
)
{
return
;
}
if
(
target
.
contentDocument
.
l10n
)
{
await
target
.
contentDocument
.
l10n
.
ready
;
}
if
(
target
.
contentDocument
.
mozSubdialogReady
)
{
await
target
.
contentDocument
.
mozSubdialogReady
;
}
await
this
.
resizeDialog
(
)
;
this
.
_resolveDialogReady
(
)
;
}
async
resizeDialog
(
)
{
let
docEl
=
this
.
_frame
.
contentDocument
.
documentElement
;
let
boxHorizontalBorder
=
2
*
parseFloat
(
this
.
_window
.
getComputedStyle
(
this
.
_box
)
.
borderLeftWidth
)
;
let
frameHorizontalMargin
=
2
*
parseFloat
(
this
.
_window
.
getComputedStyle
(
this
.
_frame
)
.
marginLeft
)
;
let
{
scrollWidth
}
=
docEl
.
ownerDocument
.
body
|
|
docEl
;
let
frameMinWidth
=
docEl
.
style
.
width
|
|
scrollWidth
+
"
px
"
;
let
frameWidth
=
docEl
.
getAttribute
(
"
width
"
)
?
docEl
.
getAttribute
(
"
width
"
)
+
"
px
"
:
frameMinWidth
;
if
(
this
.
_box
.
getAttribute
(
"
sizeto
"
)
!
=
"
available
"
)
{
this
.
_frame
.
style
.
width
=
frameWidth
;
}
let
boxMinWidth
=
calc
(
{
boxHorizontalBorder
+
frameHorizontalMargin
}
px
+
{
frameMinWidth
}
)
;
if
(
this
.
_window
.
isChromeWindow
)
{
boxMinWidth
=
min
(
80vw
{
boxMinWidth
}
)
;
}
this
.
_box
.
style
.
minWidth
=
boxMinWidth
;
this
.
resizeVertically
(
)
;
this
.
_overlay
.
dispatchEvent
(
new
CustomEvent
(
"
dialogopen
"
{
bubbles
:
true
detail
:
{
dialog
:
this
}
}
)
)
;
this
.
_overlay
.
style
.
visibility
=
"
visible
"
;
this
.
_overlay
.
style
.
opacity
=
"
"
;
if
(
this
.
_box
.
getAttribute
(
"
resizable
"
)
=
=
"
true
"
)
{
this
.
_onResize
=
this
.
_onResize
.
bind
(
this
)
;
this
.
_resizeObserver
=
new
this
.
_window
.
MutationObserver
(
this
.
_onResize
)
;
this
.
_resizeObserver
.
observe
(
this
.
_box
{
attributes
:
true
}
)
;
}
this
.
_trapFocus
(
)
;
this
.
_resizeCallback
?
.
(
{
title
:
this
.
_titleElement
frame
:
this
.
_frame
}
)
;
}
resizeVertically
(
)
{
let
docEl
=
this
.
_frame
.
contentDocument
.
documentElement
;
let
titleBarHeight
=
0
;
if
(
this
.
_titleBar
)
{
titleBarHeight
=
this
.
_titleBar
.
clientHeight
+
parseFloat
(
this
.
_window
.
getComputedStyle
(
this
.
_titleBar
)
.
borderBottomWidth
)
;
}
let
boxVerticalBorder
=
2
*
parseFloat
(
this
.
_window
.
getComputedStyle
(
this
.
_box
)
.
borderTopWidth
)
;
let
frameVerticalMargin
=
2
*
parseFloat
(
this
.
_window
.
getComputedStyle
(
this
.
_frame
)
.
marginTop
)
;
let
boxRect
=
this
.
_box
.
getBoundingClientRect
(
)
;
let
frameRect
=
this
.
_frame
.
getBoundingClientRect
(
)
;
let
frameSizeDifference
=
frameRect
.
top
-
boxRect
.
top
+
(
boxRect
.
bottom
-
frameRect
.
bottom
)
;
if
(
this
.
_box
.
getAttribute
(
"
sizeto
"
)
=
=
"
available
"
)
{
this
.
_box
.
style
.
setProperty
(
"
-
-
box
-
top
-
px
"
{
boxRect
.
top
}
px
)
;
return
;
}
let
{
scrollHeight
}
=
docEl
.
ownerDocument
.
body
|
|
docEl
;
let
frameMinHeight
=
docEl
.
style
.
height
|
|
scrollHeight
+
"
px
"
;
let
frameHeight
=
docEl
.
getAttribute
(
"
height
"
)
?
docEl
.
getAttribute
(
"
height
"
)
+
"
px
"
:
frameMinHeight
;
let
maxHeight
=
this
.
_window
.
innerHeight
-
frameSizeDifference
-
30
;
let
comparisonFrameHeight
;
if
(
frameHeight
.
endsWith
(
"
em
"
)
)
{
let
fontSize
=
parseFloat
(
this
.
_window
.
getComputedStyle
(
this
.
_frame
)
.
fontSize
)
;
comparisonFrameHeight
=
parseFloat
(
frameHeight
10
)
*
fontSize
;
}
else
if
(
frameHeight
.
endsWith
(
"
px
"
)
)
{
comparisonFrameHeight
=
parseFloat
(
frameHeight
10
)
;
}
else
{
Cu
.
reportError
(
"
This
dialog
(
"
+
this
.
_frame
.
contentWindow
.
location
.
href
+
"
)
"
+
"
set
a
height
in
non
-
px
-
non
-
em
units
(
'
"
+
frameHeight
+
"
'
)
"
+
"
which
is
likely
to
lead
to
bad
sizing
in
in
-
content
preferences
.
"
+
"
Please
consider
changing
this
.
"
)
;
comparisonFrameHeight
=
parseFloat
(
frameHeight
)
;
}
if
(
comparisonFrameHeight
>
maxHeight
)
{
frameHeight
=
maxHeight
+
"
px
"
;
frameMinHeight
=
maxHeight
+
"
px
"
;
let
contentPane
=
this
.
_frame
.
contentDocument
.
querySelector
(
"
.
contentPane
"
)
|
|
this
.
_frame
.
contentDocument
.
querySelector
(
"
dialog
"
)
;
if
(
contentPane
)
{
contentPane
.
classList
.
add
(
"
doScroll
"
)
;
}
}
this
.
_frame
.
style
.
height
=
frameHeight
;
this
.
_box
.
style
.
minHeight
=
"
calc
(
"
+
(
boxVerticalBorder
+
titleBarHeight
+
frameVerticalMargin
)
+
"
px
+
"
+
frameMinHeight
+
"
)
"
;
}
_onResize
(
mutations
)
{
let
frame
=
this
.
_frame
;
frame
.
style
.
removeProperty
(
"
width
"
)
;
frame
.
style
.
removeProperty
(
"
height
"
)
;
let
docEl
=
frame
.
contentDocument
.
documentElement
;
let
persistedAttributes
=
docEl
.
getAttribute
(
"
persist
"
)
;
if
(
!
persistedAttributes
|
|
(
!
persistedAttributes
.
includes
(
"
width
"
)
&
&
!
persistedAttributes
.
includes
(
"
height
"
)
)
)
{
return
;
}
for
(
let
mutation
of
mutations
)
{
if
(
mutation
.
attributeName
=
=
"
width
"
)
{
docEl
.
setAttribute
(
"
width
"
docEl
.
scrollWidth
)
;
}
else
if
(
mutation
.
attributeName
=
=
"
height
"
)
{
docEl
.
setAttribute
(
"
height
"
docEl
.
scrollHeight
)
;
}
}
}
_onDialogClosing
(
aEvent
)
{
this
.
_frame
.
contentWindow
.
removeEventListener
(
"
dialogclosing
"
this
)
;
this
.
_closingEvent
=
aEvent
;
}
_onKeyDown
(
aEvent
)
{
if
(
aEvent
.
keyCode
=
=
aEvent
.
DOM_VK_ESCAPE
&
&
!
aEvent
.
defaultPrevented
)
{
if
(
(
this
.
_window
.
isChromeWindow
&
&
aEvent
.
currentTarget
=
=
this
.
_box
)
|
|
(
!
this
.
_window
.
isChromeWindow
&
&
aEvent
.
currentTarget
=
=
this
.
_window
)
)
{
this
.
_frame
.
contentWindow
.
close
(
)
;
return
;
}
}
if
(
this
.
_window
.
isChromeWindow
|
|
aEvent
.
keyCode
!
=
aEvent
.
DOM_VK_TAB
|
|
aEvent
.
ctrlKey
|
|
aEvent
.
altKey
|
|
aEvent
.
metaKey
)
{
return
;
}
let
fm
=
Services
.
focus
;
let
isLastFocusableElement
=
el
=
>
{
let
rv
=
el
=
=
fm
.
moveFocus
(
this
.
_frame
.
contentWindow
null
fm
.
MOVEFOCUS_LAST
0
)
;
fm
.
setFocus
(
el
0
)
;
return
rv
;
}
;
let
forward
=
!
aEvent
.
shiftKey
;
if
(
(
aEvent
.
target
=
=
this
.
_closeButton
&
&
!
forward
)
|
|
(
isLastFocusableElement
(
aEvent
.
originalTarget
)
&
&
forward
)
)
{
aEvent
.
preventDefault
(
)
;
aEvent
.
stopImmediatePropagation
(
)
;
let
parentWin
=
this
.
_window
.
docShell
.
chromeEventHandler
.
ownerGlobal
;
if
(
forward
)
{
fm
.
moveFocus
(
parentWin
null
fm
.
MOVEFOCUS_FIRST
fm
.
FLAG_BYKEY
)
;
}
else
{
fm
.
moveFocus
(
this
.
_window
null
fm
.
MOVEFOCUS_ROOT
fm
.
FLAG_BYKEY
)
;
fm
.
moveFocus
(
parentWin
null
fm
.
MOVEFOCUS_BACKWARD
fm
.
FLAG_BYKEY
)
;
}
}
}
_onParentWinFocus
(
aEvent
)
{
if
(
this
.
_closeButton
&
&
aEvent
.
target
!
=
this
.
_closeButton
&
&
aEvent
.
target
!
=
this
.
_window
)
{
this
.
_closeButton
.
focus
(
)
;
}
}
_addDialogEventListeners
(
includeLoad
=
true
)
{
if
(
this
.
_window
.
isChromeWindow
)
{
if
(
this
.
_titleBar
)
{
this
.
_frame
.
addEventListener
(
"
DOMTitleChanged
"
this
true
)
;
}
if
(
includeLoad
)
{
this
.
_window
.
addEventListener
(
"
unload
"
this
true
)
;
}
}
else
{
let
chromeBrowser
=
this
.
_window
.
docShell
.
chromeEventHandler
;
if
(
includeLoad
)
{
chromeBrowser
.
addEventListener
(
"
unload
"
this
true
)
;
}
if
(
this
.
_titleBar
)
{
chromeBrowser
.
addEventListener
(
"
DOMTitleChanged
"
this
true
)
;
}
}
this
.
_closeButton
?
.
addEventListener
(
"
command
"
this
)
;
if
(
includeLoad
)
{
this
.
_window
.
addEventListener
(
"
DOMFrameContentLoaded
"
this
true
)
;
this
.
_frame
.
addEventListener
(
"
load
"
this
true
)
;
}
if
(
!
this
.
_window
.
isChromeWindow
)
{
this
.
_window
.
addEventListener
(
"
keydown
"
this
true
)
;
}
this
.
_overlay
.
addEventListener
(
"
click
"
this
true
)
;
}
_removeDialogEventListeners
(
includeLoad
=
true
)
{
if
(
this
.
_window
.
isChromeWindow
)
{
this
.
_frame
.
removeEventListener
(
"
DOMTitleChanged
"
this
true
)
;
if
(
includeLoad
)
{
this
.
_window
.
removeEventListener
(
"
unload
"
this
true
)
;
}
}
else
{
let
chromeBrowser
=
this
.
_window
.
docShell
.
chromeEventHandler
;
if
(
includeLoad
)
{
chromeBrowser
.
removeEventListener
(
"
unload
"
this
true
)
;
}
chromeBrowser
.
removeEventListener
(
"
DOMTitleChanged
"
this
true
)
;
}
this
.
_closeButton
?
.
removeEventListener
(
"
command
"
this
)
;
if
(
includeLoad
)
{
this
.
_window
.
removeEventListener
(
"
DOMFrameContentLoaded
"
this
true
)
;
this
.
_frame
.
removeEventListener
(
"
load
"
this
true
)
;
this
.
_frame
.
contentWindow
.
removeEventListener
(
"
dialogclosing
"
this
)
;
}
this
.
_window
.
removeEventListener
(
"
keydown
"
this
true
)
;
this
.
_overlay
.
removeEventListener
(
"
click
"
this
true
)
;
if
(
this
.
_resizeObserver
)
{
this
.
_resizeObserver
.
disconnect
(
)
;
this
.
_resizeObserver
=
null
;
}
this
.
_untrapFocus
(
)
;
}
focus
(
)
{
let
fm
=
Services
.
focus
;
let
focusedElement
=
fm
.
moveFocus
(
this
.
_frame
.
contentWindow
null
fm
.
MOVEFOCUS_FIRST
0
)
;
if
(
!
focusedElement
)
{
this
.
_frame
.
contentWindow
.
focus
(
)
;
}
}
_trapFocus
(
)
{
this
.
focus
(
)
;
this
.
_box
.
addEventListener
(
"
keydown
"
this
true
)
;
this
.
_closeButton
?
.
addEventListener
(
"
keydown
"
this
)
;
if
(
!
this
.
_window
.
isChromeWindow
)
{
this
.
_window
.
addEventListener
(
"
focus
"
this
true
)
;
}
}
_untrapFocus
(
)
{
this
.
_box
.
removeEventListener
(
"
keydown
"
this
true
)
;
this
.
_closeButton
?
.
removeEventListener
(
"
keydown
"
this
)
;
this
.
_window
.
removeEventListener
(
"
focus
"
this
true
)
;
}
}
;
class
SubDialogManager
{
constructor
(
{
dialogStack
dialogTemplate
orderType
=
SubDialogManager
.
ORDER_STACK
allowDuplicateDialogs
=
false
dialogOptions
}
)
{
this
.
_dialogs
=
[
]
;
this
.
_dialogStack
=
dialogStack
;
this
.
_dialogTemplate
=
dialogTemplate
;
this
.
_topLevelPrevActiveElement
=
null
;
this
.
_orderType
=
orderType
;
this
.
_allowDuplicateDialogs
=
allowDuplicateDialogs
;
this
.
_dialogOptions
=
dialogOptions
;
this
.
_preloadDialog
=
new
SubDialog
(
{
template
:
this
.
_dialogTemplate
parentElement
:
this
.
_dialogStack
id
:
SubDialogManager
.
_nextDialogID
+
+
dialogOptions
:
this
.
_dialogOptions
}
)
;
}
get
_topDialog
(
)
{
if
(
!
this
.
_dialogs
.
length
)
{
return
undefined
;
}
if
(
this
.
_orderType
=
=
=
SubDialogManager
.
ORDER_STACK
)
{
return
this
.
_dialogs
[
this
.
_dialogs
.
length
-
1
]
;
}
return
this
.
_dialogs
[
0
]
;
}
open
(
aURL
aFeatures
=
null
aParams
=
null
aClosingCallback
=
null
aClosedCallback
=
null
aOpenOptions
)
{
if
(
!
this
.
_allowDuplicateDialogs
&
&
this
.
_topDialog
?
.
_openedURL
=
=
aURL
)
{
return
;
}
let
doc
=
this
.
_dialogStack
.
ownerDocument
;
if
(
this
.
_orderType
=
=
=
SubDialogManager
.
ORDER_STACK
&
&
this
.
_dialogs
.
length
)
{
this
.
_topDialog
.
_prevActiveElement
=
doc
.
activeElement
;
}
if
(
!
this
.
_dialogs
.
length
)
{
this
.
_dialogStack
.
hidden
=
false
;
this
.
_topLevelPrevActiveElement
=
doc
.
activeElement
;
this
.
_preloadDialog
.
isTop
=
true
;
}
else
if
(
this
.
_orderType
=
=
=
SubDialogManager
.
ORDER_STACK
)
{
this
.
_preloadDialog
.
isTop
=
true
;
this
.
_dialogs
[
this
.
_dialogs
.
length
-
1
]
.
isTop
=
false
;
}
this
.
_preloadDialog
.
open
(
aURL
aFeatures
aParams
aClosingCallback
aClosedCallback
aOpenOptions
)
;
this
.
_dialogs
.
push
(
this
.
_preloadDialog
)
;
this
.
_preloadDialog
=
new
SubDialog
(
{
template
:
this
.
_dialogTemplate
parentElement
:
this
.
_dialogStack
id
:
SubDialogManager
.
_nextDialogID
+
+
dialogOptions
:
this
.
_dialogOptions
}
)
;
if
(
this
.
_dialogs
.
length
=
=
1
)
{
this
.
_ensureStackEventListeners
(
)
;
}
}
close
(
)
{
this
.
_topDialog
.
close
(
)
;
}
abortAll
(
)
{
this
.
_dialogs
.
slice
(
)
.
forEach
(
dialog
=
>
dialog
.
abort
(
)
)
;
}
get
hasDialogs
(
)
{
if
(
!
this
.
_dialogs
.
length
)
{
return
false
;
}
return
this
.
_dialogs
.
some
(
dialog
=
>
!
dialog
.
_isClosing
)
;
}
focusTopDialog
(
)
{
this
.
_topDialog
?
.
focus
(
)
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
dialogopen
"
:
{
this
.
_onDialogOpen
(
aEvent
.
detail
.
dialog
)
;
break
;
}
case
"
dialogclose
"
:
{
this
.
_onDialogClose
(
aEvent
.
detail
.
dialog
)
;
break
;
}
}
}
_onDialogOpen
(
dialog
)
{
if
(
this
.
_dialogs
.
length
=
=
=
1
)
{
return
;
}
let
lowerDialogs
=
[
]
;
if
(
!
dialog
.
isTop
)
{
lowerDialogs
.
push
(
dialog
)
;
}
if
(
this
.
_orderType
=
=
=
SubDialogManager
.
ORDER_STACK
)
{
let
index
=
this
.
_dialogs
.
indexOf
(
dialog
)
;
if
(
index
>
0
)
{
lowerDialogs
.
push
(
this
.
_dialogs
[
index
-
1
]
)
;
}
}
lowerDialogs
.
forEach
(
d
=
>
{
if
(
d
.
_overlay
.
hasAttribute
(
"
topmost
"
)
)
{
d
.
_overlay
.
removeAttribute
(
"
topmost
"
)
;
d
.
_removeDialogEventListeners
(
false
)
;
}
}
)
;
}
_onDialogClose
(
dialog
)
{
this
.
_dialogs
.
splice
(
this
.
_dialogs
.
indexOf
(
dialog
)
1
)
;
if
(
this
.
_topDialog
)
{
this
.
_topDialog
.
_prevActiveElement
?
.
focus
(
)
;
this
.
_topDialog
.
_overlay
.
setAttribute
(
"
topmost
"
true
)
;
this
.
_topDialog
.
_addDialogEventListeners
(
false
)
;
}
else
{
this
.
_topLevelPrevActiveElement
.
focus
(
)
;
this
.
_dialogStack
.
hidden
=
true
;
this
.
_removeStackEventListeners
(
)
;
}
}
_ensureStackEventListeners
(
)
{
this
.
_dialogStack
.
addEventListener
(
"
dialogopen
"
this
)
;
this
.
_dialogStack
.
addEventListener
(
"
dialogclose
"
this
)
;
}
_removeStackEventListeners
(
)
{
this
.
_dialogStack
.
removeEventListener
(
"
dialogopen
"
this
)
;
this
.
_dialogStack
.
removeEventListener
(
"
dialogclose
"
this
)
;
}
}
SubDialogManager
.
ORDER_STACK
=
0
;
SubDialogManager
.
ORDER_QUEUE
=
1
;
SubDialogManager
.
_nextDialogID
=
0
;
