"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UpdateUtils
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
ctypes
:
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
WindowsRegistry
:
"
resource
:
/
/
gre
/
modules
/
WindowsRegistry
.
jsm
"
WindowsVersionInfo
:
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
WindowsVersionInfo
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
const
PER_INSTALLATION_PREFS_PLATFORMS
=
[
"
win
"
]
;
const
FILE_UPDATE_CONFIG_JSON
=
"
update
-
config
.
json
"
;
const
FILE_UPDATE_LOCALE
=
"
update
.
locale
"
;
const
PREF_APP_DISTRIBUTION
=
"
distribution
.
id
"
;
const
PREF_APP_DISTRIBUTION_VERSION
=
"
distribution
.
version
"
;
var
UpdateUtils
=
{
_locale
:
undefined
getUpdateChannel
(
aIncludePartners
=
true
)
{
let
defaults
=
Services
.
prefs
.
getDefaultBranch
(
null
)
;
let
channel
=
defaults
.
getCharPref
(
"
app
.
update
.
channel
"
AppConstants
.
MOZ_UPDATE_CHANNEL
)
;
if
(
aIncludePartners
)
{
try
{
let
partners
=
Services
.
prefs
.
getChildList
(
"
app
.
partner
.
"
)
.
sort
(
)
;
if
(
partners
.
length
)
{
channel
+
=
"
-
cck
"
;
partners
.
forEach
(
function
(
prefName
)
{
channel
+
=
"
-
"
+
Services
.
prefs
.
getCharPref
(
prefName
)
;
}
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
return
channel
;
}
get
UpdateChannel
(
)
{
return
this
.
getUpdateChannel
(
)
;
}
async
formatUpdateURL
(
url
)
{
const
locale
=
await
this
.
getLocale
(
)
;
return
url
.
replace
(
/
%
(
\
w
+
)
%
/
g
(
match
name
)
=
>
{
switch
(
name
)
{
case
"
PRODUCT
"
:
return
Services
.
appinfo
.
name
;
case
"
VERSION
"
:
return
Services
.
appinfo
.
version
;
case
"
BUILD_ID
"
:
return
Services
.
appinfo
.
appBuildID
;
case
"
BUILD_TARGET
"
:
return
Services
.
appinfo
.
OS
+
"
_
"
+
this
.
ABI
;
case
"
OS_VERSION
"
:
return
this
.
OSVersion
;
case
"
LOCALE
"
:
return
locale
;
case
"
CHANNEL
"
:
return
this
.
UpdateChannel
;
case
"
PLATFORM_VERSION
"
:
return
Services
.
appinfo
.
platformVersion
;
case
"
SYSTEM_CAPABILITIES
"
:
return
getSystemCapabilities
(
)
;
case
"
DISTRIBUTION
"
:
return
getDistributionPrefValue
(
PREF_APP_DISTRIBUTION
)
;
case
"
DISTRIBUTION_VERSION
"
:
return
getDistributionPrefValue
(
PREF_APP_DISTRIBUTION_VERSION
)
;
}
return
match
;
}
)
.
replace
(
/
\
+
/
g
"
%
2B
"
)
;
}
async
getLocale
(
)
{
if
(
this
.
_locale
!
=
=
undefined
)
{
return
this
.
_locale
;
}
for
(
let
res
of
[
"
app
"
"
gre
"
]
)
{
const
url
=
"
resource
:
/
/
"
+
res
+
"
/
"
+
FILE_UPDATE_LOCALE
;
let
data
;
try
{
data
=
await
fetch
(
url
)
;
}
catch
(
e
)
{
continue
;
}
const
locale
=
await
data
.
text
(
)
;
if
(
locale
)
{
return
(
this
.
_locale
=
locale
.
trim
(
)
)
;
}
}
Cu
.
reportError
(
FILE_UPDATE_LOCALE
+
"
file
doesn
'
t
exist
in
either
the
"
+
"
application
or
GRE
directories
"
)
;
return
(
this
.
_locale
=
null
)
;
}
async
getAppUpdateAutoEnabled
(
)
{
return
this
.
readUpdateConfigSetting
(
"
app
.
update
.
auto
"
)
;
}
async
setAppUpdateAutoEnabled
(
enabledValue
)
{
return
this
.
writeUpdateConfigSetting
(
"
app
.
update
.
auto
"
!
!
enabledValue
)
;
}
appUpdateAutoSettingIsLocked
(
)
{
return
this
.
appUpdateSettingIsLocked
(
"
app
.
update
.
auto
"
)
;
}
PER_INSTALLATION_PREFS_SUPPORTED
:
PER_INSTALLATION_PREFS_PLATFORMS
.
includes
(
AppConstants
.
platform
)
PER_INSTALLATION_PREF_TYPE_BOOL
:
"
boolean
"
PER_INSTALLATION_PREF_TYPE_ASCII_STRING
:
"
ascii
"
PER_INSTALLATION_PREF_TYPE_INT
:
"
integer
"
PER_INSTALLATION_PREFS
:
null
initPerInstallPrefs
(
)
{
if
(
!
UpdateUtils
.
PER_INSTALLATION_PREFS_SUPPORTED
)
{
let
initialConfig
=
{
}
;
for
(
const
[
prefName
pref
]
of
Object
.
entries
(
UpdateUtils
.
PER_INSTALLATION_PREFS
)
)
{
const
prefTypeFns
=
TYPE_SPECIFIC_PREF_FNS
[
pref
.
type
]
;
try
{
let
initialValue
=
prefTypeFns
.
getProfilePref
(
prefName
)
;
initialConfig
[
prefName
]
=
initialValue
;
}
catch
(
e
)
{
}
Services
.
prefs
.
addObserver
(
prefName
async
(
subject
topic
data
)
=
>
{
let
config
=
{
.
.
.
gUpdateConfigCache
}
;
config
[
prefName
]
=
await
UpdateUtils
.
readUpdateConfigSetting
(
prefName
)
;
maybeUpdateConfigChanged
(
config
)
;
}
)
;
}
maybeUpdateConfigChanged
(
initialConfig
)
;
}
}
readUpdateConfigSetting
(
prefName
)
{
if
(
!
(
prefName
in
this
.
PER_INSTALLATION_PREFS
)
)
{
return
Promise
.
reject
(
new
Error
(
UpdateUtils
.
readUpdateConfigSetting
:
Unknown
per
-
installation
+
pref
'
{
prefName
}
'
)
)
;
}
const
pref
=
this
.
PER_INSTALLATION_PREFS
[
prefName
]
;
const
prefTypeFns
=
TYPE_SPECIFIC_PREF_FNS
[
pref
.
type
]
;
if
(
Services
.
policies
&
&
"
policyFn
"
in
pref
)
{
let
policyValue
=
pref
.
policyFn
(
)
;
if
(
policyValue
!
=
=
null
)
{
return
Promise
.
resolve
(
policyValue
)
;
}
}
if
(
!
this
.
PER_INSTALLATION_PREFS_SUPPORTED
)
{
let
prefValue
=
prefTypeFns
.
getProfilePref
(
prefName
pref
.
defaultValue
)
;
return
Promise
.
resolve
(
prefValue
)
;
}
let
readPromise
=
updateConfigIOPromise
.
then
(
(
)
=
>
{
}
(
)
=
>
{
}
)
.
then
(
readUpdateConfig
)
.
then
(
maybeUpdateConfigChanged
)
.
then
(
config
=
>
{
return
readEffectiveValue
(
config
prefName
)
;
}
)
;
updateConfigIOPromise
=
readPromise
;
return
readPromise
;
}
writeUpdateConfigSetting
(
prefName
value
options
)
{
if
(
!
(
prefName
in
this
.
PER_INSTALLATION_PREFS
)
)
{
return
Promise
.
reject
(
new
Error
(
UpdateUtils
.
writeUpdateConfigSetting
:
Unknown
per
-
installation
+
pref
'
{
prefName
}
'
)
)
;
}
if
(
this
.
appUpdateSettingIsLocked
(
prefName
)
)
{
return
Promise
.
reject
(
new
Error
(
UpdateUtils
.
writeUpdateConfigSetting
:
Unable
to
change
value
of
+
setting
'
{
prefName
}
'
because
it
is
locked
by
policy
)
)
;
}
if
(
!
options
)
{
options
=
{
}
;
}
const
pref
=
this
.
PER_INSTALLATION_PREFS
[
prefName
]
;
const
prefTypeFns
=
TYPE_SPECIFIC_PREF_FNS
[
pref
.
type
]
;
if
(
!
prefTypeFns
.
isValid
(
value
)
)
{
return
Promise
.
reject
(
new
Error
(
UpdateUtils
.
writeUpdateConfigSetting
:
Attempted
to
change
pref
+
'
{
prefName
}
to
invalid
value
:
{
JSON
.
stringify
(
value
)
}
)
)
;
}
if
(
!
this
.
PER_INSTALLATION_PREFS_SUPPORTED
)
{
if
(
options
.
setDefaultOnly
)
{
prefTypeFns
.
setProfileDefaultPref
(
prefName
value
)
;
}
else
{
prefTypeFns
.
setProfilePref
(
prefName
value
)
;
}
return
Promise
.
resolve
(
value
)
;
}
let
writePromise
=
updateConfigIOPromise
.
then
(
(
)
=
>
{
}
(
)
=
>
{
}
)
.
then
(
readUpdateConfig
)
.
then
(
async
config
=
>
{
setConfigValue
(
config
prefName
value
{
setDefaultOnly
:
!
!
options
.
setDefaultOnly
}
)
;
try
{
await
writeUpdateConfig
(
config
)
;
return
config
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
UpdateUtils
.
writeUpdateConfigSetting
:
App
update
configuration
"
+
"
file
write
failed
.
Exception
:
"
+
e
)
;
throw
e
;
}
}
)
.
then
(
maybeUpdateConfigChanged
)
.
then
(
(
)
=
>
{
return
value
;
}
)
;
updateConfigIOPromise
=
writePromise
;
return
writePromise
;
}
appUpdateSettingIsLocked
(
prefName
)
{
if
(
!
(
prefName
in
UpdateUtils
.
PER_INSTALLATION_PREFS
)
)
{
return
Promise
.
reject
(
new
Error
(
UpdateUtils
.
appUpdateSettingIsLocked
:
Unknown
per
-
installation
pref
'
{
prefName
}
'
)
)
;
}
if
(
!
Services
.
policies
)
{
return
false
;
}
const
pref
=
UpdateUtils
.
PER_INSTALLATION_PREFS
[
prefName
]
;
if
(
!
pref
.
policyFn
)
{
return
false
;
}
const
policyValue
=
pref
.
policyFn
(
)
;
return
policyValue
!
=
=
null
;
}
}
;
const
PER_INSTALLATION_DEFAULTS_BRANCH
=
"
__DEFAULTS__
"
;
UpdateUtils
.
PER_INSTALLATION_PREFS
=
{
"
app
.
update
.
auto
"
:
{
type
:
UpdateUtils
.
PER_INSTALLATION_PREF_TYPE_BOOL
defaultValue
:
true
migrate
:
true
observerTopic
:
"
auto
-
update
-
config
-
change
"
policyFn
:
(
)
=
>
{
if
(
!
Services
.
policies
.
isAllowed
(
"
app
-
auto
-
updates
-
off
"
)
)
{
return
true
;
}
if
(
!
Services
.
policies
.
isAllowed
(
"
app
-
auto
-
updates
-
on
"
)
)
{
return
false
;
}
return
null
;
}
}
"
app
.
update
.
background
.
enabled
"
:
{
type
:
UpdateUtils
.
PER_INSTALLATION_PREF_TYPE_BOOL
defaultValue
:
true
observerTopic
:
"
background
-
update
-
config
-
change
"
policyFn
:
(
)
=
>
{
if
(
!
Services
.
policies
.
isAllowed
(
"
app
-
background
-
update
-
off
"
)
)
{
return
true
;
}
if
(
!
Services
.
policies
.
isAllowed
(
"
app
-
background
-
update
-
on
"
)
)
{
return
false
;
}
return
null
;
}
}
}
;
const
TYPE_SPECIFIC_PREF_FNS
=
{
[
UpdateUtils
.
PER_INSTALLATION_PREF_TYPE_BOOL
]
:
{
getProfilePref
:
Services
.
prefs
.
getBoolPref
setProfilePref
:
Services
.
prefs
.
setBoolPref
setProfileDefaultPref
:
(
pref
value
)
=
>
{
let
defaults
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
defaults
.
setBoolPref
(
pref
value
)
;
}
isValid
:
value
=
>
typeof
value
=
=
"
boolean
"
}
[
UpdateUtils
.
PER_INSTALLATION_PREF_TYPE_ASCII_STRING
]
:
{
getProfilePref
:
Services
.
prefs
.
getCharPref
setProfilePref
:
Services
.
prefs
.
setCharPref
setProfileDefaultPref
:
(
pref
value
)
=
>
{
let
defaults
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
defaults
.
setCharPref
(
pref
value
)
;
}
isValid
:
value
=
>
typeof
value
=
=
"
string
"
}
[
UpdateUtils
.
PER_INSTALLATION_PREF_TYPE_INT
]
:
{
getProfilePref
:
Services
.
prefs
.
getIntPref
setProfilePref
:
Services
.
prefs
.
setIntPref
setProfileDefaultPref
:
(
pref
value
)
=
>
{
let
defaults
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
defaults
.
setIntPref
(
pref
value
)
;
}
isValid
:
value
=
>
Number
.
isInteger
(
value
)
}
}
;
var
updateConfigIOPromise
=
Promise
.
resolve
(
)
;
function
getPrefMigratedPref
(
prefName
)
{
return
prefName
+
"
.
migrated
"
;
}
function
updateConfigNeedsMigration
(
)
{
for
(
const
[
prefName
pref
]
of
Object
.
entries
(
UpdateUtils
.
PER_INSTALLATION_PREFS
)
)
{
if
(
pref
.
migrate
)
{
let
migratedPrefName
=
getPrefMigratedPref
(
prefName
)
;
let
migrated
=
Services
.
prefs
.
getBoolPref
(
migratedPrefName
false
)
;
if
(
!
migrated
)
{
return
true
;
}
}
}
return
false
;
}
function
setUpdateConfigMigrationDone
(
)
{
for
(
const
[
prefName
pref
]
of
Object
.
entries
(
UpdateUtils
.
PER_INSTALLATION_PREFS
)
)
{
if
(
pref
.
migrate
)
{
let
migratedPrefName
=
getPrefMigratedPref
(
prefName
)
;
Services
.
prefs
.
setBoolPref
(
migratedPrefName
true
)
;
}
}
}
function
onMigrationSuccessful
(
)
{
for
(
const
[
prefName
pref
]
of
Object
.
entries
(
UpdateUtils
.
PER_INSTALLATION_PREFS
)
)
{
if
(
pref
.
migrate
)
{
Services
.
prefs
.
clearUserPref
(
prefName
)
;
}
}
}
function
makeMigrationUpdateConfig
(
)
{
let
config
=
makeDefaultUpdateConfig
(
)
;
for
(
const
[
prefName
pref
]
of
Object
.
entries
(
UpdateUtils
.
PER_INSTALLATION_PREFS
)
)
{
if
(
!
pref
.
migrate
)
{
continue
;
}
let
migratedPrefName
=
getPrefMigratedPref
(
prefName
)
;
let
alreadyMigrated
=
Services
.
prefs
.
getBoolPref
(
migratedPrefName
false
)
;
if
(
alreadyMigrated
)
{
continue
;
}
const
prefTypeFns
=
TYPE_SPECIFIC_PREF_FNS
[
pref
.
type
]
;
let
prefHasValue
=
true
;
let
prefValue
;
try
{
prefValue
=
prefTypeFns
.
getProfilePref
(
prefName
)
;
}
catch
(
e
)
{
prefHasValue
=
false
;
}
if
(
prefHasValue
)
{
setConfigValue
(
config
prefName
prefValue
)
;
}
}
return
config
;
}
function
makeDefaultUpdateConfig
(
)
{
let
config
=
{
}
;
for
(
const
[
prefName
pref
]
of
Object
.
entries
(
UpdateUtils
.
PER_INSTALLATION_PREFS
)
)
{
setConfigValue
(
config
prefName
pref
.
defaultValue
{
setDefaultOnly
:
true
}
)
;
}
return
config
;
}
function
setConfigValue
(
config
prefName
prefValue
options
)
{
if
(
!
options
)
{
options
=
{
}
;
}
if
(
options
.
setDefaultOnly
)
{
if
(
!
(
PER_INSTALLATION_DEFAULTS_BRANCH
in
config
)
)
{
config
[
PER_INSTALLATION_DEFAULTS_BRANCH
]
=
{
}
;
}
config
[
PER_INSTALLATION_DEFAULTS_BRANCH
]
[
prefName
]
=
prefValue
;
}
else
if
(
prefValue
!
=
readDefaultValue
(
config
prefName
)
)
{
config
[
prefName
]
=
prefValue
;
}
else
{
delete
config
[
prefName
]
;
}
}
function
readEffectiveValue
(
config
prefName
)
{
if
(
!
(
prefName
in
UpdateUtils
.
PER_INSTALLATION_PREFS
)
)
{
throw
new
Error
(
readEffectiveValue
:
Unknown
per
-
installation
pref
'
{
prefName
}
'
)
;
}
const
pref
=
UpdateUtils
.
PER_INSTALLATION_PREFS
[
prefName
]
;
const
prefTypeFns
=
TYPE_SPECIFIC_PREF_FNS
[
pref
.
type
]
;
if
(
prefName
in
config
)
{
if
(
prefTypeFns
.
isValid
(
config
[
prefName
]
)
)
{
return
config
[
prefName
]
;
}
Cu
.
reportError
(
readEffectiveValue
:
Got
invalid
value
for
update
config
'
s
+
'
{
prefName
}
'
value
:
"
{
config
[
prefName
]
}
"
)
;
}
return
readDefaultValue
(
config
prefName
)
;
}
function
readDefaultValue
(
config
prefName
)
{
if
(
!
(
prefName
in
UpdateUtils
.
PER_INSTALLATION_PREFS
)
)
{
throw
new
Error
(
readDefaultValue
:
Unknown
per
-
installation
pref
'
{
prefName
}
'
)
;
}
const
pref
=
UpdateUtils
.
PER_INSTALLATION_PREFS
[
prefName
]
;
const
prefTypeFns
=
TYPE_SPECIFIC_PREF_FNS
[
pref
.
type
]
;
if
(
PER_INSTALLATION_DEFAULTS_BRANCH
in
config
)
{
let
defaults
=
config
[
PER_INSTALLATION_DEFAULTS_BRANCH
]
;
if
(
prefName
in
defaults
)
{
if
(
prefTypeFns
.
isValid
(
defaults
[
prefName
]
)
)
{
return
defaults
[
prefName
]
;
}
Cu
.
reportError
(
readEffectiveValue
:
Got
invalid
default
value
for
update
+
config
'
s
'
{
prefName
}
'
value
:
"
{
defaults
[
prefName
]
}
"
)
;
}
}
return
pref
.
defaultValue
;
}
async
function
readUpdateConfig
(
)
{
try
{
let
configFile
=
FileUtils
.
getDir
(
"
UpdRootD
"
[
]
true
)
;
configFile
.
append
(
FILE_UPDATE_CONFIG_JSON
)
;
let
binaryData
=
await
OS
.
File
.
read
(
configFile
.
path
)
;
setUpdateConfigMigrationDone
(
)
;
let
jsonData
=
new
TextDecoder
(
)
.
decode
(
binaryData
)
;
let
config
=
JSON
.
parse
(
jsonData
)
;
return
config
;
}
catch
(
e
)
{
if
(
e
instanceof
OS
.
File
.
Error
&
&
e
.
becauseNoSuchFile
)
{
if
(
updateConfigNeedsMigration
(
)
)
{
const
migrationConfig
=
makeMigrationUpdateConfig
(
)
;
setUpdateConfigMigrationDone
(
)
;
try
{
await
writeUpdateConfig
(
migrationConfig
)
;
onMigrationSuccessful
(
)
;
return
migrationConfig
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
readUpdateConfig
:
Migration
failed
:
"
+
e
)
;
}
}
}
else
{
setUpdateConfigMigrationDone
(
)
;
Cu
.
reportError
(
"
readUpdateConfig
:
Unable
to
read
app
update
configuration
file
.
"
+
"
Exception
:
"
+
e
)
;
}
return
makeDefaultUpdateConfig
(
)
;
}
}
async
function
writeUpdateConfig
(
config
)
{
let
configFile
=
FileUtils
.
getDir
(
"
UpdRootD
"
[
]
true
)
;
configFile
.
append
(
FILE_UPDATE_CONFIG_JSON
)
;
await
OS
.
File
.
writeAtomic
(
configFile
.
path
JSON
.
stringify
(
config
)
)
;
return
config
;
}
var
gUpdateConfigCache
;
function
maybeUpdateConfigChanged
(
config
)
{
if
(
!
gUpdateConfigCache
)
{
gUpdateConfigCache
=
config
;
return
config
;
}
for
(
const
[
prefName
pref
]
of
Object
.
entries
(
UpdateUtils
.
PER_INSTALLATION_PREFS
)
)
{
let
newPrefValue
=
readEffectiveValue
(
config
prefName
)
;
let
oldPrefValue
=
readEffectiveValue
(
gUpdateConfigCache
prefName
)
;
if
(
newPrefValue
!
=
oldPrefValue
)
{
Services
.
obs
.
notifyObservers
(
null
pref
.
observerTopic
newPrefValue
.
toString
(
)
)
;
}
}
gUpdateConfigCache
=
config
;
return
config
;
}
UpdateUtils
.
initPerInstallPrefs
(
)
;
function
getDistributionPrefValue
(
aPrefName
)
{
let
value
=
Services
.
prefs
.
getDefaultBranch
(
null
)
.
getCharPref
(
aPrefName
"
default
"
)
;
if
(
!
value
)
{
value
=
"
default
"
;
}
return
value
;
}
function
getSystemCapabilities
(
)
{
return
"
ISET
:
"
+
gInstructionSet
+
"
MEM
:
"
+
getMemoryMB
(
)
;
}
function
getMemoryMB
(
)
{
let
memoryMB
=
"
unknown
"
;
try
{
memoryMB
=
Services
.
sysinfo
.
getProperty
(
"
memsize
"
)
;
if
(
memoryMB
)
{
memoryMB
=
Math
.
round
(
memoryMB
/
1024
/
1024
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
"
Error
getting
system
info
memsize
property
.
Exception
:
"
+
e
)
;
}
return
memoryMB
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
gInstructionSet
"
function
aus_gIS
(
)
{
const
CPU_EXTENSIONS
=
[
"
hasSSE4_2
"
"
hasSSE4_1
"
"
hasSSE4A
"
"
hasSSSE3
"
"
hasSSE3
"
"
hasSSE2
"
"
hasSSE
"
"
hasMMX
"
"
hasNEON
"
"
hasARMv7
"
"
hasARMv6
"
]
;
for
(
let
ext
of
CPU_EXTENSIONS
)
{
if
(
Services
.
sysinfo
.
getProperty
(
ext
)
)
{
return
ext
.
substring
(
3
)
;
}
}
return
"
unknown
"
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gWinCPUArch
"
function
aus_gWinCPUArch
(
)
{
let
arch
=
"
unknown
"
;
const
WORD
=
ctypes
.
uint16_t
;
const
DWORD
=
ctypes
.
uint32_t
;
const
SYSTEM_INFO
=
new
ctypes
.
StructType
(
"
SYSTEM_INFO
"
[
{
wProcessorArchitecture
:
WORD
}
{
wReserved
:
WORD
}
{
dwPageSize
:
DWORD
}
{
lpMinimumApplicationAddress
:
ctypes
.
voidptr_t
}
{
lpMaximumApplicationAddress
:
ctypes
.
voidptr_t
}
{
dwActiveProcessorMask
:
DWORD
.
ptr
}
{
dwNumberOfProcessors
:
DWORD
}
{
dwProcessorType
:
DWORD
}
{
dwAllocationGranularity
:
DWORD
}
{
wProcessorLevel
:
WORD
}
{
wProcessorRevision
:
WORD
}
]
)
;
let
kernel32
=
false
;
try
{
kernel32
=
ctypes
.
open
(
"
Kernel32
"
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Unable
to
open
kernel32
!
Exception
:
"
+
e
)
;
}
if
(
kernel32
)
{
try
{
let
GetNativeSystemInfo
=
kernel32
.
declare
(
"
GetNativeSystemInfo
"
ctypes
.
winapi_abi
ctypes
.
void_t
SYSTEM_INFO
.
ptr
)
;
let
winSystemInfo
=
SYSTEM_INFO
(
)
;
winSystemInfo
.
wProcessorArchitecture
=
0xffff
;
GetNativeSystemInfo
(
winSystemInfo
.
address
(
)
)
;
switch
(
winSystemInfo
.
wProcessorArchitecture
)
{
case
12
:
arch
=
"
aarch64
"
;
break
;
case
9
:
arch
=
"
x64
"
;
break
;
case
6
:
arch
=
"
IA64
"
;
break
;
case
0
:
arch
=
"
x86
"
;
break
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
"
Error
getting
processor
architecture
.
Exception
:
"
+
e
)
;
}
finally
{
kernel32
.
close
(
)
;
}
}
return
arch
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
UpdateUtils
"
ABI
"
function
(
)
{
let
abi
=
null
;
try
{
abi
=
Services
.
appinfo
.
XPCOMABI
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
XPCOM
ABI
unknown
"
)
;
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
abi
+
=
"
-
"
+
gWinCPUArch
;
}
if
(
AppConstants
.
ASAN
)
{
abi
+
=
"
-
asan
"
;
}
return
abi
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
UpdateUtils
"
OSVersion
"
function
(
)
{
let
osVersion
;
try
{
osVersion
=
Services
.
sysinfo
.
getProperty
(
"
name
"
)
+
"
"
+
Services
.
sysinfo
.
getProperty
(
"
version
"
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
OS
Version
unknown
.
"
)
;
}
if
(
osVersion
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
try
{
const
{
servicePackMajor
servicePackMinor
buildNumber
}
=
WindowsVersionInfo
.
get
(
)
;
osVersion
+
=
.
{
servicePackMajor
}
.
{
servicePackMinor
}
.
{
buildNumber
}
;
}
catch
(
err
)
{
Cu
.
reportError
(
"
Unable
to
retrieve
windows
version
information
:
"
+
err
)
;
osVersion
+
=
"
.
unknown
"
;
}
if
(
Services
.
vc
.
compare
(
Services
.
sysinfo
.
getProperty
(
"
version
"
)
"
10
"
)
>
=
0
)
{
const
WINDOWS_UBR_KEY_PATH
=
"
SOFTWARE
\
\
Microsoft
\
\
Windows
NT
\
\
CurrentVersion
"
;
let
ubr
=
WindowsRegistry
.
readRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_LOCAL_MACHINE
WINDOWS_UBR_KEY_PATH
"
UBR
"
Ci
.
nsIWindowsRegKey
.
WOW64_64
)
;
if
(
ubr
!
=
=
undefined
)
{
osVersion
+
=
.
{
ubr
}
;
}
else
{
osVersion
+
=
"
.
unknown
"
;
}
}
osVersion
+
=
"
(
"
+
gWinCPUArch
+
"
)
"
;
}
try
{
osVersion
+
=
"
(
"
+
Services
.
sysinfo
.
getProperty
(
"
secondaryLibrary
"
)
+
"
)
"
;
}
catch
(
e
)
{
}
osVersion
=
encodeURIComponent
(
osVersion
)
;
}
return
osVersion
;
}
)
;
