"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
WebRequestCommon
"
"
resource
:
/
/
gre
/
modules
/
WebRequestCommon
.
jsm
"
)
;
const
IS_HTTP
=
/
^
(
?
:
http
|
ws
)
s
?
:
/
;
var
ContentPolicy
=
{
_classDescription
:
"
WebRequest
content
policy
"
_classID
:
Components
.
ID
(
"
938e5d24
-
9ccc
-
4b55
-
883e
-
c252a41f7ce9
"
)
_contractID
:
"
mozilla
.
org
/
webrequest
/
policy
;
1
"
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIContentPolicy
Ci
.
nsIFactory
Ci
.
nsISupportsWeakReference
]
)
init
(
)
{
let
registrar
=
Components
.
manager
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
registrar
.
registerFactory
(
this
.
_classID
this
.
_classDescription
this
.
_contractID
this
)
;
this
.
contentPolicies
=
new
Map
(
)
;
Services
.
cpmm
.
addMessageListener
(
"
WebRequest
:
AddContentPolicy
"
this
)
;
Services
.
cpmm
.
addMessageListener
(
"
WebRequest
:
RemoveContentPolicy
"
this
)
;
if
(
initialProcessData
&
&
initialProcessData
.
webRequestContentPolicies
)
{
for
(
let
data
of
initialProcessData
.
webRequestContentPolicies
.
values
(
)
)
{
this
.
addContentPolicy
(
data
)
;
}
}
}
addContentPolicy
(
{
id
blocking
filter
}
)
{
if
(
this
.
contentPolicies
.
size
=
=
0
)
{
this
.
register
(
)
;
}
if
(
filter
.
urls
)
{
filter
.
urls
=
new
MatchPatternSet
(
filter
.
urls
)
;
}
this
.
contentPolicies
.
set
(
id
{
blocking
filter
}
)
;
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
WebRequest
:
AddContentPolicy
"
:
this
.
addContentPolicy
(
msg
.
data
)
;
break
;
case
"
WebRequest
:
RemoveContentPolicy
"
:
this
.
contentPolicies
.
delete
(
msg
.
data
.
id
)
;
if
(
this
.
contentPolicies
.
size
=
=
0
)
{
this
.
unregister
(
)
;
}
break
;
}
}
register
(
)
{
let
catMan
=
Cc
[
"
mozilla
.
org
/
categorymanager
;
1
"
]
.
getService
(
Ci
.
nsICategoryManager
)
;
catMan
.
addCategoryEntry
(
"
content
-
policy
"
this
.
_contractID
this
.
_contractID
false
true
)
;
}
unregister
(
)
{
let
catMan
=
Cc
[
"
mozilla
.
org
/
categorymanager
;
1
"
]
.
getService
(
Ci
.
nsICategoryManager
)
;
catMan
.
deleteCategoryEntry
(
"
content
-
policy
"
this
.
_contractID
false
)
;
}
shouldLoad
(
contentLocation
loadInfo
mimeTypeGuess
)
{
let
policyType
=
loadInfo
.
externalContentPolicyType
;
let
loadingPrincipal
=
loadInfo
.
loadingPrincipal
;
let
requestPrincipal
=
loadInfo
.
triggeringPrincipal
;
let
requestOrigin
=
null
;
if
(
loadingPrincipal
)
{
requestOrigin
=
loadingPrincipal
.
URI
;
}
if
(
loadInfo
.
skipContentPolicyCheckForWebRequest
)
{
return
Ci
.
nsIContentPolicy
.
ACCEPT
;
}
if
(
requestPrincipal
&
&
Services
.
scriptSecurityManager
.
isSystemPrincipal
(
requestPrincipal
)
)
{
return
Ci
.
nsIContentPolicy
.
ACCEPT
;
}
let
url
=
contentLocation
.
spec
;
if
(
IS_HTTP
.
test
(
url
)
)
{
return
Ci
.
nsIContentPolicy
.
ACCEPT
;
}
let
ids
=
[
]
;
for
(
let
[
id
{
filter
}
]
of
this
.
contentPolicies
.
entries
(
)
)
{
if
(
WebRequestCommon
.
typeMatches
(
policyType
filter
.
types
)
&
&
WebRequestCommon
.
urlMatches
(
contentLocation
filter
.
urls
)
)
{
ids
.
push
(
id
)
;
}
}
if
(
!
ids
.
length
)
{
return
Ci
.
nsIContentPolicy
.
ACCEPT
;
}
let
windowId
=
0
;
let
parentWindowId
=
-
1
;
let
frameAncestors
=
[
]
;
let
mm
=
Services
.
cpmm
;
function
getWindowId
(
window
)
{
return
window
.
windowUtils
.
outerWindowID
;
}
let
node
=
loadInfo
.
loadingContext
;
if
(
node
&
&
(
policyType
=
=
Ci
.
nsIContentPolicy
.
TYPE_SUBDOCUMENT
|
|
(
ChromeUtils
.
getClassName
(
node
)
=
=
"
XULFrameElement
"
&
&
node
.
localName
=
=
"
browser
"
)
)
)
{
node
=
node
.
contentWindow
;
}
if
(
node
)
{
let
window
;
if
(
node
instanceof
Ci
.
nsIDOMWindow
)
{
window
=
node
;
}
else
{
let
doc
;
if
(
node
.
ownerDocument
)
{
doc
=
node
.
ownerDocument
;
}
else
{
doc
=
node
;
}
window
=
doc
.
defaultView
;
}
windowId
=
getWindowId
(
window
)
;
if
(
window
.
parent
!
=
=
window
)
{
parentWindowId
=
getWindowId
(
window
.
parent
)
;
for
(
let
frame
=
window
.
parent
;
;
frame
=
frame
.
parent
)
{
frameAncestors
.
push
(
{
url
:
frame
.
document
.
documentURIObject
.
spec
frameId
:
getWindowId
(
frame
)
}
)
;
if
(
frame
=
=
=
frame
.
parent
)
{
frameAncestors
[
frameAncestors
.
length
-
1
]
.
frameId
=
0
;
break
;
}
}
}
let
ir
=
window
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
try
{
mm
=
ir
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_NOINTERFACE
)
{
throw
e
;
}
}
}
let
data
=
{
ids
url
type
:
WebRequestCommon
.
typeForPolicyType
(
policyType
)
windowId
parentWindowId
}
;
if
(
frameAncestors
.
length
>
0
)
{
data
.
frameAncestors
=
frameAncestors
;
}
if
(
requestOrigin
)
{
data
.
documentUrl
=
requestOrigin
.
spec
;
}
if
(
requestPrincipal
&
&
requestPrincipal
.
URI
)
{
data
.
originUrl
=
requestPrincipal
.
URI
.
spec
;
}
mm
.
sendAsyncMessage
(
"
WebRequest
:
ShouldLoad
"
data
)
;
return
Ci
.
nsIContentPolicy
.
ACCEPT
;
}
shouldProcess
:
function
(
contentLocation
loadInfo
mimeType
)
{
return
Ci
.
nsIContentPolicy
.
ACCEPT
;
}
createInstance
:
function
(
outer
iid
)
{
if
(
outer
)
{
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
}
return
this
.
QueryInterface
(
iid
)
;
}
}
;
ContentPolicy
.
init
(
)
;
