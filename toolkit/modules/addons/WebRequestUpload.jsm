"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
WebRequestUpload
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
{
DefaultMap
}
=
ExtensionUtils
;
const
BinaryInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
binaryinputstream
;
1
"
"
nsIBinaryInputStream
"
"
setInputStream
"
)
;
const
ConverterInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
intl
/
converter
-
input
-
stream
;
1
"
"
nsIConverterInputStream
"
"
init
"
)
;
var
WebRequestUpload
;
function
mapToObject
(
map
)
{
let
result
=
{
}
;
for
(
let
[
key
value
]
of
map
)
{
result
[
key
]
=
value
;
}
return
result
;
}
function
rewind
(
stream
)
{
stream
.
QueryInterface
(
Ci
.
nsISeekableStream
)
;
try
{
stream
.
seek
(
0
0
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
function
*
getStreams
(
outerStream
)
{
let
unbuffered
=
outerStream
;
if
(
outerStream
instanceof
Ci
.
nsIStreamBufferAccess
)
{
unbuffered
=
outerStream
.
unbufferedStream
;
}
if
(
unbuffered
instanceof
Ci
.
nsIMultiplexInputStream
)
{
let
count
=
unbuffered
.
count
;
for
(
let
i
=
0
;
i
<
count
;
i
+
+
)
{
yield
unbuffered
.
getStream
(
i
)
;
}
}
else
{
yield
outerStream
;
}
}
function
parseFormData
(
stream
channel
lenient
=
false
)
{
const
BUFFER_SIZE
=
8192
;
let
touchedStreams
=
new
Set
(
)
;
function
createTextStream
(
stream
)
{
if
(
!
(
stream
instanceof
Ci
.
nsISeekableStream
)
)
{
return
null
;
}
touchedStreams
.
add
(
stream
)
;
return
ConverterInputStream
(
stream
"
UTF
-
8
"
0
lenient
?
Ci
.
nsIConverterInputStream
.
DEFAULT_REPLACEMENT_CHARACTER
:
0
)
;
}
function
readString
(
stream
length
=
BUFFER_SIZE
)
{
let
data
=
{
}
;
stream
.
readString
(
length
data
)
;
return
data
.
value
;
}
function
*
getTextStreams
(
outerStream
)
{
for
(
let
stream
of
getStreams
(
outerStream
)
)
{
if
(
stream
instanceof
Ci
.
nsIStringInputStream
)
{
touchedStreams
.
add
(
outerStream
)
;
yield
createTextStream
(
stream
)
;
}
}
}
function
*
readAllStrings
(
outerStream
)
{
for
(
let
textStream
of
getTextStreams
(
outerStream
)
)
{
let
str
;
while
(
(
str
=
readString
(
textStream
)
)
)
{
yield
str
;
}
}
}
function
*
getParts
(
stream
boundary
tail
=
"
"
)
{
for
(
let
chunk
of
readAllStrings
(
stream
)
)
{
chunk
=
tail
+
chunk
;
let
parts
=
chunk
.
split
(
boundary
)
;
tail
=
parts
.
pop
(
)
;
yield
*
parts
;
}
if
(
tail
)
{
yield
tail
;
}
}
function
parseMultiPart
(
stream
boundary
)
{
let
formData
=
new
DefaultMap
(
(
)
=
>
[
]
)
;
let
unslash
=
str
=
>
str
.
replace
(
/
\
\
"
/
g
'
"
'
)
;
for
(
let
part
of
getParts
(
stream
boundary
"
\
r
\
n
"
)
)
{
if
(
part
=
=
=
"
-
-
\
r
\
n
"
)
{
break
;
}
let
match
=
part
.
match
(
/
^
\
r
\
nContent
-
Disposition
:
form
-
data
;
name
=
"
(
.
*
)
"
\
r
\
n
(
?
:
Content
-
Type
:
(
\
S
+
)
)
?
.
*
\
r
\
n
/
i
)
;
if
(
!
match
)
{
continue
;
}
let
[
header
name
contentType
]
=
match
;
let
value
=
"
"
;
if
(
contentType
)
{
let
fileName
;
match
=
name
.
match
(
/
^
(
.
*
[
^
\
\
]
)
"
;
filename
=
"
(
.
*
)
/
)
;
if
(
match
)
{
[
name
fileName
]
=
match
;
}
if
(
fileName
)
{
value
=
unslash
(
fileName
)
;
}
}
else
{
value
=
part
.
slice
(
header
.
length
)
;
}
formData
.
get
(
unslash
(
name
)
)
.
push
(
value
)
;
}
return
formData
;
}
function
parseUrlEncoded
(
stream
)
{
let
formData
=
new
DefaultMap
(
(
)
=
>
[
]
)
;
for
(
let
part
of
getParts
(
stream
"
&
"
)
)
{
let
[
name
value
]
=
part
.
replace
(
/
\
+
/
g
"
"
)
.
split
(
"
=
"
)
.
map
(
decodeURIComponent
)
;
formData
.
get
(
name
)
.
push
(
value
)
;
}
return
formData
;
}
try
{
let
headers
;
if
(
stream
instanceof
Ci
.
nsIMIMEInputStream
&
&
stream
.
data
)
{
headers
=
readString
(
createTextStream
(
stream
)
stream
.
available
(
)
-
stream
.
data
.
available
(
)
)
;
rewind
(
stream
)
;
stream
=
stream
.
data
;
}
let
contentType
;
try
{
contentType
=
channel
.
getRequestHeader
(
"
Content
-
Type
"
)
;
}
catch
(
e
)
{
let
match
=
/
^
Content
-
Type
:
\
s
+
(
.
+
)
/
i
.
exec
(
headers
)
;
contentType
=
match
&
&
match
[
1
]
;
}
let
match
=
/
^
(
?
:
multipart
\
/
form
-
data
;
\
s
*
boundary
=
(
\
S
*
)
|
(
application
\
/
x
-
www
-
form
-
urlencoded
)
)
/
i
.
exec
(
contentType
)
;
if
(
match
)
{
let
boundary
=
match
[
1
]
;
if
(
boundary
)
{
return
parseMultiPart
(
stream
\
r
\
n
-
-
{
boundary
}
)
;
}
if
(
match
[
2
]
)
{
return
parseUrlEncoded
(
stream
)
;
}
}
}
finally
{
for
(
let
stream
of
touchedStreams
)
{
rewind
(
stream
)
;
}
}
return
null
;
}
function
createFormData
(
stream
channel
lenient
)
{
if
(
!
(
stream
instanceof
Ci
.
nsISeekableStream
)
)
{
return
null
;
}
try
{
let
formData
=
parseFormData
(
stream
channel
lenient
)
;
if
(
formData
)
{
return
mapToObject
(
formData
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
finally
{
rewind
(
stream
)
;
}
return
null
;
}
function
*
getRawDataChunked
(
outerStream
maxRead
=
WebRequestUpload
.
MAX_RAW_BYTES
)
{
for
(
let
stream
of
getStreams
(
outerStream
)
)
{
let
unbuffered
=
stream
;
if
(
stream
instanceof
Ci
.
nsIStreamBufferAccess
)
{
unbuffered
=
stream
.
unbufferedStream
;
}
if
(
unbuffered
instanceof
Ci
.
nsIFileInputStream
)
{
yield
{
file
:
"
<
file
>
"
}
;
continue
;
}
try
{
let
binaryStream
=
BinaryInputStream
(
stream
)
;
let
available
;
while
(
(
available
=
binaryStream
.
available
(
)
)
)
{
let
buffer
=
new
ArrayBuffer
(
Math
.
min
(
maxRead
available
)
)
;
binaryStream
.
readArrayBuffer
(
buffer
.
byteLength
buffer
)
;
maxRead
-
=
buffer
.
byteLength
;
let
chunk
=
{
bytes
:
buffer
}
;
if
(
buffer
.
byteLength
<
available
)
{
chunk
.
truncated
=
true
;
chunk
.
originalSize
=
available
;
}
yield
chunk
;
if
(
maxRead
<
=
0
)
{
return
;
}
}
}
finally
{
rewind
(
stream
)
;
}
}
}
WebRequestUpload
=
{
createRequestBody
(
channel
)
{
if
(
channel
instanceof
Ci
.
nsIUploadChannel
&
&
channel
.
uploadStream
)
{
try
{
let
stream
=
channel
.
uploadStream
;
let
formData
=
createFormData
(
stream
channel
)
;
if
(
formData
)
{
return
{
formData
}
;
}
return
{
raw
:
Array
.
from
(
getRawDataChunked
(
stream
)
)
lenientFormData
:
createFormData
(
stream
channel
true
)
}
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
{
error
:
e
.
message
|
|
String
(
e
)
}
;
}
}
return
null
;
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
WebRequestUpload
"
MAX_RAW_BYTES
"
"
webextensions
.
webRequest
.
requestBodyMaxRawBytes
"
)
;
