"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
WebNavigation
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserWindowTracker
"
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
)
;
const
RECENT_DATA_THRESHOLD
=
5
*
1000000
;
var
Manager
=
{
listeners
:
new
Map
(
)
init
(
)
{
this
.
recentTabTransitionData
=
new
WeakMap
(
)
;
this
.
createdNavigationTargetByOuterWindowId
=
new
Map
(
)
;
Services
.
obs
.
addObserver
(
this
"
autocomplete
-
did
-
enter
-
text
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
webNavigation
-
createdNavigationTarget
"
)
;
Services
.
mm
.
addMessageListener
(
"
Content
:
Click
"
this
)
;
Services
.
mm
.
addMessageListener
(
"
Extension
:
DOMContentLoaded
"
this
)
;
Services
.
mm
.
addMessageListener
(
"
Extension
:
StateChange
"
this
)
;
Services
.
mm
.
addMessageListener
(
"
Extension
:
DocumentChange
"
this
)
;
Services
.
mm
.
addMessageListener
(
"
Extension
:
HistoryChange
"
this
)
;
Services
.
mm
.
addMessageListener
(
"
Extension
:
CreatedNavigationTarget
"
this
)
;
Services
.
mm
.
loadFrameScript
(
"
resource
:
/
/
gre
/
modules
/
WebNavigationContent
.
js
"
true
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
"
autocomplete
-
did
-
enter
-
text
"
)
;
Services
.
obs
.
removeObserver
(
this
"
webNavigation
-
createdNavigationTarget
"
)
;
Services
.
mm
.
removeMessageListener
(
"
Content
:
Click
"
this
)
;
Services
.
mm
.
removeMessageListener
(
"
Extension
:
StateChange
"
this
)
;
Services
.
mm
.
removeMessageListener
(
"
Extension
:
DocumentChange
"
this
)
;
Services
.
mm
.
removeMessageListener
(
"
Extension
:
HistoryChange
"
this
)
;
Services
.
mm
.
removeMessageListener
(
"
Extension
:
DOMContentLoaded
"
this
)
;
Services
.
mm
.
removeMessageListener
(
"
Extension
:
CreatedNavigationTarget
"
this
)
;
Services
.
mm
.
removeDelayedFrameScript
(
"
resource
:
/
/
gre
/
modules
/
WebNavigationContent
.
js
"
)
;
Services
.
mm
.
broadcastAsyncMessage
(
"
Extension
:
DisableWebNavigation
"
)
;
this
.
recentTabTransitionData
=
new
WeakMap
(
)
;
this
.
createdNavigationTargetByOuterWindowId
.
clear
(
)
;
}
addListener
(
type
listener
filters
)
{
if
(
this
.
listeners
.
size
=
=
0
)
{
this
.
init
(
)
;
}
if
(
!
this
.
listeners
.
has
(
type
)
)
{
this
.
listeners
.
set
(
type
new
Map
(
)
)
;
}
let
listeners
=
this
.
listeners
.
get
(
type
)
;
listeners
.
set
(
listener
filters
)
;
}
removeListener
(
type
listener
)
{
let
listeners
=
this
.
listeners
.
get
(
type
)
;
if
(
!
listeners
)
{
return
;
}
listeners
.
delete
(
listener
)
;
if
(
listeners
.
size
=
=
0
)
{
this
.
listeners
.
delete
(
type
)
;
}
if
(
this
.
listeners
.
size
=
=
0
)
{
this
.
uninit
(
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
observe
:
function
(
subject
topic
data
)
{
if
(
topic
=
=
"
autocomplete
-
did
-
enter
-
text
"
)
{
this
.
onURLBarAutoCompletion
(
subject
)
;
}
else
if
(
topic
=
=
"
webNavigation
-
createdNavigationTarget
"
)
{
const
{
createdTabBrowser
url
sourceFrameOuterWindowID
sourceTabBrowser
}
=
subject
.
wrappedJSObject
;
this
.
fire
(
"
onCreatedNavigationTarget
"
createdTabBrowser
{
}
{
sourceTabBrowser
sourceFrameId
:
sourceFrameOuterWindowID
url
}
)
;
}
}
onURLBarAutoCompletion
(
input
)
{
if
(
input
&
&
input
instanceof
Ci
.
nsIAutoCompleteInput
)
{
if
(
input
.
id
!
=
=
"
urlbar
"
)
{
return
;
}
let
controller
=
input
.
popup
.
view
.
QueryInterface
(
Ci
.
nsIAutoCompleteController
)
;
let
idx
=
input
.
popup
.
selectedIndex
;
let
tabTransistionData
=
{
from_address_bar
:
true
}
;
if
(
idx
<
0
|
|
idx
>
=
controller
.
matchCount
)
{
tabTransistionData
.
typed
=
true
;
}
else
{
let
value
=
controller
.
getValueAt
(
idx
)
;
let
action
=
input
.
_parseActionUrl
(
value
)
;
if
(
action
)
{
switch
(
action
.
type
)
{
case
"
keyword
"
:
tabTransistionData
.
keyword
=
true
;
break
;
case
"
searchengine
"
:
case
"
searchsuggestion
"
:
tabTransistionData
.
generated
=
true
;
break
;
case
"
visiturl
"
:
tabTransistionData
.
typed
=
true
;
break
;
case
"
remotetab
"
:
tabTransistionData
.
typed
=
true
;
break
;
case
"
switchtab
"
:
return
;
default
:
tabTransistionData
.
typed
=
true
;
}
}
else
{
let
styles
=
new
Set
(
controller
.
getStyleAt
(
idx
)
.
split
(
/
\
s
+
/
)
)
;
if
(
styles
.
has
(
"
bookmark
"
)
)
{
tabTransistionData
.
auto_bookmark
=
true
;
}
else
{
tabTransistionData
.
typed
=
true
;
}
}
}
this
.
setRecentTabTransitionData
(
tabTransistionData
)
;
}
}
setRecentTabTransitionData
(
tabTransitionData
)
{
let
window
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
window
&
&
window
.
gBrowser
&
&
window
.
gBrowser
.
selectedTab
&
&
window
.
gBrowser
.
selectedTab
.
linkedBrowser
)
{
let
browser
=
window
.
gBrowser
.
selectedTab
.
linkedBrowser
;
let
prevData
=
this
.
getAndForgetRecentTabTransitionData
(
browser
)
;
let
newData
=
Object
.
assign
(
{
time
:
Date
.
now
(
)
}
prevData
tabTransitionData
)
;
this
.
recentTabTransitionData
.
set
(
browser
newData
)
;
}
}
getAndForgetRecentTabTransitionData
(
browser
)
{
let
data
=
this
.
recentTabTransitionData
.
get
(
browser
)
;
this
.
recentTabTransitionData
.
delete
(
browser
)
;
if
(
!
data
|
|
(
data
.
time
-
Date
.
now
(
)
)
>
RECENT_DATA_THRESHOLD
)
{
return
{
}
;
}
return
data
;
}
receiveMessage
(
{
name
data
target
}
)
{
switch
(
name
)
{
case
"
Extension
:
StateChange
"
:
this
.
onStateChange
(
target
data
)
;
break
;
case
"
Extension
:
DocumentChange
"
:
this
.
onDocumentChange
(
target
data
)
;
break
;
case
"
Extension
:
HistoryChange
"
:
this
.
onHistoryChange
(
target
data
)
;
break
;
case
"
Extension
:
DOMContentLoaded
"
:
this
.
onLoad
(
target
data
)
;
break
;
case
"
Content
:
Click
"
:
this
.
onContentClick
(
target
data
)
;
break
;
case
"
Extension
:
CreatedNavigationTarget
"
:
this
.
onCreatedNavigationTarget
(
target
data
)
;
break
;
}
}
onContentClick
(
target
data
)
{
if
(
data
.
href
&
&
!
data
.
bookmark
)
{
let
ownerWin
=
target
.
ownerGlobal
;
let
where
=
ownerWin
.
whereToOpenLink
(
data
)
;
if
(
where
=
=
"
current
"
)
{
this
.
setRecentTabTransitionData
(
{
link
:
true
}
)
;
}
}
}
onCreatedNavigationTarget
(
browser
data
)
{
const
{
createdOuterWindowId
isSourceTab
sourceFrameId
url
}
=
data
;
const
pairedMessage
=
this
.
createdNavigationTargetByOuterWindowId
.
get
(
createdOuterWindowId
)
;
if
(
!
isSourceTab
)
{
if
(
pairedMessage
)
{
Services
.
console
.
logStringMessage
(
Discarding
onCreatedNavigationTarget
for
{
createdOuterWindowId
}
:
+
"
unexpected
pending
data
while
receiving
the
created
tab
data
"
)
;
}
const
browserWeakRef
=
Cu
.
getWeakReference
(
browser
)
;
this
.
createdNavigationTargetByOuterWindowId
.
set
(
createdOuterWindowId
{
browserWeakRef
data
}
)
;
return
;
}
if
(
!
pairedMessage
)
{
Services
.
console
.
logStringMessage
(
Discarding
onCreatedNavigationTarget
for
{
createdOuterWindowId
}
:
+
"
received
source
tab
data
without
any
created
tab
data
available
"
)
;
return
;
}
this
.
createdNavigationTargetByOuterWindowId
.
delete
(
createdOuterWindowId
)
;
let
sourceTabBrowser
=
browser
;
let
createdTabBrowser
=
pairedMessage
.
browserWeakRef
.
get
(
)
;
if
(
!
createdTabBrowser
)
{
Services
.
console
.
logStringMessage
(
Discarding
onCreatedNavigationTarget
for
{
createdOuterWindowId
}
:
+
"
the
created
tab
has
been
already
destroyed
"
)
;
return
;
}
this
.
fire
(
"
onCreatedNavigationTarget
"
createdTabBrowser
{
}
{
sourceTabBrowser
sourceFrameId
url
}
)
;
}
onStateChange
(
browser
data
)
{
let
stateFlags
=
data
.
stateFlags
;
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
)
{
let
url
=
data
.
requestURL
;
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
this
.
fire
(
"
onBeforeNavigate
"
browser
data
{
url
}
)
;
}
else
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
if
(
Components
.
isSuccessCode
(
data
.
status
)
)
{
this
.
fire
(
"
onCompleted
"
browser
data
{
url
}
)
;
}
else
{
let
error
=
Error
code
{
data
.
status
}
;
this
.
fire
(
"
onErrorOccurred
"
browser
data
{
error
url
}
)
;
}
}
}
}
onDocumentChange
(
browser
data
)
{
let
extra
=
{
url
:
data
.
location
frameTransitionData
:
data
.
frameTransitionData
tabTransitionData
:
this
.
getAndForgetRecentTabTransitionData
(
browser
)
}
;
this
.
fire
(
"
onCommitted
"
browser
data
extra
)
;
}
onHistoryChange
(
browser
data
)
{
let
extra
=
{
url
:
data
.
location
frameTransitionData
:
data
.
frameTransitionData
tabTransitionData
:
this
.
getAndForgetRecentTabTransitionData
(
browser
)
}
;
if
(
data
.
isReferenceFragmentUpdated
)
{
this
.
fire
(
"
onReferenceFragmentUpdated
"
browser
data
extra
)
;
}
else
if
(
data
.
isHistoryStateUpdated
)
{
this
.
fire
(
"
onHistoryStateUpdated
"
browser
data
extra
)
;
}
}
onLoad
(
browser
data
)
{
this
.
fire
(
"
onDOMContentLoaded
"
browser
data
{
url
:
data
.
url
}
)
;
}
fire
(
type
browser
data
extra
)
{
let
listeners
=
this
.
listeners
.
get
(
type
)
;
if
(
!
listeners
)
{
return
;
}
let
details
=
{
browser
frameId
:
data
.
frameId
}
;
if
(
data
.
parentFrameId
!
=
=
undefined
)
{
details
.
parentFrameId
=
data
.
parentFrameId
;
}
for
(
let
prop
in
extra
)
{
details
[
prop
]
=
extra
[
prop
]
;
}
for
(
let
[
listener
filters
]
of
listeners
)
{
if
(
!
filters
|
|
filters
.
matches
(
extra
.
url
)
)
{
listener
(
details
)
;
}
}
}
}
;
const
EVENTS
=
[
"
onBeforeNavigate
"
"
onCommitted
"
"
onDOMContentLoaded
"
"
onCompleted
"
"
onErrorOccurred
"
"
onReferenceFragmentUpdated
"
"
onHistoryStateUpdated
"
"
onCreatedNavigationTarget
"
]
;
var
WebNavigation
=
{
}
;
for
(
let
event
of
EVENTS
)
{
WebNavigation
[
event
]
=
{
addListener
:
Manager
.
addListener
.
bind
(
Manager
event
)
removeListener
:
Manager
.
removeListener
.
bind
(
Manager
event
)
}
;
}
