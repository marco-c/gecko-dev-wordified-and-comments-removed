"
use
strict
"
;
const
Cu
=
Components
.
utils
;
const
Ci
=
Components
.
interfaces
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
MatchPattern
"
"
MatchGlobs
"
"
MatchURLFilters
"
]
;
const
PERMITTED_SCHEMES
=
[
"
http
"
"
https
"
"
file
"
"
ftp
"
"
data
"
]
;
const
PERMITTED_SCHEMES_REGEXP
=
PERMITTED_SCHEMES
.
join
(
"
|
"
)
;
const
PATTERN_REGEXP
=
new
RegExp
(
^
(
{
PERMITTED_SCHEMES_REGEXP
}
|
\
\
*
)
:
/
/
(
\
\
*
|
\
\
*
\
\
.
[
^
*
/
]
+
|
[
^
*
/
]
+
|
)
(
/
.
*
)
)
;
const
WILDCARD_SCHEMES
=
[
"
http
"
"
https
"
]
;
function
globToRegexp
(
pat
allowQuestion
)
{
pat
=
pat
.
replace
(
/
[
.
+
^
{
}
(
)
|
[
\
]
\
\
]
/
g
"
\
\
&
"
)
;
if
(
allowQuestion
)
{
pat
=
pat
.
replace
(
/
\
?
/
g
"
.
"
)
;
}
else
{
pat
=
pat
.
replace
(
/
\
?
/
g
"
\
\
?
"
)
;
}
pat
=
pat
.
replace
(
/
\
*
/
g
"
.
*
"
)
;
return
new
RegExp
(
"
^
"
+
pat
+
"
"
)
;
}
function
SingleMatchPattern
(
pat
)
{
this
.
pat
=
pat
;
if
(
pat
=
=
"
<
all_urls
>
"
)
{
this
.
schemes
=
PERMITTED_SCHEMES
;
this
.
hostMatch
=
(
)
=
>
true
;
this
.
pathMatch
=
(
)
=
>
true
;
}
else
if
(
!
pat
)
{
this
.
schemes
=
[
]
;
}
else
{
let
match
=
PATTERN_REGEXP
.
exec
(
pat
)
;
if
(
!
match
)
{
Cu
.
reportError
(
Invalid
match
pattern
:
'
{
pat
}
'
)
;
this
.
schemes
=
[
]
;
return
;
}
if
(
match
[
1
]
=
=
"
*
"
)
{
this
.
schemes
=
WILDCARD_SCHEMES
;
}
else
{
this
.
schemes
=
[
match
[
1
]
]
;
}
if
(
match
[
2
]
=
=
"
"
&
&
this
.
schemes
[
0
]
!
=
"
file
"
)
{
Cu
.
reportError
(
Invalid
match
pattern
:
'
{
pat
}
'
)
;
this
.
schemes
=
[
]
;
return
;
}
this
.
host
=
match
[
2
]
;
this
.
hostMatch
=
this
.
getHostMatcher
(
match
[
2
]
)
;
let
pathMatch
=
globToRegexp
(
match
[
3
]
false
)
;
this
.
pathMatch
=
pathMatch
.
test
.
bind
(
pathMatch
)
;
}
}
SingleMatchPattern
.
prototype
=
{
getHostMatcher
(
host
)
{
if
(
host
=
=
"
*
"
)
{
return
(
)
=
>
true
;
}
if
(
host
.
startsWith
(
"
*
.
"
)
)
{
let
suffix
=
host
.
substr
(
2
)
;
let
dotSuffix
=
"
.
"
+
suffix
;
return
(
{
host
}
)
=
>
host
=
=
=
suffix
|
|
host
.
endsWith
(
dotSuffix
)
;
}
return
uri
=
>
uri
.
host
=
=
=
host
;
}
matches
(
uri
ignorePath
=
false
)
{
return
(
this
.
schemes
.
includes
(
uri
.
scheme
)
&
&
this
.
hostMatch
(
uri
)
&
&
(
ignorePath
|
|
(
this
.
pathMatch
(
uri
.
cloneIgnoringRef
(
)
.
path
)
)
)
)
;
}
}
;
this
.
MatchPattern
=
function
(
pat
)
{
this
.
pat
=
pat
;
if
(
!
pat
)
{
this
.
matchers
=
[
]
;
}
else
if
(
pat
instanceof
String
|
|
typeof
(
pat
)
=
=
"
string
"
)
{
this
.
matchers
=
[
new
SingleMatchPattern
(
pat
)
]
;
}
else
{
this
.
matchers
=
pat
.
map
(
p
=
>
new
SingleMatchPattern
(
p
)
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
explicitMatchers
"
(
)
=
>
{
return
this
.
matchers
.
filter
(
matcher
=
>
matcher
.
pat
!
=
"
<
all_urls
>
"
&
&
matcher
.
host
&
&
!
matcher
.
host
.
startsWith
(
"
*
"
)
)
;
}
)
;
}
;
MatchPattern
.
prototype
=
{
matches
(
uri
)
{
return
this
.
matchers
.
some
(
matcher
=
>
matcher
.
matches
(
uri
)
)
;
}
matchesIgnoringPath
(
uri
explicit
=
false
)
{
if
(
explicit
)
{
return
this
.
explicitMatchers
.
some
(
matcher
=
>
matcher
.
matches
(
uri
true
)
)
;
}
return
this
.
matchers
.
some
(
matcher
=
>
matcher
.
matches
(
uri
true
)
)
;
}
matchesCookie
(
cookie
)
{
let
secureURI
=
NetUtil
.
newURI
(
https
:
/
/
{
cookie
.
rawHost
}
/
)
;
if
(
this
.
matchesIgnoringPath
(
secureURI
)
)
{
return
true
;
}
let
plainURI
=
NetUtil
.
newURI
(
http
:
/
/
{
cookie
.
rawHost
}
/
)
;
if
(
!
cookie
.
isSecure
&
&
this
.
matchesIgnoringPath
(
plainURI
)
)
{
return
true
;
}
if
(
!
cookie
.
isDomain
)
{
return
false
;
}
let
{
host
isSecure
}
=
cookie
;
for
(
let
matcher
of
this
.
matchers
)
{
let
schemes
=
matcher
.
schemes
;
if
(
schemes
.
includes
(
"
https
"
)
|
|
(
!
isSecure
&
&
schemes
.
includes
(
"
http
"
)
)
)
{
if
(
matcher
.
host
.
endsWith
(
host
)
)
{
return
true
;
}
}
}
return
false
;
}
subsumes
(
pattern
)
{
let
match
=
PATTERN_REGEXP
.
exec
(
pattern
)
;
if
(
!
match
)
{
throw
new
Error
(
"
Invalid
match
pattern
"
)
;
}
if
(
match
[
1
]
=
=
"
*
"
)
{
return
WILDCARD_SCHEMES
.
every
(
scheme
=
>
this
.
matchesIgnoringPath
(
{
scheme
host
:
match
[
2
]
}
)
)
;
}
return
this
.
matchesIgnoringPath
(
{
scheme
:
match
[
1
]
host
:
match
[
2
]
}
)
;
}
serialize
(
)
{
return
this
.
pat
;
}
removeOne
(
pattern
)
{
if
(
!
Array
.
isArray
(
this
.
pat
)
)
{
return
;
}
let
index
=
this
.
pat
.
indexOf
(
pattern
)
;
if
(
index
>
=
0
)
{
if
(
this
.
matchers
[
index
]
.
pat
!
=
pattern
)
{
throw
new
Error
(
"
pat
/
matcher
mismatch
in
removeOne
(
)
"
)
;
}
this
.
pat
.
splice
(
index
1
)
;
this
.
matchers
.
splice
(
index
1
)
;
}
}
}
;
this
.
MatchGlobs
=
function
(
globs
)
{
this
.
original
=
globs
;
if
(
globs
)
{
this
.
regexps
=
Array
.
from
(
globs
(
glob
)
=
>
globToRegexp
(
glob
true
)
)
;
}
else
{
this
.
regexps
=
[
]
;
}
}
;
MatchGlobs
.
prototype
=
{
matches
(
str
)
{
return
this
.
regexps
.
some
(
regexp
=
>
regexp
.
test
(
str
)
)
;
}
serialize
(
)
{
return
this
.
original
;
}
}
;
this
.
MatchURLFilters
=
function
(
filters
)
{
if
(
!
Array
.
isArray
(
filters
)
)
{
throw
new
TypeError
(
"
filters
should
be
an
array
"
)
;
}
if
(
filters
.
length
=
=
0
)
{
throw
new
Error
(
"
filters
array
should
not
be
empty
"
)
;
}
this
.
filters
=
filters
;
}
;
MatchURLFilters
.
prototype
=
{
matches
(
url
)
{
let
uri
=
NetUtil
.
newURI
(
url
)
;
let
uriURL
=
{
}
;
if
(
uri
instanceof
Ci
.
nsIURL
)
{
uriURL
=
uri
;
}
let
host
=
"
"
;
try
{
host
=
uri
.
host
;
}
catch
(
e
)
{
}
let
port
;
try
{
port
=
uri
.
port
;
}
catch
(
e
)
{
}
let
data
=
{
path
:
uriURL
.
filePath
query
:
uriURL
.
query
host
port
url
}
;
return
this
.
filters
.
some
(
filter
=
>
this
.
matchURLFilter
(
{
filter
data
uri
uriURL
}
)
)
;
}
matchURLFilter
(
{
filter
data
uri
uriURL
}
)
{
if
(
filter
.
schemes
)
{
if
(
!
filter
.
schemes
.
some
(
(
scheme
)
=
>
uri
.
schemeIs
(
scheme
)
)
)
{
return
false
;
}
}
if
(
filter
.
ports
)
{
let
port
=
data
.
port
;
if
(
port
=
=
=
-
1
)
{
if
(
[
"
resource
"
"
chrome
"
]
.
includes
(
uri
.
scheme
)
)
{
port
=
undefined
;
}
else
{
port
=
Services
.
io
.
getProtocolHandler
(
uri
.
scheme
)
.
defaultPort
;
}
}
return
filter
.
ports
.
some
(
(
filterPort
)
=
>
{
if
(
Array
.
isArray
(
filterPort
)
)
{
let
[
lower
upper
]
=
filterPort
;
return
port
>
=
lower
&
&
port
<
=
upper
;
}
return
port
=
=
=
filterPort
;
}
)
;
}
for
(
let
urlComponent
of
[
"
host
"
"
path
"
"
query
"
"
url
"
]
)
{
if
(
!
this
.
testMatchOnURLComponent
(
{
urlComponent
data
filter
}
)
)
{
return
false
;
}
}
if
(
filter
.
urlMatches
)
{
let
urlWithoutRef
=
uri
.
specIgnoringRef
;
if
(
!
urlWithoutRef
.
match
(
filter
.
urlMatches
)
)
{
return
false
;
}
}
if
(
filter
.
originAndPathMatches
)
{
let
urlWithoutQueryAndRef
=
uri
.
resolve
(
uriURL
.
filePath
)
;
if
(
!
urlWithoutQueryAndRef
|
|
!
urlWithoutQueryAndRef
.
match
(
filter
.
originAndPathMatches
)
)
{
return
false
;
}
}
return
true
;
}
testMatchOnURLComponent
(
{
urlComponent
:
key
data
filter
}
)
{
if
(
filter
[
{
key
}
Equals
]
!
=
null
)
{
if
(
data
[
key
]
!
=
=
filter
[
{
key
}
Equals
]
)
{
return
false
;
}
}
if
(
filter
[
{
key
}
Contains
]
)
{
let
value
=
(
key
=
=
"
host
"
?
"
.
"
:
"
"
)
+
data
[
key
]
;
if
(
!
data
[
key
]
|
|
!
value
.
includes
(
filter
[
{
key
}
Contains
]
)
)
{
return
false
;
}
}
if
(
filter
[
{
key
}
Prefix
]
)
{
if
(
!
data
[
key
]
|
|
!
data
[
key
]
.
startsWith
(
filter
[
{
key
}
Prefix
]
)
)
{
return
false
;
}
}
if
(
filter
[
{
key
}
Suffix
]
)
{
if
(
!
data
[
key
]
|
|
!
data
[
key
]
.
endsWith
(
filter
[
{
key
}
Suffix
]
)
)
{
return
false
;
}
}
return
true
;
}
serialize
(
)
{
return
this
.
filters
;
}
}
;
