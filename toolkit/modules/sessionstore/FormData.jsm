"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
FormData
"
]
;
function
isRestorationPage
(
url
)
{
return
url
=
=
"
about
:
sessionrestore
"
|
|
url
=
=
"
about
:
welcomeback
"
;
}
function
hasRestorationData
(
data
)
{
if
(
isRestorationPage
(
data
.
url
)
&
&
data
.
id
)
{
return
typeof
(
data
.
id
.
sessionData
)
=
=
"
object
"
;
}
return
false
;
}
function
getDocumentURI
(
doc
)
{
return
doc
.
documentURI
.
replace
(
/
#
.
*
/
"
"
)
;
}
var
FormData
=
Object
.
freeze
(
{
restore
(
frame
data
)
{
return
FormDataInternal
.
restore
(
frame
data
)
;
}
restoreTree
(
root
data
)
{
FormDataInternal
.
restoreTree
(
root
data
)
;
}
}
)
;
var
FormDataInternal
=
{
namespaceURIs
:
{
"
xhtml
"
:
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
xul
"
:
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
}
resolve
(
aDocument
aQuery
)
{
let
xptype
=
aDocument
.
defaultView
.
XPathResult
.
FIRST_ORDERED_NODE_TYPE
;
return
aDocument
.
evaluate
(
aQuery
aDocument
this
.
resolveNS
.
bind
(
this
)
xptype
null
)
.
singleNodeValue
;
}
resolveNS
(
aPrefix
)
{
return
this
.
namespaceURIs
[
aPrefix
]
|
|
null
;
}
get
restorableFormNodesXPath
(
)
{
let
formNodesXPath
=
"
/
/
textarea
|
/
/
xhtml
:
textarea
|
"
+
"
/
/
select
|
/
/
xhtml
:
select
|
"
+
"
/
/
input
|
/
/
xhtml
:
input
"
+
"
|
/
xul
:
window
[
id
=
'
config
'
]
/
/
xul
:
textbox
[
id
=
'
textbox
'
]
"
;
delete
this
.
restorableFormNodesXPath
;
return
(
this
.
restorableFormNodesXPath
=
formNodesXPath
)
;
}
restore
(
{
document
:
doc
}
data
)
{
if
(
!
data
.
url
)
{
return
true
;
}
if
(
data
.
url
!
=
getDocumentURI
(
doc
)
)
{
return
false
;
}
if
(
hasRestorationData
(
data
)
)
{
data
.
id
.
sessionData
=
JSON
.
stringify
(
data
.
id
.
sessionData
)
;
}
if
(
"
id
"
in
data
)
{
let
retrieveNode
=
id
=
>
doc
.
getElementById
(
id
)
;
this
.
restoreManyInputValues
(
data
.
id
retrieveNode
)
;
}
if
(
"
xpath
"
in
data
)
{
let
retrieveNode
=
xpath
=
>
this
.
resolve
(
doc
xpath
)
;
this
.
restoreManyInputValues
(
data
.
xpath
retrieveNode
)
;
}
if
(
"
innerHTML
"
in
data
)
{
if
(
doc
.
body
&
&
doc
.
designMode
=
=
"
on
"
)
{
doc
.
body
.
innerHTML
=
data
.
innerHTML
;
this
.
fireInputEvent
(
doc
.
body
)
;
}
}
return
true
;
}
restoreManyInputValues
(
data
retrieve
)
{
for
(
let
key
of
Object
.
keys
(
data
)
)
{
let
input
=
retrieve
(
key
)
;
if
(
input
)
{
this
.
restoreSingleInputValue
(
input
data
[
key
]
)
;
}
}
}
restoreSingleInputValue
(
aNode
aValue
)
{
let
fireEvent
=
false
;
if
(
typeof
aValue
=
=
"
string
"
&
&
aNode
.
type
!
=
"
file
"
)
{
if
(
aNode
.
value
=
=
aValue
)
{
return
;
}
aNode
.
value
=
aValue
;
fireEvent
=
true
;
}
else
if
(
typeof
aValue
=
=
"
boolean
"
)
{
if
(
aNode
.
checked
=
=
aValue
)
{
return
;
}
aNode
.
checked
=
aValue
;
fireEvent
=
true
;
}
else
if
(
aValue
&
&
aValue
.
selectedIndex
>
=
0
&
&
aValue
.
value
)
{
if
(
aNode
.
options
[
aNode
.
selectedIndex
]
.
value
=
=
aValue
.
value
)
{
return
;
}
for
(
let
i
=
0
;
i
<
aNode
.
options
.
length
;
i
+
+
)
{
if
(
aNode
.
options
[
i
]
.
value
=
=
aValue
.
value
)
{
aNode
.
selectedIndex
=
i
;
fireEvent
=
true
;
break
;
}
}
}
else
if
(
aValue
&
&
aValue
.
fileList
&
&
aValue
.
type
=
=
"
file
"
&
&
aNode
.
type
=
=
"
file
"
)
{
try
{
aNode
.
mozSetFileNameArray
(
aValue
.
fileList
aValue
.
fileList
.
length
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
mozSetFileNameArray
:
"
+
e
)
;
}
fireEvent
=
true
;
}
else
if
(
Array
.
isArray
(
aValue
)
&
&
aNode
.
options
)
{
Array
.
forEach
(
aNode
.
options
function
(
opt
index
)
{
opt
.
selected
=
aValue
.
indexOf
(
opt
.
value
)
>
-
1
;
if
(
!
opt
.
defaultSelected
)
{
fireEvent
=
true
;
}
}
)
;
}
if
(
fireEvent
)
{
this
.
fireInputEvent
(
aNode
)
;
}
}
fireInputEvent
(
node
)
{
let
event
=
node
.
isInputEventTarget
?
new
node
.
ownerGlobal
.
InputEvent
(
"
input
"
{
bubbles
:
true
inputType
:
"
"
}
)
:
new
node
.
ownerGlobal
.
Event
(
"
input
"
{
bubbles
:
true
}
)
;
node
.
dispatchEvent
(
event
)
;
}
restoreTree
(
root
data
)
{
if
(
this
.
restore
(
root
data
)
=
=
=
false
)
{
return
;
}
if
(
!
data
.
hasOwnProperty
(
"
children
"
)
)
{
return
;
}
let
frames
=
root
.
frames
;
for
(
let
index
of
Object
.
keys
(
data
.
children
)
)
{
if
(
index
<
frames
.
length
)
{
this
.
restoreTree
(
frames
[
index
]
data
.
children
[
index
]
)
;
}
}
}
}
;
