"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
FormData
"
]
;
const
Cu
=
Components
.
utils
;
const
Ci
=
Components
.
interfaces
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
function
isRestorationPage
(
url
)
{
return
url
=
=
"
about
:
sessionrestore
"
|
|
url
=
=
"
about
:
welcomeback
"
;
}
function
hasRestorationData
(
data
)
{
if
(
isRestorationPage
(
data
.
url
)
&
&
data
.
id
)
{
return
typeof
(
data
.
id
.
sessionData
)
=
=
"
object
"
;
}
return
false
;
}
function
getDocumentURI
(
doc
)
{
return
doc
.
documentURI
.
replace
(
/
#
.
*
/
"
"
)
;
}
function
isValidCCNumber
(
value
)
{
let
ccNumber
=
value
.
replace
(
/
[
-
\
s
]
+
/
g
"
"
)
;
if
(
/
[
^
0
-
9
]
/
.
test
(
ccNumber
)
)
{
return
false
;
}
let
length
=
ccNumber
.
length
;
if
(
length
!
=
9
&
&
length
!
=
15
&
&
length
!
=
16
)
{
return
false
;
}
let
total
=
0
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
let
currentChar
=
ccNumber
.
charAt
(
length
-
i
-
1
)
;
let
currentDigit
=
parseInt
(
currentChar
10
)
;
if
(
i
%
2
)
{
total
+
=
currentDigit
*
2
;
if
(
currentDigit
>
4
)
{
total
-
=
9
;
}
}
else
{
total
+
=
currentDigit
;
}
}
return
total
%
10
=
=
0
;
}
const
IGNORE_ATTRIBUTES
=
[
[
"
type
"
new
Set
(
[
"
password
"
"
hidden
"
"
button
"
"
image
"
"
submit
"
"
reset
"
]
)
]
[
"
autocomplete
"
new
Set
(
[
"
off
"
]
)
]
]
;
function
shouldIgnoreNode
(
node
)
{
for
(
let
i
=
0
;
i
<
IGNORE_ATTRIBUTES
.
length
;
+
+
i
)
{
let
[
attrName
attrValues
]
=
IGNORE_ATTRIBUTES
[
i
]
;
if
(
node
.
hasAttribute
(
attrName
)
&
&
attrValues
.
has
(
node
.
getAttribute
(
attrName
)
.
toLowerCase
(
)
)
)
{
return
true
;
}
}
return
false
;
}
this
.
FormData
=
Object
.
freeze
(
{
collect
(
frame
)
{
return
FormDataInternal
.
collect
(
frame
)
;
}
restore
(
frame
data
)
{
return
FormDataInternal
.
restore
(
frame
data
)
;
}
restoreTree
(
root
data
)
{
FormDataInternal
.
restoreTree
(
root
data
)
;
}
}
)
;
var
FormDataInternal
=
{
namespaceURIs
:
{
"
xhtml
"
:
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
xul
"
:
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
}
resolve
(
aDocument
aQuery
)
{
let
xptype
=
Components
.
interfaces
.
nsIDOMXPathResult
.
FIRST_ORDERED_NODE_TYPE
;
return
aDocument
.
evaluate
(
aQuery
aDocument
this
.
resolveNS
.
bind
(
this
)
xptype
null
)
.
singleNodeValue
;
}
resolveNS
(
aPrefix
)
{
return
this
.
namespaceURIs
[
aPrefix
]
|
|
null
;
}
get
restorableFormNodesXPath
(
)
{
let
formNodesXPath
=
"
/
/
textarea
|
/
/
xhtml
:
textarea
|
"
+
"
/
/
select
|
/
/
xhtml
:
select
|
"
+
"
/
/
input
|
/
/
xhtml
:
input
"
+
"
|
/
xul
:
window
[
id
=
'
config
'
]
/
/
xul
:
textbox
[
id
=
'
textbox
'
]
"
;
delete
this
.
restorableFormNodesXPath
;
return
(
this
.
restorableFormNodesXPath
=
formNodesXPath
)
;
}
collect
(
{
document
:
doc
}
)
{
let
formNodes
=
doc
.
evaluate
(
this
.
restorableFormNodesXPath
doc
this
.
resolveNS
.
bind
(
this
)
Ci
.
nsIDOMXPathResult
.
UNORDERED_NODE_ITERATOR_TYPE
null
)
;
let
node
;
let
ret
=
{
}
;
const
MAX_TRAVERSED_XPATHS
=
100
;
let
generatedCount
=
0
;
while
(
(
node
=
formNodes
.
iterateNext
(
)
)
)
{
if
(
shouldIgnoreNode
(
node
)
)
{
continue
;
}
let
hasDefaultValue
=
true
;
let
value
;
if
(
!
node
.
id
&
&
generatedCount
>
MAX_TRAVERSED_XPATHS
)
{
continue
;
}
if
(
node
instanceof
Ci
.
nsIDOMHTMLInputElement
&
&
isValidCCNumber
(
node
.
value
)
)
{
continue
;
}
if
(
node
instanceof
Ci
.
nsIDOMHTMLInputElement
|
|
node
instanceof
Ci
.
nsIDOMHTMLTextAreaElement
|
|
node
instanceof
Ci
.
nsIDOMXULTextBoxElement
)
{
switch
(
node
.
type
)
{
case
"
checkbox
"
:
case
"
radio
"
:
value
=
node
.
checked
;
hasDefaultValue
=
value
=
=
node
.
defaultChecked
;
break
;
case
"
file
"
:
value
=
{
type
:
"
file
"
fileList
:
node
.
mozGetFileNameArray
(
)
}
;
hasDefaultValue
=
!
value
.
fileList
.
length
;
break
;
default
:
value
=
node
.
value
;
hasDefaultValue
=
value
=
=
node
.
defaultValue
;
break
;
}
}
else
if
(
!
node
.
multiple
)
{
hasDefaultValue
=
false
;
value
=
{
selectedIndex
:
node
.
selectedIndex
value
:
node
.
value
}
;
}
else
{
let
options
=
Array
.
map
(
node
.
options
opt
=
>
{
hasDefaultValue
=
hasDefaultValue
&
&
(
opt
.
selected
=
=
opt
.
defaultSelected
)
;
return
opt
.
selected
?
opt
.
value
:
-
1
;
}
)
;
value
=
options
.
filter
(
ix
=
>
ix
>
-
1
)
;
}
if
(
hasDefaultValue
)
{
continue
;
}
if
(
node
.
id
)
{
ret
.
id
=
ret
.
id
|
|
{
}
;
ret
.
id
[
node
.
id
]
=
value
;
}
else
{
generatedCount
+
+
;
ret
.
xpath
=
ret
.
xpath
|
|
{
}
;
ret
.
xpath
[
node
.
generateXPath
(
)
]
=
value
;
}
}
if
(
(
doc
.
designMode
|
|
"
"
)
=
=
"
on
"
&
&
doc
.
body
)
{
ret
.
innerHTML
=
doc
.
body
.
innerHTML
;
}
if
(
Object
.
keys
(
ret
)
.
length
=
=
=
0
)
{
return
null
;
}
ret
.
url
=
getDocumentURI
(
doc
)
;
if
(
isRestorationPage
(
ret
.
url
)
)
{
ret
.
id
.
sessionData
=
JSON
.
parse
(
ret
.
id
.
sessionData
)
;
}
return
ret
;
}
restore
(
{
document
:
doc
}
data
)
{
if
(
!
data
.
url
)
{
return
;
}
if
(
data
.
url
!
=
getDocumentURI
(
doc
)
)
{
return
false
;
}
if
(
hasRestorationData
(
data
)
)
{
data
.
id
.
sessionData
=
JSON
.
stringify
(
data
.
id
.
sessionData
)
;
}
if
(
"
id
"
in
data
)
{
let
retrieveNode
=
id
=
>
doc
.
getElementById
(
id
)
;
this
.
restoreManyInputValues
(
data
.
id
retrieveNode
)
;
}
if
(
"
xpath
"
in
data
)
{
let
retrieveNode
=
xpath
=
>
this
.
resolve
(
doc
xpath
)
;
this
.
restoreManyInputValues
(
data
.
xpath
retrieveNode
)
;
}
if
(
"
innerHTML
"
in
data
)
{
if
(
doc
.
body
&
&
doc
.
designMode
=
=
"
on
"
)
{
doc
.
body
.
innerHTML
=
data
.
innerHTML
;
this
.
fireInputEvent
(
doc
.
body
)
;
}
}
}
restoreManyInputValues
(
data
retrieve
)
{
for
(
let
key
of
Object
.
keys
(
data
)
)
{
let
input
=
retrieve
(
key
)
;
if
(
input
)
{
this
.
restoreSingleInputValue
(
input
data
[
key
]
)
;
}
}
}
restoreSingleInputValue
(
aNode
aValue
)
{
let
fireEvent
=
false
;
if
(
typeof
aValue
=
=
"
string
"
&
&
aNode
.
type
!
=
"
file
"
)
{
if
(
aNode
.
value
=
=
aValue
)
{
return
;
}
aNode
.
value
=
aValue
;
fireEvent
=
true
;
}
else
if
(
typeof
aValue
=
=
"
boolean
"
)
{
if
(
aNode
.
checked
=
=
aValue
)
{
return
;
}
aNode
.
checked
=
aValue
;
fireEvent
=
true
;
}
else
if
(
aValue
&
&
aValue
.
selectedIndex
>
=
0
&
&
aValue
.
value
)
{
if
(
aNode
.
options
[
aNode
.
selectedIndex
]
.
value
=
=
aValue
.
value
)
{
return
;
}
for
(
let
i
=
0
;
i
<
aNode
.
options
.
length
;
i
+
+
)
{
if
(
aNode
.
options
[
i
]
.
value
=
=
aValue
.
value
)
{
aNode
.
selectedIndex
=
i
;
fireEvent
=
true
;
break
;
}
}
}
else
if
(
aValue
&
&
aValue
.
fileList
&
&
aValue
.
type
=
=
"
file
"
&
&
aNode
.
type
=
=
"
file
"
)
{
try
{
aNode
.
mozSetFileNameArray
(
aValue
.
fileList
aValue
.
fileList
.
length
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
mozSetFileNameArray
:
"
+
e
)
;
}
fireEvent
=
true
;
}
else
if
(
Array
.
isArray
(
aValue
)
&
&
aNode
.
options
)
{
Array
.
forEach
(
aNode
.
options
function
(
opt
index
)
{
opt
.
selected
=
aValue
.
indexOf
(
opt
.
value
)
>
-
1
;
if
(
!
opt
.
defaultSelected
)
{
fireEvent
=
true
;
}
}
)
;
}
if
(
fireEvent
)
{
this
.
fireInputEvent
(
aNode
)
;
}
}
fireInputEvent
(
node
)
{
let
doc
=
node
.
ownerDocument
;
let
event
=
doc
.
createEvent
(
"
UIEvents
"
)
;
event
.
initUIEvent
(
"
input
"
true
true
doc
.
defaultView
0
)
;
node
.
dispatchEvent
(
event
)
;
}
restoreTree
(
root
data
)
{
if
(
this
.
restore
(
root
data
)
=
=
=
false
)
{
return
;
}
if
(
!
data
.
hasOwnProperty
(
"
children
"
)
)
{
return
;
}
let
frames
=
root
.
frames
;
for
(
let
index
of
Object
.
keys
(
data
.
children
)
)
{
if
(
index
<
frames
.
length
)
{
this
.
restoreTree
(
frames
[
index
]
data
.
children
[
index
]
)
;
}
}
}
}
;
