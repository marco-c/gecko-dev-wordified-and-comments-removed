"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
E10SUtils
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
useSeparateFileUriProcess
"
"
browser
.
tabs
.
remote
.
separateFileUriProcess
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
allowLinkedWebInFileUriProcess
"
"
browser
.
tabs
.
remote
.
allowLinkedWebInFileUriProcess
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
useSeparatePrivilegedContentProcess
"
"
browser
.
tabs
.
remote
.
separatePrivilegedContentProcess
"
false
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Utils
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
Utils
.
jsm
"
)
;
function
getAboutModule
(
aURL
)
{
let
moduleName
=
aURL
.
pathQueryRef
.
replace
(
/
[
#
?
]
.
*
/
"
"
)
.
toLowerCase
(
)
;
let
contract
=
"
mozilla
.
org
/
network
/
protocol
/
about
;
1
?
what
=
"
+
moduleName
;
try
{
return
Cc
[
contract
]
.
getService
(
Ci
.
nsIAboutModule
)
;
}
catch
(
e
)
{
return
null
;
}
}
const
NOT_REMOTE
=
null
;
const
WEB_REMOTE_TYPE
=
"
web
"
;
const
FILE_REMOTE_TYPE
=
"
file
"
;
const
EXTENSION_REMOTE_TYPE
=
"
extension
"
;
const
PRIVILEGED_REMOTE_TYPE
=
"
privileged
"
;
const
LARGE_ALLOCATION_REMOTE_TYPE
=
"
webLargeAllocation
"
;
const
DEFAULT_REMOTE_TYPE
=
WEB_REMOTE_TYPE
;
const
ACTIVITY_STREAM_PAGES
=
new
Set
(
[
"
home
"
"
newtab
"
"
welcome
"
]
)
;
function
validatedWebRemoteType
(
aPreferredRemoteType
aTargetUri
aCurrentUri
)
{
const
sm
=
Services
.
scriptSecurityManager
;
if
(
sm
.
inFileURIWhitelist
(
aTargetUri
)
)
{
return
FILE_REMOTE_TYPE
;
}
if
(
!
aPreferredRemoteType
)
{
return
WEB_REMOTE_TYPE
;
}
if
(
aPreferredRemoteType
.
startsWith
(
WEB_REMOTE_TYPE
)
)
{
return
aPreferredRemoteType
;
}
if
(
allowLinkedWebInFileUriProcess
&
&
aPreferredRemoteType
=
=
FILE_REMOTE_TYPE
)
{
if
(
aCurrentUri
)
{
try
{
sm
.
checkSameOriginURI
(
aCurrentUri
aTargetUri
false
)
;
return
FILE_REMOTE_TYPE
;
}
catch
(
e
)
{
return
WEB_REMOTE_TYPE
;
}
}
return
FILE_REMOTE_TYPE
;
}
return
WEB_REMOTE_TYPE
;
}
var
E10SUtils
=
{
DEFAULT_REMOTE_TYPE
NOT_REMOTE
WEB_REMOTE_TYPE
FILE_REMOTE_TYPE
EXTENSION_REMOTE_TYPE
PRIVILEGED_REMOTE_TYPE
LARGE_ALLOCATION_REMOTE_TYPE
canLoadURIInProcess
(
aURL
aProcess
)
{
let
remoteType
=
aProcess
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
?
DEFAULT_REMOTE_TYPE
:
NOT_REMOTE
;
return
remoteType
=
=
this
.
getRemoteTypeForURI
(
aURL
true
remoteType
)
;
}
getRemoteTypeForURI
(
aURL
aMultiProcess
aPreferredRemoteType
=
DEFAULT_REMOTE_TYPE
aCurrentUri
)
{
if
(
!
aMultiProcess
)
{
return
NOT_REMOTE
;
}
if
(
!
aURL
)
{
aURL
=
"
about
:
blank
"
;
}
let
uri
;
try
{
uri
=
Services
.
uriFixup
.
createFixupURI
(
aURL
Ci
.
nsIURIFixup
.
FIXUP_FLAG_NONE
)
;
}
catch
(
e
)
{
return
DEFAULT_REMOTE_TYPE
;
}
return
this
.
getRemoteTypeForURIObject
(
uri
aMultiProcess
aPreferredRemoteType
aCurrentUri
)
;
}
getRemoteTypeForURIObject
(
aURI
aMultiProcess
aPreferredRemoteType
=
DEFAULT_REMOTE_TYPE
aCurrentUri
)
{
if
(
!
aMultiProcess
)
{
return
NOT_REMOTE
;
}
switch
(
aURI
.
scheme
)
{
case
"
javascript
"
:
return
aPreferredRemoteType
;
case
"
data
"
:
case
"
blob
"
:
return
aPreferredRemoteType
=
=
NOT_REMOTE
?
DEFAULT_REMOTE_TYPE
:
aPreferredRemoteType
;
case
"
file
"
:
return
useSeparateFileUriProcess
?
FILE_REMOTE_TYPE
:
DEFAULT_REMOTE_TYPE
;
case
"
about
"
:
let
module
=
getAboutModule
(
aURI
)
;
if
(
!
module
)
{
return
aPreferredRemoteType
;
}
let
flags
=
module
.
getURIFlags
(
aURI
)
;
if
(
flags
&
Ci
.
nsIAboutModule
.
URI_MUST_LOAD_IN_CHILD
)
{
if
(
useSeparatePrivilegedContentProcess
&
&
ACTIVITY_STREAM_PAGES
.
has
(
aURI
.
filePath
)
)
{
return
PRIVILEGED_REMOTE_TYPE
;
}
return
DEFAULT_REMOTE_TYPE
;
}
if
(
flags
&
Ci
.
nsIAboutModule
.
URI_CAN_LOAD_IN_CHILD
)
{
return
aPreferredRemoteType
;
}
return
NOT_REMOTE
;
case
"
chrome
"
:
let
chromeReg
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIXULChromeRegistry
)
;
if
(
chromeReg
.
mustLoadURLRemotely
(
aURI
)
)
{
return
DEFAULT_REMOTE_TYPE
;
}
if
(
chromeReg
.
canLoadURLRemotely
(
aURI
)
&
&
aPreferredRemoteType
!
=
NOT_REMOTE
)
{
return
DEFAULT_REMOTE_TYPE
;
}
return
NOT_REMOTE
;
case
"
moz
-
extension
"
:
return
WebExtensionPolicy
.
useRemoteWebExtensions
?
EXTENSION_REMOTE_TYPE
:
NOT_REMOTE
;
default
:
if
(
aURI
instanceof
Ci
.
nsINestedURI
)
{
let
innerURI
=
aURI
.
QueryInterface
(
Ci
.
nsINestedURI
)
.
innerURI
;
return
this
.
getRemoteTypeForURIObject
(
innerURI
aMultiProcess
aPreferredRemoteType
aCurrentUri
)
;
}
return
validatedWebRemoteType
(
aPreferredRemoteType
aURI
aCurrentUri
)
;
}
}
shouldLoadURIInBrowser
(
browser
uri
multiProcess
=
true
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
)
{
let
currentRemoteType
=
browser
.
remoteType
;
let
requiredRemoteType
;
let
uriObject
;
try
{
let
fixupFlags
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_NONE
;
if
(
flags
&
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
)
{
fixupFlags
|
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
;
}
if
(
flags
&
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FIXUP_SCHEME_TYPOS
)
{
fixupFlags
|
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
;
}
uriObject
=
Services
.
uriFixup
.
createFixupURI
(
uri
fixupFlags
)
;
requiredRemoteType
=
this
.
getRemoteTypeForURIObject
(
uriObject
multiProcess
currentRemoteType
browser
.
currentURI
)
;
}
catch
(
e
)
{
requiredRemoteType
=
multiProcess
?
DEFAULT_REMOTE_TYPE
:
NOT_REMOTE
;
}
let
mustChangeProcess
=
requiredRemoteType
!
=
currentRemoteType
;
let
newFrameloader
=
false
;
if
(
browser
.
getAttribute
(
"
preloadedState
"
)
=
=
=
"
consumed
"
&
&
uri
!
=
"
about
:
newtab
"
)
{
mustChangeProcess
=
true
;
newFrameloader
=
true
;
}
return
{
uriObject
requiredRemoteType
mustChangeProcess
newFrameloader
}
;
}
shouldLoadURIInThisProcess
(
aURI
)
{
let
remoteType
=
Services
.
appinfo
.
remoteType
;
return
remoteType
=
=
this
.
getRemoteTypeForURIObject
(
aURI
true
remoteType
)
;
}
shouldLoadURI
(
aDocShell
aURI
aReferrer
aHasPostData
)
{
if
(
aDocShell
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
sameTypeParent
)
return
true
;
if
(
!
aHasPostData
&
&
Services
.
appinfo
.
remoteType
=
=
LARGE_ALLOCATION_REMOTE_TYPE
&
&
!
aDocShell
.
awaitingLargeAlloc
&
&
aDocShell
.
isOnlyToplevelInTabGroup
)
{
return
false
;
}
let
webNav
=
aDocShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
let
sessionHistory
=
webNav
.
sessionHistory
;
let
requestedIndex
=
sessionHistory
.
legacySHistory
.
requestedIndex
;
if
(
requestedIndex
>
=
0
)
{
if
(
sessionHistory
.
legacySHistory
.
getEntryAtIndex
(
requestedIndex
false
)
.
loadedInThisProcess
)
{
return
true
;
}
let
remoteType
=
Services
.
appinfo
.
remoteType
;
return
remoteType
=
=
this
.
getRemoteTypeForURIObject
(
aURI
true
remoteType
webNav
.
currentURI
)
;
}
if
(
!
aHasPostData
&
&
Services
.
appinfo
.
remoteType
=
=
WEB_REMOTE_TYPE
&
&
sessionHistory
.
count
=
=
1
&
&
webNav
.
currentURI
.
spec
=
=
"
about
:
newtab
"
)
{
return
false
;
}
return
this
.
shouldLoadURIInThisProcess
(
aURI
)
;
}
redirectLoad
(
aDocShell
aURI
aReferrer
aTriggeringPrincipal
aFreshProcess
aFlags
)
{
let
messageManager
=
aDocShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
let
sessionHistory
=
aDocShell
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
;
messageManager
.
sendAsyncMessage
(
"
Browser
:
LoadURI
"
{
loadOptions
:
{
uri
:
aURI
.
spec
flags
:
aFlags
|
|
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
referrer
:
aReferrer
?
aReferrer
.
spec
:
null
triggeringPrincipal
:
aTriggeringPrincipal
?
Utils
.
serializePrincipal
(
aTriggeringPrincipal
)
:
null
reloadInFreshProcess
:
!
!
aFreshProcess
}
historyIndex
:
sessionHistory
.
legacySHistory
.
requestedIndex
}
)
;
return
false
;
}
wrapHandlingUserInput
(
aWindow
aIsHandling
aCallback
)
{
var
handlingUserInput
;
try
{
handlingUserInput
=
aWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
setHandlingUserInput
(
aIsHandling
)
;
aCallback
(
)
;
}
finally
{
handlingUserInput
.
destruct
(
)
;
}
}
}
;
