"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
E10SUtils
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
useSeparateFileUriProcess
"
"
browser
.
tabs
.
remote
.
separateFileUriProcess
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
useSeparateDataUriProcess
"
"
browser
.
tabs
.
remote
.
dataUriInDefaultWebProcess
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
useSeparatePrivilegedAboutContentProcess
"
"
browser
.
tabs
.
remote
.
separatePrivilegedContentProcess
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
separatePrivilegedMozillaWebContentProcess
"
"
browser
.
tabs
.
remote
.
separatePrivilegedMozillaWebContentProcess
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
separatedMozillaDomains
"
"
browser
.
tabs
.
remote
.
separatedMozillaDomains
"
false
false
val
=
>
val
.
split
(
"
"
)
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
useCrossOriginOpenerPolicy
"
"
browser
.
tabs
.
remote
.
useCrossOriginOpenerPolicy
"
false
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
serializationHelper
"
"
mozilla
.
org
/
network
/
serialization
-
helper
;
1
"
"
nsISerializationHelper
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
extProtService
"
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
"
nsIExternalProtocolService
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
sessionHistoryInParent
"
"
fission
.
sessionHistoryInParent
"
false
)
;
function
getAboutModule
(
aURL
)
{
let
moduleName
=
aURL
.
pathQueryRef
.
replace
(
/
[
#
?
]
.
*
/
"
"
)
.
toLowerCase
(
)
;
let
contract
=
"
mozilla
.
org
/
network
/
protocol
/
about
;
1
?
what
=
"
+
moduleName
;
try
{
return
Cc
[
contract
]
.
getService
(
Ci
.
nsIAboutModule
)
;
}
catch
(
e
)
{
return
null
;
}
}
const
NOT_REMOTE
=
null
;
const
WEB_REMOTE_TYPE
=
"
web
"
;
const
FISSION_WEB_REMOTE_TYPE
=
"
webIsolated
"
;
const
WEB_REMOTE_COOP_COEP_TYPE_PREFIX
=
"
webCOOP
+
COEP
=
"
;
const
FILE_REMOTE_TYPE
=
"
file
"
;
const
EXTENSION_REMOTE_TYPE
=
"
extension
"
;
const
PRIVILEGEDABOUT_REMOTE_TYPE
=
"
privilegedabout
"
;
const
PRIVILEGEDMOZILLA_REMOTE_TYPE
=
"
privilegedmozilla
"
;
const
LARGE_ALLOCATION_REMOTE_TYPE
=
"
webLargeAllocation
"
;
const
DEFAULT_REMOTE_TYPE
=
WEB_REMOTE_TYPE
;
const
kSafeSchemes
=
[
"
bitcoin
"
"
geo
"
"
im
"
"
irc
"
"
ircs
"
"
magnet
"
"
mailto
"
"
mms
"
"
news
"
"
nntp
"
"
openpgp4fpr
"
"
sip
"
"
sms
"
"
smsto
"
"
ssh
"
"
tel
"
"
urn
"
"
webcal
"
"
wtai
"
"
xmpp
"
]
;
const
kDocumentChannelDeniedSchemes
=
[
"
javascript
"
]
;
const
kDocumentChannelDeniedURIs
=
[
"
about
:
crashcontent
"
"
about
:
printpreview
"
]
;
function
documentChannelPermittedForURI
(
aURI
)
{
return
(
!
kDocumentChannelDeniedSchemes
.
includes
(
aURI
.
scheme
)
&
&
!
kDocumentChannelDeniedURIs
.
includes
(
aURI
.
spec
)
)
;
}
function
canProcessSwitchWithDocumentChannel
(
aURI
aRemoteSubframes
aDesiredRemoteType
aBrowsingContext
)
{
return
documentChannelPermittedForURI
(
aURI
)
;
}
function
hasPotentiallyWebHandledScheme
(
{
scheme
}
)
{
if
(
kSafeSchemes
.
includes
(
scheme
)
)
{
return
true
;
}
if
(
!
scheme
.
startsWith
(
"
web
+
"
)
|
|
scheme
.
length
<
5
)
{
return
false
;
}
return
/
^
[
a
-
z
]
+
/
.
test
(
scheme
.
substr
(
"
web
+
"
.
length
)
)
;
}
function
validatedWebRemoteType
(
aPreferredRemoteType
aTargetUri
aCurrentUri
aResultPrincipal
aRemoteSubframes
aIsWorker
=
false
)
{
if
(
separatePrivilegedMozillaWebContentProcess
&
&
aTargetUri
.
asciiHost
&
&
aTargetUri
.
scheme
=
=
"
https
"
&
&
separatedMozillaDomains
.
some
(
function
(
val
)
{
return
(
aTargetUri
.
asciiHost
=
=
val
|
|
aTargetUri
.
asciiHost
.
endsWith
(
"
.
"
+
val
)
)
;
}
)
)
{
return
PRIVILEGEDMOZILLA_REMOTE_TYPE
;
}
if
(
aRemoteSubframes
&
&
hasPotentiallyWebHandledScheme
(
aTargetUri
)
)
{
if
(
aIsWorker
)
{
throw
Components
.
Exception
(
"
Unexpected
remote
worker
with
a
web
handled
scheme
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
if
(
Services
.
appinfo
.
processType
!
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
&
&
Services
.
appinfo
.
remoteType
.
startsWith
(
FISSION_WEB_REMOTE_TYPE
+
"
=
"
)
)
{
return
Services
.
appinfo
.
remoteType
;
}
let
handlerInfo
=
extProtService
.
getProtocolHandlerInfo
(
aTargetUri
.
scheme
)
;
try
{
if
(
!
handlerInfo
.
alwaysAskBeforeHandling
)
{
let
app
=
handlerInfo
.
preferredApplicationHandler
;
app
.
QueryInterface
(
Ci
.
nsIWebHandlerApp
)
;
let
uriStr
=
app
.
uriTemplate
.
replace
(
/
%
s
/
aTargetUri
.
spec
)
;
aTargetUri
=
Services
.
io
.
newURI
(
uriStr
)
;
}
}
catch
(
ex
)
{
}
}
const
sm
=
Services
.
scriptSecurityManager
;
if
(
!
aIsWorker
&
&
sm
.
inFileURIAllowlist
(
aTargetUri
)
)
{
return
FILE_REMOTE_TYPE
;
}
if
(
aRemoteSubframes
)
{
let
originAttributes
=
{
}
;
let
targetPrincipal
;
if
(
aResultPrincipal
)
{
targetPrincipal
=
sm
.
principalWithOA
(
aResultPrincipal
originAttributes
)
;
}
else
{
targetPrincipal
=
sm
.
createContentPrincipal
(
aTargetUri
originAttributes
)
;
}
if
(
aPreferredRemoteType
&
&
aPreferredRemoteType
=
=
{
WEB_REMOTE_COOP_COEP_TYPE_PREFIX
}
{
targetPrincipal
.
siteOrigin
}
)
{
return
aPreferredRemoteType
;
}
return
{
FISSION_WEB_REMOTE_TYPE
}
=
{
targetPrincipal
.
siteOrigin
}
;
}
if
(
!
aPreferredRemoteType
)
{
return
WEB_REMOTE_TYPE
;
}
if
(
aPreferredRemoteType
.
startsWith
(
WEB_REMOTE_TYPE
)
)
{
return
aPreferredRemoteType
;
}
return
WEB_REMOTE_TYPE
;
}
const
SYSTEM_WORKERS_REMOTE_TYPES_ALLOWED
=
[
NOT_REMOTE
PRIVILEGEDABOUT_REMOTE_TYPE
]
;
var
E10SUtils
=
{
DEFAULT_REMOTE_TYPE
NOT_REMOTE
WEB_REMOTE_TYPE
WEB_REMOTE_COOP_COEP_TYPE_PREFIX
FILE_REMOTE_TYPE
EXTENSION_REMOTE_TYPE
PRIVILEGEDABOUT_REMOTE_TYPE
PRIVILEGEDMOZILLA_REMOTE_TYPE
LARGE_ALLOCATION_REMOTE_TYPE
FISSION_WEB_REMOTE_TYPE
useCrossOriginOpenerPolicy
(
)
{
return
useCrossOriginOpenerPolicy
;
}
_log
:
null
_uriStr
:
function
uriStr
(
aUri
)
{
return
aUri
?
aUri
.
spec
:
"
undefined
"
;
}
log
:
function
log
(
)
{
if
(
!
this
.
_log
)
{
this
.
_log
=
console
.
createInstance
(
{
prefix
:
"
ProcessSwitch
"
maxLogLevel
:
"
Error
"
}
)
;
this
.
_log
.
debug
(
"
Setup
logger
"
)
;
}
return
this
.
_log
;
}
serializeCSP
(
csp
)
{
let
serializedCSP
=
null
;
try
{
if
(
csp
)
{
serializedCSP
=
serializationHelper
.
serializeToString
(
csp
)
;
}
}
catch
(
e
)
{
this
.
log
(
)
.
error
(
Failed
to
serialize
csp
'
{
csp
}
'
{
e
}
)
;
}
return
serializedCSP
;
}
deserializeCSP
(
csp_b64
)
{
if
(
!
csp_b64
)
{
return
null
;
}
try
{
let
csp
=
serializationHelper
.
deserializeObject
(
csp_b64
)
;
csp
.
QueryInterface
(
Ci
.
nsIContentSecurityPolicy
)
;
return
csp
;
}
catch
(
e
)
{
this
.
log
(
)
.
error
(
Failed
to
deserialize
csp_b64
'
{
csp_b64
}
'
{
e
}
)
;
}
return
null
;
}
canLoadURIInRemoteType
(
aURL
aRemoteSubframes
aRemoteType
=
DEFAULT_REMOTE_TYPE
)
{
return
(
aRemoteType
=
=
this
.
getRemoteTypeForURI
(
aURL
true
aRemoteSubframes
aRemoteType
)
)
;
}
getRemoteTypeForURI
(
aURL
aMultiProcess
aRemoteSubframes
aPreferredRemoteType
=
DEFAULT_REMOTE_TYPE
aCurrentUri
)
{
if
(
!
aMultiProcess
)
{
return
NOT_REMOTE
;
}
if
(
!
aURL
)
{
aURL
=
"
about
:
blank
"
;
}
let
uri
;
try
{
uri
=
Services
.
uriFixup
.
createFixupURI
(
aURL
Ci
.
nsIURIFixup
.
FIXUP_FLAG_NONE
)
;
}
catch
(
e
)
{
return
DEFAULT_REMOTE_TYPE
;
}
return
this
.
getRemoteTypeForURIObject
(
uri
aMultiProcess
aRemoteSubframes
aPreferredRemoteType
aCurrentUri
)
;
}
getRemoteTypeForURIObject
(
aURI
aMultiProcess
aRemoteSubframes
aPreferredRemoteType
=
DEFAULT_REMOTE_TYPE
aCurrentUri
=
null
aResultPrincipal
=
null
aIsSubframe
=
false
aIsWorker
=
false
)
{
if
(
!
aMultiProcess
)
{
return
NOT_REMOTE
;
}
switch
(
aURI
.
scheme
)
{
case
"
javascript
"
:
return
aPreferredRemoteType
;
case
"
data
"
:
case
"
blob
"
:
return
aPreferredRemoteType
=
=
NOT_REMOTE
?
DEFAULT_REMOTE_TYPE
:
aPreferredRemoteType
;
case
"
file
"
:
return
useSeparateFileUriProcess
?
FILE_REMOTE_TYPE
:
DEFAULT_REMOTE_TYPE
;
case
"
about
"
:
let
module
=
getAboutModule
(
aURI
)
;
if
(
!
module
)
{
return
aPreferredRemoteType
;
}
let
flags
=
module
.
getURIFlags
(
aURI
)
;
if
(
flags
&
Ci
.
nsIAboutModule
.
URI_MUST_LOAD_IN_EXTENSION_PROCESS
)
{
return
WebExtensionPolicy
.
useRemoteWebExtensions
?
EXTENSION_REMOTE_TYPE
:
NOT_REMOTE
;
}
if
(
flags
&
Ci
.
nsIAboutModule
.
URI_MUST_LOAD_IN_CHILD
)
{
if
(
flags
&
Ci
.
nsIAboutModule
.
URI_CAN_LOAD_IN_PRIVILEGEDABOUT_PROCESS
&
&
(
useSeparatePrivilegedAboutContentProcess
|
|
aURI
.
filePath
=
=
"
logins
"
|
|
aURI
.
filePath
=
=
"
welcome
"
)
)
{
return
PRIVILEGEDABOUT_REMOTE_TYPE
;
}
return
DEFAULT_REMOTE_TYPE
;
}
if
(
flags
&
Ci
.
nsIAboutModule
.
URI_CAN_LOAD_IN_CHILD
)
{
return
aPreferredRemoteType
;
}
return
NOT_REMOTE
;
case
"
chrome
"
:
let
chromeReg
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIXULChromeRegistry
)
;
if
(
chromeReg
.
mustLoadURLRemotely
(
aURI
)
)
{
return
DEFAULT_REMOTE_TYPE
;
}
if
(
chromeReg
.
canLoadURLRemotely
(
aURI
)
&
&
aPreferredRemoteType
!
=
NOT_REMOTE
)
{
return
DEFAULT_REMOTE_TYPE
;
}
return
NOT_REMOTE
;
case
"
moz
-
extension
"
:
if
(
WebExtensionPolicy
.
useRemoteWebExtensions
)
{
return
aIsSubframe
?
aPreferredRemoteType
:
EXTENSION_REMOTE_TYPE
;
}
return
NOT_REMOTE
;
default
:
if
(
aURI
.
scheme
.
startsWith
(
"
ext
+
"
)
)
{
if
(
aIsWorker
)
{
throw
Components
.
Exception
(
"
Unexpected
remote
worker
with
extension
handled
scheme
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
return
WebExtensionPolicy
.
useRemoteWebExtensions
?
EXTENSION_REMOTE_TYPE
:
NOT_REMOTE
;
}
if
(
aURI
instanceof
Ci
.
nsINestedURI
)
{
if
(
aIsWorker
)
{
throw
Components
.
Exception
(
"
Unexpected
worker
with
a
NestedURI
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
let
innerURI
=
aURI
.
QueryInterface
(
Ci
.
nsINestedURI
)
.
innerURI
;
return
this
.
getRemoteTypeForURIObject
(
innerURI
aMultiProcess
aRemoteSubframes
aPreferredRemoteType
aCurrentUri
aResultPrincipal
)
;
}
var
log
=
this
.
log
(
)
;
log
.
debug
(
"
validatedWebRemoteType
(
)
"
)
;
log
.
debug
(
aPreferredRemoteType
:
{
aPreferredRemoteType
}
)
;
log
.
debug
(
aTargetUri
:
{
this
.
_uriStr
(
aURI
)
}
)
;
log
.
debug
(
aCurrentUri
:
{
this
.
_uriStr
(
aCurrentUri
)
}
)
;
var
remoteType
=
validatedWebRemoteType
(
aPreferredRemoteType
aURI
aCurrentUri
aResultPrincipal
aRemoteSubframes
aIsWorker
)
;
log
.
debug
(
validatedWebRemoteType
(
)
returning
:
{
remoteType
}
)
;
return
remoteType
;
}
}
getRemoteTypeForPrincipal
(
aPrincipal
aOriginalURI
aMultiProcess
aRemoteSubframes
aPreferredRemoteType
=
DEFAULT_REMOTE_TYPE
aCurrentPrincipal
aIsSubframe
)
{
if
(
!
aMultiProcess
)
{
return
NOT_REMOTE
;
}
let
useOriginalURI
;
if
(
aOriginalURI
.
scheme
=
=
"
about
"
)
{
useOriginalURI
=
!
[
"
about
:
srcdoc
"
"
about
:
blank
"
]
.
includes
(
aOriginalURI
.
spec
)
;
}
else
{
useOriginalURI
=
aOriginalURI
.
scheme
=
=
"
chrome
"
;
}
if
(
!
useOriginalURI
)
{
if
(
aPrincipal
.
isSystemPrincipal
|
|
aPrincipal
.
isExpandedPrincipal
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
if
(
aPrincipal
.
isNullPrincipal
)
{
if
(
aOriginalURI
.
spec
=
=
"
about
:
blank
"
)
{
useOriginalURI
=
true
;
}
else
if
(
(
aRemoteSubframes
&
&
useSeparateDataUriProcess
)
|
|
aPreferredRemoteType
=
=
NOT_REMOTE
)
{
return
WEB_REMOTE_TYPE
;
}
return
aPreferredRemoteType
;
}
}
let
currentURI
=
aCurrentPrincipal
&
&
aCurrentPrincipal
.
isContentPrincipal
?
Services
.
io
.
newURI
(
aCurrentPrincipal
.
spec
)
:
null
;
return
E10SUtils
.
getRemoteTypeForURIObject
(
useOriginalURI
?
aOriginalURI
:
Services
.
io
.
newURI
(
aPrincipal
.
spec
)
aMultiProcess
aRemoteSubframes
aPreferredRemoteType
currentURI
aPrincipal
aIsSubframe
)
;
}
getRemoteTypeForWorkerPrincipal
(
aPrincipal
aWorkerType
aIsMultiProcess
aIsFission
aPreferredRemoteType
=
DEFAULT_REMOTE_TYPE
)
{
if
(
aPrincipal
.
isExpandedPrincipal
)
{
throw
new
Error
(
"
Unexpected
expanded
principal
worker
"
)
;
}
if
(
aWorkerType
=
=
=
Ci
.
nsIE10SUtils
.
REMOTE_WORKER_TYPE_SERVICE
&
&
!
aPrincipal
.
isContentPrincipal
)
{
throw
new
Error
(
"
Unexpected
system
or
null
principal
service
worker
"
)
;
}
if
(
!
aIsMultiProcess
)
{
return
NOT_REMOTE
;
}
if
(
aPreferredRemoteType
=
=
=
LARGE_ALLOCATION_REMOTE_TYPE
|
|
aPreferredRemoteType
?
.
startsWith
(
WEB_REMOTE_COOP_COEP_TYPE_PREFIX
)
)
{
aPreferredRemoteType
=
DEFAULT_REMOTE_TYPE
;
}
if
(
aPrincipal
.
isSystemPrincipal
&
&
SYSTEM_WORKERS_REMOTE_TYPES_ALLOWED
.
includes
(
aPreferredRemoteType
)
)
{
return
aPreferredRemoteType
;
}
if
(
aPrincipal
.
isNullPrincipal
)
{
return
aPreferredRemoteType
=
=
=
NOT_REMOTE
?
DEFAULT_REMOTE_TYPE
:
aPreferredRemoteType
;
}
if
(
aPrincipal
.
isContentPrincipal
)
{
return
E10SUtils
.
getRemoteTypeForURIObject
(
aPrincipal
.
URI
aIsMultiProcess
aIsFission
aPreferredRemoteType
null
aPrincipal
false
true
)
;
}
throw
new
Error
(
"
Failed
to
get
a
remoteType
for
a
non
content
principal
worker
"
)
;
}
makeInputStream
(
data
)
{
if
(
typeof
data
=
=
"
string
"
)
{
let
stream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsCString
)
;
stream
.
data
=
data
;
return
stream
;
}
let
stream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsCString
)
;
stream
.
data
=
data
.
content
;
if
(
data
.
headers
)
{
let
mimeStream
=
Cc
[
"
mozilla
.
org
/
network
/
mime
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIMIMEInputStream
)
;
mimeStream
.
setData
(
stream
)
;
for
(
let
[
name
value
]
of
data
.
headers
)
{
mimeStream
.
addHeader
(
name
value
)
;
}
return
mimeStream
;
}
return
stream
;
}
serializePrincipal
(
principal
)
{
let
serializedPrincipal
=
null
;
try
{
if
(
principal
)
{
serializedPrincipal
=
btoa
(
Services
.
scriptSecurityManager
.
principalToJSON
(
principal
)
)
;
}
}
catch
(
e
)
{
this
.
log
(
)
.
error
(
Failed
to
serialize
principal
'
{
principal
}
'
{
e
}
)
;
}
return
serializedPrincipal
;
}
deserializePrincipal
(
principal_b64
fallbackPrincipalCallback
=
null
)
{
if
(
!
principal_b64
)
{
if
(
!
fallbackPrincipalCallback
)
{
this
.
log
(
)
.
warn
(
"
No
principal
passed
to
deserializePrincipal
and
no
fallbackPrincipalCallback
"
)
;
return
null
;
}
return
fallbackPrincipalCallback
(
)
;
}
try
{
let
principal
;
let
tmpa
=
atob
(
principal_b64
)
;
if
(
tmpa
.
startsWith
(
"
{
"
)
)
{
principal
=
Services
.
scriptSecurityManager
.
JSONToPrincipal
(
tmpa
)
;
}
else
{
principal
=
serializationHelper
.
deserializeObject
(
principal_b64
)
;
}
principal
.
QueryInterface
(
Ci
.
nsIPrincipal
)
;
return
principal
;
}
catch
(
e
)
{
this
.
log
(
)
.
error
(
Failed
to
deserialize
principal_b64
'
{
principal_b64
}
'
{
e
}
)
;
}
if
(
!
fallbackPrincipalCallback
)
{
this
.
log
(
)
.
warn
(
"
No
principal
passed
to
deserializePrincipal
and
no
fallbackPrincipalCallback
"
)
;
return
null
;
}
return
fallbackPrincipalCallback
(
)
;
}
shouldLoadURIInBrowser
(
browser
uri
multiProcess
=
true
remoteSubframes
=
false
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
)
{
let
currentRemoteType
=
browser
.
remoteType
;
let
requiredRemoteType
;
let
uriObject
;
try
{
let
fixupFlags
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_NONE
;
if
(
flags
&
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
)
{
fixupFlags
|
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
;
}
if
(
flags
&
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FIXUP_SCHEME_TYPOS
)
{
fixupFlags
|
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
;
}
if
(
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
)
{
fixupFlags
|
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_PRIVATE_CONTEXT
;
}
uriObject
=
Services
.
uriFixup
.
createFixupURI
(
uri
fixupFlags
)
;
requiredRemoteType
=
this
.
getRemoteTypeForURIObject
(
uriObject
multiProcess
remoteSubframes
currentRemoteType
browser
.
currentURI
)
;
}
catch
(
e
)
{
requiredRemoteType
=
multiProcess
?
DEFAULT_REMOTE_TYPE
:
NOT_REMOTE
;
}
let
mustChangeProcess
=
requiredRemoteType
!
=
currentRemoteType
;
let
newFrameloader
=
false
;
if
(
browser
.
getAttribute
(
"
preloadedState
"
)
=
=
=
"
consumed
"
&
&
uri
!
=
"
about
:
newtab
"
)
{
mustChangeProcess
=
true
;
newFrameloader
=
true
;
}
if
(
uriObject
&
&
canProcessSwitchWithDocumentChannel
(
uriObject
remoteSubframes
requiredRemoteType
browser
.
browsingContext
)
)
{
mustChangeProcess
=
false
;
newFrameloader
=
false
;
}
return
{
uriObject
requiredRemoteType
mustChangeProcess
newFrameloader
}
;
}
shouldLoadURIInThisProcess
(
aURI
aRemoteSubframes
)
{
let
remoteType
=
Services
.
appinfo
.
remoteType
;
let
wantRemoteType
=
this
.
getRemoteTypeForURIObject
(
aURI
true
aRemoteSubframes
remoteType
)
;
this
.
log
(
)
.
info
(
shouldLoadURIInThisProcess
:
have
{
remoteType
}
want
{
wantRemoteType
}
)
;
if
(
canProcessSwitchWithDocumentChannel
(
aURI
aRemoteSubframes
wantRemoteType
)
)
{
return
true
;
}
return
remoteType
=
=
wantRemoteType
;
}
shouldLoadURI
(
aDocShell
aURI
aHasPostData
)
{
let
{
useRemoteSubframes
}
=
aDocShell
;
this
.
log
(
)
.
debug
(
shouldLoadURI
(
{
this
.
_uriStr
(
aURI
)
}
)
)
;
let
remoteType
=
Services
.
appinfo
.
remoteType
;
if
(
aDocShell
.
browsingContext
.
parent
)
{
return
true
;
}
let
webNav
=
aDocShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
let
sessionHistory
=
webNav
.
sessionHistory
;
let
wantRemoteType
=
this
.
getRemoteTypeForURIObject
(
aURI
true
useRemoteSubframes
remoteType
webNav
.
currentURI
)
;
if
(
AppConstants
.
MOZ_WIDGET_TOOLKIT
!
=
"
android
"
&
&
canProcessSwitchWithDocumentChannel
(
aURI
useRemoteSubframes
wantRemoteType
aDocShell
.
browsingContext
)
)
{
return
true
;
}
if
(
!
aHasPostData
&
&
remoteType
=
=
WEB_REMOTE_TYPE
&
&
sessionHistory
.
count
=
=
1
&
&
webNav
.
currentURI
.
spec
=
=
"
about
:
newtab
"
)
{
return
false
;
}
if
(
!
sessionHistoryInParent
)
{
let
requestedIndex
=
sessionHistory
.
legacySHistory
.
requestedIndex
;
if
(
requestedIndex
>
=
0
)
{
this
.
log
(
)
.
debug
(
"
Checking
history
case
\
n
"
)
;
if
(
sessionHistory
.
legacySHistory
.
getEntryAtIndex
(
requestedIndex
)
.
loadedInThisProcess
)
{
this
.
log
(
)
.
info
(
"
History
entry
loaded
in
this
process
"
)
;
return
true
;
}
this
.
log
(
)
.
debug
(
Checking
remote
type
got
:
{
remoteType
}
want
:
{
wantRemoteType
}
\
n
)
;
return
remoteType
=
=
wantRemoteType
;
}
}
return
remoteType
=
=
wantRemoteType
;
}
redirectLoad
(
aDocShell
aURI
aReferrerInfo
aTriggeringPrincipal
aFlags
aCsp
)
{
const
actor
=
aDocShell
.
domWindow
.
windowGlobalChild
.
getActor
(
"
BrowserTab
"
)
;
let
loadOptions
=
{
uri
:
aURI
.
spec
flags
:
aFlags
|
|
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
referrerInfo
:
this
.
serializeReferrerInfo
(
aReferrerInfo
)
triggeringPrincipal
:
this
.
serializePrincipal
(
aTriggeringPrincipal
|
|
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
}
)
)
csp
:
aCsp
?
this
.
serializeCSP
(
aCsp
)
:
null
}
;
if
(
sessionHistoryInParent
)
{
let
sessionHistory
=
aDocShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
;
actor
.
sendAsyncMessage
(
"
Browser
:
LoadURI
"
{
loadOptions
historyIndex
:
sessionHistory
.
legacySHistory
.
requestedIndex
}
)
;
}
else
{
actor
.
sendAsyncMessage
(
"
Browser
:
LoadURI
"
{
loadOptions
}
)
;
}
return
false
;
}
wrapHandlingUserInput
(
aWindow
aIsHandling
aCallback
)
{
var
handlingUserInput
;
try
{
handlingUserInput
=
aWindow
.
windowUtils
.
setHandlingUserInput
(
aIsHandling
)
;
aCallback
(
)
;
}
finally
{
handlingUserInput
.
destruct
(
)
;
}
}
serializeReferrerInfo
(
referrerInfo
)
{
let
serialized
=
null
;
if
(
referrerInfo
)
{
try
{
serialized
=
serializationHelper
.
serializeToString
(
referrerInfo
)
;
}
catch
(
e
)
{
this
.
log
(
)
.
error
(
Failed
to
serialize
referrerInfo
'
{
referrerInfo
}
'
{
e
}
)
;
}
}
return
serialized
;
}
deserializeReferrerInfo
(
referrerInfo_b64
)
{
let
deserialized
=
null
;
if
(
referrerInfo_b64
)
{
try
{
deserialized
=
serializationHelper
.
deserializeObject
(
referrerInfo_b64
)
;
deserialized
.
QueryInterface
(
Ci
.
nsIReferrerInfo
)
;
}
catch
(
e
)
{
this
.
log
(
)
.
error
(
Failed
to
deserialize
referrerInfo_b64
'
{
referrerInfo_b64
}
'
{
e
}
)
;
}
}
return
deserialized
;
}
getBrowserPids
(
aBrowser
aRemoteSubframes
)
{
if
(
!
aBrowser
.
isRemoteBrowser
|
|
!
aBrowser
.
frameLoader
)
{
return
[
]
;
}
let
tabPid
=
aBrowser
.
frameLoader
.
remoteTab
.
osPid
;
let
pids
=
new
Set
(
)
;
if
(
aRemoteSubframes
)
{
let
stack
=
[
aBrowser
.
browsingContext
]
;
while
(
stack
.
length
)
{
let
bc
=
stack
.
pop
(
)
;
stack
.
push
(
.
.
.
bc
.
children
)
;
if
(
bc
.
currentWindowGlobal
)
{
let
pid
=
bc
.
currentWindowGlobal
.
osPid
;
if
(
pid
!
=
tabPid
)
{
pids
.
add
(
pid
)
;
}
}
}
}
return
[
tabPid
.
.
.
pids
]
;
}
remoteTypePrefix
(
aRemoteType
)
{
return
aRemoteType
.
split
(
"
=
"
)
[
0
]
;
}
isWebRemoteType
(
aRemoteType
)
{
return
aRemoteType
.
startsWith
(
WEB_REMOTE_TYPE
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
E10SUtils
"
SERIALIZED_SYSTEMPRINCIPAL
"
function
(
)
{
return
E10SUtils
.
serializePrincipal
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
)
;
