import
{
AppConstants
}
from
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
;
import
{
XPCOMUtils
}
from
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
ReaderMode
:
"
moz
-
src
:
/
/
/
toolkit
/
components
/
reader
/
ReaderMode
.
sys
.
mjs
"
Region
:
"
resource
:
/
/
gre
/
modules
/
Region
.
sys
.
mjs
"
}
)
;
ChromeUtils
.
defineLazyGetter
(
lazy
"
CatManListenerManager
"
(
)
=
>
{
const
CatManListenerManager
=
{
cachedModules
:
{
}
cachedListeners
:
{
}
observe
(
_subject
_topic
categoryName
)
{
delete
this
.
cachedListeners
[
categoryName
]
;
}
getListeners
(
categoryName
)
{
if
(
Object
.
hasOwn
(
this
.
cachedListeners
categoryName
)
)
{
return
this
.
cachedListeners
[
categoryName
]
;
}
let
rv
=
Array
.
from
(
Services
.
catMan
.
enumerateCategory
(
categoryName
)
(
{
data
:
module
value
}
)
=
>
{
try
{
let
[
objName
method
]
=
value
.
split
(
"
.
"
)
;
let
fn
=
(
.
.
.
args
)
=
>
{
if
(
!
Object
.
hasOwn
(
this
.
cachedModules
module
)
)
{
this
.
cachedModules
[
module
]
=
ChromeUtils
.
importESModule
(
module
)
;
}
let
obj
=
this
.
cachedModules
[
module
]
[
objName
]
;
if
(
!
obj
)
{
throw
new
Error
(
Could
not
access
{
objName
}
in
{
module
}
.
Is
it
exported
?
)
;
}
if
(
typeof
obj
[
method
]
!
=
"
function
"
)
{
throw
new
Error
(
{
objName
}
.
{
method
}
in
{
module
}
is
not
a
function
.
)
;
}
return
this
.
cachedModules
[
module
]
[
objName
]
[
method
]
(
.
.
.
args
)
;
}
;
fn
.
_descriptiveName
=
value
;
return
fn
;
}
catch
(
ex
)
{
console
.
error
(
Error
processing
category
manifest
for
{
module
}
:
{
value
}
ex
)
;
return
null
;
}
}
)
;
rv
=
rv
.
filter
(
l
=
>
!
!
l
)
;
this
.
cachedListeners
[
categoryName
]
=
rv
;
return
rv
;
}
}
;
Services
.
obs
.
addObserver
(
CatManListenerManager
"
xpcom
-
category
-
entry
-
removed
"
)
;
Services
.
obs
.
addObserver
(
CatManListenerManager
"
xpcom
-
category
-
entry
-
added
"
)
;
Services
.
obs
.
addObserver
(
CatManListenerManager
"
xpcom
-
category
-
cleared
"
)
;
return
CatManListenerManager
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
INVALID_SHAREABLE_SCHEMES
"
"
services
.
sync
.
engine
.
tabs
.
filteredSchemes
"
"
"
null
val
=
>
{
return
new
Set
(
val
.
split
(
"
|
"
)
)
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
lazy
"
gLocalization
"
(
)
=
>
{
return
new
Localization
(
[
"
toolkit
/
global
/
browser
-
utils
.
ftl
"
]
true
)
;
}
)
;
function
stringPrefToSet
(
prefVal
)
{
return
new
Set
(
prefVal
.
toLowerCase
(
)
.
split
(
/
\
s
*
\
s
*
/
g
)
.
filter
(
v
=
>
!
!
v
)
)
;
}
export
var
BrowserUtils
=
{
principalWithMatchingOA
(
principal
existingPrincipal
)
{
if
(
principal
.
isSystemPrincipal
)
{
return
principal
;
}
if
(
existingPrincipal
.
originSuffix
=
=
principal
.
originSuffix
)
{
return
principal
;
}
let
secMan
=
Services
.
scriptSecurityManager
;
if
(
principal
.
isContentPrincipal
)
{
return
secMan
.
principalWithOA
(
principal
existingPrincipal
.
originAttributes
)
;
}
if
(
principal
.
isNullPrincipal
)
{
return
secMan
.
createNullPrincipal
(
existingPrincipal
.
originAttributes
)
;
}
throw
new
Error
(
"
Can
'
t
change
the
originAttributes
of
an
expanded
principal
!
"
)
;
}
copyLink
(
url
title
)
{
let
node
=
{
}
;
node
.
type
=
0
;
node
.
title
=
title
;
node
.
uri
=
url
;
lazy
.
PlacesUtils
.
copyNode
(
node
)
;
}
mimeTypeIsTextBased
(
mimeType
)
{
return
(
mimeType
.
startsWith
(
"
text
/
"
)
|
|
mimeType
.
endsWith
(
"
+
xml
"
)
|
|
mimeType
.
endsWith
(
"
+
json
"
)
|
|
mimeType
=
=
"
application
/
x
-
javascript
"
|
|
mimeType
=
=
"
application
/
javascript
"
|
|
mimeType
=
=
"
application
/
json
"
|
|
mimeType
=
=
"
application
/
xml
"
)
;
}
canFindInPage
(
location
)
{
return
(
!
location
.
startsWith
(
"
about
:
preferences
"
)
&
&
!
location
.
startsWith
(
"
about
:
settings
"
)
&
&
!
location
.
startsWith
(
"
about
:
logins
"
)
&
&
!
location
.
startsWith
(
"
about
:
firefoxview
"
)
)
;
}
isFindbarVisible
(
docShell
)
{
const
FINDER_SYS_MJS
=
"
resource
:
/
/
gre
/
modules
/
Finder
.
sys
.
mjs
"
;
return
(
Cu
.
isESModuleLoaded
(
FINDER_SYS_MJS
)
&
&
ChromeUtils
.
importESModule
(
FINDER_SYS_MJS
)
.
Finder
.
isFindbarVisible
(
docShell
)
)
;
}
promiseObserved
(
topic
test
=
(
)
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
_topic
data
)
=
>
{
if
(
test
(
subject
data
)
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
{
subject
data
}
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
topic
)
;
}
)
;
}
formatURIStringForDisplay
(
uriString
options
=
{
}
)
{
try
{
return
this
.
formatURIForDisplay
(
Services
.
io
.
newURI
(
uriString
)
options
)
;
}
catch
(
ex
)
{
return
uriString
;
}
}
formatURIForDisplay
(
uri
options
=
{
}
)
{
let
{
showInsecureHTTP
=
false
}
=
options
;
switch
(
uri
.
scheme
)
{
case
"
view
-
source
"
:
{
let
innerURI
=
uri
.
spec
.
substring
(
"
view
-
source
:
"
.
length
)
;
return
this
.
formatURIStringForDisplay
(
innerURI
options
)
;
}
case
"
http
"
:
case
"
https
"
:
{
let
host
=
uri
.
displayHostPort
;
if
(
!
showInsecureHTTP
&
&
host
.
startsWith
(
"
www
.
"
)
)
{
host
=
Services
.
eTLD
.
getSchemelessSite
(
uri
)
;
}
if
(
showInsecureHTTP
&
&
uri
.
scheme
=
=
"
http
"
)
{
return
"
http
:
/
/
"
+
host
;
}
return
host
;
}
case
"
about
"
:
return
"
about
:
"
+
uri
.
filePath
;
case
"
blob
"
:
try
{
let
url
=
new
URL
(
uri
.
specIgnoringRef
)
;
if
(
url
.
origin
&
&
url
.
origin
!
=
"
null
"
)
{
return
this
.
formatURIStringForDisplay
(
url
.
origin
options
)
;
}
}
catch
(
ex
)
{
console
.
error
(
"
Invalid
blob
URI
passed
to
formatURIForDisplay
:
"
ex
)
;
}
case
"
data
"
:
return
lazy
.
gLocalization
.
formatValueSync
(
"
browser
-
utils
-
url
-
data
"
)
;
case
"
moz
-
extension
"
:
{
let
policy
=
WebExtensionPolicy
.
getByURI
(
uri
)
;
return
lazy
.
gLocalization
.
formatValueSync
(
"
browser
-
utils
-
url
-
extension
"
{
extension
:
policy
?
.
name
.
trim
(
)
|
|
uri
.
spec
}
)
;
}
case
"
chrome
"
:
case
"
resource
"
:
case
"
jar
"
:
case
"
file
"
:
default
:
try
{
let
url
=
uri
.
QueryInterface
(
Ci
.
nsIURL
)
;
if
(
url
.
fileName
)
{
return
url
.
fileName
;
}
if
(
url
.
directory
)
{
let
parts
=
url
.
directory
.
split
(
"
/
"
)
;
let
last
;
while
(
!
last
&
&
parts
.
length
)
{
last
=
parts
.
pop
(
)
;
}
if
(
last
)
{
return
last
;
}
}
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
}
return
uri
.
asciiHost
|
|
uri
.
spec
;
}
getShareableURL
(
url
)
{
if
(
!
url
)
{
return
null
;
}
if
(
url
.
spec
.
startsWith
(
"
about
:
reader
?
"
)
)
{
url
=
Services
.
io
.
newURI
(
lazy
.
ReaderMode
.
getOriginalUrl
(
url
.
spec
)
)
;
}
if
(
url
.
spec
.
length
>
65535
)
{
return
null
;
}
return
lazy
.
INVALID_SHAREABLE_SCHEMES
.
has
(
url
.
scheme
)
?
null
:
url
;
}
hrefAndLinkNodeForClickEvent
(
event
)
{
let
content
=
event
.
view
|
|
event
.
composedTarget
?
.
ownerGlobal
;
if
(
!
content
?
.
HTMLAnchorElement
)
{
return
null
;
}
function
isHTMLLink
(
aNode
)
{
return
(
(
content
.
HTMLAnchorElement
.
isInstance
(
aNode
)
&
&
aNode
.
href
)
|
|
(
content
.
HTMLAreaElement
.
isInstance
(
aNode
)
&
&
aNode
.
href
)
|
|
content
.
HTMLLinkElement
.
isInstance
(
aNode
)
)
;
}
let
node
=
event
.
composedTarget
;
while
(
node
&
&
!
isHTMLLink
(
node
)
)
{
node
=
node
.
flattenedTreeParentNode
;
}
if
(
node
)
{
return
[
node
.
href
node
node
.
ownerDocument
.
nodePrincipal
]
;
}
let
href
baseURI
;
node
=
event
.
composedTarget
;
while
(
node
&
&
!
href
)
{
if
(
node
.
nodeType
=
=
content
.
Node
.
ELEMENT_NODE
&
&
(
node
.
localName
=
=
"
a
"
|
|
node
.
namespaceURI
=
=
"
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
"
)
)
{
href
=
node
.
getAttribute
(
"
href
"
)
|
|
node
.
getAttributeNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
"
"
href
"
)
;
if
(
href
)
{
baseURI
=
node
.
ownerDocument
.
baseURIObject
;
break
;
}
}
node
=
node
.
flattenedTreeParentNode
;
}
return
[
href
?
Services
.
io
.
newURI
(
href
null
baseURI
)
.
spec
:
null
null
node
&
&
node
.
ownerDocument
.
nodePrincipal
]
;
}
whereToOpenLink
(
e
ignoreButton
ignoreAlt
)
{
if
(
!
e
)
{
return
"
current
"
;
}
e
=
this
.
getRootEvent
(
e
)
;
var
shift
=
e
.
shiftKey
;
var
ctrl
=
e
.
ctrlKey
;
var
meta
=
e
.
metaKey
;
var
alt
=
e
.
altKey
&
&
!
ignoreAlt
;
let
middle
=
!
ignoreButton
&
&
e
.
button
=
=
1
;
let
middleUsesTabs
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
opentabfor
.
middleclick
"
true
)
;
let
middleUsesNewWindow
=
Services
.
prefs
.
getBoolPref
(
"
middlemouse
.
openNewWindow
"
false
)
;
var
metaKey
=
AppConstants
.
platform
=
=
"
macosx
"
?
meta
:
ctrl
;
if
(
metaKey
|
|
(
middle
&
&
middleUsesTabs
)
)
{
return
shift
?
"
tabshifted
"
:
"
tab
"
;
}
if
(
alt
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
altClickSave
"
false
)
)
{
return
"
save
"
;
}
if
(
shift
|
|
(
middle
&
&
!
middleUsesTabs
&
&
middleUsesNewWindow
)
)
{
return
"
window
"
;
}
return
"
current
"
;
}
getRootEvent
(
aEvent
)
{
if
(
!
aEvent
)
{
return
aEvent
;
}
let
tempEvent
=
aEvent
;
while
(
tempEvent
.
sourceEvent
)
{
if
(
tempEvent
.
sourceEvent
.
button
=
=
1
)
{
aEvent
=
tempEvent
.
sourceEvent
;
break
;
}
tempEvent
=
tempEvent
.
sourceEvent
;
}
return
aEvent
;
}
callModulesFromCategory
(
{
categoryName
profilerMarker
=
"
"
idleDispatch
=
false
failureHandler
=
null
}
.
.
.
args
)
{
let
callSingleListener
=
async
fn
=
>
{
let
startTime
=
profilerMarker
?
ChromeUtils
.
now
(
)
:
0
;
try
{
await
fn
(
.
.
.
args
)
;
}
catch
(
ex
)
{
console
.
error
(
Error
in
processing
{
categoryName
}
for
{
fn
.
_descriptiveName
}
)
;
console
.
error
(
ex
)
;
try
{
await
failureHandler
?
.
(
ex
)
;
}
catch
(
nestedEx
)
{
console
.
error
(
Error
in
handling
failure
:
{
nestedEx
}
)
;
if
(
BrowserUtils
.
_inAutomation
)
{
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
.
abort
(
nestedEx
.
filename
nestedEx
.
lineNumber
)
;
}
}
}
if
(
profilerMarker
)
{
ChromeUtils
.
addProfilerMarker
(
profilerMarker
startTime
fn
.
_descriptiveName
)
;
}
}
;
for
(
let
listener
of
lazy
.
CatManListenerManager
.
getListeners
(
categoryName
)
)
{
if
(
idleDispatch
)
{
ChromeUtils
.
idleDispatch
(
(
)
=
>
callSingleListener
(
listener
)
)
;
}
else
{
callSingleListener
(
listener
)
;
}
}
}
isChinaRepack
(
)
{
return
(
Services
.
prefs
.
getDefaultBranch
(
"
"
)
.
getCharPref
(
"
distribution
.
id
"
"
default
"
)
=
=
=
"
MozillaOnline
"
)
;
}
PromoType
:
{
DEFAULT
:
0
VPN
:
1
RELAY
:
2
FOCUS
:
3
PIN
:
4
COOKIE_BANNERS
:
5
}
shouldShowPromo
(
promoType
)
{
switch
(
promoType
)
{
case
this
.
PromoType
.
VPN
:
case
this
.
PromoType
.
FOCUS
:
case
this
.
PromoType
.
PIN
:
case
this
.
PromoType
.
RELAY
:
case
this
.
PromoType
.
COOKIE_BANNERS
:
break
;
default
:
throw
new
Error
(
"
Unknown
promo
type
:
"
promoType
)
;
}
const
info
=
PromoInfo
[
promoType
]
;
const
promoEnabled
=
!
info
.
enabledPref
|
|
Services
.
prefs
.
getBoolPref
(
info
.
enabledPref
true
)
;
const
homeRegion
=
lazy
.
Region
.
home
|
|
"
"
;
const
currentRegion
=
lazy
.
Region
.
current
|
|
"
"
;
let
inSupportedRegion
=
true
;
if
(
"
supportedRegions
"
in
info
.
lazyStringSetPrefs
)
{
const
supportedRegions
=
info
.
lazyStringSetPrefs
.
supportedRegions
.
lazyValue
;
inSupportedRegion
=
supportedRegions
.
has
(
currentRegion
.
toLowerCase
(
)
)
|
|
supportedRegions
.
has
(
homeRegion
.
toLowerCase
(
)
)
;
}
const
avoidAdsRegions
=
info
.
lazyStringSetPrefs
.
disallowedRegions
?
.
lazyValue
;
const
noActivePolicy
=
info
.
showForEnterprise
|
|
!
Services
.
policies
|
|
Services
.
policies
.
status
!
=
=
Services
.
policies
.
ACTIVE
;
const
passedExtraCheck
=
!
info
.
extraCheck
|
|
info
.
extraCheck
(
)
;
return
(
promoEnabled
&
&
!
avoidAdsRegions
?
.
has
(
homeRegion
.
toLowerCase
(
)
)
&
&
!
avoidAdsRegions
?
.
has
(
currentRegion
.
toLowerCase
(
)
)
&
&
!
info
.
illegalRegions
.
includes
(
homeRegion
.
toLowerCase
(
)
)
&
&
!
info
.
illegalRegions
.
includes
(
currentRegion
.
toLowerCase
(
)
)
&
&
inSupportedRegion
&
&
noActivePolicy
&
&
passedExtraCheck
)
;
}
shouldShowVPNPromo
(
)
{
return
this
.
shouldShowPromo
(
this
.
PromoType
.
VPN
)
;
}
sendToDeviceEmailsSupported
(
)
{
const
userLocale
=
Services
.
locale
.
appLocaleAsBCP47
.
toLowerCase
(
)
;
return
this
.
emailSupportedLocales
.
has
(
userLocale
)
;
}
}
;
let
PromoInfo
=
{
[
BrowserUtils
.
PromoType
.
VPN
]
:
{
enabledPref
:
"
browser
.
vpn_promo
.
enabled
"
lazyStringSetPrefs
:
{
supportedRegions
:
{
name
:
"
browser
.
contentblocking
.
report
.
vpn_regions
"
default
:
"
as
at
au
bd
be
bg
br
ca
ch
cl
co
cy
cz
de
dk
ee
eg
es
fi
fr
gb
gg
gr
hr
hu
id
ie
im
in
io
it
je
ke
kr
lt
lu
lv
ma
mp
mt
mx
my
ng
nl
no
nz
pl
pr
pt
ro
sa
se
sg
si
sk
sn
th
tr
tw
ua
ug
uk
um
us
vg
vi
vn
za
"
}
disallowedRegions
:
{
name
:
"
browser
.
vpn_promo
.
disallowed_regions
"
default
:
"
ae
by
cn
cu
iq
ir
kp
om
ru
sd
sy
tm
tr
"
}
}
illegalRegions
:
[
"
ae
"
"
by
"
"
cn
"
"
cu
"
"
iq
"
"
ir
"
"
kp
"
"
om
"
"
ru
"
"
sd
"
"
sy
"
"
tm
"
"
tr
"
]
}
[
BrowserUtils
.
PromoType
.
FOCUS
]
:
{
enabledPref
:
"
browser
.
promo
.
focus
.
enabled
"
lazyStringSetPrefs
:
{
disallowedRegions
:
{
name
:
"
browser
.
promo
.
focus
.
disallowed_regions
"
default
:
"
cn
"
}
}
illegalRegions
:
[
"
cn
"
]
}
[
BrowserUtils
.
PromoType
.
PIN
]
:
{
enabledPref
:
"
browser
.
promo
.
pin
.
enabled
"
lazyStringSetPrefs
:
{
}
illegalRegions
:
[
]
}
[
BrowserUtils
.
PromoType
.
RELAY
]
:
{
lazyStringSetPrefs
:
{
}
illegalRegions
:
[
]
extraCheck
:
(
)
=
>
!
Services
.
prefs
.
getCharPref
(
"
identity
.
fxaccounts
.
autoconfig
.
uri
"
"
"
)
&
&
[
"
identity
.
fxaccounts
.
remote
.
root
"
"
identity
.
fxaccounts
.
auth
.
uri
"
"
identity
.
fxaccounts
.
remote
.
oauth
.
uri
"
"
identity
.
fxaccounts
.
remote
.
profile
.
uri
"
"
identity
.
fxaccounts
.
remote
.
pairing
.
uri
"
"
identity
.
sync
.
tokenserver
.
uri
"
]
.
every
(
pref
=
>
!
Services
.
prefs
.
prefHasUserValue
(
pref
)
)
}
[
BrowserUtils
.
PromoType
.
COOKIE_BANNERS
]
:
{
enabledPref
:
"
browser
.
promo
.
cookiebanners
.
enabled
"
lazyStringSetPrefs
:
{
}
illegalRegions
:
[
]
showForEnterprise
:
true
}
}
;
for
(
let
promo
of
Object
.
values
(
PromoInfo
)
)
{
for
(
let
prefObj
of
Object
.
values
(
promo
.
lazyStringSetPrefs
)
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
prefObj
"
lazyValue
"
prefObj
.
name
prefObj
.
default
null
stringPrefToSet
)
;
}
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
BrowserUtils
"
navigationRequireUserInteraction
"
"
browser
.
navigation
.
requireUserInteraction
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
BrowserUtils
"
emailSupportedLocales
"
"
browser
.
send_to_device_locales
"
"
de
en
-
GB
en
-
US
es
-
AR
es
-
CL
es
-
ES
es
-
MX
fr
id
pl
pt
-
BR
ru
zh
-
TW
"
null
stringPrefToSet
)
;
