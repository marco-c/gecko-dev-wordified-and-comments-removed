"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
OSKeyStore
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
nativeOSKeyStore
"
"
mozilla
.
org
/
security
/
oskeystore
;
1
"
Ci
.
nsIOSKeyStore
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
osReauthenticator
"
"
mozilla
.
org
/
security
/
osreauthenticator
;
1
"
Ci
.
nsIOSReauthenticator
)
;
const
TEST_ONLY_REAUTH
=
"
toolkit
.
osKeyStore
.
unofficialBuildOnlyLogin
"
;
var
OSKeyStore
=
{
STORE_LABEL
:
AppConstants
.
MOZ_APP_NAME
_isLocked
:
true
_pendingUnlockPromise
:
null
get
isLoggedIn
(
)
{
return
!
this
.
_isLocked
;
}
get
isUIBusy
(
)
{
return
!
!
this
.
_pendingUnlockPromise
;
}
async
_reauthInTests
(
)
{
log
.
debug
(
"
_ensureReauth
:
_testReauth
:
"
this
.
_testReauth
)
;
switch
(
this
.
_testReauth
)
{
case
"
pass
"
:
Services
.
obs
.
notifyObservers
(
null
"
oskeystore
-
testonly
-
reauth
"
"
pass
"
)
;
return
{
authenticated
:
true
auth_details
:
"
success
"
}
;
case
"
cancel
"
:
Services
.
obs
.
notifyObservers
(
null
"
oskeystore
-
testonly
-
reauth
"
"
cancel
"
)
;
throw
new
Components
.
Exception
(
"
Simulating
user
cancelling
login
dialog
"
Cr
.
NS_ERROR_FAILURE
)
;
default
:
throw
new
Components
.
Exception
(
"
Unknown
test
pref
value
"
Cr
.
NS_ERROR_FAILURE
)
;
}
}
async
ensureLoggedIn
(
reauth
=
false
dialogCaption
=
"
"
parentWindow
=
null
generateKeyIfNotAvailable
=
true
)
{
if
(
(
typeof
reauth
!
=
"
boolean
"
&
&
typeof
reauth
!
=
"
string
"
)
|
|
reauth
=
=
=
true
|
|
reauth
=
=
=
"
"
)
{
throw
new
Error
(
"
reauth
is
required
to
either
be
false
or
a
non
-
empty
string
"
)
;
}
if
(
this
.
_pendingUnlockPromise
)
{
log
.
debug
(
"
ensureLoggedIn
:
Has
a
pending
unlock
operation
"
)
;
return
this
.
_pendingUnlockPromise
;
}
log
.
debug
(
"
ensureLoggedIn
:
Creating
new
pending
unlock
promise
.
reauth
:
"
reauth
)
;
let
unlockPromise
;
if
(
typeof
reauth
=
=
"
string
"
)
{
if
(
UpdateUtils
.
getUpdateChannel
(
false
)
=
=
"
default
"
&
&
this
.
_testReauth
)
{
unlockPromise
=
this
.
_reauthInTests
(
)
;
}
else
if
(
AppConstants
.
platform
=
=
"
win
"
|
|
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
AppConstants
.
isPlatformAndVersionAtLeast
(
"
macosx
"
"
16
"
)
)
)
{
unlockPromise
=
osReauthenticator
.
asyncReauthenticateUser
(
reauth
dialogCaption
parentWindow
)
.
then
(
reauthResult
=
>
{
if
(
typeof
reauthResult
[
0
]
=
=
"
boolean
"
&
&
!
reauthResult
[
0
]
)
{
throw
new
Components
.
Exception
(
"
User
canceled
OS
reauth
entry
"
Cr
.
NS_ERROR_FAILURE
)
;
}
let
result
=
{
authenticated
:
true
auth_details
:
"
success
"
}
;
if
(
reauthResult
.
length
=
=
2
&
&
reauthResult
[
1
]
)
{
result
.
auth_details
+
=
"
_no_password
"
;
}
return
result
;
}
)
;
}
else
{
log
.
debug
(
"
ensureLoggedIn
:
Skipping
reauth
on
unsupported
platforms
"
)
;
unlockPromise
=
Promise
.
resolve
(
{
authenticated
:
true
auth_details
:
"
success_unsupported_platform
"
}
)
;
}
}
else
{
unlockPromise
=
Promise
.
resolve
(
{
authenticated
:
true
}
)
;
}
if
(
generateKeyIfNotAvailable
)
{
unlockPromise
=
unlockPromise
.
then
(
async
reauthResult
=
>
{
if
(
!
(
await
nativeOSKeyStore
.
asyncSecretAvailable
(
this
.
STORE_LABEL
)
)
)
{
log
.
debug
(
"
ensureLoggedIn
:
Secret
unavailable
attempt
to
generate
new
secret
.
"
)
;
let
recoveryPhrase
=
await
nativeOSKeyStore
.
asyncGenerateSecret
(
this
.
STORE_LABEL
)
;
log
.
debug
(
"
ensureLoggedIn
:
Secret
generated
.
Recovery
phrase
length
:
"
+
recoveryPhrase
.
length
)
;
}
return
reauthResult
;
}
)
;
}
unlockPromise
=
unlockPromise
.
then
(
reauthResult
=
>
{
log
.
debug
(
"
ensureLoggedIn
:
Logged
in
"
)
;
this
.
_pendingUnlockPromise
=
null
;
this
.
_isLocked
=
false
;
return
reauthResult
;
}
err
=
>
{
log
.
debug
(
"
ensureLoggedIn
:
Not
logged
in
"
err
)
;
this
.
_pendingUnlockPromise
=
null
;
this
.
_isLocked
=
true
;
return
{
authenticated
:
false
auth_details
:
"
fail
"
}
;
}
)
;
this
.
_pendingUnlockPromise
=
unlockPromise
;
return
this
.
_pendingUnlockPromise
;
}
async
decrypt
(
cipherText
reauth
=
false
)
{
if
(
!
(
await
this
.
ensureLoggedIn
(
reauth
)
)
.
authenticated
)
{
throw
Components
.
Exception
(
"
User
canceled
OS
unlock
entry
"
Cr
.
NS_ERROR_ABORT
)
;
}
let
bytes
=
await
nativeOSKeyStore
.
asyncDecryptBytes
(
this
.
STORE_LABEL
cipherText
)
;
return
String
.
fromCharCode
.
apply
(
String
bytes
)
;
}
async
encrypt
(
plainText
)
{
if
(
!
(
await
this
.
ensureLoggedIn
(
)
)
.
authenticated
)
{
throw
Components
.
Exception
(
"
User
canceled
OS
unlock
entry
"
Cr
.
NS_ERROR_ABORT
)
;
}
plainText
=
unescape
(
encodeURIComponent
(
plainText
)
)
;
let
textArr
=
[
]
;
for
(
let
char
of
plainText
)
{
textArr
.
push
(
char
.
charCodeAt
(
0
)
)
;
}
let
rawEncryptedText
=
await
nativeOSKeyStore
.
asyncEncryptBytes
(
this
.
STORE_LABEL
textArr
)
;
return
rawEncryptedText
;
}
async
waitForExistingDialog
(
)
{
if
(
this
.
isUIBusy
)
{
return
this
.
_pendingUnlockPromise
;
}
return
this
.
isLoggedIn
;
}
async
cleanup
(
)
{
return
nativeOSKeyStore
.
asyncDeleteSecret
(
this
.
STORE_LABEL
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
ConsoleAPI
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
.
ConsoleAPI
;
return
new
ConsoleAPI
(
{
maxLogLevelPref
:
"
browser
.
osKeyStore
.
loglevel
"
prefix
:
"
OSKeyStore
"
}
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
OSKeyStore
"
_testReauth
"
TEST_ONLY_REAUTH
"
"
)
;
