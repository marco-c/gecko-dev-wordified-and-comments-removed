"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SelectionUtils
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
SelectionUtils
=
{
trimSelection
(
aSelection
aMaxLen
)
{
const
maxLen
=
Math
.
min
(
aMaxLen
|
|
150
aSelection
.
length
)
;
if
(
aSelection
.
length
>
maxLen
)
{
let
pattern
=
new
RegExp
(
"
^
(
?
:
\
\
s
*
.
)
{
0
"
+
maxLen
+
"
}
"
)
;
pattern
.
test
(
aSelection
)
;
aSelection
=
RegExp
.
lastMatch
;
}
aSelection
=
aSelection
.
trim
(
)
.
replace
(
/
\
s
+
/
g
"
"
)
;
if
(
aSelection
.
length
>
maxLen
)
{
aSelection
=
aSelection
.
substr
(
0
maxLen
)
;
}
return
aSelection
;
}
getSelectionDetails
(
aTopWindow
aCharLen
)
{
let
focusedWindow
=
{
}
;
let
focusedElement
=
Services
.
focus
.
getFocusedElementForWindow
(
aTopWindow
true
focusedWindow
)
;
focusedWindow
=
focusedWindow
.
value
;
let
selection
=
focusedWindow
.
getSelection
(
)
;
let
selectionStr
=
selection
.
toString
(
)
;
let
fullText
;
let
url
;
let
linkText
;
let
isDocumentLevelSelection
=
true
;
if
(
!
selectionStr
&
&
focusedElement
)
{
if
(
ChromeUtils
.
getClassName
(
focusedElement
)
=
=
=
"
HTMLTextAreaElement
"
|
|
(
ChromeUtils
.
getClassName
(
focusedElement
)
=
=
=
"
HTMLInputElement
"
&
&
focusedElement
.
mozIsTextField
(
true
)
)
)
{
selection
=
focusedElement
.
editor
.
selection
;
selectionStr
=
selection
.
toString
(
)
;
isDocumentLevelSelection
=
false
;
}
}
let
collapsed
=
selection
.
isCollapsed
;
if
(
selectionStr
)
{
linkText
=
selectionStr
.
trim
(
)
;
if
(
/
^
(
?
:
https
?
|
ftp
)
:
/
i
.
test
(
linkText
)
)
{
try
{
url
=
Services
.
io
.
newURI
(
linkText
)
;
}
catch
(
ex
)
{
}
}
else
if
(
/
^
(
?
:
[
a
-
z
\
d
-
]
+
\
.
)
+
[
a
-
z
]
+
/
i
.
test
(
linkText
)
)
{
let
beginRange
=
selection
.
getRangeAt
(
0
)
;
let
delimitedAtStart
=
/
^
\
s
/
.
test
(
beginRange
)
;
if
(
!
delimitedAtStart
)
{
let
container
=
beginRange
.
startContainer
;
let
offset
=
beginRange
.
startOffset
;
if
(
container
.
nodeType
=
=
container
.
TEXT_NODE
&
&
offset
>
0
)
{
delimitedAtStart
=
/
\
W
/
.
test
(
container
.
textContent
[
offset
-
1
]
)
;
}
else
{
delimitedAtStart
=
true
;
}
}
let
delimitedAtEnd
=
false
;
if
(
delimitedAtStart
)
{
let
endRange
=
selection
.
getRangeAt
(
selection
.
rangeCount
-
1
)
;
delimitedAtEnd
=
/
\
s
/
.
test
(
endRange
)
;
if
(
!
delimitedAtEnd
)
{
let
container
=
endRange
.
endContainer
;
let
offset
=
endRange
.
endOffset
;
if
(
container
.
nodeType
=
=
container
.
TEXT_NODE
&
&
offset
<
container
.
textContent
.
length
)
{
delimitedAtEnd
=
/
\
W
/
.
test
(
container
.
textContent
[
offset
]
)
;
}
else
{
delimitedAtEnd
=
true
;
}
}
}
if
(
delimitedAtStart
&
&
delimitedAtEnd
)
{
try
{
url
=
Services
.
uriFixup
.
getFixupURIInfo
(
linkText
)
.
preferredURI
;
}
catch
(
ex
)
{
}
}
}
}
if
(
selectionStr
)
{
fullText
=
selectionStr
.
substr
(
0
16384
)
;
selectionStr
=
this
.
trimSelection
(
selectionStr
aCharLen
)
;
}
if
(
url
&
&
!
url
.
host
)
{
url
=
null
;
}
return
{
text
:
selectionStr
docSelectionIsCollapsed
:
collapsed
isDocumentLevelSelection
fullText
linkURL
:
url
?
url
.
spec
:
null
linkText
:
url
?
linkText
:
"
"
}
;
}
}
;
