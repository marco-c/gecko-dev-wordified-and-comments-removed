"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ProfileAge
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
TelemetryUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
FILE_TIMES
=
"
times
.
json
"
;
function
getElapsedTimeInDays
(
aStartDate
aEndDate
)
{
return
TelemetryUtils
.
millisecondsToDays
(
aEndDate
-
aStartDate
)
;
}
async
function
getOldestProfileTimestamp
(
profilePath
log
)
{
let
start
=
Date
.
now
(
)
;
let
oldest
=
start
+
1000
;
log
.
debug
(
"
Iterating
over
profile
"
+
profilePath
)
;
Services
.
telemetry
.
scalarAdd
(
"
telemetry
.
profile_directory_scans
"
1
)
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
PROFILE_DIRECTORY_FILE_AGE
"
)
;
try
{
for
(
const
childPath
of
await
IOUtils
.
getChildren
(
profilePath
)
)
{
try
{
let
info
=
await
IOUtils
.
stat
(
childPath
)
;
let
timestamp
;
if
(
info
.
creationTime
!
=
=
undefined
)
{
timestamp
=
info
.
creationTime
;
}
else
{
log
.
debug
(
"
No
birth
date
.
Using
mtime
.
"
)
;
timestamp
=
info
.
lastModified
;
}
let
ageInDays
=
Math
.
max
(
0
getElapsedTimeInDays
(
timestamp
start
)
)
;
histogram
.
add
(
ageInDays
)
;
log
.
debug
(
Using
date
:
{
childPath
}
=
{
timestamp
}
)
;
if
(
timestamp
<
oldest
)
{
oldest
=
timestamp
;
}
}
catch
(
e
)
{
log
.
debug
(
"
Stat
failure
"
e
)
;
}
}
}
catch
(
reason
)
{
throw
new
Error
(
"
Unable
to
fetch
oldest
profile
entry
:
"
+
reason
)
;
}
return
oldest
;
}
class
ProfileAgeImpl
{
constructor
(
profile
times
)
{
this
.
_profilePath
=
profile
;
this
.
_times
=
times
;
this
.
_log
=
Log
.
repository
.
getLogger
(
"
Toolkit
.
ProfileAge
"
)
;
if
(
"
firstUse
"
in
this
.
_times
&
&
this
.
_times
.
firstUse
=
=
=
null
)
{
this
.
_times
.
firstUse
=
Date
.
now
(
)
;
this
.
writeTimes
(
)
;
}
}
get
profilePath
(
)
{
if
(
this
.
_profilePath
)
{
return
Promise
.
resolve
(
this
.
_profilePath
)
;
}
return
PathUtils
.
getProfileDir
(
)
.
then
(
profilePath
=
>
{
this
.
_profilePath
=
profilePath
;
return
profilePath
;
}
)
;
}
get
created
(
)
{
if
(
this
.
_created
)
{
return
this
.
_created
;
}
if
(
!
this
.
_times
.
created
)
{
this
.
_created
=
this
.
computeAndPersistCreated
(
)
;
}
else
{
this
.
_created
=
Promise
.
resolve
(
this
.
_times
.
created
)
;
}
return
this
.
_created
;
}
get
firstUse
(
)
{
if
(
"
firstUse
"
in
this
.
_times
)
{
return
Promise
.
resolve
(
this
.
_times
.
firstUse
)
;
}
return
Promise
.
resolve
(
undefined
)
;
}
async
writeTimes
(
)
{
await
IOUtils
.
writeJSON
(
PathUtils
.
join
(
await
this
.
profilePath
FILE_TIMES
)
this
.
_times
)
;
}
async
computeAndPersistCreated
(
)
{
let
oldest
=
await
getOldestProfileTimestamp
(
await
this
.
profilePath
this
.
_log
)
;
this
.
_times
.
created
=
oldest
;
Services
.
telemetry
.
scalarSet
(
"
telemetry
.
profile_directory_scan_date
"
TelemetryUtils
.
millisecondsToDays
(
Date
.
now
(
)
)
)
;
await
this
.
writeTimes
(
)
;
return
oldest
;
}
recordProfileReset
(
time
=
Date
.
now
(
)
)
{
this
.
_times
.
reset
=
time
;
return
this
.
writeTimes
(
)
;
}
get
reset
(
)
{
if
(
"
reset
"
in
this
.
_times
)
{
return
Promise
.
resolve
(
this
.
_times
.
reset
)
;
}
return
Promise
.
resolve
(
undefined
)
;
}
}
const
PROFILES
=
new
Map
(
)
;
async
function
initProfileAge
(
profile
)
{
let
timesPath
=
PathUtils
.
join
(
profile
FILE_TIMES
)
;
try
{
let
times
=
await
IOUtils
.
readJSON
(
timesPath
)
;
return
new
ProfileAgeImpl
(
profile
times
|
|
{
}
)
;
}
catch
(
e
)
{
return
new
ProfileAgeImpl
(
profile
{
firstUse
:
null
}
)
;
}
}
async
function
ProfileAge
(
profile
)
{
if
(
!
profile
)
{
profile
=
await
PathUtils
.
getProfileDir
(
)
;
}
if
(
PROFILES
.
has
(
profile
)
)
{
return
PROFILES
.
get
(
profile
)
;
}
let
promise
=
initProfileAge
(
profile
)
;
PROFILES
.
set
(
profile
promise
)
;
return
promise
;
}
