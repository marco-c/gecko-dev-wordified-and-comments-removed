"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ProfileAge
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
function
getElapsedTimeInDays
(
aStartDate
aEndDate
)
{
return
TelemetryUtils
.
millisecondsToDays
(
aEndDate
-
aStartDate
)
;
}
var
ProfileAge
=
function
(
profile
log
)
{
this
.
profilePath
=
profile
|
|
OS
.
Constants
.
Path
.
profileDir
;
if
(
!
this
.
profilePath
)
{
throw
new
Error
(
"
No
profile
directory
.
"
)
;
}
if
(
!
log
)
{
log
=
Log
.
repository
.
getLogger
(
"
Toolkit
.
ProfileAge
"
)
;
}
this
.
_log
=
log
;
}
;
this
.
ProfileAge
.
prototype
=
{
get
created
(
)
{
function
onSuccess
(
times
)
{
if
(
times
.
created
)
{
return
times
.
created
;
}
return
onFailure
.
call
(
this
null
times
)
;
}
function
onFailure
(
err
times
)
{
return
this
.
computeAndPersistCreated
(
times
)
.
then
(
function
onSuccess
(
created
)
{
return
created
;
}
)
;
}
return
this
.
getTimes
(
)
.
then
(
onSuccess
.
bind
(
this
)
onFailure
.
bind
(
this
)
)
;
}
getPath
(
file
)
{
return
OS
.
Path
.
join
(
this
.
profilePath
file
)
;
}
getTimes
(
file
=
"
times
.
json
"
)
{
if
(
this
.
_times
)
{
return
Promise
.
resolve
(
this
.
_times
)
;
}
return
this
.
readTimes
(
file
)
.
then
(
times
=
>
{
return
this
.
_times
=
times
|
|
{
}
;
}
)
;
}
readTimes
(
file
=
"
times
.
json
"
)
{
return
CommonUtils
.
readJSON
(
this
.
getPath
(
file
)
)
;
}
writeTimes
(
contents
file
=
"
times
.
json
"
)
{
return
CommonUtils
.
writeJSON
(
contents
this
.
getPath
(
file
)
)
;
}
computeAndPersistCreated
(
existingContents
file
=
"
times
.
json
"
)
{
let
path
=
this
.
getPath
(
file
)
;
function
onOldest
(
oldest
)
{
let
contents
=
existingContents
|
|
{
}
;
contents
.
created
=
oldest
;
this
.
_times
=
contents
;
Services
.
telemetry
.
scalarSet
(
"
telemetry
.
profile_directory_scan_date
"
TelemetryUtils
.
millisecondsToDays
(
Date
.
now
(
)
)
)
return
this
.
writeTimes
(
contents
path
)
.
then
(
function
onSuccess
(
)
{
return
oldest
;
}
)
;
}
return
this
.
getOldestProfileTimestamp
(
)
.
then
(
onOldest
.
bind
(
this
)
)
;
}
getOldestProfileTimestamp
(
)
{
let
self
=
this
;
let
start
=
Date
.
now
(
)
;
let
oldest
=
start
+
1000
;
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
this
.
profilePath
)
;
self
.
_log
.
debug
(
"
Iterating
over
profile
"
+
this
.
profilePath
)
;
if
(
!
iterator
)
{
throw
new
Error
(
"
Unable
to
fetch
oldest
profile
entry
:
no
profile
iterator
.
"
)
;
}
Services
.
telemetry
.
scalarAdd
(
"
telemetry
.
profile_directory_scans
"
1
)
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
PROFILE_DIRECTORY_FILE_AGE
"
)
;
function
onEntry
(
entry
)
{
function
onStatSuccess
(
info
)
{
let
date
=
info
.
winBirthDate
|
|
info
.
macBirthDate
;
if
(
!
date
|
|
!
date
.
getTime
(
)
)
{
self
.
_log
.
debug
(
"
No
birth
date
.
Using
mtime
.
"
)
;
date
=
info
.
lastModificationDate
;
}
if
(
date
)
{
let
timestamp
=
date
.
getTime
(
)
;
let
age_in_days
=
Math
.
max
(
0
getElapsedTimeInDays
(
timestamp
start
)
)
;
histogram
.
add
(
age_in_days
)
;
self
.
_log
.
debug
(
"
Using
date
:
"
+
entry
.
path
+
"
=
"
+
date
)
;
if
(
timestamp
<
oldest
)
{
oldest
=
timestamp
;
}
}
}
function
onStatFailure
(
e
)
{
self
.
_log
.
debug
(
"
Stat
failure
"
e
)
;
}
return
OS
.
File
.
stat
(
entry
.
path
)
.
then
(
onStatSuccess
onStatFailure
)
;
}
let
promise
=
iterator
.
forEach
(
onEntry
)
;
function
onSuccess
(
)
{
iterator
.
close
(
)
;
return
oldest
;
}
function
onFailure
(
reason
)
{
iterator
.
close
(
)
;
throw
new
Error
(
"
Unable
to
fetch
oldest
profile
entry
:
"
+
reason
)
;
}
return
promise
.
then
(
onSuccess
onFailure
)
;
}
recordProfileReset
(
time
=
Date
.
now
(
)
file
=
"
times
.
json
"
)
{
return
this
.
getTimes
(
file
)
.
then
(
times
=
>
{
times
.
reset
=
time
;
return
this
.
writeTimes
(
times
file
)
;
}
)
;
}
get
reset
(
)
{
return
this
.
getTimes
(
)
.
then
(
times
=
>
times
.
reset
)
;
}
}
;
