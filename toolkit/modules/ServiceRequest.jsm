"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
XMLHttpRequest
"
]
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
ProxyService
"
"
mozilla
.
org
/
network
/
protocol
-
proxy
-
service
;
1
"
"
nsIProtocolProxyService
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ExtensionPreferencesManager
:
"
resource
:
/
/
gre
/
modules
/
ExtensionPreferencesManager
.
jsm
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
ServiceRequest
"
]
;
const
PROXY_CONFIG_TYPES
=
[
"
direct
"
"
manual
"
"
pac
"
"
unused
"
"
wpad
"
"
system
"
]
;
function
recordEvent
(
service
source
=
{
}
)
{
try
{
Services
.
telemetry
.
setEventRecordingEnabled
(
"
service_request
"
true
)
;
Services
.
telemetry
.
recordEvent
(
"
service_request
"
"
bypass
"
"
proxy_info
"
service
source
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
async
function
getControllingExtension
(
)
{
if
(
!
WebExtensionPolicy
.
getActiveExtensions
(
)
.
some
(
p
=
>
p
.
permissions
.
includes
(
"
proxy
"
)
)
)
{
return
undefined
;
}
let
setting
=
await
ExtensionPreferencesManager
.
getSetting
(
"
proxy
.
settings
"
)
;
return
setting
?
.
id
;
}
async
function
getProxySource
(
proxyInfo
)
{
if
(
proxyInfo
.
sourceId
)
{
return
{
source
:
proxyInfo
.
sourceId
type
:
"
api
"
}
;
}
let
type
=
PROXY_CONFIG_TYPES
[
ProxyService
.
proxyConfigType
]
|
|
"
unknown
"
;
if
(
Services
.
policies
.
status
=
=
=
Services
.
policies
.
ACTIVE
)
{
let
policies
=
Services
.
policies
.
getActivePolicies
(
)
?
.
filter
(
p
=
>
p
.
Proxy
)
;
if
(
policies
?
.
length
)
{
return
{
source
:
"
policy
"
type
}
;
}
}
let
source
=
await
getControllingExtension
(
)
;
return
{
source
:
source
|
|
"
prefs
"
type
}
;
}
class
ServiceRequest
extends
XMLHttpRequest
{
constructor
(
options
)
{
super
(
options
)
;
}
open
(
method
url
options
)
{
super
.
open
(
method
url
true
)
;
if
(
super
.
channel
instanceof
Ci
.
nsIHttpChannelInternal
)
{
let
internal
=
super
.
channel
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
;
internal
.
beConservative
=
true
;
if
(
options
?
.
bypassProxy
&
&
this
.
bypassProxyEnabled
)
{
internal
.
bypassProxy
=
this
.
bypassProxyEnabled
;
}
}
}
get
bypassProxy
(
)
{
let
{
channel
}
=
this
;
return
channel
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
.
bypassProxy
;
}
get
isProxied
(
)
{
let
{
channel
}
=
this
;
return
!
!
(
channel
instanceof
Ci
.
nsIProxiedChannel
&
&
channel
.
proxyInfo
)
;
}
get
bypassProxyEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
network
.
proxy
.
allow_bypass
"
true
)
;
}
static
async
logProxySource
(
channel
service
)
{
if
(
channel
.
proxyInfo
)
{
let
source
=
await
getProxySource
(
channel
.
proxyInfo
)
;
recordEvent
(
service
source
)
;
}
}
}
