var
EXPORTED_SYMBOLS
=
[
"
FirstStartup
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
Normandy
:
"
resource
:
/
/
normandy
/
Normandy
.
jsm
"
TaskScheduler
:
"
resource
:
/
/
gre
/
modules
/
TaskScheduler
.
jsm
"
}
)
;
const
PREF_TIMEOUT
=
"
first
-
startup
.
timeout
"
;
var
FirstStartup
=
{
NOT_STARTED
:
0
IN_PROGRESS
:
1
TIMED_OUT
:
2
SUCCESS
:
3
UNSUPPORTED
:
4
_state
:
0
init
(
)
{
this
.
_state
=
this
.
IN_PROGRESS
;
const
timeout
=
Services
.
prefs
.
getIntPref
(
PREF_TIMEOUT
30000
)
;
let
startingTime
=
Date
.
now
(
)
;
let
initialized
=
false
;
let
promises
=
[
]
;
if
(
AppConstants
.
MOZ_NORMANDY
)
{
promises
.
push
(
lazy
.
Normandy
.
init
(
{
runAsync
:
false
}
)
)
;
}
if
(
AppConstants
.
MOZ_UPDATE_AGENT
)
{
promises
.
push
(
lazy
.
TaskScheduler
.
deleteAllTasks
(
)
.
catch
(
(
)
=
>
{
}
)
)
;
}
if
(
promises
.
length
)
{
Promise
.
all
(
promises
)
.
then
(
(
)
=
>
(
initialized
=
true
)
)
;
this
.
elapsed
=
0
;
Services
.
tm
.
spinEventLoopUntil
(
"
FirstStartup
.
jsm
:
init
"
(
)
=
>
{
this
.
elapsed
=
Date
.
now
(
)
-
startingTime
;
if
(
this
.
elapsed
>
=
timeout
)
{
this
.
_state
=
this
.
TIMED_OUT
;
return
true
;
}
else
if
(
initialized
)
{
this
.
_state
=
this
.
SUCCESS
;
return
true
;
}
return
false
;
}
)
;
}
else
{
this
.
_state
=
this
.
UNSUPPORTED
;
}
}
get
state
(
)
{
return
this
.
_state
;
}
}
;
