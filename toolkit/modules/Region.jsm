"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
Region
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
RemoteSettings
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
LocationHelper
:
"
resource
:
/
/
gre
/
modules
/
LocationHelper
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
wifiScanningEnabled
"
"
browser
.
region
.
network
.
scan
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
networkTimeout
"
"
browser
.
region
.
timeout
"
5000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
retryTimeout
"
"
browser
.
region
.
retry
-
timeout
"
60
*
60
*
1000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
loggingEnabled
"
"
browser
.
region
.
log
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
cacheBustEnabled
"
"
browser
.
region
.
update
.
enabled
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
updateDebounce
"
"
browser
.
region
.
update
.
debounce
"
60
*
60
*
24
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
lastUpdated
"
"
browser
.
region
.
update
.
updated
"
0
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
localGeocodingEnabled
"
"
browser
.
region
.
local
-
geocoding
"
false
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
timerManager
"
"
mozilla
.
org
/
updates
/
timer
-
manager
;
1
"
"
nsIUpdateTimerManager
"
)
;
const
log
=
console
.
createInstance
(
{
prefix
:
"
Region
.
jsm
"
maxLogLevel
:
loggingEnabled
?
"
All
"
:
"
Warn
"
}
)
;
const
REGION_PREF
=
"
browser
.
search
.
region
"
;
const
COLLECTION_ID
=
"
regions
"
;
const
GEOLOCATION_TOPIC
=
"
geolocation
-
position
-
events
"
;
const
UPDATE_PREFIX
=
"
browser
.
region
.
update
"
;
const
UPDATE_INTERVAL
=
60
*
60
*
24
*
14
;
const
MAX_RETRIES
=
3
;
const
UPDATE_CHECK_NAME
=
"
region
-
update
-
timer
"
;
const
UPDATE_CHECK_INTERVAL
=
60
*
60
*
24
*
7
;
let
inChildProcess
=
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
;
class
RegionDetector
{
_home
=
null
;
_current
=
null
;
_rsClient
=
null
;
_wifiDataPromise
=
null
;
_retryCount
=
0
;
_initPromise
=
null
;
REGION_TOPIC
=
"
browser
-
region
"
;
REGION_UPDATED
=
"
region
-
updated
"
;
TELEMETRY
=
{
SUCCESS
:
0
NO_RESULT
:
1
TIMEOUT
:
2
ERROR
:
3
}
;
async
init
(
)
{
if
(
this
.
_initPromise
)
{
return
this
.
_initPromise
;
}
if
(
cacheBustEnabled
&
&
!
inChildProcess
)
{
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
timerManager
.
registerTimer
(
UPDATE_CHECK_NAME
(
)
=
>
this
.
_updateTimer
(
)
UPDATE_CHECK_INTERVAL
)
;
}
)
;
}
let
promises
=
[
]
;
this
.
_home
=
Services
.
prefs
.
getCharPref
(
REGION_PREF
null
)
;
if
(
!
this
.
_home
&
&
!
inChildProcess
)
{
promises
.
push
(
this
.
_idleDispatch
(
(
)
=
>
this
.
_fetchRegion
(
)
)
)
;
}
if
(
localGeocodingEnabled
&
&
!
inChildProcess
)
{
promises
.
push
(
this
.
_idleDispatch
(
(
)
=
>
this
.
_setupRemoteSettings
(
)
)
)
;
}
return
(
this
.
_initPromise
=
Promise
.
all
(
promises
)
)
;
}
get
home
(
)
{
return
this
.
_home
;
}
get
current
(
)
{
return
this
.
_current
;
}
async
_fetchRegion
(
)
{
if
(
this
.
_retryCount
>
=
MAX_RETRIES
)
{
return
null
;
}
let
startTime
=
Date
.
now
(
)
;
let
telemetryResult
=
this
.
TELEMETRY
.
SUCCESS
;
let
result
=
null
;
try
{
result
=
await
this
.
_getRegion
(
)
;
}
catch
(
err
)
{
telemetryResult
=
this
.
TELEMETRY
[
err
.
message
]
|
|
this
.
TELEMETRY
.
ERROR
;
log
.
error
(
"
Failed
to
fetch
region
"
err
)
;
if
(
retryTimeout
)
{
this
.
_retryCount
+
+
;
setTimeout
(
(
)
=
>
{
Services
.
tm
.
idleDispatchToMainThread
(
this
.
_fetchRegion
.
bind
(
this
)
)
;
}
retryTimeout
)
;
}
}
let
took
=
Date
.
now
(
)
-
startTime
;
if
(
result
)
{
await
this
.
_storeRegion
(
result
)
;
}
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_FETCH_TIME_MS
"
)
.
add
(
took
)
;
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_FETCH_RESULT
"
)
.
add
(
telemetryResult
)
;
return
result
;
}
async
_storeRegion
(
region
)
{
let
prefix
=
"
SEARCH_SERVICE
"
;
let
isTimezoneUS
=
isUSTimezone
(
)
;
if
(
region
!
=
"
US
"
|
|
isTimezoneUS
)
{
this
.
_setCurrentRegion
(
region
true
)
;
}
if
(
region
=
=
"
US
"
&
&
!
isTimezoneUS
)
{
log
.
info
(
"
storeRegion
mismatch
-
US
Region
non
-
US
timezone
"
)
;
Services
.
telemetry
.
getHistogramById
(
{
prefix
}
_US_COUNTRY_MISMATCHED_TIMEZONE
)
.
add
(
1
)
;
}
if
(
region
!
=
"
US
"
&
&
isTimezoneUS
)
{
log
.
info
(
"
storeRegion
mismatch
-
non
-
US
Region
US
timezone
"
)
;
Services
.
telemetry
.
getHistogramById
(
{
prefix
}
_US_TIMEZONE_MISMATCHED_COUNTRY
)
.
add
(
1
)
;
}
let
platformCC
=
await
Services
.
sysinfo
.
countryCode
;
if
(
platformCC
)
{
let
probeUSMismatched
probeNonUSMismatched
;
switch
(
AppConstants
.
platform
)
{
case
"
macosx
"
:
probeUSMismatched
=
{
prefix
}
_US_COUNTRY_MISMATCHED_PLATFORM_OSX
;
probeNonUSMismatched
=
{
prefix
}
_NONUS_COUNTRY_MISMATCHED_PLATFORM_OSX
;
break
;
case
"
win
"
:
probeUSMismatched
=
{
prefix
}
_US_COUNTRY_MISMATCHED_PLATFORM_WIN
;
probeNonUSMismatched
=
{
prefix
}
_NONUS_COUNTRY_MISMATCHED_PLATFORM_WIN
;
break
;
default
:
log
.
error
(
"
Platform
"
+
Services
.
appinfo
.
OS
+
"
has
system
country
code
but
no
search
service
telemetry
probes
"
)
;
break
;
}
if
(
probeUSMismatched
&
&
probeNonUSMismatched
)
{
if
(
region
=
=
"
US
"
|
|
platformCC
=
=
"
US
"
)
{
Services
.
telemetry
.
getHistogramById
(
probeUSMismatched
)
.
add
(
region
!
=
platformCC
)
;
}
else
{
Services
.
telemetry
.
getHistogramById
(
probeNonUSMismatched
)
.
add
(
region
!
=
platformCC
)
;
}
}
}
}
_setCurrentRegion
(
region
=
"
"
)
{
log
.
info
(
"
Setting
current
region
:
"
region
)
;
this
.
_current
=
region
;
let
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
let
prefs
=
Services
.
prefs
;
prefs
.
setIntPref
(
{
UPDATE_PREFIX
}
.
updated
now
)
;
let
interval
=
prefs
.
getIntPref
(
{
UPDATE_PREFIX
}
.
interval
UPDATE_INTERVAL
)
;
let
seenRegion
=
prefs
.
getCharPref
(
{
UPDATE_PREFIX
}
.
region
null
)
;
let
firstSeen
=
prefs
.
getIntPref
(
{
UPDATE_PREFIX
}
.
first
-
seen
0
)
;
if
(
!
this
.
_home
)
{
this
.
_setHomeRegion
(
region
)
;
}
else
if
(
region
!
=
this
.
_home
&
&
region
!
=
seenRegion
)
{
prefs
.
setCharPref
(
{
UPDATE_PREFIX
}
.
region
region
)
;
prefs
.
setIntPref
(
{
UPDATE_PREFIX
}
.
first
-
seen
now
)
;
}
else
if
(
region
!
=
this
.
_home
&
&
region
=
=
seenRegion
)
{
if
(
now
>
=
firstSeen
+
interval
)
{
this
.
_setHomeRegion
(
region
)
;
}
}
else
{
prefs
.
clearUserPref
(
{
UPDATE_PREFIX
}
.
region
)
;
prefs
.
clearUserPref
(
{
UPDATE_PREFIX
}
.
first
-
seen
)
;
}
}
_createSupportsString
(
data
)
{
let
string
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
string
.
data
=
data
;
return
string
;
}
_setHomeRegion
(
region
notify
=
true
)
{
if
(
region
=
=
this
.
_home
)
{
return
;
}
log
.
info
(
"
Updating
home
region
:
"
region
)
;
this
.
_home
=
region
;
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
region
"
region
)
;
if
(
notify
)
{
Services
.
obs
.
notifyObservers
(
this
.
_createSupportsString
(
region
)
this
.
REGION_TOPIC
this
.
REGION_UPDATED
)
;
}
}
async
_getRegion
(
)
{
log
.
info
(
"
_getRegion
called
"
)
;
let
fetchOpts
=
{
headers
:
{
"
Content
-
Type
"
:
"
application
/
json
"
}
credentials
:
"
omit
"
}
;
if
(
wifiScanningEnabled
)
{
let
wifiData
=
await
this
.
_fetchWifiData
(
)
;
if
(
wifiData
)
{
let
postData
=
JSON
.
stringify
(
{
wifiAccessPoints
:
wifiData
}
)
;
log
.
info
(
"
Sending
wifi
details
:
"
wifiData
)
;
fetchOpts
.
method
=
"
POST
"
;
fetchOpts
.
body
=
postData
;
}
}
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
browser
.
region
.
network
.
url
"
)
;
log
.
info
(
"
_getRegion
url
is
:
"
url
)
;
if
(
!
url
)
{
return
null
;
}
try
{
let
req
=
await
this
.
_fetchTimeout
(
url
fetchOpts
networkTimeout
)
;
let
res
=
await
req
.
json
(
)
;
log
.
info
(
"
_getRegion
returning
"
res
.
country_code
)
;
return
res
.
country_code
;
}
catch
(
err
)
{
log
.
error
(
"
Error
fetching
region
"
err
)
;
let
errCode
=
err
.
message
in
this
.
TELEMETRY
?
err
.
message
:
"
NO_RESULT
"
;
throw
new
Error
(
errCode
)
;
}
}
async
_setupRemoteSettings
(
)
{
log
.
info
(
"
_setupRemoteSettings
"
)
;
this
.
_rsClient
=
RemoteSettings
(
COLLECTION_ID
)
;
this
.
_rsClient
.
on
(
"
sync
"
this
.
_onRegionFilesSync
.
bind
(
this
)
)
;
await
this
.
_ensureRegionFilesDownloaded
(
)
;
Services
.
obs
.
addObserver
(
this
GEOLOCATION_TOPIC
)
;
}
async
_onRegionFilesSync
(
{
data
:
{
deleted
}
}
)
{
log
.
info
(
"
_onRegionFilesSync
"
)
;
const
toDelete
=
deleted
.
filter
(
d
=
>
d
.
attachment
)
;
await
Promise
.
all
(
toDelete
.
map
(
entry
=
>
this
.
_rsClient
.
attachments
.
delete
(
entry
)
)
)
;
await
this
.
_ensureRegionFilesDownloaded
(
)
;
}
async
_ensureRegionFilesDownloaded
(
)
{
log
.
info
(
"
_ensureRegionFilesDownloaded
"
)
;
let
records
=
(
await
this
.
_rsClient
.
get
(
)
)
.
filter
(
d
=
>
d
.
attachment
)
;
log
.
info
(
"
_ensureRegionFilesDownloaded
"
records
)
;
if
(
!
records
.
length
)
{
log
.
info
(
"
_ensureRegionFilesDownloaded
:
Nothing
to
download
"
)
;
return
;
}
let
opts
=
{
useCache
:
true
}
;
await
Promise
.
all
(
records
.
map
(
r
=
>
this
.
_rsClient
.
attachments
.
download
(
r
opts
)
)
)
;
log
.
info
(
"
_ensureRegionFilesDownloaded
complete
"
)
;
this
.
_regionFilesReady
=
true
;
}
async
_fetchAttachment
(
id
)
{
let
record
=
(
await
this
.
_rsClient
.
get
(
{
filters
:
{
id
}
}
)
)
.
pop
(
)
;
let
{
buffer
}
=
await
this
.
_rsClient
.
attachments
.
download
(
record
{
useCache
:
true
}
)
;
let
text
=
new
TextDecoder
(
"
utf
-
8
"
)
.
decode
(
buffer
)
;
return
JSON
.
parse
(
text
)
;
}
async
_getPlainMap
(
)
{
return
this
.
_fetchAttachment
(
"
world
"
)
;
}
async
_getBufferedMap
(
)
{
return
this
.
_fetchAttachment
(
"
world
-
buffered
"
)
;
}
async
_getLocation
(
)
{
log
.
info
(
"
_getLocation
called
"
)
;
let
fetchOpts
=
{
headers
:
{
"
Content
-
Type
"
:
"
application
/
json
"
}
}
;
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
geo
.
provider
.
network
.
url
"
)
;
let
req
=
await
this
.
_fetchTimeout
(
url
fetchOpts
networkTimeout
)
;
let
result
=
await
req
.
json
(
)
;
log
.
info
(
"
_getLocation
returning
"
result
)
;
return
result
;
}
async
_getRegionLocally
(
)
{
let
{
location
}
=
await
this
.
_getLocation
(
)
;
return
this
.
_geoCode
(
location
)
;
}
async
_geoCode
(
location
)
{
let
plainMap
=
await
this
.
_getPlainMap
(
)
;
let
polygons
=
this
.
_getPolygonsContainingPoint
(
location
plainMap
)
;
if
(
polygons
.
length
=
=
1
)
{
log
.
info
(
"
Found
in
single
exact
region
"
)
;
return
polygons
[
0
]
.
properties
.
alpha2
;
}
if
(
polygons
.
length
)
{
log
.
info
(
"
Found
in
"
polygons
.
length
"
overlapping
exact
regions
"
)
;
return
this
.
_findFurthest
(
location
polygons
)
;
}
let
bufferedMap
=
await
this
.
_getBufferedMap
(
)
;
polygons
=
this
.
_getPolygonsContainingPoint
(
location
bufferedMap
)
;
if
(
polygons
.
length
=
=
=
1
)
{
log
.
info
(
"
Found
in
single
buffered
region
"
)
;
return
polygons
[
0
]
.
properties
.
alpha2
;
}
if
(
polygons
.
length
)
{
log
.
info
(
"
Found
in
"
polygons
.
length
"
overlapping
buffered
regions
"
)
;
let
regions
=
polygons
.
map
(
polygon
=
>
polygon
.
properties
.
alpha2
)
;
let
unBufferedRegions
=
plainMap
.
features
.
filter
(
feature
=
>
regions
.
includes
(
feature
.
properties
.
alpha2
)
)
;
return
this
.
_findClosest
(
location
unBufferedRegions
)
;
}
return
null
;
}
_getPolygonsContainingPoint
(
point
map
)
{
let
polygons
=
[
]
;
for
(
const
feature
of
map
.
features
)
{
let
coords
=
feature
.
geometry
.
coordinates
;
if
(
feature
.
geometry
.
type
=
=
=
"
Polygon
"
)
{
if
(
this
.
_polygonInPoint
(
point
coords
[
0
]
)
)
{
polygons
.
push
(
feature
)
;
}
}
else
if
(
feature
.
geometry
.
type
=
=
=
"
MultiPolygon
"
)
{
for
(
const
innerCoords
of
coords
)
{
if
(
this
.
_polygonInPoint
(
point
innerCoords
[
0
]
)
)
{
polygons
.
push
(
feature
)
;
}
}
}
}
return
polygons
;
}
_findFurthest
(
location
regions
)
{
let
max
=
{
distance
:
0
region
:
null
}
;
this
.
_traverse
(
regions
(
{
lat
lng
region
}
)
=
>
{
let
distance
=
this
.
_distanceBetween
(
location
{
lng
lat
}
)
;
if
(
distance
>
max
.
distance
)
{
max
=
{
distance
region
}
;
}
}
)
;
return
max
.
region
;
}
_findClosest
(
location
regions
)
{
let
min
=
{
distance
:
Infinity
region
:
null
}
;
this
.
_traverse
(
regions
(
{
lat
lng
region
}
)
=
>
{
let
distance
=
this
.
_distanceBetween
(
location
{
lng
lat
}
)
;
if
(
distance
<
min
.
distance
)
{
min
=
{
distance
region
}
;
}
}
)
;
return
min
.
region
;
}
_traverse
(
regions
fun
)
{
for
(
const
region
of
regions
)
{
if
(
region
.
geometry
.
type
=
=
=
"
Polygon
"
)
{
for
(
const
[
lng
lat
]
of
region
.
geometry
.
coordinates
[
0
]
)
{
fun
(
{
lat
lng
region
:
region
.
properties
.
alpha2
}
)
;
}
}
else
if
(
region
.
geometry
.
type
=
=
=
"
MultiPolygon
"
)
{
for
(
const
innerCoords
of
region
.
geometry
.
coordinates
)
{
for
(
const
[
lng
lat
]
of
innerCoords
[
0
]
)
{
fun
(
{
lat
lng
region
:
region
.
properties
.
alpha2
}
)
;
}
}
}
}
}
_polygonInPoint
(
{
lng
lat
}
poly
)
{
let
inside
=
false
;
for
(
let
i
=
0
j
=
poly
.
length
-
1
;
i
<
poly
.
length
;
j
=
i
+
+
)
{
let
xi
=
poly
[
i
]
[
0
]
;
let
yi
=
poly
[
i
]
[
1
]
;
let
xj
=
poly
[
j
]
[
0
]
;
let
yj
=
poly
[
j
]
[
1
]
;
let
intersect
=
yi
>
lat
!
=
yj
>
lat
&
&
lng
<
(
(
xj
-
xi
)
*
(
lat
-
yi
)
)
/
(
yj
-
yi
)
+
xi
;
if
(
intersect
)
{
inside
=
!
inside
;
}
}
return
inside
;
}
_distanceBetween
(
p1
p2
)
{
return
Math
.
hypot
(
p2
.
lng
-
p1
.
lng
p2
.
lat
-
p1
.
lat
)
;
}
async
_fetchTimeout
(
url
opts
timeout
)
{
let
controller
=
new
AbortController
(
)
;
opts
.
signal
=
controller
.
signal
;
return
Promise
.
race
(
[
fetch
(
url
opts
)
this
.
_timeout
(
timeout
controller
)
]
)
;
}
async
_timeout
(
timeout
controller
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
timeout
)
)
;
if
(
controller
)
{
setTimeout
(
(
)
=
>
controller
.
abort
(
)
0
)
;
}
throw
new
Error
(
"
TIMEOUT
"
)
;
}
async
_fetchWifiData
(
)
{
log
.
info
(
"
fetchWifiData
called
"
)
;
this
.
wifiService
=
Cc
[
"
mozilla
.
org
/
wifi
/
monitor
;
1
"
]
.
getService
(
Ci
.
nsIWifiMonitor
)
;
this
.
wifiService
.
startWatching
(
this
)
;
return
new
Promise
(
resolve
=
>
{
this
.
_wifiDataPromise
=
resolve
;
}
)
;
}
_needsUpdateCheck
(
)
{
let
sinceUpdate
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
-
lastUpdated
;
let
needsUpdate
=
sinceUpdate
>
=
updateDebounce
;
if
(
!
needsUpdate
)
{
log
.
info
(
Ignoring
update
check
last
seen
{
sinceUpdate
}
seconds
ago
)
;
}
return
needsUpdate
;
}
_idleDispatch
(
fun
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
tm
.
idleDispatchToMainThread
(
fun
(
)
.
then
(
resolve
)
)
;
}
)
;
}
async
_updateTimer
(
)
{
if
(
this
.
_needsUpdateCheck
(
)
)
{
await
this
.
_fetchRegion
(
)
;
}
}
async
_seenLocation
(
location
)
{
log
.
info
(
Got
location
update
:
{
location
.
lat
}
:
{
location
.
lng
}
)
;
if
(
this
.
_needsUpdateCheck
(
)
)
{
let
region
=
await
this
.
_geoCode
(
location
)
;
if
(
region
)
{
this
.
_setCurrentRegion
(
region
)
;
}
}
}
onChange
(
accessPoints
)
{
log
.
info
(
"
onChange
called
"
)
;
if
(
!
accessPoints
|
|
!
this
.
_wifiDataPromise
)
{
return
;
}
if
(
this
.
wifiService
)
{
this
.
wifiService
.
stopWatching
(
this
)
;
this
.
wifiService
=
null
;
}
if
(
this
.
_wifiDataPromise
)
{
let
data
=
LocationHelper
.
formatWifiAccessPoints
(
accessPoints
)
;
this
.
_wifiDataPromise
(
data
)
;
this
.
_wifiDataPromise
=
null
;
}
}
observe
(
aSubject
aTopic
aData
)
{
log
.
info
(
Observed
{
aTopic
}
)
;
switch
(
aTopic
)
{
case
GEOLOCATION_TOPIC
:
let
coords
=
aSubject
.
coords
|
|
aSubject
.
wrappedJSObject
.
coords
;
this
.
_seenLocation
(
{
lat
:
coords
.
latitude
lng
:
coords
.
longitude
}
)
;
break
;
}
}
newInstance
(
)
{
return
new
RegionDetector
(
)
;
}
}
let
Region
=
new
RegionDetector
(
)
;
Region
.
init
(
)
;
function
isUSTimezone
(
)
{
let
UTCOffset
=
new
Date
(
)
.
getTimezoneOffset
(
)
;
return
UTCOffset
>
=
150
&
&
UTCOffset
<
=
600
;
}
