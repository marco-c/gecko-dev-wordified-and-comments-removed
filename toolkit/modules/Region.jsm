"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
Region
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
LocationHelper
:
"
resource
:
/
/
gre
/
modules
/
LocationHelper
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
wifiScanningEnabled
"
"
browser
.
region
.
network
.
scan
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
regionFetchTimeout
"
"
browser
.
region
.
timeout
"
5000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
loggingEnabled
"
"
browser
.
region
.
log
"
false
)
;
const
log
=
console
.
createInstance
(
{
prefix
:
"
Region
.
jsm
"
maxLogLevel
:
loggingEnabled
?
"
All
"
:
"
Warn
"
}
)
;
function
timeout
(
ms
)
{
return
new
Promise
(
resolve
=
>
setTimeout
(
resolve
ms
)
)
;
}
class
RegionDetector
{
wifiDataPromise
=
null
;
fetchController
=
null
;
async
getHomeRegion
(
)
{
return
Promise
.
race
(
[
this
.
_getRegion
(
)
this
.
_timeout
(
)
]
)
;
}
async
_getRegion
(
)
{
log
.
info
(
"
getRegion
called
"
)
;
this
.
fetchController
=
new
AbortController
(
)
;
let
fetchOpts
=
{
headers
:
{
"
Content
-
Type
"
:
"
application
/
json
"
}
credentials
:
"
omit
"
signal
:
this
.
fetchController
.
signal
}
;
if
(
wifiScanningEnabled
)
{
let
wifiData
=
await
this
.
_fetchWifiData
(
)
;
if
(
wifiData
)
{
let
postData
=
JSON
.
stringify
(
{
wifiAccessPoints
:
wifiData
}
)
;
log
.
info
(
"
Sending
wifi
details
:
"
wifiData
)
;
fetchOpts
.
method
=
"
POST
"
;
fetchOpts
.
body
=
postData
;
}
}
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
browser
.
region
.
network
.
url
"
)
;
let
req
=
await
fetch
(
url
fetchOpts
)
;
try
{
let
res
=
await
req
.
json
(
)
;
this
.
fetchController
=
null
;
log
.
info
(
"
getRegion
returning
"
+
res
.
country_code
)
;
return
{
country_code
:
res
.
country_code
}
;
}
catch
(
err
)
{
log
.
error
(
"
Error
fetching
region
"
err
)
;
throw
new
Error
(
"
region
-
fetch
-
no
-
result
"
)
;
}
}
async
_timeout
(
)
{
await
timeout
(
regionFetchTimeout
)
;
if
(
this
.
fetchController
)
{
this
.
fetchController
.
abort
(
)
;
}
throw
new
Error
(
"
region
-
fetch
-
timeout
"
)
;
}
async
_fetchWifiData
(
)
{
log
.
info
(
"
fetchWifiData
called
"
)
;
this
.
wifiService
=
Cc
[
"
mozilla
.
org
/
wifi
/
monitor
;
1
"
]
.
getService
(
Ci
.
nsIWifiMonitor
)
;
this
.
wifiService
.
startWatching
(
this
)
;
return
new
Promise
(
resolve
=
>
{
this
.
wifiDataPromise
=
resolve
;
}
)
;
}
onChange
(
accessPoints
)
{
log
.
info
(
"
onChange
called
"
)
;
if
(
!
accessPoints
|
|
!
this
.
wifiDataPromise
)
{
return
;
}
if
(
this
.
wifiService
)
{
this
.
wifiService
.
stopWatching
(
this
)
;
this
.
wifiService
=
null
;
}
if
(
this
.
wifiDataPromise
)
{
let
data
=
LocationHelper
.
formatWifiAccessPoints
(
accessPoints
)
;
this
.
wifiDataPromise
(
data
)
;
this
.
wifiDataPromise
=
null
;
}
}
}
let
Region
=
new
RegionDetector
(
)
;
