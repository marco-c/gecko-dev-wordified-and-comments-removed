"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
Region
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
LocationHelper
:
"
resource
:
/
/
gre
/
modules
/
LocationHelper
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
wifiScanningEnabled
"
"
browser
.
region
.
network
.
scan
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
networkTimeout
"
"
browser
.
region
.
timeout
"
5000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
loggingEnabled
"
"
browser
.
region
.
log
"
false
)
;
const
log
=
console
.
createInstance
(
{
prefix
:
"
Region
.
jsm
"
maxLogLevel
:
loggingEnabled
?
"
All
"
:
"
Warn
"
}
)
;
const
REGION_PREF
=
"
browser
.
search
.
region
"
;
class
RegionDetector
{
wifiDataPromise
=
null
;
REGION_TOPIC
=
"
browser
-
region
"
;
REGION_UPDATED
=
"
region
-
updated
"
;
TELEMETRY
=
{
SUCCESS
:
0
NO_RESULT
:
1
TIMEOUT
:
2
ERROR
:
3
}
;
init
(
)
{
let
region
=
Services
.
prefs
.
getCharPref
(
REGION_PREF
null
)
;
if
(
!
region
)
{
Services
.
tm
.
idleDispatchToMainThread
(
this
.
_fetchRegion
.
bind
(
this
)
)
;
}
this
.
_home
=
region
;
}
get
home
(
)
{
return
this
.
_home
;
}
async
_fetchRegion
(
)
{
let
startTime
=
Date
.
now
(
)
;
let
telemetryResult
=
this
.
TELEMETRY
.
SUCCESS
;
let
result
=
null
;
try
{
result
=
await
this
.
_getRegion
(
)
;
}
catch
(
err
)
{
telemetryResult
=
this
.
TELEMETRY
[
err
.
message
]
|
|
this
.
TELEMETRY
.
ERROR
;
log
.
error
(
"
Failed
to
fetch
region
"
err
)
;
}
let
took
=
Date
.
now
(
)
-
startTime
;
if
(
result
)
{
await
this
.
_storeRegion
(
result
)
;
}
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_FETCH_TIME_MS
"
)
.
add
(
took
)
;
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_FETCH_RESULT
"
)
.
add
(
telemetryResult
)
;
return
result
;
}
async
_storeRegion
(
region
)
{
let
prefix
=
"
SEARCH_SERVICE
"
;
let
isTimezoneUS
=
isUSTimezone
(
)
;
if
(
region
!
=
"
US
"
|
|
isTimezoneUS
)
{
log
.
info
(
"
Saving
home
region
:
"
region
)
;
this
.
_setRegion
(
region
true
)
;
}
if
(
region
=
=
"
US
"
&
&
!
isTimezoneUS
)
{
log
.
info
(
"
storeRegion
mismatch
-
US
Region
non
-
US
timezone
"
)
;
Services
.
telemetry
.
getHistogramById
(
{
prefix
}
_US_COUNTRY_MISMATCHED_TIMEZONE
)
.
add
(
1
)
;
}
if
(
region
!
=
"
US
"
&
&
isTimezoneUS
)
{
log
.
info
(
"
storeRegion
mismatch
-
non
-
US
Region
US
timezone
"
)
;
Services
.
telemetry
.
getHistogramById
(
{
prefix
}
_US_TIMEZONE_MISMATCHED_COUNTRY
)
.
add
(
1
)
;
}
let
platformCC
=
await
Services
.
sysinfo
.
countryCode
;
if
(
platformCC
)
{
let
probeUSMismatched
probeNonUSMismatched
;
switch
(
AppConstants
.
platform
)
{
case
"
macosx
"
:
probeUSMismatched
=
{
prefix
}
_US_COUNTRY_MISMATCHED_PLATFORM_OSX
;
probeNonUSMismatched
=
{
prefix
}
_NONUS_COUNTRY_MISMATCHED_PLATFORM_OSX
;
break
;
case
"
win
"
:
probeUSMismatched
=
{
prefix
}
_US_COUNTRY_MISMATCHED_PLATFORM_WIN
;
probeNonUSMismatched
=
{
prefix
}
_NONUS_COUNTRY_MISMATCHED_PLATFORM_WIN
;
break
;
default
:
log
.
error
(
"
Platform
"
+
Services
.
appinfo
.
OS
+
"
has
system
country
code
but
no
search
service
telemetry
probes
"
)
;
break
;
}
if
(
probeUSMismatched
&
&
probeNonUSMismatched
)
{
if
(
region
=
=
"
US
"
|
|
platformCC
=
=
"
US
"
)
{
Services
.
telemetry
.
getHistogramById
(
probeUSMismatched
)
.
add
(
region
!
=
platformCC
)
;
}
else
{
Services
.
telemetry
.
getHistogramById
(
probeNonUSMismatched
)
.
add
(
region
!
=
platformCC
)
;
}
}
}
}
_setRegion
(
region
=
"
"
notify
=
false
)
{
this
.
_home
=
region
;
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
region
"
region
)
;
if
(
notify
)
{
Services
.
obs
.
notifyObservers
(
null
this
.
REGION_TOPIC
this
.
REGION_UPDATED
region
)
;
}
}
async
_getRegion
(
)
{
log
.
info
(
"
_getRegion
called
"
)
;
let
fetchOpts
=
{
headers
:
{
"
Content
-
Type
"
:
"
application
/
json
"
}
credentials
:
"
omit
"
}
;
if
(
wifiScanningEnabled
)
{
let
wifiData
=
await
this
.
_fetchWifiData
(
)
;
if
(
wifiData
)
{
let
postData
=
JSON
.
stringify
(
{
wifiAccessPoints
:
wifiData
}
)
;
log
.
info
(
"
Sending
wifi
details
:
"
wifiData
)
;
fetchOpts
.
method
=
"
POST
"
;
fetchOpts
.
body
=
postData
;
}
}
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
browser
.
region
.
network
.
url
"
)
;
log
.
info
(
"
_getRegion
url
is
:
"
url
)
;
if
(
!
url
)
{
return
null
;
}
try
{
let
req
=
await
this
.
_fetchTimeout
(
url
fetchOpts
networkTimeout
)
;
let
res
=
await
req
.
json
(
)
;
log
.
info
(
"
_getRegion
returning
"
res
.
country_code
)
;
return
res
.
country_code
;
}
catch
(
err
)
{
log
.
error
(
"
Error
fetching
region
"
err
)
;
throw
new
Error
(
"
NO_RESULT
"
)
;
}
}
async
_getLocation
(
)
{
log
.
info
(
"
_getLocation
called
"
)
;
let
fetchOpts
=
{
headers
:
{
"
Content
-
Type
"
:
"
application
/
json
"
}
}
;
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
geo
.
provider
.
network
.
url
"
)
;
let
req
=
await
this
.
_fetchTimeout
(
url
fetchOpts
networkTimeout
)
;
let
result
=
await
req
.
json
(
)
;
log
.
info
(
"
_getLocation
returning
"
result
)
;
return
result
;
}
async
_getRegionLocally
(
)
{
let
{
location
}
=
await
this
.
_getLocation
(
)
;
return
this
.
_geoCode
(
location
)
;
}
async
_getPlainMap
(
)
{
return
null
;
}
async
_getBufferedMap
(
)
{
return
null
;
}
async
_geoCode
(
location
)
{
let
plainMap
=
await
this
.
_getPlainMap
(
)
;
let
polygons
=
this
.
_getPolygonsContainingPoint
(
location
plainMap
)
;
if
(
polygons
.
length
)
{
return
polygons
[
0
]
.
region
;
}
let
bufferedMap
=
await
this
.
_getBufferedMap
(
)
;
polygons
=
this
.
_getPolygonsContainingPoint
(
location
bufferedMap
)
;
if
(
polygons
.
length
=
=
=
1
)
{
return
polygons
[
0
]
.
region
;
}
if
(
polygons
.
length
>
1
)
{
return
this
.
_findLargestDistance
(
location
polygons
)
;
}
return
null
;
}
_getPolygonsContainingPoint
(
point
map
)
{
let
polygons
=
[
]
;
for
(
const
feature
of
map
.
features
)
{
let
coords
=
feature
.
geometry
.
coordinates
;
if
(
feature
.
geometry
.
type
=
=
=
"
Polygon
"
)
{
if
(
this
.
_polygonInPoint
(
point
coords
[
0
]
)
)
{
polygons
.
push
(
{
coords
:
coords
[
0
]
region
:
feature
.
properties
.
alpha2
}
)
;
}
}
else
if
(
feature
.
geometry
.
type
=
=
=
"
MultiPolygon
"
)
{
for
(
const
innerCoords
of
coords
)
{
if
(
this
.
_polygonInPoint
(
point
innerCoords
[
0
]
)
)
{
polygons
.
push
(
{
coords
:
innerCoords
[
0
]
region
:
feature
.
properties
.
alpha2
}
)
;
}
}
}
}
return
polygons
;
}
_findLargestDistance
(
location
polygons
)
{
let
maxDistance
=
{
distance
:
0
region
:
null
}
;
for
(
const
polygon
of
polygons
)
{
for
(
const
[
lng
lat
]
of
polygon
.
coords
)
{
let
distance
=
this
.
_distanceBetween
(
location
{
lng
lat
}
)
;
if
(
distance
>
maxDistance
.
distance
)
{
maxDistance
=
{
distance
region
:
polygon
.
region
}
;
}
}
}
return
maxDistance
.
region
;
}
_polygonInPoint
(
{
lng
lat
}
poly
)
{
let
inside
=
false
;
for
(
let
i
=
0
j
=
poly
.
length
-
1
;
i
<
poly
.
length
;
j
=
i
+
+
)
{
let
xi
=
poly
[
i
]
[
0
]
;
let
yi
=
poly
[
i
]
[
1
]
;
let
xj
=
poly
[
j
]
[
0
]
;
let
yj
=
poly
[
j
]
[
1
]
;
let
intersect
=
yi
>
lat
!
=
yj
>
lat
&
&
lng
<
(
(
xj
-
xi
)
*
(
lat
-
yi
)
)
/
(
yj
-
yi
)
+
xi
;
if
(
intersect
)
{
inside
=
!
inside
;
}
}
return
inside
;
}
_distanceBetween
(
p1
p2
)
{
return
Math
.
hypot
(
p2
.
lng
-
p1
.
lng
p2
.
lat
-
p1
.
lat
)
;
}
async
_fetchTimeout
(
url
opts
timeout
)
{
let
controller
=
new
AbortController
(
)
;
opts
.
signal
=
controller
.
signal
;
return
Promise
.
race
(
[
fetch
(
url
opts
)
this
.
_timeout
(
timeout
controller
)
]
)
;
}
async
_timeout
(
timeout
controller
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
timeout
)
)
;
if
(
controller
)
{
controller
.
abort
(
)
;
}
throw
new
Error
(
"
TIMEOUT
"
)
;
}
async
_fetchWifiData
(
)
{
log
.
info
(
"
fetchWifiData
called
"
)
;
this
.
wifiService
=
Cc
[
"
mozilla
.
org
/
wifi
/
monitor
;
1
"
]
.
getService
(
Ci
.
nsIWifiMonitor
)
;
this
.
wifiService
.
startWatching
(
this
)
;
return
new
Promise
(
resolve
=
>
{
this
.
wifiDataPromise
=
resolve
;
}
)
;
}
onChange
(
accessPoints
)
{
log
.
info
(
"
onChange
called
"
)
;
if
(
!
accessPoints
|
|
!
this
.
wifiDataPromise
)
{
return
;
}
if
(
this
.
wifiService
)
{
this
.
wifiService
.
stopWatching
(
this
)
;
this
.
wifiService
=
null
;
}
if
(
this
.
wifiDataPromise
)
{
let
data
=
LocationHelper
.
formatWifiAccessPoints
(
accessPoints
)
;
this
.
wifiDataPromise
(
data
)
;
this
.
wifiDataPromise
=
null
;
}
}
}
let
Region
=
new
RegionDetector
(
)
;
Region
.
init
(
)
;
function
isUSTimezone
(
)
{
let
UTCOffset
=
new
Date
(
)
.
getTimezoneOffset
(
)
;
return
UTCOffset
>
=
150
&
&
UTCOffset
<
=
600
;
}
