"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DeferredTask
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
Timer
=
Components
.
Constructor
(
"
mozilla
.
org
/
timer
;
1
"
"
nsITimer
"
"
initWithCallback
"
)
;
var
DeferredTask
=
function
(
aTaskFn
aDelayMs
aIdleTimeoutMs
)
{
this
.
_taskFn
=
aTaskFn
;
this
.
_delayMs
=
aDelayMs
;
this
.
_timeoutMs
=
aIdleTimeoutMs
;
}
;
this
.
DeferredTask
.
prototype
=
{
_taskFn
:
null
_delayMs
:
null
get
isArmed
(
)
{
return
this
.
_armed
;
}
_armed
:
false
get
isRunning
(
)
{
return
!
!
this
.
_runningPromise
;
}
_runningPromise
:
null
_timer
:
null
_startTimer
(
)
{
this
.
_timer
=
new
Timer
(
this
.
_timerCallback
.
bind
(
this
)
this
.
_delayMs
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
arm
(
)
{
if
(
this
.
_finalized
)
{
throw
new
Error
(
"
Unable
to
arm
timer
the
object
has
been
finalized
.
"
)
;
}
this
.
_armed
=
true
;
if
(
!
this
.
_runningPromise
&
&
!
this
.
_timer
)
{
this
.
_startTimer
(
)
;
}
}
disarm
(
)
{
this
.
_armed
=
false
;
if
(
this
.
_timer
)
{
this
.
_timer
.
cancel
(
)
;
this
.
_timer
=
null
;
}
}
finalize
(
)
{
if
(
this
.
_finalized
)
{
throw
new
Error
(
"
The
object
has
been
already
finalized
.
"
)
;
}
this
.
_finalized
=
true
;
if
(
this
.
_timer
)
{
this
.
disarm
(
)
;
this
.
_timerCallback
(
)
;
}
if
(
this
.
_runningPromise
)
{
return
this
.
_runningPromise
;
}
return
Promise
.
resolve
(
)
;
}
_finalized
:
false
_timerCallback
(
)
{
let
runningDeferred
=
PromiseUtils
.
defer
(
)
;
this
.
_timer
=
null
;
this
.
_armed
=
false
;
this
.
_runningPromise
=
runningDeferred
.
promise
;
runningDeferred
.
resolve
(
(
async
(
)
=
>
{
await
this
.
_runTask
(
)
;
if
(
this
.
_armed
)
{
if
(
!
this
.
_finalized
)
{
this
.
_startTimer
(
)
;
}
else
{
this
.
_armed
=
false
;
await
this
.
_runTask
(
)
;
}
}
this
.
_runningPromise
=
null
;
}
)
(
)
.
catch
(
Cu
.
reportError
)
)
;
}
async
_runTask
(
)
{
try
{
if
(
this
.
_finalized
|
|
this
.
_timeoutMs
=
=
=
0
)
{
await
this
.
_taskFn
(
)
;
}
else
{
await
PromiseUtils
.
idleDispatch
(
this
.
_taskFn
this
.
_timeoutMs
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
;
