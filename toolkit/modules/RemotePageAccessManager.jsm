"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
RemotePageAccessManager
"
]
;
let
RemotePageAccessManager
=
{
accessMap
:
{
"
about
:
certerror
"
:
{
RPMSendAsyncMessage
:
[
"
Browser
:
EnableOnlineMode
"
"
Browser
:
ResetSSLPreferences
"
"
GetChangedCertPrefs
"
"
ReportTLSError
"
"
Browser
:
OpenCaptivePortalPage
"
"
Browser
:
SSLErrorGoBack
"
"
Browser
:
PrimeMitm
"
"
Browser
:
ResetEnterpriseRootsPref
"
]
RPMAddMessageListener
:
[
"
*
"
]
RPMRemoveMessageListener
:
[
"
*
"
]
RPMGetFormatURLPref
:
[
"
app
.
support
.
baseURL
"
]
RPMGetBoolPref
:
[
"
security
.
certerrors
.
mitm
.
priming
.
enabled
"
"
security
.
certerrors
.
permanentOverride
"
"
security
.
enterprise_roots
.
auto
-
enabled
"
"
security
.
certerror
.
hideAddException
"
"
security
.
ssl
.
errorReporting
.
automatic
"
"
security
.
ssl
.
errorReporting
.
enabled
"
]
RPMSetBoolPref
:
[
"
security
.
ssl
.
errorReporting
.
automatic
"
"
security
.
tls
.
version
.
enable
-
deprecated
"
]
RPMGetIntPref
:
[
"
services
.
settings
.
clock_skew_seconds
"
"
services
.
settings
.
last_update_seconds
"
]
RPMGetAppBuildID
:
[
"
*
"
]
RPMIsWindowPrivate
:
[
"
*
"
]
RPMAddToHistogram
:
[
"
*
"
]
}
"
about
:
neterror
"
:
{
RPMSendAsyncMessage
:
[
"
Browser
:
EnableOnlineMode
"
"
Browser
:
ResetSSLPreferences
"
"
GetChangedCertPrefs
"
"
ReportTLSError
"
"
Browser
:
OpenCaptivePortalPage
"
"
Browser
:
SSLErrorGoBack
"
"
Browser
:
PrimeMitm
"
"
Browser
:
ResetEnterpriseRootsPref
"
]
RPMAddMessageListener
:
[
"
*
"
]
RPMRemoveMessageListener
:
[
"
*
"
]
RPMGetFormatURLPref
:
[
"
app
.
support
.
baseURL
"
]
RPMGetBoolPref
:
[
"
security
.
certerror
.
hideAddException
"
"
security
.
ssl
.
errorReporting
.
automatic
"
"
security
.
ssl
.
errorReporting
.
enabled
"
"
security
.
tls
.
version
.
enable
-
deprecated
"
"
security
.
certerrors
.
tls
.
version
.
show
-
override
"
]
RPMSetBoolPref
:
[
"
security
.
ssl
.
errorReporting
.
automatic
"
"
security
.
tls
.
version
.
enable
-
deprecated
"
]
RPMPrefIsLocked
:
[
"
security
.
tls
.
version
.
min
"
]
RPMAddToHistogram
:
[
"
*
"
]
}
}
checkAllowAccess
(
aDocument
aFeature
aValue
)
{
let
principal
=
aDocument
.
nodePrincipal
;
if
(
!
principal
)
{
return
false
;
}
return
this
.
checkAllowAccessWithPrincipal
(
principal
aFeature
aValue
aDocument
)
;
}
checkAllowAccessWithPrincipal
(
aPrincipal
aFeature
aValue
aDocument
)
{
let
accessMapForFeature
=
this
.
checkAllowAccessToFeature
(
aPrincipal
aFeature
aDocument
)
;
if
(
!
accessMapForFeature
)
{
Cu
.
reportError
(
"
RemotePageAccessManager
does
not
allow
access
to
Feature
:
"
+
aFeature
+
"
for
:
"
+
aDocument
.
location
)
;
return
false
;
}
if
(
accessMapForFeature
.
includes
(
aValue
)
|
|
accessMapForFeature
[
0
]
=
=
"
*
"
)
{
return
true
;
}
return
false
;
}
checkAllowAccessToFeature
(
aPrincipal
aFeature
aDocument
)
{
let
uri
;
if
(
aPrincipal
.
isNullPrincipal
|
|
!
aPrincipal
.
URI
)
{
if
(
!
aDocument
)
{
return
null
;
}
uri
=
aDocument
.
documentURIObject
;
}
else
{
uri
=
aPrincipal
.
URI
;
}
let
spec
=
uri
.
prePath
+
uri
.
filePath
;
if
(
!
uri
.
schemeIs
(
"
about
"
)
)
{
return
null
;
}
let
accessMapForURI
=
this
.
accessMap
[
spec
]
;
if
(
!
accessMapForURI
)
{
return
null
;
}
return
accessMapForURI
[
aFeature
]
;
}
}
;
