var
EXPORTED_SYMBOLS
=
[
"
WebChannel
"
"
WebChannelBroker
"
]
;
const
ERRNO_UNKNOWN_ERROR
=
999
;
const
ERROR_UNKNOWN
=
"
UNKNOWN_ERROR
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
WebChannelBroker
=
Object
.
create
(
{
registerChannel
(
channel
)
{
if
(
!
this
.
_channelMap
.
has
(
channel
)
)
{
this
.
_channelMap
.
set
(
channel
)
;
}
else
{
Cu
.
reportError
(
"
Failed
to
register
the
channel
.
Channel
already
exists
.
"
)
;
}
}
unregisterChannel
(
channelToRemove
)
{
if
(
!
this
.
_channelMap
.
delete
(
channelToRemove
)
)
{
Cu
.
reportError
(
"
Failed
to
unregister
the
channel
.
Channel
not
found
.
"
)
;
}
}
_channelMap
:
new
Map
(
)
tryToDeliver
(
data
sendingContext
)
{
let
validChannelFound
=
false
;
data
.
message
=
data
.
message
|
|
{
}
;
for
(
var
channel
of
this
.
_channelMap
.
keys
(
)
)
{
if
(
channel
.
id
=
=
=
data
.
id
&
&
channel
.
_originCheckCallback
(
sendingContext
.
principal
)
)
{
validChannelFound
=
true
;
channel
.
deliver
(
data
sendingContext
)
;
}
}
return
validChannelFound
;
}
}
)
;
var
WebChannel
=
function
(
id
originOrPermission
)
{
if
(
!
id
|
|
!
originOrPermission
)
{
throw
new
Error
(
"
WebChannel
id
and
originOrPermission
are
required
.
"
)
;
}
this
.
id
=
id
;
if
(
typeof
originOrPermission
=
=
"
string
"
)
{
this
.
_originCheckCallback
=
requestPrincipal
=
>
{
let
uri
=
Services
.
io
.
newURI
(
requestPrincipal
.
originNoSuffix
)
;
if
(
uri
.
scheme
!
=
"
https
"
)
{
return
false
;
}
let
perm
=
Services
.
perms
.
testExactPermissionFromPrincipal
(
requestPrincipal
originOrPermission
)
;
return
perm
=
=
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
;
}
;
}
else
{
this
.
_originCheckCallback
=
requestPrincipal
=
>
{
return
originOrPermission
.
prePath
=
=
=
requestPrincipal
.
originNoSuffix
;
}
;
}
this
.
_originOrPermission
=
originOrPermission
;
}
;
this
.
WebChannel
.
prototype
=
{
id
:
null
_originOrPermission
:
null
_originCheckCallback
:
null
_broker
:
WebChannelBroker
_deliverCallback
:
null
listen
(
callback
)
{
if
(
this
.
_deliverCallback
)
{
throw
new
Error
(
"
Failed
to
listen
.
Listener
already
attached
.
"
)
;
}
else
if
(
!
callback
)
{
throw
new
Error
(
"
Failed
to
listen
.
Callback
argument
missing
.
"
)
;
}
else
{
this
.
_deliverCallback
=
callback
;
this
.
_broker
.
registerChannel
(
this
)
;
}
}
stopListening
(
)
{
this
.
_broker
.
unregisterChannel
(
this
)
;
this
.
_deliverCallback
=
null
;
}
send
(
message
target
)
{
let
{
browsingContext
principal
eventTarget
}
=
target
;
if
(
message
&
&
browsingContext
&
&
principal
)
{
let
{
currentWindowGlobal
}
=
browsingContext
;
if
(
!
currentWindowGlobal
)
{
Cu
.
reportError
(
"
Failed
to
send
a
WebChannel
message
.
No
currentWindowGlobal
.
"
)
;
return
;
}
currentWindowGlobal
.
getActor
(
"
WebChannel
"
)
.
sendAsyncMessage
(
"
WebChannelMessageToContent
"
{
id
:
this
.
id
message
eventTarget
principal
}
)
;
}
else
if
(
!
message
)
{
Cu
.
reportError
(
"
Failed
to
send
a
WebChannel
message
.
Message
not
set
.
"
)
;
}
else
{
Cu
.
reportError
(
"
Failed
to
send
a
WebChannel
message
.
Target
invalid
.
"
)
;
}
}
deliver
(
data
sendingContext
)
{
if
(
this
.
_deliverCallback
)
{
try
{
this
.
_deliverCallback
(
data
.
id
data
.
message
sendingContext
)
;
}
catch
(
ex
)
{
this
.
send
(
{
errno
:
ERRNO_UNKNOWN_ERROR
error
:
ex
.
message
?
ex
.
message
:
ERROR_UNKNOWN
}
sendingContext
)
;
Cu
.
reportError
(
"
Failed
to
execute
WebChannel
callback
:
"
)
;
Cu
.
reportError
(
ex
)
;
}
}
else
{
Cu
.
reportError
(
"
No
callback
set
for
this
channel
.
"
)
;
}
}
}
;
