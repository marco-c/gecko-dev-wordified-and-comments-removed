"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
FinderHighlighter
"
]
;
const
{
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Color
"
"
resource
:
/
/
gre
/
modules
/
Color
.
jsm
"
)
;
const
kHighlightIterationSizeMax
=
100
;
const
kModalHighlightRepaintFreqMs
=
10
;
const
kModalHighlightPref
=
"
findbar
.
modalHighlight
"
;
const
kFontPropsCSS
=
[
"
color
"
"
font
-
family
"
"
font
-
kerning
"
"
font
-
size
"
"
font
-
size
-
adjust
"
"
font
-
stretch
"
"
font
-
variant
"
"
font
-
weight
"
"
letter
-
spacing
"
"
text
-
emphasis
"
"
text
-
orientation
"
"
text
-
transform
"
"
word
-
spacing
"
]
;
const
kFontPropsCamelCase
=
kFontPropsCSS
.
map
(
prop
=
>
{
let
parts
=
prop
.
split
(
"
-
"
)
;
return
parts
.
shift
(
)
+
parts
.
map
(
part
=
>
part
.
charAt
(
0
)
.
toUpperCase
(
)
+
part
.
slice
(
1
)
)
.
join
(
"
"
)
;
}
)
;
const
kRGBRE
=
/
^
rgba
?
\
s
*
\
(
\
s
*
(
\
d
+
)
\
s
*
\
s
*
(
\
d
+
)
\
s
*
\
s
*
(
\
d
+
)
\
s
*
/
i
const
kModalIdPrefix
=
"
cedee4d0
-
74c5
-
4f2d
-
ab43
-
4d37c0f9d463
"
;
const
kModalOutlineId
=
kModalIdPrefix
+
"
-
findbar
-
modalHighlight
-
outline
"
;
const
kModalStyle
=
.
findbar
-
modalHighlight
-
outline
{
position
:
absolute
;
background
:
linear
-
gradient
(
to
bottom
#
f1ee00
#
edcc00
)
;
border
:
1px
solid
#
f5e600
;
border
-
radius
:
3px
;
box
-
shadow
:
0px
2px
3px
rgba
(
0
0
0
.
8
)
;
color
:
#
000
;
margin
-
top
:
-
3px
;
margin
-
inline
-
end
:
0
;
margin
-
bottom
:
0
;
margin
-
inline
-
start
:
-
3px
;
padding
-
top
:
2px
;
padding
-
inline
-
end
:
2px
;
padding
-
bottom
:
0
;
padding
-
inline
-
start
:
4px
;
pointer
-
events
:
none
;
z
-
index
:
2
;
}
.
findbar
-
modalHighlight
-
outline
[
grow
]
{
transform
:
scaleX
(
1
.
5
)
scaleY
(
1
.
5
)
}
.
findbar
-
modalHighlight
-
outline
[
hidden
]
{
opacity
:
0
;
display
:
-
moz
-
box
;
}
.
findbar
-
modalHighlight
-
outline
:
not
(
[
disable
-
transitions
]
)
{
transition
-
property
:
opacity
transform
top
left
;
transition
-
duration
:
50ms
;
transition
-
timing
-
function
:
linear
;
}
.
findbar
-
modalHighlight
-
outlineMask
{
background
:
#
000
;
mix
-
blend
-
mode
:
multiply
;
opacity
:
.
2
;
position
:
absolute
;
z
-
index
:
1
;
}
.
findbar
-
modalHighlight
-
outlineMask
[
brighttext
]
{
background
:
#
fff
;
}
.
findbar
-
modalHighlight
-
rect
{
background
:
#
fff
;
border
:
1px
solid
#
666
;
position
:
absolute
;
}
.
findbar
-
modalHighlight
-
outlineMask
[
brighttext
]
>
.
findbar
-
modalHighlight
-
rect
{
background
:
#
000
;
}
;
const
kXULNS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
function
FinderHighlighter
(
finder
)
{
this
.
finder
=
finder
;
this
.
_modal
=
Services
.
prefs
.
getBoolPref
(
kModalHighlightPref
)
;
}
FinderHighlighter
.
prototype
=
{
get
modalStyleSheet
(
)
{
if
(
!
this
.
_modalStyleSheet
)
{
this
.
_modalStyleSheet
=
kModalStyle
.
replace
(
/
(
\
.
|
#
)
findbar
-
/
g
"
1
"
+
kModalIdPrefix
+
"
-
findbar
-
"
)
;
}
return
this
.
_modalStyleSheet
;
}
get
modalStyleSheetURI
(
)
{
if
(
!
this
.
_modalStyleSheetURI
)
{
this
.
_modalStyleSheetURI
=
"
data
:
text
/
css
;
charset
=
utf
-
8
"
+
encodeURIComponent
(
this
.
modalStyleSheet
.
replace
(
/
[
\
n
]
+
/
g
"
"
)
)
;
}
return
this
.
_modalStyleSheetURI
;
}
notifyFinished
(
highlight
)
{
for
(
let
l
of
this
.
finder
.
_listeners
)
{
try
{
l
.
onHighlightFinished
(
highlight
)
;
}
catch
(
ex
)
{
}
}
}
maybeAbort
(
)
{
this
.
clear
(
)
;
if
(
!
this
.
_abortHighlight
)
{
return
;
}
this
.
_abortHighlight
(
)
;
}
iterator
:
Task
.
async
(
function
*
(
word
window
onFind
)
{
let
count
=
0
;
for
(
let
range
of
this
.
finder
.
_findIterator
(
word
window
)
)
{
onFind
(
range
)
;
if
(
+
+
count
>
=
kHighlightIterationSizeMax
)
{
count
=
0
;
yield
new
Promise
(
resolve
=
>
resolve
(
)
)
;
}
}
}
)
highlight
:
Task
.
async
(
function
*
(
highlight
word
window
)
{
let
finderWindow
=
this
.
finder
.
_getWindow
(
)
;
window
=
window
|
|
finderWindow
;
let
found
=
false
;
for
(
let
i
=
0
;
window
.
frames
&
&
i
<
window
.
frames
.
length
;
i
+
+
)
{
if
(
yield
this
.
highlight
(
highlight
word
window
.
frames
[
i
]
)
)
{
found
=
true
;
}
}
let
controller
=
this
.
finder
.
_getSelectionController
(
window
)
;
let
doc
=
window
.
document
;
if
(
!
controller
|
|
!
doc
|
|
!
doc
.
documentElement
)
{
return
found
;
}
if
(
highlight
)
{
yield
this
.
iterator
(
word
window
range
=
>
{
this
.
highlightRange
(
range
controller
finderWindow
)
;
found
=
true
;
}
)
;
}
else
{
this
.
hide
(
window
)
;
this
.
clear
(
)
;
found
=
true
;
}
return
found
;
}
)
highlightRange
(
range
controller
window
)
{
let
node
=
range
.
startContainer
;
let
editableNode
=
this
.
_getEditableNode
(
node
)
;
if
(
editableNode
)
{
controller
=
editableNode
.
editor
.
selectionController
;
}
if
(
this
.
_modal
)
{
this
.
_modalHighlight
(
range
controller
window
)
;
}
else
{
let
findSelection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
findSelection
.
addRange
(
range
)
;
}
if
(
editableNode
)
{
this
.
_addEditorListeners
(
editableNode
.
editor
)
;
}
}
show
(
window
=
null
)
{
if
(
!
this
.
_modal
)
return
null
;
window
=
window
|
|
this
.
finder
.
_getWindow
(
)
;
let
anonNode
=
this
.
_maybeCreateModalHighlightNodes
(
window
)
;
this
.
_addModalHighlightListeners
(
window
)
;
return
anonNode
;
}
hide
(
window
=
null
)
{
window
=
window
|
|
this
.
finder
.
_getWindow
(
)
;
let
doc
=
window
.
document
;
let
controller
=
this
.
finder
.
_getSelectionController
(
window
)
;
let
sel
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
sel
.
removeAllRanges
(
)
;
if
(
this
.
_editors
)
{
for
(
let
x
=
this
.
_editors
.
length
-
1
;
x
>
=
0
;
-
-
x
)
{
if
(
this
.
_editors
[
x
]
.
document
=
=
doc
)
{
sel
=
this
.
_editors
[
x
]
.
selectionController
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
sel
.
removeAllRanges
(
)
;
this
.
_unhookListenersAtIndex
(
x
)
;
}
}
}
if
(
!
this
.
_modal
)
return
;
if
(
this
.
_modalHighlightOutline
)
this
.
_modalHighlightOutline
.
setAttributeForElement
(
kModalOutlineId
"
hidden
"
"
true
"
)
;
this
.
_removeHighlightAllMask
(
window
)
;
this
.
_removeModalHighlightListeners
(
window
)
;
delete
this
.
_brightText
;
}
update
(
data
)
{
if
(
!
this
.
_modal
)
return
;
let
foundRange
=
this
.
finder
.
_fastFind
.
getFoundRange
(
)
;
if
(
data
.
result
=
=
Ci
.
nsITypeAheadFind
.
FIND_NOTFOUND
|
|
!
foundRange
)
{
this
.
hide
(
)
;
return
;
}
let
window
=
this
.
finder
.
_getWindow
(
)
;
let
textContent
=
this
.
_getRangeContentArray
(
foundRange
)
;
if
(
!
textContent
.
length
)
{
this
.
hide
(
window
)
;
return
;
}
let
rect
=
foundRange
.
getBoundingClientRect
(
)
;
let
fontStyle
=
this
.
_getRangeFontStyle
(
foundRange
)
;
if
(
typeof
this
.
_brightText
=
=
"
undefined
"
)
{
this
.
_brightText
=
this
.
_isColorBright
(
fontStyle
.
color
)
;
}
delete
fontStyle
.
color
;
let
anonNode
=
this
.
show
(
window
)
;
anonNode
.
setTextContentForElement
(
kModalOutlineId
+
"
-
text
"
textContent
.
join
(
"
"
)
)
;
anonNode
.
setAttributeForElement
(
kModalOutlineId
+
"
-
text
"
"
style
"
this
.
_getHTMLFontStyle
(
fontStyle
)
)
;
if
(
typeof
anonNode
.
getAttributeForElement
(
kModalOutlineId
"
hidden
"
)
=
=
"
string
"
)
anonNode
.
removeAttributeForElement
(
kModalOutlineId
"
hidden
"
)
;
let
{
scrollX
scrollY
}
=
this
.
_getScrollPosition
(
window
)
;
anonNode
.
setAttributeForElement
(
kModalOutlineId
"
style
"
top
:
{
scrollY
+
rect
.
top
}
px
;
left
:
{
scrollX
+
rect
.
left
}
px
)
;
if
(
typeof
anonNode
.
getAttributeForElement
(
kModalOutlineId
"
grow
"
)
=
=
"
string
"
)
return
;
window
.
requestAnimationFrame
(
(
)
=
>
{
anonNode
.
setAttributeForElement
(
kModalOutlineId
"
grow
"
true
)
;
this
.
_listenForOutlineEvent
(
kModalOutlineId
"
transitionend
"
(
)
=
>
{
try
{
anonNode
.
removeAttributeForElement
(
kModalOutlineId
"
grow
"
)
;
}
catch
(
ex
)
{
}
}
)
;
}
)
;
}
clear
(
)
{
if
(
!
this
.
_modal
)
return
;
if
(
this
.
_modalHighlightRectsMap
)
this
.
_modalHighlightRectsMap
.
clear
(
)
;
}
onLocationChange
(
)
{
if
(
!
this
.
_modalHighlightOutline
)
return
;
try
{
this
.
finder
.
_getWindow
(
)
.
document
.
removeAnonymousContent
(
this
.
_modalHighlightOutline
)
;
}
catch
(
ex
)
{
}
this
.
_modalHighlightOutline
=
null
;
}
onModalHighlightChange
(
useModalHighlight
)
{
if
(
this
.
_modal
&
&
!
useModalHighlight
)
{
this
.
hide
(
)
;
this
.
clear
(
)
;
}
this
.
_modal
=
useModalHighlight
;
}
_getDWU
(
window
=
null
)
{
return
(
window
|
|
this
.
finder
.
_getWindow
(
)
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
_getScrollPosition
(
window
=
null
)
{
let
scrollX
=
{
}
;
let
scrollY
=
{
}
;
this
.
_getDWU
(
window
)
.
getScrollXY
(
false
scrollX
scrollY
)
;
return
{
scrollX
:
scrollX
.
value
scrollY
:
scrollY
.
value
}
;
}
_getWindowDimensions
(
window
)
{
let
width
=
window
.
innerWidth
+
window
.
scrollMaxX
-
window
.
scrollMinX
;
let
height
=
window
.
innerHeight
+
window
.
scrollMaxY
-
window
.
scrollMinY
;
let
scrollbarHeight
=
{
}
;
let
scrollbarWidth
=
{
}
;
this
.
_getDWU
(
window
)
.
getScrollbarSize
(
false
scrollbarWidth
scrollbarHeight
)
;
width
-
=
scrollbarWidth
.
value
;
height
-
=
scrollbarHeight
.
value
;
return
{
width
height
}
;
}
_getRangeContentArray
(
range
)
{
let
content
=
range
.
cloneContents
(
)
;
let
t
textContent
=
[
]
;
for
(
let
node
of
content
.
childNodes
)
{
t
=
node
.
textContent
|
|
node
.
nodeValue
;
textContent
.
push
(
t
)
;
}
return
textContent
;
}
_getRangeFontStyle
(
range
)
{
let
node
=
range
.
startContainer
;
while
(
node
.
nodeType
!
=
1
)
node
=
node
.
parentNode
;
let
style
=
node
.
ownerDocument
.
defaultView
.
getComputedStyle
(
node
"
"
)
;
let
props
=
{
}
;
for
(
let
prop
of
kFontPropsCamelCase
)
{
if
(
prop
in
style
&
&
style
[
prop
]
)
props
[
prop
]
=
style
[
prop
]
;
}
return
props
;
}
_getHTMLFontStyle
(
fontStyle
)
{
let
style
=
[
]
;
for
(
let
prop
of
Object
.
getOwnPropertyNames
(
fontStyle
)
)
{
let
idx
=
kFontPropsCamelCase
.
indexOf
(
prop
)
;
if
(
idx
=
=
-
1
)
continue
style
.
push
(
{
kFontPropsCSS
[
idx
]
}
:
{
fontStyle
[
prop
]
}
;
)
;
}
return
style
.
join
(
"
"
)
;
}
_isColorBright
(
cssColor
)
{
cssColor
=
cssColor
.
match
(
kRGBRE
)
;
if
(
!
cssColor
|
|
!
cssColor
.
length
)
return
false
;
cssColor
.
shift
(
)
;
return
new
Color
(
.
.
.
cssColor
)
.
isBright
;
}
_modalHighlight
(
range
controller
window
)
{
if
(
!
this
.
_getRangeContentArray
(
range
)
.
length
)
return
;
let
rects
=
new
Set
(
)
;
let
{
scrollX
scrollY
}
=
this
.
_getScrollPosition
(
window
)
;
for
(
let
dims
of
range
.
getClientRects
(
)
)
{
rects
.
add
(
{
height
:
dims
.
bottom
-
dims
.
top
width
:
dims
.
right
-
dims
.
left
y
:
dims
.
top
+
scrollY
x
:
dims
.
left
+
scrollX
}
)
;
}
range
.
collapse
(
)
;
if
(
!
this
.
_modalHighlightRectsMap
)
this
.
_modalHighlightRectsMap
=
new
Map
(
)
;
this
.
_modalHighlightRectsMap
.
set
(
range
rects
)
;
this
.
show
(
window
)
;
this
.
_scheduleRepaintOfMask
(
window
)
;
}
_maybeCreateModalHighlightNodes
(
window
)
{
if
(
this
.
_modalHighlightOutline
)
{
if
(
!
this
.
_modalHighlightAllMask
)
this
.
_repaintHighlightAllMask
(
window
)
;
return
this
.
_modalHighlightOutline
;
}
let
document
=
window
.
document
;
if
(
document
.
hidden
)
{
let
onVisibilityChange
=
(
)
=
>
{
document
.
removeEventListener
(
"
visibilitychange
"
onVisibilityChange
)
;
this
.
_maybeCreateModalHighlightNodes
(
window
)
;
}
;
document
.
addEventListener
(
"
visibilitychange
"
onVisibilityChange
)
;
return
null
;
}
this
.
_maybeInstallStyleSheet
(
window
)
;
let
container
=
document
.
createElement
(
"
div
"
)
;
let
outlineBox
=
document
.
createElement
(
"
div
"
)
;
outlineBox
.
setAttribute
(
"
id
"
kModalOutlineId
)
;
outlineBox
.
className
=
kModalOutlineId
;
let
outlineBoxText
=
document
.
createElement
(
"
span
"
)
;
outlineBoxText
.
setAttribute
(
"
id
"
kModalOutlineId
+
"
-
text
"
)
;
outlineBox
.
appendChild
(
outlineBoxText
)
;
container
.
appendChild
(
outlineBox
)
;
this
.
_repaintHighlightAllMask
(
window
)
;
this
.
_modalHighlightOutline
=
document
.
insertAnonymousContent
(
container
)
;
return
this
.
_modalHighlightOutline
;
}
_repaintHighlightAllMask
(
window
)
{
let
document
=
window
.
document
;
const
kMaskId
=
kModalIdPrefix
+
"
-
findbar
-
modalHighlight
-
outlineMask
"
;
let
maskNode
=
document
.
createElement
(
"
div
"
)
;
let
{
width
height
}
=
this
.
_getWindowDimensions
(
window
)
;
maskNode
.
setAttribute
(
"
id
"
kMaskId
)
;
maskNode
.
setAttribute
(
"
class
"
kMaskId
)
;
maskNode
.
setAttribute
(
"
style
"
width
:
{
width
}
px
;
height
:
{
height
}
px
;
)
;
if
(
this
.
_brightText
)
maskNode
.
setAttribute
(
"
brighttext
"
"
true
"
)
;
let
maskContent
=
[
]
;
const
kRectClassName
=
kModalIdPrefix
+
"
-
findbar
-
modalHighlight
-
rect
"
;
if
(
this
.
_modalHighlightRectsMap
)
{
for
(
let
rects
of
this
.
_modalHighlightRectsMap
.
values
(
)
)
{
for
(
let
rect
of
rects
)
{
maskContent
.
push
(
<
div
class
=
"
{
kRectClassName
}
"
style
=
"
top
:
{
rect
.
y
}
px
;
left
:
{
rect
.
x
}
px
;
height
:
{
rect
.
height
}
px
;
width
:
{
rect
.
width
}
px
;
"
>
<
/
div
>
)
;
}
}
}
maskNode
.
innerHTML
=
maskContent
.
join
(
"
"
)
;
this
.
_removeHighlightAllMask
(
window
)
;
this
.
_modalHighlightAllMask
=
document
.
insertAnonymousContent
(
maskNode
)
;
}
_removeHighlightAllMask
(
window
)
{
if
(
this
.
_modalHighlightAllMask
)
{
try
{
window
.
document
.
removeAnonymousContent
(
this
.
_modalHighlightAllMask
)
;
}
catch
(
ex
)
{
}
this
.
_modalHighlightAllMask
=
null
;
}
}
_scheduleRepaintOfMask
(
window
)
{
if
(
this
.
_modalRepaintScheduler
)
window
.
clearTimeout
(
this
.
_modalRepaintScheduler
)
;
this
.
_modalRepaintScheduler
=
window
.
setTimeout
(
this
.
_repaintHighlightAllMask
.
bind
(
this
window
)
kModalHighlightRepaintFreqMs
)
;
}
_maybeInstallStyleSheet
(
window
)
{
let
document
=
window
.
document
;
if
(
!
this
.
_modalInstalledSheets
)
this
.
_modalInstalledSheets
=
new
WeakMap
(
)
;
if
(
this
.
_modalInstalledSheets
.
has
(
document
)
)
return
;
let
dwu
=
this
.
_getDWU
(
window
)
;
let
uri
=
this
.
modalStyleSheetURI
;
try
{
dwu
.
loadSheetUsingURIString
(
uri
dwu
.
AGENT_SHEET
)
;
}
catch
(
e
)
{
}
this
.
_modalInstalledSheets
.
set
(
document
uri
)
;
}
_listenForOutlineEvent
(
elementId
eventName
handler
)
{
let
target
=
this
.
finder
.
_docShell
.
chromeEventHandler
;
target
.
addEventListener
(
eventName
function
onEvent
(
event
)
{
let
node
=
event
.
originalTarget
;
while
(
node
)
{
if
(
node
.
id
=
=
elementId
)
{
handler
(
)
;
target
.
removeEventListener
(
eventName
onEvent
)
;
break
;
}
node
=
node
.
parentNode
;
}
}
)
;
}
_addModalHighlightListeners
(
window
)
{
if
(
this
.
_highlightListeners
)
return
;
this
.
_highlightListeners
=
[
this
.
_scheduleRepaintOfMask
.
bind
(
this
window
)
this
.
hide
.
bind
(
this
window
)
]
;
window
.
addEventListener
(
"
DOMContentLoaded
"
this
.
_highlightListeners
[
0
]
)
;
window
.
addEventListener
(
"
mousedown
"
this
.
_highlightListeners
[
1
]
)
;
window
.
addEventListener
(
"
resize
"
this
.
_highlightListeners
[
1
]
)
;
window
.
addEventListener
(
"
touchstart
"
this
.
_highlightListeners
[
1
]
)
;
}
_removeModalHighlightListeners
(
window
)
{
if
(
!
this
.
_highlightListeners
)
return
;
window
.
removeEventListener
(
"
DOMContentLoaded
"
this
.
_highlightListeners
[
0
]
)
;
window
.
removeEventListener
(
"
mousedown
"
this
.
_highlightListeners
[
1
]
)
;
window
.
removeEventListener
(
"
resize
"
this
.
_highlightListeners
[
1
]
)
;
window
.
removeEventListener
(
"
touchstart
"
this
.
_highlightListeners
[
1
]
)
;
this
.
_highlightListeners
=
null
;
}
_getEditableNode
(
node
)
{
if
(
node
.
nodeType
=
=
=
node
.
TEXT_NODE
&
&
node
.
parentNode
&
&
node
.
parentNode
.
parentNode
&
&
node
.
parentNode
.
parentNode
instanceof
Ci
.
nsIDOMNSEditableElement
)
{
return
node
.
parentNode
.
parentNode
;
}
return
null
;
}
_addEditorListeners
(
editor
)
{
if
(
!
this
.
_editors
)
{
this
.
_editors
=
[
]
;
this
.
_stateListeners
=
[
]
;
}
let
existingIndex
=
this
.
_editors
.
indexOf
(
editor
)
;
if
(
existingIndex
=
=
-
1
)
{
let
x
=
this
.
_editors
.
length
;
this
.
_editors
[
x
]
=
editor
;
this
.
_stateListeners
[
x
]
=
this
.
_createStateListener
(
)
;
this
.
_editors
[
x
]
.
addEditActionListener
(
this
)
;
this
.
_editors
[
x
]
.
addDocumentStateListener
(
this
.
_stateListeners
[
x
]
)
;
}
}
_unhookListenersAtIndex
(
idx
)
{
this
.
_editors
[
idx
]
.
removeEditActionListener
(
this
)
;
this
.
_editors
[
idx
]
.
removeDocumentStateListener
(
this
.
_stateListeners
[
idx
]
)
;
this
.
_editors
.
splice
(
idx
1
)
;
this
.
_stateListeners
.
splice
(
idx
1
)
;
if
(
!
this
.
_editors
.
length
)
{
delete
this
.
_editors
;
delete
this
.
_stateListeners
;
}
}
_removeEditorListeners
(
editor
)
{
let
idx
=
this
.
_editors
.
indexOf
(
editor
)
;
if
(
idx
=
=
-
1
)
{
return
;
}
this
.
_unhookListenersAtIndex
(
idx
)
;
}
_checkOverlap
(
selectionRange
findRange
)
{
if
(
findRange
.
isPointInRange
(
selectionRange
.
startContainer
selectionRange
.
startOffset
)
)
return
true
;
if
(
findRange
.
isPointInRange
(
selectionRange
.
endContainer
selectionRange
.
endOffset
)
)
return
true
;
if
(
selectionRange
.
isPointInRange
(
findRange
.
startContainer
findRange
.
startOffset
)
)
return
true
;
if
(
selectionRange
.
isPointInRange
(
findRange
.
endContainer
findRange
.
endOffset
)
)
return
true
;
return
false
;
}
_findRange
(
selection
node
offset
)
{
let
rangeCount
=
selection
.
rangeCount
;
let
rangeidx
=
0
;
let
foundContainingRange
=
false
;
let
range
=
null
;
while
(
!
foundContainingRange
&
&
rangeidx
<
rangeCount
)
{
range
=
selection
.
getRangeAt
(
rangeidx
)
;
if
(
range
.
isPointInRange
(
node
offset
)
)
{
foundContainingRange
=
true
;
break
;
}
rangeidx
+
+
;
}
if
(
foundContainingRange
)
{
return
range
;
}
return
null
;
}
WillDeleteText
(
textNode
offset
length
)
{
let
editor
=
this
.
_getEditableNode
(
textNode
)
.
editor
;
let
controller
=
editor
.
selectionController
;
let
fSelection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
let
range
=
this
.
_findRange
(
fSelection
textNode
offset
)
;
if
(
range
)
{
if
(
textNode
!
=
range
.
endContainer
|
|
offset
!
=
range
.
endOffset
)
{
fSelection
.
removeRange
(
range
)
;
if
(
fSelection
.
rangeCount
=
=
0
)
{
this
.
_removeEditorListeners
(
editor
)
;
}
}
}
}
DidInsertText
(
textNode
offset
aString
)
{
let
editor
=
this
.
_getEditableNode
(
textNode
)
.
editor
;
let
controller
=
editor
.
selectionController
;
let
fSelection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
let
range
=
this
.
_findRange
(
fSelection
textNode
offset
)
;
if
(
range
)
{
if
(
textNode
=
=
range
.
startContainer
&
&
offset
=
=
range
.
startOffset
)
{
range
.
setStart
(
range
.
startContainer
range
.
startOffset
+
aString
.
length
)
;
}
else
if
(
textNode
!
=
range
.
endContainer
|
|
offset
!
=
range
.
endOffset
)
{
fSelection
.
removeRange
(
range
)
;
if
(
fSelection
.
rangeCount
=
=
0
)
{
this
.
_removeEditorListeners
(
editor
)
;
}
}
}
}
WillDeleteSelection
(
selection
)
{
let
editor
=
this
.
_getEditableNode
(
selection
.
getRangeAt
(
0
)
.
startContainer
)
.
editor
;
let
controller
=
editor
.
selectionController
;
let
fSelection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
let
selectionIndex
=
0
;
let
findSelectionIndex
=
0
;
let
shouldDelete
=
{
}
;
let
numberOfDeletedSelections
=
0
;
let
numberOfMatches
=
fSelection
.
rangeCount
;
for
(
let
fIndex
=
0
;
fIndex
<
numberOfMatches
;
fIndex
+
+
)
{
shouldDelete
[
fIndex
]
=
false
;
let
fRange
=
fSelection
.
getRangeAt
(
fIndex
)
;
for
(
let
index
=
0
;
index
<
selection
.
rangeCount
;
index
+
+
)
{
if
(
shouldDelete
[
fIndex
]
)
{
continue
;
}
let
selRange
=
selection
.
getRangeAt
(
index
)
;
let
doesOverlap
=
this
.
_checkOverlap
(
selRange
fRange
)
;
if
(
doesOverlap
)
{
shouldDelete
[
fIndex
]
=
true
;
numberOfDeletedSelections
+
+
;
}
}
}
if
(
!
numberOfDeletedSelections
)
{
return
;
}
for
(
let
i
=
numberOfMatches
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
shouldDelete
[
i
]
)
fSelection
.
removeRange
(
fSelection
.
getRangeAt
(
i
)
)
;
}
if
(
!
fSelection
.
rangeCount
)
{
this
.
_removeEditorListeners
(
editor
)
;
}
}
_onEditorDestruction
(
aListener
)
{
let
idx
=
0
;
while
(
this
.
_stateListeners
[
idx
]
!
=
aListener
)
{
idx
+
+
;
}
this
.
_unhookListenersAtIndex
(
idx
)
;
}
_createStateListener
(
)
{
return
{
findbar
:
this
QueryInterface
:
function
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIDocumentStateListener
)
|
|
iid
.
equals
(
Ci
.
nsISupports
)
)
return
this
;
throw
Components
.
results
.
NS_ERROR_NO_INTERFACE
;
}
NotifyDocumentWillBeDestroyed
:
function
(
)
{
this
.
findbar
.
_onEditorDestruction
(
this
)
;
}
notifyDocumentCreated
:
function
(
)
{
}
notifyDocumentStateChanged
:
function
(
aDirty
)
{
}
}
;
}
}
;
