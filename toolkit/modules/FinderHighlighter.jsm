"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
FinderHighlighter
"
]
;
const
{
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
const
kHighlightIterationSizeMax
=
100
;
function
FinderHighlighter
(
finder
)
{
this
.
finder
=
finder
;
}
FinderHighlighter
.
prototype
=
{
notifyFinished
(
highlight
)
{
for
(
let
l
of
this
.
finder
.
_listeners
)
{
try
{
l
.
onHighlightFinished
(
highlight
)
;
}
catch
(
ex
)
{
}
}
}
maybeAbort
(
)
{
if
(
!
this
.
_abortHighlight
)
{
return
;
}
this
.
_abortHighlight
(
)
;
}
iterator
:
Task
.
async
(
function
*
(
word
window
onFind
)
{
let
count
=
0
;
for
(
let
range
of
this
.
finder
.
_findIterator
(
word
window
)
)
{
onFind
(
range
)
;
if
(
+
+
count
>
=
kHighlightIterationSizeMax
)
{
count
=
0
;
yield
new
Promise
(
resolve
=
>
resolve
(
)
)
;
}
}
}
)
highlight
:
Task
.
async
(
function
*
(
highlight
word
window
)
{
window
=
window
|
|
this
.
finder
.
_getWindow
(
)
;
let
found
=
false
;
for
(
let
i
=
0
;
window
.
frames
&
&
i
<
window
.
frames
.
length
;
i
+
+
)
{
if
(
yield
this
.
highlight
(
highlight
word
window
.
frames
[
i
]
)
)
{
found
=
true
;
}
}
let
controller
=
this
.
finder
.
_getSelectionController
(
window
)
;
let
doc
=
window
.
document
;
if
(
!
controller
|
|
!
doc
|
|
!
doc
.
documentElement
)
{
return
found
;
}
if
(
highlight
)
{
yield
this
.
iterator
(
word
window
range
=
>
{
this
.
highlightRange
(
range
controller
)
;
found
=
true
;
}
)
;
}
else
{
let
sel
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
sel
.
removeAllRanges
(
)
;
if
(
this
.
_editors
)
{
for
(
let
x
=
this
.
_editors
.
length
-
1
;
x
>
=
0
;
-
-
x
)
{
if
(
this
.
_editors
[
x
]
.
document
=
=
doc
)
{
sel
=
this
.
_editors
[
x
]
.
selectionController
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
sel
.
removeAllRanges
(
)
;
this
.
_unhookListenersAtIndex
(
x
)
;
}
}
}
found
=
true
;
}
return
found
;
}
)
highlightRange
(
range
controller
)
{
let
node
=
range
.
startContainer
;
let
editableNode
=
this
.
_getEditableNode
(
node
)
;
if
(
editableNode
)
{
controller
=
editableNode
.
editor
.
selectionController
;
}
let
findSelection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
findSelection
.
addRange
(
range
)
;
if
(
editableNode
)
{
this
.
_addEditorListeners
(
editableNode
.
editor
)
;
}
}
_getEditableNode
(
node
)
{
if
(
node
.
nodeType
=
=
=
node
.
TEXT_NODE
&
&
node
.
parentNode
&
&
node
.
parentNode
.
parentNode
&
&
node
.
parentNode
.
parentNode
instanceof
Ci
.
nsIDOMNSEditableElement
)
{
return
node
.
parentNode
.
parentNode
;
}
return
null
;
}
_addEditorListeners
(
editor
)
{
if
(
!
this
.
_editors
)
{
this
.
_editors
=
[
]
;
this
.
_stateListeners
=
[
]
;
}
let
existingIndex
=
this
.
_editors
.
indexOf
(
editor
)
;
if
(
existingIndex
=
=
-
1
)
{
let
x
=
this
.
_editors
.
length
;
this
.
_editors
[
x
]
=
editor
;
this
.
_stateListeners
[
x
]
=
this
.
_createStateListener
(
)
;
this
.
_editors
[
x
]
.
addEditActionListener
(
this
)
;
this
.
_editors
[
x
]
.
addDocumentStateListener
(
this
.
_stateListeners
[
x
]
)
;
}
}
_unhookListenersAtIndex
(
idx
)
{
this
.
_editors
[
idx
]
.
removeEditActionListener
(
this
)
;
this
.
_editors
[
idx
]
.
removeDocumentStateListener
(
this
.
_stateListeners
[
idx
]
)
;
this
.
_editors
.
splice
(
idx
1
)
;
this
.
_stateListeners
.
splice
(
idx
1
)
;
if
(
!
this
.
_editors
.
length
)
{
delete
this
.
_editors
;
delete
this
.
_stateListeners
;
}
}
_removeEditorListeners
(
editor
)
{
let
idx
=
this
.
_editors
.
indexOf
(
editor
)
;
if
(
idx
=
=
-
1
)
{
return
;
}
this
.
_unhookListenersAtIndex
(
idx
)
;
}
_checkOverlap
(
selectionRange
findRange
)
{
if
(
findRange
.
isPointInRange
(
selectionRange
.
startContainer
selectionRange
.
startOffset
)
)
return
true
;
if
(
findRange
.
isPointInRange
(
selectionRange
.
endContainer
selectionRange
.
endOffset
)
)
return
true
;
if
(
selectionRange
.
isPointInRange
(
findRange
.
startContainer
findRange
.
startOffset
)
)
return
true
;
if
(
selectionRange
.
isPointInRange
(
findRange
.
endContainer
findRange
.
endOffset
)
)
return
true
;
return
false
;
}
_findRange
(
selection
node
offset
)
{
let
rangeCount
=
selection
.
rangeCount
;
let
rangeidx
=
0
;
let
foundContainingRange
=
false
;
let
range
=
null
;
while
(
!
foundContainingRange
&
&
rangeidx
<
rangeCount
)
{
range
=
selection
.
getRangeAt
(
rangeidx
)
;
if
(
range
.
isPointInRange
(
node
offset
)
)
{
foundContainingRange
=
true
;
break
;
}
rangeidx
+
+
;
}
if
(
foundContainingRange
)
{
return
range
;
}
return
null
;
}
WillDeleteText
(
textNode
offset
length
)
{
let
editor
=
this
.
_getEditableNode
(
textNode
)
.
editor
;
let
controller
=
editor
.
selectionController
;
let
fSelection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
let
range
=
this
.
_findRange
(
fSelection
textNode
offset
)
;
if
(
range
)
{
if
(
textNode
!
=
range
.
endContainer
|
|
offset
!
=
range
.
endOffset
)
{
fSelection
.
removeRange
(
range
)
;
if
(
fSelection
.
rangeCount
=
=
0
)
{
this
.
_removeEditorListeners
(
editor
)
;
}
}
}
}
DidInsertText
(
textNode
offset
aString
)
{
let
editor
=
this
.
_getEditableNode
(
textNode
)
.
editor
;
let
controller
=
editor
.
selectionController
;
let
fSelection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
let
range
=
this
.
_findRange
(
fSelection
textNode
offset
)
;
if
(
range
)
{
if
(
textNode
=
=
range
.
startContainer
&
&
offset
=
=
range
.
startOffset
)
{
range
.
setStart
(
range
.
startContainer
range
.
startOffset
+
aString
.
length
)
;
}
else
if
(
textNode
!
=
range
.
endContainer
|
|
offset
!
=
range
.
endOffset
)
{
fSelection
.
removeRange
(
range
)
;
if
(
fSelection
.
rangeCount
=
=
0
)
{
this
.
_removeEditorListeners
(
editor
)
;
}
}
}
}
WillDeleteSelection
(
selection
)
{
let
editor
=
this
.
_getEditableNode
(
selection
.
getRangeAt
(
0
)
.
startContainer
)
.
editor
;
let
controller
=
editor
.
selectionController
;
let
fSelection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
let
selectionIndex
=
0
;
let
findSelectionIndex
=
0
;
let
shouldDelete
=
{
}
;
let
numberOfDeletedSelections
=
0
;
let
numberOfMatches
=
fSelection
.
rangeCount
;
for
(
let
fIndex
=
0
;
fIndex
<
numberOfMatches
;
fIndex
+
+
)
{
shouldDelete
[
fIndex
]
=
false
;
let
fRange
=
fSelection
.
getRangeAt
(
fIndex
)
;
for
(
let
index
=
0
;
index
<
selection
.
rangeCount
;
index
+
+
)
{
if
(
shouldDelete
[
fIndex
]
)
{
continue
;
}
let
selRange
=
selection
.
getRangeAt
(
index
)
;
let
doesOverlap
=
this
.
_checkOverlap
(
selRange
fRange
)
;
if
(
doesOverlap
)
{
shouldDelete
[
fIndex
]
=
true
;
numberOfDeletedSelections
+
+
;
}
}
}
if
(
!
numberOfDeletedSelections
)
{
return
;
}
for
(
let
i
=
numberOfMatches
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
shouldDelete
[
i
]
)
fSelection
.
removeRange
(
fSelection
.
getRangeAt
(
i
)
)
;
}
if
(
!
fSelection
.
rangeCount
)
{
this
.
_removeEditorListeners
(
editor
)
;
}
}
_onEditorDestruction
(
aListener
)
{
let
idx
=
0
;
while
(
this
.
_stateListeners
[
idx
]
!
=
aListener
)
{
idx
+
+
;
}
this
.
_unhookListenersAtIndex
(
idx
)
;
}
_createStateListener
(
)
{
return
{
findbar
:
this
QueryInterface
:
function
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIDocumentStateListener
)
|
|
iid
.
equals
(
Ci
.
nsISupports
)
)
return
this
;
throw
Components
.
results
.
NS_ERROR_NO_INTERFACE
;
}
NotifyDocumentWillBeDestroyed
:
function
(
)
{
this
.
findbar
.
_onEditorDestruction
(
this
)
;
}
notifyDocumentCreated
:
function
(
)
{
}
notifyDocumentStateChanged
:
function
(
aDirty
)
{
}
}
;
}
}
;
