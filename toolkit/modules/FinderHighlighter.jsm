"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
FinderHighlighter
"
]
;
const
{
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Color
"
"
resource
:
/
/
gre
/
modules
/
Color
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Rect
"
"
resource
:
/
/
gre
/
modules
/
Geometry
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
kDebug
"
(
)
=
>
{
const
kDebugPref
=
"
findbar
.
modalHighlight
.
debug
"
;
return
Services
.
prefs
.
getPrefType
(
kDebugPref
)
&
&
Services
.
prefs
.
getBoolPref
(
kDebugPref
)
;
}
)
;
const
kContentChangeThresholdPx
=
5
;
const
kBrightTextSampleSize
=
5
;
const
kModalHighlightRepaintLoFreqMs
=
100
;
const
kModalHighlightRepaintHiFreqMs
=
16
;
const
kHighlightAllPref
=
"
findbar
.
highlightAll
"
;
const
kModalHighlightPref
=
"
findbar
.
modalHighlight
"
;
const
kFontPropsCSS
=
[
"
color
"
"
font
-
family
"
"
font
-
kerning
"
"
font
-
size
"
"
font
-
size
-
adjust
"
"
font
-
stretch
"
"
font
-
variant
"
"
font
-
weight
"
"
line
-
height
"
"
letter
-
spacing
"
"
text
-
emphasis
"
"
text
-
orientation
"
"
text
-
transform
"
"
word
-
spacing
"
]
;
const
kFontPropsCamelCase
=
kFontPropsCSS
.
map
(
prop
=
>
{
let
parts
=
prop
.
split
(
"
-
"
)
;
return
parts
.
shift
(
)
+
parts
.
map
(
part
=
>
part
.
charAt
(
0
)
.
toUpperCase
(
)
+
part
.
slice
(
1
)
)
.
join
(
"
"
)
;
}
)
;
const
kRGBRE
=
/
^
rgba
?
\
s
*
\
(
\
s
*
(
\
d
+
)
\
s
*
\
s
*
(
\
d
+
)
\
s
*
\
s
*
(
\
d
+
)
\
s
*
/
i
;
const
kModalIdPrefix
=
"
cedee4d0
-
74c5
-
4f2d
-
ab43
-
4d37c0f9d463
"
;
const
kModalOutlineId
=
kModalIdPrefix
+
"
-
findbar
-
modalHighlight
-
outline
"
;
const
kModalStyles
=
{
outlineNode
:
[
[
"
position
"
"
absolute
"
]
[
"
background
"
"
#
ffc535
"
]
[
"
border
-
radius
"
"
3px
"
]
[
"
box
-
shadow
"
"
0
2px
0
0
rgba
(
0
0
0
.
1
)
"
]
[
"
color
"
"
#
000
"
]
[
"
display
"
"
-
moz
-
box
"
]
[
"
margin
"
"
-
2px
0
0
-
2px
!
important
"
]
[
"
padding
"
"
2px
!
important
"
]
[
"
pointer
-
events
"
"
none
"
]
[
"
white
-
space
"
"
nowrap
"
]
[
"
will
-
change
"
"
transform
"
]
[
"
z
-
index
"
2
]
]
outlineNodeDebug
:
[
[
"
z
-
index
"
2147483647
]
]
outlineText
:
[
[
"
margin
"
"
0
!
important
"
]
[
"
padding
"
"
0
!
important
"
]
[
"
vertical
-
align
"
"
top
!
important
"
]
]
maskNode
:
[
[
"
background
"
"
rgba
(
0
0
0
.
25
)
"
]
[
"
pointer
-
events
"
"
none
"
]
[
"
position
"
"
absolute
"
]
[
"
z
-
index
"
1
]
]
maskNodeDebug
:
[
[
"
z
-
index
"
2147483646
]
[
"
top
"
0
]
[
"
left
"
0
]
]
maskNodeBrightText
:
[
[
"
background
"
"
rgba
(
255
255
255
.
25
)
"
]
]
}
;
const
kModalOutlineAnim
=
{
"
keyframes
"
:
[
{
transform
:
"
scaleX
(
1
)
scaleY
(
1
)
"
}
{
transform
:
"
scaleX
(
1
.
5
)
scaleY
(
1
.
5
)
"
offset
:
.
5
easing
:
"
ease
-
in
"
}
{
transform
:
"
scaleX
(
1
)
scaleY
(
1
)
"
}
]
duration
:
50
}
;
const
kNSHTML
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
function
mockAnonymousContentNode
(
domNode
)
{
return
{
setTextContentForElement
(
id
text
)
{
(
domNode
.
querySelector
(
"
#
"
+
id
)
|
|
domNode
)
.
textContent
=
text
;
}
getAttributeForElement
(
id
attrName
)
{
let
node
=
domNode
.
querySelector
(
"
#
"
+
id
)
|
|
domNode
;
if
(
!
node
.
hasAttribute
(
attrName
)
)
return
undefined
;
return
node
.
getAttribute
(
attrName
)
;
}
setAttributeForElement
(
id
attrName
attrValue
)
{
(
domNode
.
querySelector
(
"
#
"
+
id
)
|
|
domNode
)
.
setAttribute
(
attrName
attrValue
)
;
}
removeAttributeForElement
(
id
attrName
)
{
let
node
=
domNode
.
querySelector
(
"
#
"
+
id
)
|
|
domNode
;
if
(
!
node
.
hasAttribute
(
attrName
)
)
return
;
node
.
removeAttribute
(
attrName
)
;
}
remove
(
)
{
try
{
domNode
.
parentNode
.
removeChild
(
domNode
)
;
}
catch
(
ex
)
{
}
}
setAnimationForElement
(
id
keyframes
duration
)
{
return
(
domNode
.
querySelector
(
"
#
"
+
id
)
|
|
domNode
)
.
animate
(
keyframes
duration
)
;
}
setCutoutRectsForElement
(
id
rects
)
{
}
}
;
}
let
gWindows
=
new
Map
(
)
;
function
FinderHighlighter
(
finder
)
{
this
.
_highlightAll
=
Services
.
prefs
.
getBoolPref
(
kHighlightAllPref
)
;
this
.
_modal
=
Services
.
prefs
.
getBoolPref
(
kModalHighlightPref
)
;
this
.
finder
=
finder
;
}
FinderHighlighter
.
prototype
=
{
get
iterator
(
)
{
if
(
this
.
_iterator
)
return
this
.
_iterator
;
this
.
_iterator
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FinderIterator
.
jsm
"
null
)
.
FinderIterator
;
return
this
.
_iterator
;
}
getForWindow
(
window
propName
=
null
)
{
if
(
!
gWindows
.
has
(
window
)
)
{
gWindows
.
set
(
window
{
dynamicRangesSet
:
new
Set
(
)
frames
:
new
Map
(
)
modalHighlightRectsMap
:
new
Map
(
)
previousRangeRectsCount
:
0
}
)
;
}
return
gWindows
.
get
(
window
)
;
}
notifyFinished
(
highlight
)
{
for
(
let
l
of
this
.
finder
.
_listeners
)
{
try
{
l
.
onHighlightFinished
(
highlight
)
;
}
catch
(
ex
)
{
}
}
}
highlight
:
Task
.
async
(
function
*
(
highlight
word
linksOnly
)
{
let
window
=
this
.
finder
.
_getWindow
(
)
;
let
dict
=
this
.
getForWindow
(
window
)
;
let
controller
=
this
.
finder
.
_getSelectionController
(
window
)
;
let
doc
=
window
.
document
;
this
.
_found
=
false
;
if
(
!
controller
|
|
!
doc
|
|
!
doc
.
documentElement
)
{
return
this
.
_found
;
}
if
(
highlight
)
{
let
params
=
{
allowDistance
:
1
caseSensitive
:
this
.
finder
.
_fastFind
.
caseSensitive
entireWord
:
this
.
finder
.
_fastFind
.
entireWord
linksOnly
word
finder
:
this
.
finder
listener
:
this
useCache
:
true
}
;
if
(
this
.
iterator
.
_areParamsEqual
(
params
dict
.
lastIteratorParams
)
)
return
this
.
_found
;
if
(
params
)
{
yield
this
.
iterator
.
start
(
params
)
;
if
(
this
.
_found
)
this
.
finder
.
_outlineLink
(
true
)
;
}
}
else
{
this
.
hide
(
window
)
;
this
.
_found
=
true
;
}
this
.
notifyFinished
(
{
highlight
found
:
this
.
_found
}
)
;
return
this
.
_found
;
}
)
onIteratorRangeFound
(
range
)
{
this
.
highlightRange
(
range
)
;
this
.
_found
=
true
;
}
onIteratorReset
(
)
{
}
onIteratorRestart
(
)
{
this
.
clear
(
this
.
finder
.
_getWindow
(
)
)
;
}
onIteratorStart
(
params
)
{
let
window
=
this
.
finder
.
_getWindow
(
)
;
let
dict
=
this
.
getForWindow
(
window
)
;
dict
.
lastIteratorParams
=
params
;
if
(
!
this
.
_modal
)
this
.
hide
(
window
this
.
finder
.
_fastFind
.
getFoundRange
(
)
)
;
this
.
clear
(
window
)
;
}
highlightRange
(
range
)
{
let
node
=
range
.
startContainer
;
let
editableNode
=
this
.
_getEditableNode
(
node
)
;
let
window
=
node
.
ownerDocument
.
defaultView
;
let
controller
=
this
.
finder
.
_getSelectionController
(
window
)
;
if
(
editableNode
)
{
controller
=
editableNode
.
editor
.
selectionController
;
}
if
(
this
.
_modal
)
{
this
.
_modalHighlight
(
range
controller
window
)
;
}
else
{
let
findSelection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
findSelection
.
addRange
(
range
)
;
if
(
window
!
=
window
.
top
)
{
let
dict
=
this
.
getForWindow
(
window
.
top
)
;
if
(
!
dict
.
frames
.
has
(
window
)
)
dict
.
frames
.
set
(
window
null
)
;
}
}
if
(
editableNode
)
{
this
.
_addEditorListeners
(
editableNode
.
editor
)
;
}
}
show
(
window
=
null
)
{
window
=
(
window
|
|
this
.
finder
.
_getWindow
(
)
)
.
top
;
let
dict
=
this
.
getForWindow
(
window
)
;
if
(
!
this
.
_modal
|
|
dict
.
visible
)
return
;
dict
.
visible
=
true
;
this
.
_maybeCreateModalHighlightNodes
(
window
)
;
this
.
_addModalHighlightListeners
(
window
)
;
}
hide
(
window
=
null
skipRange
=
null
event
=
null
)
{
if
(
event
&
&
event
.
type
=
=
"
click
"
&
&
event
.
button
!
=
=
0
)
return
;
try
{
window
=
(
window
|
|
this
.
finder
.
_getWindow
(
)
)
.
top
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
return
;
}
let
dict
=
this
.
getForWindow
(
window
)
;
this
.
_clearSelection
(
this
.
finder
.
_getSelectionController
(
window
)
skipRange
)
;
for
(
let
frame
of
dict
.
frames
.
keys
(
)
)
this
.
_clearSelection
(
this
.
finder
.
_getSelectionController
(
frame
)
skipRange
)
;
if
(
this
.
_editors
)
{
let
doc
=
window
.
document
;
for
(
let
x
=
this
.
_editors
.
length
-
1
;
x
>
=
0
;
-
-
x
)
{
if
(
this
.
_editors
[
x
]
.
document
=
=
doc
)
{
this
.
_clearSelection
(
this
.
_editors
[
x
]
.
selectionController
skipRange
)
;
this
.
_unhookListenersAtIndex
(
x
)
;
}
}
}
if
(
dict
.
modalRepaintScheduler
)
{
window
.
clearTimeout
(
dict
.
modalRepaintScheduler
)
;
dict
.
modalRepaintScheduler
=
null
;
}
dict
.
lastWindowDimensions
=
null
;
if
(
dict
.
modalHighlightOutline
)
{
dict
.
modalHighlightOutline
.
setAttributeForElement
(
kModalOutlineId
"
style
"
dict
.
modalHighlightOutline
.
getAttributeForElement
(
kModalOutlineId
"
style
"
)
+
"
;
opacity
:
0
"
)
;
}
this
.
_removeHighlightAllMask
(
window
)
;
this
.
_removeModalHighlightListeners
(
window
)
;
dict
.
visible
=
false
;
}
update
(
data
)
{
let
window
=
this
.
finder
.
_getWindow
(
)
;
let
dict
=
this
.
getForWindow
(
window
)
;
let
foundRange
=
this
.
finder
.
_fastFind
.
getFoundRange
(
)
;
if
(
!
this
.
_modal
)
{
if
(
this
.
_highlightAll
)
{
dict
.
currentFoundRange
=
foundRange
;
let
params
=
this
.
iterator
.
params
;
if
(
this
.
iterator
.
_areParamsEqual
(
params
dict
.
lastIteratorParams
)
)
return
;
if
(
params
)
this
.
highlight
(
true
params
.
word
params
.
linksOnly
)
;
}
return
;
}
if
(
data
.
result
=
=
Ci
.
nsITypeAheadFind
.
FIND_NOTFOUND
|
|
!
data
.
searchString
|
|
!
foundRange
)
{
this
.
hide
(
)
;
return
;
}
if
(
foundRange
!
=
=
dict
.
currentFoundRange
|
|
data
.
findAgain
)
{
dict
.
currentFoundRange
=
foundRange
;
let
textContent
=
this
.
_getRangeContentArray
(
foundRange
)
;
if
(
!
textContent
.
length
)
{
this
.
hide
(
window
)
;
return
;
}
if
(
data
.
findAgain
)
dict
.
updateAllRanges
=
true
;
if
(
!
dict
.
visible
)
this
.
show
(
window
)
;
else
this
.
_maybeCreateModalHighlightNodes
(
window
)
;
this
.
_updateRangeOutline
(
dict
textContent
)
;
}
let
outlineNode
=
dict
.
modalHighlightOutline
;
if
(
outlineNode
)
{
if
(
dict
.
animation
)
dict
.
animation
.
finish
(
)
;
dict
.
animation
=
outlineNode
.
setAnimationForElement
(
kModalOutlineId
Cu
.
cloneInto
(
kModalOutlineAnim
.
keyframes
window
)
kModalOutlineAnim
.
duration
)
;
dict
.
animation
.
onfinish
=
(
)
=
>
dict
.
animation
=
null
;
}
if
(
this
.
_highlightAll
)
this
.
highlight
(
true
data
.
searchString
data
.
linksOnly
)
;
}
clear
(
window
=
null
)
{
if
(
!
window
)
{
for
(
let
win
of
gWindows
.
keys
(
)
)
this
.
hide
(
win
)
;
gWindows
.
clear
(
)
;
return
;
}
let
dict
=
this
.
getForWindow
(
window
.
top
)
;
if
(
dict
.
animation
)
dict
.
animation
.
finish
(
)
;
dict
.
dynamicRangesSet
.
clear
(
)
;
dict
.
frames
.
clear
(
)
;
dict
.
modalHighlightRectsMap
.
clear
(
)
;
dict
.
brightText
=
null
;
}
onLocationChange
(
)
{
let
window
=
this
.
finder
.
_getWindow
(
)
;
this
.
hide
(
window
)
;
let
dict
=
this
.
getForWindow
(
window
)
;
this
.
clear
(
window
)
;
dict
.
currentFoundRange
=
dict
.
lastIteratorParams
=
null
;
if
(
!
dict
.
modalHighlightOutline
)
return
;
if
(
kDebug
)
{
dict
.
modalHighlightOutline
.
remove
(
)
;
}
else
{
try
{
window
.
document
.
removeAnonymousContent
(
dict
.
modalHighlightOutline
)
;
}
catch
(
ex
)
{
}
}
dict
.
modalHighlightOutline
=
null
;
}
onModalHighlightChange
(
useModalHighlight
)
{
if
(
this
.
_modal
&
&
!
useModalHighlight
)
{
this
.
hide
(
)
;
this
.
clear
(
)
;
}
this
.
_modal
=
useModalHighlight
;
}
onHighlightAllChange
(
highlightAll
)
{
this
.
_highlightAll
=
highlightAll
;
if
(
!
highlightAll
)
{
let
window
=
this
.
finder
.
_getWindow
(
)
;
if
(
!
this
.
_modal
)
this
.
hide
(
window
)
;
this
.
clear
(
window
)
;
this
.
_scheduleRepaintOfMask
(
window
)
;
}
}
_clearSelection
(
controller
restoreRange
=
null
)
{
if
(
!
controller
)
return
;
let
sel
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
sel
.
removeAllRanges
(
)
;
if
(
restoreRange
)
{
sel
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_NORMAL
)
;
sel
.
addRange
(
restoreRange
)
;
controller
.
setDisplaySelection
(
Ci
.
nsISelectionController
.
SELECTION_ATTENTION
)
;
controller
.
repaintSelection
(
Ci
.
nsISelectionController
.
SELECTION_NORMAL
)
;
}
}
_getDWU
(
window
=
null
)
{
return
(
window
|
|
this
.
finder
.
_getWindow
(
)
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
_getRootBounds
(
window
includeScroll
=
true
)
{
let
dwu
=
this
.
_getDWU
(
window
.
top
)
;
let
cssPageRect
=
Rect
.
fromRect
(
dwu
.
getRootBounds
(
)
)
;
let
scrollX
=
{
}
;
let
scrollY
=
{
}
;
if
(
includeScroll
&
&
window
=
=
window
.
top
)
{
dwu
.
getScrollXY
(
false
scrollX
scrollY
)
;
cssPageRect
.
translate
(
scrollX
.
value
scrollY
.
value
)
;
}
let
currWin
=
window
;
while
(
currWin
!
=
window
.
top
)
{
let
el
=
this
.
_getDWU
(
currWin
)
.
containerElement
;
currWin
=
currWin
.
parent
;
dwu
=
this
.
_getDWU
(
currWin
)
;
let
parentRect
=
Rect
.
fromRect
(
dwu
.
getBoundsWithoutFlushing
(
el
)
)
;
if
(
includeScroll
)
{
dwu
.
getScrollXY
(
false
scrollX
scrollY
)
;
parentRect
.
translate
(
scrollX
.
value
scrollY
.
value
)
;
}
cssPageRect
.
translate
(
parentRect
.
left
parentRect
.
top
)
;
}
return
cssPageRect
;
}
_getWindowDimensions
(
window
)
{
let
dwu
=
this
.
_getDWU
(
window
)
;
let
{
width
height
}
=
dwu
.
getRootBounds
(
)
;
if
(
!
width
|
|
!
height
)
{
width
=
window
.
innerWidth
+
window
.
scrollMaxX
-
window
.
scrollMinX
;
height
=
window
.
innerHeight
+
window
.
scrollMaxY
-
window
.
scrollMinY
;
let
scrollbarHeight
=
{
}
;
let
scrollbarWidth
=
{
}
;
dwu
.
getScrollbarSize
(
false
scrollbarWidth
scrollbarHeight
)
;
width
-
=
scrollbarWidth
.
value
;
height
-
=
scrollbarHeight
.
value
;
}
return
{
width
height
}
;
}
_getRangeContentArray
(
range
)
{
let
content
=
range
.
cloneContents
(
)
;
let
t
textContent
=
[
]
;
for
(
let
node
of
content
.
childNodes
)
{
t
=
node
.
textContent
|
|
node
.
nodeValue
;
textContent
.
push
(
t
)
;
}
return
textContent
;
}
_getRangeFontStyle
(
range
)
{
let
node
=
range
.
startContainer
;
while
(
node
.
nodeType
!
=
1
)
node
=
node
.
parentNode
;
let
style
=
node
.
ownerDocument
.
defaultView
.
getComputedStyle
(
node
"
"
)
;
let
props
=
{
}
;
for
(
let
prop
of
kFontPropsCamelCase
)
{
if
(
prop
in
style
&
&
style
[
prop
]
)
props
[
prop
]
=
style
[
prop
]
;
}
return
props
;
}
_getHTMLFontStyle
(
fontStyle
)
{
let
style
=
[
]
;
for
(
let
prop
of
Object
.
getOwnPropertyNames
(
fontStyle
)
)
{
let
idx
=
kFontPropsCamelCase
.
indexOf
(
prop
)
;
if
(
idx
=
=
-
1
)
continue
;
style
.
push
(
{
kFontPropsCSS
[
idx
]
}
:
{
fontStyle
[
prop
]
}
)
;
}
return
style
.
join
(
"
;
"
)
;
}
_getStyleString
(
stylePairs
.
.
.
additionalStyles
)
{
let
baseStyle
=
new
Map
(
stylePairs
)
;
for
(
let
additionalStyle
of
additionalStyles
)
{
for
(
let
[
prop
value
]
of
additionalStyle
)
baseStyle
.
set
(
prop
value
)
;
}
return
[
.
.
.
baseStyle
]
.
map
(
(
[
cssProp
cssVal
]
)
=
>
{
cssProp
}
:
{
cssVal
}
)
.
join
(
"
;
"
)
;
}
_isColorBright
(
cssColor
)
{
cssColor
=
cssColor
.
match
(
kRGBRE
)
;
if
(
!
cssColor
|
|
!
cssColor
.
length
)
return
false
;
cssColor
.
shift
(
)
;
return
new
Color
(
.
.
.
cssColor
)
.
isBright
;
}
_detectBrightText
(
dict
)
{
let
sampleSize
=
Math
.
min
(
dict
.
modalHighlightRectsMap
.
size
kBrightTextSampleSize
)
;
let
ranges
=
[
.
.
.
dict
.
modalHighlightRectsMap
.
keys
(
)
]
;
let
rangesCount
=
ranges
.
length
;
if
(
sampleSize
%
2
=
=
0
)
{
if
(
dict
.
currentFoundRange
)
{
ranges
.
push
(
dict
.
currentFoundRange
)
;
+
+
sampleSize
;
+
+
rangesCount
;
}
else
{
-
-
sampleSize
;
}
}
let
brightCount
=
0
;
for
(
let
i
=
0
;
i
<
sampleSize
;
+
+
i
)
{
let
range
=
ranges
[
Math
.
floor
(
(
rangesCount
/
sampleSize
)
*
i
)
]
;
let
fontStyle
=
this
.
_getRangeFontStyle
(
range
)
;
if
(
this
.
_isColorBright
(
fontStyle
.
color
)
)
+
+
brightCount
;
}
dict
.
brightText
=
(
brightCount
>
=
Math
.
ceil
(
sampleSize
/
2
)
)
;
}
_isInDynamicContainer
(
range
)
{
const
kFixed
=
new
Set
(
[
"
fixed
"
"
sticky
"
"
scroll
"
"
auto
"
]
)
;
let
node
=
range
.
startContainer
;
while
(
node
.
nodeType
!
=
1
)
node
=
node
.
parentNode
;
let
document
=
node
.
ownerDocument
;
let
window
=
document
.
defaultView
;
let
dict
=
this
.
getForWindow
(
window
.
top
)
;
if
(
window
!
=
window
.
top
)
{
if
(
!
dict
.
frames
.
has
(
window
)
)
dict
.
frames
.
set
(
window
null
)
;
return
true
;
}
do
{
let
style
=
window
.
getComputedStyle
(
node
null
)
;
if
(
kFixed
.
has
(
style
.
position
)
|
|
kFixed
.
has
(
style
.
overflow
)
|
|
kFixed
.
has
(
style
.
overflowX
)
|
|
kFixed
.
has
(
style
.
overflowY
)
)
{
return
true
;
}
node
=
node
.
parentNode
;
}
while
(
node
&
&
node
!
=
document
.
documentElement
)
return
false
;
}
_getRangeRects
(
range
dict
=
null
)
{
let
window
=
range
.
startContainer
.
ownerDocument
.
defaultView
;
let
bounds
;
if
(
dict
&
&
dict
.
frames
.
has
(
window
)
)
{
bounds
=
dict
.
frames
.
get
(
window
)
;
if
(
!
bounds
)
{
bounds
=
this
.
_getRootBounds
(
window
)
;
dict
.
frames
.
set
(
window
bounds
)
;
}
}
else
bounds
=
this
.
_getRootBounds
(
window
)
;
let
topBounds
=
this
.
_getRootBounds
(
window
.
top
false
)
;
let
rects
=
new
Set
(
)
;
for
(
let
rect
of
range
.
getClientRects
(
)
)
{
rect
=
Rect
.
fromRect
(
rect
)
;
rect
.
x
+
=
bounds
.
x
;
rect
.
y
+
=
bounds
.
y
;
if
(
rect
.
intersects
(
topBounds
)
)
rects
.
add
(
rect
)
;
}
return
rects
;
}
_updateRangeRects
(
range
checkIfDynamic
=
true
dict
=
null
)
{
let
window
=
range
.
startContainer
.
ownerDocument
.
defaultView
;
let
rects
=
this
.
_getRangeRects
(
range
dict
)
;
dict
=
dict
|
|
this
.
getForWindow
(
window
.
top
)
;
dict
.
modalHighlightRectsMap
.
set
(
range
rects
)
;
if
(
checkIfDynamic
&
&
this
.
_isInDynamicContainer
(
range
)
)
dict
.
dynamicRangesSet
.
add
(
range
)
;
return
rects
;
}
_updateDynamicRangesRects
(
dict
)
{
for
(
let
frame
of
dict
.
frames
.
keys
(
)
)
dict
.
frames
.
set
(
frame
null
)
;
for
(
let
range
of
dict
.
dynamicRangesSet
)
this
.
_updateRangeRects
(
range
false
dict
)
;
}
_updateRangeOutline
(
dict
textContent
=
null
fontStyle
=
null
)
{
let
range
=
dict
.
currentFoundRange
;
if
(
!
range
)
return
;
fontStyle
=
fontStyle
|
|
this
.
_getRangeFontStyle
(
range
)
;
delete
fontStyle
.
color
;
let
rects
=
this
.
_getRangeRects
(
range
)
;
textContent
=
textContent
|
|
this
.
_getRangeContentArray
(
range
)
;
let
outlineAnonNode
=
dict
.
modalHighlightOutline
;
let
rectCount
=
rects
.
size
;
let
rebuildOutline
=
(
!
outlineAnonNode
|
|
rectCount
!
=
=
dict
.
previousRangeRectsCount
|
|
rectCount
!
=
1
)
;
dict
.
previousRangeRectsCount
=
rectCount
;
let
window
=
range
.
startContainer
.
ownerDocument
.
defaultView
.
top
;
let
document
=
window
.
document
;
if
(
rebuildOutline
&
&
outlineAnonNode
)
{
if
(
kDebug
)
{
outlineAnonNode
.
remove
(
)
;
}
else
{
try
{
document
.
removeAnonymousContent
(
outlineAnonNode
)
;
}
catch
(
ex
)
{
}
}
dict
.
modalHighlightOutline
=
null
;
}
if
(
!
textContent
.
length
)
return
;
let
outlineBox
;
if
(
rebuildOutline
)
{
outlineBox
=
document
.
createElementNS
(
kNSHTML
"
div
"
)
;
outlineBox
.
setAttribute
(
"
id
"
kModalOutlineId
)
;
}
const
kModalOutlineTextId
=
kModalOutlineId
+
"
-
text
"
;
let
i
=
0
;
for
(
let
rect
of
rects
)
{
let
text
=
(
i
=
=
rectCount
-
1
)
?
textContent
.
slice
(
i
)
.
join
(
"
"
)
:
textContent
[
i
]
;
+
+
i
;
let
outlineStyle
=
this
.
_getStyleString
(
kModalStyles
.
outlineNode
[
[
"
top
"
rect
.
top
+
"
px
"
]
[
"
left
"
rect
.
left
+
"
px
"
]
[
"
height
"
rect
.
height
+
"
px
"
]
[
"
width
"
rect
.
width
+
"
px
"
]
]
kDebug
?
kModalStyles
.
outlineNodeDebug
:
[
]
)
;
fontStyle
.
lineHeight
=
rect
.
height
+
"
px
"
;
let
textStyle
=
this
.
_getStyleString
(
kModalStyles
.
outlineText
)
+
"
;
"
+
this
.
_getHTMLFontStyle
(
fontStyle
)
;
if
(
rebuildOutline
)
{
let
textBoxParent
=
(
rectCount
=
=
1
)
?
outlineBox
:
outlineBox
.
appendChild
(
document
.
createElementNS
(
kNSHTML
"
div
"
)
)
;
textBoxParent
.
setAttribute
(
"
style
"
outlineStyle
)
;
let
textBox
=
document
.
createElementNS
(
kNSHTML
"
span
"
)
;
if
(
rectCount
=
=
1
)
textBox
.
setAttribute
(
"
id
"
kModalOutlineTextId
)
;
textBox
.
setAttribute
(
"
style
"
textStyle
)
;
textBox
.
textContent
=
text
;
textBoxParent
.
appendChild
(
textBox
)
;
}
else
{
outlineAnonNode
.
setAttributeForElement
(
kModalOutlineId
"
style
"
outlineStyle
)
;
outlineAnonNode
.
setAttributeForElement
(
kModalOutlineTextId
"
style
"
textStyle
)
;
outlineAnonNode
.
setTextContentForElement
(
kModalOutlineTextId
text
)
;
}
}
if
(
rebuildOutline
)
{
dict
.
modalHighlightOutline
=
kDebug
?
mockAnonymousContentNode
(
(
document
.
body
|
|
document
.
documentElement
)
.
appendChild
(
outlineBox
)
)
:
document
.
insertAnonymousContent
(
outlineBox
)
;
}
}
_modalHighlight
(
range
controller
window
)
{
if
(
!
this
.
_getRangeContentArray
(
range
)
.
length
)
return
;
this
.
_updateRangeRects
(
range
)
;
this
.
show
(
window
)
;
this
.
_scheduleRepaintOfMask
(
window
)
;
}
_maybeCreateModalHighlightNodes
(
window
)
{
window
=
window
.
top
;
let
dict
=
this
.
getForWindow
(
window
)
;
if
(
dict
.
modalHighlightOutline
)
{
if
(
!
dict
.
modalHighlightAllMask
)
{
this
.
_repaintHighlightAllMask
(
window
false
)
;
this
.
_scheduleRepaintOfMask
(
window
)
;
}
else
{
this
.
_scheduleRepaintOfMask
(
window
{
scrollOnly
:
true
}
)
;
}
return
;
}
let
document
=
window
.
document
;
if
(
document
.
hidden
)
{
let
onVisibilityChange
=
(
)
=
>
{
document
.
removeEventListener
(
"
visibilitychange
"
onVisibilityChange
)
;
this
.
_maybeCreateModalHighlightNodes
(
window
)
;
}
;
document
.
addEventListener
(
"
visibilitychange
"
onVisibilityChange
)
;
return
;
}
this
.
_updateRangeOutline
(
dict
)
;
this
.
_repaintHighlightAllMask
(
window
false
)
;
}
_repaintHighlightAllMask
(
window
paintContent
=
true
)
{
window
=
window
.
top
;
let
dict
=
this
.
getForWindow
(
window
)
;
const
kMaskId
=
kModalIdPrefix
+
"
-
findbar
-
modalHighlight
-
outlineMask
"
;
if
(
!
dict
.
modalHighlightAllMask
)
{
let
document
=
window
.
document
;
let
maskNode
=
document
.
createElementNS
(
kNSHTML
"
div
"
)
;
maskNode
.
setAttribute
(
"
id
"
kMaskId
)
;
dict
.
modalHighlightAllMask
=
kDebug
?
mockAnonymousContentNode
(
(
document
.
body
|
|
document
.
documentElement
)
.
appendChild
(
maskNode
)
)
:
document
.
insertAnonymousContent
(
maskNode
)
;
}
let
{
width
height
}
=
dict
.
lastWindowDimensions
=
this
.
_getWindowDimensions
(
window
)
;
if
(
typeof
dict
.
brightText
!
=
"
boolean
"
|
|
dict
.
updateAllRanges
)
this
.
_detectBrightText
(
dict
)
;
let
maskStyle
=
this
.
_getStyleString
(
kModalStyles
.
maskNode
[
[
"
width
"
width
+
"
px
"
]
[
"
height
"
height
+
"
px
"
]
]
dict
.
brightText
?
kModalStyles
.
maskNodeBrightText
:
[
]
kDebug
?
kModalStyles
.
maskNodeDebug
:
[
]
)
;
dict
.
modalHighlightAllMask
.
setAttributeForElement
(
kMaskId
"
style
"
maskStyle
)
;
if
(
dict
.
brightText
)
dict
.
modalHighlightAllMask
.
setAttributeForElement
(
kMaskId
"
brighttext
"
"
true
"
)
;
let
allRects
=
[
]
;
if
(
paintContent
|
|
dict
.
modalHighlightAllMask
)
{
this
.
_updateRangeOutline
(
dict
)
;
this
.
_updateDynamicRangesRects
(
dict
)
;
let
DOMRect
=
window
.
DOMRect
;
for
(
let
[
range
rects
]
of
dict
.
modalHighlightRectsMap
)
{
if
(
dict
.
updateAllRanges
)
rects
=
this
.
_updateRangeRects
(
range
)
;
if
(
this
.
_checkOverlap
(
dict
.
currentFoundRange
range
)
)
continue
;
for
(
let
rect
of
rects
)
allRects
.
push
(
new
DOMRect
(
rect
.
x
rect
.
y
rect
.
width
rect
.
height
)
)
;
}
dict
.
updateAllRanges
=
false
;
}
dict
.
modalHighlightAllMask
.
setCutoutRectsForElement
(
kMaskId
allRects
)
;
}
_removeHighlightAllMask
(
window
)
{
window
=
window
.
top
;
let
dict
=
this
.
getForWindow
(
window
)
;
if
(
!
dict
.
modalHighlightAllMask
)
return
;
if
(
kDebug
)
{
dict
.
modalHighlightAllMask
.
remove
(
)
;
}
else
{
try
{
window
.
document
.
removeAnonymousContent
(
dict
.
modalHighlightAllMask
)
;
}
catch
(
ex
)
{
}
}
dict
.
modalHighlightAllMask
=
null
;
}
_scheduleRepaintOfMask
(
window
{
contentChanged
scrollOnly
updateAllRanges
}
=
{
contentChanged
:
false
scrollOnly
:
false
updateAllRanges
:
false
}
)
{
if
(
!
this
.
_modal
)
return
;
window
=
window
.
top
;
let
dict
=
this
.
getForWindow
(
window
)
;
let
hasDynamicRanges
=
!
!
dict
.
dynamicRangesSet
.
size
;
let
repaintDynamicRanges
=
(
(
scrollOnly
|
|
contentChanged
)
&
&
hasDynamicRanges
)
;
if
(
!
dict
.
unconditionalRepaintRequested
)
dict
.
unconditionalRepaintRequested
=
!
contentChanged
|
|
repaintDynamicRanges
;
if
(
!
dict
.
updateAllRanges
)
dict
.
updateAllRanges
=
updateAllRanges
;
if
(
dict
.
modalRepaintScheduler
)
return
;
dict
.
modalRepaintScheduler
=
window
.
setTimeout
(
(
)
=
>
{
dict
.
modalRepaintScheduler
=
null
;
let
{
width
:
previousWidth
height
:
previousHeight
}
=
dict
.
lastWindowDimensions
;
let
{
width
height
}
=
dict
.
lastWindowDimensions
=
this
.
_getWindowDimensions
(
window
)
;
let
pageContentChanged
=
(
Math
.
abs
(
previousWidth
-
width
)
>
kContentChangeThresholdPx
|
|
Math
.
abs
(
previousHeight
-
height
)
>
kContentChangeThresholdPx
)
;
if
(
pageContentChanged
)
this
.
iterator
.
restart
(
this
.
finder
)
;
if
(
dict
.
unconditionalRepaintRequested
|
|
(
dict
.
modalHighlightRectsMap
.
size
&
&
pageContentChanged
)
)
{
dict
.
unconditionalRepaintRequested
=
false
;
this
.
_repaintHighlightAllMask
(
window
)
;
}
}
hasDynamicRanges
?
kModalHighlightRepaintHiFreqMs
:
kModalHighlightRepaintLoFreqMs
)
;
}
_addModalHighlightListeners
(
window
)
{
window
=
window
.
top
;
let
dict
=
this
.
getForWindow
(
window
)
;
if
(
dict
.
highlightListeners
)
return
;
window
=
window
.
top
;
dict
.
highlightListeners
=
[
this
.
_scheduleRepaintOfMask
.
bind
(
this
window
{
contentChanged
:
true
}
)
this
.
_scheduleRepaintOfMask
.
bind
(
this
window
{
updateAllRanges
:
true
}
)
this
.
_scheduleRepaintOfMask
.
bind
(
this
window
{
scrollOnly
:
true
}
)
this
.
hide
.
bind
(
this
window
null
)
]
;
let
target
=
this
.
iterator
.
_getDocShell
(
window
)
.
chromeEventHandler
;
target
.
addEventListener
(
"
MozAfterPaint
"
dict
.
highlightListeners
[
0
]
)
;
target
.
addEventListener
(
"
resize
"
dict
.
highlightListeners
[
1
]
)
;
target
.
addEventListener
(
"
scroll
"
dict
.
highlightListeners
[
2
]
)
;
target
.
addEventListener
(
"
click
"
dict
.
highlightListeners
[
3
]
)
;
}
_removeModalHighlightListeners
(
window
)
{
window
=
window
.
top
;
let
dict
=
this
.
getForWindow
(
window
)
;
if
(
!
dict
.
highlightListeners
)
return
;
let
target
=
this
.
iterator
.
_getDocShell
(
window
)
.
chromeEventHandler
;
target
.
removeEventListener
(
"
MozAfterPaint
"
dict
.
highlightListeners
[
0
]
)
;
target
.
removeEventListener
(
"
resize
"
dict
.
highlightListeners
[
1
]
)
;
target
.
removeEventListener
(
"
scroll
"
dict
.
highlightListeners
[
2
]
)
;
target
.
removeEventListener
(
"
click
"
dict
.
highlightListeners
[
3
]
)
;
dict
.
highlightListeners
=
null
;
}
_getEditableNode
(
node
)
{
if
(
node
.
nodeType
=
=
=
node
.
TEXT_NODE
&
&
node
.
parentNode
&
&
node
.
parentNode
.
parentNode
&
&
node
.
parentNode
.
parentNode
instanceof
Ci
.
nsIDOMNSEditableElement
)
{
return
node
.
parentNode
.
parentNode
;
}
return
null
;
}
_addEditorListeners
(
editor
)
{
if
(
!
this
.
_editors
)
{
this
.
_editors
=
[
]
;
this
.
_stateListeners
=
[
]
;
}
let
existingIndex
=
this
.
_editors
.
indexOf
(
editor
)
;
if
(
existingIndex
=
=
-
1
)
{
let
x
=
this
.
_editors
.
length
;
this
.
_editors
[
x
]
=
editor
;
this
.
_stateListeners
[
x
]
=
this
.
_createStateListener
(
)
;
this
.
_editors
[
x
]
.
addEditActionListener
(
this
)
;
this
.
_editors
[
x
]
.
addDocumentStateListener
(
this
.
_stateListeners
[
x
]
)
;
}
}
_unhookListenersAtIndex
(
idx
)
{
this
.
_editors
[
idx
]
.
removeEditActionListener
(
this
)
;
this
.
_editors
[
idx
]
.
removeDocumentStateListener
(
this
.
_stateListeners
[
idx
]
)
;
this
.
_editors
.
splice
(
idx
1
)
;
this
.
_stateListeners
.
splice
(
idx
1
)
;
if
(
!
this
.
_editors
.
length
)
{
delete
this
.
_editors
;
delete
this
.
_stateListeners
;
}
}
_removeEditorListeners
(
editor
)
{
let
idx
=
this
.
_editors
.
indexOf
(
editor
)
;
if
(
idx
=
=
-
1
)
{
return
;
}
this
.
_unhookListenersAtIndex
(
idx
)
;
}
_checkOverlap
(
selectionRange
findRange
)
{
if
(
!
selectionRange
|
|
!
findRange
)
return
false
;
if
(
findRange
.
isPointInRange
(
selectionRange
.
startContainer
selectionRange
.
startOffset
)
)
return
true
;
if
(
findRange
.
isPointInRange
(
selectionRange
.
endContainer
selectionRange
.
endOffset
)
)
return
true
;
if
(
selectionRange
.
isPointInRange
(
findRange
.
startContainer
findRange
.
startOffset
)
)
return
true
;
if
(
selectionRange
.
isPointInRange
(
findRange
.
endContainer
findRange
.
endOffset
)
)
return
true
;
return
false
;
}
_findRange
(
selection
node
offset
)
{
let
rangeCount
=
selection
.
rangeCount
;
let
rangeidx
=
0
;
let
foundContainingRange
=
false
;
let
range
=
null
;
while
(
!
foundContainingRange
&
&
rangeidx
<
rangeCount
)
{
range
=
selection
.
getRangeAt
(
rangeidx
)
;
if
(
range
.
isPointInRange
(
node
offset
)
)
{
foundContainingRange
=
true
;
break
;
}
rangeidx
+
+
;
}
if
(
foundContainingRange
)
{
return
range
;
}
return
null
;
}
WillDeleteText
(
textNode
offset
length
)
{
let
editor
=
this
.
_getEditableNode
(
textNode
)
.
editor
;
let
controller
=
editor
.
selectionController
;
let
fSelection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
let
range
=
this
.
_findRange
(
fSelection
textNode
offset
)
;
if
(
range
)
{
if
(
textNode
!
=
range
.
endContainer
|
|
offset
!
=
range
.
endOffset
)
{
fSelection
.
removeRange
(
range
)
;
if
(
fSelection
.
rangeCount
=
=
0
)
{
this
.
_removeEditorListeners
(
editor
)
;
}
}
}
}
DidInsertText
(
textNode
offset
aString
)
{
let
editor
=
this
.
_getEditableNode
(
textNode
)
.
editor
;
let
controller
=
editor
.
selectionController
;
let
fSelection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
let
range
=
this
.
_findRange
(
fSelection
textNode
offset
)
;
if
(
range
)
{
if
(
textNode
=
=
range
.
startContainer
&
&
offset
=
=
range
.
startOffset
)
{
range
.
setStart
(
range
.
startContainer
range
.
startOffset
+
aString
.
length
)
;
}
else
if
(
textNode
!
=
range
.
endContainer
|
|
offset
!
=
range
.
endOffset
)
{
fSelection
.
removeRange
(
range
)
;
if
(
fSelection
.
rangeCount
=
=
0
)
{
this
.
_removeEditorListeners
(
editor
)
;
}
}
}
}
WillDeleteSelection
(
selection
)
{
let
editor
=
this
.
_getEditableNode
(
selection
.
getRangeAt
(
0
)
.
startContainer
)
.
editor
;
let
controller
=
editor
.
selectionController
;
let
fSelection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
let
selectionIndex
=
0
;
let
findSelectionIndex
=
0
;
let
shouldDelete
=
{
}
;
let
numberOfDeletedSelections
=
0
;
let
numberOfMatches
=
fSelection
.
rangeCount
;
for
(
let
fIndex
=
0
;
fIndex
<
numberOfMatches
;
fIndex
+
+
)
{
shouldDelete
[
fIndex
]
=
false
;
let
fRange
=
fSelection
.
getRangeAt
(
fIndex
)
;
for
(
let
index
=
0
;
index
<
selection
.
rangeCount
;
index
+
+
)
{
if
(
shouldDelete
[
fIndex
]
)
{
continue
;
}
let
selRange
=
selection
.
getRangeAt
(
index
)
;
let
doesOverlap
=
this
.
_checkOverlap
(
selRange
fRange
)
;
if
(
doesOverlap
)
{
shouldDelete
[
fIndex
]
=
true
;
numberOfDeletedSelections
+
+
;
}
}
}
if
(
!
numberOfDeletedSelections
)
{
return
;
}
for
(
let
i
=
numberOfMatches
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
shouldDelete
[
i
]
)
fSelection
.
removeRange
(
fSelection
.
getRangeAt
(
i
)
)
;
}
if
(
!
fSelection
.
rangeCount
)
{
this
.
_removeEditorListeners
(
editor
)
;
}
}
_onEditorDestruction
(
aListener
)
{
let
idx
=
0
;
while
(
this
.
_stateListeners
[
idx
]
!
=
aListener
)
{
idx
+
+
;
}
this
.
_unhookListenersAtIndex
(
idx
)
;
}
_createStateListener
(
)
{
return
{
findbar
:
this
QueryInterface
:
function
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIDocumentStateListener
)
|
|
iid
.
equals
(
Ci
.
nsISupports
)
)
return
this
;
throw
Components
.
results
.
NS_ERROR_NO_INTERFACE
;
}
NotifyDocumentWillBeDestroyed
:
function
(
)
{
this
.
findbar
.
_onEditorDestruction
(
this
)
;
}
notifyDocumentCreated
:
function
(
)
{
}
notifyDocumentStateChanged
:
function
(
aDirty
)
{
}
}
;
}
}
;
