"
use
strict
"
;
importScripts
(
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_shared
.
js
"
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_shared_win
.
js
"
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_worker_common
.
js
"
)
;
const
POLL_TIMEOUT
=
5000
;
const
TERMINATE_EXIT_CODE
=
0x7f
;
let
io
;
class
IOCPKeyGen
{
static
IOCP_KEY_IS_PIPE
=
1
<
<
31
;
static
IOCP_KEY_IS_PROC
=
1
<
<
30
;
static
keyForPipe
(
pipe
)
{
return
(
IOCPKeyGen
.
IOCP_KEY_IS_PIPE
|
pipe
.
id
)
>
>
>
0
;
}
static
keyForProcess
(
process
)
{
return
(
IOCPKeyGen
.
IOCP_KEY_IS_PROC
|
process
.
id
)
>
>
>
0
;
}
static
isPipeKey
(
completionKey
)
{
return
!
!
(
IOCPKeyGen
.
IOCP_KEY_IS_PIPE
&
completionKey
)
;
}
static
isProcessKey
(
completionKey
)
{
return
!
!
(
IOCPKeyGen
.
IOCP_KEY_IS_PROC
&
completionKey
)
;
}
static
pipeIdFromKey
(
completionKey
)
{
return
(
~
IOCPKeyGen
.
IOCP_KEY_IS_PIPE
&
completionKey
)
>
>
>
0
;
}
static
processIdFromKey
(
completionKey
)
{
return
(
~
IOCPKeyGen
.
IOCP_KEY_IS_PROC
&
completionKey
)
>
>
>
0
;
}
}
let
nextPipeId
=
0
;
class
Pipe
extends
BasePipe
{
constructor
(
process
origHandle
)
{
super
(
)
;
let
handle
=
win32
.
HANDLE
(
)
;
let
curProc
=
libc
.
GetCurrentProcess
(
)
;
libc
.
DuplicateHandle
(
curProc
origHandle
curProc
handle
.
address
(
)
0
false
win32
.
DUPLICATE_SAME_ACCESS
)
;
origHandle
.
dispose
(
)
;
this
.
id
=
nextPipeId
+
+
;
this
.
process
=
process
;
this
.
handle
=
win32
.
Handle
(
handle
)
;
this
.
overlapped
=
win32
.
OVERLAPPED
(
)
;
let
ok
=
libc
.
CreateIoCompletionPort
(
handle
io
.
iocpCompletionPort
IOCPKeyGen
.
keyForPipe
(
this
)
0
)
;
if
(
!
ok
)
{
debug
(
Failed
to
associate
IOCP
:
{
ctypes
.
winLastError
}
)
;
}
this
.
buffer
=
null
;
}
hasPendingIO
(
)
{
return
!
!
this
.
pending
.
length
;
}
maybeClose
(
)
{
}
close
(
force
=
false
)
{
if
(
!
force
&
&
this
.
pending
.
length
)
{
this
.
closing
=
true
;
return
this
.
closedPromise
;
}
for
(
let
{
reject
}
of
this
.
pending
)
{
let
error
=
new
Error
(
"
File
closed
"
)
;
error
.
errorCode
=
SubprocessConstants
.
ERROR_END_OF_FILE
;
reject
(
error
)
;
}
this
.
pending
.
length
=
0
;
this
.
buffer
=
null
;
if
(
!
this
.
closed
)
{
this
.
handle
.
dispose
(
)
;
io
.
pipes
.
delete
(
this
.
id
)
;
this
.
handle
=
null
;
this
.
closed
=
true
;
this
.
resolveClosed
(
)
;
io
.
updatePollEvents
(
)
;
}
return
this
.
closedPromise
;
}
onError
(
)
{
this
.
close
(
true
)
;
}
}
class
InputPipe
extends
Pipe
{
readNext
(
)
{
if
(
this
.
buffer
=
=
=
null
)
{
this
.
readBuffer
(
this
.
pending
[
0
]
.
length
)
;
}
}
maybeClose
(
)
{
if
(
this
.
buffer
)
{
let
read
=
win32
.
DWORD
(
)
;
let
ok
=
libc
.
GetOverlappedResult
(
this
.
handle
this
.
overlapped
.
address
(
)
read
.
address
(
)
false
)
;
if
(
!
ok
)
{
this
.
onError
(
)
;
}
}
}
read
(
length
)
{
if
(
this
.
closing
|
|
this
.
closed
)
{
throw
new
Error
(
"
Attempt
to
read
from
closed
pipe
"
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
pending
.
push
(
{
resolve
reject
length
}
)
;
this
.
readNext
(
)
;
}
)
;
}
readBuffer
(
count
)
{
this
.
buffer
=
new
ArrayBuffer
(
count
)
;
let
ok
=
libc
.
ReadFile
(
this
.
handle
this
.
buffer
count
null
this
.
overlapped
.
address
(
)
)
;
if
(
!
ok
&
&
(
!
this
.
process
.
handle
|
|
ctypes
.
winLastError
)
)
{
this
.
onError
(
)
;
}
else
{
io
.
updatePollEvents
(
)
;
}
}
onReady
(
)
{
let
read
=
win32
.
DWORD
(
)
;
let
ok
=
libc
.
GetOverlappedResult
(
this
.
handle
this
.
overlapped
.
address
(
)
read
.
address
(
)
false
)
;
read
=
read
.
value
;
if
(
!
ok
)
{
this
.
onError
(
)
;
}
else
if
(
read
>
0
)
{
let
buffer
=
this
.
buffer
;
this
.
buffer
=
null
;
let
{
resolve
}
=
this
.
shiftPending
(
)
;
if
(
read
=
=
buffer
.
byteLength
)
{
resolve
(
buffer
)
;
}
else
{
resolve
(
ArrayBuffer_transfer
(
buffer
read
)
)
;
}
if
(
this
.
pending
.
length
)
{
this
.
readNext
(
)
;
}
else
{
io
.
updatePollEvents
(
)
;
}
}
}
}
class
OutputPipe
extends
Pipe
{
writeNext
(
)
{
if
(
this
.
buffer
=
=
=
null
)
{
this
.
writeBuffer
(
this
.
pending
[
0
]
.
buffer
)
;
}
}
write
(
buffer
)
{
if
(
this
.
closing
|
|
this
.
closed
)
{
throw
new
Error
(
"
Attempt
to
write
to
closed
pipe
"
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
pending
.
push
(
{
resolve
reject
buffer
}
)
;
this
.
writeNext
(
)
;
}
)
;
}
writeBuffer
(
buffer
)
{
this
.
buffer
=
buffer
;
let
ok
=
libc
.
WriteFile
(
this
.
handle
buffer
buffer
.
byteLength
null
this
.
overlapped
.
address
(
)
)
;
if
(
!
ok
&
&
libc
.
winLastError
)
{
this
.
onError
(
)
;
}
else
{
io
.
updatePollEvents
(
)
;
}
}
onReady
(
)
{
let
written
=
win32
.
DWORD
(
)
;
let
ok
=
libc
.
GetOverlappedResult
(
this
.
handle
this
.
overlapped
.
address
(
)
written
.
address
(
)
false
)
;
written
=
written
.
value
;
if
(
!
ok
|
|
written
!
=
this
.
buffer
.
byteLength
)
{
this
.
onError
(
)
;
}
else
if
(
written
>
0
)
{
let
{
resolve
}
=
this
.
shiftPending
(
)
;
this
.
buffer
=
null
;
resolve
(
written
)
;
if
(
this
.
pending
.
length
)
{
this
.
writeNext
(
)
;
}
else
{
io
.
updatePollEvents
(
)
;
}
}
}
}
class
Process
extends
BaseProcess
{
constructor
(
.
.
.
args
)
{
super
(
.
.
.
args
)
;
this
.
killed
=
false
;
}
kill
(
)
{
this
.
killed
=
true
;
libc
.
TerminateJobObject
(
this
.
jobHandle
TERMINATE_EXIT_CODE
)
;
}
initPipes
(
{
stderr
}
)
{
let
our_pipes
=
[
]
;
let
their_pipes
=
[
]
;
let
secAttr
=
new
win32
.
SECURITY_ATTRIBUTES
(
)
;
secAttr
.
nLength
=
win32
.
SECURITY_ATTRIBUTES
.
size
;
secAttr
.
bInheritHandle
=
true
;
let
pipe
=
input
=
>
{
if
(
input
)
{
let
handles
=
win32
.
createPipe
(
secAttr
win32
.
FILE_FLAG_OVERLAPPED
)
;
our_pipes
.
push
(
new
InputPipe
(
this
handles
[
0
]
)
)
;
return
handles
[
1
]
;
}
let
handles
=
win32
.
createPipe
(
secAttr
0
win32
.
FILE_FLAG_OVERLAPPED
)
;
our_pipes
.
push
(
new
OutputPipe
(
this
handles
[
1
]
)
)
;
return
handles
[
0
]
;
}
;
their_pipes
[
0
]
=
pipe
(
false
)
;
their_pipes
[
1
]
=
pipe
(
true
)
;
if
(
stderr
=
=
"
pipe
"
)
{
their_pipes
[
2
]
=
pipe
(
true
)
;
}
else
{
let
srcHandle
;
if
(
stderr
=
=
"
stdout
"
)
{
srcHandle
=
their_pipes
[
1
]
;
}
else
{
srcHandle
=
libc
.
GetStdHandle
(
win32
.
STD_ERROR_HANDLE
)
;
}
if
(
String
(
srcHandle
)
=
=
win32
.
INVALID_HANDLE_VALUE
|
|
String
(
srcHandle
)
=
=
win32
.
NULL_HANDLE_VALUE
)
{
their_pipes
[
2
]
=
srcHandle
;
}
else
{
let
handle
=
win32
.
HANDLE
(
)
;
let
curProc
=
libc
.
GetCurrentProcess
(
)
;
let
ok
=
libc
.
DuplicateHandle
(
curProc
srcHandle
curProc
handle
.
address
(
)
0
true
win32
.
DUPLICATE_SAME_ACCESS
)
;
their_pipes
[
2
]
=
ok
&
&
win32
.
Handle
(
handle
)
;
}
}
if
(
!
their_pipes
.
every
(
handle
=
>
handle
)
)
{
throw
new
Error
(
"
Failed
to
create
pipe
"
)
;
}
this
.
pipes
=
our_pipes
;
return
their_pipes
;
}
stringList
(
strings
)
{
strings
=
strings
.
filter
(
string
=
>
string
)
;
let
string
=
strings
.
join
(
"
\
0
"
)
+
"
\
0
\
0
"
;
return
win32
.
WCHAR
.
array
(
)
(
string
)
;
}
quoteString
(
str
)
{
if
(
!
/
[
\
s
"
]
/
.
test
(
str
)
)
{
return
str
;
}
let
escaped
=
str
.
replace
(
/
(
\
\
*
)
(
"
|
)
/
g
(
m0
m1
m2
)
=
>
{
if
(
m2
)
{
m2
=
\
\
{
m2
}
;
}
return
{
m1
}
{
m1
}
{
m2
}
;
}
)
;
return
"
{
escaped
}
"
;
}
spawn
(
options
)
{
let
{
command
arguments
:
args
}
=
options
;
if
(
/
\
\
cmd
\
.
exe
/
i
.
test
(
command
)
&
&
args
.
length
=
=
3
&
&
/
^
(
\
/
S
)
?
\
/
C
/
i
.
test
(
args
[
1
]
)
)
{
args
=
[
this
.
quoteString
(
args
[
0
]
)
"
/
S
/
C
"
"
{
args
[
2
]
}
"
]
;
}
else
{
args
=
args
.
map
(
arg
=
>
this
.
quoteString
(
arg
)
)
;
}
if
(
/
\
.
(
bat
|
cmd
)
/
i
.
test
(
command
)
)
{
command
=
io
.
comspec
;
args
=
[
"
cmd
.
exe
"
"
/
s
/
c
"
"
{
args
.
join
(
"
"
)
}
"
]
;
}
let
envp
=
this
.
stringList
(
options
.
environment
)
;
let
handles
=
this
.
initPipes
(
options
)
;
let
processFlags
=
win32
.
CREATE_NO_WINDOW
|
win32
.
CREATE_SUSPENDED
|
win32
.
CREATE_UNICODE_ENVIRONMENT
;
let
startupInfoEx
=
new
win32
.
STARTUPINFOEXW
(
)
;
let
startupInfo
=
startupInfoEx
.
StartupInfo
;
startupInfo
.
cb
=
win32
.
STARTUPINFOW
.
size
;
startupInfo
.
dwFlags
=
win32
.
STARTF_USESTDHANDLES
;
startupInfo
.
hStdInput
=
handles
[
0
]
;
startupInfo
.
hStdOutput
=
handles
[
1
]
;
startupInfo
.
hStdError
=
handles
[
2
]
;
let
handleArray
=
win32
.
HANDLE
.
array
(
)
(
handles
)
;
let
threadAttrs
=
win32
.
createThreadAttributeList
(
handleArray
)
;
if
(
threadAttrs
)
{
processFlags
|
=
win32
.
EXTENDED_STARTUPINFO_PRESENT
;
startupInfo
.
cb
=
win32
.
STARTUPINFOEXW
.
size
;
startupInfoEx
.
lpAttributeList
=
threadAttrs
;
}
let
procInfo
=
new
win32
.
PROCESS_INFORMATION
(
)
;
let
errorMessage
=
"
Failed
to
create
process
"
;
let
ok
=
libc
.
CreateProcessW
(
command
args
.
join
(
"
"
)
null
null
true
processFlags
envp
options
.
workdir
startupInfo
.
address
(
)
procInfo
.
address
(
)
)
;
for
(
let
handle
of
new
Set
(
handles
)
)
{
if
(
handle
&
&
handle
.
dispose
)
{
handle
.
dispose
(
)
;
}
}
if
(
threadAttrs
)
{
libc
.
DeleteProcThreadAttributeList
(
threadAttrs
)
;
}
if
(
ok
)
{
this
.
jobHandle
=
win32
.
Handle
(
libc
.
CreateJobObjectW
(
null
null
)
)
;
let
info
=
win32
.
JOBOBJECT_EXTENDED_LIMIT_INFORMATION
(
)
;
info
.
BasicLimitInformation
.
LimitFlags
=
win32
.
JOB_OBJECT_LIMIT_BREAKAWAY_OK
;
ok
=
libc
.
SetInformationJobObject
(
this
.
jobHandle
win32
.
JobObjectExtendedLimitInformation
ctypes
.
cast
(
info
.
address
(
)
ctypes
.
voidptr_t
)
info
.
constructor
.
size
)
;
if
(
!
ok
)
{
errorMessage
=
Failed
to
set
job
limits
:
0x
{
(
ctypes
.
winLastError
|
|
0
)
.
toString
(
16
)
}
;
}
}
if
(
ok
)
{
let
acp
=
win32
.
JOBOBJECT_ASSOCIATE_COMPLETION_PORT
(
)
;
acp
.
CompletionKey
=
win32
.
PVOID
(
IOCPKeyGen
.
keyForProcess
(
this
)
)
;
acp
.
CompletionPort
=
io
.
iocpCompletionPort
;
ok
=
libc
.
SetInformationJobObject
(
this
.
jobHandle
win32
.
JobObjectAssociateCompletionPortInformation
ctypes
.
cast
(
acp
.
address
(
)
ctypes
.
voidptr_t
)
acp
.
constructor
.
size
)
;
if
(
!
ok
)
{
errorMessage
=
Failed
to
set
IOCP
:
0x
{
(
ctypes
.
winLastError
|
|
0
)
.
toString
(
16
)
}
;
}
}
if
(
ok
)
{
ok
=
libc
.
AssignProcessToJobObject
(
this
.
jobHandle
procInfo
.
hProcess
)
;
if
(
!
ok
)
{
errorMessage
=
Failed
to
attach
process
to
job
object
:
0x
{
(
ctypes
.
winLastError
|
|
0
)
.
toString
(
16
)
}
;
libc
.
TerminateProcess
(
procInfo
.
hProcess
TERMINATE_EXIT_CODE
)
;
}
}
if
(
!
ok
)
{
for
(
let
pipe
of
this
.
pipes
)
{
pipe
.
close
(
)
;
}
throw
new
Error
(
errorMessage
)
;
}
this
.
handle
=
win32
.
Handle
(
procInfo
.
hProcess
)
;
this
.
pid
=
procInfo
.
dwProcessId
;
libc
.
ResumeThread
(
procInfo
.
hThread
)
;
libc
.
CloseHandle
(
procInfo
.
hThread
)
;
}
connectRunning
(
_options
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
onReady
(
)
{
this
.
wait
(
)
;
}
wait
(
)
{
if
(
this
.
exitCode
!
=
=
null
)
{
return
this
.
exitCode
;
}
let
status
=
win32
.
DWORD
(
)
;
let
ok
=
libc
.
GetExitCodeProcess
(
this
.
handle
status
.
address
(
)
)
;
if
(
ok
&
&
status
.
value
!
=
win32
.
STILL_ACTIVE
)
{
let
exitCode
=
status
.
value
;
if
(
this
.
killed
&
&
exitCode
=
=
TERMINATE_EXIT_CODE
)
{
exitCode
=
-
9
;
}
this
.
resolveExit
(
exitCode
)
;
this
.
exitCode
=
exitCode
;
this
.
handle
.
dispose
(
)
;
this
.
handle
=
null
;
libc
.
TerminateJobObject
(
this
.
jobHandle
TERMINATE_EXIT_CODE
)
;
this
.
jobHandle
.
dispose
(
)
;
this
.
jobHandle
=
null
;
for
(
let
pipe
of
this
.
pipes
)
{
pipe
.
maybeClose
(
)
;
}
io
.
updatePollEvents
(
)
;
return
exitCode
;
}
}
}
io
=
{
iocpCompletionPort
:
null
pipes
:
new
Map
(
)
processes
:
new
Map
(
)
messageCount
:
0
running
:
true
polling
:
false
init
(
details
)
{
this
.
comspec
=
details
.
comspec
;
this
.
iocpCompletionPort
=
ctypes
.
cast
(
ctypes
.
uintptr_t
(
details
.
iocpCompletionPort
)
win32
.
HANDLE
)
;
this
.
updatePollEvents
(
)
;
setTimeout
(
this
.
loop
.
bind
(
this
)
0
)
;
}
shutdown
(
)
{
if
(
this
.
running
)
{
this
.
running
=
false
;
self
.
postMessage
(
{
msg
:
"
close
"
}
)
;
self
.
close
(
)
;
}
}
getPipe
(
pipeId
)
{
let
pipe
=
this
.
pipes
.
get
(
pipeId
)
;
if
(
!
pipe
)
{
let
error
=
new
Error
(
"
File
closed
"
)
;
error
.
errorCode
=
SubprocessConstants
.
ERROR_END_OF_FILE
;
throw
error
;
}
return
pipe
;
}
getProcess
(
processId
)
{
let
process
=
this
.
processes
.
get
(
processId
)
;
if
(
!
process
)
{
throw
new
Error
(
Invalid
process
ID
:
{
processId
}
)
;
}
return
process
;
}
updatePollEvents
(
)
{
let
shouldPoll
=
false
;
for
(
const
process
of
this
.
processes
.
values
(
)
)
{
if
(
process
.
handle
)
{
shouldPoll
=
true
;
break
;
}
}
if
(
!
shouldPoll
)
{
for
(
let
pipe
of
this
.
pipes
.
values
(
)
)
{
if
(
pipe
.
hasPendingIO
(
)
)
{
shouldPoll
=
true
;
break
;
}
}
}
if
(
!
shouldPoll
)
{
this
.
polling
=
false
;
}
else
if
(
!
this
.
polling
&
&
this
.
running
)
{
setTimeout
(
this
.
loop
.
bind
(
this
)
0
)
;
this
.
polling
=
true
;
}
}
loop
(
)
{
this
.
poll
(
)
;
if
(
this
.
running
&
&
this
.
polling
)
{
setTimeout
(
this
.
loop
.
bind
(
this
)
0
)
;
}
}
poll
(
)
{
let
timeout
=
this
.
messageCount
>
0
?
0
:
POLL_TIMEOUT
;
for
(
;
;
timeout
=
0
)
{
let
numberOfBytesTransferred
=
win32
.
DWORD
(
)
;
let
completionKeyOut
=
win32
.
ULONG_PTR
(
)
;
let
lpOverlapped
=
win32
.
OVERLAPPED
.
ptr
(
0
)
;
let
ok
=
libc
.
GetQueuedCompletionStatus
(
io
.
iocpCompletionPort
numberOfBytesTransferred
.
address
(
)
completionKeyOut
.
address
(
)
lpOverlapped
.
address
(
)
timeout
)
;
const
deqWinErr
=
ok
?
0
:
ctypes
.
winLastError
;
if
(
!
ok
)
{
if
(
deqWinErr
=
=
=
win32
.
WAIT_TIMEOUT
)
{
break
;
}
if
(
deqWinErr
=
=
=
win32
.
ERROR_ABANDONED_WAIT_0
)
{
io
.
shutdown
(
)
;
break
;
}
if
(
lpOverlapped
.
isNull
(
)
)
{
break
;
}
}
let
completionKey
=
parseInt
(
completionKeyOut
.
value
10
)
;
if
(
completionKey
=
=
=
win32
.
IOCP_COMPLETION_KEY_WAKE_WORKER
)
{
io
.
messageCount
+
=
1
;
continue
;
}
if
(
IOCPKeyGen
.
isPipeKey
(
completionKey
)
)
{
const
pipeId
=
IOCPKeyGen
.
pipeIdFromKey
(
completionKey
)
;
const
pipe
=
io
.
pipes
.
get
(
pipeId
)
;
if
(
!
pipe
)
{
debug
(
IOCP
notification
for
unknown
pipe
:
{
pipeId
}
)
;
continue
;
}
if
(
deqWinErr
=
=
=
win32
.
ERROR_BROKEN_PIPE
)
{
pipe
.
onError
(
)
;
continue
;
}
try
{
pipe
.
onReady
(
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
debug
(
Worker
error
:
{
e
}
:
:
{
e
.
stack
}
)
;
pipe
.
onError
(
)
;
}
}
else
if
(
IOCPKeyGen
.
isProcessKey
(
completionKey
)
)
{
const
jobMsgId
=
numberOfBytesTransferred
.
value
;
const
processId
=
IOCPKeyGen
.
processIdFromKey
(
completionKey
)
;
const
isExit
=
jobMsgId
=
=
=
win32
.
JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS
|
|
jobMsgId
=
=
=
win32
.
JOB_OBJECT_MSG_EXIT_PROCESS
;
const
isJobZero
=
jobMsgId
=
=
=
win32
.
JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO
;
if
(
!
isExit
&
&
!
isJobZero
)
{
continue
;
}
const
process
=
io
.
processes
.
get
(
processId
)
;
if
(
!
process
)
{
continue
;
}
if
(
isExit
)
{
let
realPid
=
ctypes
.
cast
(
lpOverlapped
win32
.
DWORD
)
.
value
;
if
(
process
.
pid
!
=
=
realPid
)
{
continue
;
}
}
try
{
process
.
onReady
(
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
debug
(
Worker
error
:
{
e
}
:
:
{
e
.
stack
}
)
;
}
}
else
{
debug
(
Unexpected
IOCP
CompletionKey
:
{
completionKey
}
)
;
}
}
}
addProcess
(
process
)
{
this
.
processes
.
set
(
process
.
id
process
)
;
for
(
let
pipe
of
process
.
pipes
)
{
this
.
pipes
.
set
(
pipe
.
id
pipe
)
;
}
}
cleanupProcess
(
process
)
{
this
.
processes
.
delete
(
process
.
id
)
;
}
}
;
