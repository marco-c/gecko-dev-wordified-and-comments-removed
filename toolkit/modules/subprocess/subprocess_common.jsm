"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
TextDecoder
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AsyncShutdown
"
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_shared
.
js
"
this
)
;
var
EXPORTED_SYMBOLS
=
[
"
BaseProcess
"
"
PromiseWorker
"
"
SubprocessConstants
"
]
;
const
BUFFER_SIZE
=
32768
;
let
nextResponseId
=
0
;
class
PromiseWorker
extends
ChromeWorker
{
constructor
(
url
)
{
super
(
url
)
;
this
.
listeners
=
new
Map
(
)
;
this
.
pendingResponses
=
new
Map
(
)
;
this
.
addListener
(
"
close
"
this
.
onClose
.
bind
(
this
)
)
;
this
.
addListener
(
"
failure
"
this
.
onFailure
.
bind
(
this
)
)
;
this
.
addListener
(
"
success
"
this
.
onSuccess
.
bind
(
this
)
)
;
this
.
addListener
(
"
debug
"
this
.
onDebug
.
bind
(
this
)
)
;
this
.
addEventListener
(
"
message
"
this
.
onmessage
)
;
this
.
shutdown
=
this
.
shutdown
.
bind
(
this
)
;
AsyncShutdown
.
webWorkersShutdown
.
addBlocker
(
"
Subprocess
.
jsm
:
Shut
down
IO
worker
"
this
.
shutdown
)
;
}
onClose
(
)
{
AsyncShutdown
.
webWorkersShutdown
.
removeBlocker
(
this
.
shutdown
)
;
}
shutdown
(
)
{
return
this
.
call
(
"
shutdown
"
[
]
)
;
}
addListener
(
msg
listener
)
{
if
(
!
this
.
listeners
.
has
(
msg
)
)
{
this
.
listeners
.
set
(
msg
new
Set
(
)
)
;
}
this
.
listeners
.
get
(
msg
)
.
add
(
listener
)
;
}
removeListener
(
msg
listener
)
{
let
listeners
=
this
.
listeners
.
get
(
msg
)
;
if
(
listeners
)
{
listeners
.
delete
(
listener
)
;
if
(
!
listeners
.
size
)
{
this
.
listeners
.
delete
(
msg
)
;
}
}
}
onmessage
(
event
)
{
let
{
msg
}
=
event
.
data
;
let
listeners
=
this
.
listeners
.
get
(
msg
)
|
|
new
Set
(
)
;
for
(
let
listener
of
listeners
)
{
try
{
listener
(
event
.
data
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
onFailure
(
{
msgId
error
}
)
{
this
.
pendingResponses
.
get
(
msgId
)
.
reject
(
error
)
;
this
.
pendingResponses
.
delete
(
msgId
)
;
}
onSuccess
(
{
msgId
data
}
)
{
this
.
pendingResponses
.
get
(
msgId
)
.
resolve
(
data
)
;
this
.
pendingResponses
.
delete
(
msgId
)
;
}
onDebug
(
{
message
}
)
{
dump
(
Worker
debug
:
{
message
}
\
n
)
;
}
call
(
method
args
transferList
=
[
]
)
{
let
msgId
=
nextResponseId
+
+
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
pendingResponses
.
set
(
msgId
{
resolve
reject
}
)
;
let
message
=
{
msg
:
method
msgId
args
}
;
this
.
postMessage
(
message
transferList
)
;
}
)
;
}
}
class
Pipe
{
constructor
(
process
fd
id
)
{
this
.
id
=
id
;
this
.
fd
=
fd
;
this
.
processId
=
process
.
id
;
this
.
worker
=
process
.
worker
;
this
.
closed
=
false
;
}
close
(
force
=
false
)
{
this
.
closed
=
true
;
return
this
.
worker
.
call
(
"
close
"
[
this
.
id
force
]
)
;
}
}
class
OutputPipe
extends
Pipe
{
constructor
(
.
.
.
args
)
{
super
(
.
.
.
args
)
;
this
.
encoder
=
new
TextEncoder
(
)
;
}
write
(
buffer
)
{
if
(
typeof
buffer
=
=
=
"
string
"
)
{
buffer
=
this
.
encoder
.
encode
(
buffer
)
;
}
if
(
Cu
.
getClassName
(
buffer
true
)
!
=
=
"
ArrayBuffer
"
)
{
if
(
buffer
.
byteLength
=
=
=
buffer
.
buffer
.
byteLength
)
{
buffer
=
buffer
.
buffer
;
}
else
{
buffer
=
buffer
.
buffer
.
slice
(
buffer
.
byteOffset
buffer
.
byteOffset
+
buffer
.
byteLength
)
;
}
}
let
args
=
[
this
.
id
buffer
]
;
return
this
.
worker
.
call
(
"
write
"
args
[
buffer
]
)
;
}
}
class
InputPipe
extends
Pipe
{
constructor
(
.
.
.
args
)
{
super
(
.
.
.
args
)
;
this
.
buffers
=
[
]
;
this
.
dataAvailable
=
0
;
this
.
decoder
=
new
TextDecoder
(
)
;
this
.
pendingReads
=
[
]
;
this
.
_pendingBufferRead
=
null
;
this
.
fillBuffer
(
)
;
}
get
bufferSize
(
)
{
if
(
this
.
pendingReads
.
length
)
{
return
Math
.
max
(
this
.
pendingReads
[
0
]
.
length
BUFFER_SIZE
)
;
}
return
BUFFER_SIZE
;
}
fillBuffer
(
)
{
let
dataWanted
=
this
.
bufferSize
-
this
.
dataAvailable
;
if
(
!
this
.
_pendingBufferRead
&
&
dataWanted
>
0
)
{
this
.
_pendingBufferRead
=
this
.
_read
(
dataWanted
)
;
this
.
_pendingBufferRead
.
then
(
(
result
)
=
>
{
this
.
_pendingBufferRead
=
null
;
if
(
result
)
{
this
.
onInput
(
result
.
buffer
)
;
this
.
fillBuffer
(
)
;
}
}
)
;
}
}
_read
(
size
)
{
let
args
=
[
this
.
id
size
]
;
return
this
.
worker
.
call
(
"
read
"
args
)
.
catch
(
e
=
>
{
this
.
closed
=
true
;
for
(
let
{
length
resolve
reject
}
of
this
.
pendingReads
.
splice
(
0
)
)
{
if
(
length
=
=
=
null
&
&
e
.
errorCode
=
=
=
SubprocessConstants
.
ERROR_END_OF_FILE
)
{
resolve
(
new
ArrayBuffer
(
0
)
)
;
}
else
{
reject
(
e
)
;
}
}
}
)
;
}
onInput
(
buffer
)
{
this
.
buffers
.
push
(
buffer
)
;
this
.
dataAvailable
+
=
buffer
.
byteLength
;
this
.
checkPendingReads
(
)
;
}
checkPendingReads
(
)
{
this
.
fillBuffer
(
)
;
let
reads
=
this
.
pendingReads
;
while
(
reads
.
length
&
&
this
.
dataAvailable
&
&
reads
[
0
]
.
length
<
=
this
.
dataAvailable
)
{
let
pending
=
this
.
pendingReads
.
shift
(
)
;
let
length
=
pending
.
length
|
|
this
.
dataAvailable
;
let
result
;
let
byteLength
=
this
.
buffers
[
0
]
.
byteLength
;
if
(
byteLength
=
=
length
)
{
result
=
this
.
buffers
.
shift
(
)
;
}
else
if
(
byteLength
>
length
)
{
let
buffer
=
this
.
buffers
[
0
]
;
this
.
buffers
[
0
]
=
buffer
.
slice
(
length
)
;
result
=
ArrayBuffer
.
transfer
(
buffer
length
)
;
}
else
{
result
=
ArrayBuffer
.
transfer
(
this
.
buffers
.
shift
(
)
length
)
;
let
u8result
=
new
Uint8Array
(
result
)
;
while
(
byteLength
<
length
)
{
let
buffer
=
this
.
buffers
[
0
]
;
let
u8buffer
=
new
Uint8Array
(
buffer
)
;
let
remaining
=
length
-
byteLength
;
if
(
buffer
.
byteLength
<
=
remaining
)
{
this
.
buffers
.
shift
(
)
;
u8result
.
set
(
u8buffer
byteLength
)
;
}
else
{
this
.
buffers
[
0
]
=
buffer
.
slice
(
remaining
)
;
u8result
.
set
(
u8buffer
.
subarray
(
0
remaining
)
byteLength
)
;
}
byteLength
+
=
Math
.
min
(
buffer
.
byteLength
remaining
)
;
}
}
this
.
dataAvailable
-
=
result
.
byteLength
;
pending
.
resolve
(
result
)
;
}
}
read
(
length
=
null
)
{
if
(
length
!
=
=
null
&
&
!
(
Number
.
isInteger
(
length
)
&
&
length
>
=
0
)
)
{
throw
new
RangeError
(
"
Length
must
be
a
non
-
negative
integer
"
)
;
}
if
(
length
=
=
0
)
{
return
Promise
.
resolve
(
new
ArrayBuffer
(
0
)
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
pendingReads
.
push
(
{
length
resolve
reject
}
)
;
this
.
checkPendingReads
(
)
;
}
)
;
}
readJSON
(
length
)
{
if
(
!
Number
.
isInteger
(
length
)
|
|
length
<
=
0
)
{
throw
new
RangeError
(
"
Length
must
be
a
positive
integer
"
)
;
}
return
this
.
readString
(
length
)
.
then
(
string
=
>
{
try
{
return
JSON
.
parse
(
string
)
;
}
catch
(
e
)
{
e
.
errorCode
=
SubprocessConstants
.
ERROR_INVALID_JSON
;
throw
e
;
}
}
)
;
}
readString
(
length
=
null
options
=
{
stream
:
length
=
=
=
null
}
)
{
if
(
length
!
=
=
null
&
&
!
(
Number
.
isInteger
(
length
)
&
&
length
>
=
0
)
)
{
throw
new
RangeError
(
"
Length
must
be
a
non
-
negative
integer
"
)
;
}
return
this
.
read
(
length
)
.
then
(
buffer
=
>
{
return
this
.
decoder
.
decode
(
buffer
options
)
;
}
)
;
}
readUint32
(
)
{
return
this
.
read
(
4
)
.
then
(
buffer
=
>
{
return
new
Uint32Array
(
buffer
)
[
0
]
;
}
)
;
}
}
class
BaseProcess
{
constructor
(
worker
processId
fds
pid
)
{
this
.
id
=
processId
;
this
.
worker
=
worker
;
this
.
pid
=
pid
;
this
.
exitCode
=
null
;
this
.
exitPromise
=
new
Promise
(
resolve
=
>
{
this
.
worker
.
call
(
"
wait
"
[
this
.
id
]
)
.
then
(
(
{
exitCode
}
)
=
>
{
resolve
(
Object
.
freeze
(
{
exitCode
}
)
)
;
this
.
exitCode
=
exitCode
;
}
)
;
}
)
;
if
(
fds
[
0
]
!
=
=
undefined
)
{
this
.
stdin
=
new
OutputPipe
(
this
0
fds
[
0
]
)
;
}
if
(
fds
[
1
]
!
=
=
undefined
)
{
this
.
stdout
=
new
InputPipe
(
this
1
fds
[
1
]
)
;
}
if
(
fds
[
2
]
!
=
=
undefined
)
{
this
.
stderr
=
new
InputPipe
(
this
2
fds
[
2
]
)
;
}
}
static
create
(
options
)
{
let
worker
=
this
.
getWorker
(
)
;
return
worker
.
call
(
"
spawn
"
[
options
]
)
.
then
(
(
{
processId
fds
pid
}
)
=
>
{
return
new
this
(
worker
processId
fds
pid
)
;
}
)
;
}
static
get
WORKER_URL
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
static
get
WorkerClass
(
)
{
return
PromiseWorker
;
}
static
getWorker
(
)
{
if
(
!
this
.
_worker
)
{
this
.
_worker
=
new
this
.
WorkerClass
(
this
.
WORKER_URL
)
;
}
return
this
.
_worker
;
}
kill
(
timeout
=
300
)
{
if
(
this
.
exitCode
!
=
null
)
{
return
this
.
wait
(
)
;
}
let
force
=
timeout
<
=
0
;
this
.
worker
.
call
(
"
kill
"
[
this
.
id
force
]
)
;
if
(
!
force
)
{
setTimeout
(
(
)
=
>
{
if
(
this
.
exitCode
=
=
null
)
{
this
.
worker
.
call
(
"
kill
"
[
this
.
id
true
]
)
;
}
}
timeout
)
;
}
return
this
.
wait
(
)
;
}
wait
(
)
{
return
this
.
exitPromise
;
}
}
