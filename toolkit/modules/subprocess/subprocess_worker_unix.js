"
use
strict
"
;
importScripts
(
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_shared
.
js
"
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_shared_unix
.
js
"
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_worker_common
.
js
"
)
;
const
POLL_TIMEOUT
=
5000
;
let
io
;
let
nextPipeId
=
0
;
class
Pipe
extends
BasePipe
{
constructor
(
process
fd
)
{
super
(
)
;
this
.
process
=
process
;
this
.
fd
=
fd
;
this
.
id
=
nextPipeId
+
+
;
}
get
pollEvents
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
close
(
force
=
false
)
{
if
(
!
force
&
&
this
.
pending
.
length
)
{
this
.
closing
=
true
;
return
this
.
closedPromise
;
}
for
(
let
{
reject
}
of
this
.
pending
)
{
let
error
=
new
Error
(
"
File
closed
"
)
;
error
.
errorCode
=
SubprocessConstants
.
ERROR_END_OF_FILE
;
reject
(
error
)
;
}
this
.
pending
.
length
=
0
;
if
(
!
this
.
closed
)
{
this
.
fd
.
dispose
(
)
;
this
.
closed
=
true
;
this
.
resolveClosed
(
)
;
io
.
pipes
.
delete
(
this
.
id
)
;
io
.
updatePollFds
(
)
;
}
return
this
.
closedPromise
;
}
onError
(
)
{
this
.
close
(
true
)
;
this
.
process
.
wait
(
)
;
}
}
class
InputPipe
extends
Pipe
{
get
pollEvents
(
)
{
if
(
this
.
pending
.
length
)
{
return
LIBC
.
POLLIN
;
}
return
0
;
}
read
(
length
)
{
if
(
this
.
closing
|
|
this
.
closed
)
{
throw
new
Error
(
"
Attempt
to
read
from
closed
pipe
"
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
pending
.
push
(
{
resolve
reject
length
}
)
;
io
.
updatePollFds
(
)
;
}
)
;
}
readBuffer
(
count
)
{
let
buffer
=
new
ArrayBuffer
(
count
)
;
let
read
=
+
libc
.
read
(
this
.
fd
buffer
buffer
.
byteLength
)
;
if
(
read
<
0
&
&
ctypes
.
errno
!
=
LIBC
.
EAGAIN
)
{
this
.
onError
(
)
;
}
if
(
read
<
=
0
)
{
return
null
;
}
if
(
read
<
buffer
.
byteLength
)
{
return
ArrayBuffer_transfer
(
buffer
read
)
;
}
return
buffer
;
}
onReady
(
)
{
let
result
=
false
;
let
reads
=
this
.
pending
;
while
(
reads
.
length
)
{
let
{
resolve
length
}
=
reads
[
0
]
;
let
buffer
=
this
.
readBuffer
(
length
)
;
if
(
buffer
)
{
result
=
true
;
this
.
shiftPending
(
)
;
resolve
(
buffer
)
;
}
else
{
break
;
}
}
if
(
!
reads
.
length
)
{
io
.
updatePollFds
(
)
;
}
return
result
;
}
}
class
OutputPipe
extends
Pipe
{
get
pollEvents
(
)
{
if
(
this
.
pending
.
length
)
{
return
LIBC
.
POLLOUT
;
}
return
0
;
}
write
(
buffer
)
{
if
(
this
.
closing
|
|
this
.
closed
)
{
throw
new
Error
(
"
Attempt
to
write
to
closed
pipe
"
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
pending
.
push
(
{
resolve
reject
buffer
length
:
buffer
.
byteLength
}
)
;
io
.
updatePollFds
(
)
;
}
)
;
}
writeBuffer
(
buffer
)
{
let
bytesWritten
=
libc
.
write
(
this
.
fd
buffer
buffer
.
byteLength
)
;
if
(
bytesWritten
<
0
&
&
ctypes
.
errno
!
=
LIBC
.
EAGAIN
)
{
this
.
onError
(
)
;
}
return
bytesWritten
;
}
onReady
(
)
{
let
writes
=
this
.
pending
;
while
(
writes
.
length
)
{
let
{
buffer
resolve
length
}
=
writes
[
0
]
;
let
written
=
this
.
writeBuffer
(
buffer
)
;
if
(
written
=
=
buffer
.
byteLength
)
{
resolve
(
length
)
;
this
.
shiftPending
(
)
;
}
else
if
(
written
>
0
)
{
writes
[
0
]
.
buffer
=
buffer
.
slice
(
written
)
;
}
else
{
break
;
}
}
if
(
!
writes
.
length
)
{
io
.
updatePollFds
(
)
;
}
}
}
class
Signal
{
constructor
(
fd
)
{
this
.
fd
=
fd
;
}
cleanup
(
)
{
libc
.
close
(
this
.
fd
)
;
this
.
fd
=
null
;
}
get
pollEvents
(
)
{
return
LIBC
.
POLLIN
;
}
onError
(
)
{
io
.
shutdown
(
)
;
}
onReady
(
)
{
let
buffer
=
new
ArrayBuffer
(
16
)
;
let
count
=
+
libc
.
read
(
this
.
fd
buffer
buffer
.
byteLength
)
;
if
(
count
>
0
)
{
io
.
messageCount
+
=
count
;
}
}
}
class
Process
extends
BaseProcess
{
get
pollEvents
(
)
{
if
(
this
.
exitCode
=
=
=
null
)
{
return
LIBC
.
POLLIN
;
}
return
0
;
}
kill
(
signal
)
{
libc
.
kill
(
this
.
pid
signal
)
;
this
.
wait
(
)
;
}
initPipes
(
options
)
{
let
stderr
=
options
.
stderr
;
let
our_pipes
=
[
]
;
let
their_pipes
=
new
Map
(
)
;
let
pipe
=
input
=
>
{
let
fds
=
ctypes
.
int
.
array
(
2
)
(
)
;
let
res
=
libc
.
pipe
(
fds
)
;
if
(
res
=
=
-
1
)
{
throw
new
Error
(
"
Unable
to
create
pipe
"
)
;
}
fds
=
Array
.
from
(
fds
unix
.
Fd
)
;
if
(
input
)
{
fds
.
reverse
(
)
;
}
if
(
input
)
{
our_pipes
.
push
(
new
InputPipe
(
this
fds
[
1
]
)
)
;
}
else
{
our_pipes
.
push
(
new
OutputPipe
(
this
fds
[
1
]
)
)
;
}
libc
.
fcntl
(
fds
[
0
]
LIBC
.
F_SETFD
LIBC
.
FD_CLOEXEC
)
;
libc
.
fcntl
(
fds
[
1
]
LIBC
.
F_SETFD
LIBC
.
FD_CLOEXEC
)
;
libc
.
fcntl
(
fds
[
1
]
LIBC
.
F_SETFL
LIBC
.
O_NONBLOCK
)
;
return
fds
[
0
]
;
}
;
their_pipes
.
set
(
0
pipe
(
false
)
)
;
their_pipes
.
set
(
1
pipe
(
true
)
)
;
if
(
stderr
=
=
"
pipe
"
)
{
their_pipes
.
set
(
2
pipe
(
true
)
)
;
}
else
if
(
stderr
=
=
"
stdout
"
)
{
their_pipes
.
set
(
2
their_pipes
.
get
(
1
)
)
;
}
their_pipes
.
set
(
3
pipe
(
true
)
)
;
this
.
fd
=
our_pipes
.
pop
(
)
.
fd
;
this
.
pipes
=
our_pipes
;
return
their_pipes
;
}
spawn
(
options
)
{
let
{
command
arguments
:
args
}
=
options
;
let
argv
=
this
.
stringArray
(
args
)
;
let
envp
=
this
.
stringArray
(
options
.
environment
)
;
let
actions
=
unix
.
posix_spawn_file_actions_t
(
)
;
let
actionsp
=
actions
.
address
(
)
;
let
attr
=
null
;
let
fds
=
this
.
initPipes
(
options
)
;
let
cwd
;
try
{
if
(
options
.
workdir
)
{
cwd
=
ctypes
.
char
.
array
(
LIBC
.
PATH_MAX
)
(
)
;
libc
.
getcwd
(
cwd
cwd
.
length
)
;
if
(
libc
.
chdir
(
options
.
workdir
)
<
0
)
{
if
(
OS
.
Constants
.
Sys
.
Name
!
=
=
"
OpenBSD
"
)
{
throw
new
Error
(
Unable
to
change
working
directory
to
{
options
.
workdir
}
)
;
}
}
}
libc
.
posix_spawn_file_actions_init
(
actionsp
)
;
for
(
let
[
i
fd
]
of
fds
.
entries
(
)
)
{
libc
.
posix_spawn_file_actions_adddup2
(
actionsp
fd
i
)
;
}
if
(
options
.
disclaim
)
{
attr
=
unix
.
posix_spawnattr_t
(
)
;
libc
.
posix_spawnattr_init
(
attr
.
address
(
)
)
;
let
rv
=
libc
.
responsibility_spawnattrs_setdisclaim
(
attr
.
address
(
)
1
)
;
if
(
rv
!
=
0
)
{
throw
new
Error
(
Failed
to
execute
command
"
{
command
}
"
+
due
to
disclaim
error
(
{
rv
}
)
.
)
;
}
}
let
pid
=
unix
.
pid_t
(
)
;
let
rv
=
libc
.
posix_spawn
(
pid
.
address
(
)
command
actionsp
attr
!
=
=
null
?
attr
.
address
(
)
:
null
argv
envp
)
;
if
(
rv
!
=
0
)
{
for
(
let
pipe
of
this
.
pipes
)
{
pipe
.
close
(
)
;
}
throw
new
Error
(
Failed
to
execute
command
"
{
command
}
"
)
;
}
this
.
pid
=
pid
.
value
;
}
finally
{
if
(
attr
!
=
=
null
)
{
libc
.
posix_spawnattr_destroy
(
attr
.
address
(
)
)
;
}
libc
.
posix_spawn_file_actions_destroy
(
actionsp
)
;
this
.
stringArrays
.
length
=
0
;
if
(
cwd
)
{
libc
.
chdir
(
cwd
)
;
}
for
(
let
fd
of
new
Set
(
fds
.
values
(
)
)
)
{
fd
.
dispose
(
)
;
}
}
}
onReady
(
)
{
if
(
this
.
wait
(
)
=
=
undefined
)
{
this
.
kill
(
9
)
;
}
}
onError
(
)
{
this
.
wait
(
)
;
}
wait
(
)
{
if
(
this
.
exitCode
!
=
=
null
)
{
return
this
.
exitCode
;
}
let
status
=
ctypes
.
int
(
)
;
let
res
=
libc
.
waitpid
(
this
.
pid
status
.
address
(
)
LIBC
.
WNOHANG
)
;
if
(
res
=
=
0
|
|
(
res
=
=
-
1
&
&
ctypes
.
errno
=
=
LIBC
.
EINTR
)
)
{
return
null
;
}
let
sig
=
unix
.
WTERMSIG
(
status
.
value
)
;
if
(
sig
)
{
this
.
exitCode
=
-
sig
;
}
else
{
this
.
exitCode
=
unix
.
WEXITSTATUS
(
status
.
value
)
;
}
this
.
fd
.
dispose
(
)
;
io
.
updatePollFds
(
)
;
this
.
resolveExit
(
this
.
exitCode
)
;
return
this
.
exitCode
;
}
}
io
=
{
pollFds
:
null
pollHandlers
:
null
pipes
:
new
Map
(
)
processes
:
new
Map
(
)
messageCount
:
0
running
:
true
polling
:
false
init
(
details
)
{
this
.
signal
=
new
Signal
(
details
.
signalFd
)
;
this
.
updatePollFds
(
)
;
setTimeout
(
this
.
loop
.
bind
(
this
)
0
)
;
}
shutdown
(
)
{
if
(
this
.
running
)
{
this
.
running
=
false
;
this
.
signal
.
cleanup
(
)
;
this
.
signal
=
null
;
self
.
postMessage
(
{
msg
:
"
close
"
}
)
;
self
.
close
(
)
;
}
}
getPipe
(
pipeId
)
{
let
pipe
=
this
.
pipes
.
get
(
pipeId
)
;
if
(
!
pipe
)
{
let
error
=
new
Error
(
"
File
closed
"
)
;
error
.
errorCode
=
SubprocessConstants
.
ERROR_END_OF_FILE
;
throw
error
;
}
return
pipe
;
}
getProcess
(
processId
)
{
let
process
=
this
.
processes
.
get
(
processId
)
;
if
(
!
process
)
{
throw
new
Error
(
Invalid
process
ID
:
{
processId
}
)
;
}
return
process
;
}
updatePollFds
(
)
{
let
handlers
=
[
this
.
signal
.
.
.
this
.
pipes
.
values
(
)
.
.
.
this
.
processes
.
values
(
)
]
;
handlers
=
handlers
.
filter
(
handler
=
>
handler
.
pollEvents
)
;
if
(
handlers
.
length
=
=
1
)
{
this
.
polling
=
false
;
}
else
if
(
!
this
.
polling
&
&
this
.
running
)
{
setTimeout
(
this
.
loop
.
bind
(
this
)
0
)
;
this
.
polling
=
true
;
}
let
pollfds
=
unix
.
pollfd
.
array
(
handlers
.
length
)
(
)
;
for
(
let
[
i
handler
]
of
handlers
.
entries
(
)
)
{
let
pollfd
=
pollfds
[
i
]
;
pollfd
.
fd
=
handler
.
fd
;
pollfd
.
events
=
handler
.
pollEvents
;
pollfd
.
revents
=
0
;
}
this
.
pollFds
=
pollfds
;
this
.
pollHandlers
=
handlers
;
}
loop
(
)
{
this
.
poll
(
)
;
if
(
this
.
running
&
&
this
.
polling
)
{
setTimeout
(
this
.
loop
.
bind
(
this
)
0
)
;
}
}
poll
(
)
{
let
handlers
=
this
.
pollHandlers
;
let
pollfds
=
this
.
pollFds
;
let
timeout
=
this
.
messageCount
>
0
?
0
:
POLL_TIMEOUT
;
let
count
=
libc
.
poll
(
pollfds
pollfds
.
length
timeout
)
;
for
(
let
i
=
0
;
count
&
&
i
<
pollfds
.
length
;
i
+
+
)
{
let
pollfd
=
pollfds
[
i
]
;
if
(
pollfd
.
revents
)
{
count
-
-
;
let
handler
=
handlers
[
i
]
;
try
{
let
success
=
false
;
if
(
pollfd
.
revents
&
handler
.
pollEvents
)
{
success
=
handler
.
onReady
(
)
;
}
if
(
!
success
&
&
pollfd
.
revents
&
(
LIBC
.
POLLERR
|
LIBC
.
POLLHUP
|
LIBC
.
POLLNVAL
)
)
{
handler
.
onError
(
)
;
}
}
catch
(
e
)
{
console
.
error
(
e
)
;
debug
(
Worker
error
:
{
e
}
:
:
{
e
.
stack
}
)
;
handler
.
onError
(
)
;
}
pollfd
.
revents
=
0
;
}
}
}
addProcess
(
process
)
{
this
.
processes
.
set
(
process
.
id
process
)
;
for
(
let
pipe
of
process
.
pipes
)
{
this
.
pipes
.
set
(
pipe
.
id
pipe
)
;
}
}
cleanupProcess
(
process
)
{
this
.
processes
.
delete
(
process
.
id
)
;
}
}
;
