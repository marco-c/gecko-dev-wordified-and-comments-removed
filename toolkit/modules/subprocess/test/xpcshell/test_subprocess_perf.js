"
use
strict
"
;
let
max_round_trip_time_ms
=
90
;
const
MAX_ROUND_TRIP_TIME_MS
=
max_round_trip_time_ms
;
const
MAX_RETRIES
=
5
;
let
PYTHON
;
const
TEST_SCRIPT
=
do_get_file
(
"
data_test_script
.
py
"
)
.
path
;
let
read
=
pipe
=
>
{
return
pipe
.
readUint32
(
)
.
then
(
count
=
>
{
return
pipe
.
readString
(
count
)
;
}
)
;
}
;
add_setup
(
async
function
setup
(
)
{
PYTHON
=
await
Subprocess
.
pathSearch
(
Services
.
env
.
get
(
"
PYTHON
"
)
)
;
}
)
;
add_task
(
async
function
test_subprocess_round_trip_perf
(
)
{
let
roundTripTime
=
Infinity
;
for
(
let
i
=
0
;
i
<
MAX_RETRIES
&
&
roundTripTime
>
MAX_ROUND_TRIP_TIME_MS
;
i
+
+
)
{
let
proc
=
await
Subprocess
.
call
(
{
command
:
PYTHON
arguments
:
[
"
-
u
"
TEST_SCRIPT
"
echo
"
]
}
)
;
const
LINE
=
"
I
'
m
a
leaf
on
the
wind
.
\
n
"
;
let
now
=
Date
.
now
(
)
;
const
COUNT
=
1000
;
for
(
let
j
=
0
;
j
<
COUNT
;
j
+
+
)
{
let
[
output
]
=
await
Promise
.
all
(
[
read
(
proc
.
stdout
)
proc
.
stdin
.
write
(
LINE
)
]
)
;
if
(
output
!
=
=
LINE
)
{
equal
(
output
LINE
"
Got
expected
output
"
)
;
}
}
roundTripTime
=
(
Date
.
now
(
)
-
now
)
/
COUNT
;
await
proc
.
stdin
.
close
(
)
;
let
{
exitCode
}
=
await
proc
.
wait
(
)
;
equal
(
exitCode
0
"
Got
expected
exit
code
"
)
;
}
Assert
.
lessOrEqual
(
roundTripTime
MAX_ROUND_TRIP_TIME_MS
Expected
round
trip
time
(
{
roundTripTime
}
ms
)
to
be
less
than
{
MAX_ROUND_TRIP_TIME_MS
}
ms
)
;
}
)
;
