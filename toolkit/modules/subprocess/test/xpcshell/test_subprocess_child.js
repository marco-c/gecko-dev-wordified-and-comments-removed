"
use
strict
"
;
const
{
TestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
)
;
const
{
setTimeout
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
)
;
let
PYTHON
;
add_setup
(
async
(
)
=
>
{
PYTHON
=
await
Subprocess
.
pathSearch
(
Services
.
env
.
get
(
"
PYTHON
"
)
)
;
}
)
;
async
function
fetchResponseText
(
url
method
)
{
const
timeoutCtrl
=
new
AbortController
(
)
;
const
timeout
=
method
=
=
=
"
DELETE
"
?
10000
:
1000
;
setTimeout
(
(
)
=
>
timeoutCtrl
.
abort
(
)
timeout
)
;
try
{
let
res
=
await
fetch
(
url
{
method
signal
:
timeoutCtrl
.
signal
}
)
;
return
await
res
.
text
(
)
;
}
catch
(
e
)
{
info
(
fetch
(
)
request
to
kill
parent
failed
:
{
e
}
)
;
if
(
e
.
name
!
=
=
"
AbortError
"
&
&
e
.
message
!
=
=
"
NetworkError
when
attempting
to
fetch
resource
.
"
)
{
ok
(
false
Unexpected
error
:
{
e
}
)
;
}
return
"
"
;
}
}
async
function
do_test_spawn_parent_with_child
(
isBreakAwayJob
)
{
let
testCmd
;
if
(
isBreakAwayJob
)
{
Assert
.
equal
(
AppConstants
.
platform
"
win
"
"
Breakaway
is
Windows
-
only
"
)
;
testCmd
=
"
spawn_child_in_breakaway_job_and_exit
"
;
}
else
{
testCmd
=
"
spawn_child_and_exit
"
;
}
const
TEST_SCRIPT
=
do_get_file
(
"
data_test_child
.
py
"
)
.
path
;
info
(
Launching
proc
:
{
PYTHON
}
-
u
{
TEST_SCRIPT
}
{
testCmd
}
)
;
const
proc
=
await
Subprocess
.
call
(
{
command
:
PYTHON
arguments
:
[
"
-
u
"
TEST_SCRIPT
testCmd
]
}
)
;
const
exitPromise
=
proc
.
wait
(
)
;
let
exited
=
false
;
exitPromise
.
then
(
(
)
=
>
{
exited
=
true
;
}
)
;
info
(
Spawned
process
with
pid
{
proc
.
pid
}
waiting
for
child
)
;
let
stdoutText
=
"
"
;
let
stdoutDonePromise
=
(
async
(
)
=
>
{
let
seenParentExit
=
false
;
for
(
let
s
;
(
s
=
await
proc
.
stdout
.
readString
(
)
)
;
)
{
s
=
s
.
replaceAll
(
"
\
r
"
"
"
)
;
stdoutText
+
=
s
;
dump
(
Received
stdout
from
test
script
:
{
s
}
\
n
)
;
seenParentExit
|
|
=
stdoutText
.
includes
(
"
parent_exit
"
)
;
if
(
!
seenParentExit
)
{
Assert
.
ok
(
!
exited
"
Process
should
not
have
exited
yet
"
)
;
}
}
}
)
(
)
;
const
EXPECTED_STDOUT_UNTIL_LISTENING
=
\
1
.
parent_start
2
.
first_child_start_and_exit
3
.
parent_after_first_child_exit
4
.
spawned_child_start
5
.
Listening
at
;
const
EXPECTED_STDOUT_AT_PARENT_EXIT
=
\
6
.
child_received_http_request
7
.
data_from_child
:
kill_parent
8
.
parent_exit
;
const
EXPECTED_STDOUT_AT_CHILD_EXIT
=
\
9
.
spawned_child_exit
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
stdoutText
.
startsWith
(
EXPECTED_STDOUT_UNTIL_LISTENING
)
"
Waiting
for
(
parent
)
process
to
start
child
with
listening
HTTP
server
"
)
;
const
url
=
stdoutText
.
replace
(
EXPECTED_STDOUT_UNTIL_LISTENING
"
"
)
.
trim
(
)
;
ok
(
/
^
http
:
\
/
\
/
127
\
.
0
\
.
0
\
.
1
:
\
d
+
/
.
test
(
url
)
Found
server
URL
:
{
url
}
)
;
stdoutText
=
"
"
;
const
promiseResponseToExitParent
=
fetchResponseText
(
url
"
DELETE
"
)
;
info
(
"
Waiting
for
spawned
(
parent
)
process
to
exit
"
)
;
const
{
exitCode
}
=
await
exitPromise
;
equal
(
exitCode
0
"
Got
expected
exit
code
"
)
;
equal
(
stdoutText
EXPECTED_STDOUT_AT_PARENT_EXIT
"
stdout
before
exit
"
)
;
stdoutText
=
"
"
;
const
responseToExitParent
=
await
promiseResponseToExitParent
;
if
(
!
responseToExitParent
)
{
info
(
"
fetch
(
)
request
to
kill
parent
failed
"
)
;
}
info
(
"
Checking
whether
the
child
process
is
still
alive
.
.
.
"
)
;
const
responseToChildAlive
=
await
fetchResponseText
(
url
"
GET
"
)
;
const
wasChildAlive
=
!
!
responseToChildAlive
;
if
(
wasChildAlive
)
{
equal
(
responseToExitParent
"
child_process_still_alive_1
"
"
Still
alive
1
"
)
;
equal
(
responseToChildAlive
"
child_process_still_alive_2
"
"
Still
alive
2
"
)
;
}
else
{
info
(
"
fetch
(
)
request
to
check
child
liveness
failed
"
)
;
}
if
(
AppConstants
.
platform
=
=
=
"
win
"
&
&
!
isBreakAwayJob
)
{
ok
(
!
wasChildAlive
"
Child
process
exits
when
the
parent
exits
"
)
;
}
else
{
ok
(
wasChildAlive
"
Child
process
outlives
parent
"
)
;
}
await
stdoutDonePromise
;
if
(
wasChildAlive
&
&
AppConstants
.
platform
!
=
=
"
win
"
)
{
equal
(
stdoutText
EXPECTED_STDOUT_AT_CHILD_EXIT
"
Stdout
from
child
"
)
;
}
else
{
equal
(
stdoutText
"
"
"
No
more
stdout
after
parent
exited
(
with
child
)
"
)
;
}
}
add_task
(
async
function
test_spawn_child_outliving_parent_process
(
)
{
const
isBreakAwayJob
=
AppConstants
.
platform
=
=
"
win
"
;
await
do_test_spawn_parent_with_child
(
isBreakAwayJob
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
AppConstants
.
platform
!
=
"
win
"
}
async
function
test_child_terminated_on_process_termination
(
)
{
await
do_test_spawn_parent_with_child
(
false
)
;
}
)
;
add_task
(
async
function
test_cleanup
(
)
{
let
{
getSubprocessImplForTest
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Subprocess
.
sys
.
mjs
"
)
;
let
worker
=
getSubprocessImplForTest
(
)
.
Process
.
getWorker
(
)
;
let
openFiles
=
await
worker
.
call
(
"
getOpenFiles
"
[
]
)
;
let
processes
=
await
worker
.
call
(
"
getProcesses
"
[
]
)
;
equal
(
openFiles
.
size
0
"
No
remaining
open
files
"
)
;
equal
(
processes
.
size
0
"
No
remaining
processes
"
)
;
}
)
;
