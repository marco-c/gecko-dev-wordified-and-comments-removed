"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SubprocessImpl
"
"
libc
"
]
;
const
{
ctypes
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
const
{
BaseProcess
PromiseWorker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_common
.
jsm
"
)
;
var
obj
=
{
}
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_shared
.
js
"
obj
)
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_shared_unix
.
js
"
obj
)
;
const
{
SubprocessConstants
libc
LIBC
}
=
obj
;
class
UnixPromiseWorker
extends
PromiseWorker
{
constructor
(
.
.
.
args
)
{
super
(
.
.
.
args
)
;
let
fds
=
ctypes
.
int
.
array
(
2
)
(
)
;
let
res
=
libc
.
pipe
(
fds
)
;
if
(
res
=
=
-
1
)
{
throw
new
Error
(
"
Unable
to
create
pipe
"
)
;
}
this
.
signalFd
=
fds
[
1
]
;
libc
.
fcntl
(
fds
[
0
]
LIBC
.
F_SETFL
LIBC
.
O_NONBLOCK
)
;
libc
.
fcntl
(
fds
[
0
]
LIBC
.
F_SETFD
LIBC
.
FD_CLOEXEC
)
;
libc
.
fcntl
(
fds
[
1
]
LIBC
.
F_SETFD
LIBC
.
FD_CLOEXEC
)
;
this
.
call
(
"
init
"
[
{
signalFd
:
fds
[
0
]
}
]
)
;
}
closePipe
(
)
{
if
(
this
.
signalFd
)
{
libc
.
close
(
this
.
signalFd
)
;
this
.
signalFd
=
null
;
}
}
onClose
(
)
{
this
.
closePipe
(
)
;
super
.
onClose
(
)
;
}
signalWorker
(
)
{
libc
.
write
(
this
.
signalFd
new
ArrayBuffer
(
1
)
1
)
;
}
postMessage
(
.
.
.
args
)
{
this
.
signalWorker
(
)
;
return
super
.
postMessage
(
.
.
.
args
)
;
}
}
class
Process
extends
BaseProcess
{
static
get
WORKER_URL
(
)
{
return
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_worker_unix
.
js
"
;
}
static
get
WorkerClass
(
)
{
return
UnixPromiseWorker
;
}
}
function
ptrToUint8Array
(
input
)
{
let
{
cast
uint8_t
}
=
ctypes
;
let
len
=
0
;
for
(
let
ptr
=
cast
(
input
uint8_t
.
ptr
)
;
ptr
.
contents
;
ptr
=
ptr
.
increment
(
)
)
{
len
+
+
;
}
let
aryPtr
=
cast
(
input
uint8_t
.
array
(
len
)
.
ptr
)
;
return
new
Uint8Array
(
aryPtr
.
contents
)
;
}
var
SubprocessUnix
=
{
Process
call
(
options
)
{
return
Process
.
create
(
options
)
;
}
*
getEnvironment
(
)
{
let
environ
;
if
(
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
)
{
environ
=
libc
.
_NSGetEnviron
(
)
.
contents
;
}
else
{
environ
=
libc
.
environ
;
}
const
EQUAL
=
"
=
"
.
charCodeAt
(
0
)
;
let
decoder
=
new
TextDecoder
(
"
utf
-
8
"
{
fatal
:
true
}
)
;
function
decode
(
array
)
{
try
{
return
decoder
.
decode
(
array
)
;
}
catch
(
e
)
{
return
array
;
}
}
for
(
let
envp
=
environ
;
!
envp
.
isNull
(
)
&
&
!
envp
.
contents
.
isNull
(
)
;
envp
=
envp
.
increment
(
)
)
{
let
buf
=
ptrToUint8Array
(
envp
.
contents
)
;
for
(
let
i
=
0
;
i
<
buf
.
length
;
i
+
+
)
{
if
(
buf
[
i
]
=
=
EQUAL
)
{
yield
[
decode
(
buf
.
subarray
(
0
i
)
)
decode
(
buf
.
subarray
(
i
+
1
)
)
]
;
break
;
}
}
}
}
isExecutableFile
:
async
function
isExecutable
(
path
)
{
if
(
!
PathUtils
.
isAbsolute
(
path
)
)
{
return
false
;
}
try
{
let
info
=
await
IOUtils
.
stat
(
path
)
;
return
info
.
type
!
=
=
"
directory
"
&
&
info
.
permissions
&
0o111
;
}
catch
(
e
)
{
return
false
;
}
}
async
pathSearch
(
bin
environment
)
{
if
(
PathUtils
.
isAbsolute
(
bin
)
)
{
if
(
await
this
.
isExecutableFile
(
bin
)
)
{
return
bin
;
}
let
error
=
new
Error
(
File
at
path
"
{
bin
}
"
does
not
exist
or
is
not
executable
)
;
error
.
errorCode
=
SubprocessConstants
.
ERROR_BAD_EXECUTABLE
;
throw
error
;
}
let
dirs
=
[
]
;
if
(
typeof
environment
.
PATH
=
=
=
"
string
"
)
{
dirs
=
environment
.
PATH
.
split
(
"
:
"
)
;
}
for
(
let
dir
of
dirs
)
{
let
path
=
PathUtils
.
join
(
dir
bin
)
;
if
(
await
this
.
isExecutableFile
(
path
)
)
{
return
path
;
}
}
let
error
=
new
Error
(
Executable
not
found
:
{
bin
}
)
;
error
.
errorCode
=
SubprocessConstants
.
ERROR_BAD_EXECUTABLE
;
throw
error
;
}
}
;
var
SubprocessImpl
=
SubprocessUnix
;
