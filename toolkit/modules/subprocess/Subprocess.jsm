"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Subprocess
"
"
getSubprocessImplForTest
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
SubprocessConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_common
.
jsm
"
)
;
const
lazy
=
{
}
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
ChromeUtils
.
defineModuleGetter
(
lazy
"
SubprocessImpl
"
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_win
.
jsm
"
)
;
}
else
{
ChromeUtils
.
defineModuleGetter
(
lazy
"
SubprocessImpl
"
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_unix
.
jsm
"
)
;
}
function
encodeEnvVar
(
name
value
)
{
if
(
typeof
name
=
=
=
"
string
"
&
&
typeof
value
=
=
=
"
string
"
)
{
return
{
name
}
=
{
value
}
;
}
let
encoder
=
new
TextEncoder
(
"
utf
-
8
"
)
;
function
encode
(
val
)
{
return
typeof
val
=
=
=
"
string
"
?
encoder
.
encode
(
val
)
:
val
;
}
return
Uint8Array
.
of
(
.
.
.
encode
(
name
)
.
.
.
encode
(
"
=
"
)
.
.
.
encode
(
value
)
0
)
;
}
function
platformSupportsDisclaimedSpawn
(
)
{
return
AppConstants
.
isPlatformAndVersionAtLeast
(
"
macosx
"
18
)
;
}
var
Subprocess
=
{
call
(
options
)
{
options
=
Object
.
assign
(
{
}
options
)
;
options
.
stderr
=
options
.
stderr
|
|
"
ignore
"
;
options
.
workdir
=
options
.
workdir
|
|
null
;
options
.
disclaim
=
options
.
disclaim
|
|
false
;
let
environment
=
{
}
;
if
(
!
options
.
environment
|
|
options
.
environmentAppend
)
{
environment
=
this
.
getEnvironment
(
)
;
}
if
(
options
.
environment
)
{
Object
.
assign
(
environment
options
.
environment
)
;
}
options
.
environment
=
Object
.
entries
(
environment
)
.
map
(
(
[
key
val
]
)
=
>
(
val
!
=
=
null
?
encodeEnvVar
(
key
val
)
:
null
)
)
.
filter
(
s
=
>
s
)
;
options
.
arguments
=
Array
.
from
(
options
.
arguments
|
|
[
]
)
;
if
(
options
.
disclaim
&
&
!
platformSupportsDisclaimedSpawn
(
)
)
{
options
.
disclaim
=
false
;
}
return
Promise
.
resolve
(
lazy
.
SubprocessImpl
.
isExecutableFile
(
options
.
command
)
)
.
then
(
isExecutable
=
>
{
if
(
!
isExecutable
)
{
let
error
=
new
Error
(
File
at
path
"
{
options
.
command
}
"
does
not
exist
or
is
not
executable
)
;
error
.
errorCode
=
SubprocessConstants
.
ERROR_BAD_EXECUTABLE
;
throw
error
;
}
options
.
arguments
.
unshift
(
options
.
command
)
;
return
lazy
.
SubprocessImpl
.
call
(
options
)
;
}
)
;
}
getEnvironment
(
)
{
let
environment
=
Object
.
create
(
null
)
;
for
(
let
[
k
v
]
of
lazy
.
SubprocessImpl
.
getEnvironment
(
)
)
{
environment
[
k
]
=
v
;
}
return
environment
;
}
pathSearch
(
command
environment
=
this
.
getEnvironment
(
)
)
{
let
path
=
lazy
.
SubprocessImpl
.
pathSearch
(
command
environment
)
;
return
Promise
.
resolve
(
path
)
;
}
}
;
Object
.
assign
(
Subprocess
SubprocessConstants
)
;
Object
.
freeze
(
Subprocess
)
;
function
getSubprocessImplForTest
(
)
{
return
lazy
.
SubprocessImpl
;
}
