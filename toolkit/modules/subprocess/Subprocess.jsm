"
use
strict
"
;
let
EXPORTED_SYMBOLS
=
[
"
Subprocess
"
]
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_common
.
jsm
"
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
SubprocessImpl
"
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_win
.
jsm
"
)
;
}
else
{
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
SubprocessImpl
"
"
resource
:
/
/
gre
/
modules
/
subprocess
/
subprocess_unix
.
jsm
"
)
;
}
var
Subprocess
=
{
call
(
options
)
{
options
=
Object
.
assign
(
{
}
options
)
;
options
.
stderr
=
options
.
stderr
|
|
"
ignore
"
;
options
.
workdir
=
options
.
workdir
|
|
null
;
let
environment
=
{
}
;
if
(
!
options
.
environment
|
|
options
.
environmentAppend
)
{
environment
=
this
.
getEnvironment
(
)
;
}
if
(
options
.
environment
)
{
Object
.
assign
(
environment
options
.
environment
)
;
}
options
.
environment
=
Object
.
keys
(
environment
)
.
map
(
key
=
>
{
key
}
=
{
environment
[
key
]
}
)
;
options
.
arguments
=
Array
.
from
(
options
.
arguments
|
|
[
]
)
;
return
Promise
.
resolve
(
SubprocessImpl
.
isExecutableFile
(
options
.
command
)
)
.
then
(
isExecutable
=
>
{
if
(
!
isExecutable
)
{
let
error
=
new
Error
(
File
at
path
"
{
options
.
command
}
"
does
not
exist
or
is
not
executable
)
;
error
.
errorCode
=
SubprocessConstants
.
ERROR_BAD_EXECUTABLE
;
throw
error
;
}
options
.
arguments
.
unshift
(
options
.
command
)
;
return
SubprocessImpl
.
call
(
options
)
;
}
)
;
}
getEnvironment
(
)
{
let
environment
=
Object
.
create
(
null
)
;
for
(
let
[
k
v
]
of
SubprocessImpl
.
getEnvironment
(
)
)
{
environment
[
k
]
=
v
;
}
return
environment
;
}
pathSearch
(
command
environment
=
this
.
getEnvironment
(
)
)
{
let
path
=
SubprocessImpl
.
pathSearch
(
command
environment
)
;
return
Promise
.
resolve
(
path
)
;
}
}
;
Object
.
assign
(
Subprocess
SubprocessConstants
)
;
Object
.
freeze
(
Subprocess
)
;
