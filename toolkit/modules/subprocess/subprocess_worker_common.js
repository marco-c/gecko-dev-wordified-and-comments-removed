"
use
strict
"
;
function
debug
(
message
)
{
self
.
postMessage
(
{
msg
:
"
debug
"
message
}
)
;
}
class
BasePipe
{
constructor
(
)
{
this
.
closing
=
false
;
this
.
closed
=
false
;
this
.
closedPromise
=
new
Promise
(
resolve
=
>
{
this
.
resolveClosed
=
resolve
;
}
)
;
this
.
pending
=
[
]
;
}
shiftPending
(
)
{
let
result
=
this
.
pending
.
shift
(
)
;
if
(
this
.
closing
&
&
this
.
pending
.
length
=
=
0
)
{
this
.
close
(
)
;
}
return
result
;
}
}
let
nextProcessId
=
0
;
class
BaseProcess
{
constructor
(
options
)
{
this
.
id
=
nextProcessId
+
+
;
this
.
exitCode
=
null
;
this
.
exitPromise
=
new
Promise
(
resolve
=
>
{
this
.
resolveExit
=
resolve
;
}
)
;
this
.
exitPromise
.
then
(
(
)
=
>
{
this
.
pipes
[
0
]
.
close
(
true
)
;
}
)
;
this
.
pid
=
null
;
this
.
pipes
=
[
]
;
this
.
stringArrays
=
[
]
;
this
.
spawn
(
options
)
;
}
stringArray
(
strings
)
{
let
result
=
ctypes
.
char
.
ptr
.
array
(
strings
.
length
+
1
)
(
)
;
let
cstrings
=
strings
.
map
(
str
=
>
ctypes
.
char
.
array
(
)
(
str
)
)
;
for
(
let
[
i
cstring
]
of
cstrings
.
entries
(
)
)
{
result
[
i
]
=
cstring
;
}
this
.
stringArrays
.
push
(
cstrings
)
;
return
result
;
}
}
let
requests
=
{
close
(
pipeId
force
=
false
)
{
let
pipe
=
io
.
getPipe
(
pipeId
)
;
return
pipe
.
close
(
force
)
.
then
(
(
)
=
>
(
{
data
:
{
}
}
)
)
;
}
spawn
(
options
)
{
let
process
=
new
Process
(
options
)
;
let
processId
=
process
.
id
;
io
.
addProcess
(
process
)
;
let
fds
=
process
.
pipes
.
map
(
pipe
=
>
pipe
.
id
)
;
return
{
data
:
{
processId
fds
pid
:
process
.
pid
}
}
;
}
kill
(
processId
force
=
false
)
{
let
process
=
io
.
getProcess
(
processId
)
;
process
.
kill
(
force
?
9
:
15
)
;
return
{
data
:
{
}
}
;
}
wait
(
processId
)
{
let
process
=
io
.
getProcess
(
processId
)
;
process
.
wait
(
)
;
return
process
.
exitPromise
.
then
(
exitCode
=
>
{
io
.
cleanupProcess
(
process
)
;
return
{
data
:
{
exitCode
}
}
;
}
)
;
}
read
(
pipeId
count
)
{
let
pipe
=
io
.
getPipe
(
pipeId
)
;
return
pipe
.
read
(
count
)
.
then
(
buffer
=
>
{
return
{
data
:
{
buffer
}
}
;
}
)
;
}
write
(
pipeId
buffer
)
{
let
pipe
=
io
.
getPipe
(
pipeId
)
;
return
pipe
.
write
(
buffer
)
.
then
(
bytesWritten
=
>
{
return
{
data
:
{
bytesWritten
}
}
;
}
)
;
}
getOpenFiles
(
)
{
return
{
data
:
new
Set
(
io
.
pipes
.
keys
(
)
)
}
;
}
getProcesses
(
)
{
let
data
=
new
Map
(
Array
.
from
(
io
.
processes
.
values
(
)
proc
=
>
[
proc
.
id
proc
.
pid
]
)
)
;
return
{
data
}
;
}
waitForNoProcesses
(
)
{
return
Promise
.
all
(
Array
.
from
(
io
.
processes
.
values
(
)
proc
=
>
proc
.
exitPromise
)
)
;
}
}
;
onmessage
=
event
=
>
{
let
{
msg
msgId
args
}
=
event
.
data
;
new
Promise
(
resolve
=
>
{
resolve
(
requests
[
msg
]
(
.
.
.
args
)
)
;
}
)
.
then
(
result
=
>
{
let
response
=
{
msg
:
"
success
"
msgId
data
:
result
.
data
}
;
self
.
postMessage
(
response
result
.
transfer
|
|
[
]
)
;
}
)
.
catch
(
error
=
>
{
if
(
error
instanceof
Error
)
{
error
=
{
message
:
error
.
message
fileName
:
error
.
fileName
lineNumber
:
error
.
lineNumber
column
:
error
.
column
stack
:
error
.
stack
errorCode
:
error
.
errorCode
}
;
}
self
.
postMessage
(
{
msg
:
"
failure
"
msgId
error
}
)
;
}
)
.
catch
(
error
=
>
{
console
.
error
(
error
)
;
self
.
postMessage
(
{
msg
:
"
failure
"
msgId
error
:
{
}
}
)
;
}
)
;
}
;
