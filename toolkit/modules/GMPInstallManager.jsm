"
use
strict
"
;
const
DEFAULT_SECONDS_BETWEEN_CHECKS
=
60
*
60
*
24
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
var
{
GMPPrefs
GMPUtils
GMP_PLUGIN_IDS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GMPUtils
.
jsm
"
)
;
const
{
ProductAddonChecker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
addons
/
ProductAddonChecker
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
GMPInstallManager
"
"
GMPExtractor
"
"
GMPDownloader
"
"
GMPAddon
"
]
;
ChromeUtils
.
defineModuleGetter
(
this
"
CertUtils
"
"
resource
:
/
/
gre
/
modules
/
CertUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ServiceRequest
"
"
resource
:
/
/
gre
/
modules
/
ServiceRequest
.
jsm
"
)
;
function
getScopedLogger
(
prefix
)
{
return
Log
.
repository
.
getLoggerWithMessagePrefix
(
"
Toolkit
.
GMP
"
prefix
+
"
"
)
;
}
const
LOCAL_GMP_SOURCES
=
[
{
id
:
"
gmp
-
gmpopenh264
"
src
:
"
chrome
:
/
/
global
/
content
/
gmp
-
sources
/
openh264
.
json
"
}
{
id
:
"
gmp
-
widevinecdm
"
src
:
"
chrome
:
/
/
global
/
content
/
gmp
-
sources
/
widevinecdm
.
json
"
}
]
;
function
downloadJSON
(
uri
)
{
let
log
=
getScopedLogger
(
"
GMPInstallManager
.
checkForAddons
"
)
;
log
.
info
(
"
fetching
config
from
:
"
+
uri
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xmlHttp
=
new
ServiceRequest
(
{
mozAnon
:
true
}
)
;
xmlHttp
.
onload
=
function
(
aResponse
)
{
resolve
(
JSON
.
parse
(
this
.
responseText
)
)
;
}
;
xmlHttp
.
onerror
=
function
(
e
)
{
reject
(
"
Fetching
"
+
uri
+
"
results
in
error
code
:
"
+
e
.
target
.
status
)
;
}
;
xmlHttp
.
open
(
"
GET
"
uri
)
;
xmlHttp
.
overrideMimeType
(
"
application
/
json
"
)
;
xmlHttp
.
send
(
)
;
}
)
;
}
function
downloadLocalConfig
(
)
{
let
log
=
getScopedLogger
(
"
GMPInstallManager
.
checkForAddons
"
)
;
return
Promise
.
all
(
LOCAL_GMP_SOURCES
.
map
(
conf
=
>
{
return
downloadJSON
(
conf
.
src
)
.
then
(
addons
=
>
{
let
platforms
=
addons
.
vendors
[
conf
.
id
]
.
platforms
;
let
target
=
Services
.
appinfo
.
OS
+
"
_
"
+
UpdateUtils
.
ABI
;
let
details
=
null
;
while
(
!
details
)
{
if
(
!
(
target
in
platforms
)
)
{
log
.
info
(
"
no
details
found
for
:
"
+
target
)
;
return
false
;
}
if
(
platforms
[
target
]
.
alias
)
{
target
=
platforms
[
target
]
.
alias
;
}
else
{
details
=
platforms
[
target
]
;
}
}
log
.
info
(
"
found
plugin
:
"
+
conf
.
id
)
;
return
{
id
:
conf
.
id
URL
:
details
.
fileUrl
hashFunction
:
addons
.
hashFunction
hashValue
:
details
.
hashValue
version
:
addons
.
vendors
[
conf
.
id
]
.
version
size
:
details
.
filesize
}
;
}
)
;
}
)
)
.
then
(
addons
=
>
{
addons
=
addons
.
filter
(
x
=
>
x
!
=
=
false
)
;
return
{
usedFallback
:
true
addons
}
;
}
)
;
}
function
GMPInstallManager
(
)
{
}
GMPInstallManager
.
prototype
=
{
async
_getURL
(
)
{
let
log
=
getScopedLogger
(
"
GMPInstallManager
.
_getURL
"
)
;
let
url
=
GMPPrefs
.
getString
(
GMPPrefs
.
KEY_URL_OVERRIDE
"
"
)
;
if
(
url
)
{
log
.
info
(
"
Using
override
url
:
"
+
url
)
;
}
else
{
url
=
GMPPrefs
.
getString
(
GMPPrefs
.
KEY_URL
)
;
log
.
info
(
"
Using
url
:
"
+
url
)
;
}
url
=
await
UpdateUtils
.
formatUpdateURL
(
url
)
;
log
.
info
(
"
Using
url
(
with
replacement
)
:
"
+
url
)
;
return
url
;
}
async
checkForAddons
(
)
{
let
log
=
getScopedLogger
(
"
GMPInstallManager
.
checkForAddons
"
)
;
if
(
this
.
_deferred
)
{
log
.
error
(
"
checkForAddons
already
called
"
)
;
return
Promise
.
reject
(
{
type
:
"
alreadycalled
"
}
)
;
}
if
(
!
GMPPrefs
.
getBool
(
GMPPrefs
.
KEY_UPDATE_ENABLED
true
)
)
{
log
.
info
(
"
Updates
are
disabled
via
media
.
gmp
-
manager
.
updateEnabled
"
)
;
return
{
usedFallback
:
true
addons
:
[
]
}
;
}
this
.
_deferred
=
PromiseUtils
.
defer
(
)
;
let
allowNonBuiltIn
=
true
;
let
certs
=
null
;
if
(
!
Services
.
prefs
.
prefHasUserValue
(
GMPPrefs
.
KEY_URL_OVERRIDE
)
)
{
allowNonBuiltIn
=
!
GMPPrefs
.
getString
(
GMPPrefs
.
KEY_CERT_REQUIREBUILTIN
true
)
;
if
(
GMPPrefs
.
getBool
(
GMPPrefs
.
KEY_CERT_CHECKATTRS
true
)
)
{
certs
=
CertUtils
.
readCertPrefs
(
GMPPrefs
.
KEY_CERTS_BRANCH
)
;
}
}
let
url
=
await
this
.
_getURL
(
)
;
let
addonPromise
=
ProductAddonChecker
.
getProductAddonList
(
url
allowNonBuiltIn
certs
)
.
catch
(
downloadLocalConfig
)
;
addonPromise
.
then
(
res
=
>
{
if
(
!
res
|
|
!
res
.
addons
)
{
this
.
_deferred
.
resolve
(
{
addons
:
[
]
}
)
;
}
else
{
res
.
addons
=
res
.
addons
.
map
(
a
=
>
new
GMPAddon
(
a
)
)
;
this
.
_deferred
.
resolve
(
res
)
;
}
delete
this
.
_deferred
;
}
ex
=
>
{
this
.
_deferred
.
reject
(
ex
)
;
delete
this
.
_deferred
;
}
)
;
return
this
.
_deferred
.
promise
;
}
installAddon
(
gmpAddon
)
{
if
(
this
.
_deferred
)
{
let
log
=
getScopedLogger
(
"
GMPInstallManager
.
installAddon
"
)
;
log
.
error
(
"
previous
error
encountered
"
)
;
return
Promise
.
reject
(
{
type
:
"
previouserrorencountered
"
}
)
;
}
this
.
gmpDownloader
=
new
GMPDownloader
(
gmpAddon
)
;
return
this
.
gmpDownloader
.
start
(
)
;
}
_getTimeSinceLastCheck
(
)
{
let
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
let
lastCheck
=
GMPPrefs
.
getInt
(
GMPPrefs
.
KEY_UPDATE_LAST_CHECK
0
)
;
if
(
now
<
lastCheck
)
{
return
now
;
}
return
now
-
lastCheck
;
}
get
_isEMEEnabled
(
)
{
return
GMPPrefs
.
getBool
(
GMPPrefs
.
KEY_EME_ENABLED
true
)
;
}
_isAddonEnabled
(
aAddon
)
{
return
GMPPrefs
.
getBool
(
GMPPrefs
.
KEY_PLUGIN_ENABLED
true
aAddon
)
;
}
_isAddonUpdateEnabled
(
aAddon
)
{
return
(
this
.
_isAddonEnabled
(
aAddon
)
&
&
GMPPrefs
.
getBool
(
GMPPrefs
.
KEY_PLUGIN_AUTOUPDATE
true
aAddon
)
)
;
}
_updateLastCheck
(
)
{
let
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
GMPPrefs
.
setInt
(
GMPPrefs
.
KEY_UPDATE_LAST_CHECK
now
)
;
}
_versionchangeOccurred
(
)
{
let
savedBuildID
=
GMPPrefs
.
getString
(
GMPPrefs
.
KEY_BUILDID
"
"
)
;
let
buildID
=
Services
.
appinfo
.
platformBuildID
|
|
"
"
;
if
(
savedBuildID
=
=
buildID
)
{
return
false
;
}
GMPPrefs
.
setString
(
GMPPrefs
.
KEY_BUILDID
buildID
)
;
return
true
;
}
async
simpleCheckAndInstall
(
)
{
let
log
=
getScopedLogger
(
"
GMPInstallManager
.
simpleCheckAndInstall
"
)
;
if
(
this
.
_versionchangeOccurred
(
)
)
{
log
.
info
(
"
A
version
change
occurred
.
Ignoring
"
+
"
media
.
gmp
-
manager
.
lastCheck
to
check
immediately
for
"
+
"
new
or
updated
GMPs
.
"
)
;
}
else
{
let
secondsBetweenChecks
=
GMPPrefs
.
getInt
(
GMPPrefs
.
KEY_SECONDS_BETWEEN_CHECKS
DEFAULT_SECONDS_BETWEEN_CHECKS
)
;
let
secondsSinceLast
=
this
.
_getTimeSinceLastCheck
(
)
;
log
.
info
(
"
Last
check
was
:
"
+
secondsSinceLast
+
"
seconds
ago
minimum
seconds
:
"
+
secondsBetweenChecks
)
;
if
(
secondsBetweenChecks
>
secondsSinceLast
)
{
log
.
info
(
"
Will
not
check
for
updates
.
"
)
;
return
{
status
:
"
too
-
frequent
-
no
-
check
"
}
;
}
}
try
{
let
{
usedFallback
addons
}
=
await
this
.
checkForAddons
(
)
;
this
.
_updateLastCheck
(
)
;
log
.
info
(
"
Found
"
+
addons
.
length
+
"
addons
advertised
.
"
)
;
let
addonsToInstall
=
addons
.
filter
(
function
(
gmpAddon
)
{
log
.
info
(
"
Found
addon
:
"
+
gmpAddon
.
toString
(
)
)
;
if
(
!
gmpAddon
.
isValid
)
{
log
.
info
(
"
Addon
|
"
+
gmpAddon
.
id
+
"
|
is
invalid
.
"
)
;
return
false
;
}
if
(
GMPUtils
.
isPluginHidden
(
gmpAddon
)
)
{
log
.
info
(
"
Addon
|
"
+
gmpAddon
.
id
+
"
|
has
been
hidden
.
"
)
;
return
false
;
}
if
(
gmpAddon
.
isInstalled
)
{
log
.
info
(
"
Addon
|
"
+
gmpAddon
.
id
+
"
|
already
installed
.
"
)
;
return
false
;
}
if
(
usedFallback
&
&
gmpAddon
.
isUpdate
)
{
log
.
info
(
"
Addon
|
"
+
gmpAddon
.
id
+
"
|
not
installing
updates
based
"
+
"
on
fallback
.
"
)
;
return
false
;
}
let
addonUpdateEnabled
=
false
;
if
(
GMP_PLUGIN_IDS
.
includes
(
gmpAddon
.
id
)
)
{
if
(
!
this
.
_isAddonEnabled
(
gmpAddon
.
id
)
)
{
log
.
info
(
"
GMP
|
"
+
gmpAddon
.
id
+
"
|
has
been
disabled
;
skipping
check
.
"
)
;
}
else
if
(
!
this
.
_isAddonUpdateEnabled
(
gmpAddon
.
id
)
)
{
log
.
info
(
"
Auto
-
update
is
off
for
"
+
gmpAddon
.
id
+
"
skipping
check
.
"
)
;
}
else
{
addonUpdateEnabled
=
true
;
}
}
else
{
log
.
info
(
"
Auto
-
update
is
off
for
unknown
plugin
'
"
+
gmpAddon
.
id
+
"
'
skipping
check
.
"
)
;
}
return
addonUpdateEnabled
;
}
this
)
;
if
(
!
addonsToInstall
.
length
)
{
log
.
info
(
"
No
new
addons
to
install
returning
"
)
;
return
{
status
:
"
nothing
-
new
-
to
-
install
"
}
;
}
let
installResults
=
[
]
;
let
failureEncountered
=
false
;
for
(
let
addon
of
addonsToInstall
)
{
try
{
await
this
.
installAddon
(
addon
)
;
installResults
.
push
(
{
id
:
addon
.
id
result
:
"
succeeded
"
}
)
;
}
catch
(
e
)
{
failureEncountered
=
true
;
installResults
.
push
(
{
id
:
addon
.
id
result
:
"
failed
"
}
)
;
}
}
if
(
failureEncountered
)
{
throw
{
status
:
"
failed
"
results
:
installResults
}
;
}
return
{
status
:
"
succeeded
"
results
:
installResults
}
;
}
catch
(
e
)
{
log
.
error
(
"
Could
not
check
for
addons
"
e
)
;
throw
e
;
}
}
uninit
(
)
{
let
log
=
getScopedLogger
(
"
GMPInstallManager
.
uninit
"
)
;
if
(
this
.
_request
)
{
log
.
info
(
"
Aborting
request
"
)
;
this
.
_request
.
abort
(
)
;
}
if
(
this
.
_deferred
)
{
log
.
info
(
"
Rejecting
deferred
"
)
;
this
.
_deferred
.
reject
(
{
type
:
"
uninitialized
"
}
)
;
}
log
.
info
(
"
Done
cleanup
"
)
;
}
overrideLeaveDownloadedZip
:
false
}
;
function
GMPAddon
(
addon
)
{
let
log
=
getScopedLogger
(
"
GMPAddon
.
constructor
"
)
;
for
(
let
name
of
Object
.
keys
(
addon
)
)
{
this
[
name
]
=
addon
[
name
]
;
}
log
.
info
(
"
Created
new
addon
:
"
+
this
.
toString
(
)
)
;
}
GMPAddon
.
prototype
=
{
toString
(
)
{
return
(
this
.
id
+
"
(
"
+
"
isValid
:
"
+
this
.
isValid
+
"
isInstalled
:
"
+
this
.
isInstalled
+
"
hashFunction
:
"
+
this
.
hashFunction
+
"
hashValue
:
"
+
this
.
hashValue
+
(
this
.
size
!
=
=
undefined
?
"
size
:
"
+
this
.
size
:
"
"
)
+
"
)
"
)
;
}
get
isValid
(
)
{
return
(
this
.
id
&
&
this
.
URL
&
&
this
.
version
&
&
this
.
hashFunction
&
&
!
!
this
.
hashValue
)
;
}
get
isInstalled
(
)
{
return
(
this
.
version
&
&
GMPPrefs
.
getString
(
GMPPrefs
.
KEY_PLUGIN_VERSION
"
"
this
.
id
)
=
=
=
this
.
version
)
;
}
get
isEME
(
)
{
return
this
.
id
=
=
"
gmp
-
widevinecdm
"
|
|
this
.
id
.
indexOf
(
"
gmp
-
eme
-
"
)
=
=
0
;
}
get
isOpenH264
(
)
{
return
this
.
id
=
=
"
gmp
-
gmpopenh264
"
;
}
get
isUpdate
(
)
{
return
(
this
.
version
&
&
GMPPrefs
.
getBool
(
GMPPrefs
.
KEY_PLUGIN_VERSION
false
this
.
id
)
)
;
}
}
;
function
GMPExtractor
(
zipPath
relativeInstallPath
)
{
this
.
zipPath
=
zipPath
;
this
.
relativeInstallPath
=
relativeInstallPath
;
}
GMPExtractor
.
prototype
=
{
install
(
)
{
this
.
_deferred
=
PromiseUtils
.
defer
(
)
;
let
deferredPromise
=
this
.
_deferred
;
let
{
zipPath
relativeInstallPath
}
=
this
;
let
worker
=
new
ChromeWorker
(
"
resource
:
/
/
gre
/
modules
/
GMPExtractorWorker
.
js
"
)
;
worker
.
onmessage
=
function
(
msg
)
{
let
log
=
getScopedLogger
(
"
GMPExtractor
"
)
;
worker
.
terminate
(
)
;
if
(
msg
.
data
.
result
!
=
"
success
"
)
{
log
.
error
(
"
Failed
to
extract
zip
file
:
"
+
zipPath
)
;
return
deferredPromise
.
reject
(
{
target
:
this
status
:
msg
.
data
.
exception
type
:
"
exception
"
}
)
;
}
log
.
info
(
"
Successfully
extracted
zip
file
:
"
+
zipPath
)
;
return
deferredPromise
.
resolve
(
msg
.
data
.
extractedPaths
)
;
}
;
worker
.
postMessage
(
{
zipPath
relativeInstallPath
}
)
;
return
this
.
_deferred
.
promise
;
}
}
;
function
GMPDownloader
(
gmpAddon
)
{
this
.
_gmpAddon
=
gmpAddon
;
}
GMPDownloader
.
prototype
=
{
start
(
)
{
let
log
=
getScopedLogger
(
"
GMPDownloader
"
)
;
let
gmpAddon
=
this
.
_gmpAddon
;
if
(
!
gmpAddon
.
isValid
)
{
log
.
info
(
"
gmpAddon
is
not
valid
will
not
continue
"
)
;
return
Promise
.
reject
(
{
target
:
this
type
:
"
downloaderr
"
}
)
;
}
const
downloadOptions
=
{
httpsOnlyNoUpgrade
:
gmpAddon
.
isOpenH264
}
;
return
ProductAddonChecker
.
downloadAddon
(
gmpAddon
downloadOptions
)
.
then
(
zipPath
=
>
{
let
relativePath
=
OS
.
Path
.
join
(
gmpAddon
.
id
gmpAddon
.
version
)
;
log
.
info
(
"
install
to
directory
path
:
"
+
relativePath
)
;
let
gmpInstaller
=
new
GMPExtractor
(
zipPath
relativePath
)
;
let
installPromise
=
gmpInstaller
.
install
(
)
;
return
installPromise
.
then
(
extractedPaths
=
>
{
let
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
GMPPrefs
.
setInt
(
GMPPrefs
.
KEY_PLUGIN_LAST_UPDATE
now
gmpAddon
.
id
)
;
let
abi
=
GMPUtils
.
_expectedABI
(
gmpAddon
)
;
log
.
info
(
"
Setting
ABI
to
'
"
+
abi
+
"
'
for
"
+
gmpAddon
.
id
)
;
GMPPrefs
.
setString
(
GMPPrefs
.
KEY_PLUGIN_ABI
abi
gmpAddon
.
id
)
;
GMPPrefs
.
setString
(
GMPPrefs
.
KEY_PLUGIN_VERSION
gmpAddon
.
version
gmpAddon
.
id
)
;
return
extractedPaths
;
}
)
;
}
)
;
}
}
;
