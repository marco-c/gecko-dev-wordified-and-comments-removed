"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserUtils
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
Region
"
"
resource
:
/
/
gre
/
modules
/
Region
.
jsm
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
INVALID_SHAREABLE_SCHEMES
"
"
services
.
sync
.
engine
.
tabs
.
filteredSchemes
"
"
"
null
val
=
>
{
return
new
Set
(
val
.
split
(
"
|
"
)
)
;
}
)
;
function
stringPrefToSet
(
prefVal
)
{
return
new
Set
(
prefVal
.
toLowerCase
(
)
.
split
(
/
\
s
*
\
s
*
/
g
)
.
filter
(
v
=
>
!
!
v
)
)
;
}
var
BrowserUtils
=
{
principalWithMatchingOA
(
principal
existingPrincipal
)
{
if
(
principal
.
isSystemPrincipal
)
{
return
principal
;
}
if
(
existingPrincipal
.
originSuffix
=
=
principal
.
originSuffix
)
{
return
principal
;
}
let
secMan
=
Services
.
scriptSecurityManager
;
if
(
principal
.
isContentPrincipal
)
{
return
secMan
.
principalWithOA
(
principal
existingPrincipal
.
originAttributes
)
;
}
if
(
principal
.
isNullPrincipal
)
{
return
secMan
.
createNullPrincipal
(
existingPrincipal
.
originAttributes
)
;
}
throw
new
Error
(
"
Can
'
t
change
the
originAttributes
of
an
expanded
principal
!
"
)
;
}
mimeTypeIsTextBased
(
mimeType
)
{
return
(
mimeType
.
startsWith
(
"
text
/
"
)
|
|
mimeType
.
endsWith
(
"
+
xml
"
)
|
|
mimeType
.
endsWith
(
"
+
json
"
)
|
|
mimeType
=
=
"
application
/
x
-
javascript
"
|
|
mimeType
=
=
"
application
/
javascript
"
|
|
mimeType
=
=
"
application
/
json
"
|
|
mimeType
=
=
"
application
/
xml
"
)
;
}
canFindInPage
(
location
)
{
return
(
!
location
.
startsWith
(
"
about
:
addons
"
)
&
&
!
location
.
startsWith
(
"
chrome
:
/
/
mozapps
/
content
/
extensions
/
aboutaddons
.
html
"
)
&
&
!
location
.
startsWith
(
"
about
:
preferences
"
)
)
;
}
isFindbarVisible
(
docShell
)
{
const
FINDER_JSM
=
"
resource
:
/
/
gre
/
modules
/
Finder
.
jsm
"
;
return
(
Cu
.
isModuleLoaded
(
FINDER_JSM
)
&
&
ChromeUtils
.
import
(
FINDER_JSM
)
.
Finder
.
isFindbarVisible
(
docShell
)
)
;
}
promiseObserved
(
topic
test
=
(
)
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
test
(
subject
data
)
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
{
subject
data
}
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
topic
)
;
}
)
;
}
isShareableURL
(
url
)
{
if
(
!
url
)
{
return
false
;
}
if
(
url
.
spec
.
length
>
65535
)
{
return
false
;
}
return
!
lazy
.
INVALID_SHAREABLE_SCHEMES
.
has
(
url
.
scheme
)
;
}
hrefAndLinkNodeForClickEvent
(
event
)
{
let
content
=
event
.
view
|
|
event
.
composedTarget
?
.
ownerGlobal
;
if
(
!
content
?
.
HTMLAnchorElement
)
{
return
null
;
}
function
isHTMLLink
(
aNode
)
{
return
(
(
content
.
HTMLAnchorElement
.
isInstance
(
aNode
)
&
&
aNode
.
href
)
|
|
(
content
.
HTMLAreaElement
.
isInstance
(
aNode
)
&
&
aNode
.
href
)
|
|
content
.
HTMLLinkElement
.
isInstance
(
aNode
)
)
;
}
let
node
=
event
.
composedTarget
;
while
(
node
&
&
!
isHTMLLink
(
node
)
)
{
node
=
node
.
flattenedTreeParentNode
;
}
if
(
node
)
{
return
[
node
.
href
node
node
.
ownerDocument
.
nodePrincipal
]
;
}
let
href
baseURI
;
node
=
event
.
composedTarget
;
while
(
node
&
&
!
href
)
{
if
(
node
.
nodeType
=
=
content
.
Node
.
ELEMENT_NODE
&
&
(
node
.
localName
=
=
"
a
"
|
|
node
.
namespaceURI
=
=
"
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
"
)
)
{
href
=
node
.
getAttribute
(
"
href
"
)
|
|
node
.
getAttributeNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
"
"
href
"
)
;
if
(
href
)
{
baseURI
=
node
.
ownerDocument
.
baseURIObject
;
break
;
}
}
node
=
node
.
flattenedTreeParentNode
;
}
return
[
href
?
Services
.
io
.
newURI
(
href
null
baseURI
)
.
spec
:
null
null
node
&
&
node
.
ownerDocument
.
nodePrincipal
]
;
}
whereToOpenLink
(
e
ignoreButton
ignoreAlt
)
{
if
(
!
e
)
{
return
"
current
"
;
}
e
=
this
.
getRootEvent
(
e
)
;
var
shift
=
e
.
shiftKey
;
var
ctrl
=
e
.
ctrlKey
;
var
meta
=
e
.
metaKey
;
var
alt
=
e
.
altKey
&
&
!
ignoreAlt
;
let
middle
=
!
ignoreButton
&
&
e
.
button
=
=
1
;
let
middleUsesTabs
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
opentabfor
.
middleclick
"
true
)
;
let
middleUsesNewWindow
=
Services
.
prefs
.
getBoolPref
(
"
middlemouse
.
openNewWindow
"
false
)
;
var
metaKey
=
AppConstants
.
platform
=
=
"
macosx
"
?
meta
:
ctrl
;
if
(
metaKey
|
|
(
middle
&
&
middleUsesTabs
)
)
{
return
shift
?
"
tabshifted
"
:
"
tab
"
;
}
if
(
alt
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
altClickSave
"
false
)
)
{
return
"
save
"
;
}
if
(
shift
|
|
(
middle
&
&
!
middleUsesTabs
&
&
middleUsesNewWindow
)
)
{
return
"
window
"
;
}
return
"
current
"
;
}
getRootEvent
(
aEvent
)
{
if
(
!
aEvent
)
{
return
aEvent
;
}
let
tempEvent
=
aEvent
;
while
(
tempEvent
.
sourceEvent
)
{
if
(
tempEvent
.
sourceEvent
.
button
=
=
1
)
{
aEvent
=
tempEvent
.
sourceEvent
;
break
;
}
tempEvent
=
tempEvent
.
sourceEvent
;
}
return
aEvent
;
}
PromoType
:
{
DEFAULT
:
0
VPN
:
1
RALLY
:
2
FOCUS
:
3
}
shouldShowPromo
(
promoType
)
{
switch
(
promoType
)
{
case
this
.
PromoType
.
VPN
:
return
this
.
_shouldShowPromoInternal
(
promoType
)
;
case
this
.
PromoType
.
RALLY
:
return
this
.
_shouldShowRallyPromo
(
)
;
case
this
.
PromoType
.
FOCUS
:
return
this
.
_shouldShowPromoInternal
(
promoType
)
;
default
:
throw
new
Error
(
"
Unknown
promo
type
:
"
promoType
)
;
}
}
shouldShowVPNPromo
(
)
{
return
this
.
_shouldShowPromoInternal
(
this
.
PromoType
.
VPN
)
;
}
_shouldShowPromoInternal
(
promoType
)
{
const
info
=
PromoInfo
[
promoType
]
;
const
promoEnabled
=
Services
.
prefs
.
getBoolPref
(
info
.
enabledPref
true
)
;
const
homeRegion
=
lazy
.
Region
.
home
|
|
"
"
;
const
currentRegion
=
lazy
.
Region
.
current
|
|
"
"
;
let
inSupportedRegion
=
true
;
if
(
"
supportedRegions
"
in
info
.
lazyStringSetPrefs
)
{
const
supportedRegions
=
info
.
lazyStringSetPrefs
.
supportedRegions
.
lazyValue
;
inSupportedRegion
=
supportedRegions
.
has
(
currentRegion
.
toLowerCase
(
)
)
|
|
supportedRegions
.
has
(
homeRegion
.
toLowerCase
(
)
)
;
}
const
avoidAdsRegions
=
info
.
lazyStringSetPrefs
.
disallowedRegions
.
lazyValue
;
const
noActivePolicy
=
!
Services
.
policies
|
|
Services
.
policies
.
status
!
=
=
Services
.
policies
.
ACTIVE
;
return
(
promoEnabled
&
&
!
avoidAdsRegions
.
has
(
homeRegion
.
toLowerCase
(
)
)
&
&
!
avoidAdsRegions
.
has
(
currentRegion
.
toLowerCase
(
)
)
&
&
!
info
.
illegalRegions
.
includes
(
homeRegion
.
toLowerCase
(
)
)
&
&
!
info
.
illegalRegions
.
includes
(
currentRegion
.
toLowerCase
(
)
)
&
&
inSupportedRegion
&
&
noActivePolicy
)
;
}
shouldShowRallyPromo
(
)
{
const
homeRegion
=
lazy
.
Region
.
home
|
|
"
"
;
const
currentRegion
=
lazy
.
Region
.
current
|
|
"
"
;
const
region
=
currentRegion
|
|
homeRegion
;
const
language
=
Services
.
locale
.
appLocaleAsBCP47
;
return
language
.
startsWith
(
"
en
-
"
)
&
&
region
.
toLowerCase
(
)
=
=
"
us
"
;
}
sendToDeviceEmailsSupported
(
)
{
const
userLocale
=
Services
.
locale
.
appLocaleAsBCP47
.
toLowerCase
(
)
;
return
this
.
emailSupportedLocales
.
has
(
userLocale
)
;
}
}
;
let
PromoInfo
=
{
[
BrowserUtils
.
PromoType
.
VPN
]
:
{
enabledPref
:
"
browser
.
vpn_promo
.
enabled
"
lazyStringSetPrefs
:
{
supportedRegions
:
{
name
:
"
browser
.
contentblocking
.
report
.
vpn_region
"
default
:
"
us
ca
nz
sg
my
gb
de
fr
"
}
disallowedRegions
:
{
name
:
"
browser
.
vpn_promo
.
disallowed_regions
"
default
:
"
ae
by
cn
cu
iq
ir
kp
om
ru
sd
sy
tm
tr
ua
"
}
}
illegalRegions
:
[
"
cn
"
"
kp
"
"
tm
"
]
}
[
BrowserUtils
.
PromoType
.
FOCUS
]
:
{
enabledPref
:
"
browser
.
promo
.
focus
.
enabled
"
lazyStringSetPrefs
:
{
disallowedRegions
:
{
name
:
"
browser
.
promo
.
focus
.
disallowed_regions
"
default
:
"
cn
"
}
}
illegalRegions
:
[
"
cn
"
]
}
}
;
for
(
let
promo
of
Object
.
values
(
PromoInfo
)
)
{
for
(
let
prefObj
of
Object
.
values
(
promo
.
lazyStringSetPrefs
)
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
prefObj
"
lazyValue
"
prefObj
.
name
prefObj
.
default
null
stringPrefToSet
)
;
}
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
BrowserUtils
"
navigationRequireUserInteraction
"
"
browser
.
navigation
.
requireUserInteraction
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
BrowserUtils
"
emailSupportedLocales
"
"
browser
.
send_to_device_locales
"
"
de
en
-
GB
en
-
US
es
-
AR
es
-
CL
es
-
ES
es
-
MX
fr
id
pl
pt
-
BR
ru
zh
-
TW
"
null
stringPrefToSet
)
;
