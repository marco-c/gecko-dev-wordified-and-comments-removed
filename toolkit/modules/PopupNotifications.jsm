this
.
EXPORTED_SYMBOLS
=
[
"
PopupNotifications
"
]
;
var
Cc
=
Components
.
classes
Ci
=
Components
.
interfaces
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
const
NOTIFICATION_EVENT_DISMISSED
=
"
dismissed
"
;
const
NOTIFICATION_EVENT_REMOVED
=
"
removed
"
;
const
NOTIFICATION_EVENT_SHOWING
=
"
showing
"
;
const
NOTIFICATION_EVENT_SHOWN
=
"
shown
"
;
const
NOTIFICATION_EVENT_SWAPPING
=
"
swapping
"
;
const
ICON_SELECTOR
=
"
.
notification
-
anchor
-
icon
"
;
const
ICON_ATTRIBUTE_SHOWING
=
"
showing
"
;
const
ICON_ANCHOR_ATTRIBUTE
=
"
popupnotificationanchor
"
;
const
PREF_SECURITY_DELAY
=
"
security
.
notification_enable_delay
"
;
const
TELEMETRY_STAT_OFFERED
=
0
;
const
TELEMETRY_STAT_ACTION_1
=
1
;
const
TELEMETRY_STAT_ACTION_2
=
2
;
const
TELEMETRY_STAT_ACTION_3
=
3
;
const
TELEMETRY_STAT_ACTION_LAST
=
4
;
const
TELEMETRY_STAT_DISMISSAL_CLICK_ELSEWHERE
=
5
;
const
TELEMETRY_STAT_DISMISSAL_LEAVE_PAGE
=
6
;
const
TELEMETRY_STAT_DISMISSAL_CLOSE_BUTTON
=
7
;
const
TELEMETRY_STAT_DISMISSAL_NOT_NOW
=
8
;
const
TELEMETRY_STAT_OPEN_SUBMENU
=
10
;
const
TELEMETRY_STAT_LEARN_MORE
=
11
;
const
TELEMETRY_STAT_REOPENED_OFFSET
=
20
;
var
popupNotificationsMap
=
new
WeakMap
(
)
;
var
gNotificationParents
=
new
WeakMap
;
function
getAnchorFromBrowser
(
aBrowser
aAnchorID
)
{
let
attrPrefix
=
aAnchorID
?
aAnchorID
.
replace
(
"
notification
-
icon
"
"
"
)
:
"
"
;
let
anchor
=
aBrowser
.
getAttribute
(
attrPrefix
+
ICON_ANCHOR_ATTRIBUTE
)
|
|
aBrowser
[
attrPrefix
+
ICON_ANCHOR_ATTRIBUTE
]
|
|
aBrowser
.
getAttribute
(
ICON_ANCHOR_ATTRIBUTE
)
|
|
aBrowser
[
ICON_ANCHOR_ATTRIBUTE
]
;
if
(
anchor
)
{
if
(
anchor
instanceof
Ci
.
nsIDOMXULElement
)
{
return
anchor
;
}
return
aBrowser
.
ownerDocument
.
getElementById
(
anchor
)
;
}
return
null
;
}
function
getNotificationFromElement
(
aElement
)
{
let
notificationEl
;
let
parent
=
aElement
;
while
(
parent
&
&
(
parent
=
aElement
.
ownerDocument
.
getBindingParent
(
parent
)
)
)
notificationEl
=
parent
;
return
notificationEl
;
}
function
Notification
(
id
message
anchorID
mainAction
secondaryActions
browser
owner
options
)
{
this
.
id
=
id
;
this
.
message
=
message
;
this
.
anchorID
=
anchorID
;
this
.
mainAction
=
mainAction
;
this
.
secondaryActions
=
secondaryActions
|
|
[
]
;
this
.
browser
=
browser
;
this
.
owner
=
owner
;
this
.
options
=
options
|
|
{
}
;
this
.
_dismissed
=
false
;
this
.
_checkboxChecked
=
null
;
this
.
wasDismissed
=
false
;
this
.
recordedTelemetryStats
=
new
Set
(
)
;
this
.
isPrivate
=
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
browser
.
ownerDocument
.
defaultView
)
;
this
.
timeCreated
=
this
.
owner
.
window
.
performance
.
now
(
)
;
}
Notification
.
prototype
=
{
id
:
null
message
:
null
anchorID
:
null
mainAction
:
null
secondaryActions
:
null
browser
:
null
owner
:
null
options
:
null
timeShown
:
null
set
dismissed
(
value
)
{
this
.
_dismissed
=
value
;
if
(
value
)
{
this
.
wasDismissed
=
true
;
}
}
get
dismissed
(
)
{
return
this
.
_dismissed
;
}
remove
:
function
Notification_remove
(
)
{
this
.
owner
.
remove
(
this
)
;
}
get
anchorElement
(
)
{
let
iconBox
=
this
.
owner
.
iconBox
;
let
anchorElement
=
getAnchorFromBrowser
(
this
.
browser
this
.
anchorID
)
;
if
(
!
iconBox
)
return
anchorElement
;
if
(
!
anchorElement
&
&
this
.
anchorID
)
anchorElement
=
iconBox
.
querySelector
(
"
#
"
+
this
.
anchorID
)
;
if
(
!
anchorElement
)
anchorElement
=
iconBox
.
querySelector
(
"
#
default
-
notification
-
icon
"
)
|
|
iconBox
;
return
anchorElement
;
}
reshow
:
function
(
)
{
this
.
owner
.
_reshowNotifications
(
this
.
anchorElement
this
.
browser
)
;
}
_recordTelemetry
(
histogramId
value
)
{
if
(
this
.
isPrivate
)
{
return
;
}
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
histogramId
)
;
histogram
.
add
(
"
(
all
)
"
value
)
;
histogram
.
add
(
this
.
id
value
)
;
}
_recordTelemetryStat
(
value
)
{
if
(
this
.
wasDismissed
)
{
value
+
=
TELEMETRY_STAT_REOPENED_OFFSET
;
}
if
(
!
this
.
recordedTelemetryStats
.
has
(
value
)
)
{
this
.
recordedTelemetryStats
.
add
(
value
)
;
this
.
_recordTelemetry
(
"
POPUP_NOTIFICATION_STATS
"
value
)
;
}
}
}
;
this
.
PopupNotifications
=
function
PopupNotifications
(
tabbrowser
panel
iconBox
)
{
if
(
!
(
tabbrowser
instanceof
Ci
.
nsIDOMXULElement
)
)
throw
"
Invalid
tabbrowser
"
;
if
(
iconBox
&
&
!
(
iconBox
instanceof
Ci
.
nsIDOMXULElement
)
)
throw
"
Invalid
iconBox
"
;
if
(
!
(
panel
instanceof
Ci
.
nsIDOMXULElement
)
)
throw
"
Invalid
panel
"
;
this
.
window
=
tabbrowser
.
ownerDocument
.
defaultView
;
this
.
panel
=
panel
;
this
.
tabbrowser
=
tabbrowser
;
this
.
iconBox
=
iconBox
;
this
.
buttonDelay
=
Services
.
prefs
.
getIntPref
(
PREF_SECURITY_DELAY
)
;
this
.
panel
.
addEventListener
(
"
popuphidden
"
this
true
)
;
this
.
window
.
addEventListener
(
"
activate
"
this
true
)
;
if
(
this
.
tabbrowser
.
tabContainer
)
this
.
tabbrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
this
true
)
;
}
PopupNotifications
.
prototype
=
{
window
:
null
panel
:
null
tabbrowser
:
null
_iconBox
:
null
set
iconBox
(
iconBox
)
{
if
(
this
.
_iconBox
)
{
this
.
_iconBox
.
removeEventListener
(
"
click
"
this
false
)
;
this
.
_iconBox
.
removeEventListener
(
"
keypress
"
this
false
)
;
}
this
.
_iconBox
=
iconBox
;
if
(
iconBox
)
{
iconBox
.
addEventListener
(
"
click
"
this
false
)
;
iconBox
.
addEventListener
(
"
keypress
"
this
false
)
;
}
}
get
iconBox
(
)
{
return
this
.
_iconBox
;
}
getNotification
:
function
PopupNotifications_getNotification
(
id
browser
)
{
let
n
=
null
;
let
notifications
=
this
.
_getNotificationsForBrowser
(
browser
|
|
this
.
tabbrowser
.
selectedBrowser
)
;
notifications
.
some
(
x
=
>
x
.
id
=
=
id
&
&
(
n
=
x
)
)
;
return
n
;
}
show
:
function
PopupNotifications_show
(
browser
id
message
anchorID
mainAction
secondaryActions
options
)
{
function
isInvalidAction
(
a
)
{
return
!
a
|
|
!
(
typeof
(
a
.
callback
)
=
=
"
function
"
)
|
|
!
a
.
label
|
|
!
a
.
accessKey
;
}
if
(
!
browser
)
throw
"
PopupNotifications_show
:
invalid
browser
"
;
if
(
!
id
)
throw
"
PopupNotifications_show
:
invalid
ID
"
;
if
(
mainAction
&
&
isInvalidAction
(
mainAction
)
)
throw
"
PopupNotifications_show
:
invalid
mainAction
"
;
if
(
secondaryActions
&
&
secondaryActions
.
some
(
isInvalidAction
)
)
throw
"
PopupNotifications_show
:
invalid
secondaryActions
"
;
if
(
options
&
&
options
.
hideNotNow
&
&
(
!
secondaryActions
|
|
!
secondaryActions
.
length
|
|
!
secondaryActions
.
concat
(
mainAction
)
.
some
(
action
=
>
action
.
dismiss
)
)
)
throw
"
PopupNotifications_show
:
'
Not
Now
'
item
hidden
without
replacement
"
;
let
notification
=
new
Notification
(
id
message
anchorID
mainAction
secondaryActions
browser
this
options
)
;
if
(
options
&
&
options
.
dismissed
)
notification
.
dismissed
=
true
;
let
existingNotification
=
this
.
getNotification
(
id
browser
)
;
if
(
existingNotification
)
this
.
_remove
(
existingNotification
)
;
let
notifications
=
this
.
_getNotificationsForBrowser
(
browser
)
;
notifications
.
push
(
notification
)
;
let
isActiveBrowser
=
browser
.
docShellIsActive
;
let
fm
=
Cc
[
"
mozilla
.
org
/
focus
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIFocusManager
)
;
let
isActiveWindow
=
fm
.
activeWindow
=
=
this
.
window
;
if
(
isActiveBrowser
)
{
if
(
isActiveWindow
)
{
this
.
_update
(
notifications
new
Set
(
[
notification
.
anchorElement
]
)
true
)
;
}
else
{
if
(
!
notification
.
dismissed
)
{
this
.
window
.
getAttention
(
)
;
}
this
.
_updateAnchorIcons
(
notifications
this
.
_getAnchorsForNotifications
(
notifications
notification
.
anchorElement
)
)
;
this
.
_notify
(
"
backgroundShow
"
)
;
}
}
else
{
this
.
_notify
(
"
backgroundShow
"
)
;
}
return
notification
;
}
get
isPanelOpen
(
)
{
let
panelState
=
this
.
panel
.
state
;
return
panelState
=
=
"
showing
"
|
|
panelState
=
=
"
open
"
;
}
locationChange
:
function
PopupNotifications_locationChange
(
aBrowser
)
{
if
(
!
aBrowser
)
throw
"
PopupNotifications_locationChange
:
invalid
browser
"
;
let
notifications
=
this
.
_getNotificationsForBrowser
(
aBrowser
)
;
notifications
=
notifications
.
filter
(
function
(
notification
)
{
if
(
notification
.
options
.
persistWhileVisible
&
&
this
.
isPanelOpen
)
{
if
(
"
persistence
"
in
notification
.
options
&
&
notification
.
options
.
persistence
)
notification
.
options
.
persistence
-
-
;
return
true
;
}
if
(
"
persistence
"
in
notification
.
options
&
&
notification
.
options
.
persistence
)
{
notification
.
options
.
persistence
-
-
;
return
true
;
}
if
(
"
timeout
"
in
notification
.
options
&
&
Date
.
now
(
)
<
=
notification
.
options
.
timeout
)
{
return
true
;
}
this
.
_fireCallback
(
notification
NOTIFICATION_EVENT_REMOVED
)
;
return
false
;
}
this
)
;
this
.
_setNotificationsForBrowser
(
aBrowser
notifications
)
;
if
(
aBrowser
.
docShellIsActive
)
{
this
.
_update
(
notifications
this
.
_getAnchorsForNotifications
(
notifications
getAnchorFromBrowser
(
aBrowser
)
)
)
;
}
}
remove
:
function
PopupNotifications_remove
(
notification
)
{
this
.
_remove
(
notification
)
;
if
(
notification
.
browser
.
docShellIsActive
)
{
let
notifications
=
this
.
_getNotificationsForBrowser
(
notification
.
browser
)
;
this
.
_update
(
notifications
)
;
}
}
handleEvent
:
function
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
popuphidden
"
:
this
.
_onPopupHidden
(
aEvent
)
;
break
;
case
"
activate
"
:
case
"
TabSelect
"
:
let
self
=
this
;
this
.
nextDismissReason
=
TELEMETRY_STAT_DISMISSAL_LEAVE_PAGE
;
this
.
window
.
setTimeout
(
function
(
)
{
self
.
_update
(
)
;
}
0
)
;
break
;
case
"
click
"
:
case
"
keypress
"
:
this
.
_onIconBoxCommand
(
aEvent
)
;
break
;
}
}
_ignoreDismissal
:
null
_currentAnchorElement
:
null
get
_currentNotifications
(
)
{
return
this
.
tabbrowser
.
selectedBrowser
?
this
.
_getNotificationsForBrowser
(
this
.
tabbrowser
.
selectedBrowser
)
:
[
]
;
}
_remove
:
function
PopupNotifications_removeHelper
(
notification
)
{
let
notifications
=
this
.
_getNotificationsForBrowser
(
notification
.
browser
)
;
if
(
!
notifications
)
return
;
var
index
=
notifications
.
indexOf
(
notification
)
;
if
(
index
=
=
-
1
)
return
;
if
(
notification
.
browser
.
docShellIsActive
)
notification
.
anchorElement
.
removeAttribute
(
ICON_ATTRIBUTE_SHOWING
)
;
notifications
.
splice
(
index
1
)
;
this
.
_fireCallback
(
notification
NOTIFICATION_EVENT_REMOVED
)
;
}
_dismiss
:
function
PopupNotifications_dismiss
(
telemetryReason
)
{
if
(
telemetryReason
)
{
this
.
nextDismissReason
=
telemetryReason
;
}
let
browser
=
this
.
panel
.
firstChild
&
&
this
.
panel
.
firstChild
.
notification
.
browser
;
this
.
panel
.
hidePopup
(
)
;
if
(
browser
)
browser
.
focus
(
)
;
}
_hidePanel
:
function
PopupNotifications_hide
(
)
{
if
(
this
.
panel
.
state
=
=
"
closed
"
)
{
return
Promise
.
resolve
(
)
;
}
if
(
this
.
_ignoreDismissal
)
{
return
this
.
_ignoreDismissal
.
promise
;
}
let
deferred
=
Promise
.
defer
(
)
;
this
.
_ignoreDismissal
=
deferred
;
this
.
panel
.
hidePopup
(
)
;
return
deferred
.
promise
;
}
_clearPanel
:
function
(
)
{
let
popupnotification
;
while
(
(
popupnotification
=
this
.
panel
.
lastChild
)
)
{
this
.
panel
.
removeChild
(
popupnotification
)
;
let
originalParent
=
gNotificationParents
.
get
(
popupnotification
)
;
if
(
originalParent
)
{
popupnotification
.
notification
=
null
;
let
contentNode
=
popupnotification
.
lastChild
;
while
(
contentNode
)
{
let
previousSibling
=
contentNode
.
previousSibling
;
if
(
contentNode
.
nodeName
=
=
"
menuitem
"
|
|
contentNode
.
nodeName
=
=
"
menuseparator
"
)
popupnotification
.
removeChild
(
contentNode
)
;
contentNode
=
previousSibling
;
}
popupnotification
.
hidden
=
true
;
originalParent
.
appendChild
(
popupnotification
)
;
}
}
}
_refreshPanel
:
function
PopupNotifications_refreshPanel
(
notificationsToShow
)
{
this
.
_clearPanel
(
)
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
notificationsToShow
.
forEach
(
function
(
n
)
{
let
doc
=
this
.
window
.
document
;
let
popupnotificationID
=
n
.
id
+
"
-
notification
"
;
let
popupnotification
=
doc
.
getElementById
(
popupnotificationID
)
;
if
(
popupnotification
)
gNotificationParents
.
set
(
popupnotification
popupnotification
.
parentNode
)
;
else
popupnotification
=
doc
.
createElementNS
(
XUL_NS
"
popupnotification
"
)
;
popupnotification
.
setAttribute
(
"
label
"
n
.
message
)
;
popupnotification
.
setAttribute
(
"
id
"
popupnotificationID
)
;
popupnotification
.
setAttribute
(
"
popupid
"
n
.
id
)
;
popupnotification
.
setAttribute
(
"
closebuttoncommand
"
PopupNotifications
.
_dismiss
(
{
TELEMETRY_STAT_DISMISSAL_CLOSE_BUTTON
}
)
;
)
;
if
(
n
.
mainAction
)
{
popupnotification
.
setAttribute
(
"
buttonlabel
"
n
.
mainAction
.
label
)
;
popupnotification
.
setAttribute
(
"
buttonaccesskey
"
n
.
mainAction
.
accessKey
)
;
popupnotification
.
setAttribute
(
"
buttoncommand
"
"
PopupNotifications
.
_onButtonEvent
(
event
'
buttoncommand
'
)
;
"
)
;
popupnotification
.
setAttribute
(
"
buttonpopupshown
"
"
PopupNotifications
.
_onButtonEvent
(
event
'
buttonpopupshown
'
)
;
"
)
;
popupnotification
.
setAttribute
(
"
learnmoreclick
"
"
PopupNotifications
.
_onButtonEvent
(
event
'
learnmoreclick
'
)
;
"
)
;
popupnotification
.
setAttribute
(
"
menucommand
"
"
PopupNotifications
.
_onMenuCommand
(
event
)
;
"
)
;
popupnotification
.
setAttribute
(
"
closeitemcommand
"
PopupNotifications
.
_dismiss
(
{
TELEMETRY_STAT_DISMISSAL_NOT_NOW
}
)
;
event
.
stopPropagation
(
)
;
)
;
}
else
{
popupnotification
.
removeAttribute
(
"
buttonlabel
"
)
;
popupnotification
.
removeAttribute
(
"
buttonaccesskey
"
)
;
popupnotification
.
removeAttribute
(
"
buttoncommand
"
)
;
popupnotification
.
removeAttribute
(
"
buttonpopupshown
"
)
;
popupnotification
.
removeAttribute
(
"
learnmoreclick
"
)
;
popupnotification
.
removeAttribute
(
"
menucommand
"
)
;
popupnotification
.
removeAttribute
(
"
closeitemcommand
"
)
;
}
if
(
n
.
options
.
popupIconURL
)
popupnotification
.
setAttribute
(
"
icon
"
n
.
options
.
popupIconURL
)
;
if
(
n
.
options
.
learnMoreURL
)
popupnotification
.
setAttribute
(
"
learnmoreurl
"
n
.
options
.
learnMoreURL
)
;
else
popupnotification
.
removeAttribute
(
"
learnmoreurl
"
)
;
if
(
n
.
options
.
displayURI
)
{
let
uri
;
try
{
if
(
n
.
options
.
displayURI
instanceof
Ci
.
nsIFileURL
)
{
uri
=
n
.
options
.
displayURI
.
path
;
}
else
{
uri
=
n
.
options
.
displayURI
.
hostPort
;
}
popupnotification
.
setAttribute
(
"
origin
"
uri
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
popupnotification
.
removeAttribute
(
"
origin
"
)
;
}
}
else
popupnotification
.
removeAttribute
(
"
origin
"
)
;
popupnotification
.
notification
=
n
;
if
(
n
.
secondaryActions
)
{
let
telemetryStatId
=
TELEMETRY_STAT_ACTION_2
;
n
.
secondaryActions
.
forEach
(
function
(
a
)
{
let
item
=
doc
.
createElementNS
(
XUL_NS
"
menuitem
"
)
;
item
.
setAttribute
(
"
label
"
a
.
label
)
;
item
.
setAttribute
(
"
accesskey
"
a
.
accessKey
)
;
item
.
notification
=
n
;
item
.
action
=
a
;
popupnotification
.
appendChild
(
item
)
;
item
.
action
.
telemetryStatId
=
telemetryStatId
;
if
(
telemetryStatId
<
TELEMETRY_STAT_ACTION_LAST
)
{
telemetryStatId
+
+
;
}
}
this
)
;
if
(
n
.
options
.
hideNotNow
)
{
popupnotification
.
setAttribute
(
"
hidenotnow
"
"
true
"
)
;
}
else
if
(
n
.
secondaryActions
.
length
)
{
let
closeItemSeparator
=
doc
.
createElementNS
(
XUL_NS
"
menuseparator
"
)
;
popupnotification
.
appendChild
(
closeItemSeparator
)
;
}
}
let
checkbox
=
n
.
options
.
checkbox
;
if
(
checkbox
&
&
checkbox
.
label
)
{
let
checked
=
n
.
_checkboxChecked
!
=
null
?
n
.
_checkboxChecked
:
!
!
checkbox
.
checked
;
popupnotification
.
setAttribute
(
"
checkboxhidden
"
"
false
"
)
;
popupnotification
.
setAttribute
(
"
checkboxchecked
"
checked
)
;
popupnotification
.
setAttribute
(
"
checkboxlabel
"
checkbox
.
label
)
;
popupnotification
.
setAttribute
(
"
checkboxcommand
"
"
PopupNotifications
.
_onCheckboxCommand
(
event
)
;
"
)
;
if
(
checked
)
{
this
.
_setNotificationUIState
(
popupnotification
checkbox
.
checkedState
)
;
}
else
{
this
.
_setNotificationUIState
(
popupnotification
checkbox
.
uncheckedState
)
;
}
}
else
{
popupnotification
.
setAttribute
(
"
checkboxhidden
"
"
true
"
)
;
}
this
.
panel
.
appendChild
(
popupnotification
)
;
popupnotification
.
hidden
=
false
;
}
this
)
;
}
_setNotificationUIState
(
notification
state
=
{
}
)
{
notification
.
setAttribute
(
"
mainactiondisabled
"
state
.
disableMainAction
|
|
"
false
"
)
;
if
(
state
.
warningLabel
)
{
notification
.
setAttribute
(
"
warninglabel
"
state
.
warningLabel
)
;
notification
.
setAttribute
(
"
warninghidden
"
"
false
"
)
;
}
else
{
notification
.
setAttribute
(
"
warninghidden
"
"
true
"
)
;
}
}
_onCheckboxCommand
(
event
)
{
let
notificationEl
=
getNotificationFromElement
(
event
.
originalTarget
)
;
let
checked
=
notificationEl
.
checkbox
.
checked
;
let
notification
=
notificationEl
.
notification
;
notification
.
_checkboxChecked
=
checked
;
if
(
checked
)
{
this
.
_setNotificationUIState
(
notificationEl
notification
.
options
.
checkbox
.
checkedState
)
;
}
else
{
this
.
_setNotificationUIState
(
notificationEl
notification
.
options
.
checkbox
.
uncheckedState
)
;
}
}
_showPanel
:
function
PopupNotifications_showPanel
(
notificationsToShow
anchorElement
)
{
this
.
panel
.
hidden
=
false
;
notificationsToShow
=
notificationsToShow
.
filter
(
n
=
>
{
let
dismiss
=
this
.
_fireCallback
(
n
NOTIFICATION_EVENT_SHOWING
)
;
if
(
dismiss
)
n
.
dismissed
=
true
;
return
!
dismiss
;
}
)
;
if
(
!
notificationsToShow
.
length
)
return
;
this
.
_refreshPanel
(
notificationsToShow
)
;
if
(
this
.
isPanelOpen
&
&
this
.
_currentAnchorElement
=
=
anchorElement
)
{
notificationsToShow
.
forEach
(
function
(
n
)
{
this
.
_fireCallback
(
n
NOTIFICATION_EVENT_SHOWN
)
;
}
this
)
;
return
;
}
let
promise
=
this
.
_hidePanel
(
)
.
then
(
(
)
=
>
{
let
selectedTab
=
this
.
tabbrowser
.
selectedTab
;
if
(
anchorElement
)
{
let
bo
=
anchorElement
.
boxObject
;
if
(
bo
.
height
=
=
0
&
&
bo
.
width
=
=
0
)
anchorElement
=
selectedTab
;
}
else
{
anchorElement
=
selectedTab
;
}
this
.
_currentAnchorElement
=
anchorElement
;
this
.
panel
.
setAttribute
(
"
popupid
"
this
.
panel
.
firstChild
.
getAttribute
(
"
popupid
"
)
)
;
notificationsToShow
.
forEach
(
function
(
n
)
{
n
.
_recordTelemetryStat
(
TELEMETRY_STAT_OFFERED
)
;
n
.
timeShown
=
this
.
window
.
performance
.
now
(
)
;
}
this
)
;
this
.
nextDismissReason
=
TELEMETRY_STAT_DISMISSAL_CLICK_ELSEWHERE
;
let
target
=
this
.
panel
;
if
(
target
.
parentNode
)
{
target
=
target
.
parentNode
;
}
if
(
this
.
_popupshownListener
)
{
target
.
removeEventListener
(
"
popupshown
"
this
.
_popupshownListener
true
)
;
}
this
.
_popupshownListener
=
function
(
e
)
{
target
.
removeEventListener
(
"
popupshown
"
this
.
_popupshownListener
true
)
;
this
.
_popupshownListener
=
null
;
notificationsToShow
.
forEach
(
function
(
n
)
{
this
.
_fireCallback
(
n
NOTIFICATION_EVENT_SHOWN
)
;
}
this
)
;
this
.
panel
.
dispatchEvent
(
new
this
.
window
.
CustomEvent
(
"
Shown
"
)
)
;
}
;
this
.
_popupshownListener
=
this
.
_popupshownListener
.
bind
(
this
)
;
target
.
addEventListener
(
"
popupshown
"
this
.
_popupshownListener
true
)
;
this
.
panel
.
openPopup
(
anchorElement
"
bottomcenter
topleft
"
)
;
}
)
;
}
_update
:
function
PopupNotifications_update
(
notifications
anchors
=
new
Set
(
)
dismissShowing
=
false
)
{
if
(
anchors
instanceof
Ci
.
nsIDOMXULElement
)
anchors
=
new
Set
(
[
anchors
]
)
;
if
(
!
notifications
)
notifications
=
this
.
_currentNotifications
;
let
haveNotifications
=
notifications
.
length
>
0
;
if
(
!
anchors
.
size
&
&
haveNotifications
)
anchors
=
this
.
_getAnchorsForNotifications
(
notifications
)
;
let
useIconBox
=
!
!
this
.
iconBox
;
if
(
useIconBox
&
&
anchors
.
size
)
{
for
(
let
anchor
of
anchors
)
{
if
(
anchor
.
parentNode
=
=
this
.
iconBox
)
continue
;
useIconBox
=
false
;
break
;
}
}
let
notificationsToShow
=
notifications
.
filter
(
function
(
n
)
{
return
!
n
.
dismissed
&
&
!
n
.
options
.
neverShow
;
}
)
;
if
(
useIconBox
)
{
this
.
_hideIcons
(
)
;
}
if
(
haveNotifications
)
{
notificationsToShow
=
notificationsToShow
.
filter
(
function
(
n
)
{
return
anchors
.
has
(
n
.
anchorElement
)
;
}
)
;
if
(
useIconBox
)
{
this
.
_showIcons
(
notifications
)
;
this
.
iconBox
.
hidden
=
false
;
anchors
=
this
.
_getAnchorsForNotifications
(
notificationsToShow
)
;
}
else
if
(
anchors
.
size
)
{
this
.
_updateAnchorIcons
(
notifications
anchors
)
;
}
}
if
(
notificationsToShow
.
length
>
0
)
{
let
anchorElement
=
anchors
.
values
(
)
.
next
(
)
.
value
;
if
(
anchorElement
)
{
this
.
_showPanel
(
notificationsToShow
anchorElement
)
;
}
}
else
{
this
.
_notify
(
"
updateNotShowing
"
)
;
if
(
!
dismissShowing
)
this
.
_dismiss
(
)
;
if
(
!
haveNotifications
)
{
if
(
useIconBox
)
{
this
.
iconBox
.
hidden
=
true
;
}
else
if
(
anchors
.
size
)
{
for
(
let
anchorElement
of
anchors
)
anchorElement
.
removeAttribute
(
ICON_ATTRIBUTE_SHOWING
)
;
}
}
}
}
_updateAnchorIcons
:
function
PopupNotifications_updateAnchorIcons
(
notifications
anchorElements
)
{
for
(
let
anchorElement
of
anchorElements
)
{
anchorElement
.
setAttribute
(
ICON_ATTRIBUTE_SHOWING
"
true
"
)
;
if
(
anchorElement
.
classList
.
contains
(
"
notification
-
anchor
-
icon
"
)
)
{
let
className
=
anchorElement
.
className
.
replace
(
/
(
[
-
\
w
]
+
-
notification
-
icon
\
s
?
)
/
g
"
"
)
if
(
notifications
.
length
>
0
)
{
let
notification
=
notifications
[
0
]
;
for
(
let
n
of
notifications
)
{
if
(
n
.
anchorElement
=
=
anchorElement
)
{
notification
=
n
;
break
;
}
}
className
=
notification
.
anchorID
+
"
"
+
className
;
}
anchorElement
.
className
=
className
;
}
}
}
_showIcons
:
function
PopupNotifications_showIcons
(
aCurrentNotifications
)
{
for
(
let
notification
of
aCurrentNotifications
)
{
let
anchorElm
=
notification
.
anchorElement
;
if
(
anchorElm
)
{
anchorElm
.
setAttribute
(
ICON_ATTRIBUTE_SHOWING
"
true
"
)
;
}
}
}
_hideIcons
:
function
PopupNotifications_hideIcons
(
)
{
let
icons
=
this
.
iconBox
.
querySelectorAll
(
ICON_SELECTOR
)
;
for
(
let
icon
of
icons
)
{
icon
.
removeAttribute
(
ICON_ATTRIBUTE_SHOWING
)
;
}
}
_getNotificationsForBrowser
:
function
PopupNotifications_getNotifications
(
browser
)
{
let
notifications
=
popupNotificationsMap
.
get
(
browser
)
;
if
(
!
notifications
)
{
notifications
=
[
]
;
popupNotificationsMap
.
set
(
browser
notifications
)
;
}
return
notifications
;
}
_setNotificationsForBrowser
:
function
PopupNotifications_setNotifications
(
browser
notifications
)
{
popupNotificationsMap
.
set
(
browser
notifications
)
;
return
notifications
;
}
_getAnchorsForNotifications
:
function
PopupNotifications_getAnchorsForNotifications
(
notifications
defaultAnchor
)
{
let
anchors
=
new
Set
(
)
;
for
(
let
notification
of
notifications
)
{
if
(
notification
.
anchorElement
)
anchors
.
add
(
notification
.
anchorElement
)
}
if
(
defaultAnchor
&
&
!
anchors
.
size
)
anchors
.
add
(
defaultAnchor
)
;
return
anchors
;
}
_onIconBoxCommand
:
function
PopupNotifications_onIconBoxCommand
(
event
)
{
let
type
=
event
.
type
;
if
(
type
=
=
"
click
"
&
&
event
.
button
!
=
0
)
return
;
if
(
type
=
=
"
keypress
"
&
&
!
(
event
.
charCode
=
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_SPACE
|
|
event
.
keyCode
=
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_RETURN
)
)
return
;
if
(
this
.
_currentNotifications
.
length
=
=
0
)
return
;
event
.
stopPropagation
(
)
;
let
anchor
=
event
.
target
;
while
(
anchor
&
&
anchor
.
parentNode
!
=
this
.
iconBox
)
anchor
=
anchor
.
parentNode
;
if
(
!
anchor
)
{
return
;
}
if
(
this
.
panel
.
state
!
=
"
closed
"
&
&
anchor
!
=
this
.
_currentAnchorElement
)
{
this
.
_dismissOrRemoveCurrentNotifications
(
)
;
}
this
.
panel
.
removeAttribute
(
"
noautofocus
"
"
true
"
)
;
this
.
_reshowNotifications
(
anchor
)
;
}
_reshowNotifications
:
function
PopupNotifications_reshowNotifications
(
anchor
browser
)
{
let
notifications
=
this
.
_getNotificationsForBrowser
(
browser
|
|
this
.
tabbrowser
.
selectedBrowser
)
;
notifications
.
forEach
(
function
(
n
)
{
if
(
n
.
anchorElement
=
=
anchor
)
n
.
dismissed
=
false
;
}
)
;
this
.
_update
(
notifications
anchor
)
;
}
_swapBrowserNotifications
:
function
PopupNotifications_swapBrowserNoficications
(
ourBrowser
otherBrowser
)
{
let
ourNotifications
=
this
.
_getNotificationsForBrowser
(
ourBrowser
)
;
let
other
=
otherBrowser
.
ownerDocument
.
defaultView
.
PopupNotifications
;
if
(
!
other
)
{
if
(
ourNotifications
.
length
>
0
)
Cu
.
reportError
(
"
unable
to
swap
notifications
:
otherBrowser
doesn
'
t
support
notifications
"
)
;
return
;
}
let
otherNotifications
=
other
.
_getNotificationsForBrowser
(
otherBrowser
)
;
if
(
ourNotifications
.
length
<
1
&
&
otherNotifications
.
length
<
1
)
{
return
;
}
otherNotifications
=
otherNotifications
.
filter
(
n
=
>
{
if
(
this
.
_fireCallback
(
n
NOTIFICATION_EVENT_SWAPPING
ourBrowser
)
)
{
n
.
browser
=
ourBrowser
;
n
.
owner
=
this
;
return
true
;
}
other
.
_fireCallback
(
n
NOTIFICATION_EVENT_REMOVED
)
;
return
false
;
}
)
;
ourNotifications
=
ourNotifications
.
filter
(
n
=
>
{
if
(
this
.
_fireCallback
(
n
NOTIFICATION_EVENT_SWAPPING
otherBrowser
)
)
{
n
.
browser
=
otherBrowser
;
n
.
owner
=
other
;
return
true
;
}
this
.
_fireCallback
(
n
NOTIFICATION_EVENT_REMOVED
)
;
return
false
;
}
)
;
this
.
_setNotificationsForBrowser
(
otherBrowser
ourNotifications
)
;
other
.
_setNotificationsForBrowser
(
ourBrowser
otherNotifications
)
;
if
(
otherNotifications
.
length
>
0
)
this
.
_update
(
otherNotifications
)
;
if
(
ourNotifications
.
length
>
0
)
other
.
_update
(
ourNotifications
)
;
}
_fireCallback
:
function
PopupNotifications_fireCallback
(
n
event
.
.
.
args
)
{
try
{
if
(
n
.
options
.
eventCallback
)
return
n
.
options
.
eventCallback
.
call
(
n
event
.
.
.
args
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
}
return
undefined
;
}
_onPopupHidden
:
function
PopupNotifications_onPopupHidden
(
event
)
{
if
(
event
.
target
!
=
this
.
panel
|
|
this
.
_ignoreDismissal
)
{
if
(
this
.
_ignoreDismissal
)
{
this
.
_ignoreDismissal
.
resolve
(
)
;
this
.
_ignoreDismissal
=
null
;
}
return
;
}
this
.
panel
.
setAttribute
(
"
noautofocus
"
"
true
"
)
;
this
.
_dismissOrRemoveCurrentNotifications
(
)
;
this
.
_clearPanel
(
)
;
this
.
_update
(
)
;
}
_dismissOrRemoveCurrentNotifications
:
function
(
)
{
let
browser
=
this
.
panel
.
firstChild
&
&
this
.
panel
.
firstChild
.
notification
.
browser
;
if
(
!
browser
)
return
;
let
notifications
=
this
.
_getNotificationsForBrowser
(
browser
)
;
Array
.
forEach
(
this
.
panel
.
childNodes
function
(
nEl
)
{
let
notificationObj
=
nEl
.
notification
;
if
(
notifications
.
indexOf
(
notificationObj
)
=
=
-
1
)
return
;
let
timeSinceShown
=
this
.
window
.
performance
.
now
(
)
-
notificationObj
.
timeShown
;
if
(
!
notificationObj
.
wasDismissed
&
&
!
notificationObj
.
recordedTelemetryMainAction
)
{
notificationObj
.
_recordTelemetry
(
"
POPUP_NOTIFICATION_DISMISSAL_MS
"
timeSinceShown
)
;
}
notificationObj
.
_recordTelemetryStat
(
this
.
nextDismissReason
)
;
if
(
notificationObj
.
options
.
removeOnDismissal
)
{
this
.
_remove
(
notificationObj
)
;
}
else
{
notificationObj
.
dismissed
=
true
;
this
.
_fireCallback
(
notificationObj
NOTIFICATION_EVENT_DISMISSED
)
;
}
}
this
)
;
}
_onButtonEvent
(
event
type
)
{
let
notificationEl
=
getNotificationFromElement
(
event
.
originalTarget
)
;
if
(
!
notificationEl
)
throw
"
PopupNotifications
.
_onButtonEvent
:
couldn
'
t
find
notification
element
"
;
if
(
!
notificationEl
.
notification
)
throw
"
PopupNotifications
.
_onButtonEvent
:
couldn
'
t
find
notification
"
;
let
notification
=
notificationEl
.
notification
;
if
(
type
=
=
"
buttonpopupshown
"
)
{
notification
.
_recordTelemetryStat
(
TELEMETRY_STAT_OPEN_SUBMENU
)
;
return
;
}
if
(
type
=
=
"
learnmoreclick
"
)
{
notification
.
_recordTelemetryStat
(
TELEMETRY_STAT_LEARN_MORE
)
;
return
;
}
let
timeSinceCreated
=
this
.
window
.
performance
.
now
(
)
-
notification
.
timeCreated
;
if
(
!
notification
.
recordedTelemetryMainAction
)
{
notification
.
recordedTelemetryMainAction
=
true
;
notification
.
_recordTelemetry
(
"
POPUP_NOTIFICATION_MAIN_ACTION_MS
"
timeSinceCreated
)
;
}
let
timeSinceShown
=
this
.
window
.
performance
.
now
(
)
-
notification
.
timeShown
;
if
(
timeSinceShown
<
this
.
buttonDelay
)
{
Services
.
console
.
logStringMessage
(
"
PopupNotifications
.
_onButtonEvent
:
"
+
"
Button
click
happened
before
the
security
delay
:
"
+
timeSinceShown
+
"
ms
"
)
;
return
;
}
notification
.
_recordTelemetryStat
(
TELEMETRY_STAT_ACTION_1
)
;
try
{
notification
.
mainAction
.
callback
.
call
(
undefined
{
checkboxChecked
:
notificationEl
.
checkbox
.
checked
}
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
}
if
(
notification
.
mainAction
.
dismiss
)
{
this
.
_dismiss
(
)
;
return
;
}
this
.
_remove
(
notification
)
;
this
.
_update
(
)
;
}
_onMenuCommand
:
function
PopupNotifications_onMenuCommand
(
event
)
{
let
target
=
event
.
originalTarget
;
if
(
!
target
.
action
|
|
!
target
.
notification
)
throw
"
menucommand
target
has
no
associated
action
/
notification
"
;
let
notificationEl
=
target
.
parentElement
;
event
.
stopPropagation
(
)
;
target
.
notification
.
_recordTelemetryStat
(
target
.
action
.
telemetryStatId
)
;
try
{
target
.
action
.
callback
.
call
(
undefined
{
checkboxChecked
:
notificationEl
.
checkbox
.
checked
}
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
}
if
(
target
.
action
.
dismiss
)
{
this
.
_dismiss
(
)
;
return
;
}
this
.
_remove
(
target
.
notification
)
;
this
.
_update
(
)
;
}
_notify
:
function
PopupNotifications_notify
(
topic
)
{
Services
.
obs
.
notifyObservers
(
null
"
PopupNotifications
-
"
+
topic
"
"
)
;
}
}
;
