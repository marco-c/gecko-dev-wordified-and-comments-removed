"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ActorManagerParent
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
DefaultMap
}
=
ExtensionUtils
;
let
ACTORS
=
{
AudioPlayback
:
{
child
:
{
module
:
"
resource
:
/
/
gre
/
actors
/
AudioPlaybackChild
.
jsm
"
messages
:
[
"
AudioPlayback
"
]
observers
:
[
"
audio
-
playback
"
]
}
}
DateTimePicker
:
{
child
:
{
module
:
"
resource
:
/
/
gre
/
actors
/
DateTimePickerChild
.
jsm
"
events
:
{
"
MozOpenDateTimePicker
"
:
{
}
}
}
}
FindBar
:
{
child
:
{
module
:
"
resource
:
/
/
gre
/
actors
/
FindBarChild
.
jsm
"
events
:
{
"
keypress
"
:
{
mozSystemGroup
:
true
}
}
}
}
PopupBlocking
:
{
child
:
{
module
:
"
resource
:
/
/
gre
/
actors
/
PopupBlockingChild
.
jsm
"
events
:
{
"
DOMPopupBlocked
"
:
{
capture
:
true
}
}
}
}
Printing
:
{
child
:
{
module
:
"
resource
:
/
/
gre
/
actors
/
PrintingChild
.
jsm
"
events
:
{
"
PrintingError
"
:
{
capture
:
true
}
"
printPreviewUpdate
"
:
{
capture
:
true
}
}
messages
:
[
"
Printing
:
Preview
:
Enter
"
"
Printing
:
Preview
:
Exit
"
"
Printing
:
Preview
:
Navigate
"
"
Printing
:
Preview
:
ParseDocument
"
"
Printing
:
Print
"
]
}
}
PurgeSessionHistory
:
{
child
:
{
module
:
"
resource
:
/
/
gre
/
actors
/
PurgeSessionHistoryChild
.
jsm
"
messages
:
[
"
Browser
:
PurgeSessionHistory
"
]
}
}
Select
:
{
child
:
{
module
:
"
resource
:
/
/
gre
/
actors
/
SelectChild
.
jsm
"
events
:
{
"
mozshowdropdown
"
:
{
}
"
mozshowdropdown
-
sourcetouch
"
:
{
}
}
}
}
SelectionSource
:
{
child
:
{
module
:
"
resource
:
/
/
gre
/
actors
/
SelectionSourceChild
.
jsm
"
messages
:
[
"
ViewSource
:
GetSelection
"
]
}
}
Thumbnails
:
{
child
:
{
module
:
"
resource
:
/
/
gre
/
actors
/
ThumbnailsChild
.
jsm
"
messages
:
[
"
Browser
:
Thumbnail
:
Request
"
"
Browser
:
Thumbnail
:
CheckState
"
"
Browser
:
Thumbnail
:
GetOriginalURL
"
]
}
}
UnselectedTabHover
:
{
child
:
{
module
:
"
resource
:
/
/
gre
/
actors
/
UnselectedTabHoverChild
.
jsm
"
events
:
{
"
UnselectedTabHover
:
Enable
"
:
{
}
"
UnselectedTabHover
:
Disable
"
:
{
}
}
messages
:
[
"
Browser
:
UnselectedTabHover
"
]
}
}
WebChannel
:
{
child
:
{
module
:
"
resource
:
/
/
gre
/
actors
/
WebChannelChild
.
jsm
"
events
:
{
"
WebChannelMessageToChrome
"
:
{
capture
:
true
wantUntrusted
:
true
}
}
messages
:
[
"
WebChannelMessageToContent
"
]
}
}
Zoom
:
{
child
:
{
module
:
"
resource
:
/
/
gre
/
actors
/
ZoomChild
.
jsm
"
events
:
{
"
FullZoomChange
"
:
{
}
"
TextZoomChange
"
:
{
}
"
ZoomChangeUsingMouseWheel
"
:
{
}
}
messages
:
[
"
FullZoom
"
"
TextZoom
"
]
}
}
}
;
class
ActorSet
{
constructor
(
group
actorSide
)
{
this
.
group
=
group
;
this
.
actorSide
=
actorSide
;
this
.
actors
=
new
Map
(
)
;
this
.
events
=
[
]
;
this
.
messages
=
new
DefaultMap
(
(
)
=
>
[
]
)
;
this
.
observers
=
new
DefaultMap
(
(
)
=
>
[
]
)
;
}
addActor
(
actorName
actor
)
{
actorName
+
=
this
.
actorSide
;
this
.
actors
.
set
(
actorName
{
module
:
actor
.
module
}
)
;
if
(
actor
.
events
)
{
for
(
let
[
event
options
]
of
Object
.
entries
(
actor
.
events
)
)
{
this
.
events
.
push
(
{
actor
:
actorName
event
options
}
)
;
}
}
for
(
let
msg
of
actor
.
messages
|
|
[
]
)
{
this
.
messages
.
get
(
msg
)
.
push
(
actorName
)
;
}
for
(
let
topic
of
actor
.
observers
|
|
[
]
)
{
this
.
observers
.
get
(
topic
)
.
push
(
actorName
)
;
}
}
}
const
{
sharedData
}
=
Services
.
ppmm
;
var
ActorManagerParent
=
{
childGroups
:
new
DefaultMap
(
group
=
>
new
ActorSet
(
group
"
Child
"
)
)
parentGroups
:
new
DefaultMap
(
group
=
>
new
ActorSet
(
group
"
Parent
"
)
)
singletons
:
new
DefaultMap
(
(
)
=
>
new
ActorSet
(
null
"
Child
"
)
)
addActors
(
actors
)
{
for
(
let
[
actorName
actor
]
of
Object
.
entries
(
actors
)
)
{
let
{
child
}
=
actor
;
{
let
actorSet
;
if
(
child
.
matches
)
{
actorSet
=
this
.
singletons
.
get
(
{
matches
:
child
.
matches
allFrames
:
child
.
allFrames
matchAboutBlank
:
child
.
matchAboutBlank
}
)
;
}
else
{
actorSet
=
this
.
childGroups
.
get
(
child
.
group
|
|
null
)
;
}
actorSet
.
addActor
(
actorName
child
)
;
}
if
(
actor
.
parent
)
{
let
{
parent
}
=
actor
;
this
.
parentGroups
.
get
(
parent
.
group
|
|
null
)
.
addActor
(
actorName
parent
)
;
}
}
}
flush
(
)
{
for
(
let
[
name
data
]
of
this
.
childGroups
)
{
sharedData
.
set
(
ChildActors
:
{
name
|
|
"
"
}
data
)
;
}
sharedData
.
set
(
"
ChildSingletonActors
"
this
.
singletons
)
;
}
}
;
ActorManagerParent
.
addActors
(
ACTORS
)
;
