"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
JSONFile
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AsyncShutdown
"
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gTextDecoder
"
function
(
)
{
return
new
TextDecoder
(
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gTextEncoder
"
function
(
)
{
return
new
TextEncoder
(
)
;
}
)
;
const
FileInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
"
nsIFileInputStream
"
"
init
"
)
;
const
kSaveDelayMs
=
1500
;
function
JSONFile
(
config
)
{
this
.
path
=
config
.
path
;
if
(
typeof
config
.
dataPostProcessor
=
=
=
"
function
"
)
{
this
.
_dataPostProcessor
=
config
.
dataPostProcessor
;
}
if
(
config
.
saveDelayMs
=
=
=
undefined
)
{
config
.
saveDelayMs
=
kSaveDelayMs
;
}
this
.
_saver
=
new
DeferredTask
(
(
)
=
>
this
.
_save
(
)
config
.
saveDelayMs
)
;
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
JSON
store
:
writing
data
"
(
)
=
>
this
.
_saver
.
finalize
(
)
)
;
}
JSONFile
.
prototype
=
{
path
:
"
"
dataReady
:
false
_saver
:
null
_data
:
null
get
data
(
)
{
if
(
!
this
.
dataReady
)
{
throw
new
Error
(
"
Data
is
not
ready
.
"
)
;
}
return
this
.
_data
;
}
load
:
Task
.
async
(
function
*
(
)
{
let
data
=
{
}
;
try
{
let
bytes
=
yield
OS
.
File
.
read
(
this
.
path
)
;
if
(
this
.
dataReady
)
{
return
;
}
data
=
JSON
.
parse
(
gTextDecoder
.
decode
(
bytes
)
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
OS
.
File
.
Error
&
&
ex
.
becauseNoSuchFile
)
)
{
Cu
.
reportError
(
ex
)
;
try
{
let
openInfo
=
yield
OS
.
File
.
openUnique
(
this
.
path
+
"
.
corrupt
"
{
humanReadable
:
true
}
)
;
yield
openInfo
.
file
.
close
(
)
;
yield
OS
.
File
.
move
(
this
.
path
openInfo
.
path
)
;
}
catch
(
e2
)
{
Cu
.
reportError
(
e2
)
;
}
}
if
(
this
.
dataReady
)
{
return
;
}
}
this
.
_processLoadedData
(
data
)
;
}
)
ensureDataReady
(
)
{
if
(
this
.
dataReady
)
{
return
;
}
let
data
=
{
}
;
try
{
let
inputStream
=
new
FileInputStream
(
new
FileUtils
.
File
(
this
.
path
)
FileUtils
.
MODE_RDONLY
FileUtils
.
PERMS_FILE
0
)
;
try
{
let
json
=
Cc
[
"
mozilla
.
org
/
dom
/
json
;
1
"
]
.
createInstance
(
Ci
.
nsIJSON
)
;
data
=
json
.
decodeFromStream
(
inputStream
inputStream
.
available
(
)
)
;
}
finally
{
inputStream
.
close
(
)
;
}
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Components
.
Exception
&
&
ex
.
result
=
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
)
{
Cu
.
reportError
(
ex
)
;
try
{
let
originalFile
=
new
FileUtils
.
File
(
this
.
path
)
;
let
backupFile
=
originalFile
.
clone
(
)
;
backupFile
.
leafName
+
=
"
.
corrupt
"
;
backupFile
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
FileUtils
.
PERMS_FILE
)
;
backupFile
.
remove
(
false
)
;
originalFile
.
moveTo
(
backupFile
.
parent
backupFile
.
leafName
)
;
}
catch
(
e2
)
{
Cu
.
reportError
(
e2
)
;
}
}
}
this
.
_processLoadedData
(
data
)
;
}
saveSoon
(
)
{
return
this
.
_saver
.
arm
(
)
;
}
_save
:
Task
.
async
(
function
*
(
)
{
let
bytes
=
gTextEncoder
.
encode
(
JSON
.
stringify
(
this
.
_data
)
)
;
yield
OS
.
File
.
writeAtomic
(
this
.
path
bytes
{
tmpPath
:
this
.
path
+
"
.
tmp
"
}
)
;
}
)
_processLoadedData
(
data
)
{
this
.
_data
=
this
.
_dataPostProcessor
?
this
.
_dataPostProcessor
(
data
)
:
data
;
this
.
dataReady
=
true
;
}
}
;
