"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
SelectParentHelper
"
]
;
const
{
utils
:
Cu
}
=
Components
;
const
{
AppConstants
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
{
}
)
;
const
{
Services
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
;
const
MAX_ROWS
=
20
;
const
SEARCH_MINIMUM_ELEMENTS
=
40
;
var
currentBrowser
=
null
;
var
currentMenulist
=
null
;
var
currentZoom
=
1
;
var
closedWithEnter
=
false
;
var
selectRect
;
var
customStylingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
dom
.
forms
.
select
.
customstyling
"
)
;
var
usedSelectBackgroundColor
;
this
.
SelectParentHelper
=
{
populate
(
menulist
items
selectedIndex
zoom
uaBackgroundColor
uaColor
uaSelectBackgroundColor
uaSelectColor
selectBackgroundColor
selectColor
)
{
menulist
.
menupopup
.
textContent
=
"
"
;
let
stylesheet
=
menulist
.
querySelector
(
"
#
ContentSelectDropdownScopedStylesheet
"
)
;
if
(
stylesheet
)
{
stylesheet
.
remove
(
)
;
}
let
doc
=
menulist
.
ownerDocument
;
let
sheet
;
if
(
customStylingEnabled
)
{
stylesheet
=
doc
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
style
"
)
;
stylesheet
.
setAttribute
(
"
id
"
"
ContentSelectDropdownScopedStylesheet
"
)
;
stylesheet
.
scoped
=
true
;
stylesheet
.
hidden
=
true
;
stylesheet
=
menulist
.
appendChild
(
stylesheet
)
;
sheet
=
stylesheet
.
sheet
;
}
let
ruleBody
=
"
"
;
if
(
customStylingEnabled
&
&
selectBackgroundColor
!
=
uaSelectBackgroundColor
&
&
selectBackgroundColor
!
=
"
rgba
(
0
0
0
0
)
"
&
&
selectBackgroundColor
!
=
selectColor
)
{
ruleBody
=
background
-
color
:
{
selectBackgroundColor
}
;
;
usedSelectBackgroundColor
=
selectBackgroundColor
;
}
else
{
usedSelectBackgroundColor
=
uaSelectBackgroundColor
;
}
if
(
customStylingEnabled
&
&
selectColor
!
=
uaSelectColor
&
&
selectColor
!
=
selectBackgroundColor
&
&
(
selectBackgroundColor
!
=
"
rgba
(
0
0
0
0
)
"
|
|
selectColor
!
=
uaSelectBackgroundColor
)
)
{
ruleBody
+
=
color
:
{
selectColor
}
;
;
}
if
(
ruleBody
)
{
sheet
.
insertRule
(
menupopup
{
{
ruleBody
}
}
0
)
;
menulist
.
menupopup
.
setAttribute
(
"
customoptionstyling
"
"
true
"
)
;
}
else
{
menulist
.
menupopup
.
removeAttribute
(
"
customoptionstyling
"
)
;
}
currentZoom
=
zoom
;
currentMenulist
=
menulist
;
populateChildren
(
menulist
items
selectedIndex
zoom
uaBackgroundColor
uaColor
sheet
)
;
}
open
(
browser
menulist
rect
isOpenedViaTouch
)
{
menulist
.
hidden
=
false
;
currentBrowser
=
browser
;
closedWithEnter
=
false
;
selectRect
=
rect
;
this
.
_registerListeners
(
browser
menulist
.
menupopup
)
;
let
win
=
browser
.
ownerGlobal
;
let
menupopup
=
menulist
.
menupopup
;
let
firstItem
=
menupopup
.
firstChild
;
while
(
firstItem
&
&
firstItem
.
hidden
)
{
firstItem
=
firstItem
.
nextSibling
;
}
if
(
firstItem
)
{
let
itemHeight
=
firstItem
.
getBoundingClientRect
(
)
.
height
;
let
cs
=
win
.
getComputedStyle
(
menupopup
)
;
let
bpHeight
=
parseFloat
(
cs
.
borderTopWidth
)
+
parseFloat
(
cs
.
borderBottomWidth
)
+
parseFloat
(
cs
.
paddingTop
)
+
parseFloat
(
cs
.
paddingBottom
)
;
menupopup
.
style
.
maxHeight
=
(
itemHeight
*
MAX_ROWS
+
bpHeight
)
+
"
px
"
;
}
menupopup
.
classList
.
toggle
(
"
isOpenedViaTouch
"
isOpenedViaTouch
)
;
let
constraintRect
=
browser
.
getBoundingClientRect
(
)
;
constraintRect
=
new
win
.
DOMRect
(
constraintRect
.
left
+
win
.
mozInnerScreenX
constraintRect
.
top
+
win
.
mozInnerScreenY
constraintRect
.
width
constraintRect
.
height
)
;
menupopup
.
setConstraintRect
(
constraintRect
)
;
menupopup
.
openPopupAtScreenRect
(
AppConstants
.
platform
=
=
"
macosx
"
?
"
selection
"
:
"
after_start
"
rect
.
left
rect
.
top
rect
.
width
rect
.
height
false
false
)
;
}
hide
(
menulist
browser
)
{
if
(
currentBrowser
=
=
browser
)
{
menulist
.
menupopup
.
hidePopup
(
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
mouseup
"
:
function
inRect
(
rect
x
y
)
{
return
x
>
=
rect
.
left
&
&
x
<
=
rect
.
left
+
rect
.
width
&
&
y
>
=
rect
.
top
&
&
y
<
=
rect
.
top
+
rect
.
height
;
}
let
x
=
event
.
screenX
y
=
event
.
screenY
;
let
onAnchor
=
!
inRect
(
currentMenulist
.
menupopup
.
getOuterScreenRect
(
)
x
y
)
&
&
inRect
(
selectRect
x
y
)
&
&
currentMenulist
.
menupopup
.
state
=
=
"
open
"
;
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
MouseUp
"
{
onAnchor
}
)
;
break
;
case
"
mouseover
"
:
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
MouseOver
"
{
}
)
;
break
;
case
"
mouseout
"
:
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
MouseOut
"
{
}
)
;
break
;
case
"
keydown
"
:
if
(
event
.
keyCode
=
=
event
.
DOM_VK_RETURN
)
{
closedWithEnter
=
true
;
}
break
;
case
"
command
"
:
if
(
event
.
target
.
hasAttribute
(
"
value
"
)
)
{
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
SelectDropDownItem
"
{
value
:
event
.
target
.
value
closedWithEnter
}
)
;
}
break
;
case
"
fullscreen
"
:
if
(
currentMenulist
)
{
currentMenulist
.
menupopup
.
hidePopup
(
)
;
}
break
;
case
"
popuphidden
"
:
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
DismissedDropDown
"
{
}
)
;
let
popup
=
event
.
target
;
this
.
_unregisterListeners
(
currentBrowser
popup
)
;
popup
.
parentNode
.
hidden
=
true
;
currentBrowser
=
null
;
currentMenulist
=
null
;
currentZoom
=
1
;
break
;
}
}
receiveMessage
(
msg
)
{
if
(
msg
.
name
=
=
"
Forms
:
UpdateDropDown
"
)
{
if
(
!
currentMenulist
|
|
!
currentBrowser
)
{
return
;
}
let
options
=
msg
.
data
.
options
;
let
selectedIndex
=
msg
.
data
.
selectedIndex
;
let
uaBackgroundColor
=
msg
.
data
.
uaBackgroundColor
;
let
uaColor
=
msg
.
data
.
uaColor
;
let
selectBackgroundColor
=
msg
.
data
.
selectBackgroundColor
;
let
selectColor
=
msg
.
data
.
selectColor
;
this
.
populate
(
currentMenulist
options
selectedIndex
currentZoom
uaBackgroundColor
uaColor
selectBackgroundColor
selectColor
)
;
}
}
_registerListeners
(
browser
popup
)
{
popup
.
addEventListener
(
"
command
"
this
)
;
popup
.
addEventListener
(
"
popuphidden
"
this
)
;
popup
.
addEventListener
(
"
mouseover
"
this
)
;
popup
.
addEventListener
(
"
mouseout
"
this
)
;
browser
.
ownerGlobal
.
addEventListener
(
"
mouseup
"
this
true
)
;
browser
.
ownerGlobal
.
addEventListener
(
"
keydown
"
this
true
)
;
browser
.
ownerGlobal
.
addEventListener
(
"
fullscreen
"
this
true
)
;
browser
.
messageManager
.
addMessageListener
(
"
Forms
:
UpdateDropDown
"
this
)
;
}
_unregisterListeners
(
browser
popup
)
{
popup
.
removeEventListener
(
"
command
"
this
)
;
popup
.
removeEventListener
(
"
popuphidden
"
this
)
;
popup
.
removeEventListener
(
"
mouseover
"
this
)
;
popup
.
removeEventListener
(
"
mouseout
"
this
)
;
browser
.
ownerGlobal
.
removeEventListener
(
"
mouseup
"
this
true
)
;
browser
.
ownerGlobal
.
removeEventListener
(
"
keydown
"
this
true
)
;
browser
.
ownerGlobal
.
removeEventListener
(
"
fullscreen
"
this
true
)
;
browser
.
messageManager
.
removeMessageListener
(
"
Forms
:
UpdateDropDown
"
this
)
;
}
}
;
function
populateChildren
(
menulist
options
selectedIndex
zoom
uaBackgroundColor
uaColor
sheet
parentElement
=
null
isGroupDisabled
=
false
adjustedTextSize
=
-
1
addSearch
=
true
nthChildIndex
=
1
)
{
let
element
=
menulist
.
menupopup
;
let
win
=
element
.
ownerGlobal
;
if
(
adjustedTextSize
=
=
-
1
)
{
let
textSize
=
win
.
getComputedStyle
(
element
)
.
getPropertyValue
(
"
font
-
size
"
)
;
adjustedTextSize
=
(
zoom
*
parseFloat
(
textSize
10
)
)
+
"
px
"
;
}
for
(
let
option
of
options
)
{
let
isOptGroup
=
(
option
.
tagName
=
=
"
OPTGROUP
"
)
;
let
item
=
element
.
ownerDocument
.
createElement
(
isOptGroup
?
"
menucaption
"
:
"
menuitem
"
)
;
item
.
setAttribute
(
"
label
"
option
.
textContent
)
;
item
.
style
.
direction
=
option
.
textDirection
;
item
.
style
.
fontSize
=
adjustedTextSize
;
item
.
hidden
=
option
.
display
=
=
"
none
"
|
|
(
parentElement
&
&
parentElement
.
hidden
)
;
item
.
hiddenByContent
=
item
.
hidden
;
item
.
setAttribute
(
"
tooltiptext
"
option
.
tooltip
)
;
let
ruleBody
=
"
"
;
if
(
customStylingEnabled
&
&
option
.
backgroundColor
&
&
option
.
backgroundColor
!
=
"
rgba
(
0
0
0
0
)
"
&
&
option
.
backgroundColor
!
=
usedSelectBackgroundColor
)
{
ruleBody
=
background
-
color
:
{
option
.
backgroundColor
}
;
;
}
if
(
customStylingEnabled
&
&
option
.
color
&
&
option
.
color
!
=
uaColor
)
{
ruleBody
+
=
color
:
{
option
.
color
}
;
;
}
if
(
ruleBody
)
{
sheet
.
insertRule
(
{
item
.
localName
}
:
nth
-
child
(
{
nthChildIndex
}
)
:
not
(
[
_moz
-
menuactive
=
"
true
"
]
)
{
{
ruleBody
}
}
0
)
;
item
.
setAttribute
(
"
customoptionstyling
"
"
true
"
)
;
}
else
{
item
.
removeAttribute
(
"
customoptionstyling
"
)
;
}
element
.
appendChild
(
item
)
;
nthChildIndex
+
+
;
let
isDisabled
=
isGroupDisabled
|
|
option
.
disabled
;
if
(
isDisabled
)
{
item
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
isOptGroup
)
{
nthChildIndex
=
populateChildren
(
menulist
option
.
children
selectedIndex
zoom
uaBackgroundColor
uaColor
sheet
item
isDisabled
adjustedTextSize
false
)
;
}
else
{
if
(
option
.
index
=
=
selectedIndex
)
{
menulist
.
selectedItem
=
item
;
menulist
.
menuBoxObject
.
activeChild
=
item
;
}
item
.
setAttribute
(
"
value
"
option
.
index
)
;
if
(
parentElement
)
{
item
.
classList
.
add
(
"
contentSelectDropdown
-
ingroup
"
)
}
}
}
if
(
Services
.
prefs
.
getBoolPref
(
"
dom
.
forms
.
selectSearch
"
)
&
&
addSearch
&
&
element
.
childElementCount
>
SEARCH_MINIMUM_ELEMENTS
)
{
let
searchbox
=
element
.
ownerDocument
.
createElement
(
"
textbox
"
)
;
searchbox
.
setAttribute
(
"
type
"
"
search
"
)
;
searchbox
.
addEventListener
(
"
input
"
onSearchInput
)
;
searchbox
.
addEventListener
(
"
focus
"
onSearchFocus
)
;
searchbox
.
addEventListener
(
"
blur
"
onSearchBlur
)
;
searchbox
.
addEventListener
(
"
keydown
"
function
(
event
)
{
if
(
event
.
defaultPrevented
)
{
return
;
}
switch
(
event
.
key
)
{
case
"
Escape
"
:
searchbox
.
parentElement
.
hidePopup
(
)
;
break
;
case
"
ArrowDown
"
:
case
"
Enter
"
:
case
"
Tab
"
:
searchbox
.
blur
(
)
;
if
(
searchbox
.
nextSibling
.
localName
=
=
"
menuitem
"
&
&
!
searchbox
.
nextSibling
.
hidden
)
{
menulist
.
menuBoxObject
.
activeChild
=
searchbox
.
nextSibling
;
}
else
{
var
currentOption
=
searchbox
.
nextSibling
;
while
(
currentOption
&
&
(
currentOption
.
localName
!
=
"
menuitem
"
|
|
currentOption
.
hidden
)
)
{
currentOption
=
currentOption
.
nextSibling
;
}
if
(
currentOption
)
{
menulist
.
menuBoxObject
.
activeChild
=
currentOption
;
}
else
{
searchbox
.
focus
(
)
;
}
}
break
;
default
:
return
;
}
event
.
preventDefault
(
)
;
}
true
)
;
element
.
insertBefore
(
searchbox
element
.
childNodes
[
0
]
)
;
}
return
nthChildIndex
;
}
function
onSearchInput
(
)
{
let
searchObj
=
this
;
let
input
=
searchObj
.
value
.
toLowerCase
(
)
;
let
menupopup
=
searchObj
.
parentElement
;
let
menuItems
=
menupopup
.
querySelectorAll
(
"
menuitem
menucaption
"
)
;
let
allHidden
=
true
;
let
prevCaption
=
null
;
for
(
let
currentItem
of
menuItems
)
{
if
(
!
currentItem
.
hiddenByContent
)
{
let
itemLabel
=
currentItem
.
getAttribute
(
"
label
"
)
.
toLowerCase
(
)
;
let
itemTooltip
=
currentItem
.
getAttribute
(
"
title
"
)
.
toLowerCase
(
)
;
if
(
!
input
)
{
currentItem
.
hidden
=
false
;
}
else
if
(
currentItem
.
localName
=
=
"
menucaption
"
)
{
if
(
prevCaption
!
=
null
)
{
prevCaption
.
hidden
=
allHidden
;
}
prevCaption
=
currentItem
;
allHidden
=
true
;
}
else
{
if
(
!
currentItem
.
classList
.
contains
(
"
contentSelectDropdown
-
ingroup
"
)
&
&
currentItem
.
previousSibling
.
classList
.
contains
(
"
contentSelectDropdown
-
ingroup
"
)
)
{
if
(
prevCaption
!
=
null
)
{
prevCaption
.
hidden
=
allHidden
;
}
prevCaption
=
null
;
allHidden
=
true
;
}
if
(
itemLabel
.
includes
(
input
)
|
|
itemTooltip
.
includes
(
input
)
)
{
currentItem
.
hidden
=
false
;
allHidden
=
false
;
}
else
{
currentItem
.
hidden
=
true
;
}
}
if
(
prevCaption
!
=
null
)
{
prevCaption
.
hidden
=
allHidden
;
}
}
}
}
function
onSearchFocus
(
)
{
let
searchObj
=
this
;
let
menupopup
=
searchObj
.
parentElement
;
menupopup
.
parentElement
.
menuBoxObject
.
activeChild
=
null
;
menupopup
.
setAttribute
(
"
ignorekeys
"
"
true
"
)
;
}
function
onSearchBlur
(
)
{
let
searchObj
=
this
;
let
menupopup
=
searchObj
.
parentElement
;
menupopup
.
setAttribute
(
"
ignorekeys
"
"
false
"
)
;
}
