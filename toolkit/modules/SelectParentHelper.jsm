"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
SelectParentHelper
"
]
;
const
MAX_ROWS
=
20
;
const
AUTOSCROLL_INTERVAL
=
25
;
var
currentBrowser
=
null
;
var
currentMenulist
=
null
;
var
currentZoom
=
1
;
var
closedWithEnter
=
false
;
this
.
SelectParentHelper
=
{
draggedOverPopup
:
false
scrollTimer
:
0
populate
:
function
(
menulist
items
selectedIndex
zoom
)
{
menulist
.
menupopup
.
textContent
=
"
"
;
currentZoom
=
zoom
;
currentMenulist
=
menulist
;
populateChildren
(
menulist
items
selectedIndex
zoom
)
;
}
open
:
function
(
browser
menulist
rect
isOpenedViaTouch
)
{
menulist
.
hidden
=
false
;
currentBrowser
=
browser
;
closedWithEnter
=
false
;
this
.
_registerListeners
(
browser
menulist
.
menupopup
)
;
let
win
=
browser
.
ownerDocument
.
defaultView
;
let
menupopup
=
menulist
.
menupopup
;
let
firstItem
=
menupopup
.
firstChild
;
while
(
firstItem
&
&
firstItem
.
hidden
)
{
firstItem
=
firstItem
.
nextSibling
;
}
if
(
firstItem
)
{
let
itemHeight
=
firstItem
.
getBoundingClientRect
(
)
.
height
;
let
cs
=
win
.
getComputedStyle
(
menupopup
)
;
let
bpHeight
=
parseFloat
(
cs
.
borderTopWidth
)
+
parseFloat
(
cs
.
borderBottomWidth
)
+
parseFloat
(
cs
.
paddingTop
)
+
parseFloat
(
cs
.
paddingBottom
)
;
menupopup
.
style
.
maxHeight
=
(
itemHeight
*
MAX_ROWS
+
bpHeight
)
+
"
px
"
;
}
menupopup
.
classList
.
toggle
(
"
isOpenedViaTouch
"
isOpenedViaTouch
)
;
let
constraintRect
=
browser
.
getBoundingClientRect
(
)
;
constraintRect
=
new
win
.
DOMRect
(
constraintRect
.
left
+
win
.
mozInnerScreenX
constraintRect
.
top
+
win
.
mozInnerScreenY
constraintRect
.
width
constraintRect
.
height
)
;
menupopup
.
setConstraintRect
(
constraintRect
)
;
menupopup
.
openPopupAtScreenRect
(
"
after_start
"
rect
.
left
rect
.
top
rect
.
width
rect
.
height
false
false
)
;
menupopup
.
setCaptureAlways
(
)
;
this
.
draggedOverPopup
=
false
;
menupopup
.
addEventListener
(
"
mousemove
"
this
)
;
}
hide
:
function
(
menulist
browser
)
{
if
(
currentBrowser
=
=
browser
)
{
menulist
.
menupopup
.
hidePopup
(
)
;
}
}
clearScrollTimer
:
function
(
)
{
if
(
this
.
scrollTimer
)
{
let
win
=
currentBrowser
.
ownerDocument
.
defaultView
;
win
.
clearInterval
(
this
.
scrollTimer
)
;
this
.
scrollTimer
=
0
;
}
}
handleEvent
:
function
(
event
)
{
switch
(
event
.
type
)
{
case
"
mouseup
"
:
this
.
clearScrollTimer
(
)
;
currentMenulist
.
menupopup
.
removeEventListener
(
"
mousemove
"
this
)
;
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
MouseUp
"
{
}
)
;
break
;
case
"
mouseover
"
:
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
MouseOver
"
{
}
)
;
break
;
case
"
mouseout
"
:
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
MouseOut
"
{
}
)
;
break
;
case
"
mousemove
"
:
let
menupopup
=
currentMenulist
.
menupopup
;
let
popupRect
=
menupopup
.
getOuterScreenRect
(
)
;
this
.
clearScrollTimer
(
)
;
if
(
event
.
screenX
>
=
popupRect
.
left
&
&
event
.
screenX
<
=
popupRect
.
right
)
{
if
(
!
this
.
draggedOverPopup
)
{
if
(
event
.
screenY
>
popupRect
.
top
&
&
event
.
screenY
<
popupRect
.
bottom
)
{
this
.
draggedOverPopup
=
true
;
}
}
if
(
this
.
draggedOverPopup
&
&
(
event
.
screenY
<
=
popupRect
.
top
|
|
event
.
screenY
>
=
popupRect
.
bottom
)
)
{
let
scrollAmount
=
event
.
screenY
<
=
popupRect
.
top
?
-
1
:
1
;
menupopup
.
scrollBox
.
scrollByIndex
(
scrollAmount
)
;
let
win
=
currentBrowser
.
ownerDocument
.
defaultView
;
this
.
scrollTimer
=
win
.
setInterval
(
function
(
)
{
menupopup
.
scrollBox
.
scrollByIndex
(
scrollAmount
)
;
}
AUTOSCROLL_INTERVAL
)
;
}
}
break
;
case
"
keydown
"
:
if
(
event
.
keyCode
=
=
event
.
DOM_VK_RETURN
)
{
closedWithEnter
=
true
;
}
break
;
case
"
command
"
:
if
(
event
.
target
.
hasAttribute
(
"
value
"
)
)
{
let
win
=
currentBrowser
.
ownerDocument
.
defaultView
;
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
SelectDropDownItem
"
{
value
:
event
.
target
.
value
closedWithEnter
:
closedWithEnter
}
)
;
}
break
;
case
"
fullscreen
"
:
if
(
currentMenulist
)
{
currentMenulist
.
menupopup
.
hidePopup
(
)
;
}
break
;
case
"
popuphidden
"
:
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
DismissedDropDown
"
{
}
)
;
let
popup
=
event
.
target
;
this
.
_unregisterListeners
(
currentBrowser
popup
)
;
this
.
clearScrollTimer
(
)
;
popup
.
releaseCapture
(
)
;
popup
.
parentNode
.
hidden
=
true
;
currentBrowser
=
null
;
currentMenulist
=
null
;
currentZoom
=
1
;
break
;
}
}
receiveMessage
(
msg
)
{
if
(
msg
.
name
=
=
"
Forms
:
UpdateDropDown
"
)
{
if
(
!
currentMenulist
|
|
!
currentBrowser
)
{
return
;
}
let
options
=
msg
.
data
.
options
;
let
selectedIndex
=
msg
.
data
.
selectedIndex
;
this
.
populate
(
currentMenulist
options
selectedIndex
currentZoom
)
;
}
}
_registerListeners
:
function
(
browser
popup
)
{
popup
.
addEventListener
(
"
command
"
this
)
;
popup
.
addEventListener
(
"
popuphidden
"
this
)
;
popup
.
addEventListener
(
"
mouseover
"
this
)
;
popup
.
addEventListener
(
"
mouseout
"
this
)
;
browser
.
ownerDocument
.
defaultView
.
addEventListener
(
"
mouseup
"
this
true
)
;
browser
.
ownerDocument
.
defaultView
.
addEventListener
(
"
keydown
"
this
true
)
;
browser
.
ownerDocument
.
defaultView
.
addEventListener
(
"
fullscreen
"
this
true
)
;
browser
.
messageManager
.
addMessageListener
(
"
Forms
:
UpdateDropDown
"
this
)
;
}
_unregisterListeners
:
function
(
browser
popup
)
{
popup
.
removeEventListener
(
"
command
"
this
)
;
popup
.
removeEventListener
(
"
popuphidden
"
this
)
;
popup
.
removeEventListener
(
"
mouseover
"
this
)
;
popup
.
removeEventListener
(
"
mouseout
"
this
)
;
browser
.
ownerDocument
.
defaultView
.
removeEventListener
(
"
mouseup
"
this
true
)
;
browser
.
ownerDocument
.
defaultView
.
removeEventListener
(
"
keydown
"
this
true
)
;
browser
.
ownerDocument
.
defaultView
.
removeEventListener
(
"
fullscreen
"
this
true
)
;
browser
.
messageManager
.
removeMessageListener
(
"
Forms
:
UpdateDropDown
"
this
)
;
}
}
;
function
populateChildren
(
menulist
options
selectedIndex
zoom
parentElement
=
null
isGroupDisabled
=
false
adjustedTextSize
=
-
1
)
{
let
element
=
menulist
.
menupopup
;
if
(
adjustedTextSize
=
=
-
1
)
{
let
win
=
element
.
ownerDocument
.
defaultView
;
let
textSize
=
win
.
getComputedStyle
(
element
)
.
getPropertyValue
(
"
font
-
size
"
)
;
adjustedTextSize
=
(
zoom
*
parseFloat
(
textSize
10
)
)
+
"
px
"
;
}
for
(
let
option
of
options
)
{
let
isOptGroup
=
(
option
.
tagName
=
=
'
OPTGROUP
'
)
;
let
item
=
element
.
ownerDocument
.
createElement
(
isOptGroup
?
"
menucaption
"
:
"
menuitem
"
)
;
item
.
setAttribute
(
"
label
"
option
.
textContent
)
;
item
.
style
.
direction
=
option
.
textDirection
;
item
.
style
.
fontSize
=
adjustedTextSize
;
item
.
hidden
=
option
.
display
=
=
"
none
"
|
|
(
parentElement
&
&
parentElement
.
hidden
)
;
item
.
setAttribute
(
"
tooltiptext
"
option
.
tooltip
)
;
element
.
appendChild
(
item
)
;
let
isDisabled
=
isGroupDisabled
|
|
option
.
disabled
;
if
(
isDisabled
)
{
item
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
isOptGroup
)
{
populateChildren
(
menulist
option
.
children
selectedIndex
zoom
item
isDisabled
adjustedTextSize
)
;
}
else
{
if
(
option
.
index
=
=
selectedIndex
)
{
menulist
.
selectedItem
=
item
;
menulist
.
menuBoxObject
.
activeChild
=
item
;
}
item
.
setAttribute
(
"
value
"
option
.
index
)
;
if
(
parentElement
)
{
item
.
classList
.
add
(
"
contentSelectDropdown
-
ingroup
"
)
}
}
}
}
