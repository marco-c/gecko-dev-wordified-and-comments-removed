"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
SelectParentHelper
"
]
;
const
{
utils
:
Cu
}
=
Components
;
const
{
AppConstants
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
{
}
)
;
const
{
Services
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
;
const
MAX_ROWS
=
20
;
const
AUTOSCROLL_INTERVAL
=
25
;
const
SEARCH_MINIMUM_ELEMENTS
=
40
;
var
currentBrowser
=
null
;
var
currentMenulist
=
null
;
var
currentZoom
=
1
;
var
closedWithEnter
=
false
;
var
selectRect
;
this
.
SelectParentHelper
=
{
draggedOverPopup
:
false
scrollTimer
:
0
populate
(
menulist
items
selectedIndex
zoom
)
{
menulist
.
menupopup
.
textContent
=
"
"
;
currentZoom
=
zoom
;
currentMenulist
=
menulist
;
populateChildren
(
menulist
items
selectedIndex
zoom
)
;
}
open
(
browser
menulist
rect
isOpenedViaTouch
)
{
menulist
.
hidden
=
false
;
currentBrowser
=
browser
;
closedWithEnter
=
false
;
selectRect
=
rect
;
this
.
_registerListeners
(
browser
menulist
.
menupopup
)
;
let
win
=
browser
.
ownerDocument
.
defaultView
;
let
menupopup
=
menulist
.
menupopup
;
let
firstItem
=
menupopup
.
firstChild
;
while
(
firstItem
&
&
firstItem
.
hidden
)
{
firstItem
=
firstItem
.
nextSibling
;
}
if
(
firstItem
)
{
let
itemHeight
=
firstItem
.
getBoundingClientRect
(
)
.
height
;
let
cs
=
win
.
getComputedStyle
(
menupopup
)
;
let
bpHeight
=
parseFloat
(
cs
.
borderTopWidth
)
+
parseFloat
(
cs
.
borderBottomWidth
)
+
parseFloat
(
cs
.
paddingTop
)
+
parseFloat
(
cs
.
paddingBottom
)
;
menupopup
.
style
.
maxHeight
=
(
itemHeight
*
MAX_ROWS
+
bpHeight
)
+
"
px
"
;
}
menupopup
.
classList
.
toggle
(
"
isOpenedViaTouch
"
isOpenedViaTouch
)
;
let
constraintRect
=
browser
.
getBoundingClientRect
(
)
;
constraintRect
=
new
win
.
DOMRect
(
constraintRect
.
left
+
win
.
mozInnerScreenX
constraintRect
.
top
+
win
.
mozInnerScreenY
constraintRect
.
width
constraintRect
.
height
)
;
menupopup
.
setConstraintRect
(
constraintRect
)
;
menupopup
.
openPopupAtScreenRect
(
AppConstants
.
platform
=
=
"
macosx
"
?
"
selection
"
:
"
after_start
"
rect
.
left
rect
.
top
rect
.
width
rect
.
height
false
false
)
;
menupopup
.
setCaptureAlways
(
)
;
this
.
draggedOverPopup
=
false
;
menupopup
.
addEventListener
(
"
mousemove
"
this
)
;
}
hide
(
menulist
browser
)
{
if
(
currentBrowser
=
=
browser
)
{
menulist
.
menupopup
.
hidePopup
(
)
;
}
}
clearScrollTimer
(
)
{
if
(
this
.
scrollTimer
)
{
let
win
=
currentBrowser
.
ownerDocument
.
defaultView
;
win
.
clearInterval
(
this
.
scrollTimer
)
;
this
.
scrollTimer
=
0
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
mouseup
"
:
this
.
clearScrollTimer
(
)
;
currentMenulist
.
menupopup
.
removeEventListener
(
"
mousemove
"
this
)
;
function
inRect
(
rect
x
y
)
{
return
x
>
=
rect
.
left
&
&
x
<
=
rect
.
left
+
rect
.
width
&
&
y
>
=
rect
.
top
&
&
y
<
=
rect
.
top
+
rect
.
height
;
}
let
x
=
event
.
screenX
y
=
event
.
screenY
;
let
onAnchor
=
!
inRect
(
currentMenulist
.
menupopup
.
getOuterScreenRect
(
)
x
y
)
&
&
inRect
(
selectRect
x
y
)
&
&
currentMenulist
.
menupopup
.
state
=
=
"
open
"
;
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
MouseUp
"
{
onAnchor
}
)
;
break
;
case
"
mouseover
"
:
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
MouseOver
"
{
}
)
;
break
;
case
"
mouseout
"
:
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
MouseOut
"
{
}
)
;
break
;
case
"
mousemove
"
:
let
menupopup
=
currentMenulist
.
menupopup
;
this
.
clearScrollTimer
(
)
;
if
(
!
(
event
.
buttons
&
1
)
)
{
currentMenulist
.
menupopup
.
removeEventListener
(
"
mousemove
"
this
)
;
menupopup
.
releaseCapture
(
)
;
return
;
}
let
popupRect
=
menupopup
.
getOuterScreenRect
(
)
;
if
(
event
.
screenX
>
=
popupRect
.
left
&
&
event
.
screenX
<
=
popupRect
.
right
)
{
if
(
!
this
.
draggedOverPopup
)
{
if
(
event
.
screenY
>
popupRect
.
top
&
&
event
.
screenY
<
popupRect
.
bottom
)
{
this
.
draggedOverPopup
=
true
;
}
}
if
(
this
.
draggedOverPopup
&
&
(
event
.
screenY
<
=
popupRect
.
top
|
|
event
.
screenY
>
=
popupRect
.
bottom
)
)
{
let
scrollAmount
=
event
.
screenY
<
=
popupRect
.
top
?
-
1
:
1
;
menupopup
.
scrollBox
.
scrollByIndex
(
scrollAmount
)
;
let
win
=
currentBrowser
.
ownerDocument
.
defaultView
;
this
.
scrollTimer
=
win
.
setInterval
(
function
(
)
{
menupopup
.
scrollBox
.
scrollByIndex
(
scrollAmount
)
;
}
AUTOSCROLL_INTERVAL
)
;
}
}
break
;
case
"
keydown
"
:
if
(
event
.
keyCode
=
=
event
.
DOM_VK_RETURN
)
{
closedWithEnter
=
true
;
}
break
;
case
"
command
"
:
if
(
event
.
target
.
hasAttribute
(
"
value
"
)
)
{
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
SelectDropDownItem
"
{
value
:
event
.
target
.
value
closedWithEnter
}
)
;
}
break
;
case
"
fullscreen
"
:
if
(
currentMenulist
)
{
currentMenulist
.
menupopup
.
hidePopup
(
)
;
}
break
;
case
"
popuphidden
"
:
currentBrowser
.
messageManager
.
sendAsyncMessage
(
"
Forms
:
DismissedDropDown
"
{
}
)
;
let
popup
=
event
.
target
;
this
.
_unregisterListeners
(
currentBrowser
popup
)
;
this
.
clearScrollTimer
(
)
;
popup
.
releaseCapture
(
)
;
popup
.
parentNode
.
hidden
=
true
;
currentBrowser
=
null
;
currentMenulist
=
null
;
currentZoom
=
1
;
break
;
}
}
receiveMessage
(
msg
)
{
if
(
msg
.
name
=
=
"
Forms
:
UpdateDropDown
"
)
{
if
(
!
currentMenulist
|
|
!
currentBrowser
)
{
return
;
}
let
options
=
msg
.
data
.
options
;
let
selectedIndex
=
msg
.
data
.
selectedIndex
;
this
.
populate
(
currentMenulist
options
selectedIndex
currentZoom
)
;
}
}
_registerListeners
(
browser
popup
)
{
popup
.
addEventListener
(
"
command
"
this
)
;
popup
.
addEventListener
(
"
popuphidden
"
this
)
;
popup
.
addEventListener
(
"
mouseover
"
this
)
;
popup
.
addEventListener
(
"
mouseout
"
this
)
;
browser
.
ownerDocument
.
defaultView
.
addEventListener
(
"
mouseup
"
this
true
)
;
browser
.
ownerDocument
.
defaultView
.
addEventListener
(
"
keydown
"
this
true
)
;
browser
.
ownerDocument
.
defaultView
.
addEventListener
(
"
fullscreen
"
this
true
)
;
browser
.
messageManager
.
addMessageListener
(
"
Forms
:
UpdateDropDown
"
this
)
;
}
_unregisterListeners
(
browser
popup
)
{
popup
.
removeEventListener
(
"
command
"
this
)
;
popup
.
removeEventListener
(
"
popuphidden
"
this
)
;
popup
.
removeEventListener
(
"
mouseover
"
this
)
;
popup
.
removeEventListener
(
"
mouseout
"
this
)
;
browser
.
ownerDocument
.
defaultView
.
removeEventListener
(
"
mouseup
"
this
true
)
;
browser
.
ownerDocument
.
defaultView
.
removeEventListener
(
"
keydown
"
this
true
)
;
browser
.
ownerDocument
.
defaultView
.
removeEventListener
(
"
fullscreen
"
this
true
)
;
browser
.
messageManager
.
removeMessageListener
(
"
Forms
:
UpdateDropDown
"
this
)
;
}
}
;
function
populateChildren
(
menulist
options
selectedIndex
zoom
parentElement
=
null
isGroupDisabled
=
false
adjustedTextSize
=
-
1
addSearch
=
true
)
{
let
element
=
menulist
.
menupopup
;
if
(
adjustedTextSize
=
=
-
1
)
{
let
win
=
element
.
ownerDocument
.
defaultView
;
let
textSize
=
win
.
getComputedStyle
(
element
)
.
getPropertyValue
(
"
font
-
size
"
)
;
adjustedTextSize
=
(
zoom
*
parseFloat
(
textSize
10
)
)
+
"
px
"
;
}
for
(
let
option
of
options
)
{
let
isOptGroup
=
(
option
.
tagName
=
=
"
OPTGROUP
"
)
;
let
item
=
element
.
ownerDocument
.
createElement
(
isOptGroup
?
"
menucaption
"
:
"
menuitem
"
)
;
item
.
setAttribute
(
"
label
"
option
.
textContent
)
;
item
.
style
.
direction
=
option
.
textDirection
;
item
.
style
.
fontSize
=
adjustedTextSize
;
item
.
hidden
=
option
.
display
=
=
"
none
"
|
|
(
parentElement
&
&
parentElement
.
hidden
)
;
item
.
hiddenByContent
=
item
.
hidden
;
item
.
setAttribute
(
"
tooltiptext
"
option
.
tooltip
)
;
element
.
appendChild
(
item
)
;
let
isDisabled
=
isGroupDisabled
|
|
option
.
disabled
;
if
(
isDisabled
)
{
item
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
isOptGroup
)
{
populateChildren
(
menulist
option
.
children
selectedIndex
zoom
item
isDisabled
adjustedTextSize
false
)
;
}
else
{
if
(
option
.
index
=
=
selectedIndex
)
{
menulist
.
selectedItem
=
item
;
menulist
.
menuBoxObject
.
activeChild
=
item
;
}
item
.
setAttribute
(
"
value
"
option
.
index
)
;
if
(
parentElement
)
{
item
.
classList
.
add
(
"
contentSelectDropdown
-
ingroup
"
)
}
}
}
if
(
Services
.
prefs
.
getBoolPref
(
"
dom
.
forms
.
selectSearch
"
)
&
&
addSearch
&
&
element
.
childElementCount
>
SEARCH_MINIMUM_ELEMENTS
)
{
let
searchbox
=
element
.
ownerDocument
.
createElement
(
"
textbox
"
)
;
searchbox
.
setAttribute
(
"
type
"
"
search
"
)
;
searchbox
.
addEventListener
(
"
input
"
onSearchInput
)
;
searchbox
.
addEventListener
(
"
focus
"
onSearchFocus
)
;
searchbox
.
addEventListener
(
"
blur
"
onSearchBlur
)
;
searchbox
.
addEventListener
(
"
keydown
"
function
(
event
)
{
if
(
event
.
defaultPrevented
)
{
return
;
}
switch
(
event
.
key
)
{
case
"
Escape
"
:
searchbox
.
parentElement
.
hidePopup
(
)
;
break
;
case
"
ArrowDown
"
:
case
"
Enter
"
:
case
"
Tab
"
:
searchbox
.
blur
(
)
;
if
(
searchbox
.
nextSibling
.
localName
=
=
"
menuitem
"
&
&
!
searchbox
.
nextSibling
.
hidden
)
{
menulist
.
menuBoxObject
.
activeChild
=
searchbox
.
nextSibling
;
}
else
{
var
currentOption
=
searchbox
.
nextSibling
;
while
(
currentOption
&
&
(
currentOption
.
localName
!
=
"
menuitem
"
|
|
currentOption
.
hidden
)
)
{
currentOption
=
currentOption
.
nextSibling
;
}
if
(
currentOption
)
{
menulist
.
menuBoxObject
.
activeChild
=
currentOption
;
}
else
{
searchbox
.
focus
(
)
;
}
}
break
;
default
:
return
;
}
event
.
preventDefault
(
)
;
}
true
)
;
element
.
insertBefore
(
searchbox
element
.
childNodes
[
0
]
)
;
}
}
function
onSearchInput
(
)
{
let
searchObj
=
this
;
let
input
=
searchObj
.
value
.
toLowerCase
(
)
;
let
menupopup
=
searchObj
.
parentElement
;
let
menuItems
=
menupopup
.
querySelectorAll
(
"
menuitem
menucaption
"
)
;
let
allHidden
=
true
;
let
prevCaption
=
null
;
for
(
let
currentItem
of
menuItems
)
{
if
(
!
currentItem
.
hiddenByContent
)
{
let
itemLabel
=
currentItem
.
getAttribute
(
"
label
"
)
.
toLowerCase
(
)
;
let
itemTooltip
=
currentItem
.
getAttribute
(
"
title
"
)
.
toLowerCase
(
)
;
if
(
!
input
)
{
currentItem
.
hidden
=
false
;
}
else
if
(
currentItem
.
localName
=
=
"
menucaption
"
)
{
if
(
prevCaption
!
=
null
)
{
prevCaption
.
hidden
=
allHidden
;
}
prevCaption
=
currentItem
;
allHidden
=
true
;
}
else
{
if
(
!
currentItem
.
classList
.
contains
(
"
contentSelectDropdown
-
ingroup
"
)
&
&
currentItem
.
previousSibling
.
classList
.
contains
(
"
contentSelectDropdown
-
ingroup
"
)
)
{
if
(
prevCaption
!
=
null
)
{
prevCaption
.
hidden
=
allHidden
;
}
prevCaption
=
null
;
allHidden
=
true
;
}
if
(
itemLabel
.
includes
(
input
)
|
|
itemTooltip
.
includes
(
input
)
)
{
currentItem
.
hidden
=
false
;
allHidden
=
false
;
}
else
{
currentItem
.
hidden
=
true
;
}
}
if
(
prevCaption
!
=
null
)
{
prevCaption
.
hidden
=
allHidden
;
}
}
}
}
function
onSearchFocus
(
)
{
let
searchObj
=
this
;
let
menupopup
=
searchObj
.
parentElement
;
menupopup
.
parentElement
.
menuBoxObject
.
activeChild
=
null
;
menupopup
.
setAttribute
(
"
ignorekeys
"
"
true
"
)
;
}
function
onSearchBlur
(
)
{
let
searchObj
=
this
;
let
menupopup
=
searchObj
.
parentElement
;
menupopup
.
setAttribute
(
"
ignorekeys
"
"
false
"
)
;
}
