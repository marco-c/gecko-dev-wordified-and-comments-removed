"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
RemotePages
"
"
RemotePageManager
"
"
PageListener
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AsyncPrefs
"
"
resource
:
/
/
gre
/
modules
/
AsyncPrefs
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
let
RPMAccessManager
=
{
accessMap
:
{
"
about
:
privatebrowsing
"
:
{
"
getBoolPref
"
:
[
"
privacy
.
trackingprotection
.
enabled
"
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
]
"
getFormatURLPref
"
:
[
"
privacy
.
trackingprotection
.
introURL
"
"
app
.
support
.
baseURL
"
]
"
isWindowPrivate
"
:
[
"
yes
"
]
}
}
checkAllowAccess
(
aPrincipal
aFeature
aValue
)
{
if
(
!
aPrincipal
|
|
!
aPrincipal
.
URI
)
{
return
false
;
}
let
uri
=
aPrincipal
.
URI
.
asciiSpec
;
let
accessMapForURI
=
this
.
accessMap
[
uri
]
;
if
(
!
accessMapForURI
)
{
Cu
.
reportError
(
"
RPMAccessManager
does
not
allow
access
to
Feature
:
"
+
aFeature
+
"
for
:
"
+
uri
)
;
return
false
;
}
let
accessMapForFeature
=
accessMapForURI
[
aFeature
]
;
if
(
!
accessMapForFeature
)
{
Cu
.
reportError
(
"
RPMAccessManager
does
not
allow
access
to
Feature
:
"
+
aFeature
+
"
for
:
"
+
uri
)
;
return
false
;
}
if
(
accessMapForFeature
.
includes
(
aValue
)
)
{
return
true
;
}
Cu
.
reportError
(
"
RPMAccessManager
does
not
allow
access
to
Feature
:
"
+
aFeature
+
"
for
:
"
+
uri
)
;
return
false
;
}
}
;
function
MessageListener
(
)
{
this
.
listeners
=
new
Map
(
)
;
}
MessageListener
.
prototype
=
{
keys
(
)
{
return
this
.
listeners
.
keys
(
)
;
}
has
(
name
)
{
return
this
.
listeners
.
has
(
name
)
;
}
callListeners
(
message
)
{
let
listeners
=
this
.
listeners
.
get
(
message
.
name
)
;
if
(
!
listeners
)
{
return
;
}
for
(
let
listener
of
listeners
.
values
(
)
)
{
try
{
listener
(
message
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
addMessageListener
(
name
callback
)
{
if
(
!
this
.
listeners
.
has
(
name
)
)
this
.
listeners
.
set
(
name
new
Set
(
[
callback
]
)
)
;
else
this
.
listeners
.
get
(
name
)
.
add
(
callback
)
;
}
removeMessageListener
(
name
callback
)
{
if
(
!
this
.
listeners
.
has
(
name
)
)
return
;
this
.
listeners
.
get
(
name
)
.
delete
(
callback
)
;
}
}
;
var
RemotePages
=
function
(
urls
)
{
this
.
urls
=
Array
.
isArray
(
urls
)
?
urls
:
[
urls
]
;
this
.
messagePorts
=
new
Set
(
)
;
this
.
listener
=
new
MessageListener
(
)
;
this
.
destroyed
=
false
;
this
.
portCreated
=
this
.
portCreated
.
bind
(
this
)
;
this
.
portMessageReceived
=
this
.
portMessageReceived
.
bind
(
this
)
;
for
(
const
url
of
this
.
urls
)
{
RemotePageManager
.
addRemotePageListener
(
url
this
.
portCreated
)
;
}
}
;
RemotePages
.
prototype
=
{
urls
:
null
messagePorts
:
null
listener
:
null
destroyed
:
null
destroy
(
)
{
for
(
const
url
of
this
.
urls
)
{
RemotePageManager
.
removeRemotePageListener
(
url
)
;
}
for
(
let
port
of
this
.
messagePorts
.
values
(
)
)
{
this
.
removeMessagePort
(
port
)
;
}
this
.
messagePorts
=
null
;
this
.
listener
=
null
;
this
.
destroyed
=
true
;
}
portCreated
(
port
)
{
this
.
messagePorts
.
add
(
port
)
;
port
.
loaded
=
false
;
port
.
addMessageListener
(
"
RemotePage
:
Load
"
this
.
portMessageReceived
)
;
port
.
addMessageListener
(
"
RemotePage
:
Unload
"
this
.
portMessageReceived
)
;
for
(
let
name
of
this
.
listener
.
keys
(
)
)
{
this
.
registerPortListener
(
port
name
)
;
}
this
.
listener
.
callListeners
(
{
target
:
port
name
:
"
RemotePage
:
Init
"
}
)
;
}
portMessageReceived
(
message
)
{
switch
(
message
.
name
)
{
case
"
RemotePage
:
Load
"
:
message
.
target
.
loaded
=
true
;
break
;
case
"
RemotePage
:
Unload
"
:
message
.
target
.
loaded
=
false
;
this
.
removeMessagePort
(
message
.
target
)
;
break
;
}
this
.
listener
.
callListeners
(
message
)
;
}
removeMessagePort
(
port
)
{
for
(
let
name
of
this
.
listener
.
keys
(
)
)
{
port
.
removeMessageListener
(
name
this
.
portMessageReceived
)
;
}
port
.
removeMessageListener
(
"
RemotePage
:
Load
"
this
.
portMessageReceived
)
;
port
.
removeMessageListener
(
"
RemotePage
:
Unload
"
this
.
portMessageReceived
)
;
this
.
messagePorts
.
delete
(
port
)
;
}
registerPortListener
(
port
name
)
{
port
.
addMessageListener
(
name
this
.
portMessageReceived
)
;
}
sendAsyncMessage
(
name
data
=
null
)
{
for
(
let
port
of
this
.
messagePorts
.
values
(
)
)
{
try
{
port
.
sendAsyncMessage
(
name
data
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
=
Cr
.
NS_ERROR_NOT_INITIALIZED
)
Cu
.
reportError
(
e
)
;
}
}
}
addMessageListener
(
name
callback
)
{
if
(
this
.
destroyed
)
{
throw
new
Error
(
"
RemotePages
has
been
destroyed
"
)
;
}
if
(
!
this
.
listener
.
has
(
name
)
)
{
for
(
let
port
of
this
.
messagePorts
.
values
(
)
)
{
this
.
registerPortListener
(
port
name
)
;
}
}
this
.
listener
.
addMessageListener
(
name
callback
)
;
}
removeMessageListener
(
name
callback
)
{
if
(
this
.
destroyed
)
{
throw
new
Error
(
"
RemotePages
has
been
destroyed
"
)
;
}
this
.
listener
.
removeMessageListener
(
name
callback
)
;
}
portsForBrowser
(
browser
)
{
return
[
.
.
.
this
.
messagePorts
]
.
filter
(
port
=
>
port
.
browser
=
=
browser
)
;
}
}
;
function
publicMessagePort
(
port
)
{
let
properties
=
[
"
addMessageListener
"
"
removeMessageListener
"
"
sendAsyncMessage
"
"
destroy
"
]
;
let
clean
=
{
}
;
for
(
let
property
of
properties
)
{
clean
[
property
]
=
port
[
property
]
.
bind
(
port
)
;
}
Object
.
defineProperty
(
clean
"
portID
"
{
enumerable
:
true
get
(
)
{
return
port
.
portID
;
}
}
)
;
if
(
port
instanceof
ChromeMessagePort
)
{
Object
.
defineProperty
(
clean
"
browser
"
{
enumerable
:
true
get
(
)
{
return
port
.
browser
;
}
}
)
;
Object
.
defineProperty
(
clean
"
url
"
{
enumerable
:
true
get
(
)
{
return
port
.
url
;
}
}
)
;
}
return
clean
;
}
function
MessagePort
(
messageManager
portID
)
{
this
.
messageManager
=
messageManager
;
this
.
portID
=
portID
;
this
.
destroyed
=
false
;
this
.
listener
=
new
MessageListener
(
)
;
this
.
message
=
this
.
message
.
bind
(
this
)
;
this
.
messageManager
.
addMessageListener
(
"
RemotePage
:
Message
"
this
.
message
)
;
}
MessagePort
.
prototype
=
{
messageManager
:
null
portID
:
null
destroyed
:
null
listener
:
null
_browser
:
null
remotePort
:
null
swapMessageManager
(
messageManager
)
{
this
.
messageManager
.
removeMessageListener
(
"
RemotePage
:
Message
"
this
.
message
)
;
this
.
messageManager
=
messageManager
;
this
.
messageManager
.
addMessageListener
(
"
RemotePage
:
Message
"
this
.
message
)
;
}
addMessageListener
(
name
callback
)
{
if
(
this
.
destroyed
)
{
throw
new
Error
(
"
Message
port
has
been
destroyed
"
)
;
}
this
.
listener
.
addMessageListener
(
name
callback
)
;
}
removeMessageListener
(
name
callback
)
{
if
(
this
.
destroyed
)
{
throw
new
Error
(
"
Message
port
has
been
destroyed
"
)
;
}
this
.
listener
.
removeMessageListener
(
name
callback
)
;
}
sendAsyncMessage
(
name
data
=
null
)
{
if
(
this
.
destroyed
)
{
throw
new
Error
(
"
Message
port
has
been
destroyed
"
)
;
}
this
.
messageManager
.
sendAsyncMessage
(
"
RemotePage
:
Message
"
{
portID
:
this
.
portID
name
data
}
)
;
}
destroy
(
)
{
try
{
this
.
messageManager
.
removeMessageListener
(
"
RemotePage
:
Message
"
this
.
message
)
;
}
catch
(
e
)
{
}
this
.
messageManager
=
null
;
this
.
destroyed
=
true
;
this
.
portID
=
null
;
this
.
listener
=
null
;
}
getBoolPref
(
aPref
)
{
let
principal
=
this
.
window
.
document
.
nodePrincipal
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
principal
"
getBoolPref
"
aPref
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
getBoolPref
"
)
;
}
return
Services
.
prefs
.
getBoolPref
(
aPref
)
;
}
setBoolPref
(
aPref
aVal
)
{
return
new
this
.
window
.
Promise
(
function
(
resolve
)
{
AsyncPrefs
.
set
(
aPref
aVal
)
.
then
(
function
(
)
{
resolve
(
)
;
}
)
;
}
)
;
}
getFormatURLPref
(
aFormatURL
)
{
let
principal
=
this
.
window
.
document
.
nodePrincipal
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
principal
"
getFormatURLPref
"
aFormatURL
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
getFormatURLPref
"
)
;
}
return
Services
.
urlFormatter
.
formatURLPref
(
aFormatURL
)
;
}
isWindowPrivate
(
)
{
let
principal
=
this
.
window
.
document
.
nodePrincipal
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
principal
"
isWindowPrivate
"
"
yes
"
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
isWindowPrivate
"
)
;
}
return
PrivateBrowsingUtils
.
isContentWindowPrivate
(
this
.
window
)
;
}
}
;
function
ChromeMessagePort
(
browser
portID
url
)
{
MessagePort
.
call
(
this
browser
.
messageManager
portID
)
;
this
.
_browser
=
browser
;
this
.
_permanentKey
=
browser
.
permanentKey
;
this
.
_url
=
url
;
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
disconnect
"
)
;
this
.
publicPort
=
publicMessagePort
(
this
)
;
this
.
swapBrowsers
=
this
.
swapBrowsers
.
bind
(
this
)
;
this
.
_browser
.
addEventListener
(
"
SwapDocShells
"
this
.
swapBrowsers
)
;
}
ChromeMessagePort
.
prototype
=
Object
.
create
(
MessagePort
.
prototype
)
;
Object
.
defineProperty
(
ChromeMessagePort
.
prototype
"
browser
"
{
get
(
)
{
return
this
.
_browser
;
}
}
)
;
Object
.
defineProperty
(
ChromeMessagePort
.
prototype
"
url
"
{
get
(
)
{
return
this
.
_url
;
}
}
)
;
ChromeMessagePort
.
prototype
.
swapBrowsers
=
function
(
{
detail
:
newBrowser
}
)
{
if
(
this
.
_browser
.
permanentKey
!
=
this
.
_permanentKey
)
return
;
this
.
_browser
.
removeEventListener
(
"
SwapDocShells
"
this
.
swapBrowsers
)
;
this
.
_browser
=
newBrowser
;
this
.
swapMessageManager
(
newBrowser
.
messageManager
)
;
this
.
_browser
.
addEventListener
(
"
SwapDocShells
"
this
.
swapBrowsers
)
;
}
;
ChromeMessagePort
.
prototype
.
observe
=
function
(
messageManager
)
{
if
(
messageManager
!
=
this
.
messageManager
)
return
;
this
.
listener
.
callListeners
(
{
target
:
this
.
publicPort
name
:
"
RemotePage
:
Unload
"
data
:
null
}
)
;
this
.
destroy
(
)
;
}
;
ChromeMessagePort
.
prototype
.
message
=
function
(
{
data
:
messagedata
}
)
{
if
(
this
.
destroyed
|
|
(
messagedata
.
portID
!
=
this
.
portID
)
)
{
return
;
}
let
message
=
{
target
:
this
.
publicPort
name
:
messagedata
.
name
data
:
messagedata
.
data
}
;
this
.
listener
.
callListeners
(
message
)
;
if
(
messagedata
.
name
=
=
"
RemotePage
:
Unload
"
)
this
.
destroy
(
)
;
}
;
ChromeMessagePort
.
prototype
.
destroy
=
function
(
)
{
try
{
this
.
_browser
.
removeEventListener
(
"
SwapDocShells
"
this
.
swapBrowsers
)
;
}
catch
(
e
)
{
}
this
.
_browser
=
null
;
Services
.
obs
.
removeObserver
(
this
"
message
-
manager
-
disconnect
"
)
;
MessagePort
.
prototype
.
destroy
.
call
(
this
)
;
}
;
function
ChildMessagePort
(
contentFrame
window
)
{
let
portID
=
Services
.
appinfo
.
processID
+
"
:
"
+
ChildMessagePort
.
prototype
.
nextPortID
+
+
;
MessagePort
.
call
(
this
contentFrame
portID
)
;
this
.
window
=
window
;
Cu
.
exportFunction
(
this
.
sendAsyncMessage
.
bind
(
this
)
window
{
defineAs
:
"
RPMSendAsyncMessage
"
}
)
;
Cu
.
exportFunction
(
this
.
addMessageListener
.
bind
(
this
)
window
{
defineAs
:
"
RPMAddMessageListener
"
allowCallbacks
:
true
}
)
;
Cu
.
exportFunction
(
this
.
removeMessageListener
.
bind
(
this
)
window
{
defineAs
:
"
RPMRemoveMessageListener
"
allowCallbacks
:
true
}
)
;
Cu
.
exportFunction
(
this
.
getBoolPref
.
bind
(
this
)
window
{
defineAs
:
"
RPMGetBoolPref
"
}
)
;
Cu
.
exportFunction
(
this
.
setBoolPref
.
bind
(
this
)
window
{
defineAs
:
"
RPMSetBoolPref
"
}
)
;
Cu
.
exportFunction
(
this
.
getFormatURLPref
.
bind
(
this
)
window
{
defineAs
:
"
RPMGetFormatURLPref
"
}
)
;
Cu
.
exportFunction
(
this
.
isWindowPrivate
.
bind
(
this
)
window
{
defineAs
:
"
RPMIsWindowPrivate
"
}
)
;
let
loadListener
=
(
)
=
>
{
this
.
sendAsyncMessage
(
"
RemotePage
:
Load
"
)
;
window
.
removeEventListener
(
"
load
"
loadListener
)
;
}
;
window
.
addEventListener
(
"
load
"
loadListener
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
try
{
this
.
sendAsyncMessage
(
"
RemotePage
:
Unload
"
)
;
}
catch
(
e
)
{
}
this
.
destroy
(
)
;
}
)
;
this
.
messageManager
.
sendAsyncMessage
(
"
RemotePage
:
InitPort
"
{
portID
url
:
window
.
document
.
documentURI
.
replace
(
/
[
\
#
|
\
?
]
.
*
/
"
"
)
}
)
;
}
ChildMessagePort
.
prototype
=
Object
.
create
(
MessagePort
.
prototype
)
;
ChildMessagePort
.
prototype
.
nextPortID
=
0
;
ChildMessagePort
.
prototype
.
message
=
function
(
{
data
:
messagedata
}
)
{
if
(
this
.
destroyed
|
|
(
messagedata
.
portID
!
=
this
.
portID
)
)
{
return
;
}
let
message
=
{
name
:
messagedata
.
name
data
:
messagedata
.
data
}
;
this
.
listener
.
callListeners
(
Cu
.
cloneInto
(
message
this
.
window
)
)
;
}
;
ChildMessagePort
.
prototype
.
destroy
=
function
(
)
{
this
.
window
=
null
;
MessagePort
.
prototype
.
destroy
.
call
(
this
)
;
}
;
var
RemotePageManagerInternal
=
{
pages
:
new
Map
(
)
init
(
)
{
Services
.
mm
.
addMessageListener
(
"
RemotePage
:
InitPort
"
this
.
initPort
.
bind
(
this
)
)
;
this
.
updateProcessUrls
(
)
;
}
updateProcessUrls
(
)
{
Services
.
ppmm
.
initialProcessData
[
"
RemotePageManager
:
urls
"
]
=
Array
.
from
(
this
.
pages
.
keys
(
)
)
;
}
addRemotePageListener
(
url
callback
)
{
if
(
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
)
throw
new
Error
(
"
RemotePageManager
can
only
be
used
in
the
main
process
.
"
)
;
if
(
this
.
pages
.
has
(
url
)
)
{
throw
new
Error
(
"
Remote
page
already
registered
:
"
+
url
)
;
}
this
.
pages
.
set
(
url
callback
)
;
this
.
updateProcessUrls
(
)
;
Services
.
ppmm
.
broadcastAsyncMessage
(
"
RemotePage
:
Register
"
{
urls
:
[
url
]
}
)
;
}
removeRemotePageListener
(
url
)
{
if
(
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
)
throw
new
Error
(
"
RemotePageManager
can
only
be
used
in
the
main
process
.
"
)
;
if
(
!
this
.
pages
.
has
(
url
)
)
{
throw
new
Error
(
"
Remote
page
is
not
registered
:
"
+
url
)
;
}
Services
.
ppmm
.
broadcastAsyncMessage
(
"
RemotePage
:
Unregister
"
{
urls
:
[
url
]
}
)
;
this
.
pages
.
delete
(
url
)
;
this
.
updateProcessUrls
(
)
;
}
initPort
(
{
target
:
browser
data
:
{
url
portID
}
}
)
{
let
callback
=
this
.
pages
.
get
(
url
)
;
if
(
!
callback
)
{
Cu
.
reportError
(
"
Unexpected
remote
page
load
:
"
+
url
)
;
return
;
}
let
port
=
new
ChromeMessagePort
(
browser
portID
url
)
;
callback
(
port
.
publicPort
)
;
}
}
;
if
(
Services
.
appinfo
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
)
RemotePageManagerInternal
.
init
(
)
;
var
RemotePageManager
=
{
addRemotePageListener
:
RemotePageManagerInternal
.
addRemotePageListener
.
bind
(
RemotePageManagerInternal
)
removeRemotePageListener
:
RemotePageManagerInternal
.
removeRemotePageListener
.
bind
(
RemotePageManagerInternal
)
}
;
var
registeredURLs
=
new
Set
(
Services
.
cpmm
.
initialProcessData
[
"
RemotePageManager
:
urls
"
]
)
;
var
observer
=
(
window
)
=
>
{
let
url
=
window
.
document
.
documentURI
.
replace
(
/
[
\
#
|
\
?
]
.
*
/
"
"
)
;
if
(
!
registeredURLs
.
has
(
url
)
)
return
;
let
messageManager
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
new
ChildMessagePort
(
messageManager
window
)
;
}
;
Services
.
obs
.
addObserver
(
observer
"
chrome
-
document
-
global
-
created
"
)
;
Services
.
obs
.
addObserver
(
observer
"
content
-
document
-
global
-
created
"
)
;
Services
.
cpmm
.
addMessageListener
(
"
RemotePage
:
Register
"
(
{
data
}
)
=
>
{
for
(
let
url
of
data
.
urls
)
registeredURLs
.
add
(
url
)
;
}
)
;
Services
.
cpmm
.
addMessageListener
(
"
RemotePage
:
Unregister
"
(
{
data
}
)
=
>
{
for
(
let
url
of
data
.
urls
)
registeredURLs
.
delete
(
url
)
;
}
)
;
