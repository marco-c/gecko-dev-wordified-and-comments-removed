var
EXPORTED_SYMBOLS
=
[
"
InlineSpellChecker
"
"
SpellCheckHelper
"
]
;
const
MAX_UNDO_STACK_DEPTH
=
1
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
function
InlineSpellChecker
(
aEditor
)
{
this
.
init
(
aEditor
)
;
this
.
mAddedWordStack
=
[
]
;
}
InlineSpellChecker
.
prototype
=
{
init
(
aEditor
)
{
this
.
uninit
(
)
;
this
.
mEditor
=
aEditor
;
try
{
this
.
mInlineSpellChecker
=
this
.
mEditor
.
getInlineSpellChecker
(
true
)
;
}
catch
(
e
)
{
this
.
mInlineSpellChecker
=
null
;
}
}
initFromRemote
(
aSpellInfo
aWindowGlobalParent
)
{
if
(
this
.
mRemote
)
{
Cu
.
reportError
(
new
Error
(
"
Unexpected
remote
spellchecker
present
!
"
)
)
;
try
{
this
.
mRemote
.
uninit
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
this
.
mRemote
=
null
;
}
this
.
uninit
(
)
;
if
(
!
aSpellInfo
)
{
return
;
}
this
.
mInlineSpellChecker
=
this
.
mRemote
=
new
RemoteSpellChecker
(
aSpellInfo
aWindowGlobalParent
)
;
this
.
mOverMisspelling
=
aSpellInfo
.
overMisspelling
;
this
.
mMisspelling
=
aSpellInfo
.
misspelling
;
}
uninit
(
)
{
if
(
this
.
mRemote
)
{
this
.
mRemote
.
uninit
(
)
;
this
.
mRemote
=
null
;
}
this
.
mEditor
=
null
;
this
.
mInlineSpellChecker
=
null
;
this
.
mOverMisspelling
=
false
;
this
.
mMisspelling
=
"
"
;
this
.
mMenu
=
null
;
this
.
mSuggestionItems
=
[
]
;
this
.
mDictionaryMenu
=
null
;
this
.
mDictionaryItems
=
[
]
;
this
.
mWordNode
=
null
;
}
initFromEvent
(
rangeParent
rangeOffset
)
{
this
.
mOverMisspelling
=
false
;
if
(
!
rangeParent
|
|
!
this
.
mInlineSpellChecker
)
{
return
;
}
var
selcon
=
this
.
mEditor
.
selectionController
;
var
spellsel
=
selcon
.
getSelection
(
selcon
.
SELECTION_SPELLCHECK
)
;
if
(
spellsel
.
rangeCount
=
=
0
)
{
return
;
}
var
range
=
this
.
mInlineSpellChecker
.
getMisspelledWord
(
rangeParent
rangeOffset
)
;
if
(
!
range
)
{
return
;
}
this
.
mMisspelling
=
range
.
toString
(
)
;
this
.
mOverMisspelling
=
true
;
this
.
mWordNode
=
rangeParent
;
this
.
mWordOffset
=
rangeOffset
;
}
get
canSpellCheck
(
)
{
if
(
this
.
mRemote
)
{
return
this
.
mRemote
.
canSpellCheck
;
}
return
this
.
mInlineSpellChecker
!
=
null
;
}
get
initialSpellCheckPending
(
)
{
if
(
this
.
mRemote
)
{
return
this
.
mRemote
.
spellCheckPending
;
}
return
!
!
(
this
.
mInlineSpellChecker
&
&
!
this
.
mInlineSpellChecker
.
spellChecker
&
&
this
.
mInlineSpellChecker
.
spellCheckPending
)
;
}
get
enabled
(
)
{
if
(
this
.
mRemote
)
{
return
this
.
mRemote
.
enableRealTimeSpell
;
}
return
(
this
.
mInlineSpellChecker
&
&
this
.
mInlineSpellChecker
.
enableRealTimeSpell
)
;
}
set
enabled
(
isEnabled
)
{
if
(
this
.
mRemote
)
{
this
.
mRemote
.
setSpellcheckUserOverride
(
isEnabled
)
;
}
else
if
(
this
.
mInlineSpellChecker
)
{
this
.
mEditor
.
setSpellcheckUserOverride
(
isEnabled
)
;
}
}
get
overMisspelling
(
)
{
return
this
.
mOverMisspelling
;
}
addSuggestionsToMenuOnParent
(
menu
insertBefore
maxNumber
)
{
if
(
this
.
mRemote
)
{
return
0
;
}
if
(
!
this
.
mInlineSpellChecker
|
|
!
this
.
mOverMisspelling
)
{
return
0
;
}
let
spellchecker
=
this
.
mInlineSpellChecker
.
spellChecker
;
let
spellSuggestions
=
[
]
;
try
{
if
(
!
spellchecker
.
CheckCurrentWord
(
this
.
mMisspelling
)
)
{
return
0
;
}
for
(
let
i
=
0
;
i
<
maxNumber
;
i
+
+
)
{
let
suggestion
=
spellchecker
.
GetSuggestedWord
(
)
;
if
(
!
suggestion
.
length
)
{
break
;
}
spellSuggestions
.
push
(
suggestion
)
;
}
}
catch
(
e
)
{
return
0
;
}
return
this
.
_addSuggestionsToMenu
(
menu
insertBefore
spellSuggestions
)
;
}
addSuggestionsToMenu
(
menu
insertBefore
spellSuggestions
)
{
if
(
!
this
.
mRemote
&
&
(
!
this
.
mInlineSpellChecker
|
|
!
this
.
mOverMisspelling
)
)
{
return
0
;
}
if
(
!
spellSuggestions
?
.
length
)
{
return
0
;
}
return
this
.
_addSuggestionsToMenu
(
menu
insertBefore
spellSuggestions
)
;
}
_addSuggestionsToMenu
(
menu
insertBefore
spellSuggestions
)
{
this
.
mMenu
=
menu
;
this
.
mSuggestionItems
=
[
]
;
for
(
let
suggestion
of
spellSuggestions
)
{
var
item
=
menu
.
ownerDocument
.
createXULElement
(
"
menuitem
"
)
;
this
.
mSuggestionItems
.
push
(
item
)
;
item
.
setAttribute
(
"
label
"
suggestion
)
;
item
.
setAttribute
(
"
value
"
suggestion
)
;
item
.
addEventListener
(
"
command
"
this
.
replaceMisspelling
.
bind
(
this
suggestion
)
true
)
;
item
.
setAttribute
(
"
class
"
"
spell
-
suggestion
"
)
;
menu
.
insertBefore
(
item
insertBefore
)
;
}
return
spellSuggestions
.
length
;
}
clearSuggestionsFromMenu
(
)
{
for
(
var
i
=
0
;
i
<
this
.
mSuggestionItems
.
length
;
i
+
+
)
{
this
.
mMenu
.
removeChild
(
this
.
mSuggestionItems
[
i
]
)
;
}
this
.
mSuggestionItems
=
[
]
;
}
sortDictionaryList
(
list
)
{
var
sortedList
=
[
]
;
var
names
=
Services
.
intl
.
getLocaleDisplayNames
(
undefined
list
)
;
for
(
var
i
=
0
;
i
<
list
.
length
;
i
+
+
)
{
sortedList
.
push
(
{
localeCode
:
list
[
i
]
displayName
:
names
[
i
]
}
)
;
}
let
comparer
=
new
Services
.
intl
.
Collator
(
)
.
compare
;
sortedList
.
sort
(
(
a
b
)
=
>
comparer
(
a
.
displayName
b
.
displayName
)
)
;
return
sortedList
;
}
addDictionaryListToMenu
(
menu
insertBefore
)
{
this
.
mDictionaryMenu
=
menu
;
this
.
mDictionaryItems
=
[
]
;
if
(
!
this
.
enabled
)
{
return
0
;
}
var
list
;
var
curlangs
=
new
Set
(
)
;
if
(
this
.
mRemote
)
{
list
=
this
.
mRemote
.
dictionaryList
;
curlangs
=
new
Set
(
this
.
mRemote
.
currentDictionaries
)
;
}
else
if
(
this
.
mInlineSpellChecker
)
{
var
spellchecker
=
this
.
mInlineSpellChecker
.
spellChecker
;
list
=
spellchecker
.
GetDictionaryList
(
)
;
try
{
curlangs
=
new
Set
(
spellchecker
.
getCurrentDictionaries
(
)
)
;
}
catch
(
e
)
{
}
}
var
sortedList
=
this
.
sortDictionaryList
(
list
)
;
menu
.
addEventListener
(
"
command
"
async
evt
=
>
{
let
localeCodes
=
new
Set
(
curlangs
)
;
let
localeCode
=
evt
.
target
.
dataset
.
localeCode
;
if
(
localeCodes
.
has
(
localeCode
)
)
{
localeCodes
.
delete
(
localeCode
)
;
}
else
{
localeCodes
.
add
(
localeCode
)
;
}
let
dictionaries
=
Array
.
from
(
localeCodes
)
;
await
this
.
selectDictionaries
(
dictionaries
)
;
var
view
=
menu
.
ownerGlobal
;
var
spellcheckChangeEvent
=
new
view
.
CustomEvent
(
"
spellcheck
-
changed
"
{
detail
:
{
dictionaries
}
}
)
;
menu
.
ownerDocument
.
dispatchEvent
(
spellcheckChangeEvent
)
;
}
true
)
;
for
(
var
i
=
0
;
i
<
sortedList
.
length
;
i
+
+
)
{
var
item
=
menu
.
ownerDocument
.
createXULElement
(
"
menuitem
"
)
;
item
.
setAttribute
(
"
id
"
"
spell
-
check
-
dictionary
-
"
+
sortedList
[
i
]
.
localeCode
)
;
item
.
setAttribute
(
"
label
"
sortedList
[
i
]
.
displayName
)
;
item
.
setAttribute
(
"
type
"
"
checkbox
"
)
;
item
.
setAttribute
(
"
selection
-
type
"
"
multiple
"
)
;
this
.
mDictionaryItems
.
push
(
item
)
;
item
.
dataset
.
localeCode
=
sortedList
[
i
]
.
localeCode
;
if
(
curlangs
.
has
(
sortedList
[
i
]
.
localeCode
)
)
{
item
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
if
(
insertBefore
)
{
menu
.
insertBefore
(
item
insertBefore
)
;
}
else
{
menu
.
appendChild
(
item
)
;
}
}
return
list
.
length
;
}
clearDictionaryListFromMenu
(
)
{
for
(
var
i
=
0
;
i
<
this
.
mDictionaryItems
.
length
;
i
+
+
)
{
this
.
mDictionaryMenu
.
removeChild
(
this
.
mDictionaryItems
[
i
]
)
;
}
this
.
mDictionaryItems
=
[
]
;
}
async
selectDictionaries
(
localeCodes
)
{
if
(
this
.
mRemote
)
{
this
.
mRemote
.
selectDictionaries
(
localeCodes
)
;
return
;
}
if
(
!
this
.
mInlineSpellChecker
)
{
return
;
}
var
spellchecker
=
this
.
mInlineSpellChecker
.
spellChecker
;
await
spellchecker
.
setCurrentDictionaries
(
localeCodes
)
;
this
.
mInlineSpellChecker
.
spellCheckRange
(
null
)
;
}
replaceMisspelling
(
suggestion
)
{
if
(
this
.
mRemote
)
{
this
.
mRemote
.
replaceMisspelling
(
suggestion
)
;
return
;
}
if
(
!
this
.
mInlineSpellChecker
|
|
!
this
.
mOverMisspelling
)
{
return
;
}
this
.
mInlineSpellChecker
.
replaceWord
(
this
.
mWordNode
this
.
mWordOffset
suggestion
)
;
}
toggleEnabled
(
)
{
if
(
this
.
mRemote
)
{
this
.
mRemote
.
toggleEnabled
(
)
;
}
else
{
this
.
mEditor
.
setSpellcheckUserOverride
(
!
this
.
mInlineSpellChecker
.
enableRealTimeSpell
)
;
}
}
addToDictionary
(
)
{
if
(
this
.
mAddedWordStack
.
length
=
=
MAX_UNDO_STACK_DEPTH
)
{
this
.
mAddedWordStack
.
shift
(
)
;
}
this
.
mAddedWordStack
.
push
(
this
.
mMisspelling
)
;
if
(
this
.
mRemote
)
{
this
.
mRemote
.
addToDictionary
(
)
;
}
else
{
this
.
mInlineSpellChecker
.
addWordToDictionary
(
this
.
mMisspelling
)
;
}
}
undoAddToDictionary
(
)
{
if
(
this
.
mAddedWordStack
.
length
)
{
var
word
=
this
.
mAddedWordStack
.
pop
(
)
;
if
(
this
.
mRemote
)
{
this
.
mRemote
.
undoAddToDictionary
(
word
)
;
}
else
{
this
.
mInlineSpellChecker
.
removeWordFromDictionary
(
word
)
;
}
}
}
canUndo
(
)
{
return
!
!
this
.
mAddedWordStack
.
length
;
}
ignoreWord
(
)
{
if
(
this
.
mRemote
)
{
this
.
mRemote
.
ignoreWord
(
)
;
}
else
{
this
.
mInlineSpellChecker
.
ignoreWord
(
this
.
mMisspelling
)
;
}
}
}
;
var
SpellCheckHelper
=
{
EDITABLE
:
0x1
INPUT
:
0x2
TEXTAREA
:
0x4
TEXTINPUT
:
0x8
KEYWORD
:
0x10
CONTENTEDITABLE
:
0x20
NUMERIC
:
0x40
PASSWORD
:
0x80
SPELLCHECKABLE
:
0x100
isTargetAKeywordField
(
aNode
window
)
{
if
(
!
(
aNode
instanceof
window
.
HTMLInputElement
)
)
{
return
false
;
}
var
form
=
aNode
.
form
;
if
(
!
form
|
|
aNode
.
type
=
=
"
password
"
)
{
return
false
;
}
var
method
=
form
.
method
.
toUpperCase
(
)
;
return
(
method
=
=
"
GET
"
|
|
method
=
=
"
"
|
|
(
form
.
enctype
!
=
"
text
/
plain
"
&
&
form
.
enctype
!
=
"
multipart
/
form
-
data
"
)
)
;
}
getComputedStyle
(
aElem
aProp
)
{
return
aElem
.
ownerGlobal
.
getComputedStyle
(
aElem
)
.
getPropertyValue
(
aProp
)
;
}
isEditable
(
element
window
)
{
var
flags
=
0
;
if
(
element
instanceof
window
.
HTMLInputElement
)
{
flags
|
=
this
.
INPUT
;
if
(
element
.
mozIsTextField
(
false
)
|
|
element
.
type
=
=
"
number
"
)
{
flags
|
=
this
.
TEXTINPUT
;
if
(
!
element
.
readOnly
)
{
flags
|
=
this
.
EDITABLE
;
}
if
(
element
.
type
=
=
"
number
"
)
{
flags
|
=
this
.
NUMERIC
;
}
if
(
!
element
.
readOnly
&
&
(
element
.
type
=
=
"
text
"
|
|
element
.
type
=
=
"
search
"
)
)
{
flags
|
=
this
.
SPELLCHECKABLE
;
}
if
(
this
.
isTargetAKeywordField
(
element
window
)
)
{
flags
|
=
this
.
KEYWORD
;
}
if
(
element
.
type
=
=
"
password
"
)
{
flags
|
=
this
.
PASSWORD
;
}
}
}
else
if
(
element
instanceof
window
.
HTMLTextAreaElement
)
{
flags
|
=
this
.
TEXTINPUT
|
this
.
TEXTAREA
;
if
(
!
element
.
readOnly
)
{
flags
|
=
this
.
SPELLCHECKABLE
|
this
.
EDITABLE
;
}
}
if
(
!
(
flags
&
this
.
SPELLCHECKABLE
)
)
{
var
win
=
element
.
ownerGlobal
;
if
(
win
)
{
var
isSpellcheckable
=
false
;
try
{
var
editingSession
=
win
.
docShell
.
editingSession
;
if
(
editingSession
.
windowIsEditable
(
win
)
&
&
this
.
getComputedStyle
(
element
"
-
moz
-
user
-
modify
"
)
=
=
"
read
-
write
"
)
{
isSpellcheckable
=
true
;
}
}
catch
(
ex
)
{
}
if
(
isSpellcheckable
)
{
flags
|
=
this
.
CONTENTEDITABLE
|
this
.
SPELLCHECKABLE
;
}
}
}
return
flags
;
}
}
;
function
RemoteSpellChecker
(
aSpellInfo
aWindowGlobalParent
)
{
this
.
_spellInfo
=
aSpellInfo
;
this
.
_suggestionGenerator
=
null
;
this
.
_actor
=
aWindowGlobalParent
.
getActor
(
"
InlineSpellChecker
"
)
;
this
.
_actor
.
registerDestructionObserver
(
this
)
;
}
RemoteSpellChecker
.
prototype
=
{
get
canSpellCheck
(
)
{
return
this
.
_spellInfo
.
canSpellCheck
;
}
get
spellCheckPending
(
)
{
return
this
.
_spellInfo
.
initialSpellCheckPending
;
}
get
overMisspelling
(
)
{
return
this
.
_spellInfo
.
overMisspelling
;
}
get
enableRealTimeSpell
(
)
{
return
this
.
_spellInfo
.
enableRealTimeSpell
;
}
get
suggestions
(
)
{
return
this
.
_spellInfo
.
spellSuggestions
;
}
get
currentDictionaries
(
)
{
return
this
.
_spellInfo
.
currentDictionaries
;
}
get
dictionaryList
(
)
{
return
this
.
_spellInfo
.
dictionaryList
.
slice
(
)
;
}
selectDictionaries
(
localeCodes
)
{
this
.
_actor
.
selectDictionaries
(
{
localeCodes
}
)
;
}
replaceMisspelling
(
suggestion
)
{
this
.
_actor
.
replaceMisspelling
(
{
suggestion
}
)
;
}
toggleEnabled
(
)
{
this
.
_actor
.
toggleEnabled
(
)
;
}
addToDictionary
(
)
{
let
dictionary
=
Cc
[
"
mozilla
.
org
/
spellchecker
/
personaldictionary
;
1
"
]
.
getService
(
Ci
.
mozIPersonalDictionary
)
;
dictionary
.
addWord
(
this
.
_spellInfo
.
misspelling
)
;
this
.
_actor
.
recheckSpelling
(
)
;
}
undoAddToDictionary
(
word
)
{
let
dictionary
=
Cc
[
"
mozilla
.
org
/
spellchecker
/
personaldictionary
;
1
"
]
.
getService
(
Ci
.
mozIPersonalDictionary
)
;
dictionary
.
removeWord
(
word
)
;
this
.
_actor
.
recheckSpelling
(
)
;
}
ignoreWord
(
)
{
let
dictionary
=
Cc
[
"
mozilla
.
org
/
spellchecker
/
personaldictionary
;
1
"
]
.
getService
(
Ci
.
mozIPersonalDictionary
)
;
dictionary
.
ignoreWord
(
this
.
_spellInfo
.
misspelling
)
;
this
.
_actor
.
recheckSpelling
(
)
;
}
uninit
(
)
{
if
(
this
.
_actor
)
{
this
.
_actor
.
uninit
(
)
;
this
.
_actor
.
unregisterDestructionObserver
(
this
)
;
}
}
actorDestroyed
(
)
{
this
.
_actor
=
null
;
}
}
;
