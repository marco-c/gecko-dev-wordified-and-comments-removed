"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
CreditCard
"
]
;
const
SUPPORTED_NETWORKS
=
Object
.
freeze
(
[
"
amex
"
"
cartebancaire
"
"
diners
"
"
discover
"
"
jcb
"
"
mastercard
"
"
mir
"
"
unionpay
"
"
visa
"
]
)
;
class
CreditCard
{
constructor
(
{
name
number
expirationString
expirationMonth
expirationYear
network
ccv
encryptedNumber
}
)
{
this
.
_name
=
name
;
this
.
_unmodifiedNumber
=
number
;
this
.
_encryptedNumber
=
encryptedNumber
;
this
.
_ccv
=
ccv
;
this
.
number
=
number
;
let
{
month
year
}
=
CreditCard
.
normalizeExpiration
(
{
expirationString
expirationMonth
expirationYear
}
)
;
this
.
_expirationMonth
=
month
;
this
.
_expirationYear
=
year
;
this
.
network
=
network
;
}
set
name
(
value
)
{
this
.
_name
=
value
;
}
set
expirationMonth
(
value
)
{
if
(
typeof
value
=
=
"
undefined
"
)
{
this
.
_expirationMonth
=
undefined
;
return
;
}
this
.
_expirationMonth
=
CreditCard
.
normalizeExpirationMonth
(
value
)
;
}
get
expirationMonth
(
)
{
return
this
.
_expirationMonth
;
}
set
expirationYear
(
value
)
{
if
(
typeof
value
=
=
"
undefined
"
)
{
this
.
_expirationYear
=
undefined
;
return
;
}
this
.
_expirationYear
=
CreditCard
.
normalizeExpirationYear
(
value
)
;
}
get
expirationYear
(
)
{
return
this
.
_expirationYear
;
}
set
expirationString
(
value
)
{
let
{
month
year
}
=
CreditCard
.
parseExpirationString
(
value
)
;
this
.
expirationMonth
=
month
;
this
.
expirationYear
=
year
;
}
set
ccv
(
value
)
{
this
.
_ccv
=
value
;
}
get
number
(
)
{
return
this
.
_number
;
}
set
number
(
value
)
{
if
(
value
)
{
let
normalizedNumber
=
value
.
replace
(
/
[
-
\
s
]
/
g
"
"
)
;
normalizedNumber
=
normalizedNumber
.
match
(
/
^
\
d
{
12
}
/
)
?
normalizedNumber
:
"
"
;
this
.
_number
=
normalizedNumber
;
}
else
{
this
.
_number
=
"
"
;
}
if
(
value
&
&
!
this
.
isValidNumber
(
)
)
{
this
.
_number
=
"
"
;
throw
new
Error
(
"
Invalid
credit
card
number
"
)
;
}
}
get
network
(
)
{
return
this
.
_network
;
}
set
network
(
value
)
{
this
.
_network
=
value
|
|
undefined
;
}
isValidNumber
(
)
{
if
(
!
this
.
_number
)
{
return
false
;
}
let
number
=
this
.
_number
.
replace
(
/
[
\
-
\
s
]
/
g
"
"
)
;
let
len
=
number
.
length
;
if
(
len
<
12
|
|
len
>
19
)
{
return
false
;
}
if
(
!
/
^
\
d
+
/
.
test
(
number
)
)
{
return
false
;
}
let
total
=
0
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
let
ch
=
parseInt
(
number
[
len
-
i
-
1
]
10
)
;
if
(
i
%
2
=
=
1
)
{
ch
*
=
2
;
if
(
ch
>
9
)
{
ch
-
=
9
;
}
}
total
+
=
ch
;
}
return
total
%
10
=
=
0
;
}
isValid
(
)
{
if
(
!
this
.
isValidNumber
(
)
)
{
return
false
;
}
let
currentDate
=
new
Date
(
)
;
let
currentYear
=
currentDate
.
getFullYear
(
)
;
if
(
this
.
_expirationYear
>
currentYear
)
{
return
true
;
}
let
currentMonth
=
currentDate
.
getMonth
(
)
+
1
;
return
(
this
.
_expirationYear
=
=
currentYear
&
&
this
.
_expirationMonth
>
=
currentMonth
)
;
}
get
maskedNumber
(
)
{
return
CreditCard
.
getMaskedNumber
(
this
.
_number
)
;
}
get
longMaskedNumber
(
)
{
return
CreditCard
.
getLongMaskedNumber
(
this
.
_number
)
;
}
static
getLabel
(
{
number
name
}
)
{
let
parts
=
[
]
;
if
(
number
)
{
parts
.
push
(
CreditCard
.
getMaskedNumber
(
number
)
)
;
}
if
(
name
)
{
parts
.
push
(
name
)
;
}
return
parts
.
join
(
"
"
)
;
}
static
normalizeExpirationMonth
(
month
)
{
month
=
parseInt
(
month
10
)
;
if
(
isNaN
(
month
)
|
|
month
<
1
|
|
month
>
12
)
{
return
undefined
;
}
return
month
;
}
static
normalizeExpirationYear
(
year
)
{
year
=
parseInt
(
year
10
)
;
if
(
isNaN
(
year
)
|
|
year
<
0
)
{
return
undefined
;
}
if
(
year
<
100
)
{
year
+
=
2000
;
}
return
year
;
}
static
parseExpirationString
(
expirationString
)
{
let
rules
=
[
{
regex
:
"
(
\
\
d
{
4
}
)
[
-
/
]
(
\
\
d
{
1
2
}
)
"
yearIndex
:
1
monthIndex
:
2
}
{
regex
:
"
(
\
\
d
{
1
2
}
)
[
-
/
]
(
\
\
d
{
4
}
)
"
yearIndex
:
2
monthIndex
:
1
}
{
regex
:
"
(
\
\
d
{
1
2
}
)
[
-
/
]
(
\
\
d
{
1
2
}
)
"
}
{
regex
:
"
(
\
\
d
{
2
}
)
(
\
\
d
{
2
}
)
"
}
]
;
for
(
let
rule
of
rules
)
{
let
result
=
new
RegExp
(
(
?
:
^
|
\
\
D
)
{
rule
.
regex
}
(
?
!
\
\
d
)
)
.
exec
(
expirationString
)
;
if
(
!
result
)
{
continue
;
}
let
year
month
;
if
(
!
rule
.
yearIndex
|
|
!
rule
.
monthIndex
)
{
month
=
parseInt
(
result
[
1
]
10
)
;
if
(
month
>
12
)
{
year
=
parseInt
(
result
[
1
]
10
)
;
month
=
parseInt
(
result
[
2
]
10
)
;
}
else
{
year
=
parseInt
(
result
[
2
]
10
)
;
}
}
else
{
year
=
parseInt
(
result
[
rule
.
yearIndex
]
10
)
;
month
=
parseInt
(
result
[
rule
.
monthIndex
]
10
)
;
}
if
(
month
<
1
|
|
month
>
12
|
|
(
year
>
=
100
&
&
year
<
2000
)
)
{
continue
;
}
return
{
month
year
}
;
}
return
{
month
:
undefined
year
:
undefined
}
;
}
static
normalizeExpiration
(
{
expirationString
expirationMonth
expirationYear
}
)
{
let
parsedExpiration
=
{
}
;
if
(
expirationString
&
&
(
!
expirationMonth
|
|
!
expirationYear
)
)
{
parsedExpiration
=
CreditCard
.
parseExpirationString
(
expirationString
)
;
}
return
{
month
:
CreditCard
.
normalizeExpirationMonth
(
parsedExpiration
.
month
|
|
expirationMonth
)
year
:
CreditCard
.
normalizeExpirationYear
(
parsedExpiration
.
year
|
|
expirationYear
)
}
;
}
static
formatMaskedNumber
(
maskedNumber
)
{
return
{
affix
:
"
*
*
*
*
"
label
:
maskedNumber
.
replace
(
/
^
\
*
*
/
"
"
)
}
;
}
static
getMaskedNumber
(
number
)
{
return
"
*
"
.
repeat
(
4
)
+
"
"
+
number
.
substr
(
-
4
)
;
}
static
getLongMaskedNumber
(
number
)
{
return
"
*
"
.
repeat
(
number
.
length
-
4
)
+
number
.
substr
(
-
4
)
;
}
static
isValidNumber
(
number
)
{
try
{
new
CreditCard
(
{
number
}
)
;
}
catch
(
ex
)
{
return
false
;
}
return
true
;
}
static
isValidNetwork
(
network
)
{
return
SUPPORTED_NETWORKS
.
includes
(
network
)
;
}
}
CreditCard
.
SUPPORTED_NETWORKS
=
SUPPORTED_NETWORKS
;
