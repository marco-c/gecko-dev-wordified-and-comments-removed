const
URL_HOST
=
"
http
:
/
/
localhost
"
;
const
PR_USEC_PER_MSEC
=
1000
;
const
{
GMPExtractor
GMPInstallManager
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
GMPInstallManager
.
sys
.
mjs
"
)
;
const
{
setTimeout
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
)
;
const
{
FileUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
)
;
const
{
HttpServer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
const
{
Preferences
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
sys
.
mjs
"
)
;
const
{
TelemetryTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
)
;
const
{
UpdateUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
sys
.
mjs
"
)
;
const
{
GMPPrefs
OPEN_H264_ID
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
GMPUtils
.
sys
.
mjs
"
)
;
const
{
ProductAddonCheckerTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
addons
/
ProductAddonChecker
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
Services
.
prefs
.
setBoolPref
(
"
security
.
allow_eval_with_system_principal
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
media
.
gmp
-
manager
.
updateEnabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
telemetry
.
testing
.
overrideProductsCheck
"
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
security
.
allow_eval_with_system_principal
"
)
;
Services
.
prefs
.
clearUserPref
(
"
media
.
gmp
-
manager
.
updateEnabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
toolkit
.
telemetry
.
testing
.
overrideProductsCheck
"
)
;
}
)
;
Preferences
.
set
(
"
media
.
gmp
-
manager
.
checkContentSignature
"
false
)
;
do_get_profile
(
)
;
add_task
(
function
test_setup
(
)
{
Services
.
fog
.
initializeFOG
(
)
;
}
)
;
function
run_test
(
)
{
Preferences
.
set
(
"
media
.
gmp
.
log
.
dump
"
true
)
;
Preferences
.
set
(
"
media
.
gmp
.
log
.
level
"
0
)
;
run_next_test
(
)
;
}
add_task
(
async
function
test_prefs
(
)
{
let
addon1
=
"
addon1
"
addon2
=
"
addon2
"
;
GMPPrefs
.
setString
(
GMPPrefs
.
KEY_URL
"
http
:
/
/
not
-
really
-
used
"
)
;
GMPPrefs
.
setString
(
GMPPrefs
.
KEY_URL_OVERRIDE
"
http
:
/
/
not
-
really
-
used
-
2
"
)
;
GMPPrefs
.
setInt
(
GMPPrefs
.
KEY_PLUGIN_LAST_UPDATE
1
addon1
)
;
GMPPrefs
.
setString
(
GMPPrefs
.
KEY_PLUGIN_VERSION
"
2
"
addon1
)
;
GMPPrefs
.
setInt
(
GMPPrefs
.
KEY_PLUGIN_LAST_UPDATE
3
addon2
)
;
GMPPrefs
.
setInt
(
GMPPrefs
.
KEY_PLUGIN_VERSION
4
addon2
)
;
GMPPrefs
.
setBool
(
GMPPrefs
.
KEY_PLUGIN_AUTOUPDATE
false
addon2
)
;
GMPPrefs
.
setBool
(
GMPPrefs
.
KEY_CERT_CHECKATTRS
true
)
;
GMPPrefs
.
setString
(
GMPPrefs
.
KEY_PLUGIN_HASHVALUE
"
5
"
addon1
)
;
Assert
.
equal
(
GMPPrefs
.
getString
(
GMPPrefs
.
KEY_URL
)
"
http
:
/
/
not
-
really
-
used
"
)
;
Assert
.
equal
(
GMPPrefs
.
getString
(
GMPPrefs
.
KEY_URL_OVERRIDE
)
"
http
:
/
/
not
-
really
-
used
-
2
"
)
;
Assert
.
equal
(
GMPPrefs
.
getInt
(
GMPPrefs
.
KEY_PLUGIN_LAST_UPDATE
"
"
addon1
)
1
)
;
Assert
.
equal
(
GMPPrefs
.
getString
(
GMPPrefs
.
KEY_PLUGIN_VERSION
"
"
addon1
)
"
2
"
)
;
Assert
.
equal
(
GMPPrefs
.
getInt
(
GMPPrefs
.
KEY_PLUGIN_LAST_UPDATE
"
"
addon2
)
3
)
;
Assert
.
equal
(
GMPPrefs
.
getInt
(
GMPPrefs
.
KEY_PLUGIN_VERSION
"
"
addon2
)
4
)
;
Assert
.
equal
(
GMPPrefs
.
getBool
(
GMPPrefs
.
KEY_PLUGIN_AUTOUPDATE
undefined
addon2
)
false
)
;
Assert
.
ok
(
GMPPrefs
.
getBool
(
GMPPrefs
.
KEY_CERT_CHECKATTRS
)
)
;
GMPPrefs
.
setBool
(
GMPPrefs
.
KEY_PLUGIN_AUTOUPDATE
true
addon2
)
;
Assert
.
equal
(
GMPPrefs
.
getString
(
GMPPrefs
.
KEY_PLUGIN_HASHVALUE
"
"
addon1
)
"
5
"
)
;
}
)
;
add_task
(
async
function
test_checkForAddons_uninitWithoutCheck
(
)
{
let
installManager
=
new
GMPInstallManager
(
)
;
installManager
.
uninit
(
)
;
}
)
;
add_test
(
function
test_checkForAddons_uninitWithoutInstall
(
)
{
let
myRequest
=
new
mockRequest
(
200
"
"
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
promise
=
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
promise
.
then
(
res
=
>
{
Assert
.
ok
(
res
.
usedFallback
)
;
installManager
.
uninit
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
add_test
(
function
test_checkForAddons_noResponse
(
)
{
let
myRequest
=
new
mockRequest
(
200
"
"
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
promise
=
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
promise
.
then
(
res
=
>
{
Assert
.
ok
(
res
.
usedFallback
)
;
installManager
.
uninit
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_checkForAddons_noAddonsElement
(
)
{
let
myRequest
=
new
mockRequest
(
200
"
<
updates
>
<
/
updates
>
"
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
res
=
await
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
Assert
.
equal
(
res
.
addons
.
length
0
)
;
installManager
.
uninit
(
)
;
}
)
;
add_task
(
async
function
test_checkForAddons_emptyAddonsElement
(
)
{
let
myRequest
=
new
mockRequest
(
200
"
<
updates
>
<
addons
/
>
<
/
updates
>
"
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
res
=
await
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
Assert
.
equal
(
res
.
addons
.
length
0
)
;
installManager
.
uninit
(
)
;
}
)
;
add_test
(
function
test_checkForAddons_wrongResponseXML
(
)
{
let
myRequest
=
new
mockRequest
(
200
"
<
digits_of_pi
>
3
.
141592653589793
.
.
.
.
<
/
digits_of_pi
>
"
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
promise
=
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
promise
.
then
(
res
=
>
{
Assert
.
ok
(
res
.
usedFallback
)
;
installManager
.
uninit
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
add_test
(
function
test_checkForAddons_404Error
(
)
{
let
myRequest
=
new
mockRequest
(
404
"
"
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
promise
=
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
promise
.
then
(
res
=
>
{
Assert
.
ok
(
res
.
usedFallback
)
;
installManager
.
uninit
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
add_test
(
function
test_checkForAddons_abort
(
)
{
let
overriddenServiceRequest
=
new
mockRequest
(
200
"
"
{
dropRequest
:
true
}
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
promise
=
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
overriddenServiceRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
setTimeout
(
(
)
=
>
{
overriddenServiceRequest
.
abort
(
)
;
}
100
)
;
promise
.
then
(
res
=
>
{
Assert
.
ok
(
res
.
usedFallback
)
;
installManager
.
uninit
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
add_test
(
function
test_checkForAddons_timeout
(
)
{
let
myRequest
=
new
mockRequest
(
200
"
"
{
dropRequest
:
true
timeout
:
true
}
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
promise
=
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
promise
.
then
(
res
=
>
{
Assert
.
ok
(
res
.
usedFallback
)
;
installManager
.
uninit
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
add_test
(
function
test_checkForAddons_bad_ssl
(
)
{
let
PREF_KEY_URL_OVERRIDE_BACKUP
=
Preferences
.
get
(
GMPPrefs
.
KEY_URL_OVERRIDE
"
"
)
;
Preferences
.
reset
(
GMPPrefs
.
KEY_URL_OVERRIDE
)
;
let
CERTS_BRANCH_DOT_ONE
=
GMPPrefs
.
KEY_CERTS_BRANCH
+
"
.
1
"
;
let
PREF_CERTS_BRANCH_DOT_ONE_BACKUP
=
Preferences
.
get
(
CERTS_BRANCH_DOT_ONE
"
"
)
;
Services
.
prefs
.
setCharPref
(
CERTS_BRANCH_DOT_ONE
"
funky
value
"
)
;
let
myRequest
=
new
mockRequest
(
200
"
"
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
promise
=
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
promise
.
then
(
res
=
>
{
Assert
.
ok
(
res
.
usedFallback
)
;
installManager
.
uninit
(
)
;
if
(
PREF_KEY_URL_OVERRIDE_BACKUP
)
{
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
PREF_KEY_URL_OVERRIDE_BACKUP
)
;
}
if
(
PREF_CERTS_BRANCH_DOT_ONE_BACKUP
)
{
Preferences
.
set
(
CERTS_BRANCH_DOT_ONE
PREF_CERTS_BRANCH_DOT_ONE_BACKUP
)
;
}
run_next_test
(
)
;
}
)
;
}
)
;
add_test
(
function
test_checkForAddons_notXML
(
)
{
let
myRequest
=
new
mockRequest
(
200
"
3
.
141592653589793
.
.
.
.
"
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
promise
=
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
promise
.
then
(
res
=
>
{
Assert
.
ok
(
res
.
usedFallback
)
;
installManager
.
uninit
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_checkForAddons_singleAddon
(
)
{
let
responseXML
=
'
<
?
xml
version
=
"
1
.
0
"
?
>
'
+
"
<
updates
>
"
+
"
<
addons
>
"
+
'
<
addon
id
=
"
gmp
-
gmpopenh264
"
'
+
'
URL
=
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
'
+
'
hashFunction
=
"
sha256
"
'
+
'
hashValue
=
"
1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
'
+
'
version
=
"
1
.
1
"
/
>
'
+
"
<
/
addons
>
"
+
"
<
/
updates
>
"
;
let
myRequest
=
new
mockRequest
(
200
responseXML
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
res
=
await
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
Assert
.
equal
(
res
.
addons
.
length
1
)
;
let
gmpAddon
=
res
.
addons
[
0
]
;
Assert
.
equal
(
gmpAddon
.
id
"
gmp
-
gmpopenh264
"
)
;
Assert
.
equal
(
gmpAddon
.
URL
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
)
;
Assert
.
equal
(
gmpAddon
.
hashFunction
"
sha256
"
)
;
Assert
.
equal
(
gmpAddon
.
hashValue
"
1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
)
;
Assert
.
equal
(
gmpAddon
.
version
"
1
.
1
"
)
;
Assert
.
ok
(
gmpAddon
.
isValid
)
;
Assert
.
ok
(
!
gmpAddon
.
isInstalled
)
;
installManager
.
uninit
(
)
;
}
)
;
add_task
(
async
function
test_checkForAddons_singleAddonWithSize
(
)
{
let
responseXML
=
'
<
?
xml
version
=
"
1
.
0
"
?
>
'
+
"
<
updates
>
"
+
"
<
addons
>
"
+
'
<
addon
id
=
"
openh264
-
plugin
-
no
-
at
-
symbol
"
'
+
'
URL
=
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
'
+
'
hashFunction
=
"
sha256
"
'
+
'
size
=
"
42
"
'
+
'
hashValue
=
"
1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
'
+
'
version
=
"
1
.
1
"
/
>
'
+
"
<
/
addons
>
"
+
"
<
/
updates
>
"
;
let
myRequest
=
new
mockRequest
(
200
responseXML
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
res
=
await
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
Assert
.
equal
(
res
.
addons
.
length
1
)
;
let
gmpAddon
=
res
.
addons
[
0
]
;
Assert
.
equal
(
gmpAddon
.
id
"
openh264
-
plugin
-
no
-
at
-
symbol
"
)
;
Assert
.
equal
(
gmpAddon
.
URL
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
)
;
Assert
.
equal
(
gmpAddon
.
hashFunction
"
sha256
"
)
;
Assert
.
equal
(
gmpAddon
.
hashValue
"
1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
)
;
Assert
.
equal
(
gmpAddon
.
size
42
)
;
Assert
.
equal
(
gmpAddon
.
version
"
1
.
1
"
)
;
Assert
.
ok
(
gmpAddon
.
isValid
)
;
Assert
.
ok
(
!
gmpAddon
.
isInstalled
)
;
installManager
.
uninit
(
)
;
}
)
;
add_task
(
async
function
test_checkForAddons_multipleAddonNoUpdatesSomeInvalid
(
)
{
let
responseXML
=
'
<
?
xml
version
=
"
1
.
0
"
?
>
'
+
"
<
updates
>
"
+
"
<
addons
>
"
+
'
<
addon
id
=
"
gmp
-
gmpopenh264
"
'
+
'
URL
=
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
'
+
'
hashFunction
=
"
sha256
"
'
+
'
hashValue
=
"
1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
'
+
'
version
=
"
1
.
1
"
/
>
'
+
'
<
addon
id
=
"
NOT
-
gmp
-
gmpopenh264
"
'
+
'
URL
=
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
NOT
-
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
'
+
'
hashFunction
=
"
sha512
"
'
+
'
hashValue
=
"
141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
'
+
'
version
=
"
9
.
1
"
/
>
'
+
'
<
addon
notid
=
"
NOT
-
gmp
-
gmpopenh264
"
'
+
'
URL
=
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
NOT
-
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
'
+
'
hashFunction
=
"
sha512
"
'
+
'
hashValue
=
"
141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
'
+
'
version
=
"
9
.
1
"
/
>
'
+
'
<
addon
id
=
"
NOT
-
gmp
-
gmpopenh264
"
'
+
'
notURL
=
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
NOT
-
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
'
+
'
hashFunction
=
"
sha512
"
'
+
'
hashValue
=
"
141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
'
+
'
version
=
"
9
.
1
"
/
>
'
+
'
<
addon
id
=
"
NOT
-
gmp
-
gmpopenh264
"
'
+
'
URL
=
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
NOT
-
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
'
+
'
nothashFunction
=
"
sha512
"
'
+
'
hashValue
=
"
141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
'
+
'
version
=
"
9
.
1
"
/
>
'
+
'
<
addon
id
=
"
NOT
-
gmp
-
gmpopenh264
"
'
+
'
URL
=
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
NOT
-
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
'
+
'
hashFunction
=
"
sha512
"
'
+
'
nothashValue
=
"
141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
'
+
'
version
=
"
9
.
1
"
/
>
'
+
'
<
addon
id
=
"
NOT
-
gmp
-
gmpopenh264
"
'
+
'
URL
=
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
NOT
-
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
'
+
'
hashFunction
=
"
sha512
"
'
+
'
hashValue
=
"
141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
'
+
'
notversion
=
"
9
.
1
"
/
>
'
+
"
<
/
addons
>
"
+
"
<
/
updates
>
"
;
let
myRequest
=
new
mockRequest
(
200
responseXML
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
res
=
await
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
Assert
.
equal
(
res
.
addons
.
length
7
)
;
let
gmpAddon
=
res
.
addons
[
0
]
;
Assert
.
equal
(
gmpAddon
.
id
"
gmp
-
gmpopenh264
"
)
;
Assert
.
equal
(
gmpAddon
.
URL
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
)
;
Assert
.
equal
(
gmpAddon
.
hashFunction
"
sha256
"
)
;
Assert
.
equal
(
gmpAddon
.
hashValue
"
1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
)
;
Assert
.
equal
(
gmpAddon
.
version
"
1
.
1
"
)
;
Assert
.
ok
(
gmpAddon
.
isValid
)
;
Assert
.
ok
(
!
gmpAddon
.
isInstalled
)
;
gmpAddon
=
res
.
addons
[
1
]
;
Assert
.
equal
(
gmpAddon
.
id
"
NOT
-
gmp
-
gmpopenh264
"
)
;
Assert
.
equal
(
gmpAddon
.
URL
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
NOT
-
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
)
;
Assert
.
equal
(
gmpAddon
.
hashFunction
"
sha512
"
)
;
Assert
.
equal
(
gmpAddon
.
hashValue
"
141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
)
;
Assert
.
equal
(
gmpAddon
.
version
"
9
.
1
"
)
;
Assert
.
ok
(
gmpAddon
.
isValid
)
;
Assert
.
ok
(
!
gmpAddon
.
isInstalled
)
;
for
(
let
i
=
2
;
i
<
res
.
addons
.
length
;
i
+
+
)
{
Assert
.
ok
(
!
res
.
addons
[
i
]
.
isValid
)
;
Assert
.
ok
(
!
res
.
addons
[
i
]
.
isInstalled
)
;
}
installManager
.
uninit
(
)
;
}
)
;
add_task
(
async
function
test_checkForAddons_updatesWithAddons
(
)
{
let
responseXML
=
'
<
?
xml
version
=
"
1
.
0
"
?
>
'
+
"
<
updates
>
"
+
'
<
update
type
=
"
minor
"
displayVersion
=
"
33
.
0a1
"
appVersion
=
"
33
.
0a1
"
platformVersion
=
"
33
.
0a1
"
buildID
=
"
20140628030201
"
>
'
+
'
<
patch
type
=
"
complete
"
URL
=
"
http
:
/
/
ftp
.
mozilla
.
org
/
pub
/
mozilla
.
org
/
firefox
/
nightly
/
2014
/
06
/
2014
-
06
-
28
-
03
-
02
-
01
-
mozilla
-
central
/
firefox
-
33
.
0a1
.
en
-
US
.
mac
.
complete
.
mar
"
hashFunction
=
"
sha512
"
hashValue
=
"
f3f90d71dff03ae81def80e64bba3e4569da99c9e15269f731c2b167c4fc30b3aed9f5fee81c19614120230ca333e73a5e7def1b8e45d03135b2069c26736219
"
size
=
"
85249896
"
/
>
'
+
"
<
/
update
>
"
+
"
<
addons
>
"
+
'
<
addon
id
=
"
gmp
-
gmpopenh264
"
'
+
'
URL
=
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
'
+
'
hashFunction
=
"
sha256
"
'
+
'
hashValue
=
"
1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
'
+
'
version
=
"
1
.
1
"
/
>
'
+
"
<
/
addons
>
"
+
"
<
/
updates
>
"
;
let
myRequest
=
new
mockRequest
(
200
responseXML
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
res
=
await
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
Assert
.
equal
(
res
.
addons
.
length
1
)
;
let
gmpAddon
=
res
.
addons
[
0
]
;
Assert
.
equal
(
gmpAddon
.
id
"
gmp
-
gmpopenh264
"
)
;
Assert
.
equal
(
gmpAddon
.
URL
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
)
;
Assert
.
equal
(
gmpAddon
.
hashFunction
"
sha256
"
)
;
Assert
.
equal
(
gmpAddon
.
hashValue
"
1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
)
;
Assert
.
equal
(
gmpAddon
.
version
"
1
.
1
"
)
;
Assert
.
ok
(
gmpAddon
.
isValid
)
;
Assert
.
ok
(
!
gmpAddon
.
isInstalled
)
;
installManager
.
uninit
(
)
;
}
)
;
add_task
(
async
function
test_checkForAddons_contentSignatureSuccess
(
)
{
const
previousUrlOverride
=
setupContentSigTestPrefs
(
)
;
const
xmlFetchResultHistogram
=
resetGmpTelemetryAndGetHistogram
(
)
;
const
testServerInfo
=
getTestServerForContentSignatureTests
(
)
;
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
testServerInfo
.
validUpdateUri
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
try
{
let
res
=
await
installManager
.
checkForAddons
(
)
;
Assert
.
ok
(
true
"
checkForAddons
should
succeed
"
)
;
Assert
.
equal
(
res
.
usedFallback
false
)
;
Assert
.
equal
(
res
.
addons
.
length
5
)
;
Assert
.
equal
(
res
.
addons
[
0
]
.
id
"
test1
"
)
;
Assert
.
equal
(
res
.
addons
[
1
]
.
id
"
test2
"
)
;
Assert
.
equal
(
res
.
addons
[
2
]
.
id
"
test3
"
)
;
Assert
.
equal
(
res
.
addons
[
3
]
.
id
"
test4
"
)
;
Assert
.
equal
(
res
.
addons
[
4
]
.
id
undefined
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
"
checkForAddons
should
succeed
"
)
;
}
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
2
1
)
;
const
expectedGleanValues
=
{
cert_pin_success
:
0
cert_pin_net_request_error
:
0
cert_pin_net_timeout
:
0
cert_pin_abort
:
0
cert_pin_missing_data
:
0
cert_pin_failed
:
0
cert_pin_invalid
:
0
cert_pin_unknown_error
:
0
content_sig_success
:
1
content_sig_net_request_error
:
0
content_sig_net_timeout
:
0
content_sig_abort
:
0
content_sig_missing_data
:
0
content_sig_failed
:
0
content_sig_invalid
:
0
content_sig_unknown_error
:
0
}
;
checkGleanMetricCounts
(
expectedGleanValues
)
;
revertContentSigTestPrefs
(
previousUrlOverride
)
;
}
)
;
add_task
(
async
function
test_checkForAddons_contentSignatureFailure
(
)
{
const
previousUrlOverride
=
setupContentSigTestPrefs
(
)
;
const
xmlFetchResultHistogram
=
resetGmpTelemetryAndGetHistogram
(
)
;
const
testServerInfo
=
getTestServerForContentSignatureTests
(
)
;
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
testServerInfo
.
missingContentSigUri
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
try
{
let
res
=
await
installManager
.
checkForAddons
(
)
;
Assert
.
ok
(
true
"
checkForAddons
should
succeed
"
)
;
Assert
.
equal
(
res
.
usedFallback
true
)
;
Assert
.
greaterOrEqual
(
res
.
addons
.
length
1
)
;
if
(
res
.
addons
.
length
=
=
1
)
{
Assert
.
equal
(
res
.
addons
[
0
]
.
id
"
gmp
-
widevinecdm
"
)
;
}
else
{
Assert
.
equal
(
res
.
addons
[
0
]
.
id
"
gmp
-
gmpopenh264
"
)
;
Assert
.
equal
(
res
.
addons
[
1
]
.
id
"
gmp
-
widevinecdm
"
)
;
}
}
catch
(
e
)
{
Assert
.
ok
(
false
"
checkForAddons
should
succeed
"
)
;
}
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
3
1
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
content_sig_missing_data
.
testGetValue
(
)
1
)
;
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
testServerInfo
.
badContentSigUri
)
;
await
installManager
.
checkForAddons
(
)
;
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
3
2
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
content_sig_failed
.
testGetValue
(
)
1
)
;
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
testServerInfo
.
invalidContentSigUri
)
;
await
installManager
.
checkForAddons
(
)
;
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
3
3
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
content_sig_invalid
.
testGetValue
(
)
1
)
;
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
"
https
:
/
/
this
.
url
.
doesnt
/
go
/
anywhere
"
)
;
await
installManager
.
checkForAddons
(
)
;
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
3
4
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
content_sig_net_request_error
.
testGetValue
(
)
1
)
;
let
overriddenServiceRequest
=
new
mockRequest
(
200
"
"
{
dropRequest
:
true
timeout
:
true
}
)
;
await
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
overriddenServiceRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
3
5
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
content_sig_net_timeout
.
testGetValue
(
)
1
)
;
overriddenServiceRequest
=
new
mockRequest
(
200
"
"
{
dropRequest
:
true
}
)
;
let
promise
=
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
overriddenServiceRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
setTimeout
(
(
)
=
>
{
overriddenServiceRequest
.
abort
(
)
;
}
100
)
;
await
promise
;
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
3
6
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
content_sig_abort
.
testGetValue
(
)
1
)
;
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
testServerInfo
.
badXmlUri
)
;
await
installManager
.
checkForAddons
(
)
;
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
3
7
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
content_sig_xml_parse_error
.
testGetValue
(
)
1
)
;
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
testServerInfo
.
badX5uRequestUri
)
;
await
installManager
.
checkForAddons
(
)
;
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
3
8
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
content_sig_net_request_error
.
testGetValue
(
)
2
)
;
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
testServerInfo
.
x5uTimeoutUri
)
;
testServerInfo
.
promiseHolder
.
installPromise
=
installManager
.
checkForAddons
(
)
;
await
testServerInfo
.
promiseHolder
.
installPromise
;
await
testServerInfo
.
promiseHolder
.
serverPromise
;
delete
testServerInfo
.
promiseHolder
.
installPromise
;
delete
testServerInfo
.
promiseHolder
.
serverPromise
;
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
3
9
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
content_sig_net_timeout
.
testGetValue
(
)
2
)
;
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
testServerInfo
.
x5uAbortUri
)
;
testServerInfo
.
promiseHolder
.
installPromise
=
installManager
.
checkForAddons
(
)
;
await
testServerInfo
.
promiseHolder
.
installPromise
;
await
testServerInfo
.
promiseHolder
.
serverPromise
;
delete
testServerInfo
.
promiseHolder
.
installPromise
;
delete
testServerInfo
.
promiseHolder
.
serverPromise
;
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
3
10
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
content_sig_abort
.
testGetValue
(
)
2
)
;
const
expectedGleanValues
=
{
cert_pin_success
:
0
cert_pin_net_request_error
:
0
cert_pin_net_timeout
:
0
cert_pin_abort
:
0
cert_pin_missing_data
:
0
cert_pin_failed
:
0
cert_pin_invalid
:
0
cert_pin_xml_parse_error
:
0
cert_pin_unknown_error
:
0
content_sig_success
:
0
content_sig_net_request_error
:
2
content_sig_net_timeout
:
2
content_sig_abort
:
2
content_sig_missing_data
:
1
content_sig_failed
:
1
content_sig_invalid
:
1
content_sig_xml_parse_error
:
1
content_sig_unknown_error
:
0
}
;
checkGleanMetricCounts
(
expectedGleanValues
)
;
revertContentSigTestPrefs
(
previousUrlOverride
)
;
}
)
;
add_task
(
async
function
test_checkForAddons_telemetry_certPinning
(
)
{
const
previousUrlOverride
=
Preferences
.
get
(
GMPPrefs
.
KEY_URL_OVERRIDE
"
"
)
;
let
xmlFetchResultHistogram
=
resetGmpTelemetryAndGetHistogram
(
)
;
const
testServerInfo
=
getTestServerForContentSignatureTests
(
)
;
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
testServerInfo
.
validUpdateUri
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
try
{
await
installManager
.
checkForAddons
(
)
;
Assert
.
ok
(
true
"
checkForAddons
should
succeed
"
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
"
checkForAddons
should
succeed
"
)
;
}
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
0
1
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
cert_pin_success
.
testGetValue
(
)
1
)
;
xmlFetchResultHistogram
=
TelemetryTestUtils
.
getAndClearHistogram
(
"
MEDIA_GMP_UPDATE_XML_FETCH_RESULT
"
)
;
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
"
https
:
/
/
this
.
url
.
doesnt
/
go
/
anywhere
"
)
;
await
installManager
.
checkForAddons
(
)
;
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
1
1
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
cert_pin_net_request_error
.
testGetValue
(
)
1
)
;
let
overriddenServiceRequest
=
new
mockRequest
(
200
"
"
{
dropRequest
:
true
timeout
:
true
}
)
;
await
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
overriddenServiceRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
1
2
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
cert_pin_net_timeout
.
testGetValue
(
)
1
)
;
overriddenServiceRequest
=
new
mockRequest
(
200
"
"
{
dropRequest
:
true
}
)
;
let
promise
=
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
overriddenServiceRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
setTimeout
(
(
)
=
>
{
overriddenServiceRequest
.
abort
(
)
;
}
100
)
;
await
promise
;
TelemetryTestUtils
.
assertHistogram
(
xmlFetchResultHistogram
1
3
)
;
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
.
cert_pin_abort
.
testGetValue
(
)
1
)
;
const
expectedGleanValues
=
{
cert_pin_success
:
1
cert_pin_net_request_error
:
1
cert_pin_net_timeout
:
1
cert_pin_abort
:
1
cert_pin_missing_data
:
0
cert_pin_failed
:
0
cert_pin_invalid
:
0
cert_pin_unknown_error
:
0
content_sig_success
:
0
content_sig_net_request_error
:
0
content_sig_net_timeout
:
0
content_sig_abort
:
0
content_sig_missing_data
:
0
content_sig_failed
:
0
content_sig_invalid
:
0
content_sig_unknown_error
:
0
}
;
checkGleanMetricCounts
(
expectedGleanValues
)
;
if
(
previousUrlOverride
)
{
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
previousUrlOverride
)
;
}
else
{
Preferences
.
reset
(
GMPPrefs
.
KEY_URL_OVERRIDE
)
;
}
}
)
;
async
function
test_checkForAddons_installAddon
(
id
includeSize
wantInstallReject
)
{
info
(
"
Running
installAddon
for
id
:
"
+
id
+
"
includeSize
:
"
+
includeSize
+
"
and
wantInstallReject
:
"
+
wantInstallReject
)
;
let
httpServer
=
new
HttpServer
(
)
;
let
dir
=
FileUtils
.
getDir
(
"
TmpD
"
[
]
true
)
;
httpServer
.
registerDirectory
(
"
/
"
dir
)
;
httpServer
.
start
(
-
1
)
;
let
testserverPort
=
httpServer
.
identity
.
primaryPort
;
let
zipFileName
=
"
test_
"
+
id
+
"
_GMP
.
zip
"
;
let
zipURL
=
URL_HOST
+
"
:
"
+
testserverPort
+
"
/
"
+
zipFileName
;
info
(
"
zipURL
:
"
+
zipURL
)
;
let
data
=
"
e
~
=
0
.
5772156649
"
;
let
zipFile
=
createNewZipFile
(
zipFileName
data
)
;
let
hashFunc
=
"
sha256
"
;
let
expectedDigest
=
await
IOUtils
.
computeHexDigest
(
zipFile
.
path
hashFunc
)
;
let
fileSize
=
zipFile
.
fileSize
;
if
(
wantInstallReject
)
{
fileSize
=
1
;
}
let
responseXML
=
'
<
?
xml
version
=
"
1
.
0
"
?
>
'
+
"
<
updates
>
"
+
"
<
addons
>
"
+
'
<
addon
id
=
"
'
+
id
+
'
-
gmp
-
gmpopenh264
"
'
+
'
URL
=
"
'
+
zipURL
+
'
"
'
+
'
hashFunction
=
"
'
+
hashFunc
+
'
"
'
+
'
hashValue
=
"
'
+
expectedDigest
+
'
"
'
+
(
includeSize
?
'
size
=
"
'
+
fileSize
+
'
"
'
:
"
"
)
+
'
version
=
"
1
.
1
"
/
>
'
+
"
<
/
addons
>
"
+
"
<
/
updates
>
"
;
let
myRequest
=
new
mockRequest
(
200
responseXML
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
res
=
await
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
Assert
.
equal
(
res
.
addons
.
length
1
)
;
let
gmpAddon
=
res
.
addons
[
0
]
;
Assert
.
ok
(
!
gmpAddon
.
isInstalled
)
;
try
{
let
extractedPaths
=
await
installManager
.
installAddon
(
gmpAddon
)
;
if
(
wantInstallReject
)
{
Assert
.
ok
(
false
)
;
}
Assert
.
equal
(
extractedPaths
.
length
1
)
;
let
extractedPath
=
extractedPaths
[
0
]
;
info
(
"
Extracted
path
:
"
+
extractedPath
)
;
let
extractedFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
extractedFile
.
initWithPath
(
extractedPath
)
;
Assert
.
ok
(
extractedFile
.
exists
(
)
)
;
let
readData
=
readStringFromFile
(
extractedFile
)
;
Assert
.
equal
(
readData
data
)
;
Assert
.
ok
(
!
!
GMPPrefs
.
getInt
(
GMPPrefs
.
KEY_PLUGIN_LAST_UPDATE
"
"
gmpAddon
.
id
)
)
;
Assert
.
equal
(
GMPPrefs
.
getString
(
GMPPrefs
.
KEY_PLUGIN_HASHVALUE
"
"
gmpAddon
.
id
)
expectedDigest
)
;
Assert
.
equal
(
GMPPrefs
.
getString
(
GMPPrefs
.
KEY_PLUGIN_VERSION
"
"
gmpAddon
.
id
)
"
1
.
1
"
)
;
Assert
.
equal
(
GMPPrefs
.
getString
(
GMPPrefs
.
KEY_PLUGIN_ABI
"
"
gmpAddon
.
id
)
UpdateUtils
.
ABI
)
;
Assert
.
ok
(
gmpAddon
.
isInstalled
)
;
extractedFile
.
parent
.
remove
(
true
)
;
zipFile
.
remove
(
false
)
;
httpServer
.
stop
(
function
(
)
{
}
)
;
installManager
.
uninit
(
)
;
}
catch
(
ex
)
{
zipFile
.
remove
(
false
)
;
if
(
!
wantInstallReject
)
{
do_throw
(
"
install
update
should
not
reject
"
+
ex
.
message
)
;
}
}
}
add_task
(
test_checkForAddons_installAddon
.
bind
(
null
"
1
"
true
false
)
)
;
add_task
(
test_checkForAddons_installAddon
.
bind
(
null
"
2
"
false
false
)
)
;
add_task
(
test_checkForAddons_installAddon
.
bind
(
null
"
3
"
true
true
)
)
;
add_task
(
async
function
test_simpleCheckAndInstall_autoUpdateDisabled
(
)
{
GMPPrefs
.
setBool
(
GMPPrefs
.
KEY_PLUGIN_AUTOUPDATE
false
OPEN_H264_ID
)
;
let
responseXML
=
'
<
?
xml
version
=
"
1
.
0
"
?
>
'
+
"
<
updates
>
"
+
"
<
addons
>
"
+
'
<
addon
id
=
"
gmp
-
gmpopenh264
"
'
+
'
URL
=
"
http
:
/
/
127
.
0
.
0
.
1
:
8011
/
gmp
-
gmpopenh264
-
1
.
1
.
zip
"
'
+
'
hashFunction
=
"
sha256
"
'
+
'
hashValue
=
"
1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee
"
'
+
'
version
=
"
1
.
1
"
/
>
'
+
"
<
/
addons
>
"
+
"
<
/
updates
>
"
;
let
myRequest
=
new
mockRequest
(
200
responseXML
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
result
=
await
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
simpleCheckAndInstall
(
)
)
;
Assert
.
equal
(
result
.
status
"
nothing
-
new
-
to
-
install
"
)
;
Preferences
.
reset
(
GMPPrefs
.
KEY_UPDATE_LAST_CHECK
)
;
GMPPrefs
.
setBool
(
GMPPrefs
.
KEY_PLUGIN_AUTOUPDATE
true
OPEN_H264_ID
)
;
}
)
;
add_task
(
async
function
test_simpleCheckAndInstall_nothingToInstall
(
)
{
let
responseXML
=
'
<
?
xml
version
=
"
1
.
0
"
?
>
<
updates
>
<
/
updates
>
'
;
let
myRequest
=
new
mockRequest
(
200
responseXML
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
result
=
await
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
simpleCheckAndInstall
(
)
)
;
Assert
.
equal
(
result
.
status
"
nothing
-
new
-
to
-
install
"
)
;
}
)
;
add_task
(
async
function
test_simpleCheckAndInstall_tooFrequent
(
)
{
let
responseXML
=
'
<
?
xml
version
=
"
1
.
0
"
?
>
<
updates
>
<
/
updates
>
'
;
let
myRequest
=
new
mockRequest
(
200
responseXML
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
result
=
await
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
simpleCheckAndInstall
(
)
)
;
Assert
.
equal
(
result
.
status
"
too
-
frequent
-
no
-
check
"
)
;
}
)
;
add_test
(
function
test_installAddon_noServer
(
)
{
let
zipFileName
=
"
test_GMP
.
zip
"
;
let
zipURL
=
URL_HOST
+
"
:
0
/
"
+
zipFileName
;
let
responseXML
=
'
<
?
xml
version
=
"
1
.
0
"
?
>
'
+
"
<
updates
>
"
+
"
<
addons
>
"
+
'
<
addon
id
=
"
gmp
-
gmpopenh264
"
'
+
'
URL
=
"
'
+
zipURL
+
'
"
'
+
'
hashFunction
=
"
sha256
"
'
+
'
hashValue
=
"
11221cbda000347b054028b527a60e578f919cb10f322ef8077d3491c6fcb474
"
'
+
'
version
=
"
1
.
1
"
/
>
'
+
"
<
/
addons
>
"
+
"
<
/
updates
>
"
;
let
myRequest
=
new
mockRequest
(
200
responseXML
)
;
let
installManager
=
new
GMPInstallManager
(
)
;
let
checkPromise
=
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
myRequest
(
)
=
>
installManager
.
checkForAddons
(
)
)
;
checkPromise
.
then
(
res
=
>
{
Assert
.
equal
(
res
.
addons
.
length
1
)
;
let
gmpAddon
=
res
.
addons
[
0
]
;
GMPInstallManager
.
overrideLeaveDownloadedZip
=
true
;
let
installPromise
=
installManager
.
installAddon
(
gmpAddon
)
;
installPromise
.
then
(
extractedPaths
=
>
{
do_throw
(
"
No
server
for
install
should
reject
"
)
;
}
err
=
>
{
Assert
.
ok
(
!
!
err
)
;
installManager
.
uninit
(
)
;
run_next_test
(
)
;
}
)
;
}
(
)
=
>
{
do_throw
(
"
check
should
not
reject
for
install
no
server
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_GMPExtractor_paths
(
)
{
registerCleanupFunction
(
async
function
(
)
{
let
zipFile
=
new
FileUtils
.
File
(
PathUtils
.
join
(
tempDir
.
path
"
dummy_gmp
.
zip
"
)
)
;
Services
.
obs
.
notifyObservers
(
zipFile
"
flush
-
cache
-
entry
"
)
;
await
IOUtils
.
remove
(
extractedDir
{
recursive
:
true
}
)
;
await
IOUtils
.
remove
(
tempDir
.
path
{
recursive
:
true
}
)
;
}
)
;
const
srcPath
=
PathUtils
.
join
(
Services
.
dirsvc
.
get
(
"
CurWorkD
"
Ci
.
nsIFile
)
.
path
"
zips
"
"
dummy_gmp
.
zip
"
)
;
let
tempDirName
=
"
TmpDir
#
"
;
let
tempDir
=
FileUtils
.
getDir
(
"
TmpD
"
[
tempDirName
]
true
)
;
let
zipPath
=
PathUtils
.
join
(
tempDir
.
path
"
dummy_gmp
.
zip
"
)
;
await
IOUtils
.
copy
(
srcPath
zipPath
)
;
let
relativeExtractPath
=
"
extracted
#
"
;
let
extractor
=
new
GMPExtractor
(
zipPath
[
relativeExtractPath
]
)
;
let
extractedPaths
=
await
extractor
.
install
(
)
;
Assert
.
equal
(
extractedPaths
.
length
1
"
One
file
should
be
extracted
"
)
;
Assert
.
ok
(
extractedPaths
[
0
]
.
includes
(
"
dummy_file
.
txt
"
)
"
dummy_file
.
txt
should
be
on
extracted
path
"
)
;
Assert
.
ok
(
!
extractedPaths
[
0
]
.
includes
(
"
verified_contents
.
json
"
)
"
verified_contents
.
json
should
not
be
on
extracted
path
"
)
;
let
extractedDir
=
PathUtils
.
join
(
PathUtils
.
profileDir
relativeExtractPath
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
extractedDir
)
"
Extraction
should
have
created
a
directory
"
)
;
let
extractedFile
=
PathUtils
.
join
(
PathUtils
.
profileDir
relativeExtractPath
"
dummy_file
.
txt
"
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
extractedFile
)
"
Extraction
should
have
created
dummy_file
.
txt
"
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
await
Assert
.
rejects
(
IOUtils
.
getMacXAttr
(
extractedFile
"
com
.
apple
.
quarantine
"
)
/
NotFoundError
:
The
file
.
+
'
does
not
have
an
extended
attribute
com
.
apple
.
quarantine
'
/
"
The
'
com
.
apple
.
quarantine
'
attribute
should
not
be
present
"
)
;
}
let
unextractedFile
=
PathUtils
.
join
(
PathUtils
.
profileDir
relativeExtractPath
"
verified_contents
.
json
"
)
;
Assert
.
ok
(
!
(
await
IOUtils
.
exists
(
unextractedFile
)
)
"
Extraction
should
not
have
created
verified_contents
.
json
"
)
;
}
)
;
function
readStringFromInputStream
(
inputStream
)
{
let
sis
=
Cc
[
"
mozilla
.
org
/
scriptableinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptableInputStream
)
;
sis
.
init
(
inputStream
)
;
let
text
=
sis
.
read
(
sis
.
available
(
)
)
;
sis
.
close
(
)
;
return
text
;
}
function
readStringFromFile
(
file
)
{
if
(
!
file
.
exists
(
)
)
{
info
(
"
readStringFromFile
-
file
doesn
'
t
exist
:
"
+
file
.
path
)
;
return
null
;
}
let
fis
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fis
.
init
(
file
FileUtils
.
MODE_RDONLY
FileUtils
.
PERMS_FILE
0
)
;
return
readStringFromInputStream
(
fis
)
;
}
function
mockRequest
(
inputStatus
inputResponse
options
)
{
this
.
inputStatus
=
inputStatus
;
this
.
inputResponse
=
inputResponse
;
this
.
status
=
0
;
this
.
responseXML
=
null
;
this
.
_aborted
=
false
;
this
.
_onabort
=
null
;
this
.
_onprogress
=
null
;
this
.
_onerror
=
null
;
this
.
_onload
=
null
;
this
.
_onloadend
=
null
;
this
.
_ontimeout
=
null
;
this
.
_url
=
null
;
this
.
_method
=
null
;
this
.
_timeout
=
0
;
this
.
_notified
=
false
;
this
.
_options
=
options
|
|
{
}
;
}
mockRequest
.
prototype
=
{
overrideMimeType
(
aMimetype
)
{
}
setRequestHeader
(
aHeader
aValue
)
{
}
status
:
null
channel
:
{
set
notificationCallbacks
(
aVal
)
{
}
}
open
(
aMethod
aUrl
)
{
this
.
channel
.
originalURI
=
Services
.
io
.
newURI
(
aUrl
)
;
this
.
_method
=
aMethod
;
this
.
_url
=
aUrl
;
}
abort
(
)
{
this
.
_dropRequest
=
true
;
this
.
_notify
(
[
"
abort
"
"
loadend
"
]
)
;
}
responseXML
:
null
responseText
:
null
send
(
aBody
)
{
executeSoon
(
(
)
=
>
{
try
{
if
(
this
.
_options
.
dropRequest
)
{
if
(
this
.
_timeout
>
0
&
&
this
.
_options
.
timeout
)
{
this
.
_notify
(
[
"
timeout
"
"
loadend
"
]
)
;
}
return
;
}
this
.
status
=
this
.
inputStatus
;
this
.
responseText
=
this
.
inputResponse
;
try
{
let
parser
=
new
DOMParser
(
)
;
this
.
responseXML
=
parser
.
parseFromString
(
this
.
inputResponse
"
application
/
xml
"
)
;
}
catch
(
e
)
{
this
.
responseXML
=
null
;
}
if
(
this
.
inputStatus
=
=
=
200
)
{
this
.
_notify
(
[
"
load
"
"
loadend
"
]
)
;
}
else
{
this
.
_notify
(
[
"
error
"
"
loadend
"
]
)
;
}
}
catch
(
ex
)
{
do_throw
(
ex
)
;
}
}
)
;
}
set
onabort
(
aValue
)
{
this
.
_onabort
=
aValue
;
}
get
onabort
(
)
{
return
this
.
_onabort
;
}
set
onprogress
(
aValue
)
{
this
.
_onprogress
=
aValue
;
}
get
onprogress
(
)
{
return
this
.
_onprogress
;
}
set
onerror
(
aValue
)
{
this
.
_onerror
=
aValue
;
}
get
onerror
(
)
{
return
this
.
_onerror
;
}
set
onload
(
aValue
)
{
this
.
_onload
=
aValue
;
}
get
onload
(
)
{
return
this
.
_onload
;
}
set
onloadend
(
aValue
)
{
this
.
_onloadend
=
aValue
;
}
get
onloadend
(
)
{
return
this
.
_onloadend
;
}
set
ontimeout
(
aValue
)
{
this
.
_ontimeout
=
aValue
;
}
get
ontimeout
(
)
{
return
this
.
_ontimeout
;
}
set
timeout
(
aValue
)
{
this
.
_timeout
=
aValue
;
}
_notify
(
events
)
{
if
(
this
.
_notified
)
{
return
;
}
this
.
_notified
=
true
;
for
(
let
item
of
events
)
{
let
k
=
"
on
"
+
item
;
if
(
this
[
k
]
)
{
info
(
"
Notifying
"
+
item
)
;
let
e
=
{
target
:
this
type
:
item
}
;
this
[
k
]
(
e
)
;
}
else
{
info
(
"
Notifying
"
+
item
+
"
but
there
are
no
listeners
"
)
;
}
}
}
addEventListener
(
aEvent
aValue
aCapturing
)
{
eval
(
"
this
.
_on
"
+
aEvent
+
"
=
aValue
"
)
;
}
get
wrappedJSObject
(
)
{
return
this
;
}
}
;
function
createNewZipFile
(
zipName
data
)
{
let
stream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stream
.
setData
(
data
data
.
length
)
;
let
zipWriter
=
Cc
[
"
mozilla
.
org
/
zipwriter
;
1
"
]
.
createInstance
(
Ci
.
nsIZipWriter
)
;
let
zipFile
=
FileUtils
.
getFile
(
"
TmpD
"
[
zipName
]
)
;
if
(
zipFile
.
exists
(
)
)
{
zipFile
.
remove
(
false
)
;
}
const
PR_RDWR
=
0x04
;
const
PR_CREATE_FILE
=
0x08
;
const
PR_TRUNCATE
=
0x20
;
zipWriter
.
open
(
zipFile
PR_RDWR
|
PR_CREATE_FILE
|
PR_TRUNCATE
)
;
zipWriter
.
addEntryStream
(
"
entry1
.
info
"
Date
.
now
(
)
*
PR_USEC_PER_MSEC
Ci
.
nsIZipWriter
.
COMPRESSION_BEST
stream
false
)
;
zipWriter
.
close
(
)
;
stream
.
close
(
)
;
info
(
"
zip
file
created
on
disk
at
:
"
+
zipFile
.
path
)
;
return
zipFile
;
}
function
setupContentSigTestPrefs
(
)
{
Preferences
.
set
(
"
media
.
gmp
-
manager
.
checkContentSignature
"
true
)
;
return
Preferences
.
get
(
GMPPrefs
.
KEY_URL_OVERRIDE
"
"
)
;
}
function
revertContentSigTestPrefs
(
previousUrlOverride
)
{
if
(
previousUrlOverride
)
{
Preferences
.
set
(
GMPPrefs
.
KEY_URL_OVERRIDE
previousUrlOverride
)
;
}
else
{
Preferences
.
reset
(
GMPPrefs
.
KEY_URL_OVERRIDE
)
;
}
Preferences
.
set
(
"
media
.
gmp
-
manager
.
checkContentSignature
"
false
)
;
}
function
resetGmpTelemetryAndGetHistogram
(
)
{
Services
.
fog
.
testResetFOG
(
)
;
return
TelemetryTestUtils
.
getAndClearHistogram
(
"
MEDIA_GMP_UPDATE_XML_FETCH_RESULT
"
)
;
}
function
checkGleanMetricCounts
(
expectedGleanValues
)
{
for
(
const
property
in
expectedGleanValues
)
{
if
(
Glean
.
gmp
.
updateXmlFetchResult
[
property
]
.
testGetValue
(
)
)
{
Assert
.
equal
(
Glean
.
gmp
.
updateXmlFetchResult
[
property
]
.
testGetValue
(
)
expectedGleanValues
[
property
]
{
property
}
should
have
been
recorded
{
expectedGleanValues
[
property
]
}
times
)
;
}
else
{
Assert
.
equal
(
expectedGleanValues
[
property
]
0
"
testGetValue
(
)
being
undefined
should
mean
we
expect
a
metric
to
not
have
been
gathered
"
)
;
}
}
}
function
getTestServerForContentSignatureTests
(
)
{
const
testServer
=
new
HttpServer
(
)
;
testServer
.
start
(
)
;
const
baseUri
=
testServer
.
identity
.
primaryScheme
+
"
:
/
/
"
+
testServer
.
identity
.
primaryHost
+
"
:
"
+
testServer
.
identity
.
primaryPort
;
let
promiseHolder
=
{
}
;
const
goodXml
=
readStringFromFile
(
do_get_file
(
"
good
.
xml
"
)
)
;
const
goodXmlContentSignature
=
"
7QYnPqFoOlS02BpDdIRIljzmPr6BFwPs1z1y8KJUBlnU7EVG6FbnXmVVt5Op9wDzgvhXX7th8qFJvpPOZs_B_tHRDNJ8SK0HN95BAN15z3ZW2r95SSHmU
-
fP2JgoNOR3
"
;
const
validX5uPath
=
"
/
valid_x5u
"
;
const
validCertChain
=
[
readStringFromFile
(
do_get_file
(
"
content_signing_aus_ee
.
pem
"
)
)
readStringFromFile
(
do_get_file
(
"
content_signing_int
.
pem
"
)
)
]
;
testServer
.
registerPathHandler
(
validX5uPath
(
req
res
)
=
>
{
res
.
write
(
validCertChain
.
join
(
"
\
n
"
)
)
;
}
)
;
const
validX5uUrl
=
baseUri
+
validX5uPath
;
const
validUpdatePath
=
"
/
valid_update
.
xml
"
;
testServer
.
registerPathHandler
(
validUpdatePath
(
req
res
)
=
>
{
const
validContentSignatureHeader
=
x5u
=
{
validX5uUrl
}
;
p384ecdsa
=
{
goodXmlContentSignature
}
;
res
.
setHeader
(
"
content
-
signature
"
validContentSignatureHeader
)
;
res
.
write
(
goodXml
)
;
}
)
;
const
missingContentSigPath
=
"
/
update_missing_content_sig
.
xml
"
;
testServer
.
registerPathHandler
(
missingContentSigPath
(
req
res
)
=
>
{
res
.
write
(
goodXml
)
;
}
)
;
const
badContentSigPath
=
"
/
update_bad_content_sig
.
xml
"
;
testServer
.
registerPathHandler
(
badContentSigPath
(
req
res
)
=
>
{
res
.
setHeader
(
"
content
-
signature
"
x5u
=
{
validX5uUrl
}
;
p384ecdsa
=
I
'
m
a
bad
content
signature
)
;
res
.
write
(
goodXml
)
;
}
)
;
const
invalidXmlContentSignature
=
"
Z
"
+
goodXmlContentSignature
.
slice
(
1
)
;
const
invalidContentSigPath
=
"
/
update_invalid_content_sig
.
xml
"
;
testServer
.
registerPathHandler
(
invalidContentSigPath
(
req
res
)
=
>
{
res
.
setHeader
(
"
content
-
signature
"
x5u
=
{
validX5uUrl
}
;
p384ecdsa
=
{
invalidXmlContentSignature
}
)
;
res
.
write
(
goodXml
)
;
}
)
;
const
badXml
=
readStringFromFile
(
do_get_file
(
"
bad
.
xml
"
)
)
;
const
badXmlContentSignature
=
"
7QYnPqFoOlS02BpDdIRIljzmPr6BFwPs1z1y8KJUBlnU7EVG6FbnXmVVt5Op9wDz8YoQ_b
-
3i9rWpj40s8QZsMgo2eImx83LW9JE0d0z6sSAnwRb4lHFPpJXC_hv7wi7
"
;
const
badXmlPath
=
"
/
bad
.
xml
"
;
testServer
.
registerPathHandler
(
badXmlPath
(
req
res
)
=
>
{
const
validContentSignatureHeader
=
x5u
=
{
validX5uUrl
}
;
p384ecdsa
=
{
badXmlContentSignature
}
;
res
.
setHeader
(
"
content
-
signature
"
validContentSignatureHeader
)
;
res
.
write
(
badXml
)
;
}
)
;
const
badX5uRequestPath
=
"
/
bad_x5u_request
.
xml
"
;
testServer
.
registerPathHandler
(
badX5uRequestPath
(
req
res
)
=
>
{
const
badX5uUrlHeader
=
x5u
=
https
:
/
/
this
.
is
.
a
/
bad
/
url
;
p384ecdsa
=
{
goodXmlContentSignature
}
;
res
.
setHeader
(
"
content
-
signature
"
badX5uUrlHeader
)
;
res
.
write
(
badXml
)
;
}
)
;
const
x5uTimeoutPath
=
"
/
x5u_timeout
.
xml
"
;
testServer
.
registerPathHandler
(
x5uTimeoutPath
(
req
res
)
=
>
{
const
validContentSignatureHeader
=
x5u
=
{
validX5uUrl
}
;
p384ecdsa
=
{
goodXmlContentSignature
}
;
let
overriddenServiceRequest
=
new
mockRequest
(
200
"
"
{
dropRequest
:
true
timeout
:
true
}
)
;
promiseHolder
.
serverPromise
=
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
overriddenServiceRequest
(
)
=
>
{
res
.
setHeader
(
"
content
-
signature
"
validContentSignatureHeader
)
;
res
.
write
(
goodXml
)
;
return
promiseHolder
.
installPromise
;
}
)
;
}
)
;
const
x5uAbortPath
=
"
/
x5u_abort
.
xml
"
;
testServer
.
registerPathHandler
(
x5uAbortPath
(
req
res
)
=
>
{
const
validContentSignatureHeader
=
x5u
=
{
validX5uUrl
}
;
p384ecdsa
=
{
goodXmlContentSignature
}
;
let
overriddenServiceRequest
=
new
mockRequest
(
200
"
"
{
dropRequest
:
true
}
)
;
promiseHolder
.
serverPromise
=
ProductAddonCheckerTestUtils
.
overrideServiceRequest
(
overriddenServiceRequest
(
)
=
>
{
res
.
setHeader
(
"
content
-
signature
"
validContentSignatureHeader
)
;
res
.
write
(
goodXml
)
;
return
promiseHolder
.
installPromise
;
}
)
;
setTimeout
(
(
)
=
>
{
overriddenServiceRequest
.
abort
(
)
;
}
100
)
;
}
)
;
return
{
testServer
promiseHolder
validUpdateUri
:
baseUri
+
validUpdatePath
missingContentSigUri
:
baseUri
+
missingContentSigPath
badContentSigUri
:
baseUri
+
badContentSigPath
invalidContentSigUri
:
baseUri
+
invalidContentSigPath
badXmlUri
:
baseUri
+
badXmlPath
badX5uRequestUri
:
baseUri
+
badX5uRequestPath
x5uTimeoutUri
:
baseUri
+
x5uTimeoutPath
x5uAbortUri
:
baseUri
+
x5uAbortPath
}
;
}
