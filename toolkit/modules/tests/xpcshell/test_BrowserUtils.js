const
{
BrowserUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
sys
.
mjs
"
)
;
const
{
EnterprisePolicyTesting
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
EnterprisePolicyTesting
.
sys
.
mjs
"
)
;
const
{
Region
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Region
.
sys
.
mjs
"
)
;
const
{
updateAppInfo
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
sys
.
mjs
"
)
;
function
setupRegions
(
home
current
)
{
Region
.
_setHomeRegion
(
home
|
|
"
"
)
;
Region
.
_setCurrentRegion
(
current
|
|
"
"
)
;
}
function
setLanguage
(
language
)
{
Services
.
locale
.
availableLocales
=
[
language
]
;
Services
.
locale
.
requestedLocales
=
[
language
]
;
}
async
function
setupEnterprisePolicy
(
)
{
updateAppInfo
(
{
name
:
"
XPCShell
"
}
)
;
await
EnterprisePolicyTesting
.
setupPolicyEngineWithJson
(
{
policies
:
{
EnableTrackingProtection
:
{
Value
:
true
}
}
}
)
;
}
add_task
(
async
function
test_shouldShowVPNPromo
(
)
{
function
setPromoEnabled
(
enabled
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
vpn_promo
.
enabled
"
enabled
)
;
}
const
allowedRegion
=
"
US
"
;
const
disallowedRegion
=
"
SY
"
;
const
illegalRegion
=
"
CN
"
;
const
unsupportedRegion
=
"
LY
"
;
const
regionNotInDefaultPref
=
"
QQ
"
;
setupRegions
(
allowedRegion
allowedRegion
)
;
Assert
.
ok
(
BrowserUtils
.
shouldShowVPNPromo
(
)
)
;
setPromoEnabled
(
false
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowVPNPromo
(
)
)
;
setPromoEnabled
(
true
)
;
setupRegions
(
disallowedRegion
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowVPNPromo
(
)
)
;
setupRegions
(
illegalRegion
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowVPNPromo
(
)
)
;
setupRegions
(
allowedRegion
disallowedRegion
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowVPNPromo
(
)
)
;
setupRegions
(
allowedRegion
illegalRegion
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowVPNPromo
(
)
)
;
setupRegions
(
allowedRegion
unsupportedRegion
)
;
Assert
.
ok
(
BrowserUtils
.
shouldShowVPNPromo
(
)
)
;
setupRegions
(
unsupportedRegion
allowedRegion
)
;
Assert
.
ok
(
BrowserUtils
.
shouldShowVPNPromo
(
)
)
;
setupRegions
(
regionNotInDefaultPref
)
;
Services
.
prefs
.
setStringPref
(
"
browser
.
contentblocking
.
report
.
vpn_regions
"
"
qq
"
)
;
Assert
.
ok
(
BrowserUtils
.
shouldShowVPNPromo
(
)
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
contentblocking
.
report
.
vpn_regions
"
)
;
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
setupRegions
(
allowedRegion
allowedRegion
)
;
await
setupEnterprisePolicy
(
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowVPNPromo
(
)
)
;
await
EnterprisePolicyTesting
.
setupPolicyEngineWithJson
(
"
"
)
;
}
}
)
;
add_task
(
async
function
test_sendToDeviceEmailsSupported
(
)
{
const
allowedLanguage
=
"
en
-
US
"
;
const
disallowedLanguage
=
"
ar
"
;
setLanguage
(
allowedLanguage
)
;
Assert
.
ok
(
BrowserUtils
.
sendToDeviceEmailsSupported
(
)
)
;
setLanguage
(
disallowedLanguage
)
;
Assert
.
ok
(
!
BrowserUtils
.
sendToDeviceEmailsSupported
(
)
)
;
}
)
;
add_task
(
async
function
test_shouldShowFocusPromo
(
)
{
const
allowedRegion
=
"
US
"
;
const
disallowedRegion
=
"
CN
"
;
setupRegions
(
allowedRegion
allowedRegion
)
;
Assert
.
ok
(
BrowserUtils
.
shouldShowPromo
(
BrowserUtils
.
PromoType
.
FOCUS
)
)
;
setupRegions
(
disallowedRegion
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowPromo
(
BrowserUtils
.
PromoType
.
FOCUS
)
)
;
setupRegions
(
allowedRegion
allowedRegion
)
;
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
await
setupEnterprisePolicy
(
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowPromo
(
BrowserUtils
.
PromoType
.
FOCUS
)
)
;
await
EnterprisePolicyTesting
.
setupPolicyEngineWithJson
(
"
"
)
;
}
Preferences
.
set
(
"
browser
.
promo
.
focus
.
enabled
"
false
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowPromo
(
BrowserUtils
.
PromoType
.
FOCUS
)
)
;
Preferences
.
resetBranch
(
"
browser
.
promo
.
focus
"
)
;
}
)
;
add_task
(
async
function
test_shouldShowPinPromo
(
)
{
Preferences
.
set
(
"
browser
.
promo
.
pin
.
enabled
"
true
)
;
Assert
.
ok
(
BrowserUtils
.
shouldShowPromo
(
BrowserUtils
.
PromoType
.
PIN
)
)
;
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
await
setupEnterprisePolicy
(
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowPromo
(
BrowserUtils
.
PromoType
.
PIN
)
)
;
await
EnterprisePolicyTesting
.
setupPolicyEngineWithJson
(
"
"
)
;
}
Preferences
.
set
(
"
browser
.
promo
.
pin
.
enabled
"
false
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowPromo
(
BrowserUtils
.
PromoType
.
PIN
)
)
;
Preferences
.
resetBranch
(
"
browser
.
promo
.
pin
"
)
;
}
)
;
add_task
(
async
function
test_shouldShowRelayPromo
(
)
{
Preferences
.
set
(
"
identity
.
fxaccounts
.
autoconfig
.
uri
"
"
"
)
;
Assert
.
ok
(
BrowserUtils
.
shouldShowPromo
(
BrowserUtils
.
PromoType
.
RELAY
)
)
;
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
await
setupEnterprisePolicy
(
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowPromo
(
BrowserUtils
.
PromoType
.
RELAY
)
)
;
await
EnterprisePolicyTesting
.
setupPolicyEngineWithJson
(
"
"
)
;
}
Preferences
.
set
(
"
identity
.
fxaccounts
.
autoconfig
.
uri
"
"
https
:
/
/
x
"
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowPromo
(
BrowserUtils
.
PromoType
.
RELAY
)
)
;
Preferences
.
reset
(
"
identity
.
fxaccounts
.
autoconfig
.
uri
"
)
;
}
)
;
add_task
(
async
function
test_shouldShowCookieBannersPromo
(
)
{
Preferences
.
set
(
"
browser
.
promo
.
cookiebanners
.
enabled
"
true
)
;
Assert
.
ok
(
BrowserUtils
.
shouldShowPromo
(
BrowserUtils
.
PromoType
.
COOKIE_BANNERS
)
)
;
Preferences
.
set
(
"
browser
.
promo
.
cookiebanners
.
enabled
"
false
)
;
Assert
.
ok
(
!
BrowserUtils
.
shouldShowPromo
(
BrowserUtils
.
PromoType
.
COOKIE_BANNERS
)
)
;
Preferences
.
resetBranch
(
"
browser
.
promo
.
cookiebanners
"
)
;
}
)
;
add_task
(
function
test_getShareableURL
(
)
{
if
(
!
Preferences
.
get
(
"
services
.
sync
.
engine
.
tabs
.
filteredSchemes
"
)
)
{
Preferences
.
set
(
"
services
.
sync
.
engine
.
tabs
.
filteredSchemes
"
"
about
|
resource
|
chrome
|
file
|
blob
|
moz
-
extension
|
data
"
)
;
}
Assert
.
ok
(
!
BrowserUtils
.
getShareableURL
(
"
"
)
)
;
let
good
=
Services
.
io
.
newURI
(
"
https
:
/
/
mozilla
.
org
"
)
;
Assert
.
ok
(
BrowserUtils
.
getShareableURL
(
good
)
.
equals
(
good
)
)
;
Assert
.
ok
(
!
BrowserUtils
.
getShareableURL
(
Services
.
io
.
newURI
(
"
file
:
/
/
path
/
to
/
pdf
.
pdf
"
)
)
)
;
Assert
.
ok
(
!
BrowserUtils
.
getShareableURL
(
Services
.
io
.
newURI
(
"
data
:
application
/
json
;
base64
ewogICJ0eXBlIjogIm1haW4i
=
=
"
)
)
)
;
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
let
readerUrl
=
Services
.
io
.
newURI
(
"
about
:
reader
?
url
=
"
+
encodeURIComponent
(
"
http
:
/
/
foo
.
com
/
"
)
)
;
Assert
.
equal
(
BrowserUtils
.
getShareableURL
(
readerUrl
)
.
spec
"
http
:
/
/
foo
.
com
/
"
)
;
}
}
)
;
add_task
(
async
function
test_callModulesFromCategory
(
)
{
const
MODULE1
=
"
resource
:
/
/
test
/
my_catman_1
.
sys
.
mjs
"
;
const
MODULE2
=
"
resource
:
/
/
test
/
my_catman_2
.
sys
.
mjs
"
;
const
CATEGORY
=
"
test
-
modules
-
from
-
catman
"
;
const
OBSTOPIC1
=
CATEGORY
+
"
-
notification
"
;
const
OBSTOPIC2
=
CATEGORY
+
"
-
other
-
notification
"
;
let
rvFromModule
=
topic
=
>
TestUtils
.
topicObserved
(
topic
)
.
then
(
(
[
_subj
data
]
)
=
>
data
)
;
Assert
.
equal
(
Cu
.
isESModuleLoaded
(
MODULE1
)
false
"
First
module
should
not
be
loaded
.
"
)
;
let
catEntries
=
Array
.
from
(
Services
.
catMan
.
enumerateCategory
(
CATEGORY
)
)
;
Assert
.
deepEqual
(
catEntries
[
]
"
Should
be
no
entries
for
this
category
.
"
)
;
try
{
BrowserUtils
.
callModulesFromCategory
(
{
categoryName
:
CATEGORY
}
"
Hello
"
)
;
}
catch
(
ex
)
{
Assert
.
ok
(
false
Should
not
have
thrown
but
received
an
exception
{
ex
}
)
;
}
let
catManUpdated
=
TestUtils
.
topicObserved
(
"
xpcom
-
category
-
entry
-
added
"
)
;
Services
.
catMan
.
addCategoryEntry
(
CATEGORY
MODULE1
Module1
.
test
false
false
)
;
catEntries
=
Array
.
from
(
Services
.
catMan
.
enumerateCategory
(
CATEGORY
)
)
;
Assert
.
equal
(
catEntries
.
length
1
)
;
await
catManUpdated
;
Assert
.
equal
(
Cu
.
isESModuleLoaded
(
MODULE1
)
false
"
First
module
should
still
not
be
loaded
.
"
)
;
let
moduleResult
=
rvFromModule
(
OBSTOPIC1
)
;
BrowserUtils
.
callModulesFromCategory
(
{
categoryName
:
CATEGORY
}
"
Hello
"
)
;
Assert
.
equal
(
Cu
.
isESModuleLoaded
(
MODULE1
)
true
"
First
module
should
be
loaded
sync
.
"
)
;
Assert
.
equal
(
"
Hello
"
await
moduleResult
"
Should
have
been
called
.
"
)
;
catManUpdated
=
TestUtils
.
topicObserved
(
"
xpcom
-
category
-
entry
-
added
"
)
;
Services
.
catMan
.
addCategoryEntry
(
CATEGORY
MODULE2
Module2
.
othertest
false
false
)
;
await
catManUpdated
;
moduleResult
=
Promise
.
all
(
[
rvFromModule
(
OBSTOPIC1
)
rvFromModule
(
OBSTOPIC2
)
]
)
;
BrowserUtils
.
callModulesFromCategory
(
{
categoryName
:
CATEGORY
}
"
Hello
"
)
;
Assert
.
deepEqual
(
[
"
Hello
"
"
Hello
"
]
await
moduleResult
"
Both
modules
should
have
been
called
.
"
)
;
catManUpdated
=
TestUtils
.
topicObserved
(
"
xpcom
-
category
-
entry
-
removed
"
)
;
Services
.
catMan
.
deleteCategoryEntry
(
CATEGORY
MODULE1
false
)
;
await
catManUpdated
;
let
ob
=
(
)
=
>
Assert
.
ok
(
false
"
I
shouldn
'
t
be
called
.
"
)
;
Services
.
obs
.
addObserver
(
ob
OBSTOPIC1
)
;
moduleResult
=
rvFromModule
(
OBSTOPIC2
)
;
BrowserUtils
.
callModulesFromCategory
(
{
categoryName
:
CATEGORY
}
"
Hello
"
)
;
Assert
.
equal
(
"
Hello
"
await
moduleResult
"
Second
module
should
still
be
called
.
"
)
;
let
idleResult
=
null
;
let
idlePromise
=
TestUtils
.
topicObserved
(
OBSTOPIC2
)
.
then
(
(
[
_subj
data
]
)
=
>
{
idleResult
=
data
;
return
data
;
}
)
;
BrowserUtils
.
callModulesFromCategory
(
{
categoryName
:
CATEGORY
idleDispatch
:
true
}
"
Hello
"
)
;
Assert
.
equal
(
idleResult
null
"
Idle
calls
should
not
happen
immediately
.
"
)
;
Assert
.
equal
(
"
Hello
"
await
idlePromise
"
Idle
calls
should
run
eventually
.
"
)
;
Services
.
obs
.
removeObserver
(
ob
OBSTOPIC1
)
;
Services
.
catMan
.
deleteCategory
(
CATEGORY
)
;
}
)
;
add_task
(
async
function
test_callModulesFromCategory_errors
(
)
{
const
OTHER_CAT
=
"
someothercat
"
;
const
MODULE1
=
"
resource
:
/
/
test
/
my_catman_1
.
sys
.
mjs
"
;
let
catManUpdated
=
TestUtils
.
topicObserved
(
"
xpcom
-
category
-
entry
-
added
"
)
;
Services
.
catMan
.
addCategoryEntry
(
OTHER_CAT
MODULE1
Module1
.
nonExistantFunction
false
false
)
;
await
catManUpdated
;
let
catEntries
=
Array
.
from
(
Services
.
catMan
.
enumerateCategory
(
OTHER_CAT
)
)
;
Assert
.
equal
(
catEntries
.
length
1
)
;
let
consolePromise
=
TestUtils
.
consoleMessageObserved
(
m
=
>
{
let
firstArg
=
m
.
wrappedJSObject
.
arguments
?
.
[
0
]
?
.
message
;
return
typeof
firstArg
=
=
"
string
"
&
&
firstArg
.
includes
(
"
not
a
function
"
)
;
}
)
;
BrowserUtils
.
callModulesFromCategory
(
{
categoryName
:
OTHER_CAT
}
"
Hello
"
)
;
let
reportedError
=
await
consolePromise
;
let
firstArg
=
reportedError
.
wrappedJSObject
.
arguments
?
.
[
0
]
?
.
message
;
Assert
.
stringContains
(
firstArg
MODULE1
"
Error
message
should
include
module
URL
.
"
)
;
Services
.
catMan
.
deleteCategoryEntry
(
OTHER_CAT
MODULE1
false
)
;
catManUpdated
=
TestUtils
.
topicObserved
(
"
xpcom
-
category
-
entry
-
added
"
)
;
Services
.
catMan
.
addCategoryEntry
(
OTHER_CAT
MODULE1
Module1
.
throwingFunction
false
false
)
;
await
catManUpdated
;
Assert
.
equal
(
catEntries
.
length
1
)
;
let
exHandler
=
Promise
.
withResolvers
(
)
;
BrowserUtils
.
callModulesFromCategory
(
{
categoryName
:
OTHER_CAT
failureHandler
:
exHandler
.
resolve
}
)
;
let
caughtException
=
await
exHandler
.
promise
;
Assert
.
stringContains
(
caughtException
.
message
"
Uh
oh
"
"
Exceptions
should
be
handled
.
"
)
;
Services
.
catMan
.
deleteCategory
(
OTHER_CAT
)
;
}
)
;
add_task
(
async
function
test_callModulesFromCategory_returns_promise
(
)
{
const
CATEGORY
=
"
test
-
modules
-
from
-
catman
"
;
const
MODULE1
=
"
resource
:
/
/
test
/
my_catman_1
.
sys
.
mjs
"
;
const
OBSTOPIC1
=
CATEGORY
+
"
-
notification
"
;
let
catManUpdated
=
TestUtils
.
topicObserved
(
"
xpcom
-
category
-
entry
-
added
"
)
;
Services
.
catMan
.
addCategoryEntry
(
CATEGORY
MODULE1
Module1
.
test
false
false
)
;
await
catManUpdated
;
let
moduleResult
=
TestUtils
.
topicObserved
(
OBSTOPIC1
)
.
then
(
(
[
_subj
data
]
)
=
>
data
)
;
let
result
=
BrowserUtils
.
callModulesFromCategory
(
{
categoryName
:
CATEGORY
}
"
Hello
"
)
;
Assert
.
ok
(
result
.
then
"
Should
return
a
Promise
"
)
;
let
settledResults
=
await
result
;
Assert
.
ok
(
Array
.
isArray
(
settledResults
)
"
Should
return
an
array
of
results
"
)
;
Assert
.
equal
(
settledResults
.
length
1
"
Should
have
one
result
"
)
;
Assert
.
equal
(
settledResults
[
0
]
.
status
"
fulfilled
"
"
Task
should
have
been
fulfilled
"
)
;
Assert
.
equal
(
await
moduleResult
"
Hello
"
"
Module
should
have
been
called
"
)
;
Services
.
catMan
.
deleteCategory
(
CATEGORY
)
;
}
)
;
