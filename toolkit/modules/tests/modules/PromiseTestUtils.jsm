"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PromiseTestUtils
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
Assert
.
jsm
"
this
)
;
let
JSMPromise
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
{
}
)
.
Promise
;
var
PromiseTestUtils
=
{
_rejections
:
[
]
_rejectionIgnoreFns
:
[
]
_globalRejectionIgnoreFns
:
[
]
init
(
)
{
if
(
this
.
_initialized
)
{
Cu
.
reportError
(
"
This
object
was
already
initialized
.
"
)
;
return
;
}
PromiseDebugging
.
addUncaughtRejectionObserver
(
this
)
;
JSMPromise
.
Debugging
.
addUncaughtErrorObserver
(
rejection
=
>
this
.
_rejections
.
push
(
rejection
)
)
;
this
.
_initialized
=
true
;
}
_initialized
:
false
uninit
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
PromiseDebugging
.
removeUncaughtRejectionObserver
(
this
)
;
JSMPromise
.
Debugging
.
clearUncaughtErrorObservers
(
)
;
this
.
_initialized
=
false
;
}
ensureDOMPromiseRejectionsProcessed
(
)
{
let
observed
=
false
;
let
observer
=
{
onLeftUncaught
:
promise
=
>
{
if
(
PromiseDebugging
.
getState
(
promise
)
.
reason
=
=
=
this
.
_ensureDOMPromiseRejectionsProcessedReason
)
{
observed
=
true
;
}
}
onConsumed
(
)
{
}
}
;
PromiseDebugging
.
addUncaughtRejectionObserver
(
observer
)
;
Promise
.
reject
(
this
.
_ensureDOMPromiseRejectionsProcessedReason
)
;
Services
.
tm
.
spinEventLoopUntil
(
(
)
=
>
observed
)
;
PromiseDebugging
.
removeUncaughtRejectionObserver
(
observer
)
;
}
_ensureDOMPromiseRejectionsProcessedReason
:
{
}
disableUncaughtRejectionObserverForSelfTest
(
)
{
this
.
uninit
(
)
;
}
thisTestLeaksUncaughtRejectionsAndShouldBeFixed
(
)
{
this
.
uninit
(
)
;
}
onLeftUncaught
(
promise
)
{
let
message
=
"
(
Unable
to
convert
rejection
reason
to
string
.
)
"
;
let
reason
=
null
;
try
{
reason
=
PromiseDebugging
.
getState
(
promise
)
.
reason
;
if
(
reason
=
=
=
this
.
_ensureDOMPromiseRejectionsProcessedReason
)
{
return
;
}
message
=
reason
.
message
|
|
"
"
+
reason
;
}
catch
(
ex
)
{
}
let
stack
=
"
(
Unable
to
convert
rejection
stack
to
string
.
)
"
;
try
{
stack
=
"
"
+
(
(
reason
&
&
reason
.
stack
)
|
|
PromiseDebugging
.
getRejectionStack
(
promise
)
|
|
"
(
No
stack
available
.
)
"
)
;
}
catch
(
ex
)
{
}
if
(
!
stack
.
endsWith
(
"
\
n
"
)
)
{
stack
+
=
"
\
n
"
;
}
this
.
_rejections
.
push
(
{
id
:
PromiseDebugging
.
getPromiseID
(
promise
)
message
date
:
new
Date
(
)
stack
}
)
;
}
onConsumed
(
promise
)
{
let
id
=
PromiseDebugging
.
getPromiseID
(
promise
)
;
let
index
=
this
.
_rejections
.
findIndex
(
rejection
=
>
rejection
.
id
=
=
id
)
;
if
(
index
!
=
-
1
)
{
this
.
_rejections
.
splice
(
index
1
)
;
}
}
expectUncaughtRejection
(
regExpOrCheckFn
)
{
let
checkFn
=
!
(
"
test
"
in
regExpOrCheckFn
)
?
regExpOrCheckFn
:
rejection
=
>
regExpOrCheckFn
.
test
(
rejection
.
message
)
;
this
.
_rejectionIgnoreFns
.
push
(
checkFn
)
;
}
whitelistRejectionsGlobally
(
regExp
)
{
this
.
_globalRejectionIgnoreFns
.
push
(
rejection
=
>
regExp
.
test
(
rejection
.
message
)
)
;
}
assertNoUncaughtRejections
(
)
{
JSMPromise
.
Debugging
.
flushUncaughtErrors
(
)
;
while
(
this
.
_rejections
.
length
>
0
)
{
let
rejection
=
this
.
_rejections
.
shift
(
)
;
let
index
=
this
.
_rejectionIgnoreFns
.
findIndex
(
f
=
>
f
(
rejection
)
)
;
if
(
index
!
=
-
1
)
{
this
.
_rejectionIgnoreFns
.
splice
(
index
1
)
;
continue
;
}
if
(
this
.
_globalRejectionIgnoreFns
.
some
(
fn
=
>
fn
(
rejection
)
)
)
{
continue
;
}
Assert
.
ok
(
false
A
promise
chain
failed
to
handle
a
rejection
:
+
{
rejection
.
message
}
-
stack
:
{
rejection
.
stack
}
+
Rejection
date
:
{
rejection
.
date
}
)
;
}
}
assertNoMoreExpectedRejections
(
)
{
if
(
this
.
_rejectionIgnoreFns
.
length
>
0
)
{
Assert
.
equal
(
this
.
_rejectionIgnoreFns
.
length
0
"
Unable
to
find
a
rejection
expected
by
expectUncaughtRejection
.
"
)
;
}
this
.
_rejectionIgnoreFns
=
[
]
;
}
}
;
