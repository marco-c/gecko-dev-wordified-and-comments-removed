"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
OS
"
]
;
var
SharedAll
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
/
osfile_shared_allthreads
.
jsm
"
SharedAll
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
this
)
;
var
LOG
=
SharedAll
.
LOG
.
bind
(
SharedAll
"
Controller
"
)
;
var
isTypedArray
=
SharedAll
.
isTypedArray
;
var
SysAll
=
{
}
;
if
(
SharedAll
.
Constants
.
Win
)
{
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
/
osfile_win_allthreads
.
jsm
"
SysAll
)
;
}
else
if
(
SharedAll
.
Constants
.
libc
)
{
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
/
osfile_unix_allthreads
.
jsm
"
SysAll
)
;
}
else
{
throw
new
Error
(
"
I
am
neither
under
Windows
nor
under
a
Posix
system
"
)
;
}
var
OSError
=
SysAll
.
Error
;
var
Type
=
SysAll
.
Type
;
var
Path
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
/
ospath
.
jsm
"
Path
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseWorker
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
this
)
;
var
Native
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
/
osfile_native
.
jsm
"
{
}
)
;
function
lazyPathGetter
(
constProp
dirKey
)
{
return
function
(
)
{
let
path
;
try
{
path
=
Services
.
dirsvc
.
get
(
dirKey
Ci
.
nsIFile
)
.
path
;
delete
SharedAll
.
Constants
.
Path
[
constProp
]
;
SharedAll
.
Constants
.
Path
[
constProp
]
=
path
;
}
catch
(
ex
)
{
}
return
path
;
}
;
}
for
(
let
[
constProp
dirKey
]
of
[
[
"
localProfileDir
"
"
ProfLD
"
]
[
"
profileDir
"
"
ProfD
"
]
[
"
userApplicationDataDir
"
"
UAppData
"
]
[
"
winAppDataDir
"
"
AppData
"
]
[
"
winLocalAppDataDir
"
"
LocalAppData
"
]
[
"
winStartMenuProgsDir
"
"
Progs
"
]
]
)
{
if
(
constProp
in
SharedAll
.
Constants
.
Path
)
{
continue
;
}
LOG
(
"
Installing
lazy
getter
for
OS
.
Constants
.
Path
.
"
+
constProp
+
"
because
it
isn
'
t
defined
and
profile
may
not
be
loaded
.
"
)
;
Object
.
defineProperty
(
SharedAll
.
Constants
.
Path
constProp
{
get
:
lazyPathGetter
(
constProp
dirKey
)
}
)
;
}
var
clone
=
SharedAll
.
clone
;
function
summarizeObject
(
obj
)
{
if
(
!
obj
)
{
return
null
;
}
if
(
typeof
obj
=
=
"
string
"
)
{
if
(
obj
.
length
>
1024
)
{
return
{
"
Long
string
"
:
obj
.
length
}
;
}
return
obj
;
}
if
(
typeof
obj
=
=
"
object
"
)
{
if
(
Array
.
isArray
(
obj
)
)
{
if
(
obj
.
length
>
32
)
{
return
{
"
Long
array
"
:
obj
.
length
}
;
}
return
obj
.
map
(
summarizeObject
)
;
}
if
(
"
byteLength
"
in
obj
)
{
return
{
"
Binary
Data
"
:
obj
.
byteLength
}
;
}
let
result
=
{
}
;
for
(
let
k
of
Object
.
keys
(
obj
)
)
{
result
[
k
]
=
summarizeObject
(
obj
[
k
]
)
;
}
return
result
;
}
return
obj
;
}
var
Scheduler
=
this
.
Scheduler
=
{
launched
:
false
shutdown
:
false
queue
:
Promise
.
resolve
(
)
_killQueue
:
Promise
.
resolve
(
)
Debugging
:
{
latestSent
:
undefined
latestReceived
:
undefined
messagesSent
:
0
messagesQueued
:
0
messagesReceived
:
0
}
resetTimer
:
null
hasRecentActivity
:
false
get
worker
(
)
{
if
(
!
this
.
_worker
)
{
this
.
_worker
=
new
BasePromiseWorker
(
"
resource
:
/
/
gre
/
modules
/
osfile
/
osfile_async_worker
.
js
"
)
;
this
.
_worker
.
log
=
LOG
;
this
.
_worker
.
ExceptionHandlers
[
"
OS
.
File
.
Error
"
]
=
OSError
.
fromMsg
;
let
delay
=
Services
.
prefs
.
getIntPref
(
"
osfile
.
reset_worker_delay
"
0
)
;
if
(
delay
)
{
this
.
resetTimer
=
setInterval
(
(
)
=
>
{
if
(
this
.
hasRecentActivity
)
{
this
.
hasRecentActivity
=
false
;
return
;
}
clearInterval
(
this
.
resetTimer
)
;
Scheduler
.
kill
(
{
reset
:
true
shutdown
:
false
}
)
;
}
delay
)
;
}
}
return
this
.
_worker
;
}
_worker
:
null
restartTimer
(
arg
)
{
this
.
hasRecentActivity
=
true
;
}
kill
(
{
shutdown
reset
}
)
{
let
killQueue
=
this
.
_killQueue
;
let
deferred
=
PromiseUtils
.
defer
(
)
;
let
savedQueue
=
this
.
queue
;
this
.
queue
=
deferred
.
promise
;
return
this
.
_killQueue
=
(
async
(
)
=
>
{
await
killQueue
;
await
savedQueue
;
try
{
if
(
!
this
.
launched
|
|
this
.
shutdown
|
|
!
this
.
_worker
)
{
this
.
shutdown
=
this
.
shutdown
|
|
shutdown
;
this
.
_worker
=
null
;
return
null
;
}
let
message
=
[
"
Meta_shutdown
"
[
reset
]
]
;
Scheduler
.
latestReceived
=
[
]
;
let
stack
=
new
Error
(
)
.
stack
;
if
(
stack
.
includes
(
"
/
Task
.
jsm
:
"
)
)
stack
=
Task
.
Debugging
.
generateReadableStack
(
stack
)
;
Scheduler
.
latestSent
=
[
Date
.
now
(
)
stack
.
.
.
message
]
;
let
resources
;
try
{
resources
=
await
this
.
_worker
.
post
(
.
.
.
message
)
;
Scheduler
.
latestReceived
=
[
Date
.
now
(
)
message
]
;
}
catch
(
ex
)
{
LOG
(
"
Could
not
dispatch
Meta_reset
"
ex
)
;
resources
=
{
openedFiles
:
[
]
openedDirectoryIterators
:
[
]
killed
:
true
}
;
Scheduler
.
latestReceived
=
[
Date
.
now
(
)
message
ex
]
;
}
let
{
openedFiles
openedDirectoryIterators
killed
}
=
resources
;
if
(
!
reset
&
&
(
openedFiles
&
&
openedFiles
.
length
|
|
(
openedDirectoryIterators
&
&
openedDirectoryIterators
.
length
)
)
)
{
let
msg
=
"
"
;
if
(
openedFiles
.
length
>
0
)
{
msg
+
=
"
The
following
files
are
still
open
:
\
n
"
+
openedFiles
.
join
(
"
\
n
"
)
;
}
if
(
openedDirectoryIterators
.
length
>
0
)
{
msg
+
=
"
The
following
directory
iterators
are
still
open
:
\
n
"
+
openedDirectoryIterators
.
join
(
"
\
n
"
)
;
}
LOG
(
"
WARNING
:
File
descriptors
leaks
detected
.
\
n
"
+
msg
)
;
}
if
(
killed
|
|
shutdown
)
{
this
.
_worker
=
null
;
}
this
.
shutdown
=
shutdown
;
return
resources
;
}
finally
{
deferred
.
resolve
(
)
;
}
}
)
(
)
;
}
push
(
code
)
{
let
promise
=
this
.
queue
.
then
(
code
)
;
this
.
queue
=
promise
.
catch
(
(
)
=
>
undefined
)
;
return
promise
.
then
(
)
;
}
post
:
function
post
(
method
args
=
undefined
closure
=
undefined
)
{
if
(
this
.
shutdown
)
{
LOG
(
"
OS
.
File
is
not
available
anymore
.
The
following
request
has
been
rejected
.
"
method
args
)
;
return
Promise
.
reject
(
new
Error
(
"
OS
.
File
has
been
shut
down
.
Rejecting
post
to
"
+
method
)
)
;
}
let
firstLaunch
=
!
this
.
launched
;
this
.
launched
=
true
;
if
(
firstLaunch
&
&
SharedAll
.
Config
.
DEBUG
)
{
this
.
worker
.
post
(
"
SET_DEBUG
"
[
true
]
)
;
Scheduler
.
Debugging
.
messagesSent
+
+
;
}
Scheduler
.
Debugging
.
messagesQueued
+
+
;
return
this
.
push
(
async
(
)
=
>
{
if
(
this
.
shutdown
)
{
LOG
(
"
OS
.
File
is
not
available
anymore
.
The
following
request
has
been
rejected
.
"
method
args
)
;
throw
new
Error
(
"
OS
.
File
has
been
shut
down
.
Rejecting
request
to
"
+
method
)
;
}
Scheduler
.
Debugging
.
latestReceived
=
null
;
Scheduler
.
Debugging
.
latestSent
=
[
Date
.
now
(
)
method
summarizeObject
(
args
)
]
;
Scheduler
.
restartTimer
(
)
;
let
options
=
null
;
if
(
args
&
&
args
.
length
>
=
1
&
&
typeof
args
[
args
.
length
-
1
]
=
=
=
"
object
"
)
{
options
=
args
[
args
.
length
-
1
]
;
}
let
reply
;
try
{
try
{
Scheduler
.
Debugging
.
messagesSent
+
+
;
Scheduler
.
Debugging
.
latestSent
=
Scheduler
.
Debugging
.
latestSent
.
slice
(
0
2
)
;
let
serializationStartTimeMs
=
Date
.
now
(
)
;
reply
=
await
this
.
worker
.
post
(
method
args
closure
)
;
let
serializationEndTimeMs
=
Date
.
now
(
)
;
Scheduler
.
Debugging
.
latestReceived
=
[
Date
.
now
(
)
summarizeObject
(
reply
)
]
;
if
(
options
&
&
"
outSerializationDuration
"
in
options
)
{
let
serializationDurationMs
=
Math
.
max
(
0
serializationEndTimeMs
-
serializationStartTimeMs
)
;
if
(
typeof
options
.
outSerializationDuration
=
=
=
"
number
"
)
{
options
.
outSerializationDuration
+
=
serializationDurationMs
;
}
else
{
options
.
outSerializationDuration
=
serializationDurationMs
;
}
}
return
reply
;
}
finally
{
Scheduler
.
Debugging
.
messagesReceived
+
+
;
}
}
catch
(
error
)
{
Scheduler
.
Debugging
.
latestReceived
=
[
Date
.
now
(
)
error
.
message
error
.
fileName
error
.
lineNumber
]
;
throw
error
;
}
finally
{
if
(
firstLaunch
)
{
Scheduler
.
_updateTelemetry
(
)
;
}
Scheduler
.
restartTimer
(
)
;
}
}
)
;
}
_updateTelemetry
(
)
{
let
worker
=
this
.
worker
;
let
workerTimeStamps
=
worker
.
workerTimeStamps
;
if
(
!
workerTimeStamps
)
{
return
;
}
let
HISTOGRAM_LAUNCH
=
Services
.
telemetry
.
getHistogramById
(
"
OSFILE_WORKER_LAUNCH_MS
"
)
;
HISTOGRAM_LAUNCH
.
add
(
worker
.
workerTimeStamps
.
entered
-
worker
.
launchTimeStamp
)
;
let
HISTOGRAM_READY
=
Services
.
telemetry
.
getHistogramById
(
"
OSFILE_WORKER_READY_MS
"
)
;
HISTOGRAM_READY
.
add
(
worker
.
workerTimeStamps
.
loaded
-
worker
.
launchTimeStamp
)
;
}
}
;
const
PREF_OSFILE_LOG
=
"
toolkit
.
osfile
.
log
"
;
const
PREF_OSFILE_LOG_REDIRECT
=
"
toolkit
.
osfile
.
log
.
redirect
"
;
function
readDebugPref
(
prefName
oldPref
=
false
)
{
return
Services
.
prefs
.
getBoolPref
(
prefName
oldPref
)
;
}
Services
.
prefs
.
addObserver
(
PREF_OSFILE_LOG
function
prefObserver
(
aSubject
aTopic
aData
)
{
SharedAll
.
Config
.
DEBUG
=
readDebugPref
(
PREF_OSFILE_LOG
SharedAll
.
Config
.
DEBUG
)
;
if
(
Scheduler
.
launched
)
{
Scheduler
.
post
(
"
SET_DEBUG
"
[
SharedAll
.
Config
.
DEBUG
]
)
;
}
}
)
;
SharedAll
.
Config
.
DEBUG
=
readDebugPref
(
PREF_OSFILE_LOG
false
)
;
Services
.
prefs
.
addObserver
(
PREF_OSFILE_LOG_REDIRECT
function
prefObserver
(
aSubject
aTopic
aData
)
{
SharedAll
.
Config
.
TEST
=
readDebugPref
(
PREF_OSFILE_LOG_REDIRECT
OS
.
Shared
.
TEST
)
;
}
)
;
SharedAll
.
Config
.
TEST
=
readDebugPref
(
PREF_OSFILE_LOG_REDIRECT
false
)
;
var
nativeWheneverAvailable
=
true
;
const
PREF_OSFILE_NATIVE
=
"
toolkit
.
osfile
.
native
"
;
Services
.
prefs
.
addObserver
(
PREF_OSFILE_NATIVE
function
prefObserver
(
aSubject
aTopic
aData
)
{
nativeWheneverAvailable
=
readDebugPref
(
PREF_OSFILE_NATIVE
nativeWheneverAvailable
)
;
}
)
;
if
(
SharedAll
.
Config
.
DEBUG
&
&
Scheduler
.
launched
)
{
Scheduler
.
post
(
"
SET_DEBUG
"
[
true
]
)
;
}
const
PREF_OSFILE_TEST_SHUTDOWN_OBSERVER
=
"
toolkit
.
osfile
.
test
.
shutdown
.
observer
"
;
AsyncShutdown
.
webWorkersShutdown
.
addBlocker
(
"
OS
.
File
:
flush
pending
requests
warn
about
unclosed
files
shut
down
service
.
"
async
function
(
)
{
await
Barriers
.
shutdown
.
wait
(
{
crashAfterMS
:
null
}
)
;
await
Scheduler
.
kill
(
{
reset
:
false
shutdown
:
true
}
)
;
}
(
)
=
>
{
let
details
=
Barriers
.
getDetails
(
)
;
details
.
clients
=
Barriers
.
shutdown
.
state
;
return
details
;
}
)
;
Services
.
prefs
.
addObserver
(
PREF_OSFILE_TEST_SHUTDOWN_OBSERVER
function
prefObserver
(
)
{
let
TOPIC
=
Services
.
prefs
.
getCharPref
(
PREF_OSFILE_TEST_SHUTDOWN_OBSERVER
"
"
)
;
if
(
TOPIC
)
{
let
phase
=
AsyncShutdown
.
_getPhase
(
TOPIC
)
;
phase
.
addBlocker
(
"
(
for
testing
purposes
)
OS
.
File
:
warn
about
unclosed
files
"
(
)
=
>
Scheduler
.
kill
(
{
shutdown
:
false
reset
:
false
}
)
)
;
}
}
)
;
var
File
=
function
File
(
fdmsg
)
{
this
.
_fdmsg
=
fdmsg
;
this
.
_closeResult
=
null
;
this
.
_closed
=
null
;
}
;
File
.
prototype
=
{
close
:
function
close
(
)
{
if
(
this
.
_fdmsg
!
=
null
)
{
let
msg
=
this
.
_fdmsg
;
this
.
_fdmsg
=
null
;
return
this
.
_closeResult
=
Scheduler
.
post
(
"
File_prototype_close
"
[
msg
]
this
)
;
}
return
this
.
_closeResult
;
}
stat
:
function
stat
(
)
{
return
Scheduler
.
post
(
"
File_prototype_stat
"
[
this
.
_fdmsg
]
this
)
.
then
(
File
.
Info
.
fromMsg
)
;
}
write
:
function
write
(
buffer
options
=
{
}
)
{
if
(
isTypedArray
(
buffer
)
&
&
!
(
options
&
&
"
bytes
"
in
options
)
)
{
options
=
clone
(
options
[
"
outExecutionDuration
"
"
outSerializationDuration
"
]
)
;
options
.
bytes
=
buffer
.
byteLength
;
}
return
Scheduler
.
post
(
"
File_prototype_write
"
[
this
.
_fdmsg
Type
.
void_t
.
in_ptr
.
toMsg
(
buffer
)
options
]
buffer
)
;
}
read
:
function
read
(
nbytes
options
=
{
}
)
{
let
promise
=
Scheduler
.
post
(
"
File_prototype_read
"
[
this
.
_fdmsg
nbytes
options
]
)
;
return
promise
.
then
(
function
onSuccess
(
data
)
{
return
new
Uint8Array
(
data
.
buffer
data
.
byteOffset
data
.
byteLength
)
;
}
)
;
}
getPosition
:
function
getPosition
(
)
{
return
Scheduler
.
post
(
"
File_prototype_getPosition
"
[
this
.
_fdmsg
]
)
;
}
setPosition
:
function
setPosition
(
pos
whence
)
{
return
Scheduler
.
post
(
"
File_prototype_setPosition
"
[
this
.
_fdmsg
pos
whence
]
)
;
}
flush
:
function
flush
(
)
{
return
Scheduler
.
post
(
"
File_prototype_flush
"
[
this
.
_fdmsg
]
)
;
}
setPermissions
:
function
setPermissions
(
options
=
{
}
)
{
return
Scheduler
.
post
(
"
File_prototype_setPermissions
"
[
this
.
_fdmsg
options
]
)
;
}
}
;
if
(
SharedAll
.
Constants
.
Sys
.
Name
!
=
"
Android
"
)
{
File
.
prototype
.
setDates
=
function
(
accessDate
modificationDate
)
{
return
Scheduler
.
post
(
"
File_prototype_setDates
"
[
this
.
_fdmsg
accessDate
modificationDate
]
this
)
;
}
;
}
File
.
open
=
function
open
(
path
mode
options
)
{
return
Scheduler
.
post
(
"
open
"
[
Type
.
path
.
toMsg
(
path
)
mode
options
]
path
)
.
then
(
function
onSuccess
(
msg
)
{
return
new
File
(
msg
)
;
}
)
;
}
;
File
.
openUnique
=
function
openUnique
(
path
options
)
{
return
Scheduler
.
post
(
"
openUnique
"
[
Type
.
path
.
toMsg
(
path
)
options
]
path
)
.
then
(
function
onSuccess
(
msg
)
{
return
{
path
:
msg
.
path
file
:
new
File
(
msg
.
file
)
}
;
}
)
;
}
;
File
.
stat
=
function
stat
(
path
options
)
{
return
Scheduler
.
post
(
"
stat
"
[
Type
.
path
.
toMsg
(
path
)
options
]
path
)
.
then
(
File
.
Info
.
fromMsg
)
;
}
;
File
.
setDates
=
function
setDates
(
path
accessDate
modificationDate
)
{
return
Scheduler
.
post
(
"
setDates
"
[
Type
.
path
.
toMsg
(
path
)
accessDate
modificationDate
]
this
)
;
}
;
File
.
setPermissions
=
function
setPermissions
(
path
options
=
{
}
)
{
return
Scheduler
.
post
(
"
setPermissions
"
[
Type
.
path
.
toMsg
(
path
)
options
]
)
;
}
;
File
.
getCurrentDirectory
=
function
getCurrentDirectory
(
)
{
return
Scheduler
.
post
(
"
getCurrentDirectory
"
)
.
then
(
Type
.
path
.
fromMsg
)
;
}
;
File
.
setCurrentDirectory
=
function
setCurrentDirectory
(
path
)
{
return
Scheduler
.
post
(
"
setCurrentDirectory
"
[
Type
.
path
.
toMsg
(
path
)
]
path
)
;
}
;
File
.
copy
=
function
copy
(
sourcePath
destPath
options
)
{
return
Scheduler
.
post
(
"
copy
"
[
Type
.
path
.
toMsg
(
sourcePath
)
Type
.
path
.
toMsg
(
destPath
)
options
]
[
sourcePath
destPath
]
)
;
}
;
File
.
move
=
function
move
(
sourcePath
destPath
options
)
{
return
Scheduler
.
post
(
"
move
"
[
Type
.
path
.
toMsg
(
sourcePath
)
Type
.
path
.
toMsg
(
destPath
)
options
]
[
sourcePath
destPath
]
)
;
}
;
if
(
!
SharedAll
.
Constants
.
Win
)
{
File
.
unixSymLink
=
function
unixSymLink
(
sourcePath
destPath
)
{
return
Scheduler
.
post
(
"
unixSymLink
"
[
Type
.
path
.
toMsg
(
sourcePath
)
Type
.
path
.
toMsg
(
destPath
)
]
[
sourcePath
destPath
]
)
;
}
;
}
File
.
removeEmptyDir
=
function
removeEmptyDir
(
path
options
)
{
return
Scheduler
.
post
(
"
removeEmptyDir
"
[
Type
.
path
.
toMsg
(
path
)
options
]
path
)
;
}
;
File
.
remove
=
function
remove
(
path
options
)
{
return
Scheduler
.
post
(
"
remove
"
[
Type
.
path
.
toMsg
(
path
)
options
]
path
)
;
}
;
File
.
makeDir
=
function
makeDir
(
path
options
)
{
return
Scheduler
.
post
(
"
makeDir
"
[
Type
.
path
.
toMsg
(
path
)
options
]
path
)
;
}
;
File
.
read
=
function
read
(
path
bytes
options
=
{
}
)
{
if
(
typeof
bytes
=
=
"
object
"
)
{
options
=
bytes
|
|
{
}
;
}
else
{
options
=
clone
(
options
[
"
outExecutionDuration
"
"
outSerializationDuration
"
]
)
;
if
(
typeof
bytes
!
=
"
undefined
"
)
{
options
.
bytes
=
bytes
;
}
}
if
(
options
.
compression
|
|
!
nativeWheneverAvailable
)
{
let
promise
=
Scheduler
.
post
(
"
read
"
[
Type
.
path
.
toMsg
(
path
)
bytes
options
]
path
)
;
return
promise
.
then
(
function
onSuccess
(
data
)
{
if
(
typeof
data
=
=
"
string
"
)
{
return
data
;
}
return
new
Uint8Array
(
data
.
buffer
data
.
byteOffset
data
.
byteLength
)
;
}
)
;
}
return
Scheduler
.
push
(
(
)
=
>
Native
.
read
(
path
options
)
)
;
}
;
File
.
exists
=
function
exists
(
path
)
{
return
Scheduler
.
post
(
"
exists
"
[
Type
.
path
.
toMsg
(
path
)
]
path
)
;
}
;
File
.
writeAtomic
=
function
writeAtomic
(
path
buffer
options
=
{
}
)
{
const
useNativeImplementation
=
nativeWheneverAvailable
&
&
!
options
.
compression
&
&
!
(
isTypedArray
(
buffer
)
&
&
"
byteOffset
"
in
buffer
&
&
buffer
.
byteOffset
>
0
)
;
options
=
clone
(
options
[
"
outExecutionDuration
"
"
outSerializationDuration
"
]
)
;
if
(
"
tmpPath
"
in
options
&
&
!
useNativeImplementation
)
{
options
.
tmpPath
=
Type
.
path
.
toMsg
(
options
.
tmpPath
)
;
}
if
(
isTypedArray
(
buffer
)
&
&
(
!
(
"
bytes
"
in
options
)
)
)
{
options
.
bytes
=
buffer
.
byteLength
;
}
let
refObj
=
{
}
;
let
promise
;
TelemetryStopwatch
.
start
(
"
OSFILE_WRITEATOMIC_JANK_MS
"
refObj
)
;
if
(
useNativeImplementation
)
{
promise
=
Scheduler
.
push
(
(
)
=
>
Native
.
writeAtomic
(
path
buffer
options
)
)
;
}
else
{
promise
=
Scheduler
.
post
(
"
writeAtomic
"
[
Type
.
path
.
toMsg
(
path
)
Type
.
void_t
.
in_ptr
.
toMsg
(
buffer
)
options
]
[
options
buffer
path
]
)
;
}
TelemetryStopwatch
.
finish
(
"
OSFILE_WRITEATOMIC_JANK_MS
"
refObj
)
;
return
promise
;
}
;
File
.
removeDir
=
function
(
path
options
=
{
}
)
{
return
Scheduler
.
post
(
"
removeDir
"
[
Type
.
path
.
toMsg
(
path
)
options
]
path
)
;
}
;
File
.
Info
=
function
Info
(
value
)
{
for
(
let
k
in
value
)
{
if
(
k
!
=
"
creationDate
"
)
{
Object
.
defineProperty
(
this
k
{
value
:
value
[
k
]
}
)
;
}
}
Object
.
defineProperty
(
this
"
_deprecatedCreationDate
"
{
value
:
value
.
creationDate
}
)
;
}
;
File
.
Info
.
prototype
=
SysAll
.
AbstractInfo
.
prototype
;
Object
.
defineProperty
(
File
.
Info
.
prototype
"
creationDate
"
{
get
:
function
creationDate
(
)
{
let
{
Deprecated
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Deprecated
.
jsm
"
{
}
)
;
Deprecated
.
warning
(
"
Field
'
creationDate
'
is
deprecated
.
"
"
https
:
/
/
developer
.
mozilla
.
org
/
en
-
US
/
docs
/
JavaScript_OS
.
File
/
OS
.
File
.
Info
#
Cross
-
platform_Attributes
"
)
;
return
this
.
_deprecatedCreationDate
;
}
}
)
;
File
.
Info
.
fromMsg
=
function
fromMsg
(
value
)
{
return
new
File
.
Info
(
value
)
;
}
;
File
.
GET_DEBUG
=
function
GET_DEBUG
(
)
{
return
Scheduler
.
post
(
"
GET_DEBUG
"
)
;
}
;
var
DirectoryIterator
=
function
DirectoryIterator
(
path
options
)
{
this
.
_itmsg
=
Scheduler
.
post
(
"
new_DirectoryIterator
"
[
Type
.
path
.
toMsg
(
path
)
options
]
path
)
;
this
.
_isClosed
=
false
;
}
;
DirectoryIterator
.
prototype
=
{
[
Symbol
.
asyncIterator
]
(
)
{
return
this
;
}
_itmsg
:
null
async
exists
(
)
{
if
(
this
.
_isClosed
)
{
return
Promise
.
resolve
(
false
)
;
}
let
iterator
=
await
this
.
_itmsg
;
return
Scheduler
.
post
(
"
DirectoryIterator_prototype_exists
"
[
iterator
]
)
;
}
async
next
(
)
{
if
(
this
.
_isClosed
)
{
return
{
value
:
undefined
done
:
true
}
;
}
return
this
.
_next
(
await
this
.
_itmsg
)
;
}
async
nextBatch
(
size
)
{
if
(
this
.
_isClosed
)
{
return
[
]
;
}
let
iterator
=
await
this
.
_itmsg
;
let
array
=
await
Scheduler
.
post
(
"
DirectoryIterator_prototype_nextBatch
"
[
iterator
size
]
)
;
return
array
.
map
(
DirectoryIterator
.
Entry
.
fromMsg
)
;
}
async
forEach
(
cb
options
)
{
if
(
this
.
_isClosed
)
{
return
undefined
;
}
let
position
=
0
;
let
iterator
=
await
this
.
_itmsg
;
while
(
true
)
{
if
(
this
.
_isClosed
)
{
return
undefined
;
}
let
{
value
done
}
=
await
this
.
_next
(
iterator
)
;
if
(
done
)
{
return
undefined
;
}
await
cb
(
value
position
+
+
this
)
;
}
}
async
_next
(
iterator
)
{
if
(
this
.
_isClosed
)
{
return
{
value
:
undefined
done
:
true
}
;
}
let
{
value
done
}
=
await
Scheduler
.
post
(
"
DirectoryIterator_prototype_next
"
[
iterator
]
)
;
if
(
done
)
{
this
.
close
(
)
;
return
{
value
:
undefined
done
:
true
}
;
}
return
{
value
:
DirectoryIterator
.
Entry
.
fromMsg
(
value
)
done
:
false
}
;
}
async
close
(
)
{
if
(
this
.
_isClosed
)
{
return
undefined
;
}
this
.
_isClosed
=
true
;
let
iterator
=
this
.
_itmsg
;
this
.
_itmsg
=
null
;
return
Scheduler
.
post
(
"
DirectoryIterator_prototype_close
"
[
iterator
]
)
;
}
}
;
DirectoryIterator
.
Entry
=
function
Entry
(
value
)
{
return
value
;
}
;
DirectoryIterator
.
Entry
.
prototype
=
Object
.
create
(
SysAll
.
AbstractEntry
.
prototype
)
;
DirectoryIterator
.
Entry
.
fromMsg
=
function
fromMsg
(
value
)
{
return
new
DirectoryIterator
.
Entry
(
value
)
;
}
;
File
.
resetWorker
=
function
(
)
{
return
(
async
function
(
)
{
let
resources
=
await
Scheduler
.
kill
(
{
shutdown
:
false
reset
:
true
}
)
;
if
(
resources
&
&
!
resources
.
killed
)
{
throw
new
Error
(
"
Could
not
reset
worker
this
would
leak
file
descriptors
:
"
+
JSON
.
stringify
(
resources
)
)
;
}
}
)
(
)
;
}
;
File
.
POS_START
=
SysAll
.
POS_START
;
File
.
POS_CURRENT
=
SysAll
.
POS_CURRENT
;
File
.
POS_END
=
SysAll
.
POS_END
;
File
.
Error
=
OSError
;
File
.
DirectoryIterator
=
DirectoryIterator
;
var
OS
=
{
}
;
this
.
OS
.
File
=
File
;
this
.
OS
.
Constants
=
SharedAll
.
Constants
;
this
.
OS
.
Shared
=
{
LOG
:
SharedAll
.
LOG
Type
:
SysAll
.
Type
get
DEBUG
(
)
{
return
SharedAll
.
Config
.
DEBUG
;
}
set
DEBUG
(
x
)
{
return
SharedAll
.
Config
.
DEBUG
=
x
;
}
}
;
Object
.
freeze
(
this
.
OS
.
Shared
)
;
this
.
OS
.
Path
=
Path
;
Object
.
defineProperty
(
OS
.
File
"
queue
"
{
get
(
)
{
return
Scheduler
.
queue
;
}
}
)
;
const
isContent
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
;
var
Barriers
=
{
shutdown
:
new
AsyncShutdown
.
Barrier
(
"
OS
.
File
:
Waiting
for
clients
before
full
shutdown
"
)
getDetails
(
)
{
let
result
=
{
launched
:
Scheduler
.
launched
shutdown
:
Scheduler
.
shutdown
worker
:
!
!
Scheduler
.
_worker
pendingReset
:
!
!
Scheduler
.
resetTimer
latestSent
:
Scheduler
.
Debugging
.
latestSent
latestReceived
:
Scheduler
.
Debugging
.
latestReceived
messagesSent
:
Scheduler
.
Debugging
.
messagesSent
messagesReceived
:
Scheduler
.
Debugging
.
messagesReceived
messagesQueued
:
Scheduler
.
Debugging
.
messagesQueued
DEBUG
:
SharedAll
.
Config
.
DEBUG
}
;
for
(
let
key
of
[
"
latestSent
"
"
latestReceived
"
]
)
{
if
(
result
[
key
]
&
&
typeof
result
[
key
]
[
0
]
=
=
"
number
"
)
{
result
[
key
]
[
0
]
=
Date
(
result
[
key
]
[
0
]
)
;
}
}
return
result
;
}
}
;
function
setupShutdown
(
phaseName
)
{
Barriers
[
phaseName
]
=
new
AsyncShutdown
.
Barrier
(
OS
.
File
:
Waiting
for
clients
before
{
phaseName
}
)
File
[
phaseName
]
=
Barriers
[
phaseName
]
.
client
;
AsyncShutdown
[
phaseName
]
.
addBlocker
(
OS
.
File
:
flush
I
/
O
queued
before
{
phaseName
}
async
function
(
)
{
await
Barriers
[
phaseName
]
.
wait
(
{
crashAfterMS
:
null
}
)
;
await
Scheduler
.
queue
;
}
(
)
=
>
{
let
details
=
Barriers
.
getDetails
(
)
;
details
.
clients
=
Barriers
[
phaseName
]
.
state
;
return
details
;
}
)
;
}
if
(
!
isContent
)
{
setupShutdown
(
"
profileBeforeChange
"
)
;
}
File
.
shutdown
=
Barriers
.
shutdown
.
client
;
