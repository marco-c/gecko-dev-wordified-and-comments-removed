#
include
"
NativeOSFileInternals
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXPCOMCID
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
mozilla
/
dom
/
NativeOSFileInternalsBinding
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Scoped
.
h
"
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
prio
.
h
"
#
include
"
prerror
.
h
"
#
include
"
private
/
pprio
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
js
/
MemoryFunctions
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
<
algorithm
>
#
if
defined
(
XP_UNIX
)
#
include
<
unistd
.
h
>
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
uio
.
h
>
#
endif
#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
endif
namespace
mozilla
{
MOZ_TYPE_SPECIFIC_SCOPED_POINTER_TEMPLATE
(
ScopedPRFileDesc
PRFileDesc
PR_Close
)
namespace
{
struct
ArrayBufferContents
{
uint8_t
*
data
;
size_t
nbytes
;
}
;
struct
ScopedArrayBufferContentsTraits
{
typedef
ArrayBufferContents
type
;
const
static
type
empty
(
)
{
type
result
=
{
0
0
}
;
return
result
;
}
static
void
release
(
type
ptr
)
{
js_free
(
ptr
.
data
)
;
ptr
.
data
=
nullptr
;
ptr
.
nbytes
=
0
;
}
}
;
struct
MOZ_NON_TEMPORARY_CLASS
ScopedArrayBufferContents
:
public
Scoped
<
ScopedArrayBufferContentsTraits
>
{
explicit
ScopedArrayBufferContents
(
)
:
Scoped
<
ScopedArrayBufferContentsTraits
>
(
)
{
}
ScopedArrayBufferContents
&
operator
=
(
ArrayBufferContents
ptr
)
{
Scoped
<
ScopedArrayBufferContentsTraits
>
:
:
operator
=
(
ptr
)
;
return
*
this
;
}
bool
Allocate
(
uint32_t
length
)
{
dispose
(
)
;
ArrayBufferContents
&
value
=
rwget
(
)
;
void
*
ptr
=
js_calloc
(
1
length
)
;
if
(
ptr
)
{
value
.
data
=
(
uint8_t
*
)
ptr
;
value
.
nbytes
=
length
;
return
true
;
}
return
false
;
}
private
:
explicit
ScopedArrayBufferContents
(
ScopedArrayBufferContents
&
source
)
=
delete
;
ScopedArrayBufferContents
&
operator
=
(
ScopedArrayBufferContents
&
source
)
=
delete
;
}
;
#
if
defined
(
XP_UNIX
)
#
define
OS_ERROR_FILE_EXISTS
EEXIST
#
define
OS_ERROR_NOMEM
ENOMEM
#
define
OS_ERROR_INVAL
EINVAL
#
define
OS_ERROR_TOO_LARGE
EFBIG
#
define
OS_ERROR_RACE
EIO
#
elif
defined
(
XP_WIN
)
#
define
OS_ERROR_FILE_EXISTS
ERROR_ALREADY_EXISTS
#
define
OS_ERROR_NOMEM
ERROR_NOT_ENOUGH_MEMORY
#
define
OS_ERROR_INVAL
ERROR_BAD_ARGUMENTS
#
define
OS_ERROR_TOO_LARGE
ERROR_FILE_TOO_LARGE
#
define
OS_ERROR_RACE
ERROR_SHARING_VIOLATION
#
else
#
error
"
We
do
not
have
platform
-
specific
constants
for
this
platform
"
#
endif
class
AbstractResult
:
public
nsINativeOSFileResult
{
public
:
NS_DECL_NSINATIVEOSFILERESULT
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
AbstractResult
)
explicit
AbstractResult
(
TimeStamp
aStartDate
)
:
mStartDate
(
aStartDate
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mozilla
:
:
HoldJSObjects
(
this
)
;
}
void
Init
(
TimeStamp
aDispatchDate
TimeDuration
aExecutionDuration
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mDispatchDuration
=
(
aDispatchDate
-
mStartDate
)
;
mExecutionDuration
=
aExecutionDuration
;
}
void
DropJSData
(
)
{
mCachedResult
=
JS
:
:
UndefinedValue
(
)
;
}
protected
:
virtual
~
AbstractResult
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mozilla
:
:
DropJSObjects
(
this
)
;
}
virtual
nsresult
GetCacheableResult
(
JSContext
*
cx
JS
:
:
MutableHandleValue
aResult
)
=
0
;
private
:
TimeStamp
mStartDate
;
TimeDuration
mDispatchDuration
;
TimeDuration
mExecutionDuration
;
JS
:
:
Heap
<
JS
:
:
Value
>
mCachedResult
;
}
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
AbstractResult
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
AbstractResult
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
AbstractResult
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
AbstractResult
)
NS_INTERFACE_MAP_ENTRY
(
nsINativeOSFileResult
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
AbstractResult
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mCachedResult
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
AbstractResult
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
AbstractResult
)
tmp
-
>
DropJSData
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMETHODIMP
AbstractResult
:
:
GetDispatchDurationMS
(
double
*
aDispatchDuration
)
{
*
aDispatchDuration
=
mDispatchDuration
.
ToMilliseconds
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AbstractResult
:
:
GetExecutionDurationMS
(
double
*
aExecutionDuration
)
{
*
aExecutionDuration
=
mExecutionDuration
.
ToMilliseconds
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AbstractResult
:
:
GetResult
(
JSContext
*
cx
JS
:
:
MutableHandleValue
aResult
)
{
if
(
mCachedResult
.
isUndefined
(
)
)
{
nsresult
rv
=
GetCacheableResult
(
cx
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mCachedResult
=
aResult
;
return
NS_OK
;
}
aResult
.
set
(
mCachedResult
)
;
return
NS_OK
;
}
class
StringResult
final
:
public
AbstractResult
{
public
:
explicit
StringResult
(
TimeStamp
aStartDate
)
:
AbstractResult
(
aStartDate
)
{
}
void
Init
(
TimeStamp
aDispatchDate
TimeDuration
aExecutionDuration
nsString
&
aContents
)
{
AbstractResult
:
:
Init
(
aDispatchDate
aExecutionDuration
)
;
mContents
=
aContents
;
}
protected
:
nsresult
GetCacheableResult
(
JSContext
*
cx
JS
:
:
MutableHandleValue
aResult
)
override
;
private
:
nsString
mContents
;
}
;
nsresult
StringResult
:
:
GetCacheableResult
(
JSContext
*
cx
JS
:
:
MutableHandleValue
aResult
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mContents
.
get
(
)
)
;
if
(
!
xpc
:
:
StringToJsval
(
cx
mContents
aResult
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
class
TypedArrayResult
final
:
public
AbstractResult
{
public
:
explicit
TypedArrayResult
(
TimeStamp
aStartDate
)
:
AbstractResult
(
aStartDate
)
{
}
void
Init
(
TimeStamp
aDispatchDate
TimeDuration
aExecutionDuration
ArrayBufferContents
aContents
)
{
AbstractResult
:
:
Init
(
aDispatchDate
aExecutionDuration
)
;
mContents
=
aContents
;
}
protected
:
nsresult
GetCacheableResult
(
JSContext
*
cx
JS
:
:
MutableHandleValue
aResult
)
override
;
private
:
ScopedArrayBufferContents
mContents
;
}
;
nsresult
TypedArrayResult
:
:
GetCacheableResult
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
const
ArrayBufferContents
&
contents
=
mContents
.
get
(
)
;
MOZ_ASSERT
(
contents
.
data
)
;
JS
:
:
Rooted
<
JSObject
*
>
arrayBuffer
(
cx
JS
:
:
NewArrayBufferWithContents
(
cx
contents
.
nbytes
contents
.
data
)
)
;
if
(
!
arrayBuffer
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
JS
:
:
Rooted
<
JSObject
*
>
result
(
cx
JS_NewUint8ArrayWithBuffer
(
cx
arrayBuffer
0
contents
.
nbytes
)
)
;
if
(
!
result
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mContents
.
forget
(
)
;
aResult
.
setObject
(
*
result
)
;
return
NS_OK
;
}
class
Int32Result
final
:
public
AbstractResult
{
public
:
explicit
Int32Result
(
TimeStamp
aStartDate
)
:
AbstractResult
(
aStartDate
)
mContents
(
0
)
{
}
void
Init
(
TimeStamp
aDispatchDate
TimeDuration
aExecutionDuration
int32_t
aContents
)
{
AbstractResult
:
:
Init
(
aDispatchDate
aExecutionDuration
)
;
mContents
=
aContents
;
}
protected
:
nsresult
GetCacheableResult
(
JSContext
*
cx
JS
:
:
MutableHandleValue
aResult
)
override
;
private
:
int32_t
mContents
;
}
;
nsresult
Int32Result
:
:
GetCacheableResult
(
JSContext
*
cx
JS
:
:
MutableHandleValue
aResult
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aResult
.
set
(
JS
:
:
NumberValue
(
mContents
)
)
;
return
NS_OK
;
}
class
OSFileErrorEvent
final
:
public
Runnable
{
public
:
OSFileErrorEvent
(
nsMainThreadPtrHandle
<
nsINativeOSFileSuccessCallback
>
&
aOnSuccess
nsMainThreadPtrHandle
<
nsINativeOSFileErrorCallback
>
&
aOnError
already_AddRefed
<
AbstractResult
>
&
aDiscardedResult
const
nsACString
&
aOperation
int32_t
aOSError
)
:
Runnable
(
"
OSFileErrorEvent
"
)
mOnSuccess
(
aOnSuccess
)
mOnError
(
aOnError
)
mDiscardedResult
(
aDiscardedResult
)
mOSError
(
aOSError
)
mOperation
(
aOperation
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
(
void
)
mOnError
-
>
Complete
(
mOperation
mOSError
)
;
mOnSuccess
=
nullptr
;
mOnError
=
nullptr
;
mDiscardedResult
=
nullptr
;
return
NS_OK
;
}
private
:
nsMainThreadPtrHandle
<
nsINativeOSFileSuccessCallback
>
mOnSuccess
;
nsMainThreadPtrHandle
<
nsINativeOSFileErrorCallback
>
mOnError
;
RefPtr
<
AbstractResult
>
mDiscardedResult
;
int32_t
mOSError
;
nsCString
mOperation
;
}
;
class
SuccessEvent
final
:
public
Runnable
{
public
:
SuccessEvent
(
nsMainThreadPtrHandle
<
nsINativeOSFileSuccessCallback
>
&
aOnSuccess
nsMainThreadPtrHandle
<
nsINativeOSFileErrorCallback
>
&
aOnError
already_AddRefed
<
nsINativeOSFileResult
>
&
aResult
)
:
Runnable
(
"
SuccessEvent
"
)
mOnSuccess
(
aOnSuccess
)
mOnError
(
aOnError
)
mResult
(
aResult
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
(
void
)
mOnSuccess
-
>
Complete
(
mResult
)
;
mOnSuccess
=
nullptr
;
mOnError
=
nullptr
;
mResult
=
nullptr
;
return
NS_OK
;
}
private
:
nsMainThreadPtrHandle
<
nsINativeOSFileSuccessCallback
>
mOnSuccess
;
nsMainThreadPtrHandle
<
nsINativeOSFileErrorCallback
>
mOnError
;
RefPtr
<
nsINativeOSFileResult
>
mResult
;
}
;
class
AbstractDoEvent
:
public
Runnable
{
public
:
AbstractDoEvent
(
nsMainThreadPtrHandle
<
nsINativeOSFileSuccessCallback
>
&
aOnSuccess
nsMainThreadPtrHandle
<
nsINativeOSFileErrorCallback
>
&
aOnError
)
:
Runnable
(
"
AbstractDoEvent
"
)
mOnSuccess
(
aOnSuccess
)
mOnError
(
aOnError
)
#
if
defined
(
DEBUG
)
mResolved
(
false
)
#
endif
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
Fail
(
const
nsACString
&
aOperation
already_AddRefed
<
AbstractResult
>
&
&
aDiscardedResult
int32_t
aOSError
=
0
)
{
Resolve
(
)
;
RefPtr
<
OSFileErrorEvent
>
event
=
new
OSFileErrorEvent
(
mOnSuccess
mOnError
aDiscardedResult
aOperation
aOSError
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
event
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ReleaseOnMainThread
(
"
AbstractDoEvent
:
:
OSFileErrorEvent
"
event
.
forget
(
)
)
;
}
}
void
Succeed
(
already_AddRefed
<
nsINativeOSFileResult
>
&
&
aResult
)
{
Resolve
(
)
;
RefPtr
<
SuccessEvent
>
event
=
new
SuccessEvent
(
mOnSuccess
mOnError
aResult
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
event
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ReleaseOnMainThread
(
"
AbstractDoEvent
:
:
SuccessEvent
"
event
.
forget
(
)
)
;
}
}
private
:
void
Resolve
(
)
{
#
if
defined
(
DEBUG
)
MOZ_ASSERT
(
!
mResolved
)
;
mResolved
=
true
;
#
endif
}
private
:
nsMainThreadPtrHandle
<
nsINativeOSFileSuccessCallback
>
mOnSuccess
;
nsMainThreadPtrHandle
<
nsINativeOSFileErrorCallback
>
mOnError
;
#
if
defined
(
DEBUG
)
bool
mResolved
;
#
endif
}
;
class
AbstractReadEvent
:
public
AbstractDoEvent
{
public
:
AbstractReadEvent
(
const
nsAString
&
aPath
const
uint64_t
aBytes
nsMainThreadPtrHandle
<
nsINativeOSFileSuccessCallback
>
&
aOnSuccess
nsMainThreadPtrHandle
<
nsINativeOSFileErrorCallback
>
&
aOnError
)
:
AbstractDoEvent
(
aOnSuccess
aOnError
)
mPath
(
aPath
)
mBytes
(
aBytes
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
TimeStamp
dispatchDate
=
TimeStamp
:
:
Now
(
)
;
nsresult
rv
=
BeforeRead
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
ScopedArrayBufferContents
buffer
;
rv
=
Read
(
buffer
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
AfterRead
(
dispatchDate
buffer
)
;
return
NS_OK
;
}
private
:
nsresult
Read
(
ScopedArrayBufferContents
&
aBuffer
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
ScopedPRFileDesc
file
;
#
if
defined
(
XP_WIN
)
HANDLE
handle
=
:
:
CreateFileW
(
mPath
.
get
(
)
GENERIC_READ
FILE_SHARE_READ
|
FILE_SHARE_WRITE
|
FILE_SHARE_DELETE
nullptr
OPEN_EXISTING
FILE_ATTRIBUTE_NORMAL
|
FILE_FLAG_SEQUENTIAL_SCAN
nullptr
)
;
if
(
handle
=
=
INVALID_HANDLE_VALUE
)
{
Fail
(
"
open
"
_ns
nullptr
:
:
GetLastError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
file
=
PR_ImportFile
(
(
PROsfd
)
handle
)
;
if
(
!
file
)
{
Fail
(
"
ImportFile
"
_ns
nullptr
PR_GetOSError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
#
else
NS_ConvertUTF16toUTF8
path
(
mPath
)
;
file
=
PR_OpenFile
(
path
.
get
(
)
PR_RDONLY
0
)
;
if
(
!
file
)
{
Fail
(
"
open
"
_ns
nullptr
PR_GetOSError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
#
endif
PRFileInfo64
stat
;
if
(
PR_GetOpenFileInfo64
(
file
&
stat
)
!
=
PR_SUCCESS
)
{
Fail
(
"
stat
"
_ns
nullptr
PR_GetOSError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
uint64_t
bytes
=
std
:
:
min
(
(
uint64_t
)
stat
.
size
mBytes
)
;
if
(
bytes
>
UINT32_MAX
)
{
Fail
(
"
Arithmetics
"
_ns
nullptr
OS_ERROR_INVAL
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
aBuffer
.
Allocate
(
bytes
)
)
{
Fail
(
"
allocate
"
_ns
nullptr
OS_ERROR_NOMEM
)
;
return
NS_ERROR_FAILURE
;
}
uint64_t
total_read
=
0
;
int32_t
just_read
=
0
;
char
*
dest_chars
=
reinterpret_cast
<
char
*
>
(
aBuffer
.
rwget
(
)
.
data
)
;
do
{
just_read
=
PR_Read
(
file
dest_chars
+
total_read
std
:
:
min
(
uint64_t
(
PR_INT32_MAX
)
bytes
-
total_read
)
)
;
if
(
just_read
=
=
-
1
)
{
Fail
(
"
read
"
_ns
nullptr
PR_GetOSError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
total_read
+
=
just_read
;
}
while
(
just_read
!
=
0
&
&
total_read
<
bytes
)
;
if
(
total_read
!
=
bytes
)
{
Fail
(
"
read
"
_ns
nullptr
OS_ERROR_RACE
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
protected
:
virtual
nsresult
BeforeRead
(
)
{
return
NS_OK
;
}
virtual
void
AfterRead
(
TimeStamp
aDispatchDate
ScopedArrayBufferContents
&
aBuffer
)
=
0
;
protected
:
const
nsString
mPath
;
const
uint64_t
mBytes
;
}
;
class
DoReadToTypedArrayEvent
final
:
public
AbstractReadEvent
{
public
:
DoReadToTypedArrayEvent
(
const
nsAString
&
aPath
const
uint32_t
aBytes
nsMainThreadPtrHandle
<
nsINativeOSFileSuccessCallback
>
&
aOnSuccess
nsMainThreadPtrHandle
<
nsINativeOSFileErrorCallback
>
&
aOnError
)
:
AbstractReadEvent
(
aPath
aBytes
aOnSuccess
aOnError
)
mResult
(
new
TypedArrayResult
(
TimeStamp
:
:
Now
(
)
)
)
{
}
~
DoReadToTypedArrayEvent
(
)
override
{
if
(
!
mResult
)
{
return
;
}
NS_ReleaseOnMainThread
(
"
DoReadToTypedArrayEvent
:
:
mResult
"
mResult
.
forget
(
)
)
;
}
protected
:
void
AfterRead
(
TimeStamp
aDispatchDate
ScopedArrayBufferContents
&
aBuffer
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mResult
-
>
Init
(
aDispatchDate
TimeStamp
:
:
Now
(
)
-
aDispatchDate
aBuffer
.
forget
(
)
)
;
Succeed
(
mResult
.
forget
(
)
)
;
}
private
:
RefPtr
<
TypedArrayResult
>
mResult
;
}
;
class
DoReadToStringEvent
final
:
public
AbstractReadEvent
{
public
:
DoReadToStringEvent
(
const
nsAString
&
aPath
const
nsACString
&
aEncoding
const
uint32_t
aBytes
nsMainThreadPtrHandle
<
nsINativeOSFileSuccessCallback
>
&
aOnSuccess
nsMainThreadPtrHandle
<
nsINativeOSFileErrorCallback
>
&
aOnError
)
:
AbstractReadEvent
(
aPath
aBytes
aOnSuccess
aOnError
)
mEncoding
(
aEncoding
)
mResult
(
new
StringResult
(
TimeStamp
:
:
Now
(
)
)
)
{
}
~
DoReadToStringEvent
(
)
override
{
if
(
!
mResult
)
{
return
;
}
NS_ReleaseOnMainThread
(
"
DoReadToStringEvent
:
:
mResult
"
mResult
.
forget
(
)
)
;
}
protected
:
nsresult
BeforeRead
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
const
Encoding
*
encoding
=
Encoding
:
:
ForLabel
(
mEncoding
)
;
if
(
!
encoding
)
{
Fail
(
"
Decode
"
_ns
mResult
.
forget
(
)
OS_ERROR_INVAL
)
;
return
NS_ERROR_FAILURE
;
}
mDecoder
=
encoding
-
>
NewDecoderWithBOMRemoval
(
)
;
if
(
!
mDecoder
)
{
Fail
(
"
DecoderForEncoding
"
_ns
mResult
.
forget
(
)
OS_ERROR_INVAL
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
AfterRead
(
TimeStamp
aDispatchDate
ScopedArrayBufferContents
&
aBuffer
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
auto
src
=
Span
(
aBuffer
.
get
(
)
.
data
aBuffer
.
get
(
)
.
nbytes
)
;
CheckedInt
<
size_t
>
needed
=
mDecoder
-
>
MaxUTF16BufferLength
(
src
.
Length
(
)
)
;
if
(
!
needed
.
isValid
(
)
|
|
needed
.
value
(
)
>
std
:
:
numeric_limits
<
nsAString
:
:
size_type
>
:
:
max
(
)
)
{
Fail
(
"
arithmetics
"
_ns
mResult
.
forget
(
)
OS_ERROR_TOO_LARGE
)
;
return
;
}
nsString
resultString
;
auto
resultSpan
=
resultString
.
GetMutableData
(
needed
.
value
(
)
fallible
)
;
if
(
!
resultSpan
)
{
Fail
(
"
allocation
"
_ns
mResult
.
forget
(
)
OS_ERROR_TOO_LARGE
)
;
return
;
}
uint32_t
result
;
size_t
read
;
size_t
written
;
std
:
:
tie
(
result
read
written
std
:
:
ignore
)
=
mDecoder
-
>
DecodeToUTF16
(
src
*
resultSpan
false
)
;
MOZ_ASSERT
(
result
=
=
kInputEmpty
)
;
MOZ_ASSERT
(
read
=
=
src
.
Length
(
)
)
;
MOZ_ASSERT
(
written
<
=
needed
.
value
(
)
)
;
bool
ok
=
resultString
.
SetLength
(
written
fallible
)
;
if
(
!
ok
)
{
Fail
(
"
allocation
"
_ns
mResult
.
forget
(
)
OS_ERROR_TOO_LARGE
)
;
return
;
}
mResult
-
>
Init
(
aDispatchDate
TimeStamp
:
:
Now
(
)
-
aDispatchDate
resultString
)
;
Succeed
(
mResult
.
forget
(
)
)
;
}
private
:
nsCString
mEncoding
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
Decoder
>
mDecoder
;
RefPtr
<
StringResult
>
mResult
;
}
;
class
DoWriteAtomicEvent
:
public
AbstractDoEvent
{
public
:
DoWriteAtomicEvent
(
const
nsAString
&
aPath
UniquePtr
<
char
[
]
JS
:
:
FreePolicy
>
aBuffer
const
uint64_t
aBytes
const
nsAString
&
aTmpPath
const
nsAString
&
aBackupTo
const
bool
aFlush
const
bool
aNoOverwrite
nsMainThreadPtrHandle
<
nsINativeOSFileSuccessCallback
>
&
aOnSuccess
nsMainThreadPtrHandle
<
nsINativeOSFileErrorCallback
>
&
aOnError
)
:
AbstractDoEvent
(
aOnSuccess
aOnError
)
mPath
(
aPath
)
mBuffer
(
std
:
:
move
(
aBuffer
)
)
mBytes
(
aBytes
)
mTmpPath
(
aTmpPath
)
mBackupTo
(
aBackupTo
)
mFlush
(
aFlush
)
mNoOverwrite
(
aNoOverwrite
)
mResult
(
new
Int32Result
(
TimeStamp
:
:
Now
(
)
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
~
DoWriteAtomicEvent
(
)
override
{
if
(
!
mResult
)
{
return
;
}
NS_ReleaseOnMainThread
(
"
DoWriteAtomicEvent
:
:
mResult
"
mResult
.
forget
(
)
)
;
}
NS_IMETHODIMP
Run
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
TimeStamp
dispatchDate
=
TimeStamp
:
:
Now
(
)
;
int32_t
bytesWritten
;
nsresult
rv
=
WriteAtomic
(
&
bytesWritten
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
AfterWriteAtomic
(
dispatchDate
bytesWritten
)
;
return
NS_OK
;
}
private
:
nsresult
WriteAtomic
(
int32_t
*
aBytesWritten
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
ScopedPRFileDesc
file
;
NS_ConvertUTF16toUTF8
path
(
mPath
)
;
NS_ConvertUTF16toUTF8
tmpPath
(
mTmpPath
)
;
NS_ConvertUTF16toUTF8
backupTo
(
mBackupTo
)
;
bool
fileExists
=
false
;
if
(
!
mTmpPath
.
IsVoid
(
)
|
|
!
mBackupTo
.
IsVoid
(
)
|
|
mNoOverwrite
)
{
#
if
defined
(
XP_WIN
)
fileExists
=
:
:
GetFileAttributesW
(
mPath
.
get
(
)
)
!
=
INVALID_FILE_ATTRIBUTES
;
#
else
fileExists
=
PR_Access
(
path
.
get
(
)
PR_ACCESS_EXISTS
)
=
=
PR_SUCCESS
;
#
endif
}
if
(
mNoOverwrite
&
&
fileExists
)
{
Fail
(
"
noOverwrite
"
_ns
nullptr
OS_ERROR_FILE_EXISTS
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mBackupTo
.
IsVoid
(
)
&
&
fileExists
)
{
#
if
defined
(
XP_WIN
)
if
(
:
:
GetFileAttributesW
(
mBackupTo
.
get
(
)
)
!
=
INVALID_FILE_ATTRIBUTES
)
{
if
(
:
:
DeleteFileW
(
mBackupTo
.
get
(
)
)
=
=
false
)
{
Fail
(
"
delete
"
_ns
nullptr
:
:
GetLastError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
}
if
(
:
:
MoveFileW
(
mPath
.
get
(
)
mBackupTo
.
get
(
)
)
=
=
false
)
{
Fail
(
"
rename
"
_ns
nullptr
:
:
GetLastError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
#
else
if
(
PR_Access
(
backupTo
.
get
(
)
PR_ACCESS_EXISTS
)
=
=
PR_SUCCESS
)
{
if
(
PR_Delete
(
backupTo
.
get
(
)
)
=
=
PR_FAILURE
)
{
Fail
(
"
delete
"
_ns
nullptr
PR_GetOSError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
}
if
(
PR_Rename
(
path
.
get
(
)
backupTo
.
get
(
)
)
=
=
PR_FAILURE
)
{
Fail
(
"
rename
"
_ns
nullptr
PR_GetOSError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
#
endif
}
#
if
defined
(
XP_WIN
)
HANDLE
handle
;
if
(
!
mTmpPath
.
IsVoid
(
)
)
{
handle
=
:
:
CreateFileW
(
mTmpPath
.
get
(
)
GENERIC_WRITE
FILE_SHARE_READ
|
FILE_SHARE_WRITE
|
FILE_SHARE_DELETE
nullptr
CREATE_ALWAYS
FILE_ATTRIBUTE_NORMAL
|
FILE_FLAG_WRITE_THROUGH
nullptr
)
;
}
else
{
handle
=
:
:
CreateFileW
(
mPath
.
get
(
)
GENERIC_WRITE
FILE_SHARE_READ
|
FILE_SHARE_WRITE
|
FILE_SHARE_DELETE
nullptr
CREATE_ALWAYS
FILE_ATTRIBUTE_NORMAL
|
FILE_FLAG_WRITE_THROUGH
nullptr
)
;
}
if
(
handle
=
=
INVALID_HANDLE_VALUE
)
{
Fail
(
"
open
"
_ns
nullptr
:
:
GetLastError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
file
=
PR_ImportFile
(
(
PROsfd
)
handle
)
;
if
(
!
file
)
{
Fail
(
"
ImportFile
"
_ns
nullptr
PR_GetOSError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
#
else
if
(
!
mTmpPath
.
IsVoid
(
)
)
{
file
=
PR_OpenFile
(
tmpPath
.
get
(
)
PR_WRONLY
|
PR_CREATE_FILE
|
PR_TRUNCATE
PR_IRUSR
|
PR_IWUSR
)
;
}
else
{
file
=
PR_OpenFile
(
path
.
get
(
)
PR_WRONLY
|
PR_CREATE_FILE
|
PR_TRUNCATE
PR_IRUSR
|
PR_IWUSR
)
;
}
if
(
!
file
)
{
Fail
(
"
open
"
_ns
nullptr
PR_GetOSError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
#
endif
int32_t
bytesWrittenSuccess
=
PR_Write
(
file
(
void
*
)
(
mBuffer
.
get
(
)
)
mBytes
)
;
if
(
bytesWrittenSuccess
=
=
-
1
)
{
Fail
(
"
write
"
_ns
nullptr
PR_GetOSError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mTmpPath
.
IsVoid
(
)
)
{
if
(
mBackupTo
.
IsVoid
(
)
&
&
fileExists
)
{
#
if
defined
(
XP_WIN
)
if
(
:
:
DeleteFileW
(
mPath
.
get
(
)
)
=
=
false
)
{
Fail
(
"
delete
"
_ns
nullptr
:
:
GetLastError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
#
else
if
(
PR_Delete
(
path
.
get
(
)
)
=
=
PR_FAILURE
)
{
Fail
(
"
delete
"
_ns
nullptr
PR_GetOSError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
#
endif
}
#
if
defined
(
XP_WIN
)
if
(
:
:
MoveFileW
(
mTmpPath
.
get
(
)
mPath
.
get
(
)
)
=
=
false
)
{
Fail
(
"
rename
"
_ns
nullptr
:
:
GetLastError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
#
else
if
(
PR_Rename
(
tmpPath
.
get
(
)
path
.
get
(
)
)
=
=
PR_FAILURE
)
{
Fail
(
"
rename
"
_ns
nullptr
PR_GetOSError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
#
endif
}
if
(
mFlush
)
{
if
(
PR_Sync
(
file
)
=
=
PR_FAILURE
)
{
Fail
(
"
sync
"
_ns
nullptr
PR_GetOSError
(
)
)
;
return
NS_ERROR_FAILURE
;
}
}
*
aBytesWritten
=
bytesWrittenSuccess
;
return
NS_OK
;
}
protected
:
nsresult
AfterWriteAtomic
(
TimeStamp
aDispatchDate
int32_t
aBytesWritten
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mResult
-
>
Init
(
aDispatchDate
TimeStamp
:
:
Now
(
)
-
aDispatchDate
aBytesWritten
)
;
Succeed
(
mResult
.
forget
(
)
)
;
return
NS_OK
;
}
const
nsString
mPath
;
const
UniquePtr
<
char
[
]
JS
:
:
FreePolicy
>
mBuffer
;
const
int32_t
mBytes
;
const
nsString
mTmpPath
;
const
nsString
mBackupTo
;
const
bool
mFlush
;
const
bool
mNoOverwrite
;
private
:
RefPtr
<
Int32Result
>
mResult
;
}
;
}
NS_IMPL_ISUPPORTS
(
NativeOSFileInternalsService
nsINativeOSFileInternalsService
)
;
NS_IMETHODIMP
NativeOSFileInternalsService
:
:
Read
(
const
nsAString
&
aPath
JS
:
:
HandleValue
aOptions
nsINativeOSFileSuccessCallback
*
aOnSuccess
nsINativeOSFileErrorCallback
*
aOnError
JSContext
*
cx
)
{
nsCString
encoding
;
uint64_t
bytes
=
UINT64_MAX
;
if
(
aOptions
.
isObject
(
)
)
{
dom
:
:
NativeOSFileReadOptions
dict
;
if
(
!
dict
.
Init
(
cx
aOptions
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
dict
.
mEncoding
.
WasPassed
(
)
)
{
CopyUTF16toUTF8
(
dict
.
mEncoding
.
Value
(
)
encoding
)
;
}
if
(
dict
.
mBytes
.
WasPassed
(
)
&
&
!
dict
.
mBytes
.
Value
(
)
.
IsNull
(
)
)
{
bytes
=
dict
.
mBytes
.
Value
(
)
.
Value
(
)
;
}
}
nsCOMPtr
<
nsINativeOSFileSuccessCallback
>
onSuccess
(
aOnSuccess
)
;
nsMainThreadPtrHandle
<
nsINativeOSFileSuccessCallback
>
onSuccessHandle
(
new
nsMainThreadPtrHolder
<
nsINativeOSFileSuccessCallback
>
(
"
nsINativeOSFileSuccessCallback
"
onSuccess
)
)
;
nsCOMPtr
<
nsINativeOSFileErrorCallback
>
onError
(
aOnError
)
;
nsMainThreadPtrHandle
<
nsINativeOSFileErrorCallback
>
onErrorHandle
(
new
nsMainThreadPtrHolder
<
nsINativeOSFileErrorCallback
>
(
"
nsINativeOSFileErrorCallback
"
onError
)
)
;
RefPtr
<
AbstractDoEvent
>
event
;
if
(
encoding
.
IsEmpty
(
)
)
{
event
=
new
DoReadToTypedArrayEvent
(
aPath
bytes
onSuccessHandle
onErrorHandle
)
;
}
else
{
event
=
new
DoReadToStringEvent
(
aPath
encoding
bytes
onSuccessHandle
onErrorHandle
)
;
}
nsresult
rv
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
target
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
NativeOSFileInternalsService
:
:
WriteAtomic
(
const
nsAString
&
aPath
JS
:
:
HandleValue
aBuffer
JS
:
:
HandleValue
aOptions
nsINativeOSFileSuccessCallback
*
aOnSuccess
nsINativeOSFileErrorCallback
*
aOnError
JSContext
*
cx
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
UniquePtr
<
char
[
]
JS
:
:
FreePolicy
>
buffer
;
int32_t
bytes
;
if
(
!
aBuffer
.
isObject
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
JS
:
:
RootedObject
bufferObject
(
cx
nullptr
)
;
if
(
!
JS_ValueToObject
(
cx
aBuffer
&
bufferObject
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
JS
:
:
IsArrayBufferObject
(
bufferObject
.
get
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
{
size_t
len
=
JS
:
:
GetArrayBufferByteLength
(
bufferObject
.
get
(
)
)
;
if
(
len
>
INT32_MAX
)
{
return
NS_ERROR_INVALID_ARG
;
}
bytes
=
len
;
}
buffer
.
reset
(
static_cast
<
char
*
>
(
JS
:
:
StealArrayBufferContents
(
cx
bufferObject
)
)
)
;
if
(
!
buffer
)
{
return
NS_ERROR_FAILURE
;
}
dom
:
:
NativeOSFileWriteAtomicOptions
dict
;
if
(
aOptions
.
isObject
(
)
)
{
if
(
!
dict
.
Init
(
cx
aOptions
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
}
else
{
if
(
!
dict
.
Init
(
cx
JS
:
:
NullHandleValue
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
dict
.
mBytes
.
WasPassed
(
)
&
&
!
dict
.
mBytes
.
Value
(
)
.
IsNull
(
)
)
{
if
(
dict
.
mBytes
.
Value
(
)
.
Value
(
)
>
PR_INT32_MAX
)
{
return
NS_ERROR_INVALID_ARG
;
}
bytes
=
(
int32_t
)
(
dict
.
mBytes
.
Value
(
)
.
Value
(
)
)
;
}
nsCOMPtr
<
nsINativeOSFileSuccessCallback
>
onSuccess
(
aOnSuccess
)
;
nsMainThreadPtrHandle
<
nsINativeOSFileSuccessCallback
>
onSuccessHandle
(
new
nsMainThreadPtrHolder
<
nsINativeOSFileSuccessCallback
>
(
"
nsINativeOSFileSuccessCallback
"
onSuccess
)
)
;
nsCOMPtr
<
nsINativeOSFileErrorCallback
>
onError
(
aOnError
)
;
nsMainThreadPtrHandle
<
nsINativeOSFileErrorCallback
>
onErrorHandle
(
new
nsMainThreadPtrHolder
<
nsINativeOSFileErrorCallback
>
(
"
nsINativeOSFileErrorCallback
"
onError
)
)
;
RefPtr
<
AbstractDoEvent
>
event
=
new
DoWriteAtomicEvent
(
aPath
std
:
:
move
(
buffer
)
bytes
dict
.
mTmpPath
dict
.
mBackupTo
dict
.
mFlush
dict
.
mNoOverwrite
onSuccessHandle
onErrorHandle
)
;
nsresult
rv
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
target
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
}
