"
use
strict
"
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
add_task
(
async
function
test_nonproto
(
)
{
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
tmpDir
"
test_osfile_async_setDates_nonproto
.
tmp
"
)
;
await
OS
.
File
.
writeAtomic
(
path
new
Uint8Array
(
1
)
)
;
try
{
const
accDate
=
2000
;
const
modDate
=
4000
;
{
await
OS
.
File
.
setDates
(
path
accDate
modDate
)
;
let
stat
=
await
OS
.
File
.
stat
(
path
)
;
Assert
.
equal
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
equal
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
{
await
OS
.
File
.
setDates
(
path
accDate
)
;
let
stat
=
await
OS
.
File
.
stat
(
path
)
;
Assert
.
equal
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
notEqual
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
{
await
OS
.
File
.
setDates
(
path
)
;
let
stat
=
await
OS
.
File
.
stat
(
path
)
;
Assert
.
notEqual
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
notEqual
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
{
await
OS
.
File
.
setDates
(
path
new
Date
(
accDate
)
new
Date
(
modDate
)
)
;
let
stat
=
await
OS
.
File
.
stat
(
path
)
;
Assert
.
equal
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
equal
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
{
for
(
let
p
of
[
"
invalid
"
new
Uint8Array
(
1
)
NaN
]
)
{
try
{
await
OS
.
File
.
setDates
(
path
p
modDate
)
;
do_throw
(
"
Invalid
access
date
should
have
thrown
for
:
"
+
p
)
;
}
catch
(
ex
)
{
let
stat
=
await
OS
.
File
.
stat
(
path
)
;
Assert
.
equal
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
equal
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
try
{
await
OS
.
File
.
setDates
(
path
accDate
p
)
;
do_throw
(
"
Invalid
modification
date
should
have
thrown
for
:
"
+
p
)
;
}
catch
(
ex
)
{
let
stat
=
await
OS
.
File
.
stat
(
path
)
;
Assert
.
equal
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
equal
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
try
{
await
OS
.
File
.
setDates
(
path
p
p
)
;
do_throw
(
"
Invalid
dates
should
have
thrown
for
:
"
+
p
)
;
}
catch
(
ex
)
{
let
stat
=
await
OS
.
File
.
stat
(
path
)
;
Assert
.
equal
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
equal
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
}
}
}
finally
{
await
OS
.
File
.
remove
(
path
)
;
}
}
)
;
add_task
(
async
function
test_proto
(
)
{
if
(
OS
.
Constants
.
Sys
.
Name
=
=
"
Android
"
)
{
info
(
"
File
.
prototype
.
setDates
is
not
implemented
for
Android
"
)
;
Assert
.
equal
(
OS
.
File
.
prototype
.
setDates
undefined
)
;
return
;
}
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
tmpDir
"
test_osfile_async_setDates_proto
.
tmp
"
)
;
await
OS
.
File
.
writeAtomic
(
path
new
Uint8Array
(
1
)
)
;
try
{
let
fd
=
await
OS
.
File
.
open
(
path
{
write
:
true
}
)
;
try
{
const
accDate
=
2000
;
const
modDate
=
4000
;
{
await
fd
.
setDates
(
accDate
modDate
)
;
let
stat
=
await
fd
.
stat
(
)
;
Assert
.
equal
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
equal
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
{
await
fd
.
setDates
(
accDate
)
;
let
stat
=
await
fd
.
stat
(
)
;
Assert
.
equal
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
notEqual
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
{
await
fd
.
setDates
(
)
;
let
stat
=
await
fd
.
stat
(
)
;
Assert
.
notEqual
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
notEqual
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
{
await
fd
.
setDates
(
new
Date
(
accDate
)
new
Date
(
modDate
)
)
;
let
stat
=
await
fd
.
stat
(
)
;
Assert
.
equal
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
equal
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
{
for
(
let
p
of
[
"
invalid
"
new
Uint8Array
(
1
)
NaN
]
)
{
try
{
await
fd
.
setDates
(
p
modDate
)
;
do_throw
(
"
Invalid
access
date
should
have
thrown
for
:
"
+
p
)
;
}
catch
(
ex
)
{
let
stat
=
await
fd
.
stat
(
)
;
Assert
.
equal
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
equal
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
try
{
await
fd
.
setDates
(
accDate
p
)
;
do_throw
(
"
Invalid
modification
date
should
have
thrown
for
:
"
+
p
)
;
}
catch
(
ex
)
{
let
stat
=
await
fd
.
stat
(
)
;
Assert
.
equal
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
equal
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
try
{
await
fd
.
setDates
(
p
p
)
;
do_throw
(
"
Invalid
dates
should
have
thrown
for
:
"
+
p
)
;
}
catch
(
ex
)
{
let
stat
=
await
fd
.
stat
(
)
;
Assert
.
equal
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
equal
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
}
}
}
finally
{
await
fd
.
close
(
)
;
}
}
finally
{
await
OS
.
File
.
remove
(
path
)
;
}
}
)
;
add_task
(
async
function
test_dirs
(
)
{
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
tmpDir
"
test_osfile_async_setDates_dir
"
)
;
await
OS
.
File
.
makeDir
(
path
)
;
try
{
const
accDate
=
2000
;
const
modDate
=
4000
;
{
await
OS
.
File
.
setDates
(
path
accDate
modDate
)
;
let
stat
=
await
OS
.
File
.
stat
(
path
)
;
Assert
.
equal
(
accDate
stat
.
lastAccessDate
.
getTime
(
)
)
;
Assert
.
equal
(
modDate
stat
.
lastModificationDate
.
getTime
(
)
)
;
}
}
finally
{
await
OS
.
File
.
removeEmptyDir
(
path
)
;
}
}
)
;
