#
include
"
nsWindowWatcher
.
h
"
#
include
"
nsAutoWindowStateHelper
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIAuthPrompt
.
h
"
#
include
"
nsIAuthPrompt2
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsHashPropertyBag
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIBrowserDOMWindow
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
nsIDocumentLoader
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIScreen
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIWebBrowser
.
h
"
#
include
"
nsIWebBrowserChrome
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIWindowCreator
.
h
"
#
include
"
nsIWindowCreator2
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIWindowProvider
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsIDOMStorageManager
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsSimpleEnumerator
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Storage
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
nsIXULWindow
.
h
"
#
include
"
nsIXULBrowserWindow
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
ReferrerInfo
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
class
nsWindowWatcher
;
struct
nsWatcherWindowEntry
{
nsWatcherWindowEntry
(
mozIDOMWindowProxy
*
aWindow
nsIWebBrowserChrome
*
aChrome
)
:
mChrome
(
nullptr
)
{
mWindow
=
aWindow
;
nsCOMPtr
<
nsISupportsWeakReference
>
supportsweak
(
do_QueryInterface
(
aChrome
)
)
;
if
(
supportsweak
)
{
supportsweak
-
>
GetWeakReference
(
getter_AddRefs
(
mChromeWeak
)
)
;
}
else
{
mChrome
=
aChrome
;
mChromeWeak
=
nullptr
;
}
ReferenceSelf
(
)
;
}
~
nsWatcherWindowEntry
(
)
{
}
void
InsertAfter
(
nsWatcherWindowEntry
*
aOlder
)
;
void
Unlink
(
)
;
void
ReferenceSelf
(
)
;
mozIDOMWindowProxy
*
mWindow
;
nsIWebBrowserChrome
*
mChrome
;
nsWeakPtr
mChromeWeak
;
nsWatcherWindowEntry
*
mYounger
;
nsWatcherWindowEntry
*
mOlder
;
}
;
void
nsWatcherWindowEntry
:
:
InsertAfter
(
nsWatcherWindowEntry
*
aOlder
)
{
if
(
aOlder
)
{
mOlder
=
aOlder
;
mYounger
=
aOlder
-
>
mYounger
;
mOlder
-
>
mYounger
=
this
;
if
(
mOlder
-
>
mOlder
=
=
mOlder
)
{
mOlder
-
>
mOlder
=
this
;
}
mYounger
-
>
mOlder
=
this
;
if
(
mYounger
-
>
mYounger
=
=
mYounger
)
{
mYounger
-
>
mYounger
=
this
;
}
}
}
void
nsWatcherWindowEntry
:
:
Unlink
(
)
{
mOlder
-
>
mYounger
=
mYounger
;
mYounger
-
>
mOlder
=
mOlder
;
ReferenceSelf
(
)
;
}
void
nsWatcherWindowEntry
:
:
ReferenceSelf
(
)
{
mYounger
=
this
;
mOlder
=
this
;
}
class
nsWatcherWindowEnumerator
:
public
nsSimpleEnumerator
{
public
:
explicit
nsWatcherWindowEnumerator
(
nsWindowWatcher
*
aWatcher
)
;
NS_IMETHOD
HasMoreElements
(
bool
*
aResult
)
override
;
NS_IMETHOD
GetNext
(
nsISupports
*
*
aResult
)
override
;
protected
:
~
nsWatcherWindowEnumerator
(
)
override
;
private
:
friend
class
nsWindowWatcher
;
nsWatcherWindowEntry
*
FindNext
(
)
;
void
WindowRemoved
(
nsWatcherWindowEntry
*
aInfo
)
;
nsWindowWatcher
*
mWindowWatcher
;
nsWatcherWindowEntry
*
mCurrentPosition
;
}
;
nsWatcherWindowEnumerator
:
:
nsWatcherWindowEnumerator
(
nsWindowWatcher
*
aWatcher
)
:
mWindowWatcher
(
aWatcher
)
mCurrentPosition
(
aWatcher
-
>
mOldestWindow
)
{
mWindowWatcher
-
>
AddEnumerator
(
this
)
;
mWindowWatcher
-
>
AddRef
(
)
;
}
nsWatcherWindowEnumerator
:
:
~
nsWatcherWindowEnumerator
(
)
{
mWindowWatcher
-
>
RemoveEnumerator
(
this
)
;
mWindowWatcher
-
>
Release
(
)
;
}
NS_IMETHODIMP
nsWatcherWindowEnumerator
:
:
HasMoreElements
(
bool
*
aResult
)
{
if
(
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
!
!
mCurrentPosition
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWatcherWindowEnumerator
:
:
GetNext
(
nsISupports
*
*
aResult
)
{
if
(
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
nullptr
;
if
(
mCurrentPosition
)
{
CallQueryInterface
(
mCurrentPosition
-
>
mWindow
aResult
)
;
mCurrentPosition
=
FindNext
(
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
nsWatcherWindowEntry
*
nsWatcherWindowEnumerator
:
:
FindNext
(
)
{
nsWatcherWindowEntry
*
info
;
if
(
!
mCurrentPosition
)
{
return
0
;
}
info
=
mCurrentPosition
-
>
mYounger
;
return
info
=
=
mWindowWatcher
-
>
mOldestWindow
?
0
:
info
;
}
void
nsWatcherWindowEnumerator
:
:
WindowRemoved
(
nsWatcherWindowEntry
*
aInfo
)
{
if
(
mCurrentPosition
=
=
aInfo
)
{
mCurrentPosition
=
mCurrentPosition
!
=
aInfo
-
>
mYounger
?
aInfo
-
>
mYounger
:
0
;
}
}
NS_IMPL_ADDREF
(
nsWindowWatcher
)
NS_IMPL_RELEASE
(
nsWindowWatcher
)
NS_IMPL_QUERY_INTERFACE
(
nsWindowWatcher
nsIWindowWatcher
nsIPromptFactory
nsPIWindowWatcher
)
nsWindowWatcher
:
:
nsWindowWatcher
(
)
:
mEnumeratorList
(
)
mOldestWindow
(
0
)
mListLock
(
"
nsWindowWatcher
.
mListLock
"
)
{
}
nsWindowWatcher
:
:
~
nsWindowWatcher
(
)
{
while
(
mOldestWindow
)
{
RemoveWindow
(
mOldestWindow
)
;
}
}
nsresult
nsWindowWatcher
:
:
Init
(
)
{
return
NS_OK
;
}
static
already_AddRefed
<
nsIArray
>
ConvertArgsToArray
(
nsISupports
*
aArguments
)
{
if
(
!
aArguments
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIArray
>
array
=
do_QueryInterface
(
aArguments
)
;
if
(
array
)
{
uint32_t
argc
=
0
;
array
-
>
GetLength
(
&
argc
)
;
if
(
argc
=
=
0
)
{
return
nullptr
;
}
return
array
.
forget
(
)
;
}
nsCOMPtr
<
nsIMutableArray
>
singletonArray
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
)
;
NS_ENSURE_TRUE
(
singletonArray
nullptr
)
;
nsresult
rv
=
singletonArray
-
>
AppendElement
(
aArguments
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
singletonArray
.
forget
(
)
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
OpenWindow
(
mozIDOMWindowProxy
*
aParent
const
char
*
aUrl
const
char
*
aName
const
char
*
aFeatures
nsISupports
*
aArguments
mozIDOMWindowProxy
*
*
aResult
)
{
nsCOMPtr
<
nsIArray
>
argv
=
ConvertArgsToArray
(
aArguments
)
;
uint32_t
argc
=
0
;
if
(
argv
)
{
argv
-
>
GetLength
(
&
argc
)
;
}
bool
dialog
=
(
argc
!
=
0
)
;
return
OpenWindowInternal
(
aParent
aUrl
aName
aFeatures
false
dialog
true
argv
false
false
nullptr
aResult
)
;
}
struct
SizeSpec
{
SizeSpec
(
)
:
mLeft
(
0
)
mTop
(
0
)
mOuterWidth
(
0
)
mOuterHeight
(
0
)
mInnerWidth
(
0
)
mInnerHeight
(
0
)
mLeftSpecified
(
false
)
mTopSpecified
(
false
)
mOuterWidthSpecified
(
false
)
mOuterHeightSpecified
(
false
)
mInnerWidthSpecified
(
false
)
mInnerHeightSpecified
(
false
)
mUseDefaultWidth
(
false
)
mUseDefaultHeight
(
false
)
{
}
int32_t
mLeft
;
int32_t
mTop
;
int32_t
mOuterWidth
;
int32_t
mOuterHeight
;
int32_t
mInnerWidth
;
int32_t
mInnerHeight
;
bool
mLeftSpecified
;
bool
mTopSpecified
;
bool
mOuterWidthSpecified
;
bool
mOuterHeightSpecified
;
bool
mInnerWidthSpecified
;
bool
mInnerHeightSpecified
;
bool
mUseDefaultWidth
;
bool
mUseDefaultHeight
;
bool
PositionSpecified
(
)
const
{
return
mLeftSpecified
|
|
mTopSpecified
;
}
bool
SizeSpecified
(
)
const
{
return
mOuterWidthSpecified
|
|
mOuterHeightSpecified
|
|
mInnerWidthSpecified
|
|
mInnerHeightSpecified
;
}
}
;
NS_IMETHODIMP
nsWindowWatcher
:
:
OpenWindow2
(
mozIDOMWindowProxy
*
aParent
const
char
*
aUrl
const
char
*
aName
const
char
*
aFeatures
bool
aCalledFromScript
bool
aDialog
bool
aNavigate
nsISupports
*
aArguments
bool
aIsPopupSpam
bool
aForceNoOpener
nsDocShellLoadState
*
aLoadState
mozIDOMWindowProxy
*
*
aResult
)
{
nsCOMPtr
<
nsIArray
>
argv
=
ConvertArgsToArray
(
aArguments
)
;
uint32_t
argc
=
0
;
if
(
argv
)
{
argv
-
>
GetLength
(
&
argc
)
;
}
bool
dialog
=
aDialog
;
if
(
!
aCalledFromScript
)
{
dialog
=
argc
>
0
;
}
return
OpenWindowInternal
(
aParent
aUrl
aName
aFeatures
aCalledFromScript
dialog
aNavigate
argv
aIsPopupSpam
aForceNoOpener
aLoadState
aResult
)
;
}
static
bool
CheckUserContextCompatibility
(
nsIDocShell
*
aDocShell
)
{
MOZ_ASSERT
(
aDocShell
)
;
uint32_t
userContextId
=
static_cast
<
nsDocShell
*
>
(
aDocShell
)
-
>
GetOriginAttributes
(
)
.
mUserContextId
;
nsCOMPtr
<
nsIPrincipal
>
subjectPrincipal
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
?
nsContentUtils
:
:
SubjectPrincipal
(
)
:
nullptr
;
if
(
!
subjectPrincipal
)
{
return
true
;
}
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
subjectPrincipal
)
)
{
return
true
;
}
return
subjectPrincipal
-
>
GetUserContextId
(
)
=
=
userContextId
;
}
nsresult
nsWindowWatcher
:
:
CreateChromeWindow
(
const
nsACString
&
aFeatures
nsIWebBrowserChrome
*
aParentChrome
uint32_t
aChromeFlags
nsITabParent
*
aOpeningTabParent
mozIDOMWindowProxy
*
aOpener
uint64_t
aNextTabParentId
nsIWebBrowserChrome
*
*
aResult
)
{
nsCOMPtr
<
nsIWindowCreator2
>
windowCreator2
(
do_QueryInterface
(
mWindowCreator
)
)
;
if
(
NS_WARN_IF
(
!
windowCreator2
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
bool
cancel
=
false
;
nsCOMPtr
<
nsIWebBrowserChrome
>
newWindowChrome
;
nsresult
rv
=
windowCreator2
-
>
CreateChromeWindow2
(
aParentChrome
aChromeFlags
aOpeningTabParent
aOpener
aNextTabParentId
&
cancel
getter_AddRefs
(
newWindowChrome
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
cancel
)
{
newWindowChrome
=
nullptr
;
return
NS_ERROR_ABORT
;
}
newWindowChrome
.
forget
(
aResult
)
;
return
NS_OK
;
}
void
nsWindowWatcher
:
:
MaybeDisablePersistence
(
const
nsACString
&
aFeatures
nsIDocShellTreeOwner
*
aTreeOwner
)
{
if
(
!
aTreeOwner
)
{
return
;
}
if
(
PL_strcasestr
(
aFeatures
.
BeginReading
(
)
"
width
=
"
)
|
|
PL_strcasestr
(
aFeatures
.
BeginReading
(
)
"
height
=
"
)
)
{
aTreeOwner
-
>
SetPersistence
(
false
false
false
)
;
}
}
NS_IMETHODIMP
nsWindowWatcher
:
:
OpenWindowWithTabParent
(
nsITabParent
*
aOpeningTabParent
const
nsACString
&
aFeatures
bool
aCalledFromJS
float
aOpenerFullZoom
uint64_t
aNextTabParentId
bool
aForceNoOpener
nsITabParent
*
*
aResult
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
mWindowCreator
)
;
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsContentUtils
:
:
WarnScriptWasIgnored
(
nullptr
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
mWindowCreator
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
bool
isPrivateBrowsingWindow
=
Preferences
:
:
GetBool
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parentWindowOuter
;
if
(
aOpeningTabParent
)
{
TabParent
*
openingTab
=
TabParent
:
:
GetFrom
(
aOpeningTabParent
)
;
parentWindowOuter
=
openingTab
-
>
GetParentWindowOuter
(
)
;
if
(
!
isPrivateBrowsingWindow
)
{
nsCOMPtr
<
nsILoadContext
>
parentContext
=
openingTab
-
>
GetLoadContext
(
)
;
if
(
parentContext
)
{
isPrivateBrowsingWindow
=
parentContext
-
>
UsePrivateBrowsing
(
)
;
}
}
}
if
(
!
parentWindowOuter
)
{
parentWindowOuter
=
nsContentUtils
:
:
GetMostRecentNonPBWindow
(
)
;
}
if
(
NS_WARN_IF
(
!
parentWindowOuter
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
parentTreeOwner
;
GetWindowTreeOwner
(
parentWindowOuter
getter_AddRefs
(
parentTreeOwner
)
)
;
if
(
NS_WARN_IF
(
!
parentTreeOwner
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIWindowCreator2
>
windowCreator2
(
do_QueryInterface
(
mWindowCreator
)
)
;
if
(
NS_WARN_IF
(
!
windowCreator2
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
uint32_t
chromeFlags
=
CalculateChromeFlagsForChild
(
aFeatures
)
;
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
;
nsCOMPtr
<
nsIWebBrowserChrome
>
parentChrome
(
do_GetInterface
(
parentTreeOwner
)
)
;
nsCOMPtr
<
nsIWebBrowserChrome
>
newWindowChrome
;
CreateChromeWindow
(
aFeatures
parentChrome
chromeFlags
aForceNoOpener
?
nullptr
:
aOpeningTabParent
nullptr
aNextTabParentId
getter_AddRefs
(
newWindowChrome
)
)
;
if
(
NS_WARN_IF
(
!
newWindowChrome
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
chromeTreeItem
=
do_GetInterface
(
newWindowChrome
)
;
if
(
NS_WARN_IF
(
!
chromeTreeItem
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
chromeTreeOwner
;
chromeTreeItem
-
>
GetTreeOwner
(
getter_AddRefs
(
chromeTreeOwner
)
)
;
if
(
NS_WARN_IF
(
!
chromeTreeOwner
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsILoadContext
>
chromeContext
=
do_QueryInterface
(
chromeTreeItem
)
;
if
(
NS_WARN_IF
(
!
chromeContext
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
chromeContext
-
>
SetPrivateBrowsing
(
isPrivateBrowsingWindow
)
;
chromeContext
-
>
SetRemoteTabs
(
true
)
;
MaybeDisablePersistence
(
aFeatures
chromeTreeOwner
)
;
SizeSpec
sizeSpec
;
CalcSizeSpec
(
aFeatures
sizeSpec
)
;
SizeOpenedWindow
(
chromeTreeOwner
parentWindowOuter
false
sizeSpec
Some
(
aOpenerFullZoom
)
)
;
nsCOMPtr
<
nsITabParent
>
newTabParent
;
chromeTreeOwner
-
>
GetPrimaryTabParent
(
getter_AddRefs
(
newTabParent
)
)
;
if
(
NS_WARN_IF
(
!
newTabParent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
newTabParent
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
nsWindowWatcher
:
:
OpenWindowInternal
(
mozIDOMWindowProxy
*
aParent
const
char
*
aUrl
const
char
*
aName
const
char
*
aFeatures
bool
aCalledFromJS
bool
aDialog
bool
aNavigate
nsIArray
*
aArgv
bool
aIsPopupSpam
bool
aForceNoOpener
nsDocShellLoadState
*
aLoadState
mozIDOMWindowProxy
*
*
aResult
)
{
nsresult
rv
=
NS_OK
;
bool
isNewToplevelWindow
=
false
;
bool
windowIsNew
=
false
;
bool
windowNeedsName
=
false
;
bool
windowIsModal
=
false
;
bool
uriToLoadIsChrome
=
false
;
bool
windowIsModalContentDialog
=
false
;
uint32_t
chromeFlags
;
nsAutoString
name
;
nsAutoCString
features
;
nsCOMPtr
<
nsIURI
>
uriToLoad
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
parentTreeOwner
;
nsCOMPtr
<
nsIDocShellTreeItem
>
newDocShellItem
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
=
aParent
?
nsPIDOMWindowOuter
:
:
From
(
aParent
)
:
nullptr
;
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
0
;
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsContentUtils
:
:
WarnScriptWasIgnored
(
nullptr
)
;
return
NS_ERROR_FAILURE
;
}
GetWindowTreeOwner
(
parent
getter_AddRefs
(
parentTreeOwner
)
)
;
if
(
aUrl
)
{
rv
=
URIfromURL
(
aUrl
aParent
getter_AddRefs
(
uriToLoad
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uriToLoad
-
>
SchemeIs
(
"
chrome
"
&
uriToLoadIsChrome
)
;
}
bool
nameSpecified
=
false
;
if
(
aName
)
{
CopyUTF8toUTF16
(
MakeStringSpan
(
aName
)
name
)
;
nameSpecified
=
true
;
}
else
{
name
.
SetIsVoid
(
true
)
;
}
if
(
aFeatures
)
{
features
.
Assign
(
aFeatures
)
;
features
.
StripWhitespace
(
)
;
}
else
{
features
.
SetIsVoid
(
true
)
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
foundWindow
=
SafeGetWindowByName
(
name
aForceNoOpener
aParent
)
;
GetWindowTreeItem
(
foundWindow
getter_AddRefs
(
newDocShellItem
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parentWindow
=
aParent
?
nsPIDOMWindowOuter
:
:
From
(
aParent
)
:
nullptr
;
nsCOMPtr
<
nsIDocShell
>
parentDocShell
;
if
(
parentWindow
)
{
parentDocShell
=
parentWindow
-
>
GetDocShell
(
)
;
if
(
parentDocShell
)
{
nsCOMPtr
<
nsIDocShell
>
foundDocShell
=
do_QueryInterface
(
newDocShellItem
)
;
if
(
parentDocShell
-
>
IsSandboxedFrom
(
foundDocShell
)
)
{
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
}
}
bool
hasChromeParent
=
XRE_IsContentProcess
(
)
?
false
:
true
;
if
(
aParent
)
{
Document
*
doc
=
parentWindow
-
>
GetDoc
(
)
;
hasChromeParent
=
doc
&
&
nsContentUtils
:
:
IsChromeDoc
(
doc
)
;
}
bool
isCallerChrome
=
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
;
if
(
isCallerChrome
&
&
XRE_IsParentProcess
(
)
)
{
chromeFlags
=
CalculateChromeFlagsForParent
(
aParent
features
aDialog
uriToLoadIsChrome
hasChromeParent
aCalledFromJS
)
;
}
else
{
chromeFlags
=
CalculateChromeFlagsForChild
(
features
)
;
if
(
aDialog
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
;
}
}
SizeSpec
sizeSpec
;
CalcSizeSpec
(
features
sizeSpec
)
;
dom
:
:
AutoJSAPI
jsapiChromeGuard
;
bool
windowTypeIsChrome
=
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
if
(
isCallerChrome
&
&
!
hasChromeParent
&
&
!
windowTypeIsChrome
)
{
nsCOMPtr
<
nsIGlobalObject
>
parentGlobalObject
=
do_QueryInterface
(
aParent
)
;
if
(
!
aParent
)
{
jsapiChromeGuard
.
Init
(
)
;
}
else
if
(
NS_WARN_IF
(
!
jsapiChromeGuard
.
Init
(
parentGlobalObject
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
}
uint32_t
activeDocsSandboxFlags
=
0
;
if
(
!
newDocShellItem
)
{
windowNeedsName
=
true
;
if
(
aParent
)
{
if
(
Document
*
doc
=
parentWindow
-
>
GetDoc
(
)
)
{
activeDocsSandboxFlags
=
doc
-
>
GetSandboxFlags
(
)
;
if
(
activeDocsSandboxFlags
&
SANDBOXED_AUXILIARY_NAVIGATION
)
{
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
}
}
nsCOMPtr
<
nsIDOMChromeWindow
>
chromeWin
=
do_QueryInterface
(
aParent
)
;
if
(
!
aDialog
&
&
!
chromeWin
&
&
!
(
chromeFlags
&
(
nsIWebBrowserChrome
:
:
CHROME_MODAL
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
)
)
)
{
nsCOMPtr
<
nsIWindowProvider
>
provider
;
if
(
parentTreeOwner
)
{
provider
=
do_GetInterface
(
parentTreeOwner
)
;
}
else
if
(
XRE_IsContentProcess
(
)
)
{
provider
=
nsContentUtils
:
:
GetWindowProviderForContentProcess
(
)
;
}
if
(
provider
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
newWindow
;
rv
=
provider
-
>
ProvideWindow
(
aParent
chromeFlags
aCalledFromJS
sizeSpec
.
PositionSpecified
(
)
sizeSpec
.
SizeSpecified
(
)
uriToLoad
name
features
aForceNoOpener
aLoadState
&
windowIsNew
getter_AddRefs
(
newWindow
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
GetWindowTreeItem
(
newWindow
getter_AddRefs
(
newDocShellItem
)
)
;
if
(
windowIsNew
&
&
newDocShellItem
)
{
nsCOMPtr
<
nsIWebNavigation
>
webNav
=
do_QueryInterface
(
newDocShellItem
)
;
webNav
-
>
Stop
(
nsIWebNavigation
:
:
STOP_NETWORK
)
;
}
if
(
!
windowIsNew
&
&
newDocShellItem
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
do_QueryInterface
(
newDocShellItem
)
;
if
(
!
CheckUserContextCompatibility
(
docShell
)
)
{
newWindow
=
nullptr
;
newDocShellItem
=
nullptr
;
windowIsNew
=
false
;
}
}
}
else
if
(
rv
=
=
NS_ERROR_ABORT
)
{
return
NS_OK
;
}
}
}
}
bool
newWindowShouldBeModal
=
false
;
bool
parentIsModal
=
false
;
if
(
!
newDocShellItem
)
{
windowIsNew
=
true
;
isNewToplevelWindow
=
true
;
nsCOMPtr
<
nsIWebBrowserChrome
>
parentChrome
(
do_GetInterface
(
parentTreeOwner
)
)
;
bool
weAreModal
=
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_MODAL
)
!
=
0
;
newWindowShouldBeModal
=
weAreModal
;
if
(
!
weAreModal
&
&
parentChrome
)
{
parentChrome
-
>
IsWindowModal
(
&
weAreModal
)
;
parentIsModal
=
weAreModal
;
}
if
(
weAreModal
)
{
windowIsModal
=
true
;
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_MODAL
|
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
;
}
if
(
!
hasChromeParent
&
&
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_MODAL
)
)
{
nsCOMPtr
<
nsIBaseWindow
>
parentWindow
(
do_GetInterface
(
parentTreeOwner
)
)
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
if
(
parentWindow
)
{
parentWindow
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
}
if
(
parentWidget
&
&
!
parentWidget
-
>
IsVisible
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
NS_ASSERTION
(
mWindowCreator
"
attempted
to
open
a
new
window
with
no
WindowCreator
"
)
;
rv
=
NS_ERROR_FAILURE
;
if
(
mWindowCreator
)
{
nsCOMPtr
<
nsIWebBrowserChrome
>
newChrome
;
nsCOMPtr
<
nsPIDOMWindowInner
>
parentTopInnerWindow
;
if
(
parentWindow
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
parentTopWindow
=
parentWindow
-
>
GetTop
(
)
;
if
(
parentTopWindow
)
{
parentTopInnerWindow
=
parentTopWindow
-
>
GetCurrentInnerWindow
(
)
;
}
}
if
(
parentTopInnerWindow
)
{
parentTopInnerWindow
-
>
Suspend
(
)
;
}
nsCOMPtr
<
nsIWindowCreator2
>
windowCreator2
(
do_QueryInterface
(
mWindowCreator
)
)
;
if
(
windowCreator2
)
{
mozIDOMWindowProxy
*
openerWindow
=
aForceNoOpener
?
nullptr
:
aParent
;
rv
=
CreateChromeWindow
(
features
parentChrome
chromeFlags
nullptr
openerWindow
0
getter_AddRefs
(
newChrome
)
)
;
}
else
{
rv
=
mWindowCreator
-
>
CreateChromeWindow
(
parentChrome
chromeFlags
getter_AddRefs
(
newChrome
)
)
;
}
if
(
parentTopInnerWindow
)
{
parentTopInnerWindow
-
>
Resume
(
)
;
}
if
(
newChrome
)
{
nsCOMPtr
<
nsIXULWindow
>
xulWin
=
do_GetInterface
(
newChrome
)
;
if
(
xulWin
)
{
nsCOMPtr
<
nsIXULBrowserWindow
>
xulBrowserWin
;
xulWin
-
>
GetXULBrowserWindow
(
getter_AddRefs
(
xulBrowserWin
)
)
;
if
(
xulBrowserWin
)
{
nsPIDOMWindowOuter
*
openerWindow
=
aForceNoOpener
?
nullptr
:
parentWindow
.
get
(
)
;
xulBrowserWin
-
>
ForceInitialBrowserNonRemote
(
openerWindow
)
;
}
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
newWindow
(
do_GetInterface
(
newChrome
)
)
;
if
(
newWindow
)
{
GetWindowTreeItem
(
newWindow
getter_AddRefs
(
newDocShellItem
)
)
;
}
if
(
!
newDocShellItem
)
{
newDocShellItem
=
do_GetInterface
(
newChrome
)
;
}
if
(
!
newDocShellItem
)
{
rv
=
NS_ERROR_FAILURE
;
}
}
}
}
if
(
!
newDocShellItem
)
{
return
rv
;
}
nsCOMPtr
<
nsIDocShell
>
newDocShell
(
do_QueryInterface
(
newDocShellItem
)
)
;
NS_ENSURE_TRUE
(
newDocShell
NS_ERROR_UNEXPECTED
)
;
if
(
activeDocsSandboxFlags
&
&
parentWindow
)
{
newDocShell
-
>
SetOnePermittedSandboxedNavigator
(
parentWindow
-
>
GetDocShell
(
)
)
;
}
if
(
activeDocsSandboxFlags
&
SANDBOX_PROPAGATES_TO_AUXILIARY_BROWSING_CONTEXTS
)
{
newDocShell
-
>
SetSandboxFlags
(
activeDocsSandboxFlags
)
;
}
rv
=
ReadyOpenedDocShellItem
(
newDocShellItem
parentWindow
windowIsNew
aForceNoOpener
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
isNewToplevelWindow
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
newTreeOwner
;
newDocShellItem
-
>
GetTreeOwner
(
getter_AddRefs
(
newTreeOwner
)
)
;
MaybeDisablePersistence
(
features
newTreeOwner
)
;
}
if
(
(
aDialog
|
|
windowIsModalContentDialog
)
&
&
aArgv
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
piwin
(
do_QueryInterface
(
*
aResult
)
)
;
NS_ENSURE_TRUE
(
piwin
NS_ERROR_UNEXPECTED
)
;
rv
=
piwin
-
>
SetArguments
(
aArgv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
windowNeedsName
)
{
if
(
nameSpecified
&
&
!
name
.
LowerCaseEqualsLiteral
(
"
_blank
"
)
)
{
newDocShellItem
-
>
SetName
(
name
)
;
}
else
{
newDocShellItem
-
>
SetName
(
EmptyString
(
)
)
;
}
}
nsCOMPtr
<
nsIPrincipal
>
subjectPrincipal
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
?
nsContentUtils
:
:
SubjectPrincipal
(
)
:
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
bool
isPrivateBrowsingWindow
=
false
;
if
(
windowIsNew
)
{
auto
*
docShell
=
static_cast
<
nsDocShell
*
>
(
newDocShell
.
get
(
)
)
;
if
(
subjectPrincipal
&
&
!
nsContentUtils
:
:
IsSystemOrExpandedPrincipal
(
subjectPrincipal
)
&
&
docShell
-
>
ItemType
(
)
!
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
isPrivateBrowsingWindow
=
!
!
subjectPrincipal
-
>
OriginAttributesRef
(
)
.
mPrivateBrowsingId
;
docShell
-
>
SetOriginAttributes
(
subjectPrincipal
-
>
OriginAttributesRef
(
)
)
;
}
else
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parentItem
;
GetWindowTreeItem
(
aParent
getter_AddRefs
(
parentItem
)
)
;
nsCOMPtr
<
nsILoadContext
>
parentContext
=
do_QueryInterface
(
parentItem
)
;
if
(
parentContext
)
{
isPrivateBrowsingWindow
=
parentContext
-
>
UsePrivateBrowsing
(
)
;
}
}
bool
autoPrivateBrowsing
=
Preferences
:
:
GetBool
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
if
(
!
autoPrivateBrowsing
&
&
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_NON_PRIVATE_WINDOW
)
)
{
isPrivateBrowsingWindow
=
false
;
}
else
if
(
autoPrivateBrowsing
|
|
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
)
)
{
isPrivateBrowsingWindow
=
true
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
newWindow
=
do_QueryInterface
(
*
aResult
)
;
NS_ASSERTION
(
newWindow
=
=
newDocShell
-
>
GetWindow
(
)
"
Different
windows
?
?
"
)
;
if
(
newWindow
)
{
newWindow
-
>
SetInitialPrincipalToSubject
(
)
;
if
(
aIsPopupSpam
)
{
nsGlobalWindowOuter
*
globalWin
=
nsGlobalWindowOuter
:
:
Cast
(
newWindow
)
;
MOZ_ASSERT
(
!
globalWin
-
>
IsPopupSpamWindow
(
)
"
Who
marked
it
as
popup
spam
already
?
?
?
"
)
;
if
(
!
globalWin
-
>
IsPopupSpamWindow
(
)
)
{
globalWin
-
>
SetIsPopupSpamWindow
(
true
)
;
}
}
}
}
bool
isRemoteWindow
=
!
!
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
)
;
if
(
isNewToplevelWindow
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
childRoot
;
newDocShellItem
-
>
GetRootTreeItem
(
getter_AddRefs
(
childRoot
)
)
;
nsCOMPtr
<
nsILoadContext
>
childContext
=
do_QueryInterface
(
childRoot
)
;
if
(
childContext
)
{
childContext
-
>
SetPrivateBrowsing
(
isPrivateBrowsingWindow
)
;
childContext
-
>
SetRemoteTabs
(
isRemoteWindow
)
;
}
}
else
if
(
windowIsNew
)
{
nsCOMPtr
<
nsILoadContext
>
childContext
=
do_QueryInterface
(
newDocShellItem
)
;
if
(
childContext
)
{
childContext
-
>
SetPrivateBrowsing
(
isPrivateBrowsingWindow
)
;
childContext
-
>
SetRemoteTabs
(
isRemoteWindow
)
;
}
}
RefPtr
<
nsDocShellLoadState
>
loadState
=
aLoadState
;
if
(
uriToLoad
&
&
loadState
)
{
loadState
-
>
SetURI
(
uriToLoad
)
;
}
else
if
(
uriToLoad
&
&
aNavigate
&
&
!
loadState
)
{
loadState
=
new
nsDocShellLoadState
(
uriToLoad
)
;
if
(
subjectPrincipal
)
{
loadState
-
>
SetTriggeringPrincipal
(
subjectPrincipal
)
;
}
#
ifndef
ANDROID
MOZ_ASSERT
(
subjectPrincipal
"
nsWindowWatcher
:
triggeringPrincipal
required
"
)
;
#
endif
RefPtr
<
Document
>
doc
=
GetEntryDocument
(
)
;
if
(
!
doc
&
&
parentWindow
)
{
doc
=
parentWindow
-
>
GetExtantDoc
(
)
;
}
if
(
doc
)
{
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
new
ReferrerInfo
(
doc
-
>
GetDocumentURI
(
)
doc
-
>
GetReferrerPolicy
(
)
)
;
loadState
-
>
SetReferrerInfo
(
referrerInfo
)
;
}
}
if
(
isNewToplevelWindow
)
{
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
NotifyObservers
(
*
aResult
"
toplevel
-
window
-
ready
"
nullptr
)
;
}
}
MOZ_ASSERT
(
CheckUserContextCompatibility
(
newDocShell
)
)
;
if
(
parentDocShell
&
&
newDocShellItem
)
{
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
RefPtr
<
nsHashPropertyBag
>
props
=
new
nsHashPropertyBag
(
)
;
if
(
uriToLoad
)
{
props
-
>
SetPropertyAsACString
(
NS_LITERAL_STRING
(
"
url
"
)
uriToLoad
-
>
GetSpecOrDefault
(
)
)
;
}
props
-
>
SetPropertyAsInterface
(
NS_LITERAL_STRING
(
"
sourceTabDocShell
"
)
parentDocShell
)
;
props
-
>
SetPropertyAsInterface
(
NS_LITERAL_STRING
(
"
createdTabDocShell
"
)
newDocShellItem
)
;
obsSvc
-
>
NotifyObservers
(
static_cast
<
nsIPropertyBag2
*
>
(
props
)
"
webNavigation
-
createdNavigationTarget
-
from
-
js
"
nullptr
)
;
}
}
if
(
uriToLoad
&
&
aNavigate
)
{
loadState
-
>
SetLoadFlags
(
windowIsNew
?
static_cast
<
uint32_t
>
(
nsIWebNavigation
:
:
LOAD_FLAGS_FIRST_LOAD
)
:
static_cast
<
uint32_t
>
(
nsIWebNavigation
:
:
LOAD_FLAGS_NONE
)
)
;
loadState
-
>
SetFirstParty
(
true
)
;
newDocShell
-
>
LoadURI
(
loadState
)
;
}
if
(
!
aForceNoOpener
&
&
subjectPrincipal
&
&
parentDocShell
)
{
nsCOMPtr
<
nsIDOMStorageManager
>
parentStorageManager
=
do_QueryInterface
(
parentDocShell
)
;
nsCOMPtr
<
nsIDOMStorageManager
>
newStorageManager
=
do_QueryInterface
(
newDocShell
)
;
if
(
parentStorageManager
&
&
newStorageManager
)
{
RefPtr
<
Storage
>
storage
;
nsCOMPtr
<
nsPIDOMWindowInner
>
pInnerWin
=
parentWindow
-
>
GetCurrentInnerWindow
(
)
;
parentStorageManager
-
>
GetStorage
(
pInnerWin
subjectPrincipal
isPrivateBrowsingWindow
getter_AddRefs
(
storage
)
)
;
if
(
storage
)
{
newStorageManager
-
>
CloneStorage
(
storage
)
;
}
}
}
if
(
isNewToplevelWindow
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
newTreeOwner
;
newDocShellItem
-
>
GetTreeOwner
(
getter_AddRefs
(
newTreeOwner
)
)
;
SizeOpenedWindow
(
newTreeOwner
aParent
isCallerChrome
sizeSpec
)
;
}
if
(
windowIsModal
|
|
windowIsModalContentDialog
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
newTreeOwner
;
newDocShellItem
-
>
GetTreeOwner
(
getter_AddRefs
(
newTreeOwner
)
)
;
nsCOMPtr
<
nsIWebBrowserChrome
>
newChrome
(
do_GetInterface
(
newTreeOwner
)
)
;
NS_ENSURE_TRUE
(
newChrome
NS_ERROR_NOT_AVAILABLE
)
;
nsAutoWindowStateHelper
windowStateHelper
(
parentWindow
?
parentWindow
-
>
GetOuterWindow
(
)
:
nullptr
)
;
if
(
!
windowStateHelper
.
DefaultEnabled
(
)
)
{
NS_RELEASE
(
*
aResult
)
;
return
NS_OK
;
}
bool
isAppModal
=
false
;
nsCOMPtr
<
nsIBaseWindow
>
parentWindow
(
do_GetInterface
(
newTreeOwner
)
)
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
if
(
parentWindow
)
{
parentWindow
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
if
(
parentWidget
)
{
isAppModal
=
parentWidget
-
>
IsRunningAppModal
(
)
;
}
}
if
(
parentWidget
&
&
(
(
!
newWindowShouldBeModal
&
&
parentIsModal
)
|
|
isAppModal
)
)
{
parentWidget
-
>
SetFakeModal
(
true
)
;
}
else
{
nsAutoPopupStatePusher
popupStatePusher
(
PopupBlocker
:
:
openAbused
)
;
newChrome
-
>
ShowAsModal
(
)
;
}
}
if
(
aForceNoOpener
&
&
windowIsNew
)
{
NS_RELEASE
(
*
aResult
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
RegisterNotification
(
nsIObserver
*
aObserver
)
{
if
(
!
aObserver
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
os
-
>
AddObserver
(
aObserver
"
domwindowopened
"
false
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
os
-
>
AddObserver
(
aObserver
"
domwindowclosed
"
false
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
UnregisterNotification
(
nsIObserver
*
aObserver
)
{
if
(
!
aObserver
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
NS_ERROR_FAILURE
;
}
os
-
>
RemoveObserver
(
aObserver
"
domwindowopened
"
)
;
os
-
>
RemoveObserver
(
aObserver
"
domwindowclosed
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetWindowEnumerator
(
nsISimpleEnumerator
*
*
aResult
)
{
if
(
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
MutexAutoLock
lock
(
mListLock
)
;
RefPtr
<
nsWatcherWindowEnumerator
>
enumerator
=
new
nsWatcherWindowEnumerator
(
this
)
;
enumerator
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetNewPrompter
(
mozIDOMWindowProxy
*
aParent
nsIPrompt
*
*
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
factory
=
do_GetService
(
"
mozilla
.
org
/
prompter
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
factory
-
>
GetPrompt
(
aParent
NS_GET_IID
(
nsIPrompt
)
reinterpret_cast
<
void
*
*
>
(
aResult
)
)
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetNewAuthPrompter
(
mozIDOMWindowProxy
*
aParent
nsIAuthPrompt
*
*
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
factory
=
do_GetService
(
"
mozilla
.
org
/
prompter
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
factory
-
>
GetPrompt
(
aParent
NS_GET_IID
(
nsIAuthPrompt
)
reinterpret_cast
<
void
*
*
>
(
aResult
)
)
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetPrompt
(
mozIDOMWindowProxy
*
aParent
const
nsIID
&
aIID
void
*
*
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
factory
=
do_GetService
(
"
mozilla
.
org
/
prompter
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
factory
-
>
GetPrompt
(
aParent
aIID
aResult
)
;
if
(
rv
=
=
NS_NOINTERFACE
&
&
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPrompt2
)
)
)
{
nsCOMPtr
<
nsIAuthPrompt
>
oldPrompt
;
rv
=
factory
-
>
GetPrompt
(
aParent
NS_GET_IID
(
nsIAuthPrompt
)
getter_AddRefs
(
oldPrompt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_WrapAuthPrompt
(
oldPrompt
reinterpret_cast
<
nsIAuthPrompt2
*
*
>
(
aResult
)
)
;
if
(
!
*
aResult
)
{
rv
=
NS_ERROR_NOT_AVAILABLE
;
}
}
return
rv
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
SetWindowCreator
(
nsIWindowCreator
*
aCreator
)
{
mWindowCreator
=
aCreator
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
HasWindowCreator
(
bool
*
aResult
)
{
*
aResult
=
mWindowCreator
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetActiveWindow
(
mozIDOMWindowProxy
*
*
aActiveWindow
)
{
*
aActiveWindow
=
nullptr
;
nsCOMPtr
<
nsIFocusManager
>
fm
=
do_GetService
(
FOCUSMANAGER_CONTRACTID
)
;
if
(
fm
)
{
return
fm
-
>
GetActiveWindow
(
aActiveWindow
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
SetActiveWindow
(
mozIDOMWindowProxy
*
aActiveWindow
)
{
nsCOMPtr
<
nsIFocusManager
>
fm
=
do_GetService
(
FOCUSMANAGER_CONTRACTID
)
;
if
(
fm
)
{
return
fm
-
>
SetActiveWindow
(
aActiveWindow
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
AddWindow
(
mozIDOMWindowProxy
*
aWindow
nsIWebBrowserChrome
*
aChrome
)
{
if
(
!
aWindow
)
{
return
NS_ERROR_INVALID_ARG
;
}
{
nsWatcherWindowEntry
*
info
;
MutexAutoLock
lock
(
mListLock
)
;
info
=
FindWindowEntry
(
aWindow
)
;
if
(
info
)
{
nsCOMPtr
<
nsISupportsWeakReference
>
supportsweak
(
do_QueryInterface
(
aChrome
)
)
;
if
(
supportsweak
)
{
supportsweak
-
>
GetWeakReference
(
getter_AddRefs
(
info
-
>
mChromeWeak
)
)
;
}
else
{
info
-
>
mChrome
=
aChrome
;
info
-
>
mChromeWeak
=
nullptr
;
}
return
NS_OK
;
}
info
=
new
nsWatcherWindowEntry
(
aWindow
aChrome
)
;
if
(
!
info
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
mOldestWindow
)
{
info
-
>
InsertAfter
(
mOldestWindow
-
>
mOlder
)
;
}
else
{
mOldestWindow
=
info
;
}
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISupports
>
domwin
(
do_QueryInterface
(
aWindow
)
)
;
return
os
-
>
NotifyObservers
(
domwin
"
domwindowopened
"
0
)
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
RemoveWindow
(
mozIDOMWindowProxy
*
aWindow
)
{
if
(
!
aWindow
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsWatcherWindowEntry
*
info
=
FindWindowEntry
(
aWindow
)
;
if
(
info
)
{
RemoveWindow
(
info
)
;
return
NS_OK
;
}
NS_WARNING
(
"
requested
removal
of
nonexistent
window
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
nsWatcherWindowEntry
*
nsWindowWatcher
:
:
FindWindowEntry
(
mozIDOMWindowProxy
*
aWindow
)
{
nsWatcherWindowEntry
*
info
;
nsWatcherWindowEntry
*
listEnd
;
info
=
mOldestWindow
;
listEnd
=
0
;
while
(
info
!
=
listEnd
)
{
if
(
info
-
>
mWindow
=
=
aWindow
)
{
return
info
;
}
info
=
info
-
>
mYounger
;
listEnd
=
mOldestWindow
;
}
return
0
;
}
nsresult
nsWindowWatcher
:
:
RemoveWindow
(
nsWatcherWindowEntry
*
aInfo
)
{
uint32_t
count
=
mEnumeratorList
.
Length
(
)
;
{
MutexAutoLock
lock
(
mListLock
)
;
for
(
uint32_t
ctr
=
0
;
ctr
<
count
;
+
+
ctr
)
{
mEnumeratorList
[
ctr
]
-
>
WindowRemoved
(
aInfo
)
;
}
if
(
aInfo
=
=
mOldestWindow
)
{
mOldestWindow
=
aInfo
-
>
mYounger
=
=
mOldestWindow
?
0
:
aInfo
-
>
mYounger
;
}
aInfo
-
>
Unlink
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
nsCOMPtr
<
nsISupports
>
domwin
(
do_QueryInterface
(
aInfo
-
>
mWindow
)
)
;
os
-
>
NotifyObservers
(
domwin
"
domwindowclosed
"
0
)
;
}
delete
aInfo
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetChromeForWindow
(
mozIDOMWindowProxy
*
aWindow
nsIWebBrowserChrome
*
*
aResult
)
{
if
(
!
aWindow
|
|
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
0
;
MutexAutoLock
lock
(
mListLock
)
;
nsWatcherWindowEntry
*
info
=
FindWindowEntry
(
aWindow
)
;
if
(
info
)
{
if
(
info
-
>
mChromeWeak
)
{
return
info
-
>
mChromeWeak
-
>
QueryReferent
(
NS_GET_IID
(
nsIWebBrowserChrome
)
reinterpret_cast
<
void
*
*
>
(
aResult
)
)
;
}
*
aResult
=
info
-
>
mChrome
;
NS_IF_ADDREF
(
*
aResult
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetWindowByName
(
const
nsAString
&
aTargetName
mozIDOMWindowProxy
*
aCurrentWindow
mozIDOMWindowProxy
*
*
aResult
)
{
if
(
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
nullptr
;
nsPIDOMWindowOuter
*
currentWindow
=
aCurrentWindow
?
nsPIDOMWindowOuter
:
:
From
(
aCurrentWindow
)
:
nullptr
;
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
;
nsCOMPtr
<
nsIDocShellTreeItem
>
startItem
;
GetWindowTreeItem
(
currentWindow
getter_AddRefs
(
startItem
)
)
;
if
(
startItem
)
{
startItem
-
>
FindItemWithName
(
aTargetName
nullptr
nullptr
false
getter_AddRefs
(
treeItem
)
)
;
}
else
{
FindItemWithName
(
aTargetName
nullptr
nullptr
getter_AddRefs
(
treeItem
)
)
;
}
if
(
treeItem
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
treeItem
-
>
GetWindow
(
)
;
domWindow
.
forget
(
aResult
)
;
}
return
NS_OK
;
}
bool
nsWindowWatcher
:
:
AddEnumerator
(
nsWatcherWindowEnumerator
*
aEnumerator
)
{
return
mEnumeratorList
.
AppendElement
(
aEnumerator
)
!
=
nullptr
;
}
bool
nsWindowWatcher
:
:
RemoveEnumerator
(
nsWatcherWindowEnumerator
*
aEnumerator
)
{
return
mEnumeratorList
.
RemoveElement
(
aEnumerator
)
;
}
nsresult
nsWindowWatcher
:
:
URIfromURL
(
const
char
*
aURL
mozIDOMWindowProxy
*
aParent
nsIURI
*
*
aURI
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
baseWindow
=
do_QueryInterface
(
GetEntryGlobal
(
)
)
;
if
(
!
baseWindow
&
&
aParent
)
{
baseWindow
=
nsPIDOMWindowOuter
:
:
From
(
aParent
)
-
>
GetCurrentInnerWindow
(
)
;
}
nsIURI
*
baseURI
=
nullptr
;
if
(
baseWindow
)
{
if
(
Document
*
doc
=
baseWindow
-
>
GetDoc
(
)
)
{
baseURI
=
doc
-
>
GetDocBaseURI
(
)
;
}
}
return
NS_NewURI
(
aURI
aURL
baseURI
)
;
}
#
define
NS_CALCULATE_CHROME_FLAG_FOR
(
feature
flag
)
\
prefBranch
-
>
GetBoolPref
(
feature
&
forceEnable
)
;
\
if
(
forceEnable
&
&
!
aDialog
&
&
!
aHasChromeParent
&
&
!
aChromeURL
)
{
\
chromeFlags
|
=
flag
;
\
}
else
{
\
chromeFlags
|
=
\
WinHasOption
(
aFeatures
feature
0
&
presenceFlag
)
?
flag
:
0
;
\
}
uint32_t
nsWindowWatcher
:
:
CalculateChromeFlagsHelper
(
uint32_t
aInitialFlags
const
nsACString
&
aFeatures
bool
&
presenceFlag
bool
aDialog
bool
aHasChromeParent
bool
aChromeURL
)
{
uint32_t
chromeFlags
=
aInitialFlags
;
nsresult
rv
;
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
;
nsCOMPtr
<
nsIPrefService
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
nsIWebBrowserChrome
:
:
CHROME_DEFAULT
)
;
rv
=
prefs
-
>
GetBranch
(
"
dom
.
disable_window_open_feature
.
"
getter_AddRefs
(
prefBranch
)
)
;
NS_ENSURE_SUCCESS
(
rv
nsIWebBrowserChrome
:
:
CHROME_DEFAULT
)
;
bool
forceEnable
=
false
;
NS_CALCULATE_CHROME_FLAG_FOR
(
"
titlebar
"
nsIWebBrowserChrome
:
:
CHROME_TITLEBAR
)
;
NS_CALCULATE_CHROME_FLAG_FOR
(
"
close
"
nsIWebBrowserChrome
:
:
CHROME_WINDOW_CLOSE
)
;
NS_CALCULATE_CHROME_FLAG_FOR
(
"
toolbar
"
nsIWebBrowserChrome
:
:
CHROME_TOOLBAR
)
;
NS_CALCULATE_CHROME_FLAG_FOR
(
"
location
"
nsIWebBrowserChrome
:
:
CHROME_LOCATIONBAR
)
;
NS_CALCULATE_CHROME_FLAG_FOR
(
"
personalbar
"
nsIWebBrowserChrome
:
:
CHROME_PERSONAL_TOOLBAR
)
;
NS_CALCULATE_CHROME_FLAG_FOR
(
"
status
"
nsIWebBrowserChrome
:
:
CHROME_STATUSBAR
)
;
NS_CALCULATE_CHROME_FLAG_FOR
(
"
menubar
"
nsIWebBrowserChrome
:
:
CHROME_MENUBAR
)
;
NS_CALCULATE_CHROME_FLAG_FOR
(
"
resizable
"
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RESIZE
)
;
NS_CALCULATE_CHROME_FLAG_FOR
(
"
minimizable
"
nsIWebBrowserChrome
:
:
CHROME_WINDOW_MIN
)
;
bool
scrollbarsPresent
=
false
;
if
(
WinHasOption
(
aFeatures
"
scrollbars
"
1
&
scrollbarsPresent
)
|
|
!
scrollbarsPresent
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_SCROLLBARS
;
}
presenceFlag
=
presenceFlag
|
|
scrollbarsPresent
;
return
chromeFlags
;
}
uint32_t
nsWindowWatcher
:
:
EnsureFlagsSafeForContent
(
uint32_t
aChromeFlags
bool
aChromeURL
)
{
aChromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_TITLEBAR
;
aChromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_CLOSE
;
aChromeFlags
&
=
~
nsIWebBrowserChrome
:
:
CHROME_WINDOW_LOWERED
;
aChromeFlags
&
=
~
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RAISED
;
aChromeFlags
&
=
~
nsIWebBrowserChrome
:
:
CHROME_WINDOW_POPUP
;
if
(
!
aChromeURL
)
{
aChromeFlags
&
=
~
(
nsIWebBrowserChrome
:
:
CHROME_MODAL
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
)
;
}
if
(
!
(
aChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
)
)
{
aChromeFlags
&
=
~
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
;
}
return
aChromeFlags
;
}
uint32_t
nsWindowWatcher
:
:
CalculateChromeFlagsForChild
(
const
nsACString
&
aFeatures
)
{
if
(
aFeatures
.
IsVoid
(
)
)
{
return
nsIWebBrowserChrome
:
:
CHROME_ALL
;
}
bool
presenceFlag
=
false
;
uint32_t
chromeFlags
=
CalculateChromeFlagsHelper
(
nsIWebBrowserChrome
:
:
CHROME_WINDOW_BORDERS
aFeatures
presenceFlag
)
;
return
EnsureFlagsSafeForContent
(
chromeFlags
)
;
}
uint32_t
nsWindowWatcher
:
:
CalculateChromeFlagsForParent
(
mozIDOMWindowProxy
*
aParent
const
nsACString
&
aFeatures
bool
aDialog
bool
aChromeURL
bool
aHasChromeParent
bool
aCalledFromJS
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
)
;
uint32_t
chromeFlags
=
0
;
if
(
aFeatures
.
IsVoid
(
)
)
{
chromeFlags
=
nsIWebBrowserChrome
:
:
CHROME_ALL
;
if
(
aDialog
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
}
}
else
{
chromeFlags
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_BORDERS
;
}
bool
presenceFlag
=
false
;
if
(
aDialog
&
&
WinHasOption
(
aFeatures
"
all
"
0
&
presenceFlag
)
)
{
chromeFlags
=
nsIWebBrowserChrome
:
:
CHROME_ALL
;
}
chromeFlags
=
CalculateChromeFlagsHelper
(
chromeFlags
aFeatures
presenceFlag
aDialog
aHasChromeParent
aChromeURL
)
;
chromeFlags
|
=
WinHasOption
(
aFeatures
"
private
"
0
&
presenceFlag
)
?
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
:
0
;
chromeFlags
|
=
WinHasOption
(
aFeatures
"
non
-
private
"
0
&
presenceFlag
)
?
nsIWebBrowserChrome
:
:
CHROME_NON_PRIVATE_WINDOW
:
0
;
bool
remote
=
BrowserTabsRemoteAutostart
(
)
;
if
(
remote
)
{
remote
=
!
WinHasOption
(
aFeatures
"
non
-
remote
"
0
&
presenceFlag
)
;
}
else
{
remote
=
WinHasOption
(
aFeatures
"
remote
"
0
&
presenceFlag
)
;
}
if
(
remote
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
;
}
chromeFlags
|
=
WinHasOption
(
aFeatures
"
popup
"
0
&
presenceFlag
)
?
nsIWebBrowserChrome
:
:
CHROME_WINDOW_POPUP
:
0
;
if
(
!
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_WINDOW_POPUP
)
)
{
if
(
!
PL_strcasestr
(
aFeatures
.
BeginReading
(
)
"
titlebar
"
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_TITLEBAR
;
}
if
(
!
PL_strcasestr
(
aFeatures
.
BeginReading
(
)
"
close
"
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_CLOSE
;
}
}
if
(
aDialog
&
&
!
aFeatures
.
IsVoid
(
)
&
&
!
presenceFlag
)
{
chromeFlags
=
nsIWebBrowserChrome
:
:
CHROME_DEFAULT
;
}
if
(
WinHasOption
(
aFeatures
"
alwaysLowered
"
0
nullptr
)
|
|
WinHasOption
(
aFeatures
"
z
-
lock
"
0
nullptr
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_LOWERED
;
}
else
if
(
WinHasOption
(
aFeatures
"
alwaysRaised
"
0
nullptr
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RAISED
;
}
chromeFlags
|
=
WinHasOption
(
aFeatures
"
suppressanimation
"
0
nullptr
)
?
nsIWebBrowserChrome
:
:
CHROME_SUPPRESS_ANIMATION
:
0
;
chromeFlags
|
=
WinHasOption
(
aFeatures
"
alwaysontop
"
0
nullptr
)
?
nsIWebBrowserChrome
:
:
CHROME_ALWAYS_ON_TOP
:
0
;
chromeFlags
|
=
WinHasOption
(
aFeatures
"
chrome
"
0
nullptr
)
?
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
:
0
;
chromeFlags
|
=
WinHasOption
(
aFeatures
"
extrachrome
"
0
nullptr
)
?
nsIWebBrowserChrome
:
:
CHROME_EXTRA
:
0
;
chromeFlags
|
=
WinHasOption
(
aFeatures
"
centerscreen
"
0
nullptr
)
?
nsIWebBrowserChrome
:
:
CHROME_CENTER_SCREEN
:
0
;
chromeFlags
|
=
WinHasOption
(
aFeatures
"
dependent
"
0
nullptr
)
?
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
:
0
;
chromeFlags
|
=
WinHasOption
(
aFeatures
"
modal
"
0
nullptr
)
?
(
nsIWebBrowserChrome
:
:
CHROME_MODAL
|
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
)
:
0
;
bool
disableDialogFeature
=
false
;
nsCOMPtr
<
nsIPrefBranch
>
branch
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
branch
-
>
GetBoolPref
(
"
dom
.
disable_window_open_dialog_feature
"
&
disableDialogFeature
)
;
if
(
!
disableDialogFeature
)
{
chromeFlags
|
=
WinHasOption
(
aFeatures
"
dialog
"
0
nullptr
)
?
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
:
0
;
}
if
(
aDialog
)
{
if
(
!
PL_strcasestr
(
aFeatures
.
BeginReading
(
)
"
dialog
"
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
;
}
if
(
!
PL_strcasestr
(
aFeatures
.
BeginReading
(
)
"
chrome
"
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
}
}
if
(
!
aHasChromeParent
)
{
chromeFlags
=
EnsureFlagsSafeForContent
(
chromeFlags
aChromeURL
)
;
}
nsCOMPtr
<
nsIDocShell
>
docshell
=
do_GetInterface
(
aParent
)
;
if
(
docshell
&
&
docshell
-
>
GetIsInMozBrowser
(
)
)
{
chromeFlags
&
=
~
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
;
}
return
chromeFlags
;
}
int32_t
nsWindowWatcher
:
:
WinHasOption
(
const
nsACString
&
aOptions
const
char
*
aName
int32_t
aDefault
bool
*
aPresenceFlag
)
{
if
(
aOptions
.
IsEmpty
(
)
)
{
return
0
;
}
const
char
*
options
=
aOptions
.
BeginReading
(
)
;
char
*
comma
;
char
*
equal
;
int32_t
found
=
0
;
#
ifdef
DEBUG
NS_ASSERTION
(
nsAutoCString
(
aOptions
)
.
FindCharInSet
(
"
\
n
\
r
\
t
"
)
=
=
kNotFound
"
There
should
be
no
whitespace
in
this
string
!
"
)
;
#
endif
while
(
true
)
{
comma
=
PL_strchr
(
options
'
'
)
;
if
(
comma
)
{
*
comma
=
'
\
0
'
;
}
equal
=
PL_strchr
(
options
'
=
'
)
;
if
(
equal
)
{
*
equal
=
'
\
0
'
;
}
if
(
nsCRT
:
:
strcasecmp
(
options
aName
)
=
=
0
)
{
if
(
aPresenceFlag
)
{
*
aPresenceFlag
=
true
;
}
if
(
equal
)
if
(
*
(
equal
+
1
)
=
=
'
*
'
)
{
found
=
aDefault
;
}
else
if
(
nsCRT
:
:
strcasecmp
(
equal
+
1
"
yes
"
)
=
=
0
)
{
found
=
1
;
}
else
{
found
=
atoi
(
equal
+
1
)
;
}
else
{
found
=
1
;
}
}
if
(
equal
)
{
*
equal
=
'
=
'
;
}
if
(
comma
)
{
*
comma
=
'
'
;
}
if
(
found
|
|
!
comma
)
{
break
;
}
options
=
comma
+
1
;
}
return
found
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
FindItemWithName
(
const
nsAString
&
aName
nsIDocShellTreeItem
*
aRequestor
nsIDocShellTreeItem
*
aOriginalRequestor
nsIDocShellTreeItem
*
*
aFoundItem
)
{
*
aFoundItem
=
nullptr
;
if
(
aName
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
aName
.
LowerCaseEqualsLiteral
(
"
_blank
"
)
|
|
aName
.
LowerCaseEqualsLiteral
(
"
_top
"
)
|
|
aName
.
LowerCaseEqualsLiteral
(
"
_parent
"
)
|
|
aName
.
LowerCaseEqualsLiteral
(
"
_self
"
)
)
{
return
NS_OK
;
}
return
TabGroup
:
:
GetChromeTabGroup
(
)
-
>
FindItemWithName
(
aName
aRequestor
aOriginalRequestor
aFoundItem
)
;
}
already_AddRefed
<
nsIDocShellTreeItem
>
nsWindowWatcher
:
:
GetCallerTreeItem
(
nsIDocShellTreeItem
*
aParentItem
)
{
nsCOMPtr
<
nsIWebNavigation
>
callerWebNav
=
do_GetInterface
(
GetEntryGlobal
(
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
callerItem
=
do_QueryInterface
(
callerWebNav
)
;
if
(
!
callerItem
)
{
callerItem
=
aParentItem
;
}
return
callerItem
.
forget
(
)
;
}
nsPIDOMWindowOuter
*
nsWindowWatcher
:
:
SafeGetWindowByName
(
const
nsAString
&
aName
bool
aForceNoOpener
mozIDOMWindowProxy
*
aCurrentWindow
)
{
if
(
aForceNoOpener
)
{
if
(
!
aName
.
LowerCaseEqualsLiteral
(
"
_self
"
)
&
&
!
aName
.
LowerCaseEqualsLiteral
(
"
_top
"
)
&
&
!
aName
.
LowerCaseEqualsLiteral
(
"
_parent
"
)
)
{
return
nullptr
;
}
}
nsCOMPtr
<
nsIDocShellTreeItem
>
startItem
;
GetWindowTreeItem
(
aCurrentWindow
getter_AddRefs
(
startItem
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
callerItem
=
GetCallerTreeItem
(
startItem
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
foundItem
;
if
(
startItem
)
{
startItem
-
>
FindItemWithName
(
aName
nullptr
callerItem
false
getter_AddRefs
(
foundItem
)
)
;
}
else
{
FindItemWithName
(
aName
nullptr
callerItem
getter_AddRefs
(
foundItem
)
)
;
}
return
foundItem
?
foundItem
-
>
GetWindow
(
)
:
nullptr
;
}
nsresult
nsWindowWatcher
:
:
ReadyOpenedDocShellItem
(
nsIDocShellTreeItem
*
aOpenedItem
nsPIDOMWindowOuter
*
aParent
bool
aWindowIsNew
bool
aForceNoOpener
mozIDOMWindowProxy
*
*
aOpenedWindow
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
NS_ENSURE_ARG
(
aOpenedWindow
)
;
*
aOpenedWindow
=
0
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
piOpenedWindow
=
aOpenedItem
-
>
GetWindow
(
)
;
if
(
piOpenedWindow
)
{
if
(
!
aForceNoOpener
)
{
piOpenedWindow
-
>
SetOpenerWindow
(
aParent
aWindowIsNew
)
;
}
else
if
(
aParent
&
&
aParent
!
=
piOpenedWindow
)
{
MOZ_ASSERT
(
piOpenedWindow
-
>
TabGroup
(
)
!
=
aParent
-
>
TabGroup
(
)
"
If
we
'
re
forcing
no
opener
they
should
be
in
different
tab
groups
"
)
;
}
if
(
aWindowIsNew
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIDocumentLoader
>
docloader
=
do_QueryInterface
(
aOpenedItem
)
;
NS_ASSERTION
(
docloader
"
How
can
we
not
have
a
docloader
here
?
"
)
;
nsCOMPtr
<
nsIChannel
>
chan
;
docloader
-
>
GetDocumentChannel
(
getter_AddRefs
(
chan
)
)
;
NS_ASSERTION
(
!
chan
"
Why
is
there
a
document
channel
?
"
)
;
#
endif
RefPtr
<
Document
>
doc
=
piOpenedWindow
-
>
GetExtantDoc
(
)
;
if
(
doc
)
{
doc
-
>
SetIsInitialDocument
(
true
)
;
}
}
piOpenedWindow
.
forget
(
aOpenedWindow
)
;
rv
=
NS_OK
;
}
return
rv
;
}
void
nsWindowWatcher
:
:
CalcSizeSpec
(
const
nsACString
&
aFeatures
SizeSpec
&
aResult
)
{
bool
present
;
int32_t
temp
;
present
=
false
;
if
(
(
temp
=
WinHasOption
(
aFeatures
"
left
"
0
&
present
)
)
|
|
present
)
{
aResult
.
mLeft
=
temp
;
}
else
if
(
(
temp
=
WinHasOption
(
aFeatures
"
screenX
"
0
&
present
)
)
|
|
present
)
{
aResult
.
mLeft
=
temp
;
}
aResult
.
mLeftSpecified
=
present
;
present
=
false
;
if
(
(
temp
=
WinHasOption
(
aFeatures
"
top
"
0
&
present
)
)
|
|
present
)
{
aResult
.
mTop
=
temp
;
}
else
if
(
(
temp
=
WinHasOption
(
aFeatures
"
screenY
"
0
&
present
)
)
|
|
present
)
{
aResult
.
mTop
=
temp
;
}
aResult
.
mTopSpecified
=
present
;
if
(
(
temp
=
WinHasOption
(
aFeatures
"
outerWidth
"
INT32_MIN
nullptr
)
)
)
{
if
(
temp
=
=
INT32_MIN
)
{
aResult
.
mUseDefaultWidth
=
true
;
}
else
{
aResult
.
mOuterWidth
=
temp
;
}
aResult
.
mOuterWidthSpecified
=
true
;
}
else
if
(
(
temp
=
WinHasOption
(
aFeatures
"
width
"
INT32_MIN
nullptr
)
)
|
|
(
temp
=
WinHasOption
(
aFeatures
"
innerWidth
"
INT32_MIN
nullptr
)
)
)
{
if
(
temp
=
=
INT32_MIN
)
{
aResult
.
mUseDefaultWidth
=
true
;
}
else
{
aResult
.
mInnerWidth
=
temp
;
}
aResult
.
mInnerWidthSpecified
=
true
;
}
if
(
(
temp
=
WinHasOption
(
aFeatures
"
outerHeight
"
INT32_MIN
nullptr
)
)
)
{
if
(
temp
=
=
INT32_MIN
)
{
aResult
.
mUseDefaultHeight
=
true
;
}
else
{
aResult
.
mOuterHeight
=
temp
;
}
aResult
.
mOuterHeightSpecified
=
true
;
}
else
if
(
(
temp
=
WinHasOption
(
aFeatures
"
height
"
INT32_MIN
nullptr
)
)
|
|
(
temp
=
WinHasOption
(
aFeatures
"
innerHeight
"
INT32_MIN
nullptr
)
)
)
{
if
(
temp
=
=
INT32_MIN
)
{
aResult
.
mUseDefaultHeight
=
true
;
}
else
{
aResult
.
mInnerHeight
=
temp
;
}
aResult
.
mInnerHeightSpecified
=
true
;
}
}
void
nsWindowWatcher
:
:
SizeOpenedWindow
(
nsIDocShellTreeOwner
*
aTreeOwner
mozIDOMWindowProxy
*
aParent
bool
aIsCallerChrome
const
SizeSpec
&
aSizeSpec
const
Maybe
<
float
>
&
aOpenerFullZoom
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
int32_t
left
=
0
top
=
0
width
=
100
height
=
100
;
int32_t
chromeWidth
=
0
chromeHeight
=
0
;
bool
sizeChromeWidth
=
true
sizeChromeHeight
=
true
;
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
(
do_QueryInterface
(
aTreeOwner
)
)
;
if
(
!
treeOwnerAsWin
)
{
return
;
}
double
openerZoom
=
aOpenerFullZoom
.
valueOr
(
1
.
0
)
;
if
(
aParent
&
&
aOpenerFullZoom
.
isNothing
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
piWindow
=
nsPIDOMWindowOuter
:
:
From
(
aParent
)
;
if
(
Document
*
doc
=
piWindow
-
>
GetDoc
(
)
)
{
if
(
nsPresContext
*
presContext
=
doc
-
>
GetPresContext
(
)
)
{
openerZoom
=
presContext
-
>
GetFullZoom
(
)
;
}
}
}
double
scale
=
1
.
0
;
treeOwnerAsWin
-
>
GetUnscaledDevicePixelsPerCSSPixel
(
&
scale
)
;
treeOwnerAsWin
-
>
GetPositionAndSize
(
&
left
&
top
&
width
&
height
)
;
left
=
NSToIntRound
(
left
/
scale
)
;
top
=
NSToIntRound
(
top
/
scale
)
;
width
=
NSToIntRound
(
width
/
scale
)
;
height
=
NSToIntRound
(
height
/
scale
)
;
{
int32_t
contentWidth
contentHeight
;
bool
hasPrimaryContent
=
false
;
aTreeOwner
-
>
GetHasPrimaryContent
(
&
hasPrimaryContent
)
;
if
(
hasPrimaryContent
)
{
aTreeOwner
-
>
GetPrimaryContentSize
(
&
contentWidth
&
contentHeight
)
;
}
else
{
aTreeOwner
-
>
GetRootShellSize
(
&
contentWidth
&
contentHeight
)
;
}
chromeWidth
=
width
-
contentWidth
;
chromeHeight
=
height
-
contentHeight
;
}
if
(
aSizeSpec
.
mLeftSpecified
)
{
left
=
NSToIntRound
(
aSizeSpec
.
mLeft
*
openerZoom
)
;
}
if
(
aSizeSpec
.
mTopSpecified
)
{
top
=
NSToIntRound
(
aSizeSpec
.
mTop
*
openerZoom
)
;
}
if
(
aSizeSpec
.
mOuterWidthSpecified
)
{
if
(
!
aSizeSpec
.
mUseDefaultWidth
)
{
width
=
NSToIntRound
(
aSizeSpec
.
mOuterWidth
*
openerZoom
)
;
}
}
else
if
(
aSizeSpec
.
mInnerWidthSpecified
)
{
sizeChromeWidth
=
false
;
if
(
aSizeSpec
.
mUseDefaultWidth
)
{
width
=
width
-
chromeWidth
;
}
else
{
width
=
NSToIntRound
(
aSizeSpec
.
mInnerWidth
*
openerZoom
)
;
}
}
if
(
aSizeSpec
.
mOuterHeightSpecified
)
{
if
(
!
aSizeSpec
.
mUseDefaultHeight
)
{
height
=
NSToIntRound
(
aSizeSpec
.
mOuterHeight
*
openerZoom
)
;
}
}
else
if
(
aSizeSpec
.
mInnerHeightSpecified
)
{
sizeChromeHeight
=
false
;
if
(
aSizeSpec
.
mUseDefaultHeight
)
{
height
=
height
-
chromeHeight
;
}
else
{
height
=
NSToIntRound
(
aSizeSpec
.
mInnerHeight
*
openerZoom
)
;
}
}
bool
positionSpecified
=
aSizeSpec
.
PositionSpecified
(
)
;
bool
enabled
=
false
;
if
(
aIsCallerChrome
)
{
nsCOMPtr
<
nsIDOMChromeWindow
>
chromeWin
(
do_QueryInterface
(
aParent
)
)
;
enabled
=
!
aParent
|
|
chromeWin
;
}
if
(
!
enabled
)
{
int32_t
oldTop
=
top
oldLeft
=
left
;
nsCOMPtr
<
nsIScreen
>
screen
;
nsCOMPtr
<
nsIScreenManager
>
screenMgr
(
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
)
;
if
(
screenMgr
)
screenMgr
-
>
ScreenForRect
(
left
top
width
height
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
int32_t
screenLeft
screenTop
screenWidth
screenHeight
;
int32_t
winWidth
=
width
+
(
sizeChromeWidth
?
0
:
chromeWidth
)
winHeight
=
height
+
(
sizeChromeHeight
?
0
:
chromeHeight
)
;
screen
-
>
GetAvailRect
(
&
screenLeft
&
screenTop
&
screenWidth
&
screenHeight
)
;
screenLeft
=
NSToIntRound
(
screenLeft
/
scale
)
;
screenTop
=
NSToIntRound
(
screenTop
/
scale
)
;
screenWidth
=
NSToIntRound
(
screenWidth
/
scale
)
;
screenHeight
=
NSToIntRound
(
screenHeight
/
scale
)
;
if
(
aSizeSpec
.
SizeSpecified
(
)
)
{
if
(
!
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
)
{
if
(
height
<
100
)
{
height
=
100
;
winHeight
=
height
+
(
sizeChromeHeight
?
0
:
chromeHeight
)
;
}
if
(
winHeight
>
screenHeight
)
{
height
=
screenHeight
-
(
sizeChromeHeight
?
0
:
chromeHeight
)
;
}
if
(
width
<
100
)
{
width
=
100
;
winWidth
=
width
+
(
sizeChromeWidth
?
0
:
chromeWidth
)
;
}
if
(
winWidth
>
screenWidth
)
{
width
=
screenWidth
-
(
sizeChromeWidth
?
0
:
chromeWidth
)
;
}
}
else
{
int32_t
targetContentWidth
=
0
;
int32_t
targetContentHeight
=
0
;
nsContentUtils
:
:
CalcRoundedWindowSizeForResistingFingerprinting
(
chromeWidth
chromeHeight
screenWidth
screenHeight
width
height
sizeChromeWidth
sizeChromeHeight
&
targetContentWidth
&
targetContentHeight
)
;
if
(
aSizeSpec
.
mInnerWidthSpecified
|
|
aSizeSpec
.
mOuterWidthSpecified
)
{
width
=
targetContentWidth
;
winWidth
=
width
+
(
sizeChromeWidth
?
0
:
chromeWidth
)
;
}
if
(
aSizeSpec
.
mInnerHeightSpecified
|
|
aSizeSpec
.
mOuterHeightSpecified
)
{
height
=
targetContentHeight
;
winHeight
=
height
+
(
sizeChromeHeight
?
0
:
chromeHeight
)
;
}
}
}
CheckedInt
<
decltype
(
left
)
>
leftPlusWinWidth
=
left
;
leftPlusWinWidth
+
=
winWidth
;
if
(
!
leftPlusWinWidth
.
isValid
(
)
|
|
leftPlusWinWidth
.
value
(
)
>
screenLeft
+
screenWidth
)
{
left
=
screenLeft
+
screenWidth
-
winWidth
;
}
if
(
left
<
screenLeft
)
{
left
=
screenLeft
;
}
CheckedInt
<
decltype
(
top
)
>
topPlusWinHeight
=
top
;
topPlusWinHeight
+
=
winHeight
;
if
(
!
topPlusWinHeight
.
isValid
(
)
|
|
topPlusWinHeight
.
value
(
)
>
screenTop
+
screenHeight
)
{
top
=
screenTop
+
screenHeight
-
winHeight
;
}
if
(
top
<
screenTop
)
{
top
=
screenTop
;
}
if
(
top
!
=
oldTop
|
|
left
!
=
oldLeft
)
{
positionSpecified
=
true
;
}
}
}
if
(
positionSpecified
)
{
nsCOMPtr
<
nsIScreen
>
screen
;
nsCOMPtr
<
nsIScreenManager
>
screenMgr
(
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
)
;
if
(
screenMgr
)
{
screenMgr
-
>
ScreenForRect
(
left
top
1
1
getter_AddRefs
(
screen
)
)
;
}
if
(
screen
)
{
double
cssToDevPixScale
desktopToDevPixScale
;
screen
-
>
GetDefaultCSSScaleFactor
(
&
cssToDevPixScale
)
;
screen
-
>
GetContentsScaleFactor
(
&
desktopToDevPixScale
)
;
double
cssToDesktopScale
=
cssToDevPixScale
/
desktopToDevPixScale
;
int32_t
screenLeft
screenTop
screenWd
screenHt
;
screen
-
>
GetRectDisplayPix
(
&
screenLeft
&
screenTop
&
screenWd
&
screenHt
)
;
treeOwnerAsWin
-
>
SetPositionDesktopPix
(
(
left
-
screenLeft
)
*
cssToDesktopScale
+
screenLeft
(
top
-
screenTop
)
*
cssToDesktopScale
+
screenTop
)
;
}
else
{
treeOwnerAsWin
-
>
SetPosition
(
left
*
scale
top
*
scale
)
;
}
treeOwnerAsWin
-
>
GetUnscaledDevicePixelsPerCSSPixel
(
&
scale
)
;
}
if
(
aSizeSpec
.
SizeSpecified
(
)
)
{
if
(
!
sizeChromeWidth
&
&
!
sizeChromeHeight
)
{
bool
hasPrimaryContent
=
false
;
aTreeOwner
-
>
GetHasPrimaryContent
(
&
hasPrimaryContent
)
;
if
(
hasPrimaryContent
)
{
aTreeOwner
-
>
SetPrimaryContentSize
(
width
*
scale
height
*
scale
)
;
}
else
{
aTreeOwner
-
>
SetRootShellSize
(
width
*
scale
height
*
scale
)
;
}
}
else
{
if
(
!
sizeChromeWidth
)
{
width
+
=
chromeWidth
;
}
if
(
!
sizeChromeHeight
)
{
height
+
=
chromeHeight
;
}
treeOwnerAsWin
-
>
SetSize
(
width
*
scale
height
*
scale
false
)
;
}
}
treeOwnerAsWin
-
>
SetVisibility
(
true
)
;
}
void
nsWindowWatcher
:
:
GetWindowTreeItem
(
mozIDOMWindowProxy
*
aWindow
nsIDocShellTreeItem
*
*
aResult
)
{
*
aResult
=
0
;
if
(
aWindow
)
{
nsCOMPtr
<
nsIDocShell
>
docshell
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
-
>
GetDocShell
(
)
;
docshell
.
forget
(
aResult
)
;
}
}
void
nsWindowWatcher
:
:
GetWindowTreeOwner
(
nsPIDOMWindowOuter
*
aWindow
nsIDocShellTreeOwner
*
*
aResult
)
{
*
aResult
=
0
;
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
;
GetWindowTreeItem
(
aWindow
getter_AddRefs
(
treeItem
)
)
;
if
(
treeItem
)
{
treeItem
-
>
GetTreeOwner
(
aResult
)
;
}
}
int32_t
nsWindowWatcher
:
:
GetWindowOpenLocation
(
nsPIDOMWindowOuter
*
aParent
uint32_t
aChromeFlags
bool
aCalledFromJS
bool
aPositionSpecified
bool
aSizeSpecified
)
{
bool
isFullScreen
=
aParent
-
>
GetFullScreen
(
)
;
int32_t
containerPref
;
if
(
NS_FAILED
(
Preferences
:
:
GetInt
(
"
browser
.
link
.
open_newwindow
"
&
containerPref
)
)
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_NEWTAB
;
}
bool
isDisabledOpenNewWindow
=
isFullScreen
&
&
Preferences
:
:
GetBool
(
"
browser
.
link
.
open_newwindow
.
disabled_in_fullscreen
"
)
;
if
(
isDisabledOpenNewWindow
&
&
(
containerPref
=
=
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
)
)
{
containerPref
=
nsIBrowserDOMWindow
:
:
OPEN_NEWTAB
;
}
if
(
containerPref
!
=
nsIBrowserDOMWindow
:
:
OPEN_NEWTAB
&
&
containerPref
!
=
nsIBrowserDOMWindow
:
:
OPEN_CURRENTWINDOW
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
;
}
if
(
aCalledFromJS
)
{
int32_t
restrictionPref
=
Preferences
:
:
GetInt
(
"
browser
.
link
.
open_newwindow
.
restriction
"
2
)
;
if
(
restrictionPref
<
0
|
|
restrictionPref
>
2
)
{
restrictionPref
=
2
;
}
if
(
isDisabledOpenNewWindow
)
{
restrictionPref
=
0
;
}
if
(
restrictionPref
=
=
1
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
;
}
if
(
restrictionPref
=
=
2
)
{
int32_t
uiChromeFlags
=
aChromeFlags
;
uiChromeFlags
&
=
~
(
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_NON_PRIVATE_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_LIFETIME
)
;
if
(
uiChromeFlags
!
=
nsIWebBrowserChrome
:
:
CHROME_ALL
|
|
aPositionSpecified
|
|
aSizeSpecified
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
;
}
}
}
return
containerPref
;
}
