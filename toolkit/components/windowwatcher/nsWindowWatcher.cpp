#
include
"
nsWindowWatcher
.
h
"
#
include
"
nsAutoWindowStateHelper
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIAuthPrompt
.
h
"
#
include
"
nsIAuthPrompt2
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsHashPropertyBag
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIBrowserDOMWindow
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContextGroup
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIScreen
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIWebBrowser
.
h
"
#
include
"
nsIWebBrowserChrome
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIWindowCreator
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIWindowProvider
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsIDOMStorageManager
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsOpenWindowInfo
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsSimpleEnumerator
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
StaticPrefs_full_screen_api
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Storage
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
BrowserHost
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
SessionStorageManager
.
h
"
#
include
"
nsIAppWindow
.
h
"
#
include
"
nsIXULBrowserWindow
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
ReferrerInfo
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
class
nsWindowWatcher
;
struct
nsWatcherWindowEntry
{
nsWatcherWindowEntry
(
mozIDOMWindowProxy
*
aWindow
nsIWebBrowserChrome
*
aChrome
)
:
mChrome
(
nullptr
)
{
mWindow
=
aWindow
;
nsCOMPtr
<
nsISupportsWeakReference
>
supportsweak
(
do_QueryInterface
(
aChrome
)
)
;
if
(
supportsweak
)
{
supportsweak
-
>
GetWeakReference
(
getter_AddRefs
(
mChromeWeak
)
)
;
}
else
{
mChrome
=
aChrome
;
mChromeWeak
=
nullptr
;
}
ReferenceSelf
(
)
;
}
~
nsWatcherWindowEntry
(
)
=
default
;
void
InsertAfter
(
nsWatcherWindowEntry
*
aOlder
)
;
void
Unlink
(
)
;
void
ReferenceSelf
(
)
;
mozIDOMWindowProxy
*
mWindow
;
nsIWebBrowserChrome
*
mChrome
;
nsWeakPtr
mChromeWeak
;
nsWatcherWindowEntry
*
mYounger
;
nsWatcherWindowEntry
*
mOlder
;
}
;
void
nsWatcherWindowEntry
:
:
InsertAfter
(
nsWatcherWindowEntry
*
aOlder
)
{
if
(
aOlder
)
{
mOlder
=
aOlder
;
mYounger
=
aOlder
-
>
mYounger
;
mOlder
-
>
mYounger
=
this
;
if
(
mOlder
-
>
mOlder
=
=
mOlder
)
{
mOlder
-
>
mOlder
=
this
;
}
mYounger
-
>
mOlder
=
this
;
if
(
mYounger
-
>
mYounger
=
=
mYounger
)
{
mYounger
-
>
mYounger
=
this
;
}
}
}
void
nsWatcherWindowEntry
:
:
Unlink
(
)
{
mOlder
-
>
mYounger
=
mYounger
;
mYounger
-
>
mOlder
=
mOlder
;
ReferenceSelf
(
)
;
}
void
nsWatcherWindowEntry
:
:
ReferenceSelf
(
)
{
mYounger
=
this
;
mOlder
=
this
;
}
class
nsWatcherWindowEnumerator
:
public
nsSimpleEnumerator
{
public
:
explicit
nsWatcherWindowEnumerator
(
nsWindowWatcher
*
aWatcher
)
;
NS_IMETHOD
HasMoreElements
(
bool
*
aResult
)
override
;
NS_IMETHOD
GetNext
(
nsISupports
*
*
aResult
)
override
;
protected
:
~
nsWatcherWindowEnumerator
(
)
override
;
private
:
friend
class
nsWindowWatcher
;
nsWatcherWindowEntry
*
FindNext
(
)
;
void
WindowRemoved
(
nsWatcherWindowEntry
*
aInfo
)
;
nsWindowWatcher
*
mWindowWatcher
;
nsWatcherWindowEntry
*
mCurrentPosition
;
}
;
nsWatcherWindowEnumerator
:
:
nsWatcherWindowEnumerator
(
nsWindowWatcher
*
aWatcher
)
:
mWindowWatcher
(
aWatcher
)
mCurrentPosition
(
aWatcher
-
>
mOldestWindow
)
{
mWindowWatcher
-
>
AddEnumerator
(
this
)
;
mWindowWatcher
-
>
AddRef
(
)
;
}
nsWatcherWindowEnumerator
:
:
~
nsWatcherWindowEnumerator
(
)
{
mWindowWatcher
-
>
RemoveEnumerator
(
this
)
;
mWindowWatcher
-
>
Release
(
)
;
}
NS_IMETHODIMP
nsWatcherWindowEnumerator
:
:
HasMoreElements
(
bool
*
aResult
)
{
if
(
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
!
!
mCurrentPosition
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWatcherWindowEnumerator
:
:
GetNext
(
nsISupports
*
*
aResult
)
{
if
(
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
nullptr
;
if
(
mCurrentPosition
)
{
CallQueryInterface
(
mCurrentPosition
-
>
mWindow
aResult
)
;
mCurrentPosition
=
FindNext
(
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
nsWatcherWindowEntry
*
nsWatcherWindowEnumerator
:
:
FindNext
(
)
{
nsWatcherWindowEntry
*
info
;
if
(
!
mCurrentPosition
)
{
return
0
;
}
info
=
mCurrentPosition
-
>
mYounger
;
return
info
=
=
mWindowWatcher
-
>
mOldestWindow
?
0
:
info
;
}
void
nsWatcherWindowEnumerator
:
:
WindowRemoved
(
nsWatcherWindowEntry
*
aInfo
)
{
if
(
mCurrentPosition
=
=
aInfo
)
{
mCurrentPosition
=
mCurrentPosition
!
=
aInfo
-
>
mYounger
?
aInfo
-
>
mYounger
:
0
;
}
}
NS_IMPL_ADDREF
(
nsWindowWatcher
)
NS_IMPL_RELEASE
(
nsWindowWatcher
)
NS_IMPL_QUERY_INTERFACE
(
nsWindowWatcher
nsIWindowWatcher
nsIPromptFactory
nsPIWindowWatcher
)
nsWindowWatcher
:
:
nsWindowWatcher
(
)
:
mEnumeratorList
(
)
mOldestWindow
(
0
)
mListLock
(
"
nsWindowWatcher
.
mListLock
"
)
{
}
nsWindowWatcher
:
:
~
nsWindowWatcher
(
)
{
while
(
mOldestWindow
)
{
RemoveWindow
(
mOldestWindow
)
;
}
}
nsresult
nsWindowWatcher
:
:
Init
(
)
{
return
NS_OK
;
}
static
already_AddRefed
<
nsIArray
>
ConvertArgsToArray
(
nsISupports
*
aArguments
)
{
if
(
!
aArguments
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIArray
>
array
=
do_QueryInterface
(
aArguments
)
;
if
(
array
)
{
uint32_t
argc
=
0
;
array
-
>
GetLength
(
&
argc
)
;
if
(
argc
=
=
0
)
{
return
nullptr
;
}
return
array
.
forget
(
)
;
}
nsCOMPtr
<
nsIMutableArray
>
singletonArray
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
)
;
NS_ENSURE_TRUE
(
singletonArray
nullptr
)
;
nsresult
rv
=
singletonArray
-
>
AppendElement
(
aArguments
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
singletonArray
.
forget
(
)
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
OpenWindow
(
mozIDOMWindowProxy
*
aParent
const
nsACString
&
aUrl
const
nsACString
&
aName
const
nsACString
&
aFeatures
nsISupports
*
aArguments
mozIDOMWindowProxy
*
*
aResult
)
{
nsCOMPtr
<
nsIArray
>
argv
=
ConvertArgsToArray
(
aArguments
)
;
uint32_t
argc
=
0
;
if
(
argv
)
{
argv
-
>
GetLength
(
&
argc
)
;
}
bool
dialog
=
(
argc
!
=
0
)
;
RefPtr
<
BrowsingContext
>
bc
;
MOZ_TRY
(
OpenWindowInternal
(
aParent
aUrl
aName
aFeatures
false
dialog
true
argv
false
false
false
PRINT_NONE
nullptr
getter_AddRefs
(
bc
)
)
)
;
if
(
bc
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
win
(
bc
-
>
GetDOMWindow
(
)
)
;
win
.
forget
(
aResult
)
;
}
return
NS_OK
;
}
struct
SizeSpec
{
SizeSpec
(
)
:
mLeft
(
0
)
mTop
(
0
)
mOuterWidth
(
0
)
mOuterHeight
(
0
)
mInnerWidth
(
0
)
mInnerHeight
(
0
)
mLeftSpecified
(
false
)
mTopSpecified
(
false
)
mOuterWidthSpecified
(
false
)
mOuterHeightSpecified
(
false
)
mInnerWidthSpecified
(
false
)
mInnerHeightSpecified
(
false
)
mLockAspectRatio
(
false
)
{
}
int32_t
mLeft
;
int32_t
mTop
;
int32_t
mOuterWidth
;
int32_t
mOuterHeight
;
int32_t
mInnerWidth
;
int32_t
mInnerHeight
;
bool
mLeftSpecified
;
bool
mTopSpecified
;
bool
mOuterWidthSpecified
;
bool
mOuterHeightSpecified
;
bool
mInnerWidthSpecified
;
bool
mInnerHeightSpecified
;
bool
mLockAspectRatio
;
bool
PositionSpecified
(
)
const
{
return
mLeftSpecified
|
|
mTopSpecified
;
}
bool
SizeSpecified
(
)
const
{
return
WidthSpecified
(
)
|
|
HeightSpecified
(
)
;
}
bool
WidthSpecified
(
)
const
{
return
mOuterWidthSpecified
|
|
mInnerWidthSpecified
;
}
bool
HeightSpecified
(
)
const
{
return
mOuterHeightSpecified
|
|
mInnerHeightSpecified
;
}
}
;
NS_IMETHODIMP
nsWindowWatcher
:
:
OpenWindow2
(
mozIDOMWindowProxy
*
aParent
const
nsACString
&
aUrl
const
nsACString
&
aName
const
nsACString
&
aFeatures
bool
aCalledFromScript
bool
aDialog
bool
aNavigate
nsISupports
*
aArguments
bool
aIsPopupSpam
bool
aForceNoOpener
bool
aForceNoReferrer
PrintKind
aPrintKind
nsDocShellLoadState
*
aLoadState
BrowsingContext
*
*
aResult
)
{
nsCOMPtr
<
nsIArray
>
argv
=
ConvertArgsToArray
(
aArguments
)
;
uint32_t
argc
=
0
;
if
(
argv
)
{
argv
-
>
GetLength
(
&
argc
)
;
}
bool
dialog
=
aDialog
;
if
(
!
aCalledFromScript
)
{
dialog
=
argc
>
0
;
}
return
OpenWindowInternal
(
aParent
aUrl
aName
aFeatures
aCalledFromScript
dialog
aNavigate
argv
aIsPopupSpam
aForceNoOpener
aForceNoReferrer
aPrintKind
aLoadState
aResult
)
;
}
static
bool
CheckUserContextCompatibility
(
nsIDocShell
*
aDocShell
)
{
MOZ_ASSERT
(
aDocShell
)
;
uint32_t
userContextId
=
static_cast
<
nsDocShell
*
>
(
aDocShell
)
-
>
GetOriginAttributes
(
)
.
mUserContextId
;
nsCOMPtr
<
nsIPrincipal
>
subjectPrincipal
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
?
nsContentUtils
:
:
SubjectPrincipal
(
)
:
nullptr
;
if
(
!
subjectPrincipal
)
{
return
true
;
}
if
(
subjectPrincipal
-
>
IsSystemPrincipal
(
)
)
{
return
true
;
}
return
subjectPrincipal
-
>
GetUserContextId
(
)
=
=
userContextId
;
}
nsresult
nsWindowWatcher
:
:
CreateChromeWindow
(
nsIWebBrowserChrome
*
aParentChrome
uint32_t
aChromeFlags
nsIOpenWindowInfo
*
aOpenWindowInfo
nsIWebBrowserChrome
*
*
aResult
)
{
if
(
NS_WARN_IF
(
!
mWindowCreator
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
bool
cancel
=
false
;
nsCOMPtr
<
nsIWebBrowserChrome
>
newWindowChrome
;
nsresult
rv
=
mWindowCreator
-
>
CreateChromeWindow
(
aParentChrome
aChromeFlags
aOpenWindowInfo
&
cancel
getter_AddRefs
(
newWindowChrome
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
cancel
)
{
newWindowChrome
=
nullptr
;
return
NS_ERROR_ABORT
;
}
newWindowChrome
.
forget
(
aResult
)
;
return
NS_OK
;
}
void
nsWindowWatcher
:
:
MaybeDisablePersistence
(
const
SizeSpec
&
sizeSpec
nsIDocShellTreeOwner
*
aTreeOwner
)
{
if
(
!
aTreeOwner
)
{
return
;
}
if
(
sizeSpec
.
SizeSpecified
(
)
)
{
aTreeOwner
-
>
SetPersistence
(
false
false
false
)
;
}
}
NS_IMETHODIMP
nsWindowWatcher
:
:
OpenWindowWithRemoteTab
(
nsIRemoteTab
*
aRemoteTab
const
nsACString
&
aFeatures
bool
aCalledFromJS
float
aOpenerFullZoom
nsIOpenWindowInfo
*
aOpenWindowInfo
nsIRemoteTab
*
*
aResult
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
mWindowCreator
)
;
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsContentUtils
:
:
WarnScriptWasIgnored
(
nullptr
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
mWindowCreator
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
bool
isFissionWindow
=
FissionAutostart
(
)
;
bool
isPrivateBrowsingWindow
=
Preferences
:
:
GetBool
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parentWindowOuter
;
RefPtr
<
BrowsingContext
>
parentBC
=
aOpenWindowInfo
-
>
GetParent
(
)
;
if
(
parentBC
)
{
RefPtr
<
Element
>
browserElement
=
parentBC
-
>
Top
(
)
-
>
GetEmbedderElement
(
)
;
if
(
browserElement
&
&
browserElement
-
>
GetOwnerGlobal
(
)
&
&
browserElement
-
>
GetOwnerGlobal
(
)
-
>
AsInnerWindow
(
)
)
{
parentWindowOuter
=
browserElement
-
>
GetOwnerGlobal
(
)
-
>
AsInnerWindow
(
)
-
>
GetOuterWindow
(
)
;
}
isFissionWindow
=
parentBC
-
>
UseRemoteSubframes
(
)
;
isPrivateBrowsingWindow
=
isPrivateBrowsingWindow
|
|
parentBC
-
>
UsePrivateBrowsing
(
)
;
}
if
(
!
parentWindowOuter
)
{
parentWindowOuter
=
nsContentUtils
:
:
GetMostRecentNonPBWindow
(
)
;
}
if
(
NS_WARN_IF
(
!
parentWindowOuter
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
parentTreeOwner
=
parentWindowOuter
-
>
GetTreeOwner
(
)
;
if
(
NS_WARN_IF
(
!
parentTreeOwner
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
NS_WARN_IF
(
!
mWindowCreator
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
WindowFeatures
features
;
features
.
Tokenize
(
aFeatures
)
;
SizeSpec
sizeSpec
;
CalcSizeSpec
(
features
false
sizeSpec
)
;
uint32_t
chromeFlags
=
CalculateChromeFlagsForContent
(
features
sizeSpec
)
;
if
(
isPrivateBrowsingWindow
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
;
}
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
;
if
(
isFissionWindow
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
;
}
nsCOMPtr
<
nsIWebBrowserChrome
>
parentChrome
(
do_GetInterface
(
parentTreeOwner
)
)
;
nsCOMPtr
<
nsIWebBrowserChrome
>
newWindowChrome
;
CreateChromeWindow
(
parentChrome
chromeFlags
aOpenWindowInfo
getter_AddRefs
(
newWindowChrome
)
)
;
if
(
NS_WARN_IF
(
!
newWindowChrome
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
chromeTreeItem
=
do_GetInterface
(
newWindowChrome
)
;
if
(
NS_WARN_IF
(
!
chromeTreeItem
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
chromeTreeOwner
;
chromeTreeItem
-
>
GetTreeOwner
(
getter_AddRefs
(
chromeTreeOwner
)
)
;
if
(
NS_WARN_IF
(
!
chromeTreeOwner
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsILoadContext
>
chromeContext
=
do_QueryInterface
(
chromeTreeItem
)
;
if
(
NS_WARN_IF
(
!
chromeContext
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
chromeContext
-
>
UsePrivateBrowsing
(
)
=
=
isPrivateBrowsingWindow
)
;
MOZ_ASSERT
(
chromeContext
-
>
UseRemoteSubframes
(
)
=
=
isFissionWindow
)
;
MOZ_ASSERT
(
chromeContext
-
>
UseRemoteTabs
(
)
)
;
MaybeDisablePersistence
(
sizeSpec
chromeTreeOwner
)
;
SizeOpenedWindow
(
chromeTreeOwner
parentWindowOuter
false
sizeSpec
Some
(
aOpenerFullZoom
)
)
;
nsCOMPtr
<
nsIRemoteTab
>
newBrowserParent
;
chromeTreeOwner
-
>
GetPrimaryRemoteTab
(
getter_AddRefs
(
newBrowserParent
)
)
;
if
(
NS_WARN_IF
(
!
newBrowserParent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
newBrowserParent
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
nsWindowWatcher
:
:
OpenWindowInternal
(
mozIDOMWindowProxy
*
aParent
const
nsACString
&
aUrl
const
nsACString
&
aName
const
nsACString
&
aFeatures
bool
aCalledFromJS
bool
aDialog
bool
aNavigate
nsIArray
*
aArgv
bool
aIsPopupSpam
bool
aForceNoOpener
bool
aForceNoReferrer
PrintKind
aPrintKind
nsDocShellLoadState
*
aLoadState
BrowsingContext
*
*
aResult
)
{
MOZ_ASSERT_IF
(
aForceNoReferrer
aForceNoOpener
)
;
nsresult
rv
=
NS_OK
;
bool
isNewToplevelWindow
=
false
;
bool
windowIsNew
=
false
;
bool
windowNeedsName
=
false
;
bool
windowIsModal
=
false
;
bool
uriToLoadIsChrome
=
false
;
uint32_t
chromeFlags
;
nsAutoString
name
;
nsCOMPtr
<
nsIURI
>
uriToLoad
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
parentTreeOwner
;
RefPtr
<
BrowsingContext
>
newBC
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parentWindow
=
aParent
?
nsPIDOMWindowOuter
:
:
From
(
aParent
)
:
nullptr
;
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
0
;
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsContentUtils
:
:
WarnScriptWasIgnored
(
nullptr
)
;
return
NS_ERROR_FAILURE
;
}
if
(
parentWindow
)
{
parentTreeOwner
=
parentWindow
-
>
GetTreeOwner
(
)
;
}
if
(
!
aUrl
.
IsVoid
(
)
)
{
rv
=
URIfromURL
(
aUrl
aParent
getter_AddRefs
(
uriToLoad
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uriToLoadIsChrome
=
uriToLoad
-
>
SchemeIs
(
"
chrome
"
)
;
}
bool
nameSpecified
=
false
;
if
(
!
aName
.
IsEmpty
(
)
)
{
CopyUTF8toUTF16
(
aName
name
)
;
nameSpecified
=
true
;
}
else
{
name
.
SetIsVoid
(
true
)
;
}
WindowFeatures
features
;
nsAutoCString
featuresStr
;
if
(
!
aFeatures
.
IsEmpty
(
)
)
{
featuresStr
.
Assign
(
aFeatures
)
;
features
.
Tokenize
(
featuresStr
)
;
}
else
{
featuresStr
.
SetIsVoid
(
true
)
;
}
RefPtr
<
BrowsingContext
>
parentBC
(
parentWindow
?
parentWindow
-
>
GetBrowsingContext
(
)
:
nullptr
)
;
nsCOMPtr
<
nsIDocShell
>
parentDocShell
(
parentBC
?
parentBC
-
>
GetDocShell
(
)
:
nullptr
)
;
if
(
parentBC
&
&
parentBC
-
>
IsDiscarded
(
)
)
{
return
NS_ERROR_ABORT
;
}
newBC
=
GetBrowsingContextByName
(
name
aForceNoOpener
parentBC
)
;
if
(
parentBC
&
&
parentBC
-
>
IsSandboxedFrom
(
newBC
)
)
{
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
if
(
newBC
&
&
NS_WARN_IF
(
newBC
-
>
GetPendingInitialization
(
)
)
)
{
return
NS_ERROR_ABORT
;
}
bool
hasChromeParent
=
XRE_IsContentProcess
(
)
?
false
:
true
;
if
(
aParent
)
{
Document
*
doc
=
parentWindow
-
>
GetDoc
(
)
;
hasChromeParent
=
doc
&
&
nsContentUtils
:
:
IsChromeDoc
(
doc
)
;
}
bool
isCallerChrome
=
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
;
SizeSpec
sizeSpec
;
CalcSizeSpec
(
features
hasChromeParent
sizeSpec
)
;
if
(
isCallerChrome
&
&
XRE_IsParentProcess
(
)
)
{
chromeFlags
=
CalculateChromeFlagsForSystem
(
features
sizeSpec
aDialog
uriToLoadIsChrome
hasChromeParent
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
parentBC
&
&
parentBC
-
>
IsContent
(
)
"
content
caller
must
provide
content
parent
"
)
;
chromeFlags
=
CalculateChromeFlagsForContent
(
features
sizeSpec
)
;
if
(
aDialog
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
;
}
}
bool
windowTypeIsChrome
=
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
if
(
parentBC
&
&
!
aForceNoOpener
)
{
if
(
parentBC
-
>
IsChrome
(
)
&
&
!
windowTypeIsChrome
)
{
NS_WARNING
(
"
Content
windows
may
never
have
chrome
windows
as
their
openers
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
parentBC
-
>
IsContent
(
)
&
&
windowTypeIsChrome
)
{
NS_WARNING
(
"
Chrome
windows
may
never
have
content
windows
as
their
openers
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
if
(
parentBC
&
&
parentBC
-
>
IsContent
(
)
&
&
!
windowTypeIsChrome
)
{
chromeFlags
&
=
~
(
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
)
;
if
(
parentBC
-
>
UseRemoteTabs
(
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
;
}
if
(
parentBC
-
>
UseRemoteSubframes
(
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
;
}
}
dom
:
:
AutoJSAPI
jsapiChromeGuard
;
if
(
isCallerChrome
&
&
!
hasChromeParent
&
&
!
windowTypeIsChrome
)
{
nsCOMPtr
<
nsIGlobalObject
>
parentGlobalObject
=
do_QueryInterface
(
aParent
)
;
if
(
!
aParent
)
{
jsapiChromeGuard
.
Init
(
)
;
}
else
if
(
NS_WARN_IF
(
!
jsapiChromeGuard
.
Init
(
parentGlobalObject
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
}
RefPtr
<
nsOpenWindowInfo
>
openWindowInfo
;
if
(
!
newBC
&
&
!
windowTypeIsChrome
)
{
openWindowInfo
=
new
nsOpenWindowInfo
(
)
;
openWindowInfo
-
>
mForceNoOpener
=
aForceNoOpener
;
openWindowInfo
-
>
mParent
=
parentBC
;
openWindowInfo
-
>
mIsForPrinting
=
aPrintKind
!
=
PRINT_NONE
;
openWindowInfo
-
>
mIsForPrintPreview
=
aPrintKind
=
=
PRINT_PREVIEW
;
openWindowInfo
-
>
mIsRemote
=
XRE_IsContentProcess
(
)
;
nsCOMPtr
<
nsIPrincipal
>
subjectPrincipal
=
nsContentUtils
:
:
SubjectPrincipalOrSystemIfNativeCaller
(
)
;
if
(
subjectPrincipal
&
&
!
nsContentUtils
:
:
IsSystemOrExpandedPrincipal
(
subjectPrincipal
)
)
{
openWindowInfo
-
>
mOriginAttributes
=
subjectPrincipal
-
>
OriginAttributesRef
(
)
;
}
else
if
(
parentBC
)
{
openWindowInfo
-
>
mOriginAttributes
=
parentBC
-
>
OriginAttributesRef
(
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
parentBC
|
|
openWindowInfo
-
>
mOriginAttributes
.
EqualsIgnoringFPD
(
parentBC
-
>
OriginAttributesRef
(
)
)
"
subject
principal
origin
attributes
doesn
'
t
match
opener
"
)
;
}
uint32_t
activeDocsSandboxFlags
=
0
;
if
(
!
newBC
)
{
windowNeedsName
=
true
;
if
(
aParent
)
{
if
(
Document
*
doc
=
parentWindow
-
>
GetDoc
(
)
)
{
activeDocsSandboxFlags
=
doc
-
>
GetSandboxFlags
(
)
;
if
(
activeDocsSandboxFlags
&
SANDBOXED_AUXILIARY_NAVIGATION
)
{
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
}
}
if
(
parentTreeOwner
&
&
!
aDialog
&
&
parentBC
-
>
IsContent
(
)
&
&
!
(
chromeFlags
&
(
nsIWebBrowserChrome
:
:
CHROME_MODAL
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
)
)
)
{
MOZ_ASSERT
(
openWindowInfo
)
;
nsCOMPtr
<
nsIWindowProvider
>
provider
=
do_GetInterface
(
parentTreeOwner
)
;
if
(
provider
)
{
rv
=
provider
-
>
ProvideWindow
(
openWindowInfo
chromeFlags
aCalledFromJS
sizeSpec
.
WidthSpecified
(
)
uriToLoad
name
featuresStr
aForceNoOpener
aForceNoReferrer
aLoadState
&
windowIsNew
getter_AddRefs
(
newBC
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
newBC
)
{
nsCOMPtr
<
nsIDocShell
>
newDocShell
=
newBC
-
>
GetDocShell
(
)
;
if
(
!
windowIsNew
&
&
newDocShell
)
{
if
(
!
CheckUserContextCompatibility
(
newDocShell
)
)
{
newBC
=
nullptr
;
windowIsNew
=
false
;
}
}
}
else
if
(
rv
=
=
NS_ERROR_ABORT
)
{
return
NS_OK
;
}
}
}
}
bool
newWindowShouldBeModal
=
false
;
bool
parentIsModal
=
false
;
if
(
!
newBC
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
NS_OK
;
}
windowIsNew
=
true
;
isNewToplevelWindow
=
true
;
nsCOMPtr
<
nsIWebBrowserChrome
>
parentChrome
(
do_GetInterface
(
parentTreeOwner
)
)
;
bool
weAreModal
=
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_MODAL
)
!
=
0
;
newWindowShouldBeModal
=
weAreModal
;
if
(
!
weAreModal
&
&
parentChrome
)
{
parentChrome
-
>
IsWindowModal
(
&
weAreModal
)
;
parentIsModal
=
weAreModal
;
}
if
(
weAreModal
)
{
windowIsModal
=
true
;
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_MODAL
|
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
;
}
if
(
!
hasChromeParent
&
&
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_MODAL
)
)
{
nsCOMPtr
<
nsIBaseWindow
>
parentWindow
(
do_GetInterface
(
parentTreeOwner
)
)
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
if
(
parentWindow
)
{
parentWindow
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
}
if
(
parentWidget
&
&
!
parentWidget
-
>
IsVisible
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
NS_ASSERTION
(
mWindowCreator
"
attempted
to
open
a
new
window
with
no
WindowCreator
"
)
;
rv
=
NS_ERROR_FAILURE
;
if
(
mWindowCreator
)
{
nsCOMPtr
<
nsIWebBrowserChrome
>
newChrome
;
nsCOMPtr
<
nsPIDOMWindowInner
>
parentTopInnerWindow
;
if
(
parentWindow
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
parentTopWindow
=
parentWindow
-
>
GetInProcessTop
(
)
;
if
(
parentTopWindow
)
{
parentTopInnerWindow
=
parentTopWindow
-
>
GetCurrentInnerWindow
(
)
;
}
}
if
(
parentTopInnerWindow
)
{
parentTopInnerWindow
-
>
Suspend
(
)
;
}
rv
=
CreateChromeWindow
(
parentChrome
chromeFlags
openWindowInfo
getter_AddRefs
(
newChrome
)
)
;
if
(
parentTopInnerWindow
)
{
parentTopInnerWindow
-
>
Resume
(
)
;
}
if
(
newChrome
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
newWindow
(
do_GetInterface
(
newChrome
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
newDocShellItem
;
if
(
newWindow
)
{
newDocShellItem
=
newWindow
-
>
GetDocShell
(
)
;
}
if
(
!
newDocShellItem
)
{
newDocShellItem
=
do_GetInterface
(
newChrome
)
;
}
if
(
!
newDocShellItem
)
{
rv
=
NS_ERROR_FAILURE
;
}
newBC
=
newDocShellItem
-
>
GetBrowsingContext
(
)
;
}
}
}
if
(
!
newBC
)
{
return
rv
;
}
if
(
activeDocsSandboxFlags
&
&
parentBC
)
{
MOZ_ALWAYS_SUCCEEDS
(
newBC
-
>
SetOnePermittedSandboxedNavigator
(
parentBC
)
)
;
}
if
(
!
aForceNoOpener
&
&
parentBC
)
{
if
(
windowIsNew
&
&
newBC
-
>
IsContent
(
)
)
{
MOZ_RELEASE_ASSERT
(
newBC
-
>
GetOpenerId
(
)
=
=
parentBC
-
>
Id
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
!
parentBC
=
=
newBC
-
>
HadOriginalOpener
(
)
)
;
}
else
{
newBC
-
>
SetOpener
(
parentBC
)
;
}
}
RefPtr
<
nsDocShell
>
newDocShell
(
nsDocShell
:
:
Cast
(
newBC
-
>
GetDocShell
(
)
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
windowIsNew
|
|
newDocShell
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
isNewToplevelWindow
|
|
newDocShell
)
;
if
(
activeDocsSandboxFlags
&
SANDBOX_PROPAGATES_TO_AUXILIARY_BROWSING_CONTEXTS
)
{
MOZ_ASSERT
(
windowIsNew
"
Should
only
get
here
for
new
windows
"
)
;
MOZ_ALWAYS_SUCCEEDS
(
newBC
-
>
SetSandboxFlags
(
activeDocsSandboxFlags
)
)
;
}
RefPtr
<
nsGlobalWindowOuter
>
win
(
nsGlobalWindowOuter
:
:
Cast
(
newBC
-
>
GetDOMWindow
(
)
)
)
;
if
(
win
)
{
if
(
windowIsNew
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIChannel
>
chan
;
newDocShell
-
>
GetDocumentChannel
(
getter_AddRefs
(
chan
)
)
;
MOZ_ASSERT
(
!
chan
"
Why
is
there
a
document
channel
?
"
)
;
#
endif
if
(
RefPtr
<
Document
>
doc
=
win
-
>
GetExtantDoc
(
)
)
{
doc
-
>
SetIsInitialDocument
(
true
)
;
}
}
}
MOZ_ASSERT
(
win
|
|
!
windowIsNew
"
New
windows
are
always
created
in
-
process
"
)
;
*
aResult
=
do_AddRef
(
newBC
)
.
take
(
)
;
if
(
isNewToplevelWindow
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
newTreeOwner
;
newDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
newTreeOwner
)
)
;
MaybeDisablePersistence
(
sizeSpec
newTreeOwner
)
;
}
if
(
aDialog
&
&
aArgv
)
{
MOZ_ASSERT
(
win
)
;
NS_ENSURE_TRUE
(
win
NS_ERROR_UNEXPECTED
)
;
MOZ_TRY
(
win
-
>
SetArguments
(
aArgv
)
)
;
}
if
(
windowNeedsName
)
{
if
(
nameSpecified
&
&
!
name
.
LowerCaseEqualsLiteral
(
"
_blank
"
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
newBC
-
>
SetName
(
name
)
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
newBC
-
>
SetName
(
EmptyString
(
)
)
)
;
}
}
JSContext
*
cx
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
;
nsCOMPtr
<
nsIPrincipal
>
subjectPrincipal
=
cx
?
nsContentUtils
:
:
SubjectPrincipal
(
)
:
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
if
(
windowIsNew
)
{
if
(
subjectPrincipal
&
&
!
nsContentUtils
:
:
IsSystemOrExpandedPrincipal
(
subjectPrincipal
)
&
&
newBC
-
>
IsContent
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
subjectPrincipal
-
>
OriginAttributesRef
(
)
.
EqualsIgnoringFPD
(
newBC
-
>
OriginAttributesRef
(
)
)
)
;
}
bool
autoPrivateBrowsing
=
Preferences
:
:
GetBool
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
if
(
!
autoPrivateBrowsing
&
&
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_NON_PRIVATE_WINDOW
)
)
{
if
(
newBC
-
>
IsChrome
(
)
)
{
newBC
-
>
SetUsePrivateBrowsing
(
false
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
newBC
-
>
UsePrivateBrowsing
(
)
"
CHROME_NON_PRIVATE_WINDOW
passed
but
got
private
window
"
)
;
}
else
if
(
autoPrivateBrowsing
|
|
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
)
)
{
if
(
newBC
-
>
IsChrome
(
)
)
{
newBC
-
>
SetUsePrivateBrowsing
(
true
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
newBC
-
>
UsePrivateBrowsing
(
)
"
CHROME_PRIVATE_WINDOW
passed
but
got
non
-
private
window
"
)
;
}
NS_ASSERTION
(
win
=
=
newDocShell
-
>
GetWindow
(
)
"
Different
windows
?
?
"
)
;
if
(
win
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
cspToInheritForAboutBlank
;
Maybe
<
nsILoadInfo
:
:
CrossOriginEmbedderPolicy
>
coepToInheritForAboutBlank
;
nsCOMPtr
<
mozIDOMWindowProxy
>
targetOpener
=
win
-
>
GetSameProcessOpener
(
)
;
nsCOMPtr
<
nsIDocShell
>
openerDocShell
(
do_GetInterface
(
targetOpener
)
)
;
if
(
openerDocShell
)
{
RefPtr
<
Document
>
openerDoc
=
static_cast
<
nsDocShell
*
>
(
openerDocShell
.
get
(
)
)
-
>
GetDocument
(
)
;
cspToInheritForAboutBlank
=
openerDoc
?
openerDoc
-
>
GetCsp
(
)
:
nullptr
;
coepToInheritForAboutBlank
=
openerDoc
-
>
GetEmbedderPolicy
(
)
;
}
win
-
>
SetInitialPrincipalToSubject
(
cspToInheritForAboutBlank
coepToInheritForAboutBlank
)
;
if
(
aIsPopupSpam
)
{
MOZ_ASSERT
(
!
newBC
-
>
GetIsPopupSpam
(
)
"
Who
marked
it
as
popup
spam
already
?
?
?
"
)
;
if
(
!
newBC
-
>
GetIsPopupSpam
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
newBC
-
>
SetIsPopupSpam
(
true
)
)
;
}
}
}
}
MOZ_DIAGNOSTIC_ASSERT
(
newBC
-
>
UseRemoteTabs
(
)
=
=
!
!
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
newBC
-
>
UseRemoteSubframes
(
)
=
=
!
!
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
)
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
pInnerWin
=
parentWindow
?
parentWindow
-
>
GetCurrentInnerWindow
(
)
:
nullptr
;
;
RefPtr
<
nsDocShellLoadState
>
loadState
=
aLoadState
;
if
(
uriToLoad
&
&
loadState
)
{
loadState
-
>
SetURI
(
uriToLoad
)
;
}
else
if
(
uriToLoad
&
&
aNavigate
&
&
!
loadState
)
{
RefPtr
<
WindowContext
>
context
=
pInnerWin
?
pInnerWin
-
>
GetWindowContext
(
)
:
nullptr
;
loadState
=
new
nsDocShellLoadState
(
uriToLoad
)
;
loadState
-
>
SetSourceBrowsingContext
(
parentBC
)
;
loadState
-
>
SetHasValidUserGestureActivation
(
context
&
&
context
-
>
HasValidTransientUserGestureActivation
(
)
)
;
if
(
parentBC
)
{
loadState
-
>
SetTriggeringSandboxFlags
(
parentBC
-
>
GetSandboxFlags
(
)
)
;
}
if
(
subjectPrincipal
)
{
loadState
-
>
SetTriggeringPrincipal
(
subjectPrincipal
)
;
}
#
ifndef
ANDROID
MOZ_ASSERT
(
subjectPrincipal
"
nsWindowWatcher
:
triggeringPrincipal
required
"
)
;
#
endif
if
(
!
aForceNoReferrer
)
{
RefPtr
<
Document
>
doc
=
GetEntryDocument
(
)
;
if
(
!
doc
&
&
parentWindow
)
{
doc
=
parentWindow
-
>
GetExtantDoc
(
)
;
}
if
(
doc
)
{
auto
referrerInfo
=
MakeRefPtr
<
ReferrerInfo
>
(
*
doc
)
;
loadState
-
>
SetReferrerInfo
(
referrerInfo
)
;
}
}
}
if
(
loadState
&
&
cx
)
{
nsGlobalWindowInner
*
win
=
xpc
:
:
CurrentWindowOrNull
(
cx
)
;
if
(
win
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
win
-
>
GetCsp
(
)
;
loadState
-
>
SetCsp
(
csp
)
;
}
}
if
(
isNewToplevelWindow
)
{
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
NotifyObservers
(
ToSupports
(
win
)
"
toplevel
-
window
-
ready
"
nullptr
)
;
}
}
MOZ_ASSERT_IF
(
newDocShell
CheckUserContextCompatibility
(
newDocShell
)
)
;
if
(
parentDocShell
&
&
windowIsNew
)
{
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
RefPtr
<
nsHashPropertyBag
>
props
=
new
nsHashPropertyBag
(
)
;
if
(
uriToLoad
)
{
props
-
>
SetPropertyAsACString
(
u
"
url
"
_ns
uriToLoad
-
>
GetSpecOrDefault
(
)
)
;
}
props
-
>
SetPropertyAsInterface
(
u
"
sourceTabDocShell
"
_ns
parentDocShell
)
;
props
-
>
SetPropertyAsInterface
(
u
"
createdTabDocShell
"
_ns
ToSupports
(
newDocShell
)
)
;
obsSvc
-
>
NotifyObservers
(
static_cast
<
nsIPropertyBag2
*
>
(
props
)
"
webNavigation
-
createdNavigationTarget
-
from
-
js
"
nullptr
)
;
}
}
if
(
uriToLoad
&
&
aNavigate
)
{
loadState
-
>
SetLoadFlags
(
windowIsNew
?
static_cast
<
uint32_t
>
(
nsIWebNavigation
:
:
LOAD_FLAGS_FIRST_LOAD
)
:
static_cast
<
uint32_t
>
(
nsIWebNavigation
:
:
LOAD_FLAGS_NONE
)
)
;
loadState
-
>
SetFirstParty
(
true
)
;
newBC
-
>
LoadURI
(
loadState
)
;
}
if
(
!
aForceNoOpener
&
&
subjectPrincipal
&
&
parentDocShell
&
&
newDocShell
)
{
const
RefPtr
<
SessionStorageManager
>
parentStorageManager
=
parentDocShell
-
>
GetBrowsingContext
(
)
-
>
GetSessionStorageManager
(
)
;
const
RefPtr
<
SessionStorageManager
>
newStorageManager
=
newDocShell
-
>
GetBrowsingContext
(
)
-
>
GetSessionStorageManager
(
)
;
if
(
parentStorageManager
&
&
newStorageManager
)
{
RefPtr
<
Storage
>
storage
;
parentStorageManager
-
>
GetStorage
(
pInnerWin
subjectPrincipal
subjectPrincipal
newBC
-
>
UsePrivateBrowsing
(
)
getter_AddRefs
(
storage
)
)
;
if
(
storage
)
{
newStorageManager
-
>
CloneStorage
(
storage
)
;
}
}
}
if
(
isNewToplevelWindow
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
newTreeOwner
;
newDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
newTreeOwner
)
)
;
SizeOpenedWindow
(
newTreeOwner
aParent
isCallerChrome
sizeSpec
)
;
}
if
(
windowIsModal
)
{
NS_ENSURE_TRUE
(
newDocShell
NS_ERROR_NOT_IMPLEMENTED
)
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
newTreeOwner
;
newDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
newTreeOwner
)
)
;
nsCOMPtr
<
nsIWebBrowserChrome
>
newChrome
(
do_GetInterface
(
newTreeOwner
)
)
;
NS_ENSURE_TRUE
(
newChrome
NS_ERROR_NOT_AVAILABLE
)
;
nsAutoWindowStateHelper
windowStateHelper
(
parentWindow
)
;
if
(
!
windowStateHelper
.
DefaultEnabled
(
)
)
{
NS_RELEASE
(
*
aResult
)
;
return
NS_OK
;
}
bool
isAppModal
=
false
;
nsCOMPtr
<
nsIBaseWindow
>
parentWindow
(
do_GetInterface
(
newTreeOwner
)
)
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
if
(
parentWindow
)
{
parentWindow
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
if
(
parentWidget
)
{
isAppModal
=
parentWidget
-
>
IsRunningAppModal
(
)
;
}
}
if
(
parentWidget
&
&
(
(
!
newWindowShouldBeModal
&
&
parentIsModal
)
|
|
isAppModal
)
)
{
parentWidget
-
>
SetFakeModal
(
true
)
;
}
else
{
AutoPopupStatePusher
popupStatePusher
(
PopupBlocker
:
:
openAbused
)
;
newChrome
-
>
ShowAsModal
(
)
;
}
}
if
(
StaticPrefs
:
:
full_screen_api_exit_on_windowOpen
(
)
&
&
windowIsNew
&
&
aCalledFromJS
&
&
!
hasChromeParent
&
&
!
isCallerChrome
&
&
parentWindow
)
{
Document
:
:
AsyncExitFullscreen
(
parentWindow
-
>
GetDoc
(
)
)
;
}
if
(
aForceNoOpener
&
&
windowIsNew
)
{
NS_RELEASE
(
*
aResult
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
RegisterNotification
(
nsIObserver
*
aObserver
)
{
if
(
!
aObserver
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
os
-
>
AddObserver
(
aObserver
"
domwindowopened
"
false
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
os
-
>
AddObserver
(
aObserver
"
domwindowclosed
"
false
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
UnregisterNotification
(
nsIObserver
*
aObserver
)
{
if
(
!
aObserver
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
NS_ERROR_FAILURE
;
}
os
-
>
RemoveObserver
(
aObserver
"
domwindowopened
"
)
;
os
-
>
RemoveObserver
(
aObserver
"
domwindowclosed
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetWindowEnumerator
(
nsISimpleEnumerator
*
*
aResult
)
{
if
(
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
MutexAutoLock
lock
(
mListLock
)
;
RefPtr
<
nsWatcherWindowEnumerator
>
enumerator
=
new
nsWatcherWindowEnumerator
(
this
)
;
enumerator
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetNewPrompter
(
mozIDOMWindowProxy
*
aParent
nsIPrompt
*
*
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
factory
=
do_GetService
(
"
mozilla
.
org
/
prompter
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
factory
-
>
GetPrompt
(
aParent
NS_GET_IID
(
nsIPrompt
)
reinterpret_cast
<
void
*
*
>
(
aResult
)
)
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetNewAuthPrompter
(
mozIDOMWindowProxy
*
aParent
nsIAuthPrompt
*
*
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
factory
=
do_GetService
(
"
mozilla
.
org
/
prompter
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
factory
-
>
GetPrompt
(
aParent
NS_GET_IID
(
nsIAuthPrompt
)
reinterpret_cast
<
void
*
*
>
(
aResult
)
)
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetPrompt
(
mozIDOMWindowProxy
*
aParent
const
nsIID
&
aIID
void
*
*
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
factory
=
do_GetService
(
"
mozilla
.
org
/
prompter
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
factory
-
>
GetPrompt
(
aParent
aIID
aResult
)
;
if
(
rv
=
=
NS_NOINTERFACE
&
&
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPrompt2
)
)
)
{
nsCOMPtr
<
nsIAuthPrompt
>
oldPrompt
;
rv
=
factory
-
>
GetPrompt
(
aParent
NS_GET_IID
(
nsIAuthPrompt
)
getter_AddRefs
(
oldPrompt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_WrapAuthPrompt
(
oldPrompt
reinterpret_cast
<
nsIAuthPrompt2
*
*
>
(
aResult
)
)
;
if
(
!
*
aResult
)
{
rv
=
NS_ERROR_NOT_AVAILABLE
;
}
}
return
rv
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
SetWindowCreator
(
nsIWindowCreator
*
aCreator
)
{
mWindowCreator
=
aCreator
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
HasWindowCreator
(
bool
*
aResult
)
{
*
aResult
=
mWindowCreator
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetActiveWindow
(
mozIDOMWindowProxy
*
*
aActiveWindow
)
{
*
aActiveWindow
=
nullptr
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
return
fm
-
>
GetActiveWindow
(
aActiveWindow
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
AddWindow
(
mozIDOMWindowProxy
*
aWindow
nsIWebBrowserChrome
*
aChrome
)
{
if
(
!
aWindow
)
{
return
NS_ERROR_INVALID_ARG
;
}
{
nsWatcherWindowEntry
*
info
;
MutexAutoLock
lock
(
mListLock
)
;
info
=
FindWindowEntry
(
aWindow
)
;
if
(
info
)
{
nsCOMPtr
<
nsISupportsWeakReference
>
supportsweak
(
do_QueryInterface
(
aChrome
)
)
;
if
(
supportsweak
)
{
supportsweak
-
>
GetWeakReference
(
getter_AddRefs
(
info
-
>
mChromeWeak
)
)
;
}
else
{
info
-
>
mChrome
=
aChrome
;
info
-
>
mChromeWeak
=
nullptr
;
}
return
NS_OK
;
}
info
=
new
nsWatcherWindowEntry
(
aWindow
aChrome
)
;
if
(
!
info
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
mOldestWindow
)
{
info
-
>
InsertAfter
(
mOldestWindow
-
>
mOlder
)
;
}
else
{
mOldestWindow
=
info
;
}
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISupports
>
domwin
(
do_QueryInterface
(
aWindow
)
)
;
return
os
-
>
NotifyObservers
(
domwin
"
domwindowopened
"
0
)
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
RemoveWindow
(
mozIDOMWindowProxy
*
aWindow
)
{
if
(
!
aWindow
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsWatcherWindowEntry
*
info
=
FindWindowEntry
(
aWindow
)
;
if
(
info
)
{
RemoveWindow
(
info
)
;
return
NS_OK
;
}
NS_WARNING
(
"
requested
removal
of
nonexistent
window
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
nsWatcherWindowEntry
*
nsWindowWatcher
:
:
FindWindowEntry
(
mozIDOMWindowProxy
*
aWindow
)
{
nsWatcherWindowEntry
*
info
;
nsWatcherWindowEntry
*
listEnd
;
info
=
mOldestWindow
;
listEnd
=
0
;
while
(
info
!
=
listEnd
)
{
if
(
info
-
>
mWindow
=
=
aWindow
)
{
return
info
;
}
info
=
info
-
>
mYounger
;
listEnd
=
mOldestWindow
;
}
return
0
;
}
nsresult
nsWindowWatcher
:
:
RemoveWindow
(
nsWatcherWindowEntry
*
aInfo
)
{
uint32_t
count
=
mEnumeratorList
.
Length
(
)
;
{
MutexAutoLock
lock
(
mListLock
)
;
for
(
uint32_t
ctr
=
0
;
ctr
<
count
;
+
+
ctr
)
{
mEnumeratorList
[
ctr
]
-
>
WindowRemoved
(
aInfo
)
;
}
if
(
aInfo
=
=
mOldestWindow
)
{
mOldestWindow
=
aInfo
-
>
mYounger
=
=
mOldestWindow
?
0
:
aInfo
-
>
mYounger
;
}
aInfo
-
>
Unlink
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
nsCOMPtr
<
nsISupports
>
domwin
(
do_QueryInterface
(
aInfo
-
>
mWindow
)
)
;
os
-
>
NotifyObservers
(
domwin
"
domwindowclosed
"
0
)
;
}
delete
aInfo
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetChromeForWindow
(
mozIDOMWindowProxy
*
aWindow
nsIWebBrowserChrome
*
*
aResult
)
{
if
(
!
aWindow
|
|
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
0
;
MutexAutoLock
lock
(
mListLock
)
;
nsWatcherWindowEntry
*
info
=
FindWindowEntry
(
aWindow
)
;
if
(
info
)
{
if
(
info
-
>
mChromeWeak
)
{
return
info
-
>
mChromeWeak
-
>
QueryReferent
(
NS_GET_IID
(
nsIWebBrowserChrome
)
reinterpret_cast
<
void
*
*
>
(
aResult
)
)
;
}
*
aResult
=
info
-
>
mChrome
;
NS_IF_ADDREF
(
*
aResult
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetWindowByName
(
const
nsAString
&
aTargetName
mozIDOMWindowProxy
*
aCurrentWindow
mozIDOMWindowProxy
*
*
aResult
)
{
if
(
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
nullptr
;
BrowsingContext
*
currentContext
=
aCurrentWindow
?
nsPIDOMWindowOuter
:
:
From
(
aCurrentWindow
)
-
>
GetBrowsingContext
(
)
:
nullptr
;
RefPtr
<
BrowsingContext
>
context
=
GetBrowsingContextByName
(
aTargetName
false
currentContext
)
;
if
(
context
)
{
*
aResult
=
do_AddRef
(
context
-
>
GetDOMWindow
(
)
)
.
take
(
)
;
MOZ_ASSERT
(
*
aResult
)
;
}
return
NS_OK
;
}
bool
nsWindowWatcher
:
:
AddEnumerator
(
nsWatcherWindowEnumerator
*
aEnumerator
)
{
mEnumeratorList
.
AppendElement
(
aEnumerator
)
;
return
true
;
}
bool
nsWindowWatcher
:
:
RemoveEnumerator
(
nsWatcherWindowEnumerator
*
aEnumerator
)
{
return
mEnumeratorList
.
RemoveElement
(
aEnumerator
)
;
}
nsresult
nsWindowWatcher
:
:
URIfromURL
(
const
nsACString
&
aURL
mozIDOMWindowProxy
*
aParent
nsIURI
*
*
aURI
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
baseWindow
=
do_QueryInterface
(
GetEntryGlobal
(
)
)
;
if
(
!
baseWindow
&
&
aParent
)
{
baseWindow
=
nsPIDOMWindowOuter
:
:
From
(
aParent
)
-
>
GetCurrentInnerWindow
(
)
;
}
nsIURI
*
baseURI
=
nullptr
;
if
(
baseWindow
)
{
if
(
Document
*
doc
=
baseWindow
-
>
GetDoc
(
)
)
{
baseURI
=
doc
-
>
GetDocBaseURI
(
)
;
}
}
return
NS_NewURI
(
aURI
aURL
nullptr
baseURI
)
;
}
uint32_t
nsWindowWatcher
:
:
CalculateChromeFlagsHelper
(
uint32_t
aInitialFlags
const
WindowFeatures
&
aFeatures
const
SizeSpec
&
aSizeSpec
bool
*
presenceFlag
bool
aHasChromeParent
)
{
uint32_t
chromeFlags
=
aInitialFlags
;
if
(
aFeatures
.
GetBoolWithDefault
(
"
titlebar
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_TITLEBAR
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
close
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_CLOSE
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
toolbar
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_TOOLBAR
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
location
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_LOCATIONBAR
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
personalbar
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_PERSONAL_TOOLBAR
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
status
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_STATUSBAR
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
menubar
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_MENUBAR
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
resizable
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RESIZE
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
minimizable
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_MIN
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
scrollbars
"
true
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_SCROLLBARS
;
}
if
(
aHasChromeParent
)
{
return
chromeFlags
;
}
if
(
ShouldOpenPopup
(
aFeatures
aSizeSpec
)
)
{
return
aInitialFlags
|
nsIWebBrowserChrome
:
:
CHROME_TITLEBAR
|
nsIWebBrowserChrome
:
:
CHROME_WINDOW_CLOSE
|
nsIWebBrowserChrome
:
:
CHROME_LOCATIONBAR
|
nsIWebBrowserChrome
:
:
CHROME_STATUSBAR
|
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RESIZE
|
nsIWebBrowserChrome
:
:
CHROME_WINDOW_MIN
|
nsIWebBrowserChrome
:
:
CHROME_SCROLLBARS
;
}
return
aInitialFlags
|
nsIWebBrowserChrome
:
:
CHROME_ALL
;
}
uint32_t
nsWindowWatcher
:
:
EnsureFlagsSafeForContent
(
uint32_t
aChromeFlags
bool
aChromeURL
)
{
aChromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_TITLEBAR
;
aChromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_CLOSE
;
aChromeFlags
&
=
~
nsIWebBrowserChrome
:
:
CHROME_WINDOW_LOWERED
;
aChromeFlags
&
=
~
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RAISED
;
aChromeFlags
&
=
~
nsIWebBrowserChrome
:
:
CHROME_WINDOW_POPUP
;
if
(
!
aChromeURL
)
{
aChromeFlags
&
=
~
(
nsIWebBrowserChrome
:
:
CHROME_MODAL
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
)
;
}
if
(
!
(
aChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
)
)
{
aChromeFlags
&
=
~
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
;
}
return
aChromeFlags
;
}
bool
nsWindowWatcher
:
:
ShouldOpenPopup
(
const
WindowFeatures
&
aFeatures
const
SizeSpec
&
aSizeSpec
)
{
if
(
aFeatures
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
!
aFeatures
.
GetBoolWithDefault
(
"
location
"
false
)
&
&
!
aFeatures
.
GetBoolWithDefault
(
"
toolbar
"
false
)
)
{
return
true
;
}
if
(
!
aFeatures
.
GetBoolWithDefault
(
"
menubar
"
false
)
)
{
return
true
;
}
if
(
!
aFeatures
.
GetBoolWithDefault
(
"
resizable
"
true
)
)
{
return
true
;
}
if
(
!
aFeatures
.
GetBoolWithDefault
(
"
scrollbars
"
false
)
)
{
return
true
;
}
if
(
!
aFeatures
.
GetBoolWithDefault
(
"
status
"
false
)
)
{
return
true
;
}
if
(
aSizeSpec
.
WidthSpecified
(
)
)
{
return
true
;
}
return
false
;
}
uint32_t
nsWindowWatcher
:
:
CalculateChromeFlagsForContent
(
const
WindowFeatures
&
aFeatures
const
SizeSpec
&
aSizeSpec
)
{
if
(
aFeatures
.
IsEmpty
(
)
)
{
return
nsIWebBrowserChrome
:
:
CHROME_ALL
;
}
uint32_t
chromeFlags
=
CalculateChromeFlagsHelper
(
nsIWebBrowserChrome
:
:
CHROME_WINDOW_BORDERS
aFeatures
aSizeSpec
)
;
return
EnsureFlagsSafeForContent
(
chromeFlags
)
;
}
uint32_t
nsWindowWatcher
:
:
CalculateChromeFlagsForSystem
(
const
WindowFeatures
&
aFeatures
const
SizeSpec
&
aSizeSpec
bool
aDialog
bool
aChromeURL
bool
aHasChromeParent
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
)
;
uint32_t
chromeFlags
=
0
;
if
(
aFeatures
.
IsEmpty
(
)
)
{
chromeFlags
=
nsIWebBrowserChrome
:
:
CHROME_ALL
;
if
(
aDialog
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
}
}
else
{
chromeFlags
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_BORDERS
;
}
bool
presenceFlag
=
false
;
if
(
aDialog
&
&
aFeatures
.
GetBoolWithDefault
(
"
all
"
false
&
presenceFlag
)
)
{
chromeFlags
=
nsIWebBrowserChrome
:
:
CHROME_ALL
;
}
chromeFlags
=
CalculateChromeFlagsHelper
(
chromeFlags
aFeatures
aSizeSpec
&
presenceFlag
aHasChromeParent
)
;
if
(
aFeatures
.
GetBoolWithDefault
(
"
private
"
false
&
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
non
-
private
"
false
&
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_NON_PRIVATE_WINDOW
;
}
bool
remote
=
BrowserTabsRemoteAutostart
(
)
;
if
(
remote
)
{
remote
=
!
aFeatures
.
GetBoolWithDefault
(
"
non
-
remote
"
false
&
presenceFlag
)
;
}
else
{
remote
=
aFeatures
.
GetBoolWithDefault
(
"
remote
"
false
&
presenceFlag
)
;
}
if
(
remote
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
;
}
bool
fission
=
FissionAutostart
(
)
;
if
(
fission
)
{
fission
=
!
aFeatures
.
GetBoolWithDefault
(
"
non
-
fission
"
false
&
presenceFlag
)
;
}
else
{
fission
=
aFeatures
.
GetBoolWithDefault
(
"
fission
"
false
&
presenceFlag
)
;
}
if
(
fission
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
popup
"
false
&
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_POPUP
;
}
if
(
!
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_WINDOW_POPUP
)
)
{
if
(
!
aFeatures
.
Exists
(
"
titlebar
"
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_TITLEBAR
;
}
if
(
!
aFeatures
.
Exists
(
"
close
"
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_CLOSE
;
}
}
if
(
aDialog
&
&
!
aFeatures
.
IsEmpty
(
)
&
&
!
presenceFlag
)
{
chromeFlags
=
nsIWebBrowserChrome
:
:
CHROME_DEFAULT
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
alwayslowered
"
false
)
|
|
aFeatures
.
GetBoolWithDefault
(
"
z
-
lock
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_LOWERED
;
}
else
if
(
aFeatures
.
GetBoolWithDefault
(
"
alwaysraised
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RAISED
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
suppressanimation
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_SUPPRESS_ANIMATION
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
alwaysontop
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_ALWAYS_ON_TOP
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
chrome
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
extrachrome
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_EXTRA
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
centerscreen
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_CENTER_SCREEN
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
dependent
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
modal
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_MODAL
|
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
;
}
bool
disableDialogFeature
=
false
;
nsCOMPtr
<
nsIPrefBranch
>
branch
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
branch
-
>
GetBoolPref
(
"
dom
.
disable_window_open_dialog_feature
"
&
disableDialogFeature
)
;
if
(
!
disableDialogFeature
)
{
if
(
aFeatures
.
GetBoolWithDefault
(
"
dialog
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
;
}
}
if
(
aDialog
)
{
if
(
!
aFeatures
.
Exists
(
"
dialog
"
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
;
}
if
(
!
aFeatures
.
Exists
(
"
chrome
"
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
}
}
if
(
!
aHasChromeParent
)
{
chromeFlags
=
EnsureFlagsSafeForContent
(
chromeFlags
aChromeURL
)
;
}
return
chromeFlags
;
}
already_AddRefed
<
BrowsingContext
>
nsWindowWatcher
:
:
GetBrowsingContextByName
(
const
nsAString
&
aName
bool
aForceNoOpener
BrowsingContext
*
aCurrentContext
)
{
if
(
aName
.
IsEmpty
(
)
)
{
return
nullptr
;
}
if
(
aForceNoOpener
&
&
!
nsContentUtils
:
:
IsSpecialName
(
aName
)
)
{
return
nullptr
;
}
RefPtr
<
BrowsingContext
>
foundContext
;
if
(
aCurrentContext
)
{
foundContext
=
aCurrentContext
-
>
FindWithName
(
aName
)
;
}
else
if
(
!
nsContentUtils
:
:
IsSpecialName
(
aName
)
)
{
for
(
RefPtr
<
BrowsingContext
>
toplevel
:
BrowsingContextGroup
:
:
GetChromeGroup
(
)
-
>
Toplevels
(
)
)
{
foundContext
=
toplevel
-
>
FindWithNameInSubtree
(
aName
*
toplevel
)
;
if
(
foundContext
)
{
break
;
}
}
}
return
foundContext
.
forget
(
)
;
}
void
nsWindowWatcher
:
:
CalcSizeSpec
(
const
WindowFeatures
&
aFeatures
bool
aHasChromeParent
SizeSpec
&
aResult
)
{
if
(
aFeatures
.
Exists
(
"
left
"
)
)
{
int32_t
x
=
aFeatures
.
GetInt
(
"
left
"
)
;
aResult
.
mLeft
=
x
;
aResult
.
mLeftSpecified
=
true
;
}
if
(
aFeatures
.
Exists
(
"
top
"
)
)
{
int32_t
y
=
aFeatures
.
GetInt
(
"
top
"
)
;
aResult
.
mTop
=
y
;
aResult
.
mTopSpecified
=
true
;
}
if
(
aHasChromeParent
&
&
aFeatures
.
Exists
(
"
outerwidth
"
)
)
{
int32_t
width
=
aFeatures
.
GetInt
(
"
outerwidth
"
)
;
if
(
width
)
{
aResult
.
mOuterWidth
=
width
;
aResult
.
mOuterWidthSpecified
=
true
;
}
}
if
(
!
aResult
.
mOuterWidthSpecified
)
{
if
(
aFeatures
.
Exists
(
"
width
"
)
)
{
int32_t
width
=
aFeatures
.
GetInt
(
"
width
"
)
;
if
(
width
)
{
aResult
.
mInnerWidth
=
width
;
aResult
.
mInnerWidthSpecified
=
true
;
}
}
}
if
(
aHasChromeParent
&
&
aFeatures
.
Exists
(
"
outerheight
"
)
)
{
int32_t
height
=
aFeatures
.
GetInt
(
"
outerheight
"
)
;
if
(
height
)
{
aResult
.
mOuterHeight
=
height
;
aResult
.
mOuterHeightSpecified
=
true
;
}
}
if
(
!
aResult
.
mOuterHeightSpecified
)
{
if
(
aFeatures
.
Exists
(
"
height
"
)
)
{
int32_t
height
=
aFeatures
.
GetInt
(
"
height
"
)
;
if
(
height
)
{
aResult
.
mInnerHeight
=
height
;
aResult
.
mInnerHeightSpecified
=
true
;
}
}
}
aResult
.
mLockAspectRatio
=
aFeatures
.
GetBoolWithDefault
(
"
lockaspectratio
"
false
)
;
}
void
nsWindowWatcher
:
:
SizeOpenedWindow
(
nsIDocShellTreeOwner
*
aTreeOwner
mozIDOMWindowProxy
*
aParent
bool
aIsCallerChrome
const
SizeSpec
&
aSizeSpec
const
Maybe
<
float
>
&
aOpenerFullZoom
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
int32_t
left
=
0
top
=
0
width
=
100
height
=
100
;
int32_t
chromeWidth
=
0
chromeHeight
=
0
;
bool
sizeChromeWidth
=
true
sizeChromeHeight
=
true
;
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
(
do_QueryInterface
(
aTreeOwner
)
)
;
if
(
!
treeOwnerAsWin
)
{
return
;
}
double
openerZoom
=
aOpenerFullZoom
.
valueOr
(
1
.
0
)
;
if
(
aParent
&
&
aOpenerFullZoom
.
isNothing
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
piWindow
=
nsPIDOMWindowOuter
:
:
From
(
aParent
)
;
if
(
Document
*
doc
=
piWindow
-
>
GetDoc
(
)
)
{
if
(
nsPresContext
*
presContext
=
doc
-
>
GetPresContext
(
)
)
{
openerZoom
=
presContext
-
>
GetFullZoom
(
)
;
}
}
}
double
scale
=
1
.
0
;
treeOwnerAsWin
-
>
GetUnscaledDevicePixelsPerCSSPixel
(
&
scale
)
;
treeOwnerAsWin
-
>
GetPositionAndSize
(
&
left
&
top
&
width
&
height
)
;
left
=
NSToIntRound
(
left
/
scale
)
;
top
=
NSToIntRound
(
top
/
scale
)
;
width
=
NSToIntRound
(
width
/
scale
)
;
height
=
NSToIntRound
(
height
/
scale
)
;
{
int32_t
contentWidth
contentHeight
;
bool
hasPrimaryContent
=
false
;
aTreeOwner
-
>
GetHasPrimaryContent
(
&
hasPrimaryContent
)
;
if
(
hasPrimaryContent
)
{
aTreeOwner
-
>
GetPrimaryContentSize
(
&
contentWidth
&
contentHeight
)
;
}
else
{
aTreeOwner
-
>
GetRootShellSize
(
&
contentWidth
&
contentHeight
)
;
}
chromeWidth
=
width
-
contentWidth
;
chromeHeight
=
height
-
contentHeight
;
}
if
(
aSizeSpec
.
mLeftSpecified
)
{
left
=
NSToIntRound
(
aSizeSpec
.
mLeft
*
openerZoom
)
;
}
if
(
aSizeSpec
.
mTopSpecified
)
{
top
=
NSToIntRound
(
aSizeSpec
.
mTop
*
openerZoom
)
;
}
if
(
aSizeSpec
.
mOuterWidthSpecified
)
{
width
=
NSToIntRound
(
aSizeSpec
.
mOuterWidth
*
openerZoom
)
;
}
else
if
(
aSizeSpec
.
mInnerWidthSpecified
)
{
sizeChromeWidth
=
false
;
width
=
NSToIntRound
(
aSizeSpec
.
mInnerWidth
*
openerZoom
)
;
}
if
(
aSizeSpec
.
mOuterHeightSpecified
)
{
height
=
NSToIntRound
(
aSizeSpec
.
mOuterHeight
*
openerZoom
)
;
}
else
if
(
aSizeSpec
.
mInnerHeightSpecified
)
{
sizeChromeHeight
=
false
;
height
=
NSToIntRound
(
aSizeSpec
.
mInnerHeight
*
openerZoom
)
;
}
bool
positionSpecified
=
aSizeSpec
.
PositionSpecified
(
)
;
bool
enabled
=
false
;
if
(
aIsCallerChrome
)
{
nsCOMPtr
<
nsIDOMChromeWindow
>
chromeWin
(
do_QueryInterface
(
aParent
)
)
;
enabled
=
!
aParent
|
|
chromeWin
;
}
if
(
!
enabled
)
{
int32_t
oldTop
=
top
oldLeft
=
left
;
nsCOMPtr
<
nsIScreen
>
screen
;
nsCOMPtr
<
nsIScreenManager
>
screenMgr
(
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
)
;
if
(
screenMgr
)
screenMgr
-
>
ScreenForRect
(
left
top
width
height
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
int32_t
screenLeft
screenTop
screenWidth
screenHeight
;
int32_t
winWidth
=
width
+
(
sizeChromeWidth
?
0
:
chromeWidth
)
winHeight
=
height
+
(
sizeChromeHeight
?
0
:
chromeHeight
)
;
screen
-
>
GetAvailRect
(
&
screenLeft
&
screenTop
&
screenWidth
&
screenHeight
)
;
screenLeft
=
NSToIntRound
(
screenLeft
/
scale
)
;
screenTop
=
NSToIntRound
(
screenTop
/
scale
)
;
screenWidth
=
NSToIntRound
(
screenWidth
/
scale
)
;
screenHeight
=
NSToIntRound
(
screenHeight
/
scale
)
;
if
(
aSizeSpec
.
SizeSpecified
(
)
)
{
if
(
!
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
)
{
if
(
height
<
100
)
{
height
=
100
;
winHeight
=
height
+
(
sizeChromeHeight
?
0
:
chromeHeight
)
;
}
if
(
winHeight
>
screenHeight
)
{
height
=
screenHeight
-
(
sizeChromeHeight
?
0
:
chromeHeight
)
;
}
if
(
width
<
100
)
{
width
=
100
;
winWidth
=
width
+
(
sizeChromeWidth
?
0
:
chromeWidth
)
;
}
if
(
winWidth
>
screenWidth
)
{
width
=
screenWidth
-
(
sizeChromeWidth
?
0
:
chromeWidth
)
;
}
}
else
{
int32_t
targetContentWidth
=
0
;
int32_t
targetContentHeight
=
0
;
nsContentUtils
:
:
CalcRoundedWindowSizeForResistingFingerprinting
(
chromeWidth
chromeHeight
screenWidth
screenHeight
width
height
sizeChromeWidth
sizeChromeHeight
&
targetContentWidth
&
targetContentHeight
)
;
if
(
aSizeSpec
.
mInnerWidthSpecified
|
|
aSizeSpec
.
mOuterWidthSpecified
)
{
width
=
targetContentWidth
;
winWidth
=
width
+
(
sizeChromeWidth
?
0
:
chromeWidth
)
;
}
if
(
aSizeSpec
.
mInnerHeightSpecified
|
|
aSizeSpec
.
mOuterHeightSpecified
)
{
height
=
targetContentHeight
;
winHeight
=
height
+
(
sizeChromeHeight
?
0
:
chromeHeight
)
;
}
}
}
CheckedInt
<
decltype
(
left
)
>
leftPlusWinWidth
=
left
;
leftPlusWinWidth
+
=
winWidth
;
if
(
!
leftPlusWinWidth
.
isValid
(
)
|
|
leftPlusWinWidth
.
value
(
)
>
screenLeft
+
screenWidth
)
{
left
=
screenLeft
+
screenWidth
-
winWidth
;
}
if
(
left
<
screenLeft
)
{
left
=
screenLeft
;
}
CheckedInt
<
decltype
(
top
)
>
topPlusWinHeight
=
top
;
topPlusWinHeight
+
=
winHeight
;
if
(
!
topPlusWinHeight
.
isValid
(
)
|
|
topPlusWinHeight
.
value
(
)
>
screenTop
+
screenHeight
)
{
top
=
screenTop
+
screenHeight
-
winHeight
;
}
if
(
top
<
screenTop
)
{
top
=
screenTop
;
}
if
(
top
!
=
oldTop
|
|
left
!
=
oldLeft
)
{
positionSpecified
=
true
;
}
}
}
if
(
positionSpecified
)
{
nsCOMPtr
<
nsIScreen
>
screen
;
nsCOMPtr
<
nsIScreenManager
>
screenMgr
(
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
)
;
if
(
screenMgr
)
{
screenMgr
-
>
ScreenForRect
(
left
top
1
1
getter_AddRefs
(
screen
)
)
;
}
if
(
screen
)
{
double
cssToDevPixScale
desktopToDevPixScale
;
screen
-
>
GetDefaultCSSScaleFactor
(
&
cssToDevPixScale
)
;
screen
-
>
GetContentsScaleFactor
(
&
desktopToDevPixScale
)
;
double
cssToDesktopScale
=
cssToDevPixScale
/
desktopToDevPixScale
;
int32_t
screenLeft
screenTop
screenWd
screenHt
;
screen
-
>
GetRectDisplayPix
(
&
screenLeft
&
screenTop
&
screenWd
&
screenHt
)
;
treeOwnerAsWin
-
>
SetPositionDesktopPix
(
(
left
-
screenLeft
)
*
cssToDesktopScale
+
screenLeft
(
top
-
screenTop
)
*
cssToDesktopScale
+
screenTop
)
;
}
else
{
treeOwnerAsWin
-
>
SetPosition
(
left
*
scale
top
*
scale
)
;
}
treeOwnerAsWin
-
>
GetUnscaledDevicePixelsPerCSSPixel
(
&
scale
)
;
}
if
(
aSizeSpec
.
SizeSpecified
(
)
)
{
if
(
!
sizeChromeWidth
&
&
!
sizeChromeHeight
)
{
bool
hasPrimaryContent
=
false
;
aTreeOwner
-
>
GetHasPrimaryContent
(
&
hasPrimaryContent
)
;
if
(
hasPrimaryContent
)
{
aTreeOwner
-
>
SetPrimaryContentSize
(
width
*
scale
height
*
scale
)
;
}
else
{
aTreeOwner
-
>
SetRootShellSize
(
width
*
scale
height
*
scale
)
;
}
}
else
{
if
(
!
sizeChromeWidth
)
{
width
+
=
chromeWidth
;
}
if
(
!
sizeChromeHeight
)
{
height
+
=
chromeHeight
;
}
treeOwnerAsWin
-
>
SetSize
(
width
*
scale
height
*
scale
false
)
;
}
}
if
(
aIsCallerChrome
)
{
nsCOMPtr
<
nsIAppWindow
>
appWin
=
do_GetInterface
(
treeOwnerAsWin
)
;
if
(
appWin
&
&
aSizeSpec
.
mLockAspectRatio
)
{
appWin
-
>
LockAspectRatio
(
true
)
;
}
}
treeOwnerAsWin
-
>
SetVisibility
(
true
)
;
}
int32_t
nsWindowWatcher
:
:
GetWindowOpenLocation
(
nsPIDOMWindowOuter
*
aParent
uint32_t
aChromeFlags
bool
aCalledFromJS
bool
aWidthSpecified
bool
aIsForPrinting
)
{
if
(
aIsForPrinting
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_PRINT_BROWSER
;
}
int32_t
containerPref
;
if
(
NS_FAILED
(
Preferences
:
:
GetInt
(
"
browser
.
link
.
open_newwindow
"
&
containerPref
)
)
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_NEWTAB
;
}
bool
isDisabledOpenNewWindow
=
aParent
-
>
GetFullScreen
(
)
&
&
Preferences
:
:
GetBool
(
"
browser
.
link
.
open_newwindow
.
disabled_in_fullscreen
"
)
;
if
(
isDisabledOpenNewWindow
&
&
(
containerPref
=
=
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
)
)
{
containerPref
=
nsIBrowserDOMWindow
:
:
OPEN_NEWTAB
;
}
if
(
containerPref
!
=
nsIBrowserDOMWindow
:
:
OPEN_NEWTAB
&
&
containerPref
!
=
nsIBrowserDOMWindow
:
:
OPEN_CURRENTWINDOW
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
;
}
if
(
aCalledFromJS
)
{
int32_t
restrictionPref
=
Preferences
:
:
GetInt
(
"
browser
.
link
.
open_newwindow
.
restriction
"
2
)
;
if
(
restrictionPref
<
0
|
|
restrictionPref
>
2
)
{
restrictionPref
=
2
;
}
if
(
isDisabledOpenNewWindow
)
{
restrictionPref
=
0
;
}
if
(
restrictionPref
=
=
1
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
;
}
if
(
restrictionPref
=
=
2
)
{
int32_t
uiChromeFlags
=
aChromeFlags
;
uiChromeFlags
&
=
~
(
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_NON_PRIVATE_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_LIFETIME
)
;
if
(
uiChromeFlags
!
=
nsIWebBrowserChrome
:
:
CHROME_ALL
|
|
aWidthSpecified
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
;
}
}
}
return
containerPref
;
}
