#
include
"
nsWindowWatcher
.
h
"
#
include
"
nsAutoWindowStateHelper
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIAuthPrompt
.
h
"
#
include
"
nsIAuthPrompt2
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsHashPropertyBag
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIBrowserDOMWindow
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContextGroup
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
nsIDragService
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIScreen
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIWebBrowser
.
h
"
#
include
"
nsIWebBrowserChrome
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIWindowCreator
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIWindowProvider
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsIDOMStorageManager
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsOpenWindowInfo
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsSimpleEnumerator
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
StaticPrefs_full_screen_api
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Storage
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
BrowserHost
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
SessionStorageManager
.
h
"
#
include
"
nsIAppWindow
.
h
"
#
include
"
nsIXULBrowserWindow
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
ReferrerInfo
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
class
nsWindowWatcher
;
struct
nsWatcherWindowEntry
{
nsWatcherWindowEntry
(
mozIDOMWindowProxy
*
aWindow
nsIWebBrowserChrome
*
aChrome
)
:
mChrome
(
nullptr
)
{
mWindow
=
aWindow
;
nsCOMPtr
<
nsISupportsWeakReference
>
supportsweak
(
do_QueryInterface
(
aChrome
)
)
;
if
(
supportsweak
)
{
supportsweak
-
>
GetWeakReference
(
getter_AddRefs
(
mChromeWeak
)
)
;
}
else
{
mChrome
=
aChrome
;
mChromeWeak
=
nullptr
;
}
ReferenceSelf
(
)
;
}
~
nsWatcherWindowEntry
(
)
=
default
;
void
InsertAfter
(
nsWatcherWindowEntry
*
aOlder
)
;
void
Unlink
(
)
;
void
ReferenceSelf
(
)
;
mozIDOMWindowProxy
*
mWindow
;
nsIWebBrowserChrome
*
mChrome
;
nsWeakPtr
mChromeWeak
;
nsWatcherWindowEntry
*
mYounger
;
nsWatcherWindowEntry
*
mOlder
;
}
;
void
nsWatcherWindowEntry
:
:
InsertAfter
(
nsWatcherWindowEntry
*
aOlder
)
{
if
(
aOlder
)
{
mOlder
=
aOlder
;
mYounger
=
aOlder
-
>
mYounger
;
mOlder
-
>
mYounger
=
this
;
if
(
mOlder
-
>
mOlder
=
=
mOlder
)
{
mOlder
-
>
mOlder
=
this
;
}
mYounger
-
>
mOlder
=
this
;
if
(
mYounger
-
>
mYounger
=
=
mYounger
)
{
mYounger
-
>
mYounger
=
this
;
}
}
}
void
nsWatcherWindowEntry
:
:
Unlink
(
)
{
mOlder
-
>
mYounger
=
mYounger
;
mYounger
-
>
mOlder
=
mOlder
;
ReferenceSelf
(
)
;
}
void
nsWatcherWindowEntry
:
:
ReferenceSelf
(
)
{
mYounger
=
this
;
mOlder
=
this
;
}
class
nsWatcherWindowEnumerator
:
public
nsSimpleEnumerator
{
public
:
explicit
nsWatcherWindowEnumerator
(
nsWindowWatcher
*
aWatcher
)
;
NS_IMETHOD
HasMoreElements
(
bool
*
aResult
)
override
;
NS_IMETHOD
GetNext
(
nsISupports
*
*
aResult
)
override
;
protected
:
~
nsWatcherWindowEnumerator
(
)
override
;
private
:
friend
class
nsWindowWatcher
;
nsWatcherWindowEntry
*
FindNext
(
)
;
void
WindowRemoved
(
nsWatcherWindowEntry
*
aInfo
)
;
nsWindowWatcher
*
mWindowWatcher
;
nsWatcherWindowEntry
*
mCurrentPosition
;
}
;
nsWatcherWindowEnumerator
:
:
nsWatcherWindowEnumerator
(
nsWindowWatcher
*
aWatcher
)
:
mWindowWatcher
(
aWatcher
)
mCurrentPosition
(
aWatcher
-
>
mOldestWindow
)
{
mWindowWatcher
-
>
AddEnumerator
(
this
)
;
mWindowWatcher
-
>
AddRef
(
)
;
}
nsWatcherWindowEnumerator
:
:
~
nsWatcherWindowEnumerator
(
)
{
mWindowWatcher
-
>
RemoveEnumerator
(
this
)
;
mWindowWatcher
-
>
Release
(
)
;
}
NS_IMETHODIMP
nsWatcherWindowEnumerator
:
:
HasMoreElements
(
bool
*
aResult
)
{
if
(
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
!
!
mCurrentPosition
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWatcherWindowEnumerator
:
:
GetNext
(
nsISupports
*
*
aResult
)
{
if
(
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
nullptr
;
if
(
mCurrentPosition
)
{
CallQueryInterface
(
mCurrentPosition
-
>
mWindow
aResult
)
;
mCurrentPosition
=
FindNext
(
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
nsWatcherWindowEntry
*
nsWatcherWindowEnumerator
:
:
FindNext
(
)
{
nsWatcherWindowEntry
*
info
;
if
(
!
mCurrentPosition
)
{
return
nullptr
;
}
info
=
mCurrentPosition
-
>
mYounger
;
return
info
=
=
mWindowWatcher
-
>
mOldestWindow
?
nullptr
:
info
;
}
void
nsWatcherWindowEnumerator
:
:
WindowRemoved
(
nsWatcherWindowEntry
*
aInfo
)
{
if
(
mCurrentPosition
=
=
aInfo
)
{
mCurrentPosition
=
mCurrentPosition
!
=
aInfo
-
>
mYounger
?
aInfo
-
>
mYounger
:
nullptr
;
}
}
NS_IMPL_ADDREF
(
nsWindowWatcher
)
NS_IMPL_RELEASE
(
nsWindowWatcher
)
NS_IMPL_QUERY_INTERFACE
(
nsWindowWatcher
nsIWindowWatcher
nsIPromptFactory
nsPIWindowWatcher
)
nsWindowWatcher
:
:
nsWindowWatcher
(
)
:
mEnumeratorList
(
)
mOldestWindow
(
nullptr
)
mListLock
(
"
nsWindowWatcher
.
mListLock
"
)
{
}
nsWindowWatcher
:
:
~
nsWindowWatcher
(
)
{
while
(
mOldestWindow
)
{
RemoveWindow
(
mOldestWindow
)
;
}
}
nsresult
nsWindowWatcher
:
:
Init
(
)
{
return
NS_OK
;
}
static
already_AddRefed
<
nsIArray
>
ConvertArgsToArray
(
nsISupports
*
aArguments
)
{
if
(
!
aArguments
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIArray
>
array
=
do_QueryInterface
(
aArguments
)
;
if
(
array
)
{
uint32_t
argc
=
0
;
array
-
>
GetLength
(
&
argc
)
;
if
(
argc
=
=
0
)
{
return
nullptr
;
}
return
array
.
forget
(
)
;
}
nsCOMPtr
<
nsIMutableArray
>
singletonArray
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
)
;
NS_ENSURE_TRUE
(
singletonArray
nullptr
)
;
nsresult
rv
=
singletonArray
-
>
AppendElement
(
aArguments
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
singletonArray
.
forget
(
)
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
OpenWindow
(
mozIDOMWindowProxy
*
aParent
const
nsACString
&
aUrl
const
nsACString
&
aName
const
nsACString
&
aFeatures
nsISupports
*
aArguments
mozIDOMWindowProxy
*
*
aResult
)
{
nsCOMPtr
<
nsIArray
>
argv
=
ConvertArgsToArray
(
aArguments
)
;
uint32_t
argc
=
0
;
if
(
argv
)
{
argv
-
>
GetLength
(
&
argc
)
;
}
bool
dialog
=
(
argc
!
=
0
)
;
RefPtr
<
BrowsingContext
>
bc
;
MOZ_TRY
(
OpenWindowInternal
(
aParent
aUrl
aName
aFeatures
false
dialog
true
argv
false
false
false
PRINT_NONE
nullptr
getter_AddRefs
(
bc
)
)
)
;
if
(
bc
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
win
(
bc
-
>
GetDOMWindow
(
)
)
;
win
.
forget
(
aResult
)
;
}
return
NS_OK
;
}
struct
SizeSpec
{
SizeSpec
(
)
=
default
;
Maybe
<
DesktopIntCoord
>
mLeft
;
Maybe
<
DesktopIntCoord
>
mTop
;
Maybe
<
CSSIntCoord
>
mOuterWidth
;
Maybe
<
CSSIntCoord
>
mOuterHeight
;
Maybe
<
CSSIntCoord
>
mInnerWidth
;
Maybe
<
CSSIntCoord
>
mInnerHeight
;
bool
mLockAspectRatio
=
false
;
bool
PositionSpecified
(
)
const
{
return
mLeft
.
isSome
(
)
|
|
mTop
.
isSome
(
)
;
}
bool
SizeSpecified
(
)
const
{
return
WidthSpecified
(
)
|
|
HeightSpecified
(
)
;
}
bool
WidthSpecified
(
)
const
{
return
mOuterWidth
.
isSome
(
)
|
|
mInnerWidth
.
isSome
(
)
;
}
bool
HeightSpecified
(
)
const
{
return
mOuterHeight
.
isSome
(
)
|
|
mInnerHeight
.
isSome
(
)
;
}
void
ScaleBy
(
float
aOpenerZoom
)
{
if
(
aOpenerZoom
=
=
1
.
0f
)
{
return
;
}
auto
Scale
=
[
&
aOpenerZoom
]
(
auto
&
aValue
)
{
if
(
aValue
)
{
*
aValue
=
NSToIntRound
(
*
aValue
*
aOpenerZoom
)
;
}
}
;
Scale
(
mLeft
)
;
Scale
(
mTop
)
;
Scale
(
mOuterWidth
)
;
Scale
(
mOuterHeight
)
;
Scale
(
mInnerWidth
)
;
Scale
(
mInnerHeight
)
;
}
}
;
static
void
SizeOpenedWindow
(
nsIDocShellTreeOwner
*
aTreeOwner
mozIDOMWindowProxy
*
aParent
bool
aIsCallerChrome
const
SizeSpec
&
)
;
static
SizeSpec
CalcSizeSpec
(
const
WindowFeatures
&
bool
aHasChromeParent
CSSToDesktopScale
)
;
NS_IMETHODIMP
nsWindowWatcher
:
:
OpenWindow2
(
mozIDOMWindowProxy
*
aParent
const
nsACString
&
aUrl
const
nsACString
&
aName
const
nsACString
&
aFeatures
bool
aCalledFromScript
bool
aDialog
bool
aNavigate
nsISupports
*
aArguments
bool
aIsPopupSpam
bool
aForceNoOpener
bool
aForceNoReferrer
PrintKind
aPrintKind
nsDocShellLoadState
*
aLoadState
BrowsingContext
*
*
aResult
)
{
nsCOMPtr
<
nsIArray
>
argv
=
ConvertArgsToArray
(
aArguments
)
;
uint32_t
argc
=
0
;
if
(
argv
)
{
argv
-
>
GetLength
(
&
argc
)
;
}
bool
dialog
=
aDialog
;
if
(
!
aCalledFromScript
)
{
dialog
=
argc
>
0
;
}
return
OpenWindowInternal
(
aParent
aUrl
aName
aFeatures
aCalledFromScript
dialog
aNavigate
argv
aIsPopupSpam
aForceNoOpener
aForceNoReferrer
aPrintKind
aLoadState
aResult
)
;
}
static
bool
CheckUserContextCompatibility
(
nsIDocShell
*
aDocShell
)
{
MOZ_ASSERT
(
aDocShell
)
;
uint32_t
userContextId
=
static_cast
<
nsDocShell
*
>
(
aDocShell
)
-
>
GetOriginAttributes
(
)
.
mUserContextId
;
nsCOMPtr
<
nsIPrincipal
>
subjectPrincipal
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
?
nsContentUtils
:
:
SubjectPrincipal
(
)
:
nullptr
;
if
(
!
subjectPrincipal
)
{
return
true
;
}
if
(
subjectPrincipal
-
>
IsSystemPrincipal
(
)
)
{
return
true
;
}
return
subjectPrincipal
-
>
GetUserContextId
(
)
=
=
userContextId
;
}
nsresult
nsWindowWatcher
:
:
CreateChromeWindow
(
nsIWebBrowserChrome
*
aParentChrome
uint32_t
aChromeFlags
nsIOpenWindowInfo
*
aOpenWindowInfo
nsIWebBrowserChrome
*
*
aResult
)
{
if
(
NS_WARN_IF
(
!
mWindowCreator
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
bool
cancel
=
false
;
if
(
aChromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
)
{
nsCOMPtr
<
nsIDragService
>
ds
=
do_GetService
(
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
)
;
if
(
ds
)
{
ds
-
>
EndDragSession
(
true
0
)
;
}
}
nsCOMPtr
<
nsIWebBrowserChrome
>
newWindowChrome
;
nsresult
rv
=
mWindowCreator
-
>
CreateChromeWindow
(
aParentChrome
aChromeFlags
aOpenWindowInfo
&
cancel
getter_AddRefs
(
newWindowChrome
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
cancel
)
{
newWindowChrome
=
nullptr
;
return
NS_ERROR_ABORT
;
}
newWindowChrome
.
forget
(
aResult
)
;
return
NS_OK
;
}
static
void
MaybeDisablePersistence
(
const
SizeSpec
&
aSizeSpec
nsIDocShellTreeOwner
*
aTreeOwner
)
{
if
(
!
aTreeOwner
)
{
return
;
}
if
(
aSizeSpec
.
SizeSpecified
(
)
)
{
aTreeOwner
-
>
SetPersistence
(
false
false
false
)
;
}
}
NS_IMETHODIMP
nsWindowWatcher
:
:
OpenWindowWithRemoteTab
(
nsIRemoteTab
*
aRemoteTab
const
nsACString
&
aFeatures
bool
aCalledFromJS
float
aOpenerFullZoom
nsIOpenWindowInfo
*
aOpenWindowInfo
nsIRemoteTab
*
*
aResult
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
mWindowCreator
)
;
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsContentUtils
:
:
WarnScriptWasIgnored
(
nullptr
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
mWindowCreator
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
bool
isFissionWindow
=
FissionAutostart
(
)
;
bool
isPrivateBrowsingWindow
=
Preferences
:
:
GetBool
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parentWindowOuter
;
RefPtr
<
BrowsingContext
>
parentBC
=
aOpenWindowInfo
-
>
GetParent
(
)
;
if
(
parentBC
)
{
RefPtr
<
Element
>
browserElement
=
parentBC
-
>
Top
(
)
-
>
GetEmbedderElement
(
)
;
if
(
browserElement
&
&
browserElement
-
>
GetOwnerGlobal
(
)
&
&
browserElement
-
>
GetOwnerGlobal
(
)
-
>
AsInnerWindow
(
)
)
{
parentWindowOuter
=
browserElement
-
>
GetOwnerGlobal
(
)
-
>
AsInnerWindow
(
)
-
>
GetOuterWindow
(
)
;
}
isFissionWindow
=
parentBC
-
>
UseRemoteSubframes
(
)
;
isPrivateBrowsingWindow
=
isPrivateBrowsingWindow
|
|
parentBC
-
>
UsePrivateBrowsing
(
)
;
}
if
(
!
parentWindowOuter
)
{
parentWindowOuter
=
nsContentUtils
:
:
GetMostRecentNonPBWindow
(
)
;
}
if
(
NS_WARN_IF
(
!
parentWindowOuter
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
parentTreeOwner
=
parentWindowOuter
-
>
GetTreeOwner
(
)
;
if
(
NS_WARN_IF
(
!
parentTreeOwner
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
NS_WARN_IF
(
!
mWindowCreator
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
WindowFeatures
features
;
features
.
Tokenize
(
aFeatures
)
;
CSSToDesktopScale
cssToDesktopScale
(
1
.
0f
)
;
if
(
nsCOMPtr
<
nsIBaseWindow
>
win
=
do_QueryInterface
(
parentTreeOwner
)
)
{
cssToDesktopScale
=
win
-
>
GetUnscaledCSSToDesktopScale
(
)
;
}
SizeSpec
sizeSpec
=
CalcSizeSpec
(
features
false
cssToDesktopScale
)
;
sizeSpec
.
ScaleBy
(
aOpenerFullZoom
)
;
bool
unused
=
false
;
uint32_t
chromeFlags
=
CalculateChromeFlagsForContent
(
features
&
unused
)
;
if
(
isPrivateBrowsingWindow
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
;
}
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
;
if
(
isFissionWindow
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
;
}
nsCOMPtr
<
nsIWebBrowserChrome
>
parentChrome
(
do_GetInterface
(
parentTreeOwner
)
)
;
nsCOMPtr
<
nsIWebBrowserChrome
>
newWindowChrome
;
CreateChromeWindow
(
parentChrome
chromeFlags
aOpenWindowInfo
getter_AddRefs
(
newWindowChrome
)
)
;
if
(
NS_WARN_IF
(
!
newWindowChrome
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
chromeTreeItem
=
do_GetInterface
(
newWindowChrome
)
;
if
(
NS_WARN_IF
(
!
chromeTreeItem
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
chromeTreeOwner
;
chromeTreeItem
-
>
GetTreeOwner
(
getter_AddRefs
(
chromeTreeOwner
)
)
;
if
(
NS_WARN_IF
(
!
chromeTreeOwner
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsILoadContext
>
chromeContext
=
do_QueryInterface
(
chromeTreeItem
)
;
if
(
NS_WARN_IF
(
!
chromeContext
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
chromeContext
-
>
UsePrivateBrowsing
(
)
=
=
isPrivateBrowsingWindow
)
;
MOZ_ASSERT
(
chromeContext
-
>
UseRemoteSubframes
(
)
=
=
isFissionWindow
)
;
MOZ_ASSERT
(
chromeContext
-
>
UseRemoteTabs
(
)
)
;
MaybeDisablePersistence
(
sizeSpec
chromeTreeOwner
)
;
SizeOpenedWindow
(
chromeTreeOwner
parentWindowOuter
false
sizeSpec
)
;
nsCOMPtr
<
nsIRemoteTab
>
newBrowserParent
;
chromeTreeOwner
-
>
GetPrimaryRemoteTab
(
getter_AddRefs
(
newBrowserParent
)
)
;
if
(
NS_WARN_IF
(
!
newBrowserParent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
newBrowserParent
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
nsWindowWatcher
:
:
OpenWindowInternal
(
mozIDOMWindowProxy
*
aParent
const
nsACString
&
aUrl
const
nsACString
&
aName
const
nsACString
&
aFeatures
bool
aCalledFromJS
bool
aDialog
bool
aNavigate
nsIArray
*
aArgv
bool
aIsPopupSpam
bool
aForceNoOpener
bool
aForceNoReferrer
PrintKind
aPrintKind
nsDocShellLoadState
*
aLoadState
BrowsingContext
*
*
aResult
)
{
MOZ_ASSERT_IF
(
aForceNoReferrer
aForceNoOpener
)
;
nsresult
rv
=
NS_OK
;
bool
isNewToplevelWindow
=
false
;
bool
windowIsNew
=
false
;
bool
windowNeedsName
=
false
;
bool
windowIsModal
=
false
;
bool
uriToLoadIsChrome
=
false
;
uint32_t
chromeFlags
;
nsAutoString
name
;
nsCOMPtr
<
nsIURI
>
uriToLoad
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
parentTreeOwner
;
RefPtr
<
BrowsingContext
>
targetBC
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parentOuterWin
=
aParent
?
nsPIDOMWindowOuter
:
:
From
(
aParent
)
:
nullptr
;
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
nullptr
;
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsContentUtils
:
:
WarnScriptWasIgnored
(
nullptr
)
;
return
NS_ERROR_FAILURE
;
}
if
(
parentOuterWin
)
{
parentTreeOwner
=
parentOuterWin
-
>
GetTreeOwner
(
)
;
}
if
(
!
aUrl
.
IsVoid
(
)
)
{
rv
=
URIfromURL
(
aUrl
aParent
getter_AddRefs
(
uriToLoad
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uriToLoadIsChrome
=
uriToLoad
-
>
SchemeIs
(
"
chrome
"
)
;
}
bool
nameSpecified
=
false
;
if
(
!
aName
.
IsEmpty
(
)
)
{
CopyUTF8toUTF16
(
aName
name
)
;
nameSpecified
=
true
;
}
else
{
name
.
SetIsVoid
(
true
)
;
}
WindowFeatures
features
;
nsAutoCString
featuresStr
;
if
(
!
aFeatures
.
IsEmpty
(
)
)
{
featuresStr
.
Assign
(
aFeatures
)
;
features
.
Tokenize
(
featuresStr
)
;
}
else
{
featuresStr
.
SetIsVoid
(
true
)
;
}
RefPtr
<
BrowsingContext
>
parentBC
(
parentOuterWin
?
parentOuterWin
-
>
GetBrowsingContext
(
)
:
nullptr
)
;
nsCOMPtr
<
nsIDocShell
>
parentDocShell
(
parentBC
?
parentBC
-
>
GetDocShell
(
)
:
nullptr
)
;
RefPtr
<
Document
>
parentDoc
(
parentOuterWin
?
parentOuterWin
-
>
GetDoc
(
)
:
nullptr
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
parentInnerWin
(
parentOuterWin
?
parentOuterWin
-
>
GetCurrentInnerWindow
(
)
:
nullptr
)
;
if
(
parentBC
&
&
parentBC
-
>
IsDiscarded
(
)
)
{
return
NS_ERROR_ABORT
;
}
targetBC
=
GetBrowsingContextByName
(
name
aForceNoOpener
parentBC
)
;
if
(
parentBC
&
&
parentBC
-
>
IsSandboxedFrom
(
targetBC
)
)
{
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
if
(
targetBC
&
&
NS_WARN_IF
(
targetBC
-
>
GetPendingInitialization
(
)
)
)
{
return
NS_ERROR_ABORT
;
}
bool
hasChromeParent
=
!
XRE_IsContentProcess
(
)
;
if
(
aParent
)
{
hasChromeParent
=
parentDoc
&
&
nsContentUtils
:
:
IsChromeDoc
(
parentDoc
)
;
}
bool
isCallerChrome
=
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
;
CSSToDesktopScale
cssToDesktopScale
(
1
.
0
)
;
if
(
nsCOMPtr
<
nsIBaseWindow
>
win
=
do_QueryInterface
(
parentDocShell
)
)
{
cssToDesktopScale
=
win
-
>
GetUnscaledCSSToDesktopScale
(
)
;
}
SizeSpec
sizeSpec
=
CalcSizeSpec
(
features
hasChromeParent
cssToDesktopScale
)
;
sizeSpec
.
ScaleBy
(
parentBC
?
parentBC
-
>
FullZoom
(
)
:
1
.
0f
)
;
bool
isPopupRequested
=
false
;
if
(
hasChromeParent
&
&
isCallerChrome
&
&
XRE_IsParentProcess
(
)
)
{
chromeFlags
=
CalculateChromeFlagsForSystem
(
features
aDialog
uriToLoadIsChrome
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
parentBC
&
&
parentBC
-
>
IsContent
(
)
"
content
caller
must
provide
content
parent
"
)
;
chromeFlags
=
CalculateChromeFlagsForContent
(
features
&
isPopupRequested
)
;
if
(
aDialog
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
;
}
}
bool
windowTypeIsChrome
=
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
if
(
parentBC
&
&
!
aForceNoOpener
)
{
if
(
parentBC
-
>
IsChrome
(
)
&
&
!
windowTypeIsChrome
)
{
NS_WARNING
(
"
Content
windows
may
never
have
chrome
windows
as
their
openers
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
parentBC
-
>
IsContent
(
)
&
&
windowTypeIsChrome
)
{
NS_WARNING
(
"
Chrome
windows
may
never
have
content
windows
as
their
openers
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
if
(
parentBC
&
&
parentBC
-
>
IsContent
(
)
&
&
!
windowTypeIsChrome
)
{
chromeFlags
&
=
~
(
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
)
;
if
(
parentBC
-
>
UseRemoteTabs
(
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
;
}
if
(
parentBC
-
>
UseRemoteSubframes
(
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
;
}
}
dom
:
:
AutoJSAPI
jsapiChromeGuard
;
if
(
isCallerChrome
&
&
!
hasChromeParent
&
&
!
windowTypeIsChrome
)
{
nsCOMPtr
<
nsIGlobalObject
>
parentGlobalObject
=
do_QueryInterface
(
aParent
)
;
if
(
!
aParent
)
{
jsapiChromeGuard
.
Init
(
)
;
}
else
if
(
NS_WARN_IF
(
!
jsapiChromeGuard
.
Init
(
parentGlobalObject
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
}
JSContext
*
cx
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
;
nsCOMPtr
<
nsIPrincipal
>
subjectPrincipal
=
cx
?
nsContentUtils
:
:
SubjectPrincipal
(
)
:
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
MOZ_ASSERT
(
subjectPrincipal
)
;
nsCOMPtr
<
nsIPrincipal
>
newWindowPrincipal
;
if
(
!
targetBC
)
{
if
(
windowTypeIsChrome
)
{
MOZ_RELEASE_ASSERT
(
subjectPrincipal
-
>
IsSystemPrincipal
(
)
"
Only
system
principals
can
create
chrome
windows
"
)
;
newWindowPrincipal
=
subjectPrincipal
;
}
else
if
(
nsContentUtils
:
:
IsSystemOrExpandedPrincipal
(
subjectPrincipal
)
)
{
if
(
parentBC
)
{
newWindowPrincipal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
parentBC
-
>
OriginAttributesRef
(
)
)
;
}
else
{
newWindowPrincipal
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
}
}
else
if
(
aForceNoOpener
)
{
newWindowPrincipal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
subjectPrincipal
)
;
}
else
{
newWindowPrincipal
=
subjectPrincipal
;
}
}
RefPtr
<
nsOpenWindowInfo
>
openWindowInfo
;
if
(
!
targetBC
&
&
!
windowTypeIsChrome
)
{
openWindowInfo
=
new
nsOpenWindowInfo
(
)
;
openWindowInfo
-
>
mForceNoOpener
=
aForceNoOpener
;
openWindowInfo
-
>
mParent
=
parentBC
;
openWindowInfo
-
>
mIsForPrinting
=
aPrintKind
!
=
PRINT_NONE
;
openWindowInfo
-
>
mIsForWindowDotPrint
=
aPrintKind
=
=
PRINT_WINDOW_DOT_PRINT
;
openWindowInfo
-
>
mIsRemote
=
XRE_IsContentProcess
(
)
;
MOZ_ASSERT
(
newWindowPrincipal
&
&
!
nsContentUtils
:
:
IsSystemOrExpandedPrincipal
(
newWindowPrincipal
)
)
;
openWindowInfo
-
>
mOriginAttributes
=
newWindowPrincipal
-
>
OriginAttributesRef
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
parentBC
|
|
openWindowInfo
-
>
mOriginAttributes
.
EqualsIgnoringFPD
(
parentBC
-
>
OriginAttributesRef
(
)
)
"
subject
principal
origin
attributes
doesn
'
t
match
opener
"
)
;
}
uint32_t
activeDocsSandboxFlags
=
0
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
cspToInheritForAboutBlank
;
Maybe
<
nsILoadInfo
:
:
CrossOriginEmbedderPolicy
>
coepToInheritForAboutBlank
;
if
(
!
targetBC
)
{
windowNeedsName
=
true
;
if
(
parentDoc
)
{
activeDocsSandboxFlags
=
parentDoc
-
>
GetSandboxFlags
(
)
;
if
(
!
aForceNoOpener
)
{
cspToInheritForAboutBlank
=
parentDoc
-
>
GetCsp
(
)
;
coepToInheritForAboutBlank
=
parentDoc
-
>
GetEmbedderPolicy
(
)
;
}
if
(
aPrintKind
=
=
PRINT_NONE
&
&
(
activeDocsSandboxFlags
&
SANDBOXED_AUXILIARY_NAVIGATION
)
)
{
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
}
if
(
parentTreeOwner
&
&
!
aDialog
&
&
parentBC
-
>
IsContent
(
)
&
&
!
(
chromeFlags
&
(
nsIWebBrowserChrome
:
:
CHROME_MODAL
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
)
)
)
{
MOZ_ASSERT
(
openWindowInfo
)
;
nsCOMPtr
<
nsIWindowProvider
>
provider
=
do_GetInterface
(
parentTreeOwner
)
;
if
(
provider
)
{
rv
=
provider
-
>
ProvideWindow
(
openWindowInfo
chromeFlags
aCalledFromJS
uriToLoad
name
featuresStr
aForceNoOpener
aForceNoReferrer
isPopupRequested
aLoadState
&
windowIsNew
getter_AddRefs
(
targetBC
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
targetBC
)
{
nsCOMPtr
<
nsIDocShell
>
newDocShell
=
targetBC
-
>
GetDocShell
(
)
;
if
(
!
windowIsNew
&
&
newDocShell
)
{
if
(
!
CheckUserContextCompatibility
(
newDocShell
)
)
{
targetBC
=
nullptr
;
windowIsNew
=
false
;
}
}
}
else
if
(
rv
=
=
NS_ERROR_ABORT
)
{
return
NS_OK
;
}
}
}
}
bool
newWindowShouldBeModal
=
false
;
bool
parentIsModal
=
false
;
if
(
!
targetBC
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
NS_OK
;
}
windowIsNew
=
true
;
isNewToplevelWindow
=
true
;
nsCOMPtr
<
nsIWebBrowserChrome
>
parentChrome
(
do_GetInterface
(
parentTreeOwner
)
)
;
bool
weAreModal
=
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_MODAL
)
!
=
0
;
newWindowShouldBeModal
=
weAreModal
;
if
(
!
weAreModal
&
&
parentChrome
)
{
parentChrome
-
>
IsWindowModal
(
&
weAreModal
)
;
parentIsModal
=
weAreModal
;
}
if
(
weAreModal
)
{
windowIsModal
=
true
;
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_MODAL
|
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
;
}
if
(
!
hasChromeParent
&
&
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_MODAL
)
)
{
nsCOMPtr
<
nsIBaseWindow
>
parentWindow
(
do_GetInterface
(
parentTreeOwner
)
)
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
if
(
parentWindow
)
{
parentWindow
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
}
if
(
parentWidget
&
&
!
parentWidget
-
>
IsVisible
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
NS_ASSERTION
(
mWindowCreator
"
attempted
to
open
a
new
window
with
no
WindowCreator
"
)
;
rv
=
NS_ERROR_FAILURE
;
if
(
mWindowCreator
)
{
nsCOMPtr
<
nsIWebBrowserChrome
>
newChrome
;
nsCOMPtr
<
nsPIDOMWindowInner
>
parentTopInnerWindow
;
if
(
parentOuterWin
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
parentTopWindow
=
parentOuterWin
-
>
GetInProcessTop
(
)
;
if
(
parentTopWindow
)
{
parentTopInnerWindow
=
parentTopWindow
-
>
GetCurrentInnerWindow
(
)
;
}
}
if
(
parentTopInnerWindow
)
{
parentTopInnerWindow
-
>
Suspend
(
)
;
}
rv
=
CreateChromeWindow
(
parentChrome
chromeFlags
openWindowInfo
getter_AddRefs
(
newChrome
)
)
;
if
(
parentTopInnerWindow
)
{
parentTopInnerWindow
-
>
Resume
(
)
;
}
if
(
newChrome
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
newWindow
(
do_GetInterface
(
newChrome
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
newDocShellItem
;
if
(
newWindow
)
{
newDocShellItem
=
newWindow
-
>
GetDocShell
(
)
;
}
if
(
!
newDocShellItem
)
{
newDocShellItem
=
do_GetInterface
(
newChrome
)
;
}
if
(
!
newDocShellItem
)
{
rv
=
NS_ERROR_FAILURE
;
}
targetBC
=
newDocShellItem
-
>
GetBrowsingContext
(
)
;
}
}
}
if
(
!
targetBC
)
{
return
rv
;
}
if
(
activeDocsSandboxFlags
&
&
parentBC
)
{
MOZ_ALWAYS_SUCCEEDS
(
targetBC
-
>
SetOnePermittedSandboxedNavigator
(
parentBC
)
)
;
}
if
(
!
aForceNoOpener
&
&
parentBC
)
{
if
(
windowIsNew
&
&
targetBC
-
>
IsContent
(
)
)
{
if
(
parentBC
-
>
IsDiscarded
(
)
)
{
MOZ_RELEASE_ASSERT
(
targetBC
-
>
GetOpenerId
(
)
=
=
parentBC
-
>
Id
(
)
|
|
targetBC
-
>
GetOpenerId
(
)
=
=
0
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
targetBC
-
>
GetOpenerId
(
)
=
=
parentBC
-
>
Id
(
)
)
;
MOZ_RELEASE_ASSERT
(
targetBC
-
>
HadOriginalOpener
(
)
)
;
}
}
else
{
targetBC
-
>
SetOpener
(
parentBC
)
;
}
}
RefPtr
<
nsDocShell
>
targetDocShell
(
nsDocShell
:
:
Cast
(
targetBC
-
>
GetDocShell
(
)
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
windowIsNew
|
|
targetDocShell
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
isNewToplevelWindow
|
|
targetDocShell
)
;
if
(
activeDocsSandboxFlags
&
SANDBOX_PROPAGATES_TO_AUXILIARY_BROWSING_CONTEXTS
)
{
MOZ_ASSERT
(
windowIsNew
"
Should
only
get
here
for
new
windows
"
)
;
MOZ_ALWAYS_SUCCEEDS
(
targetBC
-
>
SetSandboxFlags
(
activeDocsSandboxFlags
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
targetBC
-
>
SetInitialSandboxFlags
(
targetBC
-
>
GetSandboxFlags
(
)
)
)
;
}
RefPtr
<
nsGlobalWindowOuter
>
targetOuterWin
(
nsGlobalWindowOuter
:
:
Cast
(
targetBC
-
>
GetDOMWindow
(
)
)
)
;
#
ifdef
DEBUG
if
(
targetOuterWin
&
&
windowIsNew
)
{
nsCOMPtr
<
nsIChannel
>
chan
;
targetDocShell
-
>
GetDocumentChannel
(
getter_AddRefs
(
chan
)
)
;
MOZ_ASSERT
(
!
chan
"
Why
is
there
a
document
channel
?
"
)
;
if
(
RefPtr
<
Document
>
doc
=
targetOuterWin
-
>
GetExtantDoc
(
)
)
{
MOZ_ASSERT
(
doc
-
>
IsInitialDocument
(
)
"
New
window
'
s
document
should
be
an
initial
document
"
)
;
}
}
#
endif
MOZ_ASSERT
(
targetOuterWin
|
|
!
windowIsNew
"
New
windows
are
always
created
in
-
process
"
)
;
*
aResult
=
do_AddRef
(
targetBC
)
.
take
(
)
;
if
(
isNewToplevelWindow
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
newTreeOwner
;
targetDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
newTreeOwner
)
)
;
MaybeDisablePersistence
(
sizeSpec
newTreeOwner
)
;
}
if
(
aDialog
&
&
aArgv
)
{
MOZ_ASSERT
(
targetOuterWin
)
;
NS_ENSURE_TRUE
(
targetOuterWin
NS_ERROR_UNEXPECTED
)
;
MOZ_TRY
(
targetOuterWin
-
>
SetArguments
(
aArgv
)
)
;
}
if
(
windowNeedsName
)
{
if
(
nameSpecified
&
&
!
name
.
LowerCaseEqualsLiteral
(
"
_blank
"
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
targetBC
-
>
SetName
(
name
)
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
targetBC
-
>
SetName
(
u
"
"
_ns
)
)
;
}
}
if
(
windowIsNew
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
targetBC
-
>
IsContent
(
)
|
|
newWindowPrincipal
-
>
OriginAttributesRef
(
)
.
EqualsIgnoringFPD
(
targetBC
-
>
OriginAttributesRef
(
)
)
)
;
bool
autoPrivateBrowsing
=
Preferences
:
:
GetBool
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
if
(
!
autoPrivateBrowsing
&
&
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_NON_PRIVATE_WINDOW
)
)
{
if
(
targetBC
-
>
IsChrome
(
)
)
{
targetBC
-
>
SetUsePrivateBrowsing
(
false
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
targetBC
-
>
UsePrivateBrowsing
(
)
"
CHROME_NON_PRIVATE_WINDOW
passed
but
got
private
window
"
)
;
}
else
if
(
autoPrivateBrowsing
|
|
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
)
)
{
if
(
targetBC
-
>
IsChrome
(
)
)
{
targetBC
-
>
SetUsePrivateBrowsing
(
true
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
targetBC
-
>
UsePrivateBrowsing
(
)
"
CHROME_PRIVATE_WINDOW
passed
but
got
non
-
private
window
"
)
;
}
NS_ASSERTION
(
targetOuterWin
=
=
targetDocShell
-
>
GetWindow
(
)
"
Different
windows
?
?
"
)
;
if
(
targetOuterWin
)
{
MOZ_ASSERT
(
windowIsNew
)
;
MOZ_ASSERT
(
!
targetOuterWin
-
>
GetSameProcessOpener
(
)
|
|
targetOuterWin
-
>
GetSameProcessOpener
(
)
=
=
aParent
)
;
targetOuterWin
-
>
SetInitialPrincipal
(
newWindowPrincipal
cspToInheritForAboutBlank
coepToInheritForAboutBlank
)
;
if
(
aIsPopupSpam
)
{
MOZ_ASSERT
(
!
targetBC
-
>
GetIsPopupSpam
(
)
"
Who
marked
it
as
popup
spam
already
?
?
?
"
)
;
if
(
!
targetBC
-
>
GetIsPopupSpam
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
targetBC
-
>
SetIsPopupSpam
(
true
)
)
;
}
}
}
if
(
!
aForceNoOpener
&
&
subjectPrincipal
&
&
parentDocShell
&
&
targetDocShell
)
{
const
RefPtr
<
SessionStorageManager
>
parentStorageManager
=
parentDocShell
-
>
GetBrowsingContext
(
)
-
>
GetSessionStorageManager
(
)
;
const
RefPtr
<
SessionStorageManager
>
newStorageManager
=
targetDocShell
-
>
GetBrowsingContext
(
)
-
>
GetSessionStorageManager
(
)
;
if
(
parentStorageManager
&
&
newStorageManager
)
{
RefPtr
<
Storage
>
storage
;
parentStorageManager
-
>
GetStorage
(
parentInnerWin
subjectPrincipal
subjectPrincipal
targetBC
-
>
UsePrivateBrowsing
(
)
getter_AddRefs
(
storage
)
)
;
if
(
storage
)
{
newStorageManager
-
>
CloneStorage
(
storage
)
;
}
}
}
}
MOZ_DIAGNOSTIC_ASSERT
(
targetBC
-
>
UseRemoteTabs
(
)
=
=
!
!
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
targetBC
-
>
UseRemoteSubframes
(
)
=
=
!
!
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
)
)
;
RefPtr
<
nsDocShellLoadState
>
loadState
=
aLoadState
;
if
(
uriToLoad
&
&
loadState
)
{
loadState
-
>
SetURI
(
uriToLoad
)
;
}
else
if
(
uriToLoad
&
&
aNavigate
&
&
!
loadState
)
{
RefPtr
<
WindowContext
>
context
=
parentInnerWin
?
parentInnerWin
-
>
GetWindowContext
(
)
:
nullptr
;
loadState
=
new
nsDocShellLoadState
(
uriToLoad
)
;
loadState
-
>
SetSourceBrowsingContext
(
parentBC
)
;
loadState
-
>
SetAllowFocusMove
(
true
)
;
loadState
-
>
SetHasValidUserGestureActivation
(
context
&
&
context
-
>
HasValidTransientUserGestureActivation
(
)
)
;
if
(
parentBC
)
{
loadState
-
>
SetTriggeringSandboxFlags
(
parentBC
-
>
GetSandboxFlags
(
)
)
;
}
if
(
subjectPrincipal
)
{
loadState
-
>
SetTriggeringPrincipal
(
subjectPrincipal
)
;
}
#
ifndef
ANDROID
MOZ_ASSERT
(
subjectPrincipal
"
nsWindowWatcher
:
triggeringPrincipal
required
"
)
;
#
endif
if
(
!
aForceNoReferrer
)
{
RefPtr
<
Document
>
doc
=
GetEntryDocument
(
)
;
if
(
!
doc
)
{
doc
=
parentDoc
;
}
if
(
doc
)
{
auto
referrerInfo
=
MakeRefPtr
<
ReferrerInfo
>
(
*
doc
)
;
loadState
-
>
SetReferrerInfo
(
referrerInfo
)
;
}
}
}
if
(
loadState
&
&
cx
)
{
nsGlobalWindowInner
*
win
=
xpc
:
:
CurrentWindowOrNull
(
cx
)
;
if
(
win
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
win
-
>
GetCsp
(
)
;
loadState
-
>
SetCsp
(
csp
)
;
}
}
if
(
isNewToplevelWindow
)
{
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
NotifyObservers
(
ToSupports
(
targetOuterWin
)
"
toplevel
-
window
-
ready
"
nullptr
)
;
}
}
MOZ_ASSERT_IF
(
targetDocShell
CheckUserContextCompatibility
(
targetDocShell
)
)
;
if
(
parentDocShell
&
&
windowIsNew
)
{
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
RefPtr
<
nsHashPropertyBag
>
props
=
new
nsHashPropertyBag
(
)
;
if
(
uriToLoad
)
{
props
-
>
SetPropertyAsACString
(
u
"
url
"
_ns
uriToLoad
-
>
GetSpecOrDefault
(
)
)
;
}
props
-
>
SetPropertyAsInterface
(
u
"
sourceTabDocShell
"
_ns
parentDocShell
)
;
props
-
>
SetPropertyAsInterface
(
u
"
createdTabDocShell
"
_ns
ToSupports
(
targetDocShell
)
)
;
obsSvc
-
>
NotifyObservers
(
static_cast
<
nsIPropertyBag2
*
>
(
props
)
"
webNavigation
-
createdNavigationTarget
-
from
-
js
"
nullptr
)
;
}
}
if
(
uriToLoad
&
&
aNavigate
)
{
uint32_t
loadFlags
=
nsIWebNavigation
:
:
LOAD_FLAGS_NONE
;
if
(
windowIsNew
)
{
loadFlags
|
=
nsIWebNavigation
:
:
LOAD_FLAGS_FIRST_LOAD
;
if
(
aForceNoOpener
)
{
loadFlags
|
=
nsIWebNavigation
:
:
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
;
}
}
loadState
-
>
SetLoadFlags
(
loadFlags
)
;
loadState
-
>
SetFirstParty
(
true
)
;
targetBC
-
>
LoadURI
(
loadState
)
;
}
if
(
isNewToplevelWindow
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
newTreeOwner
;
targetDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
newTreeOwner
)
)
;
SizeOpenedWindow
(
newTreeOwner
aParent
isCallerChrome
sizeSpec
)
;
}
if
(
windowIsModal
)
{
NS_ENSURE_TRUE
(
targetDocShell
NS_ERROR_NOT_IMPLEMENTED
)
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
newTreeOwner
;
targetDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
newTreeOwner
)
)
;
nsCOMPtr
<
nsIWebBrowserChrome
>
newChrome
(
do_GetInterface
(
newTreeOwner
)
)
;
NS_ENSURE_TRUE
(
newChrome
NS_ERROR_NOT_AVAILABLE
)
;
nsAutoWindowStateHelper
windowStateHelper
(
parentOuterWin
)
;
if
(
!
windowStateHelper
.
DefaultEnabled
(
)
)
{
NS_RELEASE
(
*
aResult
)
;
return
NS_OK
;
}
bool
isAppModal
=
false
;
nsCOMPtr
<
nsIBaseWindow
>
parentWindow
(
do_GetInterface
(
newTreeOwner
)
)
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
if
(
parentWindow
)
{
parentWindow
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
if
(
parentWidget
)
{
isAppModal
=
parentWidget
-
>
IsRunningAppModal
(
)
;
}
}
if
(
parentWidget
&
&
(
(
!
newWindowShouldBeModal
&
&
parentIsModal
)
|
|
isAppModal
)
)
{
parentWidget
-
>
SetFakeModal
(
true
)
;
}
else
{
AutoPopupStatePusher
popupStatePusher
(
PopupBlocker
:
:
openAbused
)
;
newChrome
-
>
ShowAsModal
(
)
;
}
}
if
(
StaticPrefs
:
:
full_screen_api_exit_on_windowOpen
(
)
&
&
aCalledFromJS
&
&
!
hasChromeParent
&
&
!
isCallerChrome
&
&
parentOuterWin
)
{
Document
:
:
AsyncExitFullscreen
(
parentOuterWin
-
>
GetDoc
(
)
)
;
}
if
(
aForceNoOpener
&
&
windowIsNew
)
{
NS_RELEASE
(
*
aResult
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
RegisterNotification
(
nsIObserver
*
aObserver
)
{
if
(
!
aObserver
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
os
-
>
AddObserver
(
aObserver
"
domwindowopened
"
false
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
os
-
>
AddObserver
(
aObserver
"
domwindowclosed
"
false
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
UnregisterNotification
(
nsIObserver
*
aObserver
)
{
if
(
!
aObserver
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
NS_ERROR_FAILURE
;
}
os
-
>
RemoveObserver
(
aObserver
"
domwindowopened
"
)
;
os
-
>
RemoveObserver
(
aObserver
"
domwindowclosed
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetWindowEnumerator
(
nsISimpleEnumerator
*
*
aResult
)
{
if
(
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
MutexAutoLock
lock
(
mListLock
)
;
RefPtr
<
nsWatcherWindowEnumerator
>
enumerator
=
new
nsWatcherWindowEnumerator
(
this
)
;
enumerator
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetNewPrompter
(
mozIDOMWindowProxy
*
aParent
nsIPrompt
*
*
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
factory
=
do_GetService
(
"
mozilla
.
org
/
prompter
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
factory
-
>
GetPrompt
(
aParent
NS_GET_IID
(
nsIPrompt
)
reinterpret_cast
<
void
*
*
>
(
aResult
)
)
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetNewAuthPrompter
(
mozIDOMWindowProxy
*
aParent
nsIAuthPrompt
*
*
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
factory
=
do_GetService
(
"
mozilla
.
org
/
prompter
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
factory
-
>
GetPrompt
(
aParent
NS_GET_IID
(
nsIAuthPrompt
)
reinterpret_cast
<
void
*
*
>
(
aResult
)
)
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetPrompt
(
mozIDOMWindowProxy
*
aParent
const
nsIID
&
aIID
void
*
*
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
factory
=
do_GetService
(
"
mozilla
.
org
/
prompter
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
factory
-
>
GetPrompt
(
aParent
aIID
aResult
)
;
if
(
rv
=
=
NS_NOINTERFACE
&
&
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPrompt2
)
)
)
{
nsCOMPtr
<
nsIAuthPrompt
>
oldPrompt
;
rv
=
factory
-
>
GetPrompt
(
aParent
NS_GET_IID
(
nsIAuthPrompt
)
getter_AddRefs
(
oldPrompt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_WrapAuthPrompt
(
oldPrompt
reinterpret_cast
<
nsIAuthPrompt2
*
*
>
(
aResult
)
)
;
if
(
!
*
aResult
)
{
rv
=
NS_ERROR_NOT_AVAILABLE
;
}
}
return
rv
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
SetWindowCreator
(
nsIWindowCreator
*
aCreator
)
{
mWindowCreator
=
aCreator
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
HasWindowCreator
(
bool
*
aResult
)
{
*
aResult
=
mWindowCreator
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetActiveWindow
(
mozIDOMWindowProxy
*
*
aActiveWindow
)
{
*
aActiveWindow
=
nullptr
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
return
fm
-
>
GetActiveWindow
(
aActiveWindow
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
AddWindow
(
mozIDOMWindowProxy
*
aWindow
nsIWebBrowserChrome
*
aChrome
)
{
if
(
!
aWindow
)
{
return
NS_ERROR_INVALID_ARG
;
}
{
nsWatcherWindowEntry
*
info
;
MutexAutoLock
lock
(
mListLock
)
;
info
=
FindWindowEntry
(
aWindow
)
;
if
(
info
)
{
nsCOMPtr
<
nsISupportsWeakReference
>
supportsweak
(
do_QueryInterface
(
aChrome
)
)
;
if
(
supportsweak
)
{
supportsweak
-
>
GetWeakReference
(
getter_AddRefs
(
info
-
>
mChromeWeak
)
)
;
}
else
{
info
-
>
mChrome
=
aChrome
;
info
-
>
mChromeWeak
=
nullptr
;
}
return
NS_OK
;
}
info
=
new
nsWatcherWindowEntry
(
aWindow
aChrome
)
;
if
(
!
info
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
mOldestWindow
)
{
info
-
>
InsertAfter
(
mOldestWindow
-
>
mOlder
)
;
}
else
{
mOldestWindow
=
info
;
}
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISupports
>
domwin
(
do_QueryInterface
(
aWindow
)
)
;
return
os
-
>
NotifyObservers
(
domwin
"
domwindowopened
"
nullptr
)
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
RemoveWindow
(
mozIDOMWindowProxy
*
aWindow
)
{
if
(
!
aWindow
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsWatcherWindowEntry
*
info
=
FindWindowEntry
(
aWindow
)
;
if
(
info
)
{
RemoveWindow
(
info
)
;
return
NS_OK
;
}
NS_WARNING
(
"
requested
removal
of
nonexistent
window
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
nsWatcherWindowEntry
*
nsWindowWatcher
:
:
FindWindowEntry
(
mozIDOMWindowProxy
*
aWindow
)
{
nsWatcherWindowEntry
*
info
;
nsWatcherWindowEntry
*
listEnd
;
info
=
mOldestWindow
;
listEnd
=
nullptr
;
while
(
info
!
=
listEnd
)
{
if
(
info
-
>
mWindow
=
=
aWindow
)
{
return
info
;
}
info
=
info
-
>
mYounger
;
listEnd
=
mOldestWindow
;
}
return
nullptr
;
}
nsresult
nsWindowWatcher
:
:
RemoveWindow
(
nsWatcherWindowEntry
*
aInfo
)
{
uint32_t
count
=
mEnumeratorList
.
Length
(
)
;
{
MutexAutoLock
lock
(
mListLock
)
;
for
(
uint32_t
ctr
=
0
;
ctr
<
count
;
+
+
ctr
)
{
mEnumeratorList
[
ctr
]
-
>
WindowRemoved
(
aInfo
)
;
}
if
(
aInfo
=
=
mOldestWindow
)
{
mOldestWindow
=
aInfo
-
>
mYounger
=
=
mOldestWindow
?
nullptr
:
aInfo
-
>
mYounger
;
}
aInfo
-
>
Unlink
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
nsCOMPtr
<
nsISupports
>
domwin
(
do_QueryInterface
(
aInfo
-
>
mWindow
)
)
;
os
-
>
NotifyObservers
(
domwin
"
domwindowclosed
"
nullptr
)
;
}
delete
aInfo
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetChromeForWindow
(
mozIDOMWindowProxy
*
aWindow
nsIWebBrowserChrome
*
*
aResult
)
{
if
(
!
aWindow
|
|
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
nullptr
;
MutexAutoLock
lock
(
mListLock
)
;
nsWatcherWindowEntry
*
info
=
FindWindowEntry
(
aWindow
)
;
if
(
info
)
{
if
(
info
-
>
mChromeWeak
)
{
return
info
-
>
mChromeWeak
-
>
QueryReferent
(
NS_GET_IID
(
nsIWebBrowserChrome
)
reinterpret_cast
<
void
*
*
>
(
aResult
)
)
;
}
*
aResult
=
info
-
>
mChrome
;
NS_IF_ADDREF
(
*
aResult
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowWatcher
:
:
GetWindowByName
(
const
nsAString
&
aTargetName
mozIDOMWindowProxy
*
aCurrentWindow
mozIDOMWindowProxy
*
*
aResult
)
{
if
(
!
aResult
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
nullptr
;
BrowsingContext
*
currentContext
=
aCurrentWindow
?
nsPIDOMWindowOuter
:
:
From
(
aCurrentWindow
)
-
>
GetBrowsingContext
(
)
:
nullptr
;
RefPtr
<
BrowsingContext
>
context
=
GetBrowsingContextByName
(
aTargetName
false
currentContext
)
;
if
(
context
)
{
*
aResult
=
do_AddRef
(
context
-
>
GetDOMWindow
(
)
)
.
take
(
)
;
MOZ_ASSERT
(
*
aResult
)
;
}
return
NS_OK
;
}
bool
nsWindowWatcher
:
:
AddEnumerator
(
nsWatcherWindowEnumerator
*
aEnumerator
)
{
mEnumeratorList
.
AppendElement
(
aEnumerator
)
;
return
true
;
}
bool
nsWindowWatcher
:
:
RemoveEnumerator
(
nsWatcherWindowEnumerator
*
aEnumerator
)
{
return
mEnumeratorList
.
RemoveElement
(
aEnumerator
)
;
}
nsresult
nsWindowWatcher
:
:
URIfromURL
(
const
nsACString
&
aURL
mozIDOMWindowProxy
*
aParent
nsIURI
*
*
aURI
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
baseWindow
=
do_QueryInterface
(
GetEntryGlobal
(
)
)
;
if
(
!
baseWindow
&
&
aParent
)
{
baseWindow
=
nsPIDOMWindowOuter
:
:
From
(
aParent
)
-
>
GetCurrentInnerWindow
(
)
;
}
nsIURI
*
baseURI
=
nullptr
;
if
(
baseWindow
)
{
if
(
Document
*
doc
=
baseWindow
-
>
GetDoc
(
)
)
{
baseURI
=
doc
-
>
GetDocBaseURI
(
)
;
}
}
return
NS_NewURI
(
aURI
aURL
nullptr
baseURI
)
;
}
uint32_t
nsWindowWatcher
:
:
CalculateChromeFlagsHelper
(
uint32_t
aInitialFlags
const
WindowFeatures
&
aFeatures
bool
*
presenceFlag
)
{
uint32_t
chromeFlags
=
aInitialFlags
;
if
(
aFeatures
.
GetBoolWithDefault
(
"
titlebar
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_TITLEBAR
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
close
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_CLOSE
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
toolbar
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_TOOLBAR
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
location
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_LOCATIONBAR
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
personalbar
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_PERSONAL_TOOLBAR
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
status
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_STATUSBAR
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
menubar
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_MENUBAR
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
resizable
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RESIZE
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
minimizable
"
false
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_MIN
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
scrollbars
"
true
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_SCROLLBARS
;
}
return
chromeFlags
;
}
bool
nsWindowWatcher
:
:
ShouldOpenPopup
(
const
WindowFeatures
&
aFeatures
)
{
if
(
aFeatures
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
aFeatures
.
Exists
(
"
popup
"
)
)
{
return
aFeatures
.
GetBool
(
"
popup
"
)
;
}
if
(
!
aFeatures
.
GetBoolWithDefault
(
"
location
"
false
)
&
&
!
aFeatures
.
GetBoolWithDefault
(
"
toolbar
"
false
)
)
{
return
true
;
}
if
(
!
aFeatures
.
GetBoolWithDefault
(
"
menubar
"
false
)
)
{
return
true
;
}
if
(
!
aFeatures
.
GetBoolWithDefault
(
"
resizable
"
true
)
)
{
return
true
;
}
if
(
!
aFeatures
.
GetBoolWithDefault
(
"
scrollbars
"
false
)
)
{
return
true
;
}
if
(
!
aFeatures
.
GetBoolWithDefault
(
"
status
"
false
)
)
{
return
true
;
}
return
false
;
}
uint32_t
nsWindowWatcher
:
:
CalculateChromeFlagsForContent
(
const
WindowFeatures
&
aFeatures
bool
*
aIsPopupRequested
)
{
if
(
aFeatures
.
IsEmpty
(
)
|
|
!
ShouldOpenPopup
(
aFeatures
)
)
{
return
nsIWebBrowserChrome
:
:
CHROME_ALL
;
}
*
aIsPopupRequested
=
true
;
return
nsIWebBrowserChrome
:
:
CHROME_MINIMAL_POPUP
;
}
uint32_t
nsWindowWatcher
:
:
CalculateChromeFlagsForSystem
(
const
WindowFeatures
&
aFeatures
bool
aDialog
bool
aChromeURL
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
)
;
uint32_t
chromeFlags
=
0
;
if
(
aFeatures
.
IsEmpty
(
)
)
{
chromeFlags
=
nsIWebBrowserChrome
:
:
CHROME_ALL
;
if
(
aDialog
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
|
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
}
}
else
{
chromeFlags
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_BORDERS
;
}
bool
presenceFlag
=
false
;
if
(
aDialog
&
&
aFeatures
.
GetBoolWithDefault
(
"
all
"
false
&
presenceFlag
)
)
{
chromeFlags
=
nsIWebBrowserChrome
:
:
CHROME_ALL
;
}
chromeFlags
=
CalculateChromeFlagsHelper
(
chromeFlags
aFeatures
&
presenceFlag
)
;
if
(
aFeatures
.
GetBoolWithDefault
(
"
private
"
false
&
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
non
-
private
"
false
&
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_NON_PRIVATE_WINDOW
;
}
bool
remote
=
BrowserTabsRemoteAutostart
(
)
;
if
(
remote
)
{
remote
=
!
aFeatures
.
GetBoolWithDefault
(
"
non
-
remote
"
false
&
presenceFlag
)
;
}
else
{
remote
=
aFeatures
.
GetBoolWithDefault
(
"
remote
"
false
&
presenceFlag
)
;
}
if
(
remote
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
;
}
bool
fission
=
FissionAutostart
(
)
;
if
(
fission
)
{
fission
=
!
aFeatures
.
GetBoolWithDefault
(
"
non
-
fission
"
false
&
presenceFlag
)
;
}
else
{
fission
=
aFeatures
.
GetBoolWithDefault
(
"
fission
"
false
&
presenceFlag
)
;
}
if
(
fission
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
popup
"
false
&
presenceFlag
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_POPUP
;
}
if
(
!
(
chromeFlags
&
nsIWebBrowserChrome
:
:
CHROME_WINDOW_POPUP
)
)
{
if
(
!
aFeatures
.
Exists
(
"
titlebar
"
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_TITLEBAR
;
}
if
(
!
aFeatures
.
Exists
(
"
close
"
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_CLOSE
;
}
}
if
(
aDialog
&
&
!
aFeatures
.
IsEmpty
(
)
&
&
!
presenceFlag
)
{
chromeFlags
=
nsIWebBrowserChrome
:
:
CHROME_DEFAULT
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
alwayslowered
"
false
)
|
|
aFeatures
.
GetBoolWithDefault
(
"
z
-
lock
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_LOWERED
;
}
else
if
(
aFeatures
.
GetBoolWithDefault
(
"
alwaysraised
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_WINDOW_RAISED
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
suppressanimation
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_SUPPRESS_ANIMATION
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
alwaysontop
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_ALWAYS_ON_TOP
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
chrome
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
extrachrome
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_EXTRA
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
centerscreen
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_CENTER_SCREEN
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
dependent
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
;
}
if
(
aFeatures
.
GetBoolWithDefault
(
"
modal
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_MODAL
|
nsIWebBrowserChrome
:
:
CHROME_DEPENDENT
;
}
bool
disableDialogFeature
=
false
;
nsCOMPtr
<
nsIPrefBranch
>
branch
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
branch
-
>
GetBoolPref
(
"
dom
.
disable_window_open_dialog_feature
"
&
disableDialogFeature
)
;
if
(
!
disableDialogFeature
)
{
if
(
aFeatures
.
GetBoolWithDefault
(
"
dialog
"
false
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
;
}
}
if
(
aDialog
)
{
if
(
!
aFeatures
.
Exists
(
"
dialog
"
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_DIALOG
;
}
if
(
!
aFeatures
.
Exists
(
"
chrome
"
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_OPENAS_CHROME
;
}
}
return
chromeFlags
;
}
already_AddRefed
<
BrowsingContext
>
nsWindowWatcher
:
:
GetBrowsingContextByName
(
const
nsAString
&
aName
bool
aForceNoOpener
BrowsingContext
*
aCurrentContext
)
{
if
(
aName
.
IsEmpty
(
)
)
{
return
nullptr
;
}
if
(
aForceNoOpener
&
&
!
nsContentUtils
:
:
IsSpecialName
(
aName
)
)
{
return
nullptr
;
}
RefPtr
<
BrowsingContext
>
foundContext
;
if
(
aCurrentContext
)
{
foundContext
=
aCurrentContext
-
>
FindWithName
(
aName
)
;
}
else
if
(
!
nsContentUtils
:
:
IsSpecialName
(
aName
)
)
{
for
(
RefPtr
<
BrowsingContext
>
toplevel
:
BrowsingContextGroup
:
:
GetChromeGroup
(
)
-
>
Toplevels
(
)
)
{
foundContext
=
toplevel
-
>
FindWithNameInSubtree
(
aName
*
toplevel
)
;
if
(
foundContext
)
{
break
;
}
}
}
return
foundContext
.
forget
(
)
;
}
SizeSpec
CalcSizeSpec
(
const
WindowFeatures
&
aFeatures
bool
aHasChromeParent
CSSToDesktopScale
aCSSToDesktopScale
)
{
SizeSpec
result
;
if
(
aFeatures
.
Exists
(
"
left
"
)
)
{
int32_t
x
=
aFeatures
.
GetInt
(
"
left
"
)
;
result
.
mLeft
.
emplace
(
(
CSSCoord
(
x
)
*
aCSSToDesktopScale
)
.
Rounded
(
)
)
;
}
if
(
aFeatures
.
Exists
(
"
top
"
)
)
{
int32_t
y
=
aFeatures
.
GetInt
(
"
top
"
)
;
result
.
mTop
.
emplace
(
(
CSSCoord
(
y
)
*
aCSSToDesktopScale
)
.
Rounded
(
)
)
;
}
if
(
aHasChromeParent
&
&
aFeatures
.
Exists
(
"
outerwidth
"
)
)
{
int32_t
width
=
aFeatures
.
GetInt
(
"
outerwidth
"
)
;
if
(
width
)
{
result
.
mOuterWidth
.
emplace
(
width
)
;
}
}
if
(
result
.
mOuterWidth
.
isNothing
(
)
)
{
if
(
aFeatures
.
Exists
(
"
width
"
)
)
{
int32_t
width
=
aFeatures
.
GetInt
(
"
width
"
)
;
if
(
width
)
{
result
.
mInnerWidth
.
emplace
(
width
)
;
}
}
}
if
(
aHasChromeParent
&
&
aFeatures
.
Exists
(
"
outerheight
"
)
)
{
int32_t
height
=
aFeatures
.
GetInt
(
"
outerheight
"
)
;
if
(
height
)
{
result
.
mOuterHeight
.
emplace
(
height
)
;
}
}
if
(
result
.
mOuterHeight
.
isNothing
(
)
)
{
if
(
aFeatures
.
Exists
(
"
height
"
)
)
{
int32_t
height
=
aFeatures
.
GetInt
(
"
height
"
)
;
if
(
height
)
{
result
.
mInnerHeight
.
emplace
(
height
)
;
}
}
}
result
.
mLockAspectRatio
=
aFeatures
.
GetBoolWithDefault
(
"
lockaspectratio
"
false
)
;
return
result
;
}
static
void
SizeOpenedWindow
(
nsIDocShellTreeOwner
*
aTreeOwner
mozIDOMWindowProxy
*
aParent
bool
aIsCallerChrome
const
SizeSpec
&
aSizeSpec
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
(
do_QueryInterface
(
aTreeOwner
)
)
;
if
(
!
treeOwnerAsWin
)
{
return
;
}
DesktopIntCoord
left
=
0
;
DesktopIntCoord
top
=
0
;
CSSIntCoord
width
=
0
;
CSSIntCoord
height
=
0
;
CSSIntCoord
chromeWidth
=
0
;
CSSIntCoord
chromeHeight
=
0
;
bool
sizeChromeWidth
=
true
;
bool
sizeChromeHeight
=
true
;
{
CSSToLayoutDeviceScale
cssToDevScale
=
treeOwnerAsWin
-
>
UnscaledDevicePixelsPerCSSPixel
(
)
;
DesktopToLayoutDeviceScale
devToDesktopScale
=
treeOwnerAsWin
-
>
DevicePixelsPerDesktopPixel
(
)
;
LayoutDeviceIntRect
devPxRect
=
treeOwnerAsWin
-
>
GetPositionAndSize
(
)
;
width
=
(
LayoutDeviceCoord
(
devPxRect
.
width
)
/
cssToDevScale
)
.
Rounded
(
)
;
height
=
(
LayoutDeviceCoord
(
devPxRect
.
height
)
/
cssToDevScale
)
.
Rounded
(
)
;
left
=
(
LayoutDeviceCoord
(
devPxRect
.
x
)
/
devToDesktopScale
)
.
Rounded
(
)
;
top
=
(
LayoutDeviceCoord
(
devPxRect
.
y
)
/
devToDesktopScale
)
.
Rounded
(
)
;
int32_t
contentWidth
contentHeight
;
bool
hasPrimaryContent
=
false
;
aTreeOwner
-
>
GetHasPrimaryContent
(
&
hasPrimaryContent
)
;
if
(
hasPrimaryContent
)
{
aTreeOwner
-
>
GetPrimaryContentSize
(
&
contentWidth
&
contentHeight
)
;
}
else
{
aTreeOwner
-
>
GetRootShellSize
(
&
contentWidth
&
contentHeight
)
;
}
chromeWidth
=
width
-
contentWidth
;
chromeHeight
=
height
-
contentHeight
;
}
if
(
aSizeSpec
.
mLeft
)
{
left
=
*
aSizeSpec
.
mLeft
;
}
if
(
aSizeSpec
.
mTop
)
{
top
=
*
aSizeSpec
.
mTop
;
}
if
(
aSizeSpec
.
mOuterWidth
)
{
width
=
*
aSizeSpec
.
mOuterWidth
;
}
else
if
(
aSizeSpec
.
mInnerWidth
)
{
sizeChromeWidth
=
false
;
width
=
*
aSizeSpec
.
mInnerWidth
;
}
if
(
aSizeSpec
.
mOuterHeight
)
{
height
=
*
aSizeSpec
.
mOuterHeight
;
}
else
if
(
aSizeSpec
.
mInnerHeight
)
{
sizeChromeHeight
=
false
;
height
=
*
aSizeSpec
.
mInnerHeight
;
}
bool
positionSpecified
=
aSizeSpec
.
PositionSpecified
(
)
;
bool
enabled
=
false
;
if
(
aIsCallerChrome
)
{
nsCOMPtr
<
nsIDOMChromeWindow
>
chromeWin
(
do_QueryInterface
(
aParent
)
)
;
enabled
=
!
aParent
|
|
chromeWin
;
}
const
CSSIntCoord
extraWidth
=
sizeChromeWidth
?
CSSIntCoord
(
0
)
:
chromeWidth
;
const
CSSIntCoord
extraHeight
=
sizeChromeHeight
?
CSSIntCoord
(
0
)
:
chromeHeight
;
if
(
!
enabled
)
{
int32_t
oldTop
=
top
oldLeft
=
left
;
nsCOMPtr
<
nsIScreen
>
screen
;
nsCOMPtr
<
nsIScreenManager
>
screenMgr
(
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
)
;
if
(
screenMgr
)
{
screenMgr
-
>
ScreenForRect
(
left
top
width
height
getter_AddRefs
(
screen
)
)
;
}
if
(
screen
)
{
CSSIntCoord
winWidth
=
width
+
extraWidth
;
CSSIntCoord
winHeight
=
height
+
extraHeight
;
auto
screenCssToDesktopScale
=
screen
-
>
GetCSSToDesktopScale
(
)
;
const
DesktopIntRect
screenDesktopRect
=
screen
-
>
GetAvailRectDisplayPix
(
)
;
const
CSSSize
screenCssSize
=
screenDesktopRect
.
Size
(
)
/
screenCssToDesktopScale
;
if
(
aSizeSpec
.
SizeSpecified
(
)
)
{
if
(
!
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
)
{
if
(
height
<
100
)
{
height
=
100
;
winHeight
=
height
+
extraHeight
;
}
if
(
winHeight
>
screenCssSize
.
height
)
{
height
=
screenCssSize
.
height
-
extraHeight
;
}
if
(
width
<
100
)
{
width
=
100
;
winWidth
=
width
+
extraWidth
;
}
if
(
winWidth
>
screenCssSize
.
width
)
{
width
=
screenCssSize
.
width
-
extraWidth
;
}
}
else
{
int32_t
targetContentWidth
=
0
;
int32_t
targetContentHeight
=
0
;
nsContentUtils
:
:
CalcRoundedWindowSizeForResistingFingerprinting
(
chromeWidth
chromeHeight
screenCssSize
.
width
screenCssSize
.
height
width
height
sizeChromeWidth
sizeChromeHeight
&
targetContentWidth
&
targetContentHeight
)
;
if
(
aSizeSpec
.
mInnerWidth
|
|
aSizeSpec
.
mOuterWidth
)
{
width
=
targetContentWidth
;
winWidth
=
width
+
extraWidth
;
}
if
(
aSizeSpec
.
mInnerHeight
|
|
aSizeSpec
.
mOuterHeight
)
{
height
=
targetContentHeight
;
winHeight
=
height
+
extraHeight
;
}
}
}
const
DesktopIntCoord
desktopWinWidth
=
(
CSSCoord
(
winWidth
)
*
screenCssToDesktopScale
)
.
Rounded
(
)
;
const
DesktopIntCoord
desktopWinHeight
=
(
CSSCoord
(
winHeight
)
*
screenCssToDesktopScale
)
.
Rounded
(
)
;
CheckedInt
<
int32_t
>
leftPlusWinWidth
=
int32_t
(
left
)
;
leftPlusWinWidth
+
=
int32_t
(
desktopWinWidth
)
;
if
(
!
leftPlusWinWidth
.
isValid
(
)
|
|
leftPlusWinWidth
.
value
(
)
>
screenDesktopRect
.
XMost
(
)
)
{
left
=
screenDesktopRect
.
XMost
(
)
-
desktopWinWidth
;
}
if
(
left
<
screenDesktopRect
.
x
)
{
left
=
screenDesktopRect
.
x
;
}
CheckedInt
<
int32_t
>
topPlusWinHeight
=
int32_t
(
top
)
;
topPlusWinHeight
+
=
int32_t
(
desktopWinHeight
)
;
if
(
!
topPlusWinHeight
.
isValid
(
)
|
|
topPlusWinHeight
.
value
(
)
>
screenDesktopRect
.
YMost
(
)
)
{
top
=
screenDesktopRect
.
YMost
(
)
-
desktopWinHeight
;
}
if
(
top
<
screenDesktopRect
.
y
)
{
top
=
screenDesktopRect
.
y
;
}
if
(
top
!
=
oldTop
|
|
left
!
=
oldLeft
)
{
positionSpecified
=
true
;
}
}
}
if
(
positionSpecified
)
{
treeOwnerAsWin
-
>
SetPositionDesktopPix
(
left
top
)
;
}
if
(
aSizeSpec
.
SizeSpecified
(
)
)
{
const
CSSToLayoutDeviceScale
scale
=
treeOwnerAsWin
-
>
UnscaledDevicePixelsPerCSSPixel
(
)
;
if
(
!
sizeChromeWidth
&
&
!
sizeChromeHeight
)
{
const
LayoutDeviceIntCoord
widthDevPx
=
(
CSSCoord
(
width
)
*
scale
)
.
Rounded
(
)
;
const
LayoutDeviceIntCoord
heightDevPx
=
(
CSSCoord
(
height
)
*
scale
)
.
Rounded
(
)
;
bool
hasPrimaryContent
=
false
;
aTreeOwner
-
>
GetHasPrimaryContent
(
&
hasPrimaryContent
)
;
if
(
hasPrimaryContent
)
{
aTreeOwner
-
>
SetPrimaryContentSize
(
widthDevPx
heightDevPx
)
;
}
else
{
aTreeOwner
-
>
SetRootShellSize
(
widthDevPx
heightDevPx
)
;
}
}
else
{
const
LayoutDeviceIntCoord
widthDevPx
=
(
CSSCoord
(
width
+
extraWidth
)
*
scale
)
.
Rounded
(
)
;
const
LayoutDeviceIntCoord
heightDevPx
=
(
CSSCoord
(
height
+
extraHeight
)
*
scale
)
.
Rounded
(
)
;
treeOwnerAsWin
-
>
SetSize
(
widthDevPx
heightDevPx
false
)
;
}
}
if
(
aIsCallerChrome
)
{
nsCOMPtr
<
nsIAppWindow
>
appWin
=
do_GetInterface
(
treeOwnerAsWin
)
;
if
(
appWin
&
&
aSizeSpec
.
mLockAspectRatio
)
{
appWin
-
>
LockAspectRatio
(
true
)
;
}
}
treeOwnerAsWin
-
>
SetVisibility
(
true
)
;
}
int32_t
nsWindowWatcher
:
:
GetWindowOpenLocation
(
nsPIDOMWindowOuter
*
aParent
uint32_t
aChromeFlags
bool
aCalledFromJS
bool
aIsForPrinting
)
{
if
(
aIsForPrinting
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_PRINT_BROWSER
;
}
int32_t
containerPref
;
if
(
NS_FAILED
(
Preferences
:
:
GetInt
(
"
browser
.
link
.
open_newwindow
"
&
containerPref
)
)
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_NEWTAB
;
}
bool
isDisabledOpenNewWindow
=
aParent
-
>
GetFullScreen
(
)
&
&
Preferences
:
:
GetBool
(
"
browser
.
link
.
open_newwindow
.
disabled_in_fullscreen
"
)
;
if
(
isDisabledOpenNewWindow
&
&
(
containerPref
=
=
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
)
)
{
containerPref
=
nsIBrowserDOMWindow
:
:
OPEN_NEWTAB
;
}
if
(
containerPref
!
=
nsIBrowserDOMWindow
:
:
OPEN_NEWTAB
&
&
containerPref
!
=
nsIBrowserDOMWindow
:
:
OPEN_CURRENTWINDOW
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
;
}
if
(
aCalledFromJS
)
{
int32_t
restrictionPref
=
Preferences
:
:
GetInt
(
"
browser
.
link
.
open_newwindow
.
restriction
"
2
)
;
if
(
restrictionPref
<
0
|
|
restrictionPref
>
2
)
{
restrictionPref
=
2
;
}
if
(
isDisabledOpenNewWindow
)
{
restrictionPref
=
0
;
}
if
(
restrictionPref
=
=
1
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
;
}
if
(
restrictionPref
=
=
2
)
{
int32_t
uiChromeFlags
=
aChromeFlags
;
uiChromeFlags
&
=
~
(
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_NON_PRIVATE_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_LIFETIME
)
;
if
(
uiChromeFlags
!
=
nsIWebBrowserChrome
:
:
CHROME_ALL
)
{
return
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
;
}
}
}
return
containerPref
;
}
