"
use
strict
"
;
const
svc
=
Cc
[
"
mozilla
.
org
/
win
-
task
-
scheduler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIWinTaskSchedulerService
)
;
const
uuidGenerator
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
function
randomName
(
)
{
return
(
"
moz
-
taskschd
-
test
-
"
+
uuidGenerator
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
)
;
}
const
gParentFolderName
=
randomName
(
)
;
const
gParentFolderPath
=
\
\
{
gParentFolderName
}
;
const
gSubFolderName
=
randomName
(
)
;
const
gSubFolderPath
=
\
\
{
gParentFolderName
}
\
\
{
gSubFolderName
}
;
const
gMissingFolderName
=
randomName
(
)
;
const
gMissingFolderPath
=
\
\
{
gParentFolderName
}
\
\
{
gMissingFolderName
}
;
const
gValidTaskXML
=
<
Task
xmlns
=
"
http
:
/
/
schemas
.
microsoft
.
com
/
windows
/
2004
/
02
/
mit
/
task
"
>
<
Triggers
/
>
<
Settings
>
<
Enabled
>
false
<
/
Enabled
>
<
/
Settings
>
<
Actions
>
<
Exec
>
<
Command
>
xyz123
.
exe
<
/
Command
>
<
/
Exec
>
<
/
Actions
>
<
/
Task
>
;
const
gInvalidTaskXML
=
<
Task
xmlns
=
"
http
:
/
/
schemas
.
microsoft
.
com
/
windows
/
2004
/
02
/
mit
/
task
"
>
<
Triggers
/
>
<
Settings
>
<
Enabled
>
false
<
/
Enabled
>
<
/
Settings
>
<
/
Task
>
;
function
cleanup
(
)
{
let
tasksToDelete
=
svc
.
getFolderTasks
(
gSubFolderPath
)
;
for
(
const
task
of
tasksToDelete
)
{
svc
.
deleteTask
(
gSubFolderPath
task
)
;
}
svc
.
deleteFolder
(
gParentFolderPath
gSubFolderName
)
;
svc
.
deleteFolder
(
"
\
\
"
gParentFolderPath
)
;
}
registerCleanupFunction
(
(
)
=
>
{
try
{
cleanup
(
)
;
}
catch
(
_ex
)
{
}
}
)
;
add_task
(
async
function
test_svc
(
)
{
Assert
.
throws
(
(
)
=
>
svc
.
createFolder
(
gParentFolderPath
gSubFolderName
)
/
NS_ERROR_FILE_NOT_FOUND
/
)
;
svc
.
createFolder
(
"
\
\
"
gParentFolderName
)
;
svc
.
createFolder
(
gParentFolderPath
gSubFolderName
)
;
Assert
.
throws
(
(
)
=
>
svc
.
createFolder
(
gParentFolderPath
gSubFolderName
)
/
NS_ERROR_FILE_ALREADY_EXISTS
/
)
;
Assert
.
throws
(
(
)
=
>
svc
.
deleteFolder
(
gParentFolderPath
gMissingFolderName
)
/
NS_ERROR_FILE_NOT_FOUND
/
)
;
const
taskNames
=
[
randomName
(
)
randomName
(
)
randomName
(
)
]
;
Assert
.
throws
(
(
)
=
>
svc
.
getFolderTasks
(
gMissingFolderPath
)
/
NS_ERROR_FILE_NOT_FOUND
/
)
;
Assert
.
deepEqual
(
svc
.
getFolderTasks
(
gSubFolderPath
)
[
]
)
;
Assert
.
throws
(
(
)
=
>
svc
.
registerTask
(
gMissingFolderPath
taskNames
[
0
]
gValidTaskXML
)
/
NS_ERROR_FILE_NOT_FOUND
/
)
;
svc
.
registerTask
(
gSubFolderPath
taskNames
[
0
]
gValidTaskXML
)
;
Assert
.
throws
(
(
)
=
>
svc
.
registerTask
(
gSubFolderPath
taskNames
[
0
]
gValidTaskXML
)
/
NS_ERROR_FILE_ALREADY_EXISTS
/
)
;
svc
.
registerTask
(
gSubFolderPath
taskNames
[
0
]
gValidTaskXML
true
)
;
Assert
.
ok
(
svc
.
getTaskXML
(
gSubFolderPath
taskNames
[
0
]
)
)
;
for
(
const
task
of
taskNames
.
slice
(
1
)
)
{
svc
.
registerTask
(
gSubFolderPath
task
gValidTaskXML
)
;
}
Assert
.
throws
(
(
)
=
>
svc
.
registerTask
(
gSubFolderPath
randomName
(
)
gInvalidTaskXML
)
/
NS_ERROR_FAILURE
/
)
;
Assert
.
equal
(
svc
.
validateTaskDefinition
(
gValidTaskXML
)
0
)
;
Assert
.
notEqual
(
svc
.
validateTaskDefinition
(
gInvalidTaskXML
)
0
)
;
{
let
foundTasks
=
svc
.
getFolderTasks
(
gSubFolderPath
)
;
foundTasks
.
sort
(
)
;
let
allTasks
=
taskNames
.
slice
(
)
;
allTasks
.
sort
(
)
;
Assert
.
deepEqual
(
foundTasks
allTasks
)
;
}
Assert
.
throws
(
(
)
=
>
svc
.
deleteFolder
(
gParentFolderPath
gSubFolderName
)
/
NS_ERROR_FILE_DIR_NOT_EMPTY
/
)
;
const
missingTaskName
=
randomName
(
)
;
Assert
.
throws
(
(
)
=
>
svc
.
deleteTask
(
gSubFolderName
missingTaskName
)
/
NS_ERROR_FILE_NOT_FOUND
/
)
;
Assert
.
throws
(
(
)
=
>
svc
.
getTaskXML
(
gSubFolderPath
missingTaskName
)
/
NS_ERROR_FILE_NOT_FOUND
/
)
;
cleanup
(
)
;
}
)
;
