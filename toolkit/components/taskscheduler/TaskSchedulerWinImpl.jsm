"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
_TaskSchedulerWinImpl
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
WinTaskSvc
:
[
"
mozilla
.
org
/
win
-
task
-
scheduler
-
service
;
1
"
"
nsIWinTaskSchedulerService
"
]
XreDirProvider
:
[
"
mozilla
.
org
/
xre
/
directory
-
provider
;
1
"
"
nsIXREDirProvider
"
]
}
)
;
var
_TaskSchedulerWinImpl
=
{
registerTask
(
id
command
intervalSeconds
options
)
{
this
.
_createFolderIfNonexistent
(
)
;
const
xml
=
this
.
_formatTaskDefinitionXML
(
command
intervalSeconds
options
)
;
const
updateExisting
=
true
;
WinTaskSvc
.
registerTask
(
this
.
_taskFolderName
(
)
this
.
_formatTaskName
(
id
)
xml
updateExisting
)
;
}
deleteTask
(
id
)
{
WinTaskSvc
.
deleteTask
(
this
.
_taskFolderName
(
)
this
.
_formatTaskName
(
id
)
)
;
}
deleteAllTasks
(
)
{
const
taskFolderName
=
this
.
_taskFolderName
(
)
;
let
allTasks
;
try
{
allTasks
=
WinTaskSvc
.
getFolderTasks
(
taskFolderName
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
{
return
;
}
throw
ex
;
}
const
tasksToDelete
=
allTasks
.
filter
(
name
=
>
this
.
_matchAppTaskName
(
name
)
)
;
let
numberDeleted
=
0
;
let
lastFailedTaskName
;
const
defaultBrowserAgentTaskName
=
AppConstants
.
MOZ_APP_DISPLAYNAME_DO_NOT_USE
+
"
Default
Browser
Agent
"
+
XreDirProvider
.
getInstallHash
(
)
;
for
(
const
taskName
of
tasksToDelete
)
{
if
(
taskName
=
=
defaultBrowserAgentTaskName
)
{
continue
;
}
try
{
WinTaskSvc
.
deleteTask
(
taskFolderName
taskName
)
;
numberDeleted
+
=
1
;
}
catch
(
e
)
{
lastFailedTaskName
=
taskName
;
}
}
if
(
lastFailedTaskName
)
{
WinTaskSvc
.
deleteTask
(
taskFolderName
lastFailedTaskName
)
;
}
if
(
allTasks
.
length
=
=
numberDeleted
)
{
this
.
_deleteFolderIfEmpty
(
)
;
}
}
taskExists
(
id
)
{
const
taskFolderName
=
this
.
_taskFolderName
(
)
;
let
allTasks
;
try
{
allTasks
=
WinTaskSvc
.
getFolderTasks
(
taskFolderName
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
{
return
false
;
}
throw
ex
;
}
return
allTasks
.
includes
(
this
.
_formatTaskName
(
id
)
)
;
}
_formatTaskDefinitionXML
(
command
intervalSeconds
options
)
{
const
startTime
=
new
Date
(
Date
.
now
(
)
+
intervalSeconds
*
1000
)
;
const
xmlns
=
"
http
:
/
/
schemas
.
microsoft
.
com
/
windows
/
2004
/
02
/
mit
/
task
"
;
const
docBase
=
<
Task
xmlns
=
"
{
xmlns
}
"
>
<
Triggers
>
<
TimeTrigger
>
<
StartBoundary
>
{
startTime
.
toISOString
(
)
}
<
/
StartBoundary
>
<
Repetition
>
<
Interval
>
PT
{
intervalSeconds
}
S
<
/
Interval
>
<
/
Repetition
>
<
/
TimeTrigger
>
<
/
Triggers
>
<
Actions
>
<
Exec
/
>
<
/
Actions
>
<
Settings
>
<
StartWhenAvailable
>
true
<
/
StartWhenAvailable
>
<
MultipleInstancesPolicy
>
IgnoreNew
<
/
MultipleInstancesPolicy
>
<
/
Settings
>
<
RegistrationInfo
>
<
Author
/
>
<
/
RegistrationInfo
>
<
/
Task
>
;
const
doc
=
new
DOMParser
(
)
.
parseFromString
(
docBase
"
text
/
xml
"
)
;
const
execAction
=
doc
.
querySelector
(
"
Actions
Exec
"
)
;
const
settings
=
doc
.
querySelector
(
"
Settings
"
)
;
const
commandNode
=
doc
.
createElementNS
(
xmlns
"
Command
"
)
;
commandNode
.
textContent
=
command
;
execAction
.
appendChild
(
commandNode
)
;
if
(
options
?
.
args
)
{
const
args
=
doc
.
createElementNS
(
xmlns
"
Arguments
"
)
;
args
.
textContent
=
options
.
args
.
map
(
this
.
_quoteString
)
.
join
(
"
"
)
;
execAction
.
appendChild
(
args
)
;
}
if
(
options
?
.
workingDirectory
)
{
const
workingDirectory
=
doc
.
createElementNS
(
xmlns
"
WorkingDirectory
"
)
;
workingDirectory
.
textContent
=
options
.
workingDirectory
;
execAction
.
appendChild
(
workingDirectory
)
;
}
if
(
options
?
.
disabled
)
{
const
enabled
=
doc
.
createElementNS
(
xmlns
"
Enabled
"
)
;
enabled
.
textContent
=
"
false
"
;
settings
.
appendChild
(
enabled
)
;
}
if
(
options
?
.
executionTimeoutSec
&
&
options
.
executionTimeoutSec
>
0
)
{
const
timeout
=
doc
.
createElementNS
(
xmlns
"
ExecutionTimeLimit
"
)
;
timeout
.
textContent
=
PT
{
options
.
executionTimeoutSec
}
S
;
settings
.
appendChild
(
timeout
)
;
}
doc
.
querySelector
(
"
RegistrationInfo
Author
"
)
.
textContent
=
Services
.
appinfo
.
vendor
;
if
(
options
?
.
description
)
{
const
registrationInfo
=
doc
.
querySelector
(
"
RegistrationInfo
"
)
;
const
description
=
doc
.
createElementNS
(
xmlns
"
Description
"
)
;
description
.
textContent
=
options
.
description
;
registrationInfo
.
appendChild
(
description
)
;
}
const
serializer
=
new
XMLSerializer
(
)
;
return
serializer
.
serializeToString
(
doc
)
;
}
_createFolderIfNonexistent
(
)
{
const
{
parentName
subName
}
=
this
.
_taskFolderNameParts
(
)
;
try
{
WinTaskSvc
.
createFolder
(
parentName
subName
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_FILE_ALREADY_EXISTS
)
{
throw
e
;
}
}
}
_deleteFolderIfEmpty
(
)
{
const
{
parentName
subName
}
=
this
.
_taskFolderNameParts
(
)
;
try
{
WinTaskSvc
.
deleteFolder
(
parentName
subName
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_FILE_DIR_NOT_EMPTY
)
{
throw
e
;
}
}
}
_quoteString
(
str
)
{
if
(
!
/
[
\
s
"
]
/
.
test
(
str
)
)
{
return
str
;
}
let
escaped
=
str
.
replace
(
/
(
\
\
*
)
(
"
|
)
/
g
(
m0
m1
m2
)
=
>
{
if
(
m2
)
{
m2
=
\
\
{
m2
}
;
}
return
{
m1
}
{
m1
}
{
m2
}
;
}
)
;
return
"
{
escaped
}
"
;
}
_taskFolderName
(
)
{
return
\
\
{
Services
.
appinfo
.
vendor
}
;
}
_taskFolderNameParts
(
)
{
return
{
parentName
:
"
\
\
"
subName
:
Services
.
appinfo
.
vendor
}
;
}
_formatTaskName
(
id
)
{
const
installHash
=
XreDirProvider
.
getInstallHash
(
)
;
return
{
id
}
{
installHash
}
;
}
_matchAppTaskName
(
name
)
{
const
installHash
=
XreDirProvider
.
getInstallHash
(
)
;
return
name
.
endsWith
(
{
installHash
}
)
;
}
}
;
