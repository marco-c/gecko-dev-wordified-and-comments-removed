"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
_TaskSchedulerMacOSImpl
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
Subprocess
:
"
resource
:
/
/
gre
/
modules
/
Subprocess
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
XreDirProvider
:
[
"
mozilla
.
org
/
xre
/
directory
-
provider
;
1
"
"
nsIXREDirProvider
"
]
}
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
XMLSerializer
"
]
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
ConsoleAPI
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
.
ConsoleAPI
;
let
consoleOptions
=
{
maxLogLevel
:
"
error
"
maxLogLevelPref
:
"
toolkit
.
components
.
taskscheduler
.
loglevel
"
prefix
:
"
TaskScheduler
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
var
_TaskSchedulerMacOSImpl
=
{
async
registerTask
(
id
command
intervalSeconds
options
)
{
log
.
info
(
registerTask
(
{
id
}
{
command
}
{
intervalSeconds
}
{
JSON
.
stringify
(
options
)
}
)
)
;
let
uid
=
await
this
.
_uid
(
)
;
log
.
debug
(
registerTask
:
uid
=
{
uid
}
)
;
let
label
=
this
.
_formatLabelForThisApp
(
id
)
;
let
plist
=
{
}
;
plist
.
Label
=
label
;
plist
.
ProgramArguments
=
[
command
]
;
if
(
options
.
args
)
{
plist
.
ProgramArguments
.
push
(
.
.
.
options
.
args
)
;
}
plist
.
StartInterval
=
intervalSeconds
;
if
(
options
.
workingDirectory
)
{
plist
.
WorkingDirectory
=
options
.
workingDirectory
;
}
let
str
=
this
.
_formatLaunchdPlist
(
plist
)
;
let
path
=
this
.
_formatPlistPath
(
label
)
;
await
IOUtils
.
write
(
path
new
TextEncoder
(
)
.
encode
(
str
)
)
;
log
.
debug
(
registerTask
:
wrote
{
path
}
)
;
try
{
let
bootout
=
await
Subprocess
.
call
(
{
command
:
"
/
bin
/
launchctl
"
arguments
:
[
"
bootout
"
gui
/
{
uid
}
/
{
label
}
]
stderr
:
"
stdout
"
}
)
;
log
.
debug
(
"
registerTask
:
bootout
stdout
"
await
bootout
.
stdout
.
readString
(
)
)
;
let
{
exitCode
}
=
await
bootout
.
wait
(
)
;
log
.
debug
(
registerTask
:
bootout
returned
{
exitCode
}
)
;
let
bootstrap
=
await
Subprocess
.
call
(
{
command
:
"
/
bin
/
launchctl
"
arguments
:
[
"
bootstrap
"
gui
/
{
uid
}
path
]
stderr
:
"
stdout
"
}
)
;
log
.
debug
(
"
registerTask
:
bootstrap
stdout
"
await
bootstrap
.
stdout
.
readString
(
)
)
;
(
{
exitCode
}
=
await
bootstrap
.
wait
(
)
)
;
log
.
debug
(
registerTask
:
bootstrap
returned
{
exitCode
}
)
;
if
(
exitCode
!
=
0
)
{
throw
new
Components
.
Exception
(
Failed
to
run
launchctl
bootstrap
:
{
exitCode
}
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
}
catch
(
e
)
{
await
IOUtils
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
throw
e
;
}
return
true
;
}
async
deleteTask
(
id
)
{
log
.
info
(
deleteTask
(
{
id
}
)
)
;
let
label
=
this
.
_formatLabelForThisApp
(
id
)
;
return
this
.
_deleteTaskByLabel
(
label
)
;
}
async
_deleteTaskByLabel
(
label
)
{
let
path
=
this
.
_formatPlistPath
(
label
)
;
log
.
debug
(
_deleteTaskByLabel
:
removing
{
path
}
)
;
await
IOUtils
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
let
uid
=
await
this
.
_uid
(
)
;
log
.
debug
(
_deleteTaskByLabel
:
uid
=
{
uid
}
)
;
let
bootout
=
await
Subprocess
.
call
(
{
command
:
"
/
bin
/
launchctl
"
arguments
:
[
"
bootout
"
gui
/
{
uid
}
/
{
label
}
]
stderr
:
"
stdout
"
}
)
;
let
{
exitCode
}
=
await
bootout
.
wait
(
)
;
log
.
debug
(
_deleteTaskByLabel
:
bootout
returned
{
exitCode
}
)
;
log
.
debug
(
_deleteTaskByLabel
:
bootout
stdout
await
bootout
.
stdout
.
readString
(
)
)
;
return
!
exitCode
;
}
async
_listAllLabelsForThisApp
(
)
{
let
proc
=
await
Subprocess
.
call
(
{
command
:
"
/
bin
/
launchctl
"
arguments
:
[
"
list
"
]
stderr
:
"
stdout
"
}
)
;
let
{
exitCode
}
=
await
proc
.
wait
(
)
;
if
(
exitCode
!
=
0
)
{
throw
new
Components
.
Exception
(
Failed
to
run
/
bin
/
launchctl
list
:
{
exitCode
}
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
let
stdout
=
await
proc
.
stdout
.
readString
(
)
;
let
lines
=
stdout
.
split
(
/
\
r
\
n
|
\
n
|
\
r
/
)
;
let
labels
=
lines
.
map
(
line
=
>
line
.
split
(
"
\
t
"
)
.
pop
(
)
)
.
filter
(
this
.
_labelMatchesThisApp
)
;
log
.
debug
(
_listAllLabelsForThisApp
labels
)
;
return
labels
;
}
async
deleteAllTasks
(
)
{
log
.
info
(
deleteAllTasks
(
)
)
;
let
labelsToDelete
=
await
this
.
_listAllLabelsForThisApp
(
)
;
let
deleted
=
0
;
let
failed
=
0
;
for
(
const
label
of
labelsToDelete
)
{
try
{
if
(
await
this
.
_deleteTaskByLabel
(
label
)
)
{
deleted
+
=
1
;
}
else
{
failed
+
=
1
;
}
}
catch
(
e
)
{
failed
+
=
1
;
}
}
let
result
=
{
deleted
failed
}
;
log
.
debug
(
deleteAllTasks
:
returning
{
JSON
.
stringify
(
result
)
}
)
;
}
_toLaunchdPlist
(
options
)
{
const
doc
=
new
DOMParser
(
)
.
parseFromString
(
"
<
plist
>
<
/
plist
>
"
"
text
/
xml
"
)
;
const
root
=
doc
.
documentElement
;
root
.
setAttribute
(
"
version
"
"
1
.
0
"
)
;
let
dict
=
doc
.
createElement
(
"
dict
"
)
;
root
.
appendChild
(
dict
)
;
for
(
let
[
k
v
]
of
Object
.
entries
(
options
)
)
{
let
key
=
doc
.
createElement
(
"
key
"
)
;
key
.
textContent
=
k
;
dict
.
appendChild
(
key
)
;
if
(
Array
.
isArray
(
v
)
)
{
let
array
=
doc
.
createElement
(
"
array
"
)
;
dict
.
appendChild
(
array
)
;
for
(
let
vv
of
v
)
{
let
string
=
doc
.
createElement
(
"
string
"
)
;
string
.
textContent
=
vv
;
array
.
appendChild
(
string
)
;
}
}
else
if
(
typeof
v
=
=
=
"
object
"
)
{
let
d
=
doc
.
createElement
(
"
dict
"
)
;
dict
.
appendChild
(
d
)
;
for
(
let
[
kk
vv
]
of
Object
.
entries
(
v
)
)
{
key
=
doc
.
createElement
(
"
key
"
)
;
key
.
textContent
=
kk
;
d
.
appendChild
(
key
)
;
let
string
=
doc
.
createElement
(
"
string
"
)
;
string
.
textContent
=
vv
;
d
.
appendChild
(
string
)
;
}
}
else
if
(
typeof
v
=
=
=
"
number
"
)
{
let
number
=
doc
.
createElement
(
Number
.
isInteger
(
v
)
?
"
integer
"
:
"
real
"
)
;
number
.
textContent
=
v
;
dict
.
appendChild
(
number
)
;
}
else
if
(
typeof
v
=
=
=
"
string
"
)
{
let
string
=
doc
.
createElement
(
"
string
"
)
;
string
.
textContent
=
v
;
dict
.
appendChild
(
string
)
;
}
else
if
(
typeof
v
=
=
=
"
boolean
"
)
{
let
bool
=
doc
.
createElement
(
v
?
"
true
"
:
"
false
"
)
;
dict
.
appendChild
(
bool
)
;
}
}
return
doc
;
}
_formatLaunchdPlist
(
options
)
{
let
doc
=
this
.
_toLaunchdPlist
(
options
)
;
let
serializer
=
new
XMLSerializer
(
)
;
return
serializer
.
serializeToString
(
doc
)
;
}
_formatLabelForThisApp
(
id
)
{
let
installHash
=
XreDirProvider
.
getInstallHash
(
)
;
return
{
AppConstants
.
MOZ_MACBUNDLE_ID
}
.
{
installHash
}
.
{
id
}
;
}
_labelMatchesThisApp
(
label
)
{
let
installHash
=
XreDirProvider
.
getInstallHash
(
)
;
return
(
label
&
&
label
.
startsWith
(
{
AppConstants
.
MOZ_MACBUNDLE_ID
}
.
{
installHash
}
.
)
)
;
}
_formatPlistPath
(
label
)
{
let
file
=
Services
.
dirsvc
.
get
(
"
Home
"
Ci
.
nsIFile
)
;
file
.
append
(
"
Library
"
)
;
file
.
append
(
"
LaunchAgents
"
)
;
file
.
append
(
{
label
}
.
plist
)
;
return
file
.
path
;
}
_cachedUid
:
-
1
async
_uid
(
)
{
if
(
this
.
_cachedUid
>
=
0
)
{
return
this
.
_cachedUid
;
}
let
proc
=
await
Subprocess
.
call
(
{
command
:
"
/
usr
/
bin
/
id
"
arguments
:
[
"
-
u
"
]
stderr
:
"
stdout
"
}
)
;
let
stdout
=
await
proc
.
stdout
.
readString
(
)
;
let
{
exitCode
}
=
await
proc
.
wait
(
)
;
if
(
exitCode
!
=
0
)
{
throw
new
Components
.
Exception
(
Failed
to
run
/
usr
/
bin
/
id
:
{
exitCode
}
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
try
{
this
.
_cachedUid
=
Number
.
parseInt
(
stdout
)
;
return
this
.
_cachedUid
;
}
catch
(
e
)
{
throw
new
Components
.
Exception
(
Failed
to
parse
/
usr
/
bin
/
id
output
as
integer
:
{
stdout
}
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
}
}
;
