var
EXPORTED_SYMBOLS
=
[
"
CrashMonitor
"
]
;
const
{
PrivateBrowsingUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
SESSIONSTORE_WINDOWS_RESTORED_TOPIC
=
"
sessionstore
-
windows
-
restored
"
;
const
SESSIONSTORE_FINAL_STATE_WRITE_COMPLETE_TOPIC
=
"
sessionstore
-
final
-
state
-
write
-
complete
"
;
const
NOTIFICATIONS
=
[
"
final
-
ui
-
startup
"
SESSIONSTORE_WINDOWS_RESTORED_TOPIC
"
quit
-
application
-
granted
"
"
quit
-
application
"
"
profile
-
change
-
net
-
teardown
"
"
profile
-
change
-
teardown
"
SESSIONSTORE_FINAL_STATE_WRITE_COMPLETE_TOPIC
]
;
const
SHUTDOWN_PHASES
=
[
"
profile
-
before
-
change
"
]
;
var
CrashMonitorInternal
=
{
checkpoints
:
{
}
sessionStoreFinalWriteComplete
:
PromiseUtils
.
defer
(
)
previousCheckpoints
:
null
path
:
PathUtils
.
join
(
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
.
path
"
sessionCheckpoints
.
json
"
)
loadPreviousCheckpoints
(
)
{
this
.
previousCheckpoints
=
(
async
function
(
)
{
let
notifications
;
try
{
notifications
=
await
IOUtils
.
readJSON
(
CrashMonitorInternal
.
path
)
;
}
catch
(
ex
)
{
if
(
ex
.
name
!
=
=
"
NotFoundError
"
)
{
Cu
.
reportError
(
Error
while
loading
crash
monitor
data
:
{
ex
.
message
}
)
;
}
return
null
;
}
if
(
Object
(
notifications
)
!
=
=
notifications
)
{
Cu
.
reportError
(
"
Error
while
parsing
crash
monitor
data
:
invalid
monitor
data
"
)
;
return
null
;
}
return
Object
.
freeze
(
notifications
)
;
}
)
(
)
;
return
this
.
previousCheckpoints
;
}
}
;
var
CrashMonitor
=
{
get
previousCheckpoints
(
)
{
if
(
!
CrashMonitorInternal
.
initialized
)
{
throw
new
Error
(
"
CrashMonitor
must
be
initialized
before
getting
previous
checkpoints
"
)
;
}
return
CrashMonitorInternal
.
previousCheckpoints
;
}
init
(
)
{
if
(
CrashMonitorInternal
.
initialized
)
{
throw
new
Error
(
"
CrashMonitor
.
init
(
)
must
only
be
called
once
!
"
)
;
}
let
promise
=
CrashMonitorInternal
.
loadPreviousCheckpoints
(
)
;
CrashMonitorInternal
.
checkpoints
[
"
profile
-
after
-
change
"
]
=
true
;
NOTIFICATIONS
.
forEach
(
function
(
aTopic
)
{
Services
.
obs
.
addObserver
(
this
aTopic
)
;
}
this
)
;
IOUtils
.
profileBeforeChange
.
addBlocker
(
"
CrashMonitor
:
Writing
notifications
to
file
after
receiving
profile
-
before
-
change
and
awaiting
all
checkpoints
written
"
async
(
)
=
>
{
await
this
.
writeCheckpoint
(
"
profile
-
before
-
change
"
)
;
if
(
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
&
&
CrashMonitorInternal
.
checkpoints
[
SESSIONSTORE_WINDOWS_RESTORED_TOPIC
]
)
{
await
CrashMonitorInternal
.
sessionStoreFinalWriteComplete
.
promise
;
}
}
(
)
=
>
CrashMonitorInternal
.
checkpoints
)
;
CrashMonitorInternal
.
initialized
=
true
;
return
promise
;
}
observe
(
aSubject
aTopic
aData
)
{
this
.
writeCheckpoint
(
aTopic
)
;
if
(
NOTIFICATIONS
.
every
(
elem
=
>
elem
in
CrashMonitorInternal
.
checkpoints
)
&
&
SHUTDOWN_PHASES
.
every
(
elem
=
>
elem
in
CrashMonitorInternal
.
checkpoints
)
)
{
NOTIFICATIONS
.
forEach
(
function
(
aTopic
)
{
Services
.
obs
.
removeObserver
(
this
aTopic
)
;
}
this
)
;
}
if
(
aTopic
=
=
=
SESSIONSTORE_FINAL_STATE_WRITE_COMPLETE_TOPIC
)
{
CrashMonitorInternal
.
sessionStoreFinalWriteComplete
.
resolve
(
)
;
}
}
async
writeCheckpoint
(
aCheckpoint
)
{
if
(
!
(
aCheckpoint
in
CrashMonitorInternal
.
checkpoints
)
)
{
CrashMonitorInternal
.
checkpoints
[
aCheckpoint
]
=
true
;
await
IOUtils
.
writeJSON
(
CrashMonitorInternal
.
path
CrashMonitorInternal
.
checkpoints
{
tmpPath
:
CrashMonitorInternal
.
path
+
"
.
tmp
"
}
)
;
}
}
}
;
Object
.
freeze
(
CrashMonitor
)
;
