"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PictureInPicture
"
"
PictureInPictureParent
"
"
PictureInPictureToggleParent
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
PLAYER_URI
=
"
chrome
:
/
/
global
/
content
/
pictureinpicture
/
player
.
xhtml
"
;
var
PLAYER_FEATURES
=
"
chrome
titlebar
=
yes
alwaysontop
lockaspectratio
resizable
"
;
if
(
!
AppConstants
.
MOZ_WIDGET_GTK
)
{
PLAYER_FEATURES
+
=
"
dialog
"
;
}
const
WINDOW_TYPE
=
"
Toolkit
:
PictureInPicture
"
;
const
TOGGLE_ENABLED_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
enabled
"
;
let
gCloseReasons
=
new
WeakMap
(
)
;
let
gNextWindowID
=
0
;
class
PictureInPictureToggleParent
extends
JSWindowActorParent
{
receiveMessage
(
aMessage
)
{
let
browsingContext
=
aMessage
.
target
.
browsingContext
;
let
browser
=
browsingContext
.
top
.
embedderElement
;
switch
(
aMessage
.
name
)
{
case
"
PictureInPicture
:
OpenToggleContextMenu
"
:
{
let
win
=
browser
.
ownerGlobal
;
PictureInPicture
.
openToggleContextMenu
(
win
aMessage
.
data
)
;
break
;
}
}
}
}
class
PictureInPictureParent
extends
JSWindowActorParent
{
receiveMessage
(
aMessage
)
{
let
browsingContext
=
aMessage
.
target
.
browsingContext
;
let
browser
=
browsingContext
.
top
.
embedderElement
;
switch
(
aMessage
.
name
)
{
case
"
PictureInPicture
:
Request
"
:
{
let
videoData
=
aMessage
.
data
;
PictureInPicture
.
handlePictureInPictureRequest
(
browser
videoData
)
;
break
;
}
case
"
PictureInPicture
:
Close
"
:
{
let
reason
=
aMessage
.
data
.
reason
;
PictureInPicture
.
closePipWindow
(
{
reason
}
)
;
break
;
}
case
"
PictureInPicture
:
Playing
"
:
{
let
player
=
PictureInPicture
.
getWeakPipPlayer
(
)
;
if
(
player
)
{
player
.
setIsPlayingState
(
true
)
;
}
break
;
}
case
"
PictureInPicture
:
Paused
"
:
{
let
player
=
PictureInPicture
.
getWeakPipPlayer
(
)
;
if
(
player
)
{
player
.
setIsPlayingState
(
false
)
;
}
break
;
}
case
"
PictureInPicture
:
Muting
"
:
{
let
player
=
PictureInPicture
.
getWeakPipPlayer
(
)
;
if
(
player
)
{
player
.
setIsMutedState
(
true
)
;
}
break
;
}
case
"
PictureInPicture
:
Unmuting
"
:
{
let
player
=
PictureInPicture
.
getWeakPipPlayer
(
)
;
if
(
player
)
{
player
.
setIsMutedState
(
false
)
;
}
break
;
}
}
}
}
var
PictureInPicture
=
{
getWeakPipPlayer
(
)
{
let
weakRef
=
this
.
_weakPipPlayer
;
if
(
weakRef
)
{
let
playerWin
;
try
{
playerWin
=
weakRef
.
get
(
)
;
}
catch
(
e
)
{
return
null
;
}
if
(
!
playerWin
.
closed
)
{
return
playerWin
;
}
}
return
null
;
}
onCommand
(
event
)
{
let
win
=
event
.
target
.
ownerGlobal
;
let
browser
=
win
.
gBrowser
.
selectedBrowser
;
browser
.
messageManager
.
sendAsyncMessage
(
"
PictureInPicture
:
KeyToggle
"
)
;
}
async
focusTabAndClosePip
(
)
{
let
gBrowser
=
this
.
browser
.
ownerGlobal
.
gBrowser
;
let
tab
=
gBrowser
.
getTabForBrowser
(
this
.
browser
)
;
gBrowser
.
selectedTab
=
tab
;
await
this
.
closePipWindow
(
{
reason
:
"
unpip
"
}
)
;
}
clearPipTabIcon
(
)
{
let
win
=
this
.
browser
.
ownerGlobal
;
let
tab
=
win
.
gBrowser
.
getTabForBrowser
(
this
.
browser
)
;
if
(
tab
)
{
tab
.
removeAttribute
(
"
pictureinpicture
"
)
;
}
}
async
closePipWindow
(
{
reason
}
)
{
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
WINDOW_TYPE
)
)
{
if
(
win
.
closed
)
{
continue
;
}
let
closedPromise
=
new
Promise
(
resolve
=
>
{
win
.
addEventListener
(
"
unload
"
resolve
{
once
:
true
}
)
;
}
)
;
gCloseReasons
.
set
(
win
reason
)
;
win
.
close
(
)
;
await
closedPromise
;
}
}
async
handlePictureInPictureRequest
(
browser
videoData
)
{
await
this
.
closePipWindow
(
{
reason
:
"
new
-
pip
"
}
)
;
let
parentWin
=
browser
.
ownerGlobal
;
this
.
browser
=
browser
;
let
win
=
await
this
.
openPipWindow
(
parentWin
videoData
)
;
this
.
_weakPipPlayer
=
Cu
.
getWeakReference
(
win
)
;
win
.
setIsPlayingState
(
videoData
.
playing
)
;
win
.
setIsMutedState
(
videoData
.
isMuted
)
;
let
tab
=
parentWin
.
gBrowser
.
getTabForBrowser
(
browser
)
;
tab
.
setAttribute
(
"
pictureinpicture
"
true
)
;
win
.
setupPlayer
(
gNextWindowID
.
toString
(
)
browser
)
;
gNextWindowID
+
+
;
}
unload
(
window
)
{
TelemetryStopwatch
.
finish
(
"
FX_PICTURE_IN_PICTURE_WINDOW_OPEN_DURATION
"
window
)
;
let
reason
=
gCloseReasons
.
get
(
window
)
|
|
"
other
"
;
Services
.
telemetry
.
keyedScalarAdd
(
"
pictureinpicture
.
closed_method
"
reason
1
)
;
this
.
clearPipTabIcon
(
)
;
delete
this
.
_weakPipPlayer
;
delete
this
.
browser
;
}
async
openPipWindow
(
parentWin
videoData
)
{
let
{
videoHeight
videoWidth
}
=
videoData
;
let
screenManager
=
Cc
[
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
]
.
getService
(
Ci
.
nsIScreenManager
)
;
let
screen
=
screenManager
.
screenForRect
(
parentWin
.
screenX
parentWin
.
screenY
1
1
)
;
let
screenLeft
=
{
}
screenTop
=
{
}
screenWidth
=
{
}
screenHeight
=
{
}
;
screen
.
GetAvailRectDisplayPix
(
screenLeft
screenTop
screenWidth
screenHeight
)
;
let
fullLeft
=
{
}
fullTop
=
{
}
fullWidth
=
{
}
fullHeight
=
{
}
;
screen
.
GetRectDisplayPix
(
fullLeft
fullTop
fullWidth
fullHeight
)
;
let
scaleFactor
=
screen
.
contentsScaleFactor
/
screen
.
defaultCSSScaleFactor
;
screenWidth
.
value
*
=
scaleFactor
;
screenHeight
.
value
*
=
scaleFactor
;
screenLeft
.
value
=
(
screenLeft
.
value
-
fullLeft
.
value
)
*
scaleFactor
+
fullLeft
.
value
;
screenTop
.
value
=
(
screenTop
.
value
-
fullTop
.
value
)
*
scaleFactor
+
fullTop
.
value
;
const
MAX_HEIGHT
=
screenHeight
.
value
/
4
;
const
MAX_WIDTH
=
screenWidth
.
value
/
3
;
let
resultWidth
=
videoWidth
;
let
resultHeight
=
videoHeight
;
if
(
videoHeight
>
MAX_HEIGHT
|
|
videoWidth
>
MAX_WIDTH
)
{
let
aspectRatio
=
videoWidth
/
videoHeight
;
if
(
videoWidth
>
=
videoHeight
)
{
resultWidth
=
MAX_WIDTH
;
resultHeight
=
Math
.
round
(
MAX_WIDTH
/
aspectRatio
)
;
}
else
{
resultHeight
=
MAX_HEIGHT
;
resultWidth
=
Math
.
round
(
MAX_HEIGHT
*
aspectRatio
)
;
}
}
let
isRTL
=
Services
.
locale
.
isAppLocaleRTL
;
let
pipLeft
=
isRTL
?
screenLeft
.
value
:
screenLeft
.
value
+
screenWidth
.
value
-
resultWidth
;
let
pipTop
=
screenTop
.
value
+
screenHeight
.
value
-
resultHeight
;
let
features
=
{
PLAYER_FEATURES
}
top
=
{
pipTop
}
left
=
{
pipLeft
}
+
outerWidth
=
{
resultWidth
}
outerHeight
=
{
resultHeight
}
;
let
pipWindow
=
Services
.
ww
.
openWindow
(
parentWin
PLAYER_URI
null
features
null
)
;
TelemetryStopwatch
.
start
(
"
FX_PICTURE_IN_PICTURE_WINDOW_OPEN_DURATION
"
pipWindow
{
inSeconds
:
true
}
)
;
return
new
Promise
(
resolve
=
>
{
pipWindow
.
addEventListener
(
"
load
"
(
)
=
>
{
resolve
(
pipWindow
)
;
}
{
once
:
true
}
)
;
}
)
;
}
openToggleContextMenu
(
window
data
)
{
let
document
=
window
.
document
;
let
popup
=
document
.
getElementById
(
"
pictureInPictureToggleContextMenu
"
)
;
let
newEvent
=
document
.
createEvent
(
"
MouseEvent
"
)
;
newEvent
.
initNSMouseEvent
(
"
contextmenu
"
true
true
null
0
data
.
screenX
data
.
screenY
0
0
false
false
false
false
0
null
0
data
.
mozInputSource
)
;
popup
.
openPopupAtScreen
(
newEvent
.
screenX
newEvent
.
screenY
true
newEvent
)
;
}
hideToggle
(
)
{
Services
.
prefs
.
setBoolPref
(
TOGGLE_ENABLED_PREF
false
)
;
}
}
;
