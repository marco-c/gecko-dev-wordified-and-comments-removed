"
use
strict
"
;
add_task
(
async
(
)
=
>
{
for
(
let
videoID
of
[
"
with
-
controls
"
"
no
-
controls
"
]
)
{
info
(
Testing
{
videoID
}
case
.
)
;
await
BrowserTestUtils
.
withNewTab
(
{
url
:
TEST_PAGE
gBrowser
}
async
browser
=
>
{
let
pipWin
=
await
triggerPictureInPicture
(
browser
videoID
)
;
Assert
.
ok
(
pipWin
"
Got
PiP
window
.
"
)
;
await
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
let
doc
=
content
.
document
;
let
otherVideo
=
doc
.
querySelector
(
video
:
not
(
[
id
=
"
{
videoID
}
"
]
)
)
;
let
eventFired
=
false
;
let
listener
=
(
)
=
>
{
eventFired
=
true
;
}
;
docShell
.
chromeEventHandler
.
addEventListener
(
"
MozStopPictureInPicture
"
listener
{
capture
:
true
}
)
;
otherVideo
.
remove
(
)
;
Assert
.
ok
(
!
eventFired
"
Should
not
have
seen
MozStopPictureInPicture
for
other
video
"
)
;
docShell
.
chromeEventHandler
.
removeEventListener
(
"
MozStopPictureInPicture
"
listener
{
capture
:
true
}
)
;
}
)
;
Assert
.
ok
(
!
pipWin
.
closed
"
PiP
window
should
still
be
open
.
"
)
;
await
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
let
doc
=
content
.
document
;
let
video
=
doc
.
querySelector
(
#
{
videoID
}
)
;
let
promise
=
ContentTaskUtils
.
waitForEvent
(
docShell
.
chromeEventHandler
"
MozStopPictureInPicture
"
{
capture
:
true
}
)
;
video
.
remove
(
)
;
await
promise
;
}
)
;
try
{
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
pipWin
.
closed
"
Player
window
closed
.
"
)
;
}
finally
{
if
(
!
pipWin
.
closed
)
{
await
BrowserTestUtils
.
closeWindow
(
pipWin
)
;
}
}
}
)
;
}
}
)
;
