"
use
strict
"
;
const
MIN_DURATION_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
min
-
video
-
secs
"
;
const
ALWAYS_SHOW_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
always
-
show
"
;
add_setup
(
async
(
)
=
>
{
const
PIP_ON_TAB_SWITCH_ENABLED_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
enable
-
when
-
switching
-
tabs
.
enabled
"
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PIP_ON_TAB_SWITCH_ENABLED_PREF
true
]
]
}
)
;
}
)
;
add_task
(
async
function
autopip_and_focus
(
)
{
let
win1
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
firstTab
=
win1
.
gBrowser
.
selectedTab
;
let
pipTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
win1
.
gBrowser
TEST_PAGE
)
;
let
browser
=
pipTab
.
linkedBrowser
;
let
secondTab
=
win1
.
gBrowser
.
selectedTab
;
let
videoID
=
"
with
-
controls
"
;
await
ensureVideosReady
(
browser
)
;
await
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
await
content
.
document
.
getElementById
(
videoID
)
.
play
(
)
;
}
)
;
let
domWindowOpened
=
BrowserTestUtils
.
domWindowOpenedAndLoaded
(
null
)
;
let
blurAborter
=
new
AbortController
(
)
;
win1
.
addEventListener
(
"
blur
"
(
)
=
>
{
ok
(
false
"
Should
never
have
seen
the
blur
event
!
"
)
;
}
{
signal
:
blurAborter
.
signal
}
)
;
await
BrowserTestUtils
.
switchTab
(
win1
.
gBrowser
firstTab
)
;
let
pipWin
=
await
domWindowOpened
;
ok
(
pipWin
"
PiP
window
automatically
opened
.
"
)
;
await
new
Promise
(
resolve
=
>
pipWin
.
requestAnimationFrame
(
resolve
)
)
;
is
(
Services
.
focus
.
activeWindow
win1
"
First
window
is
still
focused
"
)
;
blurAborter
.
abort
(
)
;
let
pipClosed
=
BrowserTestUtils
.
domWindowClosed
(
pipWin
)
;
await
BrowserTestUtils
.
switchTab
(
win1
.
gBrowser
secondTab
)
;
ok
(
await
pipClosed
"
PiP
window
automatically
closed
.
"
)
;
await
BrowserTestUtils
.
closeWindow
(
win1
)
;
}
)
;
add_task
(
async
function
autopip_interference
(
)
{
let
firstTab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
withNewTab
(
{
url
:
TEST_PAGE
gBrowser
waitForLoad
:
true
}
async
browser
=
>
{
let
videoID
=
"
with
-
controls
"
;
await
ensureVideosReady
(
browser
)
;
await
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
await
content
.
document
.
getElementById
(
videoID
)
.
play
(
)
;
}
)
;
let
pipWin
=
await
triggerPictureInPicture
(
browser
"
with
-
controls
"
)
;
ok
(
pipWin
"
PiP
window
has
been
manually
opened
by
the
user
"
)
;
let
secondTab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
firstTab
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
2000
)
)
;
ok
(
!
pipWin
.
closed
"
PiP
window
should
still
be
open
.
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
secondTab
)
;
let
pipClosed
=
BrowserTestUtils
.
domWindowClosed
(
pipWin
)
;
let
closeButton
=
pipWin
.
document
.
getElementById
(
"
close
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
closeButton
{
}
pipWin
)
;
ok
(
await
pipClosed
"
PiP
window
has
been
manually
closed
by
the
user
"
)
;
await
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
await
content
.
document
.
getElementById
(
videoID
)
.
play
(
)
;
}
)
;
let
domWindowOpened
=
BrowserTestUtils
.
domWindowOpenedAndLoaded
(
null
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
firstTab
)
;
let
pipWinAuto
=
await
domWindowOpened
;
ok
(
pipWinAuto
"
PiP
window
automatically
opened
.
"
)
;
let
pipClosedAuto
=
BrowserTestUtils
.
domWindowClosed
(
pipWinAuto
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
secondTab
)
;
ok
(
await
pipClosedAuto
"
PiP
window
automatically
closed
.
"
)
;
}
)
;
}
)
;
add_task
(
async
function
autopip_silent_videos
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
ALWAYS_SHOW_PREF
false
]
[
MIN_DURATION_PREF
3
]
]
}
)
;
let
firstTab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
TEST_PAGE_WITHOUT_AUDIO
}
async
browser
=
>
{
let
videoID
=
"
without
-
audio
"
;
await
ensureVideosReady
(
browser
)
;
await
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
await
content
.
document
.
getElementById
(
videoID
)
.
play
(
)
;
}
)
;
let
visibilityChange
=
BrowserTestUtils
.
waitForContentEvent
(
browser
"
visibilitychange
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
firstTab
)
;
await
visibilityChange
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
2000
)
)
;
assertNoPiPWindowsOpen
(
)
;
}
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
ALWAYS_SHOW_PREF
false
]
[
MIN_DURATION_PREF
3
]
]
}
)
;
let
firstTab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
TEST_PAGE_WITH_SOUND
}
async
browser
=
>
{
let
videoID
=
"
with
-
controls
"
;
await
ensureVideosReady
(
browser
)
;
await
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
let
videoEl
=
content
.
document
.
getElementById
(
videoID
)
;
videoEl
.
style
.
maxWidth
=
"
10px
"
;
videoEl
.
style
.
maxHeight
=
"
10px
"
;
await
videoEl
.
play
(
)
;
}
)
;
let
visibilityChange
=
BrowserTestUtils
.
waitForContentEvent
(
browser
"
visibilitychange
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
firstTab
)
;
await
visibilityChange
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
2000
)
)
;
assertNoPiPWindowsOpen
(
)
;
}
)
;
}
)
;
