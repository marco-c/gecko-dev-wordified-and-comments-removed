"
use
strict
"
;
const
TEST_ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
http
:
/
/
example
.
com
"
)
;
const
TEST_ROOT_2
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
http
:
/
/
example
.
org
"
)
;
const
TEST_PAGE
=
TEST_ROOT
+
"
test
-
page
.
html
"
;
const
TEST_PAGE_2
=
TEST_ROOT_2
+
"
test
-
page
.
html
"
;
const
TEST_PAGE_WITH_IFRAME
=
TEST_ROOT_2
+
"
test
-
page
-
with
-
iframe
.
html
"
;
const
WINDOW_TYPE
=
"
Toolkit
:
PictureInPicture
"
;
const
TOGGLE_ID
=
"
pictureInPictureToggleButton
"
;
const
HOVER_VIDEO_OPACITY
=
0
.
8
;
const
HOVER_TOGGLE_OPACITY
=
1
.
0
;
async
function
triggerPictureInPicture
(
browser
videoID
)
{
let
domWindowOpened
=
BrowserTestUtils
.
domWindowOpened
(
null
)
;
let
videoReady
=
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
event
=
new
content
.
CustomEvent
(
"
MozTogglePictureInPicture
"
{
bubbles
:
true
}
)
;
video
.
dispatchEvent
(
event
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
video
.
isCloningElementVisually
;
}
"
Video
is
being
cloned
visually
.
"
)
;
}
)
;
let
win
=
await
domWindowOpened
;
await
BrowserTestUtils
.
waitForEvent
(
win
"
load
"
)
;
await
win
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
;
await
videoReady
;
return
win
;
}
async
function
assertShowingMessage
(
browser
videoID
expected
)
{
let
showing
=
await
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
let
pipOverlay
=
shadowRoot
.
querySelector
(
"
.
pictureInPictureOverlay
"
)
;
Assert
.
ok
(
pipOverlay
"
Should
be
able
to
find
Picture
-
in
-
Picture
overlay
.
"
)
;
let
rect
=
pipOverlay
.
getBoundingClientRect
(
)
;
return
rect
.
height
>
0
&
&
rect
.
width
>
0
;
}
)
;
Assert
.
equal
(
showing
expected
"
Video
should
be
showing
the
expected
state
.
"
)
;
}
async
function
ensureVideosReady
(
browser
)
{
info
(
Waiting
for
videos
to
be
ready
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
videos
=
this
.
content
.
document
.
querySelectorAll
(
"
video
"
)
;
for
(
let
video
of
videos
)
{
if
(
video
.
readyState
<
content
.
HTMLMediaElement
.
HAVE_ENOUGH_DATA
)
{
await
ContentTaskUtils
.
waitForEvent
(
video
"
canplay
"
)
;
}
}
}
)
;
}
async
function
toggleOpacityReachesThreshold
(
browser
videoID
opacityThreshold
)
{
let
args
=
{
videoID
TOGGLE_ID
opacityThreshold
}
;
await
SpecialPowers
.
spawn
(
browser
[
args
]
async
args
=
>
{
let
{
videoID
TOGGLE_ID
opacityThreshold
}
=
args
;
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
let
toggle
=
shadowRoot
.
getElementById
(
TOGGLE_ID
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
let
opacity
=
parseFloat
(
this
.
content
.
getComputedStyle
(
toggle
)
.
opacity
)
;
return
opacity
>
=
opacityThreshold
;
}
Toggle
should
have
opacity
>
=
{
opacityThreshold
}
100
100
)
;
ok
(
true
"
Toggle
reached
target
opacity
.
"
)
;
}
)
;
}
async
function
assertTogglePolicy
(
browser
videoID
policy
)
{
let
args
=
{
videoID
TOGGLE_ID
policy
}
;
await
SpecialPowers
.
spawn
(
browser
[
args
]
async
args
=
>
{
let
{
videoID
TOGGLE_ID
policy
}
=
args
;
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
let
controlsOverlay
=
shadowRoot
.
querySelector
(
"
.
controlsOverlay
"
)
;
let
toggle
=
shadowRoot
.
getElementById
(
TOGGLE_ID
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
controlsOverlay
.
classList
.
contains
(
"
hovering
"
)
;
}
"
Waiting
for
the
hovering
state
to
be
set
on
the
video
.
"
)
;
if
(
policy
)
{
const
{
TOGGLE_POLICY_STRINGS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PictureInPictureTogglePolicy
.
jsm
"
)
;
let
policyAttr
=
toggle
.
getAttribute
(
"
policy
"
)
;
Assert
.
equal
(
policyAttr
TOGGLE_POLICY_STRINGS
[
policy
]
"
The
correct
toggle
policy
is
set
.
"
)
;
}
else
{
Assert
.
ok
(
!
toggle
.
hasAttribute
(
"
policy
"
)
"
No
toggle
policy
should
be
set
.
"
)
;
}
}
)
;
}
async
function
assertSawMouseEvents
(
browser
isExpectingEvents
isExpectingClick
=
true
)
{
const
MOUSE_BUTTON_EVENTS
=
[
"
pointerdown
"
"
mousedown
"
"
pointerup
"
"
mouseup
"
]
;
if
(
isExpectingClick
)
{
MOUSE_BUTTON_EVENTS
.
push
(
"
click
"
)
;
}
let
mouseEvents
=
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
return
this
.
content
.
wrappedJSObject
.
getRecordedEvents
(
)
;
}
)
;
let
expectedEvents
=
isExpectingEvents
?
MOUSE_BUTTON_EVENTS
:
[
]
;
Assert
.
deepEqual
(
mouseEvents
expectedEvents
"
Expected
to
get
the
right
mouse
events
.
"
)
;
}
async
function
prepareForToggleClick
(
browser
videoID
)
{
let
args
=
{
videoID
}
;
return
SpecialPowers
.
spawn
(
browser
[
args
]
async
args
=
>
{
let
{
videoID
}
=
args
;
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
video
.
scrollIntoView
(
{
behaviour
:
"
instant
"
}
)
;
if
(
!
video
.
controls
)
{
let
{
PictureInPictureToggleChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
actors
/
PictureInPictureChild
.
jsm
"
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
PictureInPictureToggleChild
.
isTracking
(
video
)
;
}
"
Waiting
for
PictureInPictureToggleChild
to
be
tracking
the
video
.
"
100
100
)
;
}
return
{
controls
:
video
.
controls
}
;
}
)
;
}
async
function
getToggleClientRect
(
browser
videoID
)
{
let
args
=
{
videoID
TOGGLE_ID
}
;
return
ContentTask
.
spawn
(
browser
args
async
args
=
>
{
let
{
videoID
TOGGLE_ID
}
=
args
;
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
let
toggle
=
shadowRoot
.
getElementById
(
TOGGLE_ID
)
;
let
rect
=
toggle
.
getBoundingClientRect
(
)
;
if
(
!
rect
.
width
&
&
!
rect
.
height
)
{
rect
=
video
.
getBoundingClientRect
(
)
;
}
return
{
top
:
rect
.
top
right
:
rect
.
right
left
:
rect
.
left
bottom
:
rect
.
bottom
}
;
}
)
;
}
async
function
testToggle
(
testURL
expectations
prepFn
=
async
(
)
=
>
{
}
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
testURL
}
async
browser
=
>
{
await
prepFn
(
browser
)
;
await
ensureVideosReady
(
browser
)
;
for
(
let
[
videoID
{
canToggle
policy
}
]
of
Object
.
entries
(
expectations
)
)
{
await
SimpleTest
.
promiseFocus
(
browser
)
;
info
(
Testing
video
with
id
:
{
videoID
}
)
;
await
testToggleHelper
(
browser
videoID
canToggle
policy
)
;
}
}
)
;
}
async
function
testToggleHelper
(
browser
videoID
canToggle
policy
)
{
let
{
controls
}
=
await
prepareForToggleClick
(
browser
videoID
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
#
{
videoID
}
{
type
:
"
mousemove
"
}
browser
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
#
{
videoID
}
{
type
:
"
mouseover
"
}
browser
)
;
info
(
"
Checking
toggle
policy
"
)
;
await
assertTogglePolicy
(
browser
videoID
policy
)
;
if
(
canToggle
)
{
info
(
"
Waiting
for
toggle
to
become
visible
"
)
;
await
toggleOpacityReachesThreshold
(
browser
videoID
HOVER_VIDEO_OPACITY
policy
)
;
}
let
toggleClientRect
=
await
getToggleClientRect
(
browser
videoID
)
;
info
(
"
Hovering
the
toggle
rect
now
.
"
)
;
let
toggleLeft
=
toggleClientRect
.
left
+
2
;
let
toggleTop
=
toggleClientRect
.
top
+
2
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleLeft
toggleTop
{
type
:
"
mousemove
"
}
browser
)
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleLeft
toggleTop
{
type
:
"
mouseover
"
}
browser
)
;
if
(
canToggle
)
{
info
(
"
Waiting
for
toggle
to
reach
full
opacity
"
)
;
await
toggleOpacityReachesThreshold
(
browser
videoID
HOVER_TOGGLE_OPACITY
policy
)
;
}
info
(
"
Right
-
clicking
on
toggle
.
"
)
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleLeft
toggleTop
{
button
:
2
}
browser
)
;
await
assertSawMouseEvents
(
browser
!
controls
false
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
WINDOW_TYPE
)
)
{
if
(
!
win
.
closed
)
{
ok
(
false
"
Found
a
Picture
-
in
-
Picture
window
unexpectedly
.
"
)
;
return
;
}
}
ok
(
true
"
No
Picture
-
in
-
Picture
window
found
.
"
)
;
if
(
canToggle
)
{
info
(
"
Clicking
on
toggle
and
expecting
a
Picture
-
in
-
Picture
window
to
open
"
)
;
let
domWindowOpened
=
BrowserTestUtils
.
domWindowOpened
(
null
)
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleLeft
toggleTop
{
}
browser
)
;
let
win
=
await
domWindowOpened
;
ok
(
win
"
A
Picture
-
in
-
Picture
window
opened
.
"
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
await
assertSawMouseEvents
(
browser
false
)
;
}
else
{
info
(
"
Clicking
on
toggle
and
expecting
no
Picture
-
in
-
Picture
window
opens
"
)
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleLeft
toggleTop
{
}
browser
)
;
await
assertSawMouseEvents
(
browser
!
controls
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
WINDOW_TYPE
)
)
{
if
(
!
win
.
closed
)
{
ok
(
false
"
Found
a
Picture
-
in
-
Picture
window
unexpectedly
.
"
)
;
return
;
}
}
ok
(
true
"
No
Picture
-
in
-
Picture
window
found
.
"
)
;
}
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
1
1
{
}
browser
)
;
await
assertSawMouseEvents
(
browser
true
)
;
}
async
function
promiseFullscreenEntered
(
window
asyncFn
)
{
let
entered
=
BrowserTestUtils
.
waitForEvent
(
window
"
MozDOMFullscreen
:
Entered
"
)
;
await
asyncFn
(
)
;
await
entered
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
TelemetryStopwatch
.
running
(
"
FULLSCREEN_CHANGE_MS
"
)
;
}
)
;
}
async
function
promiseFullscreenExited
(
window
asyncFn
)
{
let
exited
=
BrowserTestUtils
.
waitForEvent
(
window
"
MozDOMFullscreen
:
Exited
"
)
;
await
asyncFn
(
)
;
await
exited
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
TelemetryStopwatch
.
running
(
"
FULLSCREEN_CHANGE_MS
"
)
;
}
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
2000
)
)
;
}
}
