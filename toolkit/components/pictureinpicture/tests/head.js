"
use
strict
"
;
const
TEST_ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
http
:
/
/
example
.
com
"
)
;
const
TEST_ROOT_2
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
http
:
/
/
example
.
org
"
)
;
const
TEST_PAGE
=
TEST_ROOT
+
"
test
-
page
.
html
"
;
const
TEST_PAGE_2
=
TEST_ROOT_2
+
"
test
-
page
.
html
"
;
const
TEST_PAGE_WITH_IFRAME
=
TEST_ROOT_2
+
"
test
-
page
-
with
-
iframe
.
html
"
;
const
TEST_PAGE_WITH_SOUND
=
TEST_ROOT
+
"
test
-
page
-
with
-
sound
.
html
"
;
const
WINDOW_TYPE
=
"
Toolkit
:
PictureInPicture
"
;
const
TOGGLE_MODE_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
mode
"
;
const
TOGGLE_POSITION_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
position
"
;
const
HAS_USED_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
has
-
used
"
;
const
DEFAULT_TOGGLE_STYLES
=
{
rootID
:
"
pictureInPictureToggleExperiment
"
stages
:
{
hoverVideo
:
{
opacities
:
{
"
.
pip
-
wrapper
"
:
0
.
8
}
hidden
:
[
"
#
pictureInPictureToggleButton
"
"
.
pip
-
expanded
"
]
}
hoverToggle
:
{
opacities
:
{
"
.
pip
-
wrapper
"
:
1
.
0
}
hidden
:
[
"
#
pictureInPictureToggleButton
"
"
.
pip
-
expanded
"
]
}
}
}
;
async
function
triggerPictureInPicture
(
browser
videoID
)
{
let
domWindowOpened
=
BrowserTestUtils
.
domWindowOpenedAndLoaded
(
null
)
;
let
videoReady
=
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
event
=
new
content
.
CustomEvent
(
"
MozTogglePictureInPicture
"
{
bubbles
:
true
}
)
;
video
.
dispatchEvent
(
event
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
video
.
isCloningElementVisually
;
}
"
Video
is
being
cloned
visually
.
"
)
;
}
)
;
let
win
=
await
domWindowOpened
;
await
win
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
;
await
videoReady
;
return
win
;
}
async
function
assertShowingMessage
(
browser
videoID
expected
)
{
let
showing
=
await
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
let
pipOverlay
=
shadowRoot
.
querySelector
(
"
.
pictureInPictureOverlay
"
)
;
Assert
.
ok
(
pipOverlay
"
Should
be
able
to
find
Picture
-
in
-
Picture
overlay
.
"
)
;
let
rect
=
pipOverlay
.
getBoundingClientRect
(
)
;
return
rect
.
height
>
0
&
&
rect
.
width
>
0
;
}
)
;
Assert
.
equal
(
showing
expected
"
Video
should
be
showing
the
expected
state
.
"
)
;
}
async
function
ensureVideosReady
(
browser
)
{
info
(
Waiting
for
videos
to
be
ready
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
videos
=
this
.
content
.
document
.
querySelectorAll
(
"
video
"
)
;
for
(
let
video
of
videos
)
{
if
(
video
.
readyState
<
content
.
HTMLMediaElement
.
HAVE_ENOUGH_DATA
)
{
await
ContentTaskUtils
.
waitForEvent
(
video
"
canplay
"
)
;
}
}
}
)
;
}
async
function
toggleOpacityReachesThreshold
(
browser
videoID
stage
toggleStyles
=
DEFAULT_TOGGLE_STYLES
)
{
let
toggleMode
=
String
(
Services
.
prefs
.
getIntPref
(
TOGGLE_MODE_PREF
-
1
)
)
;
let
togglePosition
=
Services
.
prefs
.
getStringPref
(
TOGGLE_POSITION_PREF
"
right
"
)
;
let
hasUsed
=
Services
.
prefs
.
getBoolPref
(
HAS_USED_PREF
false
)
;
let
toggleStylesForStage
=
toggleStyles
.
stages
[
stage
]
;
info
(
Testing
toggle
mode
{
toggleMode
}
for
stage
{
stage
}
+
in
position
{
togglePosition
}
has
used
:
{
hasUsed
}
)
;
let
args
=
{
videoID
toggleStylesForStage
togglePosition
hasUsed
}
;
await
SpecialPowers
.
spawn
(
browser
[
args
]
async
args
=
>
{
let
{
videoID
toggleStylesForStage
}
=
args
;
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
for
(
let
hiddenElement
of
toggleStylesForStage
.
hidden
)
{
let
el
=
shadowRoot
.
querySelector
(
hiddenElement
)
;
ok
(
ContentTaskUtils
.
is_hidden
(
el
)
Expected
{
hiddenElement
}
to
be
hidden
.
)
;
}
for
(
let
opacityElement
in
toggleStylesForStage
.
opacities
)
{
let
opacityThreshold
=
toggleStylesForStage
.
opacities
[
opacityElement
]
;
let
el
=
shadowRoot
.
querySelector
(
opacityElement
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
let
opacity
=
parseFloat
(
this
.
content
.
getComputedStyle
(
el
)
.
opacity
)
;
return
opacity
>
=
opacityThreshold
;
}
Toggle
element
{
opacityElement
}
should
have
eventually
reached
+
target
opacity
{
opacityThreshold
}
100
100
)
;
}
ok
(
true
"
Toggle
reached
target
opacity
.
"
)
;
}
)
;
}
async
function
assertTogglePolicy
(
browser
videoID
policy
toggleStyles
=
DEFAULT_TOGGLE_STYLES
)
{
let
toggleID
=
toggleStyles
.
rootID
;
let
args
=
{
videoID
toggleID
policy
}
;
await
SpecialPowers
.
spawn
(
browser
[
args
]
async
args
=
>
{
let
{
videoID
toggleID
policy
}
=
args
;
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
let
controlsOverlay
=
shadowRoot
.
querySelector
(
"
.
controlsOverlay
"
)
;
let
toggle
=
shadowRoot
.
getElementById
(
toggleID
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
controlsOverlay
.
classList
.
contains
(
"
hovering
"
)
;
}
"
Waiting
for
the
hovering
state
to
be
set
on
the
video
.
"
)
;
if
(
policy
)
{
const
{
TOGGLE_POLICY_STRINGS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PictureInPictureControls
.
jsm
"
)
;
let
policyAttr
=
toggle
.
getAttribute
(
"
policy
"
)
;
Assert
.
equal
(
policyAttr
TOGGLE_POLICY_STRINGS
[
policy
]
"
The
correct
toggle
policy
is
set
.
"
)
;
}
else
{
Assert
.
ok
(
!
toggle
.
hasAttribute
(
"
policy
"
)
"
No
toggle
policy
should
be
set
.
"
)
;
}
}
)
;
}
async
function
assertSawMouseEvents
(
browser
isExpectingEvents
isExpectingClick
=
true
)
{
const
MOUSE_BUTTON_EVENTS
=
[
"
pointerdown
"
"
mousedown
"
"
pointerup
"
"
mouseup
"
]
;
if
(
isExpectingClick
)
{
MOUSE_BUTTON_EVENTS
.
push
(
"
click
"
)
;
}
let
mouseEvents
=
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
return
this
.
content
.
wrappedJSObject
.
getRecordedEvents
(
)
;
}
)
;
let
expectedEvents
=
isExpectingEvents
?
MOUSE_BUTTON_EVENTS
:
[
]
;
Assert
.
deepEqual
(
mouseEvents
expectedEvents
"
Expected
to
get
the
right
mouse
events
.
"
)
;
}
async
function
prepareForToggleClick
(
browser
videoID
)
{
await
BrowserTestUtils
.
synthesizeMouse
(
#
{
videoID
}
-
5
-
5
{
type
:
"
mousemove
"
}
browser
false
)
;
let
args
=
{
videoID
}
;
return
SpecialPowers
.
spawn
(
browser
[
args
]
async
args
=
>
{
let
{
videoID
}
=
args
;
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
video
.
scrollIntoView
(
{
behaviour
:
"
instant
"
}
)
;
if
(
!
video
.
controls
)
{
let
{
PictureInPictureToggleChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
actors
/
PictureInPictureChild
.
jsm
"
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
PictureInPictureToggleChild
.
isTracking
(
video
)
;
}
"
Waiting
for
PictureInPictureToggleChild
to
be
tracking
the
video
.
"
100
100
)
;
}
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
let
controlsOverlay
=
shadowRoot
.
querySelector
(
"
.
controlsOverlay
"
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
!
controlsOverlay
.
classList
.
contains
(
"
hovering
"
)
;
}
"
Waiting
for
the
video
to
not
be
hovered
.
"
100
100
)
;
return
{
controls
:
video
.
controls
}
;
}
)
;
}
async
function
getToggleClientRect
(
browser
videoID
toggleStyles
=
DEFAULT_TOGGLE_STYLES
)
{
let
args
=
{
videoID
toggleID
:
toggleStyles
.
rootID
}
;
return
ContentTask
.
spawn
(
browser
args
async
args
=
>
{
const
{
Rect
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Geometry
.
jsm
"
)
;
let
{
videoID
toggleID
}
=
args
;
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
let
toggle
=
shadowRoot
.
getElementById
(
toggleID
)
;
let
rect
=
Rect
.
fromRect
(
toggle
.
getBoundingClientRect
(
)
)
;
let
clickableChildren
=
toggle
.
querySelectorAll
(
"
.
clickable
"
)
;
for
(
let
child
of
clickableChildren
)
{
let
childRect
=
Rect
.
fromRect
(
child
.
getBoundingClientRect
(
)
)
;
rect
.
expandToContain
(
childRect
)
;
}
if
(
!
rect
.
width
&
&
!
rect
.
height
)
{
rect
=
video
.
getBoundingClientRect
(
)
;
}
return
{
top
:
rect
.
top
right
:
rect
.
right
left
:
rect
.
left
bottom
:
rect
.
bottom
}
;
}
)
;
}
async
function
testToggle
(
testURL
expectations
prepFn
=
async
(
)
=
>
{
}
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
testURL
}
async
browser
=
>
{
await
prepFn
(
browser
)
;
await
ensureVideosReady
(
browser
)
;
for
(
let
[
videoID
{
canToggle
policy
toggleStyles
}
]
of
Object
.
entries
(
expectations
)
)
{
await
SimpleTest
.
promiseFocus
(
browser
)
;
info
(
Testing
video
with
id
:
{
videoID
}
)
;
await
testToggleHelper
(
browser
videoID
canToggle
policy
toggleStyles
)
;
}
}
)
;
}
async
function
testToggleHelper
(
browser
videoID
canToggle
policy
toggleStyles
)
{
let
{
controls
}
=
await
prepareForToggleClick
(
browser
videoID
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
#
{
videoID
}
{
type
:
"
mousemove
"
}
browser
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
#
{
videoID
}
{
type
:
"
mouseover
"
}
browser
)
;
info
(
"
Checking
toggle
policy
"
)
;
await
assertTogglePolicy
(
browser
videoID
policy
toggleStyles
)
;
if
(
canToggle
)
{
info
(
"
Waiting
for
toggle
to
become
visible
"
)
;
await
toggleOpacityReachesThreshold
(
browser
videoID
"
hoverVideo
"
toggleStyles
)
;
}
let
toggleClientRect
=
await
getToggleClientRect
(
browser
videoID
toggleStyles
)
;
info
(
"
Hovering
the
toggle
rect
now
.
"
)
;
let
toggleLeft
=
toggleClientRect
.
left
+
2
;
let
toggleTop
=
toggleClientRect
.
top
+
2
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleLeft
toggleTop
{
type
:
"
mousemove
"
}
browser
)
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleLeft
toggleTop
{
type
:
"
mouseover
"
}
browser
)
;
if
(
canToggle
)
{
info
(
"
Waiting
for
toggle
to
reach
full
opacity
"
)
;
await
toggleOpacityReachesThreshold
(
browser
videoID
"
hoverToggle
"
toggleStyles
)
;
}
info
(
"
Right
-
clicking
on
toggle
.
"
)
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleLeft
toggleTop
{
button
:
2
}
browser
)
;
await
assertSawMouseEvents
(
browser
!
controls
false
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
WINDOW_TYPE
)
)
{
if
(
!
win
.
closed
)
{
ok
(
false
"
Found
a
Picture
-
in
-
Picture
window
unexpectedly
.
"
)
;
return
;
}
}
ok
(
true
"
No
Picture
-
in
-
Picture
window
found
.
"
)
;
if
(
canToggle
)
{
info
(
"
Clicking
on
toggle
and
expecting
a
Picture
-
in
-
Picture
window
to
open
"
)
;
let
domWindowOpened
=
BrowserTestUtils
.
domWindowOpenedAndLoaded
(
null
)
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleLeft
toggleTop
{
}
browser
)
;
let
win
=
await
domWindowOpened
;
ok
(
win
"
A
Picture
-
in
-
Picture
window
opened
.
"
)
;
await
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
video
.
isCloningElementVisually
;
}
"
Video
is
being
cloned
visually
.
"
)
;
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
await
assertSawMouseEvents
(
browser
false
)
;
}
else
{
info
(
"
Clicking
on
toggle
and
expecting
no
Picture
-
in
-
Picture
window
opens
"
)
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleLeft
toggleTop
{
}
browser
)
;
await
assertSawMouseEvents
(
browser
!
controls
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
WINDOW_TYPE
)
)
{
if
(
!
win
.
closed
)
{
ok
(
false
"
Found
a
Picture
-
in
-
Picture
window
unexpectedly
.
"
)
;
return
;
}
}
ok
(
true
"
No
Picture
-
in
-
Picture
window
found
.
"
)
;
}
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
1
1
{
}
browser
)
;
await
assertSawMouseEvents
(
browser
true
)
;
}
async
function
promiseFullscreenEntered
(
window
asyncFn
)
{
let
entered
=
BrowserTestUtils
.
waitForEvent
(
window
"
MozDOMFullscreen
:
Entered
"
)
;
await
asyncFn
(
)
;
await
entered
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
TelemetryStopwatch
.
running
(
"
FULLSCREEN_CHANGE_MS
"
)
;
}
)
;
}
async
function
promiseFullscreenExited
(
window
asyncFn
)
{
let
exited
=
BrowserTestUtils
.
waitForEvent
(
window
"
MozDOMFullscreen
:
Exited
"
)
;
await
asyncFn
(
)
;
await
exited
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
TelemetryStopwatch
.
running
(
"
FULLSCREEN_CHANGE_MS
"
)
;
}
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
2000
)
)
;
}
}
async
function
ensureMessageAndClosePiP
(
browser
videoID
pipWin
isIframe
)
{
try
{
await
assertShowingMessage
(
browser
videoID
true
)
;
}
finally
{
let
uaWidgetUpdate
=
null
;
if
(
isIframe
)
{
uaWidgetUpdate
=
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
await
ContentTaskUtils
.
waitForEvent
(
content
.
windowRoot
"
UAWidgetSetupOrChange
"
true
)
;
}
)
;
}
else
{
uaWidgetUpdate
=
BrowserTestUtils
.
waitForContentEvent
(
browser
"
UAWidgetSetupOrChange
"
true
)
;
}
await
BrowserTestUtils
.
closeWindow
(
pipWin
)
;
await
uaWidgetUpdate
;
}
}
