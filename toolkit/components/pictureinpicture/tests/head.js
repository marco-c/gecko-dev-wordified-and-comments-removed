"
use
strict
"
;
const
{
TOGGLE_POLICIES
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PictureInPictureControls
.
sys
.
mjs
"
)
;
const
TEST_ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
http
:
/
/
example
.
com
"
)
;
const
TEST_ROOT_2
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
http
:
/
/
example
.
org
"
)
;
const
TEST_PAGE
=
TEST_ROOT
+
"
test
-
page
.
html
"
;
const
TEST_PAGE_2
=
TEST_ROOT_2
+
"
test
-
page
.
html
"
;
const
TEST_PAGE_WITH_IFRAME
=
TEST_ROOT_2
+
"
test
-
page
-
with
-
iframe
.
html
"
;
const
TEST_PAGE_WITH_SOUND
=
TEST_ROOT
+
"
test
-
page
-
with
-
sound
.
html
"
;
const
TEST_PAGE_WITH_NAN_VIDEO_DURATION
=
TEST_ROOT
+
"
test
-
page
-
with
-
nan
-
video
-
duration
.
html
"
;
const
TEST_PAGE_WITH_WEBVTT
=
TEST_ROOT
+
"
test
-
page
-
with
-
webvtt
.
html
"
;
const
TEST_PAGE_MULTIPLE_CONTEXTS
=
TEST_ROOT
+
"
test
-
page
-
multiple
-
contexts
.
html
"
;
const
TEST_PAGE_TRANSPARENT_NESTED_IFRAMES
=
TEST_ROOT
+
"
test
-
transparent
-
nested
-
iframes
.
html
"
;
const
WINDOW_TYPE
=
"
Toolkit
:
PictureInPicture
"
;
const
TOGGLE_POSITION_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
position
"
;
const
DEFAULT_TOGGLE_OPACITY
=
0
.
8
;
const
HAS_USED_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
has
-
used
"
;
const
SHARED_DATA_KEY
=
"
PictureInPicture
:
SiteOverrides
"
;
const
PLAYER_URI
=
"
chrome
:
/
/
global
/
content
/
pictureinpicture
/
player
.
xhtml
"
;
const
ACCEPTABLE_DIFFERENCE
=
2
;
const
DEFAULT_TOGGLE_STYLES
=
{
rootID
:
"
pictureInPictureToggle
"
stages
:
{
hoverVideo
:
{
opacities
:
{
"
.
pip
-
wrapper
"
:
DEFAULT_TOGGLE_OPACITY
}
hidden
:
[
"
.
pip
-
expanded
"
]
}
hoverToggle
:
{
opacities
:
{
"
.
pip
-
wrapper
"
:
1
.
0
}
hidden
:
[
"
.
pip
-
expanded
"
]
}
}
}
;
async
function
triggerPictureInPicture
(
browser
videoID
triggerFn
)
{
let
domWindowOpened
=
BrowserTestUtils
.
domWindowOpenedAndLoaded
(
null
)
;
let
videoReady
=
null
;
if
(
triggerFn
)
{
await
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
video
.
focus
(
)
;
}
)
;
triggerFn
(
)
;
videoReady
=
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
video
.
isCloningElementVisually
;
}
"
Video
is
being
cloned
visually
.
"
)
;
}
)
;
}
else
{
videoReady
=
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
event
=
new
content
.
CustomEvent
(
"
MozTogglePictureInPicture
"
{
bubbles
:
true
}
)
;
video
.
dispatchEvent
(
event
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
video
.
isCloningElementVisually
;
}
"
Video
is
being
cloned
visually
.
"
)
;
}
)
;
}
let
win
=
await
domWindowOpened
;
await
Promise
.
all
(
[
SimpleTest
.
promiseFocus
(
win
)
win
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
videoReady
]
)
;
return
win
;
}
async
function
assertShowingMessage
(
browser
videoID
expected
)
{
let
showing
=
await
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
let
pipOverlay
=
shadowRoot
.
querySelector
(
"
.
pictureInPictureOverlay
"
)
;
Assert
.
ok
(
pipOverlay
"
Should
be
able
to
find
Picture
-
in
-
Picture
overlay
.
"
)
;
let
rect
=
pipOverlay
.
getBoundingClientRect
(
)
;
return
rect
.
height
>
0
&
&
rect
.
width
>
0
;
}
)
;
Assert
.
equal
(
showing
expected
"
Video
should
be
showing
the
expected
state
.
"
)
;
}
function
assertVideoIsBeingCloned
(
browser
selector
)
{
return
SpecialPowers
.
spawn
(
browser
[
selector
]
async
slctr
=
>
{
let
video
=
content
.
document
.
querySelector
(
slctr
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
video
.
isCloningElementVisually
;
}
"
Video
is
being
cloned
visually
.
"
)
;
}
)
;
}
async
function
ensureVideosReady
(
browser
)
{
info
(
Waiting
for
videos
to
be
ready
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
videos
=
this
.
content
.
document
.
querySelectorAll
(
"
video
"
)
;
for
(
let
video
of
videos
)
{
video
.
currentTime
=
0
;
if
(
video
.
readyState
<
content
.
HTMLMediaElement
.
HAVE_ENOUGH_DATA
)
{
info
(
Waiting
for
'
canplaythrough
'
for
'
{
video
.
id
}
'
)
;
await
ContentTaskUtils
.
waitForEvent
(
video
"
canplaythrough
"
)
;
}
}
}
)
;
}
async
function
toggleOpacityReachesThreshold
(
browser
videoID
stage
toggleStyles
=
DEFAULT_TOGGLE_STYLES
)
{
let
togglePosition
=
Services
.
prefs
.
getStringPref
(
TOGGLE_POSITION_PREF
"
right
"
)
;
let
hasUsed
=
Services
.
prefs
.
getBoolPref
(
HAS_USED_PREF
false
)
;
let
toggleStylesForStage
=
toggleStyles
.
stages
[
stage
]
;
info
(
Testing
toggle
for
stage
{
stage
}
+
in
position
{
togglePosition
}
has
used
:
{
hasUsed
}
)
;
let
args
=
{
videoID
toggleStylesForStage
togglePosition
hasUsed
}
;
await
SpecialPowers
.
spawn
(
browser
[
args
]
async
args
=
>
{
let
{
videoID
toggleStylesForStage
}
=
args
;
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
for
(
let
hiddenElement
of
toggleStylesForStage
.
hidden
)
{
let
el
=
shadowRoot
.
querySelector
(
hiddenElement
)
;
ok
(
ContentTaskUtils
.
is_hidden
(
el
)
Expected
{
hiddenElement
}
to
be
hidden
.
)
;
}
for
(
let
opacityElement
in
toggleStylesForStage
.
opacities
)
{
let
opacityThreshold
=
toggleStylesForStage
.
opacities
[
opacityElement
]
;
let
el
=
shadowRoot
.
querySelector
(
opacityElement
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
let
opacity
=
parseFloat
(
this
.
content
.
getComputedStyle
(
el
)
.
opacity
)
;
return
opacity
>
=
opacityThreshold
;
}
Toggle
element
{
opacityElement
}
should
have
eventually
reached
+
target
opacity
{
opacityThreshold
}
100
100
)
;
}
ok
(
true
"
Toggle
reached
target
opacity
.
"
)
;
}
)
;
}
async
function
assertTogglePolicy
(
browser
videoID
policy
toggleStyles
=
DEFAULT_TOGGLE_STYLES
)
{
let
toggleID
=
toggleStyles
.
rootID
;
let
args
=
{
videoID
toggleID
policy
}
;
await
SpecialPowers
.
spawn
(
browser
[
args
]
async
args
=
>
{
let
{
videoID
toggleID
policy
}
=
args
;
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
let
controlsOverlay
=
shadowRoot
.
querySelector
(
"
.
controlsOverlay
"
)
;
let
toggle
=
shadowRoot
.
getElementById
(
toggleID
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
controlsOverlay
.
classList
.
contains
(
"
hovering
"
)
;
}
"
Waiting
for
the
hovering
state
to
be
set
on
the
video
.
"
)
;
if
(
policy
)
{
const
{
TOGGLE_POLICY_STRINGS
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PictureInPictureControls
.
sys
.
mjs
"
)
;
let
policyAttr
=
toggle
.
getAttribute
(
"
policy
"
)
;
Assert
.
equal
(
policyAttr
TOGGLE_POLICY_STRINGS
[
policy
]
"
The
correct
toggle
policy
is
set
.
"
)
;
}
else
{
Assert
.
ok
(
!
toggle
.
hasAttribute
(
"
policy
"
)
"
No
toggle
policy
should
be
set
.
"
)
;
}
}
)
;
}
async
function
assertSawMouseEvents
(
browser
isExpectingEvents
isExpectingClick
=
true
)
{
const
MOUSE_BUTTON_EVENTS
=
[
"
pointerdown
"
"
mousedown
"
"
pointerup
"
"
mouseup
"
]
;
if
(
isExpectingClick
)
{
MOUSE_BUTTON_EVENTS
.
push
(
"
click
"
)
;
}
let
mouseEvents
=
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
return
this
.
content
.
wrappedJSObject
.
getRecordedEvents
(
)
;
}
)
;
let
expectedEvents
=
isExpectingEvents
?
MOUSE_BUTTON_EVENTS
:
[
]
;
Assert
.
deepEqual
(
mouseEvents
expectedEvents
"
Expected
to
get
the
right
mouse
events
.
"
)
;
}
async
function
prepareForToggleClick
(
browser
videoID
)
{
await
BrowserTestUtils
.
synthesizeMouse
(
#
{
videoID
}
-
5
-
5
{
type
:
"
mousemove
"
}
browser
false
)
;
let
args
=
{
videoID
}
;
return
SpecialPowers
.
spawn
(
browser
[
args
]
async
args
=
>
{
let
{
videoID
}
=
args
;
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
video
.
scrollIntoView
(
{
behaviour
:
"
instant
"
}
)
;
if
(
!
video
.
controls
)
{
let
{
PictureInPictureToggleChild
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
actors
/
PictureInPictureChild
.
sys
.
mjs
"
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
PictureInPictureToggleChild
.
isTracking
(
video
)
;
}
"
Waiting
for
PictureInPictureToggleChild
to
be
tracking
the
video
.
"
100
100
)
;
}
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
let
controlsOverlay
=
shadowRoot
.
querySelector
(
"
.
controlsOverlay
"
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
!
controlsOverlay
.
classList
.
contains
(
"
hovering
"
)
;
}
"
Waiting
for
the
video
to
not
be
hovered
.
"
100
100
)
;
return
{
controls
:
video
.
controls
}
;
}
)
;
}
async
function
getToggleClientRect
(
browser
videoID
toggleStyles
=
DEFAULT_TOGGLE_STYLES
)
{
let
args
=
{
videoID
toggleID
:
toggleStyles
.
rootID
}
;
return
ContentTask
.
spawn
(
browser
args
async
args
=
>
{
const
{
Rect
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Geometry
.
sys
.
mjs
"
)
;
let
{
videoID
toggleID
}
=
args
;
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
let
toggle
=
shadowRoot
.
getElementById
(
toggleID
)
;
let
rect
=
Rect
.
fromRect
(
toggle
.
getBoundingClientRect
(
)
)
;
let
clickableChildren
=
toggle
.
querySelectorAll
(
"
.
clickable
"
)
;
for
(
let
child
of
clickableChildren
)
{
let
childRect
=
Rect
.
fromRect
(
child
.
getBoundingClientRect
(
)
)
;
rect
.
expandToContain
(
childRect
)
;
}
if
(
!
rect
.
width
&
&
!
rect
.
height
)
{
rect
=
video
.
getBoundingClientRect
(
)
;
}
return
{
top
:
rect
.
top
left
:
rect
.
left
width
:
rect
.
width
height
:
rect
.
height
}
;
}
)
;
}
async
function
hoverToggle
(
browser
videoID
)
{
await
prepareForToggleClick
(
browser
videoID
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
#
{
videoID
}
{
type
:
"
mousemove
"
}
browser
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
#
{
videoID
}
{
type
:
"
mouseover
"
}
browser
)
;
info
(
"
Checking
toggle
policy
"
)
;
await
assertTogglePolicy
(
browser
videoID
null
)
;
let
toggleClientRect
=
await
getToggleClientRect
(
browser
videoID
)
;
info
(
"
Hovering
the
toggle
rect
now
.
"
)
;
let
toggleCenterX
=
toggleClientRect
.
left
+
toggleClientRect
.
width
/
2
;
let
toggleCenterY
=
toggleClientRect
.
top
+
toggleClientRect
.
height
/
2
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleCenterX
toggleCenterY
{
type
:
"
mousemove
"
}
browser
)
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleCenterX
toggleCenterY
{
type
:
"
mouseover
"
}
browser
)
;
}
async
function
testToggle
(
testURL
expectations
prepFn
=
async
(
)
=
>
{
}
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
testURL
}
async
browser
=
>
{
await
prepFn
(
browser
)
;
await
ensureVideosReady
(
browser
)
;
for
(
let
[
videoID
{
canToggle
policy
toggleStyles
}
]
of
Object
.
entries
(
expectations
)
)
{
await
SimpleTest
.
promiseFocus
(
browser
)
;
info
(
Testing
video
with
id
:
{
videoID
}
)
;
await
testToggleHelper
(
browser
videoID
canToggle
policy
toggleStyles
)
;
}
}
)
;
}
async
function
testToggleHelper
(
browser
videoID
canToggle
policy
toggleStyles
)
{
let
{
controls
}
=
await
prepareForToggleClick
(
browser
videoID
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
#
{
videoID
}
{
type
:
"
mousemove
"
}
browser
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
#
{
videoID
}
{
type
:
"
mouseover
"
}
browser
)
;
info
(
"
Checking
toggle
policy
"
)
;
await
assertTogglePolicy
(
browser
videoID
policy
toggleStyles
)
;
if
(
canToggle
)
{
info
(
"
Waiting
for
toggle
to
become
visible
"
)
;
await
toggleOpacityReachesThreshold
(
browser
videoID
"
hoverVideo
"
toggleStyles
)
;
}
let
toggleClientRect
=
await
getToggleClientRect
(
browser
videoID
toggleStyles
)
;
info
(
"
Hovering
the
toggle
rect
now
.
"
)
;
let
toggleCenterX
=
toggleClientRect
.
left
+
toggleClientRect
.
width
/
2
;
let
toggleCenterY
=
toggleClientRect
.
top
+
toggleClientRect
.
height
/
2
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleCenterX
toggleCenterY
{
type
:
"
mousemove
"
}
browser
)
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleCenterX
toggleCenterY
{
type
:
"
mouseover
"
}
browser
)
;
if
(
canToggle
)
{
info
(
"
Waiting
for
toggle
to
reach
full
opacity
"
)
;
await
toggleOpacityReachesThreshold
(
browser
videoID
"
hoverToggle
"
toggleStyles
)
;
}
info
(
"
Right
-
clicking
on
toggle
.
"
)
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleCenterX
toggleCenterY
{
button
:
2
}
browser
)
;
await
assertSawMouseEvents
(
browser
!
controls
false
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
WINDOW_TYPE
)
)
{
if
(
!
win
.
closed
)
{
ok
(
false
"
Found
a
Picture
-
in
-
Picture
window
unexpectedly
.
"
)
;
return
;
}
}
ok
(
true
"
No
Picture
-
in
-
Picture
window
found
.
"
)
;
if
(
canToggle
)
{
info
(
"
Clicking
on
toggle
and
expecting
a
Picture
-
in
-
Picture
window
to
open
"
)
;
let
domWindowOpened
=
BrowserTestUtils
.
domWindowOpenedAndLoaded
(
null
)
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleCenterX
toggleCenterY
{
}
browser
)
;
let
win
=
await
domWindowOpened
;
ok
(
win
"
A
Picture
-
in
-
Picture
window
opened
.
"
)
;
await
assertVideoIsBeingCloned
(
browser
"
#
"
+
videoID
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
await
assertSawMouseEvents
(
browser
false
)
;
}
else
{
info
(
"
Clicking
on
toggle
and
expecting
no
Picture
-
in
-
Picture
window
opens
"
)
;
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
toggleCenterX
toggleCenterY
{
}
browser
)
;
await
assertSawMouseEvents
(
browser
!
controls
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
WINDOW_TYPE
)
)
{
if
(
!
win
.
closed
)
{
ok
(
false
"
Found
a
Picture
-
in
-
Picture
window
unexpectedly
.
"
)
;
return
;
}
}
ok
(
true
"
No
Picture
-
in
-
Picture
window
found
.
"
)
;
}
await
BrowserTestUtils
.
synthesizeMouseAtPoint
(
1
1
{
}
browser
)
;
await
assertSawMouseEvents
(
browser
true
)
;
}
async
function
promiseFullscreenEntered
(
window
asyncFn
)
{
let
entered
=
BrowserTestUtils
.
waitForEvent
(
window
"
MozDOMFullscreen
:
Entered
"
)
;
await
asyncFn
(
)
;
await
entered
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
TelemetryStopwatch
.
running
(
"
FULLSCREEN_CHANGE_MS
"
)
;
}
)
;
}
async
function
promiseFullscreenExited
(
window
asyncFn
)
{
let
exited
=
BrowserTestUtils
.
waitForEvent
(
window
"
MozDOMFullscreen
:
Exited
"
)
;
await
asyncFn
(
)
;
await
exited
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
TelemetryStopwatch
.
running
(
"
FULLSCREEN_CHANGE_MS
"
)
;
}
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
2000
)
)
;
}
}
async
function
ensureMessageAndClosePiP
(
browser
videoID
pipWin
isIframe
)
{
try
{
await
assertShowingMessage
(
browser
videoID
true
)
;
}
finally
{
let
uaWidgetUpdate
=
null
;
if
(
isIframe
)
{
uaWidgetUpdate
=
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
await
ContentTaskUtils
.
waitForEvent
(
content
.
windowRoot
"
UAWidgetSetupOrChange
"
true
)
;
}
)
;
}
else
{
uaWidgetUpdate
=
BrowserTestUtils
.
waitForContentEvent
(
browser
"
UAWidgetSetupOrChange
"
true
)
;
}
await
BrowserTestUtils
.
closeWindow
(
pipWin
)
;
await
uaWidgetUpdate
;
}
}
async
function
isVideoPaused
(
browser
videoID
)
{
return
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
return
content
.
document
.
getElementById
(
videoID
)
.
paused
;
}
)
;
}
async
function
isVideoMuted
(
browser
videoID
)
{
return
SpecialPowers
.
spawn
(
browser
[
videoID
]
async
videoID
=
>
{
return
content
.
document
.
getElementById
(
videoID
)
.
muted
;
}
)
;
}
async
function
prepareVideosAndWebVTTTracks
(
browser
videoID
defaultTrackIndex
=
0
)
{
info
(
"
Preparing
video
and
initial
text
tracks
"
)
;
await
ensureVideosReady
(
browser
)
;
await
SpecialPowers
.
spawn
(
browser
[
{
videoID
defaultTrackIndex
}
]
async
args
=
>
{
let
video
=
content
.
document
.
getElementById
(
args
.
videoID
)
;
let
tracks
=
video
.
textTracks
;
is
(
tracks
.
length
5
"
Number
of
tracks
loaded
should
be
5
"
)
;
if
(
args
.
defaultTrackIndex
>
=
0
)
{
info
(
Loading
track
{
args
.
defaultTrackIndex
+
1
}
)
;
let
track
=
tracks
[
args
.
defaultTrackIndex
]
;
tracks
.
mode
=
"
showing
"
;
track
.
mode
=
"
showing
"
;
}
info
(
"
Playing
video
to
load
text
tracks
"
)
;
video
.
play
(
)
;
info
(
"
Pausing
video
"
)
;
video
.
pause
(
)
;
ok
(
video
.
paused
"
Video
should
be
paused
before
proceeding
with
test
"
)
;
}
)
;
}
async
function
waitForNextCue
(
browser
videoID
textTrackIndex
=
0
)
{
if
(
textTrackIndex
<
0
)
{
ok
(
false
"
Cannot
wait
for
next
cue
with
invalid
track
index
"
)
;
}
await
SpecialPowers
.
spawn
(
browser
[
{
videoID
textTrackIndex
}
]
async
args
=
>
{
let
video
=
content
.
document
.
getElementById
(
args
.
videoID
)
;
info
(
"
Playing
video
to
activate
next
cue
"
)
;
video
.
play
(
)
;
ok
(
!
video
.
paused
"
Video
is
playing
"
)
;
info
(
"
Waiting
until
cuechange
is
called
"
)
;
await
ContentTaskUtils
.
waitForEvent
(
video
.
textTracks
[
args
.
textTrackIndex
]
"
cuechange
"
)
;
info
(
"
Pausing
video
to
read
text
track
"
)
;
video
.
pause
(
)
;
ok
(
video
.
paused
"
Video
is
paused
"
)
;
}
)
;
}
function
clearSavedPosition
(
)
{
let
xulStore
=
Services
.
xulStore
;
xulStore
.
setValue
(
PLAYER_URI
"
picture
-
in
-
picture
"
"
left
"
NaN
)
;
xulStore
.
setValue
(
PLAYER_URI
"
picture
-
in
-
picture
"
"
top
"
NaN
)
;
xulStore
.
setValue
(
PLAYER_URI
"
picture
-
in
-
picture
"
"
width
"
NaN
)
;
xulStore
.
setValue
(
PLAYER_URI
"
picture
-
in
-
picture
"
"
height
"
NaN
)
;
}
function
overrideSavedPosition
(
left
top
width
height
)
{
let
xulStore
=
Services
.
xulStore
;
xulStore
.
setValue
(
PLAYER_URI
"
picture
-
in
-
picture
"
"
left
"
left
)
;
xulStore
.
setValue
(
PLAYER_URI
"
picture
-
in
-
picture
"
"
top
"
top
)
;
xulStore
.
setValue
(
PLAYER_URI
"
picture
-
in
-
picture
"
"
width
"
width
)
;
xulStore
.
setValue
(
PLAYER_URI
"
picture
-
in
-
picture
"
"
height
"
height
)
;
}
function
matches
(
expected
actual
)
{
if
(
expected
=
=
=
undefined
)
{
return
true
;
}
return
expected
=
=
=
actual
;
}
async
function
waitForTelemeryEvents
(
filter
length
process
)
{
let
{
category
:
filterCategory
method
:
filterMethod
object
:
filterObject
}
=
filter
;
let
events
=
[
]
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
events
=
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
false
)
[
process
]
;
if
(
!
events
)
{
return
false
;
}
let
filtered
=
events
.
map
(
(
[
category
method
object
value
extra
]
)
=
>
{
return
[
category
method
object
value
extra
]
;
}
)
.
filter
(
(
[
category
method
object
]
)
=
>
{
return
(
matches
(
filterCategory
category
)
&
&
matches
(
filterMethod
method
)
&
&
matches
(
filterObject
object
)
)
;
}
)
;
info
(
JSON
.
stringify
(
filtered
null
2
)
)
;
return
filtered
&
&
filtered
.
length
>
=
length
;
}
"
Waiting
for
one
create
pictureinpicture
telemetry
event
.
"
200
100
)
;
}
