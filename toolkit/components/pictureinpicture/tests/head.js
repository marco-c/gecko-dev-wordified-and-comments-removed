"
use
strict
"
;
const
TEST_ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
http
:
/
/
example
.
com
"
)
;
const
TEST_PAGE
=
TEST_ROOT
+
"
test
-
page
.
html
"
;
const
WINDOW_TYPE
=
"
Toolkit
:
PictureInPicture
"
;
async
function
triggerPictureInPicture
(
browser
videoID
)
{
let
domWindowOpened
=
BrowserTestUtils
.
domWindowOpened
(
null
)
;
let
videoReady
=
ContentTask
.
spawn
(
browser
videoID
async
videoID
=
>
{
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
event
=
new
content
.
CustomEvent
(
"
MozTogglePictureInPicture
"
{
bubbles
:
true
}
)
;
video
.
dispatchEvent
(
event
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
video
.
isCloningElementVisually
;
}
"
Video
is
being
cloned
visually
.
"
)
;
}
)
;
let
win
=
await
domWindowOpened
;
await
BrowserTestUtils
.
waitForEvent
(
win
"
load
"
)
;
await
videoReady
;
return
win
;
}
async
function
assertShowingMessage
(
browser
videoID
expected
)
{
let
showing
=
await
ContentTask
.
spawn
(
browser
videoID
async
videoID
=
>
{
let
video
=
content
.
document
.
getElementById
(
videoID
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
let
pipOverlay
=
shadowRoot
.
querySelector
(
"
.
pictureInPictureOverlay
"
)
;
ok
(
pipOverlay
"
Should
be
able
to
find
Picture
-
in
-
Picture
overlay
.
"
)
;
let
rect
=
pipOverlay
.
getBoundingClientRect
(
)
;
return
rect
.
height
>
0
&
&
rect
.
width
>
0
;
}
)
;
Assert
.
equal
(
showing
expected
"
Video
should
be
showing
the
expected
state
.
"
)
;
}
