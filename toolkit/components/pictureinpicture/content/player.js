const
{
PictureInPicture
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PictureInPicture
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
DeferredTask
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
const
AUDIO_TOGGLE_ENABLED_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
audio
-
toggle
.
enabled
"
;
const
CONTROLS_FADE_TIMEOUT_MS
=
3000
;
const
RESIZE_DEBOUNCE_RATE_MS
=
500
;
function
setupPlayer
(
id
originatingBrowser
)
{
Player
.
init
(
id
originatingBrowser
)
;
}
function
setIsPlayingState
(
isPlaying
)
{
Player
.
isPlaying
=
isPlaying
;
}
function
setIsMutedState
(
isMuted
)
{
Player
.
isMuted
=
isMuted
;
}
let
Player
=
{
WINDOW_EVENTS
:
[
"
click
"
"
contextmenu
"
"
keydown
"
"
mouseout
"
"
resize
"
"
unload
"
]
actor
:
null
resizeDebouncer
:
null
lastScreenX
:
-
1
lastScreenY
:
-
1
id
:
-
1
showingTimeout
:
null
init
(
id
originatingBrowser
)
{
this
.
id
=
id
;
let
holder
=
document
.
querySelector
(
"
.
player
-
holder
"
)
;
let
browser
=
document
.
getElementById
(
"
browser
"
)
;
browser
.
remove
(
)
;
browser
.
setAttribute
(
"
nodefaultsrc
"
"
true
"
)
;
browser
.
sameProcessAsFrameLoader
=
originatingBrowser
.
frameLoader
;
holder
.
appendChild
(
browser
)
;
this
.
actor
=
browser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
PictureInPicture
"
)
;
this
.
actor
.
sendAsyncMessage
(
"
PictureInPicture
:
SetupPlayer
"
)
;
for
(
let
eventType
of
this
.
WINDOW_EVENTS
)
{
addEventListener
(
eventType
this
)
;
}
browser
.
addEventListener
(
"
oop
-
browser
-
crashed
"
this
)
;
this
.
revealControls
(
false
)
;
if
(
Services
.
prefs
.
getBoolPref
(
AUDIO_TOGGLE_ENABLED_PREF
false
)
)
{
const
audioButton
=
document
.
getElementById
(
"
audio
"
)
;
audioButton
.
hidden
=
false
;
audioButton
.
previousElementSibling
.
hidden
=
false
;
}
Services
.
telemetry
.
setEventRecordingEnabled
(
"
pictureinpicture
"
true
)
;
this
.
resizeDebouncer
=
new
DeferredTask
(
(
)
=
>
{
this
.
recordEvent
(
"
resize
"
{
width
:
window
.
outerWidth
.
toString
(
)
height
:
window
.
outerHeight
.
toString
(
)
}
)
;
}
RESIZE_DEBOUNCE_RATE_MS
)
;
this
.
lastScreenX
=
window
.
screenX
;
this
.
lastScreenY
=
window
.
screenY
;
this
.
recordEvent
(
"
create
"
{
width
:
window
.
outerWidth
.
toString
(
)
height
:
window
.
outerHeight
.
toString
(
)
screenX
:
window
.
screenX
.
toString
(
)
screenY
:
window
.
screenY
.
toString
(
)
}
)
;
}
uninit
(
)
{
this
.
resizeDebouncer
.
disarm
(
)
;
PictureInPicture
.
unload
(
window
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
click
"
:
{
this
.
onClick
(
event
)
;
this
.
controls
.
removeAttribute
(
"
keying
"
)
;
break
;
}
case
"
contextmenu
"
:
{
event
.
preventDefault
(
)
;
break
;
}
case
"
keydown
"
:
{
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_TAB
)
{
this
.
controls
.
setAttribute
(
"
keying
"
true
)
;
}
else
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_ESCAPE
)
{
this
.
controls
.
removeAttribute
(
"
keying
"
)
;
}
break
;
}
case
"
mouseout
"
:
{
this
.
onMouseOut
(
event
)
;
break
;
}
case
"
oop
-
browser
-
crashed
"
:
{
PictureInPicture
.
closePipWindow
(
{
reason
:
"
browser
-
crash
"
}
)
;
break
;
}
case
"
resize
"
:
{
this
.
onResize
(
event
)
;
break
;
}
case
"
unload
"
:
{
this
.
uninit
(
)
;
break
;
}
}
}
onClick
(
event
)
{
switch
(
event
.
target
.
id
)
{
case
"
audio
"
:
{
if
(
this
.
isMuted
)
{
this
.
actor
.
sendAsyncMessage
(
"
PictureInPicture
:
Unmute
"
)
;
}
else
{
this
.
actor
.
sendAsyncMessage
(
"
PictureInPicture
:
Mute
"
)
;
}
break
;
}
case
"
close
"
:
{
PictureInPicture
.
closePipWindow
(
{
reason
:
"
close
-
button
"
}
)
;
break
;
}
case
"
playpause
"
:
{
if
(
!
this
.
isPlaying
)
{
this
.
actor
.
sendAsyncMessage
(
"
PictureInPicture
:
Play
"
)
;
this
.
revealControls
(
false
)
;
}
else
{
this
.
actor
.
sendAsyncMessage
(
"
PictureInPicture
:
Pause
"
)
;
this
.
revealControls
(
true
)
;
}
break
;
}
case
"
unpip
"
:
{
PictureInPicture
.
focusTabAndClosePip
(
)
;
break
;
}
}
}
onMouseOut
(
event
)
{
if
(
window
.
screenX
!
=
this
.
lastScreenX
|
|
window
.
screenY
!
=
this
.
lastScreenY
)
{
this
.
recordEvent
(
"
move
"
{
screenX
:
window
.
screenX
.
toString
(
)
screenY
:
window
.
screenY
.
toString
(
)
}
)
;
}
this
.
lastScreenX
=
window
.
screenX
;
this
.
lastScreenY
=
window
.
screenY
;
}
onResize
(
event
)
{
this
.
resizeDebouncer
.
disarm
(
)
;
this
.
resizeDebouncer
.
arm
(
)
;
}
get
controls
(
)
{
delete
this
.
controls
;
return
(
this
.
controls
=
document
.
getElementById
(
"
controls
"
)
)
;
}
_isPlaying
:
false
get
isPlaying
(
)
{
return
this
.
_isPlaying
;
}
set
isPlaying
(
isPlaying
)
{
this
.
_isPlaying
=
isPlaying
;
this
.
controls
.
classList
.
toggle
(
"
playing
"
isPlaying
)
;
}
_isMuted
:
false
get
isMuted
(
)
{
return
this
.
_isMuted
;
}
set
isMuted
(
isMuted
)
{
this
.
_isMuted
=
isMuted
;
this
.
controls
.
classList
.
toggle
(
"
muted
"
isMuted
)
;
}
recordEvent
(
type
args
)
{
Services
.
telemetry
.
recordEvent
(
"
pictureinpicture
"
type
"
player
"
this
.
id
args
)
;
}
revealControls
(
revealIndefinitely
)
{
clearTimeout
(
this
.
showingTimeout
)
;
this
.
showingTimeout
=
null
;
this
.
controls
.
setAttribute
(
"
showing
"
true
)
;
if
(
!
revealIndefinitely
)
{
this
.
showingTimeout
=
setTimeout
(
(
)
=
>
{
this
.
controls
.
removeAttribute
(
"
showing
"
)
;
}
CONTROLS_FADE_TIMEOUT_MS
)
;
}
}
}
;
