const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cr
=
Components
.
results
;
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
debug
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
DeferredTask
:
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
TelemetryStopwatch
:
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
Deprecated
:
"
resource
:
/
/
gre
/
modules
/
Deprecated
.
jsm
"
SearchStaticData
:
"
resource
:
/
/
gre
/
modules
/
SearchStaticData
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
Lz4
:
"
resource
:
/
/
gre
/
modules
/
lz4
.
js
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
gTextToSubURI
:
[
"
mozilla
.
org
/
intl
/
texttosuburi
;
1
"
"
nsITextToSubURI
"
]
gEnvironment
:
[
"
mozilla
.
org
/
process
/
environment
;
1
"
"
nsIEnvironment
"
]
gChromeReg
:
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
"
nsIChromeRegistry
"
]
}
)
;
Cu
.
importGlobalProperties
(
[
"
XMLHttpRequest
"
]
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gEncoder
"
function
(
)
{
return
new
TextEncoder
(
)
;
}
)
;
const
MODE_RDONLY
=
0x01
;
const
MODE_WRONLY
=
0x02
;
const
MODE_CREATE
=
0x08
;
const
MODE_APPEND
=
0x10
;
const
MODE_TRUNCATE
=
0x20
;
const
PERMS_FILE
=
0o644
;
const
NS_APP_SEARCH_DIR_LIST
=
"
SrchPluginsDL
"
;
const
NS_APP_DISTRIBUTION_SEARCH_DIR_LIST
=
"
SrchPluginsDistDL
"
;
const
NS_APP_USER_SEARCH_DIR
=
"
UsrSrchPlugns
"
;
const
NS_APP_SEARCH_DIR
=
"
SrchPlugns
"
;
const
NS_APP_USER_PROFILE_50_DIR
=
"
ProfD
"
;
const
APP_SEARCH_PREFIX
=
"
resource
:
/
/
search
-
plugins
/
"
;
const
SEARCH_ENGINE_TOPIC
=
"
browser
-
search
-
engine
-
modified
"
;
const
QUIT_APPLICATION_TOPIC
=
"
quit
-
application
"
;
const
SEARCH_ENGINE_REMOVED
=
"
engine
-
removed
"
;
const
SEARCH_ENGINE_ADDED
=
"
engine
-
added
"
;
const
SEARCH_ENGINE_CHANGED
=
"
engine
-
changed
"
;
const
SEARCH_ENGINE_LOADED
=
"
engine
-
loaded
"
;
const
SEARCH_ENGINE_CURRENT
=
"
engine
-
current
"
;
const
SEARCH_ENGINE_DEFAULT
=
"
engine
-
default
"
;
const
SEARCH_SERVICE_TOPIC
=
"
browser
-
search
-
service
"
;
const
SEARCH_SERVICE_CACHE_WRITTEN
=
"
write
-
cache
-
to
-
disk
-
complete
"
;
const
LAZY_SERIALIZE_DELAY
=
100
;
const
CACHE_INVALIDATION_DELAY
=
1000
;
const
CACHE_VERSION
=
1
;
const
CACHE_FILENAME
=
"
search
.
json
.
mozlz4
"
;
const
NEW_LINES
=
/
(
\
r
\
n
|
\
r
|
\
n
)
/
;
const
MAX_ICON_SIZE
=
10000
;
const
DEFAULT_QUERY_CHARSET
=
"
ISO
-
8859
-
1
"
;
const
SEARCH_BUNDLE
=
"
chrome
:
/
/
global
/
locale
/
search
/
search
.
properties
"
;
const
BRAND_BUNDLE
=
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
;
const
OPENSEARCH_NS_10
=
"
http
:
/
/
a9
.
com
/
-
/
spec
/
opensearch
/
1
.
0
/
"
;
const
OPENSEARCH_NS_11
=
"
http
:
/
/
a9
.
com
/
-
/
spec
/
opensearch
/
1
.
1
/
"
;
const
OPENSEARCH_NAMESPACES
=
[
OPENSEARCH_NS_11
OPENSEARCH_NS_10
"
http
:
/
/
a9
.
com
/
-
/
spec
/
opensearchdescription
/
1
.
1
/
"
"
http
:
/
/
a9
.
com
/
-
/
spec
/
opensearchdescription
/
1
.
0
/
"
]
;
const
OPENSEARCH_LOCALNAME
=
"
OpenSearchDescription
"
;
const
MOZSEARCH_NS_10
=
"
http
:
/
/
www
.
mozilla
.
org
/
2006
/
browser
/
search
/
"
;
const
MOZSEARCH_LOCALNAME
=
"
SearchPlugin
"
;
const
URLTYPE_SUGGEST_JSON
=
"
application
/
x
-
suggestions
+
json
"
;
const
URLTYPE_SEARCH_HTML
=
"
text
/
html
"
;
const
URLTYPE_OPENSEARCH
=
"
application
/
opensearchdescription
+
xml
"
;
const
BROWSER_SEARCH_PREF
=
"
browser
.
search
.
"
;
const
LOCALE_PREF
=
"
general
.
useragent
.
locale
"
;
const
USER_DEFINED
=
"
searchTerms
"
;
const
MOZ_PARAM_LOCALE
=
"
moz
:
locale
"
;
const
MOZ_PARAM_DIST_ID
=
"
moz
:
distributionID
"
const
MOZ_PARAM_OFFICIAL
=
"
moz
:
official
"
;
const
OS_PARAM_USER_DEFINED
=
"
searchTerms
"
;
const
OS_PARAM_INPUT_ENCODING
=
"
inputEncoding
"
;
const
OS_PARAM_LANGUAGE
=
"
language
"
;
const
OS_PARAM_OUTPUT_ENCODING
=
"
outputEncoding
"
;
const
OS_PARAM_LANGUAGE_DEF
=
"
*
"
;
const
OS_PARAM_OUTPUT_ENCODING_DEF
=
"
UTF
-
8
"
;
const
OS_PARAM_INPUT_ENCODING_DEF
=
"
UTF
-
8
"
;
const
OS_PARAM_COUNT
=
"
count
"
;
const
OS_PARAM_START_INDEX
=
"
startIndex
"
;
const
OS_PARAM_START_PAGE
=
"
startPage
"
;
const
OS_PARAM_COUNT_DEF
=
"
20
"
;
const
OS_PARAM_START_INDEX_DEF
=
"
1
"
;
const
OS_PARAM_START_PAGE_DEF
=
"
1
"
;
var
OS_UNSUPPORTED_PARAMS
=
[
[
OS_PARAM_COUNT
OS_PARAM_COUNT_DEF
]
[
OS_PARAM_START_INDEX
OS_PARAM_START_INDEX_DEF
]
[
OS_PARAM_START_PAGE
OS_PARAM_START_PAGE_DEF
]
]
;
const
SEARCH_DEFAULT_UPDATE_INTERVAL
=
7
;
const
SEARCH_GEO_DEFAULT_UPDATE_INTERVAL
=
2592000
;
const
SEARCH_LOG_PREFIX
=
"
*
*
*
Search
:
"
;
function
DO_LOG
(
aText
)
{
dump
(
SEARCH_LOG_PREFIX
+
aText
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
aText
)
;
}
var
LOG
=
function
(
)
{
}
;
if
(
AppConstants
.
DEBUG
)
{
LOG
=
function
(
aText
)
{
if
(
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
log
"
false
)
)
{
DO_LOG
(
aText
)
;
}
}
;
}
function
ERROR
(
message
resultCode
)
{
NS_ASSERT
(
false
SEARCH_LOG_PREFIX
+
message
)
;
throw
Components
.
Exception
(
message
resultCode
)
;
}
function
FAIL
(
message
resultCode
)
{
LOG
(
message
)
;
throw
Components
.
Exception
(
message
resultCode
|
|
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
function
limitURILength
(
str
len
)
{
len
=
len
|
|
140
;
if
(
str
.
length
>
len
)
return
str
.
slice
(
0
len
)
+
"
.
.
.
"
;
return
str
;
}
function
ENSURE_WARN
(
assertion
message
resultCode
)
{
NS_ASSERT
(
assertion
SEARCH_LOG_PREFIX
+
message
)
;
if
(
!
assertion
)
throw
Components
.
Exception
(
message
resultCode
)
;
}
function
loadListener
(
aChannel
aEngine
aCallback
)
{
this
.
_channel
=
aChannel
;
this
.
_bytes
=
[
]
;
this
.
_engine
=
aEngine
;
this
.
_callback
=
aCallback
;
}
loadListener
.
prototype
=
{
_callback
:
null
_channel
:
null
_countRead
:
0
_engine
:
null
_stream
:
null
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIRequestObserver
Ci
.
nsIStreamListener
Ci
.
nsIChannelEventSink
Ci
.
nsIInterfaceRequestor
Ci
.
nsIProgressEventSink
]
)
onStartRequest
:
function
SRCH_loadStartR
(
aRequest
aContext
)
{
LOG
(
"
loadListener
:
Starting
request
:
"
+
aRequest
.
name
)
;
this
.
_stream
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
}
onStopRequest
:
function
SRCH_loadStopR
(
aRequest
aContext
aStatusCode
)
{
LOG
(
"
loadListener
:
Stopping
request
:
"
+
aRequest
.
name
)
;
var
requestFailed
=
!
Components
.
isSuccessCode
(
aStatusCode
)
;
if
(
!
requestFailed
&
&
(
aRequest
instanceof
Ci
.
nsIHttpChannel
)
)
requestFailed
=
!
aRequest
.
requestSucceeded
;
if
(
requestFailed
|
|
this
.
_countRead
=
=
0
)
{
LOG
(
"
loadListener
:
request
failed
!
"
)
;
this
.
_callback
(
null
this
.
_engine
)
;
}
else
this
.
_callback
(
this
.
_bytes
this
.
_engine
)
;
this
.
_channel
=
null
;
this
.
_engine
=
null
;
}
onDataAvailable
:
function
SRCH_loadDAvailable
(
aRequest
aContext
aInputStream
aOffset
aCount
)
{
this
.
_stream
.
setInputStream
(
aInputStream
)
;
this
.
_bytes
=
this
.
_bytes
.
concat
(
this
.
_stream
.
readByteArray
(
aCount
)
)
;
this
.
_countRead
+
=
aCount
;
}
asyncOnChannelRedirect
:
function
SRCH_loadCRedirect
(
aOldChannel
aNewChannel
aFlags
callback
)
{
this
.
_channel
=
aNewChannel
;
callback
.
onRedirectVerifyCallback
(
Components
.
results
.
NS_OK
)
;
}
getInterface
:
function
SRCH_load_GI
(
aIID
)
{
return
this
.
QueryInterface
(
aIID
)
;
}
onProgress
(
aRequest
aContext
aProgress
aProgressMax
)
{
}
onStatus
(
aRequest
aContext
aStatus
aStatusArg
)
{
}
}
function
isPartnerBuild
(
)
{
try
{
let
distroID
=
Services
.
prefs
.
getCharPref
(
"
distribution
.
id
"
)
;
if
(
distroID
&
&
!
distroID
.
startsWith
(
"
mozilla
"
)
)
{
return
true
;
}
}
catch
(
e
)
{
}
return
false
;
}
function
geoSpecificDefaultsEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
browser
.
search
.
geoSpecificDefaults
"
false
)
;
}
function
migrateRegionPrefs
(
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
"
browser
.
search
.
region
"
)
)
{
return
;
}
try
{
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
search
.
isUS
"
)
&
&
!
Services
.
prefs
.
prefHasUserValue
(
"
browser
.
search
.
countryCode
"
)
)
{
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
region
"
"
US
"
)
;
}
}
catch
(
ex
)
{
}
try
{
let
countryCode
=
Services
.
prefs
.
getCharPref
(
"
browser
.
search
.
countryCode
"
)
;
if
(
!
Services
.
prefs
.
prefHasUserValue
(
"
browser
.
search
.
region
"
)
)
{
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
region
"
countryCode
)
;
}
}
catch
(
ex
)
{
}
}
function
getIsUS
(
)
{
if
(
getLocale
(
)
!
=
"
en
-
US
"
)
{
return
false
;
}
try
{
return
Services
.
prefs
.
getCharPref
(
"
browser
.
search
.
region
"
)
=
=
"
US
"
;
}
catch
(
e
)
{
}
let
isNA
=
isUSTimezone
(
)
;
LOG
(
"
getIsUS
(
)
fell
back
to
a
timezone
check
with
the
result
=
"
+
isNA
)
;
return
isNA
;
}
function
getGeoSpecificPrefName
(
basepref
)
{
if
(
!
geoSpecificDefaultsEnabled
(
)
|
|
isPartnerBuild
(
)
)
return
basepref
;
if
(
getIsUS
(
)
)
return
basepref
+
"
.
US
"
;
return
basepref
;
}
function
isUSTimezone
(
)
{
let
UTCOffset
=
(
new
Date
(
)
)
.
getTimezoneOffset
(
)
;
return
UTCOffset
>
=
150
&
&
UTCOffset
<
=
600
;
}
var
ensureKnownCountryCode
=
async
function
(
ss
)
{
let
countryCode
=
Services
.
prefs
.
getCharPref
(
"
browser
.
search
.
countryCode
"
"
"
)
;
if
(
!
countryCode
)
{
await
fetchCountryCode
(
ss
)
;
}
else
{
if
(
!
geoSpecificDefaultsEnabled
(
)
)
return
;
let
expir
=
ss
.
getGlobalAttr
(
"
searchDefaultExpir
"
)
|
|
0
;
if
(
expir
>
Date
.
now
(
)
)
{
let
defaultEngine
=
ss
.
getVerifiedGlobalAttr
(
"
searchDefault
"
)
;
let
visibleDefaultEngines
=
ss
.
getVerifiedGlobalAttr
(
"
visibleDefaultEngines
"
)
;
if
(
(
defaultEngine
|
|
defaultEngine
=
=
=
undefined
)
&
&
(
visibleDefaultEngines
|
|
visibleDefaultEngines
=
=
=
undefined
)
)
{
return
;
}
}
await
new
Promise
(
resolve
=
>
{
let
timeoutMS
=
Services
.
prefs
.
getIntPref
(
"
browser
.
search
.
geoip
.
timeout
"
)
;
let
timerId
=
setTimeout
(
(
)
=
>
{
timerId
=
null
;
resolve
(
)
;
}
timeoutMS
)
;
let
callback
=
(
)
=
>
{
clearTimeout
(
timerId
)
;
resolve
(
)
;
}
;
fetchRegionDefault
(
ss
)
.
then
(
callback
)
.
catch
(
err
=
>
{
Components
.
utils
.
reportError
(
err
)
;
callback
(
)
;
}
)
;
}
)
;
}
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_FETCH_CAUSED_SYNC_INIT
"
)
.
add
(
gInitialized
)
;
}
;
function
storeCountryCode
(
cc
)
{
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
countryCode
"
cc
)
;
if
(
!
Services
.
prefs
.
prefHasUserValue
(
"
browser
.
search
.
region
"
)
)
{
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
region
"
cc
)
;
}
let
isTimezoneUS
=
isUSTimezone
(
)
;
if
(
cc
=
=
"
US
"
&
&
!
isTimezoneUS
)
{
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_US_COUNTRY_MISMATCHED_TIMEZONE
"
)
.
add
(
1
)
;
}
if
(
cc
!
=
"
US
"
&
&
isTimezoneUS
)
{
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_US_TIMEZONE_MISMATCHED_COUNTRY
"
)
.
add
(
1
)
;
}
let
platformCC
=
Services
.
sysinfo
.
get
(
"
countryCode
"
)
;
if
(
platformCC
)
{
let
probeUSMismatched
probeNonUSMismatched
;
switch
(
Services
.
appinfo
.
OS
)
{
case
"
Darwin
"
:
probeUSMismatched
=
"
SEARCH_SERVICE_US_COUNTRY_MISMATCHED_PLATFORM_OSX
"
;
probeNonUSMismatched
=
"
SEARCH_SERVICE_NONUS_COUNTRY_MISMATCHED_PLATFORM_OSX
"
;
break
;
case
"
WINNT
"
:
probeUSMismatched
=
"
SEARCH_SERVICE_US_COUNTRY_MISMATCHED_PLATFORM_WIN
"
;
probeNonUSMismatched
=
"
SEARCH_SERVICE_NONUS_COUNTRY_MISMATCHED_PLATFORM_WIN
"
;
break
;
default
:
Cu
.
reportError
(
"
Platform
"
+
Services
.
appinfo
.
OS
+
"
has
system
country
code
but
no
search
service
telemetry
probes
"
)
;
break
;
}
if
(
probeUSMismatched
&
&
probeNonUSMismatched
)
{
if
(
cc
=
=
"
US
"
|
|
platformCC
=
=
"
US
"
)
{
Services
.
telemetry
.
getHistogramById
(
probeUSMismatched
)
.
add
(
cc
!
=
platformCC
)
;
}
else
{
Services
.
telemetry
.
getHistogramById
(
probeNonUSMismatched
)
.
add
(
cc
!
=
platformCC
)
;
}
}
}
}
function
fetchCountryCode
(
ss
)
{
const
TELEMETRY_RESULT_ENUM
=
{
SUCCESS
:
0
SUCCESS_WITHOUT_DATA
:
1
XHRTIMEOUT
:
2
ERROR
:
3
}
;
let
endpoint
=
Services
.
urlFormatter
.
formatURLPref
(
"
browser
.
search
.
geoip
.
url
"
)
;
LOG
(
"
_fetchCountryCode
starting
with
endpoint
"
+
endpoint
)
;
if
(
!
endpoint
)
{
return
Promise
.
resolve
(
)
;
}
let
startTime
=
Date
.
now
(
)
;
return
new
Promise
(
resolve
=
>
{
let
timeoutMS
=
Services
.
prefs
.
getIntPref
(
"
browser
.
search
.
geoip
.
timeout
"
)
;
let
geoipTimeoutPossible
=
true
;
let
timerId
=
setTimeout
(
(
)
=
>
{
LOG
(
"
_fetchCountryCode
:
timeout
fetching
country
information
"
)
;
if
(
geoipTimeoutPossible
)
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_TIMEOUT
"
)
.
add
(
1
)
;
timerId
=
null
;
resolve
(
)
;
}
timeoutMS
)
;
let
resolveAndReportSuccess
=
(
result
reason
)
=
>
{
if
(
result
)
{
storeCountryCode
(
result
)
;
}
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_FETCH_RESULT
"
)
.
add
(
reason
)
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
geoip
-
lookup
-
xhr
-
complete
"
)
;
if
(
timerId
)
{
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_TIMEOUT
"
)
.
add
(
0
)
;
geoipTimeoutPossible
=
false
;
}
let
callback
=
(
)
=
>
{
if
(
timerId
=
=
null
)
{
return
;
}
clearTimeout
(
timerId
)
;
resolve
(
)
;
}
;
if
(
result
&
&
geoSpecificDefaultsEnabled
(
)
)
{
fetchRegionDefault
(
ss
)
.
then
(
callback
)
.
catch
(
err
=
>
{
Components
.
utils
.
reportError
(
err
)
;
callback
(
)
;
}
)
;
}
else
{
callback
(
)
;
}
}
;
let
request
=
new
XMLHttpRequest
(
)
;
Services
.
obs
.
notifyObservers
(
request
SEARCH_SERVICE_TOPIC
"
geoip
-
lookup
-
xhr
-
starting
"
)
;
request
.
timeout
=
100000
;
request
.
onload
=
function
(
event
)
{
let
took
=
Date
.
now
(
)
-
startTime
;
let
cc
=
event
.
target
.
response
&
&
event
.
target
.
response
.
country_code
;
LOG
(
"
_fetchCountryCode
got
success
response
in
"
+
took
+
"
ms
:
"
+
cc
)
;
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_FETCH_TIME_MS
"
)
.
add
(
took
)
;
let
reason
=
cc
?
TELEMETRY_RESULT_ENUM
.
SUCCESS
:
TELEMETRY_RESULT_ENUM
.
SUCCESS_WITHOUT_DATA
;
resolveAndReportSuccess
(
cc
reason
)
;
}
;
request
.
ontimeout
=
function
(
event
)
{
LOG
(
"
_fetchCountryCode
:
XHR
finally
timed
-
out
fetching
country
information
"
)
;
resolveAndReportSuccess
(
null
TELEMETRY_RESULT_ENUM
.
XHRTIMEOUT
)
;
}
;
request
.
onerror
=
function
(
event
)
{
LOG
(
"
_fetchCountryCode
:
failed
to
retrieve
country
information
"
)
;
resolveAndReportSuccess
(
null
TELEMETRY_RESULT_ENUM
.
ERROR
)
;
}
;
request
.
open
(
"
POST
"
endpoint
true
)
;
request
.
setRequestHeader
(
"
Content
-
Type
"
"
application
/
json
"
)
;
request
.
responseType
=
"
json
"
;
request
.
send
(
"
{
}
"
)
;
}
)
;
}
var
fetchRegionDefault
=
(
ss
)
=
>
new
Promise
(
resolve
=
>
{
let
urlTemplate
=
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
.
getCharPref
(
"
geoSpecificDefaults
.
url
"
)
;
let
endpoint
=
Services
.
urlFormatter
.
formatURL
(
urlTemplate
)
;
if
(
!
endpoint
)
{
resolve
(
)
;
return
;
}
const
cohortPref
=
"
browser
.
search
.
cohort
"
;
let
cohort
=
Services
.
prefs
.
getCharPref
(
cohortPref
"
"
)
;
if
(
cohort
)
endpoint
+
=
"
/
"
+
cohort
;
LOG
(
"
fetchRegionDefault
starting
with
endpoint
"
+
endpoint
)
;
let
startTime
=
Date
.
now
(
)
;
let
request
=
new
XMLHttpRequest
(
)
;
request
.
timeout
=
100000
;
request
.
onload
=
function
(
event
)
{
let
took
=
Date
.
now
(
)
-
startTime
;
let
status
=
event
.
target
.
status
;
if
(
status
!
=
200
)
{
LOG
(
"
fetchRegionDefault
failed
with
HTTP
code
"
+
status
)
;
let
retryAfter
=
request
.
getResponseHeader
(
"
retry
-
after
"
)
;
if
(
retryAfter
)
{
ss
.
setGlobalAttr
(
"
searchDefaultExpir
"
Date
.
now
(
)
+
retryAfter
*
1000
)
;
}
resolve
(
)
;
return
;
}
let
response
=
event
.
target
.
response
|
|
{
}
;
LOG
(
"
received
"
+
response
.
toSource
(
)
)
;
if
(
response
.
cohort
)
{
Services
.
prefs
.
setCharPref
(
cohortPref
response
.
cohort
)
;
}
else
{
Services
.
prefs
.
clearUserPref
(
cohortPref
)
;
}
if
(
response
.
settings
&
&
response
.
settings
.
searchDefault
)
{
let
defaultEngine
=
response
.
settings
.
searchDefault
;
ss
.
setVerifiedGlobalAttr
(
"
searchDefault
"
defaultEngine
)
;
LOG
(
"
fetchRegionDefault
saved
searchDefault
:
"
+
defaultEngine
)
;
}
if
(
response
.
settings
&
&
response
.
settings
.
visibleDefaultEngines
)
{
let
visibleDefaultEngines
=
response
.
settings
.
visibleDefaultEngines
;
let
string
=
visibleDefaultEngines
.
join
(
"
"
)
;
ss
.
setVerifiedGlobalAttr
(
"
visibleDefaultEngines
"
string
)
;
LOG
(
"
fetchRegionDefault
saved
visibleDefaultEngines
:
"
+
string
)
;
}
let
interval
=
response
.
interval
|
|
SEARCH_GEO_DEFAULT_UPDATE_INTERVAL
;
let
milliseconds
=
interval
*
1000
;
ss
.
setGlobalAttr
(
"
searchDefaultExpir
"
Date
.
now
(
)
+
milliseconds
)
;
LOG
(
"
fetchRegionDefault
got
success
response
in
"
+
took
+
"
ms
"
)
;
resolve
(
)
;
}
;
request
.
ontimeout
=
function
(
event
)
{
LOG
(
"
fetchRegionDefault
:
XHR
finally
timed
-
out
"
)
;
resolve
(
)
;
}
;
request
.
onerror
=
function
(
event
)
{
LOG
(
"
fetchRegionDefault
:
failed
to
retrieve
territory
default
information
"
)
;
resolve
(
)
;
}
;
request
.
open
(
"
GET
"
endpoint
true
)
;
request
.
setRequestHeader
(
"
Content
-
Type
"
"
application
/
json
"
)
;
request
.
responseType
=
"
json
"
;
request
.
send
(
)
;
}
)
;
function
getVerificationHash
(
aName
)
{
let
disclaimer
=
"
By
modifying
this
file
I
agree
that
I
am
doing
so
"
+
"
only
within
appName
itself
using
official
user
-
driven
search
"
+
"
engine
selection
processes
and
in
a
way
which
does
not
circumvent
"
+
"
user
consent
.
I
acknowledge
that
any
attempt
to
change
this
file
"
+
"
from
outside
of
appName
is
a
malicious
act
and
will
be
responded
"
+
"
to
accordingly
.
"
let
salt
=
OS
.
Path
.
basename
(
OS
.
Constants
.
Path
.
profileDir
)
+
aName
+
disclaimer
.
replace
(
/
\
appName
/
g
Services
.
appinfo
.
name
)
;
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
let
data
=
converter
.
convertToByteArray
(
salt
{
}
)
;
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA256
)
;
hasher
.
update
(
data
data
.
length
)
;
return
hasher
.
finish
(
true
)
;
}
function
closeSafeOutputStream
(
aFOS
)
{
if
(
aFOS
instanceof
Ci
.
nsISafeOutputStream
)
{
try
{
aFOS
.
finish
(
)
;
return
;
}
catch
(
e
)
{
}
}
aFOS
.
close
(
)
;
}
function
makeURI
(
aURLSpec
aCharset
)
{
try
{
return
Services
.
io
.
newURI
(
aURLSpec
aCharset
)
;
}
catch
(
ex
)
{
}
return
null
;
}
function
makeChannel
(
url
)
{
try
{
let
uri
=
typeof
url
=
=
"
string
"
?
Services
.
io
.
newURI
(
url
)
:
url
;
return
Services
.
io
.
newChannelFromURI2
(
uri
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
null
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
Ci
.
nsIContentPolicy
.
TYPE_OTHER
)
;
}
catch
(
ex
)
{
}
return
null
;
}
function
getDir
(
aKey
aIFace
)
{
if
(
!
aKey
)
FAIL
(
"
getDir
requires
a
directory
key
!
"
)
;
return
Services
.
dirsvc
.
get
(
aKey
aIFace
|
|
Ci
.
nsIFile
)
;
}
function
getLocale
(
)
{
return
Services
.
locale
.
getRequestedLocale
(
)
;
}
function
getLocalizedPref
(
aPrefName
aDefault
)
{
const
nsIPLS
=
Ci
.
nsIPrefLocalizedString
;
try
{
return
Services
.
prefs
.
getComplexValue
(
aPrefName
nsIPLS
)
.
data
;
}
catch
(
ex
)
{
}
return
aDefault
;
}
function
getBoolPref
(
aName
aDefault
)
{
if
(
Services
.
prefs
.
getPrefType
(
aName
)
!
=
Ci
.
nsIPrefBranch
.
PREF_BOOL
)
return
aDefault
;
return
Services
.
prefs
.
getBoolPref
(
aName
)
;
}
function
sanitizeName
(
aName
)
{
const
maxLength
=
60
;
const
minLength
=
1
;
var
name
=
aName
.
toLowerCase
(
)
;
name
=
name
.
replace
(
/
\
s
+
/
g
"
-
"
)
;
name
=
name
.
replace
(
/
[
^
-
a
-
z0
-
9
]
/
g
"
"
)
;
if
(
name
.
length
<
minLength
)
name
=
Math
.
random
(
)
.
toString
(
36
)
.
replace
(
/
^
.
*
\
.
/
"
"
)
;
return
name
.
substring
(
0
maxLength
)
;
}
function
getMozParamPref
(
prefName
)
{
let
branch
=
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
+
"
param
.
"
)
;
return
encodeURIComponent
(
branch
.
getCharPref
(
prefName
)
)
;
}
var
gInitialized
=
false
;
function
notifyAction
(
aEngine
aVerb
)
{
if
(
gInitialized
)
{
LOG
(
"
NOTIFY
:
Engine
:
\
"
"
+
aEngine
.
name
+
"
\
"
;
Verb
:
\
"
"
+
aVerb
+
"
\
"
"
)
;
Services
.
obs
.
notifyObservers
(
aEngine
SEARCH_ENGINE_TOPIC
aVerb
)
;
}
}
function
parseJsonFromStream
(
aInputStream
)
{
const
json
=
Cc
[
"
mozilla
.
org
/
dom
/
json
;
1
"
]
.
createInstance
(
Ci
.
nsIJSON
)
;
const
data
=
json
.
decodeFromStream
(
aInputStream
aInputStream
.
available
(
)
)
;
return
data
;
}
function
QueryParameter
(
aName
aValue
aPurpose
)
{
if
(
!
aName
|
|
(
aValue
=
=
null
)
)
FAIL
(
"
missing
name
or
value
for
QueryParameter
!
"
)
;
this
.
name
=
aName
;
this
.
value
=
aValue
;
this
.
purpose
=
aPurpose
;
}
function
ParamSubstitution
(
aParamValue
aSearchTerms
aEngine
)
{
const
PARAM_REGEXP
=
/
\
{
(
(
?
:
\
w
+
:
)
?
\
w
+
)
(
\
?
?
)
\
}
/
g
;
return
aParamValue
.
replace
(
PARAM_REGEXP
function
(
match
name
optional
)
{
if
(
name
=
=
USER_DEFINED
)
return
aSearchTerms
;
if
(
name
=
=
OS_PARAM_INPUT_ENCODING
)
return
aEngine
.
queryCharset
;
if
(
name
.
startsWith
(
"
moz
:
"
)
&
&
aEngine
.
_isDefault
)
{
if
(
name
=
=
MOZ_PARAM_LOCALE
)
return
getLocale
(
)
;
if
(
name
=
=
MOZ_PARAM_DIST_ID
)
{
return
Services
.
prefs
.
getCharPref
(
BROWSER_SEARCH_PREF
+
"
distributionID
"
Services
.
appinfo
.
distributionID
|
|
"
"
)
;
}
if
(
name
=
=
MOZ_PARAM_OFFICIAL
)
{
if
(
Services
.
prefs
.
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
official
"
AppConstants
.
MOZ_OFFICIAL_BRANDING
)
)
return
"
official
"
;
return
"
unofficial
"
;
}
}
if
(
name
=
=
OS_PARAM_LANGUAGE
)
return
getLocale
(
)
|
|
OS_PARAM_LANGUAGE_DEF
;
if
(
name
=
=
OS_PARAM_OUTPUT_ENCODING
)
return
OS_PARAM_OUTPUT_ENCODING_DEF
;
if
(
optional
)
return
"
"
;
for
(
let
param
of
OS_UNSUPPORTED_PARAMS
)
{
if
(
name
=
=
param
[
0
]
)
return
param
[
1
]
;
}
return
match
;
}
)
;
}
function
EngineURL
(
aType
aMethod
aTemplate
aResultDomain
)
{
if
(
!
aType
|
|
!
aMethod
|
|
!
aTemplate
)
FAIL
(
"
missing
type
method
or
template
for
EngineURL
!
"
)
;
var
method
=
aMethod
.
toUpperCase
(
)
;
var
type
=
aType
.
toLowerCase
(
)
;
if
(
method
!
=
"
GET
"
&
&
method
!
=
"
POST
"
)
FAIL
(
"
method
passed
to
EngineURL
must
be
\
"
GET
\
"
or
\
"
POST
\
"
"
)
;
this
.
type
=
type
;
this
.
method
=
method
;
this
.
params
=
[
]
;
this
.
rels
=
[
]
;
this
.
mozparams
=
{
}
;
var
templateURI
=
makeURI
(
aTemplate
)
;
if
(
!
templateURI
)
FAIL
(
"
new
EngineURL
:
template
is
not
a
valid
URI
!
"
Cr
.
NS_ERROR_FAILURE
)
;
switch
(
templateURI
.
scheme
)
{
case
"
http
"
:
case
"
https
"
:
this
.
template
=
aTemplate
;
break
;
default
:
FAIL
(
"
new
EngineURL
:
template
uses
invalid
scheme
!
"
Cr
.
NS_ERROR_FAILURE
)
;
}
this
.
resultDomain
=
aResultDomain
|
|
templateURI
.
host
;
if
(
this
.
resultDomain
.
startsWith
(
"
www
.
"
)
)
{
this
.
resultDomain
=
this
.
resultDomain
.
substr
(
4
)
;
}
}
EngineURL
.
prototype
=
{
addParam
:
function
SRCH_EURL_addParam
(
aName
aValue
aPurpose
)
{
this
.
params
.
push
(
new
QueryParameter
(
aName
aValue
aPurpose
)
)
;
}
_addMozParam
:
function
SRCH_EURL__addMozParam
(
aObj
)
{
aObj
.
mozparam
=
true
;
this
.
mozparams
[
aObj
.
name
]
=
aObj
;
}
getSubmission
:
function
SRCH_EURL_getSubmission
(
aSearchTerms
aEngine
aPurpose
)
{
var
url
=
ParamSubstitution
(
this
.
template
aSearchTerms
aEngine
)
;
var
purpose
=
aPurpose
|
|
"
searchbar
"
;
if
(
!
this
.
params
.
some
(
p
=
>
p
.
purpose
!
=
=
undefined
&
&
p
.
purpose
=
=
purpose
)
)
purpose
=
"
searchbar
"
;
var
dataString
=
"
"
;
for
(
var
i
=
0
;
i
<
this
.
params
.
length
;
+
+
i
)
{
var
param
=
this
.
params
[
i
]
;
if
(
param
.
purpose
!
=
=
undefined
&
&
param
.
purpose
!
=
purpose
)
continue
;
var
value
=
ParamSubstitution
(
param
.
value
aSearchTerms
aEngine
)
;
dataString
+
=
(
i
>
0
?
"
&
"
:
"
"
)
+
param
.
name
+
"
=
"
+
value
;
}
var
postData
=
null
;
if
(
this
.
method
=
=
"
GET
"
)
{
if
(
url
.
indexOf
(
"
?
"
)
=
=
-
1
&
&
dataString
)
url
+
=
"
?
"
;
url
+
=
dataString
;
}
else
if
(
this
.
method
=
=
"
POST
"
)
{
var
stringStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stringStream
.
data
=
dataString
;
postData
=
Cc
[
"
mozilla
.
org
/
network
/
mime
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIMIMEInputStream
)
;
postData
.
addHeader
(
"
Content
-
Type
"
"
application
/
x
-
www
-
form
-
urlencoded
"
)
;
postData
.
setData
(
stringStream
)
;
}
return
new
Submission
(
Services
.
io
.
newURI
(
url
)
postData
)
;
}
_getTermsParameterName
:
function
SRCH_EURL__getTermsParameterName
(
)
{
let
queryParam
=
this
.
params
.
find
(
p
=
>
p
.
value
=
=
"
{
"
+
USER_DEFINED
+
"
}
"
)
;
return
queryParam
?
queryParam
.
name
:
"
"
;
}
_hasRelation
:
function
SRC_EURL__hasRelation
(
aRel
)
{
return
this
.
rels
.
some
(
e
=
>
e
=
=
aRel
.
toLowerCase
(
)
)
;
}
_initWithJSON
:
function
SRC_EURL__initWithJSON
(
aJson
aEngine
)
{
if
(
!
aJson
.
params
)
return
;
this
.
rels
=
aJson
.
rels
;
for
(
let
i
=
0
;
i
<
aJson
.
params
.
length
;
+
+
i
)
{
let
param
=
aJson
.
params
[
i
]
;
if
(
param
.
mozparam
)
{
if
(
param
.
condition
=
=
"
pref
"
)
{
let
value
=
getMozParamPref
(
param
.
pref
)
;
this
.
addParam
(
param
.
name
value
)
;
}
this
.
_addMozParam
(
param
)
;
}
else
this
.
addParam
(
param
.
name
param
.
value
param
.
purpose
|
|
undefined
)
;
}
}
toJSON
:
function
SRCH_EURL_toJSON
(
)
{
var
json
=
{
template
:
this
.
template
rels
:
this
.
rels
resultDomain
:
this
.
resultDomain
}
;
if
(
this
.
type
!
=
URLTYPE_SEARCH_HTML
)
json
.
type
=
this
.
type
;
if
(
this
.
method
!
=
"
GET
"
)
json
.
method
=
this
.
method
;
function
collapseMozParams
(
aParam
)
{
return
this
.
mozparams
[
aParam
.
name
]
|
|
aParam
;
}
json
.
params
=
this
.
params
.
map
(
collapseMozParams
this
)
;
return
json
;
}
}
;
function
Engine
(
aLocation
aIsReadOnly
)
{
this
.
_readOnly
=
aIsReadOnly
;
this
.
_urls
=
[
]
;
this
.
_metaData
=
{
}
;
let
file
uri
;
if
(
typeof
aLocation
=
=
"
string
"
)
{
this
.
_shortName
=
aLocation
;
}
else
if
(
aLocation
instanceof
Ci
.
nsIFile
)
{
if
(
!
aIsReadOnly
)
{
this
.
_filePath
=
aLocation
.
persistentDescriptor
;
}
file
=
aLocation
;
}
else
if
(
aLocation
instanceof
Ci
.
nsIURI
)
{
switch
(
aLocation
.
scheme
)
{
case
"
https
"
:
case
"
http
"
:
case
"
ftp
"
:
case
"
data
"
:
case
"
file
"
:
case
"
resource
"
:
case
"
chrome
"
:
uri
=
aLocation
;
break
;
default
:
ERROR
(
"
Invalid
URI
passed
to
the
nsISearchEngine
constructor
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
}
else
ERROR
(
"
Engine
location
is
neither
a
File
nor
a
URI
object
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
if
(
!
this
.
_shortName
)
{
let
shortName
;
if
(
file
)
{
shortName
=
file
.
leafName
;
}
else
if
(
uri
&
&
uri
instanceof
Ci
.
nsIURL
)
{
if
(
aIsReadOnly
|
|
(
gEnvironment
.
get
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
&
&
uri
.
scheme
=
=
"
resource
"
)
)
{
shortName
=
uri
.
fileName
;
}
}
if
(
shortName
&
&
shortName
.
endsWith
(
"
.
xml
"
)
)
{
this
.
_shortName
=
shortName
.
slice
(
0
-
4
)
;
}
this
.
_loadPath
=
this
.
getAnonymizedLoadPath
(
file
uri
)
;
if
(
!
shortName
&
&
!
aIsReadOnly
)
{
return
;
}
if
(
this
.
_isDefault
|
|
(
uri
&
&
uri
.
spec
.
startsWith
(
APP_SEARCH_PREFIX
)
)
)
{
this
.
_id
=
"
[
app
]
/
"
+
this
.
_shortName
+
"
.
xml
"
;
}
else
if
(
!
aIsReadOnly
)
{
this
.
_id
=
"
[
profile
]
/
"
+
this
.
_shortName
+
"
.
xml
"
;
}
else
{
LOG
(
"
Setting
_id
to
full
path
for
engine
from
"
+
this
.
_loadPath
)
;
this
.
_id
=
file
?
file
.
path
:
uri
.
spec
;
}
}
}
Engine
.
prototype
=
{
_metaData
:
null
_data
:
null
_readOnly
:
true
_loadPath
:
null
_description
:
"
"
_engineToUpdate
:
null
_hasPreferredIcon
:
null
_name
:
null
_queryCharset
:
null
__searchForm
:
null
get
_searchForm
(
)
{
return
this
.
__searchForm
;
}
set
_searchForm
(
aValue
)
{
if
(
/
^
https
?
:
/
i
.
test
(
aValue
)
)
this
.
__searchForm
=
aValue
;
else
LOG
(
"
_searchForm
:
Invalid
URL
dropped
for
"
+
this
.
_name
|
|
"
the
current
engine
"
)
;
}
_confirm
:
false
_useNow
:
false
_installCallback
:
null
_updateInterval
:
null
_updateURL
:
null
_iconUpdateURL
:
null
_extensionID
:
null
_initFromFile
:
function
SRCH_ENG_initFromFile
(
file
)
{
if
(
!
file
|
|
!
file
.
exists
(
)
)
FAIL
(
"
File
must
exist
before
calling
initFromFile
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
var
fileInStream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fileInStream
.
init
(
file
MODE_RDONLY
PERMS_FILE
false
)
;
var
domParser
=
Cc
[
"
mozilla
.
org
/
xmlextras
/
domparser
;
1
"
]
.
createInstance
(
Ci
.
nsIDOMParser
)
;
var
doc
=
domParser
.
parseFromStream
(
fileInStream
"
UTF
-
8
"
file
.
fileSize
"
text
/
xml
"
)
;
this
.
_data
=
doc
.
documentElement
;
fileInStream
.
close
(
)
;
this
.
_initFromData
(
)
;
}
async
_asyncInitFromFile
(
file
)
{
if
(
!
file
|
|
!
(
await
OS
.
File
.
exists
(
file
.
path
)
)
)
FAIL
(
"
File
must
exist
before
calling
initFromFile
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
let
fileURI
=
Services
.
io
.
newFileURI
(
file
)
;
await
this
.
_retrieveSearchXMLData
(
fileURI
.
spec
)
;
this
.
_initFromData
(
)
;
}
_initFromURIAndLoad
:
function
SRCH_ENG_initFromURIAndLoad
(
uri
)
{
ENSURE_WARN
(
uri
instanceof
Ci
.
nsIURI
"
Must
have
URI
when
calling
_initFromURIAndLoad
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
LOG
(
"
_initFromURIAndLoad
:
Downloading
engine
from
:
\
"
"
+
uri
.
spec
+
"
\
"
.
"
)
;
var
chan
=
makeChannel
(
uri
)
;
if
(
this
.
_engineToUpdate
&
&
(
chan
instanceof
Ci
.
nsIHttpChannel
)
)
{
var
lastModified
=
this
.
_engineToUpdate
.
getAttr
(
"
updatelastmodified
"
)
;
if
(
lastModified
)
chan
.
setRequestHeader
(
"
If
-
Modified
-
Since
"
lastModified
false
)
;
}
this
.
_uri
=
uri
;
var
listener
=
new
loadListener
(
chan
this
this
.
_onLoad
)
;
chan
.
notificationCallbacks
=
listener
;
chan
.
asyncOpen2
(
listener
)
;
}
async
_asyncInitFromURI
(
uri
)
{
LOG
(
"
_asyncInitFromURI
:
Loading
engine
from
:
\
"
"
+
uri
.
spec
+
"
\
"
.
"
)
;
await
this
.
_retrieveSearchXMLData
(
uri
.
spec
)
;
this
.
_initFromData
(
)
;
}
_retrieveSearchXMLData
:
function
SRCH_ENG__retrieveSearchXMLData
(
aURL
)
{
return
new
Promise
(
resolve
=
>
{
let
request
=
Cc
[
"
mozilla
.
org
/
xmlextras
/
xmlhttprequest
;
1
"
]
.
createInstance
(
Ci
.
nsIXMLHttpRequest
)
;
request
.
overrideMimeType
(
"
text
/
xml
"
)
;
request
.
onload
=
(
aEvent
)
=
>
{
let
responseXML
=
aEvent
.
target
.
responseXML
;
this
.
_data
=
responseXML
.
documentElement
;
resolve
(
)
;
}
;
request
.
onerror
=
function
(
aEvent
)
{
resolve
(
)
;
}
;
request
.
open
(
"
GET
"
aURL
true
)
;
request
.
send
(
)
;
}
)
;
}
_initFromURISync
:
function
SRCH_ENG_initFromURISync
(
uri
)
{
ENSURE_WARN
(
uri
instanceof
Ci
.
nsIURI
"
Must
have
URI
when
calling
_initFromURISync
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
ENSURE_WARN
(
uri
.
schemeIs
(
"
resource
"
)
"
_initFromURISync
called
for
non
-
resource
URI
"
Cr
.
NS_ERROR_FAILURE
)
;
LOG
(
"
_initFromURISync
:
Loading
engine
from
:
\
"
"
+
uri
.
spec
+
"
\
"
.
"
)
;
var
chan
=
makeChannel
(
uri
)
;
var
stream
=
chan
.
open2
(
)
;
var
parser
=
Cc
[
"
mozilla
.
org
/
xmlextras
/
domparser
;
1
"
]
.
createInstance
(
Ci
.
nsIDOMParser
)
;
var
doc
=
parser
.
parseFromStream
(
stream
"
UTF
-
8
"
stream
.
available
(
)
"
text
/
xml
"
)
;
this
.
_data
=
doc
.
documentElement
;
this
.
_initFromData
(
)
;
}
_getURLOfType
:
function
SRCH_ENG__getURLOfType
(
aType
aRel
)
{
for
(
let
url
of
this
.
_urls
)
{
if
(
url
.
type
=
=
aType
&
&
(
!
aRel
|
|
url
.
_hasRelation
(
aRel
)
)
)
return
url
;
}
return
null
;
}
_confirmAddEngine
:
function
SRCH_SVC_confirmAddEngine
(
)
{
var
stringBundle
=
Services
.
strings
.
createBundle
(
SEARCH_BUNDLE
)
;
var
titleMessage
=
stringBundle
.
GetStringFromName
(
"
addEngineConfirmTitle
"
)
;
var
dialogMessage
=
stringBundle
.
formatStringFromName
(
"
addEngineConfirmation
"
[
this
.
_name
this
.
_uri
.
host
]
2
)
;
var
checkboxMessage
=
null
;
if
(
!
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
noCurrentEngine
"
false
)
)
checkboxMessage
=
stringBundle
.
GetStringFromName
(
"
addEngineAsCurrentText
"
)
;
var
addButtonLabel
=
stringBundle
.
GetStringFromName
(
"
addEngineAddButtonLabel
"
)
;
var
ps
=
Services
.
prompt
;
var
buttonFlags
=
(
ps
.
BUTTON_TITLE_IS_STRING
*
ps
.
BUTTON_POS_0
)
+
(
ps
.
BUTTON_TITLE_CANCEL
*
ps
.
BUTTON_POS_1
)
+
ps
.
BUTTON_POS_0_DEFAULT
;
var
checked
=
{
value
:
false
}
;
var
confirm
=
!
ps
.
confirmEx
(
null
titleMessage
dialogMessage
buttonFlags
addButtonLabel
null
null
checkboxMessage
checked
)
;
return
{
confirmed
:
confirm
useNow
:
checked
.
value
}
;
}
_onLoad
:
function
SRCH_ENG_onLoad
(
aBytes
aEngine
)
{
function
onError
(
errorCode
=
Ci
.
nsISearchInstallCallback
.
ERROR_UNKNOWN_FAILURE
)
{
if
(
aEngine
.
_installCallback
)
{
aEngine
.
_installCallback
(
errorCode
)
;
}
}
function
promptError
(
strings
=
{
}
error
=
undefined
)
{
onError
(
error
)
;
if
(
aEngine
.
_engineToUpdate
)
{
LOG
(
"
updating
"
+
aEngine
.
_engineToUpdate
.
name
+
"
failed
"
)
;
return
;
}
var
brandBundle
=
Services
.
strings
.
createBundle
(
BRAND_BUNDLE
)
;
var
brandName
=
brandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
var
searchBundle
=
Services
.
strings
.
createBundle
(
SEARCH_BUNDLE
)
;
var
msgStringName
=
strings
.
error
|
|
"
error_loading_engine_msg2
"
;
var
titleStringName
=
strings
.
title
|
|
"
error_loading_engine_title
"
;
var
title
=
searchBundle
.
GetStringFromName
(
titleStringName
)
;
var
text
=
searchBundle
.
formatStringFromName
(
msgStringName
[
brandName
aEngine
.
_location
]
2
)
;
Services
.
ww
.
getNewPrompter
(
null
)
.
alert
(
title
text
)
;
}
if
(
!
aBytes
)
{
promptError
(
)
;
return
;
}
var
parser
=
Cc
[
"
mozilla
.
org
/
xmlextras
/
domparser
;
1
"
]
.
createInstance
(
Ci
.
nsIDOMParser
)
;
var
doc
=
parser
.
parseFromBuffer
(
aBytes
aBytes
.
length
"
text
/
xml
"
)
;
aEngine
.
_data
=
doc
.
documentElement
;
try
{
aEngine
.
_initFromData
(
)
;
}
catch
(
ex
)
{
LOG
(
"
_onLoad
:
Failed
to
init
engine
!
\
n
"
+
ex
)
;
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_FILE_CORRUPTED
)
{
promptError
(
{
error
:
"
error_invalid_engine_msg2
"
title
:
"
error_invalid_format_title
"
}
)
;
}
else
{
promptError
(
)
;
}
return
;
}
if
(
aEngine
.
_engineToUpdate
)
{
let
engineToUpdate
=
aEngine
.
_engineToUpdate
.
wrappedJSObject
;
aEngine
.
_shortName
=
engineToUpdate
.
_shortName
;
Object
.
keys
(
engineToUpdate
.
_metaData
)
.
forEach
(
key
=
>
{
aEngine
.
setAttr
(
key
engineToUpdate
.
getAttr
(
key
)
)
;
}
)
;
aEngine
.
_loadPath
=
engineToUpdate
.
_loadPath
;
aEngine
.
setAttr
(
"
updatelastmodified
"
(
new
Date
(
)
)
.
toUTCString
(
)
)
;
if
(
!
aEngine
.
_iconURI
&
&
engineToUpdate
.
_iconURI
)
aEngine
.
_iconURI
=
engineToUpdate
.
_iconURI
;
}
else
{
if
(
Services
.
search
.
getEngineByName
(
aEngine
.
name
)
)
{
if
(
aEngine
.
_confirm
)
{
promptError
(
{
error
:
"
error_duplicate_engine_msg
"
title
:
"
error_invalid_engine_title
"
}
Ci
.
nsISearchInstallCallback
.
ERROR_DUPLICATE_ENGINE
)
;
}
else
{
onError
(
Ci
.
nsISearchInstallCallback
.
ERROR_DUPLICATE_ENGINE
)
;
}
LOG
(
"
_onLoad
:
duplicate
engine
found
bailing
"
)
;
return
;
}
if
(
aEngine
.
_confirm
)
{
var
confirmation
=
aEngine
.
_confirmAddEngine
(
)
;
LOG
(
"
_onLoad
:
confirm
is
"
+
confirmation
.
confirmed
+
"
;
useNow
is
"
+
confirmation
.
useNow
)
;
if
(
!
confirmation
.
confirmed
)
{
onError
(
)
;
return
;
}
aEngine
.
_useNow
=
confirmation
.
useNow
;
}
aEngine
.
_shortName
=
sanitizeName
(
aEngine
.
name
)
;
aEngine
.
_loadPath
=
aEngine
.
getAnonymizedLoadPath
(
null
aEngine
.
_uri
)
;
aEngine
.
setAttr
(
"
loadPathHash
"
getVerificationHash
(
aEngine
.
_loadPath
)
)
;
}
notifyAction
(
aEngine
SEARCH_ENGINE_LOADED
)
;
if
(
aEngine
.
_installCallback
)
{
aEngine
.
_installCallback
(
)
;
}
}
_getIconKey
:
function
SRCH_ENG_getIconKey
(
aWidth
aHeight
)
{
let
keyObj
=
{
width
:
aWidth
height
:
aHeight
}
;
return
JSON
.
stringify
(
keyObj
)
;
}
_addIconToMap
:
function
SRCH_ENG_addIconToMap
(
aWidth
aHeight
aURISpec
)
{
if
(
aWidth
=
=
16
&
&
aHeight
=
=
16
)
{
return
;
}
this
.
_iconMapObj
=
this
.
_iconMapObj
|
|
{
}
;
let
key
=
this
.
_getIconKey
(
aWidth
aHeight
)
;
this
.
_iconMapObj
[
key
]
=
aURISpec
;
}
_setIcon
:
function
SRCH_ENG_setIcon
(
aIconURL
aIsPreferred
aWidth
aHeight
)
{
var
uri
=
makeURI
(
aIconURL
)
;
if
(
!
uri
)
return
;
LOG
(
"
_setIcon
:
Setting
icon
url
\
"
"
+
limitURILength
(
uri
.
spec
)
+
"
\
"
for
engine
\
"
"
+
this
.
name
+
"
\
"
.
"
)
;
switch
(
uri
.
scheme
)
{
case
"
resource
"
:
case
"
chrome
"
:
if
(
!
this
.
_isDefault
)
{
return
;
}
case
"
data
"
:
if
(
!
this
.
_hasPreferredIcon
|
|
aIsPreferred
)
{
this
.
_iconURI
=
uri
;
notifyAction
(
this
SEARCH_ENGINE_CHANGED
)
;
this
.
_hasPreferredIcon
=
aIsPreferred
;
}
if
(
aWidth
&
&
aHeight
)
{
this
.
_addIconToMap
(
aWidth
aHeight
aIconURL
)
}
break
;
case
"
http
"
:
case
"
https
"
:
case
"
ftp
"
:
LOG
(
"
_setIcon
:
Downloading
icon
:
\
"
"
+
uri
.
spec
+
"
\
"
for
engine
:
\
"
"
+
this
.
name
+
"
\
"
"
)
;
var
chan
=
makeChannel
(
uri
)
;
let
iconLoadCallback
=
function
(
aByteArray
aEngine
)
{
if
(
aEngine
.
_hasPreferredIcon
&
&
!
aIsPreferred
)
return
;
if
(
!
aByteArray
|
|
aByteArray
.
length
>
MAX_ICON_SIZE
)
{
LOG
(
"
iconLoadCallback
:
load
failed
or
the
icon
was
too
large
!
"
)
;
return
;
}
let
type
=
chan
.
contentType
;
if
(
!
type
.
startsWith
(
"
image
/
"
)
)
type
=
"
image
/
x
-
icon
"
;
let
dataURL
=
"
data
:
"
+
type
+
"
;
base64
"
+
btoa
(
String
.
fromCharCode
.
apply
(
null
aByteArray
)
)
;
aEngine
.
_iconURI
=
makeURI
(
dataURL
)
;
if
(
aWidth
&
&
aHeight
)
{
aEngine
.
_addIconToMap
(
aWidth
aHeight
dataURL
)
}
notifyAction
(
aEngine
SEARCH_ENGINE_CHANGED
)
;
aEngine
.
_hasPreferredIcon
=
aIsPreferred
;
}
;
var
engineToSet
=
this
.
_engineToUpdate
|
|
this
;
var
listener
=
new
loadListener
(
chan
engineToSet
iconLoadCallback
)
;
chan
.
notificationCallbacks
=
listener
;
chan
.
asyncOpen2
(
listener
)
;
break
;
}
}
_initFromData
:
function
SRCH_ENG_initFromData
(
)
{
ENSURE_WARN
(
this
.
_data
"
Can
'
t
init
an
engine
with
no
data
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
let
element
=
this
.
_data
;
if
(
(
element
.
localName
=
=
MOZSEARCH_LOCALNAME
&
&
element
.
namespaceURI
=
=
MOZSEARCH_NS_10
)
|
|
(
element
.
localName
=
=
OPENSEARCH_LOCALNAME
&
&
OPENSEARCH_NAMESPACES
.
indexOf
(
element
.
namespaceURI
)
!
=
-
1
)
)
{
LOG
(
"
_init
:
Initing
search
plugin
from
"
+
this
.
_location
)
;
this
.
_parse
(
)
;
}
else
{
Cu
.
reportError
(
"
Invalid
search
plugin
due
to
namespace
not
matching
.
"
)
;
FAIL
(
this
.
_location
+
"
is
not
a
valid
search
plugin
.
"
Cr
.
NS_ERROR_FILE_CORRUPTED
)
;
}
this
.
_data
=
null
;
}
_initFromMetadata
:
function
SRCH_ENG_initMetaData
(
aName
aParams
)
{
ENSURE_WARN
(
!
this
.
_readOnly
"
Can
'
t
call
_initFromMetaData
on
a
readonly
engine
!
"
Cr
.
NS_ERROR_FAILURE
)
;
let
method
=
aParams
.
method
|
|
"
GET
"
;
this
.
_urls
.
push
(
new
EngineURL
(
URLTYPE_SEARCH_HTML
method
aParams
.
template
)
)
;
if
(
aParams
.
suggestURL
)
{
this
.
_urls
.
push
(
new
EngineURL
(
URLTYPE_SUGGEST_JSON
"
GET
"
aParams
.
suggestURL
)
)
;
}
this
.
_name
=
aName
;
this
.
alias
=
aParams
.
alias
;
this
.
_description
=
aParams
.
description
;
this
.
_setIcon
(
aParams
.
iconURL
true
)
;
this
.
_extensionID
=
aParams
.
extensionID
;
}
_parseURL
:
function
SRCH_ENG_parseURL
(
aElement
)
{
var
type
=
aElement
.
getAttribute
(
"
type
"
)
;
var
method
=
aElement
.
getAttribute
(
"
method
"
)
|
|
"
GET
"
;
var
template
=
aElement
.
getAttribute
(
"
template
"
)
;
var
resultDomain
=
aElement
.
getAttribute
(
"
resultdomain
"
)
;
try
{
var
url
=
new
EngineURL
(
type
method
template
resultDomain
)
;
}
catch
(
ex
)
{
FAIL
(
"
_parseURL
:
failed
to
add
"
+
template
+
"
as
a
URL
"
Cr
.
NS_ERROR_FAILURE
)
;
}
if
(
aElement
.
hasAttribute
(
"
rel
"
)
)
url
.
rels
=
aElement
.
getAttribute
(
"
rel
"
)
.
toLowerCase
(
)
.
split
(
/
\
s
+
/
)
;
for
(
var
i
=
0
;
i
<
aElement
.
childNodes
.
length
;
+
+
i
)
{
var
param
=
aElement
.
childNodes
[
i
]
;
if
(
param
.
localName
=
=
"
Param
"
)
{
try
{
url
.
addParam
(
param
.
getAttribute
(
"
name
"
)
param
.
getAttribute
(
"
value
"
)
)
;
}
catch
(
ex
)
{
LOG
(
"
_parseURL
:
Url
element
has
an
invalid
param
"
)
;
}
}
else
if
(
param
.
localName
=
=
"
MozParam
"
&
&
this
.
_isDefault
)
{
var
value
;
let
condition
=
param
.
getAttribute
(
"
condition
"
)
;
if
(
!
condition
)
{
let
engineLoc
=
this
.
_location
;
let
paramName
=
param
.
getAttribute
(
"
name
"
)
;
LOG
(
"
_parseURL
:
MozParam
(
"
+
paramName
+
"
)
without
a
condition
attribute
found
parsing
engine
:
"
+
engineLoc
)
;
continue
;
}
switch
(
condition
)
{
case
"
purpose
"
:
url
.
addParam
(
param
.
getAttribute
(
"
name
"
)
param
.
getAttribute
(
"
value
"
)
param
.
getAttribute
(
"
purpose
"
)
)
;
break
;
case
"
pref
"
:
try
{
value
=
getMozParamPref
(
param
.
getAttribute
(
"
pref
"
)
value
)
;
url
.
addParam
(
param
.
getAttribute
(
"
name
"
)
value
)
;
url
.
_addMozParam
(
{
"
pref
"
:
param
.
getAttribute
(
"
pref
"
)
"
name
"
:
param
.
getAttribute
(
"
name
"
)
"
condition
"
:
"
pref
"
}
)
;
}
catch
(
e
)
{
}
break
;
default
:
let
engineLoc
=
this
.
_location
;
let
paramName
=
param
.
getAttribute
(
"
name
"
)
;
LOG
(
"
_parseURL
:
MozParam
(
"
+
paramName
+
"
)
has
an
unknown
condition
:
"
+
condition
+
"
.
Found
parsing
engine
:
"
+
engineLoc
)
;
break
;
}
}
}
this
.
_urls
.
push
(
url
)
;
}
_parseImage
:
function
SRCH_ENG_parseImage
(
aElement
)
{
LOG
(
"
_parseImage
:
Image
textContent
:
\
"
"
+
limitURILength
(
aElement
.
textContent
)
+
"
\
"
"
)
;
let
width
=
parseInt
(
aElement
.
getAttribute
(
"
width
"
)
10
)
;
let
height
=
parseInt
(
aElement
.
getAttribute
(
"
height
"
)
10
)
;
let
isPrefered
=
width
=
=
16
&
&
height
=
=
16
;
if
(
isNaN
(
width
)
|
|
isNaN
(
height
)
|
|
width
<
=
0
|
|
height
<
=
0
)
{
LOG
(
"
OpenSearch
image
element
must
have
positive
width
and
height
.
"
)
;
return
;
}
this
.
_setIcon
(
aElement
.
textContent
isPrefered
width
height
)
;
}
_parse
:
function
SRCH_ENG_parse
(
)
{
var
doc
=
this
.
_data
;
this
.
_queryCharset
=
OS_PARAM_INPUT_ENCODING_DEF
;
for
(
var
i
=
0
;
i
<
doc
.
childNodes
.
length
;
+
+
i
)
{
var
child
=
doc
.
childNodes
[
i
]
;
switch
(
child
.
localName
)
{
case
"
ShortName
"
:
this
.
_name
=
child
.
textContent
;
break
;
case
"
Description
"
:
this
.
_description
=
child
.
textContent
;
break
;
case
"
Url
"
:
try
{
this
.
_parseURL
(
child
)
;
}
catch
(
ex
)
{
LOG
(
"
_parse
:
failed
to
parse
URL
child
:
"
+
ex
)
;
}
break
;
case
"
Image
"
:
this
.
_parseImage
(
child
)
;
break
;
case
"
InputEncoding
"
:
this
.
_queryCharset
=
child
.
textContent
.
toUpperCase
(
)
;
break
;
case
"
SearchForm
"
:
this
.
_searchForm
=
child
.
textContent
;
break
;
case
"
UpdateUrl
"
:
this
.
_updateURL
=
child
.
textContent
;
break
;
case
"
UpdateInterval
"
:
this
.
_updateInterval
=
parseInt
(
child
.
textContent
)
;
break
;
case
"
IconUpdateUrl
"
:
this
.
_iconUpdateURL
=
child
.
textContent
;
break
;
case
"
ExtensionID
"
:
this
.
_extensionID
=
child
.
textContent
;
break
;
}
}
if
(
!
this
.
name
|
|
(
this
.
_urls
.
length
=
=
0
)
)
FAIL
(
"
_parse
:
No
name
or
missing
URL
!
"
Cr
.
NS_ERROR_FAILURE
)
;
if
(
!
this
.
supportsResponseType
(
URLTYPE_SEARCH_HTML
)
)
FAIL
(
"
_parse
:
No
text
/
html
result
type
!
"
Cr
.
NS_ERROR_FAILURE
)
;
}
_initWithJSON
:
function
SRCH_ENG__initWithJSON
(
aJson
)
{
this
.
_name
=
aJson
.
_name
;
this
.
_shortName
=
aJson
.
_shortName
;
this
.
_loadPath
=
aJson
.
_loadPath
;
this
.
_description
=
aJson
.
description
;
this
.
_hasPreferredIcon
=
aJson
.
_hasPreferredIcon
=
=
undefined
;
this
.
_queryCharset
=
aJson
.
queryCharset
|
|
DEFAULT_QUERY_CHARSET
;
this
.
__searchForm
=
aJson
.
__searchForm
;
this
.
_updateInterval
=
aJson
.
_updateInterval
|
|
null
;
this
.
_updateURL
=
aJson
.
_updateURL
|
|
null
;
this
.
_iconUpdateURL
=
aJson
.
_iconUpdateURL
|
|
null
;
this
.
_readOnly
=
aJson
.
_readOnly
=
=
undefined
;
this
.
_iconURI
=
makeURI
(
aJson
.
_iconURL
)
;
this
.
_iconMapObj
=
aJson
.
_iconMapObj
;
this
.
_metaData
=
aJson
.
_metaData
|
|
{
}
;
if
(
aJson
.
filePath
)
{
this
.
_filePath
=
aJson
.
filePath
;
}
if
(
aJson
.
dirPath
)
{
this
.
_dirPath
=
aJson
.
dirPath
;
this
.
_dirLastModifiedTime
=
aJson
.
dirLastModifiedTime
;
}
if
(
aJson
.
extensionID
)
{
this
.
_extensionID
=
aJson
.
extensionID
;
}
for
(
let
i
=
0
;
i
<
aJson
.
_urls
.
length
;
+
+
i
)
{
let
url
=
aJson
.
_urls
[
i
]
;
let
engineURL
=
new
EngineURL
(
url
.
type
|
|
URLTYPE_SEARCH_HTML
url
.
method
|
|
"
GET
"
url
.
template
url
.
resultDomain
|
|
undefined
)
;
engineURL
.
_initWithJSON
(
url
this
)
;
this
.
_urls
.
push
(
engineURL
)
;
}
}
toJSON
:
function
SRCH_ENG_toJSON
(
)
{
var
json
=
{
_name
:
this
.
_name
_shortName
:
this
.
_shortName
_loadPath
:
this
.
_loadPath
description
:
this
.
description
__searchForm
:
this
.
__searchForm
_iconURL
:
this
.
_iconURL
_iconMapObj
:
this
.
_iconMapObj
_metaData
:
this
.
_metaData
_urls
:
this
.
_urls
}
;
if
(
this
.
_updateInterval
)
json
.
_updateInterval
=
this
.
_updateInterval
;
if
(
this
.
_updateURL
)
json
.
_updateURL
=
this
.
_updateURL
;
if
(
this
.
_iconUpdateURL
)
json
.
_iconUpdateURL
=
this
.
_iconUpdateURL
;
if
(
!
this
.
_hasPreferredIcon
)
json
.
_hasPreferredIcon
=
this
.
_hasPreferredIcon
;
if
(
this
.
queryCharset
!
=
DEFAULT_QUERY_CHARSET
)
json
.
queryCharset
=
this
.
queryCharset
;
if
(
!
this
.
_readOnly
)
json
.
_readOnly
=
this
.
_readOnly
;
if
(
this
.
_filePath
)
{
json
.
filePath
=
this
.
_filePath
;
}
if
(
this
.
_dirPath
)
{
json
.
dirPath
=
this
.
_dirPath
;
json
.
dirLastModifiedTime
=
this
.
_dirLastModifiedTime
;
}
if
(
this
.
_extensionID
)
{
json
.
extensionID
=
this
.
_extensionID
;
}
return
json
;
}
setAttr
(
name
val
)
{
this
.
_metaData
[
name
]
=
val
;
}
getAttr
(
name
)
{
return
this
.
_metaData
[
name
]
|
|
undefined
;
}
get
alias
(
)
{
return
this
.
getAttr
(
"
alias
"
)
;
}
set
alias
(
val
)
{
var
value
=
val
?
val
.
trim
(
)
:
null
;
this
.
setAttr
(
"
alias
"
value
)
;
notifyAction
(
this
SEARCH_ENGINE_CHANGED
)
;
}
get
identifier
(
)
{
return
this
.
_isDefault
?
this
.
_shortName
:
null
;
}
get
description
(
)
{
return
this
.
_description
;
}
get
hidden
(
)
{
return
this
.
getAttr
(
"
hidden
"
)
|
|
false
;
}
set
hidden
(
val
)
{
var
value
=
!
!
val
;
if
(
value
!
=
this
.
hidden
)
{
this
.
setAttr
(
"
hidden
"
value
)
;
notifyAction
(
this
SEARCH_ENGINE_CHANGED
)
;
}
}
get
iconURI
(
)
{
if
(
this
.
_iconURI
)
return
this
.
_iconURI
;
return
null
;
}
get
_iconURL
(
)
{
if
(
!
this
.
_iconURI
)
return
"
"
;
return
this
.
_iconURI
.
spec
;
}
get
_location
(
)
{
if
(
this
.
_uri
)
return
this
.
_uri
.
spec
;
return
this
.
_loadPath
;
}
getAnonymizedLoadPath
(
file
uri
)
{
const
NS_XPCOM_CURRENT_PROCESS_DIR
=
"
XCurProcD
"
;
const
NS_APP_USER_PROFILE_50_DIR
=
"
ProfD
"
;
const
XRE_APP_DISTRIBUTION_DIR
=
"
XREAppDist
"
;
const
knownDirs
=
{
app
:
NS_XPCOM_CURRENT_PROCESS_DIR
profile
:
NS_APP_USER_PROFILE_50_DIR
distribution
:
XRE_APP_DISTRIBUTION_DIR
}
;
let
leafName
=
this
.
_shortName
;
if
(
!
leafName
)
return
"
null
"
;
leafName
+
=
"
.
xml
"
;
let
prefix
=
"
"
suffix
=
"
"
;
if
(
!
file
)
{
if
(
uri
.
schemeIs
(
"
resource
"
)
)
{
uri
=
makeURI
(
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsISubstitutingProtocolHandler
)
.
resolveURI
(
uri
)
)
;
}
let
scheme
=
uri
.
scheme
;
let
packageName
=
"
"
;
if
(
scheme
=
=
"
chrome
"
)
{
packageName
=
uri
.
hostPort
;
uri
=
gChromeReg
.
convertChromeURL
(
uri
)
;
}
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
let
appPath
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
.
getSubstitution
(
"
android
"
)
;
if
(
appPath
)
{
appPath
=
appPath
.
spec
;
let
spec
=
uri
.
spec
;
if
(
spec
.
includes
(
appPath
)
)
{
let
appURI
=
Services
.
io
.
newFileURI
(
getDir
(
knownDirs
.
app
)
)
;
uri
=
Services
.
io
.
newURI
(
spec
.
replace
(
appPath
appURI
.
spec
)
)
;
}
}
}
if
(
uri
instanceof
Ci
.
nsINestedURI
)
{
prefix
=
"
jar
:
"
;
suffix
=
"
!
"
+
packageName
+
"
/
"
+
leafName
;
uri
=
uri
.
innermostURI
;
}
if
(
uri
instanceof
Ci
.
nsIFileURL
)
{
file
=
uri
.
file
;
}
else
{
let
path
=
"
[
"
+
scheme
+
"
]
"
;
if
(
/
^
(
?
:
https
?
|
ftp
)
/
.
test
(
scheme
)
)
{
path
+
=
uri
.
host
;
}
return
path
+
"
/
"
+
leafName
;
}
}
let
id
;
let
enginePath
=
file
.
path
;
for
(
let
key
in
knownDirs
)
{
let
path
;
try
{
path
=
getDir
(
knownDirs
[
key
]
)
.
path
;
}
catch
(
e
)
{
continue
;
}
if
(
enginePath
.
startsWith
(
path
)
)
{
id
=
"
[
"
+
key
+
"
]
"
+
enginePath
.
slice
(
path
.
length
)
.
replace
(
/
\
\
/
g
"
/
"
)
;
break
;
}
}
if
(
!
id
)
id
=
"
[
other
]
/
"
+
file
.
leafName
;
return
prefix
+
id
+
suffix
;
}
get
_isDefault
(
)
{
if
(
!
this
.
_shortName
)
return
false
;
if
(
/
^
(
?
:
jar
:
)
?
(
?
:
\
[
app
\
]
|
\
[
distribution
\
]
)
/
.
test
(
this
.
_loadPath
)
)
return
true
;
if
(
!
Services
.
prefs
.
prefHasUserValue
(
LOCALE_PREF
)
&
&
!
gEnvironment
.
get
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
)
return
false
;
if
(
!
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
.
hasSubstitution
(
"
search
-
plugins
"
)
)
return
false
;
let
uri
=
makeURI
(
APP_SEARCH_PREFIX
+
this
.
_shortName
+
"
.
xml
"
)
;
if
(
this
.
getAnonymizedLoadPath
(
null
uri
)
=
=
this
.
_loadPath
)
{
LOG
(
"
_isDefault
pretending
"
+
this
.
_loadPath
+
"
is
a
default
engine
"
)
;
return
true
;
}
return
false
;
}
get
_hasUpdates
(
)
{
let
selfURL
=
this
.
_getURLOfType
(
URLTYPE_OPENSEARCH
"
self
"
)
;
return
!
!
(
this
.
_updateURL
|
|
this
.
_iconUpdateURL
|
|
selfURL
)
;
}
get
name
(
)
{
return
this
.
_name
;
}
get
searchForm
(
)
{
return
this
.
_getSearchFormWithPurpose
(
)
;
}
_getSearchFormWithPurpose
(
aPurpose
=
"
"
)
{
var
searchFormURL
=
this
.
_getURLOfType
(
URLTYPE_SEARCH_HTML
"
searchform
"
)
;
if
(
searchFormURL
)
{
let
submission
=
searchFormURL
.
getSubmission
(
"
"
this
aPurpose
)
;
if
(
!
submission
.
postData
)
return
submission
.
uri
.
spec
;
}
if
(
!
this
.
_searchForm
)
{
var
htmlUrl
=
this
.
_getURLOfType
(
URLTYPE_SEARCH_HTML
)
;
ENSURE_WARN
(
htmlUrl
"
Engine
has
no
HTML
URL
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
this
.
_searchForm
=
makeURI
(
htmlUrl
.
template
)
.
prePath
;
}
return
ParamSubstitution
(
this
.
_searchForm
"
"
this
)
;
}
get
queryCharset
(
)
{
if
(
this
.
_queryCharset
)
return
this
.
_queryCharset
;
return
this
.
_queryCharset
=
"
windows
-
1252
"
;
}
addParam
:
function
SRCH_ENG_addParam
(
aName
aValue
aResponseType
)
{
if
(
!
aName
|
|
(
aValue
=
=
null
)
)
FAIL
(
"
missing
name
or
value
for
nsISearchEngine
:
:
addParam
!
"
)
;
ENSURE_WARN
(
!
this
.
_readOnly
"
called
nsISearchEngine
:
:
addParam
on
a
read
-
only
engine
!
"
Cr
.
NS_ERROR_FAILURE
)
;
if
(
!
aResponseType
)
aResponseType
=
URLTYPE_SEARCH_HTML
;
var
url
=
this
.
_getURLOfType
(
aResponseType
)
;
if
(
!
url
)
FAIL
(
"
Engine
object
has
no
URL
for
response
type
"
+
aResponseType
Cr
.
NS_ERROR_FAILURE
)
;
url
.
addParam
(
aName
aValue
)
;
}
get
_defaultMobileResponseType
(
)
{
let
type
=
URLTYPE_SEARCH_HTML
;
let
sysInfo
=
Cc
[
"
mozilla
.
org
/
system
-
info
;
1
"
]
.
getService
(
Ci
.
nsIPropertyBag2
)
;
let
isTablet
=
sysInfo
.
get
(
"
tablet
"
)
;
if
(
isTablet
&
&
this
.
supportsResponseType
(
"
application
/
x
-
moz
-
tabletsearch
"
)
)
{
type
=
"
application
/
x
-
moz
-
tabletsearch
"
;
}
else
if
(
!
isTablet
&
&
this
.
supportsResponseType
(
"
application
/
x
-
moz
-
phonesearch
"
)
)
{
type
=
"
application
/
x
-
moz
-
phonesearch
"
;
}
delete
this
.
_defaultMobileResponseType
;
return
this
.
_defaultMobileResponseType
=
type
;
}
get
_isWhiteListed
(
)
{
let
url
=
this
.
_getURLOfType
(
URLTYPE_SEARCH_HTML
)
.
template
;
let
hostname
=
makeURI
(
url
)
.
host
;
let
whitelist
=
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
.
getCharPref
(
"
reset
.
whitelist
"
)
.
split
(
"
"
)
;
if
(
whitelist
.
includes
(
hostname
)
)
{
LOG
(
"
The
hostname
"
+
hostname
+
"
is
white
listed
"
+
"
we
won
'
t
show
the
search
reset
prompt
"
)
;
return
true
;
}
return
false
;
}
getSubmission
:
function
SRCH_ENG_getSubmission
(
aData
aResponseType
aPurpose
)
{
if
(
!
aResponseType
)
{
aResponseType
=
AppConstants
.
platform
=
=
"
android
"
?
this
.
_defaultMobileResponseType
:
URLTYPE_SEARCH_HTML
;
}
if
(
aResponseType
=
=
URLTYPE_SEARCH_HTML
&
&
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
.
getBoolPref
(
"
reset
.
enabled
"
)
&
&
this
.
name
=
=
Services
.
search
.
currentEngine
.
name
&
&
!
this
.
_isDefault
&
&
this
.
name
!
=
Services
.
search
.
originalDefaultEngine
.
name
&
&
(
!
this
.
getAttr
(
"
loadPathHash
"
)
|
|
this
.
getAttr
(
"
loadPathHash
"
)
!
=
getVerificationHash
(
this
.
_loadPath
)
)
&
&
!
this
.
_isWhiteListed
)
{
let
url
=
"
about
:
searchreset
"
;
let
data
=
[
]
;
if
(
aData
)
data
.
push
(
"
data
=
"
+
encodeURIComponent
(
aData
)
)
;
if
(
aPurpose
)
data
.
push
(
"
purpose
=
"
+
aPurpose
)
;
if
(
data
.
length
)
url
+
=
"
?
"
+
data
.
join
(
"
&
"
)
;
return
new
Submission
(
makeURI
(
url
)
)
;
}
var
url
=
this
.
_getURLOfType
(
aResponseType
)
;
if
(
!
url
)
return
null
;
if
(
!
aData
)
{
return
new
Submission
(
makeURI
(
this
.
_getSearchFormWithPurpose
(
aPurpose
)
)
)
;
}
LOG
(
"
getSubmission
:
In
data
:
\
"
"
+
aData
+
"
\
"
;
Purpose
:
\
"
"
+
aPurpose
+
"
\
"
"
)
;
var
data
=
"
"
;
try
{
data
=
gTextToSubURI
.
ConvertAndEscape
(
this
.
queryCharset
aData
)
;
}
catch
(
ex
)
{
LOG
(
"
getSubmission
:
Falling
back
to
default
queryCharset
!
"
)
;
data
=
gTextToSubURI
.
ConvertAndEscape
(
DEFAULT_QUERY_CHARSET
aData
)
;
}
LOG
(
"
getSubmission
:
Out
data
:
\
"
"
+
data
+
"
\
"
"
)
;
return
url
.
getSubmission
(
data
this
aPurpose
)
;
}
supportsResponseType
:
function
SRCH_ENG_supportsResponseType
(
type
)
{
return
(
this
.
_getURLOfType
(
type
)
!
=
null
)
;
}
getResultDomain
:
function
SRCH_ENG_getResultDomain
(
aResponseType
)
{
if
(
!
aResponseType
)
{
aResponseType
=
AppConstants
.
platform
=
=
"
android
"
?
this
.
_defaultMobileResponseType
:
URLTYPE_SEARCH_HTML
;
}
LOG
(
"
getResultDomain
:
responseType
:
\
"
"
+
aResponseType
+
"
\
"
"
)
;
let
url
=
this
.
_getURLOfType
(
aResponseType
)
;
if
(
url
)
return
url
.
resultDomain
;
return
"
"
;
}
getURLParsingInfo
(
)
{
let
responseType
=
AppConstants
.
platform
=
=
"
android
"
?
this
.
_defaultMobileResponseType
:
URLTYPE_SEARCH_HTML
;
LOG
(
"
getURLParsingInfo
:
responseType
:
\
"
"
+
responseType
+
"
\
"
"
)
;
let
url
=
this
.
_getURLOfType
(
responseType
)
;
if
(
!
url
|
|
url
.
method
!
=
"
GET
"
)
{
return
null
;
}
let
termsParameterName
=
url
.
_getTermsParameterName
(
)
;
if
(
!
termsParameterName
)
{
return
null
;
}
let
templateUrl
=
Services
.
io
.
newURI
(
url
.
template
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
return
{
mainDomain
:
templateUrl
.
host
path
:
templateUrl
.
filePath
.
toLowerCase
(
)
termsParameterName
}
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISearchEngine
]
)
get
wrappedJSObject
(
)
{
return
this
;
}
getIconURLBySize
:
function
SRCH_ENG_getIconURLBySize
(
aWidth
aHeight
)
{
if
(
aWidth
=
=
16
&
&
aHeight
=
=
16
)
return
this
.
_iconURL
;
if
(
!
this
.
_iconMapObj
)
return
null
;
let
key
=
this
.
_getIconKey
(
aWidth
aHeight
)
;
if
(
key
in
this
.
_iconMapObj
)
{
return
this
.
_iconMapObj
[
key
]
;
}
return
null
;
}
getIcons
:
function
SRCH_ENG_getIcons
(
)
{
let
result
=
[
]
;
if
(
this
.
_iconURL
)
result
.
push
(
{
width
:
16
height
:
16
url
:
this
.
_iconURL
}
)
;
if
(
!
this
.
_iconMapObj
)
return
result
;
for
(
let
key
of
Object
.
keys
(
this
.
_iconMapObj
)
)
{
let
iconSize
=
JSON
.
parse
(
key
)
;
result
.
push
(
{
width
:
iconSize
.
width
height
:
iconSize
.
height
url
:
this
.
_iconMapObj
[
key
]
}
)
;
}
return
result
;
}
speculativeConnect
:
function
SRCH_ENG_speculativeConnect
(
options
)
{
if
(
!
options
|
|
!
options
.
window
)
{
Cu
.
reportError
(
"
invalid
options
arg
passed
to
nsISearchEngine
.
speculativeConnect
"
)
;
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
let
connector
=
Services
.
io
.
QueryInterface
(
Components
.
interfaces
.
nsISpeculativeConnect
)
;
let
searchURI
=
this
.
getSubmission
(
"
dummy
"
)
.
uri
;
let
callbacks
=
options
.
window
.
QueryInterface
(
Components
.
interfaces
.
nsIInterfaceRequestor
)
.
getInterface
(
Components
.
interfaces
.
nsIWebNavigation
)
.
QueryInterface
(
Components
.
interfaces
.
nsILoadContext
)
;
let
attrs
=
options
.
originAttributes
;
if
(
!
attrs
)
{
attrs
=
options
.
window
.
document
.
docShell
.
getOriginAttributes
(
)
;
}
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
searchURI
attrs
)
;
connector
.
speculativeConnect2
(
searchURI
principal
callbacks
)
;
if
(
this
.
supportsResponseType
(
URLTYPE_SUGGEST_JSON
)
)
{
let
suggestURI
=
this
.
getSubmission
(
"
dummy
"
URLTYPE_SUGGEST_JSON
)
.
uri
;
if
(
suggestURI
.
prePath
!
=
searchURI
.
prePath
)
connector
.
speculativeConnect2
(
suggestURI
principal
callbacks
)
;
}
}
}
;
function
Submission
(
aURI
aPostData
=
null
)
{
this
.
_uri
=
aURI
;
this
.
_postData
=
aPostData
;
}
Submission
.
prototype
=
{
get
uri
(
)
{
return
this
.
_uri
;
}
get
postData
(
)
{
return
this
.
_postData
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISearchSubmission
]
)
}
function
ParseSubmissionResult
(
aEngine
aTerms
aTermsOffset
aTermsLength
)
{
this
.
_engine
=
aEngine
;
this
.
_terms
=
aTerms
;
this
.
_termsOffset
=
aTermsOffset
;
this
.
_termsLength
=
aTermsLength
;
}
ParseSubmissionResult
.
prototype
=
{
get
engine
(
)
{
return
this
.
_engine
;
}
get
terms
(
)
{
return
this
.
_terms
;
}
get
termsOffset
(
)
{
return
this
.
_termsOffset
;
}
get
termsLength
(
)
{
return
this
.
_termsLength
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISearchParseSubmissionResult
]
)
}
const
gEmptyParseSubmissionResult
=
Object
.
freeze
(
new
ParseSubmissionResult
(
null
"
"
-
1
0
)
)
;
function
executeSoon
(
func
)
{
Services
.
tm
.
dispatchToMainThread
(
func
)
;
}
function
checkForSyncCompletion
(
aPromise
)
{
return
aPromise
.
then
(
function
(
aValue
)
{
if
(
gInitialized
)
{
throw
Components
.
Exception
(
"
Synchronous
fallback
was
called
and
has
"
+
"
finished
so
no
need
to
pursue
asynchronous
"
+
"
initialization
"
Cr
.
NS_ERROR_ALREADY_INITIALIZED
)
;
}
return
aValue
;
}
)
;
}
function
SearchService
(
)
{
if
(
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
log
"
false
)
)
LOG
=
DO_LOG
;
this
.
_initObservers
=
PromiseUtils
.
defer
(
)
;
}
SearchService
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
7319788a
-
fe93
-
4db3
-
9f39
-
818cf08f4256
}
"
)
_initRV
:
Cr
.
NS_OK
_initStarted
:
null
_cacheFileJSON
:
null
_ensureInitialized
:
function
SRCH_SVC__ensureInitialized
(
)
{
if
(
gInitialized
)
{
if
(
!
Components
.
isSuccessCode
(
this
.
_initRV
)
)
{
LOG
(
"
_ensureInitialized
:
failure
"
)
;
throw
this
.
_initRV
;
}
return
;
}
let
warning
=
"
Search
service
falling
back
to
synchronous
initialization
.
"
+
"
This
is
generally
the
consequence
of
an
add
-
on
using
a
deprecated
"
+
"
search
service
API
.
"
;
Deprecated
.
warning
(
warning
"
https
:
/
/
developer
.
mozilla
.
org
/
en
-
US
/
docs
/
XPCOM_Interface_Reference
/
nsIBrowserSearchService
#
async_warning
"
)
;
LOG
(
warning
)
;
this
.
_syncInit
(
)
;
if
(
!
Components
.
isSuccessCode
(
this
.
_initRV
)
)
{
throw
this
.
_initRV
;
}
}
_syncInit
:
function
SRCH_SVC__syncInit
(
)
{
LOG
(
"
_syncInit
start
"
)
;
this
.
_initStarted
=
true
;
migrateRegionPrefs
(
)
;
let
cache
=
this
.
_readCacheFile
(
)
;
if
(
cache
.
metaData
)
this
.
_metaData
=
cache
.
metaData
;
try
{
this
.
_syncLoadEngines
(
cache
)
;
}
catch
(
ex
)
{
this
.
_initRV
=
Cr
.
NS_ERROR_FAILURE
;
LOG
(
"
_syncInit
:
failure
loading
engines
:
"
+
ex
)
;
}
this
.
_addObservers
(
)
;
gInitialized
=
true
;
this
.
_cacheFileJSON
=
null
;
this
.
_initObservers
.
resolve
(
this
.
_initRV
)
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
init
-
complete
"
)
;
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_INIT_SYNC
"
)
.
add
(
true
)
;
this
.
_recordEngineTelemetry
(
)
;
LOG
(
"
_syncInit
end
"
)
;
}
async
_asyncInit
(
)
{
LOG
(
"
_asyncInit
start
"
)
;
migrateRegionPrefs
(
)
;
let
cache
=
{
}
;
cache
=
await
this
.
_asyncReadCacheFile
(
)
;
if
(
!
gInitialized
&
&
cache
.
metaData
)
this
.
_metaData
=
cache
.
metaData
;
try
{
await
checkForSyncCompletion
(
ensureKnownCountryCode
(
this
)
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_ALREADY_INITIALIZED
)
{
throw
ex
;
}
LOG
(
"
_asyncInit
:
failure
determining
country
code
:
"
+
ex
)
;
}
try
{
await
checkForSyncCompletion
(
this
.
_asyncLoadEngines
(
cache
)
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_ALREADY_INITIALIZED
)
{
throw
ex
;
}
this
.
_initRV
=
Cr
.
NS_ERROR_FAILURE
;
LOG
(
"
_asyncInit
:
failure
loading
engines
:
"
+
ex
)
;
}
this
.
_addObservers
(
)
;
gInitialized
=
true
;
this
.
_cacheFileJSON
=
null
;
this
.
_initObservers
.
resolve
(
this
.
_initRV
)
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
init
-
complete
"
)
;
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_INIT_SYNC
"
)
.
add
(
false
)
;
this
.
_recordEngineTelemetry
(
)
;
LOG
(
"
_asyncInit
:
Completed
_asyncInit
"
)
;
}
_metaData
:
{
}
setGlobalAttr
(
name
val
)
{
this
.
_metaData
[
name
]
=
val
;
this
.
batchTask
.
disarm
(
)
;
this
.
batchTask
.
arm
(
)
;
}
setVerifiedGlobalAttr
(
name
val
)
{
this
.
setGlobalAttr
(
name
val
)
;
this
.
setGlobalAttr
(
name
+
"
Hash
"
getVerificationHash
(
val
)
)
;
}
getGlobalAttr
(
name
)
{
return
this
.
_metaData
[
name
]
|
|
undefined
;
}
getVerifiedGlobalAttr
(
name
)
{
let
val
=
this
.
getGlobalAttr
(
name
)
;
if
(
val
&
&
this
.
getGlobalAttr
(
name
+
"
Hash
"
)
!
=
getVerificationHash
(
val
)
)
{
LOG
(
"
getVerifiedGlobalAttr
invalid
hash
for
"
+
name
)
;
return
"
"
;
}
return
val
;
}
_engines
:
{
}
__sortedEngines
:
null
_visibleDefaultEngines
:
[
]
get
_sortedEngines
(
)
{
if
(
!
this
.
__sortedEngines
)
return
this
.
_buildSortedEngineList
(
)
;
return
this
.
__sortedEngines
;
}
get
originalDefaultEngine
(
)
{
let
defaultEngine
=
this
.
getVerifiedGlobalAttr
(
"
searchDefault
"
)
;
if
(
!
defaultEngine
)
{
let
defaultPrefB
=
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
;
let
nsIPLS
=
Ci
.
nsIPrefLocalizedString
;
let
defPref
=
getGeoSpecificPrefName
(
"
defaultenginename
"
)
;
try
{
defaultEngine
=
defaultPrefB
.
getComplexValue
(
defPref
nsIPLS
)
.
data
;
}
catch
(
ex
)
{
}
}
return
this
.
getEngineByName
(
defaultEngine
)
;
}
resetToOriginalDefaultEngine
:
function
SRCH_SVC__resetToOriginalDefaultEngine
(
)
{
this
.
currentEngine
=
this
.
originalDefaultEngine
;
}
_buildCache
:
function
SRCH_SVC__buildCache
(
)
{
if
(
this
.
_batchTask
)
this
.
_batchTask
.
disarm
(
)
;
let
cache
=
{
}
;
let
locale
=
getLocale
(
)
;
let
buildID
=
Services
.
appinfo
.
platformBuildID
;
cache
.
version
=
CACHE_VERSION
;
cache
.
buildID
=
buildID
;
cache
.
locale
=
locale
;
cache
.
visibleDefaultEngines
=
this
.
_visibleDefaultEngines
;
cache
.
metaData
=
this
.
_metaData
;
cache
.
engines
=
[
]
;
for
(
let
name
in
this
.
_engines
)
{
cache
.
engines
.
push
(
this
.
_engines
[
name
]
)
;
}
try
{
if
(
!
cache
.
engines
.
length
)
throw
"
cannot
write
without
any
engine
.
"
;
LOG
(
"
_buildCache
:
Writing
to
cache
file
.
"
)
;
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CACHE_FILENAME
)
;
let
data
=
gEncoder
.
encode
(
JSON
.
stringify
(
cache
)
)
;
let
promise
=
OS
.
File
.
writeAtomic
(
path
data
{
compression
:
"
lz4
"
tmpPath
:
path
+
"
.
tmp
"
}
)
;
promise
.
then
(
function
onSuccess
(
)
{
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
SEARCH_SERVICE_CACHE_WRITTEN
)
;
}
function
onError
(
e
)
{
LOG
(
"
_buildCache
:
failure
during
writeAtomic
:
"
+
e
)
;
}
)
;
}
catch
(
ex
)
{
LOG
(
"
_buildCache
:
Could
not
write
to
cache
file
:
"
+
ex
)
;
}
}
_syncLoadEngines
:
function
SRCH_SVC__syncLoadEngines
(
cache
)
{
LOG
(
"
_syncLoadEngines
:
start
"
)
;
let
chromeURIs
=
this
.
_findJAREngines
(
)
;
let
distDirs
=
[
]
;
let
locations
;
try
{
locations
=
getDir
(
NS_APP_DISTRIBUTION_SEARCH_DIR_LIST
Ci
.
nsISimpleEnumerator
)
;
}
catch
(
e
)
{
locations
=
{
hasMoreElements
:
(
)
=
>
false
}
;
}
while
(
locations
.
hasMoreElements
(
)
)
{
let
dir
=
locations
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIFile
)
;
if
(
dir
.
directoryEntries
.
hasMoreElements
(
)
)
distDirs
.
push
(
dir
)
;
}
let
otherDirs
=
[
]
;
let
userSearchDir
=
getDir
(
NS_APP_USER_SEARCH_DIR
)
;
locations
=
getDir
(
NS_APP_SEARCH_DIR_LIST
Ci
.
nsISimpleEnumerator
)
;
while
(
locations
.
hasMoreElements
(
)
)
{
let
dir
=
locations
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIFile
)
;
if
(
(
!
cache
.
engines
|
|
!
dir
.
equals
(
userSearchDir
)
)
&
&
dir
.
directoryEntries
.
hasMoreElements
(
)
)
otherDirs
.
push
(
dir
)
;
}
function
modifiedDir
(
aDir
)
{
return
cacheOtherPaths
.
get
(
aDir
.
path
)
!
=
aDir
.
lastModifiedTime
;
}
function
notInCacheVisibleEngines
(
aEngineName
)
{
return
cache
.
visibleDefaultEngines
.
indexOf
(
aEngineName
)
=
=
-
1
;
}
let
buildID
=
Services
.
appinfo
.
platformBuildID
;
let
cacheOtherPaths
=
new
Map
(
)
;
if
(
cache
.
engines
)
{
for
(
let
engine
of
cache
.
engines
)
{
if
(
engine
.
_dirPath
)
{
cacheOtherPaths
.
set
(
engine
.
_dirPath
engine
.
_dirLastModifiedTime
)
;
}
}
}
let
rebuildCache
=
!
cache
.
engines
|
|
cache
.
version
!
=
CACHE_VERSION
|
|
cache
.
locale
!
=
getLocale
(
)
|
|
cache
.
buildID
!
=
buildID
|
|
cacheOtherPaths
.
size
!
=
otherDirs
.
length
|
|
otherDirs
.
some
(
d
=
>
!
cacheOtherPaths
.
has
(
d
.
path
)
)
|
|
cache
.
visibleDefaultEngines
.
length
!
=
this
.
_visibleDefaultEngines
.
length
|
|
this
.
_visibleDefaultEngines
.
some
(
notInCacheVisibleEngines
)
|
|
otherDirs
.
some
(
modifiedDir
)
;
if
(
rebuildCache
)
{
LOG
(
"
_loadEngines
:
Absent
or
outdated
cache
.
Loading
engines
from
disk
.
"
)
;
distDirs
.
forEach
(
this
.
_loadEnginesFromDir
this
)
;
this
.
_loadFromChromeURLs
(
chromeURIs
)
;
LOG
(
"
_loadEngines
:
load
user
-
installed
engines
from
the
obsolete
cache
"
)
;
this
.
_loadEnginesFromCache
(
cache
true
)
;
otherDirs
.
forEach
(
this
.
_loadEnginesFromDir
this
)
;
this
.
_loadEnginesMetadataFromCache
(
cache
)
;
this
.
_buildCache
(
)
;
return
;
}
LOG
(
"
_loadEngines
:
loading
from
cache
directories
"
)
;
this
.
_loadEnginesFromCache
(
cache
)
;
LOG
(
"
_loadEngines
:
done
"
)
;
}
async
_asyncLoadEngines
(
cache
)
{
LOG
(
"
_asyncLoadEngines
:
start
"
)
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
find
-
jar
-
engines
"
)
;
let
chromeURIs
=
await
checkForSyncCompletion
(
this
.
_asyncFindJAREngines
(
)
)
;
let
distDirs
=
[
]
;
let
locations
;
try
{
locations
=
getDir
(
NS_APP_DISTRIBUTION_SEARCH_DIR_LIST
Ci
.
nsISimpleEnumerator
)
;
}
catch
(
e
)
{
locations
=
{
hasMoreElements
:
(
)
=
>
false
}
;
}
while
(
locations
.
hasMoreElements
(
)
)
{
let
dir
=
locations
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIFile
)
;
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
dir
.
path
{
winPattern
:
"
*
.
xml
"
}
)
;
try
{
await
checkForSyncCompletion
(
iterator
.
next
(
)
)
;
distDirs
.
push
(
dir
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_ALREADY_INITIALIZED
)
{
throw
ex
;
}
}
finally
{
iterator
.
close
(
)
;
}
}
let
otherDirs
=
[
]
;
let
userSearchDir
=
getDir
(
NS_APP_USER_SEARCH_DIR
)
;
locations
=
getDir
(
NS_APP_SEARCH_DIR_LIST
Ci
.
nsISimpleEnumerator
)
;
while
(
locations
.
hasMoreElements
(
)
)
{
let
dir
=
locations
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIFile
)
;
if
(
cache
.
engines
&
&
dir
.
equals
(
userSearchDir
)
)
continue
;
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
dir
.
path
{
winPattern
:
"
*
.
xml
"
}
)
;
try
{
await
checkForSyncCompletion
(
iterator
.
next
(
)
)
;
otherDirs
.
push
(
dir
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_ALREADY_INITIALIZED
)
{
throw
ex
;
}
}
finally
{
iterator
.
close
(
)
;
}
}
let
hasModifiedDir
=
async
function
(
aList
)
{
let
modifiedDir
=
false
;
for
(
let
dir
of
aList
)
{
let
lastModifiedTime
=
cacheOtherPaths
.
get
(
dir
.
path
)
;
if
(
!
lastModifiedTime
)
{
continue
;
}
let
info
=
await
OS
.
File
.
stat
(
dir
.
path
)
;
if
(
lastModifiedTime
!
=
info
.
lastModificationDate
.
getTime
(
)
)
{
modifiedDir
=
true
;
break
;
}
}
return
modifiedDir
;
}
;
function
notInCacheVisibleEngines
(
aEngineName
)
{
return
cache
.
visibleDefaultEngines
.
indexOf
(
aEngineName
)
=
=
-
1
;
}
let
buildID
=
Services
.
appinfo
.
platformBuildID
;
let
cacheOtherPaths
=
new
Map
(
)
;
if
(
cache
.
engines
)
{
for
(
let
engine
of
cache
.
engines
)
{
if
(
engine
.
_dirPath
)
{
cacheOtherPaths
.
set
(
engine
.
_dirPath
engine
.
_dirLastModifiedTime
)
;
}
}
}
let
rebuildCache
=
!
cache
.
engines
|
|
cache
.
version
!
=
CACHE_VERSION
|
|
cache
.
locale
!
=
getLocale
(
)
|
|
cache
.
buildID
!
=
buildID
|
|
cacheOtherPaths
.
size
!
=
otherDirs
.
length
|
|
otherDirs
.
some
(
d
=
>
!
cacheOtherPaths
.
has
(
d
.
path
)
)
|
|
cache
.
visibleDefaultEngines
.
length
!
=
this
.
_visibleDefaultEngines
.
length
|
|
this
.
_visibleDefaultEngines
.
some
(
notInCacheVisibleEngines
)
|
|
(
await
checkForSyncCompletion
(
hasModifiedDir
(
otherDirs
)
)
)
;
if
(
rebuildCache
)
{
LOG
(
"
_asyncLoadEngines
:
Absent
or
outdated
cache
.
Loading
engines
from
disk
.
"
)
;
for
(
let
loadDir
of
distDirs
)
{
let
enginesFromDir
=
await
checkForSyncCompletion
(
this
.
_asyncLoadEnginesFromDir
(
loadDir
)
)
;
enginesFromDir
.
forEach
(
this
.
_addEngineToStore
this
)
;
}
let
enginesFromURLs
=
await
checkForSyncCompletion
(
this
.
_asyncLoadFromChromeURLs
(
chromeURIs
)
)
;
enginesFromURLs
.
forEach
(
this
.
_addEngineToStore
this
)
;
LOG
(
"
_asyncLoadEngines
:
loading
user
-
installed
engines
from
the
obsolete
cache
"
)
;
this
.
_loadEnginesFromCache
(
cache
true
)
;
for
(
let
loadDir
of
otherDirs
)
{
let
enginesFromDir
=
await
checkForSyncCompletion
(
this
.
_asyncLoadEnginesFromDir
(
loadDir
)
)
;
enginesFromDir
.
forEach
(
this
.
_addEngineToStore
this
)
;
}
this
.
_loadEnginesMetadataFromCache
(
cache
)
;
this
.
_buildCache
(
)
;
return
;
}
LOG
(
"
_asyncLoadEngines
:
loading
from
cache
directories
"
)
;
this
.
_loadEnginesFromCache
(
cache
)
;
LOG
(
"
_asyncLoadEngines
:
done
"
)
;
}
_asyncReInit
(
)
{
LOG
(
"
_asyncReInit
"
)
;
gInitialized
=
false
;
(
async
(
)
=
>
{
try
{
if
(
this
.
_batchTask
)
{
LOG
(
"
finalizing
batch
task
"
)
;
let
task
=
this
.
_batchTask
;
this
.
_batchTask
=
null
;
await
task
.
finalize
(
)
;
}
this
.
_engines
=
{
}
;
this
.
__sortedEngines
=
null
;
this
.
_currentEngine
=
null
;
this
.
_visibleDefaultEngines
=
[
]
;
this
.
_metaData
=
{
}
;
this
.
_cacheFileJSON
=
null
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
uninit
-
complete
"
)
;
let
cache
=
{
}
;
cache
=
await
this
.
_asyncReadCacheFile
(
)
;
if
(
!
gInitialized
&
&
cache
.
metaData
)
this
.
_metaData
=
cache
.
metaData
;
await
ensureKnownCountryCode
(
this
)
;
if
(
!
gInitialized
)
await
this
.
_asyncLoadEngines
(
cache
)
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
init
-
complete
"
)
;
this
.
_recordEngineTelemetry
(
)
;
gInitialized
=
true
;
}
catch
(
err
)
{
LOG
(
"
Reinit
failed
:
"
+
err
)
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
reinit
-
failed
"
)
;
}
finally
{
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
reinit
-
complete
"
)
;
}
}
)
(
)
;
}
_readCacheFile
:
function
SRCH_SVC__readCacheFile
(
)
{
if
(
this
.
_cacheFileJSON
)
{
return
this
.
_cacheFileJSON
;
}
let
cacheFile
=
getDir
(
NS_APP_USER_PROFILE_50_DIR
)
;
cacheFile
.
append
(
CACHE_FILENAME
)
;
let
stream
;
try
{
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
stream
.
init
(
cacheFile
MODE_RDONLY
PERMS_FILE
0
)
;
let
bis
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
bis
.
setInputStream
(
stream
)
;
let
count
=
stream
.
available
(
)
;
let
array
=
new
Uint8Array
(
count
)
;
bis
.
readArrayBuffer
(
count
array
.
buffer
)
;
let
bytes
=
Lz4
.
decompressFileContent
(
array
)
;
let
json
=
JSON
.
parse
(
new
TextDecoder
(
)
.
decode
(
bytes
)
)
;
if
(
!
json
.
engines
|
|
!
json
.
engines
.
length
)
throw
"
no
engine
in
the
file
"
;
return
json
;
}
catch
(
ex
)
{
LOG
(
"
_readCacheFile
:
Error
reading
cache
file
:
"
+
ex
)
;
}
finally
{
stream
.
close
(
)
;
}
try
{
cacheFile
.
leafName
=
"
search
-
metadata
.
json
"
;
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
stream
.
init
(
cacheFile
MODE_RDONLY
PERMS_FILE
0
)
;
let
metadata
=
parseJsonFromStream
(
stream
)
;
let
json
=
{
}
;
if
(
"
[
global
]
"
in
metadata
)
{
LOG
(
"
_readCacheFile
:
migrating
metadata
from
search
-
metadata
.
json
"
)
;
let
data
=
metadata
[
"
[
global
]
"
]
;
json
.
metaData
=
{
}
;
let
fields
=
[
"
searchDefault
"
"
searchDefaultHash
"
"
searchDefaultExpir
"
"
current
"
"
hash
"
"
visibleDefaultEngines
"
"
visibleDefaultEnginesHash
"
]
;
for
(
let
field
of
fields
)
{
let
name
=
field
.
toLowerCase
(
)
;
if
(
name
in
data
)
json
.
metaData
[
field
]
=
data
[
name
]
;
}
}
delete
metadata
[
"
[
global
]
"
]
;
json
.
_oldMetadata
=
metadata
;
return
json
;
}
catch
(
ex
)
{
LOG
(
"
_readCacheFile
:
failed
to
read
old
metadata
:
"
+
ex
)
;
return
{
}
;
}
finally
{
stream
.
close
(
)
;
}
}
async
_asyncReadCacheFile
(
)
{
let
json
;
try
{
let
cacheFilePath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CACHE_FILENAME
)
;
let
bytes
=
await
OS
.
File
.
read
(
cacheFilePath
{
compression
:
"
lz4
"
}
)
;
json
=
JSON
.
parse
(
new
TextDecoder
(
)
.
decode
(
bytes
)
)
;
if
(
!
json
.
engines
|
|
!
json
.
engines
.
length
)
throw
"
no
engine
in
the
file
"
;
this
.
_cacheFileJSON
=
json
;
}
catch
(
ex
)
{
LOG
(
"
_asyncReadCacheFile
:
Error
reading
cache
file
:
"
+
ex
)
;
json
=
{
}
;
let
oldMetadata
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
search
-
metadata
.
json
"
)
;
try
{
let
bytes
=
await
OS
.
File
.
read
(
oldMetadata
)
;
let
metadata
=
JSON
.
parse
(
new
TextDecoder
(
)
.
decode
(
bytes
)
)
;
if
(
"
[
global
]
"
in
metadata
)
{
LOG
(
"
_asyncReadCacheFile
:
migrating
metadata
from
search
-
metadata
.
json
"
)
;
let
data
=
metadata
[
"
[
global
]
"
]
;
json
.
metaData
=
{
}
;
let
fields
=
[
"
searchDefault
"
"
searchDefaultHash
"
"
searchDefaultExpir
"
"
current
"
"
hash
"
"
visibleDefaultEngines
"
"
visibleDefaultEnginesHash
"
]
;
for
(
let
field
of
fields
)
{
let
name
=
field
.
toLowerCase
(
)
;
if
(
name
in
data
)
json
.
metaData
[
field
]
=
data
[
name
]
;
}
}
delete
metadata
[
"
[
global
]
"
]
;
json
.
_oldMetadata
=
metadata
;
}
catch
(
ex
)
{
}
}
return
json
;
}
_batchTask
:
null
get
batchTask
(
)
{
if
(
!
this
.
_batchTask
)
{
let
task
=
(
)
=
>
{
LOG
(
"
batchTask
:
Invalidating
engine
cache
"
)
;
this
.
_buildCache
(
)
;
}
;
this
.
_batchTask
=
new
DeferredTask
(
task
CACHE_INVALIDATION_DELAY
)
;
}
return
this
.
_batchTask
;
}
_addEngineToStore
:
function
SRCH_SVC_addEngineToStore
(
aEngine
)
{
LOG
(
"
_addEngineToStore
:
Adding
engine
:
\
"
"
+
aEngine
.
name
+
"
\
"
"
)
;
var
hasSameNameAsUpdate
=
(
aEngine
.
_engineToUpdate
&
&
aEngine
.
name
=
=
aEngine
.
_engineToUpdate
.
name
)
;
if
(
aEngine
.
name
in
this
.
_engines
&
&
!
hasSameNameAsUpdate
)
{
LOG
(
"
_addEngineToStore
:
Duplicate
engine
found
aborting
!
"
)
;
return
;
}
if
(
aEngine
.
_engineToUpdate
)
{
var
oldEngine
=
aEngine
.
_engineToUpdate
;
delete
this
.
_engines
[
oldEngine
.
name
]
;
for
(
var
p
in
aEngine
)
{
if
(
!
(
aEngine
.
__lookupGetter__
(
p
)
|
|
aEngine
.
__lookupSetter__
(
p
)
)
)
oldEngine
[
p
]
=
aEngine
[
p
]
;
}
aEngine
=
oldEngine
;
aEngine
.
_engineToUpdate
=
null
;
this
.
_engines
[
aEngine
.
name
]
=
aEngine
;
notifyAction
(
aEngine
SEARCH_ENGINE_CHANGED
)
;
}
else
{
this
.
_engines
[
aEngine
.
name
]
=
aEngine
;
if
(
this
.
__sortedEngines
)
{
this
.
__sortedEngines
.
push
(
aEngine
)
;
this
.
_saveSortedEngineList
(
)
;
}
notifyAction
(
aEngine
SEARCH_ENGINE_ADDED
)
;
}
if
(
aEngine
.
_hasUpdates
)
{
if
(
!
aEngine
.
getAttr
(
"
updateexpir
"
)
)
engineUpdateService
.
scheduleNextUpdate
(
aEngine
)
;
}
}
_loadEnginesMetadataFromCache
:
function
SRCH_SVC__loadEnginesMetadataFromCache
(
cache
)
{
if
(
cache
.
_oldMetadata
)
{
for
(
let
name
in
this
.
_engines
)
{
let
engine
=
this
.
_engines
[
name
]
;
if
(
engine
.
_id
&
&
cache
.
_oldMetadata
[
engine
.
_id
]
)
engine
.
_metaData
=
cache
.
_oldMetadata
[
engine
.
_id
]
;
}
return
;
}
if
(
!
cache
.
engines
)
return
;
for
(
let
engine
of
cache
.
engines
)
{
let
name
=
engine
.
_name
;
if
(
name
in
this
.
_engines
)
{
LOG
(
"
_loadEnginesMetadataFromCache
transfering
metadata
for
"
+
name
)
;
this
.
_engines
[
name
]
.
_metaData
=
engine
.
_metaData
;
}
}
}
_loadEnginesFromCache
:
function
SRCH_SVC__loadEnginesFromCache
(
cache
skipReadOnly
)
{
if
(
!
cache
.
engines
)
return
;
LOG
(
"
_loadEnginesFromCache
:
Loading
"
+
cache
.
engines
.
length
+
"
engines
from
cache
"
)
;
let
skippedEngines
=
0
;
for
(
let
engine
of
cache
.
engines
)
{
if
(
skipReadOnly
&
&
engine
.
_readOnly
=
=
undefined
)
{
+
+
skippedEngines
;
continue
;
}
this
.
_loadEngineFromCache
(
engine
)
;
}
if
(
skippedEngines
)
{
LOG
(
"
_loadEnginesFromCache
:
skipped
"
+
skippedEngines
+
"
read
-
only
engines
.
"
)
;
}
}
_loadEngineFromCache
:
function
SRCH_SVC__loadEngineFromCache
(
json
)
{
try
{
let
engine
=
new
Engine
(
json
.
_shortName
json
.
_readOnly
=
=
undefined
)
;
engine
.
_initWithJSON
(
json
)
;
this
.
_addEngineToStore
(
engine
)
;
}
catch
(
ex
)
{
LOG
(
"
Failed
to
load
"
+
json
.
_name
+
"
from
cache
:
"
+
ex
)
;
LOG
(
"
Engine
JSON
:
"
+
json
.
toSource
(
)
)
;
}
}
_loadEnginesFromDir
:
function
SRCH_SVC__loadEnginesFromDir
(
aDir
)
{
LOG
(
"
_loadEnginesFromDir
:
Searching
in
"
+
aDir
.
path
+
"
for
search
engines
.
"
)
;
var
isInProfile
=
aDir
.
equals
(
getDir
(
NS_APP_USER_SEARCH_DIR
)
)
;
var
files
=
aDir
.
directoryEntries
.
QueryInterface
(
Ci
.
nsIDirectoryEnumerator
)
;
while
(
files
.
hasMoreElements
(
)
)
{
var
file
=
files
.
nextFile
;
if
(
!
file
.
isFile
(
)
|
|
file
.
fileSize
=
=
0
|
|
file
.
isHidden
(
)
)
continue
;
var
fileURL
=
Services
.
io
.
newFileURI
(
file
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
var
fileExtension
=
fileURL
.
fileExtension
.
toLowerCase
(
)
;
if
(
fileExtension
!
=
"
xml
"
)
{
continue
;
}
var
addedEngine
=
null
;
try
{
addedEngine
=
new
Engine
(
file
!
isInProfile
)
;
addedEngine
.
_initFromFile
(
file
)
;
if
(
!
isInProfile
&
&
!
addedEngine
.
_isDefault
)
{
addedEngine
.
_dirPath
=
aDir
.
path
;
addedEngine
.
_dirLastModifiedTime
=
aDir
.
lastModifiedTime
;
}
}
catch
(
ex
)
{
LOG
(
"
_loadEnginesFromDir
:
Failed
to
load
"
+
file
.
path
+
"
!
\
n
"
+
ex
)
;
continue
;
}
this
.
_addEngineToStore
(
addedEngine
)
;
}
}
async
_asyncLoadEnginesFromDir
(
aDir
)
{
LOG
(
"
_asyncLoadEnginesFromDir
:
Searching
in
"
+
aDir
.
path
+
"
for
search
engines
.
"
)
;
let
isInProfile
=
aDir
.
equals
(
getDir
(
NS_APP_USER_SEARCH_DIR
)
)
;
let
dirPath
=
aDir
.
path
;
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
dirPath
)
;
let
osfiles
=
await
iterator
.
nextBatch
(
)
;
iterator
.
close
(
)
;
let
engines
=
[
]
;
for
(
let
osfile
of
osfiles
)
{
if
(
osfile
.
isDir
|
|
osfile
.
isSymLink
)
continue
;
let
fileInfo
=
await
OS
.
File
.
stat
(
osfile
.
path
)
;
if
(
fileInfo
.
size
=
=
0
)
continue
;
let
parts
=
osfile
.
path
.
split
(
"
.
"
)
;
if
(
parts
.
length
<
=
1
|
|
(
parts
.
pop
(
)
)
.
toLowerCase
(
)
!
=
"
xml
"
)
{
continue
;
}
let
addedEngine
=
null
;
try
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
osfile
.
path
)
;
addedEngine
=
new
Engine
(
file
!
isInProfile
)
;
await
checkForSyncCompletion
(
addedEngine
.
_asyncInitFromFile
(
file
)
)
;
if
(
!
isInProfile
&
&
!
addedEngine
.
_isDefault
)
{
addedEngine
.
_dirPath
=
dirPath
;
let
info
=
await
OS
.
File
.
stat
(
dirPath
)
;
addedEngine
.
_dirLastModifiedTime
=
info
.
lastModificationDate
.
getTime
(
)
;
}
engines
.
push
(
addedEngine
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_ALREADY_INITIALIZED
)
{
throw
ex
;
}
LOG
(
"
_asyncLoadEnginesFromDir
:
Failed
to
load
"
+
osfile
.
path
+
"
!
\
n
"
+
ex
)
;
}
}
return
engines
;
}
_loadFromChromeURLs
:
function
SRCH_SVC_loadFromChromeURLs
(
aURLs
)
{
aURLs
.
forEach
(
function
(
url
)
{
try
{
LOG
(
"
_loadFromChromeURLs
:
loading
engine
from
chrome
url
:
"
+
url
)
;
let
uri
=
makeURI
(
url
)
;
let
engine
=
new
Engine
(
uri
true
)
;
engine
.
_initFromURISync
(
uri
)
;
this
.
_addEngineToStore
(
engine
)
;
}
catch
(
ex
)
{
LOG
(
"
_loadFromChromeURLs
:
failed
to
load
engine
:
"
+
ex
)
;
}
}
this
)
;
}
async
_asyncLoadFromChromeURLs
(
aURLs
)
{
let
engines
=
[
]
;
for
(
let
url
of
aURLs
)
{
try
{
LOG
(
"
_asyncLoadFromChromeURLs
:
loading
engine
from
chrome
url
:
"
+
url
)
;
let
uri
=
Services
.
io
.
newURI
(
url
)
;
let
engine
=
new
Engine
(
uri
true
)
;
await
checkForSyncCompletion
(
engine
.
_asyncInitFromURI
(
uri
)
)
;
engines
.
push
(
engine
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_ALREADY_INITIALIZED
)
{
throw
ex
;
}
LOG
(
"
_asyncLoadFromChromeURLs
:
failed
to
load
engine
:
"
+
ex
)
;
}
}
return
engines
;
}
_convertChannelToFile
(
chan
)
{
let
fileURI
=
chan
.
URI
;
while
(
fileURI
instanceof
Ci
.
nsIJARURI
)
fileURI
=
fileURI
.
JARFile
;
fileURI
.
QueryInterface
(
Ci
.
nsIFileURL
)
;
return
fileURI
.
file
;
}
_findJAREngines
:
function
SRCH_SVC_findJAREngines
(
)
{
LOG
(
"
_findJAREngines
:
looking
for
engines
in
JARs
"
)
let
chan
=
makeChannel
(
APP_SEARCH_PREFIX
+
"
list
.
json
"
)
;
if
(
!
chan
)
{
LOG
(
"
_findJAREngines
:
"
+
APP_SEARCH_PREFIX
+
"
isn
'
t
registered
"
)
;
return
[
]
;
}
let
uris
=
[
]
;
let
sis
=
Cc
[
"
mozilla
.
org
/
scriptableinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptableInputStream
)
;
try
{
sis
.
init
(
chan
.
open2
(
)
)
;
this
.
_parseListJSON
(
sis
.
read
(
sis
.
available
(
)
)
uris
)
;
}
catch
(
e
)
{
chan
=
makeChannel
(
APP_SEARCH_PREFIX
+
"
list
.
txt
"
)
;
sis
.
init
(
chan
.
open2
(
)
)
;
this
.
_parseListTxt
(
sis
.
read
(
sis
.
available
(
)
)
uris
)
;
}
return
uris
;
}
async
_asyncFindJAREngines
(
)
{
LOG
(
"
_asyncFindJAREngines
:
looking
for
engines
in
JARs
"
)
let
listURL
=
APP_SEARCH_PREFIX
+
"
list
.
json
"
;
let
chan
=
makeChannel
(
listURL
)
;
if
(
!
chan
)
{
LOG
(
"
_asyncFindJAREngines
:
"
+
APP_SEARCH_PREFIX
+
"
isn
'
t
registered
"
)
;
return
[
]
;
}
let
uris
=
[
]
;
let
request
=
Cc
[
"
mozilla
.
org
/
xmlextras
/
xmlhttprequest
;
1
"
]
.
createInstance
(
Ci
.
nsIXMLHttpRequest
)
;
request
.
overrideMimeType
(
"
text
/
plain
"
)
;
let
list
=
await
new
Promise
(
resolve
=
>
{
request
.
onload
=
function
(
aEvent
)
{
resolve
(
aEvent
.
target
.
responseText
)
;
}
;
request
.
onerror
=
function
(
aEvent
)
{
LOG
(
"
_asyncFindJAREngines
:
failed
to
read
"
+
listURL
)
;
request
.
onerror
=
function
(
aEvent
)
{
LOG
(
"
_asyncFindJAREngines
:
failed
to
read
"
+
APP_SEARCH_PREFIX
+
"
list
.
txt
"
)
;
resolve
(
"
"
)
;
}
request
.
open
(
"
GET
"
Services
.
io
.
newURI
(
APP_SEARCH_PREFIX
+
"
list
.
txt
"
)
.
spec
true
)
;
request
.
send
(
)
;
}
;
request
.
open
(
"
GET
"
Services
.
io
.
newURI
(
listURL
)
.
spec
true
)
;
request
.
send
(
)
;
}
)
;
if
(
request
.
responseURL
.
endsWith
(
"
.
txt
"
)
)
{
this
.
_parseListTxt
(
list
uris
)
;
}
else
{
this
.
_parseListJSON
(
list
uris
)
;
}
return
uris
;
}
_parseListJSON
:
function
SRCH_SVC_parseListJSON
(
list
uris
)
{
let
searchSettings
;
try
{
searchSettings
=
JSON
.
parse
(
list
)
;
}
catch
(
e
)
{
LOG
(
"
failing
to
parse
list
.
json
:
"
+
e
)
;
return
;
}
let
engineNames
;
let
visibleDefaultEngines
=
this
.
getVerifiedGlobalAttr
(
"
visibleDefaultEngines
"
)
;
if
(
visibleDefaultEngines
)
{
let
jarNames
=
new
Set
(
)
;
for
(
let
region
in
searchSettings
)
{
if
(
!
(
"
visibleDefaultEngines
"
in
searchSettings
[
region
]
)
)
{
continue
;
}
for
(
let
engine
of
searchSettings
[
region
]
.
visibleDefaultEngines
)
{
jarNames
.
add
(
engine
)
;
}
}
engineNames
=
visibleDefaultEngines
.
split
(
"
"
)
;
for
(
let
engineName
of
engineNames
)
{
if
(
!
jarNames
.
has
(
engineName
)
)
{
LOG
(
"
_parseListJSON
:
ignoring
visibleDefaultEngines
value
because
"
+
engineName
+
"
is
not
in
the
jar
engines
we
have
found
"
)
;
engineNames
=
null
;
break
;
}
}
}
if
(
!
engineNames
|
|
!
engineNames
.
length
)
{
let
region
;
if
(
Services
.
prefs
.
prefHasUserValue
(
"
browser
.
search
.
region
"
)
)
{
region
=
Services
.
prefs
.
getCharPref
(
"
browser
.
search
.
region
"
)
;
}
if
(
!
region
|
|
!
(
region
in
searchSettings
)
)
{
region
=
"
default
"
;
}
engineNames
=
searchSettings
[
region
]
.
visibleDefaultEngines
;
}
let
branch
=
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
;
if
(
isPartnerBuild
(
)
&
&
branch
.
getPrefType
(
"
ignoredJAREngines
"
)
=
=
branch
.
PREF_STRING
)
{
let
ignoredJAREngines
=
branch
.
getCharPref
(
"
ignoredJAREngines
"
)
.
split
(
"
"
)
;
let
filteredEngineNames
=
engineNames
.
filter
(
e
=
>
!
ignoredJAREngines
.
includes
(
e
)
)
;
if
(
filteredEngineNames
.
length
>
0
)
{
engineNames
=
filteredEngineNames
;
}
}
for
(
let
name
of
engineNames
)
{
uris
.
push
(
APP_SEARCH_PREFIX
+
name
+
"
.
xml
"
)
;
}
this
.
_visibleDefaultEngines
=
engineNames
;
}
_parseListTxt
:
function
SRCH_SVC_parseListTxt
(
list
uris
)
{
let
names
=
list
.
split
(
"
\
n
"
)
.
filter
(
n
=
>
!
!
n
)
;
let
jarNames
=
new
Map
(
)
;
for
(
let
name
of
names
)
{
if
(
name
.
endsWith
(
"
:
hidden
"
)
)
{
name
=
name
.
split
(
"
:
"
)
[
0
]
;
jarNames
.
set
(
name
true
)
;
}
else
{
jarNames
.
set
(
name
false
)
;
}
}
let
engineNames
;
let
visibleDefaultEngines
=
this
.
getVerifiedGlobalAttr
(
"
visibleDefaultEngines
"
)
;
if
(
visibleDefaultEngines
)
{
engineNames
=
visibleDefaultEngines
.
split
(
"
"
)
;
for
(
let
engineName
of
engineNames
)
{
if
(
!
jarNames
.
has
(
engineName
)
)
{
LOG
(
"
_parseListTxt
:
ignoring
visibleDefaultEngines
value
because
"
+
engineName
+
"
is
not
in
the
jar
engines
we
have
found
"
)
;
engineNames
=
null
;
break
;
}
}
}
if
(
!
engineNames
)
{
engineNames
=
[
]
;
for
(
let
[
name
hidden
]
of
jarNames
)
{
if
(
!
hidden
)
engineNames
.
push
(
name
)
;
}
}
for
(
let
name
of
engineNames
)
{
uris
.
push
(
APP_SEARCH_PREFIX
+
name
+
"
.
xml
"
)
;
}
this
.
_visibleDefaultEngines
=
engineNames
;
}
_saveSortedEngineList
:
function
SRCH_SVC_saveSortedEngineList
(
)
{
LOG
(
"
SRCH_SVC_saveSortedEngineList
:
starting
"
)
;
Services
.
prefs
.
setBoolPref
(
BROWSER_SEARCH_PREF
+
"
useDBForOrder
"
true
)
;
var
engines
=
this
.
_getSortedEngines
(
true
)
;
for
(
var
i
=
0
;
i
<
engines
.
length
;
+
+
i
)
{
engines
[
i
]
.
setAttr
(
"
order
"
i
+
1
)
;
}
LOG
(
"
SRCH_SVC_saveSortedEngineList
:
done
"
)
;
}
_buildSortedEngineList
:
function
SRCH_SVC_buildSortedEngineList
(
)
{
LOG
(
"
_buildSortedEngineList
:
building
list
"
)
;
var
addedEngines
=
{
}
;
this
.
__sortedEngines
=
[
]
;
var
engine
;
if
(
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
useDBForOrder
"
false
)
)
{
LOG
(
"
_buildSortedEngineList
:
using
db
for
order
"
)
;
let
needToSaveEngineList
=
false
;
for
(
let
name
in
this
.
_engines
)
{
let
engine
=
this
.
_engines
[
name
]
;
var
orderNumber
=
engine
.
getAttr
(
"
order
"
)
;
if
(
orderNumber
&
&
!
this
.
__sortedEngines
[
orderNumber
-
1
]
)
{
this
.
__sortedEngines
[
orderNumber
-
1
]
=
engine
;
addedEngines
[
engine
.
name
]
=
engine
;
}
else
{
needToSaveEngineList
=
true
;
}
}
var
filteredEngines
=
this
.
__sortedEngines
.
filter
(
function
(
a
)
{
return
!
!
a
;
}
)
;
if
(
this
.
__sortedEngines
.
length
!
=
filteredEngines
.
length
)
needToSaveEngineList
=
true
;
this
.
__sortedEngines
=
filteredEngines
;
if
(
needToSaveEngineList
)
this
.
_saveSortedEngineList
(
)
;
}
else
{
var
i
=
0
;
var
engineName
;
var
prefName
;
try
{
var
extras
=
Services
.
prefs
.
getChildList
(
BROWSER_SEARCH_PREF
+
"
order
.
extra
.
"
)
;
for
(
prefName
of
extras
)
{
engineName
=
Services
.
prefs
.
getCharPref
(
prefName
)
;
engine
=
this
.
_engines
[
engineName
]
;
if
(
!
engine
|
|
engine
.
name
in
addedEngines
)
continue
;
this
.
__sortedEngines
.
push
(
engine
)
;
addedEngines
[
engine
.
name
]
=
engine
;
}
}
catch
(
e
)
{
}
let
prefNameBase
=
getGeoSpecificPrefName
(
BROWSER_SEARCH_PREF
+
"
order
"
)
;
while
(
true
)
{
prefName
=
prefNameBase
+
"
.
"
+
(
+
+
i
)
;
engineName
=
getLocalizedPref
(
prefName
)
;
if
(
!
engineName
)
break
;
engine
=
this
.
_engines
[
engineName
]
;
if
(
!
engine
|
|
engine
.
name
in
addedEngines
)
continue
;
this
.
__sortedEngines
.
push
(
engine
)
;
addedEngines
[
engine
.
name
]
=
engine
;
}
}
let
alphaEngines
=
[
]
;
for
(
let
name
in
this
.
_engines
)
{
let
engine
=
this
.
_engines
[
name
]
;
if
(
!
(
engine
.
name
in
addedEngines
)
)
alphaEngines
.
push
(
this
.
_engines
[
engine
.
name
]
)
;
}
let
collation
=
Cc
[
"
mozilla
.
org
/
intl
/
collation
-
factory
;
1
"
]
.
createInstance
(
Ci
.
nsICollationFactory
)
.
CreateCollation
(
)
;
const
strength
=
Ci
.
nsICollation
.
kCollationCaseInsensitiveAscii
;
let
comparator
=
(
a
b
)
=
>
collation
.
compareString
(
strength
a
.
name
b
.
name
)
;
alphaEngines
.
sort
(
comparator
)
;
return
this
.
__sortedEngines
=
this
.
__sortedEngines
.
concat
(
alphaEngines
)
;
}
_getSortedEngines
:
function
SRCH_SVC_getSorted
(
aWithHidden
)
{
if
(
aWithHidden
)
return
this
.
_sortedEngines
;
return
this
.
_sortedEngines
.
filter
(
function
(
engine
)
{
return
!
engine
.
hidden
;
}
)
;
}
init
:
function
SRCH_SVC_init
(
observer
)
{
LOG
(
"
SearchService
.
init
"
)
;
let
self
=
this
;
if
(
!
this
.
_initStarted
)
{
TelemetryStopwatch
.
start
(
"
SEARCH_SERVICE_INIT_MS
"
)
;
this
.
_initStarted
=
true
;
(
async
function
task
(
)
{
try
{
await
self
.
_asyncInit
(
)
;
TelemetryStopwatch
.
finish
(
"
SEARCH_SERVICE_INIT_MS
"
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_ALREADY_INITIALIZED
)
{
TelemetryStopwatch
.
finish
(
"
SEARCH_SERVICE_INIT_MS
"
)
;
}
else
{
self
.
_initObservers
.
reject
(
ex
)
;
TelemetryStopwatch
.
cancel
(
"
SEARCH_SERVICE_INIT_MS
"
)
;
}
}
}
)
(
)
;
}
if
(
observer
)
{
this
.
_initObservers
.
promise
.
then
(
function
onSuccess
(
)
{
try
{
observer
.
onInitComplete
(
self
.
_initRV
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
function
onError
(
aReason
)
{
Cu
.
reportError
(
"
Internal
error
while
initializing
SearchService
:
"
+
aReason
)
;
observer
.
onInitComplete
(
Components
.
results
.
NS_ERROR_UNEXPECTED
)
;
}
)
;
}
}
get
isInitialized
(
)
{
return
gInitialized
;
}
getEngines
:
function
SRCH_SVC_getEngines
(
aCount
)
{
this
.
_ensureInitialized
(
)
;
LOG
(
"
getEngines
:
getting
all
engines
"
)
;
var
engines
=
this
.
_getSortedEngines
(
true
)
;
aCount
.
value
=
engines
.
length
;
return
engines
;
}
getVisibleEngines
:
function
SRCH_SVC_getVisible
(
aCount
)
{
this
.
_ensureInitialized
(
)
;
LOG
(
"
getVisibleEngines
:
getting
all
visible
engines
"
)
;
var
engines
=
this
.
_getSortedEngines
(
false
)
;
aCount
.
value
=
engines
.
length
;
return
engines
;
}
getDefaultEngines
:
function
SRCH_SVC_getDefault
(
aCount
)
{
this
.
_ensureInitialized
(
)
;
function
isDefault
(
engine
)
{
return
engine
.
_isDefault
;
}
var
engines
=
this
.
_sortedEngines
.
filter
(
isDefault
)
;
var
engineOrder
=
{
}
;
var
engineName
;
var
i
=
1
;
try
{
var
extras
=
Services
.
prefs
.
getChildList
(
BROWSER_SEARCH_PREF
+
"
order
.
extra
.
"
)
;
for
(
var
prefName
of
extras
)
{
engineName
=
Services
.
prefs
.
getCharPref
(
prefName
)
;
if
(
!
(
engineName
in
engineOrder
)
)
engineOrder
[
engineName
]
=
i
+
+
;
}
}
catch
(
e
)
{
LOG
(
"
Getting
extra
order
prefs
failed
:
"
+
e
)
;
}
let
prefNameBase
=
getGeoSpecificPrefName
(
BROWSER_SEARCH_PREF
+
"
order
"
)
;
for
(
var
j
=
1
;
;
j
+
+
)
{
let
prefName
=
prefNameBase
+
"
.
"
+
j
;
engineName
=
getLocalizedPref
(
prefName
)
;
if
(
!
engineName
)
break
;
if
(
!
(
engineName
in
engineOrder
)
)
engineOrder
[
engineName
]
=
i
+
+
;
}
LOG
(
"
getDefaultEngines
:
engineOrder
:
"
+
engineOrder
.
toSource
(
)
)
;
function
compareEngines
(
a
b
)
{
var
aIdx
=
engineOrder
[
a
.
name
]
;
var
bIdx
=
engineOrder
[
b
.
name
]
;
if
(
aIdx
&
&
bIdx
)
return
aIdx
-
bIdx
;
if
(
aIdx
)
return
-
1
;
if
(
bIdx
)
return
1
;
return
a
.
name
.
localeCompare
(
b
.
name
)
;
}
engines
.
sort
(
compareEngines
)
;
aCount
.
value
=
engines
.
length
;
return
engines
;
}
getEnginesByExtensionID
:
function
SRCH_SVC_getEngines
(
aExtensionID
aCount
)
{
this
.
_ensureInitialized
(
)
;
LOG
(
"
getEngines
:
getting
all
engines
for
"
+
aExtensionID
)
;
var
engines
=
this
.
_getSortedEngines
(
true
)
.
filter
(
function
(
engine
)
{
return
engine
.
_extensionID
=
=
aExtensionID
;
}
)
;
aCount
.
value
=
engines
.
length
;
return
engines
;
}
getEngineByName
:
function
SRCH_SVC_getEngineByName
(
aEngineName
)
{
this
.
_ensureInitialized
(
)
;
return
this
.
_engines
[
aEngineName
]
|
|
null
;
}
getEngineByAlias
:
function
SRCH_SVC_getEngineByAlias
(
aAlias
)
{
this
.
_ensureInitialized
(
)
;
for
(
var
engineName
in
this
.
_engines
)
{
var
engine
=
this
.
_engines
[
engineName
]
;
if
(
engine
&
&
engine
.
alias
=
=
aAlias
)
return
engine
;
}
return
null
;
}
addEngineWithDetails
:
function
SRCH_SVC_addEWD
(
aName
iconURL
alias
description
method
template
extensionID
)
{
var
params
;
if
(
iconURL
&
&
typeof
iconURL
=
=
"
object
"
)
{
params
=
iconURL
;
}
else
{
params
=
{
iconURL
alias
description
method
template
extensionID
}
;
}
this
.
_ensureInitialized
(
)
;
if
(
!
aName
)
FAIL
(
"
Invalid
name
passed
to
addEngineWithDetails
!
"
)
;
if
(
!
params
.
template
)
FAIL
(
"
Invalid
template
passed
to
addEngineWithDetails
!
"
)
;
if
(
this
.
_engines
[
aName
]
)
FAIL
(
"
An
engine
with
that
name
already
exists
!
"
Cr
.
NS_ERROR_FILE_ALREADY_EXISTS
)
;
var
engine
=
new
Engine
(
sanitizeName
(
aName
)
false
)
;
engine
.
_initFromMetadata
(
aName
params
)
;
engine
.
_loadPath
=
"
[
other
]
addEngineWithDetails
"
;
if
(
params
.
extensionID
)
{
engine
.
_loadPath
+
=
"
:
"
+
params
.
extensionID
;
}
this
.
_addEngineToStore
(
engine
)
;
}
addEngine
:
function
SRCH_SVC_addEngine
(
aEngineURL
aDataType
aIconURL
aConfirm
aCallback
)
{
LOG
(
"
addEngine
:
Adding
\
"
"
+
aEngineURL
+
"
\
"
.
"
)
;
this
.
_ensureInitialized
(
)
;
try
{
var
uri
=
makeURI
(
aEngineURL
)
;
var
engine
=
new
Engine
(
uri
false
)
;
if
(
aCallback
)
{
engine
.
_installCallback
=
function
(
errorCode
)
{
try
{
if
(
errorCode
=
=
null
)
aCallback
.
onSuccess
(
engine
)
;
else
aCallback
.
onError
(
errorCode
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Error
invoking
addEngine
install
callback
:
"
+
ex
)
;
}
engine
.
_installCallback
=
null
;
}
;
}
engine
.
_initFromURIAndLoad
(
uri
)
;
}
catch
(
ex
)
{
if
(
engine
)
engine
.
_installCallback
=
null
;
FAIL
(
"
addEngine
:
Error
adding
engine
:
\
n
"
+
ex
Cr
.
NS_ERROR_FAILURE
)
;
}
engine
.
_setIcon
(
aIconURL
false
)
;
engine
.
_confirm
=
aConfirm
;
}
removeEngine
:
function
SRCH_SVC_removeEngine
(
aEngine
)
{
this
.
_ensureInitialized
(
)
;
if
(
!
aEngine
)
FAIL
(
"
no
engine
passed
to
removeEngine
!
"
)
;
var
engineToRemove
=
null
;
for
(
var
e
in
this
.
_engines
)
{
if
(
aEngine
.
wrappedJSObject
=
=
this
.
_engines
[
e
]
)
engineToRemove
=
this
.
_engines
[
e
]
;
}
if
(
!
engineToRemove
)
FAIL
(
"
removeEngine
:
Can
'
t
find
engine
to
remove
!
"
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
;
if
(
engineToRemove
=
=
this
.
currentEngine
)
{
this
.
_currentEngine
=
null
;
}
if
(
engineToRemove
.
_readOnly
)
{
engineToRemove
.
hidden
=
true
;
engineToRemove
.
alias
=
null
;
}
else
{
if
(
engineToRemove
.
_filePath
)
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
persistentDescriptor
=
engineToRemove
.
_filePath
;
if
(
file
.
exists
(
)
)
{
file
.
remove
(
false
)
;
}
engineToRemove
.
_filePath
=
null
;
}
var
index
=
this
.
_sortedEngines
.
indexOf
(
engineToRemove
)
;
if
(
index
=
=
-
1
)
FAIL
(
"
Can
'
t
find
engine
to
remove
in
_sortedEngines
!
"
Cr
.
NS_ERROR_FAILURE
)
;
this
.
__sortedEngines
.
splice
(
index
1
)
;
delete
this
.
_engines
[
engineToRemove
.
name
]
;
this
.
_saveSortedEngineList
(
)
;
}
notifyAction
(
engineToRemove
SEARCH_ENGINE_REMOVED
)
;
}
moveEngine
:
function
SRCH_SVC_moveEngine
(
aEngine
aNewIndex
)
{
this
.
_ensureInitialized
(
)
;
if
(
(
aNewIndex
>
this
.
_sortedEngines
.
length
)
|
|
(
aNewIndex
<
0
)
)
FAIL
(
"
SRCH_SVC_moveEngine
:
Index
out
of
bounds
!
"
)
;
if
(
!
(
aEngine
instanceof
Ci
.
nsISearchEngine
)
)
FAIL
(
"
SRCH_SVC_moveEngine
:
Invalid
engine
passed
to
moveEngine
!
"
)
;
if
(
aEngine
.
hidden
)
FAIL
(
"
moveEngine
:
Can
'
t
move
a
hidden
engine
!
"
Cr
.
NS_ERROR_FAILURE
)
;
var
engine
=
aEngine
.
wrappedJSObject
;
var
currentIndex
=
this
.
_sortedEngines
.
indexOf
(
engine
)
;
if
(
currentIndex
=
=
-
1
)
FAIL
(
"
moveEngine
:
Can
'
t
find
engine
to
move
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
var
newIndexEngine
=
this
.
_getSortedEngines
(
false
)
[
aNewIndex
]
;
if
(
!
newIndexEngine
)
FAIL
(
"
moveEngine
:
Can
'
t
find
engine
to
replace
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
for
(
var
i
=
0
;
i
<
this
.
_sortedEngines
.
length
;
+
+
i
)
{
if
(
newIndexEngine
=
=
this
.
_sortedEngines
[
i
]
)
break
;
if
(
this
.
_sortedEngines
[
i
]
.
hidden
)
aNewIndex
+
+
;
}
if
(
currentIndex
=
=
aNewIndex
)
return
;
var
movedEngine
=
this
.
__sortedEngines
.
splice
(
currentIndex
1
)
[
0
]
;
this
.
__sortedEngines
.
splice
(
aNewIndex
0
movedEngine
)
;
notifyAction
(
engine
SEARCH_ENGINE_CHANGED
)
;
this
.
_saveSortedEngineList
(
)
;
}
restoreDefaultEngines
:
function
SRCH_SVC_resetDefaultEngines
(
)
{
this
.
_ensureInitialized
(
)
;
for
(
let
name
in
this
.
_engines
)
{
let
e
=
this
.
_engines
[
name
]
;
if
(
e
.
hidden
&
&
e
.
_isDefault
)
e
.
hidden
=
false
;
}
}
get
defaultEngine
(
)
{
return
this
.
currentEngine
;
}
set
defaultEngine
(
val
)
{
this
.
currentEngine
=
val
;
}
get
currentEngine
(
)
{
this
.
_ensureInitialized
(
)
;
if
(
!
this
.
_currentEngine
)
{
let
name
=
this
.
getGlobalAttr
(
"
current
"
)
;
let
engine
=
this
.
getEngineByName
(
name
)
;
if
(
engine
&
&
(
this
.
getGlobalAttr
(
"
hash
"
)
=
=
getVerificationHash
(
name
)
|
|
engine
.
_isDefault
)
)
{
this
.
_currentEngine
=
engine
;
}
if
(
!
name
)
this
.
_currentEngine
=
this
.
originalDefaultEngine
;
}
if
(
!
this
.
_currentEngine
|
|
this
.
_currentEngine
.
hidden
)
{
let
originalDefault
=
this
.
originalDefaultEngine
;
if
(
!
originalDefault
|
|
originalDefault
.
hidden
)
{
let
firstVisible
=
this
.
_getSortedEngines
(
false
)
[
0
]
;
if
(
firstVisible
&
&
!
firstVisible
.
hidden
)
{
this
.
currentEngine
=
firstVisible
;
return
firstVisible
;
}
if
(
originalDefault
)
originalDefault
.
hidden
=
false
;
}
if
(
!
originalDefault
)
return
null
;
this
.
currentEngine
=
originalDefault
;
}
return
this
.
_currentEngine
;
}
set
currentEngine
(
val
)
{
this
.
_ensureInitialized
(
)
;
if
(
!
(
val
instanceof
Ci
.
nsISearchEngine
)
&
&
!
(
val
instanceof
Engine
)
)
FAIL
(
"
Invalid
argument
passed
to
currentEngine
setter
"
)
;
var
newCurrentEngine
=
this
.
getEngineByName
(
val
.
name
)
;
if
(
!
newCurrentEngine
)
FAIL
(
"
Can
'
t
find
engine
in
store
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
if
(
!
newCurrentEngine
.
_isDefault
)
{
if
(
!
newCurrentEngine
.
_loadPath
)
newCurrentEngine
.
_loadPath
=
"
[
other
]
unknown
"
;
let
loadPathHash
=
getVerificationHash
(
newCurrentEngine
.
_loadPath
)
;
let
currentHash
=
newCurrentEngine
.
getAttr
(
"
loadPathHash
"
)
;
if
(
!
currentHash
|
|
currentHash
!
=
loadPathHash
)
{
newCurrentEngine
.
setAttr
(
"
loadPathHash
"
loadPathHash
)
;
notifyAction
(
newCurrentEngine
SEARCH_ENGINE_CHANGED
)
;
}
}
if
(
newCurrentEngine
=
=
this
.
_currentEngine
)
return
;
this
.
_currentEngine
=
newCurrentEngine
;
let
newName
=
this
.
_currentEngine
.
name
;
if
(
this
.
_currentEngine
=
=
this
.
originalDefaultEngine
)
{
newName
=
"
"
;
}
this
.
setGlobalAttr
(
"
current
"
newName
)
;
this
.
setGlobalAttr
(
"
hash
"
getVerificationHash
(
newName
)
)
;
notifyAction
(
this
.
_currentEngine
SEARCH_ENGINE_DEFAULT
)
;
notifyAction
(
this
.
_currentEngine
SEARCH_ENGINE_CURRENT
)
;
}
getDefaultEngineInfo
(
)
{
let
result
=
{
}
;
let
engine
;
try
{
engine
=
this
.
defaultEngine
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
getDefaultEngineInfo
:
No
default
engine
"
)
;
}
if
(
!
engine
)
{
result
.
name
=
"
NONE
"
;
}
else
{
if
(
engine
.
name
)
result
.
name
=
engine
.
name
;
result
.
loadPath
=
engine
.
_loadPath
;
let
origin
;
if
(
engine
.
_isDefault
)
origin
=
"
default
"
;
else
{
let
currentHash
=
engine
.
getAttr
(
"
loadPathHash
"
)
;
if
(
!
currentHash
)
origin
=
"
unverified
"
;
else
{
let
loadPathHash
=
getVerificationHash
(
engine
.
_loadPath
)
;
origin
=
currentHash
=
=
loadPathHash
?
"
verified
"
:
"
invalid
"
;
}
}
result
.
origin
=
origin
;
let
sendSubmissionURL
=
engine
.
_isDefault
;
if
(
!
sendSubmissionURL
)
{
let
extras
=
Services
.
prefs
.
getChildList
(
BROWSER_SEARCH_PREF
+
"
order
.
extra
.
"
)
;
for
(
let
prefName
of
extras
)
{
try
{
if
(
result
.
name
=
=
Services
.
prefs
.
getCharPref
(
prefName
)
)
{
sendSubmissionURL
=
true
;
break
;
}
}
catch
(
e
)
{
}
}
let
prefNameBase
=
getGeoSpecificPrefName
(
BROWSER_SEARCH_PREF
+
"
order
"
)
;
let
i
=
0
;
while
(
!
sendSubmissionURL
)
{
let
prefName
=
prefNameBase
+
"
.
"
+
(
+
+
i
)
;
let
engineName
=
getLocalizedPref
(
prefName
)
;
if
(
!
engineName
)
break
;
if
(
result
.
name
=
=
engineName
)
{
sendSubmissionURL
=
true
;
break
;
}
}
}
if
(
sendSubmissionURL
)
{
let
uri
=
engine
.
_getURLOfType
(
"
text
/
html
"
)
.
getSubmission
(
"
"
engine
"
searchbar
"
)
.
uri
;
uri
.
userPass
=
"
"
;
result
.
submissionURL
=
uri
.
spec
;
}
}
return
result
;
}
_recordEngineTelemetry
(
)
{
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_ENGINE_COUNT
"
)
.
add
(
Object
.
keys
(
this
.
_engines
)
.
length
)
;
}
_parseSubmissionMap
:
null
_buildParseSubmissionMap
:
function
SRCH_SVC__buildParseSubmissionMap
(
)
{
LOG
(
"
_buildParseSubmissionMap
"
)
;
this
.
_parseSubmissionMap
=
new
Map
(
)
;
let
keysOfAlternates
=
new
Set
(
)
;
for
(
let
engine
of
this
.
_sortedEngines
)
{
LOG
(
"
Processing
engine
:
"
+
engine
.
name
)
;
if
(
engine
.
hidden
)
{
LOG
(
"
Engine
is
hidden
.
"
)
;
continue
;
}
let
urlParsingInfo
=
engine
.
getURLParsingInfo
(
)
;
if
(
!
urlParsingInfo
)
{
LOG
(
"
Engine
does
not
support
URL
parsing
.
"
)
;
continue
;
}
let
mapValueForEngine
=
{
engine
termsParameterName
:
urlParsingInfo
.
termsParameterName
}
;
let
processDomain
=
(
domain
isAlternate
)
=
>
{
let
key
=
domain
+
urlParsingInfo
.
path
;
let
existingEntry
=
this
.
_parseSubmissionMap
.
get
(
key
)
;
if
(
!
existingEntry
)
{
LOG
(
"
Adding
new
entry
:
"
+
key
)
;
if
(
isAlternate
)
{
keysOfAlternates
.
add
(
key
)
;
}
}
else
if
(
!
isAlternate
&
&
keysOfAlternates
.
has
(
key
)
)
{
LOG
(
"
Overriding
alternate
entry
:
"
+
key
+
"
(
"
+
existingEntry
.
engine
.
name
+
"
)
"
)
;
keysOfAlternates
.
delete
(
key
)
;
}
else
{
LOG
(
"
Keeping
existing
entry
:
"
+
key
+
"
(
"
+
existingEntry
.
engine
.
name
+
"
)
"
)
;
return
;
}
this
.
_parseSubmissionMap
.
set
(
key
mapValueForEngine
)
;
}
;
processDomain
(
urlParsingInfo
.
mainDomain
false
)
;
SearchStaticData
.
getAlternateDomains
(
urlParsingInfo
.
mainDomain
)
.
forEach
(
d
=
>
processDomain
(
d
true
)
)
;
}
}
hasEngineWithURL
(
method
template
formData
)
{
this
.
_ensureInitialized
(
)
;
let
getSortedFormData
=
data
=
>
{
return
data
.
filter
(
a
=
>
a
.
name
&
&
a
.
value
)
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
name
>
b
.
name
)
{
return
1
;
}
else
if
(
b
.
name
>
a
.
name
)
{
return
-
1
;
}
else
if
(
a
.
value
>
b
.
value
)
{
return
1
;
}
return
(
b
.
value
>
a
.
value
)
?
-
1
:
0
;
}
)
;
}
;
let
methodUpper
=
method
.
toUpperCase
(
)
;
let
sortedFormData
=
getSortedFormData
(
formData
)
;
let
sortedFormLength
=
sortedFormData
.
length
;
return
this
.
_getSortedEngines
(
false
)
.
some
(
engine
=
>
{
return
engine
.
_urls
.
some
(
url
=
>
{
if
(
url
.
type
!
=
URLTYPE_SEARCH_HTML
|
|
url
.
method
!
=
methodUpper
|
|
url
.
template
!
=
template
|
|
url
.
params
.
length
!
=
sortedFormLength
)
{
return
false
;
}
let
sortedParams
=
getSortedFormData
(
url
.
params
)
;
for
(
let
i
=
0
;
i
<
sortedFormLength
;
i
+
+
)
{
let
formData
=
sortedFormData
[
i
]
;
let
param
=
sortedParams
[
i
]
;
if
(
param
.
name
!
=
formData
.
name
|
|
param
.
value
!
=
formData
.
value
|
|
param
.
purpose
!
=
formData
.
purpose
)
{
return
false
;
}
}
return
true
;
}
)
;
}
)
;
}
parseSubmissionURL
:
function
SRCH_SVC_parseSubmissionURL
(
aURL
)
{
this
.
_ensureInitialized
(
)
;
LOG
(
"
parseSubmissionURL
:
Parsing
\
"
"
+
aURL
+
"
\
"
.
"
)
;
if
(
!
this
.
_parseSubmissionMap
)
{
this
.
_buildParseSubmissionMap
(
)
;
}
let
soughtKey
soughtQuery
;
try
{
let
soughtUrl
=
Services
.
io
.
newURI
(
aURL
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
if
(
soughtUrl
.
scheme
!
=
"
http
"
&
&
soughtUrl
.
scheme
!
=
"
https
"
)
{
LOG
(
"
The
URL
scheme
is
not
HTTP
or
HTTPS
.
"
)
;
return
gEmptyParseSubmissionResult
;
}
soughtKey
=
soughtUrl
.
host
+
soughtUrl
.
filePath
.
toLowerCase
(
)
;
soughtQuery
=
soughtUrl
.
query
;
}
catch
(
ex
)
{
LOG
(
"
The
value
does
not
look
like
a
structured
URL
.
"
)
;
return
gEmptyParseSubmissionResult
;
}
let
mapEntry
=
this
.
_parseSubmissionMap
.
get
(
soughtKey
)
;
if
(
!
mapEntry
)
{
LOG
(
"
No
engine
associated
with
domain
and
path
:
"
+
soughtKey
)
;
return
gEmptyParseSubmissionResult
;
}
let
encodedTerms
=
null
;
for
(
let
param
of
soughtQuery
.
split
(
"
&
"
)
)
{
let
equalPos
=
param
.
indexOf
(
"
=
"
)
;
if
(
equalPos
!
=
-
1
&
&
param
.
substr
(
0
equalPos
)
=
=
mapEntry
.
termsParameterName
)
{
encodedTerms
=
param
.
substr
(
equalPos
+
1
)
;
break
;
}
}
if
(
encodedTerms
=
=
=
null
)
{
LOG
(
"
Missing
terms
parameter
:
"
+
mapEntry
.
termsParameterName
)
;
return
gEmptyParseSubmissionResult
;
}
let
length
=
0
;
let
offset
=
aURL
.
indexOf
(
"
?
"
)
+
1
;
let
query
=
aURL
.
slice
(
offset
)
;
for
(
let
param
of
query
.
split
(
"
&
"
)
)
{
let
equalPos
=
param
.
indexOf
(
"
=
"
)
;
if
(
equalPos
!
=
-
1
&
&
param
.
substr
(
0
equalPos
)
=
=
mapEntry
.
termsParameterName
)
{
offset
+
=
equalPos
+
1
;
length
=
param
.
length
-
equalPos
-
1
;
break
;
}
offset
+
=
param
.
length
+
1
;
}
let
terms
;
try
{
terms
=
gTextToSubURI
.
UnEscapeAndConvert
(
mapEntry
.
engine
.
queryCharset
encodedTerms
.
replace
(
/
\
+
/
g
"
"
)
)
;
}
catch
(
ex
)
{
LOG
(
"
Parameter
decoding
failed
.
Charset
:
"
+
mapEntry
.
engine
.
queryCharset
)
;
return
gEmptyParseSubmissionResult
;
}
LOG
(
"
Match
found
.
Terms
:
"
+
terms
)
;
return
new
ParseSubmissionResult
(
mapEntry
.
engine
terms
offset
length
)
;
}
observe
:
function
SRCH_SVC_observe
(
aEngine
aTopic
aVerb
)
{
switch
(
aTopic
)
{
case
SEARCH_ENGINE_TOPIC
:
switch
(
aVerb
)
{
case
SEARCH_ENGINE_LOADED
:
var
engine
=
aEngine
.
QueryInterface
(
Ci
.
nsISearchEngine
)
;
LOG
(
"
nsSearchService
:
:
observe
:
Done
installation
of
"
+
engine
.
name
+
"
.
"
)
;
this
.
_addEngineToStore
(
engine
.
wrappedJSObject
)
;
if
(
engine
.
wrappedJSObject
.
_useNow
)
{
LOG
(
"
nsSearchService
:
:
observe
:
setting
current
"
)
;
this
.
currentEngine
=
aEngine
;
}
break
;
case
SEARCH_ENGINE_ADDED
:
case
SEARCH_ENGINE_CHANGED
:
case
SEARCH_ENGINE_REMOVED
:
this
.
batchTask
.
disarm
(
)
;
this
.
batchTask
.
arm
(
)
;
this
.
_parseSubmissionMap
=
null
;
break
;
}
break
;
case
QUIT_APPLICATION_TOPIC
:
this
.
_removeObservers
(
)
;
break
;
case
"
nsPref
:
changed
"
:
if
(
aVerb
=
=
LOCALE_PREF
)
{
this
.
_asyncReInit
(
)
;
break
;
}
}
}
notify
:
function
SRCH_SVC_notify
(
aTimer
)
{
LOG
(
"
_notify
:
checking
for
updates
"
)
;
if
(
!
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
update
"
true
)
)
return
;
var
currentTime
=
Date
.
now
(
)
;
LOG
(
"
currentTime
:
"
+
currentTime
)
;
for
(
let
name
in
this
.
_engines
)
{
let
engine
=
this
.
_engines
[
name
]
.
wrappedJSObject
;
if
(
!
engine
.
_hasUpdates
)
continue
;
LOG
(
"
checking
"
+
engine
.
name
)
;
var
expirTime
=
engine
.
getAttr
(
"
updateexpir
"
)
;
LOG
(
"
expirTime
:
"
+
expirTime
+
"
\
nupdateURL
:
"
+
engine
.
_updateURL
+
"
\
niconUpdateURL
:
"
+
engine
.
_iconUpdateURL
)
;
var
engineExpired
=
expirTime
<
=
currentTime
;
if
(
!
expirTime
|
|
!
engineExpired
)
{
LOG
(
"
skipping
engine
"
)
;
continue
;
}
LOG
(
engine
.
name
+
"
has
expired
"
)
;
engineUpdateService
.
update
(
engine
)
;
engineUpdateService
.
scheduleNextUpdate
(
engine
)
;
}
}
_addObservers
:
function
SRCH_SVC_addObservers
(
)
{
if
(
this
.
_observersAdded
)
{
return
;
}
this
.
_observersAdded
=
true
;
Services
.
obs
.
addObserver
(
this
SEARCH_ENGINE_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
QUIT_APPLICATION_TOPIC
)
;
if
(
AppConstants
.
MOZ_BUILD_APP
=
=
"
mobile
/
android
"
)
{
Services
.
prefs
.
addObserver
(
LOCALE_PREF
this
)
;
}
let
shutdownState
=
{
step
:
"
Not
started
"
latestError
:
{
message
:
undefined
stack
:
undefined
}
}
;
OS
.
File
.
profileBeforeChange
.
addBlocker
(
"
Search
service
:
shutting
down
"
(
)
=
>
(
async
(
)
=
>
{
if
(
this
.
_batchTask
)
{
shutdownState
.
step
=
"
Finalizing
batched
task
"
;
try
{
await
this
.
_batchTask
.
finalize
(
)
;
shutdownState
.
step
=
"
Batched
task
finalized
"
;
}
catch
(
ex
)
{
shutdownState
.
step
=
"
Batched
task
failed
to
finalize
"
;
shutdownState
.
latestError
.
message
=
"
"
+
ex
;
if
(
ex
&
&
typeof
ex
=
=
"
object
"
)
{
shutdownState
.
latestError
.
stack
=
ex
.
stack
|
|
undefined
;
}
Promise
.
reject
(
ex
)
;
}
}
}
)
(
)
(
)
=
>
shutdownState
)
;
}
_observersAdded
:
false
_removeObservers
:
function
SRCH_SVC_removeObservers
(
)
{
Services
.
obs
.
removeObserver
(
this
SEARCH_ENGINE_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
QUIT_APPLICATION_TOPIC
)
;
if
(
AppConstants
.
MOZ_BUILD_APP
=
=
"
mobile
/
android
"
)
{
Services
.
prefs
.
removeObserver
(
LOCALE_PREF
this
)
;
}
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIBrowserSearchService
Ci
.
nsIObserver
Ci
.
nsITimerCallback
]
)
}
;
const
SEARCH_UPDATE_LOG_PREFIX
=
"
*
*
*
Search
update
:
"
;
function
ULOG
(
aText
)
{
if
(
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
update
.
log
"
false
)
)
{
dump
(
SEARCH_UPDATE_LOG_PREFIX
+
aText
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
aText
)
;
}
}
var
engineUpdateService
=
{
scheduleNextUpdate
:
function
eus_scheduleNextUpdate
(
aEngine
)
{
var
interval
=
aEngine
.
_updateInterval
|
|
SEARCH_DEFAULT_UPDATE_INTERVAL
;
var
milliseconds
=
interval
*
86400000
;
aEngine
.
setAttr
(
"
updateexpir
"
Date
.
now
(
)
+
milliseconds
)
;
}
update
:
function
eus_Update
(
aEngine
)
{
let
engine
=
aEngine
.
wrappedJSObject
;
ULOG
(
"
update
called
for
"
+
aEngine
.
_name
)
;
if
(
!
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
update
"
true
)
|
|
!
engine
.
_hasUpdates
)
return
;
let
testEngine
=
null
;
let
updateURL
=
engine
.
_getURLOfType
(
URLTYPE_OPENSEARCH
)
;
let
updateURI
=
(
updateURL
&
&
updateURL
.
_hasRelation
(
"
self
"
)
)
?
updateURL
.
getSubmission
(
"
"
engine
)
.
uri
:
makeURI
(
engine
.
_updateURL
)
;
if
(
updateURI
)
{
if
(
engine
.
_isDefault
&
&
!
updateURI
.
schemeIs
(
"
https
"
)
)
{
ULOG
(
"
Invalid
scheme
for
default
engine
update
"
)
;
return
;
}
ULOG
(
"
updating
"
+
engine
.
name
+
"
from
"
+
updateURI
.
spec
)
;
testEngine
=
new
Engine
(
updateURI
false
)
;
testEngine
.
_engineToUpdate
=
engine
;
testEngine
.
_initFromURIAndLoad
(
updateURI
)
;
}
else
ULOG
(
"
invalid
updateURI
"
)
;
if
(
engine
.
_iconUpdateURL
)
{
(
testEngine
|
|
engine
)
.
_setIcon
(
engine
.
_iconUpdateURL
true
)
;
}
}
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
SearchService
]
)
;
