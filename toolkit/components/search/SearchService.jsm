const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
DeferredTask
:
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
SearchStaticData
:
"
resource
:
/
/
gre
/
modules
/
SearchStaticData
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
ExtensionParent
:
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
gEnvironment
:
[
"
mozilla
.
org
/
process
/
environment
;
1
"
"
nsIEnvironment
"
]
gChromeReg
:
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
"
nsIChromeRegistry
"
]
}
)
;
const
BROWSER_SEARCH_PREF
=
"
browser
.
search
.
"
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
loggingEnabled
"
BROWSER_SEARCH_PREF
+
"
log
"
false
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
distroID
"
(
)
=
>
{
return
Services
.
prefs
.
getDefaultBranch
(
"
distribution
.
"
)
.
getCharPref
(
"
id
"
"
"
)
;
}
)
;
const
BinaryInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
binaryinputstream
;
1
"
"
nsIBinaryInputStream
"
"
setInputStream
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
DOMParser
"
"
XMLHttpRequest
"
"
URLSearchParams
"
]
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gEncoder
"
function
(
)
{
return
new
TextEncoder
(
)
;
}
)
;
const
NS_APP_DISTRIBUTION_SEARCH_DIR_LIST
=
"
SrchPluginsDistDL
"
;
const
EXT_SEARCH_PREFIX
=
"
resource
:
/
/
search
-
extensions
/
"
;
const
APP_SEARCH_PREFIX
=
"
resource
:
/
/
search
-
plugins
/
"
;
const
EXT_SIGNING_ADDRESS
=
"
search
.
mozilla
.
org
"
;
const
SEARCH_ENGINE_TOPIC
=
"
browser
-
search
-
engine
-
modified
"
;
const
TOPIC_LOCALES_CHANGE
=
"
intl
:
app
-
locales
-
changed
"
;
const
QUIT_APPLICATION_TOPIC
=
"
quit
-
application
"
;
const
SEARCH_ENGINE_REMOVED
=
"
engine
-
removed
"
;
const
SEARCH_ENGINE_ADDED
=
"
engine
-
added
"
;
const
SEARCH_ENGINE_CHANGED
=
"
engine
-
changed
"
;
const
SEARCH_ENGINE_LOADED
=
"
engine
-
loaded
"
;
const
SEARCH_ENGINE_DEFAULT
=
"
engine
-
default
"
;
const
SEARCH_SERVICE_TOPIC
=
"
browser
-
search
-
service
"
;
const
SEARCH_SERVICE_CACHE_WRITTEN
=
"
write
-
cache
-
to
-
disk
-
complete
"
;
const
CACHE_INVALIDATION_DELAY
=
1000
;
const
CACHE_VERSION
=
1
;
const
CACHE_FILENAME
=
"
search
.
json
.
mozlz4
"
;
const
MAX_ICON_SIZE
=
20000
;
const
DEFAULT_QUERY_CHARSET
=
"
ISO
-
8859
-
1
"
;
const
SEARCH_BUNDLE
=
"
chrome
:
/
/
global
/
locale
/
search
/
search
.
properties
"
;
const
BRAND_BUNDLE
=
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
;
const
OPENSEARCH_NS_10
=
"
http
:
/
/
a9
.
com
/
-
/
spec
/
opensearch
/
1
.
0
/
"
;
const
OPENSEARCH_NS_11
=
"
http
:
/
/
a9
.
com
/
-
/
spec
/
opensearch
/
1
.
1
/
"
;
const
OPENSEARCH_NAMESPACES
=
[
OPENSEARCH_NS_11
OPENSEARCH_NS_10
"
http
:
/
/
a9
.
com
/
-
/
spec
/
opensearchdescription
/
1
.
1
/
"
"
http
:
/
/
a9
.
com
/
-
/
spec
/
opensearchdescription
/
1
.
0
/
"
]
;
const
OPENSEARCH_LOCALNAME
=
"
OpenSearchDescription
"
;
const
MOZSEARCH_NS_10
=
"
http
:
/
/
www
.
mozilla
.
org
/
2006
/
browser
/
search
/
"
;
const
MOZSEARCH_LOCALNAME
=
"
SearchPlugin
"
;
const
URLTYPE_SUGGEST_JSON
=
"
application
/
x
-
suggestions
+
json
"
;
const
URLTYPE_SEARCH_HTML
=
"
text
/
html
"
;
const
URLTYPE_OPENSEARCH
=
"
application
/
opensearchdescription
+
xml
"
;
const
USER_DEFINED
=
"
searchTerms
"
;
const
MOZ_PARAM_LOCALE
=
"
moz
:
locale
"
;
const
MOZ_PARAM_DIST_ID
=
"
moz
:
distributionID
"
;
const
MOZ_PARAM_OFFICIAL
=
"
moz
:
official
"
;
const
OS_PARAM_INPUT_ENCODING
=
"
inputEncoding
"
;
const
OS_PARAM_LANGUAGE
=
"
language
"
;
const
OS_PARAM_OUTPUT_ENCODING
=
"
outputEncoding
"
;
const
OS_PARAM_LANGUAGE_DEF
=
"
*
"
;
const
OS_PARAM_OUTPUT_ENCODING_DEF
=
"
UTF
-
8
"
;
const
OS_PARAM_INPUT_ENCODING_DEF
=
"
UTF
-
8
"
;
const
OS_PARAM_COUNT
=
"
count
"
;
const
OS_PARAM_START_INDEX
=
"
startIndex
"
;
const
OS_PARAM_START_PAGE
=
"
startPage
"
;
const
OS_PARAM_COUNT_DEF
=
"
20
"
;
const
OS_PARAM_START_INDEX_DEF
=
"
1
"
;
const
OS_PARAM_START_PAGE_DEF
=
"
1
"
;
var
OS_UNSUPPORTED_PARAMS
=
[
[
OS_PARAM_COUNT
OS_PARAM_COUNT_DEF
]
[
OS_PARAM_START_INDEX
OS_PARAM_START_INDEX_DEF
]
[
OS_PARAM_START_PAGE
OS_PARAM_START_PAGE_DEF
]
]
;
const
SEARCH_DEFAULT_UPDATE_INTERVAL
=
7
;
const
SEARCH_GEO_DEFAULT_UPDATE_INTERVAL
=
2592000
;
const
MULTI_LOCALE_ENGINES
=
[
"
amazon
"
"
amazondotcom
"
"
bolcom
"
"
ebay
"
"
google
"
"
marktplaats
"
"
mercadolibre
"
"
twitter
"
"
wikipedia
"
"
wiktionary
"
"
yandex
"
"
multilocale
"
]
;
const
DEFAULT_TAG
=
"
default
"
;
const
SEARCH_LOG_PREFIX
=
"
*
*
*
Search
:
"
;
const
SETTINGS_IGNORELIST_KEY
=
"
hijack
-
blocklists
"
;
function
LOG
(
text
)
{
if
(
loggingEnabled
)
{
dump
(
SEARCH_LOG_PREFIX
+
text
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
text
)
;
}
}
function
ERROR
(
message
resultCode
)
{
throw
Components
.
Exception
(
message
resultCode
)
;
}
function
FAIL
(
message
resultCode
)
{
LOG
(
message
)
;
throw
Components
.
Exception
(
message
resultCode
|
|
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
function
limitURILength
(
str
len
)
{
len
=
len
|
|
140
;
if
(
str
.
length
>
len
)
return
str
.
slice
(
0
len
)
+
"
.
.
.
"
;
return
str
;
}
function
ENSURE_WARN
(
assertion
message
resultCode
)
{
if
(
!
assertion
)
throw
Components
.
Exception
(
message
resultCode
)
;
}
function
loadListener
(
channel
engine
callback
)
{
this
.
_channel
=
channel
;
this
.
_bytes
=
[
]
;
this
.
_engine
=
engine
;
this
.
_callback
=
callback
;
}
loadListener
.
prototype
=
{
_callback
:
null
_channel
:
null
_countRead
:
0
_engine
:
null
_stream
:
null
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIRequestObserver
Ci
.
nsIStreamListener
Ci
.
nsIChannelEventSink
Ci
.
nsIInterfaceRequestor
Ci
.
nsIProgressEventSink
]
)
onStartRequest
(
request
)
{
LOG
(
"
loadListener
:
Starting
request
:
"
+
request
.
name
)
;
this
.
_stream
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
}
onStopRequest
(
request
statusCode
)
{
LOG
(
"
loadListener
:
Stopping
request
:
"
+
request
.
name
)
;
var
requestFailed
=
!
Components
.
isSuccessCode
(
statusCode
)
;
if
(
!
requestFailed
&
&
(
request
instanceof
Ci
.
nsIHttpChannel
)
)
requestFailed
=
!
request
.
requestSucceeded
;
if
(
requestFailed
|
|
this
.
_countRead
=
=
0
)
{
LOG
(
"
loadListener
:
request
failed
!
"
)
;
this
.
_bytes
=
null
;
}
this
.
_callback
(
this
.
_bytes
this
.
_engine
)
;
this
.
_channel
=
null
;
this
.
_engine
=
null
;
}
onDataAvailable
(
request
inputStream
offset
count
)
{
this
.
_stream
.
setInputStream
(
inputStream
)
;
this
.
_bytes
=
this
.
_bytes
.
concat
(
this
.
_stream
.
readByteArray
(
count
)
)
;
this
.
_countRead
+
=
count
;
}
asyncOnChannelRedirect
(
oldChannel
newChannel
flags
callback
)
{
this
.
_channel
=
newChannel
;
callback
.
onRedirectVerifyCallback
(
Cr
.
NS_OK
)
;
}
getInterface
(
iid
)
{
return
this
.
QueryInterface
(
iid
)
;
}
onProgress
(
request
context
progress
progressMax
)
{
}
onStatus
(
request
context
status
statusArg
)
{
}
}
;
function
rescaleIcon
(
byteArray
contentType
size
=
32
)
{
if
(
contentType
=
=
"
image
/
svg
+
xml
"
)
throw
new
Error
(
"
Cannot
rescale
SVG
image
"
)
;
let
imgTools
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
;
let
arrayBuffer
=
(
new
Int8Array
(
byteArray
)
)
.
buffer
;
let
container
=
imgTools
.
decodeImageFromArrayBuffer
(
arrayBuffer
contentType
)
;
let
stream
=
imgTools
.
encodeScaledImage
(
container
"
image
/
png
"
size
size
)
;
let
streamSize
=
stream
.
available
(
)
;
if
(
streamSize
>
MAX_ICON_SIZE
)
throw
new
Error
(
"
Icon
is
too
big
"
)
;
let
bis
=
new
BinaryInputStream
(
stream
)
;
return
[
bis
.
readByteArray
(
streamSize
)
"
image
/
png
"
]
;
}
function
isPartnerBuild
(
)
{
return
distroID
&
&
!
distroID
.
startsWith
(
"
mozilla
"
)
;
}
function
geoSpecificDefaultsEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
browser
.
search
.
geoSpecificDefaults
"
false
)
;
}
function
isUSTimezone
(
)
{
let
UTCOffset
=
(
new
Date
(
)
)
.
getTimezoneOffset
(
)
;
return
UTCOffset
>
=
150
&
&
UTCOffset
<
=
600
;
}
var
ensureKnownRegion
=
async
function
(
ss
)
{
let
region
=
Services
.
prefs
.
getCharPref
(
"
browser
.
search
.
region
"
"
"
)
;
try
{
if
(
!
region
)
{
await
fetchRegion
(
ss
)
;
}
else
if
(
geoSpecificDefaultsEnabled
(
)
)
{
let
expired
=
(
ss
.
getGlobalAttr
(
"
searchDefaultExpir
"
)
|
|
0
)
<
=
Date
.
now
(
)
;
let
defaultEngine
=
ss
.
getVerifiedGlobalAttr
(
"
searchDefault
"
)
;
let
visibleDefaultEngines
=
ss
.
getVerifiedGlobalAttr
(
"
visibleDefaultEngines
"
)
;
let
hasValidHashes
=
(
defaultEngine
|
|
defaultEngine
=
=
=
undefined
)
&
&
(
visibleDefaultEngines
|
|
visibleDefaultEngines
=
=
=
undefined
)
;
if
(
expired
|
|
!
hasValidHashes
)
{
await
new
Promise
(
resolve
=
>
{
let
timeoutMS
=
Services
.
prefs
.
getIntPref
(
"
browser
.
search
.
geoip
.
timeout
"
)
;
let
timerId
=
setTimeout
(
(
)
=
>
{
timerId
=
null
;
resolve
(
)
;
}
timeoutMS
)
;
let
callback
=
(
)
=
>
{
clearTimeout
(
timerId
)
;
resolve
(
)
;
}
;
fetchRegionDefault
(
ss
)
.
then
(
callback
)
.
catch
(
err
=
>
{
Cu
.
reportError
(
err
)
;
callback
(
)
;
}
)
;
}
)
;
}
}
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_FETCH_CAUSED_SYNC_INIT
"
)
.
add
(
gInitialized
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
finally
{
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
ensure
-
known
-
region
-
done
"
)
;
}
}
;
function
storeRegion
(
region
)
{
let
isTimezoneUS
=
isUSTimezone
(
)
;
if
(
region
!
=
"
US
"
|
|
isTimezoneUS
)
{
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
region
"
region
)
;
}
if
(
region
=
=
"
US
"
&
&
!
isTimezoneUS
)
{
LOG
(
"
storeRegion
mismatch
-
US
Region
non
-
US
timezone
"
)
;
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_US_COUNTRY_MISMATCHED_TIMEZONE
"
)
.
add
(
1
)
;
}
if
(
region
!
=
"
US
"
&
&
isTimezoneUS
)
{
LOG
(
"
storeRegion
mismatch
-
non
-
US
Region
US
timezone
"
)
;
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_US_TIMEZONE_MISMATCHED_COUNTRY
"
)
.
add
(
1
)
;
}
let
platformCC
=
Services
.
sysinfo
.
get
(
"
countryCode
"
)
;
if
(
platformCC
)
{
let
probeUSMismatched
probeNonUSMismatched
;
switch
(
Services
.
appinfo
.
OS
)
{
case
"
Darwin
"
:
probeUSMismatched
=
"
SEARCH_SERVICE_US_COUNTRY_MISMATCHED_PLATFORM_OSX
"
;
probeNonUSMismatched
=
"
SEARCH_SERVICE_NONUS_COUNTRY_MISMATCHED_PLATFORM_OSX
"
;
break
;
case
"
WINNT
"
:
probeUSMismatched
=
"
SEARCH_SERVICE_US_COUNTRY_MISMATCHED_PLATFORM_WIN
"
;
probeNonUSMismatched
=
"
SEARCH_SERVICE_NONUS_COUNTRY_MISMATCHED_PLATFORM_WIN
"
;
break
;
default
:
Cu
.
reportError
(
"
Platform
"
+
Services
.
appinfo
.
OS
+
"
has
system
country
code
but
no
search
service
telemetry
probes
"
)
;
break
;
}
if
(
probeUSMismatched
&
&
probeNonUSMismatched
)
{
if
(
region
=
=
"
US
"
|
|
platformCC
=
=
"
US
"
)
{
Services
.
telemetry
.
getHistogramById
(
probeUSMismatched
)
.
add
(
region
!
=
platformCC
)
;
}
else
{
Services
.
telemetry
.
getHistogramById
(
probeNonUSMismatched
)
.
add
(
region
!
=
platformCC
)
;
}
}
}
}
function
fetchRegion
(
ss
)
{
const
TELEMETRY_RESULT_ENUM
=
{
SUCCESS
:
0
SUCCESS_WITHOUT_DATA
:
1
XHRTIMEOUT
:
2
ERROR
:
3
}
;
let
endpoint
=
Services
.
urlFormatter
.
formatURLPref
(
"
browser
.
search
.
geoip
.
url
"
)
;
LOG
(
"
_fetchRegion
starting
with
endpoint
"
+
endpoint
)
;
if
(
!
endpoint
)
{
return
Promise
.
resolve
(
)
;
}
let
startTime
=
Date
.
now
(
)
;
return
new
Promise
(
resolve
=
>
{
let
timeoutMS
=
Services
.
prefs
.
getIntPref
(
"
browser
.
search
.
geoip
.
timeout
"
)
;
let
geoipTimeoutPossible
=
true
;
let
timerId
=
setTimeout
(
(
)
=
>
{
LOG
(
"
_fetchRegion
:
timeout
fetching
region
information
"
)
;
if
(
geoipTimeoutPossible
)
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_TIMEOUT
"
)
.
add
(
1
)
;
timerId
=
null
;
resolve
(
)
;
}
timeoutMS
)
;
let
resolveAndReportSuccess
=
(
result
reason
)
=
>
{
if
(
result
)
{
storeRegion
(
result
)
;
}
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_FETCH_RESULT
"
)
.
add
(
reason
)
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
geoip
-
lookup
-
xhr
-
complete
"
)
;
if
(
timerId
)
{
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_TIMEOUT
"
)
.
add
(
0
)
;
geoipTimeoutPossible
=
false
;
}
let
callback
=
(
)
=
>
{
if
(
timerId
=
=
null
)
{
return
;
}
clearTimeout
(
timerId
)
;
resolve
(
)
;
}
;
if
(
result
&
&
geoSpecificDefaultsEnabled
(
)
)
{
fetchRegionDefault
(
ss
)
.
then
(
callback
)
.
catch
(
err
=
>
{
Cu
.
reportError
(
err
)
;
callback
(
)
;
}
)
;
}
else
{
callback
(
)
;
}
}
;
let
request
=
new
XMLHttpRequest
(
)
;
Services
.
obs
.
notifyObservers
(
request
SEARCH_SERVICE_TOPIC
"
geoip
-
lookup
-
xhr
-
starting
"
)
;
request
.
timeout
=
100000
;
request
.
onload
=
function
(
event
)
{
let
took
=
Date
.
now
(
)
-
startTime
;
let
region
=
event
.
target
.
response
&
&
event
.
target
.
response
.
country_code
;
LOG
(
"
_fetchRegion
got
success
response
in
"
+
took
+
"
ms
:
"
+
region
)
;
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_FETCH_TIME_MS
"
)
.
add
(
took
)
;
let
reason
=
region
?
TELEMETRY_RESULT_ENUM
.
SUCCESS
:
TELEMETRY_RESULT_ENUM
.
SUCCESS_WITHOUT_DATA
;
resolveAndReportSuccess
(
region
reason
)
;
}
;
request
.
ontimeout
=
function
(
event
)
{
LOG
(
"
_fetchRegion
:
XHR
finally
timed
-
out
fetching
region
information
"
)
;
resolveAndReportSuccess
(
null
TELEMETRY_RESULT_ENUM
.
XHRTIMEOUT
)
;
}
;
request
.
onerror
=
function
(
event
)
{
LOG
(
"
_fetchRegion
:
failed
to
retrieve
region
information
"
)
;
resolveAndReportSuccess
(
null
TELEMETRY_RESULT_ENUM
.
ERROR
)
;
}
;
request
.
open
(
"
POST
"
endpoint
true
)
;
request
.
setRequestHeader
(
"
Content
-
Type
"
"
application
/
json
"
)
;
request
.
responseType
=
"
json
"
;
request
.
send
(
"
{
}
"
)
;
}
)
;
}
function
convertGoogleEngines
(
engineNames
)
{
let
overrides
=
{
"
google
"
:
"
google
-
b
-
d
"
"
google
-
2018
"
:
"
google
-
b
-
1
-
d
"
}
;
let
mobileOverrides
=
{
"
google
"
:
"
google
-
b
-
m
"
"
google
-
2018
"
:
"
google
-
b
-
1
-
m
"
}
;
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
overrides
=
mobileOverrides
;
}
for
(
let
engine
in
overrides
)
{
let
index
=
engineNames
.
indexOf
(
engine
)
;
if
(
index
>
-
1
)
{
engineNames
[
index
]
=
overrides
[
engine
]
;
}
}
return
engineNames
;
}
var
fetchRegionDefault
=
(
ss
)
=
>
new
Promise
(
resolve
=
>
{
let
urlTemplate
=
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
.
getCharPref
(
"
geoSpecificDefaults
.
url
"
)
;
let
endpoint
=
Services
.
urlFormatter
.
formatURL
(
urlTemplate
)
;
if
(
!
endpoint
)
{
resolve
(
)
;
return
;
}
const
cohortPref
=
"
browser
.
search
.
cohort
"
;
let
cohort
=
Services
.
prefs
.
getCharPref
(
cohortPref
"
"
)
;
if
(
cohort
)
endpoint
+
=
"
/
"
+
cohort
;
LOG
(
"
fetchRegionDefault
starting
with
endpoint
"
+
endpoint
)
;
let
startTime
=
Date
.
now
(
)
;
let
request
=
new
XMLHttpRequest
(
)
;
request
.
timeout
=
100000
;
request
.
onload
=
function
(
event
)
{
let
took
=
Date
.
now
(
)
-
startTime
;
let
status
=
event
.
target
.
status
;
if
(
status
!
=
200
)
{
LOG
(
"
fetchRegionDefault
failed
with
HTTP
code
"
+
status
)
;
let
retryAfter
=
request
.
getResponseHeader
(
"
retry
-
after
"
)
;
if
(
retryAfter
)
{
ss
.
setGlobalAttr
(
"
searchDefaultExpir
"
Date
.
now
(
)
+
retryAfter
*
1000
)
;
}
resolve
(
)
;
return
;
}
let
response
=
event
.
target
.
response
|
|
{
}
;
LOG
(
"
received
"
+
response
.
toSource
(
)
)
;
if
(
response
.
cohort
)
{
Services
.
prefs
.
setCharPref
(
cohortPref
response
.
cohort
)
;
}
else
{
Services
.
prefs
.
clearUserPref
(
cohortPref
)
;
}
if
(
response
.
settings
&
&
response
.
settings
.
searchDefault
)
{
let
defaultEngine
=
response
.
settings
.
searchDefault
;
ss
.
setVerifiedGlobalAttr
(
"
searchDefault
"
defaultEngine
)
;
LOG
(
"
fetchRegionDefault
saved
searchDefault
:
"
+
defaultEngine
)
;
}
if
(
response
.
settings
&
&
response
.
settings
.
visibleDefaultEngines
)
{
let
visibleDefaultEngines
=
response
.
settings
.
visibleDefaultEngines
;
let
string
=
visibleDefaultEngines
.
join
(
"
"
)
;
ss
.
setVerifiedGlobalAttr
(
"
visibleDefaultEngines
"
string
)
;
LOG
(
"
fetchRegionDefault
saved
visibleDefaultEngines
:
"
+
string
)
;
}
let
interval
=
response
.
interval
|
|
SEARCH_GEO_DEFAULT_UPDATE_INTERVAL
;
let
milliseconds
=
interval
*
1000
;
ss
.
setGlobalAttr
(
"
searchDefaultExpir
"
Date
.
now
(
)
+
milliseconds
)
;
LOG
(
"
fetchRegionDefault
got
success
response
in
"
+
took
+
"
ms
"
)
;
ss
.
_maybeReloadEngines
(
)
.
finally
(
resolve
)
;
}
;
request
.
ontimeout
=
function
(
event
)
{
LOG
(
"
fetchRegionDefault
:
XHR
finally
timed
-
out
"
)
;
resolve
(
)
;
}
;
request
.
onerror
=
function
(
event
)
{
LOG
(
"
fetchRegionDefault
:
failed
to
retrieve
territory
default
information
"
)
;
resolve
(
)
;
}
;
request
.
open
(
"
GET
"
endpoint
true
)
;
request
.
setRequestHeader
(
"
Content
-
Type
"
"
application
/
json
"
)
;
request
.
responseType
=
"
json
"
;
request
.
send
(
)
;
}
)
;
function
getVerificationHash
(
name
)
{
let
disclaimer
=
"
By
modifying
this
file
I
agree
that
I
am
doing
so
"
+
"
only
within
appName
itself
using
official
user
-
driven
search
"
+
"
engine
selection
processes
and
in
a
way
which
does
not
circumvent
"
+
"
user
consent
.
I
acknowledge
that
any
attempt
to
change
this
file
"
+
"
from
outside
of
appName
is
a
malicious
act
and
will
be
responded
"
+
"
to
accordingly
.
"
;
let
salt
=
OS
.
Path
.
basename
(
OS
.
Constants
.
Path
.
profileDir
)
+
name
+
disclaimer
.
replace
(
/
\
appName
/
g
Services
.
appinfo
.
name
)
;
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
let
data
=
converter
.
convertToByteArray
(
salt
{
}
)
;
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA256
)
;
hasher
.
update
(
data
data
.
length
)
;
return
hasher
.
finish
(
true
)
;
}
function
makeURI
(
urlSpec
)
{
try
{
return
Services
.
io
.
newURI
(
urlSpec
)
;
}
catch
(
ex
)
{
}
return
null
;
}
function
makeChannel
(
url
)
{
try
{
let
uri
=
typeof
url
=
=
"
string
"
?
Services
.
io
.
newURI
(
url
)
:
url
;
return
Services
.
io
.
newChannelFromURI
(
uri
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
null
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
Ci
.
nsIContentPolicy
.
TYPE_OTHER
)
;
}
catch
(
ex
)
{
}
return
null
;
}
function
getDir
(
key
iface
)
{
if
(
!
key
)
FAIL
(
"
getDir
requires
a
directory
key
!
"
)
;
return
Services
.
dirsvc
.
get
(
key
iface
|
|
Ci
.
nsIFile
)
;
}
function
getLocale
(
)
{
return
Services
.
locale
.
requestedLocale
;
}
function
getLocalizedPref
(
prefName
defaultValue
)
{
try
{
return
Services
.
prefs
.
getComplexValue
(
prefName
Ci
.
nsIPrefLocalizedString
)
.
data
;
}
catch
(
ex
)
{
}
return
defaultValue
;
}
function
sanitizeName
(
name
)
{
const
maxLength
=
60
;
const
minLength
=
1
;
var
result
=
name
.
toLowerCase
(
)
;
result
=
result
.
replace
(
/
\
s
+
/
g
"
-
"
)
;
result
=
result
.
replace
(
/
[
^
-
a
-
z0
-
9
]
/
g
"
"
)
;
if
(
result
.
length
<
minLength
)
result
=
Math
.
random
(
)
.
toString
(
36
)
.
replace
(
/
^
.
*
\
.
/
"
"
)
;
return
result
.
substring
(
0
maxLength
)
;
}
function
getMozParamPref
(
prefName
)
{
let
branch
=
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
+
"
param
.
"
)
;
let
prefValue
=
branch
.
getCharPref
(
prefName
null
)
;
return
prefValue
?
encodeURIComponent
(
prefValue
)
:
null
;
}
var
gInitialized
=
false
;
var
gReinitializing
=
false
;
function
notifyAction
(
engine
verb
)
{
if
(
gInitialized
)
{
LOG
(
"
NOTIFY
:
Engine
:
\
"
"
+
engine
.
name
+
"
\
"
;
Verb
:
\
"
"
+
verb
+
"
\
"
"
)
;
Services
.
obs
.
notifyObservers
(
engine
SEARCH_ENGINE_TOPIC
verb
)
;
}
}
function
QueryParameter
(
name
value
purpose
)
{
if
(
!
name
|
|
(
value
=
=
null
)
)
FAIL
(
"
missing
name
or
value
for
QueryParameter
!
"
)
;
this
.
name
=
name
;
this
.
value
=
value
;
this
.
purpose
=
purpose
;
}
function
ParamSubstitution
(
paramValue
searchTerms
engine
)
{
const
PARAM_REGEXP
=
/
\
{
(
(
?
:
\
w
+
:
)
?
\
w
+
)
(
\
?
?
)
\
}
/
g
;
return
paramValue
.
replace
(
PARAM_REGEXP
function
(
match
name
optional
)
{
if
(
name
=
=
USER_DEFINED
)
return
searchTerms
;
if
(
name
=
=
OS_PARAM_INPUT_ENCODING
)
return
engine
.
queryCharset
;
if
(
name
.
startsWith
(
"
moz
:
"
)
&
&
engine
.
_isDefault
)
{
if
(
name
=
=
MOZ_PARAM_LOCALE
)
return
getLocale
(
)
;
if
(
name
=
=
MOZ_PARAM_DIST_ID
)
{
return
Services
.
prefs
.
getCharPref
(
BROWSER_SEARCH_PREF
+
"
distributionID
"
Services
.
appinfo
.
distributionID
|
|
"
"
)
;
}
if
(
name
=
=
MOZ_PARAM_OFFICIAL
)
{
if
(
Services
.
prefs
.
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
official
"
AppConstants
.
MOZ_OFFICIAL_BRANDING
)
)
return
"
official
"
;
return
"
unofficial
"
;
}
}
if
(
name
=
=
OS_PARAM_LANGUAGE
)
return
getLocale
(
)
|
|
OS_PARAM_LANGUAGE_DEF
;
if
(
name
=
=
OS_PARAM_OUTPUT_ENCODING
)
return
OS_PARAM_OUTPUT_ENCODING_DEF
;
if
(
optional
)
return
"
"
;
for
(
let
param
of
OS_UNSUPPORTED_PARAMS
)
{
if
(
name
=
=
param
[
0
]
)
return
param
[
1
]
;
}
return
match
;
}
)
;
}
const
ENGINE_ALIASES
=
new
Map
(
[
[
"
google
"
[
"
google
"
]
]
[
"
amazondotcom
"
[
"
amazon
"
]
]
[
"
amazondotcom
-
de
"
[
"
amazon
"
]
]
[
"
amazon
-
en
-
GB
"
[
"
amazon
"
]
]
[
"
amazon
-
france
"
[
"
amazon
"
]
]
[
"
amazon
-
jp
"
[
"
amazon
"
]
]
[
"
amazon
-
it
"
[
"
amazon
"
]
]
[
"
twitter
"
[
"
twitter
"
]
]
[
"
wikipedia
"
[
"
wikipedia
"
]
]
[
"
ebay
"
[
"
ebay
"
]
]
[
"
bing
"
[
"
bing
"
]
]
[
"
ddg
"
[
"
duckduckgo
"
"
ddg
"
]
]
[
"
yandex
"
[
"
\
u044F
\
u043D
\
u0434
\
u0435
\
u043A
\
u0441
"
"
yandex
"
]
]
[
"
baidu
"
[
"
\
u767E
\
u5EA6
"
"
baidu
"
]
]
]
)
;
function
getInternalAliases
(
engine
)
{
if
(
!
engine
.
_isDefault
)
{
return
[
]
;
}
for
(
let
[
name
aliases
]
of
ENGINE_ALIASES
)
{
if
(
engine
.
_shortName
.
startsWith
(
name
)
)
{
return
aliases
;
}
}
return
[
]
;
}
function
EngineURL
(
mimeType
requestMethod
template
resultDomain
)
{
if
(
!
mimeType
|
|
!
requestMethod
|
|
!
template
)
FAIL
(
"
missing
mimeType
method
or
template
for
EngineURL
!
"
)
;
var
method
=
requestMethod
.
toUpperCase
(
)
;
var
type
=
mimeType
.
toLowerCase
(
)
;
if
(
method
!
=
"
GET
"
&
&
method
!
=
"
POST
"
)
FAIL
(
"
method
passed
to
EngineURL
must
be
\
"
GET
\
"
or
\
"
POST
\
"
"
)
;
this
.
type
=
type
;
this
.
method
=
method
;
this
.
params
=
[
]
;
this
.
rels
=
[
]
;
this
.
mozparams
=
{
}
;
var
templateURI
=
makeURI
(
template
)
;
if
(
!
templateURI
)
FAIL
(
"
new
EngineURL
:
template
is
not
a
valid
URI
!
"
Cr
.
NS_ERROR_FAILURE
)
;
switch
(
templateURI
.
scheme
)
{
case
"
http
"
:
case
"
https
"
:
this
.
template
=
template
;
break
;
default
:
FAIL
(
"
new
EngineURL
:
template
uses
invalid
scheme
!
"
Cr
.
NS_ERROR_FAILURE
)
;
}
this
.
templateHost
=
templateURI
.
host
;
this
.
resultDomain
=
resultDomain
|
|
this
.
templateHost
;
}
EngineURL
.
prototype
=
{
addParam
(
name
value
purpose
)
{
this
.
params
.
push
(
new
QueryParameter
(
name
value
purpose
)
)
;
}
_addMozParam
(
obj
)
{
obj
.
mozparam
=
true
;
this
.
mozparams
[
obj
.
name
]
=
obj
;
}
getSubmission
(
searchTerms
engine
purpose
)
{
var
url
=
ParamSubstitution
(
this
.
template
searchTerms
engine
)
;
var
requestPurpose
=
purpose
|
|
"
searchbar
"
;
if
(
!
this
.
params
.
some
(
p
=
>
p
.
purpose
!
=
=
undefined
&
&
p
.
purpose
=
=
requestPurpose
)
)
requestPurpose
=
"
searchbar
"
;
let
dataArray
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
params
.
length
;
+
+
i
)
{
var
param
=
this
.
params
[
i
]
;
if
(
param
.
purpose
!
=
=
undefined
&
&
param
.
purpose
!
=
requestPurpose
)
continue
;
var
value
=
ParamSubstitution
(
param
.
value
searchTerms
engine
)
;
dataArray
.
push
(
param
.
name
+
"
=
"
+
value
)
;
}
let
dataString
=
dataArray
.
join
(
"
&
"
)
;
var
postData
=
null
;
if
(
this
.
method
=
=
"
GET
"
)
{
if
(
dataString
)
{
if
(
url
.
includes
(
"
?
"
)
)
{
url
=
{
url
}
&
{
dataString
}
;
}
else
{
url
=
{
url
}
?
{
dataString
}
;
}
}
}
else
if
(
this
.
method
=
=
"
POST
"
)
{
var
stringStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stringStream
.
data
=
dataString
;
postData
=
Cc
[
"
mozilla
.
org
/
network
/
mime
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIMIMEInputStream
)
;
postData
.
addHeader
(
"
Content
-
Type
"
"
application
/
x
-
www
-
form
-
urlencoded
"
)
;
postData
.
setData
(
stringStream
)
;
}
return
new
Submission
(
Services
.
io
.
newURI
(
url
)
postData
)
;
}
_getTermsParameterName
(
)
{
let
queryParam
=
this
.
params
.
find
(
p
=
>
p
.
value
=
=
"
{
"
+
USER_DEFINED
+
"
}
"
)
;
return
queryParam
?
queryParam
.
name
:
"
"
;
}
_hasRelation
(
rel
)
{
return
this
.
rels
.
some
(
e
=
>
e
=
=
rel
.
toLowerCase
(
)
)
;
}
_initWithJSON
(
json
)
{
if
(
!
json
.
params
)
return
;
this
.
rels
=
json
.
rels
;
for
(
let
i
=
0
;
i
<
json
.
params
.
length
;
+
+
i
)
{
let
param
=
json
.
params
[
i
]
;
if
(
param
.
mozparam
)
{
if
(
param
.
condition
=
=
"
pref
"
)
{
let
value
=
getMozParamPref
(
param
.
pref
)
;
if
(
value
)
{
this
.
addParam
(
param
.
name
value
)
;
}
}
this
.
_addMozParam
(
param
)
;
}
else
{
this
.
addParam
(
param
.
name
param
.
value
param
.
purpose
|
|
undefined
)
;
}
}
}
toJSON
(
)
{
var
json
=
{
template
:
this
.
template
rels
:
this
.
rels
resultDomain
:
this
.
resultDomain
}
;
if
(
this
.
type
!
=
URLTYPE_SEARCH_HTML
)
json
.
type
=
this
.
type
;
if
(
this
.
method
!
=
"
GET
"
)
json
.
method
=
this
.
method
;
function
collapseMozParams
(
param
)
{
return
this
.
mozparams
[
param
.
name
]
|
|
param
;
}
json
.
params
=
this
.
params
.
map
(
collapseMozParams
this
)
;
return
json
;
}
}
;
function
Engine
(
location
isReadOnly
)
{
this
.
_readOnly
=
isReadOnly
;
this
.
_urls
=
[
]
;
this
.
_metaData
=
{
}
;
let
file
uri
;
if
(
typeof
location
=
=
"
string
"
)
{
this
.
_shortName
=
location
;
}
else
if
(
location
instanceof
Ci
.
nsIFile
)
{
file
=
location
;
}
else
if
(
location
instanceof
Ci
.
nsIURI
)
{
switch
(
location
.
scheme
)
{
case
"
https
"
:
case
"
http
"
:
case
"
ftp
"
:
case
"
data
"
:
case
"
file
"
:
case
"
resource
"
:
case
"
chrome
"
:
uri
=
location
;
break
;
default
:
ERROR
(
"
Invalid
URI
passed
to
the
nsISearchEngine
constructor
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
}
else
{
ERROR
(
"
Engine
location
is
neither
a
File
nor
a
URI
object
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
this
.
_shortName
)
{
let
shortName
;
if
(
file
)
{
shortName
=
file
.
leafName
;
}
else
if
(
uri
&
&
uri
instanceof
Ci
.
nsIURL
)
{
if
(
isReadOnly
|
|
(
gEnvironment
.
get
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
&
&
uri
.
scheme
=
=
"
resource
"
)
)
{
shortName
=
uri
.
fileName
;
}
}
if
(
shortName
&
&
shortName
.
endsWith
(
"
.
xml
"
)
)
{
this
.
_shortName
=
shortName
.
slice
(
0
-
4
)
;
}
this
.
_loadPath
=
this
.
getAnonymizedLoadPath
(
file
uri
)
;
if
(
!
shortName
&
&
!
isReadOnly
)
{
return
;
}
if
(
this
.
_isDefault
|
|
(
uri
&
&
uri
.
spec
.
startsWith
(
APP_SEARCH_PREFIX
)
)
)
{
this
.
_id
=
"
[
app
]
/
"
+
this
.
_shortName
+
"
.
xml
"
;
}
else
if
(
!
isReadOnly
)
{
this
.
_id
=
"
[
profile
]
/
"
+
this
.
_shortName
+
"
.
xml
"
;
}
else
{
LOG
(
"
Setting
_id
to
full
path
for
engine
from
"
+
this
.
_loadPath
)
;
this
.
_id
=
file
?
file
.
path
:
uri
.
spec
;
}
}
}
Engine
.
prototype
=
{
_metaData
:
null
_data
:
null
_readOnly
:
true
_loadPath
:
null
_description
:
"
"
_engineToUpdate
:
null
_hasPreferredIcon
:
null
_name
:
null
_queryCharset
:
null
__searchForm
:
null
get
_searchForm
(
)
{
return
this
.
__searchForm
;
}
set
_searchForm
(
value
)
{
if
(
/
^
https
?
:
/
i
.
test
(
value
)
)
this
.
__searchForm
=
value
;
else
LOG
(
"
_searchForm
:
Invalid
URL
dropped
for
"
+
this
.
_name
|
|
"
the
current
engine
"
)
;
}
_confirm
:
false
_useNow
:
false
_installCallback
:
null
_updateInterval
:
null
_updateURL
:
null
_iconUpdateURL
:
null
_extensionID
:
null
_isBuiltin
:
false
async
_initFromFile
(
file
)
{
if
(
!
file
|
|
!
(
await
OS
.
File
.
exists
(
file
.
path
)
)
)
FAIL
(
"
File
must
exist
before
calling
initFromFile
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
let
fileURI
=
Services
.
io
.
newFileURI
(
file
)
;
await
this
.
_retrieveSearchXMLData
(
fileURI
.
spec
)
;
this
.
_initFromData
(
)
;
}
_initFromURIAndLoad
(
uri
)
{
ENSURE_WARN
(
uri
instanceof
Ci
.
nsIURI
"
Must
have
URI
when
calling
_initFromURIAndLoad
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
LOG
(
"
_initFromURIAndLoad
:
Downloading
engine
from
:
\
"
"
+
uri
.
spec
+
"
\
"
.
"
)
;
var
chan
=
makeChannel
(
uri
)
;
if
(
this
.
_engineToUpdate
&
&
(
chan
instanceof
Ci
.
nsIHttpChannel
)
)
{
var
lastModified
=
this
.
_engineToUpdate
.
getAttr
(
"
updatelastmodified
"
)
;
if
(
lastModified
)
chan
.
setRequestHeader
(
"
If
-
Modified
-
Since
"
lastModified
false
)
;
}
this
.
_uri
=
uri
;
var
listener
=
new
loadListener
(
chan
this
this
.
_onLoad
)
;
chan
.
notificationCallbacks
=
listener
;
chan
.
asyncOpen
(
listener
)
;
}
async
_initFromURI
(
uri
)
{
LOG
(
"
_initFromURI
:
Loading
engine
from
:
\
"
"
+
uri
.
spec
+
"
\
"
.
"
)
;
await
this
.
_retrieveSearchXMLData
(
uri
.
spec
)
;
this
.
_initFromData
(
)
;
}
_retrieveSearchXMLData
(
url
)
{
return
new
Promise
(
resolve
=
>
{
let
request
=
new
XMLHttpRequest
(
)
;
request
.
overrideMimeType
(
"
text
/
xml
"
)
;
request
.
onload
=
event
=
>
{
let
responseXML
=
event
.
target
.
responseXML
;
this
.
_data
=
responseXML
.
documentElement
;
resolve
(
)
;
}
;
request
.
onerror
=
function
(
event
)
{
resolve
(
)
;
}
;
request
.
open
(
"
GET
"
url
true
)
;
request
.
send
(
)
;
}
)
;
}
_getURLOfType
(
type
rel
)
{
for
(
let
url
of
this
.
_urls
)
{
if
(
url
.
type
=
=
type
&
&
(
!
rel
|
|
url
.
_hasRelation
(
rel
)
)
)
return
url
;
}
return
null
;
}
_confirmAddEngine
(
)
{
var
stringBundle
=
Services
.
strings
.
createBundle
(
SEARCH_BUNDLE
)
;
var
titleMessage
=
stringBundle
.
GetStringFromName
(
"
addEngineConfirmTitle
"
)
;
var
dialogMessage
=
stringBundle
.
formatStringFromName
(
"
addEngineConfirmation
"
[
this
.
_name
this
.
_uri
.
host
]
2
)
;
var
checkboxMessage
=
null
;
if
(
!
Services
.
prefs
.
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
noCurrentEngine
"
false
)
)
checkboxMessage
=
stringBundle
.
GetStringFromName
(
"
addEngineAsCurrentText
"
)
;
var
addButtonLabel
=
stringBundle
.
GetStringFromName
(
"
addEngineAddButtonLabel
"
)
;
var
ps
=
Services
.
prompt
;
var
buttonFlags
=
(
ps
.
BUTTON_TITLE_IS_STRING
*
ps
.
BUTTON_POS_0
)
+
(
ps
.
BUTTON_TITLE_CANCEL
*
ps
.
BUTTON_POS_1
)
+
ps
.
BUTTON_POS_0_DEFAULT
;
var
checked
=
{
value
:
false
}
;
var
confirm
=
!
ps
.
confirmEx
(
null
titleMessage
dialogMessage
buttonFlags
addButtonLabel
null
null
checkboxMessage
checked
)
;
return
{
confirmed
:
confirm
useNow
:
checked
.
value
}
;
}
_onLoad
(
bytes
engine
)
{
function
onError
(
errorCode
=
Ci
.
nsISearchService
.
ERROR_UNKNOWN_FAILURE
)
{
if
(
engine
.
_installCallback
)
{
engine
.
_installCallback
(
errorCode
)
;
}
}
function
promptError
(
strings
=
{
}
error
=
undefined
)
{
onError
(
error
)
;
if
(
engine
.
_engineToUpdate
)
{
LOG
(
"
updating
"
+
engine
.
_engineToUpdate
.
name
+
"
failed
"
)
;
return
;
}
var
brandBundle
=
Services
.
strings
.
createBundle
(
BRAND_BUNDLE
)
;
var
brandName
=
brandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
var
searchBundle
=
Services
.
strings
.
createBundle
(
SEARCH_BUNDLE
)
;
var
msgStringName
=
strings
.
error
|
|
"
error_loading_engine_msg2
"
;
var
titleStringName
=
strings
.
title
|
|
"
error_loading_engine_title
"
;
var
title
=
searchBundle
.
GetStringFromName
(
titleStringName
)
;
var
text
=
searchBundle
.
formatStringFromName
(
msgStringName
[
brandName
engine
.
_location
]
2
)
;
Services
.
ww
.
getNewPrompter
(
null
)
.
alert
(
title
text
)
;
}
if
(
!
bytes
)
{
promptError
(
)
;
return
;
}
var
parser
=
new
DOMParser
(
)
;
var
doc
=
parser
.
parseFromBuffer
(
bytes
"
text
/
xml
"
)
;
engine
.
_data
=
doc
.
documentElement
;
try
{
engine
.
_initFromData
(
)
;
}
catch
(
ex
)
{
LOG
(
"
_onLoad
:
Failed
to
init
engine
!
\
n
"
+
ex
)
;
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_FILE_CORRUPTED
)
{
promptError
(
{
error
:
"
error_invalid_engine_msg2
"
title
:
"
error_invalid_format_title
"
}
)
;
}
else
{
promptError
(
)
;
}
return
;
}
if
(
engine
.
_engineToUpdate
)
{
let
engineToUpdate
=
engine
.
_engineToUpdate
.
wrappedJSObject
;
engine
.
_shortName
=
engineToUpdate
.
_shortName
;
Object
.
keys
(
engineToUpdate
.
_metaData
)
.
forEach
(
key
=
>
{
engine
.
setAttr
(
key
engineToUpdate
.
getAttr
(
key
)
)
;
}
)
;
engine
.
_loadPath
=
engineToUpdate
.
_loadPath
;
engine
.
setAttr
(
"
updatelastmodified
"
(
new
Date
(
)
)
.
toUTCString
(
)
)
;
if
(
!
engine
.
_iconURI
&
&
engineToUpdate
.
_iconURI
)
engine
.
_iconURI
=
engineToUpdate
.
_iconURI
;
}
else
{
if
(
Services
.
search
.
getEngineByName
(
engine
.
name
)
)
{
if
(
engine
.
_confirm
)
{
promptError
(
{
error
:
"
error_duplicate_engine_msg
"
title
:
"
error_invalid_engine_title
"
}
Ci
.
nsISearchService
.
ERROR_DUPLICATE_ENGINE
)
;
}
else
{
onError
(
Ci
.
nsISearchService
.
ERROR_DUPLICATE_ENGINE
)
;
}
LOG
(
"
_onLoad
:
duplicate
engine
found
bailing
"
)
;
return
;
}
if
(
engine
.
_confirm
)
{
var
confirmation
=
engine
.
_confirmAddEngine
(
)
;
LOG
(
"
_onLoad
:
confirm
is
"
+
confirmation
.
confirmed
+
"
;
useNow
is
"
+
confirmation
.
useNow
)
;
if
(
!
confirmation
.
confirmed
)
{
onError
(
)
;
return
;
}
engine
.
_useNow
=
confirmation
.
useNow
;
}
engine
.
_shortName
=
sanitizeName
(
engine
.
name
)
;
engine
.
_loadPath
=
engine
.
getAnonymizedLoadPath
(
null
engine
.
_uri
)
;
if
(
engine
.
_extensionID
)
{
engine
.
_loadPath
+
=
"
:
"
+
engine
.
_extensionID
;
}
engine
.
setAttr
(
"
loadPathHash
"
getVerificationHash
(
engine
.
_loadPath
)
)
;
}
notifyAction
(
engine
SEARCH_ENGINE_LOADED
)
;
if
(
engine
.
_installCallback
)
{
engine
.
_installCallback
(
)
;
}
}
_getIconKey
(
width
height
)
{
let
keyObj
=
{
width
height
}
;
return
JSON
.
stringify
(
keyObj
)
;
}
_addIconToMap
(
width
height
uriSpec
)
{
if
(
width
=
=
16
&
&
height
=
=
16
)
{
return
;
}
this
.
_iconMapObj
=
this
.
_iconMapObj
|
|
{
}
;
let
key
=
this
.
_getIconKey
(
width
height
)
;
this
.
_iconMapObj
[
key
]
=
uriSpec
;
}
_setIcon
(
iconURL
isPreferred
width
height
)
{
var
uri
=
makeURI
(
iconURL
)
;
if
(
!
uri
)
return
;
LOG
(
"
_setIcon
:
Setting
icon
url
\
"
"
+
limitURILength
(
uri
.
spec
)
+
"
\
"
for
engine
\
"
"
+
this
.
name
+
"
\
"
.
"
)
;
switch
(
uri
.
scheme
)
{
case
"
resource
"
:
case
"
chrome
"
:
if
(
!
this
.
_isDefault
)
{
return
;
}
case
"
moz
-
extension
"
:
case
"
data
"
:
if
(
!
this
.
_hasPreferredIcon
|
|
isPreferred
)
{
this
.
_iconURI
=
uri
;
notifyAction
(
this
SEARCH_ENGINE_CHANGED
)
;
this
.
_hasPreferredIcon
=
isPreferred
;
}
if
(
width
&
&
height
)
{
this
.
_addIconToMap
(
width
height
iconURL
)
;
}
break
;
case
"
http
"
:
case
"
https
"
:
case
"
ftp
"
:
LOG
(
"
_setIcon
:
Downloading
icon
:
\
"
"
+
uri
.
spec
+
"
\
"
for
engine
:
\
"
"
+
this
.
name
+
"
\
"
"
)
;
var
chan
=
makeChannel
(
uri
)
;
let
iconLoadCallback
=
function
(
byteArray
engine
)
{
if
(
engine
.
_hasPreferredIcon
&
&
!
isPreferred
)
return
;
if
(
!
byteArray
)
{
LOG
(
"
iconLoadCallback
:
load
failed
"
)
;
return
;
}
let
contentType
=
chan
.
contentType
;
if
(
byteArray
.
length
>
MAX_ICON_SIZE
)
{
try
{
LOG
(
"
iconLoadCallback
:
rescaling
icon
"
)
;
[
byteArray
contentType
]
=
rescaleIcon
(
byteArray
contentType
)
;
}
catch
(
ex
)
{
LOG
(
"
iconLoadCallback
:
got
exception
:
"
+
ex
)
;
Cu
.
reportError
(
"
Unable
to
set
an
icon
for
the
search
engine
because
:
"
+
ex
)
;
return
;
}
}
if
(
!
contentType
.
startsWith
(
"
image
/
"
)
)
contentType
=
"
image
/
x
-
icon
"
;
let
dataURL
=
"
data
:
"
+
contentType
+
"
;
base64
"
+
btoa
(
String
.
fromCharCode
.
apply
(
null
byteArray
)
)
;
engine
.
_iconURI
=
makeURI
(
dataURL
)
;
if
(
width
&
&
height
)
{
engine
.
_addIconToMap
(
width
height
dataURL
)
;
}
notifyAction
(
engine
SEARCH_ENGINE_CHANGED
)
;
engine
.
_hasPreferredIcon
=
isPreferred
;
}
;
var
engineToSet
=
this
.
_engineToUpdate
|
|
this
;
var
listener
=
new
loadListener
(
chan
engineToSet
iconLoadCallback
)
;
chan
.
notificationCallbacks
=
listener
;
chan
.
asyncOpen
(
listener
)
;
break
;
}
}
_initFromData
(
)
{
ENSURE_WARN
(
this
.
_data
"
Can
'
t
init
an
engine
with
no
data
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
let
element
=
this
.
_data
;
if
(
(
element
.
localName
=
=
MOZSEARCH_LOCALNAME
&
&
element
.
namespaceURI
=
=
MOZSEARCH_NS_10
)
|
|
(
element
.
localName
=
=
OPENSEARCH_LOCALNAME
&
&
OPENSEARCH_NAMESPACES
.
includes
(
element
.
namespaceURI
)
)
)
{
LOG
(
"
_init
:
Initing
search
plugin
from
"
+
this
.
_location
)
;
this
.
_parse
(
)
;
}
else
{
Cu
.
reportError
(
"
Invalid
search
plugin
due
to
namespace
not
matching
.
"
)
;
FAIL
(
this
.
_location
+
"
is
not
a
valid
search
plugin
.
"
Cr
.
NS_ERROR_FILE_CORRUPTED
)
;
}
this
.
_data
=
null
;
}
_initEngineURLFromMetaData
(
type
params
)
{
let
url
=
new
EngineURL
(
type
params
.
method
|
|
"
GET
"
params
.
template
)
;
if
(
params
.
postParams
)
{
let
queries
=
new
URLSearchParams
(
params
.
postParams
)
;
for
(
let
[
name
value
]
of
queries
)
{
url
.
addParam
(
name
value
)
;
}
}
if
(
params
.
getParams
)
{
let
queries
=
new
URLSearchParams
(
params
.
getParams
)
;
for
(
let
[
name
value
]
of
queries
)
{
url
.
addParam
(
name
value
)
;
}
}
if
(
params
.
mozParams
)
{
for
(
let
p
of
params
.
mozParams
)
{
if
(
(
p
.
condition
|
|
p
.
purpose
)
&
&
!
this
.
_isDefault
)
{
continue
;
}
if
(
p
.
condition
=
=
"
pref
"
)
{
let
value
=
getMozParamPref
(
p
.
pref
)
;
if
(
value
)
{
url
.
addParam
(
p
.
name
value
)
;
}
url
.
_addMozParam
(
p
)
;
}
else
{
url
.
addParam
(
p
.
name
p
.
value
p
.
purpose
|
|
undefined
)
;
}
}
}
this
.
_urls
.
push
(
url
)
;
}
_initFromMetadata
(
engineName
params
)
{
this
.
_extensionID
=
params
.
extensionID
;
this
.
_isBuiltin
=
!
!
params
.
isBuiltin
;
this
.
_initEngineURLFromMetaData
(
URLTYPE_SEARCH_HTML
{
method
:
(
params
.
searchPostParams
&
&
"
POST
"
)
|
|
params
.
method
|
|
"
GET
"
template
:
params
.
template
getParams
:
params
.
searchGetParams
postParams
:
params
.
searchPostParams
mozParams
:
params
.
mozParams
}
)
;
if
(
params
.
suggestURL
)
{
this
.
_initEngineURLFromMetaData
(
URLTYPE_SUGGEST_JSON
{
method
:
(
params
.
suggestPostParams
&
&
"
POST
"
)
|
|
params
.
method
|
|
"
GET
"
template
:
params
.
suggestURL
getParams
:
params
.
suggestGetParams
postParams
:
params
.
suggestPostParams
}
)
;
}
if
(
params
.
queryCharset
)
{
this
.
_queryCharset
=
params
.
queryCharset
;
}
if
(
params
.
postData
)
{
let
queries
=
new
URLSearchParams
(
params
.
postData
)
;
for
(
let
[
name
value
]
of
queries
)
{
this
.
addParam
(
name
value
)
;
}
}
this
.
_name
=
engineName
;
if
(
params
.
shortName
)
{
this
.
_shortName
=
params
.
shortName
;
}
this
.
alias
=
params
.
alias
;
this
.
_description
=
params
.
description
;
this
.
__searchForm
=
params
.
searchForm
;
if
(
params
.
iconURL
)
{
this
.
_setIcon
(
params
.
iconURL
true
)
;
}
if
(
params
.
icons
)
{
for
(
let
icon
of
params
.
icons
)
{
this
.
_addIconToMap
(
icon
.
size
icon
.
size
icon
.
url
)
;
}
}
}
_parseURL
(
element
)
{
var
type
=
element
.
getAttribute
(
"
type
"
)
;
var
method
=
element
.
getAttribute
(
"
method
"
)
|
|
"
GET
"
;
var
template
=
element
.
getAttribute
(
"
template
"
)
;
var
resultDomain
=
element
.
getAttribute
(
"
resultdomain
"
)
;
let
rels
=
[
]
;
if
(
element
.
hasAttribute
(
"
rel
"
)
)
{
rels
=
element
.
getAttribute
(
"
rel
"
)
.
toLowerCase
(
)
.
split
(
/
\
s
+
/
)
;
}
if
(
type
=
=
"
application
/
json
"
&
&
rels
.
includes
(
"
suggestions
"
)
)
{
type
=
URLTYPE_SUGGEST_JSON
;
}
try
{
var
url
=
new
EngineURL
(
type
method
template
resultDomain
)
;
}
catch
(
ex
)
{
FAIL
(
"
_parseURL
:
failed
to
add
"
+
template
+
"
as
a
URL
"
Cr
.
NS_ERROR_FAILURE
)
;
}
if
(
rels
.
length
)
{
url
.
rels
=
rels
;
}
for
(
var
i
=
0
;
i
<
element
.
children
.
length
;
+
+
i
)
{
var
param
=
element
.
children
[
i
]
;
if
(
param
.
localName
=
=
"
Param
"
)
{
try
{
url
.
addParam
(
param
.
getAttribute
(
"
name
"
)
param
.
getAttribute
(
"
value
"
)
)
;
}
catch
(
ex
)
{
LOG
(
"
_parseURL
:
Url
element
has
an
invalid
param
"
)
;
}
}
else
if
(
param
.
localName
=
=
"
MozParam
"
&
&
this
.
_isDefault
)
{
var
value
;
let
condition
=
param
.
getAttribute
(
"
condition
"
)
;
if
(
!
condition
)
{
let
engineLoc
=
this
.
_location
;
let
paramName
=
param
.
getAttribute
(
"
name
"
)
;
LOG
(
"
_parseURL
:
MozParam
(
"
+
paramName
+
"
)
without
a
condition
attribute
found
parsing
engine
:
"
+
engineLoc
)
;
continue
;
}
switch
(
condition
)
{
case
"
purpose
"
:
url
.
addParam
(
param
.
getAttribute
(
"
name
"
)
param
.
getAttribute
(
"
value
"
)
param
.
getAttribute
(
"
purpose
"
)
)
;
break
;
case
"
pref
"
:
value
=
getMozParamPref
(
param
.
getAttribute
(
"
pref
"
)
value
)
;
if
(
value
)
{
url
.
addParam
(
param
.
getAttribute
(
"
name
"
)
value
)
;
}
url
.
_addMozParam
(
{
"
pref
"
:
param
.
getAttribute
(
"
pref
"
)
"
name
"
:
param
.
getAttribute
(
"
name
"
)
"
condition
"
:
"
pref
"
}
)
;
break
;
default
:
let
engineLoc
=
this
.
_location
;
let
paramName
=
param
.
getAttribute
(
"
name
"
)
;
LOG
(
"
_parseURL
:
MozParam
(
"
+
paramName
+
"
)
has
an
unknown
condition
:
"
+
condition
+
"
.
Found
parsing
engine
:
"
+
engineLoc
)
;
break
;
}
}
}
this
.
_urls
.
push
(
url
)
;
}
_parseImage
(
element
)
{
LOG
(
"
_parseImage
:
Image
textContent
:
\
"
"
+
limitURILength
(
element
.
textContent
)
+
"
\
"
"
)
;
let
width
=
parseInt
(
element
.
getAttribute
(
"
width
"
)
10
)
;
let
height
=
parseInt
(
element
.
getAttribute
(
"
height
"
)
10
)
;
let
isPrefered
=
width
=
=
16
&
&
height
=
=
16
;
if
(
isNaN
(
width
)
|
|
isNaN
(
height
)
|
|
width
<
=
0
|
|
height
<
=
0
)
{
LOG
(
"
OpenSearch
image
element
must
have
positive
width
and
height
.
"
)
;
return
;
}
this
.
_setIcon
(
element
.
textContent
isPrefered
width
height
)
;
}
_parse
(
)
{
var
doc
=
this
.
_data
;
this
.
_queryCharset
=
OS_PARAM_INPUT_ENCODING_DEF
;
for
(
var
i
=
0
;
i
<
doc
.
children
.
length
;
+
+
i
)
{
var
child
=
doc
.
children
[
i
]
;
switch
(
child
.
localName
)
{
case
"
ShortName
"
:
this
.
_name
=
child
.
textContent
;
break
;
case
"
Description
"
:
this
.
_description
=
child
.
textContent
;
break
;
case
"
Url
"
:
try
{
this
.
_parseURL
(
child
)
;
}
catch
(
ex
)
{
LOG
(
"
_parse
:
failed
to
parse
URL
child
:
"
+
ex
)
;
}
break
;
case
"
Image
"
:
this
.
_parseImage
(
child
)
;
break
;
case
"
InputEncoding
"
:
this
.
_queryCharset
=
child
.
textContent
.
toUpperCase
(
)
;
break
;
case
"
SearchForm
"
:
this
.
_searchForm
=
child
.
textContent
;
break
;
case
"
UpdateUrl
"
:
this
.
_updateURL
=
child
.
textContent
;
break
;
case
"
UpdateInterval
"
:
this
.
_updateInterval
=
parseInt
(
child
.
textContent
)
;
break
;
case
"
IconUpdateUrl
"
:
this
.
_iconUpdateURL
=
child
.
textContent
;
break
;
case
"
ExtensionID
"
:
this
.
_extensionID
=
child
.
textContent
;
break
;
}
}
if
(
!
this
.
name
|
|
(
this
.
_urls
.
length
=
=
0
)
)
FAIL
(
"
_parse
:
No
name
or
missing
URL
!
"
Cr
.
NS_ERROR_FAILURE
)
;
if
(
!
this
.
supportsResponseType
(
URLTYPE_SEARCH_HTML
)
)
FAIL
(
"
_parse
:
No
text
/
html
result
type
!
"
Cr
.
NS_ERROR_FAILURE
)
;
}
_initWithJSON
(
json
)
{
this
.
_name
=
json
.
_name
;
this
.
_shortName
=
json
.
_shortName
;
this
.
_loadPath
=
json
.
_loadPath
;
this
.
_description
=
json
.
description
;
this
.
_hasPreferredIcon
=
json
.
_hasPreferredIcon
=
=
undefined
;
this
.
_queryCharset
=
json
.
queryCharset
|
|
DEFAULT_QUERY_CHARSET
;
this
.
__searchForm
=
json
.
__searchForm
;
this
.
_updateInterval
=
json
.
_updateInterval
|
|
null
;
this
.
_updateURL
=
json
.
_updateURL
|
|
null
;
this
.
_iconUpdateURL
=
json
.
_iconUpdateURL
|
|
null
;
this
.
_readOnly
=
json
.
_readOnly
=
=
undefined
;
this
.
_iconURI
=
makeURI
(
json
.
_iconURL
)
;
this
.
_iconMapObj
=
json
.
_iconMapObj
;
this
.
_metaData
=
json
.
_metaData
|
|
{
}
;
this
.
_isBuiltin
=
json
.
_isBuiltin
;
if
(
json
.
filePath
)
{
this
.
_filePath
=
json
.
filePath
;
}
if
(
json
.
extensionID
)
{
this
.
_extensionID
=
json
.
extensionID
;
}
for
(
let
i
=
0
;
i
<
json
.
_urls
.
length
;
+
+
i
)
{
let
url
=
json
.
_urls
[
i
]
;
let
engineURL
=
new
EngineURL
(
url
.
type
|
|
URLTYPE_SEARCH_HTML
url
.
method
|
|
"
GET
"
url
.
template
url
.
resultDomain
|
|
undefined
)
;
engineURL
.
_initWithJSON
(
url
)
;
this
.
_urls
.
push
(
engineURL
)
;
}
}
toJSON
(
)
{
var
json
=
{
_name
:
this
.
_name
_shortName
:
this
.
_shortName
_loadPath
:
this
.
_loadPath
description
:
this
.
description
__searchForm
:
this
.
__searchForm
_iconURL
:
this
.
_iconURL
_iconMapObj
:
this
.
_iconMapObj
_metaData
:
this
.
_metaData
_urls
:
this
.
_urls
_isBuiltin
:
this
.
_isBuiltin
}
;
if
(
this
.
_updateInterval
)
json
.
_updateInterval
=
this
.
_updateInterval
;
if
(
this
.
_updateURL
)
json
.
_updateURL
=
this
.
_updateURL
;
if
(
this
.
_iconUpdateURL
)
json
.
_iconUpdateURL
=
this
.
_iconUpdateURL
;
if
(
!
this
.
_hasPreferredIcon
)
json
.
_hasPreferredIcon
=
this
.
_hasPreferredIcon
;
if
(
this
.
queryCharset
!
=
DEFAULT_QUERY_CHARSET
)
json
.
queryCharset
=
this
.
queryCharset
;
if
(
!
this
.
_readOnly
)
json
.
_readOnly
=
this
.
_readOnly
;
if
(
this
.
_filePath
)
{
json
.
filePath
=
this
.
_filePath
;
}
if
(
this
.
_extensionID
)
{
json
.
extensionID
=
this
.
_extensionID
;
}
return
json
;
}
setAttr
(
name
val
)
{
this
.
_metaData
[
name
]
=
val
;
}
getAttr
(
name
)
{
return
this
.
_metaData
[
name
]
|
|
undefined
;
}
get
alias
(
)
{
return
this
.
getAttr
(
"
alias
"
)
;
}
set
alias
(
val
)
{
var
value
=
val
?
val
.
trim
(
)
:
null
;
this
.
setAttr
(
"
alias
"
value
)
;
notifyAction
(
this
SEARCH_ENGINE_CHANGED
)
;
}
get
identifier
(
)
{
return
this
.
_isDefault
?
this
.
_shortName
:
null
;
}
get
description
(
)
{
return
this
.
_description
;
}
get
hidden
(
)
{
return
this
.
getAttr
(
"
hidden
"
)
|
|
false
;
}
set
hidden
(
val
)
{
var
value
=
!
!
val
;
if
(
value
!
=
this
.
hidden
)
{
this
.
setAttr
(
"
hidden
"
value
)
;
notifyAction
(
this
SEARCH_ENGINE_CHANGED
)
;
}
}
get
iconURI
(
)
{
if
(
this
.
_iconURI
)
return
this
.
_iconURI
;
return
null
;
}
get
_iconURL
(
)
{
if
(
!
this
.
_iconURI
)
return
"
"
;
return
this
.
_iconURI
.
spec
;
}
get
_location
(
)
{
if
(
this
.
_uri
)
return
this
.
_uri
.
spec
;
return
this
.
_loadPath
;
}
getAnonymizedLoadPath
(
file
uri
)
{
const
NS_XPCOM_CURRENT_PROCESS_DIR
=
"
XCurProcD
"
;
const
NS_APP_USER_PROFILE_50_DIR
=
"
ProfD
"
;
const
XRE_APP_DISTRIBUTION_DIR
=
"
XREAppDist
"
;
const
knownDirs
=
{
app
:
NS_XPCOM_CURRENT_PROCESS_DIR
profile
:
NS_APP_USER_PROFILE_50_DIR
distribution
:
XRE_APP_DISTRIBUTION_DIR
}
;
let
leafName
=
this
.
_shortName
;
if
(
!
leafName
)
return
"
null
"
;
leafName
+
=
"
.
xml
"
;
let
prefix
=
"
"
suffix
=
"
"
;
if
(
!
file
)
{
if
(
uri
.
schemeIs
(
"
resource
"
)
)
{
uri
=
makeURI
(
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsISubstitutingProtocolHandler
)
.
resolveURI
(
uri
)
)
;
}
let
scheme
=
uri
.
scheme
;
let
packageName
=
"
"
;
if
(
scheme
=
=
"
chrome
"
)
{
packageName
=
uri
.
hostPort
;
uri
=
gChromeReg
.
convertChromeURL
(
uri
)
;
}
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
let
appPath
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
.
getSubstitution
(
"
android
"
)
;
if
(
appPath
)
{
appPath
=
appPath
.
spec
;
let
spec
=
uri
.
spec
;
if
(
spec
.
includes
(
appPath
)
)
{
let
appURI
=
Services
.
io
.
newFileURI
(
getDir
(
knownDirs
.
app
)
)
;
uri
=
Services
.
io
.
newURI
(
spec
.
replace
(
appPath
appURI
.
spec
)
)
;
}
}
}
if
(
uri
instanceof
Ci
.
nsINestedURI
)
{
prefix
=
"
jar
:
"
;
suffix
=
"
!
"
+
packageName
+
"
/
"
+
leafName
;
uri
=
uri
.
innermostURI
;
}
if
(
uri
instanceof
Ci
.
nsIFileURL
)
{
file
=
uri
.
file
;
}
else
{
let
path
=
"
[
"
+
scheme
+
"
]
"
;
if
(
/
^
(
?
:
https
?
|
ftp
)
/
.
test
(
scheme
)
)
{
path
+
=
uri
.
host
;
}
return
path
+
"
/
"
+
leafName
;
}
}
let
id
;
let
enginePath
=
file
.
path
;
for
(
let
key
in
knownDirs
)
{
let
path
;
try
{
path
=
getDir
(
knownDirs
[
key
]
)
.
path
;
}
catch
(
e
)
{
continue
;
}
if
(
enginePath
.
startsWith
(
path
)
)
{
id
=
"
[
"
+
key
+
"
]
"
+
enginePath
.
slice
(
path
.
length
)
.
replace
(
/
\
\
/
g
"
/
"
)
;
break
;
}
}
if
(
!
id
)
id
=
"
[
other
]
/
"
+
file
.
leafName
;
return
prefix
+
id
+
suffix
;
}
get
_isDistribution
(
)
{
return
!
!
(
this
.
_extensionID
&
&
Services
.
prefs
.
getCharPref
(
extensions
.
installedDistroAddon
.
{
this
.
_extensionID
}
"
"
)
)
;
}
get
_isDefault
(
)
{
if
(
this
.
_extensionID
)
{
return
this
.
_isBuiltin
|
|
this
.
_isDistribution
;
}
if
(
!
this
.
_shortName
)
return
false
;
if
(
/
^
(
?
:
jar
:
)
?
(
?
:
\
[
app
\
]
|
\
[
distribution
\
]
)
/
.
test
(
this
.
_loadPath
)
)
return
true
;
return
false
;
}
get
_hasUpdates
(
)
{
let
selfURL
=
this
.
_getURLOfType
(
URLTYPE_OPENSEARCH
"
self
"
)
;
return
!
!
(
this
.
_updateURL
|
|
this
.
_iconUpdateURL
|
|
selfURL
)
;
}
get
name
(
)
{
return
this
.
_name
;
}
get
searchForm
(
)
{
return
this
.
_getSearchFormWithPurpose
(
)
;
}
__internalAliases
:
null
get
_internalAliases
(
)
{
if
(
!
this
.
__internalAliases
)
{
this
.
__internalAliases
=
getInternalAliases
(
this
)
;
}
return
this
.
__internalAliases
;
}
_getSearchFormWithPurpose
(
aPurpose
=
"
"
)
{
var
searchFormURL
=
this
.
_getURLOfType
(
URLTYPE_SEARCH_HTML
"
searchform
"
)
;
if
(
searchFormURL
)
{
let
submission
=
searchFormURL
.
getSubmission
(
"
"
this
aPurpose
)
;
if
(
!
submission
.
postData
)
return
submission
.
uri
.
spec
;
}
if
(
!
this
.
_searchForm
)
{
var
htmlUrl
=
this
.
_getURLOfType
(
URLTYPE_SEARCH_HTML
)
;
ENSURE_WARN
(
htmlUrl
"
Engine
has
no
HTML
URL
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
this
.
_searchForm
=
makeURI
(
htmlUrl
.
template
)
.
prePath
;
}
return
ParamSubstitution
(
this
.
_searchForm
"
"
this
)
;
}
get
queryCharset
(
)
{
if
(
this
.
_queryCharset
)
return
this
.
_queryCharset
;
return
this
.
_queryCharset
=
"
windows
-
1252
"
;
}
addParam
(
name
value
responseType
)
{
if
(
!
name
|
|
(
value
=
=
null
)
)
FAIL
(
"
missing
name
or
value
for
nsISearchEngine
:
:
addParam
!
"
)
;
ENSURE_WARN
(
!
this
.
_readOnly
"
called
nsISearchEngine
:
:
addParam
on
a
read
-
only
engine
!
"
Cr
.
NS_ERROR_FAILURE
)
;
if
(
!
responseType
)
responseType
=
URLTYPE_SEARCH_HTML
;
var
url
=
this
.
_getURLOfType
(
responseType
)
;
if
(
!
url
)
FAIL
(
"
Engine
object
has
no
URL
for
response
type
"
+
responseType
Cr
.
NS_ERROR_FAILURE
)
;
url
.
addParam
(
name
value
)
;
}
get
_defaultMobileResponseType
(
)
{
let
type
=
URLTYPE_SEARCH_HTML
;
let
isTablet
=
Services
.
sysinfo
.
get
(
"
tablet
"
)
;
if
(
isTablet
&
&
this
.
supportsResponseType
(
"
application
/
x
-
moz
-
tabletsearch
"
)
)
{
type
=
"
application
/
x
-
moz
-
tabletsearch
"
;
}
else
if
(
!
isTablet
&
&
this
.
supportsResponseType
(
"
application
/
x
-
moz
-
phonesearch
"
)
)
{
type
=
"
application
/
x
-
moz
-
phonesearch
"
;
}
Object
.
defineProperty
(
this
"
_defaultMobileResponseType
"
{
value
:
type
configurable
:
true
}
)
;
return
type
;
}
get
_isWhiteListed
(
)
{
let
url
=
this
.
_getURLOfType
(
URLTYPE_SEARCH_HTML
)
.
template
;
let
hostname
=
makeURI
(
url
)
.
host
;
let
whitelist
=
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
.
getCharPref
(
"
reset
.
whitelist
"
)
.
split
(
"
"
)
;
if
(
whitelist
.
includes
(
hostname
)
)
{
LOG
(
"
The
hostname
"
+
hostname
+
"
is
white
listed
"
+
"
we
won
'
t
show
the
search
reset
prompt
"
)
;
return
true
;
}
return
false
;
}
getSubmission
(
data
responseType
purpose
)
{
if
(
!
responseType
)
{
responseType
=
AppConstants
.
platform
=
=
"
android
"
?
this
.
_defaultMobileResponseType
:
URLTYPE_SEARCH_HTML
;
}
var
url
=
this
.
_getURLOfType
(
responseType
)
;
if
(
!
url
)
return
null
;
if
(
!
data
)
{
return
new
Submission
(
makeURI
(
this
.
_getSearchFormWithPurpose
(
purpose
)
)
)
;
}
LOG
(
"
getSubmission
:
In
data
:
\
"
"
+
data
+
"
\
"
;
Purpose
:
\
"
"
+
purpose
+
"
\
"
"
)
;
var
submissionData
=
"
"
;
try
{
submissionData
=
Services
.
textToSubURI
.
ConvertAndEscape
(
this
.
queryCharset
data
)
;
}
catch
(
ex
)
{
LOG
(
"
getSubmission
:
Falling
back
to
default
queryCharset
!
"
)
;
submissionData
=
Services
.
textToSubURI
.
ConvertAndEscape
(
DEFAULT_QUERY_CHARSET
data
)
;
}
LOG
(
"
getSubmission
:
Out
data
:
\
"
"
+
submissionData
+
"
\
"
"
)
;
return
url
.
getSubmission
(
submissionData
this
purpose
)
;
}
supportsResponseType
(
type
)
{
return
(
this
.
_getURLOfType
(
type
)
!
=
null
)
;
}
getResultDomain
(
responseType
)
{
if
(
!
responseType
)
{
responseType
=
AppConstants
.
platform
=
=
"
android
"
?
this
.
_defaultMobileResponseType
:
URLTYPE_SEARCH_HTML
;
}
LOG
(
"
getResultDomain
:
responseType
:
\
"
"
+
responseType
+
"
\
"
"
)
;
let
url
=
this
.
_getURLOfType
(
responseType
)
;
if
(
url
)
return
url
.
resultDomain
;
return
"
"
;
}
getURLParsingInfo
(
)
{
let
responseType
=
AppConstants
.
platform
=
=
"
android
"
?
this
.
_defaultMobileResponseType
:
URLTYPE_SEARCH_HTML
;
let
url
=
this
.
_getURLOfType
(
responseType
)
;
if
(
!
url
|
|
url
.
method
!
=
"
GET
"
)
{
return
null
;
}
let
termsParameterName
=
url
.
_getTermsParameterName
(
)
;
if
(
!
termsParameterName
)
{
return
null
;
}
let
templateUrl
=
Services
.
io
.
newURI
(
url
.
template
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
return
{
mainDomain
:
templateUrl
.
host
path
:
templateUrl
.
filePath
.
toLowerCase
(
)
termsParameterName
}
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsISearchEngine
]
)
get
wrappedJSObject
(
)
{
return
this
;
}
getIconURLBySize
(
width
height
)
{
if
(
width
=
=
16
&
&
height
=
=
16
)
return
this
.
_iconURL
;
if
(
!
this
.
_iconMapObj
)
return
null
;
let
key
=
this
.
_getIconKey
(
width
height
)
;
if
(
key
in
this
.
_iconMapObj
)
{
return
this
.
_iconMapObj
[
key
]
;
}
return
null
;
}
getIcons
(
)
{
let
result
=
[
]
;
if
(
this
.
_iconURL
)
result
.
push
(
{
width
:
16
height
:
16
url
:
this
.
_iconURL
}
)
;
if
(
!
this
.
_iconMapObj
)
return
result
;
for
(
let
key
of
Object
.
keys
(
this
.
_iconMapObj
)
)
{
let
iconSize
=
JSON
.
parse
(
key
)
;
result
.
push
(
{
width
:
iconSize
.
width
height
:
iconSize
.
height
url
:
this
.
_iconMapObj
[
key
]
}
)
;
}
return
result
;
}
speculativeConnect
(
options
)
{
if
(
!
options
|
|
!
options
.
window
)
{
Cu
.
reportError
(
"
invalid
options
arg
passed
to
nsISearchEngine
.
speculativeConnect
"
)
;
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
let
connector
=
Services
.
io
.
QueryInterface
(
Ci
.
nsISpeculativeConnect
)
;
let
searchURI
=
this
.
getSubmission
(
"
dummy
"
)
.
uri
;
let
callbacks
=
options
.
window
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
;
let
attrs
=
options
.
originAttributes
;
if
(
!
attrs
)
{
attrs
=
options
.
window
.
docShell
.
getOriginAttributes
(
)
;
}
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
searchURI
attrs
)
;
try
{
connector
.
speculativeConnect
(
searchURI
principal
callbacks
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
this
.
supportsResponseType
(
URLTYPE_SUGGEST_JSON
)
)
{
let
suggestURI
=
this
.
getSubmission
(
"
dummy
"
URLTYPE_SUGGEST_JSON
)
.
uri
;
if
(
suggestURI
.
prePath
!
=
searchURI
.
prePath
)
try
{
connector
.
speculativeConnect
(
suggestURI
principal
callbacks
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
}
;
function
Submission
(
uri
postData
=
null
)
{
this
.
_uri
=
uri
;
this
.
_postData
=
postData
;
}
Submission
.
prototype
=
{
get
uri
(
)
{
return
this
.
_uri
;
}
get
postData
(
)
{
return
this
.
_postData
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsISearchSubmission
]
)
}
;
function
ParseSubmissionResult
(
engine
terms
termsOffset
termsLength
)
{
this
.
_engine
=
engine
;
this
.
_terms
=
terms
;
this
.
_termsOffset
=
termsOffset
;
this
.
_termsLength
=
termsLength
;
}
ParseSubmissionResult
.
prototype
=
{
get
engine
(
)
{
return
this
.
_engine
;
}
get
terms
(
)
{
return
this
.
_terms
;
}
get
termsOffset
(
)
{
return
this
.
_termsOffset
;
}
get
termsLength
(
)
{
return
this
.
_termsLength
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsISearchParseSubmissionResult
]
)
}
;
const
gEmptyParseSubmissionResult
=
Object
.
freeze
(
new
ParseSubmissionResult
(
null
"
"
-
1
0
)
)
;
function
SearchService
(
)
{
this
.
_initObservers
=
PromiseUtils
.
defer
(
)
;
}
SearchService
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
7319788a
-
fe93
-
4db3
-
9f39
-
818cf08f4256
}
"
)
_initRV
:
Cr
.
NS_OK
_initStarted
:
null
_ensureKnownRegionPromise
:
null
_cacheFileJSON
:
null
_submissionURLIgnoreList
:
[
]
_loadPathIgnoreList
:
[
]
_ensureInitialized
(
)
{
if
(
gInitialized
)
{
if
(
!
Components
.
isSuccessCode
(
this
.
_initRV
)
)
{
LOG
(
"
_ensureInitialized
:
failure
"
)
;
throw
this
.
_initRV
;
}
return
;
}
let
err
=
new
Error
(
"
Something
tried
to
use
the
search
service
before
it
'
s
been
"
+
"
properly
intialized
.
Please
examine
the
stack
trace
to
figure
out
what
and
"
+
"
where
to
fix
it
:
\
n
"
)
;
err
.
message
+
=
err
.
stack
;
throw
err
;
}
async
_init
(
skipRegionCheck
)
{
LOG
(
"
_init
start
"
)
;
let
cache
=
await
this
.
_readCacheFile
(
)
;
this
.
_ensureKnownRegionPromise
=
ensureKnownRegion
(
this
)
.
catch
(
ex
=
>
LOG
(
"
_init
:
failure
determining
region
:
"
+
ex
)
)
.
finally
(
(
)
=
>
this
.
_ensureKnownRegionPromise
=
null
)
;
if
(
!
skipRegionCheck
)
{
await
this
.
_ensureKnownRegionPromise
;
}
this
.
_setupRemoteSettings
(
)
.
catch
(
Cu
.
reportError
)
;
try
{
await
this
.
_loadEngines
(
cache
)
;
}
catch
(
ex
)
{
this
.
_initRV
=
Cr
.
NS_ERROR_FAILURE
;
LOG
(
"
_init
:
failure
loading
engines
:
"
+
ex
+
"
\
n
"
+
ex
.
stack
)
;
}
this
.
_buildCache
(
)
;
this
.
_addObservers
(
)
;
gInitialized
=
true
;
if
(
Components
.
isSuccessCode
(
this
.
_initRV
)
)
{
this
.
_initObservers
.
resolve
(
this
.
_initRV
)
;
}
else
{
this
.
_initObservers
.
reject
(
this
.
_initRV
)
;
}
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
init
-
complete
"
)
;
LOG
(
"
_init
:
Completed
_init
"
)
;
return
this
.
_initRV
;
}
async
_setupRemoteSettings
(
)
{
const
ignoreListSettings
=
RemoteSettings
(
SETTINGS_IGNORELIST_KEY
)
;
const
current
=
await
ignoreListSettings
.
get
(
)
;
this
.
_ignoreListListener
=
this
.
_handleIgnoreListUpdated
.
bind
(
this
)
;
ignoreListSettings
.
on
(
"
sync
"
this
.
_ignoreListListener
)
;
await
this
.
_handleIgnoreListUpdated
(
{
data
:
{
current
}
}
)
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
settings
-
update
-
complete
"
)
;
}
async
_handleIgnoreListUpdated
(
eventData
)
{
LOG
(
"
_handleIgnoreListUpdated
"
)
;
const
{
data
:
{
current
}
}
=
eventData
;
for
(
const
entry
of
current
)
{
if
(
entry
.
id
=
=
"
load
-
paths
"
)
{
this
.
_loadPathIgnoreList
=
[
.
.
.
entry
.
matches
]
;
}
else
if
(
entry
.
id
=
=
"
submission
-
urls
"
)
{
this
.
_submissionURLIgnoreList
=
[
.
.
.
entry
.
matches
]
;
}
}
if
(
!
this
.
isInitialized
)
{
await
this
.
_initObservers
;
}
let
engineRemoved
=
false
;
for
(
let
name
in
this
.
_engines
)
{
let
engine
=
this
.
_engines
[
name
]
;
if
(
this
.
_engineMatchesIgnoreLists
(
engine
)
)
{
await
this
.
removeEngine
(
engine
)
;
engineRemoved
=
true
;
}
}
if
(
engineRemoved
&
&
!
Object
.
keys
(
this
.
_engines
)
.
length
)
{
this
.
_reInit
(
)
;
}
}
_engineMatchesIgnoreLists
(
engine
)
{
if
(
this
.
_loadPathIgnoreList
.
includes
(
engine
.
_loadPath
)
)
{
return
true
;
}
let
url
=
engine
.
_getURLOfType
(
"
text
/
html
"
)
.
getSubmission
(
"
dummy
"
engine
)
.
uri
.
spec
.
toLowerCase
(
)
;
if
(
this
.
_submissionURLIgnoreList
.
some
(
code
=
>
url
.
includes
(
code
.
toLowerCase
(
)
)
)
)
{
return
true
;
}
return
false
;
}
_metaData
:
{
}
setGlobalAttr
(
name
val
)
{
this
.
_metaData
[
name
]
=
val
;
this
.
batchTask
.
disarm
(
)
;
this
.
batchTask
.
arm
(
)
;
}
setVerifiedGlobalAttr
(
name
val
)
{
this
.
setGlobalAttr
(
name
val
)
;
this
.
setGlobalAttr
(
name
+
"
Hash
"
getVerificationHash
(
val
)
)
;
}
getGlobalAttr
(
name
)
{
return
this
.
_metaData
[
name
]
|
|
undefined
;
}
getVerifiedGlobalAttr
(
name
)
{
let
val
=
this
.
getGlobalAttr
(
name
)
;
if
(
val
&
&
this
.
getGlobalAttr
(
name
+
"
Hash
"
)
!
=
getVerificationHash
(
val
)
)
{
LOG
(
"
getVerifiedGlobalAttr
invalid
hash
for
"
+
name
)
;
return
"
"
;
}
return
val
;
}
_listJSONURL
:
(
(
AppConstants
.
platform
=
=
"
android
"
)
?
APP_SEARCH_PREFIX
:
EXT_SEARCH_PREFIX
)
+
"
list
.
json
"
_engines
:
{
}
__sortedEngines
:
null
_visibleDefaultEngines
:
[
]
_searchDefault
:
null
_searchOrder
:
[
]
_extensions
:
new
Map
(
)
get
_sortedEngines
(
)
{
if
(
!
this
.
__sortedEngines
)
return
this
.
_buildSortedEngineList
(
)
;
return
this
.
__sortedEngines
;
}
get
originalDefaultEngine
(
)
{
let
defaultEngineName
=
this
.
getVerifiedGlobalAttr
(
"
searchDefault
"
)
;
if
(
!
defaultEngineName
)
{
if
(
distroID
)
{
let
defaultPrefB
=
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
;
let
nsIPLS
=
Ci
.
nsIPrefLocalizedString
;
try
{
defaultEngineName
=
defaultPrefB
.
getComplexValue
(
"
defaultenginename
"
nsIPLS
)
.
data
;
}
catch
(
ex
)
{
defaultEngineName
=
this
.
_searchDefault
;
}
}
else
{
defaultEngineName
=
this
.
_searchDefault
;
}
}
let
defaultEngine
=
this
.
getEngineByName
(
defaultEngineName
)
;
if
(
!
defaultEngine
)
{
return
this
.
_getSortedEngines
(
false
)
[
0
]
;
}
return
defaultEngine
;
}
resetToOriginalDefaultEngine
(
)
{
let
originalDefaultEngine
=
this
.
originalDefaultEngine
;
originalDefaultEngine
.
hidden
=
false
;
this
.
defaultEngine
=
originalDefaultEngine
;
}
async
_buildCache
(
)
{
if
(
this
.
_batchTask
)
this
.
_batchTask
.
disarm
(
)
;
let
cache
=
{
}
;
let
locale
=
getLocale
(
)
;
let
buildID
=
Services
.
appinfo
.
platformBuildID
;
let
appVersion
=
Services
.
appinfo
.
version
;
cache
.
version
=
CACHE_VERSION
;
cache
.
buildID
=
buildID
;
cache
.
appVersion
=
appVersion
;
cache
.
locale
=
locale
;
cache
.
visibleDefaultEngines
=
this
.
_visibleDefaultEngines
;
cache
.
metaData
=
this
.
_metaData
;
cache
.
engines
=
[
]
;
for
(
let
name
in
this
.
_engines
)
{
cache
.
engines
.
push
(
this
.
_engines
[
name
]
)
;
}
try
{
if
(
!
cache
.
engines
.
length
)
throw
new
Error
(
"
cannot
write
without
any
engine
.
"
)
;
LOG
(
"
_buildCache
:
Writing
to
cache
file
.
"
)
;
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CACHE_FILENAME
)
;
let
data
=
gEncoder
.
encode
(
JSON
.
stringify
(
cache
)
)
;
await
OS
.
File
.
writeAtomic
(
path
data
{
compression
:
"
lz4
"
tmpPath
:
path
+
"
.
tmp
"
}
)
;
LOG
(
"
_buildCache
:
cache
file
written
to
disk
.
"
)
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
SEARCH_SERVICE_CACHE_WRITTEN
)
;
}
catch
(
ex
)
{
LOG
(
"
_buildCache
:
Could
not
write
to
cache
file
:
"
+
ex
)
;
}
}
async
_loadEngines
(
cache
isReload
)
{
LOG
(
"
_loadEngines
:
start
"
)
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
find
-
jar
-
engines
"
)
;
let
engines
=
await
this
.
_findEngines
(
)
;
let
distDirs
=
[
]
;
let
locations
;
try
{
locations
=
getDir
(
NS_APP_DISTRIBUTION_SEARCH_DIR_LIST
Ci
.
nsISimpleEnumerator
)
;
}
catch
(
e
)
{
locations
=
[
]
;
}
for
(
let
dir
of
locations
)
{
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
dir
.
path
{
winPattern
:
"
*
.
xml
"
}
)
;
try
{
let
{
done
}
=
await
iterator
.
next
(
)
;
if
(
!
done
)
{
distDirs
.
push
(
dir
)
;
}
}
finally
{
iterator
.
close
(
)
;
}
}
function
notInCacheVisibleEngines
(
engineName
)
{
return
!
cache
.
visibleDefaultEngines
.
includes
(
engineName
)
;
}
function
parseEngineName
(
engineName
)
{
let
[
name
locale
]
=
engineName
.
split
(
/
-
(
.
+
)
/
)
;
if
(
!
MULTI_LOCALE_ENGINES
.
includes
(
name
)
)
{
return
[
engineName
DEFAULT_TAG
]
;
}
if
(
!
locale
)
{
locale
=
DEFAULT_TAG
;
}
return
[
name
locale
]
;
}
function
extensionId
(
name
)
{
return
name
+
"
"
+
EXT_SIGNING_ADDRESS
;
}
let
buildID
=
Services
.
appinfo
.
platformBuildID
;
let
rebuildCache
=
!
cache
.
engines
|
|
cache
.
version
!
=
CACHE_VERSION
|
|
cache
.
locale
!
=
getLocale
(
)
|
|
cache
.
buildID
!
=
buildID
|
|
cache
.
visibleDefaultEngines
.
length
!
=
this
.
_visibleDefaultEngines
.
length
|
|
this
.
_visibleDefaultEngines
.
some
(
notInCacheVisibleEngines
)
;
for
(
let
id
of
this
.
_extensions
.
keys
(
)
)
{
let
policy
=
WebExtensionPolicy
.
getByID
(
id
)
;
if
(
!
policy
)
{
continue
;
}
let
extension
=
policy
.
extension
;
if
(
extension
.
addonData
.
builtIn
&
&
!
engines
.
some
(
name
=
>
extensionId
(
name
)
=
=
=
id
)
)
{
this
.
_extensions
.
delete
(
id
)
;
}
}
for
(
let
engine
of
engines
)
{
let
[
extensionName
locale
]
=
parseEngineName
(
engine
)
;
let
id
=
extensionId
(
extensionName
)
;
let
localeMap
=
this
.
_extensions
.
get
(
id
)
|
|
new
Map
(
)
;
let
params
=
localeMap
.
get
(
locale
)
;
if
(
!
params
)
{
localeMap
.
set
(
locale
!
rebuildCache
)
;
this
.
_extensions
.
set
(
id
localeMap
)
;
}
}
if
(
!
rebuildCache
)
{
LOG
(
"
_loadEngines
:
loading
from
cache
directories
"
)
;
this
.
_loadEnginesFromCache
(
cache
)
;
if
(
Object
.
keys
(
this
.
_engines
)
.
length
)
{
LOG
(
"
_loadEngines
:
done
using
existing
cache
"
)
;
return
;
}
LOG
(
"
_loadEngines
:
No
valid
engines
found
in
cache
.
Loading
engines
from
disk
.
"
)
;
}
LOG
(
"
_loadEngines
:
Absent
or
outdated
cache
.
Loading
engines
from
disk
.
"
)
;
for
(
let
loadDir
of
distDirs
)
{
let
enginesFromDir
=
await
this
.
_loadEnginesFromDir
(
loadDir
)
;
enginesFromDir
.
forEach
(
this
.
_addEngineToStore
this
)
;
}
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
let
enginesFromURLs
=
await
this
.
_loadFromChromeURLs
(
engines
isReload
)
;
enginesFromURLs
.
forEach
(
this
.
_addEngineToStore
this
)
;
}
else
{
for
(
let
[
id
localeMap
]
of
this
.
_extensions
)
{
let
policy
=
WebExtensionPolicy
.
getByID
(
id
)
;
if
(
policy
)
{
LOG
(
"
_loadEngines
:
Found
previously
installed
extension
"
)
;
await
this
.
addEnginesFromExtension
(
policy
.
extension
)
;
}
else
{
LOG
(
"
_loadEngines
:
Installing
"
+
id
)
;
for
(
let
[
locale
installed
]
of
localeMap
)
{
if
(
installed
=
=
=
true
)
{
localeMap
.
set
(
locale
null
)
;
}
}
this
.
_extensions
.
set
(
id
localeMap
)
;
let
path
=
EXT_SEARCH_PREFIX
+
id
.
split
(
"
"
)
[
0
]
+
"
/
"
;
await
AddonManager
.
installBuiltinAddon
(
path
)
;
await
ExtensionParent
.
apiManager
.
global
.
pendingSearchSetupTasks
.
get
(
id
)
;
LOG
(
"
_loadEngines
:
"
+
id
+
"
installed
"
)
;
}
}
}
LOG
(
"
_loadEngines
:
loading
user
-
installed
engines
from
the
obsolete
cache
"
)
;
this
.
_loadEnginesFromCache
(
cache
true
)
;
this
.
_loadEnginesMetadataFromCache
(
cache
)
;
LOG
(
"
_loadEngines
:
done
using
rebuilt
cache
"
)
;
}
async
_maybeReloadEngines
(
)
{
if
(
!
gInitialized
)
{
return
;
}
if
(
this
.
_batchTask
)
{
let
task
=
this
.
_batchTask
;
this
.
_batchTask
=
null
;
await
task
.
finalize
(
)
;
}
let
prevCurrentEngine
=
this
.
_currentEngine
;
this
.
_currentEngine
=
null
;
await
this
.
_loadEngines
(
await
this
.
_readCacheFile
(
)
true
)
;
await
this
.
_buildCache
(
)
;
if
(
prevCurrentEngine
&
&
this
.
defaultEngine
!
=
=
prevCurrentEngine
)
{
notifyAction
(
this
.
_currentEngine
SEARCH_ENGINE_DEFAULT
)
;
}
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
engines
-
reloaded
"
)
;
}
_reInit
(
origin
skipRegionCheck
=
true
)
{
LOG
(
"
_reInit
"
)
;
if
(
gReinitializing
)
{
LOG
(
"
_reInit
:
already
re
-
initializing
bailing
out
.
"
)
;
return
;
}
gReinitializing
=
true
;
gInitialized
=
false
;
(
async
(
)
=
>
{
try
{
this
.
_initObservers
=
PromiseUtils
.
defer
(
)
;
if
(
this
.
_batchTask
)
{
LOG
(
"
finalizing
batch
task
"
)
;
let
task
=
this
.
_batchTask
;
this
.
_batchTask
=
null
;
if
(
origin
=
=
"
test
"
)
{
task
.
disarm
(
)
;
}
else
{
await
task
.
finalize
(
)
;
}
}
this
.
_engines
=
{
}
;
this
.
__sortedEngines
=
null
;
this
.
_currentEngine
=
null
;
this
.
_visibleDefaultEngines
=
[
]
;
this
.
_searchDefault
=
null
;
this
.
_searchOrder
=
[
]
;
this
.
_metaData
=
{
}
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
uninit
-
complete
"
)
;
let
cache
=
await
this
.
_readCacheFile
(
)
;
this
.
_ensureKnownRegionPromise
=
ensureKnownRegion
(
this
)
.
catch
(
ex
=
>
LOG
(
"
_reInit
:
failure
determining
region
:
"
+
ex
)
)
.
finally
(
(
)
=
>
this
.
_ensureKnownRegionPromise
=
null
)
;
if
(
!
skipRegionCheck
)
{
await
this
.
_ensureKnownRegionPromise
;
}
await
this
.
_loadEngines
(
cache
)
;
await
this
.
_buildCache
(
)
;
gInitialized
=
true
;
this
.
_initObservers
.
resolve
(
)
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
init
-
complete
"
)
;
}
catch
(
err
)
{
LOG
(
"
Reinit
failed
:
"
+
err
)
;
LOG
(
err
.
stack
)
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
reinit
-
failed
"
)
;
}
finally
{
gReinitializing
=
false
;
Services
.
obs
.
notifyObservers
(
null
SEARCH_SERVICE_TOPIC
"
reinit
-
complete
"
)
;
}
}
)
(
)
;
}
reset
(
)
{
gInitialized
=
false
;
this
.
_extensions
=
new
Map
(
)
;
this
.
_startupExtensions
=
new
Map
(
)
;
}
async
_readCacheFile
(
)
{
let
json
;
try
{
let
cacheFilePath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CACHE_FILENAME
)
;
let
bytes
=
await
OS
.
File
.
read
(
cacheFilePath
{
compression
:
"
lz4
"
}
)
;
json
=
JSON
.
parse
(
new
TextDecoder
(
)
.
decode
(
bytes
)
)
;
if
(
!
json
.
engines
|
|
!
json
.
engines
.
length
)
throw
new
Error
(
"
no
engine
in
the
file
"
)
;
if
(
json
.
appVersion
!
=
Services
.
appinfo
.
version
&
&
geoSpecificDefaultsEnabled
(
)
&
&
json
.
metaData
)
{
json
.
metaData
.
searchDefaultExpir
=
0
;
}
}
catch
(
ex
)
{
LOG
(
"
_readCacheFile
:
Error
reading
cache
file
:
"
+
ex
)
;
json
=
{
}
;
}
if
(
!
gInitialized
&
&
json
.
metaData
)
this
.
_metaData
=
json
.
metaData
;
return
json
;
}
_batchTask
:
null
get
batchTask
(
)
{
if
(
!
this
.
_batchTask
)
{
let
task
=
async
(
)
=
>
{
LOG
(
"
batchTask
:
Invalidating
engine
cache
"
)
;
await
this
.
_buildCache
(
)
;
}
;
this
.
_batchTask
=
new
DeferredTask
(
task
CACHE_INVALIDATION_DELAY
)
;
}
return
this
.
_batchTask
;
}
_addEngineToStore
(
engine
)
{
if
(
this
.
_engineMatchesIgnoreLists
(
engine
)
)
{
LOG
(
"
_addEngineToStore
:
Ignoring
engine
"
)
;
return
;
}
LOG
(
"
_addEngineToStore
:
Adding
engine
:
\
"
"
+
engine
.
name
+
"
\
"
"
)
;
var
hasSameNameAsUpdate
=
(
engine
.
_engineToUpdate
&
&
engine
.
name
=
=
engine
.
_engineToUpdate
.
name
)
;
if
(
engine
.
name
in
this
.
_engines
&
&
!
hasSameNameAsUpdate
)
{
LOG
(
"
_addEngineToStore
:
Duplicate
engine
found
aborting
!
"
)
;
return
;
}
if
(
engine
.
_engineToUpdate
)
{
var
oldEngine
=
engine
.
_engineToUpdate
;
delete
this
.
_engines
[
oldEngine
.
name
]
;
for
(
var
p
in
engine
)
{
if
(
!
(
engine
.
__lookupGetter__
(
p
)
|
|
engine
.
__lookupSetter__
(
p
)
)
)
oldEngine
[
p
]
=
engine
[
p
]
;
}
engine
=
oldEngine
;
engine
.
_engineToUpdate
=
null
;
this
.
_engines
[
engine
.
name
]
=
engine
;
notifyAction
(
engine
SEARCH_ENGINE_CHANGED
)
;
}
else
{
this
.
_engines
[
engine
.
name
]
=
engine
;
if
(
this
.
__sortedEngines
)
{
this
.
__sortedEngines
.
push
(
engine
)
;
this
.
_saveSortedEngineList
(
)
;
}
notifyAction
(
engine
SEARCH_ENGINE_ADDED
)
;
}
if
(
engine
.
_hasUpdates
)
{
if
(
!
engine
.
getAttr
(
"
updateexpir
"
)
)
engineUpdateService
.
scheduleNextUpdate
(
engine
)
;
}
}
_loadEnginesMetadataFromCache
(
cache
)
{
if
(
!
cache
.
engines
)
return
;
for
(
let
engine
of
cache
.
engines
)
{
let
name
=
engine
.
_name
;
if
(
name
in
this
.
_engines
)
{
LOG
(
"
_loadEnginesMetadataFromCache
transfering
metadata
for
"
+
name
)
;
this
.
_engines
[
name
]
.
_metaData
=
engine
.
_metaData
|
|
{
}
;
}
}
}
_loadEnginesFromCache
(
cache
skipReadOnly
)
{
if
(
!
cache
.
engines
)
return
;
LOG
(
"
_loadEnginesFromCache
:
Loading
"
+
cache
.
engines
.
length
+
"
engines
from
cache
"
)
;
let
skippedEngines
=
0
;
for
(
let
engine
of
cache
.
engines
)
{
if
(
skipReadOnly
&
&
engine
.
_readOnly
=
=
undefined
)
{
+
+
skippedEngines
;
continue
;
}
this
.
_loadEngineFromCache
(
engine
)
;
}
if
(
skippedEngines
)
{
LOG
(
"
_loadEnginesFromCache
:
skipped
"
+
skippedEngines
+
"
read
-
only
engines
.
"
)
;
}
}
_loadEngineFromCache
(
json
)
{
try
{
let
engine
=
new
Engine
(
json
.
_shortName
json
.
_readOnly
=
=
undefined
)
;
engine
.
_initWithJSON
(
json
)
;
this
.
_addEngineToStore
(
engine
)
;
}
catch
(
ex
)
{
LOG
(
"
Failed
to
load
"
+
json
.
_name
+
"
from
cache
:
"
+
ex
)
;
LOG
(
"
Engine
JSON
:
"
+
json
.
toSource
(
)
)
;
}
}
async
_loadEnginesFromDir
(
dir
)
{
LOG
(
"
_loadEnginesFromDir
:
Searching
in
"
+
dir
.
path
+
"
for
search
engines
.
"
)
;
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
dir
.
path
)
;
let
osfiles
=
await
iterator
.
nextBatch
(
)
;
iterator
.
close
(
)
;
let
engines
=
[
]
;
for
(
let
osfile
of
osfiles
)
{
if
(
osfile
.
isDir
|
|
osfile
.
isSymLink
)
continue
;
let
fileInfo
=
await
OS
.
File
.
stat
(
osfile
.
path
)
;
if
(
fileInfo
.
size
=
=
0
)
continue
;
let
parts
=
osfile
.
path
.
split
(
"
.
"
)
;
if
(
parts
.
length
<
=
1
|
|
(
parts
.
pop
(
)
)
.
toLowerCase
(
)
!
=
"
xml
"
)
{
continue
;
}
let
addedEngine
=
null
;
try
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
osfile
.
path
)
;
addedEngine
=
new
Engine
(
file
false
)
;
await
addedEngine
.
_initFromFile
(
file
)
;
engines
.
push
(
addedEngine
)
;
}
catch
(
ex
)
{
LOG
(
"
_loadEnginesFromDir
:
Failed
to
load
"
+
osfile
.
path
+
"
!
\
n
"
+
ex
)
;
}
}
return
engines
;
}
async
_loadFromChromeURLs
(
urls
isReload
=
false
)
{
let
engines
=
[
]
;
for
(
let
url
of
urls
)
{
try
{
LOG
(
"
_loadFromChromeURLs
:
loading
engine
from
chrome
url
:
"
+
url
)
;
let
uri
=
Services
.
io
.
newURI
(
APP_SEARCH_PREFIX
+
url
+
"
.
xml
"
)
;
let
engine
=
new
Engine
(
uri
true
)
;
await
engine
.
_initFromURI
(
uri
)
;
if
(
isReload
&
&
engine
.
name
in
this
.
_engines
)
{
engine
.
_engineToUpdate
=
this
.
_engines
[
engine
.
name
]
;
}
engines
.
push
(
engine
)
;
}
catch
(
ex
)
{
LOG
(
"
_loadFromChromeURLs
:
failed
to
load
engine
:
"
+
ex
)
;
}
}
return
engines
;
}
async
_findEngines
(
)
{
LOG
(
"
_findEngines
:
looking
for
engines
in
JARs
"
)
;
let
chan
=
makeChannel
(
this
.
_listJSONURL
)
;
if
(
!
chan
)
{
LOG
(
"
_findEngines
:
"
+
this
.
_listJSONURL
+
"
isn
'
t
registered
"
)
;
return
[
]
;
}
let
uris
=
[
]
;
let
request
=
new
XMLHttpRequest
(
)
;
request
.
overrideMimeType
(
"
text
/
plain
"
)
;
let
list
=
await
new
Promise
(
resolve
=
>
{
request
.
onload
=
function
(
event
)
{
resolve
(
event
.
target
.
responseText
)
;
}
;
request
.
onerror
=
function
(
event
)
{
LOG
(
"
_findEngines
:
failed
to
read
"
+
this
.
_listJSONURL
)
;
resolve
(
)
;
}
;
request
.
open
(
"
GET
"
Services
.
io
.
newURI
(
this
.
_listJSONURL
)
.
spec
true
)
;
request
.
send
(
)
;
}
)
;
this
.
_parseListJSON
(
list
uris
)
;
return
uris
;
}
_parseListJSON
(
list
uris
)
{
let
json
;
try
{
json
=
JSON
.
parse
(
list
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
parseListJSON
:
Failed
to
parse
list
.
json
:
"
+
e
)
;
dump
(
"
parseListJSON
:
Failed
to
parse
list
.
json
:
"
+
e
+
"
\
n
"
)
;
return
;
}
let
searchRegion
=
Services
.
prefs
.
getCharPref
(
"
browser
.
search
.
region
"
null
)
;
let
searchSettings
;
let
locale
=
Services
.
locale
.
appLocaleAsBCP47
;
if
(
"
locales
"
in
json
&
&
locale
in
json
.
locales
)
{
searchSettings
=
json
.
locales
[
locale
]
;
}
else
{
if
(
!
(
"
default
"
in
json
)
)
{
Cu
.
reportError
(
"
parseListJSON
:
Missing
default
in
list
.
json
"
)
;
dump
(
"
parseListJSON
:
Missing
default
in
list
.
json
\
n
"
)
;
return
;
}
searchSettings
=
json
;
}
let
engineNames
;
let
visibleDefaultEngines
=
this
.
getVerifiedGlobalAttr
(
"
visibleDefaultEngines
"
)
;
if
(
visibleDefaultEngines
)
{
let
jarNames
=
new
Set
(
)
;
for
(
let
region
in
searchSettings
)
{
if
(
!
(
"
visibleDefaultEngines
"
in
searchSettings
[
region
]
)
)
{
continue
;
}
for
(
let
engine
of
searchSettings
[
region
]
.
visibleDefaultEngines
)
{
jarNames
.
add
(
engine
)
;
}
if
(
"
regionOverrides
"
in
json
&
&
searchRegion
in
json
.
regionOverrides
)
{
for
(
let
engine
in
json
.
regionOverrides
[
searchRegion
]
)
{
jarNames
.
add
(
json
.
regionOverrides
[
searchRegion
]
[
engine
]
)
;
}
}
}
engineNames
=
visibleDefaultEngines
.
split
(
"
"
)
;
engineNames
=
convertGoogleEngines
(
engineNames
)
;
for
(
let
engineName
of
engineNames
)
{
if
(
!
jarNames
.
has
(
engineName
)
)
{
LOG
(
"
_parseListJSON
:
ignoring
visibleDefaultEngines
value
because
"
+
engineName
+
"
is
not
in
the
jar
engines
we
have
found
"
)
;
engineNames
=
null
;
break
;
}
}
}
if
(
!
engineNames
|
|
!
engineNames
.
length
)
{
if
(
searchRegion
&
&
searchRegion
in
searchSettings
&
&
"
visibleDefaultEngines
"
in
searchSettings
[
searchRegion
]
)
{
engineNames
=
searchSettings
[
searchRegion
]
.
visibleDefaultEngines
;
}
else
{
engineNames
=
searchSettings
.
default
.
visibleDefaultEngines
;
}
}
let
branch
=
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
;
if
(
isPartnerBuild
(
)
&
&
branch
.
getPrefType
(
"
ignoredJAREngines
"
)
=
=
branch
.
PREF_STRING
)
{
let
ignoredJAREngines
=
branch
.
getCharPref
(
"
ignoredJAREngines
"
)
.
split
(
"
"
)
;
let
filteredEngineNames
=
engineNames
.
filter
(
e
=
>
!
ignoredJAREngines
.
includes
(
e
)
)
;
if
(
filteredEngineNames
.
length
>
0
)
{
engineNames
=
filteredEngineNames
;
}
}
if
(
"
regionOverrides
"
in
json
&
&
searchRegion
in
json
.
regionOverrides
)
{
for
(
let
engine
in
json
.
regionOverrides
[
searchRegion
]
)
{
let
index
=
engineNames
.
indexOf
(
engine
)
;
if
(
index
>
-
1
)
{
engineNames
[
index
]
=
json
.
regionOverrides
[
searchRegion
]
[
engine
]
;
}
}
}
if
(
AppConstants
.
MOZ_APP_VERSION_DISPLAY
.
endsWith
(
"
esr
"
)
)
{
let
esrOverrides
=
{
"
google
-
b
-
d
"
:
"
google
-
b
-
e
"
"
google
-
b
-
1
-
d
"
:
"
google
-
b
-
1
-
e
"
}
;
for
(
let
engine
in
esrOverrides
)
{
let
index
=
engineNames
.
indexOf
(
engine
)
;
if
(
index
>
-
1
)
{
engineNames
[
index
]
=
esrOverrides
[
engine
]
;
}
}
}
for
(
let
name
of
engineNames
)
{
uris
.
push
(
name
)
;
}
this
.
_visibleDefaultEngines
=
engineNames
;
if
(
searchRegion
&
&
searchRegion
in
searchSettings
&
&
"
searchDefault
"
in
searchSettings
[
searchRegion
]
)
{
this
.
_searchDefault
=
searchSettings
[
searchRegion
]
.
searchDefault
;
}
else
if
(
"
searchDefault
"
in
searchSettings
.
default
)
{
this
.
_searchDefault
=
searchSettings
.
default
.
searchDefault
;
}
else
{
this
.
_searchDefault
=
json
.
default
.
searchDefault
;
}
if
(
!
this
.
_searchDefault
)
{
Cu
.
reportError
(
"
parseListJSON
:
No
searchDefault
"
)
;
}
if
(
searchRegion
&
&
searchRegion
in
searchSettings
&
&
"
searchOrder
"
in
searchSettings
[
searchRegion
]
)
{
this
.
_searchOrder
=
searchSettings
[
searchRegion
]
.
searchOrder
;
}
else
if
(
"
searchOrder
"
in
searchSettings
.
default
)
{
this
.
_searchOrder
=
searchSettings
.
default
.
searchOrder
;
}
else
if
(
"
searchOrder
"
in
json
.
default
)
{
this
.
_searchOrder
=
json
.
default
.
searchOrder
;
}
}
_saveSortedEngineList
(
)
{
LOG
(
"
_saveSortedEngineList
:
starting
"
)
;
Services
.
prefs
.
setBoolPref
(
BROWSER_SEARCH_PREF
+
"
useDBForOrder
"
true
)
;
var
engines
=
this
.
_getSortedEngines
(
true
)
;
for
(
var
i
=
0
;
i
<
engines
.
length
;
+
+
i
)
{
engines
[
i
]
.
setAttr
(
"
order
"
i
+
1
)
;
}
LOG
(
"
_saveSortedEngineList
:
done
"
)
;
}
_buildSortedEngineList
(
)
{
LOG
(
"
_buildSortedEngineList
:
building
list
"
)
;
var
addedEngines
=
{
}
;
this
.
__sortedEngines
=
[
]
;
if
(
Services
.
prefs
.
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
useDBForOrder
"
false
)
)
{
LOG
(
"
_buildSortedEngineList
:
using
db
for
order
"
)
;
let
needToSaveEngineList
=
false
;
for
(
let
name
in
this
.
_engines
)
{
let
engine
=
this
.
_engines
[
name
]
;
var
orderNumber
=
engine
.
getAttr
(
"
order
"
)
;
if
(
orderNumber
&
&
!
this
.
__sortedEngines
[
orderNumber
-
1
]
)
{
this
.
__sortedEngines
[
orderNumber
-
1
]
=
engine
;
addedEngines
[
engine
.
name
]
=
engine
;
}
else
{
needToSaveEngineList
=
true
;
}
}
var
filteredEngines
=
this
.
__sortedEngines
.
filter
(
function
(
a
)
{
return
!
!
a
;
}
)
;
if
(
this
.
__sortedEngines
.
length
!
=
filteredEngines
.
length
)
needToSaveEngineList
=
true
;
this
.
__sortedEngines
=
filteredEngines
;
if
(
needToSaveEngineList
)
this
.
_saveSortedEngineList
(
)
;
}
else
{
var
i
=
0
;
var
prefName
;
if
(
this
.
originalDefaultEngine
)
{
this
.
__sortedEngines
.
push
(
this
.
originalDefaultEngine
)
;
addedEngines
[
this
.
originalDefaultEngine
.
name
]
=
this
.
originalDefaultEngine
;
}
if
(
distroID
)
{
try
{
var
extras
=
Services
.
prefs
.
getChildList
(
BROWSER_SEARCH_PREF
+
"
order
.
extra
.
"
)
;
for
(
prefName
of
extras
)
{
let
engineName
=
Services
.
prefs
.
getCharPref
(
prefName
)
;
let
engine
=
this
.
_engines
[
engineName
]
;
if
(
!
engine
|
|
engine
.
name
in
addedEngines
)
continue
;
this
.
__sortedEngines
.
push
(
engine
)
;
addedEngines
[
engine
.
name
]
=
engine
;
}
}
catch
(
e
)
{
}
while
(
true
)
{
prefName
=
{
BROWSER_SEARCH_PREF
}
order
.
{
+
+
i
}
;
let
engineName
=
getLocalizedPref
(
prefName
)
;
if
(
!
engineName
)
break
;
let
engine
=
this
.
_engines
[
engineName
]
;
if
(
!
engine
|
|
engine
.
name
in
addedEngines
)
continue
;
this
.
__sortedEngines
.
push
(
engine
)
;
addedEngines
[
engine
.
name
]
=
engine
;
}
}
for
(
let
engineName
of
this
.
_searchOrder
)
{
let
engine
=
this
.
_engines
[
engineName
]
;
if
(
!
engine
|
|
engine
.
name
in
addedEngines
)
continue
;
this
.
__sortedEngines
.
push
(
engine
)
;
addedEngines
[
engine
.
name
]
=
engine
;
}
}
let
alphaEngines
=
[
]
;
for
(
let
name
in
this
.
_engines
)
{
let
engine
=
this
.
_engines
[
name
]
;
if
(
!
(
engine
.
name
in
addedEngines
)
)
alphaEngines
.
push
(
this
.
_engines
[
engine
.
name
]
)
;
}
let
collation
=
Cc
[
"
mozilla
.
org
/
intl
/
collation
-
factory
;
1
"
]
.
createInstance
(
Ci
.
nsICollationFactory
)
.
CreateCollation
(
)
;
const
strength
=
Ci
.
nsICollation
.
kCollationCaseInsensitiveAscii
;
let
comparator
=
(
a
b
)
=
>
collation
.
compareString
(
strength
a
.
name
b
.
name
)
;
alphaEngines
.
sort
(
comparator
)
;
return
this
.
__sortedEngines
=
this
.
__sortedEngines
.
concat
(
alphaEngines
)
;
}
_getSortedEngines
(
withHidden
)
{
if
(
withHidden
)
return
this
.
_sortedEngines
;
return
this
.
_sortedEngines
.
filter
(
function
(
engine
)
{
return
!
engine
.
hidden
;
}
)
;
}
async
init
(
skipRegionCheck
=
false
)
{
LOG
(
"
SearchService
.
init
"
)
;
if
(
this
.
_initStarted
)
{
if
(
!
skipRegionCheck
)
{
await
this
.
_ensureKnownRegionPromise
;
}
return
this
.
_initObservers
.
promise
;
}
TelemetryStopwatch
.
start
(
"
SEARCH_SERVICE_INIT_MS
"
)
;
this
.
_initStarted
=
true
;
try
{
await
this
.
_init
(
skipRegionCheck
)
;
TelemetryStopwatch
.
finish
(
"
SEARCH_SERVICE_INIT_MS
"
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_ALREADY_INITIALIZED
)
{
TelemetryStopwatch
.
finish
(
"
SEARCH_SERVICE_INIT_MS
"
)
;
}
else
{
this
.
_initObservers
.
reject
(
ex
.
result
)
;
TelemetryStopwatch
.
cancel
(
"
SEARCH_SERVICE_INIT_MS
"
)
;
throw
ex
;
}
}
if
(
!
Components
.
isSuccessCode
(
this
.
_initRV
)
)
{
throw
this
.
_initRV
;
}
return
this
.
_initRV
;
}
get
isInitialized
(
)
{
return
gInitialized
;
}
async
reInit
(
skipRegionCheck
)
{
return
this
.
_reInit
(
"
test
"
skipRegionCheck
)
;
}
async
getEngines
(
)
{
await
this
.
init
(
true
)
;
LOG
(
"
getEngines
:
getting
all
engines
"
)
;
var
engines
=
this
.
_getSortedEngines
(
true
)
;
return
engines
;
}
async
getVisibleEngines
(
)
{
await
this
.
init
(
)
;
LOG
(
"
getVisibleEngines
:
getting
all
visible
engines
"
)
;
var
engines
=
this
.
_getSortedEngines
(
false
)
;
return
engines
;
}
async
getDefaultEngines
(
)
{
await
this
.
init
(
true
)
;
function
isDefault
(
engine
)
{
return
engine
.
_isDefault
;
}
var
engines
=
this
.
_sortedEngines
.
filter
(
isDefault
)
;
var
engineOrder
=
{
}
;
var
i
=
1
;
if
(
distroID
)
{
try
{
var
extras
=
Services
.
prefs
.
getChildList
(
BROWSER_SEARCH_PREF
+
"
order
.
extra
.
"
)
;
for
(
let
prefName
of
extras
)
{
let
engineName
=
Services
.
prefs
.
getCharPref
(
prefName
)
;
if
(
!
(
engineName
in
engineOrder
)
)
engineOrder
[
engineName
]
=
i
+
+
;
}
}
catch
(
e
)
{
LOG
(
"
Getting
extra
order
prefs
failed
:
"
+
e
)
;
}
for
(
var
j
=
1
;
;
j
+
+
)
{
let
prefName
=
{
BROWSER_SEARCH_PREF
}
order
.
{
j
}
;
let
engineName
=
getLocalizedPref
(
prefName
)
;
if
(
!
engineName
)
break
;
if
(
!
(
engineName
in
engineOrder
)
)
engineOrder
[
engineName
]
=
i
+
+
;
}
}
for
(
let
engineName
of
this
.
_searchOrder
)
{
engineOrder
[
engineName
]
=
i
+
+
;
}
LOG
(
"
getDefaultEngines
:
engineOrder
:
"
+
engineOrder
.
toSource
(
)
)
;
function
compareEngines
(
a
b
)
{
var
aIdx
=
engineOrder
[
a
.
name
]
;
var
bIdx
=
engineOrder
[
b
.
name
]
;
if
(
aIdx
&
&
bIdx
)
return
aIdx
-
bIdx
;
if
(
aIdx
)
return
-
1
;
if
(
bIdx
)
return
1
;
return
a
.
name
.
localeCompare
(
b
.
name
)
;
}
engines
.
sort
(
compareEngines
)
;
return
engines
;
}
async
getEnginesByExtensionID
(
extensionID
)
{
await
this
.
init
(
true
)
;
LOG
(
"
getEngines
:
getting
all
engines
for
"
+
extensionID
)
;
var
engines
=
this
.
_getSortedEngines
(
true
)
.
filter
(
function
(
engine
)
{
return
engine
.
_extensionID
=
=
extensionID
;
}
)
;
return
engines
;
}
getEngineByName
(
engineName
)
{
this
.
_ensureInitialized
(
)
;
return
this
.
_engines
[
engineName
]
|
|
null
;
}
getEngineByAlias
(
alias
)
{
this
.
_ensureInitialized
(
)
;
for
(
var
engineName
in
this
.
_engines
)
{
var
engine
=
this
.
_engines
[
engineName
]
;
if
(
engine
&
&
(
engine
.
alias
=
=
alias
|
|
engine
.
_internalAliases
.
includes
(
alias
)
)
)
{
return
engine
;
}
}
return
null
;
}
async
addEngineWithDetails
(
name
iconURL
alias
description
method
template
extensionID
)
{
let
isCurrent
=
false
;
var
params
;
if
(
iconURL
&
&
typeof
iconURL
=
=
"
object
"
)
{
params
=
iconURL
;
}
else
{
params
=
{
iconURL
alias
description
method
template
extensionID
}
;
}
let
isBuiltin
=
!
!
params
.
isBuiltin
;
if
(
!
gInitialized
&
&
!
this
.
_extensions
.
has
(
params
.
extensionID
)
)
{
LOG
(
"
addEngineWithDetails
:
Not
expecting
"
+
params
.
extensionID
)
;
await
this
.
init
(
true
)
;
}
if
(
!
name
)
FAIL
(
"
Invalid
name
passed
to
addEngineWithDetails
!
"
)
;
if
(
!
params
.
template
)
FAIL
(
"
Invalid
template
passed
to
addEngineWithDetails
!
"
)
;
let
existingEngine
=
this
.
_engines
[
name
]
;
if
(
existingEngine
)
{
if
(
params
.
extensionID
&
&
existingEngine
.
_loadPath
.
startsWith
(
jar
:
[
profile
]
/
extensions
/
{
params
.
extensionID
}
)
)
{
isCurrent
=
this
.
defaultEngine
=
=
existingEngine
;
await
this
.
removeEngine
(
existingEngine
)
;
}
else
{
FAIL
(
"
An
engine
with
that
name
already
exists
!
"
Cr
.
NS_ERROR_FILE_ALREADY_EXISTS
)
;
}
}
let
newEngine
=
new
Engine
(
sanitizeName
(
name
)
isBuiltin
)
;
newEngine
.
_initFromMetadata
(
name
params
)
;
newEngine
.
_loadPath
=
"
[
other
]
addEngineWithDetails
"
;
if
(
params
.
extensionID
)
{
newEngine
.
_loadPath
+
=
"
:
"
+
params
.
extensionID
;
}
this
.
_addEngineToStore
(
newEngine
)
;
if
(
isCurrent
)
{
this
.
defaultEngine
=
newEngine
;
}
return
newEngine
;
}
async
addEnginesFromExtension
(
extension
)
{
LOG
(
"
addEnginesFromExtension
:
"
+
extension
.
id
)
;
try
{
if
(
!
gInitialized
&
&
extension
.
addonData
.
builtIn
&
&
!
this
.
_extensions
.
has
(
extension
.
id
)
)
{
return
[
]
;
}
if
(
!
this
.
_extensions
.
has
(
extension
.
id
)
)
{
LOG
(
"
addEnginesFromExtension
:
User
installed
extension
"
+
extension
.
id
)
;
this
.
_extensions
.
set
(
extension
.
id
new
Map
(
[
[
DEFAULT_TAG
null
]
]
)
)
;
}
let
installLocale
=
async
(
locale
)
=
>
{
let
manifest
=
(
locale
=
=
=
DEFAULT_TAG
)
?
extension
.
manifest
:
(
await
extension
.
getLocalizedManifest
(
locale
)
)
;
return
this
.
_addEngineForManifest
(
extension
manifest
locale
)
;
}
;
let
engines
=
[
]
;
for
(
let
[
locale
installed
]
of
this
.
_extensions
.
get
(
extension
.
id
)
)
{
if
(
installed
!
=
=
true
)
{
LOG
(
"
addEnginesFromExtension
:
installing
locale
:
"
+
extension
.
id
+
"
:
"
+
locale
)
;
engines
.
push
(
await
installLocale
(
locale
)
)
;
}
}
return
engines
;
}
catch
(
err
)
{
LOG
(
"
addEnginesFromExtension
:
Failed
to
install
"
+
extension
.
id
+
"
:
\
"
"
+
err
.
message
+
"
\
"
\
n
"
+
err
.
stack
)
;
return
[
]
;
}
}
async
_addEngineForManifest
(
extension
manifest
locale
=
DEFAULT_TAG
)
{
let
{
IconDetails
}
=
ExtensionParent
;
let
icons
=
extension
.
manifest
.
icons
;
let
iconList
=
[
]
;
if
(
icons
)
{
iconList
=
Object
.
entries
(
icons
)
.
map
(
icon
=
>
{
return
{
width
:
icon
[
0
]
height
:
icon
[
0
]
url
:
extension
.
baseURI
.
resolve
(
icon
[
1
]
)
}
;
}
)
;
}
let
preferredIconUrl
=
icons
&
&
extension
.
baseURI
.
resolve
(
IconDetails
.
getPreferredIcon
(
icons
)
.
icon
)
;
let
searchProvider
=
manifest
.
chrome_settings_overrides
.
search_provider
;
if
(
searchProvider
.
params
)
{
searchProvider
.
params
=
searchProvider
.
params
.
filter
(
param
=
>
{
return
!
(
param
.
value
&
&
param
.
value
.
startsWith
(
"
__MSG_
"
)
)
;
}
)
;
}
let
params
=
{
name
:
searchProvider
.
name
.
trim
(
)
shortName
:
extension
.
id
.
split
(
"
"
)
[
0
]
description
:
extension
.
manifest
.
description
searchForm
:
searchProvider
.
search_form
template
:
searchProvider
.
search_url
searchGetParams
:
searchProvider
.
search_url_get_params
searchPostParams
:
searchProvider
.
search_url_post_params
iconURL
:
searchProvider
.
favicon_url
|
|
preferredIconUrl
icons
:
iconList
alias
:
searchProvider
.
keyword
extensionID
:
extension
.
id
isBuiltin
:
extension
.
addonData
.
builtIn
suggestURL
:
searchProvider
.
suggest_url
suggestPostParams
:
searchProvider
.
suggest_url_post_params
suggestGetParams
:
searchProvider
.
suggest_url_get_params
queryCharset
:
searchProvider
.
encoding
|
|
"
UTF
-
8
"
mozParams
:
searchProvider
.
params
}
;
let
localeMap
=
this
.
_extensions
.
get
(
extension
.
id
)
;
localeMap
.
set
(
locale
params
)
;
this
.
_extensions
.
set
(
extension
.
id
localeMap
)
;
return
this
.
addEngineWithDetails
(
params
.
name
params
)
;
}
async
addEngine
(
engineURL
iconURL
confirm
extensionID
)
{
LOG
(
"
addEngine
:
Adding
\
"
"
+
engineURL
+
"
\
"
.
"
)
;
await
this
.
init
(
true
)
;
let
errCode
;
try
{
var
uri
=
makeURI
(
engineURL
)
;
var
engine
=
new
Engine
(
uri
false
)
;
engine
.
_setIcon
(
iconURL
false
)
;
engine
.
_confirm
=
confirm
;
if
(
extensionID
)
{
engine
.
_extensionID
=
extensionID
;
}
errCode
=
await
new
Promise
(
resolve
=
>
{
engine
.
_installCallback
=
function
(
errorCode
)
{
resolve
(
errorCode
)
;
engine
.
_installCallback
=
null
;
}
;
engine
.
_initFromURIAndLoad
(
uri
)
;
}
)
;
if
(
errCode
)
{
throw
errCode
;
}
}
catch
(
ex
)
{
if
(
engine
)
engine
.
_installCallback
=
null
;
FAIL
(
"
addEngine
:
Error
adding
engine
:
\
n
"
+
ex
errCode
|
|
Cr
.
NS_ERROR_FAILURE
)
;
}
return
engine
;
}
async
removeWebExtensionEngine
(
id
)
{
LOG
(
"
removeWebExtensionEngine
:
"
+
id
)
;
let
localeMap
=
this
.
_extensions
.
get
(
id
)
;
if
(
!
localeMap
)
{
Cu
.
reportError
(
"
Cannot
find
extension
(
"
+
id
+
"
)
to
remove
"
)
;
return
;
}
for
(
let
params
of
localeMap
.
values
(
)
)
{
let
engine
=
await
this
.
getEngineByName
(
params
.
name
)
;
await
this
.
removeEngine
(
engine
)
;
}
this
.
_extensions
.
delete
(
id
)
;
}
async
removeEngine
(
engine
)
{
await
this
.
init
(
true
)
;
if
(
!
engine
)
FAIL
(
"
no
engine
passed
to
removeEngine
!
"
)
;
var
engineToRemove
=
null
;
for
(
var
e
in
this
.
_engines
)
{
if
(
engine
.
wrappedJSObject
=
=
this
.
_engines
[
e
]
)
engineToRemove
=
this
.
_engines
[
e
]
;
}
if
(
!
engineToRemove
)
FAIL
(
"
removeEngine
:
Can
'
t
find
engine
to
remove
!
"
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
;
if
(
engineToRemove
=
=
this
.
defaultEngine
)
{
this
.
_currentEngine
=
null
;
}
if
(
engineToRemove
.
_readOnly
|
|
engineToRemove
.
isBuiltin
)
{
engineToRemove
.
hidden
=
true
;
engineToRemove
.
alias
=
null
;
}
else
{
if
(
engineToRemove
.
_filePath
)
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
persistentDescriptor
=
engineToRemove
.
_filePath
;
if
(
file
.
exists
(
)
)
{
file
.
remove
(
false
)
;
}
engineToRemove
.
_filePath
=
null
;
}
var
index
=
this
.
_sortedEngines
.
indexOf
(
engineToRemove
)
;
if
(
index
=
=
-
1
)
FAIL
(
"
Can
'
t
find
engine
to
remove
in
_sortedEngines
!
"
Cr
.
NS_ERROR_FAILURE
)
;
this
.
__sortedEngines
.
splice
(
index
1
)
;
delete
this
.
_engines
[
engineToRemove
.
name
]
;
this
.
_saveSortedEngineList
(
)
;
}
notifyAction
(
engineToRemove
SEARCH_ENGINE_REMOVED
)
;
}
async
moveEngine
(
engine
newIndex
)
{
await
this
.
init
(
true
)
;
if
(
(
newIndex
>
this
.
_sortedEngines
.
length
)
|
|
(
newIndex
<
0
)
)
FAIL
(
"
moveEngine
:
Index
out
of
bounds
!
"
)
;
if
(
!
(
engine
instanceof
Ci
.
nsISearchEngine
)
&
&
!
(
engine
instanceof
Engine
)
)
FAIL
(
"
moveEngine
:
Invalid
engine
passed
to
moveEngine
!
"
)
;
if
(
engine
.
hidden
)
FAIL
(
"
moveEngine
:
Can
'
t
move
a
hidden
engine
!
"
Cr
.
NS_ERROR_FAILURE
)
;
engine
=
engine
.
wrappedJSObject
;
var
currentIndex
=
this
.
_sortedEngines
.
indexOf
(
engine
)
;
if
(
currentIndex
=
=
-
1
)
FAIL
(
"
moveEngine
:
Can
'
t
find
engine
to
move
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
var
newIndexEngine
=
this
.
_getSortedEngines
(
false
)
[
newIndex
]
;
if
(
!
newIndexEngine
)
FAIL
(
"
moveEngine
:
Can
'
t
find
engine
to
replace
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
for
(
var
i
=
0
;
i
<
this
.
_sortedEngines
.
length
;
+
+
i
)
{
if
(
newIndexEngine
=
=
this
.
_sortedEngines
[
i
]
)
break
;
if
(
this
.
_sortedEngines
[
i
]
.
hidden
)
newIndex
+
+
;
}
if
(
currentIndex
=
=
newIndex
)
return
;
var
movedEngine
=
this
.
__sortedEngines
.
splice
(
currentIndex
1
)
[
0
]
;
this
.
__sortedEngines
.
splice
(
newIndex
0
movedEngine
)
;
notifyAction
(
engine
SEARCH_ENGINE_CHANGED
)
;
this
.
_saveSortedEngineList
(
)
;
}
restoreDefaultEngines
(
)
{
this
.
_ensureInitialized
(
)
;
for
(
let
name
in
this
.
_engines
)
{
let
e
=
this
.
_engines
[
name
]
;
if
(
e
.
hidden
&
&
e
.
_isDefault
)
e
.
hidden
=
false
;
}
}
get
defaultEngine
(
)
{
this
.
_ensureInitialized
(
)
;
if
(
!
this
.
_currentEngine
)
{
let
name
=
this
.
getGlobalAttr
(
"
current
"
)
;
let
engine
=
this
.
getEngineByName
(
name
)
;
if
(
engine
&
&
(
this
.
getGlobalAttr
(
"
hash
"
)
=
=
getVerificationHash
(
name
)
|
|
engine
.
_isDefault
)
)
{
this
.
_currentEngine
=
engine
;
}
if
(
!
name
)
this
.
_currentEngine
=
this
.
originalDefaultEngine
;
}
if
(
!
this
.
_currentEngine
|
|
this
.
_currentEngine
.
hidden
)
{
let
originalDefault
=
this
.
originalDefaultEngine
;
if
(
!
originalDefault
|
|
originalDefault
.
hidden
)
{
let
firstVisible
=
this
.
_getSortedEngines
(
false
)
[
0
]
;
if
(
firstVisible
&
&
!
firstVisible
.
hidden
)
{
this
.
defaultEngine
=
firstVisible
;
return
firstVisible
;
}
if
(
originalDefault
)
originalDefault
.
hidden
=
false
;
}
if
(
!
originalDefault
)
return
null
;
this
.
defaultEngine
=
originalDefault
;
}
return
this
.
_currentEngine
;
}
set
defaultEngine
(
val
)
{
this
.
_ensureInitialized
(
)
;
if
(
!
(
val
instanceof
Ci
.
nsISearchEngine
)
&
&
!
(
val
instanceof
Engine
)
)
FAIL
(
"
Invalid
argument
passed
to
defaultEngine
setter
"
)
;
var
newCurrentEngine
=
this
.
getEngineByName
(
val
.
name
)
;
if
(
!
newCurrentEngine
)
FAIL
(
"
Can
'
t
find
engine
in
store
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
if
(
!
newCurrentEngine
.
_isDefault
)
{
if
(
!
newCurrentEngine
.
_loadPath
)
newCurrentEngine
.
_loadPath
=
"
[
other
]
unknown
"
;
let
loadPathHash
=
getVerificationHash
(
newCurrentEngine
.
_loadPath
)
;
let
currentHash
=
newCurrentEngine
.
getAttr
(
"
loadPathHash
"
)
;
if
(
!
currentHash
|
|
currentHash
!
=
loadPathHash
)
{
newCurrentEngine
.
setAttr
(
"
loadPathHash
"
loadPathHash
)
;
notifyAction
(
newCurrentEngine
SEARCH_ENGINE_CHANGED
)
;
}
}
if
(
newCurrentEngine
=
=
this
.
_currentEngine
)
return
;
this
.
_currentEngine
=
newCurrentEngine
;
let
newName
=
this
.
_currentEngine
.
name
;
if
(
this
.
_currentEngine
=
=
this
.
originalDefaultEngine
)
{
newName
=
"
"
;
}
this
.
setGlobalAttr
(
"
current
"
newName
)
;
this
.
setGlobalAttr
(
"
hash
"
getVerificationHash
(
newName
)
)
;
notifyAction
(
this
.
_currentEngine
SEARCH_ENGINE_DEFAULT
)
;
}
async
getDefault
(
)
{
await
this
.
init
(
true
)
;
return
this
.
defaultEngine
;
}
async
setDefault
(
engine
)
{
await
this
.
init
(
true
)
;
return
this
.
defaultEngine
=
engine
;
}
async
getDefaultEngineInfo
(
)
{
let
result
=
{
}
;
let
engine
;
try
{
engine
=
await
this
.
getDefault
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
getDefaultEngineInfo
:
No
default
engine
"
)
;
}
if
(
!
engine
)
{
result
.
name
=
"
NONE
"
;
}
else
{
if
(
engine
.
name
)
result
.
name
=
engine
.
name
;
result
.
loadPath
=
engine
.
_loadPath
;
let
origin
;
if
(
engine
.
_isDefault
)
{
origin
=
"
default
"
;
}
else
{
let
currentHash
=
engine
.
getAttr
(
"
loadPathHash
"
)
;
if
(
!
currentHash
)
{
origin
=
"
unverified
"
;
}
else
{
let
loadPathHash
=
getVerificationHash
(
engine
.
_loadPath
)
;
origin
=
currentHash
=
=
loadPathHash
?
"
verified
"
:
"
invalid
"
;
}
}
result
.
origin
=
origin
;
let
sendSubmissionURL
=
engine
.
_isDefault
;
if
(
!
sendSubmissionURL
)
{
let
extras
=
Services
.
prefs
.
getChildList
(
BROWSER_SEARCH_PREF
+
"
order
.
extra
.
"
)
;
for
(
let
prefName
of
extras
)
{
try
{
if
(
result
.
name
=
=
Services
.
prefs
.
getCharPref
(
prefName
)
)
{
sendSubmissionURL
=
true
;
break
;
}
}
catch
(
e
)
{
}
}
let
i
=
0
;
while
(
!
sendSubmissionURL
)
{
let
prefName
=
{
BROWSER_SEARCH_PREF
}
order
.
{
+
+
i
}
;
let
engineName
=
getLocalizedPref
(
prefName
)
;
if
(
!
engineName
)
break
;
if
(
result
.
name
=
=
engineName
)
{
sendSubmissionURL
=
true
;
break
;
}
}
for
(
let
engineName
of
this
.
_searchOrder
)
{
if
(
result
.
name
=
=
engineName
)
{
sendSubmissionURL
=
true
;
break
;
}
}
}
if
(
!
sendSubmissionURL
)
{
let
engineHost
=
engine
.
_getURLOfType
(
URLTYPE_SEARCH_HTML
)
.
templateHost
;
for
(
let
name
in
this
.
_engines
)
{
let
innerEngine
=
this
.
_engines
[
name
]
;
if
(
!
innerEngine
.
_isDefault
)
{
continue
;
}
let
innerEngineURL
=
innerEngine
.
_getURLOfType
(
URLTYPE_SEARCH_HTML
)
;
if
(
innerEngineURL
.
templateHost
=
=
engineHost
)
{
sendSubmissionURL
=
true
;
break
;
}
}
if
(
!
sendSubmissionURL
)
{
const
urlTest
=
/
^
(
?
:
www
\
.
google
\
.
|
search
\
.
aol
\
.
|
yandex
\
.
)
|
(
?
:
search
\
.
yahoo
|
\
.
ask
|
\
.
bing
|
\
.
startpage
|
\
.
baidu
|
duckduckgo
)
\
.
com
/
;
sendSubmissionURL
=
urlTest
.
test
(
engineHost
)
;
}
}
if
(
sendSubmissionURL
)
{
let
uri
=
engine
.
_getURLOfType
(
"
text
/
html
"
)
.
getSubmission
(
"
"
engine
"
searchbar
"
)
.
uri
;
uri
=
uri
.
mutate
(
)
.
setUserPass
(
"
"
)
.
finalize
(
)
;
result
.
submissionURL
=
uri
.
spec
;
}
}
return
result
;
}
_parseSubmissionMap
:
null
_buildParseSubmissionMap
(
)
{
this
.
_parseSubmissionMap
=
new
Map
(
)
;
let
keysOfAlternates
=
new
Set
(
)
;
for
(
let
engine
of
this
.
_sortedEngines
)
{
if
(
engine
.
hidden
)
{
continue
;
}
let
urlParsingInfo
=
engine
.
getURLParsingInfo
(
)
;
if
(
!
urlParsingInfo
)
{
continue
;
}
let
mapValueForEngine
=
{
engine
termsParameterName
:
urlParsingInfo
.
termsParameterName
}
;
let
processDomain
=
(
domain
isAlternate
)
=
>
{
let
key
=
domain
+
urlParsingInfo
.
path
;
let
existingEntry
=
this
.
_parseSubmissionMap
.
get
(
key
)
;
if
(
!
existingEntry
)
{
if
(
isAlternate
)
{
keysOfAlternates
.
add
(
key
)
;
}
}
else
if
(
!
isAlternate
&
&
keysOfAlternates
.
has
(
key
)
)
{
keysOfAlternates
.
delete
(
key
)
;
}
else
{
return
;
}
this
.
_parseSubmissionMap
.
set
(
key
mapValueForEngine
)
;
}
;
processDomain
(
urlParsingInfo
.
mainDomain
false
)
;
SearchStaticData
.
getAlternateDomains
(
urlParsingInfo
.
mainDomain
)
.
forEach
(
d
=
>
processDomain
(
d
true
)
)
;
}
}
hasEngineWithURL
(
method
template
formData
)
{
this
.
_ensureInitialized
(
)
;
let
getSortedFormData
=
data
=
>
{
return
data
.
filter
(
a
=
>
a
.
name
&
&
a
.
value
)
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
name
>
b
.
name
)
{
return
1
;
}
else
if
(
b
.
name
>
a
.
name
)
{
return
-
1
;
}
else
if
(
a
.
value
>
b
.
value
)
{
return
1
;
}
return
(
b
.
value
>
a
.
value
)
?
-
1
:
0
;
}
)
;
}
;
let
methodUpper
=
method
.
toUpperCase
(
)
;
let
sortedFormData
=
getSortedFormData
(
formData
)
;
let
sortedFormLength
=
sortedFormData
.
length
;
return
this
.
_getSortedEngines
(
false
)
.
some
(
engine
=
>
{
return
engine
.
_urls
.
some
(
url
=
>
{
if
(
url
.
type
!
=
URLTYPE_SEARCH_HTML
|
|
url
.
method
!
=
methodUpper
|
|
url
.
template
!
=
template
|
|
url
.
params
.
length
!
=
sortedFormLength
)
{
return
false
;
}
let
sortedParams
=
getSortedFormData
(
url
.
params
)
;
for
(
let
i
=
0
;
i
<
sortedFormLength
;
i
+
+
)
{
let
data
=
sortedFormData
[
i
]
;
let
param
=
sortedParams
[
i
]
;
if
(
param
.
name
!
=
data
.
name
|
|
param
.
value
!
=
data
.
value
|
|
param
.
purpose
!
=
data
.
purpose
)
{
return
false
;
}
}
return
true
;
}
)
;
}
)
;
}
parseSubmissionURL
(
url
)
{
if
(
!
gInitialized
)
{
return
gEmptyParseSubmissionResult
;
}
if
(
!
this
.
_parseSubmissionMap
)
{
this
.
_buildParseSubmissionMap
(
)
;
}
let
soughtKey
soughtQuery
;
try
{
let
soughtUrl
=
Services
.
io
.
newURI
(
url
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
if
(
soughtUrl
.
scheme
!
=
"
http
"
&
&
soughtUrl
.
scheme
!
=
"
https
"
)
{
return
gEmptyParseSubmissionResult
;
}
soughtKey
=
soughtUrl
.
host
+
soughtUrl
.
filePath
.
toLowerCase
(
)
;
soughtQuery
=
soughtUrl
.
query
;
}
catch
(
ex
)
{
return
gEmptyParseSubmissionResult
;
}
let
mapEntry
=
this
.
_parseSubmissionMap
.
get
(
soughtKey
)
;
if
(
!
mapEntry
)
{
return
gEmptyParseSubmissionResult
;
}
let
encodedTerms
=
null
;
for
(
let
param
of
soughtQuery
.
split
(
"
&
"
)
)
{
let
equalPos
=
param
.
indexOf
(
"
=
"
)
;
if
(
equalPos
!
=
-
1
&
&
param
.
substr
(
0
equalPos
)
=
=
mapEntry
.
termsParameterName
)
{
encodedTerms
=
param
.
substr
(
equalPos
+
1
)
;
break
;
}
}
if
(
encodedTerms
=
=
=
null
)
{
return
gEmptyParseSubmissionResult
;
}
let
length
=
0
;
let
offset
=
url
.
indexOf
(
"
?
"
)
+
1
;
let
query
=
url
.
slice
(
offset
)
;
for
(
let
param
of
query
.
split
(
"
&
"
)
)
{
let
equalPos
=
param
.
indexOf
(
"
=
"
)
;
if
(
equalPos
!
=
-
1
&
&
param
.
substr
(
0
equalPos
)
=
=
mapEntry
.
termsParameterName
)
{
offset
+
=
equalPos
+
1
;
length
=
param
.
length
-
equalPos
-
1
;
break
;
}
offset
+
=
param
.
length
+
1
;
}
let
terms
;
try
{
terms
=
Services
.
textToSubURI
.
UnEscapeAndConvert
(
mapEntry
.
engine
.
queryCharset
encodedTerms
.
replace
(
/
\
+
/
g
"
"
)
)
;
}
catch
(
ex
)
{
return
gEmptyParseSubmissionResult
;
}
return
new
ParseSubmissionResult
(
mapEntry
.
engine
terms
offset
length
)
;
}
observe
(
engine
topic
verb
)
{
switch
(
topic
)
{
case
SEARCH_ENGINE_TOPIC
:
switch
(
verb
)
{
case
SEARCH_ENGINE_LOADED
:
engine
=
engine
.
QueryInterface
(
Ci
.
nsISearchEngine
)
;
LOG
(
"
nsSearchService
:
:
observe
:
Done
installation
of
"
+
engine
.
name
+
"
.
"
)
;
this
.
_addEngineToStore
(
engine
.
wrappedJSObject
)
;
if
(
engine
.
wrappedJSObject
.
_useNow
)
{
LOG
(
"
nsSearchService
:
:
observe
:
setting
current
"
)
;
this
.
defaultEngine
=
engine
;
}
break
;
case
SEARCH_ENGINE_ADDED
:
case
SEARCH_ENGINE_CHANGED
:
case
SEARCH_ENGINE_REMOVED
:
this
.
batchTask
.
disarm
(
)
;
this
.
batchTask
.
arm
(
)
;
this
.
_parseSubmissionMap
=
null
;
break
;
}
break
;
case
QUIT_APPLICATION_TOPIC
:
this
.
_removeObservers
(
)
;
break
;
case
TOPIC_LOCALES_CHANGE
:
if
(
!
Services
.
startup
.
shuttingDown
)
{
this
.
_reInit
(
verb
)
;
}
break
;
}
}
notify
(
timer
)
{
LOG
(
"
_notify
:
checking
for
updates
"
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
update
"
true
)
)
return
;
var
currentTime
=
Date
.
now
(
)
;
LOG
(
"
currentTime
:
"
+
currentTime
)
;
for
(
let
name
in
this
.
_engines
)
{
let
engine
=
this
.
_engines
[
name
]
.
wrappedJSObject
;
if
(
!
engine
.
_hasUpdates
)
continue
;
LOG
(
"
checking
"
+
engine
.
name
)
;
var
expirTime
=
engine
.
getAttr
(
"
updateexpir
"
)
;
LOG
(
"
expirTime
:
"
+
expirTime
+
"
\
nupdateURL
:
"
+
engine
.
_updateURL
+
"
\
niconUpdateURL
:
"
+
engine
.
_iconUpdateURL
)
;
var
engineExpired
=
expirTime
<
=
currentTime
;
if
(
!
expirTime
|
|
!
engineExpired
)
{
LOG
(
"
skipping
engine
"
)
;
continue
;
}
LOG
(
engine
.
name
+
"
has
expired
"
)
;
engineUpdateService
.
update
(
engine
)
;
engineUpdateService
.
scheduleNextUpdate
(
engine
)
;
}
}
_addObservers
(
)
{
if
(
this
.
_observersAdded
)
{
return
;
}
this
.
_observersAdded
=
true
;
Services
.
obs
.
addObserver
(
this
SEARCH_ENGINE_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
QUIT_APPLICATION_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
TOPIC_LOCALES_CHANGE
)
;
let
shutdownState
=
{
step
:
"
Not
started
"
latestError
:
{
message
:
undefined
stack
:
undefined
}
}
;
OS
.
File
.
profileBeforeChange
.
addBlocker
(
"
Search
service
:
shutting
down
"
(
)
=
>
(
async
(
)
=
>
{
if
(
this
.
_batchTask
)
{
shutdownState
.
step
=
"
Finalizing
batched
task
"
;
try
{
await
this
.
_batchTask
.
finalize
(
)
;
shutdownState
.
step
=
"
Batched
task
finalized
"
;
}
catch
(
ex
)
{
shutdownState
.
step
=
"
Batched
task
failed
to
finalize
"
;
shutdownState
.
latestError
.
message
=
"
"
+
ex
;
if
(
ex
&
&
typeof
ex
=
=
"
object
"
)
{
shutdownState
.
latestError
.
stack
=
ex
.
stack
|
|
undefined
;
}
Promise
.
reject
(
ex
)
;
}
}
}
)
(
)
(
)
=
>
shutdownState
)
;
}
_observersAdded
:
false
_removeObservers
(
)
{
if
(
this
.
_ignoreListListener
)
{
RemoteSettings
(
SETTINGS_IGNORELIST_KEY
)
.
off
(
"
sync
"
this
.
_ignoreListListener
)
;
delete
this
.
_ignoreListListener
;
}
Services
.
obs
.
removeObserver
(
this
SEARCH_ENGINE_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
QUIT_APPLICATION_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
TOPIC_LOCALES_CHANGE
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsISearchService
Ci
.
nsIObserver
Ci
.
nsITimerCallback
]
)
}
;
const
SEARCH_UPDATE_LOG_PREFIX
=
"
*
*
*
Search
update
:
"
;
function
ULOG
(
text
)
{
if
(
Services
.
prefs
.
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
update
.
log
"
false
)
)
{
dump
(
SEARCH_UPDATE_LOG_PREFIX
+
text
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
text
)
;
}
}
var
engineUpdateService
=
{
scheduleNextUpdate
(
engine
)
{
var
interval
=
engine
.
_updateInterval
|
|
SEARCH_DEFAULT_UPDATE_INTERVAL
;
var
milliseconds
=
interval
*
86400000
;
engine
.
setAttr
(
"
updateexpir
"
Date
.
now
(
)
+
milliseconds
)
;
}
update
(
engine
)
{
engine
=
engine
.
wrappedJSObject
;
ULOG
(
"
update
called
for
"
+
engine
.
_name
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
BROWSER_SEARCH_PREF
+
"
update
"
true
)
|
|
!
engine
.
_hasUpdates
)
return
;
let
testEngine
=
null
;
let
updateURL
=
engine
.
_getURLOfType
(
URLTYPE_OPENSEARCH
)
;
let
updateURI
=
(
updateURL
&
&
updateURL
.
_hasRelation
(
"
self
"
)
)
?
updateURL
.
getSubmission
(
"
"
engine
)
.
uri
:
makeURI
(
engine
.
_updateURL
)
;
if
(
updateURI
)
{
if
(
engine
.
_isDefault
&
&
!
updateURI
.
schemeIs
(
"
https
"
)
)
{
ULOG
(
"
Invalid
scheme
for
default
engine
update
"
)
;
return
;
}
ULOG
(
"
updating
"
+
engine
.
name
+
"
from
"
+
updateURI
.
spec
)
;
testEngine
=
new
Engine
(
updateURI
false
)
;
testEngine
.
_engineToUpdate
=
engine
;
testEngine
.
_initFromURIAndLoad
(
updateURI
)
;
}
else
{
ULOG
(
"
invalid
updateURI
"
)
;
}
if
(
engine
.
_iconUpdateURL
)
{
(
testEngine
|
|
engine
)
.
_setIcon
(
engine
.
_iconUpdateURL
true
)
;
}
}
}
;
var
EXPORTED_SYMBOLS
=
[
"
SearchService
"
]
;
