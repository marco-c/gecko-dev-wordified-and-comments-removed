const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AddonSearchEngine
:
"
resource
:
/
/
gre
/
modules
/
AddonSearchEngine
.
jsm
"
IgnoreLists
:
"
resource
:
/
/
gre
/
modules
/
IgnoreLists
.
jsm
"
OpenSearchEngine
:
"
resource
:
/
/
gre
/
modules
/
OpenSearchEngine
.
jsm
"
PolicySearchEngine
:
"
resource
:
/
/
gre
/
modules
/
PolicySearchEngine
.
jsm
"
Region
:
"
resource
:
/
/
gre
/
modules
/
Region
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
SearchEngine
:
"
resource
:
/
/
gre
/
modules
/
SearchEngine
.
jsm
"
SearchEngineSelector
:
"
resource
:
/
/
gre
/
modules
/
SearchEngineSelector
.
jsm
"
SearchSettings
:
"
resource
:
/
/
gre
/
modules
/
SearchSettings
.
jsm
"
SearchStaticData
:
"
resource
:
/
/
gre
/
modules
/
SearchStaticData
.
jsm
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
jsm
"
UserSearchEngine
:
"
resource
:
/
/
gre
/
modules
/
UserSearchEngine
.
jsm
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logConsole
"
(
)
=
>
{
return
console
.
createInstance
(
{
prefix
:
"
SearchService
"
maxLogLevel
:
lazy
.
SearchUtils
.
loggingEnabled
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
const
TOPIC_LOCALES_CHANGE
=
"
intl
:
app
-
locales
-
changed
"
;
const
QUIT_APPLICATION_TOPIC
=
"
quit
-
application
"
;
const
SEARCH_DEFAULT_UPDATE_INTERVAL
=
7
;
const
RECONFIG_IDLE_TIME_SEC
=
5
*
60
;
class
ParseSubmissionResult
{
constructor
(
engine
terms
termsParameterName
termsOffset
termsLength
)
{
this
.
#
engine
=
engine
;
this
.
#
terms
=
terms
;
this
.
#
termsParameterName
=
termsParameterName
;
this
.
#
termsOffset
=
termsOffset
;
this
.
#
termsLength
=
termsLength
;
}
get
engine
(
)
{
return
this
.
#
engine
;
}
get
terms
(
)
{
return
this
.
#
terms
;
}
get
termsParameterName
(
)
{
return
this
.
#
termsParameterName
;
}
get
termsOffset
(
)
{
return
this
.
#
termsOffset
;
}
get
termsLength
(
)
{
return
this
.
#
termsLength
;
}
#
engine
;
#
terms
;
#
termsParameterName
;
#
termsOffset
;
#
termsLength
;
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsISearchParseSubmissionResult
"
]
)
;
}
const
gEmptyParseSubmissionResult
=
Object
.
freeze
(
new
ParseSubmissionResult
(
null
"
"
"
"
-
1
0
)
)
;
class
SearchService
{
constructor
(
)
{
this
.
#
initObservers
=
PromiseUtils
.
defer
(
)
;
this
.
_engines
=
new
Map
(
)
;
this
.
_settings
=
new
lazy
.
SearchSettings
(
this
)
;
}
classID
=
Components
.
ID
(
"
{
7319788a
-
fe93
-
4db3
-
9f39
-
818cf08f4256
}
"
)
;
get
defaultEngine
(
)
{
this
.
#
ensureInitialized
(
)
;
return
this
.
_getEngineDefault
(
false
)
;
}
set
defaultEngine
(
newEngine
)
{
this
.
#
ensureInitialized
(
)
;
this
.
#
setEngineDefault
(
false
newEngine
)
;
}
get
defaultPrivateEngine
(
)
{
this
.
#
ensureInitialized
(
)
;
return
this
.
_getEngineDefault
(
this
.
#
separatePrivateDefault
)
;
}
set
defaultPrivateEngine
(
newEngine
)
{
this
.
#
ensureInitialized
(
)
;
if
(
!
this
.
_separatePrivateDefaultPrefValue
)
{
Services
.
prefs
.
setBoolPref
(
lazy
.
SearchUtils
.
BROWSER_SEARCH_PREF
+
"
separatePrivateDefault
"
true
)
;
}
this
.
#
setEngineDefault
(
this
.
#
separatePrivateDefault
newEngine
)
;
}
async
getDefault
(
)
{
await
this
.
init
(
)
;
return
this
.
defaultEngine
;
}
async
setDefault
(
engine
)
{
await
this
.
init
(
)
;
return
(
this
.
defaultEngine
=
engine
)
;
}
async
getDefaultPrivate
(
)
{
await
this
.
init
(
)
;
return
this
.
defaultPrivateEngine
;
}
async
setDefaultPrivate
(
engine
)
{
await
this
.
init
(
)
;
return
(
this
.
defaultPrivateEngine
=
engine
)
;
}
get
appDefaultEngine
(
)
{
return
this
.
#
appDefaultEngine
(
)
;
}
get
appPrivateDefaultEngine
(
)
{
return
this
.
#
appDefaultEngine
(
this
.
#
separatePrivateDefault
)
;
}
get
isInitialized
(
)
{
return
this
.
_initialized
;
}
getDefaultEngineInfo
(
)
{
let
[
telemetryId
defaultSearchEngineData
]
=
this
.
#
getEngineInfo
(
this
.
defaultEngine
)
;
const
result
=
{
defaultSearchEngine
:
telemetryId
defaultSearchEngineData
}
;
if
(
this
.
#
separatePrivateDefault
)
{
let
[
privateTelemetryId
defaultPrivateSearchEngineData
]
=
this
.
#
getEngineInfo
(
this
.
defaultPrivateEngine
)
;
result
.
defaultPrivateSearchEngine
=
privateTelemetryId
;
result
.
defaultPrivateSearchEngineData
=
defaultPrivateSearchEngineData
;
}
return
result
;
}
getEngineByName
(
engineName
)
{
this
.
#
ensureInitialized
(
)
;
return
this
.
_engines
.
get
(
engineName
)
|
|
null
;
}
async
getEngineByAlias
(
alias
)
{
await
this
.
init
(
)
;
for
(
var
engine
of
this
.
_engines
.
values
(
)
)
{
if
(
engine
&
&
engine
.
aliases
.
includes
(
alias
)
)
{
return
engine
;
}
}
return
null
;
}
async
getEngines
(
)
{
await
this
.
init
(
)
;
lazy
.
logConsole
.
debug
(
"
getEngines
:
getting
all
engines
"
)
;
return
this
.
#
sortedEngines
;
}
async
getVisibleEngines
(
)
{
await
this
.
init
(
true
)
;
lazy
.
logConsole
.
debug
(
"
getVisibleEngines
:
getting
all
visible
engines
"
)
;
return
this
.
#
sortedVisibleEngines
;
}
async
getAppProvidedEngines
(
)
{
await
this
.
init
(
)
;
return
this
.
_sortEnginesByDefaults
(
this
.
#
sortedEngines
.
filter
(
e
=
>
e
.
isAppProvided
)
)
;
}
async
getEnginesByExtensionID
(
extensionID
)
{
await
this
.
init
(
)
;
return
this
.
#
getEnginesByExtensionID
(
extensionID
)
;
}
async
init
(
)
{
lazy
.
logConsole
.
debug
(
"
init
"
)
;
if
(
this
.
#
initStarted
)
{
return
this
.
#
initObservers
.
promise
;
}
TelemetryStopwatch
.
start
(
"
SEARCH_SERVICE_INIT_MS
"
)
;
this
.
#
initStarted
=
true
;
try
{
await
this
.
#
init
(
)
;
TelemetryStopwatch
.
finish
(
"
SEARCH_SERVICE_INIT_MS
"
)
;
}
catch
(
ex
)
{
TelemetryStopwatch
.
cancel
(
"
SEARCH_SERVICE_INIT_MS
"
)
;
this
.
#
initObservers
.
reject
(
ex
.
result
)
;
throw
ex
;
}
if
(
!
Components
.
isSuccessCode
(
this
.
#
initRV
)
)
{
throw
Components
.
Exception
(
"
SearchService
initialization
failed
"
this
.
#
initRV
)
;
}
else
if
(
this
.
#
startupRemovedExtensions
.
size
)
{
Services
.
tm
.
dispatchToMainThread
(
async
(
)
=
>
{
lazy
.
logConsole
.
debug
(
"
Removing
delayed
extension
engines
"
)
;
for
(
let
id
of
this
.
#
startupRemovedExtensions
)
{
for
(
let
engine
of
this
.
#
getEnginesByExtensionID
(
id
)
)
{
if
(
!
engine
.
isAppProvided
)
{
await
this
.
removeEngine
(
engine
)
;
}
}
}
this
.
#
startupRemovedExtensions
.
clear
(
)
;
}
)
;
}
return
this
.
#
initRV
;
}
async
runBackgroundChecks
(
)
{
await
this
.
init
(
)
;
await
this
.
#
migrateLegacyEngines
(
)
;
await
this
.
#
checkWebExtensionEngines
(
)
;
}
reset
(
)
{
this
.
_initialized
=
false
;
this
.
#
initObservers
=
PromiseUtils
.
defer
(
)
;
this
.
#
initStarted
=
false
;
this
.
#
startupExtensions
=
new
Set
(
)
;
this
.
_engines
.
clear
(
)
;
this
.
__sortedEngines
=
null
;
this
.
#
currentEngine
=
null
;
this
.
#
currentPrivateEngine
=
null
;
this
.
_searchDefault
=
null
;
this
.
#
searchPrivateDefault
=
null
;
this
.
#
maybeReloadDebounce
=
false
;
this
.
_settings
.
_batchTask
?
.
disarm
(
)
;
}
resetToAppDefaultEngine
(
)
{
let
appDefaultEngine
=
this
.
appDefaultEngine
;
appDefaultEngine
.
hidden
=
false
;
this
.
defaultEngine
=
appDefaultEngine
;
}
async
maybeSetAndOverrideDefault
(
extension
)
{
let
searchProvider
=
extension
.
manifest
.
chrome_settings_overrides
.
search_provider
;
let
engine
=
this
.
_engines
.
get
(
searchProvider
.
name
)
;
if
(
!
engine
|
|
!
engine
.
isAppProvided
|
|
engine
.
hidden
)
{
return
{
canChangeToAppProvided
:
false
canInstallEngine
:
!
engine
?
.
hidden
}
;
}
if
(
!
this
.
#
defaultOverrideAllowlist
)
{
this
.
#
defaultOverrideAllowlist
=
new
SearchDefaultOverrideAllowlistHandler
(
)
;
}
if
(
extension
.
startupReason
=
=
=
"
ADDON_INSTALL
"
|
|
extension
.
startupReason
=
=
=
"
ADDON_ENABLE
"
)
{
if
(
this
.
defaultEngine
.
name
=
=
searchProvider
.
name
)
{
return
{
canChangeToAppProvided
:
false
canInstallEngine
:
false
}
;
}
if
(
!
(
await
this
.
#
defaultOverrideAllowlist
.
canOverride
(
extension
engine
.
_extensionID
)
)
)
{
lazy
.
logConsole
.
debug
(
"
Allowing
default
engine
to
be
set
to
app
-
provided
.
"
extension
.
id
)
;
return
{
canChangeToAppProvided
:
true
canInstallEngine
:
false
}
;
}
engine
.
overrideWithExtension
(
extension
.
id
extension
.
manifest
)
;
lazy
.
logConsole
.
debug
(
"
Allowing
default
engine
to
be
set
to
app
-
provided
and
overridden
.
"
extension
.
id
)
;
return
{
canChangeToAppProvided
:
true
canInstallEngine
:
false
}
;
}
if
(
engine
.
getAttr
(
"
overriddenBy
"
)
=
=
extension
.
id
&
&
(
await
this
.
#
defaultOverrideAllowlist
.
canOverride
(
extension
engine
.
_extensionID
)
)
)
{
engine
.
overrideWithExtension
(
extension
.
id
extension
.
manifest
)
;
lazy
.
logConsole
.
debug
(
"
Re
-
enabling
overriding
of
core
extension
by
"
extension
.
id
)
;
return
{
canChangeToAppProvided
:
true
canInstallEngine
:
false
}
;
}
return
{
canChangeToAppProvided
:
false
canInstallEngine
:
false
}
;
}
async
addPolicyEngine
(
details
)
{
await
this
.
init
(
)
;
let
newEngine
=
new
lazy
.
PolicySearchEngine
(
{
details
}
)
;
let
existingEngine
=
this
.
_engines
.
get
(
newEngine
.
name
)
;
if
(
existingEngine
)
{
throw
Components
.
Exception
(
"
An
engine
with
that
name
already
exists
!
"
Cr
.
NS_ERROR_FILE_ALREADY_EXISTS
)
;
}
lazy
.
logConsole
.
debug
(
Adding
{
newEngine
.
name
}
)
;
this
.
#
addEngineToStore
(
newEngine
)
;
}
async
updatePolicyEngine
(
details
)
{
let
engine
=
this
.
getEngineByName
(
details
.
name
)
;
if
(
engine
&
&
!
engine
.
isAppProvided
)
{
engine
.
update
(
details
)
;
}
}
async
addUserEngine
(
name
url
alias
)
{
await
this
.
init
(
)
;
let
newEngine
=
new
lazy
.
UserSearchEngine
(
{
details
:
{
name
url
alias
}
}
)
;
let
existingEngine
=
this
.
_engines
.
get
(
newEngine
.
name
)
;
if
(
existingEngine
)
{
throw
Components
.
Exception
(
"
An
engine
with
that
name
already
exists
!
"
Cr
.
NS_ERROR_FILE_ALREADY_EXISTS
)
;
}
lazy
.
logConsole
.
debug
(
Adding
{
newEngine
.
name
}
)
;
this
.
#
addEngineToStore
(
newEngine
)
;
}
async
addEnginesFromExtension
(
extension
)
{
lazy
.
logConsole
.
debug
(
"
addEnginesFromExtension
:
"
+
extension
.
id
)
;
if
(
extension
.
startupReason
=
=
"
ADDON_UPGRADE
"
|
|
extension
.
startupReason
=
=
"
ADDON_DOWNGRADE
"
)
{
let
existing
=
await
this
.
#
upgradeExtensionEngine
(
extension
)
;
if
(
existing
?
.
length
)
{
return
existing
;
}
}
if
(
extension
.
isAppProvided
)
{
if
(
this
.
_initialized
&
&
!
this
.
_reloadingEngines
)
{
let
{
engines
}
=
await
this
.
_fetchEngineSelectorEngines
(
)
;
let
inConfig
=
engines
.
filter
(
el
=
>
el
.
webExtension
.
id
=
=
extension
.
id
)
;
if
(
inConfig
.
length
)
{
return
this
.
#
installExtensionEngine
(
extension
inConfig
.
map
(
el
=
>
el
.
webExtension
.
locale
)
)
;
}
}
lazy
.
logConsole
.
debug
(
"
addEnginesFromExtension
:
Ignoring
builtIn
engine
.
"
)
;
return
[
]
;
}
if
(
!
this
.
_initialized
)
{
this
.
#
startupExtensions
.
add
(
extension
)
;
return
[
]
;
}
return
this
.
#
installExtensionEngine
(
extension
[
lazy
.
SearchUtils
.
DEFAULT_TAG
]
)
;
}
async
addOpenSearchEngine
(
engineURL
iconURL
)
{
lazy
.
logConsole
.
debug
(
"
addEngine
:
Adding
"
engineURL
)
;
await
this
.
init
(
)
;
let
errCode
;
try
{
var
engine
=
new
lazy
.
OpenSearchEngine
(
)
;
engine
.
_setIcon
(
iconURL
false
)
;
errCode
=
await
new
Promise
(
resolve
=
>
{
engine
.
install
(
engineURL
errorCode
=
>
{
resolve
(
errorCode
)
;
}
)
;
}
)
;
if
(
errCode
)
{
throw
errCode
;
}
}
catch
(
ex
)
{
throw
Components
.
Exception
(
"
addEngine
:
Error
adding
engine
:
\
n
"
+
ex
errCode
|
|
Cr
.
NS_ERROR_FAILURE
)
;
}
return
engine
;
}
async
removeWebExtensionEngine
(
id
)
{
if
(
!
this
.
isInitialized
)
{
lazy
.
logConsole
.
debug
(
"
Delaying
removing
extension
engine
on
startup
:
"
id
)
;
this
.
#
startupRemovedExtensions
.
add
(
id
)
;
return
;
}
lazy
.
logConsole
.
debug
(
"
removeWebExtensionEngine
:
"
id
)
;
for
(
let
engine
of
this
.
#
getEnginesByExtensionID
(
id
)
)
{
await
this
.
removeEngine
(
engine
)
;
}
}
async
removeEngine
(
engine
)
{
await
this
.
init
(
)
;
if
(
!
engine
)
{
throw
Components
.
Exception
(
"
no
engine
passed
to
removeEngine
!
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
var
engineToRemove
=
null
;
for
(
var
e
of
this
.
_engines
.
values
(
)
)
{
if
(
engine
.
wrappedJSObject
=
=
e
)
{
engineToRemove
=
e
;
}
}
if
(
!
engineToRemove
)
{
throw
Components
.
Exception
(
"
removeEngine
:
Can
'
t
find
engine
to
remove
!
"
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
;
}
if
(
engineToRemove
=
=
this
.
defaultEngine
)
{
this
.
#
findAndSetNewDefaultEngine
(
{
privateMode
:
false
excludeEngineName
:
engineToRemove
.
name
}
)
;
}
if
(
this
.
#
separatePrivateDefault
&
&
engineToRemove
=
=
this
.
defaultPrivateEngine
)
{
this
.
#
findAndSetNewDefaultEngine
(
{
privateMode
:
true
excludeEngineName
:
engineToRemove
.
name
}
)
;
}
if
(
engineToRemove
.
_isAppProvided
)
{
engineToRemove
.
hidden
=
true
;
engineToRemove
.
alias
=
null
;
}
else
{
if
(
engineToRemove
.
_filePath
)
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
persistentDescriptor
=
engineToRemove
.
_filePath
;
if
(
file
.
exists
(
)
)
{
file
.
remove
(
false
)
;
}
engineToRemove
.
_filePath
=
null
;
}
this
.
#
internalRemoveEngine
(
engineToRemove
)
;
if
(
!
this
.
#
dontSetUseSavedOrder
)
{
this
.
#
saveSortedEngineList
(
)
;
}
}
lazy
.
SearchUtils
.
notifyAction
(
engineToRemove
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
REMOVED
)
;
}
async
moveEngine
(
engine
newIndex
)
{
await
this
.
init
(
)
;
if
(
newIndex
>
this
.
#
sortedEngines
.
length
|
|
newIndex
<
0
)
{
throw
Components
.
Exception
(
"
moveEngine
:
Index
out
of
bounds
!
"
)
;
}
if
(
!
(
engine
instanceof
Ci
.
nsISearchEngine
)
&
&
!
(
engine
instanceof
lazy
.
SearchEngine
)
)
{
throw
Components
.
Exception
(
"
moveEngine
:
Invalid
engine
passed
to
moveEngine
!
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
engine
.
hidden
)
{
throw
Components
.
Exception
(
"
moveEngine
:
Can
'
t
move
a
hidden
engine
!
"
Cr
.
NS_ERROR_FAILURE
)
;
}
engine
=
engine
.
wrappedJSObject
;
var
currentIndex
=
this
.
#
sortedEngines
.
indexOf
(
engine
)
;
if
(
currentIndex
=
=
-
1
)
{
throw
Components
.
Exception
(
"
moveEngine
:
Can
'
t
find
engine
to
move
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
var
newIndexEngine
=
this
.
#
sortedVisibleEngines
[
newIndex
]
;
if
(
!
newIndexEngine
)
{
throw
Components
.
Exception
(
"
moveEngine
:
Can
'
t
find
engine
to
replace
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
for
(
var
i
=
0
;
i
<
this
.
#
sortedEngines
.
length
;
+
+
i
)
{
if
(
newIndexEngine
=
=
this
.
#
sortedEngines
[
i
]
)
{
break
;
}
if
(
this
.
#
sortedEngines
[
i
]
.
hidden
)
{
newIndex
+
+
;
}
}
if
(
currentIndex
=
=
newIndex
)
{
return
;
}
var
movedEngine
=
this
.
__sortedEngines
.
splice
(
currentIndex
1
)
[
0
]
;
this
.
__sortedEngines
.
splice
(
newIndex
0
movedEngine
)
;
lazy
.
SearchUtils
.
notifyAction
(
engine
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
CHANGED
)
;
this
.
#
saveSortedEngineList
(
)
;
}
restoreDefaultEngines
(
)
{
this
.
#
ensureInitialized
(
)
;
for
(
let
e
of
this
.
_engines
.
values
(
)
)
{
if
(
e
.
hidden
&
&
e
.
isAppProvided
)
{
e
.
hidden
=
false
;
}
}
}
parseSubmissionURL
(
url
)
{
if
(
!
this
.
_initialized
)
{
return
gEmptyParseSubmissionResult
;
}
if
(
!
this
.
#
parseSubmissionMap
)
{
this
.
#
buildParseSubmissionMap
(
)
;
}
let
soughtKey
soughtQuery
;
try
{
let
soughtUrl
=
Services
.
io
.
newURI
(
url
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
if
(
soughtUrl
.
scheme
!
=
"
http
"
&
&
soughtUrl
.
scheme
!
=
"
https
"
)
{
return
gEmptyParseSubmissionResult
;
}
soughtKey
=
soughtUrl
.
host
+
soughtUrl
.
filePath
.
toLowerCase
(
)
;
soughtQuery
=
soughtUrl
.
query
;
}
catch
(
ex
)
{
return
gEmptyParseSubmissionResult
;
}
let
mapEntry
=
this
.
#
parseSubmissionMap
.
get
(
soughtKey
)
;
if
(
!
mapEntry
)
{
return
gEmptyParseSubmissionResult
;
}
let
encodedTerms
=
null
;
for
(
let
param
of
soughtQuery
.
split
(
"
&
"
)
)
{
let
equalPos
=
param
.
indexOf
(
"
=
"
)
;
if
(
equalPos
!
=
-
1
&
&
param
.
substr
(
0
equalPos
)
=
=
mapEntry
.
termsParameterName
)
{
encodedTerms
=
param
.
substr
(
equalPos
+
1
)
;
break
;
}
}
if
(
encodedTerms
=
=
=
null
)
{
return
gEmptyParseSubmissionResult
;
}
let
length
=
0
;
let
offset
=
url
.
indexOf
(
"
?
"
)
+
1
;
let
query
=
url
.
slice
(
offset
)
;
for
(
let
param
of
query
.
split
(
"
&
"
)
)
{
let
equalPos
=
param
.
indexOf
(
"
=
"
)
;
if
(
equalPos
!
=
-
1
&
&
param
.
substr
(
0
equalPos
)
=
=
mapEntry
.
termsParameterName
)
{
offset
+
=
equalPos
+
1
;
length
=
param
.
length
-
equalPos
-
1
;
break
;
}
offset
+
=
param
.
length
+
1
;
}
let
terms
;
try
{
terms
=
Services
.
textToSubURI
.
UnEscapeAndConvert
(
mapEntry
.
engine
.
queryCharset
encodedTerms
.
replace
(
/
\
+
/
g
"
"
)
)
;
}
catch
(
ex
)
{
return
gEmptyParseSubmissionResult
;
}
let
submission
=
new
ParseSubmissionResult
(
mapEntry
.
engine
terms
mapEntry
.
termsParameterName
offset
length
)
;
return
submission
;
}
notify
(
timer
)
{
lazy
.
logConsole
.
debug
(
"
notify
:
checking
for
updates
"
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
lazy
.
SearchUtils
.
BROWSER_SEARCH_PREF
+
"
update
"
true
)
)
{
return
;
}
var
currentTime
=
Date
.
now
(
)
;
lazy
.
logConsole
.
debug
(
"
currentTime
:
"
+
currentTime
)
;
for
(
let
e
of
this
.
_engines
.
values
(
)
)
{
let
engine
=
e
.
wrappedJSObject
;
if
(
!
engine
.
_hasUpdates
)
{
continue
;
}
var
expirTime
=
engine
.
getAttr
(
"
updateexpir
"
)
;
lazy
.
logConsole
.
debug
(
engine
.
name
"
expirTime
:
"
expirTime
"
updateURL
:
"
engine
.
_updateURL
"
iconUpdateURL
:
"
engine
.
_iconUpdateURL
)
;
var
engineExpired
=
expirTime
<
=
currentTime
;
if
(
!
expirTime
|
|
!
engineExpired
)
{
lazy
.
logConsole
.
debug
(
"
skipping
engine
"
)
;
continue
;
}
lazy
.
logConsole
.
debug
(
engine
.
name
"
has
expired
"
)
;
engineUpdateService
.
update
(
engine
)
;
engineUpdateService
.
scheduleNextUpdate
(
engine
)
;
}
}
#
initObservers
;
#
currentEngine
;
#
currentPrivateEngine
;
#
queuedIdle
;
#
initRV
=
Cr
.
NS_OK
;
#
initStarted
=
false
;
_initialized
=
false
;
#
maybeReloadDebounce
=
false
;
_reloadingEngines
=
false
;
#
engineSelector
=
null
;
#
submissionURLIgnoreList
=
[
]
;
#
loadPathIgnoreList
=
[
]
;
_engines
=
null
;
__sortedEngines
=
null
;
#
dontSetUseSavedOrder
=
false
;
_searchDefault
=
null
;
#
searchPrivateDefault
=
null
;
#
startupExtensions
=
new
Set
(
)
;
#
startupRemovedExtensions
=
new
Set
(
)
;
#
defaultOverrideAllowlist
=
null
;
#
parseSubmissionMap
=
null
;
#
observersAdded
=
false
;
get
#
sortedEngines
(
)
{
if
(
!
this
.
__sortedEngines
)
{
return
this
.
#
buildSortedEngineList
(
)
;
}
return
this
.
__sortedEngines
;
}
get
#
separatePrivateDefault
(
)
{
return
(
this
.
_separatePrivateDefaultPrefValue
&
&
this
.
_separatePrivateDefaultEnabledPrefValue
)
;
}
#
getEnginesByExtensionID
(
extensionID
)
{
lazy
.
logConsole
.
debug
(
"
getEngines
:
getting
all
engines
for
"
extensionID
)
;
var
engines
=
this
.
#
sortedEngines
.
filter
(
function
(
engine
)
{
return
engine
.
_extensionID
=
=
extensionID
;
}
)
;
return
engines
;
}
#
getEngineByWebExtensionDetails
(
details
)
{
for
(
const
engine
of
this
.
_engines
.
values
(
)
)
{
if
(
engine
.
_extensionID
=
=
details
.
id
&
&
engine
.
_locale
=
=
details
.
locale
)
{
return
engine
;
}
}
return
null
;
}
_getEngineDefault
(
privateMode
)
{
let
currentEngine
=
privateMode
?
this
.
#
currentPrivateEngine
:
this
.
#
currentEngine
;
if
(
currentEngine
&
&
!
currentEngine
.
hidden
)
{
return
currentEngine
;
}
const
attributeName
=
privateMode
?
"
private
"
:
"
current
"
;
let
name
=
this
.
_settings
.
getAttribute
(
attributeName
)
;
let
engine
=
this
.
_engines
.
get
(
name
)
|
|
null
;
if
(
engine
&
&
(
engine
.
isAppProvided
|
|
this
.
_settings
.
getVerifiedAttribute
(
attributeName
)
)
)
{
if
(
privateMode
)
{
this
.
#
currentPrivateEngine
=
engine
;
}
else
{
this
.
#
currentEngine
=
engine
;
}
}
if
(
!
name
)
{
if
(
privateMode
)
{
this
.
#
currentPrivateEngine
=
this
.
appPrivateDefaultEngine
;
}
else
{
this
.
#
currentEngine
=
this
.
appDefaultEngine
;
}
}
currentEngine
=
privateMode
?
this
.
#
currentPrivateEngine
:
this
.
#
currentEngine
;
if
(
currentEngine
&
&
!
currentEngine
.
hidden
)
{
return
currentEngine
;
}
return
this
.
#
findAndSetNewDefaultEngine
(
{
privateMode
}
)
;
}
#
ensureInitialized
(
)
{
if
(
this
.
_initialized
)
{
if
(
!
Components
.
isSuccessCode
(
this
.
#
initRV
)
)
{
lazy
.
logConsole
.
debug
(
"
#
ensureInitialized
:
failure
"
)
;
throw
Components
.
Exception
(
"
SearchService
previously
failed
to
initialize
"
this
.
#
initRV
)
;
}
return
;
}
let
err
=
new
Error
(
"
Something
tried
to
use
the
search
service
before
it
'
s
been
"
+
"
properly
intialized
.
Please
examine
the
stack
trace
to
figure
out
what
and
"
+
"
where
to
fix
it
:
\
n
"
)
;
err
.
message
+
=
err
.
stack
;
throw
err
;
}
async
#
init
(
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_separatePrivateDefaultPrefValue
"
lazy
.
SearchUtils
.
BROWSER_SEARCH_PREF
+
"
separatePrivateDefault
"
false
this
.
#
onSeparateDefaultPrefChanged
.
bind
(
this
)
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_separatePrivateDefaultEnabledPrefValue
"
lazy
.
SearchUtils
.
BROWSER_SEARCH_PREF
+
"
separatePrivateDefault
.
ui
.
enabled
"
false
this
.
#
onSeparateDefaultPrefChanged
.
bind
(
this
)
)
;
Services
.
obs
.
addObserver
(
this
lazy
.
Region
.
REGION_TOPIC
)
;
try
{
this
.
#
engineSelector
=
new
lazy
.
SearchEngineSelector
(
this
.
#
handleConfigurationUpdated
.
bind
(
this
)
)
;
let
settings
=
await
this
.
_settings
.
get
(
)
;
this
.
#
setupRemoteSettings
(
)
.
catch
(
Cu
.
reportError
)
;
await
this
.
#
loadEngines
(
settings
)
;
if
(
Services
.
startup
.
shuttingDown
)
{
lazy
.
logConsole
.
warn
(
"
#
init
:
abandoning
init
due
to
shutting
down
"
)
;
this
.
#
initRV
=
Cr
.
NS_ERROR_ABORT
;
this
.
#
initObservers
.
reject
(
this
.
#
initRV
)
;
return
this
.
#
initRV
;
}
lazy
.
logConsole
.
debug
(
"
#
init
:
engines
loaded
writing
settings
"
)
;
this
.
#
addObservers
(
)
;
}
catch
(
ex
)
{
this
.
#
initRV
=
ex
.
result
!
=
=
undefined
?
ex
.
result
:
Cr
.
NS_ERROR_FAILURE
;
lazy
.
logConsole
.
error
(
"
#
init
:
failure
initializing
search
:
"
ex
)
;
}
this
.
_initialized
=
true
;
if
(
Components
.
isSuccessCode
(
this
.
#
initRV
)
)
{
this
.
#
initObservers
.
resolve
(
this
.
#
initRV
)
;
}
else
{
this
.
#
initObservers
.
reject
(
this
.
#
initRV
)
;
}
this
.
#
recordTelemetryData
(
)
;
Services
.
obs
.
notifyObservers
(
null
lazy
.
SearchUtils
.
TOPIC_SEARCH_SERVICE
"
init
-
complete
"
)
;
lazy
.
logConsole
.
debug
(
"
Completed
#
init
"
)
;
return
this
.
#
initRV
;
}
async
#
setupRemoteSettings
(
)
{
let
listener
=
this
.
#
handleIgnoreListUpdated
.
bind
(
this
)
;
const
current
=
await
lazy
.
IgnoreLists
.
getAndSubscribe
(
listener
)
;
this
.
ignoreListListener
=
listener
;
await
this
.
#
handleIgnoreListUpdated
(
{
data
:
{
current
}
}
)
;
Services
.
obs
.
notifyObservers
(
null
lazy
.
SearchUtils
.
TOPIC_SEARCH_SERVICE
"
settings
-
update
-
complete
"
)
;
}
async
#
handleIgnoreListUpdated
(
eventData
)
{
lazy
.
logConsole
.
debug
(
"
#
handleIgnoreListUpdated
"
)
;
const
{
data
:
{
current
}
}
=
eventData
;
for
(
const
entry
of
current
)
{
if
(
entry
.
id
=
=
"
load
-
paths
"
)
{
this
.
#
loadPathIgnoreList
=
[
.
.
.
entry
.
matches
]
;
}
else
if
(
entry
.
id
=
=
"
submission
-
urls
"
)
{
this
.
#
submissionURLIgnoreList
=
[
.
.
.
entry
.
matches
]
;
}
}
if
(
!
this
.
isInitialized
)
{
await
this
.
#
initObservers
;
}
let
engineRemoved
=
false
;
for
(
let
engine
of
this
.
_engines
.
values
(
)
)
{
if
(
this
.
#
engineMatchesIgnoreLists
(
engine
)
)
{
await
this
.
removeEngine
(
engine
)
;
engineRemoved
=
true
;
}
}
if
(
engineRemoved
&
&
!
this
.
_engines
.
size
)
{
this
.
_maybeReloadEngines
(
)
.
catch
(
Cu
.
reportError
)
;
}
}
#
engineMatchesIgnoreLists
(
engine
)
{
if
(
this
.
#
loadPathIgnoreList
.
includes
(
engine
.
_loadPath
)
)
{
return
true
;
}
let
url
=
engine
.
_getURLOfType
(
"
text
/
html
"
)
.
getSubmission
(
"
dummy
"
engine
)
.
uri
.
spec
.
toLowerCase
(
)
;
if
(
this
.
#
submissionURLIgnoreList
.
some
(
code
=
>
url
.
includes
(
code
.
toLowerCase
(
)
)
)
)
{
return
true
;
}
return
false
;
}
#
handleConfigurationUpdated
(
)
{
if
(
this
.
#
queuedIdle
)
{
return
;
}
this
.
#
queuedIdle
=
true
;
this
.
idleService
.
addIdleObserver
(
this
RECONFIG_IDLE_TIME_SEC
)
;
}
#
appDefaultEngine
(
privateMode
=
false
)
{
let
defaultEngine
=
this
.
#
getEngineByWebExtensionDetails
(
privateMode
&
&
this
.
#
searchPrivateDefault
?
this
.
#
searchPrivateDefault
:
this
.
_searchDefault
)
;
if
(
defaultEngine
)
{
return
defaultEngine
;
}
if
(
privateMode
)
{
return
this
.
#
appDefaultEngine
(
false
)
;
}
return
this
.
#
sortedVisibleEngines
[
0
]
;
}
async
#
loadEngines
(
settings
)
{
let
prevMetaData
=
{
.
.
.
settings
?
.
metaData
}
;
let
prevCurrentEngine
=
prevMetaData
.
current
;
let
prevAppDefaultEngine
=
prevMetaData
?
.
appDefaultEngine
;
lazy
.
logConsole
.
debug
(
"
#
loadEngines
:
start
"
)
;
let
{
engines
privateDefault
}
=
await
this
.
_fetchEngineSelectorEngines
(
)
;
this
.
#
setDefaultAndOrdersFromSelector
(
engines
privateDefault
)
;
await
lazy
.
AddonManager
.
readyPromise
;
let
newEngines
=
await
this
.
#
loadEnginesFromConfig
(
engines
)
;
for
(
let
engine
of
newEngines
)
{
this
.
#
addEngineToStore
(
engine
)
;
}
lazy
.
logConsole
.
debug
(
"
#
loadEngines
:
loading
"
this
.
#
startupExtensions
.
size
"
engines
reported
by
AddonManager
startup
"
)
;
for
(
let
extension
of
this
.
#
startupExtensions
)
{
await
this
.
#
installExtensionEngine
(
extension
[
lazy
.
SearchUtils
.
DEFAULT_TAG
]
true
)
;
}
this
.
#
startupExtensions
.
clear
(
)
;
this
.
#
loadEnginesFromSettings
(
settings
.
engines
)
;
this
.
#
loadEnginesMetadataFromSettings
(
settings
.
engines
)
;
lazy
.
logConsole
.
debug
(
"
#
loadEngines
:
done
"
)
;
let
newCurrentEngine
=
this
.
_getEngineDefault
(
false
)
?
.
name
;
this
.
_settings
.
setAttribute
(
"
appDefaultEngine
"
this
.
appDefaultEngine
?
.
name
)
;
if
(
this
.
#
shouldDisplayRemovalOfEngineNotificationBox
(
settings
prevMetaData
newCurrentEngine
prevCurrentEngine
prevAppDefaultEngine
)
)
{
this
.
_showRemovalOfSearchEngineNotificationBox
(
prevCurrentEngine
|
|
prevAppDefaultEngine
newCurrentEngine
)
;
}
}
#
shouldDisplayRemovalOfEngineNotificationBox
(
settings
prevMetaData
newCurrentEngine
prevCurrentEngine
prevAppDefaultEngine
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
search
.
removeEngineInfobar
.
enabled
"
)
)
{
return
false
;
}
if
(
!
newCurrentEngine
)
{
return
false
;
}
if
(
(
prevCurrentEngine
&
&
prevCurrentEngine
!
=
=
newCurrentEngine
)
|
|
(
!
prevCurrentEngine
&
&
prevAppDefaultEngine
&
&
prevAppDefaultEngine
!
=
=
newCurrentEngine
)
)
{
if
(
!
this
.
#
didSettingsMetaDataUpdate
(
prevMetaData
)
)
{
return
true
;
}
}
return
false
;
}
async
#
loadEnginesFromConfig
(
engineConfigs
)
{
lazy
.
logConsole
.
debug
(
"
#
loadEnginesFromConfig
"
)
;
let
engines
=
[
]
;
for
(
let
config
of
engineConfigs
)
{
try
{
let
engine
=
await
this
.
_makeEngineFromConfig
(
config
)
;
engines
.
push
(
engine
)
;
}
catch
(
ex
)
{
console
.
error
(
Could
not
load
engine
{
"
webExtension
"
in
config
?
config
.
webExtension
.
id
:
"
unknown
"
}
:
{
ex
}
)
;
}
}
return
engines
;
}
async
_maybeReloadEngines
(
)
{
if
(
this
.
#
maybeReloadDebounce
)
{
lazy
.
logConsole
.
debug
(
"
We
'
re
already
waiting
to
reload
engines
.
"
)
;
return
;
}
if
(
!
this
.
_initialized
|
|
this
.
_reloadingEngines
)
{
this
.
#
maybeReloadDebounce
=
true
;
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
if
(
!
this
.
#
maybeReloadDebounce
)
{
return
;
}
this
.
#
maybeReloadDebounce
=
false
;
this
.
_maybeReloadEngines
(
)
.
catch
(
Cu
.
reportError
)
;
}
10000
)
;
lazy
.
logConsole
.
debug
(
"
Post
-
poning
maybeReloadEngines
(
)
as
we
'
re
currently
initializing
.
"
)
;
return
;
}
let
settings
=
await
this
.
_settings
.
get
(
)
;
lazy
.
logConsole
.
debug
(
"
Running
maybeReloadEngines
"
)
;
this
.
_reloadingEngines
=
true
;
try
{
await
this
.
_reloadEngines
(
settings
)
;
}
catch
(
ex
)
{
lazy
.
logConsole
.
error
(
"
maybeReloadEngines
failed
"
ex
)
;
}
this
.
_reloadingEngines
=
false
;
lazy
.
logConsole
.
debug
(
"
maybeReloadEngines
complete
"
)
;
}
async
_reloadEngines
(
settings
)
{
let
prevCurrentEngine
=
this
.
#
currentEngine
;
let
prevPrivateEngine
=
this
.
#
currentPrivateEngine
;
let
prevMetaData
=
{
.
.
.
settings
?
.
metaData
}
;
this
.
#
dontSetUseSavedOrder
=
true
;
let
{
engines
:
appDefaultConfigEngines
privateDefault
}
=
await
this
.
_fetchEngineSelectorEngines
(
)
;
let
enginesToRemove
=
[
]
;
let
configEngines
=
[
.
.
.
appDefaultConfigEngines
]
;
let
oldEngineList
=
[
.
.
.
this
.
_engines
.
values
(
)
]
;
for
(
let
engine
of
oldEngineList
)
{
if
(
!
engine
.
isAppProvided
)
{
continue
;
}
let
index
=
configEngines
.
findIndex
(
e
=
>
e
.
webExtension
.
id
=
=
engine
.
_extensionID
&
&
e
.
webExtension
.
locale
=
=
engine
.
_locale
)
;
let
policy
manifest
locale
;
if
(
index
=
=
-
1
)
{
let
replacementEngines
=
configEngines
.
filter
(
e
=
>
e
.
webExtension
.
id
=
=
engine
.
_extensionID
)
;
if
(
replacementEngines
.
length
!
=
1
)
{
enginesToRemove
.
push
(
engine
)
;
continue
;
}
policy
=
await
this
.
#
getExtensionPolicy
(
engine
.
_extensionID
)
;
locale
=
replacementEngines
[
0
]
.
webExtension
.
locale
|
|
lazy
.
SearchUtils
.
DEFAULT_TAG
;
manifest
=
await
this
.
#
getManifestForLocale
(
policy
.
extension
locale
)
;
if
(
engine
.
name
!
=
manifest
.
chrome_settings_overrides
.
search_provider
.
name
.
trim
(
)
)
{
enginesToRemove
.
push
(
engine
)
;
continue
;
}
index
=
configEngines
.
findIndex
(
e
=
>
e
.
webExtension
.
id
=
=
replacementEngines
[
0
]
.
webExtension
.
id
&
&
e
.
webExtension
.
locale
=
=
replacementEngines
[
0
]
.
webExtension
.
locale
)
;
}
else
{
policy
=
await
this
.
#
getExtensionPolicy
(
engine
.
_extensionID
)
;
locale
=
engine
.
_locale
;
manifest
=
await
this
.
#
getManifestForLocale
(
policy
.
extension
locale
)
;
}
engine
.
updateFromManifest
(
policy
.
extension
.
id
policy
.
extension
.
baseURI
manifest
locale
configEngines
[
index
]
)
;
configEngines
.
splice
(
index
1
)
;
}
for
(
let
engine
of
configEngines
)
{
try
{
let
newEngine
=
await
this
.
_makeEngineFromConfig
(
engine
)
;
this
.
#
addEngineToStore
(
newEngine
true
)
;
}
catch
(
ex
)
{
lazy
.
logConsole
.
warn
(
Could
not
load
engine
{
"
webExtension
"
in
engine
?
engine
.
webExtension
.
id
:
"
unknown
"
}
:
{
ex
}
)
;
}
}
this
.
#
loadEnginesMetadataFromSettings
(
settings
.
engines
)
;
this
.
#
currentEngine
=
null
;
this
.
#
currentPrivateEngine
=
null
;
if
(
prevCurrentEngine
&
&
enginesToRemove
.
some
(
e
=
>
e
.
name
=
=
prevCurrentEngine
.
name
)
)
{
this
.
_settings
.
setAttribute
(
"
current
"
"
"
)
;
}
if
(
prevPrivateEngine
&
&
enginesToRemove
.
some
(
e
=
>
e
.
name
=
=
prevPrivateEngine
.
name
)
)
{
this
.
_settings
.
setAttribute
(
"
private
"
"
"
)
;
}
this
.
#
setDefaultAndOrdersFromSelector
(
appDefaultConfigEngines
privateDefault
)
;
if
(
prevCurrentEngine
&
&
this
.
defaultEngine
!
=
=
prevCurrentEngine
)
{
lazy
.
SearchUtils
.
notifyAction
(
this
.
#
currentEngine
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
DEFAULT
)
;
if
(
!
this
.
#
separatePrivateDefault
)
{
lazy
.
SearchUtils
.
notifyAction
(
this
.
#
currentEngine
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
DEFAULT_PRIVATE
)
;
}
if
(
prevMetaData
&
&
settings
.
metaData
&
&
!
this
.
#
didSettingsMetaDataUpdate
(
prevMetaData
)
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
search
.
removeEngineInfobar
.
enabled
"
)
)
{
this
.
_showRemovalOfSearchEngineNotificationBox
(
prevCurrentEngine
.
name
this
.
defaultEngine
.
name
)
;
}
}
if
(
this
.
#
separatePrivateDefault
&
&
prevPrivateEngine
&
&
this
.
defaultPrivateEngine
!
=
=
prevPrivateEngine
)
{
lazy
.
SearchUtils
.
notifyAction
(
this
.
#
currentPrivateEngine
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
DEFAULT_PRIVATE
)
;
}
for
(
let
engine
of
enginesToRemove
)
{
let
inUseEngines
=
[
.
.
.
this
.
_engines
.
values
(
)
]
.
filter
(
e
=
>
e
.
_extensionID
=
=
engine
.
_extensionID
)
;
if
(
inUseEngines
.
length
<
=
1
)
{
if
(
inUseEngines
.
length
=
=
1
&
&
inUseEngines
[
0
]
=
=
engine
)
{
this
.
#
internalRemoveEngine
(
engine
)
;
let
addon
=
await
lazy
.
AddonManager
.
getAddonByID
(
engine
.
_extensionID
)
;
if
(
addon
)
{
await
addon
.
uninstall
(
)
;
}
}
}
else
{
this
.
#
internalRemoveEngine
(
engine
)
;
}
lazy
.
SearchUtils
.
notifyAction
(
engine
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
REMOVED
)
;
}
this
.
_settings
.
setAttribute
(
"
appDefaultEngine
"
this
.
appDefaultEngine
?
.
name
)
;
this
.
#
dontSetUseSavedOrder
=
false
;
this
.
__sortedEngines
=
null
;
Services
.
obs
.
notifyObservers
(
null
lazy
.
SearchUtils
.
TOPIC_SEARCH_SERVICE
"
engines
-
reloaded
"
)
;
}
#
addEngineToStore
(
engine
skipDuplicateCheck
=
false
)
{
if
(
this
.
#
engineMatchesIgnoreLists
(
engine
)
)
{
lazy
.
logConsole
.
debug
(
"
#
addEngineToStore
:
Ignoring
engine
"
)
;
return
;
}
lazy
.
logConsole
.
debug
(
"
#
addEngineToStore
:
Adding
engine
:
"
engine
.
name
)
;
var
hasSameNameAsUpdate
=
engine
.
_engineToUpdate
&
&
engine
.
name
=
=
engine
.
_engineToUpdate
.
name
;
if
(
!
skipDuplicateCheck
&
&
this
.
_engines
.
has
(
engine
.
name
)
&
&
!
hasSameNameAsUpdate
)
{
lazy
.
logConsole
.
debug
(
"
#
addEngineToStore
:
Duplicate
engine
found
aborting
!
"
)
;
return
;
}
if
(
engine
.
_engineToUpdate
)
{
var
oldEngine
=
engine
.
_engineToUpdate
;
this
.
_engines
.
delete
(
oldEngine
.
name
)
;
for
(
var
p
in
engine
)
{
if
(
!
(
engine
.
__lookupGetter__
(
p
)
|
|
engine
.
__lookupSetter__
(
p
)
)
)
{
oldEngine
[
p
]
=
engine
[
p
]
;
}
}
engine
=
oldEngine
;
engine
.
_engineToUpdate
=
null
;
this
.
_engines
.
set
(
engine
.
name
engine
)
;
lazy
.
SearchUtils
.
notifyAction
(
engine
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
CHANGED
)
;
}
else
{
this
.
_engines
.
set
(
engine
.
name
engine
)
;
if
(
this
.
__sortedEngines
&
&
!
this
.
#
dontSetUseSavedOrder
)
{
this
.
__sortedEngines
.
push
(
engine
)
;
this
.
#
saveSortedEngineList
(
)
;
}
lazy
.
SearchUtils
.
notifyAction
(
engine
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
ADDED
)
;
}
engine
.
_engineAddedToStore
=
true
;
if
(
engine
.
_hasUpdates
)
{
if
(
!
engine
.
getAttr
(
"
updateexpir
"
)
)
{
engineUpdateService
.
scheduleNextUpdate
(
engine
)
;
}
}
}
#
loadEnginesMetadataFromSettings
(
engines
)
{
if
(
!
engines
)
{
return
;
}
for
(
let
engine
of
engines
)
{
let
name
=
engine
.
_name
;
if
(
this
.
_engines
.
has
(
name
)
)
{
lazy
.
logConsole
.
debug
(
"
#
loadEnginesMetadataFromSettings
transfering
metadata
for
"
name
engine
.
_metaData
)
;
let
eng
=
this
.
_engines
.
get
(
name
)
;
if
(
eng
.
_alias
=
=
=
engine
?
.
_metaData
?
.
alias
)
{
delete
engine
.
_metaData
.
alias
;
}
eng
.
_metaData
=
engine
.
_metaData
|
|
{
}
;
}
}
}
#
loadEnginesFromSettings
(
enginesCache
)
{
if
(
!
enginesCache
)
{
return
;
}
lazy
.
logConsole
.
debug
(
"
#
loadEnginesFromSettings
:
Loading
"
enginesCache
.
length
"
engines
from
settings
"
)
;
let
skippedEngines
=
0
;
for
(
let
engineJSON
of
enginesCache
)
{
if
(
engineJSON
.
_isAppProvided
|
|
engineJSON
.
_isBuiltin
)
{
+
+
skippedEngines
;
continue
;
}
let
loadPath
=
engineJSON
.
_loadPath
?
.
toLowerCase
(
)
;
if
(
loadPath
&
&
(
loadPath
.
startsWith
(
"
[
distribution
]
"
)
|
|
loadPath
.
includes
(
"
[
app
]
/
extensions
/
langpack
"
)
|
|
loadPath
.
includes
(
"
[
other
]
/
langpack
"
)
|
|
loadPath
.
includes
(
"
[
profile
]
/
extensions
/
langpack
"
)
|
|
loadPath
.
startsWith
(
"
jar
:
[
app
]
/
omni
.
ja
"
)
)
)
{
continue
;
}
try
{
let
engine
;
if
(
loadPath
?
.
includes
(
"
set
-
via
-
policy
"
)
)
{
engine
=
new
lazy
.
PolicySearchEngine
(
{
json
:
engineJSON
}
)
;
}
else
if
(
loadPath
?
.
includes
(
"
set
-
via
-
user
"
)
)
{
engine
=
new
lazy
.
UserSearchEngine
(
{
json
:
engineJSON
}
)
;
}
else
if
(
engineJSON
.
extensionID
?
?
engineJSON
.
_extensionID
)
{
engine
=
new
lazy
.
AddonSearchEngine
(
{
isAppProvided
:
false
json
:
engineJSON
}
)
;
}
else
{
engine
=
new
lazy
.
OpenSearchEngine
(
{
json
:
engineJSON
}
)
;
}
this
.
#
addEngineToStore
(
engine
)
;
}
catch
(
ex
)
{
lazy
.
logConsole
.
error
(
"
Failed
to
load
"
engineJSON
.
_name
"
from
settings
:
"
ex
engineJSON
)
;
}
}
if
(
skippedEngines
)
{
lazy
.
logConsole
.
debug
(
"
#
loadEnginesFromSettings
:
skipped
"
skippedEngines
"
built
-
in
engines
.
"
)
;
}
}
async
_fetchEngineSelectorEngines
(
)
{
let
searchEngineSelectorProperties
=
{
locale
:
Services
.
locale
.
appLocaleAsBCP47
region
:
lazy
.
Region
.
home
|
|
"
default
"
channel
:
AppConstants
.
MOZ_APP_VERSION_DISPLAY
.
endsWith
(
"
esr
"
)
?
"
esr
"
:
AppConstants
.
MOZ_UPDATE_CHANNEL
experiment
:
lazy
.
NimbusFeatures
.
search
.
getVariable
(
"
experiment
"
)
?
?
"
"
distroID
:
lazy
.
SearchUtils
.
distroID
?
?
"
"
}
;
for
(
let
[
key
value
]
of
Object
.
entries
(
searchEngineSelectorProperties
)
)
{
this
.
_settings
.
setAttribute
(
key
value
)
;
}
let
{
engines
privateDefault
}
=
await
this
.
#
engineSelector
.
fetchEngineConfiguration
(
searchEngineSelectorProperties
)
;
for
(
let
e
of
engines
)
{
if
(
!
e
.
webExtension
)
{
e
.
webExtension
=
{
}
;
}
e
.
webExtension
.
locale
=
e
.
webExtension
?
.
locale
?
?
lazy
.
SearchUtils
.
DEFAULT_TAG
;
}
return
{
engines
privateDefault
}
;
}
#
setDefaultAndOrdersFromSelector
(
engines
privateDefault
)
{
const
defaultEngine
=
engines
[
0
]
;
this
.
_searchDefault
=
{
id
:
defaultEngine
.
webExtension
.
id
locale
:
defaultEngine
.
webExtension
.
locale
}
;
if
(
privateDefault
)
{
this
.
#
searchPrivateDefault
=
{
id
:
privateDefault
.
webExtension
.
id
locale
:
privateDefault
.
webExtension
.
locale
}
;
}
}
#
saveSortedEngineList
(
)
{
lazy
.
logConsole
.
debug
(
"
#
saveSortedEngineList
"
)
;
this
.
_settings
.
setAttribute
(
"
useSavedOrder
"
true
)
;
var
engines
=
this
.
#
sortedEngines
;
for
(
var
i
=
0
;
i
<
engines
.
length
;
+
+
i
)
{
engines
[
i
]
.
setAttr
(
"
order
"
i
+
1
)
;
}
}
#
buildSortedEngineList
(
)
{
this
.
__sortedEngines
=
[
]
;
if
(
this
.
_settings
.
getAttribute
(
"
useSavedOrder
"
)
)
{
lazy
.
logConsole
.
debug
(
"
#
buildSortedEngineList
:
using
saved
order
"
)
;
let
addedEngines
=
{
}
;
let
needToSaveEngineList
=
false
;
for
(
let
engine
of
this
.
_engines
.
values
(
)
)
{
var
orderNumber
=
engine
.
getAttr
(
"
order
"
)
;
if
(
orderNumber
&
&
!
this
.
__sortedEngines
[
orderNumber
-
1
]
)
{
this
.
__sortedEngines
[
orderNumber
-
1
]
=
engine
;
addedEngines
[
engine
.
name
]
=
engine
;
}
else
{
needToSaveEngineList
=
true
;
}
}
var
filteredEngines
=
this
.
__sortedEngines
.
filter
(
function
(
a
)
{
return
!
!
a
;
}
)
;
if
(
this
.
__sortedEngines
.
length
!
=
filteredEngines
.
length
)
{
needToSaveEngineList
=
true
;
}
this
.
__sortedEngines
=
filteredEngines
;
if
(
needToSaveEngineList
)
{
this
.
#
saveSortedEngineList
(
)
;
}
let
alphaEngines
=
[
]
;
for
(
let
engine
of
this
.
_engines
.
values
(
)
)
{
if
(
!
(
engine
.
name
in
addedEngines
)
)
{
alphaEngines
.
push
(
engine
)
;
}
}
const
collator
=
new
Intl
.
Collator
(
)
;
alphaEngines
.
sort
(
(
a
b
)
=
>
{
return
collator
.
compare
(
a
.
name
b
.
name
)
;
}
)
;
return
(
this
.
__sortedEngines
=
this
.
__sortedEngines
.
concat
(
alphaEngines
)
)
;
}
lazy
.
logConsole
.
debug
(
"
#
buildSortedEngineList
:
using
default
orders
"
)
;
return
(
this
.
__sortedEngines
=
this
.
_sortEnginesByDefaults
(
Array
.
from
(
this
.
_engines
.
values
(
)
)
)
)
;
}
_sortEnginesByDefaults
(
engines
)
{
const
sortedEngines
=
[
]
;
const
addedEngines
=
new
Set
(
)
;
function
maybeAddEngineToSort
(
engine
)
{
if
(
!
engine
|
|
addedEngines
.
has
(
engine
.
name
)
)
{
return
;
}
sortedEngines
.
push
(
engine
)
;
addedEngines
.
add
(
engine
.
name
)
;
}
const
appDefault
=
this
.
appDefaultEngine
;
maybeAddEngineToSort
(
appDefault
)
;
const
appPrivateDefault
=
this
.
appPrivateDefaultEngine
;
if
(
appPrivateDefault
&
&
appPrivateDefault
!
=
appDefault
)
{
maybeAddEngineToSort
(
appPrivateDefault
)
;
}
let
remainingEngines
;
const
collator
=
new
Intl
.
Collator
(
)
;
remainingEngines
=
engines
.
filter
(
e
=
>
!
addedEngines
.
has
(
e
.
name
)
)
;
remainingEngines
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
_orderHint
&
&
b
.
_orderHint
)
{
if
(
a
.
_orderHint
=
=
b
.
_orderHint
)
{
return
collator
.
compare
(
a
.
name
b
.
name
)
;
}
return
b
.
_orderHint
-
a
.
_orderHint
;
}
if
(
a
.
_orderHint
)
{
return
-
1
;
}
if
(
b
.
_orderHint
)
{
return
1
;
}
return
collator
.
compare
(
a
.
name
b
.
name
)
;
}
)
;
return
[
.
.
.
sortedEngines
.
.
.
remainingEngines
]
;
}
get
#
sortedVisibleEngines
(
)
{
this
.
__sortedVisibleEngines
=
this
.
#
sortedEngines
.
filter
(
engine
=
>
!
engine
.
hidden
)
;
return
this
.
__sortedVisibleEngines
;
}
async
#
migrateLegacyEngines
(
)
{
lazy
.
logConsole
.
debug
(
"
Running
migrate
legacy
engines
"
)
;
const
matchRegExp
=
/
extensions
\
/
(
.
*
?
)
\
.
xpi
!
/
i
;
for
(
let
engine
of
this
.
_engines
.
values
(
)
)
{
if
(
!
engine
.
isAppProvided
&
&
!
engine
.
_extensionID
&
&
engine
.
_loadPath
.
includes
(
"
[
profile
]
/
extensions
/
"
)
)
{
let
match
=
engine
.
_loadPath
.
match
(
matchRegExp
)
;
if
(
match
?
.
[
1
]
)
{
let
engines
=
await
this
.
getEnginesByExtensionID
(
match
[
1
]
)
;
if
(
engines
.
length
)
{
lazy
.
logConsole
.
debug
(
Migrating
{
engine
.
name
}
to
WebExtension
install
)
;
if
(
this
.
defaultEngine
=
=
engine
)
{
this
.
defaultEngine
=
engines
[
0
]
;
}
await
this
.
removeEngine
(
engine
)
;
}
}
}
}
lazy
.
logConsole
.
debug
(
"
Migrate
legacy
engines
complete
"
)
;
}
async
#
checkWebExtensionEngines
(
)
{
lazy
.
logConsole
.
debug
(
"
Running
check
on
WebExtension
engines
"
)
;
for
(
let
engine
of
this
.
_engines
.
values
(
)
)
{
if
(
engine
.
isAppProvided
|
|
!
engine
.
_extensionID
|
|
engine
.
_extensionID
=
=
"
set
-
via
-
policy
"
|
|
engine
.
_extensionID
=
=
"
set
-
via
-
user
"
)
{
continue
;
}
let
addon
=
await
lazy
.
AddonManager
.
getAddonByID
(
engine
.
_extensionID
)
;
if
(
!
addon
)
{
lazy
.
logConsole
.
debug
(
Add
-
on
{
engine
.
_extensionID
}
for
search
engine
{
engine
.
name
}
is
not
installed
!
)
;
Services
.
telemetry
.
keyedScalarSet
(
"
browser
.
searchinit
.
engine_invalid_webextension
"
engine
.
_extensionID
1
)
;
}
else
if
(
!
addon
.
isActive
)
{
lazy
.
logConsole
.
debug
(
Add
-
on
{
engine
.
_extensionID
}
for
search
engine
{
engine
.
name
}
is
not
active
!
)
;
Services
.
telemetry
.
keyedScalarSet
(
"
browser
.
searchinit
.
engine_invalid_webextension
"
engine
.
_extensionID
2
)
;
}
else
{
let
policy
=
await
this
.
#
getExtensionPolicy
(
engine
.
_extensionID
)
;
let
providerSettings
=
policy
.
extension
.
manifest
?
.
chrome_settings_overrides
?
.
search_provider
;
if
(
!
providerSettings
)
{
lazy
.
logConsole
.
debug
(
Add
-
on
{
engine
.
_extensionID
}
for
search
engine
{
engine
.
name
}
no
longer
has
an
engine
defined
)
;
Services
.
telemetry
.
keyedScalarSet
(
"
browser
.
searchinit
.
engine_invalid_webextension
"
engine
.
_extensionID
4
)
;
}
else
if
(
engine
.
name
!
=
providerSettings
.
name
)
{
lazy
.
logConsole
.
debug
(
Add
-
on
{
engine
.
_extensionID
}
for
search
engine
{
engine
.
name
}
has
a
different
name
!
)
;
Services
.
telemetry
.
keyedScalarSet
(
"
browser
.
searchinit
.
engine_invalid_webextension
"
engine
.
_extensionID
5
)
;
}
else
if
(
!
engine
.
checkSearchUrlMatchesManifest
(
providerSettings
)
)
{
lazy
.
logConsole
.
debug
(
Add
-
on
{
engine
.
_extensionID
}
for
search
engine
{
engine
.
name
}
has
out
-
of
-
date
manifest
!
)
;
Services
.
telemetry
.
keyedScalarSet
(
"
browser
.
searchinit
.
engine_invalid_webextension
"
engine
.
_extensionID
6
)
;
}
}
}
lazy
.
logConsole
.
debug
(
"
WebExtension
engine
check
complete
"
)
;
}
async
_createAndAddEngine
(
{
extensionID
extensionBaseURI
isAppProvided
manifest
locale
=
lazy
.
SearchUtils
.
DEFAULT_TAG
initEngine
=
false
}
)
{
if
(
!
this
.
_initialized
&
&
!
isAppProvided
&
&
!
initEngine
)
{
await
this
.
init
(
)
;
}
let
isCurrent
=
false
;
for
(
let
engine
of
this
.
_engines
.
values
(
)
)
{
if
(
!
engine
.
extensionID
&
&
engine
.
_loadPath
.
startsWith
(
jar
:
[
profile
]
/
extensions
/
{
extensionID
}
)
)
{
lazy
.
logConsole
.
debug
(
"
Migrating
existing
engine
"
)
;
isCurrent
=
isCurrent
|
|
this
.
defaultEngine
=
=
engine
;
await
this
.
removeEngine
(
engine
)
;
}
}
let
newEngine
=
new
lazy
.
AddonSearchEngine
(
{
isAppProvided
details
:
{
extensionID
extensionBaseURI
manifest
locale
}
}
)
;
let
existingEngine
=
this
.
_engines
.
get
(
newEngine
.
name
)
;
if
(
existingEngine
)
{
throw
Components
.
Exception
(
"
An
engine
with
that
name
already
exists
!
"
Cr
.
NS_ERROR_FILE_ALREADY_EXISTS
)
;
}
this
.
#
addEngineToStore
(
newEngine
)
;
if
(
isCurrent
)
{
this
.
defaultEngine
=
newEngine
;
}
return
newEngine
;
}
async
#
upgradeExtensionEngine
(
extension
)
{
let
{
engines
}
=
await
this
.
_fetchEngineSelectorEngines
(
)
;
let
extensionEngines
=
await
this
.
getEnginesByExtensionID
(
extension
.
id
)
;
for
(
let
engine
of
extensionEngines
)
{
let
locale
=
engine
.
_locale
|
|
lazy
.
SearchUtils
.
DEFAULT_TAG
;
let
manifest
=
await
this
.
#
getManifestForLocale
(
extension
locale
)
;
let
configuration
=
engines
.
find
(
e
=
>
e
.
webExtension
.
id
=
=
extension
.
id
&
&
e
.
webExtension
.
locale
=
=
locale
)
?
?
{
}
;
let
appDefaultName
=
engine
.
name
;
let
name
=
manifest
.
chrome_settings_overrides
.
search_provider
.
name
.
trim
(
)
;
if
(
appDefaultName
!
=
name
&
&
this
.
_engines
.
has
(
name
)
)
{
throw
new
Error
(
"
Can
'
t
upgrade
to
the
same
name
as
an
existing
engine
"
)
;
}
let
isDefault
=
engine
=
=
this
.
defaultEngine
;
let
isDefaultPrivate
=
engine
=
=
this
.
defaultPrivateEngine
;
engine
.
updateFromManifest
(
extension
.
id
extension
.
baseURI
manifest
locale
configuration
)
;
if
(
appDefaultName
!
=
engine
.
name
)
{
this
.
_engines
.
delete
(
appDefaultName
)
;
this
.
_engines
.
set
(
engine
.
name
engine
)
;
if
(
isDefault
)
{
this
.
_settings
.
setVerifiedAttribute
(
"
current
"
engine
.
name
)
;
}
if
(
isDefaultPrivate
)
{
this
.
_settings
.
setVerifiedAttribute
(
"
private
"
engine
.
name
)
;
}
this
.
__sortedEngines
=
null
;
}
}
return
extensionEngines
;
}
async
#
installExtensionEngine
(
extension
locales
initEngine
=
false
)
{
lazy
.
logConsole
.
debug
(
"
installExtensionEngine
:
"
extension
.
id
)
;
let
installLocale
=
async
locale
=
>
{
let
manifest
=
await
this
.
#
getManifestForLocale
(
extension
locale
)
;
return
this
.
#
addEngineForManifest
(
extension
manifest
locale
initEngine
)
;
}
;
let
engines
=
[
]
;
for
(
let
locale
of
locales
)
{
lazy
.
logConsole
.
debug
(
"
addEnginesFromExtension
:
installing
:
"
extension
.
id
"
:
"
locale
)
;
engines
.
push
(
await
installLocale
(
locale
)
)
;
}
return
engines
;
}
async
#
addEngineForManifest
(
extension
manifest
locale
=
lazy
.
SearchUtils
.
DEFAULT_TAG
initEngine
=
false
)
{
if
(
extension
.
startupReason
=
=
"
APP_STARTUP
"
)
{
let
engine
=
this
.
#
getEngineByWebExtensionDetails
(
{
id
:
extension
.
id
locale
}
)
;
if
(
engine
)
{
lazy
.
logConsole
.
debug
(
"
Engine
already
loaded
via
settings
skipping
due
to
APP_STARTUP
:
"
extension
.
id
)
;
return
engine
;
}
}
return
this
.
_createAndAddEngine
(
{
extensionID
:
extension
.
id
extensionBaseURI
:
extension
.
baseURI
isAppProvided
:
extension
.
isAppProvided
manifest
locale
initEngine
}
)
;
}
#
internalRemoveEngine
(
engine
)
{
if
(
this
.
__sortedEngines
)
{
var
index
=
this
.
__sortedEngines
.
indexOf
(
engine
)
;
if
(
index
=
=
-
1
)
{
throw
Components
.
Exception
(
"
Can
'
t
find
engine
to
remove
in
_sortedEngines
!
"
Cr
.
NS_ERROR_FAILURE
)
;
}
this
.
__sortedEngines
.
splice
(
index
1
)
;
}
this
.
_engines
.
delete
(
engine
.
name
)
;
}
#
findAndSetNewDefaultEngine
(
{
privateMode
excludeEngineName
=
"
"
}
)
{
let
newDefault
=
privateMode
?
this
.
appPrivateDefaultEngine
:
this
.
appDefaultEngine
;
if
(
!
newDefault
|
|
newDefault
.
hidden
|
|
newDefault
.
name
=
=
excludeEngineName
)
{
let
sortedEngines
=
this
.
#
sortedVisibleEngines
;
let
generalSearchEngines
=
sortedEngines
.
filter
(
e
=
>
e
.
isGeneralPurposeEngine
)
;
let
firstVisible
=
generalSearchEngines
.
find
(
e
=
>
e
.
name
!
=
excludeEngineName
)
;
if
(
firstVisible
)
{
newDefault
=
firstVisible
;
}
else
if
(
newDefault
)
{
if
(
newDefault
.
name
!
=
excludeEngineName
)
{
newDefault
.
hidden
=
false
;
}
else
{
newDefault
=
null
;
}
}
if
(
!
newDefault
)
{
if
(
!
firstVisible
)
{
sortedEngines
=
this
.
#
sortedEngines
;
firstVisible
=
sortedEngines
.
find
(
e
=
>
e
.
isGeneralPurposeEngine
)
;
if
(
!
firstVisible
)
{
firstVisible
=
sortedEngines
[
0
]
;
}
}
if
(
firstVisible
)
{
firstVisible
.
hidden
=
false
;
newDefault
=
firstVisible
;
}
}
}
if
(
!
newDefault
)
{
lazy
.
logConsole
.
error
(
"
Could
not
find
a
replacement
default
engine
.
"
)
;
return
null
;
}
this
.
#
setEngineDefault
(
privateMode
newDefault
)
;
return
privateMode
?
this
.
#
currentPrivateEngine
:
this
.
#
currentEngine
;
}
#
setEngineDefault
(
privateMode
newEngine
)
{
if
(
!
(
newEngine
instanceof
Ci
.
nsISearchEngine
)
&
&
!
(
newEngine
instanceof
lazy
.
SearchEngine
)
)
{
throw
Components
.
Exception
(
"
Invalid
argument
passed
to
defaultEngine
setter
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
const
newCurrentEngine
=
this
.
_engines
.
get
(
newEngine
.
name
)
;
if
(
!
newCurrentEngine
)
{
throw
Components
.
Exception
(
"
Can
'
t
find
engine
in
store
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
if
(
!
newCurrentEngine
.
isAppProvided
)
{
if
(
!
newCurrentEngine
.
_loadPath
)
{
newCurrentEngine
.
_loadPath
=
"
[
other
]
unknown
"
;
}
let
loadPathHash
=
lazy
.
SearchUtils
.
getVerificationHash
(
newCurrentEngine
.
_loadPath
)
;
let
currentHash
=
newCurrentEngine
.
getAttr
(
"
loadPathHash
"
)
;
if
(
!
currentHash
|
|
currentHash
!
=
loadPathHash
)
{
newCurrentEngine
.
setAttr
(
"
loadPathHash
"
loadPathHash
)
;
lazy
.
SearchUtils
.
notifyAction
(
newCurrentEngine
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
CHANGED
)
;
}
}
let
currentEngine
=
privateMode
?
this
.
#
currentPrivateEngine
:
this
.
#
currentEngine
;
if
(
newCurrentEngine
=
=
currentEngine
)
{
return
;
}
currentEngine
?
.
removeExtensionOverride
(
)
;
if
(
privateMode
)
{
this
.
#
currentPrivateEngine
=
newCurrentEngine
;
}
else
{
this
.
#
currentEngine
=
newCurrentEngine
;
}
let
newName
=
newCurrentEngine
.
name
;
const
appDefaultEngine
=
privateMode
?
this
.
appPrivateDefaultEngine
:
this
.
appDefaultEngine
;
if
(
newCurrentEngine
=
=
appDefaultEngine
)
{
newName
=
"
"
;
}
this
.
_settings
.
setVerifiedAttribute
(
privateMode
?
"
private
"
:
"
current
"
newName
)
;
if
(
this
.
_initialized
)
{
this
.
#
recordTelemetryData
(
)
;
}
lazy
.
SearchUtils
.
notifyAction
(
newCurrentEngine
lazy
.
SearchUtils
.
MODIFIED_TYPE
[
privateMode
?
"
DEFAULT_PRIVATE
"
:
"
DEFAULT
"
]
)
;
if
(
!
privateMode
&
&
!
this
.
#
separatePrivateDefault
)
{
lazy
.
SearchUtils
.
notifyAction
(
newCurrentEngine
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
DEFAULT_PRIVATE
)
;
}
}
#
onSeparateDefaultPrefChanged
(
)
{
this
.
__sortedEngines
=
null
;
if
(
this
.
defaultEngine
!
=
this
.
_getEngineDefault
(
true
)
)
{
lazy
.
SearchUtils
.
notifyAction
(
this
.
defaultPrivateEngine
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
DEFAULT_PRIVATE
)
;
this
.
#
recordTelemetryData
(
)
;
}
}
#
getEngineInfo
(
engine
)
{
if
(
!
engine
)
{
Cu
.
reportError
(
"
getDefaultEngineInfo
:
No
default
engine
"
)
;
return
[
"
NONE
"
{
name
:
"
NONE
"
}
]
;
}
const
engineData
=
{
loadPath
:
engine
.
_loadPath
name
:
engine
.
name
?
engine
.
name
:
"
"
}
;
if
(
engine
.
isAppProvided
)
{
engineData
.
origin
=
"
default
"
;
}
else
{
let
currentHash
=
engine
.
getAttr
(
"
loadPathHash
"
)
;
if
(
!
currentHash
)
{
engineData
.
origin
=
"
unverified
"
;
}
else
{
let
loadPathHash
=
lazy
.
SearchUtils
.
getVerificationHash
(
engine
.
_loadPath
)
;
engineData
.
origin
=
currentHash
=
=
loadPathHash
?
"
verified
"
:
"
invalid
"
;
}
}
let
sendSubmissionURL
=
engine
.
isAppProvided
;
if
(
!
sendSubmissionURL
)
{
let
engineHost
=
engine
.
_getURLOfType
(
lazy
.
SearchUtils
.
URL_TYPE
.
SEARCH
)
.
templateHost
;
for
(
let
innerEngine
of
this
.
_engines
.
values
(
)
)
{
if
(
!
innerEngine
.
isAppProvided
)
{
continue
;
}
let
innerEngineURL
=
innerEngine
.
_getURLOfType
(
lazy
.
SearchUtils
.
URL_TYPE
.
SEARCH
)
;
if
(
innerEngineURL
.
templateHost
=
=
engineHost
)
{
sendSubmissionURL
=
true
;
break
;
}
}
if
(
!
sendSubmissionURL
)
{
const
urlTest
=
/
^
(
?
:
www
\
.
google
\
.
|
search
\
.
aol
\
.
|
yandex
\
.
)
|
(
?
:
search
\
.
yahoo
|
\
.
ask
|
\
.
bing
|
\
.
startpage
|
\
.
baidu
|
duckduckgo
)
\
.
com
/
;
sendSubmissionURL
=
urlTest
.
test
(
engineHost
)
;
}
}
if
(
sendSubmissionURL
)
{
let
uri
=
engine
.
_getURLOfType
(
"
text
/
html
"
)
.
getSubmission
(
"
"
engine
"
searchbar
"
)
.
uri
;
uri
=
uri
.
mutate
(
)
.
setUserPass
(
"
"
)
.
finalize
(
)
;
engineData
.
submissionURL
=
uri
.
spec
;
}
return
[
engine
.
telemetryId
engineData
]
;
}
#
recordTelemetryData
(
)
{
let
info
=
this
.
getDefaultEngineInfo
(
)
;
Glean
.
searchEngineDefault
.
engineId
.
set
(
info
.
defaultSearchEngine
)
;
Glean
.
searchEngineDefault
.
displayName
.
set
(
info
.
defaultSearchEngineData
.
name
)
;
Glean
.
searchEngineDefault
.
loadPath
.
set
(
info
.
defaultSearchEngineData
.
loadPath
)
;
Glean
.
searchEngineDefault
.
submissionUrl
.
set
(
info
.
defaultSearchEngineData
.
submissionURL
?
?
"
blank
:
"
)
;
Glean
.
searchEngineDefault
.
verified
.
set
(
info
.
defaultSearchEngineData
.
origin
)
;
Glean
.
searchEnginePrivate
.
engineId
.
set
(
info
.
defaultPrivateSearchEngine
?
?
"
"
)
;
if
(
info
.
defaultPrivateSearchEngineData
)
{
Glean
.
searchEnginePrivate
.
displayName
.
set
(
info
.
defaultPrivateSearchEngineData
.
name
)
;
Glean
.
searchEnginePrivate
.
loadPath
.
set
(
info
.
defaultPrivateSearchEngineData
.
loadPath
)
;
Glean
.
searchEnginePrivate
.
submissionUrl
.
set
(
info
.
defaultPrivateSearchEngineData
.
submissionURL
?
?
"
blank
:
"
)
;
Glean
.
searchEnginePrivate
.
verified
.
set
(
info
.
defaultPrivateSearchEngineData
.
origin
)
;
}
else
{
Glean
.
searchEnginePrivate
.
displayName
.
set
(
"
"
)
;
Glean
.
searchEnginePrivate
.
loadPath
.
set
(
"
"
)
;
Glean
.
searchEnginePrivate
.
submissionUrl
.
set
(
"
"
)
;
Glean
.
searchEnginePrivate
.
verified
.
set
(
"
"
)
;
}
}
#
buildParseSubmissionMap
(
)
{
this
.
#
parseSubmissionMap
=
new
Map
(
)
;
let
keysOfAlternates
=
new
Set
(
)
;
for
(
let
engine
of
this
.
#
sortedEngines
)
{
if
(
engine
.
hidden
)
{
continue
;
}
let
urlParsingInfo
=
engine
.
getURLParsingInfo
(
)
;
if
(
!
urlParsingInfo
)
{
continue
;
}
let
mapValueForEngine
=
{
engine
termsParameterName
:
urlParsingInfo
.
termsParameterName
}
;
let
processDomain
=
(
domain
isAlternate
)
=
>
{
let
key
=
domain
+
urlParsingInfo
.
path
;
let
existingEntry
=
this
.
#
parseSubmissionMap
.
get
(
key
)
;
if
(
!
existingEntry
)
{
if
(
isAlternate
)
{
keysOfAlternates
.
add
(
key
)
;
}
}
else
if
(
!
isAlternate
&
&
keysOfAlternates
.
has
(
key
)
)
{
keysOfAlternates
.
delete
(
key
)
;
}
else
{
return
;
}
this
.
#
parseSubmissionMap
.
set
(
key
mapValueForEngine
)
;
}
;
processDomain
(
urlParsingInfo
.
mainDomain
false
)
;
lazy
.
SearchStaticData
.
getAlternateDomains
(
urlParsingInfo
.
mainDomain
)
.
forEach
(
d
=
>
processDomain
(
d
true
)
)
;
}
}
async
#
getExtensionPolicy
(
id
)
{
let
policy
=
WebExtensionPolicy
.
getByID
(
id
)
;
if
(
!
policy
)
{
let
idPrefix
=
id
.
split
(
"
"
)
[
0
]
;
let
path
=
resource
:
/
/
search
-
extensions
/
{
idPrefix
}
/
;
await
lazy
.
AddonManager
.
installBuiltinAddon
(
path
)
;
policy
=
WebExtensionPolicy
.
getByID
(
id
)
;
}
await
policy
.
readyPromise
;
return
policy
;
}
#
addObservers
(
)
{
if
(
this
.
#
observersAdded
)
{
return
;
}
this
.
#
observersAdded
=
true
;
lazy
.
NimbusFeatures
.
search
.
onUpdate
(
(
)
=
>
Services
.
search
.
wrappedJSObject
.
_maybeReloadEngines
(
)
)
;
Services
.
obs
.
addObserver
(
this
lazy
.
SearchUtils
.
TOPIC_ENGINE_MODIFIED
)
;
Services
.
obs
.
addObserver
(
this
QUIT_APPLICATION_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
TOPIC_LOCALES_CHANGE
)
;
this
.
_settings
.
addObservers
(
)
;
let
shutdownState
=
{
step
:
"
Not
started
"
latestError
:
{
message
:
undefined
stack
:
undefined
}
}
;
IOUtils
.
profileBeforeChange
.
addBlocker
(
"
Search
service
:
shutting
down
"
(
)
=
>
(
async
(
)
=
>
{
if
(
!
this
.
_initialized
)
{
lazy
.
logConsole
.
warn
(
"
not
saving
settings
on
shutdown
due
to
initializing
.
"
)
;
return
;
}
try
{
await
this
.
_settings
.
shutdown
(
shutdownState
)
;
}
catch
(
ex
)
{
Promise
.
reject
(
ex
)
;
}
}
)
(
)
(
)
=
>
shutdownState
)
;
}
_removeObservers
(
)
{
if
(
this
.
ignoreListListener
)
{
lazy
.
IgnoreLists
.
unsubscribe
(
this
.
ignoreListListener
)
;
delete
this
.
ignoreListListener
;
}
if
(
this
.
#
queuedIdle
)
{
this
.
idleService
.
removeIdleObserver
(
this
RECONFIG_IDLE_TIME_SEC
)
;
this
.
#
queuedIdle
=
false
;
}
this
.
_settings
.
removeObservers
(
)
;
lazy
.
NimbusFeatures
.
search
.
off
(
(
)
=
>
Services
.
search
.
wrappedJSObject
.
_maybeReloadEngines
(
)
)
;
Services
.
obs
.
removeObserver
(
this
lazy
.
SearchUtils
.
TOPIC_ENGINE_MODIFIED
)
;
Services
.
obs
.
removeObserver
(
this
QUIT_APPLICATION_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
TOPIC_LOCALES_CHANGE
)
;
Services
.
obs
.
removeObserver
(
this
lazy
.
Region
.
REGION_TOPIC
)
;
}
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsISearchService
"
"
nsIObserver
"
"
nsITimerCallback
"
]
)
;
observe
(
engine
topic
verb
)
{
switch
(
topic
)
{
case
lazy
.
SearchUtils
.
TOPIC_ENGINE_MODIFIED
:
switch
(
verb
)
{
case
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
LOADED
:
engine
=
engine
.
QueryInterface
(
Ci
.
nsISearchEngine
)
;
lazy
.
logConsole
.
debug
(
"
observe
:
Done
installation
of
"
engine
.
name
)
;
this
.
#
addEngineToStore
(
engine
.
wrappedJSObject
)
;
break
;
case
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
ADDED
:
case
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
CHANGED
:
case
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
REMOVED
:
this
.
#
parseSubmissionMap
=
null
;
break
;
}
break
;
case
"
idle
"
:
{
this
.
idleService
.
removeIdleObserver
(
this
RECONFIG_IDLE_TIME_SEC
)
;
this
.
#
queuedIdle
=
false
;
lazy
.
logConsole
.
debug
(
"
Reloading
engines
after
idle
due
to
configuration
change
"
)
;
this
.
_maybeReloadEngines
(
)
.
catch
(
Cu
.
reportError
)
;
break
;
}
case
QUIT_APPLICATION_TOPIC
:
this
.
_removeObservers
(
)
;
break
;
case
TOPIC_LOCALES_CHANGE
:
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
if
(
!
Services
.
startup
.
shuttingDown
)
{
this
.
_maybeReloadEngines
(
)
.
catch
(
Cu
.
reportError
)
;
}
}
)
;
break
;
case
lazy
.
Region
.
REGION_TOPIC
:
lazy
.
logConsole
.
debug
(
"
Region
updated
:
"
lazy
.
Region
.
home
)
;
this
.
_maybeReloadEngines
(
)
.
catch
(
Cu
.
reportError
)
;
break
;
}
}
async
_makeEngineFromConfig
(
config
)
{
lazy
.
logConsole
.
debug
(
"
_makeEngineFromConfig
:
"
config
)
;
let
policy
=
await
this
.
#
getExtensionPolicy
(
config
.
webExtension
.
id
)
;
let
locale
=
"
locale
"
in
config
.
webExtension
?
config
.
webExtension
.
locale
:
lazy
.
SearchUtils
.
DEFAULT_TAG
;
let
manifest
=
await
this
.
#
getManifestForLocale
(
policy
.
extension
locale
)
;
return
new
lazy
.
AddonSearchEngine
(
{
isAppProvided
:
policy
.
extension
.
isAppProvided
details
:
{
extensionID
:
policy
.
extension
.
id
extensionBaseURI
:
policy
.
extension
.
baseURI
manifest
locale
config
}
}
)
;
}
#
didSettingsMetaDataUpdate
(
metaData
)
{
let
metaDataProperties
=
[
"
locale
"
"
region
"
"
channel
"
"
experiment
"
"
distroID
"
]
;
return
metaDataProperties
.
some
(
p
=
>
{
return
metaData
?
.
[
p
]
!
=
=
this
.
_settings
.
getAttribute
(
p
)
;
}
)
;
}
_showRemovalOfSearchEngineNotificationBox
(
prevCurrentEngine
newCurrentEngine
)
{
let
win
=
Services
.
wm
.
getMostRecentBrowserWindow
(
)
;
win
.
BrowserSearch
.
removalOfSearchEngineNotificationBox
(
prevCurrentEngine
newCurrentEngine
)
;
}
async
#
getManifestForLocale
(
extension
locale
)
{
let
manifest
=
extension
.
manifest
;
let
localeToLoad
=
locale
=
=
lazy
.
SearchUtils
.
DEFAULT_TAG
?
manifest
.
default_locale
:
locale
;
if
(
localeToLoad
)
{
manifest
=
await
extension
.
getLocalizedManifest
(
localeToLoad
)
;
}
return
manifest
;
}
}
var
engineUpdateService
=
{
scheduleNextUpdate
(
engine
)
{
var
interval
=
engine
.
_updateInterval
|
|
SEARCH_DEFAULT_UPDATE_INTERVAL
;
var
milliseconds
=
interval
*
86400000
;
engine
.
setAttr
(
"
updateexpir
"
Date
.
now
(
)
+
milliseconds
)
;
}
update
(
engine
)
{
engine
=
engine
.
wrappedJSObject
;
lazy
.
logConsole
.
debug
(
"
update
called
for
"
engine
.
_name
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
lazy
.
SearchUtils
.
BROWSER_SEARCH_PREF
+
"
update
"
true
)
|
|
!
engine
.
_hasUpdates
)
{
return
;
}
let
testEngine
=
null
;
let
updateURL
=
engine
.
_getURLOfType
(
lazy
.
SearchUtils
.
URL_TYPE
.
OPENSEARCH
)
;
let
updateURI
=
updateURL
&
&
updateURL
.
_hasRelation
(
"
self
"
)
?
updateURL
.
getSubmission
(
"
"
engine
)
.
uri
:
lazy
.
SearchUtils
.
makeURI
(
engine
.
_updateURL
)
;
if
(
updateURI
)
{
if
(
engine
.
isAppProvided
&
&
!
updateURI
.
schemeIs
(
"
https
"
)
)
{
lazy
.
logConsole
.
debug
(
"
Invalid
scheme
for
default
engine
update
"
)
;
return
;
}
lazy
.
logConsole
.
debug
(
"
updating
"
engine
.
name
updateURI
.
spec
)
;
testEngine
=
new
lazy
.
OpenSearchEngine
(
)
;
testEngine
.
_engineToUpdate
=
engine
;
try
{
testEngine
.
install
(
updateURI
)
;
}
catch
(
ex
)
{
lazy
.
logConsole
.
error
(
"
Failed
to
update
"
engine
.
name
ex
)
;
}
}
else
{
lazy
.
logConsole
.
debug
(
"
invalid
updateURI
"
)
;
}
if
(
engine
.
_iconUpdateURL
)
{
(
testEngine
|
|
engine
)
.
_setIcon
(
engine
.
_iconUpdateURL
true
)
;
}
}
}
;
XPCOMUtils
.
defineLazyServiceGetter
(
SearchService
.
prototype
"
idleService
"
"
mozilla
.
org
/
widget
/
useridleservice
;
1
"
"
nsIUserIdleService
"
)
;
class
SearchDefaultOverrideAllowlistHandler
{
constructor
(
listener
)
{
this
.
_remoteConfig
=
lazy
.
RemoteSettings
(
lazy
.
SearchUtils
.
SETTINGS_ALLOWLIST_KEY
)
;
}
async
canOverride
(
extension
appProvidedExtensionId
)
{
const
overrideTable
=
await
this
.
_getAllowlist
(
)
;
let
entry
=
overrideTable
.
find
(
e
=
>
e
.
thirdPartyId
=
=
extension
.
id
)
;
if
(
!
entry
)
{
return
false
;
}
if
(
appProvidedExtensionId
!
=
entry
.
overridesId
)
{
return
false
;
}
let
searchProvider
=
extension
.
manifest
.
chrome_settings_overrides
.
search_provider
;
return
entry
.
urls
.
some
(
e
=
>
searchProvider
.
search_url
=
=
e
.
search_url
&
&
searchProvider
.
search_form
=
=
e
.
search_form
&
&
searchProvider
.
search_url_get_params
=
=
e
.
search_url_get_params
&
&
searchProvider
.
search_url_post_params
=
=
e
.
search_url_post_params
)
;
}
async
_getAllowlist
(
)
{
let
result
=
[
]
;
try
{
result
=
await
this
.
_remoteConfig
.
get
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
lazy
.
logConsole
.
debug
(
"
Allow
list
is
:
"
result
)
;
return
result
;
}
}
var
EXPORTED_SYMBOLS
=
[
"
SearchService
"
]
;
