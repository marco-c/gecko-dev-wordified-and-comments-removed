var
EXPORTED_SYMBOLS
=
[
"
SearchCache
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
DeferredTask
:
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
(
)
=
>
{
return
console
.
createInstance
(
{
prefix
:
"
SearchCache
"
maxLogLevel
:
SearchUtils
.
loggingEnabled
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gEncoder
"
function
(
)
{
return
new
TextEncoder
(
)
;
}
)
;
const
CACHE_FILENAME
=
"
search
.
json
.
mozlz4
"
;
class
SearchCache
{
constructor
(
searchService
)
{
this
.
_searchService
=
searchService
;
}
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
;
static
CACHE_INVALIDATION_DELAY
=
1000
;
_batchTask
=
null
;
_metaData
=
{
}
;
_searchService
;
addObservers
(
)
{
Services
.
obs
.
addObserver
(
this
SearchUtils
.
TOPIC_ENGINE_MODIFIED
)
;
Services
.
obs
.
addObserver
(
this
SearchUtils
.
TOPIC_SEARCH_SERVICE
)
;
}
removeObservers
(
)
{
Services
.
obs
.
removeObserver
(
this
SearchUtils
.
TOPIC_ENGINE_MODIFIED
)
;
Services
.
obs
.
removeObserver
(
this
SearchUtils
.
TOPIC_SEARCH_SERVICE
)
;
}
async
get
(
origin
=
"
"
)
{
let
json
;
await
this
.
_ensurePendingWritesCompleted
(
origin
)
;
try
{
let
cacheFilePath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CACHE_FILENAME
)
;
let
bytes
=
await
OS
.
File
.
read
(
cacheFilePath
{
compression
:
"
lz4
"
}
)
;
json
=
JSON
.
parse
(
new
TextDecoder
(
)
.
decode
(
bytes
)
)
;
if
(
!
json
.
engines
|
|
!
json
.
engines
.
length
)
{
throw
new
Error
(
"
no
engine
in
the
file
"
)
;
}
}
catch
(
ex
)
{
logConsole
.
error
(
"
_readCacheFile
:
Error
reading
cache
file
:
"
ex
)
;
json
=
{
}
;
}
if
(
json
.
metaData
)
{
this
.
_metaData
=
json
.
metaData
;
}
return
json
;
}
_delayedWrite
(
)
{
if
(
this
.
_batchTask
)
{
this
.
_batchTask
.
disarm
(
)
;
}
else
{
let
task
=
async
(
)
=
>
{
logConsole
.
debug
(
"
batchTask
:
Invalidating
engine
cache
"
)
;
await
this
.
_write
(
)
;
}
;
this
.
_batchTask
=
new
DeferredTask
(
task
SearchCache
.
CACHE_INVALIDATION_DELAY
)
;
}
this
.
_batchTask
.
arm
(
)
;
}
async
_ensurePendingWritesCompleted
(
origin
=
"
"
)
{
if
(
!
this
.
_batchTask
)
{
return
;
}
logConsole
.
debug
(
"
finalizing
batch
task
"
)
;
let
task
=
this
.
_batchTask
;
this
.
_batchTask
=
null
;
if
(
origin
=
=
"
test
"
)
{
task
.
disarm
(
)
;
}
else
{
await
task
.
finalize
(
)
;
}
}
async
_write
(
)
{
if
(
this
.
_batchTask
)
{
this
.
_batchTask
.
disarm
(
)
;
}
let
cache
=
{
}
;
let
locale
=
Services
.
locale
.
requestedLocale
;
let
buildID
=
Services
.
appinfo
.
platformBuildID
;
let
appVersion
=
Services
.
appinfo
.
version
;
cache
.
version
=
SearchUtils
.
CACHE_VERSION
;
cache
.
buildID
=
buildID
;
cache
.
appVersion
=
appVersion
;
cache
.
locale
=
locale
;
cache
.
builtInEngineList
=
this
.
_searchService
.
_searchOrder
;
cache
.
engines
=
[
.
.
.
this
.
_searchService
.
_engines
.
values
(
)
]
;
cache
.
metaData
=
this
.
_metaData
;
try
{
if
(
!
cache
.
engines
.
length
)
{
throw
new
Error
(
"
cannot
write
without
any
engine
.
"
)
;
}
logConsole
.
debug
(
"
_buildCache
:
Writing
to
cache
file
.
"
)
;
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CACHE_FILENAME
)
;
let
data
=
gEncoder
.
encode
(
JSON
.
stringify
(
cache
)
)
;
await
OS
.
File
.
writeAtomic
(
path
data
{
compression
:
"
lz4
"
tmpPath
:
path
+
"
.
tmp
"
}
)
;
logConsole
.
debug
(
"
_buildCache
:
cache
file
written
to
disk
.
"
)
;
Services
.
obs
.
notifyObservers
(
null
SearchUtils
.
TOPIC_SEARCH_SERVICE
"
write
-
cache
-
to
-
disk
-
complete
"
)
;
}
catch
(
ex
)
{
logConsole
.
error
(
"
_buildCache
:
Could
not
write
to
cache
file
:
"
ex
)
;
}
}
setAttribute
(
name
val
)
{
this
.
_metaData
[
name
]
=
val
;
this
.
_delayedWrite
(
)
;
}
setVerifiedAttribute
(
name
val
)
{
this
.
_metaData
[
name
]
=
val
;
this
.
_metaData
[
this
.
getHashName
(
name
)
]
=
SearchUtils
.
getVerificationHash
(
val
)
;
this
.
_delayedWrite
(
)
;
}
getAttribute
(
name
)
{
return
this
.
_metaData
[
name
]
|
|
undefined
;
}
getVerifiedAttribute
(
name
)
{
let
val
=
this
.
getAttribute
(
name
)
;
if
(
val
&
&
this
.
getAttribute
(
this
.
getHashName
(
name
)
)
!
=
SearchUtils
.
getVerificationHash
(
val
)
)
{
logConsole
.
warn
(
"
getVerifiedGlobalAttr
invalid
hash
for
"
name
)
;
return
"
"
;
}
return
val
;
}
getHashName
(
name
)
{
if
(
name
=
=
"
current
"
)
{
return
"
hash
"
;
}
return
name
+
"
Hash
"
;
}
async
shutdown
(
state
)
{
if
(
!
this
.
_batchTask
)
{
return
;
}
state
.
step
=
"
Finalizing
batched
task
"
;
try
{
await
this
.
_batchTask
.
finalize
(
)
;
state
.
step
=
"
Batched
task
finalized
"
;
}
catch
(
ex
)
{
state
.
step
=
"
Batched
task
failed
to
finalize
"
;
state
.
latestError
.
message
=
"
"
+
ex
;
if
(
ex
&
&
typeof
ex
=
=
"
object
"
)
{
state
.
latestError
.
stack
=
ex
.
stack
|
|
undefined
;
}
}
}
observe
(
engine
topic
verb
)
{
switch
(
topic
)
{
case
SearchUtils
.
TOPIC_ENGINE_MODIFIED
:
switch
(
verb
)
{
case
SearchUtils
.
MODIFIED_TYPE
.
ADDED
:
case
SearchUtils
.
MODIFIED_TYPE
.
CHANGED
:
case
SearchUtils
.
MODIFIED_TYPE
.
REMOVED
:
this
.
_delayedWrite
(
)
;
break
;
}
break
;
case
SearchUtils
.
TOPIC_SEARCH_SERVICE
:
switch
(
verb
)
{
case
"
init
-
complete
"
:
case
"
reinit
-
complete
"
:
case
"
engines
-
reloaded
"
:
this
.
_delayedWrite
(
)
;
break
;
}
break
;
}
}
}
