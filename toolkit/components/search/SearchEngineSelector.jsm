"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SearchEngineSelector
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
jsm
"
}
)
;
const
EXT_SEARCH_PREFIX
=
"
resource
:
/
/
search
-
extensions
/
"
;
const
ENGINE_CONFIG_URL
=
{
EXT_SEARCH_PREFIX
}
engines
.
json
;
function
log
(
str
)
{
SearchUtils
.
log
(
"
SearchEngineSelector
"
+
str
+
"
\
n
"
)
;
}
class
SearchEngineSelector
{
async
init
(
url
=
ENGINE_CONFIG_URL
)
{
this
.
configuration
=
await
this
.
getEngineConfiguration
(
url
)
;
}
async
getEngineConfiguration
(
url
)
{
const
response
=
await
fetch
(
url
)
;
return
(
await
response
.
json
(
)
)
.
data
;
}
fetchEngineConfiguration
(
region
locale
)
{
if
(
!
region
|
|
!
locale
)
{
throw
new
Error
(
"
region
and
locale
parameters
required
"
)
;
}
log
(
fetchEngineConfiguration
{
region
}
:
{
locale
}
)
;
let
engines
=
[
]
;
for
(
let
config
of
this
.
configuration
)
{
const
appliesTo
=
config
.
appliesTo
|
|
[
]
;
const
applies
=
appliesTo
.
filter
(
section
=
>
{
let
included
=
"
included
"
in
section
&
&
this
.
_isInSection
(
region
locale
section
.
included
)
;
let
excluded
=
"
excluded
"
in
section
&
&
this
.
_isInSection
(
region
locale
section
.
excluded
)
;
return
included
&
&
!
excluded
;
}
)
;
let
baseConfig
=
this
.
_copyObject
(
{
}
config
)
;
if
(
applies
.
length
)
{
for
(
let
section
of
applies
)
{
this
.
_copyObject
(
baseConfig
section
)
;
}
engines
.
push
(
baseConfig
)
;
}
}
engines
.
sort
(
this
.
_sort
.
bind
(
this
)
)
;
let
privateEngine
=
engines
.
find
(
engine
=
>
{
return
(
"
defaultPrivate
"
in
engine
&
&
[
"
yes
"
"
yes
-
if
-
no
-
other
"
]
.
includes
(
engine
.
defaultPrivate
)
)
;
}
)
;
let
result
=
{
engines
}
;
if
(
privateEngine
)
{
result
.
privateDefault
=
privateEngine
.
engineName
;
}
return
result
;
}
_sort
(
a
b
)
{
return
this
.
_sortIndex
(
b
)
-
this
.
_sortIndex
(
a
)
;
}
_sortIndex
(
obj
)
{
let
orderHint
=
obj
.
orderHint
|
|
0
;
if
(
this
.
_isDefault
(
obj
)
)
{
orderHint
+
=
50000
;
}
if
(
"
privateDefault
"
in
obj
&
&
obj
.
default
=
=
=
"
yes
"
)
{
orderHint
+
=
40000
;
}
if
(
"
default
"
in
obj
&
&
obj
.
default
=
=
=
"
yes
-
if
-
no
-
other
"
)
{
orderHint
+
=
20000
;
}
if
(
"
privateDefault
"
in
obj
&
&
obj
.
default
=
=
=
"
yes
-
if
-
no
-
other
"
)
{
orderHint
+
=
10000
;
}
return
orderHint
;
}
_isDefault
(
obj
)
{
return
"
default
"
in
obj
&
&
obj
.
default
=
=
=
"
yes
"
;
}
_copyObject
(
target
source
)
{
for
(
let
key
in
source
)
{
if
(
[
"
included
"
"
excluded
"
"
appliesTo
"
]
.
includes
(
key
)
)
{
continue
;
}
target
[
key
]
=
source
[
key
]
;
}
return
target
;
}
_isInSection
(
region
locale
config
)
{
if
(
!
config
)
{
return
false
;
}
if
(
config
.
everywhere
)
{
return
true
;
}
let
locales
=
config
.
locales
|
|
{
}
;
let
inLocales
=
locales
.
matches
&
&
locales
.
matches
.
includes
(
locale
)
;
let
inRegions
=
config
.
regions
&
&
config
.
regions
.
includes
(
region
)
;
if
(
locales
.
startsWith
&
&
locales
.
startsWith
.
some
(
key
=
>
locale
.
startsWith
(
key
)
)
)
{
inLocales
=
true
;
}
if
(
config
.
locales
&
&
config
.
regions
)
{
return
inLocales
&
&
inRegions
;
}
return
inLocales
|
|
inRegions
;
}
}
