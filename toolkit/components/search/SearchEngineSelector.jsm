"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SearchEngineSelector
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
jsm
"
}
)
;
const
USER_LOCALE
=
"
USER_LOCALE
"
;
const
USER_REGION
=
"
USER_REGION
"
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logConsole
"
(
)
=
>
{
return
console
.
createInstance
(
{
prefix
:
"
SearchEngineSelector
"
maxLogLevel
:
lazy
.
SearchUtils
.
loggingEnabled
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
function
getAppInfo
(
key
)
{
let
value
=
null
;
try
{
value
=
Services
.
appinfo
[
key
]
.
toLowerCase
(
)
;
}
catch
(
e
)
{
}
return
value
;
}
function
hasAppKey
(
config
key
)
{
return
"
application
"
in
config
&
&
key
in
config
.
application
;
}
function
sectionExcludes
(
config
key
value
)
{
return
hasAppKey
(
config
key
)
&
&
!
config
.
application
[
key
]
.
includes
(
value
)
;
}
function
sectionIncludes
(
config
key
value
)
{
return
hasAppKey
(
config
key
)
&
&
config
.
application
[
key
]
.
includes
(
value
)
;
}
function
isDistroExcluded
(
config
key
distroID
)
{
const
appKey
=
hasAppKey
(
config
key
)
;
if
(
!
appKey
)
{
return
false
;
}
const
distroList
=
config
.
application
[
key
]
;
if
(
distroID
)
{
return
distroList
.
length
&
&
!
distroList
.
includes
(
distroID
)
;
}
return
!
!
distroList
.
length
;
}
function
belowMinVersion
(
config
version
)
{
return
(
hasAppKey
(
config
"
minVersion
"
)
&
&
Services
.
vc
.
compare
(
version
config
.
application
.
minVersion
)
<
0
)
;
}
function
aboveMaxVersion
(
config
version
)
{
return
(
hasAppKey
(
config
"
maxVersion
"
)
&
&
Services
.
vc
.
compare
(
version
config
.
application
.
maxVersion
)
>
0
)
;
}
class
SearchEngineSelector
{
constructor
(
listener
)
{
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
]
)
;
this
.
_remoteConfig
=
lazy
.
RemoteSettings
(
lazy
.
SearchUtils
.
SETTINGS_KEY
)
;
this
.
_listenerAdded
=
false
;
this
.
_onConfigurationUpdated
=
this
.
_onConfigurationUpdated
.
bind
(
this
)
;
this
.
_changeListener
=
listener
;
}
async
getEngineConfiguration
(
)
{
if
(
this
.
_getConfigurationPromise
)
{
return
this
.
_getConfigurationPromise
;
}
this
.
_configuration
=
await
(
this
.
_getConfigurationPromise
=
this
.
_getConfiguration
(
)
)
;
delete
this
.
_getConfigurationPromise
;
if
(
!
this
.
_configuration
?
.
length
)
{
throw
Components
.
Exception
(
"
Failed
to
get
engine
data
from
Remote
Settings
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
if
(
!
this
.
_listenerAdded
)
{
this
.
_remoteConfig
.
on
(
"
sync
"
this
.
_onConfigurationUpdated
)
;
this
.
_listenerAdded
=
true
;
}
return
this
.
_configuration
;
}
async
_getConfiguration
(
firstTime
=
true
)
{
let
result
=
[
]
;
let
failed
=
false
;
try
{
result
=
await
this
.
_remoteConfig
.
get
(
{
order
:
"
id
"
}
)
;
}
catch
(
ex
)
{
lazy
.
logConsole
.
error
(
ex
)
;
failed
=
true
;
}
if
(
!
result
.
length
)
{
lazy
.
logConsole
.
error
(
"
Received
empty
search
configuration
!
"
)
;
failed
=
true
;
}
if
(
firstTime
&
&
failed
)
{
await
this
.
_remoteConfig
.
db
.
clear
(
)
;
return
this
.
_getConfiguration
(
false
)
;
}
return
result
;
}
_onConfigurationUpdated
(
{
data
:
{
current
}
}
)
{
this
.
_configuration
=
current
;
lazy
.
logConsole
.
debug
(
"
Search
configuration
updated
remotely
"
)
;
if
(
this
.
_changeListener
)
{
this
.
_changeListener
(
)
;
}
}
async
fetchEngineConfiguration
(
{
locale
region
channel
=
"
default
"
distroID
experiment
}
)
{
if
(
!
this
.
_configuration
)
{
await
this
.
getEngineConfiguration
(
)
;
}
let
name
=
getAppInfo
(
"
name
"
)
;
let
version
=
getAppInfo
(
"
version
"
)
;
lazy
.
logConsole
.
debug
(
fetchEngineConfiguration
{
locale
}
:
{
region
}
:
{
channel
}
:
{
distroID
}
:
{
experiment
}
:
{
name
}
:
{
version
}
)
;
let
engines
=
[
]
;
const
lcLocale
=
locale
.
toLowerCase
(
)
;
const
lcRegion
=
region
.
toLowerCase
(
)
;
for
(
let
config
of
this
.
_configuration
)
{
const
appliesTo
=
config
.
appliesTo
|
|
[
]
;
const
applies
=
appliesTo
.
filter
(
section
=
>
{
if
(
"
experiment
"
in
section
)
{
if
(
experiment
!
=
section
.
experiment
)
{
return
false
;
}
if
(
section
.
override
)
{
return
true
;
}
}
let
shouldInclude
=
(
)
=
>
{
let
included
=
"
included
"
in
section
&
&
this
.
_isInSection
(
lcRegion
lcLocale
section
.
included
)
;
let
excluded
=
"
excluded
"
in
section
&
&
this
.
_isInSection
(
lcRegion
lcLocale
section
.
excluded
)
;
return
included
&
&
!
excluded
;
}
;
const
distroExcluded
=
(
distroID
&
&
sectionIncludes
(
section
"
excludedDistributions
"
distroID
)
)
|
|
isDistroExcluded
(
section
"
distributions
"
distroID
)
;
if
(
distroID
&
&
!
distroExcluded
&
&
section
.
override
)
{
if
(
"
included
"
in
section
|
|
"
excluded
"
in
section
)
{
return
shouldInclude
(
)
;
}
return
true
;
}
if
(
sectionExcludes
(
section
"
channel
"
channel
)
|
|
sectionExcludes
(
section
"
name
"
name
)
|
|
distroExcluded
|
|
belowMinVersion
(
section
version
)
|
|
aboveMaxVersion
(
section
version
)
)
{
return
false
;
}
return
shouldInclude
(
)
;
}
)
;
let
baseConfig
=
this
.
_copyObject
(
{
}
config
)
;
let
allOverrides
=
applies
.
every
(
e
=
>
"
override
"
in
e
&
&
e
.
override
)
;
if
(
applies
.
length
&
&
!
allOverrides
)
{
for
(
let
section
of
applies
)
{
this
.
_copyObject
(
baseConfig
section
)
;
}
if
(
"
webExtension
"
in
baseConfig
&
&
"
locales
"
in
baseConfig
.
webExtension
)
{
for
(
const
webExtensionLocale
of
baseConfig
.
webExtension
.
locales
)
{
const
engine
=
{
.
.
.
baseConfig
}
;
engine
.
webExtension
=
{
.
.
.
baseConfig
.
webExtension
}
;
delete
engine
.
webExtension
.
locales
;
engine
.
webExtension
.
locale
=
webExtensionLocale
.
replace
(
USER_LOCALE
locale
)
.
replace
(
USER_REGION
lcRegion
)
;
engines
.
push
(
engine
)
;
}
}
else
{
const
engine
=
{
.
.
.
baseConfig
}
;
(
engine
.
webExtension
=
engine
.
webExtension
|
|
{
}
)
.
locale
=
lazy
.
SearchUtils
.
DEFAULT_TAG
;
engines
.
push
(
engine
)
;
}
}
}
let
defaultEngine
;
let
privateEngine
;
function
shouldPrefer
(
setting
hasCurrentDefault
currentDefaultSetting
)
{
if
(
setting
=
=
"
yes
"
&
&
(
!
hasCurrentDefault
|
|
currentDefaultSetting
=
=
"
yes
-
if
-
no
-
other
"
)
)
{
return
true
;
}
return
setting
=
=
"
yes
-
if
-
no
-
other
"
&
&
!
hasCurrentDefault
;
}
for
(
const
engine
of
engines
)
{
engine
.
telemetryId
=
engine
.
telemetryId
?
.
replace
(
USER_LOCALE
locale
)
.
replace
(
USER_REGION
lcRegion
)
;
if
(
"
default
"
in
engine
&
&
shouldPrefer
(
engine
.
default
!
!
defaultEngine
defaultEngine
&
&
defaultEngine
.
default
)
)
{
defaultEngine
=
engine
;
}
if
(
"
defaultPrivate
"
in
engine
&
&
shouldPrefer
(
engine
.
defaultPrivate
!
!
privateEngine
privateEngine
&
&
privateEngine
.
defaultPrivate
)
)
{
privateEngine
=
engine
;
}
}
engines
.
sort
(
this
.
_sort
.
bind
(
this
defaultEngine
privateEngine
)
)
;
let
result
=
{
engines
}
;
if
(
privateEngine
)
{
result
.
privateDefault
=
privateEngine
;
}
if
(
lazy
.
SearchUtils
.
loggingEnabled
)
{
lazy
.
logConsole
.
debug
(
"
fetchEngineConfiguration
:
"
+
result
.
engines
.
map
(
e
=
>
e
.
webExtension
.
id
)
)
;
}
return
result
;
}
_sort
(
defaultEngine
privateEngine
a
b
)
{
return
(
this
.
_sortIndex
(
b
defaultEngine
privateEngine
)
-
this
.
_sortIndex
(
a
defaultEngine
privateEngine
)
)
;
}
_sortIndex
(
obj
defaultEngine
privateEngine
)
{
if
(
obj
=
=
defaultEngine
)
{
return
Number
.
MAX_SAFE_INTEGER
;
}
if
(
obj
=
=
privateEngine
)
{
return
Number
.
MAX_SAFE_INTEGER
-
1
;
}
return
obj
.
orderHint
|
|
0
;
}
_isDefault
(
obj
)
{
return
"
default
"
in
obj
&
&
obj
.
default
=
=
=
"
yes
"
;
}
_copyObject
(
target
source
)
{
for
(
let
key
in
source
)
{
if
(
[
"
included
"
"
excluded
"
"
appliesTo
"
]
.
includes
(
key
)
)
{
continue
;
}
if
(
key
=
=
"
webExtension
"
)
{
if
(
key
in
target
)
{
this
.
_copyObject
(
target
[
key
]
source
[
key
]
)
;
}
else
{
target
[
key
]
=
{
.
.
.
source
[
key
]
}
;
}
}
else
{
target
[
key
]
=
source
[
key
]
;
}
}
return
target
;
}
_isInSection
(
region
locale
config
)
{
if
(
!
config
)
{
return
false
;
}
if
(
config
.
everywhere
)
{
return
true
;
}
let
locales
=
config
.
locales
|
|
{
}
;
let
inLocales
=
"
matches
"
in
locales
&
&
!
!
locales
.
matches
.
find
(
e
=
>
e
.
toLowerCase
(
)
=
=
locale
)
;
let
inRegions
=
"
regions
"
in
config
&
&
!
!
config
.
regions
.
find
(
e
=
>
e
.
toLowerCase
(
)
=
=
region
)
;
if
(
locales
.
startsWith
&
&
locales
.
startsWith
.
some
(
key
=
>
locale
.
startsWith
(
key
)
)
)
{
inLocales
=
true
;
}
if
(
config
.
locales
&
&
config
.
regions
)
{
return
inLocales
&
&
inRegions
;
}
return
inLocales
|
|
inRegions
;
}
}
