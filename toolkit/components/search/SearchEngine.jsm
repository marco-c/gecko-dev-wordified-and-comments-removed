const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
ExtensionParent
:
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
Region
:
"
resource
:
/
/
gre
/
modules
/
Region
.
jsm
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
const
BinaryInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
binaryinputstream
;
1
"
"
nsIBinaryInputStream
"
"
setInputStream
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
(
)
=
>
{
return
console
.
createInstance
(
{
prefix
:
"
SearchEngine
"
maxLogLevel
:
SearchUtils
.
loggingEnabled
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
const
USER_DEFINED
=
"
searchTerms
"
;
const
OS_PARAM_INPUT_ENCODING
=
"
inputEncoding
"
;
const
OS_PARAM_LANGUAGE
=
"
language
"
;
const
OS_PARAM_OUTPUT_ENCODING
=
"
outputEncoding
"
;
const
OS_PARAM_LANGUAGE_DEF
=
"
*
"
;
const
OS_PARAM_OUTPUT_ENCODING_DEF
=
"
UTF
-
8
"
;
const
OS_PARAM_COUNT
=
"
count
"
;
const
OS_PARAM_START_INDEX
=
"
startIndex
"
;
const
OS_PARAM_START_PAGE
=
"
startPage
"
;
const
OS_PARAM_COUNT_DEF
=
"
20
"
;
const
OS_PARAM_START_INDEX_DEF
=
"
1
"
;
const
OS_PARAM_START_PAGE_DEF
=
"
1
"
;
var
OS_UNSUPPORTED_PARAMS
=
[
[
OS_PARAM_COUNT
OS_PARAM_COUNT_DEF
]
[
OS_PARAM_START_INDEX
OS_PARAM_START_INDEX_DEF
]
[
OS_PARAM_START_PAGE
OS_PARAM_START_PAGE_DEF
]
]
;
function
limitURILength
(
str
len
)
{
len
=
len
|
|
140
;
if
(
str
.
length
>
len
)
{
return
str
.
slice
(
0
len
)
+
"
.
.
.
"
;
}
return
str
;
}
function
rescaleIcon
(
byteArray
contentType
size
=
32
)
{
if
(
contentType
=
=
"
image
/
svg
+
xml
"
)
{
throw
new
Error
(
"
Cannot
rescale
SVG
image
"
)
;
}
let
imgTools
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
;
let
arrayBuffer
=
new
Int8Array
(
byteArray
)
.
buffer
;
let
container
=
imgTools
.
decodeImageFromArrayBuffer
(
arrayBuffer
contentType
)
;
let
stream
=
imgTools
.
encodeScaledImage
(
container
"
image
/
png
"
size
size
)
;
let
streamSize
=
stream
.
available
(
)
;
if
(
streamSize
>
SearchUtils
.
MAX_ICON_SIZE
)
{
throw
new
Error
(
"
Icon
is
too
big
"
)
;
}
let
bis
=
new
BinaryInputStream
(
stream
)
;
return
[
bis
.
readByteArray
(
streamSize
)
"
image
/
png
"
]
;
}
const
ParamPreferenceCache
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
initCache
(
)
{
this
.
branch
=
Services
.
prefs
.
getDefaultBranch
(
SearchUtils
.
BROWSER_SEARCH_PREF
+
"
param
.
"
)
;
this
.
cache
=
new
Map
(
)
;
for
(
let
prefName
of
this
.
branch
.
getChildList
(
"
"
)
)
{
this
.
cache
.
set
(
prefName
this
.
branch
.
getCharPref
(
prefName
null
)
)
;
}
this
.
branch
.
addObserver
(
"
"
this
true
)
;
}
observe
(
subject
topic
data
)
{
this
.
cache
.
set
(
data
this
.
branch
.
getCharPref
(
data
null
)
)
;
}
getPref
(
prefName
)
{
if
(
!
this
.
cache
)
{
this
.
initCache
(
)
;
}
return
this
.
cache
.
get
(
prefName
)
;
}
}
;
class
QueryParameter
{
constructor
(
name
value
purpose
)
{
if
(
!
name
|
|
value
=
=
null
)
{
throw
Components
.
Exception
(
"
missing
name
or
value
for
QueryParameter
!
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
name
=
name
;
this
.
_value
=
value
;
this
.
purpose
=
purpose
;
}
get
value
(
)
{
return
this
.
_value
;
}
toJSON
(
)
{
const
result
=
{
name
:
this
.
name
value
:
this
.
value
}
;
if
(
this
.
purpose
)
{
result
.
purpose
=
this
.
purpose
;
}
return
result
;
}
}
class
QueryPreferenceParameter
extends
QueryParameter
{
constructor
(
name
prefName
purpose
)
{
super
(
name
prefName
purpose
)
;
}
get
value
(
)
{
const
prefValue
=
ParamPreferenceCache
.
getPref
(
this
.
_value
)
;
return
prefValue
?
encodeURIComponent
(
prefValue
)
:
null
;
}
toJSON
(
)
{
const
result
=
{
condition
:
"
pref
"
mozparam
:
true
name
:
this
.
name
pref
:
this
.
_value
}
;
if
(
this
.
purpose
)
{
result
.
purpose
=
this
.
purpose
;
}
return
result
;
}
}
function
ParamSubstitution
(
paramValue
searchTerms
engine
)
{
const
PARAM_REGEXP
=
/
\
{
(
(
?
:
\
w
+
:
)
?
\
w
+
)
(
\
?
?
)
\
}
/
g
;
return
paramValue
.
replace
(
PARAM_REGEXP
function
(
match
name
optional
)
{
if
(
name
=
=
USER_DEFINED
)
{
return
searchTerms
;
}
if
(
name
=
=
OS_PARAM_INPUT_ENCODING
)
{
return
engine
.
queryCharset
;
}
if
(
name
.
startsWith
(
"
moz
:
"
)
&
&
engine
.
isAppProvided
)
{
if
(
name
=
=
SearchUtils
.
MOZ_PARAM
.
LOCALE
)
{
return
Services
.
locale
.
requestedLocale
;
}
if
(
name
=
=
SearchUtils
.
MOZ_PARAM
.
DATE
)
{
let
date
=
new
Date
(
)
;
let
pad
=
number
=
>
number
.
toString
(
)
.
padStart
(
2
"
0
"
)
;
return
(
String
(
date
.
getFullYear
(
)
)
+
pad
(
date
.
getMonth
(
)
+
1
)
+
pad
(
date
.
getDate
(
)
)
+
pad
(
date
.
getHours
(
)
)
)
;
}
if
(
name
=
=
SearchUtils
.
MOZ_PARAM
.
DIST_ID
)
{
return
Services
.
prefs
.
getCharPref
(
SearchUtils
.
BROWSER_SEARCH_PREF
+
"
distributionID
"
Services
.
appinfo
.
distributionID
|
|
"
"
)
;
}
if
(
name
=
=
SearchUtils
.
MOZ_PARAM
.
OFFICIAL
)
{
if
(
Services
.
prefs
.
getBoolPref
(
SearchUtils
.
BROWSER_SEARCH_PREF
+
"
official
"
AppConstants
.
MOZ_OFFICIAL_BRANDING
)
)
{
return
"
official
"
;
}
return
"
unofficial
"
;
}
}
if
(
name
=
=
OS_PARAM_LANGUAGE
)
{
return
Services
.
locale
.
requestedLocale
|
|
OS_PARAM_LANGUAGE_DEF
;
}
if
(
name
=
=
OS_PARAM_OUTPUT_ENCODING
)
{
return
OS_PARAM_OUTPUT_ENCODING_DEF
;
}
if
(
optional
)
{
return
"
"
;
}
for
(
let
param
of
OS_UNSUPPORTED_PARAMS
)
{
if
(
name
=
=
param
[
0
]
)
{
return
param
[
1
]
;
}
}
return
match
;
}
)
;
}
class
EngineURL
{
params
=
[
]
;
rels
=
[
]
;
constructor
(
mimeType
requestMethod
template
)
{
if
(
!
mimeType
|
|
!
requestMethod
|
|
!
template
)
{
throw
Components
.
Exception
(
"
missing
mimeType
method
or
template
for
EngineURL
!
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
var
method
=
requestMethod
.
toUpperCase
(
)
;
var
type
=
mimeType
.
toLowerCase
(
)
;
if
(
method
!
=
"
GET
"
&
&
method
!
=
"
POST
"
)
{
throw
Components
.
Exception
(
'
method
passed
to
EngineURL
must
be
"
GET
"
or
"
POST
"
'
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
type
=
type
;
this
.
method
=
method
;
this
.
_queryCharset
=
SearchUtils
.
DEFAULT_QUERY_CHARSET
;
var
templateURI
=
SearchUtils
.
makeURI
(
template
)
;
if
(
!
templateURI
)
{
throw
Components
.
Exception
(
"
new
EngineURL
:
template
is
not
a
valid
URI
!
"
Cr
.
NS_ERROR_FAILURE
)
;
}
switch
(
templateURI
.
scheme
)
{
case
"
http
"
:
case
"
https
"
:
this
.
template
=
template
;
break
;
default
:
throw
Components
.
Exception
(
"
new
EngineURL
:
template
uses
invalid
scheme
!
"
Cr
.
NS_ERROR_FAILURE
)
;
}
this
.
templateHost
=
templateURI
.
host
;
}
addParam
(
name
value
purpose
)
{
this
.
params
.
push
(
new
QueryParameter
(
name
value
purpose
)
)
;
}
_addMozParam
(
param
)
{
const
purpose
=
param
.
purpose
|
|
undefined
;
if
(
param
.
condition
&
&
param
.
condition
=
=
"
pref
"
)
{
this
.
params
.
push
(
new
QueryPreferenceParameter
(
param
.
name
param
.
pref
purpose
)
)
;
}
else
{
this
.
addParam
(
param
.
name
param
.
value
|
|
undefined
purpose
)
;
}
}
getSubmission
(
searchTerms
engine
purpose
)
{
var
url
=
ParamSubstitution
(
this
.
template
searchTerms
engine
)
;
var
requestPurpose
=
purpose
|
|
"
searchbar
"
;
if
(
requestPurpose
!
=
"
searchbar
"
&
&
!
this
.
params
.
some
(
p
=
>
p
.
purpose
&
&
p
.
purpose
=
=
requestPurpose
)
)
{
requestPurpose
=
"
searchbar
"
;
}
let
dataArray
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
params
.
length
;
+
+
i
)
{
var
param
=
this
.
params
[
i
]
;
if
(
param
.
purpose
&
&
param
.
purpose
!
=
requestPurpose
)
{
continue
;
}
let
paramValue
=
param
.
value
;
if
(
engine
.
_regionParams
?
.
[
Region
.
current
]
)
{
let
override
=
engine
.
_regionParams
[
Region
.
current
]
.
find
(
p
=
>
p
.
name
=
=
param
.
name
)
;
if
(
override
)
{
paramValue
=
override
.
value
;
}
}
if
(
paramValue
!
=
null
)
{
var
value
=
ParamSubstitution
(
paramValue
searchTerms
engine
)
;
dataArray
.
push
(
param
.
name
+
"
=
"
+
value
)
;
}
}
let
dataString
=
dataArray
.
join
(
"
&
"
)
;
var
postData
=
null
;
if
(
this
.
method
=
=
"
GET
"
)
{
if
(
dataString
)
{
if
(
url
.
includes
(
"
?
"
)
)
{
url
=
{
url
}
&
{
dataString
}
;
}
else
{
url
=
{
url
}
?
{
dataString
}
;
}
}
}
else
if
(
this
.
method
=
=
"
POST
"
)
{
var
stringStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stringStream
.
data
=
dataString
;
postData
=
Cc
[
"
mozilla
.
org
/
network
/
mime
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIMIMEInputStream
)
;
postData
.
addHeader
(
"
Content
-
Type
"
"
application
/
x
-
www
-
form
-
urlencoded
"
)
;
postData
.
setData
(
stringStream
)
;
}
return
new
Submission
(
Services
.
io
.
newURI
(
url
)
postData
)
;
}
_getTermsParameterName
(
)
{
let
queryParam
=
this
.
params
.
find
(
p
=
>
p
.
value
=
=
"
{
"
+
USER_DEFINED
+
"
}
"
)
;
return
queryParam
?
queryParam
.
name
:
"
"
;
}
_hasRelation
(
rel
)
{
return
this
.
rels
.
some
(
e
=
>
e
=
=
rel
.
toLowerCase
(
)
)
;
}
_initWithJSON
(
json
)
{
if
(
!
json
.
params
)
{
return
;
}
this
.
rels
=
json
.
rels
;
for
(
let
i
=
0
;
i
<
json
.
params
.
length
;
+
+
i
)
{
let
param
=
json
.
params
[
i
]
;
if
(
!
param
.
mozparam
&
&
!
param
.
purpose
)
{
this
.
addParam
(
param
.
name
param
.
value
)
;
}
}
}
toJSON
(
)
{
var
json
=
{
params
:
this
.
params
rels
:
this
.
rels
template
:
this
.
template
}
;
if
(
this
.
type
!
=
SearchUtils
.
URL_TYPE
.
SEARCH
)
{
json
.
type
=
this
.
type
;
}
if
(
this
.
method
!
=
"
GET
"
)
{
json
.
method
=
this
.
method
;
}
return
json
;
}
}
class
SearchEngine
{
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsISearchEngine
"
]
)
;
_metaData
=
{
}
;
_loadPath
=
null
;
_description
=
"
"
;
_engineToUpdate
=
null
;
_hasPreferredIcon
=
null
;
_name
=
null
;
_queryCharset
=
null
;
__searchForm
=
null
;
_sendAttributionRequest
=
false
;
_updateInterval
=
null
;
_updateURL
=
null
;
_iconUpdateURL
=
null
;
_extensionID
=
null
;
_locale
=
null
;
_isAppProvided
=
false
;
_orderHint
=
null
;
_telemetryId
=
null
;
_engineAddedToStore
=
false
;
_definedAliases
=
[
]
;
_urls
=
[
]
;
_searchUrlQueryParamName
=
null
;
_searchUrlPublicSuffix
=
null
;
constructor
(
options
=
{
}
)
{
if
(
!
(
"
isAppProvided
"
in
options
)
)
{
throw
new
Error
(
"
isAppProvided
missing
from
options
.
"
)
;
}
if
(
!
(
"
loadPath
"
in
options
)
)
{
throw
new
Error
(
"
loadPath
missing
from
options
.
"
)
;
}
this
.
_isAppProvided
=
options
.
isAppProvided
;
this
.
_loadPath
=
options
.
loadPath
;
}
get
_searchForm
(
)
{
return
this
.
__searchForm
;
}
set
_searchForm
(
value
)
{
if
(
/
^
https
?
:
/
i
.
test
(
value
)
)
{
this
.
__searchForm
=
value
;
}
else
{
logConsole
.
debug
(
"
_searchForm
:
Invalid
URL
dropped
for
"
this
.
_name
|
|
"
the
current
engine
"
)
;
}
}
_getURLOfType
(
type
rel
)
{
for
(
let
url
of
this
.
_urls
)
{
if
(
url
.
type
=
=
type
&
&
(
!
rel
|
|
url
.
_hasRelation
(
rel
)
)
)
{
return
url
;
}
}
return
null
;
}
_getIconKey
(
width
height
)
{
let
keyObj
=
{
width
height
}
;
return
JSON
.
stringify
(
keyObj
)
;
}
_addIconToMap
(
width
height
uriSpec
)
{
if
(
width
=
=
16
&
&
height
=
=
16
)
{
return
;
}
this
.
_iconMapObj
=
this
.
_iconMapObj
|
|
{
}
;
let
key
=
this
.
_getIconKey
(
width
height
)
;
this
.
_iconMapObj
[
key
]
=
uriSpec
;
}
_setIcon
(
iconURL
isPreferred
width
height
)
{
var
uri
=
SearchUtils
.
makeURI
(
iconURL
)
;
if
(
!
uri
)
{
return
;
}
logConsole
.
debug
(
"
_setIcon
:
Setting
icon
url
for
"
this
.
name
"
to
"
limitURILength
(
uri
.
spec
)
)
;
switch
(
uri
.
scheme
)
{
case
"
moz
-
extension
"
:
case
"
data
"
:
if
(
!
this
.
_hasPreferredIcon
|
|
isPreferred
)
{
this
.
_iconURI
=
uri
;
this
.
_hasPreferredIcon
=
isPreferred
;
}
if
(
width
&
&
height
)
{
this
.
_addIconToMap
(
width
height
iconURL
)
;
}
break
;
case
"
http
"
:
case
"
https
"
:
case
"
ftp
"
:
var
chan
=
SearchUtils
.
makeChannel
(
uri
)
;
let
iconLoadCallback
=
function
(
byteArray
)
{
if
(
this
.
_hasPreferredIcon
&
&
!
isPreferred
)
{
return
;
}
if
(
!
byteArray
)
{
logConsole
.
warn
(
"
iconLoadCallback
:
load
failed
"
)
;
return
;
}
let
contentType
=
chan
.
contentType
;
if
(
byteArray
.
length
>
SearchUtils
.
MAX_ICON_SIZE
)
{
try
{
logConsole
.
debug
(
"
iconLoadCallback
:
rescaling
icon
"
)
;
[
byteArray
contentType
]
=
rescaleIcon
(
byteArray
contentType
)
;
}
catch
(
ex
)
{
logConsole
.
error
(
"
Unable
to
set
icon
for
the
search
engine
:
"
ex
)
;
return
;
}
}
if
(
!
contentType
.
startsWith
(
"
image
/
"
)
)
{
contentType
=
"
image
/
x
-
icon
"
;
}
let
dataURL
=
"
data
:
"
+
contentType
+
"
;
base64
"
+
btoa
(
String
.
fromCharCode
.
apply
(
null
byteArray
)
)
;
this
.
_iconURI
=
SearchUtils
.
makeURI
(
dataURL
)
;
if
(
width
&
&
height
)
{
this
.
_addIconToMap
(
width
height
dataURL
)
;
}
if
(
this
.
_engineAddedToStore
)
{
SearchUtils
.
notifyAction
(
this
SearchUtils
.
MODIFIED_TYPE
.
CHANGED
)
;
}
this
.
_hasPreferredIcon
=
isPreferred
;
}
;
var
listener
=
new
SearchUtils
.
LoadListener
(
chan
iconLoadCallback
.
bind
(
this
.
_engineToUpdate
|
|
this
)
)
;
chan
.
notificationCallbacks
=
listener
;
chan
.
asyncOpen
(
listener
)
;
break
;
}
}
_getEngineURLFromMetaData
(
type
params
)
{
let
url
=
new
EngineURL
(
type
params
.
method
|
|
"
GET
"
params
.
template
)
;
if
(
params
.
mozParams
)
{
for
(
let
p
of
params
.
mozParams
)
{
if
(
(
p
.
condition
|
|
p
.
purpose
)
&
&
!
this
.
isAppProvided
)
{
continue
;
}
url
.
_addMozParam
(
p
)
;
}
}
if
(
params
.
postParams
)
{
if
(
Array
.
isArray
(
params
.
postParams
)
)
{
for
(
let
{
name
value
}
of
params
.
postParams
)
{
url
.
addParam
(
name
value
)
;
}
}
else
{
for
(
let
[
name
value
]
of
new
URLSearchParams
(
params
.
postParams
)
)
{
url
.
addParam
(
name
value
)
;
}
}
}
if
(
params
.
getParams
)
{
if
(
Array
.
isArray
(
params
.
getParams
)
)
{
for
(
let
{
name
value
}
of
params
.
getParams
)
{
url
.
addParam
(
name
value
)
;
}
}
else
{
for
(
let
[
name
value
]
of
new
URLSearchParams
(
params
.
getParams
)
)
{
url
.
addParam
(
name
value
)
;
}
}
}
return
url
;
}
_initFromManifest
(
extensionID
extensionBaseURI
manifest
locale
configuration
=
{
}
)
{
let
{
IconDetails
}
=
ExtensionParent
;
let
searchProvider
=
manifest
.
chrome_settings_overrides
.
search_provider
;
let
iconURL
=
manifest
.
iconURL
|
|
searchProvider
.
favicon_url
;
let
icons
=
manifest
.
icons
;
let
iconList
=
[
]
;
if
(
icons
)
{
iconList
=
Object
.
entries
(
icons
)
.
map
(
icon
=
>
{
return
{
width
:
icon
[
0
]
height
:
icon
[
0
]
url
:
extensionBaseURI
.
resolve
(
icon
[
1
]
)
}
;
}
)
;
}
if
(
!
iconURL
)
{
iconURL
=
icons
&
&
extensionBaseURI
.
resolve
(
IconDetails
.
getPreferredIcon
(
icons
)
.
icon
)
;
}
if
(
this
.
_isAppProvided
)
{
if
(
configuration
.
telemetryId
)
{
this
.
_telemetryId
=
configuration
.
telemetryId
;
}
else
{
let
telemetryId
=
extensionID
.
split
(
"
"
)
[
0
]
;
if
(
locale
!
=
SearchUtils
.
DEFAULT_TAG
)
{
telemetryId
+
=
"
-
"
+
locale
;
}
this
.
_telemetryId
=
telemetryId
;
}
}
this
.
_extensionID
=
extensionID
;
this
.
_locale
=
locale
;
this
.
_orderHint
=
configuration
.
orderHint
;
this
.
_name
=
searchProvider
.
name
.
trim
(
)
;
this
.
_regionParams
=
configuration
.
regionParams
;
this
.
_sendAttributionRequest
=
configuration
.
sendAttributionRequest
?
?
false
;
this
.
_definedAliases
=
[
]
;
if
(
Array
.
isArray
(
searchProvider
.
keyword
)
)
{
this
.
_definedAliases
=
searchProvider
.
keyword
.
map
(
k
=
>
k
.
trim
(
)
)
;
}
else
if
(
searchProvider
.
keyword
?
.
trim
(
)
)
{
this
.
_definedAliases
=
[
searchProvider
.
keyword
?
.
trim
(
)
]
;
}
this
.
_description
=
manifest
.
description
;
if
(
iconURL
)
{
this
.
_setIcon
(
iconURL
true
)
;
}
if
(
iconList
)
{
for
(
let
icon
of
iconList
)
{
this
.
_addIconToMap
(
icon
.
size
icon
.
size
icon
.
url
)
;
}
}
this
.
_setUrls
(
searchProvider
configuration
)
;
}
_setUrls
(
searchProvider
configuration
=
{
}
)
{
if
(
searchProvider
.
params
)
{
searchProvider
.
params
=
searchProvider
.
params
.
filter
(
param
=
>
{
return
!
(
param
.
value
&
&
param
.
value
.
startsWith
(
"
__MSG_
"
)
)
;
}
)
;
}
let
postParams
=
configuration
.
params
?
.
searchUrlPostParams
|
|
searchProvider
.
search_url_post_params
|
|
"
"
;
let
url
=
this
.
_getEngineURLFromMetaData
(
SearchUtils
.
URL_TYPE
.
SEARCH
{
method
:
(
postParams
&
&
"
POST
"
)
|
|
"
GET
"
template
:
decodeURI
(
searchProvider
.
search_url
)
getParams
:
configuration
.
params
?
.
searchUrlGetParams
|
|
searchProvider
.
search_url_get_params
|
|
"
"
postParams
mozParams
:
configuration
.
extraParams
|
|
searchProvider
.
params
|
|
[
]
}
)
;
this
.
_urls
.
push
(
url
)
;
if
(
searchProvider
.
suggest_url
)
{
let
suggestPostParams
=
configuration
.
params
?
.
suggestUrlPostParams
|
|
searchProvider
.
suggest_url_post_params
|
|
"
"
;
url
=
this
.
_getEngineURLFromMetaData
(
SearchUtils
.
URL_TYPE
.
SUGGEST_JSON
{
method
:
(
suggestPostParams
&
&
"
POST
"
)
|
|
"
GET
"
template
:
searchProvider
.
suggest_url
getParams
:
configuration
.
params
?
.
suggestUrlGetParams
|
|
searchProvider
.
suggest_url_get_params
|
|
"
"
postParams
:
suggestPostParams
}
)
;
this
.
_urls
.
push
(
url
)
;
}
if
(
searchProvider
.
encoding
)
{
this
.
_queryCharset
=
searchProvider
.
encoding
;
}
this
.
__searchForm
=
searchProvider
.
search_form
;
}
checkSearchUrlMatchesManifest
(
searchProvider
)
{
let
existingUrl
=
this
.
_getURLOfType
(
SearchUtils
.
URL_TYPE
.
SEARCH
)
;
let
newUrl
=
this
.
_getEngineURLFromMetaData
(
SearchUtils
.
URL_TYPE
.
SEARCH
{
method
:
(
searchProvider
.
search_url_post_params
&
&
"
POST
"
)
|
|
"
GET
"
template
:
decodeURI
(
searchProvider
.
search_url
)
getParams
:
searchProvider
.
search_url_get_params
|
|
"
"
postParams
:
searchProvider
.
search_url_post_params
|
|
"
"
}
)
;
let
existingSubmission
=
existingUrl
.
getSubmission
(
"
"
this
)
;
let
newSubmission
=
newUrl
.
getSubmission
(
"
"
this
)
;
return
(
existingSubmission
.
uri
.
equals
(
newSubmission
.
uri
)
&
&
existingSubmission
.
postData
=
=
newSubmission
.
postData
)
;
}
_updateFromManifest
(
extensionID
extensionBaseURI
manifest
locale
configuration
=
{
}
)
{
this
.
_urls
=
[
]
;
this
.
_iconMapObj
=
null
;
this
.
_initFromManifest
(
extensionID
extensionBaseURI
manifest
locale
configuration
)
;
SearchUtils
.
notifyAction
(
this
SearchUtils
.
MODIFIED_TYPE
.
CHANGED
)
;
}
overrideWithExtension
(
extensionID
manifest
)
{
this
.
_overriddenData
=
{
urls
:
this
.
_urls
queryCharset
:
this
.
_queryCharset
searchForm
:
this
.
__searchForm
}
;
this
.
_urls
=
[
]
;
this
.
setAttr
(
"
overriddenBy
"
extensionID
)
;
this
.
_setUrls
(
manifest
.
chrome_settings_overrides
.
search_provider
)
;
SearchUtils
.
notifyAction
(
this
SearchUtils
.
MODIFIED_TYPE
.
CHANGED
)
;
}
removeExtensionOverride
(
)
{
if
(
this
.
getAttr
(
"
overriddenBy
"
)
)
{
this
.
_urls
=
this
.
_overriddenData
.
urls
;
this
.
_queryCharset
=
this
.
_overriddenData
.
queryCharset
;
this
.
__searchForm
=
this
.
_overriddenData
.
searchForm
;
delete
this
.
_overriddenData
;
this
.
clearAttr
(
"
overriddenBy
"
)
;
SearchUtils
.
notifyAction
(
this
SearchUtils
.
MODIFIED_TYPE
.
CHANGED
)
;
}
}
_initWithJSON
(
json
)
{
this
.
_name
=
json
.
_name
;
this
.
_description
=
json
.
description
;
this
.
_hasPreferredIcon
=
json
.
_hasPreferredIcon
=
=
undefined
;
this
.
_queryCharset
=
json
.
queryCharset
|
|
SearchUtils
.
DEFAULT_QUERY_CHARSET
;
this
.
__searchForm
=
json
.
__searchForm
;
this
.
_updateInterval
=
json
.
_updateInterval
|
|
null
;
this
.
_updateURL
=
json
.
_updateURL
|
|
null
;
this
.
_iconUpdateURL
=
json
.
_iconUpdateURL
|
|
null
;
this
.
_iconURI
=
SearchUtils
.
makeURI
(
json
.
_iconURL
)
;
this
.
_iconMapObj
=
json
.
_iconMapObj
;
this
.
_metaData
=
json
.
_metaData
|
|
{
}
;
this
.
_orderHint
=
json
.
_orderHint
|
|
null
;
this
.
_definedAliases
=
json
.
_definedAliases
|
|
[
]
;
if
(
json
.
_definedAlias
)
{
this
.
_definedAliases
.
push
(
json
.
_definedAlias
)
;
}
this
.
_filePath
=
json
.
filePath
|
|
json
.
_filePath
|
|
null
;
this
.
_extensionID
=
json
.
extensionID
|
|
json
.
_extensionID
|
|
null
;
this
.
_locale
=
json
.
extensionLocale
|
|
json
.
_locale
|
|
null
;
for
(
let
i
=
0
;
i
<
json
.
_urls
.
length
;
+
+
i
)
{
let
url
=
json
.
_urls
[
i
]
;
let
engineURL
=
new
EngineURL
(
url
.
type
|
|
SearchUtils
.
URL_TYPE
.
SEARCH
url
.
method
|
|
"
GET
"
url
.
template
)
;
engineURL
.
_initWithJSON
(
url
)
;
this
.
_urls
.
push
(
engineURL
)
;
}
}
toJSON
(
)
{
if
(
this
.
_isAppProvided
)
{
return
{
_name
:
this
.
name
_isAppProvided
:
true
_metaData
:
this
.
_metaData
}
;
}
const
fieldsToCopy
=
[
"
_name
"
"
_loadPath
"
"
description
"
"
__searchForm
"
"
_iconURL
"
"
_iconMapObj
"
"
_metaData
"
"
_urls
"
"
_isAppProvided
"
"
_orderHint
"
"
_telemetryId
"
"
_updateInterval
"
"
_updateURL
"
"
_iconUpdateURL
"
"
_filePath
"
"
_extensionID
"
"
_locale
"
"
_definedAliases
"
]
;
let
json
=
{
}
;
for
(
const
field
of
fieldsToCopy
)
{
if
(
field
in
this
)
{
json
[
field
]
=
this
[
field
]
;
}
}
if
(
!
this
.
_hasPreferredIcon
)
{
json
.
_hasPreferredIcon
=
this
.
_hasPreferredIcon
;
}
if
(
this
.
queryCharset
!
=
SearchUtils
.
DEFAULT_QUERY_CHARSET
)
{
json
.
queryCharset
=
this
.
queryCharset
;
}
return
json
;
}
setAttr
(
name
val
)
{
this
.
_metaData
[
name
]
=
val
;
}
getAttr
(
name
)
{
return
this
.
_metaData
[
name
]
|
|
undefined
;
}
clearAttr
(
name
)
{
delete
this
.
_metaData
[
name
]
;
}
get
alias
(
)
{
return
this
.
getAttr
(
"
alias
"
)
;
}
set
alias
(
val
)
{
var
value
=
val
?
val
.
trim
(
)
:
null
;
this
.
setAttr
(
"
alias
"
value
)
;
SearchUtils
.
notifyAction
(
this
SearchUtils
.
MODIFIED_TYPE
.
CHANGED
)
;
}
get
aliases
(
)
{
return
[
.
.
.
(
this
.
getAttr
(
"
alias
"
)
?
[
this
.
getAttr
(
"
alias
"
)
]
:
[
]
)
.
.
.
this
.
_definedAliases
]
;
}
get
telemetryId
(
)
{
let
telemetryId
=
this
.
_telemetryId
|
|
other
-
{
this
.
name
}
;
if
(
this
.
getAttr
(
"
overriddenBy
"
)
)
{
return
telemetryId
+
"
-
addon
"
;
}
return
telemetryId
;
}
get
identifier
(
)
{
return
this
.
isAppProvided
?
this
.
_telemetryId
:
null
;
}
get
description
(
)
{
return
this
.
_description
;
}
get
hidden
(
)
{
return
this
.
getAttr
(
"
hidden
"
)
|
|
false
;
}
set
hidden
(
val
)
{
var
value
=
!
!
val
;
if
(
value
!
=
this
.
hidden
)
{
this
.
setAttr
(
"
hidden
"
value
)
;
SearchUtils
.
notifyAction
(
this
SearchUtils
.
MODIFIED_TYPE
.
CHANGED
)
;
}
}
get
iconURI
(
)
{
if
(
this
.
_iconURI
)
{
return
this
.
_iconURI
;
}
return
null
;
}
get
_iconURL
(
)
{
if
(
!
this
.
_iconURI
)
{
return
"
"
;
}
return
this
.
_iconURI
.
spec
;
}
get
_location
(
)
{
if
(
this
.
_uri
)
{
return
this
.
_uri
.
spec
;
}
return
this
.
_loadPath
;
}
get
isAppProvided
(
)
{
return
!
!
(
this
.
_extensionID
&
&
this
.
_isAppProvided
)
;
}
get
_hasUpdates
(
)
{
return
false
;
}
get
name
(
)
{
return
this
.
_name
;
}
get
searchForm
(
)
{
return
this
.
_getSearchFormWithPurpose
(
)
;
}
get
sendAttributionRequest
(
)
{
return
this
.
_sendAttributionRequest
;
}
_getSearchFormWithPurpose
(
purpose
)
{
var
searchFormURL
=
this
.
_getURLOfType
(
SearchUtils
.
URL_TYPE
.
SEARCH
"
searchform
"
)
;
if
(
searchFormURL
)
{
let
submission
=
searchFormURL
.
getSubmission
(
"
"
this
purpose
)
;
if
(
!
submission
.
postData
)
{
return
submission
.
uri
.
spec
;
}
}
if
(
!
this
.
_searchForm
)
{
var
htmlUrl
=
this
.
_getURLOfType
(
SearchUtils
.
URL_TYPE
.
SEARCH
)
;
if
(
!
htmlUrl
)
{
throw
Components
.
Exception
(
"
Engine
has
no
HTML
URL
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
this
.
_searchForm
=
SearchUtils
.
makeURI
(
htmlUrl
.
template
)
.
prePath
;
}
return
ParamSubstitution
(
this
.
_searchForm
"
"
this
)
;
}
get
queryCharset
(
)
{
return
this
.
_queryCharset
|
|
SearchUtils
.
DEFAULT_QUERY_CHARSET
;
}
get
_defaultMobileResponseType
(
)
{
let
type
=
SearchUtils
.
URL_TYPE
.
SEARCH
;
let
isTablet
=
Services
.
sysinfo
.
get
(
"
tablet
"
)
;
if
(
isTablet
&
&
this
.
supportsResponseType
(
"
application
/
x
-
moz
-
tabletsearch
"
)
)
{
type
=
"
application
/
x
-
moz
-
tabletsearch
"
;
}
else
if
(
!
isTablet
&
&
this
.
supportsResponseType
(
"
application
/
x
-
moz
-
phonesearch
"
)
)
{
type
=
"
application
/
x
-
moz
-
phonesearch
"
;
}
Object
.
defineProperty
(
this
"
_defaultMobileResponseType
"
{
value
:
type
configurable
:
true
}
)
;
return
type
;
}
getSubmission
(
data
responseType
purpose
)
{
if
(
!
responseType
)
{
responseType
=
AppConstants
.
platform
=
=
"
android
"
?
this
.
_defaultMobileResponseType
:
SearchUtils
.
URL_TYPE
.
SEARCH
;
}
var
url
=
this
.
_getURLOfType
(
responseType
)
;
if
(
!
url
)
{
return
null
;
}
if
(
!
data
)
{
return
new
Submission
(
SearchUtils
.
makeURI
(
this
.
_getSearchFormWithPurpose
(
purpose
)
)
)
;
}
var
submissionData
=
"
"
;
try
{
submissionData
=
Services
.
textToSubURI
.
ConvertAndEscape
(
this
.
queryCharset
data
)
;
}
catch
(
ex
)
{
logConsole
.
warn
(
"
getSubmission
:
Falling
back
to
default
queryCharset
!
"
)
;
submissionData
=
Services
.
textToSubURI
.
ConvertAndEscape
(
SearchUtils
.
DEFAULT_QUERY_CHARSET
data
)
;
}
return
url
.
getSubmission
(
submissionData
this
purpose
)
;
}
get
searchUrlQueryParamName
(
)
{
if
(
this
.
_searchUrlQueryParamName
!
=
null
)
{
return
this
.
_searchUrlQueryParamName
;
}
let
submission
=
this
.
getSubmission
(
"
{
searchTerms
}
"
SearchUtils
.
URL_TYPE
.
SEARCH
)
;
if
(
submission
.
postData
)
{
Cu
.
reportError
(
"
searchUrlQueryParamName
can
'
t
handle
POST
urls
.
"
)
;
return
(
this
.
_searchUrlQueryParamName
=
"
"
)
;
}
let
queryParams
=
new
URLSearchParams
(
submission
.
uri
.
query
)
;
let
searchUrlQueryParamName
=
"
"
;
for
(
let
[
key
value
]
of
queryParams
)
{
if
(
value
=
=
"
{
searchTerms
}
"
)
{
searchUrlQueryParamName
=
key
;
}
}
return
(
this
.
_searchUrlQueryParamName
=
searchUrlQueryParamName
)
;
}
get
searchUrlPublicSuffix
(
)
{
if
(
this
.
_searchUrlPublicSuffix
!
=
null
)
{
return
this
.
_searchUrlPublicSuffix
;
}
let
submission
=
this
.
getSubmission
(
"
{
searchTerms
}
"
SearchUtils
.
URL_TYPE
.
SEARCH
)
;
let
searchURLPublicSuffix
=
Services
.
eTLD
.
getKnownPublicSuffix
(
submission
.
uri
)
;
return
(
this
.
_searchUrlPublicSuffix
=
searchURLPublicSuffix
)
;
}
supportsResponseType
(
type
)
{
return
this
.
_getURLOfType
(
type
)
!
=
null
;
}
getResultDomain
(
responseType
)
{
if
(
!
responseType
)
{
responseType
=
AppConstants
.
platform
=
=
"
android
"
?
this
.
_defaultMobileResponseType
:
SearchUtils
.
URL_TYPE
.
SEARCH
;
}
let
url
=
this
.
_getURLOfType
(
responseType
)
;
if
(
url
)
{
return
url
.
templateHost
;
}
return
"
"
;
}
getURLParsingInfo
(
)
{
let
responseType
=
AppConstants
.
platform
=
=
"
android
"
?
this
.
_defaultMobileResponseType
:
SearchUtils
.
URL_TYPE
.
SEARCH
;
let
url
=
this
.
_getURLOfType
(
responseType
)
;
if
(
!
url
|
|
url
.
method
!
=
"
GET
"
)
{
return
null
;
}
let
termsParameterName
=
url
.
_getTermsParameterName
(
)
;
if
(
!
termsParameterName
)
{
return
null
;
}
let
templateUrl
=
Services
.
io
.
newURI
(
url
.
template
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
return
{
mainDomain
:
templateUrl
.
host
path
:
templateUrl
.
filePath
.
toLowerCase
(
)
termsParameterName
}
;
}
get
wrappedJSObject
(
)
{
return
this
;
}
getIconURLBySize
(
width
height
)
{
if
(
width
=
=
16
&
&
height
=
=
16
)
{
return
this
.
_iconURL
;
}
if
(
!
this
.
_iconMapObj
)
{
return
null
;
}
let
key
=
this
.
_getIconKey
(
width
height
)
;
if
(
key
in
this
.
_iconMapObj
)
{
return
this
.
_iconMapObj
[
key
]
;
}
return
null
;
}
getIcons
(
)
{
let
result
=
[
]
;
if
(
this
.
_iconURL
)
{
result
.
push
(
{
width
:
16
height
:
16
url
:
this
.
_iconURL
}
)
;
}
if
(
!
this
.
_iconMapObj
)
{
return
result
;
}
for
(
let
key
of
Object
.
keys
(
this
.
_iconMapObj
)
)
{
let
iconSize
=
JSON
.
parse
(
key
)
;
result
.
push
(
{
width
:
iconSize
.
width
height
:
iconSize
.
height
url
:
this
.
_iconMapObj
[
key
]
}
)
;
}
return
result
;
}
speculativeConnect
(
options
)
{
if
(
!
options
|
|
!
options
.
window
)
{
Cu
.
reportError
(
"
invalid
options
arg
passed
to
nsISearchEngine
.
speculativeConnect
"
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
connector
=
Services
.
io
.
QueryInterface
(
Ci
.
nsISpeculativeConnect
)
;
let
searchURI
=
this
.
getSubmission
(
"
dummy
"
)
.
uri
;
let
callbacks
=
options
.
window
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
;
let
attrs
=
options
.
originAttributes
;
if
(
!
attrs
)
{
attrs
=
options
.
window
.
docShell
.
getOriginAttributes
(
)
;
}
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
searchURI
attrs
)
;
try
{
connector
.
speculativeConnect
(
searchURI
principal
callbacks
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
this
.
supportsResponseType
(
SearchUtils
.
URL_TYPE
.
SUGGEST_JSON
)
)
{
let
suggestURI
=
this
.
getSubmission
(
"
dummy
"
SearchUtils
.
URL_TYPE
.
SUGGEST_JSON
)
.
uri
;
if
(
suggestURI
.
prePath
!
=
searchURI
.
prePath
)
{
try
{
connector
.
speculativeConnect
(
suggestURI
principal
callbacks
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
}
}
class
Submission
{
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsISearchSubmission
"
]
)
;
constructor
(
uri
postData
=
null
)
{
this
.
_uri
=
uri
;
this
.
_postData
=
postData
;
}
get
uri
(
)
{
return
this
.
_uri
;
}
get
postData
(
)
{
return
this
.
_postData
;
}
}
var
EXPORTED_SYMBOLS
=
[
"
EngineURL
"
"
SearchEngine
"
]
;
