const
{
EngineURL
SearchEngine
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
SearchEngine
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logConsole
"
(
)
=
>
{
return
console
.
createInstance
(
{
prefix
:
"
OpenSearchEngine
"
maxLogLevel
:
lazy
.
SearchUtils
.
loggingEnabled
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
const
OPENSEARCH_NS_10
=
"
http
:
/
/
a9
.
com
/
-
/
spec
/
opensearch
/
1
.
0
/
"
;
const
OPENSEARCH_NS_11
=
"
http
:
/
/
a9
.
com
/
-
/
spec
/
opensearch
/
1
.
1
/
"
;
const
OPENSEARCH_NAMESPACES
=
[
OPENSEARCH_NS_11
OPENSEARCH_NS_10
"
http
:
/
/
a9
.
com
/
-
/
spec
/
opensearchdescription
/
1
.
1
/
"
"
http
:
/
/
a9
.
com
/
-
/
spec
/
opensearchdescription
/
1
.
0
/
"
]
;
const
OPENSEARCH_LOCALNAME
=
"
OpenSearchDescription
"
;
const
MOZSEARCH_NS_10
=
"
http
:
/
/
www
.
mozilla
.
org
/
2006
/
browser
/
search
/
"
;
const
MOZSEARCH_LOCALNAME
=
"
SearchPlugin
"
;
function
ENSURE_WARN
(
assertion
message
resultCode
)
{
if
(
!
assertion
)
{
throw
Components
.
Exception
(
message
resultCode
)
;
}
}
class
OpenSearchEngine
extends
SearchEngine
{
_data
=
null
;
constructor
(
options
=
{
}
)
{
super
(
{
isAppProvided
:
false
loadPath
:
options
.
json
?
.
_loadPath
?
?
"
[
opensearch
]
loading
"
}
)
;
if
(
options
.
json
)
{
this
.
_initWithJSON
(
options
.
json
)
;
}
}
install
(
uri
callback
)
{
let
loadURI
=
uri
instanceof
Ci
.
nsIURI
?
uri
:
lazy
.
SearchUtils
.
makeURI
(
uri
)
;
if
(
!
loadURI
)
{
throw
Components
.
Exception
(
loadURI
"
Must
have
URI
when
calling
_install
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
if
(
!
/
^
https
?
/
i
.
test
(
loadURI
.
scheme
)
)
{
throw
Components
.
Exception
(
"
Invalid
URI
passed
to
SearchEngine
constructor
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
lazy
.
logConsole
.
debug
(
"
_install
:
Downloading
engine
from
:
"
loadURI
.
spec
)
;
var
chan
=
lazy
.
SearchUtils
.
makeChannel
(
loadURI
)
;
if
(
this
.
_engineToUpdate
&
&
chan
instanceof
Ci
.
nsIHttpChannel
)
{
var
lastModified
=
this
.
_engineToUpdate
.
getAttr
(
"
updatelastmodified
"
)
;
if
(
lastModified
)
{
chan
.
setRequestHeader
(
"
If
-
Modified
-
Since
"
lastModified
false
)
;
}
}
this
.
_uri
=
loadURI
;
var
listener
=
new
lazy
.
SearchUtils
.
LoadListener
(
chan
/
(
^
text
\
/
|
xml
)
/
this
.
_onLoad
.
bind
(
this
callback
)
)
;
chan
.
notificationCallbacks
=
listener
;
chan
.
asyncOpen
(
listener
)
;
}
_onLoad
(
callback
bytes
)
{
let
onError
=
errorCode
=
>
{
if
(
this
.
_engineToUpdate
)
{
lazy
.
logConsole
.
warn
(
"
Failed
to
update
"
this
.
_engineToUpdate
.
name
)
;
}
callback
?
.
(
errorCode
)
;
}
;
if
(
!
bytes
)
{
onError
(
Ci
.
nsISearchService
.
ERROR_DOWNLOAD_FAILURE
)
;
return
;
}
var
parser
=
new
DOMParser
(
)
;
var
doc
=
parser
.
parseFromBuffer
(
bytes
"
text
/
xml
"
)
;
this
.
_data
=
doc
.
documentElement
;
try
{
this
.
_initFromData
(
)
;
}
catch
(
ex
)
{
lazy
.
logConsole
.
error
(
"
_onLoad
:
Failed
to
init
engine
!
"
ex
)
;
if
(
ex
.
result
=
=
Cr
.
NS_ERROR_FILE_CORRUPTED
)
{
onError
(
Ci
.
nsISearchService
.
ERROR_ENGINE_CORRUPTED
)
;
}
else
{
onError
(
Ci
.
nsISearchService
.
ERROR_DOWNLOAD_FAILURE
)
;
}
return
;
}
if
(
this
.
_engineToUpdate
)
{
let
engineToUpdate
=
this
.
_engineToUpdate
.
wrappedJSObject
;
Object
.
keys
(
engineToUpdate
.
_metaData
)
.
forEach
(
key
=
>
{
this
.
setAttr
(
key
engineToUpdate
.
getAttr
(
key
)
)
;
}
)
;
this
.
_loadPath
=
engineToUpdate
.
_loadPath
;
this
.
setAttr
(
"
updatelastmodified
"
new
Date
(
)
.
toUTCString
(
)
)
;
if
(
!
this
.
_iconURI
&
&
engineToUpdate
.
_iconURI
)
{
this
.
_iconURI
=
engineToUpdate
.
_iconURI
;
}
}
else
{
if
(
Services
.
search
.
getEngineByName
(
this
.
name
)
)
{
onError
(
Ci
.
nsISearchService
.
ERROR_DUPLICATE_ENGINE
)
;
lazy
.
logConsole
.
debug
(
"
_onLoad
:
duplicate
engine
found
bailing
"
)
;
return
;
}
this
.
_loadPath
=
OpenSearchEngine
.
getAnonymizedLoadPath
(
lazy
.
SearchUtils
.
sanitizeName
(
this
.
name
)
this
.
_uri
)
;
if
(
this
.
_extensionID
)
{
this
.
_loadPath
+
=
"
:
"
+
this
.
_extensionID
;
}
this
.
setAttr
(
"
loadPathHash
"
lazy
.
SearchUtils
.
getVerificationHash
(
this
.
_loadPath
)
)
;
}
lazy
.
SearchUtils
.
notifyAction
(
this
lazy
.
SearchUtils
.
MODIFIED_TYPE
.
LOADED
)
;
callback
?
.
(
)
;
}
_initFromData
(
)
{
ENSURE_WARN
(
this
.
_data
"
Can
'
t
init
an
engine
with
no
data
!
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
let
element
=
this
.
_data
;
if
(
(
element
.
localName
=
=
MOZSEARCH_LOCALNAME
&
&
element
.
namespaceURI
=
=
MOZSEARCH_NS_10
)
|
|
(
element
.
localName
=
=
OPENSEARCH_LOCALNAME
&
&
OPENSEARCH_NAMESPACES
.
includes
(
element
.
namespaceURI
)
)
)
{
lazy
.
logConsole
.
debug
(
"
Initing
search
plugin
from
"
this
.
_location
)
;
this
.
_parse
(
)
;
}
else
{
Cu
.
reportError
(
"
Invalid
search
plugin
due
to
namespace
not
matching
.
"
)
;
throw
Components
.
Exception
(
this
.
_location
+
"
is
not
a
valid
search
plugin
.
"
Cr
.
NS_ERROR_FILE_CORRUPTED
)
;
}
this
.
_data
=
null
;
}
_parseURL
(
element
)
{
var
type
=
element
.
getAttribute
(
"
type
"
)
;
var
method
=
element
.
getAttribute
(
"
method
"
)
|
|
"
GET
"
;
var
template
=
element
.
getAttribute
(
"
template
"
)
;
let
rels
=
[
]
;
if
(
element
.
hasAttribute
(
"
rel
"
)
)
{
rels
=
element
.
getAttribute
(
"
rel
"
)
.
toLowerCase
(
)
.
split
(
/
\
s
+
/
)
;
}
if
(
type
=
=
"
application
/
json
"
&
&
rels
.
includes
(
"
suggestions
"
)
)
{
type
=
lazy
.
SearchUtils
.
URL_TYPE
.
SUGGEST_JSON
;
}
try
{
var
url
=
new
EngineURL
(
type
method
template
)
;
}
catch
(
ex
)
{
throw
Components
.
Exception
(
"
_parseURL
:
failed
to
add
"
+
template
+
"
as
a
URL
"
Cr
.
NS_ERROR_FAILURE
)
;
}
if
(
rels
.
length
)
{
url
.
rels
=
rels
;
}
for
(
var
i
=
0
;
i
<
element
.
children
.
length
;
+
+
i
)
{
var
param
=
element
.
children
[
i
]
;
if
(
param
.
localName
=
=
"
Param
"
)
{
try
{
url
.
addParam
(
param
.
getAttribute
(
"
name
"
)
param
.
getAttribute
(
"
value
"
)
)
;
}
catch
(
ex
)
{
lazy
.
logConsole
.
error
(
"
_parseURL
:
Url
element
has
an
invalid
param
"
)
;
}
}
}
this
.
_urls
.
push
(
url
)
;
}
_parseImage
(
element
)
{
let
width
=
parseInt
(
element
.
getAttribute
(
"
width
"
)
10
)
;
let
height
=
parseInt
(
element
.
getAttribute
(
"
height
"
)
10
)
;
let
isPrefered
=
width
=
=
16
&
&
height
=
=
16
;
if
(
isNaN
(
width
)
|
|
isNaN
(
height
)
|
|
width
<
=
0
|
|
height
<
=
0
)
{
lazy
.
logConsole
.
warn
(
"
OpenSearch
image
element
must
have
positive
width
and
height
.
"
)
;
return
;
}
this
.
_setIcon
(
element
.
textContent
isPrefered
width
height
)
;
}
_parse
(
)
{
var
doc
=
this
.
_data
;
for
(
var
i
=
0
;
i
<
doc
.
children
.
length
;
+
+
i
)
{
var
child
=
doc
.
children
[
i
]
;
switch
(
child
.
localName
)
{
case
"
ShortName
"
:
this
.
_name
=
child
.
textContent
;
break
;
case
"
Description
"
:
this
.
_description
=
child
.
textContent
;
break
;
case
"
Url
"
:
try
{
this
.
_parseURL
(
child
)
;
}
catch
(
ex
)
{
lazy
.
logConsole
.
error
(
"
Failed
to
parse
URL
child
:
"
ex
)
;
}
break
;
case
"
Image
"
:
this
.
_parseImage
(
child
)
;
break
;
case
"
InputEncoding
"
:
this
.
_queryCharset
=
child
.
textContent
;
break
;
case
"
SearchForm
"
:
this
.
_searchForm
=
child
.
textContent
;
break
;
case
"
UpdateUrl
"
:
this
.
_updateURL
=
child
.
textContent
;
break
;
case
"
UpdateInterval
"
:
this
.
_updateInterval
=
parseInt
(
child
.
textContent
)
;
break
;
case
"
IconUpdateUrl
"
:
this
.
_iconUpdateURL
=
child
.
textContent
;
break
;
case
"
ExtensionID
"
:
this
.
_extensionID
=
child
.
textContent
;
break
;
}
}
if
(
!
this
.
name
|
|
!
this
.
_urls
.
length
)
{
throw
Components
.
Exception
(
"
_parse
:
No
name
or
missing
URL
!
"
Cr
.
NS_ERROR_FAILURE
)
;
}
if
(
!
this
.
supportsResponseType
(
lazy
.
SearchUtils
.
URL_TYPE
.
SEARCH
)
)
{
throw
Components
.
Exception
(
"
_parse
:
No
text
/
html
result
type
!
"
Cr
.
NS_ERROR_FAILURE
)
;
}
}
get
_hasUpdates
(
)
{
let
selfURL
=
this
.
_getURLOfType
(
lazy
.
SearchUtils
.
URL_TYPE
.
OPENSEARCH
"
self
"
)
;
return
!
!
(
this
.
_updateURL
|
|
this
.
_iconUpdateURL
|
|
selfURL
)
;
}
static
getAnonymizedLoadPath
(
shortName
uri
)
{
return
[
{
uri
.
scheme
}
]
{
uri
.
host
}
/
{
shortName
}
.
xml
;
}
}
var
EXPORTED_SYMBOLS
=
[
"
OpenSearchEngine
"
]
;
