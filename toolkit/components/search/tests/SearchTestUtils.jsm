"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
MockRegistrar
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AddonTestUtils
:
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
ExtensionTestUtils
:
"
resource
:
/
/
testing
-
common
/
ExtensionXPCShellUtils
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
jsm
"
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
jsm
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
SearchTestUtils
"
]
;
var
gTestScope
;
var
SearchTestUtils
=
{
init
(
testScope
)
{
gTestScope
=
testScope
;
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
this
.
_isMochitest
=
!
env
.
exists
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
;
if
(
this
.
_isMochitest
)
{
this
.
_isMochitest
=
true
;
lazy
.
AddonTestUtils
.
initMochitest
(
testScope
)
;
}
else
{
this
.
_isMochitest
=
false
;
gTestScope
.
ExtensionTestUtils
=
lazy
.
ExtensionTestUtils
;
this
.
initXPCShellAddonManager
(
testScope
)
;
}
}
async
promiseNewSearchEngine
(
url
)
{
url
=
url
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
https
:
/
/
example
.
com
"
)
;
let
engine
=
await
Services
.
search
.
addOpenSearchEngine
(
url
"
"
)
;
gTestScope
.
registerCleanupFunction
(
async
(
)
=
>
{
try
{
await
Services
.
search
.
removeEngine
(
engine
)
;
}
catch
(
ex
)
{
}
}
)
;
return
engine
;
}
promiseSearchNotification
(
expectedData
topic
=
"
browser
-
search
-
service
"
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observer
(
aSubject
aTopic
aData
)
{
if
(
aData
!
=
expectedData
)
{
return
;
}
Services
.
obs
.
removeObserver
(
observer
topic
)
;
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
resolve
(
aSubject
)
)
;
}
topic
)
;
}
)
;
}
async
useTestEngines
(
folder
=
"
data
"
subFolder
=
null
config
=
null
)
{
let
url
=
resource
:
/
/
test
/
{
folder
}
/
;
if
(
subFolder
)
{
url
+
=
{
subFolder
}
/
;
}
let
resProt
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
resProt
.
setSubstitution
(
"
search
-
extensions
"
Services
.
io
.
newURI
(
url
)
)
;
const
settings
=
await
lazy
.
RemoteSettings
(
lazy
.
SearchUtils
.
SETTINGS_KEY
)
;
if
(
config
)
{
return
lazy
.
sinon
.
stub
(
settings
"
get
"
)
.
returns
(
config
)
;
}
let
response
=
await
fetch
(
resource
:
/
/
search
-
extensions
/
engines
.
json
)
;
let
json
=
await
response
.
json
(
)
;
return
lazy
.
sinon
.
stub
(
settings
"
get
"
)
.
returns
(
json
.
data
)
;
}
async
useMochitestEngines
(
testDir
)
{
let
resProt
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
let
originalSubstitution
=
resProt
.
getSubstitution
(
"
search
-
extensions
"
)
;
resProt
.
setSubstitution
(
"
search
-
extensions
"
Services
.
io
.
newURI
(
"
file
:
/
/
"
+
testDir
.
path
)
)
;
gTestScope
.
registerCleanupFunction
(
(
)
=
>
{
resProt
.
setSubstitution
(
"
search
-
extensions
"
originalSubstitution
)
;
}
)
;
}
async
searchConfigToEngines
(
engineConfigurations
)
{
let
engines
=
[
]
;
for
(
let
config
of
engineConfigurations
)
{
let
engine
=
await
Services
.
search
.
wrappedJSObject
.
_makeEngineFromConfig
(
config
)
;
engines
.
push
(
engine
)
;
}
return
engines
;
}
initXPCShellAddonManager
(
scope
usePrivilegedSignatures
=
false
)
{
let
scopes
=
lazy
.
AddonManager
.
SCOPE_PROFILE
|
lazy
.
AddonManager
.
SCOPE_APPLICATION
;
Services
.
prefs
.
setIntPref
(
"
extensions
.
enabledScopes
"
scopes
)
;
try
{
gTestScope
.
ExtensionTestUtils
.
init
(
scope
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_FILE_ALREADY_EXISTS
)
{
throw
ex
;
}
}
lazy
.
AddonTestUtils
.
usePrivilegedSignatures
=
usePrivilegedSignatures
;
lazy
.
AddonTestUtils
.
overrideCertDB
(
)
;
}
async
installSearchExtension
(
options
=
{
}
skipUnload
=
false
)
{
await
Services
.
search
.
init
(
)
;
let
extensionInfo
=
{
useAddonManager
:
"
permanent
"
manifest
:
this
.
createEngineManifest
(
options
)
}
;
let
extension
;
if
(
!
skipUnload
&
&
this
.
_isMochitest
)
{
gTestScope
.
registerCleanupFunction
(
async
(
)
=
>
{
await
extension
.
unload
(
)
;
}
)
;
}
extension
=
gTestScope
.
ExtensionTestUtils
.
loadExtension
(
extensionInfo
)
;
await
extension
.
startup
(
)
;
if
(
!
options
.
skipWaitForSearchEngine
)
{
await
lazy
.
AddonTestUtils
.
waitForSearchProviderStartup
(
extension
)
;
}
if
(
!
skipUnload
&
&
!
this
.
_isMochitest
)
{
gTestScope
.
registerCleanupFunction
(
async
(
)
=
>
{
await
extension
.
unload
(
)
;
}
)
;
}
return
extension
;
}
async
installSystemSearchExtension
(
options
=
{
}
)
{
options
.
id
=
(
options
.
id
?
?
"
example
"
)
+
"
search
.
mozilla
.
org
"
;
let
xpi
=
await
lazy
.
AddonTestUtils
.
createTempWebExtensionFile
(
{
manifest
:
this
.
createEngineManifest
(
options
)
background
(
)
{
browser
.
test
.
sendMessage
(
"
started
"
)
;
}
}
)
;
let
wrapper
=
gTestScope
.
ExtensionTestUtils
.
expectExtension
(
options
.
id
)
;
const
install
=
await
lazy
.
AddonManager
.
getInstallForURL
(
file
:
/
/
{
xpi
.
path
}
{
useSystemLocation
:
true
}
)
;
install
.
install
(
)
;
await
wrapper
.
awaitStartup
(
)
;
await
wrapper
.
awaitMessage
(
"
started
"
)
;
return
wrapper
;
}
createEngineManifest
(
options
=
{
}
)
{
options
.
name
=
options
.
name
?
?
"
Example
"
;
options
.
id
=
options
.
id
?
?
options
.
name
.
toLowerCase
(
)
.
replaceAll
(
"
"
"
"
)
;
if
(
!
options
.
id
.
includes
(
"
"
)
)
{
options
.
id
+
=
"
tests
.
mozilla
.
org
"
;
}
options
.
version
=
options
.
version
?
?
"
1
.
0
"
;
let
manifest
=
{
version
:
options
.
version
applications
:
{
gecko
:
{
id
:
options
.
id
}
}
chrome_settings_overrides
:
{
search_provider
:
{
name
:
options
.
name
search_url
:
options
.
search_url
?
?
"
https
:
/
/
example
.
com
/
"
}
}
}
;
if
(
options
.
search_url_post_params
)
{
manifest
.
chrome_settings_overrides
.
search_provider
.
search_url_post_params
=
options
.
search_url_post_params
;
}
else
{
manifest
.
chrome_settings_overrides
.
search_provider
.
search_url_get_params
=
options
.
search_url_get_params
?
?
"
?
q
=
{
searchTerms
}
"
;
}
if
(
options
.
favicon_url
)
{
manifest
.
chrome_settings_overrides
.
search_provider
.
favicon_url
=
options
.
favicon_url
;
}
if
(
options
.
encoding
)
{
manifest
.
chrome_settings_overrides
.
search_provider
.
encoding
=
options
.
encoding
;
}
if
(
options
.
keyword
)
{
manifest
.
chrome_settings_overrides
.
search_provider
.
keyword
=
options
.
keyword
;
}
if
(
options
.
suggest_url
)
{
manifest
.
chrome_settings_overrides
.
search_provider
.
suggest_url
=
options
.
suggest_url
;
}
if
(
options
.
suggest_url
)
{
manifest
.
chrome_settings_overrides
.
search_provider
.
suggest_url_get_params
=
options
.
suggest_url_get_params
;
}
if
(
options
.
search_form
)
{
manifest
.
chrome_settings_overrides
.
search_provider
.
search_form
=
options
.
search_form
;
}
if
(
options
.
favicon_url
)
{
manifest
.
chrome_settings_overrides
.
search_provider
.
favicon_url
=
options
.
favicon_url
;
}
return
manifest
;
}
idleService
:
{
_observers
:
new
Set
(
)
_reset
(
)
{
this
.
_observers
.
clear
(
)
;
}
_fireObservers
(
state
)
{
for
(
let
observer
of
this
.
_observers
.
values
(
)
)
{
observer
.
observe
(
observer
state
null
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUserIdleService
"
]
)
idleTime
:
19999
addIdleObserver
(
observer
time
)
{
this
.
_observers
.
add
(
observer
)
;
}
removeIdleObserver
(
observer
time
)
{
this
.
_observers
.
delete
(
observer
)
;
}
}
useMockIdleService
(
)
{
let
fakeIdleService
=
MockRegistrar
.
register
(
"
mozilla
.
org
/
widget
/
useridleservice
;
1
"
SearchTestUtils
.
idleService
)
;
gTestScope
.
registerCleanupFunction
(
(
)
=
>
{
MockRegistrar
.
unregister
(
fakeIdleService
)
;
}
)
;
}
async
updateRemoteSettingsConfig
(
config
)
{
if
(
!
config
)
{
let
settings
=
lazy
.
RemoteSettings
(
lazy
.
SearchUtils
.
SETTINGS_KEY
)
;
config
=
await
settings
.
get
(
)
;
}
const
reloadObserved
=
SearchTestUtils
.
promiseSearchNotification
(
"
engines
-
reloaded
"
)
;
await
lazy
.
RemoteSettings
(
lazy
.
SearchUtils
.
SETTINGS_KEY
)
.
emit
(
"
sync
"
{
data
:
{
current
:
config
}
}
)
;
this
.
idleService
.
_fireObservers
(
"
idle
"
)
;
await
reloadObserved
;
}
}
;
