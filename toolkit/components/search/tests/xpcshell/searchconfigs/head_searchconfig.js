"
use
strict
"
;
const
TEST_DEBUG
=
false
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AddonTestUtils
:
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
ObjectUtils
:
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
SearchEngine
:
"
resource
:
/
/
gre
/
modules
/
SearchEngine
.
jsm
"
SearchEngineSelector
:
"
resource
:
/
/
gre
/
modules
/
SearchEngineSelector
.
jsm
"
SearchTestUtils
:
"
resource
:
/
/
testing
-
common
/
SearchTestUtils
.
jsm
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
const
GLOBAL_SCOPE
=
this
;
const
URLTYPE_SUGGEST_JSON
=
"
application
/
x
-
suggestions
+
json
"
;
const
URLTYPE_SEARCH_HTML
=
"
text
/
html
"
;
const
SUBMISSION_PURPOSES
=
[
"
searchbar
"
"
keyword
"
"
contextmenu
"
"
homepage
"
"
newtab
"
]
;
const
engineSelector
=
new
SearchEngineSelector
(
)
;
class
SearchConfigTest
{
constructor
(
config
=
{
}
)
{
this
.
_config
=
config
;
}
async
setup
(
)
{
AddonTestUtils
.
init
(
GLOBAL_SCOPE
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
42
"
"
42
"
)
;
await
engineSelector
.
init
(
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
geoSpecificDefaults
"
false
)
;
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
geoip
.
url
"
"
"
)
;
Services
.
prefs
.
setBoolPref
(
SearchUtils
.
BROWSER_SEARCH_PREF
+
"
separatePrivateDefault
"
true
)
;
await
AddonTestUtils
.
promiseStartupManager
(
)
;
await
Services
.
search
.
init
(
)
;
Assert
.
ok
(
Services
.
search
.
isInitialized
"
Should
have
correctly
initialized
the
search
service
"
)
;
}
async
run
(
useEngineSelector
=
false
)
{
const
locales
=
await
this
.
_getLocales
(
)
;
const
regions
=
this
.
_regions
;
for
(
let
region
of
regions
)
{
for
(
let
locale
of
locales
)
{
if
(
!
useEngineSelector
)
{
await
this
.
_reinit
(
region
locale
)
;
}
const
engines
=
await
this
.
_getEngines
(
useEngineSelector
region
locale
)
;
this
.
_assertEngineRules
(
[
engines
[
0
]
]
region
locale
"
default
"
)
;
const
isPresent
=
this
.
_assertAvailableEngines
(
region
locale
engines
)
;
if
(
isPresent
)
{
this
.
_assertEngineDetails
(
region
locale
engines
)
;
}
}
}
this
.
assertOk
(
!
TEST_DEBUG
"
Should
not
have
test
debug
turned
on
in
production
"
)
;
}
async
_getEngines
(
useEngineSelector
region
locale
)
{
if
(
useEngineSelector
)
{
let
engines
=
[
]
;
let
configs
=
await
engineSelector
.
fetchEngineConfiguration
(
locale
region
)
;
for
(
let
config
of
configs
.
engines
)
{
let
engine
=
await
this
.
_getExtensionEngine
(
config
)
;
engines
.
push
(
engine
)
;
}
return
engines
;
}
return
Services
.
search
.
getVisibleEngines
(
)
;
}
async
_getExtensionEngine
(
config
)
{
let
id
=
config
.
webExtensionId
;
let
policy
=
WebExtensionPolicy
.
getByID
(
id
)
;
if
(
!
policy
)
{
let
idPrefix
=
id
.
split
(
"
"
)
[
0
]
;
let
path
=
resource
:
/
/
search
-
extensions
/
{
idPrefix
}
/
;
await
AddonManager
.
installBuiltinAddon
(
path
)
;
policy
=
WebExtensionPolicy
.
getByID
(
id
)
;
}
let
params
=
{
code
:
config
.
searchUrlGetExtraCodes
}
;
let
locale
=
"
webExtensionLocales
"
in
config
?
config
.
webExtensionLocales
[
0
]
:
"
default
"
;
await
policy
.
readyPromise
;
let
manifest
=
policy
.
extension
.
manifest
;
if
(
locale
!
=
"
default
"
)
{
manifest
=
await
policy
.
extension
.
getLocalizedManifest
(
locale
)
;
}
let
engineParams
=
await
Services
.
search
.
getEngineParams
(
policy
.
extension
manifest
locale
params
)
;
let
engine
=
new
SearchEngine
(
{
name
:
engineParams
.
name
readOnly
:
engineParams
.
isBuiltin
sanitizeName
:
true
}
)
;
engine
.
_initFromMetadata
(
engineParams
.
name
engineParams
)
;
engine
.
_loadPath
=
"
[
other
]
addEngineWithDetails
"
;
if
(
engineParams
.
extensionID
)
{
engine
.
_loadPath
+
=
"
:
"
+
engineParams
.
extensionID
;
}
return
engine
;
}
async
_reinit
(
region
locale
)
{
Services
.
prefs
.
setStringPref
(
"
browser
.
search
.
region
"
region
.
toUpperCase
(
)
)
;
const
reinitCompletePromise
=
SearchTestUtils
.
promiseSearchNotification
(
"
reinit
-
complete
"
)
;
Services
.
locale
.
availableLocales
=
[
locale
]
;
Services
.
locale
.
requestedLocales
=
[
locale
]
;
Services
.
search
.
reInit
(
)
;
await
reinitCompletePromise
;
this
.
assertOk
(
Services
.
search
.
isInitialized
"
Should
have
completely
re
-
initialization
if
it
fails
check
logs
for
if
reinit
was
successful
"
)
;
}
get
_regions
(
)
{
if
(
TEST_DEBUG
)
{
return
new
Set
(
[
"
by
"
"
cn
"
"
kz
"
"
us
"
"
ru
"
"
tr
"
]
)
;
}
const
chunk
=
Services
.
prefs
.
getIntPref
(
"
browser
.
search
.
config
.
test
.
section
"
-
1
)
-
1
;
const
regions
=
Services
.
intl
.
getAvailableLocaleDisplayNames
(
"
region
"
)
;
const
chunkSize
=
Math
.
ceil
(
regions
.
length
/
4
)
;
const
startPoint
=
chunk
*
chunkSize
;
return
regions
.
slice
(
startPoint
startPoint
+
chunkSize
)
;
}
async
_getLocales
(
)
{
if
(
TEST_DEBUG
)
{
return
[
"
be
"
"
en
-
US
"
"
kk
"
"
tr
"
"
ru
"
"
zh
-
CN
"
"
ach
"
]
;
}
const
data
=
await
OS
.
File
.
read
(
do_get_file
(
"
all
-
locales
"
)
.
path
{
encoding
:
"
utf
-
8
"
}
)
;
return
[
.
.
.
data
.
split
(
"
\
n
"
)
.
filter
(
e
=
>
e
!
=
"
"
)
"
en
-
US
"
]
;
}
_localeIncludes
(
locales
locale
)
{
if
(
"
matches
"
in
locales
&
&
locales
.
matches
.
includes
(
locale
)
)
{
return
true
;
}
if
(
"
startsWith
"
in
locales
)
{
return
!
!
locales
.
startsWith
.
find
(
element
=
>
locale
.
startsWith
(
element
)
)
;
}
return
false
;
}
_localeRegionInSection
(
section
region
locale
)
{
for
(
const
{
regions
locales
}
of
section
)
{
const
inRegions
=
!
regions
|
|
regions
.
includes
(
region
)
;
const
inLocales
=
!
locales
|
|
this
.
_localeIncludes
(
locales
locale
)
;
if
(
inRegions
&
&
inLocales
)
{
return
true
;
}
}
return
false
;
}
_findEngine
(
engines
identifier
)
{
return
engines
.
find
(
engine
=
>
engine
.
identifier
.
startsWith
(
identifier
)
)
;
}
_assertEngineRules
(
engines
region
locale
section
)
{
const
infoString
=
region
:
"
{
region
}
"
locale
:
"
{
locale
}
"
;
const
config
=
this
.
_config
[
section
]
;
const
hasIncluded
=
"
included
"
in
config
;
const
hasExcluded
=
"
excluded
"
in
config
;
const
identifierIncluded
=
!
!
this
.
_findEngine
(
engines
this
.
_config
.
identifier
)
;
if
(
section
=
=
"
default
"
&
&
!
hasIncluded
&
&
!
hasExcluded
)
{
this
.
assertOk
(
!
identifierIncluded
Should
not
be
{
section
}
for
any
locale
/
region
currently
set
for
{
infoString
}
)
;
return
false
;
}
let
included
=
hasIncluded
&
&
this
.
_localeRegionInSection
(
config
.
included
region
locale
)
;
let
notExcluded
=
hasExcluded
&
&
!
this
.
_localeRegionInSection
(
config
.
excluded
region
locale
)
;
if
(
included
|
|
notExcluded
)
{
this
.
assertOk
(
identifierIncluded
Should
be
{
section
}
for
{
infoString
}
)
;
return
true
;
}
this
.
assertOk
(
!
identifierIncluded
Should
not
be
{
section
}
for
{
infoString
}
)
;
return
false
;
}
_assertDefaultEngines
(
region
locale
)
{
this
.
_assertEngineRules
(
[
Services
.
search
.
originalDefaultEngine
]
region
locale
"
default
"
)
;
this
.
_assertEngineRules
(
[
Services
.
search
.
originalPrivateDefaultEngine
]
region
locale
"
default
"
)
;
}
_assertAvailableEngines
(
region
locale
engines
)
{
return
this
.
_assertEngineRules
(
engines
region
locale
"
available
"
)
;
}
_assertEngineDetails
(
region
locale
engines
)
{
const
details
=
this
.
_config
.
details
.
filter
(
value
=
>
{
const
included
=
this
.
_localeRegionInSection
(
value
.
included
region
locale
)
;
const
excluded
=
value
.
excluded
&
&
this
.
_localeRegionInSection
(
value
.
excluded
region
locale
)
;
return
included
&
&
!
excluded
;
}
)
;
const
engine
=
this
.
_findEngine
(
engines
this
.
_config
.
identifier
)
;
this
.
assertOk
(
engine
"
Should
have
an
engine
present
"
)
;
if
(
this
.
_config
.
aliases
)
{
this
.
assertDeepEqual
(
engine
.
_internalAliases
this
.
_config
.
aliases
"
Should
have
the
correct
aliases
for
the
engine
"
)
;
}
const
location
=
in
region
:
{
region
}
locale
:
{
locale
}
;
for
(
const
rule
of
details
)
{
this
.
_assertCorrectDomains
(
location
engine
rule
)
;
if
(
rule
.
codes
)
{
this
.
_assertCorrectCodes
(
location
engine
rule
)
;
}
if
(
rule
.
searchUrlCode
|
|
rule
.
searchFormUrlCode
|
|
rule
.
suggestUrlCode
)
{
this
.
_assertCorrectUrlCode
(
location
engine
rule
)
;
}
if
(
rule
.
aliases
)
{
this
.
assertDeepEqual
(
engine
.
_internalAliases
rule
.
aliases
"
Should
have
the
correct
aliases
for
the
engine
"
)
;
}
}
}
_assertCorrectDomains
(
location
engine
rules
)
{
this
.
assertOk
(
rules
.
domain
Should
have
an
expectedDomain
for
the
engine
{
location
}
)
;
const
searchForm
=
new
URL
(
engine
.
searchForm
)
;
this
.
assertOk
(
searchForm
.
host
.
endsWith
(
rules
.
domain
)
Should
have
the
correct
search
form
domain
{
location
}
.
Got
"
{
searchForm
.
host
}
"
expected
to
end
with
"
{
rules
.
domain
}
"
.
)
;
for
(
const
urlType
of
[
URLTYPE_SUGGEST_JSON
URLTYPE_SEARCH_HTML
]
)
{
const
submission
=
engine
.
getSubmission
(
"
test
"
urlType
)
;
if
(
urlType
=
=
URLTYPE_SUGGEST_JSON
&
&
(
this
.
_config
.
noSuggestionsURL
|
|
rules
.
noSuggestionsURL
)
)
{
this
.
assertOk
(
!
submission
"
Should
not
have
a
submission
url
"
)
;
}
else
if
(
this
.
_config
.
searchUrlBase
)
{
this
.
assertEqual
(
submission
.
uri
.
prePath
+
submission
.
uri
.
filePath
this
.
_config
.
searchUrlBase
+
rules
.
searchUrlEnd
Should
have
the
correct
domain
for
type
:
{
urlType
}
{
location
}
.
)
;
}
else
{
this
.
assertOk
(
submission
.
uri
.
host
.
endsWith
(
rules
.
domain
)
Should
have
the
correct
domain
for
type
:
{
urlType
}
{
location
}
.
Got
"
{
submission
.
uri
.
host
}
"
expected
to
end
with
"
{
rules
.
domain
}
"
.
)
;
}
}
}
_assertCorrectCodes
(
location
engine
rules
)
{
for
(
const
purpose
of
SUBMISSION_PURPOSES
)
{
const
code
=
typeof
rules
.
codes
=
=
=
"
string
"
?
rules
.
codes
:
rules
.
codes
[
purpose
]
;
const
submission
=
engine
.
getSubmission
(
"
test
"
"
text
/
html
"
purpose
)
;
const
submissionQueryParams
=
submission
.
uri
.
query
.
split
(
"
&
"
)
;
this
.
assertOk
(
submissionQueryParams
.
includes
(
code
)
Expected
"
{
code
}
"
in
url
"
{
submission
.
uri
.
spec
}
"
from
purpose
"
{
purpose
}
"
{
location
}
)
;
const
paramName
=
code
.
split
(
"
=
"
)
[
0
]
;
this
.
assertOk
(
submissionQueryParams
.
filter
(
param
=
>
param
.
startsWith
(
paramName
)
)
.
length
=
=
1
Expected
only
one
"
{
paramName
}
"
parameter
in
"
{
submission
.
uri
.
spec
}
"
from
purpose
"
{
purpose
}
"
{
location
}
)
;
}
}
_assertCorrectUrlCode
(
location
engine
rule
)
{
if
(
rule
.
searchUrlCode
)
{
const
submission
=
engine
.
getSubmission
(
"
test
"
URLTYPE_SEARCH_HTML
)
;
this
.
assertOk
(
submission
.
uri
.
query
.
split
(
"
&
"
)
.
includes
(
rule
.
searchUrlCode
)
Expected
"
{
rule
.
searchUrlCode
}
"
in
search
url
"
{
submission
.
uri
.
spec
}
"
)
;
}
if
(
rule
.
searchFormUrlCode
)
{
const
uri
=
engine
.
searchForm
;
this
.
assertOk
(
uri
.
includes
(
rule
.
searchFormUrlCode
)
Expected
"
{
rule
.
searchFormUrlCode
}
"
in
"
{
uri
}
"
)
;
}
if
(
rule
.
suggestUrlCode
)
{
const
submission
=
engine
.
getSubmission
(
"
test
"
URLTYPE_SUGGEST_JSON
)
;
this
.
assertOk
(
submission
.
uri
.
query
.
split
(
"
&
"
)
.
includes
(
rule
.
suggestUrlCode
)
Expected
"
{
rule
.
suggestUrlCode
}
"
in
suggestion
url
"
{
submission
.
uri
.
spec
}
"
)
;
}
}
assertOk
(
value
message
)
{
if
(
!
value
|
|
TEST_DEBUG
)
{
Assert
.
ok
(
value
message
)
;
}
}
assertEqual
(
actual
expected
message
)
{
if
(
actual
!
=
expected
|
|
TEST_DEBUG
)
{
Assert
.
equal
(
actual
expected
message
)
;
}
}
assertDeepEqual
(
actual
expected
message
)
{
if
(
!
ObjectUtils
.
deepEqual
(
actual
expected
)
)
{
Assert
.
deepEqual
(
actual
expected
message
)
;
}
}
}
