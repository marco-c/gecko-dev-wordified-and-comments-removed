"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
ObjectUtils
:
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
sys
.
mjs
"
Region
:
"
resource
:
/
/
gre
/
modules
/
Region
.
sys
.
mjs
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
sys
.
mjs
"
SearchEngine
:
"
moz
-
src
:
/
/
/
toolkit
/
components
/
search
/
SearchEngine
.
sys
.
mjs
"
SearchEngineSelector
:
"
moz
-
src
:
/
/
/
toolkit
/
components
/
search
/
SearchEngineSelector
.
sys
.
mjs
"
SearchTestUtils
:
"
resource
:
/
/
testing
-
common
/
SearchTestUtils
.
sys
.
mjs
"
SearchUtils
:
"
moz
-
src
:
/
/
/
toolkit
/
components
/
search
/
SearchUtils
.
sys
.
mjs
"
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
updateAppInfo
:
"
resource
:
/
/
testing
-
common
/
AppInfo
.
sys
.
mjs
"
}
)
;
const
GLOBAL_SCOPE
=
this
;
const
TEST_DEBUG
=
Services
.
env
.
get
(
"
TEST_DEBUG
"
)
;
const
URLTYPE_SUGGEST_JSON
=
"
application
/
x
-
suggestions
+
json
"
;
const
URLTYPE_SEARCH_HTML
=
"
text
/
html
"
;
async
function
maybeSetupConfig
(
)
{
const
SEARCH_CONFIG
=
Services
.
env
.
get
(
"
SEARCH_CONFIG
"
)
;
if
(
SEARCH_CONFIG
)
{
if
(
!
(
SEARCH_CONFIG
in
SearchUtils
.
ENGINES_URLS
)
)
{
throw
new
Error
(
Invalid
value
for
SEARCH_CONFIG
)
;
}
const
url
=
SearchUtils
.
ENGINES_URLS
[
SEARCH_CONFIG
]
;
const
response
=
await
fetch
(
url
)
;
const
config
=
await
response
.
json
(
)
;
SearchTestUtils
.
setRemoteSettingsConfig
(
config
.
data
)
;
}
}
class
SearchConfigTest
{
#
engineSelector
;
#
testDetails
;
constructor
(
testDetails
)
{
this
.
#
testDetails
=
testDetails
;
}
async
setup
(
version
=
"
42
.
0
"
)
{
updateAppInfo
(
{
name
:
"
firefox
"
ID
:
"
xpcshell
tests
.
mozilla
.
org
"
version
platformVersion
:
version
}
)
;
await
maybeSetupConfig
(
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
geoSpecificDefaults
"
false
)
;
Services
.
prefs
.
setBoolPref
(
SearchUtils
.
BROWSER_SEARCH_PREF
+
"
separatePrivateDefault
.
ui
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
SearchUtils
.
BROWSER_SEARCH_PREF
+
"
separatePrivateDefault
"
true
)
;
this
.
#
engineSelector
=
new
SearchEngineSelector
(
)
;
}
async
run
(
)
{
const
locales
=
await
this
.
getLocales
(
)
;
const
regions
=
this
.
_regions
;
for
(
let
region
of
regions
)
{
for
(
let
locale
of
locales
)
{
const
{
engines
appDefaultEngineId
}
=
await
this
.
_getEngines
(
region
locale
)
;
this
.
_assertEngineRules
(
engines
.
filter
(
e
=
>
e
.
id
=
=
appDefaultEngineId
)
region
locale
"
default
"
)
;
const
isPresent
=
this
.
_assertAvailableEngines
(
region
locale
engines
)
;
if
(
isPresent
)
{
this
.
_assertEngineDetails
(
region
locale
engines
)
;
}
}
}
}
async
_getEngines
(
region
locale
)
{
let
configs
=
await
this
.
#
engineSelector
.
fetchEngineConfiguration
(
{
locale
region
:
region
|
|
"
default
"
channel
:
SearchUtils
.
MODIFIED_APP_CHANNEL
}
)
;
return
{
engines
:
await
SearchTestUtils
.
searchConfigToEngines
(
configs
.
engines
)
appDefaultEngineId
:
configs
.
appDefaultEngineId
}
;
}
get
_regions
(
)
{
if
(
TEST_DEBUG
)
{
return
new
Set
(
[
"
by
"
"
cn
"
"
kz
"
"
us
"
"
ru
"
"
tr
"
null
]
)
;
}
return
[
.
.
.
Services
.
intl
.
getAvailableLocaleDisplayNames
(
"
region
"
)
null
]
;
}
async
getLocales
(
)
{
if
(
TEST_DEBUG
)
{
return
[
"
be
"
"
en
-
US
"
"
kk
"
"
tr
"
"
ru
"
"
zh
-
CN
"
"
ach
"
"
unknown
"
]
;
}
const
data
=
await
IOUtils
.
readUTF8
(
do_get_file
(
"
all
-
locales
"
)
.
path
)
;
let
locales
=
[
.
.
.
data
.
split
(
"
\
n
"
)
.
filter
(
e
=
>
e
!
=
"
"
)
"
en
-
US
"
]
;
locales
=
locales
.
map
(
l
=
>
(
l
=
=
"
ja
-
JP
-
mac
"
?
"
ja
-
JP
-
macos
"
:
l
)
)
;
locales
.
push
(
"
unknown
"
)
;
return
locales
;
}
_localeRegionInSection
(
section
region
locale
)
{
for
(
const
{
regions
locales
}
of
section
)
{
const
inRegions
=
!
regions
|
|
regions
.
includes
(
region
)
;
const
inLocales
=
!
locales
|
|
locales
.
includes
(
locale
)
;
if
(
inRegions
&
&
inLocales
)
{
return
true
;
}
}
return
false
;
}
_findEngine
(
engines
identifier
exactMatch
)
{
return
engines
.
find
(
engine
=
>
exactMatch
?
engine
.
identifier
=
=
identifier
:
engine
.
identifier
.
startsWith
(
identifier
)
)
;
}
_assertEngineRules
(
engines
region
locale
section
)
{
const
infoString
=
region
:
"
{
region
}
"
locale
:
"
{
locale
}
"
;
const
testSection
=
this
.
#
testDetails
[
section
]
;
const
hasIncluded
=
"
included
"
in
testSection
;
const
hasExcluded
=
"
excluded
"
in
testSection
;
const
identifierIncluded
=
!
!
this
.
_findEngine
(
engines
this
.
#
testDetails
.
identifier
this
.
#
testDetails
.
identifierExactMatch
?
?
false
)
;
if
(
section
=
=
"
default
"
&
&
!
hasIncluded
&
&
!
hasExcluded
)
{
this
.
assertOk
(
!
identifierIncluded
Should
not
be
{
section
}
for
any
locale
/
region
currently
set
for
{
infoString
}
)
;
return
false
;
}
let
included
=
hasIncluded
&
&
this
.
_localeRegionInSection
(
testSection
.
included
region
locale
)
;
let
excluded
=
hasExcluded
&
&
this
.
_localeRegionInSection
(
testSection
.
excluded
region
locale
)
;
if
(
(
included
&
&
(
!
hasExcluded
|
|
!
excluded
)
)
|
|
(
!
hasIncluded
&
&
hasExcluded
&
&
!
excluded
)
)
{
this
.
assertOk
(
identifierIncluded
Should
be
{
section
}
for
{
infoString
}
)
;
return
true
;
}
this
.
assertOk
(
!
identifierIncluded
Should
not
be
{
section
}
for
{
infoString
}
)
;
return
false
;
}
_assertDefaultEngines
(
region
locale
)
{
this
.
_assertEngineRules
(
[
Services
.
search
.
appDefaultEngine
]
region
locale
"
default
"
)
;
this
.
_assertEngineRules
(
[
Services
.
search
.
appPrivateDefaultEngine
]
region
locale
"
default
"
)
;
}
_assertAvailableEngines
(
region
locale
engines
)
{
return
this
.
_assertEngineRules
(
engines
region
locale
"
available
"
)
;
}
_assertEngineDetails
(
region
locale
engines
)
{
const
details
=
this
.
#
testDetails
.
details
.
filter
(
value
=
>
{
const
included
=
this
.
_localeRegionInSection
(
value
.
included
region
locale
)
;
const
excluded
=
value
.
excluded
&
&
this
.
_localeRegionInSection
(
value
.
excluded
region
locale
)
;
return
included
&
&
!
excluded
;
}
)
;
this
.
assertEqual
(
details
.
length
1
Should
have
just
one
details
section
for
region
:
{
region
}
locale
:
{
locale
}
)
;
const
engine
=
this
.
_findEngine
(
engines
this
.
#
testDetails
.
identifier
this
.
#
testDetails
.
identifierExactMatch
?
?
false
)
;
this
.
assertOk
(
engine
"
Should
have
an
engine
present
"
)
;
if
(
this
.
#
testDetails
.
aliases
)
{
this
.
assertDeepEqual
(
engine
.
aliases
this
.
#
testDetails
.
aliases
"
Should
have
the
correct
aliases
for
the
engine
"
)
;
}
const
location
=
in
region
:
{
region
}
locale
:
{
locale
}
;
for
(
const
rule
of
details
)
{
this
.
_assertCorrectDomains
(
location
engine
rule
)
;
this
.
_assertCorrectUrlCode
(
location
engine
rule
)
;
if
(
"
aliases
"
in
rule
)
{
this
.
assertDeepEqual
(
engine
.
aliases
rule
.
aliases
"
Should
have
the
correct
aliases
for
the
engine
"
)
;
}
if
(
"
required_aliases
"
in
rule
)
{
this
.
assertOk
(
rule
.
required_aliases
.
every
(
a
=
>
engine
.
aliases
.
includes
(
a
)
)
"
Should
have
the
required
aliases
for
the
engine
"
)
;
}
if
(
"
telemetryId
"
in
rule
)
{
this
.
assertEqual
(
engine
.
telemetryId
rule
.
telemetryId
Should
have
the
correct
telemetryId
{
location
}
.
)
;
}
if
(
"
partnerCode
"
in
rule
)
{
this
.
assertEqual
(
engine
.
partnerCode
rule
.
partnerCode
Should
have
the
correct
partnerCode
{
location
}
.
)
;
}
}
}
_assertCorrectDomains
(
location
engine
rules
)
{
this
.
assertOk
(
rules
.
domain
Should
have
an
expectedDomain
for
the
engine
{
location
}
)
;
let
submission
=
engine
.
getSubmission
(
"
test
"
URLTYPE_SEARCH_HTML
)
;
this
.
assertOk
(
submission
.
uri
.
host
.
endsWith
(
rules
.
domain
)
Should
have
the
correct
domain
for
type
:
{
URLTYPE_SEARCH_HTML
}
{
location
}
.
Got
"
{
submission
.
uri
.
host
}
"
expected
to
end
with
"
{
rules
.
domain
}
"
.
)
;
submission
=
engine
.
getSubmission
(
"
test
"
URLTYPE_SUGGEST_JSON
)
;
if
(
this
.
#
testDetails
.
noSuggestionsURL
|
|
rules
.
noSuggestionsURL
)
{
this
.
assertOk
(
!
submission
"
Should
not
have
a
submission
url
"
)
;
}
else
if
(
this
.
#
testDetails
.
suggestionUrlBase
)
{
this
.
assertEqual
(
submission
.
uri
.
prePath
+
submission
.
uri
.
filePath
this
.
#
testDetails
.
suggestionUrlBase
Should
have
the
correct
domain
for
type
:
{
URLTYPE_SUGGEST_JSON
}
{
location
}
.
)
;
this
.
assertOk
(
submission
.
uri
.
query
.
includes
(
rules
.
suggestUrlCode
)
Should
have
the
code
in
the
uri
)
;
}
}
_assertCorrectUrlCode
(
location
engine
rule
)
{
if
(
rule
.
searchUrlCode
)
{
const
submission
=
engine
.
getSubmission
(
"
test
"
URLTYPE_SEARCH_HTML
)
;
this
.
assertOk
(
submission
.
uri
.
query
.
split
(
"
&
"
)
.
includes
(
rule
.
searchUrlCode
)
Expected
"
{
rule
.
searchUrlCode
}
"
in
search
url
"
{
submission
.
uri
.
spec
}
"
)
;
}
if
(
rule
.
searchUrlCodeNotInQuery
)
{
const
submission
=
engine
.
getSubmission
(
"
test
"
URLTYPE_SEARCH_HTML
)
;
this
.
assertOk
(
submission
.
uri
.
query
.
includes
(
rule
.
searchUrlCodeNotInQuery
)
Expected
"
{
rule
.
searchUrlCodeNotInQuery
}
"
in
search
url
"
{
submission
.
uri
.
spec
}
"
)
;
}
if
(
rule
.
suggestUrlCode
)
{
const
submission
=
engine
.
getSubmission
(
"
test
"
URLTYPE_SUGGEST_JSON
)
;
this
.
assertOk
(
submission
.
uri
.
query
.
split
(
"
&
"
)
.
includes
(
rule
.
suggestUrlCode
)
Expected
"
{
rule
.
suggestUrlCode
}
"
in
suggestion
url
"
{
submission
.
uri
.
spec
}
"
)
;
}
}
assertOk
(
value
message
)
{
if
(
!
value
|
|
TEST_DEBUG
)
{
Assert
.
ok
(
value
message
)
;
}
}
assertEqual
(
actual
expected
message
)
{
if
(
actual
!
=
expected
|
|
TEST_DEBUG
)
{
Assert
.
equal
(
actual
expected
message
)
;
}
}
assertDeepEqual
(
actual
expected
message
)
{
if
(
!
ObjectUtils
.
deepEqual
(
actual
expected
)
)
{
Assert
.
deepEqual
(
actual
expected
message
)
;
}
}
}
async
function
checkUISchemaValid
(
configSchema
uiSchema
)
{
for
(
let
key
of
Object
.
keys
(
configSchema
.
properties
)
)
{
Assert
.
ok
(
uiSchema
[
"
ui
:
order
"
]
.
includes
(
key
)
Should
have
{
key
}
listed
at
the
top
-
level
of
the
ui
schema
)
;
}
}
