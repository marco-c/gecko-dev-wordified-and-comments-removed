var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TestUtils
"
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
BROWSER_SEARCH_PREF
=
"
browser
.
search
.
"
;
const
NS_APP_SEARCH_DIR
=
"
SrchPlugns
"
;
const
MODE_RDONLY
=
FileUtils
.
MODE_RDONLY
;
const
MODE_WRONLY
=
FileUtils
.
MODE_WRONLY
;
const
MODE_CREATE
=
FileUtils
.
MODE_CREATE
;
const
MODE_TRUNCATE
=
FileUtils
.
MODE_TRUNCATE
;
const
CACHE_FILENAME
=
"
search
.
json
.
mozlz4
"
;
var
XULRuntime
=
Components
.
classesByID
[
"
{
95d89e3e
-
a169
-
41a3
-
8e56
-
719978e15b12
}
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
var
isChild
=
XULRuntime
.
processType
=
=
XULRuntime
.
PROCESS_TYPE_CONTENT
;
updateAppInfo
(
{
name
:
"
XPCShell
"
ID
:
"
xpcshell
test
.
mozilla
.
org
"
version
:
"
5
"
platformVersion
:
"
1
.
9
"
OS
:
XULRuntime
.
OS
extraProps
:
{
processType
:
XULRuntime
.
processType
}
}
)
;
var
gProfD
;
if
(
!
isChild
)
{
gProfD
=
do_get_profile
(
)
;
}
function
dumpn
(
text
)
{
dump
(
"
search
test
:
"
+
text
+
"
\
n
"
)
;
}
function
configureToLoadJarEngines
(
)
{
let
url
=
"
chrome
:
/
/
testsearchplugin
/
locale
/
searchplugins
/
"
;
let
resProt
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
resProt
.
setSubstitution
(
"
search
-
plugins
"
Services
.
io
.
newURI
(
url
)
)
;
}
function
installAddonEngine
(
name
=
"
engine
-
addon
"
)
{
const
XRE_EXTENSIONS_DIR_LIST
=
"
XREExtDL
"
;
const
profD
=
do_get_profile
(
)
.
QueryInterface
(
Ci
.
nsIFile
)
;
let
dir
=
profD
.
clone
(
)
;
dir
.
append
(
"
extensions
"
)
;
if
(
!
dir
.
exists
(
)
)
dir
.
create
(
dir
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
dir
.
append
(
"
search
-
engine
tests
.
mozilla
.
org
"
)
;
dir
.
create
(
dir
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
do_get_file
(
"
data
/
install
.
rdf
"
)
.
copyTo
(
dir
"
install
.
rdf
"
)
;
let
addonDir
=
dir
.
clone
(
)
;
dir
.
append
(
"
searchplugins
"
)
;
dir
.
create
(
dir
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
do_get_file
(
"
data
/
"
+
name
+
"
.
xml
"
)
.
copyTo
(
dir
"
bug645970
.
xml
"
)
;
Services
.
dirsvc
.
registerProvider
(
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIDirectoryServiceProvider
Ci
.
nsIDirectoryServiceProvider2
]
)
getFile
(
prop
persistant
)
{
throw
Cr
.
NS_ERROR_FAILURE
;
}
getFiles
(
prop
)
{
let
result
=
[
]
;
switch
(
prop
)
{
case
XRE_EXTENSIONS_DIR_LIST
:
result
.
push
(
addonDir
)
;
break
;
default
:
throw
Cr
.
NS_ERROR_FAILURE
;
}
return
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISimpleEnumerator
]
)
hasMoreElements
:
(
)
=
>
result
.
length
>
0
getNext
:
(
)
=
>
result
.
shift
(
)
}
;
}
}
)
;
}
function
installDistributionEngine
(
)
{
const
XRE_APP_DISTRIBUTION_DIR
=
"
XREAppDist
"
;
const
profD
=
do_get_profile
(
)
.
QueryInterface
(
Ci
.
nsIFile
)
;
let
dir
=
profD
.
clone
(
)
;
dir
.
append
(
"
distribution
"
)
;
dir
.
create
(
dir
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
let
distDir
=
dir
.
clone
(
)
;
dir
.
append
(
"
searchplugins
"
)
;
dir
.
create
(
dir
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
dir
.
append
(
"
common
"
)
;
dir
.
create
(
dir
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
do_get_file
(
"
data
/
engine
-
override
.
xml
"
)
.
copyTo
(
dir
"
bug645970
.
xml
"
)
;
Services
.
dirsvc
.
registerProvider
(
{
getFile
(
aProp
aPersistent
)
{
aPersistent
.
value
=
true
;
if
(
aProp
=
=
XRE_APP_DISTRIBUTION_DIR
)
return
distDir
.
clone
(
)
;
return
null
;
}
}
)
;
}
function
promiseCacheData
(
)
{
return
new
Promise
(
resolve
=
>
(
async
function
(
)
{
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CACHE_FILENAME
)
;
let
bytes
=
await
OS
.
File
.
read
(
path
{
compression
:
"
lz4
"
}
)
;
resolve
(
JSON
.
parse
(
new
TextDecoder
(
)
.
decode
(
bytes
)
)
)
;
}
)
(
)
)
;
}
function
promiseSaveCacheData
(
data
)
{
return
OS
.
File
.
writeAtomic
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CACHE_FILENAME
)
new
TextEncoder
(
)
.
encode
(
JSON
.
stringify
(
data
)
)
{
compression
:
"
lz4
"
}
)
;
}
function
promiseEngineMetadata
(
)
{
return
new
Promise
(
resolve
=
>
(
async
function
(
)
{
let
cache
=
await
promiseCacheData
(
)
;
let
data
=
{
}
;
for
(
let
engine
of
cache
.
engines
)
{
data
[
engine
.
_shortName
]
=
engine
.
_metaData
;
}
resolve
(
data
)
;
}
)
(
)
)
;
}
function
promiseGlobalMetadata
(
)
{
return
new
Promise
(
resolve
=
>
(
async
function
(
)
{
let
cache
=
await
promiseCacheData
(
)
;
resolve
(
cache
.
metaData
)
;
}
)
(
)
)
;
}
function
promiseSaveGlobalMetadata
(
globalData
)
{
return
new
Promise
(
resolve
=
>
(
async
function
(
)
{
let
data
=
await
promiseCacheData
(
)
;
data
.
metaData
=
globalData
;
await
promiseSaveCacheData
(
data
)
;
resolve
(
)
;
}
)
(
)
)
;
}
var
forceExpiration
=
async
function
(
)
{
let
metadata
=
await
promiseGlobalMetadata
(
)
;
metadata
.
searchDefaultExpir
=
Date
.
now
(
)
-
1000
;
await
promiseSaveGlobalMetadata
(
metadata
)
;
}
;
function
removeCacheFile
(
)
{
let
file
=
gProfD
.
clone
(
)
;
file
.
append
(
CACHE_FILENAME
)
;
if
(
file
.
exists
(
)
)
{
file
.
remove
(
false
)
;
return
true
;
}
return
false
;
}
function
isUSTimezone
(
)
{
let
UTCOffset
=
(
new
Date
(
)
)
.
getTimezoneOffset
(
)
;
return
UTCOffset
>
=
150
&
&
UTCOffset
<
=
600
;
}
const
kDefaultenginenamePref
=
"
browser
.
search
.
defaultenginename
"
;
const
kTestEngineName
=
"
Test
search
engine
"
;
const
REQ_LOCALES_CHANGED_TOPIC
=
"
intl
:
requested
-
locales
-
changed
"
;
function
getDefaultEngineName
(
isUS
)
{
const
nsIPLS
=
Ci
.
nsIPrefLocalizedString
;
let
pref
=
kDefaultenginenamePref
;
if
(
isUS
=
=
=
undefined
)
isUS
=
Services
.
locale
.
getRequestedLocale
(
)
=
=
"
en
-
US
"
&
&
isUSTimezone
(
)
;
if
(
isUS
)
{
pref
+
=
"
.
US
"
;
}
return
Services
.
prefs
.
getComplexValue
(
pref
nsIPLS
)
.
data
;
}
function
promiseAfterCache
(
)
{
return
waitForSearchNotification
(
"
write
-
cache
-
to
-
disk
-
complete
"
)
;
}
function
parseJsonFromStream
(
aInputStream
)
{
let
bytes
=
NetUtil
.
readInputStream
(
aInputStream
aInputStream
.
available
(
)
)
;
return
JSON
.
parse
(
(
new
TextDecoder
(
)
)
.
decode
(
bytes
)
)
;
}
function
readJSONFile
(
aFile
)
{
let
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
try
{
stream
.
init
(
aFile
MODE_RDONLY
FileUtils
.
PERMS_FILE
0
)
;
return
parseJsonFromStream
(
stream
stream
.
available
(
)
)
;
}
catch
(
ex
)
{
dumpn
(
"
readJSONFile
:
Error
reading
JSON
file
:
"
+
ex
)
;
}
finally
{
stream
.
close
(
)
;
}
return
false
;
}
function
isSubObjectOf
(
expectedObj
actualObj
)
{
for
(
let
prop
in
expectedObj
)
{
if
(
expectedObj
[
prop
]
instanceof
Object
)
{
Assert
.
equal
(
expectedObj
[
prop
]
.
length
actualObj
[
prop
]
.
length
)
;
isSubObjectOf
(
expectedObj
[
prop
]
actualObj
[
prop
]
)
;
}
else
{
if
(
expectedObj
[
prop
]
!
=
actualObj
[
prop
]
)
do_print
(
"
comparing
property
"
+
prop
)
;
Assert
.
equal
(
expectedObj
[
prop
]
actualObj
[
prop
]
)
;
}
}
}
if
(
!
isChild
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
log
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
geoSpecificDefaults
"
true
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
search
.
geoip
.
timeout
"
3000
)
;
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
geoip
.
url
"
"
"
)
;
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
.
setCharPref
(
"
geoSpecificDefaults
.
url
"
"
"
)
;
}
var
gDataUrl
;
function
useHttpServer
(
)
{
let
httpServer
=
new
HttpServer
(
)
;
httpServer
.
start
(
-
1
)
;
httpServer
.
registerDirectory
(
"
/
"
do_get_cwd
(
)
)
;
gDataUrl
=
"
http
:
/
/
localhost
:
"
+
httpServer
.
identity
.
primaryPort
+
"
/
data
/
"
;
do_register_cleanup
(
async
function
cleanup_httpServer
(
)
{
await
new
Promise
(
resolve
=
>
{
httpServer
.
stop
(
resolve
)
;
}
)
;
}
)
;
return
httpServer
;
}
var
addTestEngines
=
async
function
(
aItems
)
{
if
(
!
gDataUrl
)
{
do_throw
(
"
useHttpServer
must
be
called
before
addTestEngines
.
"
)
;
}
let
engines
=
[
]
;
for
(
let
item
of
aItems
)
{
do_print
(
"
Adding
engine
:
"
+
item
.
name
)
;
await
new
Promise
(
(
resolve
reject
)
=
>
{
Services
.
obs
.
addObserver
(
function
obs
(
subject
topic
data
)
{
try
{
let
engine
=
subject
.
QueryInterface
(
Ci
.
nsISearchEngine
)
;
do_print
(
"
Observed
"
+
data
+
"
for
"
+
engine
.
name
)
;
if
(
data
!
=
"
engine
-
added
"
|
|
engine
.
name
!
=
item
.
name
)
{
return
;
}
Services
.
obs
.
removeObserver
(
obs
"
browser
-
search
-
engine
-
modified
"
)
;
engines
.
push
(
engine
)
;
resolve
(
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
}
}
"
browser
-
search
-
engine
-
modified
"
)
;
if
(
item
.
xmlFileName
)
{
Services
.
search
.
addEngine
(
gDataUrl
+
item
.
xmlFileName
null
null
false
)
;
}
else
{
Services
.
search
.
addEngineWithDetails
(
item
.
name
.
.
.
item
.
details
)
;
}
}
)
;
}
return
engines
;
}
;
function
installTestEngine
(
)
{
useHttpServer
(
)
;
return
addTestEngines
(
[
{
name
:
kTestEngineName
xmlFileName
:
"
engine
.
xml
"
}
]
)
;
}
function
setLocalizedDefaultPref
(
aPrefName
aValue
)
{
let
value
=
"
data
:
text
/
plain
"
+
BROWSER_SEARCH_PREF
+
aPrefName
+
"
=
"
+
aValue
;
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
.
setCharPref
(
aPrefName
value
)
;
}
function
setUpGeoDefaults
(
)
{
const
kSecondTestEngineName
=
"
A
second
test
engine
"
;
setLocalizedDefaultPref
(
"
defaultenginename
"
"
Test
search
engine
"
)
;
setLocalizedDefaultPref
(
"
defaultenginename
.
US
"
"
A
second
test
engine
"
)
;
useHttpServer
(
)
;
return
addTestEngines
(
[
{
name
:
kTestEngineName
xmlFileName
:
"
engine
.
xml
"
}
{
name
:
kSecondTestEngineName
xmlFileName
:
"
engine2
.
xml
"
}
]
)
;
}
function
waitForSearchNotification
(
aExpectedData
)
{
return
new
Promise
(
resolve
=
>
{
const
SEARCH_SERVICE_TOPIC
=
"
browser
-
search
-
service
"
;
Services
.
obs
.
addObserver
(
function
observer
(
aSubject
aTopic
aData
)
{
if
(
aData
!
=
aExpectedData
)
return
;
Services
.
obs
.
removeObserver
(
observer
SEARCH_SERVICE_TOPIC
)
;
resolve
(
aSubject
)
;
}
SEARCH_SERVICE_TOPIC
)
;
}
)
;
}
function
asyncInit
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
search
.
init
(
function
(
)
{
Assert
.
ok
(
Services
.
search
.
isInitialized
)
;
resolve
(
)
;
}
)
;
}
)
;
}
function
asyncReInit
(
)
{
let
promise
=
waitForSearchNotification
(
"
reinit
-
complete
"
)
;
Services
.
search
.
QueryInterface
(
Ci
.
nsIObserver
)
.
observe
(
null
REQ_LOCALES_CHANGED_TOPIC
null
)
;
return
promise
;
}
const
TELEMETRY_RESULT_ENUM
=
{
SUCCESS
:
0
SUCCESS_WITHOUT_DATA
:
1
XHRTIMEOUT
:
2
ERROR
:
3
}
;
function
checkCountryResultTelemetry
(
aExpectedValue
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_FETCH_RESULT
"
)
;
let
snapshot
=
histogram
.
snapshot
(
)
;
let
expectedCounts
=
[
0
0
0
0
0
0
0
0
0
]
;
if
(
aExpectedValue
!
=
null
)
{
expectedCounts
[
aExpectedValue
]
=
1
;
}
deepEqual
(
snapshot
.
counts
expectedCounts
)
;
}
