ChromeUtils
.
defineESModuleGetters
(
this
{
AddonTestUtils
:
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
sys
.
mjs
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
ExtensionTestUtils
:
"
resource
:
/
/
testing
-
common
/
ExtensionXPCShellUtils
.
sys
.
mjs
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
HttpServer
:
"
resource
:
/
/
testing
-
common
/
httpd
.
sys
.
mjs
"
Region
:
"
resource
:
/
/
gre
/
modules
/
Region
.
sys
.
mjs
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
sys
.
mjs
"
RemoteSettingsClient
:
"
resource
:
/
/
services
-
settings
/
RemoteSettingsClient
.
sys
.
mjs
"
SearchEngineSelector
:
"
resource
:
/
/
gre
/
modules
/
SearchEngineSelector
.
sys
.
mjs
"
SearchService
:
"
resource
:
/
/
gre
/
modules
/
SearchService
.
sys
.
mjs
"
SearchSettings
:
"
resource
:
/
/
gre
/
modules
/
SearchSettings
.
sys
.
mjs
"
SearchTestUtils
:
"
resource
:
/
/
testing
-
common
/
SearchTestUtils
.
sys
.
mjs
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
sys
.
mjs
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
updateAppInfo
:
"
resource
:
/
/
testing
-
common
/
AppInfo
.
sys
.
mjs
"
Utils
:
"
resource
:
/
/
services
-
settings
/
Utils
.
sys
.
mjs
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
}
)
;
const
RemoteSettingsUtils
=
Utils
;
updateAppInfo
(
{
name
:
"
XPCShell
"
version
:
"
48
"
platformVersion
:
"
48
"
}
)
;
do_get_profile
(
)
;
SearchTestUtils
.
init
(
this
)
;
const
SETTINGS_FILENAME
=
"
search
.
json
.
mozlz4
"
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
log
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
region
.
log
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
telemetry
.
testing
.
overrideProductsCheck
"
true
)
;
SearchSettings
.
SETTNGS_INVALIDATION_DELAY
=
250
;
async
function
promiseSettingsData
(
)
{
let
path
=
PathUtils
.
join
(
PathUtils
.
profileDir
SETTINGS_FILENAME
)
;
return
IOUtils
.
readJSON
(
path
{
decompress
:
true
}
)
;
}
function
promiseSaveSettingsData
(
data
)
{
return
IOUtils
.
writeJSON
(
PathUtils
.
join
(
PathUtils
.
profileDir
SETTINGS_FILENAME
)
data
{
compress
:
true
}
)
;
}
async
function
promiseEngineMetadata
(
)
{
let
settings
=
await
promiseSettingsData
(
)
;
let
data
=
{
}
;
for
(
let
engine
of
settings
.
engines
)
{
data
[
engine
.
_name
]
=
engine
.
_metaData
;
}
return
data
;
}
async
function
promiseGlobalMetadata
(
)
{
return
(
await
promiseSettingsData
(
)
)
.
metaData
;
}
async
function
promiseSaveGlobalMetadata
(
globalData
)
{
let
data
=
await
promiseSettingsData
(
)
;
data
.
metaData
=
globalData
;
await
promiseSaveSettingsData
(
data
)
;
}
function
promiseDefaultNotification
(
type
=
"
normal
"
)
{
return
SearchTestUtils
.
promiseSearchNotification
(
SearchUtils
.
MODIFIED_TYPE
[
type
=
=
"
private
"
?
"
DEFAULT_PRIVATE
"
:
"
DEFAULT
"
]
SearchUtils
.
TOPIC_ENGINE_MODIFIED
)
;
}
function
removeSettingsFile
(
)
{
let
file
=
do_get_profile
(
)
.
clone
(
)
;
file
.
append
(
SETTINGS_FILENAME
)
;
if
(
file
.
exists
(
)
)
{
file
.
remove
(
false
)
;
return
true
;
}
return
false
;
}
function
isUSTimezone
(
)
{
let
UTCOffset
=
new
Date
(
)
.
getTimezoneOffset
(
)
;
return
UTCOffset
>
=
150
&
&
UTCOffset
<
=
600
;
}
const
kTestEngineName
=
"
Test
search
engine
"
;
function
promiseAfterSettings
(
)
{
return
SearchTestUtils
.
promiseSearchNotification
(
"
write
-
settings
-
to
-
disk
-
complete
"
)
;
}
async
function
promiseSetHomeRegion
(
region
)
{
let
promise
=
SearchTestUtils
.
promiseSearchNotification
(
"
engines
-
reloaded
"
)
;
Region
.
_setHomeRegion
(
region
)
;
await
promise
;
}
async
function
promiseSetLocale
(
locale
)
{
if
(
!
Services
.
locale
.
availableLocales
.
includes
(
locale
)
)
{
throw
new
Error
(
"
{
locale
}
"
needs
to
be
included
in
Services
.
locales
.
availableLocales
at
the
start
of
the
test
.
)
;
}
let
promise
=
SearchTestUtils
.
promiseSearchNotification
(
"
engines
-
reloaded
"
)
;
Services
.
locale
.
requestedLocales
=
[
locale
]
;
await
promise
;
}
async
function
readJSONFile
(
file
)
{
return
JSON
.
parse
(
await
IOUtils
.
readUTF8
(
file
.
path
)
)
;
}
function
isSubObjectOf
(
expectedObj
actualObj
skipProp
)
{
for
(
let
prop
in
expectedObj
)
{
if
(
skipProp
&
&
skipProp
(
prop
expectedObj
[
prop
]
)
)
{
continue
;
}
if
(
expectedObj
[
prop
]
instanceof
Object
)
{
Assert
.
equal
(
actualObj
[
prop
]
?
.
length
expectedObj
[
prop
]
.
length
Should
have
the
correct
length
for
property
{
prop
}
)
;
isSubObjectOf
(
expectedObj
[
prop
]
actualObj
[
prop
]
skipProp
)
;
}
else
{
Assert
.
equal
(
actualObj
[
prop
]
expectedObj
[
prop
]
Should
have
the
correct
value
for
property
{
prop
}
)
;
}
}
}
var
gDataUrl
;
function
useHttpServer
(
dir
=
"
data
"
)
{
let
httpServer
=
new
HttpServer
(
)
;
httpServer
.
start
(
-
1
)
;
httpServer
.
registerDirectory
(
"
/
"
do_get_cwd
(
)
)
;
gDataUrl
=
http
:
/
/
localhost
:
{
httpServer
.
identity
.
primaryPort
}
/
{
dir
}
/
;
registerCleanupFunction
(
async
function
cleanup_httpServer
(
)
{
await
new
Promise
(
resolve
=
>
{
httpServer
.
stop
(
resolve
)
;
}
)
;
}
)
;
return
httpServer
;
}
const
TELEMETRY_RESULT_ENUM
=
{
SUCCESS
:
0
SUCCESS_WITHOUT_DATA
:
1
TIMEOUT
:
2
ERROR
:
3
}
;
function
checkCountryResultTelemetry
(
aExpectedValue
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_FETCH_RESULT
"
)
;
let
snapshot
=
histogram
.
snapshot
(
)
;
if
(
aExpectedValue
!
=
null
)
{
equal
(
snapshot
.
values
[
aExpectedValue
]
1
)
;
}
else
{
deepEqual
(
snapshot
.
values
{
}
)
;
}
}
async
function
setupRemoteSettings
(
)
{
const
settings
=
await
RemoteSettings
(
"
hijack
-
blocklists
"
)
;
sinon
.
stub
(
settings
"
get
"
)
.
returns
(
[
{
id
:
"
load
-
paths
"
matches
:
[
"
[
addon
]
searchignore
mozilla
.
com
"
]
_status
:
"
synced
"
}
{
id
:
"
submission
-
urls
"
matches
:
[
"
ignore
=
true
"
]
_status
:
"
synced
"
}
]
)
;
}
async
function
getFileDataBuffer
(
filename
)
{
return
IOUtils
.
read
(
PathUtils
.
join
(
do_get_cwd
(
)
.
path
"
data
"
filename
)
)
;
}
async
function
mockRecordWithAttachment
(
{
filename
engineIdentifiers
imageSize
id
=
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
lastModified
=
Date
.
now
(
)
}
)
{
let
buffer
=
await
getFileDataBuffer
(
filename
)
;
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
Ci
.
nsICryptoHash
.
SHA256
)
;
hasher
.
update
(
buffer
buffer
.
length
)
;
let
hash
=
hasher
.
finish
(
false
)
;
hash
=
Array
.
from
(
hash
(
_
i
)
=
>
(
"
0
"
+
hash
.
charCodeAt
(
i
)
.
toString
(
16
)
)
.
slice
(
-
2
)
)
.
join
(
"
"
)
;
const
mimetypeFromExtension
=
{
ico
:
"
image
/
x
-
icon
"
svg
:
"
image
/
svg
+
xml
"
png
:
"
image
/
png
"
}
;
const
extension
=
filename
.
split
(
"
.
"
)
.
pop
(
)
.
toLowerCase
(
)
;
let
record
=
{
id
engineIdentifiers
imageSize
attachment
:
{
hash
location
:
{
filename
}
filename
size
:
buffer
.
byteLength
mimetype
:
mimetypeFromExtension
[
extension
]
|
|
"
"
}
last_modified
:
lastModified
}
;
let
attachment
=
{
record
blob
:
new
Blob
(
[
buffer
]
)
}
;
return
{
record
attachment
}
;
}
async
function
insertRecordIntoCollection
(
client
item
addAttachmentToCache
=
true
)
{
let
{
record
attachment
}
=
await
mockRecordWithAttachment
(
item
)
;
await
client
.
db
.
create
(
record
)
;
if
(
addAttachmentToCache
)
{
await
client
.
attachments
.
cacheImpl
.
set
(
record
.
id
attachment
)
;
}
await
client
.
db
.
importChanges
(
{
}
record
.
last_modified
)
;
}
function
useCustomGeoServer
(
region
waitToRespond
=
Promise
.
resolve
(
)
)
{
let
srv
=
useHttpServer
(
)
;
srv
.
registerPathHandler
(
"
/
fetch_region
"
async
(
req
res
)
=
>
{
res
.
processAsync
(
)
;
await
waitToRespond
;
res
.
setStatusLine
(
"
1
.
1
"
200
"
OK
"
)
;
res
.
write
(
JSON
.
stringify
(
{
country_code
:
region
}
)
)
;
res
.
finish
(
)
;
}
)
;
Services
.
prefs
.
setCharPref
(
"
browser
.
region
.
network
.
url
"
http
:
/
/
localhost
:
{
srv
.
identity
.
primaryPort
}
/
fetch_region
)
;
}
async
function
assertGleanDefaultEngine
(
expected
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
Glean
.
searchEngineDefault
.
engineId
.
testGetValue
(
)
=
=
(
expected
.
normal
.
engineId
?
?
"
"
)
"
Should
have
set
the
correct
telemetry
id
for
the
normal
engine
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
Glean
.
searchEnginePrivate
.
engineId
.
testGetValue
(
)
=
=
(
expected
.
private
?
.
engineId
?
?
"
"
)
"
Should
have
set
the
correct
telemetry
id
for
the
private
engine
"
)
;
for
(
let
property
of
[
"
displayName
"
"
loadPath
"
"
submissionUrl
"
"
verified
"
]
)
{
if
(
property
in
expected
.
normal
)
{
Assert
.
equal
(
Glean
.
searchEngineDefault
[
property
]
.
testGetValue
(
)
expected
.
normal
[
property
]
?
?
"
"
Should
have
set
{
property
}
correctly
)
;
}
if
(
expected
.
private
&
&
property
in
expected
.
private
)
{
Assert
.
equal
(
Glean
.
searchEnginePrivate
[
property
]
.
testGetValue
(
)
expected
.
private
[
property
]
?
?
"
"
Should
have
set
{
property
}
correctly
)
;
}
}
}
class
SearchObserver
{
constructor
(
expectedNotifications
returnEngineForNotification
=
false
)
{
this
.
observer
=
this
.
observer
.
bind
(
this
)
;
this
.
deferred
=
Promise
.
withResolvers
(
)
;
this
.
expectedNotifications
=
expectedNotifications
;
this
.
returnEngineForNotification
=
returnEngineForNotification
;
Services
.
obs
.
addObserver
(
this
.
observer
SearchUtils
.
TOPIC_ENGINE_MODIFIED
)
;
this
.
timeout
=
setTimeout
(
this
.
handleTimeout
.
bind
(
this
)
5000
)
;
}
get
promise
(
)
{
return
this
.
deferred
.
promise
;
}
handleTimeout
(
)
{
this
.
deferred
.
reject
(
new
Error
(
"
Waiting
for
Notifications
timed
out
only
received
:
"
+
this
.
expectedNotifications
.
join
(
"
"
)
)
)
;
}
observer
(
subject
topic
data
)
{
Assert
.
greater
(
this
.
expectedNotifications
.
length
0
"
Should
be
expecting
a
notification
"
)
;
Assert
.
equal
(
data
this
.
expectedNotifications
[
0
]
"
Should
have
received
the
next
expected
notification
"
)
;
if
(
this
.
returnEngineForNotification
&
&
data
=
=
this
.
returnEngineForNotification
)
{
this
.
engineToReturn
=
subject
.
QueryInterface
(
Ci
.
nsISearchEngine
)
;
}
this
.
expectedNotifications
.
shift
(
)
;
if
(
!
this
.
expectedNotifications
.
length
)
{
clearTimeout
(
this
.
timeout
)
;
delete
this
.
timeout
;
this
.
deferred
.
resolve
(
this
.
engineToReturn
)
;
Services
.
obs
.
removeObserver
(
this
.
observer
SearchUtils
.
TOPIC_ENGINE_MODIFIED
)
;
}
}
}
let
updatePromise
=
SearchTestUtils
.
promiseSearchNotification
(
"
settings
-
update
-
complete
"
)
;
registerCleanupFunction
(
async
(
)
=
>
{
if
(
Services
.
search
.
isInitialized
)
{
await
updatePromise
;
}
}
)
;
let
consoleAllowList
=
[
'
property
"
localProfileDir
"
is
non
-
configurable
and
can
\
'
t
be
deleted
'
'
property
"
profileDir
"
is
non
-
configurable
and
can
\
'
t
be
deleted
'
]
;
let
endConsoleListening
=
TestUtils
.
listenForConsoleMessages
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
let
msgs
=
await
endConsoleListening
(
)
;
for
(
let
msg
of
msgs
)
{
msg
=
msg
.
wrappedJSObject
;
if
(
msg
.
level
!
=
"
error
"
)
{
continue
;
}
if
(
!
msg
.
arguments
?
.
length
)
{
Assert
.
ok
(
false
"
Unexpected
console
message
received
during
test
:
"
+
msg
)
;
}
else
{
let
firstArg
=
msg
.
arguments
[
0
]
;
let
message
=
firstArg
.
messageContents
?
?
firstArg
.
message
?
?
firstArg
;
if
(
!
consoleAllowList
.
some
(
e
=
>
message
.
includes
(
e
)
)
)
{
Assert
.
ok
(
false
"
Unexpected
console
message
received
during
test
:
"
+
message
)
;
}
}
}
}
)
;
