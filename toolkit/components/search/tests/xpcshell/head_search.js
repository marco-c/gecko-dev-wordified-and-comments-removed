const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
RemoteSettingsClient
:
"
resource
:
/
/
services
-
settings
/
RemoteSettingsClient
.
jsm
"
SearchTestUtils
:
"
resource
:
/
/
testing
-
common
/
SearchTestUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
jsm
"
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
jsm
"
}
)
;
var
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
var
{
HttpServer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
var
{
AddonTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
)
;
const
PREF_SEARCH_URL
=
"
geoSpecificDefaults
.
url
"
;
const
NS_APP_SEARCH_DIR
=
"
SrchPlugns
"
;
const
MODE_RDONLY
=
FileUtils
.
MODE_RDONLY
;
const
MODE_WRONLY
=
FileUtils
.
MODE_WRONLY
;
const
MODE_CREATE
=
FileUtils
.
MODE_CREATE
;
const
MODE_TRUNCATE
=
FileUtils
.
MODE_TRUNCATE
;
const
CACHE_FILENAME
=
"
search
.
json
.
mozlz4
"
;
var
XULRuntime
=
Cc
[
"
mozilla
.
org
/
xre
/
runtime
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
log
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
geoSpecificDefaults
"
true
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
search
.
geoip
.
timeout
"
3000
)
;
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
geoip
.
url
"
"
"
)
;
Services
.
prefs
.
getDefaultBranch
(
SearchUtils
.
BROWSER_SEARCH_PREF
)
.
setCharPref
(
"
geoSpecificDefaults
.
url
"
"
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gModernConfig
"
SearchUtils
.
BROWSER_SEARCH_PREF
+
"
modernConfig
"
false
)
;
AddonTestUtils
.
init
(
this
false
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
42
"
"
42
"
)
;
function
configureToLoadJarEngines
(
)
{
let
searchExtensions
=
do_get_cwd
(
)
;
searchExtensions
.
append
(
"
data
"
)
;
searchExtensions
.
append
(
"
search
-
extensions
"
)
;
let
url
=
"
file
:
/
/
"
+
searchExtensions
.
path
;
let
resProt
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
resProt
.
setSubstitution
(
"
search
-
extensions
"
Services
.
io
.
newURI
(
url
)
)
;
}
function
useTestEngines
(
folder
)
{
let
searchExtensions
=
do_get_cwd
(
)
;
searchExtensions
.
append
(
"
data
"
)
;
searchExtensions
.
append
(
folder
)
;
let
resProt
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
resProt
.
setSubstitution
(
"
search
-
extensions
"
Services
.
io
.
newURI
(
"
file
:
/
/
"
+
searchExtensions
.
path
)
)
;
}
async
function
promiseCacheData
(
)
{
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CACHE_FILENAME
)
;
let
bytes
=
await
OS
.
File
.
read
(
path
{
compression
:
"
lz4
"
}
)
;
return
JSON
.
parse
(
new
TextDecoder
(
)
.
decode
(
bytes
)
)
;
}
function
promiseSaveCacheData
(
data
)
{
return
OS
.
File
.
writeAtomic
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CACHE_FILENAME
)
new
TextEncoder
(
)
.
encode
(
JSON
.
stringify
(
data
)
)
{
compression
:
"
lz4
"
}
)
;
}
async
function
promiseEngineMetadata
(
)
{
let
cache
=
await
promiseCacheData
(
)
;
let
data
=
{
}
;
for
(
let
engine
of
cache
.
engines
)
{
data
[
engine
.
_shortName
]
=
engine
.
_metaData
;
}
return
data
;
}
async
function
promiseGlobalMetadata
(
)
{
return
(
await
promiseCacheData
(
)
)
.
metaData
;
}
async
function
promiseSaveGlobalMetadata
(
globalData
)
{
let
data
=
await
promiseCacheData
(
)
;
data
.
metaData
=
globalData
;
await
promiseSaveCacheData
(
data
)
;
}
async
function
forceExpiration
(
)
{
let
metadata
=
await
promiseGlobalMetadata
(
)
;
metadata
.
searchDefaultExpir
=
Date
.
now
(
)
-
1000
;
await
promiseSaveGlobalMetadata
(
metadata
)
;
}
function
promiseDefaultNotification
(
type
=
"
normal
"
)
{
return
SearchTestUtils
.
promiseSearchNotification
(
SearchUtils
.
MODIFIED_TYPE
[
type
=
=
"
private
"
?
"
DEFAULT_PRIVATE
"
:
"
DEFAULT
"
]
SearchUtils
.
TOPIC_ENGINE_MODIFIED
)
;
}
function
removeCacheFile
(
)
{
let
file
=
do_get_profile
(
)
.
clone
(
)
;
file
.
append
(
CACHE_FILENAME
)
;
if
(
file
.
exists
(
)
)
{
file
.
remove
(
false
)
;
return
true
;
}
return
false
;
}
function
isUSTimezone
(
)
{
let
UTCOffset
=
new
Date
(
)
.
getTimezoneOffset
(
)
;
return
UTCOffset
>
=
150
&
&
UTCOffset
<
=
600
;
}
const
kDefaultenginenamePref
=
"
browser
.
search
.
defaultenginename
"
;
const
kTestEngineName
=
"
Test
search
engine
"
;
const
TOPIC_LOCALES_CHANGE
=
"
intl
:
app
-
locales
-
changed
"
;
function
useTestEngineConfig
(
url
=
"
resource
:
/
/
test
/
data
/
"
)
{
const
resProt
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
resProt
.
setSubstitution
(
"
search
-
extensions
"
Services
.
io
.
newURI
(
url
)
)
;
}
function
getDefaultEngineName
(
isUS
=
false
privateMode
=
false
)
{
let
chan
=
NetUtil
.
newChannel
(
{
uri
:
"
resource
:
/
/
search
-
extensions
/
list
.
json
"
loadUsingSystemPrincipal
:
true
}
)
;
const
settingName
=
privateMode
?
"
searchPrivateDefault
"
:
"
searchDefault
"
;
let
searchSettings
=
parseJsonFromStream
(
chan
.
open
(
)
)
;
let
defaultEngineName
=
searchSettings
.
default
[
settingName
]
;
if
(
!
isUS
)
{
isUS
=
Services
.
locale
.
requestedLocale
=
=
"
en
-
US
"
&
&
isUSTimezone
(
)
;
}
if
(
isUS
&
&
(
"
US
"
in
searchSettings
&
&
settingName
in
searchSettings
.
US
)
)
{
defaultEngineName
=
searchSettings
.
US
[
settingName
]
;
}
return
defaultEngineName
;
}
function
getDefaultEngineList
(
isUS
)
{
let
chan
=
NetUtil
.
newChannel
(
{
uri
:
"
resource
:
/
/
search
-
extensions
/
list
.
json
"
loadUsingSystemPrincipal
:
true
}
)
;
let
json
=
parseJsonFromStream
(
chan
.
open
(
)
)
;
let
visibleDefaultEngines
=
json
.
default
.
visibleDefaultEngines
;
if
(
isUS
=
=
=
undefined
)
{
isUS
=
Services
.
locale
.
requestedLocale
=
=
"
en
-
US
"
&
&
isUSTimezone
(
)
;
}
if
(
isUS
)
{
let
searchSettings
=
json
.
locales
[
"
en
-
US
"
]
;
if
(
"
US
"
in
searchSettings
&
&
"
visibleDefaultEngines
"
in
searchSettings
.
US
)
{
visibleDefaultEngines
=
searchSettings
.
US
.
visibleDefaultEngines
;
}
let
searchRegion
=
"
US
"
;
if
(
"
regionOverrides
"
in
json
&
&
searchRegion
in
json
.
regionOverrides
)
{
for
(
let
engine
in
json
.
regionOverrides
[
searchRegion
]
)
{
let
index
=
visibleDefaultEngines
.
indexOf
(
engine
)
;
if
(
index
>
-
1
)
{
visibleDefaultEngines
[
index
]
=
json
.
regionOverrides
[
searchRegion
]
[
engine
]
;
}
}
}
}
return
visibleDefaultEngines
;
}
function
promiseAfterCache
(
)
{
return
SearchTestUtils
.
promiseSearchNotification
(
"
write
-
cache
-
to
-
disk
-
complete
"
)
;
}
function
parseJsonFromStream
(
aInputStream
)
{
let
bytes
=
NetUtil
.
readInputStream
(
aInputStream
aInputStream
.
available
(
)
)
;
return
JSON
.
parse
(
new
TextDecoder
(
)
.
decode
(
bytes
)
)
;
}
function
readJSONFile
(
aFile
)
{
let
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
try
{
stream
.
init
(
aFile
MODE_RDONLY
FileUtils
.
PERMS_FILE
0
)
;
return
parseJsonFromStream
(
stream
stream
.
available
(
)
)
;
}
catch
(
ex
)
{
dump
(
"
search
test
:
readJSONFile
:
Error
reading
JSON
file
:
"
+
ex
+
"
\
n
"
)
;
}
finally
{
stream
.
close
(
)
;
}
return
false
;
}
function
isSubObjectOf
(
expectedObj
actualObj
skipProp
)
{
for
(
let
prop
in
expectedObj
)
{
if
(
skipProp
&
&
skipProp
(
prop
expectedObj
[
prop
]
)
)
{
continue
;
}
if
(
expectedObj
[
prop
]
instanceof
Object
)
{
Assert
.
equal
(
actualObj
[
prop
]
.
length
expectedObj
[
prop
]
.
length
Should
have
the
correct
length
for
property
{
prop
}
)
;
isSubObjectOf
(
expectedObj
[
prop
]
actualObj
[
prop
]
skipProp
)
;
}
else
{
Assert
.
equal
(
actualObj
[
prop
]
expectedObj
[
prop
]
Should
have
the
correct
value
for
property
{
prop
}
)
;
}
}
}
var
gDataUrl
;
function
useHttpServer
(
)
{
let
httpServer
=
new
HttpServer
(
)
;
httpServer
.
start
(
-
1
)
;
httpServer
.
registerDirectory
(
"
/
"
do_get_cwd
(
)
)
;
gDataUrl
=
"
http
:
/
/
localhost
:
"
+
httpServer
.
identity
.
primaryPort
+
"
/
data
/
"
;
registerCleanupFunction
(
async
function
cleanup_httpServer
(
)
{
await
new
Promise
(
resolve
=
>
{
httpServer
.
stop
(
resolve
)
;
}
)
;
}
)
;
return
httpServer
;
}
async
function
withGeoServer
(
testFn
{
visibleDefaultEngines
=
null
geoLookupData
=
null
preGeolookupPromise
=
Promise
.
resolve
cohort
=
null
intval200
=
86400
*
365
intval503
=
86400
delay
=
0
path
=
"
lookup_defaults
"
}
=
{
}
)
{
let
srv
=
new
HttpServer
(
)
;
let
gRequests
=
[
]
;
srv
.
registerPathHandler
(
"
/
lookup_defaults
"
(
metadata
response
)
=
>
{
let
data
=
{
interval
:
intval200
settings
:
{
searchDefault
:
kTestEngineName
}
}
;
if
(
cohort
)
{
data
.
cohort
=
cohort
;
}
if
(
visibleDefaultEngines
)
{
data
.
settings
.
visibleDefaultEngines
=
visibleDefaultEngines
;
}
response
.
processAsync
(
)
;
setTimeout
(
(
)
=
>
{
response
.
setStatusLine
(
"
1
.
1
"
200
"
OK
"
)
;
response
.
write
(
JSON
.
stringify
(
data
)
)
;
response
.
finish
(
)
;
gRequests
.
push
(
metadata
)
;
}
delay
)
;
}
)
;
srv
.
registerPathHandler
(
"
/
lookup_fail
"
(
metadata
response
)
=
>
{
response
.
processAsync
(
)
;
setTimeout
(
(
)
=
>
{
response
.
setStatusLine
(
"
1
.
1
"
404
"
Not
Found
"
)
;
response
.
finish
(
)
;
gRequests
.
push
(
metadata
)
;
}
delay
)
;
}
)
;
srv
.
registerPathHandler
(
"
/
lookup_unavailable
"
(
metadata
response
)
=
>
{
response
.
processAsync
(
)
;
setTimeout
(
(
)
=
>
{
response
.
setStatusLine
(
"
1
.
1
"
503
"
Service
Unavailable
"
)
;
response
.
setHeader
(
"
Retry
-
After
"
intval503
.
toString
(
)
)
;
response
.
finish
(
)
;
gRequests
.
push
(
metadata
)
;
}
delay
)
;
}
)
;
srv
.
registerPathHandler
(
"
/
lookup_geoip
"
async
(
metadata
response
)
=
>
{
response
.
processAsync
(
)
;
await
preGeolookupPromise
;
response
.
setStatusLine
(
"
1
.
1
"
200
"
OK
"
)
;
response
.
write
(
JSON
.
stringify
(
geoLookupData
)
)
;
response
.
finish
(
)
;
gRequests
.
push
(
metadata
)
;
}
)
;
srv
.
start
(
-
1
)
;
let
url
=
http
:
/
/
localhost
:
{
srv
.
identity
.
primaryPort
}
/
{
path
}
?
;
let
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
SearchUtils
.
BROWSER_SEARCH_PREF
)
;
let
originalURL
=
defaultBranch
.
getCharPref
(
PREF_SEARCH_URL
)
;
defaultBranch
.
setCharPref
(
PREF_SEARCH_URL
url
)
;
Services
.
prefs
.
setCharPref
(
SearchUtils
.
BROWSER_SEARCH_PREF
+
PREF_SEARCH_URL
"
about
:
blank
"
)
;
let
geoLookupUrl
=
geoLookupData
?
http
:
/
/
localhost
:
{
srv
.
identity
.
primaryPort
}
/
lookup_geoip
:
'
data
:
application
/
json
{
"
country_code
"
:
"
FR
"
}
'
;
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
geoip
.
url
"
geoLookupUrl
)
;
try
{
await
testFn
(
gRequests
)
;
}
finally
{
srv
.
stop
(
(
)
=
>
{
}
)
;
defaultBranch
.
setCharPref
(
PREF_SEARCH_URL
originalURL
)
;
Services
.
prefs
.
clearUserPref
(
SearchUtils
.
BROWSER_SEARCH_PREF
+
PREF_SEARCH_URL
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
geoip
.
url
"
)
;
}
}
function
checkNoRequest
(
requests
)
{
Assert
.
equal
(
requests
.
length
0
)
;
}
function
checkRequest
(
requests
cohort
=
"
"
)
{
Assert
.
equal
(
requests
.
length
1
)
;
let
req
=
requests
.
pop
(
)
;
Assert
.
equal
(
req
.
_method
"
GET
"
)
;
Assert
.
equal
(
req
.
_queryString
cohort
?
"
/
"
+
cohort
:
"
"
)
;
}
var
addTestEngines
=
async
function
(
aItems
)
{
if
(
!
gDataUrl
)
{
do_throw
(
"
useHttpServer
must
be
called
before
addTestEngines
.
"
)
;
}
let
engines
=
[
]
;
for
(
let
item
of
aItems
)
{
info
(
"
Adding
engine
:
"
+
item
.
name
)
;
await
new
Promise
(
(
resolve
reject
)
=
>
{
Services
.
obs
.
addObserver
(
function
obs
(
subject
topic
data
)
{
try
{
let
engine
=
subject
.
QueryInterface
(
Ci
.
nsISearchEngine
)
;
info
(
"
Observed
"
+
data
+
"
for
"
+
engine
.
name
)
;
if
(
data
!
=
"
engine
-
added
"
|
|
engine
.
name
!
=
item
.
name
)
{
return
;
}
Services
.
obs
.
removeObserver
(
obs
"
browser
-
search
-
engine
-
modified
"
)
;
engines
.
push
(
engine
)
;
resolve
(
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
}
}
"
browser
-
search
-
engine
-
modified
"
)
;
if
(
item
.
xmlFileName
)
{
Services
.
search
.
addEngine
(
gDataUrl
+
item
.
xmlFileName
null
false
)
;
}
else
{
Services
.
search
.
addEngineWithDetails
(
item
.
name
item
.
details
)
;
}
}
)
;
}
return
engines
;
}
;
function
installTestEngine
(
)
{
useHttpServer
(
)
;
return
addTestEngines
(
[
{
name
:
kTestEngineName
xmlFileName
:
"
engine
.
xml
"
}
]
)
;
}
async
function
asyncReInit
(
{
waitForRegionFetch
=
false
skipReset
=
false
}
=
{
}
)
{
let
promises
=
[
SearchTestUtils
.
promiseSearchNotification
(
"
reinit
-
complete
"
)
]
;
if
(
waitForRegionFetch
)
{
promises
.
push
(
SearchTestUtils
.
promiseSearchNotification
(
"
ensure
-
known
-
region
-
done
"
)
)
;
}
if
(
!
skipReset
)
{
Services
.
search
.
reset
(
)
;
}
Services
.
search
.
reInit
(
!
waitForRegionFetch
)
;
return
Promise
.
all
(
promises
)
;
}
const
TELEMETRY_RESULT_ENUM
=
{
SUCCESS
:
0
SUCCESS_WITHOUT_DATA
:
1
XHRTIMEOUT
:
2
ERROR
:
3
}
;
function
checkCountryResultTelemetry
(
aExpectedValue
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
SEARCH_SERVICE_COUNTRY_FETCH_RESULT
"
)
;
let
snapshot
=
histogram
.
snapshot
(
)
;
if
(
aExpectedValue
!
=
null
)
{
equal
(
snapshot
.
values
[
aExpectedValue
]
1
)
;
}
else
{
deepEqual
(
snapshot
.
values
{
}
)
;
}
}
async
function
setupRemoteSettings
(
)
{
const
settings
=
await
RemoteSettings
(
"
hijack
-
blocklists
"
)
;
sinon
.
stub
(
settings
"
get
"
)
.
returns
(
[
{
id
:
"
load
-
paths
"
matches
:
[
"
[
other
]
addEngineWithDetails
:
searchignore
mozilla
.
com
"
]
_status
:
"
synced
"
}
{
id
:
"
submission
-
urls
"
matches
:
[
"
ignore
=
true
"
]
_status
:
"
synced
"
}
]
)
;
}
let
updatePromise
=
SearchTestUtils
.
promiseSearchNotification
(
"
settings
-
update
-
complete
"
)
;
registerCleanupFunction
(
async
(
)
=
>
{
if
(
Services
.
search
.
isInitialized
)
{
await
updatePromise
;
}
}
)
;
