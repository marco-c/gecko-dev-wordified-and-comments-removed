"
use
strict
"
;
var
gTestLog
=
[
]
;
var
expectedLog
=
[
"
engine
-
changed
"
"
engine
-
added
"
"
engine
-
default
"
"
engine
-
loaded
"
"
engine
-
removed
"
]
;
function
create_search_observer
(
resolve
)
{
return
function
search_observer
(
subject
topic
data
)
{
let
engine
=
subject
.
QueryInterface
(
Ci
.
nsISearchEngine
)
;
gTestLog
.
push
(
data
+
"
for
"
+
engine
.
name
)
;
info
(
"
Observer
:
"
+
data
+
"
for
"
+
engine
.
name
)
;
switch
(
data
)
{
case
"
engine
-
added
"
:
let
retrievedEngine
=
Services
.
search
.
getEngineByName
(
"
Test
search
engine
"
)
;
Assert
.
equal
(
engine
retrievedEngine
)
;
Services
.
search
.
defaultEngine
=
engine
;
executeSoon
(
function
(
)
{
Services
.
search
.
removeEngine
(
engine
)
;
}
)
;
break
;
case
"
engine
-
removed
"
:
let
engineNameOutput
=
"
for
Test
search
engine
"
;
expectedLog
=
expectedLog
.
map
(
logLine
=
>
logLine
+
engineNameOutput
)
;
info
(
"
expectedLog
:
\
n
"
+
expectedLog
.
join
(
"
\
n
"
)
)
;
info
(
"
gTestLog
:
\
n
"
+
gTestLog
.
join
(
"
\
n
"
)
)
;
for
(
let
i
=
0
;
i
<
expectedLog
.
length
;
i
+
+
)
{
Assert
.
equal
(
gTestLog
[
i
]
expectedLog
[
i
]
)
;
}
Assert
.
equal
(
gTestLog
.
length
expectedLog
.
length
)
;
resolve
(
)
;
break
;
}
}
;
}
add_task
(
async
function
setup
(
)
{
await
AddonTestUtils
.
promiseStartupManager
(
)
;
}
)
;
add_task
(
async
function
test_notifications
(
)
{
return
new
Promise
(
resolve
=
>
{
useHttpServer
(
)
;
registerCleanupFunction
(
function
cleanup
(
)
{
Services
.
obs
.
removeObserver
(
search_observer
"
browser
-
search
-
engine
-
modified
"
)
;
}
)
;
let
search_observer
=
create_search_observer
(
resolve
)
;
Services
.
obs
.
addObserver
(
search_observer
"
browser
-
search
-
engine
-
modified
"
)
;
Services
.
search
.
addEngine
(
gDataUrl
+
"
engine
.
xml
"
null
false
)
;
}
)
;
}
)
;
