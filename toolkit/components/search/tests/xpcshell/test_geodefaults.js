"
use
strict
"
;
var
requests
=
[
]
;
var
gServerCohort
=
"
"
;
const
kUrlPref
=
"
geoSpecificDefaults
.
url
"
;
const
kDayInSeconds
=
86400
;
const
kYearInSeconds
=
kDayInSeconds
*
365
;
function
run_test
(
)
{
let
srv
=
new
HttpServer
(
)
;
srv
.
registerPathHandler
(
"
/
lookup_defaults
"
(
metadata
response
)
=
>
{
response
.
setStatusLine
(
"
1
.
1
"
200
"
OK
"
)
;
let
data
=
{
interval
:
kYearInSeconds
settings
:
{
searchDefault
:
"
Test
search
engine
"
}
}
;
if
(
gServerCohort
)
data
.
cohort
=
gServerCohort
;
response
.
write
(
JSON
.
stringify
(
data
)
)
;
requests
.
push
(
metadata
)
;
}
)
;
srv
.
registerPathHandler
(
"
/
lookup_fail
"
(
metadata
response
)
=
>
{
response
.
setStatusLine
(
"
1
.
1
"
404
"
Not
Found
"
)
;
requests
.
push
(
metadata
)
;
}
)
;
srv
.
registerPathHandler
(
"
/
lookup_unavailable
"
(
metadata
response
)
=
>
{
response
.
setStatusLine
(
"
1
.
1
"
503
"
Service
Unavailable
"
)
;
response
.
setHeader
(
"
Retry
-
After
"
kDayInSeconds
.
toString
(
)
)
;
requests
.
push
(
metadata
)
;
}
)
;
srv
.
start
(
-
1
)
;
registerCleanupFunction
(
(
)
=
>
srv
.
stop
(
(
)
=
>
{
}
)
)
;
let
url
=
"
http
:
/
/
localhost
:
"
+
srv
.
identity
.
primaryPort
+
"
/
lookup_defaults
?
"
;
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
.
setCharPref
(
kUrlPref
url
)
;
Services
.
prefs
.
setCharPref
(
BROWSER_SEARCH_PREF
+
kUrlPref
"
about
:
blank
"
)
;
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
geoip
.
url
"
'
data
:
application
/
json
{
"
country_code
"
:
"
FR
"
}
'
)
;
run_next_test
(
)
;
}
function
checkNoRequest
(
)
{
Assert
.
equal
(
requests
.
length
0
)
;
}
function
checkRequest
(
cohort
=
"
"
)
{
Assert
.
equal
(
requests
.
length
1
)
;
let
req
=
requests
.
pop
(
)
;
Assert
.
equal
(
req
.
_method
"
GET
"
)
;
Assert
.
equal
(
req
.
_queryString
cohort
?
"
/
"
+
cohort
:
"
"
)
;
}
add_task
(
async
function
no_request_if_prefed_off
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
geoSpecificDefaults
"
false
)
;
await
asyncInit
(
)
;
checkNoRequest
(
)
;
await
promiseAfterCache
(
)
;
await
installTestEngine
(
)
;
await
promiseAfterCache
(
)
;
Assert
.
equal
(
Services
.
search
.
currentEngine
.
name
getDefaultEngineName
(
false
)
)
;
let
metadata
=
await
promiseGlobalMetadata
(
)
;
Assert
.
equal
(
typeof
metadata
.
searchDefaultExpir
"
undefined
"
)
;
Assert
.
equal
(
typeof
metadata
.
searchDefault
"
undefined
"
)
;
Assert
.
equal
(
typeof
metadata
.
searchDefaultHash
"
undefined
"
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
geoSpecificDefaults
"
true
)
;
}
)
;
add_task
(
async
function
should_get_geo_defaults_only_once
(
)
{
Assert
.
ok
(
Services
.
prefs
.
prefHasUserValue
(
"
browser
.
search
.
countryCode
"
)
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
"
browser
.
search
.
countryCode
"
)
"
FR
"
)
;
await
asyncReInit
(
)
;
checkRequest
(
)
;
Assert
.
equal
(
Services
.
search
.
currentEngine
.
name
kTestEngineName
)
;
await
promiseAfterCache
(
)
;
let
metadata
=
await
promiseGlobalMetadata
(
)
;
Assert
.
equal
(
typeof
metadata
.
searchDefaultExpir
"
number
"
)
;
Assert
.
ok
(
metadata
.
searchDefaultExpir
>
Date
.
now
(
)
)
;
Assert
.
equal
(
typeof
metadata
.
searchDefault
"
string
"
)
;
Assert
.
equal
(
metadata
.
searchDefault
"
Test
search
engine
"
)
;
Assert
.
equal
(
typeof
metadata
.
searchDefaultHash
"
string
"
)
;
Assert
.
equal
(
metadata
.
searchDefaultHash
.
length
44
)
;
await
asyncReInit
(
)
;
checkNoRequest
(
)
;
Assert
.
equal
(
Services
.
search
.
currentEngine
.
name
kTestEngineName
)
;
}
)
;
add_task
(
async
function
should_request_when_countryCode_not_set
(
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
countryCode
"
)
;
await
asyncReInit
(
)
;
checkRequest
(
)
;
await
promiseAfterCache
(
)
;
}
)
;
add_task
(
async
function
should_recheck_if_interval_expired
(
)
{
await
forceExpiration
(
)
;
let
date
=
Date
.
now
(
)
;
await
asyncReInit
(
)
;
checkRequest
(
)
;
await
promiseAfterCache
(
)
;
let
metadata
=
await
promiseGlobalMetadata
(
)
;
Assert
.
equal
(
typeof
metadata
.
searchDefaultExpir
"
number
"
)
;
Assert
.
ok
(
metadata
.
searchDefaultExpir
>
=
date
+
kYearInSeconds
*
1000
)
;
Assert
.
ok
(
metadata
.
searchDefaultExpir
<
date
+
(
kYearInSeconds
+
3600
)
*
1000
)
;
}
)
;
add_task
(
async
function
should_recheck_if_appversion_changed
(
)
{
let
data
=
await
promiseCacheData
(
)
;
Assert
.
equal
(
data
.
appVersion
Services
.
appinfo
.
version
)
;
data
.
appVersion
=
"
1
"
;
await
promiseSaveCacheData
(
data
)
;
await
asyncReInit
(
)
;
checkRequest
(
)
;
await
promiseAfterCache
(
)
;
data
=
await
promiseCacheData
(
)
;
Assert
.
equal
(
data
.
appVersion
Services
.
appinfo
.
version
)
;
}
)
;
add_task
(
async
function
should_recheck_if_appversion_changed_sync
(
)
{
let
data
=
await
promiseCacheData
(
)
;
Assert
.
equal
(
data
.
appVersion
Services
.
appinfo
.
version
)
;
data
.
appVersion
=
"
1
"
;
await
promiseSaveCacheData
(
data
)
;
let
commitPromise
=
promiseAfterCache
(
)
;
let
unInitPromise
=
waitForSearchNotification
(
"
uninit
-
complete
"
)
;
let
reInitPromise
=
asyncReInit
(
)
;
await
unInitPromise
;
Assert
.
ok
(
!
Services
.
search
.
isInitialized
)
;
Services
.
search
.
getEngines
(
)
;
Assert
.
ok
(
Services
.
search
.
isInitialized
)
;
await
reInitPromise
;
checkRequest
(
)
;
await
commitPromise
;
data
=
await
promiseCacheData
(
)
;
Assert
.
equal
(
data
.
appVersion
Services
.
appinfo
.
version
)
;
}
)
;
add_task
(
async
function
should_recheck_when_broken_hash
(
)
{
let
metadata
=
await
promiseGlobalMetadata
(
)
;
let
hash
=
metadata
.
searchDefaultHash
;
metadata
.
searchDefaultHash
=
"
broken
"
;
await
promiseSaveGlobalMetadata
(
metadata
)
;
let
commitPromise
=
promiseAfterCache
(
)
;
let
unInitPromise
=
waitForSearchNotification
(
"
uninit
-
complete
"
)
;
let
reInitPromise
=
asyncReInit
(
)
;
await
unInitPromise
;
Assert
.
ok
(
!
Services
.
search
.
isInitialized
)
;
Assert
.
equal
(
Services
.
search
.
currentEngine
.
name
getDefaultEngineName
(
false
)
)
;
Assert
.
ok
(
Services
.
search
.
isInitialized
)
;
await
reInitPromise
;
checkRequest
(
)
;
await
commitPromise
;
metadata
=
await
promiseGlobalMetadata
(
)
;
Assert
.
equal
(
typeof
metadata
.
searchDefaultHash
"
string
"
)
;
if
(
metadata
.
searchDefaultHash
=
=
"
broken
"
)
{
info
(
"
waiting
for
the
cache
to
be
saved
a
second
time
"
)
;
await
promiseAfterCache
(
)
;
metadata
=
await
promiseGlobalMetadata
(
)
;
}
Assert
.
equal
(
metadata
.
searchDefaultHash
hash
)
;
Assert
.
equal
(
Services
.
search
.
currentEngine
.
name
getDefaultEngineName
(
false
)
)
;
await
asyncReInit
(
)
;
checkNoRequest
(
)
;
Assert
.
equal
(
Services
.
search
.
currentEngine
.
name
kTestEngineName
)
;
}
)
;
add_task
(
async
function
should_remember_cohort_id
(
)
{
const
cohortPref
=
"
browser
.
search
.
cohort
"
;
Assert
.
equal
(
Services
.
prefs
.
getPrefType
(
cohortPref
)
Services
.
prefs
.
PREF_INVALID
)
;
let
cohort
=
gServerCohort
=
"
xpcshell
"
;
await
forceExpiration
(
)
;
let
commitPromise
=
promiseAfterCache
(
)
;
await
asyncReInit
(
)
;
checkRequest
(
)
;
await
commitPromise
;
Assert
.
equal
(
Services
.
prefs
.
getPrefType
(
cohortPref
)
Services
.
prefs
.
PREF_STRING
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
cohortPref
)
cohort
)
;
gServerCohort
=
"
"
;
await
forceExpiration
(
)
;
commitPromise
=
promiseAfterCache
(
)
;
await
asyncReInit
(
)
;
checkRequest
(
cohort
)
;
await
commitPromise
;
Assert
.
equal
(
Services
.
prefs
.
getPrefType
(
cohortPref
)
Services
.
prefs
.
PREF_INVALID
)
;
}
)
;
add_task
(
async
function
should_retry_after_failure
(
)
{
let
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
;
let
originalUrl
=
defaultBranch
.
getCharPref
(
kUrlPref
)
;
defaultBranch
.
setCharPref
(
kUrlPref
originalUrl
.
replace
(
"
defaults
"
"
fail
"
)
)
;
await
forceExpiration
(
)
;
await
asyncReInit
(
)
;
checkRequest
(
)
;
await
asyncReInit
(
)
;
checkRequest
(
)
;
}
)
;
add_task
(
async
function
should_honor_retry_after_header
(
)
{
let
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
BROWSER_SEARCH_PREF
)
;
let
originalUrl
=
defaultBranch
.
getCharPref
(
kUrlPref
)
;
defaultBranch
.
setCharPref
(
kUrlPref
originalUrl
.
replace
(
"
fail
"
"
unavailable
"
)
)
;
await
forceExpiration
(
)
;
let
date
=
Date
.
now
(
)
;
let
commitPromise
=
promiseAfterCache
(
)
;
await
asyncReInit
(
)
;
checkRequest
(
)
;
await
commitPromise
;
let
metadata
=
await
promiseGlobalMetadata
(
)
;
Assert
.
equal
(
typeof
metadata
.
searchDefaultExpir
"
number
"
)
;
Assert
.
ok
(
metadata
.
searchDefaultExpir
>
=
date
+
kDayInSeconds
*
1000
)
;
Assert
.
ok
(
metadata
.
searchDefaultExpir
<
date
+
(
kDayInSeconds
+
3600
)
*
1000
)
;
await
asyncReInit
(
)
;
checkNoRequest
(
)
;
}
)
;
