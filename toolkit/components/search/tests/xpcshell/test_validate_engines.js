"
use
strict
"
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
const
{
SearchUtils
SearchExtensionLoader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
jsm
"
)
;
function
traverse
(
obj
fun
)
{
for
(
var
i
in
obj
)
{
fun
.
apply
(
this
[
i
obj
[
i
]
]
)
;
if
(
obj
[
i
]
!
=
=
null
&
&
typeof
obj
[
i
]
=
=
"
object
"
)
{
traverse
(
obj
[
i
]
fun
)
;
}
}
}
add_task
(
async
function
setup
(
)
{
let
engines
=
await
fetch
(
SearchUtils
.
LIST_JSON_URL
)
.
then
(
req
=
>
req
.
json
(
)
)
;
let
visibleDefaultEngines
=
new
Set
(
)
;
traverse
(
engines
(
key
val
)
=
>
{
if
(
key
=
=
=
"
visibleDefaultEngines
"
)
{
val
.
forEach
(
engine
=
>
visibleDefaultEngines
.
add
(
engine
)
)
;
}
}
)
;
let
listjson
=
{
default
:
{
visibleDefaultEngines
:
Array
.
from
(
visibleDefaultEngines
)
}
}
;
SearchUtils
.
LIST_JSON_URL
=
"
data
:
application
/
json
"
+
JSON
.
stringify
(
listjson
)
;
SearchExtensionLoader
.
_strict
=
true
;
await
AddonTestUtils
.
promiseStartupManager
(
)
;
}
)
;
add_task
(
async
function
test_validate_engines
(
)
{
await
Services
.
search
.
init
(
)
.
then
(
(
)
=
>
{
ok
(
true
"
all
engines
parsed
and
loaded
"
)
;
}
)
.
catch
(
(
)
=
>
{
ok
(
false
"
an
engine
failed
to
parse
and
load
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_install_timeout_failure
(
)
{
Services
.
prefs
.
setIntPref
(
"
browser
.
search
.
addonLoadTimeout
"
1
)
;
removeCacheFile
(
)
;
Services
.
search
.
reset
(
)
;
await
Services
.
search
.
init
(
)
.
then
(
(
)
=
>
{
ok
(
false
"
search
init
did
not
time
out
"
)
;
}
)
.
catch
(
error
=
>
{
equal
(
Cr
.
NS_ERROR_FAILURE
error
"
search
init
timed
out
"
)
;
}
)
;
}
)
;
