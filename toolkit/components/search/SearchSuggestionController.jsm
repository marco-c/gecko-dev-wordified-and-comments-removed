"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SearchSuggestionController
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
jsm
"
}
)
;
const
DEFAULT_FORM_HISTORY_PARAM
=
"
searchbar
-
history
"
;
const
HTTP_OK
=
200
;
const
BROWSER_SUGGEST_PREF
=
"
browser
.
search
.
suggest
.
enabled
"
;
const
BROWSER_SUGGEST_PRIVATE_PREF
=
"
browser
.
search
.
suggest
.
enabled
.
private
"
;
const
REMOTE_TIMEOUT_PREF
=
"
browser
.
search
.
suggest
.
timeout
"
;
const
REMOTE_TIMEOUT_DEFAULT
=
500
;
const
SEARCH_DATA_TRANSFERRED_SCALAR
=
"
browser
.
search
.
data_transferred
"
;
const
SEARCH_TELEMETRY_KEY_PREFIX
=
"
sggt
"
;
const
SEARCH_TELEMETRY_PRIVATE_BROWSING_KEY_SUFFIX
=
"
pb
"
;
const
SEARCH_TELEMETRY_LATENCY
=
"
SEARCH_SUGGESTIONS_LATENCY_MS
"
;
function
uuid
(
)
{
let
uuid
=
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
;
return
uuid
.
slice
(
1
uuid
.
length
-
1
)
;
}
class
SearchSuggestionEntry
{
constructor
(
value
{
matchPrefix
tail
}
=
{
}
)
{
this
.
#
value
=
value
;
this
.
#
matchPrefix
=
matchPrefix
;
this
.
#
tail
=
tail
;
}
get
value
(
)
{
return
this
.
#
value
;
}
get
matchPrefix
(
)
{
return
this
.
#
matchPrefix
;
}
get
tail
(
)
{
return
this
.
#
tail
;
}
get
tailOffsetIndex
(
)
{
if
(
!
this
.
#
tail
)
{
return
-
1
;
}
let
offsetIndex
=
this
.
#
value
.
lastIndexOf
(
this
.
#
tail
)
;
if
(
offsetIndex
+
this
.
#
tail
.
length
<
this
.
#
value
.
length
)
{
let
lastWordIndex
=
this
.
#
value
.
lastIndexOf
(
"
"
)
;
if
(
this
.
#
tail
.
startsWith
(
this
.
#
value
.
substring
(
lastWordIndex
)
)
)
{
offsetIndex
=
lastWordIndex
;
}
else
{
offsetIndex
=
-
1
;
}
}
return
offsetIndex
;
}
equals
(
otherEntry
)
{
return
otherEntry
.
value
=
=
this
.
value
;
}
#
value
;
#
matchPrefix
;
#
tail
;
}
var
gFirstPartyDomains
=
new
Map
(
)
;
class
SearchSuggestionController
{
static
SEARCH_HISTORY_MAX_VALUE_LENGTH
=
255
;
static
REMOTE_TIMEOUT_DEFAULT
=
REMOTE_TIMEOUT_DEFAULT
;
static
engineOffersSuggestions
(
engine
)
{
return
engine
.
supportsResponseType
(
lazy
.
SearchUtils
.
URL_TYPE
.
SUGGEST_JSON
)
;
}
constructor
(
callback
=
null
)
{
this
.
#
callback
=
callback
;
}
maxLocalResults
=
5
;
maxRemoteResults
=
10
;
formHistoryParam
=
DEFAULT_FORM_HISTORY_PARAM
;
formHistoryResult
=
null
;
remoteResultTimer
=
null
;
deferredRemoteResult
=
null
;
request
=
null
;
get
firstPartyDomains
(
)
{
return
gFirstPartyDomains
;
}
fetch
(
searchTerm
privateMode
engine
userContextId
=
0
restrictToEngine
=
false
dedupeRemoteAndLocal
=
true
)
{
this
.
stop
(
)
;
if
(
!
Services
.
search
.
isInitialized
)
{
throw
new
Error
(
"
Search
not
initialized
yet
(
how
did
you
get
here
?
)
"
)
;
}
if
(
typeof
privateMode
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
The
privateMode
argument
is
required
to
avoid
unintentional
privacy
leaks
"
)
;
}
if
(
!
engine
.
getSubmission
)
{
throw
new
Error
(
"
Invalid
search
engine
"
)
;
}
if
(
!
this
.
maxLocalResults
&
&
!
this
.
maxRemoteResults
)
{
throw
new
Error
(
"
Zero
results
expected
what
are
you
trying
to
do
?
"
)
;
}
if
(
this
.
maxLocalResults
<
0
|
|
this
.
maxRemoteResults
<
0
)
{
throw
new
Error
(
"
Number
of
requested
results
must
be
positive
"
)
;
}
let
promises
=
[
]
;
this
.
#
searchString
=
searchTerm
;
if
(
searchTerm
&
&
this
.
suggestionsEnabled
&
&
(
!
privateMode
|
|
this
.
suggestionsInPrivateBrowsingEnabled
)
&
&
this
.
maxRemoteResults
&
&
engine
.
supportsResponseType
(
lazy
.
SearchUtils
.
URL_TYPE
.
SUGGEST_JSON
)
)
{
this
.
#
deferredRemoteResult
=
this
.
#
fetchRemote
(
searchTerm
engine
privateMode
userContextId
)
;
promises
.
push
(
this
.
#
deferredRemoteResult
.
promise
)
;
}
if
(
this
.
maxLocalResults
)
{
promises
.
push
(
this
.
#
fetchFormHistory
(
searchTerm
restrictToEngine
?
engine
.
name
:
null
)
)
;
}
function
handleRejection
(
reason
)
{
if
(
reason
=
=
"
HTTP
request
aborted
"
)
{
return
null
;
}
Cu
.
reportError
(
"
SearchSuggestionController
rejection
:
"
+
reason
)
;
return
null
;
}
return
Promise
.
all
(
promises
)
.
then
(
results
=
>
this
.
#
dedupeAndReturnResults
(
results
dedupeRemoteAndLocal
)
handleRejection
)
;
}
stop
(
)
{
if
(
this
.
#
request
)
{
this
.
#
request
.
abort
(
)
;
}
this
.
#
reset
(
)
;
}
#
callback
;
#
searchString
;
#
deferredRemoteResult
;
#
request
;
#
formHistoryResult
;
#
remoteResultTimer
;
#
requestStopwatchToken
;
#
fetchFormHistory
(
searchTerm
source
)
{
return
new
Promise
(
resolve
=
>
{
let
acSearchObserver
=
{
onSearchResult
:
(
search
result
)
=
>
{
this
.
#
formHistoryResult
=
result
;
if
(
this
.
#
request
)
{
this
.
#
remoteResultTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
#
remoteResultTimer
.
initWithCallback
(
this
.
#
onRemoteTimeout
.
bind
(
this
)
this
.
remoteTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
switch
(
result
.
searchResult
)
{
case
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
:
case
Ci
.
nsIAutoCompleteResult
.
RESULT_NOMATCH
:
if
(
result
.
searchString
!
=
=
this
.
#
searchString
)
{
resolve
(
"
Unexpected
response
this
.
#
searchString
does
not
match
form
history
response
"
)
;
return
;
}
let
fhEntries
=
[
]
;
for
(
let
i
=
0
;
i
<
result
.
matchCount
;
+
+
i
)
{
fhEntries
.
push
(
result
.
getValueAt
(
i
)
)
;
}
resolve
(
{
result
:
fhEntries
formHistoryResult
:
result
}
)
;
break
;
case
Ci
.
nsIAutoCompleteResult
.
RESULT_FAILURE
:
case
Ci
.
nsIAutoCompleteResult
.
RESULT_IGNORED
:
resolve
(
"
Form
History
returned
RESULT_FAILURE
or
RESULT_IGNORED
"
)
;
break
;
}
}
}
;
let
formHistory
=
Cc
[
"
mozilla
.
org
/
autocomplete
/
search
;
1
?
name
=
form
-
history
"
]
.
createInstance
(
Ci
.
nsIAutoCompleteSearch
)
;
let
params
=
this
.
formHistoryParam
|
|
DEFAULT_FORM_HISTORY_PARAM
;
let
options
=
null
;
if
(
source
)
{
options
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag2
)
;
options
.
setPropertyAsAUTF8String
(
"
source
"
source
)
;
}
formHistory
.
startSearch
(
searchTerm
params
this
.
#
formHistoryResult
acSearchObserver
options
)
;
}
)
;
}
#
reportTelemetryForEngine
(
engineId
privateMode
aborted
=
false
)
{
this
.
#
reportBandwidthForEngine
(
engineId
privateMode
)
;
if
(
this
.
#
requestStopwatchToken
)
{
if
(
aborted
)
{
TelemetryStopwatch
.
cancelKeyed
(
SEARCH_TELEMETRY_LATENCY
engineId
this
.
#
requestStopwatchToken
)
;
}
else
{
TelemetryStopwatch
.
finishKeyed
(
SEARCH_TELEMETRY_LATENCY
engineId
this
.
#
requestStopwatchToken
)
;
}
this
.
#
requestStopwatchToken
=
null
;
}
}
#
reportBandwidthForEngine
(
engineId
privateMode
)
{
if
(
!
this
.
#
request
|
|
!
this
.
#
request
.
channel
)
{
return
;
}
let
channel
=
ChannelWrapper
.
get
(
this
.
#
request
.
channel
)
;
let
bytesTransferred
=
channel
.
requestSize
+
channel
.
responseSize
;
if
(
bytesTransferred
=
=
0
)
{
return
;
}
let
telemetryKey
=
{
SEARCH_TELEMETRY_KEY_PREFIX
}
-
{
engineId
}
;
if
(
privateMode
)
{
telemetryKey
+
=
-
{
SEARCH_TELEMETRY_PRIVATE_BROWSING_KEY_SUFFIX
}
;
}
Services
.
telemetry
.
keyedScalarAdd
(
SEARCH_DATA_TRANSFERRED_SCALAR
telemetryKey
bytesTransferred
)
;
}
#
fetchRemote
(
searchTerm
engine
privateMode
userContextId
)
{
let
deferredResponse
=
lazy
.
PromiseUtils
.
defer
(
)
;
this
.
#
request
=
new
XMLHttpRequest
(
)
;
let
submission
=
engine
.
getSubmission
(
searchTerm
lazy
.
SearchUtils
.
URL_TYPE
.
SUGGEST_JSON
)
;
let
method
=
submission
.
postData
?
"
POST
"
:
"
GET
"
;
this
.
#
request
.
open
(
method
submission
.
uri
.
spec
true
)
;
this
.
#
request
.
channel
.
loadFlags
=
Ci
.
nsIChannel
.
LOAD_ANONYMOUS
|
Ci
.
nsIChannel
.
INHIBIT_PERSISTENT_CACHING
;
if
(
!
gFirstPartyDomains
.
has
(
engine
.
name
)
)
{
gFirstPartyDomains
.
set
(
engine
.
name
{
engine
.
identifier
|
|
uuid
(
)
}
.
search
.
suggestions
.
mozilla
)
;
}
let
firstPartyDomain
=
gFirstPartyDomains
.
get
(
engine
.
name
)
;
this
.
#
request
.
setOriginAttributes
(
{
userContextId
privateBrowsingId
:
privateMode
?
1
:
0
firstPartyDomain
}
)
;
this
.
#
request
.
mozBackgroundRequest
=
true
;
/
/
suppress
dialogs
and
fail
silently
let
engineId
=
engine
.
identifier
|
|
"
other
"
;
this
.
#
request
.
addEventListener
(
"
load
"
this
.
#
onRemoteLoaded
.
bind
(
this
deferredResponse
engineId
privateMode
)
)
;
this
.
#
request
.
addEventListener
(
"
error
"
evt
=
>
{
this
.
#
reportTelemetryForEngine
(
engineId
privateMode
)
;
deferredResponse
.
resolve
(
"
HTTP
error
"
)
;
}
)
;
this
.
#
request
.
addEventListener
(
"
abort
"
evt
=
>
{
this
.
#
reportTelemetryForEngine
(
engineId
privateMode
true
)
;
deferredResponse
.
reject
(
"
HTTP
request
aborted
"
)
;
}
)
;
if
(
submission
.
postData
)
{
this
.
#
request
.
sendInputStream
(
submission
.
postData
)
;
}
else
{
this
.
#
request
.
send
(
)
;
}
if
(
this
.
#
requestStopwatchToken
)
{
TelemetryStopwatch
.
cancelKeyed
(
SEARCH_TELEMETRY_LATENCY
this
.
#
requestStopwatchToken
.
engineId
this
.
#
requestStopwatchToken
)
;
}
this
.
#
requestStopwatchToken
=
{
engineId
}
;
TelemetryStopwatch
.
startKeyed
(
SEARCH_TELEMETRY_LATENCY
engineId
this
.
#
requestStopwatchToken
)
;
return
deferredResponse
;
}
#
onRemoteLoaded
(
deferredResponse
engineId
privateMode
)
{
this
.
#
reportTelemetryForEngine
(
engineId
privateMode
)
;
if
(
!
this
.
#
request
)
{
deferredResponse
.
resolve
(
"
Got
HTTP
response
after
the
request
was
cancelled
"
)
;
return
;
}
let
status
serverResults
;
try
{
status
=
this
.
#
request
.
status
;
}
catch
(
e
)
{
deferredResponse
.
resolve
(
"
Unknown
HTTP
status
:
"
+
e
)
;
return
;
}
if
(
status
!
=
HTTP_OK
|
|
this
.
#
request
.
responseText
=
=
"
"
)
{
deferredResponse
.
resolve
(
"
Non
-
200
status
or
empty
HTTP
response
:
"
+
status
)
;
return
;
}
try
{
serverResults
=
JSON
.
parse
(
this
.
#
request
.
responseText
)
;
}
catch
(
ex
)
{
deferredResponse
.
resolve
(
"
Failed
to
parse
suggestion
JSON
:
"
+
ex
)
;
return
;
}
try
{
if
(
!
Array
.
isArray
(
serverResults
)
|
|
!
serverResults
[
0
]
|
|
(
this
.
#
searchString
.
localeCompare
(
serverResults
[
0
]
undefined
{
sensitivity
:
"
base
"
}
)
&
&
this
.
#
searchString
.
localeCompare
(
decodeURIComponent
(
JSON
.
parse
(
'
"
'
+
serverResults
[
0
]
.
replace
(
/
\
"
/
g
'
\
\
"
'
)
+
'
"
'
)
)
undefined
{
sensitivity
:
"
base
"
}
)
)
)
{
deferredResponse
.
resolve
(
"
Unexpected
response
this
.
#
searchString
does
not
match
remote
response
"
)
;
return
;
}
}
catch
(
ex
)
{
deferredResponse
.
resolve
(
Failed
to
parse
the
remote
response
string
:
{
ex
}
)
;
return
;
}
let
results
=
serverResults
.
slice
(
1
)
|
|
[
]
;
deferredResponse
.
resolve
(
{
result
:
results
}
)
;
}
#
onRemoteTimeout
(
)
{
this
.
#
request
=
null
;
this
.
#
remoteResultTimer
=
null
;
if
(
this
.
#
deferredRemoteResult
)
{
this
.
#
deferredRemoteResult
.
resolve
(
"
HTTP
Timeout
"
)
;
this
.
#
deferredRemoteResult
=
null
;
}
}
#
dedupeAndReturnResults
(
suggestResults
dedupeRemoteAndLocal
)
{
if
(
this
.
#
searchString
=
=
=
null
)
{
return
null
;
}
let
results
=
{
term
:
this
.
#
searchString
remote
:
[
]
local
:
[
]
formHistoryResult
:
null
}
;
for
(
let
resultData
of
suggestResults
)
{
if
(
typeof
result
=
=
=
"
string
"
)
{
Cu
.
reportError
(
"
SearchSuggestionController
found
an
unexpected
string
value
:
"
+
resultData
)
;
}
else
if
(
resultData
.
formHistoryResult
)
{
results
.
formHistoryResult
=
resultData
.
formHistoryResult
;
if
(
resultData
.
result
)
{
results
.
local
=
resultData
.
result
.
map
(
s
=
>
new
SearchSuggestionEntry
(
s
)
)
;
}
}
else
if
(
resultData
.
result
)
{
let
richSuggestionData
=
this
.
#
getRichSuggestionData
(
resultData
.
result
)
;
let
fullTextSuggestions
=
resultData
.
result
[
0
]
;
for
(
let
i
=
0
;
i
<
fullTextSuggestions
.
length
;
+
+
i
)
{
results
.
remote
.
push
(
this
.
#
newSearchSuggestionEntry
(
fullTextSuggestions
[
i
]
richSuggestionData
?
.
[
i
]
)
)
;
}
}
}
if
(
results
.
remote
.
length
)
{
results
.
local
=
results
.
local
.
slice
(
0
this
.
maxLocalResults
)
;
}
if
(
results
.
remote
.
length
&
&
results
.
local
.
length
&
&
dedupeRemoteAndLocal
)
{
for
(
let
i
=
0
;
i
<
results
.
local
.
length
;
+
+
i
)
{
let
dupIndex
=
results
.
remote
.
findIndex
(
e
=
>
e
.
equals
(
results
.
local
[
i
]
)
)
;
if
(
dupIndex
!
=
-
1
)
{
results
.
remote
.
splice
(
dupIndex
1
)
;
}
}
}
let
maxRemoteCount
=
this
.
maxRemoteResults
;
if
(
dedupeRemoteAndLocal
)
{
maxRemoteCount
-
=
results
.
local
.
length
;
}
results
.
remote
=
results
.
remote
.
slice
(
0
maxRemoteCount
)
;
if
(
this
.
#
callback
)
{
this
.
#
callback
(
results
)
;
}
this
.
#
reset
(
)
;
return
results
;
}
#
getRichSuggestionData
(
remoteResultData
)
{
if
(
!
remoteResultData
|
|
!
Array
.
isArray
(
remoteResultData
)
)
{
return
undefined
;
}
for
(
let
entry
of
remoteResultData
)
{
if
(
typeof
entry
=
=
"
object
"
&
&
entry
.
hasOwnProperty
(
"
google
:
suggestdetail
"
)
)
{
let
richData
=
entry
[
"
google
:
suggestdetail
"
]
;
if
(
Array
.
isArray
(
richData
)
&
&
richData
.
length
=
=
remoteResultData
[
0
]
.
length
)
{
return
richData
;
}
}
}
return
undefined
;
}
#
newSearchSuggestionEntry
(
suggestion
richSuggestionData
)
{
if
(
richSuggestionData
)
{
return
new
SearchSuggestionEntry
(
suggestion
{
matchPrefix
:
richSuggestionData
?
.
mp
tail
:
richSuggestionData
?
.
t
}
)
;
}
return
new
SearchSuggestionEntry
(
suggestion
)
;
}
#
reset
(
)
{
this
.
#
request
=
null
;
if
(
this
.
#
remoteResultTimer
)
{
this
.
#
remoteResultTimer
.
cancel
(
)
;
this
.
#
remoteResultTimer
=
null
;
}
this
.
#
deferredRemoteResult
=
null
;
this
.
#
searchString
=
null
;
}
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
SearchSuggestionController
.
prototype
"
remoteTimeout
"
REMOTE_TIMEOUT_PREF
REMOTE_TIMEOUT_DEFAULT
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SearchSuggestionController
.
prototype
"
suggestionsEnabled
"
BROWSER_SUGGEST_PREF
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SearchSuggestionController
.
prototype
"
suggestionsInPrivateBrowsingEnabled
"
BROWSER_SUGGEST_PRIVATE_PREF
false
)
;
