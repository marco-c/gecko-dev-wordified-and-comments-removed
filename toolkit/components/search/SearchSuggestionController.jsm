"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SearchSuggestionController
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
XMLHttpRequest
"
]
)
;
const
SEARCH_RESPONSE_SUGGESTION_JSON
=
"
application
/
x
-
suggestions
+
json
"
;
const
DEFAULT_FORM_HISTORY_PARAM
=
"
searchbar
-
history
"
;
const
HTTP_OK
=
200
;
const
BROWSER_SUGGEST_PREF
=
"
browser
.
search
.
suggest
.
enabled
"
;
const
REMOTE_TIMEOUT_PREF
=
"
browser
.
search
.
suggest
.
timeout
"
;
const
REMOTE_TIMEOUT_DEFAULT
=
500
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
UUIDGenerator
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
var
gRemoteSuggestionsEnabled
=
Services
.
prefs
.
getBoolPref
(
BROWSER_SUGGEST_PREF
)
;
Services
.
prefs
.
addObserver
(
BROWSER_SUGGEST_PREF
function
(
aSubject
aTopic
aData
)
{
gRemoteSuggestionsEnabled
=
Services
.
prefs
.
getBoolPref
(
BROWSER_SUGGEST_PREF
)
;
}
)
;
function
uuid
(
)
{
let
uuid
=
UUIDGenerator
.
generateUUID
(
)
.
toString
(
)
;
return
uuid
.
slice
(
1
uuid
.
length
-
1
)
;
}
var
gFirstPartyDomains
=
new
Map
(
)
;
function
SearchSuggestionController
(
callback
=
null
)
{
this
.
_callback
=
callback
;
}
this
.
SearchSuggestionController
.
prototype
=
{
maxLocalResults
:
5
maxRemoteResults
:
10
formHistoryParam
:
DEFAULT_FORM_HISTORY_PARAM
_formHistoryResult
:
null
_remoteResultTimer
:
null
_deferredRemoteResult
:
null
_callback
:
null
_request
:
null
get
firstPartyDomains
(
)
{
return
gFirstPartyDomains
;
}
fetch
(
searchTerm
privateMode
engine
userContextId
=
0
)
{
this
.
stop
(
)
;
if
(
!
Services
.
search
.
isInitialized
)
{
throw
new
Error
(
"
Search
not
initialized
yet
(
how
did
you
get
here
?
)
"
)
;
}
if
(
typeof
privateMode
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
The
privateMode
argument
is
required
to
avoid
unintentional
privacy
leaks
"
)
;
}
if
(
!
engine
.
getSubmission
)
{
throw
new
Error
(
"
Invalid
search
engine
"
)
;
}
if
(
!
this
.
maxLocalResults
&
&
!
this
.
maxRemoteResults
)
{
throw
new
Error
(
"
Zero
results
expected
what
are
you
trying
to
do
?
"
)
;
}
if
(
this
.
maxLocalResults
<
0
|
|
this
.
maxRemoteResults
<
0
)
{
throw
new
Error
(
"
Number
of
requested
results
must
be
positive
"
)
;
}
let
promises
=
[
]
;
this
.
_searchString
=
searchTerm
;
if
(
searchTerm
&
&
gRemoteSuggestionsEnabled
&
&
this
.
maxRemoteResults
&
&
engine
.
supportsResponseType
(
SEARCH_RESPONSE_SUGGESTION_JSON
)
)
{
this
.
_deferredRemoteResult
=
this
.
_fetchRemote
(
searchTerm
engine
privateMode
userContextId
)
;
promises
.
push
(
this
.
_deferredRemoteResult
.
promise
)
;
}
if
(
this
.
maxLocalResults
)
{
promises
.
push
(
this
.
_fetchFormHistory
(
searchTerm
)
)
;
}
function
handleRejection
(
reason
)
{
if
(
reason
=
=
"
HTTP
request
aborted
"
)
{
return
null
;
}
Cu
.
reportError
(
"
SearchSuggestionController
rejection
:
"
+
reason
)
;
return
null
;
}
return
Promise
.
all
(
promises
)
.
then
(
this
.
_dedupeAndReturnResults
.
bind
(
this
)
handleRejection
)
;
}
stop
(
)
{
if
(
this
.
_request
)
{
this
.
_request
.
abort
(
)
;
}
else
if
(
!
this
.
maxRemoteResults
)
{
Cu
.
reportError
(
"
SearchSuggestionController
:
Cannot
stop
fetching
if
remote
results
were
not
"
+
"
requested
"
)
;
}
this
.
_reset
(
)
;
}
_fetchFormHistory
(
searchTerm
)
{
return
new
Promise
(
resolve
=
>
{
let
acSearchObserver
=
{
onSearchResult
:
(
search
result
)
=
>
{
this
.
_formHistoryResult
=
result
;
if
(
this
.
_request
)
{
this
.
_remoteResultTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_remoteResultTimer
.
initWithCallback
(
this
.
_onRemoteTimeout
.
bind
(
this
)
this
.
remoteTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
switch
(
result
.
searchResult
)
{
case
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
:
case
Ci
.
nsIAutoCompleteResult
.
RESULT_NOMATCH
:
if
(
result
.
searchString
!
=
=
this
.
_searchString
)
{
resolve
(
"
Unexpected
response
this
.
_searchString
does
not
match
form
history
response
"
)
;
return
;
}
let
fhEntries
=
[
]
;
for
(
let
i
=
0
;
i
<
result
.
matchCount
;
+
+
i
)
{
fhEntries
.
push
(
result
.
getValueAt
(
i
)
)
;
}
resolve
(
{
result
:
fhEntries
formHistoryResult
:
result
}
)
;
break
;
case
Ci
.
nsIAutoCompleteResult
.
RESULT_FAILURE
:
case
Ci
.
nsIAutoCompleteResult
.
RESULT_IGNORED
:
resolve
(
"
Form
History
returned
RESULT_FAILURE
or
RESULT_IGNORED
"
)
;
break
;
}
}
}
;
let
formHistory
=
Cc
[
"
mozilla
.
org
/
autocomplete
/
search
;
1
?
name
=
form
-
history
"
]
.
createInstance
(
Ci
.
nsIAutoCompleteSearch
)
;
formHistory
.
startSearch
(
searchTerm
this
.
formHistoryParam
|
|
DEFAULT_FORM_HISTORY_PARAM
this
.
_formHistoryResult
acSearchObserver
)
;
}
)
;
}
_fetchRemote
(
searchTerm
engine
privateMode
userContextId
)
{
let
deferredResponse
=
PromiseUtils
.
defer
(
)
;
this
.
_request
=
new
XMLHttpRequest
(
)
;
let
submission
=
engine
.
getSubmission
(
searchTerm
SEARCH_RESPONSE_SUGGESTION_JSON
)
;
let
method
=
(
submission
.
postData
?
"
POST
"
:
"
GET
"
)
;
this
.
_request
.
open
(
method
submission
.
uri
.
spec
true
)
;
this
.
_request
.
channel
.
loadFlags
=
Ci
.
nsIChannel
.
LOAD_ANONYMOUS
|
Ci
.
nsIChannel
.
INHIBIT_PERSISTENT_CACHING
;
if
(
!
gFirstPartyDomains
.
has
(
engine
.
name
)
)
{
gFirstPartyDomains
.
set
(
engine
.
name
{
engine
.
identifier
|
|
uuid
(
)
}
.
search
.
suggestions
.
mozilla
)
;
}
let
firstPartyDomain
=
gFirstPartyDomains
.
get
(
engine
.
name
)
;
this
.
_request
.
setOriginAttributes
(
{
userContextId
privateBrowsingId
:
privateMode
?
1
:
0
firstPartyDomain
}
)
;
this
.
_request
.
mozBackgroundRequest
=
true
;
this
.
_request
.
addEventListener
(
"
load
"
this
.
_onRemoteLoaded
.
bind
(
this
deferredResponse
)
)
;
this
.
_request
.
addEventListener
(
"
error
"
(
evt
)
=
>
deferredResponse
.
resolve
(
"
HTTP
error
"
)
)
;
this
.
_request
.
addEventListener
(
"
abort
"
(
evt
)
=
>
deferredResponse
.
reject
(
"
HTTP
request
aborted
"
)
)
;
if
(
submission
.
postData
)
{
this
.
_request
.
sendInputStream
(
submission
.
postData
)
;
}
else
{
this
.
_request
.
send
(
)
;
}
return
deferredResponse
;
}
_onRemoteLoaded
(
deferredResponse
)
{
if
(
!
this
.
_request
)
{
deferredResponse
.
resolve
(
"
Got
HTTP
response
after
the
request
was
cancelled
"
)
;
return
;
}
let
status
serverResults
;
try
{
status
=
this
.
_request
.
status
;
}
catch
(
e
)
{
deferredResponse
.
resolve
(
"
Unknown
HTTP
status
:
"
+
e
)
;
return
;
}
if
(
status
!
=
HTTP_OK
|
|
this
.
_request
.
responseText
=
=
"
"
)
{
deferredResponse
.
resolve
(
"
Non
-
200
status
or
empty
HTTP
response
:
"
+
status
)
;
return
;
}
try
{
serverResults
=
JSON
.
parse
(
this
.
_request
.
responseText
)
;
}
catch
(
ex
)
{
deferredResponse
.
resolve
(
"
Failed
to
parse
suggestion
JSON
:
"
+
ex
)
;
return
;
}
if
(
!
serverResults
[
0
]
|
|
this
.
_searchString
.
localeCompare
(
serverResults
[
0
]
undefined
{
sensitivity
:
"
base
"
}
)
)
{
deferredResponse
.
resolve
(
"
Unexpected
response
this
.
_searchString
does
not
match
remote
response
"
)
;
return
;
}
let
results
=
serverResults
[
1
]
|
|
[
]
;
deferredResponse
.
resolve
(
{
result
:
results
}
)
;
}
_onRemoteTimeout
(
)
{
this
.
_request
=
null
;
this
.
_remoteResultTimer
=
null
;
if
(
this
.
_deferredRemoteResult
)
{
this
.
_deferredRemoteResult
.
resolve
(
"
HTTP
Timeout
"
)
;
this
.
_deferredRemoteResult
=
null
;
}
}
_dedupeAndReturnResults
(
suggestResults
)
{
if
(
this
.
_searchString
=
=
=
null
)
{
return
null
;
}
let
results
=
{
term
:
this
.
_searchString
remote
:
[
]
local
:
[
]
formHistoryResult
:
null
}
;
for
(
let
result
of
suggestResults
)
{
if
(
typeof
result
=
=
=
"
string
"
)
{
Cu
.
reportError
(
"
SearchSuggestionController
:
"
+
result
)
;
}
else
if
(
result
.
formHistoryResult
)
{
results
.
formHistoryResult
=
result
.
formHistoryResult
;
results
.
local
=
result
.
result
|
|
[
]
;
}
else
{
results
.
remote
=
result
.
result
|
|
[
]
;
}
}
if
(
results
.
remote
.
length
)
{
results
.
local
=
results
.
local
.
slice
(
0
this
.
maxLocalResults
)
;
}
if
(
results
.
remote
.
length
&
&
results
.
local
.
length
)
{
for
(
let
i
=
0
;
i
<
results
.
local
.
length
;
+
+
i
)
{
let
term
=
results
.
local
[
i
]
;
let
dupIndex
=
results
.
remote
.
indexOf
(
term
)
;
if
(
dupIndex
!
=
-
1
)
{
results
.
remote
.
splice
(
dupIndex
1
)
;
}
}
}
results
.
remote
=
results
.
remote
.
slice
(
0
this
.
maxRemoteResults
-
results
.
local
.
length
)
;
if
(
this
.
_callback
)
{
this
.
_callback
(
results
)
;
}
this
.
_reset
(
)
;
return
results
;
}
_reset
(
)
{
this
.
_request
=
null
;
if
(
this
.
_remoteResultTimer
)
{
this
.
_remoteResultTimer
.
cancel
(
)
;
this
.
_remoteResultTimer
=
null
;
}
this
.
_deferredRemoteResult
=
null
;
this
.
_searchString
=
null
;
}
}
;
this
.
SearchSuggestionController
.
engineOffersSuggestions
=
function
(
engine
)
{
return
engine
.
supportsResponseType
(
SEARCH_RESPONSE_SUGGESTION_JSON
)
;
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
.
SearchSuggestionController
.
prototype
"
remoteTimeout
"
REMOTE_TIMEOUT_PREF
REMOTE_TIMEOUT_DEFAULT
)
;
