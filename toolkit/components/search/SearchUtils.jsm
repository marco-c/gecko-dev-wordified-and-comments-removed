"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SearchUtils
"
"
SearchExtensionLoader
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
const
BROWSER_SEARCH_PREF
=
"
browser
.
search
.
"
;
const
EXT_SEARCH_PREFIX
=
"
resource
:
/
/
search
-
extensions
/
"
;
const
APP_SEARCH_PREFIX
=
"
resource
:
/
/
search
-
plugins
/
"
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
ADDON_LOAD_TIMEOUT
"
BROWSER_SEARCH_PREF
+
"
addonLoadTimeout
"
1000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
loggingEnabled
"
BROWSER_SEARCH_PREF
+
"
log
"
false
)
;
var
SearchUtils
=
{
APP_SEARCH_PREFIX
BROWSER_SEARCH_PREF
EXT_SEARCH_PREFIX
LIST_JSON_URL
:
(
AppConstants
.
platform
=
=
"
android
"
?
APP_SEARCH_PREFIX
:
EXT_SEARCH_PREFIX
)
+
"
list
.
json
"
TOPIC_SEARCH_SERVICE
:
"
browser
-
search
-
service
"
TOPIC_ENGINE_MODIFIED
:
"
browser
-
search
-
engine
-
modified
"
MODIFIED_TYPE
:
{
CHANGED
:
"
engine
-
changed
"
LOADED
:
"
engine
-
loaded
"
REMOVED
:
"
engine
-
removed
"
ADDED
:
"
engine
-
added
"
DEFAULT
:
"
engine
-
default
"
}
URL_TYPE
:
{
SUGGEST_JSON
:
"
application
/
x
-
suggestions
+
json
"
SEARCH
:
"
text
/
html
"
OPENSEARCH
:
"
application
/
opensearchdescription
+
xml
"
}
MAX_ICON_SIZE
:
20000
DEFAULT_QUERY_CHARSET
:
"
ISO
-
8859
-
1
"
SETTINGS_IGNORELIST_KEY
:
"
hijack
-
blocklists
"
notifyAction
(
engine
verb
)
{
if
(
Services
.
search
.
isInitialized
)
{
this
.
log
(
'
NOTIFY
:
Engine
:
"
'
+
engine
.
name
+
'
"
;
Verb
:
"
'
+
verb
+
'
"
'
)
;
Services
.
obs
.
notifyObservers
(
engine
this
.
TOPIC_ENGINE_MODIFIED
verb
)
;
}
}
log
(
text
)
{
if
(
loggingEnabled
)
{
Services
.
console
.
logStringMessage
(
text
)
;
}
}
fail
(
message
resultCode
)
{
this
.
log
(
message
)
;
throw
Components
.
Exception
(
message
resultCode
|
|
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
makeURI
(
urlSpec
)
{
try
{
return
Services
.
io
.
newURI
(
urlSpec
)
;
}
catch
(
ex
)
{
}
return
null
;
}
makeChannel
(
url
)
{
try
{
let
uri
=
typeof
url
=
=
"
string
"
?
Services
.
io
.
newURI
(
url
)
:
url
;
return
Services
.
io
.
newChannelFromURI
(
uri
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
null
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
Ci
.
nsIContentPolicy
.
TYPE_OTHER
)
;
}
catch
(
ex
)
{
}
return
null
;
}
makeExtensionId
(
name
)
{
return
name
+
"
search
.
mozilla
.
org
"
;
}
getExtensionUrl
(
id
)
{
return
EXT_SEARCH_PREFIX
+
id
.
split
(
"
"
)
[
0
]
+
"
/
"
;
}
}
;
const
SearchExtensionLoader
=
{
_promises
:
new
Map
(
)
_strict
:
false
_addPromise
(
id
)
{
let
deferred
=
PromiseUtils
.
defer
(
)
;
if
(
ADDON_LOAD_TIMEOUT
>
0
)
{
deferred
.
timeout
=
setTimeout
(
(
)
=
>
{
deferred
.
reject
(
id
new
Error
(
"
addon
install
timed
out
.
"
)
)
;
this
.
_promises
.
delete
(
id
)
;
}
ADDON_LOAD_TIMEOUT
)
;
}
this
.
_promises
.
set
(
id
deferred
)
;
return
deferred
.
promise
;
}
resolve
(
id
)
{
if
(
this
.
_promises
.
has
(
id
)
)
{
let
deferred
=
this
.
_promises
.
get
(
id
)
;
if
(
deferred
.
timeout
)
{
clearTimeout
(
deferred
.
timeout
)
;
}
deferred
.
resolve
(
)
;
this
.
_promises
.
delete
(
id
)
;
}
}
reject
(
id
error
)
{
if
(
this
.
_promises
.
has
(
id
)
)
{
let
deferred
=
this
.
_promises
.
get
(
id
)
;
if
(
deferred
.
timeout
)
{
clearTimeout
(
deferred
.
timeout
)
;
}
Cu
.
reportError
(
Addon
install
for
search
engine
{
id
}
failed
:
{
error
}
)
;
if
(
this
.
_strict
)
{
deferred
.
reject
(
)
;
}
else
{
deferred
.
resolve
(
)
;
}
this
.
_promises
.
delete
(
id
)
;
}
}
_reset
(
)
{
SearchUtils
.
log
(
SearchExtensionLoader
.
reset
)
;
for
(
let
id
of
this
.
_promises
.
keys
(
)
)
{
this
.
reject
(
id
new
Error
(
installAddons
reset
during
install
)
)
;
}
this
.
_promises
=
new
Map
(
)
;
}
async
installAddons
(
engineIDList
)
{
SearchUtils
.
log
(
SearchExtensionLoader
.
installAddons
)
;
this
.
_reset
(
)
;
let
promises
=
[
]
;
for
(
let
id
of
engineIDList
)
{
promises
.
push
(
this
.
_addPromise
(
id
)
)
;
let
path
=
SearchUtils
.
getExtensionUrl
(
id
)
;
SearchUtils
.
log
(
SearchExtensionLoader
.
installAddons
:
installing
{
id
}
at
{
path
}
)
;
AddonManager
.
installBuiltinAddon
(
path
)
.
catch
(
error
=
>
{
this
.
reject
(
id
error
)
;
}
)
;
}
return
Promise
.
all
(
promises
)
;
}
}
;
