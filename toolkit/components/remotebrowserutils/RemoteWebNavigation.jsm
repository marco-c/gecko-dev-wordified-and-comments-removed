ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
class
RemoteWebNavigation
{
constructor
(
aBrowser
)
{
this
.
_browser
=
aBrowser
;
this
.
_cancelContentJSEpoch
=
1
;
this
.
_currentURI
=
null
;
this
.
canGoBack
=
false
;
this
.
canGoForward
=
false
;
this
.
referringURI
=
null
;
this
.
wrappedJSObject
=
this
;
}
swapBrowser
(
aBrowser
)
{
this
.
_browser
=
aBrowser
;
}
maybeCancelContentJSExecution
(
aNavigationType
aOptions
=
{
}
)
{
const
epoch
=
this
.
_cancelContentJSEpoch
+
+
;
this
.
_browser
.
frameLoader
.
remoteTab
.
maybeCancelContentJSExecution
(
aNavigationType
{
.
.
.
aOptions
epoch
}
)
;
return
epoch
;
}
goBack
(
requireUserInteraction
=
false
)
{
let
cancelContentJSEpoch
=
this
.
maybeCancelContentJSExecution
(
Ci
.
nsIRemoteTab
.
NAVIGATE_BACK
)
;
this
.
_sendMessage
(
"
WebNavigation
:
GoBack
"
{
cancelContentJSEpoch
requireUserInteraction
}
)
;
}
goForward
(
requireUserInteraction
=
false
)
{
let
cancelContentJSEpoch
=
this
.
maybeCancelContentJSExecution
(
Ci
.
nsIRemoteTab
.
NAVIGATE_FORWARD
)
;
this
.
_sendMessage
(
"
WebNavigation
:
GoForward
"
{
cancelContentJSEpoch
requireUserInteraction
}
)
;
}
gotoIndex
(
aIndex
)
{
let
cancelContentJSEpoch
=
this
.
maybeCancelContentJSExecution
(
Ci
.
nsIRemoteTab
.
NAVIGATE_INDEX
{
index
:
aIndex
}
)
;
this
.
_sendMessage
(
"
WebNavigation
:
GotoIndex
"
{
index
:
aIndex
cancelContentJSEpoch
}
)
;
}
loadURI
(
aURI
aLoadURIOptions
)
{
let
uri
;
try
{
let
fixupFlags
=
Services
.
uriFixup
.
webNavigationFlagsToFixupFlags
(
aURI
aLoadURIOptions
.
loadFlags
)
;
let
isBrowserPrivate
=
PrivateBrowsingUtils
.
isBrowserPrivate
(
this
.
_browser
)
;
if
(
isBrowserPrivate
)
{
fixupFlags
|
=
Services
.
uriFixup
.
FIXUP_FLAG_PRIVATE_CONTEXT
;
}
uri
=
Services
.
uriFixup
.
createFixupURI
(
aURI
fixupFlags
)
;
if
(
uri
.
schemeIs
(
"
http
"
)
|
|
uri
.
schemeIs
(
"
https
"
)
)
{
let
principal
=
aLoadURIOptions
.
triggeringPrincipal
;
if
(
!
principal
|
|
principal
.
isSystemPrincipal
)
{
let
attrs
=
{
userContextId
:
this
.
_browser
.
getAttribute
(
"
usercontextid
"
)
|
|
0
privateBrowsingId
:
isBrowserPrivate
?
1
:
0
}
;
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
uri
attrs
)
;
}
Services
.
io
.
speculativeConnect
(
uri
principal
null
)
;
}
}
catch
(
ex
)
{
}
let
cancelContentJSEpoch
=
this
.
maybeCancelContentJSExecution
(
Ci
.
nsIRemoteTab
.
NAVIGATE_URL
{
uri
}
)
;
this
.
_browser
.
frameLoader
.
browsingContext
.
loadURI
(
aURI
{
.
.
.
aLoadURIOptions
cancelContentJSEpoch
}
)
;
}
reload
(
aReloadFlags
)
{
this
.
_sendMessage
(
"
WebNavigation
:
Reload
"
{
loadFlags
:
aReloadFlags
}
)
;
}
stop
(
aStopFlags
)
{
this
.
_sendMessage
(
"
WebNavigation
:
Stop
"
{
loadFlags
:
aStopFlags
}
)
;
}
get
document
(
)
{
return
this
.
_browser
.
contentDocument
;
}
get
currentURI
(
)
{
if
(
!
this
.
_currentURI
)
{
this
.
_currentURI
=
Services
.
io
.
newURI
(
"
about
:
blank
"
)
;
}
return
this
.
_currentURI
;
}
set
currentURI
(
aURI
)
{
let
loadURIOptions
=
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
;
this
.
loadURI
(
aURI
.
spec
loadURIOptions
)
;
}
get
sessionHistory
(
)
{
throw
new
Components
.
Exception
(
"
Not
implemented
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
set
sessionHistory
(
aValue
)
{
throw
new
Components
.
Exception
(
"
Not
implemented
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
_sendMessage
(
aMessage
aData
)
{
try
{
this
.
_browser
.
sendMessageToActor
(
aMessage
aData
"
WebNavigation
"
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
RemoteWebNavigation
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebNavigation
]
)
;
var
EXPORTED_SYMBOLS
=
[
"
RemoteWebNavigation
"
]
;
