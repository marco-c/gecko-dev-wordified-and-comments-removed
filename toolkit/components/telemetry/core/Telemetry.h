#
ifndef
Telemetry_h__
#
define
Telemetry_h__
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
TelemetryEventEnums
.
h
"
#
include
"
mozilla
/
TelemetryHistogramEnums
.
h
"
#
include
"
mozilla
/
TelemetryOriginEnums
.
h
"
#
include
"
mozilla
/
TelemetryScalarEnums
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsXULAppAPI
.
h
"
namespace
mozilla
{
namespace
Telemetry
{
struct
HistogramAccumulation
;
struct
KeyedHistogramAccumulation
;
struct
ScalarAction
;
struct
KeyedScalarAction
;
struct
ChildEventData
;
struct
EventExtraEntry
;
void
Init
(
)
;
void
ShutdownTelemetry
(
)
;
void
Accumulate
(
HistogramID
id
uint32_t
sample
)
;
void
Accumulate
(
HistogramID
id
const
nsTArray
<
uint32_t
>
&
samples
)
;
void
Accumulate
(
HistogramID
id
const
nsCString
&
key
uint32_t
sample
=
1
)
;
void
Accumulate
(
HistogramID
id
const
nsCString
&
key
const
nsTArray
<
uint32_t
>
&
samples
)
;
void
Accumulate
(
const
char
*
name
uint32_t
sample
)
;
void
Accumulate
(
const
char
*
name
const
nsCString
&
key
uint32_t
sample
=
1
)
;
template
<
class
E
>
void
AccumulateCategorical
(
E
enumValue
)
{
static_assert
(
IsCategoricalLabelEnum
<
E
>
:
:
value
"
Only
categorical
label
enum
types
are
supported
.
"
)
;
Accumulate
(
static_cast
<
HistogramID
>
(
CategoricalLabelId
<
E
>
:
:
value
)
static_cast
<
uint32_t
>
(
enumValue
)
)
;
}
;
template
<
class
E
>
void
AccumulateCategorical
(
const
nsTArray
<
E
>
&
enumValues
)
{
static_assert
(
IsCategoricalLabelEnum
<
E
>
:
:
value
"
Only
categorical
label
enum
types
are
supported
.
"
)
;
nsTArray
<
uint32_t
>
intSamples
(
enumValues
.
Length
(
)
)
;
for
(
E
aValue
:
enumValues
)
{
intSamples
.
AppendElement
(
static_cast
<
uint32_t
>
(
aValue
)
)
;
}
HistogramID
categoricalId
=
static_cast
<
HistogramID
>
(
CategoricalLabelId
<
E
>
:
:
value
)
;
Accumulate
(
categoricalId
intSamples
)
;
}
template
<
class
E
>
void
AccumulateCategoricalKeyed
(
const
nsCString
&
key
E
enumValue
)
{
static_assert
(
IsCategoricalLabelEnum
<
E
>
:
:
value
"
Only
categorical
label
enum
types
are
supported
.
"
)
;
Accumulate
(
static_cast
<
HistogramID
>
(
CategoricalLabelId
<
E
>
:
:
value
)
key
static_cast
<
uint32_t
>
(
enumValue
)
)
;
}
;
template
<
class
E
>
void
AccumulateCategoricalKeyed
(
const
nsCString
&
key
const
nsTArray
<
E
>
&
enumValues
)
{
static_assert
(
IsCategoricalLabelEnum
<
E
>
:
:
value
"
Only
categorical
label
enum
types
are
supported
.
"
)
;
nsTArray
<
uint32_t
>
intSamples
(
enumValues
.
Length
(
)
)
;
for
(
E
aValue
:
enumValues
)
{
intSamples
.
AppendElement
(
static_cast
<
uint32_t
>
(
aValue
)
)
;
}
Accumulate
(
static_cast
<
HistogramID
>
(
CategoricalLabelId
<
E
>
:
:
value
)
key
intSamples
)
;
}
;
void
AccumulateCategorical
(
HistogramID
id
const
nsCString
&
label
)
;
void
AccumulateCategorical
(
HistogramID
id
const
nsTArray
<
nsCString
>
&
labels
)
;
void
AccumulateTimeDelta
(
HistogramID
id
TimeStamp
start
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
)
;
void
AccumulateTimeDelta
(
HistogramID
id
const
nsCString
&
key
TimeStamp
start
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
)
;
void
SetHistogramRecordingEnabled
(
HistogramID
id
bool
enabled
)
;
const
char
*
GetHistogramName
(
HistogramID
id
)
;
class
MOZ_RAII
RuntimeAutoTimer
{
public
:
explicit
RuntimeAutoTimer
(
Telemetry
:
:
HistogramID
aId
TimeStamp
aStart
=
TimeStamp
:
:
Now
(
)
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
id
(
aId
)
start
(
aStart
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
explicit
RuntimeAutoTimer
(
Telemetry
:
:
HistogramID
aId
const
nsCString
&
aKey
TimeStamp
aStart
=
TimeStamp
:
:
Now
(
)
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
id
(
aId
)
key
(
aKey
)
start
(
aStart
)
{
MOZ_ASSERT
(
!
aKey
.
IsEmpty
(
)
"
The
key
must
not
be
empty
.
"
)
;
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
RuntimeAutoTimer
(
)
{
if
(
key
.
IsEmpty
(
)
)
{
AccumulateTimeDelta
(
id
start
)
;
}
else
{
AccumulateTimeDelta
(
id
key
start
)
;
}
}
private
:
Telemetry
:
:
HistogramID
id
;
const
nsCString
key
;
const
TimeStamp
start
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
template
<
HistogramID
id
>
class
MOZ_RAII
AutoTimer
{
public
:
explicit
AutoTimer
(
TimeStamp
aStart
=
TimeStamp
:
:
Now
(
)
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
start
(
aStart
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
explicit
AutoTimer
(
const
nsCString
&
aKey
TimeStamp
aStart
=
TimeStamp
:
:
Now
(
)
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
start
(
aStart
)
key
(
aKey
)
{
MOZ_ASSERT
(
!
aKey
.
IsEmpty
(
)
"
The
key
must
not
be
empty
.
"
)
;
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoTimer
(
)
{
if
(
key
.
IsEmpty
(
)
)
{
AccumulateTimeDelta
(
id
start
)
;
}
else
{
AccumulateTimeDelta
(
id
key
start
)
;
}
}
private
:
const
TimeStamp
start
;
const
nsCString
key
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
RuntimeAutoCounter
{
public
:
explicit
RuntimeAutoCounter
(
HistogramID
aId
uint32_t
counterStart
=
0
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
id
(
aId
)
counter
(
counterStart
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
RuntimeAutoCounter
(
)
{
Accumulate
(
id
counter
)
;
}
void
operator
+
+
(
)
{
if
(
NS_WARN_IF
(
counter
=
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
)
{
return
;
}
+
+
counter
;
}
void
operator
+
=
(
int
increment
)
{
if
(
NS_WARN_IF
(
increment
>
0
&
&
static_cast
<
uint32_t
>
(
increment
)
>
(
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
-
counter
)
)
)
{
counter
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
return
;
}
if
(
NS_WARN_IF
(
increment
<
0
&
&
static_cast
<
uint32_t
>
(
-
increment
)
>
counter
)
)
{
counter
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
min
(
)
;
return
;
}
counter
+
=
increment
;
}
private
:
HistogramID
id
;
uint32_t
counter
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
template
<
HistogramID
id
>
class
MOZ_RAII
AutoCounter
{
public
:
explicit
AutoCounter
(
uint32_t
counterStart
=
0
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
counter
(
counterStart
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoCounter
(
)
{
Accumulate
(
id
counter
)
;
}
void
operator
+
+
(
)
{
if
(
NS_WARN_IF
(
counter
=
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
)
{
return
;
}
+
+
counter
;
}
void
operator
+
=
(
int
increment
)
{
if
(
NS_WARN_IF
(
increment
>
0
&
&
static_cast
<
uint32_t
>
(
increment
)
>
(
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
-
counter
)
)
)
{
counter
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
return
;
}
if
(
NS_WARN_IF
(
increment
<
0
&
&
static_cast
<
uint32_t
>
(
-
increment
)
>
counter
)
)
{
counter
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
min
(
)
;
return
;
}
counter
+
=
increment
;
}
private
:
uint32_t
counter
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
bool
CanRecordBase
(
)
;
bool
CanRecordExtended
(
)
;
bool
CanRecordReleaseData
(
)
;
bool
CanRecordPrereleaseData
(
)
;
void
RecordSlowSQLStatement
(
const
nsACString
&
statement
const
nsACString
&
dbName
uint32_t
delay
)
;
void
InitIOReporting
(
nsIFile
*
aXreDir
)
;
void
SetProfileDir
(
nsIFile
*
aProfD
)
;
void
LeavingStartupStage
(
)
;
void
EnteringShutdownStage
(
)
;
const
uint32_t
kSlowSQLThresholdForMainThread
=
50
;
const
uint32_t
kSlowSQLThresholdForHelperThreads
=
100
;
class
ProcessedStack
;
#
if
defined
(
MOZ_GECKO_PROFILER
)
void
CaptureStack
(
const
nsCString
&
aKey
)
;
#
endif
void
WriteFailedProfileLock
(
nsIFile
*
aProfileDir
)
;
void
ScalarAdd
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
;
void
ScalarSet
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
;
void
ScalarSet
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
bool
aValue
)
;
void
ScalarSet
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aValue
)
;
void
ScalarSetMaximum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
;
void
ScalarAdd
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
;
void
ScalarSet
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
;
void
ScalarSet
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
bool
aValue
)
;
void
ScalarSetMaximum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
;
template
<
ScalarID
id
>
class
MOZ_RAII
AutoScalarTimer
{
public
:
explicit
AutoScalarTimer
(
TimeStamp
aStart
=
TimeStamp
:
:
Now
(
)
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
start
(
aStart
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
explicit
AutoScalarTimer
(
const
nsAString
&
aKey
TimeStamp
aStart
=
TimeStamp
:
:
Now
(
)
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
start
(
aStart
)
key
(
aKey
)
{
MOZ_ASSERT
(
!
aKey
.
IsEmpty
(
)
"
The
key
must
not
be
empty
.
"
)
;
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoScalarTimer
(
)
{
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
;
uint32_t
delta
=
static_cast
<
uint32_t
>
(
(
end
-
start
)
.
ToMilliseconds
(
)
)
;
if
(
key
.
IsEmpty
(
)
)
{
mozilla
:
:
Telemetry
:
:
ScalarSet
(
id
delta
)
;
}
else
{
mozilla
:
:
Telemetry
:
:
ScalarSet
(
id
key
delta
)
;
}
}
private
:
const
TimeStamp
start
;
const
nsString
key
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
void
RecordEvent
(
mozilla
:
:
Telemetry
:
:
EventID
aId
const
mozilla
:
:
Maybe
<
nsCString
>
&
aValue
const
mozilla
:
:
Maybe
<
nsTArray
<
EventExtraEntry
>
>
&
aExtra
)
;
void
SetEventRecordingEnabled
(
const
nsACString
&
aCategory
bool
aEnabled
)
;
void
RecordOrigin
(
mozilla
:
:
Telemetry
:
:
OriginMetricID
aId
const
nsACString
&
aOrigin
)
;
}
}
#
endif
