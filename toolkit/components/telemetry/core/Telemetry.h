#
ifndef
Telemetry_h__
#
define
Telemetry_h__
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TelemetryEventEnums
.
h
"
#
include
"
mozilla
/
TelemetryHistogramEnums
.
h
"
#
include
"
mozilla
/
TelemetryScalarEnums
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsXULAppAPI
.
h
"
namespace
mozilla
{
namespace
Telemetry
{
struct
HistogramAccumulation
;
struct
KeyedHistogramAccumulation
;
struct
ScalarAction
;
struct
KeyedScalarAction
;
struct
ChildEventData
;
struct
EventExtraEntry
{
nsCString
key
;
nsCString
value
;
}
;
void
Init
(
)
;
void
ShutdownTelemetry
(
)
;
void
Accumulate
(
HistogramID
id
uint32_t
sample
)
;
void
Accumulate
(
HistogramID
id
const
nsTArray
<
uint32_t
>
&
samples
)
;
void
Accumulate
(
HistogramID
id
const
nsCString
&
key
uint32_t
sample
=
1
)
;
void
Accumulate
(
HistogramID
id
const
nsCString
&
key
const
nsTArray
<
uint32_t
>
&
samples
)
;
void
Accumulate
(
const
char
*
name
uint32_t
sample
)
;
void
Accumulate
(
const
char
*
name
const
nsCString
&
key
uint32_t
sample
=
1
)
;
template
<
class
E
>
void
AccumulateCategorical
(
E
enumValue
)
{
static_assert
(
IsCategoricalLabelEnum
<
E
>
:
:
value
"
Only
categorical
label
enum
types
are
supported
.
"
)
;
Accumulate
(
static_cast
<
HistogramID
>
(
CategoricalLabelId
<
E
>
:
:
value
)
static_cast
<
uint32_t
>
(
enumValue
)
)
;
}
;
template
<
class
E
>
void
AccumulateCategoricalKeyed
(
const
nsCString
&
key
E
enumValue
)
{
static_assert
(
IsCategoricalLabelEnum
<
E
>
:
:
value
"
Only
categorical
label
enum
types
are
supported
.
"
)
;
Accumulate
(
static_cast
<
HistogramID
>
(
CategoricalLabelId
<
E
>
:
:
value
)
key
static_cast
<
uint32_t
>
(
enumValue
)
)
;
}
;
void
AccumulateCategorical
(
HistogramID
id
const
nsCString
&
label
)
;
void
AccumulateCategorical
(
HistogramID
id
const
nsTArray
<
nsCString
>
&
labels
)
;
void
AccumulateTimeDelta
(
HistogramID
id
TimeStamp
start
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
)
;
void
AccumulateTimeDelta
(
HistogramID
id
const
nsCString
&
key
TimeStamp
start
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
)
;
const
char
*
GetHistogramName
(
HistogramID
id
)
;
template
<
HistogramID
id
>
class
MOZ_RAII
AutoTimer
{
public
:
explicit
AutoTimer
(
TimeStamp
aStart
=
TimeStamp
:
:
Now
(
)
)
:
start
(
aStart
)
{
}
explicit
AutoTimer
(
const
nsCString
&
aKey
TimeStamp
aStart
=
TimeStamp
:
:
Now
(
)
)
:
start
(
aStart
)
key
(
aKey
)
{
MOZ_ASSERT
(
!
aKey
.
IsEmpty
(
)
"
The
key
must
not
be
empty
.
"
)
;
}
~
AutoTimer
(
)
{
if
(
key
.
IsEmpty
(
)
)
{
AccumulateTimeDelta
(
id
start
)
;
}
else
{
AccumulateTimeDelta
(
id
key
start
)
;
}
}
private
:
const
TimeStamp
start
;
const
nsCString
key
;
}
;
bool
CanRecordBase
(
)
;
bool
CanRecordExtended
(
)
;
bool
CanRecordReleaseData
(
)
;
bool
CanRecordPrereleaseData
(
)
;
void
RecordSlowSQLStatement
(
const
nsACString
&
statement
const
nsACString
&
dbName
uint32_t
delay
)
;
void
InitIOReporting
(
nsIFile
*
aXreDir
)
;
void
SetProfileDir
(
nsIFile
*
aProfD
)
;
void
LeavingStartupStage
(
)
;
void
EnteringShutdownStage
(
)
;
const
uint32_t
kSlowSQLThresholdForMainThread
=
50
;
const
uint32_t
kSlowSQLThresholdForHelperThreads
=
100
;
void
WriteFailedProfileLock
(
nsIFile
*
aProfileDir
)
;
}
}
#
endif
