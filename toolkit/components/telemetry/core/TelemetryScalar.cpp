#
include
"
TelemetryScalar
.
h
"
#
include
"
geckoview
/
streaming
/
GeckoViewStreamingTelemetry
.
h
"
#
include
"
ipc
/
TelemetryIPCAccumulator
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
JSONWriter
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TelemetryComms
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsITelemetry
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
TelemetryScalarData
.
h
"
using
mozilla
:
:
MakeUnique
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Preferences
;
using
mozilla
:
:
Some
;
using
mozilla
:
:
StaticAutoPtr
;
using
mozilla
:
:
StaticMutex
;
using
mozilla
:
:
StaticMutexAutoLock
;
using
mozilla
:
:
UniquePtr
;
using
mozilla
:
:
Telemetry
:
:
DynamicScalarDefinition
;
using
mozilla
:
:
Telemetry
:
:
KeyedScalarAction
;
using
mozilla
:
:
Telemetry
:
:
ProcessID
;
using
mozilla
:
:
Telemetry
:
:
ScalarAction
;
using
mozilla
:
:
Telemetry
:
:
ScalarActionType
;
using
mozilla
:
:
Telemetry
:
:
ScalarID
;
using
mozilla
:
:
Telemetry
:
:
ScalarVariant
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
AutoHashtable
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
CanRecordDataset
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
CanRecordProduct
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
GetCurrentProduct
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
GetIDForProcessName
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
GetNameForProcessID
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsExpiredVersion
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsInDataset
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsValidIdentifierString
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
LogToBrowserConsole
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
RecordedProcessType
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
StringHashSet
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
SupportedProduct
;
namespace
TelemetryIPCAccumulator
=
mozilla
:
:
TelemetryIPCAccumulator
;
namespace
{
const
uint32_t
kMaximumNumberOfKeys
=
100
;
const
uint32_t
kMaxEventSummaryKeys
=
500
;
const
uint32_t
kMaximumKeyStringLength
=
72
;
const
uint32_t
kMaximumStringValueLength
=
50
;
const
uint32_t
kMaximumCategoryNameLength
=
40
;
const
uint32_t
kMaximumScalarNameLength
=
40
;
const
uint32_t
kScalarCount
=
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
ScalarCount
)
;
const
size_t
kScalarActionsArrayHighWaterMark
=
10000
;
const
char
*
TEST_SCALAR_PREFIX
=
"
telemetry
.
test
.
"
;
const
uint32_t
kMaxStaticStoreOffset
=
UINT16_MAX
;
enum
class
ScalarResult
:
uint8_t
{
Ok
NotInitialized
CannotUnpackVariant
CannotRecordInProcess
CannotRecordDataset
KeyedTypeMismatch
UnknownScalar
OperationNotSupported
InvalidType
InvalidValue
KeyIsEmpty
KeyTooLong
TooManyKeys
KeyNotAllowed
StringTooLong
UnsignedNegativeValue
UnsignedTruncatedValue
}
;
struct
ScalarKey
{
uint32_t
id
;
bool
dynamic
;
}
;
StaticAutoPtr
<
nsTArray
<
RefPtr
<
nsAtom
>
>
>
gDynamicStoreNames
;
struct
DynamicScalarInfo
:
BaseScalarInfo
{
nsCString
mDynamicName
;
bool
mDynamicExpiration
;
uint32_t
store_count
;
uint32_t
store_offset
;
DynamicScalarInfo
(
uint32_t
aKind
bool
aRecordOnRelease
bool
aExpired
const
nsACString
&
aName
bool
aKeyed
bool
aBuiltin
const
nsTArray
<
nsCString
>
&
aStores
)
:
BaseScalarInfo
(
aKind
aRecordOnRelease
?
nsITelemetry
:
:
DATASET_ALL_CHANNELS
:
nsITelemetry
:
:
DATASET_PRERELEASE_CHANNELS
RecordedProcessType
:
:
All
aKeyed
0
0
GetCurrentProduct
(
)
aBuiltin
)
mDynamicName
(
aName
)
mDynamicExpiration
(
aExpired
)
{
store_count
=
aStores
.
Length
(
)
;
if
(
store_count
=
=
0
)
{
store_count
=
1
;
store_offset
=
kMaxStaticStoreOffset
;
}
else
{
store_offset
=
kMaxStaticStoreOffset
+
1
+
gDynamicStoreNames
-
>
Length
(
)
;
for
(
const
auto
&
storeName
:
aStores
)
{
gDynamicStoreNames
-
>
AppendElement
(
NS_Atomize
(
storeName
)
)
;
}
MOZ_ASSERT
(
gDynamicStoreNames
-
>
Length
(
)
<
UINT32_MAX
-
kMaxStaticStoreOffset
-
1
"
Too
many
dynamic
scalar
store
names
.
Overflow
.
"
)
;
}
}
;
const
char
*
name
(
)
const
override
;
const
char
*
expiration
(
)
const
override
;
uint32_t
storeCount
(
)
const
override
;
uint32_t
storeOffset
(
)
const
override
;
}
;
const
char
*
DynamicScalarInfo
:
:
name
(
)
const
{
return
mDynamicName
.
get
(
)
;
}
const
char
*
DynamicScalarInfo
:
:
expiration
(
)
const
{
return
mDynamicExpiration
?
"
1
.
0
"
:
"
never
"
;
}
uint32_t
DynamicScalarInfo
:
:
storeOffset
(
)
const
{
return
store_offset
;
}
uint32_t
DynamicScalarInfo
:
:
storeCount
(
)
const
{
return
store_count
;
}
typedef
nsBaseHashtableET
<
nsDepCharHashKey
ScalarKey
>
CharPtrEntryType
;
typedef
AutoHashtable
<
CharPtrEntryType
>
ScalarMapType
;
StaticAutoPtr
<
nsTArray
<
DynamicScalarInfo
>
>
gDynamicScalarInfo
;
const
BaseScalarInfo
&
internal_GetScalarInfo
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
)
{
if
(
!
aId
.
dynamic
)
{
return
gScalars
[
aId
.
id
]
;
}
return
(
*
gDynamicScalarInfo
)
[
aId
.
id
]
;
}
bool
IsValidEnumId
(
mozilla
:
:
Telemetry
:
:
ScalarID
aID
)
{
return
aID
<
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
ScalarCount
;
}
bool
internal_IsValidId
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
)
{
return
aId
.
dynamic
?
(
aId
.
id
<
gDynamicScalarInfo
-
>
Length
(
)
)
:
IsValidEnumId
(
static_cast
<
mozilla
:
:
Telemetry
:
:
ScalarID
>
(
aId
.
id
)
)
;
}
ScalarResult
GetVariantFromIVariant
(
nsIVariant
*
aInput
uint32_t
aScalarKind
mozilla
:
:
Maybe
<
ScalarVariant
>
&
aOutput
)
{
switch
(
aScalarKind
)
{
case
nsITelemetry
:
:
SCALAR_TYPE_COUNT
:
{
uint32_t
val
=
0
;
nsresult
rv
=
aInput
-
>
GetAsUint32
(
&
val
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
CannotUnpackVariant
;
}
aOutput
=
mozilla
:
:
Some
(
mozilla
:
:
AsVariant
(
val
)
)
;
break
;
}
case
nsITelemetry
:
:
SCALAR_TYPE_STRING
:
{
nsString
val
;
nsresult
rv
=
aInput
-
>
GetAsAString
(
val
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
CannotUnpackVariant
;
}
aOutput
=
mozilla
:
:
Some
(
mozilla
:
:
AsVariant
(
val
)
)
;
break
;
}
case
nsITelemetry
:
:
SCALAR_TYPE_BOOLEAN
:
{
bool
val
=
false
;
nsresult
rv
=
aInput
-
>
GetAsBool
(
&
val
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
CannotUnpackVariant
;
}
aOutput
=
mozilla
:
:
Some
(
mozilla
:
:
AsVariant
(
val
)
)
;
break
;
}
default
:
MOZ_ASSERT
(
false
"
Unknown
scalar
kind
.
"
)
;
return
ScalarResult
:
:
UnknownScalar
;
}
return
ScalarResult
:
:
Ok
;
}
nsresult
WriteVariantToJSONWriter
(
uint32_t
aScalarType
nsIVariant
*
aInputValue
const
mozilla
:
:
Span
<
const
char
>
&
aPropertyName
mozilla
:
:
JSONWriter
&
aWriter
)
{
MOZ_ASSERT
(
aInputValue
)
;
switch
(
aScalarType
)
{
case
nsITelemetry
:
:
SCALAR_TYPE_COUNT
:
{
uint32_t
val
=
0
;
nsresult
rv
=
aInputValue
-
>
GetAsUint32
(
&
val
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aWriter
.
IntProperty
(
aPropertyName
val
)
;
break
;
}
case
nsITelemetry
:
:
SCALAR_TYPE_STRING
:
{
nsCString
val
;
nsresult
rv
=
aInputValue
-
>
GetAsACString
(
val
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aWriter
.
StringProperty
(
aPropertyName
val
)
;
break
;
}
case
nsITelemetry
:
:
SCALAR_TYPE_BOOLEAN
:
{
bool
val
=
false
;
nsresult
rv
=
aInputValue
-
>
GetAsBool
(
&
val
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aWriter
.
BoolProperty
(
aPropertyName
val
)
;
break
;
}
default
:
MOZ_ASSERT
(
false
"
Unknown
scalar
kind
.
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
const
char
*
ScalarInfo
:
:
name
(
)
const
{
return
&
gScalarsStringTable
[
this
-
>
name_offset
]
;
}
const
char
*
ScalarInfo
:
:
expiration
(
)
const
{
return
&
gScalarsStringTable
[
this
-
>
expiration_offset
]
;
}
class
ScalarBase
{
public
:
explicit
ScalarBase
(
const
BaseScalarInfo
&
aInfo
)
:
mStoreCount
(
aInfo
.
storeCount
(
)
)
mStoreOffset
(
aInfo
.
storeOffset
(
)
)
mStoreHasValue
(
mStoreCount
)
mName
(
aInfo
.
name
(
)
)
{
mStoreHasValue
.
SetLength
(
mStoreCount
)
;
for
(
auto
&
val
:
mStoreHasValue
)
{
val
=
false
;
}
}
;
virtual
~
ScalarBase
(
)
=
default
;
virtual
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
=
0
;
virtual
ScalarResult
AddValue
(
nsIVariant
*
aValue
)
{
return
ScalarResult
:
:
OperationNotSupported
;
}
virtual
ScalarResult
SetMaximum
(
nsIVariant
*
aValue
)
{
return
ScalarResult
:
:
OperationNotSupported
;
}
virtual
void
SetValue
(
uint32_t
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
ScalarResult
SetValue
(
const
nsAString
&
aValue
)
{
return
HandleUnsupported
(
)
;
}
virtual
void
SetValue
(
bool
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
void
AddValue
(
uint32_t
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
void
SetMaximum
(
uint32_t
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
nsresult
GetValue
(
const
nsACString
&
aStoreName
bool
aClearStore
nsCOMPtr
<
nsIVariant
>
&
aResult
)
=
0
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
virtual
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
=
0
;
protected
:
bool
HasValueInStore
(
size_t
aStoreIndex
)
const
;
void
ClearValueInStore
(
size_t
aStoreIndex
)
;
void
SetValueInStores
(
)
;
nsresult
StoreIndex
(
const
nsACString
&
aStoreName
size_t
*
aStoreIndex
)
const
;
private
:
ScalarResult
HandleUnsupported
(
)
const
;
const
uint32_t
mStoreCount
;
const
uint32_t
mStoreOffset
;
nsTArray
<
bool
>
mStoreHasValue
;
protected
:
const
nsCString
mName
;
}
;
ScalarResult
ScalarBase
:
:
HandleUnsupported
(
)
const
{
MOZ_ASSERT
(
false
"
This
operation
is
not
support
for
this
scalar
type
.
"
)
;
return
ScalarResult
:
:
OperationNotSupported
;
}
bool
ScalarBase
:
:
HasValueInStore
(
size_t
aStoreIndex
)
const
{
MOZ_ASSERT
(
aStoreIndex
<
mStoreHasValue
.
Length
(
)
"
Invalid
scalar
store
index
.
"
)
;
return
mStoreHasValue
[
aStoreIndex
]
;
}
void
ScalarBase
:
:
ClearValueInStore
(
size_t
aStoreIndex
)
{
MOZ_ASSERT
(
aStoreIndex
<
mStoreHasValue
.
Length
(
)
"
Invalid
scalar
store
index
to
clear
.
"
)
;
mStoreHasValue
[
aStoreIndex
]
=
false
;
}
void
ScalarBase
:
:
SetValueInStores
(
)
{
for
(
auto
&
val
:
mStoreHasValue
)
{
val
=
true
;
}
}
nsresult
ScalarBase
:
:
StoreIndex
(
const
nsACString
&
aStoreName
size_t
*
aStoreIndex
)
const
{
if
(
mStoreCount
=
=
1
&
&
mStoreOffset
=
=
kMaxStaticStoreOffset
)
{
if
(
aStoreName
.
EqualsLiteral
(
"
main
"
)
)
{
*
aStoreIndex
=
0
;
return
NS_OK
;
}
return
NS_ERROR_NO_CONTENT
;
}
if
(
mStoreOffset
>
kMaxStaticStoreOffset
)
{
auto
dynamicOffset
=
mStoreOffset
-
kMaxStaticStoreOffset
-
1
;
for
(
uint32_t
i
=
0
;
i
<
mStoreCount
;
+
+
i
)
{
auto
scalarStore
=
(
*
gDynamicStoreNames
)
[
dynamicOffset
+
i
]
;
if
(
nsAtomCString
(
scalarStore
)
.
Equals
(
aStoreName
)
)
{
*
aStoreIndex
=
i
;
return
NS_OK
;
}
}
return
NS_ERROR_NO_CONTENT
;
}
for
(
uint32_t
i
=
0
;
i
<
mStoreCount
;
+
+
i
)
{
uint32_t
stringIndex
=
gScalarStoresTable
[
mStoreOffset
+
i
]
;
if
(
aStoreName
.
EqualsASCII
(
&
gScalarsStringTable
[
stringIndex
]
)
)
{
*
aStoreIndex
=
i
;
return
NS_OK
;
}
}
return
NS_ERROR_NO_CONTENT
;
}
size_t
ScalarBase
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
mStoreHasValue
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
class
ScalarUnsigned
:
public
ScalarBase
{
public
:
using
ScalarBase
:
:
SetValue
;
explicit
ScalarUnsigned
(
const
BaseScalarInfo
&
aInfo
)
:
ScalarBase
(
aInfo
)
mStorage
(
aInfo
.
storeCount
(
)
)
{
mStorage
.
SetLength
(
aInfo
.
storeCount
(
)
)
;
for
(
auto
&
val
:
mStorage
)
{
val
=
0
;
}
}
;
~
ScalarUnsigned
(
)
override
=
default
;
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
final
;
void
SetValue
(
uint32_t
aValue
)
final
;
ScalarResult
AddValue
(
nsIVariant
*
aValue
)
final
;
void
AddValue
(
uint32_t
aValue
)
final
;
ScalarResult
SetMaximum
(
nsIVariant
*
aValue
)
final
;
void
SetMaximum
(
uint32_t
aValue
)
final
;
nsresult
GetValue
(
const
nsACString
&
aStoreName
bool
aClearStore
nsCOMPtr
<
nsIVariant
>
&
aResult
)
final
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
final
;
private
:
nsTArray
<
uint32_t
>
mStorage
;
ScalarResult
CheckInput
(
nsIVariant
*
aValue
)
;
ScalarUnsigned
(
const
ScalarUnsigned
&
aOther
)
=
delete
;
void
operator
=
(
const
ScalarUnsigned
&
aOther
)
=
delete
;
}
;
ScalarResult
ScalarUnsigned
:
:
SetValue
(
nsIVariant
*
aValue
)
{
ScalarResult
sr
=
CheckInput
(
aValue
)
;
if
(
sr
=
=
ScalarResult
:
:
UnsignedNegativeValue
)
{
return
sr
;
}
uint32_t
value
=
0
;
if
(
NS_FAILED
(
aValue
-
>
GetAsUint32
(
&
value
)
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
SetValue
(
value
)
;
return
sr
;
}
void
ScalarUnsigned
:
:
SetValue
(
uint32_t
aValue
)
{
if
(
GetCurrentProduct
(
)
=
=
SupportedProduct
:
:
GeckoviewStreaming
)
{
GeckoViewStreamingTelemetry
:
:
UintScalarSet
(
mName
aValue
)
;
return
;
}
for
(
auto
&
val
:
mStorage
)
{
val
=
aValue
;
}
SetValueInStores
(
)
;
}
ScalarResult
ScalarUnsigned
:
:
AddValue
(
nsIVariant
*
aValue
)
{
ScalarResult
sr
=
CheckInput
(
aValue
)
;
if
(
sr
=
=
ScalarResult
:
:
UnsignedNegativeValue
)
{
return
sr
;
}
uint32_t
newAddend
=
0
;
nsresult
rv
=
aValue
-
>
GetAsUint32
(
&
newAddend
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
AddValue
(
newAddend
)
;
return
sr
;
}
void
ScalarUnsigned
:
:
AddValue
(
uint32_t
aValue
)
{
MOZ_ASSERT
(
GetCurrentProduct
(
)
!
=
SupportedProduct
:
:
GeckoviewStreaming
)
;
for
(
auto
&
val
:
mStorage
)
{
val
+
=
aValue
;
}
SetValueInStores
(
)
;
}
ScalarResult
ScalarUnsigned
:
:
SetMaximum
(
nsIVariant
*
aValue
)
{
MOZ_ASSERT
(
GetCurrentProduct
(
)
!
=
SupportedProduct
:
:
GeckoviewStreaming
)
;
ScalarResult
sr
=
CheckInput
(
aValue
)
;
if
(
sr
=
=
ScalarResult
:
:
UnsignedNegativeValue
)
{
return
sr
;
}
uint32_t
newValue
=
0
;
nsresult
rv
=
aValue
-
>
GetAsUint32
(
&
newValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
SetMaximum
(
newValue
)
;
return
sr
;
}
void
ScalarUnsigned
:
:
SetMaximum
(
uint32_t
aValue
)
{
for
(
auto
&
val
:
mStorage
)
{
if
(
aValue
>
val
)
{
val
=
aValue
;
}
}
SetValueInStores
(
)
;
}
nsresult
ScalarUnsigned
:
:
GetValue
(
const
nsACString
&
aStoreName
bool
aClearStore
nsCOMPtr
<
nsIVariant
>
&
aResult
)
{
size_t
storeIndex
=
0
;
nsresult
rv
=
StoreIndex
(
aStoreName
&
storeIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
HasValueInStore
(
storeIndex
)
)
{
return
NS_ERROR_NO_CONTENT
;
}
nsCOMPtr
<
nsIWritableVariant
>
outVar
(
new
nsVariant
(
)
)
;
rv
=
outVar
-
>
SetAsUint32
(
mStorage
[
storeIndex
]
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aResult
=
std
:
:
move
(
outVar
)
;
if
(
aClearStore
)
{
mStorage
[
storeIndex
]
=
0
;
ClearValueInStore
(
storeIndex
)
;
}
return
NS_OK
;
}
size_t
ScalarUnsigned
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
ScalarBase
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
n
+
=
mStorage
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
n
;
}
ScalarResult
ScalarUnsigned
:
:
CheckInput
(
nsIVariant
*
aValue
)
{
uint16_t
type
=
aValue
-
>
GetDataType
(
)
;
if
(
type
=
=
nsIDataType
:
:
VTYPE_FLOAT
|
|
type
=
=
nsIDataType
:
:
VTYPE_DOUBLE
)
{
return
ScalarResult
:
:
UnsignedTruncatedValue
;
}
int32_t
signedTest
;
if
(
NS_SUCCEEDED
(
aValue
-
>
GetAsInt32
(
&
signedTest
)
)
&
&
signedTest
<
0
)
{
return
ScalarResult
:
:
UnsignedNegativeValue
;
}
return
ScalarResult
:
:
Ok
;
}
class
ScalarString
:
public
ScalarBase
{
public
:
using
ScalarBase
:
:
SetValue
;
explicit
ScalarString
(
const
BaseScalarInfo
&
aInfo
)
:
ScalarBase
(
aInfo
)
mStorage
(
aInfo
.
storeCount
(
)
)
{
mStorage
.
SetLength
(
aInfo
.
storeCount
(
)
)
;
}
;
~
ScalarString
(
)
override
=
default
;
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
final
;
ScalarResult
SetValue
(
const
nsAString
&
aValue
)
final
;
nsresult
GetValue
(
const
nsACString
&
aStoreName
bool
aClearStore
nsCOMPtr
<
nsIVariant
>
&
aResult
)
final
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
final
;
private
:
nsTArray
<
nsString
>
mStorage
;
ScalarString
(
const
ScalarString
&
aOther
)
=
delete
;
void
operator
=
(
const
ScalarString
&
aOther
)
=
delete
;
}
;
ScalarResult
ScalarString
:
:
SetValue
(
nsIVariant
*
aValue
)
{
uint16_t
type
=
aValue
-
>
GetDataType
(
)
;
if
(
type
!
=
nsIDataType
:
:
VTYPE_CHAR
&
&
type
!
=
nsIDataType
:
:
VTYPE_WCHAR
&
&
type
!
=
nsIDataType
:
:
VTYPE_CHAR_STR
&
&
type
!
=
nsIDataType
:
:
VTYPE_WCHAR_STR
&
&
type
!
=
nsIDataType
:
:
VTYPE_STRING_SIZE_IS
&
&
type
!
=
nsIDataType
:
:
VTYPE_WSTRING_SIZE_IS
&
&
type
!
=
nsIDataType
:
:
VTYPE_UTF8STRING
&
&
type
!
=
nsIDataType
:
:
VTYPE_CSTRING
&
&
type
!
=
nsIDataType
:
:
VTYPE_ASTRING
)
{
return
ScalarResult
:
:
InvalidType
;
}
nsAutoString
convertedString
;
nsresult
rv
=
aValue
-
>
GetAsAString
(
convertedString
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
return
SetValue
(
convertedString
)
;
}
;
ScalarResult
ScalarString
:
:
SetValue
(
const
nsAString
&
aValue
)
{
auto
str
=
Substring
(
aValue
0
kMaximumStringValueLength
)
;
if
(
GetCurrentProduct
(
)
=
=
SupportedProduct
:
:
GeckoviewStreaming
)
{
GeckoViewStreamingTelemetry
:
:
StringScalarSet
(
mName
NS_ConvertUTF16toUTF8
(
str
)
)
;
return
aValue
.
Length
(
)
>
kMaximumStringValueLength
?
ScalarResult
:
:
StringTooLong
:
ScalarResult
:
:
Ok
;
}
for
(
auto
&
val
:
mStorage
)
{
val
.
Assign
(
str
)
;
}
SetValueInStores
(
)
;
if
(
aValue
.
Length
(
)
>
kMaximumStringValueLength
)
{
return
ScalarResult
:
:
StringTooLong
;
}
return
ScalarResult
:
:
Ok
;
}
nsresult
ScalarString
:
:
GetValue
(
const
nsACString
&
aStoreName
bool
aClearStore
nsCOMPtr
<
nsIVariant
>
&
aResult
)
{
nsCOMPtr
<
nsIWritableVariant
>
outVar
(
new
nsVariant
(
)
)
;
size_t
storeIndex
=
0
;
nsresult
rv
=
StoreIndex
(
aStoreName
&
storeIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
HasValueInStore
(
storeIndex
)
)
{
return
NS_ERROR_NO_CONTENT
;
}
rv
=
outVar
-
>
SetAsAString
(
mStorage
[
storeIndex
]
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aClearStore
)
{
ClearValueInStore
(
storeIndex
)
;
}
aResult
=
std
:
:
move
(
outVar
)
;
return
NS_OK
;
}
size_t
ScalarString
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
ScalarBase
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
n
+
=
mStorage
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
&
val
:
mStorage
)
{
n
+
=
val
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
return
n
;
}
class
ScalarBoolean
:
public
ScalarBase
{
public
:
using
ScalarBase
:
:
SetValue
;
explicit
ScalarBoolean
(
const
BaseScalarInfo
&
aInfo
)
:
ScalarBase
(
aInfo
)
mStorage
(
aInfo
.
storeCount
(
)
)
{
mStorage
.
SetLength
(
aInfo
.
storeCount
(
)
)
;
for
(
auto
&
val
:
mStorage
)
{
val
=
false
;
}
}
;
~
ScalarBoolean
(
)
override
=
default
;
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
final
;
void
SetValue
(
bool
aValue
)
final
;
nsresult
GetValue
(
const
nsACString
&
aStoreName
bool
aClearStore
nsCOMPtr
<
nsIVariant
>
&
aResult
)
final
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
final
;
private
:
nsTArray
<
bool
>
mStorage
;
ScalarBoolean
(
const
ScalarBoolean
&
aOther
)
=
delete
;
void
operator
=
(
const
ScalarBoolean
&
aOther
)
=
delete
;
}
;
ScalarResult
ScalarBoolean
:
:
SetValue
(
nsIVariant
*
aValue
)
{
uint16_t
type
=
aValue
-
>
GetDataType
(
)
;
if
(
type
!
=
nsIDataType
:
:
VTYPE_BOOL
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT8
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT16
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT32
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT64
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT8
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT16
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT32
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT64
)
{
return
ScalarResult
:
:
InvalidType
;
}
bool
value
=
false
;
if
(
NS_FAILED
(
aValue
-
>
GetAsBool
(
&
value
)
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
SetValue
(
value
)
;
return
ScalarResult
:
:
Ok
;
}
;
void
ScalarBoolean
:
:
SetValue
(
bool
aValue
)
{
if
(
GetCurrentProduct
(
)
=
=
SupportedProduct
:
:
GeckoviewStreaming
)
{
GeckoViewStreamingTelemetry
:
:
BoolScalarSet
(
mName
aValue
)
;
return
;
}
for
(
auto
&
val
:
mStorage
)
{
val
=
aValue
;
}
SetValueInStores
(
)
;
}
nsresult
ScalarBoolean
:
:
GetValue
(
const
nsACString
&
aStoreName
bool
aClearStore
nsCOMPtr
<
nsIVariant
>
&
aResult
)
{
nsCOMPtr
<
nsIWritableVariant
>
outVar
(
new
nsVariant
(
)
)
;
size_t
storeIndex
=
0
;
nsresult
rv
=
StoreIndex
(
aStoreName
&
storeIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
HasValueInStore
(
storeIndex
)
)
{
return
NS_ERROR_NO_CONTENT
;
}
if
(
aClearStore
)
{
ClearValueInStore
(
storeIndex
)
;
}
rv
=
outVar
-
>
SetAsBool
(
mStorage
[
storeIndex
]
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aResult
=
std
:
:
move
(
outVar
)
;
return
NS_OK
;
}
size_t
ScalarBoolean
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
ScalarBase
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
n
+
=
mStorage
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
n
;
}
ScalarBase
*
internal_ScalarAllocate
(
const
BaseScalarInfo
&
aInfo
)
{
ScalarBase
*
scalar
=
nullptr
;
switch
(
aInfo
.
kind
)
{
case
nsITelemetry
:
:
SCALAR_TYPE_COUNT
:
scalar
=
new
ScalarUnsigned
(
aInfo
)
;
break
;
case
nsITelemetry
:
:
SCALAR_TYPE_STRING
:
scalar
=
new
ScalarString
(
aInfo
)
;
break
;
case
nsITelemetry
:
:
SCALAR_TYPE_BOOLEAN
:
scalar
=
new
ScalarBoolean
(
aInfo
)
;
break
;
default
:
MOZ_ASSERT
(
false
"
Invalid
scalar
type
"
)
;
}
return
scalar
;
}
class
KeyedScalar
{
public
:
typedef
std
:
:
pair
<
nsCString
nsCOMPtr
<
nsIVariant
>
>
KeyValuePair
;
explicit
KeyedScalar
(
const
BaseScalarInfo
&
info
)
:
mScalarName
(
info
.
name
(
)
)
mScalarKeyCount
(
info
.
key_count
)
mScalarKeyOffset
(
info
.
key_offset
)
mMaximumNumberOfKeys
(
kMaximumNumberOfKeys
)
{
}
;
~
KeyedScalar
(
)
=
default
;
ScalarResult
SetValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
nsIVariant
*
aValue
)
;
ScalarResult
AddValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
nsIVariant
*
aValue
)
;
ScalarResult
SetMaximum
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
nsIVariant
*
aValue
)
;
void
SetValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
uint32_t
aValue
)
;
void
SetValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
bool
aValue
)
;
void
AddValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
uint32_t
aValue
)
;
void
SetMaximum
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
uint32_t
aValue
)
;
nsresult
GetValue
(
const
nsACString
&
aStoreName
bool
aClearStorage
nsTArray
<
KeyValuePair
>
&
aValues
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
;
void
SetMaximumNumberOfKeys
(
uint32_t
aMaximumNumberOfKeys
)
{
mMaximumNumberOfKeys
=
aMaximumNumberOfKeys
;
}
;
private
:
typedef
nsClassHashtable
<
nsCStringHashKey
ScalarBase
>
ScalarKeysMapType
;
const
nsCString
mScalarName
;
ScalarKeysMapType
mScalarKeys
;
uint32_t
mScalarKeyCount
;
uint32_t
mScalarKeyOffset
;
uint32_t
mMaximumNumberOfKeys
;
ScalarResult
GetScalarForKey
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
ScalarBase
*
*
aRet
)
;
bool
AllowsKey
(
const
nsAString
&
aKey
)
const
;
}
;
ScalarResult
KeyedScalar
:
:
SetValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
nsIVariant
*
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
return
sr
;
}
return
scalar
-
>
SetValue
(
aValue
)
;
}
ScalarResult
KeyedScalar
:
:
AddValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
nsIVariant
*
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
return
sr
;
}
return
scalar
-
>
AddValue
(
aValue
)
;
}
ScalarResult
KeyedScalar
:
:
SetMaximum
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
nsIVariant
*
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
return
sr
;
}
return
scalar
-
>
SetMaximum
(
aValue
)
;
}
void
KeyedScalar
:
:
SetValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
uint32_t
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
=
=
ScalarResult
:
:
KeyTooLong
)
{
MOZ_ASSERT
(
false
"
Key
too
long
to
be
recorded
in
the
scalar
.
"
)
;
}
return
;
}
return
scalar
-
>
SetValue
(
aValue
)
;
}
void
KeyedScalar
:
:
SetValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
bool
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
=
=
ScalarResult
:
:
KeyTooLong
)
{
MOZ_ASSERT
(
false
"
Key
too
long
to
be
recorded
in
the
scalar
.
"
)
;
}
return
;
}
return
scalar
-
>
SetValue
(
aValue
)
;
}
void
KeyedScalar
:
:
AddValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
uint32_t
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
=
=
ScalarResult
:
:
KeyTooLong
)
{
MOZ_ASSERT
(
false
"
Key
too
long
to
be
recorded
in
the
scalar
.
"
)
;
}
return
;
}
return
scalar
-
>
AddValue
(
aValue
)
;
}
void
KeyedScalar
:
:
SetMaximum
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
uint32_t
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
=
=
ScalarResult
:
:
KeyTooLong
)
{
MOZ_ASSERT
(
false
"
Key
too
long
to
be
recorded
in
the
scalar
.
"
)
;
}
return
;
}
return
scalar
-
>
SetMaximum
(
aValue
)
;
}
nsresult
KeyedScalar
:
:
GetValue
(
const
nsACString
&
aStoreName
bool
aClearStorage
nsTArray
<
KeyValuePair
>
&
aValues
)
{
for
(
const
auto
&
entry
:
mScalarKeys
)
{
ScalarBase
*
scalar
=
entry
.
GetWeak
(
)
;
nsCOMPtr
<
nsIVariant
>
scalarValue
;
nsresult
rv
=
scalar
-
>
GetValue
(
aStoreName
aClearStorage
scalarValue
)
;
if
(
rv
=
=
NS_ERROR_NO_CONTENT
)
{
continue
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aValues
.
AppendElement
(
std
:
:
make_pair
(
nsCString
(
entry
.
GetKey
(
)
)
scalarValue
)
)
;
}
return
NS_OK
;
}
nsresult
internal_GetKeyedScalarByEnum
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
ProcessID
aProcessStorage
KeyedScalar
*
*
aRet
)
;
nsresult
internal_GetEnumByScalarName
(
const
StaticMutexAutoLock
&
lock
const
nsACString
&
aName
ScalarKey
*
aId
)
;
ScalarResult
KeyedScalar
:
:
GetScalarForKey
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
ScalarBase
*
*
aRet
)
{
if
(
aKey
.
IsEmpty
(
)
)
{
return
ScalarResult
:
:
KeyIsEmpty
;
}
if
(
!
AllowsKey
(
aKey
)
)
{
KeyedScalar
*
scalarUnknown
=
nullptr
;
ScalarKey
scalarUnknownUniqueId
{
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
TELEMETRY_KEYED_SCALARS_UNKNOWN_KEYS
)
false
}
;
ProcessID
process
=
ProcessID
:
:
Parent
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
locker
scalarUnknownUniqueId
process
&
scalarUnknown
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
TooManyKeys
;
}
scalarUnknown
-
>
AddValue
(
locker
NS_ConvertUTF8toUTF16
(
mScalarName
)
1
)
;
return
ScalarResult
:
:
KeyNotAllowed
;
}
if
(
aKey
.
Length
(
)
>
kMaximumKeyStringLength
)
{
return
ScalarResult
:
:
KeyTooLong
;
}
NS_ConvertUTF16toUTF8
utf8Key
(
aKey
)
;
ScalarBase
*
scalar
=
nullptr
;
if
(
mScalarKeys
.
Get
(
utf8Key
&
scalar
)
)
{
*
aRet
=
scalar
;
return
ScalarResult
:
:
Ok
;
}
ScalarKey
uniqueId
;
nsresult
rv
=
internal_GetEnumByScalarName
(
locker
mScalarName
&
uniqueId
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
(
rv
=
=
NS_ERROR_FAILURE
)
?
ScalarResult
:
:
NotInitialized
:
ScalarResult
:
:
UnknownScalar
;
}
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
locker
uniqueId
)
;
if
(
mScalarKeys
.
Count
(
)
>
=
mMaximumNumberOfKeys
)
{
if
(
aKey
.
EqualsLiteral
(
"
telemetry
.
keyed_scalars_exceed_limit
"
)
)
{
return
ScalarResult
:
:
TooManyKeys
;
}
KeyedScalar
*
scalarExceed
=
nullptr
;
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
TELEMETRY_KEYED_SCALARS_EXCEED_LIMIT
)
false
}
;
ProcessID
process
=
ProcessID
:
:
Parent
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
locker
uniqueId
process
&
scalarExceed
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
TooManyKeys
;
}
scalarExceed
-
>
AddValue
(
locker
NS_ConvertUTF8toUTF16
(
info
.
name
(
)
)
1
)
;
return
ScalarResult
:
:
TooManyKeys
;
}
scalar
=
internal_ScalarAllocate
(
info
)
;
if
(
!
scalar
)
{
return
ScalarResult
:
:
InvalidType
;
}
mScalarKeys
.
InsertOrUpdate
(
utf8Key
UniquePtr
<
ScalarBase
>
(
scalar
)
)
;
*
aRet
=
scalar
;
return
ScalarResult
:
:
Ok
;
}
size_t
KeyedScalar
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
this
)
;
for
(
const
auto
&
scalar
:
mScalarKeys
.
Values
(
)
)
{
n
+
=
scalar
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
bool
KeyedScalar
:
:
AllowsKey
(
const
nsAString
&
aKey
)
const
{
if
(
mScalarKeyCount
=
=
0
)
{
return
true
;
}
for
(
uint32_t
i
=
0
;
i
<
mScalarKeyCount
;
+
+
i
)
{
uint32_t
stringIndex
=
gScalarKeysTable
[
mScalarKeyOffset
+
i
]
;
if
(
aKey
.
EqualsASCII
(
&
gScalarsStringTable
[
stringIndex
]
)
)
{
return
true
;
}
}
return
false
;
}
typedef
nsUint32HashKey
ScalarIDHashKey
;
typedef
nsUint32HashKey
ProcessIDHashKey
;
typedef
nsClassHashtable
<
ScalarIDHashKey
ScalarBase
>
ScalarStorageMapType
;
typedef
nsClassHashtable
<
ScalarIDHashKey
KeyedScalar
>
KeyedScalarStorageMapType
;
typedef
nsClassHashtable
<
ProcessIDHashKey
ScalarStorageMapType
>
ProcessesScalarsMapType
;
typedef
nsClassHashtable
<
ProcessIDHashKey
KeyedScalarStorageMapType
>
ProcessesKeyedScalarsMapType
;
typedef
mozilla
:
:
Tuple
<
const
char
*
nsCOMPtr
<
nsIVariant
>
uint32_t
>
ScalarDataTuple
;
typedef
nsTArray
<
ScalarDataTuple
>
ScalarTupleArray
;
typedef
nsTHashMap
<
ProcessIDHashKey
ScalarTupleArray
>
ScalarSnapshotTable
;
typedef
mozilla
:
:
Tuple
<
const
char
*
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
uint32_t
>
KeyedScalarDataTuple
;
typedef
nsTArray
<
KeyedScalarDataTuple
>
KeyedScalarTupleArray
;
typedef
nsTHashMap
<
ProcessIDHashKey
KeyedScalarTupleArray
>
KeyedScalarSnapshotTable
;
}
namespace
{
bool
gInitDone
=
false
;
bool
gCanRecordBase
;
bool
gCanRecordExtended
;
ScalarMapType
gScalarNameIDMap
(
kScalarCount
)
;
ProcessesScalarsMapType
gScalarStorageMap
;
ProcessesKeyedScalarsMapType
gKeyedScalarStorageMap
;
ProcessesScalarsMapType
gDynamicBuiltinScalarStorageMap
;
ProcessesKeyedScalarsMapType
gDynamicBuiltinKeyedScalarStorageMap
;
bool
gIsDeserializing
=
false
;
StaticAutoPtr
<
nsTArray
<
ScalarAction
>
>
gScalarsActions
;
StaticAutoPtr
<
nsTArray
<
KeyedScalarAction
>
>
gKeyedScalarsActions
;
bool
internal_IsScalarDeserializing
(
const
StaticMutexAutoLock
&
lock
)
{
return
gIsDeserializing
;
}
}
namespace
{
void
internal_LogScalarError
(
const
nsACString
&
aScalarName
ScalarResult
aSr
)
{
nsAutoString
errorMessage
;
AppendUTF8toUTF16
(
aScalarName
errorMessage
)
;
switch
(
aSr
)
{
case
ScalarResult
:
:
NotInitialized
:
errorMessage
.
AppendLiteral
(
u
"
-
Telemetry
was
not
yet
initialized
.
"
)
;
break
;
case
ScalarResult
:
:
CannotUnpackVariant
:
errorMessage
.
AppendLiteral
(
u
"
-
Cannot
convert
the
provided
JS
value
to
nsIVariant
.
"
)
;
break
;
case
ScalarResult
:
:
CannotRecordInProcess
:
errorMessage
.
AppendLiteral
(
u
"
-
Cannot
record
the
scalar
in
the
current
process
.
"
)
;
break
;
case
ScalarResult
:
:
KeyedTypeMismatch
:
errorMessage
.
AppendLiteral
(
u
"
-
Attempting
to
manage
a
keyed
scalar
as
a
scalar
(
or
"
u
"
vice
-
versa
)
.
"
)
;
break
;
case
ScalarResult
:
:
UnknownScalar
:
errorMessage
.
AppendLiteral
(
u
"
-
Unknown
scalar
.
"
)
;
break
;
case
ScalarResult
:
:
OperationNotSupported
:
errorMessage
.
AppendLiteral
(
u
"
-
The
requested
operation
is
not
supported
on
this
scalar
.
"
)
;
break
;
case
ScalarResult
:
:
InvalidType
:
errorMessage
.
AppendLiteral
(
u
"
-
Attempted
to
set
the
scalar
to
an
invalid
data
type
.
"
)
;
break
;
case
ScalarResult
:
:
InvalidValue
:
errorMessage
.
AppendLiteral
(
u
"
-
Attempted
to
set
the
scalar
to
an
incompatible
value
.
"
)
;
break
;
case
ScalarResult
:
:
StringTooLong
:
AppendUTF8toUTF16
(
nsPrintfCString
(
"
-
Truncating
scalar
value
to
%
d
characters
.
"
kMaximumStringValueLength
)
errorMessage
)
;
break
;
case
ScalarResult
:
:
KeyIsEmpty
:
errorMessage
.
AppendLiteral
(
u
"
-
The
key
must
not
be
empty
.
"
)
;
break
;
case
ScalarResult
:
:
KeyTooLong
:
AppendUTF8toUTF16
(
nsPrintfCString
(
"
-
The
key
length
must
be
limited
to
%
d
characters
.
"
kMaximumKeyStringLength
)
errorMessage
)
;
break
;
case
ScalarResult
:
:
KeyNotAllowed
:
AppendUTF8toUTF16
(
nsPrintfCString
(
"
-
The
key
is
not
allowed
for
this
scalar
.
"
)
errorMessage
)
;
break
;
case
ScalarResult
:
:
TooManyKeys
:
AppendUTF8toUTF16
(
nsPrintfCString
(
"
-
Keyed
scalars
cannot
have
more
than
%
d
keys
.
"
kMaximumNumberOfKeys
)
errorMessage
)
;
break
;
case
ScalarResult
:
:
UnsignedNegativeValue
:
errorMessage
.
AppendLiteral
(
u
"
-
Trying
to
set
an
unsigned
scalar
to
a
negative
number
.
"
)
;
break
;
case
ScalarResult
:
:
UnsignedTruncatedValue
:
errorMessage
.
AppendLiteral
(
u
"
-
Truncating
float
/
double
number
.
"
)
;
break
;
default
:
return
;
}
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
errorMessage
)
;
}
}
namespace
{
bool
internal_CanRecordBase
(
const
StaticMutexAutoLock
&
lock
)
{
return
gCanRecordBase
;
}
bool
internal_CanRecordExtended
(
const
StaticMutexAutoLock
&
lock
)
{
return
gCanRecordExtended
;
}
bool
internal_IsKeyedScalar
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
)
{
return
internal_GetScalarInfo
(
lock
aId
)
.
keyed
;
}
bool
internal_CanRecordProcess
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
aId
)
;
return
CanRecordInProcess
(
info
.
record_in_processes
XRE_GetProcessType
(
)
)
;
}
bool
internal_CanRecordProduct
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
aId
)
;
return
CanRecordProduct
(
info
.
products
)
;
}
bool
internal_CanRecordForScalarID
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
aId
)
;
bool
canRecordBase
=
internal_CanRecordBase
(
lock
)
;
if
(
!
canRecordBase
)
{
return
false
;
}
bool
canRecordDataset
=
CanRecordDataset
(
info
.
dataset
canRecordBase
internal_CanRecordExtended
(
lock
)
)
;
if
(
!
canRecordDataset
)
{
return
false
;
}
return
true
;
}
ScalarResult
internal_CanRecordScalar
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
bool
aKeyed
bool
aForce
=
false
)
{
if
(
internal_IsKeyedScalar
(
lock
aId
)
!
=
aKeyed
)
{
return
ScalarResult
:
:
KeyedTypeMismatch
;
}
if
(
!
internal_CanRecordForScalarID
(
lock
aId
)
)
{
return
ScalarResult
:
:
CannotRecordDataset
;
}
if
(
!
aForce
&
&
!
internal_CanRecordProcess
(
lock
aId
)
)
{
return
ScalarResult
:
:
CannotRecordInProcess
;
}
if
(
!
internal_CanRecordProduct
(
lock
aId
)
)
{
return
ScalarResult
:
:
CannotRecordDataset
;
}
return
ScalarResult
:
:
Ok
;
}
nsresult
internal_GetEnumByScalarName
(
const
StaticMutexAutoLock
&
lock
const
nsACString
&
aName
ScalarKey
*
aId
)
{
if
(
!
gInitDone
)
{
return
NS_ERROR_FAILURE
;
}
CharPtrEntryType
*
entry
=
gScalarNameIDMap
.
GetEntry
(
PromiseFlatCString
(
aName
)
.
get
(
)
)
;
if
(
!
entry
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aId
=
entry
-
>
GetData
(
)
;
return
NS_OK
;
}
nsresult
internal_GetScalarByEnum
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
ProcessID
aProcessStorage
ScalarBase
*
*
aRet
)
{
if
(
!
internal_IsValidId
(
lock
aId
)
)
{
MOZ_ASSERT
(
false
"
Requested
a
scalar
with
an
invalid
id
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
aId
)
;
if
(
aId
.
dynamic
&
&
!
info
.
builtin
)
{
aProcessStorage
=
ProcessID
:
:
Dynamic
;
}
ScalarBase
*
scalar
=
nullptr
;
uint32_t
storageId
=
static_cast
<
uint32_t
>
(
aProcessStorage
)
;
ProcessesScalarsMapType
&
processStorage
=
(
aId
.
dynamic
&
&
info
.
builtin
)
?
gDynamicBuiltinScalarStorageMap
:
gScalarStorageMap
;
ScalarStorageMapType
*
const
scalarStorage
=
processStorage
.
GetOrInsertNew
(
storageId
)
;
if
(
scalarStorage
-
>
Get
(
aId
.
id
&
scalar
)
)
{
if
(
aId
.
dynamic
)
{
const
DynamicScalarInfo
&
dynInfo
=
static_cast
<
const
DynamicScalarInfo
&
>
(
info
)
;
if
(
dynInfo
.
mDynamicExpiration
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
*
aRet
=
scalar
;
return
NS_OK
;
}
if
(
IsExpiredVersion
(
info
.
expiration
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
scalar
=
internal_ScalarAllocate
(
info
)
;
if
(
!
scalar
)
{
return
NS_ERROR_INVALID_ARG
;
}
scalarStorage
-
>
InsertOrUpdate
(
aId
.
id
UniquePtr
<
ScalarBase
>
(
scalar
)
)
;
*
aRet
=
scalar
;
return
NS_OK
;
}
void
internal_ApplyPendingOperations
(
const
StaticMutexAutoLock
&
lock
)
;
void
internal_RecordScalarAction
(
const
StaticMutexAutoLock
&
lock
const
ScalarAction
&
aScalarAction
)
{
if
(
!
gScalarsActions
)
{
gScalarsActions
=
new
nsTArray
<
ScalarAction
>
(
)
;
}
gScalarsActions
-
>
AppendElement
(
aScalarAction
)
;
if
(
gScalarsActions
-
>
Length
(
)
>
kScalarActionsArrayHighWaterMark
)
{
internal_ApplyPendingOperations
(
lock
)
;
return
;
}
}
void
internal_RecordScalarAction
(
const
StaticMutexAutoLock
&
lock
uint32_t
aId
bool
aDynamic
ScalarActionType
aAction
const
ScalarVariant
&
aValue
)
{
internal_RecordScalarAction
(
lock
ScalarAction
{
aId
aDynamic
aAction
Some
(
aValue
)
ProcessID
:
:
Parent
}
)
;
}
void
internal_RecordKeyedScalarAction
(
const
StaticMutexAutoLock
&
lock
const
KeyedScalarAction
&
aScalarAction
)
{
if
(
!
gKeyedScalarsActions
)
{
gKeyedScalarsActions
=
new
nsTArray
<
KeyedScalarAction
>
(
)
;
}
gKeyedScalarsActions
-
>
AppendElement
(
aScalarAction
)
;
if
(
gKeyedScalarsActions
-
>
Length
(
)
>
kScalarActionsArrayHighWaterMark
)
{
internal_ApplyPendingOperations
(
lock
)
;
return
;
}
}
void
internal_RecordKeyedScalarAction
(
const
StaticMutexAutoLock
&
lock
uint32_t
aId
bool
aDynamic
const
nsAString
&
aKey
ScalarActionType
aAction
const
ScalarVariant
&
aValue
)
{
internal_RecordKeyedScalarAction
(
lock
KeyedScalarAction
{
aId
aDynamic
aAction
NS_ConvertUTF16toUTF8
(
aKey
)
Some
(
aValue
)
ProcessID
:
:
Parent
}
)
;
}
ScalarResult
internal_UpdateScalar
(
const
StaticMutexAutoLock
&
lock
const
nsACString
&
aName
ScalarActionType
aType
nsIVariant
*
aValue
ProcessID
aProcessOverride
=
ProcessID
:
:
Parent
bool
aForce
=
false
)
{
ScalarKey
uniqueId
;
nsresult
rv
=
internal_GetEnumByScalarName
(
lock
aName
&
uniqueId
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
(
rv
=
=
NS_ERROR_FAILURE
)
?
ScalarResult
:
:
NotInitialized
:
ScalarResult
:
:
UnknownScalar
;
}
ScalarResult
sr
=
internal_CanRecordScalar
(
lock
uniqueId
false
aForce
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
=
=
ScalarResult
:
:
CannotRecordDataset
)
{
return
ScalarResult
:
:
Ok
;
}
return
sr
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
uniqueId
)
;
mozilla
:
:
Maybe
<
ScalarVariant
>
variantValue
;
sr
=
GetVariantFromIVariant
(
aValue
info
.
kind
variantValue
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Unable
to
convert
nsIVariant
to
mozilla
:
:
Variant
.
"
)
;
return
sr
;
}
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
aType
variantValue
.
ref
(
)
)
;
return
ScalarResult
:
:
Ok
;
}
if
(
!
aForce
&
&
internal_IsScalarDeserializing
(
lock
)
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
uniqueId
)
;
mozilla
:
:
Maybe
<
ScalarVariant
>
variantValue
;
sr
=
GetVariantFromIVariant
(
aValue
info
.
kind
variantValue
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Unable
to
convert
nsIVariant
to
mozilla
:
:
Variant
.
"
)
;
return
sr
;
}
internal_RecordScalarAction
(
lock
uniqueId
.
id
uniqueId
.
dynamic
aType
variantValue
.
ref
(
)
)
;
return
ScalarResult
:
:
Ok
;
}
ScalarBase
*
scalar
=
nullptr
;
rv
=
internal_GetScalarByEnum
(
lock
uniqueId
aProcessOverride
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
ScalarResult
:
:
Ok
;
}
return
ScalarResult
:
:
UnknownScalar
;
}
if
(
aType
=
=
ScalarActionType
:
:
eAdd
)
{
return
scalar
-
>
AddValue
(
aValue
)
;
}
if
(
aType
=
=
ScalarActionType
:
:
eSet
)
{
return
scalar
-
>
SetValue
(
aValue
)
;
}
return
scalar
-
>
SetMaximum
(
aValue
)
;
}
}
namespace
{
nsresult
internal_GetKeyedScalarByEnum
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
ProcessID
aProcessStorage
KeyedScalar
*
*
aRet
)
{
if
(
!
internal_IsValidId
(
lock
aId
)
)
{
MOZ_ASSERT
(
false
"
Requested
a
keyed
scalar
with
an
invalid
id
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
aId
)
;
if
(
aId
.
dynamic
&
&
!
info
.
builtin
)
{
aProcessStorage
=
ProcessID
:
:
Dynamic
;
}
KeyedScalar
*
scalar
=
nullptr
;
uint32_t
storageId
=
static_cast
<
uint32_t
>
(
aProcessStorage
)
;
ProcessesKeyedScalarsMapType
&
processStorage
=
(
aId
.
dynamic
&
&
info
.
builtin
)
?
gDynamicBuiltinKeyedScalarStorageMap
:
gKeyedScalarStorageMap
;
KeyedScalarStorageMapType
*
const
scalarStorage
=
processStorage
.
GetOrInsertNew
(
storageId
)
;
if
(
scalarStorage
-
>
Get
(
aId
.
id
&
scalar
)
)
{
*
aRet
=
scalar
;
return
NS_OK
;
}
if
(
IsExpiredVersion
(
info
.
expiration
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
info
.
kind
=
=
nsITelemetry
:
:
SCALAR_TYPE_STRING
)
{
MOZ_ASSERT
(
false
"
Keyed
string
scalars
are
not
currently
supported
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
scalar
=
new
KeyedScalar
(
info
)
;
scalarStorage
-
>
InsertOrUpdate
(
aId
.
id
UniquePtr
<
KeyedScalar
>
(
scalar
)
)
;
*
aRet
=
scalar
;
return
NS_OK
;
}
ScalarResult
internal_UpdateKeyedScalar
(
const
StaticMutexAutoLock
&
lock
const
nsACString
&
aName
const
nsAString
&
aKey
ScalarActionType
aType
nsIVariant
*
aValue
ProcessID
aProcessOverride
=
ProcessID
:
:
Parent
bool
aForce
=
false
)
{
ScalarKey
uniqueId
;
nsresult
rv
=
internal_GetEnumByScalarName
(
lock
aName
&
uniqueId
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
(
rv
=
=
NS_ERROR_FAILURE
)
?
ScalarResult
:
:
NotInitialized
:
ScalarResult
:
:
UnknownScalar
;
}
ScalarResult
sr
=
internal_CanRecordScalar
(
lock
uniqueId
true
aForce
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
=
=
ScalarResult
:
:
CannotRecordDataset
)
{
return
ScalarResult
:
:
Ok
;
}
return
sr
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
uniqueId
)
;
mozilla
:
:
Maybe
<
ScalarVariant
>
variantValue
;
sr
=
GetVariantFromIVariant
(
aValue
info
.
kind
variantValue
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Unable
to
convert
nsIVariant
to
mozilla
:
:
Variant
.
"
)
;
return
sr
;
}
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
aKey
aType
variantValue
.
ref
(
)
)
;
return
ScalarResult
:
:
Ok
;
}
if
(
!
aForce
&
&
internal_IsScalarDeserializing
(
lock
)
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
uniqueId
)
;
mozilla
:
:
Maybe
<
ScalarVariant
>
variantValue
;
sr
=
GetVariantFromIVariant
(
aValue
info
.
kind
variantValue
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Unable
to
convert
nsIVariant
to
mozilla
:
:
Variant
.
"
)
;
return
sr
;
}
internal_RecordKeyedScalarAction
(
lock
uniqueId
.
id
uniqueId
.
dynamic
aKey
aType
variantValue
.
ref
(
)
)
;
return
ScalarResult
:
:
Ok
;
}
KeyedScalar
*
scalar
=
nullptr
;
rv
=
internal_GetKeyedScalarByEnum
(
lock
uniqueId
aProcessOverride
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
ScalarResult
:
:
Ok
;
}
return
ScalarResult
:
:
UnknownScalar
;
}
if
(
aType
=
=
ScalarActionType
:
:
eAdd
)
{
return
scalar
-
>
AddValue
(
lock
aKey
aValue
)
;
}
if
(
aType
=
=
ScalarActionType
:
:
eSet
)
{
return
scalar
-
>
SetValue
(
lock
aKey
aValue
)
;
}
return
scalar
-
>
SetMaximum
(
lock
aKey
aValue
)
;
}
void
internal_DynamicScalarToIPC
(
const
StaticMutexAutoLock
&
lock
const
nsTArray
<
DynamicScalarInfo
>
&
aDynamicScalarInfos
nsTArray
<
DynamicScalarDefinition
>
&
aIPCDefs
)
{
for
(
auto
&
info
:
aDynamicScalarInfos
)
{
DynamicScalarDefinition
stubDefinition
;
stubDefinition
.
type
=
info
.
kind
;
stubDefinition
.
dataset
=
info
.
dataset
;
stubDefinition
.
expired
=
info
.
mDynamicExpiration
;
stubDefinition
.
keyed
=
info
.
keyed
;
stubDefinition
.
name
=
info
.
mDynamicName
;
stubDefinition
.
builtin
=
info
.
builtin
;
aIPCDefs
.
AppendElement
(
stubDefinition
)
;
}
}
void
internal_BroadcastDefinitions
(
const
nsTArray
<
DynamicScalarDefinition
>
&
scalarDefs
)
{
nsTArray
<
mozilla
:
:
dom
:
:
ContentParent
*
>
parents
;
mozilla
:
:
dom
:
:
ContentParent
:
:
GetAll
(
parents
)
;
if
(
!
parents
.
Length
(
)
)
{
return
;
}
for
(
auto
parent
:
parents
)
{
mozilla
:
:
Unused
<
<
parent
-
>
SendAddDynamicScalars
(
scalarDefs
)
;
}
}
void
internal_RegisterScalars
(
const
StaticMutexAutoLock
&
lock
const
nsTArray
<
DynamicScalarInfo
>
&
scalarInfos
)
{
if
(
!
gDynamicScalarInfo
)
{
gDynamicScalarInfo
=
new
nsTArray
<
DynamicScalarInfo
>
(
)
;
}
if
(
!
gDynamicStoreNames
)
{
gDynamicStoreNames
=
new
nsTArray
<
RefPtr
<
nsAtom
>
>
(
)
;
}
for
(
auto
&
scalarInfo
:
scalarInfos
)
{
CharPtrEntryType
*
existingKey
=
gScalarNameIDMap
.
GetEntry
(
scalarInfo
.
name
(
)
)
;
if
(
existingKey
)
{
if
(
scalarInfo
.
mDynamicExpiration
&
&
!
scalarInfo
.
builtin
)
{
DynamicScalarInfo
&
scalarData
=
(
*
gDynamicScalarInfo
)
[
existingKey
-
>
GetData
(
)
.
id
]
;
scalarData
.
mDynamicExpiration
=
true
;
}
continue
;
}
gDynamicScalarInfo
-
>
AppendElement
(
scalarInfo
)
;
uint32_t
scalarId
=
gDynamicScalarInfo
-
>
Length
(
)
-
1
;
CharPtrEntryType
*
entry
=
gScalarNameIDMap
.
PutEntry
(
scalarInfo
.
name
(
)
)
;
entry
-
>
SetData
(
ScalarKey
{
scalarId
true
}
)
;
}
}
nsresult
internal_ScalarSnapshotter
(
const
StaticMutexAutoLock
&
aLock
ScalarSnapshotTable
&
aScalarsToReflect
unsigned
int
aDataset
ProcessesScalarsMapType
&
aProcessStorage
bool
aIsBuiltinDynamic
bool
aClearScalars
const
nsACString
&
aStoreName
)
{
for
(
const
auto
&
entry
:
aProcessStorage
)
{
ScalarStorageMapType
*
scalarStorage
=
entry
.
GetWeak
(
)
;
ScalarTupleArray
&
processScalars
=
aScalarsToReflect
.
LookupOrInsert
(
entry
.
GetKey
(
)
)
;
bool
isDynamicProcess
=
ProcessID
:
:
Dynamic
=
=
static_cast
<
ProcessID
>
(
entry
.
GetKey
(
)
)
;
for
(
const
auto
&
childEntry
:
*
scalarStorage
)
{
ScalarBase
*
scalar
=
childEntry
.
GetWeak
(
)
;
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
aLock
ScalarKey
{
childEntry
.
GetKey
(
)
aIsBuiltinDynamic
?
true
:
isDynamicProcess
}
)
;
if
(
IsInDataset
(
info
.
dataset
aDataset
)
)
{
nsCOMPtr
<
nsIVariant
>
scalarValue
;
nsresult
rv
=
scalar
-
>
GetValue
(
aStoreName
aClearScalars
scalarValue
)
;
if
(
rv
=
=
NS_ERROR_NO_CONTENT
)
{
continue
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
processScalars
.
AppendElement
(
mozilla
:
:
MakeTuple
(
info
.
name
(
)
scalarValue
info
.
kind
)
)
;
}
}
if
(
processScalars
.
Length
(
)
=
=
0
)
{
aScalarsToReflect
.
Remove
(
entry
.
GetKey
(
)
)
;
}
}
return
NS_OK
;
}
nsresult
internal_KeyedScalarSnapshotter
(
const
StaticMutexAutoLock
&
aLock
KeyedScalarSnapshotTable
&
aScalarsToReflect
unsigned
int
aDataset
ProcessesKeyedScalarsMapType
&
aProcessStorage
bool
aIsBuiltinDynamic
bool
aClearScalars
const
nsACString
&
aStoreName
)
{
for
(
const
auto
&
entry
:
aProcessStorage
)
{
KeyedScalarStorageMapType
*
scalarStorage
=
entry
.
GetWeak
(
)
;
KeyedScalarTupleArray
&
processScalars
=
aScalarsToReflect
.
LookupOrInsert
(
entry
.
GetKey
(
)
)
;
bool
isDynamicProcess
=
ProcessID
:
:
Dynamic
=
=
static_cast
<
ProcessID
>
(
entry
.
GetKey
(
)
)
;
for
(
const
auto
&
childEntry
:
*
scalarStorage
)
{
KeyedScalar
*
scalar
=
childEntry
.
GetWeak
(
)
;
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
aLock
ScalarKey
{
childEntry
.
GetKey
(
)
aIsBuiltinDynamic
?
true
:
isDynamicProcess
}
)
;
if
(
IsInDataset
(
info
.
dataset
aDataset
)
)
{
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
scalarKeyedData
;
nsresult
rv
=
scalar
-
>
GetValue
(
aStoreName
aClearScalars
scalarKeyedData
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
scalarKeyedData
.
Length
(
)
=
=
0
)
{
continue
;
}
processScalars
.
AppendElement
(
mozilla
:
:
MakeTuple
(
info
.
name
(
)
std
:
:
move
(
scalarKeyedData
)
info
.
kind
)
)
;
}
}
if
(
processScalars
.
Length
(
)
=
=
0
)
{
aScalarsToReflect
.
Remove
(
entry
.
GetKey
(
)
)
;
}
}
return
NS_OK
;
}
nsresult
internal_GetScalarSnapshot
(
const
StaticMutexAutoLock
&
aLock
ScalarSnapshotTable
&
aScalarsToReflect
unsigned
int
aDataset
bool
aClearScalars
const
nsACString
&
aStoreName
)
{
nsresult
rv
=
internal_ScalarSnapshotter
(
aLock
aScalarsToReflect
aDataset
gScalarStorageMap
false
aClearScalars
aStoreName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
internal_ScalarSnapshotter
(
aLock
aScalarsToReflect
aDataset
gDynamicBuiltinScalarStorageMap
true
aClearScalars
aStoreName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
internal_GetKeyedScalarSnapshot
(
const
StaticMutexAutoLock
&
aLock
KeyedScalarSnapshotTable
&
aScalarsToReflect
unsigned
int
aDataset
bool
aClearScalars
const
nsACString
&
aStoreName
)
{
nsresult
rv
=
internal_KeyedScalarSnapshotter
(
aLock
aScalarsToReflect
aDataset
gKeyedScalarStorageMap
false
aClearScalars
aStoreName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
internal_KeyedScalarSnapshotter
(
aLock
aScalarsToReflect
aDataset
gDynamicBuiltinKeyedScalarStorageMap
true
aClearScalars
aStoreName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
namespace
{
void
internal_ApplyScalarActions
(
const
StaticMutexAutoLock
&
lock
const
nsTArray
<
mozilla
:
:
Telemetry
:
:
ScalarAction
>
&
aScalarActions
const
mozilla
:
:
Maybe
<
ProcessID
>
&
aProcessType
=
Nothing
(
)
)
{
if
(
!
internal_CanRecordBase
(
lock
)
)
{
return
;
}
for
(
auto
&
upd
:
aScalarActions
)
{
ScalarKey
uniqueId
{
upd
.
mId
upd
.
mDynamic
}
;
if
(
NS_WARN_IF
(
!
internal_IsValidId
(
lock
uniqueId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
continue
;
}
if
(
internal_IsKeyedScalar
(
lock
uniqueId
)
)
{
continue
;
}
if
(
!
internal_CanRecordForScalarID
(
lock
uniqueId
)
)
{
continue
;
}
ProcessID
processType
=
aProcessType
.
valueOr
(
upd
.
mProcessType
)
;
MOZ_ASSERT
(
processType
!
=
ProcessID
:
:
Count
)
;
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
lock
uniqueId
processType
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
{
NS_WARNING
(
"
NS_FAILED
internal_GetScalarByEnum
for
CHILD
"
)
;
}
continue
;
}
if
(
upd
.
mData
.
isNothing
(
)
)
{
MOZ_ASSERT
(
false
"
There
is
no
data
in
the
ScalarActionType
.
"
)
;
continue
;
}
const
uint32_t
scalarType
=
internal_GetScalarInfo
(
lock
uniqueId
)
.
kind
;
switch
(
upd
.
mActionType
)
{
case
ScalarActionType
:
:
eSet
:
{
switch
(
scalarType
)
{
case
nsITelemetry
:
:
SCALAR_TYPE_COUNT
:
if
(
!
upd
.
mData
-
>
is
<
uint32_t
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
set
a
count
scalar
to
a
non
-
integer
.
"
)
;
continue
;
}
scalar
-
>
SetValue
(
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
case
nsITelemetry
:
:
SCALAR_TYPE_BOOLEAN
:
if
(
!
upd
.
mData
-
>
is
<
bool
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
set
a
boolean
scalar
to
a
non
-
boolean
.
"
)
;
continue
;
}
scalar
-
>
SetValue
(
upd
.
mData
-
>
as
<
bool
>
(
)
)
;
break
;
case
nsITelemetry
:
:
SCALAR_TYPE_STRING
:
if
(
!
upd
.
mData
-
>
is
<
nsString
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
set
a
string
scalar
to
a
non
-
string
.
"
)
;
continue
;
}
scalar
-
>
SetValue
(
upd
.
mData
-
>
as
<
nsString
>
(
)
)
;
break
;
}
break
;
}
case
ScalarActionType
:
:
eAdd
:
{
if
(
scalarType
!
=
nsITelemetry
:
:
SCALAR_TYPE_COUNT
)
{
NS_WARNING
(
"
Attempting
to
add
on
a
non
count
scalar
.
"
)
;
continue
;
}
if
(
!
upd
.
mData
-
>
is
<
uint32_t
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
add
to
a
count
scalar
with
a
non
-
integer
.
"
)
;
continue
;
}
scalar
-
>
AddValue
(
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
}
case
ScalarActionType
:
:
eSetMaximum
:
{
if
(
scalarType
!
=
nsITelemetry
:
:
SCALAR_TYPE_COUNT
)
{
NS_WARNING
(
"
Attempting
to
setMaximum
on
a
non
count
scalar
.
"
)
;
continue
;
}
if
(
!
upd
.
mData
-
>
is
<
uint32_t
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
setMaximum
a
count
scalar
to
a
non
-
integer
.
"
)
;
continue
;
}
scalar
-
>
SetMaximum
(
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
}
default
:
NS_WARNING
(
"
Unsupported
action
coming
from
scalar
child
updates
.
"
)
;
}
}
}
void
internal_ApplyKeyedScalarActions
(
const
StaticMutexAutoLock
&
lock
const
nsTArray
<
mozilla
:
:
Telemetry
:
:
KeyedScalarAction
>
&
aScalarActions
const
mozilla
:
:
Maybe
<
ProcessID
>
&
aProcessType
=
Nothing
(
)
)
{
if
(
!
internal_CanRecordBase
(
lock
)
)
{
return
;
}
for
(
auto
&
upd
:
aScalarActions
)
{
ScalarKey
uniqueId
{
upd
.
mId
upd
.
mDynamic
}
;
if
(
NS_WARN_IF
(
!
internal_IsValidId
(
lock
uniqueId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
continue
;
}
if
(
!
internal_IsKeyedScalar
(
lock
uniqueId
)
)
{
continue
;
}
if
(
!
internal_CanRecordForScalarID
(
lock
uniqueId
)
)
{
continue
;
}
ProcessID
processType
=
aProcessType
.
valueOr
(
upd
.
mProcessType
)
;
MOZ_ASSERT
(
processType
!
=
ProcessID
:
:
Count
)
;
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
lock
uniqueId
processType
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
{
NS_WARNING
(
"
NS_FAILED
internal_GetKeyedScalarByEnum
for
CHILD
"
)
;
}
continue
;
}
if
(
upd
.
mData
.
isNothing
(
)
)
{
MOZ_ASSERT
(
false
"
There
is
no
data
in
the
KeyedScalarAction
.
"
)
;
continue
;
}
const
uint32_t
scalarType
=
internal_GetScalarInfo
(
lock
uniqueId
)
.
kind
;
switch
(
upd
.
mActionType
)
{
case
ScalarActionType
:
:
eSet
:
{
switch
(
scalarType
)
{
case
nsITelemetry
:
:
SCALAR_TYPE_COUNT
:
if
(
!
upd
.
mData
-
>
is
<
uint32_t
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
set
a
count
scalar
to
a
non
-
integer
.
"
)
;
continue
;
}
scalar
-
>
SetValue
(
lock
NS_ConvertUTF8toUTF16
(
upd
.
mKey
)
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
case
nsITelemetry
:
:
SCALAR_TYPE_BOOLEAN
:
if
(
!
upd
.
mData
-
>
is
<
bool
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
set
a
boolean
scalar
to
a
non
-
boolean
.
"
)
;
continue
;
}
scalar
-
>
SetValue
(
lock
NS_ConvertUTF8toUTF16
(
upd
.
mKey
)
upd
.
mData
-
>
as
<
bool
>
(
)
)
;
break
;
default
:
NS_WARNING
(
"
Unsupported
type
coming
from
scalar
child
updates
.
"
)
;
}
break
;
}
case
ScalarActionType
:
:
eAdd
:
{
if
(
scalarType
!
=
nsITelemetry
:
:
SCALAR_TYPE_COUNT
)
{
NS_WARNING
(
"
Attempting
to
add
on
a
non
count
scalar
.
"
)
;
continue
;
}
if
(
!
upd
.
mData
-
>
is
<
uint32_t
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
add
to
a
count
scalar
with
a
non
-
integer
.
"
)
;
continue
;
}
scalar
-
>
AddValue
(
lock
NS_ConvertUTF8toUTF16
(
upd
.
mKey
)
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
}
case
ScalarActionType
:
:
eSetMaximum
:
{
if
(
scalarType
!
=
nsITelemetry
:
:
SCALAR_TYPE_COUNT
)
{
NS_WARNING
(
"
Attempting
to
setMaximum
on
a
non
count
scalar
.
"
)
;
continue
;
}
if
(
!
upd
.
mData
-
>
is
<
uint32_t
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
setMaximum
a
count
scalar
to
a
non
-
integer
.
"
)
;
continue
;
}
scalar
-
>
SetMaximum
(
lock
NS_ConvertUTF8toUTF16
(
upd
.
mKey
)
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
}
default
:
NS_WARNING
(
"
Unsupported
action
coming
from
keyed
scalar
child
updates
.
"
)
;
}
}
}
void
internal_ApplyPendingOperations
(
const
StaticMutexAutoLock
&
lock
)
{
if
(
gScalarsActions
&
&
gScalarsActions
-
>
Length
(
)
>
0
)
{
internal_ApplyScalarActions
(
lock
*
gScalarsActions
)
;
gScalarsActions
-
>
Clear
(
)
;
}
if
(
gKeyedScalarsActions
&
&
gKeyedScalarsActions
-
>
Length
(
)
>
0
)
{
internal_ApplyKeyedScalarActions
(
lock
*
gKeyedScalarsActions
)
;
gKeyedScalarsActions
-
>
Clear
(
)
;
}
gIsDeserializing
=
false
;
}
}
static
StaticMutex
gTelemetryScalarsMutex
MOZ_UNANNOTATED
;
void
TelemetryScalar
:
:
InitializeGlobalState
(
bool
aCanRecordBase
bool
aCanRecordExtended
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
MOZ_ASSERT
(
!
gInitDone
"
TelemetryScalar
:
:
InitializeGlobalState
"
"
may
only
be
called
once
"
)
;
gCanRecordBase
=
aCanRecordBase
;
gCanRecordExtended
=
aCanRecordExtended
;
uint32_t
scalarCount
=
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
ScalarCount
)
;
for
(
uint32_t
i
=
0
;
i
<
scalarCount
;
i
+
+
)
{
CharPtrEntryType
*
entry
=
gScalarNameIDMap
.
PutEntry
(
gScalars
[
i
]
.
name
(
)
)
;
entry
-
>
SetData
(
ScalarKey
{
i
false
}
)
;
}
const
nsTArray
<
DynamicScalarInfo
>
initialDynamicScalars
(
{
DynamicScalarInfo
{
nsITelemetry
:
:
SCALAR_TYPE_COUNT
true
false
nsAutoCString
(
"
telemetry
.
dynamic_event_counts
"
)
true
false
{
}
}
}
)
;
internal_RegisterScalars
(
locker
initialDynamicScalars
)
;
gInitDone
=
true
;
}
void
TelemetryScalar
:
:
DeInitializeGlobalState
(
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gCanRecordBase
=
false
;
gCanRecordExtended
=
false
;
gScalarNameIDMap
.
Clear
(
)
;
gScalarStorageMap
.
Clear
(
)
;
gKeyedScalarStorageMap
.
Clear
(
)
;
gDynamicBuiltinScalarStorageMap
.
Clear
(
)
;
gDynamicBuiltinKeyedScalarStorageMap
.
Clear
(
)
;
gDynamicScalarInfo
=
nullptr
;
gDynamicStoreNames
=
nullptr
;
gInitDone
=
false
;
}
void
TelemetryScalar
:
:
DeserializationStarted
(
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gIsDeserializing
=
true
;
}
void
TelemetryScalar
:
:
ApplyPendingOperations
(
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
internal_ApplyPendingOperations
(
locker
)
;
}
void
TelemetryScalar
:
:
SetCanRecordBase
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gCanRecordBase
=
b
;
}
void
TelemetryScalar
:
:
SetCanRecordExtended
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gCanRecordExtended
=
b
;
}
nsresult
TelemetryScalar
:
:
Add
(
const
nsACString
&
aName
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateScalar
(
locker
aName
ScalarActionType
:
:
eAdd
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
Add
(
const
nsACString
&
aName
const
nsAString
&
aKey
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateKeyedScalar
(
locker
aName
aKey
ScalarActionType
:
:
eAdd
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
void
TelemetryScalar
:
:
Add
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eAdd
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eAdd
ScalarVariant
(
aValue
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
AddValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Add
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
true
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eAdd
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordKeyedScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eAdd
ScalarVariant
(
aValue
)
)
;
return
;
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
AddValue
(
locker
aKey
aValue
)
;
}
nsresult
TelemetryScalar
:
:
Set
(
const
nsACString
&
aName
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateScalar
(
locker
aName
ScalarActionType
:
:
eSet
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
Set
(
const
nsACString
&
aName
const
nsAString
&
aKey
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateKeyedScalar
(
locker
aName
aKey
ScalarActionType
:
:
eSet
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSet
ScalarVariant
(
nsString
(
aValue
)
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSet
ScalarVariant
(
nsString
(
aValue
)
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
bool
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
true
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordKeyedScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
locker
aKey
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
bool
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
true
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordKeyedScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
locker
aKey
aValue
)
;
}
nsresult
TelemetryScalar
:
:
SetMaximum
(
const
nsACString
&
aName
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateScalar
(
locker
aName
ScalarActionType
:
:
eSetMaximum
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
SetMaximum
(
const
nsACString
&
aName
const
nsAString
&
aKey
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateKeyedScalar
(
locker
aName
aKey
ScalarActionType
:
:
eSetMaximum
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
void
TelemetryScalar
:
:
SetMaximum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSetMaximum
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSetMaximum
ScalarVariant
(
aValue
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetMaximum
(
aValue
)
;
}
void
TelemetryScalar
:
:
SetMaximum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
true
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eSetMaximum
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordKeyedScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eSetMaximum
ScalarVariant
(
aValue
)
)
;
return
;
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetMaximum
(
locker
aKey
aValue
)
;
}
nsresult
TelemetryScalar
:
:
CreateSnapshots
(
unsigned
int
aDataset
bool
aClearScalars
JSContext
*
aCx
uint8_t
optional_argc
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
bool
aFilterTest
const
nsACString
&
aStoreName
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Snapshotting
scalars
should
only
happen
in
the
parent
processes
.
"
)
;
if
(
!
optional_argc
)
{
aClearScalars
=
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
root_obj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
root_obj
)
{
return
NS_ERROR_FAILURE
;
}
aResult
.
setObject
(
*
root_obj
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_OK
;
}
ScalarSnapshotTable
scalarsToReflect
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
nsresult
rv
=
internal_GetScalarSnapshot
(
locker
scalarsToReflect
aDataset
aClearScalars
aStoreName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
for
(
const
auto
&
entry
:
scalarsToReflect
)
{
const
ScalarTupleArray
&
processScalars
=
entry
.
GetData
(
)
;
const
char
*
processName
=
GetNameForProcessID
(
ProcessID
(
entry
.
GetKey
(
)
)
)
;
JS
:
:
RootedObject
processObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
processObj
|
|
!
JS_DefineProperty
(
aCx
root_obj
processName
processObj
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
ScalarTupleArray
:
:
size_type
i
=
0
;
i
<
processScalars
.
Length
(
)
;
i
+
+
)
{
const
ScalarDataTuple
&
scalar
=
processScalars
[
i
]
;
const
char
*
scalarName
=
mozilla
:
:
Get
<
0
>
(
scalar
)
;
if
(
aFilterTest
&
&
strncmp
(
TEST_SCALAR_PREFIX
scalarName
strlen
(
TEST_SCALAR_PREFIX
)
)
=
=
0
)
{
continue
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
scalarJsValue
(
aCx
)
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
VariantToJS
(
aCx
processObj
mozilla
:
:
Get
<
1
>
(
scalar
)
&
scalarJsValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
JS_DefineProperty
(
aCx
processObj
scalarName
scalarJsValue
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
CreateKeyedSnapshots
(
unsigned
int
aDataset
bool
aClearScalars
JSContext
*
aCx
uint8_t
optional_argc
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
bool
aFilterTest
const
nsACString
&
aStoreName
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Snapshotting
scalars
should
only
happen
in
the
parent
processes
.
"
)
;
if
(
!
optional_argc
)
{
aClearScalars
=
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
root_obj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
root_obj
)
{
return
NS_ERROR_FAILURE
;
}
aResult
.
setObject
(
*
root_obj
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_OK
;
}
KeyedScalarSnapshotTable
scalarsToReflect
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
nsresult
rv
=
internal_GetKeyedScalarSnapshot
(
locker
scalarsToReflect
aDataset
aClearScalars
aStoreName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
for
(
const
auto
&
entry
:
scalarsToReflect
)
{
const
KeyedScalarTupleArray
&
processScalars
=
entry
.
GetData
(
)
;
const
char
*
processName
=
GetNameForProcessID
(
ProcessID
(
entry
.
GetKey
(
)
)
)
;
JS
:
:
RootedObject
processObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
processObj
|
|
!
JS_DefineProperty
(
aCx
root_obj
processName
processObj
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
KeyedScalarTupleArray
:
:
size_type
i
=
0
;
i
<
processScalars
.
Length
(
)
;
i
+
+
)
{
const
KeyedScalarDataTuple
&
keyedScalarData
=
processScalars
[
i
]
;
const
char
*
scalarName
=
mozilla
:
:
Get
<
0
>
(
keyedScalarData
)
;
if
(
aFilterTest
&
&
strncmp
(
TEST_SCALAR_PREFIX
scalarName
strlen
(
TEST_SCALAR_PREFIX
)
)
=
=
0
)
{
continue
;
}
JS
:
:
RootedObject
keyedScalarObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
const
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
&
keyProps
=
mozilla
:
:
Get
<
1
>
(
keyedScalarData
)
;
for
(
uint32_t
i
=
0
;
i
<
keyProps
.
Length
(
)
;
i
+
+
)
{
const
KeyedScalar
:
:
KeyValuePair
&
keyData
=
keyProps
[
i
]
;
JS
:
:
Rooted
<
JS
:
:
Value
>
keyJsValue
(
aCx
)
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
VariantToJS
(
aCx
keyedScalarObj
keyData
.
second
&
keyJsValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
const
NS_ConvertUTF8toUTF16
key
(
keyData
.
first
)
;
if
(
!
JS_DefineUCProperty
(
aCx
keyedScalarObj
key
.
Data
(
)
key
.
Length
(
)
keyJsValue
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
!
JS_DefineProperty
(
aCx
processObj
scalarName
keyedScalarObj
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
RegisterScalars
(
const
nsACString
&
aCategoryName
JS
:
:
Handle
<
JS
:
:
Value
>
aScalarData
bool
aBuiltin
JSContext
*
cx
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Dynamic
scalars
should
only
be
created
in
the
parent
process
.
"
)
;
if
(
!
IsValidIdentifierString
(
aCategoryName
kMaximumCategoryNameLength
true
false
)
)
{
JS_ReportErrorASCII
(
cx
"
Invalid
category
name
%
s
.
"
PromiseFlatCString
(
aCategoryName
)
.
get
(
)
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
aScalarData
.
isObject
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Scalar
data
parameter
should
be
an
object
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
JS
:
:
RootedObject
obj
(
cx
&
aScalarData
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
scalarPropertyIds
(
cx
JS
:
:
IdVector
(
cx
)
)
;
if
(
!
JS_Enumerate
(
cx
obj
&
scalarPropertyIds
)
)
{
return
NS_ERROR_FAILURE
;
}
nsTArray
<
DynamicScalarInfo
>
newScalarInfos
;
for
(
size_t
i
=
0
n
=
scalarPropertyIds
.
length
(
)
;
i
<
n
;
i
+
+
)
{
nsAutoJSString
scalarName
;
if
(
!
scalarName
.
init
(
cx
scalarPropertyIds
[
i
]
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsValidIdentifierString
(
NS_ConvertUTF16toUTF8
(
scalarName
)
kMaximumScalarNameLength
false
true
)
)
{
JS_ReportErrorASCII
(
cx
"
Invalid
scalar
name
%
s
.
"
PromiseFlatCString
(
NS_ConvertUTF16toUTF8
(
scalarName
)
)
.
get
(
)
)
;
return
NS_ERROR_INVALID_ARG
;
}
nsPrintfCString
fullName
(
"
%
s
.
%
s
"
PromiseFlatCString
(
aCategoryName
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
scalarName
)
.
get
(
)
)
;
JS
:
:
RootedValue
value
(
cx
)
;
if
(
!
JS_GetPropertyById
(
cx
obj
scalarPropertyIds
[
i
]
&
value
)
|
|
!
value
.
isObject
(
)
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedObject
scalarDef
(
cx
&
value
.
toObject
(
)
)
;
if
(
!
JS_GetProperty
(
cx
scalarDef
"
kind
"
&
value
)
|
|
!
value
.
isInt32
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Invalid
or
missing
'
kind
'
for
scalar
%
s
.
"
PromiseFlatCString
(
fullName
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
kind
=
static_cast
<
uint32_t
>
(
value
.
toInt32
(
)
)
;
bool
hasProperty
=
false
;
bool
recordOnRelease
=
false
;
if
(
JS_HasProperty
(
cx
scalarDef
"
record_on_release
"
&
hasProperty
)
&
&
hasProperty
)
{
if
(
!
JS_GetProperty
(
cx
scalarDef
"
record_on_release
"
&
value
)
|
|
!
value
.
isBoolean
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Invalid
'
record_on_release
'
for
scalar
%
s
.
"
PromiseFlatCString
(
fullName
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
recordOnRelease
=
static_cast
<
bool
>
(
value
.
toBoolean
(
)
)
;
}
bool
keyed
=
false
;
if
(
JS_HasProperty
(
cx
scalarDef
"
keyed
"
&
hasProperty
)
&
&
hasProperty
)
{
if
(
!
JS_GetProperty
(
cx
scalarDef
"
keyed
"
&
value
)
|
|
!
value
.
isBoolean
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Invalid
'
keyed
'
for
scalar
%
s
.
"
PromiseFlatCString
(
fullName
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
keyed
=
static_cast
<
bool
>
(
value
.
toBoolean
(
)
)
;
}
bool
expired
=
false
;
if
(
JS_HasProperty
(
cx
scalarDef
"
expired
"
&
hasProperty
)
&
&
hasProperty
)
{
if
(
!
JS_GetProperty
(
cx
scalarDef
"
expired
"
&
value
)
|
|
!
value
.
isBoolean
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Invalid
'
expired
'
for
scalar
%
s
.
"
PromiseFlatCString
(
fullName
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
expired
=
static_cast
<
bool
>
(
value
.
toBoolean
(
)
)
;
}
nsTArray
<
nsCString
>
stores
;
if
(
JS_HasProperty
(
cx
scalarDef
"
stores
"
&
hasProperty
)
&
&
hasProperty
)
{
bool
isArray
=
false
;
if
(
!
JS_GetProperty
(
cx
scalarDef
"
stores
"
&
value
)
|
|
!
JS
:
:
IsArrayObject
(
cx
value
&
isArray
)
|
|
!
isArray
)
{
JS_ReportErrorASCII
(
cx
"
Invalid
'
stores
'
for
scalar
%
s
.
"
PromiseFlatCString
(
fullName
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedObject
arrayObj
(
cx
&
value
.
toObject
(
)
)
;
uint32_t
storesLength
=
0
;
if
(
!
JS
:
:
GetArrayLength
(
cx
arrayObj
&
storesLength
)
)
{
JS_ReportErrorASCII
(
cx
"
Can
'
t
get
'
stores
'
array
length
for
scalar
%
s
.
"
PromiseFlatCString
(
fullName
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
for
(
uint32_t
i
=
0
;
i
<
storesLength
;
+
+
i
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
elt
(
cx
)
;
if
(
!
JS_GetElement
(
cx
arrayObj
i
&
elt
)
)
{
JS_ReportErrorASCII
(
cx
"
Can
'
t
get
element
from
scalar
%
s
'
stores
'
array
.
"
PromiseFlatCString
(
fullName
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
elt
.
isString
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Element
in
scalar
%
s
'
stores
'
array
isn
'
t
a
"
"
string
.
"
PromiseFlatCString
(
fullName
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
nsAutoJSString
jsStr
;
if
(
!
jsStr
.
init
(
cx
elt
)
)
{
return
NS_ERROR_FAILURE
;
}
stores
.
AppendElement
(
NS_ConvertUTF16toUTF8
(
jsStr
)
)
;
}
if
(
stores
.
Length
(
)
=
=
1
&
&
stores
[
0
]
.
EqualsLiteral
(
"
main
"
)
)
{
stores
.
TruncateLength
(
0
)
;
}
}
newScalarInfos
.
AppendElement
(
DynamicScalarInfo
{
kind
recordOnRelease
expired
fullName
keyed
aBuiltin
std
:
:
move
(
stores
)
}
)
;
}
nsTArray
<
DynamicScalarDefinition
>
ipcDefinitions
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
:
:
internal_RegisterScalars
(
locker
newScalarInfos
)
;
:
:
internal_DynamicScalarToIPC
(
locker
newScalarInfos
ipcDefinitions
)
;
}
:
:
internal_BroadcastDefinitions
(
ipcDefinitions
)
;
return
NS_OK
;
}
void
TelemetryScalar
:
:
SummarizeEvent
(
const
nsCString
&
aUniqueEventName
ProcessID
aProcessType
bool
aDynamic
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Only
summarize
events
in
the
parent
process
"
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
StaticMutexAutoLock
lock
(
gTelemetryScalarsMutex
)
;
ScalarKey
scalarKey
{
static_cast
<
uint32_t
>
(
ScalarID
:
:
TELEMETRY_EVENT_COUNTS
)
aDynamic
}
;
if
(
aDynamic
)
{
nsresult
rv
=
internal_GetEnumByScalarName
(
lock
nsAutoCString
(
"
telemetry
.
dynamic_event_counts
"
)
&
scalarKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
NS_FAILED
getting
ScalarKey
for
telemetry
.
dynamic_event_counts
"
)
;
return
;
}
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
lock
scalarKey
aProcessType
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
NS_FAILED
getting
keyed
scalar
for
event
summary
.
Wut
.
"
)
;
return
;
}
scalar
-
>
SetMaximumNumberOfKeys
(
kMaxEventSummaryKeys
)
;
scalar
-
>
AddValue
(
lock
NS_ConvertASCIItoUTF16
(
aUniqueEventName
)
1
)
;
}
void
TelemetryScalar
:
:
ClearScalars
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Scalars
should
only
be
cleared
in
the
parent
process
.
"
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gScalarStorageMap
.
Clear
(
)
;
gKeyedScalarStorageMap
.
Clear
(
)
;
gDynamicBuiltinScalarStorageMap
.
Clear
(
)
;
gDynamicBuiltinKeyedScalarStorageMap
.
Clear
(
)
;
gScalarsActions
=
nullptr
;
gKeyedScalarsActions
=
nullptr
;
}
size_t
TelemetryScalar
:
:
GetMapShallowSizesOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
return
gScalarNameIDMap
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
TelemetryScalar
:
:
GetScalarSizesOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
size_t
n
=
0
;
auto
getSizeOf
=
[
aMallocSizeOf
]
(
auto
&
storageMap
)
{
size_t
partial
=
0
;
for
(
const
auto
&
scalarStorage
:
storageMap
.
Values
(
)
)
{
for
(
const
auto
&
scalar
:
scalarStorage
-
>
Values
(
)
)
{
partial
+
=
scalar
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
return
partial
;
}
;
n
+
=
getSizeOf
(
gScalarStorageMap
)
;
n
+
=
getSizeOf
(
gKeyedScalarStorageMap
)
;
n
+
=
getSizeOf
(
gDynamicBuiltinScalarStorageMap
)
;
n
+
=
getSizeOf
(
gDynamicBuiltinKeyedScalarStorageMap
)
;
return
n
;
}
void
TelemetryScalar
:
:
UpdateChildData
(
ProcessID
aProcessType
const
nsTArray
<
mozilla
:
:
Telemetry
:
:
ScalarAction
>
&
aScalarActions
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
The
stored
child
processes
scalar
data
must
be
updated
from
the
"
"
parent
process
.
"
)
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
for
(
const
ScalarAction
&
action
:
aScalarActions
)
{
ScalarAction
copy
=
action
;
copy
.
mProcessType
=
aProcessType
;
internal_RecordScalarAction
(
locker
copy
)
;
}
return
;
}
internal_ApplyScalarActions
(
locker
aScalarActions
Some
(
aProcessType
)
)
;
}
void
TelemetryScalar
:
:
UpdateChildKeyedData
(
ProcessID
aProcessType
const
nsTArray
<
mozilla
:
:
Telemetry
:
:
KeyedScalarAction
>
&
aScalarActions
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
The
stored
child
processes
keyed
scalar
data
must
be
updated
"
"
from
the
parent
process
.
"
)
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
for
(
const
KeyedScalarAction
&
action
:
aScalarActions
)
{
KeyedScalarAction
copy
=
action
;
copy
.
mProcessType
=
aProcessType
;
internal_RecordKeyedScalarAction
(
locker
copy
)
;
}
return
;
}
internal_ApplyKeyedScalarActions
(
locker
aScalarActions
Some
(
aProcessType
)
)
;
}
void
TelemetryScalar
:
:
RecordDiscardedData
(
ProcessID
aProcessType
const
mozilla
:
:
Telemetry
:
:
DiscardedData
&
aDiscardedData
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Discarded
Data
must
be
updated
from
the
parent
process
.
"
)
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
!
internal_CanRecordBase
(
locker
)
)
{
return
;
}
if
(
GetCurrentProduct
(
)
=
=
SupportedProduct
:
:
GeckoviewStreaming
)
{
return
;
}
ScalarBase
*
scalar
=
nullptr
;
mozilla
:
:
DebugOnly
<
nsresult
>
rv
;
rv
=
internal_GetScalarByEnum
(
locker
ScalarKey
{
static_cast
<
uint32_t
>
(
ScalarID
:
:
TELEMETRY_DISCARDED_ACCUMULATIONS
)
false
}
aProcessType
&
scalar
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
scalar
-
>
AddValue
(
aDiscardedData
.
mDiscardedHistogramAccumulations
)
;
rv
=
internal_GetScalarByEnum
(
locker
ScalarKey
{
static_cast
<
uint32_t
>
(
ScalarID
:
:
TELEMETRY_DISCARDED_KEYED_ACCUMULATIONS
)
false
}
aProcessType
&
scalar
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
scalar
-
>
AddValue
(
aDiscardedData
.
mDiscardedKeyedHistogramAccumulations
)
;
rv
=
internal_GetScalarByEnum
(
locker
ScalarKey
{
static_cast
<
uint32_t
>
(
ScalarID
:
:
TELEMETRY_DISCARDED_SCALAR_ACTIONS
)
false
}
aProcessType
&
scalar
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
scalar
-
>
AddValue
(
aDiscardedData
.
mDiscardedScalarActions
)
;
rv
=
internal_GetScalarByEnum
(
locker
ScalarKey
{
static_cast
<
uint32_t
>
(
ScalarID
:
:
TELEMETRY_DISCARDED_KEYED_SCALAR_ACTIONS
)
false
}
aProcessType
&
scalar
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
scalar
-
>
AddValue
(
aDiscardedData
.
mDiscardedKeyedScalarActions
)
;
rv
=
internal_GetScalarByEnum
(
locker
ScalarKey
{
static_cast
<
uint32_t
>
(
ScalarID
:
:
TELEMETRY_DISCARDED_CHILD_EVENTS
)
false
}
aProcessType
&
scalar
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
scalar
-
>
AddValue
(
aDiscardedData
.
mDiscardedChildEvents
)
;
}
void
TelemetryScalar
:
:
GetDynamicScalarDefinitions
(
nsTArray
<
DynamicScalarDefinition
>
&
aDefArray
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
gDynamicScalarInfo
)
{
return
;
}
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
internal_DynamicScalarToIPC
(
locker
*
gDynamicScalarInfo
aDefArray
)
;
}
void
TelemetryScalar
:
:
AddDynamicScalarDefinitions
(
const
nsTArray
<
DynamicScalarDefinition
>
&
aDefs
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
nsTArray
<
DynamicScalarInfo
>
dynamicStubs
;
for
(
auto
&
def
:
aDefs
)
{
bool
recordOnRelease
=
def
.
dataset
=
=
nsITelemetry
:
:
DATASET_ALL_CHANNELS
;
dynamicStubs
.
AppendElement
(
DynamicScalarInfo
{
def
.
type
recordOnRelease
def
.
expired
def
.
name
def
.
keyed
def
.
builtin
{
}
}
)
;
}
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
internal_RegisterScalars
(
locker
dynamicStubs
)
;
}
}
nsresult
TelemetryScalar
:
:
GetAllStores
(
StringHashSet
&
set
)
{
for
(
uint32_t
storeIdx
:
gScalarStoresTable
)
{
const
char
*
name
=
&
gScalarsStringTable
[
storeIdx
]
;
nsAutoCString
store
;
store
.
AssignASCII
(
name
)
;
if
(
!
set
.
Insert
(
store
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_FAILURE
;
}
}
for
(
auto
&
ptr
:
*
gDynamicStoreNames
)
{
nsAutoCString
store
;
ptr
-
>
ToUTF8String
(
store
)
;
if
(
!
set
.
Insert
(
store
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
SerializeScalars
(
mozilla
:
:
JSONWriter
&
aWriter
)
{
ScalarSnapshotTable
scalarsToReflect
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
nsresult
rv
=
internal_GetScalarSnapshot
(
locker
scalarsToReflect
nsITelemetry
:
:
DATASET_PRERELEASE_CHANNELS
false
"
main
"
_ns
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
for
(
const
auto
&
entry
:
scalarsToReflect
)
{
const
ScalarTupleArray
&
processScalars
=
entry
.
GetData
(
)
;
const
char
*
processName
=
GetNameForProcessID
(
ProcessID
(
entry
.
GetKey
(
)
)
)
;
aWriter
.
StartObjectProperty
(
mozilla
:
:
MakeStringSpan
(
processName
)
)
;
for
(
const
ScalarDataTuple
&
scalar
:
processScalars
)
{
nsresult
rv
=
WriteVariantToJSONWriter
(
mozilla
:
:
Get
<
2
>
(
scalar
)
mozilla
:
:
Get
<
1
>
(
scalar
)
mozilla
:
:
MakeStringSpan
(
mozilla
:
:
Get
<
0
>
(
scalar
)
)
aWriter
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
}
aWriter
.
EndObject
(
)
;
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
SerializeKeyedScalars
(
mozilla
:
:
JSONWriter
&
aWriter
)
{
KeyedScalarSnapshotTable
keyedScalarsToReflect
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
nsresult
rv
=
internal_GetKeyedScalarSnapshot
(
locker
keyedScalarsToReflect
nsITelemetry
:
:
DATASET_PRERELEASE_CHANNELS
false
"
main
"
_ns
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
for
(
const
auto
&
entry
:
keyedScalarsToReflect
)
{
const
KeyedScalarTupleArray
&
processScalars
=
entry
.
GetData
(
)
;
const
char
*
processName
=
GetNameForProcessID
(
ProcessID
(
entry
.
GetKey
(
)
)
)
;
aWriter
.
StartObjectProperty
(
mozilla
:
:
MakeStringSpan
(
processName
)
)
;
for
(
const
KeyedScalarDataTuple
&
keyedScalarData
:
processScalars
)
{
aWriter
.
StartObjectProperty
(
mozilla
:
:
MakeStringSpan
(
mozilla
:
:
Get
<
0
>
(
keyedScalarData
)
)
)
;
const
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
&
keyProps
=
mozilla
:
:
Get
<
1
>
(
keyedScalarData
)
;
for
(
const
KeyedScalar
:
:
KeyValuePair
&
keyData
:
keyProps
)
{
nsresult
rv
=
WriteVariantToJSONWriter
(
mozilla
:
:
Get
<
2
>
(
keyedScalarData
)
keyData
.
second
PromiseFlatCString
(
keyData
.
first
)
aWriter
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
}
aWriter
.
EndObject
(
)
;
}
aWriter
.
EndObject
(
)
;
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
DeserializePersistedScalars
(
JSContext
*
aCx
JS
:
:
HandleValue
aData
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Only
load
scalars
in
the
parent
process
"
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_FAILURE
;
}
typedef
std
:
:
pair
<
nsCString
nsCOMPtr
<
nsIVariant
>
>
PersistedScalarPair
;
typedef
nsTArray
<
PersistedScalarPair
>
PersistedScalarArray
;
typedef
nsTHashMap
<
ProcessIDHashKey
PersistedScalarArray
>
PeristedScalarStorage
;
PeristedScalarStorage
scalarsToUpdate
;
JS
:
:
RootedObject
scalarDataObj
(
aCx
&
aData
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
processes
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
scalarDataObj
&
processes
)
)
{
JS_ClearPendingException
(
aCx
)
;
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedId
process
(
aCx
)
;
for
(
auto
&
processVal
:
processes
)
{
process
=
processVal
;
nsAutoJSString
processNameJS
;
if
(
!
processNameJS
.
init
(
aCx
process
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
NS_ConvertUTF16toUTF8
processName
(
processNameJS
)
;
ProcessID
processID
=
GetIDForProcessName
(
processName
.
get
(
)
)
;
if
(
processID
=
=
ProcessID
:
:
Count
)
{
NS_WARNING
(
nsPrintfCString
(
"
Failed
to
get
process
ID
for
%
s
"
processName
.
get
(
)
)
.
get
(
)
)
;
continue
;
}
JS
:
:
RootedValue
processData
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
scalarDataObj
process
&
processData
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
if
(
!
processData
.
isObject
(
)
)
{
continue
;
}
JS
:
:
RootedObject
processDataObj
(
aCx
&
processData
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
scalars
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
processDataObj
&
scalars
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
JS
:
:
RootedId
scalar
(
aCx
)
;
for
(
auto
&
scalarVal
:
scalars
)
{
scalar
=
scalarVal
;
nsAutoJSString
scalarName
;
if
(
!
scalarName
.
init
(
aCx
scalar
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
JS
:
:
RootedValue
scalarValue
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
processDataObj
scalar
&
scalarValue
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
if
(
scalarValue
.
isNullOrUndefined
(
)
)
{
continue
;
}
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
scalarValue
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
PersistedScalarArray
&
processScalars
=
scalarsToUpdate
.
LookupOrInsert
(
static_cast
<
uint32_t
>
(
processID
)
)
;
processScalars
.
AppendElement
(
std
:
:
make_pair
(
nsCString
(
NS_ConvertUTF16toUTF8
(
scalarName
)
)
unpackedVal
)
)
;
}
}
{
StaticMutexAutoLock
lock
(
gTelemetryScalarsMutex
)
;
for
(
const
auto
&
entry
:
scalarsToUpdate
)
{
const
PersistedScalarArray
&
processScalars
=
entry
.
GetData
(
)
;
for
(
PersistedScalarArray
:
:
size_type
i
=
0
;
i
<
processScalars
.
Length
(
)
;
i
+
+
)
{
mozilla
:
:
Unused
<
<
internal_UpdateScalar
(
lock
processScalars
[
i
]
.
first
ScalarActionType
:
:
eSet
processScalars
[
i
]
.
second
ProcessID
(
entry
.
GetKey
(
)
)
true
)
;
}
}
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
DeserializePersistedKeyedScalars
(
JSContext
*
aCx
JS
:
:
HandleValue
aData
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Only
load
scalars
in
the
parent
process
"
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_FAILURE
;
}
typedef
mozilla
:
:
Tuple
<
nsCString
nsString
nsCOMPtr
<
nsIVariant
>
>
PersistedKeyedScalarTuple
;
typedef
nsTArray
<
PersistedKeyedScalarTuple
>
PersistedKeyedScalarArray
;
typedef
nsTHashMap
<
ProcessIDHashKey
PersistedKeyedScalarArray
>
PeristedKeyedScalarStorage
;
PeristedKeyedScalarStorage
scalarsToUpdate
;
JS
:
:
RootedObject
scalarDataObj
(
aCx
&
aData
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
processes
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
scalarDataObj
&
processes
)
)
{
JS_ClearPendingException
(
aCx
)
;
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedId
process
(
aCx
)
;
for
(
auto
&
processVal
:
processes
)
{
process
=
processVal
;
nsAutoJSString
processNameJS
;
if
(
!
processNameJS
.
init
(
aCx
process
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
NS_ConvertUTF16toUTF8
processName
(
processNameJS
)
;
ProcessID
processID
=
GetIDForProcessName
(
processName
.
get
(
)
)
;
if
(
processID
=
=
ProcessID
:
:
Count
)
{
NS_WARNING
(
nsPrintfCString
(
"
Failed
to
get
process
ID
for
%
s
"
processName
.
get
(
)
)
.
get
(
)
)
;
continue
;
}
JS
:
:
RootedValue
processData
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
scalarDataObj
process
&
processData
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
if
(
!
processData
.
isObject
(
)
)
{
continue
;
}
JS
:
:
RootedObject
processDataObj
(
aCx
&
processData
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
keyedScalars
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
processDataObj
&
keyedScalars
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
JS
:
:
RootedId
keyedScalar
(
aCx
)
;
for
(
auto
&
keyedScalarVal
:
keyedScalars
)
{
keyedScalar
=
keyedScalarVal
;
nsAutoJSString
scalarName
;
if
(
!
scalarName
.
init
(
aCx
keyedScalar
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
JS
:
:
RootedValue
keyedScalarData
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
processDataObj
keyedScalar
&
keyedScalarData
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
if
(
!
keyedScalarData
.
isObject
(
)
)
{
continue
;
}
JS
:
:
RootedObject
keyedScalarDataObj
(
aCx
&
keyedScalarData
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
keys
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
keyedScalarDataObj
&
keys
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
JS
:
:
RootedId
key
(
aCx
)
;
for
(
auto
keyVal
:
keys
)
{
key
=
keyVal
;
nsAutoJSString
keyName
;
if
(
!
keyName
.
init
(
aCx
key
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
JS
:
:
RootedValue
scalarValue
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
keyedScalarDataObj
key
&
scalarValue
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
if
(
scalarValue
.
isNullOrUndefined
(
)
)
{
continue
;
}
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
scalarValue
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
PersistedKeyedScalarArray
&
processScalars
=
scalarsToUpdate
.
LookupOrInsert
(
static_cast
<
uint32_t
>
(
processID
)
)
;
processScalars
.
AppendElement
(
mozilla
:
:
MakeTuple
(
nsCString
(
NS_ConvertUTF16toUTF8
(
scalarName
)
)
nsString
(
keyName
)
unpackedVal
)
)
;
}
}
}
{
StaticMutexAutoLock
lock
(
gTelemetryScalarsMutex
)
;
for
(
const
auto
&
entry
:
scalarsToUpdate
)
{
const
PersistedKeyedScalarArray
&
processScalars
=
entry
.
GetData
(
)
;
for
(
PersistedKeyedScalarArray
:
:
size_type
i
=
0
;
i
<
processScalars
.
Length
(
)
;
i
+
+
)
{
mozilla
:
:
Unused
<
<
internal_UpdateKeyedScalar
(
lock
mozilla
:
:
Get
<
0
>
(
processScalars
[
i
]
)
mozilla
:
:
Get
<
1
>
(
processScalars
[
i
]
)
ScalarActionType
:
:
eSet
mozilla
:
:
Get
<
2
>
(
processScalars
[
i
]
)
ProcessID
(
entry
.
GetKey
(
)
)
true
)
;
}
}
}
return
NS_OK
;
}
