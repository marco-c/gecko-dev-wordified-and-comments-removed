#
include
"
TelemetryScalar
.
h
"
#
include
"
ipc
/
TelemetryComms
.
h
"
#
include
"
ipc
/
TelemetryIPCAccumulator
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
PContent
.
h
"
#
include
"
mozilla
/
JSONWriter
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsITelemetry
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
TelemetryCommon
.
h
"
#
include
"
TelemetryScalarData
.
h
"
using
mozilla
:
:
Preferences
;
using
mozilla
:
:
StaticAutoPtr
;
using
mozilla
:
:
StaticMutex
;
using
mozilla
:
:
StaticMutexNotRecorded
;
using
mozilla
:
:
StaticMutexAutoLock
;
using
mozilla
:
:
Some
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
AutoHashtable
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsExpiredVersion
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
CanRecordDataset
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
CanRecordProduct
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsInDataset
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
LogToBrowserConsole
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
GetNameForProcessID
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
GetIDForProcessName
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
RecordedProcessType
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsValidIdentifierString
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
GetCurrentProduct
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
SupportedProduct
;
using
mozilla
:
:
Telemetry
:
:
ScalarActionType
;
using
mozilla
:
:
Telemetry
:
:
ScalarAction
;
using
mozilla
:
:
Telemetry
:
:
KeyedScalarAction
;
using
mozilla
:
:
Telemetry
:
:
ScalarID
;
using
mozilla
:
:
Telemetry
:
:
DynamicScalarDefinition
;
using
mozilla
:
:
Telemetry
:
:
ScalarVariant
;
using
mozilla
:
:
Telemetry
:
:
ProcessID
;
namespace
TelemetryIPCAccumulator
=
mozilla
:
:
TelemetryIPCAccumulator
;
namespace
{
const
uint32_t
kMaximumNumberOfKeys
=
100
;
const
uint32_t
kMaximumKeyStringLength
=
72
;
const
uint32_t
kMaximumStringValueLength
=
50
;
const
uint32_t
kMaximumCategoryNameLength
=
40
;
const
uint32_t
kMaximumScalarNameLength
=
40
;
const
uint32_t
kScalarCount
=
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
ScalarCount
)
;
const
size_t
kScalarActionsArrayHighWaterMark
=
10000
;
const
char
*
TEST_SCALAR_PREFIX
=
"
telemetry
.
test
.
"
;
enum
class
ScalarResult
:
uint8_t
{
Ok
NotInitialized
CannotUnpackVariant
CannotRecordInProcess
CannotRecordDataset
KeyedTypeMismatch
UnknownScalar
OperationNotSupported
InvalidType
InvalidValue
KeyIsEmpty
KeyTooLong
TooManyKeys
StringTooLong
UnsignedNegativeValue
UnsignedTruncatedValue
}
;
struct
ScalarKey
{
uint32_t
id
;
bool
dynamic
;
}
;
struct
DynamicScalarInfo
:
BaseScalarInfo
{
nsCString
mDynamicName
;
bool
mDynamicExpiration
;
DynamicScalarInfo
(
uint32_t
aKind
bool
aRecordOnRelease
bool
aExpired
const
nsACString
&
aName
bool
aKeyed
bool
aBuiltin
)
:
BaseScalarInfo
(
aKind
aRecordOnRelease
?
nsITelemetry
:
:
DATASET_RELEASE_CHANNEL_OPTOUT
:
nsITelemetry
:
:
DATASET_RELEASE_CHANNEL_OPTIN
RecordedProcessType
:
:
All
aKeyed
GetCurrentProduct
(
)
aBuiltin
)
mDynamicName
(
aName
)
mDynamicExpiration
(
aExpired
)
{
}
const
char
*
name
(
)
const
override
;
const
char
*
expiration
(
)
const
override
;
}
;
const
char
*
DynamicScalarInfo
:
:
name
(
)
const
{
return
mDynamicName
.
get
(
)
;
}
const
char
*
DynamicScalarInfo
:
:
expiration
(
)
const
{
return
mDynamicExpiration
?
"
1
.
0
"
:
"
never
"
;
}
typedef
nsBaseHashtableET
<
nsDepCharHashKey
ScalarKey
>
CharPtrEntryType
;
typedef
AutoHashtable
<
CharPtrEntryType
>
ScalarMapType
;
StaticAutoPtr
<
nsTArray
<
DynamicScalarInfo
>
>
gDynamicScalarInfo
;
const
BaseScalarInfo
&
internal_GetScalarInfo
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
)
{
if
(
!
aId
.
dynamic
)
{
return
gScalars
[
aId
.
id
]
;
}
return
(
*
gDynamicScalarInfo
)
[
aId
.
id
]
;
}
bool
IsValidEnumId
(
mozilla
:
:
Telemetry
:
:
ScalarID
aID
)
{
return
aID
<
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
ScalarCount
;
}
bool
internal_IsValidId
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
)
{
return
aId
.
dynamic
?
(
aId
.
id
<
gDynamicScalarInfo
-
>
Length
(
)
)
:
IsValidEnumId
(
static_cast
<
mozilla
:
:
Telemetry
:
:
ScalarID
>
(
aId
.
id
)
)
;
}
ScalarResult
GetVariantFromIVariant
(
nsIVariant
*
aInput
uint32_t
aScalarKind
mozilla
:
:
Maybe
<
ScalarVariant
>
&
aOutput
)
{
switch
(
aScalarKind
)
{
case
nsITelemetry
:
:
SCALAR_TYPE_COUNT
:
{
uint32_t
val
=
0
;
nsresult
rv
=
aInput
-
>
GetAsUint32
(
&
val
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
CannotUnpackVariant
;
}
aOutput
=
mozilla
:
:
Some
(
mozilla
:
:
AsVariant
(
val
)
)
;
break
;
}
case
nsITelemetry
:
:
SCALAR_TYPE_STRING
:
{
nsString
val
;
nsresult
rv
=
aInput
-
>
GetAsAString
(
val
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
CannotUnpackVariant
;
}
aOutput
=
mozilla
:
:
Some
(
mozilla
:
:
AsVariant
(
val
)
)
;
break
;
}
case
nsITelemetry
:
:
SCALAR_TYPE_BOOLEAN
:
{
bool
val
=
false
;
nsresult
rv
=
aInput
-
>
GetAsBool
(
&
val
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
CannotUnpackVariant
;
}
aOutput
=
mozilla
:
:
Some
(
mozilla
:
:
AsVariant
(
val
)
)
;
break
;
}
default
:
MOZ_ASSERT
(
false
"
Unknown
scalar
kind
.
"
)
;
return
ScalarResult
:
:
UnknownScalar
;
}
return
ScalarResult
:
:
Ok
;
}
nsresult
WriteVariantToJSONWriter
(
uint32_t
aScalarType
nsIVariant
*
aInputValue
const
char
*
aPropertyName
mozilla
:
:
JSONWriter
&
aWriter
)
{
MOZ_ASSERT
(
aInputValue
)
;
switch
(
aScalarType
)
{
case
nsITelemetry
:
:
SCALAR_TYPE_COUNT
:
{
uint32_t
val
=
0
;
nsresult
rv
=
aInputValue
-
>
GetAsUint32
(
&
val
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aWriter
.
IntProperty
(
aPropertyName
val
)
;
break
;
}
case
nsITelemetry
:
:
SCALAR_TYPE_STRING
:
{
nsCString
val
;
nsresult
rv
=
aInputValue
-
>
GetAsACString
(
val
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aWriter
.
StringProperty
(
aPropertyName
val
.
get
(
)
)
;
break
;
}
case
nsITelemetry
:
:
SCALAR_TYPE_BOOLEAN
:
{
bool
val
=
false
;
nsresult
rv
=
aInputValue
-
>
GetAsBool
(
&
val
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aWriter
.
BoolProperty
(
aPropertyName
val
)
;
break
;
}
default
:
MOZ_ASSERT
(
false
"
Unknown
scalar
kind
.
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
const
char
*
ScalarInfo
:
:
name
(
)
const
{
return
&
gScalarsStringTable
[
this
-
>
name_offset
]
;
}
const
char
*
ScalarInfo
:
:
expiration
(
)
const
{
return
&
gScalarsStringTable
[
this
-
>
expiration_offset
]
;
}
class
ScalarBase
{
public
:
explicit
ScalarBase
(
const
BaseScalarInfo
&
aInfo
)
:
mStoreCount
(
aInfo
.
storeCount
(
)
)
mStoreOffset
(
aInfo
.
storeOffset
(
)
)
mStoreHasValue
(
mStoreCount
)
{
mStoreHasValue
.
SetLength
(
mStoreCount
)
;
for
(
auto
&
val
:
mStoreHasValue
)
{
val
=
false
;
}
}
;
virtual
~
ScalarBase
(
)
=
default
;
virtual
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
=
0
;
virtual
ScalarResult
AddValue
(
nsIVariant
*
aValue
)
{
return
ScalarResult
:
:
OperationNotSupported
;
}
virtual
ScalarResult
SetMaximum
(
nsIVariant
*
aValue
)
{
return
ScalarResult
:
:
OperationNotSupported
;
}
virtual
void
SetValue
(
uint32_t
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
ScalarResult
SetValue
(
const
nsAString
&
aValue
)
{
return
HandleUnsupported
(
)
;
}
virtual
void
SetValue
(
bool
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
void
AddValue
(
uint32_t
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
void
SetMaximum
(
uint32_t
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
nsresult
GetValue
(
const
nsACString
&
aStoreName
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
=
0
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
virtual
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
=
0
;
protected
:
bool
HasValueInStore
(
size_t
aStoreIndex
)
const
;
void
ClearValueInStore
(
size_t
aStoreIndex
)
;
void
SetValueInStores
(
)
;
nsresult
StoreIndex
(
const
nsACString
&
aStoreName
size_t
*
aStoreIndex
)
const
;
private
:
ScalarResult
HandleUnsupported
(
)
const
;
const
uint32_t
mStoreCount
;
const
uint16_t
mStoreOffset
;
nsTArray
<
bool
>
mStoreHasValue
;
}
;
ScalarResult
ScalarBase
:
:
HandleUnsupported
(
)
const
{
MOZ_ASSERT
(
false
"
This
operation
is
not
support
for
this
scalar
type
.
"
)
;
return
ScalarResult
:
:
OperationNotSupported
;
}
bool
ScalarBase
:
:
HasValueInStore
(
size_t
aStoreIndex
)
const
{
MOZ_ASSERT
(
aStoreIndex
<
mStoreHasValue
.
Length
(
)
"
Invalid
scalar
store
index
.
"
)
;
return
mStoreHasValue
[
aStoreIndex
]
;
}
void
ScalarBase
:
:
ClearValueInStore
(
size_t
aStoreIndex
)
{
MOZ_ASSERT
(
aStoreIndex
<
mStoreHasValue
.
Length
(
)
"
Invalid
scalar
store
index
to
clear
.
"
)
;
mStoreHasValue
[
aStoreIndex
]
=
false
;
}
void
ScalarBase
:
:
SetValueInStores
(
)
{
for
(
auto
&
val
:
mStoreHasValue
)
{
val
=
true
;
}
}
nsresult
ScalarBase
:
:
StoreIndex
(
const
nsACString
&
aStoreName
size_t
*
aStoreIndex
)
const
{
if
(
mStoreCount
=
=
1
&
&
mStoreOffset
=
=
UINT16_MAX
)
{
if
(
aStoreName
.
EqualsLiteral
(
"
main
"
)
)
{
*
aStoreIndex
=
0
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
for
(
uint32_t
i
=
0
;
i
<
mStoreCount
;
+
+
i
)
{
uint32_t
stringIndex
=
gScalarStoresTable
[
mStoreOffset
+
i
]
;
if
(
aStoreName
.
EqualsASCII
(
&
gScalarsStringTable
[
stringIndex
]
)
)
{
*
aStoreIndex
=
i
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
size_t
ScalarBase
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
mStoreHasValue
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
class
ScalarUnsigned
:
public
ScalarBase
{
public
:
using
ScalarBase
:
:
SetValue
;
ScalarUnsigned
(
const
BaseScalarInfo
&
aInfo
)
:
ScalarBase
(
aInfo
)
mStorage
(
0
)
{
}
;
~
ScalarUnsigned
(
)
override
=
default
;
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
final
;
void
SetValue
(
uint32_t
aValue
)
final
;
ScalarResult
AddValue
(
nsIVariant
*
aValue
)
final
;
void
AddValue
(
uint32_t
aValue
)
final
;
ScalarResult
SetMaximum
(
nsIVariant
*
aValue
)
final
;
void
SetMaximum
(
uint32_t
aValue
)
final
;
nsresult
GetValue
(
const
nsACString
&
aStoreName
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
final
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
final
;
private
:
uint32_t
mStorage
;
ScalarResult
CheckInput
(
nsIVariant
*
aValue
)
;
ScalarUnsigned
(
const
ScalarUnsigned
&
aOther
)
=
delete
;
void
operator
=
(
const
ScalarUnsigned
&
aOther
)
=
delete
;
}
;
ScalarResult
ScalarUnsigned
:
:
SetValue
(
nsIVariant
*
aValue
)
{
ScalarResult
sr
=
CheckInput
(
aValue
)
;
if
(
sr
=
=
ScalarResult
:
:
UnsignedNegativeValue
)
{
return
sr
;
}
if
(
NS_FAILED
(
aValue
-
>
GetAsUint32
(
&
mStorage
)
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
return
sr
;
}
void
ScalarUnsigned
:
:
SetValue
(
uint32_t
aValue
)
{
mStorage
=
aValue
;
}
ScalarResult
ScalarUnsigned
:
:
AddValue
(
nsIVariant
*
aValue
)
{
ScalarResult
sr
=
CheckInput
(
aValue
)
;
if
(
sr
=
=
ScalarResult
:
:
UnsignedNegativeValue
)
{
return
sr
;
}
uint32_t
newAddend
=
0
;
nsresult
rv
=
aValue
-
>
GetAsUint32
(
&
newAddend
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
mStorage
+
=
newAddend
;
return
sr
;
}
void
ScalarUnsigned
:
:
AddValue
(
uint32_t
aValue
)
{
mStorage
+
=
aValue
;
}
ScalarResult
ScalarUnsigned
:
:
SetMaximum
(
nsIVariant
*
aValue
)
{
ScalarResult
sr
=
CheckInput
(
aValue
)
;
if
(
sr
=
=
ScalarResult
:
:
UnsignedNegativeValue
)
{
return
sr
;
}
uint32_t
newValue
=
0
;
nsresult
rv
=
aValue
-
>
GetAsUint32
(
&
newValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
if
(
newValue
>
mStorage
)
{
mStorage
=
newValue
;
}
return
sr
;
}
void
ScalarUnsigned
:
:
SetMaximum
(
uint32_t
aValue
)
{
if
(
aValue
>
mStorage
)
{
mStorage
=
aValue
;
}
}
nsresult
ScalarUnsigned
:
:
GetValue
(
const
nsACString
&
aStoreName
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
{
nsCOMPtr
<
nsIWritableVariant
>
outVar
(
new
nsVariant
(
)
)
;
nsresult
rv
=
outVar
-
>
SetAsUint32
(
mStorage
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aResult
=
outVar
.
forget
(
)
;
return
NS_OK
;
}
size_t
ScalarUnsigned
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
;
}
ScalarResult
ScalarUnsigned
:
:
CheckInput
(
nsIVariant
*
aValue
)
{
uint16_t
type
=
aValue
-
>
GetDataType
(
)
;
if
(
type
=
=
nsIDataType
:
:
VTYPE_FLOAT
|
|
type
=
=
nsIDataType
:
:
VTYPE_DOUBLE
)
{
return
ScalarResult
:
:
UnsignedTruncatedValue
;
}
int32_t
signedTest
;
if
(
NS_SUCCEEDED
(
aValue
-
>
GetAsInt32
(
&
signedTest
)
)
&
&
signedTest
<
0
)
{
return
ScalarResult
:
:
UnsignedNegativeValue
;
}
return
ScalarResult
:
:
Ok
;
}
class
ScalarString
:
public
ScalarBase
{
public
:
using
ScalarBase
:
:
SetValue
;
ScalarString
(
const
BaseScalarInfo
&
aInfo
)
:
ScalarBase
(
aInfo
)
mStorage
(
EmptyString
(
)
)
{
}
;
~
ScalarString
(
)
override
=
default
;
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
final
;
ScalarResult
SetValue
(
const
nsAString
&
aValue
)
final
;
nsresult
GetValue
(
const
nsACString
&
aStoreName
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
final
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
final
;
private
:
nsString
mStorage
;
ScalarString
(
const
ScalarString
&
aOther
)
=
delete
;
void
operator
=
(
const
ScalarString
&
aOther
)
=
delete
;
}
;
ScalarResult
ScalarString
:
:
SetValue
(
nsIVariant
*
aValue
)
{
uint16_t
type
=
aValue
-
>
GetDataType
(
)
;
if
(
type
!
=
nsIDataType
:
:
VTYPE_CHAR
&
&
type
!
=
nsIDataType
:
:
VTYPE_WCHAR
&
&
type
!
=
nsIDataType
:
:
VTYPE_CHAR_STR
&
&
type
!
=
nsIDataType
:
:
VTYPE_WCHAR_STR
&
&
type
!
=
nsIDataType
:
:
VTYPE_STRING_SIZE_IS
&
&
type
!
=
nsIDataType
:
:
VTYPE_WSTRING_SIZE_IS
&
&
type
!
=
nsIDataType
:
:
VTYPE_UTF8STRING
&
&
type
!
=
nsIDataType
:
:
VTYPE_CSTRING
&
&
type
!
=
nsIDataType
:
:
VTYPE_ASTRING
)
{
return
ScalarResult
:
:
InvalidType
;
}
nsAutoString
convertedString
;
nsresult
rv
=
aValue
-
>
GetAsAString
(
convertedString
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
return
SetValue
(
convertedString
)
;
}
;
ScalarResult
ScalarString
:
:
SetValue
(
const
nsAString
&
aValue
)
{
mStorage
=
Substring
(
aValue
0
kMaximumStringValueLength
)
;
if
(
aValue
.
Length
(
)
>
kMaximumStringValueLength
)
{
return
ScalarResult
:
:
StringTooLong
;
}
return
ScalarResult
:
:
Ok
;
}
nsresult
ScalarString
:
:
GetValue
(
const
nsACString
&
aStoreName
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
{
nsCOMPtr
<
nsIWritableVariant
>
outVar
(
new
nsVariant
(
)
)
;
nsresult
rv
=
outVar
-
>
SetAsAString
(
mStorage
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aResult
=
outVar
.
forget
(
)
;
return
NS_OK
;
}
size_t
ScalarString
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mStorage
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
return
n
;
}
class
ScalarBoolean
:
public
ScalarBase
{
public
:
using
ScalarBase
:
:
SetValue
;
ScalarBoolean
(
const
BaseScalarInfo
&
aInfo
)
:
ScalarBase
(
aInfo
)
mStorage
(
false
)
{
}
;
~
ScalarBoolean
(
)
override
=
default
;
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
final
;
void
SetValue
(
bool
aValue
)
final
;
nsresult
GetValue
(
const
nsACString
&
aStoreName
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
final
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
final
;
private
:
bool
mStorage
;
ScalarBoolean
(
const
ScalarBoolean
&
aOther
)
=
delete
;
void
operator
=
(
const
ScalarBoolean
&
aOther
)
=
delete
;
}
;
ScalarResult
ScalarBoolean
:
:
SetValue
(
nsIVariant
*
aValue
)
{
uint16_t
type
=
aValue
-
>
GetDataType
(
)
;
if
(
type
!
=
nsIDataType
:
:
VTYPE_BOOL
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT8
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT16
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT32
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT64
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT8
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT16
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT32
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT64
)
{
return
ScalarResult
:
:
InvalidType
;
}
if
(
NS_FAILED
(
aValue
-
>
GetAsBool
(
&
mStorage
)
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
return
ScalarResult
:
:
Ok
;
}
;
void
ScalarBoolean
:
:
SetValue
(
bool
aValue
)
{
mStorage
=
aValue
;
}
nsresult
ScalarBoolean
:
:
GetValue
(
const
nsACString
&
aStoreName
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
{
nsCOMPtr
<
nsIWritableVariant
>
outVar
(
new
nsVariant
(
)
)
;
nsresult
rv
=
outVar
-
>
SetAsBool
(
mStorage
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aResult
=
outVar
.
forget
(
)
;
return
NS_OK
;
}
size_t
ScalarBoolean
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
;
}
ScalarBase
*
internal_ScalarAllocate
(
const
BaseScalarInfo
&
aInfo
)
{
ScalarBase
*
scalar
=
nullptr
;
switch
(
aInfo
.
kind
)
{
case
nsITelemetry
:
:
SCALAR_TYPE_COUNT
:
scalar
=
new
ScalarUnsigned
(
aInfo
)
;
break
;
case
nsITelemetry
:
:
SCALAR_TYPE_STRING
:
scalar
=
new
ScalarString
(
aInfo
)
;
break
;
case
nsITelemetry
:
:
SCALAR_TYPE_BOOLEAN
:
scalar
=
new
ScalarBoolean
(
aInfo
)
;
break
;
default
:
MOZ_ASSERT
(
false
"
Invalid
scalar
type
"
)
;
}
return
scalar
;
}
class
KeyedScalar
{
public
:
typedef
mozilla
:
:
Pair
<
nsCString
nsCOMPtr
<
nsIVariant
>
>
KeyValuePair
;
explicit
KeyedScalar
(
const
BaseScalarInfo
&
info
)
:
mScalarInfo
(
info
)
mMaximumNumberOfKeys
(
kMaximumNumberOfKeys
)
{
}
;
~
KeyedScalar
(
)
=
default
;
ScalarResult
SetValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
nsIVariant
*
aValue
)
;
ScalarResult
AddValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
nsIVariant
*
aValue
)
;
ScalarResult
SetMaximum
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
nsIVariant
*
aValue
)
;
void
SetValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
uint32_t
aValue
)
;
void
SetValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
bool
aValue
)
;
void
AddValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
uint32_t
aValue
)
;
void
SetMaximum
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
uint32_t
aValue
)
;
nsresult
GetValue
(
const
nsACString
&
aStoreName
nsTArray
<
KeyValuePair
>
&
aValues
)
const
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
;
void
SetMaximumNumberOfKeys
(
uint32_t
aMaximumNumberOfKeys
)
{
mMaximumNumberOfKeys
=
aMaximumNumberOfKeys
;
}
;
private
:
typedef
nsClassHashtable
<
nsCStringHashKey
ScalarBase
>
ScalarKeysMapType
;
ScalarKeysMapType
mScalarKeys
;
const
BaseScalarInfo
&
mScalarInfo
;
uint32_t
mMaximumNumberOfKeys
;
ScalarResult
GetScalarForKey
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
ScalarBase
*
*
aRet
)
;
}
;
ScalarResult
KeyedScalar
:
:
SetValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
nsIVariant
*
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
return
sr
;
}
return
scalar
-
>
SetValue
(
aValue
)
;
}
ScalarResult
KeyedScalar
:
:
AddValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
nsIVariant
*
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
return
sr
;
}
return
scalar
-
>
AddValue
(
aValue
)
;
}
ScalarResult
KeyedScalar
:
:
SetMaximum
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
nsIVariant
*
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
return
sr
;
}
return
scalar
-
>
SetMaximum
(
aValue
)
;
}
void
KeyedScalar
:
:
SetValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
uint32_t
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
!
=
ScalarResult
:
:
TooManyKeys
)
{
MOZ_ASSERT
(
false
"
Key
too
long
to
be
recorded
in
the
scalar
.
"
)
;
}
return
;
}
return
scalar
-
>
SetValue
(
aValue
)
;
}
void
KeyedScalar
:
:
SetValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
bool
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
!
=
ScalarResult
:
:
TooManyKeys
)
{
MOZ_ASSERT
(
false
"
Key
too
long
to
be
recorded
in
the
scalar
.
"
)
;
}
return
;
}
return
scalar
-
>
SetValue
(
aValue
)
;
}
void
KeyedScalar
:
:
AddValue
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
uint32_t
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
!
=
ScalarResult
:
:
TooManyKeys
)
{
MOZ_ASSERT
(
false
"
Key
too
long
to
be
recorded
in
the
scalar
.
"
)
;
}
return
;
}
return
scalar
-
>
AddValue
(
aValue
)
;
}
void
KeyedScalar
:
:
SetMaximum
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
uint32_t
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
locker
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
!
=
ScalarResult
:
:
TooManyKeys
)
{
MOZ_ASSERT
(
false
"
Key
too
long
to
be
recorded
in
the
scalar
.
"
)
;
}
return
;
}
return
scalar
-
>
SetMaximum
(
aValue
)
;
}
nsresult
KeyedScalar
:
:
GetValue
(
const
nsACString
&
aStoreName
nsTArray
<
KeyValuePair
>
&
aValues
)
const
{
for
(
auto
iter
=
mScalarKeys
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarBase
*
scalar
=
static_cast
<
ScalarBase
*
>
(
iter
.
Data
(
)
)
;
nsCOMPtr
<
nsIVariant
>
scalarValue
;
nsresult
rv
=
scalar
-
>
GetValue
(
aStoreName
scalarValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aValues
.
AppendElement
(
mozilla
:
:
MakePair
(
nsCString
(
iter
.
Key
(
)
)
scalarValue
)
)
;
}
return
NS_OK
;
}
nsresult
internal_GetKeyedScalarByEnum
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
ProcessID
aProcessStorage
KeyedScalar
*
*
aRet
)
;
ScalarResult
KeyedScalar
:
:
GetScalarForKey
(
const
StaticMutexAutoLock
&
locker
const
nsAString
&
aKey
ScalarBase
*
*
aRet
)
{
if
(
aKey
.
IsEmpty
(
)
)
{
return
ScalarResult
:
:
KeyIsEmpty
;
}
if
(
aKey
.
Length
(
)
>
kMaximumKeyStringLength
)
{
return
ScalarResult
:
:
KeyTooLong
;
}
NS_ConvertUTF16toUTF8
utf8Key
(
aKey
)
;
ScalarBase
*
scalar
=
nullptr
;
if
(
mScalarKeys
.
Get
(
utf8Key
&
scalar
)
)
{
*
aRet
=
scalar
;
return
ScalarResult
:
:
Ok
;
}
if
(
mScalarKeys
.
Count
(
)
>
=
mMaximumNumberOfKeys
)
{
if
(
aKey
.
EqualsLiteral
(
"
telemetry
.
keyed_scalars_exceed_limit
"
)
)
{
return
ScalarResult
:
:
TooManyKeys
;
}
KeyedScalar
*
scalarExceed
=
nullptr
;
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
TELEMETRY_KEYED_SCALARS_EXCEED_LIMIT
)
false
}
;
ProcessID
process
=
ProcessID
:
:
Parent
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
locker
uniqueId
process
&
scalarExceed
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
TooManyKeys
;
}
scalarExceed
-
>
AddValue
(
locker
NS_ConvertUTF8toUTF16
(
mScalarInfo
.
name
(
)
)
1
)
;
return
ScalarResult
:
:
TooManyKeys
;
}
scalar
=
internal_ScalarAllocate
(
mScalarInfo
)
;
if
(
!
scalar
)
{
return
ScalarResult
:
:
InvalidType
;
}
mScalarKeys
.
Put
(
utf8Key
scalar
)
;
*
aRet
=
scalar
;
return
ScalarResult
:
:
Ok
;
}
size_t
KeyedScalar
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
this
)
;
for
(
auto
iter
=
mScalarKeys
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarBase
*
scalar
=
static_cast
<
ScalarBase
*
>
(
iter
.
Data
(
)
)
;
n
+
=
scalar
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
typedef
nsUint32HashKey
ScalarIDHashKey
;
typedef
nsUint32HashKey
ProcessIDHashKey
;
typedef
nsClassHashtable
<
ScalarIDHashKey
ScalarBase
>
ScalarStorageMapType
;
typedef
nsClassHashtable
<
ScalarIDHashKey
KeyedScalar
>
KeyedScalarStorageMapType
;
typedef
nsClassHashtable
<
ProcessIDHashKey
ScalarStorageMapType
>
ProcessesScalarsMapType
;
typedef
nsClassHashtable
<
ProcessIDHashKey
KeyedScalarStorageMapType
>
ProcessesKeyedScalarsMapType
;
typedef
mozilla
:
:
Tuple
<
const
char
*
nsCOMPtr
<
nsIVariant
>
uint32_t
>
ScalarDataTuple
;
typedef
nsTArray
<
ScalarDataTuple
>
ScalarTupleArray
;
typedef
nsDataHashtable
<
ProcessIDHashKey
ScalarTupleArray
>
ScalarSnapshotTable
;
typedef
mozilla
:
:
Tuple
<
const
char
*
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
uint32_t
>
KeyedScalarDataTuple
;
typedef
nsTArray
<
KeyedScalarDataTuple
>
KeyedScalarTupleArray
;
typedef
nsDataHashtable
<
ProcessIDHashKey
KeyedScalarTupleArray
>
KeyedScalarSnapshotTable
;
}
namespace
{
bool
gInitDone
=
false
;
bool
gCanRecordBase
;
bool
gCanRecordExtended
;
ScalarMapType
gScalarNameIDMap
(
kScalarCount
)
;
ProcessesScalarsMapType
gScalarStorageMap
;
ProcessesKeyedScalarsMapType
gKeyedScalarStorageMap
;
ProcessesScalarsMapType
gDynamicBuiltinScalarStorageMap
;
ProcessesKeyedScalarsMapType
gDynamicBuiltinKeyedScalarStorageMap
;
bool
gIsDeserializing
=
false
;
StaticAutoPtr
<
nsTArray
<
ScalarAction
>
>
gScalarsActions
;
StaticAutoPtr
<
nsTArray
<
KeyedScalarAction
>
>
gKeyedScalarsActions
;
bool
internal_IsScalarDeserializing
(
const
StaticMutexAutoLock
&
lock
)
{
return
gIsDeserializing
;
}
}
namespace
{
void
internal_LogScalarError
(
const
nsACString
&
aScalarName
ScalarResult
aSr
)
{
nsAutoString
errorMessage
;
AppendUTF8toUTF16
(
aScalarName
errorMessage
)
;
switch
(
aSr
)
{
case
ScalarResult
:
:
NotInitialized
:
errorMessage
.
AppendLiteral
(
u
"
-
Telemetry
was
not
yet
initialized
.
"
)
;
break
;
case
ScalarResult
:
:
CannotUnpackVariant
:
errorMessage
.
AppendLiteral
(
u
"
-
Cannot
convert
the
provided
JS
value
to
nsIVariant
.
"
)
;
break
;
case
ScalarResult
:
:
CannotRecordInProcess
:
errorMessage
.
AppendLiteral
(
u
"
-
Cannot
record
the
scalar
in
the
current
process
.
"
)
;
break
;
case
ScalarResult
:
:
KeyedTypeMismatch
:
errorMessage
.
AppendLiteral
(
u
"
-
Attempting
to
manage
a
keyed
scalar
as
a
scalar
(
or
vice
-
versa
)
.
"
)
;
break
;
case
ScalarResult
:
:
UnknownScalar
:
errorMessage
.
AppendLiteral
(
u
"
-
Unknown
scalar
.
"
)
;
break
;
case
ScalarResult
:
:
OperationNotSupported
:
errorMessage
.
AppendLiteral
(
u
"
-
The
requested
operation
is
not
supported
on
this
scalar
.
"
)
;
break
;
case
ScalarResult
:
:
InvalidType
:
errorMessage
.
AppendLiteral
(
u
"
-
Attempted
to
set
the
scalar
to
an
invalid
data
type
.
"
)
;
break
;
case
ScalarResult
:
:
InvalidValue
:
errorMessage
.
AppendLiteral
(
u
"
-
Attempted
to
set
the
scalar
to
an
incompatible
value
.
"
)
;
break
;
case
ScalarResult
:
:
StringTooLong
:
AppendUTF8toUTF16
(
nsPrintfCString
(
"
-
Truncating
scalar
value
to
%
d
characters
.
"
kMaximumStringValueLength
)
errorMessage
)
;
break
;
case
ScalarResult
:
:
KeyIsEmpty
:
errorMessage
.
AppendLiteral
(
u
"
-
The
key
must
not
be
empty
.
"
)
;
break
;
case
ScalarResult
:
:
KeyTooLong
:
AppendUTF8toUTF16
(
nsPrintfCString
(
"
-
The
key
length
must
be
limited
to
%
d
characters
.
"
kMaximumKeyStringLength
)
errorMessage
)
;
break
;
case
ScalarResult
:
:
TooManyKeys
:
AppendUTF8toUTF16
(
nsPrintfCString
(
"
-
Keyed
scalars
cannot
have
more
than
%
d
keys
.
"
kMaximumNumberOfKeys
)
errorMessage
)
;
break
;
case
ScalarResult
:
:
UnsignedNegativeValue
:
errorMessage
.
AppendLiteral
(
u
"
-
Trying
to
set
an
unsigned
scalar
to
a
negative
number
.
"
)
;
break
;
case
ScalarResult
:
:
UnsignedTruncatedValue
:
errorMessage
.
AppendLiteral
(
u
"
-
Truncating
float
/
double
number
.
"
)
;
break
;
default
:
return
;
}
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
errorMessage
)
;
}
}
namespace
{
bool
internal_CanRecordBase
(
const
StaticMutexAutoLock
&
lock
)
{
return
gCanRecordBase
;
}
bool
internal_CanRecordExtended
(
const
StaticMutexAutoLock
&
lock
)
{
return
gCanRecordExtended
;
}
bool
internal_IsKeyedScalar
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
)
{
return
internal_GetScalarInfo
(
lock
aId
)
.
keyed
;
}
bool
internal_CanRecordProcess
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
aId
)
;
return
CanRecordInProcess
(
info
.
record_in_processes
XRE_GetProcessType
(
)
)
;
}
bool
internal_CanRecordProduct
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
aId
)
;
return
CanRecordProduct
(
info
.
products
)
;
}
bool
internal_CanRecordForScalarID
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
aId
)
;
bool
canRecordBase
=
internal_CanRecordBase
(
lock
)
;
if
(
!
canRecordBase
)
{
return
false
;
}
bool
canRecordDataset
=
CanRecordDataset
(
info
.
dataset
canRecordBase
internal_CanRecordExtended
(
lock
)
)
;
if
(
!
canRecordDataset
)
{
return
false
;
}
return
true
;
}
ScalarResult
internal_CanRecordScalar
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
bool
aKeyed
bool
aForce
=
false
)
{
if
(
internal_IsKeyedScalar
(
lock
aId
)
!
=
aKeyed
)
{
return
ScalarResult
:
:
KeyedTypeMismatch
;
}
if
(
!
internal_CanRecordForScalarID
(
lock
aId
)
)
{
return
ScalarResult
:
:
CannotRecordDataset
;
}
if
(
!
aForce
&
&
!
internal_CanRecordProcess
(
lock
aId
)
)
{
return
ScalarResult
:
:
CannotRecordInProcess
;
}
if
(
!
internal_CanRecordProduct
(
lock
aId
)
)
{
return
ScalarResult
:
:
CannotRecordDataset
;
}
return
ScalarResult
:
:
Ok
;
}
nsresult
internal_GetEnumByScalarName
(
const
StaticMutexAutoLock
&
lock
const
nsACString
&
aName
ScalarKey
*
aId
)
{
if
(
!
gInitDone
)
{
return
NS_ERROR_FAILURE
;
}
CharPtrEntryType
*
entry
=
gScalarNameIDMap
.
GetEntry
(
PromiseFlatCString
(
aName
)
.
get
(
)
)
;
if
(
!
entry
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aId
=
entry
-
>
mData
;
return
NS_OK
;
}
nsresult
internal_GetScalarByEnum
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
ProcessID
aProcessStorage
ScalarBase
*
*
aRet
)
{
if
(
!
internal_IsValidId
(
lock
aId
)
)
{
MOZ_ASSERT
(
false
"
Requested
a
scalar
with
an
invalid
id
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
aId
)
;
if
(
aId
.
dynamic
&
&
!
info
.
builtin
)
{
aProcessStorage
=
ProcessID
:
:
Dynamic
;
}
ScalarBase
*
scalar
=
nullptr
;
ScalarStorageMapType
*
scalarStorage
=
nullptr
;
uint32_t
storageId
=
static_cast
<
uint32_t
>
(
aProcessStorage
)
;
ProcessesScalarsMapType
&
processStorage
=
(
aId
.
dynamic
&
&
info
.
builtin
)
?
gDynamicBuiltinScalarStorageMap
:
gScalarStorageMap
;
if
(
!
processStorage
.
Get
(
storageId
&
scalarStorage
)
)
{
scalarStorage
=
new
ScalarStorageMapType
(
)
;
processStorage
.
Put
(
storageId
scalarStorage
)
;
}
if
(
scalarStorage
-
>
Get
(
aId
.
id
&
scalar
)
)
{
if
(
aId
.
dynamic
)
{
const
DynamicScalarInfo
&
dynInfo
=
static_cast
<
const
DynamicScalarInfo
&
>
(
info
)
;
if
(
dynInfo
.
mDynamicExpiration
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
*
aRet
=
scalar
;
return
NS_OK
;
}
if
(
IsExpiredVersion
(
info
.
expiration
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
scalar
=
internal_ScalarAllocate
(
info
)
;
if
(
!
scalar
)
{
return
NS_ERROR_INVALID_ARG
;
}
scalarStorage
-
>
Put
(
aId
.
id
scalar
)
;
*
aRet
=
scalar
;
return
NS_OK
;
}
void
internal_ApplyPendingOperations
(
const
StaticMutexAutoLock
&
lock
)
;
void
internal_RecordHighwatermarkReached
(
const
StaticMutexAutoLock
&
lock
)
{
MOZ_ASSERT
(
gIsDeserializing
)
;
MOZ_ASSERT
(
gScalarsActions
)
;
ScalarID
id
=
ScalarID
:
:
TELEMETRY_PENDING_OPERATIONS_HIGHWATERMARK_REACHED
;
ScalarAction
action
{
static_cast
<
uint32_t
>
(
id
)
false
ScalarActionType
:
:
eAdd
Some
(
ScalarVariant
(
1u
)
)
ProcessID
:
:
Parent
}
;
gScalarsActions
-
>
AppendElement
(
action
)
;
}
void
internal_RecordScalarAction
(
const
StaticMutexAutoLock
&
lock
const
ScalarAction
&
aScalarAction
)
{
if
(
!
gScalarsActions
)
{
gScalarsActions
=
new
nsTArray
<
ScalarAction
>
(
)
;
}
gScalarsActions
-
>
AppendElement
(
aScalarAction
)
;
if
(
gScalarsActions
-
>
Length
(
)
>
kScalarActionsArrayHighWaterMark
)
{
internal_RecordHighwatermarkReached
(
lock
)
;
internal_ApplyPendingOperations
(
lock
)
;
return
;
}
}
void
internal_RecordScalarAction
(
const
StaticMutexAutoLock
&
lock
uint32_t
aId
bool
aDynamic
ScalarActionType
aAction
const
ScalarVariant
&
aValue
)
{
internal_RecordScalarAction
(
lock
ScalarAction
{
aId
aDynamic
aAction
Some
(
aValue
)
ProcessID
:
:
Parent
}
)
;
}
void
internal_RecordKeyedScalarAction
(
const
StaticMutexAutoLock
&
lock
const
KeyedScalarAction
&
aScalarAction
)
{
if
(
!
gKeyedScalarsActions
)
{
gKeyedScalarsActions
=
new
nsTArray
<
KeyedScalarAction
>
(
)
;
}
gKeyedScalarsActions
-
>
AppendElement
(
aScalarAction
)
;
if
(
gKeyedScalarsActions
-
>
Length
(
)
>
kScalarActionsArrayHighWaterMark
)
{
internal_RecordHighwatermarkReached
(
lock
)
;
internal_ApplyPendingOperations
(
lock
)
;
return
;
}
}
void
internal_RecordKeyedScalarAction
(
const
StaticMutexAutoLock
&
lock
uint32_t
aId
bool
aDynamic
const
nsAString
&
aKey
ScalarActionType
aAction
const
ScalarVariant
&
aValue
)
{
internal_RecordKeyedScalarAction
(
lock
KeyedScalarAction
{
aId
aDynamic
aAction
NS_ConvertUTF16toUTF8
(
aKey
)
Some
(
aValue
)
ProcessID
:
:
Parent
}
)
;
}
ScalarResult
internal_UpdateScalar
(
const
StaticMutexAutoLock
&
lock
const
nsACString
&
aName
ScalarActionType
aType
nsIVariant
*
aValue
ProcessID
aProcessOverride
=
ProcessID
:
:
Parent
bool
aForce
=
false
)
{
ScalarKey
uniqueId
;
nsresult
rv
=
internal_GetEnumByScalarName
(
lock
aName
&
uniqueId
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
(
rv
=
=
NS_ERROR_FAILURE
)
?
ScalarResult
:
:
NotInitialized
:
ScalarResult
:
:
UnknownScalar
;
}
ScalarResult
sr
=
internal_CanRecordScalar
(
lock
uniqueId
false
aForce
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
=
=
ScalarResult
:
:
CannotRecordDataset
)
{
return
ScalarResult
:
:
Ok
;
}
return
sr
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
uniqueId
)
;
mozilla
:
:
Maybe
<
ScalarVariant
>
variantValue
;
sr
=
GetVariantFromIVariant
(
aValue
info
.
kind
variantValue
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Unable
to
convert
nsIVariant
to
mozilla
:
:
Variant
.
"
)
;
return
sr
;
}
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
aType
variantValue
.
ref
(
)
)
;
return
ScalarResult
:
:
Ok
;
}
if
(
!
aForce
&
&
internal_IsScalarDeserializing
(
lock
)
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
uniqueId
)
;
mozilla
:
:
Maybe
<
ScalarVariant
>
variantValue
;
sr
=
GetVariantFromIVariant
(
aValue
info
.
kind
variantValue
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Unable
to
convert
nsIVariant
to
mozilla
:
:
Variant
.
"
)
;
return
sr
;
}
internal_RecordScalarAction
(
lock
uniqueId
.
id
uniqueId
.
dynamic
aType
variantValue
.
ref
(
)
)
;
return
ScalarResult
:
:
Ok
;
}
ScalarBase
*
scalar
=
nullptr
;
rv
=
internal_GetScalarByEnum
(
lock
uniqueId
aProcessOverride
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
ScalarResult
:
:
Ok
;
}
return
ScalarResult
:
:
UnknownScalar
;
}
if
(
aType
=
=
ScalarActionType
:
:
eAdd
)
{
return
scalar
-
>
AddValue
(
aValue
)
;
}
if
(
aType
=
=
ScalarActionType
:
:
eSet
)
{
return
scalar
-
>
SetValue
(
aValue
)
;
}
return
scalar
-
>
SetMaximum
(
aValue
)
;
}
}
namespace
{
nsresult
internal_GetKeyedScalarByEnum
(
const
StaticMutexAutoLock
&
lock
const
ScalarKey
&
aId
ProcessID
aProcessStorage
KeyedScalar
*
*
aRet
)
{
if
(
!
internal_IsValidId
(
lock
aId
)
)
{
MOZ_ASSERT
(
false
"
Requested
a
keyed
scalar
with
an
invalid
id
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
aId
)
;
if
(
aId
.
dynamic
&
&
!
info
.
builtin
)
{
aProcessStorage
=
ProcessID
:
:
Dynamic
;
}
KeyedScalar
*
scalar
=
nullptr
;
KeyedScalarStorageMapType
*
scalarStorage
=
nullptr
;
uint32_t
storageId
=
static_cast
<
uint32_t
>
(
aProcessStorage
)
;
ProcessesKeyedScalarsMapType
&
processStorage
=
(
aId
.
dynamic
&
&
info
.
builtin
)
?
gDynamicBuiltinKeyedScalarStorageMap
:
gKeyedScalarStorageMap
;
if
(
!
processStorage
.
Get
(
storageId
&
scalarStorage
)
)
{
scalarStorage
=
new
KeyedScalarStorageMapType
(
)
;
processStorage
.
Put
(
storageId
scalarStorage
)
;
}
if
(
scalarStorage
-
>
Get
(
aId
.
id
&
scalar
)
)
{
*
aRet
=
scalar
;
return
NS_OK
;
}
if
(
IsExpiredVersion
(
info
.
expiration
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
info
.
kind
=
=
nsITelemetry
:
:
SCALAR_TYPE_STRING
)
{
MOZ_ASSERT
(
false
"
Keyed
string
scalars
are
not
currently
supported
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
scalar
=
new
KeyedScalar
(
info
)
;
if
(
!
scalar
)
{
return
NS_ERROR_INVALID_ARG
;
}
scalarStorage
-
>
Put
(
aId
.
id
scalar
)
;
*
aRet
=
scalar
;
return
NS_OK
;
}
ScalarResult
internal_UpdateKeyedScalar
(
const
StaticMutexAutoLock
&
lock
const
nsACString
&
aName
const
nsAString
&
aKey
ScalarActionType
aType
nsIVariant
*
aValue
ProcessID
aProcessOverride
=
ProcessID
:
:
Parent
bool
aForce
=
false
)
{
ScalarKey
uniqueId
;
nsresult
rv
=
internal_GetEnumByScalarName
(
lock
aName
&
uniqueId
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
(
rv
=
=
NS_ERROR_FAILURE
)
?
ScalarResult
:
:
NotInitialized
:
ScalarResult
:
:
UnknownScalar
;
}
ScalarResult
sr
=
internal_CanRecordScalar
(
lock
uniqueId
true
aForce
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
=
=
ScalarResult
:
:
CannotRecordDataset
)
{
return
ScalarResult
:
:
Ok
;
}
return
sr
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
uniqueId
)
;
mozilla
:
:
Maybe
<
ScalarVariant
>
variantValue
;
sr
=
GetVariantFromIVariant
(
aValue
info
.
kind
variantValue
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Unable
to
convert
nsIVariant
to
mozilla
:
:
Variant
.
"
)
;
return
sr
;
}
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
aKey
aType
variantValue
.
ref
(
)
)
;
return
ScalarResult
:
:
Ok
;
}
if
(
!
aForce
&
&
internal_IsScalarDeserializing
(
lock
)
)
{
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
lock
uniqueId
)
;
mozilla
:
:
Maybe
<
ScalarVariant
>
variantValue
;
sr
=
GetVariantFromIVariant
(
aValue
info
.
kind
variantValue
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Unable
to
convert
nsIVariant
to
mozilla
:
:
Variant
.
"
)
;
return
sr
;
}
internal_RecordKeyedScalarAction
(
lock
uniqueId
.
id
uniqueId
.
dynamic
aKey
aType
variantValue
.
ref
(
)
)
;
return
ScalarResult
:
:
Ok
;
}
KeyedScalar
*
scalar
=
nullptr
;
rv
=
internal_GetKeyedScalarByEnum
(
lock
uniqueId
aProcessOverride
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
ScalarResult
:
:
Ok
;
}
return
ScalarResult
:
:
UnknownScalar
;
}
if
(
aType
=
=
ScalarActionType
:
:
eAdd
)
{
return
scalar
-
>
AddValue
(
lock
aKey
aValue
)
;
}
if
(
aType
=
=
ScalarActionType
:
:
eSet
)
{
return
scalar
-
>
SetValue
(
lock
aKey
aValue
)
;
}
return
scalar
-
>
SetMaximum
(
lock
aKey
aValue
)
;
}
void
internal_DynamicScalarToIPC
(
const
StaticMutexAutoLock
&
lock
const
nsTArray
<
DynamicScalarInfo
>
&
aDynamicScalarInfos
nsTArray
<
DynamicScalarDefinition
>
&
aIPCDefs
)
{
for
(
auto
info
:
aDynamicScalarInfos
)
{
DynamicScalarDefinition
stubDefinition
;
stubDefinition
.
type
=
info
.
kind
;
stubDefinition
.
dataset
=
info
.
dataset
;
stubDefinition
.
expired
=
info
.
mDynamicExpiration
;
stubDefinition
.
keyed
=
info
.
keyed
;
stubDefinition
.
name
=
info
.
mDynamicName
;
aIPCDefs
.
AppendElement
(
stubDefinition
)
;
}
}
void
internal_BroadcastDefinitions
(
const
StaticMutexAutoLock
&
lock
const
nsTArray
<
DynamicScalarInfo
>
&
scalarInfos
)
{
nsTArray
<
mozilla
:
:
dom
:
:
ContentParent
*
>
parents
;
mozilla
:
:
dom
:
:
ContentParent
:
:
GetAll
(
parents
)
;
if
(
!
parents
.
Length
(
)
)
{
return
;
}
nsTArray
<
DynamicScalarDefinition
>
ipcDefinitions
;
internal_DynamicScalarToIPC
(
lock
scalarInfos
ipcDefinitions
)
;
for
(
auto
parent
:
parents
)
{
mozilla
:
:
Unused
<
<
parent
-
>
SendAddDynamicScalars
(
ipcDefinitions
)
;
}
}
void
internal_RegisterScalars
(
const
StaticMutexAutoLock
&
lock
const
nsTArray
<
DynamicScalarInfo
>
&
scalarInfos
)
{
if
(
!
gDynamicScalarInfo
)
{
gDynamicScalarInfo
=
new
nsTArray
<
DynamicScalarInfo
>
(
)
;
}
for
(
auto
scalarInfo
:
scalarInfos
)
{
CharPtrEntryType
*
existingKey
=
gScalarNameIDMap
.
GetEntry
(
scalarInfo
.
name
(
)
)
;
if
(
existingKey
)
{
if
(
scalarInfo
.
mDynamicExpiration
&
&
!
scalarInfo
.
builtin
)
{
DynamicScalarInfo
&
scalarData
=
(
*
gDynamicScalarInfo
)
[
existingKey
-
>
mData
.
id
]
;
scalarData
.
mDynamicExpiration
=
true
;
}
continue
;
}
gDynamicScalarInfo
-
>
AppendElement
(
scalarInfo
)
;
uint32_t
scalarId
=
gDynamicScalarInfo
-
>
Length
(
)
-
1
;
CharPtrEntryType
*
entry
=
gScalarNameIDMap
.
PutEntry
(
scalarInfo
.
name
(
)
)
;
entry
-
>
mData
=
ScalarKey
{
scalarId
true
}
;
}
}
nsresult
internal_ScalarSnapshotter
(
const
StaticMutexAutoLock
&
aLock
ScalarSnapshotTable
&
aScalarsToReflect
unsigned
int
aDataset
ProcessesScalarsMapType
&
aProcessStorage
bool
aIsBuiltinDynamic
bool
aClearScalars
const
nsACString
&
aStoreName
)
{
for
(
auto
iter
=
aProcessStorage
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarStorageMapType
*
scalarStorage
=
static_cast
<
ScalarStorageMapType
*
>
(
iter
.
Data
(
)
)
;
ScalarTupleArray
&
processScalars
=
aScalarsToReflect
.
GetOrInsert
(
iter
.
Key
(
)
)
;
bool
isDynamicProcess
=
ProcessID
:
:
Dynamic
=
=
static_cast
<
ProcessID
>
(
iter
.
Key
(
)
)
;
for
(
auto
childIter
=
scalarStorage
-
>
Iter
(
)
;
!
childIter
.
Done
(
)
;
childIter
.
Next
(
)
)
{
ScalarBase
*
scalar
=
static_cast
<
ScalarBase
*
>
(
childIter
.
Data
(
)
)
;
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
aLock
ScalarKey
{
childIter
.
Key
(
)
aIsBuiltinDynamic
?
true
:
isDynamicProcess
}
)
;
if
(
IsInDataset
(
info
.
dataset
aDataset
)
)
{
nsCOMPtr
<
nsIVariant
>
scalarValue
;
nsresult
rv
=
scalar
-
>
GetValue
(
aStoreName
scalarValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
processScalars
.
AppendElement
(
mozilla
:
:
MakeTuple
(
info
.
name
(
)
scalarValue
info
.
kind
)
)
;
}
}
}
return
NS_OK
;
}
nsresult
internal_KeyedScalarSnapshotter
(
const
StaticMutexAutoLock
&
aLock
KeyedScalarSnapshotTable
&
aScalarsToReflect
unsigned
int
aDataset
ProcessesKeyedScalarsMapType
&
aProcessStorage
bool
aIsBuiltinDynamic
bool
aClearScalars
const
nsACString
&
aStoreName
)
{
for
(
auto
iter
=
aProcessStorage
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
KeyedScalarStorageMapType
*
scalarStorage
=
static_cast
<
KeyedScalarStorageMapType
*
>
(
iter
.
Data
(
)
)
;
KeyedScalarTupleArray
&
processScalars
=
aScalarsToReflect
.
GetOrInsert
(
iter
.
Key
(
)
)
;
bool
isDynamicProcess
=
ProcessID
:
:
Dynamic
=
=
static_cast
<
ProcessID
>
(
iter
.
Key
(
)
)
;
for
(
auto
childIter
=
scalarStorage
-
>
Iter
(
)
;
!
childIter
.
Done
(
)
;
childIter
.
Next
(
)
)
{
KeyedScalar
*
scalar
=
static_cast
<
KeyedScalar
*
>
(
childIter
.
Data
(
)
)
;
const
BaseScalarInfo
&
info
=
internal_GetScalarInfo
(
aLock
ScalarKey
{
childIter
.
Key
(
)
aIsBuiltinDynamic
?
true
:
isDynamicProcess
}
)
;
if
(
IsInDataset
(
info
.
dataset
aDataset
)
)
{
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
scalarKeyedData
;
nsresult
rv
=
scalar
-
>
GetValue
(
aStoreName
scalarKeyedData
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
processScalars
.
AppendElement
(
mozilla
:
:
MakeTuple
(
info
.
name
(
)
scalarKeyedData
info
.
kind
)
)
;
}
}
}
return
NS_OK
;
}
nsresult
internal_GetScalarSnapshot
(
const
StaticMutexAutoLock
&
aLock
ScalarSnapshotTable
&
aScalarsToReflect
unsigned
int
aDataset
bool
aClearScalars
const
nsACString
&
aStoreName
)
{
nsresult
rv
=
internal_ScalarSnapshotter
(
aLock
aScalarsToReflect
aDataset
gScalarStorageMap
false
aClearScalars
aStoreName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
internal_ScalarSnapshotter
(
aLock
aScalarsToReflect
aDataset
gDynamicBuiltinScalarStorageMap
true
aClearScalars
aStoreName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aClearScalars
)
{
gScalarStorageMap
.
Clear
(
)
;
gDynamicBuiltinScalarStorageMap
.
Clear
(
)
;
}
return
NS_OK
;
}
nsresult
internal_GetKeyedScalarSnapshot
(
const
StaticMutexAutoLock
&
aLock
KeyedScalarSnapshotTable
&
aScalarsToReflect
unsigned
int
aDataset
bool
aClearScalars
const
nsACString
&
aStoreName
)
{
nsresult
rv
=
internal_KeyedScalarSnapshotter
(
aLock
aScalarsToReflect
aDataset
gKeyedScalarStorageMap
false
aClearScalars
aStoreName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
internal_KeyedScalarSnapshotter
(
aLock
aScalarsToReflect
aDataset
gDynamicBuiltinKeyedScalarStorageMap
true
aClearScalars
aStoreName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aClearScalars
)
{
gKeyedScalarStorageMap
.
Clear
(
)
;
gDynamicBuiltinKeyedScalarStorageMap
.
Clear
(
)
;
}
return
NS_OK
;
}
}
namespace
{
void
internal_ApplyScalarActions
(
const
StaticMutexAutoLock
&
lock
const
nsTArray
<
mozilla
:
:
Telemetry
:
:
ScalarAction
>
&
aScalarActions
const
mozilla
:
:
Maybe
<
ProcessID
>
&
aProcessType
=
Nothing
(
)
)
{
if
(
!
internal_CanRecordBase
(
lock
)
)
{
return
;
}
for
(
auto
&
upd
:
aScalarActions
)
{
ScalarKey
uniqueId
{
upd
.
mId
upd
.
mDynamic
}
;
if
(
NS_WARN_IF
(
!
internal_IsValidId
(
lock
uniqueId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
continue
;
}
if
(
internal_IsKeyedScalar
(
lock
uniqueId
)
)
{
continue
;
}
if
(
!
internal_CanRecordForScalarID
(
lock
uniqueId
)
)
{
continue
;
}
ProcessID
processType
=
aProcessType
.
valueOr
(
upd
.
mProcessType
)
;
MOZ_ASSERT
(
processType
!
=
ProcessID
:
:
Count
)
;
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
lock
uniqueId
processType
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
NS_FAILED
internal_GetScalarByEnum
for
CHILD
"
)
;
continue
;
}
if
(
upd
.
mData
.
isNothing
(
)
)
{
MOZ_ASSERT
(
false
"
There
is
no
data
in
the
ScalarActionType
.
"
)
;
continue
;
}
const
uint32_t
scalarType
=
internal_GetScalarInfo
(
lock
uniqueId
)
.
kind
;
switch
(
upd
.
mActionType
)
{
case
ScalarActionType
:
:
eSet
:
{
switch
(
scalarType
)
{
case
nsITelemetry
:
:
SCALAR_TYPE_COUNT
:
if
(
!
upd
.
mData
-
>
is
<
uint32_t
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
set
a
count
scalar
to
a
non
-
integer
.
"
)
;
continue
;
}
scalar
-
>
SetValue
(
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
case
nsITelemetry
:
:
SCALAR_TYPE_BOOLEAN
:
if
(
!
upd
.
mData
-
>
is
<
bool
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
set
a
boolean
scalar
to
a
non
-
boolean
.
"
)
;
continue
;
}
scalar
-
>
SetValue
(
upd
.
mData
-
>
as
<
bool
>
(
)
)
;
break
;
case
nsITelemetry
:
:
SCALAR_TYPE_STRING
:
if
(
!
upd
.
mData
-
>
is
<
nsString
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
set
a
string
scalar
to
a
non
-
string
.
"
)
;
continue
;
}
scalar
-
>
SetValue
(
upd
.
mData
-
>
as
<
nsString
>
(
)
)
;
break
;
}
break
;
}
case
ScalarActionType
:
:
eAdd
:
{
if
(
scalarType
!
=
nsITelemetry
:
:
SCALAR_TYPE_COUNT
)
{
NS_WARNING
(
"
Attempting
to
add
on
a
non
count
scalar
.
"
)
;
continue
;
}
if
(
!
upd
.
mData
-
>
is
<
uint32_t
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
add
to
a
count
scalar
with
a
non
-
integer
.
"
)
;
continue
;
}
scalar
-
>
AddValue
(
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
}
case
ScalarActionType
:
:
eSetMaximum
:
{
if
(
scalarType
!
=
nsITelemetry
:
:
SCALAR_TYPE_COUNT
)
{
NS_WARNING
(
"
Attempting
to
setMaximum
on
a
non
count
scalar
.
"
)
;
continue
;
}
if
(
!
upd
.
mData
-
>
is
<
uint32_t
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
setMaximum
a
count
scalar
to
a
non
-
integer
.
"
)
;
continue
;
}
scalar
-
>
SetMaximum
(
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
}
default
:
NS_WARNING
(
"
Unsupported
action
coming
from
scalar
child
updates
.
"
)
;
}
}
}
void
internal_ApplyKeyedScalarActions
(
const
StaticMutexAutoLock
&
lock
const
nsTArray
<
mozilla
:
:
Telemetry
:
:
KeyedScalarAction
>
&
aScalarActions
const
mozilla
:
:
Maybe
<
ProcessID
>
&
aProcessType
=
Nothing
(
)
)
{
if
(
!
internal_CanRecordBase
(
lock
)
)
{
return
;
}
for
(
auto
&
upd
:
aScalarActions
)
{
ScalarKey
uniqueId
{
upd
.
mId
upd
.
mDynamic
}
;
if
(
NS_WARN_IF
(
!
internal_IsValidId
(
lock
uniqueId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
continue
;
}
if
(
!
internal_IsKeyedScalar
(
lock
uniqueId
)
)
{
continue
;
}
if
(
!
internal_CanRecordForScalarID
(
lock
uniqueId
)
)
{
continue
;
}
ProcessID
processType
=
aProcessType
.
valueOr
(
upd
.
mProcessType
)
;
MOZ_ASSERT
(
processType
!
=
ProcessID
:
:
Count
)
;
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
lock
uniqueId
processType
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
NS_FAILED
internal_GetScalarByEnum
for
CHILD
"
)
;
continue
;
}
if
(
upd
.
mData
.
isNothing
(
)
)
{
MOZ_ASSERT
(
false
"
There
is
no
data
in
the
KeyedScalarAction
.
"
)
;
continue
;
}
const
uint32_t
scalarType
=
internal_GetScalarInfo
(
lock
uniqueId
)
.
kind
;
switch
(
upd
.
mActionType
)
{
case
ScalarActionType
:
:
eSet
:
{
switch
(
scalarType
)
{
case
nsITelemetry
:
:
SCALAR_TYPE_COUNT
:
if
(
!
upd
.
mData
-
>
is
<
uint32_t
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
set
a
count
scalar
to
a
non
-
integer
.
"
)
;
continue
;
}
scalar
-
>
SetValue
(
lock
NS_ConvertUTF8toUTF16
(
upd
.
mKey
)
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
case
nsITelemetry
:
:
SCALAR_TYPE_BOOLEAN
:
if
(
!
upd
.
mData
-
>
is
<
bool
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
set
a
boolean
scalar
to
a
non
-
boolean
.
"
)
;
continue
;
}
scalar
-
>
SetValue
(
lock
NS_ConvertUTF8toUTF16
(
upd
.
mKey
)
upd
.
mData
-
>
as
<
bool
>
(
)
)
;
break
;
default
:
NS_WARNING
(
"
Unsupported
type
coming
from
scalar
child
updates
.
"
)
;
}
break
;
}
case
ScalarActionType
:
:
eAdd
:
{
if
(
scalarType
!
=
nsITelemetry
:
:
SCALAR_TYPE_COUNT
)
{
NS_WARNING
(
"
Attempting
to
add
on
a
non
count
scalar
.
"
)
;
continue
;
}
if
(
!
upd
.
mData
-
>
is
<
uint32_t
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
add
to
a
count
scalar
with
a
non
-
integer
.
"
)
;
continue
;
}
scalar
-
>
AddValue
(
lock
NS_ConvertUTF8toUTF16
(
upd
.
mKey
)
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
}
case
ScalarActionType
:
:
eSetMaximum
:
{
if
(
scalarType
!
=
nsITelemetry
:
:
SCALAR_TYPE_COUNT
)
{
NS_WARNING
(
"
Attempting
to
setMaximum
on
a
non
count
scalar
.
"
)
;
continue
;
}
if
(
!
upd
.
mData
-
>
is
<
uint32_t
>
(
)
)
{
NS_WARNING
(
"
Attempting
to
setMaximum
a
count
scalar
to
a
non
-
integer
.
"
)
;
continue
;
}
scalar
-
>
SetMaximum
(
lock
NS_ConvertUTF8toUTF16
(
upd
.
mKey
)
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
}
default
:
NS_WARNING
(
"
Unsupported
action
coming
from
keyed
scalar
child
updates
.
"
)
;
}
}
}
void
internal_ApplyPendingOperations
(
const
StaticMutexAutoLock
&
lock
)
{
if
(
gScalarsActions
&
&
gScalarsActions
-
>
Length
(
)
>
0
)
{
internal_ApplyScalarActions
(
lock
*
gScalarsActions
)
;
gScalarsActions
-
>
Clear
(
)
;
}
if
(
gKeyedScalarsActions
&
&
gKeyedScalarsActions
-
>
Length
(
)
>
0
)
{
internal_ApplyKeyedScalarActions
(
lock
*
gKeyedScalarsActions
)
;
gKeyedScalarsActions
-
>
Clear
(
)
;
}
gIsDeserializing
=
false
;
}
}
static
StaticMutexNotRecorded
gTelemetryScalarsMutex
;
void
TelemetryScalar
:
:
InitializeGlobalState
(
bool
aCanRecordBase
bool
aCanRecordExtended
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
MOZ_ASSERT
(
!
gInitDone
"
TelemetryScalar
:
:
InitializeGlobalState
"
"
may
only
be
called
once
"
)
;
gCanRecordBase
=
aCanRecordBase
;
gCanRecordExtended
=
aCanRecordExtended
;
uint32_t
scalarCount
=
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
ScalarCount
)
;
for
(
uint32_t
i
=
0
;
i
<
scalarCount
;
i
+
+
)
{
CharPtrEntryType
*
entry
=
gScalarNameIDMap
.
PutEntry
(
gScalars
[
i
]
.
name
(
)
)
;
entry
-
>
mData
=
ScalarKey
{
i
false
}
;
}
const
nsTArray
<
DynamicScalarInfo
>
initialDynamicScalars
(
{
DynamicScalarInfo
{
nsITelemetry
:
:
SCALAR_TYPE_COUNT
true
false
nsAutoCString
(
"
telemetry
.
dynamic_event_counts
"
)
true
false
}
}
)
;
internal_RegisterScalars
(
locker
initialDynamicScalars
)
;
gInitDone
=
true
;
}
void
TelemetryScalar
:
:
DeInitializeGlobalState
(
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gCanRecordBase
=
false
;
gCanRecordExtended
=
false
;
gScalarNameIDMap
.
Clear
(
)
;
gScalarStorageMap
.
Clear
(
)
;
gKeyedScalarStorageMap
.
Clear
(
)
;
gDynamicBuiltinScalarStorageMap
.
Clear
(
)
;
gDynamicBuiltinKeyedScalarStorageMap
.
Clear
(
)
;
gDynamicScalarInfo
=
nullptr
;
gInitDone
=
false
;
}
void
TelemetryScalar
:
:
DeserializationStarted
(
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gIsDeserializing
=
true
;
}
void
TelemetryScalar
:
:
ApplyPendingOperations
(
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
internal_ApplyPendingOperations
(
locker
)
;
}
void
TelemetryScalar
:
:
SetCanRecordBase
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gCanRecordBase
=
b
;
}
void
TelemetryScalar
:
:
SetCanRecordExtended
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gCanRecordExtended
=
b
;
}
nsresult
TelemetryScalar
:
:
Add
(
const
nsACString
&
aName
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateScalar
(
locker
aName
ScalarActionType
:
:
eAdd
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
Add
(
const
nsACString
&
aName
const
nsAString
&
aKey
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateKeyedScalar
(
locker
aName
aKey
ScalarActionType
:
:
eAdd
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
void
TelemetryScalar
:
:
Add
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eAdd
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eAdd
ScalarVariant
(
aValue
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
AddValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Add
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
true
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eAdd
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordKeyedScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eAdd
ScalarVariant
(
aValue
)
)
;
return
;
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
AddValue
(
locker
aKey
aValue
)
;
}
nsresult
TelemetryScalar
:
:
Set
(
const
nsACString
&
aName
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateScalar
(
locker
aName
ScalarActionType
:
:
eSet
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
Set
(
const
nsACString
&
aName
const
nsAString
&
aKey
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateKeyedScalar
(
locker
aName
aKey
ScalarActionType
:
:
eSet
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSet
ScalarVariant
(
nsString
(
aValue
)
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSet
ScalarVariant
(
nsString
(
aValue
)
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
bool
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
true
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordKeyedScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
locker
aKey
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
bool
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
true
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordKeyedScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
locker
aKey
aValue
)
;
}
nsresult
TelemetryScalar
:
:
SetMaximum
(
const
nsACString
&
aName
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateScalar
(
locker
aName
ScalarActionType
:
:
eSetMaximum
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
SetMaximum
(
const
nsACString
&
aName
const
nsAString
&
aKey
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateKeyedScalar
(
locker
aName
aKey
ScalarActionType
:
:
eSetMaximum
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
void
TelemetryScalar
:
:
SetMaximum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSetMaximum
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
ScalarActionType
:
:
eSetMaximum
ScalarVariant
(
aValue
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetMaximum
(
aValue
)
;
}
void
TelemetryScalar
:
:
SetMaximum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
{
if
(
NS_WARN_IF
(
!
IsValidEnumId
(
aId
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Scalar
usage
requires
valid
ids
.
"
)
;
return
;
}
ScalarKey
uniqueId
{
static_cast
<
uint32_t
>
(
aId
)
false
}
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
locker
uniqueId
true
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eSetMaximum
ScalarVariant
(
aValue
)
)
;
return
;
}
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
internal_RecordKeyedScalarAction
(
locker
uniqueId
.
id
uniqueId
.
dynamic
aKey
ScalarActionType
:
:
eSetMaximum
ScalarVariant
(
aValue
)
)
;
return
;
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
locker
uniqueId
ProcessID
:
:
Parent
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetMaximum
(
locker
aKey
aValue
)
;
}
nsresult
TelemetryScalar
:
:
CreateSnapshots
(
unsigned
int
aDataset
bool
aClearScalars
JSContext
*
aCx
uint8_t
optional_argc
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
bool
aFilterTest
const
nsACString
&
aStoreName
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Snapshotting
scalars
should
only
happen
in
the
parent
processes
.
"
)
;
if
(
!
optional_argc
)
{
aClearScalars
=
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
root_obj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
root_obj
)
{
return
NS_ERROR_FAILURE
;
}
aResult
.
setObject
(
*
root_obj
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_OK
;
}
ScalarSnapshotTable
scalarsToReflect
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
nsresult
rv
=
internal_GetScalarSnapshot
(
locker
scalarsToReflect
aDataset
aClearScalars
aStoreName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
for
(
auto
iter
=
scalarsToReflect
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarTupleArray
&
processScalars
=
iter
.
Data
(
)
;
const
char
*
processName
=
GetNameForProcessID
(
ProcessID
(
iter
.
Key
(
)
)
)
;
JS
:
:
RootedObject
processObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
processObj
|
|
!
JS_DefineProperty
(
aCx
root_obj
processName
processObj
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
ScalarTupleArray
:
:
size_type
i
=
0
;
i
<
processScalars
.
Length
(
)
;
i
+
+
)
{
const
ScalarDataTuple
&
scalar
=
processScalars
[
i
]
;
const
char
*
scalarName
=
mozilla
:
:
Get
<
0
>
(
scalar
)
;
if
(
aFilterTest
&
&
strncmp
(
TEST_SCALAR_PREFIX
scalarName
strlen
(
TEST_SCALAR_PREFIX
)
)
=
=
0
)
{
continue
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
scalarJsValue
(
aCx
)
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
VariantToJS
(
aCx
processObj
mozilla
:
:
Get
<
1
>
(
scalar
)
&
scalarJsValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
JS_DefineProperty
(
aCx
processObj
scalarName
scalarJsValue
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
CreateKeyedSnapshots
(
unsigned
int
aDataset
bool
aClearScalars
JSContext
*
aCx
uint8_t
optional_argc
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
bool
aFilterTest
const
nsACString
&
aStoreName
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Snapshotting
scalars
should
only
happen
in
the
parent
processes
.
"
)
;
if
(
!
optional_argc
)
{
aClearScalars
=
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
root_obj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
root_obj
)
{
return
NS_ERROR_FAILURE
;
}
aResult
.
setObject
(
*
root_obj
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_OK
;
}
KeyedScalarSnapshotTable
scalarsToReflect
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
nsresult
rv
=
internal_GetKeyedScalarSnapshot
(
locker
scalarsToReflect
aDataset
aClearScalars
aStoreName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
for
(
auto
iter
=
scalarsToReflect
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
KeyedScalarTupleArray
&
processScalars
=
iter
.
Data
(
)
;
const
char
*
processName
=
GetNameForProcessID
(
ProcessID
(
iter
.
Key
(
)
)
)
;
JS
:
:
RootedObject
processObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
processObj
|
|
!
JS_DefineProperty
(
aCx
root_obj
processName
processObj
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
KeyedScalarTupleArray
:
:
size_type
i
=
0
;
i
<
processScalars
.
Length
(
)
;
i
+
+
)
{
const
KeyedScalarDataTuple
&
keyedScalarData
=
processScalars
[
i
]
;
const
char
*
scalarName
=
mozilla
:
:
Get
<
0
>
(
keyedScalarData
)
;
if
(
aFilterTest
&
&
strncmp
(
TEST_SCALAR_PREFIX
scalarName
strlen
(
TEST_SCALAR_PREFIX
)
)
=
=
0
)
{
continue
;
}
JS
:
:
RootedObject
keyedScalarObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
const
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
&
keyProps
=
mozilla
:
:
Get
<
1
>
(
keyedScalarData
)
;
for
(
uint32_t
i
=
0
;
i
<
keyProps
.
Length
(
)
;
i
+
+
)
{
const
KeyedScalar
:
:
KeyValuePair
&
keyData
=
keyProps
[
i
]
;
JS
:
:
Rooted
<
JS
:
:
Value
>
keyJsValue
(
aCx
)
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
VariantToJS
(
aCx
keyedScalarObj
keyData
.
second
(
)
&
keyJsValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
const
NS_ConvertUTF8toUTF16
key
(
keyData
.
first
(
)
)
;
if
(
!
JS_DefineUCProperty
(
aCx
keyedScalarObj
key
.
Data
(
)
key
.
Length
(
)
keyJsValue
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
!
JS_DefineProperty
(
aCx
processObj
scalarName
keyedScalarObj
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
RegisterScalars
(
const
nsACString
&
aCategoryName
JS
:
:
Handle
<
JS
:
:
Value
>
aScalarData
bool
aBuiltin
JSContext
*
cx
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Dynamic
scalars
should
only
be
created
in
the
parent
process
.
"
)
;
if
(
!
IsValidIdentifierString
(
aCategoryName
kMaximumCategoryNameLength
true
false
)
)
{
JS_ReportErrorASCII
(
cx
"
Invalid
category
name
%
s
.
"
PromiseFlatCString
(
aCategoryName
)
.
get
(
)
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
aScalarData
.
isObject
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Scalar
data
parameter
should
be
an
object
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
JS
:
:
RootedObject
obj
(
cx
&
aScalarData
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
scalarPropertyIds
(
cx
JS
:
:
IdVector
(
cx
)
)
;
if
(
!
JS_Enumerate
(
cx
obj
&
scalarPropertyIds
)
)
{
return
NS_ERROR_FAILURE
;
}
nsTArray
<
DynamicScalarInfo
>
newScalarInfos
;
for
(
size_t
i
=
0
n
=
scalarPropertyIds
.
length
(
)
;
i
<
n
;
i
+
+
)
{
nsAutoJSString
scalarName
;
if
(
!
scalarName
.
init
(
cx
scalarPropertyIds
[
i
]
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsValidIdentifierString
(
NS_ConvertUTF16toUTF8
(
scalarName
)
kMaximumScalarNameLength
false
true
)
)
{
JS_ReportErrorASCII
(
cx
"
Invalid
scalar
name
%
s
.
"
PromiseFlatCString
(
NS_ConvertUTF16toUTF8
(
scalarName
)
)
.
get
(
)
)
;
return
NS_ERROR_INVALID_ARG
;
}
nsPrintfCString
fullName
(
"
%
s
.
%
s
"
PromiseFlatCString
(
aCategoryName
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
scalarName
)
.
get
(
)
)
;
JS
:
:
RootedValue
value
(
cx
)
;
if
(
!
JS_GetPropertyById
(
cx
obj
scalarPropertyIds
[
i
]
&
value
)
|
|
!
value
.
isObject
(
)
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedObject
scalarDef
(
cx
&
value
.
toObject
(
)
)
;
if
(
!
JS_GetProperty
(
cx
scalarDef
"
kind
"
&
value
)
|
|
!
value
.
isInt32
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Invalid
or
missing
'
kind
'
for
scalar
%
s
.
"
PromiseFlatCString
(
fullName
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
kind
=
static_cast
<
uint32_t
>
(
value
.
toInt32
(
)
)
;
bool
hasProperty
=
false
;
bool
recordOnRelease
=
false
;
if
(
JS_HasProperty
(
cx
scalarDef
"
record_on_release
"
&
hasProperty
)
&
&
hasProperty
)
{
if
(
!
JS_GetProperty
(
cx
scalarDef
"
record_on_release
"
&
value
)
|
|
!
value
.
isBoolean
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Invalid
'
record_on_release
'
for
scalar
%
s
.
"
PromiseFlatCString
(
fullName
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
recordOnRelease
=
static_cast
<
bool
>
(
value
.
toBoolean
(
)
)
;
}
bool
keyed
=
false
;
if
(
JS_HasProperty
(
cx
scalarDef
"
keyed
"
&
hasProperty
)
&
&
hasProperty
)
{
if
(
!
JS_GetProperty
(
cx
scalarDef
"
keyed
"
&
value
)
|
|
!
value
.
isBoolean
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Invalid
'
keyed
'
for
scalar
%
s
.
"
PromiseFlatCString
(
fullName
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
keyed
=
static_cast
<
bool
>
(
value
.
toBoolean
(
)
)
;
}
bool
expired
=
false
;
if
(
JS_HasProperty
(
cx
scalarDef
"
expired
"
&
hasProperty
)
&
&
hasProperty
)
{
if
(
!
JS_GetProperty
(
cx
scalarDef
"
expired
"
&
value
)
|
|
!
value
.
isBoolean
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Invalid
'
expired
'
for
scalar
%
s
.
"
PromiseFlatCString
(
fullName
)
.
get
(
)
)
;
return
NS_ERROR_FAILURE
;
}
expired
=
static_cast
<
bool
>
(
value
.
toBoolean
(
)
)
;
}
newScalarInfos
.
AppendElement
(
DynamicScalarInfo
{
kind
recordOnRelease
expired
fullName
keyed
aBuiltin
}
)
;
}
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
:
:
internal_RegisterScalars
(
locker
newScalarInfos
)
;
:
:
internal_BroadcastDefinitions
(
locker
newScalarInfos
)
;
}
return
NS_OK
;
}
void
TelemetryScalar
:
:
SummarizeEvent
(
const
nsCString
&
aUniqueEventName
ProcessID
aProcessType
bool
aDynamic
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Only
summarize
events
in
the
parent
process
"
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
StaticMutexAutoLock
lock
(
gTelemetryScalarsMutex
)
;
ScalarKey
scalarKey
{
static_cast
<
uint32_t
>
(
ScalarID
:
:
TELEMETRY_EVENT_COUNTS
)
aDynamic
}
;
if
(
aDynamic
)
{
nsresult
rv
=
internal_GetEnumByScalarName
(
lock
nsAutoCString
(
"
telemetry
.
dynamic_event_counts
"
)
&
scalarKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
NS_FAILED
getting
ScalarKey
for
telemetry
.
dynamic_event_counts
"
)
;
return
;
}
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
lock
scalarKey
aProcessType
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
NS_FAILED
getting
keyed
scalar
for
event
summary
.
Wut
.
"
)
;
return
;
}
static
uint32_t
sMaxEventSummaryKeys
=
Preferences
:
:
GetUint
(
"
toolkit
.
telemetry
.
maxEventSummaryKeys
"
500
)
;
scalar
-
>
SetMaximumNumberOfKeys
(
sMaxEventSummaryKeys
)
;
scalar
-
>
AddValue
(
lock
NS_ConvertASCIItoUTF16
(
aUniqueEventName
)
1
)
;
}
void
TelemetryScalar
:
:
ClearScalars
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Scalars
should
only
be
cleared
in
the
parent
process
.
"
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gScalarStorageMap
.
Clear
(
)
;
gKeyedScalarStorageMap
.
Clear
(
)
;
gDynamicBuiltinScalarStorageMap
.
Clear
(
)
;
gDynamicBuiltinKeyedScalarStorageMap
.
Clear
(
)
;
gScalarsActions
=
nullptr
;
gKeyedScalarsActions
=
nullptr
;
}
size_t
TelemetryScalar
:
:
GetMapShallowSizesOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
return
gScalarNameIDMap
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
TelemetryScalar
:
:
GetScalarSizesOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
size_t
n
=
0
;
auto
getSizeOf
=
[
aMallocSizeOf
]
(
auto
&
storageMap
)
{
size_t
partial
=
0
;
for
(
auto
iter
=
storageMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
scalarStorage
=
iter
.
UserData
(
)
;
for
(
auto
childIter
=
scalarStorage
-
>
Iter
(
)
;
!
childIter
.
Done
(
)
;
childIter
.
Next
(
)
)
{
auto
scalar
=
childIter
.
UserData
(
)
;
partial
+
=
scalar
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
return
partial
;
}
;
n
+
=
getSizeOf
(
gScalarStorageMap
)
;
n
+
=
getSizeOf
(
gKeyedScalarStorageMap
)
;
n
+
=
getSizeOf
(
gDynamicBuiltinScalarStorageMap
)
;
n
+
=
getSizeOf
(
gDynamicBuiltinKeyedScalarStorageMap
)
;
return
n
;
}
void
TelemetryScalar
:
:
UpdateChildData
(
ProcessID
aProcessType
const
nsTArray
<
mozilla
:
:
Telemetry
:
:
ScalarAction
>
&
aScalarActions
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
The
stored
child
processes
scalar
data
must
be
updated
from
the
parent
process
.
"
)
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
for
(
const
ScalarAction
&
action
:
aScalarActions
)
{
ScalarAction
copy
=
action
;
copy
.
mProcessType
=
aProcessType
;
internal_RecordScalarAction
(
locker
copy
)
;
}
return
;
}
internal_ApplyScalarActions
(
locker
aScalarActions
Some
(
aProcessType
)
)
;
}
void
TelemetryScalar
:
:
UpdateChildKeyedData
(
ProcessID
aProcessType
const
nsTArray
<
mozilla
:
:
Telemetry
:
:
KeyedScalarAction
>
&
aScalarActions
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
The
stored
child
processes
keyed
scalar
data
must
be
updated
from
the
parent
process
.
"
)
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_IsScalarDeserializing
(
locker
)
)
{
for
(
const
KeyedScalarAction
&
action
:
aScalarActions
)
{
KeyedScalarAction
copy
=
action
;
copy
.
mProcessType
=
aProcessType
;
internal_RecordKeyedScalarAction
(
locker
copy
)
;
}
return
;
}
internal_ApplyKeyedScalarActions
(
locker
aScalarActions
Some
(
aProcessType
)
)
;
}
void
TelemetryScalar
:
:
RecordDiscardedData
(
ProcessID
aProcessType
const
mozilla
:
:
Telemetry
:
:
DiscardedData
&
aDiscardedData
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Discarded
Data
must
be
updated
from
the
parent
process
.
"
)
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
!
internal_CanRecordBase
(
locker
)
)
{
return
;
}
ScalarBase
*
scalar
=
nullptr
;
mozilla
:
:
DebugOnly
<
nsresult
>
rv
;
rv
=
internal_GetScalarByEnum
(
locker
ScalarKey
{
static_cast
<
uint32_t
>
(
ScalarID
:
:
TELEMETRY_DISCARDED_ACCUMULATIONS
)
false
}
aProcessType
&
scalar
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
scalar
-
>
AddValue
(
aDiscardedData
.
mDiscardedHistogramAccumulations
)
;
rv
=
internal_GetScalarByEnum
(
locker
ScalarKey
{
static_cast
<
uint32_t
>
(
ScalarID
:
:
TELEMETRY_DISCARDED_KEYED_ACCUMULATIONS
)
false
}
aProcessType
&
scalar
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
scalar
-
>
AddValue
(
aDiscardedData
.
mDiscardedKeyedHistogramAccumulations
)
;
rv
=
internal_GetScalarByEnum
(
locker
ScalarKey
{
static_cast
<
uint32_t
>
(
ScalarID
:
:
TELEMETRY_DISCARDED_SCALAR_ACTIONS
)
false
}
aProcessType
&
scalar
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
scalar
-
>
AddValue
(
aDiscardedData
.
mDiscardedScalarActions
)
;
rv
=
internal_GetScalarByEnum
(
locker
ScalarKey
{
static_cast
<
uint32_t
>
(
ScalarID
:
:
TELEMETRY_DISCARDED_KEYED_SCALAR_ACTIONS
)
false
}
aProcessType
&
scalar
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
scalar
-
>
AddValue
(
aDiscardedData
.
mDiscardedKeyedScalarActions
)
;
rv
=
internal_GetScalarByEnum
(
locker
ScalarKey
{
static_cast
<
uint32_t
>
(
ScalarID
:
:
TELEMETRY_DISCARDED_CHILD_EVENTS
)
false
}
aProcessType
&
scalar
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
scalar
-
>
AddValue
(
aDiscardedData
.
mDiscardedChildEvents
)
;
}
void
TelemetryScalar
:
:
GetDynamicScalarDefinitions
(
nsTArray
<
DynamicScalarDefinition
>
&
aDefArray
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
gDynamicScalarInfo
)
{
return
;
}
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
internal_DynamicScalarToIPC
(
locker
*
gDynamicScalarInfo
aDefArray
)
;
}
void
TelemetryScalar
:
:
AddDynamicScalarDefinitions
(
const
nsTArray
<
DynamicScalarDefinition
>
&
aDefs
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
nsTArray
<
DynamicScalarInfo
>
dynamicStubs
;
for
(
auto
def
:
aDefs
)
{
bool
recordOnRelease
=
def
.
dataset
=
=
nsITelemetry
:
:
DATASET_RELEASE_CHANNEL_OPTOUT
;
dynamicStubs
.
AppendElement
(
DynamicScalarInfo
{
def
.
type
recordOnRelease
def
.
expired
def
.
name
def
.
keyed
false
}
)
;
}
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
internal_RegisterScalars
(
locker
dynamicStubs
)
;
}
}
nsresult
TelemetryScalar
:
:
SerializeScalars
(
mozilla
:
:
JSONWriter
&
aWriter
)
{
ScalarSnapshotTable
scalarsToReflect
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
nsresult
rv
=
internal_GetScalarSnapshot
(
locker
scalarsToReflect
nsITelemetry
:
:
DATASET_RELEASE_CHANNEL_OPTIN
false
NS_LITERAL_CSTRING
(
"
main
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
for
(
auto
iter
=
scalarsToReflect
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarTupleArray
&
processScalars
=
iter
.
Data
(
)
;
const
char
*
processName
=
GetNameForProcessID
(
ProcessID
(
iter
.
Key
(
)
)
)
;
aWriter
.
StartObjectProperty
(
processName
)
;
for
(
const
ScalarDataTuple
&
scalar
:
processScalars
)
{
nsresult
rv
=
WriteVariantToJSONWriter
(
mozilla
:
:
Get
<
2
>
(
scalar
)
mozilla
:
:
Get
<
1
>
(
scalar
)
mozilla
:
:
Get
<
0
>
(
scalar
)
aWriter
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
}
aWriter
.
EndObject
(
)
;
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
SerializeKeyedScalars
(
mozilla
:
:
JSONWriter
&
aWriter
)
{
KeyedScalarSnapshotTable
keyedScalarsToReflect
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
nsresult
rv
=
internal_GetKeyedScalarSnapshot
(
locker
keyedScalarsToReflect
nsITelemetry
:
:
DATASET_RELEASE_CHANNEL_OPTIN
false
NS_LITERAL_CSTRING
(
"
main
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
for
(
auto
iter
=
keyedScalarsToReflect
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
KeyedScalarTupleArray
&
processScalars
=
iter
.
Data
(
)
;
const
char
*
processName
=
GetNameForProcessID
(
ProcessID
(
iter
.
Key
(
)
)
)
;
aWriter
.
StartObjectProperty
(
processName
)
;
for
(
const
KeyedScalarDataTuple
&
keyedScalarData
:
processScalars
)
{
aWriter
.
StartObjectProperty
(
mozilla
:
:
Get
<
0
>
(
keyedScalarData
)
)
;
const
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
&
keyProps
=
mozilla
:
:
Get
<
1
>
(
keyedScalarData
)
;
for
(
const
KeyedScalar
:
:
KeyValuePair
&
keyData
:
keyProps
)
{
nsresult
rv
=
WriteVariantToJSONWriter
(
mozilla
:
:
Get
<
2
>
(
keyedScalarData
)
keyData
.
second
(
)
PromiseFlatCString
(
keyData
.
first
(
)
)
.
get
(
)
aWriter
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
}
aWriter
.
EndObject
(
)
;
}
aWriter
.
EndObject
(
)
;
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
DeserializePersistedScalars
(
JSContext
*
aCx
JS
:
:
HandleValue
aData
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Only
load
scalars
in
the
parent
process
"
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_FAILURE
;
}
typedef
mozilla
:
:
Pair
<
nsCString
nsCOMPtr
<
nsIVariant
>
>
PersistedScalarPair
;
typedef
nsTArray
<
PersistedScalarPair
>
PersistedScalarArray
;
typedef
nsDataHashtable
<
ProcessIDHashKey
PersistedScalarArray
>
PeristedScalarStorage
;
PeristedScalarStorage
scalarsToUpdate
;
JS
:
:
RootedObject
scalarDataObj
(
aCx
&
aData
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
processes
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
scalarDataObj
&
processes
)
)
{
JS_ClearPendingException
(
aCx
)
;
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedId
process
(
aCx
)
;
for
(
auto
&
processVal
:
processes
)
{
process
=
processVal
;
nsAutoJSString
processNameJS
;
if
(
!
processNameJS
.
init
(
aCx
process
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
NS_ConvertUTF16toUTF8
processName
(
processNameJS
)
;
ProcessID
processID
=
GetIDForProcessName
(
processName
.
get
(
)
)
;
if
(
processID
=
=
ProcessID
:
:
Count
)
{
NS_WARNING
(
nsPrintfCString
(
"
Failed
to
get
process
ID
for
%
s
"
processName
.
get
(
)
)
.
get
(
)
)
;
continue
;
}
JS
:
:
RootedValue
processData
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
scalarDataObj
process
&
processData
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
if
(
!
processData
.
isObject
(
)
)
{
continue
;
}
JS
:
:
RootedObject
processDataObj
(
aCx
&
processData
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
scalars
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
processDataObj
&
scalars
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
JS
:
:
RootedId
scalar
(
aCx
)
;
for
(
auto
&
scalarVal
:
scalars
)
{
scalar
=
scalarVal
;
nsAutoJSString
scalarName
;
if
(
!
scalarName
.
init
(
aCx
scalar
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
JS
:
:
RootedValue
scalarValue
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
processDataObj
scalar
&
scalarValue
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
if
(
scalarValue
.
isNullOrUndefined
(
)
)
{
continue
;
}
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
scalarValue
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
PersistedScalarArray
&
processScalars
=
scalarsToUpdate
.
GetOrInsert
(
static_cast
<
uint32_t
>
(
processID
)
)
;
processScalars
.
AppendElement
(
mozilla
:
:
MakePair
(
nsCString
(
NS_ConvertUTF16toUTF8
(
scalarName
)
)
unpackedVal
)
)
;
}
}
{
StaticMutexAutoLock
lock
(
gTelemetryScalarsMutex
)
;
for
(
auto
iter
=
scalarsToUpdate
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
PersistedScalarArray
&
processScalars
=
iter
.
Data
(
)
;
for
(
PersistedScalarArray
:
:
size_type
i
=
0
;
i
<
processScalars
.
Length
(
)
;
i
+
+
)
{
mozilla
:
:
Unused
<
<
internal_UpdateScalar
(
lock
processScalars
[
i
]
.
first
(
)
ScalarActionType
:
:
eSet
processScalars
[
i
]
.
second
(
)
ProcessID
(
iter
.
Key
(
)
)
true
)
;
}
}
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
DeserializePersistedKeyedScalars
(
JSContext
*
aCx
JS
:
:
HandleValue
aData
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Only
load
scalars
in
the
parent
process
"
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_FAILURE
;
}
typedef
mozilla
:
:
Tuple
<
nsCString
nsString
nsCOMPtr
<
nsIVariant
>
>
PersistedKeyedScalarTuple
;
typedef
nsTArray
<
PersistedKeyedScalarTuple
>
PersistedKeyedScalarArray
;
typedef
nsDataHashtable
<
ProcessIDHashKey
PersistedKeyedScalarArray
>
PeristedKeyedScalarStorage
;
PeristedKeyedScalarStorage
scalarsToUpdate
;
JS
:
:
RootedObject
scalarDataObj
(
aCx
&
aData
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
processes
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
scalarDataObj
&
processes
)
)
{
JS_ClearPendingException
(
aCx
)
;
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedId
process
(
aCx
)
;
for
(
auto
&
processVal
:
processes
)
{
process
=
processVal
;
nsAutoJSString
processNameJS
;
if
(
!
processNameJS
.
init
(
aCx
process
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
NS_ConvertUTF16toUTF8
processName
(
processNameJS
)
;
ProcessID
processID
=
GetIDForProcessName
(
processName
.
get
(
)
)
;
if
(
processID
=
=
ProcessID
:
:
Count
)
{
NS_WARNING
(
nsPrintfCString
(
"
Failed
to
get
process
ID
for
%
s
"
processName
.
get
(
)
)
.
get
(
)
)
;
continue
;
}
JS
:
:
RootedValue
processData
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
scalarDataObj
process
&
processData
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
if
(
!
processData
.
isObject
(
)
)
{
continue
;
}
JS
:
:
RootedObject
processDataObj
(
aCx
&
processData
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
keyedScalars
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
processDataObj
&
keyedScalars
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
JS
:
:
RootedId
keyedScalar
(
aCx
)
;
for
(
auto
&
keyedScalarVal
:
keyedScalars
)
{
keyedScalar
=
keyedScalarVal
;
nsAutoJSString
scalarName
;
if
(
!
scalarName
.
init
(
aCx
keyedScalar
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
JS
:
:
RootedValue
keyedScalarData
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
processDataObj
keyedScalar
&
keyedScalarData
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
if
(
!
keyedScalarData
.
isObject
(
)
)
{
continue
;
}
JS
:
:
RootedObject
keyedScalarDataObj
(
aCx
&
keyedScalarData
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
keys
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
keyedScalarDataObj
&
keys
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
JS
:
:
RootedId
key
(
aCx
)
;
for
(
auto
keyVal
:
keys
)
{
key
=
keyVal
;
nsAutoJSString
keyName
;
if
(
!
keyName
.
init
(
aCx
key
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
JS
:
:
RootedValue
scalarValue
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
keyedScalarDataObj
key
&
scalarValue
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
if
(
scalarValue
.
isNullOrUndefined
(
)
)
{
continue
;
}
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
scalarValue
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
JS_ClearPendingException
(
aCx
)
;
continue
;
}
PersistedKeyedScalarArray
&
processScalars
=
scalarsToUpdate
.
GetOrInsert
(
static_cast
<
uint32_t
>
(
processID
)
)
;
processScalars
.
AppendElement
(
mozilla
:
:
MakeTuple
(
nsCString
(
NS_ConvertUTF16toUTF8
(
scalarName
)
)
nsString
(
keyName
)
unpackedVal
)
)
;
}
}
}
{
StaticMutexAutoLock
lock
(
gTelemetryScalarsMutex
)
;
for
(
auto
iter
=
scalarsToUpdate
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
PersistedKeyedScalarArray
&
processScalars
=
iter
.
Data
(
)
;
for
(
PersistedKeyedScalarArray
:
:
size_type
i
=
0
;
i
<
processScalars
.
Length
(
)
;
i
+
+
)
{
mozilla
:
:
Unused
<
<
internal_UpdateKeyedScalar
(
lock
mozilla
:
:
Get
<
0
>
(
processScalars
[
i
]
)
mozilla
:
:
Get
<
1
>
(
processScalars
[
i
]
)
ScalarActionType
:
:
eSet
mozilla
:
:
Get
<
2
>
(
processScalars
[
i
]
)
ProcessID
(
iter
.
Key
(
)
)
true
)
;
}
}
}
return
NS_OK
;
}
