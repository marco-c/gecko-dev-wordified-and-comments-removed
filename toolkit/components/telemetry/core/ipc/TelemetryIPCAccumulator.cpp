#
include
"
TelemetryIPCAccumulator
.
h
"
#
include
"
core
/
TelemetryHistogram
.
h
"
#
include
"
core
/
TelemetryScalar
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
mozilla
:
:
Preferences
;
using
mozilla
:
:
StaticMutex
;
using
mozilla
:
:
StaticMutexAutoLock
;
using
mozilla
:
:
StaticAutoPtr
;
using
mozilla
:
:
SystemGroup
;
using
mozilla
:
:
TaskCategory
;
using
mozilla
:
:
Telemetry
:
:
HistogramAccumulation
;
using
mozilla
:
:
Telemetry
:
:
DiscardedData
;
using
mozilla
:
:
Telemetry
:
:
KeyedHistogramAccumulation
;
using
mozilla
:
:
Telemetry
:
:
ScalarActionType
;
using
mozilla
:
:
Telemetry
:
:
ScalarAction
;
using
mozilla
:
:
Telemetry
:
:
KeyedScalarAction
;
using
mozilla
:
:
Telemetry
:
:
ScalarVariant
;
using
mozilla
:
:
Telemetry
:
:
ChildEventData
;
namespace
TelemetryIPCAccumulator
=
mozilla
:
:
TelemetryIPCAccumulator
;
const
uint32_t
kDefaultBatchTimeoutMs
=
2000
;
static
uint32_t
sBatchTimeoutMs
=
kDefaultBatchTimeoutMs
;
const
size_t
kHistogramAccumulationsArrayHighWaterMark
=
5
*
1024
;
const
size_t
kScalarActionsArrayHighWaterMark
=
10000
;
const
size_t
kEventsArrayHighWaterMark
=
10000
;
const
size_t
kWaterMarkDiscardFactor
=
5
;
DiscardedData
gDiscardedData
=
{
0
}
;
nsITimer
*
gIPCTimer
=
nullptr
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
gIPCTimerArmed
(
false
)
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
gIPCTimerArming
(
false
)
;
StaticAutoPtr
<
nsTArray
<
HistogramAccumulation
>
>
gHistogramAccumulations
;
StaticAutoPtr
<
nsTArray
<
KeyedHistogramAccumulation
>
>
gKeyedHistogramAccumulations
;
StaticAutoPtr
<
nsTArray
<
ScalarAction
>
>
gChildScalarsActions
;
StaticAutoPtr
<
nsTArray
<
KeyedScalarAction
>
>
gChildKeyedScalarsActions
;
StaticAutoPtr
<
nsTArray
<
ChildEventData
>
>
gChildEvents
;
static
StaticMutex
gTelemetryIPCAccumulatorMutex
;
namespace
{
void
DoArmIPCTimerMainThread
(
const
StaticMutexAutoLock
&
lock
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
gIPCTimerArming
=
false
;
if
(
gIPCTimerArmed
)
{
return
;
}
if
(
!
gIPCTimer
)
{
gIPCTimer
=
NS_NewTimer
(
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
)
.
take
(
)
;
}
if
(
gIPCTimer
)
{
static
bool
sTimeoutInitialized
=
false
;
if
(
!
sTimeoutInitialized
&
&
Preferences
:
:
IsServiceAvailable
(
)
)
{
Preferences
:
:
AddUintVarCache
(
&
sBatchTimeoutMs
"
toolkit
.
telemetry
.
ipcBatchTimeout
"
kDefaultBatchTimeoutMs
)
;
sTimeoutInitialized
=
true
;
}
gIPCTimer
-
>
InitWithNamedFuncCallback
(
TelemetryIPCAccumulator
:
:
IPCTimerFired
nullptr
sBatchTimeoutMs
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
"
TelemetryIPCAccumulator
:
:
IPCTimerFired
"
)
;
gIPCTimerArmed
=
true
;
}
}
void
ArmIPCTimer
(
const
StaticMutexAutoLock
&
lock
)
{
if
(
gIPCTimerArmed
|
|
gIPCTimerArming
)
{
return
;
}
gIPCTimerArming
=
true
;
if
(
NS_IsMainThread
(
)
)
{
DoArmIPCTimerMainThread
(
lock
)
;
}
else
{
TelemetryIPCAccumulator
:
:
DispatchToMainThread
(
NS_NewRunnableFunction
(
"
TelemetryIPCAccumulator
:
:
ArmIPCTimer
"
[
]
(
)
-
>
void
{
StaticMutexAutoLock
locker
(
gTelemetryIPCAccumulatorMutex
)
;
DoArmIPCTimerMainThread
(
locker
)
;
}
)
)
;
}
}
void
DispatchIPCTimerFired
(
)
{
TelemetryIPCAccumulator
:
:
DispatchToMainThread
(
NS_NewRunnableFunction
(
"
TelemetryIPCAccumulator
:
:
IPCTimerFired
"
[
]
(
)
-
>
void
{
TelemetryIPCAccumulator
:
:
IPCTimerFired
(
nullptr
nullptr
)
;
}
)
)
;
}
}
void
TelemetryIPCAccumulator
:
:
AccumulateChildHistogram
(
mozilla
:
:
Telemetry
:
:
HistogramID
aId
uint32_t
aSample
)
{
StaticMutexAutoLock
locker
(
gTelemetryIPCAccumulatorMutex
)
;
if
(
!
gHistogramAccumulations
)
{
gHistogramAccumulations
=
new
nsTArray
<
HistogramAccumulation
>
(
)
;
}
if
(
gHistogramAccumulations
-
>
Length
(
)
>
=
kWaterMarkDiscardFactor
*
kHistogramAccumulationsArrayHighWaterMark
)
{
gDiscardedData
.
mDiscardedHistogramAccumulations
+
+
;
return
;
}
if
(
gHistogramAccumulations
-
>
Length
(
)
=
=
kHistogramAccumulationsArrayHighWaterMark
)
{
DispatchIPCTimerFired
(
)
;
}
gHistogramAccumulations
-
>
AppendElement
(
HistogramAccumulation
{
aId
aSample
}
)
;
ArmIPCTimer
(
locker
)
;
}
void
TelemetryIPCAccumulator
:
:
AccumulateChildKeyedHistogram
(
mozilla
:
:
Telemetry
:
:
HistogramID
aId
const
nsCString
&
aKey
uint32_t
aSample
)
{
StaticMutexAutoLock
locker
(
gTelemetryIPCAccumulatorMutex
)
;
if
(
!
gKeyedHistogramAccumulations
)
{
gKeyedHistogramAccumulations
=
new
nsTArray
<
KeyedHistogramAccumulation
>
(
)
;
}
if
(
gKeyedHistogramAccumulations
-
>
Length
(
)
>
=
kWaterMarkDiscardFactor
*
kHistogramAccumulationsArrayHighWaterMark
)
{
gDiscardedData
.
mDiscardedKeyedHistogramAccumulations
+
+
;
return
;
}
if
(
gKeyedHistogramAccumulations
-
>
Length
(
)
=
=
kHistogramAccumulationsArrayHighWaterMark
)
{
DispatchIPCTimerFired
(
)
;
}
gKeyedHistogramAccumulations
-
>
AppendElement
(
KeyedHistogramAccumulation
{
aId
aSample
aKey
}
)
;
ArmIPCTimer
(
locker
)
;
}
void
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
uint32_t
aId
bool
aDynamic
ScalarActionType
aAction
const
ScalarVariant
&
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryIPCAccumulatorMutex
)
;
if
(
!
gChildScalarsActions
)
{
gChildScalarsActions
=
new
nsTArray
<
ScalarAction
>
(
)
;
}
if
(
gChildScalarsActions
-
>
Length
(
)
>
=
kWaterMarkDiscardFactor
*
kScalarActionsArrayHighWaterMark
)
{
gDiscardedData
.
mDiscardedScalarActions
+
+
;
return
;
}
if
(
gChildScalarsActions
-
>
Length
(
)
=
=
kScalarActionsArrayHighWaterMark
)
{
DispatchIPCTimerFired
(
)
;
}
gChildScalarsActions
-
>
AppendElement
(
ScalarAction
{
aId
aDynamic
aAction
Some
(
aValue
)
Telemetry
:
:
ProcessID
:
:
Count
}
)
;
ArmIPCTimer
(
locker
)
;
}
void
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
uint32_t
aId
bool
aDynamic
const
nsAString
&
aKey
ScalarActionType
aAction
const
ScalarVariant
&
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryIPCAccumulatorMutex
)
;
if
(
!
gChildKeyedScalarsActions
)
{
gChildKeyedScalarsActions
=
new
nsTArray
<
KeyedScalarAction
>
(
)
;
}
if
(
gChildKeyedScalarsActions
-
>
Length
(
)
>
=
kWaterMarkDiscardFactor
*
kScalarActionsArrayHighWaterMark
)
{
gDiscardedData
.
mDiscardedKeyedScalarActions
+
+
;
return
;
}
if
(
gChildKeyedScalarsActions
-
>
Length
(
)
=
=
kScalarActionsArrayHighWaterMark
)
{
DispatchIPCTimerFired
(
)
;
}
gChildKeyedScalarsActions
-
>
AppendElement
(
KeyedScalarAction
{
aId
aDynamic
aAction
NS_ConvertUTF16toUTF8
(
aKey
)
Some
(
aValue
)
Telemetry
:
:
ProcessID
:
:
Count
}
)
;
ArmIPCTimer
(
locker
)
;
}
void
TelemetryIPCAccumulator
:
:
RecordChildEvent
(
const
mozilla
:
:
TimeStamp
&
timestamp
const
nsACString
&
category
const
nsACString
&
method
const
nsACString
&
object
const
mozilla
:
:
Maybe
<
nsCString
>
&
value
const
nsTArray
<
mozilla
:
:
Telemetry
:
:
EventExtraEntry
>
&
extra
)
{
StaticMutexAutoLock
locker
(
gTelemetryIPCAccumulatorMutex
)
;
if
(
!
gChildEvents
)
{
gChildEvents
=
new
nsTArray
<
ChildEventData
>
(
)
;
}
if
(
gChildEvents
-
>
Length
(
)
>
=
kWaterMarkDiscardFactor
*
kEventsArrayHighWaterMark
)
{
gDiscardedData
.
mDiscardedChildEvents
+
+
;
return
;
}
if
(
gChildEvents
-
>
Length
(
)
=
=
kEventsArrayHighWaterMark
)
{
DispatchIPCTimerFired
(
)
;
}
gChildEvents
-
>
AppendElement
(
ChildEventData
{
timestamp
nsCString
(
category
)
nsCString
(
method
)
nsCString
(
object
)
value
nsTArray
<
mozilla
:
:
Telemetry
:
:
EventExtraEntry
>
(
extra
)
}
)
;
ArmIPCTimer
(
locker
)
;
}
template
<
class
TActor
>
static
void
SendAccumulatedData
(
TActor
*
ipcActor
)
{
nsTArray
<
HistogramAccumulation
>
histogramsToSend
;
nsTArray
<
KeyedHistogramAccumulation
>
keyedHistogramsToSend
;
nsTArray
<
ScalarAction
>
scalarsToSend
;
nsTArray
<
KeyedScalarAction
>
keyedScalarsToSend
;
nsTArray
<
ChildEventData
>
eventsToSend
;
DiscardedData
discardedData
;
{
StaticMutexAutoLock
locker
(
gTelemetryIPCAccumulatorMutex
)
;
if
(
gHistogramAccumulations
)
{
histogramsToSend
.
SwapElements
(
*
gHistogramAccumulations
)
;
}
if
(
gKeyedHistogramAccumulations
)
{
keyedHistogramsToSend
.
SwapElements
(
*
gKeyedHistogramAccumulations
)
;
}
if
(
gChildScalarsActions
)
{
scalarsToSend
.
SwapElements
(
*
gChildScalarsActions
)
;
}
if
(
gChildKeyedScalarsActions
)
{
keyedScalarsToSend
.
SwapElements
(
*
gChildKeyedScalarsActions
)
;
}
if
(
gChildEvents
)
{
eventsToSend
.
SwapElements
(
*
gChildEvents
)
;
}
discardedData
=
gDiscardedData
;
gDiscardedData
=
{
0
}
;
}
MOZ_ASSERT
(
ipcActor
)
;
if
(
histogramsToSend
.
Length
(
)
)
{
mozilla
:
:
Unused
<
<
NS_WARN_IF
(
!
ipcActor
-
>
SendAccumulateChildHistograms
(
histogramsToSend
)
)
;
}
if
(
keyedHistogramsToSend
.
Length
(
)
)
{
mozilla
:
:
Unused
<
<
NS_WARN_IF
(
!
ipcActor
-
>
SendAccumulateChildKeyedHistograms
(
keyedHistogramsToSend
)
)
;
}
if
(
scalarsToSend
.
Length
(
)
)
{
mozilla
:
:
Unused
<
<
NS_WARN_IF
(
!
ipcActor
-
>
SendUpdateChildScalars
(
scalarsToSend
)
)
;
}
if
(
keyedScalarsToSend
.
Length
(
)
)
{
mozilla
:
:
Unused
<
<
NS_WARN_IF
(
!
ipcActor
-
>
SendUpdateChildKeyedScalars
(
keyedScalarsToSend
)
)
;
}
if
(
eventsToSend
.
Length
(
)
)
{
mozilla
:
:
Unused
<
<
NS_WARN_IF
(
!
ipcActor
-
>
SendRecordChildEvents
(
eventsToSend
)
)
;
}
mozilla
:
:
Unused
<
<
NS_WARN_IF
(
!
ipcActor
-
>
SendRecordDiscardedData
(
discardedData
)
)
;
}
void
TelemetryIPCAccumulator
:
:
IPCTimerFired
(
nsITimer
*
aTimer
void
*
aClosure
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Content
:
SendAccumulatedData
(
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
)
;
break
;
case
GeckoProcessType_GPU
:
SendAccumulatedData
(
mozilla
:
:
gfx
:
:
GPUParent
:
:
GetSingleton
(
)
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
process
type
"
)
;
break
;
}
gIPCTimerArmed
=
false
;
}
void
TelemetryIPCAccumulator
:
:
DeInitializeGlobalState
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StaticMutexAutoLock
locker
(
gTelemetryIPCAccumulatorMutex
)
;
if
(
gIPCTimer
)
{
NS_RELEASE
(
gIPCTimer
)
;
}
gHistogramAccumulations
=
nullptr
;
gKeyedHistogramAccumulations
=
nullptr
;
gChildScalarsActions
=
nullptr
;
gChildKeyedScalarsActions
=
nullptr
;
gChildEvents
=
nullptr
;
}
void
TelemetryIPCAccumulator
:
:
DispatchToMainThread
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
)
{
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
-
>
Dispatch
(
std
:
:
move
(
aEvent
)
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
}
