#
include
"
Telemetry
.
h
"
#
include
"
TelemetryOrigin
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
TelemetryCommon
.
h
"
#
include
"
TelemetryOriginEnums
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
dom
/
PrioEncoder
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
cmath
>
#
include
<
type_traits
>
using
mozilla
:
:
Get
;
using
mozilla
:
:
MakeTuple
;
using
mozilla
:
:
MakeUnique
;
using
mozilla
:
:
MallocSizeOf
;
using
mozilla
:
:
StaticMutex
;
using
mozilla
:
:
StaticMutexAutoLock
;
using
mozilla
:
:
Tuple
;
using
mozilla
:
:
UniquePtr
;
using
mozilla
:
:
dom
:
:
PrioEncoder
;
using
mozilla
:
:
Telemetry
:
:
OriginMetricID
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
ToJSString
;
namespace
{
class
OriginMetricIDHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
const
OriginMetricID
&
KeyType
;
typedef
const
OriginMetricID
*
KeyTypePointer
;
explicit
OriginMetricIDHashKey
(
KeyTypePointer
aKey
)
:
mValue
(
*
aKey
)
{
}
OriginMetricIDHashKey
(
OriginMetricIDHashKey
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mValue
(
std
:
:
move
(
aOther
.
mValue
)
)
{
}
~
OriginMetricIDHashKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mValue
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
*
aKey
=
=
mValue
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
static_cast
<
std
:
:
underlying_type
<
OriginMetricID
>
:
:
type
>
(
*
aKey
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
const
OriginMetricID
mValue
;
}
;
}
namespace
{
static
StaticMutex
gTelemetryOriginMutex
;
typedef
nsTArray
<
Tuple
<
const
char
*
const
char
*
>
>
OriginHashesList
;
UniquePtr
<
OriginHashesList
>
gOriginHashesList
;
typedef
nsTHashMap
<
nsCStringHashKey
size_t
>
OriginToIndexMap
;
UniquePtr
<
OriginToIndexMap
>
gOriginToIndexMap
;
typedef
nsTHashMap
<
nsCStringHashKey
size_t
>
HashToIndexMap
;
UniquePtr
<
HashToIndexMap
>
gHashToIndexMap
;
typedef
nsTHashMap
<
nsCStringHashKey
uint32_t
>
OriginBag
;
typedef
nsTHashMap
<
OriginMetricIDHashKey
OriginBag
>
IdToOriginBag
;
UniquePtr
<
IdToOriginBag
>
gMetricToOriginBag
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
gInitDone
(
false
)
;
typedef
nsTArray
<
std
:
:
pair
<
OriginMetricID
nsTArray
<
nsTArray
<
bool
>
>
>
>
IdBoolsPairArray
;
static
uint32_t
gPrioDatasPerMetric
;
static
uint32_t
kNumMetaOrigins
=
1
;
constexpr
auto
kUnknownOrigin
=
"
__UNKNOWN__
"
_ns
;
}
namespace
{
const
char
*
GetNameForMetricID
(
OriginMetricID
aId
)
{
MOZ_ASSERT
(
aId
<
OriginMetricID
:
:
Count
)
;
return
mozilla
:
:
Telemetry
:
:
MetricIDToString
[
static_cast
<
uint32_t
>
(
aId
)
]
;
}
uint32_t
PrioDataCount
(
const
StaticMutexAutoLock
&
lock
)
{
uint32_t
count
=
0
;
for
(
const
auto
&
origins
:
gMetricToOriginBag
-
>
Values
(
)
)
{
uint32_t
maxOriginCount
=
0
;
for
(
const
auto
&
data
:
origins
.
Values
(
)
)
{
maxOriginCount
=
std
:
:
max
(
maxOriginCount
data
)
;
}
count
+
=
gPrioDatasPerMetric
*
maxOriginCount
;
}
return
count
;
}
nsresult
AppEncodeTo
(
const
StaticMutexAutoLock
&
lock
IdBoolsPairArray
&
aResult
)
{
for
(
const
auto
&
bagEntry
:
*
gMetricToOriginBag
)
{
OriginMetricID
id
=
bagEntry
.
GetKey
(
)
;
const
OriginBag
&
bag
=
bagEntry
.
GetData
(
)
;
uint32_t
generation
=
1
;
uint32_t
maxGeneration
=
1
;
do
{
nsTArray
<
nsTArray
<
bool
>
>
metricData
(
gPrioDatasPerMetric
)
;
metricData
.
SetLength
(
gPrioDatasPerMetric
)
;
for
(
size_t
i
=
0
;
i
<
metricData
.
Length
(
)
-
1
;
+
+
i
)
{
metricData
[
i
]
.
SetLength
(
PrioEncoder
:
:
gNumBooleans
)
;
for
(
auto
&
metricDatum
:
metricData
[
i
]
)
{
metricDatum
=
false
;
}
}
auto
&
lastArray
=
metricData
[
metricData
.
Length
(
)
-
1
]
;
lastArray
.
SetLength
(
(
gOriginHashesList
-
>
Length
(
)
+
kNumMetaOrigins
)
%
PrioEncoder
:
:
gNumBooleans
)
;
for
(
auto
&
metricDatum
:
lastArray
)
{
metricDatum
=
false
;
}
for
(
const
auto
&
originEntry
:
bag
)
{
uint32_t
originCount
=
originEntry
.
GetData
(
)
;
if
(
originCount
>
=
generation
)
{
maxGeneration
=
std
:
:
max
(
maxGeneration
originCount
)
;
const
nsACString
&
origin
=
originEntry
.
GetKey
(
)
;
size_t
index
;
if
(
!
gOriginToIndexMap
-
>
Get
(
origin
&
index
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
index
<
(
gOriginHashesList
-
>
Length
(
)
+
kNumMetaOrigins
)
)
;
size_t
shardIndex
=
index
/
PrioEncoder
:
:
gNumBooleans
;
MOZ_ASSERT
(
shardIndex
<
metricData
.
Length
(
)
)
;
MOZ_ASSERT
(
index
%
PrioEncoder
:
:
gNumBooleans
<
metricData
[
shardIndex
]
.
Length
(
)
)
;
metricData
[
shardIndex
]
[
index
%
PrioEncoder
:
:
gNumBooleans
]
=
true
;
}
}
aResult
.
EmplaceBack
(
id
std
:
:
move
(
metricData
)
)
;
}
while
(
generation
+
+
<
maxGeneration
)
;
}
return
NS_OK
;
}
}
void
TelemetryOrigin
:
:
InitializeGlobalState
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
StaticMutexAutoLock
locker
(
gTelemetryOriginMutex
)
;
MOZ_ASSERT
(
!
gInitDone
"
TelemetryOrigin
:
:
InitializeGlobalState
"
"
may
only
be
called
once
"
)
;
static
const
char
sOriginStrings
[
]
=
{
#
define
ORIGIN
(
origin
hash
)
origin
"
\
0
"
#
include
"
TelemetryOriginData
.
inc
"
#
undef
ORIGIN
}
;
static
const
char
sHashStrings
[
]
=
{
#
define
ORIGIN
(
origin
hash
)
hash
"
\
0
"
#
include
"
TelemetryOriginData
.
inc
"
#
undef
ORIGIN
}
;
struct
OriginHashLengths
{
uint8_t
originLength
;
uint8_t
hashLength
;
}
;
static
const
OriginHashLengths
sOriginHashLengths
[
]
=
{
#
define
ORIGIN
(
origin
hash
)
{
sizeof
(
origin
)
sizeof
(
hash
)
}
#
include
"
TelemetryOriginData
.
inc
"
#
undef
ORIGIN
}
;
static
const
size_t
kNumOrigins
=
MOZ_ARRAY_LENGTH
(
sOriginHashLengths
)
;
gOriginHashesList
=
MakeUnique
<
OriginHashesList
>
(
kNumOrigins
)
;
gPrioDatasPerMetric
=
ceil
(
static_cast
<
double
>
(
kNumOrigins
+
kNumMetaOrigins
)
/
PrioEncoder
:
:
gNumBooleans
)
;
gOriginToIndexMap
=
MakeUnique
<
OriginToIndexMap
>
(
kNumOrigins
+
kNumMetaOrigins
)
;
gHashToIndexMap
=
MakeUnique
<
HashToIndexMap
>
(
kNumOrigins
)
;
size_t
originOffset
=
0
;
size_t
hashOffset
=
0
;
for
(
size_t
i
=
0
;
i
<
kNumOrigins
;
+
+
i
)
{
const
char
*
origin
=
&
sOriginStrings
[
originOffset
]
;
const
char
*
hash
=
&
sHashStrings
[
hashOffset
]
;
MOZ_ASSERT
(
!
kUnknownOrigin
.
Equals
(
origin
)
"
Unknown
origin
literal
is
reserved
in
Origin
Telemetry
"
)
;
gOriginHashesList
-
>
AppendElement
(
MakeTuple
(
origin
hash
)
)
;
const
size_t
originLength
=
sOriginHashLengths
[
i
]
.
originLength
;
const
size_t
hashLength
=
sOriginHashLengths
[
i
]
.
hashLength
;
originOffset
+
=
originLength
;
hashOffset
+
=
hashLength
;
gOriginToIndexMap
-
>
InsertOrUpdate
(
nsDependentCString
(
origin
originLength
-
1
)
i
)
;
gHashToIndexMap
-
>
InsertOrUpdate
(
nsDependentCString
(
hash
hashLength
-
1
)
i
)
;
}
gOriginToIndexMap
-
>
InsertOrUpdate
(
kUnknownOrigin
gOriginHashesList
-
>
Length
(
)
)
;
gMetricToOriginBag
=
MakeUnique
<
IdToOriginBag
>
(
)
;
gOriginToIndexMap
-
>
MarkImmutable
(
)
;
gHashToIndexMap
-
>
MarkImmutable
(
)
;
gInitDone
=
true
;
}
void
TelemetryOrigin
:
:
DeInitializeGlobalState
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
StaticMutexAutoLock
locker
(
gTelemetryOriginMutex
)
;
MOZ_ASSERT
(
gInitDone
)
;
if
(
!
gInitDone
)
{
return
;
}
gOriginHashesList
=
nullptr
;
gOriginToIndexMap
=
nullptr
;
gHashToIndexMap
=
nullptr
;
gMetricToOriginBag
=
nullptr
;
gInitDone
=
false
;
}
nsresult
TelemetryOrigin
:
:
RecordOrigin
(
OriginMetricID
aId
const
nsACString
&
aOrigin
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
prioDataCount
;
{
StaticMutexAutoLock
locker
(
gTelemetryOriginMutex
)
;
if
(
!
gInitDone
)
{
return
NS_OK
;
}
size_t
index
;
nsCString
origin
(
aOrigin
)
;
if
(
gHashToIndexMap
-
>
Get
(
aOrigin
&
index
)
)
{
MOZ_ASSERT
(
aOrigin
.
Equals
(
Get
<
1
>
(
(
*
gOriginHashesList
)
[
index
]
)
)
)
;
origin
=
Get
<
0
>
(
(
*
gOriginHashesList
)
[
index
]
)
;
}
if
(
!
gOriginToIndexMap
-
>
Contains
(
origin
)
)
{
if
(
gMetricToOriginBag
-
>
Contains
(
aId
)
&
&
gMetricToOriginBag
-
>
LookupOrInsert
(
aId
)
.
Contains
(
kUnknownOrigin
)
)
{
return
NS_OK
;
}
origin
=
kUnknownOrigin
;
}
auto
&
originBag
=
gMetricToOriginBag
-
>
LookupOrInsert
(
aId
)
;
originBag
.
LookupOrInsert
(
origin
)
+
+
;
prioDataCount
=
PrioDataCount
(
locker
)
;
}
static
uint32_t
sPrioPingLimit
=
mozilla
:
:
Preferences
:
:
GetUint
(
"
toolkit
.
telemetry
.
prioping
.
dataLimit
"
10
)
;
if
(
prioDataCount
>
=
sPrioPingLimit
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
origin
-
telemetry
-
storage
-
limit
-
reached
"
nullptr
)
;
}
}
return
NS_OK
;
}
nsresult
TelemetryOrigin
:
:
GetOriginSnapshot
(
bool
aClear
JSContext
*
aCx
JS
:
:
MutableHandleValue
aResult
)
{
if
(
NS_WARN_IF
(
!
XRE_IsParentProcess
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
gInitDone
)
{
return
NS_OK
;
}
IdToOriginBag
copy
;
{
StaticMutexAutoLock
locker
(
gTelemetryOriginMutex
)
;
if
(
aClear
)
{
gMetricToOriginBag
-
>
SwapElements
(
copy
)
;
}
else
{
for
(
const
auto
&
entry
:
*
gMetricToOriginBag
)
{
copy
.
InsertOrUpdate
(
entry
.
GetKey
(
)
entry
.
GetData
(
)
.
Clone
(
)
)
;
}
}
}
JS
:
:
Rooted
<
JSObject
*
>
rootObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
NS_WARN_IF
(
!
rootObj
)
)
{
return
NS_ERROR_FAILURE
;
}
aResult
.
setObject
(
*
rootObj
)
;
for
(
const
auto
&
entry
:
copy
)
{
JS
:
:
RootedObject
originsObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
NS_WARN_IF
(
!
originsObj
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
JS_DefineProperty
(
aCx
rootObj
GetNameForMetricID
(
entry
.
GetKey
(
)
)
originsObj
JSPROP_ENUMERATE
)
)
{
NS_WARNING
(
"
Failed
to
define
property
in
origin
snapshot
.
"
)
;
return
NS_ERROR_FAILURE
;
}
for
(
const
auto
&
originEntry
:
entry
.
GetData
(
)
)
{
if
(
!
JS_DefineProperty
(
aCx
originsObj
nsPromiseFlatCString
(
originEntry
.
GetKey
(
)
)
.
get
(
)
originEntry
.
GetData
(
)
JSPROP_ENUMERATE
)
)
{
NS_WARNING
(
"
Failed
to
define
origin
and
count
in
snapshot
.
"
)
;
return
NS_ERROR_FAILURE
;
}
}
}
return
NS_OK
;
}
nsresult
TelemetryOrigin
:
:
GetEncodedOriginSnapshot
(
bool
aClear
JSContext
*
aCx
JS
:
:
MutableHandleValue
aSnapshot
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
gInitDone
)
{
return
NS_OK
;
}
nsresult
rv
;
IdBoolsPairArray
appEncodedMetricData
;
{
StaticMutexAutoLock
lock
(
gTelemetryOriginMutex
)
;
rv
=
AppEncodeTo
(
lock
appEncodedMetricData
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aClear
)
{
gMetricToOriginBag
-
>
Clear
(
)
;
}
}
nsTArray
<
std
:
:
pair
<
nsCString
std
:
:
pair
<
nsCString
nsCString
>
>
>
prioData
;
for
(
auto
&
metricData
:
appEncodedMetricData
)
{
auto
&
boolVectors
=
metricData
.
second
;
for
(
uint32_t
i
=
0
;
i
<
boolVectors
.
Length
(
)
;
+
+
i
)
{
nsCString
encodingName
=
nsPrintfCString
(
"
%
s
-
%
u
"
GetNameForMetricID
(
metricData
.
first
)
i
)
;
nsCString
aResult
;
nsCString
bResult
;
rv
=
PrioEncoder
:
:
EncodeNative
(
encodingName
boolVectors
[
i
]
aResult
bResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCString
aBase64
;
rv
=
mozilla
:
:
Base64Encode
(
aResult
aBase64
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCString
bBase64
;
rv
=
mozilla
:
:
Base64Encode
(
bResult
bBase64
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
prioData
.
EmplaceBack
(
std
:
:
move
(
encodingName
)
std
:
:
pair
(
std
:
:
move
(
aBase64
)
std
:
:
move
(
bBase64
)
)
)
;
}
}
JS
:
:
RootedObject
prioDataArray
(
aCx
JS
:
:
NewArrayObject
(
aCx
prioData
.
Length
(
)
)
)
;
if
(
NS_WARN_IF
(
!
prioDataArray
)
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
i
=
0
;
for
(
auto
&
prioDatum
:
prioData
)
{
JS
:
:
RootedObject
prioDatumObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
NS_WARN_IF
(
!
prioDatumObj
)
)
{
return
NS_ERROR_FAILURE
;
}
JSString
*
encoding
=
ToJSString
(
aCx
prioDatum
.
first
)
;
JS
:
:
RootedString
rootedEncoding
(
aCx
encoding
)
;
if
(
NS_WARN_IF
(
!
JS_DefineProperty
(
aCx
prioDatumObj
"
encoding
"
rootedEncoding
JSPROP_ENUMERATE
)
)
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedObject
prioObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
NS_WARN_IF
(
!
prioObj
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
JS_DefineProperty
(
aCx
prioDatumObj
"
prio
"
prioObj
JSPROP_ENUMERATE
)
)
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedString
aRootStr
(
aCx
ToJSString
(
aCx
prioDatum
.
second
.
first
)
)
;
if
(
NS_WARN_IF
(
!
JS_DefineProperty
(
aCx
prioObj
"
a
"
aRootStr
JSPROP_ENUMERATE
)
)
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedString
bRootStr
(
aCx
ToJSString
(
aCx
prioDatum
.
second
.
second
)
)
;
if
(
NS_WARN_IF
(
!
JS_DefineProperty
(
aCx
prioObj
"
b
"
bRootStr
JSPROP_ENUMERATE
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
JS_DefineElement
(
aCx
prioDataArray
i
+
+
prioDatumObj
JSPROP_ENUMERATE
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
aSnapshot
.
setObject
(
*
prioDataArray
)
;
return
NS_OK
;
}
void
TelemetryOrigin
:
:
ClearOrigins
(
)
{
StaticMutexAutoLock
lock
(
gTelemetryOriginMutex
)
;
if
(
!
gInitDone
)
{
return
;
}
gMetricToOriginBag
-
>
Clear
(
)
;
}
size_t
TelemetryOrigin
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
StaticMutexAutoLock
locker
(
gTelemetryOriginMutex
)
;
size_t
n
=
0
;
if
(
!
gInitDone
)
{
return
0
;
}
n
+
=
gMetricToOriginBag
-
>
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
origins
:
gMetricToOriginBag
-
>
Values
(
)
)
{
n
+
=
origins
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
n
+
=
gOriginToIndexMap
-
>
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
;
return
n
;
}
size_t
TelemetryOrigin
:
:
SizeOfPrioDatasPerMetric
(
)
{
return
gPrioDatasPerMetric
;
}
