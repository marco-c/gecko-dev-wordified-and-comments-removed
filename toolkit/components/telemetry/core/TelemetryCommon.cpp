#
include
"
TelemetryCommon
.
h
"
#
include
<
cstring
>
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsITelemetry
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsVersionComparator
.
h
"
#
include
"
TelemetryProcessData
.
h
"
#
include
"
Telemetry
.
h
"
namespace
mozilla
{
namespace
Telemetry
{
namespace
Common
{
bool
IsExpiredVersion
(
const
char
*
aExpiration
)
{
MOZ_ASSERT
(
aExpiration
)
;
return
strcmp
(
aExpiration
"
never
"
)
&
&
strcmp
(
aExpiration
"
default
"
)
&
&
(
mozilla
:
:
Version
(
aExpiration
)
<
=
MOZ_APP_VERSION
)
;
}
bool
IsInDataset
(
uint32_t
aDataset
uint32_t
aContainingDataset
)
{
if
(
aDataset
=
=
aContainingDataset
)
{
return
true
;
}
if
(
aContainingDataset
=
=
nsITelemetry
:
:
DATASET_RELEASE_CHANNEL_OPTIN
&
&
aDataset
=
=
nsITelemetry
:
:
DATASET_RELEASE_CHANNEL_OPTOUT
)
{
return
true
;
}
return
false
;
}
bool
CanRecordDataset
(
uint32_t
aDataset
bool
aCanRecordBase
bool
aCanRecordExtended
)
{
if
(
aCanRecordExtended
)
{
return
true
;
}
if
(
aCanRecordBase
&
&
IsInDataset
(
aDataset
nsITelemetry
:
:
DATASET_RELEASE_CHANNEL_OPTOUT
)
)
{
return
true
;
}
return
false
;
}
bool
CanRecordInProcess
(
RecordedProcessType
processes
GeckoProcessType
processType
)
{
bool
recordAllChildren
=
!
!
(
processes
&
RecordedProcessType
:
:
AllChildren
)
;
bool
canRecordProcess
=
!
!
(
processes
&
static_cast
<
RecordedProcessType
>
(
1
<
<
processType
)
)
;
return
canRecordProcess
|
|
(
(
processType
!
=
GeckoProcessType_Default
)
&
&
recordAllChildren
)
;
}
bool
CanRecordInProcess
(
RecordedProcessType
processes
ProcessID
processId
)
{
return
CanRecordInProcess
(
processes
GetGeckoProcessType
(
processId
)
)
;
}
bool
CanRecordProduct
(
SupportedProduct
aProducts
)
{
return
!
!
(
aProducts
&
GetCurrentProduct
(
)
)
;
}
nsresult
MsSinceProcessStart
(
double
*
aResult
)
{
bool
isInconsistent
=
false
;
*
aResult
=
(
TimeStamp
:
:
NowLoRes
(
)
-
TimeStamp
:
:
ProcessCreation
(
&
isInconsistent
)
)
.
ToMilliseconds
(
)
;
if
(
isInconsistent
)
{
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
TELEMETRY_PROCESS_CREATION_TIMESTAMP_INCONSISTENT
1
)
;
}
return
NS_OK
;
}
void
LogToBrowserConsole
(
uint32_t
aLogLevel
const
nsAString
&
aMsg
)
{
if
(
!
NS_IsMainThread
(
)
)
{
nsString
msg
(
aMsg
)
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
"
Telemetry
:
:
Common
:
:
LogToBrowserConsole
"
[
aLogLevel
msg
]
(
)
{
LogToBrowserConsole
(
aLogLevel
msg
)
;
}
)
;
NS_DispatchToMainThread
(
task
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
return
;
}
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
)
)
;
if
(
!
console
)
{
NS_WARNING
(
"
Failed
to
log
message
to
console
.
"
)
;
return
;
}
nsCOMPtr
<
nsIScriptError
>
error
(
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
)
)
;
error
-
>
Init
(
aMsg
EmptyString
(
)
EmptyString
(
)
0
0
aLogLevel
"
chrome
javascript
"
false
)
;
console
-
>
LogMessage
(
error
)
;
}
const
char
*
GetNameForProcessID
(
ProcessID
process
)
{
MOZ_ASSERT
(
process
<
ProcessID
:
:
Count
)
;
return
ProcessIDToString
[
static_cast
<
uint32_t
>
(
process
)
]
;
}
ProcessID
GetIDForProcessName
(
const
char
*
aProcessName
)
{
for
(
uint32_t
id
=
0
;
id
<
static_cast
<
uint32_t
>
(
ProcessID
:
:
Count
)
;
id
+
+
)
{
if
(
!
strcmp
(
GetNameForProcessID
(
ProcessID
(
id
)
)
aProcessName
)
)
{
return
ProcessID
(
id
)
;
}
}
return
ProcessID
:
:
Count
;
}
GeckoProcessType
GetGeckoProcessType
(
ProcessID
process
)
{
MOZ_ASSERT
(
process
<
ProcessID
:
:
Count
)
;
return
ProcessIDToGeckoProcessType
[
static_cast
<
uint32_t
>
(
process
)
]
;
}
bool
IsStringCharValid
(
const
char
aChar
const
bool
aAllowInfixPeriod
const
bool
aAllowInfixUnderscore
)
{
return
(
aChar
>
=
'
A
'
&
&
aChar
<
=
'
Z
'
)
|
|
(
aChar
>
=
'
a
'
&
&
aChar
<
=
'
z
'
)
|
|
(
aChar
>
=
'
0
'
&
&
aChar
<
=
'
9
'
)
|
|
(
aAllowInfixPeriod
&
&
(
aChar
=
=
'
.
'
)
)
|
|
(
aAllowInfixUnderscore
&
&
(
aChar
=
=
'
_
'
)
)
;
}
bool
IsValidIdentifierString
(
const
nsACString
&
aStr
const
size_t
aMaxLength
const
bool
aAllowInfixPeriod
const
bool
aAllowInfixUnderscore
)
{
if
(
aStr
.
Length
(
)
>
aMaxLength
)
{
return
false
;
}
const
char
*
first
=
aStr
.
BeginReading
(
)
;
const
char
*
end
=
aStr
.
EndReading
(
)
;
for
(
const
char
*
cur
=
first
;
cur
<
end
;
+
+
cur
)
{
const
bool
infix
=
(
cur
!
=
first
)
&
&
(
cur
!
=
(
end
-
1
)
)
;
if
(
!
IsStringCharValid
(
*
cur
aAllowInfixPeriod
&
&
infix
aAllowInfixUnderscore
&
&
infix
)
)
{
return
false
;
}
}
return
true
;
}
JSString
*
ToJSString
(
JSContext
*
cx
const
nsACString
&
aStr
)
{
const
NS_ConvertUTF8toUTF16
wide
(
aStr
)
;
return
JS_NewUCStringCopyN
(
cx
wide
.
Data
(
)
wide
.
Length
(
)
)
;
}
JSString
*
ToJSString
(
JSContext
*
cx
const
nsAString
&
aStr
)
{
return
JS_NewUCStringCopyN
(
cx
aStr
.
Data
(
)
aStr
.
Length
(
)
)
;
}
SupportedProduct
gCurrentProduct
=
SupportedProduct
:
:
Firefox
;
void
SetCurrentProduct
(
)
{
#
if
defined
(
MOZ_WIDGET_ANDROID
)
bool
isGeckoview
=
Preferences
:
:
GetBool
(
"
toolkit
.
telemetry
.
isGeckoViewMode
"
false
)
;
if
(
isGeckoview
)
{
gCurrentProduct
=
SupportedProduct
:
:
Geckoview
;
}
else
{
gCurrentProduct
=
SupportedProduct
:
:
Fennec
;
}
#
else
gCurrentProduct
=
SupportedProduct
:
:
Firefox
;
#
endif
}
SupportedProduct
GetCurrentProduct
(
)
{
return
gCurrentProduct
;
}
}
}
}
