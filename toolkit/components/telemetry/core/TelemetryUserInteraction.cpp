#
include
"
nsString
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
TelemetryUserInteraction
.
h
"
#
include
"
TelemetryUserInteractionData
.
h
"
#
include
"
TelemetryUserInteractionNameMap
.
h
"
#
include
"
UserInteractionInfo
.
h
"
using
mozilla
:
:
Telemetry
:
:
UserInteractionIDByNameLookup
;
namespace
{
struct
UserInteractionKey
{
uint32_t
id
;
}
;
}
namespace
{
bool
gInitDone
=
false
;
bool
gCanRecordBase
;
bool
gCanRecordExtended
;
}
namespace
{
const
char
*
UserInteractionInfo
:
:
name
(
)
const
{
return
&
gUserInteractionsStringTable
[
this
-
>
name_offset
]
;
}
}
void
TelemetryUserInteraction
:
:
InitializeGlobalState
(
bool
aCanRecordBase
bool
aCanRecordExtended
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
gInitDone
"
TelemetryUserInteraction
:
:
InitializeGlobalState
"
"
may
only
be
called
once
"
)
;
gCanRecordBase
=
aCanRecordBase
;
gCanRecordExtended
=
aCanRecordExtended
;
gInitDone
=
true
;
}
void
TelemetryUserInteraction
:
:
DeInitializeGlobalState
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
gInitDone
)
;
if
(
!
gInitDone
)
{
return
;
}
gInitDone
=
false
;
}
bool
TelemetryUserInteraction
:
:
CanRecord
(
const
nsAString
&
aName
)
{
if
(
!
gCanRecordBase
)
{
return
false
;
}
nsCString
name
=
NS_ConvertUTF16toUTF8
(
aName
)
;
const
uint32_t
idx
=
UserInteractionIDByNameLookup
(
name
)
;
MOZ_DIAGNOSTIC_ASSERT
(
idx
<
mozilla
:
:
Telemetry
:
:
UserInteractionID
:
:
UserInteractionCount
"
Intermediate
lookup
should
always
give
a
valid
index
.
"
)
;
if
(
name
.
Equals
(
gUserInteractions
[
idx
]
.
name
(
)
)
)
{
return
true
;
}
return
false
;
}
