#
ifndef
Telemetry_h__
#
define
Telemetry_h__
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
StartupTimeline
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsStringGlue
.
h
"
#
include
"
mozilla
/
TelemetryHistogramEnums
.
h
"
#
include
"
mozilla
/
TelemetryScalarEnums
.
h
"
namespace
mozilla
{
namespace
HangMonitor
{
class
HangAnnotations
;
}
namespace
Telemetry
{
struct
Accumulation
;
struct
KeyedAccumulation
;
enum
TimerResolution
{
Millisecond
Microsecond
}
;
void
CreateStatisticsRecorder
(
)
;
void
DestroyStatisticsRecorder
(
)
;
void
Init
(
)
;
void
Accumulate
(
ID
id
uint32_t
sample
)
;
void
Accumulate
(
ID
id
const
nsCString
&
key
uint32_t
sample
=
1
)
;
void
Accumulate
(
const
char
*
name
uint32_t
sample
)
;
void
Accumulate
(
const
char
*
name
const
nsCString
&
key
uint32_t
sample
=
1
)
;
template
<
class
E
>
void
AccumulateCategorical
(
E
enumValue
)
{
static_assert
(
IsCategoricalLabelEnum
<
E
>
:
:
value
"
Only
categorical
label
enum
types
are
supported
.
"
)
;
Accumulate
(
static_cast
<
ID
>
(
CategoricalLabelId
<
E
>
:
:
value
)
static_cast
<
uint32_t
>
(
enumValue
)
)
;
}
;
void
AccumulateCategorical
(
ID
id
const
nsCString
&
label
)
;
void
AccumulateTimeDelta
(
ID
id
TimeStamp
start
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
)
;
void
AccumulateChild
(
const
nsTArray
<
Accumulation
>
&
aAccumulations
)
;
void
AccumulateChildKeyed
(
const
nsTArray
<
KeyedAccumulation
>
&
aAccumulations
)
;
void
SetHistogramRecordingEnabled
(
ID
id
bool
enabled
)
;
const
char
*
GetHistogramName
(
ID
id
)
;
template
<
TimerResolution
res
>
struct
AccumulateDelta_impl
{
static
void
compute
(
ID
id
TimeStamp
start
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
)
;
static
void
compute
(
ID
id
const
nsCString
&
key
TimeStamp
start
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
)
;
}
;
template
<
>
struct
AccumulateDelta_impl
<
Millisecond
>
{
static
void
compute
(
ID
id
TimeStamp
start
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
)
{
Accumulate
(
id
static_cast
<
uint32_t
>
(
(
end
-
start
)
.
ToMilliseconds
(
)
)
)
;
}
static
void
compute
(
ID
id
const
nsCString
&
key
TimeStamp
start
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
)
{
Accumulate
(
id
key
static_cast
<
uint32_t
>
(
(
end
-
start
)
.
ToMilliseconds
(
)
)
)
;
}
}
;
template
<
>
struct
AccumulateDelta_impl
<
Microsecond
>
{
static
void
compute
(
ID
id
TimeStamp
start
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
)
{
Accumulate
(
id
static_cast
<
uint32_t
>
(
(
end
-
start
)
.
ToMicroseconds
(
)
)
)
;
}
static
void
compute
(
ID
id
const
nsCString
&
key
TimeStamp
start
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
)
{
Accumulate
(
id
key
static_cast
<
uint32_t
>
(
(
end
-
start
)
.
ToMicroseconds
(
)
)
)
;
}
}
;
template
<
ID
id
TimerResolution
res
=
Millisecond
>
class
MOZ_RAII
AutoTimer
{
public
:
explicit
AutoTimer
(
TimeStamp
aStart
=
TimeStamp
:
:
Now
(
)
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
start
(
aStart
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
explicit
AutoTimer
(
const
nsCString
&
aKey
TimeStamp
aStart
=
TimeStamp
:
:
Now
(
)
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
start
(
aStart
)
key
(
aKey
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoTimer
(
)
{
if
(
key
.
IsEmpty
(
)
)
{
AccumulateDelta_impl
<
res
>
:
:
compute
(
id
start
)
;
}
else
{
AccumulateDelta_impl
<
res
>
:
:
compute
(
id
key
start
)
;
}
}
private
:
const
TimeStamp
start
;
const
nsCString
key
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
template
<
ID
id
>
class
MOZ_RAII
AutoCounter
{
public
:
explicit
AutoCounter
(
uint32_t
counterStart
=
0
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
counter
(
counterStart
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoCounter
(
)
{
Accumulate
(
id
counter
)
;
}
void
operator
+
+
(
)
{
+
+
counter
;
}
void
operator
+
=
(
int
increment
)
{
counter
+
=
increment
;
}
private
:
uint32_t
counter
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
bool
CanRecordBase
(
)
;
bool
CanRecordExtended
(
)
;
void
RecordSlowSQLStatement
(
const
nsACString
&
statement
const
nsACString
&
dbName
uint32_t
delay
)
;
void
RecordWebrtcIceCandidates
(
const
uint32_t
iceCandidateBitmask
const
bool
success
const
bool
loop
)
;
void
InitIOReporting
(
nsIFile
*
aXreDir
)
;
void
SetProfileDir
(
nsIFile
*
aProfD
)
;
void
LeavingStartupStage
(
)
;
void
EnteringShutdownStage
(
)
;
const
uint32_t
kSlowSQLThresholdForMainThread
=
50
;
const
uint32_t
kSlowSQLThresholdForHelperThreads
=
100
;
class
ProcessedStack
;
#
if
defined
(
MOZ_ENABLE_PROFILER_SPS
)
void
RecordChromeHang
(
uint32_t
aDuration
ProcessedStack
&
aStack
int32_t
aSystemUptime
int32_t
aFirefoxUptime
mozilla
:
:
UniquePtr
<
mozilla
:
:
HangMonitor
:
:
HangAnnotations
>
aAnnotations
)
;
#
endif
class
ThreadHangStats
;
void
RecordThreadHangStats
(
ThreadHangStats
&
aStats
)
;
void
WriteFailedProfileLock
(
nsIFile
*
aProfileDir
)
;
void
ScalarAdd
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
;
void
ScalarSet
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
;
void
ScalarSet
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
bool
aValue
)
;
void
ScalarSet
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aValue
)
;
void
ScalarSetMaximum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
;
void
ScalarAdd
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
;
void
ScalarSet
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
;
void
ScalarSet
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
bool
aValue
)
;
void
ScalarSetMaximum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
;
}
}
#
endif
