"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetryHealthPing
"
"
Policy
"
]
;
const
{
TelemetryUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
TelemetryController
"
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
clearTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
Utils
=
TelemetryUtils
;
const
MS_IN_A_MINUTE
=
60
*
1000
;
const
SEND_TICK_DELAY
=
60
*
MS_IN_A_MINUTE
;
const
MAX_SEND_DISCARDED_PINGS
=
10
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
LOGGER_PREFIX
=
"
TelemetryHealthPing
:
:
"
;
var
Policy
=
{
setSchedulerTickTimeout
:
(
callback
delayMs
)
=
>
lazy
.
setTimeout
(
callback
delayMs
)
clearSchedulerTickTimeout
:
id
=
>
lazy
.
clearTimeout
(
id
)
}
;
var
TelemetryHealthPing
=
{
Reason
:
Object
.
freeze
(
{
IMMEDIATE
:
"
immediate
"
DELAYED
:
"
delayed
"
SHUT_DOWN
:
"
shutdown
"
}
)
FailureType
:
Object
.
freeze
(
{
DISCARDED_FOR_SIZE
:
"
pingDiscardedForSize
"
SEND_FAILURE
:
"
sendFailure
"
}
)
OsInfo
:
Object
.
freeze
(
{
name
:
Services
.
appinfo
.
OS
version
:
Services
.
sysinfo
.
get
(
"
kernel_version
"
)
|
|
Services
.
sysinfo
.
get
(
"
version
"
)
}
)
HEALTH_PING_TYPE
:
"
health
"
_logger
:
null
_lastSendTime
:
-
SEND_TICK_DELAY
_failures
:
{
}
_timeoutId
:
null
recordSendFailure
(
failureType
)
{
return
this
.
_addToFailure
(
this
.
FailureType
.
SEND_FAILURE
failureType
)
;
}
recordDiscardedPing
(
pingType
)
{
return
this
.
_addToFailure
(
this
.
FailureType
.
DISCARDED_FOR_SIZE
pingType
)
;
}
_assemblePayload
(
reason
)
{
this
.
_log
.
trace
(
"
_assemblePayload
(
)
"
)
;
let
payload
=
{
os
:
this
.
OsInfo
reason
}
;
for
(
let
key
of
Object
.
keys
(
this
.
_failures
)
)
{
if
(
key
=
=
=
this
.
FailureType
.
DISCARDED_FOR_SIZE
)
{
payload
[
key
]
=
this
.
_getTopDiscardFailures
(
this
.
_failures
[
key
]
)
;
}
else
{
payload
[
key
]
=
this
.
_failures
[
key
]
;
}
}
return
payload
;
}
_getTopDiscardFailures
(
failures
)
{
this
.
_log
.
trace
(
"
_getTopDiscardFailures
(
)
"
)
;
let
sortedItems
=
Object
.
entries
(
failures
)
.
sort
(
(
first
second
)
=
>
{
return
second
[
1
]
-
first
[
1
]
;
}
)
;
let
result
=
{
}
;
sortedItems
.
slice
(
0
MAX_SEND_DISCARDED_PINGS
)
.
forEach
(
(
[
key
value
]
)
=
>
{
result
[
key
]
=
value
;
}
)
;
return
result
;
}
_submitPing
(
reason
)
{
if
(
!
TelemetryHealthPing
.
enabled
|
|
!
this
.
_hasDataToSend
(
)
)
{
return
Promise
.
resolve
(
)
;
}
this
.
_log
.
trace
(
"
_submitPing
(
"
+
reason
+
"
)
"
)
;
let
payload
=
this
.
_assemblePayload
(
reason
)
;
this
.
_clearData
(
)
;
this
.
_lastSendTime
=
Utils
.
monotonicNow
(
)
;
let
options
=
{
addClientId
:
true
usePingSender
:
reason
=
=
=
this
.
Reason
.
SHUT_DOWN
}
;
return
new
Promise
(
r
=
>
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
r
(
lazy
.
TelemetryController
.
submitExternalPing
(
this
.
HEALTH_PING_TYPE
payload
options
)
)
)
)
;
}
_addToFailure
(
failureType
failureSubType
)
{
this
.
_log
.
trace
(
"
_addToFailure
(
)
-
with
type
and
subtype
:
"
+
failureType
+
"
:
"
+
failureSubType
)
;
if
(
!
(
failureType
in
this
.
_failures
)
)
{
this
.
_failures
[
failureType
]
=
{
}
;
}
let
current
=
this
.
_failures
[
failureType
]
[
failureSubType
]
|
|
0
;
this
.
_failures
[
failureType
]
[
failureSubType
]
=
current
+
1
;
const
now
=
Utils
.
monotonicNow
(
)
;
if
(
now
-
this
.
_lastSendTime
>
=
SEND_TICK_DELAY
)
{
return
this
.
_submitPing
(
this
.
Reason
.
IMMEDIATE
)
;
}
let
submissionDelay
=
SEND_TICK_DELAY
-
now
-
this
.
_lastSendTime
;
this
.
_timeoutId
=
Policy
.
setSchedulerTickTimeout
(
(
)
=
>
TelemetryHealthPing
.
_submitPing
(
this
.
Reason
.
DELAYED
)
submissionDelay
)
;
return
Promise
.
resolve
(
)
;
}
_hasDataToSend
(
)
{
return
Object
.
keys
(
this
.
_failures
)
.
length
!
=
=
0
;
}
_clearData
(
)
{
this
.
_log
.
trace
(
"
_clearData
(
)
"
)
;
this
.
_failures
=
{
}
;
}
_resetTimeout
(
)
{
if
(
this
.
_timeoutId
)
{
Policy
.
clearSchedulerTickTimeout
(
this
.
_timeoutId
)
;
this
.
_timeoutId
=
null
;
}
}
shutdown
(
)
{
this
.
_log
.
trace
(
"
shutdown
(
)
"
)
;
this
.
_resetTimeout
(
)
;
return
this
.
_submitPing
(
this
.
Reason
.
SHUT_DOWN
)
;
}
testReset
(
)
{
this
.
_lastSendTime
=
-
SEND_TICK_DELAY
;
this
.
_clearData
(
)
;
this
.
_resetTimeout
(
)
;
}
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
lazy
.
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
+
"
:
:
"
)
;
}
return
this
.
_logger
;
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
TelemetryHealthPing
"
enabled
"
TelemetryUtils
.
Preferences
.
HealthPingEnabled
true
)
;
