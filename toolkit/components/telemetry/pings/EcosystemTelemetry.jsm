"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
EcosystemTelemetry
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Weave
:
"
resource
:
/
/
services
-
sync
/
main
.
js
"
ONLOGIN_NOTIFICATION
:
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
ONLOGOUT_NOTIFICATION
:
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
TelemetryController
:
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
TelemetryUtils
:
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
TelemetryEnvironment
:
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
Telemetry
:
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
"
nsITelemetry
"
]
}
)
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
LOGGER_PREFIX
=
"
EcosystemTelemetry
:
:
"
;
var
Policy
=
{
sendPing
:
(
type
payload
options
)
=
>
TelemetryController
.
submitExternalPing
(
type
payload
options
)
monotonicNow
:
(
)
=
>
TelemetryUtils
.
monotonicNow
(
)
fxaUid
:
(
)
=
>
{
try
{
return
Weave
.
Service
.
identity
.
hashedUID
(
)
;
}
catch
(
ex
)
{
return
null
;
}
}
isClientConfigured
:
(
)
=
>
Weave
.
Status
.
checkSetup
(
)
!
=
=
Weave
.
CLIENT_NOT_CONFIGURED
}
;
var
EcosystemTelemetry
=
{
Reason
:
Object
.
freeze
(
{
PERIODIC
:
"
periodic
"
SHUTDOWN
:
"
shutdown
"
LOGIN
:
"
login
"
LOGOUT
:
"
logout
"
}
)
PingType
:
Object
.
freeze
(
{
PRE
:
"
pre
-
account
"
POST
:
"
post
-
account
"
}
)
METRICS_STORE
:
"
pre
-
account
"
_logger
:
null
_lastSendTime
:
0
_pingType
:
null
_uidPending
:
false
_initialized
:
false
enabled
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
Unified
false
)
)
{
return
false
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryEnabled
false
)
)
{
return
false
;
}
return
true
;
}
startup
(
)
{
if
(
!
this
.
enabled
(
)
)
{
return
;
}
this
.
_log
.
trace
(
"
Starting
up
.
"
)
;
this
.
_addObservers
(
)
;
this
.
_pingType
=
this
.
PingType
.
PRE
;
this
.
_initialized
=
true
;
}
shutdown
(
)
{
if
(
!
this
.
enabled
(
)
)
{
return
;
}
this
.
_log
.
trace
(
"
Shutting
down
.
"
)
;
this
.
_submitPing
(
this
.
_pingType
this
.
Reason
.
SHUTDOWN
)
;
this
.
_removeObservers
(
)
;
}
_addObservers
(
)
{
Services
.
obs
.
addObserver
(
this
ONLOGIN_NOTIFICATION
)
;
Services
.
obs
.
addObserver
(
this
ONLOGOUT_NOTIFICATION
)
;
Services
.
obs
.
addObserver
(
this
"
weave
:
service
:
ready
"
)
;
Services
.
obs
.
addObserver
(
this
"
weave
:
service
:
login
:
change
"
)
;
}
_removeObservers
(
)
{
try
{
Services
.
obs
.
removeObserver
(
this
ONLOGIN_NOTIFICATION
)
;
Services
.
obs
.
removeObserver
(
this
ONLOGOUT_NOTIFICATION
)
;
Services
.
obs
.
removeObserver
(
this
"
weave
:
service
:
ready
"
)
;
Services
.
obs
.
removeObserver
(
this
"
weave
:
service
:
login
:
change
"
)
;
}
catch
(
ex
)
{
}
}
observe
(
subject
topic
data
)
{
this
.
_log
.
trace
(
observe
topic
:
{
topic
}
)
;
switch
(
topic
)
{
case
ONLOGIN_NOTIFICATION
:
this
.
_uidPending
=
true
;
break
;
case
ONLOGOUT_NOTIFICATION
:
this
.
_uidPending
=
false
;
this
.
_pingType
=
this
.
PingType
.
PRE
;
this
.
_submitPing
(
this
.
_pingType
this
.
Reason
.
LOGOUT
)
;
break
;
case
"
weave
:
service
:
login
:
change
"
:
let
uid
=
Policy
.
fxaUid
(
)
;
if
(
this
.
_uidPending
&
&
uid
)
{
this
.
_submitPing
(
this
.
_pingType
this
.
Reason
.
LOGIN
)
;
this
.
_pingType
=
this
.
PingType
.
POST
;
this
.
_uidPending
=
false
;
}
else
if
(
!
this
.
_uidPending
&
&
uid
)
{
this
.
_pingType
=
this
.
PingType
.
POST
;
}
else
if
(
!
uid
)
{
this
.
_pingType
=
this
.
PingType
.
PRE
;
}
break
;
case
"
weave
:
service
:
ready
"
:
if
(
Policy
.
isClientConfigured
(
)
)
{
this
.
_pingType
=
this
.
PingType
.
POST
;
}
else
{
this
.
_pingType
=
this
.
PingType
.
PRE
;
}
break
;
}
}
periodicPing
(
)
{
this
.
_log
.
trace
(
"
periodic
ping
triggered
"
)
;
this
.
_submitPing
(
this
.
_pingType
this
.
Reason
.
PERIODIC
)
;
}
_submitPing
(
pingType
reason
)
{
if
(
!
this
.
enabled
(
)
)
{
this
.
_log
.
trace
(
_submitPing
was
called
but
ping
is
not
enabled
.
Bug
?
)
;
return
;
}
if
(
!
this
.
_initialized
|
|
!
pingType
)
{
this
.
_log
.
trace
(
Not
initialized
or
ping
type
undefined
when
sending
.
Bug
?
)
;
return
;
}
if
(
pingType
=
=
this
.
PingType
.
POST
)
{
this
.
_log
.
trace
(
Post
-
account
ping
not
implemented
yet
.
Sending
pre
-
account
instead
.
)
;
pingType
=
this
.
PingType
.
PRE
;
}
this
.
_log
.
trace
(
_submitPing
ping
type
:
{
pingType
}
reason
:
{
reason
}
)
;
let
now
=
Policy
.
monotonicNow
(
)
;
let
new_send_time
=
now
;
let
old_send_time
=
this
.
_lastSendTime
;
let
duration
=
Math
.
round
(
(
now
-
this
.
_lastSendTime
)
/
1000
)
;
this
.
_lastSendTime
=
now
;
Services
.
telemetry
.
scalarSet
(
"
telemetry
.
ecosystem_old_send_time
"
old_send_time
.
toString
(
)
)
;
Services
.
telemetry
.
scalarSet
(
"
telemetry
.
ecosystem_new_send_time
"
new_send_time
.
toString
(
)
)
;
let
payload
=
this
.
_payload
(
reason
duration
)
;
const
options
=
{
addClientId
:
false
addEnvironment
:
true
overrideEnvironment
:
this
.
_environment
(
)
usePingSender
:
reason
=
=
=
this
.
Reason
.
SHUTDOWN
}
;
Policy
.
sendPing
(
pingType
payload
options
)
;
}
_payload
(
reason
duration
)
{
let
payload
=
{
reason
ecosystemClientId
:
this
.
_ecosystemClientId
(
)
duration
scalars
:
Telemetry
.
getSnapshotForScalars
(
this
.
METRICS_STORE
true
true
)
keyedScalars
:
Telemetry
.
getSnapshotForKeyedScalars
(
this
.
METRICS_STORE
true
true
)
histograms
:
Telemetry
.
getSnapshotForHistograms
(
this
.
METRICS_STORE
true
true
)
keyedHistograms
:
Telemetry
.
getSnapshotForKeyedHistograms
(
this
.
METRICS_STORE
true
true
)
}
;
if
(
this
.
_pingType
=
=
this
.
PingType
.
POST
|
|
reason
=
=
this
.
Reason
.
LOGIN
)
{
let
uid
=
Policy
.
fxaUid
(
)
;
if
(
uid
)
{
payload
.
uid
=
"
00000000000000000000000000000000
"
;
}
}
return
payload
;
}
_ecosystemClientId
(
)
{
return
"
unknown
"
;
}
_environment
(
)
{
let
currentEnv
=
TelemetryEnvironment
.
currentEnvironment
;
let
environment
=
{
settings
:
{
locale
:
currentEnv
.
settings
.
locale
}
system
:
{
memoryMB
:
currentEnv
.
system
.
memoryMB
os
:
{
name
:
currentEnv
.
system
.
os
.
name
version
:
currentEnv
.
system
.
os
.
version
locale
:
currentEnv
.
system
.
os
.
locale
}
cpu
:
{
speedMHz
:
currentEnv
.
system
.
cpu
.
speedMHz
}
}
profile
:
{
}
}
;
if
(
currentEnv
.
profile
.
creationDate
)
{
environment
.
profile
.
creationDate
=
currentEnv
.
profile
.
creationDate
;
}
if
(
currentEnv
.
profile
.
firstUseDate
)
{
environment
.
profile
.
firstUseDate
=
currentEnv
.
profile
.
firstUseDate
;
}
return
environment
;
}
testReset
(
)
{
this
.
_initialized
=
false
;
this
.
_lastSendTime
=
0
;
this
.
startup
(
)
;
}
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
)
;
}
return
this
.
_logger
;
}
}
;
