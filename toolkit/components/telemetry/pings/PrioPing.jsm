"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetryPrioPing
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
TelemetryController
:
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
Telemetry
:
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
"
nsITelemetry
"
]
}
)
;
const
{
setTimeout
clearTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
{
TelemetryUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
Utils
=
TelemetryUtils
;
const
MILLISECONDS_PER_HOUR
=
60
*
60
*
1000
;
const
DEFAULT_PING_FREQUENCY_HOURS
=
24
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
LOGGER_PREFIX
=
"
TelemetryPrioPing
"
;
const
PRIO_LIMIT_REACHED_TOPIC
=
"
origin
-
telemetry
-
storage
-
limit
-
reached
"
;
const
PRIO_PING_VERSION
=
"
1
"
;
var
Policy
=
{
setTimeout
:
(
callback
delayMs
)
=
>
setTimeout
(
callback
delayMs
)
clearTimeout
:
(
id
)
=
>
clearTimeout
(
id
)
sendPing
:
(
type
payload
options
)
=
>
TelemetryController
.
submitExternalPing
(
type
payload
options
)
getEncodedOriginSnapshot
:
async
(
aClear
)
=
>
Telemetry
.
getEncodedOriginSnapshot
(
aClear
)
}
;
var
TelemetryPrioPing
=
{
Reason
:
Object
.
freeze
(
{
PERIODIC
:
"
periodic
"
MAX
:
"
max
"
SHUTDOWN
:
"
shutdown
"
}
)
PRIO_PING_TYPE
:
"
prio
"
_logger
:
null
_testing
:
false
_timeoutId
:
null
startup
(
)
{
if
(
!
this
.
_testing
&
&
!
Services
.
prefs
.
getBoolPref
(
Utils
.
Preferences
.
PrioPingEnabled
false
)
)
{
this
.
_log
.
trace
(
"
Prio
ping
disabled
.
"
)
;
return
;
}
this
.
_log
.
trace
(
"
Starting
up
.
"
)
;
Services
.
obs
.
addObserver
(
this
PRIO_LIMIT_REACHED_TOPIC
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
pingFrequency
"
Utils
.
Preferences
.
PrioPingFrequency
DEFAULT_PING_FREQUENCY_HOURS
)
;
this
.
_startTimer
(
)
;
}
async
shutdown
(
)
{
this
.
_log
.
trace
(
"
Shutting
down
.
"
)
;
try
{
Services
.
obs
.
removeObserver
(
this
PRIO_LIMIT_REACHED_TOPIC
)
;
}
catch
(
ex
)
{
}
await
this
.
_submitPing
(
this
.
Reason
.
SHUTDOWN
)
;
this
.
_clearTimer
(
)
;
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
PRIO_LIMIT_REACHED_TOPIC
:
this
.
_log
.
trace
(
"
prio
limit
reached
"
)
;
this
.
_submitPing
(
this
.
Reason
.
MAX
)
;
break
;
}
}
_startTimer
(
delay
=
this
.
pingFrequency
*
MILLISECONDS_PER_HOUR
reason
=
this
.
Reason
.
PERIODIC
discardLeftovers
=
false
)
{
this
.
_clearTimer
(
)
;
this
.
_timeoutId
=
Policy
.
setTimeout
(
(
)
=
>
TelemetryPrioPing
.
_submitPing
(
reason
)
delay
)
;
}
_clearTimer
(
)
{
if
(
this
.
_timeoutId
)
{
Policy
.
clearTimeout
(
this
.
_timeoutId
)
;
this
.
_timeoutId
=
null
;
}
}
async
_submitPing
(
reason
)
{
this
.
_log
.
trace
(
"
_submitPing
"
)
;
if
(
reason
!
=
=
this
.
Reason
.
SHUTDOWN
)
{
this
.
_startTimer
(
)
;
}
let
snapshot
=
await
Policy
.
getEncodedOriginSnapshot
(
true
)
;
if
(
!
this
.
_testing
)
{
snapshot
=
snapshot
.
filter
(
(
{
encoding
}
)
=
>
!
encoding
.
startsWith
(
"
telemetry
.
test
"
)
)
;
}
if
(
snapshot
.
length
=
=
=
0
)
{
this
.
_log
.
trace
(
"
nothing
to
send
"
)
;
return
;
}
let
payload
=
{
version
:
PRIO_PING_VERSION
reason
prioData
:
snapshot
}
;
const
options
=
{
addClientId
:
false
addEnvironment
:
false
usePingSender
:
reason
=
=
=
this
.
Reason
.
SHUTDOWN
}
;
Policy
.
sendPing
(
this
.
PRIO_PING_TYPE
payload
options
)
;
}
testReset
(
)
{
this
.
_clearTimer
(
)
;
this
.
_testing
=
true
;
}
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
+
"
:
:
"
)
;
}
return
this
.
_logger
;
}
}
;
