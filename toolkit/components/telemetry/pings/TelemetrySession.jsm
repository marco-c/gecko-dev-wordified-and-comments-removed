"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManagerPrivate
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
TelemetryController
:
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
TelemetryStorage
:
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
MemoryTelemetry
:
"
resource
:
/
/
gre
/
modules
/
MemoryTelemetry
.
jsm
"
UITelemetry
:
"
resource
:
/
/
gre
/
modules
/
UITelemetry
.
jsm
"
GCTelemetry
:
"
resource
:
/
/
gre
/
modules
/
GCTelemetry
.
jsm
"
TelemetryEnvironment
:
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
TelemetryReportingPolicy
:
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
}
)
;
const
Utils
=
TelemetryUtils
;
const
myScope
=
this
;
const
PAYLOAD_VERSION
=
4
;
const
PING_TYPE_MAIN
=
"
main
"
;
const
PING_TYPE_SAVED_SESSION
=
"
saved
-
session
"
;
const
REASON_ABORTED_SESSION
=
"
aborted
-
session
"
;
const
REASON_DAILY
=
"
daily
"
;
const
REASON_SAVED_SESSION
=
"
saved
-
session
"
;
const
REASON_GATHER_PAYLOAD
=
"
gather
-
payload
"
;
const
REASON_GATHER_SUBSESSION_PAYLOAD
=
"
gather
-
subsession
-
payload
"
;
const
REASON_TEST_PING
=
"
test
-
ping
"
;
const
REASON_ENVIRONMENT_CHANGE
=
"
environment
-
change
"
;
const
REASON_SHUTDOWN
=
"
shutdown
"
;
const
ENVIRONMENT_CHANGE_LISTENER
=
"
TelemetrySession
:
:
onEnvironmentChange
"
;
const
MIN_SUBSESSION_LENGTH_MS
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
minSubsessionLength
"
5
*
60
)
*
1000
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
LOGGER_PREFIX
=
"
TelemetrySession
"
+
(
Utils
.
isContentProcess
?
"
#
content
:
:
"
:
"
:
:
"
)
;
const
IS_UNIFIED_TELEMETRY
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
const
SCHEDULER_TICK_INTERVAL_MS
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
scheduler
.
tickInterval
"
5
*
60
)
*
1000
;
const
SCHEDULER_TICK_IDLE_INTERVAL_MS
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
scheduler
.
idleTickInterval
"
60
*
60
)
*
1000
;
const
SCHEDULER_MIDNIGHT_TOLERANCE_MS
=
15
*
60
*
1000
;
const
SCHEDULER_TICK_MAX_IDLE_DELAY_MS
=
60
*
1000
;
const
IDLE_TIMEOUT_SECONDS
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
idleTimeout
"
5
*
60
)
;
const
ABORTED_SESSION_UPDATE_INTERVAL_MS
=
5
*
60
*
1000
;
const
PRIO_ENABLED_PREF
=
"
prio
.
enabled
"
;
var
gWasDebuggerAttached
=
false
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
Telemetry
:
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
"
nsITelemetry
"
]
idleService
:
[
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
"
nsIIdleService
"
]
}
)
;
function
generateUUID
(
)
{
let
str
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
return
str
.
substring
(
1
str
.
length
-
1
)
;
}
function
getMsSinceProcessStart
(
)
{
try
{
return
Telemetry
.
msSinceProcessStart
(
)
;
}
catch
(
ex
)
{
return
-
1
;
}
}
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
monotonicNow
:
getMsSinceProcessStart
generateSessionUUID
:
(
)
=
>
generateUUID
(
)
generateSubsessionUUID
:
(
)
=
>
generateUUID
(
)
setSchedulerTickTimeout
:
(
callback
delayMs
)
=
>
setTimeout
(
callback
delayMs
)
clearSchedulerTickTimeout
:
id
=
>
clearTimeout
(
id
)
prioEncode
:
(
batchID
prioParams
)
=
>
PrioEncoder
.
encode
(
batchID
prioParams
)
}
;
function
getPingType
(
aPayload
)
{
if
(
aPayload
.
info
.
reason
=
=
REASON_SAVED_SESSION
)
{
return
PING_TYPE_SAVED_SESSION
;
}
return
PING_TYPE_MAIN
;
}
function
annotateCrashReport
(
sessionId
)
{
try
{
const
cr
=
Cc
[
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
]
;
if
(
cr
)
{
cr
.
getService
(
Ci
.
nsICrashReporter
)
.
setTelemetrySessionId
(
sessionId
)
;
}
}
catch
(
e
)
{
}
}
var
processInfo
=
{
_initialized
:
false
_IO_COUNTERS
:
null
_kernel32
:
null
_GetProcessIoCounters
:
null
_GetCurrentProcess
:
null
getCounters
(
)
{
let
isWindows
=
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
in
Cc
)
;
if
(
isWindows
)
return
this
.
getCounters_Windows
(
)
;
return
null
;
}
getCounters_Windows
(
)
{
if
(
!
this
.
_initialized
)
{
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
this
.
_IO_COUNTERS
=
new
ctypes
.
StructType
(
"
IO_COUNTERS
"
[
{
"
readOps
"
:
ctypes
.
unsigned_long_long
}
{
"
writeOps
"
:
ctypes
.
unsigned_long_long
}
{
"
otherOps
"
:
ctypes
.
unsigned_long_long
}
{
"
readBytes
"
:
ctypes
.
unsigned_long_long
}
{
"
writeBytes
"
:
ctypes
.
unsigned_long_long
}
{
"
otherBytes
"
:
ctypes
.
unsigned_long_long
}
]
)
;
try
{
this
.
_kernel32
=
ctypes
.
open
(
"
Kernel32
.
dll
"
)
;
this
.
_GetProcessIoCounters
=
this
.
_kernel32
.
declare
(
"
GetProcessIoCounters
"
ctypes
.
winapi_abi
ctypes
.
bool
ctypes
.
voidptr_t
this
.
_IO_COUNTERS
.
ptr
)
;
this
.
_GetCurrentProcess
=
this
.
_kernel32
.
declare
(
"
GetCurrentProcess
"
ctypes
.
winapi_abi
ctypes
.
voidptr_t
)
;
this
.
_initialized
=
true
;
}
catch
(
err
)
{
return
null
;
}
}
let
io
=
new
this
.
_IO_COUNTERS
(
)
;
if
(
!
this
.
_GetProcessIoCounters
(
this
.
_GetCurrentProcess
(
)
io
.
address
(
)
)
)
return
null
;
return
[
parseInt
(
io
.
readBytes
)
parseInt
(
io
.
writeBytes
)
]
;
}
}
;
var
TelemetryScheduler
=
{
_lastDailyPingTime
:
0
_lastSessionCheckpointTime
:
0
_lastAdhocPingTime
:
0
_lastTickTime
:
0
_log
:
null
_schedulerTimer
:
null
_schedulerInterval
:
0
_shuttingDown
:
true
_isUserIdle
:
false
init
(
)
{
this
.
_log
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
"
TelemetryScheduler
:
:
"
)
;
this
.
_log
.
trace
(
"
init
"
)
;
this
.
_shuttingDown
=
false
;
this
.
_isUserIdle
=
false
;
let
now
=
Policy
.
now
(
)
;
this
.
_lastDailyPingTime
=
now
.
getTime
(
)
;
this
.
_lastSessionCheckpointTime
=
now
.
getTime
(
)
;
this
.
_rescheduleTimeout
(
)
;
idleService
.
addIdleObserver
(
this
IDLE_TIMEOUT_SECONDS
)
;
Services
.
obs
.
addObserver
(
this
"
wake_notification
"
)
;
}
shutdown
(
)
{
if
(
this
.
_shuttingDown
)
{
if
(
this
.
_log
)
{
this
.
_log
.
error
(
"
shutdown
-
Already
shut
down
"
)
;
}
else
{
Cu
.
reportError
(
"
TelemetryScheduler
.
shutdown
-
Already
shut
down
"
)
;
}
return
;
}
this
.
_log
.
trace
(
"
shutdown
"
)
;
if
(
this
.
_schedulerTimer
)
{
Policy
.
clearSchedulerTickTimeout
(
this
.
_schedulerTimer
)
;
this
.
_schedulerTimer
=
null
;
}
idleService
.
removeIdleObserver
(
this
IDLE_TIMEOUT_SECONDS
)
;
Services
.
obs
.
removeObserver
(
this
"
wake_notification
"
)
;
this
.
_shuttingDown
=
true
;
}
_clearTimeout
(
)
{
if
(
this
.
_schedulerTimer
)
{
Policy
.
clearSchedulerTickTimeout
(
this
.
_schedulerTimer
)
;
}
}
_rescheduleTimeout
(
)
{
this
.
_log
.
trace
(
"
_rescheduleTimeout
-
isUserIdle
:
"
+
this
.
_isUserIdle
)
;
if
(
this
.
_shuttingDown
)
{
this
.
_log
.
warn
(
"
_rescheduleTimeout
-
already
shutdown
"
)
;
return
;
}
this
.
_clearTimeout
(
)
;
const
now
=
Policy
.
now
(
)
;
let
timeout
=
SCHEDULER_TICK_INTERVAL_MS
;
if
(
this
.
_isUserIdle
)
{
timeout
=
SCHEDULER_TICK_IDLE_INTERVAL_MS
;
const
nextMidnight
=
Utils
.
getNextMidnight
(
now
)
;
timeout
=
Math
.
min
(
timeout
nextMidnight
.
getTime
(
)
-
now
.
getTime
(
)
)
;
}
this
.
_log
.
trace
(
"
_rescheduleTimeout
-
scheduling
next
tick
for
"
+
new
Date
(
now
.
getTime
(
)
+
timeout
)
)
;
this
.
_schedulerTimer
=
Policy
.
setSchedulerTickTimeout
(
(
)
=
>
this
.
_onSchedulerTick
(
)
timeout
)
;
}
_sentDailyPingToday
(
nowDate
)
{
const
todayDate
=
Utils
.
truncateToDays
(
nowDate
)
;
return
(
this
.
_lastDailyPingTime
>
=
todayDate
.
getTime
(
)
)
;
}
_isDailyPingDue
(
nowDate
)
{
if
(
this
.
_sentDailyPingToday
(
nowDate
)
)
{
this
.
_log
.
trace
(
"
_isDailyPingDue
-
already
sent
one
today
"
)
;
return
false
;
}
const
timeSinceLastDaily
=
nowDate
.
getTime
(
)
-
this
.
_lastDailyPingTime
;
if
(
timeSinceLastDaily
<
MIN_SUBSESSION_LENGTH_MS
)
{
this
.
_log
.
trace
(
"
_isDailyPingDue
-
delaying
daily
to
keep
minimum
session
length
"
)
;
return
false
;
}
this
.
_log
.
trace
(
"
_isDailyPingDue
-
is
due
"
)
;
return
true
;
}
_saveAbortedPing
(
now
competingPayload
=
null
)
{
this
.
_lastSessionCheckpointTime
=
now
;
return
Impl
.
_saveAbortedSessionPing
(
competingPayload
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
_saveAbortedPing
-
Failed
"
e
)
)
;
}
observe
(
aSubject
aTopic
aData
)
{
this
.
_log
.
trace
(
"
observe
-
aTopic
:
"
+
aTopic
)
;
switch
(
aTopic
)
{
case
"
idle
"
:
this
.
_isUserIdle
=
true
;
return
this
.
_onSchedulerTick
(
)
;
case
"
active
"
:
this
.
_isUserIdle
=
false
;
return
this
.
_onSchedulerTick
(
true
)
;
case
"
wake_notification
"
:
return
this
.
_onSchedulerTick
(
true
)
;
}
return
undefined
;
}
_makeIdleDispatch
(
dispatchFn
)
{
this
.
_log
.
trace
(
"
_makeIdleDispatch
"
)
;
let
fn
=
dispatchFn
;
let
l
=
(
msg
)
=
>
this
.
_log
.
trace
(
msg
)
;
return
{
cancel
(
)
{
fn
=
undefined
;
}
dispatch
(
resolve
reject
)
{
l
(
"
_makeIdleDispatch
.
dispatch
-
!
!
fn
:
"
+
!
!
fn
)
;
if
(
!
fn
)
{
return
Promise
.
resolve
(
)
.
then
(
resolve
reject
)
;
}
return
fn
(
resolve
reject
)
;
}
}
;
}
_onSchedulerTick
(
dispatchOnIdle
=
false
)
{
this
.
_log
.
trace
(
"
_onSchedulerTick
-
dispatchOnIdle
:
"
+
dispatchOnIdle
)
;
this
.
_clearTimeout
(
)
;
if
(
this
.
_idleDispatch
)
{
this
.
_idleDispatch
.
cancel
(
)
;
}
if
(
this
.
_shuttingDown
)
{
this
.
_log
.
warn
(
"
_onSchedulerTick
-
already
shutdown
.
"
)
;
return
Promise
.
reject
(
new
Error
(
"
Already
shutdown
.
"
)
)
;
}
let
promise
=
Promise
.
resolve
(
)
;
try
{
if
(
dispatchOnIdle
)
{
this
.
_idleDispatch
=
this
.
_makeIdleDispatch
(
(
resolve
reject
)
=
>
{
this
.
_log
.
trace
(
"
_onSchedulerTick
-
ildeDispatchToMainThread
dispatch
"
)
;
return
this
.
_schedulerTickLogic
(
)
.
then
(
resolve
reject
)
;
}
)
;
promise
=
new
Promise
(
(
resolve
reject
)
=
>
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
return
this
.
_idleDispatch
?
this
.
_idleDispatch
.
dispatch
(
resolve
reject
)
:
Promise
.
resolve
(
)
.
then
(
resolve
reject
)
;
}
SCHEDULER_TICK_MAX_IDLE_DELAY_MS
)
)
;
}
else
{
promise
=
this
.
_schedulerTickLogic
(
)
;
}
}
catch
(
e
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_SCHEDULER_TICK_EXCEPTION
"
)
.
add
(
1
)
;
this
.
_log
.
error
(
"
_onSchedulerTick
-
There
was
an
exception
"
e
)
;
}
finally
{
this
.
_rescheduleTimeout
(
)
;
}
return
promise
;
}
_schedulerTickLogic
(
)
{
this
.
_log
.
trace
(
"
_schedulerTickLogic
"
)
;
let
nowDate
=
Policy
.
now
(
)
;
let
now
=
nowDate
.
getTime
(
)
;
if
(
(
now
-
this
.
_lastTickTime
)
>
(
1
.
1
*
SCHEDULER_TICK_INTERVAL_MS
)
&
&
(
this
.
_lastTickTime
!
=
0
)
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_SCHEDULER_WAKEUP
"
)
.
add
(
1
)
;
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
First
scheduler
tick
after
sleep
.
"
)
;
}
this
.
_lastTickTime
=
now
;
const
shouldSendDaily
=
this
.
_isDailyPingDue
(
nowDate
)
;
if
(
shouldSendDaily
)
{
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
Daily
ping
due
.
"
)
;
this
.
_lastDailyPingTime
=
now
;
return
Impl
.
_sendDailyPing
(
)
;
}
const
isAbortedPingDue
=
(
now
-
this
.
_lastSessionCheckpointTime
)
>
=
ABORTED_SESSION_UPDATE_INTERVAL_MS
;
if
(
isAbortedPingDue
)
{
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
Aborted
session
ping
due
.
"
)
;
return
this
.
_saveAbortedPing
(
now
)
;
}
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
No
ping
due
.
"
)
;
return
Promise
.
resolve
(
)
;
}
reschedulePings
(
reason
competingPayload
=
null
)
{
if
(
this
.
_shuttingDown
)
{
this
.
_log
.
error
(
"
reschedulePings
-
already
shutdown
"
)
;
return
;
}
this
.
_log
.
trace
(
"
reschedulePings
-
reason
:
"
+
reason
)
;
let
now
=
Policy
.
now
(
)
;
this
.
_lastAdhocPingTime
=
now
.
getTime
(
)
;
if
(
reason
=
=
REASON_ENVIRONMENT_CHANGE
)
{
this
.
_saveAbortedPing
(
now
.
getTime
(
)
competingPayload
)
;
let
nearestMidnight
=
Utils
.
getNearestMidnight
(
now
SCHEDULER_MIDNIGHT_TOLERANCE_MS
)
;
if
(
nearestMidnight
)
{
this
.
_lastDailyPingTime
=
now
.
getTime
(
)
;
}
}
this
.
_rescheduleTimeout
(
)
;
}
}
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetrySession
"
]
;
var
TelemetrySession
=
Object
.
freeze
(
{
testPing
(
)
{
return
Impl
.
testPing
(
)
;
}
getPayload
(
reason
clearSubsession
=
false
)
{
return
Impl
.
getPayload
(
reason
clearSubsession
)
;
}
testSavePendingPing
(
)
{
return
Impl
.
testSavePendingPing
(
)
;
}
gatherStartup
(
)
{
return
Impl
.
gatherStartup
(
)
;
}
setAddOns
(
aAddOns
)
{
return
Impl
.
setAddOns
(
aAddOns
)
;
}
getMetadata
(
reason
)
{
return
Impl
.
getMetadata
(
reason
)
;
}
resetSubsessionCounter
(
)
{
Impl
.
_subsessionCounter
=
0
;
Impl
.
_profileSubsessionCounter
=
0
;
}
testReset
(
)
{
Impl
.
_newProfilePingSent
=
false
;
Impl
.
_sessionId
=
null
;
Impl
.
_subsessionId
=
null
;
Impl
.
_previousSessionId
=
null
;
Impl
.
_previousSubsessionId
=
null
;
Impl
.
_subsessionCounter
=
0
;
Impl
.
_profileSubsessionCounter
=
0
;
Impl
.
_subsessionStartActiveTicks
=
0
;
Impl
.
_sessionActiveTicks
=
0
;
Impl
.
_isUserActive
=
true
;
Impl
.
_subsessionStartTimeMonotonic
=
0
;
Impl
.
_lastEnvironmentChangeDate
=
Policy
.
monotonicNow
(
)
;
this
.
testUninstall
(
)
;
}
shutdown
(
)
{
return
Impl
.
shutdownChromeProcess
(
)
;
}
testUninstall
(
)
{
try
{
Impl
.
uninstall
(
)
;
}
catch
(
ex
)
{
}
}
earlyInit
(
aTesting
=
false
)
{
return
Impl
.
earlyInit
(
aTesting
)
;
}
delayedInit
(
)
{
return
Impl
.
delayedInit
(
)
;
}
observe
(
aSubject
aTopic
aData
)
{
return
Impl
.
observe
(
aSubject
aTopic
aData
)
;
}
markNewProfilePingSent
(
)
{
return
Impl
.
markNewProfilePingSent
(
)
;
}
get
newProfilePingSent
(
)
{
return
Impl
.
_newProfilePingSent
;
}
}
)
;
var
Impl
=
{
_initialized
:
false
_logger
:
null
_slowSQLStartup
:
{
}
_isUserActive
:
true
_startupIO
:
{
}
_previousBuildId
:
null
_sessionId
:
null
_subsessionId
:
null
_previousSessionId
:
null
_previousSubsessionId
:
null
_subsessionCounter
:
0
_profileSubsessionCounter
:
0
_subsessionStartDate
:
null
_subsessionStartTimeMonotonic
:
0
_subsessionStartActiveTicks
:
0
_sessionActiveTicks
:
0
_delayedInitTask
:
null
_testing
:
false
_lastEnvironmentChangeDate
:
0
_newProfilePingSent
:
false
_observedTopics
:
new
Set
(
)
addObserver
(
aTopic
)
{
Services
.
obs
.
addObserver
(
this
aTopic
)
;
this
.
_observedTopics
.
add
(
aTopic
)
;
}
removeObserver
(
aTopic
)
{
Services
.
obs
.
removeObserver
(
this
aTopic
)
;
this
.
_observedTopics
.
delete
(
aTopic
)
;
}
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
)
;
}
return
this
.
_logger
;
}
getSimpleMeasurements
:
function
getSimpleMeasurements
(
forSavedSession
isSubsession
clearSubsession
)
{
let
si
=
Services
.
startup
.
getStartupInfo
(
)
;
let
elapsedTime
=
Date
.
now
(
)
-
si
.
process
;
var
ret
=
{
totalTime
:
Math
.
round
(
elapsedTime
/
1000
)
}
;
var
appTimestamps
=
{
}
;
try
{
let
o
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryTimestamps
.
jsm
"
o
)
;
appTimestamps
=
o
.
TelemetryTimestamps
.
get
(
)
;
}
catch
(
ex
)
{
}
if
(
!
Utils
.
isContentProcess
&
&
Telemetry
.
canRecordExtended
)
{
try
{
ret
.
addonManager
=
AddonManagerPrivate
.
getSimpleMeasures
(
)
;
}
catch
(
ex
)
{
}
}
if
(
si
.
process
)
{
for
(
let
field
of
Object
.
keys
(
si
)
)
{
if
(
field
=
=
"
process
"
)
continue
;
ret
[
field
]
=
si
[
field
]
-
si
.
process
;
}
for
(
let
p
in
appTimestamps
)
{
if
(
!
(
p
in
ret
)
&
&
appTimestamps
[
p
]
)
ret
[
p
]
=
appTimestamps
[
p
]
-
si
.
process
;
}
}
ret
.
startupInterrupted
=
Number
(
Services
.
startup
.
interrupted
)
;
let
maximalNumberOfConcurrentThreads
=
Telemetry
.
maximalNumberOfConcurrentThreads
;
if
(
maximalNumberOfConcurrentThreads
)
{
ret
.
maximalNumberOfConcurrentThreads
=
maximalNumberOfConcurrentThreads
;
}
if
(
Utils
.
isContentProcess
)
{
return
ret
;
}
let
debugService
=
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
;
let
isDebuggerAttached
=
debugService
.
isDebuggerAttached
;
gWasDebuggerAttached
=
gWasDebuggerAttached
|
|
isDebuggerAttached
;
ret
.
debuggerAttached
=
Number
(
gWasDebuggerAttached
)
;
let
shutdownDuration
=
Telemetry
.
lastShutdownDuration
;
if
(
shutdownDuration
)
ret
.
shutdownDuration
=
shutdownDuration
;
let
failedProfileLockCount
=
Telemetry
.
failedProfileLockCount
;
if
(
failedProfileLockCount
)
ret
.
failedProfileLockCount
=
failedProfileLockCount
;
for
(
let
ioCounter
in
this
.
_startupIO
)
ret
[
ioCounter
]
=
this
.
_startupIO
[
ioCounter
]
;
let
activeTicks
=
this
.
_sessionActiveTicks
;
if
(
isSubsession
)
{
activeTicks
=
this
.
_sessionActiveTicks
-
this
.
_subsessionStartActiveTicks
;
}
if
(
clearSubsession
)
{
this
.
_subsessionStartActiveTicks
=
this
.
_sessionActiveTicks
;
}
ret
.
activeTicks
=
activeTicks
;
return
ret
;
}
getDatasetType
(
)
{
return
Telemetry
.
canRecordExtended
?
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
:
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTOUT
;
}
getHistograms
:
function
getHistograms
(
clearSubsession
)
{
let
hls
=
Telemetry
.
snapshotHistograms
(
this
.
getDatasetType
(
)
clearSubsession
)
;
return
TelemetryUtils
.
packHistograms
(
hls
this
.
_testing
)
;
}
getKeyedHistograms
(
clearSubsession
)
{
let
khs
=
Telemetry
.
snapshotKeyedHistograms
(
this
.
getDatasetType
(
)
clearSubsession
)
;
return
TelemetryUtils
.
packKeyedHistograms
(
khs
this
.
_testing
)
;
}
getScalars
(
subsession
clearSubsession
keyed
)
{
if
(
!
subsession
)
{
this
.
_log
.
trace
(
"
getScalars
-
We
only
support
scalars
in
subsessions
.
"
)
;
return
{
}
;
}
let
scalarsSnapshot
=
keyed
?
Telemetry
.
snapshotKeyedScalars
(
this
.
getDatasetType
(
)
clearSubsession
)
:
Telemetry
.
snapshotScalars
(
this
.
getDatasetType
(
)
clearSubsession
)
;
let
ret
=
{
}
;
for
(
let
processName
in
scalarsSnapshot
)
{
for
(
let
name
in
scalarsSnapshot
[
processName
]
)
{
if
(
name
.
startsWith
(
"
telemetry
.
test
"
)
&
&
!
this
.
_testing
)
{
continue
;
}
if
(
!
(
processName
in
ret
)
)
{
ret
[
processName
]
=
{
}
;
}
ret
[
processName
]
[
name
]
=
scalarsSnapshot
[
processName
]
[
name
]
;
}
}
return
ret
;
}
getMetadata
:
function
getMetadata
(
reason
)
{
const
sessionStartDate
=
Utils
.
toLocalTimeISOString
(
Utils
.
truncateToHours
(
this
.
_sessionStartDate
)
)
;
const
subsessionStartDate
=
Utils
.
toLocalTimeISOString
(
Utils
.
truncateToHours
(
this
.
_subsessionStartDate
)
)
;
const
monotonicNow
=
Policy
.
monotonicNow
(
)
;
let
ret
=
{
reason
revision
:
AppConstants
.
SOURCE_REVISION_URL
timezoneOffset
:
-
this
.
_subsessionStartDate
.
getTimezoneOffset
(
)
previousBuildId
:
this
.
_previousBuildId
sessionId
:
this
.
_sessionId
subsessionId
:
this
.
_subsessionId
previousSessionId
:
this
.
_previousSessionId
previousSubsessionId
:
this
.
_previousSubsessionId
subsessionCounter
:
this
.
_subsessionCounter
profileSubsessionCounter
:
this
.
_profileSubsessionCounter
sessionStartDate
subsessionStartDate
sessionLength
:
Math
.
floor
(
monotonicNow
/
1000
)
subsessionLength
:
Math
.
floor
(
(
monotonicNow
-
this
.
_subsessionStartTimeMonotonic
)
/
1000
)
}
;
if
(
this
.
_addons
)
ret
.
addons
=
this
.
_addons
;
let
flashVersion
=
this
.
getFlashVersion
(
)
;
if
(
flashVersion
)
ret
.
flashVersion
=
flashVersion
;
return
ret
;
}
assemblePayloadWithMeasurements
(
simpleMeasurements
info
reason
clearSubsession
)
{
const
isSubsession
=
IS_UNIFIED_TELEMETRY
&
&
!
this
.
_isClassicReason
(
reason
)
;
clearSubsession
=
IS_UNIFIED_TELEMETRY
&
&
clearSubsession
;
this
.
_log
.
trace
(
"
assemblePayloadWithMeasurements
-
reason
:
"
+
reason
+
"
submitting
subsession
data
:
"
+
isSubsession
)
;
const
protect
=
(
fn
defaultReturn
=
null
)
=
>
{
try
{
return
fn
(
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
assemblePayloadWithMeasurements
-
caught
exception
"
ex
)
;
return
defaultReturn
;
}
}
;
let
payloadObj
=
{
ver
:
PAYLOAD_VERSION
simpleMeasurements
}
;
if
(
Telemetry
.
canRecordExtended
)
{
payloadObj
.
log
=
[
]
;
payloadObj
.
webrtc
=
protect
(
(
)
=
>
Telemetry
.
webrtcStats
)
;
}
if
(
Utils
.
isContentProcess
)
{
return
payloadObj
;
}
let
measurements
=
{
histograms
:
protect
(
(
)
=
>
this
.
getHistograms
(
clearSubsession
)
{
}
)
keyedHistograms
:
protect
(
(
)
=
>
this
.
getKeyedHistograms
(
clearSubsession
)
{
}
)
scalars
:
protect
(
(
)
=
>
this
.
getScalars
(
isSubsession
clearSubsession
)
{
}
)
keyedScalars
:
protect
(
(
)
=
>
this
.
getScalars
(
isSubsession
clearSubsession
true
)
{
}
)
}
;
let
measurementsContainGPU
=
Object
.
keys
(
measurements
)
.
some
(
key
=
>
"
gpu
"
in
measurements
[
key
]
)
;
payloadObj
.
processes
=
{
}
;
let
processTypes
=
[
"
parent
"
"
content
"
"
extension
"
"
dynamic
"
]
;
if
(
measurementsContainGPU
)
{
processTypes
.
push
(
"
gpu
"
)
;
}
for
(
const
processType
of
processTypes
)
{
let
processPayload
=
{
}
;
for
(
const
key
in
measurements
)
{
let
payloadLoc
=
processPayload
;
if
(
processType
=
=
"
parent
"
&
&
(
key
=
=
"
histograms
"
|
|
key
=
=
"
keyedHistograms
"
)
)
{
payloadLoc
=
payloadObj
;
}
if
(
processType
=
=
"
dynamic
"
&
&
key
!
=
=
"
scalars
"
)
{
continue
;
}
payloadLoc
[
key
]
=
measurements
[
key
]
[
processType
]
|
|
{
}
;
}
payloadObj
.
processes
[
processType
]
=
processPayload
;
}
payloadObj
.
info
=
info
;
if
(
Services
.
prefs
.
getBoolPref
(
PRIO_ENABLED_PREF
false
)
)
{
payloadObj
.
prio
=
protect
(
(
)
=
>
this
.
_prioEncode
(
payloadObj
)
)
;
}
if
(
Telemetry
.
canRecordExtended
)
{
payloadObj
.
slowSQL
=
protect
(
(
)
=
>
Telemetry
.
slowSQL
)
;
payloadObj
.
fileIOReports
=
protect
(
(
)
=
>
Telemetry
.
fileIOReports
)
;
payloadObj
.
lateWrites
=
protect
(
(
)
=
>
Telemetry
.
lateWrites
)
;
payloadObj
.
addonDetails
=
protect
(
(
)
=
>
AddonManagerPrivate
.
getTelemetryDetails
(
)
)
;
let
clearUIsession
=
!
(
reason
=
=
REASON_GATHER_PAYLOAD
|
|
reason
=
=
REASON_GATHER_SUBSESSION_PAYLOAD
)
;
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
payloadObj
.
UIMeasurements
=
protect
(
(
)
=
>
UITelemetry
.
getUIMeasurements
(
clearUIsession
)
)
;
}
if
(
this
.
_slowSQLStartup
&
&
Object
.
keys
(
this
.
_slowSQLStartup
)
.
length
!
=
0
&
&
(
Object
.
keys
(
this
.
_slowSQLStartup
.
mainThread
)
.
length
|
|
Object
.
keys
(
this
.
_slowSQLStartup
.
otherThreads
)
.
length
)
)
{
payloadObj
.
slowSQLStartup
=
this
.
_slowSQLStartup
;
}
if
(
!
this
.
_isClassicReason
(
reason
)
)
{
payloadObj
.
processes
.
parent
.
gc
=
protect
(
(
)
=
>
GCTelemetry
.
entries
(
"
main
"
clearSubsession
)
)
;
payloadObj
.
processes
.
content
.
gc
=
protect
(
(
)
=
>
GCTelemetry
.
entries
(
"
content
"
clearSubsession
)
)
;
}
let
stacks
=
protect
(
(
)
=
>
Telemetry
.
snapshotCapturedStacks
(
true
)
)
;
if
(
stacks
&
&
(
"
captures
"
in
stacks
)
&
&
(
stacks
.
captures
.
length
>
0
)
)
{
payloadObj
.
processes
.
parent
.
capturedStacks
=
stacks
;
}
}
return
payloadObj
;
}
startNewSubsession
(
)
{
this
.
_subsessionStartDate
=
Policy
.
now
(
)
;
this
.
_subsessionStartTimeMonotonic
=
Policy
.
monotonicNow
(
)
;
this
.
_previousSubsessionId
=
this
.
_subsessionId
;
this
.
_subsessionId
=
Policy
.
generateSubsessionUUID
(
)
;
this
.
_subsessionCounter
+
+
;
this
.
_profileSubsessionCounter
+
+
;
}
getSessionPayload
:
function
getSessionPayload
(
reason
clearSubsession
)
{
this
.
_log
.
trace
(
"
getSessionPayload
-
reason
:
"
+
reason
+
"
clearSubsession
:
"
+
clearSubsession
)
;
let
payload
;
try
{
const
isMobile
=
(
AppConstants
.
platform
=
=
"
android
"
)
;
const
isSubsession
=
isMobile
?
false
:
!
this
.
_isClassicReason
(
reason
)
;
if
(
isMobile
)
{
clearSubsession
=
false
;
}
let
measurements
=
this
.
getSimpleMeasurements
(
reason
=
=
REASON_SAVED_SESSION
isSubsession
clearSubsession
)
;
let
info
=
!
Utils
.
isContentProcess
?
this
.
getMetadata
(
reason
)
:
null
;
payload
=
this
.
assemblePayloadWithMeasurements
(
measurements
info
reason
clearSubsession
)
;
}
catch
(
ex
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_ASSEMBLE_PAYLOAD_EXCEPTION
"
)
.
add
(
1
)
;
throw
ex
;
}
finally
{
if
(
!
Utils
.
isContentProcess
&
&
clearSubsession
)
{
this
.
startNewSubsession
(
)
;
let
sessionData
=
this
.
_getSessionDataObject
(
)
;
TelemetryStorage
.
saveSessionData
(
sessionData
)
;
Services
.
obs
.
notifyObservers
(
null
"
internal
-
telemetry
-
after
-
subsession
-
split
"
)
;
}
}
return
payload
;
}
send
:
function
send
(
reason
)
{
this
.
_log
.
trace
(
"
send
-
Reason
"
+
reason
)
;
MemoryTelemetry
.
gatherMemory
(
)
;
const
isSubsession
=
!
this
.
_isClassicReason
(
reason
)
;
let
payload
=
this
.
getSessionPayload
(
reason
isSubsession
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
return
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
;
}
attachEarlyObservers
(
)
{
this
.
addObserver
(
"
sessionstore
-
windows
-
restored
"
)
;
if
(
AppConstants
.
platform
=
=
=
"
android
"
)
{
this
.
addObserver
(
"
application
-
background
"
)
;
}
this
.
addObserver
(
"
xul
-
window
-
visible
"
)
;
this
.
addObserver
(
"
user
-
interaction
-
active
"
)
;
this
.
addObserver
(
"
user
-
interaction
-
inactive
"
)
;
}
earlyInit
(
testing
)
{
this
.
_log
.
trace
(
"
earlyInit
"
)
;
this
.
_initStarted
=
true
;
this
.
_testing
=
testing
;
if
(
this
.
_initialized
&
&
!
testing
)
{
this
.
_log
.
error
(
"
earlyInit
-
already
initialized
"
)
;
return
;
}
if
(
!
Telemetry
.
canRecordBase
&
&
!
testing
)
{
this
.
_log
.
config
(
"
earlyInit
-
Telemetry
recording
is
disabled
skipping
Chrome
process
setup
.
"
)
;
return
;
}
this
.
_sessionId
=
Policy
.
generateSessionUUID
(
)
;
this
.
startNewSubsession
(
)
;
this
.
_sessionStartDate
=
this
.
_subsessionStartDate
;
annotateCrashReport
(
this
.
_sessionId
)
;
let
previousBuildId
=
Services
.
prefs
.
getStringPref
(
TelemetryUtils
.
Preferences
.
PreviousBuildID
null
)
;
let
thisBuildID
=
Services
.
appinfo
.
appBuildID
;
if
(
previousBuildId
!
=
thisBuildID
)
{
this
.
_previousBuildId
=
previousBuildId
;
Services
.
prefs
.
setStringPref
(
TelemetryUtils
.
Preferences
.
PreviousBuildID
thisBuildID
)
;
}
this
.
attachEarlyObservers
(
)
;
}
delayedInit
(
)
{
this
.
_log
.
trace
(
"
delayedInit
"
)
;
this
.
_delayedInitTask
=
(
async
(
)
=
>
{
try
{
this
.
_initialized
=
true
;
await
this
.
_loadSessionData
(
)
;
await
TelemetryStorage
.
saveSessionData
(
this
.
_getSessionDataObject
(
)
)
;
this
.
addObserver
(
"
idle
-
daily
"
)
;
MemoryTelemetry
.
gatherMemory
(
)
;
Telemetry
.
asyncFetchTelemetryData
(
function
(
)
{
}
)
;
if
(
IS_UNIFIED_TELEMETRY
)
{
await
TelemetryController
.
checkAbortedSessionPing
(
)
;
if
(
!
this
.
_testing
)
{
await
this
.
_saveAbortedSessionPing
(
)
;
}
this
.
_lastEnvironmentChangeDate
=
Policy
.
monotonicNow
(
)
;
TelemetryEnvironment
.
registerChangeListener
(
ENVIRONMENT_CHANGE_LISTENER
(
reason
data
)
=
>
this
.
_onEnvironmentChange
(
reason
data
)
)
;
TelemetryScheduler
.
init
(
)
;
}
this
.
_delayedInitTask
=
null
;
}
catch
(
e
)
{
this
.
_delayedInitTask
=
null
;
throw
e
;
}
}
)
(
)
;
return
this
.
_delayedInitTask
;
}
getFlashVersion
:
function
getFlashVersion
(
)
{
let
host
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
let
tags
=
host
.
getPluginTags
(
)
;
for
(
let
i
=
0
;
i
<
tags
.
length
;
i
+
+
)
{
if
(
tags
[
i
]
.
name
=
=
"
Shockwave
Flash
"
)
return
tags
[
i
]
.
version
;
}
return
null
;
}
saveShutdownPings
(
)
{
this
.
_log
.
trace
(
"
saveShutdownPings
"
)
;
let
p
=
[
]
;
if
(
IS_UNIFIED_TELEMETRY
)
{
let
shutdownPayload
=
this
.
getSessionPayload
(
REASON_SHUTDOWN
false
)
;
const
sendOnThisSession
=
Services
.
prefs
.
getBoolPref
(
Utils
.
Preferences
.
ShutdownPingSenderFirstSession
false
)
|
|
!
TelemetryReportingPolicy
.
isFirstRun
(
)
;
let
sendWithPingsender
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
ShutdownPingSender
false
)
&
&
sendOnThisSession
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
usePingSender
:
sendWithPingsender
}
;
p
.
push
(
TelemetryController
.
submitExternalPing
(
getPingType
(
shutdownPayload
)
shutdownPayload
options
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
saveShutdownPings
-
failed
to
submit
shutdown
ping
"
e
)
)
)
;
const
sendFirstShutdownPing
=
Services
.
prefs
.
getBoolPref
(
Utils
.
Preferences
.
ShutdownPingSender
false
)
&
&
Services
.
prefs
.
getBoolPref
(
Utils
.
Preferences
.
FirstShutdownPingEnabled
false
)
&
&
TelemetryReportingPolicy
.
isFirstRun
(
)
;
if
(
sendFirstShutdownPing
)
{
let
options
=
{
addClientId
:
true
addEnvironment
:
true
usePingSender
:
true
}
;
p
.
push
(
TelemetryController
.
submitExternalPing
(
"
first
-
shutdown
"
shutdownPayload
options
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
saveShutdownPings
-
failed
to
submit
first
shutdown
ping
"
e
)
)
)
;
}
}
if
(
AppConstants
.
platform
=
=
"
android
"
&
&
Telemetry
.
canRecordExtended
)
{
let
payload
=
this
.
getSessionPayload
(
REASON_SAVED_SESSION
false
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
p
.
push
(
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
saveShutdownPings
-
failed
to
submit
saved
-
session
ping
"
e
)
)
)
;
}
return
Promise
.
all
(
p
)
;
}
testSavePendingPing
(
)
{
let
payload
=
this
.
getSessionPayload
(
REASON_SAVED_SESSION
false
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
overwrite
:
true
}
;
return
TelemetryController
.
addPendingPing
(
getPingType
(
payload
)
payload
options
)
;
}
uninstall
(
)
{
for
(
let
topic
of
this
.
_observedTopics
)
{
try
{
this
.
removeObserver
(
topic
)
;
}
catch
(
e
)
{
this
.
_log
.
warn
(
"
uninstall
-
Failed
to
remove
"
+
topic
e
)
;
}
}
}
getPayload
:
function
getPayload
(
reason
clearSubsession
)
{
this
.
_log
.
trace
(
"
getPayload
-
clearSubsession
:
"
+
clearSubsession
)
;
reason
=
reason
|
|
REASON_GATHER_PAYLOAD
;
if
(
Object
.
keys
(
this
.
_slowSQLStartup
)
.
length
=
=
0
)
{
this
.
_slowSQLStartup
=
Telemetry
.
slowSQL
;
}
MemoryTelemetry
.
gatherMemory
(
)
;
return
this
.
getSessionPayload
(
reason
clearSubsession
)
;
}
gatherStartup
:
function
gatherStartup
(
)
{
this
.
_log
.
trace
(
"
gatherStartup
"
)
;
let
counters
=
processInfo
.
getCounters
(
)
;
if
(
counters
)
{
[
this
.
_startupIO
.
startupSessionRestoreReadBytes
this
.
_startupIO
.
startupSessionRestoreWriteBytes
]
=
counters
;
}
this
.
_slowSQLStartup
=
Telemetry
.
slowSQL
;
}
setAddOns
:
function
setAddOns
(
aAddOns
)
{
this
.
_addons
=
aAddOns
;
}
testPing
:
function
testPing
(
)
{
return
this
.
send
(
REASON_TEST_PING
)
;
}
_onActiveTick
(
aUserActive
)
{
const
needsUpdate
=
aUserActive
&
&
this
.
_isUserActive
;
this
.
_isUserActive
=
aUserActive
;
if
(
needsUpdate
)
{
this
.
_sessionActiveTicks
+
+
;
Telemetry
.
scalarAdd
(
"
browser
.
engagement
.
active_ticks
"
1
)
;
}
}
observe
(
aSubject
aTopic
aData
)
{
this
.
_log
.
trace
(
"
observe
-
"
+
aTopic
+
"
notified
.
"
)
;
switch
(
aTopic
)
{
case
"
xul
-
window
-
visible
"
:
this
.
removeObserver
(
"
xul
-
window
-
visible
"
)
;
var
counters
=
processInfo
.
getCounters
(
)
;
if
(
counters
)
{
[
this
.
_startupIO
.
startupWindowVisibleReadBytes
this
.
_startupIO
.
startupWindowVisibleWriteBytes
]
=
counters
;
}
break
;
case
"
sessionstore
-
windows
-
restored
"
:
this
.
removeObserver
(
"
sessionstore
-
windows
-
restored
"
)
;
let
debugService
=
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
;
gWasDebuggerAttached
=
debugService
.
isDebuggerAttached
;
this
.
gatherStartup
(
)
;
break
;
case
"
idle
-
daily
"
:
Services
.
tm
.
dispatchToMainThread
(
(
function
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
gather
-
telemetry
"
)
;
}
)
)
;
break
;
case
"
application
-
background
"
:
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
break
;
}
let
payload
=
this
.
getSessionPayload
(
REASON_SAVED_SESSION
false
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
overwrite
:
true
}
;
TelemetryController
.
addPendingPing
(
getPingType
(
payload
)
payload
options
)
;
break
;
case
"
user
-
interaction
-
active
"
:
this
.
_onActiveTick
(
true
)
;
break
;
case
"
user
-
interaction
-
inactive
"
:
this
.
_onActiveTick
(
false
)
;
break
;
}
return
undefined
;
}
shutdownChromeProcess
(
)
{
this
.
_log
.
trace
(
"
shutdownChromeProcess
"
)
;
let
cleanup
=
(
)
=
>
{
if
(
IS_UNIFIED_TELEMETRY
)
{
TelemetryEnvironment
.
unregisterChangeListener
(
ENVIRONMENT_CHANGE_LISTENER
)
;
TelemetryScheduler
.
shutdown
(
)
;
}
this
.
uninstall
(
)
;
let
reset
=
(
)
=
>
{
this
.
_initStarted
=
false
;
this
.
_initialized
=
false
;
}
;
return
(
async
(
)
=
>
{
await
this
.
saveShutdownPings
(
)
;
if
(
IS_UNIFIED_TELEMETRY
)
{
await
TelemetryController
.
removeAbortedSessionPing
(
)
;
}
reset
(
)
;
}
)
(
)
;
}
;
if
(
!
this
.
_initStarted
)
{
return
Promise
.
resolve
(
)
;
}
if
(
!
this
.
_delayedInitTask
)
{
return
cleanup
(
)
;
}
return
this
.
_delayedInitTask
.
then
(
cleanup
)
;
}
_sendDailyPing
(
)
{
this
.
_log
.
trace
(
"
_sendDailyPing
"
)
;
let
payload
=
this
.
getSessionPayload
(
REASON_DAILY
true
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
let
promise
=
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
;
if
(
IS_UNIFIED_TELEMETRY
)
{
this
.
_saveAbortedSessionPing
(
payload
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
_sendDailyPing
-
Failed
to
save
the
aborted
session
ping
"
e
)
)
;
}
return
promise
;
}
async
_loadSessionData
(
)
{
let
data
=
await
TelemetryStorage
.
loadSessionData
(
)
;
if
(
!
data
)
{
return
null
;
}
if
(
!
(
"
profileSubsessionCounter
"
in
data
)
|
|
!
(
typeof
(
data
.
profileSubsessionCounter
)
=
=
"
number
"
)
|
|
!
(
"
subsessionId
"
in
data
)
|
|
!
(
"
sessionId
"
in
data
)
)
{
this
.
_log
.
error
(
"
_loadSessionData
-
session
data
is
invalid
"
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_SESSIONDATA_FAILED_VALIDATION
"
)
.
add
(
1
)
;
return
null
;
}
this
.
_previousSessionId
=
data
.
sessionId
;
this
.
_previousSubsessionId
=
data
.
subsessionId
;
this
.
_profileSubsessionCounter
=
data
.
profileSubsessionCounter
+
this
.
_subsessionCounter
;
this
.
_newProfilePingSent
=
(
"
newProfilePingSent
"
in
data
)
?
data
.
newProfilePingSent
:
true
;
return
data
;
}
_getSessionDataObject
(
)
{
return
{
sessionId
:
this
.
_sessionId
subsessionId
:
this
.
_subsessionId
profileSubsessionCounter
:
this
.
_profileSubsessionCounter
newProfilePingSent
:
this
.
_newProfilePingSent
}
;
}
_onEnvironmentChange
(
reason
oldEnvironment
)
{
this
.
_log
.
trace
(
"
_onEnvironmentChange
"
reason
)
;
let
now
=
Policy
.
monotonicNow
(
)
;
let
timeDelta
=
now
-
this
.
_lastEnvironmentChangeDate
;
if
(
timeDelta
<
=
MIN_SUBSESSION_LENGTH_MS
)
{
this
.
_log
.
trace
(
_onEnvironmentChange
-
throttling
;
last
change
was
{
Math
.
round
(
timeDelta
/
1000
)
}
s
ago
.
)
;
return
;
}
this
.
_lastEnvironmentChangeDate
=
now
;
let
payload
=
this
.
getSessionPayload
(
REASON_ENVIRONMENT_CHANGE
true
)
;
TelemetryScheduler
.
reschedulePings
(
REASON_ENVIRONMENT_CHANGE
payload
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
overrideEnvironment
:
oldEnvironment
}
;
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
;
}
_isClassicReason
(
reason
)
{
const
classicReasons
=
[
REASON_SAVED_SESSION
REASON_GATHER_PAYLOAD
REASON_TEST_PING
]
;
return
classicReasons
.
includes
(
reason
)
;
}
_getState
(
)
{
return
{
initialized
:
this
.
_initialized
initStarted
:
this
.
_initStarted
haveDelayedInitTask
:
!
!
this
.
_delayedInitTask
}
;
}
_saveAbortedSessionPing
(
aProvidedPayload
=
null
)
{
this
.
_log
.
trace
(
"
_saveAbortedSessionPing
"
)
;
let
payload
=
null
;
if
(
aProvidedPayload
)
{
payload
=
Cu
.
cloneInto
(
aProvidedPayload
myScope
)
;
payload
.
info
.
reason
=
REASON_ABORTED_SESSION
;
}
else
{
payload
=
this
.
getSessionPayload
(
REASON_ABORTED_SESSION
false
)
;
}
return
TelemetryController
.
saveAbortedSessionPing
(
payload
)
;
}
async
markNewProfilePingSent
(
)
{
this
.
_log
.
trace
(
"
markNewProfilePingSent
"
)
;
this
.
_newProfilePingSent
=
true
;
return
TelemetryStorage
.
saveSessionData
(
this
.
_getSessionDataObject
(
)
)
;
}
_prioEncode
(
payloadObj
)
{
const
prioEncodedHistograms
=
[
"
BROWSER_IS_USER_DEFAULT
"
"
NEWTAB_PAGE_ENABLED
"
"
PDF_VIEWER_USED
"
]
;
let
prioParams
=
{
booleans
:
[
]
}
;
for
(
const
[
i
histogramName
]
of
prioEncodedHistograms
.
entries
(
)
)
{
try
{
if
(
histogramName
in
payloadObj
.
histograms
)
{
const
histogram
=
payloadObj
.
histograms
[
histogramName
]
;
prioParams
.
booleans
[
i
]
=
Boolean
(
histogram
.
sum
)
;
}
else
{
prioParams
.
booleans
[
i
]
=
false
;
}
}
catch
(
ex
)
{
this
.
_log
.
error
(
ex
)
;
}
}
const
batchID
=
Services
.
appinfo
.
appBuildID
;
let
prioEncodedData
;
try
{
prioEncodedData
=
Policy
.
prioEncode
(
batchID
prioParams
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
ex
)
;
}
return
prioEncodedData
;
}
}
;
