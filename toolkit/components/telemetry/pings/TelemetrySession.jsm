"
use
strict
"
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManagerPrivate
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
TelemetryController
:
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
TelemetryStorage
:
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
UITelemetry
:
"
resource
:
/
/
gre
/
modules
/
UITelemetry
.
jsm
"
GCTelemetry
:
"
resource
:
/
/
gre
/
modules
/
GCTelemetry
.
jsm
"
TelemetryEnvironment
:
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
TelemetryReportingPolicy
:
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
TelemetryScheduler
:
"
resource
:
/
/
gre
/
modules
/
TelemetryScheduler
.
jsm
"
}
)
;
const
Utils
=
TelemetryUtils
;
const
myScope
=
this
;
const
PAYLOAD_VERSION
=
4
;
const
PING_TYPE_MAIN
=
"
main
"
;
const
PING_TYPE_SAVED_SESSION
=
"
saved
-
session
"
;
const
REASON_ABORTED_SESSION
=
"
aborted
-
session
"
;
const
REASON_DAILY
=
"
daily
"
;
const
REASON_SAVED_SESSION
=
"
saved
-
session
"
;
const
REASON_GATHER_PAYLOAD
=
"
gather
-
payload
"
;
const
REASON_GATHER_SUBSESSION_PAYLOAD
=
"
gather
-
subsession
-
payload
"
;
const
REASON_TEST_PING
=
"
test
-
ping
"
;
const
REASON_ENVIRONMENT_CHANGE
=
"
environment
-
change
"
;
const
REASON_SHUTDOWN
=
"
shutdown
"
;
const
ENVIRONMENT_CHANGE_LISTENER
=
"
TelemetrySession
:
:
onEnvironmentChange
"
;
const
MIN_SUBSESSION_LENGTH_MS
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
minSubsessionLength
"
5
*
60
)
*
1000
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
LOGGER_PREFIX
=
"
TelemetrySession
"
+
(
Utils
.
isContentProcess
?
"
#
content
:
:
"
:
"
:
:
"
)
;
const
IS_UNIFIED_TELEMETRY
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
var
gWasDebuggerAttached
=
false
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
Telemetry
:
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
"
nsITelemetry
"
]
}
)
;
function
generateUUID
(
)
{
let
str
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
return
str
.
substring
(
1
str
.
length
-
1
)
;
}
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
monotonicNow
:
Utils
.
monotonicNow
generateSessionUUID
:
(
)
=
>
generateUUID
(
)
generateSubsessionUUID
:
(
)
=
>
generateUUID
(
)
}
;
function
getPingType
(
aPayload
)
{
if
(
aPayload
.
info
.
reason
=
=
REASON_SAVED_SESSION
)
{
return
PING_TYPE_SAVED_SESSION
;
}
return
PING_TYPE_MAIN
;
}
function
annotateCrashReport
(
sessionId
)
{
try
{
const
cr
=
Cc
[
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
]
;
if
(
cr
)
{
cr
.
getService
(
Ci
.
nsICrashReporter
)
.
setTelemetrySessionId
(
sessionId
)
;
}
}
catch
(
e
)
{
}
}
var
processInfo
=
{
_initialized
:
false
_IO_COUNTERS
:
null
_kernel32
:
null
_GetProcessIoCounters
:
null
_GetCurrentProcess
:
null
getCounters
(
)
{
let
isWindows
=
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
in
Cc
;
if
(
isWindows
)
{
return
this
.
getCounters_Windows
(
)
;
}
return
null
;
}
getCounters_Windows
(
)
{
if
(
!
this
.
_initialized
)
{
var
{
ctypes
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
this
.
_IO_COUNTERS
=
new
ctypes
.
StructType
(
"
IO_COUNTERS
"
[
{
readOps
:
ctypes
.
unsigned_long_long
}
{
writeOps
:
ctypes
.
unsigned_long_long
}
{
otherOps
:
ctypes
.
unsigned_long_long
}
{
readBytes
:
ctypes
.
unsigned_long_long
}
{
writeBytes
:
ctypes
.
unsigned_long_long
}
{
otherBytes
:
ctypes
.
unsigned_long_long
}
]
)
;
try
{
this
.
_kernel32
=
ctypes
.
open
(
"
Kernel32
.
dll
"
)
;
this
.
_GetProcessIoCounters
=
this
.
_kernel32
.
declare
(
"
GetProcessIoCounters
"
ctypes
.
winapi_abi
ctypes
.
bool
ctypes
.
voidptr_t
this
.
_IO_COUNTERS
.
ptr
)
;
this
.
_GetCurrentProcess
=
this
.
_kernel32
.
declare
(
"
GetCurrentProcess
"
ctypes
.
winapi_abi
ctypes
.
voidptr_t
)
;
this
.
_initialized
=
true
;
}
catch
(
err
)
{
return
null
;
}
}
let
io
=
new
this
.
_IO_COUNTERS
(
)
;
if
(
!
this
.
_GetProcessIoCounters
(
this
.
_GetCurrentProcess
(
)
io
.
address
(
)
)
)
{
return
null
;
}
return
[
parseInt
(
io
.
readBytes
)
parseInt
(
io
.
writeBytes
)
]
;
}
}
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetrySession
"
]
;
var
TelemetrySession
=
Object
.
freeze
(
{
testPing
(
)
{
return
Impl
.
testPing
(
)
;
}
getPayload
(
reason
clearSubsession
=
false
)
{
return
Impl
.
getPayload
(
reason
clearSubsession
)
;
}
testSavePendingPing
(
)
{
return
Impl
.
testSavePendingPing
(
)
;
}
gatherStartup
(
)
{
return
Impl
.
gatherStartup
(
)
;
}
setAddOns
(
aAddOns
)
{
return
Impl
.
setAddOns
(
aAddOns
)
;
}
getMetadata
(
reason
)
{
return
Impl
.
getMetadata
(
reason
)
;
}
resetSubsessionCounter
(
)
{
Impl
.
_subsessionCounter
=
0
;
Impl
.
_profileSubsessionCounter
=
0
;
}
testReset
(
)
{
Impl
.
_newProfilePingSent
=
false
;
Impl
.
_sessionId
=
null
;
Impl
.
_subsessionId
=
null
;
Impl
.
_previousSessionId
=
null
;
Impl
.
_previousSubsessionId
=
null
;
Impl
.
_subsessionCounter
=
0
;
Impl
.
_profileSubsessionCounter
=
0
;
Impl
.
_subsessionStartActiveTicks
=
0
;
Impl
.
_sessionActiveTicks
=
0
;
Impl
.
_isUserActive
=
true
;
Impl
.
_subsessionStartTimeMonotonic
=
0
;
Impl
.
_lastEnvironmentChangeDate
=
Policy
.
monotonicNow
(
)
;
this
.
testUninstall
(
)
;
}
shutdown
(
)
{
return
Impl
.
shutdownChromeProcess
(
)
;
}
testUninstall
(
)
{
try
{
Impl
.
uninstall
(
)
;
}
catch
(
ex
)
{
}
}
earlyInit
(
aTesting
=
false
)
{
return
Impl
.
earlyInit
(
aTesting
)
;
}
delayedInit
(
)
{
return
Impl
.
delayedInit
(
)
;
}
observe
(
aSubject
aTopic
aData
)
{
return
Impl
.
observe
(
aSubject
aTopic
aData
)
;
}
markNewProfilePingSent
(
)
{
return
Impl
.
markNewProfilePingSent
(
)
;
}
get
newProfilePingSent
(
)
{
return
Impl
.
_newProfilePingSent
;
}
saveAbortedSessionPing
(
aProvidedPayload
)
{
return
Impl
.
_saveAbortedSessionPing
(
aProvidedPayload
)
;
}
sendDailyPing
(
)
{
return
Impl
.
_sendDailyPing
(
)
;
}
}
)
;
var
Impl
=
{
_initialized
:
false
_logger
:
null
_slowSQLStartup
:
{
}
_isUserActive
:
true
_startupIO
:
{
}
_previousBuildId
:
null
_sessionId
:
null
_subsessionId
:
null
_previousSessionId
:
null
_previousSubsessionId
:
null
_subsessionCounter
:
0
_profileSubsessionCounter
:
0
_subsessionStartDate
:
null
_subsessionStartTimeMonotonic
:
0
_subsessionStartActiveTicks
:
0
_sessionActiveTicks
:
0
_delayedInitTask
:
null
_testing
:
false
_lastEnvironmentChangeDate
:
0
_newProfilePingSent
:
false
_observedTopics
:
new
Set
(
)
addObserver
(
aTopic
)
{
Services
.
obs
.
addObserver
(
this
aTopic
)
;
this
.
_observedTopics
.
add
(
aTopic
)
;
}
removeObserver
(
aTopic
)
{
Services
.
obs
.
removeObserver
(
this
aTopic
)
;
this
.
_observedTopics
.
delete
(
aTopic
)
;
}
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
)
;
}
return
this
.
_logger
;
}
getSimpleMeasurements
:
function
getSimpleMeasurements
(
forSavedSession
isSubsession
clearSubsession
)
{
let
si
=
Services
.
startup
.
getStartupInfo
(
)
;
let
elapsedTime
=
Date
.
now
(
)
-
si
.
process
;
var
ret
=
{
totalTime
:
Math
.
round
(
elapsedTime
/
1000
)
}
;
var
appTimestamps
=
{
}
;
try
{
let
o
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryTimestamps
.
jsm
"
o
)
;
appTimestamps
=
o
.
TelemetryTimestamps
.
get
(
)
;
}
catch
(
ex
)
{
}
if
(
!
Utils
.
isContentProcess
&
&
Telemetry
.
canRecordExtended
)
{
try
{
ret
.
addonManager
=
AddonManagerPrivate
.
getSimpleMeasures
(
)
;
}
catch
(
ex
)
{
}
}
if
(
si
.
process
)
{
for
(
let
field
of
Object
.
keys
(
si
)
)
{
if
(
field
=
=
"
process
"
)
{
continue
;
}
ret
[
field
]
=
si
[
field
]
-
si
.
process
;
}
for
(
let
p
in
appTimestamps
)
{
if
(
!
(
p
in
ret
)
&
&
appTimestamps
[
p
]
)
{
ret
[
p
]
=
appTimestamps
[
p
]
-
si
.
process
;
}
}
}
ret
.
startupInterrupted
=
Number
(
Services
.
startup
.
interrupted
)
;
let
maximalNumberOfConcurrentThreads
=
Telemetry
.
maximalNumberOfConcurrentThreads
;
if
(
maximalNumberOfConcurrentThreads
)
{
ret
.
maximalNumberOfConcurrentThreads
=
maximalNumberOfConcurrentThreads
;
}
if
(
Utils
.
isContentProcess
)
{
return
ret
;
}
let
debugService
=
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
;
let
isDebuggerAttached
=
debugService
.
isDebuggerAttached
;
gWasDebuggerAttached
=
gWasDebuggerAttached
|
|
isDebuggerAttached
;
ret
.
debuggerAttached
=
Number
(
gWasDebuggerAttached
)
;
let
shutdownDuration
=
Telemetry
.
lastShutdownDuration
;
if
(
shutdownDuration
)
{
ret
.
shutdownDuration
=
shutdownDuration
;
}
let
failedProfileLockCount
=
Telemetry
.
failedProfileLockCount
;
if
(
failedProfileLockCount
)
{
ret
.
failedProfileLockCount
=
failedProfileLockCount
;
}
for
(
let
ioCounter
in
this
.
_startupIO
)
{
ret
[
ioCounter
]
=
this
.
_startupIO
[
ioCounter
]
;
}
let
activeTicks
=
this
.
_sessionActiveTicks
;
if
(
isSubsession
)
{
activeTicks
=
this
.
_sessionActiveTicks
-
this
.
_subsessionStartActiveTicks
;
}
if
(
clearSubsession
)
{
this
.
_subsessionStartActiveTicks
=
this
.
_sessionActiveTicks
;
}
ret
.
activeTicks
=
activeTicks
;
return
ret
;
}
getHistograms
:
function
getHistograms
(
clearSubsession
)
{
return
Telemetry
.
getSnapshotForHistograms
(
"
main
"
clearSubsession
!
this
.
_testing
)
;
}
getKeyedHistograms
(
clearSubsession
)
{
return
Telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
clearSubsession
!
this
.
_testing
)
;
}
getScalars
(
subsession
clearSubsession
keyed
)
{
if
(
!
subsession
)
{
this
.
_log
.
trace
(
"
getScalars
-
We
only
support
scalars
in
subsessions
.
"
)
;
return
{
}
;
}
let
scalarsSnapshot
=
keyed
?
Telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
clearSubsession
!
this
.
_testing
)
:
Telemetry
.
getSnapshotForScalars
(
"
main
"
clearSubsession
!
this
.
_testing
)
;
return
scalarsSnapshot
;
}
getMetadata
:
function
getMetadata
(
reason
)
{
const
sessionStartDate
=
Utils
.
toLocalTimeISOString
(
Utils
.
truncateToHours
(
this
.
_sessionStartDate
)
)
;
const
subsessionStartDate
=
Utils
.
toLocalTimeISOString
(
Utils
.
truncateToHours
(
this
.
_subsessionStartDate
)
)
;
const
monotonicNow
=
Policy
.
monotonicNow
(
)
;
let
ret
=
{
reason
revision
:
AppConstants
.
SOURCE_REVISION_URL
timezoneOffset
:
-
this
.
_subsessionStartDate
.
getTimezoneOffset
(
)
previousBuildId
:
this
.
_previousBuildId
sessionId
:
this
.
_sessionId
subsessionId
:
this
.
_subsessionId
previousSessionId
:
this
.
_previousSessionId
previousSubsessionId
:
this
.
_previousSubsessionId
subsessionCounter
:
this
.
_subsessionCounter
profileSubsessionCounter
:
this
.
_profileSubsessionCounter
sessionStartDate
subsessionStartDate
sessionLength
:
Math
.
floor
(
monotonicNow
/
1000
)
subsessionLength
:
Math
.
floor
(
(
monotonicNow
-
this
.
_subsessionStartTimeMonotonic
)
/
1000
)
}
;
if
(
this
.
_addons
)
{
ret
.
addons
=
this
.
_addons
;
}
let
flashVersion
=
this
.
getFlashVersion
(
)
;
if
(
flashVersion
)
{
ret
.
flashVersion
=
flashVersion
;
}
return
ret
;
}
assemblePayloadWithMeasurements
(
simpleMeasurements
info
reason
clearSubsession
)
{
const
isSubsession
=
IS_UNIFIED_TELEMETRY
&
&
!
this
.
_isClassicReason
(
reason
)
;
clearSubsession
=
IS_UNIFIED_TELEMETRY
&
&
clearSubsession
;
this
.
_log
.
trace
(
"
assemblePayloadWithMeasurements
-
reason
:
"
+
reason
+
"
submitting
subsession
data
:
"
+
isSubsession
)
;
const
protect
=
(
fn
defaultReturn
=
null
)
=
>
{
try
{
return
fn
(
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
assemblePayloadWithMeasurements
-
caught
exception
"
ex
)
;
return
defaultReturn
;
}
}
;
let
payloadObj
=
{
ver
:
PAYLOAD_VERSION
simpleMeasurements
}
;
if
(
Telemetry
.
canRecordExtended
)
{
payloadObj
.
log
=
[
]
;
}
if
(
Utils
.
isContentProcess
)
{
return
payloadObj
;
}
let
measurements
=
{
histograms
:
protect
(
(
)
=
>
this
.
getHistograms
(
clearSubsession
)
{
}
)
keyedHistograms
:
protect
(
(
)
=
>
this
.
getKeyedHistograms
(
clearSubsession
)
{
}
)
scalars
:
protect
(
(
)
=
>
this
.
getScalars
(
isSubsession
clearSubsession
)
{
}
)
keyedScalars
:
protect
(
(
)
=
>
this
.
getScalars
(
isSubsession
clearSubsession
true
)
{
}
)
}
;
let
measurementsContainGPU
=
Object
.
keys
(
measurements
)
.
some
(
key
=
>
"
gpu
"
in
measurements
[
key
]
)
;
let
measurementsContainSocket
=
Object
.
keys
(
measurements
)
.
some
(
key
=
>
"
socket
"
in
measurements
[
key
]
)
;
payloadObj
.
processes
=
{
}
;
let
processTypes
=
[
"
parent
"
"
content
"
"
extension
"
"
dynamic
"
]
;
if
(
measurementsContainGPU
)
{
processTypes
.
push
(
"
gpu
"
)
;
}
if
(
measurementsContainSocket
)
{
processTypes
.
push
(
"
socket
"
)
;
}
for
(
const
processType
of
processTypes
)
{
let
processPayload
=
{
}
;
for
(
const
key
in
measurements
)
{
let
payloadLoc
=
processPayload
;
if
(
processType
=
=
"
parent
"
&
&
(
key
=
=
"
histograms
"
|
|
key
=
=
"
keyedHistograms
"
)
)
{
payloadLoc
=
payloadObj
;
}
if
(
processType
=
=
"
dynamic
"
&
&
key
!
=
=
"
scalars
"
)
{
continue
;
}
payloadLoc
[
key
]
=
measurements
[
key
]
[
processType
]
|
|
{
}
;
}
payloadObj
.
processes
[
processType
]
=
processPayload
;
}
payloadObj
.
info
=
info
;
if
(
Telemetry
.
canRecordExtended
)
{
payloadObj
.
slowSQL
=
protect
(
(
)
=
>
Telemetry
.
slowSQL
)
;
payloadObj
.
fileIOReports
=
protect
(
(
)
=
>
Telemetry
.
fileIOReports
)
;
payloadObj
.
lateWrites
=
protect
(
(
)
=
>
Telemetry
.
lateWrites
)
;
payloadObj
.
addonDetails
=
protect
(
(
)
=
>
AddonManagerPrivate
.
getTelemetryDetails
(
)
)
;
let
clearUIsession
=
!
(
reason
=
=
REASON_GATHER_PAYLOAD
|
|
reason
=
=
REASON_GATHER_SUBSESSION_PAYLOAD
)
;
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
payloadObj
.
UIMeasurements
=
protect
(
(
)
=
>
UITelemetry
.
getUIMeasurements
(
clearUIsession
)
)
;
}
if
(
this
.
_slowSQLStartup
&
&
!
!
Object
.
keys
(
this
.
_slowSQLStartup
)
.
length
&
&
(
Object
.
keys
(
this
.
_slowSQLStartup
.
mainThread
)
.
length
|
|
Object
.
keys
(
this
.
_slowSQLStartup
.
otherThreads
)
.
length
)
)
{
payloadObj
.
slowSQLStartup
=
this
.
_slowSQLStartup
;
}
if
(
!
this
.
_isClassicReason
(
reason
)
)
{
payloadObj
.
processes
.
parent
.
gc
=
protect
(
(
)
=
>
GCTelemetry
.
entries
(
"
main
"
clearSubsession
)
)
;
payloadObj
.
processes
.
content
.
gc
=
protect
(
(
)
=
>
GCTelemetry
.
entries
(
"
content
"
clearSubsession
)
)
;
}
let
stacks
=
protect
(
(
)
=
>
Telemetry
.
snapshotCapturedStacks
(
true
)
)
;
if
(
stacks
&
&
"
captures
"
in
stacks
&
&
stacks
.
captures
.
length
)
{
payloadObj
.
processes
.
parent
.
capturedStacks
=
stacks
;
}
}
return
payloadObj
;
}
startNewSubsession
(
)
{
this
.
_subsessionStartDate
=
Policy
.
now
(
)
;
this
.
_subsessionStartTimeMonotonic
=
Policy
.
monotonicNow
(
)
;
this
.
_previousSubsessionId
=
this
.
_subsessionId
;
this
.
_subsessionId
=
Policy
.
generateSubsessionUUID
(
)
;
this
.
_subsessionCounter
+
+
;
this
.
_profileSubsessionCounter
+
+
;
}
getSessionPayload
:
function
getSessionPayload
(
reason
clearSubsession
)
{
this
.
_log
.
trace
(
"
getSessionPayload
-
reason
:
"
+
reason
+
"
clearSubsession
:
"
+
clearSubsession
)
;
let
payload
;
try
{
const
isMobile
=
AppConstants
.
platform
=
=
"
android
"
;
const
isSubsession
=
isMobile
?
false
:
!
this
.
_isClassicReason
(
reason
)
;
if
(
isMobile
)
{
clearSubsession
=
false
;
}
let
measurements
=
this
.
getSimpleMeasurements
(
reason
=
=
REASON_SAVED_SESSION
isSubsession
clearSubsession
)
;
let
info
=
!
Utils
.
isContentProcess
?
this
.
getMetadata
(
reason
)
:
null
;
payload
=
this
.
assemblePayloadWithMeasurements
(
measurements
info
reason
clearSubsession
)
;
}
catch
(
ex
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_ASSEMBLE_PAYLOAD_EXCEPTION
"
)
.
add
(
1
)
;
throw
ex
;
}
finally
{
if
(
!
Utils
.
isContentProcess
&
&
clearSubsession
)
{
this
.
startNewSubsession
(
)
;
let
sessionData
=
this
.
_getSessionDataObject
(
)
;
TelemetryStorage
.
saveSessionData
(
sessionData
)
;
Services
.
obs
.
notifyObservers
(
null
"
internal
-
telemetry
-
after
-
subsession
-
split
"
)
;
}
}
return
payload
;
}
send
:
async
function
send
(
reason
)
{
this
.
_log
.
trace
(
"
send
-
Reason
"
+
reason
)
;
await
Services
.
telemetry
.
gatherMemory
(
)
;
const
isSubsession
=
!
this
.
_isClassicReason
(
reason
)
;
let
payload
=
this
.
getSessionPayload
(
reason
isSubsession
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
return
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
;
}
attachEarlyObservers
(
)
{
this
.
addObserver
(
"
sessionstore
-
windows
-
restored
"
)
;
if
(
AppConstants
.
platform
=
=
=
"
android
"
)
{
this
.
addObserver
(
"
application
-
background
"
)
;
}
this
.
addObserver
(
"
xul
-
window
-
visible
"
)
;
this
.
addObserver
(
"
user
-
interaction
-
active
"
)
;
this
.
addObserver
(
"
user
-
interaction
-
inactive
"
)
;
}
earlyInit
(
testing
)
{
this
.
_log
.
trace
(
"
earlyInit
"
)
;
this
.
_initStarted
=
true
;
this
.
_testing
=
testing
;
if
(
this
.
_initialized
&
&
!
testing
)
{
this
.
_log
.
error
(
"
earlyInit
-
already
initialized
"
)
;
return
;
}
if
(
!
Telemetry
.
canRecordBase
&
&
!
testing
)
{
this
.
_log
.
config
(
"
earlyInit
-
Telemetry
recording
is
disabled
skipping
Chrome
process
setup
.
"
)
;
return
;
}
this
.
_sessionId
=
Policy
.
generateSessionUUID
(
)
;
this
.
startNewSubsession
(
)
;
this
.
_sessionStartDate
=
this
.
_subsessionStartDate
;
annotateCrashReport
(
this
.
_sessionId
)
;
let
previousBuildId
=
Services
.
prefs
.
getStringPref
(
TelemetryUtils
.
Preferences
.
PreviousBuildID
null
)
;
let
thisBuildID
=
Services
.
appinfo
.
appBuildID
;
if
(
previousBuildId
!
=
thisBuildID
)
{
this
.
_previousBuildId
=
previousBuildId
;
Services
.
prefs
.
setStringPref
(
TelemetryUtils
.
Preferences
.
PreviousBuildID
thisBuildID
)
;
}
this
.
attachEarlyObservers
(
)
;
}
delayedInit
(
)
{
this
.
_log
.
trace
(
"
delayedInit
"
)
;
this
.
_delayedInitTask
=
(
async
(
)
=
>
{
try
{
this
.
_initialized
=
true
;
await
this
.
_loadSessionData
(
)
;
await
TelemetryStorage
.
saveSessionData
(
this
.
_getSessionDataObject
(
)
)
;
this
.
addObserver
(
"
idle
-
daily
"
)
;
await
Services
.
telemetry
.
gatherMemory
(
)
;
Telemetry
.
asyncFetchTelemetryData
(
function
(
)
{
}
)
;
if
(
IS_UNIFIED_TELEMETRY
)
{
await
TelemetryController
.
checkAbortedSessionPing
(
)
;
if
(
!
this
.
_testing
)
{
await
this
.
_saveAbortedSessionPing
(
)
;
}
this
.
_lastEnvironmentChangeDate
=
Policy
.
monotonicNow
(
)
;
TelemetryEnvironment
.
registerChangeListener
(
ENVIRONMENT_CHANGE_LISTENER
(
reason
data
)
=
>
this
.
_onEnvironmentChange
(
reason
data
)
)
;
TelemetryScheduler
.
init
(
)
;
}
this
.
_delayedInitTask
=
null
;
}
catch
(
e
)
{
this
.
_delayedInitTask
=
null
;
throw
e
;
}
}
)
(
)
;
return
this
.
_delayedInitTask
;
}
getFlashVersion
:
function
getFlashVersion
(
)
{
let
host
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
let
tags
=
host
.
getPluginTags
(
)
;
for
(
let
i
=
0
;
i
<
tags
.
length
;
i
+
+
)
{
if
(
tags
[
i
]
.
name
=
=
"
Shockwave
Flash
"
)
{
return
tags
[
i
]
.
version
;
}
}
return
null
;
}
saveShutdownPings
(
)
{
this
.
_log
.
trace
(
"
saveShutdownPings
"
)
;
let
p
=
[
]
;
if
(
IS_UNIFIED_TELEMETRY
)
{
let
shutdownPayload
=
this
.
getSessionPayload
(
REASON_SHUTDOWN
false
)
;
const
sendOnThisSession
=
Services
.
prefs
.
getBoolPref
(
Utils
.
Preferences
.
ShutdownPingSenderFirstSession
false
)
|
|
!
TelemetryReportingPolicy
.
isFirstRun
(
)
;
let
sendWithPingsender
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
ShutdownPingSender
false
)
&
&
sendOnThisSession
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
usePingSender
:
sendWithPingsender
}
;
p
.
push
(
TelemetryController
.
submitExternalPing
(
getPingType
(
shutdownPayload
)
shutdownPayload
options
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
saveShutdownPings
-
failed
to
submit
shutdown
ping
"
e
)
)
)
;
const
sendFirstShutdownPing
=
Services
.
prefs
.
getBoolPref
(
Utils
.
Preferences
.
ShutdownPingSender
false
)
&
&
Services
.
prefs
.
getBoolPref
(
Utils
.
Preferences
.
FirstShutdownPingEnabled
false
)
&
&
TelemetryReportingPolicy
.
isFirstRun
(
)
;
if
(
sendFirstShutdownPing
)
{
let
options
=
{
addClientId
:
true
addEnvironment
:
true
usePingSender
:
true
}
;
p
.
push
(
TelemetryController
.
submitExternalPing
(
"
first
-
shutdown
"
shutdownPayload
options
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
saveShutdownPings
-
failed
to
submit
first
shutdown
ping
"
e
)
)
)
;
}
}
if
(
AppConstants
.
platform
=
=
"
android
"
&
&
Telemetry
.
canRecordExtended
)
{
let
payload
=
this
.
getSessionPayload
(
REASON_SAVED_SESSION
false
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
p
.
push
(
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
saveShutdownPings
-
failed
to
submit
saved
-
session
ping
"
e
)
)
)
;
}
return
Promise
.
all
(
p
)
;
}
testSavePendingPing
(
)
{
let
payload
=
this
.
getSessionPayload
(
REASON_SAVED_SESSION
false
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
overwrite
:
true
}
;
return
TelemetryController
.
addPendingPing
(
getPingType
(
payload
)
payload
options
)
;
}
uninstall
(
)
{
for
(
let
topic
of
this
.
_observedTopics
)
{
try
{
this
.
removeObserver
(
topic
)
;
}
catch
(
e
)
{
this
.
_log
.
warn
(
"
uninstall
-
Failed
to
remove
"
+
topic
e
)
;
}
}
}
getPayload
:
function
getPayload
(
reason
clearSubsession
)
{
this
.
_log
.
trace
(
"
getPayload
-
clearSubsession
:
"
+
clearSubsession
)
;
reason
=
reason
|
|
REASON_GATHER_PAYLOAD
;
if
(
!
Object
.
keys
(
this
.
_slowSQLStartup
)
.
length
)
{
this
.
_slowSQLStartup
=
Telemetry
.
slowSQL
;
}
Services
.
telemetry
.
gatherMemory
(
)
;
return
this
.
getSessionPayload
(
reason
clearSubsession
)
;
}
gatherStartup
:
function
gatherStartup
(
)
{
this
.
_log
.
trace
(
"
gatherStartup
"
)
;
let
counters
=
processInfo
.
getCounters
(
)
;
if
(
counters
)
{
[
this
.
_startupIO
.
startupSessionRestoreReadBytes
this
.
_startupIO
.
startupSessionRestoreWriteBytes
]
=
counters
;
}
this
.
_slowSQLStartup
=
Telemetry
.
slowSQL
;
}
setAddOns
:
function
setAddOns
(
aAddOns
)
{
this
.
_addons
=
aAddOns
;
}
testPing
:
function
testPing
(
)
{
return
this
.
send
(
REASON_TEST_PING
)
;
}
_onActiveTick
(
aUserActive
)
{
const
needsUpdate
=
aUserActive
&
&
this
.
_isUserActive
;
this
.
_isUserActive
=
aUserActive
;
if
(
needsUpdate
)
{
this
.
_sessionActiveTicks
+
+
;
Telemetry
.
scalarAdd
(
"
browser
.
engagement
.
active_ticks
"
1
)
;
}
}
observe
(
aSubject
aTopic
aData
)
{
this
.
_log
.
trace
(
"
observe
-
"
+
aTopic
+
"
notified
.
"
)
;
switch
(
aTopic
)
{
case
"
xul
-
window
-
visible
"
:
this
.
removeObserver
(
"
xul
-
window
-
visible
"
)
;
var
counters
=
processInfo
.
getCounters
(
)
;
if
(
counters
)
{
[
this
.
_startupIO
.
startupWindowVisibleReadBytes
this
.
_startupIO
.
startupWindowVisibleWriteBytes
]
=
counters
;
}
break
;
case
"
sessionstore
-
windows
-
restored
"
:
this
.
removeObserver
(
"
sessionstore
-
windows
-
restored
"
)
;
let
debugService
=
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
;
gWasDebuggerAttached
=
debugService
.
isDebuggerAttached
;
this
.
gatherStartup
(
)
;
break
;
case
"
idle
-
daily
"
:
Services
.
tm
.
dispatchToMainThread
(
function
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
gather
-
telemetry
"
)
;
}
)
;
break
;
case
"
application
-
background
"
:
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
break
;
}
let
payload
=
this
.
getSessionPayload
(
REASON_SAVED_SESSION
false
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
overwrite
:
true
}
;
TelemetryController
.
addPendingPing
(
getPingType
(
payload
)
payload
options
)
;
break
;
case
"
user
-
interaction
-
active
"
:
this
.
_onActiveTick
(
true
)
;
break
;
case
"
user
-
interaction
-
inactive
"
:
this
.
_onActiveTick
(
false
)
;
break
;
}
return
undefined
;
}
shutdownChromeProcess
(
)
{
this
.
_log
.
trace
(
"
shutdownChromeProcess
"
)
;
let
cleanup
=
(
)
=
>
{
if
(
IS_UNIFIED_TELEMETRY
)
{
TelemetryEnvironment
.
unregisterChangeListener
(
ENVIRONMENT_CHANGE_LISTENER
)
;
TelemetryScheduler
.
shutdown
(
)
;
}
this
.
uninstall
(
)
;
let
reset
=
(
)
=
>
{
this
.
_initStarted
=
false
;
this
.
_initialized
=
false
;
}
;
return
(
async
(
)
=
>
{
await
this
.
saveShutdownPings
(
)
;
if
(
IS_UNIFIED_TELEMETRY
)
{
await
TelemetryController
.
removeAbortedSessionPing
(
)
;
}
reset
(
)
;
}
)
(
)
;
}
;
if
(
!
this
.
_initStarted
)
{
return
Promise
.
resolve
(
)
;
}
if
(
!
this
.
_delayedInitTask
)
{
return
cleanup
(
)
;
}
return
this
.
_delayedInitTask
.
then
(
cleanup
)
;
}
_sendDailyPing
(
)
{
this
.
_log
.
trace
(
"
_sendDailyPing
"
)
;
let
payload
=
this
.
getSessionPayload
(
REASON_DAILY
true
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
let
promise
=
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
;
if
(
IS_UNIFIED_TELEMETRY
)
{
this
.
_saveAbortedSessionPing
(
payload
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
_sendDailyPing
-
Failed
to
save
the
aborted
session
ping
"
e
)
)
;
}
return
promise
;
}
async
_loadSessionData
(
)
{
let
data
=
await
TelemetryStorage
.
loadSessionData
(
)
;
if
(
!
data
)
{
return
null
;
}
if
(
!
(
"
profileSubsessionCounter
"
in
data
)
|
|
!
(
typeof
data
.
profileSubsessionCounter
=
=
"
number
"
)
|
|
!
(
"
subsessionId
"
in
data
)
|
|
!
(
"
sessionId
"
in
data
)
)
{
this
.
_log
.
error
(
"
_loadSessionData
-
session
data
is
invalid
"
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_SESSIONDATA_FAILED_VALIDATION
"
)
.
add
(
1
)
;
return
null
;
}
this
.
_previousSessionId
=
data
.
sessionId
;
this
.
_previousSubsessionId
=
data
.
subsessionId
;
this
.
_profileSubsessionCounter
=
data
.
profileSubsessionCounter
+
this
.
_subsessionCounter
;
this
.
_newProfilePingSent
=
"
newProfilePingSent
"
in
data
?
data
.
newProfilePingSent
:
true
;
return
data
;
}
_getSessionDataObject
(
)
{
return
{
sessionId
:
this
.
_sessionId
subsessionId
:
this
.
_subsessionId
profileSubsessionCounter
:
this
.
_profileSubsessionCounter
newProfilePingSent
:
this
.
_newProfilePingSent
}
;
}
_onEnvironmentChange
(
reason
oldEnvironment
)
{
this
.
_log
.
trace
(
"
_onEnvironmentChange
"
reason
)
;
let
now
=
Policy
.
monotonicNow
(
)
;
let
timeDelta
=
now
-
this
.
_lastEnvironmentChangeDate
;
if
(
timeDelta
<
=
MIN_SUBSESSION_LENGTH_MS
)
{
this
.
_log
.
trace
(
_onEnvironmentChange
-
throttling
;
last
change
was
{
Math
.
round
(
timeDelta
/
1000
)
}
s
ago
.
)
;
return
;
}
this
.
_lastEnvironmentChangeDate
=
now
;
let
payload
=
this
.
getSessionPayload
(
REASON_ENVIRONMENT_CHANGE
true
)
;
TelemetryScheduler
.
rescheduleDailyPing
(
payload
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
overrideEnvironment
:
oldEnvironment
}
;
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
;
}
_isClassicReason
(
reason
)
{
const
classicReasons
=
[
REASON_SAVED_SESSION
REASON_GATHER_PAYLOAD
REASON_TEST_PING
]
;
return
classicReasons
.
includes
(
reason
)
;
}
_getState
(
)
{
return
{
initialized
:
this
.
_initialized
initStarted
:
this
.
_initStarted
haveDelayedInitTask
:
!
!
this
.
_delayedInitTask
}
;
}
_saveAbortedSessionPing
(
aProvidedPayload
=
null
)
{
this
.
_log
.
trace
(
"
_saveAbortedSessionPing
"
)
;
let
payload
=
null
;
if
(
aProvidedPayload
)
{
payload
=
Cu
.
cloneInto
(
aProvidedPayload
myScope
)
;
payload
.
info
.
reason
=
REASON_ABORTED_SESSION
;
}
else
{
payload
=
this
.
getSessionPayload
(
REASON_ABORTED_SESSION
false
)
;
}
return
TelemetryController
.
saveAbortedSessionPing
(
payload
)
;
}
async
markNewProfilePingSent
(
)
{
this
.
_log
.
trace
(
"
markNewProfilePingSent
"
)
;
this
.
_newProfilePingSent
=
true
;
return
TelemetryStorage
.
saveSessionData
(
this
.
_getSessionDataObject
(
)
)
;
}
}
;
