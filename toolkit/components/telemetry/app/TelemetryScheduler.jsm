"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetryScheduler
"
]
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
TelemetrySession
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySession
.
jsm
"
)
;
const
{
TelemetryUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
const
{
clearTimeout
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
idleService
:
[
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
"
nsIIdleService
"
]
}
)
;
const
REASON_ENVIRONMENT_CHANGE
=
"
environment
-
change
"
;
const
MIN_SUBSESSION_LENGTH_MS
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
minSubsessionLength
"
5
*
60
)
*
1000
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
IDLE_TIMEOUT_SECONDS
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
idleTimeout
"
5
*
60
)
;
const
SCHEDULER_TICK_INTERVAL_MS
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
scheduler
.
tickInterval
"
5
*
60
)
*
1000
;
const
SCHEDULER_TICK_IDLE_INTERVAL_MS
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
scheduler
.
idleTickInterval
"
60
*
60
)
*
1000
;
const
SCHEDULER_TICK_MAX_IDLE_DELAY_MS
=
60
*
1000
;
const
ABORTED_SESSION_UPDATE_INTERVAL_MS
=
5
*
60
*
1000
;
const
SCHEDULER_MIDNIGHT_TOLERANCE_MS
=
15
*
60
*
1000
;
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
setSchedulerTickTimeout
:
(
callback
delayMs
)
=
>
setTimeout
(
callback
delayMs
)
clearSchedulerTickTimeout
:
id
=
>
clearTimeout
(
id
)
prioEncode
:
(
batchID
prioParams
)
=
>
PrioEncoder
.
encode
(
batchID
prioParams
)
}
;
var
TelemetryScheduler
=
{
_lastDailyPingTime
:
0
_lastSessionCheckpointTime
:
0
_log
:
null
_schedulerTimer
:
null
_schedulerInterval
:
0
_shuttingDown
:
true
_isUserIdle
:
false
init
(
)
{
this
.
_log
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
"
TelemetryScheduler
:
:
"
)
;
this
.
_log
.
trace
(
"
init
"
)
;
this
.
_shuttingDown
=
false
;
this
.
_isUserIdle
=
false
;
let
now
=
Policy
.
now
(
)
;
this
.
_lastDailyPingTime
=
now
.
getTime
(
)
;
this
.
_lastSessionCheckpointTime
=
now
.
getTime
(
)
;
this
.
_rescheduleTimeout
(
)
;
idleService
.
addIdleObserver
(
this
IDLE_TIMEOUT_SECONDS
)
;
Services
.
obs
.
addObserver
(
this
"
wake_notification
"
)
;
}
shutdown
(
)
{
if
(
this
.
_shuttingDown
)
{
if
(
this
.
_log
)
{
this
.
_log
.
error
(
"
shutdown
-
Already
shut
down
"
)
;
}
else
{
Cu
.
reportError
(
"
TelemetryScheduler
.
shutdown
-
Already
shut
down
"
)
;
}
return
;
}
this
.
_log
.
trace
(
"
shutdown
"
)
;
if
(
this
.
_schedulerTimer
)
{
Policy
.
clearSchedulerTickTimeout
(
this
.
_schedulerTimer
)
;
this
.
_schedulerTimer
=
null
;
}
idleService
.
removeIdleObserver
(
this
IDLE_TIMEOUT_SECONDS
)
;
Services
.
obs
.
removeObserver
(
this
"
wake_notification
"
)
;
this
.
_shuttingDown
=
true
;
}
_clearTimeout
(
)
{
if
(
this
.
_schedulerTimer
)
{
Policy
.
clearSchedulerTickTimeout
(
this
.
_schedulerTimer
)
;
}
}
_rescheduleTimeout
(
)
{
this
.
_log
.
trace
(
"
_rescheduleTimeout
-
isUserIdle
:
"
+
this
.
_isUserIdle
)
;
if
(
this
.
_shuttingDown
)
{
this
.
_log
.
warn
(
"
_rescheduleTimeout
-
already
shutdown
"
)
;
return
;
}
this
.
_clearTimeout
(
)
;
const
now
=
Policy
.
now
(
)
;
let
timeout
=
SCHEDULER_TICK_INTERVAL_MS
;
if
(
this
.
_isUserIdle
)
{
timeout
=
SCHEDULER_TICK_IDLE_INTERVAL_MS
;
const
nextMidnight
=
TelemetryUtils
.
getNextMidnight
(
now
)
;
timeout
=
Math
.
min
(
timeout
nextMidnight
.
getTime
(
)
-
now
.
getTime
(
)
)
;
}
this
.
_log
.
trace
(
"
_rescheduleTimeout
-
scheduling
next
tick
for
"
+
new
Date
(
now
.
getTime
(
)
+
timeout
)
)
;
this
.
_schedulerTimer
=
Policy
.
setSchedulerTickTimeout
(
(
)
=
>
this
.
_onSchedulerTick
(
)
timeout
)
;
}
_sentDailyPingToday
(
nowDate
)
{
const
todayDate
=
TelemetryUtils
.
truncateToDays
(
nowDate
)
;
return
(
this
.
_lastDailyPingTime
>
=
todayDate
.
getTime
(
)
)
;
}
_isDailyPingDue
(
nowDate
)
{
if
(
this
.
_sentDailyPingToday
(
nowDate
)
)
{
this
.
_log
.
trace
(
"
_isDailyPingDue
-
already
sent
one
today
"
)
;
return
false
;
}
const
timeSinceLastDaily
=
nowDate
.
getTime
(
)
-
this
.
_lastDailyPingTime
;
if
(
timeSinceLastDaily
<
MIN_SUBSESSION_LENGTH_MS
)
{
this
.
_log
.
trace
(
"
_isDailyPingDue
-
delaying
daily
to
keep
minimum
session
length
"
)
;
return
false
;
}
this
.
_log
.
trace
(
"
_isDailyPingDue
-
is
due
"
)
;
return
true
;
}
_saveAbortedPing
(
now
competingPayload
=
null
)
{
this
.
_lastSessionCheckpointTime
=
now
;
return
TelemetrySession
.
saveAbortedSessionPing
(
competingPayload
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
_saveAbortedPing
-
Failed
"
e
)
)
;
}
observe
(
aSubject
aTopic
aData
)
{
this
.
_log
.
trace
(
"
observe
-
aTopic
:
"
+
aTopic
)
;
switch
(
aTopic
)
{
case
"
idle
"
:
this
.
_isUserIdle
=
true
;
return
this
.
_onSchedulerTick
(
)
;
case
"
active
"
:
this
.
_isUserIdle
=
false
;
return
this
.
_onSchedulerTick
(
true
)
;
case
"
wake_notification
"
:
return
this
.
_onSchedulerTick
(
true
)
;
}
return
undefined
;
}
_makeIdleDispatch
(
dispatchFn
)
{
this
.
_log
.
trace
(
"
_makeIdleDispatch
"
)
;
let
fn
=
dispatchFn
;
let
l
=
(
msg
)
=
>
this
.
_log
.
trace
(
msg
)
;
return
{
cancel
(
)
{
fn
=
undefined
;
}
dispatch
(
resolve
reject
)
{
l
(
"
_makeIdleDispatch
.
dispatch
-
!
!
fn
:
"
+
!
!
fn
)
;
if
(
!
fn
)
{
return
Promise
.
resolve
(
)
.
then
(
resolve
reject
)
;
}
return
fn
(
resolve
reject
)
;
}
}
;
}
_onSchedulerTick
(
dispatchOnIdle
=
false
)
{
this
.
_log
.
trace
(
"
_onSchedulerTick
-
dispatchOnIdle
:
"
+
dispatchOnIdle
)
;
this
.
_clearTimeout
(
)
;
if
(
this
.
_idleDispatch
)
{
this
.
_idleDispatch
.
cancel
(
)
;
}
if
(
this
.
_shuttingDown
)
{
this
.
_log
.
warn
(
"
_onSchedulerTick
-
already
shutdown
.
"
)
;
return
Promise
.
reject
(
new
Error
(
"
Already
shutdown
.
"
)
)
;
}
let
promise
=
Promise
.
resolve
(
)
;
try
{
if
(
dispatchOnIdle
)
{
this
.
_idleDispatch
=
this
.
_makeIdleDispatch
(
(
resolve
reject
)
=
>
{
this
.
_log
.
trace
(
"
_onSchedulerTick
-
ildeDispatchToMainThread
dispatch
"
)
;
return
this
.
_schedulerTickLogic
(
)
.
then
(
resolve
reject
)
;
}
)
;
promise
=
new
Promise
(
(
resolve
reject
)
=
>
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
return
this
.
_idleDispatch
?
this
.
_idleDispatch
.
dispatch
(
resolve
reject
)
:
Promise
.
resolve
(
)
.
then
(
resolve
reject
)
;
}
SCHEDULER_TICK_MAX_IDLE_DELAY_MS
)
)
;
}
else
{
promise
=
this
.
_schedulerTickLogic
(
)
;
}
}
catch
(
e
)
{
this
.
_log
.
error
(
"
_onSchedulerTick
-
There
was
an
exception
"
e
)
;
}
finally
{
this
.
_rescheduleTimeout
(
)
;
}
return
promise
;
}
_schedulerTickLogic
(
)
{
this
.
_log
.
trace
(
"
_schedulerTickLogic
"
)
;
let
nowDate
=
Policy
.
now
(
)
;
let
now
=
nowDate
.
getTime
(
)
;
const
shouldSendDaily
=
this
.
_isDailyPingDue
(
nowDate
)
;
if
(
shouldSendDaily
)
{
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
Daily
ping
due
.
"
)
;
this
.
_lastDailyPingTime
=
now
;
return
TelemetrySession
.
sendDailyPing
(
)
;
}
const
isAbortedPingDue
=
(
now
-
this
.
_lastSessionCheckpointTime
)
>
=
ABORTED_SESSION_UPDATE_INTERVAL_MS
;
if
(
isAbortedPingDue
)
{
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
Aborted
session
ping
due
.
"
)
;
return
this
.
_saveAbortedPing
(
now
)
;
}
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
No
ping
due
.
"
)
;
return
Promise
.
resolve
(
)
;
}
reschedulePings
(
reason
competingPayload
=
null
)
{
if
(
this
.
_shuttingDown
)
{
this
.
_log
.
error
(
"
reschedulePings
-
already
shutdown
"
)
;
return
;
}
this
.
_log
.
trace
(
"
reschedulePings
-
reason
:
"
+
reason
)
;
let
now
=
Policy
.
now
(
)
;
if
(
reason
=
=
REASON_ENVIRONMENT_CHANGE
)
{
this
.
_saveAbortedPing
(
now
.
getTime
(
)
competingPayload
)
;
let
nearestMidnight
=
TelemetryUtils
.
getNearestMidnight
(
now
SCHEDULER_MIDNIGHT_TOLERANCE_MS
)
;
if
(
nearestMidnight
)
{
this
.
_lastDailyPingTime
=
now
.
getTime
(
)
;
}
}
this
.
_rescheduleTimeout
(
)
;
}
}
;
