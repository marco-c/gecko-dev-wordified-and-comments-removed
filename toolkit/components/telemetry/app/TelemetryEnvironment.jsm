"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetryEnvironment
"
"
Policy
"
]
;
const
myScope
=
this
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
TelemetryUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
)
;
const
{
ObjectUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
Utils
=
TelemetryUtils
;
const
{
AddonManager
AddonManagerPrivate
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AttributionCode
"
"
resource
:
/
/
/
modules
/
AttributionCode
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ProfileAge
"
"
resource
:
/
/
gre
/
modules
/
ProfileAge
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
WindowsRegistry
"
"
resource
:
/
/
gre
/
modules
/
WindowsRegistry
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
WindowsVersionInfo
"
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
WindowsVersionInfo
.
jsm
"
)
;
const
MAX_ADDON_STRING_LENGTH
=
100
;
const
MAX_ATTRIBUTION_STRING_LENGTH
=
100
;
const
MAX_EXPERIMENT_ID_LENGTH
=
100
;
const
MAX_EXPERIMENT_BRANCH_LENGTH
=
100
;
const
MAX_EXPERIMENT_TYPE_LENGTH
=
20
;
const
MAX_EXPERIMENT_ENROLLMENT_ID_LENGTH
=
40
;
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
_intlLoaded
:
false
_browserDelayedStartup
(
)
{
if
(
Policy
.
_intlLoaded
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
let
startupTopic
=
"
browser
-
delayed
-
startup
-
finished
"
;
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
)
{
if
(
topic
=
=
startupTopic
)
{
Services
.
obs
.
removeObserver
(
observer
startupTopic
)
;
resolve
(
)
;
}
}
startupTopic
)
;
}
)
;
}
}
;
var
gActiveExperimentStartupBuffer
=
new
Map
(
)
;
var
gGlobalEnvironment
;
function
getGlobal
(
)
{
if
(
!
gGlobalEnvironment
)
{
gGlobalEnvironment
=
new
EnvironmentCache
(
)
;
}
return
gGlobalEnvironment
;
}
var
TelemetryEnvironment
=
{
get
currentEnvironment
(
)
{
return
getGlobal
(
)
.
currentEnvironment
;
}
onInitialized
(
)
{
return
getGlobal
(
)
.
onInitialized
(
)
;
}
delayedInit
(
)
{
return
getGlobal
(
)
.
delayedInit
(
)
;
}
registerChangeListener
(
name
listener
)
{
return
getGlobal
(
)
.
registerChangeListener
(
name
listener
)
;
}
unregisterChangeListener
(
name
)
{
return
getGlobal
(
)
.
unregisterChangeListener
(
name
)
;
}
setExperimentActive
(
id
branch
options
=
{
}
)
{
if
(
gGlobalEnvironment
)
{
gGlobalEnvironment
.
setExperimentActive
(
id
branch
options
)
;
}
else
{
gActiveExperimentStartupBuffer
.
set
(
id
{
branch
options
}
)
;
}
}
setExperimentInactive
(
id
)
{
if
(
gGlobalEnvironment
)
{
gGlobalEnvironment
.
setExperimentInactive
(
id
)
;
}
else
{
gActiveExperimentStartupBuffer
.
delete
(
id
)
;
}
}
getActiveExperiments
(
)
{
if
(
gGlobalEnvironment
)
{
return
gGlobalEnvironment
.
getActiveExperiments
(
)
;
}
const
result
=
{
}
;
for
(
const
[
id
{
branch
}
]
of
gActiveExperimentStartupBuffer
.
entries
(
)
)
{
result
[
id
]
=
branch
;
}
return
result
;
}
shutdown
(
)
{
return
getGlobal
(
)
.
shutdown
(
)
;
}
RECORD_PREF_STATE
:
1
RECORD_PREF_VALUE
:
2
RECORD_DEFAULTPREF_VALUE
:
3
RECORD_DEFAULTPREF_STATE
:
4
async
testWatchPreferences
(
prefMap
)
{
return
getGlobal
(
)
.
_watchPreferences
(
prefMap
)
;
}
testReset
(
)
{
return
getGlobal
(
)
.
reset
(
)
;
}
testCleanRestart
(
)
{
getGlobal
(
)
.
shutdown
(
)
;
gGlobalEnvironment
=
null
;
gActiveExperimentStartupBuffer
=
new
Map
(
)
;
return
getGlobal
(
)
;
}
}
;
const
RECORD_PREF_STATE
=
TelemetryEnvironment
.
RECORD_PREF_STATE
;
const
RECORD_PREF_VALUE
=
TelemetryEnvironment
.
RECORD_PREF_VALUE
;
const
RECORD_DEFAULTPREF_VALUE
=
TelemetryEnvironment
.
RECORD_DEFAULTPREF_VALUE
;
const
RECORD_DEFAULTPREF_STATE
=
TelemetryEnvironment
.
RECORD_DEFAULTPREF_STATE
;
const
DEFAULT_ENVIRONMENT_PREFS
=
new
Map
(
[
[
"
app
.
feedback
.
baseURL
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
support
.
baseURL
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
accessibility
.
browsewithcaret
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
accessibility
.
force_disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
normandy
.
test
-
prefs
.
bool
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
normandy
.
test
-
prefs
.
integer
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
normandy
.
test
-
prefs
.
string
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
shield
.
optoutstudies
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
interval
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
service
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
silent
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
cache
.
disk
.
enable
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
cache
.
disk
.
capacity
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
cache
.
memory
.
enable
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
cache
.
offline
.
enable
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
formfill
.
enable
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
newtabpage
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
shell
.
checkDefaultBrowser
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
search
.
ignoredJAREngines
"
{
what
:
RECORD_DEFAULTPREF_VALUE
}
]
[
"
browser
.
search
.
region
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
search
.
suggest
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
search
.
widget
.
inNavBar
"
{
what
:
RECORD_DEFAULTPREF_VALUE
}
]
[
"
browser
.
startup
.
homepage
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
browser
.
startup
.
page
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
urlbar
.
showSearchSuggestionsFirst
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
urlbar
.
suggest
.
searches
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
devtools
.
chrome
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
devtools
.
debugger
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
devtools
.
debugger
.
remote
-
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
doh
-
rollout
.
doorhanger
-
decision
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
dom
.
ipc
.
plugins
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
dom
.
ipc
.
plugins
.
sandbox
-
level
.
flash
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
dom
.
ipc
.
processCount
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
dom
.
max_script_run_time
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
autoDisableScopes
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
enabledScopes
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
blocklist
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
formautofill
.
addresses
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
formautofill
.
addresses
.
capture
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
formautofill
.
creditCards
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
formautofill
.
creditCards
.
available
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
formautofill
.
creditCards
.
used
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
strictCompatibility
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
update
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
update
.
url
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
update
.
background
.
url
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
screenshots
.
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
general
.
config
.
filename
"
{
what
:
RECORD_DEFAULTPREF_STATE
}
]
[
"
general
.
smoothScroll
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
gfx
.
direct2d
.
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
gfx
.
direct2d
.
force
-
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
gfx
.
webrender
.
all
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
gfx
.
webrender
.
all
.
qualified
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
acceleration
.
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
acceleration
.
force
-
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
async
-
pan
-
zoom
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
async
-
video
-
oop
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
async
-
video
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
componentalpha
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
d3d11
.
disable
-
warp
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
d3d11
.
force
-
warp
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
offmainthreadcomposition
.
force
-
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
prefer
-
d3d9
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
prefer
-
opengl
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layout
.
css
.
devPixelsPerPx
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
network
.
http
.
windows
-
sso
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
network
.
proxy
.
autoconfig_url
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
network
.
proxy
.
http
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
network
.
proxy
.
ssl
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
network
.
trr
.
mode
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
pdfjs
.
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
places
.
history
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
plugins
.
show_infobar
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
privacy
.
firstparty
.
isolate
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
privacy
.
resistFingerprinting
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
privacy
.
trackingprotection
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
privacy
.
donottrackheader
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
security
.
enterprise_roots
.
auto
-
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
security
.
enterprise_roots
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
security
.
pki
.
mitm_detected
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
security
.
mixed_content
.
block_active_content
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
security
.
mixed_content
.
block_display_content
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
security
.
tls
.
version
.
enable
-
deprecated
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
signon
.
management
.
page
.
breach
-
alerts
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
signon
.
autofillForms
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
signon
.
generation
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
signon
.
rememberSignons
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
toolkit
.
telemetry
.
pioneerId
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
widget
.
content
.
allow
-
gtk
-
dark
-
theme
"
{
what
:
RECORD_DEFAULTPREF_VALUE
}
]
[
"
widget
.
content
.
gtk
-
theme
-
override
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
widget
.
content
.
gtk
-
high
-
contrast
.
enabled
"
{
what
:
RECORD_DEFAULTPREF_VALUE
}
]
[
"
xpinstall
.
signatures
.
required
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
nimbus
.
debug
"
{
what
:
RECORD_PREF_VALUE
}
]
]
)
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
PREF_BLOCKLIST_ENABLED
=
"
extensions
.
blocklist
.
enabled
"
;
const
PREF_DISTRIBUTION_ID
=
"
distribution
.
id
"
;
const
PREF_DISTRIBUTION_VERSION
=
"
distribution
.
version
"
;
const
PREF_DISTRIBUTOR
=
"
app
.
distributor
"
;
const
PREF_DISTRIBUTOR_CHANNEL
=
"
app
.
distributor
.
channel
"
;
const
PREF_APP_PARTNER_BRANCH
=
"
app
.
partner
.
"
;
const
PREF_PARTNER_ID
=
"
mozilla
.
partner
.
id
"
;
const
COMPOSITOR_CREATED_TOPIC
=
"
compositor
:
created
"
;
const
COMPOSITOR_PROCESS_ABORTED_TOPIC
=
"
compositor
:
process
-
aborted
"
;
const
DISTRIBUTION_CUSTOMIZATION_COMPLETE_TOPIC
=
"
distribution
-
customization
-
complete
"
;
const
GFX_FEATURES_READY_TOPIC
=
"
gfx
-
features
-
ready
"
;
const
SEARCH_ENGINE_MODIFIED_TOPIC
=
"
browser
-
search
-
engine
-
modified
"
;
const
SEARCH_SERVICE_TOPIC
=
"
browser
-
search
-
service
"
;
const
SESSIONSTORE_WINDOWS_RESTORED_TOPIC
=
"
sessionstore
-
windows
-
restored
"
;
const
PREF_CHANGED_TOPIC
=
"
nsPref
:
changed
"
;
const
BLOCKLIST_LOADED_TOPIC
=
"
plugin
-
blocklist
-
loaded
"
;
const
AUTO_UPDATE_PREF_CHANGE_TOPIC
=
UpdateUtils
.
PER_INSTALLATION_PREFS
[
"
app
.
update
.
auto
"
]
.
observerTopic
;
const
BACKGROUND_UPDATE_PREF_CHANGE_TOPIC
=
UpdateUtils
.
PER_INSTALLATION_PREFS
[
"
app
.
update
.
background
.
enabled
"
]
.
observerTopic
;
const
SERVICES_INFO_CHANGE_TOPIC
=
"
sync
-
ui
-
state
:
update
"
;
function
enforceBoolean
(
aValue
)
{
if
(
typeof
aValue
!
=
=
"
number
"
&
&
typeof
aValue
!
=
=
"
boolean
"
)
{
return
null
;
}
return
Boolean
(
aValue
)
;
}
function
getBrowserLocale
(
)
{
try
{
return
Services
.
locale
.
appLocaleAsBCP47
;
}
catch
(
e
)
{
return
null
;
}
}
function
getSystemLocale
(
)
{
try
{
return
Cc
[
"
mozilla
.
org
/
intl
/
ospreferences
;
1
"
]
.
getService
(
Ci
.
mozIOSPreferences
)
.
systemLocale
;
}
catch
(
e
)
{
return
null
;
}
}
function
getSystemLocales
(
)
{
try
{
return
Cc
[
"
mozilla
.
org
/
intl
/
ospreferences
;
1
"
]
.
getService
(
Ci
.
mozIOSPreferences
)
.
systemLocales
;
}
catch
(
e
)
{
return
null
;
}
}
function
getRegionalPrefsLocales
(
)
{
try
{
return
Cc
[
"
mozilla
.
org
/
intl
/
ospreferences
;
1
"
]
.
getService
(
Ci
.
mozIOSPreferences
)
.
regionalPrefsLocales
;
}
catch
(
e
)
{
return
null
;
}
}
function
getIntlSettings
(
)
{
return
{
requestedLocales
:
Services
.
locale
.
requestedLocales
availableLocales
:
Services
.
locale
.
availableLocales
appLocales
:
Services
.
locale
.
appLocalesAsBCP47
systemLocales
:
getSystemLocales
(
)
regionalPrefsLocales
:
getRegionalPrefsLocales
(
)
acceptLanguages
:
Services
.
prefs
.
getComplexValue
(
"
intl
.
accept_languages
"
Ci
.
nsIPrefLocalizedString
)
.
data
.
split
(
"
"
)
.
map
(
str
=
>
str
.
trim
(
)
)
}
;
}
function
getSysinfoProperty
(
aPropertyName
aDefault
)
{
try
{
return
Services
.
sysinfo
.
getProperty
(
aPropertyName
)
;
}
catch
(
e
)
{
}
return
aDefault
;
}
function
getGfxField
(
aPropertyName
aDefault
)
{
let
gfxInfo
=
Cc
[
"
mozilla
.
org
/
gfx
/
info
;
1
"
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
try
{
let
gfxProp
=
gfxInfo
[
aPropertyName
]
;
if
(
gfxProp
!
=
=
undefined
&
&
gfxProp
!
=
=
"
"
)
{
return
gfxProp
;
}
}
catch
(
e
)
{
}
return
aDefault
;
}
function
limitStringToLength
(
aString
aMaxLength
)
{
if
(
typeof
aString
!
=
=
"
string
"
)
{
return
null
;
}
return
aString
.
substring
(
0
aMaxLength
)
;
}
function
forceToStringOrNull
(
aValue
)
{
if
(
aValue
=
=
=
null
)
{
return
null
;
}
return
String
(
aValue
)
;
}
function
getGfxAdapter
(
aSuffix
=
"
"
)
{
let
memoryMB
=
parseInt
(
getGfxField
(
"
adapterRAM
"
+
aSuffix
null
)
10
)
;
if
(
Number
.
isNaN
(
memoryMB
)
)
{
memoryMB
=
null
;
}
return
{
description
:
getGfxField
(
"
adapterDescription
"
+
aSuffix
null
)
vendorID
:
getGfxField
(
"
adapterVendorID
"
+
aSuffix
null
)
deviceID
:
getGfxField
(
"
adapterDeviceID
"
+
aSuffix
null
)
subsysID
:
getGfxField
(
"
adapterSubsysID
"
+
aSuffix
null
)
RAM
:
memoryMB
driver
:
getGfxField
(
"
adapterDriver
"
+
aSuffix
null
)
driverVendor
:
getGfxField
(
"
adapterDriverVendor
"
+
aSuffix
null
)
driverVersion
:
getGfxField
(
"
adapterDriverVersion
"
+
aSuffix
null
)
driverDate
:
getGfxField
(
"
adapterDriverDate
"
+
aSuffix
null
)
}
;
}
function
EnvironmentAddonBuilder
(
environment
)
{
this
.
_environment
=
environment
;
this
.
_pendingTask
=
null
;
this
.
_blocklistObserverAdded
=
false
;
this
.
_loaded
=
false
;
this
.
_shutdownState
=
"
Initial
"
;
}
EnvironmentAddonBuilder
.
prototype
=
{
async
init
(
)
{
AddonManager
.
beforeShutdown
.
addBlocker
(
"
EnvironmentAddonBuilder
"
(
)
=
>
this
.
_shutdownBlocker
(
)
{
fetchState
:
(
)
=
>
this
.
_shutdownState
}
)
;
this
.
_pendingTask
=
(
async
(
)
=
>
{
try
{
this
.
_shutdownState
=
"
Awaiting
_updateAddons
"
;
await
this
.
_updateAddons
(
true
)
;
if
(
!
this
.
_environment
.
_addonsAreFull
)
{
this
.
_shutdownState
=
"
Awaiting
AddonManagerPrivate
.
databaseReady
"
;
await
AddonManagerPrivate
.
databaseReady
;
this
.
_shutdownState
=
"
Awaiting
second
_updateAddons
"
;
await
this
.
_updateAddons
(
)
;
}
}
catch
(
err
)
{
this
.
_environment
.
_log
.
error
(
"
init
-
Exception
in
_updateAddons
"
err
)
;
}
finally
{
this
.
_pendingTask
=
null
;
this
.
_shutdownState
=
"
_pendingTask
init
complete
.
No
longer
blocking
.
"
;
}
}
)
(
)
;
return
this
.
_pendingTask
;
}
watchForChanges
(
)
{
this
.
_loaded
=
true
;
AddonManager
.
addAddonListener
(
this
)
;
}
onEnabled
(
addon
)
{
this
.
_onAddonChange
(
addon
)
;
}
onDisabled
(
addon
)
{
this
.
_onAddonChange
(
addon
)
;
}
onInstalled
(
addon
)
{
this
.
_onAddonChange
(
addon
)
;
}
onUninstalling
(
addon
)
{
this
.
_onAddonChange
(
addon
)
;
}
onUninstalled
(
addon
)
{
this
.
_onAddonChange
(
addon
)
;
}
_onAddonChange
(
addon
)
{
if
(
addon
&
&
addon
.
isBuiltin
&
&
!
addon
.
isSystem
)
{
return
;
}
this
.
_environment
.
_log
.
trace
(
"
_onAddonChange
"
)
;
this
.
_checkForChanges
(
"
addons
-
changed
"
)
;
}
observe
(
aSubject
aTopic
aData
)
{
this
.
_environment
.
_log
.
trace
(
"
observe
-
Topic
"
+
aTopic
)
;
if
(
aTopic
=
=
BLOCKLIST_LOADED_TOPIC
)
{
Services
.
obs
.
removeObserver
(
this
BLOCKLIST_LOADED_TOPIC
)
;
this
.
_blocklistObserverAdded
=
false
;
let
gmpPluginsPromise
=
this
.
_getActiveGMPlugins
(
)
;
gmpPluginsPromise
.
then
(
gmpPlugins
=
>
{
let
{
addons
}
=
this
.
_environment
.
_currentEnvironment
;
addons
.
activeGMPlugins
=
gmpPlugins
;
}
err
=
>
{
this
.
_environment
.
_log
.
error
(
"
blocklist
observe
:
Error
collecting
plugins
"
err
)
;
}
)
;
}
}
_checkForChanges
(
changeReason
)
{
if
(
this
.
_pendingTask
)
{
this
.
_environment
.
_log
.
trace
(
"
_checkForChanges
-
task
already
pending
dropping
change
with
reason
"
+
changeReason
)
;
return
;
}
this
.
_shutdownState
=
"
_checkForChanges
awaiting
_updateAddons
"
;
this
.
_pendingTask
=
this
.
_updateAddons
(
)
.
then
(
result
=
>
{
this
.
_pendingTask
=
null
;
this
.
_shutdownState
=
"
No
longer
blocking
_updateAddons
resolved
"
;
if
(
result
.
changed
)
{
this
.
_environment
.
_onEnvironmentChange
(
changeReason
result
.
oldEnvironment
)
;
}
}
err
=
>
{
this
.
_pendingTask
=
null
;
this
.
_shutdownState
=
"
No
longer
blocking
_updateAddons
rejected
"
;
this
.
_environment
.
_log
.
error
(
"
_checkForChanges
:
Error
collecting
addons
"
err
)
;
}
)
;
}
_shutdownBlocker
(
)
{
if
(
this
.
_loaded
)
{
AddonManager
.
removeAddonListener
(
this
)
;
if
(
this
.
_blocklistObserverAdded
)
{
Services
.
obs
.
removeObserver
(
this
BLOCKLIST_LOADED_TOPIC
)
;
}
}
return
this
.
_pendingTask
;
}
async
_updateAddons
(
atStartup
)
{
this
.
_environment
.
_log
.
trace
(
"
_updateAddons
"
)
;
let
addons
=
{
activeAddons
:
await
this
.
_getActiveAddons
(
)
theme
:
await
this
.
_getActiveTheme
(
)
activeGMPlugins
:
await
this
.
_getActiveGMPlugins
(
atStartup
)
}
;
let
result
=
{
changed
:
!
this
.
_environment
.
_currentEnvironment
.
addons
|
|
!
ObjectUtils
.
deepEqual
(
addons
.
activeAddons
this
.
_environment
.
_currentEnvironment
.
addons
.
activeAddons
)
}
;
if
(
result
.
changed
)
{
this
.
_environment
.
_log
.
trace
(
"
_updateAddons
:
addons
differ
"
)
;
result
.
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_environment
.
_currentEnvironment
myScope
)
;
}
this
.
_environment
.
_currentEnvironment
.
addons
=
addons
;
return
result
;
}
async
_getActiveAddons
(
)
{
let
{
addons
:
allAddons
fullData
}
=
await
AddonManager
.
getActiveAddons
(
[
"
extension
"
"
service
"
]
)
;
this
.
_environment
.
_addonsAreFull
=
fullData
;
let
activeAddons
=
{
}
;
for
(
let
addon
of
allAddons
)
{
if
(
addon
.
isBuiltin
&
&
!
addon
.
isSystem
)
{
continue
;
}
try
{
let
updateDate
=
new
Date
(
Math
.
max
(
0
addon
.
updateDate
)
)
;
activeAddons
[
addon
.
id
]
=
{
version
:
limitStringToLength
(
addon
.
version
MAX_ADDON_STRING_LENGTH
)
scope
:
addon
.
scope
type
:
addon
.
type
updateDay
:
Utils
.
millisecondsToDays
(
updateDate
.
getTime
(
)
)
isSystem
:
addon
.
isSystem
isWebExtension
:
addon
.
isWebExtension
multiprocessCompatible
:
true
}
;
if
(
fullData
)
{
let
installDate
=
new
Date
(
Math
.
max
(
0
addon
.
installDate
)
)
;
Object
.
assign
(
activeAddons
[
addon
.
id
]
{
blocklisted
:
addon
.
blocklistState
!
=
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
description
:
limitStringToLength
(
addon
.
description
MAX_ADDON_STRING_LENGTH
)
name
:
limitStringToLength
(
addon
.
name
MAX_ADDON_STRING_LENGTH
)
userDisabled
:
enforceBoolean
(
addon
.
userDisabled
)
appDisabled
:
addon
.
appDisabled
foreignInstall
:
enforceBoolean
(
addon
.
foreignInstall
)
hasBinaryComponents
:
false
installDay
:
Utils
.
millisecondsToDays
(
installDate
.
getTime
(
)
)
signedState
:
addon
.
signedState
}
)
;
}
}
catch
(
ex
)
{
this
.
_environment
.
_log
.
error
(
"
_getActiveAddons
-
An
addon
was
discarded
due
to
an
error
"
ex
)
;
continue
;
}
}
return
activeAddons
;
}
async
_getActiveTheme
(
)
{
let
{
addons
:
themes
}
=
await
AddonManager
.
getActiveAddons
(
[
"
theme
"
]
)
;
let
activeTheme
=
{
}
;
let
theme
=
themes
.
find
(
theme
=
>
theme
.
isActive
)
;
if
(
theme
)
{
let
installDate
=
new
Date
(
Math
.
max
(
0
theme
.
installDate
)
)
;
let
updateDate
=
new
Date
(
Math
.
max
(
0
theme
.
updateDate
)
)
;
activeTheme
=
{
id
:
theme
.
id
blocklisted
:
theme
.
blocklistState
!
=
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
description
:
limitStringToLength
(
theme
.
description
MAX_ADDON_STRING_LENGTH
)
name
:
limitStringToLength
(
theme
.
name
MAX_ADDON_STRING_LENGTH
)
userDisabled
:
enforceBoolean
(
theme
.
userDisabled
)
appDisabled
:
theme
.
appDisabled
version
:
limitStringToLength
(
theme
.
version
MAX_ADDON_STRING_LENGTH
)
scope
:
theme
.
scope
foreignInstall
:
enforceBoolean
(
theme
.
foreignInstall
)
hasBinaryComponents
:
false
installDay
:
Utils
.
millisecondsToDays
(
installDate
.
getTime
(
)
)
updateDay
:
Utils
.
millisecondsToDays
(
updateDate
.
getTime
(
)
)
}
;
}
return
activeTheme
;
}
async
_getActiveGMPlugins
(
atStartup
)
{
if
(
atStartup
|
|
!
Services
.
blocklist
.
isLoaded
)
{
if
(
!
this
.
_blocklistObserverAdded
)
{
Services
.
obs
.
addObserver
(
this
BLOCKLIST_LOADED_TOPIC
)
;
this
.
_blocklistObserverAdded
=
true
;
}
return
{
"
dummy
-
gmp
"
:
{
version
:
"
0
.
1
"
userDisabled
:
false
applyBackgroundUpdates
:
1
}
}
;
}
let
allPlugins
=
await
AddonManager
.
getAddonsByTypes
(
[
"
plugin
"
]
)
;
let
activeGMPlugins
=
{
}
;
for
(
let
plugin
of
allPlugins
)
{
if
(
!
plugin
.
isGMPlugin
|
|
!
plugin
.
isActive
)
{
continue
;
}
try
{
activeGMPlugins
[
plugin
.
id
]
=
{
version
:
plugin
.
version
userDisabled
:
enforceBoolean
(
plugin
.
userDisabled
)
applyBackgroundUpdates
:
plugin
.
applyBackgroundUpdates
}
;
}
catch
(
ex
)
{
this
.
_environment
.
_log
.
error
(
"
_getActiveGMPlugins
-
A
GMPlugin
was
discarded
due
to
an
error
"
ex
)
;
continue
;
}
}
return
activeGMPlugins
;
}
}
;
function
EnvironmentCache
(
)
{
this
.
_log
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
"
TelemetryEnvironment
:
:
"
)
;
this
.
_log
.
trace
(
"
constructor
"
)
;
this
.
_shutdown
=
false
;
this
.
_canQuerySearch
=
false
;
this
.
_sessionWasRestored
=
false
;
this
.
_changeListeners
=
new
Map
(
)
;
this
.
_watchedPrefs
=
DEFAULT_ENVIRONMENT_PREFS
;
this
.
_currentEnvironment
=
{
build
:
this
.
_getBuild
(
)
partner
:
this
.
_getPartner
(
)
system
:
this
.
_getSystem
(
)
}
;
this
.
_addObservers
(
)
;
let
p
=
[
this
.
_updateSettings
(
)
]
;
this
.
_addonBuilder
=
new
EnvironmentAddonBuilder
(
this
)
;
p
.
push
(
this
.
_addonBuilder
.
init
(
)
)
;
this
.
_currentEnvironment
.
profile
=
{
}
;
p
.
push
(
this
.
_updateProfile
(
)
)
;
if
(
AppConstants
.
MOZ_BUILD_APP
=
=
"
browser
"
)
{
p
.
push
(
this
.
_loadAttributionAsync
(
)
)
;
}
p
.
push
(
this
.
_loadAsyncUpdateSettings
(
)
)
;
p
.
push
(
this
.
_loadIntlData
(
)
)
;
for
(
const
[
id
{
branch
options
}
]
of
gActiveExperimentStartupBuffer
.
entries
(
)
)
{
this
.
setExperimentActive
(
id
branch
options
)
;
}
gActiveExperimentStartupBuffer
=
null
;
let
setup
=
(
)
=
>
{
this
.
_initTask
=
null
;
this
.
_startWatchingPrefs
(
)
;
this
.
_addonBuilder
.
watchForChanges
(
)
;
this
.
_updateGraphicsFeatures
(
)
;
return
this
.
currentEnvironment
;
}
;
this
.
_initTask
=
Promise
.
all
(
p
)
.
then
(
(
)
=
>
setup
(
)
err
=
>
{
this
.
_log
.
error
(
"
EnvironmentCache
-
error
while
initializing
"
err
)
;
return
setup
(
)
;
}
)
;
this
.
_addonsAreFull
=
false
;
}
EnvironmentCache
.
prototype
=
{
get
currentEnvironment
(
)
{
return
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
}
onInitialized
(
)
{
if
(
this
.
_initTask
)
{
return
this
.
_initTask
;
}
return
Promise
.
resolve
(
this
.
currentEnvironment
)
;
}
async
delayedInit
(
)
{
this
.
_processData
=
await
Services
.
sysinfo
.
processInfo
;
let
processData
=
await
Services
.
sysinfo
.
processInfo
;
delete
processData
.
isWow64
;
delete
processData
.
isWowARM64
;
let
oldEnv
=
null
;
if
(
!
this
.
_initTask
)
{
oldEnv
=
this
.
currentEnvironment
;
}
this
.
_cpuData
=
this
.
_getCPUData
(
)
;
this
.
_cpuData
=
{
.
.
.
processData
.
.
.
this
.
_cpuData
}
;
this
.
_currentEnvironment
.
system
.
cpu
=
this
.
_getCPUData
(
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
this
.
_hddData
=
await
Services
.
sysinfo
.
diskInfo
;
let
osData
=
await
Services
.
sysinfo
.
osInfo
;
if
(
!
this
.
_initTask
)
{
oldEnv
=
this
.
currentEnvironment
;
}
this
.
_osData
=
this
.
_getOSData
(
)
;
this
.
_osData
=
Object
.
assign
(
osData
this
.
_osData
)
;
this
.
_currentEnvironment
.
system
.
os
=
this
.
_getOSData
(
)
;
this
.
_currentEnvironment
.
system
.
hdd
=
this
.
_getHDDData
(
)
;
this
.
_currentEnvironment
.
system
.
isWow64
=
this
.
_getProcessData
(
)
.
isWow64
;
this
.
_currentEnvironment
.
system
.
isWowARM64
=
this
.
_getProcessData
(
)
.
isWowARM64
;
}
if
(
!
this
.
_initTask
)
{
this
.
_onEnvironmentChange
(
"
system
-
info
"
oldEnv
)
;
}
}
registerChangeListener
(
name
listener
)
{
this
.
_log
.
trace
(
"
registerChangeListener
for
"
+
name
)
;
if
(
this
.
_shutdown
)
{
this
.
_log
.
warn
(
"
registerChangeListener
-
already
shutdown
"
)
;
return
;
}
this
.
_changeListeners
.
set
(
name
listener
)
;
}
unregisterChangeListener
(
name
)
{
this
.
_log
.
trace
(
"
unregisterChangeListener
for
"
+
name
)
;
if
(
this
.
_shutdown
)
{
this
.
_log
.
warn
(
"
registerChangeListener
-
already
shutdown
"
)
;
return
;
}
this
.
_changeListeners
.
delete
(
name
)
;
}
setExperimentActive
(
id
branch
options
)
{
this
.
_log
.
trace
(
setExperimentActive
-
id
:
{
id
}
branch
:
{
branch
}
)
;
const
saneId
=
limitStringToLength
(
id
MAX_EXPERIMENT_ID_LENGTH
)
;
const
saneBranch
=
limitStringToLength
(
branch
MAX_EXPERIMENT_BRANCH_LENGTH
)
;
if
(
!
saneId
|
|
!
saneBranch
)
{
this
.
_log
.
error
(
"
setExperimentActive
-
the
provided
arguments
are
not
strings
.
"
)
;
return
;
}
if
(
saneId
.
length
!
=
id
.
length
|
|
saneBranch
.
length
!
=
branch
.
length
)
{
this
.
_log
.
warn
(
"
setExperimentActive
-
the
experiment
id
or
branch
were
truncated
.
"
)
;
}
if
(
options
.
hasOwnProperty
(
"
type
"
)
)
{
let
type
=
limitStringToLength
(
options
.
type
MAX_EXPERIMENT_TYPE_LENGTH
)
;
if
(
type
.
length
!
=
options
.
type
.
length
)
{
options
.
type
=
type
;
this
.
_log
.
warn
(
"
setExperimentActive
-
the
experiment
type
was
truncated
.
"
)
;
}
}
if
(
options
.
hasOwnProperty
(
"
enrollmentId
"
)
)
{
let
enrollmentId
=
limitStringToLength
(
options
.
enrollmentId
MAX_EXPERIMENT_ENROLLMENT_ID_LENGTH
)
;
if
(
enrollmentId
.
length
!
=
options
.
enrollmentId
.
length
)
{
options
.
enrollmentId
=
enrollmentId
;
this
.
_log
.
warn
(
"
setExperimentActive
-
the
enrollment
id
was
truncated
.
"
)
;
}
}
let
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
let
experiments
=
this
.
_currentEnvironment
.
experiments
|
|
{
}
;
experiments
[
saneId
]
=
{
branch
:
saneBranch
}
;
if
(
options
.
hasOwnProperty
(
"
type
"
)
)
{
experiments
[
saneId
]
.
type
=
options
.
type
;
}
if
(
options
.
hasOwnProperty
(
"
enrollmentId
"
)
)
{
experiments
[
saneId
]
.
enrollmentId
=
options
.
enrollmentId
;
}
this
.
_currentEnvironment
.
experiments
=
experiments
;
this
.
_onEnvironmentChange
(
"
experiment
-
annotation
-
changed
"
oldEnvironment
)
;
}
setExperimentInactive
(
id
)
{
this
.
_log
.
trace
(
"
setExperimentInactive
"
)
;
let
experiments
=
this
.
_currentEnvironment
.
experiments
|
|
{
}
;
if
(
id
in
experiments
)
{
let
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
delete
this
.
_currentEnvironment
.
experiments
[
id
]
;
this
.
_onEnvironmentChange
(
"
experiment
-
annotation
-
changed
"
oldEnvironment
)
;
}
}
getActiveExperiments
(
)
{
return
Cu
.
cloneInto
(
this
.
_currentEnvironment
.
experiments
|
|
{
}
myScope
)
;
}
shutdown
(
)
{
this
.
_log
.
trace
(
"
shutdown
"
)
;
this
.
_shutdown
=
true
;
}
async
_watchPreferences
(
aPreferences
)
{
this
.
_stopWatchingPrefs
(
)
;
this
.
_watchedPrefs
=
aPreferences
;
await
this
.
_updateSettings
(
)
;
this
.
_startWatchingPrefs
(
)
;
}
_getPrefData
(
)
{
let
prefData
=
{
}
;
for
(
let
[
pref
policy
]
of
this
.
_watchedPrefs
.
entries
(
)
)
{
let
prefValue
=
this
.
_getPrefValue
(
pref
policy
.
what
)
;
if
(
prefValue
=
=
=
undefined
)
{
continue
;
}
prefData
[
pref
]
=
prefValue
;
}
return
prefData
;
}
_getPrefValue
(
pref
what
)
{
let
prefType
=
Services
.
prefs
.
getPrefType
(
pref
)
;
if
(
what
=
=
TelemetryEnvironment
.
RECORD_DEFAULTPREF_VALUE
|
|
what
=
=
TelemetryEnvironment
.
RECORD_DEFAULTPREF_STATE
)
{
if
(
prefType
=
=
Ci
.
nsIPrefBranch
.
PREF_INVALID
)
{
return
undefined
;
}
}
else
if
(
!
Services
.
prefs
.
prefHasUserValue
(
pref
)
)
{
return
undefined
;
}
if
(
what
=
=
TelemetryEnvironment
.
RECORD_DEFAULTPREF_STATE
)
{
return
"
<
set
>
"
;
}
else
if
(
what
=
=
TelemetryEnvironment
.
RECORD_PREF_STATE
)
{
return
"
<
user
-
set
>
"
;
}
else
if
(
prefType
=
=
Ci
.
nsIPrefBranch
.
PREF_STRING
)
{
return
Services
.
prefs
.
getStringPref
(
pref
)
;
}
else
if
(
prefType
=
=
Ci
.
nsIPrefBranch
.
PREF_BOOL
)
{
return
Services
.
prefs
.
getBoolPref
(
pref
)
;
}
else
if
(
prefType
=
=
Ci
.
nsIPrefBranch
.
PREF_INT
)
{
return
Services
.
prefs
.
getIntPref
(
pref
)
;
}
else
if
(
prefType
=
=
Ci
.
nsIPrefBranch
.
PREF_INVALID
)
{
return
null
;
}
throw
new
Error
(
Unexpected
preference
type
(
"
{
prefType
}
"
)
for
"
{
pref
}
"
.
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsISupportsWeakReference
"
]
)
_startWatchingPrefs
(
)
{
this
.
_log
.
trace
(
"
_startWatchingPrefs
-
"
+
this
.
_watchedPrefs
)
;
Services
.
prefs
.
addObserver
(
"
"
this
true
)
;
}
_onPrefChanged
(
aData
)
{
this
.
_log
.
trace
(
"
_onPrefChanged
"
)
;
let
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
this
.
_currentEnvironment
.
settings
.
userPrefs
[
aData
]
=
this
.
_getPrefValue
(
aData
this
.
_watchedPrefs
.
get
(
aData
)
.
what
)
;
this
.
_onEnvironmentChange
(
"
pref
-
changed
"
oldEnvironment
)
;
}
_stopWatchingPrefs
(
)
{
this
.
_log
.
trace
(
"
_stopWatchingPrefs
"
)
;
Services
.
prefs
.
removeObserver
(
"
"
this
)
;
}
_addObservers
(
)
{
Services
.
obs
.
addObserver
(
this
SESSIONSTORE_WINDOWS_RESTORED_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
COMPOSITOR_CREATED_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
COMPOSITOR_PROCESS_ABORTED_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
DISTRIBUTION_CUSTOMIZATION_COMPLETE_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
GFX_FEATURES_READY_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
SEARCH_ENGINE_MODIFIED_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
SEARCH_SERVICE_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
AUTO_UPDATE_PREF_CHANGE_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
BACKGROUND_UPDATE_PREF_CHANGE_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
SERVICES_INFO_CHANGE_TOPIC
)
;
}
_removeObservers
(
)
{
Services
.
obs
.
removeObserver
(
this
SESSIONSTORE_WINDOWS_RESTORED_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
COMPOSITOR_CREATED_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
COMPOSITOR_PROCESS_ABORTED_TOPIC
)
;
try
{
Services
.
obs
.
removeObserver
(
this
DISTRIBUTION_CUSTOMIZATION_COMPLETE_TOPIC
)
;
}
catch
(
ex
)
{
}
Services
.
obs
.
removeObserver
(
this
GFX_FEATURES_READY_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
SEARCH_ENGINE_MODIFIED_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
SEARCH_SERVICE_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
AUTO_UPDATE_PREF_CHANGE_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
BACKGROUND_UPDATE_PREF_CHANGE_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
SERVICES_INFO_CHANGE_TOPIC
)
;
}
observe
(
aSubject
aTopic
aData
)
{
this
.
_log
.
trace
(
"
observe
-
aTopic
:
"
+
aTopic
+
"
aData
:
"
+
aData
)
;
switch
(
aTopic
)
{
case
SEARCH_ENGINE_MODIFIED_TOPIC
:
if
(
aData
!
=
"
engine
-
default
"
&
&
aData
!
=
"
engine
-
default
-
private
"
&
&
aData
!
=
"
engine
-
changed
"
)
{
return
;
}
if
(
aData
=
=
"
engine
-
changed
"
&
&
aSubject
.
QueryInterface
(
Ci
.
nsISearchEngine
)
&
&
Services
.
search
.
defaultEngine
!
=
aSubject
)
{
return
;
}
this
.
_onSearchEngineChange
(
)
;
break
;
case
SEARCH_SERVICE_TOPIC
:
if
(
aData
!
=
"
init
-
complete
"
)
{
return
;
}
this
.
_canQuerySearch
=
true
;
this
.
_updateSearchEngine
(
)
;
break
;
case
GFX_FEATURES_READY_TOPIC
:
case
COMPOSITOR_CREATED_TOPIC
:
this
.
_updateGraphicsFeatures
(
)
;
break
;
case
COMPOSITOR_PROCESS_ABORTED_TOPIC
:
this
.
_onCompositorProcessAborted
(
)
;
break
;
case
DISTRIBUTION_CUSTOMIZATION_COMPLETE_TOPIC
:
this
.
_updatePartner
(
)
;
Services
.
obs
.
removeObserver
(
this
aTopic
)
;
break
;
case
SESSIONSTORE_WINDOWS_RESTORED_TOPIC
:
this
.
_sessionWasRestored
=
true
;
Services
.
search
.
init
(
)
;
this
.
_updateDefaultBrowser
(
)
;
break
;
case
PREF_CHANGED_TOPIC
:
let
options
=
this
.
_watchedPrefs
.
get
(
aData
)
;
if
(
options
&
&
!
options
.
requiresRestart
)
{
this
.
_onPrefChanged
(
aData
)
;
}
break
;
case
AUTO_UPDATE_PREF_CHANGE_TOPIC
:
this
.
_currentEnvironment
.
settings
.
update
.
autoDownload
=
aData
=
=
"
true
"
;
break
;
case
BACKGROUND_UPDATE_PREF_CHANGE_TOPIC
:
this
.
_currentEnvironment
.
settings
.
update
.
background
=
aData
=
=
"
true
"
;
break
;
case
SERVICES_INFO_CHANGE_TOPIC
:
this
.
_updateServicesInfo
(
)
;
break
;
}
}
async
_updateSearchEngine
(
)
{
if
(
!
this
.
_canQuerySearch
)
{
this
.
_log
.
trace
(
"
_updateSearchEngine
-
ignoring
early
call
"
)
;
return
;
}
this
.
_log
.
trace
(
"
_updateSearchEngine
-
isInitialized
:
"
+
Services
.
search
.
isInitialized
)
;
if
(
!
Services
.
search
.
isInitialized
)
{
return
;
}
this
.
_currentEnvironment
.
settings
=
this
.
_currentEnvironment
.
settings
|
|
{
}
;
const
defaultEngineInfo
=
await
Services
.
search
.
getDefaultEngineInfo
(
)
;
this
.
_currentEnvironment
.
settings
.
defaultSearchEngine
=
defaultEngineInfo
.
defaultSearchEngine
;
this
.
_currentEnvironment
.
settings
.
defaultSearchEngineData
=
{
.
.
.
defaultEngineInfo
.
defaultSearchEngineData
}
;
if
(
"
defaultPrivateSearchEngine
"
in
defaultEngineInfo
)
{
this
.
_currentEnvironment
.
settings
.
defaultPrivateSearchEngine
=
defaultEngineInfo
.
defaultPrivateSearchEngine
;
}
if
(
"
defaultPrivateSearchEngineData
"
in
defaultEngineInfo
)
{
this
.
_currentEnvironment
.
settings
.
defaultPrivateSearchEngineData
=
{
.
.
.
defaultEngineInfo
.
defaultPrivateSearchEngineData
}
;
}
}
async
_onSearchEngineChange
(
)
{
this
.
_log
.
trace
(
"
_onSearchEngineChange
"
)
;
let
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
await
this
.
_updateSearchEngine
(
)
;
this
.
_onEnvironmentChange
(
"
search
-
engine
-
changed
"
oldEnvironment
)
;
}
_onCompositorProcessAborted
(
)
{
this
.
_log
.
trace
(
"
_onCompositorProcessAborted
"
)
;
let
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
this
.
_updateGraphicsFeatures
(
)
;
this
.
_onEnvironmentChange
(
"
gfx
-
features
-
changed
"
oldEnvironment
)
;
}
_updateGraphicsFeatures
(
)
{
let
gfxData
=
this
.
_currentEnvironment
.
system
.
gfx
;
try
{
let
gfxInfo
=
Cc
[
"
mozilla
.
org
/
gfx
/
info
;
1
"
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
gfxData
.
features
=
gfxInfo
.
getFeatures
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
nsIGfxInfo
.
getFeatures
(
)
caught
error
"
e
)
;
}
}
_updatePartner
(
)
{
this
.
_currentEnvironment
.
partner
=
this
.
_getPartner
(
)
;
}
_getBuild
(
)
{
let
buildData
=
{
applicationId
:
Services
.
appinfo
.
ID
|
|
null
applicationName
:
Services
.
appinfo
.
name
|
|
null
architecture
:
Services
.
sysinfo
.
get
(
"
arch
"
)
buildId
:
Services
.
appinfo
.
appBuildID
|
|
null
version
:
Services
.
appinfo
.
version
|
|
null
vendor
:
Services
.
appinfo
.
vendor
|
|
null
displayVersion
:
AppConstants
.
MOZ_APP_VERSION_DISPLAY
|
|
null
platformVersion
:
Services
.
appinfo
.
platformVersion
|
|
null
xpcomAbi
:
Services
.
appinfo
.
XPCOMABI
updaterAvailable
:
AppConstants
.
MOZ_UPDATER
}
;
return
buildData
;
}
_isDefaultBrowser
(
)
{
let
isDefault
=
(
service
.
.
.
args
)
=
>
{
try
{
return
!
!
service
.
isDefaultBrowser
(
.
.
.
args
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_isDefaultBrowser
-
Could
not
determine
if
default
browser
"
ex
)
;
return
null
;
}
}
;
if
(
!
(
"
mozilla
.
org
/
browser
/
shell
-
service
;
1
"
in
Cc
)
)
{
this
.
_log
.
info
(
"
_isDefaultBrowser
-
Could
not
obtain
browser
shell
service
"
)
;
return
null
;
}
try
{
let
{
ShellService
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
)
;
return
isDefault
(
ShellService
false
true
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_isDefaultBrowser
-
Could
not
obtain
shell
service
JSM
"
)
;
}
try
{
let
shellService
=
Cc
[
"
mozilla
.
org
/
browser
/
shell
-
service
;
1
"
]
.
getService
(
Ci
.
nsIShellService
)
;
return
isDefault
(
shellService
true
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_isDefaultBrowser
-
Could
not
obtain
shell
service
"
ex
)
;
return
null
;
}
}
_updateDefaultBrowser
(
)
{
if
(
AppConstants
.
platform
=
=
=
"
android
"
)
{
return
;
}
this
.
_currentEnvironment
.
settings
=
this
.
_currentEnvironment
.
settings
|
|
{
}
;
this
.
_currentEnvironment
.
settings
.
isDefaultBrowser
=
this
.
_sessionWasRestored
?
this
.
_isDefaultBrowser
(
)
:
null
;
}
async
_updateSettings
(
)
{
let
updateChannel
=
null
;
try
{
updateChannel
=
Utils
.
getUpdateChannel
(
)
;
}
catch
(
e
)
{
}
this
.
_currentEnvironment
.
settings
=
{
blocklistEnabled
:
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_ENABLED
true
)
e10sEnabled
:
Services
.
appinfo
.
browserTabsRemoteAutostart
e10sMultiProcesses
:
Services
.
appinfo
.
maxWebProcessCount
fissionEnabled
:
Services
.
appinfo
.
fissionAutostart
telemetryEnabled
:
Utils
.
isTelemetryEnabled
locale
:
getBrowserLocale
(
)
intl
:
Policy
.
_intlLoaded
?
getIntlSettings
(
)
:
{
}
update
:
{
channel
:
updateChannel
enabled
:
!
Services
.
policies
|
|
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
}
userPrefs
:
this
.
_getPrefData
(
)
sandbox
:
this
.
_getSandboxData
(
)
}
;
try
{
this
.
_currentEnvironment
.
settings
.
launcherProcessState
=
Services
.
appinfo
.
launcherProcessState
;
}
catch
(
e
)
{
}
this
.
_currentEnvironment
.
settings
.
addonCompatibilityCheckEnabled
=
AddonManager
.
checkCompatibility
;
if
(
AppConstants
.
MOZ_BUILD_APP
=
=
"
browser
"
)
{
this
.
_updateAttribution
(
)
;
}
this
.
_updateDefaultBrowser
(
)
;
await
this
.
_updateSearchEngine
(
)
;
this
.
_loadAsyncUpdateSettingsFromCache
(
)
;
}
_getSandboxData
(
)
{
let
effectiveContentProcessLevel
=
null
;
let
contentWin32kLockdownState
=
null
;
try
{
let
sandboxSettings
=
Cc
[
"
mozilla
.
org
/
sandbox
/
sandbox
-
settings
;
1
"
]
.
getService
(
Ci
.
mozISandboxSettings
)
;
effectiveContentProcessLevel
=
sandboxSettings
.
effectiveContentSandboxLevel
;
contentWin32kLockdownState
=
sandboxSettings
.
contentWin32kLockdownState
;
}
catch
(
e
)
{
}
return
{
effectiveContentProcessLevel
contentWin32kLockdownState
}
;
}
async
_updateProfile
(
)
{
let
profileAccessor
=
await
ProfileAge
(
)
;
let
creationDate
=
await
profileAccessor
.
created
;
let
resetDate
=
await
profileAccessor
.
reset
;
let
firstUseDate
=
await
profileAccessor
.
firstUse
;
this
.
_currentEnvironment
.
profile
.
creationDate
=
Utils
.
millisecondsToDays
(
creationDate
)
;
if
(
resetDate
)
{
this
.
_currentEnvironment
.
profile
.
resetDate
=
Utils
.
millisecondsToDays
(
resetDate
)
;
}
if
(
firstUseDate
)
{
this
.
_currentEnvironment
.
profile
.
firstUseDate
=
Utils
.
millisecondsToDays
(
firstUseDate
)
;
}
}
async
_loadAttributionAsync
(
)
{
try
{
await
AttributionCode
.
getAttrDataAsync
(
)
;
}
catch
(
e
)
{
return
;
}
this
.
_updateAttribution
(
)
;
}
_updateAttribution
(
)
{
let
data
=
null
;
try
{
data
=
AttributionCode
.
getCachedAttributionData
(
)
;
}
catch
(
e
)
{
}
if
(
!
data
|
|
!
Object
.
keys
(
data
)
.
length
)
{
return
;
}
let
attributionData
=
{
}
;
for
(
let
key
in
data
)
{
attributionData
[
key
]
=
limitStringToLength
(
data
[
key
]
MAX_ATTRIBUTION_STRING_LENGTH
)
;
}
this
.
_currentEnvironment
.
settings
.
attribution
=
attributionData
;
}
async
_loadAsyncUpdateSettings
(
)
{
if
(
AppConstants
.
MOZ_UPDATER
)
{
this
.
_updateAutoDownloadCache
=
await
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
this
.
_updateBackgroundCache
=
await
UpdateUtils
.
readUpdateConfigSetting
(
"
app
.
update
.
background
.
enabled
"
)
;
}
else
{
this
.
_updateAutoDownloadCache
=
false
;
this
.
_updateBackgroundCache
=
false
;
}
this
.
_loadAsyncUpdateSettingsFromCache
(
)
;
}
_loadAsyncUpdateSettingsFromCache
(
)
{
if
(
this
.
_updateAutoDownloadCache
!
=
=
undefined
)
{
this
.
_currentEnvironment
.
settings
.
update
.
autoDownload
=
this
.
_updateAutoDownloadCache
;
}
if
(
this
.
_updateBackgroundCache
!
=
=
undefined
)
{
this
.
_currentEnvironment
.
settings
.
update
.
background
=
this
.
_updateBackgroundCache
;
}
}
async
_loadIntlData
(
)
{
await
Policy
.
_browserDelayedStartup
(
)
;
this
.
_currentEnvironment
.
settings
.
intl
=
getIntlSettings
(
)
;
Policy
.
_intlLoaded
=
true
;
}
async
_getFxaSignedInUser
(
)
{
return
fxAccounts
.
getSignedInUser
(
)
;
}
async
_updateServicesInfo
(
)
{
let
syncEnabled
=
false
;
let
accountEnabled
=
false
;
let
weaveService
=
Cc
[
"
mozilla
.
org
/
weave
/
service
;
1
"
]
.
getService
(
)
.
wrappedJSObject
;
syncEnabled
=
weaveService
&
&
weaveService
.
enabled
;
if
(
syncEnabled
)
{
accountEnabled
=
true
;
}
else
{
try
{
let
user
=
await
this
.
_getFxaSignedInUser
(
)
;
if
(
user
)
{
accountEnabled
=
true
;
}
}
catch
(
e
)
{
delete
this
.
_currentEnvironment
.
services
;
this
.
_log
.
error
(
"
_updateServicesInfo
(
)
caught
error
"
e
)
;
return
;
}
}
this
.
_currentEnvironment
.
services
=
{
accountEnabled
syncEnabled
}
;
}
_getPartner
(
)
{
let
partnerData
=
{
distributionId
:
Services
.
prefs
.
getStringPref
(
PREF_DISTRIBUTION_ID
null
)
distributionVersion
:
Services
.
prefs
.
getStringPref
(
PREF_DISTRIBUTION_VERSION
null
)
partnerId
:
Services
.
prefs
.
getStringPref
(
PREF_PARTNER_ID
null
)
distributor
:
Services
.
prefs
.
getStringPref
(
PREF_DISTRIBUTOR
null
)
distributorChannel
:
Services
.
prefs
.
getStringPref
(
PREF_DISTRIBUTOR_CHANNEL
null
)
}
;
let
partnerBranch
=
Services
.
prefs
.
getBranch
(
PREF_APP_PARTNER_BRANCH
)
;
partnerData
.
partnerNames
=
partnerBranch
.
getChildList
(
"
"
)
;
return
partnerData
;
}
_cpuData
:
null
_getCPUData
(
)
{
if
(
this
.
_cpuData
)
{
return
this
.
_cpuData
;
}
this
.
_cpuData
=
{
}
;
const
CPU_EXTENSIONS
=
[
"
hasMMX
"
"
hasSSE
"
"
hasSSE2
"
"
hasSSE3
"
"
hasSSSE3
"
"
hasSSE4A
"
"
hasSSE4_1
"
"
hasSSE4_2
"
"
hasAVX
"
"
hasAVX2
"
"
hasAES
"
"
hasEDSP
"
"
hasARMv6
"
"
hasARMv7
"
"
hasNEON
"
"
hasUserCET
"
]
;
let
availableExts
=
[
]
;
for
(
let
ext
of
CPU_EXTENSIONS
)
{
if
(
getSysinfoProperty
(
ext
false
)
)
{
availableExts
.
push
(
ext
)
;
}
}
this
.
_cpuData
.
extensions
=
availableExts
;
return
this
.
_cpuData
;
}
_processData
:
null
_getProcessData
(
)
{
if
(
this
.
_processData
)
{
return
this
.
_processData
;
}
return
{
}
;
}
_getDeviceData
(
)
{
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
return
null
;
}
return
{
model
:
getSysinfoProperty
(
"
device
"
null
)
manufacturer
:
getSysinfoProperty
(
"
manufacturer
"
null
)
hardware
:
getSysinfoProperty
(
"
hardware
"
null
)
isTablet
:
getSysinfoProperty
(
"
tablet
"
null
)
}
;
}
_osData
:
null
_getOSData
(
)
{
if
(
this
.
_osData
)
{
return
this
.
_osData
;
}
this
.
_osData
=
{
name
:
forceToStringOrNull
(
getSysinfoProperty
(
"
name
"
null
)
)
version
:
forceToStringOrNull
(
getSysinfoProperty
(
"
version
"
null
)
)
locale
:
forceToStringOrNull
(
getSystemLocale
(
)
)
}
;
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
this
.
_osData
.
kernelVersion
=
forceToStringOrNull
(
getSysinfoProperty
(
"
kernel_version
"
null
)
)
;
}
else
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
const
WINDOWS_UBR_KEY_PATH
=
"
SOFTWARE
\
\
Microsoft
\
\
Windows
NT
\
\
CurrentVersion
"
;
let
versionInfo
=
WindowsVersionInfo
.
get
(
{
throwOnError
:
false
}
)
;
this
.
_osData
.
servicePackMajor
=
versionInfo
.
servicePackMajor
;
this
.
_osData
.
servicePackMinor
=
versionInfo
.
servicePackMinor
;
this
.
_osData
.
windowsBuildNumber
=
versionInfo
.
buildNumber
;
if
(
typeof
this
.
_osData
.
version
=
=
=
"
string
"
&
&
Services
.
vc
.
compare
(
this
.
_osData
.
version
"
10
"
)
>
=
0
)
{
let
ubr
=
WindowsRegistry
.
readRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_LOCAL_MACHINE
WINDOWS_UBR_KEY_PATH
"
UBR
"
Ci
.
nsIWindowsRegKey
.
WOW64_64
)
;
this
.
_osData
.
windowsUBR
=
ubr
!
=
=
undefined
?
ubr
:
null
;
}
}
return
this
.
_osData
;
}
_hddData
:
null
_getHDDData
(
)
{
if
(
this
.
_hddData
)
{
return
this
.
_hddData
;
}
let
nullData
=
{
model
:
null
revision
:
null
type
:
null
}
;
return
{
profile
:
nullData
binary
:
nullData
system
:
nullData
}
;
}
_getSecurityAppData
(
)
{
const
maxStringLength
=
256
;
const
keys
=
[
[
"
registeredAntiVirus
"
"
antivirus
"
]
[
"
registeredAntiSpyware
"
"
antispyware
"
]
[
"
registeredFirewall
"
"
firewall
"
]
]
;
let
result
=
{
}
;
for
(
let
[
inKey
outKey
]
of
keys
)
{
let
prop
=
getSysinfoProperty
(
inKey
null
)
;
if
(
prop
)
{
prop
=
limitStringToLength
(
prop
maxStringLength
)
.
split
(
"
;
"
)
;
}
result
[
outKey
]
=
prop
;
}
return
result
;
}
_getGFXData
(
)
{
let
gfxData
=
{
D2DEnabled
:
getGfxField
(
"
D2DEnabled
"
null
)
DWriteEnabled
:
getGfxField
(
"
DWriteEnabled
"
null
)
ContentBackend
:
getGfxField
(
"
ContentBackend
"
null
)
Headless
:
getGfxField
(
"
isHeadless
"
null
)
EmbeddedInFirefoxReality
:
getGfxField
(
"
EmbeddedInFirefoxReality
"
null
)
adapters
:
[
]
monitors
:
[
]
features
:
{
}
}
;
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
let
gfxInfo
=
Cc
[
"
mozilla
.
org
/
gfx
/
info
;
1
"
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
try
{
gfxData
.
monitors
=
gfxInfo
.
getMonitors
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
nsIGfxInfo
.
getMonitors
(
)
caught
error
"
e
)
;
}
}
try
{
let
gfxInfo
=
Cc
[
"
mozilla
.
org
/
gfx
/
info
;
1
"
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
gfxData
.
features
=
gfxInfo
.
getFeatures
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
nsIGfxInfo
.
getFeatures
(
)
caught
error
"
e
)
;
}
gfxData
.
adapters
.
push
(
getGfxAdapter
(
"
"
)
)
;
gfxData
.
adapters
[
0
]
.
GPUActive
=
true
;
let
hasGPU2
=
getGfxField
(
"
adapterDeviceID2
"
null
)
!
=
=
null
;
if
(
!
hasGPU2
)
{
this
.
_log
.
trace
(
"
_getGFXData
-
Only
one
display
adapter
detected
.
"
)
;
return
gfxData
;
}
this
.
_log
.
trace
(
"
_getGFXData
-
Two
display
adapters
detected
.
"
)
;
gfxData
.
adapters
.
push
(
getGfxAdapter
(
"
2
"
)
)
;
gfxData
.
adapters
[
1
]
.
GPUActive
=
getGfxField
(
"
isGPU2Active
"
null
)
;
return
gfxData
;
}
_getSystem
(
)
{
let
memoryMB
=
getSysinfoProperty
(
"
memsize
"
null
)
;
if
(
memoryMB
)
{
memoryMB
=
Math
.
round
(
memoryMB
/
1024
/
1024
)
;
}
let
virtualMB
=
getSysinfoProperty
(
"
virtualmemsize
"
null
)
;
if
(
virtualMB
)
{
virtualMB
=
Math
.
round
(
virtualMB
/
1024
/
1024
)
;
}
let
data
=
{
memoryMB
virtualMaxMB
:
virtualMB
cpu
:
this
.
_getCPUData
(
)
os
:
this
.
_getOSData
(
)
hdd
:
this
.
_getHDDData
(
)
gfx
:
this
.
_getGFXData
(
)
appleModelId
:
getSysinfoProperty
(
"
appleModelId
"
null
)
hasWinPackageId
:
getSysinfoProperty
(
"
hasWinPackageId
"
null
)
}
;
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
data
=
{
.
.
.
this
.
_getProcessData
(
)
.
.
.
data
}
;
}
else
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
data
.
device
=
this
.
_getDeviceData
(
)
;
}
if
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
6
.
2
"
)
)
{
data
.
sec
=
this
.
_getSecurityAppData
(
)
;
}
return
data
;
}
_onEnvironmentChange
(
what
oldEnvironment
)
{
this
.
_log
.
trace
(
"
_onEnvironmentChange
for
"
+
what
)
;
if
(
this
.
_shutdown
)
{
this
.
_log
.
trace
(
"
_onEnvironmentChange
-
Already
shut
down
.
"
)
;
return
;
}
if
(
ObjectUtils
.
deepEqual
(
this
.
_currentEnvironment
oldEnvironment
)
)
{
this
.
_log
.
trace
(
"
_onEnvironmentChange
-
Environment
didn
'
t
change
"
)
;
return
;
}
for
(
let
[
name
listener
]
of
this
.
_changeListeners
)
{
try
{
this
.
_log
.
debug
(
"
_onEnvironmentChange
-
calling
"
+
name
)
;
listener
(
what
oldEnvironment
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
_onEnvironmentChange
-
listener
"
+
name
+
"
caught
error
"
e
)
;
}
}
}
reset
(
)
{
this
.
_shutdown
=
false
;
}
}
;
