"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetryUtils
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
const
MILLISECONDS_PER_DAY
=
24
*
60
*
60
*
1000
;
const
PREF_TELEMETRY_ENABLED
=
"
toolkit
.
telemetry
.
enabled
"
;
const
IS_CONTENT_PROCESS
=
(
function
(
)
{
let
runtime
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
return
runtime
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
;
}
)
(
)
;
var
TelemetryUtils
=
{
Preferences
:
Object
.
freeze
(
{
ArchiveEnabled
:
"
toolkit
.
telemetry
.
archive
.
enabled
"
CachedClientId
:
"
toolkit
.
telemetry
.
cachedClientID
"
DisableFuzzingDelay
:
"
toolkit
.
telemetry
.
testing
.
disableFuzzingDelay
"
FirstRun
:
"
toolkit
.
telemetry
.
reportingpolicy
.
firstRun
"
FirstShutdownPingEnabled
:
"
toolkit
.
telemetry
.
firstShutdownPing
.
enabled
"
HealthPingEnabled
:
"
toolkit
.
telemetry
.
healthping
.
enabled
"
HybridContentEnabled
:
"
toolkit
.
telemetry
.
hybridContent
.
enabled
"
IPCBatchTimeout
:
"
toolkit
.
telemetry
.
ipcBatchTimeout
"
OverrideOfficialCheck
:
"
toolkit
.
telemetry
.
send
.
overrideOfficialCheck
"
OverridePreRelease
:
"
toolkit
.
telemetry
.
testing
.
overridePreRelease
"
OverrideUpdateChannel
:
"
toolkit
.
telemetry
.
overrideUpdateChannel
"
Server
:
"
toolkit
.
telemetry
.
server
"
ShutdownPingSender
:
"
toolkit
.
telemetry
.
shutdownPingSender
.
enabled
"
ShutdownPingSenderFirstSession
:
"
toolkit
.
telemetry
.
shutdownPingSender
.
enabledFirstSession
"
TelemetryEnabled
:
"
toolkit
.
telemetry
.
enabled
"
Unified
:
"
toolkit
.
telemetry
.
unified
"
UntrustedModulesPingFrequency
:
"
toolkit
.
telemetry
.
untrustedModulesPing
.
frequency
"
UpdatePing
:
"
toolkit
.
telemetry
.
updatePing
.
enabled
"
NewProfilePingEnabled
:
"
toolkit
.
telemetry
.
newProfilePing
.
enabled
"
NewProfilePingDelay
:
"
toolkit
.
telemetry
.
newProfilePing
.
delay
"
PreviousBuildID
:
"
toolkit
.
telemetry
.
previousBuildID
"
EventPingEnabled
:
"
toolkit
.
telemetry
.
eventping
.
enabled
"
EventPingEventLimit
:
"
toolkit
.
telemetry
.
eventping
.
eventLimit
"
EventPingMinimumFrequency
:
"
toolkit
.
telemetry
.
eventping
.
minimumFrequency
"
EventPingMaximumFrequency
:
"
toolkit
.
telemetry
.
eventping
.
maximumFrequency
"
LogLevel
:
"
toolkit
.
telemetry
.
log
.
level
"
LogDump
:
"
toolkit
.
telemetry
.
log
.
dump
"
AcceptedPolicyDate
:
"
datareporting
.
policy
.
dataSubmissionPolicyNotifiedTime
"
AcceptedPolicyVersion
:
"
datareporting
.
policy
.
dataSubmissionPolicyAcceptedVersion
"
BypassNotification
:
"
datareporting
.
policy
.
dataSubmissionPolicyBypassNotification
"
CurrentPolicyVersion
:
"
datareporting
.
policy
.
currentPolicyVersion
"
DataSubmissionEnabled
:
"
datareporting
.
policy
.
dataSubmissionEnabled
"
FhrUploadEnabled
:
"
datareporting
.
healthreport
.
uploadEnabled
"
MinimumPolicyVersion
:
"
datareporting
.
policy
.
minimumPolicyVersion
"
FirstRunURL
:
"
datareporting
.
policy
.
firstRunURL
"
}
)
get
knownClientID
(
)
{
return
"
c0ffeec0
-
ffee
-
c0ff
-
eec0
-
ffeec0ffeec0
"
;
}
get
isContentProcess
(
)
{
return
IS_CONTENT_PROCESS
;
}
get
isTelemetryEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_TELEMETRY_ENABLED
false
)
=
=
=
true
;
}
millisecondsToDays
(
aMsec
)
{
return
Math
.
floor
(
aMsec
/
MILLISECONDS_PER_DAY
)
;
}
truncateToDays
(
date
)
{
return
new
Date
(
date
.
getFullYear
(
)
date
.
getMonth
(
)
date
.
getDate
(
)
0
0
0
0
)
;
}
truncateToHours
(
date
)
{
return
new
Date
(
date
.
getFullYear
(
)
date
.
getMonth
(
)
date
.
getDate
(
)
date
.
getHours
(
)
0
0
0
)
;
}
areTimesClose
(
t1
t2
tolerance
)
{
return
Math
.
abs
(
t1
-
t2
)
<
=
tolerance
;
}
getNextMidnight
(
date
)
{
let
nextMidnight
=
new
Date
(
this
.
truncateToDays
(
date
)
)
;
nextMidnight
.
setDate
(
nextMidnight
.
getDate
(
)
+
1
)
;
return
nextMidnight
;
}
getNearestMidnight
(
date
tolerance
)
{
let
lastMidnight
=
this
.
truncateToDays
(
date
)
;
if
(
this
.
areTimesClose
(
date
.
getTime
(
)
lastMidnight
.
getTime
(
)
tolerance
)
)
{
return
lastMidnight
;
}
const
nextMidnightDate
=
this
.
getNextMidnight
(
date
)
;
if
(
this
.
areTimesClose
(
date
.
getTime
(
)
nextMidnightDate
.
getTime
(
)
tolerance
)
)
{
return
nextMidnightDate
;
}
return
null
;
}
generateUUID
(
)
{
let
str
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
return
str
.
substring
(
1
str
.
length
-
1
)
;
}
getElapsedTimeInMonths
(
aStartDate
aEndDate
)
{
return
(
aEndDate
.
getMonth
(
)
-
aStartDate
.
getMonth
(
)
)
+
12
*
(
aEndDate
.
getFullYear
(
)
-
aStartDate
.
getFullYear
(
)
)
;
}
toLocalTimeISOString
(
date
)
{
function
padNumber
(
number
length
)
{
return
number
.
toString
(
)
.
padStart
(
length
"
0
"
)
;
}
let
sign
=
(
n
)
=
>
n
>
=
0
?
"
+
"
:
"
-
"
;
let
tzOffset
=
-
date
.
getTimezoneOffset
(
)
;
return
padNumber
(
date
.
getFullYear
(
)
4
)
+
"
-
"
+
padNumber
(
date
.
getMonth
(
)
+
1
2
)
+
"
-
"
+
padNumber
(
date
.
getDate
(
)
2
)
+
"
T
"
+
padNumber
(
date
.
getHours
(
)
2
)
+
"
:
"
+
padNumber
(
date
.
getMinutes
(
)
2
)
+
"
:
"
+
padNumber
(
date
.
getSeconds
(
)
2
)
+
"
.
"
+
date
.
getMilliseconds
(
)
+
sign
(
tzOffset
)
+
padNumber
(
Math
.
floor
(
Math
.
abs
(
tzOffset
/
60
)
)
2
)
+
"
:
"
+
padNumber
(
Math
.
abs
(
tzOffset
%
60
)
2
)
;
}
monotonicNow
(
)
{
return
Services
.
telemetry
.
msSinceProcessStart
(
)
;
}
setTelemetryRecordingFlags
(
)
{
let
prereleaseChannels
=
[
"
nightly
"
"
aurora
"
"
beta
"
]
;
if
(
!
AppConstants
.
MOZILLA_OFFICIAL
)
{
prereleaseChannels
.
push
(
"
default
"
)
;
}
const
isPrereleaseChannel
=
prereleaseChannels
.
includes
(
AppConstants
.
MOZ_UPDATE_CHANNEL
)
;
const
isReleaseCandidateOnBeta
=
AppConstants
.
MOZ_UPDATE_CHANNEL
=
=
=
"
release
"
&
&
Services
.
prefs
.
getCharPref
(
"
app
.
update
.
channel
"
null
)
=
=
=
"
beta
"
;
Services
.
telemetry
.
canRecordBase
=
true
;
Services
.
telemetry
.
canRecordExtended
=
isPrereleaseChannel
|
|
isReleaseCandidateOnBeta
|
|
Services
.
prefs
.
getBoolPref
(
this
.
Preferences
.
OverridePreRelease
false
)
;
}
getUpdateChannel
(
)
{
let
overrideChannel
=
Services
.
prefs
.
getCharPref
(
this
.
Preferences
.
OverrideUpdateChannel
undefined
)
;
if
(
overrideChannel
)
{
return
overrideChannel
;
}
return
UpdateUtils
.
getUpdateChannel
(
false
)
;
}
}
;
