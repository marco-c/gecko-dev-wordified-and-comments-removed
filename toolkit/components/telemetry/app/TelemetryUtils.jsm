"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetryUtils
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
const
MILLISECONDS_PER_DAY
=
24
*
60
*
60
*
1000
;
const
PREF_TELEMETRY_ENABLED
=
"
toolkit
.
telemetry
.
enabled
"
;
const
IS_CONTENT_PROCESS
=
(
function
(
)
{
let
runtime
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
return
runtime
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
;
}
)
(
)
;
function
packHistogram
(
hgram
)
{
let
r
=
hgram
.
ranges
;
let
c
=
hgram
.
counts
;
let
retgram
=
{
range
:
[
r
[
1
]
r
[
r
.
length
-
1
]
]
bucket_count
:
r
.
length
histogram_type
:
hgram
.
histogram_type
values
:
{
}
sum
:
hgram
.
sum
}
;
let
first
=
true
;
let
last
=
0
;
for
(
let
i
=
0
;
i
<
c
.
length
;
i
+
+
)
{
let
value
=
c
[
i
]
;
if
(
!
value
)
continue
;
if
(
i
&
&
first
)
{
retgram
.
values
[
r
[
i
-
1
]
]
=
0
;
}
first
=
false
;
last
=
i
+
1
;
retgram
.
values
[
r
[
i
]
]
=
value
;
}
if
(
last
&
&
last
<
c
.
length
)
retgram
.
values
[
r
[
last
]
]
=
0
;
return
retgram
;
}
var
TelemetryUtils
=
{
Preferences
:
Object
.
freeze
(
{
ArchiveEnabled
:
"
toolkit
.
telemetry
.
archive
.
enabled
"
CachedClientId
:
"
toolkit
.
telemetry
.
cachedClientID
"
FirstRun
:
"
toolkit
.
telemetry
.
reportingpolicy
.
firstRun
"
FirstShutdownPingEnabled
:
"
toolkit
.
telemetry
.
firstShutdownPing
.
enabled
"
HealthPingEnabled
:
"
toolkit
.
telemetry
.
healthping
.
enabled
"
HybridContentEnabled
:
"
toolkit
.
telemetry
.
hybridContent
.
enabled
"
OverrideOfficialCheck
:
"
toolkit
.
telemetry
.
send
.
overrideOfficialCheck
"
OverridePreRelease
:
"
toolkit
.
telemetry
.
testing
.
overridePreRelease
"
OverrideUpdateChannel
:
"
toolkit
.
telemetry
.
overrideUpdateChannel
"
Server
:
"
toolkit
.
telemetry
.
server
"
ShutdownPingSender
:
"
toolkit
.
telemetry
.
shutdownPingSender
.
enabled
"
ShutdownPingSenderFirstSession
:
"
toolkit
.
telemetry
.
shutdownPingSender
.
enabledFirstSession
"
TelemetryEnabled
:
"
toolkit
.
telemetry
.
enabled
"
Unified
:
"
toolkit
.
telemetry
.
unified
"
UpdatePing
:
"
toolkit
.
telemetry
.
updatePing
.
enabled
"
NewProfilePingEnabled
:
"
toolkit
.
telemetry
.
newProfilePing
.
enabled
"
NewProfilePingDelay
:
"
toolkit
.
telemetry
.
newProfilePing
.
delay
"
PreviousBuildID
:
"
toolkit
.
telemetry
.
previousBuildID
"
EventPingEnabled
:
"
toolkit
.
telemetry
.
eventping
.
enabled
"
EventPingEventLimit
:
"
toolkit
.
telemetry
.
eventping
.
eventLimit
"
EventPingMinimumFrequency
:
"
toolkit
.
telemetry
.
eventping
.
minimumFrequency
"
EventPingMaximumFrequency
:
"
toolkit
.
telemetry
.
eventping
.
maximumFrequency
"
LogLevel
:
"
toolkit
.
telemetry
.
log
.
level
"
LogDump
:
"
toolkit
.
telemetry
.
log
.
dump
"
AcceptedPolicyDate
:
"
datareporting
.
policy
.
dataSubmissionPolicyNotifiedTime
"
AcceptedPolicyVersion
:
"
datareporting
.
policy
.
dataSubmissionPolicyAcceptedVersion
"
BypassNotification
:
"
datareporting
.
policy
.
dataSubmissionPolicyBypassNotification
"
CurrentPolicyVersion
:
"
datareporting
.
policy
.
currentPolicyVersion
"
DataSubmissionEnabled
:
"
datareporting
.
policy
.
dataSubmissionEnabled
"
FhrUploadEnabled
:
"
datareporting
.
healthreport
.
uploadEnabled
"
MinimumPolicyVersion
:
"
datareporting
.
policy
.
minimumPolicyVersion
"
FirstRunURL
:
"
datareporting
.
policy
.
firstRunURL
"
}
)
get
knownClientID
(
)
{
return
"
c0ffeec0
-
ffee
-
c0ff
-
eec0
-
ffeec0ffeec0
"
;
}
get
isContentProcess
(
)
{
return
IS_CONTENT_PROCESS
;
}
get
isTelemetryEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_TELEMETRY_ENABLED
false
)
=
=
=
true
;
}
millisecondsToDays
(
aMsec
)
{
return
Math
.
floor
(
aMsec
/
MILLISECONDS_PER_DAY
)
;
}
truncateToDays
(
date
)
{
return
new
Date
(
date
.
getFullYear
(
)
date
.
getMonth
(
)
date
.
getDate
(
)
0
0
0
0
)
;
}
truncateToHours
(
date
)
{
return
new
Date
(
date
.
getFullYear
(
)
date
.
getMonth
(
)
date
.
getDate
(
)
date
.
getHours
(
)
0
0
0
)
;
}
areTimesClose
(
t1
t2
tolerance
)
{
return
Math
.
abs
(
t1
-
t2
)
<
=
tolerance
;
}
getNextMidnight
(
date
)
{
let
nextMidnight
=
new
Date
(
this
.
truncateToDays
(
date
)
)
;
nextMidnight
.
setDate
(
nextMidnight
.
getDate
(
)
+
1
)
;
return
nextMidnight
;
}
getNearestMidnight
(
date
tolerance
)
{
let
lastMidnight
=
this
.
truncateToDays
(
date
)
;
if
(
this
.
areTimesClose
(
date
.
getTime
(
)
lastMidnight
.
getTime
(
)
tolerance
)
)
{
return
lastMidnight
;
}
const
nextMidnightDate
=
this
.
getNextMidnight
(
date
)
;
if
(
this
.
areTimesClose
(
date
.
getTime
(
)
nextMidnightDate
.
getTime
(
)
tolerance
)
)
{
return
nextMidnightDate
;
}
return
null
;
}
generateUUID
(
)
{
let
str
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
return
str
.
substring
(
1
str
.
length
-
1
)
;
}
getElapsedTimeInMonths
(
aStartDate
aEndDate
)
{
return
(
aEndDate
.
getMonth
(
)
-
aStartDate
.
getMonth
(
)
)
+
12
*
(
aEndDate
.
getFullYear
(
)
-
aStartDate
.
getFullYear
(
)
)
;
}
toLocalTimeISOString
(
date
)
{
function
padNumber
(
number
length
)
{
return
number
.
toString
(
)
.
padStart
(
length
"
0
"
)
;
}
let
sign
=
(
n
)
=
>
n
>
=
0
?
"
+
"
:
"
-
"
;
let
tzOffset
=
-
date
.
getTimezoneOffset
(
)
;
return
padNumber
(
date
.
getFullYear
(
)
4
)
+
"
-
"
+
padNumber
(
date
.
getMonth
(
)
+
1
2
)
+
"
-
"
+
padNumber
(
date
.
getDate
(
)
2
)
+
"
T
"
+
padNumber
(
date
.
getHours
(
)
2
)
+
"
:
"
+
padNumber
(
date
.
getMinutes
(
)
2
)
+
"
:
"
+
padNumber
(
date
.
getSeconds
(
)
2
)
+
"
.
"
+
date
.
getMilliseconds
(
)
+
sign
(
tzOffset
)
+
padNumber
(
Math
.
floor
(
Math
.
abs
(
tzOffset
/
60
)
)
2
)
+
"
:
"
+
padNumber
(
Math
.
abs
(
tzOffset
%
60
)
2
)
;
}
monotonicNow
(
)
{
try
{
return
Services
.
telemetry
.
msSinceProcessStart
(
)
;
}
catch
(
ex
)
{
return
Date
.
now
(
)
;
}
}
setTelemetryRecordingFlags
(
)
{
let
prereleaseChannels
=
[
"
nightly
"
"
aurora
"
"
beta
"
]
;
if
(
!
AppConstants
.
MOZILLA_OFFICIAL
)
{
prereleaseChannels
.
push
(
"
default
"
)
;
}
const
isPrereleaseChannel
=
prereleaseChannels
.
includes
(
AppConstants
.
MOZ_UPDATE_CHANNEL
)
;
const
isReleaseCandidateOnBeta
=
AppConstants
.
MOZ_UPDATE_CHANNEL
=
=
=
"
release
"
&
&
Services
.
prefs
.
getCharPref
(
"
app
.
update
.
channel
"
null
)
=
=
=
"
beta
"
;
Services
.
telemetry
.
canRecordBase
=
true
;
Services
.
telemetry
.
canRecordExtended
=
isPrereleaseChannel
|
|
isReleaseCandidateOnBeta
|
|
Services
.
prefs
.
getBoolPref
(
this
.
Preferences
.
OverridePreRelease
false
)
;
}
packHistograms
(
snapshot
testingMode
=
false
)
{
let
ret
=
{
}
;
for
(
let
[
process
histograms
]
of
Object
.
entries
(
snapshot
)
)
{
ret
[
process
]
=
{
}
;
for
(
let
[
name
value
]
of
Object
.
entries
(
histograms
)
)
{
if
(
testingMode
|
|
!
name
.
startsWith
(
"
TELEMETRY_TEST_
"
)
)
{
ret
[
process
]
[
name
]
=
packHistogram
(
value
)
;
}
}
}
return
ret
;
}
packKeyedHistograms
(
snapshot
testingMode
=
false
)
{
let
ret
=
{
}
;
for
(
let
[
process
histograms
]
of
Object
.
entries
(
snapshot
)
)
{
ret
[
process
]
=
{
}
;
for
(
let
[
name
value
]
of
Object
.
entries
(
histograms
)
)
{
if
(
testingMode
|
|
!
name
.
startsWith
(
"
TELEMETRY_TEST_
"
)
)
{
let
keys
=
Object
.
keys
(
value
)
;
if
(
keys
.
length
=
=
0
)
{
continue
;
}
ret
[
process
]
[
name
]
=
{
}
;
for
(
let
[
key
hgram
]
of
Object
.
entries
(
value
)
)
{
ret
[
process
]
[
name
]
[
key
]
=
packHistogram
(
hgram
)
;
}
}
}
}
return
ret
;
}
getUpdateChannel
(
)
{
let
overrideChannel
=
Services
.
prefs
.
getCharPref
(
this
.
Preferences
.
OverrideUpdateChannel
undefined
)
;
if
(
overrideChannel
)
{
return
overrideChannel
;
}
return
UpdateUtils
.
getUpdateChannel
(
false
)
;
}
}
;
