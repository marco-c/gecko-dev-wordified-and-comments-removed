"
use
strict
"
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
AsyncShutdown
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
{
DeferredTask
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
const
{
TelemetryUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
)
;
const
{
TelemetryControllerBase
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryControllerBase
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
Utils
=
TelemetryUtils
;
const
PING_FORMAT_VERSION
=
4
;
const
TELEMETRY_DELAY
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
initDelay
"
60
)
*
1000
;
const
TELEMETRY_TEST_DELAY
=
1
;
const
NEWPROFILE_PING_DEFAULT_DELAY
=
30
*
60
*
1000
;
const
PING_TYPE_MAIN
=
"
main
"
;
const
PING_TYPE_DELETION_REQUEST
=
"
deletion
-
request
"
;
const
PING_TYPE_UNINSTALL
=
"
uninstall
"
;
const
REASON_GATHER_PAYLOAD
=
"
gather
-
payload
"
;
const
REASON_GATHER_SUBSESSION_PAYLOAD
=
"
gather
-
subsession
-
payload
"
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
jwcrypto
"
"
resource
:
/
/
services
-
crypto
/
jwcrypto
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
ClientID
:
"
resource
:
/
/
gre
/
modules
/
ClientID
.
jsm
"
CoveragePing
:
"
resource
:
/
/
gre
/
modules
/
CoveragePing
.
jsm
"
TelemetryStorage
:
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
TelemetryEnvironment
:
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
TelemetryArchive
:
"
resource
:
/
/
gre
/
modules
/
TelemetryArchive
.
jsm
"
TelemetrySession
:
"
resource
:
/
/
gre
/
modules
/
TelemetrySession
.
jsm
"
TelemetrySend
:
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
jsm
"
TelemetryReportingPolicy
:
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
TelemetryModules
:
"
resource
:
/
/
gre
/
modules
/
ModulesPing
.
jsm
"
TelemetryUntrustedModulesPing
:
"
resource
:
/
/
gre
/
modules
/
UntrustedModulesPing
.
jsm
"
UpdatePing
:
"
resource
:
/
/
gre
/
modules
/
UpdatePing
.
jsm
"
TelemetryHealthPing
:
"
resource
:
/
/
gre
/
modules
/
HealthPing
.
jsm
"
TelemetryEventPing
:
"
resource
:
/
/
gre
/
modules
/
EventPing
.
jsm
"
TelemetryPrioPing
:
"
resource
:
/
/
gre
/
modules
/
PrioPing
.
jsm
"
UninstallPing
:
"
resource
:
/
/
gre
/
modules
/
UninstallPing
.
jsm
"
}
)
;
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
generatePingId
:
(
)
=
>
Utils
.
generateUUID
(
)
getCachedClientID
:
(
)
=
>
lazy
.
ClientID
.
getCachedClientID
(
)
}
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetryController
"
"
Policy
"
]
;
var
TelemetryController
=
Object
.
freeze
(
{
testInitLogging
(
)
{
TelemetryControllerBase
.
configureLogging
(
)
;
}
testReset
(
)
{
return
Impl
.
reset
(
)
;
}
testSetup
(
)
{
return
Impl
.
setupTelemetry
(
true
)
;
}
testShutdown
(
)
{
return
Impl
.
shutdown
(
)
;
}
testPromiseJsProbeRegistration
(
)
{
return
Promise
.
resolve
(
Impl
.
_probeRegistrationPromise
)
;
}
testRegisterJsProbes
(
)
{
return
Impl
.
registerJsProbes
(
)
;
}
testPromiseDeletionRequestPingSubmitted
(
)
{
return
Promise
.
resolve
(
Impl
.
_deletionRequestPingSubmittedPromise
)
;
}
observe
(
aSubject
aTopic
aData
)
{
return
Impl
.
observe
(
aSubject
aTopic
aData
)
;
}
submitExternalPing
(
aType
aPayload
aOptions
=
{
}
)
{
aOptions
.
addClientId
=
aOptions
.
addClientId
|
|
false
;
aOptions
.
addEnvironment
=
aOptions
.
addEnvironment
|
|
false
;
aOptions
.
usePingSender
=
aOptions
.
usePingSender
|
|
false
;
return
Impl
.
submitExternalPing
(
aType
aPayload
aOptions
)
;
}
getCurrentPingData
(
aSubsession
=
false
)
{
return
Impl
.
getCurrentPingData
(
aSubsession
)
;
}
addPendingPing
(
aType
aPayload
aOptions
=
{
}
)
{
let
options
=
aOptions
;
options
.
addClientId
=
aOptions
.
addClientId
|
|
false
;
options
.
addEnvironment
=
aOptions
.
addEnvironment
|
|
false
;
options
.
overwrite
=
aOptions
.
overwrite
|
|
false
;
return
Impl
.
addPendingPing
(
aType
aPayload
options
)
;
}
checkAbortedSessionPing
(
)
{
return
Impl
.
checkAbortedSessionPing
(
)
;
}
saveAbortedSessionPing
(
aPayload
)
{
return
Impl
.
saveAbortedSessionPing
(
aPayload
)
;
}
removeAbortedSessionPing
(
)
{
return
Impl
.
removeAbortedSessionPing
(
)
;
}
saveUninstallPing
(
)
{
return
Impl
.
saveUninstallPing
(
)
;
}
registerSyncPingShutdown
(
afnShutdown
)
{
Impl
.
registerSyncPingShutdown
(
afnShutdown
)
;
}
promiseInitialized
(
)
{
return
Impl
.
promiseInitialized
(
)
;
}
}
)
;
var
Impl
=
{
_initialized
:
false
_initStarted
:
false
_shuttingDown
:
false
_shutDown
:
false
_logger
:
null
_prevValues
:
{
}
_previousBuildID
:
undefined
_clientID
:
null
_delayedInitTask
:
null
_delayedInitTaskDeferred
:
null
_shutdownBarrier
:
new
AsyncShutdown
.
Barrier
(
"
TelemetryController
:
Waiting
for
clients
.
"
)
_shutdownState
:
"
Shutdown
not
started
.
"
_connectionsBarrier
:
new
AsyncShutdown
.
Barrier
(
"
TelemetryController
:
Waiting
for
pending
ping
activity
"
)
_testMode
:
false
_delayedNewPingTask
:
null
_probeRegistrationPromise
:
null
_deletionRequestPingSubmittedPromise
:
null
_fnSyncPingShutdown
:
null
get
_log
(
)
{
return
TelemetryControllerBase
.
log
;
}
_getApplicationSection
(
)
{
let
arch
=
null
;
try
{
arch
=
Services
.
sysinfo
.
get
(
"
arch
"
)
;
}
catch
(
e
)
{
this
.
_log
.
trace
(
"
_getApplicationSection
-
Unable
to
get
system
architecture
.
"
e
)
;
}
let
updateChannel
=
null
;
try
{
updateChannel
=
Utils
.
getUpdateChannel
(
)
;
}
catch
(
e
)
{
this
.
_log
.
trace
(
"
_getApplicationSection
-
Unable
to
get
update
channel
.
"
e
)
;
}
return
{
architecture
:
arch
buildId
:
Services
.
appinfo
.
appBuildID
name
:
Services
.
appinfo
.
name
version
:
Services
.
appinfo
.
version
displayVersion
:
AppConstants
.
MOZ_APP_VERSION_DISPLAY
vendor
:
Services
.
appinfo
.
vendor
platformVersion
:
Services
.
appinfo
.
platformVersion
xpcomAbi
:
Services
.
appinfo
.
XPCOMABI
channel
:
updateChannel
}
;
}
assemblePing
:
function
assemblePing
(
aType
aPayload
aOptions
=
{
}
)
{
this
.
_log
.
trace
(
"
assemblePing
-
Type
"
+
aType
+
"
aOptions
"
+
JSON
.
stringify
(
aOptions
)
)
;
let
payload
=
Cu
.
cloneInto
(
aPayload
{
}
)
;
let
pingData
=
{
type
:
aType
id
:
Policy
.
generatePingId
(
)
creationDate
:
Policy
.
now
(
)
.
toISOString
(
)
version
:
PING_FORMAT_VERSION
application
:
this
.
_getApplicationSection
(
)
payload
}
;
if
(
aOptions
.
addClientId
|
|
aOptions
.
overrideClientId
)
{
pingData
.
clientId
=
aOptions
.
overrideClientId
|
|
this
.
_clientID
;
}
if
(
aOptions
.
addEnvironment
)
{
pingData
.
environment
=
aOptions
.
overrideEnvironment
|
|
lazy
.
TelemetryEnvironment
.
currentEnvironment
;
}
return
pingData
;
}
_trackPendingPingTask
(
aPromise
)
{
this
.
_connectionsBarrier
.
client
.
addBlocker
(
"
Waiting
for
ping
task
"
aPromise
)
;
}
async
_submitPingLogic
(
aType
aPayload
aOptions
)
{
if
(
!
this
.
_clientID
&
&
aOptions
.
addClientId
&
&
!
aOptions
.
overrideClientId
)
{
this
.
_log
.
trace
(
"
_submitPingLogic
-
Waiting
on
client
id
"
)
;
Services
.
telemetry
.
getHistogramById
(
"
TELEMETRY_PING_SUBMISSION_WAITING_CLIENTID
"
)
.
add
(
)
;
this
.
_clientID
=
await
lazy
.
ClientID
.
getClientID
(
)
;
}
let
pingData
=
this
.
assemblePing
(
aType
aPayload
aOptions
)
;
this
.
_log
.
trace
(
"
submitExternalPing
-
ping
assembled
id
:
"
+
pingData
.
id
)
;
if
(
aOptions
.
useEncryption
=
=
=
true
)
{
try
{
if
(
!
aOptions
.
publicKey
)
{
throw
new
Error
(
"
Public
key
is
required
when
using
encryption
.
"
)
;
}
if
(
!
(
aOptions
.
schemaName
&
&
aOptions
.
schemaNamespace
&
&
aOptions
.
schemaVersion
)
)
{
throw
new
Error
(
"
Schema
name
namespace
and
version
are
required
when
using
encryption
.
"
)
;
}
const
payload
=
{
}
;
payload
.
encryptedData
=
await
lazy
.
jwcrypto
.
generateJWE
(
aOptions
.
publicKey
new
TextEncoder
(
"
utf
-
8
"
)
.
encode
(
JSON
.
stringify
(
aPayload
)
)
)
;
payload
.
schemaVersion
=
aOptions
.
schemaVersion
;
payload
.
schemaName
=
aOptions
.
schemaName
;
payload
.
schemaNamespace
=
aOptions
.
schemaNamespace
;
payload
.
encryptionKeyId
=
aOptions
.
encryptionKeyId
;
if
(
aOptions
.
addPioneerId
=
=
=
true
)
{
if
(
aOptions
.
overridePioneerId
)
{
payload
.
pioneerId
=
aOptions
.
overridePioneerId
;
}
else
{
payload
.
pioneerId
=
Services
.
prefs
.
getStringPref
(
"
toolkit
.
telemetry
.
pioneerId
"
)
;
}
payload
.
studyName
=
aOptions
.
studyName
;
}
pingData
.
payload
=
payload
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
_submitPingLogic
-
Unable
to
encrypt
ping
"
e
)
;
throw
e
;
}
}
let
archivePromise
=
lazy
.
TelemetryArchive
.
promiseArchivePing
(
pingData
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
submitExternalPing
-
Failed
to
archive
ping
"
+
pingData
.
id
e
)
)
;
let
p
=
[
archivePromise
]
;
p
.
push
(
lazy
.
TelemetrySend
.
submitPing
(
pingData
{
usePingSender
:
aOptions
.
usePingSender
}
)
)
;
return
Promise
.
all
(
p
)
.
then
(
(
)
=
>
pingData
.
id
)
;
}
submitExternalPing
:
function
send
(
aType
aPayload
aOptions
)
{
this
.
_log
.
trace
(
"
submitExternalPing
-
type
:
"
+
aType
+
"
aOptions
:
"
+
JSON
.
stringify
(
aOptions
)
)
;
if
(
this
.
_shutDown
)
{
const
errorMessage
=
"
submitExternalPing
-
Submission
is
not
allowed
after
shutdown
discarding
ping
of
type
:
"
+
aType
;
this
.
_log
.
error
(
errorMessage
)
;
return
Promise
.
reject
(
new
Error
(
errorMessage
)
)
;
}
const
typeUuid
=
/
^
[
a
-
z0
-
9
]
[
a
-
z0
-
9
-
]
+
[
a
-
z0
-
9
]
/
i
;
if
(
!
typeUuid
.
test
(
aType
)
)
{
this
.
_log
.
error
(
"
submitExternalPing
-
invalid
ping
type
:
"
+
aType
)
;
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
TELEMETRY_INVALID_PING_TYPE_SUBMITTED
"
)
;
histogram
.
add
(
aType
1
)
;
return
Promise
.
reject
(
new
Error
(
"
Invalid
type
string
submitted
.
"
)
)
;
}
if
(
aPayload
=
=
=
null
|
|
typeof
aPayload
!
=
=
"
object
"
|
|
Array
.
isArray
(
aPayload
)
)
{
this
.
_log
.
error
(
"
submitExternalPing
-
invalid
payload
type
:
"
+
typeof
aPayload
)
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
TELEMETRY_INVALID_PAYLOAD_SUBMITTED
"
)
;
histogram
.
add
(
1
)
;
return
Promise
.
reject
(
new
Error
(
"
Invalid
payload
type
submitted
.
"
)
)
;
}
let
promise
=
this
.
_submitPingLogic
(
aType
aPayload
aOptions
)
;
this
.
_trackPendingPingTask
(
promise
)
;
return
promise
;
}
addPendingPing
:
function
addPendingPing
(
aType
aPayload
aOptions
)
{
this
.
_log
.
trace
(
"
addPendingPing
-
Type
"
+
aType
+
"
aOptions
"
+
JSON
.
stringify
(
aOptions
)
)
;
let
pingData
=
this
.
assemblePing
(
aType
aPayload
aOptions
)
;
let
savePromise
=
lazy
.
TelemetryStorage
.
savePendingPing
(
pingData
)
;
let
archivePromise
=
lazy
.
TelemetryArchive
.
promiseArchivePing
(
pingData
)
.
catch
(
e
=
>
{
this
.
_log
.
error
(
"
addPendingPing
-
Failed
to
archive
ping
"
+
pingData
.
id
e
)
;
}
)
;
let
promises
=
[
savePromise
archivePromise
]
;
return
Promise
.
all
(
promises
)
.
then
(
(
)
=
>
pingData
.
id
)
;
}
async
checkAbortedSessionPing
(
)
{
let
ping
=
await
lazy
.
TelemetryStorage
.
loadAbortedSessionPing
(
)
;
this
.
_log
.
trace
(
"
checkAbortedSessionPing
-
found
aborted
-
session
ping
:
"
+
!
!
ping
)
;
if
(
!
ping
)
{
return
;
}
try
{
if
(
ping
.
clientId
!
=
Utils
.
knownClientID
)
{
await
lazy
.
TelemetryStorage
.
addPendingPing
(
ping
)
;
await
lazy
.
TelemetryArchive
.
promiseArchivePing
(
ping
)
;
}
}
catch
(
e
)
{
this
.
_log
.
error
(
"
checkAbortedSessionPing
-
Unable
to
add
the
pending
ping
"
e
)
;
}
finally
{
await
lazy
.
TelemetryStorage
.
removeAbortedSessionPing
(
)
;
}
}
saveAbortedSessionPing
(
aPayload
)
{
this
.
_log
.
trace
(
"
saveAbortedSessionPing
"
)
;
const
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
const
pingData
=
this
.
assemblePing
(
PING_TYPE_MAIN
aPayload
options
)
;
return
lazy
.
TelemetryStorage
.
saveAbortedSessionPing
(
pingData
)
;
}
removeAbortedSessionPing
(
)
{
return
lazy
.
TelemetryStorage
.
removeAbortedSessionPing
(
)
;
}
async
saveUninstallPing
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
return
undefined
;
}
this
.
_log
.
trace
(
"
saveUninstallPing
"
)
;
let
payload
=
{
}
;
try
{
payload
.
otherInstalls
=
lazy
.
UninstallPing
.
getOtherInstallsCount
(
)
;
this
.
_log
.
info
(
"
saveUninstallPing
-
otherInstalls
"
payload
.
otherInstalls
)
;
}
catch
(
e
)
{
this
.
_log
.
warn
(
"
saveUninstallPing
-
getOtherInstallCount
failed
"
e
)
;
}
const
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
const
pingData
=
this
.
assemblePing
(
PING_TYPE_UNINSTALL
payload
options
)
;
return
lazy
.
TelemetryStorage
.
saveUninstallPing
(
pingData
)
;
}
setupTelemetry
:
function
setupTelemetry
(
testing
)
{
this
.
_initStarted
=
true
;
this
.
_shuttingDown
=
false
;
this
.
_shutDown
=
false
;
this
.
_testMode
=
testing
;
this
.
_log
.
trace
(
"
setupTelemetry
"
)
;
if
(
this
.
_delayedInitTask
)
{
this
.
_log
.
error
(
"
setupTelemetry
-
init
task
already
running
"
)
;
return
this
.
_delayedInitTaskDeferred
.
promise
;
}
if
(
this
.
_initialized
&
&
!
this
.
_testMode
)
{
this
.
_log
.
error
(
"
setupTelemetry
-
already
initialized
"
)
;
return
Promise
.
resolve
(
)
;
}
this
.
_probeRegistrationPromise
=
this
.
registerJsProbes
(
)
;
lazy
.
TelemetryReportingPolicy
.
setup
(
)
;
if
(
!
TelemetryControllerBase
.
enableTelemetryRecording
(
)
)
{
this
.
_log
.
config
(
"
setupChromeProcess
-
Telemetry
recording
is
disabled
skipping
Chrome
process
setup
.
"
)
;
return
Promise
.
resolve
(
)
;
}
this
.
_attachObservers
(
)
;
lazy
.
TelemetrySession
.
earlyInit
(
this
.
_testMode
)
;
Services
.
telemetry
.
earlyInit
(
)
;
lazy
.
TelemetrySend
.
earlyInit
(
)
;
this
.
_clientID
=
lazy
.
ClientID
.
getCachedClientID
(
)
;
lazy
.
UpdatePing
.
earlyInit
(
)
;
this
.
_delayedInitTaskDeferred
=
PromiseUtils
.
defer
(
)
;
this
.
_delayedInitTask
=
new
DeferredTask
(
async
(
)
=
>
{
try
{
this
.
_initialized
=
true
;
await
lazy
.
TelemetryEnvironment
.
delayedInit
(
)
;
this
.
_clientID
=
await
lazy
.
ClientID
.
getClientID
(
)
;
const
uploadEnabled
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
if
(
uploadEnabled
&
&
this
.
_clientID
=
=
Utils
.
knownClientID
)
{
this
.
_log
.
trace
(
"
Upload
enabled
but
got
canary
client
ID
.
Resetting
.
"
)
;
await
lazy
.
ClientID
.
removeClientID
(
)
;
this
.
_clientID
=
await
lazy
.
ClientID
.
getClientID
(
)
;
}
else
if
(
!
uploadEnabled
&
&
this
.
_clientID
!
=
Utils
.
knownClientID
)
{
this
.
_log
.
trace
(
"
Upload
disabled
but
got
a
valid
client
ID
.
Setting
canary
client
ID
.
"
)
;
await
lazy
.
ClientID
.
setCanaryClientID
(
)
;
this
.
_clientID
=
await
lazy
.
ClientID
.
getClientID
(
)
;
}
await
lazy
.
TelemetrySend
.
setup
(
this
.
_testMode
)
;
await
lazy
.
TelemetrySession
.
delayedInit
(
)
;
await
Services
.
telemetry
.
delayedInit
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
NewProfilePingEnabled
false
)
&
&
!
lazy
.
TelemetrySession
.
newProfilePingSent
)
{
this
.
scheduleNewProfilePing
(
)
;
}
lazy
.
TelemetryStorage
.
runCleanPingArchiveTask
(
)
;
lazy
.
TelemetryStorage
.
removeFHRDatabase
(
)
;
if
(
!
this
.
_shuttingDown
)
{
lazy
.
TelemetryModules
.
start
(
)
;
await
lazy
.
CoveragePing
.
startup
(
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
lazy
.
TelemetryUntrustedModulesPing
.
start
(
)
;
}
}
lazy
.
TelemetryEventPing
.
startup
(
)
;
lazy
.
TelemetryPrioPing
.
startup
(
)
;
if
(
uploadEnabled
)
{
await
this
.
saveUninstallPing
(
)
.
catch
(
e
=
>
this
.
_log
.
warn
(
"
_delayedInitTask
-
saveUninstallPing
failed
"
e
)
)
;
}
else
{
await
lazy
.
TelemetryStorage
.
removeUninstallPings
(
)
.
catch
(
e
=
>
this
.
_log
.
warn
(
"
_delayedInitTask
-
saveUninstallPing
"
e
)
)
;
}
this
.
_delayedInitTaskDeferred
.
resolve
(
)
;
}
catch
(
e
)
{
this
.
_delayedInitTaskDeferred
.
reject
(
e
)
;
}
finally
{
this
.
_delayedInitTask
=
null
;
}
}
this
.
_testMode
?
TELEMETRY_TEST_DELAY
:
TELEMETRY_DELAY
this
.
_testMode
?
0
:
undefined
)
;
AsyncShutdown
.
sendTelemetry
.
addBlocker
(
"
TelemetryController
:
shutting
down
"
(
)
=
>
this
.
shutdown
(
)
(
)
=
>
this
.
_getState
(
)
)
;
this
.
_delayedInitTask
.
arm
(
)
;
return
this
.
_delayedInitTaskDeferred
.
promise
;
}
async
_cleanupOnShutdown
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
let
start
=
TelemetryUtils
.
monotonicNow
(
)
;
let
now
=
(
)
=
>
"
"
+
(
TelemetryUtils
.
monotonicNow
(
)
-
start
)
;
this
.
_shutdownStep
=
"
_cleanupOnShutdown
begin
"
+
now
(
)
;
this
.
_detachObservers
(
)
;
try
{
if
(
this
.
_delayedNewPingTask
)
{
this
.
_shutdownStep
=
"
awaiting
delayed
new
ping
task
"
+
now
(
)
;
await
this
.
_delayedNewPingTask
.
finalize
(
)
;
}
this
.
_shutdownStep
=
"
Update
"
+
now
(
)
;
lazy
.
UpdatePing
.
shutdown
(
)
;
this
.
_shutdownStep
=
"
Event
"
+
now
(
)
;
lazy
.
TelemetryEventPing
.
shutdown
(
)
;
this
.
_shutdownStep
=
"
Prio
"
+
now
(
)
;
await
lazy
.
TelemetryPrioPing
.
shutdown
(
)
;
if
(
this
.
_fnSyncPingShutdown
)
{
this
.
_shutdownStep
=
"
Sync
"
+
now
(
)
;
this
.
_fnSyncPingShutdown
(
)
;
}
this
.
_shutdownStep
=
"
Policy
"
+
now
(
)
;
lazy
.
TelemetryReportingPolicy
.
shutdown
(
)
;
this
.
_shutdownStep
=
"
Environment
"
+
now
(
)
;
lazy
.
TelemetryEnvironment
.
shutdown
(
)
;
this
.
_shutdownStep
=
"
TelemetrySend
"
+
now
(
)
;
await
lazy
.
TelemetrySend
.
shutdown
(
)
;
this
.
_shutdownStep
=
"
Health
ping
"
+
now
(
)
;
await
lazy
.
TelemetryHealthPing
.
shutdown
(
)
;
this
.
_shutdownStep
=
"
TelemetrySession
"
+
now
(
)
;
await
lazy
.
TelemetrySession
.
shutdown
(
)
;
this
.
_shutdownStep
=
"
Services
.
telemetry
"
+
now
(
)
;
await
Services
.
telemetry
.
shutdown
(
)
;
this
.
_shutdownStep
=
"
await
shutdown
barrier
"
+
now
(
)
;
await
this
.
_shutdownBarrier
.
wait
(
)
;
this
.
_shutdownStep
=
"
await
connections
barrier
"
+
now
(
)
;
await
this
.
_connectionsBarrier
.
wait
(
)
;
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
this
.
_shutdownStep
=
"
Flush
pingsender
batch
"
+
now
(
)
;
lazy
.
TelemetrySend
.
flushPingSenderBatch
(
)
;
}
this
.
_shutdownStep
=
"
await
TelemetryStorage
"
+
now
(
)
;
await
lazy
.
TelemetryStorage
.
shutdown
(
)
;
}
finally
{
this
.
_initialized
=
false
;
this
.
_initStarted
=
false
;
this
.
_shutDown
=
true
;
}
}
shutdown
(
)
{
this
.
_log
.
trace
(
"
shutdown
"
)
;
this
.
_shuttingDown
=
true
;
if
(
!
this
.
_initStarted
)
{
this
.
_shutDown
=
true
;
return
Promise
.
resolve
(
)
;
}
if
(
!
this
.
_delayedInitTask
)
{
return
this
.
_cleanupOnShutdown
(
)
;
}
return
this
.
_delayedInitTask
.
finalize
(
)
.
then
(
(
)
=
>
this
.
_cleanupOnShutdown
(
)
)
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
profile
-
after
-
change
"
)
{
TelemetryControllerBase
.
configureLogging
(
)
;
}
this
.
_log
.
trace
(
observe
-
{
aTopic
}
notified
.
)
;
switch
(
aTopic
)
{
case
"
profile
-
after
-
change
"
:
return
this
.
setupTelemetry
(
)
;
case
"
nsPref
:
changed
"
:
if
(
aData
=
=
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
)
{
return
this
.
_onUploadPrefChange
(
)
;
}
}
return
undefined
;
}
registerSyncPingShutdown
(
fnShutdown
)
{
if
(
this
.
_fnSyncPingShutdown
)
{
throw
new
Error
(
"
The
sync
ping
shutdown
handler
is
already
registered
.
"
)
;
}
this
.
_fnSyncPingShutdown
=
fnShutdown
;
}
_getState
(
)
{
return
{
initialized
:
this
.
_initialized
initStarted
:
this
.
_initStarted
haveDelayedInitTask
:
!
!
this
.
_delayedInitTask
shutdownBarrier
:
this
.
_shutdownBarrier
.
state
connectionsBarrier
:
this
.
_connectionsBarrier
.
state
sendModule
:
lazy
.
TelemetrySend
.
getShutdownState
(
)
haveDelayedNewProfileTask
:
!
!
this
.
_delayedNewPingTask
shutdownStep
:
this
.
_shutdownStep
}
;
}
_onUploadPrefChange
(
)
{
const
uploadEnabled
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
if
(
uploadEnabled
)
{
this
.
_log
.
trace
(
"
_onUploadPrefChange
-
upload
was
enabled
again
.
Resetting
client
ID
"
)
;
this
.
_clientID
=
null
;
let
p
=
(
async
(
)
=
>
{
await
lazy
.
ClientID
.
removeClientID
(
)
;
let
id
=
await
lazy
.
ClientID
.
getClientID
(
)
;
this
.
_clientID
=
id
;
Services
.
telemetry
.
scalarSet
(
"
telemetry
.
data_upload_optin
"
true
)
;
await
this
.
saveUninstallPing
(
)
.
catch
(
e
=
>
this
.
_log
.
warn
(
"
_onUploadPrefChange
-
saveUninstallPing
failed
"
e
)
)
;
}
)
(
)
;
this
.
_shutdownBarrier
.
client
.
addBlocker
(
"
TelemetryController
:
resetting
client
ID
after
data
upload
was
enabled
"
p
)
;
return
;
}
let
p
=
(
async
(
)
=
>
{
try
{
await
lazy
.
TelemetrySend
.
clearCurrentPings
(
)
;
await
lazy
.
TelemetryStorage
.
removeAppDataPings
(
)
;
await
lazy
.
TelemetryStorage
.
runRemovePendingPingsTask
(
)
;
await
lazy
.
TelemetryStorage
.
removeUninstallPings
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
_onUploadPrefChange
-
error
clearing
pending
pings
"
e
)
;
}
finally
{
lazy
.
TelemetrySession
.
resetSubsessionCounter
(
)
;
const
scalars
=
Services
.
telemetry
.
getSnapshotForScalars
(
"
deletion
-
request
"
true
)
;
let
oldClientId
=
await
lazy
.
ClientID
.
getClientID
(
)
;
await
lazy
.
ClientID
.
setCanaryClientID
(
)
;
this
.
_clientID
=
await
lazy
.
ClientID
.
getClientID
(
)
;
this
.
_log
.
trace
(
"
_onUploadPrefChange
-
Sending
deletion
-
request
ping
.
"
)
;
this
.
submitExternalPing
(
PING_TYPE_DELETION_REQUEST
{
scalars
}
{
overrideClientId
:
oldClientId
}
)
;
this
.
_deletionRequestPingSubmittedPromise
=
null
;
}
}
)
(
)
;
this
.
_deletionRequestPingSubmittedPromise
=
p
;
this
.
_shutdownBarrier
.
client
.
addBlocker
(
"
TelemetryController
:
removing
pending
pings
after
data
upload
was
disabled
"
p
)
;
Services
.
obs
.
notifyObservers
(
null
TelemetryUtils
.
TELEMETRY_UPLOAD_DISABLED_TOPIC
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsISupportsWeakReference
"
]
)
_attachObservers
(
)
{
if
(
TelemetryControllerBase
.
IS_UNIFIED_TELEMETRY
)
{
Services
.
prefs
.
addObserver
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
this
true
)
;
}
}
_detachObservers
(
)
{
if
(
TelemetryControllerBase
.
IS_UNIFIED_TELEMETRY
)
{
Services
.
prefs
.
removeObserver
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
this
)
;
}
}
promiseInitialized
(
)
{
return
this
.
_delayedInitTaskDeferred
.
promise
;
}
getCurrentPingData
(
aSubsession
)
{
this
.
_log
.
trace
(
"
getCurrentPingData
-
subsession
:
"
+
aSubsession
)
;
if
(
!
Services
.
telemetry
.
canRecordBase
)
{
return
null
;
}
const
reason
=
aSubsession
?
REASON_GATHER_SUBSESSION_PAYLOAD
:
REASON_GATHER_PAYLOAD
;
const
type
=
PING_TYPE_MAIN
;
const
payload
=
lazy
.
TelemetrySession
.
getPayload
(
reason
)
;
const
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
const
ping
=
this
.
assemblePing
(
type
payload
options
)
;
return
ping
;
}
async
reset
(
)
{
this
.
_clientID
=
null
;
this
.
_fnSyncPingShutdown
=
null
;
this
.
_detachObservers
(
)
;
let
sessionReset
=
lazy
.
TelemetrySession
.
testReset
(
)
;
this
.
_connectionsBarrier
=
new
AsyncShutdown
.
Barrier
(
"
TelemetryController
:
Waiting
for
pending
ping
activity
"
)
;
this
.
_shutdownBarrier
=
new
AsyncShutdown
.
Barrier
(
"
TelemetryController
:
Waiting
for
clients
.
"
)
;
let
controllerSetup
=
this
.
setupTelemetry
(
true
)
;
await
sessionReset
;
await
lazy
.
TelemetrySend
.
reset
(
)
;
await
lazy
.
TelemetryStorage
.
reset
(
)
;
await
lazy
.
TelemetryEnvironment
.
testReset
(
)
;
await
controllerSetup
;
}
scheduleNewProfilePing
(
)
{
this
.
_log
.
trace
(
"
scheduleNewProfilePing
"
)
;
const
sendDelay
=
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
NewProfilePingDelay
NEWPROFILE_PING_DEFAULT_DELAY
)
;
this
.
_delayedNewPingTask
=
new
DeferredTask
(
async
(
)
=
>
{
try
{
await
this
.
sendNewProfilePing
(
)
;
}
finally
{
this
.
_delayedNewPingTask
=
null
;
}
}
sendDelay
)
;
this
.
_delayedNewPingTask
.
arm
(
)
;
}
async
sendNewProfilePing
(
)
{
this
.
_log
.
trace
(
"
sendNewProfilePing
-
shutting
down
:
"
+
this
.
_shuttingDown
)
;
const
scalars
=
Services
.
telemetry
.
getSnapshotForScalars
(
"
new
-
profile
"
true
)
;
const
payload
=
{
reason
:
this
.
_shuttingDown
?
"
shutdown
"
:
"
startup
"
processes
:
{
parent
:
{
scalars
:
scalars
.
parent
}
}
}
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
usePingSender
:
this
.
_shuttingDown
}
;
await
TelemetryController
.
submitExternalPing
(
"
new
-
profile
"
payload
options
)
.
then
(
(
)
=
>
lazy
.
TelemetrySession
.
markNewProfilePingSent
(
)
e
=
>
this
.
_log
.
error
(
"
sendNewProfilePing
-
failed
to
submit
new
-
profile
ping
"
e
)
)
;
}
async
registerJsProbes
(
)
{
if
(
AppConstants
.
MOZILLA_OFFICIAL
&
&
!
this
.
_testMode
)
{
return
;
}
this
.
_log
.
trace
(
"
registerJsProbes
-
registering
builtin
JS
probes
"
)
;
await
this
.
registerScalarProbes
(
)
;
await
this
.
registerEventProbes
(
)
;
}
_loadProbeDefinitions
(
filename
)
{
let
probeFile
=
Services
.
dirsvc
.
get
(
"
GreD
"
Ci
.
nsIFile
)
;
probeFile
.
append
(
filename
)
;
if
(
!
probeFile
.
exists
(
)
)
{
this
.
_log
.
trace
(
loadProbeDefinitions
-
no
builtin
JS
probe
file
{
filename
}
)
;
return
null
;
}
return
IOUtils
.
readUTF8
(
probeFile
.
path
)
;
}
async
registerScalarProbes
(
)
{
this
.
_log
.
trace
(
"
registerScalarProbes
-
registering
scalar
builtin
JS
probes
"
)
;
const
scalarProbeFilename
=
"
ScalarArtifactDefinitions
.
json
"
;
let
scalarJSProbes
=
{
}
;
try
{
let
fileContent
=
await
this
.
_loadProbeDefinitions
(
scalarProbeFilename
)
;
scalarJSProbes
=
JSON
.
parse
(
fileContent
(
property
value
)
=
>
{
if
(
property
!
=
=
"
kind
"
|
|
typeof
value
!
=
"
string
"
)
{
return
value
;
}
let
newValue
;
switch
(
value
)
{
case
"
nsITelemetry
:
:
SCALAR_TYPE_COUNT
"
:
newValue
=
Services
.
telemetry
.
SCALAR_TYPE_COUNT
;
break
;
case
"
nsITelemetry
:
:
SCALAR_TYPE_BOOLEAN
"
:
newValue
=
Services
.
telemetry
.
SCALAR_TYPE_BOOLEAN
;
break
;
case
"
nsITelemetry
:
:
SCALAR_TYPE_STRING
"
:
newValue
=
Services
.
telemetry
.
SCALAR_TYPE_STRING
;
break
;
}
return
newValue
;
}
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
registerScalarProbes
-
there
was
an
error
loading
{
scalarProbeFilename
}
ex
)
;
}
for
(
let
category
in
scalarJSProbes
)
{
for
(
let
name
in
scalarJSProbes
[
category
]
)
{
let
def
=
scalarJSProbes
[
category
]
[
name
]
;
if
(
!
def
|
|
!
def
.
expires
|
|
def
.
expires
=
=
"
never
"
|
|
def
.
expires
=
=
"
default
"
)
{
continue
;
}
if
(
Services
.
vc
.
compare
(
AppConstants
.
MOZ_APP_VERSION
def
.
expires
)
>
=
0
)
{
def
.
expired
=
true
;
}
}
Services
.
telemetry
.
registerBuiltinScalars
(
category
scalarJSProbes
[
category
]
)
;
}
}
async
registerEventProbes
(
)
{
this
.
_log
.
trace
(
"
registerEventProbes
-
registering
builtin
JS
Event
probes
"
)
;
const
eventProbeFilename
=
"
EventArtifactDefinitions
.
json
"
;
let
eventJSProbes
=
{
}
;
try
{
let
fileContent
=
await
this
.
_loadProbeDefinitions
(
eventProbeFilename
)
;
eventJSProbes
=
JSON
.
parse
(
fileContent
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
registerEventProbes
-
there
was
an
error
loading
{
eventProbeFilename
}
ex
)
;
}
for
(
let
category
in
eventJSProbes
)
{
for
(
let
name
in
eventJSProbes
[
category
]
)
{
let
def
=
eventJSProbes
[
category
]
[
name
]
;
if
(
!
def
|
|
!
def
.
expires
|
|
def
.
expires
=
=
"
never
"
|
|
def
.
expires
=
=
"
default
"
)
{
continue
;
}
if
(
Services
.
vc
.
compare
(
AppConstants
.
MOZ_APP_VERSION
def
.
expires
)
>
=
0
)
{
def
.
expired
=
true
;
}
}
Services
.
telemetry
.
registerBuiltinEvents
(
category
eventJSProbes
[
category
]
)
;
}
}
}
;
