"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
TelemetryEnvironment
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
const
myScope
=
this
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
Utils
=
TelemetryUtils
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AttributionCode
"
"
resource
:
/
/
/
modules
/
AttributionCode
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ctypes
"
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LightweightThemeManager
"
"
resource
:
/
/
gre
/
modules
/
LightweightThemeManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ProfileAge
"
"
resource
:
/
/
gre
/
modules
/
ProfileAge
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
WindowsRegistry
"
"
resource
:
/
/
gre
/
modules
/
WindowsRegistry
.
jsm
"
)
;
const
MAX_ADDON_STRING_LENGTH
=
100
;
const
MAX_ATTRIBUTION_STRING_LENGTH
=
100
;
const
MAX_EXPERIMENT_ID_LENGTH
=
100
;
const
MAX_EXPERIMENT_BRANCH_LENGTH
=
100
;
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
}
;
var
gGlobalEnvironment
;
function
getGlobal
(
)
{
if
(
!
gGlobalEnvironment
)
{
gGlobalEnvironment
=
new
EnvironmentCache
(
)
;
}
return
gGlobalEnvironment
;
}
this
.
TelemetryEnvironment
=
{
get
currentEnvironment
(
)
{
return
getGlobal
(
)
.
currentEnvironment
;
}
onInitialized
(
)
{
return
getGlobal
(
)
.
onInitialized
(
)
;
}
delayedInit
(
)
{
return
getGlobal
(
)
.
delayedInit
(
)
;
}
registerChangeListener
(
name
listener
)
{
return
getGlobal
(
)
.
registerChangeListener
(
name
listener
)
;
}
unregisterChangeListener
(
name
)
{
return
getGlobal
(
)
.
unregisterChangeListener
(
name
)
;
}
setExperimentActive
(
id
branch
)
{
return
getGlobal
(
)
.
setExperimentActive
(
id
branch
)
;
}
setExperimentInactive
(
id
)
{
return
getGlobal
(
)
.
setExperimentInactive
(
id
)
;
}
getActiveExperiments
(
)
{
return
getGlobal
(
)
.
getActiveExperiments
(
)
;
}
shutdown
(
)
{
return
getGlobal
(
)
.
shutdown
(
)
;
}
RECORD_PREF_STATE
:
1
RECORD_PREF_VALUE
:
2
RECORD_DEFAULTPREF_VALUE
:
3
testWatchPreferences
(
prefMap
)
{
return
getGlobal
(
)
.
_watchPreferences
(
prefMap
)
;
}
testReset
(
)
{
return
getGlobal
(
)
.
reset
(
)
;
}
testCleanRestart
(
)
{
getGlobal
(
)
.
shutdown
(
)
;
gGlobalEnvironment
=
null
;
return
getGlobal
(
)
;
}
}
;
const
RECORD_PREF_STATE
=
TelemetryEnvironment
.
RECORD_PREF_STATE
;
const
RECORD_PREF_VALUE
=
TelemetryEnvironment
.
RECORD_PREF_VALUE
;
const
RECORD_DEFAULTPREF_VALUE
=
TelemetryEnvironment
.
RECORD_DEFAULTPREF_VALUE
;
const
DEFAULT_ENVIRONMENT_PREFS
=
new
Map
(
[
[
"
app
.
feedback
.
baseURL
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
support
.
baseURL
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
accessibility
.
browsewithcaret
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
accessibility
.
force_disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
auto
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
interval
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
service
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
silent
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
url
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
cache
.
disk
.
enable
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
cache
.
disk
.
capacity
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
cache
.
memory
.
enable
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
cache
.
offline
.
enable
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
formfill
.
enable
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
newtabpage
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
newtabpage
.
enhanced
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
shell
.
checkDefaultBrowser
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
search
.
ignoredJAREngines
"
{
what
:
RECORD_DEFAULTPREF_VALUE
}
]
[
"
browser
.
search
.
suggest
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
startup
.
homepage
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
browser
.
startup
.
page
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
toolkit
.
cosmeticAnimations
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
urlbar
.
suggest
.
searches
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
urlbar
.
userMadeSearchSuggestionsChoice
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
devtools
.
chrome
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
devtools
.
debugger
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
devtools
.
debugger
.
remote
-
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
dom
.
ipc
.
plugins
.
asyncInit
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
dom
.
ipc
.
plugins
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
dom
.
ipc
.
processCount
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
dom
.
max_script_run_time
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
experiments
.
manifest
.
uri
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
autoDisableScopes
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
enabledScopes
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
blocklist
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
blocklist
.
url
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
strictCompatibility
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
update
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
update
.
url
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
update
.
background
.
url
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
screenshots
.
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
screenshots
.
system
-
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
general
.
smoothScroll
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
gfx
.
direct2d
.
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
gfx
.
direct2d
.
force
-
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
gfx
.
direct2d
.
use1_1
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
acceleration
.
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
acceleration
.
force
-
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
async
-
pan
-
zoom
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
async
-
video
-
oop
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
async
-
video
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
componentalpha
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
d3d11
.
disable
-
warp
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
d3d11
.
force
-
warp
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
offmainthreadcomposition
.
force
-
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
prefer
-
d3d9
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
prefer
-
opengl
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layout
.
css
.
devPixelsPerPx
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
network
.
proxy
.
autoconfig_url
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
network
.
proxy
.
http
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
network
.
proxy
.
ssl
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
pdfjs
.
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
places
.
history
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
privacy
.
trackingprotection
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
privacy
.
donottrackheader
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
security
.
mixed_content
.
block_active_content
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
security
.
mixed_content
.
block_display_content
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
security
.
sandbox
.
content
.
level
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
xpinstall
.
signatures
.
required
"
{
what
:
RECORD_PREF_VALUE
}
]
]
)
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
PREF_BLOCKLIST_ENABLED
=
"
extensions
.
blocklist
.
enabled
"
;
const
PREF_DISTRIBUTION_ID
=
"
distribution
.
id
"
;
const
PREF_DISTRIBUTION_VERSION
=
"
distribution
.
version
"
;
const
PREF_DISTRIBUTOR
=
"
app
.
distributor
"
;
const
PREF_DISTRIBUTOR_CHANNEL
=
"
app
.
distributor
.
channel
"
;
const
PREF_HOTFIX_LASTVERSION
=
"
extensions
.
hotfix
.
lastVersion
"
;
const
PREF_APP_PARTNER_BRANCH
=
"
app
.
partner
.
"
;
const
PREF_PARTNER_ID
=
"
mozilla
.
partner
.
id
"
;
const
PREF_UPDATE_ENABLED
=
"
app
.
update
.
enabled
"
;
const
PREF_UPDATE_AUTODOWNLOAD
=
"
app
.
update
.
auto
"
;
const
PREF_SEARCH_COHORT
=
"
browser
.
search
.
cohort
"
;
const
PREF_E10S_COHORT
=
"
e10s
.
rollout
.
cohort
"
;
const
COMPOSITOR_CREATED_TOPIC
=
"
compositor
:
created
"
;
const
COMPOSITOR_PROCESS_ABORTED_TOPIC
=
"
compositor
:
process
-
aborted
"
;
const
DISTRIBUTION_CUSTOMIZATION_COMPLETE_TOPIC
=
"
distribution
-
customization
-
complete
"
;
const
EXPERIMENTS_CHANGED_TOPIC
=
"
experiments
-
changed
"
;
const
GFX_FEATURES_READY_TOPIC
=
"
gfx
-
features
-
ready
"
;
const
SEARCH_ENGINE_MODIFIED_TOPIC
=
"
browser
-
search
-
engine
-
modified
"
;
const
SEARCH_SERVICE_TOPIC
=
"
browser
-
search
-
service
"
;
function
enforceBoolean
(
aValue
)
{
if
(
typeof
(
aValue
)
!
=
=
"
number
"
&
&
typeof
(
aValue
)
!
=
=
"
boolean
"
)
{
return
null
;
}
return
(
new
Boolean
(
aValue
)
)
.
valueOf
(
)
;
}
function
getBrowserLocale
(
)
{
try
{
return
Services
.
locale
.
getAppLocaleAsLangTag
(
)
;
}
catch
(
e
)
{
return
null
;
}
}
function
getSystemLocale
(
)
{
try
{
return
Cc
[
"
mozilla
.
org
/
intl
/
ospreferences
;
1
"
]
.
getService
(
Ci
.
mozIOSPreferences
)
.
systemLocale
;
}
catch
(
e
)
{
return
null
;
}
}
function
getSysinfoProperty
(
aPropertyName
aDefault
)
{
try
{
return
Services
.
sysinfo
.
getProperty
(
aPropertyName
)
;
}
catch
(
e
)
{
}
return
aDefault
;
}
function
getGfxField
(
aPropertyName
aDefault
)
{
let
gfxInfo
=
Cc
[
"
mozilla
.
org
/
gfx
/
info
;
1
"
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
try
{
let
gfxProp
=
gfxInfo
[
aPropertyName
]
;
if
(
gfxProp
!
=
=
undefined
&
&
gfxProp
!
=
=
"
"
)
{
return
gfxProp
;
}
}
catch
(
e
)
{
}
return
aDefault
;
}
function
limitStringToLength
(
aString
aMaxLength
)
{
if
(
typeof
(
aString
)
!
=
=
"
string
"
)
{
return
null
;
}
return
aString
.
substring
(
0
aMaxLength
)
;
}
function
forceToStringOrNull
(
aValue
)
{
if
(
aValue
=
=
=
null
)
{
return
null
;
}
return
String
(
aValue
)
;
}
function
getGfxAdapter
(
aSuffix
=
"
"
)
{
let
memoryMB
=
parseInt
(
getGfxField
(
"
adapterRAM
"
+
aSuffix
null
)
10
)
;
if
(
Number
.
isNaN
(
memoryMB
)
)
{
memoryMB
=
null
;
}
return
{
description
:
getGfxField
(
"
adapterDescription
"
+
aSuffix
null
)
vendorID
:
getGfxField
(
"
adapterVendorID
"
+
aSuffix
null
)
deviceID
:
getGfxField
(
"
adapterDeviceID
"
+
aSuffix
null
)
subsysID
:
getGfxField
(
"
adapterSubsysID
"
+
aSuffix
null
)
RAM
:
memoryMB
driver
:
getGfxField
(
"
adapterDriver
"
+
aSuffix
null
)
driverVersion
:
getGfxField
(
"
adapterDriverVersion
"
+
aSuffix
null
)
driverDate
:
getGfxField
(
"
adapterDriverDate
"
+
aSuffix
null
)
}
;
}
function
getWindowsVersionInfo
(
)
{
const
UNKNOWN_VERSION_INFO
=
{
servicePackMajor
:
null
servicePackMinor
:
null
buildNumber
:
null
}
;
if
(
AppConstants
.
platform
!
=
=
"
win
"
)
{
return
UNKNOWN_VERSION_INFO
;
}
const
BYTE
=
ctypes
.
uint8_t
;
const
WORD
=
ctypes
.
uint16_t
;
const
DWORD
=
ctypes
.
uint32_t
;
const
WCHAR
=
ctypes
.
char16_t
;
const
BOOL
=
ctypes
.
int
;
const
SZCSDVERSIONLENGTH
=
128
;
const
OSVERSIONINFOEXW
=
new
ctypes
.
StructType
(
"
OSVERSIONINFOEXW
"
[
{
dwOSVersionInfoSize
:
DWORD
}
{
dwMajorVersion
:
DWORD
}
{
dwMinorVersion
:
DWORD
}
{
dwBuildNumber
:
DWORD
}
{
dwPlatformId
:
DWORD
}
{
szCSDVersion
:
ctypes
.
ArrayType
(
WCHAR
SZCSDVERSIONLENGTH
)
}
{
wServicePackMajor
:
WORD
}
{
wServicePackMinor
:
WORD
}
{
wSuiteMask
:
WORD
}
{
wProductType
:
BYTE
}
{
wReserved
:
BYTE
}
]
)
;
let
kernel32
=
ctypes
.
open
(
"
kernel32
"
)
;
try
{
let
GetVersionEx
=
kernel32
.
declare
(
"
GetVersionExW
"
ctypes
.
default_abi
BOOL
OSVERSIONINFOEXW
.
ptr
)
;
let
winVer
=
OSVERSIONINFOEXW
(
)
;
winVer
.
dwOSVersionInfoSize
=
OSVERSIONINFOEXW
.
size
;
if
(
0
=
=
=
GetVersionEx
(
winVer
.
address
(
)
)
)
{
throw
(
"
Failure
in
GetVersionEx
(
returned
0
)
"
)
;
}
return
{
servicePackMajor
:
winVer
.
wServicePackMajor
servicePackMinor
:
winVer
.
wServicePackMinor
buildNumber
:
winVer
.
dwBuildNumber
}
;
}
catch
(
e
)
{
return
UNKNOWN_VERSION_INFO
;
}
finally
{
kernel32
.
close
(
)
;
}
}
function
EnvironmentAddonBuilder
(
environment
)
{
this
.
_environment
=
environment
;
this
.
_pendingTask
=
null
;
this
.
_loaded
=
false
;
}
EnvironmentAddonBuilder
.
prototype
=
{
init
(
)
{
try
{
AddonManager
.
shutdown
.
addBlocker
(
"
EnvironmentAddonBuilder
"
(
)
=
>
this
.
_shutdownBlocker
(
)
)
;
}
catch
(
err
)
{
return
Promise
.
reject
(
err
)
;
}
this
.
_pendingTask
=
this
.
_updateAddons
(
)
.
then
(
(
)
=
>
{
this
.
_pendingTask
=
null
;
}
(
err
)
=
>
{
this
.
_environment
.
_log
.
error
(
"
init
-
Exception
in
_updateAddons
"
err
)
;
this
.
_pendingTask
=
null
;
}
)
;
return
this
.
_pendingTask
;
}
watchForChanges
(
)
{
this
.
_loaded
=
true
;
AddonManager
.
addAddonListener
(
this
)
;
Services
.
obs
.
addObserver
(
this
EXPERIMENTS_CHANGED_TOPIC
)
;
}
onEnabled
(
)
{
this
.
_onAddonChange
(
)
;
}
onDisabled
(
)
{
this
.
_onAddonChange
(
)
;
}
onInstalled
(
)
{
this
.
_onAddonChange
(
)
;
}
onUninstalling
(
)
{
this
.
_onAddonChange
(
)
;
}
_onAddonChange
(
)
{
this
.
_environment
.
_log
.
trace
(
"
_onAddonChange
"
)
;
this
.
_checkForChanges
(
"
addons
-
changed
"
)
;
}
observe
(
aSubject
aTopic
aData
)
{
this
.
_environment
.
_log
.
trace
(
"
observe
-
Topic
"
+
aTopic
)
;
this
.
_checkForChanges
(
"
experiment
-
changed
"
)
;
}
_checkForChanges
(
changeReason
)
{
if
(
this
.
_pendingTask
)
{
this
.
_environment
.
_log
.
trace
(
"
_checkForChanges
-
task
already
pending
dropping
change
with
reason
"
+
changeReason
)
;
return
;
}
this
.
_pendingTask
=
this
.
_updateAddons
(
)
.
then
(
(
result
)
=
>
{
this
.
_pendingTask
=
null
;
if
(
result
.
changed
)
{
this
.
_environment
.
_onEnvironmentChange
(
changeReason
result
.
oldEnvironment
)
;
}
}
(
err
)
=
>
{
this
.
_pendingTask
=
null
;
this
.
_environment
.
_log
.
error
(
"
_checkForChanges
:
Error
collecting
addons
"
err
)
;
}
)
;
}
_shutdownBlocker
(
)
{
if
(
this
.
_loaded
)
{
AddonManager
.
removeAddonListener
(
this
)
;
Services
.
obs
.
removeObserver
(
this
EXPERIMENTS_CHANGED_TOPIC
)
;
}
return
this
.
_pendingTask
;
}
async
_updateAddons
(
)
{
this
.
_environment
.
_log
.
trace
(
"
_updateAddons
"
)
;
let
personaId
=
null
;
let
theme
=
LightweightThemeManager
.
currentTheme
;
if
(
theme
)
{
personaId
=
theme
.
id
;
}
let
addons
=
{
activeAddons
:
await
this
.
_getActiveAddons
(
)
theme
:
await
this
.
_getActiveTheme
(
)
activePlugins
:
this
.
_getActivePlugins
(
)
activeGMPlugins
:
await
this
.
_getActiveGMPlugins
(
)
activeExperiment
:
this
.
_getActiveExperiment
(
)
persona
:
personaId
}
;
let
result
=
{
changed
:
!
this
.
_environment
.
_currentEnvironment
.
addons
|
|
!
ObjectUtils
.
deepEqual
(
addons
this
.
_environment
.
_currentEnvironment
.
addons
)
}
;
if
(
result
.
changed
)
{
this
.
_environment
.
_log
.
trace
(
"
_updateAddons
:
addons
differ
"
)
;
result
.
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_environment
.
_currentEnvironment
myScope
)
;
this
.
_environment
.
_currentEnvironment
.
addons
=
addons
;
}
return
result
;
}
async
_getActiveAddons
(
)
{
let
allAddons
=
await
AddonManager
.
getAddonsByTypes
(
[
"
extension
"
"
service
"
]
)
;
let
activeAddons
=
{
}
;
for
(
let
addon
of
allAddons
)
{
if
(
!
addon
.
isActive
)
{
continue
;
}
try
{
let
installDate
=
new
Date
(
Math
.
max
(
0
addon
.
installDate
)
)
;
let
updateDate
=
new
Date
(
Math
.
max
(
0
addon
.
updateDate
)
)
;
activeAddons
[
addon
.
id
]
=
{
blocklisted
:
(
addon
.
blocklistState
!
=
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
description
:
limitStringToLength
(
addon
.
description
MAX_ADDON_STRING_LENGTH
)
name
:
limitStringToLength
(
addon
.
name
MAX_ADDON_STRING_LENGTH
)
userDisabled
:
enforceBoolean
(
addon
.
userDisabled
)
appDisabled
:
addon
.
appDisabled
version
:
limitStringToLength
(
addon
.
version
MAX_ADDON_STRING_LENGTH
)
scope
:
addon
.
scope
type
:
addon
.
type
foreignInstall
:
enforceBoolean
(
addon
.
foreignInstall
)
hasBinaryComponents
:
addon
.
hasBinaryComponents
installDay
:
Utils
.
millisecondsToDays
(
installDate
.
getTime
(
)
)
updateDay
:
Utils
.
millisecondsToDays
(
updateDate
.
getTime
(
)
)
signedState
:
addon
.
signedState
isSystem
:
addon
.
isSystem
isWebExtension
:
addon
.
isWebExtension
}
;
if
(
addon
.
signedState
!
=
=
undefined
)
activeAddons
[
addon
.
id
]
.
signedState
=
addon
.
signedState
;
}
catch
(
ex
)
{
this
.
_environment
.
_log
.
error
(
"
_getActiveAddons
-
An
addon
was
discarded
due
to
an
error
"
ex
)
;
continue
;
}
}
return
activeAddons
;
}
async
_getActiveTheme
(
)
{
let
themes
=
await
AddonManager
.
getAddonsByTypes
(
[
"
theme
"
]
)
;
let
activeTheme
=
{
}
;
let
theme
=
themes
.
find
(
theme
=
>
theme
.
isActive
)
;
if
(
theme
)
{
let
installDate
=
new
Date
(
Math
.
max
(
0
theme
.
installDate
)
)
;
let
updateDate
=
new
Date
(
Math
.
max
(
0
theme
.
updateDate
)
)
;
activeTheme
=
{
id
:
theme
.
id
blocklisted
:
(
theme
.
blocklistState
!
=
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
description
:
limitStringToLength
(
theme
.
description
MAX_ADDON_STRING_LENGTH
)
name
:
limitStringToLength
(
theme
.
name
MAX_ADDON_STRING_LENGTH
)
userDisabled
:
enforceBoolean
(
theme
.
userDisabled
)
appDisabled
:
theme
.
appDisabled
version
:
limitStringToLength
(
theme
.
version
MAX_ADDON_STRING_LENGTH
)
scope
:
theme
.
scope
foreignInstall
:
enforceBoolean
(
theme
.
foreignInstall
)
hasBinaryComponents
:
theme
.
hasBinaryComponents
installDay
:
Utils
.
millisecondsToDays
(
installDate
.
getTime
(
)
)
updateDay
:
Utils
.
millisecondsToDays
(
updateDate
.
getTime
(
)
)
}
;
}
return
activeTheme
;
}
_getActivePlugins
(
)
{
let
pluginTags
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
.
getPluginTags
(
{
}
)
;
let
activePlugins
=
[
]
;
for
(
let
tag
of
pluginTags
)
{
if
(
tag
.
disabled
)
{
continue
;
}
try
{
let
updateDate
=
new
Date
(
Math
.
max
(
0
tag
.
lastModifiedTime
)
)
;
activePlugins
.
push
(
{
name
:
limitStringToLength
(
tag
.
name
MAX_ADDON_STRING_LENGTH
)
version
:
limitStringToLength
(
tag
.
version
MAX_ADDON_STRING_LENGTH
)
description
:
limitStringToLength
(
tag
.
description
MAX_ADDON_STRING_LENGTH
)
blocklisted
:
tag
.
blocklisted
disabled
:
tag
.
disabled
clicktoplay
:
tag
.
clicktoplay
mimeTypes
:
tag
.
getMimeTypes
(
{
}
)
updateDay
:
Utils
.
millisecondsToDays
(
updateDate
.
getTime
(
)
)
}
)
;
}
catch
(
ex
)
{
this
.
_environment
.
_log
.
error
(
"
_getActivePlugins
-
A
plugin
was
discarded
due
to
an
error
"
ex
)
;
continue
;
}
}
return
activePlugins
;
}
async
_getActiveGMPlugins
(
)
{
let
allPlugins
=
await
AddonManager
.
getAddonsByTypes
(
[
"
plugin
"
]
)
;
let
activeGMPlugins
=
{
}
;
for
(
let
plugin
of
allPlugins
)
{
if
(
!
plugin
.
isGMPlugin
|
|
!
plugin
.
isActive
)
{
continue
;
}
try
{
activeGMPlugins
[
plugin
.
id
]
=
{
version
:
plugin
.
version
userDisabled
:
enforceBoolean
(
plugin
.
userDisabled
)
applyBackgroundUpdates
:
plugin
.
applyBackgroundUpdates
}
;
}
catch
(
ex
)
{
this
.
_environment
.
_log
.
error
(
"
_getActiveGMPlugins
-
A
GMPlugin
was
discarded
due
to
an
error
"
ex
)
;
continue
;
}
}
return
activeGMPlugins
;
}
_getActiveExperiment
(
)
{
let
experimentInfo
=
{
}
;
try
{
let
scope
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
experiments
/
Experiments
.
jsm
"
scope
)
;
let
experiments
=
scope
.
Experiments
.
instance
(
)
;
let
activeExperiment
=
experiments
.
getActiveExperimentID
(
)
;
if
(
activeExperiment
)
{
experimentInfo
.
id
=
activeExperiment
;
experimentInfo
.
branch
=
experiments
.
getActiveExperimentBranch
(
)
;
}
}
catch
(
e
)
{
}
return
experimentInfo
;
}
}
;
function
EnvironmentCache
(
)
{
this
.
_log
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
"
TelemetryEnvironment
:
:
"
)
;
this
.
_log
.
trace
(
"
constructor
"
)
;
this
.
_shutdown
=
false
;
this
.
_delayedInitFinished
=
false
;
this
.
_changeListeners
=
new
Map
(
)
;
this
.
_watchedPrefs
=
DEFAULT_ENVIRONMENT_PREFS
;
this
.
_currentEnvironment
=
{
build
:
this
.
_getBuild
(
)
partner
:
this
.
_getPartner
(
)
system
:
this
.
_getSystem
(
)
}
;
this
.
_updateSettings
(
)
;
this
.
_updateSearchEngine
(
)
;
this
.
_addObservers
(
)
;
let
p
=
[
]
;
this
.
_addonBuilder
=
new
EnvironmentAddonBuilder
(
this
)
;
p
=
[
this
.
_addonBuilder
.
init
(
)
]
;
this
.
_currentEnvironment
.
profile
=
{
}
;
p
.
push
(
this
.
_updateProfile
(
)
)
;
if
(
AppConstants
.
MOZ_BUILD_APP
=
=
"
browser
"
)
{
p
.
push
(
this
.
_updateAttribution
(
)
)
;
}
let
setup
=
(
)
=
>
{
this
.
_initTask
=
null
;
this
.
_startWatchingPrefs
(
)
;
this
.
_addonBuilder
.
watchForChanges
(
)
;
this
.
_updateGraphicsFeatures
(
)
;
return
this
.
currentEnvironment
;
}
;
this
.
_initTask
=
Promise
.
all
(
p
)
.
then
(
(
)
=
>
setup
(
)
(
err
)
=
>
{
this
.
_log
.
error
(
"
EnvironmentCache
-
error
while
initializing
"
err
)
;
return
setup
(
)
;
}
)
;
}
EnvironmentCache
.
prototype
=
{
get
currentEnvironment
(
)
{
return
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
}
onInitialized
(
)
{
if
(
this
.
_initTask
)
{
return
this
.
_initTask
;
}
return
Promise
.
resolve
(
this
.
currentEnvironment
)
;
}
delayedInit
(
)
{
this
.
_delayedInitFinished
=
true
;
}
registerChangeListener
(
name
listener
)
{
this
.
_log
.
trace
(
"
registerChangeListener
for
"
+
name
)
;
if
(
this
.
_shutdown
)
{
this
.
_log
.
warn
(
"
registerChangeListener
-
already
shutdown
"
)
;
return
;
}
this
.
_changeListeners
.
set
(
name
listener
)
;
}
unregisterChangeListener
(
name
)
{
this
.
_log
.
trace
(
"
unregisterChangeListener
for
"
+
name
)
;
if
(
this
.
_shutdown
)
{
this
.
_log
.
warn
(
"
registerChangeListener
-
already
shutdown
"
)
;
return
;
}
this
.
_changeListeners
.
delete
(
name
)
;
}
setExperimentActive
(
id
branch
)
{
this
.
_log
.
trace
(
"
setExperimentActive
"
)
;
const
saneId
=
limitStringToLength
(
id
MAX_EXPERIMENT_ID_LENGTH
)
;
const
saneBranch
=
limitStringToLength
(
branch
MAX_EXPERIMENT_BRANCH_LENGTH
)
;
if
(
!
saneId
|
|
!
saneBranch
)
{
this
.
_log
.
error
(
"
setExperimentActive
-
the
provided
arguments
are
not
strings
.
"
)
;
return
;
}
if
(
saneId
.
length
!
=
id
.
length
|
|
saneBranch
.
length
!
=
branch
.
length
)
{
this
.
_log
.
warn
(
"
setExperimentActive
-
the
experiment
id
or
branch
were
truncated
.
"
)
;
}
let
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
let
experiments
=
this
.
_currentEnvironment
.
experiments
|
|
{
}
;
experiments
[
saneId
]
=
{
"
branch
"
:
saneBranch
}
;
this
.
_currentEnvironment
.
experiments
=
experiments
;
this
.
_onEnvironmentChange
(
"
experiment
-
annotation
-
changed
"
oldEnvironment
)
;
}
setExperimentInactive
(
id
)
{
this
.
_log
.
trace
(
"
setExperimentInactive
"
)
;
let
experiments
=
this
.
_currentEnvironment
.
experiments
|
|
{
}
;
if
(
id
in
experiments
)
{
let
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
delete
this
.
_currentEnvironment
.
experiments
[
id
]
;
this
.
_onEnvironmentChange
(
"
experiment
-
annotation
-
changed
"
oldEnvironment
)
;
}
}
getActiveExperiments
(
)
{
return
Cu
.
cloneInto
(
this
.
_currentEnvironment
.
experiments
|
|
{
}
myScope
)
;
}
shutdown
(
)
{
this
.
_log
.
trace
(
"
shutdown
"
)
;
this
.
_shutdown
=
true
;
}
_watchPreferences
(
aPreferences
)
{
this
.
_stopWatchingPrefs
(
)
;
this
.
_watchedPrefs
=
aPreferences
;
this
.
_updateSettings
(
)
;
this
.
_startWatchingPrefs
(
)
;
}
_getPrefData
(
)
{
let
prefData
=
{
}
;
for
(
let
[
pref
policy
]
of
this
.
_watchedPrefs
.
entries
(
)
)
{
if
(
policy
.
what
=
=
TelemetryEnvironment
.
RECORD_DEFAULTPREF_VALUE
)
{
if
(
!
Preferences
.
has
(
pref
)
)
{
continue
;
}
}
else
if
(
!
Preferences
.
isSet
(
pref
)
)
{
continue
;
}
let
prefValue
=
undefined
;
if
(
policy
.
what
=
=
TelemetryEnvironment
.
RECORD_PREF_STATE
)
{
prefValue
=
"
<
user
-
set
>
"
;
}
else
{
prefValue
=
Preferences
.
get
(
pref
null
)
;
}
prefData
[
pref
]
=
prefValue
;
}
return
prefData
;
}
_startWatchingPrefs
(
)
{
this
.
_log
.
trace
(
"
_startWatchingPrefs
-
"
+
this
.
_watchedPrefs
)
;
for
(
let
[
pref
options
]
of
this
.
_watchedPrefs
)
{
if
(
!
(
"
requiresRestart
"
in
options
)
|
|
!
options
.
requiresRestart
)
{
Preferences
.
observe
(
pref
this
.
_onPrefChanged
this
)
;
}
}
}
_onPrefChanged
(
)
{
this
.
_log
.
trace
(
"
_onPrefChanged
"
)
;
let
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
this
.
_updateSettings
(
)
;
this
.
_onEnvironmentChange
(
"
pref
-
changed
"
oldEnvironment
)
;
}
_stopWatchingPrefs
(
)
{
this
.
_log
.
trace
(
"
_stopWatchingPrefs
"
)
;
for
(
let
[
pref
options
]
of
this
.
_watchedPrefs
)
{
if
(
!
(
"
requiresRestart
"
in
options
)
|
|
!
options
.
requiresRestart
)
{
Preferences
.
ignore
(
pref
this
.
_onPrefChanged
this
)
;
}
}
}
_addObservers
(
)
{
Services
.
obs
.
addObserver
(
this
COMPOSITOR_CREATED_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
COMPOSITOR_PROCESS_ABORTED_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
DISTRIBUTION_CUSTOMIZATION_COMPLETE_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
GFX_FEATURES_READY_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
SEARCH_ENGINE_MODIFIED_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
SEARCH_SERVICE_TOPIC
)
;
}
_removeObservers
(
)
{
Services
.
obs
.
removeObserver
(
this
COMPOSITOR_CREATED_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
COMPOSITOR_PROCESS_ABORTED_TOPIC
)
;
try
{
Services
.
obs
.
removeObserver
(
this
DISTRIBUTION_CUSTOMIZATION_COMPLETE_TOPIC
)
;
}
catch
(
ex
)
{
}
Services
.
obs
.
removeObserver
(
this
GFX_FEATURES_READY_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
SEARCH_ENGINE_MODIFIED_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
SEARCH_SERVICE_TOPIC
)
;
}
observe
(
aSubject
aTopic
aData
)
{
this
.
_log
.
trace
(
"
observe
-
aTopic
:
"
+
aTopic
+
"
aData
:
"
+
aData
)
;
switch
(
aTopic
)
{
case
SEARCH_ENGINE_MODIFIED_TOPIC
:
if
(
aData
!
=
"
engine
-
current
"
)
{
return
;
}
this
.
_onSearchEngineChange
(
)
;
break
;
case
SEARCH_SERVICE_TOPIC
:
if
(
aData
!
=
"
init
-
complete
"
)
{
return
;
}
this
.
_updateSearchEngine
(
)
;
break
;
case
GFX_FEATURES_READY_TOPIC
:
case
COMPOSITOR_CREATED_TOPIC
:
this
.
_updateGraphicsFeatures
(
)
;
break
;
case
COMPOSITOR_PROCESS_ABORTED_TOPIC
:
this
.
_onCompositorProcessAborted
(
)
;
break
;
case
DISTRIBUTION_CUSTOMIZATION_COMPLETE_TOPIC
:
this
.
_updatePartner
(
)
;
Services
.
obs
.
removeObserver
(
this
aTopic
)
;
break
;
}
}
_getDefaultSearchEngine
(
)
{
let
engine
;
try
{
engine
=
Services
.
search
.
defaultEngine
;
}
catch
(
e
)
{
}
let
name
;
if
(
!
engine
)
{
name
=
"
NONE
"
;
}
else
if
(
engine
.
identifier
)
{
name
=
engine
.
identifier
;
}
else
if
(
engine
.
name
)
{
name
=
"
other
-
"
+
engine
.
name
;
}
else
{
name
=
"
UNDEFINED
"
;
}
return
name
;
}
_updateSearchEngine
(
)
{
if
(
!
Services
.
search
)
{
return
;
}
this
.
_log
.
trace
(
"
_updateSearchEngine
-
isInitialized
:
"
+
Services
.
search
.
isInitialized
)
;
if
(
!
Services
.
search
.
isInitialized
)
{
return
;
}
this
.
_currentEnvironment
.
settings
=
this
.
_currentEnvironment
.
settings
|
|
{
}
;
this
.
_currentEnvironment
.
settings
.
defaultSearchEngine
=
this
.
_getDefaultSearchEngine
(
)
;
this
.
_currentEnvironment
.
settings
.
defaultSearchEngineData
=
Services
.
search
.
getDefaultEngineInfo
(
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_SEARCH_COHORT
)
)
this
.
_currentEnvironment
.
settings
.
searchCohort
=
Services
.
prefs
.
getCharPref
(
PREF_SEARCH_COHORT
)
;
}
_onSearchEngineChange
(
)
{
this
.
_log
.
trace
(
"
_onSearchEngineChange
"
)
;
let
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
this
.
_updateSearchEngine
(
)
;
this
.
_onEnvironmentChange
(
"
search
-
engine
-
changed
"
oldEnvironment
)
;
}
_onCompositorProcessAborted
(
)
{
this
.
_log
.
trace
(
"
_onCompositorProcessAborted
"
)
;
let
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
this
.
_updateGraphicsFeatures
(
)
;
this
.
_onEnvironmentChange
(
"
gfx
-
features
-
changed
"
oldEnvironment
)
;
}
_updateGraphicsFeatures
(
)
{
let
gfxData
=
this
.
_currentEnvironment
.
system
.
gfx
;
try
{
let
gfxInfo
=
Cc
[
"
mozilla
.
org
/
gfx
/
info
;
1
"
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
gfxData
.
features
=
gfxInfo
.
getFeatures
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
nsIGfxInfo
.
getFeatures
(
)
caught
error
"
e
)
;
}
}
_updatePartner
(
)
{
this
.
_currentEnvironment
.
partner
=
this
.
_getPartner
(
)
;
}
_getBuild
(
)
{
let
buildData
=
{
applicationId
:
Services
.
appinfo
.
ID
|
|
null
applicationName
:
Services
.
appinfo
.
name
|
|
null
architecture
:
Services
.
sysinfo
.
get
(
"
arch
"
)
buildId
:
Services
.
appinfo
.
appBuildID
|
|
null
version
:
Services
.
appinfo
.
version
|
|
null
vendor
:
Services
.
appinfo
.
vendor
|
|
null
platformVersion
:
Services
.
appinfo
.
platformVersion
|
|
null
xpcomAbi
:
Services
.
appinfo
.
XPCOMABI
hotfixVersion
:
Preferences
.
get
(
PREF_HOTFIX_LASTVERSION
null
)
}
;
if
(
"
mozilla
.
org
/
xpcom
/
mac
-
utils
;
1
"
in
Cc
)
{
let
macUtils
=
Cc
[
"
mozilla
.
org
/
xpcom
/
mac
-
utils
;
1
"
]
.
getService
(
Ci
.
nsIMacUtils
)
;
if
(
macUtils
&
&
macUtils
.
isUniversalBinary
)
{
buildData
.
architecturesInBinary
=
macUtils
.
architecturesInBinary
;
}
}
return
buildData
;
}
_isDefaultBrowser
(
)
{
if
(
!
(
"
mozilla
.
org
/
browser
/
shell
-
service
;
1
"
in
Cc
)
)
{
this
.
_log
.
info
(
"
_isDefaultBrowser
-
Could
not
obtain
browser
shell
service
"
)
;
return
null
;
}
let
shellService
;
try
{
let
scope
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
scope
)
;
shellService
=
scope
.
ShellService
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_isDefaultBrowser
-
Could
not
obtain
shell
service
JSM
"
)
;
}
if
(
!
shellService
)
{
try
{
shellService
=
Cc
[
"
mozilla
.
org
/
browser
/
shell
-
service
;
1
"
]
.
getService
(
Ci
.
nsIShellService
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_isDefaultBrowser
-
Could
not
obtain
shell
service
"
ex
)
;
return
null
;
}
}
try
{
return
shellService
.
isDefaultBrowser
(
false
true
)
?
true
:
false
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_isDefaultBrowser
-
Could
not
determine
if
default
browser
"
ex
)
;
return
null
;
}
}
_updateSettings
(
)
{
let
updateChannel
=
null
;
try
{
updateChannel
=
UpdateUtils
.
getUpdateChannel
(
false
)
;
}
catch
(
e
)
{
}
this
.
_currentEnvironment
.
settings
=
{
blocklistEnabled
:
Preferences
.
get
(
PREF_BLOCKLIST_ENABLED
true
)
e10sEnabled
:
Services
.
appinfo
.
browserTabsRemoteAutostart
e10sMultiProcesses
:
Services
.
appinfo
.
maxWebProcessCount
e10sCohort
:
Preferences
.
get
(
PREF_E10S_COHORT
"
unknown
"
)
telemetryEnabled
:
Utils
.
isTelemetryEnabled
locale
:
getBrowserLocale
(
)
update
:
{
channel
:
updateChannel
enabled
:
Preferences
.
get
(
PREF_UPDATE_ENABLED
true
)
autoDownload
:
Preferences
.
get
(
PREF_UPDATE_AUTODOWNLOAD
true
)
}
userPrefs
:
this
.
_getPrefData
(
)
}
;
this
.
_currentEnvironment
.
settings
.
addonCompatibilityCheckEnabled
=
AddonManager
.
checkCompatibility
;
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
this
.
_currentEnvironment
.
settings
.
isDefaultBrowser
=
this
.
_isDefaultBrowser
(
)
;
}
this
.
_updateSearchEngine
(
)
;
}
async
_updateProfile
(
)
{
const
logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
"
ProfileAge
-
"
)
;
let
profileAccessor
=
new
ProfileAge
(
null
logger
)
;
let
creationDate
=
await
profileAccessor
.
created
;
let
resetDate
=
await
profileAccessor
.
reset
;
this
.
_currentEnvironment
.
profile
.
creationDate
=
Utils
.
millisecondsToDays
(
creationDate
)
;
if
(
resetDate
)
{
this
.
_currentEnvironment
.
profile
.
resetDate
=
Utils
.
millisecondsToDays
(
resetDate
)
;
}
}
async
_updateAttribution
(
)
{
let
data
=
await
AttributionCode
.
getAttrDataAsync
(
)
;
if
(
Object
.
keys
(
data
)
.
length
>
0
)
{
this
.
_currentEnvironment
.
settings
.
attribution
=
{
}
;
for
(
let
key
in
data
)
{
this
.
_currentEnvironment
.
settings
.
attribution
[
key
]
=
limitStringToLength
(
data
[
key
]
MAX_ATTRIBUTION_STRING_LENGTH
)
;
}
}
}
_getPartner
(
)
{
let
partnerData
=
{
distributionId
:
Preferences
.
get
(
PREF_DISTRIBUTION_ID
null
)
distributionVersion
:
Preferences
.
get
(
PREF_DISTRIBUTION_VERSION
null
)
partnerId
:
Preferences
.
get
(
PREF_PARTNER_ID
null
)
distributor
:
Preferences
.
get
(
PREF_DISTRIBUTOR
null
)
distributorChannel
:
Preferences
.
get
(
PREF_DISTRIBUTOR_CHANNEL
null
)
}
;
let
partnerBranch
=
Services
.
prefs
.
getBranch
(
PREF_APP_PARTNER_BRANCH
)
;
partnerData
.
partnerNames
=
partnerBranch
.
getChildList
(
"
"
)
;
return
partnerData
;
}
_getCpuData
(
)
{
let
cpuData
=
{
count
:
getSysinfoProperty
(
"
cpucount
"
null
)
cores
:
getSysinfoProperty
(
"
cpucores
"
null
)
vendor
:
getSysinfoProperty
(
"
cpuvendor
"
null
)
family
:
getSysinfoProperty
(
"
cpufamily
"
null
)
model
:
getSysinfoProperty
(
"
cpumodel
"
null
)
stepping
:
getSysinfoProperty
(
"
cpustepping
"
null
)
l2cacheKB
:
getSysinfoProperty
(
"
cpucachel2
"
null
)
l3cacheKB
:
getSysinfoProperty
(
"
cpucachel3
"
null
)
speedMHz
:
getSysinfoProperty
(
"
cpuspeed
"
null
)
}
;
const
CPU_EXTENSIONS
=
[
"
hasMMX
"
"
hasSSE
"
"
hasSSE2
"
"
hasSSE3
"
"
hasSSSE3
"
"
hasSSE4A
"
"
hasSSE4_1
"
"
hasSSE4_2
"
"
hasAVX
"
"
hasAVX2
"
"
hasEDSP
"
"
hasARMv6
"
"
hasARMv7
"
"
hasNEON
"
]
;
let
availableExts
=
[
]
;
for
(
let
ext
of
CPU_EXTENSIONS
)
{
if
(
getSysinfoProperty
(
ext
false
)
)
{
availableExts
.
push
(
ext
)
;
}
}
cpuData
.
extensions
=
availableExts
;
return
cpuData
;
}
_getDeviceData
(
)
{
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
return
null
;
}
return
{
model
:
getSysinfoProperty
(
"
device
"
null
)
manufacturer
:
getSysinfoProperty
(
"
manufacturer
"
null
)
hardware
:
getSysinfoProperty
(
"
hardware
"
null
)
isTablet
:
getSysinfoProperty
(
"
tablet
"
null
)
}
;
}
_getOSData
(
)
{
let
data
=
{
name
:
forceToStringOrNull
(
getSysinfoProperty
(
"
name
"
null
)
)
version
:
forceToStringOrNull
(
getSysinfoProperty
(
"
version
"
null
)
)
locale
:
forceToStringOrNull
(
getSystemLocale
(
)
)
}
;
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
data
.
kernelVersion
=
forceToStringOrNull
(
getSysinfoProperty
(
"
kernel_version
"
null
)
)
;
}
else
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
const
WINDOWS_UBR_KEY_PATH
=
"
SOFTWARE
\
\
Microsoft
\
\
Windows
NT
\
\
CurrentVersion
"
;
let
versionInfo
=
getWindowsVersionInfo
(
)
;
data
.
servicePackMajor
=
versionInfo
.
servicePackMajor
;
data
.
servicePackMinor
=
versionInfo
.
servicePackMinor
;
data
.
windowsBuildNumber
=
versionInfo
.
buildNumber
;
if
(
typeof
(
data
.
version
)
=
=
=
"
string
"
&
&
Services
.
vc
.
compare
(
data
.
version
"
10
"
)
>
=
0
)
{
let
ubr
=
WindowsRegistry
.
readRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_LOCAL_MACHINE
WINDOWS_UBR_KEY_PATH
"
UBR
"
Ci
.
nsIWindowsRegKey
.
WOW64_64
)
;
data
.
windowsUBR
=
(
ubr
!
=
=
undefined
)
?
ubr
:
null
;
}
data
.
installYear
=
getSysinfoProperty
(
"
installYear
"
null
)
;
}
return
data
;
}
_getHDDData
(
)
{
return
{
profile
:
{
model
:
getSysinfoProperty
(
"
profileHDDModel
"
null
)
revision
:
getSysinfoProperty
(
"
profileHDDRevision
"
null
)
}
binary
:
{
model
:
getSysinfoProperty
(
"
binHDDModel
"
null
)
revision
:
getSysinfoProperty
(
"
binHDDRevision
"
null
)
}
system
:
{
model
:
getSysinfoProperty
(
"
winHDDModel
"
null
)
revision
:
getSysinfoProperty
(
"
winHDDRevision
"
null
)
}
}
;
}
_getGFXData
(
)
{
let
gfxData
=
{
D2DEnabled
:
getGfxField
(
"
D2DEnabled
"
null
)
DWriteEnabled
:
getGfxField
(
"
DWriteEnabled
"
null
)
ContentBackend
:
getGfxField
(
"
ContentBackend
"
null
)
adapters
:
[
]
monitors
:
[
]
features
:
{
}
}
;
if
(
!
[
"
android
"
"
linux
"
]
.
includes
(
AppConstants
.
platform
)
)
{
let
gfxInfo
=
Cc
[
"
mozilla
.
org
/
gfx
/
info
;
1
"
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
try
{
gfxData
.
monitors
=
gfxInfo
.
getMonitors
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
nsIGfxInfo
.
getMonitors
(
)
caught
error
"
e
)
;
}
}
try
{
let
gfxInfo
=
Cc
[
"
mozilla
.
org
/
gfx
/
info
;
1
"
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
gfxData
.
features
=
gfxInfo
.
getFeatures
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
nsIGfxInfo
.
getFeatures
(
)
caught
error
"
e
)
;
}
gfxData
.
adapters
.
push
(
getGfxAdapter
(
"
"
)
)
;
gfxData
.
adapters
[
0
]
.
GPUActive
=
true
;
let
hasGPU2
=
getGfxField
(
"
adapterDeviceID2
"
null
)
!
=
=
null
;
if
(
!
hasGPU2
)
{
this
.
_log
.
trace
(
"
_getGFXData
-
Only
one
display
adapter
detected
.
"
)
;
return
gfxData
;
}
this
.
_log
.
trace
(
"
_getGFXData
-
Two
display
adapters
detected
.
"
)
;
gfxData
.
adapters
.
push
(
getGfxAdapter
(
"
2
"
)
)
;
gfxData
.
adapters
[
1
]
.
GPUActive
=
getGfxField
(
"
isGPU2Active
"
null
)
;
return
gfxData
;
}
_getSystem
(
)
{
let
memoryMB
=
getSysinfoProperty
(
"
memsize
"
null
)
;
if
(
memoryMB
)
{
memoryMB
=
Math
.
round
(
memoryMB
/
1024
/
1024
)
;
}
let
virtualMB
=
getSysinfoProperty
(
"
virtualmemsize
"
null
)
;
if
(
virtualMB
)
{
virtualMB
=
Math
.
round
(
virtualMB
/
1024
/
1024
)
;
}
let
data
=
{
memoryMB
virtualMaxMB
:
virtualMB
cpu
:
this
.
_getCpuData
(
)
os
:
this
.
_getOSData
(
)
hdd
:
this
.
_getHDDData
(
)
gfx
:
this
.
_getGFXData
(
)
}
;
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
data
.
isWow64
=
getSysinfoProperty
(
"
isWow64
"
null
)
;
}
else
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
data
.
device
=
this
.
_getDeviceData
(
)
;
}
return
data
;
}
_onEnvironmentChange
(
what
oldEnvironment
)
{
this
.
_log
.
trace
(
"
_onEnvironmentChange
for
"
+
what
)
;
if
(
this
.
_shutdown
)
{
this
.
_log
.
trace
(
"
_onEnvironmentChange
-
Already
shut
down
.
"
)
;
return
;
}
for
(
let
[
name
listener
]
of
this
.
_changeListeners
)
{
try
{
this
.
_log
.
debug
(
"
_onEnvironmentChange
-
calling
"
+
name
)
;
listener
(
what
oldEnvironment
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
_onEnvironmentChange
-
listener
"
+
name
+
"
caught
error
"
e
)
;
}
}
}
reset
(
)
{
this
.
_shutdown
=
false
;
this
.
_delayedInitFinished
=
false
;
}
}
;
