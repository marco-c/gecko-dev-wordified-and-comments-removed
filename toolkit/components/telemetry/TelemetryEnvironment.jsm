"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
TelemetryEnvironment
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
const
myScope
=
this
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
Utils
=
TelemetryUtils
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ctypes
"
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
if
(
AppConstants
.
platform
!
=
=
"
gonk
"
)
{
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LightweightThemeManager
"
"
resource
:
/
/
gre
/
modules
/
LightweightThemeManager
.
jsm
"
)
;
}
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ProfileAge
"
"
resource
:
/
/
gre
/
modules
/
ProfileAge
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
const
CHANGE_THROTTLE_INTERVAL_MS
=
5
*
60
*
1000
;
const
MAX_ADDON_STRING_LENGTH
=
100
;
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
}
;
var
gGlobalEnvironment
;
function
getGlobal
(
)
{
if
(
!
gGlobalEnvironment
)
{
gGlobalEnvironment
=
new
EnvironmentCache
(
)
;
}
return
gGlobalEnvironment
;
}
this
.
TelemetryEnvironment
=
{
get
currentEnvironment
(
)
{
return
getGlobal
(
)
.
currentEnvironment
;
}
onInitialized
:
function
(
)
{
return
getGlobal
(
)
.
onInitialized
(
)
;
}
delayedInit
:
function
(
)
{
return
getGlobal
(
)
.
delayedInit
(
)
;
}
registerChangeListener
:
function
(
name
listener
)
{
return
getGlobal
(
)
.
registerChangeListener
(
name
listener
)
;
}
unregisterChangeListener
:
function
(
name
)
{
return
getGlobal
(
)
.
unregisterChangeListener
(
name
)
;
}
shutdown
:
function
(
)
{
return
getGlobal
(
)
.
shutdown
(
)
;
}
RECORD_PREF_STATE
:
1
RECORD_PREF_VALUE
:
2
_watchPreferences
:
function
(
prefMap
)
{
return
getGlobal
(
)
.
_watchPreferences
(
prefMap
)
;
}
}
;
const
RECORD_PREF_STATE
=
TelemetryEnvironment
.
RECORD_PREF_STATE
;
const
RECORD_PREF_VALUE
=
TelemetryEnvironment
.
RECORD_PREF_VALUE
;
const
DEFAULT_ENVIRONMENT_PREFS
=
new
Map
(
[
[
"
app
.
feedback
.
baseURL
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
support
.
baseURL
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
accessibility
.
browsewithcaret
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
accessibility
.
force_disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
auto
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
interval
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
service
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
silent
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
app
.
update
.
url
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
cache
.
disk
.
enable
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
cache
.
disk
.
capacity
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
cache
.
memory
.
enable
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
cache
.
offline
.
enable
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
formfill
.
enable
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
newtab
.
url
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
browser
.
newtabpage
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
newtabpage
.
enhanced
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
shell
.
checkDefaultBrowser
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
search
.
suggest
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
startup
.
homepage
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
browser
.
startup
.
page
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
urlbar
.
suggest
.
searches
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
urlbar
.
unifiedcomplete
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
browser
.
urlbar
.
userMadeSearchSuggestionsChoice
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
devtools
.
chrome
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
devtools
.
debugger
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
devtools
.
debugger
.
remote
-
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
dom
.
ipc
.
plugins
.
asyncInit
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
dom
.
ipc
.
plugins
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
dom
.
ipc
.
processCount
"
{
what
:
RECORD_PREF_VALUE
requiresRestart
:
true
}
]
[
"
experiments
.
manifest
.
uri
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
autoDisableScopes
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
enabledScopes
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
blocklist
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
blocklist
.
url
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
strictCompatibility
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
update
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
update
.
url
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
extensions
.
update
.
background
.
url
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
general
.
smoothScroll
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
gfx
.
direct2d
.
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
gfx
.
direct2d
.
force
-
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
gfx
.
direct2d
.
use1_1
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
acceleration
.
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
acceleration
.
force
-
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
async
-
pan
-
zoom
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
async
-
video
-
oop
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
async
-
video
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
componentalpha
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
d3d11
.
disable
-
warp
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
d3d11
.
force
-
warp
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
offmainthreadcomposition
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
prefer
-
d3d9
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layers
.
prefer
-
opengl
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
layout
.
css
.
devPixelsPerPx
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
network
.
proxy
.
autoconfig_url
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
network
.
proxy
.
http
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
network
.
proxy
.
ssl
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
pdfjs
.
disabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
places
.
history
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
privacy
.
trackingprotection
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
privacy
.
donottrackheader
.
enabled
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
services
.
sync
.
serverURL
"
{
what
:
RECORD_PREF_STATE
}
]
[
"
security
.
mixed_content
.
block_active_content
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
security
.
mixed_content
.
block_display_content
"
{
what
:
RECORD_PREF_VALUE
}
]
[
"
xpinstall
.
signatures
.
required
"
{
what
:
RECORD_PREF_VALUE
}
]
]
)
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
PREF_BLOCKLIST_ENABLED
=
"
extensions
.
blocklist
.
enabled
"
;
const
PREF_DISTRIBUTION_ID
=
"
distribution
.
id
"
;
const
PREF_DISTRIBUTION_VERSION
=
"
distribution
.
version
"
;
const
PREF_DISTRIBUTOR
=
"
app
.
distributor
"
;
const
PREF_DISTRIBUTOR_CHANNEL
=
"
app
.
distributor
.
channel
"
;
const
PREF_HOTFIX_LASTVERSION
=
"
extensions
.
hotfix
.
lastVersion
"
;
const
PREF_APP_PARTNER_BRANCH
=
"
app
.
partner
.
"
;
const
PREF_PARTNER_ID
=
"
mozilla
.
partner
.
id
"
;
const
PREF_UPDATE_ENABLED
=
"
app
.
update
.
enabled
"
;
const
PREF_UPDATE_AUTODOWNLOAD
=
"
app
.
update
.
auto
"
;
const
PREF_SEARCH_COHORT
=
"
browser
.
search
.
cohort
"
;
const
EXPERIMENTS_CHANGED_TOPIC
=
"
experiments
-
changed
"
;
const
SEARCH_ENGINE_MODIFIED_TOPIC
=
"
browser
-
search
-
engine
-
modified
"
;
const
SEARCH_SERVICE_TOPIC
=
"
browser
-
search
-
service
"
;
const
COMPOSITOR_CREATED_TOPIC
=
"
compositor
:
created
"
;
const
DISTRIBUTION_CUSTOMIZATION_COMPLETE_TOPIC
=
"
distribution
-
customization
-
complete
"
;
function
getBrowserLocale
(
)
{
try
{
return
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIXULChromeRegistry
)
.
getSelectedLocale
(
'
global
'
)
;
}
catch
(
e
)
{
return
null
;
}
}
function
getSystemLocale
(
)
{
try
{
return
Services
.
locale
.
getLocaleComponentForUserAgent
(
)
;
}
catch
(
e
)
{
return
null
;
}
}
function
promiseGetAddonsByTypes
(
aTypes
)
{
return
new
Promise
(
(
resolve
)
=
>
AddonManager
.
getAddonsByTypes
(
aTypes
(
addons
)
=
>
resolve
(
addons
)
)
)
;
}
function
getSysinfoProperty
(
aPropertyName
aDefault
)
{
try
{
return
Services
.
sysinfo
.
getProperty
(
aPropertyName
)
;
}
catch
(
e
)
{
}
return
aDefault
;
}
function
getGfxField
(
aPropertyName
aDefault
)
{
let
gfxInfo
=
Cc
[
"
mozilla
.
org
/
gfx
/
info
;
1
"
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
try
{
let
gfxProp
=
gfxInfo
[
aPropertyName
]
;
if
(
gfxProp
!
=
=
"
"
)
{
return
gfxProp
;
}
}
catch
(
e
)
{
}
return
aDefault
;
}
function
limitStringToLength
(
aString
aMaxLength
)
{
if
(
typeof
(
aString
)
!
=
=
"
string
"
)
{
return
null
;
}
return
aString
.
substring
(
0
aMaxLength
)
;
}
function
getGfxAdapter
(
aSuffix
=
"
"
)
{
let
memoryMB
=
parseInt
(
getGfxField
(
"
adapterRAM
"
+
aSuffix
null
)
10
)
;
if
(
Number
.
isNaN
(
memoryMB
)
)
{
memoryMB
=
null
;
}
return
{
description
:
getGfxField
(
"
adapterDescription
"
+
aSuffix
null
)
vendorID
:
getGfxField
(
"
adapterVendorID
"
+
aSuffix
null
)
deviceID
:
getGfxField
(
"
adapterDeviceID
"
+
aSuffix
null
)
subsysID
:
getGfxField
(
"
adapterSubsysID
"
+
aSuffix
null
)
RAM
:
memoryMB
driver
:
getGfxField
(
"
adapterDriver
"
+
aSuffix
null
)
driverVersion
:
getGfxField
(
"
adapterDriverVersion
"
+
aSuffix
null
)
driverDate
:
getGfxField
(
"
adapterDriverDate
"
+
aSuffix
null
)
}
;
}
function
getServicePack
(
)
{
const
UNKNOWN_SERVICE_PACK
=
{
major
:
null
minor
:
null
}
;
if
(
AppConstants
.
platform
!
=
=
"
win
"
)
{
return
UNKNOWN_SERVICE_PACK
;
}
const
BYTE
=
ctypes
.
uint8_t
;
const
WORD
=
ctypes
.
uint16_t
;
const
DWORD
=
ctypes
.
uint32_t
;
const
WCHAR
=
ctypes
.
char16_t
;
const
BOOL
=
ctypes
.
int
;
const
SZCSDVERSIONLENGTH
=
128
;
const
OSVERSIONINFOEXW
=
new
ctypes
.
StructType
(
'
OSVERSIONINFOEXW
'
[
{
dwOSVersionInfoSize
:
DWORD
}
{
dwMajorVersion
:
DWORD
}
{
dwMinorVersion
:
DWORD
}
{
dwBuildNumber
:
DWORD
}
{
dwPlatformId
:
DWORD
}
{
szCSDVersion
:
ctypes
.
ArrayType
(
WCHAR
SZCSDVERSIONLENGTH
)
}
{
wServicePackMajor
:
WORD
}
{
wServicePackMinor
:
WORD
}
{
wSuiteMask
:
WORD
}
{
wProductType
:
BYTE
}
{
wReserved
:
BYTE
}
]
)
;
let
kernel32
=
ctypes
.
open
(
"
kernel32
"
)
;
try
{
let
GetVersionEx
=
kernel32
.
declare
(
"
GetVersionExW
"
ctypes
.
default_abi
BOOL
OSVERSIONINFOEXW
.
ptr
)
;
let
winVer
=
OSVERSIONINFOEXW
(
)
;
winVer
.
dwOSVersionInfoSize
=
OSVERSIONINFOEXW
.
size
;
if
(
0
=
=
=
GetVersionEx
(
winVer
.
address
(
)
)
)
{
throw
(
"
Failure
in
GetVersionEx
(
returned
0
)
"
)
;
}
return
{
major
:
winVer
.
wServicePackMajor
minor
:
winVer
.
wServicePackMinor
}
;
}
catch
(
e
)
{
return
UNKNOWN_SERVICE_PACK
;
}
finally
{
kernel32
.
close
(
)
;
}
}
function
EnvironmentAddonBuilder
(
environment
)
{
this
.
_environment
=
environment
;
this
.
_pendingTask
=
null
;
this
.
_loaded
=
false
;
}
EnvironmentAddonBuilder
.
prototype
=
{
init
:
function
(
)
{
try
{
AddonManager
.
shutdown
.
addBlocker
(
"
EnvironmentAddonBuilder
"
(
)
=
>
this
.
_shutdownBlocker
(
)
)
;
}
catch
(
err
)
{
return
Promise
.
reject
(
err
)
;
}
this
.
_pendingTask
=
this
.
_updateAddons
(
)
.
then
(
(
)
=
>
{
this
.
_pendingTask
=
null
;
}
(
err
)
=
>
{
this
.
_environment
.
_log
.
error
(
"
init
-
Exception
in
_updateAddons
"
err
)
;
this
.
_pendingTask
=
null
;
}
)
;
return
this
.
_pendingTask
;
}
watchForChanges
:
function
(
)
{
this
.
_loaded
=
true
;
AddonManager
.
addAddonListener
(
this
)
;
Services
.
obs
.
addObserver
(
this
EXPERIMENTS_CHANGED_TOPIC
false
)
;
}
onEnabled
:
function
(
)
{
this
.
_onAddonChange
(
)
;
}
onDisabled
:
function
(
)
{
this
.
_onAddonChange
(
)
;
}
onInstalled
:
function
(
)
{
this
.
_onAddonChange
(
)
;
}
onUninstalling
:
function
(
)
{
this
.
_onAddonChange
(
)
;
}
_onAddonChange
:
function
(
)
{
this
.
_environment
.
_log
.
trace
(
"
_onAddonChange
"
)
;
this
.
_checkForChanges
(
"
addons
-
changed
"
)
;
}
observe
:
function
(
aSubject
aTopic
aData
)
{
this
.
_environment
.
_log
.
trace
(
"
observe
-
Topic
"
+
aTopic
)
;
this
.
_checkForChanges
(
"
experiment
-
changed
"
)
;
}
_checkForChanges
:
function
(
changeReason
)
{
if
(
this
.
_pendingTask
)
{
this
.
_environment
.
_log
.
trace
(
"
_checkForChanges
-
task
already
pending
dropping
change
with
reason
"
+
changeReason
)
;
return
;
}
this
.
_pendingTask
=
this
.
_updateAddons
(
)
.
then
(
(
result
)
=
>
{
this
.
_pendingTask
=
null
;
if
(
result
.
changed
)
{
this
.
_environment
.
_onEnvironmentChange
(
changeReason
result
.
oldEnvironment
)
;
}
}
(
err
)
=
>
{
this
.
_pendingTask
=
null
;
this
.
_environment
.
_log
.
error
(
"
_checkForChanges
:
Error
collecting
addons
"
err
)
;
}
)
;
}
_shutdownBlocker
:
function
(
)
{
if
(
this
.
_loaded
)
{
AddonManager
.
removeAddonListener
(
this
)
;
Services
.
obs
.
removeObserver
(
this
EXPERIMENTS_CHANGED_TOPIC
)
;
}
return
this
.
_pendingTask
;
}
_updateAddons
:
Task
.
async
(
function
*
(
)
{
this
.
_environment
.
_log
.
trace
(
"
_updateAddons
"
)
;
let
personaId
=
null
;
if
(
AppConstants
.
platform
!
=
=
"
gonk
"
)
{
let
theme
=
LightweightThemeManager
.
currentTheme
;
if
(
theme
)
{
personaId
=
theme
.
id
;
}
}
let
addons
=
{
activeAddons
:
yield
this
.
_getActiveAddons
(
)
theme
:
yield
this
.
_getActiveTheme
(
)
activePlugins
:
this
.
_getActivePlugins
(
)
activeGMPlugins
:
yield
this
.
_getActiveGMPlugins
(
)
activeExperiment
:
this
.
_getActiveExperiment
(
)
persona
:
personaId
}
;
let
result
=
{
changed
:
!
ObjectUtils
.
deepEqual
(
addons
this
.
_environment
.
_currentEnvironment
.
addons
)
}
;
if
(
result
.
changed
)
{
this
.
_environment
.
_log
.
trace
(
"
_updateAddons
:
addons
differ
"
)
;
result
.
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_environment
.
_currentEnvironment
myScope
)
;
this
.
_environment
.
_currentEnvironment
.
addons
=
addons
;
}
return
result
;
}
)
_getActiveAddons
:
Task
.
async
(
function
*
(
)
{
let
allAddons
=
yield
promiseGetAddonsByTypes
(
[
"
extension
"
"
service
"
]
)
;
let
activeAddons
=
{
}
;
for
(
let
addon
of
allAddons
)
{
if
(
!
addon
.
isActive
)
{
continue
;
}
try
{
let
installDate
=
new
Date
(
Math
.
max
(
0
addon
.
installDate
)
)
;
let
updateDate
=
new
Date
(
Math
.
max
(
0
addon
.
updateDate
)
)
;
activeAddons
[
addon
.
id
]
=
{
blocklisted
:
(
addon
.
blocklistState
!
=
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
description
:
limitStringToLength
(
addon
.
description
MAX_ADDON_STRING_LENGTH
)
name
:
limitStringToLength
(
addon
.
name
MAX_ADDON_STRING_LENGTH
)
userDisabled
:
addon
.
userDisabled
appDisabled
:
addon
.
appDisabled
version
:
limitStringToLength
(
addon
.
version
MAX_ADDON_STRING_LENGTH
)
scope
:
addon
.
scope
type
:
addon
.
type
foreignInstall
:
addon
.
foreignInstall
hasBinaryComponents
:
addon
.
hasBinaryComponents
installDay
:
Utils
.
millisecondsToDays
(
installDate
.
getTime
(
)
)
updateDay
:
Utils
.
millisecondsToDays
(
updateDate
.
getTime
(
)
)
signedState
:
addon
.
signedState
isSystem
:
addon
.
isSystem
}
;
if
(
addon
.
signedState
!
=
=
undefined
)
activeAddons
[
addon
.
id
]
.
signedState
=
addon
.
signedState
;
}
catch
(
ex
)
{
this
.
_environment
.
_log
.
error
(
"
_getActiveAddons
-
An
addon
was
discarded
due
to
an
error
"
ex
)
;
continue
;
}
}
return
activeAddons
;
}
)
_getActiveTheme
:
Task
.
async
(
function
*
(
)
{
let
themes
=
yield
promiseGetAddonsByTypes
(
[
"
theme
"
]
)
;
let
activeTheme
=
{
}
;
let
theme
=
themes
.
find
(
theme
=
>
theme
.
isActive
)
;
if
(
theme
)
{
let
installDate
=
new
Date
(
Math
.
max
(
0
theme
.
installDate
)
)
;
let
updateDate
=
new
Date
(
Math
.
max
(
0
theme
.
updateDate
)
)
;
activeTheme
=
{
id
:
theme
.
id
blocklisted
:
(
theme
.
blocklistState
!
=
=
Ci
.
nsIBlocklistService
.
STATE_NOT_BLOCKED
)
description
:
limitStringToLength
(
theme
.
description
MAX_ADDON_STRING_LENGTH
)
name
:
limitStringToLength
(
theme
.
name
MAX_ADDON_STRING_LENGTH
)
userDisabled
:
theme
.
userDisabled
appDisabled
:
theme
.
appDisabled
version
:
limitStringToLength
(
theme
.
version
MAX_ADDON_STRING_LENGTH
)
scope
:
theme
.
scope
foreignInstall
:
theme
.
foreignInstall
hasBinaryComponents
:
theme
.
hasBinaryComponents
installDay
:
Utils
.
millisecondsToDays
(
installDate
.
getTime
(
)
)
updateDay
:
Utils
.
millisecondsToDays
(
updateDate
.
getTime
(
)
)
}
;
}
return
activeTheme
;
}
)
_getActivePlugins
:
function
(
)
{
let
pluginTags
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
.
getPluginTags
(
{
}
)
;
let
activePlugins
=
[
]
;
for
(
let
tag
of
pluginTags
)
{
if
(
tag
.
disabled
)
{
continue
;
}
try
{
let
updateDate
=
new
Date
(
Math
.
max
(
0
tag
.
lastModifiedTime
)
)
;
activePlugins
.
push
(
{
name
:
limitStringToLength
(
tag
.
name
MAX_ADDON_STRING_LENGTH
)
version
:
limitStringToLength
(
tag
.
version
MAX_ADDON_STRING_LENGTH
)
description
:
limitStringToLength
(
tag
.
description
MAX_ADDON_STRING_LENGTH
)
blocklisted
:
tag
.
blocklisted
disabled
:
tag
.
disabled
clicktoplay
:
tag
.
clicktoplay
mimeTypes
:
tag
.
getMimeTypes
(
{
}
)
updateDay
:
Utils
.
millisecondsToDays
(
updateDate
.
getTime
(
)
)
}
)
;
}
catch
(
ex
)
{
this
.
_environment
.
_log
.
error
(
"
_getActivePlugins
-
A
plugin
was
discarded
due
to
an
error
"
ex
)
;
continue
;
}
}
return
activePlugins
;
}
_getActiveGMPlugins
:
Task
.
async
(
function
*
(
)
{
let
allPlugins
=
yield
promiseGetAddonsByTypes
(
[
"
plugin
"
]
)
;
let
activeGMPlugins
=
{
}
;
for
(
let
plugin
of
allPlugins
)
{
if
(
!
plugin
.
isGMPlugin
|
|
!
plugin
.
isActive
)
{
continue
;
}
try
{
activeGMPlugins
[
plugin
.
id
]
=
{
version
:
plugin
.
version
userDisabled
:
plugin
.
userDisabled
applyBackgroundUpdates
:
plugin
.
applyBackgroundUpdates
}
;
}
catch
(
ex
)
{
this
.
_environment
.
_log
.
error
(
"
_getActiveGMPlugins
-
A
GMPlugin
was
discarded
due
to
an
error
"
ex
)
;
continue
;
}
}
return
activeGMPlugins
;
}
)
_getActiveExperiment
:
function
(
)
{
let
experimentInfo
=
{
}
;
try
{
let
scope
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
experiments
/
Experiments
.
jsm
"
scope
)
;
let
experiments
=
scope
.
Experiments
.
instance
(
)
;
let
activeExperiment
=
experiments
.
getActiveExperimentID
(
)
;
if
(
activeExperiment
)
{
experimentInfo
.
id
=
activeExperiment
;
experimentInfo
.
branch
=
experiments
.
getActiveExperimentBranch
(
)
;
}
}
catch
(
e
)
{
}
return
experimentInfo
;
}
}
;
function
EnvironmentCache
(
)
{
this
.
_log
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
"
TelemetryEnvironment
:
:
"
)
;
this
.
_log
.
trace
(
"
constructor
"
)
;
this
.
_shutdown
=
false
;
this
.
_delayedInitFinished
=
false
;
this
.
_changeListeners
=
new
Map
(
)
;
this
.
_lastEnvironmentChangeDate
=
null
;
this
.
_watchedPrefs
=
DEFAULT_ENVIRONMENT_PREFS
;
this
.
_currentEnvironment
=
{
build
:
this
.
_getBuild
(
)
partner
:
this
.
_getPartner
(
)
system
:
this
.
_getSystem
(
)
}
;
this
.
_updateSettings
(
)
;
this
.
_updateSearchEngine
(
)
;
this
.
_addObservers
(
)
;
let
p
=
[
]
;
if
(
AppConstants
.
platform
=
=
=
"
gonk
"
)
{
this
.
_addonBuilder
=
{
watchForChanges
:
function
(
)
{
}
}
;
}
else
{
this
.
_addonBuilder
=
new
EnvironmentAddonBuilder
(
this
)
;
p
=
[
this
.
_addonBuilder
.
init
(
)
]
;
}
this
.
_currentEnvironment
.
profile
=
{
}
;
p
.
push
(
this
.
_updateProfile
(
)
)
;
let
setup
=
(
)
=
>
{
this
.
_initTask
=
null
;
this
.
_startWatchingPrefs
(
)
;
this
.
_addonBuilder
.
watchForChanges
(
)
;
this
.
_updateGraphicsFeatures
(
)
;
return
this
.
currentEnvironment
;
}
;
this
.
_initTask
=
Promise
.
all
(
p
)
.
then
(
(
)
=
>
setup
(
)
(
err
)
=
>
{
this
.
_log
.
error
(
"
EnvironmentCache
-
error
while
initializing
"
err
)
;
return
setup
(
)
;
}
)
;
}
EnvironmentCache
.
prototype
=
{
get
currentEnvironment
(
)
{
return
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
}
onInitialized
:
function
(
)
{
if
(
this
.
_initTask
)
{
return
this
.
_initTask
;
}
return
Promise
.
resolve
(
this
.
currentEnvironment
)
;
}
delayedInit
:
function
(
)
{
this
.
_delayedInitFinished
=
true
;
}
registerChangeListener
:
function
(
name
listener
)
{
this
.
_log
.
trace
(
"
registerChangeListener
for
"
+
name
)
;
if
(
this
.
_shutdown
)
{
this
.
_log
.
warn
(
"
registerChangeListener
-
already
shutdown
"
)
;
return
;
}
this
.
_changeListeners
.
set
(
name
listener
)
;
}
unregisterChangeListener
:
function
(
name
)
{
this
.
_log
.
trace
(
"
unregisterChangeListener
for
"
+
name
)
;
if
(
this
.
_shutdown
)
{
this
.
_log
.
warn
(
"
registerChangeListener
-
already
shutdown
"
)
;
return
;
}
this
.
_changeListeners
.
delete
(
name
)
;
}
shutdown
:
function
(
)
{
this
.
_log
.
trace
(
"
shutdown
"
)
;
this
.
_shutdown
=
true
;
}
_watchPreferences
:
function
(
aPreferences
)
{
this
.
_stopWatchingPrefs
(
)
;
this
.
_watchedPrefs
=
aPreferences
;
this
.
_updateSettings
(
)
;
this
.
_startWatchingPrefs
(
)
;
}
_getPrefData
:
function
(
)
{
let
prefData
=
{
}
;
for
(
let
[
pref
policy
]
of
this
.
_watchedPrefs
.
entries
(
)
)
{
if
(
!
Preferences
.
isSet
(
pref
)
)
{
continue
;
}
let
prefValue
=
undefined
;
if
(
policy
.
what
=
=
TelemetryEnvironment
.
RECORD_PREF_STATE
)
{
prefValue
=
"
<
user
-
set
>
"
;
}
else
{
prefValue
=
Preferences
.
get
(
pref
null
)
;
}
prefData
[
pref
]
=
prefValue
;
}
return
prefData
;
}
_startWatchingPrefs
:
function
(
)
{
this
.
_log
.
trace
(
"
_startWatchingPrefs
-
"
+
this
.
_watchedPrefs
)
;
for
(
let
[
pref
options
]
of
this
.
_watchedPrefs
)
{
if
(
!
(
"
requiresRestart
"
in
options
)
|
|
!
options
.
requiresRestart
)
{
Preferences
.
observe
(
pref
this
.
_onPrefChanged
this
)
;
}
}
}
_onPrefChanged
:
function
(
)
{
this
.
_log
.
trace
(
"
_onPrefChanged
"
)
;
let
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
this
.
_updateSettings
(
)
;
this
.
_onEnvironmentChange
(
"
pref
-
changed
"
oldEnvironment
)
;
}
_stopWatchingPrefs
:
function
(
)
{
this
.
_log
.
trace
(
"
_stopWatchingPrefs
"
)
;
for
(
let
[
pref
options
]
of
this
.
_watchedPrefs
)
{
if
(
!
(
"
requiresRestart
"
in
options
)
|
|
!
options
.
requiresRestart
)
{
Preferences
.
ignore
(
pref
this
.
_onPrefChanged
this
)
;
}
}
}
_addObservers
:
function
(
)
{
Services
.
obs
.
addObserver
(
this
SEARCH_ENGINE_MODIFIED_TOPIC
false
)
;
Services
.
obs
.
addObserver
(
this
SEARCH_SERVICE_TOPIC
false
)
;
Services
.
obs
.
addObserver
(
this
COMPOSITOR_CREATED_TOPIC
false
)
;
Services
.
obs
.
addObserver
(
this
DISTRIBUTION_CUSTOMIZATION_COMPLETE_TOPIC
false
)
;
}
_removeObservers
:
function
(
)
{
Services
.
obs
.
removeObserver
(
this
SEARCH_ENGINE_MODIFIED_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
SEARCH_SERVICE_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
COMPOSITOR_CREATED_TOPIC
)
;
try
{
Services
.
obs
.
removeObserver
(
this
DISTRIBUTION_CUSTOMIZATION_COMPLETE_TOPIC
)
;
}
catch
(
ex
)
{
}
}
observe
:
function
(
aSubject
aTopic
aData
)
{
this
.
_log
.
trace
(
"
observe
-
aTopic
:
"
+
aTopic
+
"
aData
:
"
+
aData
)
;
switch
(
aTopic
)
{
case
SEARCH_ENGINE_MODIFIED_TOPIC
:
if
(
aData
!
=
"
engine
-
current
"
)
{
return
;
}
this
.
_onSearchEngineChange
(
)
;
break
;
case
SEARCH_SERVICE_TOPIC
:
if
(
aData
!
=
"
init
-
complete
"
)
{
return
;
}
this
.
_updateSearchEngine
(
)
;
break
;
case
COMPOSITOR_CREATED_TOPIC
:
this
.
_updateGraphicsFeatures
(
)
;
break
;
case
DISTRIBUTION_CUSTOMIZATION_COMPLETE_TOPIC
:
this
.
_updatePartner
(
)
;
Services
.
obs
.
removeObserver
(
this
aTopic
)
;
break
;
}
}
_getDefaultSearchEngine
:
function
(
)
{
let
engine
;
try
{
engine
=
Services
.
search
.
defaultEngine
;
}
catch
(
e
)
{
}
let
name
;
if
(
!
engine
)
{
name
=
"
NONE
"
;
}
else
if
(
engine
.
identifier
)
{
name
=
engine
.
identifier
;
}
else
if
(
engine
.
name
)
{
name
=
"
other
-
"
+
engine
.
name
;
}
else
{
name
=
"
UNDEFINED
"
;
}
return
name
;
}
_updateSearchEngine
:
function
(
)
{
if
(
!
Services
.
search
)
{
return
;
}
this
.
_log
.
trace
(
"
_updateSearchEngine
-
isInitialized
:
"
+
Services
.
search
.
isInitialized
)
;
if
(
!
Services
.
search
.
isInitialized
)
{
return
;
}
this
.
_currentEnvironment
.
settings
=
this
.
_currentEnvironment
.
settings
|
|
{
}
;
this
.
_currentEnvironment
.
settings
.
defaultSearchEngine
=
this
.
_getDefaultSearchEngine
(
)
;
this
.
_currentEnvironment
.
settings
.
defaultSearchEngineData
=
Services
.
search
.
getDefaultEngineInfo
(
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_SEARCH_COHORT
)
)
this
.
_currentEnvironment
.
settings
.
searchCohort
=
Services
.
prefs
.
getCharPref
(
PREF_SEARCH_COHORT
)
;
}
_onSearchEngineChange
:
function
(
)
{
this
.
_log
.
trace
(
"
_onSearchEngineChange
"
)
;
let
oldEnvironment
=
Cu
.
cloneInto
(
this
.
_currentEnvironment
myScope
)
;
this
.
_updateSearchEngine
(
)
;
this
.
_onEnvironmentChange
(
"
search
-
engine
-
changed
"
oldEnvironment
)
;
}
_updateGraphicsFeatures
:
function
(
)
{
let
gfxData
=
this
.
_currentEnvironment
.
system
.
gfx
;
try
{
let
gfxInfo
=
Cc
[
"
mozilla
.
org
/
gfx
/
info
;
1
"
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
gfxData
.
features
=
gfxInfo
.
getFeatures
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
nsIGfxInfo
.
getFeatures
(
)
caught
error
"
e
)
;
}
}
_updatePartner
:
function
(
)
{
this
.
_currentEnvironment
.
partner
=
this
.
_getPartner
(
)
;
}
_getBuild
:
function
(
)
{
let
buildData
=
{
applicationId
:
Services
.
appinfo
.
ID
|
|
null
applicationName
:
Services
.
appinfo
.
name
|
|
null
architecture
:
Services
.
sysinfo
.
get
(
"
arch
"
)
buildId
:
Services
.
appinfo
.
appBuildID
|
|
null
version
:
Services
.
appinfo
.
version
|
|
null
vendor
:
Services
.
appinfo
.
vendor
|
|
null
platformVersion
:
Services
.
appinfo
.
platformVersion
|
|
null
xpcomAbi
:
Services
.
appinfo
.
XPCOMABI
hotfixVersion
:
Preferences
.
get
(
PREF_HOTFIX_LASTVERSION
null
)
}
;
if
(
"
mozilla
.
org
/
xpcom
/
mac
-
utils
;
1
"
in
Cc
)
{
let
macUtils
=
Cc
[
"
mozilla
.
org
/
xpcom
/
mac
-
utils
;
1
"
]
.
getService
(
Ci
.
nsIMacUtils
)
;
if
(
macUtils
&
&
macUtils
.
isUniversalBinary
)
{
buildData
.
architecturesInBinary
=
macUtils
.
architecturesInBinary
;
}
}
return
buildData
;
}
_isDefaultBrowser
:
function
(
)
{
if
(
AppConstants
.
platform
=
=
=
"
gonk
"
)
{
return
true
;
}
if
(
!
(
"
mozilla
.
org
/
browser
/
shell
-
service
;
1
"
in
Cc
)
)
{
this
.
_log
.
info
(
"
_isDefaultBrowser
-
Could
not
obtain
browser
shell
service
"
)
;
return
null
;
}
let
shellService
;
try
{
let
scope
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
scope
)
;
shellService
=
scope
.
ShellService
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_isDefaultBrowser
-
Could
not
obtain
shell
service
JSM
"
)
;
}
if
(
!
shellService
)
{
try
{
shellService
=
Cc
[
"
mozilla
.
org
/
browser
/
shell
-
service
;
1
"
]
.
getService
(
Ci
.
nsIShellService
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_isDefaultBrowser
-
Could
not
obtain
shell
service
"
ex
)
;
return
null
;
}
}
try
{
return
shellService
.
isDefaultBrowser
(
false
true
)
?
true
:
false
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_isDefaultBrowser
-
Could
not
determine
if
default
browser
"
ex
)
;
return
null
;
}
return
null
;
}
_updateSettings
:
function
(
)
{
let
updateChannel
=
null
;
try
{
updateChannel
=
UpdateUtils
.
getUpdateChannel
(
false
)
;
}
catch
(
e
)
{
}
this
.
_currentEnvironment
.
settings
=
{
blocklistEnabled
:
Preferences
.
get
(
PREF_BLOCKLIST_ENABLED
true
)
e10sEnabled
:
Services
.
appinfo
.
browserTabsRemoteAutostart
telemetryEnabled
:
Utils
.
isTelemetryEnabled
locale
:
getBrowserLocale
(
)
update
:
{
channel
:
updateChannel
enabled
:
Preferences
.
get
(
PREF_UPDATE_ENABLED
true
)
autoDownload
:
Preferences
.
get
(
PREF_UPDATE_AUTODOWNLOAD
true
)
}
userPrefs
:
this
.
_getPrefData
(
)
}
;
if
(
AppConstants
.
platform
!
=
=
"
gonk
"
)
{
this
.
_currentEnvironment
.
settings
.
addonCompatibilityCheckEnabled
=
AddonManager
.
checkCompatibility
;
}
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
this
.
_currentEnvironment
.
settings
.
isDefaultBrowser
=
this
.
_isDefaultBrowser
(
)
;
}
this
.
_updateSearchEngine
(
)
;
}
_updateProfile
:
Task
.
async
(
function
*
(
)
{
const
logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
"
ProfileAge
-
"
)
;
let
profileAccessor
=
new
ProfileAge
(
null
logger
)
;
let
creationDate
=
yield
profileAccessor
.
created
;
let
resetDate
=
yield
profileAccessor
.
reset
;
this
.
_currentEnvironment
.
profile
.
creationDate
=
Utils
.
millisecondsToDays
(
creationDate
)
;
if
(
resetDate
)
{
this
.
_currentEnvironment
.
profile
.
resetDate
=
Utils
.
millisecondsToDays
(
resetDate
)
;
}
}
)
_getPartner
:
function
(
)
{
let
partnerData
=
{
distributionId
:
Preferences
.
get
(
PREF_DISTRIBUTION_ID
null
)
distributionVersion
:
Preferences
.
get
(
PREF_DISTRIBUTION_VERSION
null
)
partnerId
:
Preferences
.
get
(
PREF_PARTNER_ID
null
)
distributor
:
Preferences
.
get
(
PREF_DISTRIBUTOR
null
)
distributorChannel
:
Preferences
.
get
(
PREF_DISTRIBUTOR_CHANNEL
null
)
}
;
let
partnerBranch
=
Services
.
prefs
.
getBranch
(
PREF_APP_PARTNER_BRANCH
)
;
partnerData
.
partnerNames
=
partnerBranch
.
getChildList
(
"
"
)
;
return
partnerData
;
}
_getCpuData
:
function
(
)
{
let
cpuData
=
{
count
:
getSysinfoProperty
(
"
cpucount
"
null
)
cores
:
getSysinfoProperty
(
"
cpucores
"
null
)
vendor
:
getSysinfoProperty
(
"
cpuvendor
"
null
)
family
:
getSysinfoProperty
(
"
cpufamily
"
null
)
model
:
getSysinfoProperty
(
"
cpumodel
"
null
)
stepping
:
getSysinfoProperty
(
"
cpustepping
"
null
)
l2cacheKB
:
getSysinfoProperty
(
"
cpucachel2
"
null
)
l3cacheKB
:
getSysinfoProperty
(
"
cpucachel3
"
null
)
speedMHz
:
getSysinfoProperty
(
"
cpuspeed
"
null
)
}
;
const
CPU_EXTENSIONS
=
[
"
hasMMX
"
"
hasSSE
"
"
hasSSE2
"
"
hasSSE3
"
"
hasSSSE3
"
"
hasSSE4A
"
"
hasSSE4_1
"
"
hasSSE4_2
"
"
hasEDSP
"
"
hasARMv6
"
"
hasARMv7
"
"
hasNEON
"
]
;
let
availableExts
=
[
]
;
for
(
let
ext
of
CPU_EXTENSIONS
)
{
if
(
getSysinfoProperty
(
ext
false
)
)
{
availableExts
.
push
(
ext
)
;
}
}
cpuData
.
extensions
=
availableExts
;
return
cpuData
;
}
_getDeviceData
:
function
(
)
{
if
(
!
[
"
gonk
"
"
android
"
]
.
includes
(
AppConstants
.
platform
)
)
{
return
null
;
}
return
{
model
:
getSysinfoProperty
(
"
device
"
null
)
manufacturer
:
getSysinfoProperty
(
"
manufacturer
"
null
)
hardware
:
getSysinfoProperty
(
"
hardware
"
null
)
isTablet
:
getSysinfoProperty
(
"
tablet
"
null
)
}
;
}
_getOSData
:
function
(
)
{
let
data
=
{
name
:
getSysinfoProperty
(
"
name
"
null
)
version
:
getSysinfoProperty
(
"
version
"
null
)
locale
:
getSystemLocale
(
)
}
;
if
(
[
"
gonk
"
"
android
"
]
.
includes
(
AppConstants
.
platform
)
)
{
data
.
kernelVersion
=
getSysinfoProperty
(
"
kernel_version
"
null
)
;
}
else
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
let
servicePack
=
getServicePack
(
)
;
data
.
servicePackMajor
=
servicePack
.
major
;
data
.
servicePackMinor
=
servicePack
.
minor
;
data
.
installYear
=
getSysinfoProperty
(
"
installYear
"
null
)
;
}
return
data
;
}
_getHDDData
:
function
(
)
{
return
{
profile
:
{
model
:
getSysinfoProperty
(
"
profileHDDModel
"
null
)
revision
:
getSysinfoProperty
(
"
profileHDDRevision
"
null
)
}
binary
:
{
model
:
getSysinfoProperty
(
"
binHDDModel
"
null
)
revision
:
getSysinfoProperty
(
"
binHDDRevision
"
null
)
}
system
:
{
model
:
getSysinfoProperty
(
"
winHDDModel
"
null
)
revision
:
getSysinfoProperty
(
"
winHDDRevision
"
null
)
}
}
;
}
_getGFXData
:
function
(
)
{
let
gfxData
=
{
D2DEnabled
:
getGfxField
(
"
D2DEnabled
"
null
)
DWriteEnabled
:
getGfxField
(
"
DWriteEnabled
"
null
)
adapters
:
[
]
monitors
:
[
]
features
:
{
}
}
;
if
(
!
[
"
gonk
"
"
android
"
"
linux
"
]
.
includes
(
AppConstants
.
platform
)
)
{
let
gfxInfo
=
Cc
[
"
mozilla
.
org
/
gfx
/
info
;
1
"
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
try
{
gfxData
.
monitors
=
gfxInfo
.
getMonitors
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
nsIGfxInfo
.
getMonitors
(
)
caught
error
"
e
)
;
}
}
try
{
let
gfxInfo
=
Cc
[
"
mozilla
.
org
/
gfx
/
info
;
1
"
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
gfxData
.
features
=
gfxInfo
.
getFeatures
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
nsIGfxInfo
.
getFeatures
(
)
caught
error
"
e
)
;
}
gfxData
.
adapters
.
push
(
getGfxAdapter
(
"
"
)
)
;
gfxData
.
adapters
[
0
]
.
GPUActive
=
true
;
let
hasGPU2
=
getGfxField
(
"
adapterDeviceID2
"
null
)
!
=
=
null
;
if
(
!
hasGPU2
)
{
this
.
_log
.
trace
(
"
_getGFXData
-
Only
one
display
adapter
detected
.
"
)
;
return
gfxData
;
}
this
.
_log
.
trace
(
"
_getGFXData
-
Two
display
adapters
detected
.
"
)
;
gfxData
.
adapters
.
push
(
getGfxAdapter
(
"
2
"
)
)
;
gfxData
.
adapters
[
1
]
.
GPUActive
=
getGfxField
(
"
isGPU2Active
"
null
)
;
return
gfxData
;
}
_getSystem
:
function
(
)
{
let
memoryMB
=
getSysinfoProperty
(
"
memsize
"
null
)
;
if
(
memoryMB
)
{
memoryMB
=
Math
.
round
(
memoryMB
/
1024
/
1024
)
;
}
let
virtualMB
=
getSysinfoProperty
(
"
virtualmemsize
"
null
)
;
if
(
virtualMB
)
{
virtualMB
=
Math
.
round
(
virtualMB
/
1024
/
1024
)
;
}
let
data
=
{
memoryMB
:
memoryMB
virtualMaxMB
:
virtualMB
cpu
:
this
.
_getCpuData
(
)
os
:
this
.
_getOSData
(
)
hdd
:
this
.
_getHDDData
(
)
gfx
:
this
.
_getGFXData
(
)
}
;
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
data
.
isWow64
=
getSysinfoProperty
(
"
isWow64
"
null
)
;
}
else
if
(
[
"
gonk
"
"
android
"
]
.
includes
(
AppConstants
.
platform
)
)
{
data
.
device
=
this
.
_getDeviceData
(
)
;
}
return
data
;
}
_onEnvironmentChange
:
function
(
what
oldEnvironment
)
{
this
.
_log
.
trace
(
"
_onEnvironmentChange
for
"
+
what
)
;
if
(
this
.
_shutdown
)
{
this
.
_log
.
trace
(
"
_onEnvironmentChange
-
Already
shut
down
.
"
)
;
return
;
}
let
now
=
Policy
.
now
(
)
;
if
(
this
.
_lastEnvironmentChangeDate
&
&
this
.
_delayedInitFinished
&
&
(
CHANGE_THROTTLE_INTERVAL_MS
>
=
(
now
.
getTime
(
)
-
this
.
_lastEnvironmentChangeDate
.
getTime
(
)
)
)
)
{
this
.
_log
.
trace
(
"
_onEnvironmentChange
-
throttling
changes
now
:
"
+
now
+
"
last
change
:
"
+
this
.
_lastEnvironmentChangeDate
)
;
return
;
}
if
(
this
.
_delayedInitFinished
)
{
this
.
_lastEnvironmentChangeDate
=
now
;
}
for
(
let
[
name
listener
]
of
this
.
_changeListeners
)
{
try
{
this
.
_log
.
debug
(
"
_onEnvironmentChange
-
calling
"
+
name
)
;
listener
(
what
oldEnvironment
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
_onEnvironmentChange
-
listener
"
+
name
+
"
caught
error
"
e
)
;
}
}
}
}
;
