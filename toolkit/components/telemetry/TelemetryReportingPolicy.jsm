"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetryReportingPolicy
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
observers
.
js
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetrySend
"
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
jsm
"
)
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
LOGGER_PREFIX
=
"
TelemetryReportingPolicy
:
:
"
;
const
OLDEST_ALLOWED_ACCEPTANCE_YEAR
=
2012
;
const
PREF_BRANCH
=
"
datareporting
.
policy
.
"
;
const
DEPRECATED_FHR_PREFS
=
[
PREF_BRANCH
+
"
dataSubmissionPolicyAccepted
"
PREF_BRANCH
+
"
dataSubmissionPolicyBypassAcceptance
"
PREF_BRANCH
+
"
dataSubmissionPolicyResponseType
"
PREF_BRANCH
+
"
dataSubmissionPolicyResponseTime
"
]
;
const
NOTIFICATION_DELAY_FIRST_RUN_MSEC
=
60
*
1000
;
const
NOTIFICATION_DELAY_NEXT_RUNS_MSEC
=
10
*
1000
;
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
setShowInfobarTimeout
:
(
callback
delayMs
)
=
>
setTimeout
(
callback
delayMs
)
clearShowInfobarTimeout
:
(
id
)
=
>
clearTimeout
(
id
)
}
;
function
NotifyPolicyRequest
(
aLog
)
{
this
.
_log
=
aLog
;
}
NotifyPolicyRequest
.
prototype
=
Object
.
freeze
(
{
onUserNotifyComplete
(
)
{
return
TelemetryReportingPolicyImpl
.
_userNotified
(
)
;
}
onUserNotifyFailed
(
error
)
{
this
.
_log
.
error
(
"
onUserNotifyFailed
-
"
+
error
)
;
}
}
)
;
var
TelemetryReportingPolicy
=
{
DEFAULT_DATAREPORTING_POLICY_VERSION
:
1
setup
(
)
{
return
TelemetryReportingPolicyImpl
.
setup
(
)
;
}
shutdown
(
)
{
return
TelemetryReportingPolicyImpl
.
shutdown
(
)
;
}
canUpload
(
)
{
return
TelemetryReportingPolicyImpl
.
canUpload
(
)
;
}
isFirstRun
(
)
{
return
TelemetryReportingPolicyImpl
.
isFirstRun
(
)
;
}
reset
(
)
{
return
TelemetryReportingPolicyImpl
.
reset
(
)
;
}
testIsUserNotified
(
)
{
return
TelemetryReportingPolicyImpl
.
isUserNotifiedOfCurrentPolicy
;
}
testInfobarShown
(
)
{
return
TelemetryReportingPolicyImpl
.
_userNotified
(
)
;
}
testUpdateFirstRun
(
)
{
return
TelemetryReportingPolicyImpl
.
observe
(
null
"
sessionstore
-
windows
-
restored
"
null
)
;
}
}
;
var
TelemetryReportingPolicyImpl
=
{
_logger
:
null
_notificationInProgress
:
false
_startupNotificationTimerId
:
null
_isFirstRun
:
true
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
)
;
}
return
this
.
_logger
;
}
get
dataSubmissionPolicyNotifiedDate
(
)
{
let
prefString
=
Services
.
prefs
.
getStringPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyDate
"
0
"
)
;
let
valueInteger
=
parseInt
(
prefString
10
)
;
if
(
valueInteger
=
=
0
)
{
this
.
_log
.
info
(
"
get
dataSubmissionPolicyNotifiedDate
-
No
date
stored
yet
.
"
)
;
return
null
;
}
if
(
Number
.
isNaN
(
valueInteger
)
)
{
this
.
_log
.
error
(
"
get
dataSubmissionPolicyNotifiedDate
-
Invalid
date
stored
.
"
)
;
return
null
;
}
let
date
=
new
Date
(
valueInteger
)
;
if
(
date
.
getFullYear
(
)
<
OLDEST_ALLOWED_ACCEPTANCE_YEAR
)
{
this
.
_log
.
error
(
"
get
dataSubmissionPolicyNotifiedDate
-
The
stored
date
is
too
old
.
"
)
;
return
null
;
}
return
date
;
}
set
dataSubmissionPolicyNotifiedDate
(
aDate
)
{
this
.
_log
.
trace
(
"
set
dataSubmissionPolicyNotifiedDate
-
aDate
:
"
+
aDate
)
;
if
(
!
aDate
|
|
aDate
.
getFullYear
(
)
<
OLDEST_ALLOWED_ACCEPTANCE_YEAR
)
{
this
.
_log
.
error
(
"
set
dataSubmissionPolicyNotifiedDate
-
Invalid
notification
date
.
"
)
;
return
;
}
Services
.
prefs
.
setStringPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyDate
aDate
.
getTime
(
)
.
toString
(
)
)
;
}
get
dataSubmissionEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
DataSubmissionEnabled
true
)
;
}
get
currentPolicyVersion
(
)
{
return
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
TelemetryReportingPolicy
.
DEFAULT_DATAREPORTING_POLICY_VERSION
)
;
}
get
minimumPolicyVersion
(
)
{
const
minPolicyVersion
=
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
MinimumPolicyVersion
1
)
;
let
channel
=
"
"
;
try
{
channel
=
TelemetryUtils
.
getUpdateChannel
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
minimumPolicyVersion
-
Unable
to
retrieve
the
current
channel
.
"
)
;
return
minPolicyVersion
;
}
const
channelPref
=
TelemetryUtils
.
Preferences
.
MinimumPolicyVersion
+
"
.
channel
-
"
+
channel
;
return
Services
.
prefs
.
getIntPref
(
channelPref
minPolicyVersion
)
;
}
get
dataSubmissionPolicyAcceptedVersion
(
)
{
return
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
0
)
;
}
set
dataSubmissionPolicyAcceptedVersion
(
value
)
{
Services
.
prefs
.
setIntPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
value
)
;
}
get
isUserNotifiedOfCurrentPolicy
(
)
{
if
(
!
this
.
dataSubmissionPolicyNotifiedDate
|
|
this
.
dataSubmissionPolicyNotifiedDate
.
getTime
(
)
<
=
0
)
{
return
false
;
}
if
(
this
.
dataSubmissionPolicyAcceptedVersion
<
this
.
minimumPolicyVersion
)
{
return
false
;
}
return
true
;
}
reset
(
)
{
this
.
shutdown
(
)
;
return
this
.
setup
(
)
;
}
setup
(
)
{
this
.
_log
.
trace
(
"
setup
"
)
;
this
.
_migratePreferences
(
)
;
Services
.
obs
.
addObserver
(
this
"
sessionstore
-
windows
-
restored
"
)
;
}
shutdown
(
)
{
this
.
_log
.
trace
(
"
shutdown
"
)
;
this
.
_detachObservers
(
)
;
Policy
.
clearShowInfobarTimeout
(
this
.
_startupNotificationTimerId
)
;
}
_detachObservers
(
)
{
Services
.
obs
.
removeObserver
(
this
"
sessionstore
-
windows
-
restored
"
)
;
}
canUpload
(
)
{
if
(
!
this
.
dataSubmissionEnabled
)
{
return
false
;
}
const
bypassNotification
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
BypassNotification
false
)
;
return
this
.
isUserNotifiedOfCurrentPolicy
|
|
bypassNotification
;
}
isFirstRun
(
)
{
return
this
.
_isFirstRun
;
}
_migratePreferences
(
)
{
for
(
let
pref
of
DEPRECATED_FHR_PREFS
)
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
}
_shouldNotify
(
)
{
if
(
!
this
.
dataSubmissionEnabled
)
{
this
.
_log
.
trace
(
"
_shouldNotify
-
Data
submission
disabled
by
the
policy
.
"
)
;
return
false
;
}
const
bypassNotification
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
BypassNotification
false
)
;
if
(
this
.
isUserNotifiedOfCurrentPolicy
|
|
bypassNotification
)
{
this
.
_log
.
trace
(
"
_shouldNotify
-
User
already
notified
or
bypassing
the
policy
.
"
)
;
return
false
;
}
if
(
this
.
_notificationInProgress
)
{
this
.
_log
.
trace
(
"
_shouldNotify
-
User
not
notified
notification
already
in
progress
.
"
)
;
return
false
;
}
return
true
;
}
_showInfobar
(
)
{
if
(
!
this
.
_shouldNotify
(
)
)
{
return
;
}
this
.
_log
.
trace
(
"
_showInfobar
-
User
not
notified
notifying
now
.
"
)
;
this
.
_notificationInProgress
=
true
;
let
request
=
new
NotifyPolicyRequest
(
this
.
_log
)
;
Observers
.
notify
(
"
datareporting
:
notify
-
data
-
policy
:
request
"
request
)
;
}
_userNotified
(
)
{
this
.
_log
.
trace
(
"
_userNotified
"
)
;
this
.
_recordNotificationData
(
)
;
TelemetrySend
.
notifyCanUpload
(
)
;
}
_recordNotificationData
(
)
{
this
.
_log
.
trace
(
"
_recordNotificationData
"
)
;
this
.
dataSubmissionPolicyNotifiedDate
=
Policy
.
now
(
)
;
this
.
dataSubmissionPolicyAcceptedVersion
=
this
.
currentPolicyVersion
;
this
.
_notificationInProgress
=
false
;
}
_openFirstRunPage
(
)
{
if
(
!
this
.
_shouldNotify
(
)
)
{
return
false
;
}
let
firstRunPolicyURL
=
Services
.
prefs
.
getStringPref
(
TelemetryUtils
.
Preferences
.
FirstRunURL
"
"
)
;
if
(
!
firstRunPolicyURL
)
{
return
false
;
}
firstRunPolicyURL
=
Services
.
urlFormatter
.
formatURL
(
firstRunPolicyURL
)
;
let
win
;
try
{
const
{
BrowserWindowTracker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
{
}
)
;
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
}
catch
(
e
)
{
}
if
(
!
win
)
{
this
.
_log
.
info
(
"
Couldn
'
t
find
browser
window
to
open
first
-
run
page
.
Falling
back
to
infobar
.
"
)
;
return
false
;
}
let
tab
;
let
progressListener
=
{
}
;
progressListener
.
onStateChange
=
(
aBrowser
aWebProgress
aRequest
aStateFlags
aStatus
)
=
>
{
if
(
aWebProgress
.
isTopLevel
&
&
tab
&
&
tab
.
linkedBrowser
=
=
aBrowser
&
&
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
)
{
let
uri
=
aBrowser
.
documentURI
;
if
(
uri
&
&
!
/
^
about
:
(
blank
|
neterror
|
certerror
|
blocked
)
/
.
test
(
uri
.
spec
)
)
{
this
.
_userNotified
(
)
;
}
else
{
this
.
_log
.
info
(
"
Failed
to
load
first
-
run
page
.
Falling
back
to
infobar
.
"
)
;
this
.
_showInfobar
(
)
;
}
removeListeners
(
)
;
}
}
;
let
removeListeners
=
(
)
=
>
{
win
.
removeEventListener
(
"
unload
"
removeListeners
)
;
win
.
gBrowser
.
removeTabsProgressListener
(
progressListener
)
;
}
;
win
.
addEventListener
(
"
unload
"
removeListeners
)
;
win
.
gBrowser
.
addTabsProgressListener
(
progressListener
)
;
tab
=
win
.
gBrowser
.
loadOneTab
(
firstRunPolicyURL
{
inBackground
:
true
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
return
true
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
!
=
"
sessionstore
-
windows
-
restored
"
)
{
return
;
}
this
.
_isFirstRun
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
FirstRun
true
)
;
if
(
this
.
_isFirstRun
)
{
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
FirstRun
false
)
;
try
{
if
(
this
.
_openFirstRunPage
(
)
)
{
return
;
}
}
catch
(
e
)
{
this
.
_log
.
error
(
"
Failed
to
open
privacy
policy
tab
:
"
+
e
)
;
}
}
const
delay
=
this
.
_isFirstRun
?
NOTIFICATION_DELAY_FIRST_RUN_MSEC
:
NOTIFICATION_DELAY_NEXT_RUNS_MSEC
;
this
.
_startupNotificationTimerId
=
Policy
.
setShowInfobarTimeout
(
(
)
=
>
this
.
_showInfobar
(
)
delay
)
;
}
}
;
