"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetryStorage
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
this
)
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
LOGGER_PREFIX
=
"
TelemetryStorage
:
:
"
;
const
Telemetry
=
Services
.
telemetry
;
const
Utils
=
TelemetryUtils
;
const
DATAREPORTING_DIR
=
"
datareporting
"
;
const
PINGS_ARCHIVE_DIR
=
"
archived
"
;
const
ABORTED_SESSION_FILE_NAME
=
"
aborted
-
session
-
ping
"
;
const
DELETION_PING_FILE_NAME
=
"
pending
-
deletion
-
ping
"
;
const
SESSION_STATE_FILE_NAME
=
"
session
-
state
.
json
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gDataReportingDir
"
function
(
)
{
return
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
DATAREPORTING_DIR
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gPingsArchivePath
"
function
(
)
{
return
OS
.
Path
.
join
(
gDataReportingDir
PINGS_ARCHIVE_DIR
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gAbortedSessionFilePath
"
function
(
)
{
return
OS
.
Path
.
join
(
gDataReportingDir
ABORTED_SESSION_FILE_NAME
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gDeletionPingFilePath
"
function
(
)
{
return
OS
.
Path
.
join
(
gDataReportingDir
DELETION_PING_FILE_NAME
)
;
}
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CommonUtils
"
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryHealthPing
"
"
resource
:
/
/
gre
/
modules
/
TelemetryHealthPing
.
jsm
"
)
;
const
MAX_ARCHIVED_PINGS_RETENTION_MS
=
60
*
24
*
60
*
60
*
1000
;
const
ARCHIVE_QUOTA_BYTES
=
120
*
1024
*
1024
;
const
PENDING_PINGS_QUOTA_BYTES_DESKTOP
=
15
*
1024
*
1024
;
const
PENDING_PINGS_QUOTA_BYTES_MOBILE
=
1024
*
1024
;
const
PING_FILE_MAXIMUM_SIZE_BYTES
=
1024
*
1024
;
const
ARCHIVE_SIZE_PROBE_SPECIAL_VALUE
=
300
;
const
PENDING_PINGS_SIZE_PROBE_SPECIAL_VALUE
=
17
;
const
UUID_REGEX
=
/
^
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
/
i
;
function
PingReadError
(
message
=
"
Error
reading
the
ping
file
"
becauseNoSuchFile
=
false
)
{
Error
.
call
(
this
message
)
;
let
error
=
new
Error
(
)
;
this
.
name
=
"
PingReadError
"
;
this
.
message
=
message
;
this
.
stack
=
error
.
stack
;
this
.
becauseNoSuchFile
=
becauseNoSuchFile
;
}
PingReadError
.
prototype
=
Object
.
create
(
Error
.
prototype
)
;
PingReadError
.
prototype
.
constructor
=
PingReadError
;
function
PingParseError
(
message
=
"
Error
parsing
ping
content
"
)
{
Error
.
call
(
this
message
)
;
let
error
=
new
Error
(
)
;
this
.
name
=
"
PingParseError
"
;
this
.
message
=
message
;
this
.
stack
=
error
.
stack
;
}
PingParseError
.
prototype
=
Object
.
create
(
Error
.
prototype
)
;
PingParseError
.
prototype
.
constructor
=
PingParseError
;
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
getArchiveQuota
:
(
)
=
>
ARCHIVE_QUOTA_BYTES
getPendingPingsQuota
:
(
)
=
>
(
AppConstants
.
platform
=
=
"
android
"
)
?
PENDING_PINGS_QUOTA_BYTES_MOBILE
:
PENDING_PINGS_QUOTA_BYTES_DESKTOP
}
;
function
waitForAll
(
it
)
{
let
dummy
=
(
)
=
>
{
}
;
let
promises
=
Array
.
from
(
it
p
=
>
p
.
catch
(
dummy
)
)
;
return
Promise
.
all
(
promises
)
;
}
function
internString
(
str
)
{
return
Symbol
.
keyFor
(
Symbol
.
for
(
str
)
)
;
}
var
TelemetryStorage
=
{
get
pingDirectoryPath
(
)
{
return
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
saved
-
telemetry
-
pings
"
)
;
}
get
MAXIMUM_PING_SIZE
(
)
{
return
PING_FILE_MAXIMUM_SIZE_BYTES
;
}
shutdown
(
)
{
return
TelemetryStorageImpl
.
shutdown
(
)
;
}
saveArchivedPing
(
ping
)
{
return
TelemetryStorageImpl
.
saveArchivedPing
(
ping
)
;
}
loadArchivedPing
(
id
)
{
return
TelemetryStorageImpl
.
loadArchivedPing
(
id
)
;
}
removeArchivedPing
(
id
timestampCreated
type
)
{
return
TelemetryStorageImpl
.
_removeArchivedPing
(
id
timestampCreated
type
)
;
}
loadArchivedPingList
(
)
{
return
TelemetryStorageImpl
.
loadArchivedPingList
(
)
;
}
runCleanPingArchiveTask
(
)
{
return
TelemetryStorageImpl
.
runCleanPingArchiveTask
(
)
;
}
runEnforcePendingPingsQuotaTask
(
)
{
return
TelemetryStorageImpl
.
runEnforcePendingPingsQuotaTask
(
)
;
}
runRemovePendingPingsTask
(
)
{
return
TelemetryStorageImpl
.
runRemovePendingPingsTask
(
)
;
}
reset
(
)
{
return
TelemetryStorageImpl
.
reset
(
)
;
}
testCleanupTaskPromise
(
)
{
return
(
TelemetryStorageImpl
.
_cleanArchiveTask
|
|
Promise
.
resolve
(
)
)
;
}
testPendingQuotaTaskPromise
(
)
{
return
(
TelemetryStorageImpl
.
_enforcePendingPingsQuotaTask
|
|
Promise
.
resolve
(
)
)
;
}
savePendingPing
(
ping
)
{
return
TelemetryStorageImpl
.
savePendingPing
(
ping
)
;
}
saveSessionData
(
sessionData
)
{
return
TelemetryStorageImpl
.
saveSessionData
(
sessionData
)
;
}
loadSessionData
(
)
{
return
TelemetryStorageImpl
.
loadSessionData
(
)
;
}
loadPendingPing
(
id
)
{
return
TelemetryStorageImpl
.
loadPendingPing
(
id
)
;
}
removePendingPing
(
id
)
{
return
TelemetryStorageImpl
.
removePendingPing
(
id
)
;
}
loadPendingPingList
(
)
{
return
TelemetryStorageImpl
.
loadPendingPingList
(
)
;
}
getPendingPingList
(
)
{
return
TelemetryStorageImpl
.
getPendingPingList
(
)
;
}
saveAbortedSessionPing
(
ping
)
{
return
TelemetryStorageImpl
.
saveAbortedSessionPing
(
ping
)
;
}
loadAbortedSessionPing
(
)
{
return
TelemetryStorageImpl
.
loadAbortedSessionPing
(
)
;
}
saveDeletionPing
(
ping
)
{
return
TelemetryStorageImpl
.
saveDeletionPing
(
ping
)
;
}
removeDeletionPing
(
)
{
return
TelemetryStorageImpl
.
removeDeletionPing
(
)
;
}
isDeletionPing
(
aPingId
)
{
return
TelemetryStorageImpl
.
isDeletionPing
(
aPingId
)
;
}
removeAbortedSessionPing
(
)
{
return
TelemetryStorageImpl
.
removeAbortedSessionPing
(
)
;
}
savePingToFile
(
ping
file
overwrite
)
{
return
TelemetryStorageImpl
.
savePingToFile
(
ping
file
overwrite
)
;
}
savePing
(
ping
overwrite
)
{
return
TelemetryStorageImpl
.
savePing
(
ping
overwrite
)
;
}
addPendingPing
(
pingData
)
{
return
TelemetryStorageImpl
.
addPendingPing
(
pingData
)
;
}
cleanupPingFile
(
ping
)
{
return
TelemetryStorageImpl
.
cleanupPingFile
(
ping
)
;
}
async
loadPingFile
(
aFilePath
)
{
return
TelemetryStorageImpl
.
loadPingFile
(
aFilePath
)
;
}
removeFHRDatabase
(
)
{
return
TelemetryStorageImpl
.
removeFHRDatabase
(
)
;
}
_testGetArchivedPingPath
(
aPingId
aDate
aType
)
{
return
getArchivedPingPath
(
aPingId
aDate
aType
)
;
}
_testGetArchivedPingDataFromFileName
(
aFileName
)
{
return
TelemetryStorageImpl
.
_getArchivedPingDataFromFileName
(
aFileName
)
;
}
testClearPendingPings
(
)
{
return
TelemetryStorageImpl
.
runRemovePendingPingsTask
(
)
;
}
}
;
function
SaveSerializer
(
)
{
this
.
_queuedOperations
=
[
]
;
this
.
_queuedInProgress
=
false
;
this
.
_log
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
)
;
}
SaveSerializer
.
prototype
=
{
enqueueTask
(
aFunction
)
{
let
promise
=
new
Promise
(
(
resolve
reject
)
=
>
this
.
_queuedOperations
.
push
(
[
aFunction
resolve
reject
]
)
)
;
if
(
this
.
_queuedOperations
.
length
=
=
1
)
{
this
.
_popAndPerformQueuedOperation
(
)
;
}
return
promise
;
}
flushTasks
(
)
{
let
dummyTask
=
(
)
=
>
new
Promise
(
resolve
=
>
resolve
(
)
)
;
return
this
.
enqueueTask
(
dummyTask
)
;
}
_popAndPerformQueuedOperation
(
)
{
if
(
!
this
.
_queuedOperations
.
length
|
|
this
.
_queuedInProgress
)
{
return
;
}
this
.
_log
.
trace
(
"
_popAndPerformQueuedOperation
-
Performing
queued
operation
.
"
)
;
let
[
func
resolve
reject
]
=
this
.
_queuedOperations
.
shift
(
)
;
let
promise
;
try
{
this
.
_queuedInProgress
=
true
;
promise
=
func
(
)
;
}
catch
(
ex
)
{
this
.
_log
.
warn
(
"
_popAndPerformQueuedOperation
-
Queued
operation
threw
during
execution
.
"
ex
)
;
this
.
_queuedInProgress
=
false
;
reject
(
ex
)
;
this
.
_popAndPerformQueuedOperation
(
)
;
return
;
}
if
(
!
promise
|
|
typeof
(
promise
.
then
)
!
=
"
function
"
)
{
let
msg
=
"
Queued
operation
did
not
return
a
promise
:
"
+
func
;
this
.
_log
.
warn
(
"
_popAndPerformQueuedOperation
-
"
+
msg
)
;
this
.
_queuedInProgress
=
false
;
reject
(
new
Error
(
msg
)
)
;
this
.
_popAndPerformQueuedOperation
(
)
;
return
;
}
promise
.
then
(
result
=
>
{
this
.
_queuedInProgress
=
false
;
resolve
(
result
)
;
this
.
_popAndPerformQueuedOperation
(
)
;
}
error
=
>
{
this
.
_log
.
warn
(
"
_popAndPerformQueuedOperation
-
Failure
when
performing
queued
operation
.
"
error
)
;
this
.
_queuedInProgress
=
false
;
reject
(
error
)
;
this
.
_popAndPerformQueuedOperation
(
)
;
}
)
;
}
}
;
var
TelemetryStorageImpl
=
{
_logger
:
null
_abortedSessionSerializer
:
new
SaveSerializer
(
)
_deletionPingSerializer
:
new
SaveSerializer
(
)
_stateSaveSerializer
:
new
SaveSerializer
(
)
_archivedPings
:
new
Map
(
)
_activelyArchiving
:
new
Set
(
)
_scanArchiveTask
:
null
_cleanArchiveTask
:
null
_scannedArchiveDirectory
:
false
_removePendingPingsTask
:
null
_activePendingPingSaves
:
new
Set
(
)
_pendingPings
:
new
Map
(
)
_enforcePendingPingsQuotaTask
:
null
_shutdown
:
false
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
)
;
}
return
this
.
_logger
;
}
async
shutdown
(
)
{
this
.
_shutdown
=
true
;
await
this
.
_abortedSessionSerializer
.
flushTasks
(
)
.
catch
(
ex
=
>
{
this
.
_log
.
error
(
"
shutdown
-
failed
to
flush
aborted
-
session
writes
"
ex
)
;
}
)
;
await
this
.
_deletionPingSerializer
.
flushTasks
(
)
.
catch
(
ex
=
>
{
this
.
_log
.
error
(
"
shutdown
-
failed
to
flush
deletion
ping
writes
"
ex
)
;
}
)
;
if
(
this
.
_cleanArchiveTask
)
{
await
this
.
_cleanArchiveTask
.
catch
(
ex
=
>
{
this
.
_log
.
error
(
"
shutdown
-
the
archive
cleaning
task
failed
"
ex
)
;
}
)
;
}
if
(
this
.
_enforcePendingPingsQuotaTask
)
{
await
this
.
_enforcePendingPingsQuotaTask
.
catch
(
ex
=
>
{
this
.
_log
.
error
(
"
shutdown
-
the
pending
pings
quota
task
failed
"
ex
)
;
}
)
;
}
if
(
this
.
_removePendingPingsTask
)
{
await
this
.
_removePendingPingsTask
.
catch
(
ex
=
>
{
this
.
_log
.
error
(
"
shutdown
-
the
pending
pings
removal
task
failed
"
ex
)
;
}
)
;
}
await
this
.
promisePendingPingSaves
(
)
;
}
saveArchivedPing
(
ping
)
{
let
promise
=
this
.
_saveArchivedPingTask
(
ping
)
;
this
.
_activelyArchiving
.
add
(
promise
)
;
promise
.
then
(
(
r
)
=
>
{
this
.
_activelyArchiving
.
delete
(
promise
)
;
}
(
e
)
=
>
{
this
.
_activelyArchiving
.
delete
(
promise
)
;
}
)
;
return
promise
;
}
async
_saveArchivedPingTask
(
ping
)
{
const
creationDate
=
new
Date
(
ping
.
creationDate
)
;
if
(
this
.
_archivedPings
.
has
(
ping
.
id
)
)
{
const
data
=
this
.
_archivedPings
.
get
(
ping
.
id
)
;
if
(
data
.
timestampCreated
>
creationDate
.
getTime
(
)
)
{
this
.
_log
.
error
(
"
saveArchivedPing
-
trying
to
overwrite
newer
ping
with
the
same
id
"
)
;
return
Promise
.
reject
(
new
Error
(
"
trying
to
overwrite
newer
ping
with
the
same
id
"
)
)
;
}
this
.
_log
.
warn
(
"
saveArchivedPing
-
overwriting
older
ping
with
the
same
id
"
)
;
}
const
filePath
=
getArchivedPingPath
(
ping
.
id
creationDate
ping
.
type
)
+
"
lz4
"
;
await
OS
.
File
.
makeDir
(
OS
.
Path
.
dirname
(
filePath
)
{
ignoreExisting
:
true
from
:
OS
.
Constants
.
Path
.
profileDir
}
)
;
await
this
.
savePingToFile
(
ping
filePath
true
true
)
;
this
.
_archivedPings
.
set
(
ping
.
id
{
timestampCreated
:
creationDate
.
getTime
(
)
type
:
internString
(
ping
.
type
)
}
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_ARCHIVE_SESSION_PING_COUNT
"
)
.
add
(
)
;
return
undefined
;
}
async
loadArchivedPing
(
id
)
{
let
idAsObject
=
{
id
}
;
TelemetryStopwatch
.
start
(
"
TELEMETRY_ARCHIVE_LOAD_MS
"
idAsObject
)
;
const
data
=
this
.
_archivedPings
.
get
(
id
)
;
if
(
!
data
)
{
TelemetryStopwatch
.
cancel
(
"
TELEMETRY_ARCHIVE_LOAD_MS
"
idAsObject
)
;
this
.
_log
.
trace
(
"
loadArchivedPing
-
no
ping
with
id
:
"
+
id
)
;
return
Promise
.
reject
(
new
Error
(
"
TelemetryStorage
.
loadArchivedPing
-
no
ping
with
id
"
+
id
)
)
;
}
const
path
=
getArchivedPingPath
(
id
new
Date
(
data
.
timestampCreated
)
data
.
type
)
;
const
pathCompressed
=
path
+
"
lz4
"
;
let
checkSize
=
async
function
(
path
)
{
const
fileSize
=
(
await
OS
.
File
.
stat
(
path
)
)
.
size
;
if
(
fileSize
>
PING_FILE_MAXIMUM_SIZE_BYTES
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_DISCARDED_ARCHIVED_PINGS_SIZE_MB
"
)
.
add
(
Math
.
floor
(
fileSize
/
1024
/
1024
)
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_PING_SIZE_EXCEEDED_ARCHIVED
"
)
.
add
(
)
;
TelemetryStopwatch
.
cancel
(
"
TELEMETRY_ARCHIVE_LOAD_MS
"
idAsObject
)
;
await
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
throw
new
Error
(
"
loadArchivedPing
-
exceeded
the
maximum
ping
size
:
"
+
fileSize
)
;
}
}
;
let
ping
;
try
{
this
.
_log
.
trace
(
"
loadArchivedPing
-
loading
ping
from
:
"
+
pathCompressed
)
;
await
checkSize
(
pathCompressed
)
;
ping
=
await
this
.
loadPingFile
(
pathCompressed
true
)
;
}
catch
(
ex
)
{
if
(
!
ex
.
becauseNoSuchFile
)
{
TelemetryStopwatch
.
cancel
(
"
TELEMETRY_ARCHIVE_LOAD_MS
"
idAsObject
)
;
throw
ex
;
}
this
.
_log
.
trace
(
"
loadArchivedPing
-
compressed
ping
not
found
loading
:
"
+
path
)
;
await
checkSize
(
path
)
;
ping
=
await
this
.
loadPingFile
(
path
false
)
;
}
TelemetryStopwatch
.
finish
(
"
TELEMETRY_ARCHIVE_LOAD_MS
"
idAsObject
)
;
return
ping
;
}
saveSessionData
(
sessionData
)
{
return
this
.
_stateSaveSerializer
.
enqueueTask
(
(
)
=
>
this
.
_saveSessionData
(
sessionData
)
)
;
}
async
_saveSessionData
(
sessionData
)
{
let
dataDir
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
DATAREPORTING_DIR
)
;
await
OS
.
File
.
makeDir
(
dataDir
)
;
let
filePath
=
OS
.
Path
.
join
(
gDataReportingDir
SESSION_STATE_FILE_NAME
)
;
try
{
await
CommonUtils
.
writeJSON
(
sessionData
filePath
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
_saveSessionData
-
Failed
to
write
session
data
to
"
+
filePath
e
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_SESSIONDATA_FAILED_SAVE
"
)
.
add
(
1
)
;
}
}
loadSessionData
(
)
{
return
this
.
_stateSaveSerializer
.
enqueueTask
(
(
)
=
>
this
.
_loadSessionData
(
)
)
;
}
async
_loadSessionData
(
)
{
const
dataFile
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
DATAREPORTING_DIR
SESSION_STATE_FILE_NAME
)
;
let
content
;
try
{
content
=
await
OS
.
File
.
read
(
dataFile
{
encoding
:
"
utf
-
8
"
}
)
;
}
catch
(
ex
)
{
this
.
_log
.
info
(
"
_loadSessionData
-
can
not
load
session
data
file
"
ex
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_SESSIONDATA_FAILED_LOAD
"
)
.
add
(
1
)
;
return
null
;
}
let
data
;
try
{
data
=
JSON
.
parse
(
content
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_loadSessionData
-
failed
to
parse
session
data
"
ex
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_SESSIONDATA_FAILED_PARSE
"
)
.
add
(
1
)
;
return
null
;
}
return
data
;
}
async
_removeArchivedPing
(
id
timestampCreated
type
)
{
this
.
_log
.
trace
(
"
_removeArchivedPing
-
id
:
"
+
id
+
"
timestampCreated
:
"
+
timestampCreated
+
"
type
:
"
+
type
)
;
const
path
=
getArchivedPingPath
(
id
new
Date
(
timestampCreated
)
type
)
;
const
pathCompressed
=
path
+
"
lz4
"
;
this
.
_log
.
trace
(
"
_removeArchivedPing
-
removing
ping
from
:
"
+
path
)
;
await
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
await
OS
.
File
.
remove
(
pathCompressed
{
ignoreAbsent
:
true
}
)
;
this
.
_archivedPings
.
delete
(
id
)
;
}
runCleanPingArchiveTask
(
)
{
if
(
this
.
_cleanArchiveTask
)
{
return
this
.
_cleanArchiveTask
;
}
let
clear
=
(
)
=
>
this
.
_cleanArchiveTask
=
null
;
this
.
_cleanArchiveTask
=
this
.
_cleanArchive
(
)
.
then
(
clear
clear
)
;
return
this
.
_cleanArchiveTask
;
}
async
_purgeOldPings
(
)
{
this
.
_log
.
trace
(
"
_purgeOldPings
"
)
;
const
nowDate
=
Policy
.
now
(
)
;
const
startTimeStamp
=
nowDate
.
getTime
(
)
;
let
dirIterator
=
new
OS
.
File
.
DirectoryIterator
(
gPingsArchivePath
)
;
let
subdirs
=
(
await
dirIterator
.
nextBatch
(
)
)
.
filter
(
e
=
>
e
.
isDir
)
;
dirIterator
.
close
(
)
;
let
newestRemovedMonthTimestamp
=
null
;
let
evictedDirsCount
=
0
;
let
maxDirAgeInMonths
=
0
;
for
(
let
dir
of
subdirs
)
{
if
(
this
.
_shutdown
)
{
this
.
_log
.
trace
(
"
_purgeOldPings
-
Terminating
the
clean
up
task
due
to
shutdown
"
)
;
return
;
}
if
(
!
isValidArchiveDir
(
dir
.
name
)
)
{
this
.
_log
.
warn
(
"
_purgeOldPings
-
skipping
invalidly
named
subdirectory
"
+
dir
.
path
)
;
continue
;
}
const
archiveDate
=
getDateFromArchiveDir
(
dir
.
name
)
;
if
(
!
archiveDate
)
{
this
.
_log
.
warn
(
"
_purgeOldPings
-
skipping
invalid
subdirectory
date
"
+
dir
.
path
)
;
continue
;
}
if
(
(
startTimeStamp
-
archiveDate
.
getTime
(
)
)
>
MAX_ARCHIVED_PINGS_RETENTION_MS
)
{
try
{
await
OS
.
File
.
removeDir
(
dir
.
path
)
;
evictedDirsCount
+
+
;
newestRemovedMonthTimestamp
=
Math
.
max
(
archiveDate
newestRemovedMonthTimestamp
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_purgeOldPings
-
Unable
to
remove
"
+
dir
.
path
ex
)
;
}
}
else
{
const
dirAgeInMonths
=
Utils
.
getElapsedTimeInMonths
(
archiveDate
nowDate
)
;
maxDirAgeInMonths
=
Math
.
max
(
dirAgeInMonths
maxDirAgeInMonths
)
;
}
}
await
this
.
loadArchivedPingList
(
)
;
if
(
newestRemovedMonthTimestamp
)
{
for
(
let
[
id
info
]
of
this
.
_archivedPings
)
{
const
timestampCreated
=
new
Date
(
info
.
timestampCreated
)
;
if
(
timestampCreated
.
getTime
(
)
>
newestRemovedMonthTimestamp
)
{
continue
;
}
this
.
_archivedPings
.
delete
(
id
)
;
}
}
const
endTimeStamp
=
Policy
.
now
(
)
.
getTime
(
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_ARCHIVE_EVICTED_OLD_DIRS
"
)
.
add
(
evictedDirsCount
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_ARCHIVE_EVICTING_DIRS_MS
"
)
.
add
(
Math
.
ceil
(
endTimeStamp
-
startTimeStamp
)
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_ARCHIVE_OLDEST_DIRECTORY_AGE
"
)
.
add
(
maxDirAgeInMonths
)
;
}
async
_enforceArchiveQuota
(
)
{
this
.
_log
.
trace
(
"
_enforceArchiveQuota
"
)
;
let
startTimeStamp
=
Policy
.
now
(
)
.
getTime
(
)
;
let
pingList
=
Array
.
from
(
this
.
_archivedPings
p
=
>
(
{
id
:
p
[
0
]
timestampCreated
:
p
[
1
]
.
timestampCreated
type
:
p
[
1
]
.
type
}
)
)
;
pingList
.
sort
(
(
a
b
)
=
>
b
.
timestampCreated
-
a
.
timestampCreated
)
;
const
SAFE_QUOTA
=
Policy
.
getArchiveQuota
(
)
*
0
.
9
;
let
lastPingIndexToKeep
=
null
;
let
archiveSizeInBytes
=
0
;
for
(
let
i
=
0
;
i
<
pingList
.
length
;
i
+
+
)
{
if
(
this
.
_shutdown
)
{
this
.
_log
.
trace
(
"
_enforceArchiveQuota
-
Terminating
the
clean
up
task
due
to
shutdown
"
)
;
return
;
}
let
ping
=
pingList
[
i
]
;
const
fileSize
=
await
getArchivedPingSize
(
ping
.
id
new
Date
(
ping
.
timestampCreated
)
ping
.
type
)
;
if
(
!
fileSize
)
{
this
.
_log
.
warn
(
"
_enforceArchiveQuota
-
Unable
to
find
the
size
of
ping
"
+
ping
.
id
)
;
continue
;
}
if
(
fileSize
>
PING_FILE_MAXIMUM_SIZE_BYTES
)
{
this
.
_log
.
error
(
"
_enforceArchiveQuota
-
removing
file
exceeding
size
limit
size
:
"
+
fileSize
)
;
await
this
.
_removeArchivedPing
(
ping
.
id
ping
.
timestampCreated
ping
.
type
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
_enforceArchiveQuota
-
failed
to
remove
archived
ping
"
+
ping
.
id
)
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_DISCARDED_ARCHIVED_PINGS_SIZE_MB
"
)
.
add
(
Math
.
floor
(
fileSize
/
1024
/
1024
)
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_PING_SIZE_EXCEEDED_ARCHIVED
"
)
.
add
(
)
;
continue
;
}
archiveSizeInBytes
+
=
fileSize
;
if
(
archiveSizeInBytes
<
SAFE_QUOTA
)
{
lastPingIndexToKeep
=
i
;
}
else
if
(
archiveSizeInBytes
>
Policy
.
getArchiveQuota
(
)
)
{
break
;
}
}
Telemetry
.
getHistogramById
(
"
TELEMETRY_ARCHIVE_CHECKING_OVER_QUOTA_MS
"
)
.
add
(
Math
.
round
(
Policy
.
now
(
)
.
getTime
(
)
-
startTimeStamp
)
)
;
let
submitProbes
=
(
sizeInMB
evictedPings
elapsedMs
)
=
>
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_ARCHIVE_SIZE_MB
"
)
.
add
(
sizeInMB
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_ARCHIVE_EVICTED_OVER_QUOTA
"
)
.
add
(
evictedPings
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_ARCHIVE_EVICTING_OVER_QUOTA_MS
"
)
.
add
(
elapsedMs
)
;
}
;
if
(
archiveSizeInBytes
<
Policy
.
getArchiveQuota
(
)
)
{
submitProbes
(
Math
.
round
(
archiveSizeInBytes
/
1024
/
1024
)
0
0
)
;
return
;
}
this
.
_log
.
info
(
"
_enforceArchiveQuota
-
archive
size
:
"
+
archiveSizeInBytes
+
"
bytes
"
+
"
safety
quota
:
"
+
SAFE_QUOTA
+
"
bytes
"
)
;
startTimeStamp
=
Policy
.
now
(
)
.
getTime
(
)
;
let
pingsToPurge
=
pingList
.
slice
(
lastPingIndexToKeep
+
1
)
;
for
(
let
ping
of
pingsToPurge
)
{
if
(
this
.
_shutdown
)
{
this
.
_log
.
trace
(
"
_enforceArchiveQuota
-
Terminating
the
clean
up
task
due
to
shutdown
"
)
;
return
;
}
await
this
.
_removeArchivedPing
(
ping
.
id
ping
.
timestampCreated
ping
.
type
)
;
}
const
endTimeStamp
=
Policy
.
now
(
)
.
getTime
(
)
;
submitProbes
(
ARCHIVE_SIZE_PROBE_SPECIAL_VALUE
pingsToPurge
.
length
Math
.
ceil
(
endTimeStamp
-
startTimeStamp
)
)
;
}
async
_cleanArchive
(
)
{
this
.
_log
.
trace
(
"
cleanArchiveTask
"
)
;
if
(
!
(
await
OS
.
File
.
exists
(
gPingsArchivePath
)
)
)
{
return
;
}
try
{
await
this
.
_purgeOldPings
(
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_cleanArchive
-
There
was
an
error
removing
old
directories
"
ex
)
;
}
await
this
.
_enforceArchiveQuota
(
)
;
}
async
runEnforcePendingPingsQuotaTask
(
)
{
if
(
this
.
_enforcePendingPingsQuotaTask
)
{
return
this
.
_enforcePendingPingsQuotaTask
;
}
try
{
this
.
_enforcePendingPingsQuotaTask
=
this
.
_enforcePendingPingsQuota
(
)
;
await
this
.
_enforcePendingPingsQuotaTask
;
}
finally
{
this
.
_enforcePendingPingsQuotaTask
=
null
;
}
return
undefined
;
}
async
_enforcePendingPingsQuota
(
)
{
this
.
_log
.
trace
(
"
_enforcePendingPingsQuota
"
)
;
let
startTimeStamp
=
Policy
.
now
(
)
.
getTime
(
)
;
let
pingList
=
Array
.
from
(
this
.
_pendingPings
p
=
>
(
{
id
:
p
[
0
]
lastModificationDate
:
p
[
1
]
.
lastModificationDate
}
)
)
;
pingList
.
sort
(
(
a
b
)
=
>
b
.
lastModificationDate
-
a
.
lastModificationDate
)
;
const
SAFE_QUOTA
=
Policy
.
getPendingPingsQuota
(
)
*
0
.
9
;
let
lastPingIndexToKeep
=
null
;
let
pendingPingsSizeInBytes
=
0
;
for
(
let
i
=
0
;
i
<
pingList
.
length
;
i
+
+
)
{
if
(
this
.
_shutdown
)
{
this
.
_log
.
trace
(
"
_enforcePendingPingsQuota
-
Terminating
the
clean
up
task
due
to
shutdown
"
)
;
return
;
}
let
ping
=
pingList
[
i
]
;
const
fileSize
=
await
getPendingPingSize
(
ping
.
id
)
;
if
(
!
fileSize
)
{
this
.
_log
.
warn
(
"
_enforcePendingPingsQuota
-
Unable
to
find
the
size
of
ping
"
+
ping
.
id
)
;
continue
;
}
pendingPingsSizeInBytes
+
=
fileSize
;
if
(
pendingPingsSizeInBytes
<
SAFE_QUOTA
)
{
lastPingIndexToKeep
=
i
;
}
else
if
(
pendingPingsSizeInBytes
>
Policy
.
getPendingPingsQuota
(
)
)
{
break
;
}
}
Telemetry
.
getHistogramById
(
"
TELEMETRY_PENDING_CHECKING_OVER_QUOTA_MS
"
)
.
add
(
Math
.
round
(
Policy
.
now
(
)
.
getTime
(
)
-
startTimeStamp
)
)
;
let
recordHistograms
=
(
sizeInMB
evictedPings
elapsedMs
)
=
>
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_PENDING_PINGS_SIZE_MB
"
)
.
add
(
sizeInMB
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_PENDING_PINGS_EVICTED_OVER_QUOTA
"
)
.
add
(
evictedPings
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_PENDING_EVICTING_OVER_QUOTA_MS
"
)
.
add
(
elapsedMs
)
;
}
;
if
(
pendingPingsSizeInBytes
<
Policy
.
getPendingPingsQuota
(
)
)
{
recordHistograms
(
Math
.
round
(
pendingPingsSizeInBytes
/
1024
/
1024
)
0
0
)
;
return
;
}
this
.
_log
.
info
(
"
_enforcePendingPingsQuota
-
size
:
"
+
pendingPingsSizeInBytes
+
"
bytes
"
+
"
safety
quota
:
"
+
SAFE_QUOTA
+
"
bytes
"
)
;
startTimeStamp
=
Policy
.
now
(
)
.
getTime
(
)
;
let
pingsToPurge
=
pingList
.
slice
(
lastPingIndexToKeep
+
1
)
;
for
(
let
ping
of
pingsToPurge
)
{
if
(
this
.
_shutdown
)
{
this
.
_log
.
trace
(
"
_enforcePendingPingsQuota
-
Terminating
the
clean
up
task
due
to
shutdown
"
)
;
return
;
}
await
this
.
removePendingPing
(
ping
.
id
)
;
}
const
endTimeStamp
=
Policy
.
now
(
)
.
getTime
(
)
;
recordHistograms
(
PENDING_PINGS_SIZE_PROBE_SPECIAL_VALUE
pingsToPurge
.
length
Math
.
ceil
(
endTimeStamp
-
startTimeStamp
)
)
;
}
reset
(
)
{
this
.
_shutdown
=
false
;
this
.
_scannedArchiveDirectory
=
false
;
this
.
_archivedPings
=
new
Map
(
)
;
this
.
_scannedPendingDirectory
=
false
;
this
.
_pendingPings
=
new
Map
(
)
;
}
async
loadArchivedPingList
(
)
{
if
(
this
.
_scanArchiveTask
)
{
return
this
.
_scanArchiveTask
;
}
await
waitForAll
(
this
.
_activelyArchiving
)
;
if
(
this
.
_scannedArchiveDirectory
)
{
this
.
_log
.
trace
(
"
loadArchivedPingList
-
Archive
already
scanned
hitting
cache
.
"
)
;
return
this
.
_archivedPings
;
}
let
result
;
try
{
this
.
_scanArchiveTask
=
this
.
_scanArchive
(
)
;
result
=
await
this
.
_scanArchiveTask
;
}
finally
{
this
.
_scanArchiveTask
=
null
;
}
return
result
;
}
async
_scanArchive
(
)
{
this
.
_log
.
trace
(
"
_scanArchive
"
)
;
let
submitProbes
=
(
pingCount
dirCount
)
=
>
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_ARCHIVE_SCAN_PING_COUNT
"
)
.
add
(
pingCount
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_ARCHIVE_DIRECTORIES_COUNT
"
)
.
add
(
dirCount
)
;
}
;
if
(
!
(
await
OS
.
File
.
exists
(
gPingsArchivePath
)
)
)
{
submitProbes
(
0
0
)
;
return
new
Map
(
)
;
}
let
dirIterator
=
new
OS
.
File
.
DirectoryIterator
(
gPingsArchivePath
)
;
let
subdirs
=
(
await
dirIterator
.
nextBatch
(
)
)
.
filter
(
e
=
>
e
.
isDir
)
.
filter
(
e
=
>
isValidArchiveDir
(
e
.
name
)
)
;
dirIterator
.
close
(
)
;
for
(
let
dir
of
subdirs
)
{
this
.
_log
.
trace
(
"
_scanArchive
-
checking
in
subdir
:
"
+
dir
.
path
)
;
let
pingIterator
=
new
OS
.
File
.
DirectoryIterator
(
dir
.
path
)
;
let
pings
=
(
await
pingIterator
.
nextBatch
(
)
)
.
filter
(
e
=
>
!
e
.
isDir
)
;
pingIterator
.
close
(
)
;
for
(
let
p
of
pings
)
{
let
data
=
this
.
_getArchivedPingDataFromFileName
(
p
.
name
)
;
if
(
!
data
)
{
continue
;
}
if
(
this
.
_archivedPings
.
has
(
data
.
id
)
)
{
const
overwrite
=
data
.
timestamp
>
this
.
_archivedPings
.
get
(
data
.
id
)
.
timestampCreated
;
this
.
_log
.
warn
(
"
_scanArchive
-
have
seen
this
id
before
:
"
+
data
.
id
+
"
overwrite
:
"
+
overwrite
)
;
if
(
!
overwrite
)
{
continue
;
}
await
this
.
_removeArchivedPing
(
data
.
id
data
.
timestampCreated
data
.
type
)
.
catch
(
(
e
)
=
>
this
.
_log
.
warn
(
"
_scanArchive
-
failed
to
remove
ping
"
e
)
)
;
}
this
.
_archivedPings
.
set
(
data
.
id
{
timestampCreated
:
data
.
timestamp
type
:
internString
(
data
.
type
)
}
)
;
}
}
this
.
_scannedArchiveDirectory
=
true
;
submitProbes
(
this
.
_archivedPings
.
size
subdirs
.
length
)
;
return
this
.
_archivedPings
;
}
async
savePingToFile
(
ping
filePath
overwrite
compress
=
false
)
{
try
{
this
.
_log
.
trace
(
"
savePingToFile
-
path
:
"
+
filePath
)
;
let
pingString
=
JSON
.
stringify
(
ping
)
;
let
options
=
{
tmpPath
:
filePath
+
"
.
tmp
"
noOverwrite
:
!
overwrite
}
;
if
(
compress
)
{
options
.
compression
=
"
lz4
"
;
}
await
OS
.
File
.
writeAtomic
(
filePath
pingString
options
)
;
}
catch
(
e
)
{
if
(
!
e
.
becauseExists
)
{
throw
e
;
}
}
}
async
savePing
(
ping
overwrite
)
{
await
getPingDirectory
(
)
;
let
file
=
pingFilePath
(
ping
)
;
await
this
.
savePingToFile
(
ping
file
overwrite
)
;
return
file
;
}
addPendingPing
(
ping
)
{
return
this
.
savePendingPing
(
ping
)
;
}
cleanupPingFile
(
ping
)
{
return
OS
.
File
.
remove
(
pingFilePath
(
ping
)
)
;
}
savePendingPing
(
ping
)
{
let
p
=
this
.
savePing
(
ping
true
)
.
then
(
(
path
)
=
>
{
this
.
_pendingPings
.
set
(
ping
.
id
{
path
lastModificationDate
:
Policy
.
now
(
)
.
getTime
(
)
}
)
;
this
.
_log
.
trace
(
"
savePendingPing
-
saved
ping
with
id
"
+
ping
.
id
)
;
}
)
;
this
.
_trackPendingPingSaveTask
(
p
)
;
return
p
;
}
async
loadPendingPing
(
id
)
{
this
.
_log
.
trace
(
"
loadPendingPing
-
id
:
"
+
id
)
;
TelemetryStopwatch
.
start
(
"
TELEMETRY_PENDING_LOAD_MS
"
)
;
let
info
=
this
.
_pendingPings
.
get
(
id
)
;
if
(
!
info
)
{
TelemetryStopwatch
.
cancel
(
"
TELEMETRY_PENDING_LOAD_MS
"
)
;
this
.
_log
.
trace
(
"
loadPendingPing
-
unknown
id
"
+
id
)
;
throw
new
Error
(
"
TelemetryStorage
.
loadPendingPing
-
no
ping
with
id
"
+
id
)
;
}
let
fileSize
=
0
;
try
{
fileSize
=
(
await
OS
.
File
.
stat
(
info
.
path
)
)
.
size
;
}
catch
(
e
)
{
if
(
!
(
e
instanceof
OS
.
File
.
Error
)
|
|
!
e
.
becauseNoSuchFile
)
{
TelemetryStopwatch
.
cancel
(
"
TELEMETRY_PENDING_LOAD_MS
"
)
;
throw
e
;
}
}
if
(
fileSize
>
PING_FILE_MAXIMUM_SIZE_BYTES
)
{
await
this
.
removePendingPing
(
id
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_DISCARDED_PENDING_PINGS_SIZE_MB
"
)
.
add
(
Math
.
floor
(
fileSize
/
1024
/
1024
)
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_PING_SIZE_EXCEEDED_PENDING
"
)
.
add
(
)
;
TelemetryStopwatch
.
cancel
(
"
TELEMETRY_PENDING_LOAD_MS
"
)
;
TelemetryHealthPing
.
recordDiscardedPing
(
"
<
unknown
>
"
)
;
throw
new
Error
(
"
loadPendingPing
-
exceeded
the
maximum
ping
size
:
"
+
fileSize
)
;
}
let
ping
;
try
{
ping
=
await
this
.
loadPingFile
(
info
.
path
false
)
;
}
catch
(
e
)
{
if
(
e
instanceof
PingReadError
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_PENDING_LOAD_FAILURE_READ
"
)
.
add
(
)
;
}
else
if
(
e
instanceof
PingParseError
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_PENDING_LOAD_FAILURE_PARSE
"
)
.
add
(
)
;
}
TelemetryStopwatch
.
cancel
(
"
TELEMETRY_PENDING_LOAD_MS
"
)
;
this
.
_pendingPings
.
delete
(
id
)
;
throw
e
;
}
TelemetryStopwatch
.
finish
(
"
TELEMETRY_PENDING_LOAD_MS
"
)
;
return
ping
;
}
removePendingPing
(
id
)
{
let
info
=
this
.
_pendingPings
.
get
(
id
)
;
if
(
!
info
)
{
this
.
_log
.
trace
(
"
removePendingPing
-
unknown
id
"
+
id
)
;
return
Promise
.
resolve
(
)
;
}
this
.
_log
.
trace
(
"
removePendingPing
-
deleting
ping
with
id
:
"
+
id
+
"
path
:
"
+
info
.
path
)
;
this
.
_pendingPings
.
delete
(
id
)
;
return
OS
.
File
.
remove
(
info
.
path
)
.
catch
(
(
ex
)
=
>
this
.
_log
.
error
(
"
removePendingPing
-
failed
to
remove
ping
"
ex
)
)
;
}
_trackPendingPingSaveTask
(
promise
)
{
let
clear
=
(
)
=
>
this
.
_activePendingPingSaves
.
delete
(
promise
)
;
promise
.
then
(
clear
clear
)
;
this
.
_activePendingPingSaves
.
add
(
promise
)
;
}
promisePendingPingSaves
(
)
{
return
waitForAll
(
this
.
_activePendingPingSaves
)
;
}
async
runRemovePendingPingsTask
(
)
{
if
(
this
.
_removePendingPingsTask
)
{
return
this
.
_removePendingPingsTask
;
}
try
{
this
.
_removePendingPingsTask
=
this
.
removePendingPings
(
)
;
await
this
.
_removePendingPingsTask
;
}
finally
{
this
.
_removePendingPingsTask
=
null
;
}
return
undefined
;
}
async
removePendingPings
(
)
{
this
.
_log
.
trace
(
"
removePendingPings
-
removing
all
pending
pings
"
)
;
await
this
.
promisePendingPingSaves
(
)
;
const
directory
=
TelemetryStorage
.
pingDirectoryPath
;
let
iter
=
new
OS
.
File
.
DirectoryIterator
(
directory
)
;
try
{
if
(
!
(
await
iter
.
exists
(
)
)
)
{
this
.
_log
.
trace
(
"
removePendingPings
-
the
pending
pings
directory
doesn
'
t
exist
"
)
;
return
;
}
let
files
=
(
await
iter
.
nextBatch
(
)
)
.
filter
(
e
=
>
!
e
.
isDir
)
;
for
(
let
file
of
files
)
{
try
{
await
OS
.
File
.
remove
(
file
.
path
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
removePendingPings
-
failed
to
remove
file
"
+
file
.
path
ex
)
;
continue
;
}
}
}
finally
{
await
iter
.
close
(
)
;
}
}
async
_migrateAppDataPings
(
)
{
this
.
_log
.
trace
(
"
_migrateAppDataPings
"
)
;
if
(
!
OS
.
Constants
.
Path
.
userApplicationDataDir
)
{
this
.
_log
.
trace
(
"
_migrateAppDataPings
-
userApplicationDataDir
is
not
defined
.
Is
this
a
test
?
"
)
;
return
;
}
const
appDataPendingPings
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
userApplicationDataDir
"
Pending
Pings
"
)
;
let
iter
=
new
OS
.
File
.
DirectoryIterator
(
appDataPendingPings
)
;
try
{
if
(
!
(
await
iter
.
exists
(
)
)
)
{
this
.
_log
.
trace
(
"
_migrateAppDataPings
-
the
AppData
pending
pings
directory
doesn
'
t
exist
.
"
)
;
return
;
}
let
files
=
(
await
iter
.
nextBatch
(
)
)
.
filter
(
e
=
>
!
e
.
isDir
)
;
for
(
let
file
of
files
)
{
try
{
const
pingData
=
await
this
.
loadPingFile
(
file
.
path
)
;
await
TelemetryStorage
.
savePing
(
pingData
true
)
;
await
OS
.
File
.
remove
(
file
.
path
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_migrateAppDataPings
-
failed
to
remove
file
"
+
file
.
path
ex
)
;
continue
;
}
}
}
finally
{
await
iter
.
close
(
)
;
}
}
loadPendingPingList
(
)
{
if
(
this
.
_scanPendingPingsTask
)
{
return
this
.
_scanPendingPingsTask
;
}
if
(
this
.
_scannedPendingDirectory
)
{
this
.
_log
.
trace
(
"
loadPendingPingList
-
Pending
already
scanned
hitting
cache
.
"
)
;
return
Promise
.
resolve
(
this
.
_buildPingList
(
)
)
;
}
this
.
_scanPendingPingsTask
=
this
.
_scanPendingPings
(
)
.
then
(
pings
=
>
{
this
.
_scanPendingPingsTask
=
null
;
return
pings
;
}
ex
=
>
{
this
.
_scanPendingPingsTask
=
null
;
throw
ex
;
}
)
;
return
this
.
_scanPendingPingsTask
;
}
getPendingPingList
(
)
{
return
this
.
_buildPingList
(
)
;
}
async
_scanPendingPings
(
)
{
this
.
_log
.
trace
(
"
_scanPendingPings
"
)
;
await
this
.
_migrateAppDataPings
(
)
;
let
directory
=
TelemetryStorage
.
pingDirectoryPath
;
let
iter
=
new
OS
.
File
.
DirectoryIterator
(
directory
)
;
let
exists
=
await
iter
.
exists
(
)
;
try
{
if
(
!
exists
)
{
return
[
]
;
}
let
files
=
(
await
iter
.
nextBatch
(
)
)
.
filter
(
e
=
>
!
e
.
isDir
)
;
for
(
let
file
of
files
)
{
if
(
this
.
_shutdown
)
{
return
[
]
;
}
let
info
;
try
{
info
=
await
OS
.
File
.
stat
(
file
.
path
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_scanPendingPings
-
failed
to
stat
file
"
+
file
.
path
ex
)
;
continue
;
}
if
(
info
.
size
>
PING_FILE_MAXIMUM_SIZE_BYTES
)
{
this
.
_log
.
error
(
"
_scanPendingPings
-
removing
file
exceeding
size
limit
"
+
file
.
path
)
;
try
{
await
OS
.
File
.
remove
(
file
.
path
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_scanPendingPings
-
failed
to
remove
file
"
+
file
.
path
ex
)
;
}
finally
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_DISCARDED_PENDING_PINGS_SIZE_MB
"
)
.
add
(
Math
.
floor
(
info
.
size
/
1024
/
1024
)
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_PING_SIZE_EXCEEDED_PENDING
"
)
.
add
(
)
;
TelemetryHealthPing
.
recordDiscardedPing
(
"
<
unknown
>
"
)
;
}
continue
;
}
let
id
=
OS
.
Path
.
basename
(
file
.
path
)
;
if
(
!
UUID_REGEX
.
test
(
id
)
)
{
this
.
_log
.
trace
(
"
_scanPendingPings
-
filename
is
not
a
UUID
:
"
+
id
)
;
id
=
Utils
.
generateUUID
(
)
;
}
this
.
_pendingPings
.
set
(
id
{
path
:
file
.
path
lastModificationDate
:
info
.
lastModificationDate
.
getTime
(
)
}
)
;
}
}
finally
{
await
iter
.
close
(
)
;
}
if
(
await
OS
.
File
.
exists
(
gDeletionPingFilePath
)
)
{
this
.
_log
.
trace
(
"
_scanPendingPings
-
Adding
pending
deletion
ping
.
"
)
;
this
.
_pendingPings
.
set
(
Utils
.
generateUUID
(
)
{
path
:
gDeletionPingFilePath
lastModificationDate
:
Date
.
now
(
)
}
)
;
}
this
.
_scannedPendingDirectory
=
true
;
return
this
.
_buildPingList
(
)
;
}
_buildPingList
(
)
{
const
list
=
Array
.
from
(
this
.
_pendingPings
p
=
>
(
{
id
:
p
[
0
]
lastModificationDate
:
p
[
1
]
.
lastModificationDate
}
)
)
;
list
.
sort
(
(
a
b
)
=
>
b
.
lastModificationDate
-
a
.
lastModificationDate
)
;
return
list
;
}
async
loadPingFile
(
aFilePath
aCompressed
=
false
)
{
let
options
=
{
}
;
if
(
aCompressed
)
{
options
.
compression
=
"
lz4
"
;
}
let
array
;
try
{
array
=
await
OS
.
File
.
read
(
aFilePath
options
)
;
}
catch
(
e
)
{
this
.
_log
.
trace
(
"
loadPingfile
-
unreadable
ping
"
+
aFilePath
e
)
;
throw
new
PingReadError
(
e
.
message
e
.
becauseNoSuchFile
)
;
}
let
decoder
=
new
TextDecoder
(
)
;
let
string
=
decoder
.
decode
(
array
)
;
let
ping
;
try
{
ping
=
JSON
.
parse
(
string
)
;
}
catch
(
e
)
{
this
.
_log
.
trace
(
"
loadPingfile
-
unparseable
ping
"
+
aFilePath
e
)
;
await
OS
.
File
.
remove
(
aFilePath
)
.
catch
(
(
ex
)
=
>
{
this
.
_log
.
error
(
"
loadPingFile
-
failed
removing
unparseable
ping
file
"
ex
)
;
}
)
;
throw
new
PingParseError
(
e
.
message
)
;
}
return
ping
;
}
_getArchivedPingDataFromFileName
(
fileName
)
{
let
parts
=
fileName
.
split
(
"
.
"
)
;
if
(
parts
.
length
!
=
4
)
{
this
.
_log
.
trace
(
"
_getArchivedPingDataFromFileName
-
should
have
4
parts
"
)
;
return
null
;
}
let
[
timestamp
uuid
type
extension
]
=
parts
;
if
(
extension
!
=
"
json
"
&
&
extension
!
=
"
jsonlz4
"
)
{
this
.
_log
.
trace
(
"
_getArchivedPingDataFromFileName
-
should
have
'
json
'
or
'
jsonlz4
'
extension
"
)
;
return
null
;
}
timestamp
=
parseInt
(
timestamp
)
;
if
(
Number
.
isNaN
(
timestamp
)
)
{
this
.
_log
.
trace
(
"
_getArchivedPingDataFromFileName
-
should
have
a
valid
timestamp
"
)
;
return
null
;
}
if
(
!
UUID_REGEX
.
test
(
uuid
)
)
{
this
.
_log
.
trace
(
"
_getArchivedPingDataFromFileName
-
should
have
a
valid
id
"
)
;
return
null
;
}
const
typeRegex
=
/
^
[
a
-
z0
-
9
]
[
a
-
z0
-
9
-
]
+
[
a
-
z0
-
9
]
/
i
;
if
(
!
typeRegex
.
test
(
type
)
)
{
this
.
_log
.
trace
(
"
_getArchivedPingDataFromFileName
-
should
have
a
valid
type
"
)
;
return
null
;
}
return
{
timestamp
id
:
uuid
type
}
;
}
async
saveAbortedSessionPing
(
ping
)
{
this
.
_log
.
trace
(
"
saveAbortedSessionPing
-
ping
path
:
"
+
gAbortedSessionFilePath
)
;
await
OS
.
File
.
makeDir
(
gDataReportingDir
{
ignoreExisting
:
true
}
)
;
return
this
.
_abortedSessionSerializer
.
enqueueTask
(
(
)
=
>
this
.
savePingToFile
(
ping
gAbortedSessionFilePath
true
)
)
;
}
async
loadAbortedSessionPing
(
)
{
let
ping
=
null
;
try
{
ping
=
await
this
.
loadPingFile
(
gAbortedSessionFilePath
)
;
}
catch
(
ex
)
{
if
(
ex
.
becauseNoSuchFile
)
{
this
.
_log
.
trace
(
"
loadAbortedSessionPing
-
no
such
file
"
)
;
}
else
{
this
.
_log
.
error
(
"
loadAbortedSessionPing
-
error
loading
ping
"
ex
)
;
}
}
return
ping
;
}
removeAbortedSessionPing
(
)
{
return
this
.
_abortedSessionSerializer
.
enqueueTask
(
async
(
)
=
>
{
try
{
await
OS
.
File
.
remove
(
gAbortedSessionFilePath
{
ignoreAbsent
:
false
}
)
;
this
.
_log
.
trace
(
"
removeAbortedSessionPing
-
success
"
)
;
}
catch
(
ex
)
{
if
(
ex
.
becauseNoSuchFile
)
{
this
.
_log
.
trace
(
"
removeAbortedSessionPing
-
no
such
file
"
)
;
}
else
{
this
.
_log
.
error
(
"
removeAbortedSessionPing
-
error
removing
ping
"
ex
)
;
}
}
}
)
;
}
async
saveDeletionPing
(
ping
)
{
this
.
_log
.
trace
(
"
saveDeletionPing
-
ping
path
:
"
+
gDeletionPingFilePath
)
;
await
OS
.
File
.
makeDir
(
gDataReportingDir
{
ignoreExisting
:
true
}
)
;
let
p
=
this
.
_deletionPingSerializer
.
enqueueTask
(
(
)
=
>
this
.
savePingToFile
(
ping
gDeletionPingFilePath
true
)
)
;
this
.
_trackPendingPingSaveTask
(
p
)
;
return
p
;
}
async
removeDeletionPing
(
)
{
return
this
.
_deletionPingSerializer
.
enqueueTask
(
async
(
)
=
>
{
try
{
await
OS
.
File
.
remove
(
gDeletionPingFilePath
{
ignoreAbsent
:
false
}
)
;
this
.
_log
.
trace
(
"
removeDeletionPing
-
success
"
)
;
}
catch
(
ex
)
{
if
(
ex
.
becauseNoSuchFile
)
{
this
.
_log
.
trace
(
"
removeDeletionPing
-
no
such
file
"
)
;
}
else
{
this
.
_log
.
error
(
"
removeDeletionPing
-
error
removing
ping
"
ex
)
;
}
}
}
)
;
}
isDeletionPing
(
aPingId
)
{
let
pingInfo
=
this
.
_pendingPings
.
get
(
aPingId
)
;
if
(
!
pingInfo
)
{
return
false
;
}
if
(
pingInfo
.
path
!
=
gDeletionPingFilePath
)
{
return
false
;
}
return
true
;
}
async
removeFHRDatabase
(
)
{
this
.
_log
.
trace
(
"
removeFHRDatabase
"
)
;
const
FHR_DB_DEFAULT_FILENAME
=
"
healthreport
.
sqlite
"
;
let
FILES_TO_REMOVE
=
[
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FHR_DB_DEFAULT_FILENAME
)
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FHR_DB_DEFAULT_FILENAME
+
"
-
wal
"
)
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FHR_DB_DEFAULT_FILENAME
+
"
-
shm
"
)
]
;
const
FHR_DB_CUSTOM_FILENAME
=
Preferences
.
get
(
"
datareporting
.
healthreport
.
dbName
"
undefined
)
;
if
(
FHR_DB_CUSTOM_FILENAME
)
{
FILES_TO_REMOVE
.
push
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FHR_DB_CUSTOM_FILENAME
)
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FHR_DB_CUSTOM_FILENAME
+
"
-
wal
"
)
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
FHR_DB_CUSTOM_FILENAME
+
"
-
shm
"
)
)
;
}
for
(
let
f
of
FILES_TO_REMOVE
)
{
await
OS
.
File
.
remove
(
f
{
ignoreAbsent
:
true
}
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
removeFHRDatabase
-
failed
to
remove
"
+
f
e
)
)
;
}
}
}
;
function
pingFilePath
(
ping
)
{
let
pingIdentifier
=
(
ping
.
slug
)
?
ping
.
slug
:
ping
.
id
;
return
OS
.
Path
.
join
(
TelemetryStorage
.
pingDirectoryPath
pingIdentifier
)
;
}
function
getPingDirectory
(
)
{
return
(
async
function
(
)
{
let
directory
=
TelemetryStorage
.
pingDirectoryPath
;
if
(
!
(
await
OS
.
File
.
exists
(
directory
)
)
)
{
await
OS
.
File
.
makeDir
(
directory
{
unixMode
:
OS
.
Constants
.
S_IRWXU
}
)
;
}
return
directory
;
}
)
(
)
;
}
function
getArchivedPingPath
(
aPingId
aDate
aType
)
{
let
month
=
String
(
aDate
.
getMonth
(
)
+
1
)
;
let
archivedPingDir
=
OS
.
Path
.
join
(
gPingsArchivePath
aDate
.
getFullYear
(
)
+
"
-
"
+
month
.
padStart
(
2
"
0
"
)
)
;
let
fileName
=
[
aDate
.
getTime
(
)
aPingId
aType
"
json
"
]
.
join
(
"
.
"
)
;
return
OS
.
Path
.
join
(
archivedPingDir
fileName
)
;
}
var
getArchivedPingSize
=
async
function
(
aPingId
aDate
aType
)
{
const
path
=
getArchivedPingPath
(
aPingId
aDate
aType
)
;
let
filePaths
=
[
path
+
"
lz4
"
path
]
;
for
(
let
path
of
filePaths
)
{
try
{
return
(
await
OS
.
File
.
stat
(
path
)
)
.
size
;
}
catch
(
e
)
{
}
}
return
0
;
}
;
var
getPendingPingSize
=
async
function
(
aPingId
)
{
const
path
=
OS
.
Path
.
join
(
TelemetryStorage
.
pingDirectoryPath
aPingId
)
;
try
{
return
(
await
OS
.
File
.
stat
(
path
)
)
.
size
;
}
catch
(
e
)
{
}
return
0
;
}
;
function
isValidArchiveDir
(
aDirName
)
{
const
dirRegEx
=
/
^
[
0
-
9
]
{
4
}
-
[
0
-
9
]
{
2
}
/
;
return
dirRegEx
.
test
(
aDirName
)
;
}
function
getDateFromArchiveDir
(
aDirName
)
{
let
[
year
month
]
=
aDirName
.
split
(
"
-
"
)
;
year
=
parseInt
(
year
)
;
month
=
parseInt
(
month
)
;
if
(
!
Number
.
isFinite
(
month
)
|
|
!
Number
.
isFinite
(
year
)
|
|
month
<
1
|
|
month
>
12
)
{
return
null
;
}
return
new
Date
(
year
month
-
1
1
0
0
0
)
;
}
