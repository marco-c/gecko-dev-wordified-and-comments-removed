"
use
strict
"
;
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
Cr
=
Components
.
results
;
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetrySend
"
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
jsm
"
)
;
const
Utils
=
TelemetryUtils
;
const
myScope
=
this
;
const
PAYLOAD_VERSION
=
4
;
const
PING_TYPE_MAIN
=
"
main
"
;
const
PING_TYPE_SAVED_SESSION
=
"
saved
-
session
"
;
const
REASON_ABORTED_SESSION
=
"
aborted
-
session
"
;
const
REASON_DAILY
=
"
daily
"
;
const
REASON_SAVED_SESSION
=
"
saved
-
session
"
;
const
REASON_GATHER_PAYLOAD
=
"
gather
-
payload
"
;
const
REASON_GATHER_SUBSESSION_PAYLOAD
=
"
gather
-
subsession
-
payload
"
;
const
REASON_TEST_PING
=
"
test
-
ping
"
;
const
REASON_ENVIRONMENT_CHANGE
=
"
environment
-
change
"
;
const
REASON_SHUTDOWN
=
"
shutdown
"
;
const
HISTOGRAM_SUFFIXES
=
{
PARENT
:
"
"
CONTENT
:
"
#
content
"
GPU
:
"
#
gpu
"
}
const
INTERNAL_PROCESSES_NAMES
=
{
PARENT
:
"
default
"
CONTENT
:
"
tab
"
GPU
:
"
gpu
"
}
const
ENVIRONMENT_CHANGE_LISTENER
=
"
TelemetrySession
:
:
onEnvironmentChange
"
;
const
MS_IN_ONE_HOUR
=
60
*
60
*
1000
;
const
MIN_SUBSESSION_LENGTH_MS
=
Preferences
.
get
(
"
toolkit
.
telemetry
.
minSubsessionLength
"
5
*
60
)
*
1000
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
LOGGER_PREFIX
=
"
TelemetrySession
"
+
(
Utils
.
isContentProcess
?
"
#
content
:
:
"
:
"
:
:
"
)
;
const
PREF_BRANCH
=
"
toolkit
.
telemetry
.
"
;
const
PREF_PREVIOUS_BUILDID
=
PREF_BRANCH
+
"
previousBuildID
"
;
const
PREF_FHR_UPLOAD_ENABLED
=
"
datareporting
.
healthreport
.
uploadEnabled
"
;
const
PREF_ASYNC_PLUGIN_INIT
=
"
dom
.
ipc
.
plugins
.
asyncInit
.
enabled
"
;
const
PREF_UNIFIED
=
PREF_BRANCH
+
"
unified
"
;
const
PREF_SHUTDOWN_PINGSENDER
=
PREF_BRANCH
+
"
shutdownPingSender
.
enabled
"
;
const
MESSAGE_TELEMETRY_PAYLOAD
=
"
Telemetry
:
Payload
"
;
const
MESSAGE_TELEMETRY_THREAD_HANGS
=
"
Telemetry
:
ChildThreadHangs
"
;
const
MESSAGE_TELEMETRY_GET_CHILD_THREAD_HANGS
=
"
Telemetry
:
GetChildThreadHangs
"
;
const
MESSAGE_TELEMETRY_USS
=
"
Telemetry
:
USS
"
;
const
MESSAGE_TELEMETRY_GET_CHILD_USS
=
"
Telemetry
:
GetChildUSS
"
;
const
DATAREPORTING_DIRECTORY
=
"
datareporting
"
;
const
ABORTED_SESSION_FILE_NAME
=
"
aborted
-
session
-
ping
"
;
const
IS_UNIFIED_TELEMETRY
=
Preferences
.
get
(
PREF_UNIFIED
false
)
;
const
MAX_NUM_CONTENT_PAYLOADS
=
10
;
const
TELEMETRY_INTERVAL
=
60
*
1000
;
const
TELEMETRY_DELAY
=
Preferences
.
get
(
"
toolkit
.
telemetry
.
initDelay
"
60
)
*
1000
;
const
TELEMETRY_TEST_DELAY
=
1
;
const
SCHEDULER_TICK_INTERVAL_MS
=
Preferences
.
get
(
"
toolkit
.
telemetry
.
scheduler
.
tickInterval
"
5
*
60
)
*
1000
;
const
SCHEDULER_TICK_IDLE_INTERVAL_MS
=
Preferences
.
get
(
"
toolkit
.
telemetry
.
scheduler
.
idleTickInterval
"
60
*
60
)
*
1000
;
const
SCHEDULER_MIDNIGHT_TOLERANCE_MS
=
15
*
60
*
1000
;
const
IDLE_TIMEOUT_SECONDS
=
Preferences
.
get
(
"
toolkit
.
telemetry
.
idleTimeout
"
5
*
60
)
;
const
ABORTED_SESSION_UPDATE_INTERVAL_MS
=
5
*
60
*
1000
;
const
TOPIC_CYCLE_COLLECTOR_BEGIN
=
"
cycle
-
collector
-
begin
"
;
const
TOTAL_MEMORY_COLLECTOR_TIMEOUT
=
200
;
var
gLastMemoryPoll
=
null
;
var
gWasDebuggerAttached
=
false
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
Telemetry
"
"
mozilla
.
org
/
base
/
telemetry
;
1
"
"
nsITelemetry
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
idleService
"
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
"
nsIIdleService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
cpmm
"
"
mozilla
.
org
/
childprocessmessagemanager
;
1
"
"
nsIMessageSender
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
cpml
"
"
mozilla
.
org
/
childprocessmessagemanager
;
1
"
"
nsIMessageListenerManager
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
ppmm
"
"
mozilla
.
org
/
parentprocessmessagemanager
;
1
"
"
nsIMessageBroadcaster
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
ppml
"
"
mozilla
.
org
/
parentprocessmessagemanager
;
1
"
"
nsIMessageListenerManager
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AddonManagerPrivate
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AsyncShutdown
"
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryController
"
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryStorage
"
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryLog
"
"
resource
:
/
/
gre
/
modules
/
TelemetryLog
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ThirdPartyCookieProbe
"
"
resource
:
/
/
gre
/
modules
/
ThirdPartyCookieProbe
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
UITelemetry
"
"
resource
:
/
/
gre
/
modules
/
UITelemetry
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
GCTelemetry
"
"
resource
:
/
/
gre
/
modules
/
GCTelemetry
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryEnvironment
"
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryReportingPolicy
"
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
)
;
function
generateUUID
(
)
{
let
str
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
return
str
.
substring
(
1
str
.
length
-
1
)
;
}
function
getMsSinceProcessStart
(
)
{
try
{
return
Telemetry
.
msSinceProcessStart
(
)
;
}
catch
(
ex
)
{
return
-
1
;
}
}
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
monotonicNow
:
getMsSinceProcessStart
generateSessionUUID
:
(
)
=
>
generateUUID
(
)
generateSubsessionUUID
:
(
)
=
>
generateUUID
(
)
setSchedulerTickTimeout
:
(
callback
delayMs
)
=
>
setTimeout
(
callback
delayMs
)
clearSchedulerTickTimeout
:
id
=
>
clearTimeout
(
id
)
}
;
function
getPingType
(
aPayload
)
{
if
(
aPayload
.
info
.
reason
=
=
REASON_SAVED_SESSION
)
{
return
PING_TYPE_SAVED_SESSION
;
}
return
PING_TYPE_MAIN
;
}
function
annotateCrashReport
(
sessionId
)
{
try
{
const
cr
=
Cc
[
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
]
;
if
(
cr
)
{
cr
.
getService
(
Ci
.
nsICrashReporter
)
.
setTelemetrySessionId
(
sessionId
)
;
}
}
catch
(
e
)
{
}
}
var
processInfo
=
{
_initialized
:
false
_IO_COUNTERS
:
null
_kernel32
:
null
_GetProcessIoCounters
:
null
_GetCurrentProcess
:
null
getCounters
(
)
{
let
isWindows
=
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
in
Components
.
classes
)
;
if
(
isWindows
)
return
this
.
getCounters_Windows
(
)
;
return
null
;
}
getCounters_Windows
(
)
{
if
(
!
this
.
_initialized
)
{
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
this
.
_IO_COUNTERS
=
new
ctypes
.
StructType
(
"
IO_COUNTERS
"
[
{
"
readOps
"
:
ctypes
.
unsigned_long_long
}
{
"
writeOps
"
:
ctypes
.
unsigned_long_long
}
{
"
otherOps
"
:
ctypes
.
unsigned_long_long
}
{
"
readBytes
"
:
ctypes
.
unsigned_long_long
}
{
"
writeBytes
"
:
ctypes
.
unsigned_long_long
}
{
"
otherBytes
"
:
ctypes
.
unsigned_long_long
}
]
)
;
try
{
this
.
_kernel32
=
ctypes
.
open
(
"
Kernel32
.
dll
"
)
;
this
.
_GetProcessIoCounters
=
this
.
_kernel32
.
declare
(
"
GetProcessIoCounters
"
ctypes
.
winapi_abi
ctypes
.
bool
ctypes
.
voidptr_t
this
.
_IO_COUNTERS
.
ptr
)
;
this
.
_GetCurrentProcess
=
this
.
_kernel32
.
declare
(
"
GetCurrentProcess
"
ctypes
.
winapi_abi
ctypes
.
voidptr_t
)
;
this
.
_initialized
=
true
;
}
catch
(
err
)
{
return
null
;
}
}
let
io
=
new
this
.
_IO_COUNTERS
(
)
;
if
(
!
this
.
_GetProcessIoCounters
(
this
.
_GetCurrentProcess
(
)
io
.
address
(
)
)
)
return
null
;
return
[
parseInt
(
io
.
readBytes
)
parseInt
(
io
.
writeBytes
)
]
;
}
}
;
var
TelemetryScheduler
=
{
_lastDailyPingTime
:
0
_lastSessionCheckpointTime
:
0
_lastAdhocPingTime
:
0
_lastTickTime
:
0
_log
:
null
_schedulerTimer
:
null
_schedulerInterval
:
0
_shuttingDown
:
true
_isUserIdle
:
false
init
(
)
{
this
.
_log
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
"
TelemetryScheduler
:
:
"
)
;
this
.
_log
.
trace
(
"
init
"
)
;
this
.
_shuttingDown
=
false
;
this
.
_isUserIdle
=
false
;
let
now
=
Policy
.
now
(
)
;
this
.
_lastDailyPingTime
=
now
.
getTime
(
)
;
this
.
_lastSessionCheckpointTime
=
now
.
getTime
(
)
;
this
.
_rescheduleTimeout
(
)
;
idleService
.
addIdleObserver
(
this
IDLE_TIMEOUT_SECONDS
)
;
Services
.
obs
.
addObserver
(
this
"
wake_notification
"
false
)
;
}
shutdown
(
)
{
if
(
this
.
_shuttingDown
)
{
if
(
this
.
_log
)
{
this
.
_log
.
error
(
"
shutdown
-
Already
shut
down
"
)
;
}
else
{
Cu
.
reportError
(
"
TelemetryScheduler
.
shutdown
-
Already
shut
down
"
)
;
}
return
;
}
this
.
_log
.
trace
(
"
shutdown
"
)
;
if
(
this
.
_schedulerTimer
)
{
Policy
.
clearSchedulerTickTimeout
(
this
.
_schedulerTimer
)
;
this
.
_schedulerTimer
=
null
;
}
idleService
.
removeIdleObserver
(
this
IDLE_TIMEOUT_SECONDS
)
;
Services
.
obs
.
removeObserver
(
this
"
wake_notification
"
)
;
this
.
_shuttingDown
=
true
;
}
_clearTimeout
(
)
{
if
(
this
.
_schedulerTimer
)
{
Policy
.
clearSchedulerTickTimeout
(
this
.
_schedulerTimer
)
;
}
}
_rescheduleTimeout
(
)
{
this
.
_log
.
trace
(
"
_rescheduleTimeout
-
isUserIdle
:
"
+
this
.
_isUserIdle
)
;
if
(
this
.
_shuttingDown
)
{
this
.
_log
.
warn
(
"
_rescheduleTimeout
-
already
shutdown
"
)
;
return
;
}
this
.
_clearTimeout
(
)
;
const
now
=
Policy
.
now
(
)
;
let
timeout
=
SCHEDULER_TICK_INTERVAL_MS
;
if
(
this
.
_isUserIdle
)
{
timeout
=
SCHEDULER_TICK_IDLE_INTERVAL_MS
;
const
nextMidnight
=
Utils
.
getNextMidnight
(
now
)
;
timeout
=
Math
.
min
(
timeout
nextMidnight
.
getTime
(
)
-
now
.
getTime
(
)
)
;
}
this
.
_log
.
trace
(
"
_rescheduleTimeout
-
scheduling
next
tick
for
"
+
new
Date
(
now
.
getTime
(
)
+
timeout
)
)
;
this
.
_schedulerTimer
=
Policy
.
setSchedulerTickTimeout
(
(
)
=
>
this
.
_onSchedulerTick
(
)
timeout
)
;
}
_sentDailyPingToday
(
nowDate
)
{
const
todayDate
=
Utils
.
truncateToDays
(
nowDate
)
;
return
(
this
.
_lastDailyPingTime
>
=
todayDate
.
getTime
(
)
)
;
}
_isDailyPingDue
(
nowDate
)
{
if
(
this
.
_sentDailyPingToday
(
nowDate
)
)
{
this
.
_log
.
trace
(
"
_isDailyPingDue
-
already
sent
one
today
"
)
;
return
false
;
}
const
timeSinceLastDaily
=
nowDate
.
getTime
(
)
-
this
.
_lastDailyPingTime
;
if
(
timeSinceLastDaily
<
MIN_SUBSESSION_LENGTH_MS
)
{
this
.
_log
.
trace
(
"
_isDailyPingDue
-
delaying
daily
to
keep
minimum
session
length
"
)
;
return
false
;
}
this
.
_log
.
trace
(
"
_isDailyPingDue
-
is
due
"
)
;
return
true
;
}
_saveAbortedPing
(
now
competingPayload
=
null
)
{
this
.
_lastSessionCheckpointTime
=
now
;
return
Impl
.
_saveAbortedSessionPing
(
competingPayload
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
_saveAbortedPing
-
Failed
"
e
)
)
;
}
observe
(
aSubject
aTopic
aData
)
{
this
.
_log
.
trace
(
"
observe
-
aTopic
:
"
+
aTopic
)
;
switch
(
aTopic
)
{
case
"
idle
"
:
this
.
_isUserIdle
=
true
;
return
this
.
_onSchedulerTick
(
)
;
case
"
active
"
:
this
.
_isUserIdle
=
false
;
return
this
.
_onSchedulerTick
(
)
;
case
"
wake_notification
"
:
return
this
.
_onSchedulerTick
(
)
;
}
return
undefined
;
}
_onSchedulerTick
(
)
{
this
.
_clearTimeout
(
)
;
if
(
this
.
_shuttingDown
)
{
this
.
_log
.
warn
(
"
_onSchedulerTick
-
already
shutdown
.
"
)
;
return
Promise
.
reject
(
new
Error
(
"
Already
shutdown
.
"
)
)
;
}
let
promise
=
Promise
.
resolve
(
)
;
try
{
promise
=
this
.
_schedulerTickLogic
(
)
;
}
catch
(
e
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_SCHEDULER_TICK_EXCEPTION
"
)
.
add
(
1
)
;
this
.
_log
.
error
(
"
_onSchedulerTick
-
There
was
an
exception
"
e
)
;
}
finally
{
this
.
_rescheduleTimeout
(
)
;
}
return
promise
;
}
_schedulerTickLogic
(
)
{
this
.
_log
.
trace
(
"
_schedulerTickLogic
"
)
;
let
nowDate
=
Policy
.
now
(
)
;
let
now
=
nowDate
.
getTime
(
)
;
if
(
(
now
-
this
.
_lastTickTime
)
>
(
1
.
1
*
SCHEDULER_TICK_INTERVAL_MS
)
&
&
(
this
.
_lastTickTime
!
=
0
)
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_SCHEDULER_WAKEUP
"
)
.
add
(
1
)
;
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
First
scheduler
tick
after
sleep
.
"
)
;
}
this
.
_lastTickTime
=
now
;
const
shouldSendDaily
=
this
.
_isDailyPingDue
(
nowDate
)
;
if
(
shouldSendDaily
)
{
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
Daily
ping
due
.
"
)
;
this
.
_lastDailyPingTime
=
now
;
return
Impl
.
_sendDailyPing
(
)
;
}
const
isAbortedPingDue
=
(
now
-
this
.
_lastSessionCheckpointTime
)
>
=
ABORTED_SESSION_UPDATE_INTERVAL_MS
;
if
(
isAbortedPingDue
)
{
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
Aborted
session
ping
due
.
"
)
;
return
this
.
_saveAbortedPing
(
now
)
;
}
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
No
ping
due
.
"
)
;
return
Promise
.
resolve
(
)
;
}
reschedulePings
(
reason
competingPayload
=
null
)
{
if
(
this
.
_shuttingDown
)
{
this
.
_log
.
error
(
"
reschedulePings
-
already
shutdown
"
)
;
return
;
}
this
.
_log
.
trace
(
"
reschedulePings
-
reason
:
"
+
reason
)
;
let
now
=
Policy
.
now
(
)
;
this
.
_lastAdhocPingTime
=
now
.
getTime
(
)
;
if
(
reason
=
=
REASON_ENVIRONMENT_CHANGE
)
{
this
.
_saveAbortedPing
(
now
.
getTime
(
)
competingPayload
)
;
let
nearestMidnight
=
Utils
.
getNearestMidnight
(
now
SCHEDULER_MIDNIGHT_TOLERANCE_MS
)
;
if
(
nearestMidnight
)
{
this
.
_lastDailyPingTime
=
now
.
getTime
(
)
;
}
}
this
.
_rescheduleTimeout
(
)
;
}
}
;
this
.
EXPORTED_SYMBOLS
=
[
"
TelemetrySession
"
]
;
this
.
TelemetrySession
=
Object
.
freeze
(
{
Constants
:
Object
.
freeze
(
{
PREF_PREVIOUS_BUILDID
}
)
testPing
(
)
{
return
Impl
.
testPing
(
)
;
}
getPayload
(
reason
clearSubsession
=
false
)
{
return
Impl
.
getPayload
(
reason
clearSubsession
)
;
}
getChildThreadHangs
(
)
{
return
Impl
.
getChildThreadHangs
(
)
;
}
testSavePendingPing
(
)
{
return
Impl
.
testSavePendingPing
(
)
;
}
gatherStartup
(
)
{
return
Impl
.
gatherStartup
(
)
;
}
setAddOns
(
aAddOns
)
{
return
Impl
.
setAddOns
(
aAddOns
)
;
}
getMetadata
(
reason
)
{
return
Impl
.
getMetadata
(
reason
)
;
}
testReset
(
)
{
Impl
.
_sessionId
=
null
;
Impl
.
_subsessionId
=
null
;
Impl
.
_previousSessionId
=
null
;
Impl
.
_previousSubsessionId
=
null
;
Impl
.
_subsessionCounter
=
0
;
Impl
.
_profileSubsessionCounter
=
0
;
Impl
.
_subsessionStartActiveTicks
=
0
;
Impl
.
_subsessionStartTimeMonotonic
=
0
;
Impl
.
_lastEnvironmentChangeDate
=
Policy
.
monotonicNow
(
)
;
this
.
testUninstall
(
)
;
}
shutdown
(
)
{
return
Impl
.
shutdownChromeProcess
(
)
;
}
setupContent
(
testing
=
false
)
{
return
Impl
.
setupContentProcess
(
testing
)
;
}
testUninstall
(
)
{
try
{
Impl
.
uninstall
(
)
;
}
catch
(
ex
)
{
}
}
earlyInit
(
aTesting
=
false
)
{
return
Impl
.
earlyInit
(
aTesting
)
;
}
delayedInit
(
)
{
return
Impl
.
delayedInit
(
)
;
}
observe
(
aSubject
aTopic
aData
)
{
return
Impl
.
observe
(
aSubject
aTopic
aData
)
;
}
}
)
;
var
Impl
=
{
_histograms
:
{
}
_initialized
:
false
_logger
:
null
_prevValues
:
{
}
_slowSQLStartup
:
{
}
_hasWindowRestoredObserver
:
false
_hasXulWindowVisibleObserver
:
false
_startupIO
:
{
}
_previousBuildId
:
null
_childTelemetry
:
[
]
_childThreadHangs
:
[
]
_childThreadHangsResolveFunctions
:
[
]
_childThreadHangsTimeout
:
null
_sessionId
:
null
_subsessionId
:
null
_previousSessionId
:
null
_previousSubsessionId
:
null
_subsessionCounter
:
0
_profileSubsessionCounter
:
0
_subsessionStartDate
:
null
_subsessionStartTimeMonotonic
:
0
_subsessionStartActiveTicks
:
0
_delayedInitTask
:
null
_totalMemoryTimeout
:
undefined
_testing
:
false
_totalMemory
:
null
_childrenToHearFrom
:
null
_nextTotalMemoryId
:
1
_USSFromChildProcesses
:
null
_lastEnvironmentChangeDate
:
0
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
)
;
}
return
this
.
_logger
;
}
getSimpleMeasurements
:
function
getSimpleMeasurements
(
forSavedSession
isSubsession
clearSubsession
)
{
let
si
=
Services
.
startup
.
getStartupInfo
(
)
;
let
elapsedTime
=
Date
.
now
(
)
-
si
.
process
;
var
ret
=
{
totalTime
:
Math
.
round
(
elapsedTime
/
1000
)
uptime
:
Math
.
round
(
elapsedTime
/
60000
)
}
var
appTimestamps
=
{
}
;
try
{
let
o
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryTimestamps
.
jsm
"
o
)
;
appTimestamps
=
o
.
TelemetryTimestamps
.
get
(
)
;
}
catch
(
ex
)
{
}
if
(
!
Utils
.
isContentProcess
&
&
Telemetry
.
canRecordExtended
)
{
try
{
ret
.
addonManager
=
AddonManagerPrivate
.
getSimpleMeasures
(
)
;
ret
.
UITelemetry
=
UITelemetry
.
getSimpleMeasures
(
)
;
}
catch
(
ex
)
{
}
}
if
(
si
.
process
)
{
for
(
let
field
of
Object
.
keys
(
si
)
)
{
if
(
field
=
=
"
process
"
)
continue
;
ret
[
field
]
=
si
[
field
]
-
si
.
process
}
for
(
let
p
in
appTimestamps
)
{
if
(
!
(
p
in
ret
)
&
&
appTimestamps
[
p
]
)
ret
[
p
]
=
appTimestamps
[
p
]
-
si
.
process
;
}
}
ret
.
startupInterrupted
=
Number
(
Services
.
startup
.
interrupted
)
;
ret
.
js
=
Cu
.
getJSEngineTelemetryValue
(
)
;
let
maximalNumberOfConcurrentThreads
=
Telemetry
.
maximalNumberOfConcurrentThreads
;
if
(
maximalNumberOfConcurrentThreads
)
{
ret
.
maximalNumberOfConcurrentThreads
=
maximalNumberOfConcurrentThreads
;
}
if
(
Utils
.
isContentProcess
)
{
return
ret
;
}
let
debugService
=
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
;
let
isDebuggerAttached
=
debugService
.
isDebuggerAttached
;
gWasDebuggerAttached
=
gWasDebuggerAttached
|
|
isDebuggerAttached
;
ret
.
debuggerAttached
=
Number
(
gWasDebuggerAttached
)
;
let
shutdownDuration
=
Telemetry
.
lastShutdownDuration
;
if
(
shutdownDuration
)
ret
.
shutdownDuration
=
shutdownDuration
;
let
failedProfileLockCount
=
Telemetry
.
failedProfileLockCount
;
if
(
failedProfileLockCount
)
ret
.
failedProfileLockCount
=
failedProfileLockCount
;
for
(
let
ioCounter
in
this
.
_startupIO
)
ret
[
ioCounter
]
=
this
.
_startupIO
[
ioCounter
]
;
ret
.
savedPings
=
TelemetryStorage
.
pendingPingCount
;
ret
.
activeTicks
=
-
1
;
let
sr
=
TelemetryController
.
getSessionRecorder
(
)
;
if
(
sr
)
{
let
activeTicks
=
sr
.
activeTicks
;
if
(
isSubsession
)
{
activeTicks
=
sr
.
activeTicks
-
this
.
_subsessionStartActiveTicks
;
}
if
(
clearSubsession
)
{
this
.
_subsessionStartActiveTicks
=
activeTicks
;
}
ret
.
activeTicks
=
activeTicks
;
}
ret
.
pingsOverdue
=
TelemetrySend
.
overduePingsCount
;
return
ret
;
}
packHistogram
:
function
packHistogram
(
hgram
)
{
let
r
=
hgram
.
ranges
;
let
c
=
hgram
.
counts
;
let
retgram
=
{
range
:
[
r
[
1
]
r
[
r
.
length
-
1
]
]
bucket_count
:
r
.
length
histogram_type
:
hgram
.
histogram_type
values
:
{
}
sum
:
hgram
.
sum
}
;
let
first
=
true
;
let
last
=
0
;
for
(
let
i
=
0
;
i
<
c
.
length
;
i
+
+
)
{
let
value
=
c
[
i
]
;
if
(
!
value
)
continue
;
if
(
i
&
&
first
)
{
retgram
.
values
[
r
[
i
-
1
]
]
=
0
;
}
first
=
false
;
last
=
i
+
1
;
retgram
.
values
[
r
[
i
]
]
=
value
;
}
if
(
last
&
&
last
<
c
.
length
)
retgram
.
values
[
r
[
last
]
]
=
0
;
return
retgram
;
}
getDatasetType
(
)
{
return
Telemetry
.
canRecordExtended
?
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
:
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTOUT
;
}
getHistograms
:
function
getHistograms
(
subsession
clearSubsession
)
{
let
registered
=
Telemetry
.
registeredHistograms
(
this
.
getDatasetType
(
)
[
]
)
;
if
(
this
.
_testing
=
=
false
)
{
registered
=
registered
.
filter
(
n
=
>
!
n
.
startsWith
(
"
TELEMETRY_TEST_
"
)
)
;
}
registered
=
registered
.
concat
(
registered
.
map
(
n
=
>
"
STARTUP_
"
+
n
)
)
;
let
hls
=
subsession
?
Telemetry
.
snapshotSubsessionHistograms
(
clearSubsession
)
:
Telemetry
.
histogramSnapshots
;
let
ret
=
{
}
;
for
(
let
name
of
registered
)
{
for
(
let
suffix
of
Object
.
values
(
HISTOGRAM_SUFFIXES
)
)
{
if
(
name
+
suffix
in
hls
)
{
if
(
!
(
suffix
in
ret
)
)
{
ret
[
suffix
]
=
{
}
;
}
ret
[
suffix
]
[
name
]
=
this
.
packHistogram
(
hls
[
name
+
suffix
]
)
;
}
}
}
return
ret
;
}
getAddonHistograms
:
function
getAddonHistograms
(
)
{
let
ahs
=
Telemetry
.
addonHistogramSnapshots
;
let
ret
=
{
}
;
for
(
let
addonName
in
ahs
)
{
let
addonHistograms
=
ahs
[
addonName
]
;
let
packedHistograms
=
{
}
;
for
(
let
name
in
addonHistograms
)
{
packedHistograms
[
name
]
=
this
.
packHistogram
(
addonHistograms
[
name
]
)
;
}
if
(
Object
.
keys
(
packedHistograms
)
.
length
!
=
0
)
ret
[
addonName
]
=
packedHistograms
;
}
return
ret
;
}
getKeyedHistograms
(
subsession
clearSubsession
)
{
let
registered
=
Telemetry
.
registeredKeyedHistograms
(
this
.
getDatasetType
(
)
[
]
)
;
if
(
this
.
_testing
=
=
false
)
{
registered
=
registered
.
filter
(
id
=
>
!
id
.
startsWith
(
"
TELEMETRY_TEST_
"
)
)
;
}
let
ret
=
{
}
;
for
(
let
id
of
registered
)
{
for
(
let
suffix
of
Object
.
values
(
HISTOGRAM_SUFFIXES
)
)
{
let
keyed
=
Telemetry
.
getKeyedHistogramById
(
id
+
suffix
)
;
let
snapshot
=
null
;
if
(
subsession
)
{
snapshot
=
clearSubsession
?
keyed
.
snapshotSubsessionAndClear
(
)
:
keyed
.
subsessionSnapshot
(
)
;
}
else
{
snapshot
=
keyed
.
snapshot
(
)
;
}
let
keys
=
Object
.
keys
(
snapshot
)
;
if
(
keys
.
length
=
=
0
)
{
continue
;
}
if
(
!
(
suffix
in
ret
)
)
{
ret
[
suffix
]
=
{
}
;
}
ret
[
suffix
]
[
id
]
=
{
}
;
for
(
let
key
of
keys
)
{
ret
[
suffix
]
[
id
]
[
key
]
=
this
.
packHistogram
(
snapshot
[
key
]
)
;
}
}
}
return
ret
;
}
getScalars
(
subsession
clearSubsession
keyed
)
{
if
(
!
subsession
)
{
this
.
_log
.
trace
(
"
getScalars
-
We
only
support
scalars
in
subsessions
.
"
)
;
return
{
}
;
}
let
scalarsSnapshot
=
keyed
?
Telemetry
.
snapshotKeyedScalars
(
this
.
getDatasetType
(
)
clearSubsession
)
:
Telemetry
.
snapshotScalars
(
this
.
getDatasetType
(
)
clearSubsession
)
;
let
ret
=
{
}
;
for
(
let
processName
in
scalarsSnapshot
)
{
for
(
let
name
in
scalarsSnapshot
[
processName
]
)
{
if
(
name
.
startsWith
(
"
telemetry
.
test
"
)
&
&
this
.
_testing
=
=
false
)
{
continue
;
}
if
(
!
(
processName
in
ret
)
)
{
ret
[
processName
]
=
{
}
;
}
ret
[
processName
]
[
name
]
=
scalarsSnapshot
[
processName
]
[
name
]
;
}
}
return
ret
;
}
getEvents
(
isSubsession
clearSubsession
)
{
if
(
!
isSubsession
)
{
this
.
_log
.
trace
(
"
getEvents
-
We
only
support
events
in
subsessions
.
"
)
;
return
[
]
;
}
let
snapshot
=
Telemetry
.
snapshotBuiltinEvents
(
this
.
getDatasetType
(
)
clearSubsession
)
;
if
(
!
this
.
_testing
)
{
for
(
let
proc
of
Object
.
keys
(
snapshot
)
)
{
snapshot
[
proc
]
=
snapshot
[
proc
]
.
filter
(
e
=
>
!
e
[
1
]
.
startsWith
(
"
telemetry
.
test
"
)
)
;
}
}
return
snapshot
;
}
getThreadHangStats
:
function
getThreadHangStats
(
stats
)
{
stats
.
forEach
(
(
thread
)
=
>
{
thread
.
activity
=
this
.
packHistogram
(
thread
.
activity
)
;
thread
.
hangs
.
forEach
(
(
hang
)
=
>
{
hang
.
histogram
=
this
.
packHistogram
(
hang
.
histogram
)
;
}
)
;
}
)
;
return
stats
;
}
getMetadata
:
function
getMetadata
(
reason
)
{
const
sessionStartDate
=
Utils
.
toLocalTimeISOString
(
Utils
.
truncateToHours
(
this
.
_sessionStartDate
)
)
;
const
subsessionStartDate
=
Utils
.
toLocalTimeISOString
(
Utils
.
truncateToHours
(
this
.
_subsessionStartDate
)
)
;
const
monotonicNow
=
Policy
.
monotonicNow
(
)
;
let
ret
=
{
reason
revision
:
AppConstants
.
SOURCE_REVISION_URL
asyncPluginInit
:
Preferences
.
get
(
PREF_ASYNC_PLUGIN_INIT
false
)
timezoneOffset
:
-
this
.
_subsessionStartDate
.
getTimezoneOffset
(
)
previousBuildId
:
this
.
_previousBuildId
sessionId
:
this
.
_sessionId
subsessionId
:
this
.
_subsessionId
previousSessionId
:
this
.
_previousSessionId
previousSubsessionId
:
this
.
_previousSubsessionId
subsessionCounter
:
this
.
_subsessionCounter
profileSubsessionCounter
:
this
.
_profileSubsessionCounter
sessionStartDate
subsessionStartDate
sessionLength
:
Math
.
floor
(
monotonicNow
/
1000
)
subsessionLength
:
Math
.
floor
(
(
monotonicNow
-
this
.
_subsessionStartTimeMonotonic
)
/
1000
)
}
;
if
(
this
.
_addons
)
ret
.
addons
=
this
.
_addons
;
let
flashVersion
=
this
.
getFlashVersion
(
)
;
if
(
flashVersion
)
ret
.
flashVersion
=
flashVersion
;
return
ret
;
}
gatherMemory
:
function
gatherMemory
(
)
{
if
(
!
Telemetry
.
canRecordExtended
)
{
return
;
}
let
mgr
;
try
{
mgr
=
Cc
[
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIMemoryReporterManager
)
;
}
catch
(
e
)
{
return
;
}
let
histogram
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_MEMORY_REPORTER_MS
"
)
;
let
startTime
=
new
Date
(
)
;
let
boundHandleMemoryReport
=
this
.
handleMemoryReport
.
bind
(
this
)
;
let
h
=
(
id
units
amountName
)
=
>
{
try
{
let
amount
=
mgr
[
amountName
]
;
if
(
amount
=
=
=
undefined
)
{
this
.
_log
.
error
(
"
gatherMemory
-
telemetry
accessed
an
unknown
distinguished
amount
"
)
;
}
boundHandleMemoryReport
(
id
units
amount
)
;
}
catch
(
e
)
{
}
}
let
b
=
(
id
n
)
=
>
h
(
id
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
n
)
;
let
c
=
(
id
n
)
=
>
h
(
id
Ci
.
nsIMemoryReporter
.
UNITS_COUNT
n
)
;
let
cc
=
(
id
n
)
=
>
h
(
id
Ci
.
nsIMemoryReporter
.
UNITS_COUNT_CUMULATIVE
n
)
;
let
p
=
(
id
n
)
=
>
h
(
id
Ci
.
nsIMemoryReporter
.
UNITS_PERCENTAGE
n
)
;
b
(
"
MEMORY_VSIZE
"
"
vsize
"
)
;
b
(
"
MEMORY_VSIZE_MAX_CONTIGUOUS
"
"
vsizeMaxContiguous
"
)
;
b
(
"
MEMORY_RESIDENT_FAST
"
"
residentFast
"
)
;
b
(
"
MEMORY_UNIQUE
"
"
residentUnique
"
)
;
b
(
"
MEMORY_HEAP_ALLOCATED
"
"
heapAllocated
"
)
;
p
(
"
MEMORY_HEAP_OVERHEAD_FRACTION
"
"
heapOverheadFraction
"
)
;
b
(
"
MEMORY_JS_GC_HEAP
"
"
JSMainRuntimeGCHeap
"
)
;
c
(
"
MEMORY_JS_COMPARTMENTS_SYSTEM
"
"
JSMainRuntimeCompartmentsSystem
"
)
;
c
(
"
MEMORY_JS_COMPARTMENTS_USER
"
"
JSMainRuntimeCompartmentsUser
"
)
;
b
(
"
MEMORY_IMAGES_CONTENT_USED_UNCOMPRESSED
"
"
imagesContentUsedUncompressed
"
)
;
b
(
"
MEMORY_STORAGE_SQLITE
"
"
storageSQLite
"
)
;
cc
(
"
LOW_MEMORY_EVENTS_VIRTUAL
"
"
lowMemoryEventsVirtual
"
)
;
cc
(
"
LOW_MEMORY_EVENTS_PHYSICAL
"
"
lowMemoryEventsPhysical
"
)
;
c
(
"
GHOST_WINDOWS
"
"
ghostWindows
"
)
;
cc
(
"
PAGE_FAULTS_HARD
"
"
pageFaultsHard
"
)
;
if
(
!
Utils
.
isContentProcess
&
&
!
this
.
_totalMemoryTimeout
)
{
this
.
_totalMemory
=
mgr
.
residentFast
;
if
(
ppmm
.
childCount
>
1
)
{
this
.
_totalMemoryTimeout
=
setTimeout
(
(
)
=
>
{
this
.
_totalMemoryTimeout
=
undefined
;
this
.
_childrenToHearFrom
.
clear
(
)
;
}
TOTAL_MEMORY_COLLECTOR_TIMEOUT
)
;
this
.
_USSFromChildProcesses
=
[
]
;
this
.
_childrenToHearFrom
=
new
Set
(
)
;
for
(
let
i
=
1
;
i
<
ppmm
.
childCount
;
i
+
+
)
{
let
child
=
ppmm
.
getChildAt
(
i
)
;
try
{
child
.
sendAsyncMessage
(
MESSAGE_TELEMETRY_GET_CHILD_USS
{
id
:
this
.
_nextTotalMemoryId
}
)
;
this
.
_childrenToHearFrom
.
add
(
this
.
_nextTotalMemoryId
)
;
this
.
_nextTotalMemoryId
+
+
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
else
{
boundHandleMemoryReport
(
"
MEMORY_TOTAL
"
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
this
.
_totalMemory
)
;
}
}
histogram
.
add
(
new
Date
(
)
-
startTime
)
;
}
handleMemoryReport
(
id
units
amount
key
)
{
let
val
;
if
(
units
=
=
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
)
{
val
=
Math
.
floor
(
amount
/
1024
)
;
}
else
if
(
units
=
=
Ci
.
nsIMemoryReporter
.
UNITS_PERCENTAGE
)
{
val
=
Math
.
floor
(
amount
/
100
)
;
}
else
if
(
units
=
=
Ci
.
nsIMemoryReporter
.
UNITS_COUNT
)
{
val
=
amount
;
}
else
if
(
units
=
=
Ci
.
nsIMemoryReporter
.
UNITS_COUNT_CUMULATIVE
)
{
if
(
!
(
id
in
this
.
_prevValues
)
)
{
this
.
_prevValues
[
id
]
=
amount
;
return
;
}
val
=
amount
-
this
.
_prevValues
[
id
]
;
this
.
_prevValues
[
id
]
=
amount
;
}
else
{
this
.
_log
.
error
(
"
handleMemoryReport
-
Can
'
t
handle
memory
reporter
with
units
"
+
units
)
;
return
;
}
let
h
=
this
.
_histograms
[
id
]
;
if
(
!
h
)
{
if
(
key
)
{
h
=
Telemetry
.
getKeyedHistogramById
(
id
)
;
}
else
{
h
=
Telemetry
.
getHistogramById
(
id
)
;
}
this
.
_histograms
[
id
]
=
h
;
}
if
(
key
)
{
h
.
add
(
key
val
)
;
}
else
{
h
.
add
(
val
)
;
}
}
getChildPayloads
:
function
getChildPayloads
(
)
{
return
this
.
_childTelemetry
.
map
(
child
=
>
child
.
payload
)
;
}
assemblePayloadWithMeasurements
(
simpleMeasurements
info
reason
clearSubsession
)
{
const
isSubsession
=
IS_UNIFIED_TELEMETRY
&
&
!
this
.
_isClassicReason
(
reason
)
;
clearSubsession
=
IS_UNIFIED_TELEMETRY
&
&
clearSubsession
;
this
.
_log
.
trace
(
"
assemblePayloadWithMeasurements
-
reason
:
"
+
reason
+
"
submitting
subsession
data
:
"
+
isSubsession
)
;
const
protect
=
(
fn
defaultReturn
=
null
)
=
>
{
try
{
return
fn
(
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
assemblePayloadWithMeasurements
-
caught
exception
"
ex
)
;
return
defaultReturn
;
}
}
;
let
payloadObj
=
{
ver
:
PAYLOAD_VERSION
simpleMeasurements
}
;
if
(
Telemetry
.
canRecordExtended
)
{
payloadObj
.
chromeHangs
=
protect
(
(
)
=
>
Telemetry
.
chromeHangs
)
;
payloadObj
.
threadHangStats
=
protect
(
(
)
=
>
this
.
getThreadHangStats
(
Telemetry
.
threadHangStats
)
)
;
payloadObj
.
log
=
protect
(
(
)
=
>
TelemetryLog
.
entries
(
)
)
;
payloadObj
.
webrtc
=
protect
(
(
)
=
>
Telemetry
.
webrtcStats
)
;
}
if
(
Utils
.
isContentProcess
)
{
return
payloadObj
;
}
let
histograms
=
protect
(
(
)
=
>
this
.
getHistograms
(
isSubsession
clearSubsession
)
{
}
)
;
let
keyedHistograms
=
protect
(
(
)
=
>
this
.
getKeyedHistograms
(
isSubsession
clearSubsession
)
{
}
)
;
let
scalars
=
protect
(
(
)
=
>
this
.
getScalars
(
isSubsession
clearSubsession
)
{
}
)
;
let
keyedScalars
=
protect
(
(
)
=
>
this
.
getScalars
(
isSubsession
clearSubsession
true
)
{
}
)
;
let
events
=
protect
(
(
)
=
>
this
.
getEvents
(
isSubsession
clearSubsession
)
)
payloadObj
.
histograms
=
histograms
[
HISTOGRAM_SUFFIXES
.
PARENT
]
|
|
{
}
;
payloadObj
.
keyedHistograms
=
keyedHistograms
[
HISTOGRAM_SUFFIXES
.
PARENT
]
|
|
{
}
;
payloadObj
.
processes
=
{
parent
:
{
scalars
:
scalars
[
INTERNAL_PROCESSES_NAMES
.
PARENT
]
|
|
{
}
keyedScalars
:
keyedScalars
[
INTERNAL_PROCESSES_NAMES
.
PARENT
]
|
|
{
}
events
:
events
[
INTERNAL_PROCESSES_NAMES
.
PARENT
]
|
|
[
]
}
content
:
{
scalars
:
scalars
[
INTERNAL_PROCESSES_NAMES
.
CONTENT
]
keyedScalars
:
keyedScalars
[
INTERNAL_PROCESSES_NAMES
.
CONTENT
]
histograms
:
histograms
[
HISTOGRAM_SUFFIXES
.
CONTENT
]
keyedHistograms
:
keyedHistograms
[
HISTOGRAM_SUFFIXES
.
CONTENT
]
events
:
events
[
INTERNAL_PROCESSES_NAMES
.
CONTENT
]
|
|
[
]
}
}
;
if
(
HISTOGRAM_SUFFIXES
.
GPU
in
histograms
|
|
HISTOGRAM_SUFFIXES
.
GPU
in
keyedHistograms
|
|
INTERNAL_PROCESSES_NAMES
.
GPU
in
scalars
|
|
INTERNAL_PROCESSES_NAMES
.
GPU
in
keyedScalars
)
{
payloadObj
.
processes
.
gpu
=
{
scalars
:
scalars
[
INTERNAL_PROCESSES_NAMES
.
GPU
]
keyedScalars
:
keyedScalars
[
INTERNAL_PROCESSES_NAMES
.
GPU
]
histograms
:
histograms
[
HISTOGRAM_SUFFIXES
.
GPU
]
keyedHistograms
:
keyedHistograms
[
HISTOGRAM_SUFFIXES
.
GPU
]
events
:
events
[
INTERNAL_PROCESSES_NAMES
.
GPU
]
|
|
[
]
}
;
}
payloadObj
.
info
=
info
;
if
(
Telemetry
.
canRecordExtended
)
{
payloadObj
.
slowSQL
=
protect
(
(
)
=
>
Telemetry
.
slowSQL
)
;
payloadObj
.
fileIOReports
=
protect
(
(
)
=
>
Telemetry
.
fileIOReports
)
;
payloadObj
.
lateWrites
=
protect
(
(
)
=
>
Telemetry
.
lateWrites
)
;
let
addonHistograms
=
protect
(
(
)
=
>
this
.
getAddonHistograms
(
)
)
;
if
(
addonHistograms
&
&
Object
.
keys
(
addonHistograms
)
.
length
>
0
)
{
payloadObj
.
addonHistograms
=
addonHistograms
;
}
payloadObj
.
addonDetails
=
protect
(
(
)
=
>
AddonManagerPrivate
.
getTelemetryDetails
(
)
)
;
let
clearUIsession
=
!
(
reason
=
=
REASON_GATHER_PAYLOAD
|
|
reason
=
=
REASON_GATHER_SUBSESSION_PAYLOAD
)
;
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
payloadObj
.
UIMeasurements
=
protect
(
(
)
=
>
UITelemetry
.
getUIMeasurements
(
clearUIsession
)
)
;
}
if
(
this
.
_slowSQLStartup
&
&
Object
.
keys
(
this
.
_slowSQLStartup
)
.
length
!
=
0
&
&
(
Object
.
keys
(
this
.
_slowSQLStartup
.
mainThread
)
.
length
|
|
Object
.
keys
(
this
.
_slowSQLStartup
.
otherThreads
)
.
length
)
)
{
payloadObj
.
slowSQLStartup
=
this
.
_slowSQLStartup
;
}
if
(
!
this
.
_isClassicReason
(
reason
)
)
{
payloadObj
.
processes
.
parent
.
gc
=
protect
(
(
)
=
>
GCTelemetry
.
entries
(
"
main
"
clearSubsession
)
)
;
payloadObj
.
processes
.
content
.
gc
=
protect
(
(
)
=
>
GCTelemetry
.
entries
(
"
content
"
clearSubsession
)
)
;
}
let
stacks
=
protect
(
(
)
=
>
Telemetry
.
snapshotCapturedStacks
(
true
)
)
;
if
(
stacks
&
&
(
"
captures
"
in
stacks
)
&
&
(
stacks
.
captures
.
length
>
0
)
)
{
payloadObj
.
processes
.
parent
.
capturedStacks
=
stacks
;
}
}
if
(
this
.
_childTelemetry
.
length
)
{
payloadObj
.
childPayloads
=
protect
(
(
)
=
>
this
.
getChildPayloads
(
)
)
;
}
return
payloadObj
;
}
startNewSubsession
(
)
{
this
.
_subsessionStartDate
=
Policy
.
now
(
)
;
this
.
_subsessionStartTimeMonotonic
=
Policy
.
monotonicNow
(
)
;
this
.
_previousSubsessionId
=
this
.
_subsessionId
;
this
.
_subsessionId
=
Policy
.
generateSubsessionUUID
(
)
;
this
.
_subsessionCounter
+
+
;
this
.
_profileSubsessionCounter
+
+
;
}
getSessionPayload
:
function
getSessionPayload
(
reason
clearSubsession
)
{
this
.
_log
.
trace
(
"
getSessionPayload
-
reason
:
"
+
reason
+
"
clearSubsession
:
"
+
clearSubsession
)
;
let
payload
;
try
{
const
isMobile
=
(
AppConstants
.
platform
=
=
"
android
"
)
;
const
isSubsession
=
isMobile
?
false
:
!
this
.
_isClassicReason
(
reason
)
;
if
(
isMobile
)
{
clearSubsession
=
false
;
}
let
measurements
=
this
.
getSimpleMeasurements
(
reason
=
=
REASON_SAVED_SESSION
isSubsession
clearSubsession
)
;
let
info
=
!
Utils
.
isContentProcess
?
this
.
getMetadata
(
reason
)
:
null
;
payload
=
this
.
assemblePayloadWithMeasurements
(
measurements
info
reason
clearSubsession
)
;
}
catch
(
ex
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_ASSEMBLE_PAYLOAD_EXCEPTION
"
)
.
add
(
1
)
;
throw
ex
;
}
finally
{
if
(
!
Utils
.
isContentProcess
&
&
clearSubsession
)
{
this
.
startNewSubsession
(
)
;
let
sessionData
=
this
.
_getSessionDataObject
(
)
;
TelemetryStorage
.
saveSessionData
(
sessionData
)
;
Services
.
obs
.
notifyObservers
(
null
"
internal
-
telemetry
-
after
-
subsession
-
split
"
null
)
;
}
}
return
payload
;
}
send
:
function
send
(
reason
)
{
this
.
_log
.
trace
(
"
send
-
Reason
"
+
reason
)
;
this
.
gatherMemory
(
)
;
const
isSubsession
=
!
this
.
_isClassicReason
(
reason
)
;
let
payload
=
this
.
getSessionPayload
(
reason
isSubsession
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
return
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
;
}
attachObservers
:
function
attachObservers
(
)
{
if
(
!
this
.
_initialized
)
return
;
Services
.
obs
.
addObserver
(
this
"
idle
-
daily
"
false
)
;
if
(
Telemetry
.
canRecordExtended
)
{
Services
.
obs
.
addObserver
(
this
TOPIC_CYCLE_COLLECTOR_BEGIN
false
)
;
}
}
detachObservers
:
function
detachObservers
(
)
{
if
(
!
this
.
_initialized
)
return
;
Services
.
obs
.
removeObserver
(
this
"
idle
-
daily
"
)
;
try
{
Services
.
obs
.
removeObserver
(
this
TOPIC_CYCLE_COLLECTOR_BEGIN
)
;
}
catch
(
e
)
{
this
.
_log
.
warn
(
"
detachObservers
-
Failed
to
remove
"
+
TOPIC_CYCLE_COLLECTOR_BEGIN
e
)
;
}
}
earlyInit
(
testing
)
{
this
.
_log
.
trace
(
"
earlyInit
"
)
;
this
.
_initStarted
=
true
;
this
.
_testing
=
testing
;
if
(
this
.
_initialized
&
&
!
testing
)
{
this
.
_log
.
error
(
"
earlyInit
-
already
initialized
"
)
;
return
;
}
if
(
!
Telemetry
.
canRecordBase
&
&
!
testing
)
{
this
.
_log
.
config
(
"
earlyInit
-
Telemetry
recording
is
disabled
skipping
Chrome
process
setup
.
"
)
;
return
;
}
this
.
_sessionId
=
Policy
.
generateSessionUUID
(
)
;
this
.
startNewSubsession
(
)
;
this
.
_sessionStartDate
=
this
.
_subsessionStartDate
;
annotateCrashReport
(
this
.
_sessionId
)
;
this
.
_thirdPartyCookies
=
new
ThirdPartyCookieProbe
(
)
;
this
.
_thirdPartyCookies
.
init
(
)
;
let
previousBuildId
=
Preferences
.
get
(
PREF_PREVIOUS_BUILDID
null
)
;
let
thisBuildID
=
Services
.
appinfo
.
appBuildID
;
if
(
previousBuildId
!
=
thisBuildID
)
{
this
.
_previousBuildId
=
previousBuildId
;
Preferences
.
set
(
PREF_PREVIOUS_BUILDID
thisBuildID
)
;
}
Services
.
obs
.
addObserver
(
this
"
sessionstore
-
windows
-
restored
"
false
)
;
if
(
AppConstants
.
platform
=
=
=
"
android
"
)
{
Services
.
obs
.
addObserver
(
this
"
application
-
background
"
false
)
;
}
Services
.
obs
.
addObserver
(
this
"
xul
-
window
-
visible
"
false
)
;
this
.
_hasWindowRestoredObserver
=
true
;
this
.
_hasXulWindowVisibleObserver
=
true
;
ppml
.
addMessageListener
(
MESSAGE_TELEMETRY_PAYLOAD
this
)
;
ppml
.
addMessageListener
(
MESSAGE_TELEMETRY_THREAD_HANGS
this
)
;
ppml
.
addMessageListener
(
MESSAGE_TELEMETRY_USS
this
)
;
}
delayedInit
(
)
{
this
.
_log
.
trace
(
"
delayedInit
"
)
;
this
.
_delayedInitTask
=
(
async
function
(
)
{
try
{
this
.
_initialized
=
true
;
await
this
.
_loadSessionData
(
)
;
await
TelemetryStorage
.
saveSessionData
(
this
.
_getSessionDataObject
(
)
)
;
this
.
attachObservers
(
)
;
this
.
gatherMemory
(
)
;
if
(
Telemetry
.
canRecordExtended
)
{
GCTelemetry
.
init
(
)
;
}
Telemetry
.
asyncFetchTelemetryData
(
function
(
)
{
}
)
;
if
(
IS_UNIFIED_TELEMETRY
)
{
await
TelemetryController
.
checkAbortedSessionPing
(
)
;
if
(
!
this
.
_testing
)
{
await
this
.
_saveAbortedSessionPing
(
)
;
}
this
.
_lastEnvironmentChangeDate
=
Policy
.
monotonicNow
(
)
;
TelemetryEnvironment
.
registerChangeListener
(
ENVIRONMENT_CHANGE_LISTENER
(
reason
data
)
=
>
this
.
_onEnvironmentChange
(
reason
data
)
)
;
TelemetryScheduler
.
init
(
)
;
}
this
.
_delayedInitTask
=
null
;
}
catch
(
e
)
{
this
.
_delayedInitTask
=
null
;
throw
e
;
}
}
.
bind
(
this
)
)
(
)
;
return
this
.
_delayedInitTask
;
}
getOpenTabsCount
:
function
getOpenTabsCount
(
)
{
let
tabCount
=
0
;
let
browserEnum
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
browserEnum
.
hasMoreElements
(
)
)
{
let
win
=
browserEnum
.
getNext
(
)
;
tabCount
+
=
win
.
gBrowser
.
tabs
.
length
;
}
return
tabCount
;
}
setupContentProcess
:
function
setupContentProcess
(
testing
)
{
this
.
_log
.
trace
(
"
setupContentProcess
"
)
;
this
.
_testing
=
testing
;
if
(
!
Telemetry
.
canRecordBase
)
{
this
.
_log
.
trace
(
"
setupContentProcess
-
base
recording
is
disabled
not
initializing
"
)
;
return
;
}
Services
.
obs
.
addObserver
(
this
"
content
-
child
-
shutdown
"
false
)
;
cpml
.
addMessageListener
(
MESSAGE_TELEMETRY_GET_CHILD_THREAD_HANGS
this
)
;
cpml
.
addMessageListener
(
MESSAGE_TELEMETRY_GET_CHILD_USS
this
)
;
let
delayedTask
=
new
DeferredTask
(
function
*
(
)
{
this
.
_initialized
=
true
;
this
.
attachObservers
(
)
;
this
.
gatherMemory
(
)
;
if
(
Telemetry
.
canRecordExtended
)
{
GCTelemetry
.
init
(
)
;
}
}
.
bind
(
this
)
testing
?
TELEMETRY_TEST_DELAY
:
TELEMETRY_DELAY
)
;
delayedTask
.
arm
(
)
;
}
getFlashVersion
:
function
getFlashVersion
(
)
{
let
host
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
let
tags
=
host
.
getPluginTags
(
)
;
for
(
let
i
=
0
;
i
<
tags
.
length
;
i
+
+
)
{
if
(
tags
[
i
]
.
name
=
=
"
Shockwave
Flash
"
)
return
tags
[
i
]
.
version
;
}
return
null
;
}
receiveMessage
:
function
receiveMessage
(
message
)
{
this
.
_log
.
trace
(
"
receiveMessage
-
Message
name
"
+
message
.
name
)
;
switch
(
message
.
name
)
{
case
MESSAGE_TELEMETRY_PAYLOAD
:
{
let
source
=
message
.
data
.
childUUID
;
delete
message
.
data
.
childUUID
;
this
.
_childTelemetry
.
push
(
{
source
payload
:
message
.
data
}
)
;
if
(
this
.
_childTelemetry
.
length
=
=
MAX_NUM_CONTENT_PAYLOADS
+
1
)
{
this
.
_childTelemetry
.
shift
(
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_DISCARDED_CONTENT_PINGS_COUNT
"
)
.
add
(
)
;
}
break
;
}
case
MESSAGE_TELEMETRY_THREAD_HANGS
:
{
this
.
_childThreadHangs
.
push
(
message
.
data
)
;
if
(
this
.
_childThreadHangs
.
length
=
=
=
Math
.
min
(
this
.
_childCount
ppmm
.
childCount
)
)
{
clearTimeout
(
this
.
_childThreadHangsTimeout
)
;
for
(
let
resolve
of
this
.
_childThreadHangsResolveFunctions
)
{
resolve
(
this
.
_childThreadHangs
)
;
}
this
.
_childThreadHangsResolveFunctions
=
[
]
;
}
break
;
}
case
MESSAGE_TELEMETRY_GET_CHILD_THREAD_HANGS
:
{
this
.
sendContentProcessThreadHangs
(
)
;
break
;
}
case
MESSAGE_TELEMETRY_USS
:
{
if
(
this
.
_totalMemoryTimeout
&
&
this
.
_childrenToHearFrom
.
delete
(
message
.
data
.
id
)
)
{
let
uss
=
message
.
data
.
bytes
;
this
.
_totalMemory
+
=
uss
;
this
.
_USSFromChildProcesses
.
push
(
uss
)
;
if
(
this
.
_childrenToHearFrom
.
size
=
=
0
)
{
clearTimeout
(
this
.
_totalMemoryTimeout
)
;
this
.
_totalMemoryTimeout
=
undefined
;
this
.
handleMemoryReport
(
"
MEMORY_TOTAL
"
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
this
.
_totalMemory
)
;
let
length
=
this
.
_USSFromChildProcesses
.
length
;
if
(
length
>
1
)
{
let
mean
=
this
.
_USSFromChildProcesses
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
/
length
;
let
diffs
=
this
.
_USSFromChildProcesses
.
map
(
value
=
>
Math
.
floor
(
Math
.
abs
(
value
-
mean
)
*
100
/
mean
)
)
;
let
tabsCount
=
this
.
getOpenTabsCount
(
)
;
let
key
;
if
(
tabsCount
<
11
)
{
key
=
"
0
-
10
tabs
"
;
}
else
if
(
tabsCount
<
501
)
{
key
=
"
11
-
500
tabs
"
;
}
else
{
key
=
"
more
tabs
"
;
}
diffs
.
forEach
(
value
=
>
{
this
.
handleMemoryReport
(
"
MEMORY_DISTRIBUTION_AMONG_CONTENT
"
Ci
.
nsIMemoryReporter
.
UNITS_COUNT
value
key
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
gather
-
memory
-
telemetry
-
finished
"
null
)
;
}
this
.
_USSFromChildProcesses
=
undefined
;
}
}
else
{
this
.
_log
.
trace
(
"
Child
USS
report
was
missed
"
)
;
}
break
;
}
case
MESSAGE_TELEMETRY_GET_CHILD_USS
:
{
this
.
sendContentProcessUSS
(
message
.
data
.
id
)
;
break
}
default
:
throw
new
Error
(
"
Telemetry
.
receiveMessage
:
bad
message
name
"
)
;
}
}
_processUUID
:
generateUUID
(
)
sendContentProcessUSS
:
function
sendContentProcessUSS
(
aMessageId
)
{
this
.
_log
.
trace
(
"
sendContentProcessUSS
"
)
;
let
mgr
;
try
{
mgr
=
Cc
[
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIMemoryReporterManager
)
;
}
catch
(
e
)
{
return
;
}
cpmm
.
sendAsyncMessage
(
MESSAGE_TELEMETRY_USS
{
bytes
:
mgr
.
residentUnique
id
:
aMessageId
}
)
;
}
sendContentProcessPing
:
function
sendContentProcessPing
(
reason
)
{
this
.
_log
.
trace
(
"
sendContentProcessPing
-
Reason
"
+
reason
)
;
const
isSubsession
=
!
this
.
_isClassicReason
(
reason
)
;
let
payload
=
this
.
getSessionPayload
(
reason
isSubsession
)
;
payload
.
childUUID
=
this
.
_processUUID
;
cpmm
.
sendAsyncMessage
(
MESSAGE_TELEMETRY_PAYLOAD
payload
)
;
}
sendContentProcessThreadHangs
:
function
sendContentProcessThreadHangs
(
)
{
this
.
_log
.
trace
(
"
sendContentProcessThreadHangs
"
)
;
let
payload
=
{
childUUID
:
this
.
_processUUID
hangs
:
Telemetry
.
threadHangStats
}
;
cpmm
.
sendAsyncMessage
(
MESSAGE_TELEMETRY_THREAD_HANGS
payload
)
;
}
saveShutdownPings
(
)
{
this
.
_log
.
trace
(
"
saveShutdownPings
"
)
;
let
p
=
[
]
;
if
(
IS_UNIFIED_TELEMETRY
)
{
let
shutdownPayload
=
this
.
getSessionPayload
(
REASON_SHUTDOWN
false
)
;
let
sendWithPingsender
=
Preferences
.
get
(
PREF_SHUTDOWN_PINGSENDER
true
)
&
&
!
TelemetryReportingPolicy
.
isFirstRun
(
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
usePingSender
:
sendWithPingsender
}
;
p
.
push
(
TelemetryController
.
submitExternalPing
(
getPingType
(
shutdownPayload
)
shutdownPayload
options
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
saveShutdownPings
-
failed
to
submit
shutdown
ping
"
e
)
)
)
;
}
if
(
Telemetry
.
canRecordExtended
)
{
let
payload
=
this
.
getSessionPayload
(
REASON_SAVED_SESSION
false
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
p
.
push
(
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
saveShutdownPings
-
failed
to
submit
saved
-
session
ping
"
e
)
)
)
;
}
return
Promise
.
all
(
p
)
;
}
testSavePendingPing
(
)
{
let
payload
=
this
.
getSessionPayload
(
REASON_SAVED_SESSION
false
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
overwrite
:
true
}
;
return
TelemetryController
.
addPendingPing
(
getPingType
(
payload
)
payload
options
)
;
}
uninstall
:
function
uninstall
(
)
{
this
.
detachObservers
(
)
;
if
(
this
.
_hasWindowRestoredObserver
)
{
Services
.
obs
.
removeObserver
(
this
"
sessionstore
-
windows
-
restored
"
)
;
this
.
_hasWindowRestoredObserver
=
false
;
}
if
(
this
.
_hasXulWindowVisibleObserver
)
{
Services
.
obs
.
removeObserver
(
this
"
xul
-
window
-
visible
"
)
;
this
.
_hasXulWindowVisibleObserver
=
false
;
}
if
(
AppConstants
.
platform
=
=
=
"
android
"
)
{
Services
.
obs
.
removeObserver
(
this
"
application
-
background
"
)
;
}
GCTelemetry
.
shutdown
(
)
;
}
getPayload
:
function
getPayload
(
reason
clearSubsession
)
{
this
.
_log
.
trace
(
"
getPayload
-
clearSubsession
:
"
+
clearSubsession
)
;
reason
=
reason
|
|
REASON_GATHER_PAYLOAD
;
if
(
Object
.
keys
(
this
.
_slowSQLStartup
)
.
length
=
=
0
)
{
this
.
_slowSQLStartup
=
Telemetry
.
slowSQL
;
}
this
.
gatherMemory
(
)
;
return
this
.
getSessionPayload
(
reason
clearSubsession
)
;
}
getChildThreadHangs
:
function
getChildThreadHangs
(
)
{
return
new
Promise
(
(
resolve
)
=
>
{
if
(
ppmm
.
childCount
=
=
=
0
)
{
resolve
(
[
]
)
;
return
;
}
this
.
_childThreadHangsResolveFunctions
.
push
(
(
threadHangStats
)
=
>
{
let
hangs
=
threadHangStats
.
map
(
child
=
>
child
.
hangs
)
;
return
resolve
(
hangs
)
;
}
)
;
if
(
this
.
_childThreadHangsResolveFunctions
.
length
=
=
=
1
)
{
this
.
_childCount
=
ppmm
.
childCount
;
this
.
_childThreadHangs
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
_childCount
;
i
+
+
)
{
ppmm
.
getChildAt
(
i
)
.
sendAsyncMessage
(
MESSAGE_TELEMETRY_GET_CHILD_THREAD_HANGS
)
;
}
this
.
_childThreadHangsTimeout
=
setTimeout
(
(
)
=
>
{
for
(
let
resolve
of
this
.
_childThreadHangsResolveFunctions
)
{
resolve
(
this
.
_childThreadHangs
)
;
}
this
.
_childThreadHangsResolveFunctions
=
[
]
;
}
200
)
;
}
}
)
;
}
gatherStartup
:
function
gatherStartup
(
)
{
this
.
_log
.
trace
(
"
gatherStartup
"
)
;
let
counters
=
processInfo
.
getCounters
(
)
;
if
(
counters
)
{
[
this
.
_startupIO
.
startupSessionRestoreReadBytes
this
.
_startupIO
.
startupSessionRestoreWriteBytes
]
=
counters
;
}
this
.
_slowSQLStartup
=
Telemetry
.
slowSQL
;
}
setAddOns
:
function
setAddOns
(
aAddOns
)
{
this
.
_addons
=
aAddOns
;
}
testPing
:
function
testPing
(
)
{
return
this
.
send
(
REASON_TEST_PING
)
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
!
=
TOPIC_CYCLE_COLLECTOR_BEGIN
)
{
this
.
_log
.
trace
(
"
observe
-
"
+
aTopic
+
"
notified
.
"
)
;
}
switch
(
aTopic
)
{
case
"
content
-
child
-
shutdown
"
:
Services
.
obs
.
removeObserver
(
this
"
content
-
child
-
shutdown
"
)
;
this
.
uninstall
(
)
;
Telemetry
.
flushBatchedChildTelemetry
(
)
;
this
.
sendContentProcessPing
(
REASON_SAVED_SESSION
)
;
break
;
case
TOPIC_CYCLE_COLLECTOR_BEGIN
:
let
now
=
new
Date
(
)
;
if
(
!
gLastMemoryPoll
|
|
(
TELEMETRY_INTERVAL
<
=
now
-
gLastMemoryPoll
)
)
{
gLastMemoryPoll
=
now
;
this
.
gatherMemory
(
)
;
}
break
;
case
"
xul
-
window
-
visible
"
:
Services
.
obs
.
removeObserver
(
this
"
xul
-
window
-
visible
"
)
;
this
.
_hasXulWindowVisibleObserver
=
false
;
var
counters
=
processInfo
.
getCounters
(
)
;
if
(
counters
)
{
[
this
.
_startupIO
.
startupWindowVisibleReadBytes
this
.
_startupIO
.
startupWindowVisibleWriteBytes
]
=
counters
;
}
break
;
case
"
sessionstore
-
windows
-
restored
"
:
Services
.
obs
.
removeObserver
(
this
"
sessionstore
-
windows
-
restored
"
)
;
this
.
_hasWindowRestoredObserver
=
false
;
let
debugService
=
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
;
gWasDebuggerAttached
=
debugService
.
isDebuggerAttached
;
this
.
gatherStartup
(
)
;
break
;
case
"
idle
-
daily
"
:
Services
.
tm
.
dispatchToMainThread
(
(
function
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
gather
-
telemetry
"
null
)
;
}
)
)
;
break
;
case
"
application
-
background
"
:
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
break
;
}
let
payload
=
this
.
getSessionPayload
(
REASON_SAVED_SESSION
false
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
overwrite
:
true
}
;
TelemetryController
.
addPendingPing
(
getPingType
(
payload
)
payload
options
)
;
break
;
}
return
undefined
;
}
shutdownChromeProcess
(
)
{
this
.
_log
.
trace
(
"
shutdownChromeProcess
"
)
;
let
cleanup
=
(
)
=
>
{
if
(
IS_UNIFIED_TELEMETRY
)
{
TelemetryEnvironment
.
unregisterChangeListener
(
ENVIRONMENT_CHANGE_LISTENER
)
;
TelemetryScheduler
.
shutdown
(
)
;
}
this
.
uninstall
(
)
;
let
reset
=
(
)
=
>
{
this
.
_initStarted
=
false
;
this
.
_initialized
=
false
;
}
;
return
(
async
function
(
)
{
await
this
.
saveShutdownPings
(
)
;
if
(
IS_UNIFIED_TELEMETRY
)
{
await
TelemetryController
.
removeAbortedSessionPing
(
)
;
}
reset
(
)
;
}
.
bind
(
this
)
)
(
)
;
}
;
if
(
!
this
.
_initStarted
)
{
return
Promise
.
resolve
(
)
;
}
if
(
!
this
.
_delayedInitTask
)
{
return
cleanup
(
)
;
}
return
this
.
_delayedInitTask
.
then
(
cleanup
)
;
}
_sendDailyPing
(
)
{
this
.
_log
.
trace
(
"
_sendDailyPing
"
)
;
let
payload
=
this
.
getSessionPayload
(
REASON_DAILY
true
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
let
promise
=
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
;
if
(
IS_UNIFIED_TELEMETRY
)
{
this
.
_saveAbortedSessionPing
(
payload
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
_sendDailyPing
-
Failed
to
save
the
aborted
session
ping
"
e
)
)
;
}
return
promise
;
}
async
_loadSessionData
(
)
{
let
data
=
await
TelemetryStorage
.
loadSessionData
(
)
;
if
(
!
data
)
{
return
null
;
}
if
(
!
(
"
profileSubsessionCounter
"
in
data
)
|
|
!
(
typeof
(
data
.
profileSubsessionCounter
)
=
=
"
number
"
)
|
|
!
(
"
subsessionId
"
in
data
)
|
|
!
(
"
sessionId
"
in
data
)
)
{
this
.
_log
.
error
(
"
_loadSessionData
-
session
data
is
invalid
"
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_SESSIONDATA_FAILED_VALIDATION
"
)
.
add
(
1
)
;
return
null
;
}
this
.
_previousSessionId
=
data
.
sessionId
;
this
.
_previousSubsessionId
=
data
.
subsessionId
;
this
.
_profileSubsessionCounter
=
data
.
profileSubsessionCounter
+
this
.
_subsessionCounter
;
return
data
;
}
_getSessionDataObject
(
)
{
return
{
sessionId
:
this
.
_sessionId
subsessionId
:
this
.
_subsessionId
profileSubsessionCounter
:
this
.
_profileSubsessionCounter
}
;
}
_onEnvironmentChange
(
reason
oldEnvironment
)
{
this
.
_log
.
trace
(
"
_onEnvironmentChange
"
reason
)
;
let
now
=
Policy
.
monotonicNow
(
)
;
let
timeDelta
=
now
-
this
.
_lastEnvironmentChangeDate
;
if
(
timeDelta
<
=
MIN_SUBSESSION_LENGTH_MS
)
{
this
.
_log
.
trace
(
_onEnvironmentChange
-
throttling
;
last
change
was
{
Math
.
round
(
timeDelta
/
1000
)
}
s
ago
.
)
;
return
;
}
this
.
_lastEnvironmentChangeDate
=
now
;
let
payload
=
this
.
getSessionPayload
(
REASON_ENVIRONMENT_CHANGE
true
)
;
TelemetryScheduler
.
reschedulePings
(
REASON_ENVIRONMENT_CHANGE
payload
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
overrideEnvironment
:
oldEnvironment
}
;
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
;
}
_isClassicReason
(
reason
)
{
const
classicReasons
=
[
REASON_SAVED_SESSION
REASON_GATHER_PAYLOAD
REASON_TEST_PING
]
;
return
classicReasons
.
includes
(
reason
)
;
}
_getState
(
)
{
return
{
initialized
:
this
.
_initialized
initStarted
:
this
.
_initStarted
haveDelayedInitTask
:
!
!
this
.
_delayedInitTask
}
;
}
_saveAbortedSessionPing
(
aProvidedPayload
=
null
)
{
this
.
_log
.
trace
(
"
_saveAbortedSessionPing
"
)
;
let
payload
=
null
;
if
(
aProvidedPayload
)
{
payload
=
Cu
.
cloneInto
(
aProvidedPayload
myScope
)
;
payload
.
info
.
reason
=
REASON_ABORTED_SESSION
;
}
else
{
payload
=
this
.
getSessionPayload
(
REASON_ABORTED_SESSION
false
)
;
}
return
TelemetryController
.
saveAbortedSessionPing
(
payload
)
;
}
}
;
