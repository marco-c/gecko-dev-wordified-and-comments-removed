"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
TelemetrySend
:
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
jsm
"
AddonManagerPrivate
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
TelemetryController
:
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
TelemetryStorage
:
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
TelemetryLog
:
"
resource
:
/
/
gre
/
modules
/
TelemetryLog
.
jsm
"
UITelemetry
:
"
resource
:
/
/
gre
/
modules
/
UITelemetry
.
jsm
"
GCTelemetry
:
"
resource
:
/
/
gre
/
modules
/
GCTelemetry
.
jsm
"
TelemetryEnvironment
:
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
TelemetryReportingPolicy
:
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
}
)
;
const
Utils
=
TelemetryUtils
;
const
myScope
=
this
;
const
PAYLOAD_VERSION
=
4
;
const
PING_TYPE_MAIN
=
"
main
"
;
const
PING_TYPE_SAVED_SESSION
=
"
saved
-
session
"
;
const
REASON_ABORTED_SESSION
=
"
aborted
-
session
"
;
const
REASON_DAILY
=
"
daily
"
;
const
REASON_SAVED_SESSION
=
"
saved
-
session
"
;
const
REASON_GATHER_PAYLOAD
=
"
gather
-
payload
"
;
const
REASON_GATHER_SUBSESSION_PAYLOAD
=
"
gather
-
subsession
-
payload
"
;
const
REASON_TEST_PING
=
"
test
-
ping
"
;
const
REASON_ENVIRONMENT_CHANGE
=
"
environment
-
change
"
;
const
REASON_SHUTDOWN
=
"
shutdown
"
;
const
ENVIRONMENT_CHANGE_LISTENER
=
"
TelemetrySession
:
:
onEnvironmentChange
"
;
const
MIN_SUBSESSION_LENGTH_MS
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
minSubsessionLength
"
5
*
60
)
*
1000
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
LOGGER_PREFIX
=
"
TelemetrySession
"
+
(
Utils
.
isContentProcess
?
"
#
content
:
:
"
:
"
:
:
"
)
;
const
MESSAGE_TELEMETRY_PAYLOAD
=
"
Telemetry
:
Payload
"
;
const
MESSAGE_TELEMETRY_USS
=
"
Telemetry
:
USS
"
;
const
MESSAGE_TELEMETRY_GET_CHILD_USS
=
"
Telemetry
:
GetChildUSS
"
;
const
IS_UNIFIED_TELEMETRY
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
const
MAX_NUM_CONTENT_PAYLOADS
=
10
;
const
TELEMETRY_INTERVAL
=
60
*
1000
;
const
TELEMETRY_DELAY
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
initDelay
"
60
)
*
1000
;
const
TELEMETRY_TEST_DELAY
=
1
;
const
SCHEDULER_TICK_INTERVAL_MS
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
scheduler
.
tickInterval
"
5
*
60
)
*
1000
;
const
SCHEDULER_TICK_IDLE_INTERVAL_MS
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
scheduler
.
idleTickInterval
"
60
*
60
)
*
1000
;
const
SCHEDULER_MIDNIGHT_TOLERANCE_MS
=
15
*
60
*
1000
;
const
SCHEDULER_TICK_MAX_IDLE_DELAY_MS
=
60
*
1000
;
const
IDLE_TIMEOUT_SECONDS
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
idleTimeout
"
5
*
60
)
;
const
ABORTED_SESSION_UPDATE_INTERVAL_MS
=
5
*
60
*
1000
;
const
TOPIC_CYCLE_COLLECTOR_BEGIN
=
"
cycle
-
collector
-
begin
"
;
const
TOTAL_MEMORY_COLLECTOR_TIMEOUT
=
200
;
var
gLastMemoryPoll
=
null
;
var
gWasDebuggerAttached
=
false
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
Telemetry
:
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
"
nsITelemetry
"
]
idleService
:
[
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
"
nsIIdleService
"
]
}
)
;
function
generateUUID
(
)
{
let
str
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
return
str
.
substring
(
1
str
.
length
-
1
)
;
}
function
getMsSinceProcessStart
(
)
{
try
{
return
Telemetry
.
msSinceProcessStart
(
)
;
}
catch
(
ex
)
{
return
-
1
;
}
}
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
monotonicNow
:
getMsSinceProcessStart
generateSessionUUID
:
(
)
=
>
generateUUID
(
)
generateSubsessionUUID
:
(
)
=
>
generateUUID
(
)
setSchedulerTickTimeout
:
(
callback
delayMs
)
=
>
setTimeout
(
callback
delayMs
)
clearSchedulerTickTimeout
:
id
=
>
clearTimeout
(
id
)
}
;
function
getPingType
(
aPayload
)
{
if
(
aPayload
.
info
.
reason
=
=
REASON_SAVED_SESSION
)
{
return
PING_TYPE_SAVED_SESSION
;
}
return
PING_TYPE_MAIN
;
}
function
annotateCrashReport
(
sessionId
)
{
try
{
const
cr
=
Cc
[
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
]
;
if
(
cr
)
{
cr
.
getService
(
Ci
.
nsICrashReporter
)
.
setTelemetrySessionId
(
sessionId
)
;
}
}
catch
(
e
)
{
}
}
var
processInfo
=
{
_initialized
:
false
_IO_COUNTERS
:
null
_kernel32
:
null
_GetProcessIoCounters
:
null
_GetCurrentProcess
:
null
getCounters
(
)
{
let
isWindows
=
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
in
Cc
)
;
if
(
isWindows
)
return
this
.
getCounters_Windows
(
)
;
return
null
;
}
getCounters_Windows
(
)
{
if
(
!
this
.
_initialized
)
{
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
this
.
_IO_COUNTERS
=
new
ctypes
.
StructType
(
"
IO_COUNTERS
"
[
{
"
readOps
"
:
ctypes
.
unsigned_long_long
}
{
"
writeOps
"
:
ctypes
.
unsigned_long_long
}
{
"
otherOps
"
:
ctypes
.
unsigned_long_long
}
{
"
readBytes
"
:
ctypes
.
unsigned_long_long
}
{
"
writeBytes
"
:
ctypes
.
unsigned_long_long
}
{
"
otherBytes
"
:
ctypes
.
unsigned_long_long
}
]
)
;
try
{
this
.
_kernel32
=
ctypes
.
open
(
"
Kernel32
.
dll
"
)
;
this
.
_GetProcessIoCounters
=
this
.
_kernel32
.
declare
(
"
GetProcessIoCounters
"
ctypes
.
winapi_abi
ctypes
.
bool
ctypes
.
voidptr_t
this
.
_IO_COUNTERS
.
ptr
)
;
this
.
_GetCurrentProcess
=
this
.
_kernel32
.
declare
(
"
GetCurrentProcess
"
ctypes
.
winapi_abi
ctypes
.
voidptr_t
)
;
this
.
_initialized
=
true
;
}
catch
(
err
)
{
return
null
;
}
}
let
io
=
new
this
.
_IO_COUNTERS
(
)
;
if
(
!
this
.
_GetProcessIoCounters
(
this
.
_GetCurrentProcess
(
)
io
.
address
(
)
)
)
return
null
;
return
[
parseInt
(
io
.
readBytes
)
parseInt
(
io
.
writeBytes
)
]
;
}
}
;
var
TelemetryScheduler
=
{
_lastDailyPingTime
:
0
_lastSessionCheckpointTime
:
0
_lastAdhocPingTime
:
0
_lastTickTime
:
0
_log
:
null
_schedulerTimer
:
null
_schedulerInterval
:
0
_shuttingDown
:
true
_isUserIdle
:
false
init
(
)
{
this
.
_log
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
"
TelemetryScheduler
:
:
"
)
;
this
.
_log
.
trace
(
"
init
"
)
;
this
.
_shuttingDown
=
false
;
this
.
_isUserIdle
=
false
;
let
now
=
Policy
.
now
(
)
;
this
.
_lastDailyPingTime
=
now
.
getTime
(
)
;
this
.
_lastSessionCheckpointTime
=
now
.
getTime
(
)
;
this
.
_rescheduleTimeout
(
)
;
idleService
.
addIdleObserver
(
this
IDLE_TIMEOUT_SECONDS
)
;
Services
.
obs
.
addObserver
(
this
"
wake_notification
"
)
;
}
shutdown
(
)
{
if
(
this
.
_shuttingDown
)
{
if
(
this
.
_log
)
{
this
.
_log
.
error
(
"
shutdown
-
Already
shut
down
"
)
;
}
else
{
Cu
.
reportError
(
"
TelemetryScheduler
.
shutdown
-
Already
shut
down
"
)
;
}
return
;
}
this
.
_log
.
trace
(
"
shutdown
"
)
;
if
(
this
.
_schedulerTimer
)
{
Policy
.
clearSchedulerTickTimeout
(
this
.
_schedulerTimer
)
;
this
.
_schedulerTimer
=
null
;
}
idleService
.
removeIdleObserver
(
this
IDLE_TIMEOUT_SECONDS
)
;
Services
.
obs
.
removeObserver
(
this
"
wake_notification
"
)
;
this
.
_shuttingDown
=
true
;
}
_clearTimeout
(
)
{
if
(
this
.
_schedulerTimer
)
{
Policy
.
clearSchedulerTickTimeout
(
this
.
_schedulerTimer
)
;
}
}
_rescheduleTimeout
(
)
{
this
.
_log
.
trace
(
"
_rescheduleTimeout
-
isUserIdle
:
"
+
this
.
_isUserIdle
)
;
if
(
this
.
_shuttingDown
)
{
this
.
_log
.
warn
(
"
_rescheduleTimeout
-
already
shutdown
"
)
;
return
;
}
this
.
_clearTimeout
(
)
;
const
now
=
Policy
.
now
(
)
;
let
timeout
=
SCHEDULER_TICK_INTERVAL_MS
;
if
(
this
.
_isUserIdle
)
{
timeout
=
SCHEDULER_TICK_IDLE_INTERVAL_MS
;
const
nextMidnight
=
Utils
.
getNextMidnight
(
now
)
;
timeout
=
Math
.
min
(
timeout
nextMidnight
.
getTime
(
)
-
now
.
getTime
(
)
)
;
}
this
.
_log
.
trace
(
"
_rescheduleTimeout
-
scheduling
next
tick
for
"
+
new
Date
(
now
.
getTime
(
)
+
timeout
)
)
;
this
.
_schedulerTimer
=
Policy
.
setSchedulerTickTimeout
(
(
)
=
>
this
.
_onSchedulerTick
(
)
timeout
)
;
}
_sentDailyPingToday
(
nowDate
)
{
const
todayDate
=
Utils
.
truncateToDays
(
nowDate
)
;
return
(
this
.
_lastDailyPingTime
>
=
todayDate
.
getTime
(
)
)
;
}
_isDailyPingDue
(
nowDate
)
{
if
(
this
.
_sentDailyPingToday
(
nowDate
)
)
{
this
.
_log
.
trace
(
"
_isDailyPingDue
-
already
sent
one
today
"
)
;
return
false
;
}
const
timeSinceLastDaily
=
nowDate
.
getTime
(
)
-
this
.
_lastDailyPingTime
;
if
(
timeSinceLastDaily
<
MIN_SUBSESSION_LENGTH_MS
)
{
this
.
_log
.
trace
(
"
_isDailyPingDue
-
delaying
daily
to
keep
minimum
session
length
"
)
;
return
false
;
}
this
.
_log
.
trace
(
"
_isDailyPingDue
-
is
due
"
)
;
return
true
;
}
_saveAbortedPing
(
now
competingPayload
=
null
)
{
this
.
_lastSessionCheckpointTime
=
now
;
return
Impl
.
_saveAbortedSessionPing
(
competingPayload
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
_saveAbortedPing
-
Failed
"
e
)
)
;
}
observe
(
aSubject
aTopic
aData
)
{
this
.
_log
.
trace
(
"
observe
-
aTopic
:
"
+
aTopic
)
;
switch
(
aTopic
)
{
case
"
idle
"
:
this
.
_isUserIdle
=
true
;
return
this
.
_onSchedulerTick
(
)
;
case
"
active
"
:
this
.
_isUserIdle
=
false
;
return
this
.
_onSchedulerTick
(
true
)
;
case
"
wake_notification
"
:
return
this
.
_onSchedulerTick
(
true
)
;
}
return
undefined
;
}
_makeIdleDispatch
(
dispatchFn
)
{
this
.
_log
.
trace
(
"
_makeIdleDispatch
"
)
;
let
fn
=
dispatchFn
;
let
l
=
(
msg
)
=
>
this
.
_log
.
trace
(
msg
)
;
return
{
cancel
(
)
{
fn
=
undefined
;
}
dispatch
(
resolve
reject
)
{
l
(
"
_makeIdleDispatch
.
dispatch
-
!
!
fn
:
"
+
!
!
fn
)
;
if
(
!
fn
)
{
return
Promise
.
resolve
(
)
.
then
(
resolve
reject
)
;
}
return
fn
(
resolve
reject
)
;
}
}
;
}
_onSchedulerTick
(
dispatchOnIdle
=
false
)
{
this
.
_log
.
trace
(
"
_onSchedulerTick
-
dispatchOnIdle
:
"
+
dispatchOnIdle
)
;
this
.
_clearTimeout
(
)
;
if
(
this
.
_idleDispatch
)
{
this
.
_idleDispatch
.
cancel
(
)
;
}
if
(
this
.
_shuttingDown
)
{
this
.
_log
.
warn
(
"
_onSchedulerTick
-
already
shutdown
.
"
)
;
return
Promise
.
reject
(
new
Error
(
"
Already
shutdown
.
"
)
)
;
}
let
promise
=
Promise
.
resolve
(
)
;
try
{
if
(
dispatchOnIdle
)
{
this
.
_idleDispatch
=
this
.
_makeIdleDispatch
(
(
resolve
reject
)
=
>
{
this
.
_log
.
trace
(
"
_onSchedulerTick
-
ildeDispatchToMainThread
dispatch
"
)
;
return
this
.
_schedulerTickLogic
(
)
.
then
(
resolve
reject
)
;
}
)
;
promise
=
new
Promise
(
(
resolve
reject
)
=
>
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
return
this
.
_idleDispatch
?
this
.
_idleDispatch
.
dispatch
(
resolve
reject
)
:
Promise
.
resolve
(
)
.
then
(
resolve
reject
)
;
}
SCHEDULER_TICK_MAX_IDLE_DELAY_MS
)
)
;
}
else
{
promise
=
this
.
_schedulerTickLogic
(
)
;
}
}
catch
(
e
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_SCHEDULER_TICK_EXCEPTION
"
)
.
add
(
1
)
;
this
.
_log
.
error
(
"
_onSchedulerTick
-
There
was
an
exception
"
e
)
;
}
finally
{
this
.
_rescheduleTimeout
(
)
;
}
return
promise
;
}
_schedulerTickLogic
(
)
{
this
.
_log
.
trace
(
"
_schedulerTickLogic
"
)
;
let
nowDate
=
Policy
.
now
(
)
;
let
now
=
nowDate
.
getTime
(
)
;
if
(
(
now
-
this
.
_lastTickTime
)
>
(
1
.
1
*
SCHEDULER_TICK_INTERVAL_MS
)
&
&
(
this
.
_lastTickTime
!
=
0
)
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_SCHEDULER_WAKEUP
"
)
.
add
(
1
)
;
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
First
scheduler
tick
after
sleep
.
"
)
;
}
this
.
_lastTickTime
=
now
;
const
shouldSendDaily
=
this
.
_isDailyPingDue
(
nowDate
)
;
if
(
shouldSendDaily
)
{
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
Daily
ping
due
.
"
)
;
this
.
_lastDailyPingTime
=
now
;
return
Impl
.
_sendDailyPing
(
)
;
}
const
isAbortedPingDue
=
(
now
-
this
.
_lastSessionCheckpointTime
)
>
=
ABORTED_SESSION_UPDATE_INTERVAL_MS
;
if
(
isAbortedPingDue
)
{
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
Aborted
session
ping
due
.
"
)
;
return
this
.
_saveAbortedPing
(
now
)
;
}
this
.
_log
.
trace
(
"
_schedulerTickLogic
-
No
ping
due
.
"
)
;
return
Promise
.
resolve
(
)
;
}
reschedulePings
(
reason
competingPayload
=
null
)
{
if
(
this
.
_shuttingDown
)
{
this
.
_log
.
error
(
"
reschedulePings
-
already
shutdown
"
)
;
return
;
}
this
.
_log
.
trace
(
"
reschedulePings
-
reason
:
"
+
reason
)
;
let
now
=
Policy
.
now
(
)
;
this
.
_lastAdhocPingTime
=
now
.
getTime
(
)
;
if
(
reason
=
=
REASON_ENVIRONMENT_CHANGE
)
{
this
.
_saveAbortedPing
(
now
.
getTime
(
)
competingPayload
)
;
let
nearestMidnight
=
Utils
.
getNearestMidnight
(
now
SCHEDULER_MIDNIGHT_TOLERANCE_MS
)
;
if
(
nearestMidnight
)
{
this
.
_lastDailyPingTime
=
now
.
getTime
(
)
;
}
}
this
.
_rescheduleTimeout
(
)
;
}
}
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetrySession
"
]
;
var
TelemetrySession
=
Object
.
freeze
(
{
testPing
(
)
{
return
Impl
.
testPing
(
)
;
}
getPayload
(
reason
clearSubsession
=
false
)
{
return
Impl
.
getPayload
(
reason
clearSubsession
)
;
}
testSavePendingPing
(
)
{
return
Impl
.
testSavePendingPing
(
)
;
}
gatherStartup
(
)
{
return
Impl
.
gatherStartup
(
)
;
}
setAddOns
(
aAddOns
)
{
return
Impl
.
setAddOns
(
aAddOns
)
;
}
getMetadata
(
reason
)
{
return
Impl
.
getMetadata
(
reason
)
;
}
testReset
(
)
{
Impl
.
_newProfilePingSent
=
false
;
Impl
.
_sessionId
=
null
;
Impl
.
_subsessionId
=
null
;
Impl
.
_previousSessionId
=
null
;
Impl
.
_previousSubsessionId
=
null
;
Impl
.
_subsessionCounter
=
0
;
Impl
.
_profileSubsessionCounter
=
0
;
Impl
.
_subsessionStartActiveTicks
=
0
;
Impl
.
_sessionActiveTicks
=
0
;
Impl
.
_isUserActive
=
true
;
Impl
.
_subsessionStartTimeMonotonic
=
0
;
Impl
.
_lastEnvironmentChangeDate
=
Policy
.
monotonicNow
(
)
;
this
.
testUninstall
(
)
;
}
shutdown
(
)
{
return
Impl
.
shutdownChromeProcess
(
)
;
}
setupContent
(
testing
=
false
)
{
return
Impl
.
setupContentProcess
(
testing
)
;
}
testUninstall
(
)
{
try
{
Impl
.
uninstall
(
)
;
}
catch
(
ex
)
{
}
}
earlyInit
(
aTesting
=
false
)
{
return
Impl
.
earlyInit
(
aTesting
)
;
}
delayedInit
(
)
{
return
Impl
.
delayedInit
(
)
;
}
observe
(
aSubject
aTopic
aData
)
{
return
Impl
.
observe
(
aSubject
aTopic
aData
)
;
}
markNewProfilePingSent
(
)
{
return
Impl
.
markNewProfilePingSent
(
)
;
}
get
newProfilePingSent
(
)
{
return
Impl
.
_newProfilePingSent
;
}
}
)
;
var
Impl
=
{
_initialized
:
false
_logger
:
null
_prevValues
:
{
}
_slowSQLStartup
:
{
}
_isUserActive
:
true
_startupIO
:
{
}
_previousBuildId
:
null
_childTelemetry
:
[
]
_sessionId
:
null
_subsessionId
:
null
_previousSessionId
:
null
_previousSubsessionId
:
null
_subsessionCounter
:
0
_profileSubsessionCounter
:
0
_subsessionStartDate
:
null
_subsessionStartTimeMonotonic
:
0
_subsessionStartActiveTicks
:
0
_sessionActiveTicks
:
0
_delayedInitTask
:
null
_totalMemoryTimeout
:
undefined
_testing
:
false
_totalMemory
:
null
_childrenToHearFrom
:
null
_nextTotalMemoryId
:
1
_USSFromChildProcesses
:
null
_lastEnvironmentChangeDate
:
0
_newProfilePingSent
:
false
_observedTopics
:
new
Set
(
)
addObserver
(
aTopic
)
{
Services
.
obs
.
addObserver
(
this
aTopic
)
;
this
.
_observedTopics
.
add
(
aTopic
)
;
}
removeObserver
(
aTopic
)
{
Services
.
obs
.
removeObserver
(
this
aTopic
)
;
this
.
_observedTopics
.
delete
(
aTopic
)
;
}
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
)
;
}
return
this
.
_logger
;
}
getSimpleMeasurements
:
function
getSimpleMeasurements
(
forSavedSession
isSubsession
clearSubsession
)
{
let
si
=
Services
.
startup
.
getStartupInfo
(
)
;
let
elapsedTime
=
Date
.
now
(
)
-
si
.
process
;
var
ret
=
{
totalTime
:
Math
.
round
(
elapsedTime
/
1000
)
uptime
:
Math
.
round
(
elapsedTime
/
60000
)
}
;
var
appTimestamps
=
{
}
;
try
{
let
o
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryTimestamps
.
jsm
"
o
)
;
appTimestamps
=
o
.
TelemetryTimestamps
.
get
(
)
;
}
catch
(
ex
)
{
}
if
(
!
Utils
.
isContentProcess
&
&
Telemetry
.
canRecordExtended
)
{
try
{
ret
.
addonManager
=
AddonManagerPrivate
.
getSimpleMeasures
(
)
;
ret
.
UITelemetry
=
UITelemetry
.
getSimpleMeasures
(
)
;
}
catch
(
ex
)
{
}
}
if
(
si
.
process
)
{
for
(
let
field
of
Object
.
keys
(
si
)
)
{
if
(
field
=
=
"
process
"
)
continue
;
ret
[
field
]
=
si
[
field
]
-
si
.
process
;
}
for
(
let
p
in
appTimestamps
)
{
if
(
!
(
p
in
ret
)
&
&
appTimestamps
[
p
]
)
ret
[
p
]
=
appTimestamps
[
p
]
-
si
.
process
;
}
}
ret
.
startupInterrupted
=
Number
(
Services
.
startup
.
interrupted
)
;
ret
.
js
=
Cu
.
getJSEngineTelemetryValue
(
)
;
let
maximalNumberOfConcurrentThreads
=
Telemetry
.
maximalNumberOfConcurrentThreads
;
if
(
maximalNumberOfConcurrentThreads
)
{
ret
.
maximalNumberOfConcurrentThreads
=
maximalNumberOfConcurrentThreads
;
}
if
(
Utils
.
isContentProcess
)
{
return
ret
;
}
let
debugService
=
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
;
let
isDebuggerAttached
=
debugService
.
isDebuggerAttached
;
gWasDebuggerAttached
=
gWasDebuggerAttached
|
|
isDebuggerAttached
;
ret
.
debuggerAttached
=
Number
(
gWasDebuggerAttached
)
;
let
shutdownDuration
=
Telemetry
.
lastShutdownDuration
;
if
(
shutdownDuration
)
ret
.
shutdownDuration
=
shutdownDuration
;
let
failedProfileLockCount
=
Telemetry
.
failedProfileLockCount
;
if
(
failedProfileLockCount
)
ret
.
failedProfileLockCount
=
failedProfileLockCount
;
for
(
let
ioCounter
in
this
.
_startupIO
)
ret
[
ioCounter
]
=
this
.
_startupIO
[
ioCounter
]
;
ret
.
savedPings
=
TelemetryStorage
.
pendingPingCount
;
let
activeTicks
=
this
.
_sessionActiveTicks
;
if
(
isSubsession
)
{
activeTicks
=
this
.
_sessionActiveTicks
-
this
.
_subsessionStartActiveTicks
;
}
if
(
clearSubsession
)
{
this
.
_subsessionStartActiveTicks
=
activeTicks
;
}
ret
.
activeTicks
=
activeTicks
;
ret
.
pingsOverdue
=
TelemetrySend
.
overduePingsCount
;
return
ret
;
}
packHistogram
:
function
packHistogram
(
hgram
)
{
let
r
=
hgram
.
ranges
;
let
c
=
hgram
.
counts
;
let
retgram
=
{
range
:
[
r
[
1
]
r
[
r
.
length
-
1
]
]
bucket_count
:
r
.
length
histogram_type
:
hgram
.
histogram_type
values
:
{
}
sum
:
hgram
.
sum
}
;
let
first
=
true
;
let
last
=
0
;
for
(
let
i
=
0
;
i
<
c
.
length
;
i
+
+
)
{
let
value
=
c
[
i
]
;
if
(
!
value
)
continue
;
if
(
i
&
&
first
)
{
retgram
.
values
[
r
[
i
-
1
]
]
=
0
;
}
first
=
false
;
last
=
i
+
1
;
retgram
.
values
[
r
[
i
]
]
=
value
;
}
if
(
last
&
&
last
<
c
.
length
)
retgram
.
values
[
r
[
last
]
]
=
0
;
return
retgram
;
}
getDatasetType
(
)
{
return
Telemetry
.
canRecordExtended
?
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
:
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTOUT
;
}
getHistograms
:
function
getHistograms
(
subsession
clearSubsession
)
{
let
hls
=
Telemetry
.
snapshotHistograms
(
this
.
getDatasetType
(
)
subsession
clearSubsession
)
;
let
ret
=
{
}
;
for
(
let
[
process
histograms
]
of
Object
.
entries
(
hls
)
)
{
ret
[
process
]
=
{
}
;
for
(
let
[
name
value
]
of
Object
.
entries
(
histograms
)
)
{
if
(
this
.
_testing
|
|
!
name
.
startsWith
(
"
TELEMETRY_TEST_
"
)
)
{
ret
[
process
]
[
name
]
=
this
.
packHistogram
(
value
)
;
}
}
}
return
ret
;
}
getKeyedHistograms
(
subsession
clearSubsession
)
{
let
khs
=
Telemetry
.
snapshotKeyedHistograms
(
this
.
getDatasetType
(
)
subsession
clearSubsession
)
;
let
ret
=
{
}
;
for
(
let
[
process
histograms
]
of
Object
.
entries
(
khs
)
)
{
ret
[
process
]
=
{
}
;
for
(
let
[
name
value
]
of
Object
.
entries
(
histograms
)
)
{
if
(
this
.
_testing
|
|
!
name
.
startsWith
(
"
TELEMETRY_TEST_
"
)
)
{
let
keys
=
Object
.
keys
(
value
)
;
if
(
keys
.
length
=
=
0
)
{
continue
;
}
ret
[
process
]
[
name
]
=
{
}
;
for
(
let
[
key
hgram
]
of
Object
.
entries
(
value
)
)
{
ret
[
process
]
[
name
]
[
key
]
=
this
.
packHistogram
(
hgram
)
;
}
}
}
}
return
ret
;
}
getScalars
(
subsession
clearSubsession
keyed
)
{
if
(
!
subsession
)
{
this
.
_log
.
trace
(
"
getScalars
-
We
only
support
scalars
in
subsessions
.
"
)
;
return
{
}
;
}
let
scalarsSnapshot
=
keyed
?
Telemetry
.
snapshotKeyedScalars
(
this
.
getDatasetType
(
)
clearSubsession
)
:
Telemetry
.
snapshotScalars
(
this
.
getDatasetType
(
)
clearSubsession
)
;
let
ret
=
{
}
;
for
(
let
processName
in
scalarsSnapshot
)
{
for
(
let
name
in
scalarsSnapshot
[
processName
]
)
{
if
(
name
.
startsWith
(
"
telemetry
.
test
"
)
&
&
!
this
.
_testing
)
{
continue
;
}
if
(
!
(
processName
in
ret
)
)
{
ret
[
processName
]
=
{
}
;
}
ret
[
processName
]
[
name
]
=
scalarsSnapshot
[
processName
]
[
name
]
;
}
}
return
ret
;
}
getEvents
(
isSubsession
clearSubsession
)
{
if
(
!
isSubsession
)
{
this
.
_log
.
trace
(
"
getEvents
-
We
only
support
events
in
subsessions
.
"
)
;
return
[
]
;
}
let
snapshot
=
Telemetry
.
snapshotEvents
(
this
.
getDatasetType
(
)
clearSubsession
)
;
if
(
!
this
.
_testing
)
{
for
(
let
proc
of
Object
.
keys
(
snapshot
)
)
{
snapshot
[
proc
]
=
snapshot
[
proc
]
.
filter
(
e
=
>
!
e
[
1
]
.
startsWith
(
"
telemetry
.
test
"
)
)
;
}
}
return
snapshot
;
}
getMetadata
:
function
getMetadata
(
reason
)
{
const
sessionStartDate
=
Utils
.
toLocalTimeISOString
(
Utils
.
truncateToHours
(
this
.
_sessionStartDate
)
)
;
const
subsessionStartDate
=
Utils
.
toLocalTimeISOString
(
Utils
.
truncateToHours
(
this
.
_subsessionStartDate
)
)
;
const
monotonicNow
=
Policy
.
monotonicNow
(
)
;
let
ret
=
{
reason
revision
:
AppConstants
.
SOURCE_REVISION_URL
timezoneOffset
:
-
this
.
_subsessionStartDate
.
getTimezoneOffset
(
)
previousBuildId
:
this
.
_previousBuildId
sessionId
:
this
.
_sessionId
subsessionId
:
this
.
_subsessionId
previousSessionId
:
this
.
_previousSessionId
previousSubsessionId
:
this
.
_previousSubsessionId
subsessionCounter
:
this
.
_subsessionCounter
profileSubsessionCounter
:
this
.
_profileSubsessionCounter
sessionStartDate
subsessionStartDate
sessionLength
:
Math
.
floor
(
monotonicNow
/
1000
)
subsessionLength
:
Math
.
floor
(
(
monotonicNow
-
this
.
_subsessionStartTimeMonotonic
)
/
1000
)
}
;
if
(
this
.
_addons
)
ret
.
addons
=
this
.
_addons
;
let
flashVersion
=
this
.
getFlashVersion
(
)
;
if
(
flashVersion
)
ret
.
flashVersion
=
flashVersion
;
return
ret
;
}
gatherMemory
:
function
gatherMemory
(
)
{
let
mgr
;
try
{
mgr
=
Cc
[
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIMemoryReporterManager
)
;
}
catch
(
e
)
{
return
;
}
let
histogram
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_MEMORY_REPORTER_MS
"
)
;
let
startTime
=
new
Date
(
)
;
let
boundHandleMemoryReport
=
this
.
handleMemoryReport
.
bind
(
this
)
;
let
h
=
(
id
units
amountName
)
=
>
{
try
{
let
amount
=
mgr
[
amountName
]
;
if
(
amount
=
=
=
undefined
)
{
this
.
_log
.
error
(
"
gatherMemory
-
telemetry
accessed
an
unknown
distinguished
amount
"
)
;
}
boundHandleMemoryReport
(
id
units
amount
)
;
}
catch
(
e
)
{
}
}
;
let
b
=
(
id
n
)
=
>
h
(
id
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
n
)
;
let
c
=
(
id
n
)
=
>
h
(
id
Ci
.
nsIMemoryReporter
.
UNITS_COUNT
n
)
;
let
cc
=
(
id
n
)
=
>
h
(
id
Ci
.
nsIMemoryReporter
.
UNITS_COUNT_CUMULATIVE
n
)
;
let
p
=
(
id
n
)
=
>
h
(
id
Ci
.
nsIMemoryReporter
.
UNITS_PERCENTAGE
n
)
;
c
(
"
GHOST_WINDOWS
"
"
ghostWindows
"
)
;
if
(
!
Telemetry
.
canRecordExtended
)
{
return
;
}
b
(
"
MEMORY_VSIZE
"
"
vsize
"
)
;
if
(
!
Services
.
appinfo
.
is64Bit
|
|
AppConstants
.
platform
!
=
=
"
win
"
)
{
b
(
"
MEMORY_VSIZE_MAX_CONTIGUOUS
"
"
vsizeMaxContiguous
"
)
;
}
b
(
"
MEMORY_RESIDENT_FAST
"
"
residentFast
"
)
;
b
(
"
MEMORY_UNIQUE
"
"
residentUnique
"
)
;
p
(
"
MEMORY_HEAP_OVERHEAD_FRACTION
"
"
heapOverheadFraction
"
)
;
b
(
"
MEMORY_JS_GC_HEAP
"
"
JSMainRuntimeGCHeap
"
)
;
c
(
"
MEMORY_JS_COMPARTMENTS_SYSTEM
"
"
JSMainRuntimeCompartmentsSystem
"
)
;
c
(
"
MEMORY_JS_COMPARTMENTS_USER
"
"
JSMainRuntimeCompartmentsUser
"
)
;
b
(
"
MEMORY_IMAGES_CONTENT_USED_UNCOMPRESSED
"
"
imagesContentUsedUncompressed
"
)
;
b
(
"
MEMORY_STORAGE_SQLITE
"
"
storageSQLite
"
)
;
cc
(
"
LOW_MEMORY_EVENTS_VIRTUAL
"
"
lowMemoryEventsVirtual
"
)
;
cc
(
"
LOW_MEMORY_EVENTS_PHYSICAL
"
"
lowMemoryEventsPhysical
"
)
;
cc
(
"
PAGE_FAULTS_HARD
"
"
pageFaultsHard
"
)
;
try
{
mgr
.
getHeapAllocatedAsync
(
heapAllocated
=
>
{
boundHandleMemoryReport
(
"
MEMORY_HEAP_ALLOCATED
"
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
heapAllocated
)
;
}
)
;
}
catch
(
e
)
{
}
if
(
!
Utils
.
isContentProcess
&
&
!
this
.
_totalMemoryTimeout
)
{
this
.
_totalMemory
=
mgr
.
residentFast
;
if
(
Services
.
ppmm
.
childCount
>
1
)
{
this
.
_totalMemoryTimeout
=
setTimeout
(
(
)
=
>
{
this
.
_totalMemoryTimeout
=
undefined
;
this
.
_childrenToHearFrom
.
clear
(
)
;
}
TOTAL_MEMORY_COLLECTOR_TIMEOUT
)
;
this
.
_USSFromChildProcesses
=
[
]
;
this
.
_childrenToHearFrom
=
new
Set
(
)
;
for
(
let
i
=
1
;
i
<
Services
.
ppmm
.
childCount
;
i
+
+
)
{
let
child
=
Services
.
ppmm
.
getChildAt
(
i
)
;
try
{
child
.
sendAsyncMessage
(
MESSAGE_TELEMETRY_GET_CHILD_USS
{
id
:
this
.
_nextTotalMemoryId
}
)
;
this
.
_childrenToHearFrom
.
add
(
this
.
_nextTotalMemoryId
)
;
this
.
_nextTotalMemoryId
+
+
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
else
{
boundHandleMemoryReport
(
"
MEMORY_TOTAL
"
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
this
.
_totalMemory
)
;
}
}
histogram
.
add
(
new
Date
(
)
-
startTime
)
;
}
handleMemoryReport
(
id
units
amount
key
)
{
let
val
;
if
(
units
=
=
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
)
{
val
=
Math
.
floor
(
amount
/
1024
)
;
}
else
if
(
units
=
=
Ci
.
nsIMemoryReporter
.
UNITS_PERCENTAGE
)
{
val
=
Math
.
floor
(
amount
/
100
)
;
}
else
if
(
units
=
=
Ci
.
nsIMemoryReporter
.
UNITS_COUNT
)
{
val
=
amount
;
}
else
if
(
units
=
=
Ci
.
nsIMemoryReporter
.
UNITS_COUNT_CUMULATIVE
)
{
if
(
!
(
id
in
this
.
_prevValues
)
)
{
this
.
_prevValues
[
id
]
=
amount
;
return
;
}
val
=
amount
-
this
.
_prevValues
[
id
]
;
this
.
_prevValues
[
id
]
=
amount
;
}
else
{
this
.
_log
.
error
(
"
handleMemoryReport
-
Can
'
t
handle
memory
reporter
with
units
"
+
units
)
;
return
;
}
if
(
key
)
{
Telemetry
.
getKeyedHistogramById
(
id
)
.
add
(
key
val
)
;
return
;
}
Telemetry
.
getHistogramById
(
id
)
.
add
(
val
)
;
}
getChildPayloads
:
function
getChildPayloads
(
)
{
return
this
.
_childTelemetry
.
map
(
child
=
>
child
.
payload
)
;
}
assemblePayloadWithMeasurements
(
simpleMeasurements
info
reason
clearSubsession
)
{
const
isSubsession
=
IS_UNIFIED_TELEMETRY
&
&
!
this
.
_isClassicReason
(
reason
)
;
clearSubsession
=
IS_UNIFIED_TELEMETRY
&
&
clearSubsession
;
this
.
_log
.
trace
(
"
assemblePayloadWithMeasurements
-
reason
:
"
+
reason
+
"
submitting
subsession
data
:
"
+
isSubsession
)
;
const
protect
=
(
fn
defaultReturn
=
null
)
=
>
{
try
{
return
fn
(
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
assemblePayloadWithMeasurements
-
caught
exception
"
ex
)
;
return
defaultReturn
;
}
}
;
let
payloadObj
=
{
ver
:
PAYLOAD_VERSION
simpleMeasurements
}
;
if
(
Telemetry
.
canRecordExtended
)
{
payloadObj
.
chromeHangs
=
protect
(
(
)
=
>
Telemetry
.
chromeHangs
)
;
payloadObj
.
log
=
[
]
;
payloadObj
.
webrtc
=
protect
(
(
)
=
>
Telemetry
.
webrtcStats
)
;
}
if
(
Utils
.
isContentProcess
)
{
return
payloadObj
;
}
let
measurements
=
{
histograms
:
protect
(
(
)
=
>
this
.
getHistograms
(
isSubsession
clearSubsession
)
{
}
)
keyedHistograms
:
protect
(
(
)
=
>
this
.
getKeyedHistograms
(
isSubsession
clearSubsession
)
{
}
)
scalars
:
protect
(
(
)
=
>
this
.
getScalars
(
isSubsession
clearSubsession
)
{
}
)
keyedScalars
:
protect
(
(
)
=
>
this
.
getScalars
(
isSubsession
clearSubsession
true
)
{
}
)
events
:
protect
(
(
)
=
>
this
.
getEvents
(
isSubsession
clearSubsession
)
)
}
;
let
measurementsContainGPU
=
Object
.
keys
(
measurements
)
.
some
(
key
=
>
"
gpu
"
in
measurements
[
key
]
)
;
payloadObj
.
processes
=
{
}
;
let
processTypes
=
[
"
parent
"
"
content
"
"
extension
"
"
dynamic
"
]
;
if
(
measurementsContainGPU
)
{
processTypes
.
push
(
"
gpu
"
)
;
}
for
(
const
processType
of
processTypes
)
{
let
processPayload
=
{
}
;
for
(
const
key
in
measurements
)
{
let
payloadLoc
=
processPayload
;
if
(
processType
=
=
"
parent
"
&
&
(
key
=
=
"
histograms
"
|
|
key
=
=
"
keyedHistograms
"
)
)
{
payloadLoc
=
payloadObj
;
}
if
(
processType
=
=
"
dynamic
"
&
&
!
[
"
events
"
"
scalars
"
]
.
includes
(
key
)
)
{
continue
;
}
let
defaultValue
=
key
=
=
"
events
"
?
[
]
:
{
}
;
payloadLoc
[
key
]
=
measurements
[
key
]
[
processType
]
|
|
defaultValue
;
}
payloadObj
.
processes
[
processType
]
=
processPayload
;
}
payloadObj
.
info
=
info
;
if
(
Telemetry
.
canRecordExtended
)
{
payloadObj
.
slowSQL
=
protect
(
(
)
=
>
Telemetry
.
slowSQL
)
;
payloadObj
.
fileIOReports
=
protect
(
(
)
=
>
Telemetry
.
fileIOReports
)
;
payloadObj
.
lateWrites
=
protect
(
(
)
=
>
Telemetry
.
lateWrites
)
;
payloadObj
.
addonDetails
=
protect
(
(
)
=
>
AddonManagerPrivate
.
getTelemetryDetails
(
)
)
;
let
clearUIsession
=
!
(
reason
=
=
REASON_GATHER_PAYLOAD
|
|
reason
=
=
REASON_GATHER_SUBSESSION_PAYLOAD
)
;
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
payloadObj
.
UIMeasurements
=
protect
(
(
)
=
>
UITelemetry
.
getUIMeasurements
(
clearUIsession
)
)
;
}
if
(
this
.
_slowSQLStartup
&
&
Object
.
keys
(
this
.
_slowSQLStartup
)
.
length
!
=
0
&
&
(
Object
.
keys
(
this
.
_slowSQLStartup
.
mainThread
)
.
length
|
|
Object
.
keys
(
this
.
_slowSQLStartup
.
otherThreads
)
.
length
)
)
{
payloadObj
.
slowSQLStartup
=
this
.
_slowSQLStartup
;
}
if
(
!
this
.
_isClassicReason
(
reason
)
)
{
payloadObj
.
processes
.
parent
.
gc
=
protect
(
(
)
=
>
GCTelemetry
.
entries
(
"
main
"
clearSubsession
)
)
;
payloadObj
.
processes
.
content
.
gc
=
protect
(
(
)
=
>
GCTelemetry
.
entries
(
"
content
"
clearSubsession
)
)
;
}
let
stacks
=
protect
(
(
)
=
>
Telemetry
.
snapshotCapturedStacks
(
true
)
)
;
if
(
stacks
&
&
(
"
captures
"
in
stacks
)
&
&
(
stacks
.
captures
.
length
>
0
)
)
{
payloadObj
.
processes
.
parent
.
capturedStacks
=
stacks
;
}
}
return
payloadObj
;
}
startNewSubsession
(
)
{
this
.
_subsessionStartDate
=
Policy
.
now
(
)
;
this
.
_subsessionStartTimeMonotonic
=
Policy
.
monotonicNow
(
)
;
this
.
_previousSubsessionId
=
this
.
_subsessionId
;
this
.
_subsessionId
=
Policy
.
generateSubsessionUUID
(
)
;
this
.
_subsessionCounter
+
+
;
this
.
_profileSubsessionCounter
+
+
;
}
getSessionPayload
:
function
getSessionPayload
(
reason
clearSubsession
)
{
this
.
_log
.
trace
(
"
getSessionPayload
-
reason
:
"
+
reason
+
"
clearSubsession
:
"
+
clearSubsession
)
;
let
payload
;
try
{
const
isMobile
=
(
AppConstants
.
platform
=
=
"
android
"
)
;
const
isSubsession
=
isMobile
?
false
:
!
this
.
_isClassicReason
(
reason
)
;
if
(
isMobile
)
{
clearSubsession
=
false
;
}
let
measurements
=
this
.
getSimpleMeasurements
(
reason
=
=
REASON_SAVED_SESSION
isSubsession
clearSubsession
)
;
let
info
=
!
Utils
.
isContentProcess
?
this
.
getMetadata
(
reason
)
:
null
;
payload
=
this
.
assemblePayloadWithMeasurements
(
measurements
info
reason
clearSubsession
)
;
}
catch
(
ex
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_ASSEMBLE_PAYLOAD_EXCEPTION
"
)
.
add
(
1
)
;
throw
ex
;
}
finally
{
if
(
!
Utils
.
isContentProcess
&
&
clearSubsession
)
{
this
.
startNewSubsession
(
)
;
let
sessionData
=
this
.
_getSessionDataObject
(
)
;
TelemetryStorage
.
saveSessionData
(
sessionData
)
;
Services
.
obs
.
notifyObservers
(
null
"
internal
-
telemetry
-
after
-
subsession
-
split
"
)
;
}
}
return
payload
;
}
send
:
function
send
(
reason
)
{
this
.
_log
.
trace
(
"
send
-
Reason
"
+
reason
)
;
this
.
gatherMemory
(
)
;
const
isSubsession
=
!
this
.
_isClassicReason
(
reason
)
;
let
payload
=
this
.
getSessionPayload
(
reason
isSubsession
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
return
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
;
}
attachEarlyObservers
(
)
{
this
.
addObserver
(
"
sessionstore
-
windows
-
restored
"
)
;
if
(
AppConstants
.
platform
=
=
=
"
android
"
)
{
this
.
addObserver
(
"
application
-
background
"
)
;
}
this
.
addObserver
(
"
xul
-
window
-
visible
"
)
;
this
.
addObserver
(
"
user
-
interaction
-
active
"
)
;
this
.
addObserver
(
"
user
-
interaction
-
inactive
"
)
;
}
attachObservers
:
function
attachObservers
(
)
{
if
(
!
this
.
_initialized
)
return
;
this
.
addObserver
(
"
idle
-
daily
"
)
;
if
(
Telemetry
.
canRecordExtended
)
{
this
.
addObserver
(
TOPIC_CYCLE_COLLECTOR_BEGIN
)
;
}
}
earlyInit
(
testing
)
{
this
.
_log
.
trace
(
"
earlyInit
"
)
;
this
.
_initStarted
=
true
;
this
.
_testing
=
testing
;
if
(
this
.
_initialized
&
&
!
testing
)
{
this
.
_log
.
error
(
"
earlyInit
-
already
initialized
"
)
;
return
;
}
if
(
!
Telemetry
.
canRecordBase
&
&
!
testing
)
{
this
.
_log
.
config
(
"
earlyInit
-
Telemetry
recording
is
disabled
skipping
Chrome
process
setup
.
"
)
;
return
;
}
this
.
_sessionId
=
Policy
.
generateSessionUUID
(
)
;
this
.
startNewSubsession
(
)
;
this
.
_sessionStartDate
=
this
.
_subsessionStartDate
;
annotateCrashReport
(
this
.
_sessionId
)
;
let
previousBuildId
=
Services
.
prefs
.
getStringPref
(
TelemetryUtils
.
Preferences
.
PreviousBuildID
null
)
;
let
thisBuildID
=
Services
.
appinfo
.
appBuildID
;
if
(
previousBuildId
!
=
thisBuildID
)
{
this
.
_previousBuildId
=
previousBuildId
;
Services
.
prefs
.
setStringPref
(
TelemetryUtils
.
Preferences
.
PreviousBuildID
thisBuildID
)
;
}
this
.
attachEarlyObservers
(
)
;
Services
.
ppmm
.
addMessageListener
(
MESSAGE_TELEMETRY_PAYLOAD
this
)
;
Services
.
ppmm
.
addMessageListener
(
MESSAGE_TELEMETRY_USS
this
)
;
}
delayedInit
(
)
{
this
.
_log
.
trace
(
"
delayedInit
"
)
;
this
.
_delayedInitTask
=
(
async
(
)
=
>
{
try
{
this
.
_initialized
=
true
;
await
this
.
_loadSessionData
(
)
;
await
TelemetryStorage
.
saveSessionData
(
this
.
_getSessionDataObject
(
)
)
;
this
.
attachObservers
(
)
;
this
.
gatherMemory
(
)
;
if
(
Telemetry
.
canRecordExtended
)
{
GCTelemetry
.
init
(
)
;
}
Telemetry
.
asyncFetchTelemetryData
(
function
(
)
{
}
)
;
if
(
IS_UNIFIED_TELEMETRY
)
{
await
TelemetryController
.
checkAbortedSessionPing
(
)
;
if
(
!
this
.
_testing
)
{
await
this
.
_saveAbortedSessionPing
(
)
;
}
this
.
_lastEnvironmentChangeDate
=
Policy
.
monotonicNow
(
)
;
TelemetryEnvironment
.
registerChangeListener
(
ENVIRONMENT_CHANGE_LISTENER
(
reason
data
)
=
>
this
.
_onEnvironmentChange
(
reason
data
)
)
;
TelemetryScheduler
.
init
(
)
;
}
this
.
_delayedInitTask
=
null
;
}
catch
(
e
)
{
this
.
_delayedInitTask
=
null
;
throw
e
;
}
}
)
(
)
;
return
this
.
_delayedInitTask
;
}
getOpenTabsCount
:
function
getOpenTabsCount
(
)
{
let
tabCount
=
0
;
let
browserEnum
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
browserEnum
.
hasMoreElements
(
)
)
{
let
win
=
browserEnum
.
getNext
(
)
;
tabCount
+
=
win
.
gBrowser
.
tabs
.
length
;
}
return
tabCount
;
}
setupContentProcess
:
function
setupContentProcess
(
testing
)
{
this
.
_log
.
trace
(
"
setupContentProcess
"
)
;
this
.
_testing
=
testing
;
if
(
!
Telemetry
.
canRecordBase
)
{
this
.
_log
.
trace
(
"
setupContentProcess
-
base
recording
is
disabled
not
initializing
"
)
;
return
;
}
this
.
addObserver
(
"
content
-
child
-
shutdown
"
)
;
Services
.
cpmm
.
addMessageListener
(
MESSAGE_TELEMETRY_GET_CHILD_USS
this
)
;
let
delayedTask
=
new
DeferredTask
(
(
)
=
>
{
this
.
_initialized
=
true
;
this
.
attachObservers
(
)
;
this
.
gatherMemory
(
)
;
if
(
Telemetry
.
canRecordExtended
)
{
GCTelemetry
.
init
(
)
;
}
}
testing
?
TELEMETRY_TEST_DELAY
:
TELEMETRY_DELAY
testing
?
0
:
undefined
)
;
delayedTask
.
arm
(
)
;
}
getFlashVersion
:
function
getFlashVersion
(
)
{
let
host
=
Cc
[
"
mozilla
.
org
/
plugin
/
host
;
1
"
]
.
getService
(
Ci
.
nsIPluginHost
)
;
let
tags
=
host
.
getPluginTags
(
)
;
for
(
let
i
=
0
;
i
<
tags
.
length
;
i
+
+
)
{
if
(
tags
[
i
]
.
name
=
=
"
Shockwave
Flash
"
)
return
tags
[
i
]
.
version
;
}
return
null
;
}
receiveMessage
:
function
receiveMessage
(
message
)
{
this
.
_log
.
trace
(
"
receiveMessage
-
Message
name
"
+
message
.
name
)
;
switch
(
message
.
name
)
{
case
MESSAGE_TELEMETRY_PAYLOAD
:
{
let
source
=
message
.
data
.
childUUID
;
delete
message
.
data
.
childUUID
;
this
.
_childTelemetry
.
push
(
{
source
payload
:
message
.
data
}
)
;
if
(
this
.
_childTelemetry
.
length
=
=
MAX_NUM_CONTENT_PAYLOADS
+
1
)
{
this
.
_childTelemetry
.
shift
(
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_DISCARDED_CONTENT_PINGS_COUNT
"
)
.
add
(
)
;
}
break
;
}
case
MESSAGE_TELEMETRY_USS
:
{
if
(
this
.
_totalMemoryTimeout
&
&
this
.
_childrenToHearFrom
.
delete
(
message
.
data
.
id
)
)
{
let
uss
=
message
.
data
.
bytes
;
this
.
_totalMemory
+
=
uss
;
this
.
_USSFromChildProcesses
.
push
(
uss
)
;
if
(
this
.
_childrenToHearFrom
.
size
=
=
0
)
{
clearTimeout
(
this
.
_totalMemoryTimeout
)
;
this
.
_totalMemoryTimeout
=
undefined
;
this
.
handleMemoryReport
(
"
MEMORY_TOTAL
"
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
this
.
_totalMemory
)
;
let
length
=
this
.
_USSFromChildProcesses
.
length
;
if
(
length
>
1
)
{
let
mean
=
this
.
_USSFromChildProcesses
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
/
length
;
let
diffs
=
this
.
_USSFromChildProcesses
.
map
(
value
=
>
Math
.
floor
(
Math
.
abs
(
value
-
mean
)
*
100
/
mean
)
)
;
let
tabsCount
=
this
.
getOpenTabsCount
(
)
;
let
key
;
if
(
tabsCount
<
11
)
{
key
=
"
0
-
10
tabs
"
;
}
else
if
(
tabsCount
<
501
)
{
key
=
"
11
-
500
tabs
"
;
}
else
{
key
=
"
more
tabs
"
;
}
diffs
.
forEach
(
value
=
>
{
this
.
handleMemoryReport
(
"
MEMORY_DISTRIBUTION_AMONG_CONTENT
"
Ci
.
nsIMemoryReporter
.
UNITS_COUNT
value
key
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
gather
-
memory
-
telemetry
-
finished
"
)
;
}
this
.
_USSFromChildProcesses
=
undefined
;
}
}
else
{
this
.
_log
.
trace
(
"
Child
USS
report
was
missed
"
)
;
}
break
;
}
case
MESSAGE_TELEMETRY_GET_CHILD_USS
:
{
this
.
sendContentProcessUSS
(
message
.
data
.
id
)
;
break
;
}
default
:
throw
new
Error
(
"
Telemetry
.
receiveMessage
:
bad
message
name
"
)
;
}
}
_processUUID
:
generateUUID
(
)
sendContentProcessUSS
:
function
sendContentProcessUSS
(
aMessageId
)
{
this
.
_log
.
trace
(
"
sendContentProcessUSS
"
)
;
let
mgr
;
try
{
mgr
=
Cc
[
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIMemoryReporterManager
)
;
}
catch
(
e
)
{
return
;
}
Services
.
cpmm
.
sendAsyncMessage
(
MESSAGE_TELEMETRY_USS
{
bytes
:
mgr
.
residentUnique
id
:
aMessageId
}
)
;
}
sendContentProcessPing
:
function
sendContentProcessPing
(
reason
)
{
this
.
_log
.
trace
(
"
sendContentProcessPing
-
Reason
"
+
reason
)
;
const
isSubsession
=
!
this
.
_isClassicReason
(
reason
)
;
let
payload
=
this
.
getSessionPayload
(
reason
isSubsession
)
;
payload
.
childUUID
=
this
.
_processUUID
;
Services
.
cpmm
.
sendAsyncMessage
(
MESSAGE_TELEMETRY_PAYLOAD
payload
)
;
}
saveShutdownPings
(
)
{
this
.
_log
.
trace
(
"
saveShutdownPings
"
)
;
let
p
=
[
]
;
if
(
IS_UNIFIED_TELEMETRY
)
{
let
shutdownPayload
=
this
.
getSessionPayload
(
REASON_SHUTDOWN
false
)
;
const
sendOnThisSession
=
Services
.
prefs
.
getBoolPref
(
Utils
.
Preferences
.
ShutdownPingSenderFirstSession
false
)
|
|
!
TelemetryReportingPolicy
.
isFirstRun
(
)
;
let
sendWithPingsender
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
ShutdownPingSender
false
)
&
&
sendOnThisSession
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
usePingSender
:
sendWithPingsender
}
;
p
.
push
(
TelemetryController
.
submitExternalPing
(
getPingType
(
shutdownPayload
)
shutdownPayload
options
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
saveShutdownPings
-
failed
to
submit
shutdown
ping
"
e
)
)
)
;
const
sendFirstShutdownPing
=
Services
.
prefs
.
getBoolPref
(
Utils
.
Preferences
.
ShutdownPingSender
false
)
&
&
Services
.
prefs
.
getBoolPref
(
Utils
.
Preferences
.
FirstShutdownPingEnabled
false
)
&
&
TelemetryReportingPolicy
.
isFirstRun
(
)
;
if
(
sendFirstShutdownPing
)
{
let
options
=
{
addClientId
:
true
addEnvironment
:
true
usePingSender
:
true
}
;
p
.
push
(
TelemetryController
.
submitExternalPing
(
"
first
-
shutdown
"
shutdownPayload
options
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
saveShutdownPings
-
failed
to
submit
first
shutdown
ping
"
e
)
)
)
;
}
}
if
(
Telemetry
.
canRecordExtended
)
{
let
payload
=
this
.
getSessionPayload
(
REASON_SAVED_SESSION
false
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
p
.
push
(
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
saveShutdownPings
-
failed
to
submit
saved
-
session
ping
"
e
)
)
)
;
}
return
Promise
.
all
(
p
)
;
}
testSavePendingPing
(
)
{
let
payload
=
this
.
getSessionPayload
(
REASON_SAVED_SESSION
false
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
overwrite
:
true
}
;
return
TelemetryController
.
addPendingPing
(
getPingType
(
payload
)
payload
options
)
;
}
uninstall
(
)
{
for
(
let
topic
of
this
.
_observedTopics
)
{
try
{
this
.
removeObserver
(
topic
)
;
}
catch
(
e
)
{
this
.
_log
.
warn
(
"
uninstall
-
Failed
to
remove
"
+
topic
e
)
;
}
}
GCTelemetry
.
shutdown
(
)
;
}
getPayload
:
function
getPayload
(
reason
clearSubsession
)
{
this
.
_log
.
trace
(
"
getPayload
-
clearSubsession
:
"
+
clearSubsession
)
;
reason
=
reason
|
|
REASON_GATHER_PAYLOAD
;
if
(
Object
.
keys
(
this
.
_slowSQLStartup
)
.
length
=
=
0
)
{
this
.
_slowSQLStartup
=
Telemetry
.
slowSQL
;
}
this
.
gatherMemory
(
)
;
return
this
.
getSessionPayload
(
reason
clearSubsession
)
;
}
gatherStartup
:
function
gatherStartup
(
)
{
this
.
_log
.
trace
(
"
gatherStartup
"
)
;
let
counters
=
processInfo
.
getCounters
(
)
;
if
(
counters
)
{
[
this
.
_startupIO
.
startupSessionRestoreReadBytes
this
.
_startupIO
.
startupSessionRestoreWriteBytes
]
=
counters
;
}
this
.
_slowSQLStartup
=
Telemetry
.
slowSQL
;
}
setAddOns
:
function
setAddOns
(
aAddOns
)
{
this
.
_addons
=
aAddOns
;
}
testPing
:
function
testPing
(
)
{
return
this
.
send
(
REASON_TEST_PING
)
;
}
_onActiveTick
(
aUserActive
)
{
const
needsUpdate
=
aUserActive
&
&
this
.
_isUserActive
;
this
.
_isUserActive
=
aUserActive
;
if
(
needsUpdate
)
{
this
.
_sessionActiveTicks
+
+
;
Telemetry
.
scalarAdd
(
"
browser
.
engagement
.
active_ticks
"
1
)
;
}
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
!
=
TOPIC_CYCLE_COLLECTOR_BEGIN
)
{
this
.
_log
.
trace
(
"
observe
-
"
+
aTopic
+
"
notified
.
"
)
;
}
switch
(
aTopic
)
{
case
"
content
-
child
-
shutdown
"
:
this
.
uninstall
(
)
;
Telemetry
.
flushBatchedChildTelemetry
(
)
;
this
.
sendContentProcessPing
(
REASON_SAVED_SESSION
)
;
break
;
case
TOPIC_CYCLE_COLLECTOR_BEGIN
:
let
now
=
new
Date
(
)
;
if
(
!
gLastMemoryPoll
|
|
(
TELEMETRY_INTERVAL
<
=
now
-
gLastMemoryPoll
)
)
{
gLastMemoryPoll
=
now
;
this
.
_log
.
trace
(
"
Dispatching
idle
gatherMemory
task
"
)
;
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
this
.
_log
.
trace
(
"
Running
idle
gatherMemory
task
"
)
;
this
.
gatherMemory
(
)
;
return
true
;
}
)
;
}
break
;
case
"
xul
-
window
-
visible
"
:
this
.
removeObserver
(
"
xul
-
window
-
visible
"
)
;
var
counters
=
processInfo
.
getCounters
(
)
;
if
(
counters
)
{
[
this
.
_startupIO
.
startupWindowVisibleReadBytes
this
.
_startupIO
.
startupWindowVisibleWriteBytes
]
=
counters
;
}
break
;
case
"
sessionstore
-
windows
-
restored
"
:
this
.
removeObserver
(
"
sessionstore
-
windows
-
restored
"
)
;
let
debugService
=
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
;
gWasDebuggerAttached
=
debugService
.
isDebuggerAttached
;
this
.
gatherStartup
(
)
;
break
;
case
"
idle
-
daily
"
:
Services
.
tm
.
dispatchToMainThread
(
(
function
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
gather
-
telemetry
"
)
;
}
)
)
;
break
;
case
"
application
-
background
"
:
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
break
;
}
let
payload
=
this
.
getSessionPayload
(
REASON_SAVED_SESSION
false
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
overwrite
:
true
}
;
TelemetryController
.
addPendingPing
(
getPingType
(
payload
)
payload
options
)
;
break
;
case
"
user
-
interaction
-
active
"
:
this
.
_onActiveTick
(
true
)
;
break
;
case
"
user
-
interaction
-
inactive
"
:
this
.
_onActiveTick
(
false
)
;
break
;
}
return
undefined
;
}
shutdownChromeProcess
(
)
{
this
.
_log
.
trace
(
"
shutdownChromeProcess
"
)
;
let
cleanup
=
(
)
=
>
{
if
(
IS_UNIFIED_TELEMETRY
)
{
TelemetryEnvironment
.
unregisterChangeListener
(
ENVIRONMENT_CHANGE_LISTENER
)
;
TelemetryScheduler
.
shutdown
(
)
;
}
this
.
uninstall
(
)
;
let
reset
=
(
)
=
>
{
this
.
_initStarted
=
false
;
this
.
_initialized
=
false
;
}
;
return
(
async
(
)
=
>
{
await
this
.
saveShutdownPings
(
)
;
if
(
IS_UNIFIED_TELEMETRY
)
{
await
TelemetryController
.
removeAbortedSessionPing
(
)
;
}
reset
(
)
;
}
)
(
)
;
}
;
if
(
!
this
.
_initStarted
)
{
return
Promise
.
resolve
(
)
;
}
if
(
!
this
.
_delayedInitTask
)
{
return
cleanup
(
)
;
}
return
this
.
_delayedInitTask
.
then
(
cleanup
)
;
}
_sendDailyPing
(
)
{
this
.
_log
.
trace
(
"
_sendDailyPing
"
)
;
let
payload
=
this
.
getSessionPayload
(
REASON_DAILY
true
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
let
promise
=
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
;
if
(
IS_UNIFIED_TELEMETRY
)
{
this
.
_saveAbortedSessionPing
(
payload
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
_sendDailyPing
-
Failed
to
save
the
aborted
session
ping
"
e
)
)
;
}
return
promise
;
}
async
_loadSessionData
(
)
{
let
data
=
await
TelemetryStorage
.
loadSessionData
(
)
;
if
(
!
data
)
{
return
null
;
}
if
(
!
(
"
profileSubsessionCounter
"
in
data
)
|
|
!
(
typeof
(
data
.
profileSubsessionCounter
)
=
=
"
number
"
)
|
|
!
(
"
subsessionId
"
in
data
)
|
|
!
(
"
sessionId
"
in
data
)
)
{
this
.
_log
.
error
(
"
_loadSessionData
-
session
data
is
invalid
"
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_SESSIONDATA_FAILED_VALIDATION
"
)
.
add
(
1
)
;
return
null
;
}
this
.
_previousSessionId
=
data
.
sessionId
;
this
.
_previousSubsessionId
=
data
.
subsessionId
;
this
.
_profileSubsessionCounter
=
data
.
profileSubsessionCounter
+
this
.
_subsessionCounter
;
this
.
_newProfilePingSent
=
(
"
newProfilePingSent
"
in
data
)
?
data
.
newProfilePingSent
:
true
;
return
data
;
}
_getSessionDataObject
(
)
{
return
{
sessionId
:
this
.
_sessionId
subsessionId
:
this
.
_subsessionId
profileSubsessionCounter
:
this
.
_profileSubsessionCounter
newProfilePingSent
:
this
.
_newProfilePingSent
}
;
}
_onEnvironmentChange
(
reason
oldEnvironment
)
{
this
.
_log
.
trace
(
"
_onEnvironmentChange
"
reason
)
;
let
now
=
Policy
.
monotonicNow
(
)
;
let
timeDelta
=
now
-
this
.
_lastEnvironmentChangeDate
;
if
(
timeDelta
<
=
MIN_SUBSESSION_LENGTH_MS
)
{
this
.
_log
.
trace
(
_onEnvironmentChange
-
throttling
;
last
change
was
{
Math
.
round
(
timeDelta
/
1000
)
}
s
ago
.
)
;
return
;
}
this
.
_lastEnvironmentChangeDate
=
now
;
let
payload
=
this
.
getSessionPayload
(
REASON_ENVIRONMENT_CHANGE
true
)
;
TelemetryScheduler
.
reschedulePings
(
REASON_ENVIRONMENT_CHANGE
payload
)
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
overrideEnvironment
:
oldEnvironment
}
;
TelemetryController
.
submitExternalPing
(
getPingType
(
payload
)
payload
options
)
;
}
_isClassicReason
(
reason
)
{
const
classicReasons
=
[
REASON_SAVED_SESSION
REASON_GATHER_PAYLOAD
REASON_TEST_PING
]
;
return
classicReasons
.
includes
(
reason
)
;
}
_getState
(
)
{
return
{
initialized
:
this
.
_initialized
initStarted
:
this
.
_initStarted
haveDelayedInitTask
:
!
!
this
.
_delayedInitTask
}
;
}
_saveAbortedSessionPing
(
aProvidedPayload
=
null
)
{
this
.
_log
.
trace
(
"
_saveAbortedSessionPing
"
)
;
let
payload
=
null
;
if
(
aProvidedPayload
)
{
payload
=
Cu
.
cloneInto
(
aProvidedPayload
myScope
)
;
payload
.
info
.
reason
=
REASON_ABORTED_SESSION
;
}
else
{
payload
=
this
.
getSessionPayload
(
REASON_ABORTED_SESSION
false
)
;
}
return
TelemetryController
.
saveAbortedSessionPing
(
payload
)
;
}
async
markNewProfilePingSent
(
)
{
this
.
_log
.
trace
(
"
markNewProfilePingSent
"
)
;
this
.
_newProfilePingSent
=
true
;
return
TelemetryStorage
.
saveSessionData
(
this
.
_getSessionDataObject
(
)
)
;
}
}
;
