#
include
"
GeckoViewStreamingTelemetry
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPrefs_toolkit
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
mozilla
:
:
Runnable
;
using
mozilla
:
:
StaticMutex
;
using
mozilla
:
:
StaticMutexAutoLock
;
using
mozilla
:
:
StaticRefPtr
;
using
mozilla
:
:
SystemGroup
;
using
mozilla
:
:
TaskCategory
;
using
mozilla
:
:
TimeStamp
;
namespace
GeckoViewStreamingTelemetry
{
class
LifecycleObserver
;
void
SendBatch
(
const
StaticMutexAutoLock
&
aLock
)
;
static
const
char
*
const
kApplicationBackgroundTopic
=
"
application
-
background
"
;
static
StaticMutex
gMutex
;
TimeStamp
gBatchBegan
;
typedef
nsDataHashtable
<
nsCStringHashKey
nsTArray
<
uint32_t
>
>
HistogramBatch
;
HistogramBatch
gBatch
;
HistogramBatch
gCategoricalBatch
;
typedef
nsDataHashtable
<
nsCStringHashKey
bool
>
BoolScalarBatch
;
BoolScalarBatch
gBoolScalars
;
typedef
nsDataHashtable
<
nsCStringHashKey
nsCString
>
StringScalarBatch
;
StringScalarBatch
gStringScalars
;
typedef
nsDataHashtable
<
nsCStringHashKey
uint32_t
>
UintScalarBatch
;
UintScalarBatch
gUintScalars
;
StaticRefPtr
<
StreamingTelemetryDelegate
>
gDelegate
;
StaticRefPtr
<
LifecycleObserver
>
gObserver
;
StaticRefPtr
<
nsITimer
>
gJICTimer
;
class
LifecycleObserver
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
LifecycleObserver
(
)
=
default
;
protected
:
~
LifecycleObserver
(
)
=
default
;
}
;
NS_IMPL_ISUPPORTS
(
LifecycleObserver
nsIObserver
)
;
NS_IMETHODIMP
LifecycleObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
kApplicationBackgroundTopic
)
)
{
StaticMutexAutoLock
lock
(
gMutex
)
;
SendBatch
(
lock
)
;
}
return
NS_OK
;
}
void
RegisterDelegate
(
const
RefPtr
<
StreamingTelemetryDelegate
>
&
aDelegate
)
{
StaticMutexAutoLock
lock
(
gMutex
)
;
gDelegate
=
aDelegate
;
}
class
SendBatchRunnable
:
public
Runnable
{
public
:
explicit
SendBatchRunnable
(
RefPtr
<
StreamingTelemetryDelegate
>
aDelegate
HistogramBatch
&
&
aBatch
HistogramBatch
&
&
aCategoricalBatch
BoolScalarBatch
&
&
aBoolScalars
StringScalarBatch
&
&
aStringScalars
UintScalarBatch
&
&
aUintScalars
)
:
Runnable
(
"
SendBatchRunnable
"
)
mDelegate
(
std
:
:
move
(
aDelegate
)
)
mBatch
(
std
:
:
move
(
aBatch
)
)
mCategoricalBatch
(
std
:
:
move
(
aCategoricalBatch
)
)
mBoolScalars
(
std
:
:
move
(
aBoolScalars
)
)
mStringScalars
(
std
:
:
move
(
aStringScalars
)
)
mUintScalars
(
std
:
:
move
(
aUintScalars
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mDelegate
)
;
if
(
gJICTimer
)
{
gJICTimer
-
>
Cancel
(
)
;
}
for
(
auto
iter
=
mBatch
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsCString
&
histogramName
=
PromiseFlatCString
(
iter
.
Key
(
)
)
;
const
nsTArray
<
uint32_t
>
&
samples
=
iter
.
Data
(
)
;
mDelegate
-
>
ReceiveHistogramSamples
(
histogramName
samples
)
;
}
mBatch
.
Clear
(
)
;
for
(
auto
iter
=
mCategoricalBatch
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsCString
&
histogramName
=
PromiseFlatCString
(
iter
.
Key
(
)
)
;
const
nsTArray
<
uint32_t
>
&
samples
=
iter
.
Data
(
)
;
mDelegate
-
>
ReceiveCategoricalHistogramSamples
(
histogramName
samples
)
;
}
mCategoricalBatch
.
Clear
(
)
;
for
(
auto
iter
=
mBoolScalars
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsCString
&
scalarName
=
PromiseFlatCString
(
iter
.
Key
(
)
)
;
mDelegate
-
>
ReceiveBoolScalarValue
(
scalarName
iter
.
Data
(
)
)
;
}
mBoolScalars
.
Clear
(
)
;
for
(
auto
iter
=
mStringScalars
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsCString
&
scalarName
=
PromiseFlatCString
(
iter
.
Key
(
)
)
;
const
nsCString
&
scalarValue
=
PromiseFlatCString
(
iter
.
Data
(
)
)
;
mDelegate
-
>
ReceiveStringScalarValue
(
scalarName
scalarValue
)
;
}
mStringScalars
.
Clear
(
)
;
for
(
auto
iter
=
mUintScalars
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsCString
&
scalarName
=
PromiseFlatCString
(
iter
.
Key
(
)
)
;
mDelegate
-
>
ReceiveUintScalarValue
(
scalarName
iter
.
Data
(
)
)
;
}
mUintScalars
.
Clear
(
)
;
return
NS_OK
;
}
private
:
RefPtr
<
StreamingTelemetryDelegate
>
mDelegate
;
HistogramBatch
mBatch
;
HistogramBatch
mCategoricalBatch
;
BoolScalarBatch
mBoolScalars
;
StringScalarBatch
mStringScalars
;
UintScalarBatch
mUintScalars
;
}
;
void
SendBatch
(
const
StaticMutexAutoLock
&
aLock
)
{
if
(
!
gDelegate
)
{
NS_WARNING
(
"
Being
asked
to
send
Streaming
Telemetry
with
no
registered
Streaming
"
"
Telemetry
Delegate
.
Will
try
again
later
.
"
)
;
gBatchBegan
=
TimeStamp
:
:
Now
(
)
;
return
;
}
HistogramBatch
histogramCopy
;
gBatch
.
SwapElements
(
histogramCopy
)
;
HistogramBatch
categoricalCopy
;
gCategoricalBatch
.
SwapElements
(
categoricalCopy
)
;
BoolScalarBatch
boolScalarCopy
;
gBoolScalars
.
SwapElements
(
boolScalarCopy
)
;
StringScalarBatch
stringScalarCopy
;
gStringScalars
.
SwapElements
(
stringScalarCopy
)
;
UintScalarBatch
uintScalarCopy
;
gUintScalars
.
SwapElements
(
uintScalarCopy
)
;
RefPtr
<
SendBatchRunnable
>
runnable
=
new
SendBatchRunnable
(
gDelegate
std
:
:
move
(
histogramCopy
)
std
:
:
move
(
categoricalCopy
)
std
:
:
move
(
boolScalarCopy
)
std
:
:
move
(
stringScalarCopy
)
std
:
:
move
(
uintScalarCopy
)
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
void
BatchCheck
(
const
StaticMutexAutoLock
&
aLock
)
{
if
(
!
gObserver
)
{
gObserver
=
new
LifecycleObserver
(
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
gObserver
kApplicationBackgroundTopic
false
)
;
}
}
if
(
gBatchBegan
.
IsNull
(
)
)
{
gBatchBegan
=
TimeStamp
:
:
Now
(
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
GeckoviewStreamingTelemetry
:
:
ArmTimer
"
[
]
(
)
-
>
void
{
if
(
!
gJICTimer
)
{
gJICTimer
=
NS_NewTimer
(
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
)
.
take
(
)
;
}
if
(
gJICTimer
)
{
gJICTimer
-
>
InitWithNamedFuncCallback
(
[
]
(
nsITimer
*
void
*
)
-
>
void
{
StaticMutexAutoLock
locker
(
gMutex
)
;
SendBatch
(
locker
)
;
}
nullptr
mozilla
:
:
StaticPrefs
:
:
toolkit_telemetry_geckoview_maxBatchStalenessMS
(
)
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
"
GeckoviewStreamingTelemetry
:
:
SendBatch
"
)
;
}
}
)
)
;
}
double
batchDurationMs
=
(
TimeStamp
:
:
Now
(
)
-
gBatchBegan
)
.
ToMilliseconds
(
)
;
if
(
batchDurationMs
>
mozilla
:
:
StaticPrefs
:
:
toolkit_telemetry_geckoview_batchDurationMS
(
)
)
{
SendBatch
(
aLock
)
;
gBatchBegan
=
TimeStamp
(
)
;
}
}
void
HistogramAccumulate
(
const
nsCString
&
aName
bool
aIsCategorical
uint32_t
aValue
)
{
StaticMutexAutoLock
lock
(
gMutex
)
;
if
(
aIsCategorical
)
{
nsTArray
<
uint32_t
>
&
samples
=
gCategoricalBatch
.
GetOrInsert
(
aName
)
;
samples
.
AppendElement
(
aValue
)
;
}
else
{
nsTArray
<
uint32_t
>
&
samples
=
gBatch
.
GetOrInsert
(
aName
)
;
samples
.
AppendElement
(
aValue
)
;
}
BatchCheck
(
lock
)
;
}
void
BoolScalarSet
(
const
nsCString
&
aName
bool
aValue
)
{
StaticMutexAutoLock
lock
(
gMutex
)
;
gBoolScalars
.
Put
(
aName
aValue
)
;
BatchCheck
(
lock
)
;
}
void
StringScalarSet
(
const
nsCString
&
aName
const
nsCString
&
aValue
)
{
StaticMutexAutoLock
lock
(
gMutex
)
;
gStringScalars
.
Put
(
aName
aValue
)
;
BatchCheck
(
lock
)
;
}
void
UintScalarSet
(
const
nsCString
&
aName
uint32_t
aValue
)
{
StaticMutexAutoLock
lock
(
gMutex
)
;
gUintScalars
.
Put
(
aName
aValue
)
;
BatchCheck
(
lock
)
;
}
}
