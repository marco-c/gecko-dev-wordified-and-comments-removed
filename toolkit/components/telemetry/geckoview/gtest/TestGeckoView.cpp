#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
JSONWriter
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsITelemetry
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
prenv
.
h
"
#
include
"
Telemetry
.
h
"
#
include
"
TelemetryFixture
.
h
"
#
include
"
TelemetryGeckoViewPersistence
.
h
"
#
include
"
TelemetryScalar
.
h
"
#
include
"
TelemetryTestHelpers
.
h
"
using
namespace
mozilla
;
using
namespace
TelemetryTestHelpers
;
const
char
kSampleData
[
]
=
R
"
(
{
"
scalars
"
:
{
"
content
"
:
{
"
telemetry
.
test
.
all_processes_uint
"
:
37
}
}
"
keyedScalars
"
:
{
"
parent
"
:
{
"
telemetry
.
test
.
keyed_unsigned_int
"
:
{
"
testKey
"
:
73
}
}
}
}
)
"
;
const
char16_t
kPersistedFilename
[
]
=
u
"
gv_measurements
.
json
"
;
namespace
{
void
GetMockedDataDir
(
nsAString
&
aMockedDir
)
{
nsCOMPtr
<
nsIFile
>
tmpDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_OS_TEMP_DIR
getter_AddRefs
(
tmpDir
)
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
rv
=
tmpDir
-
>
GetPath
(
aMockedDir
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
}
void
MockAndroidDataDir
(
)
{
nsAutoString
mockedPath
;
GetMockedDataDir
(
mockedPath
)
;
nsAutoCString
mockedEnv
(
nsPrintfCString
(
"
MOZ_ANDROID_DATA_DIR
=
%
s
"
NS_ConvertUTF16toUTF8
(
mockedPath
)
.
get
(
)
)
)
;
ASSERT_EQ
(
PR_SetEnv
(
ToNewCString
(
mockedEnv
)
)
PR_SUCCESS
)
;
}
void
WritePersistenceFile
(
const
nsACString
&
aData
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_OS_TEMP_DIR
getter_AddRefs
(
file
)
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
nsAutoString
fileName
;
fileName
.
Append
(
kPersistedFilename
)
;
file
-
>
Append
(
fileName
)
;
nsCOMPtr
<
nsIOutputStream
>
stream
;
rv
=
NS_NewLocalFileOutputStream
(
getter_AddRefs
(
stream
)
file
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
uint32_t
count
;
rv
=
stream
-
>
Write
(
aData
.
Data
(
)
aData
.
Length
(
)
&
count
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
ASSERT_EQ
(
count
aData
.
Length
(
)
)
;
stream
-
>
Close
(
)
;
}
void
RemovePersistenceFile
(
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_OS_TEMP_DIR
getter_AddRefs
(
file
)
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
nsAutoString
fileName
;
fileName
.
Append
(
kPersistedFilename
)
;
file
-
>
Append
(
fileName
)
;
bool
exists
=
true
;
rv
=
file
-
>
Exists
(
&
exists
)
;
ASSERT_EQ
(
NS_OK
rv
)
<
<
"
nsIFile
:
:
Exists
cannot
fail
"
;
if
(
exists
)
{
rv
=
file
-
>
Remove
(
false
)
;
ASSERT_EQ
(
NS_OK
rv
)
<
<
"
nsIFile
:
:
Remove
cannot
delete
the
requested
file
"
;
}
}
void
CheckPersistenceFileExists
(
bool
&
aFileExists
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_OS_TEMP_DIR
getter_AddRefs
(
file
)
)
;
ASSERT_EQ
(
NS_OK
rv
)
<
<
"
NS_GetSpecialDirectory
must
return
a
valid
directory
"
;
nsAutoString
fileName
;
fileName
.
Append
(
kPersistedFilename
)
;
file
-
>
Append
(
fileName
)
;
rv
=
file
-
>
Exists
(
&
aFileExists
)
;
ASSERT_EQ
(
NS_OK
rv
)
<
<
"
nsIFile
:
:
Exists
must
not
fail
"
;
}
void
CheckJSONEqual
(
JSContext
*
aCx
JS
:
:
HandleValue
aData
JS
:
:
HandleValue
aDataOther
)
{
auto
JSONCreator
=
[
]
(
const
char16_t
*
aBuf
uint32_t
aLen
void
*
aData
)
-
>
bool
{
nsAString
*
result
=
static_cast
<
nsAString
*
>
(
aData
)
;
result
-
>
Append
(
static_cast
<
const
char16_t
*
>
(
aBuf
)
static_cast
<
uint32_t
>
(
aLen
)
)
;
return
true
;
}
;
nsAutoString
dataAsString
;
JS
:
:
RootedObject
dataObj
(
aCx
&
aData
.
toObject
(
)
)
;
ASSERT_TRUE
(
JS
:
:
ToJSONMaybeSafely
(
aCx
dataObj
JSONCreator
&
dataAsString
)
)
<
<
"
The
JS
object
must
be
correctly
converted
to
a
JSON
string
"
;
nsAutoString
otherAsString
;
JS
:
:
RootedObject
otherObj
(
aCx
&
aDataOther
.
toObject
(
)
)
;
ASSERT_TRUE
(
JS
:
:
ToJSONMaybeSafely
(
aCx
otherObj
JSONCreator
&
otherAsString
)
)
<
<
"
The
JS
object
must
be
correctly
converted
to
a
JSON
string
"
;
ASSERT_TRUE
(
dataAsString
.
Equals
(
otherAsString
)
)
<
<
"
The
JSON
strings
must
match
"
;
}
void
TestSerializeScalars
(
JSONWriter
&
aWriter
)
{
aWriter
.
StartObjectProperty
(
"
content
"
)
;
aWriter
.
IntProperty
(
"
telemetry
.
test
.
all_processes_uint
"
37
)
;
aWriter
.
EndObject
(
)
;
}
void
TestSerializeKeyedScalars
(
JSONWriter
&
aWriter
)
{
aWriter
.
StartObjectProperty
(
"
parent
"
)
;
aWriter
.
StartObjectProperty
(
"
telemetry
.
test
.
keyed_unsigned_int
"
)
;
aWriter
.
IntProperty
(
"
testKey
"
73
)
;
aWriter
.
EndObject
(
)
;
aWriter
.
EndObject
(
)
;
}
void
TestDeserializePersistedScalars
(
JSContext
*
aCx
JS
:
:
HandleValue
aData
)
{
JS
:
:
RootedValue
sampleData
(
aCx
)
;
NS_ConvertUTF8toUTF16
utf16Content
(
kSampleData
)
;
ASSERT_TRUE
(
JS_ParseJSON
(
aCx
utf16Content
.
BeginReading
(
)
utf16Content
.
Length
(
)
&
sampleData
)
)
<
<
"
Failed
to
create
a
JS
object
from
the
JSON
sample
"
;
JS
:
:
RootedObject
sampleObj
(
aCx
&
sampleData
.
toObject
(
)
)
;
JS
:
:
RootedValue
scalarData
(
aCx
)
;
ASSERT_TRUE
(
JS_GetProperty
(
aCx
sampleObj
"
scalars
"
&
scalarData
)
&
&
scalarData
.
isObject
(
)
)
<
<
"
Failed
to
get
sampleData
[
'
scalars
'
]
"
;
CheckJSONEqual
(
aCx
aData
scalarData
)
;
}
void
TestDeserializePersistedKeyedScalars
(
JSContext
*
aCx
JS
:
:
HandleValue
aData
)
{
JS
:
:
RootedValue
sampleData
(
aCx
)
;
NS_ConvertUTF8toUTF16
utf16Content
(
kSampleData
)
;
ASSERT_TRUE
(
JS_ParseJSON
(
aCx
utf16Content
.
BeginReading
(
)
utf16Content
.
Length
(
)
&
sampleData
)
)
<
<
"
Failed
to
create
a
JS
object
from
the
JSON
sample
"
;
JS
:
:
RootedObject
sampleObj
(
aCx
&
sampleData
.
toObject
(
)
)
;
JS
:
:
RootedValue
keyedScalarData
(
aCx
)
;
ASSERT_TRUE
(
JS_GetProperty
(
aCx
sampleObj
"
keyedScalars
"
&
keyedScalarData
)
&
&
keyedScalarData
.
isObject
(
)
)
<
<
"
Failed
to
get
sampleData
[
'
keyedScalars
'
]
"
;
CheckJSONEqual
(
aCx
aData
keyedScalarData
)
;
}
}
class
TelemetryGeckoViewFixture
:
public
TelemetryTestFixture
{
protected
:
virtual
void
SetUp
(
)
{
TelemetryTestFixture
:
:
SetUp
(
)
;
MockAndroidDataDir
(
)
;
}
}
;
namespace
TelemetryScalar
{
nsresult
SerializeScalars
(
JSONWriter
&
aWriter
)
{
TestSerializeScalars
(
aWriter
)
;
return
NS_OK
;
}
nsresult
SerializeKeyedScalars
(
JSONWriter
&
aWriter
)
{
TestSerializeKeyedScalars
(
aWriter
)
;
return
NS_OK
;
}
nsresult
DeserializePersistedScalars
(
JSContext
*
aCx
JS
:
:
HandleValue
aData
)
{
TestDeserializePersistedScalars
(
aCx
aData
)
;
return
NS_OK
;
}
nsresult
DeserializePersistedKeyedScalars
(
JSContext
*
aCx
JS
:
:
HandleValue
aData
)
{
TestDeserializePersistedKeyedScalars
(
aCx
aData
)
;
return
NS_OK
;
}
}
namespace
TelemetryGeckoViewTesting
{
void
TestDispatchPersist
(
)
;
}
TEST_F
(
TelemetryGeckoViewFixture
CorruptedPersistenceFiles
)
{
AutoJSContextWithGlobal
cx
(
mCleanGlobal
)
;
WritePersistenceFile
(
NS_LITERAL_CSTRING
(
"
{
"
)
)
;
TelemetryGeckoViewPersistence
:
:
InitPersistence
(
)
;
TelemetryGeckoViewPersistence
:
:
DeInitPersistence
(
)
;
RemovePersistenceFile
(
)
;
}
TEST_F
(
TelemetryGeckoViewFixture
EmptyPersistenceFiles
)
{
AutoJSContextWithGlobal
cx
(
mCleanGlobal
)
;
WritePersistenceFile
(
EmptyCString
(
)
)
;
TelemetryGeckoViewPersistence
:
:
InitPersistence
(
)
;
TelemetryGeckoViewPersistence
:
:
DeInitPersistence
(
)
;
RemovePersistenceFile
(
)
;
}
TEST_F
(
TelemetryGeckoViewFixture
ClearPersistenceFiles
)
{
AutoJSContextWithGlobal
cx
(
mCleanGlobal
)
;
bool
fileExists
=
false
;
CheckPersistenceFileExists
(
fileExists
)
;
ASSERT_FALSE
(
fileExists
)
<
<
"
No
persisted
measurements
must
exist
on
the
disk
"
;
WritePersistenceFile
(
nsDependentCString
(
kSampleData
)
)
;
CheckPersistenceFileExists
(
fileExists
)
;
ASSERT_TRUE
(
fileExists
)
<
<
"
We
should
have
written
the
test
persistence
file
to
disk
"
;
TelemetryGeckoViewPersistence
:
:
InitPersistence
(
)
;
TelemetryGeckoViewPersistence
:
:
ClearPersistenceData
(
)
;
TelemetryGeckoViewPersistence
:
:
DeInitPersistence
(
)
;
CheckPersistenceFileExists
(
fileExists
)
;
ASSERT_FALSE
(
fileExists
)
<
<
"
ClearPersistenceData
must
remove
the
persistence
file
"
;
}
TEST_F
(
TelemetryGeckoViewFixture
PersistData
)
{
AutoJSContextWithGlobal
cx
(
mCleanGlobal
)
;
bool
fileExists
=
false
;
CheckPersistenceFileExists
(
fileExists
)
;
ASSERT_FALSE
(
fileExists
)
<
<
"
No
persisted
measurements
must
exist
on
the
disk
"
;
TelemetryGeckoViewPersistence
:
:
InitPersistence
(
)
;
TelemetryGeckoViewTesting
:
:
TestDispatchPersist
(
)
;
TelemetryGeckoViewPersistence
:
:
DeInitPersistence
(
)
;
CheckPersistenceFileExists
(
fileExists
)
;
ASSERT_TRUE
(
fileExists
)
<
<
"
The
persisted
measurements
must
exist
on
the
disk
"
;
TelemetryGeckoViewPersistence
:
:
InitPersistence
(
)
;
TelemetryGeckoViewPersistence
:
:
DeInitPersistence
(
)
;
RemovePersistenceFile
(
)
;
}
