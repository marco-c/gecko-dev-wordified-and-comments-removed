"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
EventDispatcher
:
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
TelemetryUtils
:
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
}
)
;
GeckoViewUtils
.
initLogging
(
"
GeckoView
.
TelemetryController
"
this
)
;
var
EXPORTED_SYMBOLS
=
[
"
GeckoViewTelemetryController
"
]
;
const
LOAD_COMPLETE_TOPIC
=
"
internal
-
telemetry
-
geckoview
-
load
-
complete
"
;
const
GeckoViewTelemetryController
=
{
setup
(
)
{
TelemetryUtils
.
setTelemetryRecordingFlags
(
)
;
debug
setup
-
canRecordPrereleaseData
{
Services
.
telemetry
.
canRecordPrereleaseData
}
canRecordReleaseData
{
Services
.
telemetry
.
canRecordReleaseData
}
;
if
(
GeckoViewUtils
.
IS_PARENT_PROCESS
)
{
this
.
_loadComplete
=
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observer
(
aSubject
aTopic
aData
)
{
if
(
aTopic
!
=
=
LOAD_COMPLETE_TOPIC
)
{
warn
Received
unexpected
topic
{
aTopic
}
;
return
;
}
debug
observed
{
aTopic
}
-
ready
to
handle
telemetry
requests
;
Services
.
obs
.
removeObserver
(
observer
LOAD_COMPLETE_TOPIC
)
;
resolve
(
)
;
}
LOAD_COMPLETE_TOPIC
)
;
}
)
;
try
{
EventDispatcher
.
instance
.
registerListener
(
this
[
"
GeckoView
:
TelemetrySnapshots
"
]
)
;
}
catch
(
e
)
{
warn
Failed
registering
GeckoView
:
TelemetrySnapshots
listener
:
{
e
}
;
}
}
}
onEvent
(
aEvent
aData
aCallback
)
{
debug
onEvent
:
aEvent
=
{
aEvent
}
aData
=
{
aData
}
;
if
(
aEvent
!
=
=
"
GeckoView
:
TelemetrySnapshots
"
)
{
warn
Received
unexpected
event
{
aEvent
}
;
return
;
}
this
.
_loadComplete
.
then
(
(
)
=
>
this
.
retrieveSnapshots
(
aData
.
clear
aCallback
)
)
;
}
retrieveSnapshots
(
aClear
aCallback
)
{
debug
retrieveSnapshots
;
const
dataset
=
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
;
const
rawHistograms
=
Services
.
telemetry
.
snapshotHistograms
(
dataset
false
false
)
;
const
rawKeyedHistograms
=
Services
.
telemetry
.
snapshotKeyedHistograms
(
dataset
false
false
)
;
const
scalars
=
Services
.
telemetry
.
snapshotScalars
(
dataset
false
)
;
const
keyedScalars
=
Services
.
telemetry
.
snapshotKeyedScalars
(
dataset
false
)
;
const
snapshots
=
{
histograms
:
TelemetryUtils
.
packHistograms
(
rawHistograms
)
keyedHistograms
:
TelemetryUtils
.
packKeyedHistograms
(
rawKeyedHistograms
)
scalars
keyedScalars
}
;
if
(
!
snapshots
.
histograms
|
|
!
snapshots
.
keyedHistograms
|
|
!
snapshots
.
scalars
|
|
!
snapshots
.
keyedScalars
)
{
aCallback
.
onError
(
Failed
retrieving
snapshots
!
)
;
return
;
}
let
processSnapshots
=
{
}
;
for
(
let
[
name
snapshot
]
of
Object
.
entries
(
snapshots
)
)
{
for
(
let
[
processName
processSnapshot
]
of
Object
.
entries
(
snapshot
)
)
{
if
(
!
(
processName
in
processSnapshots
)
)
{
processSnapshots
[
processName
]
=
{
}
;
}
processSnapshots
[
processName
]
[
name
]
=
processSnapshot
;
}
}
if
(
aClear
)
{
Services
.
telemetry
.
clearProbes
(
)
;
}
aCallback
.
onSuccess
(
processSnapshots
)
;
}
}
;
