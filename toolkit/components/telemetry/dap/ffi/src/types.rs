use
prio
:
:
codec
:
:
{
decode_u16_items
decode_u32_items
encode_u16_items
encode_u32_items
CodecError
Decode
Encode
}
;
use
std
:
:
io
:
:
{
Cursor
Read
}
;
use
std
:
:
time
:
:
{
SystemTime
UNIX_EPOCH
}
;
use
rand
:
:
Rng
;
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
struct
TaskID
(
pub
[
u8
;
32
]
)
;
impl
Decode
for
TaskID
{
fn
decode
(
bytes
:
&
mut
Cursor
<
&
[
u8
]
>
)
-
>
Result
<
Self
CodecError
>
{
let
mut
data
:
[
u8
;
32
]
=
[
0
;
32
]
;
bytes
.
read_exact
(
&
mut
data
)
?
;
Ok
(
TaskID
(
data
)
)
}
}
impl
Encode
for
TaskID
{
fn
encode
(
&
self
bytes
:
&
mut
Vec
<
u8
>
)
{
bytes
.
extend_from_slice
(
&
self
.
0
)
;
}
}
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
struct
Time
(
pub
u64
)
;
impl
Decode
for
Time
{
fn
decode
(
bytes
:
&
mut
Cursor
<
&
[
u8
]
>
)
-
>
Result
<
Self
CodecError
>
{
Ok
(
Time
(
u64
:
:
decode
(
bytes
)
?
)
)
}
}
impl
Encode
for
Time
{
fn
encode
(
&
self
bytes
:
&
mut
Vec
<
u8
>
)
{
u64
:
:
encode
(
&
self
.
0
bytes
)
;
}
}
impl
Time
{
pub
fn
generate
(
time_precision
:
u64
)
-
>
Time
{
let
now_secs
=
SystemTime
:
:
now
(
)
.
duration_since
(
UNIX_EPOCH
)
.
expect
(
"
Failed
to
get
time
.
"
)
.
as_secs
(
)
;
let
timestamp
=
(
now_secs
/
time_precision
)
*
time_precision
;
Time
(
timestamp
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
Extension
{
extension_type
:
ExtensionType
extension_data
:
Vec
<
u8
>
}
impl
Decode
for
Extension
{
fn
decode
(
bytes
:
&
mut
Cursor
<
&
[
u8
]
>
)
-
>
Result
<
Self
CodecError
>
{
let
extension_type
=
ExtensionType
:
:
from_u16
(
u16
:
:
decode
(
bytes
)
?
)
;
let
extension_data
:
Vec
<
u8
>
=
decode_u16_items
(
&
(
)
bytes
)
?
;
Ok
(
Extension
{
extension_type
extension_data
}
)
}
}
impl
Encode
for
Extension
{
fn
encode
(
&
self
bytes
:
&
mut
Vec
<
u8
>
)
{
(
self
.
extension_type
as
u16
)
.
encode
(
bytes
)
;
encode_u16_items
(
bytes
&
(
)
&
self
.
extension_data
)
;
}
}
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
#
[
repr
(
u16
)
]
enum
ExtensionType
{
Tbd
=
0
}
impl
ExtensionType
{
fn
from_u16
(
value
:
u16
)
-
>
ExtensionType
{
match
value
{
0
=
>
ExtensionType
:
:
Tbd
_
=
>
panic
!
(
"
Unknown
value
for
Extension
Type
:
{
}
"
value
)
}
}
}
#
[
derive
(
Debug
PartialEq
Eq
Copy
Clone
)
]
pub
struct
HpkeConfigId
(
u8
)
;
impl
Decode
for
HpkeConfigId
{
fn
decode
(
bytes
:
&
mut
Cursor
<
&
[
u8
]
>
)
-
>
Result
<
Self
CodecError
>
{
Ok
(
HpkeConfigId
(
u8
:
:
decode
(
bytes
)
?
)
)
}
}
impl
Encode
for
HpkeConfigId
{
fn
encode
(
&
self
bytes
:
&
mut
Vec
<
u8
>
)
{
self
.
0
.
encode
(
bytes
)
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
HpkeConfig
{
pub
id
:
HpkeConfigId
pub
kem_id
:
u16
pub
kdf_id
:
u16
pub
aead_id
:
u16
pub
public_key
:
Vec
<
u8
>
}
impl
Decode
for
HpkeConfig
{
fn
decode
(
bytes
:
&
mut
Cursor
<
&
[
u8
]
>
)
-
>
Result
<
Self
CodecError
>
{
Ok
(
HpkeConfig
{
id
:
HpkeConfigId
:
:
decode
(
bytes
)
?
kem_id
:
u16
:
:
decode
(
bytes
)
?
kdf_id
:
u16
:
:
decode
(
bytes
)
?
aead_id
:
u16
:
:
decode
(
bytes
)
?
public_key
:
decode_u16_items
(
&
(
)
bytes
)
?
}
)
}
}
impl
Encode
for
HpkeConfig
{
fn
encode
(
&
self
bytes
:
&
mut
Vec
<
u8
>
)
{
self
.
id
.
encode
(
bytes
)
;
self
.
kem_id
.
encode
(
bytes
)
;
self
.
kdf_id
.
encode
(
bytes
)
;
self
.
aead_id
.
encode
(
bytes
)
;
encode_u16_items
(
bytes
&
(
)
&
self
.
public_key
)
;
}
}
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
struct
HpkeCiphertext
{
pub
config_id
:
HpkeConfigId
pub
enc
:
Vec
<
u8
>
pub
payload
:
Vec
<
u8
>
}
impl
Decode
for
HpkeCiphertext
{
fn
decode
(
bytes
:
&
mut
Cursor
<
&
[
u8
]
>
)
-
>
Result
<
Self
CodecError
>
{
let
config_id
=
HpkeConfigId
:
:
decode
(
bytes
)
?
;
let
enc
:
Vec
<
u8
>
=
decode_u16_items
(
&
(
)
bytes
)
?
;
let
payload
:
Vec
<
u8
>
=
decode_u32_items
(
&
(
)
bytes
)
?
;
Ok
(
HpkeCiphertext
{
config_id
enc
payload
}
)
}
}
impl
Encode
for
HpkeCiphertext
{
fn
encode
(
&
self
bytes
:
&
mut
Vec
<
u8
>
)
{
self
.
config_id
.
encode
(
bytes
)
;
encode_u16_items
(
bytes
&
(
)
&
self
.
enc
)
;
encode_u32_items
(
bytes
&
(
)
&
self
.
payload
)
;
}
}
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
struct
ReportID
(
pub
[
u8
;
16
]
)
;
impl
Decode
for
ReportID
{
fn
decode
(
bytes
:
&
mut
Cursor
<
&
[
u8
]
>
)
-
>
Result
<
Self
CodecError
>
{
let
mut
data
:
[
u8
;
16
]
=
[
0
;
16
]
;
bytes
.
read_exact
(
&
mut
data
)
?
;
Ok
(
ReportID
(
data
)
)
}
}
impl
Encode
for
ReportID
{
fn
encode
(
&
self
bytes
:
&
mut
Vec
<
u8
>
)
{
bytes
.
extend_from_slice
(
&
self
.
0
)
;
}
}
impl
ReportID
{
pub
fn
generate
(
)
-
>
ReportID
{
ReportID
(
rand
:
:
thread_rng
(
)
.
gen
(
)
)
}
}
impl
AsRef
<
[
u8
;
16
]
>
for
ReportID
{
fn
as_ref
(
&
self
)
-
>
&
[
u8
;
16
]
{
&
self
.
0
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
ReportMetadata
{
pub
report_id
:
ReportID
pub
time
:
Time
}
impl
Decode
for
ReportMetadata
{
fn
decode
(
bytes
:
&
mut
Cursor
<
&
[
u8
]
>
)
-
>
Result
<
Self
CodecError
>
{
let
report_id
=
ReportID
:
:
decode
(
bytes
)
?
;
let
time
=
Time
:
:
decode
(
bytes
)
?
;
Ok
(
ReportMetadata
{
report_id
time
}
)
}
}
impl
Encode
for
ReportMetadata
{
fn
encode
(
&
self
bytes
:
&
mut
Vec
<
u8
>
)
{
self
.
report_id
.
encode
(
bytes
)
;
self
.
time
.
encode
(
bytes
)
;
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
Report
{
pub
metadata
:
ReportMetadata
pub
public_share
:
Vec
<
u8
>
pub
encrypted_input_shares
:
Vec
<
HpkeCiphertext
>
}
impl
Report
{
pub
fn
new_dummy
(
)
-
>
Self
{
Report
{
metadata
:
ReportMetadata
{
report_id
:
ReportID
:
:
generate
(
)
time
:
Time
:
:
generate
(
1
)
}
public_share
:
vec
!
[
]
encrypted_input_shares
:
vec
!
[
]
}
}
}
impl
Decode
for
Report
{
fn
decode
(
bytes
:
&
mut
Cursor
<
&
[
u8
]
>
)
-
>
Result
<
Self
CodecError
>
{
let
metadata
=
ReportMetadata
:
:
decode
(
bytes
)
?
;
let
public_share
:
Vec
<
u8
>
=
decode_u32_items
(
&
(
)
bytes
)
?
;
let
encrypted_input_shares
:
Vec
<
HpkeCiphertext
>
=
decode_u32_items
(
&
(
)
bytes
)
?
;
let
remaining_bytes
=
bytes
.
get_ref
(
)
.
len
(
)
-
(
bytes
.
position
(
)
as
usize
)
;
if
remaining_bytes
=
=
0
{
Ok
(
Report
{
metadata
public_share
encrypted_input_shares
}
)
}
else
{
Err
(
CodecError
:
:
BytesLeftOver
(
remaining_bytes
)
)
}
}
}
impl
Encode
for
Report
{
fn
encode
(
&
self
bytes
:
&
mut
Vec
<
u8
>
)
{
self
.
metadata
.
encode
(
bytes
)
;
encode_u32_items
(
bytes
&
(
)
&
self
.
public_share
)
;
encode_u32_items
(
bytes
&
(
)
&
self
.
encrypted_input_shares
)
;
}
}
