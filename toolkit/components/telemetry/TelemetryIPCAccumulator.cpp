#
include
"
TelemetryIPCAccumulator
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
TelemetryHistogram
.
h
"
using
mozilla
:
:
StaticMutex
;
using
mozilla
:
:
StaticMutexAutoLock
;
using
mozilla
:
:
StaticAutoPtr
;
using
mozilla
:
:
Telemetry
:
:
Accumulation
;
using
mozilla
:
:
Telemetry
:
:
KeyedAccumulation
;
const
uint32_t
kBatchTimeoutMs
=
2000
;
const
size_t
kHistogramAccumulationsArrayHighWaterMark
=
5
*
1024
;
nsITimer
*
gIPCTimer
=
nullptr
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
gIPCTimerArmed
(
false
)
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
gIPCTimerArming
(
false
)
;
StaticAutoPtr
<
nsTArray
<
Accumulation
>
>
gHistogramAccumulations
;
StaticAutoPtr
<
nsTArray
<
KeyedAccumulation
>
>
gKeyedHistogramAccumulations
;
static
StaticMutex
gTelemetryIPCAccumulatorMutex
;
namespace
{
void
DoArmIPCTimerMainThread
(
const
StaticMutexAutoLock
&
lock
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
gIPCTimerArming
=
false
;
if
(
gIPCTimerArmed
)
{
return
;
}
if
(
!
gIPCTimer
)
{
CallCreateInstance
(
NS_TIMER_CONTRACTID
&
gIPCTimer
)
;
}
if
(
gIPCTimer
)
{
gIPCTimer
-
>
InitWithFuncCallback
(
TelemetryIPCAccumulator
:
:
IPCTimerFired
nullptr
kBatchTimeoutMs
nsITimer
:
:
TYPE_ONE_SHOT
)
;
gIPCTimerArmed
=
true
;
}
}
void
ArmIPCTimer
(
const
StaticMutexAutoLock
&
lock
)
{
if
(
gIPCTimerArmed
|
|
gIPCTimerArming
)
{
return
;
}
gIPCTimerArming
=
true
;
if
(
NS_IsMainThread
(
)
)
{
DoArmIPCTimerMainThread
(
lock
)
;
}
else
{
TelemetryIPCAccumulator
:
:
DispatchToMainThread
(
NS_NewRunnableFunction
(
[
]
(
)
-
>
void
{
StaticMutexAutoLock
locker
(
gTelemetryIPCAccumulatorMutex
)
;
DoArmIPCTimerMainThread
(
locker
)
;
}
)
)
;
}
}
}
void
TelemetryIPCAccumulator
:
:
AccumulateChildHistogram
(
mozilla
:
:
Telemetry
:
:
ID
aId
uint32_t
aSample
)
{
StaticMutexAutoLock
locker
(
gTelemetryIPCAccumulatorMutex
)
;
if
(
!
gHistogramAccumulations
)
{
gHistogramAccumulations
=
new
nsTArray
<
Accumulation
>
(
)
;
}
if
(
gHistogramAccumulations
-
>
Length
(
)
=
=
kHistogramAccumulationsArrayHighWaterMark
)
{
TelemetryIPCAccumulator
:
:
DispatchToMainThread
(
NS_NewRunnableFunction
(
[
]
(
)
-
>
void
{
TelemetryIPCAccumulator
:
:
IPCTimerFired
(
nullptr
nullptr
)
;
}
)
)
;
}
gHistogramAccumulations
-
>
AppendElement
(
Accumulation
{
aId
aSample
}
)
;
ArmIPCTimer
(
locker
)
;
}
void
TelemetryIPCAccumulator
:
:
AccumulateChildKeyedHistogram
(
mozilla
:
:
Telemetry
:
:
ID
aId
const
nsCString
&
aKey
uint32_t
aSample
)
{
StaticMutexAutoLock
locker
(
gTelemetryIPCAccumulatorMutex
)
;
if
(
!
gKeyedHistogramAccumulations
)
{
gKeyedHistogramAccumulations
=
new
nsTArray
<
KeyedAccumulation
>
(
)
;
}
if
(
gKeyedHistogramAccumulations
-
>
Length
(
)
=
=
kHistogramAccumulationsArrayHighWaterMark
)
{
TelemetryIPCAccumulator
:
:
DispatchToMainThread
(
NS_NewRunnableFunction
(
[
]
(
)
-
>
void
{
TelemetryIPCAccumulator
:
:
IPCTimerFired
(
nullptr
nullptr
)
;
}
)
)
;
}
gKeyedHistogramAccumulations
-
>
AppendElement
(
KeyedAccumulation
{
aId
aSample
aKey
}
)
;
ArmIPCTimer
(
locker
)
;
}
void
TelemetryIPCAccumulator
:
:
IPCTimerFired
(
nsITimer
*
aTimer
void
*
aClosure
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
Accumulation
>
accumulationsToSend
;
nsTArray
<
KeyedAccumulation
>
keyedAccumulationsToSend
;
{
StaticMutexAutoLock
locker
(
gTelemetryIPCAccumulatorMutex
)
;
if
(
gHistogramAccumulations
)
{
accumulationsToSend
.
SwapElements
(
*
gHistogramAccumulations
)
;
}
if
(
gKeyedHistogramAccumulations
)
{
keyedAccumulationsToSend
.
SwapElements
(
*
gKeyedHistogramAccumulations
)
;
}
}
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Content
:
{
mozilla
:
:
dom
:
:
ContentChild
*
contentChild
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
mozilla
:
:
Unused
<
<
NS_WARN_IF
(
!
contentChild
)
;
if
(
contentChild
)
{
if
(
accumulationsToSend
.
Length
(
)
)
{
mozilla
:
:
Unused
<
<
NS_WARN_IF
(
!
contentChild
-
>
SendAccumulateChildHistogram
(
accumulationsToSend
)
)
;
}
if
(
keyedAccumulationsToSend
.
Length
(
)
)
{
mozilla
:
:
Unused
<
<
NS_WARN_IF
(
!
contentChild
-
>
SendAccumulateChildKeyedHistogram
(
keyedAccumulationsToSend
)
)
;
}
}
break
;
}
case
GeckoProcessType_GPU
:
{
if
(
mozilla
:
:
gfx
:
:
GPUParent
*
gpu
=
mozilla
:
:
gfx
:
:
GPUParent
:
:
GetSingleton
(
)
)
{
if
(
accumulationsToSend
.
Length
(
)
)
{
mozilla
:
:
Unused
<
<
gpu
-
>
SendAccumulateChildHistogram
(
accumulationsToSend
)
;
}
if
(
keyedAccumulationsToSend
.
Length
(
)
)
{
mozilla
:
:
Unused
<
<
gpu
-
>
SendAccumulateChildKeyedHistogram
(
keyedAccumulationsToSend
)
;
}
}
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
process
type
"
)
;
break
;
}
gIPCTimerArmed
=
false
;
}
void
TelemetryIPCAccumulator
:
:
DeInitializeGlobalState
(
)
{
StaticMutexAutoLock
locker
(
gTelemetryIPCAccumulatorMutex
)
;
if
(
gIPCTimer
)
{
NS_RELEASE
(
gIPCTimer
)
;
}
gHistogramAccumulations
=
nullptr
;
gKeyedHistogramAccumulations
=
nullptr
;
}
void
TelemetryIPCAccumulator
:
:
DispatchToMainThread
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
nsCOMPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_GetMainThread
(
getter_AddRefs
(
thread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
NS_FAILED
DispatchToMainThread
.
Maybe
we
'
re
shutting
down
?
"
)
;
return
;
}
thread
-
>
Dispatch
(
event
0
)
;
}
