"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
TelemetrySend
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ClientID
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ServiceRequest
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
this
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AsyncShutdown
"
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryStorage
"
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryReportingPolicy
"
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
Telemetry
"
"
mozilla
.
org
/
base
/
telemetry
;
1
"
"
nsITelemetry
"
)
;
const
Utils
=
TelemetryUtils
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
LOGGER_PREFIX
=
"
TelemetrySend
:
:
"
;
const
TOPIC_IDLE_DAILY
=
"
idle
-
daily
"
;
const
TOPIC_QUIT_APPLICATION_GRANTED
=
"
quit
-
application
-
granted
"
;
const
TOPIC_QUIT_APPLICATION_FORCED
=
"
quit
-
application
-
forced
"
;
const
IS_UNIFIED_TELEMETRY
=
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
const
PING_FORMAT_VERSION
=
4
;
const
MS_IN_A_MINUTE
=
60
*
1000
;
const
PING_TYPE_DELETION
=
"
deletion
"
;
const
MIDNIGHT_FUZZING_INTERVAL_MS
=
60
*
MS_IN_A_MINUTE
;
const
MIDNIGHT_FUZZING_DELAY_MS
=
Math
.
random
(
)
*
MIDNIGHT_FUZZING_INTERVAL_MS
;
const
PING_SUBMIT_TIMEOUT_MS
=
1
.
5
*
MS_IN_A_MINUTE
;
const
MAX_PING_SENDS_PER_MINUTE
=
10
;
const
SEND_TICK_DELAY
=
1
*
MS_IN_A_MINUTE
;
const
SEND_MAXIMUM_BACKOFF_DELAY_MS
=
120
*
MS_IN_A_MINUTE
;
const
OVERDUE_PING_FILE_AGE
=
7
*
24
*
60
*
MS_IN_A_MINUTE
;
const
XHR_ERROR_TYPE
=
[
"
eOK
"
"
eRequest
"
"
eUnreachable
"
"
eChannelOpen
"
"
eRedirect
"
]
;
function
monotonicNow
(
)
{
try
{
return
Telemetry
.
msSinceProcessStart
(
)
;
}
catch
(
ex
)
{
return
Date
.
now
(
)
;
}
}
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
midnightPingFuzzingDelay
:
(
)
=
>
MIDNIGHT_FUZZING_DELAY_MS
setSchedulerTickTimeout
:
(
callback
delayMs
)
=
>
setTimeout
(
callback
delayMs
)
clearSchedulerTickTimeout
:
(
id
)
=
>
clearTimeout
(
id
)
}
;
function
isV4PingFormat
(
aPing
)
{
return
(
"
id
"
in
aPing
)
&
&
(
"
application
"
in
aPing
)
&
&
(
"
version
"
in
aPing
)
&
&
(
aPing
.
version
>
=
2
)
;
}
function
isDeletionPing
(
aPing
)
{
return
isV4PingFormat
(
aPing
)
&
&
(
aPing
.
type
=
=
PING_TYPE_DELETION
)
;
}
function
savePing
(
aPing
)
{
if
(
isDeletionPing
(
aPing
)
)
{
return
TelemetryStorage
.
saveDeletionPing
(
aPing
)
;
}
return
TelemetryStorage
.
savePendingPing
(
aPing
)
;
}
function
gzipCompressString
(
string
)
{
let
observer
=
{
buffer
:
"
"
onStreamComplete
(
loader
context
status
length
result
)
{
this
.
buffer
=
String
.
fromCharCode
.
apply
(
this
result
)
;
}
}
;
let
scs
=
Cc
[
"
mozilla
.
org
/
streamConverters
;
1
"
]
.
getService
(
Ci
.
nsIStreamConverterService
)
;
let
listener
=
Cc
[
"
mozilla
.
org
/
network
/
stream
-
loader
;
1
"
]
.
createInstance
(
Ci
.
nsIStreamLoader
)
;
listener
.
init
(
observer
)
;
let
converter
=
scs
.
asyncConvertData
(
"
uncompressed
"
"
gzip
"
listener
null
)
;
let
stringStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stringStream
.
data
=
string
;
converter
.
onStartRequest
(
null
null
)
;
converter
.
onDataAvailable
(
null
null
stringStream
0
string
.
length
)
;
converter
.
onStopRequest
(
null
null
null
)
;
return
observer
.
buffer
;
}
this
.
TelemetrySend
=
{
get
OVERDUE_PING_FILE_AGE
(
)
{
return
OVERDUE_PING_FILE_AGE
;
}
get
pendingPingCount
(
)
{
return
TelemetrySendImpl
.
pendingPingCount
;
}
earlyInit
(
)
{
TelemetrySendImpl
.
earlyInit
(
)
;
}
setup
(
testing
=
false
)
{
return
TelemetrySendImpl
.
setup
(
testing
)
;
}
shutdown
(
)
{
return
TelemetrySendImpl
.
shutdown
(
)
;
}
submitPing
(
ping
options
=
{
}
)
{
options
.
usePingSender
=
options
.
usePingSender
|
|
false
;
return
TelemetrySendImpl
.
submitPing
(
ping
options
)
;
}
get
overduePingsCount
(
)
{
return
TelemetrySendImpl
.
overduePingsCount
;
}
notifyCanUpload
(
)
{
return
TelemetrySendImpl
.
notifyCanUpload
(
)
;
}
reset
(
)
{
return
TelemetrySendImpl
.
reset
(
)
;
}
setServer
(
server
)
{
return
TelemetrySendImpl
.
setServer
(
server
)
;
}
clearCurrentPings
(
)
{
return
TelemetrySendImpl
.
clearCurrentPings
(
)
;
}
testWaitOnOutgoingPings
(
)
{
return
TelemetrySendImpl
.
promisePendingPingActivity
(
)
;
}
setTestModeEnabled
(
testing
)
{
TelemetrySendImpl
.
setTestModeEnabled
(
testing
)
;
}
getShutdownState
(
)
{
return
TelemetrySendImpl
.
getShutdownState
(
)
;
}
testRunPingSender
(
url
pingPath
)
{
TelemetrySendImpl
.
runPingSender
(
url
pingPath
)
;
}
}
;
var
CancellableTimeout
=
{
_deferred
:
null
_timer
:
null
promiseWaitOnTimeout
(
timeoutMs
)
{
if
(
!
this
.
_deferred
)
{
this
.
_deferred
=
PromiseUtils
.
defer
(
)
;
this
.
_timer
=
Policy
.
setSchedulerTickTimeout
(
(
)
=
>
this
.
_onTimeout
(
)
timeoutMs
)
;
}
return
this
.
_deferred
.
promise
;
}
_onTimeout
(
)
{
if
(
this
.
_deferred
)
{
this
.
_deferred
.
resolve
(
false
)
;
this
.
_timer
=
null
;
this
.
_deferred
=
null
;
}
}
cancelTimeout
(
)
{
if
(
this
.
_deferred
)
{
Policy
.
clearSchedulerTickTimeout
(
this
.
_timer
)
;
this
.
_deferred
.
resolve
(
true
)
;
this
.
_timer
=
null
;
this
.
_deferred
=
null
;
}
}
}
;
var
SendScheduler
=
{
_sendsFailed
:
false
_backoffDelay
:
SEND_TICK_DELAY
_shutdown
:
false
_sendTask
:
null
_sendTaskState
:
null
_logger
:
null
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
+
"
Scheduler
:
:
"
)
;
}
return
this
.
_logger
;
}
shutdown
(
)
{
this
.
_log
.
trace
(
"
shutdown
"
)
;
this
.
_shutdown
=
true
;
CancellableTimeout
.
cancelTimeout
(
)
;
return
Promise
.
resolve
(
this
.
_sendTask
)
;
}
start
(
)
{
this
.
_log
.
trace
(
"
start
"
)
;
this
.
_sendsFailed
=
false
;
this
.
_backoffDelay
=
SEND_TICK_DELAY
;
this
.
_shutdown
=
false
;
}
reset
(
)
{
this
.
_log
.
trace
(
"
reset
"
)
;
return
this
.
shutdown
(
)
.
then
(
(
)
=
>
this
.
start
(
)
)
;
}
notifySendsFailed
(
)
{
this
.
_log
.
trace
(
"
notifySendsFailed
"
)
;
if
(
this
.
_sendsFailed
)
{
return
;
}
this
.
_sendsFailed
=
true
;
this
.
_log
.
trace
(
"
notifySendsFailed
-
had
send
failures
"
)
;
}
isThrottled
(
)
{
const
now
=
Policy
.
now
(
)
;
const
nextPingSendTime
=
this
.
_getNextPingSendTime
(
now
)
;
return
(
nextPingSendTime
>
now
.
getTime
(
)
)
;
}
waitOnSendTask
(
)
{
return
Promise
.
resolve
(
this
.
_sendTask
)
;
}
triggerSendingPings
(
immediately
)
{
this
.
_log
.
trace
(
"
triggerSendingPings
-
active
send
task
:
"
+
!
!
this
.
_sendTask
+
"
immediately
:
"
+
immediately
)
;
if
(
!
this
.
_sendTask
)
{
this
.
_sendTask
=
this
.
_doSendTask
(
)
;
let
clear
=
(
)
=
>
this
.
_sendTask
=
null
;
this
.
_sendTask
.
then
(
clear
clear
)
;
}
else
if
(
immediately
)
{
CancellableTimeout
.
cancelTimeout
(
)
;
}
return
this
.
_sendTask
;
}
async
_doSendTask
(
)
{
this
.
_sendTaskState
=
"
send
task
started
"
;
this
.
_backoffDelay
=
SEND_TICK_DELAY
;
this
.
_sendsFailed
=
false
;
const
resetBackoffTimer
=
(
)
=
>
{
this
.
_backoffDelay
=
SEND_TICK_DELAY
;
}
;
for
(
;
;
)
{
this
.
_log
.
trace
(
"
_doSendTask
iteration
"
)
;
this
.
_sendTaskState
=
"
start
iteration
"
;
if
(
this
.
_shutdown
)
{
this
.
_log
.
trace
(
"
_doSendTask
-
shutting
down
bailing
out
"
)
;
this
.
_sendTaskState
=
"
bail
out
-
shutdown
check
"
;
return
;
}
let
pending
=
TelemetryStorage
.
getPendingPingList
(
)
;
let
current
=
TelemetrySendImpl
.
getUnpersistedPings
(
)
;
this
.
_log
.
trace
(
"
_doSendTask
-
pending
:
"
+
pending
.
length
+
"
current
:
"
+
current
.
length
)
;
if
(
!
TelemetrySendImpl
.
sendingEnabled
(
)
)
{
pending
=
pending
.
filter
(
pingInfo
=
>
TelemetryStorage
.
isDeletionPing
(
pingInfo
.
id
)
)
;
current
=
current
.
filter
(
p
=
>
isDeletionPing
(
p
)
)
;
}
this
.
_log
.
trace
(
"
_doSendTask
-
can
send
-
pending
:
"
+
pending
.
length
+
"
current
:
"
+
current
.
length
)
;
if
(
(
pending
.
length
=
=
0
)
&
&
(
current
.
length
=
=
0
)
)
{
this
.
_log
.
trace
(
"
_doSendTask
-
no
pending
pings
bailing
out
"
)
;
this
.
_sendTaskState
=
"
bail
out
-
no
pings
to
send
"
;
return
;
}
const
now
=
Policy
.
now
(
)
;
if
(
this
.
isThrottled
(
)
)
{
const
nextPingSendTime
=
this
.
_getNextPingSendTime
(
now
)
;
this
.
_log
.
trace
(
"
_doSendTask
-
throttled
delaying
ping
send
to
"
+
new
Date
(
nextPingSendTime
)
)
;
this
.
_sendTaskState
=
"
wait
for
throttling
to
pass
"
;
const
delay
=
nextPingSendTime
-
now
.
getTime
(
)
;
const
cancelled
=
await
CancellableTimeout
.
promiseWaitOnTimeout
(
delay
)
;
if
(
cancelled
)
{
this
.
_log
.
trace
(
"
_doSendTask
-
throttling
wait
was
cancelled
resetting
backoff
timer
"
)
;
resetBackoffTimer
(
)
;
}
continue
;
}
let
sending
=
pending
.
slice
(
0
MAX_PING_SENDS_PER_MINUTE
)
;
pending
=
pending
.
slice
(
MAX_PING_SENDS_PER_MINUTE
)
;
this
.
_log
.
trace
(
"
_doSendTask
-
triggering
sending
of
"
+
sending
.
length
+
"
pings
now
"
+
"
"
+
pending
.
length
+
"
pings
waiting
"
)
;
this
.
_sendsFailed
=
false
;
const
sendStartTime
=
Policy
.
now
(
)
;
this
.
_sendTaskState
=
"
wait
on
ping
sends
"
;
await
TelemetrySendImpl
.
sendPings
(
current
sending
.
map
(
p
=
>
p
.
id
)
)
;
if
(
this
.
_shutdown
|
|
(
TelemetrySend
.
pendingPingCount
=
=
0
)
)
{
this
.
_log
.
trace
(
"
_doSendTask
-
bailing
out
after
sending
shutdown
:
"
+
this
.
_shutdown
+
"
pendingPingCount
:
"
+
TelemetrySend
.
pendingPingCount
)
;
this
.
_sendTaskState
=
"
bail
out
-
shutdown
&
pending
check
after
send
"
;
return
;
}
const
timeSinceLastSend
=
Policy
.
now
(
)
-
sendStartTime
;
let
nextSendDelay
=
Math
.
max
(
0
SEND_TICK_DELAY
-
timeSinceLastSend
)
;
if
(
!
this
.
_sendsFailed
)
{
this
.
_log
.
trace
(
"
_doSendTask
-
had
no
send
failures
resetting
backoff
timer
"
)
;
resetBackoffTimer
(
)
;
}
else
{
const
newDelay
=
Math
.
min
(
SEND_MAXIMUM_BACKOFF_DELAY_MS
this
.
_backoffDelay
*
2
)
;
this
.
_log
.
trace
(
"
_doSendTask
-
had
send
failures
backing
off
-
"
+
"
old
timeout
:
"
+
this
.
_backoffDelay
+
"
new
timeout
:
"
+
newDelay
)
;
this
.
_backoffDelay
=
newDelay
;
nextSendDelay
=
this
.
_backoffDelay
;
}
this
.
_log
.
trace
(
"
_doSendTask
-
waiting
for
next
send
opportunity
timeout
is
"
+
nextSendDelay
)
this
.
_sendTaskState
=
"
wait
on
next
send
opportunity
"
;
const
cancelled
=
await
CancellableTimeout
.
promiseWaitOnTimeout
(
nextSendDelay
)
;
if
(
cancelled
)
{
this
.
_log
.
trace
(
"
_doSendTask
-
batch
send
wait
was
cancelled
resetting
backoff
timer
"
)
;
resetBackoffTimer
(
)
;
}
}
}
_getNextPingSendTime
(
now
)
{
const
midnight
=
Utils
.
truncateToDays
(
now
)
;
if
(
(
now
.
getTime
(
)
-
midnight
.
getTime
(
)
)
>
MIDNIGHT_FUZZING_INTERVAL_MS
)
{
return
now
.
getTime
(
)
;
}
return
midnight
.
getTime
(
)
+
Policy
.
midnightPingFuzzingDelay
(
)
;
}
getShutdownState
(
)
{
return
{
shutdown
:
this
.
_shutdown
hasSendTask
:
!
!
this
.
_sendTask
sendsFailed
:
this
.
_sendsFailed
sendTaskState
:
this
.
_sendTaskState
backoffDelay
:
this
.
_backoffDelay
}
;
}
}
;
var
TelemetrySendImpl
=
{
_sendingEnabled
:
false
_shutdown
:
false
_logger
:
null
_pendingPingRequests
:
new
Map
(
)
_pendingPingActivity
:
new
Set
(
)
_testMode
:
false
_currentPings
:
new
Map
(
)
_isOSShutdown
:
false
_overduePingCount
:
0
OBSERVER_TOPICS
:
[
TOPIC_IDLE_DAILY
TOPIC_QUIT_APPLICATION_GRANTED
TOPIC_QUIT_APPLICATION_FORCED
]
OBSERVED_PREFERENCES
:
[
TelemetryUtils
.
Preferences
.
TelemetryEnabled
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
]
get
_overrideOfficialCheck
(
)
{
return
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
OverrideOfficialCheck
false
)
;
}
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
)
;
}
return
this
.
_logger
;
}
get
overduePingsCount
(
)
{
return
this
.
_overduePingCount
;
}
get
pendingPingRequests
(
)
{
return
this
.
_pendingPingRequests
;
}
get
pendingPingCount
(
)
{
return
TelemetryStorage
.
getPendingPingList
(
)
.
length
+
this
.
_currentPings
.
size
;
}
setTestModeEnabled
(
testing
)
{
this
.
_testMode
=
testing
;
}
earlyInit
(
)
{
this
.
_annotateCrashReport
(
)
;
Services
.
obs
.
addObserver
(
this
TOPIC_QUIT_APPLICATION_FORCED
)
;
Services
.
obs
.
addObserver
(
this
TOPIC_QUIT_APPLICATION_GRANTED
)
;
}
async
setup
(
testing
)
{
this
.
_log
.
trace
(
"
setup
"
)
;
this
.
_testMode
=
testing
;
this
.
_sendingEnabled
=
true
;
Services
.
obs
.
addObserver
(
this
TOPIC_IDLE_DAILY
)
;
this
.
_server
=
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
Server
undefined
)
;
for
(
let
pref
of
this
.
OBSERVED_PREFERENCES
)
{
Preferences
.
observe
(
pref
this
.
_annotateCrashReport
this
)
;
}
this
.
_annotateCrashReport
(
)
;
try
{
await
this
.
_checkPendingPings
(
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
setup
-
_checkPendingPings
rejected
"
ex
)
;
}
TelemetryStorage
.
runEnforcePendingPingsQuotaTask
(
)
;
SendScheduler
.
triggerSendingPings
(
true
)
;
}
_annotateCrashReport
(
)
{
try
{
const
cr
=
Cc
[
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
]
;
if
(
cr
)
{
const
crs
=
cr
.
getService
(
Ci
.
nsICrashReporter
)
;
let
clientId
=
ClientID
.
getCachedClientID
(
)
;
let
server
=
this
.
_server
|
|
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
Server
undefined
)
;
if
(
!
this
.
sendingEnabled
(
)
|
|
!
TelemetryReportingPolicy
.
canUpload
(
)
)
{
crs
.
annotateCrashReport
(
"
TelemetryClientId
"
"
"
)
;
crs
.
annotateCrashReport
(
"
TelemetryServerURL
"
"
"
)
;
}
else
{
crs
.
annotateCrashReport
(
"
TelemetryClientId
"
clientId
)
;
crs
.
annotateCrashReport
(
"
TelemetryServerURL
"
server
)
;
}
}
}
catch
(
e
)
{
}
}
async
_checkPendingPings
(
)
{
let
infos
=
await
TelemetryStorage
.
loadPendingPingList
(
)
;
this
.
_log
.
info
(
"
_checkPendingPings
-
pending
ping
count
:
"
+
infos
.
length
)
;
if
(
infos
.
length
=
=
0
)
{
this
.
_log
.
trace
(
"
_checkPendingPings
-
no
pending
pings
"
)
;
return
;
}
const
now
=
Policy
.
now
(
)
;
const
overduePings
=
infos
.
filter
(
(
info
)
=
>
(
now
.
getTime
(
)
-
info
.
lastModificationDate
)
>
OVERDUE_PING_FILE_AGE
)
;
this
.
_overduePingCount
=
overduePings
.
length
;
for
(
let
pingInfo
of
infos
)
{
const
ageInDays
=
Utils
.
millisecondsToDays
(
Math
.
abs
(
now
.
getTime
(
)
-
pingInfo
.
lastModificationDate
)
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_PENDING_PINGS_AGE
"
)
.
add
(
ageInDays
)
;
}
}
async
shutdown
(
)
{
this
.
_shutdown
=
true
;
for
(
let
pref
of
this
.
OBSERVED_PREFERENCES
)
{
Preferences
.
ignore
(
pref
this
.
_annotateCrashReport
this
)
;
}
for
(
let
topic
of
this
.
OBSERVER_TOPICS
)
{
try
{
Services
.
obs
.
removeObserver
(
this
topic
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
shutdown
-
failed
to
remove
observer
for
"
+
topic
ex
)
;
}
}
this
.
_sendingEnabled
=
false
;
await
this
.
_cancelOutgoingRequests
(
)
;
await
SendScheduler
.
shutdown
(
)
;
await
this
.
promisePendingPingActivity
(
)
;
await
this
.
_persistCurrentPings
(
)
;
}
reset
(
)
{
this
.
_log
.
trace
(
"
reset
"
)
;
this
.
_shutdown
=
false
;
this
.
_currentPings
=
new
Map
(
)
;
this
.
_overduePingCount
=
0
;
this
.
_isOSShutdown
=
false
;
const
histograms
=
[
"
TELEMETRY_SUCCESS
"
"
TELEMETRY_SEND_SUCCESS
"
"
TELEMETRY_SEND_FAILURE
"
]
;
histograms
.
forEach
(
h
=
>
Telemetry
.
getHistogramById
(
h
)
.
clear
(
)
)
;
return
SendScheduler
.
reset
(
)
;
}
notifyCanUpload
(
)
{
SendScheduler
.
triggerSendingPings
(
true
)
;
this
.
_annotateCrashReport
(
)
;
return
this
.
promisePendingPingActivity
(
)
;
}
observe
(
subject
topic
data
)
{
let
setOSShutdown
=
(
)
=
>
{
this
.
_log
.
trace
(
"
setOSShutdown
-
in
OS
shutdown
"
)
;
this
.
_isOSShutdown
=
true
;
Telemetry
.
scalarSet
(
"
telemetry
.
os_shutting_down
"
true
)
;
}
;
switch
(
topic
)
{
case
TOPIC_IDLE_DAILY
:
SendScheduler
.
triggerSendingPings
(
true
)
;
break
;
case
TOPIC_QUIT_APPLICATION_FORCED
:
setOSShutdown
(
)
;
break
;
case
TOPIC_QUIT_APPLICATION_GRANTED
:
if
(
data
=
=
"
syncShutdown
"
)
{
setOSShutdown
(
)
;
}
break
;
}
}
_sendWithPingSender
(
pingId
submissionURL
)
{
this
.
_log
.
trace
(
"
_sendWithPingSender
-
sending
"
+
pingId
+
"
to
"
+
submissionURL
)
;
try
{
const
pingPath
=
OS
.
Path
.
join
(
TelemetryStorage
.
pingDirectoryPath
pingId
)
;
this
.
runPingSender
(
submissionURL
pingPath
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
_sendWithPingSender
-
failed
to
submit
ping
"
e
)
;
}
}
submitPing
(
ping
options
)
{
this
.
_log
.
trace
(
"
submitPing
-
ping
id
:
"
+
ping
.
id
+
"
options
:
"
+
JSON
.
stringify
(
options
)
)
;
if
(
!
this
.
sendingEnabled
(
ping
)
)
{
this
.
_log
.
trace
(
"
submitPing
-
Telemetry
is
not
allowed
to
send
pings
.
"
)
;
return
Promise
.
resolve
(
)
;
}
if
(
options
.
usePingSender
&
&
!
this
.
_isOSShutdown
&
&
TelemetryReportingPolicy
.
canUpload
(
)
&
&
AppConstants
.
platform
!
=
"
android
"
)
{
const
url
=
this
.
_buildSubmissionURL
(
ping
)
;
return
savePing
(
ping
)
.
then
(
(
)
=
>
this
.
_sendWithPingSender
(
ping
.
id
url
)
)
;
}
if
(
!
this
.
canSendNow
)
{
this
.
_log
.
trace
(
"
submitPing
-
can
'
t
send
ping
now
persisting
to
disk
-
"
+
"
canSendNow
:
"
+
this
.
canSendNow
)
;
return
savePing
(
ping
)
;
}
this
.
_log
.
trace
(
"
submitPing
-
can
send
pings
trying
to
send
now
"
)
;
this
.
_currentPings
.
set
(
ping
.
id
ping
)
;
SendScheduler
.
triggerSendingPings
(
true
)
;
return
Promise
.
resolve
(
)
;
}
setServer
(
server
)
{
this
.
_log
.
trace
(
"
setServer
"
server
)
;
this
.
_server
=
server
;
}
async
clearCurrentPings
(
)
{
if
(
this
.
_shutdown
)
{
this
.
_log
.
trace
(
"
clearCurrentPings
-
in
shutdown
bailing
out
"
)
;
return
;
}
await
SendScheduler
.
shutdown
(
)
;
this
.
_cancelOutgoingRequests
(
)
;
this
.
_currentPings
.
clear
(
)
;
if
(
this
.
_shutdown
)
{
this
.
_log
.
trace
(
"
clearCurrentPings
-
in
shutdown
not
spinning
SendScheduler
up
again
"
)
;
return
;
}
SendScheduler
.
start
(
)
;
SendScheduler
.
triggerSendingPings
(
true
)
;
}
_cancelOutgoingRequests
(
)
{
for
(
let
[
id
request
]
of
this
.
_pendingPingRequests
)
{
this
.
_log
.
trace
(
"
_cancelOutgoingRequests
-
aborting
ping
request
for
id
"
+
id
)
;
try
{
request
.
abort
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
_cancelOutgoingRequests
-
failed
to
abort
request
for
id
"
+
id
e
)
;
}
}
this
.
_pendingPingRequests
.
clear
(
)
;
}
sendPings
(
currentPings
persistedPingIds
)
{
let
pingSends
=
[
]
;
for
(
let
current
of
currentPings
)
{
let
ping
=
current
;
let
p
=
(
async
(
)
=
>
{
try
{
await
this
.
_doPing
(
ping
ping
.
id
false
)
;
}
catch
(
ex
)
{
this
.
_log
.
info
(
"
sendPings
-
ping
"
+
ping
.
id
+
"
not
sent
saving
to
disk
"
ex
)
;
await
savePing
(
ping
)
;
}
finally
{
this
.
_currentPings
.
delete
(
ping
.
id
)
;
}
}
)
(
)
;
this
.
_trackPendingPingTask
(
p
)
;
pingSends
.
push
(
p
)
;
}
if
(
persistedPingIds
.
length
>
0
)
{
pingSends
.
push
(
this
.
_sendPersistedPings
(
persistedPingIds
)
.
catch
(
(
ex
)
=
>
{
this
.
_log
.
info
(
"
sendPings
-
persisted
pings
not
sent
"
ex
)
;
}
)
)
;
}
return
Promise
.
all
(
pingSends
)
;
}
async
_sendPersistedPings
(
pingIds
)
{
this
.
_log
.
trace
(
"
sendPersistedPings
"
)
;
if
(
TelemetryStorage
.
pendingPingCount
<
1
)
{
this
.
_log
.
trace
(
"
_sendPersistedPings
-
no
pings
to
send
"
)
;
return
;
}
if
(
pingIds
.
length
<
1
)
{
this
.
_log
.
trace
(
"
sendPersistedPings
-
no
pings
to
send
"
)
;
return
;
}
this
.
_log
.
trace
(
"
sendPersistedPings
-
sending
"
+
pingIds
.
length
+
"
pings
"
)
;
let
pingSendPromises
=
[
]
;
for
(
let
pingId
of
pingIds
)
{
const
id
=
pingId
;
pingSendPromises
.
push
(
TelemetryStorage
.
loadPendingPing
(
id
)
.
then
(
(
data
)
=
>
this
.
_doPing
(
data
id
true
)
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
sendPersistedPings
-
failed
to
send
ping
"
+
id
e
)
)
)
;
}
let
promise
=
Promise
.
all
(
pingSendPromises
)
;
this
.
_trackPendingPingTask
(
promise
)
;
await
promise
;
}
_onPingRequestFinished
(
success
startTime
id
isPersisted
)
{
this
.
_log
.
trace
(
"
_onPingRequestFinished
-
success
:
"
+
success
+
"
persisted
:
"
+
isPersisted
)
;
let
sendId
=
success
?
"
TELEMETRY_SEND_SUCCESS
"
:
"
TELEMETRY_SEND_FAILURE
"
;
let
hsend
=
Telemetry
.
getHistogramById
(
sendId
)
;
let
hsuccess
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_SUCCESS
"
)
;
hsend
.
add
(
monotonicNow
(
)
-
startTime
)
;
hsuccess
.
add
(
success
)
;
if
(
!
success
)
{
SendScheduler
.
notifySendsFailed
(
)
;
}
if
(
success
&
&
isPersisted
)
{
if
(
TelemetryStorage
.
isDeletionPing
(
id
)
)
{
return
TelemetryStorage
.
removeDeletionPing
(
)
;
}
return
TelemetryStorage
.
removePendingPing
(
id
)
;
}
return
Promise
.
resolve
(
)
;
}
_buildSubmissionURL
(
ping
)
{
const
version
=
isV4PingFormat
(
ping
)
?
PING_FORMAT_VERSION
:
1
;
return
this
.
_server
+
this
.
_getSubmissionPath
(
ping
)
+
"
?
v
=
"
+
version
;
}
_getSubmissionPath
(
ping
)
{
let
pathComponents
;
if
(
isV4PingFormat
(
ping
)
)
{
let
app
=
ping
.
application
;
pathComponents
=
[
ping
.
id
ping
.
type
app
.
name
app
.
version
app
.
channel
app
.
buildId
]
;
}
else
{
if
(
!
(
"
slug
"
in
ping
)
)
{
ping
.
slug
=
Utils
.
generateUUID
(
)
;
}
let
payload
=
(
"
payload
"
in
ping
)
?
ping
.
payload
:
null
;
if
(
payload
&
&
(
"
info
"
in
payload
)
)
{
let
info
=
ping
.
payload
.
info
;
pathComponents
=
[
ping
.
slug
info
.
reason
info
.
appName
info
.
appVersion
info
.
appUpdateChannel
info
.
appBuildID
]
;
}
else
{
pathComponents
=
[
ping
.
slug
]
;
}
}
let
slug
=
pathComponents
.
join
(
"
/
"
)
;
return
"
/
submit
/
telemetry
/
"
+
slug
;
}
_doPing
(
ping
id
isPersisted
)
{
if
(
!
this
.
sendingEnabled
(
ping
)
)
{
this
.
_log
.
trace
(
"
_doPing
-
Can
'
t
send
ping
"
+
ping
.
id
)
;
return
Promise
.
resolve
(
)
;
}
this
.
_log
.
trace
(
"
_doPing
-
server
:
"
+
this
.
_server
+
"
persisted
:
"
+
isPersisted
+
"
id
:
"
+
id
)
;
const
url
=
this
.
_buildSubmissionURL
(
ping
)
;
let
request
=
new
ServiceRequest
(
)
;
request
.
mozBackgroundRequest
=
true
;
request
.
timeout
=
PING_SUBMIT_TIMEOUT_MS
;
request
.
open
(
"
POST
"
url
true
)
;
request
.
overrideMimeType
(
"
text
/
plain
"
)
;
request
.
setRequestHeader
(
"
Content
-
Type
"
"
application
/
json
;
charset
=
UTF
-
8
"
)
;
request
.
setRequestHeader
(
"
Date
"
Policy
.
now
(
)
.
toUTCString
(
)
)
;
this
.
_pendingPingRequests
.
set
(
id
request
)
;
request
.
channel
.
loadFlags
&
=
~
Ci
.
nsIChannel
.
LOAD_CLASSIFY_URI
;
const
monotonicStartTime
=
monotonicNow
(
)
;
let
deferred
=
PromiseUtils
.
defer
(
)
;
let
onRequestFinished
=
(
success
event
)
=
>
{
let
onCompletion
=
(
)
=
>
{
if
(
success
)
{
let
histogram
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_SUCCESSFUL_SEND_PINGS_SIZE_KB
"
)
;
histogram
.
add
(
compressedPingSizeKB
)
;
deferred
.
resolve
(
)
;
}
else
{
let
histogram
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_FAILED_SEND_PINGS_SIZE_KB
"
)
;
histogram
.
add
(
compressedPingSizeKB
)
;
deferred
.
reject
(
event
)
;
}
}
;
this
.
_pendingPingRequests
.
delete
(
id
)
;
this
.
_onPingRequestFinished
(
success
monotonicStartTime
id
isPersisted
)
.
then
(
(
)
=
>
onCompletion
(
)
(
error
)
=
>
{
this
.
_log
.
error
(
"
_doPing
-
request
success
:
"
+
success
+
"
error
:
"
+
error
)
;
onCompletion
(
)
;
}
)
;
}
;
let
errorhandler
=
(
event
)
=
>
{
let
failure
=
event
.
type
;
if
(
failure
=
=
=
"
error
"
)
{
failure
=
XHR_ERROR_TYPE
[
request
.
errorCode
]
;
}
Telemetry
.
getHistogramById
(
"
TELEMETRY_SEND_FAILURE_TYPE
"
)
.
add
(
failure
)
;
this
.
_log
.
error
(
"
_doPing
-
error
making
request
to
"
+
url
+
"
:
"
+
failure
)
;
onRequestFinished
(
false
event
)
;
}
;
request
.
onerror
=
errorhandler
;
request
.
ontimeout
=
errorhandler
;
request
.
onabort
=
errorhandler
;
request
.
onload
=
(
event
)
=
>
{
let
status
=
request
.
status
;
let
statusClass
=
status
-
(
status
%
100
)
;
let
success
=
false
;
if
(
statusClass
=
=
=
200
)
{
this
.
_log
.
info
(
"
_doPing
-
successfully
loaded
status
:
"
+
status
)
;
success
=
true
;
}
else
if
(
statusClass
=
=
=
400
)
{
this
.
_log
.
error
(
"
_doPing
-
error
submitting
to
"
+
url
+
"
status
:
"
+
status
+
"
-
ping
request
broken
?
"
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_PING_EVICTED_FOR_SERVER_ERRORS
"
)
.
add
(
)
;
success
=
true
;
}
else
if
(
statusClass
=
=
=
500
)
{
this
.
_log
.
error
(
"
_doPing
-
error
submitting
to
"
+
url
+
"
status
:
"
+
status
+
"
-
server
error
should
retry
later
"
)
;
}
else
{
this
.
_log
.
error
(
"
_doPing
-
error
submitting
to
"
+
url
+
"
status
:
"
+
status
+
"
type
:
"
+
event
.
type
)
;
}
onRequestFinished
(
success
event
)
;
}
;
let
networkPayload
=
isV4PingFormat
(
ping
)
?
ping
:
ping
.
payload
;
request
.
setRequestHeader
(
"
Content
-
Encoding
"
"
gzip
"
)
;
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
let
startTime
=
monotonicNow
(
)
;
let
utf8Payload
=
converter
.
ConvertFromUnicode
(
JSON
.
stringify
(
networkPayload
)
)
;
utf8Payload
+
=
converter
.
Finish
(
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_STRINGIFY
"
)
.
add
(
monotonicNow
(
)
-
startTime
)
;
const
pingSizeBytes
=
utf8Payload
.
length
;
if
(
pingSizeBytes
>
TelemetryStorage
.
MAXIMUM_PING_SIZE
)
{
this
.
_log
.
error
(
"
_doPing
-
submitted
ping
exceeds
the
size
limit
size
:
"
+
pingSizeBytes
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_PING_SIZE_EXCEEDED_SEND
"
)
.
add
(
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_DISCARDED_SEND_PINGS_SIZE_MB
"
)
.
add
(
Math
.
floor
(
pingSizeBytes
/
1024
/
1024
)
)
;
this
.
_pendingPingRequests
.
delete
(
id
)
;
return
TelemetryStorage
.
removePendingPing
(
id
)
;
}
let
payloadStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
startTime
=
monotonicNow
(
)
;
payloadStream
.
data
=
gzipCompressString
(
utf8Payload
)
;
const
compressedPingSizeKB
=
Math
.
floor
(
payloadStream
.
data
.
length
/
1024
)
;
Telemetry
.
getHistogramById
(
"
TELEMETRY_COMPRESS
"
)
.
add
(
monotonicNow
(
)
-
startTime
)
;
request
.
send
(
payloadStream
)
;
return
deferred
.
promise
;
}
get
canSendNow
(
)
{
if
(
!
TelemetryReportingPolicy
.
canUpload
(
)
)
{
return
false
;
}
return
this
.
_sendingEnabled
;
}
sendingEnabled
(
ping
=
null
)
{
if
(
!
Telemetry
.
isOfficialTelemetry
&
&
!
this
.
_testMode
&
&
!
this
.
_overrideOfficialCheck
)
{
return
false
;
}
if
(
IS_UNIFIED_TELEMETRY
)
{
if
(
ping
&
&
isDeletionPing
(
ping
)
)
{
return
true
;
}
return
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
}
return
Utils
.
isTelemetryEnabled
;
}
_trackPendingPingTask
(
promise
)
{
let
clear
=
(
)
=
>
this
.
_pendingPingActivity
.
delete
(
promise
)
;
promise
.
then
(
clear
clear
)
;
this
.
_pendingPingActivity
.
add
(
promise
)
;
}
promisePendingPingActivity
(
)
{
this
.
_log
.
trace
(
"
promisePendingPingActivity
-
Waiting
for
ping
task
"
)
;
let
p
=
Array
.
from
(
this
.
_pendingPingActivity
p
=
>
p
.
catch
(
ex
=
>
{
this
.
_log
.
error
(
"
promisePendingPingActivity
-
ping
activity
had
an
error
"
ex
)
;
}
)
)
;
p
.
push
(
SendScheduler
.
waitOnSendTask
(
)
)
;
return
Promise
.
all
(
p
)
;
}
async
_persistCurrentPings
(
)
{
for
(
let
[
id
ping
]
of
this
.
_currentPings
)
{
try
{
await
savePing
(
ping
)
;
this
.
_log
.
trace
(
"
_persistCurrentPings
-
saved
ping
"
+
id
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
_persistCurrentPings
-
failed
to
save
ping
"
+
id
ex
)
;
}
finally
{
this
.
_currentPings
.
delete
(
id
)
;
}
}
}
getUnpersistedPings
(
)
{
let
current
=
[
.
.
.
this
.
_currentPings
.
values
(
)
]
;
current
.
reverse
(
)
;
return
current
;
}
getShutdownState
(
)
{
return
{
sendingEnabled
:
this
.
_sendingEnabled
pendingPingRequestCount
:
this
.
_pendingPingRequests
.
size
pendingPingActivityCount
:
this
.
_pendingPingActivity
.
size
unpersistedPingCount
:
this
.
_currentPings
.
size
persistedPingCount
:
TelemetryStorage
.
getPendingPingList
(
)
.
length
schedulerState
:
SendScheduler
.
getShutdownState
(
)
}
;
}
runPingSender
(
url
pingPath
)
{
if
(
AppConstants
.
platform
=
=
=
"
android
"
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
const
exeName
=
AppConstants
.
platform
=
=
=
"
win
"
?
"
pingsender
.
exe
"
:
"
pingsender
"
;
let
exe
=
Services
.
dirsvc
.
get
(
"
GreBinD
"
Ci
.
nsIFile
)
;
exe
.
append
(
exeName
)
;
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
process
.
init
(
exe
)
;
process
.
startHidden
=
true
;
process
.
run
(
false
[
url
pingPath
]
2
)
;
}
}
;
