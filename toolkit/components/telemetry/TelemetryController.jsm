"
use
strict
"
;
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
Cr
=
Components
.
results
;
const
Cu
=
Components
.
utils
;
const
myScope
=
this
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
debug
.
js
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
Utils
=
TelemetryUtils
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
LOGGER_PREFIX
=
"
TelemetryController
:
:
"
;
const
PREF_BRANCH
=
"
toolkit
.
telemetry
.
"
;
const
PREF_BRANCH_LOG
=
PREF_BRANCH
+
"
log
.
"
;
const
PREF_SERVER
=
PREF_BRANCH
+
"
server
"
;
const
PREF_LOG_LEVEL
=
PREF_BRANCH_LOG
+
"
level
"
;
const
PREF_LOG_DUMP
=
PREF_BRANCH_LOG
+
"
dump
"
;
const
PREF_CACHED_CLIENTID
=
PREF_BRANCH
+
"
cachedClientID
"
;
const
PREF_FHR_UPLOAD_ENABLED
=
"
datareporting
.
healthreport
.
uploadEnabled
"
;
const
PREF_SESSIONS_BRANCH
=
"
datareporting
.
sessions
.
"
;
const
PREF_UNIFIED
=
PREF_BRANCH
+
"
unified
"
;
const
IS_UNIFIED_TELEMETRY
=
Preferences
.
get
(
PREF_UNIFIED
false
)
;
const
PING_FORMAT_VERSION
=
4
;
const
TELEMETRY_DELAY
=
Preferences
.
get
(
"
toolkit
.
telemetry
.
initDelay
"
60
)
*
1000
;
const
TELEMETRY_TEST_DELAY
=
1
;
const
PING_TYPE_MAIN
=
"
main
"
;
const
PING_TYPE_DELETION
=
"
deletion
"
;
const
REASON_GATHER_PAYLOAD
=
"
gather
-
payload
"
;
const
REASON_GATHER_SUBSESSION_PAYLOAD
=
"
gather
-
subsession
-
payload
"
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ClientID
"
"
resource
:
/
/
gre
/
modules
/
ClientID
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
Telemetry
"
"
mozilla
.
org
/
base
/
telemetry
;
1
"
"
nsITelemetry
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AsyncShutdown
"
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryStorage
"
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ThirdPartyCookieProbe
"
"
resource
:
/
/
gre
/
modules
/
ThirdPartyCookieProbe
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryEnvironment
"
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
SessionRecorder
"
"
resource
:
/
/
gre
/
modules
/
SessionRecorder
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryArchive
"
"
resource
:
/
/
gre
/
modules
/
TelemetryArchive
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetrySession
"
"
resource
:
/
/
gre
/
modules
/
TelemetrySession
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetrySend
"
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryReportingPolicy
"
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
)
;
var
gLogger
=
null
;
var
gLogAppenderDump
=
null
;
function
configureLogging
(
)
{
if
(
!
gLogger
)
{
gLogger
=
Log
.
repository
.
getLogger
(
LOGGER_NAME
)
;
let
consoleAppender
=
new
Log
.
ConsoleAppender
(
new
Log
.
BasicFormatter
(
)
)
;
gLogger
.
addAppender
(
consoleAppender
)
;
Preferences
.
observe
(
PREF_BRANCH_LOG
configureLogging
)
;
}
gLogger
.
level
=
Log
.
Level
[
Preferences
.
get
(
PREF_LOG_LEVEL
"
Warn
"
)
]
;
let
logDumping
=
Preferences
.
get
(
PREF_LOG_DUMP
false
)
;
if
(
logDumping
!
=
!
!
gLogAppenderDump
)
{
if
(
logDumping
)
{
gLogAppenderDump
=
new
Log
.
DumpAppender
(
new
Log
.
BasicFormatter
(
)
)
;
gLogger
.
addAppender
(
gLogAppenderDump
)
;
}
else
{
gLogger
.
removeAppender
(
gLogAppenderDump
)
;
gLogAppenderDump
=
null
;
}
}
}
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
generatePingId
:
(
)
=
>
Utils
.
generateUUID
(
)
getCachedClientID
:
(
)
=
>
ClientID
.
getCachedClientID
(
)
}
this
.
EXPORTED_SYMBOLS
=
[
"
TelemetryController
"
]
;
this
.
TelemetryController
=
Object
.
freeze
(
{
Constants
:
Object
.
freeze
(
{
PREF_LOG_LEVEL
PREF_LOG_DUMP
PREF_SERVER
}
)
testInitLogging
(
)
{
configureLogging
(
)
;
}
testReset
(
)
{
return
Impl
.
reset
(
)
;
}
testSetup
(
)
{
return
Impl
.
setupTelemetry
(
true
)
;
}
testShutdown
(
)
{
return
Impl
.
shutdown
(
)
;
}
testSetupContent
(
)
{
return
Impl
.
setupContentTelemetry
(
true
)
;
}
observe
(
aSubject
aTopic
aData
)
{
return
Impl
.
observe
(
aSubject
aTopic
aData
)
;
}
submitExternalPing
(
aType
aPayload
aOptions
=
{
}
)
{
aOptions
.
addClientId
=
aOptions
.
addClientId
|
|
false
;
aOptions
.
addEnvironment
=
aOptions
.
addEnvironment
|
|
false
;
return
Impl
.
submitExternalPing
(
aType
aPayload
aOptions
)
;
}
getCurrentPingData
(
aSubsession
=
false
)
{
return
Impl
.
getCurrentPingData
(
aSubsession
)
;
}
addPendingPing
(
aType
aPayload
aOptions
=
{
}
)
{
let
options
=
aOptions
;
options
.
addClientId
=
aOptions
.
addClientId
|
|
false
;
options
.
addEnvironment
=
aOptions
.
addEnvironment
|
|
false
;
options
.
overwrite
=
aOptions
.
overwrite
|
|
false
;
return
Impl
.
addPendingPing
(
aType
aPayload
options
)
;
}
checkAbortedSessionPing
(
)
{
return
Impl
.
checkAbortedSessionPing
(
)
;
}
saveAbortedSessionPing
(
aPayload
)
{
return
Impl
.
saveAbortedSessionPing
(
aPayload
)
;
}
removeAbortedSessionPing
(
)
{
return
Impl
.
removeAbortedSessionPing
(
)
;
}
savePing
(
aType
aPayload
aFilePath
aOptions
=
{
}
)
{
let
options
=
aOptions
;
options
.
addClientId
=
aOptions
.
addClientId
|
|
false
;
options
.
addEnvironment
=
aOptions
.
addEnvironment
|
|
false
;
options
.
overwrite
=
aOptions
.
overwrite
|
|
false
;
return
Impl
.
savePing
(
aType
aPayload
aFilePath
options
)
;
}
getSessionRecorder
(
)
{
return
Impl
.
_sessionRecorder
;
}
promiseInitialized
(
)
{
return
Impl
.
promiseInitialized
(
)
;
}
}
)
;
var
Impl
=
{
_initialized
:
false
_initStarted
:
false
_shuttingDown
:
false
_logger
:
null
_prevValues
:
{
}
_previousBuildID
:
undefined
_clientID
:
null
_delayedInitTask
:
null
_delayedInitTaskDeferred
:
null
_sessionRecorder
:
null
_shutdownBarrier
:
new
AsyncShutdown
.
Barrier
(
"
TelemetryController
:
Waiting
for
clients
.
"
)
_connectionsBarrier
:
new
AsyncShutdown
.
Barrier
(
"
TelemetryController
:
Waiting
for
pending
ping
activity
"
)
_testMode
:
false
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
)
;
}
return
this
.
_logger
;
}
_getApplicationSection
(
)
{
let
arch
=
null
;
try
{
arch
=
Services
.
sysinfo
.
get
(
"
arch
"
)
;
}
catch
(
e
)
{
this
.
_log
.
trace
(
"
_getApplicationSection
-
Unable
to
get
system
architecture
.
"
e
)
;
}
let
updateChannel
=
null
;
try
{
updateChannel
=
UpdateUtils
.
getUpdateChannel
(
false
)
;
}
catch
(
e
)
{
this
.
_log
.
trace
(
"
_getApplicationSection
-
Unable
to
get
update
channel
.
"
e
)
;
}
return
{
architecture
:
arch
buildId
:
Services
.
appinfo
.
appBuildID
name
:
Services
.
appinfo
.
name
version
:
Services
.
appinfo
.
version
displayVersion
:
AppConstants
.
MOZ_APP_VERSION_DISPLAY
vendor
:
Services
.
appinfo
.
vendor
platformVersion
:
Services
.
appinfo
.
platformVersion
xpcomAbi
:
Services
.
appinfo
.
XPCOMABI
channel
:
updateChannel
}
;
}
assemblePing
:
function
assemblePing
(
aType
aPayload
aOptions
=
{
}
)
{
this
.
_log
.
trace
(
"
assemblePing
-
Type
"
+
aType
+
"
aOptions
"
+
JSON
.
stringify
(
aOptions
)
)
;
let
payload
=
Cu
.
cloneInto
(
aPayload
myScope
)
;
let
pingData
=
{
type
:
aType
id
:
aOptions
.
overridePingId
|
|
Policy
.
generatePingId
(
)
creationDate
:
(
Policy
.
now
(
)
)
.
toISOString
(
)
version
:
PING_FORMAT_VERSION
application
:
this
.
_getApplicationSection
(
)
payload
}
;
if
(
aOptions
.
addClientId
)
{
pingData
.
clientId
=
this
.
_clientID
;
}
if
(
aOptions
.
addEnvironment
)
{
pingData
.
environment
=
aOptions
.
overrideEnvironment
|
|
TelemetryEnvironment
.
currentEnvironment
;
}
return
pingData
;
}
_trackPendingPingTask
(
aPromise
)
{
this
.
_connectionsBarrier
.
client
.
addBlocker
(
"
Waiting
for
ping
task
"
aPromise
)
;
}
_submitPingLogic
:
Task
.
async
(
function
*
(
aType
aPayload
aOptions
)
{
if
(
!
this
.
_clientID
&
&
aOptions
.
addClientId
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_PING_SUBMISSION_WAITING_CLIENTID
"
)
.
add
(
)
;
this
.
_clientID
=
yield
ClientID
.
getClientID
(
)
;
}
const
pingData
=
this
.
assemblePing
(
aType
aPayload
aOptions
)
;
this
.
_log
.
trace
(
"
submitExternalPing
-
ping
assembled
id
:
"
+
pingData
.
id
)
;
let
archivePromise
=
TelemetryArchive
.
promiseArchivePing
(
pingData
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
submitExternalPing
-
Failed
to
archive
ping
"
+
pingData
.
id
e
)
)
;
let
p
=
[
archivePromise
]
;
p
.
push
(
TelemetrySend
.
submitPing
(
pingData
)
)
;
return
Promise
.
all
(
p
)
.
then
(
(
)
=
>
pingData
.
id
)
;
}
)
submitExternalPing
:
function
send
(
aType
aPayload
aOptions
)
{
this
.
_log
.
trace
(
"
submitExternalPing
-
type
:
"
+
aType
+
"
aOptions
:
"
+
JSON
.
stringify
(
aOptions
)
)
;
if
(
this
.
_shuttingDown
)
{
const
errorMessage
=
"
submitExternalPing
-
Submission
is
not
allowed
after
shutdown
discarding
ping
of
type
:
"
+
aType
;
this
.
_log
.
error
(
errorMessage
)
;
return
Promise
.
reject
(
new
Error
(
errorMessage
)
)
;
}
const
typeUuid
=
/
^
[
a
-
z0
-
9
]
[
a
-
z0
-
9
-
]
+
[
a
-
z0
-
9
]
/
i
;
if
(
!
typeUuid
.
test
(
aType
)
)
{
this
.
_log
.
error
(
"
submitExternalPing
-
invalid
ping
type
:
"
+
aType
)
;
let
histogram
=
Telemetry
.
getKeyedHistogramById
(
"
TELEMETRY_INVALID_PING_TYPE_SUBMITTED
"
)
;
histogram
.
add
(
aType
1
)
;
return
Promise
.
reject
(
new
Error
(
"
Invalid
type
string
submitted
.
"
)
)
;
}
if
(
aPayload
=
=
=
null
|
|
typeof
aPayload
!
=
=
"
object
"
|
|
Array
.
isArray
(
aPayload
)
)
{
this
.
_log
.
error
(
"
submitExternalPing
-
invalid
payload
type
:
"
+
typeof
aPayload
)
;
let
histogram
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_INVALID_PAYLOAD_SUBMITTED
"
)
;
histogram
.
add
(
1
)
;
return
Promise
.
reject
(
new
Error
(
"
Invalid
payload
type
submitted
.
"
)
)
;
}
let
promise
=
this
.
_submitPingLogic
(
aType
aPayload
aOptions
)
;
this
.
_trackPendingPingTask
(
promise
)
;
return
promise
;
}
addPendingPing
:
function
addPendingPing
(
aType
aPayload
aOptions
)
{
this
.
_log
.
trace
(
"
addPendingPing
-
Type
"
+
aType
+
"
aOptions
"
+
JSON
.
stringify
(
aOptions
)
)
;
let
pingData
=
this
.
assemblePing
(
aType
aPayload
aOptions
)
;
let
savePromise
=
TelemetryStorage
.
savePendingPing
(
pingData
)
;
let
archivePromise
=
TelemetryArchive
.
promiseArchivePing
(
pingData
)
.
catch
(
e
=
>
{
this
.
_log
.
error
(
"
addPendingPing
-
Failed
to
archive
ping
"
+
pingData
.
id
e
)
;
}
)
;
let
promises
=
[
savePromise
archivePromise
]
;
return
Promise
.
all
(
promises
)
.
then
(
(
)
=
>
pingData
.
id
)
;
}
savePing
:
function
savePing
(
aType
aPayload
aFilePath
aOptions
)
{
this
.
_log
.
trace
(
"
savePing
-
Type
"
+
aType
+
"
File
Path
"
+
aFilePath
+
"
aOptions
"
+
JSON
.
stringify
(
aOptions
)
)
;
let
pingData
=
this
.
assemblePing
(
aType
aPayload
aOptions
)
;
return
TelemetryStorage
.
savePingToFile
(
pingData
aFilePath
aOptions
.
overwrite
)
.
then
(
(
)
=
>
pingData
.
id
)
;
}
checkAbortedSessionPing
:
Task
.
async
(
function
*
(
)
{
let
ping
=
yield
TelemetryStorage
.
loadAbortedSessionPing
(
)
;
this
.
_log
.
trace
(
"
checkAbortedSessionPing
-
found
aborted
-
session
ping
:
"
+
!
!
ping
)
;
if
(
!
ping
)
{
return
;
}
try
{
yield
TelemetryStorage
.
addPendingPing
(
ping
)
;
yield
TelemetryArchive
.
promiseArchivePing
(
ping
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
checkAbortedSessionPing
-
Unable
to
add
the
pending
ping
"
e
)
;
}
finally
{
yield
TelemetryStorage
.
removeAbortedSessionPing
(
)
;
}
}
)
saveAbortedSessionPing
(
aPayload
)
{
this
.
_log
.
trace
(
"
saveAbortedSessionPing
"
)
;
const
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
const
pingData
=
this
.
assemblePing
(
PING_TYPE_MAIN
aPayload
options
)
;
return
TelemetryStorage
.
saveAbortedSessionPing
(
pingData
)
;
}
removeAbortedSessionPing
(
)
{
return
TelemetryStorage
.
removeAbortedSessionPing
(
)
;
}
enableTelemetryRecording
:
function
enableTelemetryRecording
(
)
{
if
(
Utils
.
isContentProcess
&
&
!
this
.
_testMode
&
&
!
Services
.
appinfo
.
browserTabsRemoteAutostart
)
{
this
.
_log
.
config
(
"
enableTelemetryRecording
-
not
enabling
Telemetry
for
non
-
e10s
child
process
"
)
;
Telemetry
.
canRecordBase
=
false
;
Telemetry
.
canRecordExtended
=
false
;
return
false
;
}
const
enabled
=
Utils
.
isTelemetryEnabled
;
Telemetry
.
canRecordBase
=
enabled
|
|
IS_UNIFIED_TELEMETRY
;
Telemetry
.
canRecordExtended
=
enabled
;
this
.
_log
.
config
(
"
enableTelemetryRecording
-
canRecordBase
:
"
+
Telemetry
.
canRecordBase
+
"
canRecordExtended
:
"
+
Telemetry
.
canRecordExtended
)
;
return
Telemetry
.
canRecordBase
;
}
setupTelemetry
:
function
setupTelemetry
(
testing
)
{
this
.
_initStarted
=
true
;
this
.
_shuttingDown
=
false
;
this
.
_testMode
=
testing
;
this
.
_log
.
trace
(
"
setupTelemetry
"
)
;
if
(
this
.
_delayedInitTask
)
{
this
.
_log
.
error
(
"
setupTelemetry
-
init
task
already
running
"
)
;
return
this
.
_delayedInitTaskDeferred
.
promise
;
}
if
(
this
.
_initialized
&
&
!
this
.
_testMode
)
{
this
.
_log
.
error
(
"
setupTelemetry
-
already
initialized
"
)
;
return
Promise
.
resolve
(
)
;
}
TelemetryReportingPolicy
.
setup
(
)
;
if
(
!
this
.
enableTelemetryRecording
(
)
)
{
this
.
_log
.
config
(
"
setupChromeProcess
-
Telemetry
recording
is
disabled
skipping
Chrome
process
setup
.
"
)
;
return
Promise
.
resolve
(
)
;
}
if
(
!
this
.
_sessionRecorder
)
{
this
.
_sessionRecorder
=
new
SessionRecorder
(
PREF_SESSIONS_BRANCH
)
;
this
.
_sessionRecorder
.
onStartup
(
)
;
}
this
.
_attachObservers
(
)
;
TelemetrySession
.
earlyInit
(
this
.
_testMode
)
;
this
.
_clientID
=
ClientID
.
getCachedClientID
(
)
;
this
.
_delayedInitTaskDeferred
=
Promise
.
defer
(
)
;
this
.
_delayedInitTask
=
new
DeferredTask
(
function
*
(
)
{
try
{
this
.
_initialized
=
true
;
TelemetryEnvironment
.
delayedInit
(
)
;
yield
TelemetrySend
.
setup
(
this
.
_testMode
)
;
this
.
_clientID
=
yield
ClientID
.
getClientID
(
)
;
yield
TelemetrySession
.
delayedInit
(
)
;
TelemetryStorage
.
runCleanPingArchiveTask
(
)
;
TelemetryStorage
.
removeFHRDatabase
(
)
;
this
.
_delayedInitTaskDeferred
.
resolve
(
)
;
}
catch
(
e
)
{
this
.
_delayedInitTaskDeferred
.
reject
(
e
)
;
}
finally
{
this
.
_delayedInitTask
=
null
;
}
}
.
bind
(
this
)
this
.
_testMode
?
TELEMETRY_TEST_DELAY
:
TELEMETRY_DELAY
)
;
AsyncShutdown
.
sendTelemetry
.
addBlocker
(
"
TelemetryController
:
shutting
down
"
(
)
=
>
this
.
shutdown
(
)
(
)
=
>
this
.
_getState
(
)
)
;
this
.
_delayedInitTask
.
arm
(
)
;
return
this
.
_delayedInitTaskDeferred
.
promise
;
}
setupContentTelemetry
(
testing
=
false
)
{
this
.
_testMode
=
testing
;
if
(
!
this
.
enableTelemetryRecording
(
)
)
{
this
.
_log
.
trace
(
"
setupContentTelemetry
-
Content
process
recording
disabled
.
"
)
;
return
;
}
TelemetrySession
.
setupContent
(
testing
)
;
}
_cleanupOnShutdown
:
Task
.
async
(
function
*
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
Preferences
.
ignore
(
PREF_BRANCH_LOG
configureLogging
)
;
this
.
_detachObservers
(
)
;
try
{
TelemetryReportingPolicy
.
shutdown
(
)
;
TelemetryEnvironment
.
shutdown
(
)
;
yield
TelemetrySend
.
shutdown
(
)
;
yield
TelemetrySession
.
shutdown
(
)
;
yield
this
.
_shutdownBarrier
.
wait
(
)
;
yield
this
.
_connectionsBarrier
.
wait
(
)
;
yield
TelemetryStorage
.
shutdown
(
)
;
}
finally
{
this
.
_initialized
=
false
;
this
.
_initStarted
=
false
;
this
.
_shuttingDown
=
true
;
}
}
)
shutdown
(
)
{
this
.
_log
.
trace
(
"
shutdown
"
)
;
if
(
!
this
.
_initStarted
)
{
this
.
_shuttingDown
=
true
;
return
Promise
.
resolve
(
)
;
}
if
(
!
this
.
_delayedInitTask
)
{
return
this
.
_cleanupOnShutdown
(
)
;
}
return
this
.
_delayedInitTask
.
finalize
(
)
.
then
(
(
)
=
>
this
.
_cleanupOnShutdown
(
)
)
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
profile
-
after
-
change
"
|
|
aTopic
=
=
"
app
-
startup
"
)
{
configureLogging
(
)
;
}
this
.
_log
.
trace
(
"
observe
-
"
+
aTopic
+
"
notified
.
"
)
;
switch
(
aTopic
)
{
case
"
profile
-
after
-
change
"
:
return
this
.
setupTelemetry
(
)
;
case
"
app
-
startup
"
:
return
this
.
setupContentTelemetry
(
)
;
}
return
undefined
;
}
_getState
(
)
{
return
{
initialized
:
this
.
_initialized
initStarted
:
this
.
_initStarted
haveDelayedInitTask
:
!
!
this
.
_delayedInitTask
shutdownBarrier
:
this
.
_shutdownBarrier
.
state
connectionsBarrier
:
this
.
_connectionsBarrier
.
state
sendModule
:
TelemetrySend
.
getShutdownState
(
)
}
;
}
_onUploadPrefChange
(
)
{
const
uploadEnabled
=
Preferences
.
get
(
PREF_FHR_UPLOAD_ENABLED
false
)
;
if
(
uploadEnabled
)
{
return
;
}
let
p
=
Task
.
spawn
(
function
*
(
)
{
try
{
yield
TelemetrySend
.
clearCurrentPings
(
)
;
yield
TelemetryStorage
.
runRemovePendingPingsTask
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
_onUploadPrefChange
-
error
clearing
pending
pings
"
e
)
;
}
finally
{
this
.
_log
.
trace
(
"
_onUploadPrefChange
-
Sending
deletion
ping
.
"
)
;
this
.
submitExternalPing
(
PING_TYPE_DELETION
{
}
{
addClientId
:
true
}
)
;
}
}
.
bind
(
this
)
)
;
this
.
_shutdownBarrier
.
client
.
addBlocker
(
"
TelemetryController
:
removing
pending
pings
after
data
upload
was
disabled
"
p
)
;
}
_attachObservers
(
)
{
if
(
IS_UNIFIED_TELEMETRY
)
{
Preferences
.
observe
(
PREF_FHR_UPLOAD_ENABLED
this
.
_onUploadPrefChange
this
)
;
}
}
_detachObservers
(
)
{
if
(
IS_UNIFIED_TELEMETRY
)
{
Preferences
.
ignore
(
PREF_FHR_UPLOAD_ENABLED
this
.
_onUploadPrefChange
this
)
;
}
}
promiseInitialized
(
)
{
return
this
.
_delayedInitTaskDeferred
.
promise
;
}
getCurrentPingData
(
aSubsession
)
{
this
.
_log
.
trace
(
"
getCurrentPingData
-
subsession
:
"
+
aSubsession
)
if
(
!
Telemetry
.
canRecordBase
)
{
return
null
;
}
const
reason
=
aSubsession
?
REASON_GATHER_SUBSESSION_PAYLOAD
:
REASON_GATHER_PAYLOAD
;
const
type
=
PING_TYPE_MAIN
;
const
payload
=
TelemetrySession
.
getPayload
(
reason
)
;
const
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
const
ping
=
this
.
assemblePing
(
type
payload
options
)
;
return
ping
;
}
reset
:
Task
.
async
(
function
*
(
)
{
this
.
_clientID
=
null
;
this
.
_detachObservers
(
)
;
yield
TelemetrySession
.
testReset
(
)
;
this
.
_connectionsBarrier
=
new
AsyncShutdown
.
Barrier
(
"
TelemetryController
:
Waiting
for
pending
ping
activity
"
)
;
this
.
_shutdownBarrier
=
new
AsyncShutdown
.
Barrier
(
"
TelemetryController
:
Waiting
for
clients
.
"
)
;
let
controllerSetup
=
this
.
setupTelemetry
(
true
)
;
yield
TelemetrySend
.
reset
(
)
;
yield
TelemetryStorage
.
reset
(
)
;
yield
TelemetryEnvironment
.
testReset
(
)
;
yield
controllerSetup
;
}
)
}
;
