"
use
strict
"
;
const
myScope
=
this
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
Utils
=
TelemetryUtils
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
LOGGER_PREFIX
=
"
TelemetryController
:
:
"
;
const
PREF_BRANCH_LOG
=
"
toolkit
.
telemetry
.
log
.
"
;
const
IS_UNIFIED_TELEMETRY
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
const
PING_FORMAT_VERSION
=
4
;
const
TELEMETRY_DELAY
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
initDelay
"
60
)
*
1000
;
const
TELEMETRY_TEST_DELAY
=
1
;
const
NEWPROFILE_PING_DEFAULT_DELAY
=
30
*
60
*
1000
;
const
PING_TYPE_MAIN
=
"
main
"
;
const
PING_TYPE_DELETION
=
"
deletion
"
;
const
REASON_GATHER_PAYLOAD
=
"
gather
-
payload
"
;
const
REASON_GATHER_SUBSESSION_PAYLOAD
=
"
gather
-
subsession
-
payload
"
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
Telemetry
"
"
mozilla
.
org
/
base
/
telemetry
;
1
"
"
nsITelemetry
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ClientID
:
"
resource
:
/
/
gre
/
modules
/
ClientID
.
jsm
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
TelemetryStorage
:
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
TelemetryEnvironment
:
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
TelemetryArchive
:
"
resource
:
/
/
gre
/
modules
/
TelemetryArchive
.
jsm
"
TelemetrySession
:
"
resource
:
/
/
gre
/
modules
/
TelemetrySession
.
jsm
"
TelemetrySend
:
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
jsm
"
TelemetryReportingPolicy
:
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
TelemetryModules
:
"
resource
:
/
/
gre
/
modules
/
TelemetryModules
.
jsm
"
UpdatePing
:
"
resource
:
/
/
gre
/
modules
/
UpdatePing
.
jsm
"
TelemetryHealthPing
:
"
resource
:
/
/
gre
/
modules
/
TelemetryHealthPing
.
jsm
"
TelemetryEventPing
:
"
resource
:
/
/
gre
/
modules
/
TelemetryEventPing
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
}
)
;
var
gLogger
=
null
;
var
gLogAppenderDump
=
null
;
function
configureLogging
(
)
{
if
(
!
gLogger
)
{
gLogger
=
Log
.
repository
.
getLogger
(
LOGGER_NAME
)
;
let
consoleAppender
=
new
Log
.
ConsoleAppender
(
new
Log
.
BasicFormatter
(
)
)
;
gLogger
.
addAppender
(
consoleAppender
)
;
Services
.
prefs
.
addObserver
(
PREF_BRANCH_LOG
configureLogging
)
;
}
gLogger
.
level
=
Log
.
Level
[
Services
.
prefs
.
getStringPref
(
TelemetryUtils
.
Preferences
.
LogLevel
"
Warn
"
)
]
;
let
logDumping
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
LogDump
false
)
;
if
(
logDumping
!
=
!
!
gLogAppenderDump
)
{
if
(
logDumping
)
{
gLogAppenderDump
=
new
Log
.
DumpAppender
(
new
Log
.
BasicFormatter
(
)
)
;
gLogger
.
addAppender
(
gLogAppenderDump
)
;
}
else
{
gLogger
.
removeAppender
(
gLogAppenderDump
)
;
gLogAppenderDump
=
null
;
}
}
}
var
Policy
=
{
now
:
(
)
=
>
new
Date
(
)
generatePingId
:
(
)
=
>
Utils
.
generateUUID
(
)
getCachedClientID
:
(
)
=
>
ClientID
.
getCachedClientID
(
)
}
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetryController
"
]
;
var
TelemetryController
=
Object
.
freeze
(
{
testAssemblePing
(
aType
aPayload
aOptions
)
{
return
Impl
.
assemblePing
(
aType
aPayload
aOptions
)
;
}
testInitLogging
(
)
{
configureLogging
(
)
;
}
testReset
(
)
{
return
Impl
.
reset
(
)
;
}
testSetup
(
)
{
return
Impl
.
setupTelemetry
(
true
)
;
}
testShutdown
(
)
{
return
Impl
.
shutdown
(
)
;
}
testSetupContent
(
)
{
return
Impl
.
setupContentTelemetry
(
true
)
;
}
testPromiseJsProbeRegistration
(
)
{
return
Promise
.
resolve
(
Impl
.
_probeRegistrationPromise
)
;
}
observe
(
aSubject
aTopic
aData
)
{
return
Impl
.
observe
(
aSubject
aTopic
aData
)
;
}
submitExternalPing
(
aType
aPayload
aOptions
=
{
}
)
{
aOptions
.
addClientId
=
aOptions
.
addClientId
|
|
false
;
aOptions
.
addEnvironment
=
aOptions
.
addEnvironment
|
|
false
;
aOptions
.
usePingSender
=
aOptions
.
usePingSender
|
|
false
;
return
Impl
.
submitExternalPing
(
aType
aPayload
aOptions
)
;
}
getCurrentPingData
(
aSubsession
=
false
)
{
return
Impl
.
getCurrentPingData
(
aSubsession
)
;
}
addPendingPing
(
aType
aPayload
aOptions
=
{
}
)
{
let
options
=
aOptions
;
options
.
addClientId
=
aOptions
.
addClientId
|
|
false
;
options
.
addEnvironment
=
aOptions
.
addEnvironment
|
|
false
;
options
.
overwrite
=
aOptions
.
overwrite
|
|
false
;
return
Impl
.
addPendingPing
(
aType
aPayload
options
)
;
}
checkAbortedSessionPing
(
)
{
return
Impl
.
checkAbortedSessionPing
(
)
;
}
saveAbortedSessionPing
(
aPayload
)
{
return
Impl
.
saveAbortedSessionPing
(
aPayload
)
;
}
removeAbortedSessionPing
(
)
{
return
Impl
.
removeAbortedSessionPing
(
)
;
}
promiseInitialized
(
)
{
return
Impl
.
promiseInitialized
(
)
;
}
}
)
;
var
Impl
=
{
_initialized
:
false
_initStarted
:
false
_shuttingDown
:
false
_shutDown
:
false
_logger
:
null
_prevValues
:
{
}
_previousBuildID
:
undefined
_clientID
:
null
_delayedInitTask
:
null
_delayedInitTaskDeferred
:
null
_shutdownBarrier
:
new
AsyncShutdown
.
Barrier
(
"
TelemetryController
:
Waiting
for
clients
.
"
)
_connectionsBarrier
:
new
AsyncShutdown
.
Barrier
(
"
TelemetryController
:
Waiting
for
pending
ping
activity
"
)
_testMode
:
false
_delayedNewPingTask
:
null
_probeRegistrationPromise
:
null
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
)
;
}
return
this
.
_logger
;
}
_getApplicationSection
(
)
{
let
arch
=
null
;
try
{
arch
=
Services
.
sysinfo
.
get
(
"
arch
"
)
;
}
catch
(
e
)
{
this
.
_log
.
trace
(
"
_getApplicationSection
-
Unable
to
get
system
architecture
.
"
e
)
;
}
let
updateChannel
=
null
;
try
{
updateChannel
=
Utils
.
getUpdateChannel
(
)
;
}
catch
(
e
)
{
this
.
_log
.
trace
(
"
_getApplicationSection
-
Unable
to
get
update
channel
.
"
e
)
;
}
return
{
architecture
:
arch
buildId
:
Services
.
appinfo
.
appBuildID
name
:
Services
.
appinfo
.
name
version
:
Services
.
appinfo
.
version
displayVersion
:
AppConstants
.
MOZ_APP_VERSION_DISPLAY
vendor
:
Services
.
appinfo
.
vendor
platformVersion
:
Services
.
appinfo
.
platformVersion
xpcomAbi
:
Services
.
appinfo
.
XPCOMABI
channel
:
updateChannel
}
;
}
assemblePing
:
function
assemblePing
(
aType
aPayload
aOptions
=
{
}
)
{
this
.
_log
.
trace
(
"
assemblePing
-
Type
"
+
aType
+
"
aOptions
"
+
JSON
.
stringify
(
aOptions
)
)
;
let
payload
=
Cu
.
cloneInto
(
aPayload
myScope
)
;
let
pingData
=
{
type
:
aType
id
:
Policy
.
generatePingId
(
)
creationDate
:
(
Policy
.
now
(
)
)
.
toISOString
(
)
version
:
PING_FORMAT_VERSION
application
:
this
.
_getApplicationSection
(
)
payload
}
;
if
(
aOptions
.
addClientId
)
{
pingData
.
clientId
=
this
.
_clientID
;
}
if
(
aOptions
.
addEnvironment
)
{
pingData
.
environment
=
aOptions
.
overrideEnvironment
|
|
TelemetryEnvironment
.
currentEnvironment
;
}
return
pingData
;
}
_trackPendingPingTask
(
aPromise
)
{
this
.
_connectionsBarrier
.
client
.
addBlocker
(
"
Waiting
for
ping
task
"
aPromise
)
;
}
async
_submitPingLogic
(
aType
aPayload
aOptions
)
{
if
(
!
this
.
_clientID
&
&
aOptions
.
addClientId
)
{
Telemetry
.
getHistogramById
(
"
TELEMETRY_PING_SUBMISSION_WAITING_CLIENTID
"
)
.
add
(
)
;
this
.
_clientID
=
await
ClientID
.
getClientID
(
)
;
}
const
pingData
=
this
.
assemblePing
(
aType
aPayload
aOptions
)
;
this
.
_log
.
trace
(
"
submitExternalPing
-
ping
assembled
id
:
"
+
pingData
.
id
)
;
let
archivePromise
=
TelemetryArchive
.
promiseArchivePing
(
pingData
)
.
catch
(
e
=
>
this
.
_log
.
error
(
"
submitExternalPing
-
Failed
to
archive
ping
"
+
pingData
.
id
e
)
)
;
let
p
=
[
archivePromise
]
;
p
.
push
(
TelemetrySend
.
submitPing
(
pingData
{
usePingSender
:
aOptions
.
usePingSender
}
)
)
;
return
Promise
.
all
(
p
)
.
then
(
(
)
=
>
pingData
.
id
)
;
}
submitExternalPing
:
function
send
(
aType
aPayload
aOptions
)
{
this
.
_log
.
trace
(
"
submitExternalPing
-
type
:
"
+
aType
+
"
aOptions
:
"
+
JSON
.
stringify
(
aOptions
)
)
;
if
(
this
.
_shutDown
)
{
const
errorMessage
=
"
submitExternalPing
-
Submission
is
not
allowed
after
shutdown
discarding
ping
of
type
:
"
+
aType
;
this
.
_log
.
error
(
errorMessage
)
;
return
Promise
.
reject
(
new
Error
(
errorMessage
)
)
;
}
const
typeUuid
=
/
^
[
a
-
z0
-
9
]
[
a
-
z0
-
9
-
]
+
[
a
-
z0
-
9
]
/
i
;
if
(
!
typeUuid
.
test
(
aType
)
)
{
this
.
_log
.
error
(
"
submitExternalPing
-
invalid
ping
type
:
"
+
aType
)
;
let
histogram
=
Telemetry
.
getKeyedHistogramById
(
"
TELEMETRY_INVALID_PING_TYPE_SUBMITTED
"
)
;
histogram
.
add
(
aType
1
)
;
return
Promise
.
reject
(
new
Error
(
"
Invalid
type
string
submitted
.
"
)
)
;
}
if
(
aPayload
=
=
=
null
|
|
typeof
aPayload
!
=
=
"
object
"
|
|
Array
.
isArray
(
aPayload
)
)
{
this
.
_log
.
error
(
"
submitExternalPing
-
invalid
payload
type
:
"
+
typeof
aPayload
)
;
let
histogram
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_INVALID_PAYLOAD_SUBMITTED
"
)
;
histogram
.
add
(
1
)
;
return
Promise
.
reject
(
new
Error
(
"
Invalid
payload
type
submitted
.
"
)
)
;
}
let
promise
=
this
.
_submitPingLogic
(
aType
aPayload
aOptions
)
;
this
.
_trackPendingPingTask
(
promise
)
;
return
promise
;
}
addPendingPing
:
function
addPendingPing
(
aType
aPayload
aOptions
)
{
this
.
_log
.
trace
(
"
addPendingPing
-
Type
"
+
aType
+
"
aOptions
"
+
JSON
.
stringify
(
aOptions
)
)
;
let
pingData
=
this
.
assemblePing
(
aType
aPayload
aOptions
)
;
let
savePromise
=
TelemetryStorage
.
savePendingPing
(
pingData
)
;
let
archivePromise
=
TelemetryArchive
.
promiseArchivePing
(
pingData
)
.
catch
(
e
=
>
{
this
.
_log
.
error
(
"
addPendingPing
-
Failed
to
archive
ping
"
+
pingData
.
id
e
)
;
}
)
;
let
promises
=
[
savePromise
archivePromise
]
;
return
Promise
.
all
(
promises
)
.
then
(
(
)
=
>
pingData
.
id
)
;
}
async
checkAbortedSessionPing
(
)
{
let
ping
=
await
TelemetryStorage
.
loadAbortedSessionPing
(
)
;
this
.
_log
.
trace
(
"
checkAbortedSessionPing
-
found
aborted
-
session
ping
:
"
+
!
!
ping
)
;
if
(
!
ping
)
{
return
;
}
try
{
await
TelemetryStorage
.
addPendingPing
(
ping
)
;
await
TelemetryArchive
.
promiseArchivePing
(
ping
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
checkAbortedSessionPing
-
Unable
to
add
the
pending
ping
"
e
)
;
}
finally
{
await
TelemetryStorage
.
removeAbortedSessionPing
(
)
;
}
}
saveAbortedSessionPing
(
aPayload
)
{
this
.
_log
.
trace
(
"
saveAbortedSessionPing
"
)
;
const
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
const
pingData
=
this
.
assemblePing
(
PING_TYPE_MAIN
aPayload
options
)
;
return
TelemetryStorage
.
saveAbortedSessionPing
(
pingData
)
;
}
removeAbortedSessionPing
(
)
{
return
TelemetryStorage
.
removeAbortedSessionPing
(
)
;
}
enableTelemetryRecording
:
function
enableTelemetryRecording
(
)
{
if
(
Utils
.
isContentProcess
&
&
!
this
.
_testMode
&
&
!
Services
.
appinfo
.
browserTabsRemoteAutostart
)
{
this
.
_log
.
config
(
"
enableTelemetryRecording
-
not
enabling
Telemetry
for
non
-
e10s
child
process
"
)
;
Telemetry
.
canRecordBase
=
false
;
Telemetry
.
canRecordExtended
=
false
;
return
false
;
}
if
(
IS_UNIFIED_TELEMETRY
)
{
TelemetryUtils
.
setTelemetryRecordingFlags
(
)
;
}
else
{
Telemetry
.
canRecordBase
=
Telemetry
.
canRecordExtended
=
Utils
.
isTelemetryEnabled
;
}
this
.
_log
.
config
(
"
enableTelemetryRecording
-
canRecordBase
:
"
+
Telemetry
.
canRecordBase
+
"
canRecordExtended
:
"
+
Telemetry
.
canRecordExtended
)
;
return
Telemetry
.
canRecordBase
;
}
setupTelemetry
:
function
setupTelemetry
(
testing
)
{
this
.
_initStarted
=
true
;
this
.
_shuttingDown
=
false
;
this
.
_shutDown
=
false
;
this
.
_testMode
=
testing
;
this
.
_log
.
trace
(
"
setupTelemetry
"
)
;
if
(
this
.
_delayedInitTask
)
{
this
.
_log
.
error
(
"
setupTelemetry
-
init
task
already
running
"
)
;
return
this
.
_delayedInitTaskDeferred
.
promise
;
}
if
(
this
.
_initialized
&
&
!
this
.
_testMode
)
{
this
.
_log
.
error
(
"
setupTelemetry
-
already
initialized
"
)
;
return
Promise
.
resolve
(
)
;
}
this
.
_probeRegistrationPromise
=
this
.
registerJsProbes
(
)
;
TelemetryReportingPolicy
.
setup
(
)
;
if
(
!
this
.
enableTelemetryRecording
(
)
)
{
this
.
_log
.
config
(
"
setupChromeProcess
-
Telemetry
recording
is
disabled
skipping
Chrome
process
setup
.
"
)
;
return
Promise
.
resolve
(
)
;
}
this
.
_attachObservers
(
)
;
TelemetrySession
.
earlyInit
(
this
.
_testMode
)
;
TelemetrySend
.
earlyInit
(
)
;
this
.
_clientID
=
ClientID
.
getCachedClientID
(
)
;
UpdatePing
.
earlyInit
(
)
;
this
.
_delayedInitTaskDeferred
=
PromiseUtils
.
defer
(
)
;
this
.
_delayedInitTask
=
new
DeferredTask
(
async
(
)
=
>
{
try
{
this
.
_initialized
=
true
;
TelemetryEnvironment
.
delayedInit
(
)
;
this
.
_clientID
=
await
ClientID
.
getClientID
(
)
;
await
TelemetrySend
.
setup
(
this
.
_testMode
)
;
await
TelemetrySession
.
delayedInit
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
NewProfilePingEnabled
false
)
&
&
!
TelemetrySession
.
newProfilePingSent
)
{
this
.
scheduleNewProfilePing
(
)
;
}
TelemetryStorage
.
runCleanPingArchiveTask
(
)
;
TelemetryStorage
.
removeFHRDatabase
(
)
;
if
(
!
this
.
_shuttingDown
)
{
TelemetryModules
.
start
(
)
;
}
TelemetryEventPing
.
startup
(
)
;
this
.
_delayedInitTaskDeferred
.
resolve
(
)
;
}
catch
(
e
)
{
this
.
_delayedInitTaskDeferred
.
reject
(
e
)
;
}
finally
{
this
.
_delayedInitTask
=
null
;
}
}
this
.
_testMode
?
TELEMETRY_TEST_DELAY
:
TELEMETRY_DELAY
this
.
_testMode
?
0
:
undefined
)
;
AsyncShutdown
.
sendTelemetry
.
addBlocker
(
"
TelemetryController
:
shutting
down
"
(
)
=
>
this
.
shutdown
(
)
(
)
=
>
this
.
_getState
(
)
)
;
this
.
_delayedInitTask
.
arm
(
)
;
return
this
.
_delayedInitTaskDeferred
.
promise
;
}
setupContentTelemetry
(
testing
=
false
)
{
this
.
_testMode
=
testing
;
if
(
!
this
.
enableTelemetryRecording
(
)
)
{
this
.
_log
.
trace
(
"
setupContentTelemetry
-
Content
process
recording
disabled
.
"
)
;
return
;
}
TelemetrySession
.
setupContent
(
testing
)
;
}
async
_cleanupOnShutdown
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
Services
.
prefs
.
removeObserver
(
PREF_BRANCH_LOG
configureLogging
)
;
this
.
_detachObservers
(
)
;
try
{
if
(
this
.
_delayedNewPingTask
)
{
await
this
.
_delayedNewPingTask
.
finalize
(
)
;
}
UpdatePing
.
shutdown
(
)
;
TelemetryEventPing
.
shutdown
(
)
;
TelemetryReportingPolicy
.
shutdown
(
)
;
TelemetryEnvironment
.
shutdown
(
)
;
await
TelemetrySend
.
shutdown
(
)
;
await
TelemetryHealthPing
.
shutdown
(
)
;
await
TelemetrySession
.
shutdown
(
)
;
await
this
.
_shutdownBarrier
.
wait
(
)
;
await
this
.
_connectionsBarrier
.
wait
(
)
;
await
TelemetryStorage
.
shutdown
(
)
;
}
finally
{
this
.
_initialized
=
false
;
this
.
_initStarted
=
false
;
this
.
_shutDown
=
true
;
}
}
shutdown
(
)
{
this
.
_log
.
trace
(
"
shutdown
"
)
;
this
.
_shuttingDown
=
true
;
if
(
!
this
.
_initStarted
)
{
this
.
_shutDown
=
true
;
return
Promise
.
resolve
(
)
;
}
if
(
!
this
.
_delayedInitTask
)
{
return
this
.
_cleanupOnShutdown
(
)
;
}
return
this
.
_delayedInitTask
.
finalize
(
)
.
then
(
(
)
=
>
this
.
_cleanupOnShutdown
(
)
)
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
profile
-
after
-
change
"
|
|
aTopic
=
=
"
app
-
startup
"
)
{
configureLogging
(
)
;
}
this
.
_log
.
trace
(
"
observe
-
"
+
aTopic
+
"
notified
.
"
)
;
switch
(
aTopic
)
{
case
"
profile
-
after
-
change
"
:
return
this
.
setupTelemetry
(
)
;
case
"
app
-
startup
"
:
return
this
.
setupContentTelemetry
(
)
;
case
"
nsPref
:
changed
"
:
if
(
aData
=
=
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
)
{
return
this
.
_onUploadPrefChange
(
)
;
}
}
return
undefined
;
}
_getState
(
)
{
return
{
initialized
:
this
.
_initialized
initStarted
:
this
.
_initStarted
haveDelayedInitTask
:
!
!
this
.
_delayedInitTask
shutdownBarrier
:
this
.
_shutdownBarrier
.
state
connectionsBarrier
:
this
.
_connectionsBarrier
.
state
sendModule
:
TelemetrySend
.
getShutdownState
(
)
haveDelayedNewProfileTask
:
!
!
this
.
_delayedNewPingTask
}
;
}
_onUploadPrefChange
(
)
{
const
uploadEnabled
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
if
(
uploadEnabled
)
{
return
;
}
let
p
=
(
async
(
)
=
>
{
try
{
await
TelemetrySend
.
clearCurrentPings
(
)
;
await
TelemetryStorage
.
runRemovePendingPingsTask
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
_onUploadPrefChange
-
error
clearing
pending
pings
"
e
)
;
}
finally
{
this
.
_log
.
trace
(
"
_onUploadPrefChange
-
Sending
deletion
ping
.
"
)
;
this
.
submitExternalPing
(
PING_TYPE_DELETION
{
}
{
addClientId
:
true
}
)
;
}
}
)
(
)
;
this
.
_shutdownBarrier
.
client
.
addBlocker
(
"
TelemetryController
:
removing
pending
pings
after
data
upload
was
disabled
"
p
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsISupportsWeakReference
]
)
_attachObservers
(
)
{
if
(
IS_UNIFIED_TELEMETRY
)
{
Services
.
prefs
.
addObserver
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
this
true
)
;
}
}
_detachObservers
(
)
{
if
(
IS_UNIFIED_TELEMETRY
)
{
Services
.
prefs
.
removeObserver
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
this
)
;
}
}
promiseInitialized
(
)
{
return
this
.
_delayedInitTaskDeferred
.
promise
;
}
getCurrentPingData
(
aSubsession
)
{
this
.
_log
.
trace
(
"
getCurrentPingData
-
subsession
:
"
+
aSubsession
)
;
if
(
!
Telemetry
.
canRecordBase
)
{
return
null
;
}
const
reason
=
aSubsession
?
REASON_GATHER_SUBSESSION_PAYLOAD
:
REASON_GATHER_PAYLOAD
;
const
type
=
PING_TYPE_MAIN
;
const
payload
=
TelemetrySession
.
getPayload
(
reason
)
;
const
options
=
{
addClientId
:
true
addEnvironment
:
true
}
;
const
ping
=
this
.
assemblePing
(
type
payload
options
)
;
return
ping
;
}
async
reset
(
)
{
this
.
_clientID
=
null
;
this
.
_detachObservers
(
)
;
let
sessionReset
=
TelemetrySession
.
testReset
(
)
;
this
.
_connectionsBarrier
=
new
AsyncShutdown
.
Barrier
(
"
TelemetryController
:
Waiting
for
pending
ping
activity
"
)
;
this
.
_shutdownBarrier
=
new
AsyncShutdown
.
Barrier
(
"
TelemetryController
:
Waiting
for
clients
.
"
)
;
let
controllerSetup
=
this
.
setupTelemetry
(
true
)
;
await
sessionReset
;
await
TelemetrySend
.
reset
(
)
;
await
TelemetryStorage
.
reset
(
)
;
await
TelemetryEnvironment
.
testReset
(
)
;
await
controllerSetup
;
}
scheduleNewProfilePing
(
)
{
this
.
_log
.
trace
(
"
scheduleNewProfilePing
"
)
;
const
sendDelay
=
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
NewProfilePingDelay
NEWPROFILE_PING_DEFAULT_DELAY
)
;
this
.
_delayedNewPingTask
=
new
DeferredTask
(
async
(
)
=
>
{
try
{
await
this
.
sendNewProfilePing
(
)
;
}
finally
{
this
.
_delayedNewPingTask
=
null
;
}
}
sendDelay
)
;
this
.
_delayedNewPingTask
.
arm
(
)
;
}
async
sendNewProfilePing
(
)
{
this
.
_log
.
trace
(
"
sendNewProfilePing
-
shutting
down
:
"
+
this
.
_shuttingDown
)
;
const
payload
=
{
"
reason
"
:
this
.
_shuttingDown
?
"
shutdown
"
:
"
startup
"
}
;
let
options
=
{
addClientId
:
true
addEnvironment
:
true
usePingSender
:
this
.
_shuttingDown
}
;
await
TelemetryController
.
submitExternalPing
(
"
new
-
profile
"
payload
options
)
.
then
(
(
)
=
>
TelemetrySession
.
markNewProfilePingSent
(
)
e
=
>
this
.
_log
.
error
(
"
sendNewProfilePing
-
failed
to
submit
new
-
profile
ping
"
e
)
)
;
}
async
registerJsProbes
(
)
{
if
(
AppConstants
.
MOZILLA_OFFICIAL
&
&
!
this
.
_testMode
)
{
return
;
}
this
.
_log
.
trace
(
"
registerJsProbes
-
registering
builtin
JS
probes
"
)
;
await
this
.
registerScalarProbes
(
)
;
await
this
.
registerEventProbes
(
)
;
}
_loadProbeDefinitions
(
filename
)
{
let
probeFile
=
Services
.
dirsvc
.
get
(
"
GreD
"
Ci
.
nsIFile
)
;
probeFile
.
append
(
filename
)
;
if
(
!
probeFile
.
exists
(
)
)
{
this
.
_log
.
trace
(
loadProbeDefinitions
-
no
builtin
JS
probe
file
{
filename
}
)
;
return
null
;
}
return
OS
.
File
.
read
(
probeFile
.
path
{
encoding
:
"
utf
-
8
"
}
)
;
}
async
registerScalarProbes
(
)
{
this
.
_log
.
trace
(
"
registerScalarProbes
-
registering
scalar
builtin
JS
probes
"
)
;
const
scalarProbeFilename
=
"
ScalarArtifactDefinitions
.
json
"
;
let
scalarJSProbes
=
{
}
;
try
{
let
fileContent
=
await
this
.
_loadProbeDefinitions
(
scalarProbeFilename
)
;
scalarJSProbes
=
JSON
.
parse
(
fileContent
(
property
value
)
=
>
{
if
(
property
!
=
=
"
kind
"
|
|
typeof
value
!
=
"
string
"
)
{
return
value
;
}
let
newValue
;
switch
(
value
)
{
case
"
nsITelemetry
:
:
SCALAR_TYPE_COUNT
"
:
newValue
=
Telemetry
.
SCALAR_TYPE_COUNT
;
break
;
case
"
nsITelemetry
:
:
SCALAR_TYPE_BOOLEAN
"
:
newValue
=
Telemetry
.
SCALAR_TYPE_BOOLEAN
;
break
;
case
"
nsITelemetry
:
:
SCALAR_TYPE_STRING
"
:
newValue
=
Telemetry
.
SCALAR_TYPE_STRING
;
break
;
}
return
newValue
;
}
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
registerScalarProbes
-
there
was
an
error
loading
{
scalarProbeFilename
}
ex
)
;
}
for
(
let
category
in
scalarJSProbes
)
{
Telemetry
.
registerBuiltinScalars
(
category
scalarJSProbes
[
category
]
)
;
}
}
async
registerEventProbes
(
)
{
this
.
_log
.
trace
(
"
registerEventProbes
-
registering
builtin
JS
Event
probes
"
)
;
const
eventProbeFilename
=
"
EventArtifactDefinitions
.
json
"
;
let
eventJSProbes
=
{
}
;
try
{
let
fileContent
=
await
this
.
_loadProbeDefinitions
(
eventProbeFilename
)
;
eventJSProbes
=
JSON
.
parse
(
fileContent
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
registerEventProbes
-
there
was
an
error
loading
{
eventProbeFilename
}
ex
)
;
}
for
(
let
category
in
eventJSProbes
)
{
Telemetry
.
registerBuiltinEvents
(
category
eventJSProbes
[
category
]
)
;
}
}
}
;
