#
[
macro_use
]
extern
crate
cstr
;
use
glean_preview
:
:
metrics
:
:
PingType
;
use
glean_preview
:
:
{
ClientInfoMetrics
Configuration
}
;
use
log
:
:
error
;
use
nserror
:
:
{
nsresult
NS_ERROR_FAILURE
NS_OK
}
;
use
nsstring
:
:
{
nsAString
nsString
}
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
fs
:
:
{
self
File
}
;
use
std
:
:
io
:
:
{
self
BufRead
BufReader
Error
Write
}
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
std
:
:
thread
:
:
JoinHandle
;
use
std
:
:
{
thread
time
}
;
use
xpcom
:
:
interfaces
:
:
{
nsIFile
nsIProcess
}
;
use
xpcom
:
:
RefPtr
;
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
fog_init
(
data_dir
:
&
nsAString
pingsender_path
:
&
nsAString
)
-
>
nsresult
{
let
upload_enabled
=
static_prefs
:
:
pref
!
(
"
datareporting
.
healthreport
.
uploadEnabled
"
)
;
let
pingsender_path
=
pingsender_path
.
to_string
(
)
;
let
data_dir
=
data_dir
.
to_string
(
)
;
if
thread
:
:
Builder
:
:
new
(
)
.
name
(
"
fogotype_init
"
.
to_owned
(
)
)
.
spawn
(
move
|
|
{
let
cfg
=
Configuration
{
data_path
:
data_dir
.
clone
(
)
application_id
:
"
org
.
mozilla
.
fogotype
"
.
into
(
)
upload_enabled
max_events
:
None
delay_ping_lifetime_io
:
false
channel
:
Some
(
"
nightly
"
.
into
(
)
)
}
;
if
let
Err
(
e
)
=
glean_preview
:
:
initialize
(
cfg
ClientInfoMetrics
:
:
unknown
(
)
)
{
error
!
(
"
Failed
to
init
glean_preview
due
to
{
:
?
}
"
e
)
;
return
;
}
let
mut
data_path
=
PathBuf
:
:
from
(
data_dir
)
;
data_path
.
push
(
"
pending_pings
"
)
;
if
let
Err
(
e
)
=
prototype_ping_init
(
data_path
pingsender_path
)
{
error
!
(
"
Failed
to
init
fogtotype
prototype
ping
due
to
{
:
?
}
"
e
)
;
}
}
)
.
is_err
(
)
{
return
NS_ERROR_FAILURE
;
}
NS_OK
}
fn
prototype_ping_init
(
ping_dir
:
PathBuf
pingsender_path
:
String
)
-
>
Result
<
JoinHandle
<
(
)
>
Error
>
{
thread
:
:
Builder
:
:
new
(
)
.
name
(
"
fogotype_ping
"
.
to_owned
(
)
)
.
spawn
(
move
|
|
{
let
prototype_ping
=
PingType
:
:
new
(
"
prototype
"
true
true
)
;
glean_preview
:
:
register_ping_type
(
&
prototype_ping
)
;
let
an_hour
=
time
:
:
Duration
:
:
from_secs
(
60
*
60
)
;
loop
{
thread
:
:
sleep
(
an_hour
)
;
let
upload_enabled
=
static_prefs
:
:
pref
!
(
"
datareporting
.
healthreport
.
uploadEnabled
"
)
;
glean_preview
:
:
set_upload_enabled
(
upload_enabled
)
;
if
!
upload_enabled
{
continue
;
}
prototype_ping
.
submit
(
)
;
if
let
Err
(
e
)
=
send_all_pings
(
&
ping_dir
&
pingsender_path
)
{
error
!
(
"
Failed
to
send
all
pings
due
to
{
:
?
}
"
e
)
;
}
}
}
)
}
fn
send_all_pings
(
ping_dir
:
&
Path
pingsender_path
:
&
str
)
-
>
Result
<
(
)
Box
<
dyn
std
:
:
error
:
:
Error
>
>
{
assert
!
(
ping_dir
.
is_dir
(
)
)
;
let
telemetry_dir
=
ping_dir
.
join
(
"
telemetry
"
)
;
let
_
=
fs
:
:
remove_dir_all
(
&
telemetry_dir
)
;
fs
:
:
create_dir
(
&
telemetry_dir
)
?
;
for
entry
in
fs
:
:
read_dir
(
ping_dir
)
?
{
let
entry
=
entry
?
;
let
path
=
entry
.
path
(
)
;
if
!
path
.
is_file
(
)
{
continue
;
}
let
file
=
File
:
:
open
(
&
path
)
?
;
let
reader
=
BufReader
:
:
new
(
file
)
;
let
lines
:
Vec
<
String
>
=
reader
.
lines
(
)
.
filter_map
(
io
:
:
Result
:
:
ok
)
.
collect
(
)
;
if
lines
.
len
(
)
!
=
2
{
fs
:
:
remove_file
(
path
)
?
;
continue
;
}
let
telemetry_ping_path
=
telemetry_dir
.
join
(
path
.
file_name
(
)
.
ok_or
(
"
ping
dir
file
name
invalid
"
)
?
)
;
let
mut
telemetry_ping_file
=
File
:
:
create
(
&
telemetry_ping_path
)
?
;
write
!
(
telemetry_ping_file
"
{
}
"
lines
[
1
]
)
?
;
fs
:
:
remove_file
(
path
)
?
;
let
pingsender_file
:
RefPtr
<
nsIFile
>
=
xpcom
:
:
create_instance
(
&
cstr
!
(
"
mozilla
.
org
/
file
/
local
;
1
"
)
)
.
ok_or
(
"
couldn
'
t
create
nsIFile
"
)
?
;
let
process
:
RefPtr
<
nsIProcess
>
=
xpcom
:
:
create_instance
(
&
cstr
!
(
"
mozilla
.
org
/
process
/
util
;
1
"
)
)
.
ok_or
(
"
couldn
'
t
create
nsIProcess
"
)
?
;
unsafe
{
pingsender_file
.
InitWithPath
(
&
*
nsString
:
:
from
(
pingsender_path
)
as
&
nsAString
)
.
to_result
(
)
?
;
process
.
Init
(
&
*
pingsender_file
)
.
to_result
(
)
?
;
process
.
SetStartHidden
(
true
)
.
to_result
(
)
?
;
process
.
SetNoShell
(
true
)
.
to_result
(
)
?
;
}
;
let
server_url
=
CString
:
:
new
(
format
!
(
"
https
:
/
/
incoming
.
telemetry
.
mozilla
.
org
{
}
"
lines
[
0
]
)
)
?
;
let
telemetry_ping_path_cstr
=
CString
:
:
new
(
telemetry_ping_path
.
to_str
(
)
.
expect
(
"
non
-
unicode
ping
path
character
"
)
)
?
;
let
mut
args
=
[
server_url
.
as_ptr
(
)
telemetry_ping_path_cstr
.
as_ptr
(
)
]
;
let
args_length
=
2
;
unsafe
{
process
.
Run
(
true
args
.
as_mut_ptr
(
)
args_length
)
.
to_result
(
)
?
;
}
;
}
Ok
(
(
)
)
}
