#
ifndef
mozilla_BackgroundHangTelemetry_h
#
define
mozilla_BackgroundHangTelemetry_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
HangAnnotations
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsString
.
h
"
#
include
"
prinrval
.
h
"
namespace
mozilla
{
namespace
Telemetry
{
static
const
size_t
kTimeHistogramBuckets
=
8
*
sizeof
(
PRIntervalTime
)
;
class
TimeHistogram
:
public
mozilla
:
:
Array
<
uint32_t
kTimeHistogramBuckets
>
{
public
:
TimeHistogram
(
)
{
mozilla
:
:
PodArrayZero
(
*
this
)
;
}
uint32_t
GetBucketMin
(
size_t
aBucket
)
const
{
MOZ_ASSERT
(
aBucket
<
ArrayLength
(
*
this
)
)
;
return
(
1u
<
<
aBucket
)
&
~
1u
;
}
uint32_t
GetBucketMax
(
size_t
aBucket
)
const
{
MOZ_ASSERT
(
aBucket
<
ArrayLength
(
*
this
)
)
;
return
(
1u
<
<
(
aBucket
+
1u
)
)
-
1u
;
}
void
Add
(
PRIntervalTime
aTime
)
;
}
;
class
HangStack
{
public
:
static
const
size_t
sMaxInlineStorage
=
8
;
static
const
size_t
sMaxNativeFrames
=
25
;
private
:
typedef
mozilla
:
:
Vector
<
const
char
*
sMaxInlineStorage
>
Impl
;
Impl
mImpl
;
mozilla
:
:
Vector
<
char
0
>
mBuffer
;
std
:
:
vector
<
uintptr_t
>
mNativeFrames
;
public
:
HangStack
(
)
{
}
HangStack
(
HangStack
&
&
aOther
)
:
mImpl
(
mozilla
:
:
Move
(
aOther
.
mImpl
)
)
mBuffer
(
mozilla
:
:
Move
(
aOther
.
mBuffer
)
)
{
}
bool
operator
=
=
(
const
HangStack
&
aOther
)
const
{
for
(
size_t
i
=
0
;
i
<
length
(
)
;
i
+
+
)
{
if
(
!
IsSameAsEntry
(
operator
[
]
(
i
)
aOther
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
HangStack
&
aOther
)
const
{
return
!
operator
=
=
(
aOther
)
;
}
const
char
*
&
operator
[
]
(
size_t
aIndex
)
{
return
mImpl
[
aIndex
]
;
}
const
char
*
const
&
operator
[
]
(
size_t
aIndex
)
const
{
return
mImpl
[
aIndex
]
;
}
size_t
capacity
(
)
const
{
return
mImpl
.
capacity
(
)
;
}
size_t
length
(
)
const
{
return
mImpl
.
length
(
)
;
}
bool
empty
(
)
const
{
return
mImpl
.
empty
(
)
;
}
bool
canAppendWithoutRealloc
(
size_t
aNeeded
)
const
{
return
mImpl
.
canAppendWithoutRealloc
(
aNeeded
)
;
}
void
infallibleAppend
(
const
char
*
aEntry
)
{
mImpl
.
infallibleAppend
(
aEntry
)
;
}
bool
reserve
(
size_t
aRequest
)
{
return
mImpl
.
reserve
(
aRequest
)
;
}
const
char
*
*
begin
(
)
{
return
mImpl
.
begin
(
)
;
}
const
char
*
const
*
begin
(
)
const
{
return
mImpl
.
begin
(
)
;
}
const
char
*
*
end
(
)
{
return
mImpl
.
end
(
)
;
}
const
char
*
const
*
end
(
)
const
{
return
mImpl
.
end
(
)
;
}
const
char
*
&
back
(
)
{
return
mImpl
.
back
(
)
;
}
void
erase
(
const
char
*
*
aEntry
)
{
mImpl
.
erase
(
aEntry
)
;
}
void
erase
(
const
char
*
*
aBegin
const
char
*
*
aEnd
)
{
mImpl
.
erase
(
aBegin
aEnd
)
;
}
void
clear
(
)
{
mImpl
.
clear
(
)
;
mBuffer
.
clear
(
)
;
mNativeFrames
.
clear
(
)
;
}
bool
IsInBuffer
(
const
char
*
aEntry
)
const
{
return
aEntry
>
=
mBuffer
.
begin
(
)
&
&
aEntry
<
mBuffer
.
end
(
)
;
}
bool
IsSameAsEntry
(
const
char
*
aEntry
const
char
*
aOther
)
const
{
return
IsInBuffer
(
aEntry
)
?
!
strcmp
(
aEntry
aOther
)
:
(
aEntry
=
=
aOther
)
;
}
size_t
AvailableBufferSize
(
)
const
{
return
mBuffer
.
capacity
(
)
-
mBuffer
.
length
(
)
;
}
bool
EnsureBufferCapacity
(
size_t
aCapacity
)
{
return
mBuffer
.
reserve
(
aCapacity
)
&
&
mBuffer
.
reserve
(
mBuffer
.
capacity
(
)
)
;
}
const
char
*
InfallibleAppendViaBuffer
(
const
char
*
aText
size_t
aLength
)
;
const
char
*
AppendViaBuffer
(
const
char
*
aText
size_t
aLength
)
;
void
EnsureNativeFrameCapacity
(
size_t
aCapacity
)
{
mNativeFrames
.
reserve
(
aCapacity
)
;
}
void
AppendNativeFrame
(
uintptr_t
aPc
)
{
MOZ_ASSERT
(
mNativeFrames
.
size
(
)
<
=
sMaxNativeFrames
)
;
if
(
mNativeFrames
.
size
(
)
<
sMaxNativeFrames
)
{
mNativeFrames
.
push_back
(
aPc
)
;
}
}
const
std
:
:
vector
<
uintptr_t
>
&
GetNativeFrames
(
)
const
{
return
mNativeFrames
;
}
}
;
class
HangHistogram
:
public
TimeHistogram
{
private
:
static
uint32_t
GetHash
(
const
HangStack
&
aStack
)
;
HangStack
mStack
;
HangStack
mNativeStack
;
const
uint32_t
mHash
;
HangMonitor
:
:
HangAnnotationsVector
mAnnotations
;
public
:
explicit
HangHistogram
(
HangStack
&
&
aStack
)
:
mStack
(
mozilla
:
:
Move
(
aStack
)
)
mHash
(
GetHash
(
mStack
)
)
{
}
HangHistogram
(
HangHistogram
&
&
aOther
)
:
TimeHistogram
(
mozilla
:
:
Move
(
aOther
)
)
mStack
(
mozilla
:
:
Move
(
aOther
.
mStack
)
)
mNativeStack
(
mozilla
:
:
Move
(
aOther
.
mNativeStack
)
)
mHash
(
mozilla
:
:
Move
(
aOther
.
mHash
)
)
mAnnotations
(
mozilla
:
:
Move
(
aOther
.
mAnnotations
)
)
{
}
bool
operator
=
=
(
const
HangHistogram
&
aOther
)
const
;
bool
operator
!
=
(
const
HangHistogram
&
aOther
)
const
{
return
!
operator
=
=
(
aOther
)
;
}
const
HangStack
&
GetStack
(
)
const
{
return
mStack
;
}
HangStack
&
GetNativeStack
(
)
{
return
mNativeStack
;
}
const
HangStack
&
GetNativeStack
(
)
const
{
return
mNativeStack
;
}
const
HangMonitor
:
:
HangAnnotationsVector
&
GetAnnotations
(
)
const
{
return
mAnnotations
;
}
void
Add
(
PRIntervalTime
aTime
HangMonitor
:
:
HangAnnotationsPtr
aAnnotations
)
{
TimeHistogram
:
:
Add
(
aTime
)
;
if
(
aAnnotations
)
{
if
(
!
mAnnotations
.
append
(
Move
(
aAnnotations
)
)
)
{
MOZ_CRASH
(
)
;
}
}
}
}
;
class
ThreadHangStats
{
private
:
nsCString
mName
;
public
:
TimeHistogram
mActivity
;
mozilla
:
:
Vector
<
HangHistogram
4
>
mHangs
;
explicit
ThreadHangStats
(
const
char
*
aName
)
:
mName
(
aName
)
{
}
ThreadHangStats
(
ThreadHangStats
&
&
aOther
)
:
mName
(
mozilla
:
:
Move
(
aOther
.
mName
)
)
mActivity
(
mozilla
:
:
Move
(
aOther
.
mActivity
)
)
mHangs
(
mozilla
:
:
Move
(
aOther
.
mHangs
)
)
{
}
const
char
*
GetName
(
)
const
{
return
mName
.
get
(
)
;
}
}
;
}
}
#
endif
