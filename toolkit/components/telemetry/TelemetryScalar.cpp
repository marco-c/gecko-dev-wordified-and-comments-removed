#
include
"
nsITelemetry
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
TelemetryComms
.
h
"
#
include
"
TelemetryCommon
.
h
"
#
include
"
TelemetryIPCAccumulator
.
h
"
#
include
"
TelemetryScalar
.
h
"
#
include
"
TelemetryScalarData
.
h
"
using
mozilla
:
:
StaticMutex
;
using
mozilla
:
:
StaticMutexAutoLock
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
AutoHashtable
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsExpiredVersion
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
CanRecordDataset
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsInDataset
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
LogToBrowserConsole
;
using
mozilla
:
:
Telemetry
:
:
ScalarActionType
;
using
mozilla
:
:
Telemetry
:
:
ScalarVariant
;
namespace
{
const
uint32_t
kMaximumNumberOfKeys
=
100
;
const
uint32_t
kMaximumKeyStringLength
=
70
;
const
uint32_t
kMaximumStringValueLength
=
50
;
const
uint32_t
kScalarCount
=
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
ScalarCount
)
;
enum
class
ScalarResult
:
uint8_t
{
Ok
NotInitialized
CannotUnpackVariant
CannotRecordInProcess
CannotRecordDataset
KeyedTypeMismatch
UnknownScalar
OperationNotSupported
InvalidType
InvalidValue
KeyIsEmpty
KeyTooLong
TooManyKeys
StringTooLong
UnsignedNegativeValue
UnsignedTruncatedValue
}
;
typedef
nsBaseHashtableET
<
nsDepCharHashKey
mozilla
:
:
Telemetry
:
:
ScalarID
>
CharPtrEntryType
;
typedef
AutoHashtable
<
CharPtrEntryType
>
ScalarMapType
;
bool
IsValidEnumId
(
mozilla
:
:
Telemetry
:
:
ScalarID
aID
)
{
return
aID
<
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
ScalarCount
;
}
ScalarResult
GetVariantFromIVariant
(
nsIVariant
*
aInput
uint32_t
aScalarKind
mozilla
:
:
Maybe
<
ScalarVariant
>
&
aOutput
)
{
switch
(
aScalarKind
)
{
case
nsITelemetry
:
:
SCALAR_COUNT
:
{
uint32_t
val
=
0
;
nsresult
rv
=
aInput
-
>
GetAsUint32
(
&
val
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
CannotUnpackVariant
;
}
aOutput
=
mozilla
:
:
Some
(
mozilla
:
:
AsVariant
(
val
)
)
;
break
;
}
case
nsITelemetry
:
:
SCALAR_STRING
:
{
nsString
val
;
nsresult
rv
=
aInput
-
>
GetAsAString
(
val
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
CannotUnpackVariant
;
}
aOutput
=
mozilla
:
:
Some
(
mozilla
:
:
AsVariant
(
val
)
)
;
break
;
}
case
nsITelemetry
:
:
SCALAR_BOOLEAN
:
{
bool
val
=
false
;
nsresult
rv
=
aInput
-
>
GetAsBool
(
&
val
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
CannotUnpackVariant
;
}
aOutput
=
mozilla
:
:
Some
(
mozilla
:
:
AsVariant
(
val
)
)
;
break
;
}
default
:
MOZ_ASSERT
(
false
"
Unknown
scalar
kind
.
"
)
;
return
ScalarResult
:
:
UnknownScalar
;
}
return
ScalarResult
:
:
Ok
;
}
const
char
*
ScalarInfo
:
:
name
(
)
const
{
return
&
gScalarsStringTable
[
this
-
>
name_offset
]
;
}
const
char
*
ScalarInfo
:
:
expiration
(
)
const
{
return
&
gScalarsStringTable
[
this
-
>
expiration_offset
]
;
}
class
ScalarBase
{
public
:
virtual
~
ScalarBase
(
)
=
default
;
virtual
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
=
0
;
virtual
ScalarResult
AddValue
(
nsIVariant
*
aValue
)
{
return
ScalarResult
:
:
OperationNotSupported
;
}
virtual
ScalarResult
SetMaximum
(
nsIVariant
*
aValue
)
{
return
ScalarResult
:
:
OperationNotSupported
;
}
virtual
void
SetValue
(
uint32_t
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
ScalarResult
SetValue
(
const
nsAString
&
aValue
)
{
return
HandleUnsupported
(
)
;
}
virtual
void
SetValue
(
bool
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
void
AddValue
(
uint32_t
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
void
SetMaximum
(
uint32_t
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
nsresult
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
=
0
;
virtual
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
=
0
;
private
:
ScalarResult
HandleUnsupported
(
)
const
;
}
;
ScalarResult
ScalarBase
:
:
HandleUnsupported
(
)
const
{
MOZ_ASSERT
(
false
"
This
operation
is
not
support
for
this
scalar
type
.
"
)
;
return
ScalarResult
:
:
OperationNotSupported
;
}
class
ScalarUnsigned
:
public
ScalarBase
{
public
:
using
ScalarBase
:
:
SetValue
;
ScalarUnsigned
(
)
:
mStorage
(
0
)
{
}
;
~
ScalarUnsigned
(
)
override
=
default
;
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
final
;
void
SetValue
(
uint32_t
aValue
)
final
;
ScalarResult
AddValue
(
nsIVariant
*
aValue
)
final
;
void
AddValue
(
uint32_t
aValue
)
final
;
ScalarResult
SetMaximum
(
nsIVariant
*
aValue
)
final
;
void
SetMaximum
(
uint32_t
aValue
)
final
;
nsresult
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
final
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
final
;
private
:
uint32_t
mStorage
;
ScalarResult
CheckInput
(
nsIVariant
*
aValue
)
;
ScalarUnsigned
(
const
ScalarUnsigned
&
aOther
)
=
delete
;
void
operator
=
(
const
ScalarUnsigned
&
aOther
)
=
delete
;
}
;
ScalarResult
ScalarUnsigned
:
:
SetValue
(
nsIVariant
*
aValue
)
{
ScalarResult
sr
=
CheckInput
(
aValue
)
;
if
(
sr
=
=
ScalarResult
:
:
UnsignedNegativeValue
)
{
return
sr
;
}
if
(
NS_FAILED
(
aValue
-
>
GetAsUint32
(
&
mStorage
)
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
return
sr
;
}
void
ScalarUnsigned
:
:
SetValue
(
uint32_t
aValue
)
{
mStorage
=
aValue
;
}
ScalarResult
ScalarUnsigned
:
:
AddValue
(
nsIVariant
*
aValue
)
{
ScalarResult
sr
=
CheckInput
(
aValue
)
;
if
(
sr
=
=
ScalarResult
:
:
UnsignedNegativeValue
)
{
return
sr
;
}
uint32_t
newAddend
=
0
;
nsresult
rv
=
aValue
-
>
GetAsUint32
(
&
newAddend
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
mStorage
+
=
newAddend
;
return
sr
;
}
void
ScalarUnsigned
:
:
AddValue
(
uint32_t
aValue
)
{
mStorage
+
=
aValue
;
}
ScalarResult
ScalarUnsigned
:
:
SetMaximum
(
nsIVariant
*
aValue
)
{
ScalarResult
sr
=
CheckInput
(
aValue
)
;
if
(
sr
=
=
ScalarResult
:
:
UnsignedNegativeValue
)
{
return
sr
;
}
uint32_t
newValue
=
0
;
nsresult
rv
=
aValue
-
>
GetAsUint32
(
&
newValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
if
(
newValue
>
mStorage
)
{
mStorage
=
newValue
;
}
return
sr
;
}
void
ScalarUnsigned
:
:
SetMaximum
(
uint32_t
aValue
)
{
if
(
aValue
>
mStorage
)
{
mStorage
=
aValue
;
}
}
nsresult
ScalarUnsigned
:
:
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
{
nsCOMPtr
<
nsIWritableVariant
>
outVar
(
new
nsVariant
(
)
)
;
nsresult
rv
=
outVar
-
>
SetAsUint32
(
mStorage
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aResult
=
outVar
.
forget
(
)
;
return
NS_OK
;
}
size_t
ScalarUnsigned
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
;
}
ScalarResult
ScalarUnsigned
:
:
CheckInput
(
nsIVariant
*
aValue
)
{
uint16_t
type
;
aValue
-
>
GetDataType
(
&
type
)
;
if
(
type
=
=
nsIDataType
:
:
VTYPE_FLOAT
|
|
type
=
=
nsIDataType
:
:
VTYPE_DOUBLE
)
{
return
ScalarResult
:
:
UnsignedTruncatedValue
;
}
int32_t
signedTest
;
if
(
NS_SUCCEEDED
(
aValue
-
>
GetAsInt32
(
&
signedTest
)
)
&
&
signedTest
<
0
)
{
return
ScalarResult
:
:
UnsignedNegativeValue
;
}
return
ScalarResult
:
:
Ok
;
}
class
ScalarString
:
public
ScalarBase
{
public
:
using
ScalarBase
:
:
SetValue
;
ScalarString
(
)
:
mStorage
(
EmptyString
(
)
)
{
}
;
~
ScalarString
(
)
override
=
default
;
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
final
;
ScalarResult
SetValue
(
const
nsAString
&
aValue
)
final
;
nsresult
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
final
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
final
;
private
:
nsString
mStorage
;
ScalarString
(
const
ScalarString
&
aOther
)
=
delete
;
void
operator
=
(
const
ScalarString
&
aOther
)
=
delete
;
}
;
ScalarResult
ScalarString
:
:
SetValue
(
nsIVariant
*
aValue
)
{
uint16_t
type
;
aValue
-
>
GetDataType
(
&
type
)
;
if
(
type
!
=
nsIDataType
:
:
VTYPE_CHAR
&
&
type
!
=
nsIDataType
:
:
VTYPE_WCHAR
&
&
type
!
=
nsIDataType
:
:
VTYPE_DOMSTRING
&
&
type
!
=
nsIDataType
:
:
VTYPE_CHAR_STR
&
&
type
!
=
nsIDataType
:
:
VTYPE_WCHAR_STR
&
&
type
!
=
nsIDataType
:
:
VTYPE_STRING_SIZE_IS
&
&
type
!
=
nsIDataType
:
:
VTYPE_WSTRING_SIZE_IS
&
&
type
!
=
nsIDataType
:
:
VTYPE_UTF8STRING
&
&
type
!
=
nsIDataType
:
:
VTYPE_CSTRING
&
&
type
!
=
nsIDataType
:
:
VTYPE_ASTRING
)
{
return
ScalarResult
:
:
InvalidType
;
}
nsAutoString
convertedString
;
nsresult
rv
=
aValue
-
>
GetAsAString
(
convertedString
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
return
SetValue
(
convertedString
)
;
}
;
ScalarResult
ScalarString
:
:
SetValue
(
const
nsAString
&
aValue
)
{
mStorage
=
Substring
(
aValue
0
kMaximumStringValueLength
)
;
if
(
aValue
.
Length
(
)
>
kMaximumStringValueLength
)
{
return
ScalarResult
:
:
StringTooLong
;
}
return
ScalarResult
:
:
Ok
;
}
nsresult
ScalarString
:
:
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
{
nsCOMPtr
<
nsIWritableVariant
>
outVar
(
new
nsVariant
(
)
)
;
nsresult
rv
=
outVar
-
>
SetAsAString
(
mStorage
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aResult
=
outVar
.
forget
(
)
;
return
NS_OK
;
}
size_t
ScalarString
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mStorage
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
return
n
;
}
class
ScalarBoolean
:
public
ScalarBase
{
public
:
using
ScalarBase
:
:
SetValue
;
ScalarBoolean
(
)
:
mStorage
(
false
)
{
}
;
~
ScalarBoolean
(
)
override
=
default
;
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
final
;
void
SetValue
(
bool
aValue
)
final
;
nsresult
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
final
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
final
;
private
:
bool
mStorage
;
ScalarBoolean
(
const
ScalarBoolean
&
aOther
)
=
delete
;
void
operator
=
(
const
ScalarBoolean
&
aOther
)
=
delete
;
}
;
ScalarResult
ScalarBoolean
:
:
SetValue
(
nsIVariant
*
aValue
)
{
uint16_t
type
;
aValue
-
>
GetDataType
(
&
type
)
;
if
(
type
!
=
nsIDataType
:
:
VTYPE_BOOL
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT8
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT16
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT32
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT64
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT8
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT16
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT32
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT64
)
{
return
ScalarResult
:
:
InvalidType
;
}
if
(
NS_FAILED
(
aValue
-
>
GetAsBool
(
&
mStorage
)
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
return
ScalarResult
:
:
Ok
;
}
;
void
ScalarBoolean
:
:
SetValue
(
bool
aValue
)
{
mStorage
=
aValue
;
}
nsresult
ScalarBoolean
:
:
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
{
nsCOMPtr
<
nsIWritableVariant
>
outVar
(
new
nsVariant
(
)
)
;
nsresult
rv
=
outVar
-
>
SetAsBool
(
mStorage
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aResult
=
outVar
.
forget
(
)
;
return
NS_OK
;
}
size_t
ScalarBoolean
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
;
}
ScalarBase
*
internal_ScalarAllocate
(
uint32_t
aScalarKind
)
{
ScalarBase
*
scalar
=
nullptr
;
switch
(
aScalarKind
)
{
case
nsITelemetry
:
:
SCALAR_COUNT
:
scalar
=
new
ScalarUnsigned
(
)
;
break
;
case
nsITelemetry
:
:
SCALAR_STRING
:
scalar
=
new
ScalarString
(
)
;
break
;
case
nsITelemetry
:
:
SCALAR_BOOLEAN
:
scalar
=
new
ScalarBoolean
(
)
;
break
;
default
:
MOZ_ASSERT
(
false
"
Invalid
scalar
type
"
)
;
}
return
scalar
;
}
class
KeyedScalar
{
public
:
typedef
mozilla
:
:
Pair
<
nsCString
nsCOMPtr
<
nsIVariant
>
>
KeyValuePair
;
explicit
KeyedScalar
(
uint32_t
aScalarKind
)
:
mScalarKind
(
aScalarKind
)
{
}
;
~
KeyedScalar
(
)
=
default
;
ScalarResult
SetValue
(
const
nsAString
&
aKey
nsIVariant
*
aValue
)
;
ScalarResult
AddValue
(
const
nsAString
&
aKey
nsIVariant
*
aValue
)
;
ScalarResult
SetMaximum
(
const
nsAString
&
aKey
nsIVariant
*
aValue
)
;
void
SetValue
(
const
nsAString
&
aKey
uint32_t
aValue
)
;
void
SetValue
(
const
nsAString
&
aKey
bool
aValue
)
;
void
AddValue
(
const
nsAString
&
aKey
uint32_t
aValue
)
;
void
SetMaximum
(
const
nsAString
&
aKey
uint32_t
aValue
)
;
nsresult
GetValue
(
nsTArray
<
KeyValuePair
>
&
aValues
)
const
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
;
private
:
typedef
nsClassHashtable
<
nsCStringHashKey
ScalarBase
>
ScalarKeysMapType
;
ScalarKeysMapType
mScalarKeys
;
const
uint32_t
mScalarKind
;
ScalarResult
GetScalarForKey
(
const
nsAString
&
aKey
ScalarBase
*
*
aRet
)
;
}
;
ScalarResult
KeyedScalar
:
:
SetValue
(
const
nsAString
&
aKey
nsIVariant
*
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
return
sr
;
}
return
scalar
-
>
SetValue
(
aValue
)
;
}
ScalarResult
KeyedScalar
:
:
AddValue
(
const
nsAString
&
aKey
nsIVariant
*
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
return
sr
;
}
return
scalar
-
>
AddValue
(
aValue
)
;
}
ScalarResult
KeyedScalar
:
:
SetMaximum
(
const
nsAString
&
aKey
nsIVariant
*
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
return
sr
;
}
return
scalar
-
>
SetMaximum
(
aValue
)
;
}
void
KeyedScalar
:
:
SetValue
(
const
nsAString
&
aKey
uint32_t
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Key
too
long
or
too
many
keys
are
recorded
in
the
scalar
.
"
)
;
return
;
}
return
scalar
-
>
SetValue
(
aValue
)
;
}
void
KeyedScalar
:
:
SetValue
(
const
nsAString
&
aKey
bool
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Key
too
long
or
too
many
keys
are
recorded
in
the
scalar
.
"
)
;
return
;
}
return
scalar
-
>
SetValue
(
aValue
)
;
}
void
KeyedScalar
:
:
AddValue
(
const
nsAString
&
aKey
uint32_t
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Key
too
long
or
too
many
keys
are
recorded
in
the
scalar
.
"
)
;
return
;
}
return
scalar
-
>
AddValue
(
aValue
)
;
}
void
KeyedScalar
:
:
SetMaximum
(
const
nsAString
&
aKey
uint32_t
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Key
too
long
or
too
many
keys
are
recorded
in
the
scalar
.
"
)
;
return
;
}
return
scalar
-
>
SetMaximum
(
aValue
)
;
}
nsresult
KeyedScalar
:
:
GetValue
(
nsTArray
<
KeyValuePair
>
&
aValues
)
const
{
for
(
auto
iter
=
mScalarKeys
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarBase
*
scalar
=
static_cast
<
ScalarBase
*
>
(
iter
.
Data
(
)
)
;
nsCOMPtr
<
nsIVariant
>
scalarValue
;
nsresult
rv
=
scalar
-
>
GetValue
(
scalarValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aValues
.
AppendElement
(
mozilla
:
:
MakePair
(
nsCString
(
iter
.
Key
(
)
)
scalarValue
)
)
;
}
return
NS_OK
;
}
ScalarResult
KeyedScalar
:
:
GetScalarForKey
(
const
nsAString
&
aKey
ScalarBase
*
*
aRet
)
{
if
(
aKey
.
IsEmpty
(
)
)
{
return
ScalarResult
:
:
KeyIsEmpty
;
}
if
(
aKey
.
Length
(
)
>
=
kMaximumKeyStringLength
)
{
return
ScalarResult
:
:
KeyTooLong
;
}
if
(
mScalarKeys
.
Count
(
)
>
=
kMaximumNumberOfKeys
)
{
return
ScalarResult
:
:
TooManyKeys
;
}
NS_ConvertUTF16toUTF8
utf8Key
(
aKey
)
;
ScalarBase
*
scalar
=
nullptr
;
if
(
mScalarKeys
.
Get
(
utf8Key
&
scalar
)
)
{
*
aRet
=
scalar
;
return
ScalarResult
:
:
Ok
;
}
scalar
=
internal_ScalarAllocate
(
mScalarKind
)
;
if
(
!
scalar
)
{
return
ScalarResult
:
:
InvalidType
;
}
mScalarKeys
.
Put
(
utf8Key
scalar
)
;
*
aRet
=
scalar
;
return
ScalarResult
:
:
Ok
;
}
size_t
KeyedScalar
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
this
)
;
for
(
auto
iter
=
mScalarKeys
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarBase
*
scalar
=
static_cast
<
ScalarBase
*
>
(
iter
.
Data
(
)
)
;
n
+
=
scalar
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
typedef
nsUint32HashKey
ScalarIDHashKey
;
typedef
nsUint32HashKey
ProcessIDHashKey
;
typedef
nsClassHashtable
<
ScalarIDHashKey
ScalarBase
>
ScalarStorageMapType
;
typedef
nsClassHashtable
<
ScalarIDHashKey
KeyedScalar
>
KeyedScalarStorageMapType
;
typedef
nsClassHashtable
<
ProcessIDHashKey
ScalarStorageMapType
>
ProcessesScalarsMapType
;
typedef
nsClassHashtable
<
ProcessIDHashKey
KeyedScalarStorageMapType
>
ProcessesKeyedScalarsMapType
;
}
namespace
{
bool
gInitDone
=
false
;
bool
gCanRecordBase
;
bool
gCanRecordExtended
;
ScalarMapType
gScalarNameIDMap
(
kScalarCount
)
;
ProcessesScalarsMapType
gScalarStorageMap
;
ProcessesKeyedScalarsMapType
gKeyedScalarStorageMap
;
}
namespace
{
void
internal_LogScalarError
(
const
nsACString
&
aScalarName
ScalarResult
aSr
)
{
nsAutoString
errorMessage
;
AppendUTF8toUTF16
(
aScalarName
errorMessage
)
;
switch
(
aSr
)
{
case
ScalarResult
:
:
NotInitialized
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Telemetry
was
not
yet
initialized
.
"
)
)
;
break
;
case
ScalarResult
:
:
CannotUnpackVariant
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Cannot
convert
the
provided
JS
value
to
nsIVariant
.
"
)
)
;
break
;
case
ScalarResult
:
:
CannotRecordInProcess
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Cannot
record
the
scalar
in
the
current
process
.
"
)
)
;
break
;
case
ScalarResult
:
:
KeyedTypeMismatch
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Attempting
to
manage
a
keyed
scalar
as
a
scalar
(
or
vice
-
versa
)
.
"
)
)
;
break
;
case
ScalarResult
:
:
UnknownScalar
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Unknown
scalar
.
"
)
)
;
break
;
case
ScalarResult
:
:
OperationNotSupported
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
The
requested
operation
is
not
supported
on
this
scalar
.
"
)
)
;
break
;
case
ScalarResult
:
:
InvalidType
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Attempted
to
set
the
scalar
to
an
invalid
data
type
.
"
)
)
;
break
;
case
ScalarResult
:
:
InvalidValue
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Attempted
to
set
the
scalar
to
an
incompatible
value
.
"
)
)
;
break
;
case
ScalarResult
:
:
StringTooLong
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Truncating
scalar
value
to
50
characters
.
"
)
)
;
break
;
case
ScalarResult
:
:
KeyIsEmpty
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
The
key
must
not
be
empty
.
"
)
)
;
break
;
case
ScalarResult
:
:
KeyTooLong
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
The
key
length
must
be
limited
to
70
characters
.
"
)
)
;
break
;
case
ScalarResult
:
:
TooManyKeys
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Keyed
scalars
cannot
have
more
than
100
keys
.
"
)
)
;
break
;
case
ScalarResult
:
:
UnsignedNegativeValue
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Trying
to
set
an
unsigned
scalar
to
a
negative
number
.
"
)
)
;
break
;
case
ScalarResult
:
:
UnsignedTruncatedValue
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Truncating
float
/
double
number
.
"
)
)
;
break
;
default
:
return
;
}
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
errorMessage
)
;
}
}
namespace
{
bool
internal_CanRecordBase
(
)
{
return
gCanRecordBase
;
}
bool
internal_CanRecordExtended
(
)
{
return
gCanRecordExtended
;
}
const
ScalarInfo
&
internal_InfoForScalarID
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
)
{
return
gScalars
[
static_cast
<
uint32_t
>
(
aId
)
]
;
}
bool
internal_IsKeyedScalar
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
)
{
return
internal_InfoForScalarID
(
aId
)
.
keyed
;
}
bool
internal_CanRecordProcess
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
)
{
const
ScalarInfo
&
info
=
internal_InfoForScalarID
(
aId
)
;
bool
recordAllChild
=
!
!
(
info
.
record_in_processes
&
RecordedProcessType
:
:
AllChilds
)
;
bool
canRecordProcess
=
!
!
(
info
.
record_in_processes
&
static_cast
<
RecordedProcessType
>
(
1
<
<
XRE_GetProcessType
(
)
)
)
;
return
canRecordProcess
|
|
(
!
XRE_IsParentProcess
(
)
&
&
recordAllChild
)
;
}
bool
internal_CanRecordForScalarID
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
)
{
const
ScalarInfo
&
info
=
internal_InfoForScalarID
(
aId
)
;
bool
canRecordBase
=
internal_CanRecordBase
(
)
;
if
(
!
canRecordBase
)
{
return
false
;
}
bool
canRecordDataset
=
CanRecordDataset
(
info
.
dataset
canRecordBase
internal_CanRecordExtended
(
)
)
;
if
(
!
canRecordDataset
)
{
return
false
;
}
return
true
;
}
ScalarResult
internal_CanRecordScalar
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
bool
aKeyed
)
{
if
(
internal_IsKeyedScalar
(
aId
)
!
=
aKeyed
)
{
return
ScalarResult
:
:
KeyedTypeMismatch
;
}
if
(
!
internal_CanRecordForScalarID
(
aId
)
)
{
return
ScalarResult
:
:
CannotRecordDataset
;
}
if
(
!
internal_CanRecordProcess
(
aId
)
)
{
return
ScalarResult
:
:
CannotRecordInProcess
;
}
return
ScalarResult
:
:
Ok
;
}
nsresult
internal_GetEnumByScalarName
(
const
nsACString
&
aName
mozilla
:
:
Telemetry
:
:
ScalarID
*
aId
)
{
if
(
!
gInitDone
)
{
return
NS_ERROR_FAILURE
;
}
CharPtrEntryType
*
entry
=
gScalarNameIDMap
.
GetEntry
(
PromiseFlatCString
(
aName
)
.
get
(
)
)
;
if
(
!
entry
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aId
=
entry
-
>
mData
;
return
NS_OK
;
}
nsresult
internal_GetScalarByEnum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
GeckoProcessType
aProcessStorage
ScalarBase
*
*
aRet
)
{
if
(
!
IsValidEnumId
(
aId
)
)
{
MOZ_ASSERT
(
false
"
Requested
a
scalar
with
an
invalid
id
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
const
uint32_t
id
=
static_cast
<
uint32_t
>
(
aId
)
;
const
ScalarInfo
&
info
=
gScalars
[
id
]
;
ScalarBase
*
scalar
=
nullptr
;
ScalarStorageMapType
*
scalarStorage
=
nullptr
;
uint32_t
storageId
=
static_cast
<
uint32_t
>
(
aProcessStorage
)
;
if
(
!
gScalarStorageMap
.
Get
(
storageId
&
scalarStorage
)
)
{
scalarStorage
=
new
ScalarStorageMapType
(
)
;
gScalarStorageMap
.
Put
(
storageId
scalarStorage
)
;
}
if
(
scalarStorage
-
>
Get
(
id
&
scalar
)
)
{
*
aRet
=
scalar
;
return
NS_OK
;
}
if
(
IsExpiredVersion
(
info
.
expiration
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
scalar
=
internal_ScalarAllocate
(
info
.
kind
)
;
if
(
!
scalar
)
{
return
NS_ERROR_INVALID_ARG
;
}
scalarStorage
-
>
Put
(
id
scalar
)
;
*
aRet
=
scalar
;
return
NS_OK
;
}
ScalarResult
internal_UpdateScalar
(
const
nsACString
&
aName
ScalarActionType
aType
nsIVariant
*
aValue
)
{
mozilla
:
:
Telemetry
:
:
ScalarID
id
;
nsresult
rv
=
internal_GetEnumByScalarName
(
aName
&
id
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
(
rv
=
=
NS_ERROR_FAILURE
)
?
ScalarResult
:
:
NotInitialized
:
ScalarResult
:
:
UnknownScalar
;
}
ScalarResult
sr
=
internal_CanRecordScalar
(
id
false
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
=
=
ScalarResult
:
:
CannotRecordDataset
)
{
return
ScalarResult
:
:
Ok
;
}
return
sr
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
const
ScalarInfo
&
info
=
gScalars
[
static_cast
<
uint32_t
>
(
id
)
]
;
mozilla
:
:
Maybe
<
ScalarVariant
>
variantValue
;
sr
=
GetVariantFromIVariant
(
aValue
info
.
kind
variantValue
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Unable
to
convert
nsIVariant
to
mozilla
:
:
Variant
.
"
)
;
return
sr
;
}
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
id
aType
variantValue
.
ref
(
)
)
;
return
ScalarResult
:
:
Ok
;
}
ScalarBase
*
scalar
=
nullptr
;
rv
=
internal_GetScalarByEnum
(
id
GeckoProcessType_Default
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
ScalarResult
:
:
Ok
;
}
return
ScalarResult
:
:
UnknownScalar
;
}
if
(
aType
=
=
ScalarActionType
:
:
eAdd
)
{
return
scalar
-
>
AddValue
(
aValue
)
;
}
else
if
(
aType
=
=
ScalarActionType
:
:
eSet
)
{
return
scalar
-
>
SetValue
(
aValue
)
;
}
return
scalar
-
>
SetMaximum
(
aValue
)
;
}
}
namespace
{
nsresult
internal_GetKeyedScalarByEnum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
GeckoProcessType
aProcessStorage
KeyedScalar
*
*
aRet
)
{
if
(
!
IsValidEnumId
(
aId
)
)
{
MOZ_ASSERT
(
false
"
Requested
a
keyed
scalar
with
an
invalid
id
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
const
uint32_t
id
=
static_cast
<
uint32_t
>
(
aId
)
;
const
ScalarInfo
&
info
=
gScalars
[
id
]
;
KeyedScalar
*
scalar
=
nullptr
;
KeyedScalarStorageMapType
*
scalarStorage
=
nullptr
;
uint32_t
storageId
=
static_cast
<
uint32_t
>
(
aProcessStorage
)
;
if
(
!
gKeyedScalarStorageMap
.
Get
(
storageId
&
scalarStorage
)
)
{
scalarStorage
=
new
KeyedScalarStorageMapType
(
)
;
gKeyedScalarStorageMap
.
Put
(
storageId
scalarStorage
)
;
}
if
(
scalarStorage
-
>
Get
(
id
&
scalar
)
)
{
*
aRet
=
scalar
;
return
NS_OK
;
}
if
(
IsExpiredVersion
(
info
.
expiration
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
info
.
kind
=
=
nsITelemetry
:
:
SCALAR_STRING
)
{
MOZ_ASSERT
(
false
"
Keyed
string
scalars
are
not
currently
supported
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
scalar
=
new
KeyedScalar
(
info
.
kind
)
;
if
(
!
scalar
)
{
return
NS_ERROR_INVALID_ARG
;
}
scalarStorage
-
>
Put
(
id
scalar
)
;
*
aRet
=
scalar
;
return
NS_OK
;
}
ScalarResult
internal_UpdateKeyedScalar
(
const
nsACString
&
aName
const
nsAString
&
aKey
ScalarActionType
aType
nsIVariant
*
aValue
)
{
mozilla
:
:
Telemetry
:
:
ScalarID
id
;
nsresult
rv
=
internal_GetEnumByScalarName
(
aName
&
id
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
(
rv
=
=
NS_ERROR_FAILURE
)
?
ScalarResult
:
:
NotInitialized
:
ScalarResult
:
:
UnknownScalar
;
}
ScalarResult
sr
=
internal_CanRecordScalar
(
id
true
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
if
(
sr
=
=
ScalarResult
:
:
CannotRecordDataset
)
{
return
ScalarResult
:
:
Ok
;
}
return
sr
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
const
ScalarInfo
&
info
=
gScalars
[
static_cast
<
uint32_t
>
(
id
)
]
;
mozilla
:
:
Maybe
<
ScalarVariant
>
variantValue
;
sr
=
GetVariantFromIVariant
(
aValue
info
.
kind
variantValue
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Unable
to
convert
nsIVariant
to
mozilla
:
:
Variant
.
"
)
;
return
sr
;
}
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
id
aKey
aType
variantValue
.
ref
(
)
)
;
return
ScalarResult
:
:
Ok
;
}
KeyedScalar
*
scalar
=
nullptr
;
rv
=
internal_GetKeyedScalarByEnum
(
id
GeckoProcessType_Default
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
ScalarResult
:
:
Ok
;
}
return
ScalarResult
:
:
UnknownScalar
;
}
if
(
aType
=
=
ScalarActionType
:
:
eAdd
)
{
return
scalar
-
>
AddValue
(
aKey
aValue
)
;
}
else
if
(
aType
=
=
ScalarActionType
:
:
eSet
)
{
return
scalar
-
>
SetValue
(
aKey
aValue
)
;
}
return
scalar
-
>
SetMaximum
(
aKey
aValue
)
;
}
}
static
StaticMutex
gTelemetryScalarsMutex
;
void
TelemetryScalar
:
:
InitializeGlobalState
(
bool
aCanRecordBase
bool
aCanRecordExtended
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
MOZ_ASSERT
(
!
gInitDone
"
TelemetryScalar
:
:
InitializeGlobalState
"
"
may
only
be
called
once
"
)
;
gCanRecordBase
=
aCanRecordBase
;
gCanRecordExtended
=
aCanRecordExtended
;
uint32_t
scalarCount
=
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
ScalarCount
)
;
for
(
uint32_t
i
=
0
;
i
<
scalarCount
;
i
+
+
)
{
CharPtrEntryType
*
entry
=
gScalarNameIDMap
.
PutEntry
(
gScalars
[
i
]
.
name
(
)
)
;
entry
-
>
mData
=
static_cast
<
mozilla
:
:
Telemetry
:
:
ScalarID
>
(
i
)
;
}
#
ifdef
DEBUG
gScalarNameIDMap
.
MarkImmutable
(
)
;
#
endif
gInitDone
=
true
;
}
void
TelemetryScalar
:
:
DeInitializeGlobalState
(
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gCanRecordBase
=
false
;
gCanRecordExtended
=
false
;
gScalarNameIDMap
.
Clear
(
)
;
gScalarStorageMap
.
Clear
(
)
;
gKeyedScalarStorageMap
.
Clear
(
)
;
gInitDone
=
false
;
}
void
TelemetryScalar
:
:
SetCanRecordBase
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gCanRecordBase
=
b
;
}
void
TelemetryScalar
:
:
SetCanRecordExtended
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gCanRecordExtended
=
b
;
}
nsresult
TelemetryScalar
:
:
Add
(
const
nsACString
&
aName
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateScalar
(
aName
ScalarActionType
:
:
eAdd
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
Add
(
const
nsACString
&
aName
const
nsAString
&
aKey
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateKeyedScalar
(
aName
aKey
ScalarActionType
:
:
eAdd
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
void
TelemetryScalar
:
:
Add
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
aId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
aId
ScalarActionType
:
:
eAdd
ScalarVariant
(
aValue
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
aId
GeckoProcessType_Default
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
AddValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Add
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
aId
true
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
aId
aKey
ScalarActionType
:
:
eAdd
ScalarVariant
(
aValue
)
)
;
return
;
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
aId
GeckoProcessType_Default
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
AddValue
(
aKey
aValue
)
;
}
nsresult
TelemetryScalar
:
:
Set
(
const
nsACString
&
aName
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateScalar
(
aName
ScalarActionType
:
:
eSet
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
Set
(
const
nsACString
&
aName
const
nsAString
&
aKey
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateKeyedScalar
(
aName
aKey
ScalarActionType
:
:
eSet
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
aId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
aId
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
aId
GeckoProcessType_Default
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
aId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
aId
ScalarActionType
:
:
eSet
ScalarVariant
(
nsString
(
aValue
)
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
aId
GeckoProcessType_Default
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
bool
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
aId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
aId
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
aId
GeckoProcessType_Default
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
aId
true
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
aId
aKey
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
aId
GeckoProcessType_Default
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
aKey
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
bool
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
aId
true
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
aId
aKey
ScalarActionType
:
:
eSet
ScalarVariant
(
aValue
)
)
;
return
;
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
aId
GeckoProcessType_Default
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetValue
(
aKey
aValue
)
;
}
nsresult
TelemetryScalar
:
:
SetMaximum
(
const
nsACString
&
aName
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateScalar
(
aName
ScalarActionType
:
:
eSetMaximum
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
SetMaximum
(
const
nsACString
&
aName
const
nsAString
&
aKey
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
internal_LogScalarError
(
aName
ScalarResult
:
:
CannotUnpackVariant
)
;
return
NS_OK
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
sr
=
internal_UpdateKeyedScalar
(
aName
aKey
ScalarActionType
:
:
eSetMaximum
unpackedVal
)
;
}
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
NS_OK
;
}
void
TelemetryScalar
:
:
SetMaximum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
aId
false
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildScalarAction
(
aId
ScalarActionType
:
:
eSetMaximum
ScalarVariant
(
aValue
)
)
;
return
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
aId
GeckoProcessType_Default
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetMaximum
(
aValue
)
;
}
void
TelemetryScalar
:
:
SetMaximum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
internal_CanRecordScalar
(
aId
true
)
!
=
ScalarResult
:
:
Ok
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TelemetryIPCAccumulator
:
:
RecordChildKeyedScalarAction
(
aId
aKey
ScalarActionType
:
:
eSetMaximum
ScalarVariant
(
aValue
)
)
;
return
;
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
aId
GeckoProcessType_Default
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
scalar
-
>
SetMaximum
(
aKey
aValue
)
;
}
nsresult
TelemetryScalar
:
:
CreateSnapshots
(
unsigned
int
aDataset
bool
aClearScalars
JSContext
*
aCx
uint8_t
optional_argc
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Snapshotting
scalars
should
only
happen
in
the
parent
processes
.
"
)
;
if
(
!
optional_argc
)
{
aClearScalars
=
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
root_obj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
root_obj
)
{
return
NS_ERROR_FAILURE
;
}
aResult
.
setObject
(
*
root_obj
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_OK
;
}
typedef
mozilla
:
:
Pair
<
const
char
*
nsCOMPtr
<
nsIVariant
>
>
DataPair
;
typedef
nsTArray
<
DataPair
>
ScalarArray
;
nsDataHashtable
<
ProcessIDHashKey
ScalarArray
>
scalarsToReflect
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
for
(
auto
iter
=
gScalarStorageMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarStorageMapType
*
scalarStorage
=
static_cast
<
ScalarStorageMapType
*
>
(
iter
.
Data
(
)
)
;
ScalarArray
&
processScalars
=
scalarsToReflect
.
GetOrInsert
(
iter
.
Key
(
)
)
;
for
(
auto
childIter
=
scalarStorage
-
>
Iter
(
)
;
!
childIter
.
Done
(
)
;
childIter
.
Next
(
)
)
{
ScalarBase
*
scalar
=
static_cast
<
ScalarBase
*
>
(
childIter
.
Data
(
)
)
;
const
ScalarInfo
&
info
=
gScalars
[
childIter
.
Key
(
)
]
;
if
(
IsInDataset
(
info
.
dataset
aDataset
)
)
{
nsCOMPtr
<
nsIVariant
>
scalarValue
;
nsresult
rv
=
scalar
-
>
GetValue
(
scalarValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
processScalars
.
AppendElement
(
mozilla
:
:
MakePair
(
info
.
name
(
)
scalarValue
)
)
;
}
}
}
if
(
aClearScalars
)
{
gScalarStorageMap
.
Clear
(
)
;
}
}
for
(
auto
iter
=
scalarsToReflect
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarArray
&
processScalars
=
iter
.
Data
(
)
;
const
char
*
processName
=
XRE_ChildProcessTypeToString
(
static_cast
<
GeckoProcessType
>
(
iter
.
Key
(
)
)
)
;
JS
:
:
RootedObject
processObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
processObj
|
|
!
JS_DefineProperty
(
aCx
root_obj
processName
processObj
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
nsTArray
<
DataPair
>
:
:
size_type
i
=
0
;
i
<
processScalars
.
Length
(
)
;
i
+
+
)
{
const
DataPair
&
scalar
=
processScalars
[
i
]
;
JS
:
:
Rooted
<
JS
:
:
Value
>
scalarJsValue
(
aCx
)
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
VariantToJS
(
aCx
processObj
scalar
.
second
(
)
&
scalarJsValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
JS_DefineProperty
(
aCx
processObj
scalar
.
first
(
)
scalarJsValue
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
CreateKeyedSnapshots
(
unsigned
int
aDataset
bool
aClearScalars
JSContext
*
aCx
uint8_t
optional_argc
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Snapshotting
scalars
should
only
happen
in
the
parent
processes
.
"
)
;
if
(
!
optional_argc
)
{
aClearScalars
=
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
root_obj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
root_obj
)
{
return
NS_ERROR_FAILURE
;
}
aResult
.
setObject
(
*
root_obj
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_OK
;
}
typedef
mozilla
:
:
Pair
<
const
char
*
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
>
DataPair
;
typedef
nsTArray
<
DataPair
>
ScalarArray
;
nsDataHashtable
<
ProcessIDHashKey
ScalarArray
>
scalarsToReflect
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
for
(
auto
iter
=
gKeyedScalarStorageMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
KeyedScalarStorageMapType
*
scalarStorage
=
static_cast
<
KeyedScalarStorageMapType
*
>
(
iter
.
Data
(
)
)
;
ScalarArray
&
processScalars
=
scalarsToReflect
.
GetOrInsert
(
iter
.
Key
(
)
)
;
for
(
auto
childIter
=
scalarStorage
-
>
Iter
(
)
;
!
childIter
.
Done
(
)
;
childIter
.
Next
(
)
)
{
KeyedScalar
*
scalar
=
static_cast
<
KeyedScalar
*
>
(
childIter
.
Data
(
)
)
;
const
ScalarInfo
&
info
=
gScalars
[
childIter
.
Key
(
)
]
;
if
(
IsInDataset
(
info
.
dataset
aDataset
)
)
{
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
scalarKeyedData
;
nsresult
rv
=
scalar
-
>
GetValue
(
scalarKeyedData
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
processScalars
.
AppendElement
(
mozilla
:
:
MakePair
(
info
.
name
(
)
scalarKeyedData
)
)
;
}
}
}
if
(
aClearScalars
)
{
gKeyedScalarStorageMap
.
Clear
(
)
;
}
}
for
(
auto
iter
=
scalarsToReflect
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarArray
&
processScalars
=
iter
.
Data
(
)
;
const
char
*
processName
=
XRE_ChildProcessTypeToString
(
static_cast
<
GeckoProcessType
>
(
iter
.
Key
(
)
)
)
;
JS
:
:
RootedObject
processObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
processObj
|
|
!
JS_DefineProperty
(
aCx
root_obj
processName
processObj
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
nsTArray
<
DataPair
>
:
:
size_type
i
=
0
;
i
<
processScalars
.
Length
(
)
;
i
+
+
)
{
const
DataPair
&
keyedScalarData
=
processScalars
[
i
]
;
JS
:
:
RootedObject
keyedScalarObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
const
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
&
keyProps
=
keyedScalarData
.
second
(
)
;
for
(
uint32_t
i
=
0
;
i
<
keyProps
.
Length
(
)
;
i
+
+
)
{
const
KeyedScalar
:
:
KeyValuePair
&
keyData
=
keyProps
[
i
]
;
JS
:
:
Rooted
<
JS
:
:
Value
>
keyJsValue
(
aCx
)
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
VariantToJS
(
aCx
keyedScalarObj
keyData
.
second
(
)
&
keyJsValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
const
NS_ConvertUTF8toUTF16
key
(
keyData
.
first
(
)
)
;
if
(
!
JS_DefineUCProperty
(
aCx
keyedScalarObj
key
.
Data
(
)
key
.
Length
(
)
keyJsValue
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
!
JS_DefineProperty
(
aCx
processObj
keyedScalarData
.
first
(
)
keyedScalarObj
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
return
NS_OK
;
}
void
TelemetryScalar
:
:
ClearScalars
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Scalars
should
only
be
cleared
in
the
parent
process
.
"
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gScalarStorageMap
.
Clear
(
)
;
gKeyedScalarStorageMap
.
Clear
(
)
;
}
size_t
TelemetryScalar
:
:
GetMapShallowSizesOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
return
gScalarNameIDMap
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
TelemetryScalar
:
:
GetScalarSizesOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
size_t
n
=
0
;
for
(
auto
iter
=
gScalarStorageMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarStorageMapType
*
scalarStorage
=
static_cast
<
ScalarStorageMapType
*
>
(
iter
.
Data
(
)
)
;
for
(
auto
childIter
=
scalarStorage
-
>
Iter
(
)
;
!
childIter
.
Done
(
)
;
childIter
.
Next
(
)
)
{
ScalarBase
*
scalar
=
static_cast
<
ScalarBase
*
>
(
childIter
.
Data
(
)
)
;
n
+
=
scalar
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
for
(
auto
iter
=
gKeyedScalarStorageMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
KeyedScalarStorageMapType
*
scalarStorage
=
static_cast
<
KeyedScalarStorageMapType
*
>
(
iter
.
Data
(
)
)
;
for
(
auto
childIter
=
scalarStorage
-
>
Iter
(
)
;
!
childIter
.
Done
(
)
;
childIter
.
Next
(
)
)
{
KeyedScalar
*
scalar
=
static_cast
<
KeyedScalar
*
>
(
childIter
.
Data
(
)
)
;
n
+
=
scalar
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
return
n
;
}
void
TelemetryScalar
:
:
UpdateChildData
(
GeckoProcessType
aProcessType
const
nsTArray
<
mozilla
:
:
Telemetry
:
:
ScalarAction
>
&
aScalarActions
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
The
stored
child
processes
scalar
data
must
be
updated
from
the
parent
process
.
"
)
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
!
internal_CanRecordBase
(
)
)
{
return
;
}
for
(
auto
&
upd
:
aScalarActions
)
{
if
(
internal_IsKeyedScalar
(
upd
.
mId
)
)
{
continue
;
}
if
(
!
internal_CanRecordForScalarID
(
upd
.
mId
)
)
{
continue
;
}
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
upd
.
mId
aProcessType
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
NS_FAILED
internal_GetScalarByEnum
for
CHILD
"
)
;
continue
;
}
if
(
upd
.
mData
.
isNothing
(
)
)
{
MOZ_ASSERT
(
false
"
There
is
no
data
in
the
ScalarActionType
.
"
)
;
continue
;
}
const
uint32_t
scalarType
=
gScalars
[
static_cast
<
uint32_t
>
(
upd
.
mId
)
]
.
kind
;
switch
(
upd
.
mActionType
)
{
case
ScalarActionType
:
:
eSet
:
{
switch
(
scalarType
)
{
case
nsITelemetry
:
:
SCALAR_COUNT
:
scalar
-
>
SetValue
(
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
case
nsITelemetry
:
:
SCALAR_BOOLEAN
:
scalar
-
>
SetValue
(
upd
.
mData
-
>
as
<
bool
>
(
)
)
;
break
;
case
nsITelemetry
:
:
SCALAR_STRING
:
scalar
-
>
SetValue
(
upd
.
mData
-
>
as
<
nsString
>
(
)
)
;
break
;
}
break
;
}
case
ScalarActionType
:
:
eAdd
:
{
if
(
scalarType
!
=
nsITelemetry
:
:
SCALAR_COUNT
)
{
NS_WARNING
(
"
Attempting
to
add
on
a
non
count
scalar
.
"
)
;
continue
;
}
scalar
-
>
AddValue
(
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
}
case
ScalarActionType
:
:
eSetMaximum
:
{
if
(
scalarType
!
=
nsITelemetry
:
:
SCALAR_COUNT
)
{
NS_WARNING
(
"
Attempting
to
add
on
a
non
count
scalar
.
"
)
;
continue
;
}
scalar
-
>
SetMaximum
(
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
}
default
:
NS_WARNING
(
"
Unsupported
action
coming
from
scalar
child
updates
.
"
)
;
}
}
}
void
TelemetryScalar
:
:
UpdateChildKeyedData
(
GeckoProcessType
aProcessType
const
nsTArray
<
mozilla
:
:
Telemetry
:
:
KeyedScalarAction
>
&
aScalarActions
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
The
stored
child
processes
keyed
scalar
data
must
be
updated
from
the
parent
process
.
"
)
;
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
if
(
!
internal_CanRecordBase
(
)
)
{
return
;
}
for
(
auto
&
upd
:
aScalarActions
)
{
if
(
!
internal_IsKeyedScalar
(
upd
.
mId
)
)
{
continue
;
}
if
(
!
internal_CanRecordForScalarID
(
upd
.
mId
)
)
{
continue
;
}
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
upd
.
mId
aProcessType
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
NS_FAILED
internal_GetScalarByEnum
for
CHILD
"
)
;
continue
;
}
if
(
upd
.
mData
.
isNothing
(
)
)
{
MOZ_ASSERT
(
false
"
There
is
no
data
in
the
KeyedScalarAction
.
"
)
;
continue
;
}
const
uint32_t
scalarType
=
gScalars
[
static_cast
<
uint32_t
>
(
upd
.
mId
)
]
.
kind
;
switch
(
upd
.
mActionType
)
{
case
ScalarActionType
:
:
eSet
:
{
switch
(
scalarType
)
{
case
nsITelemetry
:
:
SCALAR_COUNT
:
scalar
-
>
SetValue
(
NS_ConvertUTF8toUTF16
(
upd
.
mKey
)
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
case
nsITelemetry
:
:
SCALAR_BOOLEAN
:
scalar
-
>
SetValue
(
NS_ConvertUTF8toUTF16
(
upd
.
mKey
)
upd
.
mData
-
>
as
<
bool
>
(
)
)
;
break
;
default
:
NS_WARNING
(
"
Unsupported
type
coming
from
scalar
child
updates
.
"
)
;
}
break
;
}
case
ScalarActionType
:
:
eAdd
:
{
if
(
scalarType
!
=
nsITelemetry
:
:
SCALAR_COUNT
)
{
NS_WARNING
(
"
Attempting
to
add
on
a
non
count
scalar
.
"
)
;
continue
;
}
scalar
-
>
AddValue
(
NS_ConvertUTF8toUTF16
(
upd
.
mKey
)
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
}
case
ScalarActionType
:
:
eSetMaximum
:
{
if
(
scalarType
!
=
nsITelemetry
:
:
SCALAR_COUNT
)
{
NS_WARNING
(
"
Attempting
to
add
on
a
non
count
scalar
.
"
)
;
continue
;
}
scalar
-
>
SetMaximum
(
NS_ConvertUTF8toUTF16
(
upd
.
mKey
)
upd
.
mData
-
>
as
<
uint32_t
>
(
)
)
;
break
;
}
default
:
NS_WARNING
(
"
Unsupported
action
coming
from
keyed
scalar
child
updates
.
"
)
;
}
}
}
