#
include
"
nsITelemetry
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
TelemetryCommon
.
h
"
#
include
"
TelemetryScalar
.
h
"
#
include
"
TelemetryScalarData
.
h
"
using
mozilla
:
:
StaticMutex
;
using
mozilla
:
:
StaticMutexAutoLock
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
AutoHashtable
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsExpiredVersion
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
CanRecordDataset
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsInDataset
;
namespace
{
const
uint32_t
kMaximumNumberOfKeys
=
100
;
const
uint32_t
kMaximumKeyStringLength
=
70
;
const
uint32_t
kMaximumStringValueLength
=
50
;
const
uint32_t
kScalarCount
=
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
ScalarCount
)
;
enum
class
ScalarResult
:
uint8_t
{
Ok
OperationNotSupported
InvalidType
InvalidValue
KeyTooLong
TooManyKeys
StringTooLong
UnsignedNegativeValue
UnsignedTruncatedValue
}
;
typedef
nsBaseHashtableET
<
nsDepCharHashKey
mozilla
:
:
Telemetry
:
:
ScalarID
>
CharPtrEntryType
;
typedef
AutoHashtable
<
CharPtrEntryType
>
ScalarMapType
;
nsresult
MapToNsResult
(
ScalarResult
aSr
)
{
switch
(
aSr
)
{
case
ScalarResult
:
:
Ok
:
return
NS_OK
;
case
ScalarResult
:
:
OperationNotSupported
:
return
NS_ERROR_NOT_AVAILABLE
;
case
ScalarResult
:
:
StringTooLong
:
return
NS_OK
;
case
ScalarResult
:
:
InvalidType
:
case
ScalarResult
:
:
InvalidValue
:
case
ScalarResult
:
:
KeyTooLong
:
return
NS_ERROR_ILLEGAL_VALUE
;
case
ScalarResult
:
:
TooManyKeys
:
return
NS_ERROR_FAILURE
;
case
ScalarResult
:
:
UnsignedNegativeValue
:
case
ScalarResult
:
:
UnsignedTruncatedValue
:
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
bool
IsValidEnumId
(
mozilla
:
:
Telemetry
:
:
ScalarID
aID
)
{
return
aID
<
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
ScalarCount
;
}
const
char
*
ScalarInfo
:
:
name
(
)
const
{
return
&
gScalarsStringTable
[
this
-
>
name_offset
]
;
}
const
char
*
ScalarInfo
:
:
expiration
(
)
const
{
return
&
gScalarsStringTable
[
this
-
>
expiration_offset
]
;
}
class
ScalarBase
{
public
:
virtual
~
ScalarBase
(
)
{
}
;
virtual
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
=
0
;
virtual
ScalarResult
AddValue
(
nsIVariant
*
aValue
)
{
return
ScalarResult
:
:
OperationNotSupported
;
}
virtual
ScalarResult
SetMaximum
(
nsIVariant
*
aValue
)
{
return
ScalarResult
:
:
OperationNotSupported
;
}
virtual
void
SetValue
(
uint32_t
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
ScalarResult
SetValue
(
const
nsAString
&
aValue
)
{
return
HandleUnsupported
(
)
;
}
virtual
void
SetValue
(
bool
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
void
AddValue
(
uint32_t
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
void
SetMaximum
(
uint32_t
aValue
)
{
mozilla
:
:
Unused
<
<
HandleUnsupported
(
)
;
}
virtual
nsresult
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
=
0
;
virtual
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
=
0
;
private
:
ScalarResult
HandleUnsupported
(
)
const
;
}
;
ScalarResult
ScalarBase
:
:
HandleUnsupported
(
)
const
{
MOZ_ASSERT
(
false
"
This
operation
is
not
support
for
this
scalar
type
.
"
)
;
return
ScalarResult
:
:
OperationNotSupported
;
}
class
ScalarUnsigned
:
public
ScalarBase
{
public
:
using
ScalarBase
:
:
SetValue
;
ScalarUnsigned
(
)
:
mStorage
(
0
)
{
}
;
~
ScalarUnsigned
(
)
{
}
;
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
final
;
void
SetValue
(
uint32_t
aValue
)
final
;
ScalarResult
AddValue
(
nsIVariant
*
aValue
)
final
;
void
AddValue
(
uint32_t
aValue
)
final
;
ScalarResult
SetMaximum
(
nsIVariant
*
aValue
)
final
;
void
SetMaximum
(
uint32_t
aValue
)
final
;
nsresult
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
final
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
final
;
private
:
uint32_t
mStorage
;
ScalarResult
CheckInput
(
nsIVariant
*
aValue
)
;
ScalarUnsigned
(
const
ScalarUnsigned
&
aOther
)
=
delete
;
void
operator
=
(
const
ScalarUnsigned
&
aOther
)
=
delete
;
}
;
ScalarResult
ScalarUnsigned
:
:
SetValue
(
nsIVariant
*
aValue
)
{
ScalarResult
sr
=
CheckInput
(
aValue
)
;
if
(
sr
=
=
ScalarResult
:
:
UnsignedNegativeValue
)
{
return
sr
;
}
if
(
NS_FAILED
(
aValue
-
>
GetAsUint32
(
&
mStorage
)
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
return
sr
;
}
void
ScalarUnsigned
:
:
SetValue
(
uint32_t
aValue
)
{
mStorage
=
aValue
;
}
ScalarResult
ScalarUnsigned
:
:
AddValue
(
nsIVariant
*
aValue
)
{
ScalarResult
sr
=
CheckInput
(
aValue
)
;
if
(
sr
=
=
ScalarResult
:
:
UnsignedNegativeValue
)
{
return
sr
;
}
uint32_t
newAddend
=
0
;
nsresult
rv
=
aValue
-
>
GetAsUint32
(
&
newAddend
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
mStorage
+
=
newAddend
;
return
sr
;
}
void
ScalarUnsigned
:
:
AddValue
(
uint32_t
aValue
)
{
mStorage
+
=
aValue
;
}
ScalarResult
ScalarUnsigned
:
:
SetMaximum
(
nsIVariant
*
aValue
)
{
ScalarResult
sr
=
CheckInput
(
aValue
)
;
if
(
sr
=
=
ScalarResult
:
:
UnsignedNegativeValue
)
{
return
sr
;
}
uint32_t
newValue
=
0
;
nsresult
rv
=
aValue
-
>
GetAsUint32
(
&
newValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
if
(
newValue
>
mStorage
)
{
mStorage
=
newValue
;
}
return
sr
;
}
void
ScalarUnsigned
:
:
SetMaximum
(
uint32_t
aValue
)
{
if
(
aValue
>
mStorage
)
{
mStorage
=
aValue
;
}
}
nsresult
ScalarUnsigned
:
:
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
{
nsCOMPtr
<
nsIWritableVariant
>
outVar
(
new
nsVariant
(
)
)
;
nsresult
rv
=
outVar
-
>
SetAsUint32
(
mStorage
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aResult
=
outVar
.
forget
(
)
;
return
NS_OK
;
}
size_t
ScalarUnsigned
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
;
}
ScalarResult
ScalarUnsigned
:
:
CheckInput
(
nsIVariant
*
aValue
)
{
uint16_t
type
;
aValue
-
>
GetDataType
(
&
type
)
;
if
(
type
=
=
nsIDataType
:
:
VTYPE_FLOAT
|
|
type
=
=
nsIDataType
:
:
VTYPE_DOUBLE
)
{
return
ScalarResult
:
:
UnsignedTruncatedValue
;
}
int32_t
signedTest
;
if
(
NS_SUCCEEDED
(
aValue
-
>
GetAsInt32
(
&
signedTest
)
)
&
&
signedTest
<
0
)
{
return
ScalarResult
:
:
UnsignedNegativeValue
;
}
return
ScalarResult
:
:
Ok
;
}
class
ScalarString
:
public
ScalarBase
{
public
:
using
ScalarBase
:
:
SetValue
;
ScalarString
(
)
:
mStorage
(
EmptyString
(
)
)
{
}
;
~
ScalarString
(
)
{
}
;
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
final
;
ScalarResult
SetValue
(
const
nsAString
&
aValue
)
final
;
nsresult
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
final
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
final
;
private
:
nsString
mStorage
;
ScalarString
(
const
ScalarString
&
aOther
)
=
delete
;
void
operator
=
(
const
ScalarString
&
aOther
)
=
delete
;
}
;
ScalarResult
ScalarString
:
:
SetValue
(
nsIVariant
*
aValue
)
{
uint16_t
type
;
aValue
-
>
GetDataType
(
&
type
)
;
if
(
type
!
=
nsIDataType
:
:
VTYPE_CHAR
&
&
type
!
=
nsIDataType
:
:
VTYPE_WCHAR
&
&
type
!
=
nsIDataType
:
:
VTYPE_DOMSTRING
&
&
type
!
=
nsIDataType
:
:
VTYPE_CHAR_STR
&
&
type
!
=
nsIDataType
:
:
VTYPE_WCHAR_STR
&
&
type
!
=
nsIDataType
:
:
VTYPE_STRING_SIZE_IS
&
&
type
!
=
nsIDataType
:
:
VTYPE_WSTRING_SIZE_IS
&
&
type
!
=
nsIDataType
:
:
VTYPE_UTF8STRING
&
&
type
!
=
nsIDataType
:
:
VTYPE_CSTRING
&
&
type
!
=
nsIDataType
:
:
VTYPE_ASTRING
)
{
return
ScalarResult
:
:
InvalidType
;
}
nsAutoString
convertedString
;
nsresult
rv
=
aValue
-
>
GetAsAString
(
convertedString
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
return
SetValue
(
convertedString
)
;
}
;
ScalarResult
ScalarString
:
:
SetValue
(
const
nsAString
&
aValue
)
{
mStorage
=
Substring
(
aValue
0
kMaximumStringValueLength
)
;
if
(
aValue
.
Length
(
)
>
kMaximumStringValueLength
)
{
return
ScalarResult
:
:
StringTooLong
;
}
return
ScalarResult
:
:
Ok
;
}
nsresult
ScalarString
:
:
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
{
nsCOMPtr
<
nsIWritableVariant
>
outVar
(
new
nsVariant
(
)
)
;
nsresult
rv
=
outVar
-
>
SetAsAString
(
mStorage
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aResult
=
outVar
.
forget
(
)
;
return
NS_OK
;
}
size_t
ScalarString
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mStorage
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
return
n
;
}
class
ScalarBoolean
:
public
ScalarBase
{
public
:
using
ScalarBase
:
:
SetValue
;
ScalarBoolean
(
)
:
mStorage
(
false
)
{
}
;
~
ScalarBoolean
(
)
{
}
;
ScalarResult
SetValue
(
nsIVariant
*
aValue
)
final
;
void
SetValue
(
bool
aValue
)
final
;
nsresult
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
final
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
final
;
private
:
bool
mStorage
;
ScalarBoolean
(
const
ScalarBoolean
&
aOther
)
=
delete
;
void
operator
=
(
const
ScalarBoolean
&
aOther
)
=
delete
;
}
;
ScalarResult
ScalarBoolean
:
:
SetValue
(
nsIVariant
*
aValue
)
{
uint16_t
type
;
aValue
-
>
GetDataType
(
&
type
)
;
if
(
type
!
=
nsIDataType
:
:
VTYPE_BOOL
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT8
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT16
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT32
&
&
type
!
=
nsIDataType
:
:
VTYPE_INT64
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT8
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT16
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT32
&
&
type
!
=
nsIDataType
:
:
VTYPE_UINT64
)
{
return
ScalarResult
:
:
InvalidType
;
}
if
(
NS_FAILED
(
aValue
-
>
GetAsBool
(
&
mStorage
)
)
)
{
return
ScalarResult
:
:
InvalidValue
;
}
return
ScalarResult
:
:
Ok
;
}
;
void
ScalarBoolean
:
:
SetValue
(
bool
aValue
)
{
mStorage
=
aValue
;
}
nsresult
ScalarBoolean
:
:
GetValue
(
nsCOMPtr
<
nsIVariant
>
&
aResult
)
const
{
nsCOMPtr
<
nsIWritableVariant
>
outVar
(
new
nsVariant
(
)
)
;
nsresult
rv
=
outVar
-
>
SetAsBool
(
mStorage
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aResult
=
outVar
.
forget
(
)
;
return
NS_OK
;
}
size_t
ScalarBoolean
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
;
}
ScalarBase
*
internal_ScalarAllocate
(
uint32_t
aScalarKind
)
{
ScalarBase
*
scalar
=
nullptr
;
switch
(
aScalarKind
)
{
case
nsITelemetry
:
:
SCALAR_COUNT
:
scalar
=
new
ScalarUnsigned
(
)
;
break
;
case
nsITelemetry
:
:
SCALAR_STRING
:
scalar
=
new
ScalarString
(
)
;
break
;
case
nsITelemetry
:
:
SCALAR_BOOLEAN
:
scalar
=
new
ScalarBoolean
(
)
;
break
;
default
:
MOZ_ASSERT
(
false
"
Invalid
scalar
type
"
)
;
}
return
scalar
;
}
class
KeyedScalar
{
public
:
typedef
mozilla
:
:
Pair
<
nsCString
nsCOMPtr
<
nsIVariant
>
>
KeyValuePair
;
explicit
KeyedScalar
(
uint32_t
aScalarKind
)
:
mScalarKind
(
aScalarKind
)
{
}
;
~
KeyedScalar
(
)
{
}
;
ScalarResult
SetValue
(
const
nsAString
&
aKey
nsIVariant
*
aValue
)
;
ScalarResult
AddValue
(
const
nsAString
&
aKey
nsIVariant
*
aValue
)
;
ScalarResult
SetMaximum
(
const
nsAString
&
aKey
nsIVariant
*
aValue
)
;
void
SetValue
(
const
nsAString
&
aKey
uint32_t
aValue
)
;
void
SetValue
(
const
nsAString
&
aKey
bool
aValue
)
;
void
AddValue
(
const
nsAString
&
aKey
uint32_t
aValue
)
;
void
SetMaximum
(
const
nsAString
&
aKey
uint32_t
aValue
)
;
nsresult
GetValue
(
nsTArray
<
KeyValuePair
>
&
aValues
)
const
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
;
private
:
typedef
nsClassHashtable
<
nsCStringHashKey
ScalarBase
>
ScalarKeysMapType
;
ScalarKeysMapType
mScalarKeys
;
const
uint32_t
mScalarKind
;
ScalarResult
GetScalarForKey
(
const
nsAString
&
aKey
ScalarBase
*
*
aRet
)
;
}
;
ScalarResult
KeyedScalar
:
:
SetValue
(
const
nsAString
&
aKey
nsIVariant
*
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
return
sr
;
}
return
scalar
-
>
SetValue
(
aValue
)
;
}
ScalarResult
KeyedScalar
:
:
AddValue
(
const
nsAString
&
aKey
nsIVariant
*
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
return
sr
;
}
return
scalar
-
>
AddValue
(
aValue
)
;
}
ScalarResult
KeyedScalar
:
:
SetMaximum
(
const
nsAString
&
aKey
nsIVariant
*
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
return
sr
;
}
return
scalar
-
>
SetMaximum
(
aValue
)
;
}
void
KeyedScalar
:
:
SetValue
(
const
nsAString
&
aKey
uint32_t
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Key
too
long
or
too
many
keys
are
recorded
in
the
scalar
.
"
)
;
return
;
}
return
scalar
-
>
SetValue
(
aValue
)
;
}
void
KeyedScalar
:
:
SetValue
(
const
nsAString
&
aKey
bool
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Key
too
long
or
too
many
keys
are
recorded
in
the
scalar
.
"
)
;
return
;
}
return
scalar
-
>
SetValue
(
aValue
)
;
}
void
KeyedScalar
:
:
AddValue
(
const
nsAString
&
aKey
uint32_t
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Key
too
long
or
too
many
keys
are
recorded
in
the
scalar
.
"
)
;
return
;
}
return
scalar
-
>
AddValue
(
aValue
)
;
}
void
KeyedScalar
:
:
SetMaximum
(
const
nsAString
&
aKey
uint32_t
aValue
)
{
ScalarBase
*
scalar
=
nullptr
;
ScalarResult
sr
=
GetScalarForKey
(
aKey
&
scalar
)
;
if
(
sr
!
=
ScalarResult
:
:
Ok
)
{
MOZ_ASSERT
(
false
"
Key
too
long
or
too
many
keys
are
recorded
in
the
scalar
.
"
)
;
return
;
}
return
scalar
-
>
SetMaximum
(
aValue
)
;
}
nsresult
KeyedScalar
:
:
GetValue
(
nsTArray
<
KeyValuePair
>
&
aValues
)
const
{
for
(
auto
iter
=
mScalarKeys
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarBase
*
scalar
=
static_cast
<
ScalarBase
*
>
(
iter
.
Data
(
)
)
;
nsCOMPtr
<
nsIVariant
>
scalarValue
;
nsresult
rv
=
scalar
-
>
GetValue
(
scalarValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aValues
.
AppendElement
(
mozilla
:
:
MakePair
(
nsCString
(
iter
.
Key
(
)
)
scalarValue
)
)
;
}
return
NS_OK
;
}
ScalarResult
KeyedScalar
:
:
GetScalarForKey
(
const
nsAString
&
aKey
ScalarBase
*
*
aRet
)
{
if
(
aKey
.
Length
(
)
>
=
kMaximumKeyStringLength
)
{
return
ScalarResult
:
:
KeyTooLong
;
}
if
(
mScalarKeys
.
Count
(
)
>
=
kMaximumNumberOfKeys
)
{
return
ScalarResult
:
:
TooManyKeys
;
}
NS_ConvertUTF16toUTF8
utf8Key
(
aKey
)
;
ScalarBase
*
scalar
=
nullptr
;
if
(
mScalarKeys
.
Get
(
utf8Key
&
scalar
)
)
{
*
aRet
=
scalar
;
return
ScalarResult
:
:
Ok
;
}
scalar
=
internal_ScalarAllocate
(
mScalarKind
)
;
if
(
!
scalar
)
{
return
ScalarResult
:
:
InvalidType
;
}
mScalarKeys
.
Put
(
utf8Key
scalar
)
;
*
aRet
=
scalar
;
return
ScalarResult
:
:
Ok
;
}
size_t
KeyedScalar
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
this
)
;
for
(
auto
iter
=
mScalarKeys
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarBase
*
scalar
=
static_cast
<
ScalarBase
*
>
(
iter
.
Data
(
)
)
;
n
+
=
scalar
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
typedef
nsUint32HashKey
ScalarIDHashKey
;
typedef
nsClassHashtable
<
ScalarIDHashKey
ScalarBase
>
ScalarStorageMapType
;
typedef
nsClassHashtable
<
ScalarIDHashKey
KeyedScalar
>
KeyedScalarStorageMapType
;
}
namespace
{
bool
gInitDone
=
false
;
bool
gCanRecordBase
;
bool
gCanRecordExtended
;
ScalarMapType
gScalarNameIDMap
(
kScalarCount
)
;
ScalarStorageMapType
gScalarStorageMap
;
KeyedScalarStorageMapType
gKeyedScalarStorageMap
;
}
namespace
{
void
internal_LogToBrowserConsole
(
uint32_t
aLogLevel
const
nsAString
&
aMsg
)
{
if
(
!
NS_IsMainThread
(
)
)
{
nsString
msg
(
aMsg
)
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
[
aLogLevel
msg
]
(
)
{
internal_LogToBrowserConsole
(
aLogLevel
msg
)
;
}
)
;
NS_DispatchToMainThread
(
task
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
return
;
}
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
)
)
;
if
(
!
console
)
{
NS_WARNING
(
"
Failed
to
log
message
to
console
.
"
)
;
return
;
}
nsCOMPtr
<
nsIScriptError
>
error
(
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
)
)
;
error
-
>
Init
(
aMsg
EmptyString
(
)
EmptyString
(
)
0
0
aLogLevel
"
chrome
javascript
"
)
;
console
-
>
LogMessage
(
error
)
;
}
bool
internal_ShouldLogError
(
ScalarResult
aSr
)
{
switch
(
aSr
)
{
case
ScalarResult
:
:
StringTooLong
:
MOZ_FALLTHROUGH
;
case
ScalarResult
:
:
KeyTooLong
:
MOZ_FALLTHROUGH
;
case
ScalarResult
:
:
TooManyKeys
:
MOZ_FALLTHROUGH
;
case
ScalarResult
:
:
UnsignedNegativeValue
:
MOZ_FALLTHROUGH
;
case
ScalarResult
:
:
UnsignedTruncatedValue
:
return
true
;
default
:
return
false
;
}
return
false
;
}
void
internal_LogScalarError
(
const
nsACString
&
aScalarName
ScalarResult
aSr
)
{
nsAutoString
errorMessage
;
AppendUTF8toUTF16
(
aScalarName
errorMessage
)
;
switch
(
aSr
)
{
case
ScalarResult
:
:
StringTooLong
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Truncating
scalar
value
to
50
characters
.
"
)
)
;
break
;
case
ScalarResult
:
:
KeyTooLong
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
The
key
length
must
be
limited
to
70
characters
.
"
)
)
;
break
;
case
ScalarResult
:
:
TooManyKeys
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Keyed
scalars
cannot
have
more
than
100
keys
.
"
)
)
;
break
;
case
ScalarResult
:
:
UnsignedNegativeValue
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Trying
to
set
an
unsigned
scalar
to
a
negative
number
.
"
)
)
;
break
;
case
ScalarResult
:
:
UnsignedTruncatedValue
:
errorMessage
.
Append
(
NS_LITERAL_STRING
(
"
-
Truncating
float
/
double
number
.
"
)
)
;
break
;
default
:
return
;
}
internal_LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
errorMessage
)
;
}
}
namespace
{
bool
internal_CanRecordBase
(
)
{
return
gCanRecordBase
;
}
bool
internal_CanRecordExtended
(
)
{
return
gCanRecordExtended
;
}
const
ScalarInfo
&
internal_InfoForScalarID
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
)
{
return
gScalars
[
static_cast
<
uint32_t
>
(
aId
)
]
;
}
bool
internal_IsKeyedScalar
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
)
{
return
internal_InfoForScalarID
(
aId
)
.
keyed
;
}
bool
internal_CanRecordForScalarID
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
)
{
const
ScalarInfo
&
info
=
internal_InfoForScalarID
(
aId
)
;
bool
canRecordBase
=
internal_CanRecordBase
(
)
;
if
(
!
canRecordBase
)
{
return
false
;
}
bool
canRecordDataset
=
CanRecordDataset
(
info
.
dataset
canRecordBase
internal_CanRecordExtended
(
)
)
;
if
(
!
canRecordDataset
)
{
return
false
;
}
return
true
;
}
nsresult
internal_GetEnumByScalarName
(
const
nsACString
&
aName
mozilla
:
:
Telemetry
:
:
ScalarID
*
aId
)
{
if
(
!
gInitDone
)
{
return
NS_ERROR_FAILURE
;
}
CharPtrEntryType
*
entry
=
gScalarNameIDMap
.
GetEntry
(
PromiseFlatCString
(
aName
)
.
get
(
)
)
;
if
(
!
entry
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aId
=
entry
-
>
mData
;
return
NS_OK
;
}
nsresult
internal_GetScalarByEnum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
ScalarBase
*
*
aRet
)
{
if
(
!
IsValidEnumId
(
aId
)
)
{
MOZ_ASSERT
(
false
"
Requested
a
scalar
with
an
invalid
id
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
const
uint32_t
id
=
static_cast
<
uint32_t
>
(
aId
)
;
ScalarBase
*
scalar
=
nullptr
;
if
(
gScalarStorageMap
.
Get
(
id
&
scalar
)
)
{
*
aRet
=
scalar
;
return
NS_OK
;
}
const
ScalarInfo
&
info
=
gScalars
[
id
]
;
if
(
IsExpiredVersion
(
info
.
expiration
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
scalar
=
internal_ScalarAllocate
(
info
.
kind
)
;
if
(
!
scalar
)
{
return
NS_ERROR_INVALID_ARG
;
}
gScalarStorageMap
.
Put
(
id
scalar
)
;
*
aRet
=
scalar
;
return
NS_OK
;
}
ScalarBase
*
internal_GetRecordableScalar
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
)
{
ScalarBase
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetScalarByEnum
(
aId
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
if
(
internal_IsKeyedScalar
(
aId
)
)
{
return
nullptr
;
}
if
(
!
internal_CanRecordForScalarID
(
aId
)
)
{
return
nullptr
;
}
return
scalar
;
}
}
namespace
{
nsresult
internal_GetKeyedScalarByEnum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
KeyedScalar
*
*
aRet
)
{
if
(
!
IsValidEnumId
(
aId
)
)
{
MOZ_ASSERT
(
false
"
Requested
a
keyed
scalar
with
an
invalid
id
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
const
uint32_t
id
=
static_cast
<
uint32_t
>
(
aId
)
;
KeyedScalar
*
scalar
=
nullptr
;
if
(
gKeyedScalarStorageMap
.
Get
(
id
&
scalar
)
)
{
*
aRet
=
scalar
;
return
NS_OK
;
}
const
ScalarInfo
&
info
=
gScalars
[
id
]
;
if
(
IsExpiredVersion
(
info
.
expiration
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
info
.
kind
=
=
nsITelemetry
:
:
SCALAR_STRING
)
{
MOZ_ASSERT
(
false
"
Keyed
string
scalars
are
not
currently
supported
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
scalar
=
new
KeyedScalar
(
info
.
kind
)
;
if
(
!
scalar
)
{
return
NS_ERROR_INVALID_ARG
;
}
gKeyedScalarStorageMap
.
Put
(
id
scalar
)
;
*
aRet
=
scalar
;
return
NS_OK
;
}
KeyedScalar
*
internal_GetRecordableKeyedScalar
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
)
{
KeyedScalar
*
scalar
=
nullptr
;
nsresult
rv
=
internal_GetKeyedScalarByEnum
(
aId
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
if
(
!
internal_IsKeyedScalar
(
aId
)
)
{
return
nullptr
;
}
if
(
!
internal_CanRecordForScalarID
(
aId
)
)
{
return
nullptr
;
}
return
scalar
;
}
}
static
StaticMutex
gTelemetryScalarsMutex
;
void
TelemetryScalar
:
:
InitializeGlobalState
(
bool
aCanRecordBase
bool
aCanRecordExtended
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
MOZ_ASSERT
(
!
gInitDone
"
TelemetryScalar
:
:
InitializeGlobalState
"
"
may
only
be
called
once
"
)
;
gCanRecordBase
=
aCanRecordBase
;
gCanRecordExtended
=
aCanRecordExtended
;
uint32_t
scalarCount
=
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
ScalarID
:
:
ScalarCount
)
;
for
(
uint32_t
i
=
0
;
i
<
scalarCount
;
i
+
+
)
{
CharPtrEntryType
*
entry
=
gScalarNameIDMap
.
PutEntry
(
gScalars
[
i
]
.
name
(
)
)
;
entry
-
>
mData
=
static_cast
<
mozilla
:
:
Telemetry
:
:
ScalarID
>
(
i
)
;
}
#
ifdef
DEBUG
gScalarNameIDMap
.
MarkImmutable
(
)
;
#
endif
gInitDone
=
true
;
}
void
TelemetryScalar
:
:
DeInitializeGlobalState
(
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gCanRecordBase
=
false
;
gCanRecordExtended
=
false
;
gScalarNameIDMap
.
Clear
(
)
;
gScalarStorageMap
.
Clear
(
)
;
gKeyedScalarStorageMap
.
Clear
(
)
;
gInitDone
=
false
;
}
void
TelemetryScalar
:
:
SetCanRecordBase
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gCanRecordBase
=
b
;
}
void
TelemetryScalar
:
:
SetCanRecordExtended
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gCanRecordExtended
=
b
;
}
nsresult
TelemetryScalar
:
:
Add
(
const
nsACString
&
aName
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
mozilla
:
:
Telemetry
:
:
ScalarID
id
;
rv
=
internal_GetEnumByScalarName
(
aName
&
id
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
internal_IsKeyedScalar
(
id
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
!
internal_CanRecordForScalarID
(
id
)
)
{
return
NS_OK
;
}
ScalarBase
*
scalar
=
nullptr
;
rv
=
internal_GetScalarByEnum
(
id
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
NS_OK
;
}
return
rv
;
}
sr
=
scalar
-
>
AddValue
(
unpackedVal
)
;
}
if
(
internal_ShouldLogError
(
sr
)
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
MapToNsResult
(
sr
)
;
}
nsresult
TelemetryScalar
:
:
Add
(
const
nsACString
&
aName
const
nsAString
&
aKey
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
mozilla
:
:
Telemetry
:
:
ScalarID
id
;
rv
=
internal_GetEnumByScalarName
(
aName
&
id
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
internal_IsKeyedScalar
(
id
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
!
internal_CanRecordForScalarID
(
id
)
)
{
return
NS_OK
;
}
KeyedScalar
*
scalar
=
nullptr
;
rv
=
internal_GetKeyedScalarByEnum
(
id
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
NS_OK
;
}
return
rv
;
}
sr
=
scalar
-
>
AddValue
(
aKey
unpackedVal
)
;
}
if
(
internal_ShouldLogError
(
sr
)
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
MapToNsResult
(
sr
)
;
}
void
TelemetryScalar
:
:
Add
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
ScalarBase
*
scalar
=
internal_GetRecordableScalar
(
aId
)
;
if
(
!
scalar
)
{
return
;
}
scalar
-
>
AddValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Add
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
KeyedScalar
*
scalar
=
internal_GetRecordableKeyedScalar
(
aId
)
;
if
(
!
scalar
)
{
return
;
}
scalar
-
>
AddValue
(
aKey
aValue
)
;
}
nsresult
TelemetryScalar
:
:
Set
(
const
nsACString
&
aName
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
mozilla
:
:
Telemetry
:
:
ScalarID
id
;
rv
=
internal_GetEnumByScalarName
(
aName
&
id
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
internal_IsKeyedScalar
(
id
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
!
internal_CanRecordForScalarID
(
id
)
)
{
return
NS_OK
;
}
ScalarBase
*
scalar
=
nullptr
;
rv
=
internal_GetScalarByEnum
(
id
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
NS_OK
;
}
return
rv
;
}
sr
=
scalar
-
>
SetValue
(
unpackedVal
)
;
}
if
(
internal_ShouldLogError
(
sr
)
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
MapToNsResult
(
sr
)
;
}
nsresult
TelemetryScalar
:
:
Set
(
const
nsACString
&
aName
const
nsAString
&
aKey
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
mozilla
:
:
Telemetry
:
:
ScalarID
id
;
rv
=
internal_GetEnumByScalarName
(
aName
&
id
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
internal_IsKeyedScalar
(
id
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
!
internal_CanRecordForScalarID
(
id
)
)
{
return
NS_OK
;
}
KeyedScalar
*
scalar
=
nullptr
;
rv
=
internal_GetKeyedScalarByEnum
(
id
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
NS_OK
;
}
return
rv
;
}
sr
=
scalar
-
>
SetValue
(
aKey
unpackedVal
)
;
}
if
(
internal_ShouldLogError
(
sr
)
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
MapToNsResult
(
sr
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
ScalarBase
*
scalar
=
internal_GetRecordableScalar
(
aId
)
;
if
(
!
scalar
)
{
return
;
}
scalar
-
>
SetValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
ScalarBase
*
scalar
=
internal_GetRecordableScalar
(
aId
)
;
if
(
!
scalar
)
{
return
;
}
scalar
-
>
SetValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
bool
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
ScalarBase
*
scalar
=
internal_GetRecordableScalar
(
aId
)
;
if
(
!
scalar
)
{
return
;
}
scalar
-
>
SetValue
(
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
KeyedScalar
*
scalar
=
internal_GetRecordableKeyedScalar
(
aId
)
;
if
(
!
scalar
)
{
return
;
}
scalar
-
>
SetValue
(
aKey
aValue
)
;
}
void
TelemetryScalar
:
:
Set
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
bool
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
KeyedScalar
*
scalar
=
internal_GetRecordableKeyedScalar
(
aId
)
;
if
(
!
scalar
)
{
return
;
}
scalar
-
>
SetValue
(
aKey
aValue
)
;
}
nsresult
TelemetryScalar
:
:
SetMaximum
(
const
nsACString
&
aName
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
mozilla
:
:
Telemetry
:
:
ScalarID
id
;
rv
=
internal_GetEnumByScalarName
(
aName
&
id
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
internal_IsKeyedScalar
(
id
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
!
internal_CanRecordForScalarID
(
id
)
)
{
return
NS_OK
;
}
ScalarBase
*
scalar
=
nullptr
;
rv
=
internal_GetScalarByEnum
(
id
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
NS_OK
;
}
return
rv
;
}
sr
=
scalar
-
>
SetMaximum
(
unpackedVal
)
;
}
if
(
internal_ShouldLogError
(
sr
)
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
MapToNsResult
(
sr
)
;
}
nsresult
TelemetryScalar
:
:
SetMaximum
(
const
nsACString
&
aName
const
nsAString
&
aKey
JS
:
:
HandleValue
aVal
JSContext
*
aCx
)
{
nsCOMPtr
<
nsIVariant
>
unpackedVal
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
aCx
aVal
getter_AddRefs
(
unpackedVal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
ScalarResult
sr
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
mozilla
:
:
Telemetry
:
:
ScalarID
id
;
rv
=
internal_GetEnumByScalarName
(
aName
&
id
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
internal_IsKeyedScalar
(
id
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
!
internal_CanRecordForScalarID
(
id
)
)
{
return
NS_OK
;
}
KeyedScalar
*
scalar
=
nullptr
;
rv
=
internal_GetKeyedScalarByEnum
(
id
&
scalar
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
NS_OK
;
}
return
rv
;
}
sr
=
scalar
-
>
SetMaximum
(
aKey
unpackedVal
)
;
}
if
(
internal_ShouldLogError
(
sr
)
)
{
internal_LogScalarError
(
aName
sr
)
;
}
return
MapToNsResult
(
sr
)
;
}
void
TelemetryScalar
:
:
SetMaximum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
uint32_t
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
ScalarBase
*
scalar
=
internal_GetRecordableScalar
(
aId
)
;
if
(
!
scalar
)
{
return
;
}
scalar
-
>
SetMaximum
(
aValue
)
;
}
void
TelemetryScalar
:
:
SetMaximum
(
mozilla
:
:
Telemetry
:
:
ScalarID
aId
const
nsAString
&
aKey
uint32_t
aValue
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
KeyedScalar
*
scalar
=
internal_GetRecordableKeyedScalar
(
aId
)
;
if
(
!
scalar
)
{
return
;
}
scalar
-
>
SetMaximum
(
aKey
aValue
)
;
}
nsresult
TelemetryScalar
:
:
CreateSnapshots
(
unsigned
int
aDataset
bool
aClearScalars
JSContext
*
aCx
uint8_t
optional_argc
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
{
if
(
!
optional_argc
)
{
aClearScalars
=
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
root_obj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
root_obj
)
{
return
NS_ERROR_FAILURE
;
}
aResult
.
setObject
(
*
root_obj
)
;
typedef
mozilla
:
:
Pair
<
const
char
*
nsCOMPtr
<
nsIVariant
>
>
DataPair
;
nsTArray
<
DataPair
>
scalarsToReflect
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
for
(
auto
iter
=
gScalarStorageMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarBase
*
scalar
=
static_cast
<
ScalarBase
*
>
(
iter
.
Data
(
)
)
;
const
ScalarInfo
&
info
=
gScalars
[
iter
.
Key
(
)
]
;
if
(
IsInDataset
(
info
.
dataset
aDataset
)
)
{
nsCOMPtr
<
nsIVariant
>
scalarValue
;
nsresult
rv
=
scalar
-
>
GetValue
(
scalarValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
scalarsToReflect
.
AppendElement
(
mozilla
:
:
MakePair
(
info
.
name
(
)
scalarValue
)
)
;
}
}
if
(
aClearScalars
)
{
gScalarStorageMap
.
Clear
(
)
;
}
}
for
(
nsTArray
<
DataPair
>
:
:
size_type
i
=
0
;
i
<
scalarsToReflect
.
Length
(
)
;
i
+
+
)
{
const
DataPair
&
scalar
=
scalarsToReflect
[
i
]
;
JS
:
:
Rooted
<
JS
:
:
Value
>
scalarJsValue
(
aCx
)
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
VariantToJS
(
aCx
root_obj
scalar
.
second
(
)
&
scalarJsValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
JS_DefineProperty
(
aCx
root_obj
scalar
.
first
(
)
scalarJsValue
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
nsresult
TelemetryScalar
:
:
CreateKeyedSnapshots
(
unsigned
int
aDataset
bool
aClearScalars
JSContext
*
aCx
uint8_t
optional_argc
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
{
if
(
!
optional_argc
)
{
aClearScalars
=
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
root_obj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
root_obj
)
{
return
NS_ERROR_FAILURE
;
}
aResult
.
setObject
(
*
root_obj
)
;
typedef
mozilla
:
:
Pair
<
const
char
*
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
>
DataPair
;
nsTArray
<
DataPair
>
scalarsToReflect
;
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
for
(
auto
iter
=
gKeyedScalarStorageMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
KeyedScalar
*
scalar
=
static_cast
<
KeyedScalar
*
>
(
iter
.
Data
(
)
)
;
const
ScalarInfo
&
info
=
gScalars
[
iter
.
Key
(
)
]
;
if
(
IsInDataset
(
info
.
dataset
aDataset
)
)
{
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
scalarKeyedData
;
nsresult
rv
=
scalar
-
>
GetValue
(
scalarKeyedData
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
scalarsToReflect
.
AppendElement
(
mozilla
:
:
MakePair
(
info
.
name
(
)
scalarKeyedData
)
)
;
}
}
if
(
aClearScalars
)
{
gKeyedScalarStorageMap
.
Clear
(
)
;
}
}
for
(
nsTArray
<
DataPair
>
:
:
size_type
i
=
0
;
i
<
scalarsToReflect
.
Length
(
)
;
i
+
+
)
{
const
DataPair
&
keyedScalarData
=
scalarsToReflect
[
i
]
;
JS
:
:
RootedObject
keyedScalarObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
const
nsTArray
<
KeyedScalar
:
:
KeyValuePair
>
&
keyProps
=
keyedScalarData
.
second
(
)
;
for
(
uint32_t
i
=
0
;
i
<
keyProps
.
Length
(
)
;
i
+
+
)
{
const
KeyedScalar
:
:
KeyValuePair
&
keyData
=
keyProps
[
i
]
;
JS
:
:
Rooted
<
JS
:
:
Value
>
keyJsValue
(
aCx
)
;
nsresult
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
VariantToJS
(
aCx
keyedScalarObj
keyData
.
second
(
)
&
keyJsValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
const
NS_ConvertUTF8toUTF16
key
(
keyData
.
first
(
)
)
;
if
(
!
JS_DefineUCProperty
(
aCx
keyedScalarObj
key
.
Data
(
)
key
.
Length
(
)
keyJsValue
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
!
JS_DefineProperty
(
aCx
root_obj
keyedScalarData
.
first
(
)
keyedScalarObj
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
void
TelemetryScalar
:
:
ClearScalars
(
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
gScalarStorageMap
.
Clear
(
)
;
gKeyedScalarStorageMap
.
Clear
(
)
;
}
size_t
TelemetryScalar
:
:
GetMapShallowSizesOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
return
gScalarNameIDMap
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
TelemetryScalar
:
:
GetScalarSizesOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
StaticMutexAutoLock
locker
(
gTelemetryScalarsMutex
)
;
size_t
n
=
0
;
for
(
auto
iter
=
gScalarStorageMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ScalarBase
*
scalar
=
static_cast
<
ScalarBase
*
>
(
iter
.
Data
(
)
)
;
n
+
=
scalar
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
for
(
auto
iter
=
gKeyedScalarStorageMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
KeyedScalar
*
scalar
=
static_cast
<
KeyedScalar
*
>
(
iter
.
Data
(
)
)
;
n
+
=
scalar
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
