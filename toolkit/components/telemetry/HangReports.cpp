#
include
"
HangReports
.
h
"
namespace
mozilla
{
namespace
Telemetry
{
using
namespace
HangMonitor
;
nsresult
ComputeAnnotationsKey
(
const
HangAnnotations
&
aAnnotations
nsAString
&
aKeyOut
)
{
if
(
aAnnotations
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
auto
&
annotation
:
aAnnotations
)
{
aKeyOut
.
Append
(
annotation
.
mName
)
;
aKeyOut
.
Append
(
annotation
.
mValue
)
;
}
return
NS_OK
;
}
#
if
defined
(
MOZ_GECKO_PROFILER
)
const
size_t
kMaxHangStacksKept
=
50
;
void
HangReports
:
:
AddHang
(
const
Telemetry
:
:
ProcessedStack
&
aStack
uint32_t
aDuration
int32_t
aSystemUptime
int32_t
aFirefoxUptime
HangAnnotations
&
&
aAnnotations
)
{
size_t
hangIndex
=
mStacks
.
AddStack
(
aStack
)
;
HangInfo
info
=
{
aDuration
aSystemUptime
aFirefoxUptime
}
;
if
(
mHangInfo
.
size
(
)
<
kMaxHangStacksKept
)
{
mHangInfo
.
push_back
(
info
)
;
}
else
{
mHangInfo
[
hangIndex
]
=
info
;
PruneStackReferences
(
hangIndex
)
;
}
nsAutoString
annotationsKey
;
nsresult
rv
=
ComputeAnnotationsKey
(
aAnnotations
annotationsKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
AnnotationInfo
*
annotationsEntry
=
mAnnotationInfo
.
Get
(
annotationsKey
)
;
if
(
annotationsEntry
)
{
annotationsEntry
-
>
mHangIndices
.
AppendElement
(
hangIndex
)
;
return
;
}
mAnnotationInfo
.
Put
(
annotationsKey
new
AnnotationInfo
(
hangIndex
std
:
:
move
(
aAnnotations
)
)
)
;
}
void
HangReports
:
:
PruneStackReferences
(
const
size_t
aRemovedStackIndex
)
{
for
(
auto
iter
=
mAnnotationInfo
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsTArray
<
uint32_t
>
&
stackIndices
=
iter
.
Data
(
)
-
>
mHangIndices
;
size_t
toRemove
=
stackIndices
.
NoIndex
;
for
(
size_t
k
=
0
;
k
<
stackIndices
.
Length
(
)
;
k
+
+
)
{
if
(
stackIndices
[
k
]
=
=
aRemovedStackIndex
)
{
toRemove
=
k
;
break
;
}
}
if
(
toRemove
!
=
stackIndices
.
NoIndex
)
{
stackIndices
.
RemoveElementAt
(
toRemove
)
;
}
if
(
!
stackIndices
.
Length
(
)
)
{
iter
.
Remove
(
)
;
}
}
}
#
endif
size_t
HangReports
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
n
+
=
mStacks
.
SizeOfExcludingThis
(
)
;
n
+
=
mHangInfo
.
capacity
(
)
*
sizeof
(
HangInfo
)
;
n
+
=
mAnnotationInfo
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
n
+
=
mAnnotationInfo
.
Count
(
)
*
sizeof
(
AnnotationInfo
)
;
for
(
auto
iter
=
mAnnotationInfo
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
=
iter
.
Key
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
auto
&
annotations
=
iter
.
Data
(
)
-
>
mAnnotations
;
n
+
=
annotations
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
const
CombinedStacks
&
HangReports
:
:
GetStacks
(
)
const
{
return
mStacks
;
}
uint32_t
HangReports
:
:
GetDuration
(
unsigned
aIndex
)
const
{
return
mHangInfo
[
aIndex
]
.
mDuration
;
}
int32_t
HangReports
:
:
GetSystemUptime
(
unsigned
aIndex
)
const
{
return
mHangInfo
[
aIndex
]
.
mSystemUptime
;
}
int32_t
HangReports
:
:
GetFirefoxUptime
(
unsigned
aIndex
)
const
{
return
mHangInfo
[
aIndex
]
.
mFirefoxUptime
;
}
const
nsClassHashtable
<
nsStringHashKey
HangReports
:
:
AnnotationInfo
>
&
HangReports
:
:
GetAnnotationInfo
(
)
const
{
return
mAnnotationInfo
;
}
}
}
