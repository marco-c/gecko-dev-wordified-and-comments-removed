#
include
<
prtime
.
h
>
#
include
"
nsITelemetry
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
"
TelemetryCommon
.
h
"
#
include
"
TelemetryEvent
.
h
"
#
include
"
TelemetryEventData
.
h
"
#
include
"
ipc
/
TelemetryIPCAccumulator
.
h
"
using
mozilla
:
:
StaticMutex
;
using
mozilla
:
:
StaticMutexAutoLock
;
using
mozilla
:
:
ArrayLength
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
StaticAutoPtr
;
using
mozilla
:
:
TimeStamp
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
AutoHashtable
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsExpiredVersion
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
CanRecordDataset
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsInDataset
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
MsSinceProcessStart
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
LogToBrowserConsole
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
CanRecordInProcess
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
GetNameForProcessID
;
using
mozilla
:
:
Telemetry
:
:
EventExtraEntry
;
using
mozilla
:
:
Telemetry
:
:
ChildEventData
;
using
mozilla
:
:
Telemetry
:
:
ProcessID
;
namespace
TelemetryIPCAccumulator
=
mozilla
:
:
TelemetryIPCAccumulator
;
namespace
{
const
uint32_t
kEventCount
=
mozilla
:
:
Telemetry
:
:
EventID
:
:
EventCount
;
const
uint32_t
kExpiredEventId
=
kEventCount
+
1
;
static_assert
(
kEventCount
<
kExpiredEventId
"
Should
not
overflow
.
"
)
;
const
uint32_t
kMaxEventRecords
=
1000
;
const
uint32_t
kMaxValueByteLength
=
80
;
const
uint32_t
kMaxExtraValueByteLength
=
80
;
typedef
nsDataHashtable
<
nsCStringHashKey
uint32_t
>
StringUintMap
;
typedef
nsClassHashtable
<
nsCStringHashKey
nsCString
>
StringMap
;
enum
class
RecordEventResult
{
Ok
UnknownEvent
InvalidExtraKey
StorageLimitReached
ExpiredEvent
WrongProcess
}
;
typedef
nsTArray
<
EventExtraEntry
>
ExtraArray
;
class
EventRecord
{
public
:
EventRecord
(
double
timestamp
uint32_t
eventId
const
Maybe
<
nsCString
>
&
value
const
ExtraArray
&
extra
)
:
mTimestamp
(
timestamp
)
mEventId
(
eventId
)
mValue
(
value
)
mExtra
(
extra
)
{
}
EventRecord
(
const
EventRecord
&
other
)
:
mTimestamp
(
other
.
mTimestamp
)
mEventId
(
other
.
mEventId
)
mValue
(
other
.
mValue
)
mExtra
(
other
.
mExtra
)
{
}
EventRecord
&
operator
=
(
const
EventRecord
&
other
)
=
delete
;
double
Timestamp
(
)
const
{
return
mTimestamp
;
}
uint32_t
EventId
(
)
const
{
return
mEventId
;
}
const
Maybe
<
nsCString
>
&
Value
(
)
const
{
return
mValue
;
}
const
ExtraArray
&
Extra
(
)
const
{
return
mExtra
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
const
double
mTimestamp
;
const
uint32_t
mEventId
;
const
Maybe
<
nsCString
>
mValue
;
const
ExtraArray
mExtra
;
}
;
const
char
*
EventInfo
:
:
method
(
)
const
{
return
&
gEventsStringTable
[
this
-
>
method_offset
]
;
}
const
char
*
EventInfo
:
:
object
(
)
const
{
return
&
gEventsStringTable
[
this
-
>
object_offset
]
;
}
const
char
*
CommonEventInfo
:
:
category
(
)
const
{
return
&
gEventsStringTable
[
this
-
>
category_offset
]
;
}
const
char
*
CommonEventInfo
:
:
expiration_version
(
)
const
{
return
&
gEventsStringTable
[
this
-
>
expiration_version_offset
]
;
}
const
char
*
CommonEventInfo
:
:
extra_key
(
uint32_t
index
)
const
{
MOZ_ASSERT
(
index
<
this
-
>
extra_count
)
;
uint32_t
key_index
=
gExtraKeysTable
[
this
-
>
extra_index
+
index
]
;
return
&
gEventsStringTable
[
key_index
]
;
}
size_t
EventRecord
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
if
(
mValue
)
{
n
+
=
mValue
.
value
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
n
+
=
mExtra
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
uint32_t
i
=
0
;
i
<
mExtra
.
Length
(
)
;
+
+
i
)
{
n
+
=
mExtra
[
i
]
.
key
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
n
+
=
mExtra
[
i
]
.
value
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
return
n
;
}
nsCString
UniqueEventName
(
const
nsACString
&
category
const
nsACString
&
method
const
nsACString
&
object
)
{
nsCString
name
;
name
.
Append
(
category
)
;
name
.
AppendLiteral
(
"
#
"
)
;
name
.
Append
(
method
)
;
name
.
AppendLiteral
(
"
#
"
)
;
name
.
Append
(
object
)
;
return
name
;
}
nsCString
UniqueEventName
(
const
EventInfo
&
info
)
{
return
UniqueEventName
(
nsDependentCString
(
info
.
common_info
.
category
(
)
)
nsDependentCString
(
info
.
method
(
)
)
nsDependentCString
(
info
.
object
(
)
)
)
;
}
bool
IsExpiredDate
(
uint32_t
expires_days_since_epoch
)
{
if
(
expires_days_since_epoch
=
=
0
)
{
return
false
;
}
const
uint32_t
days_since_epoch
=
PR_Now
(
)
/
(
PRTime
(
PR_USEC_PER_SEC
)
*
24
*
60
*
60
)
;
return
expires_days_since_epoch
<
=
days_since_epoch
;
}
void
TruncateToByteLength
(
nsCString
&
str
uint32_t
length
)
{
uint32_t
last
=
RewindToPriorUTF8Codepoint
(
str
.
get
(
)
length
)
;
str
.
Truncate
(
last
)
;
}
}
namespace
{
bool
gInitDone
=
false
;
bool
gCanRecordBase
;
bool
gCanRecordExtended
;
StringUintMap
gEventNameIDMap
(
kEventCount
)
;
StringUintMap
gCategoryNameIDMap
;
nsTHashtable
<
nsUint32HashKey
>
gEnabledCategories
;
typedef
nsTArray
<
EventRecord
>
EventRecordArray
;
nsClassHashtable
<
nsUint32HashKey
EventRecordArray
>
gEventRecords
;
}
namespace
{
bool
CanRecordEvent
(
const
StaticMutexAutoLock
&
lock
const
CommonEventInfo
&
info
ProcessID
process
)
{
if
(
!
gCanRecordBase
)
{
return
false
;
}
if
(
!
CanRecordDataset
(
info
.
dataset
gCanRecordBase
gCanRecordExtended
)
)
{
return
false
;
}
if
(
!
CanRecordInProcess
(
info
.
record_in_processes
process
)
)
{
return
false
;
}
return
gEnabledCategories
.
GetEntry
(
info
.
category_offset
)
;
}
EventRecordArray
*
GetEventRecordsForProcess
(
const
StaticMutexAutoLock
&
lock
ProcessID
processType
)
{
EventRecordArray
*
eventRecords
=
nullptr
;
if
(
!
gEventRecords
.
Get
(
uint32_t
(
processType
)
&
eventRecords
)
)
{
eventRecords
=
new
EventRecordArray
(
)
;
gEventRecords
.
Put
(
uint32_t
(
processType
)
eventRecords
)
;
}
return
eventRecords
;
}
bool
GetEventId
(
const
StaticMutexAutoLock
&
lock
const
nsACString
&
category
const
nsACString
&
method
const
nsACString
&
object
uint32_t
*
eventId
)
{
MOZ_ASSERT
(
eventId
)
;
const
nsCString
&
name
=
UniqueEventName
(
category
method
object
)
;
return
gEventNameIDMap
.
Get
(
name
eventId
)
;
}
RecordEventResult
RecordEvent
(
const
StaticMutexAutoLock
&
lock
ProcessID
processType
double
timestamp
const
nsACString
&
category
const
nsACString
&
method
const
nsACString
&
object
const
Maybe
<
nsCString
>
&
value
const
ExtraArray
&
extra
)
{
EventRecordArray
*
eventRecords
=
GetEventRecordsForProcess
(
lock
processType
)
;
if
(
eventRecords
-
>
Length
(
)
>
=
kMaxEventRecords
)
{
return
RecordEventResult
:
:
StorageLimitReached
;
}
uint32_t
eventId
;
if
(
!
GetEventId
(
lock
category
method
object
&
eventId
)
)
{
return
RecordEventResult
:
:
UnknownEvent
;
}
if
(
eventId
=
=
kExpiredEventId
)
{
return
RecordEventResult
:
:
ExpiredEvent
;
}
const
CommonEventInfo
&
common
=
gEventInfo
[
eventId
]
.
common_info
;
if
(
!
CanRecordEvent
(
lock
common
processType
)
)
{
return
RecordEventResult
:
:
Ok
;
}
nsTHashtable
<
nsCStringHashKey
>
validExtraKeys
;
for
(
uint32_t
i
=
0
;
i
<
common
.
extra_count
;
+
+
i
)
{
validExtraKeys
.
PutEntry
(
nsDependentCString
(
common
.
extra_key
(
i
)
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
extra
.
Length
(
)
;
+
+
i
)
{
if
(
!
validExtraKeys
.
GetEntry
(
extra
[
i
]
.
key
)
)
{
return
RecordEventResult
:
:
InvalidExtraKey
;
}
}
eventRecords
-
>
AppendElement
(
EventRecord
(
timestamp
eventId
value
extra
)
)
;
return
RecordEventResult
:
:
Ok
;
}
RecordEventResult
ShouldRecordChildEvent
(
const
StaticMutexAutoLock
&
lock
const
nsACString
&
category
const
nsACString
&
method
const
nsACString
&
object
)
{
uint32_t
eventId
;
if
(
!
GetEventId
(
lock
category
method
object
&
eventId
)
)
{
return
RecordEventResult
:
:
UnknownEvent
;
}
if
(
eventId
=
=
kExpiredEventId
)
{
return
RecordEventResult
:
:
ExpiredEvent
;
}
const
auto
processes
=
gEventInfo
[
eventId
]
.
common_info
.
record_in_processes
;
if
(
!
CanRecordInProcess
(
processes
XRE_GetProcessType
(
)
)
)
{
return
RecordEventResult
:
:
WrongProcess
;
}
return
RecordEventResult
:
:
Ok
;
}
}
namespace
{
nsresult
SerializeEventsArray
(
const
EventRecordArray
&
events
JSContext
*
cx
JS
:
:
MutableHandleObject
result
)
{
JS
:
:
RootedObject
eventsArray
(
cx
JS_NewArrayObject
(
cx
events
.
Length
(
)
)
)
;
if
(
!
eventsArray
)
{
return
NS_ERROR_FAILURE
;
}
for
(
uint32_t
i
=
0
;
i
<
events
.
Length
(
)
;
+
+
i
)
{
const
EventRecord
&
record
=
events
[
i
]
;
const
EventInfo
&
info
=
gEventInfo
[
record
.
EventId
(
)
]
;
JS
:
:
AutoValueVector
items
(
cx
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
cx
)
;
if
(
!
items
.
append
(
JS
:
:
NumberValue
(
floor
(
record
.
Timestamp
(
)
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
char
*
strings
[
]
=
{
info
.
common_info
.
category
(
)
info
.
method
(
)
info
.
object
(
)
}
;
for
(
const
char
*
s
:
strings
)
{
const
NS_ConvertUTF8toUTF16
wide
(
s
)
;
if
(
!
items
.
append
(
JS
:
:
StringValue
(
JS_NewUCStringCopyN
(
cx
wide
.
Data
(
)
wide
.
Length
(
)
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
record
.
Value
(
)
)
{
const
NS_ConvertUTF8toUTF16
wide
(
record
.
Value
(
)
.
value
(
)
)
;
if
(
!
items
.
append
(
JS
:
:
StringValue
(
JS_NewUCStringCopyN
(
cx
wide
.
Data
(
)
wide
.
Length
(
)
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
if
(
!
record
.
Extra
(
)
.
IsEmpty
(
)
)
{
if
(
!
items
.
append
(
JS
:
:
NullValue
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
!
record
.
Extra
(
)
.
IsEmpty
(
)
)
{
JS
:
:
RootedObject
obj
(
cx
JS_NewPlainObject
(
cx
)
)
;
if
(
!
obj
)
{
return
NS_ERROR_FAILURE
;
}
const
ExtraArray
&
extra
=
record
.
Extra
(
)
;
for
(
uint32_t
i
=
0
;
i
<
extra
.
Length
(
)
;
+
+
i
)
{
const
NS_ConvertUTF8toUTF16
wide
(
extra
[
i
]
.
value
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
)
;
value
.
setString
(
JS_NewUCStringCopyN
(
cx
wide
.
Data
(
)
wide
.
Length
(
)
)
)
;
if
(
!
JS_DefineProperty
(
cx
obj
extra
[
i
]
.
key
.
get
(
)
value
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
val
.
setObject
(
*
obj
)
;
if
(
!
items
.
append
(
val
)
)
{
return
NS_ERROR_FAILURE
;
}
}
JS
:
:
RootedObject
itemsArray
(
cx
JS_NewArrayObject
(
cx
items
)
)
;
if
(
!
JS_DefineElement
(
cx
eventsArray
i
itemsArray
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
result
.
set
(
eventsArray
)
;
return
NS_OK
;
}
}
static
StaticMutex
gTelemetryEventsMutex
;
void
TelemetryEvent
:
:
InitializeGlobalState
(
bool
aCanRecordBase
bool
aCanRecordExtended
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
MOZ_ASSERT
(
!
gInitDone
"
TelemetryEvent
:
:
InitializeGlobalState
"
"
may
only
be
called
once
"
)
;
gCanRecordBase
=
aCanRecordBase
;
gCanRecordExtended
=
aCanRecordExtended
;
const
uint32_t
eventCount
=
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
EventID
:
:
EventCount
)
;
for
(
uint32_t
i
=
0
;
i
<
eventCount
;
+
+
i
)
{
const
EventInfo
&
info
=
gEventInfo
[
i
]
;
uint32_t
eventId
=
i
;
if
(
IsExpiredVersion
(
info
.
common_info
.
expiration_version
(
)
)
|
|
IsExpiredDate
(
info
.
common_info
.
expiration_day
)
)
{
eventId
=
kExpiredEventId
;
}
gEventNameIDMap
.
Put
(
UniqueEventName
(
info
)
eventId
)
;
if
(
!
gCategoryNameIDMap
.
Contains
(
nsDependentCString
(
info
.
common_info
.
category
(
)
)
)
)
{
gCategoryNameIDMap
.
Put
(
nsDependentCString
(
info
.
common_info
.
category
(
)
)
info
.
common_info
.
category_offset
)
;
}
}
#
ifdef
DEBUG
gEventNameIDMap
.
MarkImmutable
(
)
;
gCategoryNameIDMap
.
MarkImmutable
(
)
;
#
endif
gInitDone
=
true
;
}
void
TelemetryEvent
:
:
DeInitializeGlobalState
(
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
MOZ_ASSERT
(
gInitDone
)
;
gCanRecordBase
=
false
;
gCanRecordExtended
=
false
;
gEventNameIDMap
.
Clear
(
)
;
gCategoryNameIDMap
.
Clear
(
)
;
gEnabledCategories
.
Clear
(
)
;
gEventRecords
.
Clear
(
)
;
gInitDone
=
false
;
}
void
TelemetryEvent
:
:
SetCanRecordBase
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
gCanRecordBase
=
b
;
}
void
TelemetryEvent
:
:
SetCanRecordExtended
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
gCanRecordExtended
=
b
;
}
nsresult
TelemetryEvent
:
:
RecordChildEvents
(
ProcessID
aProcessType
const
nsTArray
<
mozilla
:
:
Telemetry
:
:
ChildEventData
>
&
aEvents
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
for
(
uint32_t
i
=
0
;
i
<
aEvents
.
Length
(
)
;
+
+
i
)
{
const
mozilla
:
:
Telemetry
:
:
ChildEventData
e
=
aEvents
[
i
]
;
double
relativeTimestamp
=
(
e
.
timestamp
-
TimeStamp
:
:
ProcessCreation
(
)
)
.
ToMilliseconds
(
)
;
:
:
RecordEvent
(
locker
aProcessType
relativeTimestamp
e
.
category
e
.
method
e
.
object
e
.
value
e
.
extra
)
;
}
return
NS_OK
;
}
nsresult
TelemetryEvent
:
:
RecordEvent
(
const
nsACString
&
aCategory
const
nsACString
&
aMethod
const
nsACString
&
aObject
JS
:
:
HandleValue
aValue
JS
:
:
HandleValue
aExtra
JSContext
*
cx
uint8_t
optional_argc
)
{
if
(
(
optional_argc
>
0
)
&
&
!
aValue
.
isNull
(
)
&
&
!
aValue
.
isString
(
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Invalid
type
for
value
parameter
.
"
)
)
;
return
NS_OK
;
}
Maybe
<
nsCString
>
value
;
if
(
aValue
.
isString
(
)
)
{
nsAutoJSString
jsStr
;
if
(
!
jsStr
.
init
(
cx
aValue
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Invalid
string
value
for
value
parameter
.
"
)
)
;
return
NS_OK
;
}
nsCString
str
=
NS_ConvertUTF16toUTF8
(
jsStr
)
;
if
(
str
.
Length
(
)
>
kMaxValueByteLength
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Value
parameter
exceeds
maximum
string
length
truncating
.
"
)
)
;
TruncateToByteLength
(
str
kMaxValueByteLength
)
;
}
value
=
mozilla
:
:
Some
(
str
)
;
}
if
(
(
optional_argc
>
1
)
&
&
!
aExtra
.
isNull
(
)
&
&
!
aExtra
.
isObject
(
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Invalid
type
for
extra
parameter
.
"
)
)
;
return
NS_OK
;
}
ExtraArray
extra
;
if
(
aExtra
.
isObject
(
)
)
{
JS
:
:
RootedObject
obj
(
cx
&
aExtra
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
ids
(
cx
JS
:
:
IdVector
(
cx
)
)
;
if
(
!
JS_Enumerate
(
cx
obj
&
ids
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Failed
to
enumerate
object
.
"
)
)
;
return
NS_OK
;
}
for
(
size_t
i
=
0
n
=
ids
.
length
(
)
;
i
<
n
;
i
+
+
)
{
nsAutoJSString
key
;
if
(
!
key
.
init
(
cx
ids
[
i
]
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Extra
dictionary
should
only
contain
string
keys
.
"
)
)
;
return
NS_OK
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
)
;
if
(
!
JS_GetPropertyById
(
cx
obj
ids
[
i
]
&
value
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Failed
to
get
extra
property
.
"
)
)
;
return
NS_OK
;
}
nsAutoJSString
jsStr
;
if
(
!
value
.
isString
(
)
|
|
!
jsStr
.
init
(
cx
value
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Extra
properties
should
have
string
values
.
"
)
)
;
return
NS_OK
;
}
nsCString
str
=
NS_ConvertUTF16toUTF8
(
jsStr
)
;
if
(
str
.
Length
(
)
>
kMaxExtraValueByteLength
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Extra
value
exceeds
maximum
string
length
truncating
.
"
)
)
;
TruncateToByteLength
(
str
kMaxExtraValueByteLength
)
;
}
extra
.
AppendElement
(
EventExtraEntry
{
NS_ConvertUTF16toUTF8
(
key
)
str
}
)
;
}
}
RecordEventResult
res
;
if
(
!
XRE_IsParentProcess
(
)
)
{
{
StaticMutexAutoLock
lock
(
gTelemetryEventsMutex
)
;
res
=
:
:
ShouldRecordChildEvent
(
lock
aCategory
aMethod
aObject
)
;
}
if
(
res
=
=
RecordEventResult
:
:
Ok
)
{
TelemetryIPCAccumulator
:
:
RecordChildEvent
(
TimeStamp
:
:
NowLoRes
(
)
aCategory
aMethod
aObject
value
extra
)
;
}
}
else
{
StaticMutexAutoLock
lock
(
gTelemetryEventsMutex
)
;
if
(
!
gInitDone
)
{
return
NS_ERROR_FAILURE
;
}
double
timestamp
=
-
1
;
if
(
NS_WARN_IF
(
NS_FAILED
(
MsSinceProcessStart
(
&
timestamp
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
res
=
:
:
RecordEvent
(
lock
ProcessID
:
:
Parent
timestamp
aCategory
aMethod
aObject
value
extra
)
;
}
switch
(
res
)
{
case
RecordEventResult
:
:
UnknownEvent
:
{
JS_ReportErrorASCII
(
cx
R
"
(
Unknown
event
:
[
"
%
s
"
"
%
s
"
"
%
s
"
]
)
"
PromiseFlatCString
(
aCategory
)
.
get
(
)
PromiseFlatCString
(
aMethod
)
.
get
(
)
PromiseFlatCString
(
aObject
)
.
get
(
)
)
;
return
NS_ERROR_INVALID_ARG
;
}
case
RecordEventResult
:
:
InvalidExtraKey
:
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Invalid
extra
key
for
event
.
"
)
)
;
return
NS_OK
;
case
RecordEventResult
:
:
StorageLimitReached
:
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Event
storage
limit
reached
.
"
)
)
;
return
NS_OK
;
default
:
return
NS_OK
;
}
}
nsresult
TelemetryEvent
:
:
CreateSnapshots
(
uint32_t
aDataset
bool
aClear
JSContext
*
cx
uint8_t
optional_argc
JS
:
:
MutableHandleValue
aResult
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsTArray
<
mozilla
:
:
Pair
<
const
char
*
EventRecordArray
>
>
processEvents
;
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
if
(
!
gInitDone
)
{
return
NS_ERROR_FAILURE
;
}
for
(
auto
iter
=
gEventRecords
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
EventRecordArray
*
eventStorage
=
static_cast
<
EventRecordArray
*
>
(
iter
.
Data
(
)
)
;
EventRecordArray
events
;
const
uint32_t
len
=
eventStorage
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
const
EventRecord
&
record
=
(
*
eventStorage
)
[
i
]
;
const
EventInfo
&
info
=
gEventInfo
[
record
.
EventId
(
)
]
;
if
(
IsInDataset
(
info
.
common_info
.
dataset
aDataset
)
)
{
events
.
AppendElement
(
record
)
;
}
}
if
(
events
.
Length
(
)
)
{
const
char
*
processName
=
GetNameForProcessID
(
ProcessID
(
iter
.
Key
(
)
)
)
;
processEvents
.
AppendElement
(
mozilla
:
:
MakePair
(
processName
events
)
)
;
}
}
if
(
aClear
)
{
gEventRecords
.
Clear
(
)
;
}
}
JS
:
:
RootedObject
rootObj
(
cx
JS_NewPlainObject
(
cx
)
)
;
if
(
!
rootObj
)
{
return
NS_ERROR_FAILURE
;
}
const
uint32_t
processLength
=
processEvents
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
processLength
;
+
+
i
)
{
JS
:
:
RootedObject
eventsArray
(
cx
)
;
if
(
NS_FAILED
(
SerializeEventsArray
(
processEvents
[
i
]
.
second
(
)
cx
&
eventsArray
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
JS_DefineProperty
(
cx
rootObj
processEvents
[
i
]
.
first
(
)
eventsArray
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
aResult
.
setObject
(
*
rootObj
)
;
return
NS_OK
;
}
void
TelemetryEvent
:
:
ClearEvents
(
)
{
StaticMutexAutoLock
lock
(
gTelemetryEventsMutex
)
;
if
(
!
gInitDone
)
{
return
;
}
gEventRecords
.
Clear
(
)
;
}
void
TelemetryEvent
:
:
SetEventRecordingEnabled
(
const
nsACString
&
category
bool
enabled
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
uint32_t
categoryId
;
if
(
!
gCategoryNameIDMap
.
Get
(
category
&
categoryId
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Unkown
category
for
SetEventRecordingEnabled
.
"
)
)
;
return
;
}
if
(
enabled
)
{
gEnabledCategories
.
PutEntry
(
categoryId
)
;
}
else
{
gEnabledCategories
.
RemoveEntry
(
categoryId
)
;
}
}
size_t
TelemetryEvent
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
size_t
n
=
0
;
n
+
=
gEventRecords
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
gEventRecords
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
EventRecordArray
*
eventRecords
=
static_cast
<
EventRecordArray
*
>
(
iter
.
Data
(
)
)
;
n
+
=
eventRecords
-
>
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
;
const
uint32_t
len
=
eventRecords
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
n
+
=
(
*
eventRecords
)
[
i
]
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
}
n
+
=
gEventNameIDMap
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
gEventNameIDMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
=
iter
.
Key
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
n
+
=
gCategoryNameIDMap
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
gCategoryNameIDMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
=
iter
.
Key
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
n
+
=
gEnabledCategories
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
n
;
}
