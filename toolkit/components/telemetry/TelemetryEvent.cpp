#
include
<
prtime
.
h
>
#
include
"
nsITelemetry
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
"
TelemetryCommon
.
h
"
#
include
"
TelemetryEvent
.
h
"
#
include
"
TelemetryEventData
.
h
"
using
mozilla
:
:
StaticMutex
;
using
mozilla
:
:
StaticMutexAutoLock
;
using
mozilla
:
:
ArrayLength
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Pair
;
using
mozilla
:
:
StaticAutoPtr
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
AutoHashtable
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsExpiredVersion
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
CanRecordDataset
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsInDataset
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
MsSinceProcessStart
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
LogToBrowserConsole
;
namespace
{
const
uint32_t
kEventCount
=
mozilla
:
:
Telemetry
:
:
EventID
:
:
EventCount
;
const
uint32_t
kExpiredEventId
=
kEventCount
+
1
;
static_assert
(
kEventCount
<
kExpiredEventId
"
Should
not
overflow
.
"
)
;
const
uint32_t
kMaxEventRecords
=
1000
;
const
uint32_t
kMaxValueByteLength
=
80
;
const
uint32_t
kMaxExtraValueByteLength
=
80
;
typedef
nsDataHashtable
<
nsCStringHashKey
uint32_t
>
EventMapType
;
typedef
nsClassHashtable
<
nsCStringHashKey
nsCString
>
StringMap
;
enum
class
RecordEventResult
{
Ok
UnknownEvent
InvalidExtraKey
StorageLimitReached
}
;
struct
ExtraEntry
{
const
nsCString
key
;
const
nsCString
value
;
}
;
typedef
nsTArray
<
ExtraEntry
>
ExtraArray
;
class
EventRecord
{
public
:
EventRecord
(
double
timestamp
uint32_t
eventId
const
Maybe
<
nsCString
>
&
value
const
ExtraArray
&
extra
)
:
mTimestamp
(
timestamp
)
mEventId
(
eventId
)
mValue
(
value
)
mExtra
(
extra
)
{
}
EventRecord
(
const
EventRecord
&
other
)
:
mTimestamp
(
other
.
mTimestamp
)
mEventId
(
other
.
mEventId
)
mValue
(
other
.
mValue
)
mExtra
(
other
.
mExtra
)
{
}
EventRecord
&
operator
=
(
const
EventRecord
&
other
)
=
delete
;
double
Timestamp
(
)
const
{
return
mTimestamp
;
}
uint32_t
EventId
(
)
const
{
return
mEventId
;
}
const
Maybe
<
nsCString
>
&
Value
(
)
const
{
return
mValue
;
}
const
ExtraArray
&
Extra
(
)
const
{
return
mExtra
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
const
double
mTimestamp
;
const
uint32_t
mEventId
;
const
Maybe
<
nsCString
>
mValue
;
const
ExtraArray
mExtra
;
}
;
const
char
*
EventInfo
:
:
method
(
)
const
{
return
&
gEventsStringTable
[
this
-
>
method_offset
]
;
}
const
char
*
EventInfo
:
:
object
(
)
const
{
return
&
gEventsStringTable
[
this
-
>
object_offset
]
;
}
const
char
*
CommonEventInfo
:
:
category
(
)
const
{
return
&
gEventsStringTable
[
this
-
>
category_offset
]
;
}
const
char
*
CommonEventInfo
:
:
expiration_version
(
)
const
{
return
&
gEventsStringTable
[
this
-
>
expiration_version_offset
]
;
}
const
char
*
CommonEventInfo
:
:
extra_key
(
uint32_t
index
)
const
{
MOZ_ASSERT
(
index
<
this
-
>
extra_count
)
;
uint32_t
key_index
=
gExtraKeysTable
[
this
-
>
extra_index
+
index
]
;
return
&
gEventsStringTable
[
key_index
]
;
}
size_t
EventRecord
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
if
(
mValue
)
{
n
+
=
mValue
.
value
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
n
+
=
mExtra
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
uint32_t
i
=
0
;
i
<
mExtra
.
Length
(
)
;
+
+
i
)
{
n
+
=
mExtra
[
i
]
.
key
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
n
+
=
mExtra
[
i
]
.
value
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
return
n
;
}
nsCString
UniqueEventName
(
const
nsACString
&
category
const
nsACString
&
method
const
nsACString
&
object
)
{
nsCString
name
;
name
.
Append
(
category
)
;
name
.
AppendLiteral
(
"
#
"
)
;
name
.
Append
(
method
)
;
name
.
AppendLiteral
(
"
#
"
)
;
name
.
Append
(
object
)
;
return
name
;
}
nsCString
UniqueEventName
(
const
EventInfo
&
info
)
{
return
UniqueEventName
(
nsDependentCString
(
info
.
common_info
.
category
(
)
)
nsDependentCString
(
info
.
method
(
)
)
nsDependentCString
(
info
.
object
(
)
)
)
;
}
bool
IsExpiredDate
(
uint32_t
expires_days_since_epoch
)
{
if
(
expires_days_since_epoch
=
=
0
)
{
return
false
;
}
const
uint32_t
days_since_epoch
=
PR_Now
(
)
/
(
PRTime
(
PR_USEC_PER_SEC
)
*
24
*
60
*
60
)
;
return
expires_days_since_epoch
<
=
days_since_epoch
;
}
void
TruncateToByteLength
(
nsCString
&
str
uint32_t
length
)
{
uint32_t
last
=
RewindToPriorUTF8Codepoint
(
str
.
get
(
)
length
)
;
str
.
Truncate
(
last
)
;
}
}
namespace
{
bool
gInitDone
=
false
;
bool
gCanRecordBase
;
bool
gCanRecordExtended
;
EventMapType
gEventNameIDMap
(
kEventCount
)
;
StaticAutoPtr
<
nsTArray
<
EventRecord
>
>
gEventRecords
;
}
namespace
{
bool
CanRecordEvent
(
const
StaticMutexAutoLock
&
lock
const
CommonEventInfo
&
info
)
{
if
(
!
gCanRecordBase
)
{
return
false
;
}
return
CanRecordDataset
(
info
.
dataset
gCanRecordBase
gCanRecordExtended
)
;
}
RecordEventResult
RecordEvent
(
const
StaticMutexAutoLock
&
lock
double
timestamp
const
nsACString
&
category
const
nsACString
&
method
const
nsACString
&
object
const
Maybe
<
nsCString
>
&
value
const
ExtraArray
&
extra
)
{
if
(
gEventRecords
-
>
Length
(
)
>
=
kMaxEventRecords
)
{
return
RecordEventResult
:
:
StorageLimitReached
;
}
const
nsCString
&
name
=
UniqueEventName
(
category
method
object
)
;
uint32_t
eventId
;
if
(
!
gEventNameIDMap
.
Get
(
name
&
eventId
)
)
{
return
RecordEventResult
:
:
UnknownEvent
;
}
if
(
eventId
=
=
kExpiredEventId
)
{
return
RecordEventResult
:
:
Ok
;
}
const
CommonEventInfo
&
common
=
gEventInfo
[
eventId
]
.
common_info
;
if
(
!
CanRecordEvent
(
lock
common
)
)
{
return
RecordEventResult
:
:
Ok
;
}
nsTHashtable
<
nsCStringHashKey
>
validExtraKeys
;
for
(
uint32_t
i
=
0
;
i
<
common
.
extra_count
;
+
+
i
)
{
validExtraKeys
.
PutEntry
(
nsDependentCString
(
common
.
extra_key
(
i
)
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
extra
.
Length
(
)
;
+
+
i
)
{
if
(
!
validExtraKeys
.
GetEntry
(
extra
[
i
]
.
key
)
)
{
return
RecordEventResult
:
:
InvalidExtraKey
;
}
}
gEventRecords
-
>
AppendElement
(
EventRecord
(
timestamp
eventId
value
extra
)
)
;
return
RecordEventResult
:
:
Ok
;
}
}
static
StaticMutex
gTelemetryEventsMutex
;
void
TelemetryEvent
:
:
InitializeGlobalState
(
bool
aCanRecordBase
bool
aCanRecordExtended
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
MOZ_ASSERT
(
!
gInitDone
"
TelemetryEvent
:
:
InitializeGlobalState
"
"
may
only
be
called
once
"
)
;
gCanRecordBase
=
aCanRecordBase
;
gCanRecordExtended
=
aCanRecordExtended
;
gEventRecords
=
new
nsTArray
<
EventRecord
>
(
)
;
const
uint32_t
eventCount
=
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
EventID
:
:
EventCount
)
;
for
(
uint32_t
i
=
0
;
i
<
eventCount
;
+
+
i
)
{
const
EventInfo
&
info
=
gEventInfo
[
i
]
;
uint32_t
eventId
=
i
;
if
(
IsExpiredVersion
(
info
.
common_info
.
expiration_version
(
)
)
|
|
IsExpiredDate
(
info
.
common_info
.
expiration_day
)
)
{
eventId
=
kExpiredEventId
;
}
gEventNameIDMap
.
Put
(
UniqueEventName
(
info
)
eventId
)
;
}
#
ifdef
DEBUG
gEventNameIDMap
.
MarkImmutable
(
)
;
#
endif
gInitDone
=
true
;
}
void
TelemetryEvent
:
:
DeInitializeGlobalState
(
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
MOZ_ASSERT
(
gInitDone
)
;
gCanRecordBase
=
false
;
gCanRecordExtended
=
false
;
gEventNameIDMap
.
Clear
(
)
;
gEventRecords
-
>
Clear
(
)
;
gEventRecords
=
nullptr
;
gInitDone
=
false
;
}
void
TelemetryEvent
:
:
SetCanRecordBase
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
gCanRecordBase
=
b
;
}
void
TelemetryEvent
:
:
SetCanRecordExtended
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
gCanRecordExtended
=
b
;
}
nsresult
TelemetryEvent
:
:
RecordEvent
(
const
nsACString
&
aCategory
const
nsACString
&
aMethod
const
nsACString
&
aObject
JS
:
:
HandleValue
aValue
JS
:
:
HandleValue
aExtra
JSContext
*
cx
uint8_t
optional_argc
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_OK
;
}
double
timestamp
=
-
1
;
nsresult
rv
=
MsSinceProcessStart
(
&
timestamp
)
;
if
(
NS_FAILED
(
rv
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Failed
to
get
time
since
process
start
.
"
)
)
;
return
NS_OK
;
}
if
(
(
optional_argc
>
0
)
&
&
!
aValue
.
isNull
(
)
&
&
!
aValue
.
isString
(
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Invalid
type
for
value
parameter
.
"
)
)
;
return
NS_OK
;
}
Maybe
<
nsCString
>
value
;
if
(
aValue
.
isString
(
)
)
{
nsAutoJSString
jsStr
;
if
(
!
jsStr
.
init
(
cx
aValue
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Invalid
string
value
for
value
parameter
.
"
)
)
;
return
NS_OK
;
}
nsCString
str
=
NS_ConvertUTF16toUTF8
(
jsStr
)
;
if
(
str
.
Length
(
)
>
kMaxValueByteLength
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Value
parameter
exceeds
maximum
string
length
truncating
.
"
)
)
;
TruncateToByteLength
(
str
kMaxValueByteLength
)
;
}
value
=
mozilla
:
:
Some
(
str
)
;
}
if
(
(
optional_argc
>
1
)
&
&
!
aExtra
.
isNull
(
)
&
&
!
aExtra
.
isObject
(
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Invalid
type
for
extra
parameter
.
"
)
)
;
return
NS_OK
;
}
ExtraArray
extra
;
if
(
aExtra
.
isObject
(
)
)
{
JS
:
:
RootedObject
obj
(
cx
&
aExtra
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
ids
(
cx
JS
:
:
IdVector
(
cx
)
)
;
if
(
!
JS_Enumerate
(
cx
obj
&
ids
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Failed
to
enumerate
object
.
"
)
)
;
return
NS_OK
;
}
for
(
size_t
i
=
0
n
=
ids
.
length
(
)
;
i
<
n
;
i
+
+
)
{
nsAutoJSString
key
;
if
(
!
key
.
init
(
cx
ids
[
i
]
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Extra
dictionary
should
only
contain
string
keys
.
"
)
)
;
return
NS_OK
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
)
;
if
(
!
JS_GetPropertyById
(
cx
obj
ids
[
i
]
&
value
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Failed
to
get
extra
property
.
"
)
)
;
return
NS_OK
;
}
nsAutoJSString
jsStr
;
if
(
!
value
.
isString
(
)
|
|
!
jsStr
.
init
(
cx
value
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Extra
properties
should
have
string
values
.
"
)
)
;
return
NS_OK
;
}
nsCString
str
=
NS_ConvertUTF16toUTF8
(
jsStr
)
;
if
(
str
.
Length
(
)
>
kMaxExtraValueByteLength
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Extra
value
exceeds
maximum
string
length
truncating
.
"
)
)
;
TruncateToByteLength
(
str
kMaxExtraValueByteLength
)
;
}
extra
.
AppendElement
(
ExtraEntry
{
NS_ConvertUTF16toUTF8
(
key
)
str
}
)
;
}
}
RecordEventResult
res
;
{
StaticMutexAutoLock
lock
(
gTelemetryEventsMutex
)
;
if
(
!
gInitDone
)
{
return
NS_ERROR_FAILURE
;
}
res
=
:
:
RecordEvent
(
lock
timestamp
aCategory
aMethod
aObject
value
extra
)
;
}
switch
(
res
)
{
case
RecordEventResult
:
:
UnknownEvent
:
JS_ReportErrorASCII
(
cx
"
Unknown
event
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
case
RecordEventResult
:
:
InvalidExtraKey
:
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Invalid
extra
key
for
event
.
"
)
)
;
return
NS_OK
;
case
RecordEventResult
:
:
StorageLimitReached
:
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Event
storage
limit
reached
.
"
)
)
;
return
NS_OK
;
default
:
return
NS_OK
;
}
}
nsresult
TelemetryEvent
:
:
CreateSnapshots
(
uint32_t
aDataset
bool
aClear
JSContext
*
cx
uint8_t
optional_argc
JS
:
:
MutableHandleValue
aResult
)
{
nsTArray
<
EventRecord
>
events
;
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
if
(
!
gInitDone
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
len
=
gEventRecords
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
const
EventRecord
&
record
=
(
*
gEventRecords
)
[
i
]
;
const
EventInfo
&
info
=
gEventInfo
[
record
.
EventId
(
)
]
;
if
(
IsInDataset
(
info
.
common_info
.
dataset
aDataset
)
)
{
events
.
AppendElement
(
record
)
;
}
}
if
(
aClear
)
{
gEventRecords
-
>
Clear
(
)
;
}
}
JS
:
:
RootedObject
eventsArray
(
cx
JS_NewArrayObject
(
cx
events
.
Length
(
)
)
)
;
if
(
!
eventsArray
)
{
return
NS_ERROR_FAILURE
;
}
for
(
uint32_t
i
=
0
;
i
<
events
.
Length
(
)
;
+
+
i
)
{
const
EventRecord
&
record
=
events
[
i
]
;
const
EventInfo
&
info
=
gEventInfo
[
record
.
EventId
(
)
]
;
JS
:
:
RootedObject
itemsArray
(
cx
JS_NewArrayObject
(
cx
6
)
)
;
if
(
!
itemsArray
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
cx
)
;
uint32_t
itemIndex
=
0
;
val
.
setDouble
(
floor
(
record
.
Timestamp
(
)
)
)
;
if
(
!
JS_DefineElement
(
cx
itemsArray
itemIndex
+
+
val
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
const
char
*
strings
[
]
=
{
info
.
common_info
.
category
(
)
info
.
method
(
)
info
.
object
(
)
}
;
for
(
uint32_t
s
=
0
;
s
<
ArrayLength
(
strings
)
;
+
+
s
)
{
const
NS_ConvertUTF8toUTF16
wide
(
strings
[
s
]
)
;
val
.
setString
(
JS_NewUCStringCopyN
(
cx
wide
.
Data
(
)
wide
.
Length
(
)
)
)
;
if
(
!
JS_DefineElement
(
cx
itemsArray
itemIndex
+
+
val
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
!
record
.
Value
(
)
)
{
val
.
setNull
(
)
;
}
else
{
const
NS_ConvertUTF8toUTF16
wide
(
record
.
Value
(
)
.
value
(
)
)
;
val
.
setString
(
JS_NewUCStringCopyN
(
cx
wide
.
Data
(
)
wide
.
Length
(
)
)
)
;
}
if
(
!
JS_DefineElement
(
cx
itemsArray
itemIndex
+
+
val
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
record
.
Extra
(
)
.
IsEmpty
(
)
)
{
val
.
setNull
(
)
;
}
else
{
JS
:
:
RootedObject
obj
(
cx
JS_NewPlainObject
(
cx
)
)
;
if
(
!
obj
)
{
return
NS_ERROR_FAILURE
;
}
const
ExtraArray
&
extra
=
record
.
Extra
(
)
;
for
(
uint32_t
i
=
0
;
i
<
extra
.
Length
(
)
;
+
+
i
)
{
const
NS_ConvertUTF8toUTF16
wide
(
extra
[
i
]
.
value
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
)
;
value
.
setString
(
JS_NewUCStringCopyN
(
cx
wide
.
Data
(
)
wide
.
Length
(
)
)
)
;
if
(
!
JS_DefineProperty
(
cx
obj
extra
[
i
]
.
key
.
get
(
)
value
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
val
.
setObject
(
*
obj
)
;
}
if
(
!
JS_DefineElement
(
cx
itemsArray
itemIndex
+
+
val
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
JS_DefineElement
(
cx
eventsArray
i
itemsArray
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
aResult
.
setObject
(
*
eventsArray
)
;
return
NS_OK
;
}
void
TelemetryEvent
:
:
ClearEvents
(
)
{
StaticMutexAutoLock
lock
(
gTelemetryEventsMutex
)
;
if
(
!
gInitDone
)
{
return
;
}
gEventRecords
-
>
Clear
(
)
;
}
size_t
TelemetryEvent
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
size_t
n
=
0
;
n
+
=
gEventRecords
-
>
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
;
for
(
uint32_t
i
=
0
;
i
<
gEventRecords
-
>
Length
(
)
;
+
+
i
)
{
n
+
=
(
*
gEventRecords
)
[
i
]
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
n
+
=
gEventNameIDMap
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
gEventNameIDMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
=
iter
.
Key
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
return
n
;
}
