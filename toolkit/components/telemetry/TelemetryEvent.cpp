#
include
<
prtime
.
h
>
#
include
<
limits
>
#
include
"
nsITelemetry
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
TelemetryCommon
.
h
"
#
include
"
TelemetryEvent
.
h
"
#
include
"
TelemetryEventData
.
h
"
#
include
"
ipc
/
TelemetryIPCAccumulator
.
h
"
using
mozilla
:
:
StaticMutex
;
using
mozilla
:
:
StaticMutexAutoLock
;
using
mozilla
:
:
ArrayLength
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Move
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
StaticAutoPtr
;
using
mozilla
:
:
TimeStamp
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
AutoHashtable
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsExpiredVersion
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
CanRecordDataset
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsInDataset
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
MsSinceProcessStart
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
LogToBrowserConsole
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
CanRecordInProcess
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
GetNameForProcessID
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
IsValidIdentifierString
;
using
mozilla
:
:
Telemetry
:
:
Common
:
:
ToJSString
;
using
mozilla
:
:
Telemetry
:
:
EventExtraEntry
;
using
mozilla
:
:
Telemetry
:
:
ChildEventData
;
using
mozilla
:
:
Telemetry
:
:
ProcessID
;
namespace
TelemetryIPCAccumulator
=
mozilla
:
:
TelemetryIPCAccumulator
;
namespace
{
const
uint32_t
kEventCount
=
mozilla
:
:
Telemetry
:
:
EventID
:
:
EventCount
;
const
uint32_t
kExpiredEventId
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
static_assert
(
kExpiredEventId
>
kEventCount
"
Built
-
in
event
count
should
be
less
than
the
expired
event
id
.
"
)
;
const
uint32_t
kMaxEventRecords
=
1000
;
const
uint32_t
kMaxValueByteLength
=
80
;
const
uint32_t
kMaxExtraValueByteLength
=
80
;
const
uint32_t
kMaxMethodNameByteLength
=
20
;
const
uint32_t
kMaxObjectNameByteLength
=
20
;
const
uint32_t
kMaxExtraKeyNameByteLength
=
15
;
const
uint32_t
kMaxExtraKeyCount
=
10
;
typedef
nsDataHashtable
<
nsCStringHashKey
uint32_t
>
StringUintMap
;
typedef
nsClassHashtable
<
nsCStringHashKey
nsCString
>
StringMap
;
struct
EventKey
{
uint32_t
id
;
bool
dynamic
;
}
;
struct
DynamicEventInfo
{
DynamicEventInfo
(
const
nsACString
&
category
const
nsACString
&
method
const
nsACString
&
object
nsTArray
<
nsCString
>
&
&
extra_keys
bool
recordOnRelease
)
:
category
(
category
)
method
(
method
)
object
(
object
)
extra_keys
(
Move
(
extra_keys
)
)
recordOnRelease
(
recordOnRelease
)
{
}
DynamicEventInfo
(
const
DynamicEventInfo
&
)
=
default
;
DynamicEventInfo
&
operator
=
(
const
DynamicEventInfo
&
)
=
delete
;
const
nsCString
category
;
const
nsCString
method
;
const
nsCString
object
;
const
nsTArray
<
nsCString
>
extra_keys
;
const
bool
recordOnRelease
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
n
+
=
category
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
n
+
=
method
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
n
+
=
object
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
n
+
=
extra_keys
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
&
key
:
extra_keys
)
{
n
+
=
key
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
return
n
;
}
}
;
enum
class
RecordEventResult
{
Ok
UnknownEvent
InvalidExtraKey
StorageLimitReached
ExpiredEvent
WrongProcess
}
;
typedef
nsTArray
<
EventExtraEntry
>
ExtraArray
;
class
EventRecord
{
public
:
EventRecord
(
double
timestamp
const
EventKey
&
key
const
Maybe
<
nsCString
>
&
value
const
ExtraArray
&
extra
)
:
mTimestamp
(
timestamp
)
mEventKey
(
key
)
mValue
(
value
)
mExtra
(
extra
)
{
}
EventRecord
(
const
EventRecord
&
other
)
=
default
;
EventRecord
&
operator
=
(
const
EventRecord
&
other
)
=
delete
;
double
Timestamp
(
)
const
{
return
mTimestamp
;
}
const
EventKey
&
GetEventKey
(
)
const
{
return
mEventKey
;
}
const
Maybe
<
nsCString
>
&
Value
(
)
const
{
return
mValue
;
}
const
ExtraArray
&
Extra
(
)
const
{
return
mExtra
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
const
double
mTimestamp
;
const
EventKey
mEventKey
;
const
Maybe
<
nsCString
>
mValue
;
const
ExtraArray
mExtra
;
}
;
const
nsDependentCString
EventInfo
:
:
method
(
)
const
{
return
nsDependentCString
(
&
gEventsStringTable
[
this
-
>
method_offset
]
)
;
}
const
nsDependentCString
EventInfo
:
:
object
(
)
const
{
return
nsDependentCString
(
&
gEventsStringTable
[
this
-
>
object_offset
]
)
;
}
const
nsDependentCString
CommonEventInfo
:
:
category
(
)
const
{
return
nsDependentCString
(
&
gEventsStringTable
[
this
-
>
category_offset
]
)
;
}
const
nsDependentCString
CommonEventInfo
:
:
expiration_version
(
)
const
{
return
nsDependentCString
(
&
gEventsStringTable
[
this
-
>
expiration_version_offset
]
)
;
}
const
nsDependentCString
CommonEventInfo
:
:
extra_key
(
uint32_t
index
)
const
{
MOZ_ASSERT
(
index
<
this
-
>
extra_count
)
;
uint32_t
key_index
=
gExtraKeysTable
[
this
-
>
extra_index
+
index
]
;
return
nsDependentCString
(
&
gEventsStringTable
[
key_index
]
)
;
}
size_t
EventRecord
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
if
(
mValue
)
{
n
+
=
mValue
.
value
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
n
+
=
mExtra
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
uint32_t
i
=
0
;
i
<
mExtra
.
Length
(
)
;
+
+
i
)
{
n
+
=
mExtra
[
i
]
.
key
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
n
+
=
mExtra
[
i
]
.
value
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
return
n
;
}
nsCString
UniqueEventName
(
const
nsACString
&
category
const
nsACString
&
method
const
nsACString
&
object
)
{
nsCString
name
;
name
.
Append
(
category
)
;
name
.
AppendLiteral
(
"
#
"
)
;
name
.
Append
(
method
)
;
name
.
AppendLiteral
(
"
#
"
)
;
name
.
Append
(
object
)
;
return
name
;
}
nsCString
UniqueEventName
(
const
EventInfo
&
info
)
{
return
UniqueEventName
(
info
.
common_info
.
category
(
)
info
.
method
(
)
info
.
object
(
)
)
;
}
nsCString
UniqueEventName
(
const
DynamicEventInfo
&
info
)
{
return
UniqueEventName
(
info
.
category
info
.
method
info
.
object
)
;
}
void
TruncateToByteLength
(
nsCString
&
str
uint32_t
length
)
{
uint32_t
last
=
RewindToPriorUTF8Codepoint
(
str
.
get
(
)
length
)
;
str
.
Truncate
(
last
)
;
}
}
namespace
{
bool
gInitDone
=
false
;
bool
gCanRecordBase
;
bool
gCanRecordExtended
;
nsClassHashtable
<
nsCStringHashKey
EventKey
>
gEventNameIDMap
(
kEventCount
)
;
StringUintMap
gCategoryNameIDMap
;
nsTHashtable
<
nsCStringHashKey
>
gEnabledCategories
;
typedef
nsTArray
<
EventRecord
>
EventRecordArray
;
nsClassHashtable
<
nsUint32HashKey
EventRecordArray
>
gEventRecords
;
StaticAutoPtr
<
nsTArray
<
DynamicEventInfo
>
>
gDynamicEventInfo
;
}
namespace
{
unsigned
int
GetDataset
(
const
StaticMutexAutoLock
&
lock
const
EventKey
&
eventKey
)
{
if
(
!
eventKey
.
dynamic
)
{
return
gEventInfo
[
eventKey
.
id
]
.
common_info
.
dataset
;
}
if
(
!
gDynamicEventInfo
)
{
return
nsITelemetry
:
:
DATASET_RELEASE_CHANNEL_OPTIN
;
}
return
(
*
gDynamicEventInfo
)
[
eventKey
.
id
]
.
recordOnRelease
?
nsITelemetry
:
:
DATASET_RELEASE_CHANNEL_OPTOUT
:
nsITelemetry
:
:
DATASET_RELEASE_CHANNEL_OPTIN
;
}
nsCString
GetCategory
(
const
StaticMutexAutoLock
&
lock
const
EventKey
&
eventKey
)
{
if
(
!
eventKey
.
dynamic
)
{
return
gEventInfo
[
eventKey
.
id
]
.
common_info
.
category
(
)
;
}
if
(
!
gDynamicEventInfo
)
{
return
NS_LITERAL_CSTRING
(
"
"
)
;
}
return
(
*
gDynamicEventInfo
)
[
eventKey
.
id
]
.
category
;
}
bool
CanRecordEvent
(
const
StaticMutexAutoLock
&
lock
const
EventKey
&
eventKey
ProcessID
process
)
{
if
(
!
gCanRecordBase
)
{
return
false
;
}
if
(
!
CanRecordDataset
(
GetDataset
(
lock
eventKey
)
gCanRecordBase
gCanRecordExtended
)
)
{
return
false
;
}
if
(
!
eventKey
.
dynamic
)
{
const
CommonEventInfo
&
info
=
gEventInfo
[
eventKey
.
id
]
.
common_info
;
if
(
!
CanRecordInProcess
(
info
.
record_in_processes
process
)
)
{
return
false
;
}
}
return
gEnabledCategories
.
GetEntry
(
GetCategory
(
lock
eventKey
)
)
;
}
bool
IsExpired
(
const
EventKey
&
key
)
{
return
key
.
id
=
=
kExpiredEventId
;
}
EventRecordArray
*
GetEventRecordsForProcess
(
const
StaticMutexAutoLock
&
lock
ProcessID
processType
const
EventKey
&
eventKey
)
{
EventRecordArray
*
eventRecords
=
nullptr
;
if
(
!
gEventRecords
.
Get
(
uint32_t
(
processType
)
&
eventRecords
)
)
{
eventRecords
=
new
EventRecordArray
(
)
;
gEventRecords
.
Put
(
uint32_t
(
processType
)
eventRecords
)
;
}
return
eventRecords
;
}
EventKey
*
GetEventKey
(
const
StaticMutexAutoLock
&
lock
const
nsACString
&
category
const
nsACString
&
method
const
nsACString
&
object
)
{
EventKey
*
event
;
const
nsCString
&
name
=
UniqueEventName
(
category
method
object
)
;
if
(
!
gEventNameIDMap
.
Get
(
name
&
event
)
)
{
return
nullptr
;
}
return
event
;
}
static
bool
CheckExtraKeysValid
(
const
EventKey
&
eventKey
const
ExtraArray
&
extra
)
{
nsTHashtable
<
nsCStringHashKey
>
validExtraKeys
;
if
(
!
eventKey
.
dynamic
)
{
const
CommonEventInfo
&
common
=
gEventInfo
[
eventKey
.
id
]
.
common_info
;
for
(
uint32_t
i
=
0
;
i
<
common
.
extra_count
;
+
+
i
)
{
validExtraKeys
.
PutEntry
(
common
.
extra_key
(
i
)
)
;
}
}
else
if
(
gDynamicEventInfo
)
{
const
DynamicEventInfo
&
info
=
(
*
gDynamicEventInfo
)
[
eventKey
.
id
]
;
for
(
uint32_t
i
=
0
len
=
info
.
extra_keys
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
validExtraKeys
.
PutEntry
(
info
.
extra_keys
[
i
]
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
extra
.
Length
(
)
;
+
+
i
)
{
if
(
!
validExtraKeys
.
GetEntry
(
extra
[
i
]
.
key
)
)
{
return
false
;
}
}
return
true
;
}
RecordEventResult
RecordEvent
(
const
StaticMutexAutoLock
&
lock
ProcessID
processType
double
timestamp
const
nsACString
&
category
const
nsACString
&
method
const
nsACString
&
object
const
Maybe
<
nsCString
>
&
value
const
ExtraArray
&
extra
)
{
EventKey
*
eventKey
=
GetEventKey
(
lock
category
method
object
)
;
if
(
!
eventKey
)
{
return
RecordEventResult
:
:
UnknownEvent
;
}
if
(
eventKey
-
>
dynamic
)
{
processType
=
ProcessID
:
:
Dynamic
;
}
EventRecordArray
*
eventRecords
=
GetEventRecordsForProcess
(
lock
processType
*
eventKey
)
;
if
(
eventRecords
-
>
Length
(
)
>
=
kMaxEventRecords
)
{
return
RecordEventResult
:
:
StorageLimitReached
;
}
if
(
IsExpired
(
*
eventKey
)
)
{
return
RecordEventResult
:
:
ExpiredEvent
;
}
if
(
!
CanRecordEvent
(
lock
*
eventKey
processType
)
)
{
return
RecordEventResult
:
:
Ok
;
}
if
(
!
CheckExtraKeysValid
(
*
eventKey
extra
)
)
{
return
RecordEventResult
:
:
InvalidExtraKey
;
}
eventRecords
-
>
AppendElement
(
EventRecord
(
timestamp
*
eventKey
value
extra
)
)
;
return
RecordEventResult
:
:
Ok
;
}
RecordEventResult
ShouldRecordChildEvent
(
const
StaticMutexAutoLock
&
lock
const
nsACString
&
category
const
nsACString
&
method
const
nsACString
&
object
)
{
EventKey
*
eventKey
=
GetEventKey
(
lock
category
method
object
)
;
if
(
!
eventKey
)
{
return
RecordEventResult
:
:
Ok
;
}
if
(
IsExpired
(
*
eventKey
)
)
{
return
RecordEventResult
:
:
ExpiredEvent
;
}
const
auto
processes
=
gEventInfo
[
eventKey
-
>
id
]
.
common_info
.
record_in_processes
;
if
(
!
CanRecordInProcess
(
processes
XRE_GetProcessType
(
)
)
)
{
return
RecordEventResult
:
:
WrongProcess
;
}
return
RecordEventResult
:
:
Ok
;
}
void
RegisterEvents
(
const
StaticMutexAutoLock
&
lock
const
nsACString
&
category
const
nsTArray
<
DynamicEventInfo
>
&
eventInfos
const
nsTArray
<
bool
>
&
eventExpired
)
{
MOZ_ASSERT
(
eventInfos
.
Length
(
)
=
=
eventExpired
.
Length
(
)
"
Event
data
array
sizes
should
match
.
"
)
;
if
(
!
gDynamicEventInfo
)
{
gDynamicEventInfo
=
new
nsTArray
<
DynamicEventInfo
>
(
)
;
}
for
(
uint32_t
i
=
0
len
=
eventInfos
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
const
nsCString
&
eventName
=
UniqueEventName
(
eventInfos
[
i
]
)
;
EventKey
*
existing
=
nullptr
;
if
(
gEventNameIDMap
.
Get
(
eventName
&
existing
)
)
{
if
(
eventExpired
[
i
]
)
{
existing
-
>
id
=
kExpiredEventId
;
}
continue
;
}
gDynamicEventInfo
-
>
AppendElement
(
eventInfos
[
i
]
)
;
uint32_t
eventId
=
eventExpired
[
i
]
?
kExpiredEventId
:
gDynamicEventInfo
-
>
Length
(
)
-
1
;
gEventNameIDMap
.
Put
(
eventName
new
EventKey
{
eventId
true
}
)
;
}
gEnabledCategories
.
PutEntry
(
category
)
;
}
}
namespace
{
nsresult
SerializeEventsArray
(
const
EventRecordArray
&
events
JSContext
*
cx
JS
:
:
MutableHandleObject
result
unsigned
int
dataset
)
{
JS
:
:
RootedObject
eventsArray
(
cx
JS_NewArrayObject
(
cx
events
.
Length
(
)
)
)
;
if
(
!
eventsArray
)
{
return
NS_ERROR_FAILURE
;
}
for
(
uint32_t
i
=
0
;
i
<
events
.
Length
(
)
;
+
+
i
)
{
const
EventRecord
&
record
=
events
[
i
]
;
JS
:
:
AutoValueVector
items
(
cx
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
cx
)
;
if
(
!
items
.
append
(
JS
:
:
NumberValue
(
floor
(
record
.
Timestamp
(
)
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
auto
addCategoryMethodObjectValues
=
[
&
]
(
const
nsACString
&
category
const
nsACString
&
method
const
nsACString
&
object
)
-
>
bool
{
return
items
.
append
(
JS
:
:
StringValue
(
ToJSString
(
cx
category
)
)
)
&
&
items
.
append
(
JS
:
:
StringValue
(
ToJSString
(
cx
method
)
)
)
&
&
items
.
append
(
JS
:
:
StringValue
(
ToJSString
(
cx
object
)
)
)
;
}
;
const
EventKey
&
eventKey
=
record
.
GetEventKey
(
)
;
if
(
!
eventKey
.
dynamic
)
{
const
EventInfo
&
info
=
gEventInfo
[
eventKey
.
id
]
;
if
(
!
addCategoryMethodObjectValues
(
info
.
common_info
.
category
(
)
info
.
method
(
)
info
.
object
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
if
(
gDynamicEventInfo
)
{
const
DynamicEventInfo
&
info
=
(
*
gDynamicEventInfo
)
[
eventKey
.
id
]
;
if
(
!
addCategoryMethodObjectValues
(
info
.
category
info
.
method
info
.
object
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
record
.
Value
(
)
)
{
if
(
!
items
.
append
(
JS
:
:
StringValue
(
ToJSString
(
cx
record
.
Value
(
)
.
value
(
)
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
if
(
!
record
.
Extra
(
)
.
IsEmpty
(
)
)
{
if
(
!
items
.
append
(
JS
:
:
NullValue
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
!
record
.
Extra
(
)
.
IsEmpty
(
)
)
{
JS
:
:
RootedObject
obj
(
cx
JS_NewPlainObject
(
cx
)
)
;
if
(
!
obj
)
{
return
NS_ERROR_FAILURE
;
}
const
ExtraArray
&
extra
=
record
.
Extra
(
)
;
for
(
uint32_t
i
=
0
;
i
<
extra
.
Length
(
)
;
+
+
i
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
)
;
value
.
setString
(
ToJSString
(
cx
extra
[
i
]
.
value
)
)
;
if
(
!
JS_DefineProperty
(
cx
obj
extra
[
i
]
.
key
.
get
(
)
value
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
val
.
setObject
(
*
obj
)
;
if
(
!
items
.
append
(
val
)
)
{
return
NS_ERROR_FAILURE
;
}
}
JS
:
:
RootedObject
itemsArray
(
cx
JS_NewArrayObject
(
cx
items
)
)
;
if
(
!
JS_DefineElement
(
cx
eventsArray
i
itemsArray
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
result
.
set
(
eventsArray
)
;
return
NS_OK
;
}
}
static
StaticMutex
gTelemetryEventsMutex
;
void
TelemetryEvent
:
:
InitializeGlobalState
(
bool
aCanRecordBase
bool
aCanRecordExtended
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
MOZ_ASSERT
(
!
gInitDone
"
TelemetryEvent
:
:
InitializeGlobalState
"
"
may
only
be
called
once
"
)
;
gCanRecordBase
=
aCanRecordBase
;
gCanRecordExtended
=
aCanRecordExtended
;
const
uint32_t
eventCount
=
static_cast
<
uint32_t
>
(
mozilla
:
:
Telemetry
:
:
EventID
:
:
EventCount
)
;
for
(
uint32_t
i
=
0
;
i
<
eventCount
;
+
+
i
)
{
const
EventInfo
&
info
=
gEventInfo
[
i
]
;
uint32_t
eventId
=
i
;
if
(
IsExpiredVersion
(
info
.
common_info
.
expiration_version
(
)
.
get
(
)
)
)
{
eventId
=
kExpiredEventId
;
}
gEventNameIDMap
.
Put
(
UniqueEventName
(
info
)
new
EventKey
{
eventId
false
}
)
;
if
(
!
gCategoryNameIDMap
.
Contains
(
info
.
common_info
.
category
(
)
)
)
{
gCategoryNameIDMap
.
Put
(
info
.
common_info
.
category
(
)
info
.
common_info
.
category_offset
)
;
}
}
#
ifdef
DEBUG
gCategoryNameIDMap
.
MarkImmutable
(
)
;
#
endif
gInitDone
=
true
;
}
void
TelemetryEvent
:
:
DeInitializeGlobalState
(
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
MOZ_ASSERT
(
gInitDone
)
;
gCanRecordBase
=
false
;
gCanRecordExtended
=
false
;
gEventNameIDMap
.
Clear
(
)
;
gCategoryNameIDMap
.
Clear
(
)
;
gEnabledCategories
.
Clear
(
)
;
gEventRecords
.
Clear
(
)
;
gDynamicEventInfo
=
nullptr
;
gInitDone
=
false
;
}
void
TelemetryEvent
:
:
SetCanRecordBase
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
gCanRecordBase
=
b
;
}
void
TelemetryEvent
:
:
SetCanRecordExtended
(
bool
b
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
gCanRecordExtended
=
b
;
}
nsresult
TelemetryEvent
:
:
RecordChildEvents
(
ProcessID
aProcessType
const
nsTArray
<
mozilla
:
:
Telemetry
:
:
ChildEventData
>
&
aEvents
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
for
(
uint32_t
i
=
0
;
i
<
aEvents
.
Length
(
)
;
+
+
i
)
{
const
mozilla
:
:
Telemetry
:
:
ChildEventData
&
e
=
aEvents
[
i
]
;
double
relativeTimestamp
=
(
e
.
timestamp
-
TimeStamp
:
:
ProcessCreation
(
)
)
.
ToMilliseconds
(
)
;
:
:
RecordEvent
(
locker
aProcessType
relativeTimestamp
e
.
category
e
.
method
e
.
object
e
.
value
e
.
extra
)
;
}
return
NS_OK
;
}
nsresult
TelemetryEvent
:
:
RecordEvent
(
const
nsACString
&
aCategory
const
nsACString
&
aMethod
const
nsACString
&
aObject
JS
:
:
HandleValue
aValue
JS
:
:
HandleValue
aExtra
JSContext
*
cx
uint8_t
optional_argc
)
{
if
(
(
optional_argc
>
0
)
&
&
!
aValue
.
isNull
(
)
&
&
!
aValue
.
isString
(
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Invalid
type
for
value
parameter
.
"
)
)
;
return
NS_OK
;
}
Maybe
<
nsCString
>
value
;
if
(
aValue
.
isString
(
)
)
{
nsAutoJSString
jsStr
;
if
(
!
jsStr
.
init
(
cx
aValue
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Invalid
string
value
for
value
parameter
.
"
)
)
;
return
NS_OK
;
}
nsCString
str
=
NS_ConvertUTF16toUTF8
(
jsStr
)
;
if
(
str
.
Length
(
)
>
kMaxValueByteLength
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Value
parameter
exceeds
maximum
string
length
truncating
.
"
)
)
;
TruncateToByteLength
(
str
kMaxValueByteLength
)
;
}
value
=
mozilla
:
:
Some
(
str
)
;
}
if
(
(
optional_argc
>
1
)
&
&
!
aExtra
.
isNull
(
)
&
&
!
aExtra
.
isObject
(
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Invalid
type
for
extra
parameter
.
"
)
)
;
return
NS_OK
;
}
ExtraArray
extra
;
if
(
aExtra
.
isObject
(
)
)
{
JS
:
:
RootedObject
obj
(
cx
&
aExtra
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
ids
(
cx
JS
:
:
IdVector
(
cx
)
)
;
if
(
!
JS_Enumerate
(
cx
obj
&
ids
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Failed
to
enumerate
object
.
"
)
)
;
return
NS_OK
;
}
for
(
size_t
i
=
0
n
=
ids
.
length
(
)
;
i
<
n
;
i
+
+
)
{
nsAutoJSString
key
;
if
(
!
key
.
init
(
cx
ids
[
i
]
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Extra
dictionary
should
only
contain
string
keys
.
"
)
)
;
return
NS_OK
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
)
;
if
(
!
JS_GetPropertyById
(
cx
obj
ids
[
i
]
&
value
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Failed
to
get
extra
property
.
"
)
)
;
return
NS_OK
;
}
nsAutoJSString
jsStr
;
if
(
!
value
.
isString
(
)
|
|
!
jsStr
.
init
(
cx
value
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Extra
properties
should
have
string
values
.
"
)
)
;
return
NS_OK
;
}
nsCString
str
=
NS_ConvertUTF16toUTF8
(
jsStr
)
;
if
(
str
.
Length
(
)
>
kMaxExtraValueByteLength
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Extra
value
exceeds
maximum
string
length
truncating
.
"
)
)
;
TruncateToByteLength
(
str
kMaxExtraValueByteLength
)
;
}
extra
.
AppendElement
(
EventExtraEntry
{
NS_ConvertUTF16toUTF8
(
key
)
str
}
)
;
}
}
RecordEventResult
res
;
if
(
!
XRE_IsParentProcess
(
)
)
{
{
StaticMutexAutoLock
lock
(
gTelemetryEventsMutex
)
;
res
=
:
:
ShouldRecordChildEvent
(
lock
aCategory
aMethod
aObject
)
;
}
if
(
res
=
=
RecordEventResult
:
:
Ok
)
{
TelemetryIPCAccumulator
:
:
RecordChildEvent
(
TimeStamp
:
:
NowLoRes
(
)
aCategory
aMethod
aObject
value
extra
)
;
}
}
else
{
StaticMutexAutoLock
lock
(
gTelemetryEventsMutex
)
;
if
(
!
gInitDone
)
{
return
NS_ERROR_FAILURE
;
}
double
timestamp
=
-
1
;
if
(
NS_WARN_IF
(
NS_FAILED
(
MsSinceProcessStart
(
&
timestamp
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
res
=
:
:
RecordEvent
(
lock
ProcessID
:
:
Parent
timestamp
aCategory
aMethod
aObject
value
extra
)
;
}
switch
(
res
)
{
case
RecordEventResult
:
:
UnknownEvent
:
{
JS_ReportErrorASCII
(
cx
R
"
(
Unknown
event
:
[
"
%
s
"
"
%
s
"
"
%
s
"
]
)
"
PromiseFlatCString
(
aCategory
)
.
get
(
)
PromiseFlatCString
(
aMethod
)
.
get
(
)
PromiseFlatCString
(
aObject
)
.
get
(
)
)
;
return
NS_ERROR_INVALID_ARG
;
}
case
RecordEventResult
:
:
InvalidExtraKey
:
{
nsPrintfCString
msg
(
R
"
(
Invalid
extra
key
for
event
[
"
%
s
"
"
%
s
"
"
%
s
"
]
.
)
"
PromiseFlatCString
(
aCategory
)
.
get
(
)
PromiseFlatCString
(
aMethod
)
.
get
(
)
PromiseFlatCString
(
aObject
)
.
get
(
)
)
;
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_ConvertUTF8toUTF16
(
msg
)
)
;
return
NS_OK
;
}
case
RecordEventResult
:
:
StorageLimitReached
:
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Event
storage
limit
reached
.
"
)
)
;
return
NS_OK
;
default
:
return
NS_OK
;
}
}
static
bool
GetArrayPropertyValues
(
JSContext
*
cx
JS
:
:
HandleObject
obj
const
char
*
property
nsTArray
<
nsCString
>
*
results
)
{
JS
:
:
RootedValue
value
(
cx
)
;
if
(
!
JS_GetProperty
(
cx
obj
property
&
value
)
)
{
JS_ReportErrorASCII
(
cx
R
"
(
Missing
required
property
"
%
s
"
for
event
)
"
property
)
;
return
false
;
}
bool
isArray
=
false
;
if
(
!
JS_IsArrayObject
(
cx
value
&
isArray
)
|
|
!
isArray
)
{
JS_ReportErrorASCII
(
cx
R
"
(
Property
"
%
s
"
for
event
should
be
an
array
)
"
property
)
;
return
false
;
}
JS
:
:
RootedObject
arrayObj
(
cx
&
value
.
toObject
(
)
)
;
uint32_t
arrayLength
;
if
(
!
JS_GetArrayLength
(
cx
arrayObj
&
arrayLength
)
)
{
return
false
;
}
for
(
uint32_t
arrayIdx
=
0
;
arrayIdx
<
arrayLength
;
+
+
arrayIdx
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
element
(
cx
)
;
if
(
!
JS_GetElement
(
cx
arrayObj
arrayIdx
&
element
)
)
{
return
false
;
}
if
(
!
element
.
isString
(
)
)
{
JS_ReportErrorASCII
(
cx
R
"
(
Array
entries
for
event
property
"
%
s
"
should
be
strings
)
"
property
)
;
return
false
;
}
nsAutoJSString
jsStr
;
if
(
!
jsStr
.
init
(
cx
element
)
)
{
return
false
;
}
results
-
>
AppendElement
(
NS_ConvertUTF16toUTF8
(
jsStr
)
)
;
}
return
true
;
}
nsresult
TelemetryEvent
:
:
RegisterEvents
(
const
nsACString
&
aCategory
JS
:
:
Handle
<
JS
:
:
Value
>
aEventData
JSContext
*
cx
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Events
can
only
be
registered
in
the
parent
process
"
)
;
if
(
!
IsValidIdentifierString
(
aCategory
30
true
false
)
)
{
JS_ReportErrorASCII
(
cx
"
Category
parameter
should
match
the
identifier
pattern
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
aEventData
.
isObject
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Event
data
parameter
should
be
an
object
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
JS
:
:
RootedObject
obj
(
cx
&
aEventData
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
eventPropertyIds
(
cx
JS
:
:
IdVector
(
cx
)
)
;
if
(
!
JS_Enumerate
(
cx
obj
&
eventPropertyIds
)
)
{
return
NS_ERROR_FAILURE
;
}
nsTArray
<
DynamicEventInfo
>
newEventInfos
;
nsTArray
<
bool
>
newEventExpired
;
for
(
size_t
i
=
0
n
=
eventPropertyIds
.
length
(
)
;
i
<
n
;
i
+
+
)
{
nsAutoJSString
eventName
;
if
(
!
eventName
.
init
(
cx
eventPropertyIds
[
i
]
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsValidIdentifierString
(
NS_ConvertUTF16toUTF8
(
eventName
)
kMaxMethodNameByteLength
false
true
)
)
{
JS_ReportErrorASCII
(
cx
"
Event
names
should
match
the
identifier
pattern
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
JS
:
:
RootedValue
value
(
cx
)
;
if
(
!
JS_GetPropertyById
(
cx
obj
eventPropertyIds
[
i
]
&
value
)
|
|
!
value
.
isObject
(
)
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedObject
eventObj
(
cx
&
value
.
toObject
(
)
)
;
nsTArray
<
nsCString
>
methods
;
nsTArray
<
nsCString
>
objects
;
nsTArray
<
nsCString
>
extra_keys
;
bool
expired
=
false
;
bool
recordOnRelease
=
false
;
if
(
!
GetArrayPropertyValues
(
cx
eventObj
"
methods
"
&
methods
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
GetArrayPropertyValues
(
cx
eventObj
"
objects
"
&
objects
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
hasProperty
=
false
;
if
(
JS_HasProperty
(
cx
eventObj
"
extra_keys
"
&
hasProperty
)
&
&
hasProperty
)
{
if
(
!
GetArrayPropertyValues
(
cx
eventObj
"
extra_keys
"
&
extra_keys
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
JS_HasProperty
(
cx
eventObj
"
expired
"
&
hasProperty
)
&
&
hasProperty
)
{
JS
:
:
RootedValue
temp
(
cx
)
;
if
(
!
JS_GetProperty
(
cx
eventObj
"
expired
"
&
temp
)
|
|
!
temp
.
isBoolean
(
)
)
{
return
NS_ERROR_FAILURE
;
}
expired
=
temp
.
toBoolean
(
)
;
}
if
(
JS_HasProperty
(
cx
eventObj
"
record_on_release
"
&
hasProperty
)
&
&
hasProperty
)
{
JS
:
:
RootedValue
temp
(
cx
)
;
if
(
!
JS_GetProperty
(
cx
eventObj
"
record_on_release
"
&
temp
)
|
|
!
temp
.
isBoolean
(
)
)
{
return
NS_ERROR_FAILURE
;
}
recordOnRelease
=
temp
.
toBoolean
(
)
;
}
for
(
auto
&
method
:
methods
)
{
if
(
!
IsValidIdentifierString
(
method
kMaxMethodNameByteLength
false
false
)
)
{
JS_ReportErrorASCII
(
cx
"
Method
names
should
match
the
identifier
pattern
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
for
(
auto
&
object
:
objects
)
{
if
(
!
IsValidIdentifierString
(
object
kMaxObjectNameByteLength
false
true
)
)
{
JS_ReportErrorASCII
(
cx
"
Object
names
should
match
the
identifier
pattern
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
if
(
extra_keys
.
Length
(
)
>
kMaxExtraKeyCount
)
{
JS_ReportErrorASCII
(
cx
"
No
more
than
10
extra
keys
can
be
registered
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
for
(
auto
&
key
:
extra_keys
)
{
if
(
!
IsValidIdentifierString
(
key
kMaxExtraKeyNameByteLength
false
false
)
)
{
JS_ReportErrorASCII
(
cx
"
Extra
key
names
should
match
the
identifier
pattern
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
for
(
auto
&
method
:
methods
)
{
for
(
auto
&
object
:
objects
)
{
DynamicEventInfo
info
{
aCategory
method
object
Move
(
extra_keys
)
recordOnRelease
}
;
newEventInfos
.
AppendElement
(
info
)
;
newEventExpired
.
AppendElement
(
expired
)
;
}
}
}
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
RegisterEvents
(
locker
aCategory
newEventInfos
newEventExpired
)
;
}
return
NS_OK
;
}
nsresult
TelemetryEvent
:
:
CreateSnapshots
(
uint32_t
aDataset
bool
aClear
JSContext
*
cx
uint8_t
optional_argc
JS
:
:
MutableHandleValue
aResult
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsTArray
<
mozilla
:
:
Pair
<
const
char
*
EventRecordArray
>
>
processEvents
;
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
if
(
!
gInitDone
)
{
return
NS_ERROR_FAILURE
;
}
for
(
auto
iter
=
gEventRecords
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
EventRecordArray
*
eventStorage
=
static_cast
<
EventRecordArray
*
>
(
iter
.
Data
(
)
)
;
EventRecordArray
events
;
const
uint32_t
len
=
eventStorage
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
const
EventRecord
&
record
=
(
*
eventStorage
)
[
i
]
;
if
(
IsInDataset
(
GetDataset
(
locker
record
.
GetEventKey
(
)
)
aDataset
)
)
{
events
.
AppendElement
(
record
)
;
}
}
if
(
events
.
Length
(
)
)
{
const
char
*
processName
=
GetNameForProcessID
(
ProcessID
(
iter
.
Key
(
)
)
)
;
processEvents
.
AppendElement
(
mozilla
:
:
MakePair
(
processName
Move
(
events
)
)
)
;
}
}
if
(
aClear
)
{
gEventRecords
.
Clear
(
)
;
}
}
JS
:
:
RootedObject
rootObj
(
cx
JS_NewPlainObject
(
cx
)
)
;
if
(
!
rootObj
)
{
return
NS_ERROR_FAILURE
;
}
const
uint32_t
processLength
=
processEvents
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
processLength
;
+
+
i
)
{
JS
:
:
RootedObject
eventsArray
(
cx
)
;
if
(
NS_FAILED
(
SerializeEventsArray
(
processEvents
[
i
]
.
second
(
)
cx
&
eventsArray
aDataset
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
JS_DefineProperty
(
cx
rootObj
processEvents
[
i
]
.
first
(
)
eventsArray
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
aResult
.
setObject
(
*
rootObj
)
;
return
NS_OK
;
}
void
TelemetryEvent
:
:
ClearEvents
(
)
{
StaticMutexAutoLock
lock
(
gTelemetryEventsMutex
)
;
if
(
!
gInitDone
)
{
return
;
}
gEventRecords
.
Clear
(
)
;
}
void
TelemetryEvent
:
:
SetEventRecordingEnabled
(
const
nsACString
&
category
bool
enabled
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
uint32_t
categoryId
;
if
(
!
gCategoryNameIDMap
.
Get
(
category
&
categoryId
)
)
{
LogToBrowserConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_STRING
(
"
Unkown
category
for
SetEventRecordingEnabled
.
"
)
)
;
return
;
}
if
(
enabled
)
{
gEnabledCategories
.
PutEntry
(
category
)
;
}
else
{
gEnabledCategories
.
RemoveEntry
(
category
)
;
}
}
size_t
TelemetryEvent
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
StaticMutexAutoLock
locker
(
gTelemetryEventsMutex
)
;
size_t
n
=
0
;
n
+
=
gEventRecords
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
gEventRecords
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
EventRecordArray
*
eventRecords
=
static_cast
<
EventRecordArray
*
>
(
iter
.
Data
(
)
)
;
n
+
=
eventRecords
-
>
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
;
const
uint32_t
len
=
eventRecords
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
n
+
=
(
*
eventRecords
)
[
i
]
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
}
n
+
=
gEventNameIDMap
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
gEventNameIDMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
=
iter
.
Key
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
n
+
=
gCategoryNameIDMap
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
gCategoryNameIDMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
=
iter
.
Key
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
n
+
=
gEnabledCategories
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
if
(
gDynamicEventInfo
)
{
n
+
=
gDynamicEventInfo
-
>
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
;
for
(
auto
&
info
:
*
gDynamicEventInfo
)
{
n
+
=
info
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
}
return
n
;
}
