"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
TelemetryUtils
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
this
)
;
const
MILLISECONDS_PER_DAY
=
24
*
60
*
60
*
1000
;
const
PREF_TELEMETRY_ENABLED
=
"
toolkit
.
telemetry
.
enabled
"
;
const
IS_CONTENT_PROCESS
=
(
function
(
)
{
let
runtime
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
return
runtime
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
;
}
)
(
)
;
this
.
TelemetryUtils
=
{
get
isContentProcess
(
)
{
return
IS_CONTENT_PROCESS
;
}
get
isTelemetryEnabled
(
)
{
return
Preferences
.
get
(
PREF_TELEMETRY_ENABLED
false
)
=
=
=
true
;
}
millisecondsToDays
:
function
(
aMsec
)
{
return
Math
.
floor
(
aMsec
/
MILLISECONDS_PER_DAY
)
;
}
truncateToDays
:
function
(
date
)
{
return
new
Date
(
date
.
getFullYear
(
)
date
.
getMonth
(
)
date
.
getDate
(
)
0
0
0
0
)
;
}
areTimesClose
:
function
(
t1
t2
tolerance
)
{
return
Math
.
abs
(
t1
-
t2
)
<
=
tolerance
;
}
getNextMidnight
:
function
(
date
)
{
let
nextMidnight
=
new
Date
(
this
.
truncateToDays
(
date
)
)
;
nextMidnight
.
setDate
(
nextMidnight
.
getDate
(
)
+
1
)
;
return
nextMidnight
;
}
getNearestMidnight
:
function
(
date
tolerance
)
{
let
lastMidnight
=
this
.
truncateToDays
(
date
)
;
if
(
this
.
areTimesClose
(
date
.
getTime
(
)
lastMidnight
.
getTime
(
)
tolerance
)
)
{
return
lastMidnight
;
}
const
nextMidnightDate
=
this
.
getNextMidnight
(
date
)
;
if
(
this
.
areTimesClose
(
date
.
getTime
(
)
nextMidnightDate
.
getTime
(
)
tolerance
)
)
{
return
nextMidnightDate
;
}
return
null
;
}
generateUUID
:
function
(
)
{
let
str
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
return
str
.
substring
(
1
str
.
length
-
1
)
;
}
getElapsedTimeInMonths
:
function
(
aStartDate
aEndDate
)
{
return
(
aEndDate
.
getMonth
(
)
-
aStartDate
.
getMonth
(
)
)
+
12
*
(
aEndDate
.
getFullYear
(
)
-
aStartDate
.
getFullYear
(
)
)
;
}
toLocalTimeISOString
:
function
(
date
)
{
function
padNumber
(
number
places
)
{
number
=
number
.
toString
(
)
;
while
(
number
.
length
<
places
)
{
number
=
"
0
"
+
number
;
}
return
number
;
}
let
sign
=
(
n
)
=
>
n
>
=
0
?
"
+
"
:
"
-
"
;
let
tzOffset
=
-
date
.
getTimezoneOffset
(
)
;
return
padNumber
(
date
.
getFullYear
(
)
4
)
+
"
-
"
+
padNumber
(
date
.
getMonth
(
)
+
1
2
)
+
"
-
"
+
padNumber
(
date
.
getDate
(
)
2
)
+
"
T
"
+
padNumber
(
date
.
getHours
(
)
2
)
+
"
:
"
+
padNumber
(
date
.
getMinutes
(
)
2
)
+
"
:
"
+
padNumber
(
date
.
getSeconds
(
)
2
)
+
"
.
"
+
date
.
getMilliseconds
(
)
+
sign
(
tzOffset
)
+
padNumber
(
Math
.
floor
(
Math
.
abs
(
tzOffset
/
60
)
)
2
)
+
"
:
"
+
padNumber
(
Math
.
abs
(
tzOffset
%
60
)
2
)
;
}
}
;
