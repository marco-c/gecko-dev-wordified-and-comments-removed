#
include
"
KeyedStackCapturer
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
include
"
ProcessedStack
.
h
"
#
include
"
jsapi
.
h
"
namespace
{
const
uint8_t
kMaxKeyLength
=
50
;
const
size_t
kMaxCapturedStacksKept
=
50
;
bool
IsKeyCharValid
(
const
char
aChar
)
{
return
(
aChar
>
=
'
A
'
&
&
aChar
<
=
'
Z
'
)
|
|
(
aChar
>
=
'
a
'
&
&
aChar
<
=
'
z
'
)
|
|
(
aChar
>
=
'
0
'
&
&
aChar
<
=
'
9
'
)
|
|
aChar
=
=
'
-
'
;
}
bool
IsKeyValid
(
const
nsACString
&
aKey
)
{
if
(
aKey
.
Length
(
)
>
kMaxKeyLength
)
{
return
false
;
}
const
char
*
cur
=
aKey
.
BeginReading
(
)
;
const
char
*
end
=
aKey
.
EndReading
(
)
;
for
(
;
cur
<
end
;
+
+
cur
)
{
if
(
!
IsKeyCharValid
(
*
cur
)
)
{
return
false
;
}
}
return
true
;
}
}
namespace
mozilla
{
namespace
Telemetry
{
void
KeyedStackCapturer
:
:
Capture
(
const
nsACString
&
aKey
)
{
MutexAutoLock
captureStackMutex
(
mStackCapturerMutex
)
;
if
(
!
IsKeyValid
(
aKey
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
Invalid
key
is
used
to
capture
stack
in
telemetry
:
'
%
s
'
"
PromiseFlatCString
(
aKey
)
.
get
(
)
)
.
get
(
)
)
;
return
;
}
StackFrequencyInfo
*
info
=
mStackInfos
.
Get
(
aKey
)
;
if
(
info
)
{
info
-
>
mCount
+
+
;
return
;
}
if
(
mStackInfos
.
Count
(
)
>
=
kMaxCapturedStacksKept
)
{
return
;
}
std
:
:
vector
<
uintptr_t
>
rawStack
;
auto
callback
=
[
]
(
uint32_t
void
*
aPC
void
*
void
*
aClosure
)
{
std
:
:
vector
<
uintptr_t
>
*
stack
=
static_cast
<
std
:
:
vector
<
uintptr_t
>
*
>
(
aClosure
)
;
stack
-
>
push_back
(
reinterpret_cast
<
uintptr_t
>
(
aPC
)
)
;
}
;
MozStackWalk
(
callback
0
0
&
rawStack
)
;
ProcessedStack
stack
=
GetStackAndModules
(
rawStack
)
;
size_t
stackIndex
=
mStacks
.
AddStack
(
stack
)
;
mStackInfos
.
Put
(
aKey
new
StackFrequencyInfo
(
1
stackIndex
)
)
;
}
NS_IMETHODIMP
KeyedStackCapturer
:
:
ReflectCapturedStacks
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
ret
)
{
MutexAutoLock
capturedStackMutex
(
mStackCapturerMutex
)
;
JS
:
:
RootedObject
fullReportObj
(
cx
CreateJSStackObject
(
cx
mStacks
)
)
;
if
(
!
fullReportObj
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedObject
keysArray
(
cx
JS_NewArrayObject
(
cx
0
)
)
;
if
(
!
keysArray
)
{
return
NS_ERROR_FAILURE
;
}
bool
ok
=
JS_DefineProperty
(
cx
fullReportObj
"
captures
"
keysArray
JSPROP_ENUMERATE
)
;
if
(
!
ok
)
{
return
NS_ERROR_FAILURE
;
}
size_t
keyIndex
=
0
;
for
(
auto
iter
=
mStackInfos
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
+
+
keyIndex
)
{
const
StackFrequencyInfo
*
info
=
iter
.
Data
(
)
;
JS
:
:
RootedObject
infoArray
(
cx
JS_NewArrayObject
(
cx
0
)
)
;
if
(
!
keysArray
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedString
str
(
cx
JS_NewStringCopyZ
(
cx
PromiseFlatCString
(
iter
.
Key
(
)
)
.
get
(
)
)
)
;
if
(
!
str
|
|
!
JS_DefineElement
(
cx
infoArray
0
str
JSPROP_ENUMERATE
)
|
|
!
JS_DefineElement
(
cx
infoArray
1
info
-
>
mIndex
JSPROP_ENUMERATE
)
|
|
!
JS_DefineElement
(
cx
infoArray
2
info
-
>
mCount
JSPROP_ENUMERATE
)
|
|
!
JS_DefineElement
(
cx
keysArray
keyIndex
infoArray
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
ret
.
setObject
(
*
fullReportObj
)
;
return
NS_OK
;
}
void
KeyedStackCapturer
:
:
Clear
(
)
{
MutexAutoLock
captureStackMutex
(
mStackCapturerMutex
)
;
mStackInfos
.
Clear
(
)
;
mStacks
.
Clear
(
)
;
}
size_t
KeyedStackCapturer
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
n
+
=
mStackInfos
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
n
+
=
mStacks
.
SizeOfExcludingThis
(
)
;
return
n
;
}
}
}
