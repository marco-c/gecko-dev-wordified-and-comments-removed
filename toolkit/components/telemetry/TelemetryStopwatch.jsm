const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
Cu
=
Components
.
utils
;
this
.
EXPORTED_SYMBOLS
=
[
"
TelemetryStopwatch
"
]
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
this
)
;
var
Telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
const
NULL_OBJECT
=
{
}
;
const
NULL_KEY
=
{
}
;
let
Timers
=
{
_timers
:
new
Map
(
)
_validTypes
(
histogram
obj
key
)
{
let
nonEmptyString
=
value
=
>
{
return
typeof
value
=
=
=
"
string
"
&
&
value
!
=
=
"
"
&
&
value
.
length
>
0
;
}
;
return
nonEmptyString
(
histogram
)
&
&
typeof
obj
=
=
"
object
"
&
&
(
key
=
=
=
NULL_KEY
|
|
nonEmptyString
(
key
)
)
;
}
get
(
histogram
obj
key
)
{
key
=
key
=
=
=
null
?
NULL_KEY
:
key
;
obj
=
obj
|
|
NULL_OBJECT
;
if
(
!
this
.
has
(
histogram
obj
key
)
)
{
return
null
;
}
return
this
.
_timers
.
get
(
histogram
)
.
get
(
obj
)
.
get
(
key
)
;
}
put
(
histogram
obj
key
startTime
)
{
key
=
key
=
=
=
null
?
NULL_KEY
:
key
;
obj
=
obj
|
|
NULL_OBJECT
;
if
(
!
this
.
_validTypes
(
histogram
obj
key
)
)
{
return
false
;
}
let
objectMap
=
this
.
_timers
.
get
(
histogram
)
|
|
new
WeakMap
(
)
;
let
keyedInfo
=
objectMap
.
get
(
obj
)
|
|
new
Map
(
)
;
keyedInfo
.
set
(
key
startTime
)
;
objectMap
.
set
(
obj
keyedInfo
)
;
this
.
_timers
.
set
(
histogram
objectMap
)
;
return
true
;
}
has
(
histogram
obj
key
)
{
key
=
key
=
=
=
null
?
NULL_KEY
:
key
;
obj
=
obj
|
|
NULL_OBJECT
;
return
this
.
_timers
.
has
(
histogram
)
&
&
this
.
_timers
.
get
(
histogram
)
.
has
(
obj
)
&
&
this
.
_timers
.
get
(
histogram
)
.
get
(
obj
)
.
has
(
key
)
;
}
delete
(
histogram
obj
key
)
{
key
=
key
=
=
=
null
?
NULL_KEY
:
key
;
obj
=
obj
|
|
NULL_OBJECT
;
if
(
!
this
.
has
(
histogram
obj
key
)
)
{
return
false
;
}
let
objectMap
=
this
.
_timers
.
get
(
histogram
)
;
let
keyedInfo
=
objectMap
.
get
(
obj
)
;
if
(
keyedInfo
.
size
>
1
)
{
keyedInfo
.
delete
(
key
)
;
return
true
;
}
objectMap
.
delete
(
obj
)
;
return
true
;
}
}
;
this
.
TelemetryStopwatch
=
{
start
(
aHistogram
aObj
)
{
return
TelemetryStopwatchImpl
.
start
(
aHistogram
aObj
null
)
;
}
cancel
(
aHistogram
aObj
)
{
return
TelemetryStopwatchImpl
.
cancel
(
aHistogram
aObj
null
)
;
}
timeElapsed
(
aHistogram
aObj
aCanceledOkay
)
{
return
TelemetryStopwatchImpl
.
timeElapsed
(
aHistogram
aObj
null
aCanceledOkay
)
;
}
finish
(
aHistogram
aObj
aCanceledOkay
)
{
return
TelemetryStopwatchImpl
.
finish
(
aHistogram
aObj
null
aCanceledOkay
)
;
}
startKeyed
(
aHistogram
aKey
aObj
)
{
return
TelemetryStopwatchImpl
.
start
(
aHistogram
aObj
aKey
)
;
}
cancelKeyed
(
aHistogram
aKey
aObj
)
{
return
TelemetryStopwatchImpl
.
cancel
(
aHistogram
aObj
aKey
)
;
}
timeElapsedKeyed
(
aHistogram
aKey
aObj
aCanceledOkay
)
{
return
TelemetryStopwatchImpl
.
timeElapsed
(
aHistogram
aObj
aKey
aCanceledOkay
)
;
}
finishKeyed
(
aHistogram
aKey
aObj
aCanceledOkay
)
{
return
TelemetryStopwatchImpl
.
finish
(
aHistogram
aObj
aKey
aCanceledOkay
)
;
}
}
;
this
.
TelemetryStopwatchImpl
=
{
start
(
histogram
object
key
)
{
if
(
Timers
.
has
(
histogram
object
key
)
)
{
Timers
.
delete
(
histogram
object
key
)
;
Cu
.
reportError
(
TelemetryStopwatch
:
key
"
{
histogram
}
"
was
already
+
"
initialized
"
)
;
return
false
;
}
return
Timers
.
put
(
histogram
object
key
Components
.
utils
.
now
(
)
)
;
}
cancel
(
histogram
object
key
)
{
return
Timers
.
delete
(
histogram
object
key
)
;
}
timeElapsed
(
histogram
object
key
aCanceledOkay
)
{
let
startTime
=
Timers
.
get
(
histogram
object
key
)
;
if
(
startTime
=
=
=
null
)
{
if
(
!
aCanceledOkay
)
{
Cu
.
reportError
(
"
TelemetryStopwatch
:
requesting
elapsed
time
for
"
+
nonexisting
stopwatch
.
Histogram
:
"
{
histogram
}
"
+
key
:
"
{
key
}
"
)
;
}
return
-
1
;
}
try
{
let
delta
=
Components
.
utils
.
now
(
)
-
startTime
return
Math
.
round
(
delta
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
TelemetryStopwatch
:
failed
to
calculate
elapsed
time
"
+
for
Histogram
:
"
{
histogram
}
"
key
:
"
{
key
}
"
+
exception
:
{
Log
.
exceptionStr
(
e
)
}
)
;
return
-
1
;
}
}
finish
(
histogram
object
key
aCanceledOkay
)
{
let
delta
=
this
.
timeElapsed
(
histogram
object
key
aCanceledOkay
)
;
if
(
delta
=
=
-
1
)
{
return
false
;
}
try
{
if
(
key
)
{
Telemetry
.
getKeyedHistogramById
(
histogram
)
.
add
(
key
delta
)
;
}
else
{
Telemetry
.
getHistogramById
(
histogram
)
.
add
(
delta
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
"
TelemetryStopwatch
:
failed
to
update
the
Histogram
"
+
"
{
histogram
}
"
using
key
:
"
{
key
}
"
+
exception
:
{
Log
.
exceptionStr
(
e
)
}
)
;
return
false
;
}
return
Timers
.
delete
(
histogram
object
key
)
;
}
}
