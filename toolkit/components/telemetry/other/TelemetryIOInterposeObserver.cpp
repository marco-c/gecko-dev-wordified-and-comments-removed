#
include
"
TelemetryIOInterposeObserver
.
h
"
#
include
"
core
/
TelemetryCommon
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
ValueArray
.
h
"
#
include
"
nsIFile
.
h
"
namespace
mozilla
:
:
Telemetry
{
TelemetryIOInterposeObserver
:
:
TelemetryIOInterposeObserver
(
nsIFile
*
aXreDir
)
:
mCurStage
(
STAGE_STARTUP
)
{
nsAutoString
xreDirPath
;
nsresult
rv
=
aXreDir
-
>
GetPath
(
xreDirPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
AddPath
(
xreDirPath
u
"
{
xre
}
"
_ns
)
;
}
}
void
TelemetryIOInterposeObserver
:
:
AddPath
(
const
nsAString
&
aPath
const
nsAString
&
aSubstName
)
{
mSafeDirs
.
AppendElement
(
SafeDir
(
aPath
aSubstName
)
)
;
}
const
TimeDuration
kTelemetryReportThreshold
=
TimeDuration
:
:
FromMilliseconds
(
50
)
;
void
TelemetryIOInterposeObserver
:
:
Observe
(
Observation
&
aOb
)
{
if
(
!
IsMainThread
(
)
)
{
return
;
}
if
(
aOb
.
ObservedOperation
(
)
=
=
OpNextStage
)
{
mCurStage
=
NextStage
(
mCurStage
)
;
MOZ_ASSERT
(
mCurStage
<
NUM_STAGES
)
;
return
;
}
if
(
aOb
.
Duration
(
)
<
kTelemetryReportThreshold
)
{
return
;
}
nsAutoString
filename
;
aOb
.
Filename
(
filename
)
;
if
(
filename
.
IsEmpty
(
)
)
{
return
;
}
#
if
defined
(
XP_WIN
)
auto
comparator
=
nsCaseInsensitiveStringComparator
;
#
else
auto
comparator
=
nsTDefaultStringComparator
<
char16_t
>
;
#
endif
nsAutoString
processedName
;
uint32_t
safeDirsLen
=
mSafeDirs
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
safeDirsLen
;
+
+
i
)
{
if
(
StringBeginsWith
(
filename
mSafeDirs
[
i
]
.
mPath
comparator
)
)
{
processedName
=
mSafeDirs
[
i
]
.
mSubstName
;
processedName
+
=
Substring
(
filename
mSafeDirs
[
i
]
.
mPath
.
Length
(
)
)
;
break
;
}
}
if
(
processedName
.
IsEmpty
(
)
)
{
return
;
}
FileIOEntryType
*
entry
=
mFileStats
.
PutEntry
(
processedName
)
;
if
(
entry
)
{
FileStats
&
stats
=
entry
-
>
GetModifiableData
(
)
-
>
mStats
[
mCurStage
]
;
stats
.
totalTime
+
=
(
double
)
aOb
.
Duration
(
)
.
ToMilliseconds
(
)
;
switch
(
aOb
.
ObservedOperation
(
)
)
{
case
OpCreateOrOpen
:
stats
.
creates
+
+
;
break
;
case
OpRead
:
stats
.
reads
+
+
;
break
;
case
OpWrite
:
stats
.
writes
+
+
;
break
;
case
OpFSync
:
stats
.
fsyncs
+
+
;
break
;
case
OpStat
:
stats
.
stats
+
+
;
break
;
default
:
break
;
}
}
}
bool
TelemetryIOInterposeObserver
:
:
ReflectFileStats
(
FileIOEntryType
*
entry
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
)
{
JS
:
:
RootedValueArray
<
NUM_STAGES
>
stages
(
cx
)
;
FileStatsByStage
&
statsByStage
=
*
entry
-
>
GetModifiableData
(
)
;
for
(
int
s
=
STAGE_STARTUP
;
s
<
NUM_STAGES
;
+
+
s
)
{
FileStats
&
fileStats
=
statsByStage
.
mStats
[
s
]
;
if
(
fileStats
.
totalTime
=
=
0
&
&
fileStats
.
creates
=
=
0
&
&
fileStats
.
reads
=
=
0
&
&
fileStats
.
writes
=
=
0
&
&
fileStats
.
fsyncs
=
=
0
&
&
fileStats
.
stats
=
=
0
)
{
stages
[
s
]
.
setNull
(
)
;
continue
;
}
JS
:
:
RootedValueArray
<
6
>
stats
(
cx
)
;
stats
[
0
]
.
setNumber
(
fileStats
.
totalTime
)
;
stats
[
1
]
.
setNumber
(
fileStats
.
creates
)
;
stats
[
2
]
.
setNumber
(
fileStats
.
reads
)
;
stats
[
3
]
.
setNumber
(
fileStats
.
writes
)
;
stats
[
4
]
.
setNumber
(
fileStats
.
fsyncs
)
;
stats
[
5
]
.
setNumber
(
fileStats
.
stats
)
;
JS
:
:
Rooted
<
JSObject
*
>
jsStats
(
cx
JS
:
:
NewArrayObject
(
cx
stats
)
)
;
if
(
!
jsStats
)
{
continue
;
}
stages
[
s
]
.
setObject
(
*
jsStats
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
jsEntry
(
cx
JS
:
:
NewArrayObject
(
cx
stages
)
)
;
if
(
!
jsEntry
)
{
return
false
;
}
const
nsAString
&
key
=
entry
-
>
GetKey
(
)
;
return
JS_DefineUCProperty
(
cx
obj
key
.
Data
(
)
key
.
Length
(
)
jsEntry
JSPROP_ENUMERATE
|
JSPROP_READONLY
)
;
}
bool
TelemetryIOInterposeObserver
:
:
ReflectIntoJS
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
rootObj
)
{
return
mFileStats
.
ReflectIntoJS
(
ReflectFileStats
cx
rootObj
)
;
}
size_t
TelemetryIOInterposeObserver
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
TelemetryIOInterposeObserver
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
size
=
0
;
size
+
=
mFileStats
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mFileStats
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
size
+
=
iter
.
Get
(
)
-
>
GetKey
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
size
+
=
mSafeDirs
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
uint32_t
safeDirsLen
=
mSafeDirs
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
safeDirsLen
;
+
+
i
)
{
size
+
=
mSafeDirs
[
i
]
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
return
size
;
}
}
