"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
GCTelemetry
"
]
;
const
PROCESS_NAMES
=
[
"
main
"
"
content
"
]
;
const
BASE_TIME
=
Date
.
now
(
)
-
Services
.
telemetry
.
msSinceProcessStart
(
)
;
class
GCData
{
constructor
(
kind
)
{
let
numRandom
=
{
main
:
0
content
:
2
}
;
let
numWorst
=
{
main
:
2
content
:
2
}
;
this
.
totalGCTime
=
0
;
this
.
randomlySelected
=
Array
(
numRandom
[
kind
]
)
.
fill
(
null
)
;
this
.
worst
=
Array
(
numWorst
[
kind
]
)
.
fill
(
null
)
;
}
rebaseTimes
(
data
)
{
function
fixup
(
t
)
{
return
t
/
1000
.
0
-
BASE_TIME
;
}
data
.
timestamp
=
fixup
(
data
.
timestamp
)
;
for
(
let
i
=
0
;
i
<
data
.
slices_list
.
length
;
i
+
+
)
{
let
slice
=
data
.
slices_list
[
i
]
;
slice
.
start_timestamp
=
fixup
(
slice
.
start_timestamp
)
;
}
}
record
(
data
)
{
this
.
rebaseTimes
(
data
)
;
let
time
=
data
.
total_time
;
this
.
totalGCTime
+
=
time
;
let
prob
=
time
/
this
.
totalGCTime
;
for
(
let
i
=
0
;
i
<
this
.
randomlySelected
.
length
;
i
+
+
)
{
let
r
=
Math
.
random
(
)
;
if
(
r
<
=
prob
)
{
this
.
randomlySelected
[
i
]
=
data
;
}
}
for
(
let
i
=
0
;
i
<
this
.
worst
.
length
;
i
+
+
)
{
if
(
!
this
.
worst
[
i
]
)
{
this
.
worst
[
i
]
=
data
;
break
;
}
if
(
this
.
worst
[
i
]
.
max_pause
<
data
.
max_pause
)
{
this
.
worst
.
splice
(
i
0
data
)
;
this
.
worst
.
length
-
-
;
break
;
}
}
}
entries
(
)
{
return
{
random
:
this
.
randomlySelected
.
filter
(
e
=
>
e
!
=
=
null
)
worst
:
this
.
worst
.
filter
(
e
=
>
e
!
=
=
null
)
}
;
}
}
const
MAX_GC_KEYS
=
24
;
const
MAX_SLICES
=
4
;
const
MAX_SLICE_KEYS
=
12
;
const
MAX_PHASES
=
65
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
function
limitProperties
(
name
obj
count
log
)
{
let
num_properties
=
Object
.
keys
(
obj
)
.
length
;
if
(
num_properties
>
count
)
{
for
(
let
key
of
Object
.
keys
(
obj
)
)
{
if
(
name
=
=
=
"
data
"
&
&
(
key
=
=
=
"
max_pause
"
|
|
key
=
=
=
"
slices
"
|
|
key
=
=
=
"
slices_list
"
|
|
key
=
=
=
"
status
"
|
|
key
=
=
=
"
timestamp
"
|
|
key
=
=
=
"
total_time
"
|
|
key
=
=
=
"
totals
"
)
)
{
continue
;
}
delete
obj
[
key
]
;
}
let
log_fn
;
if
(
(
name
=
=
=
"
slice
.
times
"
)
|
|
(
name
=
=
=
"
data
.
totals
"
)
)
{
log_fn
=
s
=
>
log
.
info
(
s
)
;
}
else
{
log_fn
=
s
=
>
log
.
warn
(
s
)
;
}
log_fn
(
Number
of
properties
exceeded
in
the
GC
telemetry
{
name
}
ping
expected
{
count
}
got
{
num_properties
}
)
;
}
}
function
limitSize
(
data
log
)
{
data
.
slices_list
.
sort
(
(
a
b
)
=
>
b
.
pause
-
a
.
pause
)
;
if
(
data
.
slices_list
.
length
>
MAX_SLICES
)
{
let
firstSliceIndex
=
data
.
slices_list
.
findIndex
(
s
=
>
s
.
slice
=
=
0
)
;
if
(
firstSliceIndex
>
=
MAX_SLICES
)
{
data
.
slices_list
[
MAX_SLICES
-
1
]
=
data
.
slices_list
[
firstSliceIndex
]
;
}
data
.
slices_list
.
length
=
MAX_SLICES
;
}
data
.
slices_list
.
sort
(
(
a
b
)
=
>
a
.
slice
-
b
.
slice
)
;
limitProperties
(
"
data
"
data
MAX_GC_KEYS
log
)
;
for
(
let
slice
of
data
.
slices_list
)
{
limitProperties
(
"
slice
"
slice
MAX_SLICE_KEYS
log
)
;
limitProperties
(
"
slice
.
times
"
slice
.
times
MAX_PHASES
log
)
;
}
limitProperties
(
"
data
.
totals
"
data
.
totals
MAX_PHASES
log
)
;
}
let
processData
=
new
Map
(
)
;
for
(
let
name
of
PROCESS_NAMES
)
{
processData
.
set
(
name
new
GCData
(
name
)
)
;
}
var
GCTelemetry
=
{
initialized
:
false
init
(
)
{
if
(
this
.
initialized
)
{
return
false
;
}
this
.
initialized
=
true
;
this
.
_log
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
"
GCTelemetry
:
:
"
)
;
Services
.
obs
.
addObserver
(
this
"
garbage
-
collection
-
statistics
"
)
;
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
Services
.
ppmm
.
addMessageListener
(
"
Telemetry
:
GCStatistics
"
this
)
;
}
return
true
;
}
shutdown
(
)
{
if
(
!
this
.
initialized
)
{
return
;
}
Services
.
obs
.
removeObserver
(
this
"
garbage
-
collection
-
statistics
"
)
;
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
Services
.
ppmm
.
removeMessageListener
(
"
Telemetry
:
GCStatistics
"
this
)
;
}
this
.
initialized
=
false
;
}
observe
(
subject
topic
arg
)
{
this
.
observeRaw
(
JSON
.
parse
(
arg
)
)
;
}
observeRaw
(
data
)
{
limitSize
(
data
this
.
_log
)
;
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
processData
.
get
(
"
main
"
)
.
record
(
data
)
;
}
else
{
Services
.
cpmm
.
sendAsyncMessage
(
"
Telemetry
:
GCStatistics
"
data
)
;
}
}
receiveMessage
(
msg
)
{
processData
.
get
(
"
content
"
)
.
record
(
msg
.
data
)
;
}
entries
(
kind
clear
)
{
let
result
=
processData
.
get
(
kind
)
.
entries
(
)
;
if
(
clear
)
{
processData
.
set
(
kind
new
GCData
(
kind
)
)
;
}
return
result
;
}
}
;
