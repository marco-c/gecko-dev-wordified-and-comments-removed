"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
GCTelemetry
:
"
resource
:
/
/
gre
/
modules
/
GCTelemetry
.
jsm
"
}
)
;
const
Utils
=
TelemetryUtils
;
const
LOGGER_NAME
=
"
Toolkit
.
Telemetry
"
;
const
LOGGER_PREFIX
=
"
MemoryTelemetry
"
+
(
Utils
.
isContentProcess
?
"
#
content
:
:
"
:
"
:
:
"
)
;
const
MESSAGE_TELEMETRY_USS
=
"
Telemetry
:
USS
"
;
const
MESSAGE_TELEMETRY_GET_CHILD_USS
=
"
Telemetry
:
GetChildUSS
"
;
const
TELEMETRY_INTERVAL
=
60
*
1000
;
const
TELEMETRY_DELAY
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
telemetry
.
initDelay
"
60
)
*
1000
;
const
TELEMETRY_TEST_DELAY
=
1
;
const
TOPIC_CYCLE_COLLECTOR_BEGIN
=
"
cycle
-
collector
-
begin
"
;
const
TOTAL_MEMORY_COLLECTOR_TIMEOUT
=
200
;
var
gLastMemoryPoll
=
null
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
Telemetry
:
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
"
nsITelemetry
"
]
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
MemoryTelemetry
"
]
;
var
MemoryTelemetry
=
Object
.
freeze
(
{
gatherMemory
(
)
{
return
Impl
.
gatherMemory
(
)
;
}
shutdown
(
)
{
return
Impl
.
shutdown
(
)
;
}
setupContent
(
testing
=
false
)
{
return
Impl
.
setupContent
(
testing
)
;
}
earlyInit
(
aTesting
=
false
)
{
return
Impl
.
earlyInit
(
aTesting
)
;
}
delayedInit
(
)
{
return
Impl
.
delayedInit
(
)
;
}
}
)
;
var
Impl
=
{
_initialized
:
false
_logger
:
null
_prevValues
:
{
}
_delayedInitTask
:
null
_totalMemoryTimeout
:
undefined
_testing
:
false
_totalMemory
:
null
_childrenToHearFrom
:
null
_nextTotalMemoryId
:
1
_USSFromChildProcesses
:
null
_observedTopics
:
new
Set
(
)
addObserver
(
aTopic
)
{
Services
.
obs
.
addObserver
(
this
aTopic
)
;
this
.
_observedTopics
.
add
(
aTopic
)
;
}
removeObserver
(
aTopic
)
{
Services
.
obs
.
removeObserver
(
this
aTopic
)
;
this
.
_observedTopics
.
delete
(
aTopic
)
;
}
get
_log
(
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLoggerWithMessagePrefix
(
LOGGER_NAME
LOGGER_PREFIX
)
;
}
return
this
.
_logger
;
}
gatherMemory
:
function
gatherMemory
(
)
{
let
mgr
;
try
{
mgr
=
Cc
[
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIMemoryReporterManager
)
;
}
catch
(
e
)
{
return
Promise
.
resolve
(
)
;
}
let
histogram
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_MEMORY_REPORTER_MS
"
)
;
let
startTime
=
new
Date
(
)
;
let
boundHandleMemoryReport
=
this
.
handleMemoryReport
.
bind
(
this
)
;
let
h
=
(
id
units
amountName
)
=
>
{
try
{
let
amount
=
mgr
[
amountName
]
;
if
(
amount
=
=
=
undefined
)
{
this
.
_log
.
error
(
"
gatherMemory
-
telemetry
accessed
an
unknown
distinguished
amount
"
)
;
}
boundHandleMemoryReport
(
id
units
amount
)
;
}
catch
(
e
)
{
}
}
;
let
b
=
(
id
n
)
=
>
h
(
id
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
n
)
;
let
c
=
(
id
n
)
=
>
h
(
id
Ci
.
nsIMemoryReporter
.
UNITS_COUNT
n
)
;
let
cc
=
(
id
n
)
=
>
h
(
id
Ci
.
nsIMemoryReporter
.
UNITS_COUNT_CUMULATIVE
n
)
;
let
p
=
(
id
n
)
=
>
h
(
id
Ci
.
nsIMemoryReporter
.
UNITS_PERCENTAGE
n
)
;
c
(
"
GHOST_WINDOWS
"
"
ghostWindows
"
)
;
if
(
!
Telemetry
.
canRecordExtended
)
{
return
Promise
.
resolve
(
)
;
}
b
(
"
MEMORY_VSIZE
"
"
vsize
"
)
;
if
(
!
Services
.
appinfo
.
is64Bit
|
|
AppConstants
.
platform
!
=
=
"
win
"
)
{
b
(
"
MEMORY_VSIZE_MAX_CONTIGUOUS
"
"
vsizeMaxContiguous
"
)
;
}
b
(
"
MEMORY_RESIDENT_FAST
"
"
residentFast
"
)
;
b
(
"
MEMORY_UNIQUE
"
"
residentUnique
"
)
;
p
(
"
MEMORY_HEAP_OVERHEAD_FRACTION
"
"
heapOverheadFraction
"
)
;
b
(
"
MEMORY_JS_GC_HEAP
"
"
JSMainRuntimeGCHeap
"
)
;
c
(
"
MEMORY_JS_COMPARTMENTS_SYSTEM
"
"
JSMainRuntimeRealmsSystem
"
)
;
c
(
"
MEMORY_JS_COMPARTMENTS_USER
"
"
JSMainRuntimeRealmsUser
"
)
;
b
(
"
MEMORY_IMAGES_CONTENT_USED_UNCOMPRESSED
"
"
imagesContentUsedUncompressed
"
)
;
b
(
"
MEMORY_STORAGE_SQLITE
"
"
storageSQLite
"
)
;
cc
(
"
LOW_MEMORY_EVENTS_VIRTUAL
"
"
lowMemoryEventsVirtual
"
)
;
cc
(
"
LOW_MEMORY_EVENTS_COMMIT_SPACE
"
"
lowMemoryEventsCommitSpace
"
)
;
cc
(
"
LOW_MEMORY_EVENTS_PHYSICAL
"
"
lowMemoryEventsPhysical
"
)
;
cc
(
"
PAGE_FAULTS_HARD
"
"
pageFaultsHard
"
)
;
let
promise
=
new
Promise
(
resolve
=
>
{
try
{
mgr
.
getHeapAllocatedAsync
(
heapAllocated
=
>
{
boundHandleMemoryReport
(
"
MEMORY_HEAP_ALLOCATED
"
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
heapAllocated
)
;
resolve
(
)
;
}
)
;
}
catch
(
e
)
{
resolve
(
)
;
}
}
)
;
if
(
!
Utils
.
isContentProcess
&
&
!
this
.
_totalMemoryTimeout
)
{
this
.
_totalMemory
=
mgr
.
residentFast
;
if
(
Services
.
ppmm
.
childCount
>
1
)
{
this
.
_totalMemoryTimeout
=
setTimeout
(
(
)
=
>
{
this
.
_totalMemoryTimeout
=
undefined
;
this
.
_childrenToHearFrom
.
clear
(
)
;
}
TOTAL_MEMORY_COLLECTOR_TIMEOUT
)
;
this
.
_USSFromChildProcesses
=
[
]
;
this
.
_childrenToHearFrom
=
new
Set
(
)
;
for
(
let
i
=
1
;
i
<
Services
.
ppmm
.
childCount
;
i
+
+
)
{
let
child
=
Services
.
ppmm
.
getChildAt
(
i
)
;
try
{
child
.
sendAsyncMessage
(
MESSAGE_TELEMETRY_GET_CHILD_USS
{
id
:
this
.
_nextTotalMemoryId
}
)
;
this
.
_childrenToHearFrom
.
add
(
this
.
_nextTotalMemoryId
)
;
this
.
_nextTotalMemoryId
+
+
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
else
{
boundHandleMemoryReport
(
"
MEMORY_TOTAL
"
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
this
.
_totalMemory
)
;
}
}
histogram
.
add
(
new
Date
(
)
-
startTime
)
;
return
promise
;
}
handleMemoryReport
(
id
units
amount
key
)
{
let
val
;
if
(
units
=
=
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
)
{
val
=
Math
.
floor
(
amount
/
1024
)
;
}
else
if
(
units
=
=
Ci
.
nsIMemoryReporter
.
UNITS_PERCENTAGE
)
{
val
=
Math
.
floor
(
amount
/
100
)
;
}
else
if
(
units
=
=
Ci
.
nsIMemoryReporter
.
UNITS_COUNT
)
{
val
=
amount
;
}
else
if
(
units
=
=
Ci
.
nsIMemoryReporter
.
UNITS_COUNT_CUMULATIVE
)
{
if
(
!
(
id
in
this
.
_prevValues
)
)
{
this
.
_prevValues
[
id
]
=
amount
;
return
;
}
val
=
amount
-
this
.
_prevValues
[
id
]
;
this
.
_prevValues
[
id
]
=
amount
;
}
else
{
this
.
_log
.
error
(
"
handleMemoryReport
-
Can
'
t
handle
memory
reporter
with
units
"
+
units
)
;
return
;
}
if
(
key
)
{
Telemetry
.
getKeyedHistogramById
(
id
)
.
add
(
key
val
)
;
return
;
}
Telemetry
.
getHistogramById
(
id
)
.
add
(
val
)
;
}
attachObservers
:
function
attachObservers
(
)
{
if
(
!
this
.
_initialized
)
return
;
if
(
Telemetry
.
canRecordExtended
)
{
this
.
addObserver
(
TOPIC_CYCLE_COLLECTOR_BEGIN
)
;
}
}
earlyInit
(
testing
)
{
this
.
_log
.
trace
(
"
earlyInit
"
)
;
this
.
_initStarted
=
true
;
this
.
_testing
=
testing
;
if
(
this
.
_initialized
&
&
!
testing
)
{
this
.
_log
.
error
(
"
earlyInit
-
already
initialized
"
)
;
return
;
}
if
(
!
Telemetry
.
canRecordBase
&
&
!
testing
)
{
this
.
_log
.
config
(
"
earlyInit
-
Telemetry
recording
is
disabled
skipping
Chrome
process
setup
.
"
)
;
return
;
}
Services
.
ppmm
.
addMessageListener
(
MESSAGE_TELEMETRY_USS
this
)
;
}
delayedInit
(
)
{
this
.
_log
.
trace
(
"
delayedInit
"
)
;
this
.
_delayedInitTask
=
(
async
(
)
=
>
{
try
{
this
.
_initialized
=
true
;
this
.
attachObservers
(
)
;
this
.
gatherMemory
(
)
;
if
(
Telemetry
.
canRecordExtended
)
{
GCTelemetry
.
init
(
)
;
}
this
.
_delayedInitTask
=
null
;
}
catch
(
e
)
{
this
.
_delayedInitTask
=
null
;
throw
e
;
}
}
)
(
)
;
return
this
.
_delayedInitTask
;
}
setupContent
:
function
setupContent
(
testing
)
{
this
.
_log
.
trace
(
"
setupContent
"
)
;
this
.
_testing
=
testing
;
if
(
!
Telemetry
.
canRecordBase
)
{
this
.
_log
.
trace
(
"
setupContent
-
base
recording
is
disabled
not
initializing
"
)
;
return
;
}
this
.
addObserver
(
"
content
-
child
-
shutdown
"
)
;
Services
.
cpmm
.
addMessageListener
(
MESSAGE_TELEMETRY_GET_CHILD_USS
this
)
;
let
delayedTask
=
new
DeferredTask
(
(
)
=
>
{
this
.
_initialized
=
true
;
this
.
attachObservers
(
)
;
this
.
gatherMemory
(
)
;
if
(
Telemetry
.
canRecordExtended
)
{
GCTelemetry
.
init
(
)
;
}
}
testing
?
TELEMETRY_TEST_DELAY
:
TELEMETRY_DELAY
testing
?
0
:
undefined
)
;
delayedTask
.
arm
(
)
;
}
getOpenTabsCount
:
function
getOpenTabsCount
(
)
{
let
tabCount
=
0
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
tabCount
+
=
win
.
gBrowser
.
tabs
.
length
;
}
return
tabCount
;
}
receiveMessage
:
function
receiveMessage
(
message
)
{
this
.
_log
.
trace
(
"
receiveMessage
-
Message
name
"
+
message
.
name
)
;
switch
(
message
.
name
)
{
case
MESSAGE_TELEMETRY_USS
:
{
if
(
this
.
_totalMemoryTimeout
&
&
this
.
_childrenToHearFrom
.
delete
(
message
.
data
.
id
)
)
{
let
uss
=
message
.
data
.
bytes
;
this
.
_totalMemory
+
=
uss
;
this
.
_USSFromChildProcesses
.
push
(
uss
)
;
if
(
this
.
_childrenToHearFrom
.
size
=
=
0
)
{
clearTimeout
(
this
.
_totalMemoryTimeout
)
;
this
.
_totalMemoryTimeout
=
undefined
;
this
.
handleMemoryReport
(
"
MEMORY_TOTAL
"
Ci
.
nsIMemoryReporter
.
UNITS_BYTES
this
.
_totalMemory
)
;
let
length
=
this
.
_USSFromChildProcesses
.
length
;
if
(
length
>
1
)
{
let
mean
=
this
.
_USSFromChildProcesses
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
/
length
;
let
diffs
=
this
.
_USSFromChildProcesses
.
map
(
value
=
>
Math
.
floor
(
Math
.
abs
(
value
-
mean
)
*
100
/
mean
)
)
;
let
tabsCount
=
this
.
getOpenTabsCount
(
)
;
let
key
;
if
(
tabsCount
<
11
)
{
key
=
"
0
-
10
tabs
"
;
}
else
if
(
tabsCount
<
501
)
{
key
=
"
11
-
500
tabs
"
;
}
else
{
key
=
"
more
tabs
"
;
}
diffs
.
forEach
(
value
=
>
{
this
.
handleMemoryReport
(
"
MEMORY_DISTRIBUTION_AMONG_CONTENT
"
Ci
.
nsIMemoryReporter
.
UNITS_COUNT
value
key
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
gather
-
memory
-
telemetry
-
finished
"
)
;
}
this
.
_USSFromChildProcesses
=
undefined
;
}
}
else
{
this
.
_log
.
trace
(
"
Child
USS
report
was
missed
"
)
;
}
break
;
}
case
MESSAGE_TELEMETRY_GET_CHILD_USS
:
{
this
.
sendContentProcessUSS
(
message
.
data
.
id
)
;
break
;
}
default
:
throw
new
Error
(
"
Telemetry
.
receiveMessage
:
bad
message
name
"
)
;
}
}
sendContentProcessUSS
:
function
sendContentProcessUSS
(
aMessageId
)
{
this
.
_log
.
trace
(
"
sendContentProcessUSS
"
)
;
let
mgr
;
try
{
mgr
=
Cc
[
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIMemoryReporterManager
)
;
}
catch
(
e
)
{
return
;
}
Services
.
cpmm
.
sendAsyncMessage
(
MESSAGE_TELEMETRY_USS
{
bytes
:
mgr
.
residentUnique
id
:
aMessageId
}
)
;
}
uninstall
(
)
{
for
(
let
topic
of
this
.
_observedTopics
)
{
try
{
this
.
removeObserver
(
topic
)
;
}
catch
(
e
)
{
this
.
_log
.
warn
(
"
uninstall
-
Failed
to
remove
"
+
topic
e
)
;
}
}
GCTelemetry
.
shutdown
(
)
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
!
=
TOPIC_CYCLE_COLLECTOR_BEGIN
)
{
this
.
_log
.
trace
(
"
observe
-
"
+
aTopic
+
"
notified
.
"
)
;
}
switch
(
aTopic
)
{
case
"
content
-
child
-
shutdown
"
:
this
.
uninstall
(
)
;
Telemetry
.
flushBatchedChildTelemetry
(
)
;
break
;
case
TOPIC_CYCLE_COLLECTOR_BEGIN
:
let
now
=
new
Date
(
)
;
if
(
!
gLastMemoryPoll
|
|
(
TELEMETRY_INTERVAL
<
=
now
-
gLastMemoryPoll
)
)
{
gLastMemoryPoll
=
now
;
this
.
_log
.
trace
(
"
Dispatching
idle
gatherMemory
task
"
)
;
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
this
.
_log
.
trace
(
"
Running
idle
gatherMemory
task
"
)
;
this
.
gatherMemory
(
)
;
return
true
;
}
)
;
}
break
;
}
return
undefined
;
}
shutdown
(
)
{
this
.
_log
.
trace
(
"
shutdown
"
)
;
let
cleanup
=
(
)
=
>
{
this
.
uninstall
(
)
;
this
.
_initStarted
=
false
;
this
.
_initialized
=
false
;
}
;
if
(
!
this
.
_initStarted
)
{
return
Promise
.
resolve
(
)
;
}
if
(
!
this
.
_delayedInitTask
)
{
return
cleanup
(
)
;
}
return
this
.
_delayedInitTask
.
then
(
cleanup
)
;
}
}
;
