#
ifndef
ProcessedStack_h__
#
define
ProcessedStack_h__
#
include
<
string
>
#
include
<
vector
>
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsString
.
h
"
#
if
defined
(
MOZ_GECKO_PROFILER
)
#
include
"
shared
-
libraries
.
h
"
#
endif
namespace
mozilla
{
namespace
Telemetry
{
class
ProcessedStack
{
public
:
ProcessedStack
(
)
;
size_t
GetStackSize
(
)
const
;
size_t
GetNumModules
(
)
const
;
struct
Frame
{
uintptr_t
mOffset
;
uint16_t
mModIndex
;
}
;
struct
Module
{
nsString
mName
;
nsCString
mBreakpadId
;
bool
operator
=
=
(
const
Module
&
other
)
const
;
}
;
const
Frame
&
GetFrame
(
unsigned
aIndex
)
const
;
void
AddFrame
(
const
Frame
&
aFrame
)
;
const
Module
&
GetModule
(
unsigned
aIndex
)
const
;
void
AddModule
(
const
Module
&
aFrame
)
;
void
Clear
(
)
;
private
:
std
:
:
vector
<
Module
>
mModules
;
std
:
:
vector
<
Frame
>
mStack
;
}
;
ProcessedStack
GetStackAndModules
(
const
std
:
:
vector
<
uintptr_t
>
&
aPCs
)
;
class
BatchProcessedStackGenerator
{
public
:
BatchProcessedStackGenerator
(
)
;
ProcessedStack
GetStackAndModules
(
const
std
:
:
vector
<
uintptr_t
>
&
aPCs
)
;
template
<
typename
AllocatorPolicy
>
ProcessedStack
GetStackAndModules
(
const
Vector
<
void
*
0
AllocatorPolicy
>
&
aPCs
)
{
return
GetStackAndModules
(
reinterpret_cast
<
const
uintptr_t
*
>
(
aPCs
.
begin
(
)
)
reinterpret_cast
<
const
uintptr_t
*
>
(
aPCs
.
end
(
)
)
)
;
}
private
:
ProcessedStack
GetStackAndModules
(
const
uintptr_t
*
aBegin
const
uintptr_t
*
aEnd
)
;
#
if
defined
(
MOZ_GECKO_PROFILER
)
SharedLibraryInfo
mSortedRawModules
;
#
endif
}
;
}
}
#
endif
