#
ifndef
ProcessedStack_h__
#
define
ProcessedStack_h__
#
include
<
string
>
#
include
<
vector
>
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsString
.
h
"
#
if
defined
(
MOZ_GECKO_PROFILER
)
#
include
"
shared
-
libraries
.
h
"
#
endif
namespace
mozilla
{
namespace
Telemetry
{
class
ProcessedStack
{
public
:
ProcessedStack
(
)
;
size_t
GetStackSize
(
)
const
;
size_t
GetNumModules
(
)
const
;
struct
Frame
{
uintptr_t
mOffset
;
uint16_t
mModIndex
;
}
;
struct
Module
{
nsString
mName
;
nsCString
mBreakpadId
;
bool
operator
=
=
(
const
Module
&
other
)
const
;
}
;
const
Frame
&
GetFrame
(
unsigned
aIndex
)
const
;
void
AddFrame
(
const
Frame
&
aFrame
)
;
const
Module
&
GetModule
(
unsigned
aIndex
)
const
;
void
AddModule
(
const
Module
&
aFrame
)
;
void
Clear
(
)
;
private
:
std
:
:
vector
<
Module
>
mModules
;
std
:
:
vector
<
Frame
>
mStack
;
}
;
ProcessedStack
GetStackAndModules
(
const
std
:
:
vector
<
uintptr_t
>
&
aPCs
)
;
class
BatchProcessedStackGenerator
{
public
:
BatchProcessedStackGenerator
(
)
;
ProcessedStack
GetStackAndModules
(
const
std
:
:
vector
<
uintptr_t
>
&
aPCs
)
;
template
<
typename
AllocatorPolicy
>
ProcessedStack
GetStackAndModules
(
const
Vector
<
void
*
0
AllocatorPolicy
>
&
aPCs
)
{
return
GetStackAndModules
(
reinterpret_cast
<
const
uintptr_t
*
>
(
aPCs
.
begin
(
)
)
reinterpret_cast
<
const
uintptr_t
*
>
(
aPCs
.
end
(
)
)
)
;
}
private
:
ProcessedStack
GetStackAndModules
(
const
uintptr_t
*
aBegin
const
uintptr_t
*
aEnd
)
;
#
if
defined
(
MOZ_GECKO_PROFILER
)
SharedLibraryInfo
mSortedRawModules
;
#
endif
}
;
}
}
namespace
IPC
{
template
<
>
struct
ParamTraits
<
mozilla
:
:
Telemetry
:
:
ProcessedStack
:
:
Module
>
{
typedef
mozilla
:
:
Telemetry
:
:
ProcessedStack
:
:
Module
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
WriteParam
(
aMsg
aParam
.
mName
)
;
WriteParam
(
aMsg
aParam
.
mBreakpadId
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
if
(
!
ReadParam
(
aMsg
aIter
&
aResult
-
>
mName
)
)
{
return
false
;
}
if
(
!
ReadParam
(
aMsg
aIter
&
aResult
-
>
mBreakpadId
)
)
{
return
false
;
}
return
true
;
}
}
;
template
<
>
struct
ParamTraits
<
mozilla
:
:
Telemetry
:
:
ProcessedStack
:
:
Frame
>
{
typedef
mozilla
:
:
Telemetry
:
:
ProcessedStack
:
:
Frame
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
WriteParam
(
aMsg
aParam
.
mOffset
)
;
WriteParam
(
aMsg
aParam
.
mModIndex
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
if
(
!
ReadParam
(
aMsg
aIter
&
aResult
-
>
mOffset
)
)
{
return
false
;
}
if
(
!
ReadParam
(
aMsg
aIter
&
aResult
-
>
mModIndex
)
)
{
return
false
;
}
return
true
;
}
}
;
}
#
endif
