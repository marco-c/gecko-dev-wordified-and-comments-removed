#
include
"
UntrustedModules
.
h
"
#
include
"
core
/
TelemetryCommon
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
WinDllServices
.
h
"
#
include
"
nsLocalFile
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsXPCOMCIDInternal
.
h
"
namespace
mozilla
{
namespace
Telemetry
{
static
const
int32_t
kUntrustedModuleLoadEventsTelemetryVersion
=
1
;
static
void
LimitStringLength
(
nsAString
&
aStr
size_t
aMaxFieldLength
)
{
if
(
aStr
.
Length
(
)
<
=
aMaxFieldLength
)
{
return
;
}
NS_NAMED_LITERAL_STRING
(
kEllipses
"
.
.
.
"
)
;
MOZ_ASSERT
(
aMaxFieldLength
>
=
kEllipses
.
Length
(
)
)
;
size_t
cutPos
=
(
aMaxFieldLength
-
kEllipses
.
Length
(
)
)
/
2
;
size_t
rightLen
=
aMaxFieldLength
-
kEllipses
.
Length
(
)
-
cutPos
;
size_t
cutLen
=
aStr
.
Length
(
)
-
(
cutPos
+
rightLen
)
;
aStr
.
Replace
(
cutPos
cutLen
kEllipses
)
;
}
static
bool
AddLengthLimitedStringProp
(
JSContext
*
cx
JS
:
:
HandleObject
aObj
const
char
*
aName
const
nsAString
&
aVal
size_t
aMaxFieldLength
=
260
)
{
JS
:
:
RootedValue
jsval
(
cx
)
;
nsAutoString
shortVal
(
aVal
)
;
LimitStringLength
(
shortVal
aMaxFieldLength
)
;
jsval
.
setString
(
Common
:
:
ToJSString
(
cx
shortVal
)
)
;
return
JS_DefineProperty
(
cx
aObj
aName
jsval
JSPROP_ENUMERATE
)
;
}
;
template
<
typename
T
size_t
N
typename
AllocPolicy
typename
Converter
>
static
bool
VectorToJSArray
(
JSContext
*
cx
JS
:
:
MutableHandleObject
aRet
const
Vector
<
T
N
AllocPolicy
>
&
aContainer
Converter
&
&
aElementConverter
)
{
JS
:
:
RootedObject
arr
(
cx
JS_NewArrayObject
(
cx
0
)
)
;
if
(
!
arr
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
aContainer
.
length
(
)
;
+
+
i
)
{
JS
:
:
RootedValue
jsel
(
cx
)
;
if
(
!
aElementConverter
(
cx
&
jsel
aContainer
[
i
]
)
)
{
return
false
;
}
if
(
!
JS_DefineElement
(
cx
arr
i
jsel
JSPROP_ENUMERATE
)
)
{
return
false
;
}
}
aRet
.
set
(
arr
)
;
return
true
;
}
static
bool
ModuleInfoToJSObj
(
JSContext
*
cx
JS
:
:
MutableHandleObject
aRet
const
ModuleLoadEvent
:
:
ModuleInfo
&
aModInfo
)
{
JS
:
:
RootedObject
modObj
(
cx
JS_NewObject
(
cx
nullptr
)
)
;
if
(
!
modObj
)
{
return
false
;
}
JS
:
:
RootedValue
jsval
(
cx
)
;
nsPrintfCString
strBaseAddress
(
"
0x
%
p
"
(
void
*
)
aModInfo
.
mBase
)
;
jsval
.
setString
(
Common
:
:
ToJSString
(
cx
strBaseAddress
)
)
;
if
(
!
JS_DefineProperty
(
cx
modObj
"
baseAddress
"
jsval
JSPROP_ENUMERATE
)
)
{
return
false
;
}
jsval
.
setString
(
Common
:
:
ToJSString
(
cx
aModInfo
.
mFileVersion
)
)
;
if
(
!
JS_DefineProperty
(
cx
modObj
"
fileVersion
"
jsval
JSPROP_ENUMERATE
)
)
{
return
false
;
}
if
(
!
AddLengthLimitedStringProp
(
cx
modObj
"
loaderName
"
aModInfo
.
mLdrName
)
)
{
return
false
;
}
if
(
!
AddLengthLimitedStringProp
(
cx
modObj
"
moduleName
"
aModInfo
.
mFilePathClean
)
)
{
return
false
;
}
if
(
aModInfo
.
mLoadDurationMS
.
isSome
(
)
)
{
jsval
.
setNumber
(
aModInfo
.
mLoadDurationMS
.
value
(
)
)
;
if
(
!
JS_DefineProperty
(
cx
modObj
"
loadDurationMS
"
jsval
JSPROP_ENUMERATE
)
)
{
return
false
;
}
}
jsval
.
setNumber
(
(
uint32_t
)
aModInfo
.
mTrustFlags
)
;
if
(
!
JS_DefineProperty
(
cx
modObj
"
moduleTrustFlags
"
jsval
JSPROP_ENUMERATE
)
)
{
return
false
;
}
aRet
.
set
(
modObj
)
;
return
true
;
}
static
bool
ModuleLoadEventToJSArray
(
JSContext
*
cx
JS
:
:
MutableHandleValue
aRet
const
ModuleLoadEvent
&
aEvent
)
{
JS
:
:
RootedValue
jsval
(
cx
)
;
JS
:
:
RootedObject
eObj
(
cx
JS_NewObject
(
cx
nullptr
)
)
;
if
(
!
eObj
)
{
return
false
;
}
jsval
.
setNumber
(
(
uint32_t
)
aEvent
.
mThreadID
)
;
if
(
!
JS_DefineProperty
(
cx
eObj
"
threadID
"
jsval
JSPROP_ENUMERATE
)
)
{
return
false
;
}
jsval
.
setBoolean
(
aEvent
.
mIsStartup
)
;
if
(
!
JS_DefineProperty
(
cx
eObj
"
isStartup
"
jsval
JSPROP_ENUMERATE
)
)
{
return
false
;
}
jsval
.
setNumber
(
(
double
)
aEvent
.
mProcessUptimeMS
)
;
if
(
!
JS_DefineProperty
(
cx
eObj
"
processUptimeMS
"
jsval
JSPROP_ENUMERATE
)
)
{
return
false
;
}
jsval
.
setString
(
Common
:
:
ToJSString
(
cx
aEvent
.
mThreadName
)
)
;
if
(
!
JS_DefineProperty
(
cx
eObj
"
threadName
"
jsval
JSPROP_ENUMERATE
)
)
{
return
false
;
}
JS
:
:
RootedObject
modulesArray
(
cx
)
;
bool
ok
=
VectorToJSArray
(
cx
&
modulesArray
aEvent
.
mModules
[
]
(
JSContext
*
cx
JS
:
:
MutableHandleValue
aRet
const
ModuleLoadEvent
:
:
ModuleInfo
&
aModInfo
)
{
JS
:
:
RootedObject
obj
(
cx
)
;
if
(
!
ModuleInfoToJSObj
(
cx
&
obj
aModInfo
)
)
{
return
false
;
}
aRet
.
setObject
(
*
obj
)
;
return
true
;
}
)
;
if
(
!
ok
)
{
return
false
;
}
if
(
!
JS_DefineProperty
(
cx
eObj
"
modules
"
modulesArray
JSPROP_ENUMERATE
)
)
{
return
false
;
}
aRet
.
setObject
(
*
eObj
)
;
return
true
;
}
nsresult
GetUntrustedModuleLoadEventsJSValue
(
const
UntrustedModuleLoadTelemetryData
&
aData
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRet
)
{
if
(
aData
.
mEvents
.
empty
(
)
)
{
aRet
.
setNull
(
)
;
return
NS_OK
;
}
JS
:
:
RootedValue
jsval
(
cx
)
;
JS
:
:
RootedObject
mainObj
(
cx
JS_NewObject
(
cx
nullptr
)
)
;
if
(
!
mainObj
)
{
return
NS_ERROR_FAILURE
;
}
jsval
.
setNumber
(
(
uint32_t
)
aData
.
mErrorModules
)
;
if
(
!
JS_DefineProperty
(
cx
mainObj
"
errorModules
"
jsval
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
jsval
.
setNumber
(
(
uint32_t
)
kUntrustedModuleLoadEventsTelemetryVersion
)
;
if
(
!
JS_DefineProperty
(
cx
mainObj
"
structVersion
"
jsval
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aData
.
mXULLoadDurationMS
.
isSome
(
)
)
{
jsval
.
setNumber
(
aData
.
mXULLoadDurationMS
.
value
(
)
)
;
if
(
!
JS_DefineProperty
(
cx
mainObj
"
xulLoadDurationMS
"
jsval
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
}
JS
:
:
RootedObject
eventsArray
(
cx
)
;
if
(
!
VectorToJSArray
(
cx
&
eventsArray
aData
.
mEvents
&
ModuleLoadEventToJSArray
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
JS_DefineProperty
(
cx
mainObj
"
events
"
eventsArray
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
RootedObject
combinedStacksObj
(
cx
CreateJSStackObject
(
cx
aData
.
mStacks
)
)
;
if
(
!
combinedStacksObj
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
JS_DefineProperty
(
cx
mainObj
"
combinedStacks
"
combinedStacksObj
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_FAILURE
;
}
aRet
.
setObject
(
*
mainObj
)
;
return
NS_OK
;
}
class
GetUntrustedModulesMainThreadRunnable
final
:
public
Runnable
{
nsMainThreadPtrHandle
<
dom
:
:
Promise
>
mPromise
;
bool
mDataOK
;
UntrustedModuleLoadTelemetryData
mData
;
nsCOMPtr
<
nsIThread
>
mWorkerThread
;
public
:
GetUntrustedModulesMainThreadRunnable
(
const
nsMainThreadPtrHandle
<
dom
:
:
Promise
>
&
aPromise
bool
aDataOK
UntrustedModuleLoadTelemetryData
&
&
aData
)
:
Runnable
(
"
GetUntrustedModulesMainThreadRunnable
"
)
mPromise
(
aPromise
)
mDataOK
(
aDataOK
)
mData
(
std
:
:
move
(
aData
)
)
mWorkerThread
(
do_GetCurrentThread
(
)
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mWorkerThread
-
>
Shutdown
(
)
;
dom
:
:
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
mPromise
-
>
GlobalJSObject
(
)
)
)
)
{
mPromise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
if
(
!
mDataOK
)
{
mPromise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
RootedValue
jsval
(
cx
)
;
nsresult
rv
=
GetUntrustedModuleLoadEventsJSValue
(
mData
cx
&
jsval
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mPromise
-
>
MaybeReject
(
rv
)
;
return
NS_OK
;
}
mPromise
-
>
MaybeResolve
(
jsval
)
;
return
NS_OK
;
}
}
;
class
GetUntrustedModulesTelemetryDataRunnable
final
:
public
Runnable
{
nsMainThreadPtrHandle
<
dom
:
:
Promise
>
mPromise
;
public
:
explicit
GetUntrustedModulesTelemetryDataRunnable
(
const
nsMainThreadPtrHandle
<
dom
:
:
Promise
>
&
aPromise
)
:
Runnable
(
"
GetUntrustedModulesTelemetryDataRunnable
"
)
mPromise
(
aPromise
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
DllServices
>
dllSvc
(
DllServices
:
:
Get
(
)
)
;
UntrustedModuleLoadTelemetryData
data
;
bool
ok
=
dllSvc
-
>
GetUntrustedModuleTelemetryData
(
data
)
;
return
NS_DispatchToMainThread
(
new
GetUntrustedModulesMainThreadRunnable
(
mPromise
ok
std
:
:
move
(
data
)
)
)
;
}
}
;
nsresult
GetUntrustedModuleLoadEvents
(
JSContext
*
cx
dom
:
:
Promise
*
*
aPromise
)
{
nsIGlobalObject
*
global
=
xpc
:
:
CurrentNativeGlobal
(
cx
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
result
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
global
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
StealNSResult
(
)
;
}
nsCOMPtr
<
nsIThread
>
workThread
;
nsresult
rv
=
NS_NewNamedThread
(
"
UntrustedDLLs
"
getter_AddRefs
(
workThread
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
nsMainThreadPtrHandle
<
dom
:
:
Promise
>
mainThreadPromise
(
new
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
(
"
Telemetry
:
:
UntrustedModuleLoadEvents
:
:
Promise
"
promise
)
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
GetUntrustedModulesTelemetryDataRunnable
(
mainThreadPromise
)
;
promise
.
forget
(
aPromise
)
;
return
workThread
-
>
Dispatch
(
runnable
.
forget
(
)
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
}
}
}
