#
include
"
UntrustedModules
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessParent
.
h
"
#
include
"
mozilla
/
RDDChild
.
h
"
#
include
"
mozilla
/
RDDProcessManager
.
h
"
#
include
"
mozilla
/
WinDllServices
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
UntrustedModulesDataSerializer
.
h
"
namespace
mozilla
{
namespace
Telemetry
{
static
const
uint32_t
kMaxModulesArrayLen
=
100
;
using
UntrustedModulesIpcPromise
=
MozPromise
<
Maybe
<
UntrustedModulesData
>
ipc
:
:
ResponseRejectReason
true
>
;
using
MultiGetUntrustedModulesPromise
=
MozPromise
<
bool
nsresult
true
>
;
class
MOZ_HEAP_CLASS
MultiGetUntrustedModulesData
final
{
using
BackupType
=
UntrustedModulesBackupService
:
:
BackupType
;
public
:
explicit
MultiGetUntrustedModulesData
(
uint32_t
aFlags
)
:
mFlags
(
aFlags
)
mBackupSvc
(
UntrustedModulesBackupService
:
:
Get
(
)
)
mPromise
(
new
MultiGetUntrustedModulesPromise
:
:
Private
(
__func__
)
)
mNumPending
(
0
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MultiGetUntrustedModulesData
)
RefPtr
<
MultiGetUntrustedModulesPromise
>
GetUntrustedModuleLoadEvents
(
)
;
void
Serialize
(
RefPtr
<
dom
:
:
Promise
>
&
&
aPromise
)
;
MultiGetUntrustedModulesData
(
const
MultiGetUntrustedModulesData
&
)
=
delete
;
MultiGetUntrustedModulesData
(
MultiGetUntrustedModulesData
&
&
)
=
delete
;
MultiGetUntrustedModulesData
&
operator
=
(
const
MultiGetUntrustedModulesData
&
)
=
delete
;
MultiGetUntrustedModulesData
&
operator
=
(
MultiGetUntrustedModulesData
&
&
)
=
delete
;
private
:
~
MultiGetUntrustedModulesData
(
)
=
default
;
void
AddPending
(
RefPtr
<
UntrustedModulesPromise
>
&
&
aNewPending
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
+
+
mNumPending
;
RefPtr
<
MultiGetUntrustedModulesData
>
self
(
this
)
;
aNewPending
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
]
(
Maybe
<
UntrustedModulesData
>
&
&
aResult
)
{
self
-
>
OnCompletion
(
std
:
:
move
(
aResult
)
)
;
}
[
self
]
(
nsresult
aReason
)
{
self
-
>
OnCompletion
(
)
;
}
)
;
}
void
AddPending
(
RefPtr
<
UntrustedModulesIpcPromise
>
&
&
aNewPending
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
+
+
mNumPending
;
RefPtr
<
MultiGetUntrustedModulesData
>
self
(
this
)
;
aNewPending
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
]
(
Maybe
<
UntrustedModulesData
>
&
&
aResult
)
{
self
-
>
OnCompletion
(
std
:
:
move
(
aResult
)
)
;
}
[
self
]
(
ipc
:
:
ResponseRejectReason
&
&
aReason
)
{
self
-
>
OnCompletion
(
)
;
}
)
;
}
void
OnCompletion
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
&
&
mNumPending
>
0
)
;
-
-
mNumPending
;
if
(
mNumPending
)
{
return
;
}
mPromise
-
>
Resolve
(
true
__func__
)
;
}
void
OnCompletion
(
Maybe
<
UntrustedModulesData
>
&
&
aResult
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aResult
.
isSome
(
)
)
{
mBackupSvc
-
>
Backup
(
BackupType
:
:
Staging
std
:
:
move
(
aResult
.
ref
(
)
)
)
;
}
OnCompletion
(
)
;
}
private
:
uint32_t
mFlags
;
RefPtr
<
UntrustedModulesBackupService
>
mBackupSvc
;
RefPtr
<
MultiGetUntrustedModulesPromise
:
:
Private
>
mPromise
;
size_t
mNumPending
;
}
;
RefPtr
<
MultiGetUntrustedModulesPromise
>
MultiGetUntrustedModulesData
:
:
GetUntrustedModuleLoadEvents
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
&
&
NS_IsMainThread
(
)
)
;
RefPtr
<
DllServices
>
dllSvc
(
DllServices
:
:
Get
(
)
)
;
AddPending
(
dllSvc
-
>
GetUntrustedModulesData
(
)
)
;
nsTArray
<
dom
:
:
ContentParent
*
>
contentParents
;
dom
:
:
ContentParent
:
:
GetAll
(
contentParents
)
;
for
(
auto
&
&
contentParent
:
contentParents
)
{
AddPending
(
contentParent
-
>
SendGetUntrustedModulesData
(
)
)
;
}
if
(
auto
*
socketActor
=
net
:
:
SocketProcessParent
:
:
GetSingleton
(
)
)
{
AddPending
(
socketActor
-
>
SendGetUntrustedModulesData
(
)
)
;
}
if
(
RDDProcessManager
*
rddMgr
=
RDDProcessManager
:
:
Get
(
)
)
{
if
(
RDDChild
*
rddChild
=
rddMgr
-
>
GetRDDChild
(
)
)
{
AddPending
(
rddChild
-
>
SendGetUntrustedModulesData
(
)
)
;
}
}
return
mPromise
;
}
void
MultiGetUntrustedModulesData
:
:
Serialize
(
RefPtr
<
dom
:
:
Promise
>
&
&
aPromise
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
dom
:
:
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
aPromise
-
>
GetGlobalObject
(
)
)
)
)
{
aPromise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
UntrustedModulesDataSerializer
serializer
(
cx
kMaxModulesArrayLen
mFlags
)
;
if
(
!
serializer
)
{
aPromise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
;
}
nsresult
rv
;
if
(
mFlags
&
nsITelemetry
:
:
INCLUDE_OLD_LOADEVENTS
)
{
if
(
mFlags
&
nsITelemetry
:
:
KEEP_LOADEVENTS_NEW
)
{
if
(
mFlags
&
nsITelemetry
:
:
EXCLUDE_STACKINFO_FROM_LOADEVENTS
)
{
rv
=
serializer
.
Add
(
mBackupSvc
-
>
Ref
(
BackupType
:
:
Staging
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aPromise
-
>
MaybeReject
(
rv
)
;
return
;
}
rv
=
serializer
.
Add
(
mBackupSvc
-
>
Ref
(
BackupType
:
:
Settled
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aPromise
-
>
MaybeReject
(
rv
)
;
return
;
}
}
else
{
aPromise
-
>
MaybeReject
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
}
else
{
mBackupSvc
-
>
SettleAllStagingData
(
)
;
const
UntrustedModulesBackupData
&
settledRef
=
mBackupSvc
-
>
Ref
(
BackupType
:
:
Settled
)
;
if
(
settledRef
.
IsEmpty
(
)
)
{
aPromise
-
>
MaybeReject
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
rv
=
serializer
.
Add
(
settledRef
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aPromise
-
>
MaybeReject
(
rv
)
;
return
;
}
}
}
else
{
const
UntrustedModulesBackupData
&
stagingRef
=
mBackupSvc
-
>
Ref
(
BackupType
:
:
Staging
)
;
if
(
stagingRef
.
IsEmpty
(
)
)
{
aPromise
-
>
MaybeReject
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
rv
=
serializer
.
Add
(
stagingRef
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aPromise
-
>
MaybeReject
(
rv
)
;
return
;
}
if
(
!
(
mFlags
&
nsITelemetry
:
:
KEEP_LOADEVENTS_NEW
)
)
{
mBackupSvc
-
>
SettleAllStagingData
(
)
;
}
}
JS
:
:
RootedValue
jsval
(
cx
)
;
serializer
.
GetObject
(
&
jsval
)
;
aPromise
-
>
MaybeResolve
(
jsval
)
;
}
nsresult
GetUntrustedModuleLoadEvents
(
uint32_t
aFlags
JSContext
*
cx
dom
:
:
Promise
*
*
aPromise
)
{
nsIGlobalObject
*
global
=
xpc
:
:
CurrentNativeGlobal
(
cx
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
result
;
RefPtr
<
dom
:
:
Promise
>
promise
(
dom
:
:
Promise
:
:
Create
(
global
result
)
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
StealNSResult
(
)
;
}
auto
multi
=
MakeRefPtr
<
MultiGetUntrustedModulesData
>
(
aFlags
)
;
multi
-
>
GetUntrustedModuleLoadEvents
(
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
promise
multi
]
(
bool
)
mutable
{
multi
-
>
Serialize
(
std
:
:
move
(
promise
)
)
;
}
[
promise
]
(
nsresult
aRv
)
{
promise
-
>
MaybeReject
(
aRv
)
;
}
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
}
}
