#
include
<
cerrno
>
#
include
<
cstring
>
#
include
<
string
>
#
include
<
dlfcn
.
h
>
#
include
<
unistd
.
h
>
#
include
"
third_party
/
curl
/
curl
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
namespace
PingSender
{
using
std
:
:
string
;
using
mozilla
:
:
Unused
;
class
CurlWrapper
{
public
:
CurlWrapper
(
)
;
~
CurlWrapper
(
)
;
bool
Init
(
)
;
bool
Post
(
const
string
&
url
const
string
&
payload
)
;
CURL
*
(
*
easy_init
)
(
void
)
;
CURLcode
(
*
easy_setopt
)
(
CURL
*
CURLoption
.
.
.
)
;
CURLcode
(
*
easy_perform
)
(
CURL
*
)
;
CURLcode
(
*
easy_getinfo
)
(
CURL
*
CURLINFO
.
.
.
)
;
curl_slist
*
(
*
slist_append
)
(
curl_slist
*
const
char
*
)
;
void
(
*
slist_free_all
)
(
curl_slist
*
)
;
const
char
*
(
*
easy_strerror
)
(
CURLcode
)
;
void
(
*
easy_cleanup
)
(
CURL
*
)
;
void
(
*
global_cleanup
)
(
void
)
;
private
:
void
*
mLib
;
void
*
mCurl
;
}
;
CurlWrapper
:
:
CurlWrapper
(
)
:
easy_init
(
nullptr
)
easy_setopt
(
nullptr
)
easy_perform
(
nullptr
)
easy_getinfo
(
nullptr
)
slist_append
(
nullptr
)
slist_free_all
(
nullptr
)
easy_strerror
(
nullptr
)
easy_cleanup
(
nullptr
)
global_cleanup
(
nullptr
)
mLib
(
nullptr
)
mCurl
(
nullptr
)
{
}
CurlWrapper
:
:
~
CurlWrapper
(
)
{
if
(
mLib
)
{
if
(
mCurl
&
&
easy_cleanup
)
{
easy_cleanup
(
mCurl
)
;
}
if
(
global_cleanup
)
{
global_cleanup
(
)
;
}
dlclose
(
mLib
)
;
}
}
bool
CurlWrapper
:
:
Init
(
)
{
const
char
*
libcurlPaths
[
]
=
{
"
/
usr
/
lib
"
#
ifdef
XP_LINUX
"
/
usr
/
lib32
"
"
/
usr
/
lib64
"
"
/
usr
/
lib
/
i386
-
linux
-
gnu
"
"
/
usr
/
lib
/
x86_64
-
linux
-
gnu
"
#
endif
}
;
const
char
*
libcurlNames
[
]
=
{
#
ifdef
XP_LINUX
"
libcurl
.
so
"
"
libcurl
.
so
.
4
"
"
libcurl
-
gnutls
.
so
"
"
libcurl
-
gnutls
.
so
.
4
"
"
libcurl
.
so
.
3
"
"
libcurl
-
gnutls
.
so
.
3
"
#
elif
defined
(
XP_MACOSX
)
"
libcurl
.
dylib
"
"
libcurl
.
4
.
dylib
"
"
libcurl
.
3
.
dylib
"
#
endif
}
;
for
(
const
char
*
libpath
:
libcurlPaths
)
{
for
(
const
char
*
libname
:
libcurlNames
)
{
string
fullpath
=
string
(
libpath
)
+
"
/
"
+
libname
;
mLib
=
dlopen
(
fullpath
.
c_str
(
)
RTLD_NOW
)
;
if
(
mLib
)
{
break
;
}
}
if
(
mLib
)
{
break
;
}
}
if
(
!
mLib
)
{
PINGSENDER_LOG
(
"
ERROR
:
Could
not
find
libcurl
\
n
"
)
;
return
false
;
}
*
(
void
*
*
)
(
&
easy_init
)
=
dlsym
(
mLib
"
curl_easy_init
"
)
;
*
(
void
*
*
)
(
&
easy_setopt
)
=
dlsym
(
mLib
"
curl_easy_setopt
"
)
;
*
(
void
*
*
)
(
&
easy_perform
)
=
dlsym
(
mLib
"
curl_easy_perform
"
)
;
*
(
void
*
*
)
(
&
easy_getinfo
)
=
dlsym
(
mLib
"
curl_easy_getinfo
"
)
;
*
(
void
*
*
)
(
&
slist_append
)
=
dlsym
(
mLib
"
curl_slist_append
"
)
;
*
(
void
*
*
)
(
&
slist_free_all
)
=
dlsym
(
mLib
"
curl_slist_free_all
"
)
;
*
(
void
*
*
)
(
&
easy_strerror
)
=
dlsym
(
mLib
"
curl_easy_strerror
"
)
;
*
(
void
*
*
)
(
&
easy_cleanup
)
=
dlsym
(
mLib
"
curl_easy_cleanup
"
)
;
*
(
void
*
*
)
(
&
global_cleanup
)
=
dlsym
(
mLib
"
curl_global_cleanup
"
)
;
if
(
!
easy_init
|
|
!
easy_setopt
|
|
!
easy_perform
|
|
!
easy_getinfo
|
|
!
slist_append
|
|
!
slist_free_all
|
|
!
easy_strerror
|
|
!
easy_cleanup
|
|
!
global_cleanup
)
{
PINGSENDER_LOG
(
"
ERROR
:
libcurl
is
missing
one
of
the
required
symbols
\
n
"
)
;
return
false
;
}
mCurl
=
easy_init
(
)
;
if
(
!
mCurl
)
{
PINGSENDER_LOG
(
"
ERROR
:
Could
not
initialize
libcurl
\
n
"
)
;
return
false
;
}
return
true
;
}
static
size_t
DummyWriteCallback
(
char
*
ptr
size_t
size
size_t
nmemb
void
*
userdata
)
{
Unused
<
<
ptr
;
Unused
<
<
size
;
Unused
<
<
nmemb
;
Unused
<
<
userdata
;
return
size
*
nmemb
;
}
bool
CurlWrapper
:
:
Post
(
const
string
&
url
const
string
&
payload
)
{
easy_setopt
(
mCurl
CURLOPT_URL
url
.
c_str
(
)
)
;
easy_setopt
(
mCurl
CURLOPT_USERAGENT
kUserAgent
)
;
easy_setopt
(
mCurl
CURLOPT_WRITEFUNCTION
DummyWriteCallback
)
;
std
:
:
string
dateHeader
=
GenerateDateHeader
(
)
;
curl_slist
*
headerChunk
=
nullptr
;
headerChunk
=
slist_append
(
headerChunk
kCustomVersionHeader
)
;
headerChunk
=
slist_append
(
headerChunk
kContentEncodingHeader
)
;
headerChunk
=
slist_append
(
headerChunk
dateHeader
.
c_str
(
)
)
;
CURLcode
err
=
easy_setopt
(
mCurl
CURLOPT_HTTPHEADER
headerChunk
)
;
if
(
err
!
=
CURLE_OK
)
{
PINGSENDER_LOG
(
"
ERROR
:
Failed
to
set
HTTP
headers
%
s
\
n
"
easy_strerror
(
err
)
)
;
slist_free_all
(
headerChunk
)
;
return
false
;
}
easy_setopt
(
mCurl
CURLOPT_POSTFIELDSIZE
payload
.
length
(
)
)
;
easy_setopt
(
mCurl
CURLOPT_POSTFIELDS
payload
.
c_str
(
)
)
;
easy_setopt
(
mCurl
CURLOPT_FAILONERROR
1
)
;
easy_setopt
(
mCurl
CURLOPT_CONNECTTIMEOUT_MS
kConnectionTimeoutMs
)
;
err
=
easy_perform
(
mCurl
)
;
slist_free_all
(
headerChunk
)
;
if
(
err
!
=
CURLE_OK
)
{
PINGSENDER_LOG
(
"
ERROR
:
Failed
to
send
HTTP
request
%
s
\
n
"
easy_strerror
(
err
)
)
;
return
false
;
}
return
true
;
}
bool
Post
(
const
string
&
url
const
string
&
payload
)
{
CurlWrapper
curl
;
if
(
!
curl
.
Init
(
)
)
{
return
false
;
}
return
curl
.
Post
(
url
payload
)
;
}
}
