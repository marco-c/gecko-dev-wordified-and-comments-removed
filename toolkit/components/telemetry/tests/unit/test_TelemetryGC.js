"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GCTelemetry
.
jsm
"
this
)
;
function
do_register_cleanup
(
)
{
GCTelemetry
.
shutdown
(
)
;
}
function
run_test
(
)
{
const
limit
=
24
;
const
make_gc_fields
=
19
;
Assert
.
ok
(
GCTelemetry
.
init
(
)
"
Initialize
success
"
)
;
Assert
.
ok
(
!
GCTelemetry
.
init
(
)
"
Wont
initialize
twice
"
)
;
assert_num_entries
(
0
false
)
;
GCTelemetry
.
observeRaw
(
make_gc
(
)
)
;
assert_num_entries
(
1
false
)
;
Assert
.
equal
(
make_gc_fields
Object
.
keys
(
get_entry
(
)
)
.
length
)
;
assert_num_entries
(
1
true
)
;
assert_num_entries
(
0
false
)
;
let
my_big_gc
=
make_gc
(
)
;
for
(
let
i
=
0
;
i
<
100
;
i
+
+
)
{
my_big_gc
[
"
new_property_
"
+
i
]
=
"
Data
"
;
}
GCTelemetry
.
observeRaw
(
my_big_gc
)
;
Assert
.
equal
(
7
Object
.
keys
(
get_entry
(
)
)
.
length
)
;
assert_num_entries
(
1
true
)
;
assert_num_entries
(
0
false
)
;
let
my_gc_exact
=
make_gc
(
)
;
Assert
.
equal
(
make_gc_fields
Object
.
keys
(
my_gc_exact
)
.
length
)
;
for
(
let
i
=
0
;
i
<
limit
-
make_gc_fields
;
i
+
+
)
{
my_gc_exact
[
"
new_property_
"
+
i
]
=
"
Data
"
;
}
GCTelemetry
.
observeRaw
(
my_gc_exact
)
;
Assert
.
equal
(
limit
Object
.
keys
(
get_entry
(
)
)
.
length
)
;
assert_num_entries
(
1
true
)
;
assert_num_entries
(
0
false
)
;
let
my_gc_too_many
=
make_gc
(
)
;
for
(
let
i
=
0
;
i
<
limit
-
make_gc_fields
+
1
;
i
+
+
)
{
my_gc_too_many
[
"
new_property_
"
+
i
]
=
"
Data
"
;
}
GCTelemetry
.
observeRaw
(
my_gc_too_many
)
;
Assert
.
equal
(
7
Object
.
keys
(
get_entry
(
)
)
.
length
)
;
assert_num_entries
(
1
true
)
;
assert_num_entries
(
0
false
)
;
}
function
assert_num_entries
(
expect
clear
)
{
let
entries
=
GCTelemetry
.
entries
(
"
main
"
clear
)
;
Assert
.
equal
(
expect
entries
.
worst
.
length
expect
+
"
worst
entries
"
)
;
Assert
.
equal
(
0
entries
.
random
.
length
expect
+
"
random
entries
"
)
;
}
function
get_entry
(
)
{
let
entries
=
GCTelemetry
.
entries
(
"
main
"
false
)
;
Assert
.
ok
(
entries
"
Got
entries
object
"
)
;
Assert
.
ok
(
entries
.
random
"
Has
random
property
"
)
;
Assert
.
ok
(
entries
.
worst
"
Has
worst
property
"
)
;
let
entry
=
entries
.
worst
[
0
]
;
Assert
.
ok
(
entry
"
Got
worst
entry
"
)
;
return
entry
;
}
function
make_gc
(
)
{
let
timestamp
=
Math
.
random
(
)
*
1000000
;
let
gc
=
{
status
:
"
completed
"
timestamp
max_pause
:
Math
.
random
(
)
*
95
+
5
total_time
:
Math
.
random
(
)
*
500
+
500
zones_collected
:
9
total_zones
:
9
total_compartments
:
309
minor_gcs
:
44
store_buffer_overflows
:
19
mmu_20ms
:
0
mmu_50ms
:
0
nonincremental_reason
:
"
GCBytesTrigger
"
allocated_bytes
:
38853696
added_chunks
:
54
removed_chunks
:
12
slices
:
15
slice_number
:
218
slices_list
:
[
{
slice
:
218
pause
:
Math
.
random
(
)
*
2
+
28
reason
:
"
SET_NEW_DOCUMENT
"
initial_state
:
"
NotActive
"
final_state
:
"
Mark
"
budget
:
"
10ms
"
page_faults
:
1
start_timestamp
:
timestamp
+
Math
.
random
(
)
*
50000
times
:
{
wait_background_thread
:
0
.
012
mark_discard_code
:
2
.
845
purge
:
0
.
723
mark
:
9
.
831
mark_roots
:
0
.
102
buffer_gray_roots
:
3
.
095
mark_cross_compartment_wrappers
:
0
.
039
mark_c_and_js_stacks
:
0
.
005
mark_runtime_wide_data
:
2
.
313
mark_embedding
:
0
.
117
mark_compartments
:
2
.
27
unmark
:
1
.
063
minor_gcs_to_evict_nursery
:
8
.
701
}
}
]
totals
:
{
wait_background_thread
:
0
.
012
mark_discard_code
:
2
.
845
purge
:
0
.
723
mark
:
9
.
831
mark_roots
:
0
.
102
buffer_gray_roots
:
3
.
095
mark_cross_compartment_wrappers
:
0
.
039
mark_c_and_js_stacks
:
0
.
005
mark_runtime_wide_data
:
2
.
313
mark_embedding
:
0
.
117
mark_compartments
:
2
.
27
unmark
:
1
.
063
minor_gcs_to_evict_nursery
:
8
.
701
}
}
;
return
gc
;
}
