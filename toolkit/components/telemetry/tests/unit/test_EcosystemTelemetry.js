"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
this
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ONLOGIN_NOTIFICATION
:
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
ONLOGOUT_NOTIFICATION
:
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
ONVERIFIED_NOTIFICATION
:
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
}
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
EcosystemTelemetry
"
"
resource
:
/
/
gre
/
modules
/
EcosystemTelemetry
.
jsm
"
)
;
const
TEST_PING_TYPE
=
"
test
-
ping
-
type
"
;
const
RE_VALID_GUID
=
/
^
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
/
;
function
fakeIdleNotification
(
topic
)
{
let
scheduler
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryScheduler
.
jsm
"
null
)
;
return
scheduler
.
TelemetryScheduler
.
observe
(
null
topic
null
)
;
}
async
function
promiseNoPing
(
)
{
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
{
}
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
TEST_PING_TYPE
"
Should
be
a
test
ping
.
"
)
;
}
function
checkPingStructure
(
ping
reason
)
{
Assert
.
equal
(
ping
.
type
EcosystemTelemetry
.
PING_TYPE
"
Should
be
an
ecosystem
ping
.
"
)
;
Assert
.
ok
(
!
(
"
clientId
"
in
ping
)
"
Ping
must
not
contain
a
client
ID
.
"
)
;
Assert
.
ok
(
"
environment
"
in
ping
"
Ping
must
contain
an
environment
.
"
)
;
let
environment
=
ping
.
environment
;
const
ALLOWED_ENVIRONMENT_KEYS
=
[
"
settings
"
"
system
"
"
profile
"
]
;
Assert
.
deepEqual
(
ALLOWED_ENVIRONMENT_KEYS
Object
.
keys
(
environment
)
"
Environment
should
only
contain
a
limited
set
of
keys
.
"
)
;
Assert
.
deepEqual
(
[
"
locale
"
]
Object
.
keys
(
environment
.
settings
)
"
Settings
environment
should
only
contain
locale
"
)
;
Assert
.
deepEqual
(
[
"
cpu
"
"
memoryMB
"
"
os
"
]
Object
.
keys
(
environment
.
system
)
.
sort
(
)
"
System
environment
should
contain
a
limited
set
of
keys
"
)
;
Assert
.
deepEqual
(
[
"
locale
"
"
name
"
"
version
"
]
Object
.
keys
(
environment
.
system
.
os
)
.
sort
(
)
"
system
.
environment
.
os
should
contain
a
limited
set
of
keys
"
)
;
let
payload
=
ping
.
payload
;
Assert
.
equal
(
payload
.
reason
reason
"
Ping
reason
must
match
.
"
)
;
Assert
.
ok
(
payload
.
duration
>
=
0
"
Payload
must
have
a
duration
greater
or
equal
to
0
"
)
;
Assert
.
ok
(
"
ecosystemAnonId
"
in
payload
"
payload
must
have
ecosystemAnonId
"
)
;
Assert
.
ok
(
RE_VALID_GUID
.
test
(
payload
.
ecosystemClientId
)
"
ecosystemClientId
must
be
a
valid
GUID
"
)
;
Assert
.
ok
(
"
scalars
"
in
payload
"
Payload
must
contain
scalars
"
)
;
Assert
.
ok
(
"
keyedScalars
"
in
payload
"
Payload
must
contain
keyed
scalars
"
)
;
Assert
.
ok
(
"
histograms
"
in
payload
"
Payload
must
contain
histograms
"
)
;
Assert
.
ok
(
"
keyedHistograms
"
in
payload
"
Payload
must
contain
keyed
histograms
"
)
;
}
function
fakeAnonId
(
fn
)
{
const
m
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
EcosystemTelemetry
.
jsm
"
null
)
;
let
oldFn
=
m
.
Policy
.
getEcosystemAnonId
;
m
.
Policy
.
getEcosystemAnonId
=
fn
;
return
oldFn
;
}
registerCleanupFunction
(
function
(
)
{
PingServer
.
stop
(
)
;
}
)
;
add_task
(
async
function
setup
(
)
{
do_get_profile
(
true
)
;
await
setEmptyPrefWatchlist
(
)
;
PingServer
.
start
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
Server
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
TelemetrySend
.
setServer
(
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
await
TelemetryController
.
testSetup
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
gIsAndroid
}
async
function
test_no_ecosystem_ping_on_fennec
(
)
{
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryEnabled
true
)
;
EcosystemTelemetry
.
testReset
(
)
;
EcosystemTelemetry
.
periodicPing
(
)
;
await
promiseNoPing
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
gIsAndroid
}
async
function
test_disabled_non_fxa_production
(
)
{
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryEnabled
true
)
;
Assert
.
ok
(
EcosystemTelemetry
.
enabled
(
)
"
enabled
by
default
"
)
;
Preferences
.
set
(
"
identity
.
fxaccounts
.
autoconfig
.
uri
"
"
http
:
/
/
"
)
;
Assert
.
ok
(
!
EcosystemTelemetry
.
enabled
(
)
"
disabled
if
non
-
prod
"
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryAllowForNonProductionFxA
true
)
;
Assert
.
ok
(
EcosystemTelemetry
.
enabled
(
)
"
enabled
for
non
-
prod
but
preference
override
"
)
;
Preferences
.
reset
(
"
identity
.
fxaccounts
.
autoconfig
.
uri
"
)
;
Preferences
.
reset
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryAllowForNonProductionFxA
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
gIsAndroid
}
async
function
test_nosending_if_disabled
(
)
{
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryEnabled
false
)
;
EcosystemTelemetry
.
testReset
(
)
;
EcosystemTelemetry
.
periodicPing
(
)
;
await
promiseNoPing
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
gIsAndroid
}
async
function
test_no_default_send
(
)
{
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryEnabled
true
)
;
EcosystemTelemetry
.
testReset
(
)
;
EcosystemTelemetry
.
periodicPing
(
)
;
await
promiseNoPing
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
gIsAndroid
}
async
function
test_login_workflow
(
)
{
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryEnabled
true
)
;
EcosystemTelemetry
.
testReset
(
)
;
let
originalAnonId
=
fakeAnonId
(
(
)
=
>
null
)
;
let
ping
;
EcosystemTelemetry
.
periodicPing
(
)
;
await
promiseNoPing
(
)
;
fakeAnonId
(
(
)
=
>
null
)
;
EcosystemTelemetry
.
observe
(
null
ONLOGIN_NOTIFICATION
null
)
;
EcosystemTelemetry
.
periodicPing
(
)
;
await
promiseNoPing
(
)
;
fakeAnonId
(
(
)
=
>
"
test_login_workflow
:
my
.
anon
.
id
"
)
;
EcosystemTelemetry
.
observe
(
null
ONVERIFIED_NOTIFICATION
null
)
;
print
(
"
triggering
ping
now
that
we
have
an
anon
-
id
"
)
;
EcosystemTelemetry
.
periodicPing
(
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingStructure
(
ping
"
periodic
"
)
;
Assert
.
equal
(
ping
.
payload
.
ecosystemAnonId
"
test_login_workflow
:
my
.
anon
.
id
"
)
;
print
(
"
user
disconnects
"
)
;
fakeAnonId
(
(
)
=
>
null
)
;
await
EcosystemTelemetry
.
observe
(
null
ONLOGOUT_NOTIFICATION
null
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingStructure
(
ping
"
logout
"
)
;
Assert
.
equal
(
ping
.
payload
.
ecosystemAnonId
"
test_login_workflow
:
my
.
anon
.
id
"
"
should
have
been
submitted
with
the
old
anonid
"
)
;
Assert
.
equal
(
await
EcosystemTelemetry
.
promiseEcosystemAnonId
null
"
should
resolve
to
null
immediately
after
logout
"
)
;
print
(
"
timer
fires
after
disconnection
"
)
;
EcosystemTelemetry
.
periodicPing
(
)
;
await
promiseNoPing
(
)
;
fakeAnonId
(
(
)
=
>
"
test_login_workflow
:
my
.
anon
.
id
.
2
"
)
;
EcosystemTelemetry
.
observe
(
null
ONVERIFIED_NOTIFICATION
null
)
;
print
(
"
triggering
ping
now
the
user
has
logged
back
in
"
)
;
EcosystemTelemetry
.
periodicPing
(
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingStructure
(
ping
"
periodic
"
)
;
Assert
.
equal
(
ping
.
payload
.
ecosystemAnonId
"
test_login_workflow
:
my
.
anon
.
id
.
2
"
)
;
fakeAnonId
(
originalAnonId
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
gIsAndroid
}
async
function
test_shutdown_logged_in
(
)
{
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryEnabled
true
)
;
EcosystemTelemetry
.
testReset
(
)
;
let
originalAnonId
=
fakeAnonId
(
(
)
=
>
Promise
.
resolve
(
"
test_shutdown_logged_in
:
my
.
anon
.
id
"
)
)
;
EcosystemTelemetry
.
observe
(
null
ONLOGIN_NOTIFICATION
null
)
;
await
promiseNoPing
(
)
;
EcosystemTelemetry
.
shutdown
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingStructure
(
ping
"
shutdown
"
)
;
Assert
.
equal
(
ping
.
payload
.
ecosystemAnonId
"
test_shutdown_logged_in
:
my
.
anon
.
id
"
"
our
anon
ID
is
in
the
ping
"
)
;
fakeAnonId
(
originalAnonId
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
gIsAndroid
}
async
function
test_shutdown_not_logged_in
(
)
{
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryEnabled
true
)
;
EcosystemTelemetry
.
testReset
(
)
;
let
originalAnonId
=
fakeAnonId
(
(
)
=
>
Promise
.
resolve
(
null
)
)
;
await
promiseNoPing
(
)
;
EcosystemTelemetry
.
shutdown
(
)
;
await
promiseNoPing
(
)
;
fakeAnonId
(
originalAnonId
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
gIsAndroid
}
async
function
test_periodic_ping
(
)
{
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
let
receivedPing
=
null
;
PingServer
.
registerPingHandler
(
req
=
>
{
const
ping
=
decodeRequestPayload
(
req
)
;
if
(
ping
.
type
=
=
EcosystemTelemetry
.
PING_TYPE
)
{
Assert
.
ok
(
!
receivedPing
"
Telemetry
must
only
send
one
periodic
ecosystem
ping
.
"
)
;
receivedPing
=
ping
;
}
}
)
;
let
schedulerTickCallback
=
null
;
let
now
=
new
Date
(
2040
1
1
0
0
0
)
;
fakeNow
(
now
)
;
fakeSchedulerTimer
(
callback
=
>
(
schedulerTickCallback
=
callback
)
(
)
=
>
{
}
)
;
await
TelemetryController
.
testReset
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryEnabled
true
)
;
EcosystemTelemetry
.
testReset
(
)
;
let
originalAnonId
=
fakeAnonId
(
(
)
=
>
"
test_periodic_ping
:
my
.
anon
.
id
"
)
;
EcosystemTelemetry
.
observe
(
null
ONLOGIN_NOTIFICATION
null
)
;
let
h
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
SEARCH_COUNTS
"
)
;
h
.
add
(
"
test
-
key
"
)
;
Telemetry
.
scalarSet
(
"
browser
.
engagement
.
total_uri_count
"
2
)
;
let
firstPeriodicDue
=
new
Date
(
2040
1
2
0
0
0
)
;
fakeNow
(
firstPeriodicDue
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
let
tickPromise
=
schedulerTickCallback
(
)
;
fakeIdleNotification
(
"
idle
"
)
;
fakeIdleNotification
(
"
active
"
)
;
await
tickPromise
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
Assert
.
ok
(
receivedPing
"
Telemetry
must
send
one
ecosystem
periodic
ping
.
"
)
;
checkPingStructure
(
receivedPing
"
periodic
"
)
;
Assert
.
ok
(
receivedPing
.
payload
.
keyedHistograms
.
parent
.
SEARCH_COUNTS
)
;
Assert
.
equal
(
receivedPing
.
payload
.
scalars
.
parent
[
"
browser
.
engagement
.
total_uri_count
"
]
2
)
;
fakeAnonId
(
originalAnonId
)
;
}
)
;
