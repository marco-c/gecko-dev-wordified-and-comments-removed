"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
this
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ONLOGIN_NOTIFICATION
:
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
ONLOGOUT_NOTIFICATION
:
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
}
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
EcosystemTelemetry
"
"
resource
:
/
/
gre
/
modules
/
EcosystemTelemetry
.
jsm
"
)
;
const
WEAVE_EVENT
=
"
weave
:
service
:
login
:
change
"
;
const
TEST_PING_TYPE
=
"
test
-
ping
-
type
"
;
function
checkPingStructure
(
ping
type
reason
)
{
Assert
.
equal
(
ping
.
type
type
"
Should
be
an
ecosystem
ping
.
"
)
;
Assert
.
ok
(
!
(
"
clientId
"
in
ping
)
"
Ping
must
not
contain
a
client
ID
.
"
)
;
Assert
.
ok
(
"
environment
"
in
ping
"
Ping
must
contain
an
environment
.
"
)
;
let
environment
=
ping
.
environment
;
const
ALLOWED_ENVIRONMENT_KEYS
=
[
"
settings
"
"
system
"
"
profile
"
]
;
Assert
.
deepEqual
(
ALLOWED_ENVIRONMENT_KEYS
Object
.
keys
(
environment
)
"
Environment
should
only
contain
limited
set
of
keys
.
"
)
;
Assert
.
deepEqual
(
[
"
locale
"
]
Object
.
keys
(
environment
.
settings
)
"
Settings
environment
should
only
contain
locale
"
)
;
Assert
.
deepEqual
(
[
"
cpu
"
"
memoryMB
"
"
os
"
]
Object
.
keys
(
environment
.
system
)
.
sort
(
)
"
System
environment
should
contain
limit
set
of
keys
"
)
;
let
payload
=
ping
.
payload
;
Assert
.
equal
(
payload
.
reason
reason
"
Ping
reason
must
match
.
"
)
;
Assert
.
ok
(
payload
.
duration
>
=
0
"
Payload
must
have
a
duration
greater
or
equal
to
0
"
)
;
Assert
.
ok
(
"
ecosystemClientId
"
in
payload
"
Payload
must
contain
the
ecosystem
client
ID
"
)
;
Assert
.
ok
(
"
scalars
"
in
payload
"
Payload
must
contain
scalars
"
)
;
Assert
.
ok
(
"
keyedScalars
"
in
payload
"
Payload
must
contain
keyed
scalars
"
)
;
Assert
.
ok
(
"
histograms
"
in
payload
"
Payload
must
contain
histograms
"
)
;
Assert
.
ok
(
"
keyedHistograms
"
in
payload
"
Payload
must
contain
keyed
histograms
"
)
;
}
function
sendPing
(
)
{
return
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
{
}
)
;
}
function
fakeFxaUid
(
fn
)
{
const
m
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
EcosystemTelemetry
.
jsm
"
null
)
;
let
oldFn
=
m
.
Policy
.
fxaUid
;
m
.
Policy
.
fxaUid
=
fn
;
return
oldFn
;
}
registerCleanupFunction
(
function
(
)
{
PingServer
.
stop
(
)
;
}
)
;
add_task
(
async
function
setup
(
)
{
do_get_profile
(
true
)
;
await
setEmptyPrefWatchlist
(
)
;
PingServer
.
start
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
Server
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
TelemetrySend
.
setServer
(
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
await
TelemetryController
.
testSetup
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
gIsAndroid
}
async
function
test_no_ecosystem_ping_on_fennec
(
)
{
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryEnabled
true
)
;
EcosystemTelemetry
.
testReset
(
)
;
EcosystemTelemetry
.
periodicPing
(
)
;
sendPing
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
TEST_PING_TYPE
"
Should
be
a
test
ping
.
"
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
gIsAndroid
}
async
function
test_nosending_if_disabled
(
)
{
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryEnabled
false
)
;
EcosystemTelemetry
.
testReset
(
)
;
EcosystemTelemetry
.
periodicPing
(
)
;
sendPing
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
TEST_PING_TYPE
"
Should
be
a
test
ping
.
"
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
gIsAndroid
}
async
function
test_simple_send
(
)
{
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryEnabled
true
)
;
EcosystemTelemetry
.
testReset
(
)
;
EcosystemTelemetry
.
periodicPing
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingStructure
(
ping
"
pre
-
account
"
"
periodic
"
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
gIsAndroid
}
async
function
test_login_workflow
(
)
{
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
EcosystemTelemetryEnabled
true
)
;
EcosystemTelemetry
.
testReset
(
)
;
let
originalFxaUid
=
fakeFxaUid
(
(
)
=
>
null
)
;
let
ping
;
EcosystemTelemetry
.
periodicPing
(
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingStructure
(
ping
"
pre
-
account
"
"
periodic
"
)
;
Assert
.
ok
(
!
(
"
uid
"
in
ping
.
payload
)
"
Ping
should
not
contain
a
UID
"
)
;
EcosystemTelemetry
.
observe
(
null
ONLOGIN_NOTIFICATION
null
)
;
sendPing
(
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
TEST_PING_TYPE
"
Should
be
a
test
ping
.
"
)
;
fakeFxaUid
(
(
)
=
>
"
hashed
-
id
"
)
;
EcosystemTelemetry
.
observe
(
null
WEAVE_EVENT
null
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingStructure
(
ping
"
pre
-
account
"
"
login
"
)
;
Assert
.
ok
(
"
uid
"
in
ping
.
payload
"
Ping
should
contain
hashed
ID
"
)
;
EcosystemTelemetry
.
periodicPing
(
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingStructure
(
ping
"
pre
-
account
"
"
periodic
"
)
;
Assert
.
ok
(
"
uid
"
in
ping
.
payload
"
Ping
should
contain
hashed
ID
"
)
;
fakeFxaUid
(
(
)
=
>
null
)
;
EcosystemTelemetry
.
observe
(
null
ONLOGOUT_NOTIFICATION
null
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingStructure
(
ping
"
pre
-
account
"
"
logout
"
)
;
Assert
.
ok
(
!
(
"
uid
"
in
ping
.
payload
)
"
Ping
should
not
contain
a
UID
"
)
;
EcosystemTelemetry
.
periodicPing
(
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingStructure
(
ping
"
pre
-
account
"
"
periodic
"
)
;
Assert
.
ok
(
!
(
"
uid
"
in
ping
.
payload
)
"
Ping
should
not
contain
a
UID
"
)
;
EcosystemTelemetry
.
shutdown
(
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingStructure
(
ping
"
pre
-
account
"
"
shutdown
"
)
;
Assert
.
ok
(
!
(
"
uid
"
in
ping
.
payload
)
"
Ping
should
not
contain
a
UID
"
)
;
fakeFxaUid
(
originalFxaUid
)
;
}
)
;
