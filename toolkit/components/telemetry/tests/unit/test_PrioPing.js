"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
this
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryPrioPing
"
"
resource
:
/
/
gre
/
modules
/
PrioPing
.
jsm
"
)
;
function
checkPingStructure
(
type
payload
options
)
{
Assert
.
equal
(
type
TelemetryPrioPing
.
PRIO_PING_TYPE
"
Should
be
a
prio
ping
.
"
)
;
Assert
.
ok
(
"
version
"
in
payload
"
Payload
must
have
version
.
"
)
;
Assert
.
ok
(
"
reason
"
in
payload
"
Payload
must
have
reason
.
"
)
;
Assert
.
ok
(
Object
.
values
(
TelemetryPrioPing
.
Reason
)
.
some
(
reason
=
>
payload
.
reason
=
=
=
reason
)
"
Should
be
a
known
reason
.
"
)
;
Assert
.
ok
(
Array
.
isArray
(
payload
.
prioData
)
"
Payload
prioData
must
be
present
and
an
array
.
"
)
;
payload
.
prioData
.
forEach
(
prioData
=
>
{
Assert
.
ok
(
"
encoding
"
in
prioData
"
All
prioData
must
have
encodings
.
"
)
;
Assert
.
ok
(
"
prio
"
in
prioData
"
All
prioData
must
have
prio
blocks
.
"
)
;
}
)
;
Assert
.
equal
(
options
.
addClientId
false
"
Must
forbid
client
Id
.
"
)
;
Assert
.
equal
(
options
.
addEnvironment
false
"
Must
forbid
Environment
.
"
)
;
}
function
fakePolicy
(
set
clear
send
snapshot
)
{
let
mod
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrioPing
.
jsm
"
null
)
;
mod
.
Policy
.
setTimeout
=
set
;
mod
.
Policy
.
clearTimeout
=
clear
;
mod
.
Policy
.
sendPing
=
send
;
mod
.
Policy
.
getEncodedOriginSnapshot
=
snapshot
;
}
function
pass
(
)
{
}
function
fail
(
)
{
Assert
.
ok
(
false
"
Not
allowed
"
)
;
}
function
fakeSnapshot
(
)
{
return
[
{
encoding
:
"
telemetry
.
test
-
1
-
1
"
prio
:
{
}
}
{
encoding
:
"
telemetry
.
test
-
1
-
1
"
prio
:
{
}
}
]
;
}
add_task
(
async
function
setup
(
)
{
do_get_profile
(
true
)
;
await
setEmptyPrefWatchlist
(
)
;
await
TelemetryController
.
testSetup
(
)
;
TelemetryPrioPing
.
testReset
(
)
;
}
)
;
add_task
(
async
function
test_limit_reached
(
)
{
fakePolicy
(
pass
pass
(
type
payload
options
)
=
>
{
checkPingStructure
(
type
payload
options
)
;
Assert
.
equal
(
payload
.
reason
TelemetryPrioPing
.
Reason
.
MAX
"
Sent
using
max
reason
.
"
)
;
}
fakeSnapshot
)
;
Services
.
obs
.
notifyObservers
(
null
"
origin
-
telemetry
-
storage
-
limit
-
reached
"
)
;
}
)
;
add_task
(
async
function
test_periodic
(
)
{
let
fireTimerNow
;
fakePolicy
(
callback
=
>
fireTimerNow
=
callback
pass
(
type
payload
options
)
=
>
{
checkPingStructure
(
type
payload
options
)
;
fakePolicy
(
pass
pass
(
type2
payload2
options2
)
=
>
{
checkPingStructure
(
type2
payload2
options2
)
;
Assert
.
equal
(
payload2
.
reason
TelemetryPrioPing
.
Reason
.
PERIODIC
"
Sent
with
periodic
reason
.
"
)
;
}
fakeSnapshot
)
;
fireTimerNow
(
)
;
}
fakeSnapshot
)
;
Services
.
obs
.
notifyObservers
(
null
"
origin
-
telemetry
-
storage
-
limit
-
reached
"
)
;
}
)
;
add_task
(
async
function
test_shutdown
(
)
{
fakePolicy
(
fail
pass
(
type
payload
options
)
=
>
{
checkPingStructure
(
type
payload
options
)
;
Assert
.
equal
(
payload
.
reason
TelemetryPrioPing
.
Reason
.
SHUTDOWN
"
Sent
with
shutdown
reason
.
"
)
;
}
fakeSnapshot
)
;
await
TelemetryPrioPing
.
shutdown
(
)
;
}
)
;
