"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
HttpServer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
const
{
TelemetryUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
dns
.
native
-
is
-
localhost
"
true
)
;
do_get_profile
(
true
)
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
42
"
"
42
"
)
;
const
proxy
=
AddonTestUtils
.
createHttpServer
(
)
;
proxy
.
registerPrefixHandler
(
"
/
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
504
"
hello
proxy
user
"
)
;
response
.
write
(
"
ok
!
"
)
;
}
)
;
let
proxy_info
;
function
getBadProxyPort
(
)
{
let
server
=
new
HttpServer
(
)
;
server
.
start
(
-
1
)
;
const
badPort
=
server
.
identity
.
primaryPort
;
server
.
stop
(
)
;
return
badPort
;
}
function
registerProxy
(
)
{
let
pps
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
-
proxy
-
service
;
1
"
]
.
getService
(
Ci
.
nsIProtocolProxyService
)
;
const
proxyFilter
=
{
applyFilter
(
uri
defaultProxyInfo
callback
)
{
if
(
proxy_info
&
&
uri
.
host
=
=
PingServer
.
host
&
&
uri
.
port
=
=
PingServer
.
port
)
{
let
proxyInfo
=
pps
.
newProxyInfo
(
proxy_info
.
type
proxy_info
.
host
proxy_info
.
port
"
"
"
"
0
4096
null
)
;
proxyInfo
.
sourceId
=
proxy_info
.
sourceId
;
callback
.
onProxyFilterResult
(
proxyInfo
)
;
}
else
{
callback
.
onProxyFilterResult
(
defaultProxyInfo
)
;
}
}
}
;
pps
.
registerFilter
(
proxyFilter
0
)
;
registerCleanupFunction
(
(
)
=
>
{
pps
.
unregisterFilter
(
proxyFilter
)
;
}
)
;
}
add_task
(
async
function
setup
(
)
{
fakeIntlReady
(
)
;
await
setEmptyPrefWatchlist
(
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
HealthPingEnabled
false
)
;
TelemetryStopwatch
.
setTestModeEnabled
(
true
)
;
registerProxy
(
)
;
PingServer
.
start
(
)
;
proxy
.
identity
.
add
(
"
http
"
PingServer
.
host
PingServer
.
port
)
;
await
TelemetrySend
.
setup
(
true
)
;
TelemetrySend
.
setTestModeEnabled
(
true
)
;
TelemetrySend
.
setServer
(
http
:
/
/
localhost
:
{
PingServer
.
port
}
)
;
}
)
;
function
checkEvent
(
)
{
let
expected
=
[
"
service_request
"
"
bypass
"
"
proxy_info
"
"
telemetry
.
send
"
{
source
:
proxy_info
.
sourceId
type
:
"
api
"
}
]
;
let
snapshot
=
Telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_ALL_CHANNELS
false
)
;
let
received
=
snapshot
.
parent
[
0
]
;
received
.
shift
(
)
;
Assert
.
deepEqual
(
expected
received
retry
telemetry
data
matched
{
JSON
.
stringify
(
received
)
}
)
;
Telemetry
.
clearEvents
(
)
;
}
async
function
submitPingWithDate
(
date
expected
)
{
fakeNow
(
new
Date
(
date
)
)
;
let
pingId
=
await
TelemetryController
.
submitExternalPing
(
"
test
-
send
-
date
-
header
"
{
}
)
;
let
req
=
await
PingServer
.
promiseNextRequest
(
)
;
let
ping
=
decodeRequestPayload
(
req
)
;
Assert
.
equal
(
req
.
getHeader
(
"
Date
"
)
expected
"
Telemetry
should
send
the
correct
Date
header
with
requests
.
"
)
;
Assert
.
equal
(
ping
.
id
pingId
"
Should
have
received
the
correct
ping
id
.
"
)
;
}
add_task
(
async
function
test_failed_server
(
)
{
proxy_info
=
{
type
:
"
http
"
host
:
proxy
.
identity
.
primaryHost
port
:
proxy
.
identity
.
primaryPort
sourceId
:
"
failed_server_test
"
}
;
await
TelemetrySend
.
reset
(
)
;
await
submitPingWithDate
(
Date
.
UTC
(
2011
1
1
11
0
0
)
"
Tue
01
Feb
2011
11
:
00
:
00
GMT
"
)
;
checkEvent
(
)
;
}
)
;
add_task
(
async
function
test_no_server
(
)
{
Services
.
prefs
.
setBoolPref
(
"
network
.
proxy
.
failover_direct
"
false
)
;
proxy_info
=
{
type
:
"
http
"
host
:
"
localhost
"
port
:
getBadProxyPort
(
)
sourceId
:
"
no_server_test
"
}
;
await
TelemetrySend
.
reset
(
)
;
await
submitPingWithDate
(
Date
.
UTC
(
2012
1
1
11
0
0
)
"
Wed
01
Feb
2012
11
:
00
:
00
GMT
"
)
;
checkEvent
(
)
;
}
)
;
function
waitForTimer
(
)
{
return
new
Promise
(
resolve
=
>
{
fakePingSendTimer
(
(
callback
timeout
)
=
>
{
resolve
(
[
callback
timeout
]
)
;
}
(
)
=
>
{
}
)
;
}
)
;
}
add_task
(
async
function
test_no_bypass
(
)
{
Services
.
prefs
.
setBoolPref
(
"
network
.
proxy
.
failover_direct
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
proxy
.
allow_bypass
"
false
)
;
proxy_info
=
{
type
:
"
http
"
host
:
"
localhost
"
port
:
getBadProxyPort
(
)
sourceId
:
"
no_server_test
"
}
;
await
TelemetrySend
.
reset
(
)
;
fakeNow
(
new
Date
(
Date
.
UTC
(
2013
1
1
11
0
0
)
)
)
;
let
timerPromise
=
waitForTimer
(
)
;
let
pingId
=
await
TelemetryController
.
submitExternalPing
(
"
test
-
send
-
date
-
header
"
{
}
)
;
let
[
pingSendTimerCallback
]
=
await
timerPromise
;
Assert
.
ok
(
!
!
pingSendTimerCallback
"
Should
have
a
timer
callback
"
)
;
Assert
.
equal
(
TelemetrySend
.
pendingPingCount
1
"
Should
have
correct
pending
ping
count
"
)
;
proxy_info
=
null
;
pingSendTimerCallback
(
)
;
let
req
=
await
PingServer
.
promiseNextRequest
(
)
;
let
ping
=
decodeRequestPayload
(
req
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
Assert
.
equal
(
req
.
getHeader
(
"
Date
"
)
"
Fri
01
Feb
2013
11
:
00
:
00
GMT
"
"
Telemetry
should
send
the
correct
Date
header
with
requests
.
"
)
;
Assert
.
equal
(
ping
.
id
pingId
"
Should
have
received
the
correct
ping
id
.
"
)
;
Assert
.
equal
(
TelemetrySend
.
pendingPingCount
0
"
Should
not
have
any
pending
pings
"
)
;
await
TelemetrySend
.
reset
(
)
;
PingServer
.
stop
(
)
;
}
)
;
