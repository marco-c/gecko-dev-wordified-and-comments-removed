"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
sys
.
mjs
"
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
WinTaskbarJumpList
:
"
resource
:
/
/
/
modules
/
WindowsJumpLists
.
sys
.
mjs
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
}
)
;
const
{
NimbusTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
NimbusTestUtils
.
sys
.
mjs
"
)
;
const
{
Policy
TelemetryReportingPolicy
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
sys
.
mjs
"
)
;
NimbusTestUtils
.
init
(
this
)
;
const
TOU_ACCEPTED_VERSION_PREF
=
"
termsofuse
.
acceptedVersion
"
;
const
TOU_CURRENT_VERSION_PREF
=
"
termsofuse
.
currentVersion
"
;
const
TOU_MINIMUM_VERSION_PREF
=
"
termsofuse
.
minimumVersion
"
;
const
TOU_ACCEPTED_DATE_PREF
=
"
termsofuse
.
acceptedDate
"
;
const
TOU_BYPASS_NOTIFICATION_PREF
=
"
termsofuse
.
bypassNotification
"
;
const
skipIfNotBrowser
=
(
)
=
>
(
{
skip_if
:
(
)
=
>
AppConstants
.
MOZ_BUILD_APP
!
=
"
browser
"
}
)
;
function
fakeResetAcceptedPolicy
(
)
{
Services
.
prefs
.
clearUserPref
(
TOU_ACCEPTED_DATE_PREF
)
;
Services
.
prefs
.
clearUserPref
(
TOU_ACCEPTED_VERSION_PREF
)
;
}
function
fakeInteractWithModal
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
termsofuse
:
interacted
"
)
;
}
function
unsetMinimumPolicyVersion
(
)
{
Services
.
prefs
.
clearUserPref
(
TOU_MINIMUM_VERSION_PREF
)
;
}
function
enrollInPreonboardingExperiment
(
version
)
{
return
NimbusTestUtils
.
enrollWithFeatureConfig
(
{
featureId
:
NimbusFeatures
.
preonboarding
.
featureId
value
:
{
enabled
:
true
currentVersion
:
version
minimumVersion
:
version
firstRunURL
:
http
:
/
/
mochi
.
test
/
v
{
version
}
screens
:
[
{
id
:
"
test
"
}
]
}
}
{
isRollout
:
false
}
)
;
}
add_setup
(
async
function
test_setup
(
)
{
do_get_profile
(
true
)
;
await
loadAddonManager
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
.
9
.
2
"
)
;
finishAddonManagerStartup
(
)
;
fakeIntlReady
(
)
;
await
setEmptyPrefWatchlist
(
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
BypassNotification
false
)
;
Services
.
prefs
.
setBoolPref
(
TOU_BYPASS_NOTIFICATION_PREF
false
)
;
await
Services
.
fog
.
testResetFOG
(
)
;
TelemetryReportingPolicy
.
setup
(
)
;
}
)
;
add_setup
(
skipIfNotBrowser
(
)
async
(
)
=
>
{
const
{
cleanup
}
=
await
NimbusTestUtils
.
setupTest
(
)
;
registerCleanupFunction
(
cleanup
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_feature_prefs
(
)
{
function
assertPrefs
(
currentVersion
minimumVersion
firstRunURL
)
{
Assert
.
equal
(
Services
.
prefs
.
getIntPref
(
TOU_CURRENT_VERSION_PREF
)
currentVersion
{
TOU_CURRENT_VERSION_PREF
}
is
set
)
;
Assert
.
equal
(
Services
.
prefs
.
getIntPref
(
TOU_MINIMUM_VERSION_PREF
)
minimumVersion
{
TOU_MINIMUM_VERSION_PREF
}
is
set
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
TelemetryUtils
.
Preferences
.
FirstRunURL
)
firstRunURL
"
datareporting
.
policy
.
firstRunURL
is
set
"
)
;
}
unsetMinimumPolicyVersion
(
)
;
Services
.
prefs
.
clearUserPref
(
TOU_CURRENT_VERSION_PREF
)
;
let
doCleanup
=
await
NimbusTestUtils
.
enrollWithFeatureConfig
(
{
featureId
:
NimbusFeatures
.
preonboarding
.
featureId
value
:
{
enabled
:
true
currentVersion
:
900
minimumVersion
:
899
firstRunURL
:
"
http
:
/
/
mochi
.
test
/
v900
"
}
}
{
isRollout
:
false
}
)
;
Assert
.
ok
(
NimbusFeatures
.
preonboarding
.
getVariable
(
"
enabled
"
)
)
;
TelemetryReportingPolicy
.
reset
(
)
;
Assert
.
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
TOU_CURRENT_VERSION_PREF
)
{
TOU_CURRENT_VERSION_PREF
}
is
not
set
)
;
Assert
.
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
TOU_MINIMUM_VERSION_PREF
)
{
TOU_MINIMUM_VERSION_PREF
}
is
not
set
)
;
Assert
.
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
TelemetryUtils
.
Preferences
.
FirstRunURL
)
"
datareporting
.
policy
.
firstRunURL
is
not
set
"
)
;
await
Policy
.
fakeSessionRestoreNotification
(
)
;
assertPrefs
(
900
899
"
http
:
/
/
mochi
.
test
/
v900
"
)
;
await
doCleanup
(
)
;
Assert
.
ok
(
!
NimbusFeatures
.
preonboarding
.
getVariable
(
"
enabled
"
)
)
;
assertPrefs
(
900
899
"
http
:
/
/
mochi
.
test
/
v900
"
)
;
doCleanup
=
await
NimbusTestUtils
.
enrollWithFeatureConfig
(
{
featureId
:
NimbusFeatures
.
preonboarding
.
featureId
value
:
{
enabled
:
true
currentVersion
:
901
minimumVersion
:
900
firstRunURL
:
"
http
:
/
/
mochi
.
test
/
v901
"
}
}
{
isRollout
:
false
}
)
;
Assert
.
ok
(
NimbusFeatures
.
preonboarding
.
getVariable
(
"
enabled
"
)
)
;
assertPrefs
(
900
899
"
http
:
/
/
mochi
.
test
/
v900
"
)
;
await
doCleanup
(
)
;
}
)
;
async
function
doOneModalFlow
(
version
)
{
let
doCleanup
=
await
enrollInPreonboardingExperiment
(
version
)
;
let
displayStub
=
sinon
.
stub
(
Policy
"
showModal
"
)
.
returns
(
true
)
;
TelemetryReportingPolicy
.
reset
(
)
;
await
Policy
.
fakeSessionRestoreNotification
(
)
;
Assert
.
equal
(
displayStub
.
callCount
1
"
showModal
is
invoked
"
)
;
Assert
.
equal
(
TelemetryReportingPolicy
.
userHasAcceptedTOU
(
)
false
"
Before
interaction
the
user
should
be
reported
as
not
having
accepted
"
)
;
let
completed
=
false
;
let
p
=
TelemetryReportingPolicy
.
ensureUserIsNotified
(
)
.
then
(
(
)
=
>
(
completed
=
true
)
)
;
Assert
.
equal
(
completed
false
"
The
notification
promise
should
not
resolve
before
the
user
interacts
"
)
;
fakeInteractWithModal
(
)
;
await
p
;
Assert
.
equal
(
completed
true
"
The
notification
promise
should
resolve
after
user
interacts
"
)
;
Assert
.
equal
(
TelemetryReportingPolicy
.
userHasAcceptedTOU
(
)
true
"
After
interaction
the
state
should
be
accepted
.
"
)
;
const
metricVersion
=
await
Glean
.
termsofuse
.
version
.
testGetValue
(
)
;
Assert
.
equal
(
metricVersion
version
Glean
.
termsofuse
.
version
is
{
metricVersion
}
and
matches
expected
{
version
}
)
;
const
rawDate
=
await
Glean
.
termsofuse
.
date
.
testGetValue
(
)
;
const
metricSec
=
getDateInSeconds
(
rawDate
)
;
const
expectedSec
=
getDateInSeconds
(
Services
.
prefs
.
getStringPref
(
TOU_ACCEPTED_DATE_PREF
)
)
;
Assert
.
equal
(
metricSec
expectedSec
Glean
.
termsofuse
.
date
(
in
seconds
)
is
{
metricSec
}
and
matches
expected
{
expectedSec
}
)
;
await
doCleanup
(
)
;
sinon
.
restore
(
)
;
}
add_task
(
skipIfNotBrowser
(
)
async
function
test_modal_flow_before_notification
(
)
{
fakeResetAcceptedPolicy
(
)
;
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
FirstRun
)
;
await
doOneModalFlow
(
900
)
;
Assert
.
equal
(
Services
.
prefs
.
getIntPref
(
TOU_ACCEPTED_VERSION_PREF
)
900
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_modal_flow_after_notification
(
)
{
fakeResetAcceptedPolicy
(
)
;
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
FirstRun
)
;
TelemetryReportingPolicy
.
reset
(
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotifiedOfDataReportingPolicy
(
)
"
User
is
notified
after
seeing
the
legacy
infobar
"
)
;
let
doCleanup
=
await
enrollInPreonboardingExperiment
(
900
)
;
let
modalStub
=
sinon
.
stub
(
Policy
"
showModal
"
)
.
returns
(
true
)
;
let
p
=
Policy
.
delayedSetup
(
)
;
Policy
.
fakeSessionRestoreNotification
(
)
;
await
p
;
Assert
.
equal
(
modalStub
.
callCount
0
"
showModal
should
not
be
invoked
after
legacy
infobar
notification
"
)
;
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyDate
)
;
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
)
;
TelemetryReportingPolicy
.
reset
(
)
;
await
doCleanup
(
)
;
sinon
.
restore
(
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_default_modal_shows_when_not_enrolled_in_experiment
(
)
{
if
(
AppConstants
.
platform
=
=
=
"
linux
"
)
{
info
(
"
Skipping
test
for
Linux
where
preonboarding
is
disabled
by
default
"
)
;
return
;
}
let
modalStub
=
sinon
.
stub
(
Policy
"
showModal
"
)
.
returns
(
true
)
;
fakeResetAcceptedPolicy
(
)
;
TelemetryReportingPolicy
.
reset
(
)
;
let
p
=
Policy
.
delayedSetup
(
)
;
Policy
.
fakeSessionRestoreNotification
(
)
;
fakeInteractWithModal
(
)
;
await
p
;
Assert
.
equal
(
modalStub
.
callCount
1
"
showModal
is
invoked
once
when
not
enrolled
in
an
experiemnt
"
)
;
sinon
.
restore
(
)
;
fakeResetAcceptedPolicy
(
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_modal_not_shown_on_linux
(
)
{
if
(
AppConstants
.
platform
!
=
=
"
linux
"
)
{
info
(
"
Skipping
test
on
non
-
Linux
platforms
"
)
;
return
;
}
let
modalStub
=
sinon
.
stub
(
Policy
"
showModal
"
)
.
returns
(
true
)
;
fakeResetAcceptedPolicy
(
)
;
TelemetryReportingPolicy
.
reset
(
)
;
let
p
=
Policy
.
delayedSetup
(
)
;
Policy
.
fakeSessionRestoreNotification
(
)
;
await
p
;
Assert
.
equal
(
modalStub
.
callCount
0
"
showModal
is
not
invoked
on
Linux
by
default
"
)
;
sinon
.
restore
(
)
;
fakeResetAcceptedPolicy
(
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_jumplist_blocking_on_modal_display_and_unblocking_after_interaction
(
)
{
if
(
AppConstants
.
platform
!
=
=
"
win
"
)
{
info
(
"
Skipping
test
for
Windows
only
behavior
"
)
;
return
;
}
fakeResetAcceptedPolicy
(
)
;
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
FirstRun
)
;
let
blockSpy
=
sinon
.
spy
(
WinTaskbarJumpList
"
blockJumpList
"
)
;
let
unblockSpy
=
sinon
.
spy
(
WinTaskbarJumpList
"
_unblockJumpList
"
)
;
sinon
.
stub
(
Policy
"
showModal
"
)
.
returns
(
true
)
;
let
doCleanup
=
await
enrollInPreonboardingExperiment
(
900
)
;
TelemetryReportingPolicy
.
reset
(
)
;
await
Policy
.
fakeSessionRestoreNotification
(
)
;
Assert
.
ok
(
blockSpy
.
calledOnce
"
Jump
list
should
be
blocked
when
modal
is
presented
.
"
)
;
let
p
=
TelemetryReportingPolicy
.
ensureUserIsNotified
;
fakeInteractWithModal
(
)
;
await
p
;
Assert
.
greaterOrEqual
(
unblockSpy
.
callCount
blockSpy
.
callCount
"
Jump
list
should
be
unblocked
after
user
interacts
with
modal
"
)
;
await
doCleanup
(
)
;
sinon
.
restore
(
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_startup_records_tou_telemetry_if_prefs_already_set
(
)
{
const
timestamp
=
Date
.
now
(
)
;
const
version
=
999
;
Services
.
prefs
.
setStringPref
(
TOU_ACCEPTED_DATE_PREF
timestamp
.
toString
(
)
)
;
Services
.
prefs
.
setIntPref
(
TOU_ACCEPTED_VERSION_PREF
version
)
;
TelemetryReportingPolicy
.
reset
(
)
;
const
metricVersion
=
await
Glean
.
termsofuse
.
version
.
testGetValue
(
)
;
Assert
.
equal
(
metricVersion
version
Glean
.
termsofuse
.
version
is
{
metricVersion
}
and
matches
expected
{
version
}
)
;
const
rawDate
=
await
Glean
.
termsofuse
.
date
.
testGetValue
(
)
;
const
metricSec
=
getDateInSeconds
(
rawDate
)
;
const
expectedSec
=
getDateInSeconds
(
timestamp
)
;
Assert
.
equal
(
metricSec
expectedSec
Glean
.
termsofuse
.
date
(
in
seconds
)
is
{
metricSec
}
and
matches
expected
{
expectedSec
}
)
;
fakeResetAcceptedPolicy
(
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_user_tou_ineligible_notification
(
)
{
Services
.
prefs
.
setBoolPref
(
TOU_BYPASS_NOTIFICATION_PREF
true
)
;
let
doCleanup
=
await
enrollInPreonboardingExperiment
(
999
)
;
TelemetryReportingPolicy
.
reset
(
)
;
const
modalStub
=
sinon
.
stub
(
Policy
"
showModal
"
)
.
returns
(
true
)
;
let
notificationSeen
=
false
;
TestUtils
.
topicObserved
(
TelemetryReportingPolicy
.
TELEMETRY_TOU_ACCEPTED_OR_INELIGIBLE
)
.
then
(
(
)
=
>
(
notificationSeen
=
true
)
)
;
const
p
=
Policy
.
delayedSetup
(
)
;
Policy
.
fakeSessionRestoreNotification
(
)
;
await
TestUtils
.
waitForTick
(
)
;
await
p
;
Assert
.
equal
(
modalStub
.
callCount
0
"
showModal
should
never
be
invoked
when
the
user
is
ineligible
"
)
;
Assert
.
ok
(
notificationSeen
"
System
is
notified
it
is
ok
to
continue
to
initialize
"
)
;
Services
.
prefs
.
setBoolPref
(
TOU_BYPASS_NOTIFICATION_PREF
false
)
;
fakeResetAcceptedPolicy
(
)
;
await
doCleanup
(
)
;
sinon
.
restore
(
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_user_tou_accepted_previously_notification
(
)
{
const
timestamp
=
Date
.
now
(
)
;
const
version
=
999
;
let
doCleanup
=
await
enrollInPreonboardingExperiment
(
999
)
;
Services
.
prefs
.
setStringPref
(
TOU_ACCEPTED_DATE_PREF
timestamp
.
toString
(
)
)
;
Services
.
prefs
.
setIntPref
(
TOU_ACCEPTED_VERSION_PREF
version
)
;
TelemetryReportingPolicy
.
reset
(
)
;
const
modalStub
=
sinon
.
stub
(
Policy
"
showModal
"
)
.
returns
(
true
)
;
let
notificationSeen
=
false
;
TestUtils
.
topicObserved
(
TelemetryReportingPolicy
.
TELEMETRY_TOU_ACCEPTED_OR_INELIGIBLE
)
.
then
(
(
)
=
>
(
notificationSeen
=
true
)
)
;
let
p
=
Policy
.
delayedSetup
(
)
;
Policy
.
fakeSessionRestoreNotification
(
)
;
await
p
;
Assert
.
equal
(
modalStub
.
callCount
0
"
showModal
should
not
be
invoked
when
the
user
previously
accepted
the
ToU
"
)
;
Assert
.
ok
(
notificationSeen
"
System
is
notified
it
is
ok
to
continue
to
initialize
"
)
;
fakeResetAcceptedPolicy
(
)
;
await
doCleanup
(
)
;
sinon
.
restore
(
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_user_tou_accepted_now_notification
(
)
{
const
modalStub
=
sinon
.
stub
(
Policy
"
showModal
"
)
.
returns
(
true
)
;
let
doCleanup
=
await
enrollInPreonboardingExperiment
(
999
)
;
TelemetryReportingPolicy
.
reset
(
)
;
let
notificationSeen
=
false
;
TestUtils
.
topicObserved
(
TelemetryReportingPolicy
.
TELEMETRY_TOU_ACCEPTED_OR_INELIGIBLE
)
.
then
(
(
)
=
>
(
notificationSeen
=
true
)
)
;
let
p
=
Policy
.
delayedSetup
(
)
;
Policy
.
fakeSessionRestoreNotification
(
)
;
await
TestUtils
.
waitForTick
(
)
;
Assert
.
ok
(
!
notificationSeen
"
Notification
should
not
be
dispatched
before
the
user
interacts
"
)
;
Assert
.
equal
(
modalStub
.
callCount
1
"
showModal
should
be
invoked
exactly
once
when
prompting
the
user
"
)
;
fakeInteractWithModal
(
)
;
await
TestUtils
.
waitForTick
(
)
;
await
p
;
Assert
.
ok
(
notificationSeen
"
Notification
fires
after
the
user
accepts
the
ToU
in
this
session
"
)
;
fakeResetAcceptedPolicy
(
)
;
await
doCleanup
(
)
;
sinon
.
restore
(
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_user_tou_ignored_no_notification
(
)
{
const
modalStub
=
sinon
.
stub
(
Policy
"
showModal
"
)
.
returns
(
true
)
;
let
doCleanup
=
await
enrollInPreonboardingExperiment
(
999
)
;
TelemetryReportingPolicy
.
reset
(
)
;
let
notificationSeen
=
false
;
TestUtils
.
topicObserved
(
TelemetryReportingPolicy
.
TELEMETRY_TOU_ACCEPTED_OR_INELIGIBLE
)
.
then
(
(
)
=
>
(
notificationSeen
=
true
)
)
;
let
p
=
Policy
.
delayedSetup
(
)
;
Policy
.
fakeSessionRestoreNotification
(
)
;
await
TestUtils
.
waitForTick
(
)
;
Assert
.
ok
(
!
notificationSeen
"
Notification
should
not
be
dispatched
before
the
user
interacts
"
)
;
Assert
.
equal
(
modalStub
.
callCount
1
"
showModal
should
be
invoked
exactly
once
when
prompting
the
user
"
)
;
await
TestUtils
.
waitForTick
(
)
;
await
p
;
Assert
.
ok
(
!
notificationSeen
"
Notification
should
still
not
be
dispatched
if
never
interacted
with
"
)
;
fakeResetAcceptedPolicy
(
)
;
await
doCleanup
(
)
;
sinon
.
restore
(
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_user_tou_accept_later_notification
(
)
{
const
modalStub
=
sinon
.
stub
(
Policy
"
showModal
"
)
.
returns
(
true
)
;
let
doCleanup
=
await
enrollInPreonboardingExperiment
(
999
)
;
TelemetryReportingPolicy
.
reset
(
)
;
let
notificationSeen
=
false
;
TestUtils
.
topicObserved
(
TelemetryReportingPolicy
.
TELEMETRY_TOU_ACCEPTED_OR_INELIGIBLE
)
.
then
(
(
)
=
>
(
notificationSeen
=
true
)
)
;
let
p
=
Policy
.
delayedSetup
(
)
;
Policy
.
fakeSessionRestoreNotification
(
)
;
await
TestUtils
.
waitForTick
(
)
;
Assert
.
ok
(
!
notificationSeen
"
Notification
should
not
be
dispatched
before
the
user
interacts
"
)
;
Assert
.
equal
(
modalStub
.
callCount
1
"
showModal
should
be
invoked
exactly
once
when
prompting
the
user
"
)
;
await
TestUtils
.
waitForTick
(
)
;
await
p
;
Assert
.
ok
(
!
notificationSeen
"
Notification
should
still
not
be
dispatched
if
never
interacted
with
"
)
;
fakeInteractWithModal
(
)
;
await
TestUtils
.
waitForTick
(
)
;
Assert
.
ok
(
notificationSeen
"
Notification
fires
after
the
user
accepts
the
ToU
in
this
session
"
)
;
fakeResetAcceptedPolicy
(
)
;
await
doCleanup
(
)
;
sinon
.
restore
(
)
;
}
)
;
