const
{
ClientID
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ClientID
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
const
{
Preferences
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
const
PING_FORMAT_VERSION
=
4
;
const
OPTOUT_PING_TYPE
=
"
optout
"
;
const
TEST_PING_TYPE
=
"
test
-
ping
-
type
"
;
function
sendPing
(
addEnvironment
=
false
)
{
let
options
=
{
addClientId
:
true
addEnvironment
}
;
return
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
options
)
;
}
add_task
(
async
function
test_setup
(
)
{
do_get_profile
(
)
;
await
setEmptyPrefWatchlist
(
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
new
Promise
(
resolve
=
>
Telemetry
.
asyncFetchTelemetryData
(
wrapWithExceptionHandler
(
resolve
)
)
)
;
PingServer
.
start
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
Server
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
await
TelemetryController
.
testSetup
(
)
;
}
)
;
add_task
(
async
function
test_clientid_reset_after_reenabling
(
)
{
const
isUnified
=
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
if
(
!
isUnified
)
{
return
;
}
await
sendPing
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
TEST_PING_TYPE
"
The
ping
must
be
a
test
ping
"
)
;
Assert
.
ok
(
"
clientId
"
in
ping
)
;
let
firstClientId
=
ping
.
clientId
;
Assert
.
notEqual
(
TelemetryUtils
.
knownClientID
firstClientId
"
Client
ID
should
be
valid
and
random
"
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
OPTOUT_PING_TYPE
"
The
ping
must
be
an
optout
ping
"
)
;
Assert
.
ok
(
!
(
"
clientId
"
in
ping
)
)
;
let
clientId
=
await
ClientID
.
getClientID
(
)
;
Assert
.
equal
(
TelemetryUtils
.
knownClientID
clientId
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
TelemetryController
.
testReset
(
)
;
let
newClientId
=
await
ClientID
.
getClientID
(
)
;
Assert
.
notEqual
(
TelemetryUtils
.
knownClientID
newClientId
"
Client
ID
should
be
valid
and
random
"
)
;
Assert
.
notEqual
(
firstClientId
newClientId
"
Client
ID
should
be
newly
generated
"
)
;
}
)
;
add_task
(
async
function
test_clientid_canary_after_disabling
(
)
{
const
isUnified
=
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
if
(
!
isUnified
)
{
return
;
}
await
sendPing
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
TEST_PING_TYPE
"
The
ping
must
be
a
test
ping
"
)
;
Assert
.
ok
(
"
clientId
"
in
ping
)
;
let
firstClientId
=
ping
.
clientId
;
Assert
.
notEqual
(
TelemetryUtils
.
knownClientID
firstClientId
"
Client
ID
should
be
valid
and
random
"
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
OPTOUT_PING_TYPE
"
The
ping
must
be
an
optout
ping
"
)
;
Assert
.
ok
(
!
(
"
clientId
"
in
ping
)
)
;
let
clientId
=
await
ClientID
.
getClientID
(
)
;
Assert
.
equal
(
TelemetryUtils
.
knownClientID
clientId
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
sendPing
(
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
TEST_PING_TYPE
"
The
ping
must
be
a
test
ping
"
)
;
Assert
.
notEqual
(
firstClientId
ping
.
clientId
"
Client
ID
should
be
newly
generated
"
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
await
TelemetryController
.
testReset
(
)
;
let
newClientId
=
await
ClientID
.
getClientID
(
)
;
Assert
.
equal
(
TelemetryUtils
.
knownClientID
newClientId
"
Client
ID
should
be
a
canary
when
upload
disabled
"
)
;
}
)
;
add_task
(
async
function
test_clientid_canary_reset_canary_on_nonunified
(
)
{
const
isUnified
=
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
if
(
isUnified
)
{
return
;
}
await
sendPing
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
TEST_PING_TYPE
"
The
ping
must
be
a
test
ping
"
)
;
Assert
.
ok
(
"
clientId
"
in
ping
)
;
let
firstClientId
=
ping
.
clientId
;
Assert
.
notEqual
(
TelemetryUtils
.
knownClientID
firstClientId
"
Client
ID
should
be
valid
and
random
"
)
;
let
clientId
=
await
ClientID
.
setClientID
(
TelemetryUtils
.
knownClientID
)
;
Assert
.
equal
(
TelemetryUtils
.
knownClientID
clientId
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
await
TelemetryController
.
testReset
(
)
;
let
newClientId
=
await
ClientID
.
getClientID
(
)
;
Assert
.
notEqual
(
TelemetryUtils
.
knownClientID
newClientId
"
Client
ID
should
be
valid
and
random
"
)
;
Assert
.
notEqual
(
firstClientId
newClientId
"
Client
ID
should
be
valid
and
random
"
)
;
}
)
;
add_task
(
async
function
test_clientid_canary_nonunified_no_pref_trigger
(
)
{
const
isUnified
=
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
if
(
isUnified
)
{
return
;
}
await
sendPing
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
TEST_PING_TYPE
"
The
ping
must
be
a
test
ping
"
)
;
Assert
.
ok
(
"
clientId
"
in
ping
)
;
let
firstClientId
=
ping
.
clientId
;
Assert
.
notEqual
(
TelemetryUtils
.
knownClientID
firstClientId
"
Client
ID
should
be
valid
and
random
"
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
await
TelemetryController
.
testReset
(
)
;
let
newClientId
=
await
ClientID
.
getClientID
(
)
;
Assert
.
equal
(
firstClientId
newClientId
"
Client
ID
should
be
unmodified
"
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
await
TelemetryController
.
testReset
(
)
;
newClientId
=
await
ClientID
.
getClientID
(
)
;
Assert
.
equal
(
firstClientId
newClientId
"
Client
ID
should
be
unmodified
"
)
;
}
)
;
add_task
(
async
function
test_clientid_canary_nonunified_canary_detected
(
)
{
const
isUnified
=
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
if
(
isUnified
)
{
return
;
}
let
firstClientId
=
await
ClientID
.
resetClientID
(
)
;
await
TelemetryController
.
testReset
(
)
;
await
sendPing
(
true
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
TEST_PING_TYPE
"
The
ping
must
be
a
test
ping
"
)
;
Assert
.
equal
(
firstClientId
ping
.
clientId
"
Client
ID
should
be
from
the
reset
"
)
;
Assert
.
ok
(
!
(
"
wasCanary
"
in
ping
.
environment
.
profile
)
)
;
await
ClientID
.
setClientID
(
TelemetryUtils
.
knownClientID
)
;
await
TelemetryController
.
testReset
(
)
;
await
sendPing
(
true
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
TEST_PING_TYPE
"
The
ping
must
be
a
test
ping
"
)
;
let
clientId
=
ping
.
clientId
;
Assert
.
notEqual
(
TelemetryUtils
.
knownClientID
clientId
"
Client
ID
should
have
been
reset
to
a
valid
one
.
"
)
;
Assert
.
notEqual
(
firstClientId
clientId
"
Client
ID
should
be
a
new
one
after
reset
.
"
)
;
Assert
.
ok
(
ping
.
environment
.
profile
.
wasCanary
"
Previous
canary
client
ID
should
have
been
detected
after
reset
.
"
)
;
await
TelemetryController
.
testReset
(
)
;
await
sendPing
(
true
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
ping
.
type
TEST_PING_TYPE
"
The
ping
must
be
a
test
ping
"
)
;
Assert
.
equal
(
clientId
ping
.
clientId
"
Client
ID
should
be
unmodified
now
.
"
)
;
Assert
.
ok
(
ping
.
environment
.
profile
.
wasCanary
"
Canary
client
ID
flag
should
be
persisted
.
"
)
;
}
)
;
add_task
(
async
function
stopServer
(
)
{
await
PingServer
.
stop
(
)
;
}
)
;
