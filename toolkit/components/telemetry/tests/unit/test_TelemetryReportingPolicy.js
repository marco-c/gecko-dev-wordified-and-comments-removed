"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
ExperimentAPI
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
sys
.
mjs
"
ExperimentFakes
:
"
resource
:
/
/
testing
-
common
/
NimbusTestUtils
.
sys
.
mjs
"
ExperimentManager
:
"
resource
:
/
/
nimbus
/
lib
/
ExperimentManager
.
sys
.
mjs
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
sys
.
mjs
"
UpdateUtils
:
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
sys
.
mjs
"
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
}
)
;
const
{
Policy
TelemetryReportingPolicy
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
sys
.
mjs
"
)
;
const
skipIfNotBrowser
=
(
)
=
>
(
{
skip_if
:
(
)
=
>
AppConstants
.
MOZ_BUILD_APP
!
=
"
browser
"
}
)
;
const
TEST_CHANNEL
=
"
TestChannelABC
"
;
const
PREF_MINIMUM_CHANNEL_POLICY_VERSION
=
TelemetryUtils
.
Preferences
.
MinimumPolicyVersion
+
"
.
channel
-
"
+
TEST_CHANNEL
;
function
fakeShowPolicyTimeout
(
set
clear
)
{
Policy
.
setShowInfobarTimeout
=
set
;
Policy
.
clearShowInfobarTimeout
=
clear
;
}
function
fakeResetAcceptedPolicy
(
)
{
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyDate
)
;
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
)
;
}
function
fakeInteractWithModal
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
datareporting
:
notify
-
data
-
policy
:
interacted
"
)
;
}
function
setMinimumPolicyVersion
(
aNewPolicyVersion
)
{
const
CHANNEL_NAME
=
UpdateUtils
.
getUpdateChannel
(
false
)
;
const
CHANNEL_DEPENDENT_PREF
=
TelemetryUtils
.
Preferences
.
MinimumPolicyVersion
+
"
.
channel
-
"
+
CHANNEL_NAME
;
if
(
Services
.
prefs
.
getIntPref
(
CHANNEL_DEPENDENT_PREF
undefined
)
)
{
Services
.
prefs
.
setIntPref
(
CHANNEL_DEPENDENT_PREF
aNewPolicyVersion
)
;
return
;
}
Services
.
prefs
.
setIntPref
(
TelemetryUtils
.
Preferences
.
MinimumPolicyVersion
aNewPolicyVersion
)
;
}
function
unsetMinimumPolicyVersion
(
)
{
const
CHANNEL_NAME
=
UpdateUtils
.
getUpdateChannel
(
false
)
;
const
CHANNEL_DEPENDENT_PREF
=
TelemetryUtils
.
Preferences
.
MinimumPolicyVersion
+
"
.
channel
-
"
+
CHANNEL_NAME
;
if
(
Services
.
prefs
.
getIntPref
(
CHANNEL_DEPENDENT_PREF
undefined
)
)
{
Services
.
prefs
.
clearUserPref
(
CHANNEL_DEPENDENT_PREF
)
;
}
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
MinimumPolicyVersion
)
;
}
add_setup
(
async
function
test_setup
(
)
{
do_get_profile
(
true
)
;
await
loadAddonManager
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
.
9
.
2
"
)
;
finishAddonManagerStartup
(
)
;
fakeIntlReady
(
)
;
await
setEmptyPrefWatchlist
(
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
BypassNotification
false
)
;
TelemetryReportingPolicy
.
setup
(
)
;
}
)
;
add_setup
(
skipIfNotBrowser
(
)
async
(
)
=
>
{
await
ExperimentManager
.
onStartup
(
)
;
await
ExperimentAPI
.
ready
(
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_firstRun
(
)
{
await
Services
.
search
.
init
(
)
;
const
FIRST_RUN_TIMEOUT_MSEC
=
60
*
1000
;
const
OTHER_RUNS_TIMEOUT_MSEC
=
10
*
1000
;
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
FirstRun
)
;
let
promiseTimeout
=
(
)
=
>
new
Promise
(
resolve
=
>
{
fakeShowPolicyTimeout
(
(
_callback
timeout
)
=
>
resolve
(
timeout
)
(
)
=
>
{
}
)
;
}
)
;
let
p
startupTimeout
;
TelemetryReportingPolicy
.
reset
(
)
;
p
=
promiseTimeout
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
windows
-
restored
"
)
;
startupTimeout
=
await
p
;
Assert
.
equal
(
startupTimeout
FIRST_RUN_TIMEOUT_MSEC
"
The
infobar
display
timeout
should
be
60s
on
the
first
run
.
"
)
;
TelemetryReportingPolicy
.
reset
(
)
;
p
=
promiseTimeout
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
windows
-
restored
"
)
;
startupTimeout
=
await
p
;
Assert
.
equal
(
startupTimeout
OTHER_RUNS_TIMEOUT_MSEC
"
The
infobar
display
timeout
should
be
10s
on
other
runs
.
"
)
;
}
)
;
add_task
(
async
function
test_prefs
(
)
{
TelemetryReportingPolicy
.
reset
(
)
;
let
now
=
fakeNow
(
2009
11
18
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
)
;
Assert
.
equal
(
Services
.
prefs
.
getStringPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyDate
null
)
0
"
Invalid
dates
should
not
make
the
policy
accepted
.
"
)
;
now
=
fakeNow
(
2012
11
18
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
equal
(
Services
.
prefs
.
getStringPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyDate
null
)
now
.
getTime
(
)
"
A
valid
date
must
correctly
be
saved
.
"
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
We
must
be
able
to
upload
after
the
policy
is
accepted
.
"
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
DataSubmissionEnabled
false
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
canUpload
(
)
"
We
must
not
be
able
to
upload
if
data
submission
is
disabled
.
"
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
DataSubmissionEnabled
true
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
We
must
be
able
to
upload
if
data
submission
is
enabled
and
the
policy
was
accepted
.
"
)
;
let
newMinimum
=
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
1
)
+
1
;
setMinimumPolicyVersion
(
newMinimum
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
A
greater
minimum
policy
version
must
invalidate
the
policy
and
disable
upload
.
"
)
;
Services
.
prefs
.
setIntPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
newMinimum
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
Accepting
the
policy
again
should
show
the
user
as
notified
.
"
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
Accepting
the
policy
again
should
let
us
upload
data
.
"
)
;
if
(
Services
.
prefs
.
getDefaultBranch
(
"
"
)
.
prefIsLocked
(
"
app
.
update
.
channel
"
)
)
{
Services
.
prefs
.
getDefaultBranch
(
"
"
)
.
unlockPref
(
"
app
.
update
.
channel
"
)
;
}
Services
.
prefs
.
getDefaultBranch
(
"
"
)
.
setStringPref
(
"
app
.
update
.
channel
"
TEST_CHANNEL
)
;
newMinimum
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_MINIMUM_CHANNEL_POLICY_VERSION
newMinimum
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
Increasing
the
minimum
policy
version
should
invalidate
the
policy
.
"
)
;
Services
.
prefs
.
setIntPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
newMinimum
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
Accepting
the
policy
again
should
show
the
user
as
notified
.
"
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
Accepting
the
policy
again
should
let
us
upload
data
.
"
)
;
}
)
;
add_task
(
async
function
test_migratePrefs
(
)
{
const
DEPRECATED_FHR_PREFS
=
{
"
datareporting
.
policy
.
dataSubmissionPolicyAccepted
"
:
true
"
datareporting
.
policy
.
dataSubmissionPolicyBypassAcceptance
"
:
true
"
datareporting
.
policy
.
dataSubmissionPolicyResponseType
"
:
"
foxyeah
"
"
datareporting
.
policy
.
dataSubmissionPolicyResponseTime
"
:
Date
.
now
(
)
.
toString
(
)
}
;
for
(
let
name
in
DEPRECATED_FHR_PREFS
)
{
switch
(
typeof
DEPRECATED_FHR_PREFS
[
name
]
)
{
case
"
string
"
:
Services
.
prefs
.
setStringPref
(
name
DEPRECATED_FHR_PREFS
[
name
]
)
;
break
;
case
"
number
"
:
Services
.
prefs
.
setIntPref
(
name
DEPRECATED_FHR_PREFS
[
name
]
)
;
break
;
case
"
boolean
"
:
Services
.
prefs
.
setBoolPref
(
name
DEPRECATED_FHR_PREFS
[
name
]
)
;
break
;
}
}
TelemetryReportingPolicy
.
reset
(
)
;
for
(
let
name
in
DEPRECATED_FHR_PREFS
)
{
Assert
.
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
name
)
name
+
"
should
have
been
removed
.
"
)
;
}
}
)
;
add_task
(
async
function
test_userNotifiedOfCurrentPolicy
(
)
{
fakeResetAcceptedPolicy
(
)
;
TelemetryReportingPolicy
.
reset
(
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
The
initial
state
should
be
unnotified
.
"
)
;
Services
.
prefs
.
setIntPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
TelemetryReportingPolicy
.
DEFAULT_DATAREPORTING_POLICY_VERSION
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
The
default
state
of
the
date
should
have
a
time
of
0
and
it
should
therefore
fail
"
)
;
fakeNow
(
2012
11
11
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
Using
the
proper
API
causes
user
notification
to
report
as
true
.
"
)
;
let
newVersion
=
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
1
)
+
1
;
Services
.
prefs
.
setIntPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
newVersion
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
A
future
version
of
the
policy
should
pass
.
"
)
;
newVersion
=
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
1
)
-
1
;
Services
.
prefs
.
setIntPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
newVersion
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
A
previous
version
of
the
policy
should
fail
.
"
)
;
}
)
;
add_task
(
async
function
test_canSend
(
)
{
const
TEST_PING_TYPE
=
"
test
-
ping
"
;
PingServer
.
start
(
)
;
Services
.
prefs
.
setStringPref
(
TelemetryUtils
.
Preferences
.
Server
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
await
TelemetryController
.
testReset
(
)
;
TelemetryReportingPolicy
.
reset
(
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
The
initial
state
should
be
unnotified
.
"
)
;
PingServer
.
registerPingHandler
(
(
)
=
>
Assert
.
ok
(
false
"
Should
not
have
received
any
pings
now
"
)
)
;
await
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
)
;
PingServer
.
resetPingHandler
(
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
let
ping
=
await
PingServer
.
promiseNextPings
(
1
)
;
Assert
.
equal
(
ping
.
length
1
"
We
should
have
received
one
ping
.
"
)
;
Assert
.
equal
(
ping
[
0
]
.
type
TEST_PING_TYPE
"
We
should
have
received
the
previous
ping
.
"
)
;
await
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
)
;
ping
=
await
PingServer
.
promiseNextPings
(
1
)
;
Assert
.
equal
(
ping
.
length
1
"
We
should
have
received
one
ping
.
"
)
;
Assert
.
equal
(
ping
[
0
]
.
type
TEST_PING_TYPE
"
We
should
have
received
the
new
ping
.
"
)
;
await
TelemetryController
.
addPendingPing
(
TEST_PING_TYPE
{
}
)
;
await
TelemetryController
.
testReset
(
)
;
ping
=
await
PingServer
.
promiseNextPings
(
1
)
;
Assert
.
equal
(
ping
.
length
1
"
We
should
have
received
one
ping
.
"
)
;
Assert
.
equal
(
ping
[
0
]
.
type
TEST_PING_TYPE
"
We
should
have
received
the
pending
ping
.
"
)
;
await
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
)
;
ping
=
await
PingServer
.
promiseNextPings
(
1
)
;
Assert
.
equal
(
ping
.
length
1
"
We
should
have
received
one
ping
.
"
)
;
Assert
.
equal
(
ping
[
0
]
.
type
TEST_PING_TYPE
"
We
should
have
received
the
new
ping
.
"
)
;
await
PingServer
.
stop
(
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_feature_prefs
(
)
{
function
assertPrefs
(
currentPolicyVersion
minimumPolicyVersion
firstRunURL
)
{
Assert
.
equal
(
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
)
currentPolicyVersion
"
datareporting
.
policy
.
currentPolicyVersion
is
set
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
MinimumPolicyVersion
)
minimumPolicyVersion
"
datareporting
.
policy
.
minimumPolicyVersion
is
set
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
TelemetryUtils
.
Preferences
.
FirstRunURL
)
firstRunURL
"
datareporting
.
policy
.
firstRunURL
is
set
"
)
;
}
unsetMinimumPolicyVersion
(
)
;
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
)
;
let
doCleanup
=
await
ExperimentFakes
.
enrollWithFeatureConfig
(
{
featureId
:
NimbusFeatures
.
preonboarding
.
featureId
value
:
{
enabled
:
true
currentPolicyVersion
:
900
minimumPolicyVersion
:
899
firstRunURL
:
"
http
:
/
/
mochi
.
test
/
v900
"
}
}
{
isRollout
:
false
}
)
;
Assert
.
ok
(
NimbusFeatures
.
preonboarding
.
getVariable
(
"
enabled
"
)
)
;
TelemetryReportingPolicy
.
reset
(
)
;
Assert
.
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
)
"
datareporting
.
policy
.
currentPolicyVersion
is
not
set
"
)
;
Assert
.
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
TelemetryUtils
.
Preferences
.
MinimumPolicyVersion
)
"
datareporting
.
policy
.
minimumPolicyVersion
is
not
set
"
)
;
Assert
.
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
TelemetryUtils
.
Preferences
.
FirstRunURL
)
"
datareporting
.
policy
.
firstRunURL
is
not
set
"
)
;
await
Policy
.
fakeSessionRestoreNotification
(
)
;
assertPrefs
(
900
899
"
http
:
/
/
mochi
.
test
/
v900
"
)
;
doCleanup
(
)
;
Assert
.
ok
(
!
NimbusFeatures
.
preonboarding
.
getVariable
(
"
enabled
"
)
)
;
assertPrefs
(
900
899
"
http
:
/
/
mochi
.
test
/
v900
"
)
;
doCleanup
=
await
ExperimentFakes
.
enrollWithFeatureConfig
(
{
featureId
:
NimbusFeatures
.
preonboarding
.
featureId
value
:
{
enabled
:
true
currentPolicyVersion
:
901
minimumPolicyVersion
:
900
firstRunURL
:
"
http
:
/
/
mochi
.
test
/
v901
"
}
}
{
isRollout
:
false
}
)
;
Assert
.
ok
(
NimbusFeatures
.
preonboarding
.
getVariable
(
"
enabled
"
)
)
;
assertPrefs
(
900
899
"
http
:
/
/
mochi
.
test
/
v900
"
)
;
doCleanup
(
)
;
}
)
;
async
function
doOneModalFlow
(
version
)
{
let
doCleanup
=
await
ExperimentFakes
.
enrollWithFeatureConfig
(
{
featureId
:
NimbusFeatures
.
preonboarding
.
featureId
value
:
{
enabled
:
true
currentPolicyVersion
:
version
minimumPolicyVersion
:
version
firstRunURL
:
http
:
/
/
mochi
.
test
/
v
{
version
}
screens
:
[
{
id
:
"
test
"
}
]
}
}
{
isRollout
:
false
}
)
;
let
displayStub
=
sinon
.
stub
(
Policy
"
showModal
"
)
.
returns
(
true
)
;
TelemetryReportingPolicy
.
reset
(
)
;
await
Policy
.
fakeSessionRestoreNotification
(
)
;
Assert
.
equal
(
displayStub
.
callCount
1
"
showModal
is
invoked
"
)
;
Assert
.
equal
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
false
"
Before
interaction
the
user
should
be
reported
as
not
notified
"
)
;
let
completed
=
false
;
let
p
=
TelemetryReportingPolicy
.
ensureUserIsNotified
(
)
.
then
(
(
)
=
>
(
completed
=
true
)
)
;
Assert
.
equal
(
completed
false
"
The
notification
promise
should
not
resolve
before
the
user
interacts
"
)
;
fakeInteractWithModal
(
)
;
await
p
;
Assert
.
equal
(
completed
true
"
The
notification
promise
should
resolve
after
user
interacts
"
)
;
Assert
.
equal
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
true
"
After
interaction
the
state
should
be
notified
.
"
)
;
doCleanup
(
)
;
sinon
.
restore
(
)
;
}
add_task
(
skipIfNotBrowser
(
)
async
function
test_modal_flow_before_notification
(
)
{
fakeResetAcceptedPolicy
(
)
;
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
FirstRun
)
;
await
doOneModalFlow
(
900
)
;
Assert
.
equal
(
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
)
900
)
;
}
)
;
add_task
(
skipIfNotBrowser
(
)
async
function
test_modal_flow_after_notification
(
)
{
unsetMinimumPolicyVersion
(
)
;
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
)
;
fakeResetAcceptedPolicy
(
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
FirstRun
false
)
;
TelemetryReportingPolicy
.
reset
(
)
;
fakeNow
(
2012
11
11
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
User
is
notified
after
seeing
the
legacy
infobar
"
)
;
Assert
.
ok
(
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
)
<
900
"
Before
the
user
has
not
accepted
experiment
/
rollout
version
"
)
;
await
doOneModalFlow
(
900
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
User
is
notified
after
seeing
the
experiment
modal
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
)
900
"
After
the
user
has
accepted
the
experiment
/
rollout
version
.
"
)
;
}
)
;
