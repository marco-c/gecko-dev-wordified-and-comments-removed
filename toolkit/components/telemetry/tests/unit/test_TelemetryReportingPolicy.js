"
use
strict
"
;
const
{
TelemetryReportingPolicy
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
sys
.
mjs
"
)
;
const
{
UpdateUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
sys
.
mjs
"
)
;
const
TEST_CHANNEL
=
"
TestChannelABC
"
;
const
PREF_MINIMUM_CHANNEL_POLICY_VERSION
=
TelemetryUtils
.
Preferences
.
MinimumPolicyVersion
+
"
.
channel
-
"
+
TEST_CHANNEL
;
function
fakeShowPolicyTimeout
(
set
clear
)
{
let
{
Policy
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
sys
.
mjs
"
)
;
Policy
.
setShowInfobarTimeout
=
set
;
Policy
.
clearShowInfobarTimeout
=
clear
;
}
function
fakeResetAcceptedPolicy
(
)
{
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyDate
)
;
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
)
;
}
function
setMinimumPolicyVersion
(
aNewPolicyVersion
)
{
const
CHANNEL_NAME
=
UpdateUtils
.
getUpdateChannel
(
false
)
;
const
CHANNEL_DEPENDENT_PREF
=
TelemetryUtils
.
Preferences
.
MinimumPolicyVersion
+
"
.
channel
-
"
+
CHANNEL_NAME
;
if
(
Services
.
prefs
.
getIntPref
(
CHANNEL_DEPENDENT_PREF
undefined
)
)
{
Services
.
prefs
.
setIntPref
(
CHANNEL_DEPENDENT_PREF
aNewPolicyVersion
)
;
return
;
}
Services
.
prefs
.
setIntPref
(
TelemetryUtils
.
Preferences
.
MinimumPolicyVersion
aNewPolicyVersion
)
;
}
add_setup
(
async
function
test_setup
(
)
{
do_get_profile
(
true
)
;
await
loadAddonManager
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
.
9
.
2
"
)
;
finishAddonManagerStartup
(
)
;
fakeIntlReady
(
)
;
await
setEmptyPrefWatchlist
(
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
BypassNotification
false
)
;
TelemetryReportingPolicy
.
setup
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
AppConstants
.
platform
=
=
"
android
"
}
async
function
test_firstRun
(
)
{
await
Services
.
search
.
init
(
)
;
const
FIRST_RUN_TIMEOUT_MSEC
=
60
*
1000
;
const
OTHER_RUNS_TIMEOUT_MSEC
=
10
*
1000
;
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
FirstRun
)
;
let
promiseTimeout
=
(
)
=
>
new
Promise
(
resolve
=
>
{
fakeShowPolicyTimeout
(
(
_callback
timeout
)
=
>
resolve
(
timeout
)
(
)
=
>
{
}
)
;
}
)
;
let
p
startupTimeout
;
TelemetryReportingPolicy
.
reset
(
)
;
p
=
promiseTimeout
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
windows
-
restored
"
)
;
startupTimeout
=
await
p
;
Assert
.
equal
(
startupTimeout
FIRST_RUN_TIMEOUT_MSEC
"
The
infobar
display
timeout
should
be
60s
on
the
first
run
.
"
)
;
TelemetryReportingPolicy
.
reset
(
)
;
p
=
promiseTimeout
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
windows
-
restored
"
)
;
startupTimeout
=
await
p
;
Assert
.
equal
(
startupTimeout
OTHER_RUNS_TIMEOUT_MSEC
"
The
infobar
display
timeout
should
be
10s
on
other
runs
.
"
)
;
}
)
;
add_task
(
async
function
test_prefs
(
)
{
TelemetryReportingPolicy
.
reset
(
)
;
let
now
=
fakeNow
(
2009
11
18
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
)
;
Assert
.
equal
(
Services
.
prefs
.
getStringPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyDate
null
)
0
"
Invalid
dates
should
not
make
the
policy
accepted
.
"
)
;
now
=
fakeNow
(
2012
11
18
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
equal
(
Services
.
prefs
.
getStringPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyDate
null
)
now
.
getTime
(
)
"
A
valid
date
must
correctly
be
saved
.
"
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
We
must
be
able
to
upload
after
the
policy
is
accepted
.
"
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
DataSubmissionEnabled
false
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
canUpload
(
)
"
We
must
not
be
able
to
upload
if
data
submission
is
disabled
.
"
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
DataSubmissionEnabled
true
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
We
must
be
able
to
upload
if
data
submission
is
enabled
and
the
policy
was
accepted
.
"
)
;
let
newMinimum
=
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
1
)
+
1
;
setMinimumPolicyVersion
(
newMinimum
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
A
greater
minimum
policy
version
must
invalidate
the
policy
and
disable
upload
.
"
)
;
Services
.
prefs
.
setIntPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
newMinimum
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
Accepting
the
policy
again
should
show
the
user
as
notified
.
"
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
Accepting
the
policy
again
should
let
us
upload
data
.
"
)
;
if
(
Services
.
prefs
.
getDefaultBranch
(
"
"
)
.
prefIsLocked
(
"
app
.
update
.
channel
"
)
)
{
Services
.
prefs
.
getDefaultBranch
(
"
"
)
.
unlockPref
(
"
app
.
update
.
channel
"
)
;
}
Services
.
prefs
.
getDefaultBranch
(
"
"
)
.
setStringPref
(
"
app
.
update
.
channel
"
TEST_CHANNEL
)
;
newMinimum
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_MINIMUM_CHANNEL_POLICY_VERSION
newMinimum
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
Increasing
the
minimum
policy
version
should
invalidate
the
policy
.
"
)
;
Services
.
prefs
.
setIntPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
newMinimum
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
Accepting
the
policy
again
should
show
the
user
as
notified
.
"
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
Accepting
the
policy
again
should
let
us
upload
data
.
"
)
;
}
)
;
add_task
(
async
function
test_migratePrefs
(
)
{
const
DEPRECATED_FHR_PREFS
=
{
"
datareporting
.
policy
.
dataSubmissionPolicyAccepted
"
:
true
"
datareporting
.
policy
.
dataSubmissionPolicyBypassAcceptance
"
:
true
"
datareporting
.
policy
.
dataSubmissionPolicyResponseType
"
:
"
foxyeah
"
"
datareporting
.
policy
.
dataSubmissionPolicyResponseTime
"
:
Date
.
now
(
)
.
toString
(
)
}
;
for
(
let
name
in
DEPRECATED_FHR_PREFS
)
{
switch
(
typeof
DEPRECATED_FHR_PREFS
[
name
]
)
{
case
"
string
"
:
Services
.
prefs
.
setStringPref
(
name
DEPRECATED_FHR_PREFS
[
name
]
)
;
break
;
case
"
number
"
:
Services
.
prefs
.
setIntPref
(
name
DEPRECATED_FHR_PREFS
[
name
]
)
;
break
;
case
"
boolean
"
:
Services
.
prefs
.
setBoolPref
(
name
DEPRECATED_FHR_PREFS
[
name
]
)
;
break
;
}
}
TelemetryReportingPolicy
.
reset
(
)
;
for
(
let
name
in
DEPRECATED_FHR_PREFS
)
{
Assert
.
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
name
)
name
+
"
should
have
been
removed
.
"
)
;
}
}
)
;
add_task
(
async
function
test_userNotifiedOfCurrentPolicy
(
)
{
fakeResetAcceptedPolicy
(
)
;
TelemetryReportingPolicy
.
reset
(
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
The
initial
state
should
be
unnotified
.
"
)
;
Services
.
prefs
.
setIntPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
TelemetryReportingPolicy
.
DEFAULT_DATAREPORTING_POLICY_VERSION
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
The
default
state
of
the
date
should
have
a
time
of
0
and
it
should
therefore
fail
"
)
;
fakeNow
(
2012
11
11
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
Using
the
proper
API
causes
user
notification
to
report
as
true
.
"
)
;
let
newVersion
=
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
1
)
+
1
;
Services
.
prefs
.
setIntPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
newVersion
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
A
future
version
of
the
policy
should
pass
.
"
)
;
newVersion
=
Services
.
prefs
.
getIntPref
(
TelemetryUtils
.
Preferences
.
CurrentPolicyVersion
1
)
-
1
;
Services
.
prefs
.
setIntPref
(
TelemetryUtils
.
Preferences
.
AcceptedPolicyVersion
newVersion
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
A
previous
version
of
the
policy
should
fail
.
"
)
;
}
)
;
add_task
(
async
function
test_canSend
(
)
{
const
TEST_PING_TYPE
=
"
test
-
ping
"
;
PingServer
.
start
(
)
;
Services
.
prefs
.
setStringPref
(
TelemetryUtils
.
Preferences
.
Server
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
await
TelemetryController
.
testReset
(
)
;
TelemetryReportingPolicy
.
reset
(
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
The
initial
state
should
be
unnotified
.
"
)
;
PingServer
.
registerPingHandler
(
(
)
=
>
Assert
.
ok
(
false
"
Should
not
have
received
any
pings
now
"
)
)
;
await
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
)
;
PingServer
.
resetPingHandler
(
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
let
ping
=
await
PingServer
.
promiseNextPings
(
1
)
;
Assert
.
equal
(
ping
.
length
1
"
We
should
have
received
one
ping
.
"
)
;
Assert
.
equal
(
ping
[
0
]
.
type
TEST_PING_TYPE
"
We
should
have
received
the
previous
ping
.
"
)
;
await
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
)
;
ping
=
await
PingServer
.
promiseNextPings
(
1
)
;
Assert
.
equal
(
ping
.
length
1
"
We
should
have
received
one
ping
.
"
)
;
Assert
.
equal
(
ping
[
0
]
.
type
TEST_PING_TYPE
"
We
should
have
received
the
new
ping
.
"
)
;
await
TelemetryController
.
addPendingPing
(
TEST_PING_TYPE
{
}
)
;
await
TelemetryController
.
testReset
(
)
;
ping
=
await
PingServer
.
promiseNextPings
(
1
)
;
Assert
.
equal
(
ping
.
length
1
"
We
should
have
received
one
ping
.
"
)
;
Assert
.
equal
(
ping
[
0
]
.
type
TEST_PING_TYPE
"
We
should
have
received
the
pending
ping
.
"
)
;
await
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
)
;
ping
=
await
PingServer
.
promiseNextPings
(
1
)
;
Assert
.
equal
(
ping
.
length
1
"
We
should
have
received
one
ping
.
"
)
;
Assert
.
equal
(
ping
[
0
]
.
type
TEST_PING_TYPE
"
We
should
have
received
the
new
ping
.
"
)
;
await
PingServer
.
stop
(
)
;
}
)
;
