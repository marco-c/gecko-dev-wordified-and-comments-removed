"
use
strict
"
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
this
)
;
const
PREF_BRANCH
=
"
toolkit
.
telemetry
.
"
;
const
PREF_SERVER
=
PREF_BRANCH
+
"
server
"
;
const
TEST_CHANNEL
=
"
TestChannelABC
"
;
const
PREF_POLICY_BRANCH
=
"
datareporting
.
policy
.
"
;
const
PREF_BYPASS_NOTIFICATION
=
PREF_POLICY_BRANCH
+
"
dataSubmissionPolicyBypassNotification
"
;
const
PREF_DATA_SUBMISSION_ENABLED
=
PREF_POLICY_BRANCH
+
"
dataSubmissionEnabled
"
;
const
PREF_CURRENT_POLICY_VERSION
=
PREF_POLICY_BRANCH
+
"
currentPolicyVersion
"
;
const
PREF_MINIMUM_POLICY_VERSION
=
PREF_POLICY_BRANCH
+
"
minimumPolicyVersion
"
;
const
PREF_MINIMUM_CHANNEL_POLICY_VERSION
=
PREF_MINIMUM_POLICY_VERSION
+
"
.
channel
-
"
+
TEST_CHANNEL
;
const
PREF_ACCEPTED_POLICY_VERSION
=
PREF_POLICY_BRANCH
+
"
dataSubmissionPolicyAcceptedVersion
"
;
const
PREF_ACCEPTED_POLICY_DATE
=
PREF_POLICY_BRANCH
+
"
dataSubmissionPolicyNotifiedTime
"
;
function
fakeShowPolicyTimeout
(
set
clear
)
{
let
reportingPolicy
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
)
;
reportingPolicy
.
Policy
.
setShowInfobarTimeout
=
set
;
reportingPolicy
.
Policy
.
clearShowInfobarTimeout
=
clear
;
}
function
fakeResetAcceptedPolicy
(
)
{
Preferences
.
reset
(
PREF_ACCEPTED_POLICY_DATE
)
;
Preferences
.
reset
(
PREF_ACCEPTED_POLICY_VERSION
)
;
}
function
setMinimumPolicyVersion
(
aNewPolicyVersion
)
{
const
CHANNEL_NAME
=
UpdateUtils
.
getUpdateChannel
(
false
)
;
const
CHANNEL_DEPENDENT_PREF
=
PREF_MINIMUM_POLICY_VERSION
+
"
.
channel
-
"
+
CHANNEL_NAME
;
if
(
Preferences
.
get
(
CHANNEL_DEPENDENT_PREF
undefined
)
)
{
Preferences
.
set
(
CHANNEL_DEPENDENT_PREF
aNewPolicyVersion
)
;
return
;
}
Preferences
.
set
(
PREF_MINIMUM_POLICY_VERSION
aNewPolicyVersion
)
;
}
function
run_test
(
)
{
do_get_profile
(
true
)
;
loadAddonManager
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
.
9
.
2
"
)
;
Services
.
prefs
.
setBoolPref
(
PREF_TELEMETRY_ENABLED
true
)
;
Services
.
prefs
.
setBoolPref
(
PREF_BYPASS_NOTIFICATION
false
)
;
TelemetryReportingPolicy
.
setup
(
)
;
run_next_test
(
)
;
}
add_task
(
function
*
test_firstRun
(
)
{
const
PREF_FIRST_RUN
=
"
toolkit
.
telemetry
.
reportingpolicy
.
firstRun
"
;
const
FIRST_RUN_TIMEOUT_MSEC
=
60
*
1000
;
const
OTHER_RUNS_TIMEOUT_MSEC
=
10
*
1000
;
Preferences
.
reset
(
PREF_FIRST_RUN
)
;
let
startupTimeout
=
0
;
fakeShowPolicyTimeout
(
(
callback
timeout
)
=
>
startupTimeout
=
timeout
(
)
=
>
{
}
)
;
TelemetryReportingPolicy
.
reset
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
windows
-
restored
"
null
)
;
Assert
.
equal
(
startupTimeout
FIRST_RUN_TIMEOUT_MSEC
"
The
infobar
display
timeout
should
be
60s
on
the
first
run
.
"
)
;
TelemetryReportingPolicy
.
reset
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
windows
-
restored
"
null
)
;
Assert
.
equal
(
startupTimeout
OTHER_RUNS_TIMEOUT_MSEC
"
The
infobar
display
timeout
should
be
10s
on
other
runs
.
"
)
;
}
)
;
add_task
(
function
*
test_prefs
(
)
{
TelemetryReportingPolicy
.
reset
(
)
;
let
now
=
fakeNow
(
2009
11
18
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
)
;
Assert
.
equal
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_DATE
null
)
0
"
Invalid
dates
should
not
make
the
policy
accepted
.
"
)
;
now
=
fakeNow
(
2012
11
18
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
equal
(
Preferences
.
get
(
PREF_ACCEPTED_POLICY_DATE
null
)
now
.
getTime
(
)
"
A
valid
date
must
correctly
be
saved
.
"
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
We
must
be
able
to
upload
after
the
policy
is
accepted
.
"
)
;
Preferences
.
set
(
PREF_DATA_SUBMISSION_ENABLED
false
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
canUpload
(
)
"
We
must
not
be
able
to
upload
if
data
submission
is
disabled
.
"
)
;
Preferences
.
set
(
PREF_DATA_SUBMISSION_ENABLED
true
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
We
must
be
able
to
upload
if
data
submission
is
enabled
and
the
policy
was
accepted
.
"
)
;
let
newMinimum
=
Preferences
.
get
(
PREF_CURRENT_POLICY_VERSION
1
)
+
1
;
setMinimumPolicyVersion
(
newMinimum
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
A
greater
minimum
policy
version
must
invalidate
the
policy
and
disable
upload
.
"
)
;
Preferences
.
set
(
PREF_CURRENT_POLICY_VERSION
newMinimum
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
Accepting
the
policy
again
should
show
the
user
as
notified
.
"
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
Accepting
the
policy
again
should
let
us
upload
data
.
"
)
;
let
defaultPrefs
=
new
Preferences
(
{
defaultBranch
:
true
}
)
;
defaultPrefs
.
set
(
"
app
.
update
.
channel
"
TEST_CHANNEL
)
;
newMinimum
+
+
;
Preferences
.
set
(
PREF_MINIMUM_CHANNEL_POLICY_VERSION
newMinimum
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
Increasing
the
minimum
policy
version
should
invalidate
the
policy
.
"
)
;
Preferences
.
set
(
PREF_CURRENT_POLICY_VERSION
newMinimum
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
Accepting
the
policy
again
should
show
the
user
as
notified
.
"
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
canUpload
(
)
"
Accepting
the
policy
again
should
let
us
upload
data
.
"
)
;
}
)
;
add_task
(
function
*
test_migratePrefs
(
)
{
const
DEPRECATED_FHR_PREFS
=
{
"
datareporting
.
policy
.
dataSubmissionPolicyAccepted
"
:
true
"
datareporting
.
policy
.
dataSubmissionPolicyBypassAcceptance
"
:
true
"
datareporting
.
policy
.
dataSubmissionPolicyResponseType
"
:
"
foxyeah
"
"
datareporting
.
policy
.
dataSubmissionPolicyResponseTime
"
:
Date
.
now
(
)
.
toString
(
)
}
;
for
(
let
name
in
DEPRECATED_FHR_PREFS
)
{
Preferences
.
set
(
name
DEPRECATED_FHR_PREFS
[
name
]
)
;
}
TelemetryReportingPolicy
.
reset
(
)
;
for
(
let
name
in
DEPRECATED_FHR_PREFS
)
{
Assert
.
ok
(
!
Preferences
.
has
(
name
)
name
+
"
should
have
been
removed
.
"
)
;
}
}
)
;
add_task
(
function
*
test_userNotifiedOfCurrentPolicy
(
)
{
fakeResetAcceptedPolicy
(
)
;
TelemetryReportingPolicy
.
reset
(
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
The
initial
state
should
be
unnotified
.
"
)
;
Preferences
.
set
(
PREF_ACCEPTED_POLICY_VERSION
TelemetryReportingPolicy
.
DEFAULT_DATAREPORTING_POLICY_VERSION
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
The
default
state
of
the
date
should
have
a
time
of
0
and
it
should
therefore
fail
"
)
;
let
now
=
fakeNow
(
2012
11
11
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
Using
the
proper
API
causes
user
notification
to
report
as
true
.
"
)
;
let
newVersion
=
Preferences
.
get
(
PREF_CURRENT_POLICY_VERSION
1
)
+
1
;
Preferences
.
set
(
PREF_ACCEPTED_POLICY_VERSION
newVersion
)
;
Assert
.
ok
(
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
A
future
version
of
the
policy
should
pass
.
"
)
;
newVersion
=
Preferences
.
get
(
PREF_CURRENT_POLICY_VERSION
1
)
-
1
;
Preferences
.
set
(
PREF_ACCEPTED_POLICY_VERSION
newVersion
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
A
previous
version
of
the
policy
should
fail
.
"
)
;
}
)
;
add_task
(
function
*
test_canSend
(
)
{
const
TEST_PING_TYPE
=
"
test
-
ping
"
;
PingServer
.
start
(
)
;
Preferences
.
set
(
PREF_SERVER
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
yield
TelemetryController
.
reset
(
)
;
TelemetryReportingPolicy
.
reset
(
)
;
Assert
.
ok
(
!
TelemetryReportingPolicy
.
testIsUserNotified
(
)
"
The
initial
state
should
be
unnotified
.
"
)
;
PingServer
.
registerPingHandler
(
(
)
=
>
Assert
.
ok
(
false
"
Should
not
have
received
any
pings
now
"
)
)
;
yield
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
)
;
PingServer
.
resetPingHandler
(
)
;
TelemetryReportingPolicy
.
testInfobarShown
(
)
;
let
ping
=
yield
PingServer
.
promiseNextPings
(
1
)
;
Assert
.
equal
(
ping
.
length
1
"
We
should
have
received
one
ping
.
"
)
;
Assert
.
equal
(
ping
[
0
]
.
type
TEST_PING_TYPE
"
We
should
have
received
the
previous
ping
.
"
)
;
yield
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
)
;
ping
=
yield
PingServer
.
promiseNextPings
(
1
)
;
Assert
.
equal
(
ping
.
length
1
"
We
should
have
received
one
ping
.
"
)
;
Assert
.
equal
(
ping
[
0
]
.
type
TEST_PING_TYPE
"
We
should
have
received
the
new
ping
.
"
)
;
yield
TelemetryController
.
addPendingPing
(
TEST_PING_TYPE
{
}
)
;
yield
TelemetryController
.
reset
(
)
;
ping
=
yield
PingServer
.
promiseNextPings
(
1
)
;
Assert
.
equal
(
ping
.
length
1
"
We
should
have
received
one
ping
.
"
)
;
Assert
.
equal
(
ping
[
0
]
.
type
TEST_PING_TYPE
"
We
should
have
received
the
pending
ping
.
"
)
;
yield
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
)
;
ping
=
yield
PingServer
.
promiseNextPings
(
1
)
;
Assert
.
equal
(
ping
.
length
1
"
We
should
have
received
one
ping
.
"
)
;
Assert
.
equal
(
ping
[
0
]
.
type
TEST_PING_TYPE
"
We
should
have
received
the
new
ping
.
"
)
;
yield
PingServer
.
stop
(
)
;
}
)
;
