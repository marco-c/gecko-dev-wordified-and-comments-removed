const
{
TelemetryController
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
)
;
const
{
ContentTaskUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
ContentTaskUtils
.
jsm
"
)
;
const
MESSAGE_CHILD_TEST_DONE
=
"
ChildTest
:
Done
"
;
const
RECORDED_CONTENT_EVENTS
=
[
[
"
telemetry
.
test
"
"
content_only
"
"
object1
"
]
[
"
telemetry
.
test
"
"
main_and_content
"
"
object1
"
]
[
"
telemetry
.
test
"
"
content_only
"
"
object1
"
"
some
value
"
]
[
"
telemetry
.
test
"
"
content_only
"
"
object1
"
null
{
foo
:
"
x
"
bar
:
"
y
"
}
]
[
"
telemetry
.
test
"
"
content_only
"
"
object1
"
"
some
value
"
{
foo
:
"
x
"
bar
:
"
y
"
}
]
]
;
const
UNRECORDED_CONTENT_EVENTS
=
[
[
"
telemetry
.
test
"
"
main_only
"
"
object1
"
]
]
;
const
RECORDED_PARENT_EVENTS
=
[
[
"
telemetry
.
test
"
"
main_and_content
"
"
object1
"
]
[
"
telemetry
.
test
"
"
main_only
"
"
object1
"
]
]
;
const
UNRECORDED_PARENT_EVENTS
=
[
[
"
telemetry
.
test
"
"
content_only
"
"
object1
"
]
]
;
const
RECORDED_DYNAMIC_EVENTS
=
[
[
"
telemetry
.
test
.
dynamic
"
"
test1
"
"
object1
"
]
[
"
telemetry
.
test
.
dynamic
"
"
test2
"
"
object1
"
]
]
;
function
run_child_test
(
)
{
RECORDED_CONTENT_EVENTS
.
forEach
(
e
=
>
Telemetry
.
recordEvent
(
.
.
.
e
)
)
;
UNRECORDED_CONTENT_EVENTS
.
forEach
(
e
=
>
Telemetry
.
recordEvent
(
.
.
.
e
)
)
;
RECORDED_DYNAMIC_EVENTS
.
forEach
(
e
=
>
Telemetry
.
recordEvent
(
.
.
.
e
)
)
;
}
async
function
waitForContentEvents
(
)
{
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
const
snapshot
=
Telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
false
)
;
return
(
Object
.
keys
(
snapshot
)
.
includes
(
"
content
"
)
&
&
Object
.
keys
(
snapshot
)
.
includes
(
"
dynamic
"
)
)
;
}
)
;
}
add_task
(
async
function
(
)
{
if
(
!
runningInParent
)
{
TelemetryController
.
testSetupContent
(
)
;
run_child_test
(
)
;
do_send_remote_message
(
MESSAGE_CHILD_TEST_DONE
)
;
return
;
}
do_get_profile
(
true
)
;
await
loadAddonManager
(
APP_ID
APP_NAME
APP_VERSION
PLATFORM_VERSION
)
;
finishAddonManagerStartup
(
)
;
fakeIntlReady
(
)
;
await
TelemetryController
.
testSetup
(
)
;
await
setEmptyPrefWatchlist
(
)
;
Telemetry
.
setEventRecordingEnabled
(
"
telemetry
.
test
"
true
)
;
Telemetry
.
registerEvents
(
"
telemetry
.
test
.
dynamic
"
{
test1
:
{
methods
:
[
"
test1
"
]
objects
:
[
"
object1
"
]
}
test2
:
{
methods
:
[
"
test2
"
"
test2b
"
]
objects
:
[
"
object1
"
]
extra_keys
:
[
"
key1
"
"
key2
"
]
}
}
)
;
const
timestampBeforeChildEvents
=
Telemetry
.
msSinceProcessStart
(
)
;
run_test_in_child
(
"
test_ChildEvents
.
js
"
)
;
await
do_await_remote_message
(
MESSAGE_CHILD_TEST_DONE
)
;
await
waitForContentEvents
(
)
;
const
timestampAfterChildEvents
=
Telemetry
.
msSinceProcessStart
(
)
;
RECORDED_PARENT_EVENTS
.
forEach
(
e
=
>
Telemetry
.
recordEvent
(
.
.
.
e
)
)
;
UNRECORDED_PARENT_EVENTS
.
forEach
(
e
=
>
Telemetry
.
recordEvent
(
.
.
.
e
)
)
;
let
snapshot
=
Telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
false
)
;
Assert
.
ok
(
"
parent
"
in
snapshot
"
Should
have
main
process
section
"
)
;
Assert
.
ok
(
!
!
snapshot
.
parent
.
length
"
Main
process
section
should
have
events
.
"
)
;
Assert
.
ok
(
"
content
"
in
snapshot
"
Should
have
child
process
section
"
)
;
Assert
.
ok
(
!
!
snapshot
.
content
.
length
"
Child
process
section
should
have
events
.
"
)
;
Assert
.
ok
(
"
dynamic
"
in
snapshot
"
Should
have
dynamic
process
section
"
)
;
Assert
.
ok
(
!
!
snapshot
.
dynamic
.
length
"
Dynamic
process
section
should
have
events
.
"
)
;
let
contentEvents
=
snapshot
.
content
.
map
(
e
=
>
e
.
slice
(
1
)
)
;
Assert
.
equal
(
contentEvents
.
length
RECORDED_CONTENT_EVENTS
.
length
"
Should
match
expected
event
count
.
"
)
;
for
(
let
i
=
0
;
i
<
RECORDED_CONTENT_EVENTS
.
length
;
+
+
i
)
{
Assert
.
deepEqual
(
contentEvents
[
i
]
RECORDED_CONTENT_EVENTS
[
i
]
"
Should
have
recorded
expected
event
.
"
)
;
}
let
parentEvents
=
snapshot
.
parent
.
map
(
e
=
>
e
.
slice
(
1
)
)
;
Assert
.
equal
(
parentEvents
.
length
RECORDED_PARENT_EVENTS
.
length
"
Should
match
expected
event
count
.
"
)
;
for
(
let
i
=
0
;
i
<
RECORDED_PARENT_EVENTS
.
length
;
+
+
i
)
{
Assert
.
deepEqual
(
parentEvents
[
i
]
RECORDED_PARENT_EVENTS
[
i
]
"
Should
have
recorded
expected
event
.
"
)
;
}
let
dynamicEvents
=
snapshot
.
dynamic
.
map
(
e
=
>
e
.
slice
(
1
)
)
;
Assert
.
equal
(
dynamicEvents
.
length
RECORDED_DYNAMIC_EVENTS
.
length
"
Should
match
expected
event
count
.
"
)
;
for
(
let
i
=
0
;
i
<
RECORDED_DYNAMIC_EVENTS
.
length
;
+
+
i
)
{
Assert
.
deepEqual
(
dynamicEvents
[
i
]
RECORDED_DYNAMIC_EVENTS
[
i
]
"
Should
have
recorded
expected
event
.
"
)
;
}
let
contentTimestamps
=
snapshot
.
content
.
map
(
e
=
>
e
[
0
]
)
;
let
parentTimestamps
=
snapshot
.
parent
.
map
(
e
=
>
e
[
0
]
)
;
Assert
.
ok
(
contentTimestamps
.
every
(
ts
=
>
ts
>
Math
.
floor
(
timestampBeforeChildEvents
)
&
&
ts
<
timestampAfterChildEvents
)
"
All
content
event
timestamps
should
be
in
the
expected
time
range
.
"
)
;
Assert
.
ok
(
parentTimestamps
.
every
(
ts
=
>
ts
>
=
Math
.
floor
(
timestampAfterChildEvents
)
)
"
All
parent
event
timestamps
should
be
in
the
expected
time
range
.
"
)
;
snapshot
=
Telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
true
)
;
Assert
.
greaterOrEqual
(
Object
.
keys
(
snapshot
)
.
length
2
"
Should
have
events
from
at
least
two
processes
.
"
)
;
snapshot
=
Telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
true
)
;
Assert
.
equal
(
Object
.
keys
(
snapshot
)
.
length
0
"
Should
have
cleared
all
events
from
storage
.
"
)
;
}
)
;
