"
use
strict
"
;
const
{
PromiseUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
sys
.
mjs
"
)
;
const
{
TelemetrySend
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
jsm
"
)
;
const
{
TelemetryStorage
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
)
;
const
{
TelemetryUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
)
;
const
{
setTimeout
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
)
;
function
generateTestPingData
(
)
{
return
{
type
:
"
test
-
pingsender
-
type
"
id
:
TelemetryUtils
.
generateUUID
(
)
creationDate
:
new
Date
(
)
.
toISOString
(
)
version
:
4
payload
:
{
dummy
:
"
stuff
"
}
}
;
}
function
testSendingPings
(
pingPaths
)
{
const
url
=
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
+
"
/
submit
/
telemetry
/
"
;
const
pings
=
pingPaths
.
map
(
path
=
>
{
return
{
url
path
}
;
}
)
;
TelemetrySend
.
testRunPingSender
(
pings
(
_
topic
__
)
=
>
{
switch
(
topic
)
{
case
"
process
-
finished
"
:
Assert
.
ok
(
true
"
Pingsender
should
be
able
to
post
to
localhost
"
)
;
break
;
case
"
process
-
failed
"
:
Assert
.
ok
(
false
"
Pingsender
should
be
able
to
post
to
localhost
"
)
;
break
;
}
}
)
;
}
function
waitForPingDeletion
(
pingId
)
{
const
path
=
OS
.
Path
.
join
(
TelemetryStorage
.
pingDirectoryPath
pingId
)
;
let
checkFn
=
(
resolve
reject
)
=
>
setTimeout
(
(
)
=
>
{
OS
.
File
.
exists
(
path
)
.
then
(
exists
=
>
{
if
(
!
exists
)
{
Assert
.
ok
(
true
pingId
+
"
was
deleted
"
)
;
resolve
(
)
;
}
else
{
checkFn
(
resolve
reject
)
;
}
}
reject
)
;
}
250
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
checkFn
(
resolve
reject
)
)
;
}
add_task
(
async
function
setup
(
)
{
do_get_profile
(
true
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
PingServer
.
start
(
)
;
}
)
;
async
function
test_pingSender
(
version
=
"
1
.
0
"
)
{
const
data
=
generateTestPingData
(
)
;
await
TelemetryStorage
.
savePing
(
data
true
)
;
const
pingPath
=
OS
.
Path
.
join
(
TelemetryStorage
.
pingDirectoryPath
data
.
id
)
;
let
failingServer
=
new
HttpServer
(
)
;
let
deferred404Hit
=
PromiseUtils
.
defer
(
)
;
let
hitCount
=
0
;
failingServer
.
registerPathHandler
(
"
/
lookup_fail
"
(
metadata
response
)
=
>
{
response
.
setStatusLine
(
"
1
.
1
"
404
"
Not
Found
"
)
;
hitCount
+
+
;
if
(
hitCount
>
=
2
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
deferred404Hit
.
resolve
(
)
)
;
}
}
)
;
failingServer
.
start
(
-
1
)
;
const
errorUrl
=
"
http
:
/
/
localhost
:
"
+
failingServer
.
identity
.
primaryPort
+
"
/
lookup_fail
"
;
TelemetrySend
.
testRunPingSender
(
[
{
url
:
errorUrl
path
:
pingPath
}
]
)
;
TelemetrySend
.
testRunPingSender
(
[
{
url
:
errorUrl
path
:
pingPath
}
]
)
;
await
deferred404Hit
.
promise
;
Assert
.
ok
(
await
OS
.
File
.
exists
(
pingPath
)
"
The
pending
ping
must
not
be
deleted
if
we
fail
to
send
using
the
PingSender
"
)
;
testSendingPings
(
[
pingPath
]
)
;
let
req
=
await
PingServer
.
promiseNextRequest
(
)
;
let
ping
=
decodeRequestPayload
(
req
)
;
Assert
.
equal
(
req
.
getHeader
(
"
User
-
Agent
"
)
pingsender
/
{
version
}
"
Should
have
received
the
correct
user
agent
string
.
"
)
;
Assert
.
equal
(
req
.
getHeader
(
"
X
-
PingSender
-
Version
"
)
version
"
Should
have
received
the
correct
PingSender
version
string
.
"
)
;
Assert
.
equal
(
req
.
getHeader
(
"
Content
-
Encoding
"
)
"
gzip
"
"
Should
have
a
gzip
encoded
ping
.
"
)
;
Assert
.
ok
(
req
.
getHeader
(
"
Date
"
)
"
Should
have
received
a
Date
header
.
"
)
;
Assert
.
equal
(
ping
.
id
data
.
id
"
Should
have
received
the
correct
ping
id
.
"
)
;
Assert
.
equal
(
ping
.
type
data
.
type
"
Should
have
received
the
correct
ping
type
.
"
)
;
Assert
.
deepEqual
(
ping
.
payload
data
.
payload
"
Should
have
received
the
correct
payload
.
"
)
;
await
waitForPingDeletion
(
data
.
id
)
;
await
new
Promise
(
r
=
>
failingServer
.
stop
(
r
)
)
;
}
add_task
(
async
function
test_pingsender1
(
)
{
let
orig
=
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
telemetry
.
shutdownPingSender
.
backgroundtask
.
enabled
"
false
)
;
try
{
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
telemetry
.
shutdownPingSender
.
backgroundtask
.
enabled
"
false
)
;
await
test_pingSender
(
"
1
.
0
"
)
;
}
finally
{
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
telemetry
.
shutdownPingSender
.
backgroundtask
.
enabled
"
orig
)
;
}
}
)
;
add_task
(
async
function
test_pingsender2
(
)
{
let
orig
=
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
telemetry
.
shutdownPingSender
.
backgroundtask
.
enabled
"
false
)
;
try
{
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
telemetry
.
shutdownPingSender
.
backgroundtask
.
enabled
"
true
)
;
await
test_pingSender
(
"
2
.
0
"
)
;
}
finally
{
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
telemetry
.
shutdownPingSender
.
backgroundtask
.
enabled
"
orig
)
;
}
}
)
;
add_task
(
async
function
test_bannedDomains
(
)
{
const
data
=
generateTestPingData
(
)
;
await
TelemetryStorage
.
savePing
(
data
true
)
;
const
pingPath
=
OS
.
Path
.
join
(
TelemetryStorage
.
pingDirectoryPath
data
.
id
)
;
let
bannedUris
=
[
"
https
:
/
/
example
.
com
"
"
http
:
/
/
localhost
.
com
"
"
http
:
/
/
localHOST
.
com
"
"
http
:
/
/
localhost
example
.
com
"
"
http
:
/
/
localhost
:
bob
example
.
com
"
"
http
:
/
/
localhost
:
localhost
localhost
.
example
.
com
"
]
;
for
(
let
url
of
bannedUris
)
{
let
result
=
await
new
Promise
(
resolve
=
>
TelemetrySend
.
testRunPingSender
(
[
{
url
path
:
pingPath
}
]
(
_
topic
__
)
=
>
{
switch
(
topic
)
{
case
"
process
-
finished
"
:
case
"
process
-
failed
"
:
resolve
(
topic
)
;
}
}
)
)
;
Assert
.
equal
(
result
"
process
-
failed
"
Pingsender
should
not
be
able
to
post
to
{
url
}
)
;
}
}
)
;
add_task
(
async
function
test_pingSender_multiple_pings
(
)
{
const
data
=
[
generateTestPingData
(
)
generateTestPingData
(
)
]
;
for
(
const
d
of
data
)
{
await
TelemetryStorage
.
savePing
(
d
true
)
;
}
const
pingPaths
=
data
.
map
(
d
=
>
OS
.
Path
.
join
(
TelemetryStorage
.
pingDirectoryPath
d
.
id
)
)
;
testSendingPings
(
pingPaths
)
;
let
data2
=
[
]
;
while
(
data
.
length
)
{
let
req
=
await
PingServer
.
promiseNextRequest
(
)
;
let
ping
=
decodeRequestPayload
(
req
)
;
let
idx
=
data
.
findIndex
(
d
=
>
d
.
id
=
=
ping
.
id
)
;
Assert
.
ok
(
idx
>
=
0
Should
have
received
the
correct
ping
id
:
{
data
[
idx
]
.
id
}
)
;
data2
.
push
(
data
[
idx
]
)
;
data
.
splice
(
idx
1
)
;
}
for
(
const
d
of
data2
)
{
await
waitForPingDeletion
(
d
.
id
)
;
}
}
)
;
add_task
(
async
function
cleanup
(
)
{
await
PingServer
.
stop
(
)
;
}
)
;
