const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
function
getDefinitionsPath
(
)
{
let
definitionFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
definitionFile
=
Services
.
dirsvc
.
get
(
"
GreD
"
Ci
.
nsIFile
)
;
definitionFile
.
append
(
"
EventArtifactDefinitions
.
json
"
)
;
return
definitionFile
.
path
;
}
add_task
(
async
function
test_setup
(
)
{
do_get_profile
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
AppConstants
.
platform
=
=
"
android
"
}
async
function
test_invalidJSON
(
)
{
const
INVALID_JSON
=
"
{
invalid
JSON
{
{
1
}
"
;
const
FILE_PATH
=
getDefinitionsPath
(
)
;
await
OS
.
File
.
writeAtomic
(
FILE_PATH
INVALID_JSON
{
encoding
:
"
utf
-
8
"
noOverwrite
:
false
}
)
;
await
TelemetryController
.
testSetup
(
)
;
await
TelemetryController
.
testPromiseJsProbeRegistration
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
OS
.
File
.
remove
(
FILE_PATH
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
AppConstants
.
platform
=
=
"
android
"
}
async
function
test_dynamicBuiltin
(
)
{
const
DYNAMIC_EVENT_SPEC
=
{
"
telemetry
.
test
.
builtin
"
:
{
"
test
"
:
{
"
objects
"
:
[
"
object1
"
"
object2
"
]
"
expired
"
:
false
"
methods
"
:
[
"
test1
"
"
test2
"
]
"
extra_keys
"
:
[
"
key2
"
"
key1
"
]
"
record_on_release
"
:
false
}
}
}
;
Telemetry
.
clearEvents
(
)
;
const
FILE_PATH
=
getDefinitionsPath
(
)
;
await
CommonUtils
.
writeJSON
(
DYNAMIC_EVENT_SPEC
FILE_PATH
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testPromiseJsProbeRegistration
(
)
;
const
TEST_EVENT_NAME
=
"
telemetry
.
test
.
builtin
"
;
Telemetry
.
setEventRecordingEnabled
(
TEST_EVENT_NAME
true
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test1
"
"
object1
"
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test2
"
"
object1
"
null
{
"
key1
"
:
"
foo
"
"
key2
"
:
"
bar
"
}
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test2
"
"
object2
"
null
{
"
key2
"
:
"
bar
"
}
)
;
const
snapshot
=
Telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
false
)
;
Assert
.
ok
(
(
"
parent
"
in
snapshot
)
"
Should
have
parent
events
in
the
snapshot
.
"
)
;
let
expected
=
[
[
TEST_EVENT_NAME
"
test1
"
"
object1
"
]
[
TEST_EVENT_NAME
"
test2
"
"
object1
"
null
{
key1
:
"
foo
"
key2
:
"
bar
"
}
]
[
TEST_EVENT_NAME
"
test2
"
"
object2
"
null
{
key2
:
"
bar
"
}
]
]
;
let
events
=
snapshot
.
parent
;
Assert
.
equal
(
events
.
length
expected
.
length
"
Should
have
recorded
the
right
amount
of
events
.
"
)
;
for
(
let
i
=
0
;
i
<
expected
.
length
;
+
+
i
)
{
Assert
.
deepEqual
(
events
[
i
]
.
slice
(
1
)
expected
[
i
]
"
Should
have
recorded
the
expected
event
data
.
"
)
;
}
await
TelemetryController
.
testShutdown
(
)
;
await
OS
.
File
.
remove
(
FILE_PATH
)
;
}
)
;
add_task
(
async
function
test_dynamicBuiltinEvents
(
)
{
Telemetry
.
clearEvents
(
)
;
Telemetry
.
canRecordExtended
=
true
;
const
TEST_EVENT_NAME
=
"
telemetry
.
test
.
dynamicbuiltin
"
;
Telemetry
.
registerBuiltinEvents
(
TEST_EVENT_NAME
{
"
test1
"
:
{
methods
:
[
"
test1
"
]
objects
:
[
"
object1
"
]
}
"
test2
"
:
{
methods
:
[
"
test2
"
"
test2b
"
]
objects
:
[
"
object1
"
"
object2
"
]
extra_keys
:
[
"
key1
"
"
key2
"
]
}
}
)
;
Telemetry
.
setEventRecordingEnabled
(
TEST_EVENT_NAME
true
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test1
"
"
object1
"
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test2
"
"
object1
"
null
{
"
key1
"
:
"
foo
"
"
key2
"
:
"
bar
"
}
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test2b
"
"
object2
"
null
{
"
key2
"
:
"
bar
"
}
)
;
let
snapshot
=
Telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
false
)
;
Assert
.
ok
(
(
"
parent
"
in
snapshot
)
"
Should
have
parent
events
in
the
snapshot
.
"
)
;
let
expected
=
[
[
TEST_EVENT_NAME
"
test1
"
"
object1
"
]
[
TEST_EVENT_NAME
"
test2
"
"
object1
"
null
{
key1
:
"
foo
"
key2
:
"
bar
"
}
]
[
TEST_EVENT_NAME
"
test2b
"
"
object2
"
null
{
key2
:
"
bar
"
}
]
]
;
let
events
=
snapshot
.
parent
;
Assert
.
equal
(
events
.
length
expected
.
length
"
Should
have
recorded
the
right
amount
of
events
.
"
)
;
for
(
let
i
=
0
;
i
<
expected
.
length
;
+
+
i
)
{
Assert
.
deepEqual
(
events
[
i
]
.
slice
(
1
)
expected
[
i
]
"
Should
have
recorded
the
expected
event
data
.
"
)
;
}
}
)
;
add_task
(
async
function
test_dynamicBuiltinEventsDisabledByDefault
(
)
{
Telemetry
.
clearEvents
(
)
;
Telemetry
.
canRecordExtended
=
true
;
const
TEST_EVENT_NAME
=
"
telemetry
.
test
.
offbydefault
"
;
Telemetry
.
registerBuiltinEvents
(
TEST_EVENT_NAME
{
"
test1
"
:
{
methods
:
[
"
test1
"
]
objects
:
[
"
object1
"
]
}
}
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test1
"
"
object1
"
)
;
let
snapshot
=
Telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
false
)
;
Assert
.
ok
(
!
(
"
parent
"
in
snapshot
)
"
Should
not
have
parent
events
in
the
snapshot
.
"
)
;
Telemetry
.
setEventRecordingEnabled
(
TEST_EVENT_NAME
true
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test1
"
"
object1
"
)
;
snapshot
=
Telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
false
)
;
Assert
.
ok
(
(
"
parent
"
in
snapshot
)
"
Should
have
parent
events
in
the
snapshot
.
"
)
;
let
expected
=
[
[
TEST_EVENT_NAME
"
test1
"
"
object1
"
]
]
;
let
events
=
snapshot
.
parent
;
Assert
.
equal
(
events
.
length
expected
.
length
"
Should
have
recorded
the
right
amount
of
events
.
"
)
;
for
(
let
i
=
0
;
i
<
expected
.
length
;
+
+
i
)
{
Assert
.
deepEqual
(
events
[
i
]
.
slice
(
1
)
expected
[
i
]
"
Should
have
recorded
the
expected
event
data
.
"
)
;
}
}
)
;
add_task
(
async
function
test_dynamicBuiltinDontOverwriteStaticData
(
)
{
Telemetry
.
clearEvents
(
)
;
Telemetry
.
canRecordExtended
=
true
;
const
TEST_STATIC_EVENT_NAME
=
"
telemetry
.
test
"
;
const
TEST_EVENT_NAME
=
"
telemetry
.
test
.
nooverwrite
"
;
Telemetry
.
registerBuiltinEvents
(
TEST_EVENT_NAME
{
"
dynamic
"
:
{
methods
:
[
"
dynamic
"
]
objects
:
[
"
builtin
"
"
anotherone
"
]
}
}
)
;
Telemetry
.
setEventRecordingEnabled
(
TEST_STATIC_EVENT_NAME
true
)
;
Telemetry
.
setEventRecordingEnabled
(
TEST_EVENT_NAME
true
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
dynamic
"
"
builtin
"
)
;
Telemetry
.
recordEvent
(
TEST_STATIC_EVENT_NAME
"
test1
"
"
object1
"
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
dynamic
"
"
anotherone
"
)
;
let
snapshot
=
Telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
false
)
;
Assert
.
ok
(
(
"
parent
"
in
snapshot
)
"
Should
have
parent
events
in
the
snapshot
.
"
)
;
let
expected
=
[
[
TEST_EVENT_NAME
"
dynamic
"
"
builtin
"
]
[
TEST_STATIC_EVENT_NAME
"
test1
"
"
object1
"
]
[
TEST_EVENT_NAME
"
dynamic
"
"
anotherone
"
]
]
;
let
events
=
snapshot
.
parent
;
Assert
.
equal
(
events
.
length
expected
.
length
"
Should
have
recorded
the
right
amount
of
events
.
"
)
;
for
(
let
i
=
0
;
i
<
expected
.
length
;
+
+
i
)
{
Assert
.
deepEqual
(
events
[
i
]
.
slice
(
1
)
expected
[
i
]
"
Should
have
recorded
the
expected
event
data
.
"
)
;
}
}
)
;
add_task
(
async
function
test_dynamicBuiltinEventsOverridingStatic
(
)
{
Telemetry
.
clearEvents
(
)
;
Telemetry
.
canRecordExtended
=
true
;
const
TEST_EVENT_NAME
=
"
telemetry
.
test
"
;
Telemetry
.
registerBuiltinEvents
(
TEST_EVENT_NAME
{
"
test1
"
:
{
methods
:
[
"
test1
"
]
objects
:
[
"
object1
"
"
object2
"
]
}
"
test2
"
:
{
methods
:
[
"
test2
"
]
objects
:
[
"
object1
"
"
object2
"
"
object3
"
]
extra_keys
:
[
"
key1
"
"
key2
"
"
newdynamickey
"
]
}
}
)
;
Telemetry
.
setEventRecordingEnabled
(
TEST_EVENT_NAME
true
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test1
"
"
object1
"
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test2
"
"
object1
"
null
{
"
key1
"
:
"
foo
"
"
key2
"
:
"
bar
"
}
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test2
"
"
object2
"
null
{
"
newdynamickey
"
:
"
foo
"
}
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test2
"
"
object3
"
null
{
"
key1
"
:
"
foo
"
}
)
;
let
snapshot
=
Telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
false
)
;
Assert
.
ok
(
(
"
parent
"
in
snapshot
)
"
Should
have
parent
events
in
the
snapshot
.
"
)
;
let
expected
=
[
[
TEST_EVENT_NAME
"
test1
"
"
object1
"
]
[
TEST_EVENT_NAME
"
test2
"
"
object1
"
null
{
key1
:
"
foo
"
key2
:
"
bar
"
}
]
[
TEST_EVENT_NAME
"
test2
"
"
object2
"
null
{
newdynamickey
:
"
foo
"
}
]
[
TEST_EVENT_NAME
"
test2
"
"
object3
"
null
{
key1
:
"
foo
"
}
]
]
;
let
events
=
snapshot
.
parent
;
Assert
.
equal
(
events
.
length
expected
.
length
"
Should
have
recorded
the
right
amount
of
events
.
"
)
;
for
(
let
i
=
0
;
i
<
expected
.
length
;
+
+
i
)
{
Assert
.
deepEqual
(
events
[
i
]
.
slice
(
1
)
expected
[
i
]
"
Should
have
recorded
the
expected
event
data
.
"
)
;
}
}
)
;
add_task
(
async
function
test_realDynamicDontOverwrite
(
)
{
Telemetry
.
clearEvents
(
)
;
Telemetry
.
canRecordExtended
=
true
;
const
TEST_EVENT_NAME
=
"
telemetry
.
test
"
;
Telemetry
.
registerEvents
(
TEST_EVENT_NAME
{
"
test1
"
:
{
methods
:
[
"
test1
"
]
objects
:
[
"
object1
"
"
object2
"
]
}
"
test2
"
:
{
methods
:
[
"
test2
"
]
objects
:
[
"
object1
"
"
object2
"
"
object3
"
]
extra_keys
:
[
"
key1
"
"
key2
"
"
realdynamic
"
]
}
}
)
;
Telemetry
.
setEventRecordingEnabled
(
TEST_EVENT_NAME
true
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test1
"
"
object1
"
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test2
"
"
object1
"
null
{
"
key1
"
:
"
foo
"
"
key2
"
:
"
bar
"
}
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test2
"
"
object2
"
null
{
"
realdynamic
"
:
"
foo
"
}
)
;
Telemetry
.
recordEvent
(
TEST_EVENT_NAME
"
test2
"
"
object3
"
null
{
"
key1
"
:
"
foo
"
}
)
;
let
snapshot
=
Telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
false
)
;
Assert
.
ok
(
(
"
parent
"
in
snapshot
)
"
Should
have
parent
events
in
the
snapshot
.
"
)
;
let
expected
=
[
[
TEST_EVENT_NAME
"
test1
"
"
object1
"
]
[
TEST_EVENT_NAME
"
test2
"
"
object1
"
null
{
key1
:
"
foo
"
key2
:
"
bar
"
}
]
[
TEST_EVENT_NAME
"
test2
"
"
object3
"
null
{
key1
:
"
foo
"
}
]
]
;
let
events
=
snapshot
.
parent
;
Assert
.
equal
(
events
.
length
expected
.
length
"
Should
have
recorded
the
right
amount
of
events
.
"
)
;
for
(
let
i
=
0
;
i
<
expected
.
length
;
+
+
i
)
{
Assert
.
deepEqual
(
events
[
i
]
.
slice
(
1
)
expected
[
i
]
"
Should
have
recorded
the
expected
event
data
.
"
)
;
}
}
)
;
