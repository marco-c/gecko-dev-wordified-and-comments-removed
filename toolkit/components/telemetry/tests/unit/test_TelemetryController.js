const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
const
{
ClientID
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ClientID
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
TelemetryController
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
)
;
const
{
TelemetryStorage
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
)
;
const
{
TelemetrySend
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
jsm
"
)
;
const
{
TelemetryArchive
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryArchive
.
jsm
"
)
;
const
{
TelemetryUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
)
;
const
{
Preferences
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
const
{
ContentTaskUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
ContentTaskUtils
.
jsm
"
)
;
const
{
TestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
;
const
{
TelemetryArchiveTesting
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TelemetryArchiveTesting
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
jwcrypto
"
"
resource
:
/
/
services
-
crypto
/
jwcrypto
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
JsonSchemaValidator
"
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
JsonSchemaValidator
.
jsm
"
)
;
const
PING_FORMAT_VERSION
=
4
;
const
DELETION_REQUEST_PING_TYPE
=
"
deletion
-
request
"
;
const
TEST_PING_TYPE
=
"
test
-
ping
-
type
"
;
var
gClientID
=
null
;
XPCOMUtils
.
defineLazyGetter
(
this
"
DATAREPORTING_PATH
"
async
function
(
)
{
return
PathUtils
.
join
(
PathUtils
.
profileDir
"
datareporting
"
)
;
}
)
;
function
sendPing
(
aSendClientId
aSendEnvironment
)
{
if
(
PingServer
.
started
)
{
TelemetrySend
.
setServer
(
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
}
else
{
TelemetrySend
.
setServer
(
"
http
:
/
/
doesnotexist
"
)
;
}
let
options
=
{
addClientId
:
aSendClientId
addEnvironment
:
aSendEnvironment
}
;
return
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
options
)
;
}
function
checkPingFormat
(
aPing
aType
aHasClientId
aHasEnvironment
)
{
const
MANDATORY_PING_FIELDS
=
[
"
type
"
"
id
"
"
creationDate
"
"
version
"
"
application
"
"
payload
"
]
;
const
APPLICATION_TEST_DATA
=
{
buildId
:
gAppInfo
.
appBuildID
name
:
APP_NAME
version
:
APP_VERSION
displayVersion
:
AppConstants
.
MOZ_APP_VERSION_DISPLAY
vendor
:
"
Mozilla
"
platformVersion
:
PLATFORM_VERSION
xpcomAbi
:
"
noarch
-
spidermonkey
"
}
;
for
(
let
f
of
MANDATORY_PING_FIELDS
)
{
Assert
.
ok
(
f
in
aPing
f
+
"
must
be
available
.
"
)
;
}
Assert
.
equal
(
aPing
.
type
aType
"
The
ping
must
have
the
correct
type
.
"
)
;
Assert
.
equal
(
aPing
.
version
PING_FORMAT_VERSION
"
The
ping
must
have
the
correct
version
.
"
)
;
for
(
let
f
in
APPLICATION_TEST_DATA
)
{
Assert
.
equal
(
aPing
.
application
[
f
]
APPLICATION_TEST_DATA
[
f
]
f
+
"
must
have
the
correct
value
.
"
)
;
}
Assert
.
ok
(
"
architecture
"
in
aPing
.
application
"
The
application
section
must
have
an
architecture
field
.
"
)
;
Assert
.
ok
(
"
channel
"
in
aPing
.
application
"
The
application
section
must
have
a
channel
field
.
"
)
;
Assert
.
equal
(
"
clientId
"
in
aPing
aHasClientId
)
;
Assert
.
equal
(
"
environment
"
in
aPing
aHasEnvironment
)
;
}
add_task
(
async
function
test_setup
(
)
{
do_get_profile
(
)
;
await
loadAddonManager
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
.
9
.
2
"
)
;
finishAddonManagerStartup
(
)
;
fakeIntlReady
(
)
;
await
setEmptyPrefWatchlist
(
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
new
Promise
(
resolve
=
>
Telemetry
.
asyncFetchTelemetryData
(
wrapWithExceptionHandler
(
resolve
)
)
)
;
}
)
;
add_task
(
async
function
asyncSetup
(
)
{
await
TelemetryController
.
testSetup
(
)
;
}
)
;
add_task
(
async
function
test_overwritePing
(
)
{
let
ping
=
{
id
:
"
foo
"
}
;
await
TelemetryStorage
.
savePing
(
ping
true
)
;
await
TelemetryStorage
.
savePing
(
ping
false
)
;
await
TelemetryStorage
.
cleanupPingFile
(
ping
)
;
}
)
;
add_task
(
async
function
test_simplePing
(
)
{
PingServer
.
start
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
Server
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
await
sendPing
(
false
false
)
;
let
request
=
await
PingServer
.
promiseNextRequest
(
)
;
let
ping
=
decodeRequestPayload
(
request
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
false
false
)
;
}
)
;
add_task
(
async
function
test_disableDataUpload
(
)
{
const
OPTIN_PROBE
=
"
telemetry
.
data_upload_optin
"
;
const
isUnified
=
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
if
(
!
isUnified
)
{
return
;
}
let
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
)
.
parent
|
|
{
}
;
Assert
.
ok
(
!
(
OPTIN_PROBE
in
snapshot
)
"
Data
optin
scalar
should
not
be
set
at
start
"
)
;
await
sendPing
(
true
false
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
let
firstClientId
=
ping
.
clientId
;
Assert
.
ok
(
firstClientId
"
Test
ping
needs
a
client
ID
"
)
;
Assert
.
notEqual
(
TelemetryUtils
.
knownClientID
firstClientId
"
Client
ID
should
be
valid
and
random
"
)
;
let
disableObserved
=
TestUtils
.
topicObserved
(
TelemetryUtils
.
TELEMETRY_UPLOAD_DISABLED_TOPIC
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
await
disableObserved
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
DELETION_REQUEST_PING_TYPE
true
false
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
)
.
parent
|
|
{
}
;
Assert
.
ok
(
!
(
OPTIN_PROBE
in
snapshot
)
"
Data
optin
scalar
should
not
be
set
after
opt
out
"
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
const
scalarSnapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
)
;
return
(
Object
.
keys
(
scalarSnapshot
)
.
includes
(
"
parent
"
)
&
&
OPTIN_PROBE
in
scalarSnapshot
.
parent
)
;
}
)
;
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
)
.
parent
|
|
{
}
;
Assert
.
ok
(
snapshot
[
OPTIN_PROBE
]
"
Enabling
data
upload
should
set
optin
probe
"
)
;
let
secondClientId
=
TelemetryController
.
getCurrentPingData
(
)
.
clientId
;
Assert
.
notEqual
(
firstClientId
secondClientId
"
The
client
id
must
have
changed
"
)
;
await
PingServer
.
stop
(
)
;
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
await
TelemetryController
.
testPromiseDeletionRequestPingSubmitted
(
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
await
TelemetryStorage
.
shutdown
(
)
;
await
TelemetryController
.
testReset
(
)
;
let
pendingPings
=
await
TelemetryStorage
.
loadPendingPingList
(
)
;
Assert
.
equal
(
pendingPings
.
length
1
"
All
the
pending
pings
should
have
been
deleted
except
the
deletion
-
request
ping
"
)
;
PingServer
.
start
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
Server
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
await
TelemetrySend
.
shutdown
(
)
;
await
TelemetryController
.
testReset
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
sendPing
(
true
false
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
notEqual
(
TelemetryUtils
.
knownClientID
ping
.
clientId
"
Client
ID
should
be
reset
to
a
random
value
"
)
;
Assert
.
notEqual
(
firstClientId
ping
.
clientId
"
Client
ID
should
be
different
from
the
previous
value
"
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
DELETION_REQUEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
secondClientId
ping
.
clientId
"
Deletion
must
be
requested
for
correct
client
id
"
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
}
)
;
add_task
(
async
function
test_pingHasClientId
(
)
{
Preferences
.
reset
(
TelemetryUtils
.
Preferences
.
CachedClientId
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
ClientID
.
_reset
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
let
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_PING_SUBMISSION_WAITING_CLIENTID
"
)
;
h
.
clear
(
)
;
let
promisePingSetup
=
TelemetryController
.
testReset
(
)
;
await
sendPing
(
true
false
)
;
Assert
.
equal
(
h
.
snapshot
(
)
.
sum
1
"
We
must
have
a
ping
waiting
for
the
clientId
early
during
startup
.
"
)
;
await
promisePingSetup
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
gClientID
=
await
ClientID
.
getClientID
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
The
correct
clientId
must
be
reported
.
"
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
h
.
clear
(
)
;
promisePingSetup
=
TelemetryController
.
testReset
(
)
;
await
sendPing
(
true
false
)
;
await
promisePingSetup
;
Assert
.
equal
(
h
.
snapshot
(
)
.
sum
0
"
We
must
have
used
the
cached
clientId
.
"
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
Telemetry
should
report
the
correct
cached
clientId
.
"
)
;
Preferences
.
reset
(
TelemetryUtils
.
Preferences
.
CachedClientId
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
await
TelemetryController
.
testReset
(
)
;
await
sendPing
(
true
false
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
The
correct
clientId
must
be
reported
.
"
)
;
Assert
.
equal
(
h
.
snapshot
(
)
.
sum
0
"
No
ping
should
have
been
waiting
for
a
clientId
.
"
)
;
}
)
;
add_task
(
async
function
test_pingHasEnvironment
(
)
{
await
sendPing
(
false
true
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
false
true
)
;
Assert
.
equal
(
ping
.
application
.
buildId
ping
.
environment
.
build
.
buildId
)
;
}
)
;
add_task
(
async
function
test_pingHasEnvironmentAndClientId
(
)
{
await
sendPing
(
true
true
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
Assert
.
equal
(
ping
.
application
.
buildId
ping
.
environment
.
build
.
buildId
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
The
correct
clientId
must
be
reported
.
"
)
;
}
)
;
add_task
(
async
function
test_archivePings
(
)
{
let
now
=
new
Date
(
2009
10
18
12
0
0
)
;
fakeNow
(
now
)
;
const
isUnified
=
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
const
uploadPref
=
isUnified
?
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
:
TelemetryUtils
.
Preferences
.
TelemetryEnabled
;
Preferences
.
set
(
uploadPref
false
)
;
if
(
isUnified
)
{
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
DELETION_REQUEST_PING_TYPE
true
false
)
;
}
PingServer
.
registerPingHandler
(
(
)
=
>
Assert
.
ok
(
false
"
Telemetry
must
not
send
pings
if
not
allowed
to
.
"
)
)
;
let
pingId
=
await
sendPing
(
true
true
)
;
let
ping
=
await
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
equal
(
ping
.
id
pingId
"
TelemetryController
should
still
archive
pings
.
"
)
;
now
=
new
Date
(
2010
10
18
12
0
0
)
;
fakeNow
(
now
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
ArchiveEnabled
false
)
;
pingId
=
await
sendPing
(
true
true
)
;
let
promise
=
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
ok
(
await
promiseRejects
(
promise
)
"
TelemetryController
should
not
archive
pings
if
the
archive
pref
is
disabled
.
"
)
;
Preferences
.
set
(
uploadPref
true
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
ArchiveEnabled
true
)
;
now
=
new
Date
(
2014
6
18
22
0
0
)
;
fakeNow
(
now
)
;
PingServer
.
resetPingHandler
(
)
;
pingId
=
await
sendPing
(
true
true
)
;
await
PingServer
.
promiseNextPing
(
)
;
ping
=
await
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
equal
(
ping
.
id
pingId
"
TelemetryController
should
still
archive
pings
if
ping
upload
is
enabled
.
"
)
;
}
)
;
add_task
(
async
function
test_midnightPingSendFuzzing
(
)
{
const
fuzzingDelay
=
60
*
60
*
1000
;
fakeMidnightPingFuzzingDelay
(
fuzzingDelay
)
;
let
now
=
new
Date
(
2030
5
1
11
0
0
)
;
fakeNow
(
now
)
;
let
waitForTimer
=
(
)
=
>
new
Promise
(
resolve
=
>
{
fakePingSendTimer
(
(
callback
timeout
)
=
>
{
resolve
(
[
callback
timeout
]
)
;
}
(
)
=
>
{
}
)
;
}
)
;
PingServer
.
clearRequests
(
)
;
await
TelemetryController
.
testReset
(
)
;
now
=
new
Date
(
2030
5
2
0
40
0
)
;
fakeNow
(
now
)
;
PingServer
.
registerPingHandler
(
(
req
res
)
=
>
{
Assert
.
ok
(
false
"
No
ping
should
be
received
yet
.
"
)
;
}
)
;
let
timerPromise
=
waitForTimer
(
)
;
await
sendPing
(
true
true
)
;
let
[
timerCallback
timerTimeout
]
=
await
timerPromise
;
Assert
.
ok
(
!
!
timerCallback
)
;
Assert
.
deepEqual
(
futureDate
(
now
timerTimeout
)
new
Date
(
2030
5
2
1
0
0
)
)
;
now
=
new
Date
(
2030
5
2
0
59
59
)
;
fakeNow
(
now
)
;
timerPromise
=
waitForTimer
(
)
;
await
sendPing
(
true
true
)
;
[
timerCallback
timerTimeout
]
=
await
timerPromise
;
Assert
.
deepEqual
(
timerTimeout
1
*
1000
)
;
PingServer
.
resetPingHandler
(
)
;
now
=
futureDate
(
now
timerTimeout
)
;
fakeNow
(
now
)
;
await
timerCallback
(
)
;
const
pings
=
await
PingServer
.
promiseNextPings
(
2
)
;
for
(
let
ping
of
pings
)
{
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
}
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
now
=
futureDate
(
now
5
*
60
*
1000
)
;
await
sendPing
(
true
true
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
now
=
fakeNow
(
2030
5
3
23
59
0
)
;
await
sendPing
(
true
true
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
fakeMidnightPingFuzzingDelay
(
0
)
;
fakePingSendTimer
(
(
)
=
>
{
}
(
)
=
>
{
}
)
;
}
)
;
add_task
(
async
function
test_changePingAfterSubmission
(
)
{
let
payload
=
{
canary
:
"
test
"
}
;
let
pingPromise
=
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
payload
)
;
payload
.
canary
=
"
changed
"
;
const
pingId
=
await
pingPromise
;
let
archivedCopy
=
await
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
equal
(
archivedCopy
.
payload
.
canary
"
test
"
"
The
payload
must
not
be
changed
after
being
submitted
.
"
)
;
}
)
;
add_task
(
async
function
test_telemetryCleanFHRDatabase
(
)
{
const
FHR_DBNAME_PREF
=
"
datareporting
.
healthreport
.
dbName
"
;
const
CUSTOM_DB_NAME
=
"
unlikely
.
to
.
be
.
used
.
sqlite
"
;
const
DEFAULT_DB_NAME
=
"
healthreport
.
sqlite
"
;
const
profileDir
=
PathUtils
.
profileDir
;
const
CUSTOM_DB_PATHS
=
[
PathUtils
.
join
(
profileDir
CUSTOM_DB_NAME
)
PathUtils
.
join
(
profileDir
CUSTOM_DB_NAME
+
"
-
wal
"
)
PathUtils
.
join
(
profileDir
CUSTOM_DB_NAME
+
"
-
shm
"
)
]
;
Preferences
.
set
(
FHR_DBNAME_PREF
CUSTOM_DB_NAME
)
;
for
(
let
dbFilePath
of
CUSTOM_DB_PATHS
)
{
await
IOUtils
.
writeUTF8
(
dbFilePath
"
some
data
"
)
;
}
await
TelemetryStorage
.
removeFHRDatabase
(
)
;
for
(
let
dbFilePath
of
CUSTOM_DB_PATHS
)
{
try
{
await
IOUtils
.
read
(
dbFilePath
)
;
}
catch
(
e
)
{
Assert
.
ok
(
e
instanceof
DOMException
)
;
Assert
.
equal
(
e
.
name
"
NotFoundError
"
"
The
DB
must
not
be
on
the
disk
anymore
:
"
+
dbFilePath
)
;
}
}
await
TelemetryStorage
.
removeFHRDatabase
(
)
;
Preferences
.
reset
(
FHR_DBNAME_PREF
)
;
const
DEFAULT_DB_PATHS
=
[
PathUtils
.
join
(
profileDir
DEFAULT_DB_NAME
)
PathUtils
.
join
(
profileDir
DEFAULT_DB_NAME
+
"
-
wal
"
)
PathUtils
.
join
(
profileDir
DEFAULT_DB_NAME
+
"
-
shm
"
)
]
;
for
(
let
dbFilePath
of
DEFAULT_DB_PATHS
)
{
await
IOUtils
.
writeUTF8
(
dbFilePath
"
some
data
"
)
;
}
await
TelemetryStorage
.
removeFHRDatabase
(
)
;
for
(
let
dbFilePath
of
DEFAULT_DB_PATHS
)
{
try
{
await
IOUtils
.
read
(
dbFilePath
)
;
}
catch
(
e
)
{
Assert
.
ok
(
e
instanceof
DOMException
)
;
Assert
.
equal
(
e
.
name
"
NotFoundError
"
"
The
DB
must
not
be
on
the
disk
anymore
:
"
+
dbFilePath
)
;
}
}
}
)
;
add_task
(
async
function
test_sendNewProfile
(
)
{
if
(
gIsAndroid
|
|
(
AppConstants
.
platform
=
=
"
linux
"
&
&
OS
.
Constants
.
Sys
.
bits
=
=
32
)
)
{
return
;
}
const
NEWPROFILE_PING_TYPE
=
"
new
-
profile
"
;
const
PREF_NEWPROFILE_ENABLED
=
"
toolkit
.
telemetry
.
newProfilePing
.
enabled
"
;
const
PREF_NEWPROFILE_DELAY
=
"
toolkit
.
telemetry
.
newProfilePing
.
delay
"
;
let
resetTest
=
async
function
(
)
{
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
}
;
await
resetTest
(
)
;
const
stateFilePath
=
PathUtils
.
join
(
await
DATAREPORTING_PATH
"
session
-
state
.
json
"
)
;
await
IOUtils
.
remove
(
stateFilePath
)
;
Preferences
.
set
(
PREF_NEWPROFILE_DELAY
1
)
;
Preferences
.
set
(
PREF_NEWPROFILE_ENABLED
true
)
;
let
nextReq
=
PingServer
.
promiseNextRequest
(
)
;
await
TelemetryController
.
testReset
(
)
;
let
req
=
await
nextReq
;
let
ping
=
decodeRequestPayload
(
req
)
;
checkPingFormat
(
ping
NEWPROFILE_PING_TYPE
true
true
)
;
Assert
.
equal
(
ping
.
payload
.
reason
"
startup
"
"
The
new
-
profile
ping
generated
after
startup
must
have
the
correct
reason
"
)
;
Assert
.
ok
(
"
parent
"
in
ping
.
payload
.
processes
"
The
new
-
profile
ping
generated
after
startup
must
have
processes
.
parent
data
"
)
;
Assert
.
throws
(
(
)
=
>
req
.
getHeader
(
"
X
-
PingSender
-
Version
"
)
/
NS_ERROR_NOT_AVAILABLE
/
"
Should
not
have
used
the
pingsender
.
"
)
;
await
resetTest
(
)
;
await
IOUtils
.
remove
(
stateFilePath
)
;
Preferences
.
reset
(
PREF_NEWPROFILE_DELAY
)
;
nextReq
=
PingServer
.
promiseNextRequest
(
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
req
=
await
nextReq
;
ping
=
decodeRequestPayload
(
req
)
;
checkPingFormat
(
ping
NEWPROFILE_PING_TYPE
true
true
)
;
Assert
.
equal
(
ping
.
payload
.
reason
"
shutdown
"
"
The
new
-
profile
ping
generated
at
shutdown
must
have
the
correct
reason
"
)
;
Assert
.
ok
(
"
parent
"
in
ping
.
payload
.
processes
"
The
new
-
profile
ping
generated
at
shutdown
must
have
processes
.
parent
data
"
)
;
Assert
.
equal
(
req
.
getHeader
(
"
User
-
Agent
"
)
"
pingsender
/
1
.
0
"
"
Should
have
received
the
correct
user
agent
string
.
"
)
;
Assert
.
equal
(
req
.
getHeader
(
"
X
-
PingSender
-
Version
"
)
"
1
.
0
"
"
Should
have
received
the
correct
PingSender
version
string
.
"
)
;
await
resetTest
(
)
;
PingServer
.
registerPingHandler
(
(
)
=
>
Assert
.
ok
(
false
"
The
new
-
profile
ping
must
be
sent
only
on
new
profiles
.
"
)
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
resetTest
(
)
;
await
IOUtils
.
remove
(
stateFilePath
)
;
const
sessionState
=
{
sessionId
:
null
subsessionId
:
null
profileSubsessionCounter
:
3785
}
;
await
CommonUtils
.
writeJSON
(
sessionState
stateFilePath
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
Preferences
.
reset
(
PREF_NEWPROFILE_ENABLED
)
;
PingServer
.
resetPingHandler
(
)
;
}
)
;
add_task
(
async
function
test_encryptedPing
(
)
{
if
(
gIsAndroid
)
{
return
;
}
Cu
.
importGlobalProperties
(
[
"
crypto
"
]
)
;
const
ECDH_PARAMS
=
{
name
:
"
ECDH
"
namedCurve
:
"
P
-
256
"
}
;
const
privateKey
=
{
crv
:
"
P
-
256
"
d
:
"
rcs093UlGDG6piwHenmSDoAxbzMIXT43JkQbkt3xEmI
"
ext
:
true
key_ops
:
[
"
deriveKey
"
]
kty
:
"
EC
"
x
:
"
h12feyTYBZ__wO_AnM1a5
-
KTDlko3
-
YyQ_en19jyrs0
"
y
:
"
6GSfzo14ehDyH5E
-
xCOedJDAYlN0AGPMCtIgFbheLko
"
}
;
const
publicKey
=
{
crv
:
"
P
-
256
"
ext
:
true
kty
:
"
EC
"
x
:
"
h12feyTYBZ__wO_AnM1a5
-
KTDlko3
-
YyQ_en19jyrs0
"
y
:
"
6GSfzo14ehDyH5E
-
xCOedJDAYlN0AGPMCtIgFbheLko
"
}
;
const
pioneerId
=
"
12345
"
;
const
schemaName
=
"
abc
"
;
const
schemaNamespace
=
"
def
"
;
const
schemaVersion
=
2
;
Services
.
prefs
.
setStringPref
(
"
toolkit
.
telemetry
.
pioneerId
"
pioneerId
)
;
await
TelemetrySend
.
shutdown
(
)
;
await
TelemetryController
.
testReset
(
)
;
let
payload
=
{
canary
:
"
test
"
}
;
let
pingPromise
=
TelemetryController
.
submitExternalPing
(
"
pioneer
-
study
"
payload
{
studyName
:
"
pioneer
-
dev
-
1
allizom
.
org
"
addPioneerId
:
true
useEncryption
:
true
encryptionKeyId
:
"
pioneer
-
dev
-
20200423
"
publicKey
schemaName
schemaNamespace
schemaVersion
}
)
;
const
pingId
=
await
pingPromise
;
let
archivedCopy
=
await
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
notEqual
(
archivedCopy
.
payload
.
encryptedData
payload
"
The
encrypted
payload
must
not
match
the
plaintext
.
"
)
;
Assert
.
equal
(
archivedCopy
.
payload
.
pioneerId
pioneerId
"
Pioneer
ID
in
ping
must
match
the
pref
.
"
)
;
const
schema
=
{
schema
:
"
http
:
/
/
json
-
schema
.
org
/
draft
-
04
/
schema
#
"
properties
:
{
application
:
{
additionalProperties
:
false
properties
:
{
architecture
:
{
type
:
"
string
"
}
buildId
:
{
pattern
:
"
^
[
0
-
9
]
{
10
}
"
type
:
"
string
"
}
channel
:
{
type
:
"
string
"
}
displayVersion
:
{
pattern
:
"
^
[
0
-
9
]
{
2
3
}
\
\
.
"
type
:
"
string
"
}
name
:
{
type
:
"
string
"
}
platformVersion
:
{
pattern
:
"
^
[
0
-
9
]
{
2
3
}
\
\
.
"
type
:
"
string
"
}
vendor
:
{
type
:
"
string
"
}
version
:
{
pattern
:
"
^
[
0
-
9
]
{
2
3
}
\
\
.
"
type
:
"
string
"
}
xpcomAbi
:
{
type
:
"
string
"
}
}
required
:
[
"
architecture
"
"
buildId
"
"
channel
"
"
name
"
"
platformVersion
"
"
version
"
"
vendor
"
"
xpcomAbi
"
]
type
:
"
object
"
}
creationDate
:
{
pattern
:
"
^
[
0
-
9
]
{
4
}
-
[
0
-
9
]
{
2
}
-
[
0
-
9
]
{
2
}
T
[
0
-
9
]
{
2
}
:
[
0
-
9
]
{
2
}
:
[
0
-
9
]
{
2
}
\
\
.
[
0
-
9
]
{
3
}
Z
"
type
:
"
string
"
}
id
:
{
pattern
:
"
^
[
a
-
fA
-
F0
-
9
]
{
8
}
-
[
a
-
fA
-
F0
-
9
]
{
4
}
-
[
a
-
fA
-
F0
-
9
]
{
4
}
-
[
a
-
fA
-
F0
-
9
]
{
4
}
-
[
a
-
fA
-
F0
-
9
]
{
12
}
"
type
:
"
string
"
}
payload
:
{
description
:
"
"
properties
:
{
encryptedData
:
{
description
:
"
JOSE
/
JWE
encrypted
payload
.
"
type
:
"
string
"
}
encryptionKeyId
:
{
description
:
"
JOSE
/
JWK
key
id
e
.
g
.
pioneer
-
20170520
.
"
type
:
"
string
"
}
pioneerId
:
{
description
:
"
Custom
pioneer
id
must
not
be
Telemetry
clientId
"
pattern
:
"
^
[
a
-
fA
-
F0
-
9
]
{
8
}
-
[
a
-
fA
-
F0
-
9
]
{
4
}
-
[
a
-
fA
-
F0
-
9
]
{
4
}
-
[
a
-
fA
-
F0
-
9
]
{
4
}
-
[
a
-
fA
-
F0
-
9
]
{
12
}
"
type
:
"
string
"
}
schemaName
:
{
description
:
"
Name
of
a
schema
used
for
validation
of
the
encryptedData
"
maxLength
:
100
minLength
:
1
pattern
:
"
^
\
\
S
+
"
type
:
"
string
"
}
schemaNamespace
:
{
description
:
"
The
namespace
of
the
schema
used
for
validation
and
routing
to
a
dataset
.
"
maxLength
:
100
minLength
:
1
pattern
:
"
^
\
\
S
+
"
type
:
"
string
"
}
schemaVersion
:
{
description
:
"
Integer
version
number
of
the
schema
"
minimum
:
1
type
:
"
integer
"
}
studyName
:
{
description
:
"
Name
of
a
particular
study
.
Usually
the
addon_id
.
"
maxLength
:
100
minLength
:
1
pattern
:
"
^
\
\
S
+
"
type
:
"
string
"
}
}
required
:
[
"
encryptedData
"
"
encryptionKeyId
"
"
pioneerId
"
"
studyName
"
"
schemaName
"
"
schemaNamespace
"
"
schemaVersion
"
]
title
:
"
pioneer
-
study
"
type
:
"
object
"
}
type
:
{
description
:
"
doc_type
restated
"
enum
:
[
"
pioneer
-
study
"
]
type
:
"
string
"
}
version
:
{
maximum
:
4
minimum
:
4
type
:
"
integer
"
}
}
required
:
[
"
application
"
"
creationDate
"
"
id
"
"
payload
"
"
type
"
"
version
"
]
title
:
"
pioneer
-
study
"
type
:
"
object
"
}
;
const
result
=
JsonSchemaValidator
.
validate
(
archivedCopy
schema
)
;
Assert
.
ok
(
result
.
valid
Archived
ping
should
validate
against
schema
:
{
result
.
error
}
)
;
const
privateJWK
=
await
crypto
.
subtle
.
importKey
(
"
jwk
"
privateKey
ECDH_PARAMS
false
[
"
deriveKey
"
]
)
;
const
decryptedJWE
=
await
jwcrypto
.
decryptJWE
(
archivedCopy
.
payload
.
encryptedData
privateJWK
)
;
Assert
.
deepEqual
(
JSON
.
parse
(
new
TextDecoder
(
"
utf
-
8
"
)
.
decode
(
decryptedJWE
)
)
payload
"
decrypted
payload
should
match
"
)
;
}
)
;
add_task
(
async
function
test_encryptedPing_overrideId
(
)
{
if
(
gIsAndroid
)
{
return
;
}
Cu
.
importGlobalProperties
(
[
"
crypto
"
]
)
;
const
publicKey
=
{
crv
:
"
P
-
256
"
ext
:
true
kty
:
"
EC
"
x
:
"
h12feyTYBZ__wO_AnM1a5
-
KTDlko3
-
YyQ_en19jyrs0
"
y
:
"
6GSfzo14ehDyH5E
-
xCOedJDAYlN0AGPMCtIgFbheLko
"
}
;
const
prefPioneerId
=
"
12345
"
;
const
overriddenPioneerId
=
"
c0ffeeaa
-
bbbb
-
abab
-
baba
-
eeff0ceeff0c
"
;
const
schemaName
=
"
abc
"
;
const
schemaNamespace
=
"
def
"
;
const
schemaVersion
=
2
;
Services
.
prefs
.
setStringPref
(
"
toolkit
.
telemetry
.
pioneerId
"
prefPioneerId
)
;
let
archiveTester
=
new
TelemetryArchiveTesting
.
Checker
(
)
;
await
archiveTester
.
promiseInit
(
)
;
let
payload
=
{
canary
:
"
test
"
}
;
let
pingPromise
=
TelemetryController
.
submitExternalPing
(
"
test
-
pioneer
-
study
-
override
"
payload
{
studyName
:
"
pioneer
-
dev
-
1
allizom
.
org
"
addPioneerId
:
true
overridePioneerId
:
overriddenPioneerId
useEncryption
:
true
encryptionKeyId
:
"
pioneer
-
dev
-
20200423
"
publicKey
schemaName
schemaNamespace
schemaVersion
}
)
;
const
pingId
=
await
pingPromise
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
archiveTester
.
promiseFindPing
(
"
test
-
pioneer
-
study
-
override
"
[
]
)
"
Failed
to
find
the
pioneer
ping
"
)
;
let
archivedCopy
=
await
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
notEqual
(
archivedCopy
.
payload
.
encryptedData
payload
"
The
encrypted
payload
must
not
match
the
plaintext
.
"
)
;
Assert
.
equal
(
archivedCopy
.
payload
.
pioneerId
overriddenPioneerId
"
Pioneer
ID
in
ping
must
match
the
provided
override
.
"
)
;
}
)
;
add_task
(
async
function
test_pingRejection
(
)
{
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
sendPing
(
false
false
)
.
then
(
(
)
=
>
Assert
.
ok
(
false
"
Pings
submitted
after
shutdown
must
be
rejected
.
"
)
(
)
=
>
Assert
.
ok
(
true
"
Ping
submitted
after
shutdown
correctly
rejected
.
"
)
)
;
}
)
;
add_task
(
async
function
test_newCanRecordsMatchTheOld
(
)
{
Assert
.
equal
(
Telemetry
.
canRecordBase
Telemetry
.
canRecordReleaseData
"
Release
Data
is
the
new
way
to
say
Base
Collection
"
)
;
Assert
.
equal
(
Telemetry
.
canRecordExtended
Telemetry
.
canRecordPrereleaseData
"
Prerelease
Data
is
the
new
way
to
say
Extended
Collection
"
)
;
}
)
;
add_task
(
function
test_histogram_filtering
(
)
{
const
COUNT_ID
=
"
TELEMETRY_TEST_COUNT
"
;
const
KEYED_ID
=
"
TELEMETRY_TEST_KEYED_COUNT
"
;
const
count
=
Telemetry
.
getHistogramById
(
COUNT_ID
)
;
const
keyed
=
Telemetry
.
getKeyedHistogramById
(
KEYED_ID
)
;
count
.
add
(
1
)
;
keyed
.
add
(
"
a
"
1
)
;
let
snapshot
=
Telemetry
.
getSnapshotForHistograms
(
"
main
"
false
false
)
.
parent
;
let
keyedSnapshot
=
Telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
false
false
)
.
parent
;
Assert
.
ok
(
COUNT_ID
in
snapshot
"
test
histogram
should
be
snapshotted
"
)
;
Assert
.
ok
(
KEYED_ID
in
keyedSnapshot
"
test
keyed
histogram
should
be
snapshotted
"
)
;
snapshot
=
Telemetry
.
getSnapshotForHistograms
(
"
main
"
false
true
)
.
parent
;
keyedSnapshot
=
Telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
false
true
)
.
parent
;
Assert
.
ok
(
!
(
COUNT_ID
in
snapshot
)
"
test
histogram
should
not
be
snapshotted
"
)
;
Assert
.
ok
(
!
(
KEYED_ID
in
keyedSnapshot
)
"
test
keyed
histogram
should
not
be
snapshotted
"
)
;
}
)
;
add_task
(
function
test_scalar_filtering
(
)
{
const
COUNT_ID
=
"
telemetry
.
test
.
unsigned_int_kind
"
;
const
KEYED_ID
=
"
telemetry
.
test
.
keyed_unsigned_int
"
;
Telemetry
.
scalarSet
(
COUNT_ID
2
)
;
Telemetry
.
keyedScalarSet
(
KEYED_ID
"
a
"
2
)
;
let
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
false
)
.
parent
;
let
keyedSnapshot
=
Telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
false
false
)
.
parent
;
Assert
.
ok
(
COUNT_ID
in
snapshot
"
test
scalars
should
be
snapshotted
"
)
;
Assert
.
ok
(
KEYED_ID
in
keyedSnapshot
"
test
keyed
scalars
should
be
snapshotted
"
)
;
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
true
)
.
parent
;
keyedSnapshot
=
Telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
false
true
)
.
parent
;
Assert
.
ok
(
!
(
COUNT_ID
in
snapshot
)
"
test
scalars
should
not
be
snapshotted
"
)
;
Assert
.
ok
(
!
(
KEYED_ID
in
keyedSnapshot
)
"
test
keyed
scalars
should
not
be
snapshotted
"
)
;
}
)
;
add_task
(
async
function
stopServer
(
)
{
await
PingServer
.
stop
(
)
;
}
)
;
