const
{
ClientID
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ClientID
.
sys
.
mjs
"
)
;
const
{
TelemetryController
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
sys
.
mjs
"
)
;
const
{
TelemetryStorage
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
sys
.
mjs
"
)
;
const
{
TelemetrySend
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
sys
.
mjs
"
)
;
const
{
TelemetryArchive
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
TelemetryArchive
.
sys
.
mjs
"
)
;
const
{
TelemetryUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
sys
.
mjs
"
)
;
const
{
ContentTaskUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
ContentTaskUtils
.
sys
.
mjs
"
)
;
const
{
TestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
)
;
const
PING_FORMAT_VERSION
=
4
;
const
DELETION_REQUEST_PING_TYPE
=
"
deletion
-
request
"
;
const
TEST_PING_TYPE
=
"
test
-
ping
-
type
"
;
var
gClientID
=
null
;
var
gProfileGroupID
=
null
;
ChromeUtils
.
defineLazyGetter
(
this
"
DATAREPORTING_PATH
"
async
function
(
)
{
return
PathUtils
.
join
(
PathUtils
.
profileDir
"
datareporting
"
)
;
}
)
;
function
sendPing
(
aSendClientId
aSendEnvironment
)
{
if
(
PingServer
.
started
)
{
TelemetrySend
.
setServer
(
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
}
else
{
TelemetrySend
.
setServer
(
"
http
:
/
/
doesnotexist
"
)
;
}
let
options
=
{
addClientId
:
aSendClientId
addEnvironment
:
aSendEnvironment
}
;
return
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
options
)
;
}
function
checkPingFormat
(
aPing
aType
aHasClientId
aHasEnvironment
)
{
const
MANDATORY_PING_FIELDS
=
[
"
type
"
"
id
"
"
creationDate
"
"
version
"
"
application
"
"
payload
"
]
;
const
APPLICATION_TEST_DATA
=
{
buildId
:
gAppInfo
.
appBuildID
name
:
APP_NAME
version
:
APP_VERSION
displayVersion
:
AppConstants
.
MOZ_APP_VERSION_DISPLAY
vendor
:
"
Mozilla
"
platformVersion
:
PLATFORM_VERSION
xpcomAbi
:
"
noarch
-
spidermonkey
"
}
;
for
(
let
f
of
MANDATORY_PING_FIELDS
)
{
Assert
.
ok
(
f
in
aPing
f
+
"
must
be
available
.
"
)
;
}
Assert
.
equal
(
aPing
.
type
aType
"
The
ping
must
have
the
correct
type
.
"
)
;
Assert
.
equal
(
aPing
.
version
PING_FORMAT_VERSION
"
The
ping
must
have
the
correct
version
.
"
)
;
for
(
let
f
in
APPLICATION_TEST_DATA
)
{
Assert
.
equal
(
aPing
.
application
[
f
]
APPLICATION_TEST_DATA
[
f
]
f
+
"
must
have
the
correct
value
.
"
)
;
}
Assert
.
ok
(
"
architecture
"
in
aPing
.
application
"
The
application
section
must
have
an
architecture
field
.
"
)
;
Assert
.
ok
(
"
channel
"
in
aPing
.
application
"
The
application
section
must
have
a
channel
field
.
"
)
;
Assert
.
equal
(
"
clientId
"
in
aPing
aHasClientId
)
;
Assert
.
equal
(
"
profileGroupId
"
in
aPing
aHasClientId
)
;
Assert
.
equal
(
"
environment
"
in
aPing
aHasEnvironment
)
;
}
add_task
(
async
function
test_setup
(
)
{
do_get_profile
(
)
;
await
loadAddonManager
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
.
9
.
2
"
)
;
finishAddonManagerStartup
(
)
;
fakeIntlReady
(
)
;
await
setEmptyPrefWatchlist
(
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
new
Promise
(
resolve
=
>
Telemetry
.
asyncFetchTelemetryData
(
wrapWithExceptionHandler
(
resolve
)
)
)
;
}
)
;
add_task
(
async
function
asyncSetup
(
)
{
await
TelemetryController
.
testSetup
(
)
;
}
)
;
add_task
(
async
function
test_overwritePing
(
)
{
let
ping
=
{
id
:
"
foo
"
}
;
await
TelemetryStorage
.
savePing
(
ping
true
)
;
await
TelemetryStorage
.
savePing
(
ping
false
)
;
await
TelemetryStorage
.
cleanupPingFile
(
ping
)
;
}
)
;
add_task
(
async
function
test_simplePing
(
)
{
PingServer
.
start
(
)
;
Services
.
prefs
.
setStringPref
(
TelemetryUtils
.
Preferences
.
Server
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
await
sendPing
(
false
false
)
;
let
request
=
await
PingServer
.
promiseNextRequest
(
)
;
let
ping
=
decodeRequestPayload
(
request
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
false
false
)
;
}
)
;
add_task
(
async
function
test_disableDataUpload
(
)
{
const
OPTIN_PROBE
=
"
telemetry
.
data_upload_optin
"
;
const
isUnified
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
if
(
!
isUnified
)
{
return
;
}
let
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
)
.
parent
|
|
{
}
;
Assert
.
ok
(
!
(
OPTIN_PROBE
in
snapshot
)
"
Data
optin
scalar
should
not
be
set
at
start
"
)
;
await
sendPing
(
true
false
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
let
firstClientId
=
ping
.
clientId
;
let
firstProfileGroupId
=
ping
.
profileGroupId
;
Assert
.
ok
(
firstClientId
"
Test
ping
needs
a
client
ID
"
)
;
Assert
.
notEqual
(
TelemetryUtils
.
knownClientID
firstClientId
"
Client
ID
should
be
valid
and
random
"
)
;
Assert
.
notEqual
(
TelemetryUtils
.
knownProfileGroupID
firstProfileGroupId
"
Profile
group
ID
should
be
valid
and
random
"
)
;
let
disableObserved
=
TestUtils
.
topicObserved
(
TelemetryUtils
.
TELEMETRY_UPLOAD_DISABLED_TOPIC
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
await
disableObserved
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
DELETION_REQUEST_PING_TYPE
true
false
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
)
.
parent
|
|
{
}
;
Assert
.
ok
(
!
(
OPTIN_PROBE
in
snapshot
)
"
Data
optin
scalar
should
not
be
set
after
opt
out
"
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
const
scalarSnapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
)
;
return
(
Object
.
keys
(
scalarSnapshot
)
.
includes
(
"
parent
"
)
&
&
OPTIN_PROBE
in
scalarSnapshot
.
parent
)
;
}
)
;
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
)
.
parent
|
|
{
}
;
Assert
.
ok
(
snapshot
[
OPTIN_PROBE
]
"
Enabling
data
upload
should
set
optin
probe
"
)
;
let
secondClientId
=
TelemetryController
.
getCurrentPingData
(
)
.
clientId
;
Assert
.
notEqual
(
firstClientId
secondClientId
"
The
client
id
must
have
changed
"
)
;
let
secondProfileGroupId
=
TelemetryController
.
getCurrentPingData
(
)
.
profileGroupId
;
Assert
.
notEqual
(
firstProfileGroupId
secondProfileGroupId
"
The
profile
group
id
must
have
changed
"
)
;
await
PingServer
.
stop
(
)
;
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
await
TelemetryController
.
testPromiseDeletionRequestPingSubmitted
(
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
await
TelemetryStorage
.
shutdown
(
)
;
await
TelemetryController
.
testReset
(
)
;
let
pendingPings
=
await
TelemetryStorage
.
loadPendingPingList
(
)
;
Assert
.
equal
(
pendingPings
.
length
1
"
All
the
pending
pings
should
have
been
deleted
except
the
deletion
-
request
ping
"
)
;
PingServer
.
start
(
)
;
Services
.
prefs
.
setStringPref
(
TelemetryUtils
.
Preferences
.
Server
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
await
TelemetrySend
.
shutdown
(
)
;
await
TelemetryController
.
testReset
(
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
sendPing
(
true
false
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
notEqual
(
TelemetryUtils
.
knownClientID
ping
.
clientId
"
Client
ID
should
be
reset
to
a
random
value
"
)
;
Assert
.
notEqual
(
firstClientId
ping
.
clientId
"
Client
ID
should
be
different
from
the
previous
value
"
)
;
Assert
.
notEqual
(
firstProfileGroupId
ping
.
profileGroupId
"
The
profile
group
ID
should
change
"
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
DELETION_REQUEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
secondClientId
ping
.
clientId
"
Deletion
must
be
requested
for
correct
client
id
"
)
;
Assert
.
equal
(
secondProfileGroupId
ping
.
profileGroupId
"
Deletion
must
be
requested
for
correct
profile
group
id
"
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
}
)
;
add_task
(
async
function
test_pingHasClientId
(
)
{
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
CachedClientId
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
ClientID
.
_reset
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
let
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_PING_SUBMISSION_WAITING_CLIENTID
"
)
;
h
.
clear
(
)
;
let
promisePingSetup
=
TelemetryController
.
testReset
(
)
;
await
sendPing
(
true
false
)
;
Assert
.
equal
(
h
.
snapshot
(
)
.
sum
1
"
We
must
have
a
ping
waiting
for
the
clientId
early
during
startup
.
"
)
;
await
promisePingSetup
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
gClientID
=
await
ClientID
.
getClientID
(
)
;
gProfileGroupID
=
await
ClientID
.
getProfileGroupID
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
The
correct
clientId
must
be
reported
.
"
)
;
Assert
.
equal
(
ping
.
profileGroupId
gProfileGroupID
"
The
correct
profileGroupId
must
be
reported
.
"
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
h
.
clear
(
)
;
promisePingSetup
=
TelemetryController
.
testReset
(
)
;
await
sendPing
(
true
false
)
;
await
promisePingSetup
;
Assert
.
equal
(
h
.
snapshot
(
)
.
sum
0
"
We
must
have
used
the
cached
clientId
.
"
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
Telemetry
should
report
the
correct
cached
clientId
.
"
)
;
Assert
.
equal
(
ping
.
profileGroupId
gProfileGroupID
"
Telemetry
should
report
the
correct
cached
profileGroupId
.
"
)
;
Services
.
prefs
.
clearUserPref
(
TelemetryUtils
.
Preferences
.
CachedClientId
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
await
TelemetryController
.
testReset
(
)
;
await
sendPing
(
true
false
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
The
correct
clientId
must
be
reported
.
"
)
;
Assert
.
equal
(
ping
.
profileGroupId
gProfileGroupID
"
The
correct
profileGroupId
must
be
reported
.
"
)
;
Assert
.
equal
(
h
.
snapshot
(
)
.
sum
0
"
No
ping
should
have
been
waiting
for
a
clientId
.
"
)
;
}
)
;
add_task
(
async
function
test_pingHasEnvironment
(
)
{
await
sendPing
(
false
true
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
false
true
)
;
Assert
.
equal
(
ping
.
application
.
buildId
ping
.
environment
.
build
.
buildId
)
;
}
)
;
add_task
(
async
function
test_pingHasEnvironmentAndClientId
(
)
{
await
sendPing
(
true
true
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
Assert
.
equal
(
ping
.
application
.
buildId
ping
.
environment
.
build
.
buildId
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
The
correct
clientId
must
be
reported
.
"
)
;
Assert
.
equal
(
ping
.
profileGroupId
gProfileGroupID
"
The
correct
profileGroupId
must
be
reported
.
"
)
;
}
)
;
add_task
(
async
function
test_archivePings
(
)
{
let
now
=
new
Date
(
2009
10
18
12
0
0
)
;
fakeNow
(
now
)
;
const
isUnified
=
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
const
uploadPref
=
isUnified
?
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
:
TelemetryUtils
.
Preferences
.
TelemetryEnabled
;
Services
.
prefs
.
setBoolPref
(
uploadPref
false
)
;
if
(
isUnified
)
{
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
DELETION_REQUEST_PING_TYPE
true
false
)
;
}
PingServer
.
registerPingHandler
(
(
)
=
>
Assert
.
ok
(
false
"
Telemetry
must
not
send
pings
if
not
allowed
to
.
"
)
)
;
let
pingId
=
await
sendPing
(
true
true
)
;
let
ping
=
await
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
equal
(
ping
.
id
pingId
"
TelemetryController
should
still
archive
pings
.
"
)
;
now
=
new
Date
(
2010
10
18
12
0
0
)
;
fakeNow
(
now
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
ArchiveEnabled
false
)
;
pingId
=
await
sendPing
(
true
true
)
;
let
promise
=
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
ok
(
await
promiseRejects
(
promise
)
"
TelemetryController
should
not
archive
pings
if
the
archive
pref
is
disabled
.
"
)
;
Services
.
prefs
.
setBoolPref
(
uploadPref
true
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
ArchiveEnabled
true
)
;
now
=
new
Date
(
2014
6
18
22
0
0
)
;
fakeNow
(
now
)
;
PingServer
.
resetPingHandler
(
)
;
pingId
=
await
sendPing
(
true
true
)
;
await
PingServer
.
promiseNextPing
(
)
;
ping
=
await
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
equal
(
ping
.
id
pingId
"
TelemetryController
should
still
archive
pings
if
ping
upload
is
enabled
.
"
)
;
}
)
;
add_task
(
async
function
test_midnightPingSendFuzzing
(
)
{
const
fuzzingDelay
=
60
*
60
*
1000
;
fakeMidnightPingFuzzingDelay
(
fuzzingDelay
)
;
let
now
=
new
Date
(
2030
5
1
11
0
0
)
;
fakeNow
(
now
)
;
let
waitForTimer
=
(
)
=
>
new
Promise
(
resolve
=
>
{
fakePingSendTimer
(
(
callback
timeout
)
=
>
{
resolve
(
[
callback
timeout
]
)
;
}
(
)
=
>
{
}
)
;
}
)
;
PingServer
.
clearRequests
(
)
;
await
TelemetryController
.
testReset
(
)
;
now
=
new
Date
(
2030
5
2
0
40
0
)
;
fakeNow
(
now
)
;
PingServer
.
registerPingHandler
(
(
)
=
>
{
Assert
.
ok
(
false
"
No
ping
should
be
received
yet
.
"
)
;
}
)
;
let
timerPromise
=
waitForTimer
(
)
;
await
sendPing
(
true
true
)
;
let
[
timerCallback
timerTimeout
]
=
await
timerPromise
;
Assert
.
ok
(
!
!
timerCallback
)
;
Assert
.
deepEqual
(
futureDate
(
now
timerTimeout
)
new
Date
(
2030
5
2
1
0
0
)
)
;
now
=
new
Date
(
2030
5
2
0
59
59
)
;
fakeNow
(
now
)
;
timerPromise
=
waitForTimer
(
)
;
await
sendPing
(
true
true
)
;
[
timerCallback
timerTimeout
]
=
await
timerPromise
;
Assert
.
deepEqual
(
timerTimeout
1
*
1000
)
;
PingServer
.
resetPingHandler
(
)
;
now
=
futureDate
(
now
timerTimeout
)
;
fakeNow
(
now
)
;
await
timerCallback
(
)
;
const
pings
=
await
PingServer
.
promiseNextPings
(
2
)
;
for
(
let
ping
of
pings
)
{
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
}
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
now
=
futureDate
(
now
5
*
60
*
1000
)
;
await
sendPing
(
true
true
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
now
=
fakeNow
(
2030
5
3
23
59
0
)
;
await
sendPing
(
true
true
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
fakeMidnightPingFuzzingDelay
(
0
)
;
fakePingSendTimer
(
(
)
=
>
{
}
(
)
=
>
{
}
)
;
}
)
;
add_task
(
async
function
test_changePingAfterSubmission
(
)
{
let
payload
=
{
canary
:
"
test
"
}
;
let
pingPromise
=
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
payload
)
;
payload
.
canary
=
"
changed
"
;
const
pingId
=
await
pingPromise
;
let
archivedCopy
=
await
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
equal
(
archivedCopy
.
payload
.
canary
"
test
"
"
The
payload
must
not
be
changed
after
being
submitted
.
"
)
;
}
)
;
add_task
(
async
function
test_telemetryCleanFHRDatabase
(
)
{
const
FHR_DBNAME_PREF
=
"
datareporting
.
healthreport
.
dbName
"
;
const
CUSTOM_DB_NAME
=
"
unlikely
.
to
.
be
.
used
.
sqlite
"
;
const
DEFAULT_DB_NAME
=
"
healthreport
.
sqlite
"
;
const
profileDir
=
PathUtils
.
profileDir
;
const
CUSTOM_DB_PATHS
=
[
PathUtils
.
join
(
profileDir
CUSTOM_DB_NAME
)
PathUtils
.
join
(
profileDir
CUSTOM_DB_NAME
+
"
-
wal
"
)
PathUtils
.
join
(
profileDir
CUSTOM_DB_NAME
+
"
-
shm
"
)
]
;
Services
.
prefs
.
setStringPref
(
FHR_DBNAME_PREF
CUSTOM_DB_NAME
)
;
for
(
let
dbFilePath
of
CUSTOM_DB_PATHS
)
{
await
IOUtils
.
writeUTF8
(
dbFilePath
"
some
data
"
)
;
}
await
TelemetryStorage
.
removeFHRDatabase
(
)
;
for
(
let
dbFilePath
of
CUSTOM_DB_PATHS
)
{
try
{
await
IOUtils
.
read
(
dbFilePath
)
;
}
catch
(
e
)
{
Assert
.
ok
(
DOMException
.
isInstance
(
e
)
)
;
Assert
.
equal
(
e
.
name
"
NotFoundError
"
"
The
DB
must
not
be
on
the
disk
anymore
:
"
+
dbFilePath
)
;
}
}
await
TelemetryStorage
.
removeFHRDatabase
(
)
;
Services
.
prefs
.
clearUserPref
(
FHR_DBNAME_PREF
)
;
const
DEFAULT_DB_PATHS
=
[
PathUtils
.
join
(
profileDir
DEFAULT_DB_NAME
)
PathUtils
.
join
(
profileDir
DEFAULT_DB_NAME
+
"
-
wal
"
)
PathUtils
.
join
(
profileDir
DEFAULT_DB_NAME
+
"
-
shm
"
)
]
;
for
(
let
dbFilePath
of
DEFAULT_DB_PATHS
)
{
await
IOUtils
.
writeUTF8
(
dbFilePath
"
some
data
"
)
;
}
await
TelemetryStorage
.
removeFHRDatabase
(
)
;
for
(
let
dbFilePath
of
DEFAULT_DB_PATHS
)
{
try
{
await
IOUtils
.
read
(
dbFilePath
)
;
}
catch
(
e
)
{
Assert
.
ok
(
DOMException
.
isInstance
(
e
)
)
;
Assert
.
equal
(
e
.
name
"
NotFoundError
"
"
The
DB
must
not
be
on
the
disk
anymore
:
"
+
dbFilePath
)
;
}
}
}
)
;
add_task
(
async
function
test_sendNewProfile
(
)
{
if
(
gIsAndroid
|
|
(
AppConstants
.
platform
=
=
"
linux
"
&
&
!
Services
.
appinfo
.
is64Bit
)
)
{
return
;
}
const
NEWPROFILE_PING_TYPE
=
"
new
-
profile
"
;
const
PREF_NEWPROFILE_ENABLED
=
"
toolkit
.
telemetry
.
newProfilePing
.
enabled
"
;
const
PREF_NEWPROFILE_DELAY
=
"
toolkit
.
telemetry
.
newProfilePing
.
delay
"
;
let
resetTest
=
async
function
(
)
{
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
await
TelemetryController
.
testReset
(
)
;
}
;
await
resetTest
(
)
;
const
stateFilePath
=
PathUtils
.
join
(
await
DATAREPORTING_PATH
"
session
-
state
.
json
"
)
;
await
IOUtils
.
remove
(
stateFilePath
)
;
Services
.
prefs
.
setIntPref
(
PREF_NEWPROFILE_DELAY
1
)
;
Services
.
prefs
.
setBoolPref
(
PREF_NEWPROFILE_ENABLED
true
)
;
let
nextReq
=
PingServer
.
promiseNextRequest
(
)
;
await
TelemetryController
.
testReset
(
)
;
let
req
=
await
nextReq
;
let
ping
=
decodeRequestPayload
(
req
)
;
if
(
ping
.
type
=
=
"
event
"
)
{
req
=
await
PingServer
.
promiseNextRequest
(
)
;
ping
=
decodeRequestPayload
(
req
)
;
}
checkPingFormat
(
ping
NEWPROFILE_PING_TYPE
true
true
)
;
Assert
.
equal
(
ping
.
payload
.
reason
"
startup
"
"
The
new
-
profile
ping
generated
after
startup
must
have
the
correct
reason
"
)
;
Assert
.
ok
(
"
parent
"
in
ping
.
payload
.
processes
"
The
new
-
profile
ping
generated
after
startup
must
have
processes
.
parent
data
"
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
AppConstants
.
MOZ_APP_NAME
!
=
=
"
thunderbird
"
)
{
Assert
.
ok
(
"
scalars
"
in
ping
.
payload
.
processes
.
parent
"
The
new
-
profile
ping
should
have
a
field
for
scalars
"
)
;
Assert
.
ok
(
"
installation
.
firstSeen
.
failure_reason
"
in
ping
.
payload
.
processes
.
parent
.
scalars
"
The
new
-
profile
ping
should
have
an
installation
.
firstSeen
.
failure_reason
scalar
"
)
;
Assert
.
equal
(
ping
.
payload
.
processes
.
parent
.
scalars
[
"
installation
.
firstSeen
.
failure_reason
"
]
"
NotFoundError
"
"
The
new
-
profile
ping
should
return
NotFoundError
as
we
don
'
t
have
a
telemetry
state
file
"
)
;
}
Assert
.
throws
(
(
)
=
>
req
.
getHeader
(
"
X
-
PingSender
-
Version
"
)
/
NS_ERROR_NOT_AVAILABLE
/
"
Should
not
have
used
the
pingsender
.
"
)
;
await
resetTest
(
)
;
await
IOUtils
.
remove
(
stateFilePath
)
;
Services
.
prefs
.
clearUserPref
(
PREF_NEWPROFILE_DELAY
)
;
nextReq
=
PingServer
.
promiseNextRequest
(
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
req
=
await
nextReq
;
ping
=
decodeRequestPayload
(
req
)
;
if
(
ping
.
type
=
=
"
event
"
)
{
req
=
await
PingServer
.
promiseNextRequest
(
)
;
ping
=
decodeRequestPayload
(
req
)
;
}
checkPingFormat
(
ping
NEWPROFILE_PING_TYPE
true
true
)
;
Assert
.
equal
(
ping
.
payload
.
reason
"
shutdown
"
"
The
new
-
profile
ping
generated
at
shutdown
must
have
the
correct
reason
"
)
;
Assert
.
ok
(
"
parent
"
in
ping
.
payload
.
processes
"
The
new
-
profile
ping
generated
at
shutdown
must
have
processes
.
parent
data
"
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
AppConstants
.
MOZ_APP_NAME
!
=
=
"
thunderbird
"
)
{
Assert
.
ok
(
"
scalars
"
in
ping
.
payload
.
processes
.
parent
"
The
new
-
profile
ping
should
have
a
field
for
scalars
"
)
;
Assert
.
ok
(
"
installation
.
firstSeen
.
failure_reason
"
in
ping
.
payload
.
processes
.
parent
.
scalars
"
The
new
-
profile
ping
should
have
an
installation
.
firstSeen
.
failure_reason
scalar
"
)
;
Assert
.
equal
(
ping
.
payload
.
processes
.
parent
.
scalars
[
"
installation
.
firstSeen
.
failure_reason
"
]
"
NotFoundError
"
"
The
new
-
profile
ping
should
return
NotFoundError
as
we
don
'
t
have
a
telemetry
state
file
"
)
;
}
Assert
.
equal
(
req
.
getHeader
(
"
User
-
Agent
"
)
"
pingsender
/
1
.
0
"
"
Should
have
received
the
correct
user
agent
string
.
"
)
;
Assert
.
equal
(
req
.
getHeader
(
"
X
-
PingSender
-
Version
"
)
"
1
.
0
"
"
Should
have
received
the
correct
PingSender
version
string
.
"
)
;
await
resetTest
(
)
;
PingServer
.
registerPingHandler
(
(
)
=
>
Assert
.
ok
(
false
"
The
new
-
profile
ping
must
be
sent
only
on
new
profiles
.
"
)
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
resetTest
(
)
;
await
IOUtils
.
remove
(
stateFilePath
)
;
const
sessionState
=
{
sessionId
:
null
subsessionId
:
null
profileSubsessionCounter
:
3785
}
;
await
IOUtils
.
writeJSON
(
stateFilePath
sessionState
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
Services
.
prefs
.
clearUserPref
(
PREF_NEWPROFILE_ENABLED
)
;
PingServer
.
resetPingHandler
(
)
;
}
)
;
add_task
(
async
function
test_pingRejection
(
)
{
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
sendPing
(
false
false
)
.
then
(
(
)
=
>
Assert
.
ok
(
false
"
Pings
submitted
after
shutdown
must
be
rejected
.
"
)
(
)
=
>
Assert
.
ok
(
true
"
Ping
submitted
after
shutdown
correctly
rejected
.
"
)
)
;
}
)
;
add_task
(
async
function
test_newCanRecordsMatchTheOld
(
)
{
Assert
.
equal
(
Telemetry
.
canRecordBase
Telemetry
.
canRecordReleaseData
"
Release
Data
is
the
new
way
to
say
Base
Collection
"
)
;
Assert
.
equal
(
Telemetry
.
canRecordExtended
Telemetry
.
canRecordPrereleaseData
"
Prerelease
Data
is
the
new
way
to
say
Extended
Collection
"
)
;
}
)
;
add_task
(
function
test_histogram_filtering
(
)
{
const
COUNT_ID
=
"
TELEMETRY_TEST_COUNT
"
;
const
KEYED_ID
=
"
TELEMETRY_TEST_KEYED_COUNT
"
;
const
count
=
Telemetry
.
getHistogramById
(
COUNT_ID
)
;
const
keyed
=
Telemetry
.
getKeyedHistogramById
(
KEYED_ID
)
;
count
.
add
(
1
)
;
keyed
.
add
(
"
a
"
1
)
;
let
snapshot
=
Telemetry
.
getSnapshotForHistograms
(
"
main
"
false
false
)
.
parent
;
let
keyedSnapshot
=
Telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
false
false
)
.
parent
;
Assert
.
ok
(
COUNT_ID
in
snapshot
"
test
histogram
should
be
snapshotted
"
)
;
Assert
.
ok
(
KEYED_ID
in
keyedSnapshot
"
test
keyed
histogram
should
be
snapshotted
"
)
;
snapshot
=
Telemetry
.
getSnapshotForHistograms
(
"
main
"
false
true
)
.
parent
;
keyedSnapshot
=
Telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
false
true
)
.
parent
;
Assert
.
ok
(
!
(
COUNT_ID
in
snapshot
)
"
test
histogram
should
not
be
snapshotted
"
)
;
Assert
.
ok
(
!
(
KEYED_ID
in
keyedSnapshot
)
"
test
keyed
histogram
should
not
be
snapshotted
"
)
;
}
)
;
add_task
(
function
test_scalar_filtering
(
)
{
const
COUNT_ID
=
"
telemetry
.
test
.
unsigned_int_kind
"
;
const
KEYED_ID
=
"
telemetry
.
test
.
keyed_unsigned_int
"
;
Telemetry
.
scalarSet
(
COUNT_ID
2
)
;
Telemetry
.
keyedScalarSet
(
KEYED_ID
"
a
"
2
)
;
let
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
false
)
.
parent
;
let
keyedSnapshot
=
Telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
false
false
)
.
parent
;
Assert
.
ok
(
COUNT_ID
in
snapshot
"
test
scalars
should
be
snapshotted
"
)
;
Assert
.
ok
(
KEYED_ID
in
keyedSnapshot
"
test
keyed
scalars
should
be
snapshotted
"
)
;
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
true
)
.
parent
;
keyedSnapshot
=
Telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
false
true
)
.
parent
;
Assert
.
ok
(
!
(
COUNT_ID
in
snapshot
)
"
test
scalars
should
not
be
snapshotted
"
)
;
Assert
.
ok
(
!
(
KEYED_ID
in
keyedSnapshot
)
"
test
keyed
scalars
should
not
be
snapshotted
"
)
;
}
)
;
add_task
(
async
function
stopServer
(
)
{
await
PingServer
.
stop
(
)
;
}
)
;
