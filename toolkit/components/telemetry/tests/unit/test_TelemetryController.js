Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ClientID
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryArchive
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
const
PING_FORMAT_VERSION
=
4
;
const
DELETION_PING_TYPE
=
"
deletion
"
;
const
TEST_PING_TYPE
=
"
test
-
ping
-
type
"
;
const
PLATFORM_VERSION
=
"
1
.
9
.
2
"
;
const
APP_VERSION
=
"
1
"
;
const
APP_NAME
=
"
XPCShell
"
;
const
PREF_BRANCH
=
"
toolkit
.
telemetry
.
"
;
const
PREF_ENABLED
=
PREF_BRANCH
+
"
enabled
"
;
const
PREF_ARCHIVE_ENABLED
=
PREF_BRANCH
+
"
archive
.
enabled
"
;
const
PREF_FHR_UPLOAD_ENABLED
=
"
datareporting
.
healthreport
.
uploadEnabled
"
;
const
PREF_UNIFIED
=
PREF_BRANCH
+
"
unified
"
;
var
gClientID
=
null
;
function
sendPing
(
aSendClientId
aSendEnvironment
)
{
if
(
PingServer
.
started
)
{
TelemetrySend
.
setServer
(
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
}
else
{
TelemetrySend
.
setServer
(
"
http
:
/
/
doesnotexist
"
)
;
}
let
options
=
{
addClientId
:
aSendClientId
addEnvironment
:
aSendEnvironment
}
;
return
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
options
)
;
}
function
checkPingFormat
(
aPing
aType
aHasClientId
aHasEnvironment
)
{
const
MANDATORY_PING_FIELDS
=
[
"
type
"
"
id
"
"
creationDate
"
"
version
"
"
application
"
"
payload
"
]
;
const
APPLICATION_TEST_DATA
=
{
buildId
:
gAppInfo
.
appBuildID
name
:
APP_NAME
version
:
APP_VERSION
displayVersion
:
AppConstants
.
MOZ_APP_VERSION_DISPLAY
vendor
:
"
Mozilla
"
platformVersion
:
PLATFORM_VERSION
xpcomAbi
:
"
noarch
-
spidermonkey
"
}
;
for
(
let
f
of
MANDATORY_PING_FIELDS
)
{
Assert
.
ok
(
f
in
aPing
f
+
"
must
be
available
.
"
)
;
}
Assert
.
equal
(
aPing
.
type
aType
"
The
ping
must
have
the
correct
type
.
"
)
;
Assert
.
equal
(
aPing
.
version
PING_FORMAT_VERSION
"
The
ping
must
have
the
correct
version
.
"
)
;
for
(
let
f
in
APPLICATION_TEST_DATA
)
{
Assert
.
equal
(
aPing
.
application
[
f
]
APPLICATION_TEST_DATA
[
f
]
f
+
"
must
have
the
correct
value
.
"
)
;
}
Assert
.
ok
(
"
architecture
"
in
aPing
.
application
"
The
application
section
must
have
an
architecture
field
.
"
)
;
Assert
.
ok
(
"
channel
"
in
aPing
.
application
"
The
application
section
must
have
a
channel
field
.
"
)
;
Assert
.
equal
(
"
clientId
"
in
aPing
aHasClientId
)
;
Assert
.
equal
(
"
environment
"
in
aPing
aHasEnvironment
)
;
}
add_task
(
function
*
test_setup
(
)
{
do_get_profile
(
)
;
loadAddonManager
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
.
9
.
2
"
)
;
yield
setEmptyPrefWatchlist
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_ENABLED
true
)
;
Services
.
prefs
.
setBoolPref
(
PREF_FHR_UPLOAD_ENABLED
true
)
;
yield
new
Promise
(
resolve
=
>
Telemetry
.
asyncFetchTelemetryData
(
wrapWithExceptionHandler
(
resolve
)
)
)
;
}
)
;
add_task
(
function
*
asyncSetup
(
)
{
yield
TelemetryController
.
testSetup
(
)
;
}
)
;
add_task
(
function
*
test_overwritePing
(
)
{
let
ping
=
{
id
:
"
foo
"
}
;
yield
TelemetryStorage
.
savePing
(
ping
true
)
;
yield
TelemetryStorage
.
savePing
(
ping
false
)
;
yield
TelemetryStorage
.
cleanupPingFile
(
ping
)
;
}
)
;
add_task
(
function
*
test_simplePing
(
)
{
PingServer
.
start
(
)
;
Preferences
.
set
(
TelemetryController
.
Constants
.
PREF_SERVER
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
yield
sendPing
(
false
false
)
;
let
request
=
yield
PingServer
.
promiseNextRequest
(
)
;
Assert
.
notEqual
(
request
.
queryString
"
"
)
;
let
params
=
request
.
queryString
.
split
(
"
&
"
)
;
Assert
.
ok
(
params
.
find
(
p
=
>
p
=
=
(
"
v
=
"
+
PING_FORMAT_VERSION
)
)
)
;
let
ping
=
decodeRequestPayload
(
request
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
false
false
)
;
}
)
;
add_task
(
function
*
test_disableDataUpload
(
)
{
const
isUnified
=
Preferences
.
get
(
PREF_UNIFIED
false
)
;
if
(
!
isUnified
)
{
return
;
}
Preferences
.
set
(
PREF_FHR_UPLOAD_ENABLED
false
)
;
let
ping
=
yield
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
DELETION_PING_TYPE
true
false
)
;
yield
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
Preferences
.
set
(
PREF_FHR_UPLOAD_ENABLED
true
)
;
yield
PingServer
.
stop
(
)
;
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
)
;
Preferences
.
set
(
PREF_FHR_UPLOAD_ENABLED
false
)
;
yield
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
yield
TelemetryStorage
.
shutdown
(
)
;
yield
TelemetryController
.
testReset
(
)
;
let
pendingPings
=
yield
TelemetryStorage
.
loadPendingPingList
(
)
;
Assert
.
equal
(
pendingPings
.
length
1
"
All
the
pending
pings
but
the
deletion
ping
should
have
been
deleted
"
)
;
PingServer
.
start
(
)
;
Preferences
.
set
(
TelemetryController
.
Constants
.
PREF_SERVER
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
yield
TelemetrySend
.
shutdown
(
)
;
yield
TelemetryController
.
testReset
(
)
;
ping
=
yield
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
DELETION_PING_TYPE
true
false
)
;
yield
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
Preferences
.
set
(
PREF_FHR_UPLOAD_ENABLED
true
)
;
}
)
;
add_task
(
function
*
test_pingHasClientId
(
)
{
const
PREF_CACHED_CLIENTID
=
"
toolkit
.
telemetry
.
cachedClientID
"
;
Preferences
.
reset
(
PREF_CACHED_CLIENTID
)
;
yield
TelemetryController
.
testShutdown
(
)
;
yield
ClientID
.
_reset
(
)
;
yield
TelemetryStorage
.
testClearPendingPings
(
)
;
let
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_PING_SUBMISSION_WAITING_CLIENTID
"
)
;
h
.
clear
(
)
;
let
promisePingSetup
=
TelemetryController
.
testReset
(
)
;
yield
sendPing
(
true
false
)
;
Assert
.
equal
(
h
.
snapshot
(
)
.
sum
1
"
We
must
have
a
ping
waiting
for
the
clientId
early
during
startup
.
"
)
;
yield
promisePingSetup
;
let
ping
=
yield
PingServer
.
promiseNextPing
(
)
;
gClientID
=
yield
ClientID
.
getClientID
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
The
correct
clientId
must
be
reported
.
"
)
;
yield
TelemetryController
.
testShutdown
(
)
;
yield
TelemetryStorage
.
testClearPendingPings
(
)
;
h
.
clear
(
)
;
promisePingSetup
=
TelemetryController
.
testReset
(
)
;
yield
sendPing
(
true
false
)
;
yield
promisePingSetup
;
Assert
.
equal
(
h
.
snapshot
(
)
.
sum
0
"
We
must
have
used
the
cached
clientId
.
"
)
;
ping
=
yield
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
Telemetry
should
report
the
correct
cached
clientId
.
"
)
;
Preferences
.
reset
(
PREF_CACHED_CLIENTID
)
;
yield
TelemetryController
.
testShutdown
(
)
;
yield
TelemetryStorage
.
testClearPendingPings
(
)
;
yield
TelemetryController
.
testReset
(
)
;
yield
sendPing
(
true
false
)
;
ping
=
yield
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
The
correct
clientId
must
be
reported
.
"
)
;
Assert
.
equal
(
h
.
snapshot
(
)
.
sum
0
"
No
ping
should
have
been
waiting
for
a
clientId
.
"
)
;
}
)
;
add_task
(
function
*
test_pingHasEnvironment
(
)
{
yield
sendPing
(
false
true
)
;
let
ping
=
yield
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
false
true
)
;
Assert
.
equal
(
ping
.
application
.
buildId
ping
.
environment
.
build
.
buildId
)
;
}
)
;
add_task
(
function
*
test_pingHasEnvironmentAndClientId
(
)
{
yield
sendPing
(
true
true
)
;
let
ping
=
yield
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
Assert
.
equal
(
ping
.
application
.
buildId
ping
.
environment
.
build
.
buildId
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
The
correct
clientId
must
be
reported
.
"
)
;
}
)
;
add_task
(
function
*
test_archivePings
(
)
{
const
ARCHIVE_PATH
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
datareporting
"
"
archived
"
)
;
let
now
=
new
Date
(
2009
10
18
12
0
0
)
;
fakeNow
(
now
)
;
const
isUnified
=
Preferences
.
get
(
PREF_UNIFIED
false
)
;
const
uploadPref
=
isUnified
?
PREF_FHR_UPLOAD_ENABLED
:
PREF_ENABLED
;
Preferences
.
set
(
uploadPref
false
)
;
if
(
isUnified
)
{
let
ping
=
yield
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
DELETION_PING_TYPE
true
false
)
;
}
PingServer
.
registerPingHandler
(
(
)
=
>
Assert
.
ok
(
false
"
Telemetry
must
not
send
pings
if
not
allowed
to
.
"
)
)
;
let
pingId
=
yield
sendPing
(
true
true
)
;
let
ping
=
yield
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
equal
(
ping
.
id
pingId
"
TelemetryController
should
still
archive
pings
.
"
)
;
now
=
new
Date
(
2010
10
18
12
0
0
)
;
fakeNow
(
now
)
;
Preferences
.
set
(
PREF_ARCHIVE_ENABLED
false
)
;
pingId
=
yield
sendPing
(
true
true
)
;
let
promise
=
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
ok
(
(
yield
promiseRejects
(
promise
)
)
"
TelemetryController
should
not
archive
pings
if
the
archive
pref
is
disabled
.
"
)
;
Preferences
.
set
(
uploadPref
true
)
;
Preferences
.
set
(
PREF_ARCHIVE_ENABLED
true
)
;
now
=
new
Date
(
2014
6
18
22
0
0
)
;
fakeNow
(
now
)
;
PingServer
.
resetPingHandler
(
)
;
pingId
=
yield
sendPing
(
true
true
)
;
yield
PingServer
.
promiseNextPing
(
)
;
ping
=
yield
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
equal
(
ping
.
id
pingId
"
TelemetryController
should
still
archive
pings
if
ping
upload
is
enabled
.
"
)
;
}
)
;
add_task
(
function
*
test_midnightPingSendFuzzing
(
)
{
const
fuzzingDelay
=
60
*
60
*
1000
;
fakeMidnightPingFuzzingDelay
(
fuzzingDelay
)
;
let
now
=
new
Date
(
2030
5
1
11
0
0
)
;
fakeNow
(
now
)
;
let
waitForTimer
=
(
)
=
>
new
Promise
(
resolve
=
>
{
fakePingSendTimer
(
(
callback
timeout
)
=
>
{
resolve
(
[
callback
timeout
]
)
;
}
(
)
=
>
{
}
)
;
}
)
;
PingServer
.
clearRequests
(
)
;
yield
TelemetryController
.
testReset
(
)
;
now
=
new
Date
(
2030
5
2
0
40
0
)
;
fakeNow
(
now
)
;
PingServer
.
registerPingHandler
(
(
req
res
)
=
>
{
Assert
.
ok
(
false
"
No
ping
should
be
received
yet
.
"
)
;
}
)
;
let
timerPromise
=
waitForTimer
(
)
;
yield
sendPing
(
true
true
)
;
let
[
timerCallback
timerTimeout
]
=
yield
timerPromise
;
Assert
.
ok
(
!
!
timerCallback
)
;
Assert
.
deepEqual
(
futureDate
(
now
timerTimeout
)
new
Date
(
2030
5
2
1
0
0
)
)
;
now
=
new
Date
(
2030
5
2
0
59
59
)
;
fakeNow
(
now
)
;
timerPromise
=
waitForTimer
(
)
;
yield
sendPing
(
true
true
)
;
[
timerCallback
timerTimeout
]
=
yield
timerPromise
;
Assert
.
deepEqual
(
timerTimeout
1
*
1000
)
;
PingServer
.
resetPingHandler
(
)
;
now
=
futureDate
(
now
timerTimeout
)
;
fakeNow
(
now
)
;
yield
timerCallback
(
)
;
const
pings
=
yield
PingServer
.
promiseNextPings
(
2
)
;
for
(
let
ping
of
pings
)
{
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
}
yield
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
now
=
futureDate
(
now
5
*
60
*
1000
)
;
yield
sendPing
(
true
true
)
;
let
ping
=
yield
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
yield
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
now
=
fakeNow
(
2030
5
3
23
59
0
)
;
yield
sendPing
(
true
true
)
;
ping
=
yield
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
yield
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
fakeMidnightPingFuzzingDelay
(
0
)
;
fakePingSendTimer
(
(
)
=
>
{
}
(
)
=
>
{
}
)
;
}
)
;
add_task
(
function
*
test_changePingAfterSubmission
(
)
{
let
payload
=
{
canary
:
"
test
"
}
;
let
pingPromise
=
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
payload
options
)
;
payload
.
canary
=
"
changed
"
;
const
pingId
=
yield
pingPromise
;
let
archivedCopy
=
yield
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
equal
(
archivedCopy
.
payload
.
canary
"
test
"
"
The
payload
must
not
be
changed
after
being
submitted
.
"
)
;
}
)
;
add_task
(
function
*
test_telemetryEnabledUnexpectedValue
(
)
{
let
defaultPrefBranch
=
Services
.
prefs
.
getDefaultBranch
(
null
)
;
defaultPrefBranch
.
deleteBranch
(
PREF_ENABLED
)
;
Preferences
.
set
(
PREF_ENABLED
"
false
"
)
;
yield
TelemetryController
.
testReset
(
)
;
Assert
.
equal
(
Telemetry
.
canRecordExtended
false
"
Invalid
values
must
not
enable
Telemetry
recording
.
"
)
;
defaultPrefBranch
.
deleteBranch
(
PREF_ENABLED
)
;
Preferences
.
set
(
PREF_ENABLED
true
)
;
yield
TelemetryController
.
testReset
(
)
;
Assert
.
equal
(
Telemetry
.
canRecordExtended
true
"
True
must
enable
Telemetry
recording
.
"
)
;
Preferences
.
set
(
PREF_ENABLED
false
)
;
yield
TelemetryController
.
testReset
(
)
;
Assert
.
equal
(
Telemetry
.
canRecordExtended
false
"
False
must
disable
Telemetry
recording
.
"
)
;
}
)
;
add_task
(
function
*
test_telemetryCleanFHRDatabase
(
)
{
const
FHR_DBNAME_PREF
=
"
datareporting
.
healthreport
.
dbName
"
;
const
CUSTOM_DB_NAME
=
"
unlikely
.
to
.
be
.
used
.
sqlite
"
;
const
DEFAULT_DB_NAME
=
"
healthreport
.
sqlite
"
;
const
CUSTOM_DB_PATHS
=
[
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CUSTOM_DB_NAME
)
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CUSTOM_DB_NAME
+
"
-
wal
"
)
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CUSTOM_DB_NAME
+
"
-
shm
"
)
]
;
Preferences
.
set
(
FHR_DBNAME_PREF
CUSTOM_DB_NAME
)
;
for
(
let
dbFilePath
of
CUSTOM_DB_PATHS
)
{
yield
OS
.
File
.
writeAtomic
(
dbFilePath
"
some
data
"
)
;
}
yield
TelemetryStorage
.
removeFHRDatabase
(
)
;
for
(
let
dbFilePath
of
CUSTOM_DB_PATHS
)
{
Assert
.
ok
(
!
(
yield
OS
.
File
.
exists
(
dbFilePath
)
)
"
The
DB
must
not
be
on
the
disk
anymore
:
"
+
dbFilePath
)
;
}
yield
TelemetryStorage
.
removeFHRDatabase
(
)
;
Preferences
.
reset
(
FHR_DBNAME_PREF
)
;
const
DEFAULT_DB_PATHS
=
[
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
DEFAULT_DB_NAME
)
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
DEFAULT_DB_NAME
+
"
-
wal
"
)
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
DEFAULT_DB_NAME
+
"
-
shm
"
)
]
;
for
(
let
dbFilePath
of
DEFAULT_DB_PATHS
)
{
yield
OS
.
File
.
writeAtomic
(
dbFilePath
"
some
data
"
)
;
}
yield
TelemetryStorage
.
removeFHRDatabase
(
)
;
for
(
let
dbFilePath
of
DEFAULT_DB_PATHS
)
{
Assert
.
ok
(
!
(
yield
OS
.
File
.
exists
(
dbFilePath
)
)
"
The
DB
must
not
be
on
the
disk
anymore
:
"
+
dbFilePath
)
;
}
}
)
;
add_task
(
function
*
stopServer
(
)
{
yield
PingServer
.
stop
(
)
;
}
)
;
