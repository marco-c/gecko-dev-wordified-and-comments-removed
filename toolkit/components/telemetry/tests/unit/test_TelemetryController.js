const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
const
{
ClientID
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ClientID
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryArchive
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
const
{
Preferences
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
ContentTaskUtils
.
jsm
"
this
)
;
const
PING_FORMAT_VERSION
=
4
;
const
OPTOUT_PING_TYPE
=
"
optout
"
;
const
TEST_PING_TYPE
=
"
test
-
ping
-
type
"
;
const
PLATFORM_VERSION
=
"
1
.
9
.
2
"
;
const
APP_VERSION
=
"
1
"
;
const
APP_NAME
=
"
XPCShell
"
;
var
gClientID
=
null
;
XPCOMUtils
.
defineLazyGetter
(
this
"
DATAREPORTING_PATH
"
function
(
)
{
return
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
datareporting
"
)
;
}
)
;
function
sendPing
(
aSendClientId
aSendEnvironment
)
{
if
(
PingServer
.
started
)
{
TelemetrySend
.
setServer
(
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
}
else
{
TelemetrySend
.
setServer
(
"
http
:
/
/
doesnotexist
"
)
;
}
let
options
=
{
addClientId
:
aSendClientId
addEnvironment
:
aSendEnvironment
}
;
return
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
options
)
;
}
function
checkPingFormat
(
aPing
aType
aHasClientId
aHasEnvironment
)
{
const
MANDATORY_PING_FIELDS
=
[
"
type
"
"
id
"
"
creationDate
"
"
version
"
"
application
"
"
payload
"
]
;
const
APPLICATION_TEST_DATA
=
{
buildId
:
gAppInfo
.
appBuildID
name
:
APP_NAME
version
:
APP_VERSION
displayVersion
:
AppConstants
.
MOZ_APP_VERSION_DISPLAY
vendor
:
"
Mozilla
"
platformVersion
:
PLATFORM_VERSION
xpcomAbi
:
"
noarch
-
spidermonkey
"
}
;
for
(
let
f
of
MANDATORY_PING_FIELDS
)
{
Assert
.
ok
(
f
in
aPing
f
+
"
must
be
available
.
"
)
;
}
Assert
.
equal
(
aPing
.
type
aType
"
The
ping
must
have
the
correct
type
.
"
)
;
Assert
.
equal
(
aPing
.
version
PING_FORMAT_VERSION
"
The
ping
must
have
the
correct
version
.
"
)
;
for
(
let
f
in
APPLICATION_TEST_DATA
)
{
Assert
.
equal
(
aPing
.
application
[
f
]
APPLICATION_TEST_DATA
[
f
]
f
+
"
must
have
the
correct
value
.
"
)
;
}
Assert
.
ok
(
"
architecture
"
in
aPing
.
application
"
The
application
section
must
have
an
architecture
field
.
"
)
;
Assert
.
ok
(
"
channel
"
in
aPing
.
application
"
The
application
section
must
have
a
channel
field
.
"
)
;
Assert
.
equal
(
"
clientId
"
in
aPing
aHasClientId
)
;
Assert
.
equal
(
"
environment
"
in
aPing
aHasEnvironment
)
;
}
add_task
(
async
function
test_setup
(
)
{
do_get_profile
(
)
;
loadAddonManager
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
.
9
.
2
"
)
;
finishAddonManagerStartup
(
)
;
fakeIntlReady
(
)
;
await
setEmptyPrefWatchlist
(
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
new
Promise
(
resolve
=
>
Telemetry
.
asyncFetchTelemetryData
(
wrapWithExceptionHandler
(
resolve
)
)
)
;
}
)
;
add_task
(
async
function
asyncSetup
(
)
{
await
TelemetryController
.
testSetup
(
)
;
}
)
;
add_task
(
async
function
test_overwritePing
(
)
{
let
ping
=
{
id
:
"
foo
"
}
;
await
TelemetryStorage
.
savePing
(
ping
true
)
;
await
TelemetryStorage
.
savePing
(
ping
false
)
;
await
TelemetryStorage
.
cleanupPingFile
(
ping
)
;
}
)
;
add_task
(
async
function
test_simplePing
(
)
{
PingServer
.
start
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
Server
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
await
sendPing
(
false
false
)
;
let
request
=
await
PingServer
.
promiseNextRequest
(
)
;
Assert
.
notEqual
(
request
.
queryString
"
"
)
;
let
params
=
request
.
queryString
.
split
(
"
&
"
)
;
Assert
.
ok
(
params
.
find
(
p
=
>
p
=
=
(
"
v
=
"
+
PING_FORMAT_VERSION
)
)
)
;
let
ping
=
decodeRequestPayload
(
request
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
false
false
)
;
}
)
;
add_task
(
async
function
test_disableDataUpload
(
)
{
const
OPTIN_PROBE
=
"
telemetry
.
data_upload_optin
"
;
const
isUnified
=
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
if
(
!
isUnified
)
{
return
;
}
let
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
)
.
parent
;
Assert
.
ok
(
!
(
OPTIN_PROBE
in
snapshot
)
"
Data
optin
scalar
should
not
be
set
at
start
"
)
;
await
sendPing
(
true
false
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
let
firstClientId
=
ping
.
clientId
;
Assert
.
ok
(
firstClientId
"
Test
ping
needs
a
client
ID
"
)
;
Assert
.
notEqual
(
TelemetryUtils
.
knownClientID
firstClientId
"
Client
ID
should
be
valid
and
random
"
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
OPTOUT_PING_TYPE
false
false
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
)
.
parent
;
Assert
.
ok
(
!
(
OPTIN_PROBE
in
snapshot
)
"
Data
optin
scalar
should
not
be
set
after
optout
"
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
const
scalarSnapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
)
;
return
Object
.
keys
(
scalarSnapshot
)
.
includes
(
"
parent
"
)
&
&
OPTIN_PROBE
in
scalarSnapshot
.
parent
;
}
)
;
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
)
.
parent
;
Assert
.
ok
(
snapshot
[
OPTIN_PROBE
]
"
Enabling
data
upload
should
set
optin
probe
"
)
;
await
PingServer
.
stop
(
)
;
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
{
}
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
await
TelemetryStorage
.
shutdown
(
)
;
await
TelemetryController
.
testReset
(
)
;
let
pendingPings
=
await
TelemetryStorage
.
loadPendingPingList
(
)
;
Assert
.
equal
(
pendingPings
.
length
0
"
All
the
pending
pings
should
have
been
deleted
including
the
optout
ping
"
)
;
PingServer
.
start
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
Server
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
await
TelemetrySend
.
shutdown
(
)
;
await
TelemetryController
.
testReset
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
sendPing
(
true
false
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
notEqual
(
TelemetryUtils
.
knownClientID
ping
.
clientId
"
Client
ID
should
be
reset
to
a
random
value
"
)
;
Assert
.
notEqual
(
firstClientId
ping
.
clientId
"
Client
ID
should
be
different
from
the
previous
value
"
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
}
)
;
add_task
(
async
function
test_pingHasClientId
(
)
{
Preferences
.
reset
(
TelemetryUtils
.
Preferences
.
CachedClientId
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
ClientID
.
_reset
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
let
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_PING_SUBMISSION_WAITING_CLIENTID
"
)
;
h
.
clear
(
)
;
let
promisePingSetup
=
TelemetryController
.
testReset
(
)
;
await
sendPing
(
true
false
)
;
Assert
.
equal
(
h
.
snapshot
(
)
.
sum
1
"
We
must
have
a
ping
waiting
for
the
clientId
early
during
startup
.
"
)
;
await
promisePingSetup
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
gClientID
=
await
ClientID
.
getClientID
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
The
correct
clientId
must
be
reported
.
"
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
h
.
clear
(
)
;
promisePingSetup
=
TelemetryController
.
testReset
(
)
;
await
sendPing
(
true
false
)
;
await
promisePingSetup
;
Assert
.
equal
(
h
.
snapshot
(
)
.
sum
0
"
We
must
have
used
the
cached
clientId
.
"
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
Telemetry
should
report
the
correct
cached
clientId
.
"
)
;
Preferences
.
reset
(
TelemetryUtils
.
Preferences
.
CachedClientId
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
await
TelemetryController
.
testReset
(
)
;
await
sendPing
(
true
false
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
false
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
The
correct
clientId
must
be
reported
.
"
)
;
Assert
.
equal
(
h
.
snapshot
(
)
.
sum
0
"
No
ping
should
have
been
waiting
for
a
clientId
.
"
)
;
}
)
;
add_task
(
async
function
test_pingHasEnvironment
(
)
{
await
sendPing
(
false
true
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
false
true
)
;
Assert
.
equal
(
ping
.
application
.
buildId
ping
.
environment
.
build
.
buildId
)
;
}
)
;
add_task
(
async
function
test_pingHasEnvironmentAndClientId
(
)
{
await
sendPing
(
true
true
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
Assert
.
equal
(
ping
.
application
.
buildId
ping
.
environment
.
build
.
buildId
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
"
The
correct
clientId
must
be
reported
.
"
)
;
}
)
;
add_task
(
async
function
test_archivePings
(
)
{
let
now
=
new
Date
(
2009
10
18
12
0
0
)
;
fakeNow
(
now
)
;
const
isUnified
=
Preferences
.
get
(
TelemetryUtils
.
Preferences
.
Unified
false
)
;
const
uploadPref
=
isUnified
?
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
:
TelemetryUtils
.
Preferences
.
TelemetryEnabled
;
Preferences
.
set
(
uploadPref
false
)
;
if
(
isUnified
)
{
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
OPTOUT_PING_TYPE
false
false
)
;
}
PingServer
.
registerPingHandler
(
(
)
=
>
Assert
.
ok
(
false
"
Telemetry
must
not
send
pings
if
not
allowed
to
.
"
)
)
;
let
pingId
=
await
sendPing
(
true
true
)
;
let
ping
=
await
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
equal
(
ping
.
id
pingId
"
TelemetryController
should
still
archive
pings
.
"
)
;
now
=
new
Date
(
2010
10
18
12
0
0
)
;
fakeNow
(
now
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
ArchiveEnabled
false
)
;
pingId
=
await
sendPing
(
true
true
)
;
let
promise
=
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
ok
(
(
await
promiseRejects
(
promise
)
)
"
TelemetryController
should
not
archive
pings
if
the
archive
pref
is
disabled
.
"
)
;
Preferences
.
set
(
uploadPref
true
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
ArchiveEnabled
true
)
;
now
=
new
Date
(
2014
6
18
22
0
0
)
;
fakeNow
(
now
)
;
PingServer
.
resetPingHandler
(
)
;
pingId
=
await
sendPing
(
true
true
)
;
await
PingServer
.
promiseNextPing
(
)
;
ping
=
await
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
equal
(
ping
.
id
pingId
"
TelemetryController
should
still
archive
pings
if
ping
upload
is
enabled
.
"
)
;
}
)
;
add_task
(
async
function
test_midnightPingSendFuzzing
(
)
{
const
fuzzingDelay
=
60
*
60
*
1000
;
fakeMidnightPingFuzzingDelay
(
fuzzingDelay
)
;
let
now
=
new
Date
(
2030
5
1
11
0
0
)
;
fakeNow
(
now
)
;
let
waitForTimer
=
(
)
=
>
new
Promise
(
resolve
=
>
{
fakePingSendTimer
(
(
callback
timeout
)
=
>
{
resolve
(
[
callback
timeout
]
)
;
}
(
)
=
>
{
}
)
;
}
)
;
PingServer
.
clearRequests
(
)
;
await
TelemetryController
.
testReset
(
)
;
now
=
new
Date
(
2030
5
2
0
40
0
)
;
fakeNow
(
now
)
;
PingServer
.
registerPingHandler
(
(
req
res
)
=
>
{
Assert
.
ok
(
false
"
No
ping
should
be
received
yet
.
"
)
;
}
)
;
let
timerPromise
=
waitForTimer
(
)
;
await
sendPing
(
true
true
)
;
let
[
timerCallback
timerTimeout
]
=
await
timerPromise
;
Assert
.
ok
(
!
!
timerCallback
)
;
Assert
.
deepEqual
(
futureDate
(
now
timerTimeout
)
new
Date
(
2030
5
2
1
0
0
)
)
;
now
=
new
Date
(
2030
5
2
0
59
59
)
;
fakeNow
(
now
)
;
timerPromise
=
waitForTimer
(
)
;
await
sendPing
(
true
true
)
;
[
timerCallback
timerTimeout
]
=
await
timerPromise
;
Assert
.
deepEqual
(
timerTimeout
1
*
1000
)
;
PingServer
.
resetPingHandler
(
)
;
now
=
futureDate
(
now
timerTimeout
)
;
fakeNow
(
now
)
;
await
timerCallback
(
)
;
const
pings
=
await
PingServer
.
promiseNextPings
(
2
)
;
for
(
let
ping
of
pings
)
{
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
}
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
now
=
futureDate
(
now
5
*
60
*
1000
)
;
await
sendPing
(
true
true
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
now
=
fakeNow
(
2030
5
3
23
59
0
)
;
await
sendPing
(
true
true
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
TEST_PING_TYPE
true
true
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
fakeMidnightPingFuzzingDelay
(
0
)
;
fakePingSendTimer
(
(
)
=
>
{
}
(
)
=
>
{
}
)
;
}
)
;
add_task
(
async
function
test_changePingAfterSubmission
(
)
{
let
payload
=
{
canary
:
"
test
"
}
;
let
pingPromise
=
TelemetryController
.
submitExternalPing
(
TEST_PING_TYPE
payload
)
;
payload
.
canary
=
"
changed
"
;
const
pingId
=
await
pingPromise
;
let
archivedCopy
=
await
TelemetryArchive
.
promiseArchivedPingById
(
pingId
)
;
Assert
.
equal
(
archivedCopy
.
payload
.
canary
"
test
"
"
The
payload
must
not
be
changed
after
being
submitted
.
"
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
Services
.
prefs
.
getBoolPref
(
TelemetryUtils
.
Preferences
.
Unified
false
)
}
async
function
test_telemetryEnabledUnexpectedValue
(
)
{
let
defaultPrefBranch
=
Services
.
prefs
.
getDefaultBranch
(
null
)
;
defaultPrefBranch
.
deleteBranch
(
TelemetryUtils
.
Preferences
.
TelemetryEnabled
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
TelemetryEnabled
"
false
"
)
;
await
TelemetryController
.
testReset
(
)
;
Assert
.
equal
(
Telemetry
.
canRecordExtended
false
"
Invalid
values
must
not
enable
Telemetry
recording
.
"
)
;
defaultPrefBranch
.
deleteBranch
(
TelemetryUtils
.
Preferences
.
TelemetryEnabled
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
TelemetryEnabled
true
)
;
await
TelemetryController
.
testReset
(
)
;
Assert
.
equal
(
Telemetry
.
canRecordExtended
true
"
True
must
enable
Telemetry
recording
.
"
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
TelemetryEnabled
false
)
;
await
TelemetryController
.
testReset
(
)
;
Assert
.
equal
(
Telemetry
.
canRecordExtended
false
"
False
must
disable
Telemetry
recording
.
"
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
TelemetryEnabled
true
)
;
}
)
;
add_task
(
async
function
test_telemetryCleanFHRDatabase
(
)
{
const
FHR_DBNAME_PREF
=
"
datareporting
.
healthreport
.
dbName
"
;
const
CUSTOM_DB_NAME
=
"
unlikely
.
to
.
be
.
used
.
sqlite
"
;
const
DEFAULT_DB_NAME
=
"
healthreport
.
sqlite
"
;
const
CUSTOM_DB_PATHS
=
[
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CUSTOM_DB_NAME
)
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CUSTOM_DB_NAME
+
"
-
wal
"
)
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
CUSTOM_DB_NAME
+
"
-
shm
"
)
]
;
Preferences
.
set
(
FHR_DBNAME_PREF
CUSTOM_DB_NAME
)
;
for
(
let
dbFilePath
of
CUSTOM_DB_PATHS
)
{
await
OS
.
File
.
writeAtomic
(
dbFilePath
"
some
data
"
)
;
}
await
TelemetryStorage
.
removeFHRDatabase
(
)
;
for
(
let
dbFilePath
of
CUSTOM_DB_PATHS
)
{
Assert
.
ok
(
!
(
await
OS
.
File
.
exists
(
dbFilePath
)
)
"
The
DB
must
not
be
on
the
disk
anymore
:
"
+
dbFilePath
)
;
}
await
TelemetryStorage
.
removeFHRDatabase
(
)
;
Preferences
.
reset
(
FHR_DBNAME_PREF
)
;
const
DEFAULT_DB_PATHS
=
[
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
DEFAULT_DB_NAME
)
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
DEFAULT_DB_NAME
+
"
-
wal
"
)
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
DEFAULT_DB_NAME
+
"
-
shm
"
)
]
;
for
(
let
dbFilePath
of
DEFAULT_DB_PATHS
)
{
await
OS
.
File
.
writeAtomic
(
dbFilePath
"
some
data
"
)
;
}
await
TelemetryStorage
.
removeFHRDatabase
(
)
;
for
(
let
dbFilePath
of
DEFAULT_DB_PATHS
)
{
Assert
.
ok
(
!
(
await
OS
.
File
.
exists
(
dbFilePath
)
)
"
The
DB
must
not
be
on
the
disk
anymore
:
"
+
dbFilePath
)
;
}
}
)
;
add_task
(
async
function
test_sendNewProfile
(
)
{
if
(
gIsAndroid
|
|
(
AppConstants
.
platform
=
=
"
linux
"
&
&
OS
.
Constants
.
Sys
.
bits
=
=
32
)
)
{
return
;
}
const
NEWPROFILE_PING_TYPE
=
"
new
-
profile
"
;
const
PREF_NEWPROFILE_ENABLED
=
"
toolkit
.
telemetry
.
newProfilePing
.
enabled
"
;
const
PREF_NEWPROFILE_DELAY
=
"
toolkit
.
telemetry
.
newProfilePing
.
delay
"
;
let
resetTest
=
async
function
(
)
{
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
}
;
await
resetTest
(
)
;
const
stateFilePath
=
OS
.
Path
.
join
(
DATAREPORTING_PATH
"
session
-
state
.
json
"
)
;
await
OS
.
File
.
remove
(
stateFilePath
{
ignoreAbsent
:
true
}
)
;
Preferences
.
set
(
PREF_NEWPROFILE_DELAY
1
)
;
Preferences
.
set
(
PREF_NEWPROFILE_ENABLED
true
)
;
let
nextReq
=
PingServer
.
promiseNextRequest
(
)
;
await
TelemetryController
.
testReset
(
)
;
let
req
=
await
nextReq
;
let
ping
=
decodeRequestPayload
(
req
)
;
checkPingFormat
(
ping
NEWPROFILE_PING_TYPE
true
true
)
;
Assert
.
equal
(
ping
.
payload
.
reason
"
startup
"
"
The
new
-
profile
ping
generated
after
startup
must
have
the
correct
reason
"
)
;
Assert
.
throws
(
(
)
=
>
req
.
getHeader
(
"
X
-
PingSender
-
Version
"
)
/
NS_ERROR_NOT_AVAILABLE
/
"
Should
not
have
used
the
pingsender
.
"
)
;
await
resetTest
(
)
;
await
OS
.
File
.
remove
(
stateFilePath
{
ignoreAbsent
:
true
}
)
;
Preferences
.
reset
(
PREF_NEWPROFILE_DELAY
)
;
nextReq
=
PingServer
.
promiseNextRequest
(
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
req
=
await
nextReq
;
ping
=
decodeRequestPayload
(
req
)
;
checkPingFormat
(
ping
NEWPROFILE_PING_TYPE
true
true
)
;
Assert
.
equal
(
ping
.
payload
.
reason
"
shutdown
"
"
The
new
-
profile
ping
generated
at
shutdown
must
have
the
correct
reason
"
)
;
Assert
.
equal
(
req
.
getHeader
(
"
User
-
Agent
"
)
"
pingsender
/
1
.
0
"
"
Should
have
received
the
correct
user
agent
string
.
"
)
;
Assert
.
equal
(
req
.
getHeader
(
"
X
-
PingSender
-
Version
"
)
"
1
.
0
"
"
Should
have
received
the
correct
PingSender
version
string
.
"
)
;
await
resetTest
(
)
;
PingServer
.
registerPingHandler
(
(
)
=
>
Assert
.
ok
(
false
"
The
new
-
profile
ping
must
be
sent
only
on
new
profiles
.
"
)
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
resetTest
(
)
;
await
OS
.
File
.
remove
(
stateFilePath
{
ignoreAbsent
:
true
}
)
;
const
sessionState
=
{
sessionId
:
null
subsessionId
:
null
profileSubsessionCounter
:
3785
}
;
await
CommonUtils
.
writeJSON
(
sessionState
stateFilePath
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
Preferences
.
reset
(
PREF_NEWPROFILE_ENABLED
)
;
PingServer
.
resetPingHandler
(
)
;
}
)
;
add_task
(
async
function
test_pingRejection
(
)
{
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
sendPing
(
false
false
)
.
then
(
(
)
=
>
Assert
.
ok
(
false
"
Pings
submitted
after
shutdown
must
be
rejected
.
"
)
(
)
=
>
Assert
.
ok
(
true
"
Ping
submitted
after
shutdown
correctly
rejected
.
"
)
)
;
}
)
;
add_task
(
async
function
test_newCanRecordsMatchTheOld
(
)
{
Assert
.
equal
(
Telemetry
.
canRecordBase
Telemetry
.
canRecordReleaseData
"
Release
Data
is
the
new
way
to
say
Base
Collection
"
)
;
Assert
.
equal
(
Telemetry
.
canRecordExtended
Telemetry
.
canRecordPrereleaseData
"
Prerelease
Data
is
the
new
way
to
say
Extended
Collection
"
)
;
}
)
;
add_task
(
function
test_histogram_filtering
(
)
{
const
COUNT_ID
=
"
TELEMETRY_TEST_COUNT
"
;
const
KEYED_ID
=
"
TELEMETRY_TEST_KEYED_COUNT
"
;
const
count
=
Telemetry
.
getHistogramById
(
COUNT_ID
)
;
const
keyed
=
Telemetry
.
getKeyedHistogramById
(
KEYED_ID
)
;
count
.
add
(
1
)
;
keyed
.
add
(
"
a
"
1
)
;
let
snapshot
=
Telemetry
.
getSnapshotForHistograms
(
"
main
"
false
false
)
.
parent
;
let
keyedSnapshot
=
Telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
false
false
)
.
parent
;
Assert
.
ok
(
COUNT_ID
in
snapshot
"
test
histogram
should
be
snapshotted
"
)
;
Assert
.
ok
(
KEYED_ID
in
keyedSnapshot
"
test
keyed
histogram
should
be
snapshotted
"
)
;
snapshot
=
Telemetry
.
getSnapshotForHistograms
(
"
main
"
false
true
)
.
parent
;
keyedSnapshot
=
Telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
false
true
)
.
parent
;
Assert
.
ok
(
!
(
COUNT_ID
in
snapshot
)
"
test
histogram
should
not
be
snapshotted
"
)
;
Assert
.
ok
(
!
(
KEYED_ID
in
keyedSnapshot
)
"
test
keyed
histogram
should
not
be
snapshotted
"
)
;
}
)
;
add_task
(
function
test_scalar_filtering
(
)
{
const
COUNT_ID
=
"
telemetry
.
test
.
unsigned_int_kind
"
;
const
KEYED_ID
=
"
telemetry
.
test
.
keyed_unsigned_int
"
;
Telemetry
.
scalarSet
(
COUNT_ID
2
)
;
Telemetry
.
keyedScalarSet
(
KEYED_ID
"
a
"
2
)
;
let
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
false
)
.
parent
;
let
keyedSnapshot
=
Telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
false
false
)
.
parent
;
Assert
.
ok
(
COUNT_ID
in
snapshot
"
test
scalars
should
be
snapshotted
"
)
;
Assert
.
ok
(
KEYED_ID
in
keyedSnapshot
"
test
keyed
scalars
should
be
snapshotted
"
)
;
snapshot
=
Telemetry
.
getSnapshotForScalars
(
"
main
"
false
true
)
.
parent
;
keyedSnapshot
=
Telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
false
true
)
.
parent
;
Assert
.
ok
(
!
(
COUNT_ID
in
snapshot
)
"
test
scalars
should
not
be
snapshotted
"
)
;
Assert
.
ok
(
!
(
KEYED_ID
in
keyedSnapshot
)
"
test
keyed
scalars
should
not
be
snapshotted
"
)
;
}
)
;
add_task
(
async
function
stopServer
(
)
{
await
PingServer
.
stop
(
)
;
}
)
;
