const
INT_MAX
=
0x7FFFFFFF
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
function
numberRange
(
lower
upper
)
{
let
a
=
[
]
;
for
(
let
i
=
lower
;
i
<
upper
;
+
+
i
)
{
a
.
push
(
i
)
;
}
return
a
;
}
function
expect_fail
(
f
)
{
let
failed
=
false
;
try
{
f
(
)
;
failed
=
false
;
}
catch
(
e
)
{
failed
=
true
;
}
do_check_true
(
failed
)
;
}
function
expect_success
(
f
)
{
let
succeeded
=
false
;
try
{
f
(
)
;
succeeded
=
true
;
}
catch
(
e
)
{
succeeded
=
false
;
}
do_check_true
(
succeeded
)
;
}
function
compareHistograms
(
h1
h2
)
{
let
s1
=
h1
.
snapshot
(
)
;
let
s2
=
h2
.
snapshot
(
)
;
do_check_eq
(
s1
.
histogram_type
s2
.
histogram_type
)
;
do_check_eq
(
s1
.
min
s2
.
min
)
;
do_check_eq
(
s1
.
max
s2
.
max
)
;
do_check_eq
(
s1
.
sum
s2
.
sum
)
;
do_check_eq
(
s1
.
counts
.
length
s2
.
counts
.
length
)
;
for
(
let
i
=
0
;
i
<
s1
.
counts
.
length
;
i
+
+
)
do_check_eq
(
s1
.
counts
[
i
]
s2
.
counts
[
i
]
)
;
do_check_eq
(
s1
.
ranges
.
length
s2
.
ranges
.
length
)
;
for
(
let
i
=
0
;
i
<
s1
.
ranges
.
length
;
i
+
+
)
do_check_eq
(
s1
.
ranges
[
i
]
s2
.
ranges
[
i
]
)
;
}
function
check_histogram
(
histogram_type
name
min
max
bucket_count
)
{
var
h
=
Telemetry
.
getHistogramById
(
name
)
;
var
r
=
h
.
snapshot
(
)
.
ranges
;
var
sum
=
0
;
for
(
let
i
=
0
;
i
<
r
.
length
;
i
+
+
)
{
var
v
=
r
[
i
]
;
sum
+
=
v
;
h
.
add
(
v
)
;
}
var
s
=
h
.
snapshot
(
)
;
do_check_eq
(
sum
s
.
sum
)
;
for
(
let
i
of
s
.
counts
)
{
do_check_eq
(
i
1
)
;
}
var
hgrams
=
Telemetry
.
histogramSnapshots
let
gh
=
hgrams
[
name
]
do_check_eq
(
gh
.
histogram_type
histogram_type
)
;
do_check_eq
(
gh
.
min
min
)
do_check_eq
(
gh
.
max
max
)
h
.
add
(
false
)
;
h
.
add
(
true
)
;
s
=
h
.
snapshot
(
)
.
counts
;
do_check_eq
(
s
[
0
]
2
)
do_check_eq
(
s
[
1
]
2
)
h
.
clear
(
)
;
s
=
h
.
snapshot
(
)
;
for
(
var
i
of
s
.
counts
)
{
do_check_eq
(
i
0
)
;
}
do_check_eq
(
s
.
sum
0
)
;
h
.
add
(
0
)
;
h
.
add
(
1
)
;
var
c
=
h
.
snapshot
(
)
.
counts
;
do_check_eq
(
c
[
0
]
1
)
;
do_check_eq
(
c
[
1
]
1
)
;
}
add_task
(
{
skip_if
:
(
)
=
>
gIsAndroid
}
function
test_instantiate
(
)
{
const
ID
=
"
TELEMETRY_TEST_COUNT
"
;
let
h
=
Telemetry
.
getHistogramById
(
ID
)
;
h
.
add
(
1
)
;
let
snapshot
=
h
.
snapshot
(
)
;
let
subsession
=
Telemetry
.
snapshotSubsessionHistograms
(
)
;
Assert
.
equal
(
snapshot
.
sum
subsession
[
ID
]
.
sum
"
Histogram
and
subsession
histogram
sum
must
match
.
"
)
;
h
.
clear
(
)
;
}
)
;
add_task
(
async
function
test_parameterChecks
(
)
{
let
kinds
=
[
Telemetry
.
HISTOGRAM_EXPONENTIAL
Telemetry
.
HISTOGRAM_LINEAR
]
let
testNames
=
[
"
TELEMETRY_TEST_EXPONENTIAL
"
"
TELEMETRY_TEST_LINEAR
"
]
for
(
let
i
=
0
;
i
<
kinds
.
length
;
i
+
+
)
{
let
histogram_type
=
kinds
[
i
]
;
let
test_type
=
testNames
[
i
]
;
let
[
min
max
bucket_count
]
=
[
1
INT_MAX
-
1
10
]
check_histogram
(
histogram_type
test_type
min
max
bucket_count
)
;
}
}
)
;
add_task
(
async
function
test_parameterCounts
(
)
{
let
histogramIds
=
[
"
TELEMETRY_TEST_EXPONENTIAL
"
"
TELEMETRY_TEST_LINEAR
"
"
TELEMETRY_TEST_FLAG
"
"
TELEMETRY_TEST_CATEGORICAL
"
"
TELEMETRY_TEST_BOOLEAN
"
]
;
for
(
let
id
of
histogramIds
)
{
let
h
=
Telemetry
.
getHistogramById
(
id
)
;
h
.
clear
(
)
;
h
.
add
(
)
;
Assert
.
equal
(
h
.
snapshot
(
)
.
sum
0
"
Calling
add
(
)
without
a
value
should
only
log
an
error
.
"
)
;
h
.
clear
(
)
;
}
}
)
;
add_task
(
async
function
test_parameterCountsKeyed
(
)
{
let
histogramIds
=
[
"
TELEMETRY_TEST_KEYED_FLAG
"
"
TELEMETRY_TEST_KEYED_BOOLEAN
"
"
TELEMETRY_TEST_KEYED_EXPONENTIAL
"
"
TELEMETRY_TEST_KEYED_LINEAR
"
]
;
for
(
let
id
of
histogramIds
)
{
let
h
=
Telemetry
.
getKeyedHistogramById
(
id
)
;
h
.
clear
(
)
;
h
.
add
(
"
key
"
)
;
Assert
.
equal
(
h
.
snapshot
(
"
key
"
)
.
sum
0
"
Calling
add
(
'
key
'
)
without
a
value
should
only
log
an
error
.
"
)
;
h
.
clear
(
)
;
}
}
)
;
add_task
(
async
function
test_noSerialization
(
)
{
Telemetry
.
getHistogramById
(
"
NEWTAB_PAGE_PINNED_SITES_COUNT
"
)
;
do_check_false
(
"
NEWTAB_PAGE_PINNED_SITES_COUNT
"
in
Telemetry
.
histogramSnapshots
)
;
}
)
;
add_task
(
async
function
test_boolean_histogram
(
)
{
var
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_BOOLEAN
"
)
;
var
r
=
h
.
snapshot
(
)
.
ranges
;
do_check_eq
(
uneval
(
r
)
uneval
(
[
0
1
2
]
)
)
for
(
var
i
=
0
;
i
<
r
.
length
;
i
+
+
)
{
var
v
=
r
[
i
]
;
h
.
add
(
v
)
;
}
h
.
add
(
true
)
;
h
.
add
(
false
)
;
var
s
=
h
.
snapshot
(
)
;
do_check_eq
(
s
.
histogram_type
Telemetry
.
HISTOGRAM_BOOLEAN
)
;
do_check_eq
(
s
.
counts
[
2
]
0
)
;
do_check_eq
(
s
.
sum
3
)
;
do_check_eq
(
s
.
counts
[
0
]
2
)
;
}
)
;
add_task
(
async
function
test_flag_histogram
(
)
{
var
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_FLAG
"
)
;
var
r
=
h
.
snapshot
(
)
.
ranges
;
do_check_eq
(
uneval
(
r
)
uneval
(
[
0
1
2
]
)
)
;
var
c
=
h
.
snapshot
(
)
.
counts
;
var
s
=
h
.
snapshot
(
)
.
sum
;
do_check_eq
(
uneval
(
c
)
uneval
(
[
1
0
0
]
)
)
;
do_check_eq
(
s
0
)
;
h
.
add
(
1
)
;
var
c2
=
h
.
snapshot
(
)
.
counts
;
var
s2
=
h
.
snapshot
(
)
.
sum
;
do_check_eq
(
uneval
(
c2
)
uneval
(
[
0
1
0
]
)
)
;
do_check_eq
(
s2
1
)
;
h
.
add
(
1
)
;
var
c3
=
h
.
snapshot
(
)
.
counts
;
var
s3
=
h
.
snapshot
(
)
.
sum
;
do_check_eq
(
uneval
(
c3
)
uneval
(
[
0
1
0
]
)
)
;
do_check_eq
(
s3
1
)
;
do_check_eq
(
h
.
snapshot
(
)
.
histogram_type
Telemetry
.
HISTOGRAM_FLAG
)
;
}
)
;
add_task
(
async
function
test_count_histogram
(
)
{
let
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_COUNT2
"
)
;
let
s
=
h
.
snapshot
(
)
;
do_check_eq
(
uneval
(
s
.
ranges
)
uneval
(
[
0
1
2
]
)
)
;
do_check_eq
(
uneval
(
s
.
counts
)
uneval
(
[
0
0
0
]
)
)
;
do_check_eq
(
s
.
sum
0
)
;
h
.
add
(
)
;
s
=
h
.
snapshot
(
)
;
do_check_eq
(
uneval
(
s
.
counts
)
uneval
(
[
1
0
0
]
)
)
;
do_check_eq
(
s
.
sum
1
)
;
h
.
add
(
)
;
s
=
h
.
snapshot
(
)
;
do_check_eq
(
uneval
(
s
.
counts
)
uneval
(
[
2
0
0
]
)
)
;
do_check_eq
(
s
.
sum
2
)
;
}
)
;
add_task
(
async
function
test_categorical_histogram
(
)
{
let
h1
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_CATEGORICAL
"
)
;
for
(
let
v
of
[
"
CommonLabel
"
"
Label2
"
"
Label3
"
"
Label3
"
0
0
1
]
)
{
h1
.
add
(
v
)
;
}
for
(
let
s
of
[
"
"
"
Label4
"
"
1234
"
]
)
{
h1
.
add
(
s
)
;
}
let
expectedRanges
=
[
]
;
for
(
let
i
=
0
;
i
<
51
;
+
+
i
)
{
expectedRanges
.
push
(
i
)
;
}
let
snapshot
=
h1
.
snapshot
(
)
;
Assert
.
equal
(
snapshot
.
sum
6
)
;
Assert
.
deepEqual
(
snapshot
.
ranges
expectedRanges
)
;
Assert
.
deepEqual
(
snapshot
.
counts
.
slice
(
0
4
)
[
3
2
2
0
]
)
;
let
h2
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_CATEGORICAL_OPTOUT
"
)
;
for
(
let
v
of
[
"
CommonLabel
"
"
CommonLabel
"
"
Label4
"
"
Label5
"
"
Label6
"
0
1
]
)
{
h2
.
add
(
v
)
;
}
for
(
let
s
of
[
"
"
"
Label3
"
"
1234
"
]
)
{
h2
.
add
(
s
)
;
}
snapshot
=
h2
.
snapshot
(
)
;
Assert
.
equal
(
snapshot
.
sum
7
)
;
Assert
.
deepEqual
(
snapshot
.
ranges
expectedRanges
)
;
Assert
.
deepEqual
(
snapshot
.
counts
.
slice
(
0
5
)
[
3
2
1
1
0
]
)
;
let
h3
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_CATEGORICAL_NVALUES
"
)
;
for
(
let
v
of
[
"
CommonLabel
"
"
Label7
"
"
Label8
"
]
)
{
h3
.
add
(
v
)
;
}
expectedRanges
=
[
]
;
for
(
let
i
=
0
;
i
<
71
;
+
+
i
)
{
expectedRanges
.
push
(
i
)
;
}
snapshot
=
h3
.
snapshot
(
)
;
Assert
.
equal
(
snapshot
.
sum
3
)
;
Assert
.
equal
(
snapshot
.
ranges
.
length
expectedRanges
.
length
)
;
Assert
.
deepEqual
(
snapshot
.
ranges
expectedRanges
)
;
Assert
.
deepEqual
(
snapshot
.
counts
.
slice
(
0
4
)
[
1
1
1
0
]
)
;
}
)
;
add_task
(
async
function
test_add_error_behaviour
(
)
{
const
PLAIN_HISTOGRAMS_TO_TEST
=
[
"
TELEMETRY_TEST_FLAG
"
"
TELEMETRY_TEST_EXPONENTIAL
"
"
TELEMETRY_TEST_LINEAR
"
"
TELEMETRY_TEST_BOOLEAN
"
]
;
const
KEYED_HISTOGRAMS_TO_TEST
=
[
"
TELEMETRY_TEST_KEYED_FLAG
"
"
TELEMETRY_TEST_KEYED_COUNT
"
"
TELEMETRY_TEST_KEYED_BOOLEAN
"
]
;
for
(
let
hist
of
PLAIN_HISTOGRAMS_TO_TEST
)
{
const
returnValue
=
Telemetry
.
getHistogramById
(
hist
)
.
add
(
"
unexpected
-
value
"
)
;
Assert
.
strictEqual
(
returnValue
undefined
"
Adding
to
an
histogram
must
return
'
undefined
'
.
"
)
;
}
for
(
let
hist
of
KEYED_HISTOGRAMS_TO_TEST
)
{
const
returnValue
=
Telemetry
.
getKeyedHistogramById
(
hist
)
.
add
(
"
some
-
key
"
"
unexpected
-
value
"
)
;
Assert
.
strictEqual
(
returnValue
undefined
"
Adding
to
a
keyed
histogram
must
return
'
undefined
'
.
"
)
;
}
}
)
;
add_task
(
async
function
test_API_return_values
(
)
{
let
hist
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_LINEAR
"
)
;
let
keyedHist
=
Telemetry
.
getKeyedHistogramById
(
"
TELEMETRY_TEST_KEYED_COUNT
"
)
;
const
RETURN_VALUES
=
[
hist
.
clear
(
)
hist
.
add
(
1
)
keyedHist
.
clear
(
)
keyedHist
.
add
(
"
some
-
key
"
1
)
]
;
for
(
let
returnValue
of
RETURN_VALUES
)
{
Assert
.
strictEqual
(
returnValue
undefined
"
The
function
must
return
undefined
.
"
)
;
}
}
)
;
add_task
(
async
function
test_getHistogramById
(
)
{
try
{
Telemetry
.
getHistogramById
(
"
nonexistent
"
)
;
do_throw
(
"
This
can
'
t
happen
"
)
;
}
catch
(
e
)
{
}
var
h
=
Telemetry
.
getHistogramById
(
"
CYCLE_COLLECTOR
"
)
;
var
s
=
h
.
snapshot
(
)
;
do_check_eq
(
s
.
histogram_type
Telemetry
.
HISTOGRAM_EXPONENTIAL
)
;
do_check_eq
(
s
.
min
1
)
;
do_check_eq
(
s
.
max
10000
)
;
}
)
;
add_task
(
async
function
test_getSlowSQL
(
)
{
var
slow
=
Telemetry
.
slowSQL
;
do_check_true
(
(
"
mainThread
"
in
slow
)
&
&
(
"
otherThreads
"
in
slow
)
)
;
}
)
;
add_task
(
async
function
test_getWebrtc
(
)
{
var
webrtc
=
Telemetry
.
webrtcStats
;
do_check_true
(
"
IceCandidatesStats
"
in
webrtc
)
;
var
icestats
=
webrtc
.
IceCandidatesStats
;
do_check_true
(
"
webrtc
"
in
icestats
)
;
}
)
;
add_task
(
async
function
test_privateMode
(
)
{
var
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_BOOLEAN
"
)
;
var
orig
=
h
.
snapshot
(
)
;
Telemetry
.
canRecordExtended
=
false
;
h
.
add
(
1
)
;
do_check_eq
(
uneval
(
orig
)
uneval
(
h
.
snapshot
(
)
)
)
;
Telemetry
.
canRecordExtended
=
true
;
h
.
add
(
1
)
;
do_check_neq
(
uneval
(
orig
)
uneval
(
h
.
snapshot
(
)
)
)
;
}
)
;
add_task
(
async
function
test_histogramRecording
(
)
{
Telemetry
.
canRecordBase
=
false
;
Telemetry
.
canRecordExtended
=
false
;
let
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_RELEASE_OPTOUT
"
)
;
h
.
clear
(
)
;
let
orig
=
h
.
snapshot
(
)
;
h
.
add
(
1
)
;
Assert
.
equal
(
orig
.
sum
h
.
snapshot
(
)
.
sum
)
;
Telemetry
.
canRecordBase
=
true
;
h
.
add
(
1
)
;
Assert
.
equal
(
orig
.
sum
+
1
h
.
snapshot
(
)
.
sum
"
Histogram
value
should
have
incremented
by
1
due
to
recording
.
"
)
;
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_RELEASE_OPTIN
"
)
;
orig
=
h
.
snapshot
(
)
;
h
.
add
(
1
)
;
Assert
.
equal
(
orig
.
sum
h
.
snapshot
(
)
.
sum
"
Histograms
should
be
equal
after
recording
.
"
)
;
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_BOOLEAN
"
)
;
orig
=
h
.
snapshot
(
)
;
h
.
add
(
1
)
;
Assert
.
equal
(
orig
.
sum
h
.
snapshot
(
)
.
sum
"
Histograms
should
be
equal
after
recording
.
"
)
;
Telemetry
.
canRecordExtended
=
true
;
h
.
add
(
1
)
;
Assert
.
equal
(
orig
.
sum
+
1
h
.
snapshot
(
)
.
sum
"
Runtime
histogram
value
should
have
incremented
by
1
due
to
recording
.
"
)
;
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_RELEASE_OPTIN
"
)
;
orig
=
h
.
snapshot
(
)
;
h
.
add
(
1
)
;
Assert
.
equal
(
orig
.
sum
+
1
h
.
snapshot
(
)
.
sum
"
Histogram
value
should
have
incremented
by
1
due
to
recording
.
"
)
;
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_RELEASE_OPTOUT
"
)
;
h
.
clear
(
)
;
orig
=
h
.
snapshot
(
)
;
h
.
add
(
1
)
;
Assert
.
equal
(
orig
.
sum
+
1
h
.
snapshot
(
)
.
sum
"
Histogram
value
should
have
incremented
by
1
due
to
recording
.
"
)
;
}
)
;
add_task
(
async
function
test_expired_histogram
(
)
{
var
test_expired_id
=
"
TELEMETRY_TEST_EXPIRED
"
;
var
dummy
=
Telemetry
.
getHistogramById
(
test_expired_id
)
;
var
rh
=
Telemetry
.
registeredHistograms
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
[
]
)
;
Assert
.
ok
(
!
!
rh
)
;
dummy
.
add
(
1
)
;
do_check_eq
(
Telemetry
.
histogramSnapshots
[
"
__expired__
"
]
undefined
)
;
do_check_eq
(
Telemetry
.
histogramSnapshots
[
test_expired_id
]
undefined
)
;
do_check_eq
(
rh
[
test_expired_id
]
undefined
)
;
}
)
;
add_task
(
async
function
test_keyed_histogram
(
)
{
let
threw
=
false
;
try
{
Telemetry
.
getKeyedHistogramById
(
"
test
:
:
unknown
histogram
"
"
never
"
Telemetry
.
HISTOGRAM_BOOLEAN
)
;
}
catch
(
e
)
{
threw
=
true
;
}
Assert
.
ok
(
threw
"
getKeyedHistogramById
should
have
thrown
"
)
;
}
)
;
add_task
(
async
function
test_keyed_boolean_histogram
(
)
{
const
KEYED_ID
=
"
TELEMETRY_TEST_KEYED_BOOLEAN
"
;
let
KEYS
=
numberRange
(
0
2
)
.
map
(
i
=
>
"
key
"
+
(
i
+
1
)
)
;
KEYS
.
push
(
"
"
)
;
let
histogramBase
=
{
"
min
"
:
1
"
max
"
:
2
"
histogram_type
"
:
2
"
sum
"
:
1
"
ranges
"
:
[
0
1
2
]
"
counts
"
:
[
0
1
0
]
}
;
let
testHistograms
=
numberRange
(
0
3
)
.
map
(
i
=
>
JSON
.
parse
(
JSON
.
stringify
(
histogramBase
)
)
)
;
let
testKeys
=
[
]
;
let
testSnapShot
=
{
}
;
let
h
=
Telemetry
.
getKeyedHistogramById
(
KEYED_ID
)
;
for
(
let
i
=
0
;
i
<
2
;
+
+
i
)
{
let
key
=
KEYS
[
i
]
;
h
.
add
(
key
true
)
;
testSnapShot
[
key
]
=
testHistograms
[
i
]
;
testKeys
.
push
(
key
)
;
Assert
.
deepEqual
(
h
.
keys
(
)
.
sort
(
)
testKeys
)
;
Assert
.
deepEqual
(
h
.
snapshot
(
)
testSnapShot
)
;
}
h
=
Telemetry
.
getKeyedHistogramById
(
KEYED_ID
)
;
Assert
.
deepEqual
(
h
.
keys
(
)
.
sort
(
)
testKeys
)
;
Assert
.
deepEqual
(
h
.
snapshot
(
)
testSnapShot
)
;
let
key
=
KEYS
[
2
]
;
h
.
add
(
key
false
)
;
testKeys
.
push
(
key
)
;
testSnapShot
[
key
]
=
testHistograms
[
2
]
;
testSnapShot
[
key
]
.
sum
=
0
;
testSnapShot
[
key
]
.
counts
=
[
1
0
0
]
;
Assert
.
deepEqual
(
h
.
keys
(
)
.
sort
(
)
testKeys
)
;
Assert
.
deepEqual
(
h
.
snapshot
(
)
testSnapShot
)
;
let
allSnapshots
=
Telemetry
.
keyedHistogramSnapshots
;
Assert
.
deepEqual
(
allSnapshots
[
KEYED_ID
]
testSnapShot
)
;
h
.
clear
(
)
;
Assert
.
deepEqual
(
h
.
keys
(
)
[
]
)
;
Assert
.
deepEqual
(
h
.
snapshot
(
)
{
}
)
;
}
)
;
add_task
(
async
function
test_keyed_count_histogram
(
)
{
const
KEYED_ID
=
"
TELEMETRY_TEST_KEYED_COUNT
"
;
const
KEYS
=
numberRange
(
0
5
)
.
map
(
i
=
>
"
key
"
+
(
i
+
1
)
)
;
let
histogramBase
=
{
"
min
"
:
1
"
max
"
:
2
"
histogram_type
"
:
4
"
sum
"
:
0
"
ranges
"
:
[
0
1
2
]
"
counts
"
:
[
1
0
0
]
}
;
let
testHistograms
=
numberRange
(
0
5
)
.
map
(
i
=
>
JSON
.
parse
(
JSON
.
stringify
(
histogramBase
)
)
)
;
let
testKeys
=
[
]
;
let
testSnapShot
=
{
}
;
let
h
=
Telemetry
.
getKeyedHistogramById
(
KEYED_ID
)
;
h
.
clear
(
)
;
for
(
let
i
=
0
;
i
<
4
;
+
+
i
)
{
let
key
=
KEYS
[
i
]
;
let
value
=
i
*
2
+
1
;
for
(
let
k
=
0
;
k
<
value
;
+
+
k
)
{
h
.
add
(
key
)
;
}
testHistograms
[
i
]
.
counts
[
0
]
=
value
;
testHistograms
[
i
]
.
sum
=
value
;
testSnapShot
[
key
]
=
testHistograms
[
i
]
;
testKeys
.
push
(
key
)
;
Assert
.
deepEqual
(
h
.
keys
(
)
.
sort
(
)
testKeys
)
;
Assert
.
deepEqual
(
h
.
snapshot
(
key
)
testHistograms
[
i
]
)
;
Assert
.
deepEqual
(
h
.
snapshot
(
)
testSnapShot
)
;
}
h
=
Telemetry
.
getKeyedHistogramById
(
KEYED_ID
)
;
Assert
.
deepEqual
(
h
.
keys
(
)
.
sort
(
)
testKeys
)
;
Assert
.
deepEqual
(
h
.
snapshot
(
)
testSnapShot
)
;
let
key
=
KEYS
[
4
]
;
h
.
add
(
key
)
;
testKeys
.
push
(
key
)
;
testHistograms
[
4
]
.
counts
[
0
]
=
1
;
testHistograms
[
4
]
.
sum
=
1
;
testSnapShot
[
key
]
=
testHistograms
[
4
]
;
Assert
.
deepEqual
(
h
.
keys
(
)
.
sort
(
)
testKeys
)
;
Assert
.
deepEqual
(
h
.
snapshot
(
)
testSnapShot
)
;
let
allSnapshots
=
Telemetry
.
keyedHistogramSnapshots
;
Assert
.
deepEqual
(
allSnapshots
[
KEYED_ID
]
testSnapShot
)
;
h
.
clear
(
)
;
Assert
.
deepEqual
(
h
.
keys
(
)
[
]
)
;
Assert
.
deepEqual
(
h
.
snapshot
(
)
{
}
)
;
h
.
add
(
"
key
"
)
;
Assert
.
equal
(
h
.
snapshot
(
"
key
"
)
.
sum
1
)
;
}
)
;
add_task
(
async
function
test_keyed_categorical_histogram
(
)
{
const
KEYED_ID
=
"
TELEMETRY_TEST_KEYED_CATEGORICAL
"
;
const
KEYS
=
numberRange
(
0
5
)
.
map
(
i
=
>
"
key
"
+
(
i
+
1
)
)
;
let
h
=
Telemetry
.
getKeyedHistogramById
(
KEYED_ID
)
;
for
(
let
k
of
KEYS
)
{
for
(
let
v
of
[
"
CommonLabel
"
"
Label2
"
"
Label3
"
"
Label3
"
0
0
1
]
)
{
h
.
add
(
k
v
)
;
}
for
(
let
s
of
[
"
"
"
Label4
"
"
1234
"
]
)
{
h
.
add
(
k
s
)
;
}
}
let
expectedRanges
=
[
]
;
for
(
let
i
=
0
;
i
<
51
;
+
+
i
)
{
expectedRanges
.
push
(
i
)
;
}
let
snapshot
=
h
.
snapshot
(
)
;
let
snapshotKeys
=
Object
.
keys
(
snapshot
)
;
Assert
.
equal
(
KEYS
.
length
snapshotKeys
.
length
)
;
Assert
.
ok
(
KEYS
.
every
(
k
=
>
snapshotKeys
.
includes
(
k
)
)
)
;
for
(
let
k
of
KEYS
)
{
Assert
.
ok
(
k
in
snapshot
)
;
Assert
.
equal
(
snapshot
[
k
]
.
sum
6
)
;
Assert
.
deepEqual
(
snapshot
[
k
]
.
ranges
expectedRanges
)
;
Assert
.
deepEqual
(
snapshot
[
k
]
.
counts
.
slice
(
0
4
)
[
3
2
2
0
]
)
;
}
}
)
;
add_task
(
async
function
test_keyed_flag_histogram
(
)
{
const
KEYED_ID
=
"
TELEMETRY_TEST_KEYED_FLAG
"
;
let
h
=
Telemetry
.
getKeyedHistogramById
(
KEYED_ID
)
;
const
KEY
=
"
default
"
;
h
.
add
(
KEY
true
)
;
let
testSnapshot
=
{
}
;
testSnapshot
[
KEY
]
=
{
"
min
"
:
1
"
max
"
:
2
"
histogram_type
"
:
3
"
sum
"
:
1
"
ranges
"
:
[
0
1
2
]
"
counts
"
:
[
0
1
0
]
}
;
Assert
.
deepEqual
(
h
.
keys
(
)
.
sort
(
)
[
KEY
]
)
;
Assert
.
deepEqual
(
h
.
snapshot
(
)
testSnapshot
)
;
let
allSnapshots
=
Telemetry
.
keyedHistogramSnapshots
;
Assert
.
deepEqual
(
allSnapshots
[
KEYED_ID
]
testSnapshot
)
;
h
.
clear
(
)
;
Assert
.
deepEqual
(
h
.
keys
(
)
[
]
)
;
Assert
.
deepEqual
(
h
.
snapshot
(
)
{
}
)
;
}
)
;
add_task
(
async
function
test_keyed_histogram_recording
(
)
{
Telemetry
.
canRecordBase
=
false
;
Telemetry
.
canRecordExtended
=
false
;
const
TEST_KEY
=
"
record_foo
"
;
let
h
=
Telemetry
.
getKeyedHistogramById
(
"
TELEMETRY_TEST_KEYED_RELEASE_OPTOUT
"
)
;
h
.
clear
(
)
;
h
.
add
(
TEST_KEY
1
)
;
Assert
.
equal
(
h
.
snapshot
(
TEST_KEY
)
.
sum
0
)
;
Telemetry
.
canRecordBase
=
true
;
h
.
add
(
TEST_KEY
1
)
;
Assert
.
equal
(
h
.
snapshot
(
TEST_KEY
)
.
sum
1
"
The
keyed
histogram
should
record
the
correct
value
.
"
)
;
h
=
Telemetry
.
getKeyedHistogramById
(
"
TELEMETRY_TEST_KEYED_RELEASE_OPTIN
"
)
;
h
.
clear
(
)
;
h
.
add
(
TEST_KEY
1
)
;
Assert
.
equal
(
h
.
snapshot
(
TEST_KEY
)
.
sum
0
"
The
keyed
histograms
should
not
record
any
data
.
"
)
;
Telemetry
.
canRecordExtended
=
true
;
h
.
add
(
TEST_KEY
1
)
;
Assert
.
equal
(
h
.
snapshot
(
TEST_KEY
)
.
sum
1
"
The
runtime
keyed
histogram
should
record
the
correct
value
.
"
)
;
h
=
Telemetry
.
getKeyedHistogramById
(
"
TELEMETRY_TEST_KEYED_RELEASE_OPTIN
"
)
;
h
.
clear
(
)
;
h
.
add
(
TEST_KEY
1
)
;
Assert
.
equal
(
h
.
snapshot
(
TEST_KEY
)
.
sum
1
"
The
keyed
histogram
should
record
the
correct
value
.
"
)
;
h
=
Telemetry
.
getKeyedHistogramById
(
"
TELEMETRY_TEST_KEYED_RELEASE_OPTOUT
"
)
;
h
.
clear
(
)
;
h
.
add
(
TEST_KEY
1
)
;
Assert
.
equal
(
h
.
snapshot
(
TEST_KEY
)
.
sum
1
)
;
}
)
;
add_task
(
async
function
test_histogram_recording_enabled
(
)
{
Telemetry
.
canRecordBase
=
true
;
Telemetry
.
canRecordExtended
=
true
;
var
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_COUNT
"
)
;
var
orig
=
h
.
snapshot
(
)
;
h
.
add
(
1
)
;
Assert
.
equal
(
orig
.
sum
+
1
h
.
snapshot
(
)
.
sum
"
add
should
record
by
default
.
"
)
;
Telemetry
.
setHistogramRecordingEnabled
(
"
TELEMETRY_TEST_COUNT
"
false
)
;
h
.
add
(
1
)
;
Assert
.
equal
(
orig
.
sum
+
1
h
.
snapshot
(
)
.
sum
"
When
recording
is
disabled
add
should
not
record
.
"
)
;
Telemetry
.
setHistogramRecordingEnabled
(
"
TELEMETRY_TEST_COUNT
"
true
)
;
h
.
add
(
1
)
;
Assert
.
equal
(
orig
.
sum
+
2
h
.
snapshot
(
)
.
sum
"
When
recording
is
re
-
enabled
add
should
record
.
"
)
;
h
.
clear
(
)
;
h
.
add
(
3
)
;
Assert
.
equal
(
3
h
.
snapshot
(
)
.
sum
"
Recording
counts
greater
than
1
should
work
.
"
)
;
h
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_COUNT_INIT_NO_RECORD
"
)
;
orig
=
h
.
snapshot
(
)
;
h
.
add
(
1
)
;
Assert
.
equal
(
orig
.
sum
h
.
snapshot
(
)
.
sum
"
When
recording
is
disabled
by
default
add
should
not
record
by
default
.
"
)
;
Telemetry
.
setHistogramRecordingEnabled
(
"
TELEMETRY_TEST_COUNT_INIT_NO_RECORD
"
true
)
;
h
.
add
(
1
)
;
Assert
.
equal
(
orig
.
sum
+
1
h
.
snapshot
(
)
.
sum
"
When
recording
is
enabled
add
should
record
.
"
)
;
Telemetry
.
setHistogramRecordingEnabled
(
"
TELEMETRY_TEST_COUNT_INIT_NO_RECORD
"
false
)
;
h
.
add
(
1
)
;
Assert
.
equal
(
orig
.
sum
+
1
h
.
snapshot
(
)
.
sum
"
When
recording
is
disabled
add
should
not
record
.
"
)
;
}
)
;
add_task
(
async
function
test_keyed_histogram_recording_enabled
(
)
{
Telemetry
.
canRecordBase
=
true
;
Telemetry
.
canRecordExtended
=
true
;
const
TEST_KEY
=
"
record_foo
"
;
let
h
=
Telemetry
.
getKeyedHistogramById
(
"
TELEMETRY_TEST_KEYED_RELEASE_OPTOUT
"
)
;
h
.
clear
(
)
;
h
.
add
(
TEST_KEY
1
)
;
Assert
.
equal
(
h
.
snapshot
(
TEST_KEY
)
.
sum
1
"
Keyed
histogram
add
should
record
by
default
"
)
;
Telemetry
.
setHistogramRecordingEnabled
(
"
TELEMETRY_TEST_KEYED_RELEASE_OPTOUT
"
false
)
;
h
.
add
(
TEST_KEY
1
)
;
Assert
.
equal
(
h
.
snapshot
(
TEST_KEY
)
.
sum
1
"
Keyed
histogram
add
should
not
record
when
recording
is
disabled
"
)
;
Telemetry
.
setHistogramRecordingEnabled
(
"
TELEMETRY_TEST_KEYED_RELEASE_OPTOUT
"
true
)
;
h
.
clear
(
)
;
h
.
add
(
TEST_KEY
1
)
;
Assert
.
equal
(
h
.
snapshot
(
TEST_KEY
)
.
sum
1
"
Keyed
histogram
add
should
record
when
recording
is
re
-
enabled
"
)
;
h
=
Telemetry
.
getKeyedHistogramById
(
"
TELEMETRY_TEST_KEYED_COUNT_INIT_NO_RECORD
"
)
;
h
.
clear
(
)
;
h
.
add
(
TEST_KEY
1
)
;
Assert
.
equal
(
h
.
snapshot
(
TEST_KEY
)
.
sum
0
"
Keyed
histogram
add
should
not
record
by
default
for
histograms
which
don
'
t
record
by
default
"
)
;
Telemetry
.
setHistogramRecordingEnabled
(
"
TELEMETRY_TEST_KEYED_COUNT_INIT_NO_RECORD
"
true
)
;
h
.
add
(
TEST_KEY
1
)
;
Assert
.
equal
(
h
.
snapshot
(
TEST_KEY
)
.
sum
1
"
Keyed
histogram
add
should
record
when
recording
is
enabled
"
)
;
Telemetry
.
setHistogramRecordingEnabled
(
"
TELEMETRY_TEST_KEYED_COUNT_INIT_NO_RECORD
"
false
)
;
h
.
add
(
TEST_KEY
1
)
;
Assert
.
equal
(
h
.
snapshot
(
TEST_KEY
)
.
sum
1
"
Keyed
histogram
add
should
not
record
when
recording
is
disabled
"
)
;
}
)
;
add_task
(
async
function
test_histogramSnapshots
(
)
{
let
keyed
=
Telemetry
.
getKeyedHistogramById
(
"
TELEMETRY_TEST_KEYED_COUNT
"
)
;
keyed
.
add
(
"
a
"
1
)
;
Assert
.
ok
(
!
(
"
TELEMETRY_TEST_KEYED_COUNT
#
a
"
in
Telemetry
.
histogramSnapshots
)
)
;
}
)
;
add_task
(
async
function
test_datasets
(
)
{
const
RELEASE_CHANNEL_OPTOUT
=
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTOUT
;
const
RELEASE_CHANNEL_OPTIN
=
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
;
let
registered
=
Telemetry
.
registeredHistograms
(
RELEASE_CHANNEL_OPTIN
[
]
)
;
registered
=
new
Set
(
registered
)
;
Assert
.
ok
(
registered
.
has
(
"
TELEMETRY_TEST_FLAG
"
)
)
;
Assert
.
ok
(
registered
.
has
(
"
TELEMETRY_TEST_RELEASE_OPTIN
"
)
)
;
Assert
.
ok
(
registered
.
has
(
"
TELEMETRY_TEST_RELEASE_OPTOUT
"
)
)
;
registered
=
Telemetry
.
registeredHistograms
(
RELEASE_CHANNEL_OPTOUT
[
]
)
;
registered
=
new
Set
(
registered
)
;
Assert
.
ok
(
!
registered
.
has
(
"
TELEMETRY_TEST_FLAG
"
)
)
;
Assert
.
ok
(
!
registered
.
has
(
"
TELEMETRY_TEST_RELEASE_OPTIN
"
)
)
;
Assert
.
ok
(
registered
.
has
(
"
TELEMETRY_TEST_RELEASE_OPTOUT
"
)
)
;
registered
=
Telemetry
.
registeredKeyedHistograms
(
RELEASE_CHANNEL_OPTIN
[
]
)
;
registered
=
new
Set
(
registered
)
;
Assert
.
ok
(
registered
.
has
(
"
TELEMETRY_TEST_KEYED_FLAG
"
)
)
;
Assert
.
ok
(
registered
.
has
(
"
TELEMETRY_TEST_KEYED_RELEASE_OPTOUT
"
)
)
;
registered
=
Telemetry
.
registeredKeyedHistograms
(
RELEASE_CHANNEL_OPTOUT
[
]
)
;
registered
=
new
Set
(
registered
)
;
Assert
.
ok
(
!
registered
.
has
(
"
TELEMETRY_TEST_KEYED_FLAG
"
)
)
;
Assert
.
ok
(
registered
.
has
(
"
TELEMETRY_TEST_KEYED_RELEASE_OPTOUT
"
)
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
gIsAndroid
}
function
test_subsession
(
)
{
const
ID
=
"
TELEMETRY_TEST_COUNT
"
;
const
FLAG
=
"
TELEMETRY_TEST_FLAG
"
;
let
h
=
Telemetry
.
getHistogramById
(
ID
)
;
let
flag
=
Telemetry
.
getHistogramById
(
FLAG
)
;
h
.
clear
(
)
;
let
snapshot
=
Telemetry
.
histogramSnapshots
;
let
subsession
=
Telemetry
.
snapshotSubsessionHistograms
(
)
;
Assert
.
ok
(
!
(
ID
in
snapshot
)
)
;
Assert
.
ok
(
!
(
ID
in
subsession
)
)
;
h
.
add
(
1
)
;
snapshot
=
Telemetry
.
histogramSnapshots
;
subsession
=
Telemetry
.
snapshotSubsessionHistograms
(
)
;
Assert
.
ok
(
ID
in
snapshot
)
;
Assert
.
ok
(
ID
in
subsession
)
;
Assert
.
equal
(
snapshot
[
ID
]
.
sum
1
)
;
Assert
.
equal
(
subsession
[
ID
]
.
sum
1
)
;
h
.
clear
(
)
;
snapshot
=
Telemetry
.
histogramSnapshots
;
subsession
=
Telemetry
.
snapshotSubsessionHistograms
(
)
;
Assert
.
ok
(
!
(
ID
in
snapshot
)
)
;
Assert
.
ok
(
!
(
ID
in
subsession
)
)
;
h
.
add
(
1
)
;
snapshot
=
Telemetry
.
histogramSnapshots
;
subsession
=
Telemetry
.
snapshotSubsessionHistograms
(
)
;
Assert
.
equal
(
snapshot
[
ID
]
.
sum
1
)
;
Assert
.
equal
(
subsession
[
ID
]
.
sum
1
)
;
h
.
clear
(
true
)
;
snapshot
=
Telemetry
.
histogramSnapshots
;
subsession
=
Telemetry
.
snapshotSubsessionHistograms
(
)
;
Assert
.
ok
(
ID
in
snapshot
)
;
Assert
.
ok
(
ID
in
subsession
)
;
Assert
.
equal
(
snapshot
[
ID
]
.
sum
1
)
;
Assert
.
equal
(
subsession
[
ID
]
.
sum
0
)
;
h
.
add
(
1
)
;
snapshot
=
Telemetry
.
histogramSnapshots
;
subsession
=
Telemetry
.
snapshotSubsessionHistograms
(
)
;
Assert
.
equal
(
snapshot
[
ID
]
.
sum
2
)
;
Assert
.
equal
(
subsession
[
ID
]
.
sum
1
)
;
h
.
clear
(
)
;
flag
.
clear
(
)
;
h
.
add
(
1
)
;
flag
.
add
(
1
)
;
snapshot
=
Telemetry
.
histogramSnapshots
;
subsession
=
Telemetry
.
snapshotSubsessionHistograms
(
true
)
;
Assert
.
ok
(
ID
in
snapshot
)
;
Assert
.
ok
(
ID
in
subsession
)
;
Assert
.
ok
(
FLAG
in
snapshot
)
;
Assert
.
ok
(
FLAG
in
subsession
)
;
Assert
.
equal
(
snapshot
[
ID
]
.
sum
1
)
;
Assert
.
equal
(
subsession
[
ID
]
.
sum
1
)
;
Assert
.
equal
(
snapshot
[
FLAG
]
.
sum
1
)
;
Assert
.
equal
(
subsession
[
FLAG
]
.
sum
1
)
;
snapshot
=
Telemetry
.
histogramSnapshots
;
subsession
=
Telemetry
.
snapshotSubsessionHistograms
(
)
;
Assert
.
ok
(
ID
in
snapshot
)
;
Assert
.
ok
(
ID
in
subsession
)
;
Assert
.
ok
(
FLAG
in
snapshot
)
;
Assert
.
ok
(
FLAG
in
subsession
)
;
Assert
.
equal
(
snapshot
[
ID
]
.
sum
1
)
;
Assert
.
equal
(
subsession
[
ID
]
.
sum
0
)
;
Assert
.
equal
(
snapshot
[
FLAG
]
.
sum
1
)
;
Assert
.
equal
(
subsession
[
FLAG
]
.
sum
0
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
gIsAndroid
}
function
test_keyed_subsession
(
)
{
let
h
=
Telemetry
.
getKeyedHistogramById
(
"
TELEMETRY_TEST_KEYED_FLAG
"
)
;
const
KEY
=
"
foo
"
;
h
.
clear
(
)
;
Assert
.
ok
(
!
(
KEY
in
h
.
snapshot
(
)
)
)
;
Assert
.
ok
(
!
(
KEY
in
h
.
subsessionSnapshot
(
)
)
)
;
Assert
.
equal
(
h
.
snapshot
(
KEY
)
.
sum
0
)
;
Assert
.
equal
(
h
.
subsessionSnapshot
(
KEY
)
.
sum
0
)
;
h
.
add
(
KEY
1
)
;
Assert
.
ok
(
KEY
in
h
.
snapshot
(
)
)
;
Assert
.
ok
(
KEY
in
h
.
subsessionSnapshot
(
)
)
;
Assert
.
equal
(
h
.
snapshot
(
KEY
)
.
sum
1
)
;
Assert
.
equal
(
h
.
subsessionSnapshot
(
KEY
)
.
sum
1
)
;
h
.
clear
(
true
)
;
Assert
.
ok
(
KEY
in
h
.
snapshot
(
)
)
;
Assert
.
ok
(
!
(
KEY
in
h
.
subsessionSnapshot
(
)
)
)
;
Assert
.
equal
(
h
.
snapshot
(
KEY
)
.
sum
1
)
;
Assert
.
equal
(
h
.
subsessionSnapshot
(
KEY
)
.
sum
0
)
;
h
.
add
(
KEY
1
)
;
Assert
.
ok
(
KEY
in
h
.
snapshot
(
)
)
;
Assert
.
ok
(
KEY
in
h
.
subsessionSnapshot
(
)
)
;
Assert
.
equal
(
h
.
snapshot
(
KEY
)
.
sum
1
)
;
Assert
.
equal
(
h
.
subsessionSnapshot
(
KEY
)
.
sum
1
)
;
let
snapshot
=
h
.
snapshot
(
)
;
let
subsession
=
h
.
snapshotSubsessionAndClear
(
)
;
Assert
.
ok
(
KEY
in
snapshot
)
;
Assert
.
ok
(
KEY
in
subsession
)
;
Assert
.
equal
(
snapshot
[
KEY
]
.
sum
1
)
;
Assert
.
equal
(
subsession
[
KEY
]
.
sum
1
)
;
subsession
=
h
.
subsessionSnapshot
(
)
;
Assert
.
ok
(
!
(
KEY
in
subsession
)
)
;
Assert
.
equal
(
h
.
subsessionSnapshot
(
KEY
)
.
sum
0
)
;
}
)
;
