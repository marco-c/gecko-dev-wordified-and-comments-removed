"
use
strict
"
;
const
{
TelemetryStorage
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
)
;
const
{
TelemetryUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
)
;
const
{
makeFakeAppDir
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AppData
.
jsm
"
)
;
const
PENDING_PING_DIR_NAME
=
"
Pending
Pings
"
;
async
function
createFakeAppDir
(
)
{
let
profileDir
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
const
pendingPingsPath
=
OS
.
Path
.
join
(
profileDir
.
path
"
UAppData
"
PENDING_PING_DIR_NAME
)
;
await
OS
.
File
.
makeDir
(
pendingPingsPath
{
ignoreExisting
:
true
from
:
OS
.
Constants
.
Path
.
profileDir
}
)
;
await
makeFakeAppDir
(
)
;
}
add_task
(
async
function
setup
(
)
{
do_get_profile
(
)
;
await
createFakeAppDir
(
)
;
await
setEmptyPrefWatchlist
(
)
;
}
)
;
add_task
(
async
function
test_migrateUnsentPings
(
)
{
const
PINGS
=
[
{
type
:
"
crash
"
id
:
TelemetryUtils
.
generateUUID
(
)
payload
:
{
foo
:
"
bar
"
}
dateCreated
:
new
Date
(
2010
1
1
10
0
0
)
}
{
type
:
"
other
"
id
:
TelemetryUtils
.
generateUUID
(
)
payload
:
{
moo
:
"
meh
"
}
dateCreated
:
new
Date
(
2010
2
1
10
2
0
)
}
]
;
const
APP_DATA_DIR
=
Services
.
dirsvc
.
get
(
"
UAppData
"
Ci
.
nsIFile
)
.
path
;
const
APPDATA_PINGS_DIR
=
OS
.
Path
.
join
(
APP_DATA_DIR
PENDING_PING_DIR_NAME
)
;
for
(
let
ping
of
PINGS
)
{
const
pingPath
=
OS
.
Path
.
join
(
APPDATA_PINGS_DIR
ping
.
id
+
"
.
json
"
)
;
await
TelemetryStorage
.
savePingToFile
(
ping
pingPath
true
)
;
}
await
TelemetryStorage
.
testClearPendingPings
(
)
;
let
pendingPings
=
await
TelemetryStorage
.
loadPendingPingList
(
)
;
Assert
.
equal
(
pendingPings
.
length
2
"
TelemetryStorage
must
have
migrated
2
pings
.
"
)
;
for
(
let
ping
of
PINGS
)
{
Assert
.
ok
(
pendingPings
.
find
(
p
=
>
p
.
id
=
=
ping
.
id
)
"
The
ping
must
have
been
migrated
.
"
)
;
let
migratedPing
=
await
TelemetryStorage
.
loadPendingPing
(
ping
.
id
)
;
Assert
.
equal
(
ping
.
id
migratedPing
.
id
"
Should
have
loaded
the
correct
ping
id
.
"
)
;
Assert
.
equal
(
ping
.
type
migratedPing
.
type
"
Should
have
loaded
the
correct
ping
type
.
"
)
;
Assert
.
deepEqual
(
ping
.
payload
migratedPing
.
payload
"
Should
have
loaded
the
correct
payload
.
"
)
;
const
pingPath
=
OS
.
Path
.
join
(
APPDATA_PINGS_DIR
ping
.
id
+
"
.
json
"
)
;
Assert
.
ok
(
!
(
await
OS
.
File
.
exists
(
pingPath
)
)
"
The
ping
should
not
be
in
the
Pending
Pings
directory
anymore
.
"
)
;
}
}
)
;
add_task
(
async
function
test_migrateIncompatiblePing
(
)
{
const
APP_DATA_DIR
=
Services
.
dirsvc
.
get
(
"
UAppData
"
Ci
.
nsIFile
)
.
path
;
const
APPDATA_PINGS_DIR
=
OS
.
Path
.
join
(
APP_DATA_DIR
PENDING_PING_DIR_NAME
)
;
const
pingPath
=
OS
.
Path
.
join
(
APPDATA_PINGS_DIR
"
incompatible
.
json
"
)
;
await
TelemetryStorage
.
savePingToFile
(
{
incom
:
"
patible
"
}
pingPath
true
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
TelemetryStorage
.
reset
(
)
;
let
pendingPings
=
await
TelemetryStorage
.
loadPendingPingList
(
)
;
Assert
.
equal
(
pendingPings
.
length
0
"
TelemetryStorage
must
have
migrated
no
pings
.
"
+
JSON
.
stringify
(
pendingPings
)
)
;
Assert
.
ok
(
!
(
await
OS
.
File
.
exists
(
pingPath
)
)
"
The
incompatible
ping
must
have
been
deleted
by
the
migration
"
)
;
}
)
;
add_task
(
async
function
teardown
(
)
{
const
APP_DATA_DIR
=
Services
.
dirsvc
.
get
(
"
UAppData
"
Ci
.
nsIFile
)
.
path
;
await
OS
.
File
.
removeDir
(
APP_DATA_DIR
{
ignorePermissions
:
true
}
)
;
Assert
.
ok
(
!
(
await
OS
.
File
.
exists
(
APP_DATA_DIR
)
)
"
The
UAppData
directory
must
not
exist
anymore
.
"
)
;
TelemetryStorage
.
reset
(
)
;
await
TelemetryStorage
.
loadPendingPingList
(
)
;
}
)
;
