const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
const
{
ClientID
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ClientID
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LightweightThemeManager
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySession
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryStorage
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySend
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryReportingPolicy
.
jsm
"
this
)
;
const
{
Preferences
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
const
PING_FORMAT_VERSION
=
4
;
const
PING_TYPE_MAIN
=
"
main
"
;
const
PING_TYPE_SAVED_SESSION
=
"
saved
-
session
"
;
const
REASON_ABORTED_SESSION
=
"
aborted
-
session
"
;
const
REASON_SAVED_SESSION
=
"
saved
-
session
"
;
const
REASON_SHUTDOWN
=
"
shutdown
"
;
const
REASON_TEST_PING
=
"
test
-
ping
"
;
const
REASON_DAILY
=
"
daily
"
;
const
REASON_ENVIRONMENT_CHANGE
=
"
environment
-
change
"
;
const
PLATFORM_VERSION
=
"
1
.
9
.
2
"
;
const
APP_VERSION
=
"
1
"
;
const
APP_ID
=
"
xpcshell
tests
.
mozilla
.
org
"
;
const
APP_NAME
=
"
XPCShell
"
;
const
IGNORE_HISTOGRAM_TO_CLONE
=
"
MEMORY_HEAP_ALLOCATED
"
;
const
IGNORE_CLONED_HISTOGRAM
=
"
test
:
:
ignore_me_also
"
;
const
SHUTDOWN_TIME
=
10000
;
const
FAILED_PROFILE_LOCK_ATTEMPTS
=
2
;
const
PR_WRONLY
=
0x2
;
const
PR_CREATE_FILE
=
0x8
;
const
PR_TRUNCATE
=
0x20
;
const
RW_OWNER
=
parseInt
(
"
0600
"
8
)
;
const
NUMBER_OF_THREADS_TO_LAUNCH
=
30
;
var
gNumberOfThreadsLaunched
=
0
;
const
MS_IN_ONE_HOUR
=
60
*
60
*
1000
;
const
MS_IN_ONE_DAY
=
24
*
MS_IN_ONE_HOUR
;
const
DATAREPORTING_DIR
=
"
datareporting
"
;
const
ABORTED_PING_FILE_NAME
=
"
aborted
-
session
-
ping
"
;
const
ABORTED_SESSION_UPDATE_INTERVAL_MS
=
5
*
60
*
1000
;
XPCOMUtils
.
defineLazyGetter
(
this
"
DATAREPORTING_PATH
"
function
(
)
{
return
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
DATAREPORTING_DIR
)
;
}
)
;
var
gClientID
=
null
;
var
gMonotonicNow
=
0
;
function
sendPing
(
)
{
TelemetrySession
.
gatherStartup
(
)
;
if
(
PingServer
.
started
)
{
TelemetrySend
.
setServer
(
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
return
TelemetrySession
.
testPing
(
)
;
}
TelemetrySend
.
setServer
(
"
http
:
/
/
doesnotexist
"
)
;
return
TelemetrySession
.
testPing
(
)
;
}
function
fakeGenerateUUID
(
sessionFunc
subsessionFunc
)
{
let
session
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySession
.
jsm
"
null
)
;
session
.
Policy
.
generateSessionUUID
=
sessionFunc
;
session
.
Policy
.
generateSubsessionUUID
=
subsessionFunc
;
}
function
fakeIdleNotification
(
topic
)
{
let
session
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetrySession
.
jsm
"
null
)
;
return
session
.
TelemetryScheduler
.
observe
(
null
topic
null
)
;
}
function
setupTestData
(
)
{
Services
.
startup
.
interrupted
=
true
;
let
h2
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_COUNT
"
)
;
h2
.
add
(
)
;
let
k1
=
Telemetry
.
getKeyedHistogramById
(
"
TELEMETRY_TEST_KEYED_COUNT
"
)
;
k1
.
add
(
"
a
"
)
;
k1
.
add
(
"
a
"
)
;
k1
.
add
(
"
b
"
)
;
}
function
getSavedPingFile
(
basename
)
{
let
tmpDir
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
let
pingFile
=
tmpDir
.
clone
(
)
;
pingFile
.
append
(
basename
)
;
if
(
pingFile
.
exists
(
)
)
{
pingFile
.
remove
(
true
)
;
}
registerCleanupFunction
(
function
(
)
{
try
{
pingFile
.
remove
(
true
)
;
}
catch
(
e
)
{
}
}
)
;
return
pingFile
;
}
function
checkPingFormat
(
aPing
aType
aHasClientId
aHasEnvironment
)
{
const
MANDATORY_PING_FIELDS
=
[
"
type
"
"
id
"
"
creationDate
"
"
version
"
"
application
"
"
payload
"
]
;
const
APPLICATION_TEST_DATA
=
{
buildId
:
gAppInfo
.
appBuildID
name
:
APP_NAME
version
:
APP_VERSION
vendor
:
"
Mozilla
"
platformVersion
:
PLATFORM_VERSION
xpcomAbi
:
"
noarch
-
spidermonkey
"
}
;
for
(
let
f
of
MANDATORY_PING_FIELDS
)
{
Assert
.
ok
(
f
in
aPing
f
+
"
must
be
available
.
"
)
;
}
Assert
.
equal
(
aPing
.
type
aType
"
The
ping
must
have
the
correct
type
.
"
)
;
Assert
.
equal
(
aPing
.
version
PING_FORMAT_VERSION
"
The
ping
must
have
the
correct
version
.
"
)
;
for
(
let
f
in
APPLICATION_TEST_DATA
)
{
Assert
.
equal
(
aPing
.
application
[
f
]
APPLICATION_TEST_DATA
[
f
]
f
+
"
must
have
the
correct
value
.
"
)
;
}
Assert
.
ok
(
"
architecture
"
in
aPing
.
application
"
The
application
section
must
have
an
architecture
field
.
"
)
;
Assert
.
ok
(
"
channel
"
in
aPing
.
application
"
The
application
section
must
have
a
channel
field
.
"
)
;
Assert
.
equal
(
"
clientId
"
in
aPing
aHasClientId
)
;
Assert
.
equal
(
"
environment
"
in
aPing
aHasEnvironment
)
;
}
function
checkPayloadInfo
(
data
reason
)
{
const
ALLOWED_REASONS
=
[
"
environment
-
change
"
"
shutdown
"
"
daily
"
"
saved
-
session
"
"
test
-
ping
"
]
;
let
numberCheck
=
arg
=
>
{
return
(
typeof
arg
=
=
"
number
"
)
;
}
;
let
positiveNumberCheck
=
arg
=
>
{
return
numberCheck
(
arg
)
&
&
(
arg
>
=
0
)
;
}
;
let
stringCheck
=
arg
=
>
{
return
(
typeof
arg
=
=
"
string
"
)
&
&
(
arg
!
=
"
"
)
;
}
;
let
revisionCheck
=
arg
=
>
{
return
(
AppConstants
.
MOZILLA_OFFICIAL
)
?
stringCheck
(
arg
)
:
(
typeof
arg
=
=
"
string
"
)
;
}
;
let
uuidCheck
=
arg
=
>
{
return
UUID_REGEX
.
test
(
arg
)
;
}
;
let
isoDateCheck
=
arg
=
>
{
const
isoDateRegEx
=
/
^
\
d
{
4
}
-
\
d
{
2
}
-
\
d
{
2
}
T
\
d
{
2
}
:
\
d
{
2
}
:
\
d
{
2
}
\
.
\
d
+
[
+
-
]
\
d
{
2
}
:
\
d
{
2
}
/
;
return
stringCheck
(
arg
)
&
&
!
Number
.
isNaN
(
Date
.
parse
(
arg
)
)
&
&
isoDateRegEx
.
test
(
arg
)
;
}
;
const
EXPECTED_INFO_FIELDS_TYPES
=
{
reason
:
stringCheck
revision
:
revisionCheck
timezoneOffset
:
numberCheck
sessionId
:
uuidCheck
subsessionId
:
uuidCheck
previousSessionId
:
(
arg
)
=
>
{
return
(
arg
)
?
uuidCheck
(
arg
)
:
true
;
}
previousSubsessionId
:
(
arg
)
=
>
{
return
(
arg
)
?
uuidCheck
(
arg
)
:
true
;
}
subsessionCounter
:
positiveNumberCheck
profileSubsessionCounter
:
positiveNumberCheck
sessionStartDate
:
isoDateCheck
subsessionStartDate
:
isoDateCheck
subsessionLength
:
positiveNumberCheck
}
;
for
(
let
f
in
EXPECTED_INFO_FIELDS_TYPES
)
{
Assert
.
ok
(
f
in
data
f
+
"
must
be
available
.
"
)
;
let
checkFunc
=
EXPECTED_INFO_FIELDS_TYPES
[
f
]
;
Assert
.
ok
(
checkFunc
(
data
[
f
]
)
f
+
"
must
have
the
correct
type
and
valid
data
"
+
data
[
f
]
)
;
}
if
(
data
.
revision
!
=
"
"
)
{
const
revisionUrlRegEx
=
/
^
http
[
s
]
?
:
\
/
\
/
hg
.
mozilla
.
org
(
\
/
[
a
-
z
\
S
]
+
)
+
(
\
/
rev
\
/
[
0
-
9a
-
z
]
+
)
/
g
;
Assert
.
ok
(
revisionUrlRegEx
.
test
(
data
.
revision
)
)
;
}
if
(
data
.
previousBuildId
)
{
Assert
.
ok
(
stringCheck
(
data
.
previousBuildId
)
)
;
}
Assert
.
ok
(
ALLOWED_REASONS
.
find
(
r
=
>
r
=
=
data
.
reason
)
"
Payload
must
contain
an
allowed
reason
.
"
)
;
Assert
.
equal
(
data
.
reason
reason
"
Payload
reason
must
match
expected
.
"
)
;
Assert
.
ok
(
Date
.
parse
(
data
.
subsessionStartDate
)
>
=
Date
.
parse
(
data
.
sessionStartDate
)
)
;
Assert
.
ok
(
data
.
profileSubsessionCounter
>
=
data
.
subsessionCounter
)
;
Assert
.
ok
(
data
.
timezoneOffset
>
=
-
12
*
60
"
The
timezone
must
be
in
a
valid
range
.
"
)
;
Assert
.
ok
(
data
.
timezoneOffset
<
=
12
*
60
"
The
timezone
must
be
in
a
valid
range
.
"
)
;
}
function
checkScalars
(
processes
)
{
const
parentProcess
=
processes
.
parent
;
Assert
.
ok
(
"
scalars
"
in
parentProcess
"
The
scalars
section
must
be
available
in
the
parent
process
.
"
)
;
Assert
.
ok
(
"
keyedScalars
"
in
parentProcess
"
The
keyedScalars
section
must
be
available
in
the
parent
process
.
"
)
;
Assert
.
equal
(
typeof
parentProcess
.
scalars
"
object
"
"
The
scalars
entry
must
be
an
object
.
"
)
;
Assert
.
equal
(
typeof
parentProcess
.
keyedScalars
"
object
"
"
The
keyedScalars
entry
must
be
an
object
.
"
)
;
let
checkScalar
=
function
(
scalar
)
{
const
valueType
=
typeof
(
scalar
)
;
switch
(
valueType
)
{
case
"
string
"
:
Assert
.
ok
(
scalar
.
length
<
=
50
"
String
values
can
'
t
have
more
than
50
characters
"
)
;
break
;
case
"
number
"
:
Assert
.
ok
(
scalar
>
=
0
"
We
only
support
unsigned
integer
values
in
scalars
.
"
)
;
break
;
case
"
boolean
"
:
Assert
.
ok
(
true
"
Boolean
scalar
found
.
"
)
;
break
;
default
:
Assert
.
ok
(
false
name
+
"
contains
an
unsupported
value
type
(
"
+
valueType
+
"
)
"
)
;
}
}
;
const
scalars
=
parentProcess
.
scalars
;
for
(
let
name
in
scalars
)
{
Assert
.
equal
(
typeof
name
"
string
"
"
Scalar
names
must
be
strings
.
"
)
;
checkScalar
(
scalars
[
name
]
)
;
}
const
keyedScalars
=
parentProcess
.
keyedScalars
;
for
(
let
name
in
keyedScalars
)
{
Assert
.
equal
(
typeof
name
"
string
"
"
Scalar
names
must
be
strings
.
"
)
;
Assert
.
ok
(
Object
.
keys
(
keyedScalars
[
name
]
)
.
length
"
The
reported
keyed
scalars
must
contain
at
least
1
key
.
"
)
;
for
(
let
key
in
keyedScalars
[
name
]
)
{
Assert
.
equal
(
typeof
key
"
string
"
"
Keyed
scalar
keys
must
be
strings
.
"
)
;
Assert
.
ok
(
key
.
length
<
=
70
"
Keyed
scalar
keys
can
'
t
have
more
than
70
characters
.
"
)
;
checkScalar
(
scalars
[
name
]
[
key
]
)
;
}
}
}
function
checkPayload
(
payload
reason
successfulPings
)
{
Assert
.
ok
(
"
info
"
in
payload
"
Payload
must
contain
an
info
section
.
"
)
;
checkPayloadInfo
(
payload
.
info
reason
)
;
Assert
.
ok
(
payload
.
simpleMeasurements
.
totalTime
>
=
0
)
;
Assert
.
equal
(
payload
.
simpleMeasurements
.
startupInterrupted
1
)
;
Assert
.
equal
(
payload
.
simpleMeasurements
.
shutdownDuration
SHUTDOWN_TIME
)
;
Assert
.
ok
(
"
maximalNumberOfConcurrentThreads
"
in
payload
.
simpleMeasurements
)
;
Assert
.
ok
(
payload
.
simpleMeasurements
.
maximalNumberOfConcurrentThreads
>
=
gNumberOfThreadsLaunched
)
;
let
activeTicks
=
payload
.
simpleMeasurements
.
activeTicks
;
Assert
.
ok
(
activeTicks
>
=
0
)
;
if
(
"
browser
.
timings
.
last_shutdown
"
in
payload
.
processes
.
parent
.
scalars
)
{
Assert
.
equal
(
payload
.
processes
.
parent
.
scalars
[
"
browser
.
timings
.
last_shutdown
"
]
SHUTDOWN_TIME
)
;
}
Assert
.
equal
(
payload
.
simpleMeasurements
.
failedProfileLockCount
FAILED_PROFILE_LOCK_ATTEMPTS
)
;
let
profileDirectory
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
let
failedProfileLocksFile
=
profileDirectory
.
clone
(
)
;
failedProfileLocksFile
.
append
(
"
Telemetry
.
FailedProfileLocks
.
txt
"
)
;
Assert
.
ok
(
!
failedProfileLocksFile
.
exists
(
)
)
;
let
isWindows
=
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
in
Cc
)
;
if
(
isWindows
)
{
Assert
.
ok
(
payload
.
simpleMeasurements
.
startupSessionRestoreReadBytes
>
0
)
;
Assert
.
ok
(
payload
.
simpleMeasurements
.
startupSessionRestoreWriteBytes
>
0
)
;
}
const
TELEMETRY_SEND_SUCCESS
=
"
TELEMETRY_SEND_SUCCESS
"
;
const
TELEMETRY_SUCCESS
=
"
TELEMETRY_SUCCESS
"
;
const
TELEMETRY_TEST_FLAG
=
"
TELEMETRY_TEST_FLAG
"
;
const
TELEMETRY_TEST_COUNT
=
"
TELEMETRY_TEST_COUNT
"
;
const
TELEMETRY_TEST_KEYED_FLAG
=
"
TELEMETRY_TEST_KEYED_FLAG
"
;
const
TELEMETRY_TEST_KEYED_COUNT
=
"
TELEMETRY_TEST_KEYED_COUNT
"
;
if
(
successfulPings
>
0
)
{
Assert
.
ok
(
TELEMETRY_SEND_SUCCESS
in
payload
.
histograms
)
;
}
Assert
.
ok
(
TELEMETRY_TEST_FLAG
in
payload
.
histograms
)
;
Assert
.
ok
(
TELEMETRY_TEST_COUNT
in
payload
.
histograms
)
;
Assert
.
ok
(
!
(
IGNORE_CLONED_HISTOGRAM
in
payload
.
histograms
)
)
;
const
expected_flag
=
{
range
:
[
1
2
]
bucket_count
:
3
histogram_type
:
3
values
:
{
0
:
1
1
:
0
}
sum
:
0
}
;
let
flag
=
payload
.
histograms
[
TELEMETRY_TEST_FLAG
]
;
Assert
.
deepEqual
(
flag
expected_flag
)
;
const
expected_count
=
{
range
:
[
1
2
]
bucket_count
:
3
histogram_type
:
4
values
:
{
0
:
1
1
:
0
}
sum
:
1
}
;
let
count
=
payload
.
histograms
[
TELEMETRY_TEST_COUNT
]
;
Assert
.
deepEqual
(
count
expected_count
)
;
if
(
successfulPings
>
0
)
{
const
expected_tc
=
{
range
:
[
1
2
]
bucket_count
:
3
histogram_type
:
2
values
:
{
0
:
2
1
:
successfulPings
2
:
0
}
sum
:
successfulPings
}
;
let
tc
=
payload
.
histograms
[
TELEMETRY_SUCCESS
]
;
Assert
.
deepEqual
(
tc
expected_tc
)
;
}
Assert
.
ok
(
"
MEMORY_TOTAL
"
in
payload
.
histograms
)
;
Assert
.
ok
(
"
MEMORY_JS_GC_HEAP
"
in
payload
.
histograms
)
;
Assert
.
ok
(
"
MEMORY_JS_COMPARTMENTS_SYSTEM
"
in
payload
.
histograms
)
;
Assert
.
ok
(
(
"
mainThread
"
in
payload
.
slowSQL
)
&
&
(
"
otherThreads
"
in
payload
.
slowSQL
)
)
;
Assert
.
ok
(
(
"
IceCandidatesStats
"
in
payload
.
webrtc
)
&
&
(
"
webrtc
"
in
payload
.
webrtc
.
IceCandidatesStats
)
)
;
Assert
.
ok
(
"
keyedHistograms
"
in
payload
)
;
let
keyedHistograms
=
payload
.
keyedHistograms
;
Assert
.
ok
(
!
(
TELEMETRY_TEST_KEYED_FLAG
in
keyedHistograms
)
)
;
Assert
.
ok
(
TELEMETRY_TEST_KEYED_COUNT
in
keyedHistograms
)
;
const
expected_keyed_count
=
{
"
a
"
:
{
range
:
[
1
2
]
bucket_count
:
3
histogram_type
:
4
values
:
{
0
:
2
1
:
0
}
sum
:
2
}
"
b
"
:
{
range
:
[
1
2
]
bucket_count
:
3
histogram_type
:
4
values
:
{
0
:
1
1
:
0
}
sum
:
1
}
}
;
Assert
.
deepEqual
(
expected_keyed_count
keyedHistograms
[
TELEMETRY_TEST_KEYED_COUNT
]
)
;
Assert
.
ok
(
"
processes
"
in
payload
"
The
payload
must
have
a
processes
section
.
"
)
;
Assert
.
ok
(
"
parent
"
in
payload
.
processes
"
There
must
be
at
least
a
parent
process
.
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
prio
.
enabled
"
false
)
)
{
Assert
.
ok
(
"
prio
"
in
payload
"
The
payload
must
have
a
prio
section
.
"
)
;
}
checkScalars
(
payload
.
processes
)
;
}
function
writeStringToFile
(
file
contents
)
{
let
ostream
=
Cc
[
"
mozilla
.
org
/
network
/
safe
-
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
ostream
.
init
(
file
PR_WRONLY
|
PR_CREATE_FILE
|
PR_TRUNCATE
RW_OWNER
ostream
.
DEFER_OPEN
)
;
ostream
.
write
(
contents
contents
.
length
)
;
ostream
.
QueryInterface
(
Ci
.
nsISafeOutputStream
)
.
finish
(
)
;
ostream
.
close
(
)
;
}
function
write_fake_shutdown_file
(
)
{
let
profileDirectory
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
let
file
=
profileDirectory
.
clone
(
)
;
file
.
append
(
"
Telemetry
.
ShutdownTime
.
txt
"
)
;
let
contents
=
"
"
+
SHUTDOWN_TIME
;
writeStringToFile
(
file
contents
)
;
}
function
write_fake_failedprofilelocks_file
(
)
{
let
profileDirectory
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
let
file
=
profileDirectory
.
clone
(
)
;
file
.
append
(
"
Telemetry
.
FailedProfileLocks
.
txt
"
)
;
let
contents
=
"
"
+
FAILED_PROFILE_LOCK_ATTEMPTS
;
writeStringToFile
(
file
contents
)
;
}
add_task
(
async
function
test_setup
(
)
{
do_get_profile
(
)
;
loadAddonManager
(
APP_ID
APP_NAME
APP_VERSION
PLATFORM_VERSION
)
;
finishAddonManagerStartup
(
)
;
fakeIntlReady
(
)
;
await
setEmptyPrefWatchlist
(
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
write_fake_failedprofilelocks_file
(
)
;
write_fake_shutdown_file
(
)
;
let
currentMaxNumberOfThreads
=
Telemetry
.
maximalNumberOfConcurrentThreads
;
Assert
.
ok
(
currentMaxNumberOfThreads
>
0
)
;
let
threads
=
[
]
;
try
{
for
(
let
i
=
0
;
i
<
currentMaxNumberOfThreads
+
10
;
+
+
i
)
{
threads
.
push
(
Services
.
tm
.
newThread
(
0
)
)
;
}
}
catch
(
ex
)
{
}
gNumberOfThreadsLaunched
=
threads
.
length
;
Assert
.
ok
(
Telemetry
.
maximalNumberOfConcurrentThreads
>
=
gNumberOfThreadsLaunched
)
;
registerCleanupFunction
(
function
(
)
{
threads
.
forEach
(
function
(
thread
)
{
thread
.
shutdown
(
)
;
}
)
;
}
)
;
await
new
Promise
(
resolve
=
>
Telemetry
.
asyncFetchTelemetryData
(
wrapWithExceptionHandler
(
resolve
)
)
)
;
}
)
;
add_task
(
async
function
asyncSetup
(
)
{
await
TelemetryController
.
testSetup
(
)
;
gClientID
=
await
ClientID
.
getClientID
(
)
;
}
)
;
add_task
(
async
function
test_expiredHistogram
(
)
{
let
dummy
=
Telemetry
.
getHistogramById
(
"
TELEMETRY_TEST_EXPIRED
"
)
;
dummy
.
add
(
1
)
;
Assert
.
equal
(
TelemetrySession
.
getPayload
(
)
.
histograms
.
TELEMETRY_TEST_EXPIRED
undefined
)
;
}
)
;
add_task
(
async
function
test_noServerPing
(
)
{
await
sendPing
(
)
;
await
sendPing
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_simplePing
(
)
{
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
start
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
Server
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
let
now
=
new
Date
(
2020
1
1
12
5
6
)
;
let
expectedDate
=
new
Date
(
2020
1
1
12
0
0
)
;
fakeNow
(
now
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
5000
)
;
const
expectedSessionUUID
=
"
bd314d15
-
95bf
-
4356
-
b682
-
b6c4a8942202
"
;
const
expectedSubsessionUUID
=
"
3e2e5f6c
-
74ba
-
4e4d
-
a93f
-
a48af238a8c7
"
;
fakeGenerateUUID
(
(
)
=
>
expectedSessionUUID
(
)
=
>
expectedSubsessionUUID
)
;
await
TelemetryController
.
testReset
(
)
;
const
SESSION_DURATION_IN_MINUTES
=
15
;
fakeNow
(
new
Date
(
2020
1
1
12
SESSION_DURATION_IN_MINUTES
0
)
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
SESSION_DURATION_IN_MINUTES
*
60
*
1000
)
;
await
sendPing
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
PING_TYPE_MAIN
true
true
)
;
let
payload
=
ping
.
payload
;
Assert
.
equal
(
payload
.
info
.
sessionId
expectedSessionUUID
)
;
Assert
.
equal
(
payload
.
info
.
subsessionId
expectedSubsessionUUID
)
;
let
sessionStartDate
=
new
Date
(
payload
.
info
.
sessionStartDate
)
;
Assert
.
equal
(
sessionStartDate
.
toISOString
(
)
expectedDate
.
toISOString
(
)
)
;
let
subsessionStartDate
=
new
Date
(
payload
.
info
.
subsessionStartDate
)
;
Assert
.
equal
(
subsessionStartDate
.
toISOString
(
)
expectedDate
.
toISOString
(
)
)
;
Assert
.
equal
(
payload
.
info
.
subsessionLength
SESSION_DURATION_IN_MINUTES
*
60
)
;
fakeGenerateUUID
(
TelemetryUtils
.
generateUUID
TelemetryUtils
.
generateUUID
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_saveLoadPing
(
)
{
await
TelemetryStorage
.
testClearPendingPings
(
)
;
await
TelemetryController
.
testReset
(
)
;
PingServer
.
clearRequests
(
)
;
setupTestData
(
)
;
await
TelemetrySession
.
testSavePendingPing
(
)
;
await
sendPing
(
)
;
const
requests
=
await
PingServer
.
promiseNextRequests
(
2
)
;
for
(
let
req
of
requests
)
{
Assert
.
equal
(
req
.
getHeader
(
"
content
-
type
"
)
"
application
/
json
;
charset
=
UTF
-
8
"
"
The
request
must
have
the
correct
content
-
type
.
"
)
;
}
let
pings
=
Array
.
from
(
requests
decodeRequestPayload
)
;
if
(
pings
[
0
]
.
type
!
=
PING_TYPE_MAIN
)
{
pings
.
reverse
(
)
;
}
checkPingFormat
(
pings
[
0
]
PING_TYPE_MAIN
true
true
)
;
checkPayload
(
pings
[
0
]
.
payload
REASON_TEST_PING
0
)
;
checkPingFormat
(
pings
[
1
]
PING_TYPE_SAVED_SESSION
true
true
)
;
checkPayload
(
pings
[
1
]
.
payload
REASON_SAVED_SESSION
0
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_checkSubsessionScalars
(
)
{
if
(
gIsAndroid
)
{
return
;
}
Telemetry
.
clearScalars
(
)
;
await
TelemetryController
.
testReset
(
)
;
const
UINT_SCALAR
=
"
telemetry
.
test
.
unsigned_int_kind
"
;
const
STRING_SCALAR
=
"
telemetry
.
test
.
string_kind
"
;
let
expectedUint
=
37
;
let
expectedString
=
"
Test
value
.
Yay
.
"
;
Telemetry
.
scalarSet
(
UINT_SCALAR
expectedUint
)
;
Telemetry
.
scalarSet
(
STRING_SCALAR
expectedString
)
;
let
classic
=
TelemetrySession
.
getPayload
(
)
;
let
subsession
=
TelemetrySession
.
getPayload
(
"
environment
-
change
"
true
)
;
const
TEST_SCALARS
=
[
UINT_SCALAR
STRING_SCALAR
]
;
for
(
let
name
of
TEST_SCALARS
)
{
Assert
.
ok
(
name
in
subsession
.
processes
.
parent
.
scalars
name
+
"
must
be
reported
in
a
subsession
ping
.
"
)
;
}
Assert
.
ok
(
Object
.
keys
(
classic
.
processes
.
parent
.
scalars
)
.
length
=
=
0
"
Scalars
must
not
be
reported
in
a
classic
ping
.
"
)
;
Assert
.
equal
(
subsession
.
processes
.
parent
.
scalars
[
UINT_SCALAR
]
expectedUint
UINT_SCALAR
+
"
must
contain
the
expected
value
.
"
)
;
Assert
.
equal
(
subsession
.
processes
.
parent
.
scalars
[
STRING_SCALAR
]
expectedString
STRING_SCALAR
+
"
must
contain
the
expected
value
.
"
)
;
subsession
=
TelemetrySession
.
getPayload
(
"
environment
-
change
"
)
;
for
(
let
name
of
TEST_SCALARS
)
{
Assert
.
ok
(
!
(
name
in
subsession
.
processes
.
parent
.
scalars
)
name
+
"
must
be
cleared
with
the
new
subsession
.
"
)
;
}
expectedUint
=
85
;
expectedString
=
"
A
creative
different
value
"
;
Telemetry
.
scalarSet
(
UINT_SCALAR
expectedUint
)
;
Telemetry
.
scalarSet
(
STRING_SCALAR
expectedString
)
;
subsession
=
TelemetrySession
.
getPayload
(
"
environment
-
change
"
)
;
Assert
.
equal
(
subsession
.
processes
.
parent
.
scalars
[
UINT_SCALAR
]
expectedUint
UINT_SCALAR
+
"
must
contain
the
expected
value
.
"
)
;
Assert
.
equal
(
subsession
.
processes
.
parent
.
scalars
[
STRING_SCALAR
]
expectedString
STRING_SCALAR
+
"
must
contain
the
expected
value
.
"
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_dailyCollection
(
)
{
if
(
gIsAndroid
)
{
return
;
}
let
now
=
new
Date
(
2030
1
1
12
0
0
)
;
let
nowHour
=
new
Date
(
2030
1
1
12
0
0
)
;
let
schedulerTickCallback
=
null
;
PingServer
.
clearRequests
(
)
;
fakeNow
(
now
)
;
fakeSchedulerTimer
(
callback
=
>
schedulerTickCallback
=
callback
(
)
=
>
{
}
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
await
TelemetryController
.
testReset
(
)
;
TelemetrySend
.
setServer
(
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
const
COUNT_ID
=
"
TELEMETRY_TEST_COUNT
"
;
const
KEYED_ID
=
"
TELEMETRY_TEST_KEYED_COUNT
"
;
const
count
=
Telemetry
.
getHistogramById
(
COUNT_ID
)
;
const
keyed
=
Telemetry
.
getKeyedHistogramById
(
KEYED_ID
)
;
count
.
clear
(
)
;
keyed
.
clear
(
)
;
count
.
add
(
1
)
;
keyed
.
add
(
"
a
"
1
)
;
keyed
.
add
(
"
b
"
1
)
;
keyed
.
add
(
"
b
"
1
)
;
let
expectedDate
=
nowHour
;
now
=
futureDate
(
nowHour
MS_IN_ONE_DAY
)
;
fakeNow
(
now
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
await
schedulerTickCallback
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
ok
(
!
!
ping
)
;
Assert
.
equal
(
ping
.
type
PING_TYPE_MAIN
)
;
Assert
.
equal
(
ping
.
payload
.
info
.
reason
REASON_DAILY
)
;
let
subsessionStartDate
=
new
Date
(
ping
.
payload
.
info
.
subsessionStartDate
)
;
Assert
.
equal
(
subsessionStartDate
.
toISOString
(
)
expectedDate
.
toISOString
(
)
)
;
Assert
.
equal
(
ping
.
payload
.
histograms
[
COUNT_ID
]
.
sum
1
)
;
Assert
.
equal
(
ping
.
payload
.
keyedHistograms
[
KEYED_ID
]
.
a
.
sum
1
)
;
Assert
.
equal
(
ping
.
payload
.
keyedHistograms
[
KEYED_ID
]
.
b
.
sum
2
)
;
expectedDate
=
futureDate
(
expectedDate
MS_IN_ONE_DAY
)
;
now
=
futureDate
(
now
MS_IN_ONE_DAY
)
;
fakeNow
(
now
)
;
await
schedulerTickCallback
(
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
ok
(
!
!
ping
)
;
Assert
.
equal
(
ping
.
type
PING_TYPE_MAIN
)
;
Assert
.
equal
(
ping
.
payload
.
info
.
reason
REASON_DAILY
)
;
subsessionStartDate
=
new
Date
(
ping
.
payload
.
info
.
subsessionStartDate
)
;
Assert
.
equal
(
subsessionStartDate
.
toISOString
(
)
expectedDate
.
toISOString
(
)
)
;
Assert
.
ok
(
!
(
COUNT_ID
in
ping
.
payload
.
histograms
)
)
;
Assert
.
ok
(
!
(
KEYED_ID
in
ping
.
payload
.
keyedHistograms
)
)
;
count
.
add
(
1
)
;
keyed
.
add
(
"
a
"
1
)
;
keyed
.
add
(
"
b
"
1
)
;
expectedDate
=
futureDate
(
expectedDate
MS_IN_ONE_DAY
)
;
now
=
futureDate
(
now
MS_IN_ONE_DAY
)
;
fakeNow
(
now
)
;
await
schedulerTickCallback
(
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
ok
(
!
!
ping
)
;
Assert
.
equal
(
ping
.
type
PING_TYPE_MAIN
)
;
Assert
.
equal
(
ping
.
payload
.
info
.
reason
REASON_DAILY
)
;
subsessionStartDate
=
new
Date
(
ping
.
payload
.
info
.
subsessionStartDate
)
;
Assert
.
equal
(
subsessionStartDate
.
toISOString
(
)
expectedDate
.
toISOString
(
)
)
;
Assert
.
equal
(
ping
.
payload
.
histograms
[
COUNT_ID
]
.
sum
1
)
;
Assert
.
equal
(
ping
.
payload
.
keyedHistograms
[
KEYED_ID
]
.
a
.
sum
1
)
;
Assert
.
equal
(
ping
.
payload
.
keyedHistograms
[
KEYED_ID
]
.
b
.
sum
1
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_dailyDuplication
(
)
{
if
(
gIsAndroid
)
{
return
;
}
await
TelemetrySend
.
reset
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
let
schedulerTickCallback
=
null
;
let
now
=
new
Date
(
2030
1
1
0
0
0
)
;
fakeNow
(
now
)
;
fakeSchedulerTimer
(
callback
=
>
schedulerTickCallback
=
callback
(
)
=
>
{
}
)
;
await
TelemetryController
.
testReset
(
)
;
let
firstDailyDue
=
new
Date
(
2030
1
2
0
0
0
)
;
fakeNow
(
firstDailyDue
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
await
schedulerTickCallback
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
ok
(
!
!
ping
)
;
Assert
.
equal
(
ping
.
type
PING_TYPE_MAIN
)
;
Assert
.
equal
(
ping
.
payload
.
info
.
reason
REASON_DAILY
)
;
PingServer
.
registerPingHandler
(
(
req
res
)
=
>
{
Assert
.
ok
(
false
"
No
more
daily
pings
should
be
sent
/
received
in
this
test
.
"
)
;
}
)
;
let
secondDailyDue
=
new
Date
(
firstDailyDue
)
;
secondDailyDue
.
setHours
(
0
)
;
secondDailyDue
.
setMinutes
(
15
)
;
fakeNow
(
secondDailyDue
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
await
schedulerTickCallback
(
)
;
PingServer
.
resetPingHandler
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_dailyOverdue
(
)
{
if
(
gIsAndroid
)
{
return
;
}
let
schedulerTickCallback
=
null
;
let
now
=
new
Date
(
2030
1
1
11
0
0
)
;
fakeNow
(
now
)
;
fakeSchedulerTimer
(
callback
=
>
schedulerTickCallback
=
callback
(
)
=
>
{
}
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
await
TelemetryController
.
testReset
(
)
;
now
.
setHours
(
now
.
getHours
(
)
+
1
)
;
fakeNow
(
now
)
;
PingServer
.
registerPingHandler
(
(
req
res
)
=
>
{
Assert
.
ok
(
false
"
No
daily
ping
should
be
received
if
not
overdue
!
.
"
)
;
}
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
await
schedulerTickCallback
(
)
;
PingServer
.
resetPingHandler
(
)
;
PingServer
.
clearRequests
(
)
;
let
dailyOverdue
=
new
Date
(
2030
1
2
13
0
0
)
;
fakeNow
(
dailyOverdue
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
await
schedulerTickCallback
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
ok
(
!
!
ping
)
;
Assert
.
equal
(
ping
.
type
PING_TYPE_MAIN
)
;
Assert
.
equal
(
ping
.
payload
.
info
.
reason
REASON_DAILY
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_environmentChange
(
)
{
if
(
gIsAndroid
)
{
return
;
}
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
let
now
=
fakeNow
(
2040
1
1
12
0
0
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
10
*
MILLISECONDS_PER_MINUTE
)
;
const
PREF_TEST
=
"
toolkit
.
telemetry
.
test
.
pref1
"
;
Preferences
.
reset
(
PREF_TEST
)
;
const
PREFS_TO_WATCH
=
new
Map
(
[
[
PREF_TEST
{
what
:
TelemetryEnvironment
.
RECORD_PREF_VALUE
}
]
]
)
;
await
TelemetryController
.
testReset
(
)
;
TelemetrySend
.
setServer
(
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
await
TelemetryEnvironment
.
testWatchPreferences
(
PREFS_TO_WATCH
)
;
const
COUNT_ID
=
"
TELEMETRY_TEST_COUNT
"
;
const
KEYED_ID
=
"
TELEMETRY_TEST_KEYED_COUNT
"
;
const
count
=
Telemetry
.
getHistogramById
(
COUNT_ID
)
;
const
keyed
=
Telemetry
.
getKeyedHistogramById
(
KEYED_ID
)
;
count
.
clear
(
)
;
keyed
.
clear
(
)
;
count
.
add
(
1
)
;
keyed
.
add
(
"
a
"
1
)
;
keyed
.
add
(
"
b
"
1
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
10
*
MILLISECONDS_PER_MINUTE
)
;
let
startHour
=
TelemetryUtils
.
truncateToHours
(
now
)
;
now
=
fakeNow
(
futureDate
(
now
10
*
MILLISECONDS_PER_MINUTE
)
)
;
Preferences
.
set
(
PREF_TEST
1
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
ok
(
!
!
ping
)
;
Assert
.
equal
(
ping
.
type
PING_TYPE_MAIN
)
;
Assert
.
equal
(
ping
.
environment
.
settings
.
userPrefs
[
PREF_TEST
]
undefined
)
;
Assert
.
equal
(
ping
.
payload
.
info
.
reason
REASON_ENVIRONMENT_CHANGE
)
;
let
subsessionStartDate
=
new
Date
(
ping
.
payload
.
info
.
subsessionStartDate
)
;
Assert
.
equal
(
subsessionStartDate
.
toISOString
(
)
startHour
.
toISOString
(
)
)
;
Assert
.
equal
(
ping
.
payload
.
histograms
[
COUNT_ID
]
.
sum
1
)
;
Assert
.
equal
(
ping
.
payload
.
keyedHistograms
[
KEYED_ID
]
.
a
.
sum
1
)
;
startHour
=
TelemetryUtils
.
truncateToHours
(
now
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
10
*
MILLISECONDS_PER_MINUTE
)
;
now
=
fakeNow
(
futureDate
(
now
10
*
MILLISECONDS_PER_MINUTE
)
)
;
Preferences
.
set
(
PREF_TEST
2
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
ok
(
!
!
ping
)
;
Assert
.
equal
(
ping
.
type
PING_TYPE_MAIN
)
;
Assert
.
equal
(
ping
.
environment
.
settings
.
userPrefs
[
PREF_TEST
]
1
)
;
Assert
.
equal
(
ping
.
payload
.
info
.
reason
REASON_ENVIRONMENT_CHANGE
)
;
subsessionStartDate
=
new
Date
(
ping
.
payload
.
info
.
subsessionStartDate
)
;
Assert
.
equal
(
subsessionStartDate
.
toISOString
(
)
startHour
.
toISOString
(
)
)
;
Assert
.
ok
(
!
(
COUNT_ID
in
ping
.
payload
.
histograms
)
)
;
Assert
.
ok
(
!
(
KEYED_ID
in
ping
.
payload
.
keyedHistograms
)
)
;
startHour
=
TelemetryUtils
.
truncateToHours
(
now
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
10
*
MILLISECONDS_PER_MINUTE
)
;
now
=
fakeNow
(
futureDate
(
now
10
*
MILLISECONDS_PER_MINUTE
)
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
prio
.
enabled
"
false
)
)
{
fakePrioEncode
(
)
;
let
prioMeasures
=
[
"
BROWSER_IS_USER_DEFAULT
"
"
NEWTAB_PAGE_ENABLED
"
]
;
for
(
let
measure
of
prioMeasures
)
{
const
value
=
Telemetry
.
getHistogramById
(
measure
)
;
value
.
clear
(
)
;
value
.
add
(
1
)
;
}
let
expectedPrioResult
=
{
"
booleans
"
:
[
true
true
false
]
}
;
Preferences
.
set
(
PREF_TEST
3
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
ok
(
!
!
ping
)
;
Assert
.
deepEqual
(
ping
.
payload
.
prio
expectedPrioResult
)
;
}
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_experimentAnnotations_subsession
(
)
{
if
(
gIsAndroid
)
{
return
;
}
const
EXPERIMENT1
=
"
experiment
-
1
"
;
const
EXPERIMENT1_BRANCH
=
"
nice
-
branch
"
;
const
EXPERIMENT2
=
"
experiment
-
2
"
;
const
EXPERIMENT2_BRANCH
=
"
other
-
branch
"
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
let
now
=
fakeNow
(
2040
1
1
12
0
0
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
10
*
MILLISECONDS_PER_MINUTE
)
;
await
TelemetryController
.
testReset
(
)
;
TelemetrySend
.
setServer
(
"
http
:
/
/
localhost
:
"
+
PingServer
.
port
)
;
Assert
.
equal
(
TelemetrySession
.
getPayload
(
)
.
info
.
subsessionCounter
1
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
10
*
MILLISECONDS_PER_MINUTE
)
;
let
futureTestDate
=
futureDate
(
now
10
*
MILLISECONDS_PER_MINUTE
)
;
now
=
fakeNow
(
futureTestDate
)
;
TelemetryEnvironment
.
setExperimentActive
(
EXPERIMENT1
EXPERIMENT1_BRANCH
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
ok
(
!
!
ping
"
A
ping
must
be
received
.
"
)
;
Assert
.
equal
(
ping
.
type
PING_TYPE_MAIN
"
The
received
ping
must
be
a
'
main
'
ping
.
"
)
;
Assert
.
equal
(
ping
.
payload
.
info
.
reason
REASON_ENVIRONMENT_CHANGE
"
The
'
main
'
ping
must
be
triggered
by
a
change
in
the
environment
.
"
)
;
Assert
.
ok
(
!
(
"
experiments
"
in
ping
.
environment
)
"
The
old
environment
must
contain
no
active
experiments
.
"
)
;
Assert
.
equal
(
TelemetrySession
.
getPayload
(
)
.
info
.
subsessionCounter
2
"
The
experiment
annotation
must
trigger
a
new
subsession
.
"
)
;
TelemetryEnvironment
.
setExperimentActive
(
EXPERIMENT2
EXPERIMENT2_BRANCH
)
;
Assert
.
equal
(
TelemetrySession
.
getPayload
(
)
.
info
.
subsessionCounter
2
"
The
experiment
annotation
must
not
trigger
a
new
subsession
"
+
"
if
throttling
happens
.
"
)
;
let
oldExperiments
=
TelemetryEnvironment
.
getActiveExperiments
(
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
10
*
MILLISECONDS_PER_MINUTE
)
;
now
=
fakeNow
(
futureDate
(
now
10
*
MILLISECONDS_PER_MINUTE
)
)
;
TelemetryEnvironment
.
setExperimentInactive
(
EXPERIMENT1
EXPERIMENT1_BRANCH
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
ok
(
!
!
ping
"
A
ping
must
be
received
.
"
)
;
Assert
.
equal
(
ping
.
type
PING_TYPE_MAIN
"
The
received
ping
must
be
a
'
main
'
ping
.
"
)
;
Assert
.
equal
(
ping
.
payload
.
info
.
reason
REASON_ENVIRONMENT_CHANGE
"
The
'
main
'
ping
must
be
triggered
by
a
change
in
the
environment
.
"
)
;
Assert
.
deepEqual
(
ping
.
environment
.
experiments
oldExperiments
"
The
environment
must
contain
both
the
experiments
.
"
)
;
Assert
.
equal
(
TelemetrySession
.
getPayload
(
)
.
info
.
subsessionCounter
3
"
The
removing
an
experiment
annotation
must
trigger
a
new
subsession
.
"
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_savedPingsOnShutdown
(
)
{
await
TelemetryController
.
testReset
(
)
;
const
dir
=
TelemetryStorage
.
pingDirectoryPath
;
await
OS
.
File
.
removeDir
(
dir
{
ignoreAbsent
:
true
}
)
;
await
OS
.
File
.
makeDir
(
dir
)
;
await
TelemetryController
.
testShutdown
(
)
;
PingServer
.
clearRequests
(
)
;
await
TelemetryController
.
testReset
(
)
;
const
ping
=
await
PingServer
.
promiseNextPing
(
)
;
let
expectedType
=
gIsAndroid
?
PING_TYPE_SAVED_SESSION
:
PING_TYPE_MAIN
;
let
expectedReason
=
gIsAndroid
?
REASON_SAVED_SESSION
:
REASON_SHUTDOWN
;
checkPingFormat
(
ping
expectedType
true
true
)
;
Assert
.
equal
(
ping
.
payload
.
info
.
reason
expectedReason
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
)
;
}
)
;
add_task
(
async
function
test_sendShutdownPing
(
)
{
if
(
gIsAndroid
|
|
(
AppConstants
.
platform
=
=
"
linux
"
&
&
OS
.
Constants
.
Sys
.
bits
=
=
32
)
)
{
return
;
}
let
checkPendingShutdownPing
=
async
function
(
)
{
let
pendingPings
=
await
TelemetryStorage
.
loadPendingPingList
(
)
;
Assert
.
equal
(
pendingPings
.
length
1
"
We
expect
1
pending
ping
:
shutdown
.
"
)
;
const
shutdownPing
=
await
TelemetryStorage
.
loadPendingPing
(
pendingPings
[
0
]
.
id
)
;
Assert
.
ok
(
shutdownPing
"
The
'
shutdown
'
ping
must
be
saved
to
disk
.
"
)
;
Assert
.
equal
(
"
shutdown
"
shutdownPing
.
payload
.
info
.
reason
"
The
'
shutdown
'
ping
must
be
saved
to
disk
.
"
)
;
}
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
ShutdownPingSender
true
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FirstRun
false
)
;
TelemetryReportingPolicy
.
testUpdateFirstRun
(
)
;
PingServer
.
clearRequests
(
)
;
Telemetry
.
clearScalars
(
)
;
let
nextPing
=
PingServer
.
promiseNextPing
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
let
ping
=
await
nextPing
;
checkPingFormat
(
ping
ping
.
type
true
true
)
;
Assert
.
equal
(
ping
.
payload
.
info
.
reason
REASON_SHUTDOWN
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
)
;
PingServer
.
registerPingHandler
(
(
)
=
>
Assert
.
ok
(
false
"
Telemetry
must
not
send
pings
if
not
allowed
to
.
"
)
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
)
;
await
TelemetryController
.
testReset
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
quit
-
application
-
forced
"
)
;
await
TelemetryController
.
testShutdown
(
)
;
gClientID
=
await
ClientID
.
getClientID
(
)
;
await
checkPendingShutdownPing
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
Telemetry
.
clearScalars
(
)
;
await
TelemetryController
.
testReset
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
quit
-
application
-
granted
"
"
syncShutdown
"
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
checkPendingShutdownPing
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
BypassNotification
false
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
BypassNotification
true
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FirstRun
true
)
;
TelemetryReportingPolicy
.
testUpdateFirstRun
(
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
PingServer
.
resetPingHandler
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
ShutdownPingSenderFirstSession
true
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FirstRun
true
)
;
TelemetryReportingPolicy
.
testUpdateFirstRun
(
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
ping
.
type
true
true
)
;
Assert
.
equal
(
ping
.
payload
.
info
.
reason
REASON_SHUTDOWN
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
ShutdownPingSender
false
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
ShutdownPingSenderFirstSession
false
)
;
Preferences
.
reset
(
TelemetryUtils
.
Preferences
.
FirstRun
)
;
PingServer
.
resetPingHandler
(
)
;
}
)
;
add_task
(
async
function
test_sendFirstShutdownPing
(
)
{
if
(
gIsAndroid
|
|
(
AppConstants
.
platform
=
=
"
linux
"
&
&
OS
.
Constants
.
Sys
.
bits
=
=
32
)
)
{
return
;
}
let
storageContainsFirstShutdown
=
async
function
(
)
{
let
pendingPings
=
await
TelemetryStorage
.
loadPendingPingList
(
)
;
let
pings
=
await
Promise
.
all
(
pendingPings
.
map
(
async
(
p
)
=
>
{
return
TelemetryStorage
.
loadPendingPing
(
p
.
id
)
;
}
)
)
;
return
pings
.
find
(
p
=
>
p
.
type
=
=
"
first
-
shutdown
"
)
;
}
;
let
checkShutdownNotSent
=
async
function
(
)
{
PingServer
.
registerPingHandler
(
(
req
res
)
=
>
{
const
receivedPing
=
decodeRequestPayload
(
req
)
;
Assert
.
ok
(
false
No
ping
should
be
received
in
this
test
(
got
{
receivedPing
.
id
}
)
.
)
;
}
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FirstRun
true
)
;
TelemetryReportingPolicy
.
testUpdateFirstRun
(
)
;
await
TelemetryController
.
testReset
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
quit
-
application
-
forced
"
)
;
await
TelemetryController
.
testShutdown
(
)
;
Assert
.
ok
(
await
storageContainsFirstShutdown
(
)
"
The
'
first
-
shutdown
'
ping
must
be
saved
to
disk
.
"
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FirstRun
false
)
;
TelemetryReportingPolicy
.
testUpdateFirstRun
(
)
;
await
TelemetryController
.
testReset
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
quit
-
application
-
forced
"
)
;
await
TelemetryController
.
testShutdown
(
)
;
Assert
.
ok
(
!
(
await
storageContainsFirstShutdown
(
)
)
"
The
'
first
-
shutdown
'
ping
should
only
be
written
during
first
run
.
"
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FirstRun
true
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FirstShutdownPingEnabled
false
)
;
TelemetryReportingPolicy
.
testUpdateFirstRun
(
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
Assert
.
ok
(
!
(
await
storageContainsFirstShutdown
(
)
)
"
The
'
first
-
shutdown
'
ping
should
only
be
written
if
enabled
"
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FirstShutdownPingEnabled
true
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
ShutdownPingSender
false
)
;
TelemetryReportingPolicy
.
testUpdateFirstRun
(
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
Assert
.
ok
(
!
(
await
storageContainsFirstShutdown
(
)
)
"
The
'
first
-
shutdown
'
ping
should
only
be
written
if
ping
-
sender
is
enabled
"
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
PingServer
.
resetPingHandler
(
)
;
}
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
Telemetry
.
clearScalars
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
ShutdownPingSender
true
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
ShutdownPingSenderFirstSession
false
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FirstShutdownPingEnabled
true
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FirstRun
true
)
;
TelemetryReportingPolicy
.
testUpdateFirstRun
(
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
"
first
-
shutdown
"
true
true
)
;
Assert
.
equal
(
ping
.
payload
.
info
.
reason
REASON_SHUTDOWN
)
;
Assert
.
equal
(
ping
.
clientId
gClientID
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
await
checkShutdownNotSent
(
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
ShutdownPingSender
false
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
ShutdownPingSenderFirstSession
false
)
;
Preferences
.
set
(
TelemetryUtils
.
Preferences
.
FirstShutdownPingEnabled
false
)
;
Preferences
.
reset
(
TelemetryUtils
.
Preferences
.
FirstRun
)
;
PingServer
.
resetPingHandler
(
)
;
}
)
;
add_task
(
async
function
test_savedSessionData
(
)
{
await
OS
.
File
.
makeDir
(
DATAREPORTING_PATH
)
;
getHistogram
(
"
TELEMETRY_SESSIONDATA_FAILED_LOAD
"
)
.
clear
(
)
;
getHistogram
(
"
TELEMETRY_SESSIONDATA_FAILED_PARSE
"
)
.
clear
(
)
;
getHistogram
(
"
TELEMETRY_SESSIONDATA_FAILED_VALIDATION
"
)
.
clear
(
)
;
const
dataFilePath
=
OS
.
Path
.
join
(
DATAREPORTING_PATH
"
session
-
state
.
json
"
)
;
const
sessionState
=
{
sessionId
:
null
subsessionId
:
null
profileSubsessionCounter
:
3785
}
;
await
CommonUtils
.
writeJSON
(
sessionState
dataFilePath
)
;
const
PREF_TEST
=
"
toolkit
.
telemetry
.
test
.
pref1
"
;
Preferences
.
reset
(
PREF_TEST
)
;
const
PREFS_TO_WATCH
=
new
Map
(
[
[
PREF_TEST
{
what
:
TelemetryEnvironment
.
RECORD_PREF_VALUE
}
]
]
)
;
const
expectedSubsessions
=
sessionState
.
profileSubsessionCounter
+
2
;
const
expectedSessionUUID
=
"
ff602e52
-
47a1
-
b7e8
-
4c1a
-
ffffffffc87a
"
;
const
expectedSubsessionUUID
=
"
009fd1ad
-
b85e
-
4817
-
b3e5
-
000000003785
"
;
fakeGenerateUUID
(
(
)
=
>
expectedSessionUUID
(
)
=
>
expectedSubsessionUUID
)
;
if
(
gIsAndroid
)
{
return
;
}
await
TelemetryController
.
testReset
(
)
;
Assert
.
equal
(
0
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_LOAD
"
)
.
sum
)
;
Assert
.
equal
(
0
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_PARSE
"
)
.
sum
)
;
Assert
.
equal
(
0
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_VALIDATION
"
)
.
sum
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
10
*
MILLISECONDS_PER_MINUTE
)
;
fakeNow
(
new
Date
(
2050
1
1
12
0
0
)
)
;
await
TelemetryEnvironment
.
testWatchPreferences
(
PREFS_TO_WATCH
)
;
let
changePromise
=
new
Promise
(
resolve
=
>
TelemetryEnvironment
.
registerChangeListener
(
"
test_fake_change
"
resolve
)
)
;
Preferences
.
set
(
PREF_TEST
1
)
;
await
changePromise
;
TelemetryEnvironment
.
unregisterChangeListener
(
"
test_fake_change
"
)
;
let
payload
=
TelemetrySession
.
getPayload
(
)
;
Assert
.
equal
(
payload
.
info
.
profileSubsessionCounter
expectedSubsessions
)
;
await
TelemetryController
.
testShutdown
(
)
;
fakeGenerateUUID
(
TelemetryUtils
.
generateUUID
TelemetryUtils
.
generateUUID
)
;
let
data
=
await
CommonUtils
.
readJSON
(
dataFilePath
)
;
Assert
.
equal
(
data
.
profileSubsessionCounter
expectedSubsessions
)
;
Assert
.
equal
(
data
.
sessionId
expectedSessionUUID
)
;
Assert
.
equal
(
data
.
subsessionId
expectedSubsessionUUID
)
;
}
)
;
add_task
(
async
function
test_sessionData_ShortSession
(
)
{
if
(
gIsAndroid
)
{
return
;
}
const
SESSION_STATE_PATH
=
OS
.
Path
.
join
(
DATAREPORTING_PATH
"
session
-
state
.
json
"
)
;
await
OS
.
File
.
remove
(
SESSION_STATE_PATH
{
ignoreAbsent
:
true
}
)
;
getHistogram
(
"
TELEMETRY_SESSIONDATA_FAILED_LOAD
"
)
.
clear
(
)
;
getHistogram
(
"
TELEMETRY_SESSIONDATA_FAILED_PARSE
"
)
.
clear
(
)
;
getHistogram
(
"
TELEMETRY_SESSIONDATA_FAILED_VALIDATION
"
)
.
clear
(
)
;
const
expectedSessionUUID
=
"
ff602e52
-
47a1
-
b7e8
-
4c1a
-
ffffffffc87a
"
;
const
expectedSubsessionUUID
=
"
009fd1ad
-
b85e
-
4817
-
b3e5
-
000000003785
"
;
fakeGenerateUUID
(
(
)
=
>
expectedSessionUUID
(
)
=
>
expectedSubsessionUUID
)
;
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
Assert
.
equal
(
1
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_LOAD
"
)
.
sum
)
;
Assert
.
equal
(
0
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_PARSE
"
)
.
sum
)
;
Assert
.
equal
(
0
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_VALIDATION
"
)
.
sum
)
;
fakeGenerateUUID
(
TelemetryUtils
.
generateUUID
TelemetryUtils
.
generateUUID
)
;
await
TelemetryController
.
testReset
(
)
;
let
payload
=
TelemetrySession
.
getPayload
(
)
;
Assert
.
equal
(
payload
.
info
.
profileSubsessionCounter
2
)
;
Assert
.
equal
(
payload
.
info
.
previousSessionId
expectedSessionUUID
)
;
Assert
.
equal
(
payload
.
info
.
previousSubsessionId
expectedSubsessionUUID
)
;
Assert
.
equal
(
1
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_LOAD
"
)
.
sum
)
;
Assert
.
equal
(
0
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_PARSE
"
)
.
sum
)
;
Assert
.
equal
(
0
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_VALIDATION
"
)
.
sum
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_invalidSessionData
(
)
{
await
OS
.
File
.
makeDir
(
DATAREPORTING_PATH
)
;
getHistogram
(
"
TELEMETRY_SESSIONDATA_FAILED_LOAD
"
)
.
clear
(
)
;
getHistogram
(
"
TELEMETRY_SESSIONDATA_FAILED_PARSE
"
)
.
clear
(
)
;
getHistogram
(
"
TELEMETRY_SESSIONDATA_FAILED_VALIDATION
"
)
.
clear
(
)
;
const
dataFilePath
=
OS
.
Path
.
join
(
DATAREPORTING_PATH
"
session
-
state
.
json
"
)
;
const
unparseableData
=
"
{
asdf
:
"
;
OS
.
File
.
writeAtomic
(
dataFilePath
unparseableData
{
encoding
:
"
utf
-
8
"
tmpPath
:
dataFilePath
+
"
.
tmp
"
}
)
;
await
TelemetryController
.
testReset
(
)
;
Assert
.
equal
(
0
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_LOAD
"
)
.
sum
)
;
Assert
.
equal
(
1
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_PARSE
"
)
.
sum
)
;
Assert
.
equal
(
0
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_VALIDATION
"
)
.
sum
)
;
const
sessionState
=
{
profileSubsessionCounter
:
"
not
-
a
-
number
?
"
someOtherField
:
12
}
;
await
CommonUtils
.
writeJSON
(
sessionState
dataFilePath
)
;
const
expectedSubsessions
=
1
;
const
expectedSessionUUID
=
"
ff602e52
-
47a1
-
b7e8
-
4c1a
-
ffffffffc87a
"
;
const
expectedSubsessionUUID
=
"
009fd1ad
-
b85e
-
4817
-
b3e5
-
000000003785
"
;
fakeGenerateUUID
(
(
)
=
>
expectedSessionUUID
(
)
=
>
expectedSubsessionUUID
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryController
.
testReset
(
)
;
let
payload
=
TelemetrySession
.
getPayload
(
)
;
Assert
.
equal
(
payload
.
info
.
profileSubsessionCounter
expectedSubsessions
)
;
Assert
.
equal
(
0
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_LOAD
"
)
.
sum
)
;
Assert
.
equal
(
1
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_PARSE
"
)
.
sum
)
;
Assert
.
equal
(
1
getSnapshot
(
"
TELEMETRY_SESSIONDATA_FAILED_VALIDATION
"
)
.
sum
)
;
await
TelemetryController
.
testShutdown
(
)
;
fakeGenerateUUID
(
TelemetryUtils
.
generateUUID
TelemetryUtils
.
generateUUID
)
;
let
data
=
await
CommonUtils
.
readJSON
(
dataFilePath
)
;
Assert
.
equal
(
data
.
profileSubsessionCounter
expectedSubsessions
)
;
Assert
.
equal
(
data
.
sessionId
expectedSessionUUID
)
;
Assert
.
equal
(
data
.
subsessionId
expectedSubsessionUUID
)
;
}
)
;
add_task
(
async
function
test_abortedSession
(
)
{
if
(
gIsAndroid
)
{
return
;
}
const
ABORTED_FILE
=
OS
.
Path
.
join
(
DATAREPORTING_PATH
ABORTED_PING_FILE_NAME
)
;
await
OS
.
File
.
removeDir
(
DATAREPORTING_PATH
{
ignoreAbsent
:
true
}
)
;
let
schedulerTickCallback
=
null
;
let
now
=
new
Date
(
2040
1
1
0
0
0
)
;
fakeNow
(
now
)
;
fakeSchedulerTimer
(
callback
=
>
schedulerTickCallback
=
callback
(
)
=
>
{
}
)
;
await
TelemetryController
.
testReset
(
)
;
Assert
.
ok
(
(
await
OS
.
File
.
exists
(
DATAREPORTING_PATH
)
)
"
Telemetry
must
create
the
aborted
session
directory
when
starting
.
"
)
;
now
=
futureDate
(
now
ABORTED_SESSION_UPDATE_INTERVAL_MS
)
;
fakeNow
(
now
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
await
schedulerTickCallback
(
)
;
Assert
.
ok
(
(
await
OS
.
File
.
exists
(
ABORTED_FILE
)
)
"
There
must
be
an
aborted
session
ping
.
"
)
;
let
pingContent
=
await
OS
.
File
.
read
(
ABORTED_FILE
{
encoding
:
"
utf
-
8
"
}
)
;
let
abortedSessionPing
=
JSON
.
parse
(
pingContent
)
;
checkPingFormat
(
abortedSessionPing
PING_TYPE_MAIN
true
true
)
;
Assert
.
equal
(
abortedSessionPing
.
payload
.
info
.
reason
REASON_ABORTED_SESSION
)
;
now
=
futureDate
(
now
ABORTED_SESSION_UPDATE_INTERVAL_MS
)
;
fakeNow
(
now
)
;
await
schedulerTickCallback
(
)
;
pingContent
=
await
OS
.
File
.
read
(
ABORTED_FILE
{
encoding
:
"
utf
-
8
"
}
)
;
let
updatedAbortedSessionPing
=
JSON
.
parse
(
pingContent
)
;
checkPingFormat
(
updatedAbortedSessionPing
PING_TYPE_MAIN
true
true
)
;
Assert
.
equal
(
updatedAbortedSessionPing
.
payload
.
info
.
reason
REASON_ABORTED_SESSION
)
;
Assert
.
notEqual
(
abortedSessionPing
.
id
updatedAbortedSessionPing
.
id
)
;
Assert
.
notEqual
(
abortedSessionPing
.
creationDate
updatedAbortedSessionPing
.
creationDate
)
;
await
TelemetryController
.
testShutdown
(
)
;
Assert
.
ok
(
!
(
await
OS
.
File
.
exists
(
ABORTED_FILE
)
)
"
No
aborted
session
ping
must
be
available
after
a
shutdown
.
"
)
;
}
)
;
add_task
(
async
function
test_abortedSession_Shutdown
(
)
{
if
(
gIsAndroid
)
{
return
;
}
const
ABORTED_FILE
=
OS
.
Path
.
join
(
DATAREPORTING_PATH
ABORTED_PING_FILE_NAME
)
;
let
schedulerTickCallback
=
null
;
let
now
=
fakeNow
(
2040
1
1
0
0
0
)
;
fakeSchedulerTimer
(
callback
=
>
schedulerTickCallback
=
callback
(
)
=
>
{
}
)
;
await
TelemetryController
.
testReset
(
)
;
Assert
.
ok
(
(
await
OS
.
File
.
exists
(
DATAREPORTING_PATH
)
)
"
Telemetry
must
create
the
aborted
session
directory
when
starting
.
"
)
;
fakeNow
(
futureDate
(
now
ABORTED_SESSION_UPDATE_INTERVAL_MS
)
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
await
schedulerTickCallback
(
)
;
Assert
.
ok
(
(
await
OS
.
File
.
exists
(
ABORTED_FILE
)
)
"
There
must
be
an
aborted
session
ping
.
"
)
;
await
OS
.
File
.
remove
(
ABORTED_FILE
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_abortedDailyCoalescing
(
)
{
if
(
gIsAndroid
)
{
return
;
}
const
ABORTED_FILE
=
OS
.
Path
.
join
(
DATAREPORTING_PATH
ABORTED_PING_FILE_NAME
)
;
await
OS
.
File
.
removeDir
(
DATAREPORTING_PATH
{
ignoreAbsent
:
true
}
)
;
let
schedulerTickCallback
=
null
;
PingServer
.
clearRequests
(
)
;
let
nowDate
=
new
Date
(
2009
10
18
0
0
0
)
;
fakeNow
(
nowDate
)
;
fakeSchedulerTimer
(
callback
=
>
schedulerTickCallback
=
callback
(
)
=
>
{
}
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
await
TelemetryController
.
testReset
(
)
;
Assert
.
ok
(
(
await
OS
.
File
.
exists
(
DATAREPORTING_PATH
)
)
"
Telemetry
must
create
the
aborted
session
directory
when
starting
.
"
)
;
let
dailyDueDate
=
futureDate
(
nowDate
MS_IN_ONE_DAY
)
;
fakeNow
(
dailyDueDate
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
await
schedulerTickCallback
(
)
;
let
dailyPing
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
dailyPing
.
payload
.
info
.
reason
REASON_DAILY
)
;
Assert
.
ok
(
(
await
OS
.
File
.
exists
(
ABORTED_FILE
)
)
"
There
must
be
an
aborted
session
ping
.
"
)
;
let
pingContent
=
await
OS
.
File
.
read
(
ABORTED_FILE
{
encoding
:
"
utf
-
8
"
}
)
;
let
abortedSessionPing
=
JSON
.
parse
(
pingContent
)
;
Assert
.
equal
(
abortedSessionPing
.
payload
.
info
.
sessionId
dailyPing
.
payload
.
info
.
sessionId
)
;
Assert
.
equal
(
abortedSessionPing
.
payload
.
info
.
subsessionId
dailyPing
.
payload
.
info
.
subsessionId
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_schedulerComputerSleep
(
)
{
if
(
gIsAndroid
)
{
return
;
}
const
ABORTED_FILE
=
OS
.
Path
.
join
(
DATAREPORTING_PATH
ABORTED_PING_FILE_NAME
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
await
OS
.
File
.
removeDir
(
DATAREPORTING_PATH
{
ignoreAbsent
:
true
}
)
;
let
nowDate
=
fakeNow
(
2009
10
18
0
0
0
)
;
let
schedulerTickCallback
=
null
;
fakeSchedulerTimer
(
callback
=
>
schedulerTickCallback
=
callback
(
)
=
>
{
}
)
;
await
TelemetryController
.
testReset
(
)
;
nowDate
=
fakeNow
(
futureDate
(
nowDate
3
*
MS_IN_ONE_DAY
)
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
await
schedulerTickCallback
(
)
;
let
dailyPing
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
dailyPing
.
payload
.
info
.
reason
REASON_DAILY
"
The
wake
notification
should
have
triggered
a
daily
ping
.
"
)
;
Assert
.
equal
(
dailyPing
.
creationDate
nowDate
.
toISOString
(
)
"
The
daily
ping
date
should
be
correct
.
"
)
;
Assert
.
ok
(
(
await
OS
.
File
.
exists
(
ABORTED_FILE
)
)
"
There
must
be
an
aborted
session
ping
.
"
)
;
nowDate
=
fakeNow
(
futureDate
(
nowDate
1
*
MS_IN_ONE_DAY
)
)
;
Services
.
obs
.
notifyObservers
(
null
"
wake_notification
"
)
;
dailyPing
=
await
PingServer
.
promiseNextPing
(
)
;
Assert
.
equal
(
dailyPing
.
payload
.
info
.
reason
REASON_DAILY
"
The
wake
notification
should
have
triggered
a
daily
ping
.
"
)
;
Assert
.
equal
(
dailyPing
.
creationDate
nowDate
.
toISOString
(
)
"
The
daily
ping
date
should
be
correct
.
"
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_schedulerEnvironmentReschedules
(
)
{
if
(
gIsAndroid
)
{
return
;
}
const
PREF_TEST
=
"
toolkit
.
telemetry
.
test
.
pref1
"
;
Preferences
.
reset
(
PREF_TEST
)
;
const
PREFS_TO_WATCH
=
new
Map
(
[
[
PREF_TEST
{
what
:
TelemetryEnvironment
.
RECORD_PREF_VALUE
}
]
]
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
let
nowDate
=
fakeNow
(
2060
10
18
0
0
0
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
10
*
MILLISECONDS_PER_MINUTE
)
;
let
schedulerTickCallback
=
null
;
fakeSchedulerTimer
(
callback
=
>
schedulerTickCallback
=
callback
(
)
=
>
{
}
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryEnvironment
.
testWatchPreferences
(
PREFS_TO_WATCH
)
;
fakeNow
(
futureDate
(
nowDate
MS_IN_ONE_DAY
)
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
10
*
MILLISECONDS_PER_MINUTE
)
;
Preferences
.
set
(
PREF_TEST
1
)
;
await
PingServer
.
promiseNextPing
(
)
;
PingServer
.
registerPingHandler
(
(
req
res
)
=
>
{
const
receivedPing
=
decodeRequestPayload
(
req
)
;
Assert
.
ok
(
false
No
ping
should
be
received
in
this
test
(
got
{
receivedPing
.
id
}
)
.
)
;
}
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
await
schedulerTickCallback
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_schedulerNothingDue
(
)
{
if
(
gIsAndroid
)
{
return
;
}
const
ABORTED_FILE
=
OS
.
Path
.
join
(
DATAREPORTING_PATH
ABORTED_PING_FILE_NAME
)
;
await
OS
.
File
.
removeDir
(
DATAREPORTING_PATH
{
ignoreAbsent
:
true
}
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
await
TelemetryController
.
testReset
(
)
;
PingServer
.
registerPingHandler
(
(
req
res
)
=
>
{
const
receivedPing
=
decodeRequestPayload
(
req
)
;
Assert
.
ok
(
false
No
ping
should
be
received
in
this
test
(
got
{
receivedPing
.
id
}
)
.
)
;
}
)
;
let
nowDate
=
new
Date
(
2009
10
18
11
0
0
)
;
fakeNow
(
nowDate
)
;
let
schedulerTickCallback
=
null
;
fakeSchedulerTimer
(
callback
=
>
schedulerTickCallback
=
callback
(
)
=
>
{
}
)
;
await
TelemetryController
.
testReset
(
)
;
let
nothingDueDate
=
futureDate
(
nowDate
ABORTED_SESSION_UPDATE_INTERVAL_MS
/
2
)
;
fakeNow
(
nothingDueDate
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
await
schedulerTickCallback
(
)
;
Assert
.
ok
(
!
(
await
OS
.
File
.
exists
(
ABORTED_FILE
)
)
)
;
await
TelemetryController
.
testShutdown
(
)
;
PingServer
.
resetPingHandler
(
)
;
}
)
;
add_task
(
async
function
test_pingExtendedStats
(
)
{
const
EXTENDED_PAYLOAD_FIELDS
=
[
"
log
"
"
slowSQL
"
"
fileIOReports
"
"
lateWrites
"
"
addonDetails
"
"
webrtc
"
]
;
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
EXTENDED_PAYLOAD_FIELDS
.
push
(
"
UIMeasurements
"
)
;
}
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
await
TelemetryController
.
testReset
(
)
;
Telemetry
.
canRecordExtended
=
false
;
await
sendPing
(
)
;
let
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
PING_TYPE_MAIN
true
true
)
;
for
(
let
f
in
EXTENDED_PAYLOAD_FIELDS
)
{
Assert
.
ok
(
!
(
EXTENDED_PAYLOAD_FIELDS
[
f
]
in
ping
.
payload
)
EXTENDED_PAYLOAD_FIELDS
[
f
]
+
"
must
not
be
in
the
payload
if
the
extended
set
is
off
.
"
)
;
}
Assert
.
ok
(
!
(
"
slowSQLStartup
"
in
ping
.
payload
)
"
slowSQLStartup
must
not
be
sent
if
the
extended
set
is
off
"
)
;
Assert
.
ok
(
!
(
"
addonManager
"
in
ping
.
payload
.
simpleMeasurements
)
"
addonManager
must
not
be
sent
if
the
extended
set
is
off
.
"
)
;
Assert
.
ok
(
!
(
"
UITelemetry
"
in
ping
.
payload
.
simpleMeasurements
)
"
UITelemetry
must
not
be
sent
.
"
)
;
Telemetry
.
canRecordExtended
=
true
;
await
sendPing
(
)
;
ping
=
await
PingServer
.
promiseNextPing
(
)
;
checkPingFormat
(
ping
PING_TYPE_MAIN
true
true
)
;
for
(
let
f
in
EXTENDED_PAYLOAD_FIELDS
)
{
Assert
.
ok
(
EXTENDED_PAYLOAD_FIELDS
[
f
]
in
ping
.
payload
EXTENDED_PAYLOAD_FIELDS
[
f
]
+
"
must
be
in
the
payload
if
the
extended
set
is
on
.
"
)
;
}
Assert
.
ok
(
"
addonManager
"
in
ping
.
payload
.
simpleMeasurements
"
addonManager
must
be
sent
if
the
extended
set
is
on
.
"
)
;
Assert
.
ok
(
!
(
"
UITelemetry
"
in
ping
.
payload
.
simpleMeasurements
)
"
UITelemetry
must
not
be
sent
.
"
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_schedulerUserIdle
(
)
{
if
(
gIsAndroid
)
{
return
;
}
const
SCHEDULER_TICK_INTERVAL_MS
=
5
*
60
*
1000
;
const
SCHEDULER_TICK_IDLE_INTERVAL_MS
=
60
*
60
*
1000
;
let
now
=
new
Date
(
2010
1
1
11
0
0
)
;
fakeNow
(
now
)
;
let
schedulerTimeout
=
0
;
fakeSchedulerTimer
(
(
callback
timeout
)
=
>
{
schedulerTimeout
=
timeout
;
}
(
)
=
>
{
}
)
;
await
TelemetryController
.
testReset
(
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
Assert
.
equal
(
schedulerTimeout
SCHEDULER_TICK_INTERVAL_MS
)
;
fakeIdleNotification
(
"
idle
"
)
;
Assert
.
equal
(
schedulerTimeout
SCHEDULER_TICK_IDLE_INTERVAL_MS
)
;
await
fakeIdleNotification
(
"
active
"
)
;
Assert
.
equal
(
schedulerTimeout
SCHEDULER_TICK_INTERVAL_MS
)
;
now
.
setHours
(
23
)
;
now
.
setMinutes
(
50
)
;
fakeNow
(
now
)
;
fakeIdleNotification
(
"
idle
"
)
;
Assert
.
equal
(
schedulerTimeout
10
*
60
*
1000
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_DailyDueAndIdle
(
)
{
if
(
gIsAndroid
)
{
return
;
}
await
TelemetryStorage
.
testClearPendingPings
(
)
;
PingServer
.
clearRequests
(
)
;
let
receivedPingRequest
=
null
;
PingServer
.
registerPingHandler
(
req
=
>
{
Assert
.
ok
(
!
receivedPingRequest
"
Telemetry
must
only
send
one
daily
ping
.
"
)
;
receivedPingRequest
=
req
;
}
)
;
let
schedulerTickCallback
=
null
;
let
now
=
new
Date
(
2030
1
1
0
0
0
)
;
fakeNow
(
now
)
;
fakeSchedulerTimer
(
callback
=
>
schedulerTickCallback
=
callback
(
)
=
>
{
}
)
;
await
TelemetryController
.
testReset
(
)
;
let
firstDailyDue
=
new
Date
(
2030
1
2
0
0
0
)
;
fakeNow
(
firstDailyDue
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
let
tickPromise
=
schedulerTickCallback
(
)
;
fakeIdleNotification
(
"
idle
"
)
;
fakeIdleNotification
(
"
active
"
)
;
await
tickPromise
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
Assert
.
ok
(
receivedPingRequest
"
Telemetry
must
send
one
daily
ping
.
"
)
;
const
receivedPing
=
decodeRequestPayload
(
receivedPingRequest
)
;
checkPingFormat
(
receivedPing
PING_TYPE_MAIN
true
true
)
;
Assert
.
equal
(
receivedPing
.
payload
.
info
.
reason
REASON_DAILY
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_userIdleAndSchedlerTick
(
)
{
if
(
gIsAndroid
)
{
return
;
}
let
receivedPingRequest
=
null
;
PingServer
.
registerPingHandler
(
req
=
>
{
Assert
.
ok
(
!
receivedPingRequest
"
Telemetry
must
only
send
one
daily
ping
.
"
)
;
receivedPingRequest
=
req
;
}
)
;
let
schedulerTickCallback
=
null
;
let
now
=
new
Date
(
2030
1
1
0
0
0
)
;
fakeNow
(
now
)
;
fakeSchedulerTimer
(
callback
=
>
schedulerTickCallback
=
callback
(
)
=
>
{
}
)
;
await
TelemetryStorage
.
testClearPendingPings
(
)
;
await
TelemetryController
.
testReset
(
)
;
PingServer
.
clearRequests
(
)
;
let
firstDailyDue
=
new
Date
(
2030
1
2
0
0
0
)
;
fakeNow
(
firstDailyDue
)
;
fakeIdleNotification
(
"
active
"
)
;
Assert
.
ok
(
!
!
schedulerTickCallback
)
;
await
schedulerTickCallback
(
)
;
fakeIdleNotification
(
"
idle
"
)
;
await
TelemetrySend
.
testWaitOnOutgoingPings
(
)
;
Assert
.
ok
(
receivedPingRequest
"
Telemetry
must
send
one
daily
ping
.
"
)
;
const
receivedPing
=
decodeRequestPayload
(
receivedPingRequest
)
;
checkPingFormat
(
receivedPing
PING_TYPE_MAIN
true
true
)
;
Assert
.
equal
(
receivedPing
.
payload
.
info
.
reason
REASON_DAILY
)
;
PingServer
.
resetPingHandler
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
test_changeThrottling
(
)
{
if
(
gIsAndroid
)
{
return
;
}
let
getSubsessionCount
=
(
)
=
>
{
return
TelemetrySession
.
getPayload
(
)
.
info
.
subsessionCounter
;
}
;
const
PREF_TEST
=
"
toolkit
.
telemetry
.
test
.
pref1
"
;
const
PREFS_TO_WATCH
=
new
Map
(
[
[
PREF_TEST
{
what
:
TelemetryEnvironment
.
RECORD_PREF_STATE
}
]
]
)
;
Preferences
.
reset
(
PREF_TEST
)
;
let
now
=
fakeNow
(
2050
1
2
0
0
0
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
10
*
MILLISECONDS_PER_MINUTE
)
;
await
TelemetryController
.
testReset
(
)
;
Assert
.
equal
(
getSubsessionCount
(
)
1
)
;
await
TelemetryEnvironment
.
testWatchPreferences
(
PREFS_TO_WATCH
)
;
Preferences
.
set
(
PREF_TEST
1
)
;
Assert
.
equal
(
getSubsessionCount
(
)
1
)
;
fakeNow
(
futureDate
(
now
5
*
MILLISECONDS_PER_MINUTE
+
1
)
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
5
*
MILLISECONDS_PER_MINUTE
+
1
)
;
Preferences
.
set
(
PREF_TEST
2
)
;
Assert
.
equal
(
getSubsessionCount
(
)
2
)
;
now
=
fakeNow
(
futureDate
(
now
1
*
MILLISECONDS_PER_MINUTE
)
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
1
*
MILLISECONDS_PER_MINUTE
)
;
Preferences
.
set
(
PREF_TEST
3
)
;
Assert
.
equal
(
getSubsessionCount
(
)
2
)
;
now
=
fakeNow
(
futureDate
(
now
4
*
MILLISECONDS_PER_MINUTE
+
1
)
)
;
gMonotonicNow
=
fakeMonotonicNow
(
gMonotonicNow
+
4
*
MILLISECONDS_PER_MINUTE
+
1
)
;
Preferences
.
set
(
PREF_TEST
4
)
;
Assert
.
equal
(
getSubsessionCount
(
)
3
)
;
TelemetryEnvironment
.
unregisterChangeListener
(
"
testWatchPrefs_throttling
"
)
;
}
)
;
add_task
(
async
function
stopServer
(
)
{
await
PingServer
.
stop
(
)
;
}
)
;
