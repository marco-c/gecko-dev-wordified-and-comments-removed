"
use
strict
"
;
const
{
ContentTaskUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
ContentTaskUtils
.
jsm
"
{
}
)
;
const
{
TelemetryUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
{
}
)
;
const
{
ObjectUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
{
}
)
;
const
HC_PERMISSION
=
"
hc_telemetry
"
;
async
function
waitForProcessesEvents
(
aProcesses
aAdditionalCondition
=
data
=
>
true
)
{
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
const
events
=
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
)
;
return
aProcesses
.
every
(
p
=
>
Object
.
keys
(
events
)
.
includes
(
p
)
)
&
&
aAdditionalCondition
(
events
)
;
}
)
;
}
async
function
waitForEvent
(
aProcess
aEventData
)
{
await
waitForProcessesEvents
(
[
aProcess
]
events
=
>
{
let
processEvents
=
events
[
aProcess
]
.
map
(
e
=
>
e
.
slice
(
1
)
)
;
if
(
processEvents
.
length
=
=
0
)
{
return
false
;
}
return
processEvents
.
find
(
e
=
>
ObjectUtils
.
deepEqual
(
e
aEventData
)
)
;
}
)
;
}
function
removeTrailingInvalidEntry
(
aEvent
)
{
while
(
aEvent
[
aEvent
.
length
-
1
]
=
=
=
undefined
|
|
aEvent
[
aEvent
.
length
-
1
]
=
=
=
null
)
{
aEvent
.
pop
(
)
;
}
return
aEvent
;
}
add_task
(
async
function
test_setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
TelemetryUtils
.
Preferences
.
OverridePreRelease
true
]
[
TelemetryUtils
.
Preferences
.
HybridContentEnabled
true
]
[
TelemetryUtils
.
Preferences
.
LogLevel
"
Trace
"
]
]
}
)
;
let
canRecordExtended
=
Services
.
telemetry
.
canRecordExtended
;
Services
.
telemetry
.
canRecordExtended
=
true
;
registerCleanupFunction
(
(
)
=
>
Services
.
telemetry
.
canRecordExtended
=
canRecordExtended
)
;
}
)
;
add_task
(
async
function
test_untrusted_http_origin
(
)
{
Services
.
telemetry
.
clearEvents
(
)
;
const
messageName
=
"
HybridContentTelemetry
:
onTelemetryMessage
"
;
let
makeTestFail
=
(
)
=
>
ok
(
false
Received
an
unexpected
{
messageName
}
.
)
;
Services
.
mm
.
addMessageListener
(
messageName
makeTestFail
)
;
const
testHost
=
"
http
:
/
/
example
.
org
"
;
let
testHttpUri
=
Services
.
io
.
newURI
(
testHost
)
;
Services
.
perms
.
add
(
testHttpUri
HC_PERMISSION
Services
.
perms
.
ALLOW_ACTION
)
;
let
url
=
getRootDirectory
(
gTestPath
)
+
"
hybrid_content
.
html
"
;
url
=
url
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
testHost
)
;
let
newTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
url
)
;
const
TEST_CONTENT_EVENT
=
[
"
telemetry
.
test
"
"
main_and_content
"
"
object1
"
]
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
telemetry
.
test
"
true
)
;
await
ContentTask
.
spawn
(
newTab
.
linkedBrowser
[
TEST_CONTENT_EVENT
]
(
[
testContentEvent
]
)
=
>
{
let
contentWin
=
Cu
.
waiveXrays
(
content
)
;
contentWin
.
testRegisterEvents
(
testContentEvent
[
0
]
JSON
.
stringify
(
{
}
)
)
;
Services
.
telemetry
.
recordEvent
(
.
.
.
testContentEvent
)
;
}
)
;
const
processName
=
Services
.
appinfo
.
browserTabsRemoteAutostart
?
"
content
"
:
"
parent
"
;
await
waitForEvent
(
processName
TEST_CONTENT_EVENT
)
;
ok
(
true
"
The
untrusted
HTTP
page
was
not
able
to
use
the
API
.
"
)
;
BrowserTestUtils
.
removeTab
(
newTab
)
;
Services
.
perms
.
remove
(
testHttpUri
HC_PERMISSION
)
;
Services
.
mm
.
removeMessageListener
(
messageName
makeTestFail
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
telemetry
.
test
"
false
)
;
}
)
;
add_task
(
async
function
test_secure_non_whitelisted_origin
(
)
{
Services
.
telemetry
.
clearEvents
(
)
;
const
messageName
=
"
HybridContentTelemetry
:
onTelemetryMessage
"
;
let
makeTestFail
=
(
)
=
>
ok
(
false
Received
an
unexpected
{
messageName
}
.
)
;
Services
.
mm
.
addMessageListener
(
messageName
makeTestFail
)
;
const
testHost
=
"
https
:
/
/
example
.
org
"
;
let
url
=
getRootDirectory
(
gTestPath
)
+
"
hybrid_content
.
html
"
;
url
=
url
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
testHost
)
;
let
newTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
url
)
;
const
TEST_CONTENT_EVENT
=
[
"
telemetry
.
test
"
"
main_and_content
"
"
object1
"
]
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
telemetry
.
test
"
true
)
;
await
ContentTask
.
spawn
(
newTab
.
linkedBrowser
[
TEST_CONTENT_EVENT
]
(
[
testContentEvent
]
)
=
>
{
let
contentWin
=
Cu
.
waiveXrays
(
content
)
;
contentWin
.
testRegisterEvents
(
testContentEvent
[
0
]
JSON
.
stringify
(
{
}
)
)
;
Services
.
telemetry
.
recordEvent
(
.
.
.
testContentEvent
)
;
}
)
;
const
processName
=
Services
.
appinfo
.
browserTabsRemoteAutostart
?
"
content
"
:
"
parent
"
;
await
waitForEvent
(
processName
TEST_CONTENT_EVENT
)
;
ok
(
true
"
The
HTTPS
page
without
permission
was
not
able
to
use
the
API
.
"
)
;
BrowserTestUtils
.
removeTab
(
newTab
)
;
Services
.
mm
.
removeMessageListener
(
messageName
makeTestFail
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
telemetry
.
test
"
false
)
;
}
)
;
add_task
(
async
function
test_trusted_disabled_hybrid_telemetry
(
)
{
Services
.
telemetry
.
clearEvents
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
TelemetryUtils
.
Preferences
.
HybridContentEnabled
false
]
]
}
)
;
const
messageName
=
"
HybridContentTelemetry
:
onTelemetryMessage
"
;
let
makeTestFail
=
(
)
=
>
ok
(
false
Received
an
unexpected
{
messageName
}
.
)
;
Services
.
mm
.
addMessageListener
(
messageName
makeTestFail
)
;
const
testHost
=
"
https
:
/
/
example
.
org
"
;
let
testHttpsUri
=
Services
.
io
.
newURI
(
testHost
)
;
Services
.
perms
.
add
(
testHttpsUri
HC_PERMISSION
Services
.
perms
.
ALLOW_ACTION
)
;
let
url
=
getRootDirectory
(
gTestPath
)
+
"
hybrid_content
.
html
"
;
url
=
url
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
testHost
)
;
let
newTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
url
)
;
const
TEST_CONTENT_EVENT
=
[
"
telemetry
.
test
"
"
main_and_content
"
"
object1
"
]
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
telemetry
.
test
"
true
)
;
await
ContentTask
.
spawn
(
newTab
.
linkedBrowser
[
TEST_CONTENT_EVENT
]
(
[
testContentEvent
]
)
=
>
{
let
contentWin
=
Cu
.
waiveXrays
(
content
)
;
contentWin
.
testRegisterEvents
(
testContentEvent
[
0
]
JSON
.
stringify
(
{
}
)
)
;
Services
.
telemetry
.
recordEvent
(
.
.
.
testContentEvent
)
;
}
)
;
const
processName
=
Services
.
appinfo
.
browserTabsRemoteAutostart
?
"
content
"
:
"
parent
"
;
await
waitForEvent
(
processName
TEST_CONTENT_EVENT
)
;
ok
(
true
"
There
were
no
unintended
hybrid
content
API
usages
.
"
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
BrowserTestUtils
.
removeTab
(
newTab
)
;
Services
.
perms
.
remove
(
testHttpsUri
HC_PERMISSION
)
;
Services
.
mm
.
removeMessageListener
(
messageName
makeTestFail
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
telemetry
.
test
"
false
)
;
}
)
;
add_task
(
async
function
test_hybrid_content_with_iframe
(
)
{
Services
.
telemetry
.
clearEvents
(
)
;
const
testOuterPageHost
=
"
https
:
/
/
example
.
com
"
;
let
testHttpsUri
=
Services
.
io
.
newURI
(
testOuterPageHost
)
;
Services
.
perms
.
add
(
testHttpsUri
HC_PERMISSION
Services
.
perms
.
ALLOW_ACTION
)
;
let
url
=
getRootDirectory
(
gTestPath
)
+
"
hybrid_content
.
html
"
;
let
outerUrl
=
url
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
testOuterPageHost
)
;
let
newTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
outerUrl
)
;
const
messageName
=
"
HybridContentTelemetry
:
onTelemetryMessage
"
;
let
makeTestFail
=
(
)
=
>
ok
(
false
Received
an
unexpected
{
messageName
}
.
)
;
Services
.
mm
.
addMessageListener
(
messageName
makeTestFail
)
;
const
TEST_CONTENT_EVENT
=
[
"
telemetry
.
test
"
"
main_and_content
"
"
object1
"
]
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
telemetry
.
test
"
true
)
;
const
testHost
=
"
https
:
/
/
example
.
org
"
;
let
iframeUrl
=
url
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
testHost
)
;
await
ContentTask
.
spawn
(
newTab
.
linkedBrowser
[
iframeUrl
TEST_CONTENT_EVENT
]
async
function
(
[
iframeUrl
testContentEvent
]
)
{
let
doc
=
content
.
document
;
let
iframe
=
doc
.
createElement
(
"
iframe
"
)
;
let
promiseIframeLoaded
=
ContentTaskUtils
.
waitForEvent
(
iframe
"
load
"
false
)
;
iframe
.
src
=
iframeUrl
;
doc
.
body
.
insertBefore
(
iframe
doc
.
body
.
firstChild
)
;
await
promiseIframeLoaded
;
let
contentWin
=
Cu
.
waiveXrays
(
iframe
.
contentWindow
)
;
contentWin
.
testRegisterEvents
(
testContentEvent
[
0
]
JSON
.
stringify
(
{
}
)
)
;
Services
.
telemetry
.
recordEvent
(
.
.
.
testContentEvent
)
;
}
)
;
const
processName
=
Services
.
appinfo
.
browserTabsRemoteAutostart
?
"
content
"
:
"
parent
"
;
await
waitForEvent
(
processName
TEST_CONTENT_EVENT
)
;
ok
(
true
"
There
were
no
unintended
hybrid
content
API
usages
from
the
iframe
.
"
)
;
BrowserTestUtils
.
removeTab
(
newTab
)
;
Services
.
mm
.
removeMessageListener
(
messageName
makeTestFail
)
;
Services
.
perms
.
remove
(
testHttpsUri
HC_PERMISSION
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
telemetry
.
test
"
false
)
;
}
)
;
add_task
(
async
function
test_hybrid_content_recording
(
)
{
const
testHost
=
"
https
:
/
/
example
.
org
"
;
const
TEST_EVENT_CATEGORY
=
"
telemetry
.
test
.
hct
"
;
const
RECORDED_TEST_EVENTS
=
[
[
TEST_EVENT_CATEGORY
"
test1
"
"
object1
"
]
[
TEST_EVENT_CATEGORY
"
test2
"
"
object1
"
null
{
"
key1
"
:
"
foo
"
"
key2
"
:
"
bar
"
}
]
[
TEST_EVENT_CATEGORY
"
test2
"
"
object1
"
"
some
value
"
]
[
TEST_EVENT_CATEGORY
"
test1
"
"
object1
"
null
null
]
[
TEST_EVENT_CATEGORY
"
test1
"
"
object1
"
"
"
null
]
]
;
const
NON_RECORDED_TEST_EVENTS
=
[
[
TEST_EVENT_CATEGORY
"
unknown
"
"
unknown
"
]
]
;
Services
.
telemetry
.
clearEvents
(
)
;
let
testHttpsUri
=
Services
.
io
.
newURI
(
testHost
)
;
Services
.
perms
.
add
(
testHttpsUri
HC_PERMISSION
Services
.
perms
.
ALLOW_ACTION
)
;
let
url
=
getRootDirectory
(
gTestPath
)
+
"
hybrid_content
.
html
"
;
url
=
url
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
testHost
)
;
let
newTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
url
)
;
await
ContentTask
.
spawn
(
newTab
.
linkedBrowser
[
TEST_EVENT_CATEGORY
RECORDED_TEST_EVENTS
NON_RECORDED_TEST_EVENTS
]
(
[
eventCategory
recordedTestEvents
nonRecordedTestEvents
]
)
=
>
{
let
contentWin
=
Cu
.
waiveXrays
(
content
)
;
contentWin
.
testRegisterEvents
(
eventCategory
JSON
.
stringify
(
{
"
test1
"
:
{
methods
:
[
"
test1
"
]
objects
:
[
"
object1
"
]
}
"
test2
"
:
{
methods
:
[
"
test2
"
"
test2b
"
]
objects
:
[
"
object1
"
]
extra_keys
:
[
"
key1
"
"
key2
"
]
}
}
)
)
;
recordedTestEvents
.
forEach
(
e
=
>
contentWin
.
testRecordEvents
(
JSON
.
stringify
(
e
)
)
)
;
nonRecordedTestEvents
.
forEach
(
e
=
>
contentWin
.
testRecordEvents
(
JSON
.
stringify
(
e
)
)
)
;
}
)
;
await
waitForProcessesEvents
(
[
"
dynamic
"
]
)
;
let
snapshot
=
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
)
;
ok
(
"
dynamic
"
in
snapshot
"
The
snapshot
must
contain
the
'
dynamic
'
process
section
"
)
;
let
dynamicEvents
=
snapshot
.
dynamic
.
map
(
e
=
>
e
.
slice
(
1
)
)
;
is
(
dynamicEvents
.
length
RECORDED_TEST_EVENTS
.
length
"
Should
match
expected
event
count
.
"
)
;
for
(
let
i
=
0
;
i
<
RECORDED_TEST_EVENTS
.
length
;
+
+
i
)
{
SimpleTest
.
isDeeply
(
dynamicEvents
[
i
]
removeTrailingInvalidEntry
(
RECORDED_TEST_EVENTS
[
i
]
)
"
Should
have
recorded
the
expected
event
.
"
)
;
}
BrowserTestUtils
.
removeTab
(
newTab
)
;
Services
.
perms
.
remove
(
testHttpsUri
HC_PERMISSION
)
;
}
)
;
add_task
(
async
function
test_can_upload
(
)
{
const
testHost
=
"
https
:
/
/
example
.
org
"
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
true
]
]
}
)
;
let
testHttpsUri
=
Services
.
io
.
newURI
(
testHost
)
;
Services
.
perms
.
add
(
testHttpsUri
HC_PERMISSION
Services
.
perms
.
ALLOW_ACTION
)
;
let
url
=
getRootDirectory
(
gTestPath
)
+
"
hybrid_content
.
html
"
;
url
=
url
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
testHost
)
;
let
newTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
url
)
;
await
ContentTask
.
spawn
(
newTab
.
linkedBrowser
{
}
async
function
(
)
{
let
contentWin
=
Cu
.
waiveXrays
(
content
)
;
await
contentWin
.
Mozilla
.
ContentTelemetry
.
initPromise
(
)
;
let
canUpload
=
contentWin
.
Mozilla
.
ContentTelemetry
.
canUpload
(
)
;
ok
(
canUpload
"
CanUpload
must
report
'
true
'
if
the
preference
has
that
value
.
"
)
;
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
TelemetryUtils
.
Preferences
.
FhrUploadEnabled
false
]
]
}
)
;
await
ContentTask
.
spawn
(
newTab
.
linkedBrowser
{
}
async
function
(
)
{
let
contentWin
=
Cu
.
waiveXrays
(
content
)
;
await
contentWin
.
Mozilla
.
ContentTelemetry
.
initPromise
(
)
;
let
canUpload
=
contentWin
.
Mozilla
.
ContentTelemetry
.
canUpload
(
)
;
ok
(
!
canUpload
"
CanUpload
must
report
'
false
'
if
the
preference
has
that
value
.
"
)
;
}
)
;
BrowserTestUtils
.
removeTab
(
newTab
)
;
Services
.
perms
.
remove
(
testHttpsUri
HC_PERMISSION
)
;
}
)
;
add_task
(
async
function
test_hct_for_discopane
(
)
{
const
discoHost
=
"
https
:
/
/
discovery
.
addons
.
mozilla
.
org
"
;
let
discoHttpsUri
=
Services
.
io
.
newURI
(
discoHost
)
;
let
permission
=
Services
.
perms
.
testPermission
(
discoHttpsUri
HC_PERMISSION
)
;
ok
(
permission
=
=
Services
.
perms
.
ALLOW_ACTION
"
Disco
Pane
needs
Hybrid
Content
Permission
for
Telemetry
data
upload
"
)
;
}
)
;
