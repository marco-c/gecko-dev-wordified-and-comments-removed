"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
TelemetryTestUtils
"
]
;
const
{
Assert
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
Assert
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
TelemetryTestUtils
=
{
assertScalar
(
scalars
scalarName
value
msg
)
{
if
(
value
>
0
)
{
Assert
.
equal
(
scalars
[
scalarName
]
value
msg
)
;
return
;
}
Assert
.
ok
(
!
(
scalarName
in
scalars
)
scalarName
+
"
must
not
be
reported
.
"
)
;
}
assertKeyedScalar
(
scalars
scalarName
key
expectedValue
)
{
Assert
.
ok
(
scalarName
in
scalars
scalarName
+
"
must
be
recorded
.
"
)
;
Assert
.
ok
(
key
in
scalars
[
scalarName
]
scalarName
+
"
must
contain
the
'
"
+
key
+
"
'
key
.
"
)
;
Assert
.
equal
(
scalars
[
scalarName
]
[
key
]
expectedValue
scalarName
+
"
[
'
"
+
key
+
"
'
]
must
contain
the
expected
value
"
)
;
}
getProcessScalars
(
aProcessName
aKeyed
=
false
aClear
=
false
aChannel
=
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
)
{
const
extended
=
aChannel
=
=
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
;
const
currentExtended
=
Services
.
telemetry
.
canRecordExtended
;
Services
.
telemetry
.
canRecordExtended
=
extended
;
const
scalars
=
aKeyed
?
Services
.
telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
aClear
)
[
aProcessName
]
:
Services
.
telemetry
.
getSnapshotForScalars
(
"
main
"
aClear
)
[
aProcessName
]
;
Services
.
telemetry
.
canRecordExtended
=
currentExtended
;
return
scalars
|
|
{
}
;
}
assertNumberOfEvents
(
numEvents
filter
options
)
{
TelemetryTestUtils
.
assertEvents
(
Array
.
from
(
{
length
:
numEvents
}
(
)
=
>
(
{
}
)
)
filter
options
)
;
}
assertEvents
(
expectedEvents
filter
=
{
}
{
clear
=
true
process
=
"
parent
"
}
=
{
}
)
{
let
snapshots
=
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
clear
)
;
if
(
expectedEvents
.
length
=
=
=
0
&
&
!
(
process
in
snapshots
)
)
{
return
;
}
Assert
.
ok
(
process
in
snapshots
{
process
}
must
be
in
snapshot
.
Has
[
{
Object
.
keys
(
snapshots
)
}
]
.
)
;
let
snapshot
=
snapshots
[
process
]
;
let
{
category
:
filterCategory
method
:
filterMethod
object
:
filterObject
}
=
filter
;
let
matches
=
(
expected
actual
)
=
>
{
if
(
expected
=
=
=
undefined
)
{
return
true
;
}
else
if
(
expected
&
&
expected
.
test
)
{
return
expected
.
test
(
actual
)
;
}
else
if
(
typeof
expected
=
=
=
"
function
"
)
{
return
expected
(
actual
)
;
}
return
expected
=
=
=
actual
;
}
;
let
filtered
=
snapshot
.
map
(
(
[
category
method
object
value
extra
]
)
=
>
{
return
[
category
method
object
value
extra
]
;
}
)
.
filter
(
(
[
category
method
object
]
)
=
>
{
return
(
matches
(
filterCategory
category
)
&
&
matches
(
filterMethod
method
)
&
&
matches
(
filterObject
object
)
)
;
}
)
;
Assert
.
equal
(
expectedEvents
.
length
filtered
.
length
"
After
filtering
we
must
have
the
expected
number
of
events
.
"
)
;
if
(
expectedEvents
.
length
=
=
=
0
)
{
return
;
}
if
(
!
Array
.
isArray
(
expectedEvents
[
0
]
)
)
{
expectedEvents
=
expectedEvents
.
map
(
(
{
category
method
object
value
extra
}
)
=
>
[
category
method
object
value
extra
]
)
;
}
const
FIELD_NAMES
=
[
"
category
"
"
method
"
"
object
"
"
value
"
"
extra
"
]
;
const
EXTRA_INDEX
=
4
;
for
(
let
i
=
0
;
i
<
expectedEvents
.
length
;
+
+
i
)
{
let
expected
=
expectedEvents
[
i
]
;
let
actual
=
filtered
[
i
]
;
for
(
let
j
=
0
;
j
<
EXTRA_INDEX
;
+
+
j
)
{
if
(
expected
[
j
]
=
=
=
undefined
)
{
continue
;
}
Assert
.
report
(
!
matches
(
expected
[
j
]
actual
[
j
]
)
actual
[
j
]
expected
[
j
]
{
FIELD_NAMES
[
j
]
}
in
event
{
actual
[
0
]
}
#
{
actual
[
1
]
}
#
{
actual
[
2
]
}
must
match
.
"
matches
"
)
;
}
if
(
expected
.
length
>
EXTRA_INDEX
&
&
expected
[
EXTRA_INDEX
]
!
=
=
undefined
)
{
Assert
.
ok
(
actual
.
length
>
EXTRA_INDEX
Actual
event
{
actual
[
0
]
}
#
{
actual
[
1
]
}
#
{
actual
[
2
]
}
expected
to
have
extra
.
)
;
let
expectedExtra
=
expected
[
EXTRA_INDEX
]
;
let
actualExtra
=
actual
[
EXTRA_INDEX
]
;
for
(
let
[
key
value
]
of
Object
.
entries
(
expectedExtra
)
)
{
Assert
.
ok
(
key
in
actualExtra
Expected
key
{
key
}
must
be
in
actual
extra
.
Actual
keys
:
[
{
Object
.
keys
(
actualExtra
)
}
]
.
)
;
Assert
.
report
(
!
matches
(
value
actualExtra
[
key
]
)
actualExtra
[
key
]
value
extra
[
{
key
}
]
must
match
in
event
{
actual
[
0
]
}
#
{
actual
[
1
]
}
#
{
actual
[
2
]
}
.
"
matches
"
)
;
}
}
}
}
getAndClearHistogram
(
name
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
name
)
;
histogram
.
clear
(
)
;
return
histogram
;
}
getAndClearKeyedHistogram
(
name
)
{
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
name
)
;
histogram
.
clear
(
)
;
return
histogram
;
}
assertHistogram
(
histogram
index
expected
)
{
const
snapshot
=
histogram
.
snapshot
(
)
;
let
found
=
false
;
for
(
let
[
i
val
]
of
Object
.
entries
(
snapshot
.
values
)
)
{
if
(
i
=
=
index
)
{
found
=
true
;
Assert
.
equal
(
val
expected
expected
counts
should
match
for
{
histogram
.
name
(
)
}
at
index
{
i
}
)
;
}
else
{
Assert
.
equal
(
val
0
unexpected
counts
should
be
zero
for
{
histogram
.
name
(
)
}
at
index
{
i
}
)
;
}
}
Assert
.
ok
(
found
Should
have
found
an
entry
for
{
histogram
.
name
(
)
}
at
index
{
index
}
)
;
}
assertKeyedHistogramSum
(
histogram
key
expected
)
{
const
snapshot
=
histogram
.
snapshot
(
)
;
if
(
expected
=
=
=
undefined
)
{
Assert
.
ok
(
!
(
key
in
snapshot
)
The
histogram
{
histogram
.
name
(
)
}
must
not
contain
{
key
}
.
)
;
return
;
}
Assert
.
ok
(
key
in
snapshot
The
histogram
{
histogram
.
name
(
)
}
must
contain
{
key
}
.
)
;
Assert
.
equal
(
snapshot
[
key
]
.
sum
expected
The
key
{
key
}
must
contain
the
expected
sum
in
{
histogram
.
name
(
)
}
.
)
;
}
assertKeyedHistogramValue
(
histogram
key
index
expected
)
{
const
snapshot
=
histogram
.
snapshot
(
)
;
if
(
!
(
key
in
snapshot
)
)
{
Assert
.
ok
(
false
The
histogram
{
histogram
.
name
(
)
}
must
contain
{
key
}
)
;
return
;
}
for
(
let
[
i
val
]
of
Object
.
entries
(
snapshot
[
key
]
.
values
)
)
{
if
(
i
=
=
index
)
{
Assert
.
equal
(
val
expected
expected
counts
should
match
for
{
histogram
.
name
(
)
}
at
index
{
i
}
)
;
}
else
{
Assert
.
equal
(
val
0
unexpected
counts
should
be
zero
for
{
histogram
.
name
(
)
}
at
index
{
i
}
)
;
}
}
}
}
;
