"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
TelemetryTestUtils
"
]
;
const
{
Assert
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
Assert
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
TelemetryTestUtils
=
{
assertScalar
(
scalars
scalarName
value
msg
)
{
if
(
value
>
0
)
{
Assert
.
equal
(
scalars
[
scalarName
]
value
msg
)
;
return
;
}
Assert
.
ok
(
!
(
scalarName
in
scalars
)
scalarName
+
"
must
not
be
reported
.
"
)
;
}
assertKeyedScalar
(
scalars
scalarName
key
expectedValue
)
{
Assert
.
ok
(
scalarName
in
scalars
scalarName
+
"
must
be
recorded
.
"
)
;
Assert
.
ok
(
key
in
scalars
[
scalarName
]
scalarName
+
"
must
contain
the
'
"
+
key
+
"
'
key
.
"
)
;
Assert
.
equal
(
scalars
[
scalarName
]
[
key
]
expectedValue
scalarName
+
"
[
'
"
+
key
+
"
'
]
must
contain
the
expected
value
"
)
;
}
getProcessScalars
(
aProcessName
aKeyed
=
false
aClear
=
false
aChannel
=
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
)
{
const
extended
=
aChannel
=
=
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
;
const
currentExtended
=
Services
.
telemetry
.
canRecordExtended
;
Services
.
telemetry
.
canRecordExtended
=
extended
;
const
scalars
=
aKeyed
?
Services
.
telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
aClear
)
[
aProcessName
]
:
Services
.
telemetry
.
getSnapshotForScalars
(
"
main
"
aClear
)
[
aProcessName
]
;
Services
.
telemetry
.
canRecordExtended
=
currentExtended
;
return
scalars
|
|
{
}
;
}
assertEvents
(
events
expectedEvents
)
{
if
(
!
Services
.
telemetry
.
canRecordExtended
)
{
console
.
log
(
"
Not
asserting
event
telemetry
-
canRecordExtended
is
disabled
.
"
)
;
return
;
}
Assert
.
equal
(
events
.
length
expectedEvents
.
length
"
Should
have
matching
amount
of
events
.
"
)
;
events
=
events
.
map
(
e
=
>
e
.
slice
(
1
)
)
;
for
(
let
i
=
0
;
i
<
events
.
length
;
+
+
i
)
{
Assert
.
deepEqual
(
events
[
i
]
expectedEvents
[
i
]
"
Events
should
match
.
"
)
;
}
}
getAndClearHistogram
(
name
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
name
)
;
histogram
.
clear
(
)
;
return
histogram
;
}
getAndClearKeyedHistogram
(
name
)
{
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
name
)
;
histogram
.
clear
(
)
;
return
histogram
;
}
assertHistogram
(
histogram
index
expected
)
{
const
snapshot
=
histogram
.
snapshot
(
)
;
let
found
=
false
;
for
(
let
[
i
val
]
of
Object
.
entries
(
snapshot
.
values
)
)
{
if
(
i
=
=
index
)
{
found
=
true
;
Assert
.
equal
(
val
expected
expected
counts
should
match
for
the
histogram
index
{
i
}
)
;
}
else
{
Assert
.
equal
(
val
0
unexpected
counts
should
be
zero
for
the
histogram
index
{
i
}
)
;
}
}
Assert
.
ok
(
found
Should
have
found
an
entry
for
histogram
index
{
index
}
)
;
}
assertKeyedHistogramSum
(
histogram
key
expected
)
{
const
snapshot
=
histogram
.
snapshot
(
)
;
if
(
expected
=
=
=
undefined
)
{
Assert
.
ok
(
!
(
key
in
snapshot
)
The
histogram
must
not
contain
{
key
}
.
)
;
return
;
}
Assert
.
ok
(
key
in
snapshot
The
histogram
must
contain
{
key
}
.
)
;
Assert
.
equal
(
snapshot
[
key
]
.
sum
expected
The
key
{
key
}
must
contain
the
expected
sum
.
)
;
}
assertKeyedHistogramValue
(
histogram
key
index
expected
)
{
const
snapshot
=
histogram
.
snapshot
(
)
;
if
(
!
(
key
in
snapshot
)
)
{
Assert
.
ok
(
false
The
histogram
must
contain
{
key
}
)
;
return
;
}
for
(
let
[
i
val
]
of
Object
.
entries
(
snapshot
[
key
]
.
values
)
)
{
if
(
i
=
=
index
)
{
Assert
.
equal
(
val
expected
expected
counts
should
match
for
the
histogram
index
{
i
}
)
;
}
else
{
Assert
.
equal
(
val
0
unexpected
counts
should
be
zero
for
the
histogram
index
{
i
}
)
;
}
}
}
}
;
