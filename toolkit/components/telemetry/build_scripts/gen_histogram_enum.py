from
__future__
import
print_function
from
mozparsers
.
shared_telemetry_utils
import
ParserError
from
mozparsers
import
parse_histograms
import
itertools
import
sys
import
buildconfig
banner
=
"
"
"
/
*
This
file
is
auto
-
generated
see
gen_histogram_enum
.
py
.
*
/
"
"
"
header
=
"
"
"
#
ifndef
mozilla_TelemetryHistogramEnums_h
#
define
mozilla_TelemetryHistogramEnums_h
#
include
"
mozilla
/
TemplateLib
.
h
"
namespace
mozilla
{
namespace
Telemetry
{
"
"
"
footer
=
"
"
"
}
/
/
namespace
mozilla
}
/
/
namespace
Telemetry
#
endif
/
/
mozilla_TelemetryHistogramEnums_h
"
"
"
def
get_histogram_typename
(
histogram
)
:
    
name
=
histogram
.
name
(
)
    
if
name
.
startswith
(
"
USE_COUNTER2_
"
)
:
        
return
"
UseCounterWorker
"
if
name
.
endswith
(
"
_WORKER
"
)
else
"
UseCounter
"
    
return
None
def
main
(
output
*
filenames
)
:
    
print
(
banner
file
=
output
)
    
print
(
header
file
=
output
)
    
try
:
        
all_histograms
=
list
(
parse_histograms
.
from_files
(
filenames
)
)
    
except
ParserError
as
ex
:
        
print
(
"
\
nError
processing
histograms
:
\
n
"
+
str
(
ex
)
+
"
\
n
"
)
        
sys
.
exit
(
1
)
    
groups
=
itertools
.
groupby
(
all_histograms
get_histogram_typename
)
    
print
(
"
enum
HistogramID
:
uint32_t
{
"
file
=
output
)
    
seen_group_types
=
{
"
UseCounter
"
:
False
"
UseCounterWorker
"
:
False
}
    
for
(
group_type
histograms
)
in
groups
:
        
if
group_type
is
not
None
:
            
assert
isinstance
(
group_type
basestring
)
            
assert
group_type
in
seen_group_types
.
keys
(
)
            
assert
not
seen_group_types
[
group_type
]
            
seen_group_types
[
group_type
]
=
True
            
print
(
"
HistogramFirst
%
s
"
%
group_type
file
=
output
)
            
print
(
"
Histogram
{
0
}
DUMMY1
=
HistogramFirst
{
0
}
-
1
"
.
format
(
group_type
)
file
=
output
)
        
for
histogram
in
histograms
:
            
if
histogram
.
record_on_os
(
buildconfig
.
substs
[
"
OS_TARGET
"
]
)
:
                
print
(
"
%
s
"
%
histogram
.
name
(
)
file
=
output
)
        
if
group_type
is
not
None
:
            
assert
isinstance
(
group_type
basestring
)
            
print
(
"
Histogram
%
sDUMMY2
"
%
group_type
file
=
output
)
            
print
(
"
HistogramLast
{
0
}
=
Histogram
{
0
}
DUMMY2
-
1
"
.
format
(
group_type
)
file
=
output
)
    
print
(
"
HistogramCount
"
file
=
output
)
    
for
(
key
value
)
in
seen_group_types
.
items
(
)
:
        
if
value
:
            
print
(
"
Histogram
{
0
}
Count
=
HistogramLast
{
0
}
-
HistogramFirst
{
0
}
+
1
"
                  
.
format
(
key
)
file
=
output
)
        
else
:
            
print
(
"
HistogramFirst
%
s
=
0
"
%
key
file
=
output
)
            
print
(
"
HistogramLast
%
s
=
0
"
%
key
file
=
output
)
            
print
(
"
Histogram
%
sCount
=
0
"
%
key
file
=
output
)
    
print
(
"
}
;
"
file
=
output
)
    
categorical
=
filter
(
lambda
h
:
h
.
kind
(
)
=
=
"
categorical
"
all_histograms
)
    
categorical
=
filter
(
lambda
h
:
h
.
record_on_os
(
buildconfig
.
substs
[
"
OS_TARGET
"
]
)
categorical
)
    
enums
=
[
(
"
LABELS_
"
+
h
.
name
(
)
h
.
labels
(
)
h
.
name
(
)
)
for
h
in
categorical
]
    
for
name
labels
_
in
enums
:
        
print
(
"
\
nenum
class
%
s
:
uint32_t
{
"
%
name
file
=
output
)
        
print
(
"
%
s
"
%
"
\
n
"
.
join
(
labels
)
file
=
output
)
        
print
(
"
}
;
"
file
=
output
)
    
print
(
"
\
ntemplate
<
class
T
>
struct
IsCategoricalLabelEnum
:
FalseType
{
}
;
"
file
=
output
)
    
for
name
_
_
in
enums
:
        
print
(
"
template
<
>
struct
IsCategoricalLabelEnum
<
%
s
>
:
TrueType
{
}
;
"
%
name
file
=
output
)
    
print
(
"
\
ntemplate
<
class
T
>
struct
CategoricalLabelId
{
}
;
"
file
=
output
)
    
for
name
_
id
in
enums
:
        
print
(
"
template
<
>
struct
CategoricalLabelId
<
%
s
>
:
"
              
"
IntegralConstant
<
uint32_t
%
s
>
{
}
;
"
%
(
name
id
)
file
=
output
)
    
print
(
footer
file
=
output
)
if
__name__
=
=
'
__main__
'
:
    
main
(
sys
.
stdout
*
sys
.
argv
[
1
:
]
)
