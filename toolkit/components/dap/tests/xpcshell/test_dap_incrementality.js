"
use
strict
"
;
const
{
HttpServer
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
httpd
.
sys
.
mjs
"
)
;
const
{
PlacesTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
sys
.
mjs
"
)
;
const
{
NetUtil
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
sys
.
mjs
"
)
;
const
{
PlacesUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
{
NimbusTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
NimbusTestUtils
.
sys
.
mjs
"
)
;
const
{
DAPIncrementality
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
DAPIncrementality
.
sys
.
mjs
"
)
;
NimbusTestUtils
.
init
(
this
)
;
const
BinaryInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
binaryinputstream
;
1
"
"
nsIBinaryInputStream
"
"
setInputStream
"
)
;
const
PREF_LEADER
=
"
toolkit
.
telemetry
.
dap
.
leader
.
url
"
;
const
PREF_HELPER
=
"
toolkit
.
telemetry
.
dap
.
helper
.
url
"
;
const
TRANSITION_TYPED
=
PlacesUtils
.
history
.
TRANSITION_TYPED
;
const
TASK_ID
=
"
o
-
91EcR2kfxfAmkKPPHifXKqiH7Upm0Ilw5joB3L_pE
"
;
let
server
;
let
server_addr
;
let
server_requests
=
[
]
;
function
uploadHandler
(
request
response
)
{
Assert
.
equal
(
request
.
getHeader
(
"
Content
-
Type
"
)
"
application
/
dap
-
report
"
"
Wrong
Content
-
Type
header
.
"
)
;
let
body
=
new
BinaryInputStream
(
request
.
bodyInputStream
)
;
server_requests
.
push
(
body
.
available
(
)
)
;
response
.
setStatusLine
(
request
.
httpVersion
200
)
;
}
function
resetServerRequests
(
)
{
server_requests
.
length
=
0
;
}
add_setup
(
async
function
(
)
{
do_get_profile
(
)
;
server
=
new
HttpServer
(
)
;
server
.
registerPrefixHandler
(
"
/
leader_endpoint
/
tasks
/
"
uploadHandler
)
;
server
.
start
(
-
1
)
;
const
i
=
server
.
identity
;
server_addr
=
i
.
primaryScheme
+
"
:
/
/
"
+
i
.
primaryHost
+
"
:
"
+
i
.
primaryPort
;
Services
.
prefs
.
setStringPref
(
PREF_LEADER
server_addr
+
"
/
leader_endpoint
"
)
;
Services
.
prefs
.
setStringPref
(
PREF_HELPER
server_addr
+
"
/
helper_endpoint
"
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
PREF_LEADER
)
;
Services
.
prefs
.
clearUserPref
(
PREF_HELPER
)
;
return
new
Promise
(
resolve
=
>
{
server
.
stop
(
resolve
)
;
}
)
;
}
)
;
}
)
;
function
openSubCapDatabase
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
request
=
indexedDB
.
open
(
"
SubmissionCap
"
1
)
;
request
.
onsuccess
=
(
)
=
>
resolve
(
request
.
result
)
;
request
.
onerror
=
(
)
=
>
reject
(
request
.
error
)
;
}
)
;
}
function
openIncrDatabase
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
request
=
indexedDB
.
open
(
"
DAPIncrementality
"
1
)
;
request
.
onsuccess
=
(
)
=
>
resolve
(
request
.
result
)
;
request
.
onerror
=
(
)
=
>
reject
(
request
.
error
)
;
}
)
;
}
function
countRecords
(
store
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
request
=
store
.
count
(
)
;
request
.
onsuccess
=
(
)
=
>
resolve
(
request
.
result
)
;
request
.
onerror
=
(
)
=
>
reject
(
request
.
error
)
;
}
)
;
}
async
function
getFreqCapCount
(
db
)
{
const
tx
=
db
.
transaction
(
"
freq_caps
"
"
readonly
"
)
;
const
store
=
tx
.
objectStore
(
"
freq_caps
"
)
;
const
count
=
await
countRecords
(
store
)
;
await
tx
.
done
;
return
count
;
}
async
function
getReportCount
(
db
)
{
const
tx
=
db
.
transaction
(
"
reports
"
"
readonly
"
)
;
const
store
=
tx
.
objectStore
(
"
reports
"
)
;
const
count
=
await
countRecords
(
store
)
;
await
tx
.
done
;
return
count
;
}
async
function
getReport
(
db
taskId
)
{
const
tx
=
db
.
transaction
(
"
reports
"
"
readonly
"
)
;
const
store
=
await
tx
.
objectStore
(
"
reports
"
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
request
=
store
.
get
(
taskId
)
;
request
.
onsuccess
=
(
)
=
>
resolve
(
request
.
result
)
;
request
.
onerror
=
(
)
=
>
reject
(
request
.
error
)
;
}
)
;
}
async
function
getReferrerState
(
db
taskId
)
{
const
tx
=
db
.
transaction
(
"
referrer
"
"
readonly
"
)
;
const
store
=
await
tx
.
objectStore
(
"
referrer
"
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
request
=
store
.
get
(
taskId
)
;
request
.
onsuccess
=
(
)
=
>
resolve
(
request
.
result
)
;
request
.
onerror
=
(
)
=
>
reject
(
request
.
error
)
;
}
)
;
}
add_task
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_NORMANDY
}
async
function
testVisitMeasurementNimbus
(
)
{
resetServerRequests
(
)
;
const
{
cleanup
}
=
await
NimbusTestUtils
.
setupTest
(
)
;
await
DAPIncrementality
.
startup
(
)
;
Assert
.
strictEqual
(
DAPIncrementality
.
dapReportContoller
null
"
dapReportContoller
should
not
exist
before
enrollment
"
)
;
const
doExperimentCleanup
=
await
NimbusTestUtils
.
enrollWithFeatureConfig
(
{
featureId
:
"
dapIncrementality
"
value
:
{
measurementType
:
"
visitMeasurement
"
taskId
:
TASK_ID
length
:
2
timePrecision
:
3600
visitCountUrls
:
[
{
url
:
"
*
:
/
/
*
.
example
.
com
/
"
bucket
:
0
}
{
url
:
"
*
:
/
/
*
.
mozilla
.
org
/
"
bucket
:
1
}
]
}
}
)
;
Assert
.
notStrictEqual
(
DAPIncrementality
.
dapReportContoller
null
"
dapReportContoller
should
be
active
"
)
;
const
subCapDb
=
await
openSubCapDatabase
(
)
;
let
numRecords
=
await
getReportCount
(
subCapDb
)
;
Assert
.
equal
(
numRecords
0
"
Should
be
no
pending
reports
"
)
;
let
timestamp
=
Date
.
now
(
)
*
1000
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
NetUtil
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
path
"
)
transition
:
TRANSITION_TYPED
visitDate
:
timestamp
}
)
;
numRecords
=
await
getReportCount
(
subCapDb
)
;
Assert
.
equal
(
numRecords
0
"
Should
be
no
pending
reports
"
)
;
timestamp
=
Date
.
now
(
)
*
1000
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
NetUtil
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
"
)
transition
:
TRANSITION_TYPED
visitDate
:
timestamp
}
)
;
numRecords
=
await
getReportCount
(
subCapDb
)
;
Assert
.
equal
(
numRecords
1
"
Should
be
1
pending
report
"
)
;
await
DAPIncrementality
.
dapReportContoller
.
submit
(
1000
"
unit
-
test
"
)
;
numRecords
=
await
getReportCount
(
subCapDb
)
;
Assert
.
equal
(
numRecords
0
"
Should
be
no
pending
reports
"
)
;
numRecords
=
await
getFreqCapCount
(
subCapDb
)
;
Assert
.
equal
(
numRecords
1
"
Should
be
1
cap
entry
"
)
;
await
doExperimentCleanup
(
)
;
Services
.
tm
.
spinEventLoopUntil
(
"
Wait
for
DAPIncrementality
to
flush
"
(
)
=
>
DAPIncrementality
.
config
=
=
=
null
)
;
numRecords
=
await
getFreqCapCount
(
subCapDb
)
;
Assert
.
equal
(
numRecords
0
"
Should
be
0
cap
entries
"
)
;
numRecords
=
await
getReportCount
(
subCapDb
)
;
Assert
.
equal
(
numRecords
0
"
Should
be
no
pending
reports
"
)
;
Assert
.
deepEqual
(
server_requests
[
390
390
390
]
"
Should
have
one
report
on
enrollment
second
for
triggered
submission
third
on
unenrollment
"
)
;
Assert
.
strictEqual
(
DAPIncrementality
.
dapReportContoller
null
"
dapReportContoller
should
not
exist
after
unenrollment
"
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_NORMANDY
}
async
function
testParsingMultiUrlVisitMeasurementNimbus
(
)
{
resetServerRequests
(
)
;
const
{
cleanup
}
=
await
NimbusTestUtils
.
setupTest
(
)
;
await
DAPIncrementality
.
startup
(
)
;
Assert
.
strictEqual
(
DAPIncrementality
.
dapReportContoller
null
"
dapReportContoller
should
not
exist
before
enrollment
"
)
;
const
expectedVisitCountUrls
=
[
{
url
:
"
*
:
/
/
*
.
mozilla
.
org
/
"
bucket
:
0
}
{
url
:
"
*
:
/
/
*
.
example
.
com
/
"
bucket
:
1
}
]
;
const
doExperimentCleanup
=
await
NimbusTestUtils
.
enrollWithFeatureConfig
(
{
featureId
:
"
dapIncrementality
"
value
:
{
measurementType
:
"
visitMeasurement
"
taskId
:
TASK_ID
length
:
2
timePrecision
:
3600
visitCountUrls
:
expectedVisitCountUrls
}
}
)
;
const
toKey
=
(
{
url
bucket
}
)
=
>
{
url
}
#
{
bucket
}
;
const
expectedKeySorted
=
expectedVisitCountUrls
.
map
(
toKey
)
.
sort
(
)
;
const
parsedKeySorted
=
DAPIncrementality
.
config
.
visitUrlPatterns
.
map
(
(
{
pattern
bucket
}
)
=
>
{
pattern
.
pattern
}
#
{
bucket
}
)
.
sort
(
)
;
Assert
.
deepEqual
(
parsedKeySorted
expectedKeySorted
"
patterns
and
buckets
match
"
)
;
await
DAPIncrementality
.
dapReportContoller
.
submit
(
1000
"
unit
-
test
"
)
;
await
doExperimentCleanup
(
)
;
Services
.
tm
.
spinEventLoopUntil
(
"
Wait
for
DAPIncrementality
to
flush
"
(
)
=
>
DAPIncrementality
.
config
=
=
=
null
)
;
Assert
.
deepEqual
(
server_requests
[
390
390
390
]
"
Should
have
one
report
on
enrollment
second
for
triggered
submission
third
on
unenrollment
"
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_NORMANDY
}
async
function
testReferrerMeasurementNimbus
(
)
{
resetServerRequests
(
)
;
const
{
cleanup
}
=
await
NimbusTestUtils
.
setupTest
(
)
;
await
DAPIncrementality
.
startup
(
)
;
Assert
.
strictEqual
(
DAPIncrementality
.
dapReportContoller
null
"
dapReportContoller
should
not
exist
before
enrollment
"
)
;
const
doExperimentCleanup
=
await
NimbusTestUtils
.
enrollWithFeatureConfig
(
{
featureId
:
"
dapIncrementality
"
value
:
{
measurementType
:
"
referrerMeasurement
"
taskId
:
TASK_ID
length
:
3
timePrecision
:
3600
referrerUrls
:
[
{
url
:
"
*
:
/
/
*
.
mozilla
.
org
/
ref
"
bucket
:
1
}
]
targetUrls
:
"
*
:
/
/
*
.
mozilla
.
org
/
target
"
unknownReferrerBucket
:
2
}
}
)
;
let
timestamp
=
Date
.
now
(
)
*
1000
;
await
PlacesTestUtils
.
addVisits
(
{
url
:
NetUtil
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
"
)
transition
:
TRANSITION_TYPED
visitDate
:
timestamp
}
)
;
const
incrDb
=
await
openIncrDatabase
(
)
;
let
state
=
await
getReferrerState
(
incrDb
TASK_ID
)
;
Assert
.
strictEqual
(
state
undefined
"
No
referrer
state
should
be
recorded
"
)
;
timestamp
=
Date
.
now
(
)
*
1000
;
await
PlacesTestUtils
.
addVisits
(
{
url
:
NetUtil
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
ref
"
)
transition
:
TRANSITION_TYPED
visitDate
:
timestamp
}
)
;
state
=
await
getReferrerState
(
incrDb
TASK_ID
)
;
Assert
.
strictEqual
(
state
.
bucket
1
"
Referrer
state
should
be
1
"
)
;
timestamp
=
Date
.
now
(
)
*
1000
;
await
PlacesTestUtils
.
addVisits
(
{
url
:
NetUtil
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
target
"
)
transition
:
TRANSITION_TYPED
visitDate
:
timestamp
}
)
;
const
subCapDb
=
await
openSubCapDatabase
(
)
;
let
pendingReport
=
await
getReport
(
subCapDb
TASK_ID
)
;
Assert
.
equal
(
pendingReport
.
measurement
1
"
Pending
measurement
value
should
be
1
"
)
;
state
=
await
getReferrerState
(
incrDb
TASK_ID
)
;
Assert
.
strictEqual
(
state
undefined
"
Referrer
state
should
be
cleared
"
)
;
await
DAPIncrementality
.
dapReportContoller
.
submit
(
1000
"
unit
-
test
"
)
;
await
doExperimentCleanup
(
)
;
Services
.
tm
.
spinEventLoopUntil
(
"
Wait
for
DAPIncrementality
to
flush
"
(
)
=
>
DAPIncrementality
.
config
=
=
=
null
)
;
Assert
.
deepEqual
(
server_requests
[
438
438
438
]
"
Should
have
one
report
on
enrollment
second
for
triggered
submission
third
on
unenrollment
"
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_NORMANDY
}
async
function
testReferrerMeasurementParsingMultiTargetNimbus
(
)
{
resetServerRequests
(
)
;
const
{
cleanup
}
=
await
NimbusTestUtils
.
setupTest
(
)
;
await
DAPIncrementality
.
startup
(
)
;
Assert
.
strictEqual
(
DAPIncrementality
.
dapReportContoller
null
"
dapReportContoller
should
not
exist
before
enrollment
"
)
;
const
targetUrls
=
"
*
:
/
/
*
.
mozilla
.
org
/
target1
*
:
/
/
*
.
mozilla
.
org
/
target2
"
;
const
doExperimentCleanup
=
await
NimbusTestUtils
.
enrollWithFeatureConfig
(
{
featureId
:
"
dapIncrementality
"
value
:
{
measurementType
:
"
referrerMeasurement
"
taskId
:
TASK_ID
length
:
3
timePrecision
:
3600
referrerUrls
:
[
{
url
:
"
*
:
/
/
*
.
mozilla
.
org
/
ref
"
bucket
:
1
}
]
targetUrls
unknownReferrerBucket
:
2
}
}
)
;
Assert
.
strictEqual
(
DAPIncrementality
.
config
.
targetUrlPatterns
.
length
2
"
List
should
contain
2
urls
patterns
"
)
;
const
missingUrls
=
DAPIncrementality
.
config
.
targetUrlPatterns
.
filter
(
s
=
>
!
targetUrls
.
includes
(
s
.
pattern
)
)
;
Assert
.
deepEqual
(
missingUrls
[
]
"
All
urls
in
the
list
should
be
found
in
the
targetUrlPatterns
"
)
;
await
doExperimentCleanup
(
)
;
Services
.
tm
.
spinEventLoopUntil
(
"
Wait
for
DAPIncrementality
to
flush
"
(
)
=
>
DAPIncrementality
.
config
=
=
=
null
)
;
Assert
.
deepEqual
(
server_requests
[
438
438
]
"
Should
have
one
report
on
enrollment
second
on
unenrollment
"
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_NORMANDY
}
async
function
testReferrerMeasurementUnknownBucketNotSetNimbus
(
)
{
resetServerRequests
(
)
;
const
{
cleanup
}
=
await
NimbusTestUtils
.
setupTest
(
)
;
await
DAPIncrementality
.
startup
(
)
;
Assert
.
strictEqual
(
DAPIncrementality
.
dapReportContoller
null
"
dapReportContoller
should
not
exist
before
enrollment
"
)
;
const
doExperimentCleanup
=
await
NimbusTestUtils
.
enrollWithFeatureConfig
(
{
featureId
:
"
dapIncrementality
"
value
:
{
measurementType
:
"
referrerMeasurement
"
taskId
:
TASK_ID
length
:
3
timePrecision
:
3600
referrerUrls
:
[
{
url
:
"
*
:
/
/
*
.
mozilla
.
org
/
ref
"
bucket
:
1
}
]
targetUrls
:
"
*
:
/
/
*
.
mozilla
.
org
/
target
"
}
}
)
;
let
timestamp
=
Date
.
now
(
)
*
1000
;
await
PlacesTestUtils
.
addVisits
(
{
url
:
NetUtil
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
target
"
)
transition
:
TRANSITION_TYPED
visitDate
:
timestamp
}
)
;
const
incrDb
=
await
openIncrDatabase
(
)
;
let
state
=
await
getReferrerState
(
incrDb
TASK_ID
)
;
Assert
.
strictEqual
(
state
undefined
"
No
referrer
state
should
be
recorded
"
)
;
const
subCapDb
=
await
openSubCapDatabase
(
)
;
let
pendingReport
=
await
getReport
(
subCapDb
TASK_ID
)
;
Assert
.
equal
(
pendingReport
undefined
"
No
pending
report
should
be
recorded
"
)
;
await
doExperimentCleanup
(
)
;
Services
.
tm
.
spinEventLoopUntil
(
"
Wait
for
DAPIncrementality
to
flush
"
(
)
=
>
DAPIncrementality
.
config
=
=
=
null
)
;
Assert
.
deepEqual
(
server_requests
[
438
438
]
"
Should
have
one
report
on
enrollment
second
on
unenrollment
"
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_NORMANDY
}
async
function
testReferrerMeasurementUnknownBucketSet
(
)
{
resetServerRequests
(
)
;
const
{
cleanup
}
=
await
NimbusTestUtils
.
setupTest
(
)
;
await
DAPIncrementality
.
startup
(
)
;
Assert
.
strictEqual
(
DAPIncrementality
.
dapReportContoller
null
"
dapReportContoller
should
not
exist
before
enrollment
"
)
;
const
doExperimentCleanup
=
await
NimbusTestUtils
.
enrollWithFeatureConfig
(
{
featureId
:
"
dapIncrementality
"
value
:
{
measurementType
:
"
referrerMeasurement
"
taskId
:
TASK_ID
length
:
3
timePrecision
:
3600
referrerUrls
:
[
{
url
:
"
*
:
/
/
*
.
mozilla
.
org
/
ref
"
bucket
:
1
}
]
targetUrls
:
"
*
:
/
/
*
.
mozilla
.
org
/
target
"
unknownReferrerBucket
:
2
}
}
)
;
let
timestamp
=
Date
.
now
(
)
*
1000
;
await
PlacesTestUtils
.
addVisits
(
{
url
:
NetUtil
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
"
)
transition
:
TRANSITION_TYPED
visitDate
:
timestamp
}
)
;
const
incrDb
=
await
openIncrDatabase
(
)
;
let
state
=
await
getReferrerState
(
incrDb
TASK_ID
)
;
Assert
.
strictEqual
(
state
undefined
"
No
referrer
state
should
be
recorded
"
)
;
timestamp
=
Date
.
now
(
)
*
1000
;
await
PlacesTestUtils
.
addVisits
(
{
url
:
NetUtil
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
target
"
)
transition
:
TRANSITION_TYPED
visitDate
:
timestamp
}
)
;
state
=
await
getReferrerState
(
incrDb
TASK_ID
)
;
Assert
.
strictEqual
(
state
undefined
"
No
referrer
state
should
be
recorded
"
)
;
const
subCapDb
=
await
openSubCapDatabase
(
)
;
let
pendingReport
=
await
getReport
(
subCapDb
TASK_ID
)
;
Assert
.
equal
(
pendingReport
.
measurement
2
"
Pending
measurement
value
should
be
2
"
)
;
await
DAPIncrementality
.
dapReportContoller
.
submit
(
1000
"
unit
-
test
"
)
;
await
doExperimentCleanup
(
)
;
Services
.
tm
.
spinEventLoopUntil
(
"
Wait
for
DAPIncrementality
to
flush
"
(
)
=
>
DAPIncrementality
.
config
=
=
=
null
)
;
Assert
.
deepEqual
(
server_requests
[
438
438
438
]
"
Should
have
one
report
on
enrollment
second
for
triggered
submission
third
on
unenrollment
"
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_NORMANDY
}
async
function
testMultiReferrerMeasurementUnknownBucketNotSetNimbus
(
)
{
resetServerRequests
(
)
;
const
{
cleanup
}
=
await
NimbusTestUtils
.
setupTest
(
)
;
await
DAPIncrementality
.
startup
(
)
;
Assert
.
strictEqual
(
DAPIncrementality
.
dapReportContoller
null
"
dapReportContoller
should
not
exist
before
enrollment
"
)
;
const
doExperimentCleanup
=
await
NimbusTestUtils
.
enrollWithFeatureConfig
(
{
featureId
:
"
dapIncrementality
"
value
:
{
measurementType
:
"
referrerMeasurement
"
taskId
:
TASK_ID
length
:
3
timePrecision
:
3600
referrerUrls
:
[
{
url
:
"
*
:
/
/
*
.
mozilla
.
org
/
ref
"
bucket
:
1
}
{
url
:
"
*
:
/
/
*
.
mozilla
.
org
/
ref2
"
bucket
:
2
}
]
targetUrls
:
"
*
:
/
/
*
.
mozilla
.
org
/
target
"
}
}
)
;
let
timestamp
=
Date
.
now
(
)
*
1000
;
await
PlacesTestUtils
.
addVisits
(
{
url
:
NetUtil
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
ref
"
)
transition
:
TRANSITION_TYPED
visitDate
:
timestamp
}
)
;
const
incrDb
=
await
openIncrDatabase
(
)
;
let
state
=
await
getReferrerState
(
incrDb
TASK_ID
)
;
Assert
.
strictEqual
(
state
.
bucket
1
"
Referrer
state
should
be
1
"
)
;
timestamp
=
Date
.
now
(
)
*
1000
;
await
PlacesTestUtils
.
addVisits
(
{
url
:
NetUtil
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
ref2
"
)
transition
:
TRANSITION_TYPED
visitDate
:
timestamp
}
)
;
state
=
await
getReferrerState
(
incrDb
TASK_ID
)
;
Assert
.
strictEqual
(
state
.
bucket
2
"
Referrer
state
should
be
2
"
)
;
timestamp
=
Date
.
now
(
)
*
1000
;
await
PlacesTestUtils
.
addVisits
(
{
url
:
NetUtil
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
target
"
)
transition
:
TRANSITION_TYPED
visitDate
:
timestamp
}
)
;
const
subCapDb
=
await
openSubCapDatabase
(
)
;
let
pendingReport
=
await
getReport
(
subCapDb
TASK_ID
)
;
Assert
.
equal
(
pendingReport
.
measurement
2
"
Pending
measurement
value
should
be
2
"
)
;
state
=
await
getReferrerState
(
incrDb
TASK_ID
)
;
Assert
.
strictEqual
(
state
undefined
"
Referrer
state
should
be
cleared
"
)
;
await
DAPIncrementality
.
dapReportContoller
.
submit
(
1000
"
unit
-
test
"
)
;
await
doExperimentCleanup
(
)
;
Services
.
tm
.
spinEventLoopUntil
(
"
Wait
for
DAPIncrementality
to
flush
"
(
)
=
>
DAPIncrementality
.
config
=
=
=
null
)
;
Assert
.
deepEqual
(
server_requests
[
438
438
438
]
"
Should
have
one
report
on
enrollment
second
for
triggered
submission
third
on
unenrollment
"
)
;
await
cleanup
(
)
;
}
)
;
