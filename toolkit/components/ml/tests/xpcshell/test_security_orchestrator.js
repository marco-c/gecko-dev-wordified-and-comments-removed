"
use
strict
"
;
const
{
SecurityOrchestrator
getSecurityOrchestrator
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
global
/
content
/
ml
/
security
/
SecurityOrchestrator
.
sys
.
mjs
"
)
;
const
PREF_SECURITY_ENABLED
=
"
browser
.
ml
.
security
.
enabled
"
;
const
TEST_SESSION_ID
=
"
test
-
session
"
;
let
orchestrator
=
null
;
function
setup
(
)
{
Services
.
prefs
.
clearUserPref
(
PREF_SECURITY_ENABLED
)
;
}
async
function
teardown
(
)
{
Services
.
prefs
.
clearUserPref
(
PREF_SECURITY_ENABLED
)
;
await
SecurityOrchestrator
.
resetForTesting
(
)
;
orchestrator
=
null
;
}
add_task
(
async
function
test_initialization_creates_session
(
)
{
setup
(
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
orchestrator
.
registerSession
(
TEST_SESSION_ID
)
;
const
ledger
=
orchestrator
.
getSessionLedger
(
TEST_SESSION_ID
)
;
Assert
.
ok
(
ledger
"
Should
return
session
ledger
"
)
;
Assert
.
equal
(
ledger
.
tabCount
(
)
0
"
Should
start
with
no
tabs
"
)
;
Assert
.
ok
(
orchestrator
.
getSessionLedger
(
TEST_SESSION_ID
)
"
Should
be
able
to
get
session
ledger
"
)
;
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_pref_switch_disabled_allows_everything
(
)
{
setup
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_SECURITY_ENABLED
false
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
orchestrator
.
registerSession
(
TEST_SESSION_ID
)
;
const
ledger
=
orchestrator
.
getSessionLedger
(
TEST_SESSION_ID
)
;
ledger
.
forTab
(
"
tab
-
1
"
)
;
const
decision
=
await
orchestrator
.
evaluate
(
TEST_SESSION_ID
{
phase
:
"
tool
.
execution
"
action
:
{
type
:
"
tool
.
call
"
tool
:
"
get_page_content
"
urls
:
[
"
https
:
/
/
evil
.
com
"
]
tabId
:
"
tab
-
1
"
}
context
:
{
currentTabId
:
"
tab
-
1
"
mentionedTabIds
:
[
]
requestId
:
"
test
-
123
"
}
}
)
;
Assert
.
equal
(
decision
.
effect
"
allow
"
"
Pref
switch
OFF
:
should
allow
everything
(
pass
-
through
)
"
)
;
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_pref_switch_enabled_enforces_policies
(
)
{
setup
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_SECURITY_ENABLED
true
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
orchestrator
.
registerSession
(
TEST_SESSION_ID
)
;
const
ledger
=
orchestrator
.
getSessionLedger
(
TEST_SESSION_ID
)
;
ledger
.
forTab
(
"
tab
-
1
"
)
;
const
decision
=
await
orchestrator
.
evaluate
(
TEST_SESSION_ID
{
phase
:
"
tool
.
execution
"
action
:
{
type
:
"
tool
.
call
"
tool
:
"
get_page_content
"
urls
:
[
"
https
:
/
/
evil
.
com
"
]
tabId
:
"
tab
-
1
"
}
context
:
{
currentTabId
:
"
tab
-
1
"
mentionedTabIds
:
[
]
requestId
:
"
test
-
123
"
}
}
)
;
Assert
.
equal
(
decision
.
effect
"
deny
"
"
Pref
switch
ON
:
should
enforce
"
)
;
Assert
.
equal
(
decision
.
code
"
UNSEEN_LINK
"
"
Should
deny
unseen
links
"
)
;
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_pref_switch_runtime_change
(
)
{
setup
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_SECURITY_ENABLED
true
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
orchestrator
.
registerSession
(
TEST_SESSION_ID
)
;
const
ledger
=
orchestrator
.
getSessionLedger
(
TEST_SESSION_ID
)
;
ledger
.
forTab
(
"
tab
-
1
"
)
;
const
envelope
=
{
phase
:
"
tool
.
execution
"
action
:
{
type
:
"
tool
.
call
"
tool
:
"
get_page_content
"
urls
:
[
"
https
:
/
/
evil
.
com
"
]
tabId
:
"
tab
-
1
"
}
context
:
{
currentTabId
:
"
tab
-
1
"
mentionedTabIds
:
[
]
requestId
:
"
req
-
1
"
}
}
;
let
decision
=
await
orchestrator
.
evaluate
(
TEST_SESSION_ID
envelope
)
;
Assert
.
equal
(
decision
.
effect
"
deny
"
"
Should
deny
when
enabled
"
)
;
Services
.
prefs
.
setBoolPref
(
PREF_SECURITY_ENABLED
false
)
;
decision
=
await
orchestrator
.
evaluate
(
TEST_SESSION_ID
envelope
)
;
Assert
.
equal
(
decision
.
effect
"
allow
"
"
Should
allow
immediately
after
runtime
disable
"
)
;
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_invalid_envelope_throws
(
)
{
setup
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_SECURITY_ENABLED
true
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
orchestrator
.
registerSession
(
TEST_SESSION_ID
)
;
await
Assert
.
rejects
(
orchestrator
.
evaluate
(
TEST_SESSION_ID
null
)
/
Security
envelope
is
null
or
invalid
/
"
Null
envelope
should
throw
"
)
;
await
Assert
.
rejects
(
orchestrator
.
evaluate
(
TEST_SESSION_ID
{
action
:
{
type
:
"
test
"
}
context
:
{
}
}
)
/
Security
envelope
missing
required
fields
/
"
Missing
phase
should
throw
"
)
;
await
Assert
.
rejects
(
orchestrator
.
evaluate
(
TEST_SESSION_ID
{
phase
:
"
test
"
context
:
{
}
}
)
/
Security
envelope
missing
required
fields
/
"
Missing
action
should
throw
"
)
;
await
Assert
.
rejects
(
orchestrator
.
evaluate
(
TEST_SESSION_ID
{
phase
:
"
test
"
action
:
{
type
:
"
test
"
}
}
)
/
Security
envelope
missing
required
fields
/
"
Missing
context
should
throw
"
)
;
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_policy_allows_seeded_url
(
)
{
setup
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_SECURITY_ENABLED
true
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
orchestrator
.
registerSession
(
TEST_SESSION_ID
)
;
const
ledger
=
orchestrator
.
getSessionLedger
(
TEST_SESSION_ID
)
;
ledger
.
forTab
(
"
tab
-
1
"
)
.
add
(
"
https
:
/
/
example
.
com
"
)
;
const
decision
=
await
orchestrator
.
evaluate
(
TEST_SESSION_ID
{
phase
:
"
tool
.
execution
"
action
:
{
type
:
"
tool
.
call
"
tool
:
"
get_page_content
"
urls
:
[
"
https
:
/
/
example
.
com
"
]
tabId
:
"
tab
-
1
"
}
context
:
{
currentTabId
:
"
tab
-
1
"
mentionedTabIds
:
[
]
requestId
:
"
test
-
123
"
}
}
)
;
Assert
.
equal
(
decision
.
effect
"
allow
"
"
Should
allow
seeded
URL
"
)
;
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_policy_denies_unseen_url
(
)
{
setup
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_SECURITY_ENABLED
true
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
orchestrator
.
registerSession
(
TEST_SESSION_ID
)
;
const
ledger
=
orchestrator
.
getSessionLedger
(
TEST_SESSION_ID
)
;
ledger
.
forTab
(
"
tab
-
1
"
)
;
const
decision
=
await
orchestrator
.
evaluate
(
TEST_SESSION_ID
{
phase
:
"
tool
.
execution
"
action
:
{
type
:
"
tool
.
call
"
tool
:
"
get_page_content
"
urls
:
[
"
https
:
/
/
evil
.
com
"
]
tabId
:
"
tab
-
1
"
}
context
:
{
currentTabId
:
"
tab
-
1
"
mentionedTabIds
:
[
]
requestId
:
"
test
-
123
"
}
}
)
;
Assert
.
equal
(
decision
.
effect
"
deny
"
"
Should
deny
unseen
URL
"
)
;
Assert
.
equal
(
decision
.
code
"
UNSEEN_LINK
"
"
Should
have
UNSEEN_LINK
code
"
)
;
Assert
.
ok
(
decision
.
reason
"
Should
have
reason
"
)
;
Assert
.
equal
(
decision
.
policyId
"
block
-
unseen
-
links
"
"
Should
identify
policy
"
)
;
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_policy_denies_if_any_url_unseen
(
)
{
setup
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_SECURITY_ENABLED
true
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
orchestrator
.
registerSession
(
TEST_SESSION_ID
)
;
const
ledger
=
orchestrator
.
getSessionLedger
(
TEST_SESSION_ID
)
;
ledger
.
forTab
(
"
tab
-
1
"
)
.
add
(
"
https
:
/
/
example
.
com
"
)
;
const
decision
=
await
orchestrator
.
evaluate
(
TEST_SESSION_ID
{
phase
:
"
tool
.
execution
"
action
:
{
type
:
"
tool
.
call
"
tool
:
"
get_page_content
"
urls
:
[
"
https
:
/
/
example
.
com
"
"
https
:
/
/
evil
.
com
"
]
tabId
:
"
tab
-
1
"
}
context
:
{
currentTabId
:
"
tab
-
1
"
mentionedTabIds
:
[
]
requestId
:
"
test
-
123
"
}
}
)
;
Assert
.
equal
(
decision
.
effect
"
deny
"
"
Should
deny
if
ANY
URL
unseen
(
all
-
or
-
nothing
)
"
)
;
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_malformed_url_fails_closed
(
)
{
setup
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_SECURITY_ENABLED
true
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
orchestrator
.
registerSession
(
TEST_SESSION_ID
)
;
const
ledger
=
orchestrator
.
getSessionLedger
(
TEST_SESSION_ID
)
;
ledger
.
forTab
(
"
tab
-
1
"
)
;
const
decision
=
await
orchestrator
.
evaluate
(
TEST_SESSION_ID
{
phase
:
"
tool
.
execution
"
action
:
{
type
:
"
tool
.
call
"
tool
:
"
get_page_content
"
urls
:
[
"
not
-
a
-
valid
-
url
"
]
tabId
:
"
tab
-
1
"
}
context
:
{
currentTabId
:
"
tab
-
1
"
mentionedTabIds
:
[
]
requestId
:
"
test
-
123
"
}
}
)
;
Assert
.
equal
(
decision
.
effect
"
deny
"
"
Malformed
URL
should
fail
closed
(
deny
)
"
)
;
Assert
.
equal
(
decision
.
code
"
UNSEEN_LINK
"
"
Should
have
UNSEEN_LINK
code
"
)
;
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_unknown_session_throws
(
)
{
setup
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_SECURITY_ENABLED
true
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
await
Assert
.
rejects
(
orchestrator
.
evaluate
(
"
unknown
-
session
"
{
phase
:
"
tool
.
execution
"
action
:
{
type
:
"
tool
.
call
"
tool
:
"
get_page_content
"
urls
:
[
"
https
:
/
/
example
.
com
"
]
tabId
:
"
tab
-
1
"
}
context
:
{
currentTabId
:
"
tab
-
1
"
mentionedTabIds
:
[
]
requestId
:
"
test
-
123
"
}
}
)
/
Session
unknown
-
session
is
not
registered
/
"
Unknown
session
should
throw
"
)
;
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_register_session_idempotent
(
)
{
setup
(
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
orchestrator
.
registerSession
(
TEST_SESSION_ID
)
;
const
ledger1
=
orchestrator
.
getSessionLedger
(
TEST_SESSION_ID
)
;
ledger1
.
forTab
(
"
tab
-
1
"
)
.
add
(
"
https
:
/
/
example
.
com
"
)
;
orchestrator
.
registerSession
(
TEST_SESSION_ID
)
;
const
ledger2
=
orchestrator
.
getSessionLedger
(
TEST_SESSION_ID
)
;
Assert
.
equal
(
ledger1
ledger2
"
Should
return
same
ledger
instance
"
)
;
Assert
.
ok
(
ledger2
.
forTab
(
"
tab
-
1
"
)
.
has
(
"
https
:
/
/
example
.
com
"
)
"
Ledger
data
should
be
preserved
"
)
;
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_cleanup_session_removes_ledger
(
)
{
setup
(
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
orchestrator
.
registerSession
(
TEST_SESSION_ID
)
;
Assert
.
ok
(
orchestrator
.
getSessionLedger
(
TEST_SESSION_ID
)
"
Ledger
should
exist
"
)
;
orchestrator
.
cleanupSession
(
TEST_SESSION_ID
)
;
Assert
.
equal
(
orchestrator
.
getSessionLedger
(
TEST_SESSION_ID
)
undefined
"
Ledger
should
be
removed
after
cleanup
"
)
;
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_cleanup_session_idempotent
(
)
{
setup
(
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
orchestrator
.
cleanupSession
(
"
non
-
existent
-
session
"
)
;
orchestrator
.
cleanupSession
(
"
non
-
existent
-
session
"
)
;
orchestrator
.
registerSession
(
TEST_SESSION_ID
)
;
orchestrator
.
cleanupSession
(
TEST_SESSION_ID
)
;
orchestrator
.
cleanupSession
(
TEST_SESSION_ID
)
;
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_register_session_rejects_invalid_id
(
)
{
setup
(
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
const
invalidIds
=
[
null
undefined
"
"
123
{
}
[
]
]
;
for
(
const
invalidId
of
invalidIds
)
{
Assert
.
throws
(
(
)
=
>
orchestrator
.
registerSession
(
invalidId
)
/
registerSession
requires
a
non
-
empty
string
sessionId
/
Should
reject
invalid
sessionId
:
{
JSON
.
stringify
(
invalidId
)
}
)
;
}
await
teardown
(
)
;
}
)
;
add_task
(
async
function
test_get_stats_returns_session_count
(
)
{
setup
(
)
;
orchestrator
=
await
getSecurityOrchestrator
(
)
;
let
stats
=
orchestrator
.
getStats
(
)
;
Assert
.
equal
(
stats
.
sessionCount
0
"
Should
start
with
0
sessions
"
)
;
orchestrator
.
registerSession
(
"
session
-
1
"
)
;
orchestrator
.
registerSession
(
"
session
-
2
"
)
;
stats
=
orchestrator
.
getStats
(
)
;
Assert
.
equal
(
stats
.
sessionCount
2
"
Should
have
2
sessions
"
)
;
Assert
.
ok
(
stats
.
sessionStats
[
"
session
-
1
"
]
"
Should
have
stats
for
session
-
1
"
)
;
Assert
.
ok
(
stats
.
sessionStats
[
"
session
-
2
"
]
"
Should
have
stats
for
session
-
2
"
)
;
orchestrator
.
cleanupSession
(
"
session
-
1
"
)
;
stats
=
orchestrator
.
getStats
(
)
;
Assert
.
equal
(
stats
.
sessionCount
1
"
Should
have
1
session
after
cleanup
"
)
;
await
teardown
(
)
;
}
)
;
