"
use
strict
"
;
const
{
sinon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
)
;
const
FAKE_HUB
=
"
chrome
:
/
/
mochitests
/
content
/
browser
/
toolkit
/
components
/
ml
/
tests
/
browser
/
data
"
;
const
FAKE_MODEL_ARGS
=
{
model
:
"
acme
/
bert
"
revision
:
"
main
"
file
:
"
config
.
json
"
}
;
const
FAKE_RELEASED_MODEL_ARGS
=
{
model
:
"
acme
/
bert
"
revision
:
"
v0
.
1
"
file
:
"
config
.
json
"
}
;
const
FAKE_ONNX_MODEL_ARGS
=
{
model
:
"
acme
/
bert
"
revision
:
"
main
"
file
:
"
onnx
/
config
.
json
"
}
;
const
badHubs
=
[
"
https
:
/
/
my
.
cool
.
hub
"
"
https
:
/
/
sub
.
localhost
/
myhub
"
"
https
:
/
/
model
-
hub
.
mozilla
.
org
.
evil
.
com
"
"
httpsz
:
/
/
localhost
/
myhub
"
"
https
:
/
/
localhost
.
"
"
resource
:
/
/
user
localhost
"
"
ftp
:
/
/
localhost
/
myhub
"
"
https
:
/
/
model
-
hub
.
mozilla
.
org
.
hack
"
]
;
add_task
(
async
function
test_bad_hubs
(
)
{
for
(
const
badHub
of
badHubs
)
{
Assert
.
throws
(
(
)
=
>
new
ModelHub
(
{
rootUrl
:
badHub
}
)
new
RegExp
(
Error
:
Invalid
model
hub
root
url
:
{
badHub
}
)
Should
throw
with
{
badHub
}
)
;
}
}
)
;
let
goodHubs
=
[
"
https
:
/
/
/
localhost
/
myhub
"
"
https
:
/
/
localhost
:
8080
/
myhub
"
"
http
:
/
/
localhost
/
myhub
"
"
https
:
/
/
model
-
hub
.
mozilla
.
org
"
"
chrome
:
/
/
gre
/
somewhere
/
in
/
the
/
code
/
base
"
]
;
add_task
(
async
function
test_allowed_hub
(
)
{
goodHubs
.
forEach
(
url
=
>
new
ModelHub
(
{
rootUrl
:
url
}
)
)
;
}
)
;
add_task
(
async
function
test_allow_external_ml_hub
(
)
{
Services
.
env
.
set
(
"
MOZ_ALLOW_EXTERNAL_ML_HUB
"
"
1
"
)
;
new
ModelHub
(
{
rootUrl
:
"
https
:
/
/
huggingface
.
co
"
}
)
;
Services
.
env
.
set
(
"
MOZ_ALLOW_EXTERNAL_ML_HUB
"
"
"
)
;
}
)
;
const
badInputs
=
[
[
{
model
:
"
ac
me
/
bert
"
revision
:
"
main
"
file
:
"
config
.
json
"
}
"
Org
can
only
contain
letters
numbers
and
hyphens
"
]
[
{
model
:
"
1111
/
bert
"
revision
:
"
main
"
file
:
"
config
.
json
"
}
"
Org
cannot
contain
only
numbers
"
]
[
{
model
:
"
-
acme
/
bert
"
revision
:
"
main
"
file
:
"
config
.
json
"
}
"
Org
start
or
end
with
a
hyphen
or
use
consecutive
hyphens
"
]
[
{
model
:
"
a
-
c
-
m
-
e
/
#
bert
"
revision
:
"
main
"
file
:
"
config
.
json
"
}
"
Models
can
only
contain
letters
numbers
and
hyphens
underscord
periods
"
]
[
{
model
:
"
a
-
c
-
m
-
e
/
b
ert
"
revision
:
"
main
"
file
:
"
config
.
json
"
}
"
Models
cannot
contain
spaces
or
control
characters
"
]
[
{
model
:
"
a
-
c
-
m
-
e
/
b
ert
"
revision
:
"
main
"
file
:
"
.
filename
"
}
"
File
"
]
]
;
add_task
(
async
function
test_bad_inputs
(
)
{
const
hub
=
new
ModelHub
(
{
rootUrl
:
FAKE_HUB
}
)
;
for
(
const
badInput
of
badInputs
)
{
const
params
=
badInput
[
0
]
;
const
errorMsg
=
badInput
[
1
]
;
try
{
await
hub
.
getModelFileAsArrayBuffer
(
params
)
;
}
catch
(
error
)
{
continue
;
}
throw
new
Error
(
errorMsg
)
;
}
}
)
;
add_task
(
async
function
test_getting_file
(
)
{
const
hub
=
new
ModelHub
(
{
rootUrl
:
FAKE_HUB
}
)
;
let
[
array
headers
]
=
await
hub
.
getModelFileAsArrayBuffer
(
FAKE_MODEL_ARGS
)
;
Assert
.
equal
(
headers
[
"
Content
-
Type
"
]
"
application
/
json
"
)
;
let
jsonData
=
JSON
.
parse
(
String
.
fromCharCode
.
apply
(
null
new
Uint8Array
(
array
)
)
)
;
Assert
.
equal
(
jsonData
.
hidden_size
768
)
;
}
)
;
add_task
(
async
function
test_getting_released_file
(
)
{
const
hub
=
new
ModelHub
(
{
rootUrl
:
FAKE_HUB
}
)
;
console
.
log
(
hub
)
;
let
spy
=
sinon
.
spy
(
hub
"
getETag
"
)
;
let
[
array
headers
]
=
await
hub
.
getModelFileAsArrayBuffer
(
FAKE_RELEASED_MODEL_ARGS
)
;
Assert
.
equal
(
headers
[
"
Content
-
Type
"
]
"
application
/
json
"
)
;
let
jsonData
=
JSON
.
parse
(
String
.
fromCharCode
.
apply
(
null
new
Uint8Array
(
array
)
)
)
;
Assert
.
equal
(
jsonData
.
hidden_size
768
)
;
Assert
.
ok
(
!
spy
.
called
"
getETag
should
have
never
been
called
.
"
)
;
spy
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_getting_file_in_subdir
(
)
{
const
hub
=
new
ModelHub
(
{
rootUrl
:
FAKE_HUB
}
)
;
let
[
array
metadata
]
=
await
hub
.
getModelFileAsArrayBuffer
(
FAKE_ONNX_MODEL_ARGS
)
;
Assert
.
equal
(
metadata
[
"
Content
-
Type
"
]
"
application
/
json
"
)
;
let
jsonData
=
JSON
.
parse
(
String
.
fromCharCode
.
apply
(
null
new
Uint8Array
(
array
)
)
)
;
Assert
.
equal
(
jsonData
.
hidden_size
768
)
;
}
)
;
add_task
(
async
function
test_getting_file_custom_path
(
)
{
const
hub
=
new
ModelHub
(
{
rootUrl
:
FAKE_HUB
urlTemplate
:
"
{
model
}
/
resolve
/
{
revision
}
"
}
)
;
let
res
=
await
hub
.
getModelFileAsArrayBuffer
(
FAKE_MODEL_ARGS
)
;
Assert
.
equal
(
res
[
1
]
[
"
Content
-
Type
"
]
"
application
/
json
"
)
;
}
)
;
add_task
(
async
function
test_getting_file_custom_path_rogue
(
)
{
const
urlTemplate
=
"
{
model
}
/
resolve
/
{
revision
}
/
?
some_id
=
bedqwdw
"
;
Assert
.
throws
(
(
)
=
>
new
ModelHub
(
{
rootUrl
:
FAKE_HUB
urlTemplate
}
)
/
Invalid
URL
template
/
Should
throw
with
{
urlTemplate
}
)
;
}
)
;
add_task
(
async
function
test_getting_file_as_response
(
)
{
const
hub
=
new
ModelHub
(
{
rootUrl
:
FAKE_HUB
}
)
;
let
response
=
await
hub
.
getModelFileAsResponse
(
FAKE_MODEL_ARGS
)
;
let
jsonData
=
await
response
.
json
(
)
;
Assert
.
equal
(
jsonData
.
hidden_size
768
)
;
}
)
;
add_task
(
async
function
test_getting_file_from_cache
(
)
{
const
hub
=
new
ModelHub
(
{
rootUrl
:
FAKE_HUB
}
)
;
let
array
=
await
hub
.
getModelFileAsArrayBuffer
(
FAKE_MODEL_ARGS
)
;
let
matchMethod
=
hub
.
cache
.
_testGetData
;
sinon
.
stub
(
hub
.
cache
"
_testGetData
"
)
.
callsFake
(
function
(
)
{
return
matchMethod
.
apply
(
this
arguments
)
.
then
(
result
=
>
{
Assert
.
notEqual
(
result
null
)
;
return
result
;
}
)
;
}
)
;
let
array2
=
await
hub
.
getModelFileAsArrayBuffer
(
FAKE_MODEL_ARGS
)
;
hub
.
cache
.
_testGetData
.
restore
(
)
;
Assert
.
deepEqual
(
array
array2
)
;
}
)
;
add_task
(
async
function
testWellFormedFullUrl
(
)
{
const
hub
=
new
ModelHub
(
{
rootUrl
:
FAKE_HUB
}
)
;
const
url
=
{
FAKE_HUB
}
/
org1
/
model1
/
v1
/
file
/
path
;
const
result
=
hub
.
parseUrl
(
url
)
;
Assert
.
equal
(
result
.
model
"
org1
/
model1
"
"
Model
should
be
parsed
correctly
.
"
)
;
Assert
.
equal
(
result
.
revision
"
v1
"
"
Revision
should
be
parsed
correctly
.
"
)
;
Assert
.
equal
(
result
.
file
"
file
/
path
"
"
File
path
should
be
parsed
correctly
.
"
)
;
}
)
;
add_task
(
async
function
testWellFormedRelativeUrl
(
)
{
const
hub
=
new
ModelHub
(
{
rootUrl
:
FAKE_HUB
}
)
;
const
url
=
"
/
org1
/
model1
/
v1
/
file
/
path
"
;
const
result
=
hub
.
parseUrl
(
url
)
;
Assert
.
equal
(
result
.
model
"
org1
/
model1
"
"
Model
should
be
parsed
correctly
.
"
)
;
Assert
.
equal
(
result
.
revision
"
v1
"
"
Revision
should
be
parsed
correctly
.
"
)
;
Assert
.
equal
(
result
.
file
"
file
/
path
"
"
File
path
should
be
parsed
correctly
.
"
)
;
}
)
;
add_task
(
async
function
testInvalidDomain
(
)
{
const
hub
=
new
ModelHub
(
{
rootUrl
:
FAKE_HUB
}
)
;
const
url
=
"
https
:
/
/
example
.
com
/
org1
/
model1
/
v1
/
file
/
path
"
;
Assert
.
throws
(
(
)
=
>
hub
.
parseUrl
(
url
)
new
RegExp
(
Error
:
Invalid
domain
for
model
URL
:
{
url
}
)
Should
throw
with
{
url
}
)
;
}
)
;
add_task
(
async
function
testTooFewParts
(
)
{
const
hub
=
new
ModelHub
(
{
rootUrl
:
FAKE_HUB
}
)
;
const
url
=
"
/
org1
/
model1
"
;
Assert
.
throws
(
(
)
=
>
hub
.
parseUrl
(
url
)
new
RegExp
(
Error
:
Invalid
model
URL
:
{
url
}
)
Should
throw
with
{
url
}
)
;
}
)
;
async
function
initializeCache
(
)
{
const
randomSuffix
=
Math
.
floor
(
Math
.
random
(
)
*
10000
)
;
return
await
IndexedDBCache
.
init
(
modelFiles
-
{
randomSuffix
}
)
;
}
async
function
deleteCache
(
cache
)
{
await
cache
.
dispose
(
)
;
indexedDB
.
deleteDatabase
(
cache
.
dbName
)
;
}
add_task
(
async
function
test_Init
(
)
{
const
cache
=
await
initializeCache
(
)
;
Assert
.
ok
(
cache
instanceof
IndexedDBCache
"
The
cache
instance
should
be
created
successfully
.
"
)
;
Assert
.
ok
(
IDBDatabase
.
isInstance
(
cache
.
db
)
The
cache
should
have
an
IDBDatabase
instance
.
Found
{
cache
.
db
}
)
;
await
deleteCache
(
cache
)
;
}
)
;
add_task
(
async
function
test_PutAndCheckExists
(
)
{
const
cache
=
await
initializeCache
(
)
;
const
testData
=
new
ArrayBuffer
(
8
)
;
const
key
=
"
file
.
txt
"
;
await
cache
.
put
(
"
org
/
model
"
"
v1
"
"
file
.
txt
"
testData
{
ETag
:
"
ETAG123
"
}
)
;
let
exists
=
await
cache
.
fileExists
(
"
org
/
model
"
"
v1
"
key
)
;
Assert
.
ok
(
exists
"
The
file
should
exist
in
the
cache
.
"
)
;
await
cache
.
deleteModel
(
"
org
/
model
"
"
v1
"
)
;
exists
=
await
cache
.
fileExists
(
"
org
/
model
"
"
v1
"
key
)
;
Assert
.
ok
(
!
exists
"
The
file
should
be
gone
from
the
cache
.
"
)
;
await
deleteCache
(
cache
)
;
}
)
;
add_task
(
async
function
test_PutAndGet
(
)
{
const
cache
=
await
initializeCache
(
)
;
const
testData
=
new
ArrayBuffer
(
8
)
;
await
cache
.
put
(
"
org
/
model
"
"
v1
"
"
file
.
txt
"
testData
{
ETag
:
"
ETAG123
"
}
)
;
const
[
retrievedData
headers
]
=
await
cache
.
getFile
(
"
org
/
model
"
"
v1
"
"
file
.
txt
"
)
;
Assert
.
deepEqual
(
retrievedData
testData
"
The
retrieved
data
should
match
the
stored
data
.
"
)
;
Assert
.
equal
(
headers
.
ETag
"
ETAG123
"
"
The
retrieved
ETag
should
match
the
stored
ETag
.
"
)
;
await
deleteCache
(
cache
)
;
}
)
;
add_task
(
async
function
test_GetHeaders
(
)
{
const
cache
=
await
initializeCache
(
)
;
const
testData
=
new
ArrayBuffer
(
8
)
;
const
headers
=
{
ETag
:
"
ETAG123
"
status
:
200
extra
:
"
extra
"
}
;
await
cache
.
put
(
"
org
/
model
"
"
v1
"
"
file
.
txt
"
testData
headers
)
;
const
storedHeaders
=
await
cache
.
getHeaders
(
"
org
/
model
"
"
v1
"
"
file
.
txt
"
)
;
Assert
.
deepEqual
(
{
ETag
:
"
ETAG123
"
status
:
200
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
}
storedHeaders
"
The
retrieved
headers
should
match
the
stored
headers
.
"
)
;
await
deleteCache
(
cache
)
;
}
)
;
add_task
(
async
function
test_ListModels
(
)
{
const
cache
=
await
initializeCache
(
)
;
await
cache
.
put
(
"
org1
/
modelA
"
"
v1
"
"
file1
.
txt
"
new
ArrayBuffer
(
8
)
null
)
;
await
cache
.
put
(
"
org2
/
modelB
"
"
v1
"
"
file2
.
txt
"
new
ArrayBuffer
(
8
)
null
)
;
const
models
=
await
cache
.
listModels
(
)
;
Assert
.
ok
(
models
.
includes
(
"
org1
/
modelA
/
v1
"
)
&
&
models
.
includes
(
"
org2
/
modelB
/
v1
"
)
"
All
models
should
be
listed
.
"
)
;
await
deleteCache
(
cache
)
;
}
)
;
add_task
(
async
function
test_DeleteModel
(
)
{
const
cache
=
await
initializeCache
(
)
;
await
cache
.
put
(
"
org
/
model
"
"
v1
"
"
file
.
txt
"
new
ArrayBuffer
(
8
)
null
)
;
await
cache
.
deleteModel
(
"
org
/
model
"
"
v1
"
)
;
const
dataAfterDelete
=
await
cache
.
getFile
(
"
org
/
model
"
"
v1
"
"
file
.
txt
"
)
;
Assert
.
equal
(
dataAfterDelete
null
"
The
data
for
the
deleted
model
should
not
exist
.
"
)
;
await
deleteCache
(
cache
)
;
}
)
;
