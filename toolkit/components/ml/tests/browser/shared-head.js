const
{
SmartTabGroupingManager
CLUSTER_METHODS
ANCHOR_METHODS
getBestAnchorClusterInfo
}
=
ChromeUtils
.
importESModule
(
"
moz
-
src
:
/
/
/
browser
/
components
/
tabbrowser
/
SmartTabGrouping
.
sys
.
mjs
"
)
;
function
numberLooseEquals
(
a
b
decimalPoints
=
2
)
{
return
a
.
toFixed
(
decimalPoints
)
=
=
=
b
.
toFixed
(
decimalPoints
)
;
}
function
vectorLooseEquals
(
a
b
decimalPoints
=
2
)
{
return
a
.
every
(
(
item
index
)
=
>
item
.
toFixed
(
decimalPoints
)
=
=
=
b
[
index
]
.
toFixed
(
decimalPoints
)
)
;
}
function
simpleNumberSequence
(
seed
=
0
)
{
const
values
=
[
0
.
42
0
.
145
0
.
5
0
.
9234
0
.
343
0
.
1324
0
.
8343
0
.
534
0
.
634
0
.
3233
]
;
let
counter
=
Math
.
floor
(
seed
)
%
values
.
length
;
return
(
)
=
>
{
counter
=
(
counter
+
1
)
%
values
.
length
;
return
values
[
counter
]
;
}
;
}
function
shuffleArray
(
array
randFunc
)
{
randFunc
=
randFunc
?
?
Math
.
random
;
for
(
let
i
=
array
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
j
=
Math
.
floor
(
randFunc
(
)
*
(
i
+
1
)
)
;
[
array
[
i
]
array
[
j
]
]
=
[
array
[
j
]
array
[
i
]
]
;
}
}
function
averageStatsValues
(
itemArray
)
{
const
result
=
{
}
;
if
(
itemArray
.
length
=
=
=
0
)
{
return
result
;
}
for
(
const
key
of
Object
.
keys
(
itemArray
[
0
]
)
)
{
let
total
=
0
.
0
;
itemArray
.
forEach
(
a
=
>
(
total
+
=
a
[
key
]
)
)
;
result
[
key
]
=
total
/
itemArray
.
length
;
}
return
result
;
}
function
parseTsvStructured
(
tsvString
)
{
const
rows
=
tsvString
.
trim
(
)
.
split
(
"
\
n
"
)
;
const
keys
=
rows
[
0
]
.
split
(
"
\
t
"
)
;
const
arrayOfDicts
=
rows
.
slice
(
1
)
.
map
(
row
=
>
{
const
values
=
row
.
split
(
"
\
t
"
)
;
const
dict
=
{
}
;
keys
.
forEach
(
(
key
index
)
=
>
{
dict
[
key
]
=
values
[
index
]
;
}
)
;
return
dict
;
}
)
;
return
arrayOfDicts
;
}
function
parseTsvEmbeddings
(
tsvString
)
{
const
rows
=
tsvString
.
trim
(
)
.
split
(
"
\
n
"
)
;
return
rows
.
map
(
row
=
>
{
return
row
.
split
(
"
\
t
"
)
.
map
(
value
=
>
parseFloat
(
value
)
)
;
}
)
;
}
async
function
testAugmentGroup
(
clusterMethod
umapMethod
tabs
embeddings
iterations
=
1
preGroupedTabIndices
anchorMethod
=
ANCHOR_METHODS
.
FIXED
silBoost
=
undefined
)
{
const
groupManager
=
new
SmartTabGroupingManager
(
)
;
groupManager
.
setAnchorMethod
(
anchorMethod
)
;
if
(
silBoost
!
=
=
undefined
)
{
groupManager
.
setSilBoost
(
silBoost
)
;
}
const
randFunc
=
simpleNumberSequence
(
)
;
groupManager
.
setDataTitleKey
(
"
title
"
)
;
groupManager
.
setClusteringMethod
(
clusterMethod
)
;
groupManager
.
setDimensionReductionMethod
(
umapMethod
)
;
const
allScores
=
[
]
;
for
(
let
i
=
0
;
i
<
iterations
;
i
+
+
)
{
const
groupingResult
=
await
groupManager
.
generateClusters
(
tabs
embeddings
0
randFunc
preGroupedTabIndices
)
;
const
titleKey
=
"
title
"
;
const
centralClusterTitles
=
new
Set
(
groupingResult
.
getAnchorCluster
(
)
.
tabs
.
map
(
a
=
>
a
[
titleKey
]
)
)
;
groupingResult
.
getAnchorCluster
(
)
.
print
(
)
;
const
anchorTitleSet
=
new
Set
(
preGroupedTabIndices
.
map
(
a
=
>
tabs
[
a
]
[
titleKey
]
)
)
;
Assert
.
equal
(
centralClusterTitles
.
intersection
(
anchorTitleSet
)
.
size
anchorTitleSet
.
size
All
anchor
indices
in
target
cluster
)
;
const
scoreInfo
=
groupingResult
.
getAccuracyStatsForCluster
(
"
smart_group_label
"
groupingResult
.
getAnchorCluster
(
)
.
tabs
[
0
]
.
smart_group_label
)
;
allScores
.
push
(
scoreInfo
)
;
}
return
averageStatsValues
(
allScores
)
;
}
async
function
runAnchorTabTest
(
data
precomputedEmbeddings
=
null
anchorGroupIndices
anchorMethod
=
ANCHOR_METHODS
.
FIXED
silBoost
=
undefined
)
{
const
testParams
=
[
[
CLUSTER_METHODS
.
KMEANS
]
]
;
let
scoreInfo
;
for
(
let
testP
of
testParams
)
{
scoreInfo
=
await
testAugmentGroup
(
testP
[
0
]
testP
[
1
]
data
precomputedEmbeddings
1
anchorGroupIndices
anchorMethod
silBoost
)
;
}
if
(
testParams
.
length
=
=
=
1
)
{
return
scoreInfo
;
}
return
null
;
}
function
fetchFile
(
host_prefix
filename
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
xhr
=
new
XMLHttpRequest
(
)
;
const
url
=
{
host_prefix
}
{
filename
}
;
xhr
.
open
(
"
GET
"
url
true
)
;
xhr
.
onload
=
(
)
=
>
{
if
(
xhr
.
status
=
=
=
200
)
{
resolve
(
xhr
.
responseText
)
;
}
else
{
reject
(
new
Error
(
Failed
to
fetch
data
:
{
xhr
.
statusText
}
)
)
;
}
}
;
xhr
.
onerror
=
(
)
=
>
reject
(
new
Error
(
Network
error
getting
{
url
}
)
)
;
xhr
.
send
(
)
;
}
)
;
}
