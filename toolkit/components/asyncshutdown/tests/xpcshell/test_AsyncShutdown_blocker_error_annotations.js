"
use
strict
"
;
add_task
(
async
function
test_addBlockerFailureState
(
)
{
info
(
"
Testing
addBlocker
information
reported
to
crash
reporter
"
)
;
let
BLOCKER_NAME
=
"
test_addBlocker_state
blocker
"
+
Math
.
random
(
)
;
let
barrier
=
new
AsyncShutdown
.
Barrier
(
"
test_addBlocker_failure
"
)
;
let
deferred
=
PromiseUtils
.
defer
(
)
;
barrier
.
client
.
addBlocker
(
BLOCKER_NAME
function
(
)
{
return
deferred
.
promise
;
}
)
;
const
THROWING_BLOCKER_NAME
=
"
test_addBlocker_throws
blocker
"
;
Assert
.
throws
(
(
)
=
>
{
barrier
.
client
.
addBlocker
(
THROWING_BLOCKER_NAME
Promise
.
resolve
(
)
5
)
;
}
/
object
as
third
argument
/
)
;
let
promiseDone
=
barrier
.
wait
(
)
;
let
crashInfo
=
barrier
.
_gatherCrashReportTimeoutData
(
barrier
.
_name
barrier
.
state
)
;
Assert
.
deepEqual
(
crashInfo
.
conditions
barrier
.
state
"
Barrier
state
should
match
crash
info
.
"
)
;
Assert
.
equal
(
crashInfo
.
brokenAddBlockers
.
length
1
"
Should
have
registered
the
broken
addblocker
call
.
"
)
;
Assert
.
stringMatches
(
crashInfo
.
brokenAddBlockers
?
.
[
0
]
|
|
"
undefined
"
THROWING_BLOCKER_NAME
"
Throwing
call
'
s
blocker
name
should
be
listed
in
message
.
"
)
;
deferred
.
resolve
(
)
;
await
promiseDone
;
}
)
;
