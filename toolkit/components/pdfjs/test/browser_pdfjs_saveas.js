"
use
strict
"
;
const
RELATIVE_DIR
=
"
toolkit
/
components
/
pdfjs
/
test
/
"
;
const
TESTROOT
=
"
http
:
/
/
example
.
com
/
browser
/
"
+
RELATIVE_DIR
;
var
MockFilePicker
=
SpecialPowers
.
MockFilePicker
;
MockFilePicker
.
init
(
window
.
browsingContext
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
toolkit
/
content
/
tests
/
browser
/
common
/
mockTransfer
.
js
"
this
)
;
function
createPromiseForTransferComplete
(
expectedFileName
destFile
)
{
return
new
Promise
(
resolve
=
>
{
MockFilePicker
.
showCallback
=
fp
=
>
{
info
(
"
Filepicker
shown
checking
filename
"
)
;
is
(
fp
.
defaultString
expectedFileName
"
Filename
should
be
correct
.
"
)
;
let
fileName
=
fp
.
defaultString
;
destFile
.
append
(
fileName
)
;
MockFilePicker
.
setFiles
(
[
destFile
]
)
;
MockFilePicker
.
filterIndex
=
0
;
MockFilePicker
.
showCallback
=
null
;
mockTransferCallback
=
function
(
downloadSuccess
)
{
ok
(
downloadSuccess
"
File
should
have
been
downloaded
successfully
"
)
;
mockTransferCallback
=
(
)
=
>
{
}
;
resolve
(
)
;
}
;
}
;
}
)
;
}
let
tempDir
=
createTemporarySaveDirectory
(
)
;
add_setup
(
async
function
(
)
{
mockTransferRegisterer
.
register
(
)
;
registerCleanupFunction
(
function
(
)
{
mockTransferRegisterer
.
unregister
(
)
;
MockFilePicker
.
cleanup
(
)
;
tempDir
.
remove
(
true
)
;
}
)
;
}
)
;
add_task
(
async
function
test_pdf_saveas
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
"
about
:
blank
"
}
async
function
(
browser
)
{
await
waitForPdfJS
(
browser
TESTROOT
+
"
file_pdfjs_test
.
pdf
"
)
;
let
destFile
=
tempDir
.
clone
(
)
;
MockFilePicker
.
displayDirectory
=
tempDir
;
let
fileSavedPromise
=
createPromiseForTransferComplete
(
"
file_pdfjs_test
.
pdf
"
destFile
)
;
saveBrowser
(
browser
)
;
await
fileSavedPromise
;
await
waitForPdfJSClose
(
browser
)
;
}
)
;
}
)
;
add_task
(
async
function
test_pdf_saveas_forms
(
)
{
let
destFile
=
tempDir
.
clone
(
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
"
about
:
blank
"
}
async
function
(
browser
)
{
await
waitForPdfJSAnnotationLayer
(
browser
TESTROOT
+
"
file_pdfjs_form
.
pdf
"
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
let
formInput
=
content
.
document
.
querySelector
(
"
#
viewerContainer
input
"
)
;
ok
(
formInput
"
PDF
contains
text
field
.
"
)
;
is
(
formInput
.
value
"
"
"
Text
field
is
empty
to
start
.
"
)
;
formInput
.
value
=
"
test
"
;
formInput
.
dispatchEvent
(
new
content
.
window
.
Event
(
"
input
"
)
)
;
}
)
;
MockFilePicker
.
displayDirectory
=
tempDir
;
let
fileSavedPromise
=
createPromiseForTransferComplete
(
"
file_pdfjs_form
.
pdf
"
destFile
)
;
saveBrowser
(
browser
)
;
await
fileSavedPromise
;
await
waitForPdfJSClose
(
browser
)
;
}
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
"
about
:
blank
"
}
async
function
(
browser
)
{
await
waitForPdfJSAnnotationLayer
(
browser
NetUtil
.
newURI
(
destFile
)
.
spec
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
let
formInput
=
content
.
document
.
querySelector
(
"
#
viewerContainer
input
"
)
;
ok
(
formInput
"
PDF
contains
text
field
.
"
)
;
is
(
formInput
.
value
"
test
"
"
Text
field
is
filled
in
.
"
)
;
}
)
;
await
waitForPdfJSClose
(
browser
)
;
}
)
;
}
)
;
add_task
(
async
function
test_pdf_saveas_customname
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
helperApps
.
showOpenOptionForPdfJS
"
true
]
[
"
browser
.
helperApps
.
showOpenOptionForViewableInternally
"
true
]
[
"
browser
.
download
.
always_ask_before_handling_new_types
"
false
]
[
"
browser
.
download
.
open_pdf_attachments_inline
"
true
]
]
}
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
TESTROOT
+
"
file_pdf_download_link
.
html
"
}
async
function
(
browser
)
{
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
custom_filename
"
{
}
browser
)
;
let
tab
=
await
BrowserTestUtils
.
waitForNewTab
(
gBrowser
)
;
info
(
"
tab
created
"
)
;
await
BrowserTestUtils
.
waitForContentEvent
(
tab
.
linkedBrowser
"
metadataloaded
"
false
null
true
)
;
info
(
"
metadata
loaded
"
)
;
let
destFile
=
tempDir
.
clone
(
)
;
MockFilePicker
.
displayDirectory
=
tempDir
;
let
fileSavedPromise
=
createPromiseForTransferComplete
(
"
custom_filename
.
pdf
"
destFile
)
;
saveBrowser
(
tab
.
linkedBrowser
)
;
await
fileSavedPromise
;
await
waitForPdfJSClose
(
tab
.
linkedBrowser
true
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
"
about
:
blank
"
}
async
function
(
browser
)
{
const
downloadLastDir
=
new
DownloadLastDir
(
null
)
;
const
destDirs
=
[
]
;
for
(
let
i
=
1
;
i
<
=
2
;
i
+
+
)
{
const
destDir
=
createTemporarySaveDirectory
(
i
)
;
destDirs
.
push
(
destDir
)
;
const
url
=
http
:
/
/
test
{
i
}
.
example
.
com
/
browser
/
{
RELATIVE_DIR
}
file_pdfjs_test
.
pdf
;
downloadLastDir
.
setFile
(
url
destDir
)
;
await
TestUtils
.
waitForTick
(
)
;
}
const
url
=
http
:
/
/
test1
.
example
.
com
/
browser
/
{
RELATIVE_DIR
}
file_pdfjs_hcm
.
pdf
;
await
waitForPdfJS
(
browser
url
)
;
const
fileSavedPromise
=
new
Promise
(
resolve
=
>
{
MockFilePicker
.
showCallback
=
fp
=
>
{
MockFilePicker
.
setFiles
(
[
]
)
;
MockFilePicker
.
showCallback
=
null
;
resolve
(
fp
.
displayDirectory
.
path
)
;
}
;
}
)
;
registerCleanupFunction
(
(
)
=
>
{
for
(
const
destDir
of
destDirs
)
{
destDir
.
remove
(
true
)
;
}
}
)
;
saveBrowser
(
browser
)
;
const
dirPath
=
await
fileSavedPromise
;
is
(
dirPath
destDirs
[
0
]
.
path
"
Proposed
directory
must
be
based
on
the
domain
"
)
;
await
waitForPdfJSClose
(
browser
)
;
}
)
;
}
)
;
