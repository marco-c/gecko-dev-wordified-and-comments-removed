"
use
strict
"
;
const
RELATIVE_DIR
=
"
toolkit
/
components
/
pdfjs
/
test
/
"
;
const
TESTROOT
=
"
http
:
/
/
example
.
com
/
browser
/
"
+
RELATIVE_DIR
;
var
MockFilePicker
=
SpecialPowers
.
MockFilePicker
;
MockFilePicker
.
init
(
window
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
toolkit
/
content
/
tests
/
browser
/
common
/
mockTransfer
.
js
"
this
)
;
function
createTemporarySaveDirectory
(
)
{
var
saveDir
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
saveDir
.
append
(
"
testsavedir
"
)
;
if
(
!
saveDir
.
exists
(
)
)
{
saveDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
return
saveDir
;
}
function
createPromiseForTransferComplete
(
expectedFileName
destFile
)
{
return
new
Promise
(
resolve
=
>
{
MockFilePicker
.
showCallback
=
fp
=
>
{
info
(
"
Filepicker
shown
checking
filename
"
)
;
is
(
fp
.
defaultString
expectedFileName
"
Filename
should
be
correct
.
"
)
;
let
fileName
=
fp
.
defaultString
;
destFile
.
append
(
fileName
)
;
MockFilePicker
.
setFiles
(
[
destFile
]
)
;
MockFilePicker
.
filterIndex
=
0
;
MockFilePicker
.
showCallback
=
null
;
mockTransferCallback
=
function
(
downloadSuccess
)
{
ok
(
downloadSuccess
"
File
should
have
been
downloaded
successfully
"
)
;
mockTransferCallback
=
(
)
=
>
{
}
;
resolve
(
)
;
}
;
}
;
}
)
;
}
let
tempDir
=
createTemporarySaveDirectory
(
)
;
add_task
(
async
function
setup
(
)
{
mockTransferRegisterer
.
register
(
)
;
registerCleanupFunction
(
function
(
)
{
mockTransferRegisterer
.
unregister
(
)
;
MockFilePicker
.
cleanup
(
)
;
tempDir
.
remove
(
true
)
;
}
)
;
}
)
;
add_task
(
async
function
test_pdf_saveas
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
"
about
:
blank
"
}
async
function
(
browser
)
{
await
waitForPdfJS
(
browser
TESTROOT
+
"
file_pdfjs_test
.
pdf
"
)
;
let
destFile
=
tempDir
.
clone
(
)
;
MockFilePicker
.
displayDirectory
=
tempDir
;
let
fileSavedPromise
=
createPromiseForTransferComplete
(
"
file_pdfjs_test
.
pdf
"
destFile
)
;
saveBrowser
(
browser
)
;
await
fileSavedPromise
;
}
)
;
}
)
;
add_task
(
async
function
test_pdf_saveas_forms
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
pdfjs
.
renderInteractiveForms
"
true
]
]
}
)
;
let
destFile
=
tempDir
.
clone
(
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
"
about
:
blank
"
}
async
function
(
browser
)
{
await
waitForPdfJSAnnotationLayer
(
browser
TESTROOT
+
"
file_pdfjs_form
.
pdf
"
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
let
formInput
=
content
.
document
.
querySelector
(
"
#
viewerContainer
input
"
)
;
ok
(
formInput
"
PDF
contains
text
field
.
"
)
;
is
(
formInput
.
value
"
"
"
Text
field
is
empty
to
start
.
"
)
;
formInput
.
value
=
"
test
"
;
formInput
.
dispatchEvent
(
new
content
.
window
.
Event
(
"
input
"
)
)
;
}
)
;
MockFilePicker
.
displayDirectory
=
tempDir
;
let
fileSavedPromise
=
createPromiseForTransferComplete
(
"
file_pdfjs_form
.
pdf
"
destFile
)
;
saveBrowser
(
browser
)
;
await
fileSavedPromise
;
}
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
"
about
:
blank
"
}
async
function
(
browser
)
{
await
waitForPdfJSAnnotationLayer
(
browser
NetUtil
.
newURI
(
destFile
)
.
spec
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
let
formInput
=
content
.
document
.
querySelector
(
"
#
viewerContainer
input
"
)
;
ok
(
formInput
"
PDF
contains
text
field
.
"
)
;
is
(
formInput
.
value
"
test
"
"
Text
field
is
filled
in
.
"
)
;
}
)
;
}
)
;
}
)
;
