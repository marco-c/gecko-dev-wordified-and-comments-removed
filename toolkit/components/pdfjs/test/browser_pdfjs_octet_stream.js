"
use
strict
"
;
const
TESTROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
mochi
.
test
:
8888
/
"
)
;
const
PDF_URL
=
TESTROOT
+
"
file_pdfjs_object_stream
.
pdf
"
;
var
gMIMEService
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
;
add_task
(
async
function
test_octet_stream_opens_pdfjs
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
pdfjs
.
handleOctetStream
"
true
]
]
}
)
;
let
handlerInfo
=
gMIMEService
.
getFromTypeAndExtension
(
"
application
/
pdf
"
"
pdf
"
)
;
is
(
handlerInfo
.
alwaysAskBeforeHandling
false
"
pdf
handler
defaults
to
always
-
ask
is
false
"
)
;
is
(
handlerInfo
.
preferredAction
Ci
.
nsIHandlerInfo
.
handleInternally
"
pdf
handler
defaults
to
internal
"
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
"
about
:
blank
"
}
async
function
(
newTabBrowser
)
{
await
waitForPdfJS
(
newTabBrowser
PDF_URL
)
;
is
(
newTabBrowser
.
currentURI
.
spec
PDF_URL
"
Should
load
pdfjs
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_octet_stream_in_frame_downloads
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
pdfjs
.
handleOctetStream
"
true
]
[
"
browser
.
download
.
improvements_to_download_panel
"
false
]
]
}
)
;
let
handlerInfo
=
gMIMEService
.
getFromTypeAndExtension
(
"
application
/
pdf
"
"
pdf
"
)
;
is
(
handlerInfo
.
alwaysAskBeforeHandling
false
"
pdf
handler
defaults
to
always
-
ask
is
false
"
)
;
is
(
handlerInfo
.
preferredAction
Ci
.
nsIHandlerInfo
.
handleInternally
"
pdf
handler
defaults
to
internal
"
)
;
let
dialogPromise
=
BrowserTestUtils
.
domWindowOpenedAndLoaded
(
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
data
:
text
/
html
<
iframe
src
=
'
{
PDF_URL
}
'
>
}
async
function
(
newTabBrowser
)
{
let
dialogWin
=
await
dialogPromise
;
ok
(
dialogWin
"
Should
have
a
dialog
asking
what
to
do
.
"
)
;
dialogWin
.
close
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_octet_stream_in_frame_downloads_improvements_to_download_panel
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
pdfjs
.
handleOctetStream
"
true
]
[
"
browser
.
download
.
improvements_to_download_panel
"
true
]
]
}
)
;
let
handlerInfo
=
gMIMEService
.
getFromTypeAndExtension
(
"
application
/
pdf
"
"
pdf
"
)
;
is
(
handlerInfo
.
alwaysAskBeforeHandling
false
"
pdf
handler
defaults
to
always
-
ask
is
false
"
)
;
is
(
handlerInfo
.
preferredAction
Ci
.
nsIHandlerInfo
.
handleInternally
"
pdf
handler
defaults
to
internal
"
)
;
let
downloadsPanelPromise
=
BrowserTestUtils
.
waitForEvent
(
DownloadsPanel
.
panel
"
popupshown
"
)
;
let
previewTabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
url
=
>
{
let
uri
=
NetUtil
.
newURI
(
url
)
;
return
uri
.
scheme
=
=
"
file
"
&
&
uri
.
spec
.
endsWith
(
"
.
pdf
"
)
;
}
false
true
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
data
:
text
/
html
<
iframe
src
=
'
{
PDF_URL
}
'
>
}
async
function
(
newTabBrowser
)
{
info
(
"
Waiting
for
download
panel
to
open
"
)
;
await
downloadsPanelPromise
;
is
(
DownloadsPanel
.
panel
.
state
"
open
"
"
Check
the
download
panel
state
is
'
open
'
"
)
;
let
downloadList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
[
download
]
=
downloadList
.
_downloads
;
info
(
"
Waiting
for
preview
tab
"
)
;
let
previewTab
=
await
previewTabPromise
;
ok
(
previewTab
"
PDF
opened
in
a
new
tab
"
)
;
is
(
DownloadsPanel
.
isPanelShowing
true
"
DownloadsPanel
should
be
open
.
"
)
;
is
(
downloadList
.
_downloads
.
length
1
"
File
should
be
successfully
downloaded
.
"
)
;
await
BrowserTestUtils
.
removeTab
(
previewTab
)
;
info
(
"
cleaning
up
downloads
"
)
;
try
{
if
(
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
)
{
await
IOUtils
.
setPermissions
(
download
.
target
.
path
0o600
)
;
}
await
IOUtils
.
remove
(
download
.
target
.
path
)
;
}
catch
(
error
)
{
info
(
"
The
file
"
+
download
.
target
.
path
+
"
is
not
removed
"
+
error
)
;
}
await
downloadList
.
remove
(
download
)
;
await
download
.
finalize
(
)
;
if
(
DownloadsPanel
.
panel
.
state
!
=
=
"
closed
"
)
{
let
hiddenPromise
=
BrowserTestUtils
.
waitForEvent
(
DownloadsPanel
.
panel
"
popuphidden
"
)
;
DownloadsPanel
.
hidePanel
(
)
;
await
hiddenPromise
;
}
is
(
DownloadsPanel
.
panel
.
state
"
closed
"
"
Check
that
the
download
panel
is
closed
"
)
;
}
)
;
}
)
;
