"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PdfStreamConverter
"
]
;
const
PDFJS_EVENT_ID
=
"
pdf
.
js
.
message
"
;
const
PREF_PREFIX
=
"
pdfjs
"
;
const
PDF_VIEWER_ORIGIN
=
"
resource
:
/
/
pdf
.
js
"
;
const
PDF_VIEWER_WEB_PAGE
=
"
resource
:
/
/
pdf
.
js
/
web
/
viewer
.
html
"
;
const
MAX_NUMBER_OF_PREFS
=
50
;
const
MAX_STRING_PREF_LENGTH
=
128
;
const
PDF_CONTENT_TYPE
=
"
application
/
pdf
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
AsyncPrefs
"
"
resource
:
/
/
gre
/
modules
/
AsyncPrefs
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
NetworkManager
"
"
resource
:
/
/
pdf
.
js
/
PdfJsNetwork
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PdfJsTelemetry
"
"
resource
:
/
/
pdf
.
js
/
PdfJsTelemetry
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PdfJs
"
"
resource
:
/
/
pdf
.
js
/
PdfJs
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PdfSandbox
"
"
resource
:
/
/
pdf
.
js
/
PdfSandbox
.
jsm
"
)
;
var
Svc
=
{
}
;
XPCOMUtils
.
defineLazyServiceGetter
(
Svc
"
mime
"
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
Svc
"
handlers
"
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
"
nsIHandlerService
"
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gOurBinary
"
(
)
=
>
{
let
file
=
Services
.
dirsvc
.
get
(
"
XREExeF
"
Ci
.
nsIFile
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
while
(
file
)
{
if
(
/
\
.
app
\
/
?
/
i
.
test
(
file
.
leafName
)
)
{
break
;
}
file
=
file
.
parent
;
}
}
return
file
;
}
)
;
function
getBoolPref
(
pref
def
)
{
try
{
return
Services
.
prefs
.
getBoolPref
(
pref
)
;
}
catch
(
ex
)
{
return
def
;
}
}
function
getIntPref
(
pref
def
)
{
try
{
return
Services
.
prefs
.
getIntPref
(
pref
)
;
}
catch
(
ex
)
{
return
def
;
}
}
function
getStringPref
(
pref
def
)
{
try
{
return
Services
.
prefs
.
getStringPref
(
pref
)
;
}
catch
(
ex
)
{
return
def
;
}
}
function
log
(
aMsg
)
{
if
(
!
getBoolPref
(
PREF_PREFIX
+
"
.
pdfBugEnabled
"
false
)
)
{
return
;
}
var
msg
=
"
PdfStreamConverter
.
js
:
"
+
(
aMsg
.
join
?
aMsg
.
join
(
"
"
)
:
aMsg
)
;
Services
.
console
.
logStringMessage
(
msg
)
;
dump
(
msg
+
"
\
n
"
)
;
}
function
getDOMWindow
(
aChannel
aPrincipal
)
{
var
requestor
=
aChannel
.
notificationCallbacks
?
aChannel
.
notificationCallbacks
:
aChannel
.
loadGroup
.
notificationCallbacks
;
var
win
=
requestor
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
if
(
!
win
.
document
.
nodePrincipal
.
equals
(
aPrincipal
)
)
{
return
null
;
}
return
win
;
}
function
getActor
(
window
)
{
try
{
return
window
.
windowGlobalChild
.
getActor
(
"
Pdfjs
"
)
;
}
catch
(
ex
)
{
return
null
;
}
}
function
getLocalizedStrings
(
path
)
{
var
stringBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
pdf
.
js
/
locale
/
"
+
path
)
;
var
map
=
{
}
;
for
(
let
string
of
stringBundle
.
getSimpleEnumeration
(
)
)
{
var
key
=
string
.
key
property
=
"
textContent
"
;
var
i
=
key
.
lastIndexOf
(
"
.
"
)
;
if
(
i
>
=
0
)
{
property
=
key
.
substring
(
i
+
1
)
;
key
=
key
.
substring
(
0
i
)
;
}
if
(
!
(
key
in
map
)
)
{
map
[
key
]
=
{
}
;
}
map
[
key
]
[
property
]
=
string
.
value
;
}
return
map
;
}
function
isValidMatchesCount
(
data
)
{
if
(
typeof
data
!
=
=
"
object
"
|
|
data
=
=
=
null
)
{
return
false
;
}
const
{
current
total
}
=
data
;
if
(
typeof
total
!
=
=
"
number
"
|
|
total
<
0
|
|
typeof
current
!
=
=
"
number
"
|
|
current
<
0
|
|
current
>
total
)
{
return
false
;
}
return
true
;
}
function
PdfDataListener
(
length
)
{
this
.
length
=
length
;
this
.
buffers
=
[
]
;
this
.
loaded
=
0
;
}
PdfDataListener
.
prototype
=
{
append
:
function
PdfDataListener_append
(
chunk
)
{
this
.
buffers
.
push
(
chunk
)
;
this
.
loaded
+
=
chunk
.
length
;
if
(
this
.
length
>
=
0
&
&
this
.
length
<
this
.
loaded
)
{
this
.
length
=
-
1
;
}
this
.
onprogress
(
this
.
loaded
this
.
length
>
=
0
?
this
.
length
:
void
0
)
;
}
readData
:
function
PdfDataListener_readData
(
)
{
if
(
this
.
buffers
.
length
=
=
=
0
)
{
return
null
;
}
if
(
this
.
buffers
.
length
=
=
=
1
)
{
return
this
.
buffers
.
pop
(
)
;
}
let
combinedLength
=
0
;
for
(
let
buffer
of
this
.
buffers
)
{
combinedLength
+
=
buffer
.
length
;
}
let
combinedArray
=
new
Uint8Array
(
combinedLength
)
;
let
writeOffset
=
0
;
while
(
this
.
buffers
.
length
)
{
let
buffer
=
this
.
buffers
.
shift
(
)
;
combinedArray
.
set
(
buffer
writeOffset
)
;
writeOffset
+
=
buffer
.
length
;
}
return
combinedArray
;
}
get
isDone
(
)
{
return
!
!
this
.
isDataReady
;
}
finish
:
function
PdfDataListener_finish
(
)
{
this
.
isDataReady
=
true
;
if
(
this
.
oncompleteCallback
)
{
this
.
oncompleteCallback
(
this
.
readData
(
)
)
;
}
}
error
:
function
PdfDataListener_error
(
errorCode
)
{
this
.
errorCode
=
errorCode
;
if
(
this
.
oncompleteCallback
)
{
this
.
oncompleteCallback
(
null
errorCode
)
;
}
}
onprogress
(
)
{
}
get
oncomplete
(
)
{
return
this
.
oncompleteCallback
;
}
set
oncomplete
(
value
)
{
this
.
oncompleteCallback
=
value
;
if
(
this
.
isDataReady
)
{
value
(
this
.
readData
(
)
)
;
}
if
(
this
.
errorCode
)
{
value
(
null
this
.
errorCode
)
;
}
}
}
;
class
ChromeActions
{
constructor
(
domWindow
contentDispositionFilename
)
{
this
.
domWindow
=
domWindow
;
this
.
contentDispositionFilename
=
contentDispositionFilename
;
this
.
telemetryState
=
{
documentInfo
:
false
firstPageInfo
:
false
streamTypesUsed
:
{
}
fontTypesUsed
:
{
}
fallbackErrorsReported
:
{
}
}
;
this
.
sandbox
=
null
;
this
.
unloadListener
=
null
;
}
createSandbox
(
data
sendResponse
)
{
function
sendResp
(
res
)
{
if
(
sendResponse
)
{
sendResponse
(
res
)
;
}
return
res
;
}
if
(
!
getBoolPref
(
PREF_PREFIX
+
"
.
enableScripting
"
false
)
)
{
return
sendResp
(
false
)
;
}
if
(
this
.
sandbox
!
=
=
null
)
{
return
sendResp
(
true
)
;
}
try
{
this
.
sandbox
=
new
lazy
.
PdfSandbox
(
this
.
domWindow
data
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
return
sendResp
(
false
)
;
}
this
.
unloadListener
=
(
)
=
>
{
this
.
destroySandbox
(
)
;
}
;
this
.
domWindow
.
addEventListener
(
"
unload
"
this
.
unloadListener
)
;
return
sendResp
(
true
)
;
}
dispatchEventInSandbox
(
event
)
{
if
(
this
.
sandbox
)
{
this
.
sandbox
.
dispatchEvent
(
event
)
;
}
}
dispatchAsyncEventInSandbox
(
event
sendResponse
)
{
this
.
dispatchEventInSandbox
(
event
)
;
sendResponse
(
)
;
}
destroySandbox
(
)
{
if
(
this
.
sandbox
)
{
this
.
domWindow
.
removeEventListener
(
"
unload
"
this
.
unloadListener
)
;
this
.
sandbox
.
destroy
(
)
;
this
.
sandbox
=
null
;
}
}
isInPrivateBrowsing
(
)
{
return
lazy
.
PrivateBrowsingUtils
.
isContentWindowPrivate
(
this
.
domWindow
)
;
}
getWindowOriginAttributes
(
)
{
try
{
return
this
.
domWindow
.
document
.
nodePrincipal
.
originAttributes
;
}
catch
(
err
)
{
return
{
}
;
}
}
download
(
data
sendResponse
)
{
var
originalUrl
=
data
.
originalUrl
;
var
blobUrl
=
data
.
blobUrl
|
|
originalUrl
;
var
filename
=
data
.
filename
;
if
(
typeof
filename
!
=
=
"
string
"
|
|
(
!
/
\
.
pdf
/
i
.
test
(
filename
)
&
&
!
data
.
isAttachment
)
)
{
filename
=
"
document
.
pdf
"
;
}
let
actor
=
getActor
(
this
.
domWindow
)
;
actor
.
sendAsyncMessage
(
"
PDFJS
:
Parent
:
saveURL
"
{
blobUrl
originalUrl
filename
}
)
;
}
getLocale
(
)
{
return
Services
.
locale
.
requestedLocale
|
|
"
en
-
US
"
;
}
getStrings
(
)
{
try
{
this
.
localizedStrings
|
|
=
getLocalizedStrings
(
"
viewer
.
properties
"
)
;
return
this
.
localizedStrings
;
}
catch
(
e
)
{
log
(
"
Unable
to
retrieve
localized
strings
:
"
+
e
)
;
return
null
;
}
}
supportsIntegratedFind
(
)
{
return
this
.
domWindow
.
windowGlobalChild
.
browsingContext
.
parent
=
=
=
null
;
}
supportsDocumentFonts
(
)
{
var
prefBrowser
=
getIntPref
(
"
browser
.
display
.
use_document_fonts
"
1
)
;
var
prefGfx
=
getBoolPref
(
"
gfx
.
downloadable_fonts
.
enabled
"
true
)
;
return
!
!
prefBrowser
&
&
prefGfx
;
}
supportedMouseWheelZoomModifierKeys
(
)
{
return
{
ctrlKey
:
getIntPref
(
"
mousewheel
.
with_control
.
action
"
3
)
=
=
=
3
metaKey
:
getIntPref
(
"
mousewheel
.
with_meta
.
action
"
1
)
=
=
=
3
}
;
}
isInAutomation
(
)
{
return
Cu
.
isInAutomation
;
}
reportTelemetry
(
data
)
{
var
probeInfo
=
JSON
.
parse
(
data
)
;
switch
(
probeInfo
.
type
)
{
case
"
documentInfo
"
:
if
(
!
this
.
telemetryState
.
documentInfo
)
{
lazy
.
PdfJsTelemetry
.
onDocumentVersion
(
probeInfo
.
version
)
;
lazy
.
PdfJsTelemetry
.
onDocumentGenerator
(
probeInfo
.
generator
)
;
if
(
probeInfo
.
formType
)
{
lazy
.
PdfJsTelemetry
.
onForm
(
probeInfo
.
formType
)
;
}
this
.
telemetryState
.
documentInfo
=
true
;
}
break
;
case
"
pageInfo
"
:
if
(
!
this
.
telemetryState
.
firstPageInfo
)
{
lazy
.
PdfJsTelemetry
.
onTimeToView
(
probeInfo
.
timestamp
)
;
this
.
telemetryState
.
firstPageInfo
=
true
;
}
break
;
case
"
documentStats
"
:
var
documentStats
=
probeInfo
.
stats
;
if
(
!
documentStats
|
|
typeof
documentStats
!
=
=
"
object
"
)
{
break
;
}
var
i
streamTypes
=
documentStats
.
streamTypes
key
;
var
STREAM_TYPE_ID_LIMIT
=
20
;
i
=
0
;
for
(
key
in
streamTypes
)
{
if
(
+
+
i
>
STREAM_TYPE_ID_LIMIT
)
{
break
;
}
if
(
!
this
.
telemetryState
.
streamTypesUsed
[
key
]
)
{
lazy
.
PdfJsTelemetry
.
onStreamType
(
key
)
;
this
.
telemetryState
.
streamTypesUsed
[
key
]
=
true
;
}
}
var
fontTypes
=
documentStats
.
fontTypes
;
var
FONT_TYPE_ID_LIMIT
=
20
;
i
=
0
;
for
(
key
in
fontTypes
)
{
if
(
+
+
i
>
FONT_TYPE_ID_LIMIT
)
{
break
;
}
if
(
!
this
.
telemetryState
.
fontTypesUsed
[
key
]
)
{
lazy
.
PdfJsTelemetry
.
onFontType
(
key
)
;
this
.
telemetryState
.
fontTypesUsed
[
key
]
=
true
;
}
}
break
;
case
"
print
"
:
lazy
.
PdfJsTelemetry
.
onPrint
(
)
;
break
;
case
"
unsupportedFeature
"
:
if
(
!
this
.
telemetryState
.
fallbackErrorsReported
[
probeInfo
.
featureId
]
)
{
lazy
.
PdfJsTelemetry
.
onFallbackError
(
probeInfo
.
featureId
)
;
this
.
telemetryState
.
fallbackErrorsReported
[
probeInfo
.
featureId
]
=
true
;
}
break
;
case
"
tagged
"
:
lazy
.
PdfJsTelemetry
.
onTagged
(
probeInfo
.
tagged
)
;
break
;
}
}
fallback
(
args
sendResponse
)
{
sendResponse
(
false
)
;
}
updateFindControlState
(
data
)
{
if
(
!
this
.
supportsIntegratedFind
(
)
)
{
return
;
}
var
result
=
data
.
result
;
var
findPrevious
=
data
.
findPrevious
;
var
findPreviousType
=
typeof
findPrevious
;
if
(
typeof
result
!
=
=
"
number
"
|
|
result
<
0
|
|
result
>
3
|
|
(
findPreviousType
!
=
=
"
undefined
"
&
&
findPreviousType
!
=
=
"
boolean
"
)
)
{
return
;
}
let
matchesCount
=
null
;
if
(
isValidMatchesCount
(
data
.
matchesCount
)
)
{
matchesCount
=
data
.
matchesCount
;
}
let
rawQuery
=
null
;
if
(
typeof
data
.
rawQuery
=
=
=
"
string
"
)
{
rawQuery
=
data
.
rawQuery
;
}
let
actor
=
getActor
(
this
.
domWindow
)
;
actor
?
.
sendAsyncMessage
(
"
PDFJS
:
Parent
:
updateControlState
"
{
result
findPrevious
matchesCount
rawQuery
}
)
;
}
updateFindMatchesCount
(
data
)
{
if
(
!
this
.
supportsIntegratedFind
(
)
)
{
return
;
}
if
(
!
isValidMatchesCount
(
data
)
)
{
return
;
}
let
actor
=
getActor
(
this
.
domWindow
)
;
actor
?
.
sendAsyncMessage
(
"
PDFJS
:
Parent
:
updateMatchesCount
"
data
)
;
}
setPreferences
(
prefs
sendResponse
)
{
var
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
PREF_PREFIX
+
"
.
"
)
;
var
numberOfPrefs
=
0
;
var
prefValue
prefName
;
for
(
var
key
in
prefs
)
{
if
(
+
+
numberOfPrefs
>
MAX_NUMBER_OF_PREFS
)
{
log
(
"
setPreferences
-
Exceeded
the
maximum
number
of
preferences
"
+
"
that
is
allowed
to
be
set
at
once
.
"
)
;
break
;
}
else
if
(
!
defaultBranch
.
getPrefType
(
key
)
)
{
continue
;
}
prefValue
=
prefs
[
key
]
;
prefName
=
PREF_PREFIX
+
"
.
"
+
key
;
switch
(
typeof
prefValue
)
{
case
"
boolean
"
:
lazy
.
AsyncPrefs
.
set
(
prefName
prefValue
)
;
break
;
case
"
number
"
:
lazy
.
AsyncPrefs
.
set
(
prefName
prefValue
)
;
break
;
case
"
string
"
:
if
(
prefValue
.
length
>
MAX_STRING_PREF_LENGTH
)
{
log
(
"
setPreferences
-
Exceeded
the
maximum
allowed
length
"
+
"
for
a
string
preference
.
"
)
;
}
else
{
lazy
.
AsyncPrefs
.
set
(
prefName
prefValue
)
;
}
break
;
}
}
if
(
sendResponse
)
{
sendResponse
(
true
)
;
}
}
getPreferences
(
prefs
sendResponse
)
{
var
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
PREF_PREFIX
+
"
.
"
)
;
var
currentPrefs
=
{
}
numberOfPrefs
=
0
;
var
prefValue
prefName
;
for
(
var
key
in
prefs
)
{
if
(
+
+
numberOfPrefs
>
MAX_NUMBER_OF_PREFS
)
{
log
(
"
getPreferences
-
Exceeded
the
maximum
number
of
preferences
"
+
"
that
is
allowed
to
be
fetched
at
once
.
"
)
;
break
;
}
else
if
(
!
defaultBranch
.
getPrefType
(
key
)
)
{
continue
;
}
prefValue
=
prefs
[
key
]
;
prefName
=
PREF_PREFIX
+
"
.
"
+
key
;
switch
(
typeof
prefValue
)
{
case
"
boolean
"
:
currentPrefs
[
key
]
=
getBoolPref
(
prefName
prefValue
)
;
break
;
case
"
number
"
:
currentPrefs
[
key
]
=
getIntPref
(
prefName
prefValue
)
;
break
;
case
"
string
"
:
currentPrefs
[
key
]
=
getStringPref
(
prefName
prefValue
)
;
break
;
}
}
let
result
=
JSON
.
stringify
(
currentPrefs
)
;
if
(
sendResponse
)
{
sendResponse
(
result
)
;
}
return
result
;
}
updateEditorStates
(
{
details
}
)
{
const
doc
=
this
.
domWindow
.
document
;
if
(
!
doc
.
editorStates
)
{
doc
.
editorStates
=
{
isEditing
:
false
isEmpty
:
true
hasEmptyClipboard
:
true
hasSomethingToUndo
:
false
hasSomethingToRedo
:
false
hasSelectedEditor
:
false
}
;
}
const
{
editorStates
}
=
doc
;
for
(
const
[
key
value
]
of
Object
.
entries
(
details
)
)
{
if
(
typeof
value
=
=
=
"
boolean
"
&
&
key
in
editorStates
)
{
editorStates
[
key
]
=
value
;
}
}
}
}
class
RangedChromeActions
extends
ChromeActions
{
constructor
(
domWindow
contentDispositionFilename
originalRequest
rangeEnabled
streamingEnabled
dataListener
)
{
super
(
domWindow
contentDispositionFilename
)
;
this
.
dataListener
=
dataListener
;
this
.
originalRequest
=
originalRequest
;
this
.
rangeEnabled
=
rangeEnabled
;
this
.
streamingEnabled
=
streamingEnabled
;
this
.
pdfUrl
=
originalRequest
.
URI
.
spec
;
this
.
contentLength
=
originalRequest
.
contentLength
;
var
httpHeaderVisitor
=
{
headers
:
{
}
visitHeader
(
aHeader
aValue
)
{
if
(
aHeader
=
=
=
"
Range
"
)
{
return
;
}
this
.
headers
[
aHeader
]
=
aValue
;
}
}
;
if
(
originalRequest
.
visitRequestHeaders
)
{
originalRequest
.
visitRequestHeaders
(
httpHeaderVisitor
)
;
}
var
self
=
this
;
var
xhr_onreadystatechange
=
function
xhr_onreadystatechange
(
)
{
if
(
this
.
readyState
=
=
=
1
)
{
var
netChannel
=
this
.
channel
;
this
.
setOriginAttributes
(
self
.
getWindowOriginAttributes
(
)
)
;
if
(
"
nsIPrivateBrowsingChannel
"
in
Ci
&
&
netChannel
instanceof
Ci
.
nsIPrivateBrowsingChannel
)
{
var
docIsPrivate
=
self
.
isInPrivateBrowsing
(
)
;
netChannel
.
setPrivate
(
docIsPrivate
)
;
}
}
}
;
var
getXhr
=
function
getXhr
(
)
{
var
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
addEventListener
(
"
readystatechange
"
xhr_onreadystatechange
)
;
return
xhr
;
}
;
this
.
networkManager
=
new
lazy
.
NetworkManager
(
this
.
pdfUrl
{
httpHeaders
:
httpHeaderVisitor
.
headers
getXhr
}
)
;
domWindow
.
addEventListener
(
"
unload
"
function
unload
(
e
)
{
domWindow
.
removeEventListener
(
e
.
type
unload
)
;
self
.
abortLoading
(
)
;
}
)
;
}
initPassiveLoading
(
)
{
let
data
done
;
if
(
!
this
.
streamingEnabled
)
{
this
.
originalRequest
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
this
.
originalRequest
=
null
;
data
=
this
.
dataListener
.
readData
(
)
;
done
=
this
.
dataListener
.
isDone
;
this
.
dataListener
=
null
;
}
else
{
data
=
this
.
dataListener
.
readData
(
)
;
done
=
this
.
dataListener
.
isDone
;
this
.
dataListener
.
onprogress
=
(
loaded
total
)
=
>
{
this
.
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
progressiveRead
"
loaded
total
chunk
:
this
.
dataListener
.
readData
(
)
}
PDF_VIEWER_ORIGIN
)
;
}
;
this
.
dataListener
.
oncomplete
=
(
)
=
>
{
if
(
!
done
&
&
this
.
dataListener
.
isDone
)
{
this
.
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
progressiveDone
"
}
PDF_VIEWER_ORIGIN
)
;
}
this
.
dataListener
=
null
;
}
;
}
this
.
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
supportsRangedLoading
"
rangeEnabled
:
this
.
rangeEnabled
streamingEnabled
:
this
.
streamingEnabled
pdfUrl
:
this
.
pdfUrl
length
:
this
.
contentLength
data
done
filename
:
this
.
contentDispositionFilename
}
PDF_VIEWER_ORIGIN
)
;
return
true
;
}
requestDataRange
(
args
)
{
if
(
!
this
.
rangeEnabled
)
{
return
;
}
var
begin
=
args
.
begin
;
var
end
=
args
.
end
;
var
domWindow
=
this
.
domWindow
;
this
.
networkManager
.
requestRange
(
begin
end
{
onDone
:
function
RangedChromeActions_onDone
(
aArgs
)
{
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
range
"
begin
:
aArgs
.
begin
chunk
:
aArgs
.
chunk
}
PDF_VIEWER_ORIGIN
)
;
}
onProgress
:
function
RangedChromeActions_onProgress
(
evt
)
{
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
rangeProgress
"
loaded
:
evt
.
loaded
}
PDF_VIEWER_ORIGIN
)
;
}
}
)
;
}
abortLoading
(
)
{
this
.
networkManager
.
abortAllRequests
(
)
;
if
(
this
.
originalRequest
)
{
this
.
originalRequest
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
this
.
originalRequest
=
null
;
}
this
.
dataListener
=
null
;
}
}
class
StandardChromeActions
extends
ChromeActions
{
constructor
(
domWindow
contentDispositionFilename
originalRequest
dataListener
)
{
super
(
domWindow
contentDispositionFilename
)
;
this
.
originalRequest
=
originalRequest
;
this
.
dataListener
=
dataListener
;
}
initPassiveLoading
(
)
{
if
(
!
this
.
dataListener
)
{
return
false
;
}
this
.
dataListener
.
onprogress
=
(
loaded
total
)
=
>
{
this
.
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
progress
"
loaded
total
}
PDF_VIEWER_ORIGIN
)
;
}
;
this
.
dataListener
.
oncomplete
=
(
data
errorCode
)
=
>
{
this
.
domWindow
.
postMessage
(
{
pdfjsLoadAction
:
"
complete
"
data
errorCode
filename
:
this
.
contentDispositionFilename
}
PDF_VIEWER_ORIGIN
)
;
this
.
dataListener
=
null
;
this
.
originalRequest
=
null
;
}
;
return
true
;
}
abortLoading
(
)
{
if
(
this
.
originalRequest
)
{
this
.
originalRequest
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
this
.
originalRequest
=
null
;
}
this
.
dataListener
=
null
;
}
}
class
RequestListener
{
constructor
(
actions
)
{
this
.
actions
=
actions
;
}
receive
(
event
)
{
var
message
=
event
.
target
;
var
doc
=
message
.
ownerDocument
;
var
action
=
event
.
detail
.
action
;
var
data
=
event
.
detail
.
data
;
var
sync
=
event
.
detail
.
sync
;
var
actions
=
this
.
actions
;
if
(
!
(
action
in
actions
)
)
{
log
(
"
Unknown
action
:
"
+
action
)
;
return
;
}
var
response
;
if
(
sync
)
{
response
=
actions
[
action
]
.
call
(
this
.
actions
data
)
;
event
.
detail
.
response
=
Cu
.
cloneInto
(
response
doc
.
defaultView
)
;
}
else
{
if
(
!
event
.
detail
.
responseExpected
)
{
doc
.
documentElement
.
removeChild
(
message
)
;
response
=
null
;
}
else
{
response
=
function
sendResponse
(
aResponse
)
{
try
{
var
listener
=
doc
.
createEvent
(
"
CustomEvent
"
)
;
let
detail
=
Cu
.
cloneInto
(
{
response
:
aResponse
}
doc
.
defaultView
)
;
listener
.
initCustomEvent
(
"
pdf
.
js
.
response
"
true
false
detail
)
;
return
message
.
dispatchEvent
(
listener
)
;
}
catch
(
e
)
{
return
false
;
}
}
;
}
actions
[
action
]
.
call
(
this
.
actions
data
response
)
;
}
}
}
function
PdfStreamConverter
(
)
{
}
PdfStreamConverter
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIStreamConverter
"
"
nsIStreamListener
"
"
nsIRequestObserver
"
]
)
convert
(
aFromStream
aFromType
aToType
aCtxt
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
asyncConvertData
(
aFromType
aToType
aListener
aCtxt
)
{
if
(
aCtxt
&
&
aCtxt
instanceof
Ci
.
nsIChannel
)
{
aCtxt
.
QueryInterface
(
Ci
.
nsIChannel
)
;
}
this
.
getConvertedType
(
aFromType
aCtxt
)
;
this
.
listener
=
aListener
;
}
_usableHandler
(
handlerInfo
)
{
let
{
preferredApplicationHandler
}
=
handlerInfo
;
if
(
!
preferredApplicationHandler
|
|
!
(
preferredApplicationHandler
instanceof
Ci
.
nsILocalHandlerApp
)
)
{
return
false
;
}
preferredApplicationHandler
.
QueryInterface
(
Ci
.
nsILocalHandlerApp
)
;
let
{
executable
}
=
preferredApplicationHandler
;
if
(
!
executable
)
{
return
false
;
}
return
!
executable
.
equals
(
lazy
.
gOurBinary
)
;
}
_validateAndMaybeUpdatePDFPrefs
(
)
{
let
{
processType
PROCESS_TYPE_DEFAULT
}
=
Services
.
appinfo
;
if
(
processType
!
=
PROCESS_TYPE_DEFAULT
|
|
lazy
.
PdfJs
.
cachedIsDefault
(
)
)
{
return
{
shouldOpen
:
true
}
;
}
let
mime
=
Svc
.
mime
.
getFromTypeAndExtension
(
PDF_CONTENT_TYPE
"
pdf
"
)
;
if
(
!
mime
)
{
return
{
shouldOpen
:
true
}
;
}
const
{
saveToDisk
useHelperApp
useSystemDefault
}
=
Ci
.
nsIHandlerInfo
;
let
{
preferredAction
alwaysAskBeforeHandling
}
=
mime
;
let
rv
=
{
alwaysAskBeforeHandling
shouldOpen
:
false
}
;
if
(
alwaysAskBeforeHandling
|
|
preferredAction
=
=
saveToDisk
)
{
return
rv
;
}
if
(
preferredAction
=
=
useHelperApp
&
&
this
.
_usableHandler
(
mime
)
)
{
return
rv
;
}
if
(
preferredAction
=
=
useSystemDefault
&
&
!
mime
.
isCurrentAppOSDefault
(
)
)
{
return
rv
;
}
rv
.
shouldOpen
=
true
;
Cu
.
reportError
(
"
Found
unusable
PDF
preferences
.
Fixing
back
to
PDF
.
js
"
)
;
mime
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
handleInternally
;
mime
.
alwaysAskBeforeHandling
=
false
;
Svc
.
handlers
.
store
(
mime
)
;
return
true
;
}
getConvertedType
(
aFromType
aChannel
)
{
const
HTML
=
"
text
/
html
"
;
let
channelURI
=
aChannel
?
.
URI
;
if
(
aFromType
!
=
"
application
/
pdf
"
)
{
let
isPDF
=
false
;
try
{
isPDF
=
aChannel
.
contentDispositionFilename
.
endsWith
(
"
.
pdf
"
)
;
}
catch
(
ex
)
{
}
if
(
!
isPDF
)
{
isPDF
=
channelURI
?
.
QueryInterface
(
Ci
.
nsIURL
)
.
fileExtension
.
toLowerCase
(
)
=
=
"
pdf
"
;
}
let
browsingContext
=
aChannel
?
.
loadInfo
.
targetBrowsingContext
;
let
toplevelOctetStream
=
aFromType
=
=
"
application
/
octet
-
stream
"
&
&
browsingContext
&
&
!
browsingContext
.
parent
;
if
(
!
isPDF
|
|
!
toplevelOctetStream
|
|
!
getBoolPref
(
PREF_PREFIX
+
"
.
handleOctetStream
"
false
)
)
{
throw
new
Components
.
Exception
(
"
Ignore
PDF
.
js
for
this
download
.
"
Cr
.
NS_ERROR_FAILURE
)
;
}
}
let
{
alwaysAskBeforeHandling
shouldOpen
}
=
this
.
_validateAndMaybeUpdatePDFPrefs
(
)
;
if
(
shouldOpen
)
{
return
HTML
;
}
if
(
channelURI
?
.
schemeIs
(
"
file
"
)
)
{
let
triggeringPrincipal
=
aChannel
.
loadInfo
?
.
triggeringPrincipal
;
if
(
triggeringPrincipal
?
.
isSystemPrincipal
)
{
return
HTML
;
}
if
(
triggeringPrincipal
?
.
schemeIs
(
"
file
"
)
&
&
alwaysAskBeforeHandling
)
{
return
HTML
;
}
}
throw
new
Components
.
Exception
(
"
Can
'
t
use
PDF
.
js
"
Cr
.
NS_ERROR_FAILURE
)
;
}
onDataAvailable
(
aRequest
aInputStream
aOffset
aCount
)
{
if
(
!
this
.
dataListener
)
{
return
;
}
var
binaryStream
=
this
.
binaryStream
;
binaryStream
.
setInputStream
(
aInputStream
)
;
let
chunk
=
new
ArrayBuffer
(
aCount
)
;
binaryStream
.
readArrayBuffer
(
aCount
chunk
)
;
this
.
dataListener
.
append
(
new
Uint8Array
(
chunk
)
)
;
}
onStartRequest
(
aRequest
)
{
var
isHttpRequest
=
false
;
try
{
aRequest
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
isHttpRequest
=
true
;
}
catch
(
e
)
{
}
var
rangeRequest
=
false
;
var
streamRequest
=
false
;
if
(
isHttpRequest
)
{
var
contentEncoding
=
"
identity
"
;
try
{
contentEncoding
=
aRequest
.
getResponseHeader
(
"
Content
-
Encoding
"
)
;
}
catch
(
e
)
{
}
var
acceptRanges
;
try
{
acceptRanges
=
aRequest
.
getResponseHeader
(
"
Accept
-
Ranges
"
)
;
}
catch
(
e
)
{
}
var
hash
=
aRequest
.
URI
.
ref
;
var
isPDFBugEnabled
=
getBoolPref
(
PREF_PREFIX
+
"
.
pdfBugEnabled
"
false
)
;
rangeRequest
=
contentEncoding
=
=
=
"
identity
"
&
&
acceptRanges
=
=
=
"
bytes
"
&
&
aRequest
.
contentLength
>
=
0
&
&
!
getBoolPref
(
PREF_PREFIX
+
"
.
disableRange
"
false
)
&
&
(
!
isPDFBugEnabled
|
|
!
hash
.
toLowerCase
(
)
.
includes
(
"
disablerange
=
true
"
)
)
;
streamRequest
=
contentEncoding
=
=
=
"
identity
"
&
&
aRequest
.
contentLength
>
=
0
&
&
!
getBoolPref
(
PREF_PREFIX
+
"
.
disableStream
"
false
)
&
&
(
!
isPDFBugEnabled
|
|
!
hash
.
toLowerCase
(
)
.
includes
(
"
disablestream
=
true
"
)
)
;
}
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
;
aRequest
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
var
contentDisposition
=
aRequest
.
DISPOSITION_INLINE
;
var
contentDispositionFilename
;
try
{
contentDisposition
=
aRequest
.
contentDisposition
;
contentDispositionFilename
=
aRequest
.
contentDispositionFilename
;
}
catch
(
e
)
{
}
if
(
contentDispositionFilename
&
&
!
/
\
.
pdf
/
i
.
test
(
contentDispositionFilename
)
)
{
contentDispositionFilename
+
=
"
.
pdf
"
;
}
aRequest
.
setProperty
(
"
contentType
"
aRequest
.
contentType
)
;
aRequest
.
contentType
=
"
text
/
html
"
;
if
(
isHttpRequest
)
{
aRequest
.
setResponseHeader
(
"
Content
-
Security
-
Policy
"
"
"
false
)
;
aRequest
.
setResponseHeader
(
"
Content
-
Security
-
Policy
-
Report
-
Only
"
"
"
false
)
;
aRequest
.
setResponseHeader
(
"
Refresh
"
"
"
false
)
;
}
lazy
.
PdfJsTelemetry
.
onViewerIsUsed
(
contentDisposition
=
=
aRequest
.
DISPOSITION_ATTACHMENT
)
;
lazy
.
PdfJsTelemetry
.
onDocumentSize
(
aRequest
.
contentLength
)
;
aRequest
.
contentDisposition
=
Ci
.
nsIChannel
.
DISPOSITION_FORCE_INLINE
;
var
contentLength
=
aRequest
.
contentLength
;
this
.
dataListener
=
new
PdfDataListener
(
contentLength
)
;
this
.
binaryStream
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
var
channel
=
lazy
.
NetUtil
.
newChannel
(
{
uri
:
PDF_VIEWER_WEB_PAGE
loadUsingSystemPrincipal
:
true
}
)
;
var
listener
=
this
.
listener
;
var
dataListener
=
this
.
dataListener
;
var
proxy
=
{
onStartRequest
(
request
)
{
listener
.
onStartRequest
(
aRequest
)
;
}
onDataAvailable
(
request
inputStream
offset
count
)
{
listener
.
onDataAvailable
(
aRequest
inputStream
offset
count
)
;
}
onStopRequest
(
request
statusCode
)
{
var
domWindow
=
getDOMWindow
(
channel
resourcePrincipal
)
;
if
(
!
Components
.
isSuccessCode
(
statusCode
)
|
|
!
domWindow
)
{
listener
.
onStopRequest
(
aRequest
statusCode
)
;
return
;
}
var
actions
;
if
(
rangeRequest
|
|
streamRequest
)
{
actions
=
new
RangedChromeActions
(
domWindow
contentDispositionFilename
aRequest
rangeRequest
streamRequest
dataListener
)
;
}
else
{
actions
=
new
StandardChromeActions
(
domWindow
contentDispositionFilename
aRequest
dataListener
)
;
}
var
requestListener
=
new
RequestListener
(
actions
)
;
domWindow
.
document
.
addEventListener
(
PDFJS_EVENT_ID
function
(
event
)
{
requestListener
.
receive
(
event
)
;
}
false
true
)
;
let
actor
=
getActor
(
domWindow
)
;
actor
?
.
init
(
actions
.
supportsIntegratedFind
(
)
)
;
listener
.
onStopRequest
(
aRequest
statusCode
)
;
if
(
domWindow
.
windowGlobalChild
.
browsingContext
.
parent
)
{
var
isObjectEmbed
=
domWindow
.
frameElement
?
domWindow
.
frameElement
.
tagName
=
=
"
OBJECT
"
|
|
domWindow
.
frameElement
.
tagName
=
=
"
EMBED
"
:
false
;
lazy
.
PdfJsTelemetry
.
onEmbed
(
isObjectEmbed
)
;
}
}
}
;
channel
.
originalURI
=
aRequest
.
URI
;
channel
.
loadGroup
=
aRequest
.
loadGroup
;
channel
.
loadInfo
.
originAttributes
=
aRequest
.
loadInfo
.
originAttributes
;
var
uri
=
lazy
.
NetUtil
.
newURI
(
PDF_VIEWER_WEB_PAGE
)
;
var
resourcePrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
uri
aRequest
.
loadInfo
.
originAttributes
)
;
let
originalPrincipal
=
Services
.
scriptSecurityManager
.
getChannelResultPrincipal
(
aRequest
)
;
aRequest
.
owner
=
resourcePrincipal
;
aRequest
.
setProperty
(
"
noPDFJSPrincipal
"
originalPrincipal
)
;
channel
.
asyncOpen
(
proxy
)
;
}
onStopRequest
(
aRequest
aStatusCode
)
{
if
(
!
this
.
dataListener
)
{
return
;
}
if
(
Components
.
isSuccessCode
(
aStatusCode
)
)
{
this
.
dataListener
.
finish
(
)
;
}
else
{
this
.
dataListener
.
error
(
aStatusCode
)
;
}
delete
this
.
dataListener
;
delete
this
.
binaryStream
;
}
}
;
