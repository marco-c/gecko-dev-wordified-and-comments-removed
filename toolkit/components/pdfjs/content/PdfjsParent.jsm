"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PdfjsParent
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
SetClipboardSearchString
"
"
resource
:
/
/
gre
/
modules
/
Finder
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
var
Svc
=
{
}
;
XPCOMUtils
.
defineLazyServiceGetter
(
Svc
"
mime
"
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
matchesCountLimit
"
"
accessibility
.
typeaheadfind
.
matchesCountLimit
"
)
;
let
gFindTypes
=
[
"
find
"
"
findagain
"
"
findhighlightallchange
"
"
findcasesensitivitychange
"
"
findbarclose
"
"
finddiacriticmatchingchange
"
]
;
class
PdfjsParent
extends
JSWindowActorParent
{
constructor
(
)
{
super
(
)
;
this
.
_boundToFindbar
=
null
;
this
.
_findFailedString
=
null
;
}
didDestroy
(
)
{
this
.
_removeEventListener
(
)
;
}
receiveMessage
(
aMsg
)
{
switch
(
aMsg
.
name
)
{
case
"
PDFJS
:
Parent
:
displayWarning
"
:
this
.
_displayWarning
(
aMsg
)
;
break
;
case
"
PDFJS
:
Parent
:
updateControlState
"
:
return
this
.
_updateControlState
(
aMsg
)
;
case
"
PDFJS
:
Parent
:
updateMatchesCount
"
:
return
this
.
_updateMatchesCount
(
aMsg
)
;
case
"
PDFJS
:
Parent
:
addEventListener
"
:
return
this
.
_addEventListener
(
)
;
case
"
PDFJS
:
Parent
:
saveURL
"
:
return
this
.
_saveURL
(
aMsg
)
;
}
return
undefined
;
}
get
browser
(
)
{
return
this
.
browsingContext
.
top
.
embedderElement
;
}
_saveURL
(
aMsg
)
{
const
data
=
aMsg
.
data
;
this
.
browser
.
ownerGlobal
.
saveURL
(
data
.
blobUrl
data
.
originalUrl
data
.
filename
null
true
false
null
null
null
lazy
.
PrivateBrowsingUtils
.
isBrowserPrivate
(
this
.
browser
)
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
_updateControlState
(
aMsg
)
{
let
data
=
aMsg
.
data
;
let
browser
=
this
.
browser
;
let
tabbrowser
=
browser
.
getTabBrowser
(
)
;
let
tab
=
tabbrowser
.
getTabForBrowser
(
browser
)
;
tabbrowser
.
getFindBar
(
tab
)
.
then
(
fb
=
>
{
if
(
!
fb
)
{
return
;
}
fb
.
updateControlState
(
data
.
result
data
.
findPrevious
)
;
if
(
data
.
result
=
=
=
Ci
.
nsITypeAheadFind
.
FIND_FOUND
|
|
data
.
result
=
=
=
Ci
.
nsITypeAheadFind
.
FIND_WRAPPED
|
|
(
data
.
result
=
=
=
Ci
.
nsITypeAheadFind
.
FIND_PENDING
&
&
!
this
.
_findFailedString
)
)
{
this
.
_findFailedString
=
null
;
lazy
.
SetClipboardSearchString
(
data
.
rawQuery
)
;
}
else
if
(
!
this
.
_findFailedString
)
{
this
.
_findFailedString
=
data
.
rawQuery
;
lazy
.
SetClipboardSearchString
(
data
.
rawQuery
)
;
}
const
matchesCount
=
this
.
_requestMatchesCount
(
data
.
matchesCount
)
;
fb
.
onMatchesCountResult
(
matchesCount
)
;
}
)
;
}
_updateMatchesCount
(
aMsg
)
{
let
data
=
aMsg
.
data
;
let
browser
=
this
.
browser
;
let
tabbrowser
=
browser
.
getTabBrowser
(
)
;
let
tab
=
tabbrowser
.
getTabForBrowser
(
browser
)
;
tabbrowser
.
getFindBar
(
tab
)
.
then
(
fb
=
>
{
if
(
!
fb
)
{
return
;
}
const
matchesCount
=
this
.
_requestMatchesCount
(
data
)
;
fb
.
onMatchesCountResult
(
matchesCount
)
;
}
)
;
}
_requestMatchesCount
(
data
)
{
if
(
!
data
)
{
return
{
current
:
0
total
:
0
}
;
}
let
result
=
{
current
:
data
.
current
total
:
data
.
total
limit
:
typeof
lazy
.
matchesCountLimit
=
=
=
"
number
"
?
lazy
.
matchesCountLimit
:
0
}
;
if
(
result
.
total
>
result
.
limit
)
{
result
.
total
=
-
1
;
}
return
result
;
}
handleEvent
(
aEvent
)
{
const
type
=
aEvent
.
type
;
if
(
type
=
=
"
TabFindInitialized
"
)
{
let
browser
=
aEvent
.
target
.
linkedBrowser
;
this
.
_hookupEventListeners
(
browser
)
;
aEvent
.
target
.
removeEventListener
(
type
this
)
;
return
;
}
if
(
type
=
=
"
SwapDocShells
"
)
{
this
.
_removeEventListener
(
)
;
let
newBrowser
=
aEvent
.
detail
;
newBrowser
.
addEventListener
(
"
EndSwapDocShells
"
evt
=
>
{
this
.
_hookupEventListeners
(
newBrowser
)
;
}
{
once
:
true
}
)
;
return
;
}
if
(
this
.
windowContext
.
isInBFCache
)
{
return
;
}
let
detail
=
null
;
if
(
type
!
=
=
"
findbarclose
"
)
{
detail
=
{
query
:
aEvent
.
detail
.
query
caseSensitive
:
aEvent
.
detail
.
caseSensitive
entireWord
:
aEvent
.
detail
.
entireWord
highlightAll
:
aEvent
.
detail
.
highlightAll
findPrevious
:
aEvent
.
detail
.
findPrevious
matchDiacritics
:
aEvent
.
detail
.
matchDiacritics
}
;
}
let
browser
=
aEvent
.
currentTarget
.
browser
;
if
(
!
this
.
_boundToFindbar
)
{
throw
new
Error
(
"
FindEventManager
was
not
bound
for
the
current
browser
.
"
)
;
}
browser
.
sendMessageToActor
(
"
PDFJS
:
Child
:
handleEvent
"
{
type
detail
}
"
Pdfjs
"
)
;
aEvent
.
preventDefault
(
)
;
}
_addEventListener
(
)
{
let
browser
=
this
.
browser
;
if
(
this
.
_boundToFindbar
)
{
throw
new
Error
(
"
FindEventManager
was
bound
2nd
time
without
unbinding
it
first
.
"
)
;
}
this
.
_hookupEventListeners
(
browser
)
;
}
_hookupEventListeners
(
aBrowser
)
{
let
tabbrowser
=
aBrowser
.
getTabBrowser
(
)
;
let
tab
=
tabbrowser
.
getTabForBrowser
(
aBrowser
)
;
let
findbar
=
tabbrowser
.
getCachedFindBar
(
tab
)
;
if
(
findbar
)
{
for
(
var
i
=
0
;
i
<
gFindTypes
.
length
;
i
+
+
)
{
var
type
=
gFindTypes
[
i
]
;
findbar
.
addEventListener
(
type
this
true
)
;
}
this
.
_boundToFindbar
=
findbar
;
}
else
{
tab
.
addEventListener
(
"
TabFindInitialized
"
this
)
;
}
aBrowser
.
addEventListener
(
"
SwapDocShells
"
this
)
;
return
!
!
findbar
;
}
_removeEventListener
(
)
{
let
browser
=
this
.
browser
;
let
findbar
=
this
.
_boundToFindbar
;
if
(
findbar
)
{
for
(
var
i
=
0
;
i
<
gFindTypes
.
length
;
i
+
+
)
{
var
type
=
gFindTypes
[
i
]
;
findbar
.
removeEventListener
(
type
this
true
)
;
}
}
else
if
(
browser
)
{
let
tabbrowser
=
browser
.
getTabBrowser
(
)
;
let
tab
=
tabbrowser
.
getTabForBrowser
(
browser
)
;
tab
?
.
removeEventListener
(
"
TabFindInitialized
"
this
)
;
}
this
.
_boundToFindbar
=
null
;
browser
?
.
removeEventListener
(
"
SwapDocShells
"
this
)
;
}
_displayWarning
(
aMsg
)
{
let
data
=
aMsg
.
data
;
let
browser
=
this
.
browser
;
let
tabbrowser
=
browser
.
getTabBrowser
(
)
;
let
notificationBox
=
tabbrowser
.
getNotificationBox
(
browser
)
;
let
messageSent
=
false
;
let
sendMessage
=
download
=
>
{
if
(
messageSent
)
{
return
;
}
try
{
this
.
sendAsyncMessage
(
"
PDFJS
:
Child
:
fallbackDownload
"
{
download
}
)
;
messageSent
=
true
;
}
catch
(
ex
)
{
if
(
!
/
JSWindowActorParent
cannot
send
at
the
moment
/
.
test
(
ex
.
message
)
)
{
throw
ex
;
}
}
}
;
let
buttons
=
[
{
label
:
data
.
label
accessKey
:
data
.
accessKey
callback
(
)
{
sendMessage
(
true
)
;
}
}
]
;
notificationBox
.
appendNotification
(
"
pdfjs
-
fallback
"
{
label
:
data
.
message
priority
:
notificationBox
.
PRIORITY_INFO_MEDIUM
eventCallback
:
eventType
=
>
{
if
(
eventType
!
=
=
"
removed
"
)
{
return
;
}
sendMessage
(
false
)
;
}
}
buttons
)
;
}
}
