"
use
strict
"
;
const
{
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LanguageDetector
"
"
resource
:
/
/
/
modules
/
translation
/
LanguageDetector
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
Narrator
"
]
;
const
PREV_THRESHOLD
=
2000
;
function
Narrator
(
win
)
{
this
.
_winRef
=
Cu
.
getWeakReference
(
win
)
;
this
.
_inTest
=
Services
.
prefs
.
getBoolPref
(
"
narrate
.
test
"
)
;
this
.
_speechOptions
=
{
}
;
this
.
_startTime
=
0
;
this
.
_stopped
=
false
;
}
Narrator
.
prototype
=
{
get
_doc
(
)
{
return
this
.
_winRef
.
get
(
)
.
document
;
}
get
_win
(
)
{
return
this
.
_winRef
.
get
(
)
;
}
get
_voiceMap
(
)
{
if
(
!
this
.
_voiceMapInner
)
{
this
.
_voiceMapInner
=
new
Map
(
)
;
for
(
let
voice
of
this
.
_win
.
speechSynthesis
.
getVoices
(
)
)
{
this
.
_voiceMapInner
.
set
(
voice
.
voiceURI
voice
)
;
}
}
return
this
.
_voiceMapInner
;
}
get
_treeWalker
(
)
{
if
(
!
this
.
_treeWalkerRef
)
{
let
wu
=
this
.
_win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
let
nf
=
this
.
_win
.
NodeFilter
;
let
filter
=
{
_matches
:
new
Set
(
)
acceptNode
:
function
(
node
)
{
if
(
this
.
_matches
.
has
(
node
.
parentNode
)
)
{
return
nf
.
FILTER_REJECT
;
}
let
bb
=
wu
.
getBoundsWithoutFlushing
(
node
)
;
if
(
!
bb
.
width
|
|
!
bb
.
height
)
{
return
nf
.
FILTER_SKIP
;
}
for
(
let
c
=
node
.
firstChild
;
c
;
c
=
c
.
nextSibling
)
{
if
(
c
.
nodeType
=
=
c
.
TEXT_NODE
&
&
!
!
c
.
textContent
.
match
(
/
\
S
/
)
)
{
this
.
_matches
.
add
(
node
)
;
return
nf
.
FILTER_ACCEPT
;
}
}
return
nf
.
FILTER_SKIP
;
}
}
;
this
.
_treeWalkerRef
=
new
WeakMap
(
)
;
this
.
_treeWalkerRef
.
set
(
this
.
_win
this
.
_doc
.
createTreeWalker
(
this
.
_doc
.
getElementById
(
"
container
"
)
nf
.
SHOW_ELEMENT
filter
false
)
)
;
}
return
this
.
_treeWalkerRef
.
get
(
this
.
_win
)
;
}
get
_timeIntoParagraph
(
)
{
let
rv
=
Date
.
now
(
)
-
this
.
_startTime
;
return
rv
;
}
get
speaking
(
)
{
return
this
.
_win
.
speechSynthesis
.
speaking
|
|
this
.
_win
.
speechSynthesis
.
pending
;
}
_isParagraphInView
:
function
(
paragraph
)
{
if
(
!
paragraph
)
{
return
false
;
}
let
bb
=
paragraph
.
getBoundingClientRect
(
)
;
return
bb
.
top
>
=
0
&
&
bb
.
top
<
this
.
_win
.
innerHeight
;
}
_detectLanguage
:
function
(
)
{
if
(
this
.
_speechOptions
.
lang
|
|
this
.
_speechOptions
.
voice
)
{
return
Promise
.
resolve
(
)
;
}
let
sampleText
=
this
.
_doc
.
getElementById
(
"
moz
-
reader
-
content
"
)
.
textContent
.
substring
(
0
60
*
1024
)
;
return
LanguageDetector
.
detectLanguage
(
sampleText
)
.
then
(
result
=
>
{
if
(
result
.
confident
)
{
this
.
_speechOptions
.
lang
=
result
.
language
;
}
}
)
;
}
_sendTestEvent
:
function
(
eventType
detail
)
{
let
win
=
this
.
_win
;
win
.
dispatchEvent
(
new
win
.
CustomEvent
(
eventType
{
detail
:
Cu
.
cloneInto
(
detail
win
.
document
)
}
)
)
;
}
_speakInner
:
function
(
)
{
this
.
_win
.
speechSynthesis
.
cancel
(
)
;
let
tw
=
this
.
_treeWalker
;
let
paragraph
=
tw
.
nextNode
(
)
;
if
(
!
paragraph
)
{
tw
.
currentNode
=
tw
.
root
;
return
Promise
.
resolve
(
)
;
}
let
utterance
=
new
this
.
_win
.
SpeechSynthesisUtterance
(
paragraph
.
textContent
)
;
utterance
.
rate
=
this
.
_speechOptions
.
rate
;
if
(
this
.
_speechOptions
.
voice
)
{
utterance
.
voice
=
this
.
_speechOptions
.
voice
;
}
else
{
utterance
.
lang
=
this
.
_speechOptions
.
lang
;
}
this
.
_startTime
=
Date
.
now
(
)
;
return
new
Promise
(
resolve
=
>
{
utterance
.
addEventListener
(
"
start
"
(
)
=
>
{
paragraph
.
classList
.
add
(
"
narrating
"
)
;
let
bb
=
paragraph
.
getBoundingClientRect
(
)
;
if
(
bb
.
top
<
0
|
|
bb
.
bottom
>
this
.
_win
.
innerHeight
)
{
paragraph
.
scrollIntoView
(
{
behavior
:
"
smooth
"
block
:
"
start
"
}
)
;
}
if
(
this
.
_inTest
)
{
this
.
_sendTestEvent
(
"
paragraphstart
"
{
voice
:
utterance
.
chosenVoiceURI
rate
:
utterance
.
rate
paragraph
:
paragraph
.
textContent
}
)
;
}
}
)
;
utterance
.
addEventListener
(
"
end
"
(
)
=
>
{
if
(
!
this
.
_win
)
{
return
;
}
paragraph
.
classList
.
remove
(
"
narrating
"
)
;
this
.
_startTime
=
0
;
if
(
this
.
_inTest
)
{
this
.
_sendTestEvent
(
"
paragraphend
"
{
}
)
;
}
if
(
this
.
_stopped
)
{
resolve
(
)
;
}
else
{
this
.
_speakInner
(
)
.
then
(
resolve
)
;
}
}
)
;
this
.
_win
.
speechSynthesis
.
speak
(
utterance
)
;
}
)
;
}
getVoiceOptions
:
function
(
)
{
return
Array
.
from
(
this
.
_voiceMap
.
values
(
)
)
;
}
start
:
function
(
speechOptions
)
{
this
.
_speechOptions
=
{
rate
:
speechOptions
.
rate
voice
:
this
.
_voiceMap
.
get
(
speechOptions
.
voice
)
}
;
this
.
_stopped
=
false
;
return
this
.
_detectLanguage
(
)
.
then
(
(
)
=
>
{
let
tw
=
this
.
_treeWalker
;
if
(
!
this
.
_isParagraphInView
(
tw
.
currentNode
)
)
{
tw
.
currentNode
=
tw
.
root
;
while
(
tw
.
nextNode
(
)
&
&
!
this
.
_isParagraphInView
(
tw
.
currentNode
)
)
{
}
tw
.
previousNode
(
)
;
}
return
this
.
_speakInner
(
)
;
}
)
;
}
stop
:
function
(
)
{
this
.
_stopped
=
true
;
this
.
_win
.
speechSynthesis
.
cancel
(
)
;
}
skipNext
:
function
(
)
{
this
.
_win
.
speechSynthesis
.
cancel
(
)
;
}
skipPrevious
:
function
(
)
{
let
tw
=
this
.
_treeWalker
;
tw
.
previousNode
(
)
;
if
(
this
.
_timeIntoParagraph
<
PREV_THRESHOLD
)
{
tw
.
previousNode
(
)
;
}
this
.
_win
.
speechSynthesis
.
cancel
(
)
;
}
setRate
:
function
(
rate
)
{
this
.
_speechOptions
.
rate
=
rate
;
this
.
_treeWalker
.
previousNode
(
)
;
this
.
_win
.
speechSynthesis
.
cancel
(
)
;
}
setVoice
:
function
(
voice
)
{
this
.
_speechOptions
.
voice
=
this
.
_voiceMap
.
get
(
voice
)
;
this
.
_treeWalker
.
previousNode
(
)
;
this
.
_win
.
speechSynthesis
.
cancel
(
)
;
}
}
;
