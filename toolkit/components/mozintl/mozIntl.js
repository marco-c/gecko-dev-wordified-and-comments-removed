ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
mozIntlHelper
=
Cc
[
"
mozilla
.
org
/
mozintlhelper
;
1
"
]
.
getService
(
Ci
.
mozIMozIntlHelper
)
;
const
osPrefs
=
Cc
[
"
mozilla
.
org
/
intl
/
ospreferences
;
1
"
]
.
getService
(
Ci
.
mozIOSPreferences
)
;
const
languageTagMatch
=
/
^
(
[
a
-
z
]
{
2
3
}
|
[
a
-
z
]
{
4
}
|
[
a
-
z
]
{
5
8
}
)
(
?
:
[
-
_
]
(
[
a
-
z
]
{
4
}
)
)
?
(
?
:
[
-
_
]
(
[
A
-
Z
]
{
2
}
|
[
0
-
9
]
{
3
}
)
)
?
(
(
?
:
[
-
_
]
(
?
:
[
a
-
z0
-
9
]
{
5
8
}
|
[
0
-
9
]
[
a
-
z0
-
9
]
{
3
}
)
)
*
)
(
?
:
[
-
_
]
[
a
-
wy
-
z0
-
9
]
(
?
:
[
-
_
]
[
a
-
z0
-
9
]
{
2
8
}
)
+
)
*
(
?
:
[
-
_
]
x
(
?
:
[
-
_
]
[
a
-
z0
-
9
]
{
1
8
}
)
+
)
?
/
i
;
function
getLocales
(
locales
)
{
if
(
!
locales
)
{
return
Services
.
locale
.
getRegionalPrefsLocales
(
)
;
}
return
locales
;
}
function
getDateTimePatternStyle
(
option
)
{
switch
(
option
)
{
case
"
full
"
:
return
osPrefs
.
dateTimeFormatStyleFull
;
case
"
long
"
:
return
osPrefs
.
dateTimeFormatStyleLong
;
case
"
medium
"
:
return
osPrefs
.
dateTimeFormatStyleMedium
;
case
"
short
"
:
return
osPrefs
.
dateTimeFormatStyleShort
;
default
:
return
osPrefs
.
dateTimeFormatStyleNone
;
}
}
const
second
=
1e3
;
const
minute
=
6e4
;
const
hour
=
36e5
;
const
day
=
864e5
;
function
defineCachedGetter
(
obj
prop
get
)
{
defineGetter
(
obj
prop
function
(
)
{
if
(
!
this
.
_
[
prop
]
)
{
this
.
_
[
prop
]
=
get
.
call
(
this
)
;
}
return
this
.
_
[
prop
]
;
}
)
;
}
function
defineGetter
(
obj
prop
get
)
{
Object
.
defineProperty
(
obj
prop
{
get
}
)
;
}
function
startOf
(
date
unit
)
{
date
=
new
Date
(
date
.
getTime
(
)
)
;
switch
(
unit
)
{
case
"
year
"
:
date
.
setMonth
(
0
)
;
case
"
month
"
:
date
.
setDate
(
1
)
;
case
"
day
"
:
date
.
setHours
(
0
)
;
case
"
hour
"
:
date
.
setMinutes
(
0
)
;
case
"
minute
"
:
date
.
setSeconds
(
0
)
;
case
"
second
"
:
date
.
setMilliseconds
(
0
)
;
}
return
date
;
}
function
bestFit
(
absDiff
)
{
switch
(
true
)
{
case
absDiff
.
years
>
0
&
&
absDiff
.
months
>
threshold
.
month
:
return
"
year
"
;
case
absDiff
.
months
>
0
&
&
absDiff
.
days
>
threshold
.
day
:
return
"
month
"
;
case
absDiff
.
days
>
0
&
&
absDiff
.
hours
>
threshold
.
hour
:
return
"
day
"
;
case
absDiff
.
hours
>
0
&
&
absDiff
.
minutes
>
threshold
.
minute
:
return
"
hour
"
;
case
absDiff
.
minutes
>
0
&
&
absDiff
.
seconds
>
threshold
.
second
:
return
"
minute
"
;
default
:
return
"
second
"
;
}
}
const
threshold
=
{
month
:
2
day
:
6
hour
:
6
minute
:
59
second
:
59
}
;
class
MozIntl
{
constructor
(
)
{
this
.
_cache
=
{
}
;
}
getCalendarInfo
(
locales
.
.
.
args
)
{
if
(
!
this
.
_cache
.
hasOwnProperty
(
"
getCalendarInfo
"
)
)
{
mozIntlHelper
.
addGetCalendarInfo
(
this
.
_cache
)
;
}
return
this
.
_cache
.
getCalendarInfo
(
getLocales
(
locales
)
.
.
.
args
)
;
}
getDisplayNames
(
locales
.
.
.
args
)
{
if
(
!
this
.
_cache
.
hasOwnProperty
(
"
getDisplayNames
"
)
)
{
mozIntlHelper
.
addGetDisplayNames
(
this
.
_cache
)
;
}
return
this
.
_cache
.
getDisplayNames
(
getLocales
(
locales
)
.
.
.
args
)
;
}
getLocaleInfo
(
locales
.
.
.
args
)
{
if
(
!
this
.
_cache
.
hasOwnProperty
(
"
getLocaleInfo
"
)
)
{
mozIntlHelper
.
addGetLocaleInfo
(
this
.
_cache
)
;
}
return
this
.
_cache
.
getLocaleInfo
(
getLocales
(
locales
)
.
.
.
args
)
;
}
getLanguageDisplayNames
(
locales
langCodes
)
{
if
(
locales
!
=
=
undefined
)
{
throw
new
Error
(
"
First
argument
support
not
implemented
yet
"
)
;
}
const
languageBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
languageNames
.
properties
"
)
;
return
langCodes
.
map
(
langCode
=
>
{
if
(
typeof
langCode
!
=
=
"
string
"
)
{
throw
new
TypeError
(
"
All
language
codes
must
be
strings
.
"
)
;
}
try
{
return
languageBundle
.
GetStringFromName
(
langCode
.
toLowerCase
(
)
)
;
}
catch
(
e
)
{
return
langCode
.
toLowerCase
(
)
;
}
}
)
;
}
getRegionDisplayNames
(
locales
regionCodes
)
{
if
(
locales
!
=
=
undefined
)
{
throw
new
Error
(
"
First
argument
support
not
implemented
yet
"
)
;
}
const
regionBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
regionNames
.
properties
"
)
;
return
regionCodes
.
map
(
regionCode
=
>
{
if
(
typeof
regionCode
!
=
=
"
string
"
)
{
throw
new
TypeError
(
"
All
region
codes
must
be
strings
.
"
)
;
}
try
{
return
regionBundle
.
GetStringFromName
(
regionCode
.
toLowerCase
(
)
)
;
}
catch
(
e
)
{
return
regionCode
.
toUpperCase
(
)
;
}
}
)
;
}
getLocaleDisplayNames
(
locales
localeCodes
)
{
if
(
locales
!
=
=
undefined
)
{
throw
new
Error
(
"
First
argument
support
not
implemented
yet
"
)
;
}
const
localePattern
=
"
{
0
}
(
{
1
}
)
"
;
const
localeSeparator
=
"
"
;
return
localeCodes
.
map
(
localeCode
=
>
{
if
(
typeof
localeCode
!
=
=
"
string
"
)
{
throw
new
TypeError
(
"
All
locale
codes
must
be
strings
.
"
)
;
}
const
match
=
localeCode
.
match
(
languageTagMatch
)
;
if
(
match
=
=
=
null
)
{
return
localeCode
;
}
const
[
languageSubtag
scriptSubtag
regionSubtag
variantSubtags
]
=
match
;
const
displayName
=
[
this
.
getLanguageDisplayNames
(
locales
[
languageSubtag
]
)
[
0
]
]
;
if
(
scriptSubtag
)
{
displayName
.
push
(
scriptSubtag
)
;
}
if
(
regionSubtag
)
{
displayName
.
push
(
this
.
getRegionDisplayNames
(
locales
[
regionSubtag
]
)
[
0
]
)
;
}
if
(
variantSubtags
)
{
displayName
.
push
(
.
.
.
variantSubtags
.
substr
(
1
)
.
split
(
/
[
-
_
]
/
)
)
;
}
let
modifiers
;
if
(
displayName
.
length
=
=
=
1
)
{
return
displayName
[
0
]
;
}
else
if
(
displayName
.
length
>
2
)
{
modifiers
=
displayName
.
slice
(
1
)
.
join
(
localeSeparator
)
;
}
else
{
modifiers
=
displayName
[
1
]
;
}
return
localePattern
.
replace
(
"
{
0
}
"
displayName
[
0
]
)
.
replace
(
"
{
1
}
"
modifiers
)
;
}
)
;
}
get
DateTimeFormat
(
)
{
if
(
!
this
.
_cache
.
hasOwnProperty
(
"
DateTimeFormat
"
)
)
{
mozIntlHelper
.
addDateTimeFormatConstructor
(
this
.
_cache
)
;
}
let
DateTimeFormat
=
this
.
_cache
.
DateTimeFormat
;
class
MozDateTimeFormat
extends
DateTimeFormat
{
constructor
(
locales
options
.
.
.
args
)
{
let
resolvedLocales
=
DateTimeFormat
.
supportedLocalesOf
(
getLocales
(
locales
)
)
;
if
(
options
)
{
if
(
options
.
dateStyle
|
|
options
.
timeStyle
)
{
options
.
pattern
=
osPrefs
.
getDateTimePattern
(
getDateTimePatternStyle
(
options
.
dateStyle
)
getDateTimePatternStyle
(
options
.
timeStyle
)
resolvedLocales
[
0
]
)
;
}
else
{
options
.
pattern
=
undefined
;
}
}
super
(
resolvedLocales
options
.
.
.
args
)
;
}
}
return
MozDateTimeFormat
;
}
get
NumberFormat
(
)
{
class
MozNumberFormat
extends
Intl
.
NumberFormat
{
constructor
(
locales
options
.
.
.
args
)
{
super
(
getLocales
(
locales
)
options
.
.
.
args
)
;
}
}
return
MozNumberFormat
;
}
get
Collator
(
)
{
class
MozCollator
extends
Intl
.
Collator
{
constructor
(
locales
options
.
.
.
args
)
{
super
(
getLocales
(
locales
)
options
.
.
.
args
)
;
}
}
return
MozCollator
;
}
get
PluralRules
(
)
{
class
MozPluralRules
extends
Intl
.
PluralRules
{
constructor
(
locales
options
.
.
.
args
)
{
super
(
getLocales
(
locales
)
options
.
.
.
args
)
;
}
}
return
MozPluralRules
;
}
get
RelativeTimeFormat
(
)
{
if
(
!
this
.
_cache
.
hasOwnProperty
(
"
RelativeTimeFormat
"
)
)
{
mozIntlHelper
.
addRelativeTimeFormatConstructor
(
this
.
_cache
)
;
}
const
RelativeTimeFormat
=
this
.
_cache
.
RelativeTimeFormat
;
class
MozRelativeTimeFormat
extends
RelativeTimeFormat
{
constructor
(
locales
options
=
{
}
.
.
.
args
)
{
if
(
options
.
numeric
=
=
=
undefined
)
{
options
.
numeric
=
"
auto
"
;
}
super
(
getLocales
(
locales
)
options
.
.
.
args
)
;
}
formatBestUnit
(
date
{
now
=
new
Date
(
)
}
=
{
}
)
{
const
diff
=
{
_
:
{
}
ms
:
date
.
getTime
(
)
-
now
.
getTime
(
)
years
:
date
.
getFullYear
(
)
-
now
.
getFullYear
(
)
}
;
defineCachedGetter
(
diff
"
months
"
function
(
)
{
return
this
.
years
*
12
+
date
.
getMonth
(
)
-
now
.
getMonth
(
)
;
}
)
;
defineCachedGetter
(
diff
"
days
"
function
(
)
{
return
Math
.
trunc
(
(
startOf
(
date
"
day
"
)
-
startOf
(
now
"
day
"
)
)
/
day
)
;
}
)
;
defineCachedGetter
(
diff
"
hours
"
function
(
)
{
return
Math
.
trunc
(
(
startOf
(
date
"
hour
"
)
-
startOf
(
now
"
hour
"
)
)
/
hour
)
;
}
)
;
defineCachedGetter
(
diff
"
minutes
"
function
(
)
{
return
Math
.
trunc
(
(
startOf
(
date
"
minute
"
)
-
startOf
(
now
"
minute
"
)
)
/
minute
)
;
}
)
;
defineCachedGetter
(
diff
"
seconds
"
function
(
)
{
return
Math
.
trunc
(
(
startOf
(
date
"
second
"
)
-
startOf
(
now
"
second
"
)
)
/
second
)
;
}
)
;
const
absDiff
=
{
_
:
{
}
}
;
defineGetter
(
absDiff
"
years
"
function
(
)
{
return
Math
.
abs
(
diff
.
years
)
;
}
)
;
defineGetter
(
absDiff
"
months
"
function
(
)
{
return
Math
.
abs
(
diff
.
months
)
;
}
)
;
defineGetter
(
absDiff
"
days
"
function
(
)
{
return
Math
.
abs
(
diff
.
days
)
;
}
)
;
defineGetter
(
absDiff
"
hours
"
function
(
)
{
return
Math
.
abs
(
diff
.
hours
)
;
}
)
;
defineGetter
(
absDiff
"
minutes
"
function
(
)
{
return
Math
.
abs
(
diff
.
minutes
)
;
}
)
;
defineGetter
(
absDiff
"
seconds
"
function
(
)
{
return
Math
.
abs
(
diff
.
seconds
)
;
}
)
;
const
unit
=
bestFit
(
absDiff
)
;
switch
(
unit
)
{
case
"
year
"
:
return
this
.
format
(
diff
.
years
unit
)
;
case
"
month
"
:
return
this
.
format
(
diff
.
months
unit
)
;
case
"
day
"
:
return
this
.
format
(
diff
.
days
unit
)
;
case
"
hour
"
:
return
this
.
format
(
diff
.
hours
unit
)
;
case
"
minute
"
:
return
this
.
format
(
diff
.
minutes
unit
)
;
default
:
if
(
unit
!
=
=
"
second
"
)
{
throw
new
TypeError
(
Unsupported
unit
"
{
unit
}
"
)
;
}
return
this
.
format
(
diff
.
seconds
unit
)
;
}
}
}
return
MozRelativeTimeFormat
;
}
}
MozIntl
.
prototype
.
classID
=
Components
.
ID
(
"
{
35ec195a
-
e8d0
-
4300
-
83af
-
c8a2cc84b4a3
}
"
)
;
MozIntl
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
mozIMozIntl
]
)
;
var
components
=
[
MozIntl
]
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
components
)
;
