#
include
"
nsParentalControlsService
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIArray
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsILocalFileWin
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
nsIWindowsRegKey
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
<
sddl
.
h
>
using
namespace
mozilla
;
NS_IMPL_ISUPPORTS
(
nsParentalControlsService
nsIParentalControlsService
)
static
nsAutoString
GetUserSid
(
)
{
nsAutoString
ret
;
HANDLE
rawToken
;
BOOL
success
=
:
:
OpenProcessToken
(
:
:
GetCurrentProcess
(
)
TOKEN_QUERY
&
rawToken
)
;
if
(
!
success
)
{
return
ret
;
}
nsAutoHandle
token
(
rawToken
)
;
DWORD
bufLen
;
success
=
:
:
GetTokenInformation
(
token
TokenUser
nullptr
0
&
bufLen
)
;
if
(
GetLastError
(
)
!
=
ERROR_INSUFFICIENT_BUFFER
)
{
return
ret
;
}
UniquePtr
<
char
[
]
>
buf
=
MakeUnique
<
char
[
]
>
(
bufLen
)
;
success
=
:
:
GetTokenInformation
(
token
TokenUser
buf
.
get
(
)
bufLen
&
bufLen
)
;
MOZ_ASSERT
(
success
)
;
if
(
success
)
{
TOKEN_USER
*
tokenUser
=
(
TOKEN_USER
*
)
(
buf
.
get
(
)
)
;
PSID
sid
=
tokenUser
-
>
User
.
Sid
;
LPWSTR
sidStr
;
success
=
:
:
ConvertSidToStringSidW
(
sid
&
sidStr
)
;
if
(
success
)
{
ret
=
sidStr
;
:
:
LocalFree
(
sidStr
)
;
}
}
return
ret
;
}
nsParentalControlsService
:
:
nsParentalControlsService
(
)
:
mEnabled
(
false
)
mProvider
(
0
)
mPC
(
nullptr
)
{
if
(
IsWin10OrLater
(
)
)
{
nsAutoString
regKeyName
;
regKeyName
.
AppendLiteral
(
"
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
Parental
Controls
\
\
"
"
Users
\
\
"
)
;
regKeyName
.
Append
(
GetUserSid
(
)
)
;
regKeyName
.
AppendLiteral
(
"
\
\
Web
"
)
;
nsresult
rv
;
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_LOCAL_MACHINE
regKeyName
nsIWindowsRegKey
:
:
ACCESS_READ
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
uint32_t
filterOn
=
0
;
rv
=
regKey
-
>
ReadIntValue
(
u
"
Filter
On
"
_ns
&
filterOn
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
mEnabled
=
filterOn
!
=
0
;
return
;
}
HRESULT
hr
;
CoInitialize
(
nullptr
)
;
hr
=
CoCreateInstance
(
__uuidof
(
WindowsParentalControls
)
nullptr
CLSCTX_INPROC
IID_PPV_ARGS
(
&
mPC
)
)
;
if
(
FAILED
(
hr
)
)
return
;
RefPtr
<
IWPCSettings
>
wpcs
;
if
(
FAILED
(
mPC
-
>
GetUserSettings
(
nullptr
getter_AddRefs
(
wpcs
)
)
)
)
{
mPC
-
>
Release
(
)
;
mPC
=
nullptr
;
return
;
}
DWORD
settings
=
0
;
wpcs
-
>
GetRestrictions
(
&
settings
)
;
bool
enable
=
IsWin8OrLater
(
)
?
settings
&
WPCFLAG_WEB_FILTERED
:
settings
!
=
WPCFLAG_NO_RESTRICTION
;
if
(
enable
)
{
mEnabled
=
true
;
}
}
nsParentalControlsService
:
:
~
nsParentalControlsService
(
)
{
if
(
mPC
)
mPC
-
>
Release
(
)
;
if
(
mProvider
)
{
EventUnregister
(
mProvider
)
;
}
}
NS_IMETHODIMP
nsParentalControlsService
:
:
GetParentalControlsEnabled
(
bool
*
aResult
)
{
*
aResult
=
false
;
if
(
mEnabled
)
*
aResult
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsParentalControlsService
:
:
GetBlockFileDownloadsEnabled
(
bool
*
aResult
)
{
*
aResult
=
false
;
if
(
!
mEnabled
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
mPC
)
{
return
NS_OK
;
}
RefPtr
<
IWPCWebSettings
>
wpcws
;
if
(
SUCCEEDED
(
mPC
-
>
GetWebSettings
(
nullptr
getter_AddRefs
(
wpcws
)
)
)
)
{
DWORD
settings
=
0
;
wpcws
-
>
GetSettings
(
&
settings
)
;
if
(
settings
=
=
WPCFLAG_WEB_SETTING_DOWNLOADSBLOCKED
)
*
aResult
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsParentalControlsService
:
:
GetLoggingEnabled
(
bool
*
aResult
)
{
*
aResult
=
false
;
if
(
!
mEnabled
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
mPC
)
{
return
NS_OK
;
}
RefPtr
<
IWPCSettings
>
wpcs
;
if
(
SUCCEEDED
(
mPC
-
>
GetUserSettings
(
nullptr
getter_AddRefs
(
wpcs
)
)
)
)
{
BOOL
enabled
=
FALSE
;
wpcs
-
>
IsLoggingRequired
(
&
enabled
)
;
if
(
enabled
)
*
aResult
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsParentalControlsService
:
:
Log
(
int16_t
aEntryType
bool
blocked
nsIURI
*
aSource
nsIFile
*
aTarget
)
{
if
(
!
mEnabled
)
return
NS_ERROR_NOT_AVAILABLE
;
NS_ENSURE_ARG_POINTER
(
aSource
)
;
bool
enabled
;
GetLoggingEnabled
(
&
enabled
)
;
if
(
!
enabled
)
return
NS_ERROR_NOT_AVAILABLE
;
if
(
!
mProvider
)
{
if
(
EventRegister
(
&
WPCPROV
nullptr
nullptr
&
mProvider
)
!
=
ERROR_SUCCESS
)
return
NS_ERROR_OUT_OF_MEMORY
;
}
switch
(
aEntryType
)
{
case
ePCLog_URIVisit
:
break
;
case
ePCLog_FileDownload
:
LogFileDownload
(
blocked
aSource
aTarget
)
;
break
;
default
:
break
;
}
return
NS_OK
;
}
void
nsParentalControlsService
:
:
LogFileDownload
(
bool
blocked
nsIURI
*
aSource
nsIFile
*
aTarget
)
{
nsAutoCString
curi
;
aSource
-
>
GetSpec
(
curi
)
;
nsAutoString
uri
=
NS_ConvertUTF8toUTF16
(
curi
)
;
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
)
;
nsAutoCString
asciiAppName
;
if
(
appInfo
)
appInfo
-
>
GetName
(
asciiAppName
)
;
nsAutoString
appName
=
NS_ConvertUTF8toUTF16
(
asciiAppName
)
;
static
const
WCHAR
fill
[
]
=
L
"
"
;
EVENT_DATA_DESCRIPTOR
eventData
[
WPC_ARGS_FILEDOWNLOADEVENT_CARGS
]
;
DWORD
dwBlocked
=
blocked
;
EventDataDescCreate
(
&
eventData
[
WPC_ARGS_FILEDOWNLOADEVENT_URL
]
(
const
void
*
)
uri
.
get
(
)
(
(
ULONG
)
uri
.
Length
(
)
+
1
)
*
sizeof
(
WCHAR
)
)
;
EventDataDescCreate
(
&
eventData
[
WPC_ARGS_FILEDOWNLOADEVENT_APPNAME
]
(
const
void
*
)
appName
.
get
(
)
(
(
ULONG
)
appName
.
Length
(
)
+
1
)
*
sizeof
(
WCHAR
)
)
;
EventDataDescCreate
(
&
eventData
[
WPC_ARGS_FILEDOWNLOADEVENT_VERSION
]
(
const
void
*
)
fill
sizeof
(
fill
)
)
;
EventDataDescCreate
(
&
eventData
[
WPC_ARGS_FILEDOWNLOADEVENT_BLOCKED
]
(
const
void
*
)
&
dwBlocked
sizeof
(
dwBlocked
)
)
;
if
(
aTarget
)
{
nsAutoString
path
;
aTarget
-
>
GetPath
(
path
)
;
EventDataDescCreate
(
&
eventData
[
WPC_ARGS_FILEDOWNLOADEVENT_PATH
]
(
const
void
*
)
path
.
get
(
)
(
(
ULONG
)
path
.
Length
(
)
+
1
)
*
sizeof
(
WCHAR
)
)
;
}
else
{
EventDataDescCreate
(
&
eventData
[
WPC_ARGS_FILEDOWNLOADEVENT_PATH
]
(
const
void
*
)
fill
sizeof
(
fill
)
)
;
}
EventWrite
(
mProvider
&
WPCEVENT_WEB_FILEDOWNLOAD
ARRAYSIZE
(
eventData
)
eventData
)
;
}
NS_IMETHODIMP
nsParentalControlsService
:
:
IsAllowed
(
int16_t
aAction
nsIURI
*
aUri
bool
*
_retval
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
