#
include
<
google
/
protobuf
/
util
/
message_differencer
.
h
>
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
functional
>
#
include
<
limits
>
#
include
<
memory
>
#
include
<
utility
>
#
include
<
google
/
protobuf
/
stubs
/
logging
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
common
.
h
>
#
include
<
google
/
protobuf
/
io
/
printer
.
h
>
#
include
<
google
/
protobuf
/
io
/
zero_copy_stream
.
h
>
#
include
<
google
/
protobuf
/
io
/
zero_copy_stream_impl
.
h
>
#
include
<
google
/
protobuf
/
descriptor
.
pb
.
h
>
#
include
<
google
/
protobuf
/
descriptor
.
h
>
#
include
<
google
/
protobuf
/
dynamic_message
.
h
>
#
include
<
google
/
protobuf
/
generated_enum_reflection
.
h
>
#
include
<
google
/
protobuf
/
map_field
.
h
>
#
include
<
google
/
protobuf
/
message
.
h
>
#
include
<
google
/
protobuf
/
text_format
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
strutil
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
stringprintf
.
h
>
#
include
<
google
/
protobuf
/
util
/
field_comparator
.
h
>
#
include
<
google
/
protobuf
/
port_def
.
inc
>
namespace
google
{
namespace
protobuf
{
namespace
util
{
namespace
{
std
:
:
string
PrintShortTextFormat
(
const
google
:
:
protobuf
:
:
Message
&
message
)
{
std
:
:
string
debug_string
;
google
:
:
protobuf
:
:
TextFormat
:
:
Printer
printer
;
printer
.
SetSingleLineMode
(
true
)
;
printer
.
SetExpandAny
(
true
)
;
printer
.
PrintToString
(
message
&
debug_string
)
;
if
(
!
debug_string
.
empty
(
)
&
&
debug_string
[
debug_string
.
size
(
)
-
1
]
=
=
'
'
)
{
debug_string
.
resize
(
debug_string
.
size
(
)
-
1
)
;
}
return
debug_string
;
}
}
class
NumDiffsReporter
:
public
google
:
:
protobuf
:
:
util
:
:
MessageDifferencer
:
:
Reporter
{
public
:
NumDiffsReporter
(
)
:
num_diffs_
(
0
)
{
}
int32_t
GetNumDiffs
(
)
const
{
return
num_diffs_
;
}
void
Reset
(
)
{
num_diffs_
=
0
;
}
void
ReportAdded
(
const
google
:
:
protobuf
:
:
Message
&
const
google
:
:
protobuf
:
:
Message
&
const
std
:
:
vector
<
google
:
:
protobuf
:
:
util
:
:
MessageDifferencer
:
:
SpecificField
>
&
)
override
{
+
+
num_diffs_
;
}
void
ReportDeleted
(
const
google
:
:
protobuf
:
:
Message
&
const
google
:
:
protobuf
:
:
Message
&
const
std
:
:
vector
<
google
:
:
protobuf
:
:
util
:
:
MessageDifferencer
:
:
SpecificField
>
&
)
override
{
+
+
num_diffs_
;
}
void
ReportModified
(
const
google
:
:
protobuf
:
:
Message
&
const
google
:
:
protobuf
:
:
Message
&
const
std
:
:
vector
<
google
:
:
protobuf
:
:
util
:
:
MessageDifferencer
:
:
SpecificField
>
&
)
override
{
+
+
num_diffs_
;
}
private
:
int32_t
num_diffs_
;
}
;
class
MessageDifferencer
:
:
MultipleFieldsMapKeyComparator
:
public
MessageDifferencer
:
:
MapKeyComparator
{
public
:
MultipleFieldsMapKeyComparator
(
MessageDifferencer
*
message_differencer
const
std
:
:
vector
<
std
:
:
vector
<
const
FieldDescriptor
*
>
>
&
key_field_paths
)
:
message_differencer_
(
message_differencer
)
key_field_paths_
(
key_field_paths
)
{
GOOGLE_CHECK
(
!
key_field_paths_
.
empty
(
)
)
;
for
(
const
auto
&
path
:
key_field_paths_
)
{
GOOGLE_CHECK
(
!
path
.
empty
(
)
)
;
}
}
MultipleFieldsMapKeyComparator
(
MessageDifferencer
*
message_differencer
const
FieldDescriptor
*
key
)
:
message_differencer_
(
message_differencer
)
{
std
:
:
vector
<
const
FieldDescriptor
*
>
key_field_path
;
key_field_path
.
push_back
(
key
)
;
key_field_paths_
.
push_back
(
key_field_path
)
;
}
bool
IsMatch
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
)
const
override
{
for
(
const
auto
&
path
:
key_field_paths_
)
{
if
(
!
IsMatchInternal
(
message1
message2
parent_fields
path
0
)
)
{
return
false
;
}
}
return
true
;
}
private
:
bool
IsMatchInternal
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
key_field_path
int
path_index
)
const
{
const
FieldDescriptor
*
field
=
key_field_path
[
path_index
]
;
std
:
:
vector
<
SpecificField
>
current_parent_fields
(
parent_fields
)
;
if
(
path_index
=
=
static_cast
<
int64_t
>
(
key_field_path
.
size
(
)
-
1
)
)
{
if
(
field
-
>
is_map
(
)
)
{
return
message_differencer_
-
>
CompareMapField
(
message1
message2
field
&
current_parent_fields
)
;
}
else
if
(
field
-
>
is_repeated
(
)
)
{
return
message_differencer_
-
>
CompareRepeatedField
(
message1
message2
field
&
current_parent_fields
)
;
}
else
{
return
message_differencer_
-
>
CompareFieldValueUsingParentFields
(
message1
message2
field
-
1
-
1
&
current_parent_fields
)
;
}
}
else
{
const
Reflection
*
reflection1
=
message1
.
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
.
GetReflection
(
)
;
bool
has_field1
=
reflection1
-
>
HasField
(
message1
field
)
;
bool
has_field2
=
reflection2
-
>
HasField
(
message2
field
)
;
if
(
!
has_field1
&
&
!
has_field2
)
{
return
true
;
}
if
(
has_field1
!
=
has_field2
)
{
return
false
;
}
SpecificField
specific_field
;
specific_field
.
field
=
field
;
current_parent_fields
.
push_back
(
specific_field
)
;
return
IsMatchInternal
(
reflection1
-
>
GetMessage
(
message1
field
)
reflection2
-
>
GetMessage
(
message2
field
)
current_parent_fields
key_field_path
path_index
+
1
)
;
}
}
MessageDifferencer
*
message_differencer_
;
std
:
:
vector
<
std
:
:
vector
<
const
FieldDescriptor
*
>
>
key_field_paths_
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
MultipleFieldsMapKeyComparator
)
;
}
;
void
MatchIndicesPostProcessorForSmartList
(
std
:
:
vector
<
int
>
*
match_list1
std
:
:
vector
<
int
>
*
match_list2
)
{
int
last_matched_index
=
-
1
;
for
(
size_t
i
=
0
;
i
<
match_list1
-
>
size
(
)
;
+
+
i
)
{
if
(
match_list1
-
>
at
(
i
)
<
0
)
{
continue
;
}
if
(
last_matched_index
<
0
|
|
match_list1
-
>
at
(
i
)
>
last_matched_index
)
{
last_matched_index
=
match_list1
-
>
at
(
i
)
;
}
else
{
match_list2
-
>
at
(
match_list1
-
>
at
(
i
)
)
=
-
1
;
match_list1
-
>
at
(
i
)
=
-
1
;
}
}
}
void
AddSpecificIndex
(
google
:
:
protobuf
:
:
util
:
:
MessageDifferencer
:
:
SpecificField
*
specific_field
const
Message
&
message
const
FieldDescriptor
*
field
int
index
)
{
if
(
field
-
>
is_map
(
)
)
{
const
Reflection
*
reflection
=
message
.
GetReflection
(
)
;
specific_field
-
>
map_entry1
=
&
reflection
-
>
GetRepeatedMessage
(
message
field
index
)
;
}
specific_field
-
>
index
=
index
;
}
void
AddSpecificNewIndex
(
google
:
:
protobuf
:
:
util
:
:
MessageDifferencer
:
:
SpecificField
*
specific_field
const
Message
&
message
const
FieldDescriptor
*
field
int
index
)
{
if
(
field
-
>
is_map
(
)
)
{
const
Reflection
*
reflection
=
message
.
GetReflection
(
)
;
specific_field
-
>
map_entry2
=
&
reflection
-
>
GetRepeatedMessage
(
message
field
index
)
;
}
specific_field
-
>
new_index
=
index
;
}
MessageDifferencer
:
:
MapEntryKeyComparator
:
:
MapEntryKeyComparator
(
MessageDifferencer
*
message_differencer
)
:
message_differencer_
(
message_differencer
)
{
}
bool
MessageDifferencer
:
:
MapEntryKeyComparator
:
:
IsMatch
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
)
const
{
const
FieldDescriptor
*
key
=
message1
.
GetDescriptor
(
)
-
>
FindFieldByNumber
(
1
)
;
const
bool
treat_as_set
=
(
message_differencer_
-
>
scope
(
)
=
=
PARTIAL
&
&
!
message1
.
GetReflection
(
)
-
>
HasField
(
message1
key
)
)
|
|
message_differencer_
-
>
IsIgnored
(
message1
message2
key
parent_fields
)
;
std
:
:
vector
<
SpecificField
>
current_parent_fields
(
parent_fields
)
;
if
(
treat_as_set
)
{
return
message_differencer_
-
>
Compare
(
message1
message2
&
current_parent_fields
)
;
}
return
message_differencer_
-
>
CompareFieldValueUsingParentFields
(
message1
message2
key
-
1
-
1
&
current_parent_fields
)
;
}
bool
MessageDifferencer
:
:
Equals
(
const
Message
&
message1
const
Message
&
message2
)
{
MessageDifferencer
differencer
;
return
differencer
.
Compare
(
message1
message2
)
;
}
bool
MessageDifferencer
:
:
Equivalent
(
const
Message
&
message1
const
Message
&
message2
)
{
MessageDifferencer
differencer
;
differencer
.
set_message_field_comparison
(
MessageDifferencer
:
:
EQUIVALENT
)
;
return
differencer
.
Compare
(
message1
message2
)
;
}
bool
MessageDifferencer
:
:
ApproximatelyEquals
(
const
Message
&
message1
const
Message
&
message2
)
{
MessageDifferencer
differencer
;
differencer
.
set_float_comparison
(
MessageDifferencer
:
:
APPROXIMATE
)
;
return
differencer
.
Compare
(
message1
message2
)
;
}
bool
MessageDifferencer
:
:
ApproximatelyEquivalent
(
const
Message
&
message1
const
Message
&
message2
)
{
MessageDifferencer
differencer
;
differencer
.
set_message_field_comparison
(
MessageDifferencer
:
:
EQUIVALENT
)
;
differencer
.
set_float_comparison
(
MessageDifferencer
:
:
APPROXIMATE
)
;
return
differencer
.
Compare
(
message1
message2
)
;
}
MessageDifferencer
:
:
MessageDifferencer
(
)
:
reporter_
(
NULL
)
message_field_comparison_
(
EQUAL
)
scope_
(
FULL
)
repeated_field_comparison_
(
AS_LIST
)
map_entry_key_comparator_
(
this
)
report_matches_
(
false
)
report_moves_
(
true
)
report_ignores_
(
true
)
output_string_
(
nullptr
)
match_indices_for_smart_list_callback_
(
MatchIndicesPostProcessorForSmartList
)
{
}
MessageDifferencer
:
:
~
MessageDifferencer
(
)
{
for
(
MapKeyComparator
*
comparator
:
owned_key_comparators_
)
{
delete
comparator
;
}
for
(
IgnoreCriteria
*
criteria
:
ignore_criteria_
)
{
delete
criteria
;
}
}
void
MessageDifferencer
:
:
set_field_comparator
(
FieldComparator
*
comparator
)
{
GOOGLE_CHECK
(
comparator
)
<
<
"
Field
comparator
can
'
t
be
NULL
.
"
;
field_comparator_kind_
=
kFCBase
;
field_comparator_
.
base
=
comparator
;
}
#
ifdef
PROTOBUF_FUTURE_BREAKING_CHANGES
void
MessageDifferencer
:
:
set_field_comparator
(
DefaultFieldComparator
*
comparator
)
{
GOOGLE_CHECK
(
comparator
)
<
<
"
Field
comparator
can
'
t
be
NULL
.
"
;
field_comparator_kind_
=
kFCDefault
;
field_comparator_
.
default_impl
=
comparator
;
}
#
endif
void
MessageDifferencer
:
:
set_message_field_comparison
(
MessageFieldComparison
comparison
)
{
message_field_comparison_
=
comparison
;
}
MessageDifferencer
:
:
MessageFieldComparison
MessageDifferencer
:
:
message_field_comparison
(
)
const
{
return
message_field_comparison_
;
}
void
MessageDifferencer
:
:
set_scope
(
Scope
scope
)
{
scope_
=
scope
;
}
MessageDifferencer
:
:
Scope
MessageDifferencer
:
:
scope
(
)
const
{
return
scope_
;
}
void
MessageDifferencer
:
:
set_float_comparison
(
FloatComparison
comparison
)
{
default_field_comparator_
.
set_float_comparison
(
comparison
=
=
EXACT
?
DefaultFieldComparator
:
:
EXACT
:
DefaultFieldComparator
:
:
APPROXIMATE
)
;
}
void
MessageDifferencer
:
:
set_repeated_field_comparison
(
RepeatedFieldComparison
comparison
)
{
repeated_field_comparison_
=
comparison
;
}
MessageDifferencer
:
:
RepeatedFieldComparison
MessageDifferencer
:
:
repeated_field_comparison
(
)
const
{
return
repeated_field_comparison_
;
}
void
MessageDifferencer
:
:
CheckRepeatedFieldComparisons
(
const
FieldDescriptor
*
field
const
RepeatedFieldComparison
&
new_comparison
)
{
GOOGLE_CHECK
(
field
-
>
is_repeated
(
)
)
<
<
"
Field
must
be
repeated
:
"
<
<
field
-
>
full_name
(
)
;
const
MapKeyComparator
*
key_comparator
=
GetMapKeyComparator
(
field
)
;
GOOGLE_CHECK
(
key_comparator
=
=
NULL
)
<
<
"
Cannot
treat
this
repeated
field
as
both
MAP
and
"
<
<
new_comparison
<
<
"
for
comparison
.
Field
name
is
:
"
<
<
field
-
>
full_name
(
)
;
}
void
MessageDifferencer
:
:
TreatAsSet
(
const
FieldDescriptor
*
field
)
{
CheckRepeatedFieldComparisons
(
field
AS_SET
)
;
repeated_field_comparisons_
[
field
]
=
AS_SET
;
}
void
MessageDifferencer
:
:
TreatAsSmartSet
(
const
FieldDescriptor
*
field
)
{
CheckRepeatedFieldComparisons
(
field
AS_SMART_SET
)
;
repeated_field_comparisons_
[
field
]
=
AS_SMART_SET
;
}
void
MessageDifferencer
:
:
SetMatchIndicesForSmartListCallback
(
std
:
:
function
<
void
(
std
:
:
vector
<
int
>
*
std
:
:
vector
<
int
>
*
)
>
callback
)
{
match_indices_for_smart_list_callback_
=
callback
;
}
void
MessageDifferencer
:
:
TreatAsList
(
const
FieldDescriptor
*
field
)
{
CheckRepeatedFieldComparisons
(
field
AS_LIST
)
;
repeated_field_comparisons_
[
field
]
=
AS_LIST
;
}
void
MessageDifferencer
:
:
TreatAsSmartList
(
const
FieldDescriptor
*
field
)
{
CheckRepeatedFieldComparisons
(
field
AS_SMART_LIST
)
;
repeated_field_comparisons_
[
field
]
=
AS_SMART_LIST
;
}
void
MessageDifferencer
:
:
TreatAsMap
(
const
FieldDescriptor
*
field
const
FieldDescriptor
*
key
)
{
GOOGLE_CHECK_EQ
(
FieldDescriptor
:
:
CPPTYPE_MESSAGE
field
-
>
cpp_type
(
)
)
<
<
"
Field
has
to
be
message
type
.
Field
name
is
:
"
<
<
field
-
>
full_name
(
)
;
GOOGLE_CHECK
(
key
-
>
containing_type
(
)
=
=
field
-
>
message_type
(
)
)
<
<
key
-
>
full_name
(
)
<
<
"
must
be
a
direct
subfield
within
the
repeated
field
"
<
<
field
-
>
full_name
(
)
<
<
"
not
"
<
<
key
-
>
containing_type
(
)
-
>
full_name
(
)
;
GOOGLE_CHECK
(
repeated_field_comparisons_
.
find
(
field
)
=
=
repeated_field_comparisons_
.
end
(
)
)
<
<
"
Cannot
treat
the
same
field
as
both
"
<
<
repeated_field_comparisons_
[
field
]
<
<
"
and
MAP
.
Field
name
is
:
"
<
<
field
-
>
full_name
(
)
;
MapKeyComparator
*
key_comparator
=
new
MultipleFieldsMapKeyComparator
(
this
key
)
;
owned_key_comparators_
.
push_back
(
key_comparator
)
;
map_field_key_comparator_
[
field
]
=
key_comparator
;
}
void
MessageDifferencer
:
:
TreatAsMapWithMultipleFieldsAsKey
(
const
FieldDescriptor
*
field
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
key_fields
)
{
std
:
:
vector
<
std
:
:
vector
<
const
FieldDescriptor
*
>
>
key_field_paths
;
for
(
const
FieldDescriptor
*
key_filed
:
key_fields
)
{
std
:
:
vector
<
const
FieldDescriptor
*
>
key_field_path
;
key_field_path
.
push_back
(
key_filed
)
;
key_field_paths
.
push_back
(
key_field_path
)
;
}
TreatAsMapWithMultipleFieldPathsAsKey
(
field
key_field_paths
)
;
}
void
MessageDifferencer
:
:
TreatAsMapWithMultipleFieldPathsAsKey
(
const
FieldDescriptor
*
field
const
std
:
:
vector
<
std
:
:
vector
<
const
FieldDescriptor
*
>
>
&
key_field_paths
)
{
GOOGLE_CHECK
(
field
-
>
is_repeated
(
)
)
<
<
"
Field
must
be
repeated
:
"
<
<
field
-
>
full_name
(
)
;
GOOGLE_CHECK_EQ
(
FieldDescriptor
:
:
CPPTYPE_MESSAGE
field
-
>
cpp_type
(
)
)
<
<
"
Field
has
to
be
message
type
.
Field
name
is
:
"
<
<
field
-
>
full_name
(
)
;
for
(
const
auto
&
key_field_path
:
key_field_paths
)
{
for
(
size_t
j
=
0
;
j
<
key_field_path
.
size
(
)
;
+
+
j
)
{
const
FieldDescriptor
*
parent_field
=
j
=
=
0
?
field
:
key_field_path
[
j
-
1
]
;
const
FieldDescriptor
*
child_field
=
key_field_path
[
j
]
;
GOOGLE_CHECK
(
child_field
-
>
containing_type
(
)
=
=
parent_field
-
>
message_type
(
)
)
<
<
child_field
-
>
full_name
(
)
<
<
"
must
be
a
direct
subfield
within
the
field
:
"
<
<
parent_field
-
>
full_name
(
)
;
if
(
j
!
=
0
)
{
GOOGLE_CHECK_EQ
(
FieldDescriptor
:
:
CPPTYPE_MESSAGE
parent_field
-
>
cpp_type
(
)
)
<
<
parent_field
-
>
full_name
(
)
<
<
"
has
to
be
of
type
message
.
"
;
GOOGLE_CHECK
(
!
parent_field
-
>
is_repeated
(
)
)
<
<
parent_field
-
>
full_name
(
)
<
<
"
cannot
be
a
repeated
field
.
"
;
}
}
}
GOOGLE_CHECK
(
repeated_field_comparisons_
.
find
(
field
)
=
=
repeated_field_comparisons_
.
end
(
)
)
<
<
"
Cannot
treat
the
same
field
as
both
"
<
<
repeated_field_comparisons_
[
field
]
<
<
"
and
MAP
.
Field
name
is
:
"
<
<
field
-
>
full_name
(
)
;
MapKeyComparator
*
key_comparator
=
new
MultipleFieldsMapKeyComparator
(
this
key_field_paths
)
;
owned_key_comparators_
.
push_back
(
key_comparator
)
;
map_field_key_comparator_
[
field
]
=
key_comparator
;
}
void
MessageDifferencer
:
:
TreatAsMapUsingKeyComparator
(
const
FieldDescriptor
*
field
const
MapKeyComparator
*
key_comparator
)
{
GOOGLE_CHECK
(
field
-
>
is_repeated
(
)
)
<
<
"
Field
must
be
repeated
:
"
<
<
field
-
>
full_name
(
)
;
GOOGLE_CHECK
(
repeated_field_comparisons_
.
find
(
field
)
=
=
repeated_field_comparisons_
.
end
(
)
)
<
<
"
Cannot
treat
the
same
field
as
both
"
<
<
repeated_field_comparisons_
[
field
]
<
<
"
and
MAP
.
Field
name
is
:
"
<
<
field
-
>
full_name
(
)
;
map_field_key_comparator_
[
field
]
=
key_comparator
;
}
void
MessageDifferencer
:
:
AddIgnoreCriteria
(
IgnoreCriteria
*
ignore_criteria
)
{
ignore_criteria_
.
push_back
(
ignore_criteria
)
;
}
void
MessageDifferencer
:
:
IgnoreField
(
const
FieldDescriptor
*
field
)
{
ignored_fields_
.
insert
(
field
)
;
}
void
MessageDifferencer
:
:
SetFractionAndMargin
(
const
FieldDescriptor
*
field
double
fraction
double
margin
)
{
default_field_comparator_
.
SetFractionAndMargin
(
field
fraction
margin
)
;
}
void
MessageDifferencer
:
:
ReportDifferencesToString
(
std
:
:
string
*
output
)
{
GOOGLE_DCHECK
(
output
)
<
<
"
Specified
output
string
was
NULL
"
;
output_string_
=
output
;
output_string_
-
>
clear
(
)
;
}
void
MessageDifferencer
:
:
ReportDifferencesTo
(
Reporter
*
reporter
)
{
if
(
output_string_
)
{
output_string_
=
NULL
;
}
reporter_
=
reporter
;
}
bool
MessageDifferencer
:
:
FieldBefore
(
const
FieldDescriptor
*
field1
const
FieldDescriptor
*
field2
)
{
if
(
field1
=
=
NULL
)
{
return
false
;
}
if
(
field2
=
=
NULL
)
{
return
true
;
}
return
(
field1
-
>
number
(
)
<
field2
-
>
number
(
)
)
;
}
bool
MessageDifferencer
:
:
Compare
(
const
Message
&
message1
const
Message
&
message2
)
{
std
:
:
vector
<
SpecificField
>
parent_fields
;
bool
result
=
false
;
if
(
output_string_
)
{
io
:
:
StringOutputStream
output_stream
(
output_string_
)
;
StreamReporter
reporter
(
&
output_stream
)
;
reporter
.
SetMessages
(
message1
message2
)
;
reporter_
=
&
reporter
;
result
=
Compare
(
message1
message2
&
parent_fields
)
;
reporter_
=
NULL
;
}
else
{
result
=
Compare
(
message1
message2
&
parent_fields
)
;
}
return
result
;
}
bool
MessageDifferencer
:
:
CompareWithFields
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
message1_fields_arg
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
message2_fields_arg
)
{
if
(
message1
.
GetDescriptor
(
)
!
=
message2
.
GetDescriptor
(
)
)
{
GOOGLE_LOG
(
DFATAL
)
<
<
"
Comparison
between
two
messages
with
different
"
<
<
"
descriptors
.
"
;
return
false
;
}
std
:
:
vector
<
SpecificField
>
parent_fields
;
bool
result
=
false
;
FieldDescriptorArray
message1_fields
(
message1_fields_arg
.
size
(
)
+
1
)
;
FieldDescriptorArray
message2_fields
(
message2_fields_arg
.
size
(
)
+
1
)
;
std
:
:
copy
(
message1_fields_arg
.
cbegin
(
)
message1_fields_arg
.
cend
(
)
message1_fields
.
begin
(
)
)
;
std
:
:
copy
(
message2_fields_arg
.
cbegin
(
)
message2_fields_arg
.
cend
(
)
message2_fields
.
begin
(
)
)
;
message1_fields
[
message1_fields_arg
.
size
(
)
]
=
nullptr
;
message2_fields
[
message2_fields_arg
.
size
(
)
]
=
nullptr
;
std
:
:
sort
(
message1_fields
.
begin
(
)
message1_fields
.
end
(
)
FieldBefore
)
;
std
:
:
sort
(
message2_fields
.
begin
(
)
message2_fields
.
end
(
)
FieldBefore
)
;
if
(
output_string_
)
{
io
:
:
StringOutputStream
output_stream
(
output_string_
)
;
StreamReporter
reporter
(
&
output_stream
)
;
reporter_
=
&
reporter
;
result
=
CompareRequestedFieldsUsingSettings
(
message1
message2
message1_fields
message2_fields
&
parent_fields
)
;
reporter_
=
NULL
;
}
else
{
result
=
CompareRequestedFieldsUsingSettings
(
message1
message2
message1_fields
message2_fields
&
parent_fields
)
;
}
return
result
;
}
bool
MessageDifferencer
:
:
Compare
(
const
Message
&
message1
const
Message
&
message2
std
:
:
vector
<
SpecificField
>
*
parent_fields
)
{
const
Descriptor
*
descriptor1
=
message1
.
GetDescriptor
(
)
;
const
Descriptor
*
descriptor2
=
message2
.
GetDescriptor
(
)
;
if
(
descriptor1
!
=
descriptor2
)
{
GOOGLE_LOG
(
DFATAL
)
<
<
"
Comparison
between
two
messages
with
different
"
<
<
"
descriptors
.
"
<
<
descriptor1
-
>
full_name
(
)
<
<
"
vs
"
<
<
descriptor2
-
>
full_name
(
)
;
return
false
;
}
if
(
descriptor1
-
>
full_name
(
)
=
=
internal
:
:
kAnyFullTypeName
)
{
std
:
:
unique_ptr
<
Message
>
data1
;
std
:
:
unique_ptr
<
Message
>
data2
;
if
(
unpack_any_field_
.
UnpackAny
(
message1
&
data1
)
&
&
unpack_any_field_
.
UnpackAny
(
message2
&
data2
)
)
{
if
(
data1
-
>
GetDescriptor
(
)
!
=
data2
-
>
GetDescriptor
(
)
)
{
return
false
;
}
return
Compare
(
*
data1
*
data2
parent_fields
)
;
}
}
const
Reflection
*
reflection1
=
message1
.
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
.
GetReflection
(
)
;
bool
unknown_compare_result
=
true
;
if
(
message_field_comparison_
!
=
EQUIVALENT
)
{
const
UnknownFieldSet
&
unknown_field_set1
=
reflection1
-
>
GetUnknownFields
(
message1
)
;
const
UnknownFieldSet
&
unknown_field_set2
=
reflection2
-
>
GetUnknownFields
(
message2
)
;
if
(
!
CompareUnknownFields
(
message1
message2
unknown_field_set1
unknown_field_set2
parent_fields
)
)
{
if
(
reporter_
=
=
NULL
)
{
return
false
;
}
unknown_compare_result
=
false
;
}
}
FieldDescriptorArray
message1_fields
=
RetrieveFields
(
message1
true
)
;
FieldDescriptorArray
message2_fields
=
RetrieveFields
(
message2
false
)
;
return
CompareRequestedFieldsUsingSettings
(
message1
message2
message1_fields
message2_fields
parent_fields
)
&
&
unknown_compare_result
;
}
FieldDescriptorArray
MessageDifferencer
:
:
RetrieveFields
(
const
Message
&
message
bool
base_message
)
{
const
Descriptor
*
descriptor
=
message
.
GetDescriptor
(
)
;
tmp_message_fields_
.
clear
(
)
;
tmp_message_fields_
.
reserve
(
descriptor
-
>
field_count
(
)
+
1
)
;
const
Reflection
*
reflection
=
message
.
GetReflection
(
)
;
if
(
descriptor
-
>
options
(
)
.
map_entry
(
)
)
{
if
(
this
-
>
scope_
=
=
PARTIAL
&
&
base_message
)
{
reflection
-
>
ListFields
(
message
&
tmp_message_fields_
)
;
}
else
{
for
(
int
i
=
0
;
i
<
descriptor
-
>
field_count
(
)
;
i
+
+
)
{
tmp_message_fields_
.
push_back
(
descriptor
-
>
field
(
i
)
)
;
}
}
}
else
{
reflection
-
>
ListFields
(
message
&
tmp_message_fields_
)
;
}
tmp_message_fields_
.
push_back
(
nullptr
)
;
FieldDescriptorArray
message_fields
(
tmp_message_fields_
.
begin
(
)
tmp_message_fields_
.
end
(
)
)
;
return
message_fields
;
}
bool
MessageDifferencer
:
:
CompareRequestedFieldsUsingSettings
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptorArray
&
message1_fields
const
FieldDescriptorArray
&
message2_fields
std
:
:
vector
<
SpecificField
>
*
parent_fields
)
{
if
(
scope_
=
=
FULL
)
{
if
(
message_field_comparison_
=
=
EQUIVALENT
)
{
FieldDescriptorArray
fields_union
=
CombineFields
(
message1_fields
FULL
message2_fields
FULL
)
;
return
CompareWithFieldsInternal
(
message1
message2
fields_union
fields_union
parent_fields
)
;
}
else
{
return
CompareWithFieldsInternal
(
message1
message2
message1_fields
message2_fields
parent_fields
)
;
}
}
else
{
if
(
message_field_comparison_
=
=
EQUIVALENT
)
{
return
CompareWithFieldsInternal
(
message1
message2
message1_fields
message1_fields
parent_fields
)
;
}
else
{
FieldDescriptorArray
fields_intersection
=
CombineFields
(
message1_fields
PARTIAL
message2_fields
PARTIAL
)
;
return
CompareWithFieldsInternal
(
message1
message2
message1_fields
fields_intersection
parent_fields
)
;
}
}
}
FieldDescriptorArray
MessageDifferencer
:
:
CombineFields
(
const
FieldDescriptorArray
&
fields1
Scope
fields1_scope
const
FieldDescriptorArray
&
fields2
Scope
fields2_scope
)
{
size_t
index1
=
0
;
size_t
index2
=
0
;
tmp_message_fields_
.
clear
(
)
;
while
(
index1
<
fields1
.
size
(
)
&
&
index2
<
fields2
.
size
(
)
)
{
const
FieldDescriptor
*
field1
=
fields1
[
index1
]
;
const
FieldDescriptor
*
field2
=
fields2
[
index2
]
;
if
(
FieldBefore
(
field1
field2
)
)
{
if
(
fields1_scope
=
=
FULL
)
{
tmp_message_fields_
.
push_back
(
fields1
[
index1
]
)
;
}
+
+
index1
;
}
else
if
(
FieldBefore
(
field2
field1
)
)
{
if
(
fields2_scope
=
=
FULL
)
{
tmp_message_fields_
.
push_back
(
fields2
[
index2
]
)
;
}
+
+
index2
;
}
else
{
tmp_message_fields_
.
push_back
(
fields1
[
index1
]
)
;
+
+
index1
;
+
+
index2
;
}
}
tmp_message_fields_
.
push_back
(
nullptr
)
;
FieldDescriptorArray
combined_fields
(
tmp_message_fields_
.
begin
(
)
tmp_message_fields_
.
end
(
)
)
;
return
combined_fields
;
}
bool
MessageDifferencer
:
:
CompareWithFieldsInternal
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptorArray
&
message1_fields
const
FieldDescriptorArray
&
message2_fields
std
:
:
vector
<
SpecificField
>
*
parent_fields
)
{
bool
isDifferent
=
false
;
int
field_index1
=
0
;
int
field_index2
=
0
;
const
Reflection
*
reflection1
=
message1
.
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
.
GetReflection
(
)
;
while
(
true
)
{
const
FieldDescriptor
*
field1
=
message1_fields
[
field_index1
]
;
const
FieldDescriptor
*
field2
=
message2_fields
[
field_index2
]
;
if
(
field1
=
=
NULL
&
&
field2
=
=
NULL
)
{
break
;
}
if
(
FieldBefore
(
field1
field2
)
)
{
if
(
IsIgnored
(
message1
message2
field1
*
parent_fields
)
)
{
if
(
reporter_
!
=
NULL
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field1
;
parent_fields
-
>
push_back
(
specific_field
)
;
if
(
report_ignores_
)
{
reporter_
-
>
ReportIgnored
(
message1
message2
*
parent_fields
)
;
}
parent_fields
-
>
pop_back
(
)
;
}
+
+
field_index1
;
continue
;
}
if
(
reporter_
!
=
NULL
)
{
assert
(
field1
!
=
NULL
)
;
int
count
=
field1
-
>
is_repeated
(
)
?
reflection1
-
>
FieldSize
(
message1
field1
)
:
1
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field1
;
if
(
field1
-
>
is_repeated
(
)
)
{
AddSpecificIndex
(
&
specific_field
message1
field1
i
)
;
}
else
{
specific_field
.
index
=
-
1
;
}
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportDeleted
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
}
isDifferent
=
true
;
}
else
{
return
false
;
}
+
+
field_index1
;
continue
;
}
else
if
(
FieldBefore
(
field2
field1
)
)
{
if
(
IsIgnored
(
message1
message2
field2
*
parent_fields
)
)
{
if
(
reporter_
!
=
NULL
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field2
;
parent_fields
-
>
push_back
(
specific_field
)
;
if
(
report_ignores_
)
{
reporter_
-
>
ReportIgnored
(
message1
message2
*
parent_fields
)
;
}
parent_fields
-
>
pop_back
(
)
;
}
+
+
field_index2
;
continue
;
}
if
(
reporter_
!
=
NULL
)
{
int
count
=
field2
-
>
is_repeated
(
)
?
reflection2
-
>
FieldSize
(
message2
field2
)
:
1
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field2
;
if
(
field2
-
>
is_repeated
(
)
)
{
specific_field
.
index
=
i
;
AddSpecificNewIndex
(
&
specific_field
message2
field2
i
)
;
}
else
{
specific_field
.
index
=
-
1
;
specific_field
.
new_index
=
-
1
;
}
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportAdded
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
}
isDifferent
=
true
;
}
else
{
return
false
;
}
+
+
field_index2
;
continue
;
}
if
(
IsIgnored
(
message1
message2
field1
*
parent_fields
)
)
{
if
(
reporter_
!
=
NULL
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field1
;
parent_fields
-
>
push_back
(
specific_field
)
;
if
(
report_ignores_
)
{
reporter_
-
>
ReportIgnored
(
message1
message2
*
parent_fields
)
;
}
parent_fields
-
>
pop_back
(
)
;
}
+
+
field_index1
;
+
+
field_index2
;
continue
;
}
bool
fieldDifferent
=
false
;
assert
(
field1
!
=
NULL
)
;
if
(
field1
-
>
is_map
(
)
)
{
fieldDifferent
=
!
CompareMapField
(
message1
message2
field1
parent_fields
)
;
}
else
if
(
field1
-
>
is_repeated
(
)
)
{
fieldDifferent
=
!
CompareRepeatedField
(
message1
message2
field1
parent_fields
)
;
}
else
{
fieldDifferent
=
!
CompareFieldValueUsingParentFields
(
message1
message2
field1
-
1
-
1
parent_fields
)
;
if
(
reporter_
!
=
nullptr
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field1
;
parent_fields
-
>
push_back
(
specific_field
)
;
if
(
fieldDifferent
)
{
reporter_
-
>
ReportModified
(
message1
message2
*
parent_fields
)
;
isDifferent
=
true
;
}
else
if
(
report_matches_
)
{
reporter_
-
>
ReportMatched
(
message1
message2
*
parent_fields
)
;
}
parent_fields
-
>
pop_back
(
)
;
}
}
if
(
fieldDifferent
)
{
if
(
reporter_
=
=
nullptr
)
return
false
;
isDifferent
=
true
;
}
+
+
field_index1
;
+
+
field_index2
;
}
return
!
isDifferent
;
}
bool
MessageDifferencer
:
:
IsMatch
(
const
FieldDescriptor
*
repeated_field
const
MapKeyComparator
*
key_comparator
const
Message
*
message1
const
Message
*
message2
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
Reporter
*
reporter
int
index1
int
index2
)
{
std
:
:
vector
<
SpecificField
>
current_parent_fields
(
parent_fields
)
;
if
(
repeated_field
-
>
cpp_type
(
)
!
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
return
CompareFieldValueUsingParentFields
(
*
message1
*
message2
repeated_field
index1
index2
&
current_parent_fields
)
;
}
Reporter
*
backup_reporter
=
reporter_
;
std
:
:
string
*
output_string
=
output_string_
;
reporter_
=
reporter
;
output_string_
=
NULL
;
bool
match
;
if
(
key_comparator
=
=
NULL
)
{
match
=
CompareFieldValueUsingParentFields
(
*
message1
*
message2
repeated_field
index1
index2
&
current_parent_fields
)
;
}
else
{
const
Reflection
*
reflection1
=
message1
-
>
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
-
>
GetReflection
(
)
;
const
Message
&
m1
=
reflection1
-
>
GetRepeatedMessage
(
*
message1
repeated_field
index1
)
;
const
Message
&
m2
=
reflection2
-
>
GetRepeatedMessage
(
*
message2
repeated_field
index2
)
;
SpecificField
specific_field
;
specific_field
.
field
=
repeated_field
;
if
(
repeated_field
-
>
is_map
(
)
)
{
specific_field
.
map_entry1
=
&
m1
;
specific_field
.
map_entry2
=
&
m2
;
}
specific_field
.
index
=
index1
;
specific_field
.
new_index
=
index2
;
current_parent_fields
.
push_back
(
specific_field
)
;
match
=
key_comparator
-
>
IsMatch
(
m1
m2
current_parent_fields
)
;
}
reporter_
=
backup_reporter
;
output_string_
=
output_string
;
return
match
;
}
bool
MessageDifferencer
:
:
CompareMapFieldByMapReflection
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
map_field
std
:
:
vector
<
SpecificField
>
*
parent_fields
DefaultFieldComparator
*
comparator
)
{
GOOGLE_DCHECK_EQ
(
nullptr
reporter_
)
;
GOOGLE_DCHECK
(
map_field
-
>
is_map
(
)
)
;
GOOGLE_DCHECK
(
map_field_key_comparator_
.
find
(
map_field
)
=
=
map_field_key_comparator_
.
end
(
)
)
;
GOOGLE_DCHECK_EQ
(
repeated_field_comparison_
AS_LIST
)
;
const
Reflection
*
reflection1
=
message1
.
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
.
GetReflection
(
)
;
const
int
count1
=
reflection1
-
>
MapSize
(
message1
map_field
)
;
const
int
count2
=
reflection2
-
>
MapSize
(
message2
map_field
)
;
const
bool
treated_as_subset
=
IsTreatedAsSubset
(
map_field
)
;
if
(
count1
!
=
count2
&
&
!
treated_as_subset
)
{
return
false
;
}
if
(
count1
>
count2
)
{
return
false
;
}
for
(
MapIterator
it
=
reflection1
-
>
MapBegin
(
const_cast
<
Message
*
>
(
&
message1
)
map_field
)
it_end
=
reflection1
-
>
MapEnd
(
const_cast
<
Message
*
>
(
&
message1
)
map_field
)
;
it
!
=
it_end
;
+
+
it
)
{
if
(
!
reflection2
-
>
ContainsMapKey
(
message2
map_field
it
.
GetKey
(
)
)
)
{
return
false
;
}
}
const
FieldDescriptor
*
val_des
=
map_field
-
>
message_type
(
)
-
>
map_value
(
)
;
switch
(
val_des
-
>
cpp_type
(
)
)
{
#
define
HANDLE_TYPE
(
CPPTYPE
METHOD
COMPAREMETHOD
)
\
case
FieldDescriptor
:
:
CPPTYPE_
#
#
CPPTYPE
:
{
\
for
(
MapIterator
it
=
reflection1
-
>
MapBegin
(
\
const_cast
<
Message
*
>
(
&
message1
)
map_field
)
\
it_end
=
reflection1
-
>
MapEnd
(
\
const_cast
<
Message
*
>
(
&
message1
)
map_field
)
;
\
it
!
=
it_end
;
+
+
it
)
{
\
MapValueConstRef
value2
;
\
reflection2
-
>
LookupMapValue
(
message2
map_field
it
.
GetKey
(
)
&
value2
)
;
\
if
(
!
comparator
-
>
Compare
#
#
COMPAREMETHOD
(
*
val_des
\
it
.
GetValueRef
(
)
.
Get
#
#
METHOD
(
)
\
value2
.
Get
#
#
METHOD
(
)
)
)
{
\
return
false
;
\
}
\
}
\
break
;
\
}
HANDLE_TYPE
(
INT32
Int32Value
Int32
)
;
HANDLE_TYPE
(
INT64
Int64Value
Int64
)
;
HANDLE_TYPE
(
UINT32
UInt32Value
UInt32
)
;
HANDLE_TYPE
(
UINT64
UInt64Value
UInt64
)
;
HANDLE_TYPE
(
DOUBLE
DoubleValue
Double
)
;
HANDLE_TYPE
(
FLOAT
FloatValue
Float
)
;
HANDLE_TYPE
(
BOOL
BoolValue
Bool
)
;
HANDLE_TYPE
(
STRING
StringValue
String
)
;
HANDLE_TYPE
(
ENUM
EnumValue
Int32
)
;
#
undef
HANDLE_TYPE
case
FieldDescriptor
:
:
CPPTYPE_MESSAGE
:
{
for
(
MapIterator
it
=
reflection1
-
>
MapBegin
(
const_cast
<
Message
*
>
(
&
message1
)
map_field
)
;
it
!
=
reflection1
-
>
MapEnd
(
const_cast
<
Message
*
>
(
&
message1
)
map_field
)
;
+
+
it
)
{
if
(
!
reflection2
-
>
ContainsMapKey
(
message2
map_field
it
.
GetKey
(
)
)
)
{
return
false
;
}
bool
compare_result
;
MapValueConstRef
value2
;
reflection2
-
>
LookupMapValue
(
message2
map_field
it
.
GetKey
(
)
&
value2
)
;
SpecificField
specific_value_field
;
specific_value_field
.
field
=
val_des
;
parent_fields
-
>
push_back
(
specific_value_field
)
;
compare_result
=
Compare
(
it
.
GetValueRef
(
)
.
GetMessageValue
(
)
value2
.
GetMessageValue
(
)
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
if
(
!
compare_result
)
{
return
false
;
}
}
break
;
}
}
return
true
;
}
bool
MessageDifferencer
:
:
CompareMapField
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
repeated_field
std
:
:
vector
<
SpecificField
>
*
parent_fields
)
{
GOOGLE_DCHECK
(
repeated_field
-
>
is_map
(
)
)
;
const
Reflection
*
reflection1
=
message1
.
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
.
GetReflection
(
)
;
if
(
reflection1
-
>
GetMapData
(
message1
repeated_field
)
-
>
IsMapValid
(
)
&
&
reflection2
-
>
GetMapData
(
message2
repeated_field
)
-
>
IsMapValid
(
)
&
&
reporter_
=
=
nullptr
&
&
map_field_key_comparator_
.
find
(
repeated_field
)
=
=
map_field_key_comparator_
.
end
(
)
&
&
repeated_field_comparison_
=
=
AS_LIST
&
&
field_comparator_kind_
=
=
kFCDefault
)
{
const
FieldDescriptor
*
key_des
=
repeated_field
-
>
message_type
(
)
-
>
map_key
(
)
;
const
FieldDescriptor
*
val_des
=
repeated_field
-
>
message_type
(
)
-
>
map_value
(
)
;
std
:
:
vector
<
SpecificField
>
current_parent_fields
(
*
parent_fields
)
;
SpecificField
specific_field
;
specific_field
.
field
=
repeated_field
;
current_parent_fields
.
push_back
(
specific_field
)
;
if
(
!
IsIgnored
(
message1
message2
key_des
current_parent_fields
)
&
&
!
IsIgnored
(
message1
message2
val_des
current_parent_fields
)
)
{
return
CompareMapFieldByMapReflection
(
message1
message2
repeated_field
&
current_parent_fields
field_comparator_
.
default_impl
)
;
}
}
return
CompareRepeatedRep
(
message1
message2
repeated_field
parent_fields
)
;
}
bool
MessageDifferencer
:
:
CompareRepeatedField
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
repeated_field
std
:
:
vector
<
SpecificField
>
*
parent_fields
)
{
GOOGLE_DCHECK
(
!
repeated_field
-
>
is_map
(
)
)
;
return
CompareRepeatedRep
(
message1
message2
repeated_field
parent_fields
)
;
}
bool
MessageDifferencer
:
:
CompareRepeatedRep
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
repeated_field
std
:
:
vector
<
SpecificField
>
*
parent_fields
)
{
GOOGLE_DCHECK
(
repeated_field
-
>
is_repeated
(
)
)
;
const
Reflection
*
reflection1
=
message1
.
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
.
GetReflection
(
)
;
const
int
count1
=
reflection1
-
>
FieldSize
(
message1
repeated_field
)
;
const
int
count2
=
reflection2
-
>
FieldSize
(
message2
repeated_field
)
;
const
bool
treated_as_subset
=
IsTreatedAsSubset
(
repeated_field
)
;
if
(
count1
!
=
count2
&
&
reporter_
=
=
NULL
&
&
!
treated_as_subset
)
{
return
false
;
}
if
(
count1
>
count2
&
&
reporter_
=
=
NULL
)
{
return
false
;
}
std
:
:
vector
<
int
>
match_list1
;
std
:
:
vector
<
int
>
match_list2
;
const
MapKeyComparator
*
key_comparator
=
GetMapKeyComparator
(
repeated_field
)
;
bool
smart_list
=
IsTreatedAsSmartList
(
repeated_field
)
;
bool
simple_list
=
key_comparator
=
=
nullptr
&
&
!
IsTreatedAsSet
(
repeated_field
)
&
&
!
IsTreatedAsSmartSet
(
repeated_field
)
&
&
!
smart_list
;
if
(
!
simple_list
)
{
if
(
!
MatchRepeatedFieldIndices
(
message1
message2
repeated_field
key_comparator
*
parent_fields
&
match_list1
&
match_list2
)
&
&
reporter_
=
=
nullptr
)
{
return
false
;
}
}
bool
fieldDifferent
=
false
;
SpecificField
specific_field
;
specific_field
.
field
=
repeated_field
;
int
next_unmatched_index
=
0
;
for
(
int
i
=
0
;
i
<
count1
;
i
+
+
)
{
if
(
simple_list
&
&
i
>
=
count2
)
{
break
;
}
if
(
!
simple_list
&
&
match_list1
[
i
]
=
=
-
1
)
{
if
(
smart_list
)
{
if
(
reporter_
=
=
nullptr
)
return
false
;
AddSpecificIndex
(
&
specific_field
message1
repeated_field
i
)
;
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportDeleted
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
fieldDifferent
=
true
;
match_list1
[
i
]
=
-
2
;
}
continue
;
}
if
(
smart_list
)
{
for
(
int
j
=
next_unmatched_index
;
j
<
match_list1
[
i
]
;
+
+
j
)
{
GOOGLE_CHECK_LE
(
0
j
)
;
if
(
reporter_
=
=
nullptr
)
return
false
;
specific_field
.
index
=
j
;
AddSpecificNewIndex
(
&
specific_field
message2
repeated_field
j
)
;
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportAdded
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
fieldDifferent
=
true
;
match_list2
[
j
]
=
-
2
;
}
}
AddSpecificIndex
(
&
specific_field
message1
repeated_field
i
)
;
if
(
simple_list
)
{
AddSpecificNewIndex
(
&
specific_field
message2
repeated_field
i
)
;
}
else
{
AddSpecificNewIndex
(
&
specific_field
message2
repeated_field
match_list1
[
i
]
)
;
next_unmatched_index
=
match_list1
[
i
]
+
1
;
}
const
bool
result
=
CompareFieldValueUsingParentFields
(
message1
message2
repeated_field
i
specific_field
.
new_index
parent_fields
)
;
if
(
!
result
)
{
if
(
reporter_
=
=
NULL
)
return
false
;
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportModified
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
fieldDifferent
=
true
;
}
else
if
(
reporter_
!
=
NULL
&
&
specific_field
.
index
!
=
specific_field
.
new_index
&
&
!
specific_field
.
field
-
>
is_map
(
)
&
&
report_moves_
)
{
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportMoved
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
}
else
if
(
report_matches_
&
&
reporter_
!
=
NULL
)
{
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportMatched
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
}
}
for
(
int
i
=
0
;
i
<
count2
;
+
+
i
)
{
if
(
!
simple_list
&
&
match_list2
[
i
]
!
=
-
1
)
continue
;
if
(
simple_list
&
&
i
<
count1
)
continue
;
if
(
!
treated_as_subset
)
{
fieldDifferent
=
true
;
}
if
(
reporter_
=
=
NULL
)
continue
;
specific_field
.
index
=
i
;
AddSpecificNewIndex
(
&
specific_field
message2
repeated_field
i
)
;
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportAdded
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
}
for
(
int
i
=
0
;
i
<
count1
;
+
+
i
)
{
if
(
!
simple_list
&
&
match_list1
[
i
]
!
=
-
1
)
continue
;
if
(
simple_list
&
&
i
<
count2
)
continue
;
assert
(
reporter_
!
=
NULL
)
;
AddSpecificIndex
(
&
specific_field
message1
repeated_field
i
)
;
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportDeleted
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
fieldDifferent
=
true
;
}
return
!
fieldDifferent
;
}
bool
MessageDifferencer
:
:
CompareFieldValue
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
field
int
index1
int
index2
)
{
return
CompareFieldValueUsingParentFields
(
message1
message2
field
index1
index2
NULL
)
;
}
bool
MessageDifferencer
:
:
CompareFieldValueUsingParentFields
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
field
int
index1
int
index2
std
:
:
vector
<
SpecificField
>
*
parent_fields
)
{
FieldContext
field_context
(
parent_fields
)
;
FieldComparator
:
:
ComparisonResult
result
=
GetFieldComparisonResult
(
message1
message2
field
index1
index2
&
field_context
)
;
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
&
&
result
=
=
FieldComparator
:
:
RECURSE
)
{
const
Reflection
*
reflection1
=
message1
.
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
.
GetReflection
(
)
;
const
Message
&
m1
=
field
-
>
is_repeated
(
)
?
reflection1
-
>
GetRepeatedMessage
(
message1
field
index1
)
:
reflection1
-
>
GetMessage
(
message1
field
)
;
const
Message
&
m2
=
field
-
>
is_repeated
(
)
?
reflection2
-
>
GetRepeatedMessage
(
message2
field
index2
)
:
reflection2
-
>
GetMessage
(
message2
field
)
;
if
(
parent_fields
!
=
NULL
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field
;
AddSpecificIndex
(
&
specific_field
message1
field
index1
)
;
AddSpecificNewIndex
(
&
specific_field
message2
field
index2
)
;
parent_fields
-
>
push_back
(
specific_field
)
;
const
bool
compare_result
=
Compare
(
m1
m2
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
return
compare_result
;
}
else
{
return
Compare
(
m1
m2
)
;
}
}
else
{
return
(
result
=
=
FieldComparator
:
:
SAME
)
;
}
}
bool
MessageDifferencer
:
:
CheckPathChanged
(
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
for
(
const
SpecificField
&
specific_field
:
field_path
)
{
if
(
specific_field
.
field
!
=
nullptr
&
&
specific_field
.
field
-
>
is_map
(
)
)
continue
;
if
(
specific_field
.
index
!
=
specific_field
.
new_index
)
return
true
;
}
return
false
;
}
bool
MessageDifferencer
:
:
IsTreatedAsSet
(
const
FieldDescriptor
*
field
)
{
if
(
!
field
-
>
is_repeated
(
)
)
return
false
;
if
(
repeated_field_comparisons_
.
find
(
field
)
!
=
repeated_field_comparisons_
.
end
(
)
)
{
return
repeated_field_comparisons_
[
field
]
=
=
AS_SET
;
}
return
GetMapKeyComparator
(
field
)
=
=
nullptr
&
&
repeated_field_comparison_
=
=
AS_SET
;
}
bool
MessageDifferencer
:
:
IsTreatedAsSmartSet
(
const
FieldDescriptor
*
field
)
{
if
(
!
field
-
>
is_repeated
(
)
)
return
false
;
if
(
repeated_field_comparisons_
.
find
(
field
)
!
=
repeated_field_comparisons_
.
end
(
)
)
{
return
repeated_field_comparisons_
[
field
]
=
=
AS_SMART_SET
;
}
return
GetMapKeyComparator
(
field
)
=
=
nullptr
&
&
repeated_field_comparison_
=
=
AS_SMART_SET
;
}
bool
MessageDifferencer
:
:
IsTreatedAsSmartList
(
const
FieldDescriptor
*
field
)
{
if
(
!
field
-
>
is_repeated
(
)
)
return
false
;
if
(
repeated_field_comparisons_
.
find
(
field
)
!
=
repeated_field_comparisons_
.
end
(
)
)
{
return
repeated_field_comparisons_
[
field
]
=
=
AS_SMART_LIST
;
}
return
GetMapKeyComparator
(
field
)
=
=
nullptr
&
&
repeated_field_comparison_
=
=
AS_SMART_LIST
;
}
bool
MessageDifferencer
:
:
IsTreatedAsSubset
(
const
FieldDescriptor
*
field
)
{
return
scope_
=
=
PARTIAL
&
&
(
IsTreatedAsSet
(
field
)
|
|
GetMapKeyComparator
(
field
)
!
=
NULL
)
;
}
bool
MessageDifferencer
:
:
IsIgnored
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
field
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
)
{
if
(
ignored_fields_
.
find
(
field
)
!
=
ignored_fields_
.
end
(
)
)
{
return
true
;
}
for
(
IgnoreCriteria
*
criteria
:
ignore_criteria_
)
{
if
(
criteria
-
>
IsIgnored
(
message1
message2
field
parent_fields
)
)
{
return
true
;
}
}
return
false
;
}
bool
MessageDifferencer
:
:
IsUnknownFieldIgnored
(
const
Message
&
message1
const
Message
&
message2
const
SpecificField
&
field
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
)
{
for
(
IgnoreCriteria
*
criteria
:
ignore_criteria_
)
{
if
(
criteria
-
>
IsUnknownFieldIgnored
(
message1
message2
field
parent_fields
)
)
{
return
true
;
}
}
return
false
;
}
const
MessageDifferencer
:
:
MapKeyComparator
*
MessageDifferencer
:
:
GetMapKeyComparator
(
const
FieldDescriptor
*
field
)
const
{
if
(
!
field
-
>
is_repeated
(
)
)
return
NULL
;
FieldKeyComparatorMap
:
:
const_iterator
it
=
map_field_key_comparator_
.
find
(
field
)
;
if
(
it
!
=
map_field_key_comparator_
.
end
(
)
)
{
return
it
-
>
second
;
}
if
(
field
-
>
is_map
(
)
)
{
return
&
map_entry_key_comparator_
;
}
return
NULL
;
}
namespace
{
typedef
std
:
:
pair
<
int
const
UnknownField
*
>
IndexUnknownFieldPair
;
struct
UnknownFieldOrdering
{
inline
bool
operator
(
)
(
const
IndexUnknownFieldPair
&
a
const
IndexUnknownFieldPair
&
b
)
const
{
if
(
a
.
second
-
>
number
(
)
<
b
.
second
-
>
number
(
)
)
return
true
;
if
(
a
.
second
-
>
number
(
)
>
b
.
second
-
>
number
(
)
)
return
false
;
return
a
.
second
-
>
type
(
)
<
b
.
second
-
>
type
(
)
;
}
}
;
}
bool
MessageDifferencer
:
:
UnpackAnyField
:
:
UnpackAny
(
const
Message
&
any
std
:
:
unique_ptr
<
Message
>
*
data
)
{
const
Reflection
*
reflection
=
any
.
GetReflection
(
)
;
const
FieldDescriptor
*
type_url_field
;
const
FieldDescriptor
*
value_field
;
if
(
!
internal
:
:
GetAnyFieldDescriptors
(
any
&
type_url_field
&
value_field
)
)
{
return
false
;
}
const
std
:
:
string
&
type_url
=
reflection
-
>
GetString
(
any
type_url_field
)
;
std
:
:
string
full_type_name
;
if
(
!
internal
:
:
ParseAnyTypeUrl
(
type_url
&
full_type_name
)
)
{
return
false
;
}
const
Descriptor
*
desc
=
any
.
GetDescriptor
(
)
-
>
file
(
)
-
>
pool
(
)
-
>
FindMessageTypeByName
(
full_type_name
)
;
if
(
desc
=
=
NULL
)
{
GOOGLE_LOG
(
INFO
)
<
<
"
Proto
type
'
"
<
<
full_type_name
<
<
"
'
not
found
"
;
return
false
;
}
if
(
dynamic_message_factory_
=
=
NULL
)
{
dynamic_message_factory_
.
reset
(
new
DynamicMessageFactory
(
)
)
;
}
data
-
>
reset
(
dynamic_message_factory_
-
>
GetPrototype
(
desc
)
-
>
New
(
)
)
;
std
:
:
string
serialized_value
=
reflection
-
>
GetString
(
any
value_field
)
;
if
(
!
(
*
data
)
-
>
ParsePartialFromString
(
serialized_value
)
)
{
GOOGLE_DLOG
(
ERROR
)
<
<
"
Failed
to
parse
value
for
"
<
<
full_type_name
;
return
false
;
}
return
true
;
}
bool
MessageDifferencer
:
:
CompareUnknownFields
(
const
Message
&
message1
const
Message
&
message2
const
UnknownFieldSet
&
unknown_field_set1
const
UnknownFieldSet
&
unknown_field_set2
std
:
:
vector
<
SpecificField
>
*
parent_field
)
{
if
(
message_field_comparison_
=
=
EQUIVALENT
)
return
true
;
if
(
unknown_field_set1
.
empty
(
)
&
&
unknown_field_set2
.
empty
(
)
)
{
return
true
;
}
bool
is_different
=
false
;
std
:
:
vector
<
IndexUnknownFieldPair
>
fields1
;
std
:
:
vector
<
IndexUnknownFieldPair
>
fields2
;
fields1
.
reserve
(
unknown_field_set1
.
field_count
(
)
)
;
fields2
.
reserve
(
unknown_field_set2
.
field_count
(
)
)
;
for
(
int
i
=
0
;
i
<
unknown_field_set1
.
field_count
(
)
;
i
+
+
)
{
fields1
.
push_back
(
std
:
:
make_pair
(
i
&
unknown_field_set1
.
field
(
i
)
)
)
;
}
for
(
int
i
=
0
;
i
<
unknown_field_set2
.
field_count
(
)
;
i
+
+
)
{
fields2
.
push_back
(
std
:
:
make_pair
(
i
&
unknown_field_set2
.
field
(
i
)
)
)
;
}
UnknownFieldOrdering
is_before
;
std
:
:
stable_sort
(
fields1
.
begin
(
)
fields1
.
end
(
)
is_before
)
;
std
:
:
stable_sort
(
fields2
.
begin
(
)
fields2
.
end
(
)
is_before
)
;
const
UnknownField
*
current_repeated
=
NULL
;
int
current_repeated_start1
=
0
;
int
current_repeated_start2
=
0
;
size_t
index1
=
0
;
size_t
index2
=
0
;
while
(
index1
<
fields1
.
size
(
)
|
|
index2
<
fields2
.
size
(
)
)
{
enum
{
ADDITION
DELETION
MODIFICATION
COMPARE_GROUPS
NO_CHANGE
}
change_type
;
const
UnknownField
*
focus_field
;
bool
match
=
false
;
if
(
index2
=
=
fields2
.
size
(
)
|
|
(
index1
<
fields1
.
size
(
)
&
&
is_before
(
fields1
[
index1
]
fields2
[
index2
]
)
)
)
{
change_type
=
DELETION
;
focus_field
=
fields1
[
index1
]
.
second
;
}
else
if
(
index1
=
=
fields1
.
size
(
)
|
|
is_before
(
fields2
[
index2
]
fields1
[
index1
]
)
)
{
if
(
scope_
=
=
PARTIAL
)
{
+
+
index2
;
continue
;
}
change_type
=
ADDITION
;
focus_field
=
fields2
[
index2
]
.
second
;
}
else
{
change_type
=
MODIFICATION
;
focus_field
=
fields1
[
index1
]
.
second
;
switch
(
focus_field
-
>
type
(
)
)
{
case
UnknownField
:
:
TYPE_VARINT
:
match
=
fields1
[
index1
]
.
second
-
>
varint
(
)
=
=
fields2
[
index2
]
.
second
-
>
varint
(
)
;
break
;
case
UnknownField
:
:
TYPE_FIXED32
:
match
=
fields1
[
index1
]
.
second
-
>
fixed32
(
)
=
=
fields2
[
index2
]
.
second
-
>
fixed32
(
)
;
break
;
case
UnknownField
:
:
TYPE_FIXED64
:
match
=
fields1
[
index1
]
.
second
-
>
fixed64
(
)
=
=
fields2
[
index2
]
.
second
-
>
fixed64
(
)
;
break
;
case
UnknownField
:
:
TYPE_LENGTH_DELIMITED
:
match
=
fields1
[
index1
]
.
second
-
>
length_delimited
(
)
=
=
fields2
[
index2
]
.
second
-
>
length_delimited
(
)
;
break
;
case
UnknownField
:
:
TYPE_GROUP
:
change_type
=
COMPARE_GROUPS
;
break
;
}
if
(
match
&
&
change_type
!
=
COMPARE_GROUPS
)
{
change_type
=
NO_CHANGE
;
}
}
if
(
current_repeated
=
=
NULL
|
|
focus_field
-
>
number
(
)
!
=
current_repeated
-
>
number
(
)
|
|
focus_field
-
>
type
(
)
!
=
current_repeated
-
>
type
(
)
)
{
current_repeated
=
focus_field
;
current_repeated_start1
=
index1
;
current_repeated_start2
=
index2
;
}
if
(
change_type
=
=
NO_CHANGE
&
&
reporter_
=
=
NULL
)
{
+
+
index1
;
+
+
index2
;
continue
;
}
SpecificField
specific_field
;
specific_field
.
unknown_field_number
=
focus_field
-
>
number
(
)
;
specific_field
.
unknown_field_type
=
focus_field
-
>
type
(
)
;
specific_field
.
unknown_field_set1
=
&
unknown_field_set1
;
specific_field
.
unknown_field_set2
=
&
unknown_field_set2
;
if
(
change_type
!
=
ADDITION
)
{
specific_field
.
unknown_field_index1
=
fields1
[
index1
]
.
first
;
}
if
(
change_type
!
=
DELETION
)
{
specific_field
.
unknown_field_index2
=
fields2
[
index2
]
.
first
;
}
if
(
change_type
=
=
ADDITION
)
{
specific_field
.
index
=
index2
-
current_repeated_start2
;
specific_field
.
new_index
=
index2
-
current_repeated_start2
;
}
else
{
specific_field
.
index
=
index1
-
current_repeated_start1
;
specific_field
.
new_index
=
index2
-
current_repeated_start2
;
}
if
(
IsUnknownFieldIgnored
(
message1
message2
specific_field
*
parent_field
)
)
{
if
(
report_ignores_
&
&
reporter_
!
=
NULL
)
{
parent_field
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportUnknownFieldIgnored
(
message1
message2
*
parent_field
)
;
parent_field
-
>
pop_back
(
)
;
}
if
(
change_type
!
=
ADDITION
)
+
+
index1
;
if
(
change_type
!
=
DELETION
)
+
+
index2
;
continue
;
}
if
(
change_type
=
=
ADDITION
|
|
change_type
=
=
DELETION
|
|
change_type
=
=
MODIFICATION
)
{
if
(
reporter_
=
=
NULL
)
{
return
false
;
}
is_different
=
true
;
}
parent_field
-
>
push_back
(
specific_field
)
;
switch
(
change_type
)
{
case
ADDITION
:
reporter_
-
>
ReportAdded
(
message1
message2
*
parent_field
)
;
+
+
index2
;
break
;
case
DELETION
:
reporter_
-
>
ReportDeleted
(
message1
message2
*
parent_field
)
;
+
+
index1
;
break
;
case
MODIFICATION
:
reporter_
-
>
ReportModified
(
message1
message2
*
parent_field
)
;
+
+
index1
;
+
+
index2
;
break
;
case
COMPARE_GROUPS
:
if
(
!
CompareUnknownFields
(
message1
message2
fields1
[
index1
]
.
second
-
>
group
(
)
fields2
[
index2
]
.
second
-
>
group
(
)
parent_field
)
)
{
if
(
reporter_
=
=
NULL
)
return
false
;
is_different
=
true
;
reporter_
-
>
ReportModified
(
message1
message2
*
parent_field
)
;
}
+
+
index1
;
+
+
index2
;
break
;
case
NO_CHANGE
:
+
+
index1
;
+
+
index2
;
if
(
report_matches_
)
{
reporter_
-
>
ReportMatched
(
message1
message2
*
parent_field
)
;
}
}
parent_field
-
>
pop_back
(
)
;
}
return
!
is_different
;
}
namespace
{
class
MaximumMatcher
{
public
:
typedef
std
:
:
function
<
bool
(
int
int
)
>
NodeMatchCallback
;
MaximumMatcher
(
int
count1
int
count2
NodeMatchCallback
callback
std
:
:
vector
<
int
>
*
match_list1
std
:
:
vector
<
int
>
*
match_list2
)
;
int
FindMaximumMatch
(
bool
early_return
)
;
private
:
bool
Match
(
int
left
int
right
)
;
bool
FindArgumentPathDFS
(
int
v
std
:
:
vector
<
bool
>
*
visited
)
;
int
count1_
;
int
count2_
;
NodeMatchCallback
match_callback_
;
std
:
:
map
<
std
:
:
pair
<
int
int
>
bool
>
cached_match_results_
;
std
:
:
vector
<
int
>
*
match_list1_
;
std
:
:
vector
<
int
>
*
match_list2_
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
MaximumMatcher
)
;
}
;
MaximumMatcher
:
:
MaximumMatcher
(
int
count1
int
count2
NodeMatchCallback
callback
std
:
:
vector
<
int
>
*
match_list1
std
:
:
vector
<
int
>
*
match_list2
)
:
count1_
(
count1
)
count2_
(
count2
)
match_callback_
(
std
:
:
move
(
callback
)
)
match_list1_
(
match_list1
)
match_list2_
(
match_list2
)
{
match_list1_
-
>
assign
(
count1
-
1
)
;
match_list2_
-
>
assign
(
count2
-
1
)
;
}
int
MaximumMatcher
:
:
FindMaximumMatch
(
bool
early_return
)
{
int
result
=
0
;
for
(
int
i
=
0
;
i
<
count1_
;
+
+
i
)
{
std
:
:
vector
<
bool
>
visited
(
count1_
)
;
if
(
FindArgumentPathDFS
(
i
&
visited
)
)
{
+
+
result
;
}
else
if
(
early_return
)
{
return
0
;
}
}
for
(
int
i
=
0
;
i
<
count2_
;
+
+
i
)
{
if
(
(
*
match_list2_
)
[
i
]
!
=
-
1
)
{
(
*
match_list1_
)
[
(
*
match_list2_
)
[
i
]
]
=
i
;
}
}
return
result
;
}
bool
MaximumMatcher
:
:
Match
(
int
left
int
right
)
{
std
:
:
pair
<
int
int
>
p
(
left
right
)
;
std
:
:
map
<
std
:
:
pair
<
int
int
>
bool
>
:
:
iterator
it
=
cached_match_results_
.
find
(
p
)
;
if
(
it
!
=
cached_match_results_
.
end
(
)
)
{
return
it
-
>
second
;
}
cached_match_results_
[
p
]
=
match_callback_
(
left
right
)
;
return
cached_match_results_
[
p
]
;
}
bool
MaximumMatcher
:
:
FindArgumentPathDFS
(
int
v
std
:
:
vector
<
bool
>
*
visited
)
{
(
*
visited
)
[
v
]
=
true
;
for
(
int
i
=
0
;
i
<
count2_
;
+
+
i
)
{
int
matched
=
(
*
match_list2_
)
[
i
]
;
if
(
matched
=
=
-
1
&
&
Match
(
v
i
)
)
{
(
*
match_list2_
)
[
i
]
=
v
;
return
true
;
}
}
for
(
int
i
=
0
;
i
<
count2_
;
+
+
i
)
{
int
matched
=
(
*
match_list2_
)
[
i
]
;
if
(
matched
!
=
-
1
&
&
Match
(
v
i
)
)
{
if
(
!
(
*
visited
)
[
matched
]
&
&
FindArgumentPathDFS
(
matched
visited
)
)
{
(
*
match_list2_
)
[
i
]
=
v
;
return
true
;
}
}
}
return
false
;
}
}
bool
MessageDifferencer
:
:
MatchRepeatedFieldIndices
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
repeated_field
const
MapKeyComparator
*
key_comparator
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
std
:
:
vector
<
int
>
*
match_list1
std
:
:
vector
<
int
>
*
match_list2
)
{
const
int
count1
=
message1
.
GetReflection
(
)
-
>
FieldSize
(
message1
repeated_field
)
;
const
int
count2
=
message2
.
GetReflection
(
)
-
>
FieldSize
(
message2
repeated_field
)
;
const
bool
is_treated_as_smart_set
=
IsTreatedAsSmartSet
(
repeated_field
)
;
match_list1
-
>
assign
(
count1
-
1
)
;
match_list2
-
>
assign
(
count2
-
1
)
;
Reporter
*
reporter
=
reporter_
;
reporter_
=
NULL
;
NumDiffsReporter
num_diffs_reporter
;
std
:
:
vector
<
int32_t
>
num_diffs_list1
;
if
(
is_treated_as_smart_set
)
{
num_diffs_list1
.
assign
(
count1
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
;
}
bool
success
=
true
;
if
(
scope_
=
=
PARTIAL
)
{
auto
callback
=
[
&
]
(
int
i1
int
i2
)
{
return
IsMatch
(
repeated_field
key_comparator
&
message1
&
message2
parent_fields
nullptr
i1
i2
)
;
}
;
MaximumMatcher
matcher
(
count1
count2
std
:
:
move
(
callback
)
match_list1
match_list2
)
;
bool
early_return
=
(
reporter
=
=
nullptr
)
;
int
match_count
=
matcher
.
FindMaximumMatch
(
early_return
)
;
if
(
match_count
!
=
count1
&
&
early_return
)
return
false
;
success
=
success
&
&
(
match_count
=
=
count1
)
;
}
else
{
int
start_offset
=
0
;
if
(
IsTreatedAsSet
(
repeated_field
)
|
|
is_treated_as_smart_set
|
|
IsTreatedAsSmartList
(
repeated_field
)
)
{
start_offset
=
std
:
:
min
(
count1
count2
)
;
for
(
int
i
=
0
;
i
<
count1
&
&
i
<
count2
;
i
+
+
)
{
if
(
IsMatch
(
repeated_field
key_comparator
&
message1
&
message2
parent_fields
nullptr
i
i
)
)
{
match_list1
-
>
at
(
i
)
=
i
;
match_list2
-
>
at
(
i
)
=
i
;
}
else
{
start_offset
=
i
;
break
;
}
}
}
for
(
int
i
=
start_offset
;
i
<
count1
;
+
+
i
)
{
bool
match
=
false
;
int
matched_j
=
-
1
;
for
(
int
j
=
start_offset
;
j
<
count2
;
j
+
+
)
{
if
(
match_list2
-
>
at
(
j
)
!
=
-
1
)
{
if
(
!
is_treated_as_smart_set
|
|
num_diffs_list1
[
i
]
=
=
0
|
|
num_diffs_list1
[
match_list2
-
>
at
(
j
)
]
=
=
0
)
{
continue
;
}
}
if
(
is_treated_as_smart_set
)
{
num_diffs_reporter
.
Reset
(
)
;
match
=
IsMatch
(
repeated_field
key_comparator
&
message1
&
message2
parent_fields
&
num_diffs_reporter
i
j
)
;
}
else
{
match
=
IsMatch
(
repeated_field
key_comparator
&
message1
&
message2
parent_fields
nullptr
i
j
)
;
}
if
(
is_treated_as_smart_set
)
{
if
(
match
)
{
num_diffs_list1
[
i
]
=
0
;
}
else
if
(
repeated_field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
const
int32_t
num_diffs
=
num_diffs_reporter
.
GetNumDiffs
(
)
;
if
(
num_diffs
<
num_diffs_list1
[
i
]
)
{
if
(
match_list2
-
>
at
(
j
)
=
=
-
1
|
|
num_diffs
<
num_diffs_list1
[
match_list2
-
>
at
(
j
)
]
)
{
num_diffs_list1
[
i
]
=
num_diffs
;
match
=
true
;
}
}
}
}
if
(
match
)
{
matched_j
=
j
;
if
(
!
is_treated_as_smart_set
|
|
num_diffs_list1
[
i
]
=
=
0
)
{
break
;
}
}
}
match
=
(
matched_j
!
=
-
1
)
;
if
(
match
)
{
if
(
is_treated_as_smart_set
&
&
match_list2
-
>
at
(
matched_j
)
!
=
-
1
)
{
match_list1
-
>
at
(
match_list2
-
>
at
(
matched_j
)
)
=
-
1
;
match
=
false
;
}
match_list1
-
>
at
(
i
)
=
matched_j
;
match_list2
-
>
at
(
matched_j
)
=
i
;
}
if
(
!
match
&
&
reporter
=
=
nullptr
)
return
false
;
success
=
success
&
&
match
;
}
}
if
(
IsTreatedAsSmartList
(
repeated_field
)
)
{
match_indices_for_smart_list_callback_
(
match_list1
match_list2
)
;
}
reporter_
=
reporter
;
return
success
;
}
FieldComparator
:
:
ComparisonResult
MessageDifferencer
:
:
GetFieldComparisonResult
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
field
int
index1
int
index2
const
FieldContext
*
field_context
)
{
FieldComparator
*
comparator
=
field_comparator_kind_
=
=
kFCBase
?
field_comparator_
.
base
:
field_comparator_
.
default_impl
;
return
comparator
-
>
Compare
(
message1
message2
field
index1
index2
field_context
)
;
}
MessageDifferencer
:
:
Reporter
:
:
Reporter
(
)
{
}
MessageDifferencer
:
:
Reporter
:
:
~
Reporter
(
)
{
}
MessageDifferencer
:
:
MapKeyComparator
:
:
MapKeyComparator
(
)
{
}
MessageDifferencer
:
:
MapKeyComparator
:
:
~
MapKeyComparator
(
)
{
}
MessageDifferencer
:
:
IgnoreCriteria
:
:
IgnoreCriteria
(
)
{
}
MessageDifferencer
:
:
IgnoreCriteria
:
:
~
IgnoreCriteria
(
)
{
}
MessageDifferencer
:
:
StreamReporter
:
:
StreamReporter
(
io
:
:
ZeroCopyOutputStream
*
output
)
:
printer_
(
new
io
:
:
Printer
(
output
'
'
)
)
delete_printer_
(
true
)
report_modified_aggregates_
(
false
)
message1_
(
nullptr
)
message2_
(
nullptr
)
{
}
MessageDifferencer
:
:
StreamReporter
:
:
StreamReporter
(
io
:
:
Printer
*
printer
)
:
printer_
(
printer
)
delete_printer_
(
false
)
report_modified_aggregates_
(
false
)
message1_
(
nullptr
)
message2_
(
nullptr
)
{
}
MessageDifferencer
:
:
StreamReporter
:
:
~
StreamReporter
(
)
{
if
(
delete_printer_
)
delete
printer_
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
PrintPath
(
const
std
:
:
vector
<
SpecificField
>
&
field_path
bool
left_side
)
{
for
(
size_t
i
=
0
;
i
<
field_path
.
size
(
)
;
+
+
i
)
{
SpecificField
specific_field
=
field_path
[
i
]
;
if
(
specific_field
.
field
!
=
nullptr
&
&
specific_field
.
field
-
>
name
(
)
=
=
"
value
"
)
{
if
(
i
>
0
&
&
field_path
[
i
-
1
]
.
field
-
>
is_map
(
)
)
{
continue
;
}
}
if
(
i
>
0
)
{
printer_
-
>
Print
(
"
.
"
)
;
}
if
(
specific_field
.
field
!
=
NULL
)
{
if
(
specific_field
.
field
-
>
is_extension
(
)
)
{
printer_
-
>
Print
(
"
(
name
)
"
"
name
"
specific_field
.
field
-
>
full_name
(
)
)
;
}
else
{
printer_
-
>
PrintRaw
(
specific_field
.
field
-
>
name
(
)
)
;
}
if
(
specific_field
.
field
-
>
is_map
(
)
)
{
PrintMapKey
(
left_side
specific_field
)
;
continue
;
}
}
else
{
printer_
-
>
PrintRaw
(
StrCat
(
specific_field
.
unknown_field_number
)
)
;
}
if
(
left_side
&
&
specific_field
.
index
>
=
0
)
{
printer_
-
>
Print
(
"
[
name
]
"
"
name
"
StrCat
(
specific_field
.
index
)
)
;
}
if
(
!
left_side
&
&
specific_field
.
new_index
>
=
0
)
{
printer_
-
>
Print
(
"
[
name
]
"
"
name
"
StrCat
(
specific_field
.
new_index
)
)
;
}
}
}
void
MessageDifferencer
:
:
StreamReporter
:
:
PrintValue
(
const
Message
&
message
const
std
:
:
vector
<
SpecificField
>
&
field_path
bool
left_side
)
{
const
SpecificField
&
specific_field
=
field_path
.
back
(
)
;
const
FieldDescriptor
*
field
=
specific_field
.
field
;
if
(
field
!
=
NULL
)
{
std
:
:
string
output
;
int
index
=
left_side
?
specific_field
.
index
:
specific_field
.
new_index
;
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
const
Reflection
*
reflection
=
message
.
GetReflection
(
)
;
const
Message
&
field_message
=
field
-
>
is_repeated
(
)
?
reflection
-
>
GetRepeatedMessage
(
message
field
index
)
:
reflection
-
>
GetMessage
(
message
field
)
;
const
FieldDescriptor
*
fd
=
nullptr
;
if
(
field
-
>
is_map
(
)
&
&
message1_
!
=
nullptr
&
&
message2_
!
=
nullptr
)
{
fd
=
field_message
.
GetDescriptor
(
)
-
>
field
(
1
)
;
if
(
fd
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
output
=
PrintShortTextFormat
(
field_message
.
GetReflection
(
)
-
>
GetMessage
(
field_message
fd
)
)
;
}
else
{
TextFormat
:
:
PrintFieldValueToString
(
field_message
fd
-
1
&
output
)
;
}
}
else
{
output
=
PrintShortTextFormat
(
field_message
)
;
}
if
(
output
.
empty
(
)
)
{
printer_
-
>
Print
(
"
{
}
"
)
;
}
else
{
if
(
(
fd
!
=
nullptr
)
&
&
(
fd
-
>
cpp_type
(
)
!
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
)
{
printer_
-
>
PrintRaw
(
output
)
;
}
else
{
printer_
-
>
Print
(
"
{
name
}
"
"
name
"
output
)
;
}
}
}
else
{
TextFormat
:
:
PrintFieldValueToString
(
message
field
index
&
output
)
;
printer_
-
>
PrintRaw
(
output
)
;
}
}
else
{
const
UnknownFieldSet
*
unknown_fields
=
(
left_side
?
specific_field
.
unknown_field_set1
:
specific_field
.
unknown_field_set2
)
;
const
UnknownField
*
unknown_field
=
&
unknown_fields
-
>
field
(
left_side
?
specific_field
.
unknown_field_index1
:
specific_field
.
unknown_field_index2
)
;
PrintUnknownFieldValue
(
unknown_field
)
;
}
}
void
MessageDifferencer
:
:
StreamReporter
:
:
PrintUnknownFieldValue
(
const
UnknownField
*
unknown_field
)
{
GOOGLE_CHECK
(
unknown_field
!
=
NULL
)
<
<
"
Cannot
print
NULL
unknown_field
.
"
;
std
:
:
string
output
;
switch
(
unknown_field
-
>
type
(
)
)
{
case
UnknownField
:
:
TYPE_VARINT
:
output
=
StrCat
(
unknown_field
-
>
varint
(
)
)
;
break
;
case
UnknownField
:
:
TYPE_FIXED32
:
output
=
StrCat
(
"
0x
"
strings
:
:
Hex
(
unknown_field
-
>
fixed32
(
)
strings
:
:
ZERO_PAD_8
)
)
;
break
;
case
UnknownField
:
:
TYPE_FIXED64
:
output
=
StrCat
(
"
0x
"
strings
:
:
Hex
(
unknown_field
-
>
fixed64
(
)
strings
:
:
ZERO_PAD_16
)
)
;
break
;
case
UnknownField
:
:
TYPE_LENGTH_DELIMITED
:
output
=
StringPrintf
(
"
\
"
%
s
\
"
"
CEscape
(
unknown_field
-
>
length_delimited
(
)
)
.
c_str
(
)
)
;
break
;
case
UnknownField
:
:
TYPE_GROUP
:
output
=
"
{
.
.
.
}
"
;
break
;
}
printer_
-
>
PrintRaw
(
output
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
Print
(
const
std
:
:
string
&
str
)
{
printer_
-
>
Print
(
str
.
c_str
(
)
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
PrintMapKey
(
bool
left_side
const
SpecificField
&
specific_field
)
{
if
(
message1_
=
=
nullptr
|
|
message2_
=
=
nullptr
)
{
GOOGLE_LOG
(
INFO
)
<
<
"
PrintPath
cannot
log
map
keys
;
"
"
use
SetMessages
to
provide
the
messages
"
"
being
compared
prior
to
any
processing
.
"
;
return
;
}
const
Message
*
found_message
=
left_side
?
specific_field
.
map_entry1
:
specific_field
.
map_entry2
;
std
:
:
string
key_string
=
"
"
;
if
(
found_message
!
=
nullptr
)
{
const
FieldDescriptor
*
fd
=
found_message
-
>
GetDescriptor
(
)
-
>
field
(
0
)
;
if
(
fd
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_STRING
)
{
key_string
=
found_message
-
>
GetReflection
(
)
-
>
GetString
(
*
found_message
found_message
-
>
GetDescriptor
(
)
-
>
field
(
0
)
)
;
}
else
{
TextFormat
:
:
PrintFieldValueToString
(
*
found_message
fd
-
1
&
key_string
)
;
}
if
(
key_string
.
empty
(
)
)
{
key_string
=
"
'
'
"
;
}
printer_
-
>
PrintRaw
(
StrCat
(
"
[
"
key_string
"
]
"
)
)
;
}
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportAdded
(
const
Message
&
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
printer_
-
>
Print
(
"
added
:
"
)
;
PrintPath
(
field_path
false
)
;
printer_
-
>
Print
(
"
:
"
)
;
PrintValue
(
message2
field_path
false
)
;
printer_
-
>
Print
(
"
\
n
"
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportDeleted
(
const
Message
&
message1
const
Message
&
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
printer_
-
>
Print
(
"
deleted
:
"
)
;
PrintPath
(
field_path
true
)
;
printer_
-
>
Print
(
"
:
"
)
;
PrintValue
(
message1
field_path
true
)
;
printer_
-
>
Print
(
"
\
n
"
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportModified
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
if
(
!
report_modified_aggregates_
&
&
field_path
.
back
(
)
.
field
=
=
NULL
)
{
if
(
field_path
.
back
(
)
.
unknown_field_type
=
=
UnknownField
:
:
TYPE_GROUP
)
{
return
;
}
}
else
if
(
!
report_modified_aggregates_
)
{
if
(
field_path
.
back
(
)
.
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
return
;
}
}
printer_
-
>
Print
(
"
modified
:
"
)
;
PrintPath
(
field_path
true
)
;
if
(
CheckPathChanged
(
field_path
)
)
{
printer_
-
>
Print
(
"
-
>
"
)
;
PrintPath
(
field_path
false
)
;
}
printer_
-
>
Print
(
"
:
"
)
;
PrintValue
(
message1
field_path
true
)
;
printer_
-
>
Print
(
"
-
>
"
)
;
PrintValue
(
message2
field_path
false
)
;
printer_
-
>
Print
(
"
\
n
"
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportMoved
(
const
Message
&
message1
const
Message
&
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
printer_
-
>
Print
(
"
moved
:
"
)
;
PrintPath
(
field_path
true
)
;
printer_
-
>
Print
(
"
-
>
"
)
;
PrintPath
(
field_path
false
)
;
printer_
-
>
Print
(
"
:
"
)
;
PrintValue
(
message1
field_path
true
)
;
printer_
-
>
Print
(
"
\
n
"
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportMatched
(
const
Message
&
message1
const
Message
&
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
printer_
-
>
Print
(
"
matched
:
"
)
;
PrintPath
(
field_path
true
)
;
if
(
CheckPathChanged
(
field_path
)
)
{
printer_
-
>
Print
(
"
-
>
"
)
;
PrintPath
(
field_path
false
)
;
}
printer_
-
>
Print
(
"
:
"
)
;
PrintValue
(
message1
field_path
true
)
;
printer_
-
>
Print
(
"
\
n
"
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportIgnored
(
const
Message
&
const
Message
&
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
printer_
-
>
Print
(
"
ignored
:
"
)
;
PrintPath
(
field_path
true
)
;
if
(
CheckPathChanged
(
field_path
)
)
{
printer_
-
>
Print
(
"
-
>
"
)
;
PrintPath
(
field_path
false
)
;
}
printer_
-
>
Print
(
"
\
n
"
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
SetMessages
(
const
Message
&
message1
const
Message
&
message2
)
{
message1_
=
&
message1
;
message2_
=
&
message2
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportUnknownFieldIgnored
(
const
Message
&
const
Message
&
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
printer_
-
>
Print
(
"
ignored
:
"
)
;
PrintPath
(
field_path
true
)
;
if
(
CheckPathChanged
(
field_path
)
)
{
printer_
-
>
Print
(
"
-
>
"
)
;
PrintPath
(
field_path
false
)
;
}
printer_
-
>
Print
(
"
\
n
"
)
;
}
MessageDifferencer
:
:
MapKeyComparator
*
MessageDifferencer
:
:
CreateMultipleFieldsMapKeyComparator
(
const
std
:
:
vector
<
std
:
:
vector
<
const
FieldDescriptor
*
>
>
&
key_field_paths
)
{
return
new
MultipleFieldsMapKeyComparator
(
this
key_field_paths
)
;
}
}
}
}
