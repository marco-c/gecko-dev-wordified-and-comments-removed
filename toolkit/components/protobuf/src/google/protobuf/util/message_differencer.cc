#
include
<
google
/
protobuf
/
util
/
message_differencer
.
h
>
#
include
<
algorithm
>
#
include
<
memory
>
#
ifndef
_SHARED_PTR_H
#
include
<
google
/
protobuf
/
stubs
/
shared_ptr
.
h
>
#
endif
#
include
<
utility
>
#
include
<
google
/
protobuf
/
stubs
/
callback
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
common
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
logging
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
stringprintf
.
h
>
#
include
<
google
/
protobuf
/
any
.
h
>
#
include
<
google
/
protobuf
/
io
/
printer
.
h
>
#
include
<
google
/
protobuf
/
io
/
zero_copy_stream
.
h
>
#
include
<
google
/
protobuf
/
io
/
zero_copy_stream_impl
.
h
>
#
include
<
google
/
protobuf
/
descriptor
.
pb
.
h
>
#
include
<
google
/
protobuf
/
dynamic_message
.
h
>
#
include
<
google
/
protobuf
/
text_format
.
h
>
#
include
<
google
/
protobuf
/
util
/
field_comparator
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
strutil
.
h
>
namespace
google
{
namespace
protobuf
{
namespace
util
{
class
MessageDifferencer
:
:
MultipleFieldsMapKeyComparator
:
public
MessageDifferencer
:
:
MapKeyComparator
{
public
:
MultipleFieldsMapKeyComparator
(
MessageDifferencer
*
message_differencer
const
std
:
:
vector
<
std
:
:
vector
<
const
FieldDescriptor
*
>
>
&
key_field_paths
)
:
message_differencer_
(
message_differencer
)
key_field_paths_
(
key_field_paths
)
{
GOOGLE_CHECK
(
!
key_field_paths_
.
empty
(
)
)
;
for
(
int
i
=
0
;
i
<
key_field_paths_
.
size
(
)
;
+
+
i
)
{
GOOGLE_CHECK
(
!
key_field_paths_
[
i
]
.
empty
(
)
)
;
}
}
MultipleFieldsMapKeyComparator
(
MessageDifferencer
*
message_differencer
const
FieldDescriptor
*
key
)
:
message_differencer_
(
message_differencer
)
{
std
:
:
vector
<
const
FieldDescriptor
*
>
key_field_path
;
key_field_path
.
push_back
(
key
)
;
key_field_paths_
.
push_back
(
key_field_path
)
;
}
virtual
bool
IsMatch
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
)
const
{
for
(
int
i
=
0
;
i
<
key_field_paths_
.
size
(
)
;
+
+
i
)
{
if
(
!
IsMatchInternal
(
message1
message2
parent_fields
key_field_paths_
[
i
]
0
)
)
{
return
false
;
}
}
return
true
;
}
private
:
bool
IsMatchInternal
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
key_field_path
int
path_index
)
const
{
const
FieldDescriptor
*
field
=
key_field_path
[
path_index
]
;
std
:
:
vector
<
SpecificField
>
current_parent_fields
(
parent_fields
)
;
if
(
path_index
=
=
key_field_path
.
size
(
)
-
1
)
{
if
(
field
-
>
is_repeated
(
)
)
{
if
(
!
message_differencer_
-
>
CompareRepeatedField
(
message1
message2
field
&
current_parent_fields
)
)
{
return
false
;
}
}
else
{
if
(
!
message_differencer_
-
>
CompareFieldValueUsingParentFields
(
message1
message2
field
-
1
-
1
&
current_parent_fields
)
)
{
return
false
;
}
}
return
true
;
}
else
{
const
Reflection
*
reflection1
=
message1
.
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
.
GetReflection
(
)
;
bool
has_field1
=
reflection1
-
>
HasField
(
message1
field
)
;
bool
has_field2
=
reflection2
-
>
HasField
(
message2
field
)
;
if
(
!
has_field1
&
&
!
has_field2
)
{
return
true
;
}
if
(
has_field1
!
=
has_field2
)
{
return
false
;
}
SpecificField
specific_field
;
specific_field
.
field
=
field
;
current_parent_fields
.
push_back
(
specific_field
)
;
return
IsMatchInternal
(
reflection1
-
>
GetMessage
(
message1
field
)
reflection2
-
>
GetMessage
(
message2
field
)
current_parent_fields
key_field_path
path_index
+
1
)
;
}
}
MessageDifferencer
*
message_differencer_
;
std
:
:
vector
<
std
:
:
vector
<
const
FieldDescriptor
*
>
>
key_field_paths_
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
MultipleFieldsMapKeyComparator
)
;
}
;
MessageDifferencer
:
:
MapEntryKeyComparator
:
:
MapEntryKeyComparator
(
MessageDifferencer
*
message_differencer
)
:
message_differencer_
(
message_differencer
)
{
}
bool
MessageDifferencer
:
:
MapEntryKeyComparator
:
:
IsMatch
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
)
const
{
const
FieldDescriptor
*
key
=
message1
.
GetDescriptor
(
)
-
>
FindFieldByNumber
(
1
)
;
const
bool
treat_as_set
=
(
message_differencer_
-
>
scope
(
)
=
=
PARTIAL
&
&
!
message1
.
GetReflection
(
)
-
>
HasField
(
message1
key
)
)
|
|
message_differencer_
-
>
IsIgnored
(
message1
message2
key
parent_fields
)
;
std
:
:
vector
<
SpecificField
>
current_parent_fields
(
parent_fields
)
;
if
(
treat_as_set
)
{
return
message_differencer_
-
>
Compare
(
message1
message2
&
current_parent_fields
)
;
}
return
message_differencer_
-
>
CompareFieldValueUsingParentFields
(
message1
message2
key
-
1
-
1
&
current_parent_fields
)
;
}
bool
MessageDifferencer
:
:
Equals
(
const
Message
&
message1
const
Message
&
message2
)
{
MessageDifferencer
differencer
;
return
differencer
.
Compare
(
message1
message2
)
;
}
bool
MessageDifferencer
:
:
Equivalent
(
const
Message
&
message1
const
Message
&
message2
)
{
MessageDifferencer
differencer
;
differencer
.
set_message_field_comparison
(
MessageDifferencer
:
:
EQUIVALENT
)
;
return
differencer
.
Compare
(
message1
message2
)
;
}
bool
MessageDifferencer
:
:
ApproximatelyEquals
(
const
Message
&
message1
const
Message
&
message2
)
{
MessageDifferencer
differencer
;
differencer
.
set_float_comparison
(
MessageDifferencer
:
:
APPROXIMATE
)
;
return
differencer
.
Compare
(
message1
message2
)
;
}
bool
MessageDifferencer
:
:
ApproximatelyEquivalent
(
const
Message
&
message1
const
Message
&
message2
)
{
MessageDifferencer
differencer
;
differencer
.
set_message_field_comparison
(
MessageDifferencer
:
:
EQUIVALENT
)
;
differencer
.
set_float_comparison
(
MessageDifferencer
:
:
APPROXIMATE
)
;
return
differencer
.
Compare
(
message1
message2
)
;
}
MessageDifferencer
:
:
MessageDifferencer
(
)
:
reporter_
(
NULL
)
field_comparator_
(
NULL
)
message_field_comparison_
(
EQUAL
)
scope_
(
FULL
)
repeated_field_comparison_
(
AS_LIST
)
map_entry_key_comparator_
(
this
)
report_matches_
(
false
)
report_moves_
(
true
)
output_string_
(
NULL
)
{
}
MessageDifferencer
:
:
~
MessageDifferencer
(
)
{
for
(
int
i
=
0
;
i
<
owned_key_comparators_
.
size
(
)
;
+
+
i
)
{
delete
owned_key_comparators_
[
i
]
;
}
for
(
int
i
=
0
;
i
<
ignore_criteria_
.
size
(
)
;
+
+
i
)
{
delete
ignore_criteria_
[
i
]
;
}
}
void
MessageDifferencer
:
:
set_field_comparator
(
FieldComparator
*
comparator
)
{
GOOGLE_CHECK
(
comparator
)
<
<
"
Field
comparator
can
'
t
be
NULL
.
"
;
field_comparator_
=
comparator
;
}
void
MessageDifferencer
:
:
set_message_field_comparison
(
MessageFieldComparison
comparison
)
{
message_field_comparison_
=
comparison
;
}
void
MessageDifferencer
:
:
set_scope
(
Scope
scope
)
{
scope_
=
scope
;
}
MessageDifferencer
:
:
Scope
MessageDifferencer
:
:
scope
(
)
{
return
scope_
;
}
void
MessageDifferencer
:
:
set_float_comparison
(
FloatComparison
comparison
)
{
default_field_comparator_
.
set_float_comparison
(
comparison
=
=
EXACT
?
DefaultFieldComparator
:
:
EXACT
:
DefaultFieldComparator
:
:
APPROXIMATE
)
;
}
void
MessageDifferencer
:
:
set_repeated_field_comparison
(
RepeatedFieldComparison
comparison
)
{
repeated_field_comparison_
=
comparison
;
}
void
MessageDifferencer
:
:
TreatAsSet
(
const
FieldDescriptor
*
field
)
{
GOOGLE_CHECK
(
field
-
>
is_repeated
(
)
)
<
<
"
Field
must
be
repeated
:
"
<
<
field
-
>
full_name
(
)
;
const
MapKeyComparator
*
key_comparator
=
GetMapKeyComparator
(
field
)
;
GOOGLE_CHECK
(
key_comparator
=
=
NULL
)
<
<
"
Cannot
treat
this
repeated
field
as
both
Map
and
Set
for
"
<
<
"
comparison
.
Field
name
is
:
"
<
<
field
-
>
full_name
(
)
;
GOOGLE_CHECK
(
list_fields_
.
find
(
field
)
=
=
list_fields_
.
end
(
)
)
<
<
"
Cannot
treat
the
same
field
as
both
SET
and
LIST
.
Field
name
is
:
"
<
<
field
-
>
full_name
(
)
;
set_fields_
.
insert
(
field
)
;
}
void
MessageDifferencer
:
:
TreatAsList
(
const
FieldDescriptor
*
field
)
{
GOOGLE_CHECK
(
field
-
>
is_repeated
(
)
)
<
<
"
Field
must
be
repeated
:
"
<
<
field
-
>
full_name
(
)
;
const
MapKeyComparator
*
key_comparator
=
GetMapKeyComparator
(
field
)
;
GOOGLE_CHECK
(
key_comparator
=
=
NULL
)
<
<
"
Cannot
treat
this
repeated
field
as
both
Map
and
Set
for
"
<
<
"
comparison
.
Field
name
is
:
"
<
<
field
-
>
full_name
(
)
;
GOOGLE_CHECK
(
set_fields_
.
find
(
field
)
=
=
set_fields_
.
end
(
)
)
<
<
"
Cannot
treat
the
same
field
as
both
SET
and
LIST
.
Field
name
is
:
"
<
<
field
-
>
full_name
(
)
;
list_fields_
.
insert
(
field
)
;
}
void
MessageDifferencer
:
:
TreatAsMap
(
const
FieldDescriptor
*
field
const
FieldDescriptor
*
key
)
{
GOOGLE_CHECK
(
field
-
>
is_repeated
(
)
)
<
<
"
Field
must
be
repeated
:
"
<
<
field
-
>
full_name
(
)
;
GOOGLE_CHECK_EQ
(
FieldDescriptor
:
:
CPPTYPE_MESSAGE
field
-
>
cpp_type
(
)
)
<
<
"
Field
has
to
be
message
type
.
Field
name
is
:
"
<
<
field
-
>
full_name
(
)
;
GOOGLE_CHECK
(
key
-
>
containing_type
(
)
=
=
field
-
>
message_type
(
)
)
<
<
key
-
>
full_name
(
)
<
<
"
must
be
a
direct
subfield
within
the
repeated
field
"
<
<
field
-
>
full_name
(
)
<
<
"
not
"
<
<
key
-
>
containing_type
(
)
-
>
full_name
(
)
;
GOOGLE_CHECK
(
set_fields_
.
find
(
field
)
=
=
set_fields_
.
end
(
)
)
<
<
"
Cannot
treat
this
repeated
field
as
both
Map
and
Set
for
"
<
<
"
comparison
.
"
;
GOOGLE_CHECK
(
list_fields_
.
find
(
field
)
=
=
list_fields_
.
end
(
)
)
<
<
"
Cannot
treat
this
repeated
field
as
both
Map
and
List
for
"
<
<
"
comparison
.
"
;
MapKeyComparator
*
key_comparator
=
new
MultipleFieldsMapKeyComparator
(
this
key
)
;
owned_key_comparators_
.
push_back
(
key_comparator
)
;
map_field_key_comparator_
[
field
]
=
key_comparator
;
}
void
MessageDifferencer
:
:
TreatAsMapWithMultipleFieldsAsKey
(
const
FieldDescriptor
*
field
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
key_fields
)
{
std
:
:
vector
<
std
:
:
vector
<
const
FieldDescriptor
*
>
>
key_field_paths
;
for
(
int
i
=
0
;
i
<
key_fields
.
size
(
)
;
+
+
i
)
{
std
:
:
vector
<
const
FieldDescriptor
*
>
key_field_path
;
key_field_path
.
push_back
(
key_fields
[
i
]
)
;
key_field_paths
.
push_back
(
key_field_path
)
;
}
TreatAsMapWithMultipleFieldPathsAsKey
(
field
key_field_paths
)
;
}
void
MessageDifferencer
:
:
TreatAsMapWithMultipleFieldPathsAsKey
(
const
FieldDescriptor
*
field
const
std
:
:
vector
<
std
:
:
vector
<
const
FieldDescriptor
*
>
>
&
key_field_paths
)
{
GOOGLE_CHECK
(
field
-
>
is_repeated
(
)
)
<
<
"
Field
must
be
repeated
:
"
<
<
field
-
>
full_name
(
)
;
GOOGLE_CHECK_EQ
(
FieldDescriptor
:
:
CPPTYPE_MESSAGE
field
-
>
cpp_type
(
)
)
<
<
"
Field
has
to
be
message
type
.
Field
name
is
:
"
<
<
field
-
>
full_name
(
)
;
for
(
int
i
=
0
;
i
<
key_field_paths
.
size
(
)
;
+
+
i
)
{
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
key_field_path
=
key_field_paths
[
i
]
;
for
(
int
j
=
0
;
j
<
key_field_path
.
size
(
)
;
+
+
j
)
{
const
FieldDescriptor
*
parent_field
=
j
=
=
0
?
field
:
key_field_path
[
j
-
1
]
;
const
FieldDescriptor
*
child_field
=
key_field_path
[
j
]
;
GOOGLE_CHECK
(
child_field
-
>
containing_type
(
)
=
=
parent_field
-
>
message_type
(
)
)
<
<
child_field
-
>
full_name
(
)
<
<
"
must
be
a
direct
subfield
within
the
field
:
"
<
<
parent_field
-
>
full_name
(
)
;
if
(
j
!
=
0
)
{
GOOGLE_CHECK_EQ
(
FieldDescriptor
:
:
CPPTYPE_MESSAGE
parent_field
-
>
cpp_type
(
)
)
<
<
parent_field
-
>
full_name
(
)
<
<
"
has
to
be
of
type
message
.
"
;
GOOGLE_CHECK
(
!
parent_field
-
>
is_repeated
(
)
)
<
<
parent_field
-
>
full_name
(
)
<
<
"
cannot
be
a
repeated
field
.
"
;
}
}
}
GOOGLE_CHECK
(
set_fields_
.
find
(
field
)
=
=
set_fields_
.
end
(
)
)
<
<
"
Cannot
treat
this
repeated
field
as
both
Map
and
Set
for
"
<
<
"
comparison
.
"
;
MapKeyComparator
*
key_comparator
=
new
MultipleFieldsMapKeyComparator
(
this
key_field_paths
)
;
owned_key_comparators_
.
push_back
(
key_comparator
)
;
map_field_key_comparator_
[
field
]
=
key_comparator
;
}
void
MessageDifferencer
:
:
TreatAsMapUsingKeyComparator
(
const
FieldDescriptor
*
field
const
MapKeyComparator
*
key_comparator
)
{
GOOGLE_CHECK
(
field
-
>
is_repeated
(
)
)
<
<
"
Field
must
be
repeated
:
"
<
<
field
-
>
full_name
(
)
;
GOOGLE_CHECK_EQ
(
FieldDescriptor
:
:
CPPTYPE_MESSAGE
field
-
>
cpp_type
(
)
)
<
<
"
Field
has
to
be
message
type
.
Field
name
is
:
"
<
<
field
-
>
full_name
(
)
;
GOOGLE_CHECK
(
set_fields_
.
find
(
field
)
=
=
set_fields_
.
end
(
)
)
<
<
"
Cannot
treat
this
repeated
field
as
both
Map
and
Set
for
"
<
<
"
comparison
.
"
;
map_field_key_comparator_
[
field
]
=
key_comparator
;
}
void
MessageDifferencer
:
:
AddIgnoreCriteria
(
IgnoreCriteria
*
ignore_criteria
)
{
ignore_criteria_
.
push_back
(
ignore_criteria
)
;
}
void
MessageDifferencer
:
:
IgnoreField
(
const
FieldDescriptor
*
field
)
{
ignored_fields_
.
insert
(
field
)
;
}
void
MessageDifferencer
:
:
SetFractionAndMargin
(
const
FieldDescriptor
*
field
double
fraction
double
margin
)
{
default_field_comparator_
.
SetFractionAndMargin
(
field
fraction
margin
)
;
}
void
MessageDifferencer
:
:
ReportDifferencesToString
(
string
*
output
)
{
GOOGLE_DCHECK
(
output
)
<
<
"
Specified
output
string
was
NULL
"
;
output_string_
=
output
;
output_string_
-
>
clear
(
)
;
}
void
MessageDifferencer
:
:
ReportDifferencesTo
(
Reporter
*
reporter
)
{
if
(
output_string_
)
{
output_string_
=
NULL
;
}
reporter_
=
reporter
;
}
bool
MessageDifferencer
:
:
FieldBefore
(
const
FieldDescriptor
*
field1
const
FieldDescriptor
*
field2
)
{
if
(
field1
=
=
NULL
)
{
return
false
;
}
if
(
field2
=
=
NULL
)
{
return
true
;
}
return
(
field1
-
>
number
(
)
<
field2
-
>
number
(
)
)
;
}
bool
MessageDifferencer
:
:
Compare
(
const
Message
&
message1
const
Message
&
message2
)
{
std
:
:
vector
<
SpecificField
>
parent_fields
;
bool
result
=
false
;
if
(
output_string_
)
{
io
:
:
StringOutputStream
output_stream
(
output_string_
)
;
StreamReporter
reporter
(
&
output_stream
)
;
reporter_
=
&
reporter
;
result
=
Compare
(
message1
message2
&
parent_fields
)
;
reporter_
=
NULL
;
}
else
{
result
=
Compare
(
message1
message2
&
parent_fields
)
;
}
return
result
;
}
bool
MessageDifferencer
:
:
CompareWithFields
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
message1_fields_arg
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
message2_fields_arg
)
{
if
(
message1
.
GetDescriptor
(
)
!
=
message2
.
GetDescriptor
(
)
)
{
GOOGLE_LOG
(
DFATAL
)
<
<
"
Comparison
between
two
messages
with
different
"
<
<
"
descriptors
.
"
;
return
false
;
}
std
:
:
vector
<
SpecificField
>
parent_fields
;
bool
result
=
false
;
std
:
:
vector
<
const
FieldDescriptor
*
>
message1_fields
(
message1_fields_arg
)
;
std
:
:
vector
<
const
FieldDescriptor
*
>
message2_fields
(
message2_fields_arg
)
;
std
:
:
sort
(
message1_fields
.
begin
(
)
message1_fields
.
end
(
)
FieldBefore
)
;
std
:
:
sort
(
message2_fields
.
begin
(
)
message2_fields
.
end
(
)
FieldBefore
)
;
message1_fields
.
push_back
(
NULL
)
;
message2_fields
.
push_back
(
NULL
)
;
if
(
output_string_
)
{
io
:
:
StringOutputStream
output_stream
(
output_string_
)
;
StreamReporter
reporter
(
&
output_stream
)
;
reporter_
=
&
reporter
;
result
=
CompareRequestedFieldsUsingSettings
(
message1
message2
message1_fields
message2_fields
&
parent_fields
)
;
reporter_
=
NULL
;
}
else
{
result
=
CompareRequestedFieldsUsingSettings
(
message1
message2
message1_fields
message2_fields
&
parent_fields
)
;
}
return
result
;
}
bool
MessageDifferencer
:
:
Compare
(
const
Message
&
message1
const
Message
&
message2
std
:
:
vector
<
SpecificField
>
*
parent_fields
)
{
const
Descriptor
*
descriptor1
=
message1
.
GetDescriptor
(
)
;
const
Descriptor
*
descriptor2
=
message2
.
GetDescriptor
(
)
;
if
(
descriptor1
!
=
descriptor2
)
{
GOOGLE_LOG
(
DFATAL
)
<
<
"
Comparison
between
two
messages
with
different
"
<
<
"
descriptors
.
"
<
<
descriptor1
-
>
full_name
(
)
<
<
"
vs
"
<
<
descriptor2
-
>
full_name
(
)
;
return
false
;
}
if
(
descriptor1
-
>
full_name
(
)
=
=
internal
:
:
kAnyFullTypeName
)
{
google
:
:
protobuf
:
:
scoped_ptr
<
Message
>
data1
;
google
:
:
protobuf
:
:
scoped_ptr
<
Message
>
data2
;
if
(
UnpackAny
(
message1
&
data1
)
&
&
UnpackAny
(
message2
&
data2
)
)
{
if
(
data1
-
>
GetDescriptor
(
)
!
=
data2
-
>
GetDescriptor
(
)
)
{
return
false
;
}
return
Compare
(
*
data1
*
data2
parent_fields
)
;
}
}
const
Reflection
*
reflection1
=
message1
.
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
.
GetReflection
(
)
;
std
:
:
vector
<
const
FieldDescriptor
*
>
message1_fields
;
message1_fields
.
reserve
(
1
+
message1
.
GetDescriptor
(
)
-
>
field_count
(
)
)
;
std
:
:
vector
<
const
FieldDescriptor
*
>
message2_fields
;
message2_fields
.
reserve
(
1
+
message2
.
GetDescriptor
(
)
-
>
field_count
(
)
)
;
if
(
descriptor1
-
>
options
(
)
.
map_entry
(
)
)
{
if
(
scope_
=
=
PARTIAL
)
{
reflection1
-
>
ListFields
(
message1
&
message1_fields
)
;
}
else
{
for
(
int
i
=
0
;
i
<
descriptor1
-
>
field_count
(
)
;
i
+
+
)
{
message1_fields
.
push_back
(
descriptor1
-
>
field
(
i
)
)
;
}
}
for
(
int
i
=
0
;
i
<
descriptor1
-
>
field_count
(
)
;
i
+
+
)
{
message2_fields
.
push_back
(
descriptor1
-
>
field
(
i
)
)
;
}
}
else
{
reflection1
-
>
ListFields
(
message1
&
message1_fields
)
;
reflection2
-
>
ListFields
(
message2
&
message2_fields
)
;
}
message1_fields
.
push_back
(
NULL
)
;
message2_fields
.
push_back
(
NULL
)
;
bool
unknown_compare_result
=
true
;
if
(
message_field_comparison_
!
=
EQUIVALENT
)
{
const
google
:
:
protobuf
:
:
UnknownFieldSet
*
unknown_field_set1
=
&
reflection1
-
>
GetUnknownFields
(
message1
)
;
const
google
:
:
protobuf
:
:
UnknownFieldSet
*
unknown_field_set2
=
&
reflection2
-
>
GetUnknownFields
(
message2
)
;
if
(
!
CompareUnknownFields
(
message1
message2
*
unknown_field_set1
*
unknown_field_set2
parent_fields
)
)
{
if
(
reporter_
=
=
NULL
)
{
return
false
;
}
;
unknown_compare_result
=
false
;
}
}
return
CompareRequestedFieldsUsingSettings
(
message1
message2
message1_fields
message2_fields
parent_fields
)
&
&
unknown_compare_result
;
}
bool
MessageDifferencer
:
:
CompareRequestedFieldsUsingSettings
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
message1_fields
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
message2_fields
std
:
:
vector
<
SpecificField
>
*
parent_fields
)
{
if
(
scope_
=
=
FULL
)
{
if
(
message_field_comparison_
=
=
EQUIVALENT
)
{
std
:
:
vector
<
const
FieldDescriptor
*
>
fields_union
;
CombineFields
(
message1_fields
FULL
message2_fields
FULL
&
fields_union
)
;
return
CompareWithFieldsInternal
(
message1
message2
fields_union
fields_union
parent_fields
)
;
}
else
{
return
CompareWithFieldsInternal
(
message1
message2
message1_fields
message2_fields
parent_fields
)
;
}
}
else
{
if
(
message_field_comparison_
=
=
EQUIVALENT
)
{
return
CompareWithFieldsInternal
(
message1
message2
message1_fields
message1_fields
parent_fields
)
;
}
else
{
std
:
:
vector
<
const
FieldDescriptor
*
>
fields_intersection
;
CombineFields
(
message1_fields
PARTIAL
message2_fields
PARTIAL
&
fields_intersection
)
;
return
CompareWithFieldsInternal
(
message1
message2
message1_fields
fields_intersection
parent_fields
)
;
}
}
}
void
MessageDifferencer
:
:
CombineFields
(
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
fields1
Scope
fields1_scope
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
fields2
Scope
fields2_scope
std
:
:
vector
<
const
FieldDescriptor
*
>
*
combined_fields
)
{
int
index1
=
0
;
int
index2
=
0
;
while
(
index1
<
fields1
.
size
(
)
&
&
index2
<
fields2
.
size
(
)
)
{
const
FieldDescriptor
*
field1
=
fields1
[
index1
]
;
const
FieldDescriptor
*
field2
=
fields2
[
index2
]
;
if
(
FieldBefore
(
field1
field2
)
)
{
if
(
fields1_scope
=
=
FULL
)
{
combined_fields
-
>
push_back
(
fields1
[
index1
]
)
;
}
+
+
index1
;
}
else
if
(
FieldBefore
(
field2
field1
)
)
{
if
(
fields2_scope
=
=
FULL
)
{
combined_fields
-
>
push_back
(
fields2
[
index2
]
)
;
}
+
+
index2
;
}
else
{
combined_fields
-
>
push_back
(
fields1
[
index1
]
)
;
+
+
index1
;
+
+
index2
;
}
}
}
bool
MessageDifferencer
:
:
CompareWithFieldsInternal
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
message1_fields
const
std
:
:
vector
<
const
FieldDescriptor
*
>
&
message2_fields
std
:
:
vector
<
SpecificField
>
*
parent_fields
)
{
bool
isDifferent
=
false
;
int
field_index1
=
0
;
int
field_index2
=
0
;
const
Reflection
*
reflection1
=
message1
.
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
.
GetReflection
(
)
;
while
(
true
)
{
const
FieldDescriptor
*
field1
=
message1_fields
[
field_index1
]
;
const
FieldDescriptor
*
field2
=
message2_fields
[
field_index2
]
;
if
(
field1
=
=
NULL
&
&
field2
=
=
NULL
)
{
break
;
}
if
(
FieldBefore
(
field1
field2
)
)
{
if
(
IsIgnored
(
message1
message2
field1
*
parent_fields
)
)
{
if
(
reporter_
!
=
NULL
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field1
;
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportIgnored
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
}
+
+
field_index1
;
continue
;
}
if
(
reporter_
!
=
NULL
)
{
assert
(
field1
!
=
NULL
)
;
int
count
=
field1
-
>
is_repeated
(
)
?
reflection1
-
>
FieldSize
(
message1
field1
)
:
1
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field1
;
specific_field
.
index
=
field1
-
>
is_repeated
(
)
?
i
:
-
1
;
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportDeleted
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
}
isDifferent
=
true
;
}
else
{
return
false
;
}
+
+
field_index1
;
continue
;
}
else
if
(
FieldBefore
(
field2
field1
)
)
{
if
(
IsIgnored
(
message1
message2
field2
*
parent_fields
)
)
{
if
(
reporter_
!
=
NULL
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field2
;
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportIgnored
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
}
+
+
field_index2
;
continue
;
}
if
(
reporter_
!
=
NULL
)
{
int
count
=
field2
-
>
is_repeated
(
)
?
reflection2
-
>
FieldSize
(
message2
field2
)
:
1
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field2
;
specific_field
.
index
=
field2
-
>
is_repeated
(
)
?
i
:
-
1
;
specific_field
.
new_index
=
specific_field
.
index
;
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportAdded
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
}
isDifferent
=
true
;
}
else
{
return
false
;
}
+
+
field_index2
;
continue
;
}
if
(
IsIgnored
(
message1
message2
field1
*
parent_fields
)
)
{
if
(
reporter_
!
=
NULL
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field1
;
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportIgnored
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
}
+
+
field_index1
;
+
+
field_index2
;
continue
;
}
bool
fieldDifferent
=
false
;
assert
(
field1
!
=
NULL
)
;
if
(
field1
-
>
is_repeated
(
)
)
{
fieldDifferent
=
!
CompareRepeatedField
(
message1
message2
field1
parent_fields
)
;
if
(
fieldDifferent
)
{
if
(
reporter_
=
=
NULL
)
return
false
;
isDifferent
=
true
;
}
}
else
{
fieldDifferent
=
!
CompareFieldValueUsingParentFields
(
message1
message2
field1
-
1
-
1
parent_fields
)
;
if
(
fieldDifferent
&
&
reporter_
=
=
NULL
)
{
return
false
;
}
if
(
reporter_
!
=
NULL
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field1
;
parent_fields
-
>
push_back
(
specific_field
)
;
if
(
fieldDifferent
)
{
reporter_
-
>
ReportModified
(
message1
message2
*
parent_fields
)
;
isDifferent
=
true
;
}
else
if
(
report_matches_
)
{
reporter_
-
>
ReportMatched
(
message1
message2
*
parent_fields
)
;
}
parent_fields
-
>
pop_back
(
)
;
}
}
+
+
field_index1
;
+
+
field_index2
;
}
return
!
isDifferent
;
}
bool
MessageDifferencer
:
:
IsMatch
(
const
FieldDescriptor
*
repeated_field
const
MapKeyComparator
*
key_comparator
const
Message
*
message1
const
Message
*
message2
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
int
index1
int
index2
)
{
std
:
:
vector
<
SpecificField
>
current_parent_fields
(
parent_fields
)
;
if
(
repeated_field
-
>
cpp_type
(
)
!
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
return
CompareFieldValueUsingParentFields
(
*
message1
*
message2
repeated_field
index1
index2
&
current_parent_fields
)
;
}
Reporter
*
backup_reporter
=
reporter_
;
string
*
output_string
=
output_string_
;
reporter_
=
NULL
;
output_string_
=
NULL
;
bool
match
;
if
(
key_comparator
=
=
NULL
)
{
match
=
CompareFieldValueUsingParentFields
(
*
message1
*
message2
repeated_field
index1
index2
&
current_parent_fields
)
;
}
else
{
const
Reflection
*
reflection1
=
message1
-
>
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
-
>
GetReflection
(
)
;
const
Message
&
m1
=
reflection1
-
>
GetRepeatedMessage
(
*
message1
repeated_field
index1
)
;
const
Message
&
m2
=
reflection2
-
>
GetRepeatedMessage
(
*
message2
repeated_field
index2
)
;
SpecificField
specific_field
;
specific_field
.
field
=
repeated_field
;
specific_field
.
index
=
index1
;
specific_field
.
new_index
=
index2
;
current_parent_fields
.
push_back
(
specific_field
)
;
match
=
key_comparator
-
>
IsMatch
(
m1
m2
current_parent_fields
)
;
}
reporter_
=
backup_reporter
;
output_string_
=
output_string
;
return
match
;
}
bool
MessageDifferencer
:
:
CompareRepeatedField
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
repeated_field
std
:
:
vector
<
SpecificField
>
*
parent_fields
)
{
const
Reflection
*
reflection1
=
message1
.
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
.
GetReflection
(
)
;
const
int
count1
=
reflection1
-
>
FieldSize
(
message1
repeated_field
)
;
const
int
count2
=
reflection2
-
>
FieldSize
(
message2
repeated_field
)
;
const
bool
treated_as_subset
=
IsTreatedAsSubset
(
repeated_field
)
;
if
(
count1
!
=
count2
&
&
reporter_
=
=
NULL
&
&
!
treated_as_subset
)
{
return
false
;
}
if
(
count1
>
count2
&
&
reporter_
=
=
NULL
)
{
return
false
;
}
std
:
:
vector
<
int
>
match_list1
;
std
:
:
vector
<
int
>
match_list2
;
if
(
!
MatchRepeatedFieldIndices
(
message1
message2
repeated_field
*
parent_fields
&
match_list1
&
match_list2
)
&
&
reporter_
=
=
NULL
)
{
return
false
;
}
bool
fieldDifferent
=
false
;
SpecificField
specific_field
;
specific_field
.
field
=
repeated_field
;
for
(
int
i
=
0
;
i
<
count1
;
i
+
+
)
{
if
(
match_list1
[
i
]
=
=
-
1
)
continue
;
specific_field
.
index
=
i
;
specific_field
.
new_index
=
match_list1
[
i
]
;
const
bool
result
=
CompareFieldValueUsingParentFields
(
message1
message2
repeated_field
i
specific_field
.
new_index
parent_fields
)
;
if
(
!
result
)
{
if
(
reporter_
=
=
NULL
)
return
false
;
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportModified
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
fieldDifferent
=
true
;
}
else
if
(
reporter_
!
=
NULL
&
&
specific_field
.
index
!
=
specific_field
.
new_index
&
&
!
specific_field
.
field
-
>
is_map
(
)
&
&
report_moves_
)
{
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportMoved
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
}
else
if
(
report_matches_
&
&
reporter_
!
=
NULL
)
{
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportMatched
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
}
}
for
(
int
i
=
0
;
i
<
count2
;
+
+
i
)
{
if
(
match_list2
[
i
]
!
=
-
1
)
continue
;
if
(
!
treated_as_subset
)
{
fieldDifferent
=
true
;
}
if
(
reporter_
=
=
NULL
)
continue
;
specific_field
.
index
=
i
;
specific_field
.
new_index
=
i
;
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportAdded
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
}
for
(
int
i
=
0
;
i
<
count1
;
+
+
i
)
{
if
(
match_list1
[
i
]
!
=
-
1
)
continue
;
assert
(
reporter_
!
=
NULL
)
;
specific_field
.
index
=
i
;
parent_fields
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportDeleted
(
message1
message2
*
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
fieldDifferent
=
true
;
}
return
!
fieldDifferent
;
}
bool
MessageDifferencer
:
:
CompareFieldValue
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
field
int
index1
int
index2
)
{
return
CompareFieldValueUsingParentFields
(
message1
message2
field
index1
index2
NULL
)
;
}
bool
MessageDifferencer
:
:
CompareFieldValueUsingParentFields
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
field
int
index1
int
index2
std
:
:
vector
<
SpecificField
>
*
parent_fields
)
{
FieldContext
field_context
(
parent_fields
)
;
FieldComparator
:
:
ComparisonResult
result
=
GetFieldComparisonResult
(
message1
message2
field
index1
index2
&
field_context
)
;
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
&
&
result
=
=
FieldComparator
:
:
RECURSE
)
{
const
Reflection
*
reflection1
=
message1
.
GetReflection
(
)
;
const
Reflection
*
reflection2
=
message2
.
GetReflection
(
)
;
const
Message
&
m1
=
field
-
>
is_repeated
(
)
?
reflection1
-
>
GetRepeatedMessage
(
message1
field
index1
)
:
reflection1
-
>
GetMessage
(
message1
field
)
;
const
Message
&
m2
=
field
-
>
is_repeated
(
)
?
reflection2
-
>
GetRepeatedMessage
(
message2
field
index2
)
:
reflection2
-
>
GetMessage
(
message2
field
)
;
if
(
parent_fields
!
=
NULL
)
{
SpecificField
specific_field
;
specific_field
.
field
=
field
;
specific_field
.
index
=
index1
;
specific_field
.
new_index
=
index2
;
parent_fields
-
>
push_back
(
specific_field
)
;
const
bool
compare_result
=
Compare
(
m1
m2
parent_fields
)
;
parent_fields
-
>
pop_back
(
)
;
return
compare_result
;
}
else
{
return
Compare
(
m1
m2
)
;
}
}
else
{
return
(
result
=
=
FieldComparator
:
:
SAME
)
;
}
}
bool
MessageDifferencer
:
:
CheckPathChanged
(
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
for
(
int
i
=
0
;
i
<
field_path
.
size
(
)
;
+
+
i
)
{
if
(
field_path
[
i
]
.
field
!
=
NULL
&
&
field_path
[
i
]
.
field
-
>
is_map
(
)
)
continue
;
if
(
field_path
[
i
]
.
index
!
=
field_path
[
i
]
.
new_index
)
return
true
;
}
return
false
;
}
bool
MessageDifferencer
:
:
IsTreatedAsSet
(
const
FieldDescriptor
*
field
)
{
if
(
!
field
-
>
is_repeated
(
)
)
return
false
;
if
(
repeated_field_comparison_
=
=
AS_SET
)
return
list_fields_
.
find
(
field
)
=
=
list_fields_
.
end
(
)
;
return
(
set_fields_
.
find
(
field
)
!
=
set_fields_
.
end
(
)
)
;
}
bool
MessageDifferencer
:
:
IsTreatedAsSubset
(
const
FieldDescriptor
*
field
)
{
return
scope_
=
=
PARTIAL
&
&
(
IsTreatedAsSet
(
field
)
|
|
GetMapKeyComparator
(
field
)
!
=
NULL
)
;
}
bool
MessageDifferencer
:
:
IsIgnored
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
field
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
)
{
if
(
ignored_fields_
.
find
(
field
)
!
=
ignored_fields_
.
end
(
)
)
{
return
true
;
}
for
(
int
i
=
0
;
i
<
ignore_criteria_
.
size
(
)
;
+
+
i
)
{
if
(
ignore_criteria_
[
i
]
-
>
IsIgnored
(
message1
message2
field
parent_fields
)
)
{
return
true
;
}
}
return
false
;
}
bool
MessageDifferencer
:
:
IsUnknownFieldIgnored
(
const
Message
&
message1
const
Message
&
message2
const
SpecificField
&
field
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
)
{
for
(
int
i
=
0
;
i
<
ignore_criteria_
.
size
(
)
;
+
+
i
)
{
if
(
ignore_criteria_
[
i
]
-
>
IsUnknownFieldIgnored
(
message1
message2
field
parent_fields
)
)
{
return
true
;
}
}
return
false
;
}
const
MessageDifferencer
:
:
MapKeyComparator
*
MessageDifferencer
:
:
GetMapKeyComparator
(
const
FieldDescriptor
*
field
)
const
{
if
(
!
field
-
>
is_repeated
(
)
)
return
NULL
;
FieldKeyComparatorMap
:
:
const_iterator
it
=
map_field_key_comparator_
.
find
(
field
)
;
if
(
it
!
=
map_field_key_comparator_
.
end
(
)
)
{
return
it
-
>
second
;
}
if
(
field
-
>
is_map
(
)
)
{
return
&
map_entry_key_comparator_
;
}
return
NULL
;
}
namespace
{
typedef
std
:
:
pair
<
int
const
UnknownField
*
>
IndexUnknownFieldPair
;
struct
UnknownFieldOrdering
{
inline
bool
operator
(
)
(
const
IndexUnknownFieldPair
&
a
const
IndexUnknownFieldPair
&
b
)
const
{
if
(
a
.
second
-
>
number
(
)
<
b
.
second
-
>
number
(
)
)
return
true
;
if
(
a
.
second
-
>
number
(
)
>
b
.
second
-
>
number
(
)
)
return
false
;
return
a
.
second
-
>
type
(
)
<
b
.
second
-
>
type
(
)
;
}
}
;
}
bool
MessageDifferencer
:
:
UnpackAny
(
const
Message
&
any
google
:
:
protobuf
:
:
scoped_ptr
<
Message
>
*
data
)
{
const
Reflection
*
reflection
=
any
.
GetReflection
(
)
;
const
FieldDescriptor
*
type_url_field
;
const
FieldDescriptor
*
value_field
;
if
(
!
internal
:
:
GetAnyFieldDescriptors
(
any
&
type_url_field
&
value_field
)
)
{
return
false
;
}
const
string
&
type_url
=
reflection
-
>
GetString
(
any
type_url_field
)
;
string
full_type_name
;
if
(
!
internal
:
:
ParseAnyTypeUrl
(
type_url
&
full_type_name
)
)
{
return
false
;
}
const
google
:
:
protobuf
:
:
Descriptor
*
desc
=
any
.
GetDescriptor
(
)
-
>
file
(
)
-
>
pool
(
)
-
>
FindMessageTypeByName
(
full_type_name
)
;
if
(
desc
=
=
NULL
)
{
GOOGLE_DLOG
(
ERROR
)
<
<
"
Proto
type
'
"
<
<
full_type_name
<
<
"
'
not
found
"
;
return
false
;
}
if
(
dynamic_message_factory_
=
=
NULL
)
{
dynamic_message_factory_
.
reset
(
new
DynamicMessageFactory
(
)
)
;
}
data
-
>
reset
(
dynamic_message_factory_
-
>
GetPrototype
(
desc
)
-
>
New
(
)
)
;
string
serialized_value
=
reflection
-
>
GetString
(
any
value_field
)
;
if
(
!
(
*
data
)
-
>
ParseFromString
(
serialized_value
)
)
{
GOOGLE_DLOG
(
ERROR
)
<
<
"
Failed
to
parse
value
for
"
<
<
full_type_name
;
return
false
;
}
return
true
;
}
bool
MessageDifferencer
:
:
CompareUnknownFields
(
const
Message
&
message1
const
Message
&
message2
const
google
:
:
protobuf
:
:
UnknownFieldSet
&
unknown_field_set1
const
google
:
:
protobuf
:
:
UnknownFieldSet
&
unknown_field_set2
std
:
:
vector
<
SpecificField
>
*
parent_field
)
{
if
(
message_field_comparison_
=
=
EQUIVALENT
)
return
true
;
if
(
unknown_field_set1
.
empty
(
)
&
&
unknown_field_set2
.
empty
(
)
)
{
return
true
;
}
bool
is_different
=
false
;
std
:
:
vector
<
IndexUnknownFieldPair
>
fields1
;
std
:
:
vector
<
IndexUnknownFieldPair
>
fields2
;
fields1
.
reserve
(
unknown_field_set1
.
field_count
(
)
)
;
fields2
.
reserve
(
unknown_field_set2
.
field_count
(
)
)
;
for
(
int
i
=
0
;
i
<
unknown_field_set1
.
field_count
(
)
;
i
+
+
)
{
fields1
.
push_back
(
std
:
:
make_pair
(
i
&
unknown_field_set1
.
field
(
i
)
)
)
;
}
for
(
int
i
=
0
;
i
<
unknown_field_set2
.
field_count
(
)
;
i
+
+
)
{
fields2
.
push_back
(
std
:
:
make_pair
(
i
&
unknown_field_set2
.
field
(
i
)
)
)
;
}
UnknownFieldOrdering
is_before
;
std
:
:
stable_sort
(
fields1
.
begin
(
)
fields1
.
end
(
)
is_before
)
;
std
:
:
stable_sort
(
fields2
.
begin
(
)
fields2
.
end
(
)
is_before
)
;
const
UnknownField
*
current_repeated
=
NULL
;
int
current_repeated_start1
=
0
;
int
current_repeated_start2
=
0
;
int
index1
=
0
;
int
index2
=
0
;
while
(
index1
<
fields1
.
size
(
)
|
|
index2
<
fields2
.
size
(
)
)
{
enum
{
ADDITION
DELETION
MODIFICATION
COMPARE_GROUPS
NO_CHANGE
}
change_type
;
const
UnknownField
*
focus_field
;
bool
match
=
false
;
if
(
index2
=
=
fields2
.
size
(
)
|
|
(
index1
<
fields1
.
size
(
)
&
&
is_before
(
fields1
[
index1
]
fields2
[
index2
]
)
)
)
{
change_type
=
DELETION
;
focus_field
=
fields1
[
index1
]
.
second
;
}
else
if
(
index1
=
=
fields1
.
size
(
)
|
|
is_before
(
fields2
[
index2
]
fields1
[
index1
]
)
)
{
if
(
scope_
=
=
PARTIAL
)
{
+
+
index2
;
continue
;
}
change_type
=
ADDITION
;
focus_field
=
fields2
[
index2
]
.
second
;
}
else
{
change_type
=
MODIFICATION
;
focus_field
=
fields1
[
index1
]
.
second
;
switch
(
focus_field
-
>
type
(
)
)
{
case
UnknownField
:
:
TYPE_VARINT
:
match
=
fields1
[
index1
]
.
second
-
>
varint
(
)
=
=
fields2
[
index2
]
.
second
-
>
varint
(
)
;
break
;
case
UnknownField
:
:
TYPE_FIXED32
:
match
=
fields1
[
index1
]
.
second
-
>
fixed32
(
)
=
=
fields2
[
index2
]
.
second
-
>
fixed32
(
)
;
break
;
case
UnknownField
:
:
TYPE_FIXED64
:
match
=
fields1
[
index1
]
.
second
-
>
fixed64
(
)
=
=
fields2
[
index2
]
.
second
-
>
fixed64
(
)
;
break
;
case
UnknownField
:
:
TYPE_LENGTH_DELIMITED
:
match
=
fields1
[
index1
]
.
second
-
>
length_delimited
(
)
=
=
fields2
[
index2
]
.
second
-
>
length_delimited
(
)
;
break
;
case
UnknownField
:
:
TYPE_GROUP
:
change_type
=
COMPARE_GROUPS
;
break
;
}
if
(
match
&
&
change_type
!
=
COMPARE_GROUPS
)
{
change_type
=
NO_CHANGE
;
}
}
if
(
current_repeated
=
=
NULL
|
|
focus_field
-
>
number
(
)
!
=
current_repeated
-
>
number
(
)
|
|
focus_field
-
>
type
(
)
!
=
current_repeated
-
>
type
(
)
)
{
current_repeated
=
focus_field
;
current_repeated_start1
=
index1
;
current_repeated_start2
=
index2
;
}
if
(
change_type
=
=
NO_CHANGE
&
&
reporter_
=
=
NULL
)
{
+
+
index1
;
+
+
index2
;
continue
;
}
SpecificField
specific_field
;
specific_field
.
unknown_field_number
=
focus_field
-
>
number
(
)
;
specific_field
.
unknown_field_type
=
focus_field
-
>
type
(
)
;
specific_field
.
unknown_field_set1
=
&
unknown_field_set1
;
specific_field
.
unknown_field_set2
=
&
unknown_field_set2
;
if
(
change_type
!
=
ADDITION
)
{
specific_field
.
unknown_field_index1
=
fields1
[
index1
]
.
first
;
}
if
(
change_type
!
=
DELETION
)
{
specific_field
.
unknown_field_index2
=
fields2
[
index2
]
.
first
;
}
if
(
change_type
=
=
ADDITION
)
{
specific_field
.
index
=
index2
-
current_repeated_start2
;
specific_field
.
new_index
=
index2
-
current_repeated_start2
;
}
else
{
specific_field
.
index
=
index1
-
current_repeated_start1
;
specific_field
.
new_index
=
index2
-
current_repeated_start2
;
}
if
(
IsUnknownFieldIgnored
(
message1
message2
specific_field
*
parent_field
)
)
{
if
(
reporter_
!
=
NULL
)
{
parent_field
-
>
push_back
(
specific_field
)
;
reporter_
-
>
ReportUnknownFieldIgnored
(
message1
message2
*
parent_field
)
;
parent_field
-
>
pop_back
(
)
;
}
return
true
;
}
if
(
change_type
=
=
ADDITION
|
|
change_type
=
=
DELETION
|
|
change_type
=
=
MODIFICATION
)
{
if
(
reporter_
=
=
NULL
)
{
return
false
;
}
is_different
=
true
;
}
parent_field
-
>
push_back
(
specific_field
)
;
switch
(
change_type
)
{
case
ADDITION
:
reporter_
-
>
ReportAdded
(
message1
message2
*
parent_field
)
;
+
+
index2
;
break
;
case
DELETION
:
reporter_
-
>
ReportDeleted
(
message1
message2
*
parent_field
)
;
+
+
index1
;
break
;
case
MODIFICATION
:
reporter_
-
>
ReportModified
(
message1
message2
*
parent_field
)
;
+
+
index1
;
+
+
index2
;
break
;
case
COMPARE_GROUPS
:
if
(
!
CompareUnknownFields
(
message1
message2
fields1
[
index1
]
.
second
-
>
group
(
)
fields2
[
index2
]
.
second
-
>
group
(
)
parent_field
)
)
{
if
(
reporter_
=
=
NULL
)
return
false
;
is_different
=
true
;
reporter_
-
>
ReportModified
(
message1
message2
*
parent_field
)
;
}
+
+
index1
;
+
+
index2
;
break
;
case
NO_CHANGE
:
+
+
index1
;
+
+
index2
;
if
(
report_matches_
)
{
reporter_
-
>
ReportMatched
(
message1
message2
*
parent_field
)
;
}
}
parent_field
-
>
pop_back
(
)
;
}
return
!
is_different
;
}
namespace
{
class
MaximumMatcher
{
public
:
typedef
ResultCallback2
<
bool
int
int
>
NodeMatchCallback
;
MaximumMatcher
(
int
count1
int
count2
NodeMatchCallback
*
callback
std
:
:
vector
<
int
>
*
match_list1
std
:
:
vector
<
int
>
*
match_list2
)
;
int
FindMaximumMatch
(
bool
early_return
)
;
private
:
bool
Match
(
int
left
int
right
)
;
bool
FindArgumentPathDFS
(
int
v
std
:
:
vector
<
bool
>
*
visited
)
;
int
count1_
;
int
count2_
;
google
:
:
protobuf
:
:
scoped_ptr
<
NodeMatchCallback
>
match_callback_
;
std
:
:
map
<
std
:
:
pair
<
int
int
>
bool
>
cached_match_results_
;
std
:
:
vector
<
int
>
*
match_list1_
;
std
:
:
vector
<
int
>
*
match_list2_
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
MaximumMatcher
)
;
}
;
MaximumMatcher
:
:
MaximumMatcher
(
int
count1
int
count2
NodeMatchCallback
*
callback
std
:
:
vector
<
int
>
*
match_list1
std
:
:
vector
<
int
>
*
match_list2
)
:
count1_
(
count1
)
count2_
(
count2
)
match_callback_
(
callback
)
match_list1_
(
match_list1
)
match_list2_
(
match_list2
)
{
match_list1_
-
>
assign
(
count1
-
1
)
;
match_list2_
-
>
assign
(
count2
-
1
)
;
}
int
MaximumMatcher
:
:
FindMaximumMatch
(
bool
early_return
)
{
int
result
=
0
;
for
(
int
i
=
0
;
i
<
count1_
;
+
+
i
)
{
std
:
:
vector
<
bool
>
visited
(
count1_
)
;
if
(
FindArgumentPathDFS
(
i
&
visited
)
)
{
+
+
result
;
}
else
if
(
early_return
)
{
return
0
;
}
}
for
(
int
i
=
0
;
i
<
count2_
;
+
+
i
)
{
if
(
(
*
match_list2_
)
[
i
]
!
=
-
1
)
{
(
*
match_list1_
)
[
(
*
match_list2_
)
[
i
]
]
=
i
;
}
}
return
result
;
}
bool
MaximumMatcher
:
:
Match
(
int
left
int
right
)
{
std
:
:
pair
<
int
int
>
p
(
left
right
)
;
std
:
:
map
<
std
:
:
pair
<
int
int
>
bool
>
:
:
iterator
it
=
cached_match_results_
.
find
(
p
)
;
if
(
it
!
=
cached_match_results_
.
end
(
)
)
{
return
it
-
>
second
;
}
cached_match_results_
[
p
]
=
match_callback_
-
>
Run
(
left
right
)
;
return
cached_match_results_
[
p
]
;
}
bool
MaximumMatcher
:
:
FindArgumentPathDFS
(
int
v
std
:
:
vector
<
bool
>
*
visited
)
{
(
*
visited
)
[
v
]
=
true
;
for
(
int
i
=
0
;
i
<
count2_
;
+
+
i
)
{
int
matched
=
(
*
match_list2_
)
[
i
]
;
if
(
matched
=
=
-
1
&
&
Match
(
v
i
)
)
{
(
*
match_list2_
)
[
i
]
=
v
;
return
true
;
}
}
for
(
int
i
=
0
;
i
<
count2_
;
+
+
i
)
{
int
matched
=
(
*
match_list2_
)
[
i
]
;
if
(
matched
!
=
-
1
&
&
Match
(
v
i
)
)
{
if
(
!
(
*
visited
)
[
matched
]
&
&
FindArgumentPathDFS
(
matched
visited
)
)
{
(
*
match_list2_
)
[
i
]
=
v
;
return
true
;
}
}
}
return
false
;
}
}
bool
MessageDifferencer
:
:
MatchRepeatedFieldIndices
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
repeated_field
const
std
:
:
vector
<
SpecificField
>
&
parent_fields
std
:
:
vector
<
int
>
*
match_list1
std
:
:
vector
<
int
>
*
match_list2
)
{
const
int
count1
=
message1
.
GetReflection
(
)
-
>
FieldSize
(
message1
repeated_field
)
;
const
int
count2
=
message2
.
GetReflection
(
)
-
>
FieldSize
(
message2
repeated_field
)
;
const
MapKeyComparator
*
key_comparator
=
GetMapKeyComparator
(
repeated_field
)
;
match_list1
-
>
assign
(
count1
-
1
)
;
match_list2
-
>
assign
(
count2
-
1
)
;
SpecificField
specific_field
;
specific_field
.
field
=
repeated_field
;
bool
success
=
true
;
if
(
key_comparator
!
=
NULL
|
|
IsTreatedAsSet
(
repeated_field
)
)
{
if
(
scope_
=
=
PARTIAL
)
{
MaximumMatcher
:
:
NodeMatchCallback
*
callback
=
:
:
google
:
:
protobuf
:
:
NewPermanentCallback
(
this
&
MessageDifferencer
:
:
IsMatch
repeated_field
key_comparator
&
message1
&
message2
parent_fields
)
;
MaximumMatcher
matcher
(
count1
count2
callback
match_list1
match_list2
)
;
bool
early_return
=
(
reporter_
=
=
NULL
)
;
int
match_count
=
matcher
.
FindMaximumMatch
(
early_return
)
;
if
(
match_count
!
=
count1
&
&
reporter_
=
=
NULL
)
return
false
;
success
=
success
&
&
(
match_count
=
=
count1
)
;
}
else
{
for
(
int
i
=
0
;
i
<
count1
;
+
+
i
)
{
bool
match
=
false
;
specific_field
.
index
=
i
;
specific_field
.
new_index
=
i
;
for
(
int
j
=
0
;
j
<
count2
;
j
+
+
)
{
if
(
match_list2
-
>
at
(
j
)
!
=
-
1
)
continue
;
specific_field
.
index
=
i
;
specific_field
.
new_index
=
j
;
match
=
IsMatch
(
repeated_field
key_comparator
&
message1
&
message2
parent_fields
i
j
)
;
if
(
match
)
{
match_list1
-
>
at
(
specific_field
.
index
)
=
specific_field
.
new_index
;
match_list2
-
>
at
(
specific_field
.
new_index
)
=
specific_field
.
index
;
break
;
}
}
if
(
!
match
&
&
reporter_
=
=
NULL
)
return
false
;
success
=
success
&
&
match
;
}
}
}
else
{
for
(
int
i
=
0
;
i
<
count1
&
&
i
<
count2
;
i
+
+
)
{
match_list1
-
>
at
(
i
)
=
i
;
match_list2
-
>
at
(
i
)
=
i
;
}
}
return
success
;
}
FieldComparator
:
:
ComparisonResult
MessageDifferencer
:
:
GetFieldComparisonResult
(
const
Message
&
message1
const
Message
&
message2
const
FieldDescriptor
*
field
int
index1
int
index2
const
FieldContext
*
field_context
)
{
FieldComparator
*
comparator
=
field_comparator_
!
=
NULL
?
field_comparator_
:
&
default_field_comparator_
;
return
comparator
-
>
Compare
(
message1
message2
field
index1
index2
field_context
)
;
}
MessageDifferencer
:
:
Reporter
:
:
Reporter
(
)
{
}
MessageDifferencer
:
:
Reporter
:
:
~
Reporter
(
)
{
}
MessageDifferencer
:
:
MapKeyComparator
:
:
MapKeyComparator
(
)
{
}
MessageDifferencer
:
:
MapKeyComparator
:
:
~
MapKeyComparator
(
)
{
}
MessageDifferencer
:
:
IgnoreCriteria
:
:
IgnoreCriteria
(
)
{
}
MessageDifferencer
:
:
IgnoreCriteria
:
:
~
IgnoreCriteria
(
)
{
}
MessageDifferencer
:
:
StreamReporter
:
:
StreamReporter
(
io
:
:
ZeroCopyOutputStream
*
output
)
:
printer_
(
new
io
:
:
Printer
(
output
'
'
)
)
delete_printer_
(
true
)
report_modified_aggregates_
(
false
)
{
}
MessageDifferencer
:
:
StreamReporter
:
:
StreamReporter
(
io
:
:
Printer
*
printer
)
:
printer_
(
printer
)
delete_printer_
(
false
)
report_modified_aggregates_
(
false
)
{
}
MessageDifferencer
:
:
StreamReporter
:
:
~
StreamReporter
(
)
{
if
(
delete_printer_
)
delete
printer_
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
PrintPath
(
const
std
:
:
vector
<
SpecificField
>
&
field_path
bool
left_side
)
{
for
(
int
i
=
0
;
i
<
field_path
.
size
(
)
;
+
+
i
)
{
if
(
i
>
0
)
{
printer_
-
>
Print
(
"
.
"
)
;
}
SpecificField
specific_field
=
field_path
[
i
]
;
if
(
specific_field
.
field
!
=
NULL
)
{
if
(
specific_field
.
field
-
>
is_extension
(
)
)
{
printer_
-
>
Print
(
"
(
name
)
"
"
name
"
specific_field
.
field
-
>
full_name
(
)
)
;
}
else
{
printer_
-
>
PrintRaw
(
specific_field
.
field
-
>
name
(
)
)
;
}
if
(
specific_field
.
field
-
>
is_map
(
)
)
{
continue
;
}
}
else
{
printer_
-
>
PrintRaw
(
SimpleItoa
(
specific_field
.
unknown_field_number
)
)
;
}
if
(
left_side
&
&
specific_field
.
index
>
=
0
)
{
printer_
-
>
Print
(
"
[
name
]
"
"
name
"
SimpleItoa
(
specific_field
.
index
)
)
;
}
if
(
!
left_side
&
&
specific_field
.
new_index
>
=
0
)
{
printer_
-
>
Print
(
"
[
name
]
"
"
name
"
SimpleItoa
(
specific_field
.
new_index
)
)
;
}
}
}
void
MessageDifferencer
:
:
StreamReporter
:
:
PrintPath
(
const
std
:
:
vector
<
SpecificField
>
&
field_path
bool
left_side
const
Message
&
message
)
{
PrintPath
(
field_path
left_side
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
PrintValue
(
const
Message
&
message
const
std
:
:
vector
<
SpecificField
>
&
field_path
bool
left_side
)
{
const
SpecificField
&
specific_field
=
field_path
.
back
(
)
;
const
FieldDescriptor
*
field
=
specific_field
.
field
;
if
(
field
!
=
NULL
)
{
string
output
;
int
index
=
left_side
?
specific_field
.
index
:
specific_field
.
new_index
;
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
const
Reflection
*
reflection
=
message
.
GetReflection
(
)
;
const
Message
&
field_message
=
field
-
>
is_repeated
(
)
?
reflection
-
>
GetRepeatedMessage
(
message
field
index
)
:
reflection
-
>
GetMessage
(
message
field
)
;
output
=
field_message
.
ShortDebugString
(
)
;
if
(
output
.
empty
(
)
)
{
printer_
-
>
Print
(
"
{
}
"
)
;
}
else
{
printer_
-
>
Print
(
"
{
name
}
"
"
name
"
output
)
;
}
}
else
{
TextFormat
:
:
PrintFieldValueToString
(
message
field
index
&
output
)
;
printer_
-
>
PrintRaw
(
output
)
;
}
}
else
{
const
UnknownFieldSet
*
unknown_fields
=
(
left_side
?
specific_field
.
unknown_field_set1
:
specific_field
.
unknown_field_set2
)
;
const
UnknownField
*
unknown_field
=
&
unknown_fields
-
>
field
(
left_side
?
specific_field
.
unknown_field_index1
:
specific_field
.
unknown_field_index2
)
;
PrintUnknownFieldValue
(
unknown_field
)
;
}
}
void
MessageDifferencer
:
:
StreamReporter
:
:
PrintUnknownFieldValue
(
const
UnknownField
*
unknown_field
)
{
GOOGLE_CHECK
(
unknown_field
!
=
NULL
)
<
<
"
Cannot
print
NULL
unknown_field
.
"
;
string
output
;
switch
(
unknown_field
-
>
type
(
)
)
{
case
UnknownField
:
:
TYPE_VARINT
:
output
=
SimpleItoa
(
unknown_field
-
>
varint
(
)
)
;
break
;
case
UnknownField
:
:
TYPE_FIXED32
:
output
=
StrCat
(
"
0x
"
strings
:
:
Hex
(
unknown_field
-
>
fixed32
(
)
strings
:
:
ZERO_PAD_8
)
)
;
break
;
case
UnknownField
:
:
TYPE_FIXED64
:
output
=
StrCat
(
"
0x
"
strings
:
:
Hex
(
unknown_field
-
>
fixed64
(
)
strings
:
:
ZERO_PAD_16
)
)
;
break
;
case
UnknownField
:
:
TYPE_LENGTH_DELIMITED
:
output
=
StringPrintf
(
"
\
"
%
s
\
"
"
CEscape
(
unknown_field
-
>
length_delimited
(
)
)
.
c_str
(
)
)
;
break
;
case
UnknownField
:
:
TYPE_GROUP
:
output
=
"
{
.
.
.
}
"
;
break
;
}
printer_
-
>
PrintRaw
(
output
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
Print
(
const
string
&
str
)
{
printer_
-
>
Print
(
str
.
c_str
(
)
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportAdded
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
printer_
-
>
Print
(
"
added
:
"
)
;
PrintPath
(
field_path
false
message2
)
;
printer_
-
>
Print
(
"
:
"
)
;
PrintValue
(
message2
field_path
false
)
;
printer_
-
>
Print
(
"
\
n
"
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportDeleted
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
printer_
-
>
Print
(
"
deleted
:
"
)
;
PrintPath
(
field_path
true
message1
)
;
printer_
-
>
Print
(
"
:
"
)
;
PrintValue
(
message1
field_path
true
)
;
printer_
-
>
Print
(
"
\
n
"
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportModified
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
if
(
!
report_modified_aggregates_
&
&
field_path
.
back
(
)
.
field
=
=
NULL
)
{
if
(
field_path
.
back
(
)
.
unknown_field_type
=
=
UnknownField
:
:
TYPE_GROUP
)
{
return
;
}
}
else
if
(
!
report_modified_aggregates_
)
{
if
(
field_path
.
back
(
)
.
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
return
;
}
}
printer_
-
>
Print
(
"
modified
:
"
)
;
PrintPath
(
field_path
true
message1
)
;
if
(
CheckPathChanged
(
field_path
)
)
{
printer_
-
>
Print
(
"
-
>
"
)
;
PrintPath
(
field_path
false
message2
)
;
}
printer_
-
>
Print
(
"
:
"
)
;
PrintValue
(
message1
field_path
true
)
;
printer_
-
>
Print
(
"
-
>
"
)
;
PrintValue
(
message2
field_path
false
)
;
printer_
-
>
Print
(
"
\
n
"
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportMoved
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
printer_
-
>
Print
(
"
moved
:
"
)
;
PrintPath
(
field_path
true
message1
)
;
printer_
-
>
Print
(
"
-
>
"
)
;
PrintPath
(
field_path
false
message2
)
;
printer_
-
>
Print
(
"
:
"
)
;
PrintValue
(
message1
field_path
true
)
;
printer_
-
>
Print
(
"
\
n
"
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportMatched
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
printer_
-
>
Print
(
"
matched
:
"
)
;
PrintPath
(
field_path
true
message1
)
;
if
(
CheckPathChanged
(
field_path
)
)
{
printer_
-
>
Print
(
"
-
>
"
)
;
PrintPath
(
field_path
false
message2
)
;
}
printer_
-
>
Print
(
"
:
"
)
;
PrintValue
(
message1
field_path
true
)
;
printer_
-
>
Print
(
"
\
n
"
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportIgnored
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
printer_
-
>
Print
(
"
ignored
:
"
)
;
PrintPath
(
field_path
true
message1
)
;
if
(
CheckPathChanged
(
field_path
)
)
{
printer_
-
>
Print
(
"
-
>
"
)
;
PrintPath
(
field_path
false
message2
)
;
}
printer_
-
>
Print
(
"
\
n
"
)
;
}
void
MessageDifferencer
:
:
StreamReporter
:
:
ReportUnknownFieldIgnored
(
const
Message
&
message1
const
Message
&
message2
const
std
:
:
vector
<
SpecificField
>
&
field_path
)
{
printer_
-
>
Print
(
"
ignored
:
"
)
;
PrintPath
(
field_path
true
message1
)
;
if
(
CheckPathChanged
(
field_path
)
)
{
printer_
-
>
Print
(
"
-
>
"
)
;
PrintPath
(
field_path
false
message2
)
;
}
printer_
-
>
Print
(
"
\
n
"
)
;
}
}
}
}
