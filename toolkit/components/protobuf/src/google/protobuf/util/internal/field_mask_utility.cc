#
include
<
google
/
protobuf
/
util
/
internal
/
field_mask_utility
.
h
>
#
include
<
google
/
protobuf
/
util
/
internal
/
utility
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
strutil
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
status_macros
.
h
>
#
include
<
google
/
protobuf
/
port_def
.
inc
>
namespace
google
{
namespace
protobuf
{
namespace
util
{
namespace
converter
{
namespace
{
std
:
:
string
AppendPathSegmentToPrefix
(
StringPiece
prefix
StringPiece
segment
)
{
if
(
prefix
.
empty
(
)
)
{
return
std
:
:
string
(
segment
)
;
}
if
(
segment
.
empty
(
)
)
{
return
std
:
:
string
(
prefix
)
;
}
if
(
HasPrefixString
(
segment
"
[
\
"
"
)
)
{
return
StrCat
(
prefix
segment
)
;
}
return
StrCat
(
prefix
"
.
"
segment
)
;
}
}
std
:
:
string
ConvertFieldMaskPath
(
const
StringPiece
path
ConverterCallback
converter
)
{
std
:
:
string
result
;
result
.
reserve
(
path
.
size
(
)
<
<
1
)
;
bool
is_quoted
=
false
;
bool
is_escaping
=
false
;
int
current_segment_start
=
0
;
for
(
size_t
i
=
0
;
i
<
=
path
.
size
(
)
;
+
+
i
)
{
if
(
is_quoted
)
{
if
(
i
=
=
path
.
size
(
)
)
{
break
;
}
result
.
push_back
(
path
[
i
]
)
;
if
(
is_escaping
)
{
is_escaping
=
false
;
}
else
if
(
path
[
i
]
=
=
'
\
\
'
)
{
is_escaping
=
true
;
}
else
if
(
path
[
i
]
=
=
'
\
"
'
)
{
current_segment_start
=
i
+
1
;
is_quoted
=
false
;
}
continue
;
}
if
(
i
=
=
path
.
size
(
)
|
|
path
[
i
]
=
=
'
.
'
|
|
path
[
i
]
=
=
'
(
'
|
|
path
[
i
]
=
=
'
)
'
|
|
path
[
i
]
=
=
'
\
"
'
)
{
result
+
=
converter
(
path
.
substr
(
current_segment_start
i
-
current_segment_start
)
)
;
if
(
i
<
path
.
size
(
)
)
{
result
.
push_back
(
path
[
i
]
)
;
}
current_segment_start
=
i
+
1
;
}
if
(
i
<
path
.
size
(
)
&
&
path
[
i
]
=
=
'
\
"
'
)
{
is_quoted
=
true
;
}
}
return
result
;
}
util
:
:
Status
DecodeCompactFieldMaskPaths
(
StringPiece
paths
PathSinkCallback
path_sink
)
{
std
:
:
stack
<
std
:
:
string
>
prefix
;
int
length
=
paths
.
length
(
)
;
int
previous_position
=
0
;
bool
in_map_key
=
false
;
bool
is_escaping
=
false
;
for
(
int
i
=
0
;
i
<
=
length
;
+
+
i
)
{
if
(
i
!
=
length
)
{
if
(
in_map_key
)
{
if
(
is_escaping
)
{
is_escaping
=
false
;
continue
;
}
if
(
paths
[
i
]
=
=
'
\
\
'
)
{
is_escaping
=
true
;
continue
;
}
if
(
paths
[
i
]
!
=
'
\
"
'
)
{
continue
;
}
if
(
i
>
=
length
-
1
|
|
paths
[
i
+
1
]
!
=
'
]
'
)
{
return
util
:
:
Status
(
util
:
:
error
:
:
INVALID_ARGUMENT
StrCat
(
"
Invalid
FieldMask
'
"
paths
"
'
.
Map
keys
should
be
represented
as
[
\
"
some_key
\
"
]
.
"
)
)
;
}
in_map_key
=
false
;
i
+
+
;
if
(
i
<
length
-
1
&
&
paths
[
i
+
1
]
!
=
'
.
'
&
&
paths
[
i
+
1
]
!
=
'
'
&
&
paths
[
i
+
1
]
!
=
'
)
'
&
&
paths
[
i
+
1
]
!
=
'
(
'
)
{
return
util
:
:
Status
(
util
:
:
error
:
:
INVALID_ARGUMENT
StrCat
(
"
Invalid
FieldMask
'
"
paths
"
'
.
Map
keys
should
be
at
the
end
of
a
path
segment
.
"
)
)
;
}
is_escaping
=
false
;
continue
;
}
if
(
paths
[
i
]
=
=
'
[
'
)
{
if
(
i
>
=
length
-
1
|
|
paths
[
i
+
1
]
!
=
'
\
"
'
)
{
return
util
:
:
Status
(
util
:
:
error
:
:
INVALID_ARGUMENT
StrCat
(
"
Invalid
FieldMask
'
"
paths
"
'
.
Map
keys
should
be
represented
as
[
\
"
some_key
\
"
]
.
"
)
)
;
}
in_map_key
=
true
;
i
+
+
;
continue
;
}
if
(
paths
[
i
]
!
=
'
'
&
&
paths
[
i
]
!
=
'
)
'
&
&
paths
[
i
]
!
=
'
(
'
)
{
continue
;
}
}
StringPiece
segment
=
paths
.
substr
(
previous_position
i
-
previous_position
)
;
std
:
:
string
current_prefix
=
prefix
.
empty
(
)
?
"
"
:
prefix
.
top
(
)
;
if
(
i
<
length
&
&
paths
[
i
]
=
=
'
(
'
)
{
prefix
.
push
(
AppendPathSegmentToPrefix
(
current_prefix
segment
)
)
;
}
else
if
(
!
segment
.
empty
(
)
)
{
RETURN_IF_ERROR
(
path_sink
(
AppendPathSegmentToPrefix
(
current_prefix
segment
)
)
)
;
}
if
(
i
<
length
&
&
paths
[
i
]
=
=
'
)
'
)
{
if
(
prefix
.
empty
(
)
)
{
return
util
:
:
Status
(
util
:
:
error
:
:
INVALID_ARGUMENT
StrCat
(
"
Invalid
FieldMask
'
"
paths
"
'
.
Cannot
find
matching
'
(
'
for
all
'
)
'
.
"
)
)
;
}
prefix
.
pop
(
)
;
}
previous_position
=
i
+
1
;
}
if
(
in_map_key
)
{
return
util
:
:
Status
(
util
:
:
error
:
:
INVALID_ARGUMENT
StrCat
(
"
Invalid
FieldMask
'
"
paths
"
'
.
Cannot
find
matching
'
]
'
for
all
'
[
'
.
"
)
)
;
}
if
(
!
prefix
.
empty
(
)
)
{
return
util
:
:
Status
(
util
:
:
error
:
:
INVALID_ARGUMENT
StrCat
(
"
Invalid
FieldMask
'
"
paths
"
'
.
Cannot
find
matching
'
)
'
for
all
'
(
'
.
"
)
)
;
}
return
util
:
:
Status
(
)
;
}
}
}
}
}
