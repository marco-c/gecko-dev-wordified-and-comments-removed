#
include
<
google
/
protobuf
/
util
/
internal
/
datapiece
.
h
>
#
include
<
cmath
>
#
include
<
limits
>
#
include
<
google
/
protobuf
/
struct
.
pb
.
h
>
#
include
<
google
/
protobuf
/
type
.
pb
.
h
>
#
include
<
google
/
protobuf
/
descriptor
.
h
>
#
include
<
google
/
protobuf
/
util
/
internal
/
utility
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
strutil
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
mathutil
.
h
>
namespace
google
{
namespace
protobuf
{
namespace
util
{
namespace
converter
{
using
util
:
:
Status
;
using
util
:
:
StatusOr
;
using
util
:
:
error
:
:
Code
;
namespace
{
inline
Status
InvalidArgument
(
StringPiece
value_str
)
{
return
Status
(
util
:
:
error
:
:
INVALID_ARGUMENT
value_str
)
;
}
template
<
typename
To
typename
From
>
StatusOr
<
To
>
ValidateNumberConversion
(
To
after
From
before
)
{
if
(
after
=
=
before
&
&
MathUtil
:
:
Sign
<
From
>
(
before
)
=
=
MathUtil
:
:
Sign
<
To
>
(
after
)
)
{
return
after
;
}
else
{
return
InvalidArgument
(
std
:
:
is_integral
<
From
>
:
:
value
?
ValueAsString
(
before
)
:
std
:
:
is_same
<
From
double
>
:
:
value
?
DoubleAsString
(
before
)
:
FloatAsString
(
before
)
)
;
}
}
template
<
typename
To
typename
From
>
StatusOr
<
To
>
NumberConvertAndCheck
(
From
before
)
{
if
(
std
:
:
is_same
<
From
To
>
:
:
value
)
return
before
;
To
after
=
static_cast
<
To
>
(
before
)
;
return
ValidateNumberConversion
(
after
before
)
;
}
template
<
typename
To
typename
From
>
StatusOr
<
To
>
FloatingPointToIntConvertAndCheck
(
From
before
)
{
if
(
std
:
:
is_same
<
From
To
>
:
:
value
)
return
before
;
To
after
=
static_cast
<
To
>
(
before
)
;
return
ValidateNumberConversion
(
after
before
)
;
}
StatusOr
<
double
>
FloatToDouble
(
float
before
)
{
return
static_cast
<
double
>
(
before
)
;
}
StatusOr
<
float
>
DoubleToFloat
(
double
before
)
{
if
(
std
:
:
isnan
(
before
)
)
{
return
std
:
:
numeric_limits
<
float
>
:
:
quiet_NaN
(
)
;
}
else
if
(
!
std
:
:
isfinite
(
before
)
)
{
return
static_cast
<
float
>
(
before
)
;
}
else
if
(
before
>
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
|
|
before
<
-
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
)
{
return
InvalidArgument
(
DoubleAsString
(
before
)
)
;
}
else
{
return
static_cast
<
float
>
(
before
)
;
}
}
}
StatusOr
<
int32
>
DataPiece
:
:
ToInt32
(
)
const
{
if
(
type_
=
=
TYPE_STRING
)
return
StringToNumber
<
int32
>
(
safe_strto32
)
;
if
(
type_
=
=
TYPE_DOUBLE
)
return
FloatingPointToIntConvertAndCheck
<
int32
double
>
(
double_
)
;
if
(
type_
=
=
TYPE_FLOAT
)
return
FloatingPointToIntConvertAndCheck
<
int32
float
>
(
float_
)
;
return
GenericConvert
<
int32
>
(
)
;
}
StatusOr
<
uint32
>
DataPiece
:
:
ToUint32
(
)
const
{
if
(
type_
=
=
TYPE_STRING
)
return
StringToNumber
<
uint32
>
(
safe_strtou32
)
;
if
(
type_
=
=
TYPE_DOUBLE
)
return
FloatingPointToIntConvertAndCheck
<
uint32
double
>
(
double_
)
;
if
(
type_
=
=
TYPE_FLOAT
)
return
FloatingPointToIntConvertAndCheck
<
uint32
float
>
(
float_
)
;
return
GenericConvert
<
uint32
>
(
)
;
}
StatusOr
<
int64
>
DataPiece
:
:
ToInt64
(
)
const
{
if
(
type_
=
=
TYPE_STRING
)
return
StringToNumber
<
int64
>
(
safe_strto64
)
;
if
(
type_
=
=
TYPE_DOUBLE
)
return
FloatingPointToIntConvertAndCheck
<
int64
double
>
(
double_
)
;
if
(
type_
=
=
TYPE_FLOAT
)
return
FloatingPointToIntConvertAndCheck
<
int64
float
>
(
float_
)
;
return
GenericConvert
<
int64
>
(
)
;
}
StatusOr
<
uint64
>
DataPiece
:
:
ToUint64
(
)
const
{
if
(
type_
=
=
TYPE_STRING
)
return
StringToNumber
<
uint64
>
(
safe_strtou64
)
;
if
(
type_
=
=
TYPE_DOUBLE
)
return
FloatingPointToIntConvertAndCheck
<
uint64
double
>
(
double_
)
;
if
(
type_
=
=
TYPE_FLOAT
)
return
FloatingPointToIntConvertAndCheck
<
uint64
float
>
(
float_
)
;
return
GenericConvert
<
uint64
>
(
)
;
}
StatusOr
<
double
>
DataPiece
:
:
ToDouble
(
)
const
{
if
(
type_
=
=
TYPE_FLOAT
)
{
return
FloatToDouble
(
float_
)
;
}
if
(
type_
=
=
TYPE_STRING
)
{
if
(
str_
=
=
"
Infinity
"
)
return
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
if
(
str_
=
=
"
-
Infinity
"
)
return
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
if
(
str_
=
=
"
NaN
"
)
return
std
:
:
numeric_limits
<
double
>
:
:
quiet_NaN
(
)
;
StatusOr
<
double
>
value
=
StringToNumber
<
double
>
(
safe_strtod
)
;
if
(
value
.
ok
(
)
&
&
!
std
:
:
isfinite
(
value
.
ValueOrDie
(
)
)
)
{
return
InvalidArgument
(
StrCat
(
"
\
"
"
str_
"
\
"
"
)
)
;
}
else
{
return
value
;
}
}
return
GenericConvert
<
double
>
(
)
;
}
StatusOr
<
float
>
DataPiece
:
:
ToFloat
(
)
const
{
if
(
type_
=
=
TYPE_DOUBLE
)
{
return
DoubleToFloat
(
double_
)
;
}
if
(
type_
=
=
TYPE_STRING
)
{
if
(
str_
=
=
"
Infinity
"
)
return
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
;
if
(
str_
=
=
"
-
Infinity
"
)
return
-
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
;
if
(
str_
=
=
"
NaN
"
)
return
std
:
:
numeric_limits
<
float
>
:
:
quiet_NaN
(
)
;
return
StringToNumber
<
float
>
(
SafeStrToFloat
)
;
}
return
GenericConvert
<
float
>
(
)
;
}
StatusOr
<
bool
>
DataPiece
:
:
ToBool
(
)
const
{
switch
(
type_
)
{
case
TYPE_BOOL
:
return
bool_
;
case
TYPE_STRING
:
return
StringToNumber
<
bool
>
(
safe_strtob
)
;
default
:
return
InvalidArgument
(
ValueAsStringOrDefault
(
"
Wrong
type
.
Cannot
convert
to
Bool
.
"
)
)
;
}
}
StatusOr
<
std
:
:
string
>
DataPiece
:
:
ToString
(
)
const
{
switch
(
type_
)
{
case
TYPE_STRING
:
return
std
:
:
string
(
str_
)
;
case
TYPE_BYTES
:
{
std
:
:
string
base64
;
Base64Escape
(
str_
&
base64
)
;
return
base64
;
}
default
:
return
InvalidArgument
(
ValueAsStringOrDefault
(
"
Cannot
convert
to
string
.
"
)
)
;
}
}
std
:
:
string
DataPiece
:
:
ValueAsStringOrDefault
(
StringPiece
default_string
)
const
{
switch
(
type_
)
{
case
TYPE_INT32
:
return
StrCat
(
i32_
)
;
case
TYPE_INT64
:
return
StrCat
(
i64_
)
;
case
TYPE_UINT32
:
return
StrCat
(
u32_
)
;
case
TYPE_UINT64
:
return
StrCat
(
u64_
)
;
case
TYPE_DOUBLE
:
return
DoubleAsString
(
double_
)
;
case
TYPE_FLOAT
:
return
FloatAsString
(
float_
)
;
case
TYPE_BOOL
:
return
SimpleBtoa
(
bool_
)
;
case
TYPE_STRING
:
return
StrCat
(
"
\
"
"
str_
.
ToString
(
)
"
\
"
"
)
;
case
TYPE_BYTES
:
{
std
:
:
string
base64
;
WebSafeBase64Escape
(
str_
&
base64
)
;
return
StrCat
(
"
\
"
"
base64
"
\
"
"
)
;
}
case
TYPE_NULL
:
return
"
null
"
;
default
:
return
std
:
:
string
(
default_string
)
;
}
}
StatusOr
<
std
:
:
string
>
DataPiece
:
:
ToBytes
(
)
const
{
if
(
type_
=
=
TYPE_BYTES
)
return
str_
.
ToString
(
)
;
if
(
type_
=
=
TYPE_STRING
)
{
std
:
:
string
decoded
;
if
(
!
DecodeBase64
(
str_
&
decoded
)
)
{
return
InvalidArgument
(
ValueAsStringOrDefault
(
"
Invalid
data
in
input
.
"
)
)
;
}
return
decoded
;
}
else
{
return
InvalidArgument
(
ValueAsStringOrDefault
(
"
Wrong
type
.
Only
String
or
Bytes
can
be
converted
to
Bytes
.
"
)
)
;
}
}
StatusOr
<
int
>
DataPiece
:
:
ToEnum
(
const
google
:
:
protobuf
:
:
Enum
*
enum_type
bool
use_lower_camel_for_enums
bool
case_insensitive_enum_parsing
bool
ignore_unknown_enum_values
bool
*
is_unknown_enum_value
)
const
{
if
(
type_
=
=
TYPE_NULL
)
return
google
:
:
protobuf
:
:
NULL_VALUE
;
if
(
type_
=
=
TYPE_STRING
)
{
std
:
:
string
enum_name
=
std
:
:
string
(
str_
)
;
const
google
:
:
protobuf
:
:
EnumValue
*
value
=
FindEnumValueByNameOrNull
(
enum_type
enum_name
)
;
if
(
value
!
=
nullptr
)
return
value
-
>
number
(
)
;
StatusOr
<
int32
>
int_value
=
ToInt32
(
)
;
if
(
int_value
.
ok
(
)
)
{
if
(
const
google
:
:
protobuf
:
:
EnumValue
*
enum_value
=
FindEnumValueByNumberOrNull
(
enum_type
int_value
.
ValueOrDie
(
)
)
)
{
return
enum_value
-
>
number
(
)
;
}
}
bool
should_normalize_enum
=
case_insensitive_enum_parsing
|
|
use_lower_camel_for_enums
;
if
(
should_normalize_enum
)
{
for
(
std
:
:
string
:
:
iterator
it
=
enum_name
.
begin
(
)
;
it
!
=
enum_name
.
end
(
)
;
+
+
it
)
{
*
it
=
*
it
=
=
'
-
'
?
'
_
'
:
ascii_toupper
(
*
it
)
;
}
value
=
FindEnumValueByNameOrNull
(
enum_type
enum_name
)
;
if
(
value
!
=
nullptr
)
return
value
-
>
number
(
)
;
}
if
(
use_lower_camel_for_enums
)
{
value
=
FindEnumValueByNameWithoutUnderscoreOrNull
(
enum_type
enum_name
)
;
if
(
value
!
=
nullptr
)
return
value
-
>
number
(
)
;
}
if
(
ignore_unknown_enum_values
)
{
*
is_unknown_enum_value
=
true
;
return
enum_type
-
>
enumvalue
(
0
)
.
number
(
)
;
}
}
else
{
return
ToInt32
(
)
;
}
return
InvalidArgument
(
ValueAsStringOrDefault
(
"
Cannot
find
enum
with
given
value
.
"
)
)
;
}
template
<
typename
To
>
StatusOr
<
To
>
DataPiece
:
:
GenericConvert
(
)
const
{
switch
(
type_
)
{
case
TYPE_INT32
:
return
NumberConvertAndCheck
<
To
int32
>
(
i32_
)
;
case
TYPE_INT64
:
return
NumberConvertAndCheck
<
To
int64
>
(
i64_
)
;
case
TYPE_UINT32
:
return
NumberConvertAndCheck
<
To
uint32
>
(
u32_
)
;
case
TYPE_UINT64
:
return
NumberConvertAndCheck
<
To
uint64
>
(
u64_
)
;
case
TYPE_DOUBLE
:
return
NumberConvertAndCheck
<
To
double
>
(
double_
)
;
case
TYPE_FLOAT
:
return
NumberConvertAndCheck
<
To
float
>
(
float_
)
;
default
:
return
InvalidArgument
(
ValueAsStringOrDefault
(
"
Wrong
type
.
Bool
Enum
String
and
Cord
not
supported
in
"
"
GenericConvert
.
"
)
)
;
}
}
template
<
typename
To
>
StatusOr
<
To
>
DataPiece
:
:
StringToNumber
(
bool
(
*
func
)
(
StringPiece
To
*
)
)
const
{
if
(
str_
.
size
(
)
>
0
&
&
(
str_
[
0
]
=
=
'
'
|
|
str_
[
str_
.
size
(
)
-
1
]
=
=
'
'
)
)
{
return
InvalidArgument
(
StrCat
(
"
\
"
"
str_
"
\
"
"
)
)
;
}
To
result
;
if
(
func
(
str_
&
result
)
)
return
result
;
return
InvalidArgument
(
StrCat
(
"
\
"
"
std
:
:
string
(
str_
)
"
\
"
"
)
)
;
}
bool
DataPiece
:
:
DecodeBase64
(
StringPiece
src
std
:
:
string
*
dest
)
const
{
if
(
WebSafeBase64Unescape
(
src
dest
)
)
{
if
(
use_strict_base64_decoding_
)
{
std
:
:
string
encoded
;
WebSafeBase64Escape
(
*
dest
&
encoded
)
;
StringPiece
src_no_padding
=
StringPiece
(
src
)
.
substr
(
0
HasSuffixString
(
src
"
=
"
)
?
src
.
find_last_not_of
(
'
=
'
)
+
1
:
src
.
length
(
)
)
;
return
encoded
=
=
src_no_padding
;
}
return
true
;
}
if
(
Base64Unescape
(
src
dest
)
)
{
if
(
use_strict_base64_decoding_
)
{
std
:
:
string
encoded
;
Base64Escape
(
reinterpret_cast
<
const
unsigned
char
*
>
(
dest
-
>
data
(
)
)
dest
-
>
length
(
)
&
encoded
false
)
;
StringPiece
src_no_padding
=
StringPiece
(
src
)
.
substr
(
0
HasSuffixString
(
src
"
=
"
)
?
src
.
find_last_not_of
(
'
=
'
)
+
1
:
src
.
length
(
)
)
;
return
encoded
=
=
src_no_padding
;
}
return
true
;
}
return
false
;
}
void
DataPiece
:
:
InternalCopy
(
const
DataPiece
&
other
)
{
type_
=
other
.
type_
;
use_strict_base64_decoding_
=
other
.
use_strict_base64_decoding_
;
switch
(
type_
)
{
case
TYPE_INT32
:
case
TYPE_INT64
:
case
TYPE_UINT32
:
case
TYPE_UINT64
:
case
TYPE_DOUBLE
:
case
TYPE_FLOAT
:
case
TYPE_BOOL
:
case
TYPE_ENUM
:
case
TYPE_NULL
:
case
TYPE_BYTES
:
case
TYPE_STRING
:
{
str_
=
other
.
str_
;
break
;
}
}
}
}
}
}
}
