#
include
<
google
/
protobuf
/
util
/
internal
/
json_escaping
.
h
>
#
include
<
cstdint
>
#
include
<
google
/
protobuf
/
stubs
/
logging
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
common
.
h
>
namespace
google
{
namespace
protobuf
{
namespace
util
{
namespace
converter
{
namespace
{
static
const
char
kHex
[
]
=
"
0123456789abcdef
"
;
static
const
char
kCommonEscapes
[
160
]
[
7
]
=
{
"
\
\
u0000
"
"
\
\
u0001
"
"
\
\
u0002
"
"
\
\
u0003
"
"
\
\
u0004
"
"
\
\
u0005
"
"
\
\
u0006
"
"
\
\
u0007
"
"
\
\
b
"
"
\
\
t
"
"
\
\
n
"
"
\
\
u000b
"
"
\
\
f
"
"
\
\
r
"
"
\
\
u000e
"
"
\
\
u000f
"
"
\
\
u0010
"
"
\
\
u0011
"
"
\
\
u0012
"
"
\
\
u0013
"
"
\
\
u0014
"
"
\
\
u0015
"
"
\
\
u0016
"
"
\
\
u0017
"
"
\
\
u0018
"
"
\
\
u0019
"
"
\
\
u001a
"
"
\
\
u001b
"
"
\
\
u001c
"
"
\
\
u001d
"
"
\
\
u001e
"
"
\
\
u001f
"
"
"
"
"
"
\
\
\
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
\
\
u003c
"
"
"
"
\
\
u003e
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
\
\
\
\
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
\
\
u007f
"
"
\
\
u0080
"
"
\
\
u0081
"
"
\
\
u0082
"
"
\
\
u0083
"
"
\
\
u0084
"
"
\
\
u0085
"
"
\
\
u0086
"
"
\
\
u0087
"
"
\
\
u0088
"
"
\
\
u0089
"
"
\
\
u008a
"
"
\
\
u008b
"
"
\
\
u008c
"
"
\
\
u008d
"
"
\
\
u008e
"
"
\
\
u008f
"
"
\
\
u0090
"
"
\
\
u0091
"
"
\
\
u0092
"
"
\
\
u0093
"
"
\
\
u0094
"
"
\
\
u0095
"
"
\
\
u0096
"
"
\
\
u0097
"
"
\
\
u0098
"
"
\
\
u0099
"
"
\
\
u009a
"
"
\
\
u009b
"
"
\
\
u009c
"
"
\
\
u009d
"
"
\
\
u009e
"
"
\
\
u009f
"
}
;
inline
bool
IsSurrogate
(
uint32_t
c
)
{
return
(
c
&
0xfffff800
)
=
=
JsonEscaping
:
:
kMinHighSurrogate
;
}
inline
bool
IsValidCodePoint
(
uint32_t
cp
)
{
return
cp
<
=
JsonEscaping
:
:
kMaxCodePoint
;
}
inline
uint16_t
ToLowSurrogate
(
uint32_t
cp
)
{
return
(
cp
&
(
JsonEscaping
:
:
kMaxLowSurrogate
-
JsonEscaping
:
:
kMinLowSurrogate
)
)
+
JsonEscaping
:
:
kMinLowSurrogate
;
}
inline
uint16_t
ToHighSurrogate
(
uint32_t
cp
)
{
return
(
cp
>
>
10
)
+
(
JsonEscaping
:
:
kMinHighSurrogate
-
(
JsonEscaping
:
:
kMinSupplementaryCodePoint
>
>
10
)
)
;
}
bool
ReadCodePoint
(
StringPiece
str
int
index
uint32_t
*
cp
int
*
num_left
int
*
num_read
)
{
if
(
*
num_left
=
=
0
)
{
*
cp
=
static_cast
<
uint8_t
>
(
str
[
index
+
+
]
)
;
*
num_read
=
1
;
if
(
*
cp
<
=
0x7f
)
{
return
true
;
}
else
if
(
*
cp
<
=
0xbf
)
{
return
false
;
}
else
if
(
*
cp
<
=
0xdf
)
{
*
cp
&
=
0x1f
;
*
num_left
=
1
;
}
else
if
(
*
cp
<
=
0xef
)
{
*
cp
&
=
0x0f
;
*
num_left
=
2
;
}
else
if
(
*
cp
<
=
0xf7
)
{
*
cp
&
=
0x07
;
*
num_left
=
3
;
}
else
{
return
false
;
}
}
else
{
*
num_read
=
0
;
}
while
(
*
num_left
>
0
&
&
index
<
str
.
size
(
)
)
{
uint32_t
ch
=
static_cast
<
uint8_t
>
(
str
[
index
+
+
]
)
;
-
-
(
*
num_left
)
;
+
+
(
*
num_read
)
;
*
cp
=
(
*
cp
<
<
6
)
|
(
ch
&
0x3f
)
;
if
(
ch
<
0x80
|
|
ch
>
0xbf
)
return
false
;
}
return
*
num_left
>
0
|
|
(
!
IsSurrogate
(
*
cp
)
&
&
IsValidCodePoint
(
*
cp
)
)
;
}
StringPiece
ToHex
(
uint16_t
cp
char
*
buffer
)
{
buffer
[
5
]
=
kHex
[
cp
&
0x0f
]
;
cp
>
>
=
4
;
buffer
[
4
]
=
kHex
[
cp
&
0x0f
]
;
cp
>
>
=
4
;
buffer
[
3
]
=
kHex
[
cp
&
0x0f
]
;
cp
>
>
=
4
;
buffer
[
2
]
=
kHex
[
cp
&
0x0f
]
;
return
StringPiece
(
buffer
6
)
;
}
StringPiece
ToSurrogateHex
(
uint32_t
cp
char
*
buffer
)
{
uint16_t
low
=
ToLowSurrogate
(
cp
)
;
uint16_t
high
=
ToHighSurrogate
(
cp
)
;
buffer
[
11
]
=
kHex
[
low
&
0x0f
]
;
low
>
>
=
4
;
buffer
[
10
]
=
kHex
[
low
&
0x0f
]
;
low
>
>
=
4
;
buffer
[
9
]
=
kHex
[
low
&
0x0f
]
;
low
>
>
=
4
;
buffer
[
8
]
=
kHex
[
low
&
0x0f
]
;
buffer
[
5
]
=
kHex
[
high
&
0x0f
]
;
high
>
>
=
4
;
buffer
[
4
]
=
kHex
[
high
&
0x0f
]
;
high
>
>
=
4
;
buffer
[
3
]
=
kHex
[
high
&
0x0f
]
;
high
>
>
=
4
;
buffer
[
2
]
=
kHex
[
high
&
0x0f
]
;
return
StringPiece
(
buffer
12
)
;
}
StringPiece
EscapeCodePoint
(
uint32_t
cp
char
*
buffer
)
{
if
(
cp
<
0xa0
)
return
kCommonEscapes
[
cp
]
;
switch
(
cp
)
{
case
0xfeff
:
case
0xfff9
:
case
0xfffa
:
case
0xfffb
:
case
0x00ad
:
case
0x06dd
:
case
0x070f
:
case
0x17b4
:
case
0x17b5
:
return
ToHex
(
cp
buffer
)
;
default
:
if
(
(
cp
>
=
0x0600
&
&
cp
<
=
0x0603
)
|
|
(
cp
>
=
0x200b
&
&
cp
<
=
0x200f
)
|
|
(
cp
>
=
0x2028
&
&
cp
<
=
0x202e
)
|
|
(
cp
>
=
0x2060
&
&
cp
<
=
0x2064
)
|
|
(
cp
>
=
0x206a
&
&
cp
<
=
0x206f
)
)
{
return
ToHex
(
cp
buffer
)
;
}
if
(
cp
=
=
0x000e0001
|
|
(
cp
>
=
0x0001d173
&
&
cp
<
=
0x0001d17a
)
|
|
(
cp
>
=
0x000e0020
&
&
cp
<
=
0x000e007f
)
)
{
return
ToSurrogateHex
(
cp
buffer
)
;
}
}
return
StringPiece
(
)
;
}
StringPiece
EscapeCodePoint
(
uint32_t
cp
char
*
buffer
bool
force_output
)
{
StringPiece
sp
=
EscapeCodePoint
(
cp
buffer
)
;
if
(
force_output
&
&
sp
.
empty
(
)
)
{
buffer
[
5
]
=
(
cp
&
0x3f
)
|
0x80
;
cp
>
>
=
6
;
if
(
cp
<
=
0x1f
)
{
buffer
[
4
]
=
cp
|
0xc0
;
sp
=
StringPiece
(
buffer
+
4
2
)
;
return
sp
;
}
buffer
[
4
]
=
(
cp
&
0x3f
)
|
0x80
;
cp
>
>
=
6
;
if
(
cp
<
=
0x0f
)
{
buffer
[
3
]
=
cp
|
0xe0
;
sp
=
StringPiece
(
buffer
+
3
3
)
;
return
sp
;
}
buffer
[
3
]
=
(
cp
&
0x3f
)
|
0x80
;
buffer
[
2
]
=
(
(
cp
>
>
6
)
&
0x07
)
|
0xf0
;
sp
=
StringPiece
(
buffer
+
2
4
)
;
}
return
sp
;
}
}
void
JsonEscaping
:
:
Escape
(
strings
:
:
ByteSource
*
input
strings
:
:
ByteSink
*
output
)
{
char
buffer
[
12
]
=
"
\
\
udead
\
\
ubee
"
;
uint32_t
cp
=
0
;
int
num_left
=
0
;
while
(
input
-
>
Available
(
)
>
0
)
{
StringPiece
str
=
input
-
>
Peek
(
)
;
StringPiece
escaped
;
int
i
=
0
;
int
num_read
;
bool
ok
;
bool
cp_was_split
=
num_left
>
0
;
do
{
ok
=
ReadCodePoint
(
str
i
&
cp
&
num_left
&
num_read
)
;
if
(
num_left
>
0
|
|
!
ok
)
break
;
escaped
=
EscapeCodePoint
(
cp
buffer
cp_was_split
)
;
if
(
!
escaped
.
empty
(
)
)
break
;
i
+
=
num_read
;
num_read
=
0
;
}
while
(
i
<
str
.
length
(
)
)
;
if
(
i
>
0
)
input
-
>
CopyTo
(
output
i
)
;
if
(
num_read
>
0
)
input
-
>
Skip
(
num_read
)
;
if
(
!
ok
)
{
num_left
=
0
;
}
else
if
(
num_left
=
=
0
&
&
!
escaped
.
empty
(
)
)
{
output
-
>
Append
(
escaped
.
data
(
)
escaped
.
size
(
)
)
;
}
}
if
(
num_left
>
0
)
{
}
}
void
JsonEscaping
:
:
Escape
(
StringPiece
input
strings
:
:
ByteSink
*
output
)
{
const
size_t
len
=
input
.
length
(
)
;
const
char
*
p
=
input
.
data
(
)
;
bool
can_skip_escaping
=
true
;
for
(
int
i
=
0
;
i
<
len
;
i
+
+
)
{
char
c
=
p
[
i
]
;
if
(
c
<
0x20
|
|
c
>
=
0x7F
|
|
c
=
=
'
"
'
|
|
c
=
=
'
<
'
|
|
c
=
=
'
>
'
|
|
c
=
=
'
\
\
'
)
{
can_skip_escaping
=
false
;
break
;
}
}
if
(
can_skip_escaping
)
{
output
-
>
Append
(
input
.
data
(
)
input
.
length
(
)
)
;
}
else
{
strings
:
:
ArrayByteSource
source
(
input
)
;
Escape
(
&
source
output
)
;
}
}
}
}
}
}
