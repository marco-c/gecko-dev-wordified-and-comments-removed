#
include
<
google
/
protobuf
/
util
/
internal
/
json_stream_parser
.
h
>
#
include
<
algorithm
>
#
include
<
cctype
>
#
include
<
cmath
>
#
include
<
memory
>
#
include
<
stack
>
#
include
<
string
>
#
include
<
google
/
protobuf
/
stubs
/
common
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
logging
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
strutil
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
status
.
h
>
#
include
<
google
/
protobuf
/
util
/
internal
/
object_writer
.
h
>
#
include
<
google
/
protobuf
/
util
/
internal
/
json_escaping
.
h
>
namespace
google
{
namespace
protobuf
{
namespace
util
{
namespace
converter
{
static
const
int
kUnicodeEscapedLength
=
6
;
static
const
int
kDefaultMaxRecursionDepth
=
100
;
static
const
StringPiece
kKeywordTrue
=
"
true
"
;
static
const
StringPiece
kKeywordFalse
=
"
false
"
;
static
const
StringPiece
kKeywordNull
=
"
null
"
;
inline
bool
IsLetter
(
char
c
)
{
return
(
'
a
'
<
=
c
&
&
c
<
=
'
z
'
)
|
|
(
'
A
'
<
=
c
&
&
c
<
=
'
Z
'
)
|
|
(
c
=
=
'
_
'
)
|
|
(
c
=
=
'
'
)
;
}
inline
bool
IsAlphanumeric
(
char
c
)
{
return
IsLetter
(
c
)
|
|
(
'
0
'
<
=
c
&
&
c
<
=
'
9
'
)
;
}
inline
bool
IsKeySeparator
(
char
c
)
{
return
(
ascii_isspace
(
c
)
|
|
c
=
=
'
"
'
|
|
c
=
=
'
\
'
'
|
|
c
=
=
'
{
'
|
|
c
=
=
'
}
'
|
|
c
=
=
'
[
'
|
|
c
=
=
'
]
'
|
|
c
=
=
'
:
'
|
|
c
=
=
'
'
)
;
}
inline
void
ReplaceInvalidCodePoints
(
StringPiece
str
const
std
:
:
string
&
replacement
std
:
:
string
*
dst
)
{
while
(
!
str
.
empty
(
)
)
{
int
n_valid_bytes
=
internal
:
:
UTF8SpnStructurallyValid
(
str
)
;
StringPiece
valid_part
=
str
.
substr
(
0
n_valid_bytes
)
;
StrAppend
(
dst
valid_part
)
;
if
(
n_valid_bytes
=
=
str
.
size
(
)
)
{
break
;
}
StrAppend
(
dst
replacement
)
;
str
.
remove_prefix
(
n_valid_bytes
+
1
)
;
}
}
static
bool
ConsumeKey
(
StringPiece
*
input
StringPiece
*
key
)
{
if
(
input
-
>
empty
(
)
|
|
!
IsLetter
(
(
*
input
)
[
0
]
)
)
return
false
;
int
len
=
1
;
for
(
;
len
<
input
-
>
size
(
)
;
+
+
len
)
{
if
(
!
IsAlphanumeric
(
(
*
input
)
[
len
]
)
)
{
break
;
}
}
*
key
=
StringPiece
(
input
-
>
data
(
)
len
)
;
*
input
=
StringPiece
(
input
-
>
data
(
)
+
len
input
-
>
size
(
)
-
len
)
;
return
true
;
}
static
bool
ConsumeKeyPermissive
(
StringPiece
*
input
StringPiece
*
key
)
{
if
(
input
-
>
empty
(
)
|
|
!
IsLetter
(
(
*
input
)
[
0
]
)
)
return
false
;
int
len
=
1
;
for
(
;
len
<
input
-
>
size
(
)
;
+
+
len
)
{
if
(
IsKeySeparator
(
(
*
input
)
[
len
]
)
)
{
break
;
}
}
*
key
=
StringPiece
(
input
-
>
data
(
)
len
)
;
*
input
=
StringPiece
(
input
-
>
data
(
)
+
len
input
-
>
size
(
)
-
len
)
;
return
true
;
}
static
bool
MatchKey
(
StringPiece
input
)
{
return
!
input
.
empty
(
)
&
&
IsLetter
(
input
[
0
]
)
;
}
JsonStreamParser
:
:
JsonStreamParser
(
ObjectWriter
*
ow
)
:
ow_
(
ow
)
stack_
(
)
leftover_
(
)
json_
(
)
p_
(
)
key_
(
)
key_storage_
(
)
finishing_
(
false
)
seen_non_whitespace_
(
false
)
allow_no_root_element_
(
false
)
parsed_
(
)
parsed_storage_
(
)
string_open_
(
0
)
chunk_storage_
(
)
coerce_to_utf8_
(
false
)
utf8_replacement_character_
(
"
"
)
allow_empty_null_
(
false
)
allow_permissive_key_naming_
(
false
)
loose_float_number_conversion_
(
false
)
recursion_depth_
(
0
)
max_recursion_depth_
(
kDefaultMaxRecursionDepth
)
{
stack_
.
push
(
VALUE
)
;
}
JsonStreamParser
:
:
~
JsonStreamParser
(
)
{
}
util
:
:
Status
JsonStreamParser
:
:
Parse
(
StringPiece
json
)
{
StringPiece
chunk
=
json
;
if
(
!
leftover_
.
empty
(
)
)
{
chunk_storage_
.
swap
(
leftover_
)
;
StrAppend
(
&
chunk_storage_
json
)
;
chunk
=
StringPiece
(
chunk_storage_
)
;
}
int
n
=
internal
:
:
UTF8SpnStructurallyValid
(
chunk
)
;
if
(
n
>
0
)
{
util
:
:
Status
status
=
ParseChunk
(
chunk
.
substr
(
0
n
)
)
;
StrAppend
(
&
leftover_
chunk
.
substr
(
n
)
)
;
return
status
;
}
else
{
leftover_
.
assign
(
chunk
.
data
(
)
chunk
.
size
(
)
)
;
return
util
:
:
Status
(
)
;
}
}
util
:
:
Status
JsonStreamParser
:
:
FinishParse
(
)
{
if
(
stack_
.
empty
(
)
&
&
leftover_
.
empty
(
)
)
{
return
util
:
:
Status
(
)
;
}
std
:
:
unique_ptr
<
std
:
:
string
>
scratch
;
bool
is_valid_utf8
=
internal
:
:
IsStructurallyValidUTF8
(
leftover_
)
;
if
(
coerce_to_utf8_
&
&
!
is_valid_utf8
)
{
scratch
.
reset
(
new
std
:
:
string
)
;
scratch
-
>
reserve
(
leftover_
.
size
(
)
*
utf8_replacement_character_
.
size
(
)
)
;
ReplaceInvalidCodePoints
(
leftover_
utf8_replacement_character_
scratch
.
get
(
)
)
;
p_
=
json_
=
*
scratch
;
}
else
{
p_
=
json_
=
leftover_
;
if
(
!
is_valid_utf8
)
{
return
ReportFailure
(
"
Encountered
non
UTF
-
8
code
points
.
"
ParseErrorType
:
:
NON_UTF_8
)
;
}
}
finishing_
=
true
;
util
:
:
Status
result
=
RunParser
(
)
;
if
(
result
.
ok
(
)
)
{
SkipWhitespace
(
)
;
if
(
!
p_
.
empty
(
)
)
{
result
=
ReportFailure
(
"
Parsing
terminated
before
end
of
input
.
"
ParseErrorType
:
:
PARSING_TERMINATED_BEFORE_END_OF_INPUT
)
;
}
}
return
result
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseChunk
(
StringPiece
chunk
)
{
if
(
chunk
.
empty
(
)
)
return
util
:
:
Status
(
)
;
p_
=
json_
=
chunk
;
finishing_
=
false
;
util
:
:
Status
result
=
RunParser
(
)
;
if
(
!
result
.
ok
(
)
)
return
result
;
SkipWhitespace
(
)
;
if
(
p_
.
empty
(
)
)
{
leftover_
.
clear
(
)
;
}
else
{
if
(
stack_
.
empty
(
)
)
{
return
ReportFailure
(
"
Parsing
terminated
before
end
of
input
.
"
ParseErrorType
:
:
PARSING_TERMINATED_BEFORE_END_OF_INPUT
)
;
}
leftover_
=
std
:
:
string
(
p_
)
;
}
return
util
:
:
Status
(
)
;
}
bool
JsonStreamParser
:
:
IsInputAllWhiteSpaces
(
TokenType
type
)
{
if
(
finishing_
&
&
p_
.
empty
(
)
&
&
type
=
=
UNKNOWN
&
&
!
seen_non_whitespace_
)
{
return
true
;
}
return
false
;
}
util
:
:
Status
JsonStreamParser
:
:
RunParser
(
)
{
while
(
!
stack_
.
empty
(
)
)
{
ParseType
type
=
stack_
.
top
(
)
;
TokenType
t
=
(
string_open_
=
=
0
)
?
GetNextTokenType
(
)
:
BEGIN_STRING
;
stack_
.
pop
(
)
;
util
:
:
Status
result
;
switch
(
type
)
{
case
VALUE
:
if
(
allow_no_root_element_
&
&
IsInputAllWhiteSpaces
(
t
)
)
{
return
util
:
:
Status
(
)
;
}
result
=
ParseValue
(
t
)
;
break
;
case
OBJ_MID
:
result
=
ParseObjectMid
(
t
)
;
break
;
case
ENTRY
:
result
=
ParseEntry
(
t
)
;
break
;
case
ENTRY_MID
:
result
=
ParseEntryMid
(
t
)
;
break
;
case
ARRAY_VALUE
:
result
=
ParseArrayValue
(
t
)
;
break
;
case
ARRAY_MID
:
result
=
ParseArrayMid
(
t
)
;
break
;
default
:
result
=
util
:
:
InternalError
(
StrCat
(
"
Unknown
parse
type
:
"
type
)
)
;
break
;
}
if
(
!
result
.
ok
(
)
)
{
if
(
!
finishing_
&
&
util
:
:
IsCancelled
(
result
)
)
{
stack_
.
push
(
type
)
;
if
(
!
key_
.
empty
(
)
&
&
key_storage_
.
empty
(
)
)
{
StrAppend
(
&
key_storage_
key_
)
;
key_
=
StringPiece
(
key_storage_
)
;
}
result
=
util
:
:
Status
(
)
;
}
return
result
;
}
}
return
util
:
:
Status
(
)
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseValue
(
TokenType
type
)
{
switch
(
type
)
{
case
BEGIN_OBJECT
:
return
HandleBeginObject
(
)
;
case
BEGIN_ARRAY
:
return
HandleBeginArray
(
)
;
case
BEGIN_STRING
:
return
ParseString
(
)
;
case
BEGIN_NUMBER
:
return
ParseNumber
(
)
;
case
BEGIN_TRUE
:
return
ParseTrue
(
)
;
case
BEGIN_FALSE
:
return
ParseFalse
(
)
;
case
BEGIN_NULL
:
return
ParseNull
(
)
;
case
UNKNOWN
:
return
ReportUnknown
(
"
Expected
a
value
.
"
ParseErrorType
:
:
EXPECTED_VALUE
)
;
default
:
{
if
(
!
finishing_
&
&
p_
.
length
(
)
<
kKeywordFalse
.
length
(
)
)
{
return
util
:
:
CancelledError
(
"
"
)
;
}
if
(
allow_empty_null_
&
&
IsEmptyNullAllowed
(
type
)
)
{
return
ParseEmptyNull
(
)
;
}
return
ReportFailure
(
"
Unexpected
token
.
"
ParseErrorType
:
:
UNEXPECTED_TOKEN
)
;
}
}
}
util
:
:
Status
JsonStreamParser
:
:
ParseString
(
)
{
util
:
:
Status
result
=
ParseStringHelper
(
)
;
if
(
result
.
ok
(
)
)
{
ow_
-
>
RenderString
(
key_
parsed_
)
;
key_
=
StringPiece
(
)
;
parsed_
=
StringPiece
(
)
;
parsed_storage_
.
clear
(
)
;
}
return
result
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseStringHelper
(
)
{
if
(
string_open_
=
=
0
)
{
string_open_
=
*
p_
.
data
(
)
;
GOOGLE_DCHECK
(
string_open_
=
=
'
\
"
'
|
|
string_open_
=
=
'
\
'
'
)
;
Advance
(
)
;
}
const
char
*
last
=
p_
.
data
(
)
;
while
(
!
p_
.
empty
(
)
)
{
const
char
*
data
=
p_
.
data
(
)
;
if
(
*
data
=
=
'
\
\
'
)
{
if
(
last
<
data
)
{
parsed_storage_
.
append
(
last
data
-
last
)
;
}
if
(
p_
.
length
(
)
=
=
1
)
{
if
(
!
finishing_
)
{
return
util
:
:
CancelledError
(
"
"
)
;
}
return
ReportFailure
(
"
Closing
quote
expected
in
string
.
"
ParseErrorType
:
:
EXPECTED_CLOSING_QUOTE
)
;
}
if
(
data
[
1
]
=
=
'
u
'
)
{
util
:
:
Status
result
=
ParseUnicodeEscape
(
)
;
if
(
!
result
.
ok
(
)
)
{
return
result
;
}
last
=
p_
.
data
(
)
;
continue
;
}
switch
(
data
[
1
]
)
{
case
'
b
'
:
parsed_storage_
.
push_back
(
'
\
b
'
)
;
break
;
case
'
f
'
:
parsed_storage_
.
push_back
(
'
\
f
'
)
;
break
;
case
'
n
'
:
parsed_storage_
.
push_back
(
'
\
n
'
)
;
break
;
case
'
r
'
:
parsed_storage_
.
push_back
(
'
\
r
'
)
;
break
;
case
'
t
'
:
parsed_storage_
.
push_back
(
'
\
t
'
)
;
break
;
case
'
v
'
:
parsed_storage_
.
push_back
(
'
\
v
'
)
;
break
;
default
:
parsed_storage_
.
push_back
(
data
[
1
]
)
;
}
p_
.
remove_prefix
(
2
)
;
last
=
p_
.
data
(
)
;
continue
;
}
if
(
*
data
=
=
string_open_
)
{
if
(
parsed_storage_
.
empty
(
)
)
{
parsed_
=
StringPiece
(
last
data
-
last
)
;
}
else
{
if
(
last
<
data
)
{
parsed_storage_
.
append
(
last
data
-
last
)
;
}
parsed_
=
StringPiece
(
parsed_storage_
)
;
}
string_open_
=
0
;
Advance
(
)
;
return
util
:
:
Status
(
)
;
}
Advance
(
)
;
}
if
(
last
<
p_
.
data
(
)
)
{
parsed_storage_
.
append
(
last
p_
.
data
(
)
-
last
)
;
}
if
(
!
finishing_
)
{
return
util
:
:
CancelledError
(
"
"
)
;
}
string_open_
=
0
;
return
ReportFailure
(
"
Closing
quote
expected
in
string
.
"
ParseErrorType
:
:
EXPECTED_CLOSING_QUOTE
)
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseUnicodeEscape
(
)
{
if
(
p_
.
length
(
)
<
kUnicodeEscapedLength
)
{
if
(
!
finishing_
)
{
return
util
:
:
CancelledError
(
"
"
)
;
}
return
ReportFailure
(
"
Illegal
hex
string
.
"
ParseErrorType
:
:
ILLEGAL_HEX_STRING
)
;
}
GOOGLE_DCHECK_EQ
(
'
\
\
'
p_
.
data
(
)
[
0
]
)
;
GOOGLE_DCHECK_EQ
(
'
u
'
p_
.
data
(
)
[
1
]
)
;
uint32_t
code
=
0
;
for
(
int
i
=
2
;
i
<
kUnicodeEscapedLength
;
+
+
i
)
{
if
(
!
isxdigit
(
p_
.
data
(
)
[
i
]
)
)
{
return
ReportFailure
(
"
Invalid
escape
sequence
.
"
ParseErrorType
:
:
INVALID_ESCAPE_SEQUENCE
)
;
}
code
=
(
code
<
<
4
)
+
hex_digit_to_int
(
p_
.
data
(
)
[
i
]
)
;
}
if
(
code
>
=
JsonEscaping
:
:
kMinHighSurrogate
&
&
code
<
=
JsonEscaping
:
:
kMaxHighSurrogate
)
{
if
(
p_
.
length
(
)
<
2
*
kUnicodeEscapedLength
)
{
if
(
!
finishing_
)
{
return
util
:
:
CancelledError
(
"
"
)
;
}
if
(
!
coerce_to_utf8_
)
{
return
ReportFailure
(
"
Missing
low
surrogate
.
"
ParseErrorType
:
:
MISSING_LOW_SURROGATE
)
;
}
}
else
if
(
p_
.
data
(
)
[
kUnicodeEscapedLength
]
=
=
'
\
\
'
&
&
p_
.
data
(
)
[
kUnicodeEscapedLength
+
1
]
=
=
'
u
'
)
{
uint32_t
low_code
=
0
;
for
(
int
i
=
kUnicodeEscapedLength
+
2
;
i
<
2
*
kUnicodeEscapedLength
;
+
+
i
)
{
if
(
!
isxdigit
(
p_
.
data
(
)
[
i
]
)
)
{
return
ReportFailure
(
"
Invalid
escape
sequence
.
"
ParseErrorType
:
:
INVALID_ESCAPE_SEQUENCE
)
;
}
low_code
=
(
low_code
<
<
4
)
+
hex_digit_to_int
(
p_
.
data
(
)
[
i
]
)
;
}
if
(
low_code
>
=
JsonEscaping
:
:
kMinLowSurrogate
&
&
low_code
<
=
JsonEscaping
:
:
kMaxLowSurrogate
)
{
code
=
(
(
(
code
&
0x3FF
)
<
<
10
)
|
(
low_code
&
0x3FF
)
)
+
JsonEscaping
:
:
kMinSupplementaryCodePoint
;
p_
.
remove_prefix
(
kUnicodeEscapedLength
)
;
}
else
if
(
!
coerce_to_utf8_
)
{
return
ReportFailure
(
"
Invalid
low
surrogate
.
"
ParseErrorType
:
:
INVALID_LOW_SURROGATE
)
;
}
}
else
if
(
!
coerce_to_utf8_
)
{
return
ReportFailure
(
"
Missing
low
surrogate
.
"
ParseErrorType
:
:
MISSING_LOW_SURROGATE
)
;
}
}
if
(
!
coerce_to_utf8_
&
&
!
IsValidCodePoint
(
code
)
)
{
return
ReportFailure
(
"
Invalid
unicode
code
point
.
"
ParseErrorType
:
:
INVALID_UNICODE
)
;
}
char
buf
[
UTFmax
]
;
int
len
=
EncodeAsUTF8Char
(
code
buf
)
;
p_
.
remove_prefix
(
kUnicodeEscapedLength
)
;
parsed_storage_
.
append
(
buf
len
)
;
return
util
:
:
Status
(
)
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseNumber
(
)
{
NumberResult
number
;
util
:
:
Status
result
=
ParseNumberHelper
(
&
number
)
;
if
(
result
.
ok
(
)
)
{
switch
(
number
.
type
)
{
case
NumberResult
:
:
DOUBLE
:
ow_
-
>
RenderDouble
(
key_
number
.
double_val
)
;
key_
=
StringPiece
(
)
;
break
;
case
NumberResult
:
:
INT
:
ow_
-
>
RenderInt64
(
key_
number
.
int_val
)
;
key_
=
StringPiece
(
)
;
break
;
case
NumberResult
:
:
UINT
:
ow_
-
>
RenderUint64
(
key_
number
.
uint_val
)
;
key_
=
StringPiece
(
)
;
break
;
default
:
return
ReportFailure
(
"
Unable
to
parse
number
.
"
ParseErrorType
:
:
UNABLE_TO_PARSE_NUMBER
)
;
}
}
return
result
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseDoubleHelper
(
const
std
:
:
string
&
number
NumberResult
*
result
)
{
if
(
!
safe_strtod
(
number
&
result
-
>
double_val
)
)
{
return
ReportFailure
(
"
Unable
to
parse
number
.
"
ParseErrorType
:
:
UNABLE_TO_PARSE_NUMBER
)
;
}
if
(
!
loose_float_number_conversion_
&
&
!
std
:
:
isfinite
(
result
-
>
double_val
)
)
{
return
ReportFailure
(
"
Number
exceeds
the
range
of
double
.
"
ParseErrorType
:
:
NUMBER_EXCEEDS_RANGE_DOUBLE
)
;
}
result
-
>
type
=
NumberResult
:
:
DOUBLE
;
return
util
:
:
Status
(
)
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseNumberHelper
(
NumberResult
*
result
)
{
const
char
*
data
=
p_
.
data
(
)
;
int
length
=
p_
.
length
(
)
;
int
index
=
0
;
bool
floating
=
false
;
bool
negative
=
data
[
index
]
=
=
'
-
'
;
for
(
;
index
<
length
;
+
+
index
)
{
char
c
=
data
[
index
]
;
if
(
isdigit
(
c
)
)
continue
;
if
(
c
=
=
'
.
'
|
|
c
=
=
'
e
'
|
|
c
=
=
'
E
'
)
{
floating
=
true
;
continue
;
}
if
(
c
=
=
'
+
'
|
|
c
=
=
'
-
'
|
|
c
=
=
'
x
'
)
continue
;
break
;
}
if
(
index
=
=
length
&
&
!
finishing_
)
{
return
util
:
:
CancelledError
(
"
"
)
;
}
std
:
:
string
number
=
std
:
:
string
(
p_
.
substr
(
0
index
)
)
;
if
(
floating
)
{
util
:
:
Status
status
=
ParseDoubleHelper
(
number
result
)
;
if
(
status
.
ok
(
)
)
{
p_
.
remove_prefix
(
index
)
;
}
return
status
;
}
if
(
!
negative
)
{
if
(
number
.
length
(
)
>
=
2
&
&
number
[
0
]
=
=
'
0
'
)
{
return
ReportFailure
(
"
Octal
/
hex
numbers
are
not
valid
JSON
values
.
"
ParseErrorType
:
:
OCTAL_OR_HEX_ARE_NOT_VALID_JSON_VALUES
)
;
}
if
(
safe_strtou64
(
number
&
result
-
>
uint_val
)
)
{
result
-
>
type
=
NumberResult
:
:
UINT
;
p_
.
remove_prefix
(
index
)
;
return
util
:
:
Status
(
)
;
}
else
{
util
:
:
Status
status
=
ParseDoubleHelper
(
number
result
)
;
if
(
status
.
ok
(
)
)
{
p_
.
remove_prefix
(
index
)
;
}
return
status
;
}
}
if
(
number
.
length
(
)
>
=
3
&
&
number
[
1
]
=
=
'
0
'
)
{
return
ReportFailure
(
"
Octal
/
hex
numbers
are
not
valid
JSON
values
.
"
ParseErrorType
:
:
OCTAL_OR_HEX_ARE_NOT_VALID_JSON_VALUES
)
;
}
if
(
safe_strto64
(
number
&
result
-
>
int_val
)
)
{
result
-
>
type
=
NumberResult
:
:
INT
;
p_
.
remove_prefix
(
index
)
;
return
util
:
:
Status
(
)
;
}
else
{
util
:
:
Status
status
=
ParseDoubleHelper
(
number
result
)
;
if
(
status
.
ok
(
)
)
{
p_
.
remove_prefix
(
index
)
;
}
return
status
;
}
}
util
:
:
Status
JsonStreamParser
:
:
HandleBeginObject
(
)
{
GOOGLE_DCHECK_EQ
(
'
{
'
*
p_
.
data
(
)
)
;
Advance
(
)
;
ow_
-
>
StartObject
(
key_
)
;
auto
status
=
IncrementRecursionDepth
(
key_
)
;
if
(
!
status
.
ok
(
)
)
{
return
status
;
}
key_
=
StringPiece
(
)
;
stack_
.
push
(
ENTRY
)
;
return
util
:
:
Status
(
)
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseObjectMid
(
TokenType
type
)
{
if
(
type
=
=
UNKNOWN
)
{
return
ReportUnknown
(
"
Expected
or
}
after
key
:
value
pair
.
"
ParseErrorType
:
:
EXPECTED_COMMA_OR_BRACES
)
;
}
if
(
type
=
=
END_OBJECT
)
{
Advance
(
)
;
ow_
-
>
EndObject
(
)
;
-
-
recursion_depth_
;
return
util
:
:
Status
(
)
;
}
if
(
type
=
=
VALUE_SEPARATOR
)
{
Advance
(
)
;
stack_
.
push
(
ENTRY
)
;
return
util
:
:
Status
(
)
;
}
return
ReportFailure
(
"
Expected
or
}
after
key
:
value
pair
.
"
ParseErrorType
:
:
EXPECTED_COMMA_OR_BRACES
)
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseEntry
(
TokenType
type
)
{
if
(
type
=
=
UNKNOWN
)
{
return
ReportUnknown
(
"
Expected
an
object
key
or
}
.
"
ParseErrorType
:
:
EXPECTED_OBJECT_KEY_OR_BRACES
)
;
}
if
(
type
=
=
END_OBJECT
)
{
ow_
-
>
EndObject
(
)
;
Advance
(
)
;
-
-
recursion_depth_
;
return
util
:
:
Status
(
)
;
}
util
:
:
Status
result
;
if
(
type
=
=
BEGIN_STRING
)
{
result
=
ParseStringHelper
(
)
;
if
(
result
.
ok
(
)
)
{
key_storage_
.
clear
(
)
;
if
(
!
parsed_storage_
.
empty
(
)
)
{
parsed_storage_
.
swap
(
key_storage_
)
;
key_
=
StringPiece
(
key_storage_
)
;
}
else
{
key_
=
parsed_
;
}
parsed_
=
StringPiece
(
)
;
}
}
else
if
(
type
=
=
BEGIN_KEY
)
{
result
=
ParseKey
(
)
;
}
else
if
(
type
=
=
BEGIN_NULL
|
|
type
=
=
BEGIN_TRUE
|
|
type
=
=
BEGIN_FALSE
)
{
result
=
ParseKey
(
)
;
if
(
result
.
ok
(
)
&
&
(
key_
=
=
kKeywordNull
|
|
key_
=
=
kKeywordTrue
|
|
key_
=
=
kKeywordFalse
)
)
{
result
=
ReportFailure
(
"
Expected
an
object
key
or
}
.
"
ParseErrorType
:
:
EXPECTED_OBJECT_KEY_OR_BRACES
)
;
}
}
else
{
result
=
ReportFailure
(
"
Expected
an
object
key
or
}
.
"
ParseErrorType
:
:
EXPECTED_OBJECT_KEY_OR_BRACES
)
;
}
if
(
result
.
ok
(
)
)
{
stack_
.
push
(
OBJ_MID
)
;
stack_
.
push
(
ENTRY_MID
)
;
}
return
result
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseEntryMid
(
TokenType
type
)
{
if
(
type
=
=
UNKNOWN
)
{
return
ReportUnknown
(
"
Expected
:
between
key
:
value
pair
.
"
ParseErrorType
:
:
EXPECTED_COLON
)
;
}
if
(
type
=
=
ENTRY_SEPARATOR
)
{
Advance
(
)
;
stack_
.
push
(
VALUE
)
;
return
util
:
:
Status
(
)
;
}
return
ReportFailure
(
"
Expected
:
between
key
:
value
pair
.
"
ParseErrorType
:
:
EXPECTED_COLON
)
;
}
util
:
:
Status
JsonStreamParser
:
:
HandleBeginArray
(
)
{
GOOGLE_DCHECK_EQ
(
'
[
'
*
p_
.
data
(
)
)
;
Advance
(
)
;
ow_
-
>
StartList
(
key_
)
;
key_
=
StringPiece
(
)
;
stack_
.
push
(
ARRAY_VALUE
)
;
return
util
:
:
Status
(
)
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseArrayValue
(
TokenType
type
)
{
if
(
type
=
=
UNKNOWN
)
{
return
ReportUnknown
(
"
Expected
a
value
or
]
within
an
array
.
"
ParseErrorType
:
:
EXPECTED_VALUE_OR_BRACKET
)
;
}
if
(
type
=
=
END_ARRAY
)
{
ow_
-
>
EndList
(
)
;
Advance
(
)
;
return
util
:
:
Status
(
)
;
}
stack_
.
push
(
ARRAY_MID
)
;
util
:
:
Status
result
=
ParseValue
(
type
)
;
if
(
util
:
:
IsCancelled
(
result
)
)
{
stack_
.
pop
(
)
;
}
return
result
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseArrayMid
(
TokenType
type
)
{
if
(
type
=
=
UNKNOWN
)
{
return
ReportUnknown
(
"
Expected
or
]
after
array
value
.
"
ParseErrorType
:
:
EXPECTED_COMMA_OR_BRACKET
)
;
}
if
(
type
=
=
END_ARRAY
)
{
ow_
-
>
EndList
(
)
;
Advance
(
)
;
return
util
:
:
Status
(
)
;
}
if
(
type
=
=
VALUE_SEPARATOR
)
{
Advance
(
)
;
stack_
.
push
(
ARRAY_VALUE
)
;
return
util
:
:
Status
(
)
;
}
return
ReportFailure
(
"
Expected
or
]
after
array
value
.
"
ParseErrorType
:
:
EXPECTED_COMMA_OR_BRACKET
)
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseTrue
(
)
{
ow_
-
>
RenderBool
(
key_
true
)
;
key_
=
StringPiece
(
)
;
p_
.
remove_prefix
(
kKeywordTrue
.
length
(
)
)
;
return
util
:
:
Status
(
)
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseFalse
(
)
{
ow_
-
>
RenderBool
(
key_
false
)
;
key_
=
StringPiece
(
)
;
p_
.
remove_prefix
(
kKeywordFalse
.
length
(
)
)
;
return
util
:
:
Status
(
)
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseNull
(
)
{
ow_
-
>
RenderNull
(
key_
)
;
key_
=
StringPiece
(
)
;
p_
.
remove_prefix
(
kKeywordNull
.
length
(
)
)
;
return
util
:
:
Status
(
)
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseEmptyNull
(
)
{
ow_
-
>
RenderNull
(
key_
)
;
key_
=
StringPiece
(
)
;
return
util
:
:
Status
(
)
;
}
bool
JsonStreamParser
:
:
IsEmptyNullAllowed
(
TokenType
type
)
{
if
(
stack_
.
empty
(
)
)
return
false
;
return
(
stack_
.
top
(
)
=
=
ARRAY_MID
&
&
type
=
=
VALUE_SEPARATOR
)
|
|
stack_
.
top
(
)
=
=
OBJ_MID
;
}
util
:
:
Status
JsonStreamParser
:
:
ReportFailure
(
StringPiece
message
ParseErrorType
parse_code
)
{
(
void
)
parse_code
;
static
const
int
kContextLength
=
20
;
const
char
*
p_start
=
p_
.
data
(
)
;
const
char
*
json_start
=
json_
.
data
(
)
;
const
char
*
begin
=
std
:
:
max
(
p_start
-
kContextLength
json_start
)
;
const
char
*
end
=
std
:
:
min
(
p_start
+
kContextLength
json_start
+
json_
.
size
(
)
)
;
StringPiece
segment
(
begin
end
-
begin
)
;
std
:
:
string
location
(
p_start
-
begin
'
'
)
;
location
.
push_back
(
'
^
'
)
;
auto
status
=
util
:
:
InvalidArgumentError
(
StrCat
(
message
"
\
n
"
segment
"
\
n
"
location
)
)
;
return
status
;
}
util
:
:
Status
JsonStreamParser
:
:
ReportUnknown
(
StringPiece
message
ParseErrorType
parse_code
)
{
if
(
!
finishing_
)
{
return
util
:
:
CancelledError
(
"
"
)
;
}
if
(
p_
.
empty
(
)
)
{
return
ReportFailure
(
StrCat
(
"
Unexpected
end
of
string
.
"
message
)
parse_code
)
;
}
return
ReportFailure
(
message
parse_code
)
;
}
util
:
:
Status
JsonStreamParser
:
:
IncrementRecursionDepth
(
StringPiece
key
)
const
{
if
(
+
+
recursion_depth_
>
max_recursion_depth_
)
{
return
util
:
:
InvalidArgumentError
(
StrCat
(
"
Message
too
deep
.
Max
recursion
depth
reached
for
key
'
"
key
"
'
"
)
)
;
}
return
util
:
:
Status
(
)
;
}
void
JsonStreamParser
:
:
SkipWhitespace
(
)
{
while
(
!
p_
.
empty
(
)
&
&
ascii_isspace
(
*
p_
.
data
(
)
)
)
{
Advance
(
)
;
}
if
(
!
p_
.
empty
(
)
&
&
!
ascii_isspace
(
*
p_
.
data
(
)
)
)
{
seen_non_whitespace_
=
true
;
}
}
void
JsonStreamParser
:
:
Advance
(
)
{
p_
.
remove_prefix
(
std
:
:
min
<
int
>
(
p_
.
length
(
)
UTF8FirstLetterNumBytes
(
p_
.
data
(
)
p_
.
length
(
)
)
)
)
;
}
util
:
:
Status
JsonStreamParser
:
:
ParseKey
(
)
{
StringPiece
original
=
p_
;
if
(
allow_permissive_key_naming_
)
{
if
(
!
ConsumeKeyPermissive
(
&
p_
&
key_
)
)
{
return
ReportFailure
(
"
Invalid
key
or
variable
name
.
"
ParseErrorType
:
:
INVALID_KEY_OR_VARIABLE_NAME
)
;
}
}
else
{
if
(
!
ConsumeKey
(
&
p_
&
key_
)
)
{
return
ReportFailure
(
"
Invalid
key
or
variable
name
.
"
ParseErrorType
:
:
INVALID_KEY_OR_VARIABLE_NAME
)
;
}
}
if
(
!
finishing_
&
&
p_
.
empty
(
)
)
{
p_
=
original
;
return
util
:
:
CancelledError
(
"
"
)
;
}
key_storage_
.
clear
(
)
;
return
util
:
:
Status
(
)
;
}
JsonStreamParser
:
:
TokenType
JsonStreamParser
:
:
GetNextTokenType
(
)
{
SkipWhitespace
(
)
;
int
size
=
p_
.
size
(
)
;
if
(
size
=
=
0
)
{
return
UNKNOWN
;
}
const
char
*
data
=
p_
.
data
(
)
;
StringPiece
data_view
=
StringPiece
(
data
size
)
;
if
(
*
data
=
=
'
\
"
'
|
|
*
data
=
=
'
\
'
'
)
return
BEGIN_STRING
;
if
(
*
data
=
=
'
-
'
|
|
(
'
0
'
<
=
*
data
&
&
*
data
<
=
'
9
'
)
)
{
return
BEGIN_NUMBER
;
}
if
(
size
>
=
kKeywordTrue
.
length
(
)
&
&
HasPrefixString
(
data_view
kKeywordTrue
)
)
{
return
BEGIN_TRUE
;
}
if
(
size
>
=
kKeywordFalse
.
length
(
)
&
&
HasPrefixString
(
data_view
kKeywordFalse
)
)
{
return
BEGIN_FALSE
;
}
if
(
size
>
=
kKeywordNull
.
length
(
)
&
&
HasPrefixString
(
data_view
kKeywordNull
)
)
{
return
BEGIN_NULL
;
}
if
(
*
data
=
=
'
{
'
)
return
BEGIN_OBJECT
;
if
(
*
data
=
=
'
}
'
)
return
END_OBJECT
;
if
(
*
data
=
=
'
[
'
)
return
BEGIN_ARRAY
;
if
(
*
data
=
=
'
]
'
)
return
END_ARRAY
;
if
(
*
data
=
=
'
:
'
)
return
ENTRY_SEPARATOR
;
if
(
*
data
=
=
'
'
)
return
VALUE_SEPARATOR
;
if
(
MatchKey
(
p_
)
)
{
return
BEGIN_KEY
;
}
return
UNKNOWN
;
}
}
}
}
}
