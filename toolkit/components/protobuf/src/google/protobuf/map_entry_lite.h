#
ifndef
GOOGLE_PROTOBUF_MAP_ENTRY_LITE_H__
#
define
GOOGLE_PROTOBUF_MAP_ENTRY_LITE_H__
#
include
<
assert
.
h
>
#
include
<
google
/
protobuf
/
arena
.
h
>
#
include
<
google
/
protobuf
/
map
.
h
>
#
include
<
google
/
protobuf
/
map_type_handler
.
h
>
#
include
<
google
/
protobuf
/
wire_format_lite_inl
.
h
>
namespace
google
{
namespace
protobuf
{
namespace
internal
{
template
<
typename
Derived
typename
Key
typename
Value
WireFormatLite
:
:
FieldType
kKeyFieldType
WireFormatLite
:
:
FieldType
kValueFieldType
int
default_enum_value
>
class
MapEntry
;
template
<
typename
Derived
typename
Key
typename
Value
WireFormatLite
:
:
FieldType
kKeyFieldType
WireFormatLite
:
:
FieldType
kValueFieldType
int
default_enum_value
>
class
MapFieldLite
;
}
}
namespace
protobuf
{
namespace
internal
{
template
<
bool
is_enum
bool
is_message
bool
is_stringlike
typename
T
>
struct
MoveHelper
{
static
void
Move
(
T
*
src
T
*
dest
)
{
*
dest
=
*
src
;
}
}
;
template
<
bool
is_message
bool
is_stringlike
typename
T
>
struct
MoveHelper
<
true
is_message
is_stringlike
T
>
{
static
void
Move
(
T
*
src
T
*
dest
)
{
*
dest
=
*
src
;
}
static
void
Move
(
T
*
src
int
*
dest
)
{
*
dest
=
static_cast
<
int
>
(
*
src
)
;
}
static
void
Move
(
int
*
src
T
*
dest
)
{
*
dest
=
static_cast
<
T
>
(
*
src
)
;
}
}
;
template
<
bool
is_stringlike
typename
T
>
struct
MoveHelper
<
false
true
is_stringlike
T
>
{
static
void
Move
(
T
*
src
T
*
dest
)
{
dest
-
>
Swap
(
src
)
;
}
}
;
template
<
typename
T
>
struct
MoveHelper
<
false
false
true
T
>
{
static
void
Move
(
T
*
src
T
*
dest
)
{
#
if
__cplusplus
>
=
201103L
*
dest
=
std
:
:
move
(
*
src
)
;
#
else
dest
-
>
swap
(
*
src
)
;
#
endif
}
}
;
template
<
typename
Derived
typename
Base
typename
Key
typename
Value
WireFormatLite
:
:
FieldType
kKeyFieldType
WireFormatLite
:
:
FieldType
kValueFieldType
int
default_enum_value
>
class
MapEntryImpl
:
public
Base
{
protected
:
typedef
MapTypeHandler
<
kKeyFieldType
Key
>
KeyTypeHandler
;
typedef
MapTypeHandler
<
kValueFieldType
Value
>
ValueTypeHandler
;
typedef
typename
KeyTypeHandler
:
:
TypeOnMemory
KeyOnMemory
;
typedef
typename
ValueTypeHandler
:
:
TypeOnMemory
ValueOnMemory
;
typedef
typename
KeyTypeHandler
:
:
MapEntryAccessorType
KeyMapEntryAccessorType
;
typedef
typename
ValueTypeHandler
:
:
MapEntryAccessorType
ValueMapEntryAccessorType
;
static
const
int
kKeyFieldNumber
=
1
;
static
const
int
kValueFieldNumber
=
2
;
static
const
uint8
kKeyTag
=
GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG
(
kKeyFieldNumber
KeyTypeHandler
:
:
kWireType
)
;
static
const
uint8
kValueTag
=
GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG
(
kValueFieldNumber
ValueTypeHandler
:
:
kWireType
)
;
static
const
size_t
kTagSize
=
1
;
public
:
typedef
void
MapEntryHasMergeTypeTrait
;
typedef
Derived
EntryType
;
typedef
Key
EntryKeyType
;
typedef
Value
EntryValueType
;
static
const
WireFormatLite
:
:
FieldType
kEntryKeyFieldType
=
kKeyFieldType
;
static
const
WireFormatLite
:
:
FieldType
kEntryValueFieldType
=
kValueFieldType
;
static
const
int
kEntryDefaultEnumValue
=
default_enum_value
;
MapEntryImpl
(
)
:
default_instance_
(
NULL
)
arena_
(
NULL
)
{
KeyTypeHandler
:
:
Initialize
(
&
key_
NULL
)
;
ValueTypeHandler
:
:
InitializeMaybeByDefaultEnum
(
&
value_
default_enum_value
NULL
)
;
_has_bits_
[
0
]
=
0
;
}
explicit
MapEntryImpl
(
Arena
*
arena
)
:
default_instance_
(
NULL
)
arena_
(
arena
)
{
KeyTypeHandler
:
:
Initialize
(
&
key_
arena
)
;
ValueTypeHandler
:
:
InitializeMaybeByDefaultEnum
(
&
value_
default_enum_value
arena
)
;
_has_bits_
[
0
]
=
0
;
}
~
MapEntryImpl
(
)
{
if
(
this
!
=
default_instance_
)
{
if
(
GetArenaNoVirtual
(
)
!
=
NULL
)
return
;
KeyTypeHandler
:
:
DeleteNoArena
(
key_
)
;
ValueTypeHandler
:
:
DeleteNoArena
(
value_
)
;
}
}
virtual
inline
const
KeyMapEntryAccessorType
&
key
(
)
const
{
return
KeyTypeHandler
:
:
GetExternalReference
(
key_
)
;
}
virtual
inline
const
ValueMapEntryAccessorType
&
value
(
)
const
{
GOOGLE_CHECK
(
default_instance_
!
=
NULL
)
;
return
ValueTypeHandler
:
:
DefaultIfNotInitialized
(
value_
default_instance_
-
>
value_
)
;
}
inline
KeyMapEntryAccessorType
*
mutable_key
(
)
{
set_has_key
(
)
;
return
KeyTypeHandler
:
:
EnsureMutable
(
&
key_
GetArenaNoVirtual
(
)
)
;
}
inline
ValueMapEntryAccessorType
*
mutable_value
(
)
{
set_has_value
(
)
;
return
ValueTypeHandler
:
:
EnsureMutable
(
&
value_
GetArenaNoVirtual
(
)
)
;
}
string
GetTypeName
(
)
const
{
return
"
"
;
}
void
CheckTypeAndMergeFrom
(
const
MessageLite
&
other
)
{
MergeFromInternal
(
*
:
:
google
:
:
protobuf
:
:
down_cast
<
const
Derived
*
>
(
&
other
)
)
;
}
bool
MergePartialFromCodedStream
(
:
:
google
:
:
protobuf
:
:
io
:
:
CodedInputStream
*
input
)
{
uint32
tag
;
for
(
;
;
)
{
tag
=
input
-
>
ReadTagNoLastTag
(
)
;
switch
(
tag
)
{
case
kKeyTag
:
if
(
!
KeyTypeHandler
:
:
Read
(
input
mutable_key
(
)
)
)
{
return
false
;
}
set_has_key
(
)
;
if
(
!
input
-
>
ExpectTag
(
kValueTag
)
)
break
;
GOOGLE_FALLTHROUGH_INTENDED
;
case
kValueTag
:
if
(
!
ValueTypeHandler
:
:
Read
(
input
mutable_value
(
)
)
)
{
return
false
;
}
set_has_value
(
)
;
if
(
input
-
>
ExpectAtEnd
(
)
)
return
true
;
break
;
default
:
if
(
tag
=
=
0
|
|
WireFormatLite
:
:
GetTagWireType
(
tag
)
=
=
WireFormatLite
:
:
WIRETYPE_END_GROUP
)
{
return
true
;
}
if
(
!
WireFormatLite
:
:
SkipField
(
input
tag
)
)
return
false
;
break
;
}
}
}
size_t
ByteSizeLong
(
)
const
{
size_t
size
=
0
;
size
+
=
has_key
(
)
?
kTagSize
+
static_cast
<
size_t
>
(
KeyTypeHandler
:
:
ByteSize
(
key
(
)
)
)
:
0
;
size
+
=
has_value
(
)
?
kTagSize
+
static_cast
<
size_t
>
(
ValueTypeHandler
:
:
ByteSize
(
value
(
)
)
)
:
0
;
return
size
;
}
void
SerializeWithCachedSizes
(
:
:
google
:
:
protobuf
:
:
io
:
:
CodedOutputStream
*
output
)
const
{
KeyTypeHandler
:
:
Write
(
kKeyFieldNumber
key
(
)
output
)
;
ValueTypeHandler
:
:
Write
(
kValueFieldNumber
value
(
)
output
)
;
}
:
:
google
:
:
protobuf
:
:
uint8
*
InternalSerializeWithCachedSizesToArray
(
bool
deterministic
:
:
google
:
:
protobuf
:
:
uint8
*
output
)
const
{
output
=
KeyTypeHandler
:
:
InternalWriteToArray
(
kKeyFieldNumber
key
(
)
deterministic
output
)
;
output
=
ValueTypeHandler
:
:
InternalWriteToArray
(
kValueFieldNumber
value
(
)
deterministic
output
)
;
return
output
;
}
int
GetCachedSize
(
)
const
{
int
size
=
0
;
size
+
=
has_key
(
)
?
static_cast
<
int
>
(
kTagSize
)
+
KeyTypeHandler
:
:
GetCachedSize
(
key
(
)
)
:
0
;
size
+
=
has_value
(
)
?
static_cast
<
int
>
(
kTagSize
)
+
ValueTypeHandler
:
:
GetCachedSize
(
value
(
)
)
:
0
;
return
size
;
}
bool
IsInitialized
(
)
const
{
return
ValueTypeHandler
:
:
IsInitialized
(
value_
)
;
}
Base
*
New
(
)
const
{
Derived
*
entry
=
new
Derived
;
entry
-
>
default_instance_
=
default_instance_
;
return
entry
;
}
Base
*
New
(
Arena
*
arena
)
const
{
Derived
*
entry
=
Arena
:
:
CreateMessage
<
Derived
>
(
arena
)
;
entry
-
>
default_instance_
=
default_instance_
;
return
entry
;
}
size_t
SpaceUsedLong
(
)
const
{
size_t
size
=
sizeof
(
Derived
)
;
size
+
=
KeyTypeHandler
:
:
SpaceUsedInMapEntryLong
(
key_
)
;
size
+
=
ValueTypeHandler
:
:
SpaceUsedInMapEntryLong
(
value_
)
;
return
size
;
}
protected
:
void
MergeFromInternal
(
const
MapEntryImpl
&
from
)
{
if
(
from
.
_has_bits_
[
0
]
)
{
if
(
from
.
has_key
(
)
)
{
KeyTypeHandler
:
:
EnsureMutable
(
&
key_
GetArenaNoVirtual
(
)
)
;
KeyTypeHandler
:
:
Merge
(
from
.
key
(
)
&
key_
GetArenaNoVirtual
(
)
)
;
set_has_key
(
)
;
}
if
(
from
.
has_value
(
)
)
{
ValueTypeHandler
:
:
EnsureMutable
(
&
value_
GetArenaNoVirtual
(
)
)
;
ValueTypeHandler
:
:
Merge
(
from
.
value
(
)
&
value_
GetArenaNoVirtual
(
)
)
;
set_has_value
(
)
;
}
}
}
public
:
void
Clear
(
)
{
KeyTypeHandler
:
:
Clear
(
&
key_
GetArenaNoVirtual
(
)
)
;
ValueTypeHandler
:
:
ClearMaybeByDefaultEnum
(
&
value_
GetArenaNoVirtual
(
)
default_enum_value
)
;
clear_has_key
(
)
;
clear_has_value
(
)
;
}
void
set_default_instance
(
MapEntryImpl
*
default_instance
)
{
default_instance_
=
default_instance
;
}
void
InitAsDefaultInstance
(
)
{
KeyTypeHandler
:
:
AssignDefaultValue
(
&
key_
)
;
ValueTypeHandler
:
:
AssignDefaultValue
(
&
value_
)
;
}
Arena
*
GetArena
(
)
const
{
return
GetArenaNoVirtual
(
)
;
}
static
Derived
*
EnumWrap
(
const
Key
&
key
const
Value
value
Arena
*
arena
)
{
return
Arena
:
:
CreateMessage
<
MapEnumEntryWrapper
>
(
arena
key
value
)
;
}
static
Derived
*
Wrap
(
const
Key
&
key
const
Value
&
value
Arena
*
arena
)
{
return
Arena
:
:
CreateMessage
<
MapEntryWrapper
>
(
arena
key
value
)
;
}
template
<
typename
MapField
typename
Map
>
class
Parser
{
public
:
explicit
Parser
(
MapField
*
mf
)
:
mf_
(
mf
)
map_
(
mf
-
>
MutableMap
(
)
)
{
}
bool
MergePartialFromCodedStream
(
:
:
google
:
:
protobuf
:
:
io
:
:
CodedInputStream
*
input
)
{
if
(
input
-
>
ExpectTag
(
kKeyTag
)
)
{
if
(
!
KeyTypeHandler
:
:
Read
(
input
&
key_
)
)
{
return
false
;
}
const
void
*
data
;
int
size
;
input
-
>
GetDirectBufferPointerInline
(
&
data
&
size
)
;
GOOGLE_COMPILE_ASSERT
(
kTagSize
=
=
1
tag_size_error
)
;
if
(
size
>
0
&
&
*
reinterpret_cast
<
const
char
*
>
(
data
)
=
=
kValueTag
)
{
typename
Map
:
:
size_type
size
=
map_
-
>
size
(
)
;
value_ptr_
=
&
(
*
map_
)
[
key_
]
;
if
(
GOOGLE_PREDICT_TRUE
(
size
!
=
map_
-
>
size
(
)
)
)
{
typedef
typename
MapIf
<
ValueTypeHandler
:
:
kIsEnum
int
*
Value
*
>
:
:
type
T
;
input
-
>
Skip
(
kTagSize
)
;
if
(
!
ValueTypeHandler
:
:
Read
(
input
reinterpret_cast
<
T
>
(
value_ptr_
)
)
)
{
map_
-
>
erase
(
key_
)
;
return
false
;
}
if
(
input
-
>
ExpectAtEnd
(
)
)
return
true
;
return
ReadBeyondKeyValuePair
(
input
)
;
}
}
}
else
{
key_
=
Key
(
)
;
}
entry_
.
reset
(
mf_
-
>
NewEntry
(
)
)
;
*
entry_
-
>
mutable_key
(
)
=
key_
;
const
bool
result
=
entry_
-
>
MergePartialFromCodedStream
(
input
)
;
if
(
result
)
UseKeyAndValueFromEntry
(
)
;
if
(
entry_
-
>
GetArena
(
)
!
=
NULL
)
entry_
.
release
(
)
;
return
result
;
}
const
Key
&
key
(
)
const
{
return
key_
;
}
const
Value
&
value
(
)
const
{
return
*
value_ptr_
;
}
private
:
void
UseKeyAndValueFromEntry
(
)
GOOGLE_ATTRIBUTE_COLD
{
key_
=
entry_
-
>
key
(
)
;
value_ptr_
=
&
(
*
map_
)
[
key_
]
;
MoveHelper
<
ValueTypeHandler
:
:
kIsEnum
ValueTypeHandler
:
:
kIsMessage
ValueTypeHandler
:
:
kWireType
=
=
WireFormatLite
:
:
WIRETYPE_LENGTH_DELIMITED
Value
>
:
:
Move
(
entry_
-
>
mutable_value
(
)
value_ptr_
)
;
}
bool
ReadBeyondKeyValuePair
(
:
:
google
:
:
protobuf
:
:
io
:
:
CodedInputStream
*
input
)
GOOGLE_ATTRIBUTE_COLD
{
typedef
MoveHelper
<
KeyTypeHandler
:
:
kIsEnum
KeyTypeHandler
:
:
kIsMessage
KeyTypeHandler
:
:
kWireType
=
=
WireFormatLite
:
:
WIRETYPE_LENGTH_DELIMITED
Key
>
KeyMover
;
typedef
MoveHelper
<
ValueTypeHandler
:
:
kIsEnum
ValueTypeHandler
:
:
kIsMessage
ValueTypeHandler
:
:
kWireType
=
=
WireFormatLite
:
:
WIRETYPE_LENGTH_DELIMITED
Value
>
ValueMover
;
entry_
.
reset
(
mf_
-
>
NewEntry
(
)
)
;
ValueMover
:
:
Move
(
value_ptr_
entry_
-
>
mutable_value
(
)
)
;
map_
-
>
erase
(
key_
)
;
KeyMover
:
:
Move
(
&
key_
entry_
-
>
mutable_key
(
)
)
;
const
bool
result
=
entry_
-
>
MergePartialFromCodedStream
(
input
)
;
if
(
result
)
UseKeyAndValueFromEntry
(
)
;
if
(
entry_
-
>
GetArena
(
)
!
=
NULL
)
entry_
.
release
(
)
;
return
result
;
}
MapField
*
const
mf_
;
Map
*
const
map_
;
Key
key_
;
Value
*
value_ptr_
;
google
:
:
protobuf
:
:
scoped_ptr
<
MapEntryImpl
>
entry_
;
}
;
protected
:
void
set_has_key
(
)
{
_has_bits_
[
0
]
|
=
0x00000001u
;
}
bool
has_key
(
)
const
{
return
(
_has_bits_
[
0
]
&
0x00000001u
)
!
=
0
;
}
void
clear_has_key
(
)
{
_has_bits_
[
0
]
&
=
~
0x00000001u
;
}
void
set_has_value
(
)
{
_has_bits_
[
0
]
|
=
0x00000002u
;
}
bool
has_value
(
)
const
{
return
(
_has_bits_
[
0
]
&
0x00000002u
)
!
=
0
;
}
void
clear_has_value
(
)
{
_has_bits_
[
0
]
&
=
~
0x00000002u
;
}
private
:
class
MapEntryWrapper
:
public
Derived
{
typedef
Derived
BaseClass
;
typedef
typename
BaseClass
:
:
KeyMapEntryAccessorType
KeyMapEntryAccessorType
;
typedef
typename
BaseClass
:
:
ValueMapEntryAccessorType
ValueMapEntryAccessorType
;
public
:
MapEntryWrapper
(
Arena
*
arena
const
Key
&
key
const
Value
&
value
)
:
Derived
(
arena
)
key_
(
key
)
value_
(
value
)
{
BaseClass
:
:
set_has_key
(
)
;
BaseClass
:
:
set_has_value
(
)
;
}
inline
const
KeyMapEntryAccessorType
&
key
(
)
const
{
return
key_
;
}
inline
const
ValueMapEntryAccessorType
&
value
(
)
const
{
return
value_
;
}
private
:
const
Key
&
key_
;
const
Value
&
value_
;
friend
class
:
:
google
:
:
protobuf
:
:
Arena
;
typedef
void
InternalArenaConstructable_
;
typedef
void
DestructorSkippable_
;
}
;
class
MapEnumEntryWrapper
:
public
Derived
{
typedef
Derived
BaseClass
;
typedef
typename
BaseClass
:
:
KeyMapEntryAccessorType
KeyMapEntryAccessorType
;
typedef
typename
BaseClass
:
:
ValueMapEntryAccessorType
ValueMapEntryAccessorType
;
public
:
MapEnumEntryWrapper
(
Arena
*
arena
const
Key
&
key
const
Value
&
value
)
:
Derived
(
arena
)
key_
(
key
)
value_
(
value
)
{
BaseClass
:
:
set_has_key
(
)
;
BaseClass
:
:
set_has_value
(
)
;
}
inline
const
KeyMapEntryAccessorType
&
key
(
)
const
{
return
key_
;
}
inline
const
ValueMapEntryAccessorType
&
value
(
)
const
{
return
value_
;
}
private
:
const
KeyMapEntryAccessorType
&
key_
;
const
ValueMapEntryAccessorType
value_
;
friend
class
google
:
:
protobuf
:
:
Arena
;
typedef
void
DestructorSkippable_
;
}
;
inline
Arena
*
GetArenaNoVirtual
(
)
const
{
return
arena_
;
}
MapEntryImpl
*
default_instance_
;
KeyOnMemory
key_
;
ValueOnMemory
value_
;
Arena
*
arena_
;
uint32
_has_bits_
[
1
]
;
friend
class
:
:
google
:
:
protobuf
:
:
Arena
;
typedef
void
InternalArenaConstructable_
;
typedef
void
DestructorSkippable_
;
template
<
typename
C
typename
K
typename
V
WireFormatLite
:
:
FieldType
WireFormatLite
:
:
FieldType
int
>
friend
class
internal
:
:
MapEntry
;
template
<
typename
C
typename
K
typename
V
WireFormatLite
:
:
FieldType
WireFormatLite
:
:
FieldType
int
>
friend
class
internal
:
:
MapFieldLite
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
MapEntryImpl
)
;
}
;
template
<
typename
Key
typename
Value
WireFormatLite
:
:
FieldType
kKeyFieldType
WireFormatLite
:
:
FieldType
kValueFieldType
int
default_enum_value
>
class
MapEntryLite
:
public
MapEntryImpl
<
MapEntryLite
<
Key
Value
kKeyFieldType
kValueFieldType
default_enum_value
>
MessageLite
Key
Value
kKeyFieldType
kValueFieldType
default_enum_value
>
{
public
:
typedef
MapEntryImpl
<
MapEntryLite
MessageLite
Key
Value
kKeyFieldType
kValueFieldType
default_enum_value
>
SuperType
;
MapEntryLite
(
)
{
}
explicit
MapEntryLite
(
Arena
*
arena
)
:
SuperType
(
arena
)
{
}
void
MergeFrom
(
const
MapEntryLite
<
Key
Value
kKeyFieldType
kValueFieldType
default_enum_value
>
&
other
)
{
MergeFromInternal
(
other
)
;
}
private
:
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
MapEntryLite
)
;
}
;
template
<
typename
Derived
>
struct
DeconstructMapEntry
;
template
<
typename
K
typename
V
WireFormatLite
:
:
FieldType
key
WireFormatLite
:
:
FieldType
value
int
default_enum
>
struct
DeconstructMapEntry
<
MapEntryLite
<
K
V
key
value
default_enum
>
>
{
typedef
K
Key
;
typedef
V
Value
;
static
const
WireFormatLite
:
:
FieldType
kKeyFieldType
=
key
;
static
const
WireFormatLite
:
:
FieldType
kValueFieldType
=
value
;
static
const
int
default_enum_value
=
default_enum
;
}
;
template
<
typename
Key
typename
PtrToKeyValuePair
>
struct
SortItem
{
SortItem
(
)
{
}
explicit
SortItem
(
PtrToKeyValuePair
p
)
:
first
(
p
-
>
first
)
second
(
p
)
{
}
Key
first
;
PtrToKeyValuePair
second
;
}
;
template
<
typename
T
>
struct
CompareByFirstField
{
bool
operator
(
)
(
const
T
&
a
const
T
&
b
)
const
{
return
a
.
first
<
b
.
first
;
}
}
;
template
<
typename
T
>
struct
CompareByDerefFirst
{
bool
operator
(
)
(
const
T
&
a
const
T
&
b
)
const
{
return
a
-
>
first
<
b
-
>
first
;
}
}
;
template
<
WireFormatLite
:
:
FieldType
FieldType
>
struct
FromHelper
{
template
<
typename
T
>
static
const
T
&
From
(
const
T
&
x
)
{
return
x
;
}
}
;
template
<
>
struct
FromHelper
<
WireFormatLite
:
:
TYPE_STRING
>
{
static
ArenaStringPtr
From
(
const
string
&
x
)
{
ArenaStringPtr
res
;
res
.
UnsafeArenaSetAllocated
(
NULL
const_cast
<
string
*
>
(
&
x
)
NULL
)
;
return
res
;
}
}
;
template
<
>
struct
FromHelper
<
WireFormatLite
:
:
TYPE_BYTES
>
{
static
ArenaStringPtr
From
(
const
string
&
x
)
{
ArenaStringPtr
res
;
res
.
UnsafeArenaSetAllocated
(
NULL
const_cast
<
string
*
>
(
&
x
)
NULL
)
;
return
res
;
}
}
;
template
<
>
struct
FromHelper
<
WireFormatLite
:
:
TYPE_MESSAGE
>
{
template
<
typename
T
>
static
T
*
From
(
const
T
&
x
)
{
return
const_cast
<
T
*
>
(
&
x
)
;
}
}
;
template
<
typename
MapEntryType
>
struct
MapEntryHelper
;
template
<
typename
Key
typename
Value
WireFormatLite
:
:
FieldType
kKeyFieldType
WireFormatLite
:
:
FieldType
kValueFieldType
int
default_enum_value
>
struct
MapEntryHelper
<
MapEntryLite
<
Key
Value
kKeyFieldType
kValueFieldType
default_enum_value
>
>
{
typedef
MapTypeHandler
<
kKeyFieldType
Key
>
KeyTypeHandler
;
typedef
MapTypeHandler
<
kValueFieldType
Value
>
ValueTypeHandler
;
typedef
typename
KeyTypeHandler
:
:
TypeOnMemory
KeyOnMemory
;
typedef
typename
ValueTypeHandler
:
:
TypeOnMemory
ValueOnMemory
;
explicit
MapEntryHelper
(
const
MapPair
<
Key
Value
>
&
map_pair
)
:
_has_bits_
(
3
)
_cached_size_
(
2
+
KeyTypeHandler
:
:
GetCachedSize
(
map_pair
.
first
)
+
ValueTypeHandler
:
:
GetCachedSize
(
map_pair
.
second
)
)
key_
(
FromHelper
<
kKeyFieldType
>
:
:
From
(
map_pair
.
first
)
)
value_
(
FromHelper
<
kValueFieldType
>
:
:
From
(
map_pair
.
second
)
)
{
}
uint32
_has_bits_
;
uint32
_cached_size_
;
KeyOnMemory
key_
;
ValueOnMemory
value_
;
}
;
}
}
}
#
endif
