#
ifndef
GOOGLE_PROTOBUF_MAP_ENTRY_LITE_H__
#
define
GOOGLE_PROTOBUF_MAP_ENTRY_LITE_H__
#
include
<
assert
.
h
>
#
include
<
string
>
#
include
<
google
/
protobuf
/
stubs
/
casts
.
h
>
#
include
<
google
/
protobuf
/
parse_context
.
h
>
#
include
<
google
/
protobuf
/
io
/
coded_stream
.
h
>
#
include
<
google
/
protobuf
/
arena
.
h
>
#
include
<
google
/
protobuf
/
arenastring
.
h
>
#
include
<
google
/
protobuf
/
generated_message_util
.
h
>
#
include
<
google
/
protobuf
/
map
.
h
>
#
include
<
google
/
protobuf
/
map_type_handler
.
h
>
#
include
<
google
/
protobuf
/
port
.
h
>
#
include
<
google
/
protobuf
/
wire_format_lite
.
h
>
#
include
<
google
/
protobuf
/
port_def
.
inc
>
#
ifdef
SWIG
#
error
"
You
cannot
SWIG
proto
headers
"
#
endif
namespace
google
{
namespace
protobuf
{
namespace
internal
{
template
<
typename
Derived
typename
Key
typename
Value
WireFormatLite
:
:
FieldType
kKeyFieldType
WireFormatLite
:
:
FieldType
kValueFieldType
int
default_enum_value
>
class
MapEntry
;
template
<
typename
Derived
typename
Key
typename
Value
WireFormatLite
:
:
FieldType
kKeyFieldType
WireFormatLite
:
:
FieldType
kValueFieldType
int
default_enum_value
>
class
MapFieldLite
;
}
}
}
namespace
google
{
namespace
protobuf
{
namespace
internal
{
template
<
bool
is_enum
bool
is_message
bool
is_stringlike
typename
T
>
struct
MoveHelper
{
static
void
Move
(
T
*
src
T
*
dest
)
{
*
dest
=
*
src
;
}
}
;
template
<
bool
is_message
bool
is_stringlike
typename
T
>
struct
MoveHelper
<
true
is_message
is_stringlike
T
>
{
static
void
Move
(
T
*
src
T
*
dest
)
{
*
dest
=
*
src
;
}
static
void
Move
(
T
*
src
int
*
dest
)
{
*
dest
=
static_cast
<
int
>
(
*
src
)
;
}
static
void
Move
(
int
*
src
T
*
dest
)
{
*
dest
=
static_cast
<
T
>
(
*
src
)
;
}
}
;
template
<
bool
is_stringlike
typename
T
>
struct
MoveHelper
<
false
true
is_stringlike
T
>
{
static
void
Move
(
T
*
src
T
*
dest
)
{
dest
-
>
Swap
(
src
)
;
}
}
;
template
<
typename
T
>
struct
MoveHelper
<
false
false
true
T
>
{
static
void
Move
(
T
*
src
T
*
dest
)
{
#
if
__cplusplus
>
=
201103L
*
dest
=
std
:
:
move
(
*
src
)
;
#
else
dest
-
>
swap
(
*
src
)
;
#
endif
}
}
;
template
<
typename
Key
typename
Value
WireFormatLite
:
:
FieldType
kKeyFieldType
WireFormatLite
:
:
FieldType
kValueFieldType
>
struct
MapEntryFuncs
{
typedef
MapTypeHandler
<
kKeyFieldType
Key
>
KeyTypeHandler
;
typedef
MapTypeHandler
<
kValueFieldType
Value
>
ValueTypeHandler
;
static
const
int
kKeyFieldNumber
=
1
;
static
const
int
kValueFieldNumber
=
2
;
static
uint8
*
InternalSerialize
(
int
field_number
const
Key
&
key
const
Value
&
value
uint8
*
ptr
io
:
:
EpsCopyOutputStream
*
stream
)
{
ptr
=
stream
-
>
EnsureSpace
(
ptr
)
;
ptr
=
WireFormatLite
:
:
WriteTagToArray
(
field_number
WireFormatLite
:
:
WIRETYPE_LENGTH_DELIMITED
ptr
)
;
ptr
=
io
:
:
CodedOutputStream
:
:
WriteVarint32ToArray
(
GetCachedSize
(
key
value
)
ptr
)
;
ptr
=
KeyTypeHandler
:
:
Write
(
kKeyFieldNumber
key
ptr
stream
)
;
return
ValueTypeHandler
:
:
Write
(
kValueFieldNumber
value
ptr
stream
)
;
}
static
size_t
ByteSizeLong
(
const
Key
&
key
const
Value
&
value
)
{
size_t
inner_length
=
2
+
KeyTypeHandler
:
:
ByteSize
(
key
)
+
ValueTypeHandler
:
:
ByteSize
(
value
)
;
return
inner_length
+
io
:
:
CodedOutputStream
:
:
VarintSize32
(
static_cast
<
uint32
>
(
inner_length
)
)
;
}
static
int
GetCachedSize
(
const
Key
&
key
const
Value
&
value
)
{
return
2
+
KeyTypeHandler
:
:
GetCachedSize
(
key
)
+
ValueTypeHandler
:
:
GetCachedSize
(
value
)
;
}
}
;
template
<
typename
Derived
typename
Base
typename
Key
typename
Value
WireFormatLite
:
:
FieldType
kKeyFieldType
WireFormatLite
:
:
FieldType
kValueFieldType
int
default_enum_value
>
class
MapEntryImpl
:
public
Base
{
public
:
typedef
MapEntryFuncs
<
Key
Value
kKeyFieldType
kValueFieldType
>
Funcs
;
protected
:
typedef
MapTypeHandler
<
kKeyFieldType
Key
>
KeyTypeHandler
;
typedef
MapTypeHandler
<
kValueFieldType
Value
>
ValueTypeHandler
;
typedef
typename
KeyTypeHandler
:
:
TypeOnMemory
KeyOnMemory
;
typedef
typename
ValueTypeHandler
:
:
TypeOnMemory
ValueOnMemory
;
typedef
typename
KeyTypeHandler
:
:
MapEntryAccessorType
KeyMapEntryAccessorType
;
typedef
typename
ValueTypeHandler
:
:
MapEntryAccessorType
ValueMapEntryAccessorType
;
static
const
int
kKeyFieldNumber
=
1
;
static
const
int
kValueFieldNumber
=
2
;
static
const
uint8
kKeyTag
=
GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG
(
kKeyFieldNumber
KeyTypeHandler
:
:
kWireType
)
;
static
const
uint8
kValueTag
=
GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG
(
kValueFieldNumber
ValueTypeHandler
:
:
kWireType
)
;
static
const
size_t
kTagSize
=
1
;
public
:
typedef
void
MapEntryHasMergeTypeTrait
;
typedef
Derived
EntryType
;
typedef
Key
EntryKeyType
;
typedef
Value
EntryValueType
;
static
const
WireFormatLite
:
:
FieldType
kEntryKeyFieldType
=
kKeyFieldType
;
static
const
WireFormatLite
:
:
FieldType
kEntryValueFieldType
=
kValueFieldType
;
static
const
int
kEntryDefaultEnumValue
=
default_enum_value
;
MapEntryImpl
(
)
:
arena_
(
NULL
)
{
KeyTypeHandler
:
:
Initialize
(
&
key_
NULL
)
;
ValueTypeHandler
:
:
InitializeMaybeByDefaultEnum
(
&
value_
default_enum_value
NULL
)
;
_has_bits_
[
0
]
=
0
;
}
explicit
MapEntryImpl
(
Arena
*
arena
)
:
arena_
(
arena
)
{
KeyTypeHandler
:
:
Initialize
(
&
key_
arena
)
;
ValueTypeHandler
:
:
InitializeMaybeByDefaultEnum
(
&
value_
default_enum_value
arena
)
;
_has_bits_
[
0
]
=
0
;
}
~
MapEntryImpl
(
)
{
if
(
GetArenaNoVirtual
(
)
!
=
NULL
)
return
;
KeyTypeHandler
:
:
DeleteNoArena
(
key_
)
;
ValueTypeHandler
:
:
DeleteNoArena
(
value_
)
;
}
virtual
inline
const
KeyMapEntryAccessorType
&
key
(
)
const
{
return
KeyTypeHandler
:
:
GetExternalReference
(
key_
)
;
}
virtual
inline
const
ValueMapEntryAccessorType
&
value
(
)
const
{
return
ValueTypeHandler
:
:
DefaultIfNotInitialized
(
value_
Derived
:
:
internal_default_instance
(
)
-
>
value_
)
;
}
inline
KeyMapEntryAccessorType
*
mutable_key
(
)
{
set_has_key
(
)
;
return
KeyTypeHandler
:
:
EnsureMutable
(
&
key_
GetArenaNoVirtual
(
)
)
;
}
inline
ValueMapEntryAccessorType
*
mutable_value
(
)
{
set_has_value
(
)
;
return
ValueTypeHandler
:
:
EnsureMutable
(
&
value_
GetArenaNoVirtual
(
)
)
;
}
std
:
:
string
GetTypeName
(
)
const
override
{
return
"
"
;
}
void
CheckTypeAndMergeFrom
(
const
MessageLite
&
other
)
override
{
MergeFromInternal
(
*
:
:
google
:
:
protobuf
:
:
internal
:
:
DownCast
<
const
Derived
*
>
(
&
other
)
)
;
}
const
char
*
_InternalParse
(
const
char
*
ptr
ParseContext
*
ctx
)
final
{
while
(
!
ctx
-
>
Done
(
&
ptr
)
)
{
uint32
tag
;
ptr
=
ReadTag
(
ptr
&
tag
)
;
GOOGLE_PROTOBUF_PARSER_ASSERT
(
ptr
)
;
if
(
tag
=
=
kKeyTag
)
{
set_has_key
(
)
;
KeyMapEntryAccessorType
*
key
=
mutable_key
(
)
;
ptr
=
KeyTypeHandler
:
:
Read
(
ptr
ctx
key
)
;
if
(
!
Derived
:
:
ValidateKey
(
key
)
)
return
nullptr
;
}
else
if
(
tag
=
=
kValueTag
)
{
set_has_value
(
)
;
ValueMapEntryAccessorType
*
value
=
mutable_value
(
)
;
ptr
=
ValueTypeHandler
:
:
Read
(
ptr
ctx
value
)
;
if
(
!
Derived
:
:
ValidateValue
(
value
)
)
return
nullptr
;
}
else
{
if
(
tag
=
=
0
|
|
WireFormatLite
:
:
GetTagWireType
(
tag
)
=
=
WireFormatLite
:
:
WIRETYPE_END_GROUP
)
{
ctx
-
>
SetLastTag
(
tag
)
;
return
ptr
;
}
ptr
=
UnknownFieldParse
(
tag
static_cast
<
std
:
:
string
*
>
(
nullptr
)
ptr
ctx
)
;
}
GOOGLE_PROTOBUF_PARSER_ASSERT
(
ptr
)
;
}
return
ptr
;
}
size_t
ByteSizeLong
(
)
const
override
{
size_t
size
=
0
;
size
+
=
has_key
(
)
?
kTagSize
+
static_cast
<
size_t
>
(
KeyTypeHandler
:
:
ByteSize
(
key
(
)
)
)
:
0
;
size
+
=
has_value
(
)
?
kTagSize
+
static_cast
<
size_t
>
(
ValueTypeHandler
:
:
ByteSize
(
value
(
)
)
)
:
0
;
return
size
;
}
:
:
google
:
:
protobuf
:
:
uint8
*
_InternalSerialize
(
:
:
google
:
:
protobuf
:
:
uint8
*
ptr
io
:
:
EpsCopyOutputStream
*
stream
)
const
override
{
ptr
=
KeyTypeHandler
:
:
Write
(
kKeyFieldNumber
key
(
)
ptr
stream
)
;
return
ValueTypeHandler
:
:
Write
(
kValueFieldNumber
value
(
)
ptr
stream
)
;
}
int
GetCachedSize
(
)
const
override
{
int
size
=
0
;
size
+
=
has_key
(
)
?
static_cast
<
int
>
(
kTagSize
)
+
KeyTypeHandler
:
:
GetCachedSize
(
key
(
)
)
:
0
;
size
+
=
has_value
(
)
?
static_cast
<
int
>
(
kTagSize
)
+
ValueTypeHandler
:
:
GetCachedSize
(
value
(
)
)
:
0
;
return
size
;
}
bool
IsInitialized
(
)
const
override
{
return
ValueTypeHandler
:
:
IsInitialized
(
value_
)
;
}
Base
*
New
(
)
const
override
{
Derived
*
entry
=
new
Derived
;
return
entry
;
}
Base
*
New
(
Arena
*
arena
)
const
override
{
Derived
*
entry
=
Arena
:
:
CreateMessage
<
Derived
>
(
arena
)
;
return
entry
;
}
protected
:
void
MergeFromInternal
(
const
MapEntryImpl
&
from
)
{
if
(
from
.
_has_bits_
[
0
]
)
{
if
(
from
.
has_key
(
)
)
{
KeyTypeHandler
:
:
EnsureMutable
(
&
key_
GetArenaNoVirtual
(
)
)
;
KeyTypeHandler
:
:
Merge
(
from
.
key
(
)
&
key_
GetArenaNoVirtual
(
)
)
;
set_has_key
(
)
;
}
if
(
from
.
has_value
(
)
)
{
ValueTypeHandler
:
:
EnsureMutable
(
&
value_
GetArenaNoVirtual
(
)
)
;
ValueTypeHandler
:
:
Merge
(
from
.
value
(
)
&
value_
GetArenaNoVirtual
(
)
)
;
set_has_value
(
)
;
}
}
}
public
:
void
Clear
(
)
override
{
KeyTypeHandler
:
:
Clear
(
&
key_
GetArenaNoVirtual
(
)
)
;
ValueTypeHandler
:
:
ClearMaybeByDefaultEnum
(
&
value_
GetArenaNoVirtual
(
)
default_enum_value
)
;
clear_has_key
(
)
;
clear_has_value
(
)
;
}
static
void
InitAsDefaultInstance
(
)
{
Derived
*
d
=
const_cast
<
Derived
*
>
(
Derived
:
:
internal_default_instance
(
)
)
;
KeyTypeHandler
:
:
AssignDefaultValue
(
&
d
-
>
key_
)
;
ValueTypeHandler
:
:
AssignDefaultValue
(
&
d
-
>
value_
)
;
}
Arena
*
GetArena
(
)
const
override
{
return
GetArenaNoVirtual
(
)
;
}
template
<
typename
MapField
typename
Map
>
class
Parser
{
public
:
explicit
Parser
(
MapField
*
mf
)
:
mf_
(
mf
)
map_
(
mf
-
>
MutableMap
(
)
)
{
}
~
Parser
(
)
{
if
(
entry_
!
=
nullptr
&
&
entry_
-
>
GetArena
(
)
=
=
nullptr
)
delete
entry_
;
}
bool
MergePartialFromCodedStream
(
io
:
:
CodedInputStream
*
input
)
{
if
(
input
-
>
ExpectTag
(
kKeyTag
)
)
{
if
(
!
KeyTypeHandler
:
:
Read
(
input
&
key_
)
)
{
return
false
;
}
const
void
*
data
;
int
size
;
input
-
>
GetDirectBufferPointerInline
(
&
data
&
size
)
;
static_assert
(
kTagSize
=
=
1
"
tag
size
must
be
1
"
)
;
if
(
size
>
0
&
&
*
reinterpret_cast
<
const
char
*
>
(
data
)
=
=
kValueTag
)
{
typename
Map
:
:
size_type
map_size
=
map_
-
>
size
(
)
;
value_ptr_
=
&
(
*
map_
)
[
key_
]
;
if
(
PROTOBUF_PREDICT_TRUE
(
map_size
!
=
map_
-
>
size
(
)
)
)
{
typedef
typename
MapIf
<
ValueTypeHandler
:
:
kIsEnum
int
*
Value
*
>
:
:
type
T
;
input
-
>
Skip
(
kTagSize
)
;
if
(
!
ValueTypeHandler
:
:
Read
(
input
reinterpret_cast
<
T
>
(
value_ptr_
)
)
)
{
map_
-
>
erase
(
key_
)
;
return
false
;
}
if
(
input
-
>
ExpectAtEnd
(
)
)
return
true
;
return
ReadBeyondKeyValuePair
(
input
)
;
}
}
}
else
{
key_
=
Key
(
)
;
}
NewEntry
(
)
;
*
entry_
-
>
mutable_key
(
)
=
key_
;
const
bool
result
=
entry_
-
>
MergePartialFromCodedStream
(
input
)
;
if
(
result
)
UseKeyAndValueFromEntry
(
)
;
return
result
;
}
const
char
*
_InternalParse
(
const
char
*
ptr
ParseContext
*
ctx
)
{
if
(
PROTOBUF_PREDICT_TRUE
(
!
ctx
-
>
Done
(
&
ptr
)
&
&
*
ptr
=
=
kKeyTag
)
)
{
ptr
=
KeyTypeHandler
:
:
Read
(
ptr
+
1
ctx
&
key_
)
;
if
(
PROTOBUF_PREDICT_FALSE
(
!
ptr
|
|
!
Derived
:
:
ValidateKey
(
&
key_
)
)
)
{
return
nullptr
;
}
if
(
PROTOBUF_PREDICT_TRUE
(
!
ctx
-
>
Done
(
&
ptr
)
&
&
*
ptr
=
=
kValueTag
)
)
{
typename
Map
:
:
size_type
map_size
=
map_
-
>
size
(
)
;
value_ptr_
=
&
(
*
map_
)
[
key_
]
;
if
(
PROTOBUF_PREDICT_TRUE
(
map_size
!
=
map_
-
>
size
(
)
)
)
{
using
T
=
typename
MapIf
<
ValueTypeHandler
:
:
kIsEnum
int
*
Value
*
>
:
:
type
;
ptr
=
ValueTypeHandler
:
:
Read
(
ptr
+
1
ctx
reinterpret_cast
<
T
>
(
value_ptr_
)
)
;
if
(
PROTOBUF_PREDICT_FALSE
(
!
ptr
|
|
!
Derived
:
:
ValidateValue
(
value_ptr_
)
)
)
{
map_
-
>
erase
(
key_
)
;
return
nullptr
;
}
if
(
PROTOBUF_PREDICT_TRUE
(
ctx
-
>
Done
(
&
ptr
)
)
)
return
ptr
;
if
(
!
ptr
)
return
nullptr
;
NewEntry
(
)
;
ValueMover
:
:
Move
(
value_ptr_
entry_
-
>
mutable_value
(
)
)
;
map_
-
>
erase
(
key_
)
;
goto
move_key
;
}
}
else
{
if
(
!
ptr
)
return
nullptr
;
}
NewEntry
(
)
;
move_key
:
KeyMover
:
:
Move
(
&
key_
entry_
-
>
mutable_key
(
)
)
;
}
else
{
if
(
!
ptr
)
return
nullptr
;
NewEntry
(
)
;
}
ptr
=
entry_
-
>
_InternalParse
(
ptr
ctx
)
;
if
(
ptr
)
UseKeyAndValueFromEntry
(
)
;
return
ptr
;
}
template
<
typename
Metadata
>
const
char
*
ParseWithEnumValidation
(
const
char
*
ptr
ParseContext
*
ctx
bool
(
*
is_valid
)
(
int
)
uint32
field_num
Metadata
*
metadata
)
{
auto
entry
=
NewEntry
(
)
;
ptr
=
entry
-
>
_InternalParse
(
ptr
ctx
)
;
if
(
!
ptr
)
return
nullptr
;
if
(
is_valid
(
entry
-
>
value
(
)
)
)
{
UseKeyAndValueFromEntry
(
)
;
}
else
{
WriteLengthDelimited
(
field_num
entry
-
>
SerializeAsString
(
)
metadata
-
>
mutable_unknown_fields
(
)
)
;
}
return
ptr
;
}
MapEntryImpl
*
NewEntry
(
)
{
return
entry_
=
mf_
-
>
NewEntry
(
)
;
}
const
Key
&
key
(
)
const
{
return
key_
;
}
const
Value
&
value
(
)
const
{
return
*
value_ptr_
;
}
const
Key
&
entry_key
(
)
const
{
return
entry_
-
>
key
(
)
;
}
const
Value
&
entry_value
(
)
const
{
return
entry_
-
>
value
(
)
;
}
private
:
void
UseKeyAndValueFromEntry
(
)
{
key_
=
entry_
-
>
key
(
)
;
value_ptr_
=
&
(
*
map_
)
[
key_
]
;
ValueMover
:
:
Move
(
entry_
-
>
mutable_value
(
)
value_ptr_
)
;
}
bool
ReadBeyondKeyValuePair
(
io
:
:
CodedInputStream
*
input
)
PROTOBUF_COLD
{
NewEntry
(
)
;
ValueMover
:
:
Move
(
value_ptr_
entry_
-
>
mutable_value
(
)
)
;
map_
-
>
erase
(
key_
)
;
KeyMover
:
:
Move
(
&
key_
entry_
-
>
mutable_key
(
)
)
;
const
bool
result
=
entry_
-
>
MergePartialFromCodedStream
(
input
)
;
if
(
result
)
UseKeyAndValueFromEntry
(
)
;
return
result
;
}
typedef
MoveHelper
<
KeyTypeHandler
:
:
kIsEnum
KeyTypeHandler
:
:
kIsMessage
KeyTypeHandler
:
:
kWireType
=
=
WireFormatLite
:
:
WIRETYPE_LENGTH_DELIMITED
Key
>
KeyMover
;
typedef
MoveHelper
<
ValueTypeHandler
:
:
kIsEnum
ValueTypeHandler
:
:
kIsMessage
ValueTypeHandler
:
:
kWireType
=
=
WireFormatLite
:
:
WIRETYPE_LENGTH_DELIMITED
Value
>
ValueMover
;
MapField
*
const
mf_
;
Map
*
const
map_
;
Key
key_
;
Value
*
value_ptr_
;
MapEntryImpl
*
entry_
=
nullptr
;
}
;
protected
:
void
set_has_key
(
)
{
_has_bits_
[
0
]
|
=
0x00000001u
;
}
bool
has_key
(
)
const
{
return
(
_has_bits_
[
0
]
&
0x00000001u
)
!
=
0
;
}
void
clear_has_key
(
)
{
_has_bits_
[
0
]
&
=
~
0x00000001u
;
}
void
set_has_value
(
)
{
_has_bits_
[
0
]
|
=
0x00000002u
;
}
bool
has_value
(
)
const
{
return
(
_has_bits_
[
0
]
&
0x00000002u
)
!
=
0
;
}
void
clear_has_value
(
)
{
_has_bits_
[
0
]
&
=
~
0x00000002u
;
}
public
:
inline
Arena
*
GetArenaNoVirtual
(
)
const
{
return
arena_
;
}
public
:
KeyOnMemory
key_
;
ValueOnMemory
value_
;
Arena
*
arena_
;
uint32
_has_bits_
[
1
]
;
private
:
friend
class
:
:
PROTOBUF_NAMESPACE_ID
:
:
Arena
;
typedef
void
InternalArenaConstructable_
;
typedef
void
DestructorSkippable_
;
template
<
typename
C
typename
K
typename
V
WireFormatLite
:
:
FieldType
WireFormatLite
:
:
FieldType
int
>
friend
class
internal
:
:
MapEntry
;
template
<
typename
C
typename
K
typename
V
WireFormatLite
:
:
FieldType
WireFormatLite
:
:
FieldType
int
>
friend
class
internal
:
:
MapFieldLite
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
MapEntryImpl
)
;
}
;
template
<
typename
T
typename
Key
typename
Value
WireFormatLite
:
:
FieldType
kKeyFieldType
WireFormatLite
:
:
FieldType
kValueFieldType
int
default_enum_value
>
class
MapEntryLite
:
public
MapEntryImpl
<
T
MessageLite
Key
Value
kKeyFieldType
kValueFieldType
default_enum_value
>
{
public
:
typedef
MapEntryImpl
<
T
MessageLite
Key
Value
kKeyFieldType
kValueFieldType
default_enum_value
>
SuperType
;
MapEntryLite
(
)
{
}
explicit
MapEntryLite
(
Arena
*
arena
)
:
SuperType
(
arena
)
{
}
void
MergeFrom
(
const
MapEntryLite
&
other
)
{
MergeFromInternal
(
other
)
;
}
private
:
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
MapEntryLite
)
;
}
;
template
<
typename
Derived
>
struct
DeconstructMapEntry
;
template
<
typename
T
typename
K
typename
V
WireFormatLite
:
:
FieldType
key
WireFormatLite
:
:
FieldType
value
int
default_enum
>
struct
DeconstructMapEntry
<
MapEntryLite
<
T
K
V
key
value
default_enum
>
>
{
typedef
K
Key
;
typedef
V
Value
;
static
const
WireFormatLite
:
:
FieldType
kKeyFieldType
=
key
;
static
const
WireFormatLite
:
:
FieldType
kValueFieldType
=
value
;
static
const
int
default_enum_value
=
default_enum
;
}
;
template
<
typename
Key
typename
PtrToKeyValuePair
>
struct
SortItem
{
SortItem
(
)
{
}
explicit
SortItem
(
PtrToKeyValuePair
p
)
:
first
(
p
-
>
first
)
second
(
p
)
{
}
Key
first
;
PtrToKeyValuePair
second
;
}
;
template
<
typename
T
>
struct
CompareByFirstField
{
bool
operator
(
)
(
const
T
&
a
const
T
&
b
)
const
{
return
a
.
first
<
b
.
first
;
}
}
;
template
<
typename
T
>
struct
CompareByDerefFirst
{
bool
operator
(
)
(
const
T
&
a
const
T
&
b
)
const
{
return
a
-
>
first
<
b
-
>
first
;
}
}
;
template
<
WireFormatLite
:
:
FieldType
FieldType
>
struct
FromHelper
{
template
<
typename
T
>
static
const
T
&
From
(
const
T
&
x
)
{
return
x
;
}
}
;
template
<
>
struct
FromHelper
<
WireFormatLite
:
:
TYPE_STRING
>
{
static
ArenaStringPtr
From
(
const
std
:
:
string
&
x
)
{
ArenaStringPtr
res
;
TaggedPtr
<
std
:
:
string
>
ptr
;
ptr
.
Set
(
const_cast
<
std
:
:
string
*
>
(
&
x
)
)
;
res
.
UnsafeSetTaggedPointer
(
ptr
)
;
return
res
;
}
}
;
template
<
>
struct
FromHelper
<
WireFormatLite
:
:
TYPE_BYTES
>
{
static
ArenaStringPtr
From
(
const
std
:
:
string
&
x
)
{
ArenaStringPtr
res
;
TaggedPtr
<
std
:
:
string
>
ptr
;
ptr
.
Set
(
const_cast
<
std
:
:
string
*
>
(
&
x
)
)
;
res
.
UnsafeSetTaggedPointer
(
ptr
)
;
return
res
;
}
}
;
template
<
>
struct
FromHelper
<
WireFormatLite
:
:
TYPE_MESSAGE
>
{
template
<
typename
T
>
static
T
*
From
(
const
T
&
x
)
{
return
const_cast
<
T
*
>
(
&
x
)
;
}
}
;
template
<
typename
MapEntryType
>
struct
MapEntryHelper
;
template
<
typename
T
typename
Key
typename
Value
WireFormatLite
:
:
FieldType
kKeyFieldType
WireFormatLite
:
:
FieldType
kValueFieldType
int
default_enum_value
>
struct
MapEntryHelper
<
MapEntryLite
<
T
Key
Value
kKeyFieldType
kValueFieldType
default_enum_value
>
>
{
typedef
MapTypeHandler
<
kKeyFieldType
Key
>
KeyTypeHandler
;
typedef
MapTypeHandler
<
kValueFieldType
Value
>
ValueTypeHandler
;
typedef
typename
KeyTypeHandler
:
:
TypeOnMemory
KeyOnMemory
;
typedef
typename
ValueTypeHandler
:
:
TypeOnMemory
ValueOnMemory
;
explicit
MapEntryHelper
(
const
MapPair
<
Key
Value
>
&
map_pair
)
:
_has_bits_
(
3
)
_cached_size_
(
2
+
KeyTypeHandler
:
:
GetCachedSize
(
map_pair
.
first
)
+
ValueTypeHandler
:
:
GetCachedSize
(
map_pair
.
second
)
)
key_
(
FromHelper
<
kKeyFieldType
>
:
:
From
(
map_pair
.
first
)
)
value_
(
FromHelper
<
kValueFieldType
>
:
:
From
(
map_pair
.
second
)
)
{
}
uint32
_has_bits_
;
uint32
_cached_size_
;
KeyOnMemory
key_
;
ValueOnMemory
value_
;
}
;
}
}
}
#
include
<
google
/
protobuf
/
port_undef
.
inc
>
#
endif
