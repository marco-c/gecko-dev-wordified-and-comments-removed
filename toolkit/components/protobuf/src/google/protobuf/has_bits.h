#
ifndef
GOOGLE_PROTOBUF_HAS_BITS_H__
#
define
GOOGLE_PROTOBUF_HAS_BITS_H__
#
include
<
google
/
protobuf
/
stubs
/
common
.
h
>
namespace
google
{
namespace
protobuf
{
namespace
internal
{
template
<
size_t
doublewords
>
class
HasBits
{
public
:
HasBits
(
)
GOOGLE_ATTRIBUTE_ALWAYS_INLINE
{
Clear
(
)
;
}
void
Clear
(
)
GOOGLE_ATTRIBUTE_ALWAYS_INLINE
{
memset
(
has_bits_
0
sizeof
(
has_bits_
)
)
;
}
:
:
google
:
:
protobuf
:
:
uint32
&
operator
[
]
(
int
index
)
GOOGLE_ATTRIBUTE_ALWAYS_INLINE
{
return
has_bits_
[
index
]
;
}
const
:
:
google
:
:
protobuf
:
:
uint32
&
operator
[
]
(
int
index
)
const
GOOGLE_ATTRIBUTE_ALWAYS_INLINE
{
return
has_bits_
[
index
]
;
}
bool
operator
=
=
(
const
HasBits
<
doublewords
>
&
rhs
)
const
{
return
memcmp
(
has_bits_
rhs
.
has_bits_
sizeof
(
has_bits_
)
)
=
=
0
;
}
bool
operator
!
=
(
const
HasBits
<
doublewords
>
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
empty
(
)
const
;
private
:
:
:
google
:
:
protobuf
:
:
uint32
has_bits_
[
doublewords
]
;
}
;
template
<
>
inline
bool
HasBits
<
1
>
:
:
empty
(
)
const
{
return
!
has_bits_
[
0
]
;
}
template
<
>
inline
bool
HasBits
<
2
>
:
:
empty
(
)
const
{
return
!
(
has_bits_
[
0
]
|
has_bits_
[
1
]
)
;
}
template
<
>
inline
bool
HasBits
<
3
>
:
:
empty
(
)
const
{
return
!
(
has_bits_
[
0
]
|
has_bits_
[
1
]
|
has_bits_
[
2
]
)
;
}
template
<
>
inline
bool
HasBits
<
4
>
:
:
empty
(
)
const
{
return
!
(
has_bits_
[
0
]
|
has_bits_
[
1
]
|
has_bits_
[
2
]
|
has_bits_
[
3
]
)
;
}
template
<
size_t
doublewords
>
inline
bool
HasBits
<
doublewords
>
:
:
empty
(
)
const
{
for
(
size_t
i
=
0
;
i
<
doublewords
;
+
+
i
)
{
if
(
has_bits_
[
i
]
)
return
false
;
}
return
true
;
}
}
}
}
#
endif
