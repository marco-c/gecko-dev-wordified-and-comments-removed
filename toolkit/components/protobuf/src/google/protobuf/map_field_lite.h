#
ifndef
GOOGLE_PROTOBUF_MAP_FIELD_LITE_H__
#
define
GOOGLE_PROTOBUF_MAP_FIELD_LITE_H__
#
include
<
google
/
protobuf
/
map
.
h
>
#
include
<
google
/
protobuf
/
map_entry_lite
.
h
>
#
include
<
google
/
protobuf
/
wire_format_lite
.
h
>
namespace
google
{
namespace
protobuf
{
namespace
internal
{
template
<
typename
Derived
typename
Key
typename
T
WireFormatLite
:
:
FieldType
key_wire_type
WireFormatLite
:
:
FieldType
value_wire_type
int
default_enum_value
=
0
>
class
MapFieldLite
{
typedef
Derived
EntryType
;
public
:
typedef
Map
<
Key
T
>
MapType
;
typedef
EntryType
EntryTypeTrait
;
MapFieldLite
(
)
:
arena_
(
NULL
)
{
SetDefaultEnumValue
(
)
;
}
explicit
MapFieldLite
(
Arena
*
arena
)
:
arena_
(
arena
)
map_
(
arena
)
{
SetDefaultEnumValue
(
)
;
}
const
Map
<
Key
T
>
&
GetMap
(
)
const
{
return
map_
;
}
Map
<
Key
T
>
*
MutableMap
(
)
{
return
&
map_
;
}
int
size
(
)
const
{
return
static_cast
<
int
>
(
map_
.
size
(
)
)
;
}
void
Clear
(
)
{
return
map_
.
clear
(
)
;
}
void
MergeFrom
(
const
MapFieldLite
&
other
)
{
for
(
typename
Map
<
Key
T
>
:
:
const_iterator
it
=
other
.
map_
.
begin
(
)
;
it
!
=
other
.
map_
.
end
(
)
;
+
+
it
)
{
map_
[
it
-
>
first
]
=
it
-
>
second
;
}
}
void
Swap
(
MapFieldLite
*
other
)
{
map_
.
swap
(
other
-
>
map_
)
;
}
void
SetDefaultEnumValue
(
)
{
MutableMap
(
)
-
>
SetDefaultEnumValue
(
default_enum_value
)
;
}
EntryType
*
NewEntry
(
)
const
{
if
(
arena_
=
=
NULL
)
{
return
new
EntryType
(
)
;
}
else
{
return
Arena
:
:
CreateMessage
<
EntryType
>
(
arena_
)
;
}
}
EntryType
*
NewEnumEntryWrapper
(
const
Key
&
key
const
T
t
)
const
{
return
EntryType
:
:
EnumWrap
(
key
t
arena_
)
;
}
EntryType
*
NewEntryWrapper
(
const
Key
&
key
const
T
&
t
)
const
{
return
EntryType
:
:
Wrap
(
key
t
arena_
)
;
}
private
:
typedef
void
DestructorSkippable_
;
Arena
*
arena_
;
Map
<
Key
T
>
map_
;
friend
class
:
:
google
:
:
protobuf
:
:
Arena
;
}
;
template
<
typename
Key
typename
T
>
bool
AllAreInitialized
(
const
Map
<
Key
T
>
&
t
)
{
for
(
typename
Map
<
Key
T
>
:
:
const_iterator
it
=
t
.
begin
(
)
;
it
!
=
t
.
end
(
)
;
+
+
it
)
{
if
(
!
it
-
>
second
.
IsInitialized
(
)
)
return
false
;
}
return
true
;
}
}
}
}
#
endif
