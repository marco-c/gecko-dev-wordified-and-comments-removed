#
include
<
google
/
protobuf
/
arena
.
h
>
#
include
<
algorithm
>
#
include
<
atomic
>
#
include
<
limits
>
#
include
<
google
/
protobuf
/
stubs
/
mutex
.
h
>
#
ifdef
ADDRESS_SANITIZER
#
include
<
sanitizer
/
asan_interface
.
h
>
#
endif
#
include
<
google
/
protobuf
/
port_def
.
inc
>
static
const
size_t
kMinCleanupListElements
=
8
;
static
const
size_t
kMaxCleanupListElements
=
64
;
namespace
google
{
namespace
protobuf
{
namespace
internal
{
std
:
:
atomic
<
LifecycleId
>
ArenaImpl
:
:
lifecycle_id_generator_
;
#
if
defined
(
GOOGLE_PROTOBUF_NO_THREADLOCAL
)
ArenaImpl
:
:
ThreadCache
&
ArenaImpl
:
:
thread_cache
(
)
{
static
internal
:
:
ThreadLocalStorage
<
ThreadCache
>
*
thread_cache_
=
new
internal
:
:
ThreadLocalStorage
<
ThreadCache
>
(
)
;
return
*
thread_cache_
-
>
Get
(
)
;
}
#
elif
defined
(
PROTOBUF_USE_DLLS
)
ArenaImpl
:
:
ThreadCache
&
ArenaImpl
:
:
thread_cache
(
)
{
static
GOOGLE_THREAD_LOCAL
ThreadCache
thread_cache_
=
{
-
1
NULL
}
;
return
thread_cache_
;
}
#
else
GOOGLE_THREAD_LOCAL
ArenaImpl
:
:
ThreadCache
ArenaImpl
:
:
thread_cache_
=
{
-
1
NULL
}
;
#
endif
void
ArenaImpl
:
:
Init
(
)
{
lifecycle_id_
=
lifecycle_id_generator_
.
fetch_add
(
1
std
:
:
memory_order_relaxed
)
;
hint_
.
store
(
nullptr
std
:
:
memory_order_relaxed
)
;
threads_
.
store
(
nullptr
std
:
:
memory_order_relaxed
)
;
if
(
initial_block_
)
{
new
(
initial_block_
)
Block
(
options_
.
initial_block_size
NULL
)
;
SerialArena
*
serial
=
SerialArena
:
:
New
(
initial_block_
&
thread_cache
(
)
this
)
;
serial
-
>
set_next
(
NULL
)
;
threads_
.
store
(
serial
std
:
:
memory_order_relaxed
)
;
space_allocated_
.
store
(
options_
.
initial_block_size
std
:
:
memory_order_relaxed
)
;
CacheSerialArena
(
serial
)
;
}
else
{
space_allocated_
.
store
(
0
std
:
:
memory_order_relaxed
)
;
}
}
ArenaImpl
:
:
~
ArenaImpl
(
)
{
CleanupList
(
)
;
FreeBlocks
(
)
;
}
uint64
ArenaImpl
:
:
Reset
(
)
{
CleanupList
(
)
;
uint64
space_allocated
=
FreeBlocks
(
)
;
Init
(
)
;
return
space_allocated
;
}
ArenaImpl
:
:
Block
*
ArenaImpl
:
:
NewBlock
(
Block
*
last_block
size_t
min_bytes
)
{
size_t
size
;
if
(
last_block
)
{
size
=
std
:
:
min
(
2
*
last_block
-
>
size
(
)
options_
.
max_block_size
)
;
}
else
{
size
=
options_
.
start_block_size
;
}
GOOGLE_CHECK_LE
(
min_bytes
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
-
kBlockHeaderSize
)
;
size
=
std
:
:
max
(
size
kBlockHeaderSize
+
min_bytes
)
;
void
*
mem
=
options_
.
block_alloc
(
size
)
;
Block
*
b
=
new
(
mem
)
Block
(
size
last_block
)
;
space_allocated_
.
fetch_add
(
size
std
:
:
memory_order_relaxed
)
;
return
b
;
}
ArenaImpl
:
:
Block
:
:
Block
(
size_t
size
Block
*
next
)
:
next_
(
next
)
pos_
(
kBlockHeaderSize
)
size_
(
size
)
{
}
PROTOBUF_NOINLINE
void
ArenaImpl
:
:
SerialArena
:
:
AddCleanupFallback
(
void
*
elem
void
(
*
cleanup
)
(
void
*
)
)
{
size_t
size
=
cleanup_
?
cleanup_
-
>
size
*
2
:
kMinCleanupListElements
;
size
=
std
:
:
min
(
size
kMaxCleanupListElements
)
;
size_t
bytes
=
internal
:
:
AlignUpTo8
(
CleanupChunk
:
:
SizeOf
(
size
)
)
;
CleanupChunk
*
list
=
reinterpret_cast
<
CleanupChunk
*
>
(
AllocateAligned
(
bytes
)
)
;
list
-
>
next
=
cleanup_
;
list
-
>
size
=
size
;
cleanup_
=
list
;
cleanup_ptr_
=
&
list
-
>
nodes
[
0
]
;
cleanup_limit_
=
&
list
-
>
nodes
[
size
]
;
AddCleanup
(
elem
cleanup
)
;
}
void
*
ArenaImpl
:
:
AllocateAlignedAndAddCleanup
(
size_t
n
void
(
*
cleanup
)
(
void
*
)
)
{
SerialArena
*
arena
;
if
(
PROTOBUF_PREDICT_TRUE
(
GetSerialArenaFast
(
&
arena
)
)
)
{
return
arena
-
>
AllocateAlignedAndAddCleanup
(
n
cleanup
)
;
}
else
{
return
AllocateAlignedAndAddCleanupFallback
(
n
cleanup
)
;
}
}
void
ArenaImpl
:
:
AddCleanup
(
void
*
elem
void
(
*
cleanup
)
(
void
*
)
)
{
SerialArena
*
arena
;
if
(
PROTOBUF_PREDICT_TRUE
(
GetSerialArenaFast
(
&
arena
)
)
)
{
arena
-
>
AddCleanup
(
elem
cleanup
)
;
}
else
{
return
AddCleanupFallback
(
elem
cleanup
)
;
}
}
PROTOBUF_NOINLINE
void
*
ArenaImpl
:
:
AllocateAlignedFallback
(
size_t
n
)
{
return
GetSerialArena
(
)
-
>
AllocateAligned
(
n
)
;
}
PROTOBUF_NOINLINE
void
*
ArenaImpl
:
:
AllocateAlignedAndAddCleanupFallback
(
size_t
n
void
(
*
cleanup
)
(
void
*
)
)
{
return
GetSerialArena
(
)
-
>
AllocateAlignedAndAddCleanup
(
n
cleanup
)
;
}
PROTOBUF_NOINLINE
void
ArenaImpl
:
:
AddCleanupFallback
(
void
*
elem
void
(
*
cleanup
)
(
void
*
)
)
{
GetSerialArena
(
)
-
>
AddCleanup
(
elem
cleanup
)
;
}
ArenaImpl
:
:
SerialArena
*
ArenaImpl
:
:
GetSerialArena
(
)
{
SerialArena
*
arena
;
if
(
PROTOBUF_PREDICT_TRUE
(
GetSerialArenaFast
(
&
arena
)
)
)
{
return
arena
;
}
else
{
return
GetSerialArenaFallback
(
&
thread_cache
(
)
)
;
}
}
PROTOBUF_NOINLINE
void
*
ArenaImpl
:
:
SerialArena
:
:
AllocateAlignedFallback
(
size_t
n
)
{
head_
-
>
set_pos
(
head_
-
>
size
(
)
-
(
limit_
-
ptr_
)
)
;
head_
=
arena_
-
>
NewBlock
(
head_
n
)
;
ptr_
=
head_
-
>
Pointer
(
head_
-
>
pos
(
)
)
;
limit_
=
head_
-
>
Pointer
(
head_
-
>
size
(
)
)
;
#
ifdef
ADDRESS_SANITIZER
ASAN_POISON_MEMORY_REGION
(
ptr_
limit_
-
ptr_
)
;
#
endif
return
AllocateAligned
(
n
)
;
}
uint64
ArenaImpl
:
:
SpaceAllocated
(
)
const
{
return
space_allocated_
.
load
(
std
:
:
memory_order_relaxed
)
;
}
uint64
ArenaImpl
:
:
SpaceUsed
(
)
const
{
SerialArena
*
serial
=
threads_
.
load
(
std
:
:
memory_order_acquire
)
;
uint64
space_used
=
0
;
for
(
;
serial
;
serial
=
serial
-
>
next
(
)
)
{
space_used
+
=
serial
-
>
SpaceUsed
(
)
;
}
return
space_used
;
}
uint64
ArenaImpl
:
:
SerialArena
:
:
SpaceUsed
(
)
const
{
uint64
space_used
=
ptr_
-
head_
-
>
Pointer
(
kBlockHeaderSize
)
;
for
(
Block
*
b
=
head_
-
>
next
(
)
;
b
;
b
=
b
-
>
next
(
)
)
{
space_used
+
=
(
b
-
>
pos
(
)
-
kBlockHeaderSize
)
;
}
space_used
-
=
kSerialArenaSize
;
return
space_used
;
}
uint64
ArenaImpl
:
:
FreeBlocks
(
)
{
uint64
space_allocated
=
0
;
SerialArena
*
serial
=
threads_
.
load
(
std
:
:
memory_order_relaxed
)
;
while
(
serial
)
{
SerialArena
*
next
=
serial
-
>
next
(
)
;
space_allocated
+
=
ArenaImpl
:
:
SerialArena
:
:
Free
(
serial
initial_block_
options_
.
block_dealloc
)
;
serial
=
next
;
}
return
space_allocated
;
}
uint64
ArenaImpl
:
:
SerialArena
:
:
Free
(
ArenaImpl
:
:
SerialArena
*
serial
Block
*
initial_block
void
(
*
block_dealloc
)
(
void
*
size_t
)
)
{
uint64
space_allocated
=
0
;
for
(
Block
*
b
=
serial
-
>
head_
;
b
;
)
{
Block
*
next_block
=
b
-
>
next
(
)
;
space_allocated
+
=
(
b
-
>
size
(
)
)
;
#
ifdef
ADDRESS_SANITIZER
ASAN_UNPOISON_MEMORY_REGION
(
b
-
>
Pointer
(
0
)
b
-
>
size
(
)
)
;
#
endif
if
(
b
!
=
initial_block
)
{
block_dealloc
(
b
b
-
>
size
(
)
)
;
}
b
=
next_block
;
}
return
space_allocated
;
}
void
ArenaImpl
:
:
CleanupList
(
)
{
SerialArena
*
serial
=
threads_
.
load
(
std
:
:
memory_order_relaxed
)
;
for
(
;
serial
;
serial
=
serial
-
>
next
(
)
)
{
serial
-
>
CleanupList
(
)
;
}
}
void
ArenaImpl
:
:
SerialArena
:
:
CleanupList
(
)
{
if
(
cleanup_
!
=
NULL
)
{
CleanupListFallback
(
)
;
}
}
void
ArenaImpl
:
:
SerialArena
:
:
CleanupListFallback
(
)
{
size_t
n
=
cleanup_ptr_
-
&
cleanup_
-
>
nodes
[
0
]
;
CleanupChunk
*
list
=
cleanup_
;
while
(
true
)
{
CleanupNode
*
node
=
&
list
-
>
nodes
[
0
]
;
for
(
size_t
i
=
n
;
i
>
0
;
i
-
-
)
{
node
[
i
-
1
]
.
cleanup
(
node
[
i
-
1
]
.
elem
)
;
}
list
=
list
-
>
next
;
if
(
list
=
=
nullptr
)
{
break
;
}
n
=
list
-
>
size
;
}
}
ArenaImpl
:
:
SerialArena
*
ArenaImpl
:
:
SerialArena
:
:
New
(
Block
*
b
void
*
owner
ArenaImpl
*
arena
)
{
GOOGLE_DCHECK_EQ
(
b
-
>
pos
(
)
kBlockHeaderSize
)
;
GOOGLE_DCHECK_LE
(
kBlockHeaderSize
+
kSerialArenaSize
b
-
>
size
(
)
)
;
SerialArena
*
serial
=
reinterpret_cast
<
SerialArena
*
>
(
b
-
>
Pointer
(
kBlockHeaderSize
)
)
;
b
-
>
set_pos
(
kBlockHeaderSize
+
kSerialArenaSize
)
;
serial
-
>
arena_
=
arena
;
serial
-
>
owner_
=
owner
;
serial
-
>
head_
=
b
;
serial
-
>
ptr_
=
b
-
>
Pointer
(
b
-
>
pos
(
)
)
;
serial
-
>
limit_
=
b
-
>
Pointer
(
b
-
>
size
(
)
)
;
serial
-
>
cleanup_
=
NULL
;
serial
-
>
cleanup_ptr_
=
NULL
;
serial
-
>
cleanup_limit_
=
NULL
;
return
serial
;
}
PROTOBUF_NOINLINE
ArenaImpl
:
:
SerialArena
*
ArenaImpl
:
:
GetSerialArenaFallback
(
void
*
me
)
{
SerialArena
*
serial
=
threads_
.
load
(
std
:
:
memory_order_acquire
)
;
for
(
;
serial
;
serial
=
serial
-
>
next
(
)
)
{
if
(
serial
-
>
owner
(
)
=
=
me
)
{
break
;
}
}
if
(
!
serial
)
{
Block
*
b
=
NewBlock
(
NULL
kSerialArenaSize
)
;
serial
=
SerialArena
:
:
New
(
b
me
this
)
;
SerialArena
*
head
=
threads_
.
load
(
std
:
:
memory_order_relaxed
)
;
do
{
serial
-
>
set_next
(
head
)
;
}
while
(
!
threads_
.
compare_exchange_weak
(
head
serial
std
:
:
memory_order_release
std
:
:
memory_order_relaxed
)
)
;
}
CacheSerialArena
(
serial
)
;
return
serial
;
}
}
PROTOBUF_FUNC_ALIGN
(
32
)
void
*
Arena
:
:
AllocateAlignedNoHook
(
size_t
n
)
{
return
impl_
.
AllocateAligned
(
n
)
;
}
void
Arena
:
:
CallDestructorHooks
(
)
{
uint64
space_allocated
=
impl_
.
SpaceAllocated
(
)
;
if
(
on_arena_reset_
!
=
NULL
)
{
on_arena_reset_
(
this
hooks_cookie_
space_allocated
)
;
}
if
(
on_arena_destruction_
!
=
NULL
)
{
on_arena_destruction_
(
this
hooks_cookie_
space_allocated
)
;
}
}
void
Arena
:
:
OnArenaAllocation
(
const
std
:
:
type_info
*
allocated_type
size_t
n
)
const
{
if
(
on_arena_allocation_
!
=
NULL
)
{
on_arena_allocation_
(
allocated_type
n
hooks_cookie_
)
;
}
}
}
}
