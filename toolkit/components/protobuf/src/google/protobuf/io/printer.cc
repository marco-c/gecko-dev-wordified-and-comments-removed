#
include
<
google
/
protobuf
/
io
/
printer
.
h
>
#
include
<
cctype
>
#
include
<
google
/
protobuf
/
stubs
/
logging
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
common
.
h
>
#
include
<
google
/
protobuf
/
io
/
zero_copy_stream
.
h
>
namespace
google
{
namespace
protobuf
{
namespace
io
{
Printer
:
:
Printer
(
ZeroCopyOutputStream
*
output
char
variable_delimiter
)
:
variable_delimiter_
(
variable_delimiter
)
output_
(
output
)
buffer_
(
NULL
)
buffer_size_
(
0
)
offset_
(
0
)
at_start_of_line_
(
true
)
failed_
(
false
)
annotation_collector_
(
NULL
)
{
}
Printer
:
:
Printer
(
ZeroCopyOutputStream
*
output
char
variable_delimiter
AnnotationCollector
*
annotation_collector
)
:
variable_delimiter_
(
variable_delimiter
)
output_
(
output
)
buffer_
(
NULL
)
buffer_size_
(
0
)
offset_
(
0
)
at_start_of_line_
(
true
)
failed_
(
false
)
annotation_collector_
(
annotation_collector
)
{
}
Printer
:
:
~
Printer
(
)
{
if
(
buffer_
!
=
nullptr
&
&
!
failed_
)
{
output_
-
>
BackUp
(
buffer_size_
)
;
}
}
bool
Printer
:
:
GetSubstitutionRange
(
const
char
*
varname
std
:
:
pair
<
size_t
size_t
>
*
range
)
{
std
:
:
map
<
std
:
:
string
std
:
:
pair
<
size_t
size_t
>
>
:
:
const_iterator
iter
=
substitutions_
.
find
(
varname
)
;
if
(
iter
=
=
substitutions_
.
end
(
)
)
{
GOOGLE_LOG
(
DFATAL
)
<
<
"
Undefined
variable
in
annotation
:
"
<
<
varname
;
return
false
;
}
if
(
iter
-
>
second
.
first
>
iter
-
>
second
.
second
)
{
GOOGLE_LOG
(
DFATAL
)
<
<
"
Variable
used
for
annotation
used
multiple
times
:
"
<
<
varname
;
return
false
;
}
*
range
=
iter
-
>
second
;
return
true
;
}
void
Printer
:
:
Annotate
(
const
char
*
begin_varname
const
char
*
end_varname
const
std
:
:
string
&
file_path
const
std
:
:
vector
<
int
>
&
path
)
{
if
(
annotation_collector_
=
=
NULL
)
{
return
;
}
std
:
:
pair
<
size_t
size_t
>
begin
end
;
if
(
!
GetSubstitutionRange
(
begin_varname
&
begin
)
|
|
!
GetSubstitutionRange
(
end_varname
&
end
)
)
{
return
;
}
if
(
begin
.
first
>
end
.
second
)
{
GOOGLE_LOG
(
DFATAL
)
<
<
"
Annotation
has
negative
length
from
"
<
<
begin_varname
<
<
"
to
"
<
<
end_varname
;
}
else
{
annotation_collector_
-
>
AddAnnotation
(
begin
.
first
end
.
second
file_path
path
)
;
}
}
void
Printer
:
:
Print
(
const
std
:
:
map
<
std
:
:
string
std
:
:
string
>
&
variables
const
char
*
text
)
{
int
size
=
strlen
(
text
)
;
int
pos
=
0
;
substitutions_
.
clear
(
)
;
line_start_variables_
.
clear
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
+
+
)
{
if
(
text
[
i
]
=
=
'
\
n
'
)
{
WriteRaw
(
text
+
pos
i
-
pos
+
1
)
;
pos
=
i
+
1
;
at_start_of_line_
=
true
;
line_start_variables_
.
clear
(
)
;
}
else
if
(
text
[
i
]
=
=
variable_delimiter_
)
{
WriteRaw
(
text
+
pos
i
-
pos
)
;
pos
=
i
+
1
;
const
char
*
end
=
strchr
(
text
+
pos
variable_delimiter_
)
;
if
(
end
=
=
NULL
)
{
GOOGLE_LOG
(
DFATAL
)
<
<
"
Unclosed
variable
name
.
"
;
end
=
text
+
pos
;
}
int
endpos
=
end
-
text
;
std
:
:
string
varname
(
text
+
pos
endpos
-
pos
)
;
if
(
varname
.
empty
(
)
)
{
WriteRaw
(
&
variable_delimiter_
1
)
;
}
else
{
std
:
:
map
<
std
:
:
string
std
:
:
string
>
:
:
const_iterator
iter
=
variables
.
find
(
varname
)
;
if
(
iter
=
=
variables
.
end
(
)
)
{
GOOGLE_LOG
(
DFATAL
)
<
<
"
Undefined
variable
:
"
<
<
varname
;
}
else
{
if
(
at_start_of_line_
&
&
iter
-
>
second
.
empty
(
)
)
{
line_start_variables_
.
push_back
(
varname
)
;
}
WriteRaw
(
iter
-
>
second
.
data
(
)
iter
-
>
second
.
size
(
)
)
;
std
:
:
pair
<
std
:
:
map
<
std
:
:
string
std
:
:
pair
<
size_t
size_t
>
>
:
:
iterator
bool
>
inserted
=
substitutions_
.
insert
(
std
:
:
make_pair
(
varname
std
:
:
make_pair
(
offset_
-
iter
-
>
second
.
size
(
)
offset_
)
)
)
;
if
(
!
inserted
.
second
)
{
inserted
.
first
-
>
second
=
std
:
:
make_pair
(
1
0
)
;
}
}
}
i
=
endpos
;
pos
=
endpos
+
1
;
}
}
WriteRaw
(
text
+
pos
size
-
pos
)
;
}
void
Printer
:
:
Indent
(
)
{
indent_
+
=
"
"
;
}
void
Printer
:
:
Outdent
(
)
{
if
(
indent_
.
empty
(
)
)
{
GOOGLE_LOG
(
DFATAL
)
<
<
"
Outdent
(
)
without
matching
Indent
(
)
.
"
;
return
;
}
indent_
.
resize
(
indent_
.
size
(
)
-
2
)
;
}
void
Printer
:
:
PrintRaw
(
const
std
:
:
string
&
data
)
{
WriteRaw
(
data
.
data
(
)
data
.
size
(
)
)
;
}
void
Printer
:
:
PrintRaw
(
const
char
*
data
)
{
if
(
failed_
)
return
;
WriteRaw
(
data
strlen
(
data
)
)
;
}
void
Printer
:
:
WriteRaw
(
const
char
*
data
int
size
)
{
if
(
failed_
)
return
;
if
(
size
=
=
0
)
return
;
if
(
at_start_of_line_
&
&
(
size
>
0
)
&
&
(
data
[
0
]
!
=
'
\
n
'
)
)
{
at_start_of_line_
=
false
;
CopyToBuffer
(
indent_
.
data
(
)
indent_
.
size
(
)
)
;
if
(
failed_
)
return
;
for
(
std
:
:
vector
<
std
:
:
string
>
:
:
iterator
i
=
line_start_variables_
.
begin
(
)
;
i
!
=
line_start_variables_
.
end
(
)
;
+
+
i
)
{
substitutions_
[
*
i
]
.
first
+
=
indent_
.
size
(
)
;
substitutions_
[
*
i
]
.
second
+
=
indent_
.
size
(
)
;
}
}
line_start_variables_
.
clear
(
)
;
CopyToBuffer
(
data
size
)
;
}
bool
Printer
:
:
Next
(
)
{
do
{
void
*
void_buffer
;
if
(
!
output_
-
>
Next
(
&
void_buffer
&
buffer_size_
)
)
{
failed_
=
true
;
return
false
;
}
buffer_
=
reinterpret_cast
<
char
*
>
(
void_buffer
)
;
}
while
(
buffer_size_
=
=
0
)
;
return
true
;
}
void
Printer
:
:
CopyToBuffer
(
const
char
*
data
int
size
)
{
if
(
failed_
)
return
;
if
(
size
=
=
0
)
return
;
while
(
size
>
buffer_size_
)
{
if
(
buffer_size_
>
0
)
{
memcpy
(
buffer_
data
buffer_size_
)
;
offset_
+
=
buffer_size_
;
data
+
=
buffer_size_
;
size
-
=
buffer_size_
;
}
void
*
void_buffer
;
failed_
=
!
output_
-
>
Next
(
&
void_buffer
&
buffer_size_
)
;
if
(
failed_
)
return
;
buffer_
=
reinterpret_cast
<
char
*
>
(
void_buffer
)
;
}
memcpy
(
buffer_
data
size
)
;
buffer_
+
=
size
;
buffer_size_
-
=
size
;
offset_
+
=
size
;
}
void
Printer
:
:
IndentIfAtStart
(
)
{
if
(
at_start_of_line_
)
{
CopyToBuffer
(
indent_
.
data
(
)
indent_
.
size
(
)
)
;
at_start_of_line_
=
false
;
}
}
void
Printer
:
:
FormatInternal
(
const
std
:
:
vector
<
std
:
:
string
>
&
args
const
std
:
:
map
<
std
:
:
string
std
:
:
string
>
&
vars
const
char
*
format
)
{
auto
save
=
format
;
int
arg_index
=
0
;
std
:
:
vector
<
AnnotationCollector
:
:
Annotation
>
annotations
;
while
(
*
format
)
{
char
c
=
*
format
+
+
;
switch
(
c
)
{
case
'
'
:
format
=
WriteVariable
(
args
vars
format
&
arg_index
&
annotations
)
;
continue
;
case
'
\
n
'
:
at_start_of_line_
=
true
;
line_start_variables_
.
clear
(
)
;
break
;
default
:
IndentIfAtStart
(
)
;
break
;
}
push_back
(
c
)
;
}
if
(
arg_index
!
=
static_cast
<
int
>
(
args
.
size
(
)
)
)
{
GOOGLE_LOG
(
FATAL
)
<
<
"
Unused
arguments
.
"
<
<
save
;
}
if
(
!
annotations
.
empty
(
)
)
{
GOOGLE_LOG
(
FATAL
)
<
<
"
Annotation
range
is
not
-
closed
expect
}
.
"
<
<
save
;
}
}
const
char
*
Printer
:
:
WriteVariable
(
const
std
:
:
vector
<
std
:
:
string
>
&
args
const
std
:
:
map
<
std
:
:
string
std
:
:
string
>
&
vars
const
char
*
format
int
*
arg_index
std
:
:
vector
<
AnnotationCollector
:
:
Annotation
>
*
annotations
)
{
auto
start
=
format
;
auto
end
=
strchr
(
format
'
'
)
;
if
(
!
end
)
{
GOOGLE_LOG
(
FATAL
)
<
<
"
Unclosed
variable
name
.
"
;
}
format
=
end
+
1
;
if
(
end
=
=
start
)
{
IndentIfAtStart
(
)
;
push_back
(
'
'
)
;
return
format
;
}
if
(
*
start
=
=
'
{
'
)
{
GOOGLE_CHECK
(
std
:
:
isdigit
(
start
[
1
]
)
)
;
GOOGLE_CHECK_EQ
(
end
-
start
2
)
;
int
idx
=
start
[
1
]
-
'
1
'
;
if
(
idx
<
0
|
|
static_cast
<
size_t
>
(
idx
)
>
=
args
.
size
(
)
)
{
GOOGLE_LOG
(
FATAL
)
<
<
"
Annotation
{
"
<
<
idx
+
1
<
<
"
is
out
of
bounds
.
"
;
}
if
(
idx
>
*
arg_index
)
{
GOOGLE_LOG
(
FATAL
)
<
<
"
Annotation
arg
must
be
in
correct
order
as
given
.
Expected
"
<
<
"
{
"
<
<
(
*
arg_index
)
+
1
<
<
"
got
{
"
<
<
idx
+
1
<
<
"
.
"
;
}
else
if
(
idx
=
=
*
arg_index
)
{
(
*
arg_index
)
+
+
;
}
IndentIfAtStart
(
)
;
annotations
-
>
push_back
(
{
{
offset_
0
}
args
[
idx
]
}
)
;
return
format
;
}
else
if
(
*
start
=
=
'
}
'
)
{
GOOGLE_CHECK
(
annotations
)
;
if
(
annotations
-
>
empty
(
)
)
{
GOOGLE_LOG
(
FATAL
)
<
<
"
Unexpected
end
of
annotation
found
.
"
;
}
auto
&
a
=
annotations
-
>
back
(
)
;
a
.
first
.
second
=
offset_
;
if
(
annotation_collector_
)
annotation_collector_
-
>
AddAnnotationNew
(
a
)
;
annotations
-
>
pop_back
(
)
;
return
format
;
}
auto
start_var
=
start
;
while
(
start_var
<
end
&
&
*
start_var
=
=
'
'
)
start_var
+
+
;
if
(
start_var
=
=
end
)
{
GOOGLE_LOG
(
FATAL
)
<
<
"
Empty
variable
.
"
;
}
auto
end_var
=
end
;
while
(
start_var
<
end_var
&
&
*
(
end_var
-
1
)
=
=
'
'
)
end_var
-
-
;
std
:
:
string
var_name
{
start_var
static_cast
<
std
:
:
string
:
:
size_type
>
(
end_var
-
start_var
)
}
;
std
:
:
string
sub
;
if
(
std
:
:
isdigit
(
var_name
[
0
]
)
)
{
GOOGLE_CHECK_EQ
(
var_name
.
size
(
)
1U
)
;
int
idx
=
var_name
[
0
]
-
'
1
'
;
GOOGLE_CHECK_GE
(
idx
0
)
;
if
(
static_cast
<
size_t
>
(
idx
)
>
=
args
.
size
(
)
)
{
GOOGLE_LOG
(
FATAL
)
<
<
"
Argument
"
<
<
idx
+
1
<
<
"
is
out
of
bounds
.
"
;
}
if
(
idx
>
*
arg_index
)
{
GOOGLE_LOG
(
FATAL
)
<
<
"
Arguments
must
be
used
in
same
order
as
given
.
Expected
"
<
<
(
*
arg_index
)
+
1
<
<
"
got
"
<
<
idx
+
1
<
<
"
.
"
;
}
else
if
(
idx
=
=
*
arg_index
)
{
(
*
arg_index
)
+
+
;
}
sub
=
args
[
idx
]
;
}
else
{
auto
it
=
vars
.
find
(
var_name
)
;
if
(
it
=
=
vars
.
end
(
)
)
{
GOOGLE_LOG
(
FATAL
)
<
<
"
Unknown
variable
:
"
<
<
var_name
<
<
"
.
"
;
}
sub
=
it
-
>
second
;
}
if
(
sub
.
empty
(
)
)
return
format
;
IndentIfAtStart
(
)
;
CopyToBuffer
(
start
start_var
-
start
)
;
CopyToBuffer
(
sub
.
c_str
(
)
sub
.
size
(
)
)
;
CopyToBuffer
(
end_var
end
-
end_var
)
;
return
format
;
}
}
}
}
