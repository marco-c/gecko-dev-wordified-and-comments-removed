#
ifndef
GOOGLE_PROTOBUF_IO_CODED_STREAM_H__
#
define
GOOGLE_PROTOBUF_IO_CODED_STREAM_H__
#
include
<
assert
.
h
>
#
include
<
atomic
>
#
include
<
climits
>
#
include
<
cstddef
>
#
include
<
cstring
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
utility
>
#
ifdef
_MSC_VER
#
if
!
defined
(
PROTOBUF_DISABLE_LITTLE_ENDIAN_OPT_FOR_TEST
)
#
define
PROTOBUF_LITTLE_ENDIAN
1
#
endif
#
if
_MSC_VER
>
=
1300
&
&
!
defined
(
__INTEL_COMPILER
)
#
pragma
runtime_checks
(
"
c
"
off
)
#
endif
#
else
#
include
<
sys
/
param
.
h
>
#
if
(
(
defined
(
__LITTLE_ENDIAN__
)
&
&
!
defined
(
__BIG_ENDIAN__
)
)
|
|
\
(
defined
(
__BYTE_ORDER
)
&
&
__BYTE_ORDER
=
=
__LITTLE_ENDIAN
)
)
&
&
\
!
defined
(
PROTOBUF_DISABLE_LITTLE_ENDIAN_OPT_FOR_TEST
)
#
define
PROTOBUF_LITTLE_ENDIAN
1
#
endif
#
endif
#
include
<
google
/
protobuf
/
stubs
/
common
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
logging
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
strutil
.
h
>
#
include
<
google
/
protobuf
/
port
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
port
.
h
>
#
include
<
google
/
protobuf
/
port_def
.
inc
>
namespace
google
{
namespace
protobuf
{
class
DescriptorPool
;
class
MessageFactory
;
class
ZeroCopyCodedInputStream
;
namespace
internal
{
void
MapTestForceDeterministic
(
)
;
class
EpsCopyByteStream
;
}
namespace
io
{
class
CodedInputStream
;
class
CodedOutputStream
;
class
ZeroCopyInputStream
;
class
ZeroCopyOutputStream
;
class
PROTOBUF_EXPORT
CodedInputStream
{
public
:
explicit
CodedInputStream
(
ZeroCopyInputStream
*
input
)
;
explicit
CodedInputStream
(
const
uint8
*
buffer
int
size
)
;
~
CodedInputStream
(
)
;
inline
bool
IsFlat
(
)
const
;
inline
bool
Skip
(
int
count
)
;
bool
GetDirectBufferPointer
(
const
void
*
*
data
int
*
size
)
;
PROTOBUF_ALWAYS_INLINE
void
GetDirectBufferPointerInline
(
const
void
*
*
data
int
*
size
)
;
bool
ReadRaw
(
void
*
buffer
int
size
)
;
bool
ReadString
(
std
:
:
string
*
buffer
int
size
)
;
bool
ReadLittleEndian32
(
uint32
*
value
)
;
bool
ReadLittleEndian64
(
uint64
*
value
)
;
static
const
uint8
*
ReadLittleEndian32FromArray
(
const
uint8
*
buffer
uint32
*
value
)
;
static
const
uint8
*
ReadLittleEndian64FromArray
(
const
uint8
*
buffer
uint64
*
value
)
;
bool
ReadVarint32
(
uint32
*
value
)
;
bool
ReadVarint64
(
uint64
*
value
)
;
bool
ReadVarintSizeAsInt
(
int
*
value
)
;
PROTOBUF_ALWAYS_INLINE
uint32
ReadTag
(
)
{
return
last_tag_
=
ReadTagNoLastTag
(
)
;
}
PROTOBUF_ALWAYS_INLINE
uint32
ReadTagNoLastTag
(
)
;
PROTOBUF_ALWAYS_INLINE
std
:
:
pair
<
uint32
bool
>
ReadTagWithCutoff
(
uint32
cutoff
)
{
std
:
:
pair
<
uint32
bool
>
result
=
ReadTagWithCutoffNoLastTag
(
cutoff
)
;
last_tag_
=
result
.
first
;
return
result
;
}
PROTOBUF_ALWAYS_INLINE
std
:
:
pair
<
uint32
bool
>
ReadTagWithCutoffNoLastTag
(
uint32
cutoff
)
;
PROTOBUF_ALWAYS_INLINE
bool
ExpectTag
(
uint32
expected
)
;
PROTOBUF_ALWAYS_INLINE
static
const
uint8
*
ExpectTagFromArray
(
const
uint8
*
buffer
uint32
expected
)
;
bool
ExpectAtEnd
(
)
;
bool
LastTagWas
(
uint32
expected
)
;
void
SetLastTag
(
uint32
tag
)
{
last_tag_
=
tag
;
}
bool
ConsumedEntireMessage
(
)
;
void
SetConsumed
(
)
{
legitimate_message_end_
=
true
;
}
typedef
int
Limit
;
Limit
PushLimit
(
int
byte_limit
)
;
void
PopLimit
(
Limit
limit
)
;
int
BytesUntilLimit
(
)
const
;
int
CurrentPosition
(
)
const
;
void
SetTotalBytesLimit
(
int
total_bytes_limit
)
;
PROTOBUF_DEPRECATED_MSG
(
"
Please
use
the
single
parameter
version
of
SetTotalBytesLimit
(
)
.
The
"
"
second
parameter
is
ignored
.
"
)
void
SetTotalBytesLimit
(
int
total_bytes_limit
int
)
{
SetTotalBytesLimit
(
total_bytes_limit
)
;
}
int
BytesUntilTotalBytesLimit
(
)
const
;
void
SetRecursionLimit
(
int
limit
)
;
int
RecursionBudget
(
)
{
return
recursion_budget_
;
}
static
int
GetDefaultRecursionLimit
(
)
{
return
default_recursion_limit_
;
}
bool
IncrementRecursionDepth
(
)
;
void
DecrementRecursionDepth
(
)
;
void
UnsafeDecrementRecursionDepth
(
)
;
std
:
:
pair
<
CodedInputStream
:
:
Limit
int
>
IncrementRecursionDepthAndPushLimit
(
int
byte_limit
)
;
Limit
ReadLengthAndPushLimit
(
)
;
bool
DecrementRecursionDepthAndPopLimit
(
Limit
limit
)
;
bool
CheckEntireMessageConsumedAndPopLimit
(
Limit
limit
)
;
void
SetExtensionRegistry
(
const
DescriptorPool
*
pool
MessageFactory
*
factory
)
;
const
DescriptorPool
*
GetExtensionPool
(
)
;
MessageFactory
*
GetExtensionFactory
(
)
;
private
:
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
CodedInputStream
)
;
const
uint8
*
buffer_
;
const
uint8
*
buffer_end_
;
ZeroCopyInputStream
*
input_
;
int
total_bytes_read_
;
int
overflow_bytes_
;
uint32
last_tag_
;
bool
legitimate_message_end_
;
bool
aliasing_enabled_
;
Limit
current_limit_
;
int
buffer_size_after_limit_
;
int
total_bytes_limit_
;
int
recursion_budget_
;
int
recursion_limit_
;
const
DescriptorPool
*
extension_pool_
;
MessageFactory
*
extension_factory_
;
bool
SkipFallback
(
int
count
int
original_buffer_size
)
;
void
Advance
(
int
amount
)
;
void
BackUpInputToCurrentPosition
(
)
;
void
RecomputeBufferLimits
(
)
;
void
PrintTotalBytesLimitError
(
)
;
bool
Refresh
(
)
;
int64
ReadVarint32Fallback
(
uint32
first_byte_or_zero
)
;
int
ReadVarintSizeAsIntFallback
(
)
;
std
:
:
pair
<
uint64
bool
>
ReadVarint64Fallback
(
)
;
bool
ReadVarint32Slow
(
uint32
*
value
)
;
bool
ReadVarint64Slow
(
uint64
*
value
)
;
int
ReadVarintSizeAsIntSlow
(
)
;
bool
ReadLittleEndian32Fallback
(
uint32
*
value
)
;
bool
ReadLittleEndian64Fallback
(
uint64
*
value
)
;
uint32
ReadTagFallback
(
uint32
first_byte_or_zero
)
;
uint32
ReadTagSlow
(
)
;
bool
ReadStringFallback
(
std
:
:
string
*
buffer
int
size
)
;
int
BufferSize
(
)
const
;
static
const
int
kDefaultTotalBytesLimit
=
INT_MAX
;
static
int
default_recursion_limit_
;
friend
class
google
:
:
protobuf
:
:
ZeroCopyCodedInputStream
;
friend
class
google
:
:
protobuf
:
:
internal
:
:
EpsCopyByteStream
;
}
;
class
PROTOBUF_EXPORT
EpsCopyOutputStream
{
public
:
enum
{
kSlopBytes
=
16
}
;
EpsCopyOutputStream
(
ZeroCopyOutputStream
*
stream
bool
deterministic
uint8
*
*
pp
)
:
end_
(
buffer_
)
stream_
(
stream
)
is_serialization_deterministic_
(
deterministic
)
{
*
pp
=
buffer_
;
}
EpsCopyOutputStream
(
void
*
data
int
size
bool
deterministic
)
:
end_
(
static_cast
<
uint8
*
>
(
data
)
+
size
)
buffer_end_
(
nullptr
)
stream_
(
nullptr
)
is_serialization_deterministic_
(
deterministic
)
{
}
EpsCopyOutputStream
(
void
*
data
int
size
ZeroCopyOutputStream
*
stream
bool
deterministic
uint8
*
*
pp
)
:
stream_
(
stream
)
is_serialization_deterministic_
(
deterministic
)
{
*
pp
=
SetInitialBuffer
(
data
size
)
;
}
uint8
*
Trim
(
uint8
*
ptr
)
;
PROTOBUF_MUST_USE_RESULT
uint8
*
EnsureSpace
(
uint8
*
ptr
)
{
if
(
PROTOBUF_PREDICT_FALSE
(
ptr
>
=
end_
)
)
{
return
EnsureSpaceFallback
(
ptr
)
;
}
return
ptr
;
}
uint8
*
WriteRaw
(
const
void
*
data
int
size
uint8
*
ptr
)
{
if
(
PROTOBUF_PREDICT_FALSE
(
end_
-
ptr
<
size
)
)
{
return
WriteRawFallback
(
data
size
ptr
)
;
}
std
:
:
memcpy
(
ptr
data
size
)
;
return
ptr
+
size
;
}
uint8
*
WriteRawMaybeAliased
(
const
void
*
data
int
size
uint8
*
ptr
)
{
if
(
aliasing_enabled_
)
{
return
WriteAliasedRaw
(
data
size
ptr
)
;
}
else
{
return
WriteRaw
(
data
size
ptr
)
;
}
}
uint8
*
WriteStringMaybeAliased
(
uint32
num
const
std
:
:
string
&
s
uint8
*
ptr
)
{
std
:
:
ptrdiff_t
size
=
s
.
size
(
)
;
if
(
PROTOBUF_PREDICT_FALSE
(
size
>
=
128
|
|
end_
-
ptr
+
16
-
TagSize
(
num
<
<
3
)
-
1
<
size
)
)
{
return
WriteStringMaybeAliasedOutline
(
num
s
ptr
)
;
}
ptr
=
UnsafeVarint
(
(
num
<
<
3
)
|
2
ptr
)
;
*
ptr
+
+
=
static_cast
<
uint8
>
(
size
)
;
std
:
:
memcpy
(
ptr
s
.
data
(
)
size
)
;
return
ptr
+
size
;
}
uint8
*
WriteBytesMaybeAliased
(
uint32
num
const
std
:
:
string
&
s
uint8
*
ptr
)
{
return
WriteStringMaybeAliased
(
num
s
ptr
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
uint8
*
WriteString
(
uint32
num
const
T
&
s
uint8
*
ptr
)
{
std
:
:
ptrdiff_t
size
=
s
.
size
(
)
;
if
(
PROTOBUF_PREDICT_FALSE
(
size
>
=
128
|
|
end_
-
ptr
+
16
-
TagSize
(
num
<
<
3
)
-
1
<
size
)
)
{
return
WriteStringOutline
(
num
s
ptr
)
;
}
ptr
=
UnsafeVarint
(
(
num
<
<
3
)
|
2
ptr
)
;
*
ptr
+
+
=
static_cast
<
uint8
>
(
size
)
;
std
:
:
memcpy
(
ptr
s
.
data
(
)
size
)
;
return
ptr
+
size
;
}
template
<
typename
T
>
uint8
*
WriteBytes
(
uint32
num
const
T
&
s
uint8
*
ptr
)
{
return
WriteString
(
num
s
ptr
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
uint8
*
WriteInt32Packed
(
int
num
const
T
&
r
int
size
uint8
*
ptr
)
{
return
WriteVarintPacked
(
num
r
size
ptr
Encode64
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
uint8
*
WriteUInt32Packed
(
int
num
const
T
&
r
int
size
uint8
*
ptr
)
{
return
WriteVarintPacked
(
num
r
size
ptr
Encode32
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
uint8
*
WriteSInt32Packed
(
int
num
const
T
&
r
int
size
uint8
*
ptr
)
{
return
WriteVarintPacked
(
num
r
size
ptr
ZigZagEncode32
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
uint8
*
WriteInt64Packed
(
int
num
const
T
&
r
int
size
uint8
*
ptr
)
{
return
WriteVarintPacked
(
num
r
size
ptr
Encode64
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
uint8
*
WriteUInt64Packed
(
int
num
const
T
&
r
int
size
uint8
*
ptr
)
{
return
WriteVarintPacked
(
num
r
size
ptr
Encode64
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
uint8
*
WriteSInt64Packed
(
int
num
const
T
&
r
int
size
uint8
*
ptr
)
{
return
WriteVarintPacked
(
num
r
size
ptr
ZigZagEncode64
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
uint8
*
WriteEnumPacked
(
int
num
const
T
&
r
int
size
uint8
*
ptr
)
{
return
WriteVarintPacked
(
num
r
size
ptr
Encode64
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
uint8
*
WriteFixedPacked
(
int
num
const
T
&
r
uint8
*
ptr
)
{
ptr
=
EnsureSpace
(
ptr
)
;
constexpr
auto
element_size
=
sizeof
(
typename
T
:
:
value_type
)
;
auto
size
=
r
.
size
(
)
*
element_size
;
ptr
=
WriteLengthDelim
(
num
size
ptr
)
;
return
WriteRawLittleEndian
<
element_size
>
(
r
.
data
(
)
static_cast
<
int
>
(
size
)
ptr
)
;
}
bool
HadError
(
)
const
{
return
had_error_
;
}
void
EnableAliasing
(
bool
enabled
)
;
void
SetSerializationDeterministic
(
bool
value
)
{
is_serialization_deterministic_
=
value
;
}
bool
IsSerializationDeterministic
(
)
const
{
return
is_serialization_deterministic_
;
}
int64
ByteCount
(
uint8
*
ptr
)
const
;
private
:
uint8
*
end_
;
uint8
*
buffer_end_
=
buffer_
;
uint8
buffer_
[
2
*
kSlopBytes
]
;
ZeroCopyOutputStream
*
stream_
;
bool
had_error_
=
false
;
bool
aliasing_enabled_
=
false
;
bool
is_serialization_deterministic_
;
uint8
*
EnsureSpaceFallback
(
uint8
*
ptr
)
;
inline
uint8
*
Next
(
)
;
int
Flush
(
uint8
*
ptr
)
;
std
:
:
ptrdiff_t
GetSize
(
uint8
*
ptr
)
const
{
GOOGLE_DCHECK
(
ptr
<
=
end_
+
kSlopBytes
)
;
return
end_
+
kSlopBytes
-
ptr
;
}
uint8
*
Error
(
)
{
had_error_
=
true
;
end_
=
buffer_
+
kSlopBytes
;
return
buffer_
;
}
static
constexpr
int
TagSize
(
uint32
tag
)
{
return
(
tag
<
(
1
<
<
7
)
)
?
1
:
(
tag
<
(
1
<
<
14
)
)
?
2
:
(
tag
<
(
1
<
<
21
)
)
?
3
:
(
tag
<
(
1
<
<
28
)
)
?
4
:
5
;
}
PROTOBUF_ALWAYS_INLINE
uint8
*
WriteTag
(
uint32
num
uint32
wt
uint8
*
ptr
)
{
GOOGLE_DCHECK
(
ptr
<
end_
)
;
return
UnsafeVarint
(
(
num
<
<
3
)
|
wt
ptr
)
;
}
PROTOBUF_ALWAYS_INLINE
uint8
*
WriteLengthDelim
(
int
num
uint32
size
uint8
*
ptr
)
{
ptr
=
WriteTag
(
num
2
ptr
)
;
return
UnsafeWriteSize
(
size
ptr
)
;
}
uint8
*
WriteRawFallback
(
const
void
*
data
int
size
uint8
*
ptr
)
;
uint8
*
WriteAliasedRaw
(
const
void
*
data
int
size
uint8
*
ptr
)
;
uint8
*
WriteStringMaybeAliasedOutline
(
uint32
num
const
std
:
:
string
&
s
uint8
*
ptr
)
;
uint8
*
WriteStringOutline
(
uint32
num
const
std
:
:
string
&
s
uint8
*
ptr
)
;
template
<
typename
T
typename
E
>
PROTOBUF_ALWAYS_INLINE
uint8
*
WriteVarintPacked
(
int
num
const
T
&
r
int
size
uint8
*
ptr
const
E
&
encode
)
{
ptr
=
EnsureSpace
(
ptr
)
;
ptr
=
WriteLengthDelim
(
num
size
ptr
)
;
auto
it
=
r
.
data
(
)
;
auto
end
=
it
+
r
.
size
(
)
;
do
{
ptr
=
EnsureSpace
(
ptr
)
;
ptr
=
UnsafeVarint
(
encode
(
*
it
+
+
)
ptr
)
;
}
while
(
it
<
end
)
;
return
ptr
;
}
static
uint32
Encode32
(
uint32
v
)
{
return
v
;
}
static
uint64
Encode64
(
uint64
v
)
{
return
v
;
}
static
uint32
ZigZagEncode32
(
int32
v
)
{
return
(
static_cast
<
uint32
>
(
v
)
<
<
1
)
^
static_cast
<
uint32
>
(
v
>
>
31
)
;
}
static
uint64
ZigZagEncode64
(
int64
v
)
{
return
(
static_cast
<
uint64
>
(
v
)
<
<
1
)
^
static_cast
<
uint64
>
(
v
>
>
63
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
static
uint8
*
UnsafeVarint
(
T
value
uint8
*
ptr
)
{
static_assert
(
std
:
:
is_unsigned
<
T
>
:
:
value
"
Varint
serialization
must
be
unsigned
"
)
;
if
(
value
<
0x80
)
{
ptr
[
0
]
=
static_cast
<
uint8
>
(
value
)
;
return
ptr
+
1
;
}
ptr
[
0
]
=
static_cast
<
uint8
>
(
value
|
0x80
)
;
value
>
>
=
7
;
if
(
value
<
0x80
)
{
ptr
[
1
]
=
static_cast
<
uint8
>
(
value
)
;
return
ptr
+
2
;
}
ptr
+
+
;
do
{
*
ptr
=
static_cast
<
uint8
>
(
value
|
0x80
)
;
value
>
>
=
7
;
+
+
ptr
;
}
while
(
PROTOBUF_PREDICT_FALSE
(
value
>
=
0x80
)
)
;
*
ptr
+
+
=
static_cast
<
uint8
>
(
value
)
;
return
ptr
;
}
PROTOBUF_ALWAYS_INLINE
static
uint8
*
UnsafeWriteSize
(
uint32
value
uint8
*
ptr
)
{
while
(
PROTOBUF_PREDICT_FALSE
(
value
>
=
0x80
)
)
{
*
ptr
=
static_cast
<
uint8
>
(
value
|
0x80
)
;
value
>
>
=
7
;
+
+
ptr
;
}
*
ptr
+
+
=
static_cast
<
uint8
>
(
value
)
;
return
ptr
;
}
template
<
int
S
>
uint8
*
WriteRawLittleEndian
(
const
void
*
data
int
size
uint8
*
ptr
)
;
#
ifndef
PROTOBUF_LITTLE_ENDIAN
uint8
*
WriteRawLittleEndian32
(
const
void
*
data
int
size
uint8
*
ptr
)
;
uint8
*
WriteRawLittleEndian64
(
const
void
*
data
int
size
uint8
*
ptr
)
;
#
endif
public
:
uint8
*
SetInitialBuffer
(
void
*
data
int
size
)
{
auto
ptr
=
static_cast
<
uint8
*
>
(
data
)
;
if
(
size
>
kSlopBytes
)
{
end_
=
ptr
+
size
-
kSlopBytes
;
buffer_end_
=
nullptr
;
return
ptr
;
}
else
{
end_
=
buffer_
+
size
;
buffer_end_
=
ptr
;
return
buffer_
;
}
}
private
:
uint8
*
FlushAndResetBuffer
(
uint8
*
)
;
bool
Skip
(
int
count
uint8
*
*
pp
)
;
bool
GetDirectBufferPointer
(
void
*
*
data
int
*
size
uint8
*
*
pp
)
;
uint8
*
GetDirectBufferForNBytesAndAdvance
(
int
size
uint8
*
*
pp
)
;
friend
class
CodedOutputStream
;
}
;
template
<
>
inline
uint8
*
EpsCopyOutputStream
:
:
WriteRawLittleEndian
<
1
>
(
const
void
*
data
int
size
uint8
*
ptr
)
{
return
WriteRaw
(
data
size
ptr
)
;
}
template
<
>
inline
uint8
*
EpsCopyOutputStream
:
:
WriteRawLittleEndian
<
4
>
(
const
void
*
data
int
size
uint8
*
ptr
)
{
#
ifdef
PROTOBUF_LITTLE_ENDIAN
return
WriteRaw
(
data
size
ptr
)
;
#
else
return
WriteRawLittleEndian32
(
data
size
ptr
)
;
#
endif
}
template
<
>
inline
uint8
*
EpsCopyOutputStream
:
:
WriteRawLittleEndian
<
8
>
(
const
void
*
data
int
size
uint8
*
ptr
)
{
#
ifdef
PROTOBUF_LITTLE_ENDIAN
return
WriteRaw
(
data
size
ptr
)
;
#
else
return
WriteRawLittleEndian64
(
data
size
ptr
)
;
#
endif
}
class
PROTOBUF_EXPORT
CodedOutputStream
{
public
:
explicit
CodedOutputStream
(
ZeroCopyOutputStream
*
stream
)
:
CodedOutputStream
(
stream
true
)
{
}
CodedOutputStream
(
ZeroCopyOutputStream
*
stream
bool
do_eager_refresh
)
;
~
CodedOutputStream
(
)
;
bool
HadError
(
)
{
cur_
=
impl_
.
FlushAndResetBuffer
(
cur_
)
;
GOOGLE_DCHECK
(
cur_
)
;
return
impl_
.
HadError
(
)
;
}
void
Trim
(
)
{
cur_
=
impl_
.
Trim
(
cur_
)
;
}
bool
Skip
(
int
count
)
{
return
impl_
.
Skip
(
count
&
cur_
)
;
}
bool
GetDirectBufferPointer
(
void
*
*
data
int
*
size
)
{
return
impl_
.
GetDirectBufferPointer
(
data
size
&
cur_
)
;
}
inline
uint8
*
GetDirectBufferForNBytesAndAdvance
(
int
size
)
{
return
impl_
.
GetDirectBufferForNBytesAndAdvance
(
size
&
cur_
)
;
}
void
WriteRaw
(
const
void
*
buffer
int
size
)
{
cur_
=
impl_
.
WriteRaw
(
buffer
size
cur_
)
;
}
void
WriteRawMaybeAliased
(
const
void
*
data
int
size
)
;
static
uint8
*
WriteRawToArray
(
const
void
*
buffer
int
size
uint8
*
target
)
;
void
WriteString
(
const
std
:
:
string
&
str
)
;
static
uint8
*
WriteStringToArray
(
const
std
:
:
string
&
str
uint8
*
target
)
;
static
uint8
*
WriteStringWithSizeToArray
(
const
std
:
:
string
&
str
uint8
*
target
)
;
void
WriteLittleEndian32
(
uint32
value
)
{
cur_
=
impl_
.
EnsureSpace
(
cur_
)
;
SetCur
(
WriteLittleEndian32ToArray
(
value
Cur
(
)
)
)
;
}
static
uint8
*
WriteLittleEndian32ToArray
(
uint32
value
uint8
*
target
)
;
void
WriteLittleEndian64
(
uint64
value
)
{
cur_
=
impl_
.
EnsureSpace
(
cur_
)
;
SetCur
(
WriteLittleEndian64ToArray
(
value
Cur
(
)
)
)
;
}
static
uint8
*
WriteLittleEndian64ToArray
(
uint64
value
uint8
*
target
)
;
void
WriteVarint32
(
uint32
value
)
;
static
uint8
*
WriteVarint32ToArray
(
uint32
value
uint8
*
target
)
;
void
WriteVarint64
(
uint64
value
)
;
static
uint8
*
WriteVarint64ToArray
(
uint64
value
uint8
*
target
)
;
void
WriteVarint32SignExtended
(
int32
value
)
;
static
uint8
*
WriteVarint32SignExtendedToArray
(
int32
value
uint8
*
target
)
;
void
WriteTag
(
uint32
value
)
;
PROTOBUF_ALWAYS_INLINE
static
uint8
*
WriteTagToArray
(
uint32
value
uint8
*
target
)
;
static
size_t
VarintSize32
(
uint32
value
)
;
static
size_t
VarintSize64
(
uint64
value
)
;
static
size_t
VarintSize32SignExtended
(
int32
value
)
;
template
<
uint32
Value
>
struct
StaticVarintSize32
{
static
const
size_t
value
=
(
Value
<
(
1
<
<
7
)
)
?
1
:
(
Value
<
(
1
<
<
14
)
)
?
2
:
(
Value
<
(
1
<
<
21
)
)
?
3
:
(
Value
<
(
1
<
<
28
)
)
?
4
:
5
;
}
;
int
ByteCount
(
)
const
{
return
static_cast
<
int
>
(
impl_
.
ByteCount
(
cur_
)
-
start_count_
)
;
}
void
EnableAliasing
(
bool
enabled
)
{
impl_
.
EnableAliasing
(
enabled
)
;
}
void
SetSerializationDeterministic
(
bool
value
)
{
impl_
.
SetSerializationDeterministic
(
value
)
;
}
bool
IsSerializationDeterministic
(
)
const
{
return
impl_
.
IsSerializationDeterministic
(
)
;
}
static
bool
IsDefaultSerializationDeterministic
(
)
{
return
default_serialization_deterministic_
.
load
(
std
:
:
memory_order_relaxed
)
!
=
0
;
}
template
<
typename
Func
>
void
Serialize
(
const
Func
&
func
)
;
uint8
*
Cur
(
)
const
{
return
cur_
;
}
void
SetCur
(
uint8
*
ptr
)
{
cur_
=
ptr
;
}
EpsCopyOutputStream
*
EpsCopy
(
)
{
return
&
impl_
;
}
private
:
EpsCopyOutputStream
impl_
;
uint8
*
cur_
;
int64
start_count_
;
static
std
:
:
atomic
<
bool
>
default_serialization_deterministic_
;
friend
void
internal
:
:
MapTestForceDeterministic
(
)
;
static
void
SetDefaultSerializationDeterministic
(
)
{
default_serialization_deterministic_
.
store
(
true
std
:
:
memory_order_relaxed
)
;
}
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
CodedOutputStream
)
;
}
;
inline
bool
CodedInputStream
:
:
ReadVarint32
(
uint32
*
value
)
{
uint32
v
=
0
;
if
(
PROTOBUF_PREDICT_TRUE
(
buffer_
<
buffer_end_
)
)
{
v
=
*
buffer_
;
if
(
v
<
0x80
)
{
*
value
=
v
;
Advance
(
1
)
;
return
true
;
}
}
int64
result
=
ReadVarint32Fallback
(
v
)
;
*
value
=
static_cast
<
uint32
>
(
result
)
;
return
result
>
=
0
;
}
inline
bool
CodedInputStream
:
:
ReadVarint64
(
uint64
*
value
)
{
if
(
PROTOBUF_PREDICT_TRUE
(
buffer_
<
buffer_end_
)
&
&
*
buffer_
<
0x80
)
{
*
value
=
*
buffer_
;
Advance
(
1
)
;
return
true
;
}
std
:
:
pair
<
uint64
bool
>
p
=
ReadVarint64Fallback
(
)
;
*
value
=
p
.
first
;
return
p
.
second
;
}
inline
bool
CodedInputStream
:
:
ReadVarintSizeAsInt
(
int
*
value
)
{
if
(
PROTOBUF_PREDICT_TRUE
(
buffer_
<
buffer_end_
)
)
{
int
v
=
*
buffer_
;
if
(
v
<
0x80
)
{
*
value
=
v
;
Advance
(
1
)
;
return
true
;
}
}
*
value
=
ReadVarintSizeAsIntFallback
(
)
;
return
*
value
>
=
0
;
}
inline
const
uint8
*
CodedInputStream
:
:
ReadLittleEndian32FromArray
(
const
uint8
*
buffer
uint32
*
value
)
{
#
if
defined
(
PROTOBUF_LITTLE_ENDIAN
)
memcpy
(
value
buffer
sizeof
(
*
value
)
)
;
return
buffer
+
sizeof
(
*
value
)
;
#
else
*
value
=
(
static_cast
<
uint32
>
(
buffer
[
0
]
)
)
|
(
static_cast
<
uint32
>
(
buffer
[
1
]
)
<
<
8
)
|
(
static_cast
<
uint32
>
(
buffer
[
2
]
)
<
<
16
)
|
(
static_cast
<
uint32
>
(
buffer
[
3
]
)
<
<
24
)
;
return
buffer
+
sizeof
(
*
value
)
;
#
endif
}
inline
const
uint8
*
CodedInputStream
:
:
ReadLittleEndian64FromArray
(
const
uint8
*
buffer
uint64
*
value
)
{
#
if
defined
(
PROTOBUF_LITTLE_ENDIAN
)
memcpy
(
value
buffer
sizeof
(
*
value
)
)
;
return
buffer
+
sizeof
(
*
value
)
;
#
else
uint32
part0
=
(
static_cast
<
uint32
>
(
buffer
[
0
]
)
)
|
(
static_cast
<
uint32
>
(
buffer
[
1
]
)
<
<
8
)
|
(
static_cast
<
uint32
>
(
buffer
[
2
]
)
<
<
16
)
|
(
static_cast
<
uint32
>
(
buffer
[
3
]
)
<
<
24
)
;
uint32
part1
=
(
static_cast
<
uint32
>
(
buffer
[
4
]
)
)
|
(
static_cast
<
uint32
>
(
buffer
[
5
]
)
<
<
8
)
|
(
static_cast
<
uint32
>
(
buffer
[
6
]
)
<
<
16
)
|
(
static_cast
<
uint32
>
(
buffer
[
7
]
)
<
<
24
)
;
*
value
=
static_cast
<
uint64
>
(
part0
)
|
(
static_cast
<
uint64
>
(
part1
)
<
<
32
)
;
return
buffer
+
sizeof
(
*
value
)
;
#
endif
}
inline
bool
CodedInputStream
:
:
ReadLittleEndian32
(
uint32
*
value
)
{
#
if
defined
(
PROTOBUF_LITTLE_ENDIAN
)
if
(
PROTOBUF_PREDICT_TRUE
(
BufferSize
(
)
>
=
static_cast
<
int
>
(
sizeof
(
*
value
)
)
)
)
{
buffer_
=
ReadLittleEndian32FromArray
(
buffer_
value
)
;
return
true
;
}
else
{
return
ReadLittleEndian32Fallback
(
value
)
;
}
#
else
return
ReadLittleEndian32Fallback
(
value
)
;
#
endif
}
inline
bool
CodedInputStream
:
:
ReadLittleEndian64
(
uint64
*
value
)
{
#
if
defined
(
PROTOBUF_LITTLE_ENDIAN
)
if
(
PROTOBUF_PREDICT_TRUE
(
BufferSize
(
)
>
=
static_cast
<
int
>
(
sizeof
(
*
value
)
)
)
)
{
buffer_
=
ReadLittleEndian64FromArray
(
buffer_
value
)
;
return
true
;
}
else
{
return
ReadLittleEndian64Fallback
(
value
)
;
}
#
else
return
ReadLittleEndian64Fallback
(
value
)
;
#
endif
}
inline
uint32
CodedInputStream
:
:
ReadTagNoLastTag
(
)
{
uint32
v
=
0
;
if
(
PROTOBUF_PREDICT_TRUE
(
buffer_
<
buffer_end_
)
)
{
v
=
*
buffer_
;
if
(
v
<
0x80
)
{
Advance
(
1
)
;
return
v
;
}
}
v
=
ReadTagFallback
(
v
)
;
return
v
;
}
inline
std
:
:
pair
<
uint32
bool
>
CodedInputStream
:
:
ReadTagWithCutoffNoLastTag
(
uint32
cutoff
)
{
uint32
first_byte_or_zero
=
0
;
if
(
PROTOBUF_PREDICT_TRUE
(
buffer_
<
buffer_end_
)
)
{
first_byte_or_zero
=
buffer_
[
0
]
;
if
(
static_cast
<
int8
>
(
buffer_
[
0
]
)
>
0
)
{
const
uint32
kMax1ByteVarint
=
0x7f
;
uint32
tag
=
buffer_
[
0
]
;
Advance
(
1
)
;
return
std
:
:
make_pair
(
tag
cutoff
>
=
kMax1ByteVarint
|
|
tag
<
=
cutoff
)
;
}
if
(
cutoff
>
=
0x80
&
&
PROTOBUF_PREDICT_TRUE
(
buffer_
+
1
<
buffer_end_
)
&
&
PROTOBUF_PREDICT_TRUE
(
(
buffer_
[
0
]
&
~
buffer_
[
1
]
)
>
=
0x80
)
)
{
const
uint32
kMax2ByteVarint
=
(
0x7f
<
<
7
)
+
0x7f
;
uint32
tag
=
(
1u
<
<
7
)
*
buffer_
[
1
]
+
(
buffer_
[
0
]
-
0x80
)
;
Advance
(
2
)
;
bool
at_or_below_cutoff
=
cutoff
>
=
kMax2ByteVarint
|
|
tag
<
=
cutoff
;
return
std
:
:
make_pair
(
tag
at_or_below_cutoff
)
;
}
}
const
uint32
tag
=
ReadTagFallback
(
first_byte_or_zero
)
;
return
std
:
:
make_pair
(
tag
static_cast
<
uint32
>
(
tag
-
1
)
<
cutoff
)
;
}
inline
bool
CodedInputStream
:
:
LastTagWas
(
uint32
expected
)
{
return
last_tag_
=
=
expected
;
}
inline
bool
CodedInputStream
:
:
ConsumedEntireMessage
(
)
{
return
legitimate_message_end_
;
}
inline
bool
CodedInputStream
:
:
ExpectTag
(
uint32
expected
)
{
if
(
expected
<
(
1
<
<
7
)
)
{
if
(
PROTOBUF_PREDICT_TRUE
(
buffer_
<
buffer_end_
)
&
&
buffer_
[
0
]
=
=
expected
)
{
Advance
(
1
)
;
return
true
;
}
else
{
return
false
;
}
}
else
if
(
expected
<
(
1
<
<
14
)
)
{
if
(
PROTOBUF_PREDICT_TRUE
(
BufferSize
(
)
>
=
2
)
&
&
buffer_
[
0
]
=
=
static_cast
<
uint8
>
(
expected
|
0x80
)
&
&
buffer_
[
1
]
=
=
static_cast
<
uint8
>
(
expected
>
>
7
)
)
{
Advance
(
2
)
;
return
true
;
}
else
{
return
false
;
}
}
else
{
return
false
;
}
}
inline
const
uint8
*
CodedInputStream
:
:
ExpectTagFromArray
(
const
uint8
*
buffer
uint32
expected
)
{
if
(
expected
<
(
1
<
<
7
)
)
{
if
(
buffer
[
0
]
=
=
expected
)
{
return
buffer
+
1
;
}
}
else
if
(
expected
<
(
1
<
<
14
)
)
{
if
(
buffer
[
0
]
=
=
static_cast
<
uint8
>
(
expected
|
0x80
)
&
&
buffer
[
1
]
=
=
static_cast
<
uint8
>
(
expected
>
>
7
)
)
{
return
buffer
+
2
;
}
}
return
nullptr
;
}
inline
void
CodedInputStream
:
:
GetDirectBufferPointerInline
(
const
void
*
*
data
int
*
size
)
{
*
data
=
buffer_
;
*
size
=
static_cast
<
int
>
(
buffer_end_
-
buffer_
)
;
}
inline
bool
CodedInputStream
:
:
ExpectAtEnd
(
)
{
if
(
buffer_
=
=
buffer_end_
&
&
(
(
buffer_size_after_limit_
!
=
0
)
|
|
(
total_bytes_read_
=
=
current_limit_
)
)
)
{
last_tag_
=
0
;
legitimate_message_end_
=
true
;
return
true
;
}
else
{
return
false
;
}
}
inline
int
CodedInputStream
:
:
CurrentPosition
(
)
const
{
return
total_bytes_read_
-
(
BufferSize
(
)
+
buffer_size_after_limit_
)
;
}
inline
void
CodedInputStream
:
:
Advance
(
int
amount
)
{
buffer_
+
=
amount
;
}
inline
void
CodedInputStream
:
:
SetRecursionLimit
(
int
limit
)
{
recursion_budget_
+
=
limit
-
recursion_limit_
;
recursion_limit_
=
limit
;
}
inline
bool
CodedInputStream
:
:
IncrementRecursionDepth
(
)
{
-
-
recursion_budget_
;
return
recursion_budget_
>
=
0
;
}
inline
void
CodedInputStream
:
:
DecrementRecursionDepth
(
)
{
if
(
recursion_budget_
<
recursion_limit_
)
+
+
recursion_budget_
;
}
inline
void
CodedInputStream
:
:
UnsafeDecrementRecursionDepth
(
)
{
assert
(
recursion_budget_
<
recursion_limit_
)
;
+
+
recursion_budget_
;
}
inline
void
CodedInputStream
:
:
SetExtensionRegistry
(
const
DescriptorPool
*
pool
MessageFactory
*
factory
)
{
extension_pool_
=
pool
;
extension_factory_
=
factory
;
}
inline
const
DescriptorPool
*
CodedInputStream
:
:
GetExtensionPool
(
)
{
return
extension_pool_
;
}
inline
MessageFactory
*
CodedInputStream
:
:
GetExtensionFactory
(
)
{
return
extension_factory_
;
}
inline
int
CodedInputStream
:
:
BufferSize
(
)
const
{
return
static_cast
<
int
>
(
buffer_end_
-
buffer_
)
;
}
inline
CodedInputStream
:
:
CodedInputStream
(
ZeroCopyInputStream
*
input
)
:
buffer_
(
nullptr
)
buffer_end_
(
nullptr
)
input_
(
input
)
total_bytes_read_
(
0
)
overflow_bytes_
(
0
)
last_tag_
(
0
)
legitimate_message_end_
(
false
)
aliasing_enabled_
(
false
)
current_limit_
(
kint32max
)
buffer_size_after_limit_
(
0
)
total_bytes_limit_
(
kDefaultTotalBytesLimit
)
recursion_budget_
(
default_recursion_limit_
)
recursion_limit_
(
default_recursion_limit_
)
extension_pool_
(
nullptr
)
extension_factory_
(
nullptr
)
{
Refresh
(
)
;
}
inline
CodedInputStream
:
:
CodedInputStream
(
const
uint8
*
buffer
int
size
)
:
buffer_
(
buffer
)
buffer_end_
(
buffer
+
size
)
input_
(
nullptr
)
total_bytes_read_
(
size
)
overflow_bytes_
(
0
)
last_tag_
(
0
)
legitimate_message_end_
(
false
)
aliasing_enabled_
(
false
)
current_limit_
(
size
)
buffer_size_after_limit_
(
0
)
total_bytes_limit_
(
kDefaultTotalBytesLimit
)
recursion_budget_
(
default_recursion_limit_
)
recursion_limit_
(
default_recursion_limit_
)
extension_pool_
(
nullptr
)
extension_factory_
(
nullptr
)
{
}
inline
bool
CodedInputStream
:
:
IsFlat
(
)
const
{
return
input_
=
=
nullptr
;
}
inline
bool
CodedInputStream
:
:
Skip
(
int
count
)
{
if
(
count
<
0
)
return
false
;
const
int
original_buffer_size
=
BufferSize
(
)
;
if
(
count
<
=
original_buffer_size
)
{
Advance
(
count
)
;
return
true
;
}
return
SkipFallback
(
count
original_buffer_size
)
;
}
inline
uint8
*
CodedOutputStream
:
:
WriteVarint32ToArray
(
uint32
value
uint8
*
target
)
{
return
EpsCopyOutputStream
:
:
UnsafeVarint
(
value
target
)
;
}
inline
uint8
*
CodedOutputStream
:
:
WriteVarint64ToArray
(
uint64
value
uint8
*
target
)
{
return
EpsCopyOutputStream
:
:
UnsafeVarint
(
value
target
)
;
}
inline
void
CodedOutputStream
:
:
WriteVarint32SignExtended
(
int32
value
)
{
WriteVarint64
(
static_cast
<
uint64
>
(
value
)
)
;
}
inline
uint8
*
CodedOutputStream
:
:
WriteVarint32SignExtendedToArray
(
int32
value
uint8
*
target
)
{
return
WriteVarint64ToArray
(
static_cast
<
uint64
>
(
value
)
target
)
;
}
inline
uint8
*
CodedOutputStream
:
:
WriteLittleEndian32ToArray
(
uint32
value
uint8
*
target
)
{
#
if
defined
(
PROTOBUF_LITTLE_ENDIAN
)
memcpy
(
target
&
value
sizeof
(
value
)
)
;
#
else
target
[
0
]
=
static_cast
<
uint8
>
(
value
)
;
target
[
1
]
=
static_cast
<
uint8
>
(
value
>
>
8
)
;
target
[
2
]
=
static_cast
<
uint8
>
(
value
>
>
16
)
;
target
[
3
]
=
static_cast
<
uint8
>
(
value
>
>
24
)
;
#
endif
return
target
+
sizeof
(
value
)
;
}
inline
uint8
*
CodedOutputStream
:
:
WriteLittleEndian64ToArray
(
uint64
value
uint8
*
target
)
{
#
if
defined
(
PROTOBUF_LITTLE_ENDIAN
)
memcpy
(
target
&
value
sizeof
(
value
)
)
;
#
else
uint32
part0
=
static_cast
<
uint32
>
(
value
)
;
uint32
part1
=
static_cast
<
uint32
>
(
value
>
>
32
)
;
target
[
0
]
=
static_cast
<
uint8
>
(
part0
)
;
target
[
1
]
=
static_cast
<
uint8
>
(
part0
>
>
8
)
;
target
[
2
]
=
static_cast
<
uint8
>
(
part0
>
>
16
)
;
target
[
3
]
=
static_cast
<
uint8
>
(
part0
>
>
24
)
;
target
[
4
]
=
static_cast
<
uint8
>
(
part1
)
;
target
[
5
]
=
static_cast
<
uint8
>
(
part1
>
>
8
)
;
target
[
6
]
=
static_cast
<
uint8
>
(
part1
>
>
16
)
;
target
[
7
]
=
static_cast
<
uint8
>
(
part1
>
>
24
)
;
#
endif
return
target
+
sizeof
(
value
)
;
}
inline
void
CodedOutputStream
:
:
WriteVarint32
(
uint32
value
)
{
cur_
=
impl_
.
EnsureSpace
(
cur_
)
;
SetCur
(
WriteVarint32ToArray
(
value
Cur
(
)
)
)
;
}
inline
void
CodedOutputStream
:
:
WriteVarint64
(
uint64
value
)
{
cur_
=
impl_
.
EnsureSpace
(
cur_
)
;
SetCur
(
WriteVarint64ToArray
(
value
Cur
(
)
)
)
;
}
inline
void
CodedOutputStream
:
:
WriteTag
(
uint32
value
)
{
WriteVarint32
(
value
)
;
}
inline
uint8
*
CodedOutputStream
:
:
WriteTagToArray
(
uint32
value
uint8
*
target
)
{
return
WriteVarint32ToArray
(
value
target
)
;
}
inline
size_t
CodedOutputStream
:
:
VarintSize32
(
uint32
value
)
{
uint32
log2value
=
Bits
:
:
Log2FloorNonZero
(
value
|
0x1
)
;
return
static_cast
<
size_t
>
(
(
log2value
*
9
+
73
)
/
64
)
;
}
inline
size_t
CodedOutputStream
:
:
VarintSize64
(
uint64
value
)
{
uint32
log2value
=
Bits
:
:
Log2FloorNonZero64
(
value
|
0x1
)
;
return
static_cast
<
size_t
>
(
(
log2value
*
9
+
73
)
/
64
)
;
}
inline
size_t
CodedOutputStream
:
:
VarintSize32SignExtended
(
int32
value
)
{
if
(
value
<
0
)
{
return
10
;
}
else
{
return
VarintSize32
(
static_cast
<
uint32
>
(
value
)
)
;
}
}
inline
void
CodedOutputStream
:
:
WriteString
(
const
std
:
:
string
&
str
)
{
WriteRaw
(
str
.
data
(
)
static_cast
<
int
>
(
str
.
size
(
)
)
)
;
}
inline
void
CodedOutputStream
:
:
WriteRawMaybeAliased
(
const
void
*
data
int
size
)
{
cur_
=
impl_
.
WriteRawMaybeAliased
(
data
size
cur_
)
;
}
inline
uint8
*
CodedOutputStream
:
:
WriteRawToArray
(
const
void
*
data
int
size
uint8
*
target
)
{
memcpy
(
target
data
size
)
;
return
target
+
size
;
}
inline
uint8
*
CodedOutputStream
:
:
WriteStringToArray
(
const
std
:
:
string
&
str
uint8
*
target
)
{
return
WriteRawToArray
(
str
.
data
(
)
static_cast
<
int
>
(
str
.
size
(
)
)
target
)
;
}
}
}
}
#
if
defined
(
_MSC_VER
)
&
&
_MSC_VER
>
=
1300
&
&
!
defined
(
__INTEL_COMPILER
)
#
pragma
runtime_checks
(
"
c
"
restore
)
#
endif
#
include
<
google
/
protobuf
/
port_undef
.
inc
>
#
endif
