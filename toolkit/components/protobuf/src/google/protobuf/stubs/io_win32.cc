#
if
defined
(
_MSC_VER
)
#
define
SUPPORT_LONGPATHS
#
include
<
ctype
.
h
>
#
include
<
direct
.
h
>
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
io
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
wctype
.
h
>
#
include
<
windows
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
io_win32
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
scoped_ptr
.
h
>
#
include
<
cassert
>
#
include
<
memory
>
#
include
<
sstream
>
#
include
<
string
>
#
include
<
vector
>
namespace
google
{
namespace
protobuf
{
namespace
internal
{
namespace
win32
{
namespace
{
using
std
:
:
string
;
using
std
:
:
wstring
;
template
<
typename
char_type
>
struct
CharTraits
{
static
bool
is_alpha
(
char_type
ch
)
;
}
;
template
<
>
struct
CharTraits
<
char
>
{
static
bool
is_alpha
(
char
ch
)
{
return
isalpha
(
ch
)
;
}
}
;
template
<
>
struct
CharTraits
<
wchar_t
>
{
static
bool
is_alpha
(
wchar_t
ch
)
{
return
iswalpha
(
ch
)
;
}
}
;
template
<
typename
char_type
>
bool
has_drive_letter
(
const
char_type
*
ch
)
{
return
CharTraits
<
char_type
>
:
:
is_alpha
(
ch
[
0
]
)
&
&
ch
[
1
]
=
=
'
:
'
;
}
template
<
typename
char_type
>
bool
has_longpath_prefix
(
const
char_type
*
path
)
{
return
path
[
0
]
=
=
'
\
\
'
&
&
path
[
1
]
=
=
'
\
\
'
&
&
path
[
2
]
=
=
'
?
'
&
&
path
[
3
]
=
=
'
\
\
'
;
}
template
<
typename
char_type
>
bool
is_separator
(
char_type
c
)
{
return
c
=
=
'
/
'
|
|
c
=
=
'
\
\
'
;
}
template
<
typename
char_type
>
bool
is_path_absolute
(
const
char_type
*
path
)
{
return
has_drive_letter
(
path
)
&
&
is_separator
(
path
[
2
]
)
;
}
template
<
typename
char_type
>
bool
is_drive_relative
(
const
char_type
*
path
)
{
return
has_drive_letter
(
path
)
&
&
(
path
[
2
]
=
=
0
|
|
!
is_separator
(
path
[
2
]
)
)
;
}
template
<
typename
char_type
>
void
replace_directory_separators
(
char_type
*
p
)
{
for
(
;
*
p
;
+
+
p
)
{
if
(
*
p
=
=
'
/
'
)
{
*
p
=
'
\
\
'
;
}
}
}
string
join_paths
(
const
string
&
path1
const
string
&
path2
)
{
if
(
path1
.
empty
(
)
|
|
is_path_absolute
(
path2
.
c_str
(
)
)
|
|
has_longpath_prefix
(
path2
.
c_str
(
)
)
)
{
return
path2
;
}
if
(
path2
.
empty
(
)
)
{
return
path1
;
}
if
(
is_separator
(
path1
[
path1
.
size
(
)
-
1
]
)
)
{
return
is_separator
(
path2
[
0
]
)
?
(
path1
+
path2
.
substr
(
1
)
)
:
(
path1
+
path2
)
;
}
else
{
return
is_separator
(
path2
[
0
]
)
?
(
path1
+
path2
)
:
(
path1
+
'
\
\
'
+
path2
)
;
}
}
string
normalize
(
string
path
)
{
if
(
has_longpath_prefix
(
path
.
c_str
(
)
)
)
{
path
=
path
.
substr
(
4
)
;
}
static
const
string
dot
(
"
.
"
)
;
static
const
string
dotdot
(
"
.
.
"
)
;
std
:
:
vector
<
string
>
segments
;
int
segment_start
=
-
1
;
for
(
int
i
=
0
;
;
+
+
i
)
{
if
(
!
is_separator
(
path
[
i
]
)
&
&
path
[
i
]
!
=
'
\
0
'
)
{
if
(
segment_start
<
0
)
{
segment_start
=
i
;
}
}
else
if
(
segment_start
>
=
0
&
&
i
>
segment_start
)
{
string
segment
(
path
segment_start
i
-
segment_start
)
;
segment_start
=
-
1
;
if
(
segment
=
=
dotdot
)
{
if
(
!
segments
.
empty
(
)
&
&
(
!
has_drive_letter
(
segments
[
0
]
.
c_str
(
)
)
|
|
segments
.
size
(
)
>
1
)
)
{
segments
.
pop_back
(
)
;
}
}
else
if
(
segment
!
=
dot
&
&
!
segment
.
empty
(
)
)
{
segments
.
push_back
(
segment
)
;
}
}
if
(
path
[
i
]
=
=
'
\
0
'
)
{
break
;
}
}
if
(
segments
.
size
(
)
=
=
1
&
&
segments
[
0
]
.
size
(
)
=
=
2
&
&
has_drive_letter
(
segments
[
0
]
.
c_str
(
)
)
)
{
return
segments
[
0
]
+
'
\
\
'
;
}
bool
first
=
true
;
std
:
:
ostringstream
result
;
for
(
const
auto
&
s
:
segments
)
{
if
(
!
first
)
{
result
<
<
'
\
\
'
;
}
first
=
false
;
result
<
<
s
;
}
if
(
!
path
.
empty
(
)
&
&
is_separator
(
path
[
path
.
size
(
)
-
1
]
)
)
{
result
<
<
'
\
\
'
;
}
return
result
.
str
(
)
;
}
WCHAR
*
as_wstring
(
const
string
&
s
)
{
int
len
=
:
:
MultiByteToWideChar
(
CP_UTF8
0
s
.
c_str
(
)
s
.
size
(
)
NULL
0
)
;
WCHAR
*
result
=
new
WCHAR
[
len
+
1
]
;
:
:
MultiByteToWideChar
(
CP_UTF8
0
s
.
c_str
(
)
s
.
size
(
)
result
len
+
1
)
;
result
[
len
]
=
0
;
return
result
;
}
void
as_wchar_path
(
const
string
&
path
wstring
*
wchar_path
)
{
scoped_array
<
WCHAR
>
wbuf
(
as_wstring
(
path
)
)
;
replace_directory_separators
(
wbuf
.
get
(
)
)
;
wchar_path
-
>
assign
(
wbuf
.
get
(
)
)
;
}
bool
as_windows_path
(
const
string
&
path
wstring
*
result
)
{
if
(
path
.
empty
(
)
)
{
result
-
>
clear
(
)
;
return
true
;
}
if
(
is_separator
(
path
[
0
]
)
|
|
is_drive_relative
(
path
.
c_str
(
)
)
)
{
return
false
;
}
string
mutable_path
=
path
;
if
(
!
is_path_absolute
(
mutable_path
.
c_str
(
)
)
&
&
!
has_longpath_prefix
(
mutable_path
.
c_str
(
)
)
)
{
char
cwd
[
MAX_PATH
]
;
:
:
GetCurrentDirectoryA
(
MAX_PATH
cwd
)
;
mutable_path
=
join_paths
(
cwd
mutable_path
)
;
}
as_wchar_path
(
normalize
(
mutable_path
)
result
)
;
if
(
!
has_longpath_prefix
(
result
-
>
c_str
(
)
)
)
{
*
result
=
wstring
(
L
"
\
\
\
\
?
\
\
"
)
+
*
result
;
}
return
true
;
}
}
int
open
(
const
char
*
path
int
flags
int
mode
)
{
#
ifdef
SUPPORT_LONGPATHS
wstring
wpath
;
if
(
!
as_windows_path
(
path
&
wpath
)
)
{
errno
=
ENOENT
;
return
-
1
;
}
return
:
:
_wopen
(
wpath
.
c_str
(
)
flags
mode
)
;
#
else
return
:
:
_open
(
path
flags
mode
)
;
#
endif
}
int
mkdir
(
const
char
*
path
int
_mode
)
{
#
ifdef
SUPPORT_LONGPATHS
wstring
wpath
;
if
(
!
as_windows_path
(
path
&
wpath
)
)
{
errno
=
ENOENT
;
return
-
1
;
}
return
:
:
_wmkdir
(
wpath
.
c_str
(
)
)
;
#
else
return
:
:
_mkdir
(
path
)
;
#
endif
}
int
access
(
const
char
*
path
int
mode
)
{
#
ifdef
SUPPORT_LONGPATHS
wstring
wpath
;
if
(
!
as_windows_path
(
path
&
wpath
)
)
{
errno
=
ENOENT
;
return
-
1
;
}
return
:
:
_waccess
(
wpath
.
c_str
(
)
mode
)
;
#
else
return
:
:
_access
(
path
mode
)
;
#
endif
}
int
chdir
(
const
char
*
path
)
{
#
ifdef
SUPPORT_LONGPATHS
wstring
wpath
;
if
(
!
as_windows_path
(
path
&
wpath
)
)
{
errno
=
ENOENT
;
return
-
1
;
}
return
:
:
_wchdir
(
wpath
.
c_str
(
)
)
;
#
else
return
:
:
_chdir
(
path
)
;
#
endif
}
int
stat
(
const
char
*
path
struct
_stat
*
buffer
)
{
#
ifdef
SUPPORT_LONGPATHS
wstring
wpath
;
if
(
!
as_windows_path
(
path
&
wpath
)
)
{
errno
=
ENOENT
;
return
-
1
;
}
return
:
:
_wstat
(
wpath
.
c_str
(
)
buffer
)
;
#
else
return
:
:
_stat
(
path
buffer
)
;
#
endif
}
FILE
*
fopen
(
const
char
*
path
const
char
*
mode
)
{
#
ifdef
SUPPORT_LONGPATHS
wstring
wpath
;
if
(
!
as_windows_path
(
path
&
wpath
)
)
{
errno
=
ENOENT
;
return
NULL
;
}
scoped_array
<
WCHAR
>
wmode
(
as_wstring
(
mode
)
)
;
return
:
:
_wfopen
(
wpath
.
c_str
(
)
wmode
.
get
(
)
)
;
#
else
return
:
:
fopen
(
path
mode
)
;
#
endif
}
int
close
(
int
fd
)
{
return
:
:
close
(
fd
)
;
}
int
dup
(
int
fd
)
{
return
:
:
_dup
(
fd
)
;
}
int
dup2
(
int
fd1
int
fd2
)
{
return
:
:
_dup2
(
fd1
fd2
)
;
}
int
read
(
int
fd
void
*
buffer
size_t
size
)
{
return
:
:
_read
(
fd
buffer
size
)
;
}
int
setmode
(
int
fd
int
mode
)
{
return
:
:
_setmode
(
fd
mode
)
;
}
int
write
(
int
fd
const
void
*
buffer
size_t
size
)
{
return
:
:
_write
(
fd
buffer
size
)
;
}
wstring
testonly_path_to_winpath
(
const
string
&
path
)
{
wstring
wpath
;
as_windows_path
(
path
&
wpath
)
;
return
wpath
;
}
}
}
}
}
#
endif
