#
ifndef
GOOGLE_PROTOBUF_STUBS_STATUSOR_H_
#
define
GOOGLE_PROTOBUF_STUBS_STATUSOR_H_
#
include
<
new
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
google
/
protobuf
/
stubs
/
status
.
h
>
#
include
<
google
/
protobuf
/
port_def
.
inc
>
namespace
google
{
namespace
protobuf
{
namespace
util
{
namespace
statusor_internal
{
template
<
typename
T
>
class
StatusOr
{
template
<
typename
U
>
friend
class
StatusOr
;
public
:
using
value_type
=
T
;
explicit
StatusOr
(
)
;
StatusOr
(
const
Status
&
status
)
;
StatusOr
(
const
T
&
value
)
;
StatusOr
(
const
StatusOr
&
other
)
;
template
<
typename
U
>
StatusOr
(
const
StatusOr
<
U
>
&
other
)
;
StatusOr
&
operator
=
(
const
StatusOr
&
other
)
;
template
<
typename
U
>
StatusOr
&
operator
=
(
const
StatusOr
<
U
>
&
other
)
;
const
Status
&
status
(
)
const
;
bool
ok
(
)
const
;
const
T
&
value
(
)
const
;
private
:
Status
status_
;
T
value_
;
}
;
class
PROTOBUF_EXPORT
StatusOrHelper
{
public
:
static
void
Crash
(
const
util
:
:
Status
&
status
)
;
template
<
typename
T
>
struct
Specialize
;
}
;
template
<
typename
T
>
struct
StatusOrHelper
:
:
Specialize
{
static
inline
bool
IsValueNull
(
const
T
&
)
{
return
false
;
}
}
;
template
<
typename
T
>
struct
StatusOrHelper
:
:
Specialize
<
T
*
>
{
static
inline
bool
IsValueNull
(
const
T
*
t
)
{
return
t
=
=
nullptr
;
}
}
;
template
<
typename
T
>
inline
StatusOr
<
T
>
:
:
StatusOr
(
)
:
status_
(
util
:
:
UnknownError
(
"
"
)
)
{
}
template
<
typename
T
>
inline
StatusOr
<
T
>
:
:
StatusOr
(
const
Status
&
status
)
{
if
(
status
.
ok
(
)
)
{
status_
=
util
:
:
InternalError
(
"
OkStatus
(
)
is
not
a
valid
argument
.
"
)
;
}
else
{
status_
=
status
;
}
}
template
<
typename
T
>
inline
StatusOr
<
T
>
:
:
StatusOr
(
const
T
&
value
)
{
if
(
StatusOrHelper
:
:
Specialize
<
T
>
:
:
IsValueNull
(
value
)
)
{
status_
=
util
:
:
InternalError
(
"
nullptr
is
not
a
valid
argument
.
"
)
;
}
else
{
status_
=
util
:
:
OkStatus
(
)
;
value_
=
value
;
}
}
template
<
typename
T
>
inline
StatusOr
<
T
>
:
:
StatusOr
(
const
StatusOr
<
T
>
&
other
)
:
status_
(
other
.
status_
)
value_
(
other
.
value_
)
{
}
template
<
typename
T
>
inline
StatusOr
<
T
>
&
StatusOr
<
T
>
:
:
operator
=
(
const
StatusOr
<
T
>
&
other
)
{
status_
=
other
.
status_
;
value_
=
other
.
value_
;
return
*
this
;
}
template
<
typename
T
>
template
<
typename
U
>
inline
StatusOr
<
T
>
:
:
StatusOr
(
const
StatusOr
<
U
>
&
other
)
:
status_
(
other
.
status_
)
value_
(
other
.
status_
.
ok
(
)
?
other
.
value_
:
T
(
)
)
{
}
template
<
typename
T
>
template
<
typename
U
>
inline
StatusOr
<
T
>
&
StatusOr
<
T
>
:
:
operator
=
(
const
StatusOr
<
U
>
&
other
)
{
status_
=
other
.
status_
;
if
(
status_
.
ok
(
)
)
value_
=
other
.
value_
;
return
*
this
;
}
template
<
typename
T
>
inline
const
Status
&
StatusOr
<
T
>
:
:
status
(
)
const
{
return
status_
;
}
template
<
typename
T
>
inline
bool
StatusOr
<
T
>
:
:
ok
(
)
const
{
return
status
(
)
.
ok
(
)
;
}
template
<
typename
T
>
inline
const
T
&
StatusOr
<
T
>
:
:
value
(
)
const
{
if
(
!
status_
.
ok
(
)
)
{
StatusOrHelper
:
:
Crash
(
status_
)
;
}
return
value_
;
}
}
using
:
:
google
:
:
protobuf
:
:
util
:
:
statusor_internal
:
:
StatusOr
;
}
}
}
#
include
<
google
/
protobuf
/
port_undef
.
inc
>
#
endif
