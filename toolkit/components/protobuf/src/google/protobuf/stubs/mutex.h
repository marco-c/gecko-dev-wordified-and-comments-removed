#
ifndef
GOOGLE_PROTOBUF_STUBS_MUTEX_H_
#
define
GOOGLE_PROTOBUF_STUBS_MUTEX_H_
#
ifdef
GOOGLE_PROTOBUF_NO_THREADLOCAL
#
include
<
pthread
.
h
>
#
endif
#
include
<
google
/
protobuf
/
stubs
/
macros
.
h
>
namespace
google
{
namespace
protobuf
{
namespace
internal
{
class
LIBPROTOBUF_EXPORT
Mutex
{
public
:
Mutex
(
)
;
~
Mutex
(
)
;
void
Lock
(
)
;
void
Unlock
(
)
;
void
AssertHeld
(
)
;
private
:
struct
Internal
;
Internal
*
mInternal
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
Mutex
)
;
}
;
class
LIBPROTOBUF_EXPORT
MutexLock
{
public
:
explicit
MutexLock
(
Mutex
*
mu
)
:
mu_
(
mu
)
{
this
-
>
mu_
-
>
Lock
(
)
;
}
~
MutexLock
(
)
{
this
-
>
mu_
-
>
Unlock
(
)
;
}
private
:
Mutex
*
const
mu_
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
MutexLock
)
;
}
;
typedef
MutexLock
ReaderMutexLock
;
typedef
MutexLock
WriterMutexLock
;
class
LIBPROTOBUF_EXPORT
MutexLockMaybe
{
public
:
explicit
MutexLockMaybe
(
Mutex
*
mu
)
:
mu_
(
mu
)
{
if
(
this
-
>
mu_
!
=
NULL
)
{
this
-
>
mu_
-
>
Lock
(
)
;
}
}
~
MutexLockMaybe
(
)
{
if
(
this
-
>
mu_
!
=
NULL
)
{
this
-
>
mu_
-
>
Unlock
(
)
;
}
}
private
:
Mutex
*
const
mu_
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
MutexLockMaybe
)
;
}
;
#
if
defined
(
GOOGLE_PROTOBUF_NO_THREADLOCAL
)
template
<
typename
T
>
class
ThreadLocalStorage
{
public
:
ThreadLocalStorage
(
)
{
pthread_key_create
(
&
key_
&
ThreadLocalStorage
:
:
Delete
)
;
}
~
ThreadLocalStorage
(
)
{
pthread_key_delete
(
key_
)
;
}
T
*
Get
(
)
{
T
*
result
=
static_cast
<
T
*
>
(
pthread_getspecific
(
key_
)
)
;
if
(
result
=
=
NULL
)
{
result
=
new
T
(
)
;
pthread_setspecific
(
key_
result
)
;
}
return
result
;
}
private
:
static
void
Delete
(
void
*
value
)
{
delete
static_cast
<
T
*
>
(
value
)
;
}
pthread_key_t
key_
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
ThreadLocalStorage
)
;
}
;
#
endif
}
using
internal
:
:
Mutex
;
using
internal
:
:
MutexLock
;
using
internal
:
:
ReaderMutexLock
;
using
internal
:
:
WriterMutexLock
;
using
internal
:
:
MutexLockMaybe
;
}
}
#
endif
