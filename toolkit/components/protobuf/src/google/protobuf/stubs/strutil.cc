#
include
<
google
/
protobuf
/
stubs
/
strutil
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
mathlimits
.
h
>
#
include
<
errno
.
h
>
#
include
<
float
.
h
>
#
include
<
limits
>
#
include
<
limits
.
h
>
#
include
<
stdio
.
h
>
#
include
<
iterator
>
#
include
<
google
/
protobuf
/
stubs
/
stl_util
.
h
>
#
ifdef
_WIN32
#
define
snprintf
_snprintf
#
endif
namespace
google
{
namespace
protobuf
{
#
undef
isxdigit
#
undef
isprint
inline
bool
isxdigit
(
char
c
)
{
return
(
'
0
'
<
=
c
&
&
c
<
=
'
9
'
)
|
|
(
'
a
'
<
=
c
&
&
c
<
=
'
f
'
)
|
|
(
'
A
'
<
=
c
&
&
c
<
=
'
F
'
)
;
}
inline
bool
isprint
(
char
c
)
{
return
c
>
=
0x20
&
&
c
<
=
0x7E
;
}
void
StripString
(
string
*
s
const
char
*
remove
char
replacewith
)
{
const
char
*
str_start
=
s
-
>
c_str
(
)
;
const
char
*
str
=
str_start
;
for
(
str
=
strpbrk
(
str
remove
)
;
str
!
=
NULL
;
str
=
strpbrk
(
str
+
1
remove
)
)
{
(
*
s
)
[
str
-
str_start
]
=
replacewith
;
}
}
void
ReplaceCharacters
(
string
*
s
const
char
*
remove
char
replacewith
)
{
const
char
*
str_start
=
s
-
>
c_str
(
)
;
const
char
*
str
=
str_start
;
for
(
str
=
strpbrk
(
str
remove
)
;
str
!
=
NULL
;
str
=
strpbrk
(
str
+
1
remove
)
)
{
(
*
s
)
[
str
-
str_start
]
=
replacewith
;
}
}
void
StripWhitespace
(
string
*
str
)
{
int
str_length
=
str
-
>
length
(
)
;
int
first
=
0
;
while
(
first
<
str_length
&
&
ascii_isspace
(
str
-
>
at
(
first
)
)
)
{
+
+
first
;
}
if
(
first
=
=
str_length
)
{
str
-
>
clear
(
)
;
return
;
}
if
(
first
>
0
)
{
str
-
>
erase
(
0
first
)
;
str_length
-
=
first
;
}
int
last
=
str_length
-
1
;
while
(
last
>
=
0
&
&
ascii_isspace
(
str
-
>
at
(
last
)
)
)
{
-
-
last
;
}
if
(
last
!
=
(
str_length
-
1
)
&
&
last
>
=
0
)
{
str
-
>
erase
(
last
+
1
string
:
:
npos
)
;
}
}
void
StringReplace
(
const
string
&
s
const
string
&
oldsub
const
string
&
newsub
bool
replace_all
string
*
res
)
{
if
(
oldsub
.
empty
(
)
)
{
res
-
>
append
(
s
)
;
return
;
}
string
:
:
size_type
start_pos
=
0
;
string
:
:
size_type
pos
;
do
{
pos
=
s
.
find
(
oldsub
start_pos
)
;
if
(
pos
=
=
string
:
:
npos
)
{
break
;
}
res
-
>
append
(
s
start_pos
pos
-
start_pos
)
;
res
-
>
append
(
newsub
)
;
start_pos
=
pos
+
oldsub
.
size
(
)
;
}
while
(
replace_all
)
;
res
-
>
append
(
s
start_pos
s
.
length
(
)
-
start_pos
)
;
}
string
StringReplace
(
const
string
&
s
const
string
&
oldsub
const
string
&
newsub
bool
replace_all
)
{
string
ret
;
StringReplace
(
s
oldsub
newsub
replace_all
&
ret
)
;
return
ret
;
}
template
<
typename
ITR
>
static
inline
void
SplitStringToIteratorUsing
(
const
string
&
full
const
char
*
delim
ITR
&
result
)
{
if
(
delim
[
0
]
!
=
'
\
0
'
&
&
delim
[
1
]
=
=
'
\
0
'
)
{
char
c
=
delim
[
0
]
;
const
char
*
p
=
full
.
data
(
)
;
const
char
*
end
=
p
+
full
.
size
(
)
;
while
(
p
!
=
end
)
{
if
(
*
p
=
=
c
)
{
+
+
p
;
}
else
{
const
char
*
start
=
p
;
while
(
+
+
p
!
=
end
&
&
*
p
!
=
c
)
;
*
result
+
+
=
string
(
start
p
-
start
)
;
}
}
return
;
}
string
:
:
size_type
begin_index
end_index
;
begin_index
=
full
.
find_first_not_of
(
delim
)
;
while
(
begin_index
!
=
string
:
:
npos
)
{
end_index
=
full
.
find_first_of
(
delim
begin_index
)
;
if
(
end_index
=
=
string
:
:
npos
)
{
*
result
+
+
=
full
.
substr
(
begin_index
)
;
return
;
}
*
result
+
+
=
full
.
substr
(
begin_index
(
end_index
-
begin_index
)
)
;
begin_index
=
full
.
find_first_not_of
(
delim
end_index
)
;
}
}
void
SplitStringUsing
(
const
string
&
full
const
char
*
delim
vector
<
string
>
*
result
)
{
std
:
:
back_insert_iterator
<
vector
<
string
>
>
it
(
*
result
)
;
SplitStringToIteratorUsing
(
full
delim
it
)
;
}
template
<
typename
StringType
typename
ITR
>
static
inline
void
SplitStringToIteratorAllowEmpty
(
const
StringType
&
full
const
char
*
delim
int
pieces
ITR
&
result
)
{
string
:
:
size_type
begin_index
end_index
;
begin_index
=
0
;
for
(
int
i
=
0
;
(
i
<
pieces
-
1
)
|
|
(
pieces
=
=
0
)
;
i
+
+
)
{
end_index
=
full
.
find_first_of
(
delim
begin_index
)
;
if
(
end_index
=
=
string
:
:
npos
)
{
*
result
+
+
=
full
.
substr
(
begin_index
)
;
return
;
}
*
result
+
+
=
full
.
substr
(
begin_index
(
end_index
-
begin_index
)
)
;
begin_index
=
end_index
+
1
;
}
*
result
+
+
=
full
.
substr
(
begin_index
)
;
}
void
SplitStringAllowEmpty
(
const
string
&
full
const
char
*
delim
vector
<
string
>
*
result
)
{
std
:
:
back_insert_iterator
<
vector
<
string
>
>
it
(
*
result
)
;
SplitStringToIteratorAllowEmpty
(
full
delim
0
it
)
;
}
template
<
class
ITERATOR
>
static
void
JoinStringsIterator
(
const
ITERATOR
&
start
const
ITERATOR
&
end
const
char
*
delim
string
*
result
)
{
GOOGLE_CHECK
(
result
!
=
NULL
)
;
result
-
>
clear
(
)
;
int
delim_length
=
strlen
(
delim
)
;
int
length
=
0
;
for
(
ITERATOR
iter
=
start
;
iter
!
=
end
;
+
+
iter
)
{
if
(
iter
!
=
start
)
{
length
+
=
delim_length
;
}
length
+
=
iter
-
>
size
(
)
;
}
result
-
>
reserve
(
length
)
;
for
(
ITERATOR
iter
=
start
;
iter
!
=
end
;
+
+
iter
)
{
if
(
iter
!
=
start
)
{
result
-
>
append
(
delim
delim_length
)
;
}
result
-
>
append
(
iter
-
>
data
(
)
iter
-
>
size
(
)
)
;
}
}
void
JoinStrings
(
const
vector
<
string
>
&
components
const
char
*
delim
string
*
result
)
{
JoinStringsIterator
(
components
.
begin
(
)
components
.
end
(
)
delim
result
)
;
}
#
define
IS_OCTAL_DIGIT
(
c
)
(
(
(
c
)
>
=
'
0
'
)
&
&
(
(
c
)
<
=
'
7
'
)
)
#
define
LOG_STRING
(
LEVEL
VECTOR
)
GOOGLE_LOG_IF
(
LEVEL
false
)
int
UnescapeCEscapeSequences
(
const
char
*
source
char
*
dest
)
{
return
UnescapeCEscapeSequences
(
source
dest
NULL
)
;
}
int
UnescapeCEscapeSequences
(
const
char
*
source
char
*
dest
vector
<
string
>
*
errors
)
{
GOOGLE_DCHECK
(
errors
=
=
NULL
)
<
<
"
Error
reporting
not
implemented
.
"
;
char
*
d
=
dest
;
const
char
*
p
=
source
;
while
(
p
=
=
d
&
&
*
p
!
=
'
\
0
'
&
&
*
p
!
=
'
\
\
'
)
p
+
+
d
+
+
;
while
(
*
p
!
=
'
\
0
'
)
{
if
(
*
p
!
=
'
\
\
'
)
{
*
d
+
+
=
*
p
+
+
;
}
else
{
switch
(
*
+
+
p
)
{
case
'
\
0
'
:
LOG_STRING
(
ERROR
errors
)
<
<
"
String
cannot
end
with
\
\
"
;
*
d
=
'
\
0
'
;
return
d
-
dest
;
case
'
a
'
:
*
d
+
+
=
'
\
a
'
;
break
;
case
'
b
'
:
*
d
+
+
=
'
\
b
'
;
break
;
case
'
f
'
:
*
d
+
+
=
'
\
f
'
;
break
;
case
'
n
'
:
*
d
+
+
=
'
\
n
'
;
break
;
case
'
r
'
:
*
d
+
+
=
'
\
r
'
;
break
;
case
'
t
'
:
*
d
+
+
=
'
\
t
'
;
break
;
case
'
v
'
:
*
d
+
+
=
'
\
v
'
;
break
;
case
'
\
\
'
:
*
d
+
+
=
'
\
\
'
;
break
;
case
'
?
'
:
*
d
+
+
=
'
\
?
'
;
break
;
case
'
\
'
'
:
*
d
+
+
=
'
\
'
'
;
break
;
case
'
"
'
:
*
d
+
+
=
'
\
"
'
;
break
;
case
'
0
'
:
case
'
1
'
:
case
'
2
'
:
case
'
3
'
:
case
'
4
'
:
case
'
5
'
:
case
'
6
'
:
case
'
7
'
:
{
char
ch
=
*
p
-
'
0
'
;
if
(
IS_OCTAL_DIGIT
(
p
[
1
]
)
)
ch
=
ch
*
8
+
*
+
+
p
-
'
0
'
;
if
(
IS_OCTAL_DIGIT
(
p
[
1
]
)
)
ch
=
ch
*
8
+
*
+
+
p
-
'
0
'
;
*
d
+
+
=
ch
;
break
;
}
case
'
x
'
:
case
'
X
'
:
{
if
(
!
isxdigit
(
p
[
1
]
)
)
{
if
(
p
[
1
]
=
=
'
\
0
'
)
{
LOG_STRING
(
ERROR
errors
)
<
<
"
String
cannot
end
with
\
\
x
"
;
}
else
{
LOG_STRING
(
ERROR
errors
)
<
<
"
\
\
x
cannot
be
followed
by
non
-
hex
digit
:
\
\
"
<
<
*
p
<
<
p
[
1
]
;
}
break
;
}
unsigned
int
ch
=
0
;
const
char
*
hex_start
=
p
;
while
(
isxdigit
(
p
[
1
]
)
)
ch
=
(
ch
<
<
4
)
+
hex_digit_to_int
(
*
+
+
p
)
;
if
(
ch
>
0xFF
)
LOG_STRING
(
ERROR
errors
)
<
<
"
Value
of
"
<
<
"
\
\
"
<
<
string
(
hex_start
p
+
1
-
hex_start
)
<
<
"
exceeds
8
bits
"
;
*
d
+
+
=
ch
;
break
;
}
#
if
0
case
'
u
'
:
{
char32
rune
=
0
;
const
char
*
hex_start
=
p
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
if
(
isxdigit
(
p
[
1
]
)
)
{
rune
=
(
rune
<
<
4
)
+
hex_digit_to_int
(
*
+
+
p
)
;
}
else
{
LOG_STRING
(
ERROR
errors
)
<
<
"
\
\
u
must
be
followed
by
4
hex
digits
:
\
\
"
<
<
string
(
hex_start
p
+
1
-
hex_start
)
;
break
;
}
}
d
+
=
runetochar
(
d
&
rune
)
;
break
;
}
case
'
U
'
:
{
char32
rune
=
0
;
const
char
*
hex_start
=
p
;
for
(
int
i
=
0
;
i
<
8
;
+
+
i
)
{
if
(
isxdigit
(
p
[
1
]
)
)
{
char32
newrune
=
(
rune
<
<
4
)
+
hex_digit_to_int
(
*
+
+
p
)
;
if
(
newrune
>
0x10FFFF
)
{
LOG_STRING
(
ERROR
errors
)
<
<
"
Value
of
\
\
"
<
<
string
(
hex_start
p
+
1
-
hex_start
)
<
<
"
exceeds
Unicode
limit
(
0x10FFFF
)
"
;
break
;
}
else
{
rune
=
newrune
;
}
}
else
{
LOG_STRING
(
ERROR
errors
)
<
<
"
\
\
U
must
be
followed
by
8
hex
digits
:
\
\
"
<
<
string
(
hex_start
p
+
1
-
hex_start
)
;
break
;
}
}
d
+
=
runetochar
(
d
&
rune
)
;
break
;
}
#
endif
default
:
LOG_STRING
(
ERROR
errors
)
<
<
"
Unknown
escape
sequence
:
\
\
"
<
<
*
p
;
}
p
+
+
;
}
}
*
d
=
'
\
0
'
;
return
d
-
dest
;
}
int
UnescapeCEscapeString
(
const
string
&
src
string
*
dest
)
{
return
UnescapeCEscapeString
(
src
dest
NULL
)
;
}
int
UnescapeCEscapeString
(
const
string
&
src
string
*
dest
vector
<
string
>
*
errors
)
{
scoped_array
<
char
>
unescaped
(
new
char
[
src
.
size
(
)
+
1
]
)
;
int
len
=
UnescapeCEscapeSequences
(
src
.
c_str
(
)
unescaped
.
get
(
)
errors
)
;
GOOGLE_CHECK
(
dest
)
;
dest
-
>
assign
(
unescaped
.
get
(
)
len
)
;
return
len
;
}
string
UnescapeCEscapeString
(
const
string
&
src
)
{
scoped_array
<
char
>
unescaped
(
new
char
[
src
.
size
(
)
+
1
]
)
;
int
len
=
UnescapeCEscapeSequences
(
src
.
c_str
(
)
unescaped
.
get
(
)
NULL
)
;
return
string
(
unescaped
.
get
(
)
len
)
;
}
int
CEscapeInternal
(
const
char
*
src
int
src_len
char
*
dest
int
dest_len
bool
use_hex
bool
utf8_safe
)
{
const
char
*
src_end
=
src
+
src_len
;
int
used
=
0
;
bool
last_hex_escape
=
false
;
for
(
;
src
<
src_end
;
src
+
+
)
{
if
(
dest_len
-
used
<
2
)
return
-
1
;
bool
is_hex_escape
=
false
;
switch
(
*
src
)
{
case
'
\
n
'
:
dest
[
used
+
+
]
=
'
\
\
'
;
dest
[
used
+
+
]
=
'
n
'
;
break
;
case
'
\
r
'
:
dest
[
used
+
+
]
=
'
\
\
'
;
dest
[
used
+
+
]
=
'
r
'
;
break
;
case
'
\
t
'
:
dest
[
used
+
+
]
=
'
\
\
'
;
dest
[
used
+
+
]
=
'
t
'
;
break
;
case
'
\
"
'
:
dest
[
used
+
+
]
=
'
\
\
'
;
dest
[
used
+
+
]
=
'
\
"
'
;
break
;
case
'
\
'
'
:
dest
[
used
+
+
]
=
'
\
\
'
;
dest
[
used
+
+
]
=
'
\
'
'
;
break
;
case
'
\
\
'
:
dest
[
used
+
+
]
=
'
\
\
'
;
dest
[
used
+
+
]
=
'
\
\
'
;
break
;
default
:
if
(
(
!
utf8_safe
|
|
static_cast
<
uint8
>
(
*
src
)
<
0x80
)
&
&
(
!
isprint
(
*
src
)
|
|
(
last_hex_escape
&
&
isxdigit
(
*
src
)
)
)
)
{
if
(
dest_len
-
used
<
4
)
return
-
1
;
sprintf
(
dest
+
used
(
use_hex
?
"
\
\
x
%
02x
"
:
"
\
\
%
03o
"
)
static_cast
<
uint8
>
(
*
src
)
)
;
is_hex_escape
=
use_hex
;
used
+
=
4
;
}
else
{
dest
[
used
+
+
]
=
*
src
;
break
;
}
}
last_hex_escape
=
is_hex_escape
;
}
if
(
dest_len
-
used
<
1
)
return
-
1
;
dest
[
used
]
=
'
\
0
'
;
return
used
;
}
static
inline
size_t
CEscapedLength
(
StringPiece
src
)
{
static
char
c_escaped_len
[
256
]
=
{
4
4
4
4
4
4
4
4
4
2
2
4
4
2
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
1
1
2
1
1
1
1
2
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
2
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
}
;
size_t
escaped_len
=
0
;
for
(
int
i
=
0
;
i
<
src
.
size
(
)
;
+
+
i
)
{
unsigned
char
c
=
static_cast
<
unsigned
char
>
(
src
[
i
]
)
;
escaped_len
+
=
c_escaped_len
[
c
]
;
}
return
escaped_len
;
}
void
CEscapeAndAppend
(
StringPiece
src
string
*
dest
)
{
size_t
escaped_len
=
CEscapedLength
(
src
)
;
if
(
escaped_len
=
=
src
.
size
(
)
)
{
dest
-
>
append
(
src
.
data
(
)
src
.
size
(
)
)
;
return
;
}
size_t
cur_dest_len
=
dest
-
>
size
(
)
;
dest
-
>
resize
(
cur_dest_len
+
escaped_len
)
;
char
*
append_ptr
=
&
(
*
dest
)
[
cur_dest_len
]
;
for
(
int
i
=
0
;
i
<
src
.
size
(
)
;
+
+
i
)
{
unsigned
char
c
=
static_cast
<
unsigned
char
>
(
src
[
i
]
)
;
switch
(
c
)
{
case
'
\
n
'
:
*
append_ptr
+
+
=
'
\
\
'
;
*
append_ptr
+
+
=
'
n
'
;
break
;
case
'
\
r
'
:
*
append_ptr
+
+
=
'
\
\
'
;
*
append_ptr
+
+
=
'
r
'
;
break
;
case
'
\
t
'
:
*
append_ptr
+
+
=
'
\
\
'
;
*
append_ptr
+
+
=
'
t
'
;
break
;
case
'
\
"
'
:
*
append_ptr
+
+
=
'
\
\
'
;
*
append_ptr
+
+
=
'
\
"
'
;
break
;
case
'
\
'
'
:
*
append_ptr
+
+
=
'
\
\
'
;
*
append_ptr
+
+
=
'
\
'
'
;
break
;
case
'
\
\
'
:
*
append_ptr
+
+
=
'
\
\
'
;
*
append_ptr
+
+
=
'
\
\
'
;
break
;
default
:
if
(
!
isprint
(
c
)
)
{
*
append_ptr
+
+
=
'
\
\
'
;
*
append_ptr
+
+
=
'
0
'
+
c
/
64
;
*
append_ptr
+
+
=
'
0
'
+
(
c
%
64
)
/
8
;
*
append_ptr
+
+
=
'
0
'
+
c
%
8
;
}
else
{
*
append_ptr
+
+
=
c
;
}
break
;
}
}
}
string
CEscape
(
const
string
&
src
)
{
string
dest
;
CEscapeAndAppend
(
src
&
dest
)
;
return
dest
;
}
namespace
strings
{
string
Utf8SafeCEscape
(
const
string
&
src
)
{
const
int
dest_length
=
src
.
size
(
)
*
4
+
1
;
scoped_array
<
char
>
dest
(
new
char
[
dest_length
]
)
;
const
int
len
=
CEscapeInternal
(
src
.
data
(
)
src
.
size
(
)
dest
.
get
(
)
dest_length
false
true
)
;
GOOGLE_DCHECK_GE
(
len
0
)
;
return
string
(
dest
.
get
(
)
len
)
;
}
string
CHexEscape
(
const
string
&
src
)
{
const
int
dest_length
=
src
.
size
(
)
*
4
+
1
;
scoped_array
<
char
>
dest
(
new
char
[
dest_length
]
)
;
const
int
len
=
CEscapeInternal
(
src
.
data
(
)
src
.
size
(
)
dest
.
get
(
)
dest_length
true
false
)
;
GOOGLE_DCHECK_GE
(
len
0
)
;
return
string
(
dest
.
get
(
)
len
)
;
}
}
int32
strto32_adaptor
(
const
char
*
nptr
char
*
*
endptr
int
base
)
{
const
int
saved_errno
=
errno
;
errno
=
0
;
const
long
result
=
strtol
(
nptr
endptr
base
)
;
if
(
errno
=
=
ERANGE
&
&
result
=
=
LONG_MIN
)
{
return
kint32min
;
}
else
if
(
errno
=
=
ERANGE
&
&
result
=
=
LONG_MAX
)
{
return
kint32max
;
}
else
if
(
errno
=
=
0
&
&
result
<
kint32min
)
{
errno
=
ERANGE
;
return
kint32min
;
}
else
if
(
errno
=
=
0
&
&
result
>
kint32max
)
{
errno
=
ERANGE
;
return
kint32max
;
}
if
(
errno
=
=
0
)
errno
=
saved_errno
;
return
static_cast
<
int32
>
(
result
)
;
}
uint32
strtou32_adaptor
(
const
char
*
nptr
char
*
*
endptr
int
base
)
{
const
int
saved_errno
=
errno
;
errno
=
0
;
const
unsigned
long
result
=
strtoul
(
nptr
endptr
base
)
;
if
(
errno
=
=
ERANGE
&
&
result
=
=
ULONG_MAX
)
{
return
kuint32max
;
}
else
if
(
errno
=
=
0
&
&
result
>
kuint32max
)
{
errno
=
ERANGE
;
return
kuint32max
;
}
if
(
errno
=
=
0
)
errno
=
saved_errno
;
return
static_cast
<
uint32
>
(
result
)
;
}
inline
bool
safe_parse_sign
(
string
*
text
bool
*
negative_ptr
)
{
const
char
*
start
=
text
-
>
data
(
)
;
const
char
*
end
=
start
+
text
-
>
size
(
)
;
while
(
start
<
end
&
&
(
start
[
0
]
=
=
'
'
)
)
{
+
+
start
;
}
while
(
start
<
end
&
&
(
end
[
-
1
]
=
=
'
'
)
)
{
-
-
end
;
}
if
(
start
>
=
end
)
{
return
false
;
}
*
negative_ptr
=
(
start
[
0
]
=
=
'
-
'
)
;
if
(
*
negative_ptr
|
|
start
[
0
]
=
=
'
+
'
)
{
+
+
start
;
if
(
start
>
=
end
)
{
return
false
;
}
}
*
text
=
text
-
>
substr
(
start
-
text
-
>
data
(
)
end
-
start
)
;
return
true
;
}
template
<
typename
IntType
>
bool
safe_parse_positive_int
(
string
text
IntType
*
value_p
)
{
int
base
=
10
;
IntType
value
=
0
;
const
IntType
vmax
=
std
:
:
numeric_limits
<
IntType
>
:
:
max
(
)
;
assert
(
vmax
>
0
)
;
assert
(
vmax
>
=
base
)
;
const
IntType
vmax_over_base
=
vmax
/
base
;
const
char
*
start
=
text
.
data
(
)
;
const
char
*
end
=
start
+
text
.
size
(
)
;
for
(
;
start
<
end
;
+
+
start
)
{
unsigned
char
c
=
static_cast
<
unsigned
char
>
(
start
[
0
]
)
;
int
digit
=
c
-
'
0
'
;
if
(
digit
>
=
base
|
|
digit
<
0
)
{
*
value_p
=
value
;
return
false
;
}
if
(
value
>
vmax_over_base
)
{
*
value_p
=
vmax
;
return
false
;
}
value
*
=
base
;
if
(
value
>
vmax
-
digit
)
{
*
value_p
=
vmax
;
return
false
;
}
value
+
=
digit
;
}
*
value_p
=
value
;
return
true
;
}
template
<
typename
IntType
>
bool
safe_parse_negative_int
(
const
string
&
text
IntType
*
value_p
)
{
int
base
=
10
;
IntType
value
=
0
;
const
IntType
vmin
=
std
:
:
numeric_limits
<
IntType
>
:
:
min
(
)
;
assert
(
vmin
<
0
)
;
assert
(
vmin
<
=
0
-
base
)
;
IntType
vmin_over_base
=
vmin
/
base
;
if
(
vmin
%
base
>
0
)
{
vmin_over_base
+
=
1
;
}
const
char
*
start
=
text
.
data
(
)
;
const
char
*
end
=
start
+
text
.
size
(
)
;
for
(
;
start
<
end
;
+
+
start
)
{
unsigned
char
c
=
static_cast
<
unsigned
char
>
(
start
[
0
]
)
;
int
digit
=
c
-
'
0
'
;
if
(
digit
>
=
base
|
|
digit
<
0
)
{
*
value_p
=
value
;
return
false
;
}
if
(
value
<
vmin_over_base
)
{
*
value_p
=
vmin
;
return
false
;
}
value
*
=
base
;
if
(
value
<
vmin
+
digit
)
{
*
value_p
=
vmin
;
return
false
;
}
value
-
=
digit
;
}
*
value_p
=
value
;
return
true
;
}
template
<
typename
IntType
>
bool
safe_int_internal
(
string
text
IntType
*
value_p
)
{
*
value_p
=
0
;
bool
negative
;
if
(
!
safe_parse_sign
(
&
text
&
negative
)
)
{
return
false
;
}
if
(
!
negative
)
{
return
safe_parse_positive_int
(
text
value_p
)
;
}
else
{
return
safe_parse_negative_int
(
text
value_p
)
;
}
}
template
<
typename
IntType
>
bool
safe_uint_internal
(
string
text
IntType
*
value_p
)
{
*
value_p
=
0
;
bool
negative
;
if
(
!
safe_parse_sign
(
&
text
&
negative
)
|
|
negative
)
{
return
false
;
}
return
safe_parse_positive_int
(
text
value_p
)
;
}
static
const
int
kFastInt64ToBufferOffset
=
21
;
char
*
FastInt64ToBuffer
(
int64
i
char
*
buffer
)
{
char
*
p
=
buffer
+
kFastInt64ToBufferOffset
;
*
p
-
-
=
'
\
0
'
;
if
(
i
>
=
0
)
{
do
{
*
p
-
-
=
'
0
'
+
i
%
10
;
i
/
=
10
;
}
while
(
i
>
0
)
;
return
p
+
1
;
}
else
{
if
(
i
>
-
10
)
{
i
=
-
i
;
*
p
-
-
=
'
0
'
+
i
;
*
p
=
'
-
'
;
return
p
;
}
else
{
i
=
i
+
10
;
i
=
-
i
;
*
p
-
-
=
'
0
'
+
i
%
10
;
i
=
i
/
10
+
1
;
do
{
*
p
-
-
=
'
0
'
+
i
%
10
;
i
/
=
10
;
}
while
(
i
>
0
)
;
*
p
=
'
-
'
;
return
p
;
}
}
}
static
const
int
kFastInt32ToBufferOffset
=
11
;
char
*
FastInt32ToBuffer
(
int32
i
char
*
buffer
)
{
char
*
p
=
buffer
+
kFastInt32ToBufferOffset
;
*
p
-
-
=
'
\
0
'
;
if
(
i
>
=
0
)
{
do
{
*
p
-
-
=
'
0
'
+
i
%
10
;
i
/
=
10
;
}
while
(
i
>
0
)
;
return
p
+
1
;
}
else
{
if
(
i
>
-
10
)
{
i
=
-
i
;
*
p
-
-
=
'
0
'
+
i
;
*
p
=
'
-
'
;
return
p
;
}
else
{
i
=
i
+
10
;
i
=
-
i
;
*
p
-
-
=
'
0
'
+
i
%
10
;
i
=
i
/
10
+
1
;
do
{
*
p
-
-
=
'
0
'
+
i
%
10
;
i
/
=
10
;
}
while
(
i
>
0
)
;
*
p
=
'
-
'
;
return
p
;
}
}
}
char
*
FastHexToBuffer
(
int
i
char
*
buffer
)
{
GOOGLE_CHECK
(
i
>
=
0
)
<
<
"
FastHexToBuffer
(
)
wants
non
-
negative
integers
not
"
<
<
i
;
static
const
char
*
hexdigits
=
"
0123456789abcdef
"
;
char
*
p
=
buffer
+
21
;
*
p
-
-
=
'
\
0
'
;
do
{
*
p
-
-
=
hexdigits
[
i
&
15
]
;
i
>
>
=
4
;
}
while
(
i
>
0
)
;
return
p
+
1
;
}
char
*
InternalFastHexToBuffer
(
uint64
value
char
*
buffer
int
num_byte
)
{
static
const
char
*
hexdigits
=
"
0123456789abcdef
"
;
buffer
[
num_byte
]
=
'
\
0
'
;
for
(
int
i
=
num_byte
-
1
;
i
>
=
0
;
i
-
-
)
{
#
ifdef
_M_X64
buffer
[
i
]
=
hexdigits
[
value
&
0xf
]
;
#
else
buffer
[
i
]
=
hexdigits
[
uint32
(
value
)
&
0xf
]
;
#
endif
value
>
>
=
4
;
}
return
buffer
;
}
char
*
FastHex64ToBuffer
(
uint64
value
char
*
buffer
)
{
return
InternalFastHexToBuffer
(
value
buffer
16
)
;
}
char
*
FastHex32ToBuffer
(
uint32
value
char
*
buffer
)
{
return
InternalFastHexToBuffer
(
value
buffer
8
)
;
}
static
const
char
two_ASCII_digits
[
100
]
[
2
]
=
{
{
'
0
'
'
0
'
}
{
'
0
'
'
1
'
}
{
'
0
'
'
2
'
}
{
'
0
'
'
3
'
}
{
'
0
'
'
4
'
}
{
'
0
'
'
5
'
}
{
'
0
'
'
6
'
}
{
'
0
'
'
7
'
}
{
'
0
'
'
8
'
}
{
'
0
'
'
9
'
}
{
'
1
'
'
0
'
}
{
'
1
'
'
1
'
}
{
'
1
'
'
2
'
}
{
'
1
'
'
3
'
}
{
'
1
'
'
4
'
}
{
'
1
'
'
5
'
}
{
'
1
'
'
6
'
}
{
'
1
'
'
7
'
}
{
'
1
'
'
8
'
}
{
'
1
'
'
9
'
}
{
'
2
'
'
0
'
}
{
'
2
'
'
1
'
}
{
'
2
'
'
2
'
}
{
'
2
'
'
3
'
}
{
'
2
'
'
4
'
}
{
'
2
'
'
5
'
}
{
'
2
'
'
6
'
}
{
'
2
'
'
7
'
}
{
'
2
'
'
8
'
}
{
'
2
'
'
9
'
}
{
'
3
'
'
0
'
}
{
'
3
'
'
1
'
}
{
'
3
'
'
2
'
}
{
'
3
'
'
3
'
}
{
'
3
'
'
4
'
}
{
'
3
'
'
5
'
}
{
'
3
'
'
6
'
}
{
'
3
'
'
7
'
}
{
'
3
'
'
8
'
}
{
'
3
'
'
9
'
}
{
'
4
'
'
0
'
}
{
'
4
'
'
1
'
}
{
'
4
'
'
2
'
}
{
'
4
'
'
3
'
}
{
'
4
'
'
4
'
}
{
'
4
'
'
5
'
}
{
'
4
'
'
6
'
}
{
'
4
'
'
7
'
}
{
'
4
'
'
8
'
}
{
'
4
'
'
9
'
}
{
'
5
'
'
0
'
}
{
'
5
'
'
1
'
}
{
'
5
'
'
2
'
}
{
'
5
'
'
3
'
}
{
'
5
'
'
4
'
}
{
'
5
'
'
5
'
}
{
'
5
'
'
6
'
}
{
'
5
'
'
7
'
}
{
'
5
'
'
8
'
}
{
'
5
'
'
9
'
}
{
'
6
'
'
0
'
}
{
'
6
'
'
1
'
}
{
'
6
'
'
2
'
}
{
'
6
'
'
3
'
}
{
'
6
'
'
4
'
}
{
'
6
'
'
5
'
}
{
'
6
'
'
6
'
}
{
'
6
'
'
7
'
}
{
'
6
'
'
8
'
}
{
'
6
'
'
9
'
}
{
'
7
'
'
0
'
}
{
'
7
'
'
1
'
}
{
'
7
'
'
2
'
}
{
'
7
'
'
3
'
}
{
'
7
'
'
4
'
}
{
'
7
'
'
5
'
}
{
'
7
'
'
6
'
}
{
'
7
'
'
7
'
}
{
'
7
'
'
8
'
}
{
'
7
'
'
9
'
}
{
'
8
'
'
0
'
}
{
'
8
'
'
1
'
}
{
'
8
'
'
2
'
}
{
'
8
'
'
3
'
}
{
'
8
'
'
4
'
}
{
'
8
'
'
5
'
}
{
'
8
'
'
6
'
}
{
'
8
'
'
7
'
}
{
'
8
'
'
8
'
}
{
'
8
'
'
9
'
}
{
'
9
'
'
0
'
}
{
'
9
'
'
1
'
}
{
'
9
'
'
2
'
}
{
'
9
'
'
3
'
}
{
'
9
'
'
4
'
}
{
'
9
'
'
5
'
}
{
'
9
'
'
6
'
}
{
'
9
'
'
7
'
}
{
'
9
'
'
8
'
}
{
'
9
'
'
9
'
}
}
;
char
*
FastUInt32ToBufferLeft
(
uint32
u
char
*
buffer
)
{
uint32
digits
;
const
char
*
ASCII_digits
=
NULL
;
if
(
u
>
=
1000000000
)
{
digits
=
u
/
100000000
;
ASCII_digits
=
two_ASCII_digits
[
digits
]
;
buffer
[
0
]
=
ASCII_digits
[
0
]
;
buffer
[
1
]
=
ASCII_digits
[
1
]
;
buffer
+
=
2
;
sublt100_000_000
:
u
-
=
digits
*
100000000
;
lt100_000_000
:
digits
=
u
/
1000000
;
ASCII_digits
=
two_ASCII_digits
[
digits
]
;
buffer
[
0
]
=
ASCII_digits
[
0
]
;
buffer
[
1
]
=
ASCII_digits
[
1
]
;
buffer
+
=
2
;
sublt1_000_000
:
u
-
=
digits
*
1000000
;
lt1_000_000
:
digits
=
u
/
10000
;
ASCII_digits
=
two_ASCII_digits
[
digits
]
;
buffer
[
0
]
=
ASCII_digits
[
0
]
;
buffer
[
1
]
=
ASCII_digits
[
1
]
;
buffer
+
=
2
;
sublt10_000
:
u
-
=
digits
*
10000
;
lt10_000
:
digits
=
u
/
100
;
ASCII_digits
=
two_ASCII_digits
[
digits
]
;
buffer
[
0
]
=
ASCII_digits
[
0
]
;
buffer
[
1
]
=
ASCII_digits
[
1
]
;
buffer
+
=
2
;
sublt100
:
u
-
=
digits
*
100
;
lt100
:
digits
=
u
;
ASCII_digits
=
two_ASCII_digits
[
digits
]
;
buffer
[
0
]
=
ASCII_digits
[
0
]
;
buffer
[
1
]
=
ASCII_digits
[
1
]
;
buffer
+
=
2
;
done
:
*
buffer
=
0
;
return
buffer
;
}
if
(
u
<
100
)
{
digits
=
u
;
if
(
u
>
=
10
)
goto
lt100
;
*
buffer
+
+
=
'
0
'
+
digits
;
goto
done
;
}
if
(
u
<
10000
)
{
if
(
u
>
=
1000
)
goto
lt10_000
;
digits
=
u
/
100
;
*
buffer
+
+
=
'
0
'
+
digits
;
goto
sublt100
;
}
if
(
u
<
1000000
)
{
if
(
u
>
=
100000
)
goto
lt1_000_000
;
digits
=
u
/
10000
;
*
buffer
+
+
=
'
0
'
+
digits
;
goto
sublt10_000
;
}
if
(
u
<
100000000
)
{
if
(
u
>
=
10000000
)
goto
lt100_000_000
;
digits
=
u
/
1000000
;
*
buffer
+
+
=
'
0
'
+
digits
;
goto
sublt1_000_000
;
}
digits
=
u
/
100000000
;
*
buffer
+
+
=
'
0
'
+
digits
;
goto
sublt100_000_000
;
}
char
*
FastInt32ToBufferLeft
(
int32
i
char
*
buffer
)
{
uint32
u
=
i
;
if
(
i
<
0
)
{
*
buffer
+
+
=
'
-
'
;
u
=
-
i
;
}
return
FastUInt32ToBufferLeft
(
u
buffer
)
;
}
char
*
FastUInt64ToBufferLeft
(
uint64
u64
char
*
buffer
)
{
int
digits
;
const
char
*
ASCII_digits
=
NULL
;
uint32
u
=
static_cast
<
uint32
>
(
u64
)
;
if
(
u
=
=
u64
)
return
FastUInt32ToBufferLeft
(
u
buffer
)
;
uint64
top_11_digits
=
u64
/
1000000000
;
buffer
=
FastUInt64ToBufferLeft
(
top_11_digits
buffer
)
;
u
=
u64
-
(
top_11_digits
*
1000000000
)
;
digits
=
u
/
10000000
;
GOOGLE_DCHECK_LT
(
digits
100
)
;
ASCII_digits
=
two_ASCII_digits
[
digits
]
;
buffer
[
0
]
=
ASCII_digits
[
0
]
;
buffer
[
1
]
=
ASCII_digits
[
1
]
;
buffer
+
=
2
;
u
-
=
digits
*
10000000
;
digits
=
u
/
100000
;
ASCII_digits
=
two_ASCII_digits
[
digits
]
;
buffer
[
0
]
=
ASCII_digits
[
0
]
;
buffer
[
1
]
=
ASCII_digits
[
1
]
;
buffer
+
=
2
;
u
-
=
digits
*
100000
;
digits
=
u
/
1000
;
ASCII_digits
=
two_ASCII_digits
[
digits
]
;
buffer
[
0
]
=
ASCII_digits
[
0
]
;
buffer
[
1
]
=
ASCII_digits
[
1
]
;
buffer
+
=
2
;
u
-
=
digits
*
1000
;
digits
=
u
/
10
;
ASCII_digits
=
two_ASCII_digits
[
digits
]
;
buffer
[
0
]
=
ASCII_digits
[
0
]
;
buffer
[
1
]
=
ASCII_digits
[
1
]
;
buffer
+
=
2
;
u
-
=
digits
*
10
;
digits
=
u
;
*
buffer
+
+
=
'
0
'
+
digits
;
*
buffer
=
0
;
return
buffer
;
}
char
*
FastInt64ToBufferLeft
(
int64
i
char
*
buffer
)
{
uint64
u
=
i
;
if
(
i
<
0
)
{
*
buffer
+
+
=
'
-
'
;
u
=
-
i
;
}
return
FastUInt64ToBufferLeft
(
u
buffer
)
;
}
string
SimpleItoa
(
int
i
)
{
char
buffer
[
kFastToBufferSize
]
;
return
(
sizeof
(
i
)
=
=
4
)
?
FastInt32ToBuffer
(
i
buffer
)
:
FastInt64ToBuffer
(
i
buffer
)
;
}
string
SimpleItoa
(
unsigned
int
i
)
{
char
buffer
[
kFastToBufferSize
]
;
return
string
(
buffer
(
sizeof
(
i
)
=
=
4
)
?
FastUInt32ToBufferLeft
(
i
buffer
)
:
FastUInt64ToBufferLeft
(
i
buffer
)
)
;
}
string
SimpleItoa
(
long
i
)
{
char
buffer
[
kFastToBufferSize
]
;
return
(
sizeof
(
i
)
=
=
4
)
?
FastInt32ToBuffer
(
i
buffer
)
:
FastInt64ToBuffer
(
i
buffer
)
;
}
string
SimpleItoa
(
unsigned
long
i
)
{
char
buffer
[
kFastToBufferSize
]
;
return
string
(
buffer
(
sizeof
(
i
)
=
=
4
)
?
FastUInt32ToBufferLeft
(
i
buffer
)
:
FastUInt64ToBufferLeft
(
i
buffer
)
)
;
}
string
SimpleItoa
(
long
long
i
)
{
char
buffer
[
kFastToBufferSize
]
;
return
(
sizeof
(
i
)
=
=
4
)
?
FastInt32ToBuffer
(
i
buffer
)
:
FastInt64ToBuffer
(
i
buffer
)
;
}
string
SimpleItoa
(
unsigned
long
long
i
)
{
char
buffer
[
kFastToBufferSize
]
;
return
string
(
buffer
(
sizeof
(
i
)
=
=
4
)
?
FastUInt32ToBufferLeft
(
i
buffer
)
:
FastUInt64ToBufferLeft
(
i
buffer
)
)
;
}
string
SimpleDtoa
(
double
value
)
{
char
buffer
[
kDoubleToBufferSize
]
;
return
DoubleToBuffer
(
value
buffer
)
;
}
string
SimpleFtoa
(
float
value
)
{
char
buffer
[
kFloatToBufferSize
]
;
return
FloatToBuffer
(
value
buffer
)
;
}
static
inline
bool
IsValidFloatChar
(
char
c
)
{
return
(
'
0
'
<
=
c
&
&
c
<
=
'
9
'
)
|
|
c
=
=
'
e
'
|
|
c
=
=
'
E
'
|
|
c
=
=
'
+
'
|
|
c
=
=
'
-
'
;
}
void
DelocalizeRadix
(
char
*
buffer
)
{
if
(
strchr
(
buffer
'
.
'
)
!
=
NULL
)
return
;
while
(
IsValidFloatChar
(
*
buffer
)
)
+
+
buffer
;
if
(
*
buffer
=
=
'
\
0
'
)
{
return
;
}
*
buffer
=
'
.
'
;
+
+
buffer
;
if
(
!
IsValidFloatChar
(
*
buffer
)
&
&
*
buffer
!
=
'
\
0
'
)
{
char
*
target
=
buffer
;
do
{
+
+
buffer
;
}
while
(
!
IsValidFloatChar
(
*
buffer
)
&
&
*
buffer
!
=
'
\
0
'
)
;
memmove
(
target
buffer
strlen
(
buffer
)
+
1
)
;
}
}
char
*
DoubleToBuffer
(
double
value
char
*
buffer
)
{
GOOGLE_COMPILE_ASSERT
(
DBL_DIG
<
20
DBL_DIG_is_too_big
)
;
if
(
value
=
=
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
)
{
strcpy
(
buffer
"
inf
"
)
;
return
buffer
;
}
else
if
(
value
=
=
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
)
{
strcpy
(
buffer
"
-
inf
"
)
;
return
buffer
;
}
else
if
(
MathLimits
<
double
>
:
:
IsNaN
(
value
)
)
{
strcpy
(
buffer
"
nan
"
)
;
return
buffer
;
}
int
snprintf_result
=
snprintf
(
buffer
kDoubleToBufferSize
"
%
.
*
g
"
DBL_DIG
value
)
;
GOOGLE_DCHECK
(
snprintf_result
>
0
&
&
snprintf_result
<
kDoubleToBufferSize
)
;
volatile
double
parsed_value
=
strtod
(
buffer
NULL
)
;
if
(
parsed_value
!
=
value
)
{
int
snprintf_result
=
snprintf
(
buffer
kDoubleToBufferSize
"
%
.
*
g
"
DBL_DIG
+
2
value
)
;
GOOGLE_DCHECK
(
snprintf_result
>
0
&
&
snprintf_result
<
kDoubleToBufferSize
)
;
}
DelocalizeRadix
(
buffer
)
;
return
buffer
;
}
static
int
memcasecmp
(
const
char
*
s1
const
char
*
s2
size_t
len
)
{
const
unsigned
char
*
us1
=
reinterpret_cast
<
const
unsigned
char
*
>
(
s1
)
;
const
unsigned
char
*
us2
=
reinterpret_cast
<
const
unsigned
char
*
>
(
s2
)
;
for
(
int
i
=
0
;
i
<
len
;
i
+
+
)
{
const
int
diff
=
static_cast
<
int
>
(
static_cast
<
unsigned
char
>
(
ascii_tolower
(
us1
[
i
]
)
)
)
-
static_cast
<
int
>
(
static_cast
<
unsigned
char
>
(
ascii_tolower
(
us2
[
i
]
)
)
)
;
if
(
diff
!
=
0
)
return
diff
;
}
return
0
;
}
inline
bool
CaseEqual
(
StringPiece
s1
StringPiece
s2
)
{
if
(
s1
.
size
(
)
!
=
s2
.
size
(
)
)
return
false
;
return
memcasecmp
(
s1
.
data
(
)
s2
.
data
(
)
s1
.
size
(
)
)
=
=
0
;
}
bool
safe_strtob
(
StringPiece
str
bool
*
value
)
{
GOOGLE_CHECK
(
value
!
=
NULL
)
<
<
"
NULL
output
boolean
given
.
"
;
if
(
CaseEqual
(
str
"
true
"
)
|
|
CaseEqual
(
str
"
t
"
)
|
|
CaseEqual
(
str
"
yes
"
)
|
|
CaseEqual
(
str
"
y
"
)
|
|
CaseEqual
(
str
"
1
"
)
)
{
*
value
=
true
;
return
true
;
}
if
(
CaseEqual
(
str
"
false
"
)
|
|
CaseEqual
(
str
"
f
"
)
|
|
CaseEqual
(
str
"
no
"
)
|
|
CaseEqual
(
str
"
n
"
)
|
|
CaseEqual
(
str
"
0
"
)
)
{
*
value
=
false
;
return
true
;
}
return
false
;
}
bool
safe_strtof
(
const
char
*
str
float
*
value
)
{
char
*
endptr
;
errno
=
0
;
#
if
defined
(
_WIN32
)
|
|
defined
(
__hpux
)
*
value
=
strtod
(
str
&
endptr
)
;
#
else
*
value
=
strtof
(
str
&
endptr
)
;
#
endif
return
*
str
!
=
0
&
&
*
endptr
=
=
0
&
&
errno
=
=
0
;
}
bool
safe_strtod
(
const
char
*
str
double
*
value
)
{
char
*
endptr
;
*
value
=
strtod
(
str
&
endptr
)
;
if
(
endptr
!
=
str
)
{
while
(
ascii_isspace
(
*
endptr
)
)
+
+
endptr
;
}
return
*
str
!
=
'
\
0
'
&
&
*
endptr
=
=
'
\
0
'
;
}
bool
safe_strto32
(
const
string
&
str
int32
*
value
)
{
return
safe_int_internal
(
str
value
)
;
}
bool
safe_strtou32
(
const
string
&
str
uint32
*
value
)
{
return
safe_uint_internal
(
str
value
)
;
}
bool
safe_strto64
(
const
string
&
str
int64
*
value
)
{
return
safe_int_internal
(
str
value
)
;
}
bool
safe_strtou64
(
const
string
&
str
uint64
*
value
)
{
return
safe_uint_internal
(
str
value
)
;
}
char
*
FloatToBuffer
(
float
value
char
*
buffer
)
{
GOOGLE_COMPILE_ASSERT
(
FLT_DIG
<
10
FLT_DIG_is_too_big
)
;
if
(
value
=
=
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
)
{
strcpy
(
buffer
"
inf
"
)
;
return
buffer
;
}
else
if
(
value
=
=
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
)
{
strcpy
(
buffer
"
-
inf
"
)
;
return
buffer
;
}
else
if
(
MathLimits
<
float
>
:
:
IsNaN
(
value
)
)
{
strcpy
(
buffer
"
nan
"
)
;
return
buffer
;
}
int
snprintf_result
=
snprintf
(
buffer
kFloatToBufferSize
"
%
.
*
g
"
FLT_DIG
value
)
;
GOOGLE_DCHECK
(
snprintf_result
>
0
&
&
snprintf_result
<
kFloatToBufferSize
)
;
float
parsed_value
;
if
(
!
safe_strtof
(
buffer
&
parsed_value
)
|
|
parsed_value
!
=
value
)
{
int
snprintf_result
=
snprintf
(
buffer
kFloatToBufferSize
"
%
.
*
g
"
FLT_DIG
+
3
value
)
;
GOOGLE_DCHECK
(
snprintf_result
>
0
&
&
snprintf_result
<
kFloatToBufferSize
)
;
}
DelocalizeRadix
(
buffer
)
;
return
buffer
;
}
namespace
strings
{
AlphaNum
:
:
AlphaNum
(
strings
:
:
Hex
hex
)
{
char
*
const
end
=
&
digits
[
kFastToBufferSize
]
;
char
*
writer
=
end
;
uint64
value
=
hex
.
value
;
uint64
width
=
hex
.
spec
;
uint64
mask
=
(
(
static_cast
<
uint64
>
(
1
)
<
<
(
width
-
1
)
*
4
)
)
|
value
;
static
const
char
hexdigits
[
]
=
"
0123456789abcdef
"
;
do
{
*
-
-
writer
=
hexdigits
[
value
&
0xF
]
;
value
>
>
=
4
;
mask
>
>
=
4
;
}
while
(
mask
!
=
0
)
;
piece_data_
=
writer
;
piece_size_
=
end
-
writer
;
}
}
static
char
*
Append1
(
char
*
out
const
AlphaNum
&
x
)
{
memcpy
(
out
x
.
data
(
)
x
.
size
(
)
)
;
return
out
+
x
.
size
(
)
;
}
static
char
*
Append2
(
char
*
out
const
AlphaNum
&
x1
const
AlphaNum
&
x2
)
{
memcpy
(
out
x1
.
data
(
)
x1
.
size
(
)
)
;
out
+
=
x1
.
size
(
)
;
memcpy
(
out
x2
.
data
(
)
x2
.
size
(
)
)
;
return
out
+
x2
.
size
(
)
;
}
static
char
*
Append4
(
char
*
out
const
AlphaNum
&
x1
const
AlphaNum
&
x2
const
AlphaNum
&
x3
const
AlphaNum
&
x4
)
{
memcpy
(
out
x1
.
data
(
)
x1
.
size
(
)
)
;
out
+
=
x1
.
size
(
)
;
memcpy
(
out
x2
.
data
(
)
x2
.
size
(
)
)
;
out
+
=
x2
.
size
(
)
;
memcpy
(
out
x3
.
data
(
)
x3
.
size
(
)
)
;
out
+
=
x3
.
size
(
)
;
memcpy
(
out
x4
.
data
(
)
x4
.
size
(
)
)
;
return
out
+
x4
.
size
(
)
;
}
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
)
{
string
result
;
result
.
resize
(
a
.
size
(
)
+
b
.
size
(
)
)
;
char
*
const
begin
=
&
*
result
.
begin
(
)
;
char
*
out
=
Append2
(
begin
a
b
)
;
GOOGLE_DCHECK_EQ
(
out
begin
+
result
.
size
(
)
)
;
return
result
;
}
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
)
{
string
result
;
result
.
resize
(
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
)
;
char
*
const
begin
=
&
*
result
.
begin
(
)
;
char
*
out
=
Append2
(
begin
a
b
)
;
out
=
Append1
(
out
c
)
;
GOOGLE_DCHECK_EQ
(
out
begin
+
result
.
size
(
)
)
;
return
result
;
}
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
)
{
string
result
;
result
.
resize
(
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
+
d
.
size
(
)
)
;
char
*
const
begin
=
&
*
result
.
begin
(
)
;
char
*
out
=
Append4
(
begin
a
b
c
d
)
;
GOOGLE_DCHECK_EQ
(
out
begin
+
result
.
size
(
)
)
;
return
result
;
}
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
const
AlphaNum
&
e
)
{
string
result
;
result
.
resize
(
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
+
d
.
size
(
)
+
e
.
size
(
)
)
;
char
*
const
begin
=
&
*
result
.
begin
(
)
;
char
*
out
=
Append4
(
begin
a
b
c
d
)
;
out
=
Append1
(
out
e
)
;
GOOGLE_DCHECK_EQ
(
out
begin
+
result
.
size
(
)
)
;
return
result
;
}
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
const
AlphaNum
&
e
const
AlphaNum
&
f
)
{
string
result
;
result
.
resize
(
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
+
d
.
size
(
)
+
e
.
size
(
)
+
f
.
size
(
)
)
;
char
*
const
begin
=
&
*
result
.
begin
(
)
;
char
*
out
=
Append4
(
begin
a
b
c
d
)
;
out
=
Append2
(
out
e
f
)
;
GOOGLE_DCHECK_EQ
(
out
begin
+
result
.
size
(
)
)
;
return
result
;
}
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
const
AlphaNum
&
e
const
AlphaNum
&
f
const
AlphaNum
&
g
)
{
string
result
;
result
.
resize
(
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
+
d
.
size
(
)
+
e
.
size
(
)
+
f
.
size
(
)
+
g
.
size
(
)
)
;
char
*
const
begin
=
&
*
result
.
begin
(
)
;
char
*
out
=
Append4
(
begin
a
b
c
d
)
;
out
=
Append2
(
out
e
f
)
;
out
=
Append1
(
out
g
)
;
GOOGLE_DCHECK_EQ
(
out
begin
+
result
.
size
(
)
)
;
return
result
;
}
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
const
AlphaNum
&
e
const
AlphaNum
&
f
const
AlphaNum
&
g
const
AlphaNum
&
h
)
{
string
result
;
result
.
resize
(
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
+
d
.
size
(
)
+
e
.
size
(
)
+
f
.
size
(
)
+
g
.
size
(
)
+
h
.
size
(
)
)
;
char
*
const
begin
=
&
*
result
.
begin
(
)
;
char
*
out
=
Append4
(
begin
a
b
c
d
)
;
out
=
Append4
(
out
e
f
g
h
)
;
GOOGLE_DCHECK_EQ
(
out
begin
+
result
.
size
(
)
)
;
return
result
;
}
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
const
AlphaNum
&
e
const
AlphaNum
&
f
const
AlphaNum
&
g
const
AlphaNum
&
h
const
AlphaNum
&
i
)
{
string
result
;
result
.
resize
(
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
+
d
.
size
(
)
+
e
.
size
(
)
+
f
.
size
(
)
+
g
.
size
(
)
+
h
.
size
(
)
+
i
.
size
(
)
)
;
char
*
const
begin
=
&
*
result
.
begin
(
)
;
char
*
out
=
Append4
(
begin
a
b
c
d
)
;
out
=
Append4
(
out
e
f
g
h
)
;
out
=
Append1
(
out
i
)
;
GOOGLE_DCHECK_EQ
(
out
begin
+
result
.
size
(
)
)
;
return
result
;
}
#
define
GOOGLE_DCHECK_NO_OVERLAP
(
dest
src
)
\
GOOGLE_DCHECK_GT
(
uintptr_t
(
(
src
)
.
data
(
)
-
(
dest
)
.
data
(
)
)
\
uintptr_t
(
(
dest
)
.
size
(
)
)
)
void
StrAppend
(
string
*
result
const
AlphaNum
&
a
)
{
GOOGLE_DCHECK_NO_OVERLAP
(
*
result
a
)
;
result
-
>
append
(
a
.
data
(
)
a
.
size
(
)
)
;
}
void
StrAppend
(
string
*
result
const
AlphaNum
&
a
const
AlphaNum
&
b
)
{
GOOGLE_DCHECK_NO_OVERLAP
(
*
result
a
)
;
GOOGLE_DCHECK_NO_OVERLAP
(
*
result
b
)
;
string
:
:
size_type
old_size
=
result
-
>
size
(
)
;
result
-
>
resize
(
old_size
+
a
.
size
(
)
+
b
.
size
(
)
)
;
char
*
const
begin
=
&
*
result
-
>
begin
(
)
;
char
*
out
=
Append2
(
begin
+
old_size
a
b
)
;
GOOGLE_DCHECK_EQ
(
out
begin
+
result
-
>
size
(
)
)
;
}
void
StrAppend
(
string
*
result
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
)
{
GOOGLE_DCHECK_NO_OVERLAP
(
*
result
a
)
;
GOOGLE_DCHECK_NO_OVERLAP
(
*
result
b
)
;
GOOGLE_DCHECK_NO_OVERLAP
(
*
result
c
)
;
string
:
:
size_type
old_size
=
result
-
>
size
(
)
;
result
-
>
resize
(
old_size
+
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
)
;
char
*
const
begin
=
&
*
result
-
>
begin
(
)
;
char
*
out
=
Append2
(
begin
+
old_size
a
b
)
;
out
=
Append1
(
out
c
)
;
GOOGLE_DCHECK_EQ
(
out
begin
+
result
-
>
size
(
)
)
;
}
void
StrAppend
(
string
*
result
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
)
{
GOOGLE_DCHECK_NO_OVERLAP
(
*
result
a
)
;
GOOGLE_DCHECK_NO_OVERLAP
(
*
result
b
)
;
GOOGLE_DCHECK_NO_OVERLAP
(
*
result
c
)
;
GOOGLE_DCHECK_NO_OVERLAP
(
*
result
d
)
;
string
:
:
size_type
old_size
=
result
-
>
size
(
)
;
result
-
>
resize
(
old_size
+
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
+
d
.
size
(
)
)
;
char
*
const
begin
=
&
*
result
-
>
begin
(
)
;
char
*
out
=
Append4
(
begin
+
old_size
a
b
c
d
)
;
GOOGLE_DCHECK_EQ
(
out
begin
+
result
-
>
size
(
)
)
;
}
int
GlobalReplaceSubstring
(
const
string
&
substring
const
string
&
replacement
string
*
s
)
{
GOOGLE_CHECK
(
s
!
=
NULL
)
;
if
(
s
-
>
empty
(
)
|
|
substring
.
empty
(
)
)
return
0
;
string
tmp
;
int
num_replacements
=
0
;
int
pos
=
0
;
for
(
int
match_pos
=
s
-
>
find
(
substring
.
data
(
)
pos
substring
.
length
(
)
)
;
match_pos
!
=
string
:
:
npos
;
pos
=
match_pos
+
substring
.
length
(
)
match_pos
=
s
-
>
find
(
substring
.
data
(
)
pos
substring
.
length
(
)
)
)
{
+
+
num_replacements
;
tmp
.
append
(
*
s
pos
match_pos
-
pos
)
;
tmp
.
append
(
replacement
.
begin
(
)
replacement
.
end
(
)
)
;
}
if
(
num_replacements
>
0
)
{
tmp
.
append
(
*
s
pos
s
-
>
length
(
)
-
pos
)
;
s
-
>
swap
(
tmp
)
;
}
return
num_replacements
;
}
int
CalculateBase64EscapedLen
(
int
input_len
bool
do_padding
)
{
int
len
=
(
input_len
/
3
)
*
4
;
if
(
input_len
%
3
=
=
0
)
{
}
else
if
(
input_len
%
3
=
=
1
)
{
len
+
=
2
;
if
(
do_padding
)
{
len
+
=
2
;
}
}
else
{
len
+
=
3
;
if
(
do_padding
)
{
len
+
=
1
;
}
}
assert
(
len
>
=
input_len
)
;
return
len
;
}
int
CalculateBase64EscapedLen
(
int
input_len
)
{
return
CalculateBase64EscapedLen
(
input_len
true
)
;
}
int
Base64UnescapeInternal
(
const
char
*
src_param
int
szsrc
char
*
dest
int
szdest
const
signed
char
*
unbase64
)
{
static
const
char
kPad64Equals
=
'
=
'
;
static
const
char
kPad64Dot
=
'
.
'
;
int
decode
=
0
;
int
destidx
=
0
;
int
state
=
0
;
unsigned
int
ch
=
0
;
unsigned
int
temp
=
0
;
const
unsigned
char
*
src
=
reinterpret_cast
<
const
unsigned
char
*
>
(
src_param
)
;
#
define
GET_INPUT
(
label
remain
)
\
label
:
\
-
-
szsrc
;
\
ch
=
*
src
+
+
;
\
decode
=
unbase64
[
ch
]
;
\
if
(
decode
<
0
)
{
\
if
(
ascii_isspace
(
ch
)
&
&
szsrc
>
=
remain
)
\
goto
label
;
\
state
=
4
-
remain
;
\
break
;
\
}
if
(
dest
)
{
while
(
szsrc
>
=
4
)
{
if
(
!
src
[
0
]
|
|
!
src
[
1
]
|
|
!
src
[
2
]
|
|
(
temp
=
(
(
unsigned
(
unbase64
[
src
[
0
]
]
)
<
<
18
)
|
(
unsigned
(
unbase64
[
src
[
1
]
]
)
<
<
12
)
|
(
unsigned
(
unbase64
[
src
[
2
]
]
)
<
<
6
)
|
(
unsigned
(
unbase64
[
src
[
3
]
]
)
)
)
)
&
0x80000000
)
{
GET_INPUT
(
first
4
)
;
temp
=
decode
;
GET_INPUT
(
second
3
)
;
temp
=
(
temp
<
<
6
)
|
decode
;
GET_INPUT
(
third
2
)
;
temp
=
(
temp
<
<
6
)
|
decode
;
GET_INPUT
(
fourth
1
)
;
temp
=
(
temp
<
<
6
)
|
decode
;
}
else
{
szsrc
-
=
4
;
src
+
=
4
;
decode
=
-
1
;
ch
=
'
\
0
'
;
}
if
(
destidx
+
3
>
szdest
)
return
-
1
;
dest
[
destidx
+
2
]
=
temp
;
temp
>
>
=
8
;
dest
[
destidx
+
1
]
=
temp
;
temp
>
>
=
8
;
dest
[
destidx
]
=
temp
;
destidx
+
=
3
;
}
}
else
{
while
(
szsrc
>
=
4
)
{
if
(
!
src
[
0
]
|
|
!
src
[
1
]
|
|
!
src
[
2
]
|
|
(
temp
=
(
(
unsigned
(
unbase64
[
src
[
0
]
]
)
<
<
18
)
|
(
unsigned
(
unbase64
[
src
[
1
]
]
)
<
<
12
)
|
(
unsigned
(
unbase64
[
src
[
2
]
]
)
<
<
6
)
|
(
unsigned
(
unbase64
[
src
[
3
]
]
)
)
)
)
&
0x80000000
)
{
GET_INPUT
(
first_no_dest
4
)
;
GET_INPUT
(
second_no_dest
3
)
;
GET_INPUT
(
third_no_dest
2
)
;
GET_INPUT
(
fourth_no_dest
1
)
;
}
else
{
szsrc
-
=
4
;
src
+
=
4
;
decode
=
-
1
;
ch
=
'
\
0
'
;
}
destidx
+
=
3
;
}
}
#
undef
GET_INPUT
if
(
decode
<
0
&
&
ch
!
=
'
\
0
'
&
&
ch
!
=
kPad64Equals
&
&
ch
!
=
kPad64Dot
&
&
!
ascii_isspace
(
ch
)
)
return
-
1
;
if
(
ch
=
=
kPad64Equals
|
|
ch
=
=
kPad64Dot
)
{
+
+
szsrc
;
-
-
src
;
}
else
{
while
(
szsrc
>
0
)
{
-
-
szsrc
;
ch
=
*
src
+
+
;
decode
=
unbase64
[
ch
]
;
if
(
decode
<
0
)
{
if
(
ascii_isspace
(
ch
)
)
{
continue
;
}
else
if
(
ch
=
=
'
\
0
'
)
{
break
;
}
else
if
(
ch
=
=
kPad64Equals
|
|
ch
=
=
kPad64Dot
)
{
+
+
szsrc
;
-
-
src
;
break
;
}
else
{
return
-
1
;
}
}
temp
=
(
temp
<
<
6
)
|
decode
;
+
+
state
;
if
(
state
=
=
4
)
{
if
(
dest
)
{
if
(
destidx
+
3
>
szdest
)
return
-
1
;
dest
[
destidx
+
2
]
=
temp
;
temp
>
>
=
8
;
dest
[
destidx
+
1
]
=
temp
;
temp
>
>
=
8
;
dest
[
destidx
]
=
temp
;
}
destidx
+
=
3
;
state
=
0
;
temp
=
0
;
}
}
}
int
expected_equals
=
0
;
switch
(
state
)
{
case
0
:
break
;
case
1
:
return
-
1
;
case
2
:
if
(
dest
)
{
if
(
destidx
+
1
>
szdest
)
return
-
1
;
temp
>
>
=
4
;
dest
[
destidx
]
=
temp
;
}
+
+
destidx
;
expected_equals
=
2
;
break
;
case
3
:
if
(
dest
)
{
if
(
destidx
+
2
>
szdest
)
return
-
1
;
temp
>
>
=
2
;
dest
[
destidx
+
1
]
=
temp
;
temp
>
>
=
8
;
dest
[
destidx
]
=
temp
;
}
destidx
+
=
2
;
expected_equals
=
1
;
break
;
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
This
can
'
t
happen
;
base64
decoder
state
=
"
<
<
state
;
}
int
equals
=
0
;
while
(
szsrc
>
0
&
&
*
src
)
{
if
(
*
src
=
=
kPad64Equals
|
|
*
src
=
=
kPad64Dot
)
+
+
equals
;
else
if
(
!
ascii_isspace
(
*
src
)
)
return
-
1
;
-
-
szsrc
;
+
+
src
;
}
return
(
equals
=
=
0
|
|
equals
=
=
expected_equals
)
?
destidx
:
-
1
;
}
static
const
signed
char
kUnBase64
[
]
=
{
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
62
-
1
-
1
-
1
63
52
53
54
55
56
57
58
59
60
61
-
1
-
1
-
1
-
1
-
1
-
1
-
1
0
1
2
3
4
5
6
07
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
-
1
-
1
-
1
-
1
-
1
-
1
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
}
;
static
const
signed
char
kUnWebSafeBase64
[
]
=
{
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
62
-
1
-
1
52
53
54
55
56
57
58
59
60
61
-
1
-
1
-
1
-
1
-
1
-
1
-
1
0
1
2
3
4
5
6
07
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
-
1
-
1
-
1
-
1
63
-
1
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
}
;
int
WebSafeBase64Unescape
(
const
char
*
src
int
szsrc
char
*
dest
int
szdest
)
{
return
Base64UnescapeInternal
(
src
szsrc
dest
szdest
kUnWebSafeBase64
)
;
}
static
bool
Base64UnescapeInternal
(
const
char
*
src
int
slen
string
*
dest
const
signed
char
*
unbase64
)
{
const
int
dest_len
=
3
*
(
slen
/
4
)
+
(
slen
%
4
)
;
dest
-
>
resize
(
dest_len
)
;
const
int
len
=
Base64UnescapeInternal
(
src
slen
string_as_array
(
dest
)
dest_len
unbase64
)
;
if
(
len
<
0
)
{
dest
-
>
clear
(
)
;
return
false
;
}
GOOGLE_DCHECK_LE
(
len
dest_len
)
;
dest
-
>
erase
(
len
)
;
return
true
;
}
bool
Base64Unescape
(
StringPiece
src
string
*
dest
)
{
return
Base64UnescapeInternal
(
src
.
data
(
)
src
.
size
(
)
dest
kUnBase64
)
;
}
bool
WebSafeBase64Unescape
(
StringPiece
src
string
*
dest
)
{
return
Base64UnescapeInternal
(
src
.
data
(
)
src
.
size
(
)
dest
kUnWebSafeBase64
)
;
}
int
Base64EscapeInternal
(
const
unsigned
char
*
src
int
szsrc
char
*
dest
int
szdest
const
char
*
base64
bool
do_padding
)
{
static
const
char
kPad64
=
'
=
'
;
if
(
szsrc
<
=
0
)
return
0
;
if
(
szsrc
*
4
>
szdest
*
3
)
return
0
;
char
*
cur_dest
=
dest
;
const
unsigned
char
*
cur_src
=
src
;
char
*
limit_dest
=
dest
+
szdest
;
const
unsigned
char
*
limit_src
=
src
+
szsrc
;
while
(
cur_src
<
limit_src
-
3
)
{
uint32
in
=
BigEndian
:
:
Load32
(
cur_src
)
>
>
8
;
cur_dest
[
0
]
=
base64
[
in
>
>
18
]
;
in
&
=
0x3FFFF
;
cur_dest
[
1
]
=
base64
[
in
>
>
12
]
;
in
&
=
0xFFF
;
cur_dest
[
2
]
=
base64
[
in
>
>
6
]
;
in
&
=
0x3F
;
cur_dest
[
3
]
=
base64
[
in
]
;
cur_dest
+
=
4
;
cur_src
+
=
3
;
}
szdest
=
limit_dest
-
cur_dest
;
szsrc
=
limit_src
-
cur_src
;
switch
(
szsrc
)
{
case
0
:
break
;
case
1
:
{
if
(
(
szdest
-
=
2
)
<
0
)
return
0
;
uint32
in
=
cur_src
[
0
]
;
cur_dest
[
0
]
=
base64
[
in
>
>
2
]
;
in
&
=
0x3
;
cur_dest
[
1
]
=
base64
[
in
<
<
4
]
;
cur_dest
+
=
2
;
if
(
do_padding
)
{
if
(
(
szdest
-
=
2
)
<
0
)
return
0
;
cur_dest
[
0
]
=
kPad64
;
cur_dest
[
1
]
=
kPad64
;
cur_dest
+
=
2
;
}
break
;
}
case
2
:
{
if
(
(
szdest
-
=
3
)
<
0
)
return
0
;
uint32
in
=
BigEndian
:
:
Load16
(
cur_src
)
;
cur_dest
[
0
]
=
base64
[
in
>
>
10
]
;
in
&
=
0x3FF
;
cur_dest
[
1
]
=
base64
[
in
>
>
4
]
;
in
&
=
0x00F
;
cur_dest
[
2
]
=
base64
[
in
<
<
2
]
;
cur_dest
+
=
3
;
if
(
do_padding
)
{
if
(
(
szdest
-
=
1
)
<
0
)
return
0
;
cur_dest
[
0
]
=
kPad64
;
cur_dest
+
=
1
;
}
break
;
}
case
3
:
{
if
(
(
szdest
-
=
4
)
<
0
)
return
0
;
uint32
in
=
(
cur_src
[
0
]
<
<
16
)
+
BigEndian
:
:
Load16
(
cur_src
+
1
)
;
cur_dest
[
0
]
=
base64
[
in
>
>
18
]
;
in
&
=
0x3FFFF
;
cur_dest
[
1
]
=
base64
[
in
>
>
12
]
;
in
&
=
0xFFF
;
cur_dest
[
2
]
=
base64
[
in
>
>
6
]
;
in
&
=
0x3F
;
cur_dest
[
3
]
=
base64
[
in
]
;
cur_dest
+
=
4
;
break
;
}
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
Logic
problem
?
szsrc
=
"
<
<
szsrc
;
break
;
}
return
(
cur_dest
-
dest
)
;
}
static
const
char
kBase64Chars
[
]
=
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
"
;
static
const
char
kWebSafeBase64Chars
[
]
=
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
-
_
"
;
int
Base64Escape
(
const
unsigned
char
*
src
int
szsrc
char
*
dest
int
szdest
)
{
return
Base64EscapeInternal
(
src
szsrc
dest
szdest
kBase64Chars
true
)
;
}
int
WebSafeBase64Escape
(
const
unsigned
char
*
src
int
szsrc
char
*
dest
int
szdest
bool
do_padding
)
{
return
Base64EscapeInternal
(
src
szsrc
dest
szdest
kWebSafeBase64Chars
do_padding
)
;
}
void
Base64EscapeInternal
(
const
unsigned
char
*
src
int
szsrc
string
*
dest
bool
do_padding
const
char
*
base64_chars
)
{
const
int
calc_escaped_size
=
CalculateBase64EscapedLen
(
szsrc
do_padding
)
;
dest
-
>
resize
(
calc_escaped_size
)
;
const
int
escaped_len
=
Base64EscapeInternal
(
src
szsrc
string_as_array
(
dest
)
dest
-
>
size
(
)
base64_chars
do_padding
)
;
GOOGLE_DCHECK_EQ
(
calc_escaped_size
escaped_len
)
;
dest
-
>
erase
(
escaped_len
)
;
}
void
Base64Escape
(
const
unsigned
char
*
src
int
szsrc
string
*
dest
bool
do_padding
)
{
Base64EscapeInternal
(
src
szsrc
dest
do_padding
kBase64Chars
)
;
}
void
WebSafeBase64Escape
(
const
unsigned
char
*
src
int
szsrc
string
*
dest
bool
do_padding
)
{
Base64EscapeInternal
(
src
szsrc
dest
do_padding
kWebSafeBase64Chars
)
;
}
void
Base64Escape
(
StringPiece
src
string
*
dest
)
{
Base64Escape
(
reinterpret_cast
<
const
unsigned
char
*
>
(
src
.
data
(
)
)
src
.
size
(
)
dest
true
)
;
}
void
WebSafeBase64Escape
(
StringPiece
src
string
*
dest
)
{
WebSafeBase64Escape
(
reinterpret_cast
<
const
unsigned
char
*
>
(
src
.
data
(
)
)
src
.
size
(
)
dest
false
)
;
}
void
WebSafeBase64EscapeWithPadding
(
StringPiece
src
string
*
dest
)
{
WebSafeBase64Escape
(
reinterpret_cast
<
const
unsigned
char
*
>
(
src
.
data
(
)
)
src
.
size
(
)
dest
true
)
;
}
int
EncodeAsUTF8Char
(
uint32
code_point
char
*
output
)
{
uint32
tmp
=
0
;
int
len
=
0
;
if
(
code_point
<
=
0x7f
)
{
tmp
=
code_point
;
len
=
1
;
}
else
if
(
code_point
<
=
0x07ff
)
{
tmp
=
0x0000c080
|
(
(
code_point
&
0x07c0
)
<
<
2
)
|
(
code_point
&
0x003f
)
;
len
=
2
;
}
else
if
(
code_point
<
=
0xffff
)
{
tmp
=
0x00e08080
|
(
(
code_point
&
0xf000
)
<
<
4
)
|
(
(
code_point
&
0x0fc0
)
<
<
2
)
|
(
code_point
&
0x003f
)
;
len
=
3
;
}
else
{
tmp
=
0xf0808080
|
(
(
code_point
&
0x1c0000
)
<
<
6
)
|
(
(
code_point
&
0x03f000
)
<
<
4
)
|
(
(
code_point
&
0x000fc0
)
<
<
2
)
|
(
code_point
&
0x003f
)
;
len
=
4
;
}
tmp
=
ghtonl
(
tmp
)
;
memcpy
(
output
reinterpret_cast
<
const
char
*
>
(
&
tmp
)
+
sizeof
(
tmp
)
-
len
len
)
;
return
len
;
}
static
const
unsigned
char
kUTF8LenTbl
[
256
]
=
{
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
}
;
int
UTF8FirstLetterNumBytes
(
const
char
*
src
int
len
)
{
if
(
len
=
=
0
)
{
return
0
;
}
return
kUTF8LenTbl
[
*
reinterpret_cast
<
const
uint8
*
>
(
src
)
]
;
}
}
}
