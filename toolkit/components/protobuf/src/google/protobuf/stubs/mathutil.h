#
ifndef
GOOGLE_PROTOBUF_STUBS_MATHUTIL_H_
#
define
GOOGLE_PROTOBUF_STUBS_MATHUTIL_H_
#
include
<
cmath
>
#
include
<
float
.
h
>
#
include
<
limits
>
#
include
<
google
/
protobuf
/
stubs
/
common
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
logging
.
h
>
namespace
google
{
namespace
protobuf
{
namespace
internal
{
template
<
typename
T
>
using
MakeUnsignedT
=
typename
std
:
:
conditional
<
std
:
:
is_integral
<
T
>
:
:
value
std
:
:
make_unsigned
<
T
>
std
:
:
common_type
<
T
>
>
:
:
type
:
:
type
;
template
<
typename
T
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
int
>
:
:
type
=
0
>
bool
IsNan
(
T
)
{
return
false
;
}
template
<
typename
T
typename
std
:
:
enable_if
<
std
:
:
is_floating_point
<
T
>
:
:
value
int
>
:
:
type
=
0
>
bool
IsNan
(
T
val
)
{
return
std
:
:
isnan
(
val
)
;
}
template
<
typename
T
>
bool
AlmostEquals
(
T
a
T
b
)
{
return
a
=
=
b
;
}
template
<
>
inline
bool
AlmostEquals
(
float
a
float
b
)
{
return
fabs
(
a
-
b
)
<
32
*
FLT_EPSILON
;
}
template
<
>
inline
bool
AlmostEquals
(
double
a
double
b
)
{
return
fabs
(
a
-
b
)
<
32
*
DBL_EPSILON
;
}
}
class
MathUtil
{
public
:
template
<
typename
T
>
static
T
Sign
(
T
value
)
{
if
(
value
=
=
T
(
0
)
|
|
internal
:
:
IsNan
(
value
)
)
{
return
value
;
}
return
value
>
T
(
0
)
?
1
:
-
1
;
}
template
<
typename
T
>
static
bool
AlmostEquals
(
T
a
T
b
)
{
return
internal
:
:
AlmostEquals
(
a
b
)
;
}
template
<
typename
T
>
static
T
Max
(
const
T
x
const
T
y
)
{
return
internal
:
:
IsNan
(
x
)
|
|
x
>
y
?
x
:
y
;
}
template
<
typename
T
>
static
T
Abs
(
const
T
x
)
{
return
x
>
T
(
0
)
?
x
:
-
x
;
}
template
<
typename
T
>
static
typename
internal
:
:
MakeUnsignedT
<
T
>
AbsDiff
(
const
T
x
const
T
y
)
{
typedef
typename
internal
:
:
MakeUnsignedT
<
T
>
R
;
return
x
>
y
?
R
(
x
)
-
R
(
y
)
:
R
(
y
)
-
R
(
x
)
;
}
template
<
typename
T
>
static
bool
WithinFractionOrMargin
(
const
T
x
const
T
y
const
T
fraction
const
T
margin
)
;
}
;
template
<
typename
T
>
bool
MathUtil
:
:
WithinFractionOrMargin
(
const
T
x
const
T
y
const
T
fraction
const
T
margin
)
{
GOOGLE_DCHECK
(
(
T
(
0
)
<
fraction
|
|
T
(
0
)
=
=
fraction
)
&
&
fraction
<
T
(
1
)
&
&
margin
>
=
T
(
0
)
)
;
if
(
std
:
:
numeric_limits
<
T
>
:
:
is_integer
)
{
return
x
=
=
y
;
}
else
{
if
(
!
std
:
:
isfinite
(
x
)
|
|
!
std
:
:
isfinite
(
y
)
)
{
return
false
;
}
T
relative_margin
=
static_cast
<
T
>
(
fraction
*
Max
(
Abs
(
x
)
Abs
(
y
)
)
)
;
return
AbsDiff
(
x
y
)
<
=
Max
(
margin
relative_margin
)
;
}
}
}
}
#
endif
