#
include
<
google
/
protobuf
/
descriptor
.
h
>
#
include
<
algorithm
>
#
include
<
functional
>
#
include
<
limits
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
string
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
<
vector
>
#
include
<
google
/
protobuf
/
stubs
/
common
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
logging
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
stringprintf
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
strutil
.
h
>
#
include
<
google
/
protobuf
/
descriptor
.
pb
.
h
>
#
include
<
google
/
protobuf
/
io
/
coded_stream
.
h
>
#
include
<
google
/
protobuf
/
io
/
tokenizer
.
h
>
#
include
<
google
/
protobuf
/
io
/
zero_copy_stream_impl
.
h
>
#
include
<
google
/
protobuf
/
descriptor_database
.
h
>
#
include
<
google
/
protobuf
/
dynamic_message
.
h
>
#
include
<
google
/
protobuf
/
generated_message_util
.
h
>
#
include
<
google
/
protobuf
/
text_format
.
h
>
#
include
<
google
/
protobuf
/
unknown_field_set
.
h
>
#
include
<
google
/
protobuf
/
wire_format
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
casts
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
substitute
.
h
>
#
include
<
google
/
protobuf
/
io
/
strtod
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
map_util
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
stl_util
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
hash
.
h
>
#
undef
PACKAGE
/
/
autoheader
#
defines
this
.
:
(
#
include
<
google
/
protobuf
/
port_def
.
inc
>
namespace
google
{
namespace
protobuf
{
struct
Symbol
{
enum
Type
{
NULL_SYMBOL
MESSAGE
FIELD
ONEOF
ENUM
ENUM_VALUE
SERVICE
METHOD
PACKAGE
}
;
Type
type
;
union
{
const
Descriptor
*
descriptor
;
const
FieldDescriptor
*
field_descriptor
;
const
OneofDescriptor
*
oneof_descriptor
;
const
EnumDescriptor
*
enum_descriptor
;
const
EnumValueDescriptor
*
enum_value_descriptor
;
const
ServiceDescriptor
*
service_descriptor
;
const
MethodDescriptor
*
method_descriptor
;
const
FileDescriptor
*
package_file_descriptor
;
}
;
inline
Symbol
(
)
:
type
(
NULL_SYMBOL
)
{
descriptor
=
nullptr
;
}
inline
bool
IsNull
(
)
const
{
return
type
=
=
NULL_SYMBOL
;
}
inline
bool
IsType
(
)
const
{
return
type
=
=
MESSAGE
|
|
type
=
=
ENUM
;
}
inline
bool
IsAggregate
(
)
const
{
return
type
=
=
MESSAGE
|
|
type
=
=
PACKAGE
|
|
type
=
=
ENUM
|
|
type
=
=
SERVICE
;
}
#
define
CONSTRUCTOR
(
TYPE
TYPE_CONSTANT
FIELD
)
\
inline
explicit
Symbol
(
const
TYPE
*
value
)
{
\
type
=
TYPE_CONSTANT
;
\
this
-
>
FIELD
=
value
;
\
}
CONSTRUCTOR
(
Descriptor
MESSAGE
descriptor
)
CONSTRUCTOR
(
FieldDescriptor
FIELD
field_descriptor
)
CONSTRUCTOR
(
OneofDescriptor
ONEOF
oneof_descriptor
)
CONSTRUCTOR
(
EnumDescriptor
ENUM
enum_descriptor
)
CONSTRUCTOR
(
EnumValueDescriptor
ENUM_VALUE
enum_value_descriptor
)
CONSTRUCTOR
(
ServiceDescriptor
SERVICE
service_descriptor
)
CONSTRUCTOR
(
MethodDescriptor
METHOD
method_descriptor
)
CONSTRUCTOR
(
FileDescriptor
PACKAGE
package_file_descriptor
)
#
undef
CONSTRUCTOR
const
FileDescriptor
*
GetFile
(
)
const
{
switch
(
type
)
{
case
NULL_SYMBOL
:
return
nullptr
;
case
MESSAGE
:
return
descriptor
-
>
file
(
)
;
case
FIELD
:
return
field_descriptor
-
>
file
(
)
;
case
ONEOF
:
return
oneof_descriptor
-
>
containing_type
(
)
-
>
file
(
)
;
case
ENUM
:
return
enum_descriptor
-
>
file
(
)
;
case
ENUM_VALUE
:
return
enum_value_descriptor
-
>
type
(
)
-
>
file
(
)
;
case
SERVICE
:
return
service_descriptor
-
>
file
(
)
;
case
METHOD
:
return
method_descriptor
-
>
service
(
)
-
>
file
(
)
;
case
PACKAGE
:
return
package_file_descriptor
;
}
return
nullptr
;
}
}
;
const
FieldDescriptor
:
:
CppType
FieldDescriptor
:
:
kTypeToCppTypeMap
[
MAX_TYPE
+
1
]
=
{
static_cast
<
CppType
>
(
0
)
CPPTYPE_DOUBLE
CPPTYPE_FLOAT
CPPTYPE_INT64
CPPTYPE_UINT64
CPPTYPE_INT32
CPPTYPE_UINT64
CPPTYPE_UINT32
CPPTYPE_BOOL
CPPTYPE_STRING
CPPTYPE_MESSAGE
CPPTYPE_MESSAGE
CPPTYPE_STRING
CPPTYPE_UINT32
CPPTYPE_ENUM
CPPTYPE_INT32
CPPTYPE_INT64
CPPTYPE_INT32
CPPTYPE_INT64
}
;
const
char
*
const
FieldDescriptor
:
:
kTypeToName
[
MAX_TYPE
+
1
]
=
{
"
ERROR
"
"
double
"
"
float
"
"
int64
"
"
uint64
"
"
int32
"
"
fixed64
"
"
fixed32
"
"
bool
"
"
string
"
"
group
"
"
message
"
"
bytes
"
"
uint32
"
"
enum
"
"
sfixed32
"
"
sfixed64
"
"
sint32
"
"
sint64
"
}
;
const
char
*
const
FieldDescriptor
:
:
kCppTypeToName
[
MAX_CPPTYPE
+
1
]
=
{
"
ERROR
"
"
int32
"
"
int64
"
"
uint32
"
"
uint64
"
"
double
"
"
float
"
"
bool
"
"
enum
"
"
string
"
"
message
"
}
;
const
char
*
const
FieldDescriptor
:
:
kLabelToName
[
MAX_LABEL
+
1
]
=
{
"
ERROR
"
"
optional
"
"
required
"
"
repeated
"
}
;
const
char
*
FileDescriptor
:
:
SyntaxName
(
FileDescriptor
:
:
Syntax
syntax
)
{
switch
(
syntax
)
{
case
SYNTAX_PROTO2
:
return
"
proto2
"
;
case
SYNTAX_PROTO3
:
return
"
proto3
"
;
case
SYNTAX_UNKNOWN
:
return
"
unknown
"
;
}
GOOGLE_LOG
(
FATAL
)
<
<
"
can
'
t
reach
here
.
"
;
return
nullptr
;
}
static
const
char
*
const
kNonLinkedWeakMessageReplacementName
=
"
google
.
protobuf
.
Empty
"
;
#
if
!
defined
(
_MSC_VER
)
|
|
_MSC_VER
>
=
1900
const
int
FieldDescriptor
:
:
kMaxNumber
;
const
int
FieldDescriptor
:
:
kFirstReservedNumber
;
const
int
FieldDescriptor
:
:
kLastReservedNumber
;
#
endif
namespace
{
char
ToUpper
(
char
ch
)
{
return
(
ch
>
=
'
a
'
&
&
ch
<
=
'
z
'
)
?
(
ch
-
'
a
'
+
'
A
'
)
:
ch
;
}
char
ToLower
(
char
ch
)
{
return
(
ch
>
=
'
A
'
&
&
ch
<
=
'
Z
'
)
?
(
ch
-
'
A
'
+
'
a
'
)
:
ch
;
}
std
:
:
string
ToCamelCase
(
const
std
:
:
string
&
input
bool
lower_first
)
{
bool
capitalize_next
=
!
lower_first
;
std
:
:
string
result
;
result
.
reserve
(
input
.
size
(
)
)
;
for
(
int
i
=
0
;
i
<
input
.
size
(
)
;
i
+
+
)
{
if
(
input
[
i
]
=
=
'
_
'
)
{
capitalize_next
=
true
;
}
else
if
(
capitalize_next
)
{
result
.
push_back
(
ToUpper
(
input
[
i
]
)
)
;
capitalize_next
=
false
;
}
else
{
result
.
push_back
(
input
[
i
]
)
;
}
}
if
(
lower_first
&
&
!
result
.
empty
(
)
)
{
result
[
0
]
=
ToLower
(
result
[
0
]
)
;
}
return
result
;
}
std
:
:
string
ToJsonName
(
const
std
:
:
string
&
input
)
{
bool
capitalize_next
=
false
;
std
:
:
string
result
;
result
.
reserve
(
input
.
size
(
)
)
;
for
(
int
i
=
0
;
i
<
input
.
size
(
)
;
i
+
+
)
{
if
(
input
[
i
]
=
=
'
_
'
)
{
capitalize_next
=
true
;
}
else
if
(
capitalize_next
)
{
result
.
push_back
(
ToUpper
(
input
[
i
]
)
)
;
capitalize_next
=
false
;
}
else
{
result
.
push_back
(
input
[
i
]
)
;
}
}
return
result
;
}
std
:
:
string
EnumValueToPascalCase
(
const
std
:
:
string
&
input
)
{
bool
next_upper
=
true
;
std
:
:
string
result
;
result
.
reserve
(
input
.
size
(
)
)
;
for
(
int
i
=
0
;
i
<
input
.
size
(
)
;
i
+
+
)
{
if
(
input
[
i
]
=
=
'
_
'
)
{
next_upper
=
true
;
}
else
{
if
(
next_upper
)
{
result
.
push_back
(
ToUpper
(
input
[
i
]
)
)
;
}
else
{
result
.
push_back
(
ToLower
(
input
[
i
]
)
)
;
}
next_upper
=
false
;
}
}
return
result
;
}
class
PrefixRemover
{
public
:
PrefixRemover
(
StringPiece
prefix
)
{
for
(
int
i
=
0
;
i
<
prefix
.
size
(
)
;
i
+
+
)
{
if
(
prefix
[
i
]
!
=
'
_
'
)
{
prefix_
+
=
ascii_tolower
(
prefix
[
i
]
)
;
}
}
}
std
:
:
string
MaybeRemove
(
StringPiece
str
)
{
size_t
i
j
;
for
(
i
=
0
j
=
0
;
i
<
str
.
size
(
)
&
&
j
<
prefix_
.
size
(
)
;
i
+
+
)
{
if
(
str
[
i
]
=
=
'
_
'
)
{
continue
;
}
if
(
ascii_tolower
(
str
[
i
]
)
!
=
prefix_
[
j
+
+
]
)
{
return
std
:
:
string
(
str
)
;
}
}
if
(
j
<
prefix_
.
size
(
)
)
{
return
std
:
:
string
(
str
)
;
}
while
(
i
<
str
.
size
(
)
&
&
str
[
i
]
=
=
'
_
'
)
{
i
+
+
;
}
if
(
i
=
=
str
.
size
(
)
)
{
return
std
:
:
string
(
str
)
;
}
str
.
remove_prefix
(
i
)
;
return
std
:
:
string
(
str
)
;
}
private
:
std
:
:
string
prefix_
;
}
;
typedef
std
:
:
pair
<
const
void
*
const
char
*
>
PointerStringPair
;
struct
PointerStringPairEqual
{
inline
bool
operator
(
)
(
const
PointerStringPair
&
a
const
PointerStringPair
&
b
)
const
{
return
a
.
first
=
=
b
.
first
&
&
strcmp
(
a
.
second
b
.
second
)
=
=
0
;
}
}
;
typedef
std
:
:
pair
<
const
Descriptor
*
int
>
DescriptorIntPair
;
typedef
std
:
:
pair
<
const
EnumDescriptor
*
int
>
EnumIntPair
;
#
define
HASH_MAP
std
:
:
unordered_map
#
define
HASH_SET
std
:
:
unordered_set
#
define
HASH_FXN
hash
template
<
typename
PairType
>
struct
PointerIntegerPairHash
{
size_t
operator
(
)
(
const
PairType
&
p
)
const
{
static
const
size_t
prime1
=
16777499
;
static
const
size_t
prime2
=
16777619
;
return
reinterpret_cast
<
size_t
>
(
p
.
first
)
*
prime1
^
static_cast
<
size_t
>
(
p
.
second
)
*
prime2
;
}
#
ifdef
_MSC_VER
static
const
size_t
bucket_size
=
4
;
static
const
size_t
min_buckets
=
8
;
#
endif
inline
bool
operator
(
)
(
const
PairType
&
a
const
PairType
&
b
)
const
{
return
a
.
first
<
b
.
first
|
|
(
a
.
first
=
=
b
.
first
&
&
a
.
second
<
b
.
second
)
;
}
}
;
struct
PointerStringPairHash
{
size_t
operator
(
)
(
const
PointerStringPair
&
p
)
const
{
static
const
size_t
prime
=
16777619
;
hash
<
const
char
*
>
cstring_hash
;
return
reinterpret_cast
<
size_t
>
(
p
.
first
)
*
prime
^
static_cast
<
size_t
>
(
cstring_hash
(
p
.
second
)
)
;
}
#
ifdef
_MSC_VER
static
const
size_t
bucket_size
=
4
;
static
const
size_t
min_buckets
=
8
;
#
endif
inline
bool
operator
(
)
(
const
PointerStringPair
&
a
const
PointerStringPair
&
b
)
const
{
if
(
a
.
first
<
b
.
first
)
return
true
;
if
(
a
.
first
>
b
.
first
)
return
false
;
return
strcmp
(
a
.
second
b
.
second
)
<
0
;
}
}
;
const
Symbol
kNullSymbol
;
typedef
HASH_MAP
<
const
char
*
Symbol
HASH_FXN
<
const
char
*
>
streq
>
SymbolsByNameMap
;
typedef
HASH_MAP
<
PointerStringPair
Symbol
PointerStringPairHash
PointerStringPairEqual
>
SymbolsByParentMap
;
typedef
HASH_MAP
<
const
char
*
const
FileDescriptor
*
HASH_FXN
<
const
char
*
>
streq
>
FilesByNameMap
;
typedef
HASH_MAP
<
PointerStringPair
const
FieldDescriptor
*
PointerStringPairHash
PointerStringPairEqual
>
FieldsByNameMap
;
typedef
HASH_MAP
<
DescriptorIntPair
const
FieldDescriptor
*
PointerIntegerPairHash
<
DescriptorIntPair
>
std
:
:
equal_to
<
DescriptorIntPair
>
>
FieldsByNumberMap
;
typedef
HASH_MAP
<
EnumIntPair
const
EnumValueDescriptor
*
PointerIntegerPairHash
<
EnumIntPair
>
std
:
:
equal_to
<
EnumIntPair
>
>
EnumValuesByNumberMap
;
typedef
std
:
:
map
<
DescriptorIntPair
const
FieldDescriptor
*
>
ExtensionsGroupedByDescriptorMap
;
typedef
HASH_MAP
<
std
:
:
string
const
SourceCodeInfo_Location
*
>
LocationsByPathMap
;
std
:
:
set
<
std
:
:
string
>
*
NewAllowedProto3Extendee
(
)
{
auto
allowed_proto3_extendees
=
new
std
:
:
set
<
std
:
:
string
>
;
const
char
*
kOptionNames
[
]
=
{
"
FileOptions
"
"
MessageOptions
"
"
FieldOptions
"
"
EnumOptions
"
"
EnumValueOptions
"
"
ServiceOptions
"
"
MethodOptions
"
"
OneofOptions
"
}
;
for
(
int
i
=
0
;
i
<
GOOGLE_ARRAYSIZE
(
kOptionNames
)
;
+
+
i
)
{
allowed_proto3_extendees
-
>
insert
(
std
:
:
string
(
"
google
.
protobuf
.
"
)
+
kOptionNames
[
i
]
)
;
allowed_proto3_extendees
-
>
insert
(
std
:
:
string
(
"
proto
"
)
+
"
2
.
"
+
kOptionNames
[
i
]
)
;
}
return
allowed_proto3_extendees
;
}
bool
AllowedExtendeeInProto3
(
const
std
:
:
string
&
name
)
{
static
auto
allowed_proto3_extendees
=
internal
:
:
OnShutdownDelete
(
NewAllowedProto3Extendee
(
)
)
;
return
allowed_proto3_extendees
-
>
find
(
name
)
!
=
allowed_proto3_extendees
-
>
end
(
)
;
}
}
class
DescriptorPool
:
:
Tables
{
public
:
Tables
(
)
;
~
Tables
(
)
;
void
AddCheckpoint
(
)
;
void
ClearLastCheckpoint
(
)
;
void
RollbackToLastCheckpoint
(
)
;
std
:
:
vector
<
std
:
:
string
>
pending_files_
;
HASH_SET
<
std
:
:
string
>
known_bad_files_
;
HASH_SET
<
std
:
:
string
>
known_bad_symbols_
;
HASH_SET
<
const
Descriptor
*
>
extensions_loaded_from_db_
;
inline
Symbol
FindSymbol
(
const
std
:
:
string
&
key
)
const
;
Symbol
FindByNameHelper
(
const
DescriptorPool
*
pool
const
std
:
:
string
&
name
)
;
inline
const
FileDescriptor
*
FindFile
(
const
std
:
:
string
&
key
)
const
;
inline
const
FieldDescriptor
*
FindExtension
(
const
Descriptor
*
extendee
int
number
)
const
;
inline
void
FindAllExtensions
(
const
Descriptor
*
extendee
std
:
:
vector
<
const
FieldDescriptor
*
>
*
out
)
const
;
bool
AddSymbol
(
const
std
:
:
string
&
full_name
Symbol
symbol
)
;
bool
AddFile
(
const
FileDescriptor
*
file
)
;
bool
AddExtension
(
const
FieldDescriptor
*
field
)
;
template
<
typename
Type
>
Type
*
Allocate
(
)
;
template
<
typename
Type
>
Type
*
AllocateArray
(
int
count
)
;
std
:
:
string
*
AllocateString
(
const
std
:
:
string
&
value
)
;
std
:
:
string
*
AllocateEmptyString
(
)
;
internal
:
:
once_flag
*
AllocateOnceDynamic
(
)
;
template
<
typename
Type
>
Type
*
AllocateMessage
(
Type
*
dummy
=
nullptr
)
;
FileDescriptorTables
*
AllocateFileTables
(
)
;
private
:
std
:
:
vector
<
std
:
:
unique_ptr
<
char
[
]
>
>
allocations_
;
std
:
:
vector
<
std
:
:
unique_ptr
<
std
:
:
string
>
>
strings_
;
std
:
:
vector
<
std
:
:
unique_ptr
<
Message
>
>
messages_
;
std
:
:
vector
<
std
:
:
unique_ptr
<
internal
:
:
once_flag
>
>
once_dynamics_
;
std
:
:
vector
<
std
:
:
unique_ptr
<
FileDescriptorTables
>
>
file_tables_
;
SymbolsByNameMap
symbols_by_name_
;
FilesByNameMap
files_by_name_
;
ExtensionsGroupedByDescriptorMap
extensions_
;
struct
CheckPoint
{
explicit
CheckPoint
(
const
Tables
*
tables
)
:
strings_before_checkpoint
(
tables
-
>
strings_
.
size
(
)
)
messages_before_checkpoint
(
tables
-
>
messages_
.
size
(
)
)
once_dynamics_before_checkpoint
(
tables
-
>
once_dynamics_
.
size
(
)
)
file_tables_before_checkpoint
(
tables
-
>
file_tables_
.
size
(
)
)
allocations_before_checkpoint
(
tables
-
>
allocations_
.
size
(
)
)
pending_symbols_before_checkpoint
(
tables
-
>
symbols_after_checkpoint_
.
size
(
)
)
pending_files_before_checkpoint
(
tables
-
>
files_after_checkpoint_
.
size
(
)
)
pending_extensions_before_checkpoint
(
tables
-
>
extensions_after_checkpoint_
.
size
(
)
)
{
}
int
strings_before_checkpoint
;
int
messages_before_checkpoint
;
int
once_dynamics_before_checkpoint
;
int
file_tables_before_checkpoint
;
int
allocations_before_checkpoint
;
int
pending_symbols_before_checkpoint
;
int
pending_files_before_checkpoint
;
int
pending_extensions_before_checkpoint
;
}
;
std
:
:
vector
<
CheckPoint
>
checkpoints_
;
std
:
:
vector
<
const
char
*
>
symbols_after_checkpoint_
;
std
:
:
vector
<
const
char
*
>
files_after_checkpoint_
;
std
:
:
vector
<
DescriptorIntPair
>
extensions_after_checkpoint_
;
void
*
AllocateBytes
(
int
size
)
;
}
;
class
FileDescriptorTables
{
public
:
FileDescriptorTables
(
)
;
~
FileDescriptorTables
(
)
;
inline
static
const
FileDescriptorTables
&
GetEmptyInstance
(
)
;
inline
Symbol
FindNestedSymbol
(
const
void
*
parent
const
std
:
:
string
&
name
)
const
;
inline
Symbol
FindNestedSymbolOfType
(
const
void
*
parent
const
std
:
:
string
&
name
const
Symbol
:
:
Type
type
)
const
;
inline
const
FieldDescriptor
*
FindFieldByNumber
(
const
Descriptor
*
parent
int
number
)
const
;
inline
const
FieldDescriptor
*
FindFieldByLowercaseName
(
const
void
*
parent
const
std
:
:
string
&
lowercase_name
)
const
;
inline
const
FieldDescriptor
*
FindFieldByCamelcaseName
(
const
void
*
parent
const
std
:
:
string
&
camelcase_name
)
const
;
inline
const
EnumValueDescriptor
*
FindEnumValueByNumber
(
const
EnumDescriptor
*
parent
int
number
)
const
;
inline
const
EnumValueDescriptor
*
FindEnumValueByNumberCreatingIfUnknown
(
const
EnumDescriptor
*
parent
int
number
)
const
;
bool
AddAliasUnderParent
(
const
void
*
parent
const
std
:
:
string
&
name
Symbol
symbol
)
;
bool
AddFieldByNumber
(
const
FieldDescriptor
*
field
)
;
bool
AddEnumValueByNumber
(
const
EnumValueDescriptor
*
value
)
;
void
AddFieldByStylizedNames
(
const
FieldDescriptor
*
field
)
;
static
void
BuildLocationsByPath
(
std
:
:
pair
<
const
FileDescriptorTables
*
const
SourceCodeInfo
*
>
*
p
)
;
const
SourceCodeInfo_Location
*
GetSourceLocation
(
const
std
:
:
vector
<
int
>
&
path
const
SourceCodeInfo
*
info
)
const
;
void
FinalizeTables
(
)
;
private
:
const
void
*
FindParentForFieldsByMap
(
const
FieldDescriptor
*
field
)
const
;
static
void
FieldsByLowercaseNamesLazyInitStatic
(
const
FileDescriptorTables
*
tables
)
;
void
FieldsByLowercaseNamesLazyInitInternal
(
)
const
;
static
void
FieldsByCamelcaseNamesLazyInitStatic
(
const
FileDescriptorTables
*
tables
)
;
void
FieldsByCamelcaseNamesLazyInitInternal
(
)
const
;
SymbolsByParentMap
symbols_by_parent_
;
mutable
FieldsByNameMap
fields_by_lowercase_name_
;
std
:
:
unique_ptr
<
FieldsByNameMap
>
fields_by_lowercase_name_tmp_
;
mutable
internal
:
:
once_flag
fields_by_lowercase_name_once_
;
mutable
FieldsByNameMap
fields_by_camelcase_name_
;
std
:
:
unique_ptr
<
FieldsByNameMap
>
fields_by_camelcase_name_tmp_
;
mutable
internal
:
:
once_flag
fields_by_camelcase_name_once_
;
FieldsByNumberMap
fields_by_number_
;
EnumValuesByNumberMap
enum_values_by_number_
;
mutable
EnumValuesByNumberMap
unknown_enum_values_by_number_
PROTOBUF_GUARDED_BY
(
unknown_enum_values_mu_
)
;
mutable
internal
:
:
once_flag
locations_by_path_once_
;
mutable
LocationsByPathMap
locations_by_path_
;
mutable
internal
:
:
WrappedMutex
unknown_enum_values_mu_
;
}
;
DescriptorPool
:
:
Tables
:
:
Tables
(
)
:
known_bad_files_
(
3
)
known_bad_symbols_
(
3
)
extensions_loaded_from_db_
(
3
)
symbols_by_name_
(
3
)
files_by_name_
(
3
)
{
}
DescriptorPool
:
:
Tables
:
:
~
Tables
(
)
{
GOOGLE_DCHECK
(
checkpoints_
.
empty
(
)
)
;
}
FileDescriptorTables
:
:
FileDescriptorTables
(
)
:
symbols_by_parent_
(
3
)
fields_by_lowercase_name_
(
3
)
fields_by_lowercase_name_tmp_
(
new
FieldsByNameMap
(
)
)
fields_by_camelcase_name_
(
3
)
fields_by_camelcase_name_tmp_
(
new
FieldsByNameMap
(
)
)
fields_by_number_
(
3
)
enum_values_by_number_
(
3
)
unknown_enum_values_by_number_
(
3
)
locations_by_path_
(
3
)
{
}
FileDescriptorTables
:
:
~
FileDescriptorTables
(
)
{
}
inline
const
FileDescriptorTables
&
FileDescriptorTables
:
:
GetEmptyInstance
(
)
{
static
auto
file_descriptor_tables
=
internal
:
:
OnShutdownDelete
(
new
FileDescriptorTables
(
)
)
;
return
*
file_descriptor_tables
;
}
void
DescriptorPool
:
:
Tables
:
:
AddCheckpoint
(
)
{
checkpoints_
.
push_back
(
CheckPoint
(
this
)
)
;
}
void
DescriptorPool
:
:
Tables
:
:
ClearLastCheckpoint
(
)
{
GOOGLE_DCHECK
(
!
checkpoints_
.
empty
(
)
)
;
checkpoints_
.
pop_back
(
)
;
if
(
checkpoints_
.
empty
(
)
)
{
symbols_after_checkpoint_
.
clear
(
)
;
files_after_checkpoint_
.
clear
(
)
;
extensions_after_checkpoint_
.
clear
(
)
;
}
}
void
DescriptorPool
:
:
Tables
:
:
RollbackToLastCheckpoint
(
)
{
GOOGLE_DCHECK
(
!
checkpoints_
.
empty
(
)
)
;
const
CheckPoint
&
checkpoint
=
checkpoints_
.
back
(
)
;
for
(
int
i
=
checkpoint
.
pending_symbols_before_checkpoint
;
i
<
symbols_after_checkpoint_
.
size
(
)
;
i
+
+
)
{
symbols_by_name_
.
erase
(
symbols_after_checkpoint_
[
i
]
)
;
}
for
(
int
i
=
checkpoint
.
pending_files_before_checkpoint
;
i
<
files_after_checkpoint_
.
size
(
)
;
i
+
+
)
{
files_by_name_
.
erase
(
files_after_checkpoint_
[
i
]
)
;
}
for
(
int
i
=
checkpoint
.
pending_extensions_before_checkpoint
;
i
<
extensions_after_checkpoint_
.
size
(
)
;
i
+
+
)
{
extensions_
.
erase
(
extensions_after_checkpoint_
[
i
]
)
;
}
symbols_after_checkpoint_
.
resize
(
checkpoint
.
pending_symbols_before_checkpoint
)
;
files_after_checkpoint_
.
resize
(
checkpoint
.
pending_files_before_checkpoint
)
;
extensions_after_checkpoint_
.
resize
(
checkpoint
.
pending_extensions_before_checkpoint
)
;
strings_
.
resize
(
checkpoint
.
strings_before_checkpoint
)
;
messages_
.
resize
(
checkpoint
.
messages_before_checkpoint
)
;
once_dynamics_
.
resize
(
checkpoint
.
once_dynamics_before_checkpoint
)
;
file_tables_
.
resize
(
checkpoint
.
file_tables_before_checkpoint
)
;
allocations_
.
resize
(
checkpoint
.
allocations_before_checkpoint
)
;
checkpoints_
.
pop_back
(
)
;
}
inline
Symbol
DescriptorPool
:
:
Tables
:
:
FindSymbol
(
const
std
:
:
string
&
key
)
const
{
const
Symbol
*
result
=
FindOrNull
(
symbols_by_name_
key
.
c_str
(
)
)
;
if
(
result
=
=
nullptr
)
{
return
kNullSymbol
;
}
else
{
return
*
result
;
}
}
inline
Symbol
FileDescriptorTables
:
:
FindNestedSymbol
(
const
void
*
parent
const
std
:
:
string
&
name
)
const
{
const
Symbol
*
result
=
FindOrNull
(
symbols_by_parent_
PointerStringPair
(
parent
name
.
c_str
(
)
)
)
;
if
(
result
=
=
nullptr
)
{
return
kNullSymbol
;
}
else
{
return
*
result
;
}
}
inline
Symbol
FileDescriptorTables
:
:
FindNestedSymbolOfType
(
const
void
*
parent
const
std
:
:
string
&
name
const
Symbol
:
:
Type
type
)
const
{
Symbol
result
=
FindNestedSymbol
(
parent
name
)
;
if
(
result
.
type
!
=
type
)
return
kNullSymbol
;
return
result
;
}
Symbol
DescriptorPool
:
:
Tables
:
:
FindByNameHelper
(
const
DescriptorPool
*
pool
const
std
:
:
string
&
name
)
{
if
(
pool
-
>
mutex_
!
=
nullptr
)
{
ReaderMutexLock
lock
(
pool
-
>
mutex_
)
;
if
(
known_bad_symbols_
.
empty
(
)
&
&
known_bad_files_
.
empty
(
)
)
{
Symbol
result
=
FindSymbol
(
name
)
;
if
(
!
result
.
IsNull
(
)
)
return
result
;
}
}
MutexLockMaybe
lock
(
pool
-
>
mutex_
)
;
if
(
pool
-
>
fallback_database_
!
=
nullptr
)
{
known_bad_symbols_
.
clear
(
)
;
known_bad_files_
.
clear
(
)
;
}
Symbol
result
=
FindSymbol
(
name
)
;
if
(
result
.
IsNull
(
)
&
&
pool
-
>
underlay_
!
=
nullptr
)
{
result
=
pool
-
>
underlay_
-
>
tables_
-
>
FindByNameHelper
(
pool
-
>
underlay_
name
)
;
}
if
(
result
.
IsNull
(
)
)
{
if
(
pool
-
>
TryFindSymbolInFallbackDatabase
(
name
)
)
{
result
=
FindSymbol
(
name
)
;
}
}
return
result
;
}
inline
const
FileDescriptor
*
DescriptorPool
:
:
Tables
:
:
FindFile
(
const
std
:
:
string
&
key
)
const
{
return
FindPtrOrNull
(
files_by_name_
key
.
c_str
(
)
)
;
}
inline
const
FieldDescriptor
*
FileDescriptorTables
:
:
FindFieldByNumber
(
const
Descriptor
*
parent
int
number
)
const
{
return
FindPtrOrNull
(
fields_by_number_
std
:
:
make_pair
(
parent
number
)
)
;
}
const
void
*
FileDescriptorTables
:
:
FindParentForFieldsByMap
(
const
FieldDescriptor
*
field
)
const
{
if
(
field
-
>
is_extension
(
)
)
{
if
(
field
-
>
extension_scope
(
)
=
=
nullptr
)
{
return
field
-
>
file
(
)
;
}
else
{
return
field
-
>
extension_scope
(
)
;
}
}
else
{
return
field
-
>
containing_type
(
)
;
}
}
void
FileDescriptorTables
:
:
FieldsByLowercaseNamesLazyInitStatic
(
const
FileDescriptorTables
*
tables
)
{
tables
-
>
FieldsByLowercaseNamesLazyInitInternal
(
)
;
}
void
FileDescriptorTables
:
:
FieldsByLowercaseNamesLazyInitInternal
(
)
const
{
for
(
FieldsByNumberMap
:
:
const_iterator
it
=
fields_by_number_
.
begin
(
)
;
it
!
=
fields_by_number_
.
end
(
)
;
it
+
+
)
{
PointerStringPair
lowercase_key
(
FindParentForFieldsByMap
(
it
-
>
second
)
it
-
>
second
-
>
lowercase_name
(
)
.
c_str
(
)
)
;
InsertIfNotPresent
(
&
fields_by_lowercase_name_
lowercase_key
it
-
>
second
)
;
}
}
inline
const
FieldDescriptor
*
FileDescriptorTables
:
:
FindFieldByLowercaseName
(
const
void
*
parent
const
std
:
:
string
&
lowercase_name
)
const
{
internal
:
:
call_once
(
fields_by_lowercase_name_once_
&
FileDescriptorTables
:
:
FieldsByLowercaseNamesLazyInitStatic
this
)
;
return
FindPtrOrNull
(
fields_by_lowercase_name_
PointerStringPair
(
parent
lowercase_name
.
c_str
(
)
)
)
;
}
void
FileDescriptorTables
:
:
FieldsByCamelcaseNamesLazyInitStatic
(
const
FileDescriptorTables
*
tables
)
{
tables
-
>
FieldsByCamelcaseNamesLazyInitInternal
(
)
;
}
void
FileDescriptorTables
:
:
FieldsByCamelcaseNamesLazyInitInternal
(
)
const
{
for
(
FieldsByNumberMap
:
:
const_iterator
it
=
fields_by_number_
.
begin
(
)
;
it
!
=
fields_by_number_
.
end
(
)
;
it
+
+
)
{
PointerStringPair
camelcase_key
(
FindParentForFieldsByMap
(
it
-
>
second
)
it
-
>
second
-
>
camelcase_name
(
)
.
c_str
(
)
)
;
InsertIfNotPresent
(
&
fields_by_camelcase_name_
camelcase_key
it
-
>
second
)
;
}
}
inline
const
FieldDescriptor
*
FileDescriptorTables
:
:
FindFieldByCamelcaseName
(
const
void
*
parent
const
std
:
:
string
&
camelcase_name
)
const
{
internal
:
:
call_once
(
fields_by_camelcase_name_once_
FileDescriptorTables
:
:
FieldsByCamelcaseNamesLazyInitStatic
this
)
;
return
FindPtrOrNull
(
fields_by_camelcase_name_
PointerStringPair
(
parent
camelcase_name
.
c_str
(
)
)
)
;
}
inline
const
EnumValueDescriptor
*
FileDescriptorTables
:
:
FindEnumValueByNumber
(
const
EnumDescriptor
*
parent
int
number
)
const
{
return
FindPtrOrNull
(
enum_values_by_number_
std
:
:
make_pair
(
parent
number
)
)
;
}
inline
const
EnumValueDescriptor
*
FileDescriptorTables
:
:
FindEnumValueByNumberCreatingIfUnknown
(
const
EnumDescriptor
*
parent
int
number
)
const
{
{
const
EnumValueDescriptor
*
desc
=
FindPtrOrNull
(
enum_values_by_number_
std
:
:
make_pair
(
parent
number
)
)
;
if
(
desc
!
=
nullptr
)
{
return
desc
;
}
}
{
ReaderMutexLock
l
(
&
unknown_enum_values_mu_
)
;
const
EnumValueDescriptor
*
desc
=
FindPtrOrNull
(
unknown_enum_values_by_number_
std
:
:
make_pair
(
parent
number
)
)
;
if
(
desc
!
=
nullptr
)
{
return
desc
;
}
}
{
WriterMutexLock
l
(
&
unknown_enum_values_mu_
)
;
const
EnumValueDescriptor
*
desc
=
FindPtrOrNull
(
unknown_enum_values_by_number_
std
:
:
make_pair
(
parent
number
)
)
;
if
(
desc
!
=
nullptr
)
{
return
desc
;
}
std
:
:
string
enum_value_name
=
StringPrintf
(
"
UNKNOWN_ENUM_VALUE_
%
s_
%
d
"
parent
-
>
name
(
)
.
c_str
(
)
number
)
;
DescriptorPool
:
:
Tables
*
tables
=
const_cast
<
DescriptorPool
:
:
Tables
*
>
(
DescriptorPool
:
:
generated_pool
(
)
-
>
tables_
.
get
(
)
)
;
EnumValueDescriptor
*
result
=
tables
-
>
Allocate
<
EnumValueDescriptor
>
(
)
;
result
-
>
name_
=
tables
-
>
AllocateString
(
enum_value_name
)
;
result
-
>
full_name_
=
tables
-
>
AllocateString
(
parent
-
>
full_name
(
)
+
"
.
"
+
enum_value_name
)
;
result
-
>
number_
=
number
;
result
-
>
type_
=
parent
;
result
-
>
options_
=
&
EnumValueOptions
:
:
default_instance
(
)
;
InsertIfNotPresent
(
&
unknown_enum_values_by_number_
std
:
:
make_pair
(
parent
number
)
result
)
;
return
result
;
}
}
inline
const
FieldDescriptor
*
DescriptorPool
:
:
Tables
:
:
FindExtension
(
const
Descriptor
*
extendee
int
number
)
const
{
return
FindPtrOrNull
(
extensions_
std
:
:
make_pair
(
extendee
number
)
)
;
}
inline
void
DescriptorPool
:
:
Tables
:
:
FindAllExtensions
(
const
Descriptor
*
extendee
std
:
:
vector
<
const
FieldDescriptor
*
>
*
out
)
const
{
ExtensionsGroupedByDescriptorMap
:
:
const_iterator
it
=
extensions_
.
lower_bound
(
std
:
:
make_pair
(
extendee
0
)
)
;
for
(
;
it
!
=
extensions_
.
end
(
)
&
&
it
-
>
first
.
first
=
=
extendee
;
+
+
it
)
{
out
-
>
push_back
(
it
-
>
second
)
;
}
}
bool
DescriptorPool
:
:
Tables
:
:
AddSymbol
(
const
std
:
:
string
&
full_name
Symbol
symbol
)
{
if
(
InsertIfNotPresent
(
&
symbols_by_name_
full_name
.
c_str
(
)
symbol
)
)
{
symbols_after_checkpoint_
.
push_back
(
full_name
.
c_str
(
)
)
;
return
true
;
}
else
{
return
false
;
}
}
bool
FileDescriptorTables
:
:
AddAliasUnderParent
(
const
void
*
parent
const
std
:
:
string
&
name
Symbol
symbol
)
{
PointerStringPair
by_parent_key
(
parent
name
.
c_str
(
)
)
;
return
InsertIfNotPresent
(
&
symbols_by_parent_
by_parent_key
symbol
)
;
}
bool
DescriptorPool
:
:
Tables
:
:
AddFile
(
const
FileDescriptor
*
file
)
{
if
(
InsertIfNotPresent
(
&
files_by_name_
file
-
>
name
(
)
.
c_str
(
)
file
)
)
{
files_after_checkpoint_
.
push_back
(
file
-
>
name
(
)
.
c_str
(
)
)
;
return
true
;
}
else
{
return
false
;
}
}
void
FileDescriptorTables
:
:
FinalizeTables
(
)
{
fields_by_lowercase_name_tmp_
=
nullptr
;
fields_by_camelcase_name_tmp_
=
nullptr
;
}
void
FileDescriptorTables
:
:
AddFieldByStylizedNames
(
const
FieldDescriptor
*
field
)
{
const
void
*
parent
=
FindParentForFieldsByMap
(
field
)
;
PointerStringPair
lowercase_key
(
parent
field
-
>
lowercase_name
(
)
.
c_str
(
)
)
;
if
(
!
InsertIfNotPresent
(
fields_by_lowercase_name_tmp_
.
get
(
)
lowercase_key
field
)
)
{
InsertIfNotPresent
(
&
fields_by_lowercase_name_
lowercase_key
FindPtrOrNull
(
*
fields_by_lowercase_name_tmp_
lowercase_key
)
)
;
}
PointerStringPair
camelcase_key
(
parent
field
-
>
camelcase_name
(
)
.
c_str
(
)
)
;
if
(
!
InsertIfNotPresent
(
fields_by_camelcase_name_tmp_
.
get
(
)
camelcase_key
field
)
)
{
InsertIfNotPresent
(
&
fields_by_camelcase_name_
camelcase_key
FindPtrOrNull
(
*
fields_by_camelcase_name_tmp_
camelcase_key
)
)
;
}
}
bool
FileDescriptorTables
:
:
AddFieldByNumber
(
const
FieldDescriptor
*
field
)
{
DescriptorIntPair
key
(
field
-
>
containing_type
(
)
field
-
>
number
(
)
)
;
return
InsertIfNotPresent
(
&
fields_by_number_
key
field
)
;
}
bool
FileDescriptorTables
:
:
AddEnumValueByNumber
(
const
EnumValueDescriptor
*
value
)
{
EnumIntPair
key
(
value
-
>
type
(
)
value
-
>
number
(
)
)
;
return
InsertIfNotPresent
(
&
enum_values_by_number_
key
value
)
;
}
bool
DescriptorPool
:
:
Tables
:
:
AddExtension
(
const
FieldDescriptor
*
field
)
{
DescriptorIntPair
key
(
field
-
>
containing_type
(
)
field
-
>
number
(
)
)
;
if
(
InsertIfNotPresent
(
&
extensions_
key
field
)
)
{
extensions_after_checkpoint_
.
push_back
(
key
)
;
return
true
;
}
else
{
return
false
;
}
}
template
<
typename
Type
>
Type
*
DescriptorPool
:
:
Tables
:
:
Allocate
(
)
{
return
reinterpret_cast
<
Type
*
>
(
AllocateBytes
(
sizeof
(
Type
)
)
)
;
}
template
<
typename
Type
>
Type
*
DescriptorPool
:
:
Tables
:
:
AllocateArray
(
int
count
)
{
return
reinterpret_cast
<
Type
*
>
(
AllocateBytes
(
sizeof
(
Type
)
*
count
)
)
;
}
std
:
:
string
*
DescriptorPool
:
:
Tables
:
:
AllocateString
(
const
std
:
:
string
&
value
)
{
std
:
:
string
*
result
=
new
std
:
:
string
(
value
)
;
strings_
.
emplace_back
(
result
)
;
return
result
;
}
std
:
:
string
*
DescriptorPool
:
:
Tables
:
:
AllocateEmptyString
(
)
{
std
:
:
string
*
result
=
new
std
:
:
string
(
)
;
strings_
.
emplace_back
(
result
)
;
return
result
;
}
internal
:
:
once_flag
*
DescriptorPool
:
:
Tables
:
:
AllocateOnceDynamic
(
)
{
internal
:
:
once_flag
*
result
=
new
internal
:
:
once_flag
(
)
;
once_dynamics_
.
emplace_back
(
result
)
;
return
result
;
}
template
<
typename
Type
>
Type
*
DescriptorPool
:
:
Tables
:
:
AllocateMessage
(
Type
*
)
{
Type
*
result
=
new
Type
;
messages_
.
emplace_back
(
result
)
;
return
result
;
}
FileDescriptorTables
*
DescriptorPool
:
:
Tables
:
:
AllocateFileTables
(
)
{
FileDescriptorTables
*
result
=
new
FileDescriptorTables
;
file_tables_
.
emplace_back
(
result
)
;
return
result
;
}
void
*
DescriptorPool
:
:
Tables
:
:
AllocateBytes
(
int
size
)
{
if
(
size
=
=
0
)
return
nullptr
;
allocations_
.
emplace_back
(
new
char
[
size
]
)
;
return
allocations_
.
back
(
)
.
get
(
)
;
}
void
FileDescriptorTables
:
:
BuildLocationsByPath
(
std
:
:
pair
<
const
FileDescriptorTables
*
const
SourceCodeInfo
*
>
*
p
)
{
for
(
int
i
=
0
len
=
p
-
>
second
-
>
location_size
(
)
;
i
<
len
;
+
+
i
)
{
const
SourceCodeInfo_Location
*
loc
=
&
p
-
>
second
-
>
location
(
)
.
Get
(
i
)
;
p
-
>
first
-
>
locations_by_path_
[
Join
(
loc
-
>
path
(
)
"
"
)
]
=
loc
;
}
}
const
SourceCodeInfo_Location
*
FileDescriptorTables
:
:
GetSourceLocation
(
const
std
:
:
vector
<
int
>
&
path
const
SourceCodeInfo
*
info
)
const
{
std
:
:
pair
<
const
FileDescriptorTables
*
const
SourceCodeInfo
*
>
p
(
std
:
:
make_pair
(
this
info
)
)
;
internal
:
:
call_once
(
locations_by_path_once_
FileDescriptorTables
:
:
BuildLocationsByPath
&
p
)
;
return
FindPtrOrNull
(
locations_by_path_
Join
(
path
"
"
)
)
;
}
DescriptorPool
:
:
ErrorCollector
:
:
~
ErrorCollector
(
)
{
}
DescriptorPool
:
:
DescriptorPool
(
)
:
mutex_
(
nullptr
)
fallback_database_
(
nullptr
)
default_error_collector_
(
nullptr
)
underlay_
(
nullptr
)
tables_
(
new
Tables
)
enforce_dependencies_
(
true
)
lazily_build_dependencies_
(
false
)
allow_unknown_
(
false
)
enforce_weak_
(
false
)
disallow_enforce_utf8_
(
false
)
{
}
DescriptorPool
:
:
DescriptorPool
(
DescriptorDatabase
*
fallback_database
ErrorCollector
*
error_collector
)
:
mutex_
(
new
internal
:
:
WrappedMutex
)
fallback_database_
(
fallback_database
)
default_error_collector_
(
error_collector
)
underlay_
(
nullptr
)
tables_
(
new
Tables
)
enforce_dependencies_
(
true
)
lazily_build_dependencies_
(
false
)
allow_unknown_
(
false
)
enforce_weak_
(
false
)
disallow_enforce_utf8_
(
false
)
{
}
DescriptorPool
:
:
DescriptorPool
(
const
DescriptorPool
*
underlay
)
:
mutex_
(
nullptr
)
fallback_database_
(
nullptr
)
default_error_collector_
(
nullptr
)
underlay_
(
underlay
)
tables_
(
new
Tables
)
enforce_dependencies_
(
true
)
lazily_build_dependencies_
(
false
)
allow_unknown_
(
false
)
enforce_weak_
(
false
)
disallow_enforce_utf8_
(
false
)
{
}
DescriptorPool
:
:
~
DescriptorPool
(
)
{
if
(
mutex_
!
=
nullptr
)
delete
mutex_
;
}
void
DescriptorPool
:
:
InternalDontEnforceDependencies
(
)
{
enforce_dependencies_
=
false
;
}
void
DescriptorPool
:
:
AddUnusedImportTrackFile
(
const
std
:
:
string
&
file_name
)
{
unused_import_track_files_
.
insert
(
file_name
)
;
}
void
DescriptorPool
:
:
ClearUnusedImportTrackFiles
(
)
{
unused_import_track_files_
.
clear
(
)
;
}
bool
DescriptorPool
:
:
InternalIsFileLoaded
(
const
std
:
:
string
&
filename
)
const
{
MutexLockMaybe
lock
(
mutex_
)
;
return
tables_
-
>
FindFile
(
filename
)
!
=
nullptr
;
}
namespace
{
EncodedDescriptorDatabase
*
GeneratedDatabase
(
)
{
static
auto
generated_database
=
internal
:
:
OnShutdownDelete
(
new
EncodedDescriptorDatabase
(
)
)
;
return
generated_database
;
}
DescriptorPool
*
NewGeneratedPool
(
)
{
auto
generated_pool
=
new
DescriptorPool
(
GeneratedDatabase
(
)
)
;
generated_pool
-
>
InternalSetLazilyBuildDependencies
(
)
;
return
generated_pool
;
}
}
DescriptorPool
*
DescriptorPool
:
:
internal_generated_pool
(
)
{
static
DescriptorPool
*
generated_pool
=
internal
:
:
OnShutdownDelete
(
NewGeneratedPool
(
)
)
;
return
generated_pool
;
}
const
DescriptorPool
*
DescriptorPool
:
:
generated_pool
(
)
{
const
DescriptorPool
*
pool
=
internal_generated_pool
(
)
;
DescriptorProto
:
:
descriptor
(
)
;
return
pool
;
}
void
DescriptorPool
:
:
InternalAddGeneratedFile
(
const
void
*
encoded_file_descriptor
int
size
)
{
GOOGLE_CHECK
(
GeneratedDatabase
(
)
-
>
Add
(
encoded_file_descriptor
size
)
)
;
}
const
FileDescriptor
*
DescriptorPool
:
:
FindFileByName
(
const
std
:
:
string
&
name
)
const
{
MutexLockMaybe
lock
(
mutex_
)
;
if
(
fallback_database_
!
=
nullptr
)
{
tables_
-
>
known_bad_symbols_
.
clear
(
)
;
tables_
-
>
known_bad_files_
.
clear
(
)
;
}
const
FileDescriptor
*
result
=
tables_
-
>
FindFile
(
name
)
;
if
(
result
!
=
nullptr
)
return
result
;
if
(
underlay_
!
=
nullptr
)
{
result
=
underlay_
-
>
FindFileByName
(
name
)
;
if
(
result
!
=
nullptr
)
return
result
;
}
if
(
TryFindFileInFallbackDatabase
(
name
)
)
{
result
=
tables_
-
>
FindFile
(
name
)
;
if
(
result
!
=
nullptr
)
return
result
;
}
return
nullptr
;
}
const
FileDescriptor
*
DescriptorPool
:
:
FindFileContainingSymbol
(
const
std
:
:
string
&
symbol_name
)
const
{
MutexLockMaybe
lock
(
mutex_
)
;
if
(
fallback_database_
!
=
nullptr
)
{
tables_
-
>
known_bad_symbols_
.
clear
(
)
;
tables_
-
>
known_bad_files_
.
clear
(
)
;
}
Symbol
result
=
tables_
-
>
FindSymbol
(
symbol_name
)
;
if
(
!
result
.
IsNull
(
)
)
return
result
.
GetFile
(
)
;
if
(
underlay_
!
=
nullptr
)
{
const
FileDescriptor
*
file_result
=
underlay_
-
>
FindFileContainingSymbol
(
symbol_name
)
;
if
(
file_result
!
=
nullptr
)
return
file_result
;
}
if
(
TryFindSymbolInFallbackDatabase
(
symbol_name
)
)
{
result
=
tables_
-
>
FindSymbol
(
symbol_name
)
;
if
(
!
result
.
IsNull
(
)
)
return
result
.
GetFile
(
)
;
}
return
nullptr
;
}
const
Descriptor
*
DescriptorPool
:
:
FindMessageTypeByName
(
const
std
:
:
string
&
name
)
const
{
Symbol
result
=
tables_
-
>
FindByNameHelper
(
this
name
)
;
return
(
result
.
type
=
=
Symbol
:
:
MESSAGE
)
?
result
.
descriptor
:
nullptr
;
}
const
FieldDescriptor
*
DescriptorPool
:
:
FindFieldByName
(
const
std
:
:
string
&
name
)
const
{
Symbol
result
=
tables_
-
>
FindByNameHelper
(
this
name
)
;
if
(
result
.
type
=
=
Symbol
:
:
FIELD
&
&
!
result
.
field_descriptor
-
>
is_extension
(
)
)
{
return
result
.
field_descriptor
;
}
else
{
return
nullptr
;
}
}
const
FieldDescriptor
*
DescriptorPool
:
:
FindExtensionByName
(
const
std
:
:
string
&
name
)
const
{
Symbol
result
=
tables_
-
>
FindByNameHelper
(
this
name
)
;
if
(
result
.
type
=
=
Symbol
:
:
FIELD
&
&
result
.
field_descriptor
-
>
is_extension
(
)
)
{
return
result
.
field_descriptor
;
}
else
{
return
nullptr
;
}
}
const
OneofDescriptor
*
DescriptorPool
:
:
FindOneofByName
(
const
std
:
:
string
&
name
)
const
{
Symbol
result
=
tables_
-
>
FindByNameHelper
(
this
name
)
;
return
(
result
.
type
=
=
Symbol
:
:
ONEOF
)
?
result
.
oneof_descriptor
:
nullptr
;
}
const
EnumDescriptor
*
DescriptorPool
:
:
FindEnumTypeByName
(
const
std
:
:
string
&
name
)
const
{
Symbol
result
=
tables_
-
>
FindByNameHelper
(
this
name
)
;
return
(
result
.
type
=
=
Symbol
:
:
ENUM
)
?
result
.
enum_descriptor
:
nullptr
;
}
const
EnumValueDescriptor
*
DescriptorPool
:
:
FindEnumValueByName
(
const
std
:
:
string
&
name
)
const
{
Symbol
result
=
tables_
-
>
FindByNameHelper
(
this
name
)
;
return
(
result
.
type
=
=
Symbol
:
:
ENUM_VALUE
)
?
result
.
enum_value_descriptor
:
nullptr
;
}
const
ServiceDescriptor
*
DescriptorPool
:
:
FindServiceByName
(
const
std
:
:
string
&
name
)
const
{
Symbol
result
=
tables_
-
>
FindByNameHelper
(
this
name
)
;
return
(
result
.
type
=
=
Symbol
:
:
SERVICE
)
?
result
.
service_descriptor
:
nullptr
;
}
const
MethodDescriptor
*
DescriptorPool
:
:
FindMethodByName
(
const
std
:
:
string
&
name
)
const
{
Symbol
result
=
tables_
-
>
FindByNameHelper
(
this
name
)
;
return
(
result
.
type
=
=
Symbol
:
:
METHOD
)
?
result
.
method_descriptor
:
nullptr
;
}
const
FieldDescriptor
*
DescriptorPool
:
:
FindExtensionByNumber
(
const
Descriptor
*
extendee
int
number
)
const
{
if
(
extendee
-
>
extension_range_count
(
)
=
=
0
)
return
nullptr
;
if
(
mutex_
!
=
nullptr
)
{
ReaderMutexLock
lock
(
mutex_
)
;
const
FieldDescriptor
*
result
=
tables_
-
>
FindExtension
(
extendee
number
)
;
if
(
result
!
=
nullptr
)
{
return
result
;
}
}
MutexLockMaybe
lock
(
mutex_
)
;
if
(
fallback_database_
!
=
nullptr
)
{
tables_
-
>
known_bad_symbols_
.
clear
(
)
;
tables_
-
>
known_bad_files_
.
clear
(
)
;
}
const
FieldDescriptor
*
result
=
tables_
-
>
FindExtension
(
extendee
number
)
;
if
(
result
!
=
nullptr
)
{
return
result
;
}
if
(
underlay_
!
=
nullptr
)
{
result
=
underlay_
-
>
FindExtensionByNumber
(
extendee
number
)
;
if
(
result
!
=
nullptr
)
return
result
;
}
if
(
TryFindExtensionInFallbackDatabase
(
extendee
number
)
)
{
result
=
tables_
-
>
FindExtension
(
extendee
number
)
;
if
(
result
!
=
nullptr
)
{
return
result
;
}
}
return
nullptr
;
}
const
FieldDescriptor
*
DescriptorPool
:
:
InternalFindExtensionByNumberNoLock
(
const
Descriptor
*
extendee
int
number
)
const
{
if
(
extendee
-
>
extension_range_count
(
)
=
=
0
)
return
nullptr
;
const
FieldDescriptor
*
result
=
tables_
-
>
FindExtension
(
extendee
number
)
;
if
(
result
!
=
nullptr
)
{
return
result
;
}
if
(
underlay_
!
=
nullptr
)
{
result
=
underlay_
-
>
InternalFindExtensionByNumberNoLock
(
extendee
number
)
;
if
(
result
!
=
nullptr
)
return
result
;
}
return
nullptr
;
}
const
FieldDescriptor
*
DescriptorPool
:
:
FindExtensionByPrintableName
(
const
Descriptor
*
extendee
const
std
:
:
string
&
printable_name
)
const
{
if
(
extendee
-
>
extension_range_count
(
)
=
=
0
)
return
nullptr
;
const
FieldDescriptor
*
result
=
FindExtensionByName
(
printable_name
)
;
if
(
result
!
=
nullptr
&
&
result
-
>
containing_type
(
)
=
=
extendee
)
{
return
result
;
}
if
(
extendee
-
>
options
(
)
.
message_set_wire_format
(
)
)
{
const
Descriptor
*
type
=
FindMessageTypeByName
(
printable_name
)
;
if
(
type
!
=
nullptr
)
{
const
int
type_extension_count
=
type
-
>
extension_count
(
)
;
for
(
int
i
=
0
;
i
<
type_extension_count
;
i
+
+
)
{
const
FieldDescriptor
*
extension
=
type
-
>
extension
(
i
)
;
if
(
extension
-
>
containing_type
(
)
=
=
extendee
&
&
extension
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_MESSAGE
&
&
extension
-
>
is_optional
(
)
&
&
extension
-
>
message_type
(
)
=
=
type
)
{
return
extension
;
}
}
}
}
return
nullptr
;
}
void
DescriptorPool
:
:
FindAllExtensions
(
const
Descriptor
*
extendee
std
:
:
vector
<
const
FieldDescriptor
*
>
*
out
)
const
{
MutexLockMaybe
lock
(
mutex_
)
;
if
(
fallback_database_
!
=
nullptr
)
{
tables_
-
>
known_bad_symbols_
.
clear
(
)
;
tables_
-
>
known_bad_files_
.
clear
(
)
;
}
if
(
fallback_database_
!
=
nullptr
&
&
tables_
-
>
extensions_loaded_from_db_
.
count
(
extendee
)
=
=
0
)
{
std
:
:
vector
<
int
>
numbers
;
if
(
fallback_database_
-
>
FindAllExtensionNumbers
(
extendee
-
>
full_name
(
)
&
numbers
)
)
{
for
(
int
i
=
0
;
i
<
numbers
.
size
(
)
;
+
+
i
)
{
int
number
=
numbers
[
i
]
;
if
(
tables_
-
>
FindExtension
(
extendee
number
)
=
=
nullptr
)
{
TryFindExtensionInFallbackDatabase
(
extendee
number
)
;
}
}
tables_
-
>
extensions_loaded_from_db_
.
insert
(
extendee
)
;
}
}
tables_
-
>
FindAllExtensions
(
extendee
out
)
;
if
(
underlay_
!
=
nullptr
)
{
underlay_
-
>
FindAllExtensions
(
extendee
out
)
;
}
}
const
FieldDescriptor
*
Descriptor
:
:
FindFieldByNumber
(
int
key
)
const
{
const
FieldDescriptor
*
result
=
file
(
)
-
>
tables_
-
>
FindFieldByNumber
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
const
FieldDescriptor
*
Descriptor
:
:
FindFieldByLowercaseName
(
const
std
:
:
string
&
key
)
const
{
const
FieldDescriptor
*
result
=
file
(
)
-
>
tables_
-
>
FindFieldByLowercaseName
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
const
FieldDescriptor
*
Descriptor
:
:
FindFieldByCamelcaseName
(
const
std
:
:
string
&
key
)
const
{
const
FieldDescriptor
*
result
=
file
(
)
-
>
tables_
-
>
FindFieldByCamelcaseName
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
const
FieldDescriptor
*
Descriptor
:
:
FindFieldByName
(
const
std
:
:
string
&
key
)
const
{
Symbol
result
=
file
(
)
-
>
tables_
-
>
FindNestedSymbolOfType
(
this
key
Symbol
:
:
FIELD
)
;
if
(
!
result
.
IsNull
(
)
&
&
!
result
.
field_descriptor
-
>
is_extension
(
)
)
{
return
result
.
field_descriptor
;
}
else
{
return
nullptr
;
}
}
const
OneofDescriptor
*
Descriptor
:
:
FindOneofByName
(
const
std
:
:
string
&
key
)
const
{
Symbol
result
=
file
(
)
-
>
tables_
-
>
FindNestedSymbolOfType
(
this
key
Symbol
:
:
ONEOF
)
;
if
(
!
result
.
IsNull
(
)
)
{
return
result
.
oneof_descriptor
;
}
else
{
return
nullptr
;
}
}
const
FieldDescriptor
*
Descriptor
:
:
FindExtensionByName
(
const
std
:
:
string
&
key
)
const
{
Symbol
result
=
file
(
)
-
>
tables_
-
>
FindNestedSymbolOfType
(
this
key
Symbol
:
:
FIELD
)
;
if
(
!
result
.
IsNull
(
)
&
&
result
.
field_descriptor
-
>
is_extension
(
)
)
{
return
result
.
field_descriptor
;
}
else
{
return
nullptr
;
}
}
const
FieldDescriptor
*
Descriptor
:
:
FindExtensionByLowercaseName
(
const
std
:
:
string
&
key
)
const
{
const
FieldDescriptor
*
result
=
file
(
)
-
>
tables_
-
>
FindFieldByLowercaseName
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
!
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
const
FieldDescriptor
*
Descriptor
:
:
FindExtensionByCamelcaseName
(
const
std
:
:
string
&
key
)
const
{
const
FieldDescriptor
*
result
=
file
(
)
-
>
tables_
-
>
FindFieldByCamelcaseName
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
!
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
const
Descriptor
*
Descriptor
:
:
FindNestedTypeByName
(
const
std
:
:
string
&
key
)
const
{
Symbol
result
=
file
(
)
-
>
tables_
-
>
FindNestedSymbolOfType
(
this
key
Symbol
:
:
MESSAGE
)
;
if
(
!
result
.
IsNull
(
)
)
{
return
result
.
descriptor
;
}
else
{
return
nullptr
;
}
}
const
EnumDescriptor
*
Descriptor
:
:
FindEnumTypeByName
(
const
std
:
:
string
&
key
)
const
{
Symbol
result
=
file
(
)
-
>
tables_
-
>
FindNestedSymbolOfType
(
this
key
Symbol
:
:
ENUM
)
;
if
(
!
result
.
IsNull
(
)
)
{
return
result
.
enum_descriptor
;
}
else
{
return
nullptr
;
}
}
const
EnumValueDescriptor
*
Descriptor
:
:
FindEnumValueByName
(
const
std
:
:
string
&
key
)
const
{
Symbol
result
=
file
(
)
-
>
tables_
-
>
FindNestedSymbolOfType
(
this
key
Symbol
:
:
ENUM_VALUE
)
;
if
(
!
result
.
IsNull
(
)
)
{
return
result
.
enum_value_descriptor
;
}
else
{
return
nullptr
;
}
}
const
EnumValueDescriptor
*
EnumDescriptor
:
:
FindValueByName
(
const
std
:
:
string
&
key
)
const
{
Symbol
result
=
file
(
)
-
>
tables_
-
>
FindNestedSymbolOfType
(
this
key
Symbol
:
:
ENUM_VALUE
)
;
if
(
!
result
.
IsNull
(
)
)
{
return
result
.
enum_value_descriptor
;
}
else
{
return
nullptr
;
}
}
const
EnumValueDescriptor
*
EnumDescriptor
:
:
FindValueByNumber
(
int
key
)
const
{
return
file
(
)
-
>
tables_
-
>
FindEnumValueByNumber
(
this
key
)
;
}
const
EnumValueDescriptor
*
EnumDescriptor
:
:
FindValueByNumberCreatingIfUnknown
(
int
key
)
const
{
return
file
(
)
-
>
tables_
-
>
FindEnumValueByNumberCreatingIfUnknown
(
this
key
)
;
}
const
MethodDescriptor
*
ServiceDescriptor
:
:
FindMethodByName
(
const
std
:
:
string
&
key
)
const
{
Symbol
result
=
file
(
)
-
>
tables_
-
>
FindNestedSymbolOfType
(
this
key
Symbol
:
:
METHOD
)
;
if
(
!
result
.
IsNull
(
)
)
{
return
result
.
method_descriptor
;
}
else
{
return
nullptr
;
}
}
const
Descriptor
*
FileDescriptor
:
:
FindMessageTypeByName
(
const
std
:
:
string
&
key
)
const
{
Symbol
result
=
tables_
-
>
FindNestedSymbolOfType
(
this
key
Symbol
:
:
MESSAGE
)
;
if
(
!
result
.
IsNull
(
)
)
{
return
result
.
descriptor
;
}
else
{
return
nullptr
;
}
}
const
EnumDescriptor
*
FileDescriptor
:
:
FindEnumTypeByName
(
const
std
:
:
string
&
key
)
const
{
Symbol
result
=
tables_
-
>
FindNestedSymbolOfType
(
this
key
Symbol
:
:
ENUM
)
;
if
(
!
result
.
IsNull
(
)
)
{
return
result
.
enum_descriptor
;
}
else
{
return
nullptr
;
}
}
const
EnumValueDescriptor
*
FileDescriptor
:
:
FindEnumValueByName
(
const
std
:
:
string
&
key
)
const
{
Symbol
result
=
tables_
-
>
FindNestedSymbolOfType
(
this
key
Symbol
:
:
ENUM_VALUE
)
;
if
(
!
result
.
IsNull
(
)
)
{
return
result
.
enum_value_descriptor
;
}
else
{
return
nullptr
;
}
}
const
ServiceDescriptor
*
FileDescriptor
:
:
FindServiceByName
(
const
std
:
:
string
&
key
)
const
{
Symbol
result
=
tables_
-
>
FindNestedSymbolOfType
(
this
key
Symbol
:
:
SERVICE
)
;
if
(
!
result
.
IsNull
(
)
)
{
return
result
.
service_descriptor
;
}
else
{
return
nullptr
;
}
}
const
FieldDescriptor
*
FileDescriptor
:
:
FindExtensionByName
(
const
std
:
:
string
&
key
)
const
{
Symbol
result
=
tables_
-
>
FindNestedSymbolOfType
(
this
key
Symbol
:
:
FIELD
)
;
if
(
!
result
.
IsNull
(
)
&
&
result
.
field_descriptor
-
>
is_extension
(
)
)
{
return
result
.
field_descriptor
;
}
else
{
return
nullptr
;
}
}
const
FieldDescriptor
*
FileDescriptor
:
:
FindExtensionByLowercaseName
(
const
std
:
:
string
&
key
)
const
{
const
FieldDescriptor
*
result
=
tables_
-
>
FindFieldByLowercaseName
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
!
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
const
FieldDescriptor
*
FileDescriptor
:
:
FindExtensionByCamelcaseName
(
const
std
:
:
string
&
key
)
const
{
const
FieldDescriptor
*
result
=
tables_
-
>
FindFieldByCamelcaseName
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
!
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
void
Descriptor
:
:
ExtensionRange
:
:
CopyTo
(
DescriptorProto_ExtensionRange
*
proto
)
const
{
proto
-
>
set_start
(
this
-
>
start
)
;
proto
-
>
set_end
(
this
-
>
end
)
;
if
(
options_
!
=
&
ExtensionRangeOptions
:
:
default_instance
(
)
)
{
*
proto
-
>
mutable_options
(
)
=
*
options_
;
}
}
const
Descriptor
:
:
ExtensionRange
*
Descriptor
:
:
FindExtensionRangeContainingNumber
(
int
number
)
const
{
for
(
int
i
=
0
;
i
<
extension_range_count
(
)
;
i
+
+
)
{
if
(
number
>
=
extension_range
(
i
)
-
>
start
&
&
number
<
extension_range
(
i
)
-
>
end
)
{
return
extension_range
(
i
)
;
}
}
return
nullptr
;
}
const
Descriptor
:
:
ReservedRange
*
Descriptor
:
:
FindReservedRangeContainingNumber
(
int
number
)
const
{
for
(
int
i
=
0
;
i
<
reserved_range_count
(
)
;
i
+
+
)
{
if
(
number
>
=
reserved_range
(
i
)
-
>
start
&
&
number
<
reserved_range
(
i
)
-
>
end
)
{
return
reserved_range
(
i
)
;
}
}
return
nullptr
;
}
const
EnumDescriptor
:
:
ReservedRange
*
EnumDescriptor
:
:
FindReservedRangeContainingNumber
(
int
number
)
const
{
for
(
int
i
=
0
;
i
<
reserved_range_count
(
)
;
i
+
+
)
{
if
(
number
>
=
reserved_range
(
i
)
-
>
start
&
&
number
<
=
reserved_range
(
i
)
-
>
end
)
{
return
reserved_range
(
i
)
;
}
}
return
nullptr
;
}
bool
DescriptorPool
:
:
TryFindFileInFallbackDatabase
(
const
std
:
:
string
&
name
)
const
{
if
(
fallback_database_
=
=
nullptr
)
return
false
;
if
(
tables_
-
>
known_bad_files_
.
count
(
name
)
>
0
)
return
false
;
FileDescriptorProto
file_proto
;
if
(
!
fallback_database_
-
>
FindFileByName
(
name
&
file_proto
)
|
|
BuildFileFromDatabase
(
file_proto
)
=
=
nullptr
)
{
tables_
-
>
known_bad_files_
.
insert
(
name
)
;
return
false
;
}
return
true
;
}
bool
DescriptorPool
:
:
IsSubSymbolOfBuiltType
(
const
std
:
:
string
&
name
)
const
{
std
:
:
string
prefix
=
name
;
for
(
;
;
)
{
std
:
:
string
:
:
size_type
dot_pos
=
prefix
.
find_last_of
(
'
.
'
)
;
if
(
dot_pos
=
=
std
:
:
string
:
:
npos
)
{
break
;
}
prefix
=
prefix
.
substr
(
0
dot_pos
)
;
Symbol
symbol
=
tables_
-
>
FindSymbol
(
prefix
)
;
if
(
!
symbol
.
IsNull
(
)
&
&
symbol
.
type
!
=
Symbol
:
:
PACKAGE
)
{
return
true
;
}
}
if
(
underlay_
!
=
nullptr
)
{
return
underlay_
-
>
IsSubSymbolOfBuiltType
(
name
)
;
}
return
false
;
}
bool
DescriptorPool
:
:
TryFindSymbolInFallbackDatabase
(
const
std
:
:
string
&
name
)
const
{
if
(
fallback_database_
=
=
nullptr
)
return
false
;
if
(
tables_
-
>
known_bad_symbols_
.
count
(
name
)
>
0
)
return
false
;
FileDescriptorProto
file_proto
;
if
(
IsSubSymbolOfBuiltType
(
name
)
|
|
!
fallback_database_
-
>
FindFileContainingSymbol
(
name
&
file_proto
)
|
|
tables_
-
>
FindFile
(
file_proto
.
name
(
)
)
!
=
nullptr
|
|
BuildFileFromDatabase
(
file_proto
)
=
=
nullptr
)
{
tables_
-
>
known_bad_symbols_
.
insert
(
name
)
;
return
false
;
}
return
true
;
}
bool
DescriptorPool
:
:
TryFindExtensionInFallbackDatabase
(
const
Descriptor
*
containing_type
int
field_number
)
const
{
if
(
fallback_database_
=
=
nullptr
)
return
false
;
FileDescriptorProto
file_proto
;
if
(
!
fallback_database_
-
>
FindFileContainingExtension
(
containing_type
-
>
full_name
(
)
field_number
&
file_proto
)
)
{
return
false
;
}
if
(
tables_
-
>
FindFile
(
file_proto
.
name
(
)
)
!
=
nullptr
)
{
return
false
;
}
if
(
BuildFileFromDatabase
(
file_proto
)
=
=
nullptr
)
{
return
false
;
}
return
true
;
}
bool
FieldDescriptor
:
:
is_map_message_type
(
)
const
{
return
message_type_
-
>
options
(
)
.
map_entry
(
)
;
}
std
:
:
string
FieldDescriptor
:
:
DefaultValueAsString
(
bool
quote_string_type
)
const
{
GOOGLE_CHECK
(
has_default_value
(
)
)
<
<
"
No
default
value
"
;
switch
(
cpp_type
(
)
)
{
case
CPPTYPE_INT32
:
return
StrCat
(
default_value_int32
(
)
)
;
break
;
case
CPPTYPE_INT64
:
return
StrCat
(
default_value_int64
(
)
)
;
break
;
case
CPPTYPE_UINT32
:
return
StrCat
(
default_value_uint32
(
)
)
;
break
;
case
CPPTYPE_UINT64
:
return
StrCat
(
default_value_uint64
(
)
)
;
break
;
case
CPPTYPE_FLOAT
:
return
SimpleFtoa
(
default_value_float
(
)
)
;
break
;
case
CPPTYPE_DOUBLE
:
return
SimpleDtoa
(
default_value_double
(
)
)
;
break
;
case
CPPTYPE_BOOL
:
return
default_value_bool
(
)
?
"
true
"
:
"
false
"
;
break
;
case
CPPTYPE_STRING
:
if
(
quote_string_type
)
{
return
"
\
"
"
+
CEscape
(
default_value_string
(
)
)
+
"
\
"
"
;
}
else
{
if
(
type
(
)
=
=
TYPE_BYTES
)
{
return
CEscape
(
default_value_string
(
)
)
;
}
else
{
return
default_value_string
(
)
;
}
}
break
;
case
CPPTYPE_ENUM
:
return
default_value_enum
(
)
-
>
name
(
)
;
break
;
case
CPPTYPE_MESSAGE
:
GOOGLE_LOG
(
DFATAL
)
<
<
"
Messages
can
'
t
have
default
values
!
"
;
break
;
}
GOOGLE_LOG
(
FATAL
)
<
<
"
Can
'
t
get
here
:
failed
to
get
default
value
as
string
"
;
return
"
"
;
}
void
FileDescriptor
:
:
CopyTo
(
FileDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
if
(
!
package
(
)
.
empty
(
)
)
proto
-
>
set_package
(
package
(
)
)
;
if
(
syntax
(
)
=
=
SYNTAX_PROTO3
)
proto
-
>
set_syntax
(
SyntaxName
(
syntax
(
)
)
)
;
for
(
int
i
=
0
;
i
<
dependency_count
(
)
;
i
+
+
)
{
proto
-
>
add_dependency
(
dependency
(
i
)
-
>
name
(
)
)
;
}
for
(
int
i
=
0
;
i
<
public_dependency_count
(
)
;
i
+
+
)
{
proto
-
>
add_public_dependency
(
public_dependencies_
[
i
]
)
;
}
for
(
int
i
=
0
;
i
<
weak_dependency_count
(
)
;
i
+
+
)
{
proto
-
>
add_weak_dependency
(
weak_dependencies_
[
i
]
)
;
}
for
(
int
i
=
0
;
i
<
message_type_count
(
)
;
i
+
+
)
{
message_type
(
i
)
-
>
CopyTo
(
proto
-
>
add_message_type
(
)
)
;
}
for
(
int
i
=
0
;
i
<
enum_type_count
(
)
;
i
+
+
)
{
enum_type
(
i
)
-
>
CopyTo
(
proto
-
>
add_enum_type
(
)
)
;
}
for
(
int
i
=
0
;
i
<
service_count
(
)
;
i
+
+
)
{
service
(
i
)
-
>
CopyTo
(
proto
-
>
add_service
(
)
)
;
}
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
extension
(
i
)
-
>
CopyTo
(
proto
-
>
add_extension
(
)
)
;
}
if
(
&
options
(
)
!
=
&
FileOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
FileDescriptor
:
:
CopyJsonNameTo
(
FileDescriptorProto
*
proto
)
const
{
if
(
message_type_count
(
)
!
=
proto
-
>
message_type_size
(
)
|
|
extension_count
(
)
!
=
proto
-
>
extension_size
(
)
)
{
GOOGLE_LOG
(
ERROR
)
<
<
"
Cannot
copy
json_name
to
a
proto
of
a
different
size
.
"
;
return
;
}
for
(
int
i
=
0
;
i
<
message_type_count
(
)
;
i
+
+
)
{
message_type
(
i
)
-
>
CopyJsonNameTo
(
proto
-
>
mutable_message_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
extension
(
i
)
-
>
CopyJsonNameTo
(
proto
-
>
mutable_extension
(
i
)
)
;
}
}
void
FileDescriptor
:
:
CopySourceCodeInfoTo
(
FileDescriptorProto
*
proto
)
const
{
if
(
source_code_info_
&
&
source_code_info_
!
=
&
SourceCodeInfo
:
:
default_instance
(
)
)
{
proto
-
>
mutable_source_code_info
(
)
-
>
CopyFrom
(
*
source_code_info_
)
;
}
}
void
Descriptor
:
:
CopyTo
(
DescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
for
(
int
i
=
0
;
i
<
field_count
(
)
;
i
+
+
)
{
field
(
i
)
-
>
CopyTo
(
proto
-
>
add_field
(
)
)
;
}
for
(
int
i
=
0
;
i
<
oneof_decl_count
(
)
;
i
+
+
)
{
oneof_decl
(
i
)
-
>
CopyTo
(
proto
-
>
add_oneof_decl
(
)
)
;
}
for
(
int
i
=
0
;
i
<
nested_type_count
(
)
;
i
+
+
)
{
nested_type
(
i
)
-
>
CopyTo
(
proto
-
>
add_nested_type
(
)
)
;
}
for
(
int
i
=
0
;
i
<
enum_type_count
(
)
;
i
+
+
)
{
enum_type
(
i
)
-
>
CopyTo
(
proto
-
>
add_enum_type
(
)
)
;
}
for
(
int
i
=
0
;
i
<
extension_range_count
(
)
;
i
+
+
)
{
extension_range
(
i
)
-
>
CopyTo
(
proto
-
>
add_extension_range
(
)
)
;
}
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
extension
(
i
)
-
>
CopyTo
(
proto
-
>
add_extension
(
)
)
;
}
for
(
int
i
=
0
;
i
<
reserved_range_count
(
)
;
i
+
+
)
{
DescriptorProto
:
:
ReservedRange
*
range
=
proto
-
>
add_reserved_range
(
)
;
range
-
>
set_start
(
reserved_range
(
i
)
-
>
start
)
;
range
-
>
set_end
(
reserved_range
(
i
)
-
>
end
)
;
}
for
(
int
i
=
0
;
i
<
reserved_name_count
(
)
;
i
+
+
)
{
proto
-
>
add_reserved_name
(
reserved_name
(
i
)
)
;
}
if
(
&
options
(
)
!
=
&
MessageOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
Descriptor
:
:
CopyJsonNameTo
(
DescriptorProto
*
proto
)
const
{
if
(
field_count
(
)
!
=
proto
-
>
field_size
(
)
|
|
nested_type_count
(
)
!
=
proto
-
>
nested_type_size
(
)
|
|
extension_count
(
)
!
=
proto
-
>
extension_size
(
)
)
{
GOOGLE_LOG
(
ERROR
)
<
<
"
Cannot
copy
json_name
to
a
proto
of
a
different
size
.
"
;
return
;
}
for
(
int
i
=
0
;
i
<
field_count
(
)
;
i
+
+
)
{
field
(
i
)
-
>
CopyJsonNameTo
(
proto
-
>
mutable_field
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
nested_type_count
(
)
;
i
+
+
)
{
nested_type
(
i
)
-
>
CopyJsonNameTo
(
proto
-
>
mutable_nested_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
extension
(
i
)
-
>
CopyJsonNameTo
(
proto
-
>
mutable_extension
(
i
)
)
;
}
}
void
FieldDescriptor
:
:
CopyTo
(
FieldDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
proto
-
>
set_number
(
number
(
)
)
;
if
(
has_json_name_
)
{
proto
-
>
set_json_name
(
json_name
(
)
)
;
}
proto
-
>
set_label
(
static_cast
<
FieldDescriptorProto
:
:
Label
>
(
implicit_cast
<
int
>
(
label
(
)
)
)
)
;
proto
-
>
set_type
(
static_cast
<
FieldDescriptorProto
:
:
Type
>
(
implicit_cast
<
int
>
(
type
(
)
)
)
)
;
if
(
is_extension
(
)
)
{
if
(
!
containing_type
(
)
-
>
is_unqualified_placeholder_
)
{
proto
-
>
set_extendee
(
"
.
"
)
;
}
proto
-
>
mutable_extendee
(
)
-
>
append
(
containing_type
(
)
-
>
full_name
(
)
)
;
}
if
(
cpp_type
(
)
=
=
CPPTYPE_MESSAGE
)
{
if
(
message_type
(
)
-
>
is_placeholder_
)
{
proto
-
>
clear_type
(
)
;
}
if
(
!
message_type
(
)
-
>
is_unqualified_placeholder_
)
{
proto
-
>
set_type_name
(
"
.
"
)
;
}
proto
-
>
mutable_type_name
(
)
-
>
append
(
message_type
(
)
-
>
full_name
(
)
)
;
}
else
if
(
cpp_type
(
)
=
=
CPPTYPE_ENUM
)
{
if
(
!
enum_type
(
)
-
>
is_unqualified_placeholder_
)
{
proto
-
>
set_type_name
(
"
.
"
)
;
}
proto
-
>
mutable_type_name
(
)
-
>
append
(
enum_type
(
)
-
>
full_name
(
)
)
;
}
if
(
has_default_value
(
)
)
{
proto
-
>
set_default_value
(
DefaultValueAsString
(
false
)
)
;
}
if
(
containing_oneof
(
)
!
=
nullptr
&
&
!
is_extension
(
)
)
{
proto
-
>
set_oneof_index
(
containing_oneof
(
)
-
>
index
(
)
)
;
}
if
(
&
options
(
)
!
=
&
FieldOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
FieldDescriptor
:
:
CopyJsonNameTo
(
FieldDescriptorProto
*
proto
)
const
{
proto
-
>
set_json_name
(
json_name
(
)
)
;
}
void
OneofDescriptor
:
:
CopyTo
(
OneofDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
if
(
&
options
(
)
!
=
&
OneofOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
EnumDescriptor
:
:
CopyTo
(
EnumDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
for
(
int
i
=
0
;
i
<
value_count
(
)
;
i
+
+
)
{
value
(
i
)
-
>
CopyTo
(
proto
-
>
add_value
(
)
)
;
}
for
(
int
i
=
0
;
i
<
reserved_range_count
(
)
;
i
+
+
)
{
EnumDescriptorProto
:
:
EnumReservedRange
*
range
=
proto
-
>
add_reserved_range
(
)
;
range
-
>
set_start
(
reserved_range
(
i
)
-
>
start
)
;
range
-
>
set_end
(
reserved_range
(
i
)
-
>
end
)
;
}
for
(
int
i
=
0
;
i
<
reserved_name_count
(
)
;
i
+
+
)
{
proto
-
>
add_reserved_name
(
reserved_name
(
i
)
)
;
}
if
(
&
options
(
)
!
=
&
EnumOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
EnumValueDescriptor
:
:
CopyTo
(
EnumValueDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
proto
-
>
set_number
(
number
(
)
)
;
if
(
&
options
(
)
!
=
&
EnumValueOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
ServiceDescriptor
:
:
CopyTo
(
ServiceDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
for
(
int
i
=
0
;
i
<
method_count
(
)
;
i
+
+
)
{
method
(
i
)
-
>
CopyTo
(
proto
-
>
add_method
(
)
)
;
}
if
(
&
options
(
)
!
=
&
ServiceOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
MethodDescriptor
:
:
CopyTo
(
MethodDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
if
(
!
input_type
(
)
-
>
is_unqualified_placeholder_
)
{
proto
-
>
set_input_type
(
"
.
"
)
;
}
proto
-
>
mutable_input_type
(
)
-
>
append
(
input_type
(
)
-
>
full_name
(
)
)
;
if
(
!
output_type
(
)
-
>
is_unqualified_placeholder_
)
{
proto
-
>
set_output_type
(
"
.
"
)
;
}
proto
-
>
mutable_output_type
(
)
-
>
append
(
output_type
(
)
-
>
full_name
(
)
)
;
if
(
&
options
(
)
!
=
&
MethodOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
if
(
client_streaming_
)
{
proto
-
>
set_client_streaming
(
true
)
;
}
if
(
server_streaming_
)
{
proto
-
>
set_server_streaming
(
true
)
;
}
}
namespace
{
bool
RetrieveOptionsAssumingRightPool
(
int
depth
const
Message
&
options
std
:
:
vector
<
std
:
:
string
>
*
option_entries
)
{
option_entries
-
>
clear
(
)
;
const
Reflection
*
reflection
=
options
.
GetReflection
(
)
;
std
:
:
vector
<
const
FieldDescriptor
*
>
fields
;
reflection
-
>
ListFields
(
options
&
fields
)
;
for
(
int
i
=
0
;
i
<
fields
.
size
(
)
;
i
+
+
)
{
int
count
=
1
;
bool
repeated
=
false
;
if
(
fields
[
i
]
-
>
is_repeated
(
)
)
{
count
=
reflection
-
>
FieldSize
(
options
fields
[
i
]
)
;
repeated
=
true
;
}
for
(
int
j
=
0
;
j
<
count
;
j
+
+
)
{
std
:
:
string
fieldval
;
if
(
fields
[
i
]
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
std
:
:
string
tmp
;
TextFormat
:
:
Printer
printer
;
printer
.
SetInitialIndentLevel
(
depth
+
1
)
;
printer
.
PrintFieldValueToString
(
options
fields
[
i
]
repeated
?
j
:
-
1
&
tmp
)
;
fieldval
.
append
(
"
{
\
n
"
)
;
fieldval
.
append
(
tmp
)
;
fieldval
.
append
(
depth
*
2
'
'
)
;
fieldval
.
append
(
"
}
"
)
;
}
else
{
TextFormat
:
:
PrintFieldValueToString
(
options
fields
[
i
]
repeated
?
j
:
-
1
&
fieldval
)
;
}
std
:
:
string
name
;
if
(
fields
[
i
]
-
>
is_extension
(
)
)
{
name
=
"
(
.
"
+
fields
[
i
]
-
>
full_name
(
)
+
"
)
"
;
}
else
{
name
=
fields
[
i
]
-
>
name
(
)
;
}
option_entries
-
>
push_back
(
name
+
"
=
"
+
fieldval
)
;
}
}
return
!
option_entries
-
>
empty
(
)
;
}
bool
RetrieveOptions
(
int
depth
const
Message
&
options
const
DescriptorPool
*
pool
std
:
:
vector
<
std
:
:
string
>
*
option_entries
)
{
if
(
options
.
GetDescriptor
(
)
-
>
file
(
)
-
>
pool
(
)
=
=
pool
)
{
return
RetrieveOptionsAssumingRightPool
(
depth
options
option_entries
)
;
}
else
{
const
Descriptor
*
option_descriptor
=
pool
-
>
FindMessageTypeByName
(
options
.
GetDescriptor
(
)
-
>
full_name
(
)
)
;
if
(
option_descriptor
=
=
nullptr
)
{
return
RetrieveOptionsAssumingRightPool
(
depth
options
option_entries
)
;
}
DynamicMessageFactory
factory
;
std
:
:
unique_ptr
<
Message
>
dynamic_options
(
factory
.
GetPrototype
(
option_descriptor
)
-
>
New
(
)
)
;
if
(
dynamic_options
-
>
ParseFromString
(
options
.
SerializeAsString
(
)
)
)
{
return
RetrieveOptionsAssumingRightPool
(
depth
*
dynamic_options
option_entries
)
;
}
else
{
GOOGLE_LOG
(
ERROR
)
<
<
"
Found
invalid
proto
option
data
for
:
"
<
<
options
.
GetDescriptor
(
)
-
>
full_name
(
)
;
return
RetrieveOptionsAssumingRightPool
(
depth
options
option_entries
)
;
}
}
}
bool
FormatBracketedOptions
(
int
depth
const
Message
&
options
const
DescriptorPool
*
pool
std
:
:
string
*
output
)
{
std
:
:
vector
<
std
:
:
string
>
all_options
;
if
(
RetrieveOptions
(
depth
options
pool
&
all_options
)
)
{
output
-
>
append
(
Join
(
all_options
"
"
)
)
;
}
return
!
all_options
.
empty
(
)
;
}
bool
FormatLineOptions
(
int
depth
const
Message
&
options
const
DescriptorPool
*
pool
std
:
:
string
*
output
)
{
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
std
:
:
vector
<
std
:
:
string
>
all_options
;
if
(
RetrieveOptions
(
depth
options
pool
&
all_options
)
)
{
for
(
int
i
=
0
;
i
<
all_options
.
size
(
)
;
i
+
+
)
{
strings
:
:
SubstituteAndAppend
(
output
"
0option
1
;
\
n
"
prefix
all_options
[
i
]
)
;
}
}
return
!
all_options
.
empty
(
)
;
}
class
SourceLocationCommentPrinter
{
public
:
template
<
typename
DescType
>
SourceLocationCommentPrinter
(
const
DescType
*
desc
const
std
:
:
string
&
prefix
const
DebugStringOptions
&
options
)
:
options_
(
options
)
prefix_
(
prefix
)
{
have_source_loc_
=
options
.
include_comments
&
&
desc
-
>
GetSourceLocation
(
&
source_loc_
)
;
}
SourceLocationCommentPrinter
(
const
FileDescriptor
*
file
const
std
:
:
vector
<
int
>
&
path
const
std
:
:
string
&
prefix
const
DebugStringOptions
&
options
)
:
options_
(
options
)
prefix_
(
prefix
)
{
have_source_loc_
=
options
.
include_comments
&
&
file
-
>
GetSourceLocation
(
path
&
source_loc_
)
;
}
void
AddPreComment
(
std
:
:
string
*
output
)
{
if
(
have_source_loc_
)
{
for
(
int
i
=
0
;
i
<
source_loc_
.
leading_detached_comments
.
size
(
)
;
+
+
i
)
{
*
output
+
=
FormatComment
(
source_loc_
.
leading_detached_comments
[
i
]
)
;
*
output
+
=
"
\
n
"
;
}
if
(
!
source_loc_
.
leading_comments
.
empty
(
)
)
{
*
output
+
=
FormatComment
(
source_loc_
.
leading_comments
)
;
}
}
}
void
AddPostComment
(
std
:
:
string
*
output
)
{
if
(
have_source_loc_
&
&
source_loc_
.
trailing_comments
.
size
(
)
>
0
)
{
*
output
+
=
FormatComment
(
source_loc_
.
trailing_comments
)
;
}
}
std
:
:
string
FormatComment
(
const
std
:
:
string
&
comment_text
)
{
std
:
:
string
stripped_comment
=
comment_text
;
StripWhitespace
(
&
stripped_comment
)
;
std
:
:
vector
<
std
:
:
string
>
lines
=
Split
(
stripped_comment
"
\
n
"
)
;
std
:
:
string
output
;
for
(
int
i
=
0
;
i
<
lines
.
size
(
)
;
+
+
i
)
{
const
std
:
:
string
&
line
=
lines
[
i
]
;
strings
:
:
SubstituteAndAppend
(
&
output
"
0
/
/
1
\
n
"
prefix_
line
)
;
}
return
output
;
}
private
:
bool
have_source_loc_
;
SourceLocation
source_loc_
;
DebugStringOptions
options_
;
std
:
:
string
prefix_
;
}
;
}
std
:
:
string
FileDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
FileDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
contents
;
{
std
:
:
vector
<
int
>
path
;
path
.
push_back
(
FileDescriptorProto
:
:
kSyntaxFieldNumber
)
;
SourceLocationCommentPrinter
syntax_comment
(
this
path
"
"
debug_string_options
)
;
syntax_comment
.
AddPreComment
(
&
contents
)
;
strings
:
:
SubstituteAndAppend
(
&
contents
"
syntax
=
\
"
0
\
"
;
\
n
\
n
"
SyntaxName
(
syntax
(
)
)
)
;
syntax_comment
.
AddPostComment
(
&
contents
)
;
}
SourceLocationCommentPrinter
comment_printer
(
this
"
"
debug_string_options
)
;
comment_printer
.
AddPreComment
(
&
contents
)
;
std
:
:
set
<
int
>
public_dependencies
;
std
:
:
set
<
int
>
weak_dependencies
;
public_dependencies
.
insert
(
public_dependencies_
public_dependencies_
+
public_dependency_count_
)
;
weak_dependencies
.
insert
(
weak_dependencies_
weak_dependencies_
+
weak_dependency_count_
)
;
for
(
int
i
=
0
;
i
<
dependency_count
(
)
;
i
+
+
)
{
if
(
public_dependencies
.
count
(
i
)
>
0
)
{
strings
:
:
SubstituteAndAppend
(
&
contents
"
import
public
\
"
0
\
"
;
\
n
"
dependency
(
i
)
-
>
name
(
)
)
;
}
else
if
(
weak_dependencies
.
count
(
i
)
>
0
)
{
strings
:
:
SubstituteAndAppend
(
&
contents
"
import
weak
\
"
0
\
"
;
\
n
"
dependency
(
i
)
-
>
name
(
)
)
;
}
else
{
strings
:
:
SubstituteAndAppend
(
&
contents
"
import
\
"
0
\
"
;
\
n
"
dependency
(
i
)
-
>
name
(
)
)
;
}
}
if
(
!
package
(
)
.
empty
(
)
)
{
std
:
:
vector
<
int
>
path
;
path
.
push_back
(
FileDescriptorProto
:
:
kPackageFieldNumber
)
;
SourceLocationCommentPrinter
package_comment
(
this
path
"
"
debug_string_options
)
;
package_comment
.
AddPreComment
(
&
contents
)
;
strings
:
:
SubstituteAndAppend
(
&
contents
"
package
0
;
\
n
\
n
"
package
(
)
)
;
package_comment
.
AddPostComment
(
&
contents
)
;
}
if
(
FormatLineOptions
(
0
options
(
)
pool
(
)
&
contents
)
)
{
contents
.
append
(
"
\
n
"
)
;
}
for
(
int
i
=
0
;
i
<
enum_type_count
(
)
;
i
+
+
)
{
enum_type
(
i
)
-
>
DebugString
(
0
&
contents
debug_string_options
)
;
contents
.
append
(
"
\
n
"
)
;
}
std
:
:
set
<
const
Descriptor
*
>
groups
;
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
if
(
extension
(
i
)
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_GROUP
)
{
groups
.
insert
(
extension
(
i
)
-
>
message_type
(
)
)
;
}
}
for
(
int
i
=
0
;
i
<
message_type_count
(
)
;
i
+
+
)
{
if
(
groups
.
count
(
message_type
(
i
)
)
=
=
0
)
{
message_type
(
i
)
-
>
DebugString
(
0
&
contents
debug_string_options
true
)
;
contents
.
append
(
"
\
n
"
)
;
}
}
for
(
int
i
=
0
;
i
<
service_count
(
)
;
i
+
+
)
{
service
(
i
)
-
>
DebugString
(
&
contents
debug_string_options
)
;
contents
.
append
(
"
\
n
"
)
;
}
const
Descriptor
*
containing_type
=
nullptr
;
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
if
(
extension
(
i
)
-
>
containing_type
(
)
!
=
containing_type
)
{
if
(
i
>
0
)
contents
.
append
(
"
}
\
n
\
n
"
)
;
containing_type
=
extension
(
i
)
-
>
containing_type
(
)
;
strings
:
:
SubstituteAndAppend
(
&
contents
"
extend
.
0
{
\
n
"
containing_type
-
>
full_name
(
)
)
;
}
extension
(
i
)
-
>
DebugString
(
1
FieldDescriptor
:
:
PRINT_LABEL
&
contents
debug_string_options
)
;
}
if
(
extension_count
(
)
>
0
)
contents
.
append
(
"
}
\
n
\
n
"
)
;
comment_printer
.
AddPostComment
(
&
contents
)
;
return
contents
;
}
std
:
:
string
Descriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
Descriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
options
)
const
{
std
:
:
string
contents
;
DebugString
(
0
&
contents
options
true
)
;
return
contents
;
}
void
Descriptor
:
:
DebugString
(
int
depth
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
bool
include_opening_clause
)
const
{
if
(
options
(
)
.
map_entry
(
)
)
{
return
;
}
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
+
+
depth
;
SourceLocationCommentPrinter
comment_printer
(
this
prefix
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
if
(
include_opening_clause
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0message
1
"
prefix
name
(
)
)
;
}
contents
-
>
append
(
"
{
\
n
"
)
;
FormatLineOptions
(
depth
options
(
)
file
(
)
-
>
pool
(
)
contents
)
;
std
:
:
set
<
const
Descriptor
*
>
groups
;
for
(
int
i
=
0
;
i
<
field_count
(
)
;
i
+
+
)
{
if
(
field
(
i
)
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_GROUP
)
{
groups
.
insert
(
field
(
i
)
-
>
message_type
(
)
)
;
}
}
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
if
(
extension
(
i
)
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_GROUP
)
{
groups
.
insert
(
extension
(
i
)
-
>
message_type
(
)
)
;
}
}
for
(
int
i
=
0
;
i
<
nested_type_count
(
)
;
i
+
+
)
{
if
(
groups
.
count
(
nested_type
(
i
)
)
=
=
0
)
{
nested_type
(
i
)
-
>
DebugString
(
depth
contents
debug_string_options
true
)
;
}
}
for
(
int
i
=
0
;
i
<
enum_type_count
(
)
;
i
+
+
)
{
enum_type
(
i
)
-
>
DebugString
(
depth
contents
debug_string_options
)
;
}
for
(
int
i
=
0
;
i
<
field_count
(
)
;
i
+
+
)
{
if
(
field
(
i
)
-
>
containing_oneof
(
)
=
=
nullptr
)
{
field
(
i
)
-
>
DebugString
(
depth
FieldDescriptor
:
:
PRINT_LABEL
contents
debug_string_options
)
;
}
else
if
(
field
(
i
)
-
>
containing_oneof
(
)
-
>
field
(
0
)
=
=
field
(
i
)
)
{
field
(
i
)
-
>
containing_oneof
(
)
-
>
DebugString
(
depth
contents
debug_string_options
)
;
}
}
for
(
int
i
=
0
;
i
<
extension_range_count
(
)
;
i
+
+
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
extensions
1
to
2
;
\
n
"
prefix
extension_range
(
i
)
-
>
start
extension_range
(
i
)
-
>
end
-
1
)
;
}
const
Descriptor
*
containing_type
=
nullptr
;
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
if
(
extension
(
i
)
-
>
containing_type
(
)
!
=
containing_type
)
{
if
(
i
>
0
)
strings
:
:
SubstituteAndAppend
(
contents
"
0
}
\
n
"
prefix
)
;
containing_type
=
extension
(
i
)
-
>
containing_type
(
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
0
extend
.
1
{
\
n
"
prefix
containing_type
-
>
full_name
(
)
)
;
}
extension
(
i
)
-
>
DebugString
(
depth
+
1
FieldDescriptor
:
:
PRINT_LABEL
contents
debug_string_options
)
;
}
if
(
extension_count
(
)
>
0
)
strings
:
:
SubstituteAndAppend
(
contents
"
0
}
\
n
"
prefix
)
;
if
(
reserved_range_count
(
)
>
0
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
reserved
"
prefix
)
;
for
(
int
i
=
0
;
i
<
reserved_range_count
(
)
;
i
+
+
)
{
const
Descriptor
:
:
ReservedRange
*
range
=
reserved_range
(
i
)
;
if
(
range
-
>
end
=
=
range
-
>
start
+
1
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
"
range
-
>
start
)
;
}
else
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
to
1
"
range
-
>
start
range
-
>
end
-
1
)
;
}
}
contents
-
>
replace
(
contents
-
>
size
(
)
-
2
2
"
;
\
n
"
)
;
}
if
(
reserved_name_count
(
)
>
0
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
reserved
"
prefix
)
;
for
(
int
i
=
0
;
i
<
reserved_name_count
(
)
;
i
+
+
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
\
"
0
\
"
"
CEscape
(
reserved_name
(
i
)
)
)
;
}
contents
-
>
replace
(
contents
-
>
size
(
)
-
2
2
"
;
\
n
"
)
;
}
strings
:
:
SubstituteAndAppend
(
contents
"
0
}
\
n
"
prefix
)
;
comment_printer
.
AddPostComment
(
contents
)
;
}
std
:
:
string
FieldDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
FieldDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
contents
;
int
depth
=
0
;
if
(
is_extension
(
)
)
{
strings
:
:
SubstituteAndAppend
(
&
contents
"
extend
.
0
{
\
n
"
containing_type
(
)
-
>
full_name
(
)
)
;
depth
=
1
;
}
DebugString
(
depth
PRINT_LABEL
&
contents
debug_string_options
)
;
if
(
is_extension
(
)
)
{
contents
.
append
(
"
}
\
n
"
)
;
}
return
contents
;
}
std
:
:
string
FieldDescriptor
:
:
FieldTypeNameDebugString
(
)
const
{
switch
(
type
(
)
)
{
case
TYPE_MESSAGE
:
return
"
.
"
+
message_type
(
)
-
>
full_name
(
)
;
case
TYPE_ENUM
:
return
"
.
"
+
enum_type
(
)
-
>
full_name
(
)
;
default
:
return
kTypeToName
[
type
(
)
]
;
}
}
void
FieldDescriptor
:
:
DebugString
(
int
depth
PrintLabelFlag
print_label_flag
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
std
:
:
string
field_type
;
if
(
is_map
(
)
)
{
strings
:
:
SubstituteAndAppend
(
&
field_type
"
map
<
0
1
>
"
message_type
(
)
-
>
field
(
0
)
-
>
FieldTypeNameDebugString
(
)
message_type
(
)
-
>
field
(
1
)
-
>
FieldTypeNameDebugString
(
)
)
;
}
else
{
field_type
=
FieldTypeNameDebugString
(
)
;
}
bool
print_label
=
true
;
if
(
is_optional
(
)
&
&
(
print_label_flag
=
=
OMIT_LABEL
|
|
file
(
)
-
>
syntax
(
)
=
=
FileDescriptor
:
:
SYNTAX_PROTO3
)
)
{
print_label
=
false
;
}
else
if
(
is_map
(
)
)
{
print_label
=
false
;
}
std
:
:
string
label
;
if
(
print_label
)
{
label
=
kLabelToName
[
this
-
>
label
(
)
]
;
label
.
push_back
(
'
'
)
;
}
SourceLocationCommentPrinter
comment_printer
(
this
prefix
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
0
1
2
3
=
4
"
prefix
label
field_type
type
(
)
=
=
TYPE_GROUP
?
message_type
(
)
-
>
name
(
)
:
name
(
)
number
(
)
)
;
bool
bracketed
=
false
;
if
(
has_default_value
(
)
)
{
bracketed
=
true
;
strings
:
:
SubstituteAndAppend
(
contents
"
[
default
=
0
"
DefaultValueAsString
(
true
)
)
;
}
if
(
has_json_name_
)
{
if
(
!
bracketed
)
{
bracketed
=
true
;
contents
-
>
append
(
"
[
"
)
;
}
else
{
contents
-
>
append
(
"
"
)
;
}
contents
-
>
append
(
"
json_name
=
\
"
"
)
;
contents
-
>
append
(
CEscape
(
json_name
(
)
)
)
;
contents
-
>
append
(
"
\
"
"
)
;
}
std
:
:
string
formatted_options
;
if
(
FormatBracketedOptions
(
depth
options
(
)
file
(
)
-
>
pool
(
)
&
formatted_options
)
)
{
contents
-
>
append
(
bracketed
?
"
"
:
"
[
"
)
;
bracketed
=
true
;
contents
-
>
append
(
formatted_options
)
;
}
if
(
bracketed
)
{
contents
-
>
append
(
"
]
"
)
;
}
if
(
type
(
)
=
=
TYPE_GROUP
)
{
if
(
debug_string_options
.
elide_group_body
)
{
contents
-
>
append
(
"
{
.
.
.
}
;
\
n
"
)
;
}
else
{
message_type
(
)
-
>
DebugString
(
depth
contents
debug_string_options
false
)
;
}
}
else
{
contents
-
>
append
(
"
;
\
n
"
)
;
}
comment_printer
.
AddPostComment
(
contents
)
;
}
std
:
:
string
OneofDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
OneofDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
options
)
const
{
std
:
:
string
contents
;
DebugString
(
0
&
contents
options
)
;
return
contents
;
}
void
OneofDescriptor
:
:
DebugString
(
int
depth
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
+
+
depth
;
SourceLocationCommentPrinter
comment_printer
(
this
prefix
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
0oneof
1
{
"
prefix
name
(
)
)
;
FormatLineOptions
(
depth
options
(
)
containing_type
(
)
-
>
file
(
)
-
>
pool
(
)
contents
)
;
if
(
debug_string_options
.
elide_oneof_body
)
{
contents
-
>
append
(
"
.
.
.
}
\
n
"
)
;
}
else
{
contents
-
>
append
(
"
\
n
"
)
;
for
(
int
i
=
0
;
i
<
field_count
(
)
;
i
+
+
)
{
field
(
i
)
-
>
DebugString
(
depth
FieldDescriptor
:
:
OMIT_LABEL
contents
debug_string_options
)
;
}
strings
:
:
SubstituteAndAppend
(
contents
"
0
}
\
n
"
prefix
)
;
}
comment_printer
.
AddPostComment
(
contents
)
;
}
std
:
:
string
EnumDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
EnumDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
options
)
const
{
std
:
:
string
contents
;
DebugString
(
0
&
contents
options
)
;
return
contents
;
}
void
EnumDescriptor
:
:
DebugString
(
int
depth
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
+
+
depth
;
SourceLocationCommentPrinter
comment_printer
(
this
prefix
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
0enum
1
{
\
n
"
prefix
name
(
)
)
;
FormatLineOptions
(
depth
options
(
)
file
(
)
-
>
pool
(
)
contents
)
;
for
(
int
i
=
0
;
i
<
value_count
(
)
;
i
+
+
)
{
value
(
i
)
-
>
DebugString
(
depth
contents
debug_string_options
)
;
}
if
(
reserved_range_count
(
)
>
0
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
reserved
"
prefix
)
;
for
(
int
i
=
0
;
i
<
reserved_range_count
(
)
;
i
+
+
)
{
const
EnumDescriptor
:
:
ReservedRange
*
range
=
reserved_range
(
i
)
;
if
(
range
-
>
end
=
=
range
-
>
start
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
"
range
-
>
start
)
;
}
else
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
to
1
"
range
-
>
start
range
-
>
end
)
;
}
}
contents
-
>
replace
(
contents
-
>
size
(
)
-
2
2
"
;
\
n
"
)
;
}
if
(
reserved_name_count
(
)
>
0
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
reserved
"
prefix
)
;
for
(
int
i
=
0
;
i
<
reserved_name_count
(
)
;
i
+
+
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
\
"
0
\
"
"
CEscape
(
reserved_name
(
i
)
)
)
;
}
contents
-
>
replace
(
contents
-
>
size
(
)
-
2
2
"
;
\
n
"
)
;
}
strings
:
:
SubstituteAndAppend
(
contents
"
0
}
\
n
"
prefix
)
;
comment_printer
.
AddPostComment
(
contents
)
;
}
std
:
:
string
EnumValueDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
EnumValueDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
options
)
const
{
std
:
:
string
contents
;
DebugString
(
0
&
contents
options
)
;
return
contents
;
}
void
EnumValueDescriptor
:
:
DebugString
(
int
depth
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
SourceLocationCommentPrinter
comment_printer
(
this
prefix
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
0
1
=
2
"
prefix
name
(
)
number
(
)
)
;
std
:
:
string
formatted_options
;
if
(
FormatBracketedOptions
(
depth
options
(
)
type
(
)
-
>
file
(
)
-
>
pool
(
)
&
formatted_options
)
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
[
0
]
"
formatted_options
)
;
}
contents
-
>
append
(
"
;
\
n
"
)
;
comment_printer
.
AddPostComment
(
contents
)
;
}
std
:
:
string
ServiceDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
ServiceDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
options
)
const
{
std
:
:
string
contents
;
DebugString
(
&
contents
options
)
;
return
contents
;
}
void
ServiceDescriptor
:
:
DebugString
(
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
)
const
{
SourceLocationCommentPrinter
comment_printer
(
this
"
"
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
service
0
{
\
n
"
name
(
)
)
;
FormatLineOptions
(
1
options
(
)
file
(
)
-
>
pool
(
)
contents
)
;
for
(
int
i
=
0
;
i
<
method_count
(
)
;
i
+
+
)
{
method
(
i
)
-
>
DebugString
(
1
contents
debug_string_options
)
;
}
contents
-
>
append
(
"
}
\
n
"
)
;
comment_printer
.
AddPostComment
(
contents
)
;
}
std
:
:
string
MethodDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
MethodDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
options
)
const
{
std
:
:
string
contents
;
DebugString
(
0
&
contents
options
)
;
return
contents
;
}
void
MethodDescriptor
:
:
DebugString
(
int
depth
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
+
+
depth
;
SourceLocationCommentPrinter
comment_printer
(
this
prefix
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
0rpc
1
(
4
.
2
)
returns
(
5
.
3
)
"
prefix
name
(
)
input_type
(
)
-
>
full_name
(
)
output_type
(
)
-
>
full_name
(
)
client_streaming
(
)
?
"
stream
"
:
"
"
server_streaming
(
)
?
"
stream
"
:
"
"
)
;
std
:
:
string
formatted_options
;
if
(
FormatLineOptions
(
depth
options
(
)
service
(
)
-
>
file
(
)
-
>
pool
(
)
&
formatted_options
)
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
{
\
n
0
1
}
\
n
"
formatted_options
prefix
)
;
}
else
{
contents
-
>
append
(
"
;
\
n
"
)
;
}
comment_printer
.
AddPostComment
(
contents
)
;
}
bool
FileDescriptor
:
:
GetSourceLocation
(
const
std
:
:
vector
<
int
>
&
path
SourceLocation
*
out_location
)
const
{
GOOGLE_CHECK
(
out_location
!
=
nullptr
)
;
if
(
source_code_info_
)
{
if
(
const
SourceCodeInfo_Location
*
loc
=
tables_
-
>
GetSourceLocation
(
path
source_code_info_
)
)
{
const
RepeatedField
<
int32
>
&
span
=
loc
-
>
span
(
)
;
if
(
span
.
size
(
)
=
=
3
|
|
span
.
size
(
)
=
=
4
)
{
out_location
-
>
start_line
=
span
.
Get
(
0
)
;
out_location
-
>
start_column
=
span
.
Get
(
1
)
;
out_location
-
>
end_line
=
span
.
Get
(
span
.
size
(
)
=
=
3
?
0
:
2
)
;
out_location
-
>
end_column
=
span
.
Get
(
span
.
size
(
)
-
1
)
;
out_location
-
>
leading_comments
=
loc
-
>
leading_comments
(
)
;
out_location
-
>
trailing_comments
=
loc
-
>
trailing_comments
(
)
;
out_location
-
>
leading_detached_comments
.
assign
(
loc
-
>
leading_detached_comments
(
)
.
begin
(
)
loc
-
>
leading_detached_comments
(
)
.
end
(
)
)
;
return
true
;
}
}
}
return
false
;
}
bool
FileDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
return
GetSourceLocation
(
path
out_location
)
;
}
bool
FieldDescriptor
:
:
is_packed
(
)
const
{
if
(
!
is_packable
(
)
)
return
false
;
if
(
file_
-
>
syntax
(
)
=
=
FileDescriptor
:
:
SYNTAX_PROTO2
)
{
return
(
options_
!
=
nullptr
)
&
&
options_
-
>
packed
(
)
;
}
else
{
return
options_
=
=
nullptr
|
|
!
options_
-
>
has_packed
(
)
|
|
options_
-
>
packed
(
)
;
}
}
bool
Descriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
bool
FieldDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
bool
OneofDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
containing_type
(
)
-
>
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
bool
EnumDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
bool
MethodDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
service
(
)
-
>
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
bool
ServiceDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
bool
EnumValueDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
type
(
)
-
>
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
void
Descriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
if
(
containing_type
(
)
)
{
containing_type
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
DescriptorProto
:
:
kNestedTypeFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
else
{
output
-
>
push_back
(
FileDescriptorProto
:
:
kMessageTypeFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
}
void
FieldDescriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
if
(
is_extension
(
)
)
{
if
(
extension_scope
(
)
=
=
nullptr
)
{
output
-
>
push_back
(
FileDescriptorProto
:
:
kExtensionFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
else
{
extension_scope
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
DescriptorProto
:
:
kExtensionFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
}
else
{
containing_type
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
DescriptorProto
:
:
kFieldFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
}
void
OneofDescriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
containing_type
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
DescriptorProto
:
:
kOneofDeclFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
void
EnumDescriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
if
(
containing_type
(
)
)
{
containing_type
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
DescriptorProto
:
:
kEnumTypeFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
else
{
output
-
>
push_back
(
FileDescriptorProto
:
:
kEnumTypeFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
}
void
EnumValueDescriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
type
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
EnumDescriptorProto
:
:
kValueFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
void
ServiceDescriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
output
-
>
push_back
(
FileDescriptorProto
:
:
kServiceFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
void
MethodDescriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
service
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
ServiceDescriptorProto
:
:
kMethodFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
namespace
{
struct
OptionsToInterpret
{
OptionsToInterpret
(
const
std
:
:
string
&
ns
const
std
:
:
string
&
el
const
std
:
:
vector
<
int
>
&
path
const
Message
*
orig_opt
Message
*
opt
)
:
name_scope
(
ns
)
element_name
(
el
)
element_path
(
path
)
original_options
(
orig_opt
)
options
(
opt
)
{
}
std
:
:
string
name_scope
;
std
:
:
string
element_name
;
std
:
:
vector
<
int
>
element_path
;
const
Message
*
original_options
;
Message
*
options
;
}
;
}
class
DescriptorBuilder
{
public
:
DescriptorBuilder
(
const
DescriptorPool
*
pool
DescriptorPool
:
:
Tables
*
tables
DescriptorPool
:
:
ErrorCollector
*
error_collector
)
;
~
DescriptorBuilder
(
)
;
const
FileDescriptor
*
BuildFile
(
const
FileDescriptorProto
&
proto
)
;
private
:
friend
class
OptionInterpreter
;
FileDescriptor
*
BuildFileImpl
(
const
FileDescriptorProto
&
proto
)
;
const
DescriptorPool
*
pool_
;
DescriptorPool
:
:
Tables
*
tables_
;
DescriptorPool
:
:
ErrorCollector
*
error_collector_
;
std
:
:
vector
<
OptionsToInterpret
>
options_to_interpret_
;
bool
had_errors_
;
std
:
:
string
filename_
;
FileDescriptor
*
file_
;
FileDescriptorTables
*
file_tables_
;
std
:
:
set
<
const
FileDescriptor
*
>
dependencies_
;
std
:
:
set
<
const
FileDescriptor
*
>
unused_dependency_
;
const
FileDescriptor
*
possible_undeclared_dependency_
;
std
:
:
string
possible_undeclared_dependency_name_
;
std
:
:
string
undefine_resolved_name_
;
void
AddError
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
error
)
;
void
AddError
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
char
*
error
)
;
void
AddRecursiveImportError
(
const
FileDescriptorProto
&
proto
int
from_here
)
;
void
AddTwiceListedError
(
const
FileDescriptorProto
&
proto
int
index
)
;
void
AddImportError
(
const
FileDescriptorProto
&
proto
int
index
)
;
void
AddNotDefinedError
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
undefined_symbol
)
;
void
AddWarning
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
error
)
;
bool
IsInPackage
(
const
FileDescriptor
*
file
const
std
:
:
string
&
package_name
)
;
void
RecordPublicDependencies
(
const
FileDescriptor
*
file
)
;
Symbol
FindSymbol
(
const
std
:
:
string
&
name
bool
build_it
=
true
)
;
Symbol
FindSymbolNotEnforcingDeps
(
const
std
:
:
string
&
name
bool
build_it
=
true
)
;
Symbol
FindSymbolNotEnforcingDepsHelper
(
const
DescriptorPool
*
pool
const
std
:
:
string
&
name
bool
build_it
=
true
)
;
enum
ResolveMode
{
LOOKUP_ALL
LOOKUP_TYPES
}
;
Symbol
LookupSymbol
(
const
std
:
:
string
&
name
const
std
:
:
string
&
relative_to
DescriptorPool
:
:
PlaceholderType
placeholder_type
=
DescriptorPool
:
:
PLACEHOLDER_MESSAGE
ResolveMode
resolve_mode
=
LOOKUP_ALL
bool
build_it
=
true
)
;
Symbol
LookupSymbolNoPlaceholder
(
const
std
:
:
string
&
name
const
std
:
:
string
&
relative_to
ResolveMode
resolve_mode
=
LOOKUP_ALL
bool
build_it
=
true
)
;
bool
AddSymbol
(
const
std
:
:
string
&
full_name
const
void
*
parent
const
std
:
:
string
&
name
const
Message
&
proto
Symbol
symbol
)
;
void
AddPackage
(
const
std
:
:
string
&
name
const
Message
&
proto
const
FileDescriptor
*
file
)
;
void
ValidateSymbolName
(
const
std
:
:
string
&
name
const
std
:
:
string
&
full_name
const
Message
&
proto
)
;
template
<
typename
Type
>
inline
void
AllocateArray
(
int
size
Type
*
*
output
)
{
*
output
=
tables_
-
>
AllocateArray
<
Type
>
(
size
)
;
}
template
<
class
DescriptorT
>
void
AllocateOptions
(
const
typename
DescriptorT
:
:
OptionsType
&
orig_options
DescriptorT
*
descriptor
int
options_field_tag
const
std
:
:
string
&
option_name
)
;
void
AllocateOptions
(
const
FileOptions
&
orig_options
FileDescriptor
*
descriptor
)
;
template
<
class
DescriptorT
>
void
AllocateOptionsImpl
(
const
std
:
:
string
&
name_scope
const
std
:
:
string
&
element_name
const
typename
DescriptorT
:
:
OptionsType
&
orig_options
DescriptorT
*
descriptor
const
std
:
:
vector
<
int
>
&
options_path
const
std
:
:
string
&
option_name
)
;
std
:
:
string
*
AllocateNameString
(
const
std
:
:
string
&
scope
const
std
:
:
string
&
proto_name
)
;
void
BuildMessage
(
const
DescriptorProto
&
proto
const
Descriptor
*
parent
Descriptor
*
result
)
;
void
BuildFieldOrExtension
(
const
FieldDescriptorProto
&
proto
const
Descriptor
*
parent
FieldDescriptor
*
result
bool
is_extension
)
;
void
BuildField
(
const
FieldDescriptorProto
&
proto
const
Descriptor
*
parent
FieldDescriptor
*
result
)
{
BuildFieldOrExtension
(
proto
parent
result
false
)
;
}
void
BuildExtension
(
const
FieldDescriptorProto
&
proto
const
Descriptor
*
parent
FieldDescriptor
*
result
)
{
BuildFieldOrExtension
(
proto
parent
result
true
)
;
}
void
BuildExtensionRange
(
const
DescriptorProto
:
:
ExtensionRange
&
proto
const
Descriptor
*
parent
Descriptor
:
:
ExtensionRange
*
result
)
;
void
BuildReservedRange
(
const
DescriptorProto
:
:
ReservedRange
&
proto
const
Descriptor
*
parent
Descriptor
:
:
ReservedRange
*
result
)
;
void
BuildReservedRange
(
const
EnumDescriptorProto
:
:
EnumReservedRange
&
proto
const
EnumDescriptor
*
parent
EnumDescriptor
:
:
ReservedRange
*
result
)
;
void
BuildOneof
(
const
OneofDescriptorProto
&
proto
Descriptor
*
parent
OneofDescriptor
*
result
)
;
void
CheckEnumValueUniqueness
(
const
EnumDescriptorProto
&
proto
const
EnumDescriptor
*
result
)
;
void
BuildEnum
(
const
EnumDescriptorProto
&
proto
const
Descriptor
*
parent
EnumDescriptor
*
result
)
;
void
BuildEnumValue
(
const
EnumValueDescriptorProto
&
proto
const
EnumDescriptor
*
parent
EnumValueDescriptor
*
result
)
;
void
BuildService
(
const
ServiceDescriptorProto
&
proto
const
void
*
dummy
ServiceDescriptor
*
result
)
;
void
BuildMethod
(
const
MethodDescriptorProto
&
proto
const
ServiceDescriptor
*
parent
MethodDescriptor
*
result
)
;
void
LogUnusedDependency
(
const
FileDescriptorProto
&
proto
const
FileDescriptor
*
result
)
;
void
CrossLinkFile
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
;
void
CrossLinkMessage
(
Descriptor
*
message
const
DescriptorProto
&
proto
)
;
void
CrossLinkField
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
;
void
CrossLinkExtensionRange
(
Descriptor
:
:
ExtensionRange
*
range
const
DescriptorProto
:
:
ExtensionRange
&
proto
)
;
void
CrossLinkEnum
(
EnumDescriptor
*
enum_type
const
EnumDescriptorProto
&
proto
)
;
void
CrossLinkEnumValue
(
EnumValueDescriptor
*
enum_value
const
EnumValueDescriptorProto
&
proto
)
;
void
CrossLinkService
(
ServiceDescriptor
*
service
const
ServiceDescriptorProto
&
proto
)
;
void
CrossLinkMethod
(
MethodDescriptor
*
method
const
MethodDescriptorProto
&
proto
)
;
void
InterpretOptions
(
)
;
class
OptionInterpreter
{
public
:
explicit
OptionInterpreter
(
DescriptorBuilder
*
builder
)
;
~
OptionInterpreter
(
)
;
bool
InterpretOptions
(
OptionsToInterpret
*
options_to_interpret
)
;
void
UpdateSourceCodeInfo
(
SourceCodeInfo
*
info
)
;
class
AggregateOptionFinder
;
private
:
bool
InterpretSingleOption
(
Message
*
options
const
std
:
:
vector
<
int
>
&
src_path
const
std
:
:
vector
<
int
>
&
options_path
)
;
void
AddWithoutInterpreting
(
const
UninterpretedOption
&
uninterpreted_option
Message
*
options
)
;
bool
ExamineIfOptionIsSet
(
std
:
:
vector
<
const
FieldDescriptor
*
>
:
:
const_iterator
intermediate_fields_iter
std
:
:
vector
<
const
FieldDescriptor
*
>
:
:
const_iterator
intermediate_fields_end
const
FieldDescriptor
*
innermost_field
const
std
:
:
string
&
debug_msg_name
const
UnknownFieldSet
&
unknown_fields
)
;
bool
SetOptionValue
(
const
FieldDescriptor
*
option_field
UnknownFieldSet
*
unknown_fields
)
;
bool
SetAggregateOption
(
const
FieldDescriptor
*
option_field
UnknownFieldSet
*
unknown_fields
)
;
void
SetInt32
(
int
number
int32
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
;
void
SetInt64
(
int
number
int64
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
;
void
SetUInt32
(
int
number
uint32
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
;
void
SetUInt64
(
int
number
uint64
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
;
bool
AddOptionError
(
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
msg
)
{
builder_
-
>
AddError
(
options_to_interpret_
-
>
element_name
*
uninterpreted_option_
location
msg
)
;
return
false
;
}
bool
AddNameError
(
const
std
:
:
string
&
msg
)
{
return
AddOptionError
(
DescriptorPool
:
:
ErrorCollector
:
:
OPTION_NAME
msg
)
;
}
bool
AddValueError
(
const
std
:
:
string
&
msg
)
{
return
AddOptionError
(
DescriptorPool
:
:
ErrorCollector
:
:
OPTION_VALUE
msg
)
;
}
DescriptorBuilder
*
builder_
;
const
OptionsToInterpret
*
options_to_interpret_
;
const
UninterpretedOption
*
uninterpreted_option_
;
std
:
:
map
<
std
:
:
vector
<
int
>
std
:
:
vector
<
int
>
>
interpreted_paths_
;
std
:
:
map
<
std
:
:
vector
<
int
>
int
>
repeated_option_counts_
;
DynamicMessageFactory
dynamic_factory_
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
OptionInterpreter
)
;
}
;
friend
class
OptionInterpreter
;
friend
class
OptionInterpreter
:
:
AggregateOptionFinder
;
static
inline
bool
get_allow_unknown
(
const
DescriptorPool
*
pool
)
{
return
pool
-
>
allow_unknown_
;
}
static
inline
bool
get_enforce_weak
(
const
DescriptorPool
*
pool
)
{
return
pool
-
>
enforce_weak_
;
}
static
inline
bool
get_is_placeholder
(
const
Descriptor
*
descriptor
)
{
return
descriptor
-
>
is_placeholder_
;
}
static
inline
void
assert_mutex_held
(
const
DescriptorPool
*
pool
)
{
if
(
pool
-
>
mutex_
!
=
nullptr
)
{
pool
-
>
mutex_
-
>
AssertHeld
(
)
;
}
}
void
ValidateFileOptions
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
;
void
ValidateMessageOptions
(
Descriptor
*
message
const
DescriptorProto
&
proto
)
;
void
ValidateFieldOptions
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
;
void
ValidateEnumOptions
(
EnumDescriptor
*
enm
const
EnumDescriptorProto
&
proto
)
;
void
ValidateEnumValueOptions
(
EnumValueDescriptor
*
enum_value
const
EnumValueDescriptorProto
&
proto
)
;
void
ValidateServiceOptions
(
ServiceDescriptor
*
service
const
ServiceDescriptorProto
&
proto
)
;
void
ValidateMethodOptions
(
MethodDescriptor
*
method
const
MethodDescriptorProto
&
proto
)
;
void
ValidateProto3
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
;
void
ValidateProto3Message
(
Descriptor
*
message
const
DescriptorProto
&
proto
)
;
void
ValidateProto3Field
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
;
void
ValidateProto3Enum
(
EnumDescriptor
*
enm
const
EnumDescriptorProto
&
proto
)
;
bool
ValidateMapEntry
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
;
void
DetectMapConflicts
(
const
Descriptor
*
message
const
DescriptorProto
&
proto
)
;
void
ValidateJSType
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
;
}
;
const
FileDescriptor
*
DescriptorPool
:
:
BuildFile
(
const
FileDescriptorProto
&
proto
)
{
GOOGLE_CHECK
(
fallback_database_
=
=
nullptr
)
<
<
"
Cannot
call
BuildFile
on
a
DescriptorPool
that
uses
a
"
"
DescriptorDatabase
.
You
must
instead
find
a
way
to
get
your
file
"
"
into
the
underlying
database
.
"
;
GOOGLE_CHECK
(
mutex_
=
=
nullptr
)
;
tables_
-
>
known_bad_symbols_
.
clear
(
)
;
tables_
-
>
known_bad_files_
.
clear
(
)
;
return
DescriptorBuilder
(
this
tables_
.
get
(
)
nullptr
)
.
BuildFile
(
proto
)
;
}
const
FileDescriptor
*
DescriptorPool
:
:
BuildFileCollectingErrors
(
const
FileDescriptorProto
&
proto
ErrorCollector
*
error_collector
)
{
GOOGLE_CHECK
(
fallback_database_
=
=
nullptr
)
<
<
"
Cannot
call
BuildFile
on
a
DescriptorPool
that
uses
a
"
"
DescriptorDatabase
.
You
must
instead
find
a
way
to
get
your
file
"
"
into
the
underlying
database
.
"
;
GOOGLE_CHECK
(
mutex_
=
=
nullptr
)
;
tables_
-
>
known_bad_symbols_
.
clear
(
)
;
tables_
-
>
known_bad_files_
.
clear
(
)
;
return
DescriptorBuilder
(
this
tables_
.
get
(
)
error_collector
)
.
BuildFile
(
proto
)
;
}
const
FileDescriptor
*
DescriptorPool
:
:
BuildFileFromDatabase
(
const
FileDescriptorProto
&
proto
)
const
{
mutex_
-
>
AssertHeld
(
)
;
if
(
tables_
-
>
known_bad_files_
.
count
(
proto
.
name
(
)
)
>
0
)
{
return
nullptr
;
}
const
FileDescriptor
*
result
=
DescriptorBuilder
(
this
tables_
.
get
(
)
default_error_collector_
)
.
BuildFile
(
proto
)
;
if
(
result
=
=
nullptr
)
{
tables_
-
>
known_bad_files_
.
insert
(
proto
.
name
(
)
)
;
}
return
result
;
}
DescriptorBuilder
:
:
DescriptorBuilder
(
const
DescriptorPool
*
pool
DescriptorPool
:
:
Tables
*
tables
DescriptorPool
:
:
ErrorCollector
*
error_collector
)
:
pool_
(
pool
)
tables_
(
tables
)
error_collector_
(
error_collector
)
had_errors_
(
false
)
possible_undeclared_dependency_
(
nullptr
)
undefine_resolved_name_
(
"
"
)
{
}
DescriptorBuilder
:
:
~
DescriptorBuilder
(
)
{
}
void
DescriptorBuilder
:
:
AddError
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
error
)
{
if
(
error_collector_
=
=
nullptr
)
{
if
(
!
had_errors_
)
{
GOOGLE_LOG
(
ERROR
)
<
<
"
Invalid
proto
descriptor
for
file
\
"
"
<
<
filename_
<
<
"
\
"
:
"
;
}
GOOGLE_LOG
(
ERROR
)
<
<
"
"
<
<
element_name
<
<
"
:
"
<
<
error
;
}
else
{
error_collector_
-
>
AddError
(
filename_
element_name
&
descriptor
location
error
)
;
}
had_errors_
=
true
;
}
void
DescriptorBuilder
:
:
AddError
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
char
*
error
)
{
AddError
(
element_name
descriptor
location
std
:
:
string
(
error
)
)
;
}
void
DescriptorBuilder
:
:
AddNotDefinedError
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
undefined_symbol
)
{
if
(
possible_undeclared_dependency_
=
=
nullptr
&
&
undefine_resolved_name_
.
empty
(
)
)
{
AddError
(
element_name
descriptor
location
"
\
"
"
+
undefined_symbol
+
"
\
"
is
not
defined
.
"
)
;
}
else
{
if
(
possible_undeclared_dependency_
!
=
nullptr
)
{
AddError
(
element_name
descriptor
location
"
\
"
"
+
possible_undeclared_dependency_name_
+
"
\
"
seems
to
be
defined
in
\
"
"
+
possible_undeclared_dependency_
-
>
name
(
)
+
"
\
"
which
is
not
"
"
imported
by
\
"
"
+
filename_
+
"
\
"
.
To
use
it
here
please
"
"
add
the
necessary
import
.
"
)
;
}
if
(
!
undefine_resolved_name_
.
empty
(
)
)
{
AddError
(
element_name
descriptor
location
"
\
"
"
+
undefined_symbol
+
"
\
"
is
resolved
to
\
"
"
+
undefine_resolved_name_
+
"
\
"
which
is
not
defined
.
"
"
The
innermost
scope
is
searched
first
in
name
resolution
.
"
"
Consider
using
a
leading
'
.
'
(
i
.
e
.
\
"
.
"
+
undefined_symbol
+
"
\
"
)
to
start
from
the
outermost
scope
.
"
)
;
}
}
}
void
DescriptorBuilder
:
:
AddWarning
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
error
)
{
if
(
error_collector_
=
=
nullptr
)
{
GOOGLE_LOG
(
WARNING
)
<
<
filename_
<
<
"
"
<
<
element_name
<
<
"
:
"
<
<
error
;
}
else
{
error_collector_
-
>
AddWarning
(
filename_
element_name
&
descriptor
location
error
)
;
}
}
bool
DescriptorBuilder
:
:
IsInPackage
(
const
FileDescriptor
*
file
const
std
:
:
string
&
package_name
)
{
return
HasPrefixString
(
file
-
>
package
(
)
package_name
)
&
&
(
file
-
>
package
(
)
.
size
(
)
=
=
package_name
.
size
(
)
|
|
file
-
>
package
(
)
[
package_name
.
size
(
)
]
=
=
'
.
'
)
;
}
void
DescriptorBuilder
:
:
RecordPublicDependencies
(
const
FileDescriptor
*
file
)
{
if
(
file
=
=
nullptr
|
|
!
dependencies_
.
insert
(
file
)
.
second
)
return
;
for
(
int
i
=
0
;
file
!
=
nullptr
&
&
i
<
file
-
>
public_dependency_count
(
)
;
i
+
+
)
{
RecordPublicDependencies
(
file
-
>
public_dependency
(
i
)
)
;
}
}
Symbol
DescriptorBuilder
:
:
FindSymbolNotEnforcingDepsHelper
(
const
DescriptorPool
*
pool
const
std
:
:
string
&
name
bool
build_it
)
{
MutexLockMaybe
lock
(
(
pool
=
=
pool_
)
?
nullptr
:
pool
-
>
mutex_
)
;
Symbol
result
=
pool
-
>
tables_
-
>
FindSymbol
(
name
)
;
if
(
result
.
IsNull
(
)
&
&
pool
-
>
underlay_
!
=
nullptr
)
{
result
=
FindSymbolNotEnforcingDepsHelper
(
pool
-
>
underlay_
name
)
;
}
if
(
result
.
IsNull
(
)
)
{
if
(
build_it
&
&
pool
-
>
TryFindSymbolInFallbackDatabase
(
name
)
)
{
result
=
pool
-
>
tables_
-
>
FindSymbol
(
name
)
;
}
}
return
result
;
}
Symbol
DescriptorBuilder
:
:
FindSymbolNotEnforcingDeps
(
const
std
:
:
string
&
name
bool
build_it
)
{
Symbol
result
=
FindSymbolNotEnforcingDepsHelper
(
pool_
name
build_it
)
;
const
FileDescriptor
*
file
=
result
.
GetFile
(
)
;
if
(
file
=
=
file_
|
|
dependencies_
.
count
(
file
)
>
0
)
{
unused_dependency_
.
erase
(
file
)
;
}
return
result
;
}
Symbol
DescriptorBuilder
:
:
FindSymbol
(
const
std
:
:
string
&
name
bool
build_it
)
{
Symbol
result
=
FindSymbolNotEnforcingDeps
(
name
build_it
)
;
if
(
result
.
IsNull
(
)
)
return
result
;
if
(
!
pool_
-
>
enforce_dependencies_
)
{
return
result
;
}
const
FileDescriptor
*
file
=
result
.
GetFile
(
)
;
if
(
file
=
=
file_
|
|
dependencies_
.
count
(
file
)
>
0
)
{
return
result
;
}
if
(
result
.
type
=
=
Symbol
:
:
PACKAGE
)
{
if
(
IsInPackage
(
file_
name
)
)
return
result
;
for
(
std
:
:
set
<
const
FileDescriptor
*
>
:
:
const_iterator
it
=
dependencies_
.
begin
(
)
;
it
!
=
dependencies_
.
end
(
)
;
+
+
it
)
{
if
(
*
it
!
=
nullptr
&
&
IsInPackage
(
*
it
name
)
)
return
result
;
}
}
possible_undeclared_dependency_
=
file
;
possible_undeclared_dependency_name_
=
name
;
return
kNullSymbol
;
}
Symbol
DescriptorBuilder
:
:
LookupSymbolNoPlaceholder
(
const
std
:
:
string
&
name
const
std
:
:
string
&
relative_to
ResolveMode
resolve_mode
bool
build_it
)
{
possible_undeclared_dependency_
=
nullptr
;
undefine_resolved_name_
.
clear
(
)
;
if
(
!
name
.
empty
(
)
&
&
name
[
0
]
=
=
'
.
'
)
{
return
FindSymbol
(
name
.
substr
(
1
)
build_it
)
;
}
std
:
:
string
:
:
size_type
name_dot_pos
=
name
.
find_first_of
(
'
.
'
)
;
std
:
:
string
first_part_of_name
;
if
(
name_dot_pos
=
=
std
:
:
string
:
:
npos
)
{
first_part_of_name
=
name
;
}
else
{
first_part_of_name
=
name
.
substr
(
0
name_dot_pos
)
;
}
std
:
:
string
scope_to_try
(
relative_to
)
;
while
(
true
)
{
std
:
:
string
:
:
size_type
dot_pos
=
scope_to_try
.
find_last_of
(
'
.
'
)
;
if
(
dot_pos
=
=
std
:
:
string
:
:
npos
)
{
return
FindSymbol
(
name
build_it
)
;
}
else
{
scope_to_try
.
erase
(
dot_pos
)
;
}
std
:
:
string
:
:
size_type
old_size
=
scope_to_try
.
size
(
)
;
scope_to_try
.
append
(
1
'
.
'
)
;
scope_to_try
.
append
(
first_part_of_name
)
;
Symbol
result
=
FindSymbol
(
scope_to_try
build_it
)
;
if
(
!
result
.
IsNull
(
)
)
{
if
(
first_part_of_name
.
size
(
)
<
name
.
size
(
)
)
{
if
(
result
.
IsAggregate
(
)
)
{
scope_to_try
.
append
(
name
first_part_of_name
.
size
(
)
name
.
size
(
)
-
first_part_of_name
.
size
(
)
)
;
result
=
FindSymbol
(
scope_to_try
build_it
)
;
if
(
result
.
IsNull
(
)
)
{
undefine_resolved_name_
=
scope_to_try
;
}
return
result
;
}
else
{
}
}
else
{
if
(
resolve_mode
=
=
LOOKUP_TYPES
&
&
!
result
.
IsType
(
)
)
{
}
else
{
return
result
;
}
}
}
scope_to_try
.
erase
(
old_size
)
;
}
}
Symbol
DescriptorBuilder
:
:
LookupSymbol
(
const
std
:
:
string
&
name
const
std
:
:
string
&
relative_to
DescriptorPool
:
:
PlaceholderType
placeholder_type
ResolveMode
resolve_mode
bool
build_it
)
{
Symbol
result
=
LookupSymbolNoPlaceholder
(
name
relative_to
resolve_mode
build_it
)
;
if
(
result
.
IsNull
(
)
&
&
pool_
-
>
allow_unknown_
)
{
result
=
pool_
-
>
NewPlaceholderWithMutexHeld
(
name
placeholder_type
)
;
}
return
result
;
}
static
bool
ValidateQualifiedName
(
const
std
:
:
string
&
name
)
{
bool
last_was_period
=
false
;
for
(
int
i
=
0
;
i
<
name
.
size
(
)
;
i
+
+
)
{
if
(
(
'
a
'
<
=
name
[
i
]
&
&
name
[
i
]
<
=
'
z
'
)
|
|
(
'
A
'
<
=
name
[
i
]
&
&
name
[
i
]
<
=
'
Z
'
)
|
|
(
'
0
'
<
=
name
[
i
]
&
&
name
[
i
]
<
=
'
9
'
)
|
|
(
name
[
i
]
=
=
'
_
'
)
)
{
last_was_period
=
false
;
}
else
if
(
name
[
i
]
=
=
'
.
'
)
{
if
(
last_was_period
)
return
false
;
last_was_period
=
true
;
}
else
{
return
false
;
}
}
return
!
name
.
empty
(
)
&
&
!
last_was_period
;
}
Symbol
DescriptorPool
:
:
NewPlaceholder
(
const
std
:
:
string
&
name
PlaceholderType
placeholder_type
)
const
{
MutexLockMaybe
lock
(
mutex_
)
;
return
NewPlaceholderWithMutexHeld
(
name
placeholder_type
)
;
}
Symbol
DescriptorPool
:
:
NewPlaceholderWithMutexHeld
(
const
std
:
:
string
&
name
PlaceholderType
placeholder_type
)
const
{
if
(
mutex_
)
{
mutex_
-
>
AssertHeld
(
)
;
}
const
std
:
:
string
*
placeholder_full_name
;
const
std
:
:
string
*
placeholder_name
;
const
std
:
:
string
*
placeholder_package
;
if
(
!
ValidateQualifiedName
(
name
)
)
return
kNullSymbol
;
if
(
name
[
0
]
=
=
'
.
'
)
{
placeholder_full_name
=
tables_
-
>
AllocateString
(
name
.
substr
(
1
)
)
;
}
else
{
placeholder_full_name
=
tables_
-
>
AllocateString
(
name
)
;
}
std
:
:
string
:
:
size_type
dotpos
=
placeholder_full_name
-
>
find_last_of
(
'
.
'
)
;
if
(
dotpos
!
=
std
:
:
string
:
:
npos
)
{
placeholder_package
=
tables_
-
>
AllocateString
(
placeholder_full_name
-
>
substr
(
0
dotpos
)
)
;
placeholder_name
=
tables_
-
>
AllocateString
(
placeholder_full_name
-
>
substr
(
dotpos
+
1
)
)
;
}
else
{
placeholder_package
=
&
internal
:
:
GetEmptyString
(
)
;
placeholder_name
=
placeholder_full_name
;
}
FileDescriptor
*
placeholder_file
=
NewPlaceholderFileWithMutexHeld
(
*
placeholder_full_name
+
"
.
placeholder
.
proto
"
)
;
placeholder_file
-
>
package_
=
placeholder_package
;
if
(
placeholder_type
=
=
PLACEHOLDER_ENUM
)
{
placeholder_file
-
>
enum_type_count_
=
1
;
placeholder_file
-
>
enum_types_
=
tables_
-
>
AllocateArray
<
EnumDescriptor
>
(
1
)
;
EnumDescriptor
*
placeholder_enum
=
&
placeholder_file
-
>
enum_types_
[
0
]
;
memset
(
static_cast
<
void
*
>
(
placeholder_enum
)
0
sizeof
(
*
placeholder_enum
)
)
;
placeholder_enum
-
>
full_name_
=
placeholder_full_name
;
placeholder_enum
-
>
name_
=
placeholder_name
;
placeholder_enum
-
>
file_
=
placeholder_file
;
placeholder_enum
-
>
options_
=
&
EnumOptions
:
:
default_instance
(
)
;
placeholder_enum
-
>
is_placeholder_
=
true
;
placeholder_enum
-
>
is_unqualified_placeholder_
=
(
name
[
0
]
!
=
'
.
'
)
;
placeholder_enum
-
>
value_count_
=
1
;
placeholder_enum
-
>
values_
=
tables_
-
>
AllocateArray
<
EnumValueDescriptor
>
(
1
)
;
EnumValueDescriptor
*
placeholder_value
=
&
placeholder_enum
-
>
values_
[
0
]
;
memset
(
static_cast
<
void
*
>
(
placeholder_value
)
0
sizeof
(
*
placeholder_value
)
)
;
placeholder_value
-
>
name_
=
tables_
-
>
AllocateString
(
"
PLACEHOLDER_VALUE
"
)
;
placeholder_value
-
>
full_name_
=
placeholder_package
-
>
empty
(
)
?
placeholder_value
-
>
name_
:
tables_
-
>
AllocateString
(
*
placeholder_package
+
"
.
PLACEHOLDER_VALUE
"
)
;
placeholder_value
-
>
number_
=
0
;
placeholder_value
-
>
type_
=
placeholder_enum
;
placeholder_value
-
>
options_
=
&
EnumValueOptions
:
:
default_instance
(
)
;
return
Symbol
(
placeholder_enum
)
;
}
else
{
placeholder_file
-
>
message_type_count_
=
1
;
placeholder_file
-
>
message_types_
=
tables_
-
>
AllocateArray
<
Descriptor
>
(
1
)
;
Descriptor
*
placeholder_message
=
&
placeholder_file
-
>
message_types_
[
0
]
;
memset
(
static_cast
<
void
*
>
(
placeholder_message
)
0
sizeof
(
*
placeholder_message
)
)
;
placeholder_message
-
>
full_name_
=
placeholder_full_name
;
placeholder_message
-
>
name_
=
placeholder_name
;
placeholder_message
-
>
file_
=
placeholder_file
;
placeholder_message
-
>
options_
=
&
MessageOptions
:
:
default_instance
(
)
;
placeholder_message
-
>
is_placeholder_
=
true
;
placeholder_message
-
>
is_unqualified_placeholder_
=
(
name
[
0
]
!
=
'
.
'
)
;
if
(
placeholder_type
=
=
PLACEHOLDER_EXTENDABLE_MESSAGE
)
{
placeholder_message
-
>
extension_range_count_
=
1
;
placeholder_message
-
>
extension_ranges_
=
tables_
-
>
AllocateArray
<
Descriptor
:
:
ExtensionRange
>
(
1
)
;
placeholder_message
-
>
extension_ranges_
-
>
start
=
1
;
placeholder_message
-
>
extension_ranges_
-
>
end
=
FieldDescriptor
:
:
kMaxNumber
+
1
;
}
return
Symbol
(
placeholder_message
)
;
}
}
FileDescriptor
*
DescriptorPool
:
:
NewPlaceholderFile
(
const
std
:
:
string
&
name
)
const
{
MutexLockMaybe
lock
(
mutex_
)
;
return
NewPlaceholderFileWithMutexHeld
(
name
)
;
}
FileDescriptor
*
DescriptorPool
:
:
NewPlaceholderFileWithMutexHeld
(
const
std
:
:
string
&
name
)
const
{
if
(
mutex_
)
{
mutex_
-
>
AssertHeld
(
)
;
}
FileDescriptor
*
placeholder
=
tables_
-
>
Allocate
<
FileDescriptor
>
(
)
;
memset
(
static_cast
<
void
*
>
(
placeholder
)
0
sizeof
(
*
placeholder
)
)
;
placeholder
-
>
name_
=
tables_
-
>
AllocateString
(
name
)
;
placeholder
-
>
package_
=
&
internal
:
:
GetEmptyString
(
)
;
placeholder
-
>
pool_
=
this
;
placeholder
-
>
options_
=
&
FileOptions
:
:
default_instance
(
)
;
placeholder
-
>
tables_
=
&
FileDescriptorTables
:
:
GetEmptyInstance
(
)
;
placeholder
-
>
source_code_info_
=
&
SourceCodeInfo
:
:
default_instance
(
)
;
placeholder
-
>
is_placeholder_
=
true
;
placeholder
-
>
syntax_
=
FileDescriptor
:
:
SYNTAX_PROTO2
;
placeholder
-
>
finished_building_
=
true
;
return
placeholder
;
}
bool
DescriptorBuilder
:
:
AddSymbol
(
const
std
:
:
string
&
full_name
const
void
*
parent
const
std
:
:
string
&
name
const
Message
&
proto
Symbol
symbol
)
{
if
(
parent
=
=
nullptr
)
parent
=
file_
;
if
(
tables_
-
>
AddSymbol
(
full_name
symbol
)
)
{
if
(
!
file_tables_
-
>
AddAliasUnderParent
(
parent
name
symbol
)
)
{
if
(
!
had_errors_
)
{
GOOGLE_LOG
(
DFATAL
)
<
<
"
\
"
"
<
<
full_name
<
<
"
\
"
not
previously
defined
in
"
"
symbols_by_name_
but
was
defined
in
"
"
symbols_by_parent_
;
this
shouldn
'
t
be
possible
.
"
;
}
return
false
;
}
return
true
;
}
else
{
const
FileDescriptor
*
other_file
=
tables_
-
>
FindSymbol
(
full_name
)
.
GetFile
(
)
;
if
(
other_file
=
=
file_
)
{
std
:
:
string
:
:
size_type
dot_pos
=
full_name
.
find_last_of
(
'
.
'
)
;
if
(
dot_pos
=
=
std
:
:
string
:
:
npos
)
{
AddError
(
full_name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
\
"
"
+
full_name
+
"
\
"
is
already
defined
.
"
)
;
}
else
{
AddError
(
full_name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
\
"
"
+
full_name
.
substr
(
dot_pos
+
1
)
+
"
\
"
is
already
defined
in
\
"
"
+
full_name
.
substr
(
0
dot_pos
)
+
"
\
"
.
"
)
;
}
}
else
{
AddError
(
full_name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
\
"
"
+
full_name
+
"
\
"
is
already
defined
in
file
\
"
"
+
other_file
-
>
name
(
)
+
"
\
"
.
"
)
;
}
return
false
;
}
}
void
DescriptorBuilder
:
:
AddPackage
(
const
std
:
:
string
&
name
const
Message
&
proto
const
FileDescriptor
*
file
)
{
if
(
tables_
-
>
AddSymbol
(
name
Symbol
(
file
)
)
)
{
std
:
:
string
:
:
size_type
dot_pos
=
name
.
find_last_of
(
'
.
'
)
;
if
(
dot_pos
=
=
std
:
:
string
:
:
npos
)
{
ValidateSymbolName
(
name
name
proto
)
;
}
else
{
std
:
:
string
*
parent_name
=
tables_
-
>
AllocateString
(
name
.
substr
(
0
dot_pos
)
)
;
AddPackage
(
*
parent_name
proto
file
)
;
ValidateSymbolName
(
name
.
substr
(
dot_pos
+
1
)
name
proto
)
;
}
}
else
{
Symbol
existing_symbol
=
tables_
-
>
FindSymbol
(
name
)
;
if
(
existing_symbol
.
type
!
=
Symbol
:
:
PACKAGE
)
{
AddError
(
name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
\
"
"
+
name
+
"
\
"
is
already
defined
(
as
something
other
than
"
"
a
package
)
in
file
\
"
"
+
existing_symbol
.
GetFile
(
)
-
>
name
(
)
+
"
\
"
.
"
)
;
}
}
}
void
DescriptorBuilder
:
:
ValidateSymbolName
(
const
std
:
:
string
&
name
const
std
:
:
string
&
full_name
const
Message
&
proto
)
{
if
(
name
.
empty
(
)
)
{
AddError
(
full_name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Missing
name
.
"
)
;
}
else
{
for
(
int
i
=
0
;
i
<
name
.
size
(
)
;
i
+
+
)
{
if
(
(
name
[
i
]
<
'
a
'
|
|
'
z
'
<
name
[
i
]
)
&
&
(
name
[
i
]
<
'
A
'
|
|
'
Z
'
<
name
[
i
]
)
&
&
(
name
[
i
]
<
'
0
'
|
|
'
9
'
<
name
[
i
]
)
&
&
(
name
[
i
]
!
=
'
_
'
)
)
{
AddError
(
full_name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
\
"
"
+
name
+
"
\
"
is
not
a
valid
identifier
.
"
)
;
}
}
}
}
template
<
class
DescriptorT
>
void
DescriptorBuilder
:
:
AllocateOptions
(
const
typename
DescriptorT
:
:
OptionsType
&
orig_options
DescriptorT
*
descriptor
int
options_field_tag
const
std
:
:
string
&
option_name
)
{
std
:
:
vector
<
int
>
options_path
;
descriptor
-
>
GetLocationPath
(
&
options_path
)
;
options_path
.
push_back
(
options_field_tag
)
;
AllocateOptionsImpl
(
descriptor
-
>
full_name
(
)
descriptor
-
>
full_name
(
)
orig_options
descriptor
options_path
option_name
)
;
}
void
DescriptorBuilder
:
:
AllocateOptions
(
const
FileOptions
&
orig_options
FileDescriptor
*
descriptor
)
{
std
:
:
vector
<
int
>
options_path
;
options_path
.
push_back
(
FileDescriptorProto
:
:
kOptionsFieldNumber
)
;
AllocateOptionsImpl
(
descriptor
-
>
package
(
)
+
"
.
dummy
"
descriptor
-
>
name
(
)
orig_options
descriptor
options_path
"
google
.
protobuf
.
FileOptions
"
)
;
}
template
<
class
DescriptorT
>
void
DescriptorBuilder
:
:
AllocateOptionsImpl
(
const
std
:
:
string
&
name_scope
const
std
:
:
string
&
element_name
const
typename
DescriptorT
:
:
OptionsType
&
orig_options
DescriptorT
*
descriptor
const
std
:
:
vector
<
int
>
&
options_path
const
std
:
:
string
&
option_name
)
{
typename
DescriptorT
:
:
OptionsType
*
const
dummy
=
nullptr
;
typename
DescriptorT
:
:
OptionsType
*
options
=
tables_
-
>
AllocateMessage
(
dummy
)
;
if
(
!
orig_options
.
IsInitialized
(
)
)
{
AddError
(
name_scope
+
"
.
"
+
element_name
orig_options
DescriptorPool
:
:
ErrorCollector
:
:
OPTION_NAME
"
Uninterpreted
option
is
missing
name
or
value
.
"
)
;
return
;
}
options
-
>
ParseFromString
(
orig_options
.
SerializeAsString
(
)
)
;
descriptor
-
>
options_
=
options
;
if
(
options
-
>
uninterpreted_option_size
(
)
>
0
)
{
options_to_interpret_
.
push_back
(
OptionsToInterpret
(
name_scope
element_name
options_path
&
orig_options
options
)
)
;
}
const
UnknownFieldSet
&
unknown_fields
=
orig_options
.
unknown_fields
(
)
;
if
(
!
unknown_fields
.
empty
(
)
)
{
Symbol
msg_symbol
=
tables_
-
>
FindSymbol
(
option_name
)
;
if
(
msg_symbol
.
type
=
=
Symbol
:
:
MESSAGE
)
{
for
(
int
i
=
0
;
i
<
unknown_fields
.
field_count
(
)
;
+
+
i
)
{
assert_mutex_held
(
pool_
)
;
const
FieldDescriptor
*
field
=
pool_
-
>
InternalFindExtensionByNumberNoLock
(
msg_symbol
.
descriptor
unknown_fields
.
field
(
i
)
.
number
(
)
)
;
if
(
field
)
{
unused_dependency_
.
erase
(
field
-
>
file
(
)
)
;
}
}
}
}
}
#
define
BUILD_ARRAY
(
INPUT
OUTPUT
NAME
METHOD
PARENT
)
\
OUTPUT
-
>
NAME
#
#
_count_
=
INPUT
.
NAME
#
#
_size
(
)
;
\
AllocateArray
(
INPUT
.
NAME
#
#
_size
(
)
&
OUTPUT
-
>
NAME
#
#
s_
)
;
\
for
(
int
i
=
0
;
i
<
INPUT
.
NAME
#
#
_size
(
)
;
i
+
+
)
{
\
METHOD
(
INPUT
.
NAME
(
i
)
PARENT
OUTPUT
-
>
NAME
#
#
s_
+
i
)
;
\
}
void
DescriptorBuilder
:
:
AddRecursiveImportError
(
const
FileDescriptorProto
&
proto
int
from_here
)
{
std
:
:
string
error_message
(
"
File
recursively
imports
itself
:
"
)
;
for
(
int
i
=
from_here
;
i
<
tables_
-
>
pending_files_
.
size
(
)
;
i
+
+
)
{
error_message
.
append
(
tables_
-
>
pending_files_
[
i
]
)
;
error_message
.
append
(
"
-
>
"
)
;
}
error_message
.
append
(
proto
.
name
(
)
)
;
if
(
from_here
<
tables_
-
>
pending_files_
.
size
(
)
-
1
)
{
AddError
(
tables_
-
>
pending_files_
[
from_here
+
1
]
proto
DescriptorPool
:
:
ErrorCollector
:
:
IMPORT
error_message
)
;
}
else
{
AddError
(
proto
.
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
IMPORT
error_message
)
;
}
}
void
DescriptorBuilder
:
:
AddTwiceListedError
(
const
FileDescriptorProto
&
proto
int
index
)
{
AddError
(
proto
.
dependency
(
index
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
IMPORT
"
Import
\
"
"
+
proto
.
dependency
(
index
)
+
"
\
"
was
listed
twice
.
"
)
;
}
void
DescriptorBuilder
:
:
AddImportError
(
const
FileDescriptorProto
&
proto
int
index
)
{
std
:
:
string
message
;
if
(
pool_
-
>
fallback_database_
=
=
nullptr
)
{
message
=
"
Import
\
"
"
+
proto
.
dependency
(
index
)
+
"
\
"
has
not
been
loaded
.
"
;
}
else
{
message
=
"
Import
\
"
"
+
proto
.
dependency
(
index
)
+
"
\
"
was
not
found
or
had
errors
.
"
;
}
AddError
(
proto
.
dependency
(
index
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
IMPORT
message
)
;
}
static
bool
ExistingFileMatchesProto
(
const
FileDescriptor
*
existing_file
const
FileDescriptorProto
&
proto
)
{
FileDescriptorProto
existing_proto
;
existing_file
-
>
CopyTo
(
&
existing_proto
)
;
if
(
existing_file
-
>
syntax
(
)
=
=
FileDescriptor
:
:
SYNTAX_PROTO2
&
&
proto
.
has_syntax
(
)
)
{
existing_proto
.
set_syntax
(
existing_file
-
>
SyntaxName
(
existing_file
-
>
syntax
(
)
)
)
;
}
return
existing_proto
.
SerializeAsString
(
)
=
=
proto
.
SerializeAsString
(
)
;
}
const
FileDescriptor
*
DescriptorBuilder
:
:
BuildFile
(
const
FileDescriptorProto
&
proto
)
{
filename_
=
proto
.
name
(
)
;
const
FileDescriptor
*
existing_file
=
tables_
-
>
FindFile
(
filename_
)
;
if
(
existing_file
!
=
nullptr
)
{
if
(
ExistingFileMatchesProto
(
existing_file
proto
)
)
{
return
existing_file
;
}
}
for
(
int
i
=
0
;
i
<
tables_
-
>
pending_files_
.
size
(
)
;
i
+
+
)
{
if
(
tables_
-
>
pending_files_
[
i
]
=
=
proto
.
name
(
)
)
{
AddRecursiveImportError
(
proto
i
)
;
return
nullptr
;
}
}
if
(
!
pool_
-
>
lazily_build_dependencies_
)
{
if
(
pool_
-
>
fallback_database_
!
=
nullptr
)
{
tables_
-
>
pending_files_
.
push_back
(
proto
.
name
(
)
)
;
for
(
int
i
=
0
;
i
<
proto
.
dependency_size
(
)
;
i
+
+
)
{
if
(
tables_
-
>
FindFile
(
proto
.
dependency
(
i
)
)
=
=
nullptr
&
&
(
pool_
-
>
underlay_
=
=
nullptr
|
|
pool_
-
>
underlay_
-
>
FindFileByName
(
proto
.
dependency
(
i
)
)
=
=
nullptr
)
)
{
pool_
-
>
TryFindFileInFallbackDatabase
(
proto
.
dependency
(
i
)
)
;
}
}
tables_
-
>
pending_files_
.
pop_back
(
)
;
}
}
tables_
-
>
AddCheckpoint
(
)
;
FileDescriptor
*
result
=
BuildFileImpl
(
proto
)
;
file_tables_
-
>
FinalizeTables
(
)
;
if
(
result
)
{
tables_
-
>
ClearLastCheckpoint
(
)
;
result
-
>
finished_building_
=
true
;
}
else
{
tables_
-
>
RollbackToLastCheckpoint
(
)
;
}
return
result
;
}
FileDescriptor
*
DescriptorBuilder
:
:
BuildFileImpl
(
const
FileDescriptorProto
&
proto
)
{
FileDescriptor
*
result
=
tables_
-
>
Allocate
<
FileDescriptor
>
(
)
;
file_
=
result
;
result
-
>
is_placeholder_
=
false
;
result
-
>
finished_building_
=
false
;
SourceCodeInfo
*
info
=
nullptr
;
if
(
proto
.
has_source_code_info
(
)
)
{
info
=
tables_
-
>
AllocateMessage
<
SourceCodeInfo
>
(
)
;
info
-
>
CopyFrom
(
proto
.
source_code_info
(
)
)
;
result
-
>
source_code_info_
=
info
;
}
else
{
result
-
>
source_code_info_
=
&
SourceCodeInfo
:
:
default_instance
(
)
;
}
file_tables_
=
tables_
-
>
AllocateFileTables
(
)
;
file_
-
>
tables_
=
file_tables_
;
if
(
!
proto
.
has_name
(
)
)
{
AddError
(
"
"
proto
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
Missing
field
:
FileDescriptorProto
.
name
.
"
)
;
}
if
(
proto
.
syntax
(
)
.
empty
(
)
|
|
proto
.
syntax
(
)
=
=
"
proto2
"
)
{
file_
-
>
syntax_
=
FileDescriptor
:
:
SYNTAX_PROTO2
;
}
else
if
(
proto
.
syntax
(
)
=
=
"
proto3
"
)
{
file_
-
>
syntax_
=
FileDescriptor
:
:
SYNTAX_PROTO3
;
}
else
{
file_
-
>
syntax_
=
FileDescriptor
:
:
SYNTAX_UNKNOWN
;
AddError
(
proto
.
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
Unrecognized
syntax
:
"
+
proto
.
syntax
(
)
)
;
}
result
-
>
name_
=
tables_
-
>
AllocateString
(
proto
.
name
(
)
)
;
if
(
proto
.
has_package
(
)
)
{
result
-
>
package_
=
tables_
-
>
AllocateString
(
proto
.
package
(
)
)
;
}
else
{
result
-
>
package_
=
tables_
-
>
AllocateString
(
"
"
)
;
}
result
-
>
pool_
=
pool_
;
if
(
!
tables_
-
>
AddFile
(
result
)
)
{
AddError
(
proto
.
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
A
file
with
this
name
is
already
in
the
pool
.
"
)
;
return
nullptr
;
}
if
(
!
result
-
>
package
(
)
.
empty
(
)
)
{
AddPackage
(
result
-
>
package
(
)
proto
result
)
;
}
std
:
:
set
<
std
:
:
string
>
seen_dependencies
;
result
-
>
dependency_count_
=
proto
.
dependency_size
(
)
;
result
-
>
dependencies_
=
tables_
-
>
AllocateArray
<
const
FileDescriptor
*
>
(
proto
.
dependency_size
(
)
)
;
if
(
pool_
-
>
lazily_build_dependencies_
)
{
result
-
>
dependencies_once_
=
tables_
-
>
AllocateOnceDynamic
(
)
;
result
-
>
dependencies_names_
=
tables_
-
>
AllocateArray
<
const
std
:
:
string
*
>
(
proto
.
dependency_size
(
)
)
;
if
(
proto
.
dependency_size
(
)
>
0
)
{
memset
(
result
-
>
dependencies_names_
0
sizeof
(
*
result
-
>
dependencies_names_
)
*
proto
.
dependency_size
(
)
)
;
}
}
else
{
result
-
>
dependencies_once_
=
nullptr
;
result
-
>
dependencies_names_
=
nullptr
;
}
unused_dependency_
.
clear
(
)
;
std
:
:
set
<
int
>
weak_deps
;
for
(
int
i
=
0
;
i
<
proto
.
weak_dependency_size
(
)
;
+
+
i
)
{
weak_deps
.
insert
(
proto
.
weak_dependency
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
proto
.
dependency_size
(
)
;
i
+
+
)
{
if
(
!
seen_dependencies
.
insert
(
proto
.
dependency
(
i
)
)
.
second
)
{
AddTwiceListedError
(
proto
i
)
;
}
const
FileDescriptor
*
dependency
=
tables_
-
>
FindFile
(
proto
.
dependency
(
i
)
)
;
if
(
dependency
=
=
nullptr
&
&
pool_
-
>
underlay_
!
=
nullptr
)
{
dependency
=
pool_
-
>
underlay_
-
>
FindFileByName
(
proto
.
dependency
(
i
)
)
;
}
if
(
dependency
=
=
result
)
{
return
nullptr
;
}
if
(
dependency
=
=
nullptr
)
{
if
(
!
pool_
-
>
lazily_build_dependencies_
)
{
if
(
pool_
-
>
allow_unknown_
|
|
(
!
pool_
-
>
enforce_weak_
&
&
weak_deps
.
find
(
i
)
!
=
weak_deps
.
end
(
)
)
)
{
dependency
=
pool_
-
>
NewPlaceholderFileWithMutexHeld
(
proto
.
dependency
(
i
)
)
;
}
else
{
AddImportError
(
proto
i
)
;
}
}
}
else
{
if
(
pool_
-
>
enforce_dependencies_
&
&
(
pool_
-
>
unused_import_track_files_
.
find
(
proto
.
name
(
)
)
!
=
pool_
-
>
unused_import_track_files_
.
end
(
)
)
&
&
(
dependency
-
>
public_dependency_count
(
)
=
=
0
)
)
{
unused_dependency_
.
insert
(
dependency
)
;
}
}
result
-
>
dependencies_
[
i
]
=
dependency
;
if
(
pool_
-
>
lazily_build_dependencies_
&
&
!
dependency
)
{
result
-
>
dependencies_names_
[
i
]
=
tables_
-
>
AllocateString
(
proto
.
dependency
(
i
)
)
;
}
}
int
public_dependency_count
=
0
;
result
-
>
public_dependencies_
=
tables_
-
>
AllocateArray
<
int
>
(
proto
.
public_dependency_size
(
)
)
;
for
(
int
i
=
0
;
i
<
proto
.
public_dependency_size
(
)
;
i
+
+
)
{
int
index
=
proto
.
public_dependency
(
i
)
;
if
(
index
>
=
0
&
&
index
<
proto
.
dependency_size
(
)
)
{
result
-
>
public_dependencies_
[
public_dependency_count
+
+
]
=
index
;
if
(
!
pool_
-
>
lazily_build_dependencies_
)
{
unused_dependency_
.
erase
(
result
-
>
dependency
(
index
)
)
;
}
}
else
{
AddError
(
proto
.
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
Invalid
public
dependency
index
.
"
)
;
}
}
result
-
>
public_dependency_count_
=
public_dependency_count
;
dependencies_
.
clear
(
)
;
if
(
!
pool_
-
>
lazily_build_dependencies_
)
{
for
(
int
i
=
0
;
i
<
result
-
>
dependency_count
(
)
;
i
+
+
)
{
RecordPublicDependencies
(
result
-
>
dependency
(
i
)
)
;
}
}
int
weak_dependency_count
=
0
;
result
-
>
weak_dependencies_
=
tables_
-
>
AllocateArray
<
int
>
(
proto
.
weak_dependency_size
(
)
)
;
for
(
int
i
=
0
;
i
<
proto
.
weak_dependency_size
(
)
;
i
+
+
)
{
int
index
=
proto
.
weak_dependency
(
i
)
;
if
(
index
>
=
0
&
&
index
<
proto
.
dependency_size
(
)
)
{
result
-
>
weak_dependencies_
[
weak_dependency_count
+
+
]
=
index
;
}
else
{
AddError
(
proto
.
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
Invalid
weak
dependency
index
.
"
)
;
}
}
result
-
>
weak_dependency_count_
=
weak_dependency_count
;
BUILD_ARRAY
(
proto
result
message_type
BuildMessage
nullptr
)
;
BUILD_ARRAY
(
proto
result
enum_type
BuildEnum
nullptr
)
;
BUILD_ARRAY
(
proto
result
service
BuildService
nullptr
)
;
BUILD_ARRAY
(
proto
result
extension
BuildExtension
nullptr
)
;
if
(
!
proto
.
has_options
(
)
)
{
result
-
>
options_
=
nullptr
;
}
else
{
AllocateOptions
(
proto
.
options
(
)
result
)
;
}
CrossLinkFile
(
result
proto
)
;
if
(
!
had_errors_
)
{
OptionInterpreter
option_interpreter
(
this
)
;
for
(
std
:
:
vector
<
OptionsToInterpret
>
:
:
iterator
iter
=
options_to_interpret_
.
begin
(
)
;
iter
!
=
options_to_interpret_
.
end
(
)
;
+
+
iter
)
{
option_interpreter
.
InterpretOptions
(
&
(
*
iter
)
)
;
}
options_to_interpret_
.
clear
(
)
;
if
(
info
!
=
nullptr
)
{
option_interpreter
.
UpdateSourceCodeInfo
(
info
)
;
}
}
if
(
!
had_errors_
&
&
!
pool_
-
>
lazily_build_dependencies_
)
{
ValidateFileOptions
(
result
proto
)
;
}
if
(
had_errors_
)
{
for
(
int
i
=
0
;
i
<
proto
.
message_type_size
(
)
;
+
+
i
)
{
DetectMapConflicts
(
result
-
>
message_type
(
i
)
proto
.
message_type
(
i
)
)
;
}
}
if
(
!
unused_dependency_
.
empty
(
)
&
&
!
pool_
-
>
lazily_build_dependencies_
)
{
LogUnusedDependency
(
proto
result
)
;
}
if
(
had_errors_
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
std
:
:
string
*
DescriptorBuilder
:
:
AllocateNameString
(
const
std
:
:
string
&
scope
const
std
:
:
string
&
proto_name
)
{
std
:
:
string
*
full_name
;
if
(
scope
.
empty
(
)
)
{
full_name
=
tables_
-
>
AllocateString
(
proto_name
)
;
}
else
{
full_name
=
tables_
-
>
AllocateEmptyString
(
)
;
*
full_name
=
StrCat
(
scope
"
.
"
proto_name
)
;
}
return
full_name
;
}
void
DescriptorBuilder
:
:
BuildMessage
(
const
DescriptorProto
&
proto
const
Descriptor
*
parent
Descriptor
*
result
)
{
const
std
:
:
string
&
scope
=
(
parent
=
=
nullptr
)
?
file_
-
>
package
(
)
:
parent
-
>
full_name
(
)
;
std
:
:
string
*
full_name
=
AllocateNameString
(
scope
proto
.
name
(
)
)
;
ValidateSymbolName
(
proto
.
name
(
)
*
full_name
proto
)
;
result
-
>
name_
=
tables_
-
>
AllocateString
(
proto
.
name
(
)
)
;
result
-
>
full_name_
=
full_name
;
result
-
>
file_
=
file_
;
result
-
>
containing_type_
=
parent
;
result
-
>
is_placeholder_
=
false
;
result
-
>
is_unqualified_placeholder_
=
false
;
BUILD_ARRAY
(
proto
result
oneof_decl
BuildOneof
result
)
;
BUILD_ARRAY
(
proto
result
field
BuildField
result
)
;
BUILD_ARRAY
(
proto
result
nested_type
BuildMessage
result
)
;
BUILD_ARRAY
(
proto
result
enum_type
BuildEnum
result
)
;
BUILD_ARRAY
(
proto
result
extension_range
BuildExtensionRange
result
)
;
BUILD_ARRAY
(
proto
result
extension
BuildExtension
result
)
;
BUILD_ARRAY
(
proto
result
reserved_range
BuildReservedRange
result
)
;
int
reserved_name_count
=
proto
.
reserved_name_size
(
)
;
result
-
>
reserved_name_count_
=
reserved_name_count
;
result
-
>
reserved_names_
=
tables_
-
>
AllocateArray
<
const
std
:
:
string
*
>
(
reserved_name_count
)
;
for
(
int
i
=
0
;
i
<
reserved_name_count
;
+
+
i
)
{
result
-
>
reserved_names_
[
i
]
=
tables_
-
>
AllocateString
(
proto
.
reserved_name
(
i
)
)
;
}
if
(
!
proto
.
has_options
(
)
)
{
result
-
>
options_
=
nullptr
;
}
else
{
AllocateOptions
(
proto
.
options
(
)
result
DescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
MessageOptions
"
)
;
}
AddSymbol
(
result
-
>
full_name
(
)
parent
result
-
>
name
(
)
proto
Symbol
(
result
)
)
;
for
(
int
i
=
0
;
i
<
proto
.
reserved_range_size
(
)
;
i
+
+
)
{
const
DescriptorProto_ReservedRange
&
range1
=
proto
.
reserved_range
(
i
)
;
for
(
int
j
=
i
+
1
;
j
<
proto
.
reserved_range_size
(
)
;
j
+
+
)
{
const
DescriptorProto_ReservedRange
&
range2
=
proto
.
reserved_range
(
j
)
;
if
(
range1
.
end
(
)
>
range2
.
start
(
)
&
&
range2
.
end
(
)
>
range1
.
start
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
.
reserved_range
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Reserved
range
0
to
1
overlaps
with
"
"
already
-
defined
range
2
to
3
.
"
range2
.
start
(
)
range2
.
end
(
)
-
1
range1
.
start
(
)
range1
.
end
(
)
-
1
)
)
;
}
}
}
HASH_SET
<
std
:
:
string
>
reserved_name_set
;
for
(
int
i
=
0
;
i
<
proto
.
reserved_name_size
(
)
;
i
+
+
)
{
const
std
:
:
string
&
name
=
proto
.
reserved_name
(
i
)
;
if
(
reserved_name_set
.
find
(
name
)
=
=
reserved_name_set
.
end
(
)
)
{
reserved_name_set
.
insert
(
name
)
;
}
else
{
AddError
(
name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
strings
:
:
Substitute
(
"
Field
name
\
"
0
\
"
is
reserved
multiple
times
.
"
name
)
)
;
}
}
for
(
int
i
=
0
;
i
<
result
-
>
field_count
(
)
;
i
+
+
)
{
const
FieldDescriptor
*
field
=
result
-
>
field
(
i
)
;
for
(
int
j
=
0
;
j
<
result
-
>
extension_range_count
(
)
;
j
+
+
)
{
const
Descriptor
:
:
ExtensionRange
*
range
=
result
-
>
extension_range
(
j
)
;
if
(
range
-
>
start
<
=
field
-
>
number
(
)
&
&
field
-
>
number
(
)
<
range
-
>
end
)
{
AddError
(
field
-
>
full_name
(
)
proto
.
extension_range
(
j
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Extension
range
0
to
1
includes
field
\
"
2
\
"
(
3
)
.
"
range
-
>
start
range
-
>
end
-
1
field
-
>
name
(
)
field
-
>
number
(
)
)
)
;
}
}
for
(
int
j
=
0
;
j
<
result
-
>
reserved_range_count
(
)
;
j
+
+
)
{
const
Descriptor
:
:
ReservedRange
*
range
=
result
-
>
reserved_range
(
j
)
;
if
(
range
-
>
start
<
=
field
-
>
number
(
)
&
&
field
-
>
number
(
)
<
range
-
>
end
)
{
AddError
(
field
-
>
full_name
(
)
proto
.
reserved_range
(
j
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Field
\
"
0
\
"
uses
reserved
number
1
.
"
field
-
>
name
(
)
field
-
>
number
(
)
)
)
;
}
}
if
(
reserved_name_set
.
find
(
field
-
>
name
(
)
)
!
=
reserved_name_set
.
end
(
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
.
field
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NAME
strings
:
:
Substitute
(
"
Field
name
\
"
0
\
"
is
reserved
.
"
field
-
>
name
(
)
)
)
;
}
}
for
(
int
i
=
0
;
i
<
result
-
>
extension_range_count
(
)
;
i
+
+
)
{
const
Descriptor
:
:
ExtensionRange
*
range1
=
result
-
>
extension_range
(
i
)
;
for
(
int
j
=
0
;
j
<
result
-
>
reserved_range_count
(
)
;
j
+
+
)
{
const
Descriptor
:
:
ReservedRange
*
range2
=
result
-
>
reserved_range
(
j
)
;
if
(
range1
-
>
end
>
range2
-
>
start
&
&
range2
-
>
end
>
range1
-
>
start
)
{
AddError
(
result
-
>
full_name
(
)
proto
.
extension_range
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Extension
range
0
to
1
overlaps
with
"
"
reserved
range
2
to
3
.
"
range1
-
>
start
range1
-
>
end
-
1
range2
-
>
start
range2
-
>
end
-
1
)
)
;
}
}
for
(
int
j
=
i
+
1
;
j
<
result
-
>
extension_range_count
(
)
;
j
+
+
)
{
const
Descriptor
:
:
ExtensionRange
*
range2
=
result
-
>
extension_range
(
j
)
;
if
(
range1
-
>
end
>
range2
-
>
start
&
&
range2
-
>
end
>
range1
-
>
start
)
{
AddError
(
result
-
>
full_name
(
)
proto
.
extension_range
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Extension
range
0
to
1
overlaps
with
"
"
already
-
defined
range
2
to
3
.
"
range2
-
>
start
range2
-
>
end
-
1
range1
-
>
start
range1
-
>
end
-
1
)
)
;
}
}
}
}
void
DescriptorBuilder
:
:
BuildFieldOrExtension
(
const
FieldDescriptorProto
&
proto
const
Descriptor
*
parent
FieldDescriptor
*
result
bool
is_extension
)
{
const
std
:
:
string
&
scope
=
(
parent
=
=
nullptr
)
?
file_
-
>
package
(
)
:
parent
-
>
full_name
(
)
;
std
:
:
string
*
full_name
=
AllocateNameString
(
scope
proto
.
name
(
)
)
;
ValidateSymbolName
(
proto
.
name
(
)
*
full_name
proto
)
;
result
-
>
name_
=
tables_
-
>
AllocateString
(
proto
.
name
(
)
)
;
result
-
>
full_name_
=
full_name
;
result
-
>
file_
=
file_
;
result
-
>
number_
=
proto
.
number
(
)
;
result
-
>
is_extension_
=
is_extension
;
std
:
:
string
lowercase_name
(
proto
.
name
(
)
)
;
LowerString
(
&
lowercase_name
)
;
if
(
lowercase_name
=
=
proto
.
name
(
)
)
{
result
-
>
lowercase_name_
=
result
-
>
name_
;
}
else
{
result
-
>
lowercase_name_
=
tables_
-
>
AllocateString
(
lowercase_name
)
;
}
result
-
>
camelcase_name_
=
tables_
-
>
AllocateString
(
ToCamelCase
(
proto
.
name
(
)
true
)
)
;
if
(
proto
.
has_json_name
(
)
)
{
result
-
>
has_json_name_
=
true
;
result
-
>
json_name_
=
tables_
-
>
AllocateString
(
proto
.
json_name
(
)
)
;
}
else
{
result
-
>
has_json_name_
=
false
;
result
-
>
json_name_
=
tables_
-
>
AllocateString
(
ToJsonName
(
proto
.
name
(
)
)
)
;
}
result
-
>
type_
=
static_cast
<
FieldDescriptor
:
:
Type
>
(
implicit_cast
<
int
>
(
proto
.
type
(
)
)
)
;
result
-
>
label_
=
static_cast
<
FieldDescriptor
:
:
Label
>
(
implicit_cast
<
int
>
(
proto
.
label
(
)
)
)
;
if
(
result
-
>
is_extension_
&
&
result
-
>
label_
=
=
FieldDescriptor
:
:
LABEL_REQUIRED
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
The
extension
"
+
result
-
>
full_name
(
)
+
"
cannot
be
required
.
"
)
;
}
result
-
>
containing_type_
=
nullptr
;
result
-
>
extension_scope_
=
nullptr
;
result
-
>
message_type_
=
nullptr
;
result
-
>
enum_type_
=
nullptr
;
result
-
>
type_name_
=
nullptr
;
result
-
>
type_once_
=
nullptr
;
result
-
>
default_value_enum_
=
nullptr
;
result
-
>
default_value_enum_name_
=
nullptr
;
result
-
>
has_default_value_
=
proto
.
has_default_value
(
)
;
if
(
proto
.
has_default_value
(
)
&
&
result
-
>
is_repeated
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Repeated
fields
can
'
t
have
default
values
.
"
)
;
}
if
(
proto
.
has_type
(
)
)
{
if
(
proto
.
has_default_value
(
)
)
{
char
*
end_pos
=
nullptr
;
switch
(
result
-
>
cpp_type
(
)
)
{
case
FieldDescriptor
:
:
CPPTYPE_INT32
:
result
-
>
default_value_int32_
=
strtol
(
proto
.
default_value
(
)
.
c_str
(
)
&
end_pos
0
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_INT64
:
result
-
>
default_value_int64_
=
strto64
(
proto
.
default_value
(
)
.
c_str
(
)
&
end_pos
0
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_UINT32
:
result
-
>
default_value_uint32_
=
strtoul
(
proto
.
default_value
(
)
.
c_str
(
)
&
end_pos
0
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_UINT64
:
result
-
>
default_value_uint64_
=
strtou64
(
proto
.
default_value
(
)
.
c_str
(
)
&
end_pos
0
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_FLOAT
:
if
(
proto
.
default_value
(
)
=
=
"
inf
"
)
{
result
-
>
default_value_float_
=
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
;
}
else
if
(
proto
.
default_value
(
)
=
=
"
-
inf
"
)
{
result
-
>
default_value_float_
=
-
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
;
}
else
if
(
proto
.
default_value
(
)
=
=
"
nan
"
)
{
result
-
>
default_value_float_
=
std
:
:
numeric_limits
<
float
>
:
:
quiet_NaN
(
)
;
}
else
{
result
-
>
default_value_float_
=
io
:
:
SafeDoubleToFloat
(
io
:
:
NoLocaleStrtod
(
proto
.
default_value
(
)
.
c_str
(
)
&
end_pos
)
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_DOUBLE
:
if
(
proto
.
default_value
(
)
=
=
"
inf
"
)
{
result
-
>
default_value_double_
=
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
else
if
(
proto
.
default_value
(
)
=
=
"
-
inf
"
)
{
result
-
>
default_value_double_
=
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
else
if
(
proto
.
default_value
(
)
=
=
"
nan
"
)
{
result
-
>
default_value_double_
=
std
:
:
numeric_limits
<
double
>
:
:
quiet_NaN
(
)
;
}
else
{
result
-
>
default_value_double_
=
io
:
:
NoLocaleStrtod
(
proto
.
default_value
(
)
.
c_str
(
)
&
end_pos
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_BOOL
:
if
(
proto
.
default_value
(
)
=
=
"
true
"
)
{
result
-
>
default_value_bool_
=
true
;
}
else
if
(
proto
.
default_value
(
)
=
=
"
false
"
)
{
result
-
>
default_value_bool_
=
false
;
}
else
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Boolean
default
must
be
true
or
false
.
"
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_ENUM
:
result
-
>
default_value_enum_
=
nullptr
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_STRING
:
if
(
result
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_BYTES
)
{
result
-
>
default_value_string_
=
tables_
-
>
AllocateString
(
UnescapeCEscapeString
(
proto
.
default_value
(
)
)
)
;
}
else
{
result
-
>
default_value_string_
=
tables_
-
>
AllocateString
(
proto
.
default_value
(
)
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_MESSAGE
:
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Messages
can
'
t
have
default
values
.
"
)
;
result
-
>
has_default_value_
=
false
;
break
;
}
if
(
end_pos
!
=
nullptr
)
{
if
(
proto
.
default_value
(
)
.
empty
(
)
|
|
*
end_pos
!
=
'
\
0
'
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Couldn
'
t
parse
default
value
\
"
"
+
proto
.
default_value
(
)
+
"
\
"
.
"
)
;
}
}
}
else
{
switch
(
result
-
>
cpp_type
(
)
)
{
case
FieldDescriptor
:
:
CPPTYPE_INT32
:
result
-
>
default_value_int32_
=
0
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_INT64
:
result
-
>
default_value_int64_
=
0
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_UINT32
:
result
-
>
default_value_uint32_
=
0
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_UINT64
:
result
-
>
default_value_uint64_
=
0
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_FLOAT
:
result
-
>
default_value_float_
=
0
.
0f
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_DOUBLE
:
result
-
>
default_value_double_
=
0
.
0
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_BOOL
:
result
-
>
default_value_bool_
=
false
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_ENUM
:
result
-
>
default_value_enum_
=
nullptr
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_STRING
:
result
-
>
default_value_string_
=
&
internal
:
:
GetEmptyString
(
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_MESSAGE
:
break
;
}
}
}
if
(
result
-
>
number
(
)
<
=
0
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
Field
numbers
must
be
positive
integers
.
"
)
;
}
else
if
(
!
is_extension
&
&
result
-
>
number
(
)
>
FieldDescriptor
:
:
kMaxNumber
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Field
numbers
cannot
be
greater
than
0
.
"
FieldDescriptor
:
:
kMaxNumber
)
)
;
}
else
if
(
result
-
>
number
(
)
>
=
FieldDescriptor
:
:
kFirstReservedNumber
&
&
result
-
>
number
(
)
<
=
FieldDescriptor
:
:
kLastReservedNumber
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Field
numbers
0
through
1
are
reserved
for
the
protocol
"
"
buffer
library
implementation
.
"
FieldDescriptor
:
:
kFirstReservedNumber
FieldDescriptor
:
:
kLastReservedNumber
)
)
;
}
if
(
is_extension
)
{
if
(
!
proto
.
has_extendee
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
EXTENDEE
"
FieldDescriptorProto
.
extendee
not
set
for
extension
field
.
"
)
;
}
result
-
>
extension_scope_
=
parent
;
if
(
proto
.
has_oneof_index
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
FieldDescriptorProto
.
oneof_index
should
not
be
set
for
"
"
extensions
.
"
)
;
}
result
-
>
containing_oneof_
=
nullptr
;
}
else
{
if
(
proto
.
has_extendee
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
EXTENDEE
"
FieldDescriptorProto
.
extendee
set
for
non
-
extension
field
.
"
)
;
}
result
-
>
containing_type_
=
parent
;
if
(
proto
.
has_oneof_index
(
)
)
{
if
(
proto
.
oneof_index
(
)
<
0
|
|
proto
.
oneof_index
(
)
>
=
parent
-
>
oneof_decl_count
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
strings
:
:
Substitute
(
"
FieldDescriptorProto
.
oneof_index
0
is
"
"
out
of
range
for
type
\
"
1
\
"
.
"
proto
.
oneof_index
(
)
parent
-
>
name
(
)
)
)
;
result
-
>
containing_oneof_
=
nullptr
;
}
else
{
result
-
>
containing_oneof_
=
parent
-
>
oneof_decl
(
proto
.
oneof_index
(
)
)
;
}
}
else
{
result
-
>
containing_oneof_
=
nullptr
;
}
}
if
(
!
proto
.
has_options
(
)
)
{
result
-
>
options_
=
nullptr
;
}
else
{
AllocateOptions
(
proto
.
options
(
)
result
FieldDescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
FieldOptions
"
)
;
}
AddSymbol
(
result
-
>
full_name
(
)
parent
result
-
>
name
(
)
proto
Symbol
(
result
)
)
;
}
void
DescriptorBuilder
:
:
BuildExtensionRange
(
const
DescriptorProto
:
:
ExtensionRange
&
proto
const
Descriptor
*
parent
Descriptor
:
:
ExtensionRange
*
result
)
{
result
-
>
start
=
proto
.
start
(
)
;
result
-
>
end
=
proto
.
end
(
)
;
if
(
result
-
>
start
<
=
0
)
{
AddError
(
parent
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
Extension
numbers
must
be
positive
integers
.
"
)
;
}
if
(
result
-
>
start
>
=
result
-
>
end
)
{
AddError
(
parent
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
Extension
range
end
number
must
be
greater
than
start
number
.
"
)
;
}
if
(
!
proto
.
has_options
(
)
)
{
result
-
>
options_
=
nullptr
;
}
else
{
std
:
:
vector
<
int
>
options_path
;
parent
-
>
GetLocationPath
(
&
options_path
)
;
options_path
.
push_back
(
DescriptorProto
:
:
kExtensionRangeFieldNumber
)
;
int
index
;
for
(
index
=
0
;
parent
-
>
extension_ranges_
+
index
!
=
result
;
index
+
+
)
{
}
options_path
.
push_back
(
index
)
;
options_path
.
push_back
(
DescriptorProto_ExtensionRange
:
:
kOptionsFieldNumber
)
;
AllocateOptionsImpl
(
parent
-
>
full_name
(
)
parent
-
>
full_name
(
)
proto
.
options
(
)
result
options_path
"
google
.
protobuf
.
ExtensionRangeOptions
"
)
;
}
}
void
DescriptorBuilder
:
:
BuildReservedRange
(
const
DescriptorProto
:
:
ReservedRange
&
proto
const
Descriptor
*
parent
Descriptor
:
:
ReservedRange
*
result
)
{
result
-
>
start
=
proto
.
start
(
)
;
result
-
>
end
=
proto
.
end
(
)
;
if
(
result
-
>
start
<
=
0
)
{
AddError
(
parent
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
Reserved
numbers
must
be
positive
integers
.
"
)
;
}
}
void
DescriptorBuilder
:
:
BuildReservedRange
(
const
EnumDescriptorProto
:
:
EnumReservedRange
&
proto
const
EnumDescriptor
*
parent
EnumDescriptor
:
:
ReservedRange
*
result
)
{
result
-
>
start
=
proto
.
start
(
)
;
result
-
>
end
=
proto
.
end
(
)
;
if
(
result
-
>
start
>
result
-
>
end
)
{
AddError
(
parent
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
Reserved
range
end
number
must
be
greater
than
start
number
.
"
)
;
}
}
void
DescriptorBuilder
:
:
BuildOneof
(
const
OneofDescriptorProto
&
proto
Descriptor
*
parent
OneofDescriptor
*
result
)
{
std
:
:
string
*
full_name
=
AllocateNameString
(
parent
-
>
full_name
(
)
proto
.
name
(
)
)
;
ValidateSymbolName
(
proto
.
name
(
)
*
full_name
proto
)
;
result
-
>
name_
=
tables_
-
>
AllocateString
(
proto
.
name
(
)
)
;
result
-
>
full_name_
=
full_name
;
result
-
>
containing_type_
=
parent
;
result
-
>
field_count_
=
0
;
result
-
>
fields_
=
nullptr
;
result
-
>
options_
=
nullptr
;
if
(
proto
.
has_options
(
)
)
{
AllocateOptions
(
proto
.
options
(
)
result
OneofDescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
OneofOptions
"
)
;
}
AddSymbol
(
result
-
>
full_name
(
)
parent
result
-
>
name
(
)
proto
Symbol
(
result
)
)
;
}
void
DescriptorBuilder
:
:
CheckEnumValueUniqueness
(
const
EnumDescriptorProto
&
proto
const
EnumDescriptor
*
result
)
{
PrefixRemover
remover
(
result
-
>
name
(
)
)
;
std
:
:
map
<
std
:
:
string
const
EnumValueDescriptor
*
>
values
;
for
(
int
i
=
0
;
i
<
result
-
>
value_count
(
)
;
i
+
+
)
{
const
EnumValueDescriptor
*
value
=
result
-
>
value
(
i
)
;
std
:
:
string
stripped
=
EnumValueToPascalCase
(
remover
.
MaybeRemove
(
value
-
>
name
(
)
)
)
;
std
:
:
pair
<
std
:
:
map
<
std
:
:
string
const
EnumValueDescriptor
*
>
:
:
iterator
bool
>
insert_result
=
values
.
insert
(
std
:
:
make_pair
(
stripped
value
)
)
;
bool
inserted
=
insert_result
.
second
;
if
(
!
inserted
&
&
insert_result
.
first
-
>
second
-
>
name
(
)
!
=
value
-
>
name
(
)
&
&
insert_result
.
first
-
>
second
-
>
number
(
)
!
=
value
-
>
number
(
)
)
{
std
:
:
string
error_message
=
"
Enum
name
"
+
value
-
>
name
(
)
+
"
has
the
same
name
as
"
+
values
[
stripped
]
-
>
name
(
)
+
"
if
you
ignore
case
and
strip
out
the
enum
name
prefix
(
if
any
)
.
"
"
This
is
error
-
prone
and
can
lead
to
undefined
behavior
.
"
"
Please
avoid
doing
this
.
If
you
are
using
allow_alias
please
"
"
assign
the
same
numeric
value
to
both
enums
.
"
;
if
(
result
-
>
file
(
)
-
>
syntax
(
)
=
=
FileDescriptor
:
:
SYNTAX_PROTO2
)
{
AddWarning
(
value
-
>
full_name
(
)
proto
.
value
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NAME
error_message
)
;
}
else
{
AddError
(
value
-
>
full_name
(
)
proto
.
value
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NAME
error_message
)
;
}
}
}
}
void
DescriptorBuilder
:
:
BuildEnum
(
const
EnumDescriptorProto
&
proto
const
Descriptor
*
parent
EnumDescriptor
*
result
)
{
const
std
:
:
string
&
scope
=
(
parent
=
=
nullptr
)
?
file_
-
>
package
(
)
:
parent
-
>
full_name
(
)
;
std
:
:
string
*
full_name
=
AllocateNameString
(
scope
proto
.
name
(
)
)
;
ValidateSymbolName
(
proto
.
name
(
)
*
full_name
proto
)
;
result
-
>
name_
=
tables_
-
>
AllocateString
(
proto
.
name
(
)
)
;
result
-
>
full_name_
=
full_name
;
result
-
>
file_
=
file_
;
result
-
>
containing_type_
=
parent
;
result
-
>
is_placeholder_
=
false
;
result
-
>
is_unqualified_placeholder_
=
false
;
if
(
proto
.
value_size
(
)
=
=
0
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Enums
must
contain
at
least
one
value
.
"
)
;
}
BUILD_ARRAY
(
proto
result
value
BuildEnumValue
result
)
;
BUILD_ARRAY
(
proto
result
reserved_range
BuildReservedRange
result
)
;
int
reserved_name_count
=
proto
.
reserved_name_size
(
)
;
result
-
>
reserved_name_count_
=
reserved_name_count
;
result
-
>
reserved_names_
=
tables_
-
>
AllocateArray
<
const
std
:
:
string
*
>
(
reserved_name_count
)
;
for
(
int
i
=
0
;
i
<
reserved_name_count
;
+
+
i
)
{
result
-
>
reserved_names_
[
i
]
=
tables_
-
>
AllocateString
(
proto
.
reserved_name
(
i
)
)
;
}
CheckEnumValueUniqueness
(
proto
result
)
;
if
(
!
proto
.
has_options
(
)
)
{
result
-
>
options_
=
nullptr
;
}
else
{
AllocateOptions
(
proto
.
options
(
)
result
EnumDescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
EnumOptions
"
)
;
}
AddSymbol
(
result
-
>
full_name
(
)
parent
result
-
>
name
(
)
proto
Symbol
(
result
)
)
;
for
(
int
i
=
0
;
i
<
proto
.
reserved_range_size
(
)
;
i
+
+
)
{
const
EnumDescriptorProto_EnumReservedRange
&
range1
=
proto
.
reserved_range
(
i
)
;
for
(
int
j
=
i
+
1
;
j
<
proto
.
reserved_range_size
(
)
;
j
+
+
)
{
const
EnumDescriptorProto_EnumReservedRange
&
range2
=
proto
.
reserved_range
(
j
)
;
if
(
range1
.
end
(
)
>
=
range2
.
start
(
)
&
&
range2
.
end
(
)
>
=
range1
.
start
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
.
reserved_range
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Reserved
range
0
to
1
overlaps
with
"
"
already
-
defined
range
2
to
3
.
"
range2
.
start
(
)
range2
.
end
(
)
range1
.
start
(
)
range1
.
end
(
)
)
)
;
}
}
}
HASH_SET
<
std
:
:
string
>
reserved_name_set
;
for
(
int
i
=
0
;
i
<
proto
.
reserved_name_size
(
)
;
i
+
+
)
{
const
std
:
:
string
&
name
=
proto
.
reserved_name
(
i
)
;
if
(
reserved_name_set
.
find
(
name
)
=
=
reserved_name_set
.
end
(
)
)
{
reserved_name_set
.
insert
(
name
)
;
}
else
{
AddError
(
name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
strings
:
:
Substitute
(
"
Enum
value
\
"
0
\
"
is
reserved
multiple
times
.
"
name
)
)
;
}
}
for
(
int
i
=
0
;
i
<
result
-
>
value_count
(
)
;
i
+
+
)
{
const
EnumValueDescriptor
*
value
=
result
-
>
value
(
i
)
;
for
(
int
j
=
0
;
j
<
result
-
>
reserved_range_count
(
)
;
j
+
+
)
{
const
EnumDescriptor
:
:
ReservedRange
*
range
=
result
-
>
reserved_range
(
j
)
;
if
(
range
-
>
start
<
=
value
-
>
number
(
)
&
&
value
-
>
number
(
)
<
=
range
-
>
end
)
{
AddError
(
value
-
>
full_name
(
)
proto
.
reserved_range
(
j
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Enum
value
\
"
0
\
"
uses
reserved
number
1
.
"
value
-
>
name
(
)
value
-
>
number
(
)
)
)
;
}
}
if
(
reserved_name_set
.
find
(
value
-
>
name
(
)
)
!
=
reserved_name_set
.
end
(
)
)
{
AddError
(
value
-
>
full_name
(
)
proto
.
value
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NAME
strings
:
:
Substitute
(
"
Enum
value
\
"
0
\
"
is
reserved
.
"
value
-
>
name
(
)
)
)
;
}
}
}
void
DescriptorBuilder
:
:
BuildEnumValue
(
const
EnumValueDescriptorProto
&
proto
const
EnumDescriptor
*
parent
EnumValueDescriptor
*
result
)
{
result
-
>
name_
=
tables_
-
>
AllocateString
(
proto
.
name
(
)
)
;
result
-
>
number_
=
proto
.
number
(
)
;
result
-
>
type_
=
parent
;
std
:
:
string
*
full_name
=
tables_
-
>
AllocateEmptyString
(
)
;
size_t
scope_len
=
parent
-
>
full_name_
-
>
size
(
)
-
parent
-
>
name_
-
>
size
(
)
;
full_name
-
>
reserve
(
scope_len
+
result
-
>
name_
-
>
size
(
)
)
;
full_name
-
>
append
(
parent
-
>
full_name_
-
>
data
(
)
scope_len
)
;
full_name
-
>
append
(
*
result
-
>
name_
)
;
result
-
>
full_name_
=
full_name
;
ValidateSymbolName
(
proto
.
name
(
)
*
full_name
proto
)
;
if
(
!
proto
.
has_options
(
)
)
{
result
-
>
options_
=
nullptr
;
}
else
{
AllocateOptions
(
proto
.
options
(
)
result
EnumValueDescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
EnumValueOptions
"
)
;
}
bool
added_to_outer_scope
=
AddSymbol
(
result
-
>
full_name
(
)
parent
-
>
containing_type
(
)
result
-
>
name
(
)
proto
Symbol
(
result
)
)
;
bool
added_to_inner_scope
=
file_tables_
-
>
AddAliasUnderParent
(
parent
result
-
>
name
(
)
Symbol
(
result
)
)
;
if
(
added_to_inner_scope
&
&
!
added_to_outer_scope
)
{
std
:
:
string
outer_scope
;
if
(
parent
-
>
containing_type
(
)
=
=
nullptr
)
{
outer_scope
=
file_
-
>
package
(
)
;
}
else
{
outer_scope
=
parent
-
>
containing_type
(
)
-
>
full_name
(
)
;
}
if
(
outer_scope
.
empty
(
)
)
{
outer_scope
=
"
the
global
scope
"
;
}
else
{
outer_scope
=
"
\
"
"
+
outer_scope
+
"
\
"
"
;
}
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Note
that
enum
values
use
C
+
+
scoping
rules
meaning
that
"
"
enum
values
are
siblings
of
their
type
not
children
of
it
.
"
"
Therefore
\
"
"
+
result
-
>
name
(
)
+
"
\
"
must
be
unique
within
"
+
outer_scope
+
"
not
just
within
\
"
"
+
parent
-
>
name
(
)
+
"
\
"
.
"
)
;
}
file_tables_
-
>
AddEnumValueByNumber
(
result
)
;
}
void
DescriptorBuilder
:
:
BuildService
(
const
ServiceDescriptorProto
&
proto
const
void
*
ServiceDescriptor
*
result
)
{
std
:
:
string
*
full_name
=
AllocateNameString
(
file_
-
>
package
(
)
proto
.
name
(
)
)
;
ValidateSymbolName
(
proto
.
name
(
)
*
full_name
proto
)
;
result
-
>
name_
=
tables_
-
>
AllocateString
(
proto
.
name
(
)
)
;
result
-
>
full_name_
=
full_name
;
result
-
>
file_
=
file_
;
BUILD_ARRAY
(
proto
result
method
BuildMethod
result
)
;
if
(
!
proto
.
has_options
(
)
)
{
result
-
>
options_
=
nullptr
;
}
else
{
AllocateOptions
(
proto
.
options
(
)
result
ServiceDescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
ServiceOptions
"
)
;
}
AddSymbol
(
result
-
>
full_name
(
)
nullptr
result
-
>
name
(
)
proto
Symbol
(
result
)
)
;
}
void
DescriptorBuilder
:
:
BuildMethod
(
const
MethodDescriptorProto
&
proto
const
ServiceDescriptor
*
parent
MethodDescriptor
*
result
)
{
result
-
>
name_
=
tables_
-
>
AllocateString
(
proto
.
name
(
)
)
;
result
-
>
service_
=
parent
;
std
:
:
string
*
full_name
=
AllocateNameString
(
parent
-
>
full_name
(
)
*
result
-
>
name_
)
;
result
-
>
full_name_
=
full_name
;
ValidateSymbolName
(
proto
.
name
(
)
*
full_name
proto
)
;
result
-
>
input_type_
.
Init
(
)
;
result
-
>
output_type_
.
Init
(
)
;
if
(
!
proto
.
has_options
(
)
)
{
result
-
>
options_
=
nullptr
;
}
else
{
AllocateOptions
(
proto
.
options
(
)
result
MethodDescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
MethodOptions
"
)
;
}
result
-
>
client_streaming_
=
proto
.
client_streaming
(
)
;
result
-
>
server_streaming_
=
proto
.
server_streaming
(
)
;
AddSymbol
(
result
-
>
full_name
(
)
parent
result
-
>
name
(
)
proto
Symbol
(
result
)
)
;
}
#
undef
BUILD_ARRAY
void
DescriptorBuilder
:
:
CrossLinkFile
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
{
if
(
file
-
>
options_
=
=
nullptr
)
{
file
-
>
options_
=
&
FileOptions
:
:
default_instance
(
)
;
}
for
(
int
i
=
0
;
i
<
file
-
>
message_type_count
(
)
;
i
+
+
)
{
CrossLinkMessage
(
&
file
-
>
message_types_
[
i
]
proto
.
message_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
file
-
>
extension_count
(
)
;
i
+
+
)
{
CrossLinkField
(
&
file
-
>
extensions_
[
i
]
proto
.
extension
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
file
-
>
enum_type_count
(
)
;
i
+
+
)
{
CrossLinkEnum
(
&
file
-
>
enum_types_
[
i
]
proto
.
enum_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
file
-
>
service_count
(
)
;
i
+
+
)
{
CrossLinkService
(
&
file
-
>
services_
[
i
]
proto
.
service
(
i
)
)
;
}
}
void
DescriptorBuilder
:
:
CrossLinkMessage
(
Descriptor
*
message
const
DescriptorProto
&
proto
)
{
if
(
message
-
>
options_
=
=
nullptr
)
{
message
-
>
options_
=
&
MessageOptions
:
:
default_instance
(
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
nested_type_count
(
)
;
i
+
+
)
{
CrossLinkMessage
(
&
message
-
>
nested_types_
[
i
]
proto
.
nested_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
enum_type_count
(
)
;
i
+
+
)
{
CrossLinkEnum
(
&
message
-
>
enum_types_
[
i
]
proto
.
enum_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
field_count
(
)
;
i
+
+
)
{
CrossLinkField
(
&
message
-
>
fields_
[
i
]
proto
.
field
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
extension_count
(
)
;
i
+
+
)
{
CrossLinkField
(
&
message
-
>
extensions_
[
i
]
proto
.
extension
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
extension_range_count
(
)
;
i
+
+
)
{
CrossLinkExtensionRange
(
&
message
-
>
extension_ranges_
[
i
]
proto
.
extension_range
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
field_count
(
)
;
i
+
+
)
{
const
OneofDescriptor
*
oneof_decl
=
message
-
>
field
(
i
)
-
>
containing_oneof
(
)
;
if
(
oneof_decl
!
=
nullptr
)
{
if
(
oneof_decl
-
>
field_count
(
)
>
0
&
&
message
-
>
field
(
i
-
1
)
-
>
containing_oneof
(
)
!
=
oneof_decl
)
{
AddError
(
message
-
>
full_name
(
)
+
"
.
"
+
message
-
>
field
(
i
-
1
)
-
>
name
(
)
proto
.
field
(
i
-
1
)
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
strings
:
:
Substitute
(
"
Fields
in
the
same
oneof
must
be
defined
consecutively
.
"
"
\
"
0
\
"
cannot
be
defined
before
the
completion
of
the
"
"
\
"
1
\
"
oneof
definition
.
"
message
-
>
field
(
i
-
1
)
-
>
name
(
)
oneof_decl
-
>
name
(
)
)
)
;
}
+
+
message
-
>
oneof_decls_
[
oneof_decl
-
>
index
(
)
]
.
field_count_
;
}
}
for
(
int
i
=
0
;
i
<
message
-
>
oneof_decl_count
(
)
;
i
+
+
)
{
OneofDescriptor
*
oneof_decl
=
&
message
-
>
oneof_decls_
[
i
]
;
if
(
oneof_decl
-
>
field_count
(
)
=
=
0
)
{
AddError
(
message
-
>
full_name
(
)
+
"
.
"
+
oneof_decl
-
>
name
(
)
proto
.
oneof_decl
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Oneof
must
have
at
least
one
field
.
"
)
;
}
oneof_decl
-
>
fields_
=
tables_
-
>
AllocateArray
<
const
FieldDescriptor
*
>
(
oneof_decl
-
>
field_count_
)
;
oneof_decl
-
>
field_count_
=
0
;
if
(
oneof_decl
-
>
options_
=
=
nullptr
)
{
oneof_decl
-
>
options_
=
&
OneofOptions
:
:
default_instance
(
)
;
}
}
for
(
int
i
=
0
;
i
<
message
-
>
field_count
(
)
;
i
+
+
)
{
const
OneofDescriptor
*
oneof_decl
=
message
-
>
field
(
i
)
-
>
containing_oneof
(
)
;
if
(
oneof_decl
!
=
nullptr
)
{
OneofDescriptor
*
mutable_oneof_decl
=
&
message
-
>
oneof_decls_
[
oneof_decl
-
>
index
(
)
]
;
message
-
>
fields_
[
i
]
.
index_in_oneof_
=
mutable_oneof_decl
-
>
field_count_
;
mutable_oneof_decl
-
>
fields_
[
mutable_oneof_decl
-
>
field_count_
+
+
]
=
message
-
>
field
(
i
)
;
}
}
}
void
DescriptorBuilder
:
:
CrossLinkExtensionRange
(
Descriptor
:
:
ExtensionRange
*
range
const
DescriptorProto
:
:
ExtensionRange
&
proto
)
{
if
(
range
-
>
options_
=
=
nullptr
)
{
range
-
>
options_
=
&
ExtensionRangeOptions
:
:
default_instance
(
)
;
}
}
void
DescriptorBuilder
:
:
CrossLinkField
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
{
if
(
field
-
>
options_
=
=
nullptr
)
{
field
-
>
options_
=
&
FieldOptions
:
:
default_instance
(
)
;
}
file_tables_
-
>
AddFieldByStylizedNames
(
field
)
;
if
(
proto
.
has_extendee
(
)
)
{
Symbol
extendee
=
LookupSymbol
(
proto
.
extendee
(
)
field
-
>
full_name
(
)
DescriptorPool
:
:
PLACEHOLDER_EXTENDABLE_MESSAGE
)
;
if
(
extendee
.
IsNull
(
)
)
{
AddNotDefinedError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
EXTENDEE
proto
.
extendee
(
)
)
;
return
;
}
else
if
(
extendee
.
type
!
=
Symbol
:
:
MESSAGE
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
EXTENDEE
"
\
"
"
+
proto
.
extendee
(
)
+
"
\
"
is
not
a
message
type
.
"
)
;
return
;
}
field
-
>
containing_type_
=
extendee
.
descriptor
;
const
Descriptor
:
:
ExtensionRange
*
extension_range
=
field
-
>
containing_type
(
)
-
>
FindExtensionRangeContainingNumber
(
field
-
>
number
(
)
)
;
if
(
extension_range
=
=
nullptr
)
{
auto
skip_check
=
get_allow_unknown
(
pool_
)
&
&
proto
.
extendee
(
)
=
=
"
google
.
protobuf
.
bridge
.
MessageSet
"
;
if
(
!
skip_check
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
\
"
0
\
"
does
not
declare
1
as
an
"
"
extension
number
.
"
field
-
>
containing_type
(
)
-
>
full_name
(
)
field
-
>
number
(
)
)
)
;
}
}
}
if
(
field
-
>
containing_oneof
(
)
!
=
nullptr
)
{
if
(
field
-
>
label
(
)
!
=
FieldDescriptor
:
:
LABEL_OPTIONAL
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Fields
of
oneofs
must
themselves
have
label
LABEL_OPTIONAL
.
"
)
;
}
}
if
(
proto
.
has_type_name
(
)
)
{
bool
expecting_enum
=
(
proto
.
type
(
)
=
=
FieldDescriptorProto
:
:
TYPE_ENUM
)
|
|
proto
.
has_default_value
(
)
;
bool
is_weak
=
!
pool_
-
>
enforce_weak_
&
&
proto
.
options
(
)
.
weak
(
)
;
bool
is_lazy
=
pool_
-
>
lazily_build_dependencies_
&
&
!
is_weak
;
Symbol
type
=
LookupSymbol
(
proto
.
type_name
(
)
field
-
>
full_name
(
)
expecting_enum
?
DescriptorPool
:
:
PLACEHOLDER_ENUM
:
DescriptorPool
:
:
PLACEHOLDER_MESSAGE
LOOKUP_TYPES
!
is_lazy
)
;
if
(
type
.
IsNull
(
)
)
{
if
(
is_lazy
)
{
std
:
:
string
name
=
proto
.
type_name
(
)
;
field
-
>
type_once_
=
tables_
-
>
AllocateOnceDynamic
(
)
;
field
-
>
type_name_
=
tables_
-
>
AllocateString
(
name
)
;
if
(
proto
.
has_default_value
(
)
)
{
field
-
>
default_value_enum_name_
=
tables_
-
>
AllocateString
(
proto
.
default_value
(
)
)
;
}
file_tables_
-
>
AddFieldByNumber
(
field
)
;
if
(
field
-
>
is_extension
(
)
)
{
tables_
-
>
AddExtension
(
field
)
;
}
return
;
}
else
{
if
(
is_weak
)
{
type
=
FindSymbol
(
kNonLinkedWeakMessageReplacementName
)
;
}
if
(
type
.
IsNull
(
)
)
{
AddNotDefinedError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
proto
.
type_name
(
)
)
;
return
;
}
}
}
if
(
!
proto
.
has_type
(
)
)
{
if
(
type
.
type
=
=
Symbol
:
:
MESSAGE
)
{
field
-
>
type_
=
FieldDescriptor
:
:
TYPE_MESSAGE
;
}
else
if
(
type
.
type
=
=
Symbol
:
:
ENUM
)
{
field
-
>
type_
=
FieldDescriptor
:
:
TYPE_ENUM
;
}
else
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
\
"
"
+
proto
.
type_name
(
)
+
"
\
"
is
not
a
type
.
"
)
;
return
;
}
}
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
if
(
type
.
type
!
=
Symbol
:
:
MESSAGE
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
\
"
"
+
proto
.
type_name
(
)
+
"
\
"
is
not
a
message
type
.
"
)
;
return
;
}
field
-
>
message_type_
=
type
.
descriptor
;
if
(
field
-
>
has_default_value
(
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Messages
can
'
t
have
default
values
.
"
)
;
}
}
else
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_ENUM
)
{
if
(
type
.
type
!
=
Symbol
:
:
ENUM
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
\
"
"
+
proto
.
type_name
(
)
+
"
\
"
is
not
an
enum
type
.
"
)
;
return
;
}
field
-
>
enum_type_
=
type
.
enum_descriptor
;
if
(
field
-
>
enum_type
(
)
-
>
is_placeholder_
)
{
field
-
>
has_default_value_
=
false
;
}
if
(
field
-
>
has_default_value
(
)
)
{
if
(
!
io
:
:
Tokenizer
:
:
IsIdentifier
(
proto
.
default_value
(
)
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Default
value
for
an
enum
field
must
be
an
identifier
.
"
)
;
}
else
{
Symbol
default_value
=
LookupSymbolNoPlaceholder
(
proto
.
default_value
(
)
field
-
>
enum_type
(
)
-
>
full_name
(
)
)
;
if
(
default_value
.
type
=
=
Symbol
:
:
ENUM_VALUE
&
&
default_value
.
enum_value_descriptor
-
>
type
(
)
=
=
field
-
>
enum_type
(
)
)
{
field
-
>
default_value_enum_
=
default_value
.
enum_value_descriptor
;
}
else
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Enum
type
\
"
"
+
field
-
>
enum_type
(
)
-
>
full_name
(
)
+
"
\
"
has
no
value
named
\
"
"
+
proto
.
default_value
(
)
+
"
\
"
.
"
)
;
}
}
}
else
if
(
field
-
>
enum_type
(
)
-
>
value_count
(
)
>
0
)
{
field
-
>
default_value_enum_
=
field
-
>
enum_type
(
)
-
>
value
(
0
)
;
}
}
else
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Field
with
primitive
type
has
type_name
.
"
)
;
}
}
else
{
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
|
|
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_ENUM
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Field
with
message
or
enum
type
missing
type_name
.
"
)
;
}
}
if
(
!
file_tables_
-
>
AddFieldByNumber
(
field
)
)
{
const
FieldDescriptor
*
conflicting_field
=
file_tables_
-
>
FindFieldByNumber
(
field
-
>
containing_type
(
)
field
-
>
number
(
)
)
;
std
:
:
string
containing_type_name
=
field
-
>
containing_type
(
)
=
=
nullptr
?
"
unknown
"
:
field
-
>
containing_type
(
)
-
>
full_name
(
)
;
if
(
field
-
>
is_extension
(
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Extension
number
0
has
already
been
used
"
"
in
\
"
1
\
"
by
extension
\
"
2
\
"
.
"
field
-
>
number
(
)
containing_type_name
conflicting_field
-
>
full_name
(
)
)
)
;
}
else
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Field
number
0
has
already
been
used
in
"
"
\
"
1
\
"
by
field
\
"
2
\
"
.
"
field
-
>
number
(
)
containing_type_name
conflicting_field
-
>
name
(
)
)
)
;
}
}
else
{
if
(
field
-
>
is_extension
(
)
)
{
if
(
!
tables_
-
>
AddExtension
(
field
)
)
{
const
FieldDescriptor
*
conflicting_field
=
tables_
-
>
FindExtension
(
field
-
>
containing_type
(
)
field
-
>
number
(
)
)
;
std
:
:
string
containing_type_name
=
field
-
>
containing_type
(
)
=
=
nullptr
?
"
unknown
"
:
field
-
>
containing_type
(
)
-
>
full_name
(
)
;
std
:
:
string
error_msg
=
strings
:
:
Substitute
(
"
Extension
number
0
has
already
been
used
in
\
"
1
\
"
by
extension
"
"
\
"
2
\
"
defined
in
3
.
"
field
-
>
number
(
)
containing_type_name
conflicting_field
-
>
full_name
(
)
conflicting_field
-
>
file
(
)
-
>
name
(
)
)
;
AddWarning
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
error_msg
)
;
}
}
}
}
void
DescriptorBuilder
:
:
CrossLinkEnum
(
EnumDescriptor
*
enum_type
const
EnumDescriptorProto
&
proto
)
{
if
(
enum_type
-
>
options_
=
=
nullptr
)
{
enum_type
-
>
options_
=
&
EnumOptions
:
:
default_instance
(
)
;
}
for
(
int
i
=
0
;
i
<
enum_type
-
>
value_count
(
)
;
i
+
+
)
{
CrossLinkEnumValue
(
&
enum_type
-
>
values_
[
i
]
proto
.
value
(
i
)
)
;
}
}
void
DescriptorBuilder
:
:
CrossLinkEnumValue
(
EnumValueDescriptor
*
enum_value
const
EnumValueDescriptorProto
&
)
{
if
(
enum_value
-
>
options_
=
=
nullptr
)
{
enum_value
-
>
options_
=
&
EnumValueOptions
:
:
default_instance
(
)
;
}
}
void
DescriptorBuilder
:
:
CrossLinkService
(
ServiceDescriptor
*
service
const
ServiceDescriptorProto
&
proto
)
{
if
(
service
-
>
options_
=
=
nullptr
)
{
service
-
>
options_
=
&
ServiceOptions
:
:
default_instance
(
)
;
}
for
(
int
i
=
0
;
i
<
service
-
>
method_count
(
)
;
i
+
+
)
{
CrossLinkMethod
(
&
service
-
>
methods_
[
i
]
proto
.
method
(
i
)
)
;
}
}
void
DescriptorBuilder
:
:
CrossLinkMethod
(
MethodDescriptor
*
method
const
MethodDescriptorProto
&
proto
)
{
if
(
method
-
>
options_
=
=
nullptr
)
{
method
-
>
options_
=
&
MethodOptions
:
:
default_instance
(
)
;
}
Symbol
input_type
=
LookupSymbol
(
proto
.
input_type
(
)
method
-
>
full_name
(
)
DescriptorPool
:
:
PLACEHOLDER_MESSAGE
LOOKUP_ALL
!
pool_
-
>
lazily_build_dependencies_
)
;
if
(
input_type
.
IsNull
(
)
)
{
if
(
!
pool_
-
>
lazily_build_dependencies_
)
{
AddNotDefinedError
(
method
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
INPUT_TYPE
proto
.
input_type
(
)
)
;
}
else
{
method
-
>
input_type_
.
SetLazy
(
proto
.
input_type
(
)
file_
)
;
}
}
else
if
(
input_type
.
type
!
=
Symbol
:
:
MESSAGE
)
{
AddError
(
method
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
INPUT_TYPE
"
\
"
"
+
proto
.
input_type
(
)
+
"
\
"
is
not
a
message
type
.
"
)
;
}
else
{
method
-
>
input_type_
.
Set
(
input_type
.
descriptor
)
;
}
Symbol
output_type
=
LookupSymbol
(
proto
.
output_type
(
)
method
-
>
full_name
(
)
DescriptorPool
:
:
PLACEHOLDER_MESSAGE
LOOKUP_ALL
!
pool_
-
>
lazily_build_dependencies_
)
;
if
(
output_type
.
IsNull
(
)
)
{
if
(
!
pool_
-
>
lazily_build_dependencies_
)
{
AddNotDefinedError
(
method
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OUTPUT_TYPE
proto
.
output_type
(
)
)
;
}
else
{
method
-
>
output_type_
.
SetLazy
(
proto
.
output_type
(
)
file_
)
;
}
}
else
if
(
output_type
.
type
!
=
Symbol
:
:
MESSAGE
)
{
AddError
(
method
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OUTPUT_TYPE
"
\
"
"
+
proto
.
output_type
(
)
+
"
\
"
is
not
a
message
type
.
"
)
;
}
else
{
method
-
>
output_type_
.
Set
(
output_type
.
descriptor
)
;
}
}
#
define
VALIDATE_OPTIONS_FROM_ARRAY
(
descriptor
array_name
type
)
\
for
(
int
i
=
0
;
i
<
descriptor
-
>
array_name
#
#
_count
(
)
;
+
+
i
)
{
\
Validate
#
#
type
#
#
Options
(
descriptor
-
>
array_name
#
#
s_
+
i
\
proto
.
array_name
(
i
)
)
;
\
}
static
bool
IsLite
(
const
FileDescriptor
*
file
)
{
return
file
!
=
nullptr
&
&
&
file
-
>
options
(
)
!
=
&
FileOptions
:
:
default_instance
(
)
&
&
file
-
>
options
(
)
.
optimize_for
(
)
=
=
FileOptions
:
:
LITE_RUNTIME
;
}
void
DescriptorBuilder
:
:
ValidateFileOptions
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
{
VALIDATE_OPTIONS_FROM_ARRAY
(
file
message_type
Message
)
;
VALIDATE_OPTIONS_FROM_ARRAY
(
file
enum_type
Enum
)
;
VALIDATE_OPTIONS_FROM_ARRAY
(
file
service
Service
)
;
VALIDATE_OPTIONS_FROM_ARRAY
(
file
extension
Field
)
;
if
(
!
IsLite
(
file
)
)
{
for
(
int
i
=
0
;
i
<
file
-
>
dependency_count
(
)
;
i
+
+
)
{
if
(
IsLite
(
file
-
>
dependency
(
i
)
)
)
{
AddError
(
file
-
>
dependency
(
i
)
-
>
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
IMPORT
"
Files
that
do
not
use
optimize_for
=
LITE_RUNTIME
cannot
import
"
"
files
which
do
use
this
option
.
This
file
is
not
lite
but
it
"
"
imports
\
"
"
+
file
-
>
dependency
(
i
)
-
>
name
(
)
+
"
\
"
which
is
.
"
)
;
break
;
}
}
}
if
(
file
-
>
syntax
(
)
=
=
FileDescriptor
:
:
SYNTAX_PROTO3
)
{
ValidateProto3
(
file
proto
)
;
}
}
void
DescriptorBuilder
:
:
ValidateProto3
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
{
for
(
int
i
=
0
;
i
<
file
-
>
extension_count
(
)
;
+
+
i
)
{
ValidateProto3Field
(
file
-
>
extensions_
+
i
proto
.
extension
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
file
-
>
message_type_count
(
)
;
+
+
i
)
{
ValidateProto3Message
(
file
-
>
message_types_
+
i
proto
.
message_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
file
-
>
enum_type_count
(
)
;
+
+
i
)
{
ValidateProto3Enum
(
file
-
>
enum_types_
+
i
proto
.
enum_type
(
i
)
)
;
}
}
static
std
:
:
string
ToLowercaseWithoutUnderscores
(
const
std
:
:
string
&
name
)
{
std
:
:
string
result
;
for
(
int
i
=
0
;
i
<
name
.
size
(
)
;
+
+
i
)
{
if
(
name
[
i
]
!
=
'
_
'
)
{
if
(
name
[
i
]
>
=
'
A
'
&
&
name
[
i
]
<
=
'
Z
'
)
{
result
.
push_back
(
name
[
i
]
-
'
A
'
+
'
a
'
)
;
}
else
{
result
.
push_back
(
name
[
i
]
)
;
}
}
}
return
result
;
}
void
DescriptorBuilder
:
:
ValidateProto3Message
(
Descriptor
*
message
const
DescriptorProto
&
proto
)
{
for
(
int
i
=
0
;
i
<
message
-
>
nested_type_count
(
)
;
+
+
i
)
{
ValidateProto3Message
(
message
-
>
nested_types_
+
i
proto
.
nested_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
enum_type_count
(
)
;
+
+
i
)
{
ValidateProto3Enum
(
message
-
>
enum_types_
+
i
proto
.
enum_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
field_count
(
)
;
+
+
i
)
{
ValidateProto3Field
(
message
-
>
fields_
+
i
proto
.
field
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
extension_count
(
)
;
+
+
i
)
{
ValidateProto3Field
(
message
-
>
extensions_
+
i
proto
.
extension
(
i
)
)
;
}
if
(
message
-
>
extension_range_count
(
)
>
0
)
{
AddError
(
message
-
>
full_name
(
)
proto
.
extension_range
(
0
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
Extension
ranges
are
not
allowed
in
proto3
.
"
)
;
}
if
(
message
-
>
options
(
)
.
message_set_wire_format
(
)
)
{
AddError
(
message
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
MessageSet
is
not
supported
in
proto3
.
"
)
;
}
std
:
:
map
<
std
:
:
string
const
FieldDescriptor
*
>
name_to_field
;
for
(
int
i
=
0
;
i
<
message
-
>
field_count
(
)
;
+
+
i
)
{
std
:
:
string
lowercase_name
=
ToLowercaseWithoutUnderscores
(
message
-
>
field
(
i
)
-
>
name
(
)
)
;
if
(
name_to_field
.
find
(
lowercase_name
)
!
=
name_to_field
.
end
(
)
)
{
AddError
(
message
-
>
full_name
(
)
proto
.
field
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
The
JSON
camel
-
case
name
of
field
\
"
"
+
message
-
>
field
(
i
)
-
>
name
(
)
+
"
\
"
conflicts
with
field
\
"
"
+
name_to_field
[
lowercase_name
]
-
>
name
(
)
+
"
\
"
.
This
is
not
"
+
"
allowed
in
proto3
.
"
)
;
}
else
{
name_to_field
[
lowercase_name
]
=
message
-
>
field
(
i
)
;
}
}
}
void
DescriptorBuilder
:
:
ValidateProto3Field
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
{
if
(
field
-
>
is_extension
(
)
&
&
!
AllowedExtendeeInProto3
(
field
-
>
containing_type
(
)
-
>
full_name
(
)
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
EXTENDEE
"
Extensions
in
proto3
are
only
allowed
for
defining
options
.
"
)
;
}
if
(
field
-
>
is_required
(
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Required
fields
are
not
allowed
in
proto3
.
"
)
;
}
if
(
field
-
>
has_default_value
(
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Explicit
default
values
are
not
allowed
in
proto3
.
"
)
;
}
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_ENUM
&
&
field
-
>
enum_type
(
)
&
&
field
-
>
enum_type
(
)
-
>
file
(
)
-
>
syntax
(
)
!
=
FileDescriptor
:
:
SYNTAX_PROTO3
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Enum
type
\
"
"
+
field
-
>
enum_type
(
)
-
>
full_name
(
)
+
"
\
"
is
not
a
proto3
enum
but
is
used
in
\
"
"
+
field
-
>
containing_type
(
)
-
>
full_name
(
)
+
"
\
"
which
is
a
proto3
message
type
.
"
)
;
}
if
(
field
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_GROUP
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Groups
are
not
supported
in
proto3
syntax
.
"
)
;
}
}
void
DescriptorBuilder
:
:
ValidateProto3Enum
(
EnumDescriptor
*
enm
const
EnumDescriptorProto
&
proto
)
{
if
(
enm
-
>
value_count
(
)
>
0
&
&
enm
-
>
value
(
0
)
-
>
number
(
)
!
=
0
)
{
AddError
(
enm
-
>
full_name
(
)
proto
.
value
(
0
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
The
first
enum
value
must
be
zero
in
proto3
.
"
)
;
}
}
void
DescriptorBuilder
:
:
ValidateMessageOptions
(
Descriptor
*
message
const
DescriptorProto
&
proto
)
{
VALIDATE_OPTIONS_FROM_ARRAY
(
message
field
Field
)
;
VALIDATE_OPTIONS_FROM_ARRAY
(
message
nested_type
Message
)
;
VALIDATE_OPTIONS_FROM_ARRAY
(
message
enum_type
Enum
)
;
VALIDATE_OPTIONS_FROM_ARRAY
(
message
extension
Field
)
;
const
int64
max_extension_range
=
static_cast
<
int64
>
(
message
-
>
options
(
)
.
message_set_wire_format
(
)
?
kint32max
:
FieldDescriptor
:
:
kMaxNumber
)
;
for
(
int
i
=
0
;
i
<
message
-
>
extension_range_count
(
)
;
+
+
i
)
{
if
(
message
-
>
extension_range
(
i
)
-
>
end
>
max_extension_range
+
1
)
{
AddError
(
message
-
>
full_name
(
)
proto
.
extension_range
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Extension
numbers
cannot
be
greater
than
0
.
"
max_extension_range
)
)
;
}
}
}
void
DescriptorBuilder
:
:
ValidateFieldOptions
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
{
if
(
pool_
-
>
lazily_build_dependencies_
&
&
(
!
field
|
|
!
field
-
>
message_type
(
)
)
)
{
return
;
}
if
(
field
-
>
options
(
)
.
lazy
(
)
)
{
if
(
field
-
>
type
(
)
!
=
FieldDescriptor
:
:
TYPE_MESSAGE
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
[
lazy
=
true
]
can
only
be
specified
for
submessage
fields
.
"
)
;
}
}
if
(
field
-
>
options
(
)
.
packed
(
)
&
&
!
field
-
>
is_packable
(
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
[
packed
=
true
]
can
only
be
specified
for
repeated
primitive
fields
.
"
)
;
}
if
(
field
-
>
containing_type_
!
=
nullptr
&
&
&
field
-
>
containing_type
(
)
-
>
options
(
)
!
=
&
MessageOptions
:
:
default_instance
(
)
&
&
field
-
>
containing_type
(
)
-
>
options
(
)
.
message_set_wire_format
(
)
)
{
if
(
field
-
>
is_extension
(
)
)
{
if
(
!
field
-
>
is_optional
(
)
|
|
field
-
>
type
(
)
!
=
FieldDescriptor
:
:
TYPE_MESSAGE
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Extensions
of
MessageSets
must
be
optional
messages
.
"
)
;
}
}
else
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
MessageSets
cannot
have
fields
only
extensions
.
"
)
;
}
}
if
(
IsLite
(
field
-
>
file
(
)
)
&
&
field
-
>
containing_type_
!
=
nullptr
&
&
!
IsLite
(
field
-
>
containing_type
(
)
-
>
file
(
)
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
EXTENDEE
"
Extensions
to
non
-
lite
types
can
only
be
declared
in
non
-
lite
"
"
files
.
Note
that
you
cannot
extend
a
non
-
lite
type
to
contain
"
"
a
lite
type
but
the
reverse
is
allowed
.
"
)
;
}
if
(
field
-
>
is_map
(
)
)
{
if
(
!
ValidateMapEntry
(
field
proto
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
map_entry
should
not
be
set
explicitly
.
Use
map
<
KeyType
"
"
ValueType
>
instead
.
"
)
;
}
}
ValidateJSType
(
field
proto
)
;
if
(
field
-
>
is_extension
(
)
&
&
(
field
-
>
has_json_name
(
)
&
&
field
-
>
json_name
(
)
!
=
ToJsonName
(
field
-
>
name
(
)
)
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OPTION_NAME
"
option
json_name
is
not
allowed
on
extension
fields
.
"
)
;
}
}
void
DescriptorBuilder
:
:
ValidateEnumOptions
(
EnumDescriptor
*
enm
const
EnumDescriptorProto
&
proto
)
{
VALIDATE_OPTIONS_FROM_ARRAY
(
enm
value
EnumValue
)
;
if
(
!
enm
-
>
options
(
)
.
has_allow_alias
(
)
|
|
!
enm
-
>
options
(
)
.
allow_alias
(
)
)
{
std
:
:
map
<
int
std
:
:
string
>
used_values
;
for
(
int
i
=
0
;
i
<
enm
-
>
value_count
(
)
;
+
+
i
)
{
const
EnumValueDescriptor
*
enum_value
=
enm
-
>
value
(
i
)
;
if
(
used_values
.
find
(
enum_value
-
>
number
(
)
)
!
=
used_values
.
end
(
)
)
{
std
:
:
string
error
=
"
\
"
"
+
enum_value
-
>
full_name
(
)
+
"
\
"
uses
the
same
enum
value
as
\
"
"
+
used_values
[
enum_value
-
>
number
(
)
]
+
"
\
"
.
If
this
is
intended
set
"
"
'
option
allow_alias
=
true
;
'
to
the
enum
definition
.
"
;
if
(
!
enm
-
>
options
(
)
.
allow_alias
(
)
)
{
AddError
(
enm
-
>
full_name
(
)
proto
.
value
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
error
)
;
}
}
else
{
used_values
[
enum_value
-
>
number
(
)
]
=
enum_value
-
>
full_name
(
)
;
}
}
}
}
void
DescriptorBuilder
:
:
ValidateEnumValueOptions
(
EnumValueDescriptor
*
const
EnumValueDescriptorProto
&
)
{
}
void
DescriptorBuilder
:
:
ValidateServiceOptions
(
ServiceDescriptor
*
service
const
ServiceDescriptorProto
&
proto
)
{
if
(
IsLite
(
service
-
>
file
(
)
)
&
&
(
service
-
>
file
(
)
-
>
options
(
)
.
cc_generic_services
(
)
|
|
service
-
>
file
(
)
-
>
options
(
)
.
java_generic_services
(
)
)
)
{
AddError
(
service
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Files
with
optimize_for
=
LITE_RUNTIME
cannot
define
services
"
"
unless
you
set
both
options
cc_generic_services
and
"
"
java_generic_services
to
false
.
"
)
;
}
VALIDATE_OPTIONS_FROM_ARRAY
(
service
method
Method
)
;
}
void
DescriptorBuilder
:
:
ValidateMethodOptions
(
MethodDescriptor
*
const
MethodDescriptorProto
&
)
{
}
bool
DescriptorBuilder
:
:
ValidateMapEntry
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
{
const
Descriptor
*
message
=
field
-
>
message_type
(
)
;
if
(
message
-
>
extension_count
(
)
!
=
0
|
|
field
-
>
label
(
)
!
=
FieldDescriptor
:
:
LABEL_REPEATED
|
|
message
-
>
extension_range_count
(
)
!
=
0
|
|
message
-
>
nested_type_count
(
)
!
=
0
|
|
message
-
>
enum_type_count
(
)
!
=
0
|
|
message
-
>
field_count
(
)
!
=
2
|
|
message
-
>
name
(
)
!
=
ToCamelCase
(
field
-
>
name
(
)
false
)
+
"
Entry
"
|
|
field
-
>
containing_type
(
)
!
=
message
-
>
containing_type
(
)
)
{
return
false
;
}
const
FieldDescriptor
*
key
=
message
-
>
field
(
0
)
;
const
FieldDescriptor
*
value
=
message
-
>
field
(
1
)
;
if
(
key
-
>
label
(
)
!
=
FieldDescriptor
:
:
LABEL_OPTIONAL
|
|
key
-
>
number
(
)
!
=
1
|
|
key
-
>
name
(
)
!
=
"
key
"
)
{
return
false
;
}
if
(
value
-
>
label
(
)
!
=
FieldDescriptor
:
:
LABEL_OPTIONAL
|
|
value
-
>
number
(
)
!
=
2
|
|
value
-
>
name
(
)
!
=
"
value
"
)
{
return
false
;
}
switch
(
key
-
>
type
(
)
)
{
case
FieldDescriptor
:
:
TYPE_ENUM
:
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Key
in
map
fields
cannot
be
enum
types
.
"
)
;
break
;
case
FieldDescriptor
:
:
TYPE_FLOAT
:
case
FieldDescriptor
:
:
TYPE_DOUBLE
:
case
FieldDescriptor
:
:
TYPE_MESSAGE
:
case
FieldDescriptor
:
:
TYPE_GROUP
:
case
FieldDescriptor
:
:
TYPE_BYTES
:
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Key
in
map
fields
cannot
be
float
/
double
bytes
or
message
types
.
"
)
;
break
;
case
FieldDescriptor
:
:
TYPE_BOOL
:
case
FieldDescriptor
:
:
TYPE_INT32
:
case
FieldDescriptor
:
:
TYPE_INT64
:
case
FieldDescriptor
:
:
TYPE_SINT32
:
case
FieldDescriptor
:
:
TYPE_SINT64
:
case
FieldDescriptor
:
:
TYPE_STRING
:
case
FieldDescriptor
:
:
TYPE_UINT32
:
case
FieldDescriptor
:
:
TYPE_UINT64
:
case
FieldDescriptor
:
:
TYPE_FIXED32
:
case
FieldDescriptor
:
:
TYPE_FIXED64
:
case
FieldDescriptor
:
:
TYPE_SFIXED32
:
case
FieldDescriptor
:
:
TYPE_SFIXED64
:
break
;
}
if
(
value
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_ENUM
)
{
if
(
value
-
>
enum_type
(
)
-
>
value
(
0
)
-
>
number
(
)
!
=
0
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Enum
value
in
map
must
define
0
as
the
first
value
.
"
)
;
}
}
return
true
;
}
void
DescriptorBuilder
:
:
DetectMapConflicts
(
const
Descriptor
*
message
const
DescriptorProto
&
proto
)
{
std
:
:
map
<
std
:
:
string
const
Descriptor
*
>
seen_types
;
for
(
int
i
=
0
;
i
<
message
-
>
nested_type_count
(
)
;
+
+
i
)
{
const
Descriptor
*
nested
=
message
-
>
nested_type
(
i
)
;
std
:
:
pair
<
std
:
:
map
<
std
:
:
string
const
Descriptor
*
>
:
:
iterator
bool
>
result
=
seen_types
.
insert
(
std
:
:
make_pair
(
nested
-
>
name
(
)
nested
)
)
;
if
(
!
result
.
second
)
{
if
(
result
.
first
-
>
second
-
>
options
(
)
.
map_entry
(
)
|
|
nested
-
>
options
(
)
.
map_entry
(
)
)
{
AddError
(
message
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Expanded
map
entry
type
"
+
nested
-
>
name
(
)
+
"
conflicts
with
an
existing
nested
message
type
.
"
)
;
}
}
DetectMapConflicts
(
message
-
>
nested_type
(
i
)
proto
.
nested_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
field_count
(
)
;
+
+
i
)
{
const
FieldDescriptor
*
field
=
message
-
>
field
(
i
)
;
std
:
:
map
<
std
:
:
string
const
Descriptor
*
>
:
:
iterator
iter
=
seen_types
.
find
(
field
-
>
name
(
)
)
;
if
(
iter
!
=
seen_types
.
end
(
)
&
&
iter
-
>
second
-
>
options
(
)
.
map_entry
(
)
)
{
AddError
(
message
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Expanded
map
entry
type
"
+
iter
-
>
second
-
>
name
(
)
+
"
conflicts
with
an
existing
field
.
"
)
;
}
}
for
(
int
i
=
0
;
i
<
message
-
>
enum_type_count
(
)
;
+
+
i
)
{
const
EnumDescriptor
*
enum_desc
=
message
-
>
enum_type
(
i
)
;
std
:
:
map
<
std
:
:
string
const
Descriptor
*
>
:
:
iterator
iter
=
seen_types
.
find
(
enum_desc
-
>
name
(
)
)
;
if
(
iter
!
=
seen_types
.
end
(
)
&
&
iter
-
>
second
-
>
options
(
)
.
map_entry
(
)
)
{
AddError
(
message
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Expanded
map
entry
type
"
+
iter
-
>
second
-
>
name
(
)
+
"
conflicts
with
an
existing
enum
type
.
"
)
;
}
}
for
(
int
i
=
0
;
i
<
message
-
>
oneof_decl_count
(
)
;
+
+
i
)
{
const
OneofDescriptor
*
oneof_desc
=
message
-
>
oneof_decl
(
i
)
;
std
:
:
map
<
std
:
:
string
const
Descriptor
*
>
:
:
iterator
iter
=
seen_types
.
find
(
oneof_desc
-
>
name
(
)
)
;
if
(
iter
!
=
seen_types
.
end
(
)
&
&
iter
-
>
second
-
>
options
(
)
.
map_entry
(
)
)
{
AddError
(
message
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Expanded
map
entry
type
"
+
iter
-
>
second
-
>
name
(
)
+
"
conflicts
with
an
existing
oneof
type
.
"
)
;
}
}
}
void
DescriptorBuilder
:
:
ValidateJSType
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
{
FieldOptions
:
:
JSType
jstype
=
field
-
>
options
(
)
.
jstype
(
)
;
if
(
jstype
=
=
FieldOptions
:
:
JS_NORMAL
)
{
return
;
}
switch
(
field
-
>
type
(
)
)
{
case
FieldDescriptor
:
:
TYPE_UINT64
:
case
FieldDescriptor
:
:
TYPE_INT64
:
case
FieldDescriptor
:
:
TYPE_SINT64
:
case
FieldDescriptor
:
:
TYPE_FIXED64
:
case
FieldDescriptor
:
:
TYPE_SFIXED64
:
if
(
jstype
=
=
FieldOptions
:
:
JS_STRING
|
|
jstype
=
=
FieldOptions
:
:
JS_NUMBER
)
{
return
;
}
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Illegal
jstype
for
int64
uint64
sint64
fixed64
"
"
or
sfixed64
field
:
"
+
FieldOptions_JSType_descriptor
(
)
-
>
value
(
jstype
)
-
>
name
(
)
)
;
break
;
default
:
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
jstype
is
only
allowed
on
int64
uint64
sint64
fixed64
"
"
or
sfixed64
fields
.
"
)
;
break
;
}
}
#
undef
VALIDATE_OPTIONS_FROM_ARRAY
DescriptorBuilder
:
:
OptionInterpreter
:
:
OptionInterpreter
(
DescriptorBuilder
*
builder
)
:
builder_
(
builder
)
{
GOOGLE_CHECK
(
builder_
)
;
}
DescriptorBuilder
:
:
OptionInterpreter
:
:
~
OptionInterpreter
(
)
{
}
bool
DescriptorBuilder
:
:
OptionInterpreter
:
:
InterpretOptions
(
OptionsToInterpret
*
options_to_interpret
)
{
Message
*
options
=
options_to_interpret
-
>
options
;
const
Message
*
original_options
=
options_to_interpret
-
>
original_options
;
bool
failed
=
false
;
options_to_interpret_
=
options_to_interpret
;
const
FieldDescriptor
*
uninterpreted_options_field
=
options
-
>
GetDescriptor
(
)
-
>
FindFieldByName
(
"
uninterpreted_option
"
)
;
GOOGLE_CHECK
(
uninterpreted_options_field
!
=
nullptr
)
<
<
"
No
field
named
\
"
uninterpreted_option
\
"
in
the
Options
proto
.
"
;
options
-
>
GetReflection
(
)
-
>
ClearField
(
options
uninterpreted_options_field
)
;
std
:
:
vector
<
int
>
src_path
=
options_to_interpret
-
>
element_path
;
src_path
.
push_back
(
uninterpreted_options_field
-
>
number
(
)
)
;
const
FieldDescriptor
*
original_uninterpreted_options_field
=
original_options
-
>
GetDescriptor
(
)
-
>
FindFieldByName
(
"
uninterpreted_option
"
)
;
GOOGLE_CHECK
(
original_uninterpreted_options_field
!
=
nullptr
)
<
<
"
No
field
named
\
"
uninterpreted_option
\
"
in
the
Options
proto
.
"
;
const
int
num_uninterpreted_options
=
original_options
-
>
GetReflection
(
)
-
>
FieldSize
(
*
original_options
original_uninterpreted_options_field
)
;
for
(
int
i
=
0
;
i
<
num_uninterpreted_options
;
+
+
i
)
{
src_path
.
push_back
(
i
)
;
uninterpreted_option_
=
down_cast
<
const
UninterpretedOption
*
>
(
&
original_options
-
>
GetReflection
(
)
-
>
GetRepeatedMessage
(
*
original_options
original_uninterpreted_options_field
i
)
)
;
if
(
!
InterpretSingleOption
(
options
src_path
options_to_interpret
-
>
element_path
)
)
{
failed
=
true
;
break
;
}
src_path
.
pop_back
(
)
;
}
uninterpreted_option_
=
nullptr
;
options_to_interpret_
=
nullptr
;
if
(
!
failed
)
{
std
:
:
unique_ptr
<
Message
>
unparsed_options
(
options
-
>
New
(
)
)
;
options
-
>
GetReflection
(
)
-
>
Swap
(
unparsed_options
.
get
(
)
options
)
;
std
:
:
string
buf
;
if
(
!
unparsed_options
-
>
AppendToString
(
&
buf
)
|
|
!
options
-
>
ParseFromString
(
buf
)
)
{
builder_
-
>
AddError
(
options_to_interpret
-
>
element_name
*
original_options
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
Some
options
could
not
be
correctly
parsed
using
the
proto
"
"
descriptors
compiled
into
this
binary
.
\
n
"
"
Unparsed
options
:
"
+
unparsed_options
-
>
ShortDebugString
(
)
+
"
\
n
"
"
Parsing
attempt
:
"
+
options
-
>
ShortDebugString
(
)
)
;
options
-
>
GetReflection
(
)
-
>
Swap
(
unparsed_options
.
get
(
)
options
)
;
}
}
return
!
failed
;
}
bool
DescriptorBuilder
:
:
OptionInterpreter
:
:
InterpretSingleOption
(
Message
*
options
const
std
:
:
vector
<
int
>
&
src_path
const
std
:
:
vector
<
int
>
&
options_path
)
{
if
(
uninterpreted_option_
-
>
name_size
(
)
=
=
0
)
{
return
AddNameError
(
"
Option
must
have
a
name
.
"
)
;
}
if
(
uninterpreted_option_
-
>
name
(
0
)
.
name_part
(
)
=
=
"
uninterpreted_option
"
)
{
return
AddNameError
(
"
Option
must
not
use
reserved
name
"
"
\
"
uninterpreted_option
\
"
.
"
)
;
}
const
Descriptor
*
options_descriptor
=
nullptr
;
Symbol
symbol
=
builder_
-
>
FindSymbolNotEnforcingDeps
(
options
-
>
GetDescriptor
(
)
-
>
full_name
(
)
)
;
if
(
!
symbol
.
IsNull
(
)
&
&
symbol
.
type
=
=
Symbol
:
:
MESSAGE
)
{
options_descriptor
=
symbol
.
descriptor
;
}
else
{
options_descriptor
=
options
-
>
GetDescriptor
(
)
;
}
GOOGLE_CHECK
(
options_descriptor
)
;
const
Descriptor
*
descriptor
=
options_descriptor
;
const
FieldDescriptor
*
field
=
nullptr
;
std
:
:
vector
<
const
FieldDescriptor
*
>
intermediate_fields
;
std
:
:
string
debug_msg_name
=
"
"
;
std
:
:
vector
<
int
>
dest_path
=
options_path
;
for
(
int
i
=
0
;
i
<
uninterpreted_option_
-
>
name_size
(
)
;
+
+
i
)
{
builder_
-
>
undefine_resolved_name_
.
clear
(
)
;
const
std
:
:
string
&
name_part
=
uninterpreted_option_
-
>
name
(
i
)
.
name_part
(
)
;
if
(
debug_msg_name
.
size
(
)
>
0
)
{
debug_msg_name
+
=
"
.
"
;
}
if
(
uninterpreted_option_
-
>
name
(
i
)
.
is_extension
(
)
)
{
debug_msg_name
+
=
"
(
"
+
name_part
+
"
)
"
;
symbol
=
builder_
-
>
LookupSymbol
(
name_part
options_to_interpret_
-
>
name_scope
)
;
if
(
!
symbol
.
IsNull
(
)
&
&
symbol
.
type
=
=
Symbol
:
:
FIELD
)
{
field
=
symbol
.
field_descriptor
;
}
}
else
{
debug_msg_name
+
=
name_part
;
field
=
descriptor
-
>
FindFieldByName
(
name_part
)
;
}
if
(
field
=
=
nullptr
)
{
if
(
get_allow_unknown
(
builder_
-
>
pool_
)
)
{
AddWithoutInterpreting
(
*
uninterpreted_option_
options
)
;
return
true
;
}
else
if
(
!
(
builder_
-
>
undefine_resolved_name_
)
.
empty
(
)
)
{
return
AddNameError
(
"
Option
\
"
"
+
debug_msg_name
+
"
\
"
is
resolved
to
\
"
(
"
+
builder_
-
>
undefine_resolved_name_
+
"
)
\
"
which
is
not
defined
.
The
innermost
scope
is
searched
first
"
"
in
name
resolution
.
Consider
using
a
leading
'
.
'
(
i
.
e
.
\
"
(
.
"
+
debug_msg_name
.
substr
(
1
)
+
"
\
"
)
to
start
from
the
outermost
scope
.
"
)
;
}
else
{
return
AddNameError
(
"
Option
\
"
"
+
debug_msg_name
+
"
\
"
unknown
.
Ensure
that
your
proto
"
+
"
definition
file
imports
the
proto
which
defines
the
option
.
"
)
;
}
}
else
if
(
field
-
>
containing_type
(
)
!
=
descriptor
)
{
if
(
get_is_placeholder
(
field
-
>
containing_type
(
)
)
)
{
AddWithoutInterpreting
(
*
uninterpreted_option_
options
)
;
return
true
;
}
else
{
return
AddNameError
(
"
Option
field
\
"
"
+
debug_msg_name
+
"
\
"
is
not
a
field
or
extension
of
message
\
"
"
+
descriptor
-
>
name
(
)
+
"
\
"
.
"
)
;
}
}
else
{
dest_path
.
push_back
(
field
-
>
number
(
)
)
;
if
(
i
<
uninterpreted_option_
-
>
name_size
(
)
-
1
)
{
if
(
field
-
>
cpp_type
(
)
!
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
return
AddNameError
(
"
Option
\
"
"
+
debug_msg_name
+
"
\
"
is
an
atomic
type
not
a
message
.
"
)
;
}
else
if
(
field
-
>
is_repeated
(
)
)
{
return
AddNameError
(
"
Option
field
\
"
"
+
debug_msg_name
+
"
\
"
is
a
repeated
message
.
Repeated
message
"
"
options
must
be
initialized
using
an
"
"
aggregate
value
.
"
)
;
}
else
{
intermediate_fields
.
push_back
(
field
)
;
descriptor
=
field
-
>
message_type
(
)
;
}
}
}
}
if
(
!
field
-
>
is_repeated
(
)
&
&
!
ExamineIfOptionIsSet
(
intermediate_fields
.
begin
(
)
intermediate_fields
.
end
(
)
field
debug_msg_name
options
-
>
GetReflection
(
)
-
>
GetUnknownFields
(
*
options
)
)
)
{
return
false
;
}
std
:
:
unique_ptr
<
UnknownFieldSet
>
unknown_fields
(
new
UnknownFieldSet
(
)
)
;
if
(
!
SetOptionValue
(
field
unknown_fields
.
get
(
)
)
)
{
return
false
;
}
for
(
std
:
:
vector
<
const
FieldDescriptor
*
>
:
:
reverse_iterator
iter
=
intermediate_fields
.
rbegin
(
)
;
iter
!
=
intermediate_fields
.
rend
(
)
;
+
+
iter
)
{
std
:
:
unique_ptr
<
UnknownFieldSet
>
parent_unknown_fields
(
new
UnknownFieldSet
(
)
)
;
switch
(
(
*
iter
)
-
>
type
(
)
)
{
case
FieldDescriptor
:
:
TYPE_MESSAGE
:
{
io
:
:
StringOutputStream
outstr
(
parent_unknown_fields
-
>
AddLengthDelimited
(
(
*
iter
)
-
>
number
(
)
)
)
;
io
:
:
CodedOutputStream
out
(
&
outstr
)
;
internal
:
:
WireFormat
:
:
SerializeUnknownFields
(
*
unknown_fields
&
out
)
;
GOOGLE_CHECK
(
!
out
.
HadError
(
)
)
<
<
"
Unexpected
failure
while
serializing
option
submessage
"
<
<
debug_msg_name
<
<
"
\
"
.
"
;
break
;
}
case
FieldDescriptor
:
:
TYPE_GROUP
:
{
parent_unknown_fields
-
>
AddGroup
(
(
*
iter
)
-
>
number
(
)
)
-
>
MergeFrom
(
*
unknown_fields
)
;
break
;
}
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
Invalid
wire
type
for
CPPTYPE_MESSAGE
:
"
<
<
(
*
iter
)
-
>
type
(
)
;
return
false
;
}
unknown_fields
.
reset
(
parent_unknown_fields
.
release
(
)
)
;
}
options
-
>
GetReflection
(
)
-
>
MutableUnknownFields
(
options
)
-
>
MergeFrom
(
*
unknown_fields
)
;
if
(
field
-
>
is_repeated
(
)
)
{
int
index
=
repeated_option_counts_
[
dest_path
]
+
+
;
dest_path
.
push_back
(
index
)
;
}
interpreted_paths_
[
src_path
]
=
dest_path
;
return
true
;
}
void
DescriptorBuilder
:
:
OptionInterpreter
:
:
UpdateSourceCodeInfo
(
SourceCodeInfo
*
info
)
{
if
(
interpreted_paths_
.
empty
(
)
)
{
return
;
}
RepeatedPtrField
<
SourceCodeInfo_Location
>
*
locs
=
info
-
>
mutable_location
(
)
;
RepeatedPtrField
<
SourceCodeInfo_Location
>
new_locs
;
bool
copying
=
false
;
std
:
:
vector
<
int
>
pathv
;
bool
matched
=
false
;
for
(
RepeatedPtrField
<
SourceCodeInfo_Location
>
:
:
iterator
loc
=
locs
-
>
begin
(
)
;
loc
!
=
locs
-
>
end
(
)
;
loc
+
+
)
{
if
(
matched
)
{
bool
loc_matches
=
true
;
if
(
loc
-
>
path_size
(
)
<
pathv
.
size
(
)
)
{
loc_matches
=
false
;
}
else
{
for
(
int
j
=
0
;
j
<
pathv
.
size
(
)
;
j
+
+
)
{
if
(
loc
-
>
path
(
j
)
!
=
pathv
[
j
]
)
{
loc_matches
=
false
;
break
;
}
}
}
if
(
loc_matches
)
{
continue
;
}
matched
=
false
;
}
pathv
.
clear
(
)
;
for
(
int
j
=
0
;
j
<
loc
-
>
path_size
(
)
;
j
+
+
)
{
pathv
.
push_back
(
loc
-
>
path
(
j
)
)
;
}
std
:
:
map
<
std
:
:
vector
<
int
>
std
:
:
vector
<
int
>
>
:
:
iterator
entry
=
interpreted_paths_
.
find
(
pathv
)
;
if
(
entry
=
=
interpreted_paths_
.
end
(
)
)
{
if
(
copying
)
{
*
new_locs
.
Add
(
)
=
*
loc
;
}
continue
;
}
matched
=
true
;
if
(
!
copying
)
{
copying
=
true
;
new_locs
.
Reserve
(
locs
-
>
size
(
)
)
;
for
(
RepeatedPtrField
<
SourceCodeInfo_Location
>
:
:
iterator
it
=
locs
-
>
begin
(
)
;
it
!
=
loc
;
it
+
+
)
{
*
new_locs
.
Add
(
)
=
*
it
;
}
}
SourceCodeInfo_Location
*
replacement
=
new_locs
.
Add
(
)
;
*
replacement
=
*
loc
;
replacement
-
>
clear_path
(
)
;
for
(
std
:
:
vector
<
int
>
:
:
iterator
rit
=
entry
-
>
second
.
begin
(
)
;
rit
!
=
entry
-
>
second
.
end
(
)
;
rit
+
+
)
{
replacement
-
>
add_path
(
*
rit
)
;
}
}
if
(
copying
)
{
*
locs
=
new_locs
;
}
}
void
DescriptorBuilder
:
:
OptionInterpreter
:
:
AddWithoutInterpreting
(
const
UninterpretedOption
&
uninterpreted_option
Message
*
options
)
{
const
FieldDescriptor
*
field
=
options
-
>
GetDescriptor
(
)
-
>
FindFieldByName
(
"
uninterpreted_option
"
)
;
GOOGLE_CHECK
(
field
!
=
nullptr
)
;
options
-
>
GetReflection
(
)
-
>
AddMessage
(
options
field
)
-
>
CopyFrom
(
uninterpreted_option
)
;
}
bool
DescriptorBuilder
:
:
OptionInterpreter
:
:
ExamineIfOptionIsSet
(
std
:
:
vector
<
const
FieldDescriptor
*
>
:
:
const_iterator
intermediate_fields_iter
std
:
:
vector
<
const
FieldDescriptor
*
>
:
:
const_iterator
intermediate_fields_end
const
FieldDescriptor
*
innermost_field
const
std
:
:
string
&
debug_msg_name
const
UnknownFieldSet
&
unknown_fields
)
{
if
(
intermediate_fields_iter
=
=
intermediate_fields_end
)
{
for
(
int
i
=
0
;
i
<
unknown_fields
.
field_count
(
)
;
i
+
+
)
{
if
(
unknown_fields
.
field
(
i
)
.
number
(
)
=
=
innermost_field
-
>
number
(
)
)
{
return
AddNameError
(
"
Option
\
"
"
+
debug_msg_name
+
"
\
"
was
already
set
.
"
)
;
}
}
return
true
;
}
for
(
int
i
=
0
;
i
<
unknown_fields
.
field_count
(
)
;
i
+
+
)
{
if
(
unknown_fields
.
field
(
i
)
.
number
(
)
=
=
(
*
intermediate_fields_iter
)
-
>
number
(
)
)
{
const
UnknownField
*
unknown_field
=
&
unknown_fields
.
field
(
i
)
;
FieldDescriptor
:
:
Type
type
=
(
*
intermediate_fields_iter
)
-
>
type
(
)
;
switch
(
type
)
{
case
FieldDescriptor
:
:
TYPE_MESSAGE
:
if
(
unknown_field
-
>
type
(
)
=
=
UnknownField
:
:
TYPE_LENGTH_DELIMITED
)
{
UnknownFieldSet
intermediate_unknown_fields
;
if
(
intermediate_unknown_fields
.
ParseFromString
(
unknown_field
-
>
length_delimited
(
)
)
&
&
!
ExamineIfOptionIsSet
(
intermediate_fields_iter
+
1
intermediate_fields_end
innermost_field
debug_msg_name
intermediate_unknown_fields
)
)
{
return
false
;
}
}
break
;
case
FieldDescriptor
:
:
TYPE_GROUP
:
if
(
unknown_field
-
>
type
(
)
=
=
UnknownField
:
:
TYPE_GROUP
)
{
if
(
!
ExamineIfOptionIsSet
(
intermediate_fields_iter
+
1
intermediate_fields_end
innermost_field
debug_msg_name
unknown_field
-
>
group
(
)
)
)
{
return
false
;
}
}
break
;
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
Invalid
wire
type
for
CPPTYPE_MESSAGE
:
"
<
<
type
;
return
false
;
}
}
}
return
true
;
}
bool
DescriptorBuilder
:
:
OptionInterpreter
:
:
SetOptionValue
(
const
FieldDescriptor
*
option_field
UnknownFieldSet
*
unknown_fields
)
{
switch
(
option_field
-
>
cpp_type
(
)
)
{
case
FieldDescriptor
:
:
CPPTYPE_INT32
:
if
(
uninterpreted_option_
-
>
has_positive_int_value
(
)
)
{
if
(
uninterpreted_option_
-
>
positive_int_value
(
)
>
static_cast
<
uint64
>
(
kint32max
)
)
{
return
AddValueError
(
"
Value
out
of
range
for
int32
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
else
{
SetInt32
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
positive_int_value
(
)
option_field
-
>
type
(
)
unknown_fields
)
;
}
}
else
if
(
uninterpreted_option_
-
>
has_negative_int_value
(
)
)
{
if
(
uninterpreted_option_
-
>
negative_int_value
(
)
<
static_cast
<
int64
>
(
kint32min
)
)
{
return
AddValueError
(
"
Value
out
of
range
for
int32
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
else
{
SetInt32
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
negative_int_value
(
)
option_field
-
>
type
(
)
unknown_fields
)
;
}
}
else
{
return
AddValueError
(
"
Value
must
be
integer
for
int32
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_INT64
:
if
(
uninterpreted_option_
-
>
has_positive_int_value
(
)
)
{
if
(
uninterpreted_option_
-
>
positive_int_value
(
)
>
static_cast
<
uint64
>
(
kint64max
)
)
{
return
AddValueError
(
"
Value
out
of
range
for
int64
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
else
{
SetInt64
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
positive_int_value
(
)
option_field
-
>
type
(
)
unknown_fields
)
;
}
}
else
if
(
uninterpreted_option_
-
>
has_negative_int_value
(
)
)
{
SetInt64
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
negative_int_value
(
)
option_field
-
>
type
(
)
unknown_fields
)
;
}
else
{
return
AddValueError
(
"
Value
must
be
integer
for
int64
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_UINT32
:
if
(
uninterpreted_option_
-
>
has_positive_int_value
(
)
)
{
if
(
uninterpreted_option_
-
>
positive_int_value
(
)
>
kuint32max
)
{
return
AddValueError
(
"
Value
out
of
range
for
uint32
option
\
"
"
+
option_field
-
>
name
(
)
+
"
\
"
.
"
)
;
}
else
{
SetUInt32
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
positive_int_value
(
)
option_field
-
>
type
(
)
unknown_fields
)
;
}
}
else
{
return
AddValueError
(
"
Value
must
be
non
-
negative
integer
for
uint32
"
"
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_UINT64
:
if
(
uninterpreted_option_
-
>
has_positive_int_value
(
)
)
{
SetUInt64
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
positive_int_value
(
)
option_field
-
>
type
(
)
unknown_fields
)
;
}
else
{
return
AddValueError
(
"
Value
must
be
non
-
negative
integer
for
uint64
"
"
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_FLOAT
:
{
float
value
;
if
(
uninterpreted_option_
-
>
has_double_value
(
)
)
{
value
=
uninterpreted_option_
-
>
double_value
(
)
;
}
else
if
(
uninterpreted_option_
-
>
has_positive_int_value
(
)
)
{
value
=
uninterpreted_option_
-
>
positive_int_value
(
)
;
}
else
if
(
uninterpreted_option_
-
>
has_negative_int_value
(
)
)
{
value
=
uninterpreted_option_
-
>
negative_int_value
(
)
;
}
else
{
return
AddValueError
(
"
Value
must
be
number
for
float
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
unknown_fields
-
>
AddFixed32
(
option_field
-
>
number
(
)
internal
:
:
WireFormatLite
:
:
EncodeFloat
(
value
)
)
;
break
;
}
case
FieldDescriptor
:
:
CPPTYPE_DOUBLE
:
{
double
value
;
if
(
uninterpreted_option_
-
>
has_double_value
(
)
)
{
value
=
uninterpreted_option_
-
>
double_value
(
)
;
}
else
if
(
uninterpreted_option_
-
>
has_positive_int_value
(
)
)
{
value
=
uninterpreted_option_
-
>
positive_int_value
(
)
;
}
else
if
(
uninterpreted_option_
-
>
has_negative_int_value
(
)
)
{
value
=
uninterpreted_option_
-
>
negative_int_value
(
)
;
}
else
{
return
AddValueError
(
"
Value
must
be
number
for
double
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
unknown_fields
-
>
AddFixed64
(
option_field
-
>
number
(
)
internal
:
:
WireFormatLite
:
:
EncodeDouble
(
value
)
)
;
break
;
}
case
FieldDescriptor
:
:
CPPTYPE_BOOL
:
uint64
value
;
if
(
!
uninterpreted_option_
-
>
has_identifier_value
(
)
)
{
return
AddValueError
(
"
Value
must
be
identifier
for
boolean
option
"
"
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
if
(
uninterpreted_option_
-
>
identifier_value
(
)
=
=
"
true
"
)
{
value
=
1
;
}
else
if
(
uninterpreted_option_
-
>
identifier_value
(
)
=
=
"
false
"
)
{
value
=
0
;
}
else
{
return
AddValueError
(
"
Value
must
be
\
"
true
\
"
or
\
"
false
\
"
for
boolean
"
"
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
unknown_fields
-
>
AddVarint
(
option_field
-
>
number
(
)
value
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_ENUM
:
{
if
(
!
uninterpreted_option_
-
>
has_identifier_value
(
)
)
{
return
AddValueError
(
"
Value
must
be
identifier
for
enum
-
valued
option
"
"
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
const
EnumDescriptor
*
enum_type
=
option_field
-
>
enum_type
(
)
;
const
std
:
:
string
&
value_name
=
uninterpreted_option_
-
>
identifier_value
(
)
;
const
EnumValueDescriptor
*
enum_value
=
nullptr
;
if
(
enum_type
-
>
file
(
)
-
>
pool
(
)
!
=
DescriptorPool
:
:
generated_pool
(
)
)
{
std
:
:
string
fully_qualified_name
=
enum_type
-
>
full_name
(
)
;
fully_qualified_name
.
resize
(
fully_qualified_name
.
size
(
)
-
enum_type
-
>
name
(
)
.
size
(
)
)
;
fully_qualified_name
+
=
value_name
;
Symbol
symbol
=
builder_
-
>
FindSymbolNotEnforcingDeps
(
fully_qualified_name
)
;
if
(
!
symbol
.
IsNull
(
)
&
&
symbol
.
type
=
=
Symbol
:
:
ENUM_VALUE
)
{
if
(
symbol
.
enum_value_descriptor
-
>
type
(
)
!
=
enum_type
)
{
return
AddValueError
(
"
Enum
type
\
"
"
+
enum_type
-
>
full_name
(
)
+
"
\
"
has
no
value
named
\
"
"
+
value_name
+
"
\
"
for
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
This
appears
to
be
a
value
from
a
sibling
type
.
"
)
;
}
else
{
enum_value
=
symbol
.
enum_value_descriptor
;
}
}
}
else
{
enum_value
=
enum_type
-
>
FindValueByName
(
value_name
)
;
}
if
(
enum_value
=
=
nullptr
)
{
return
AddValueError
(
"
Enum
type
\
"
"
+
option_field
-
>
enum_type
(
)
-
>
full_name
(
)
+
"
\
"
has
no
value
named
\
"
"
+
value_name
+
"
\
"
for
"
"
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
else
{
unknown_fields
-
>
AddVarint
(
option_field
-
>
number
(
)
static_cast
<
uint64
>
(
static_cast
<
int64
>
(
enum_value
-
>
number
(
)
)
)
)
;
}
break
;
}
case
FieldDescriptor
:
:
CPPTYPE_STRING
:
if
(
!
uninterpreted_option_
-
>
has_string_value
(
)
)
{
return
AddValueError
(
"
Value
must
be
quoted
string
for
string
option
"
"
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
unknown_fields
-
>
AddLengthDelimited
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
string_value
(
)
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_MESSAGE
:
if
(
!
SetAggregateOption
(
option_field
unknown_fields
)
)
{
return
false
;
}
break
;
}
return
true
;
}
class
DescriptorBuilder
:
:
OptionInterpreter
:
:
AggregateOptionFinder
:
public
TextFormat
:
:
Finder
{
public
:
DescriptorBuilder
*
builder_
;
const
FieldDescriptor
*
FindExtension
(
Message
*
message
const
std
:
:
string
&
name
)
const
override
{
assert_mutex_held
(
builder_
-
>
pool_
)
;
const
Descriptor
*
descriptor
=
message
-
>
GetDescriptor
(
)
;
Symbol
result
=
builder_
-
>
LookupSymbolNoPlaceholder
(
name
descriptor
-
>
full_name
(
)
)
;
if
(
result
.
type
=
=
Symbol
:
:
FIELD
&
&
result
.
field_descriptor
-
>
is_extension
(
)
)
{
return
result
.
field_descriptor
;
}
else
if
(
result
.
type
=
=
Symbol
:
:
MESSAGE
&
&
descriptor
-
>
options
(
)
.
message_set_wire_format
(
)
)
{
const
Descriptor
*
foreign_type
=
result
.
descriptor
;
for
(
int
i
=
0
;
i
<
foreign_type
-
>
extension_count
(
)
;
i
+
+
)
{
const
FieldDescriptor
*
extension
=
foreign_type
-
>
extension
(
i
)
;
if
(
extension
-
>
containing_type
(
)
=
=
descriptor
&
&
extension
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_MESSAGE
&
&
extension
-
>
is_optional
(
)
&
&
extension
-
>
message_type
(
)
=
=
foreign_type
)
{
return
extension
;
}
}
}
return
nullptr
;
}
}
;
namespace
{
class
AggregateErrorCollector
:
public
io
:
:
ErrorCollector
{
public
:
std
:
:
string
error_
;
void
AddError
(
int
int
const
std
:
:
string
&
message
)
override
{
if
(
!
error_
.
empty
(
)
)
{
error_
+
=
"
;
"
;
}
error_
+
=
message
;
}
void
AddWarning
(
int
int
const
std
:
:
string
&
)
override
{
}
}
;
}
bool
DescriptorBuilder
:
:
OptionInterpreter
:
:
SetAggregateOption
(
const
FieldDescriptor
*
option_field
UnknownFieldSet
*
unknown_fields
)
{
if
(
!
uninterpreted_option_
-
>
has_aggregate_value
(
)
)
{
return
AddValueError
(
"
Option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
is
a
message
.
To
set
the
entire
message
use
"
"
syntax
like
\
"
"
+
option_field
-
>
name
(
)
+
"
=
{
<
proto
text
format
>
}
\
"
.
"
"
To
set
fields
within
it
use
"
"
syntax
like
\
"
"
+
option_field
-
>
name
(
)
+
"
.
foo
=
value
\
"
.
"
)
;
}
const
Descriptor
*
type
=
option_field
-
>
message_type
(
)
;
std
:
:
unique_ptr
<
Message
>
dynamic
(
dynamic_factory_
.
GetPrototype
(
type
)
-
>
New
(
)
)
;
GOOGLE_CHECK
(
dynamic
.
get
(
)
!
=
nullptr
)
<
<
"
Could
not
create
an
instance
of
"
<
<
option_field
-
>
DebugString
(
)
;
AggregateErrorCollector
collector
;
AggregateOptionFinder
finder
;
finder
.
builder_
=
builder_
;
TextFormat
:
:
Parser
parser
;
parser
.
RecordErrorsTo
(
&
collector
)
;
parser
.
SetFinder
(
&
finder
)
;
if
(
!
parser
.
ParseFromString
(
uninterpreted_option_
-
>
aggregate_value
(
)
dynamic
.
get
(
)
)
)
{
AddValueError
(
"
Error
while
parsing
option
value
for
\
"
"
+
option_field
-
>
name
(
)
+
"
\
"
:
"
+
collector
.
error_
)
;
return
false
;
}
else
{
std
:
:
string
serial
;
dynamic
-
>
SerializeToString
(
&
serial
)
;
if
(
option_field
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_MESSAGE
)
{
unknown_fields
-
>
AddLengthDelimited
(
option_field
-
>
number
(
)
serial
)
;
}
else
{
GOOGLE_CHECK_EQ
(
option_field
-
>
type
(
)
FieldDescriptor
:
:
TYPE_GROUP
)
;
UnknownFieldSet
*
group
=
unknown_fields
-
>
AddGroup
(
option_field
-
>
number
(
)
)
;
group
-
>
ParseFromString
(
serial
)
;
}
return
true
;
}
}
void
DescriptorBuilder
:
:
OptionInterpreter
:
:
SetInt32
(
int
number
int32
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
{
switch
(
type
)
{
case
FieldDescriptor
:
:
TYPE_INT32
:
unknown_fields
-
>
AddVarint
(
number
static_cast
<
uint64
>
(
static_cast
<
int64
>
(
value
)
)
)
;
break
;
case
FieldDescriptor
:
:
TYPE_SFIXED32
:
unknown_fields
-
>
AddFixed32
(
number
static_cast
<
uint32
>
(
value
)
)
;
break
;
case
FieldDescriptor
:
:
TYPE_SINT32
:
unknown_fields
-
>
AddVarint
(
number
internal
:
:
WireFormatLite
:
:
ZigZagEncode32
(
value
)
)
;
break
;
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
Invalid
wire
type
for
CPPTYPE_INT32
:
"
<
<
type
;
break
;
}
}
void
DescriptorBuilder
:
:
OptionInterpreter
:
:
SetInt64
(
int
number
int64
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
{
switch
(
type
)
{
case
FieldDescriptor
:
:
TYPE_INT64
:
unknown_fields
-
>
AddVarint
(
number
static_cast
<
uint64
>
(
value
)
)
;
break
;
case
FieldDescriptor
:
:
TYPE_SFIXED64
:
unknown_fields
-
>
AddFixed64
(
number
static_cast
<
uint64
>
(
value
)
)
;
break
;
case
FieldDescriptor
:
:
TYPE_SINT64
:
unknown_fields
-
>
AddVarint
(
number
internal
:
:
WireFormatLite
:
:
ZigZagEncode64
(
value
)
)
;
break
;
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
Invalid
wire
type
for
CPPTYPE_INT64
:
"
<
<
type
;
break
;
}
}
void
DescriptorBuilder
:
:
OptionInterpreter
:
:
SetUInt32
(
int
number
uint32
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
{
switch
(
type
)
{
case
FieldDescriptor
:
:
TYPE_UINT32
:
unknown_fields
-
>
AddVarint
(
number
static_cast
<
uint64
>
(
value
)
)
;
break
;
case
FieldDescriptor
:
:
TYPE_FIXED32
:
unknown_fields
-
>
AddFixed32
(
number
static_cast
<
uint32
>
(
value
)
)
;
break
;
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
Invalid
wire
type
for
CPPTYPE_UINT32
:
"
<
<
type
;
break
;
}
}
void
DescriptorBuilder
:
:
OptionInterpreter
:
:
SetUInt64
(
int
number
uint64
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
{
switch
(
type
)
{
case
FieldDescriptor
:
:
TYPE_UINT64
:
unknown_fields
-
>
AddVarint
(
number
value
)
;
break
;
case
FieldDescriptor
:
:
TYPE_FIXED64
:
unknown_fields
-
>
AddFixed64
(
number
value
)
;
break
;
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
Invalid
wire
type
for
CPPTYPE_UINT64
:
"
<
<
type
;
break
;
}
}
void
DescriptorBuilder
:
:
LogUnusedDependency
(
const
FileDescriptorProto
&
proto
const
FileDescriptor
*
result
)
{
if
(
!
unused_dependency_
.
empty
(
)
)
{
for
(
std
:
:
set
<
const
FileDescriptor
*
>
:
:
const_iterator
it
=
unused_dependency_
.
begin
(
)
;
it
!
=
unused_dependency_
.
end
(
)
;
+
+
it
)
{
std
:
:
string
error_message
=
"
Import
"
+
(
*
it
)
-
>
name
(
)
+
"
is
unused
.
"
;
AddWarning
(
(
*
it
)
-
>
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
IMPORT
error_message
)
;
}
}
}
Symbol
DescriptorPool
:
:
CrossLinkOnDemandHelper
(
const
std
:
:
string
&
name
bool
expecting_enum
)
const
{
std
:
:
string
lookup_name
=
name
;
if
(
!
lookup_name
.
empty
(
)
&
&
lookup_name
[
0
]
=
=
'
.
'
)
{
lookup_name
=
lookup_name
.
substr
(
1
)
;
}
Symbol
result
=
tables_
-
>
FindByNameHelper
(
this
lookup_name
)
;
return
result
;
}
void
FieldDescriptor
:
:
InternalTypeOnceInit
(
)
const
{
GOOGLE_CHECK
(
file
(
)
-
>
finished_building_
=
=
true
)
;
if
(
type_name_
)
{
Symbol
result
=
file
(
)
-
>
pool
(
)
-
>
CrossLinkOnDemandHelper
(
*
type_name_
type_
=
=
FieldDescriptor
:
:
TYPE_ENUM
)
;
if
(
result
.
type
=
=
Symbol
:
:
MESSAGE
)
{
type_
=
FieldDescriptor
:
:
TYPE_MESSAGE
;
message_type_
=
result
.
descriptor
;
}
else
if
(
result
.
type
=
=
Symbol
:
:
ENUM
)
{
type_
=
FieldDescriptor
:
:
TYPE_ENUM
;
enum_type_
=
result
.
enum_descriptor
;
}
}
if
(
enum_type_
&
&
!
default_value_enum_
)
{
if
(
default_value_enum_name_
)
{
std
:
:
string
name
=
enum_type_
-
>
full_name
(
)
;
std
:
:
string
:
:
size_type
last_dot
=
name
.
find_last_of
(
'
.
'
)
;
if
(
last_dot
!
=
std
:
:
string
:
:
npos
)
{
name
=
name
.
substr
(
0
last_dot
)
+
"
.
"
+
*
default_value_enum_name_
;
}
else
{
name
=
*
default_value_enum_name_
;
}
Symbol
result
=
file
(
)
-
>
pool
(
)
-
>
CrossLinkOnDemandHelper
(
name
true
)
;
if
(
result
.
type
=
=
Symbol
:
:
ENUM_VALUE
)
{
default_value_enum_
=
result
.
enum_value_descriptor
;
}
}
if
(
!
default_value_enum_
)
{
GOOGLE_CHECK
(
enum_type_
-
>
value_count
(
)
)
;
default_value_enum_
=
enum_type_
-
>
value
(
0
)
;
}
}
}
void
FieldDescriptor
:
:
TypeOnceInit
(
const
FieldDescriptor
*
to_init
)
{
to_init
-
>
InternalTypeOnceInit
(
)
;
}
const
Descriptor
*
FieldDescriptor
:
:
message_type
(
)
const
{
if
(
type_once_
)
{
internal
:
:
call_once
(
*
type_once_
FieldDescriptor
:
:
TypeOnceInit
this
)
;
}
return
message_type_
;
}
const
EnumDescriptor
*
FieldDescriptor
:
:
enum_type
(
)
const
{
if
(
type_once_
)
{
internal
:
:
call_once
(
*
type_once_
FieldDescriptor
:
:
TypeOnceInit
this
)
;
}
return
enum_type_
;
}
const
EnumValueDescriptor
*
FieldDescriptor
:
:
default_value_enum
(
)
const
{
if
(
type_once_
)
{
internal
:
:
call_once
(
*
type_once_
FieldDescriptor
:
:
TypeOnceInit
this
)
;
}
return
default_value_enum_
;
}
const
std
:
:
string
&
FieldDescriptor
:
:
PrintableNameForExtension
(
)
const
{
const
bool
is_message_set_extension
=
is_extension
(
)
&
&
containing_type
(
)
-
>
options
(
)
.
message_set_wire_format
(
)
&
&
type
(
)
=
=
FieldDescriptor
:
:
TYPE_MESSAGE
&
&
is_optional
(
)
&
&
extension_scope
(
)
=
=
message_type
(
)
;
return
is_message_set_extension
?
message_type
(
)
-
>
full_name
(
)
:
full_name
(
)
;
}
void
FileDescriptor
:
:
InternalDependenciesOnceInit
(
)
const
{
GOOGLE_CHECK
(
finished_building_
=
=
true
)
;
for
(
int
i
=
0
;
i
<
dependency_count
(
)
;
i
+
+
)
{
if
(
dependencies_names_
[
i
]
)
{
dependencies_
[
i
]
=
pool_
-
>
FindFileByName
(
*
dependencies_names_
[
i
]
)
;
}
}
}
void
FileDescriptor
:
:
DependenciesOnceInit
(
const
FileDescriptor
*
to_init
)
{
to_init
-
>
InternalDependenciesOnceInit
(
)
;
}
const
FileDescriptor
*
FileDescriptor
:
:
dependency
(
int
index
)
const
{
if
(
dependencies_once_
)
{
internal
:
:
call_once
(
*
dependencies_once_
FileDescriptor
:
:
DependenciesOnceInit
this
)
;
}
return
dependencies_
[
index
]
;
}
const
Descriptor
*
MethodDescriptor
:
:
input_type
(
)
const
{
return
input_type_
.
Get
(
)
;
}
const
Descriptor
*
MethodDescriptor
:
:
output_type
(
)
const
{
return
output_type_
.
Get
(
)
;
}
namespace
internal
{
void
LazyDescriptor
:
:
Set
(
const
Descriptor
*
descriptor
)
{
GOOGLE_CHECK
(
!
name_
)
;
GOOGLE_CHECK
(
!
once_
)
;
GOOGLE_CHECK
(
!
file_
)
;
descriptor_
=
descriptor
;
}
void
LazyDescriptor
:
:
SetLazy
(
const
std
:
:
string
&
name
const
FileDescriptor
*
file
)
{
GOOGLE_CHECK
(
!
descriptor_
)
;
GOOGLE_CHECK
(
!
file_
)
;
GOOGLE_CHECK
(
!
name_
)
;
GOOGLE_CHECK
(
!
once_
)
;
GOOGLE_CHECK
(
file
&
&
file
-
>
pool_
)
;
GOOGLE_CHECK
(
file
-
>
pool_
-
>
lazily_build_dependencies_
)
;
GOOGLE_CHECK
(
!
file
-
>
finished_building_
)
;
file_
=
file
;
name_
=
file
-
>
pool_
-
>
tables_
-
>
AllocateString
(
name
)
;
once_
=
file
-
>
pool_
-
>
tables_
-
>
AllocateOnceDynamic
(
)
;
}
void
LazyDescriptor
:
:
Once
(
)
{
if
(
once_
)
{
internal
:
:
call_once
(
*
once_
LazyDescriptor
:
:
OnceStatic
this
)
;
}
}
void
LazyDescriptor
:
:
OnceStatic
(
LazyDescriptor
*
lazy
)
{
lazy
-
>
OnceInternal
(
)
;
}
void
LazyDescriptor
:
:
OnceInternal
(
)
{
GOOGLE_CHECK
(
file_
-
>
finished_building_
)
;
if
(
!
descriptor_
&
&
name_
)
{
Symbol
result
=
file_
-
>
pool_
-
>
CrossLinkOnDemandHelper
(
*
name_
false
)
;
if
(
!
result
.
IsNull
(
)
&
&
result
.
type
=
=
Symbol
:
:
MESSAGE
)
{
descriptor_
=
result
.
descriptor
;
}
}
}
}
}
}
