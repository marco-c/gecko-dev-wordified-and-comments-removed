#
include
<
google
/
protobuf
/
descriptor
.
h
>
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
functional
>
#
include
<
limits
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
sstream
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
<
vector
>
#
include
<
google
/
protobuf
/
stubs
/
common
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
logging
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
strutil
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
once
.
h
>
#
include
<
google
/
protobuf
/
any
.
h
>
#
include
<
google
/
protobuf
/
descriptor
.
pb
.
h
>
#
include
<
google
/
protobuf
/
io
/
coded_stream
.
h
>
#
include
<
google
/
protobuf
/
io
/
tokenizer
.
h
>
#
include
<
google
/
protobuf
/
io
/
zero_copy_stream_impl
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
casts
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
stringprintf
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
substitute
.
h
>
#
include
<
google
/
protobuf
/
descriptor_database
.
h
>
#
include
<
google
/
protobuf
/
dynamic_message
.
h
>
#
include
<
google
/
protobuf
/
generated_message_util
.
h
>
#
include
<
google
/
protobuf
/
io
/
strtod
.
h
>
#
include
<
google
/
protobuf
/
port
.
h
>
#
include
<
google
/
protobuf
/
text_format
.
h
>
#
include
<
google
/
protobuf
/
unknown_field_set
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
map_util
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
stl_util
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
hash
.
h
>
#
undef
PACKAGE
/
/
autoheader
#
defines
this
.
:
(
#
include
<
google
/
protobuf
/
port_def
.
inc
>
namespace
google
{
namespace
protobuf
{
namespace
{
const
int
kPackageLimit
=
100
;
char
ToUpper
(
char
ch
)
{
return
(
ch
>
=
'
a
'
&
&
ch
<
=
'
z
'
)
?
(
ch
-
'
a
'
+
'
A
'
)
:
ch
;
}
char
ToLower
(
char
ch
)
{
return
(
ch
>
=
'
A
'
&
&
ch
<
=
'
Z
'
)
?
(
ch
-
'
A
'
+
'
a
'
)
:
ch
;
}
std
:
:
string
ToCamelCase
(
const
std
:
:
string
&
input
bool
lower_first
)
{
bool
capitalize_next
=
!
lower_first
;
std
:
:
string
result
;
result
.
reserve
(
input
.
size
(
)
)
;
for
(
char
character
:
input
)
{
if
(
character
=
=
'
_
'
)
{
capitalize_next
=
true
;
}
else
if
(
capitalize_next
)
{
result
.
push_back
(
ToUpper
(
character
)
)
;
capitalize_next
=
false
;
}
else
{
result
.
push_back
(
character
)
;
}
}
if
(
lower_first
&
&
!
result
.
empty
(
)
)
{
result
[
0
]
=
ToLower
(
result
[
0
]
)
;
}
return
result
;
}
std
:
:
string
ToJsonName
(
const
std
:
:
string
&
input
)
{
bool
capitalize_next
=
false
;
std
:
:
string
result
;
result
.
reserve
(
input
.
size
(
)
)
;
for
(
char
character
:
input
)
{
if
(
character
=
=
'
_
'
)
{
capitalize_next
=
true
;
}
else
if
(
capitalize_next
)
{
result
.
push_back
(
ToUpper
(
character
)
)
;
capitalize_next
=
false
;
}
else
{
result
.
push_back
(
character
)
;
}
}
return
result
;
}
struct
ExpressionEater
{
template
<
typename
T
>
ExpressionEater
(
T
&
&
)
{
}
}
;
void
Fold
(
std
:
:
initializer_list
<
ExpressionEater
>
)
{
}
template
<
int
R
>
constexpr
size_t
RoundUpTo
(
size_t
n
)
{
static_assert
(
(
R
&
(
R
-
1
)
)
=
=
0
"
Must
be
power
of
two
"
)
;
return
(
n
+
(
R
-
1
)
)
&
~
(
R
-
1
)
;
}
constexpr
size_t
Max
(
size_t
a
size_t
b
)
{
return
a
>
b
?
a
:
b
;
}
template
<
typename
T
typename
.
.
.
Ts
>
constexpr
size_t
Max
(
T
a
Ts
.
.
.
b
)
{
return
Max
(
a
Max
(
b
.
.
.
)
)
;
}
template
<
typename
T
>
constexpr
size_t
EffectiveAlignof
(
)
{
return
std
:
:
is_same
<
T
char
>
:
:
value
?
8
:
alignof
(
T
)
;
}
template
<
int
align
typename
U
typename
.
.
.
T
>
using
AppendIfAlign
=
typename
std
:
:
conditional
<
EffectiveAlignof
<
U
>
(
)
=
=
align
void
(
*
)
(
T
.
.
.
U
)
void
(
*
)
(
T
.
.
.
)
>
:
:
type
;
template
<
typename
In
typename
T16
typename
T8
typename
T4
typename
T2
typename
T1
>
struct
TypeListSortImpl
;
template
<
typename
.
.
.
T16
typename
.
.
.
T8
typename
.
.
.
T4
typename
.
.
.
T2
typename
.
.
.
T1
>
struct
TypeListSortImpl
<
void
(
*
)
(
)
void
(
*
)
(
T16
.
.
.
)
void
(
*
)
(
T8
.
.
.
)
void
(
*
)
(
T4
.
.
.
)
void
(
*
)
(
T2
.
.
.
)
void
(
*
)
(
T1
.
.
.
)
>
{
using
type
=
void
(
*
)
(
T16
.
.
.
T8
.
.
.
T4
.
.
.
T2
.
.
.
T1
.
.
.
)
;
}
;
template
<
typename
First
typename
.
.
.
Rest
typename
.
.
.
T16
typename
.
.
.
T8
typename
.
.
.
T4
typename
.
.
.
T2
typename
.
.
.
T1
>
struct
TypeListSortImpl
<
void
(
*
)
(
First
Rest
.
.
.
)
void
(
*
)
(
T16
.
.
.
)
void
(
*
)
(
T8
.
.
.
)
void
(
*
)
(
T4
.
.
.
)
void
(
*
)
(
T2
.
.
.
)
void
(
*
)
(
T1
.
.
.
)
>
{
using
type
=
typename
TypeListSortImpl
<
void
(
*
)
(
Rest
.
.
.
)
AppendIfAlign
<
16
First
T16
.
.
.
>
AppendIfAlign
<
8
First
T8
.
.
.
>
AppendIfAlign
<
4
First
T4
.
.
.
>
AppendIfAlign
<
2
First
T2
.
.
.
>
AppendIfAlign
<
1
First
T1
.
.
.
>
>
:
:
type
;
}
;
template
<
typename
.
.
.
T
>
using
SortByAlignment
=
typename
TypeListSortImpl
<
void
(
*
)
(
T
.
.
.
)
void
(
*
)
(
)
void
(
*
)
(
)
void
(
*
)
(
)
void
(
*
)
(
)
void
(
*
)
(
)
>
:
:
type
;
template
<
template
<
typename
.
.
.
>
class
C
typename
.
.
.
T
>
auto
ApplyTypeList
(
void
(
*
)
(
T
.
.
.
)
)
-
>
C
<
T
.
.
.
>
;
template
<
typename
T
>
constexpr
int
FindTypeIndex
(
)
{
return
-
1
;
}
template
<
typename
T
typename
T1
typename
.
.
.
Ts
>
constexpr
int
FindTypeIndex
(
)
{
return
std
:
:
is_same
<
T
T1
>
:
:
value
?
0
:
FindTypeIndex
<
T
Ts
.
.
.
>
(
)
+
1
;
}
template
<
template
<
typename
>
class
ValueT
typename
.
.
.
Keys
>
class
TypeMap
{
public
:
template
<
typename
K
>
ValueT
<
K
>
&
Get
(
)
{
return
static_cast
<
Base
<
K
>
&
>
(
payload_
)
.
value
;
}
template
<
typename
K
>
const
ValueT
<
K
>
&
Get
(
)
const
{
return
static_cast
<
const
Base
<
K
>
&
>
(
payload_
)
.
value
;
}
private
:
template
<
typename
K
>
struct
Base
{
ValueT
<
K
>
value
{
}
;
}
;
struct
Payload
:
Base
<
Keys
>
.
.
.
{
}
;
Payload
payload_
;
}
;
template
<
typename
T
>
using
IntT
=
int
;
template
<
typename
T
>
using
PointerT
=
T
*
;
template
<
typename
.
.
.
T
>
class
FlatAllocation
{
public
:
static
constexpr
size_t
kMaxAlign
=
Max
(
alignof
(
T
)
.
.
.
)
;
FlatAllocation
(
const
TypeMap
<
IntT
T
.
.
.
>
&
ends
)
:
ends_
(
ends
)
{
Fold
(
{
(
ends_
.
template
Get
<
T
>
(
)
+
=
RoundUpTo
<
kMaxAlign
>
(
sizeof
(
FlatAllocation
)
)
)
.
.
.
}
)
;
Fold
(
{
Init
<
T
>
(
)
.
.
.
}
)
;
}
void
Destroy
(
)
{
Fold
(
{
Destroy
<
T
>
(
)
.
.
.
}
)
;
internal
:
:
SizedDelete
(
this
total_bytes
(
)
)
;
}
template
<
int
I
>
using
type
=
typename
std
:
:
tuple_element
<
I
std
:
:
tuple
<
T
.
.
.
>
>
:
:
type
;
TypeMap
<
PointerT
T
.
.
.
>
Pointers
(
)
const
{
TypeMap
<
PointerT
T
.
.
.
>
out
;
Fold
(
{
(
out
.
template
Get
<
T
>
(
)
=
Begin
<
T
>
(
)
)
.
.
.
}
)
;
return
out
;
}
private
:
int
total_bytes
(
)
const
{
return
ends_
.
template
Get
<
typename
std
:
:
tuple_element
<
sizeof
.
.
.
(
T
)
-
1
std
:
:
tuple
<
T
.
.
.
>
>
:
:
type
>
(
)
;
}
template
<
typename
U
>
int
BeginOffset
(
)
const
{
constexpr
int
type_index
=
FindTypeIndex
<
U
T
.
.
.
>
(
)
;
constexpr
int
prev_type_index
=
type_index
=
=
0
?
0
:
type_index
-
1
;
using
PrevType
=
typename
std
:
:
tuple_element
<
prev_type_index
std
:
:
tuple
<
T
.
.
.
>
>
:
:
type
;
static_assert
(
EffectiveAlignof
<
PrevType
>
(
)
>
=
EffectiveAlignof
<
U
>
(
)
"
"
)
;
return
type_index
=
=
0
?
RoundUpTo
<
kMaxAlign
>
(
sizeof
(
FlatAllocation
)
)
:
ends_
.
template
Get
<
PrevType
>
(
)
;
}
template
<
typename
U
>
int
EndOffset
(
)
const
{
return
ends_
.
template
Get
<
U
>
(
)
;
}
template
<
typename
U
>
U
*
Begin
(
)
const
{
int
begin
=
BeginOffset
<
U
>
(
)
end
=
EndOffset
<
U
>
(
)
;
if
(
begin
=
=
end
)
return
nullptr
;
return
reinterpret_cast
<
U
*
>
(
data
(
)
+
begin
)
;
}
template
<
typename
U
>
U
*
End
(
)
const
{
int
begin
=
BeginOffset
<
U
>
(
)
end
=
EndOffset
<
U
>
(
)
;
if
(
begin
=
=
end
)
return
nullptr
;
return
reinterpret_cast
<
U
*
>
(
data
(
)
+
end
)
;
}
template
<
typename
U
>
bool
Init
(
)
{
if
(
std
:
:
is_same
<
U
char
>
:
:
value
)
return
true
;
for
(
char
*
p
=
data
(
)
+
BeginOffset
<
U
>
(
)
*
end
=
data
(
)
+
EndOffset
<
U
>
(
)
;
p
!
=
end
;
p
+
=
sizeof
(
U
)
)
{
:
:
new
(
p
)
U
{
}
;
}
return
true
;
}
template
<
typename
U
>
bool
Destroy
(
)
{
if
(
std
:
:
is_trivially_destructible
<
U
>
:
:
value
)
return
true
;
for
(
U
*
it
=
Begin
<
U
>
(
)
*
end
=
End
<
U
>
(
)
;
it
!
=
end
;
+
+
it
)
{
it
-
>
~
U
(
)
;
}
return
true
;
}
char
*
data
(
)
const
{
return
const_cast
<
char
*
>
(
reinterpret_cast
<
const
char
*
>
(
this
)
)
;
}
TypeMap
<
IntT
T
.
.
.
>
ends_
;
}
;
template
<
typename
.
.
.
T
>
TypeMap
<
IntT
T
.
.
.
>
CalculateEnds
(
const
TypeMap
<
IntT
T
.
.
.
>
&
sizes
)
{
int
total
=
0
;
TypeMap
<
IntT
T
.
.
.
>
out
;
Fold
(
{
(
out
.
template
Get
<
T
>
(
)
=
total
+
=
sizeof
(
T
)
*
sizes
.
template
Get
<
T
>
(
)
)
.
.
.
}
)
;
return
out
;
}
template
<
typename
.
.
.
T
>
class
FlatAllocatorImpl
{
public
:
using
Allocation
=
FlatAllocation
<
T
.
.
.
>
;
template
<
typename
U
>
void
PlanArray
(
int
array_size
)
{
GOOGLE_CHECK
(
!
has_allocated
(
)
)
;
if
(
std
:
:
is_trivially_destructible
<
U
>
:
:
value
)
{
static_assert
(
alignof
(
U
)
<
=
8
"
"
)
;
total_
.
template
Get
<
char
>
(
)
+
=
RoundUpTo
<
8
>
(
array_size
*
sizeof
(
U
)
)
;
}
else
{
using
TypeToUse
=
typename
std
:
:
conditional
<
std
:
:
is_trivially_destructible
<
U
>
:
:
value
char
U
>
:
:
type
;
total_
.
template
Get
<
TypeToUse
>
(
)
+
=
array_size
;
}
}
template
<
typename
U
>
U
*
AllocateArray
(
int
array_size
)
{
constexpr
bool
trivial
=
std
:
:
is_trivially_destructible
<
U
>
:
:
value
;
using
TypeToUse
=
typename
std
:
:
conditional
<
trivial
char
U
>
:
:
type
;
GOOGLE_CHECK
(
has_allocated
(
)
)
;
TypeToUse
*
&
data
=
pointers_
.
template
Get
<
TypeToUse
>
(
)
;
int
&
used
=
used_
.
template
Get
<
TypeToUse
>
(
)
;
U
*
res
=
reinterpret_cast
<
U
*
>
(
data
+
used
)
;
used
+
=
trivial
?
RoundUpTo
<
8
>
(
array_size
*
sizeof
(
U
)
)
:
array_size
;
GOOGLE_CHECK_LE
(
used
total_
.
template
Get
<
TypeToUse
>
(
)
)
;
return
res
;
}
template
<
typename
.
.
.
In
>
const
std
:
:
string
*
AllocateStrings
(
In
&
&
.
.
.
in
)
{
std
:
:
string
*
strings
=
AllocateArray
<
std
:
:
string
>
(
sizeof
.
.
.
(
in
)
)
;
std
:
:
string
*
res
=
strings
;
Fold
(
{
(
*
strings
+
+
=
std
:
:
string
(
std
:
:
forward
<
In
>
(
in
)
)
)
.
.
.
}
)
;
return
res
;
}
void
PlanFieldNames
(
const
std
:
:
string
&
name
const
std
:
:
string
*
opt_json_name
)
{
GOOGLE_CHECK
(
!
has_allocated
(
)
)
;
if
(
opt_json_name
=
=
nullptr
)
{
switch
(
GetFieldNameCase
(
name
)
)
{
case
FieldNameCase
:
:
kAllLower
:
return
PlanArray
<
std
:
:
string
>
(
2
)
;
case
FieldNameCase
:
:
kSnakeCase
:
return
PlanArray
<
std
:
:
string
>
(
3
)
;
default
:
break
;
}
}
std
:
:
string
lowercase_name
=
name
;
LowerString
(
&
lowercase_name
)
;
std
:
:
string
camelcase_name
=
ToCamelCase
(
name
true
)
;
std
:
:
string
json_name
=
opt_json_name
!
=
nullptr
?
*
opt_json_name
:
ToJsonName
(
name
)
;
StringPiece
all_names
[
]
=
{
name
lowercase_name
camelcase_name
json_name
}
;
std
:
:
sort
(
all_names
all_names
+
4
)
;
int
unique
=
static_cast
<
int
>
(
std
:
:
unique
(
all_names
all_names
+
4
)
-
all_names
)
;
PlanArray
<
std
:
:
string
>
(
unique
+
1
)
;
}
struct
FieldNamesResult
{
const
std
:
:
string
*
array
;
int
lowercase_index
;
int
camelcase_index
;
int
json_index
;
}
;
FieldNamesResult
AllocateFieldNames
(
const
std
:
:
string
&
name
const
std
:
:
string
&
scope
const
std
:
:
string
*
opt_json_name
)
{
GOOGLE_CHECK
(
has_allocated
(
)
)
;
std
:
:
string
full_name
=
scope
.
empty
(
)
?
name
:
StrCat
(
scope
"
.
"
name
)
;
if
(
opt_json_name
=
=
nullptr
)
{
switch
(
GetFieldNameCase
(
name
)
)
{
case
FieldNameCase
:
:
kAllLower
:
return
{
AllocateStrings
(
name
std
:
:
move
(
full_name
)
)
0
0
0
}
;
case
FieldNameCase
:
:
kSnakeCase
:
return
{
AllocateStrings
(
name
std
:
:
move
(
full_name
)
ToCamelCase
(
name
true
)
)
0
2
2
}
;
default
:
break
;
}
}
std
:
:
vector
<
std
:
:
string
>
names
;
names
.
push_back
(
name
)
;
names
.
push_back
(
std
:
:
move
(
full_name
)
)
;
const
auto
push_name
=
[
&
]
(
std
:
:
string
new_name
)
{
for
(
size_t
i
=
0
;
i
<
names
.
size
(
)
;
+
+
i
)
{
if
(
i
=
=
1
)
continue
;
if
(
names
[
i
]
=
=
new_name
)
return
i
;
}
names
.
push_back
(
std
:
:
move
(
new_name
)
)
;
return
names
.
size
(
)
-
1
;
}
;
FieldNamesResult
result
{
nullptr
0
0
0
}
;
std
:
:
string
lowercase_name
=
name
;
LowerString
(
&
lowercase_name
)
;
result
.
lowercase_index
=
push_name
(
std
:
:
move
(
lowercase_name
)
)
;
result
.
camelcase_index
=
push_name
(
ToCamelCase
(
name
true
)
)
;
result
.
json_index
=
push_name
(
opt_json_name
!
=
nullptr
?
*
opt_json_name
:
ToJsonName
(
name
)
)
;
std
:
:
string
*
all_names
=
AllocateArray
<
std
:
:
string
>
(
names
.
size
(
)
)
;
result
.
array
=
all_names
;
std
:
:
move
(
names
.
begin
(
)
names
.
end
(
)
all_names
)
;
return
result
;
}
template
<
typename
Alloc
>
void
FinalizePlanning
(
Alloc
&
alloc
)
{
GOOGLE_CHECK
(
!
has_allocated
(
)
)
;
pointers_
=
alloc
-
>
CreateFlatAlloc
(
total_
)
-
>
Pointers
(
)
;
GOOGLE_CHECK
(
has_allocated
(
)
)
;
}
void
ExpectConsumed
(
)
const
{
Fold
(
{
ExpectConsumed
<
T
>
(
)
.
.
.
}
)
;
}
private
:
bool
has_allocated
(
)
const
{
return
pointers_
.
template
Get
<
char
>
(
)
!
=
nullptr
;
}
static
bool
IsLower
(
char
c
)
{
return
'
a
'
<
=
c
&
&
c
<
=
'
z
'
;
}
static
bool
IsDigit
(
char
c
)
{
return
'
0
'
<
=
c
&
&
c
<
=
'
9
'
;
}
static
bool
IsLowerOrDigit
(
char
c
)
{
return
IsLower
(
c
)
|
|
IsDigit
(
c
)
;
}
enum
class
FieldNameCase
{
kAllLower
kSnakeCase
kOther
}
;
FieldNameCase
GetFieldNameCase
(
const
std
:
:
string
&
name
)
{
if
(
!
IsLower
(
name
[
0
]
)
)
return
FieldNameCase
:
:
kOther
;
FieldNameCase
best
=
FieldNameCase
:
:
kAllLower
;
for
(
char
c
:
name
)
{
if
(
IsLowerOrDigit
(
c
)
)
{
}
else
if
(
c
=
=
'
_
'
)
{
best
=
FieldNameCase
:
:
kSnakeCase
;
}
else
{
return
FieldNameCase
:
:
kOther
;
}
}
return
best
;
}
template
<
typename
U
>
bool
ExpectConsumed
(
)
const
{
GOOGLE_CHECK_EQ
(
total_
.
template
Get
<
U
>
(
)
used_
.
template
Get
<
U
>
(
)
)
;
return
true
;
}
TypeMap
<
PointerT
T
.
.
.
>
pointers_
;
TypeMap
<
IntT
T
.
.
.
>
total_
;
TypeMap
<
IntT
T
.
.
.
>
used_
;
}
;
}
class
Symbol
{
public
:
enum
Type
{
NULL_SYMBOL
MESSAGE
FIELD
ONEOF
ENUM
ENUM_VALUE
ENUM_VALUE_OTHER_PARENT
SERVICE
METHOD
FULL_PACKAGE
SUB_PACKAGE
QUERY_KEY
}
;
Symbol
(
)
{
static
constexpr
internal
:
:
SymbolBase
null_symbol
{
}
;
static_assert
(
null_symbol
.
symbol_type_
=
=
NULL_SYMBOL
"
"
)
;
ptr_
=
&
null_symbol
;
}
#
define
DEFINE_MEMBERS
(
TYPE
TYPE_CONSTANT
FIELD
)
\
explicit
Symbol
(
TYPE
*
value
)
:
ptr_
(
value
)
{
\
value
-
>
symbol_type_
=
TYPE_CONSTANT
;
\
}
\
const
TYPE
*
FIELD
(
)
const
{
\
return
type
(
)
=
=
TYPE_CONSTANT
?
static_cast
<
const
TYPE
*
>
(
ptr_
)
:
nullptr
;
\
}
DEFINE_MEMBERS
(
Descriptor
MESSAGE
descriptor
)
DEFINE_MEMBERS
(
FieldDescriptor
FIELD
field_descriptor
)
DEFINE_MEMBERS
(
OneofDescriptor
ONEOF
oneof_descriptor
)
DEFINE_MEMBERS
(
EnumDescriptor
ENUM
enum_descriptor
)
DEFINE_MEMBERS
(
ServiceDescriptor
SERVICE
service_descriptor
)
DEFINE_MEMBERS
(
MethodDescriptor
METHOD
method_descriptor
)
DEFINE_MEMBERS
(
FileDescriptor
FULL_PACKAGE
file_descriptor
)
struct
Subpackage
:
internal
:
:
SymbolBase
{
int
name_size
;
const
FileDescriptor
*
file
;
}
;
DEFINE_MEMBERS
(
Subpackage
SUB_PACKAGE
sub_package_file_descriptor
)
static
Symbol
EnumValue
(
EnumValueDescriptor
*
value
int
n
)
{
Symbol
s
;
internal
:
:
SymbolBase
*
ptr
;
if
(
n
=
=
0
)
{
ptr
=
static_cast
<
internal
:
:
SymbolBaseN
<
0
>
*
>
(
value
)
;
ptr
-
>
symbol_type_
=
ENUM_VALUE
;
}
else
{
ptr
=
static_cast
<
internal
:
:
SymbolBaseN
<
1
>
*
>
(
value
)
;
ptr
-
>
symbol_type_
=
ENUM_VALUE_OTHER_PARENT
;
}
s
.
ptr_
=
ptr
;
return
s
;
}
const
EnumValueDescriptor
*
enum_value_descriptor
(
)
const
{
return
type
(
)
=
=
ENUM_VALUE
?
static_cast
<
const
EnumValueDescriptor
*
>
(
static_cast
<
const
internal
:
:
SymbolBaseN
<
0
>
*
>
(
ptr_
)
)
:
type
(
)
=
=
ENUM_VALUE_OTHER_PARENT
?
static_cast
<
const
EnumValueDescriptor
*
>
(
static_cast
<
const
internal
:
:
SymbolBaseN
<
1
>
*
>
(
ptr_
)
)
:
nullptr
;
}
struct
QueryKey
:
internal
:
:
SymbolBase
{
StringPiece
name
;
const
void
*
parent
;
int
field_number
;
StringPiece
full_name
(
)
const
{
return
name
;
}
std
:
:
pair
<
const
void
*
int
>
parent_number_key
(
)
const
{
return
{
parent
field_number
}
;
}
std
:
:
pair
<
const
void
*
StringPiece
>
parent_name_key
(
)
const
{
return
{
parent
name
}
;
}
}
;
Symbol
(
QueryKey
&
value
)
:
ptr_
(
&
value
)
{
value
.
symbol_type_
=
QUERY_KEY
;
}
const
QueryKey
*
query_key
(
)
const
{
return
type
(
)
=
=
QUERY_KEY
?
static_cast
<
const
QueryKey
*
>
(
ptr_
)
:
nullptr
;
}
#
undef
DEFINE_MEMBERS
Type
type
(
)
const
{
return
static_cast
<
Type
>
(
ptr_
-
>
symbol_type_
)
;
}
bool
IsNull
(
)
const
{
return
type
(
)
=
=
NULL_SYMBOL
;
}
bool
IsType
(
)
const
{
return
type
(
)
=
=
MESSAGE
|
|
type
(
)
=
=
ENUM
;
}
bool
IsAggregate
(
)
const
{
return
IsType
(
)
|
|
IsPackage
(
)
|
|
type
(
)
=
=
SERVICE
;
}
bool
IsPackage
(
)
const
{
return
type
(
)
=
=
FULL_PACKAGE
|
|
type
(
)
=
=
SUB_PACKAGE
;
}
const
FileDescriptor
*
GetFile
(
)
const
{
switch
(
type
(
)
)
{
case
MESSAGE
:
return
descriptor
(
)
-
>
file
(
)
;
case
FIELD
:
return
field_descriptor
(
)
-
>
file
(
)
;
case
ONEOF
:
return
oneof_descriptor
(
)
-
>
containing_type
(
)
-
>
file
(
)
;
case
ENUM
:
return
enum_descriptor
(
)
-
>
file
(
)
;
case
ENUM_VALUE
:
return
enum_value_descriptor
(
)
-
>
type
(
)
-
>
file
(
)
;
case
SERVICE
:
return
service_descriptor
(
)
-
>
file
(
)
;
case
METHOD
:
return
method_descriptor
(
)
-
>
service
(
)
-
>
file
(
)
;
case
FULL_PACKAGE
:
return
file_descriptor
(
)
;
case
SUB_PACKAGE
:
return
sub_package_file_descriptor
(
)
-
>
file
;
default
:
return
nullptr
;
}
}
StringPiece
full_name
(
)
const
{
switch
(
type
(
)
)
{
case
MESSAGE
:
return
descriptor
(
)
-
>
full_name
(
)
;
case
FIELD
:
return
field_descriptor
(
)
-
>
full_name
(
)
;
case
ONEOF
:
return
oneof_descriptor
(
)
-
>
full_name
(
)
;
case
ENUM
:
return
enum_descriptor
(
)
-
>
full_name
(
)
;
case
ENUM_VALUE
:
return
enum_value_descriptor
(
)
-
>
full_name
(
)
;
case
SERVICE
:
return
service_descriptor
(
)
-
>
full_name
(
)
;
case
METHOD
:
return
method_descriptor
(
)
-
>
full_name
(
)
;
case
FULL_PACKAGE
:
return
file_descriptor
(
)
-
>
package
(
)
;
case
SUB_PACKAGE
:
return
StringPiece
(
sub_package_file_descriptor
(
)
-
>
file
-
>
package
(
)
)
.
substr
(
0
sub_package_file_descriptor
(
)
-
>
name_size
)
;
case
QUERY_KEY
:
return
query_key
(
)
-
>
full_name
(
)
;
default
:
GOOGLE_CHECK
(
false
)
;
}
return
"
"
;
}
std
:
:
pair
<
const
void
*
StringPiece
>
parent_name_key
(
)
const
{
const
auto
or_file
=
[
&
]
(
const
void
*
p
)
{
return
p
?
p
:
GetFile
(
)
;
}
;
switch
(
type
(
)
)
{
case
MESSAGE
:
return
{
or_file
(
descriptor
(
)
-
>
containing_type
(
)
)
descriptor
(
)
-
>
name
(
)
}
;
case
FIELD
:
{
auto
*
field
=
field_descriptor
(
)
;
return
{
or_file
(
field
-
>
is_extension
(
)
?
field
-
>
extension_scope
(
)
:
field
-
>
containing_type
(
)
)
field
-
>
name
(
)
}
;
}
case
ONEOF
:
return
{
oneof_descriptor
(
)
-
>
containing_type
(
)
oneof_descriptor
(
)
-
>
name
(
)
}
;
case
ENUM
:
return
{
or_file
(
enum_descriptor
(
)
-
>
containing_type
(
)
)
enum_descriptor
(
)
-
>
name
(
)
}
;
case
ENUM_VALUE
:
return
{
or_file
(
enum_value_descriptor
(
)
-
>
type
(
)
-
>
containing_type
(
)
)
enum_value_descriptor
(
)
-
>
name
(
)
}
;
case
ENUM_VALUE_OTHER_PARENT
:
return
{
enum_value_descriptor
(
)
-
>
type
(
)
enum_value_descriptor
(
)
-
>
name
(
)
}
;
case
SERVICE
:
return
{
GetFile
(
)
service_descriptor
(
)
-
>
name
(
)
}
;
case
METHOD
:
return
{
method_descriptor
(
)
-
>
service
(
)
method_descriptor
(
)
-
>
name
(
)
}
;
case
QUERY_KEY
:
return
query_key
(
)
-
>
parent_name_key
(
)
;
default
:
GOOGLE_CHECK
(
false
)
;
}
return
{
}
;
}
std
:
:
pair
<
const
void
*
int
>
parent_number_key
(
)
const
{
switch
(
type
(
)
)
{
case
FIELD
:
return
{
field_descriptor
(
)
-
>
containing_type
(
)
field_descriptor
(
)
-
>
number
(
)
}
;
case
ENUM_VALUE
:
return
{
enum_value_descriptor
(
)
-
>
type
(
)
enum_value_descriptor
(
)
-
>
number
(
)
}
;
case
QUERY_KEY
:
return
query_key
(
)
-
>
parent_number_key
(
)
;
default
:
GOOGLE_CHECK
(
false
)
;
}
return
{
}
;
}
private
:
const
internal
:
:
SymbolBase
*
ptr_
;
}
;
const
FieldDescriptor
:
:
CppType
FieldDescriptor
:
:
kTypeToCppTypeMap
[
MAX_TYPE
+
1
]
=
{
static_cast
<
CppType
>
(
0
)
CPPTYPE_DOUBLE
CPPTYPE_FLOAT
CPPTYPE_INT64
CPPTYPE_UINT64
CPPTYPE_INT32
CPPTYPE_UINT64
CPPTYPE_UINT32
CPPTYPE_BOOL
CPPTYPE_STRING
CPPTYPE_MESSAGE
CPPTYPE_MESSAGE
CPPTYPE_STRING
CPPTYPE_UINT32
CPPTYPE_ENUM
CPPTYPE_INT32
CPPTYPE_INT64
CPPTYPE_INT32
CPPTYPE_INT64
}
;
const
char
*
const
FieldDescriptor
:
:
kTypeToName
[
MAX_TYPE
+
1
]
=
{
"
ERROR
"
"
double
"
"
float
"
"
int64
"
"
uint64
"
"
int32
"
"
fixed64
"
"
fixed32
"
"
bool
"
"
string
"
"
group
"
"
message
"
"
bytes
"
"
uint32
"
"
enum
"
"
sfixed32
"
"
sfixed64
"
"
sint32
"
"
sint64
"
}
;
const
char
*
const
FieldDescriptor
:
:
kCppTypeToName
[
MAX_CPPTYPE
+
1
]
=
{
"
ERROR
"
"
int32
"
"
int64
"
"
uint32
"
"
uint64
"
"
double
"
"
float
"
"
bool
"
"
enum
"
"
string
"
"
message
"
}
;
const
char
*
const
FieldDescriptor
:
:
kLabelToName
[
MAX_LABEL
+
1
]
=
{
"
ERROR
"
"
optional
"
"
required
"
"
repeated
"
}
;
const
char
*
FileDescriptor
:
:
SyntaxName
(
FileDescriptor
:
:
Syntax
syntax
)
{
switch
(
syntax
)
{
case
SYNTAX_PROTO2
:
return
"
proto2
"
;
case
SYNTAX_PROTO3
:
return
"
proto3
"
;
case
SYNTAX_UNKNOWN
:
return
"
unknown
"
;
}
GOOGLE_LOG
(
FATAL
)
<
<
"
can
'
t
reach
here
.
"
;
return
nullptr
;
}
static
const
char
*
const
kNonLinkedWeakMessageReplacementName
=
"
google
.
protobuf
.
Empty
"
;
#
if
!
defined
(
_MSC_VER
)
|
|
(
_MSC_VER
>
=
1900
&
&
_MSC_VER
<
1912
)
const
int
FieldDescriptor
:
:
kMaxNumber
;
const
int
FieldDescriptor
:
:
kFirstReservedNumber
;
const
int
FieldDescriptor
:
:
kLastReservedNumber
;
#
endif
namespace
{
std
:
:
string
EnumValueToPascalCase
(
const
std
:
:
string
&
input
)
{
bool
next_upper
=
true
;
std
:
:
string
result
;
result
.
reserve
(
input
.
size
(
)
)
;
for
(
char
character
:
input
)
{
if
(
character
=
=
'
_
'
)
{
next_upper
=
true
;
}
else
{
if
(
next_upper
)
{
result
.
push_back
(
ToUpper
(
character
)
)
;
}
else
{
result
.
push_back
(
ToLower
(
character
)
)
;
}
next_upper
=
false
;
}
}
return
result
;
}
class
PrefixRemover
{
public
:
PrefixRemover
(
StringPiece
prefix
)
{
for
(
char
character
:
prefix
)
{
if
(
character
!
=
'
_
'
)
{
prefix_
+
=
ascii_tolower
(
character
)
;
}
}
}
std
:
:
string
MaybeRemove
(
StringPiece
str
)
{
size_t
i
j
;
for
(
i
=
0
j
=
0
;
i
<
str
.
size
(
)
&
&
j
<
prefix_
.
size
(
)
;
i
+
+
)
{
if
(
str
[
i
]
=
=
'
_
'
)
{
continue
;
}
if
(
ascii_tolower
(
str
[
i
]
)
!
=
prefix_
[
j
+
+
]
)
{
return
std
:
:
string
(
str
)
;
}
}
if
(
j
<
prefix_
.
size
(
)
)
{
return
std
:
:
string
(
str
)
;
}
while
(
i
<
str
.
size
(
)
&
&
str
[
i
]
=
=
'
_
'
)
{
i
+
+
;
}
if
(
i
=
=
str
.
size
(
)
)
{
return
std
:
:
string
(
str
)
;
}
str
.
remove_prefix
(
i
)
;
return
std
:
:
string
(
str
)
;
}
private
:
std
:
:
string
prefix_
;
}
;
typedef
std
:
:
pair
<
const
void
*
StringPiece
>
PointerStringPair
;
typedef
std
:
:
pair
<
const
Descriptor
*
int
>
DescriptorIntPair
;
#
define
HASH_MAP
std
:
:
unordered_map
#
define
HASH_SET
std
:
:
unordered_set
#
define
HASH_FXN
hash
template
<
typename
PairType
>
struct
PointerIntegerPairHash
{
size_t
operator
(
)
(
const
PairType
&
p
)
const
{
static
const
size_t
prime1
=
16777499
;
static
const
size_t
prime2
=
16777619
;
return
reinterpret_cast
<
size_t
>
(
p
.
first
)
*
prime1
^
static_cast
<
size_t
>
(
p
.
second
)
*
prime2
;
}
#
ifdef
_MSC_VER
static
const
size_t
bucket_size
=
4
;
static
const
size_t
min_buckets
=
8
;
#
endif
inline
bool
operator
(
)
(
const
PairType
&
a
const
PairType
&
b
)
const
{
return
a
<
b
;
}
}
;
struct
PointerStringPairHash
{
size_t
operator
(
)
(
const
PointerStringPair
&
p
)
const
{
static
const
size_t
prime
=
16777619
;
hash
<
StringPiece
>
string_hash
;
return
reinterpret_cast
<
size_t
>
(
p
.
first
)
*
prime
^
static_cast
<
size_t
>
(
string_hash
(
p
.
second
)
)
;
}
#
ifdef
_MSC_VER
static
const
size_t
bucket_size
=
4
;
static
const
size_t
min_buckets
=
8
;
#
endif
inline
bool
operator
(
)
(
const
PointerStringPair
&
a
const
PointerStringPair
&
b
)
const
{
return
a
<
b
;
}
}
;
struct
SymbolByFullNameHash
{
using
is_transparent
=
void
;
template
<
typename
T
>
size_t
operator
(
)
(
const
T
&
s
)
const
{
return
HASH_FXN
<
StringPiece
>
{
}
(
s
.
full_name
(
)
)
;
}
}
;
struct
SymbolByFullNameEq
{
using
is_transparent
=
void
;
template
<
typename
T
typename
U
>
bool
operator
(
)
(
const
T
&
a
const
U
&
b
)
const
{
return
a
.
full_name
(
)
=
=
b
.
full_name
(
)
;
}
}
;
using
SymbolsByNameSet
=
HASH_SET
<
Symbol
SymbolByFullNameHash
SymbolByFullNameEq
>
;
struct
SymbolByParentHash
{
using
is_transparent
=
void
;
template
<
typename
T
>
size_t
operator
(
)
(
const
T
&
s
)
const
{
return
PointerStringPairHash
{
}
(
s
.
parent_name_key
(
)
)
;
}
}
;
struct
SymbolByParentEq
{
using
is_transparent
=
void
;
template
<
typename
T
typename
U
>
bool
operator
(
)
(
const
T
&
a
const
U
&
b
)
const
{
return
a
.
parent_name_key
(
)
=
=
b
.
parent_name_key
(
)
;
}
}
;
using
SymbolsByParentSet
=
HASH_SET
<
Symbol
SymbolByParentHash
SymbolByParentEq
>
;
typedef
HASH_MAP
<
StringPiece
const
FileDescriptor
*
HASH_FXN
<
StringPiece
>
>
FilesByNameMap
;
typedef
HASH_MAP
<
PointerStringPair
const
FieldDescriptor
*
PointerStringPairHash
>
FieldsByNameMap
;
struct
FieldsByNumberHash
{
using
is_transparent
=
void
;
template
<
typename
T
>
size_t
operator
(
)
(
const
T
&
s
)
const
{
return
PointerIntegerPairHash
<
std
:
:
pair
<
const
void
*
int
>
>
{
}
(
s
.
parent_number_key
(
)
)
;
}
}
;
struct
FieldsByNumberEq
{
using
is_transparent
=
void
;
template
<
typename
T
typename
U
>
bool
operator
(
)
(
const
T
&
a
const
U
&
b
)
const
{
return
a
.
parent_number_key
(
)
=
=
b
.
parent_number_key
(
)
;
}
}
;
using
FieldsByNumberSet
=
HASH_SET
<
Symbol
FieldsByNumberHash
FieldsByNumberEq
>
;
using
EnumValuesByNumberSet
=
FieldsByNumberSet
;
typedef
std
:
:
map
<
DescriptorIntPair
const
FieldDescriptor
*
>
ExtensionsGroupedByDescriptorMap
;
typedef
HASH_MAP
<
std
:
:
string
const
SourceCodeInfo_Location
*
>
LocationsByPathMap
;
std
:
:
set
<
std
:
:
string
>
*
NewAllowedProto3Extendee
(
)
{
auto
allowed_proto3_extendees
=
new
std
:
:
set
<
std
:
:
string
>
;
const
char
*
kOptionNames
[
]
=
{
"
FileOptions
"
"
MessageOptions
"
"
FieldOptions
"
"
EnumOptions
"
"
EnumValueOptions
"
"
ServiceOptions
"
"
MethodOptions
"
"
OneofOptions
"
"
ExtensionRangeOptions
"
}
;
for
(
const
char
*
option_name
:
kOptionNames
)
{
allowed_proto3_extendees
-
>
insert
(
std
:
:
string
(
"
google
.
protobuf
.
"
)
+
option_name
)
;
allowed_proto3_extendees
-
>
insert
(
std
:
:
string
(
"
proto
"
)
+
"
2
.
"
+
option_name
)
;
}
return
allowed_proto3_extendees
;
}
bool
AllowedExtendeeInProto3
(
const
std
:
:
string
&
name
)
{
static
auto
allowed_proto3_extendees
=
internal
:
:
OnShutdownDelete
(
NewAllowedProto3Extendee
(
)
)
;
return
allowed_proto3_extendees
-
>
find
(
name
)
!
=
allowed_proto3_extendees
-
>
end
(
)
;
}
}
class
FileDescriptorTables
{
public
:
FileDescriptorTables
(
)
;
~
FileDescriptorTables
(
)
;
inline
static
const
FileDescriptorTables
&
GetEmptyInstance
(
)
;
inline
Symbol
FindNestedSymbol
(
const
void
*
parent
StringPiece
name
)
const
;
inline
const
FieldDescriptor
*
FindFieldByNumber
(
const
Descriptor
*
parent
int
number
)
const
;
inline
const
FieldDescriptor
*
FindFieldByLowercaseName
(
const
void
*
parent
StringPiece
lowercase_name
)
const
;
inline
const
FieldDescriptor
*
FindFieldByCamelcaseName
(
const
void
*
parent
StringPiece
camelcase_name
)
const
;
inline
const
EnumValueDescriptor
*
FindEnumValueByNumber
(
const
EnumDescriptor
*
parent
int
number
)
const
;
inline
const
EnumValueDescriptor
*
FindEnumValueByNumberCreatingIfUnknown
(
const
EnumDescriptor
*
parent
int
number
)
const
;
bool
AddAliasUnderParent
(
const
void
*
parent
const
std
:
:
string
&
name
Symbol
symbol
)
;
bool
AddFieldByNumber
(
FieldDescriptor
*
field
)
;
bool
AddEnumValueByNumber
(
EnumValueDescriptor
*
value
)
;
static
void
BuildLocationsByPath
(
std
:
:
pair
<
const
FileDescriptorTables
*
const
SourceCodeInfo
*
>
*
p
)
;
const
SourceCodeInfo_Location
*
GetSourceLocation
(
const
std
:
:
vector
<
int
>
&
path
const
SourceCodeInfo
*
info
)
const
;
void
FinalizeTables
(
)
;
private
:
const
void
*
FindParentForFieldsByMap
(
const
FieldDescriptor
*
field
)
const
;
static
void
FieldsByLowercaseNamesLazyInitStatic
(
const
FileDescriptorTables
*
tables
)
;
void
FieldsByLowercaseNamesLazyInitInternal
(
)
const
;
static
void
FieldsByCamelcaseNamesLazyInitStatic
(
const
FileDescriptorTables
*
tables
)
;
void
FieldsByCamelcaseNamesLazyInitInternal
(
)
const
;
SymbolsByParentSet
symbols_by_parent_
;
mutable
internal
:
:
once_flag
fields_by_lowercase_name_once_
;
mutable
internal
:
:
once_flag
fields_by_camelcase_name_once_
;
mutable
std
:
:
atomic
<
const
FieldsByNameMap
*
>
fields_by_lowercase_name_
{
}
;
mutable
std
:
:
atomic
<
const
FieldsByNameMap
*
>
fields_by_camelcase_name_
{
}
;
FieldsByNumberSet
fields_by_number_
;
EnumValuesByNumberSet
enum_values_by_number_
;
mutable
EnumValuesByNumberSet
unknown_enum_values_by_number_
PROTOBUF_GUARDED_BY
(
unknown_enum_values_mu_
)
;
mutable
internal
:
:
once_flag
locations_by_path_once_
;
mutable
LocationsByPathMap
locations_by_path_
;
mutable
internal
:
:
WrappedMutex
unknown_enum_values_mu_
;
}
;
namespace
internal
{
class
FlatAllocator
:
public
decltype
(
ApplyTypeList
<
FlatAllocatorImpl
>
(
SortByAlignment
<
char
std
:
:
string
SourceCodeInfo
FileDescriptorTables
MessageOptions
FieldOptions
EnumOptions
EnumValueOptions
ExtensionRangeOptions
OneofOptions
ServiceOptions
MethodOptions
FileOptions
>
(
)
)
)
{
}
;
}
class
DescriptorPool
:
:
Tables
{
public
:
Tables
(
)
;
~
Tables
(
)
;
void
AddCheckpoint
(
)
;
void
ClearLastCheckpoint
(
)
;
void
RollbackToLastCheckpoint
(
)
;
std
:
:
vector
<
std
:
:
string
>
pending_files_
;
HASH_SET
<
std
:
:
string
>
known_bad_files_
;
HASH_SET
<
std
:
:
string
>
known_bad_symbols_
;
HASH_SET
<
const
Descriptor
*
>
extensions_loaded_from_db_
;
HASH_MAP
<
std
:
:
string
Descriptor
:
:
WellKnownType
>
well_known_types_
;
inline
Symbol
FindSymbol
(
StringPiece
key
)
const
;
Symbol
FindByNameHelper
(
const
DescriptorPool
*
pool
StringPiece
name
)
;
inline
const
FileDescriptor
*
FindFile
(
StringPiece
key
)
const
;
inline
const
FieldDescriptor
*
FindExtension
(
const
Descriptor
*
extendee
int
number
)
const
;
inline
void
FindAllExtensions
(
const
Descriptor
*
extendee
std
:
:
vector
<
const
FieldDescriptor
*
>
*
out
)
const
;
bool
AddSymbol
(
const
std
:
:
string
&
full_name
Symbol
symbol
)
;
bool
AddFile
(
const
FileDescriptor
*
file
)
;
bool
AddExtension
(
const
FieldDescriptor
*
field
)
;
template
<
typename
Type
>
Type
*
Allocate
(
)
;
void
*
AllocateBytes
(
int
size
)
;
template
<
typename
.
.
.
T
>
internal
:
:
FlatAllocator
:
:
Allocation
*
CreateFlatAlloc
(
const
TypeMap
<
IntT
T
.
.
.
>
&
sizes
)
;
private
:
struct
MiscDeleter
{
void
operator
(
)
(
int
*
p
)
const
{
internal
:
:
SizedDelete
(
p
*
p
+
8
)
;
}
}
;
std
:
:
vector
<
std
:
:
unique_ptr
<
int
MiscDeleter
>
>
misc_allocs_
;
struct
FlatAllocDeleter
{
void
operator
(
)
(
internal
:
:
FlatAllocator
:
:
Allocation
*
p
)
const
{
p
-
>
Destroy
(
)
;
}
}
;
std
:
:
vector
<
std
:
:
unique_ptr
<
internal
:
:
FlatAllocator
:
:
Allocation
FlatAllocDeleter
>
>
flat_allocs_
;
SymbolsByNameSet
symbols_by_name_
;
FilesByNameMap
files_by_name_
;
ExtensionsGroupedByDescriptorMap
extensions_
;
struct
CheckPoint
{
explicit
CheckPoint
(
const
Tables
*
tables
)
:
flat_allocations_before_checkpoint
(
static_cast
<
int
>
(
tables
-
>
flat_allocs_
.
size
(
)
)
)
misc_allocations_before_checkpoint
(
static_cast
<
int
>
(
tables
-
>
misc_allocs_
.
size
(
)
)
)
pending_symbols_before_checkpoint
(
tables
-
>
symbols_after_checkpoint_
.
size
(
)
)
pending_files_before_checkpoint
(
tables
-
>
files_after_checkpoint_
.
size
(
)
)
pending_extensions_before_checkpoint
(
tables
-
>
extensions_after_checkpoint_
.
size
(
)
)
{
}
int
flat_allocations_before_checkpoint
;
int
misc_allocations_before_checkpoint
;
int
pending_symbols_before_checkpoint
;
int
pending_files_before_checkpoint
;
int
pending_extensions_before_checkpoint
;
}
;
std
:
:
vector
<
CheckPoint
>
checkpoints_
;
std
:
:
vector
<
Symbol
>
symbols_after_checkpoint_
;
std
:
:
vector
<
const
FileDescriptor
*
>
files_after_checkpoint_
;
std
:
:
vector
<
DescriptorIntPair
>
extensions_after_checkpoint_
;
}
;
DescriptorPool
:
:
Tables
:
:
Tables
(
)
{
well_known_types_
.
insert
(
{
{
"
google
.
protobuf
.
DoubleValue
"
Descriptor
:
:
WELLKNOWNTYPE_DOUBLEVALUE
}
{
"
google
.
protobuf
.
FloatValue
"
Descriptor
:
:
WELLKNOWNTYPE_FLOATVALUE
}
{
"
google
.
protobuf
.
Int64Value
"
Descriptor
:
:
WELLKNOWNTYPE_INT64VALUE
}
{
"
google
.
protobuf
.
UInt64Value
"
Descriptor
:
:
WELLKNOWNTYPE_UINT64VALUE
}
{
"
google
.
protobuf
.
Int32Value
"
Descriptor
:
:
WELLKNOWNTYPE_INT32VALUE
}
{
"
google
.
protobuf
.
UInt32Value
"
Descriptor
:
:
WELLKNOWNTYPE_UINT32VALUE
}
{
"
google
.
protobuf
.
StringValue
"
Descriptor
:
:
WELLKNOWNTYPE_STRINGVALUE
}
{
"
google
.
protobuf
.
BytesValue
"
Descriptor
:
:
WELLKNOWNTYPE_BYTESVALUE
}
{
"
google
.
protobuf
.
BoolValue
"
Descriptor
:
:
WELLKNOWNTYPE_BOOLVALUE
}
{
"
google
.
protobuf
.
Any
"
Descriptor
:
:
WELLKNOWNTYPE_ANY
}
{
"
google
.
protobuf
.
FieldMask
"
Descriptor
:
:
WELLKNOWNTYPE_FIELDMASK
}
{
"
google
.
protobuf
.
Duration
"
Descriptor
:
:
WELLKNOWNTYPE_DURATION
}
{
"
google
.
protobuf
.
Timestamp
"
Descriptor
:
:
WELLKNOWNTYPE_TIMESTAMP
}
{
"
google
.
protobuf
.
Value
"
Descriptor
:
:
WELLKNOWNTYPE_VALUE
}
{
"
google
.
protobuf
.
ListValue
"
Descriptor
:
:
WELLKNOWNTYPE_LISTVALUE
}
{
"
google
.
protobuf
.
Struct
"
Descriptor
:
:
WELLKNOWNTYPE_STRUCT
}
}
)
;
}
DescriptorPool
:
:
Tables
:
:
~
Tables
(
)
{
GOOGLE_DCHECK
(
checkpoints_
.
empty
(
)
)
;
}
FileDescriptorTables
:
:
FileDescriptorTables
(
)
{
}
FileDescriptorTables
:
:
~
FileDescriptorTables
(
)
{
delete
fields_by_lowercase_name_
.
load
(
std
:
:
memory_order_acquire
)
;
delete
fields_by_camelcase_name_
.
load
(
std
:
:
memory_order_acquire
)
;
}
inline
const
FileDescriptorTables
&
FileDescriptorTables
:
:
GetEmptyInstance
(
)
{
static
auto
file_descriptor_tables
=
internal
:
:
OnShutdownDelete
(
new
FileDescriptorTables
(
)
)
;
return
*
file_descriptor_tables
;
}
void
DescriptorPool
:
:
Tables
:
:
AddCheckpoint
(
)
{
checkpoints_
.
push_back
(
CheckPoint
(
this
)
)
;
}
void
DescriptorPool
:
:
Tables
:
:
ClearLastCheckpoint
(
)
{
GOOGLE_DCHECK
(
!
checkpoints_
.
empty
(
)
)
;
checkpoints_
.
pop_back
(
)
;
if
(
checkpoints_
.
empty
(
)
)
{
symbols_after_checkpoint_
.
clear
(
)
;
files_after_checkpoint_
.
clear
(
)
;
extensions_after_checkpoint_
.
clear
(
)
;
}
}
void
DescriptorPool
:
:
Tables
:
:
RollbackToLastCheckpoint
(
)
{
GOOGLE_DCHECK
(
!
checkpoints_
.
empty
(
)
)
;
const
CheckPoint
&
checkpoint
=
checkpoints_
.
back
(
)
;
for
(
size_t
i
=
checkpoint
.
pending_symbols_before_checkpoint
;
i
<
symbols_after_checkpoint_
.
size
(
)
;
i
+
+
)
{
symbols_by_name_
.
erase
(
symbols_after_checkpoint_
[
i
]
)
;
}
for
(
size_t
i
=
checkpoint
.
pending_files_before_checkpoint
;
i
<
files_after_checkpoint_
.
size
(
)
;
i
+
+
)
{
files_by_name_
.
erase
(
files_after_checkpoint_
[
i
]
-
>
name
(
)
)
;
}
for
(
size_t
i
=
checkpoint
.
pending_extensions_before_checkpoint
;
i
<
extensions_after_checkpoint_
.
size
(
)
;
i
+
+
)
{
extensions_
.
erase
(
extensions_after_checkpoint_
[
i
]
)
;
}
symbols_after_checkpoint_
.
resize
(
checkpoint
.
pending_symbols_before_checkpoint
)
;
files_after_checkpoint_
.
resize
(
checkpoint
.
pending_files_before_checkpoint
)
;
extensions_after_checkpoint_
.
resize
(
checkpoint
.
pending_extensions_before_checkpoint
)
;
flat_allocs_
.
resize
(
checkpoint
.
flat_allocations_before_checkpoint
)
;
misc_allocs_
.
resize
(
checkpoint
.
misc_allocations_before_checkpoint
)
;
checkpoints_
.
pop_back
(
)
;
}
inline
Symbol
DescriptorPool
:
:
Tables
:
:
FindSymbol
(
StringPiece
key
)
const
{
Symbol
:
:
QueryKey
name
;
name
.
name
=
key
;
auto
it
=
symbols_by_name_
.
find
(
name
)
;
return
it
=
=
symbols_by_name_
.
end
(
)
?
Symbol
(
)
:
*
it
;
}
inline
Symbol
FileDescriptorTables
:
:
FindNestedSymbol
(
const
void
*
parent
StringPiece
name
)
const
{
Symbol
:
:
QueryKey
query
;
query
.
name
=
name
;
query
.
parent
=
parent
;
auto
it
=
symbols_by_parent_
.
find
(
query
)
;
return
it
=
=
symbols_by_parent_
.
end
(
)
?
Symbol
(
)
:
*
it
;
}
Symbol
DescriptorPool
:
:
Tables
:
:
FindByNameHelper
(
const
DescriptorPool
*
pool
StringPiece
name
)
{
if
(
pool
-
>
mutex_
!
=
nullptr
)
{
ReaderMutexLock
lock
(
pool
-
>
mutex_
)
;
if
(
known_bad_symbols_
.
empty
(
)
&
&
known_bad_files_
.
empty
(
)
)
{
Symbol
result
=
FindSymbol
(
name
)
;
if
(
!
result
.
IsNull
(
)
)
return
result
;
}
}
MutexLockMaybe
lock
(
pool
-
>
mutex_
)
;
if
(
pool
-
>
fallback_database_
!
=
nullptr
)
{
known_bad_symbols_
.
clear
(
)
;
known_bad_files_
.
clear
(
)
;
}
Symbol
result
=
FindSymbol
(
name
)
;
if
(
result
.
IsNull
(
)
&
&
pool
-
>
underlay_
!
=
nullptr
)
{
result
=
pool
-
>
underlay_
-
>
tables_
-
>
FindByNameHelper
(
pool
-
>
underlay_
name
)
;
}
if
(
result
.
IsNull
(
)
)
{
if
(
pool
-
>
TryFindSymbolInFallbackDatabase
(
name
)
)
{
result
=
FindSymbol
(
name
)
;
}
}
return
result
;
}
inline
const
FileDescriptor
*
DescriptorPool
:
:
Tables
:
:
FindFile
(
StringPiece
key
)
const
{
return
FindPtrOrNull
(
files_by_name_
key
)
;
}
inline
const
FieldDescriptor
*
FileDescriptorTables
:
:
FindFieldByNumber
(
const
Descriptor
*
parent
int
number
)
const
{
if
(
parent
!
=
nullptr
&
&
1
<
=
number
&
&
number
<
=
parent
-
>
sequential_field_limit_
)
{
return
parent
-
>
field
(
number
-
1
)
;
}
Symbol
:
:
QueryKey
query
;
query
.
parent
=
parent
;
query
.
field_number
=
number
;
auto
it
=
fields_by_number_
.
find
(
query
)
;
return
it
=
=
fields_by_number_
.
end
(
)
?
nullptr
:
it
-
>
field_descriptor
(
)
;
}
const
void
*
FileDescriptorTables
:
:
FindParentForFieldsByMap
(
const
FieldDescriptor
*
field
)
const
{
if
(
field
-
>
is_extension
(
)
)
{
if
(
field
-
>
extension_scope
(
)
=
=
nullptr
)
{
return
field
-
>
file
(
)
;
}
else
{
return
field
-
>
extension_scope
(
)
;
}
}
else
{
return
field
-
>
containing_type
(
)
;
}
}
void
FileDescriptorTables
:
:
FieldsByLowercaseNamesLazyInitStatic
(
const
FileDescriptorTables
*
tables
)
{
tables
-
>
FieldsByLowercaseNamesLazyInitInternal
(
)
;
}
void
FileDescriptorTables
:
:
FieldsByLowercaseNamesLazyInitInternal
(
)
const
{
auto
*
map
=
new
FieldsByNameMap
;
for
(
Symbol
symbol
:
symbols_by_parent_
)
{
const
FieldDescriptor
*
field
=
symbol
.
field_descriptor
(
)
;
if
(
!
field
)
continue
;
(
*
map
)
[
{
FindParentForFieldsByMap
(
field
)
field
-
>
lowercase_name
(
)
.
c_str
(
)
}
]
=
field
;
}
fields_by_lowercase_name_
.
store
(
map
std
:
:
memory_order_release
)
;
}
inline
const
FieldDescriptor
*
FileDescriptorTables
:
:
FindFieldByLowercaseName
(
const
void
*
parent
StringPiece
lowercase_name
)
const
{
internal
:
:
call_once
(
fields_by_lowercase_name_once_
&
FileDescriptorTables
:
:
FieldsByLowercaseNamesLazyInitStatic
this
)
;
return
FindPtrOrNull
(
*
fields_by_lowercase_name_
.
load
(
std
:
:
memory_order_acquire
)
PointerStringPair
(
parent
lowercase_name
)
)
;
}
void
FileDescriptorTables
:
:
FieldsByCamelcaseNamesLazyInitStatic
(
const
FileDescriptorTables
*
tables
)
{
tables
-
>
FieldsByCamelcaseNamesLazyInitInternal
(
)
;
}
void
FileDescriptorTables
:
:
FieldsByCamelcaseNamesLazyInitInternal
(
)
const
{
auto
*
map
=
new
FieldsByNameMap
;
for
(
Symbol
symbol
:
symbols_by_parent_
)
{
const
FieldDescriptor
*
field
=
symbol
.
field_descriptor
(
)
;
if
(
!
field
)
continue
;
(
*
map
)
[
{
FindParentForFieldsByMap
(
field
)
field
-
>
camelcase_name
(
)
.
c_str
(
)
}
]
=
field
;
}
fields_by_camelcase_name_
.
store
(
map
std
:
:
memory_order_release
)
;
}
inline
const
FieldDescriptor
*
FileDescriptorTables
:
:
FindFieldByCamelcaseName
(
const
void
*
parent
StringPiece
camelcase_name
)
const
{
internal
:
:
call_once
(
fields_by_camelcase_name_once_
FileDescriptorTables
:
:
FieldsByCamelcaseNamesLazyInitStatic
this
)
;
return
FindPtrOrNull
(
*
fields_by_camelcase_name_
.
load
(
std
:
:
memory_order_acquire
)
PointerStringPair
(
parent
camelcase_name
)
)
;
}
inline
const
EnumValueDescriptor
*
FileDescriptorTables
:
:
FindEnumValueByNumber
(
const
EnumDescriptor
*
parent
int
number
)
const
{
const
int
base
=
parent
-
>
value
(
0
)
-
>
number
(
)
;
if
(
base
<
=
number
&
&
number
<
=
static_cast
<
int64_t
>
(
base
)
+
parent
-
>
sequential_value_limit_
)
{
return
parent
-
>
value
(
number
-
base
)
;
}
Symbol
:
:
QueryKey
query
;
query
.
parent
=
parent
;
query
.
field_number
=
number
;
auto
it
=
enum_values_by_number_
.
find
(
query
)
;
return
it
=
=
enum_values_by_number_
.
end
(
)
?
nullptr
:
it
-
>
enum_value_descriptor
(
)
;
}
inline
const
EnumValueDescriptor
*
FileDescriptorTables
:
:
FindEnumValueByNumberCreatingIfUnknown
(
const
EnumDescriptor
*
parent
int
number
)
const
{
{
const
auto
*
value
=
FindEnumValueByNumber
(
parent
number
)
;
if
(
value
!
=
nullptr
)
{
return
value
;
}
}
Symbol
:
:
QueryKey
query
;
query
.
parent
=
parent
;
query
.
field_number
=
number
;
{
ReaderMutexLock
l
(
&
unknown_enum_values_mu_
)
;
auto
it
=
unknown_enum_values_by_number_
.
find
(
query
)
;
if
(
it
!
=
unknown_enum_values_by_number_
.
end
(
)
&
&
it
-
>
enum_value_descriptor
(
)
!
=
nullptr
)
{
return
it
-
>
enum_value_descriptor
(
)
;
}
}
{
WriterMutexLock
l
(
&
unknown_enum_values_mu_
)
;
auto
it
=
unknown_enum_values_by_number_
.
find
(
query
)
;
if
(
it
!
=
unknown_enum_values_by_number_
.
end
(
)
&
&
it
-
>
enum_value_descriptor
(
)
!
=
nullptr
)
{
return
it
-
>
enum_value_descriptor
(
)
;
}
std
:
:
string
enum_value_name
=
StringPrintf
(
"
UNKNOWN_ENUM_VALUE_
%
s_
%
d
"
parent
-
>
name
(
)
.
c_str
(
)
number
)
;
auto
*
pool
=
DescriptorPool
:
:
generated_pool
(
)
;
auto
*
tables
=
const_cast
<
DescriptorPool
:
:
Tables
*
>
(
pool
-
>
tables_
.
get
(
)
)
;
internal
:
:
FlatAllocator
alloc
;
alloc
.
PlanArray
<
EnumValueDescriptor
>
(
1
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
2
)
;
{
MutexLockMaybe
l2
(
pool
-
>
mutex_
)
;
alloc
.
FinalizePlanning
(
tables
)
;
}
EnumValueDescriptor
*
result
=
alloc
.
AllocateArray
<
EnumValueDescriptor
>
(
1
)
;
result
-
>
all_names_
=
alloc
.
AllocateStrings
(
enum_value_name
StrCat
(
parent
-
>
full_name
(
)
"
.
"
enum_value_name
)
)
;
result
-
>
number_
=
number
;
result
-
>
type_
=
parent
;
result
-
>
options_
=
&
EnumValueOptions
:
:
default_instance
(
)
;
unknown_enum_values_by_number_
.
insert
(
Symbol
:
:
EnumValue
(
result
0
)
)
;
return
result
;
}
}
inline
const
FieldDescriptor
*
DescriptorPool
:
:
Tables
:
:
FindExtension
(
const
Descriptor
*
extendee
int
number
)
const
{
return
FindPtrOrNull
(
extensions_
std
:
:
make_pair
(
extendee
number
)
)
;
}
inline
void
DescriptorPool
:
:
Tables
:
:
FindAllExtensions
(
const
Descriptor
*
extendee
std
:
:
vector
<
const
FieldDescriptor
*
>
*
out
)
const
{
ExtensionsGroupedByDescriptorMap
:
:
const_iterator
it
=
extensions_
.
lower_bound
(
std
:
:
make_pair
(
extendee
0
)
)
;
for
(
;
it
!
=
extensions_
.
end
(
)
&
&
it
-
>
first
.
first
=
=
extendee
;
+
+
it
)
{
out
-
>
push_back
(
it
-
>
second
)
;
}
}
bool
DescriptorPool
:
:
Tables
:
:
AddSymbol
(
const
std
:
:
string
&
full_name
Symbol
symbol
)
{
GOOGLE_DCHECK_EQ
(
full_name
symbol
.
full_name
(
)
)
;
if
(
symbols_by_name_
.
insert
(
symbol
)
.
second
)
{
symbols_after_checkpoint_
.
push_back
(
symbol
)
;
return
true
;
}
else
{
return
false
;
}
}
bool
FileDescriptorTables
:
:
AddAliasUnderParent
(
const
void
*
parent
const
std
:
:
string
&
name
Symbol
symbol
)
{
GOOGLE_DCHECK_EQ
(
name
symbol
.
parent_name_key
(
)
.
second
)
;
GOOGLE_DCHECK_EQ
(
parent
symbol
.
parent_name_key
(
)
.
first
)
;
return
symbols_by_parent_
.
insert
(
symbol
)
.
second
;
}
bool
DescriptorPool
:
:
Tables
:
:
AddFile
(
const
FileDescriptor
*
file
)
{
if
(
InsertIfNotPresent
(
&
files_by_name_
file
-
>
name
(
)
file
)
)
{
files_after_checkpoint_
.
push_back
(
file
)
;
return
true
;
}
else
{
return
false
;
}
}
void
FileDescriptorTables
:
:
FinalizeTables
(
)
{
}
bool
FileDescriptorTables
:
:
AddFieldByNumber
(
FieldDescriptor
*
field
)
{
if
(
field
-
>
containing_type
(
)
!
=
nullptr
&
&
field
-
>
number
(
)
>
=
1
&
&
field
-
>
number
(
)
<
=
field
-
>
containing_type
(
)
-
>
sequential_field_limit_
)
{
if
(
field
-
>
is_extension
(
)
)
{
return
false
;
}
return
field
-
>
containing_type
(
)
-
>
field
(
field
-
>
number
(
)
-
1
)
=
=
field
;
}
return
fields_by_number_
.
insert
(
Symbol
(
field
)
)
.
second
;
}
bool
FileDescriptorTables
:
:
AddEnumValueByNumber
(
EnumValueDescriptor
*
value
)
{
const
int
base
=
value
-
>
type
(
)
-
>
value
(
0
)
-
>
number
(
)
;
if
(
base
<
=
value
-
>
number
(
)
&
&
value
-
>
number
(
)
<
=
static_cast
<
int64_t
>
(
base
)
+
value
-
>
type
(
)
-
>
sequential_value_limit_
)
return
true
;
return
enum_values_by_number_
.
insert
(
Symbol
:
:
EnumValue
(
value
0
)
)
.
second
;
}
bool
DescriptorPool
:
:
Tables
:
:
AddExtension
(
const
FieldDescriptor
*
field
)
{
DescriptorIntPair
key
(
field
-
>
containing_type
(
)
field
-
>
number
(
)
)
;
if
(
InsertIfNotPresent
(
&
extensions_
key
field
)
)
{
extensions_after_checkpoint_
.
push_back
(
key
)
;
return
true
;
}
else
{
return
false
;
}
}
template
<
typename
Type
>
Type
*
DescriptorPool
:
:
Tables
:
:
Allocate
(
)
{
static_assert
(
std
:
:
is_trivially_destructible
<
Type
>
:
:
value
"
"
)
;
static_assert
(
alignof
(
Type
)
<
=
8
"
"
)
;
return
:
:
new
(
AllocateBytes
(
sizeof
(
Type
)
)
)
Type
{
}
;
}
void
*
DescriptorPool
:
:
Tables
:
:
AllocateBytes
(
int
size
)
{
if
(
size
=
=
0
)
return
nullptr
;
void
*
p
=
:
:
operator
new
(
size
+
RoundUpTo
<
8
>
(
sizeof
(
int
)
)
)
;
int
*
sizep
=
static_cast
<
int
*
>
(
p
)
;
misc_allocs_
.
emplace_back
(
sizep
)
;
*
sizep
=
size
;
return
static_cast
<
char
*
>
(
p
)
+
RoundUpTo
<
8
>
(
sizeof
(
int
)
)
;
}
template
<
typename
.
.
.
T
>
internal
:
:
FlatAllocator
:
:
Allocation
*
DescriptorPool
:
:
Tables
:
:
CreateFlatAlloc
(
const
TypeMap
<
IntT
T
.
.
.
>
&
sizes
)
{
auto
ends
=
CalculateEnds
(
sizes
)
;
using
FlatAlloc
=
internal
:
:
FlatAllocator
:
:
Allocation
;
int
last_end
=
ends
.
template
Get
<
typename
std
:
:
tuple_element
<
sizeof
.
.
.
(
T
)
-
1
std
:
:
tuple
<
T
.
.
.
>
>
:
:
type
>
(
)
;
size_t
total_size
=
last_end
+
RoundUpTo
<
FlatAlloc
:
:
kMaxAlign
>
(
sizeof
(
FlatAlloc
)
)
;
char
*
data
=
static_cast
<
char
*
>
(
:
:
operator
new
(
total_size
)
)
;
auto
*
res
=
:
:
new
(
data
)
FlatAlloc
(
ends
)
;
flat_allocs_
.
emplace_back
(
res
)
;
return
res
;
}
void
FileDescriptorTables
:
:
BuildLocationsByPath
(
std
:
:
pair
<
const
FileDescriptorTables
*
const
SourceCodeInfo
*
>
*
p
)
{
for
(
int
i
=
0
len
=
p
-
>
second
-
>
location_size
(
)
;
i
<
len
;
+
+
i
)
{
const
SourceCodeInfo_Location
*
loc
=
&
p
-
>
second
-
>
location
(
)
.
Get
(
i
)
;
p
-
>
first
-
>
locations_by_path_
[
Join
(
loc
-
>
path
(
)
"
"
)
]
=
loc
;
}
}
const
SourceCodeInfo_Location
*
FileDescriptorTables
:
:
GetSourceLocation
(
const
std
:
:
vector
<
int
>
&
path
const
SourceCodeInfo
*
info
)
const
{
std
:
:
pair
<
const
FileDescriptorTables
*
const
SourceCodeInfo
*
>
p
(
std
:
:
make_pair
(
this
info
)
)
;
internal
:
:
call_once
(
locations_by_path_once_
FileDescriptorTables
:
:
BuildLocationsByPath
&
p
)
;
return
FindPtrOrNull
(
locations_by_path_
Join
(
path
"
"
)
)
;
}
DescriptorPool
:
:
ErrorCollector
:
:
~
ErrorCollector
(
)
{
}
DescriptorPool
:
:
DescriptorPool
(
)
:
mutex_
(
nullptr
)
fallback_database_
(
nullptr
)
default_error_collector_
(
nullptr
)
underlay_
(
nullptr
)
tables_
(
new
Tables
)
enforce_dependencies_
(
true
)
lazily_build_dependencies_
(
false
)
allow_unknown_
(
false
)
enforce_weak_
(
false
)
disallow_enforce_utf8_
(
false
)
{
}
DescriptorPool
:
:
DescriptorPool
(
DescriptorDatabase
*
fallback_database
ErrorCollector
*
error_collector
)
:
mutex_
(
new
internal
:
:
WrappedMutex
)
fallback_database_
(
fallback_database
)
default_error_collector_
(
error_collector
)
underlay_
(
nullptr
)
tables_
(
new
Tables
)
enforce_dependencies_
(
true
)
lazily_build_dependencies_
(
false
)
allow_unknown_
(
false
)
enforce_weak_
(
false
)
disallow_enforce_utf8_
(
false
)
{
}
DescriptorPool
:
:
DescriptorPool
(
const
DescriptorPool
*
underlay
)
:
mutex_
(
nullptr
)
fallback_database_
(
nullptr
)
default_error_collector_
(
nullptr
)
underlay_
(
underlay
)
tables_
(
new
Tables
)
enforce_dependencies_
(
true
)
lazily_build_dependencies_
(
false
)
allow_unknown_
(
false
)
enforce_weak_
(
false
)
disallow_enforce_utf8_
(
false
)
{
}
DescriptorPool
:
:
~
DescriptorPool
(
)
{
if
(
mutex_
!
=
nullptr
)
delete
mutex_
;
}
void
DescriptorPool
:
:
InternalDontEnforceDependencies
(
)
{
enforce_dependencies_
=
false
;
}
void
DescriptorPool
:
:
AddUnusedImportTrackFile
(
ConstStringParam
file_name
bool
is_error
)
{
unused_import_track_files_
[
std
:
:
string
(
file_name
)
]
=
is_error
;
}
void
DescriptorPool
:
:
ClearUnusedImportTrackFiles
(
)
{
unused_import_track_files_
.
clear
(
)
;
}
bool
DescriptorPool
:
:
InternalIsFileLoaded
(
ConstStringParam
filename
)
const
{
MutexLockMaybe
lock
(
mutex_
)
;
return
tables_
-
>
FindFile
(
filename
)
!
=
nullptr
;
}
namespace
{
EncodedDescriptorDatabase
*
GeneratedDatabase
(
)
{
static
auto
generated_database
=
internal
:
:
OnShutdownDelete
(
new
EncodedDescriptorDatabase
(
)
)
;
return
generated_database
;
}
DescriptorPool
*
NewGeneratedPool
(
)
{
auto
generated_pool
=
new
DescriptorPool
(
GeneratedDatabase
(
)
)
;
generated_pool
-
>
InternalSetLazilyBuildDependencies
(
)
;
return
generated_pool
;
}
}
DescriptorDatabase
*
DescriptorPool
:
:
internal_generated_database
(
)
{
return
GeneratedDatabase
(
)
;
}
DescriptorPool
*
DescriptorPool
:
:
internal_generated_pool
(
)
{
static
DescriptorPool
*
generated_pool
=
internal
:
:
OnShutdownDelete
(
NewGeneratedPool
(
)
)
;
return
generated_pool
;
}
const
DescriptorPool
*
DescriptorPool
:
:
generated_pool
(
)
{
const
DescriptorPool
*
pool
=
internal_generated_pool
(
)
;
DescriptorProto
:
:
descriptor
(
)
;
return
pool
;
}
void
DescriptorPool
:
:
InternalAddGeneratedFile
(
const
void
*
encoded_file_descriptor
int
size
)
{
GOOGLE_CHECK
(
GeneratedDatabase
(
)
-
>
Add
(
encoded_file_descriptor
size
)
)
;
}
const
FileDescriptor
*
DescriptorPool
:
:
FindFileByName
(
ConstStringParam
name
)
const
{
MutexLockMaybe
lock
(
mutex_
)
;
if
(
fallback_database_
!
=
nullptr
)
{
tables_
-
>
known_bad_symbols_
.
clear
(
)
;
tables_
-
>
known_bad_files_
.
clear
(
)
;
}
const
FileDescriptor
*
result
=
tables_
-
>
FindFile
(
name
)
;
if
(
result
!
=
nullptr
)
return
result
;
if
(
underlay_
!
=
nullptr
)
{
result
=
underlay_
-
>
FindFileByName
(
name
)
;
if
(
result
!
=
nullptr
)
return
result
;
}
if
(
TryFindFileInFallbackDatabase
(
name
)
)
{
result
=
tables_
-
>
FindFile
(
name
)
;
if
(
result
!
=
nullptr
)
return
result
;
}
return
nullptr
;
}
const
FileDescriptor
*
DescriptorPool
:
:
FindFileContainingSymbol
(
ConstStringParam
symbol_name
)
const
{
MutexLockMaybe
lock
(
mutex_
)
;
if
(
fallback_database_
!
=
nullptr
)
{
tables_
-
>
known_bad_symbols_
.
clear
(
)
;
tables_
-
>
known_bad_files_
.
clear
(
)
;
}
Symbol
result
=
tables_
-
>
FindSymbol
(
symbol_name
)
;
if
(
!
result
.
IsNull
(
)
)
return
result
.
GetFile
(
)
;
if
(
underlay_
!
=
nullptr
)
{
const
FileDescriptor
*
file_result
=
underlay_
-
>
FindFileContainingSymbol
(
symbol_name
)
;
if
(
file_result
!
=
nullptr
)
return
file_result
;
}
if
(
TryFindSymbolInFallbackDatabase
(
symbol_name
)
)
{
result
=
tables_
-
>
FindSymbol
(
symbol_name
)
;
if
(
!
result
.
IsNull
(
)
)
return
result
.
GetFile
(
)
;
}
return
nullptr
;
}
const
Descriptor
*
DescriptorPool
:
:
FindMessageTypeByName
(
ConstStringParam
name
)
const
{
return
tables_
-
>
FindByNameHelper
(
this
name
)
.
descriptor
(
)
;
}
const
FieldDescriptor
*
DescriptorPool
:
:
FindFieldByName
(
ConstStringParam
name
)
const
{
if
(
const
FieldDescriptor
*
field
=
tables_
-
>
FindByNameHelper
(
this
name
)
.
field_descriptor
(
)
)
{
if
(
!
field
-
>
is_extension
(
)
)
{
return
field
;
}
}
return
nullptr
;
}
const
FieldDescriptor
*
DescriptorPool
:
:
FindExtensionByName
(
ConstStringParam
name
)
const
{
if
(
const
FieldDescriptor
*
field
=
tables_
-
>
FindByNameHelper
(
this
name
)
.
field_descriptor
(
)
)
{
if
(
field
-
>
is_extension
(
)
)
{
return
field
;
}
}
return
nullptr
;
}
const
OneofDescriptor
*
DescriptorPool
:
:
FindOneofByName
(
ConstStringParam
name
)
const
{
return
tables_
-
>
FindByNameHelper
(
this
name
)
.
oneof_descriptor
(
)
;
}
const
EnumDescriptor
*
DescriptorPool
:
:
FindEnumTypeByName
(
ConstStringParam
name
)
const
{
return
tables_
-
>
FindByNameHelper
(
this
name
)
.
enum_descriptor
(
)
;
}
const
EnumValueDescriptor
*
DescriptorPool
:
:
FindEnumValueByName
(
ConstStringParam
name
)
const
{
return
tables_
-
>
FindByNameHelper
(
this
name
)
.
enum_value_descriptor
(
)
;
}
const
ServiceDescriptor
*
DescriptorPool
:
:
FindServiceByName
(
ConstStringParam
name
)
const
{
return
tables_
-
>
FindByNameHelper
(
this
name
)
.
service_descriptor
(
)
;
}
const
MethodDescriptor
*
DescriptorPool
:
:
FindMethodByName
(
ConstStringParam
name
)
const
{
return
tables_
-
>
FindByNameHelper
(
this
name
)
.
method_descriptor
(
)
;
}
const
FieldDescriptor
*
DescriptorPool
:
:
FindExtensionByNumber
(
const
Descriptor
*
extendee
int
number
)
const
{
if
(
extendee
-
>
extension_range_count
(
)
=
=
0
)
return
nullptr
;
if
(
mutex_
!
=
nullptr
)
{
ReaderMutexLock
lock
(
mutex_
)
;
const
FieldDescriptor
*
result
=
tables_
-
>
FindExtension
(
extendee
number
)
;
if
(
result
!
=
nullptr
)
{
return
result
;
}
}
MutexLockMaybe
lock
(
mutex_
)
;
if
(
fallback_database_
!
=
nullptr
)
{
tables_
-
>
known_bad_symbols_
.
clear
(
)
;
tables_
-
>
known_bad_files_
.
clear
(
)
;
}
const
FieldDescriptor
*
result
=
tables_
-
>
FindExtension
(
extendee
number
)
;
if
(
result
!
=
nullptr
)
{
return
result
;
}
if
(
underlay_
!
=
nullptr
)
{
result
=
underlay_
-
>
FindExtensionByNumber
(
extendee
number
)
;
if
(
result
!
=
nullptr
)
return
result
;
}
if
(
TryFindExtensionInFallbackDatabase
(
extendee
number
)
)
{
result
=
tables_
-
>
FindExtension
(
extendee
number
)
;
if
(
result
!
=
nullptr
)
{
return
result
;
}
}
return
nullptr
;
}
const
FieldDescriptor
*
DescriptorPool
:
:
InternalFindExtensionByNumberNoLock
(
const
Descriptor
*
extendee
int
number
)
const
{
if
(
extendee
-
>
extension_range_count
(
)
=
=
0
)
return
nullptr
;
const
FieldDescriptor
*
result
=
tables_
-
>
FindExtension
(
extendee
number
)
;
if
(
result
!
=
nullptr
)
{
return
result
;
}
if
(
underlay_
!
=
nullptr
)
{
result
=
underlay_
-
>
InternalFindExtensionByNumberNoLock
(
extendee
number
)
;
if
(
result
!
=
nullptr
)
return
result
;
}
return
nullptr
;
}
const
FieldDescriptor
*
DescriptorPool
:
:
FindExtensionByPrintableName
(
const
Descriptor
*
extendee
ConstStringParam
printable_name
)
const
{
if
(
extendee
-
>
extension_range_count
(
)
=
=
0
)
return
nullptr
;
const
FieldDescriptor
*
result
=
FindExtensionByName
(
printable_name
)
;
if
(
result
!
=
nullptr
&
&
result
-
>
containing_type
(
)
=
=
extendee
)
{
return
result
;
}
if
(
extendee
-
>
options
(
)
.
message_set_wire_format
(
)
)
{
const
Descriptor
*
type
=
FindMessageTypeByName
(
printable_name
)
;
if
(
type
!
=
nullptr
)
{
const
int
type_extension_count
=
type
-
>
extension_count
(
)
;
for
(
int
i
=
0
;
i
<
type_extension_count
;
i
+
+
)
{
const
FieldDescriptor
*
extension
=
type
-
>
extension
(
i
)
;
if
(
extension
-
>
containing_type
(
)
=
=
extendee
&
&
extension
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_MESSAGE
&
&
extension
-
>
is_optional
(
)
&
&
extension
-
>
message_type
(
)
=
=
type
)
{
return
extension
;
}
}
}
}
return
nullptr
;
}
void
DescriptorPool
:
:
FindAllExtensions
(
const
Descriptor
*
extendee
std
:
:
vector
<
const
FieldDescriptor
*
>
*
out
)
const
{
MutexLockMaybe
lock
(
mutex_
)
;
if
(
fallback_database_
!
=
nullptr
)
{
tables_
-
>
known_bad_symbols_
.
clear
(
)
;
tables_
-
>
known_bad_files_
.
clear
(
)
;
}
if
(
fallback_database_
!
=
nullptr
&
&
tables_
-
>
extensions_loaded_from_db_
.
count
(
extendee
)
=
=
0
)
{
std
:
:
vector
<
int
>
numbers
;
if
(
fallback_database_
-
>
FindAllExtensionNumbers
(
extendee
-
>
full_name
(
)
&
numbers
)
)
{
for
(
int
number
:
numbers
)
{
if
(
tables_
-
>
FindExtension
(
extendee
number
)
=
=
nullptr
)
{
TryFindExtensionInFallbackDatabase
(
extendee
number
)
;
}
}
tables_
-
>
extensions_loaded_from_db_
.
insert
(
extendee
)
;
}
}
tables_
-
>
FindAllExtensions
(
extendee
out
)
;
if
(
underlay_
!
=
nullptr
)
{
underlay_
-
>
FindAllExtensions
(
extendee
out
)
;
}
}
const
FieldDescriptor
*
Descriptor
:
:
FindFieldByNumber
(
int
key
)
const
{
const
FieldDescriptor
*
result
=
file
(
)
-
>
tables_
-
>
FindFieldByNumber
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
const
FieldDescriptor
*
Descriptor
:
:
FindFieldByLowercaseName
(
ConstStringParam
key
)
const
{
const
FieldDescriptor
*
result
=
file
(
)
-
>
tables_
-
>
FindFieldByLowercaseName
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
const
FieldDescriptor
*
Descriptor
:
:
FindFieldByCamelcaseName
(
ConstStringParam
key
)
const
{
const
FieldDescriptor
*
result
=
file
(
)
-
>
tables_
-
>
FindFieldByCamelcaseName
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
const
FieldDescriptor
*
Descriptor
:
:
FindFieldByName
(
ConstStringParam
key
)
const
{
const
FieldDescriptor
*
field
=
file
(
)
-
>
tables_
-
>
FindNestedSymbol
(
this
key
)
.
field_descriptor
(
)
;
return
field
!
=
nullptr
&
&
!
field
-
>
is_extension
(
)
?
field
:
nullptr
;
}
const
OneofDescriptor
*
Descriptor
:
:
FindOneofByName
(
ConstStringParam
key
)
const
{
return
file
(
)
-
>
tables_
-
>
FindNestedSymbol
(
this
key
)
.
oneof_descriptor
(
)
;
}
const
FieldDescriptor
*
Descriptor
:
:
FindExtensionByName
(
ConstStringParam
key
)
const
{
const
FieldDescriptor
*
field
=
file
(
)
-
>
tables_
-
>
FindNestedSymbol
(
this
key
)
.
field_descriptor
(
)
;
return
field
!
=
nullptr
&
&
field
-
>
is_extension
(
)
?
field
:
nullptr
;
}
const
FieldDescriptor
*
Descriptor
:
:
FindExtensionByLowercaseName
(
ConstStringParam
key
)
const
{
const
FieldDescriptor
*
result
=
file
(
)
-
>
tables_
-
>
FindFieldByLowercaseName
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
!
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
const
FieldDescriptor
*
Descriptor
:
:
FindExtensionByCamelcaseName
(
ConstStringParam
key
)
const
{
const
FieldDescriptor
*
result
=
file
(
)
-
>
tables_
-
>
FindFieldByCamelcaseName
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
!
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
const
Descriptor
*
Descriptor
:
:
FindNestedTypeByName
(
ConstStringParam
key
)
const
{
return
file
(
)
-
>
tables_
-
>
FindNestedSymbol
(
this
key
)
.
descriptor
(
)
;
}
const
EnumDescriptor
*
Descriptor
:
:
FindEnumTypeByName
(
ConstStringParam
key
)
const
{
return
file
(
)
-
>
tables_
-
>
FindNestedSymbol
(
this
key
)
.
enum_descriptor
(
)
;
}
const
EnumValueDescriptor
*
Descriptor
:
:
FindEnumValueByName
(
ConstStringParam
key
)
const
{
return
file
(
)
-
>
tables_
-
>
FindNestedSymbol
(
this
key
)
.
enum_value_descriptor
(
)
;
}
const
FieldDescriptor
*
Descriptor
:
:
map_key
(
)
const
{
if
(
!
options
(
)
.
map_entry
(
)
)
return
nullptr
;
GOOGLE_DCHECK_EQ
(
field_count
(
)
2
)
;
return
field
(
0
)
;
}
const
FieldDescriptor
*
Descriptor
:
:
map_value
(
)
const
{
if
(
!
options
(
)
.
map_entry
(
)
)
return
nullptr
;
GOOGLE_DCHECK_EQ
(
field_count
(
)
2
)
;
return
field
(
1
)
;
}
const
EnumValueDescriptor
*
EnumDescriptor
:
:
FindValueByName
(
ConstStringParam
key
)
const
{
return
file
(
)
-
>
tables_
-
>
FindNestedSymbol
(
this
key
)
.
enum_value_descriptor
(
)
;
}
const
EnumValueDescriptor
*
EnumDescriptor
:
:
FindValueByNumber
(
int
key
)
const
{
return
file
(
)
-
>
tables_
-
>
FindEnumValueByNumber
(
this
key
)
;
}
const
EnumValueDescriptor
*
EnumDescriptor
:
:
FindValueByNumberCreatingIfUnknown
(
int
key
)
const
{
return
file
(
)
-
>
tables_
-
>
FindEnumValueByNumberCreatingIfUnknown
(
this
key
)
;
}
const
MethodDescriptor
*
ServiceDescriptor
:
:
FindMethodByName
(
ConstStringParam
key
)
const
{
return
file
(
)
-
>
tables_
-
>
FindNestedSymbol
(
this
key
)
.
method_descriptor
(
)
;
}
const
Descriptor
*
FileDescriptor
:
:
FindMessageTypeByName
(
ConstStringParam
key
)
const
{
return
tables_
-
>
FindNestedSymbol
(
this
key
)
.
descriptor
(
)
;
}
const
EnumDescriptor
*
FileDescriptor
:
:
FindEnumTypeByName
(
ConstStringParam
key
)
const
{
return
tables_
-
>
FindNestedSymbol
(
this
key
)
.
enum_descriptor
(
)
;
}
const
EnumValueDescriptor
*
FileDescriptor
:
:
FindEnumValueByName
(
ConstStringParam
key
)
const
{
return
tables_
-
>
FindNestedSymbol
(
this
key
)
.
enum_value_descriptor
(
)
;
}
const
ServiceDescriptor
*
FileDescriptor
:
:
FindServiceByName
(
ConstStringParam
key
)
const
{
return
tables_
-
>
FindNestedSymbol
(
this
key
)
.
service_descriptor
(
)
;
}
const
FieldDescriptor
*
FileDescriptor
:
:
FindExtensionByName
(
ConstStringParam
key
)
const
{
const
FieldDescriptor
*
field
=
tables_
-
>
FindNestedSymbol
(
this
key
)
.
field_descriptor
(
)
;
return
field
!
=
nullptr
&
&
field
-
>
is_extension
(
)
?
field
:
nullptr
;
}
const
FieldDescriptor
*
FileDescriptor
:
:
FindExtensionByLowercaseName
(
ConstStringParam
key
)
const
{
const
FieldDescriptor
*
result
=
tables_
-
>
FindFieldByLowercaseName
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
!
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
const
FieldDescriptor
*
FileDescriptor
:
:
FindExtensionByCamelcaseName
(
ConstStringParam
key
)
const
{
const
FieldDescriptor
*
result
=
tables_
-
>
FindFieldByCamelcaseName
(
this
key
)
;
if
(
result
=
=
nullptr
|
|
!
result
-
>
is_extension
(
)
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
void
Descriptor
:
:
ExtensionRange
:
:
CopyTo
(
DescriptorProto_ExtensionRange
*
proto
)
const
{
proto
-
>
set_start
(
this
-
>
start
)
;
proto
-
>
set_end
(
this
-
>
end
)
;
if
(
options_
!
=
&
ExtensionRangeOptions
:
:
default_instance
(
)
)
{
*
proto
-
>
mutable_options
(
)
=
*
options_
;
}
}
const
Descriptor
:
:
ExtensionRange
*
Descriptor
:
:
FindExtensionRangeContainingNumber
(
int
number
)
const
{
for
(
int
i
=
0
;
i
<
extension_range_count
(
)
;
i
+
+
)
{
if
(
number
>
=
extension_range
(
i
)
-
>
start
&
&
number
<
extension_range
(
i
)
-
>
end
)
{
return
extension_range
(
i
)
;
}
}
return
nullptr
;
}
const
Descriptor
:
:
ReservedRange
*
Descriptor
:
:
FindReservedRangeContainingNumber
(
int
number
)
const
{
for
(
int
i
=
0
;
i
<
reserved_range_count
(
)
;
i
+
+
)
{
if
(
number
>
=
reserved_range
(
i
)
-
>
start
&
&
number
<
reserved_range
(
i
)
-
>
end
)
{
return
reserved_range
(
i
)
;
}
}
return
nullptr
;
}
const
EnumDescriptor
:
:
ReservedRange
*
EnumDescriptor
:
:
FindReservedRangeContainingNumber
(
int
number
)
const
{
for
(
int
i
=
0
;
i
<
reserved_range_count
(
)
;
i
+
+
)
{
if
(
number
>
=
reserved_range
(
i
)
-
>
start
&
&
number
<
=
reserved_range
(
i
)
-
>
end
)
{
return
reserved_range
(
i
)
;
}
}
return
nullptr
;
}
bool
DescriptorPool
:
:
TryFindFileInFallbackDatabase
(
StringPiece
name
)
const
{
if
(
fallback_database_
=
=
nullptr
)
return
false
;
auto
name_string
=
std
:
:
string
(
name
)
;
if
(
tables_
-
>
known_bad_files_
.
count
(
name_string
)
>
0
)
return
false
;
FileDescriptorProto
file_proto
;
if
(
!
fallback_database_
-
>
FindFileByName
(
name_string
&
file_proto
)
|
|
BuildFileFromDatabase
(
file_proto
)
=
=
nullptr
)
{
tables_
-
>
known_bad_files_
.
insert
(
std
:
:
move
(
name_string
)
)
;
return
false
;
}
return
true
;
}
bool
DescriptorPool
:
:
IsSubSymbolOfBuiltType
(
StringPiece
name
)
const
{
auto
prefix
=
std
:
:
string
(
name
)
;
for
(
;
;
)
{
std
:
:
string
:
:
size_type
dot_pos
=
prefix
.
find_last_of
(
'
.
'
)
;
if
(
dot_pos
=
=
std
:
:
string
:
:
npos
)
{
break
;
}
prefix
=
prefix
.
substr
(
0
dot_pos
)
;
Symbol
symbol
=
tables_
-
>
FindSymbol
(
prefix
)
;
if
(
!
symbol
.
IsNull
(
)
&
&
!
symbol
.
IsPackage
(
)
)
{
return
true
;
}
}
if
(
underlay_
!
=
nullptr
)
{
return
underlay_
-
>
IsSubSymbolOfBuiltType
(
name
)
;
}
return
false
;
}
bool
DescriptorPool
:
:
TryFindSymbolInFallbackDatabase
(
StringPiece
name
)
const
{
if
(
fallback_database_
=
=
nullptr
)
return
false
;
auto
name_string
=
std
:
:
string
(
name
)
;
if
(
tables_
-
>
known_bad_symbols_
.
count
(
name_string
)
>
0
)
return
false
;
FileDescriptorProto
file_proto
;
if
(
IsSubSymbolOfBuiltType
(
name
)
|
|
!
fallback_database_
-
>
FindFileContainingSymbol
(
name_string
&
file_proto
)
|
|
tables_
-
>
FindFile
(
file_proto
.
name
(
)
)
!
=
nullptr
|
|
BuildFileFromDatabase
(
file_proto
)
=
=
nullptr
)
{
tables_
-
>
known_bad_symbols_
.
insert
(
std
:
:
move
(
name_string
)
)
;
return
false
;
}
return
true
;
}
bool
DescriptorPool
:
:
TryFindExtensionInFallbackDatabase
(
const
Descriptor
*
containing_type
int
field_number
)
const
{
if
(
fallback_database_
=
=
nullptr
)
return
false
;
FileDescriptorProto
file_proto
;
if
(
!
fallback_database_
-
>
FindFileContainingExtension
(
containing_type
-
>
full_name
(
)
field_number
&
file_proto
)
)
{
return
false
;
}
if
(
tables_
-
>
FindFile
(
file_proto
.
name
(
)
)
!
=
nullptr
)
{
return
false
;
}
if
(
BuildFileFromDatabase
(
file_proto
)
=
=
nullptr
)
{
return
false
;
}
return
true
;
}
bool
FieldDescriptor
:
:
is_map_message_type
(
)
const
{
return
type_descriptor_
.
message_type
-
>
options
(
)
.
map_entry
(
)
;
}
std
:
:
string
FieldDescriptor
:
:
DefaultValueAsString
(
bool
quote_string_type
)
const
{
GOOGLE_CHECK
(
has_default_value
(
)
)
<
<
"
No
default
value
"
;
switch
(
cpp_type
(
)
)
{
case
CPPTYPE_INT32
:
return
StrCat
(
default_value_int32_t
(
)
)
;
case
CPPTYPE_INT64
:
return
StrCat
(
default_value_int64_t
(
)
)
;
case
CPPTYPE_UINT32
:
return
StrCat
(
default_value_uint32_t
(
)
)
;
case
CPPTYPE_UINT64
:
return
StrCat
(
default_value_uint64_t
(
)
)
;
case
CPPTYPE_FLOAT
:
return
SimpleFtoa
(
default_value_float
(
)
)
;
case
CPPTYPE_DOUBLE
:
return
SimpleDtoa
(
default_value_double
(
)
)
;
case
CPPTYPE_BOOL
:
return
default_value_bool
(
)
?
"
true
"
:
"
false
"
;
case
CPPTYPE_STRING
:
if
(
quote_string_type
)
{
return
"
\
"
"
+
CEscape
(
default_value_string
(
)
)
+
"
\
"
"
;
}
else
{
if
(
type
(
)
=
=
TYPE_BYTES
)
{
return
CEscape
(
default_value_string
(
)
)
;
}
else
{
return
default_value_string
(
)
;
}
}
case
CPPTYPE_ENUM
:
return
default_value_enum
(
)
-
>
name
(
)
;
case
CPPTYPE_MESSAGE
:
GOOGLE_LOG
(
DFATAL
)
<
<
"
Messages
can
'
t
have
default
values
!
"
;
break
;
}
GOOGLE_LOG
(
FATAL
)
<
<
"
Can
'
t
get
here
:
failed
to
get
default
value
as
string
"
;
return
"
"
;
}
void
FileDescriptor
:
:
CopyTo
(
FileDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
if
(
!
package
(
)
.
empty
(
)
)
proto
-
>
set_package
(
package
(
)
)
;
if
(
syntax
(
)
=
=
SYNTAX_PROTO3
)
proto
-
>
set_syntax
(
SyntaxName
(
syntax
(
)
)
)
;
for
(
int
i
=
0
;
i
<
dependency_count
(
)
;
i
+
+
)
{
proto
-
>
add_dependency
(
dependency
(
i
)
-
>
name
(
)
)
;
}
for
(
int
i
=
0
;
i
<
public_dependency_count
(
)
;
i
+
+
)
{
proto
-
>
add_public_dependency
(
public_dependencies_
[
i
]
)
;
}
for
(
int
i
=
0
;
i
<
weak_dependency_count
(
)
;
i
+
+
)
{
proto
-
>
add_weak_dependency
(
weak_dependencies_
[
i
]
)
;
}
for
(
int
i
=
0
;
i
<
message_type_count
(
)
;
i
+
+
)
{
message_type
(
i
)
-
>
CopyTo
(
proto
-
>
add_message_type
(
)
)
;
}
for
(
int
i
=
0
;
i
<
enum_type_count
(
)
;
i
+
+
)
{
enum_type
(
i
)
-
>
CopyTo
(
proto
-
>
add_enum_type
(
)
)
;
}
for
(
int
i
=
0
;
i
<
service_count
(
)
;
i
+
+
)
{
service
(
i
)
-
>
CopyTo
(
proto
-
>
add_service
(
)
)
;
}
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
extension
(
i
)
-
>
CopyTo
(
proto
-
>
add_extension
(
)
)
;
}
if
(
&
options
(
)
!
=
&
FileOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
FileDescriptor
:
:
CopyJsonNameTo
(
FileDescriptorProto
*
proto
)
const
{
if
(
message_type_count
(
)
!
=
proto
-
>
message_type_size
(
)
|
|
extension_count
(
)
!
=
proto
-
>
extension_size
(
)
)
{
GOOGLE_LOG
(
ERROR
)
<
<
"
Cannot
copy
json_name
to
a
proto
of
a
different
size
.
"
;
return
;
}
for
(
int
i
=
0
;
i
<
message_type_count
(
)
;
i
+
+
)
{
message_type
(
i
)
-
>
CopyJsonNameTo
(
proto
-
>
mutable_message_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
extension
(
i
)
-
>
CopyJsonNameTo
(
proto
-
>
mutable_extension
(
i
)
)
;
}
}
void
FileDescriptor
:
:
CopySourceCodeInfoTo
(
FileDescriptorProto
*
proto
)
const
{
if
(
source_code_info_
&
&
source_code_info_
!
=
&
SourceCodeInfo
:
:
default_instance
(
)
)
{
proto
-
>
mutable_source_code_info
(
)
-
>
CopyFrom
(
*
source_code_info_
)
;
}
}
void
Descriptor
:
:
CopyTo
(
DescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
for
(
int
i
=
0
;
i
<
field_count
(
)
;
i
+
+
)
{
field
(
i
)
-
>
CopyTo
(
proto
-
>
add_field
(
)
)
;
}
for
(
int
i
=
0
;
i
<
oneof_decl_count
(
)
;
i
+
+
)
{
oneof_decl
(
i
)
-
>
CopyTo
(
proto
-
>
add_oneof_decl
(
)
)
;
}
for
(
int
i
=
0
;
i
<
nested_type_count
(
)
;
i
+
+
)
{
nested_type
(
i
)
-
>
CopyTo
(
proto
-
>
add_nested_type
(
)
)
;
}
for
(
int
i
=
0
;
i
<
enum_type_count
(
)
;
i
+
+
)
{
enum_type
(
i
)
-
>
CopyTo
(
proto
-
>
add_enum_type
(
)
)
;
}
for
(
int
i
=
0
;
i
<
extension_range_count
(
)
;
i
+
+
)
{
extension_range
(
i
)
-
>
CopyTo
(
proto
-
>
add_extension_range
(
)
)
;
}
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
extension
(
i
)
-
>
CopyTo
(
proto
-
>
add_extension
(
)
)
;
}
for
(
int
i
=
0
;
i
<
reserved_range_count
(
)
;
i
+
+
)
{
DescriptorProto
:
:
ReservedRange
*
range
=
proto
-
>
add_reserved_range
(
)
;
range
-
>
set_start
(
reserved_range
(
i
)
-
>
start
)
;
range
-
>
set_end
(
reserved_range
(
i
)
-
>
end
)
;
}
for
(
int
i
=
0
;
i
<
reserved_name_count
(
)
;
i
+
+
)
{
proto
-
>
add_reserved_name
(
reserved_name
(
i
)
)
;
}
if
(
&
options
(
)
!
=
&
MessageOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
Descriptor
:
:
CopyJsonNameTo
(
DescriptorProto
*
proto
)
const
{
if
(
field_count
(
)
!
=
proto
-
>
field_size
(
)
|
|
nested_type_count
(
)
!
=
proto
-
>
nested_type_size
(
)
|
|
extension_count
(
)
!
=
proto
-
>
extension_size
(
)
)
{
GOOGLE_LOG
(
ERROR
)
<
<
"
Cannot
copy
json_name
to
a
proto
of
a
different
size
.
"
;
return
;
}
for
(
int
i
=
0
;
i
<
field_count
(
)
;
i
+
+
)
{
field
(
i
)
-
>
CopyJsonNameTo
(
proto
-
>
mutable_field
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
nested_type_count
(
)
;
i
+
+
)
{
nested_type
(
i
)
-
>
CopyJsonNameTo
(
proto
-
>
mutable_nested_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
extension
(
i
)
-
>
CopyJsonNameTo
(
proto
-
>
mutable_extension
(
i
)
)
;
}
}
void
FieldDescriptor
:
:
CopyTo
(
FieldDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
proto
-
>
set_number
(
number
(
)
)
;
if
(
has_json_name_
)
{
proto
-
>
set_json_name
(
json_name
(
)
)
;
}
if
(
proto3_optional_
)
{
proto
-
>
set_proto3_optional
(
true
)
;
}
proto
-
>
set_label
(
static_cast
<
FieldDescriptorProto
:
:
Label
>
(
implicit_cast
<
int
>
(
label
(
)
)
)
)
;
proto
-
>
set_type
(
static_cast
<
FieldDescriptorProto
:
:
Type
>
(
implicit_cast
<
int
>
(
type
(
)
)
)
)
;
if
(
is_extension
(
)
)
{
if
(
!
containing_type
(
)
-
>
is_unqualified_placeholder_
)
{
proto
-
>
set_extendee
(
"
.
"
)
;
}
proto
-
>
mutable_extendee
(
)
-
>
append
(
containing_type
(
)
-
>
full_name
(
)
)
;
}
if
(
cpp_type
(
)
=
=
CPPTYPE_MESSAGE
)
{
if
(
message_type
(
)
-
>
is_placeholder_
)
{
proto
-
>
clear_type
(
)
;
}
if
(
!
message_type
(
)
-
>
is_unqualified_placeholder_
)
{
proto
-
>
set_type_name
(
"
.
"
)
;
}
proto
-
>
mutable_type_name
(
)
-
>
append
(
message_type
(
)
-
>
full_name
(
)
)
;
}
else
if
(
cpp_type
(
)
=
=
CPPTYPE_ENUM
)
{
if
(
!
enum_type
(
)
-
>
is_unqualified_placeholder_
)
{
proto
-
>
set_type_name
(
"
.
"
)
;
}
proto
-
>
mutable_type_name
(
)
-
>
append
(
enum_type
(
)
-
>
full_name
(
)
)
;
}
if
(
has_default_value
(
)
)
{
proto
-
>
set_default_value
(
DefaultValueAsString
(
false
)
)
;
}
if
(
containing_oneof
(
)
!
=
nullptr
&
&
!
is_extension
(
)
)
{
proto
-
>
set_oneof_index
(
containing_oneof
(
)
-
>
index
(
)
)
;
}
if
(
&
options
(
)
!
=
&
FieldOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
FieldDescriptor
:
:
CopyJsonNameTo
(
FieldDescriptorProto
*
proto
)
const
{
proto
-
>
set_json_name
(
json_name
(
)
)
;
}
void
OneofDescriptor
:
:
CopyTo
(
OneofDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
if
(
&
options
(
)
!
=
&
OneofOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
EnumDescriptor
:
:
CopyTo
(
EnumDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
for
(
int
i
=
0
;
i
<
value_count
(
)
;
i
+
+
)
{
value
(
i
)
-
>
CopyTo
(
proto
-
>
add_value
(
)
)
;
}
for
(
int
i
=
0
;
i
<
reserved_range_count
(
)
;
i
+
+
)
{
EnumDescriptorProto
:
:
EnumReservedRange
*
range
=
proto
-
>
add_reserved_range
(
)
;
range
-
>
set_start
(
reserved_range
(
i
)
-
>
start
)
;
range
-
>
set_end
(
reserved_range
(
i
)
-
>
end
)
;
}
for
(
int
i
=
0
;
i
<
reserved_name_count
(
)
;
i
+
+
)
{
proto
-
>
add_reserved_name
(
reserved_name
(
i
)
)
;
}
if
(
&
options
(
)
!
=
&
EnumOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
EnumValueDescriptor
:
:
CopyTo
(
EnumValueDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
proto
-
>
set_number
(
number
(
)
)
;
if
(
&
options
(
)
!
=
&
EnumValueOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
ServiceDescriptor
:
:
CopyTo
(
ServiceDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
for
(
int
i
=
0
;
i
<
method_count
(
)
;
i
+
+
)
{
method
(
i
)
-
>
CopyTo
(
proto
-
>
add_method
(
)
)
;
}
if
(
&
options
(
)
!
=
&
ServiceOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
}
void
MethodDescriptor
:
:
CopyTo
(
MethodDescriptorProto
*
proto
)
const
{
proto
-
>
set_name
(
name
(
)
)
;
if
(
!
input_type
(
)
-
>
is_unqualified_placeholder_
)
{
proto
-
>
set_input_type
(
"
.
"
)
;
}
proto
-
>
mutable_input_type
(
)
-
>
append
(
input_type
(
)
-
>
full_name
(
)
)
;
if
(
!
output_type
(
)
-
>
is_unqualified_placeholder_
)
{
proto
-
>
set_output_type
(
"
.
"
)
;
}
proto
-
>
mutable_output_type
(
)
-
>
append
(
output_type
(
)
-
>
full_name
(
)
)
;
if
(
&
options
(
)
!
=
&
MethodOptions
:
:
default_instance
(
)
)
{
proto
-
>
mutable_options
(
)
-
>
CopyFrom
(
options
(
)
)
;
}
if
(
client_streaming_
)
{
proto
-
>
set_client_streaming
(
true
)
;
}
if
(
server_streaming_
)
{
proto
-
>
set_server_streaming
(
true
)
;
}
}
namespace
{
bool
RetrieveOptionsAssumingRightPool
(
int
depth
const
Message
&
options
std
:
:
vector
<
std
:
:
string
>
*
option_entries
)
{
option_entries
-
>
clear
(
)
;
const
Reflection
*
reflection
=
options
.
GetReflection
(
)
;
std
:
:
vector
<
const
FieldDescriptor
*
>
fields
;
reflection
-
>
ListFields
(
options
&
fields
)
;
for
(
const
FieldDescriptor
*
field
:
fields
)
{
int
count
=
1
;
bool
repeated
=
false
;
if
(
field
-
>
is_repeated
(
)
)
{
count
=
reflection
-
>
FieldSize
(
options
field
)
;
repeated
=
true
;
}
for
(
int
j
=
0
;
j
<
count
;
j
+
+
)
{
std
:
:
string
fieldval
;
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
std
:
:
string
tmp
;
TextFormat
:
:
Printer
printer
;
printer
.
SetExpandAny
(
true
)
;
printer
.
SetInitialIndentLevel
(
depth
+
1
)
;
printer
.
PrintFieldValueToString
(
options
field
repeated
?
j
:
-
1
&
tmp
)
;
fieldval
.
append
(
"
{
\
n
"
)
;
fieldval
.
append
(
tmp
)
;
fieldval
.
append
(
depth
*
2
'
'
)
;
fieldval
.
append
(
"
}
"
)
;
}
else
{
TextFormat
:
:
PrintFieldValueToString
(
options
field
repeated
?
j
:
-
1
&
fieldval
)
;
}
std
:
:
string
name
;
if
(
field
-
>
is_extension
(
)
)
{
name
=
"
(
.
"
+
field
-
>
full_name
(
)
+
"
)
"
;
}
else
{
name
=
field
-
>
name
(
)
;
}
option_entries
-
>
push_back
(
name
+
"
=
"
+
fieldval
)
;
}
}
return
!
option_entries
-
>
empty
(
)
;
}
bool
RetrieveOptions
(
int
depth
const
Message
&
options
const
DescriptorPool
*
pool
std
:
:
vector
<
std
:
:
string
>
*
option_entries
)
{
if
(
options
.
GetDescriptor
(
)
-
>
file
(
)
-
>
pool
(
)
=
=
pool
)
{
return
RetrieveOptionsAssumingRightPool
(
depth
options
option_entries
)
;
}
else
{
const
Descriptor
*
option_descriptor
=
pool
-
>
FindMessageTypeByName
(
options
.
GetDescriptor
(
)
-
>
full_name
(
)
)
;
if
(
option_descriptor
=
=
nullptr
)
{
return
RetrieveOptionsAssumingRightPool
(
depth
options
option_entries
)
;
}
DynamicMessageFactory
factory
;
std
:
:
unique_ptr
<
Message
>
dynamic_options
(
factory
.
GetPrototype
(
option_descriptor
)
-
>
New
(
)
)
;
std
:
:
string
serialized
=
options
.
SerializeAsString
(
)
;
io
:
:
CodedInputStream
input
(
reinterpret_cast
<
const
uint8_t
*
>
(
serialized
.
c_str
(
)
)
serialized
.
size
(
)
)
;
input
.
SetExtensionRegistry
(
pool
&
factory
)
;
if
(
dynamic_options
-
>
ParseFromCodedStream
(
&
input
)
)
{
return
RetrieveOptionsAssumingRightPool
(
depth
*
dynamic_options
option_entries
)
;
}
else
{
GOOGLE_LOG
(
ERROR
)
<
<
"
Found
invalid
proto
option
data
for
:
"
<
<
options
.
GetDescriptor
(
)
-
>
full_name
(
)
;
return
RetrieveOptionsAssumingRightPool
(
depth
options
option_entries
)
;
}
}
}
bool
FormatBracketedOptions
(
int
depth
const
Message
&
options
const
DescriptorPool
*
pool
std
:
:
string
*
output
)
{
std
:
:
vector
<
std
:
:
string
>
all_options
;
if
(
RetrieveOptions
(
depth
options
pool
&
all_options
)
)
{
output
-
>
append
(
Join
(
all_options
"
"
)
)
;
}
return
!
all_options
.
empty
(
)
;
}
bool
FormatLineOptions
(
int
depth
const
Message
&
options
const
DescriptorPool
*
pool
std
:
:
string
*
output
)
{
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
std
:
:
vector
<
std
:
:
string
>
all_options
;
if
(
RetrieveOptions
(
depth
options
pool
&
all_options
)
)
{
for
(
const
std
:
:
string
&
option
:
all_options
)
{
strings
:
:
SubstituteAndAppend
(
output
"
0option
1
;
\
n
"
prefix
option
)
;
}
}
return
!
all_options
.
empty
(
)
;
}
class
SourceLocationCommentPrinter
{
public
:
template
<
typename
DescType
>
SourceLocationCommentPrinter
(
const
DescType
*
desc
const
std
:
:
string
&
prefix
const
DebugStringOptions
&
options
)
:
options_
(
options
)
prefix_
(
prefix
)
{
have_source_loc_
=
options
.
include_comments
&
&
desc
-
>
GetSourceLocation
(
&
source_loc_
)
;
}
SourceLocationCommentPrinter
(
const
FileDescriptor
*
file
const
std
:
:
vector
<
int
>
&
path
const
std
:
:
string
&
prefix
const
DebugStringOptions
&
options
)
:
options_
(
options
)
prefix_
(
prefix
)
{
have_source_loc_
=
options
.
include_comments
&
&
file
-
>
GetSourceLocation
(
path
&
source_loc_
)
;
}
void
AddPreComment
(
std
:
:
string
*
output
)
{
if
(
have_source_loc_
)
{
for
(
const
std
:
:
string
&
leading_detached_comment
:
source_loc_
.
leading_detached_comments
)
{
*
output
+
=
FormatComment
(
leading_detached_comment
)
;
*
output
+
=
"
\
n
"
;
}
if
(
!
source_loc_
.
leading_comments
.
empty
(
)
)
{
*
output
+
=
FormatComment
(
source_loc_
.
leading_comments
)
;
}
}
}
void
AddPostComment
(
std
:
:
string
*
output
)
{
if
(
have_source_loc_
&
&
source_loc_
.
trailing_comments
.
size
(
)
>
0
)
{
*
output
+
=
FormatComment
(
source_loc_
.
trailing_comments
)
;
}
}
std
:
:
string
FormatComment
(
const
std
:
:
string
&
comment_text
)
{
std
:
:
string
stripped_comment
=
comment_text
;
StripWhitespace
(
&
stripped_comment
)
;
std
:
:
vector
<
std
:
:
string
>
lines
=
Split
(
stripped_comment
"
\
n
"
)
;
std
:
:
string
output
;
for
(
const
std
:
:
string
&
line
:
lines
)
{
strings
:
:
SubstituteAndAppend
(
&
output
"
0
/
/
1
\
n
"
prefix_
line
)
;
}
return
output
;
}
private
:
bool
have_source_loc_
;
SourceLocation
source_loc_
;
DebugStringOptions
options_
;
std
:
:
string
prefix_
;
}
;
}
std
:
:
string
FileDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
FileDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
contents
;
{
std
:
:
vector
<
int
>
path
;
path
.
push_back
(
FileDescriptorProto
:
:
kSyntaxFieldNumber
)
;
SourceLocationCommentPrinter
syntax_comment
(
this
path
"
"
debug_string_options
)
;
syntax_comment
.
AddPreComment
(
&
contents
)
;
strings
:
:
SubstituteAndAppend
(
&
contents
"
syntax
=
\
"
0
\
"
;
\
n
\
n
"
SyntaxName
(
syntax
(
)
)
)
;
syntax_comment
.
AddPostComment
(
&
contents
)
;
}
SourceLocationCommentPrinter
comment_printer
(
this
"
"
debug_string_options
)
;
comment_printer
.
AddPreComment
(
&
contents
)
;
std
:
:
set
<
int
>
public_dependencies
;
std
:
:
set
<
int
>
weak_dependencies
;
public_dependencies
.
insert
(
public_dependencies_
public_dependencies_
+
public_dependency_count_
)
;
weak_dependencies
.
insert
(
weak_dependencies_
weak_dependencies_
+
weak_dependency_count_
)
;
for
(
int
i
=
0
;
i
<
dependency_count
(
)
;
i
+
+
)
{
if
(
public_dependencies
.
count
(
i
)
>
0
)
{
strings
:
:
SubstituteAndAppend
(
&
contents
"
import
public
\
"
0
\
"
;
\
n
"
dependency
(
i
)
-
>
name
(
)
)
;
}
else
if
(
weak_dependencies
.
count
(
i
)
>
0
)
{
strings
:
:
SubstituteAndAppend
(
&
contents
"
import
weak
\
"
0
\
"
;
\
n
"
dependency
(
i
)
-
>
name
(
)
)
;
}
else
{
strings
:
:
SubstituteAndAppend
(
&
contents
"
import
\
"
0
\
"
;
\
n
"
dependency
(
i
)
-
>
name
(
)
)
;
}
}
if
(
!
package
(
)
.
empty
(
)
)
{
std
:
:
vector
<
int
>
path
;
path
.
push_back
(
FileDescriptorProto
:
:
kPackageFieldNumber
)
;
SourceLocationCommentPrinter
package_comment
(
this
path
"
"
debug_string_options
)
;
package_comment
.
AddPreComment
(
&
contents
)
;
strings
:
:
SubstituteAndAppend
(
&
contents
"
package
0
;
\
n
\
n
"
package
(
)
)
;
package_comment
.
AddPostComment
(
&
contents
)
;
}
if
(
FormatLineOptions
(
0
options
(
)
pool
(
)
&
contents
)
)
{
contents
.
append
(
"
\
n
"
)
;
}
for
(
int
i
=
0
;
i
<
enum_type_count
(
)
;
i
+
+
)
{
enum_type
(
i
)
-
>
DebugString
(
0
&
contents
debug_string_options
)
;
contents
.
append
(
"
\
n
"
)
;
}
std
:
:
set
<
const
Descriptor
*
>
groups
;
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
if
(
extension
(
i
)
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_GROUP
)
{
groups
.
insert
(
extension
(
i
)
-
>
message_type
(
)
)
;
}
}
for
(
int
i
=
0
;
i
<
message_type_count
(
)
;
i
+
+
)
{
if
(
groups
.
count
(
message_type
(
i
)
)
=
=
0
)
{
message_type
(
i
)
-
>
DebugString
(
0
&
contents
debug_string_options
true
)
;
contents
.
append
(
"
\
n
"
)
;
}
}
for
(
int
i
=
0
;
i
<
service_count
(
)
;
i
+
+
)
{
service
(
i
)
-
>
DebugString
(
&
contents
debug_string_options
)
;
contents
.
append
(
"
\
n
"
)
;
}
const
Descriptor
*
containing_type
=
nullptr
;
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
if
(
extension
(
i
)
-
>
containing_type
(
)
!
=
containing_type
)
{
if
(
i
>
0
)
contents
.
append
(
"
}
\
n
\
n
"
)
;
containing_type
=
extension
(
i
)
-
>
containing_type
(
)
;
strings
:
:
SubstituteAndAppend
(
&
contents
"
extend
.
0
{
\
n
"
containing_type
-
>
full_name
(
)
)
;
}
extension
(
i
)
-
>
DebugString
(
1
&
contents
debug_string_options
)
;
}
if
(
extension_count
(
)
>
0
)
contents
.
append
(
"
}
\
n
\
n
"
)
;
comment_printer
.
AddPostComment
(
&
contents
)
;
return
contents
;
}
std
:
:
string
Descriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
Descriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
options
)
const
{
std
:
:
string
contents
;
DebugString
(
0
&
contents
options
true
)
;
return
contents
;
}
void
Descriptor
:
:
DebugString
(
int
depth
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
bool
include_opening_clause
)
const
{
if
(
options
(
)
.
map_entry
(
)
)
{
return
;
}
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
+
+
depth
;
SourceLocationCommentPrinter
comment_printer
(
this
prefix
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
if
(
include_opening_clause
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0message
1
"
prefix
name
(
)
)
;
}
contents
-
>
append
(
"
{
\
n
"
)
;
FormatLineOptions
(
depth
options
(
)
file
(
)
-
>
pool
(
)
contents
)
;
std
:
:
set
<
const
Descriptor
*
>
groups
;
for
(
int
i
=
0
;
i
<
field_count
(
)
;
i
+
+
)
{
if
(
field
(
i
)
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_GROUP
)
{
groups
.
insert
(
field
(
i
)
-
>
message_type
(
)
)
;
}
}
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
if
(
extension
(
i
)
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_GROUP
)
{
groups
.
insert
(
extension
(
i
)
-
>
message_type
(
)
)
;
}
}
for
(
int
i
=
0
;
i
<
nested_type_count
(
)
;
i
+
+
)
{
if
(
groups
.
count
(
nested_type
(
i
)
)
=
=
0
)
{
nested_type
(
i
)
-
>
DebugString
(
depth
contents
debug_string_options
true
)
;
}
}
for
(
int
i
=
0
;
i
<
enum_type_count
(
)
;
i
+
+
)
{
enum_type
(
i
)
-
>
DebugString
(
depth
contents
debug_string_options
)
;
}
for
(
int
i
=
0
;
i
<
field_count
(
)
;
i
+
+
)
{
if
(
field
(
i
)
-
>
real_containing_oneof
(
)
=
=
nullptr
)
{
field
(
i
)
-
>
DebugString
(
depth
contents
debug_string_options
)
;
}
else
if
(
field
(
i
)
-
>
containing_oneof
(
)
-
>
field
(
0
)
=
=
field
(
i
)
)
{
field
(
i
)
-
>
containing_oneof
(
)
-
>
DebugString
(
depth
contents
debug_string_options
)
;
}
}
for
(
int
i
=
0
;
i
<
extension_range_count
(
)
;
i
+
+
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
extensions
1
to
2
;
\
n
"
prefix
extension_range
(
i
)
-
>
start
extension_range
(
i
)
-
>
end
-
1
)
;
}
const
Descriptor
*
containing_type
=
nullptr
;
for
(
int
i
=
0
;
i
<
extension_count
(
)
;
i
+
+
)
{
if
(
extension
(
i
)
-
>
containing_type
(
)
!
=
containing_type
)
{
if
(
i
>
0
)
strings
:
:
SubstituteAndAppend
(
contents
"
0
}
\
n
"
prefix
)
;
containing_type
=
extension
(
i
)
-
>
containing_type
(
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
0
extend
.
1
{
\
n
"
prefix
containing_type
-
>
full_name
(
)
)
;
}
extension
(
i
)
-
>
DebugString
(
depth
+
1
contents
debug_string_options
)
;
}
if
(
extension_count
(
)
>
0
)
strings
:
:
SubstituteAndAppend
(
contents
"
0
}
\
n
"
prefix
)
;
if
(
reserved_range_count
(
)
>
0
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
reserved
"
prefix
)
;
for
(
int
i
=
0
;
i
<
reserved_range_count
(
)
;
i
+
+
)
{
const
Descriptor
:
:
ReservedRange
*
range
=
reserved_range
(
i
)
;
if
(
range
-
>
end
=
=
range
-
>
start
+
1
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
"
range
-
>
start
)
;
}
else
if
(
range
-
>
end
>
FieldDescriptor
:
:
kMaxNumber
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
to
max
"
range
-
>
start
)
;
}
else
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
to
1
"
range
-
>
start
range
-
>
end
-
1
)
;
}
}
contents
-
>
replace
(
contents
-
>
size
(
)
-
2
2
"
;
\
n
"
)
;
}
if
(
reserved_name_count
(
)
>
0
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
reserved
"
prefix
)
;
for
(
int
i
=
0
;
i
<
reserved_name_count
(
)
;
i
+
+
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
\
"
0
\
"
"
CEscape
(
reserved_name
(
i
)
)
)
;
}
contents
-
>
replace
(
contents
-
>
size
(
)
-
2
2
"
;
\
n
"
)
;
}
strings
:
:
SubstituteAndAppend
(
contents
"
0
}
\
n
"
prefix
)
;
comment_printer
.
AddPostComment
(
contents
)
;
}
std
:
:
string
FieldDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
FieldDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
contents
;
int
depth
=
0
;
if
(
is_extension
(
)
)
{
strings
:
:
SubstituteAndAppend
(
&
contents
"
extend
.
0
{
\
n
"
containing_type
(
)
-
>
full_name
(
)
)
;
depth
=
1
;
}
DebugString
(
depth
&
contents
debug_string_options
)
;
if
(
is_extension
(
)
)
{
contents
.
append
(
"
}
\
n
"
)
;
}
return
contents
;
}
std
:
:
string
FieldDescriptor
:
:
FieldTypeNameDebugString
(
)
const
{
switch
(
type
(
)
)
{
case
TYPE_MESSAGE
:
return
"
.
"
+
message_type
(
)
-
>
full_name
(
)
;
case
TYPE_ENUM
:
return
"
.
"
+
enum_type
(
)
-
>
full_name
(
)
;
default
:
return
kTypeToName
[
type
(
)
]
;
}
}
void
FieldDescriptor
:
:
DebugString
(
int
depth
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
std
:
:
string
field_type
;
if
(
is_map
(
)
)
{
strings
:
:
SubstituteAndAppend
(
&
field_type
"
map
<
0
1
>
"
message_type
(
)
-
>
field
(
0
)
-
>
FieldTypeNameDebugString
(
)
message_type
(
)
-
>
field
(
1
)
-
>
FieldTypeNameDebugString
(
)
)
;
}
else
{
field_type
=
FieldTypeNameDebugString
(
)
;
}
std
:
:
string
label
=
StrCat
(
kLabelToName
[
this
-
>
label
(
)
]
"
"
)
;
if
(
is_map
(
)
|
|
real_containing_oneof
(
)
|
|
(
is_optional
(
)
&
&
!
has_optional_keyword
(
)
)
)
{
label
.
clear
(
)
;
}
SourceLocationCommentPrinter
comment_printer
(
this
prefix
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
0
1
2
3
=
4
"
prefix
label
field_type
type
(
)
=
=
TYPE_GROUP
?
message_type
(
)
-
>
name
(
)
:
name
(
)
number
(
)
)
;
bool
bracketed
=
false
;
if
(
has_default_value
(
)
)
{
bracketed
=
true
;
strings
:
:
SubstituteAndAppend
(
contents
"
[
default
=
0
"
DefaultValueAsString
(
true
)
)
;
}
if
(
has_json_name_
)
{
if
(
!
bracketed
)
{
bracketed
=
true
;
contents
-
>
append
(
"
[
"
)
;
}
else
{
contents
-
>
append
(
"
"
)
;
}
contents
-
>
append
(
"
json_name
=
\
"
"
)
;
contents
-
>
append
(
CEscape
(
json_name
(
)
)
)
;
contents
-
>
append
(
"
\
"
"
)
;
}
std
:
:
string
formatted_options
;
if
(
FormatBracketedOptions
(
depth
options
(
)
file
(
)
-
>
pool
(
)
&
formatted_options
)
)
{
contents
-
>
append
(
bracketed
?
"
"
:
"
[
"
)
;
bracketed
=
true
;
contents
-
>
append
(
formatted_options
)
;
}
if
(
bracketed
)
{
contents
-
>
append
(
"
]
"
)
;
}
if
(
type
(
)
=
=
TYPE_GROUP
)
{
if
(
debug_string_options
.
elide_group_body
)
{
contents
-
>
append
(
"
{
.
.
.
}
;
\
n
"
)
;
}
else
{
message_type
(
)
-
>
DebugString
(
depth
contents
debug_string_options
false
)
;
}
}
else
{
contents
-
>
append
(
"
;
\
n
"
)
;
}
comment_printer
.
AddPostComment
(
contents
)
;
}
std
:
:
string
OneofDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
OneofDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
options
)
const
{
std
:
:
string
contents
;
DebugString
(
0
&
contents
options
)
;
return
contents
;
}
void
OneofDescriptor
:
:
DebugString
(
int
depth
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
+
+
depth
;
SourceLocationCommentPrinter
comment_printer
(
this
prefix
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
0oneof
1
{
"
prefix
name
(
)
)
;
FormatLineOptions
(
depth
options
(
)
containing_type
(
)
-
>
file
(
)
-
>
pool
(
)
contents
)
;
if
(
debug_string_options
.
elide_oneof_body
)
{
contents
-
>
append
(
"
.
.
.
}
\
n
"
)
;
}
else
{
contents
-
>
append
(
"
\
n
"
)
;
for
(
int
i
=
0
;
i
<
field_count
(
)
;
i
+
+
)
{
field
(
i
)
-
>
DebugString
(
depth
contents
debug_string_options
)
;
}
strings
:
:
SubstituteAndAppend
(
contents
"
0
}
\
n
"
prefix
)
;
}
comment_printer
.
AddPostComment
(
contents
)
;
}
std
:
:
string
EnumDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
EnumDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
options
)
const
{
std
:
:
string
contents
;
DebugString
(
0
&
contents
options
)
;
return
contents
;
}
void
EnumDescriptor
:
:
DebugString
(
int
depth
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
+
+
depth
;
SourceLocationCommentPrinter
comment_printer
(
this
prefix
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
0enum
1
{
\
n
"
prefix
name
(
)
)
;
FormatLineOptions
(
depth
options
(
)
file
(
)
-
>
pool
(
)
contents
)
;
for
(
int
i
=
0
;
i
<
value_count
(
)
;
i
+
+
)
{
value
(
i
)
-
>
DebugString
(
depth
contents
debug_string_options
)
;
}
if
(
reserved_range_count
(
)
>
0
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
reserved
"
prefix
)
;
for
(
int
i
=
0
;
i
<
reserved_range_count
(
)
;
i
+
+
)
{
const
EnumDescriptor
:
:
ReservedRange
*
range
=
reserved_range
(
i
)
;
if
(
range
-
>
end
=
=
range
-
>
start
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
"
range
-
>
start
)
;
}
else
if
(
range
-
>
end
=
=
INT_MAX
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
to
max
"
range
-
>
start
)
;
}
else
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
to
1
"
range
-
>
start
range
-
>
end
)
;
}
}
contents
-
>
replace
(
contents
-
>
size
(
)
-
2
2
"
;
\
n
"
)
;
}
if
(
reserved_name_count
(
)
>
0
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
0
reserved
"
prefix
)
;
for
(
int
i
=
0
;
i
<
reserved_name_count
(
)
;
i
+
+
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
\
"
0
\
"
"
CEscape
(
reserved_name
(
i
)
)
)
;
}
contents
-
>
replace
(
contents
-
>
size
(
)
-
2
2
"
;
\
n
"
)
;
}
strings
:
:
SubstituteAndAppend
(
contents
"
0
}
\
n
"
prefix
)
;
comment_printer
.
AddPostComment
(
contents
)
;
}
std
:
:
string
EnumValueDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
EnumValueDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
options
)
const
{
std
:
:
string
contents
;
DebugString
(
0
&
contents
options
)
;
return
contents
;
}
void
EnumValueDescriptor
:
:
DebugString
(
int
depth
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
SourceLocationCommentPrinter
comment_printer
(
this
prefix
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
0
1
=
2
"
prefix
name
(
)
number
(
)
)
;
std
:
:
string
formatted_options
;
if
(
FormatBracketedOptions
(
depth
options
(
)
type
(
)
-
>
file
(
)
-
>
pool
(
)
&
formatted_options
)
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
[
0
]
"
formatted_options
)
;
}
contents
-
>
append
(
"
;
\
n
"
)
;
comment_printer
.
AddPostComment
(
contents
)
;
}
std
:
:
string
ServiceDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
ServiceDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
options
)
const
{
std
:
:
string
contents
;
DebugString
(
&
contents
options
)
;
return
contents
;
}
void
ServiceDescriptor
:
:
DebugString
(
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
)
const
{
SourceLocationCommentPrinter
comment_printer
(
this
"
"
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
service
0
{
\
n
"
name
(
)
)
;
FormatLineOptions
(
1
options
(
)
file
(
)
-
>
pool
(
)
contents
)
;
for
(
int
i
=
0
;
i
<
method_count
(
)
;
i
+
+
)
{
method
(
i
)
-
>
DebugString
(
1
contents
debug_string_options
)
;
}
contents
-
>
append
(
"
}
\
n
"
)
;
comment_printer
.
AddPostComment
(
contents
)
;
}
std
:
:
string
MethodDescriptor
:
:
DebugString
(
)
const
{
DebugStringOptions
options
;
return
DebugStringWithOptions
(
options
)
;
}
std
:
:
string
MethodDescriptor
:
:
DebugStringWithOptions
(
const
DebugStringOptions
&
options
)
const
{
std
:
:
string
contents
;
DebugString
(
0
&
contents
options
)
;
return
contents
;
}
void
MethodDescriptor
:
:
DebugString
(
int
depth
std
:
:
string
*
contents
const
DebugStringOptions
&
debug_string_options
)
const
{
std
:
:
string
prefix
(
depth
*
2
'
'
)
;
+
+
depth
;
SourceLocationCommentPrinter
comment_printer
(
this
prefix
debug_string_options
)
;
comment_printer
.
AddPreComment
(
contents
)
;
strings
:
:
SubstituteAndAppend
(
contents
"
0rpc
1
(
4
.
2
)
returns
(
5
.
3
)
"
prefix
name
(
)
input_type
(
)
-
>
full_name
(
)
output_type
(
)
-
>
full_name
(
)
client_streaming
(
)
?
"
stream
"
:
"
"
server_streaming
(
)
?
"
stream
"
:
"
"
)
;
std
:
:
string
formatted_options
;
if
(
FormatLineOptions
(
depth
options
(
)
service
(
)
-
>
file
(
)
-
>
pool
(
)
&
formatted_options
)
)
{
strings
:
:
SubstituteAndAppend
(
contents
"
{
\
n
0
1
}
\
n
"
formatted_options
prefix
)
;
}
else
{
contents
-
>
append
(
"
;
\
n
"
)
;
}
comment_printer
.
AddPostComment
(
contents
)
;
}
bool
FileDescriptor
:
:
GetSourceLocation
(
const
std
:
:
vector
<
int
>
&
path
SourceLocation
*
out_location
)
const
{
GOOGLE_CHECK
(
out_location
!
=
nullptr
)
;
if
(
source_code_info_
)
{
if
(
const
SourceCodeInfo_Location
*
loc
=
tables_
-
>
GetSourceLocation
(
path
source_code_info_
)
)
{
const
RepeatedField
<
int32_t
>
&
span
=
loc
-
>
span
(
)
;
if
(
span
.
size
(
)
=
=
3
|
|
span
.
size
(
)
=
=
4
)
{
out_location
-
>
start_line
=
span
.
Get
(
0
)
;
out_location
-
>
start_column
=
span
.
Get
(
1
)
;
out_location
-
>
end_line
=
span
.
Get
(
span
.
size
(
)
=
=
3
?
0
:
2
)
;
out_location
-
>
end_column
=
span
.
Get
(
span
.
size
(
)
-
1
)
;
out_location
-
>
leading_comments
=
loc
-
>
leading_comments
(
)
;
out_location
-
>
trailing_comments
=
loc
-
>
trailing_comments
(
)
;
out_location
-
>
leading_detached_comments
.
assign
(
loc
-
>
leading_detached_comments
(
)
.
begin
(
)
loc
-
>
leading_detached_comments
(
)
.
end
(
)
)
;
return
true
;
}
}
}
return
false
;
}
bool
FileDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
return
GetSourceLocation
(
path
out_location
)
;
}
bool
FieldDescriptor
:
:
is_packed
(
)
const
{
if
(
!
is_packable
(
)
)
return
false
;
if
(
file_
-
>
syntax
(
)
=
=
FileDescriptor
:
:
SYNTAX_PROTO2
)
{
return
(
options_
!
=
nullptr
)
&
&
options_
-
>
packed
(
)
;
}
else
{
return
options_
=
=
nullptr
|
|
!
options_
-
>
has_packed
(
)
|
|
options_
-
>
packed
(
)
;
}
}
bool
Descriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
bool
FieldDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
bool
OneofDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
containing_type
(
)
-
>
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
bool
EnumDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
bool
MethodDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
service
(
)
-
>
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
bool
ServiceDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
bool
EnumValueDescriptor
:
:
GetSourceLocation
(
SourceLocation
*
out_location
)
const
{
std
:
:
vector
<
int
>
path
;
GetLocationPath
(
&
path
)
;
return
type
(
)
-
>
file
(
)
-
>
GetSourceLocation
(
path
out_location
)
;
}
void
Descriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
if
(
containing_type
(
)
)
{
containing_type
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
DescriptorProto
:
:
kNestedTypeFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
else
{
output
-
>
push_back
(
FileDescriptorProto
:
:
kMessageTypeFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
}
void
FieldDescriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
if
(
is_extension
(
)
)
{
if
(
extension_scope
(
)
=
=
nullptr
)
{
output
-
>
push_back
(
FileDescriptorProto
:
:
kExtensionFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
else
{
extension_scope
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
DescriptorProto
:
:
kExtensionFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
}
else
{
containing_type
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
DescriptorProto
:
:
kFieldFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
}
void
OneofDescriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
containing_type
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
DescriptorProto
:
:
kOneofDeclFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
void
EnumDescriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
if
(
containing_type
(
)
)
{
containing_type
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
DescriptorProto
:
:
kEnumTypeFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
else
{
output
-
>
push_back
(
FileDescriptorProto
:
:
kEnumTypeFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
}
void
EnumValueDescriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
type
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
EnumDescriptorProto
:
:
kValueFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
void
ServiceDescriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
output
-
>
push_back
(
FileDescriptorProto
:
:
kServiceFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
void
MethodDescriptor
:
:
GetLocationPath
(
std
:
:
vector
<
int
>
*
output
)
const
{
service
(
)
-
>
GetLocationPath
(
output
)
;
output
-
>
push_back
(
ServiceDescriptorProto
:
:
kMethodFieldNumber
)
;
output
-
>
push_back
(
index
(
)
)
;
}
namespace
{
struct
OptionsToInterpret
{
OptionsToInterpret
(
const
std
:
:
string
&
ns
const
std
:
:
string
&
el
const
std
:
:
vector
<
int
>
&
path
const
Message
*
orig_opt
Message
*
opt
)
:
name_scope
(
ns
)
element_name
(
el
)
element_path
(
path
)
original_options
(
orig_opt
)
options
(
opt
)
{
}
std
:
:
string
name_scope
;
std
:
:
string
element_name
;
std
:
:
vector
<
int
>
element_path
;
const
Message
*
original_options
;
Message
*
options
;
}
;
}
class
DescriptorBuilder
{
public
:
DescriptorBuilder
(
const
DescriptorPool
*
pool
DescriptorPool
:
:
Tables
*
tables
DescriptorPool
:
:
ErrorCollector
*
error_collector
)
;
~
DescriptorBuilder
(
)
;
const
FileDescriptor
*
BuildFile
(
const
FileDescriptorProto
&
proto
)
;
private
:
friend
class
OptionInterpreter
;
FileDescriptor
*
BuildFileImpl
(
const
FileDescriptorProto
&
proto
internal
:
:
FlatAllocator
&
alloc
)
;
const
DescriptorPool
*
pool_
;
DescriptorPool
:
:
Tables
*
tables_
;
DescriptorPool
:
:
ErrorCollector
*
error_collector_
;
std
:
:
vector
<
OptionsToInterpret
>
options_to_interpret_
;
bool
had_errors_
;
std
:
:
string
filename_
;
FileDescriptor
*
file_
;
FileDescriptorTables
*
file_tables_
;
std
:
:
set
<
const
FileDescriptor
*
>
dependencies_
;
struct
MessageHints
{
int
fields_to_suggest
=
0
;
const
Message
*
first_reason
=
nullptr
;
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
first_reason_location
=
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
:
:
OTHER
;
void
RequestHintOnFieldNumbers
(
const
Message
&
reason
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
reason_location
int
range_start
=
0
int
range_end
=
1
)
{
auto
fit
=
[
]
(
int
value
)
{
return
std
:
:
min
(
std
:
:
max
(
value
0
)
FieldDescriptor
:
:
kMaxNumber
)
;
}
;
fields_to_suggest
=
fit
(
fields_to_suggest
+
fit
(
fit
(
range_end
)
-
fit
(
range_start
)
)
)
;
if
(
first_reason
)
return
;
first_reason
=
&
reason
;
first_reason_location
=
reason_location
;
}
}
;
std
:
:
unordered_map
<
const
Descriptor
*
MessageHints
>
message_hints_
;
std
:
:
set
<
const
FileDescriptor
*
>
unused_dependency_
;
const
FileDescriptor
*
possible_undeclared_dependency_
;
std
:
:
string
possible_undeclared_dependency_name_
;
std
:
:
string
undefine_resolved_name_
;
int
recursion_depth_
=
32
;
void
AddError
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
error
)
;
void
AddError
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
char
*
error
)
;
void
AddRecursiveImportError
(
const
FileDescriptorProto
&
proto
int
from_here
)
;
void
AddTwiceListedError
(
const
FileDescriptorProto
&
proto
int
index
)
;
void
AddImportError
(
const
FileDescriptorProto
&
proto
int
index
)
;
void
AddNotDefinedError
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
undefined_symbol
)
;
void
AddWarning
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
error
)
;
bool
IsInPackage
(
const
FileDescriptor
*
file
const
std
:
:
string
&
package_name
)
;
void
RecordPublicDependencies
(
const
FileDescriptor
*
file
)
;
Symbol
FindSymbol
(
const
std
:
:
string
&
name
bool
build_it
=
true
)
;
Symbol
FindSymbolNotEnforcingDeps
(
const
std
:
:
string
&
name
bool
build_it
=
true
)
;
Symbol
FindSymbolNotEnforcingDepsHelper
(
const
DescriptorPool
*
pool
const
std
:
:
string
&
name
bool
build_it
=
true
)
;
enum
ResolveMode
{
LOOKUP_ALL
LOOKUP_TYPES
}
;
Symbol
LookupSymbol
(
const
std
:
:
string
&
name
const
std
:
:
string
&
relative_to
DescriptorPool
:
:
PlaceholderType
placeholder_type
=
DescriptorPool
:
:
PLACEHOLDER_MESSAGE
ResolveMode
resolve_mode
=
LOOKUP_ALL
bool
build_it
=
true
)
;
Symbol
LookupSymbolNoPlaceholder
(
const
std
:
:
string
&
name
const
std
:
:
string
&
relative_to
ResolveMode
resolve_mode
=
LOOKUP_ALL
bool
build_it
=
true
)
;
bool
AddSymbol
(
const
std
:
:
string
&
full_name
const
void
*
parent
const
std
:
:
string
&
name
const
Message
&
proto
Symbol
symbol
)
;
void
AddPackage
(
const
std
:
:
string
&
name
const
Message
&
proto
FileDescriptor
*
file
)
;
void
ValidateSymbolName
(
const
std
:
:
string
&
name
const
std
:
:
string
&
full_name
const
Message
&
proto
)
;
template
<
class
DescriptorT
>
void
AllocateOptions
(
const
typename
DescriptorT
:
:
OptionsType
&
orig_options
DescriptorT
*
descriptor
int
options_field_tag
const
std
:
:
string
&
option_name
internal
:
:
FlatAllocator
&
alloc
)
;
void
AllocateOptions
(
const
FileOptions
&
orig_options
FileDescriptor
*
descriptor
internal
:
:
FlatAllocator
&
alloc
)
;
template
<
class
DescriptorT
>
void
AllocateOptionsImpl
(
const
std
:
:
string
&
name_scope
const
std
:
:
string
&
element_name
const
typename
DescriptorT
:
:
OptionsType
&
orig_options
DescriptorT
*
descriptor
const
std
:
:
vector
<
int
>
&
options_path
const
std
:
:
string
&
option_name
internal
:
:
FlatAllocator
&
alloc
)
;
const
std
:
:
string
*
AllocateNameStrings
(
const
std
:
:
string
&
scope
const
std
:
:
string
&
proto_name
internal
:
:
FlatAllocator
&
alloc
)
;
void
BuildMessage
(
const
DescriptorProto
&
proto
const
Descriptor
*
parent
Descriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
;
void
BuildFieldOrExtension
(
const
FieldDescriptorProto
&
proto
Descriptor
*
parent
FieldDescriptor
*
result
bool
is_extension
internal
:
:
FlatAllocator
&
alloc
)
;
void
BuildField
(
const
FieldDescriptorProto
&
proto
Descriptor
*
parent
FieldDescriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
{
BuildFieldOrExtension
(
proto
parent
result
false
alloc
)
;
}
void
BuildExtension
(
const
FieldDescriptorProto
&
proto
Descriptor
*
parent
FieldDescriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
{
BuildFieldOrExtension
(
proto
parent
result
true
alloc
)
;
}
void
BuildExtensionRange
(
const
DescriptorProto
:
:
ExtensionRange
&
proto
const
Descriptor
*
parent
Descriptor
:
:
ExtensionRange
*
result
internal
:
:
FlatAllocator
&
alloc
)
;
void
BuildReservedRange
(
const
DescriptorProto
:
:
ReservedRange
&
proto
const
Descriptor
*
parent
Descriptor
:
:
ReservedRange
*
result
internal
:
:
FlatAllocator
&
alloc
)
;
void
BuildReservedRange
(
const
EnumDescriptorProto
:
:
EnumReservedRange
&
proto
const
EnumDescriptor
*
parent
EnumDescriptor
:
:
ReservedRange
*
result
internal
:
:
FlatAllocator
&
alloc
)
;
void
BuildOneof
(
const
OneofDescriptorProto
&
proto
Descriptor
*
parent
OneofDescriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
;
void
CheckEnumValueUniqueness
(
const
EnumDescriptorProto
&
proto
const
EnumDescriptor
*
result
)
;
void
BuildEnum
(
const
EnumDescriptorProto
&
proto
const
Descriptor
*
parent
EnumDescriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
;
void
BuildEnumValue
(
const
EnumValueDescriptorProto
&
proto
const
EnumDescriptor
*
parent
EnumValueDescriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
;
void
BuildService
(
const
ServiceDescriptorProto
&
proto
const
void
*
dummy
ServiceDescriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
;
void
BuildMethod
(
const
MethodDescriptorProto
&
proto
const
ServiceDescriptor
*
parent
MethodDescriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
;
void
LogUnusedDependency
(
const
FileDescriptorProto
&
proto
const
FileDescriptor
*
result
)
;
void
CrossLinkFile
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
;
void
CrossLinkMessage
(
Descriptor
*
message
const
DescriptorProto
&
proto
)
;
void
CrossLinkField
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
;
void
CrossLinkExtensionRange
(
Descriptor
:
:
ExtensionRange
*
range
const
DescriptorProto
:
:
ExtensionRange
&
proto
)
;
void
CrossLinkEnum
(
EnumDescriptor
*
enum_type
const
EnumDescriptorProto
&
proto
)
;
void
CrossLinkEnumValue
(
EnumValueDescriptor
*
enum_value
const
EnumValueDescriptorProto
&
proto
)
;
void
CrossLinkService
(
ServiceDescriptor
*
service
const
ServiceDescriptorProto
&
proto
)
;
void
CrossLinkMethod
(
MethodDescriptor
*
method
const
MethodDescriptorProto
&
proto
)
;
void
SuggestFieldNumbers
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
;
void
InterpretOptions
(
)
;
class
OptionInterpreter
{
public
:
explicit
OptionInterpreter
(
DescriptorBuilder
*
builder
)
;
~
OptionInterpreter
(
)
;
bool
InterpretOptions
(
OptionsToInterpret
*
options_to_interpret
)
;
void
UpdateSourceCodeInfo
(
SourceCodeInfo
*
info
)
;
class
AggregateOptionFinder
;
private
:
bool
InterpretSingleOption
(
Message
*
options
const
std
:
:
vector
<
int
>
&
src_path
const
std
:
:
vector
<
int
>
&
options_path
)
;
void
AddWithoutInterpreting
(
const
UninterpretedOption
&
uninterpreted_option
Message
*
options
)
;
bool
ExamineIfOptionIsSet
(
std
:
:
vector
<
const
FieldDescriptor
*
>
:
:
const_iterator
intermediate_fields_iter
std
:
:
vector
<
const
FieldDescriptor
*
>
:
:
const_iterator
intermediate_fields_end
const
FieldDescriptor
*
innermost_field
const
std
:
:
string
&
debug_msg_name
const
UnknownFieldSet
&
unknown_fields
)
;
bool
SetOptionValue
(
const
FieldDescriptor
*
option_field
UnknownFieldSet
*
unknown_fields
)
;
bool
SetAggregateOption
(
const
FieldDescriptor
*
option_field
UnknownFieldSet
*
unknown_fields
)
;
void
SetInt32
(
int
number
int32_t
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
;
void
SetInt64
(
int
number
int64_t
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
;
void
SetUInt32
(
int
number
uint32_t
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
;
void
SetUInt64
(
int
number
uint64_t
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
;
bool
AddOptionError
(
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
msg
)
{
builder_
-
>
AddError
(
options_to_interpret_
-
>
element_name
*
uninterpreted_option_
location
msg
)
;
return
false
;
}
bool
AddNameError
(
const
std
:
:
string
&
msg
)
{
#
ifdef
PROTOBUF_INTERNAL_IGNORE_FIELD_NAME_ERRORS_
return
true
;
#
else
return
AddOptionError
(
DescriptorPool
:
:
ErrorCollector
:
:
OPTION_NAME
msg
)
;
#
endif
}
bool
AddValueError
(
const
std
:
:
string
&
msg
)
{
return
AddOptionError
(
DescriptorPool
:
:
ErrorCollector
:
:
OPTION_VALUE
msg
)
;
}
DescriptorBuilder
*
builder_
;
const
OptionsToInterpret
*
options_to_interpret_
;
const
UninterpretedOption
*
uninterpreted_option_
;
std
:
:
map
<
std
:
:
vector
<
int
>
std
:
:
vector
<
int
>
>
interpreted_paths_
;
std
:
:
map
<
std
:
:
vector
<
int
>
int
>
repeated_option_counts_
;
DynamicMessageFactory
dynamic_factory_
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
OptionInterpreter
)
;
}
;
friend
class
OptionInterpreter
;
friend
class
OptionInterpreter
:
:
AggregateOptionFinder
;
static
inline
bool
get_allow_unknown
(
const
DescriptorPool
*
pool
)
{
return
pool
-
>
allow_unknown_
;
}
static
inline
bool
get_enforce_weak
(
const
DescriptorPool
*
pool
)
{
return
pool
-
>
enforce_weak_
;
}
static
inline
bool
get_is_placeholder
(
const
Descriptor
*
descriptor
)
{
return
descriptor
!
=
nullptr
&
&
descriptor
-
>
is_placeholder_
;
}
static
inline
void
assert_mutex_held
(
const
DescriptorPool
*
pool
)
{
if
(
pool
-
>
mutex_
!
=
nullptr
)
{
pool
-
>
mutex_
-
>
AssertHeld
(
)
;
}
}
void
ValidateFileOptions
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
;
void
ValidateMessageOptions
(
Descriptor
*
message
const
DescriptorProto
&
proto
)
;
void
ValidateFieldOptions
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
;
void
ValidateEnumOptions
(
EnumDescriptor
*
enm
const
EnumDescriptorProto
&
proto
)
;
void
ValidateEnumValueOptions
(
EnumValueDescriptor
*
enum_value
const
EnumValueDescriptorProto
&
proto
)
;
void
ValidateExtensionRangeOptions
(
const
std
:
:
string
&
full_name
Descriptor
:
:
ExtensionRange
*
extension_range
const
DescriptorProto_ExtensionRange
&
proto
)
;
void
ValidateServiceOptions
(
ServiceDescriptor
*
service
const
ServiceDescriptorProto
&
proto
)
;
void
ValidateMethodOptions
(
MethodDescriptor
*
method
const
MethodDescriptorProto
&
proto
)
;
void
ValidateProto3
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
;
void
ValidateProto3Message
(
Descriptor
*
message
const
DescriptorProto
&
proto
)
;
void
ValidateProto3Field
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
;
void
ValidateProto3Enum
(
EnumDescriptor
*
enm
const
EnumDescriptorProto
&
proto
)
;
bool
ValidateMapEntry
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
;
void
DetectMapConflicts
(
const
Descriptor
*
message
const
DescriptorProto
&
proto
)
;
void
ValidateJSType
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
;
}
;
const
FileDescriptor
*
DescriptorPool
:
:
BuildFile
(
const
FileDescriptorProto
&
proto
)
{
GOOGLE_CHECK
(
fallback_database_
=
=
nullptr
)
<
<
"
Cannot
call
BuildFile
on
a
DescriptorPool
that
uses
a
"
"
DescriptorDatabase
.
You
must
instead
find
a
way
to
get
your
file
"
"
into
the
underlying
database
.
"
;
GOOGLE_CHECK
(
mutex_
=
=
nullptr
)
;
tables_
-
>
known_bad_symbols_
.
clear
(
)
;
tables_
-
>
known_bad_files_
.
clear
(
)
;
return
DescriptorBuilder
(
this
tables_
.
get
(
)
nullptr
)
.
BuildFile
(
proto
)
;
}
const
FileDescriptor
*
DescriptorPool
:
:
BuildFileCollectingErrors
(
const
FileDescriptorProto
&
proto
ErrorCollector
*
error_collector
)
{
GOOGLE_CHECK
(
fallback_database_
=
=
nullptr
)
<
<
"
Cannot
call
BuildFile
on
a
DescriptorPool
that
uses
a
"
"
DescriptorDatabase
.
You
must
instead
find
a
way
to
get
your
file
"
"
into
the
underlying
database
.
"
;
GOOGLE_CHECK
(
mutex_
=
=
nullptr
)
;
tables_
-
>
known_bad_symbols_
.
clear
(
)
;
tables_
-
>
known_bad_files_
.
clear
(
)
;
return
DescriptorBuilder
(
this
tables_
.
get
(
)
error_collector
)
.
BuildFile
(
proto
)
;
}
const
FileDescriptor
*
DescriptorPool
:
:
BuildFileFromDatabase
(
const
FileDescriptorProto
&
proto
)
const
{
mutex_
-
>
AssertHeld
(
)
;
if
(
tables_
-
>
known_bad_files_
.
count
(
proto
.
name
(
)
)
>
0
)
{
return
nullptr
;
}
const
FileDescriptor
*
result
=
DescriptorBuilder
(
this
tables_
.
get
(
)
default_error_collector_
)
.
BuildFile
(
proto
)
;
if
(
result
=
=
nullptr
)
{
tables_
-
>
known_bad_files_
.
insert
(
proto
.
name
(
)
)
;
}
return
result
;
}
DescriptorBuilder
:
:
DescriptorBuilder
(
const
DescriptorPool
*
pool
DescriptorPool
:
:
Tables
*
tables
DescriptorPool
:
:
ErrorCollector
*
error_collector
)
:
pool_
(
pool
)
tables_
(
tables
)
error_collector_
(
error_collector
)
had_errors_
(
false
)
possible_undeclared_dependency_
(
nullptr
)
undefine_resolved_name_
(
"
"
)
{
}
DescriptorBuilder
:
:
~
DescriptorBuilder
(
)
{
}
void
DescriptorBuilder
:
:
AddError
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
error
)
{
if
(
error_collector_
=
=
nullptr
)
{
if
(
!
had_errors_
)
{
GOOGLE_LOG
(
ERROR
)
<
<
"
Invalid
proto
descriptor
for
file
\
"
"
<
<
filename_
<
<
"
\
"
:
"
;
}
GOOGLE_LOG
(
ERROR
)
<
<
"
"
<
<
element_name
<
<
"
:
"
<
<
error
;
}
else
{
error_collector_
-
>
AddError
(
filename_
element_name
&
descriptor
location
error
)
;
}
had_errors_
=
true
;
}
void
DescriptorBuilder
:
:
AddError
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
char
*
error
)
{
AddError
(
element_name
descriptor
location
std
:
:
string
(
error
)
)
;
}
void
DescriptorBuilder
:
:
AddNotDefinedError
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
undefined_symbol
)
{
if
(
possible_undeclared_dependency_
=
=
nullptr
&
&
undefine_resolved_name_
.
empty
(
)
)
{
AddError
(
element_name
descriptor
location
"
\
"
"
+
undefined_symbol
+
"
\
"
is
not
defined
.
"
)
;
}
else
{
if
(
possible_undeclared_dependency_
!
=
nullptr
)
{
AddError
(
element_name
descriptor
location
"
\
"
"
+
possible_undeclared_dependency_name_
+
"
\
"
seems
to
be
defined
in
\
"
"
+
possible_undeclared_dependency_
-
>
name
(
)
+
"
\
"
which
is
not
"
"
imported
by
\
"
"
+
filename_
+
"
\
"
.
To
use
it
here
please
"
"
add
the
necessary
import
.
"
)
;
}
if
(
!
undefine_resolved_name_
.
empty
(
)
)
{
AddError
(
element_name
descriptor
location
"
\
"
"
+
undefined_symbol
+
"
\
"
is
resolved
to
\
"
"
+
undefine_resolved_name_
+
"
\
"
which
is
not
defined
.
"
"
The
innermost
scope
is
searched
first
in
name
resolution
.
"
"
Consider
using
a
leading
'
.
'
(
i
.
e
.
\
"
.
"
+
undefined_symbol
+
"
\
"
)
to
start
from
the
outermost
scope
.
"
)
;
}
}
}
void
DescriptorBuilder
:
:
AddWarning
(
const
std
:
:
string
&
element_name
const
Message
&
descriptor
DescriptorPool
:
:
ErrorCollector
:
:
ErrorLocation
location
const
std
:
:
string
&
error
)
{
if
(
error_collector_
=
=
nullptr
)
{
GOOGLE_LOG
(
WARNING
)
<
<
filename_
<
<
"
"
<
<
element_name
<
<
"
:
"
<
<
error
;
}
else
{
error_collector_
-
>
AddWarning
(
filename_
element_name
&
descriptor
location
error
)
;
}
}
bool
DescriptorBuilder
:
:
IsInPackage
(
const
FileDescriptor
*
file
const
std
:
:
string
&
package_name
)
{
return
HasPrefixString
(
file
-
>
package
(
)
package_name
)
&
&
(
file
-
>
package
(
)
.
size
(
)
=
=
package_name
.
size
(
)
|
|
file
-
>
package
(
)
[
package_name
.
size
(
)
]
=
=
'
.
'
)
;
}
void
DescriptorBuilder
:
:
RecordPublicDependencies
(
const
FileDescriptor
*
file
)
{
if
(
file
=
=
nullptr
|
|
!
dependencies_
.
insert
(
file
)
.
second
)
return
;
for
(
int
i
=
0
;
file
!
=
nullptr
&
&
i
<
file
-
>
public_dependency_count
(
)
;
i
+
+
)
{
RecordPublicDependencies
(
file
-
>
public_dependency
(
i
)
)
;
}
}
Symbol
DescriptorBuilder
:
:
FindSymbolNotEnforcingDepsHelper
(
const
DescriptorPool
*
pool
const
std
:
:
string
&
name
bool
build_it
)
{
MutexLockMaybe
lock
(
(
pool
=
=
pool_
)
?
nullptr
:
pool
-
>
mutex_
)
;
Symbol
result
=
pool
-
>
tables_
-
>
FindSymbol
(
name
)
;
if
(
result
.
IsNull
(
)
&
&
pool
-
>
underlay_
!
=
nullptr
)
{
result
=
FindSymbolNotEnforcingDepsHelper
(
pool
-
>
underlay_
name
)
;
}
if
(
result
.
IsNull
(
)
)
{
if
(
build_it
&
&
pool
-
>
TryFindSymbolInFallbackDatabase
(
name
)
)
{
result
=
pool
-
>
tables_
-
>
FindSymbol
(
name
)
;
}
}
return
result
;
}
Symbol
DescriptorBuilder
:
:
FindSymbolNotEnforcingDeps
(
const
std
:
:
string
&
name
bool
build_it
)
{
Symbol
result
=
FindSymbolNotEnforcingDepsHelper
(
pool_
name
build_it
)
;
const
FileDescriptor
*
file
=
result
.
GetFile
(
)
;
if
(
file
=
=
file_
|
|
dependencies_
.
count
(
file
)
>
0
)
{
unused_dependency_
.
erase
(
file
)
;
}
return
result
;
}
Symbol
DescriptorBuilder
:
:
FindSymbol
(
const
std
:
:
string
&
name
bool
build_it
)
{
Symbol
result
=
FindSymbolNotEnforcingDeps
(
name
build_it
)
;
if
(
result
.
IsNull
(
)
)
return
result
;
if
(
!
pool_
-
>
enforce_dependencies_
)
{
return
result
;
}
const
FileDescriptor
*
file
=
result
.
GetFile
(
)
;
if
(
file
=
=
file_
|
|
dependencies_
.
count
(
file
)
>
0
)
{
return
result
;
}
if
(
result
.
IsPackage
(
)
)
{
if
(
IsInPackage
(
file_
name
)
)
return
result
;
for
(
std
:
:
set
<
const
FileDescriptor
*
>
:
:
const_iterator
it
=
dependencies_
.
begin
(
)
;
it
!
=
dependencies_
.
end
(
)
;
+
+
it
)
{
if
(
*
it
!
=
nullptr
&
&
IsInPackage
(
*
it
name
)
)
return
result
;
}
}
possible_undeclared_dependency_
=
file
;
possible_undeclared_dependency_name_
=
name
;
return
Symbol
(
)
;
}
Symbol
DescriptorBuilder
:
:
LookupSymbolNoPlaceholder
(
const
std
:
:
string
&
name
const
std
:
:
string
&
relative_to
ResolveMode
resolve_mode
bool
build_it
)
{
possible_undeclared_dependency_
=
nullptr
;
undefine_resolved_name_
.
clear
(
)
;
if
(
!
name
.
empty
(
)
&
&
name
[
0
]
=
=
'
.
'
)
{
return
FindSymbol
(
name
.
substr
(
1
)
build_it
)
;
}
std
:
:
string
:
:
size_type
name_dot_pos
=
name
.
find_first_of
(
'
.
'
)
;
std
:
:
string
first_part_of_name
;
if
(
name_dot_pos
=
=
std
:
:
string
:
:
npos
)
{
first_part_of_name
=
name
;
}
else
{
first_part_of_name
=
name
.
substr
(
0
name_dot_pos
)
;
}
std
:
:
string
scope_to_try
(
relative_to
)
;
while
(
true
)
{
std
:
:
string
:
:
size_type
dot_pos
=
scope_to_try
.
find_last_of
(
'
.
'
)
;
if
(
dot_pos
=
=
std
:
:
string
:
:
npos
)
{
return
FindSymbol
(
name
build_it
)
;
}
else
{
scope_to_try
.
erase
(
dot_pos
)
;
}
std
:
:
string
:
:
size_type
old_size
=
scope_to_try
.
size
(
)
;
scope_to_try
.
append
(
1
'
.
'
)
;
scope_to_try
.
append
(
first_part_of_name
)
;
Symbol
result
=
FindSymbol
(
scope_to_try
build_it
)
;
if
(
!
result
.
IsNull
(
)
)
{
if
(
first_part_of_name
.
size
(
)
<
name
.
size
(
)
)
{
if
(
result
.
IsAggregate
(
)
)
{
scope_to_try
.
append
(
name
first_part_of_name
.
size
(
)
name
.
size
(
)
-
first_part_of_name
.
size
(
)
)
;
result
=
FindSymbol
(
scope_to_try
build_it
)
;
if
(
result
.
IsNull
(
)
)
{
undefine_resolved_name_
=
scope_to_try
;
}
return
result
;
}
else
{
}
}
else
{
if
(
resolve_mode
=
=
LOOKUP_TYPES
&
&
!
result
.
IsType
(
)
)
{
}
else
{
return
result
;
}
}
}
scope_to_try
.
erase
(
old_size
)
;
}
}
Symbol
DescriptorBuilder
:
:
LookupSymbol
(
const
std
:
:
string
&
name
const
std
:
:
string
&
relative_to
DescriptorPool
:
:
PlaceholderType
placeholder_type
ResolveMode
resolve_mode
bool
build_it
)
{
Symbol
result
=
LookupSymbolNoPlaceholder
(
name
relative_to
resolve_mode
build_it
)
;
if
(
result
.
IsNull
(
)
&
&
pool_
-
>
allow_unknown_
)
{
result
=
pool_
-
>
NewPlaceholderWithMutexHeld
(
name
placeholder_type
)
;
}
return
result
;
}
static
bool
ValidateQualifiedName
(
StringPiece
name
)
{
bool
last_was_period
=
false
;
for
(
char
character
:
name
)
{
if
(
(
'
a
'
<
=
character
&
&
character
<
=
'
z
'
)
|
|
(
'
A
'
<
=
character
&
&
character
<
=
'
Z
'
)
|
|
(
'
0
'
<
=
character
&
&
character
<
=
'
9
'
)
|
|
(
character
=
=
'
_
'
)
)
{
last_was_period
=
false
;
}
else
if
(
character
=
=
'
.
'
)
{
if
(
last_was_period
)
return
false
;
last_was_period
=
true
;
}
else
{
return
false
;
}
}
return
!
name
.
empty
(
)
&
&
!
last_was_period
;
}
Symbol
DescriptorPool
:
:
NewPlaceholder
(
StringPiece
name
PlaceholderType
placeholder_type
)
const
{
MutexLockMaybe
lock
(
mutex_
)
;
return
NewPlaceholderWithMutexHeld
(
name
placeholder_type
)
;
}
Symbol
DescriptorPool
:
:
NewPlaceholderWithMutexHeld
(
StringPiece
name
PlaceholderType
placeholder_type
)
const
{
if
(
mutex_
)
{
mutex_
-
>
AssertHeld
(
)
;
}
StringPiece
placeholder_full_name
;
StringPiece
placeholder_name
;
const
std
:
:
string
*
placeholder_package
;
if
(
!
ValidateQualifiedName
(
name
)
)
return
Symbol
(
)
;
if
(
name
[
0
]
=
=
'
.
'
)
{
placeholder_full_name
=
name
.
substr
(
1
)
;
}
else
{
placeholder_full_name
=
name
;
}
internal
:
:
FlatAllocator
alloc
;
alloc
.
PlanArray
<
FileDescriptor
>
(
1
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
2
)
;
if
(
placeholder_type
=
=
PLACEHOLDER_ENUM
)
{
alloc
.
PlanArray
<
EnumDescriptor
>
(
1
)
;
alloc
.
PlanArray
<
EnumValueDescriptor
>
(
1
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
2
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
2
)
;
}
else
{
alloc
.
PlanArray
<
Descriptor
>
(
1
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
2
)
;
if
(
placeholder_type
=
=
PLACEHOLDER_EXTENDABLE_MESSAGE
)
{
alloc
.
PlanArray
<
Descriptor
:
:
ExtensionRange
>
(
1
)
;
}
}
alloc
.
FinalizePlanning
(
tables_
)
;
const
std
:
:
string
:
:
size_type
dotpos
=
placeholder_full_name
.
find_last_of
(
'
.
'
)
;
if
(
dotpos
!
=
std
:
:
string
:
:
npos
)
{
placeholder_package
=
alloc
.
AllocateStrings
(
placeholder_full_name
.
substr
(
0
dotpos
)
)
;
placeholder_name
=
placeholder_full_name
.
substr
(
dotpos
+
1
)
;
}
else
{
placeholder_package
=
alloc
.
AllocateStrings
(
"
"
)
;
placeholder_name
=
placeholder_full_name
;
}
FileDescriptor
*
placeholder_file
=
NewPlaceholderFileWithMutexHeld
(
StrCat
(
placeholder_full_name
"
.
placeholder
.
proto
"
)
alloc
)
;
placeholder_file
-
>
package_
=
placeholder_package
;
if
(
placeholder_type
=
=
PLACEHOLDER_ENUM
)
{
placeholder_file
-
>
enum_type_count_
=
1
;
placeholder_file
-
>
enum_types_
=
alloc
.
AllocateArray
<
EnumDescriptor
>
(
1
)
;
EnumDescriptor
*
placeholder_enum
=
&
placeholder_file
-
>
enum_types_
[
0
]
;
memset
(
static_cast
<
void
*
>
(
placeholder_enum
)
0
sizeof
(
*
placeholder_enum
)
)
;
placeholder_enum
-
>
all_names_
=
alloc
.
AllocateStrings
(
placeholder_name
placeholder_full_name
)
;
placeholder_enum
-
>
file_
=
placeholder_file
;
placeholder_enum
-
>
options_
=
&
EnumOptions
:
:
default_instance
(
)
;
placeholder_enum
-
>
is_placeholder_
=
true
;
placeholder_enum
-
>
is_unqualified_placeholder_
=
(
name
[
0
]
!
=
'
.
'
)
;
placeholder_enum
-
>
value_count_
=
1
;
placeholder_enum
-
>
values_
=
alloc
.
AllocateArray
<
EnumValueDescriptor
>
(
1
)
;
placeholder_enum
-
>
sequential_value_limit_
=
-
1
;
EnumValueDescriptor
*
placeholder_value
=
&
placeholder_enum
-
>
values_
[
0
]
;
memset
(
static_cast
<
void
*
>
(
placeholder_value
)
0
sizeof
(
*
placeholder_value
)
)
;
placeholder_value
-
>
all_names_
=
alloc
.
AllocateStrings
(
"
PLACEHOLDER_VALUE
"
placeholder_package
-
>
empty
(
)
?
"
PLACEHOLDER_VALUE
"
:
*
placeholder_package
+
"
.
PLACEHOLDER_VALUE
"
)
;
placeholder_value
-
>
number_
=
0
;
placeholder_value
-
>
type_
=
placeholder_enum
;
placeholder_value
-
>
options_
=
&
EnumValueOptions
:
:
default_instance
(
)
;
return
Symbol
(
placeholder_enum
)
;
}
else
{
placeholder_file
-
>
message_type_count_
=
1
;
placeholder_file
-
>
message_types_
=
alloc
.
AllocateArray
<
Descriptor
>
(
1
)
;
Descriptor
*
placeholder_message
=
&
placeholder_file
-
>
message_types_
[
0
]
;
memset
(
static_cast
<
void
*
>
(
placeholder_message
)
0
sizeof
(
*
placeholder_message
)
)
;
placeholder_message
-
>
all_names_
=
alloc
.
AllocateStrings
(
placeholder_name
placeholder_full_name
)
;
placeholder_message
-
>
file_
=
placeholder_file
;
placeholder_message
-
>
options_
=
&
MessageOptions
:
:
default_instance
(
)
;
placeholder_message
-
>
is_placeholder_
=
true
;
placeholder_message
-
>
is_unqualified_placeholder_
=
(
name
[
0
]
!
=
'
.
'
)
;
if
(
placeholder_type
=
=
PLACEHOLDER_EXTENDABLE_MESSAGE
)
{
placeholder_message
-
>
extension_range_count_
=
1
;
placeholder_message
-
>
extension_ranges_
=
alloc
.
AllocateArray
<
Descriptor
:
:
ExtensionRange
>
(
1
)
;
placeholder_message
-
>
extension_ranges_
[
0
]
.
start
=
1
;
placeholder_message
-
>
extension_ranges_
[
0
]
.
end
=
FieldDescriptor
:
:
kMaxNumber
+
1
;
placeholder_message
-
>
extension_ranges_
[
0
]
.
options_
=
nullptr
;
}
return
Symbol
(
placeholder_message
)
;
}
}
FileDescriptor
*
DescriptorPool
:
:
NewPlaceholderFile
(
StringPiece
name
)
const
{
MutexLockMaybe
lock
(
mutex_
)
;
internal
:
:
FlatAllocator
alloc
;
alloc
.
PlanArray
<
FileDescriptor
>
(
1
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
1
)
;
alloc
.
FinalizePlanning
(
tables_
)
;
return
NewPlaceholderFileWithMutexHeld
(
name
alloc
)
;
}
FileDescriptor
*
DescriptorPool
:
:
NewPlaceholderFileWithMutexHeld
(
StringPiece
name
internal
:
:
FlatAllocator
&
alloc
)
const
{
if
(
mutex_
)
{
mutex_
-
>
AssertHeld
(
)
;
}
FileDescriptor
*
placeholder
=
alloc
.
AllocateArray
<
FileDescriptor
>
(
1
)
;
memset
(
static_cast
<
void
*
>
(
placeholder
)
0
sizeof
(
*
placeholder
)
)
;
placeholder
-
>
name_
=
alloc
.
AllocateStrings
(
name
)
;
placeholder
-
>
package_
=
&
internal
:
:
GetEmptyString
(
)
;
placeholder
-
>
pool_
=
this
;
placeholder
-
>
options_
=
&
FileOptions
:
:
default_instance
(
)
;
placeholder
-
>
tables_
=
&
FileDescriptorTables
:
:
GetEmptyInstance
(
)
;
placeholder
-
>
source_code_info_
=
&
SourceCodeInfo
:
:
default_instance
(
)
;
placeholder
-
>
is_placeholder_
=
true
;
placeholder
-
>
syntax_
=
FileDescriptor
:
:
SYNTAX_UNKNOWN
;
placeholder
-
>
finished_building_
=
true
;
return
placeholder
;
}
bool
DescriptorBuilder
:
:
AddSymbol
(
const
std
:
:
string
&
full_name
const
void
*
parent
const
std
:
:
string
&
name
const
Message
&
proto
Symbol
symbol
)
{
if
(
parent
=
=
nullptr
)
parent
=
file_
;
if
(
full_name
.
find
(
'
\
0
'
)
!
=
std
:
:
string
:
:
npos
)
{
AddError
(
full_name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
\
"
"
+
full_name
+
"
\
"
contains
null
character
.
"
)
;
return
false
;
}
if
(
tables_
-
>
AddSymbol
(
full_name
symbol
)
)
{
if
(
!
file_tables_
-
>
AddAliasUnderParent
(
parent
name
symbol
)
)
{
if
(
!
had_errors_
)
{
GOOGLE_LOG
(
DFATAL
)
<
<
"
\
"
"
<
<
full_name
<
<
"
\
"
not
previously
defined
in
"
"
symbols_by_name_
but
was
defined
in
"
"
symbols_by_parent_
;
this
shouldn
'
t
be
possible
.
"
;
}
return
false
;
}
return
true
;
}
else
{
const
FileDescriptor
*
other_file
=
tables_
-
>
FindSymbol
(
full_name
)
.
GetFile
(
)
;
if
(
other_file
=
=
file_
)
{
std
:
:
string
:
:
size_type
dot_pos
=
full_name
.
find_last_of
(
'
.
'
)
;
if
(
dot_pos
=
=
std
:
:
string
:
:
npos
)
{
AddError
(
full_name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
\
"
"
+
full_name
+
"
\
"
is
already
defined
.
"
)
;
}
else
{
AddError
(
full_name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
\
"
"
+
full_name
.
substr
(
dot_pos
+
1
)
+
"
\
"
is
already
defined
in
\
"
"
+
full_name
.
substr
(
0
dot_pos
)
+
"
\
"
.
"
)
;
}
}
else
{
AddError
(
full_name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
\
"
"
+
full_name
+
"
\
"
is
already
defined
in
file
\
"
"
+
(
other_file
=
=
nullptr
?
"
null
"
:
other_file
-
>
name
(
)
)
+
"
\
"
.
"
)
;
}
return
false
;
}
}
void
DescriptorBuilder
:
:
AddPackage
(
const
std
:
:
string
&
name
const
Message
&
proto
FileDescriptor
*
file
)
{
if
(
name
.
find
(
'
\
0
'
)
!
=
std
:
:
string
:
:
npos
)
{
AddError
(
name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
\
"
"
+
name
+
"
\
"
contains
null
character
.
"
)
;
return
;
}
Symbol
existing_symbol
=
tables_
-
>
FindSymbol
(
name
)
;
if
(
existing_symbol
.
IsNull
(
)
)
{
if
(
&
name
=
=
&
file
-
>
package
(
)
)
{
tables_
-
>
AddSymbol
(
file
-
>
package
(
)
Symbol
(
file
)
)
;
}
else
{
auto
*
package
=
tables_
-
>
Allocate
<
Symbol
:
:
Subpackage
>
(
)
;
package
-
>
name_size
=
static_cast
<
int
>
(
name
.
size
(
)
)
;
package
-
>
file
=
file
;
tables_
-
>
AddSymbol
(
name
Symbol
(
package
)
)
;
}
std
:
:
string
:
:
size_type
dot_pos
=
name
.
find_last_of
(
'
.
'
)
;
if
(
dot_pos
=
=
std
:
:
string
:
:
npos
)
{
ValidateSymbolName
(
name
name
proto
)
;
}
else
{
AddPackage
(
name
.
substr
(
0
dot_pos
)
proto
file
)
;
ValidateSymbolName
(
name
.
substr
(
dot_pos
+
1
)
name
proto
)
;
}
}
else
if
(
!
existing_symbol
.
IsPackage
(
)
)
{
const
FileDescriptor
*
other_file
=
existing_symbol
.
GetFile
(
)
;
AddError
(
name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
\
"
"
+
name
+
"
\
"
is
already
defined
(
as
something
other
than
"
"
a
package
)
in
file
\
"
"
+
(
other_file
=
=
nullptr
?
"
null
"
:
other_file
-
>
name
(
)
)
+
"
\
"
.
"
)
;
}
}
void
DescriptorBuilder
:
:
ValidateSymbolName
(
const
std
:
:
string
&
name
const
std
:
:
string
&
full_name
const
Message
&
proto
)
{
if
(
name
.
empty
(
)
)
{
AddError
(
full_name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Missing
name
.
"
)
;
}
else
{
for
(
char
character
:
name
)
{
if
(
(
character
<
'
a
'
|
|
'
z
'
<
character
)
&
&
(
character
<
'
A
'
|
|
'
Z
'
<
character
)
&
&
(
character
<
'
0
'
|
|
'
9
'
<
character
)
&
&
(
character
!
=
'
_
'
)
)
{
AddError
(
full_name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
\
"
"
+
name
+
"
\
"
is
not
a
valid
identifier
.
"
)
;
return
;
}
}
}
}
template
<
class
DescriptorT
>
void
DescriptorBuilder
:
:
AllocateOptions
(
const
typename
DescriptorT
:
:
OptionsType
&
orig_options
DescriptorT
*
descriptor
int
options_field_tag
const
std
:
:
string
&
option_name
internal
:
:
FlatAllocator
&
alloc
)
{
std
:
:
vector
<
int
>
options_path
;
descriptor
-
>
GetLocationPath
(
&
options_path
)
;
options_path
.
push_back
(
options_field_tag
)
;
AllocateOptionsImpl
(
descriptor
-
>
full_name
(
)
descriptor
-
>
full_name
(
)
orig_options
descriptor
options_path
option_name
alloc
)
;
}
void
DescriptorBuilder
:
:
AllocateOptions
(
const
FileOptions
&
orig_options
FileDescriptor
*
descriptor
internal
:
:
FlatAllocator
&
alloc
)
{
std
:
:
vector
<
int
>
options_path
;
options_path
.
push_back
(
FileDescriptorProto
:
:
kOptionsFieldNumber
)
;
AllocateOptionsImpl
(
descriptor
-
>
package
(
)
+
"
.
dummy
"
descriptor
-
>
name
(
)
orig_options
descriptor
options_path
"
google
.
protobuf
.
FileOptions
"
alloc
)
;
}
template
<
class
DescriptorT
>
void
DescriptorBuilder
:
:
AllocateOptionsImpl
(
const
std
:
:
string
&
name_scope
const
std
:
:
string
&
element_name
const
typename
DescriptorT
:
:
OptionsType
&
orig_options
DescriptorT
*
descriptor
const
std
:
:
vector
<
int
>
&
options_path
const
std
:
:
string
&
option_name
internal
:
:
FlatAllocator
&
alloc
)
{
auto
*
options
=
alloc
.
AllocateArray
<
typename
DescriptorT
:
:
OptionsType
>
(
1
)
;
if
(
!
orig_options
.
IsInitialized
(
)
)
{
AddError
(
name_scope
+
"
.
"
+
element_name
orig_options
DescriptorPool
:
:
ErrorCollector
:
:
OPTION_NAME
"
Uninterpreted
option
is
missing
name
or
value
.
"
)
;
return
;
}
options
-
>
ParseFromString
(
orig_options
.
SerializeAsString
(
)
)
;
descriptor
-
>
options_
=
options
;
if
(
options
-
>
uninterpreted_option_size
(
)
>
0
)
{
options_to_interpret_
.
push_back
(
OptionsToInterpret
(
name_scope
element_name
options_path
&
orig_options
options
)
)
;
}
const
UnknownFieldSet
&
unknown_fields
=
orig_options
.
unknown_fields
(
)
;
if
(
!
unknown_fields
.
empty
(
)
)
{
Symbol
msg_symbol
=
tables_
-
>
FindSymbol
(
option_name
)
;
if
(
msg_symbol
.
type
(
)
=
=
Symbol
:
:
MESSAGE
)
{
for
(
int
i
=
0
;
i
<
unknown_fields
.
field_count
(
)
;
+
+
i
)
{
assert_mutex_held
(
pool_
)
;
const
FieldDescriptor
*
field
=
pool_
-
>
InternalFindExtensionByNumberNoLock
(
msg_symbol
.
descriptor
(
)
unknown_fields
.
field
(
i
)
.
number
(
)
)
;
if
(
field
)
{
unused_dependency_
.
erase
(
field
-
>
file
(
)
)
;
}
}
}
}
}
#
define
BUILD_ARRAY
(
INPUT
OUTPUT
NAME
METHOD
PARENT
)
\
OUTPUT
-
>
NAME
#
#
_count_
=
INPUT
.
NAME
#
#
_size
(
)
;
\
OUTPUT
-
>
NAME
#
#
s_
=
alloc
.
AllocateArray
<
\
typename
std
:
:
remove_pointer
<
decltype
(
OUTPUT
-
>
NAME
#
#
s_
)
>
:
:
type
>
(
\
INPUT
.
NAME
#
#
_size
(
)
)
;
\
for
(
int
i
=
0
;
i
<
INPUT
.
NAME
#
#
_size
(
)
;
i
+
+
)
{
\
METHOD
(
INPUT
.
NAME
(
i
)
PARENT
OUTPUT
-
>
NAME
#
#
s_
+
i
alloc
)
;
\
}
void
DescriptorBuilder
:
:
AddRecursiveImportError
(
const
FileDescriptorProto
&
proto
int
from_here
)
{
std
:
:
string
error_message
(
"
File
recursively
imports
itself
:
"
)
;
for
(
size_t
i
=
from_here
;
i
<
tables_
-
>
pending_files_
.
size
(
)
;
i
+
+
)
{
error_message
.
append
(
tables_
-
>
pending_files_
[
i
]
)
;
error_message
.
append
(
"
-
>
"
)
;
}
error_message
.
append
(
proto
.
name
(
)
)
;
if
(
static_cast
<
size_t
>
(
from_here
)
<
tables_
-
>
pending_files_
.
size
(
)
-
1
)
{
AddError
(
tables_
-
>
pending_files_
[
from_here
+
1
]
proto
DescriptorPool
:
:
ErrorCollector
:
:
IMPORT
error_message
)
;
}
else
{
AddError
(
proto
.
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
IMPORT
error_message
)
;
}
}
void
DescriptorBuilder
:
:
AddTwiceListedError
(
const
FileDescriptorProto
&
proto
int
index
)
{
AddError
(
proto
.
dependency
(
index
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
IMPORT
"
Import
\
"
"
+
proto
.
dependency
(
index
)
+
"
\
"
was
listed
twice
.
"
)
;
}
void
DescriptorBuilder
:
:
AddImportError
(
const
FileDescriptorProto
&
proto
int
index
)
{
std
:
:
string
message
;
if
(
pool_
-
>
fallback_database_
=
=
nullptr
)
{
message
=
"
Import
\
"
"
+
proto
.
dependency
(
index
)
+
"
\
"
has
not
been
loaded
.
"
;
}
else
{
message
=
"
Import
\
"
"
+
proto
.
dependency
(
index
)
+
"
\
"
was
not
found
or
had
errors
.
"
;
}
AddError
(
proto
.
dependency
(
index
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
IMPORT
message
)
;
}
static
bool
ExistingFileMatchesProto
(
const
FileDescriptor
*
existing_file
const
FileDescriptorProto
&
proto
)
{
FileDescriptorProto
existing_proto
;
existing_file
-
>
CopyTo
(
&
existing_proto
)
;
if
(
existing_file
-
>
syntax
(
)
=
=
FileDescriptor
:
:
SYNTAX_PROTO2
&
&
proto
.
has_syntax
(
)
)
{
existing_proto
.
set_syntax
(
existing_file
-
>
SyntaxName
(
existing_file
-
>
syntax
(
)
)
)
;
}
return
existing_proto
.
SerializeAsString
(
)
=
=
proto
.
SerializeAsString
(
)
;
}
static
void
PlanAllocationSize
(
const
RepeatedPtrField
<
EnumValueDescriptorProto
>
&
values
internal
:
:
FlatAllocator
&
alloc
)
{
alloc
.
PlanArray
<
EnumValueDescriptor
>
(
values
.
size
(
)
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
2
*
values
.
size
(
)
)
;
for
(
const
auto
&
v
:
values
)
{
if
(
v
.
has_options
(
)
)
alloc
.
PlanArray
<
EnumValueOptions
>
(
1
)
;
}
}
static
void
PlanAllocationSize
(
const
RepeatedPtrField
<
EnumDescriptorProto
>
&
enums
internal
:
:
FlatAllocator
&
alloc
)
{
alloc
.
PlanArray
<
EnumDescriptor
>
(
enums
.
size
(
)
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
2
*
enums
.
size
(
)
)
;
for
(
const
auto
&
e
:
enums
)
{
if
(
e
.
has_options
(
)
)
alloc
.
PlanArray
<
EnumOptions
>
(
1
)
;
PlanAllocationSize
(
e
.
value
(
)
alloc
)
;
alloc
.
PlanArray
<
EnumDescriptor
:
:
ReservedRange
>
(
e
.
reserved_range_size
(
)
)
;
alloc
.
PlanArray
<
const
std
:
:
string
*
>
(
e
.
reserved_name_size
(
)
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
e
.
reserved_name_size
(
)
)
;
}
}
static
void
PlanAllocationSize
(
const
RepeatedPtrField
<
OneofDescriptorProto
>
&
oneofs
internal
:
:
FlatAllocator
&
alloc
)
{
alloc
.
PlanArray
<
OneofDescriptor
>
(
oneofs
.
size
(
)
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
2
*
oneofs
.
size
(
)
)
;
for
(
const
auto
&
oneof
:
oneofs
)
{
if
(
oneof
.
has_options
(
)
)
alloc
.
PlanArray
<
OneofOptions
>
(
1
)
;
}
}
static
void
PlanAllocationSize
(
const
RepeatedPtrField
<
FieldDescriptorProto
>
&
fields
internal
:
:
FlatAllocator
&
alloc
)
{
alloc
.
PlanArray
<
FieldDescriptor
>
(
fields
.
size
(
)
)
;
for
(
const
auto
&
field
:
fields
)
{
if
(
field
.
has_options
(
)
)
alloc
.
PlanArray
<
FieldOptions
>
(
1
)
;
alloc
.
PlanFieldNames
(
field
.
name
(
)
field
.
has_json_name
(
)
?
&
field
.
json_name
(
)
:
nullptr
)
;
if
(
field
.
has_default_value
(
)
&
&
field
.
has_type
(
)
&
&
(
field
.
type
(
)
=
=
FieldDescriptorProto
:
:
TYPE_STRING
|
|
field
.
type
(
)
=
=
FieldDescriptorProto
:
:
TYPE_BYTES
)
)
{
alloc
.
PlanArray
<
std
:
:
string
>
(
1
)
;
}
}
}
static
void
PlanAllocationSize
(
const
RepeatedPtrField
<
DescriptorProto
:
:
ExtensionRange
>
&
ranges
internal
:
:
FlatAllocator
&
alloc
)
{
alloc
.
PlanArray
<
Descriptor
:
:
ExtensionRange
>
(
ranges
.
size
(
)
)
;
for
(
const
auto
&
r
:
ranges
)
{
if
(
r
.
has_options
(
)
)
alloc
.
PlanArray
<
ExtensionRangeOptions
>
(
1
)
;
}
}
static
void
PlanAllocationSize
(
const
RepeatedPtrField
<
DescriptorProto
>
&
messages
internal
:
:
FlatAllocator
&
alloc
)
{
alloc
.
PlanArray
<
Descriptor
>
(
messages
.
size
(
)
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
2
*
messages
.
size
(
)
)
;
for
(
const
auto
&
message
:
messages
)
{
if
(
message
.
has_options
(
)
)
alloc
.
PlanArray
<
MessageOptions
>
(
1
)
;
PlanAllocationSize
(
message
.
nested_type
(
)
alloc
)
;
PlanAllocationSize
(
message
.
field
(
)
alloc
)
;
PlanAllocationSize
(
message
.
extension
(
)
alloc
)
;
PlanAllocationSize
(
message
.
extension_range
(
)
alloc
)
;
alloc
.
PlanArray
<
Descriptor
:
:
ReservedRange
>
(
message
.
reserved_range_size
(
)
)
;
alloc
.
PlanArray
<
const
std
:
:
string
*
>
(
message
.
reserved_name_size
(
)
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
message
.
reserved_name_size
(
)
)
;
PlanAllocationSize
(
message
.
enum_type
(
)
alloc
)
;
PlanAllocationSize
(
message
.
oneof_decl
(
)
alloc
)
;
}
}
static
void
PlanAllocationSize
(
const
RepeatedPtrField
<
MethodDescriptorProto
>
&
methods
internal
:
:
FlatAllocator
&
alloc
)
{
alloc
.
PlanArray
<
MethodDescriptor
>
(
methods
.
size
(
)
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
2
*
methods
.
size
(
)
)
;
for
(
const
auto
&
m
:
methods
)
{
if
(
m
.
has_options
(
)
)
alloc
.
PlanArray
<
MethodOptions
>
(
1
)
;
}
}
static
void
PlanAllocationSize
(
const
RepeatedPtrField
<
ServiceDescriptorProto
>
&
services
internal
:
:
FlatAllocator
&
alloc
)
{
alloc
.
PlanArray
<
ServiceDescriptor
>
(
services
.
size
(
)
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
2
*
services
.
size
(
)
)
;
for
(
const
auto
&
service
:
services
)
{
if
(
service
.
has_options
(
)
)
alloc
.
PlanArray
<
ServiceOptions
>
(
1
)
;
PlanAllocationSize
(
service
.
method
(
)
alloc
)
;
}
}
static
void
PlanAllocationSize
(
const
FileDescriptorProto
&
proto
internal
:
:
FlatAllocator
&
alloc
)
{
alloc
.
PlanArray
<
FileDescriptor
>
(
1
)
;
alloc
.
PlanArray
<
FileDescriptorTables
>
(
1
)
;
alloc
.
PlanArray
<
std
:
:
string
>
(
2
)
;
if
(
proto
.
has_options
(
)
)
alloc
.
PlanArray
<
FileOptions
>
(
1
)
;
if
(
proto
.
has_source_code_info
(
)
)
alloc
.
PlanArray
<
SourceCodeInfo
>
(
1
)
;
PlanAllocationSize
(
proto
.
service
(
)
alloc
)
;
PlanAllocationSize
(
proto
.
message_type
(
)
alloc
)
;
PlanAllocationSize
(
proto
.
enum_type
(
)
alloc
)
;
PlanAllocationSize
(
proto
.
extension
(
)
alloc
)
;
alloc
.
PlanArray
<
int
>
(
proto
.
weak_dependency_size
(
)
)
;
alloc
.
PlanArray
<
int
>
(
proto
.
public_dependency_size
(
)
)
;
alloc
.
PlanArray
<
const
FileDescriptor
*
>
(
proto
.
dependency_size
(
)
)
;
}
const
FileDescriptor
*
DescriptorBuilder
:
:
BuildFile
(
const
FileDescriptorProto
&
proto
)
{
filename_
=
proto
.
name
(
)
;
const
FileDescriptor
*
existing_file
=
tables_
-
>
FindFile
(
filename_
)
;
if
(
existing_file
!
=
nullptr
)
{
if
(
ExistingFileMatchesProto
(
existing_file
proto
)
)
{
return
existing_file
;
}
}
for
(
size_t
i
=
0
;
i
<
tables_
-
>
pending_files_
.
size
(
)
;
i
+
+
)
{
if
(
tables_
-
>
pending_files_
[
i
]
=
=
proto
.
name
(
)
)
{
AddRecursiveImportError
(
proto
i
)
;
return
nullptr
;
}
}
static
const
int
kMaximumPackageLength
=
511
;
if
(
proto
.
package
(
)
.
size
(
)
>
kMaximumPackageLength
)
{
AddError
(
proto
.
package
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Package
name
is
too
long
"
)
;
return
nullptr
;
}
if
(
!
pool_
-
>
lazily_build_dependencies_
)
{
if
(
pool_
-
>
fallback_database_
!
=
nullptr
)
{
tables_
-
>
pending_files_
.
push_back
(
proto
.
name
(
)
)
;
for
(
int
i
=
0
;
i
<
proto
.
dependency_size
(
)
;
i
+
+
)
{
if
(
tables_
-
>
FindFile
(
proto
.
dependency
(
i
)
)
=
=
nullptr
&
&
(
pool_
-
>
underlay_
=
=
nullptr
|
|
pool_
-
>
underlay_
-
>
FindFileByName
(
proto
.
dependency
(
i
)
)
=
=
nullptr
)
)
{
pool_
-
>
TryFindFileInFallbackDatabase
(
proto
.
dependency
(
i
)
)
;
}
}
tables_
-
>
pending_files_
.
pop_back
(
)
;
}
}
tables_
-
>
AddCheckpoint
(
)
;
internal
:
:
FlatAllocator
alloc
;
PlanAllocationSize
(
proto
alloc
)
;
alloc
.
FinalizePlanning
(
tables_
)
;
FileDescriptor
*
result
=
BuildFileImpl
(
proto
alloc
)
;
file_tables_
-
>
FinalizeTables
(
)
;
if
(
result
)
{
tables_
-
>
ClearLastCheckpoint
(
)
;
result
-
>
finished_building_
=
true
;
alloc
.
ExpectConsumed
(
)
;
}
else
{
tables_
-
>
RollbackToLastCheckpoint
(
)
;
}
return
result
;
}
FileDescriptor
*
DescriptorBuilder
:
:
BuildFileImpl
(
const
FileDescriptorProto
&
proto
internal
:
:
FlatAllocator
&
alloc
)
{
FileDescriptor
*
result
=
alloc
.
AllocateArray
<
FileDescriptor
>
(
1
)
;
file_
=
result
;
result
-
>
is_placeholder_
=
false
;
result
-
>
finished_building_
=
false
;
SourceCodeInfo
*
info
=
nullptr
;
if
(
proto
.
has_source_code_info
(
)
)
{
info
=
alloc
.
AllocateArray
<
SourceCodeInfo
>
(
1
)
;
info
-
>
CopyFrom
(
proto
.
source_code_info
(
)
)
;
result
-
>
source_code_info_
=
info
;
}
else
{
result
-
>
source_code_info_
=
&
SourceCodeInfo
:
:
default_instance
(
)
;
}
file_tables_
=
alloc
.
AllocateArray
<
FileDescriptorTables
>
(
1
)
;
file_
-
>
tables_
=
file_tables_
;
if
(
!
proto
.
has_name
(
)
)
{
AddError
(
"
"
proto
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
Missing
field
:
FileDescriptorProto
.
name
.
"
)
;
}
if
(
proto
.
syntax
(
)
.
empty
(
)
|
|
proto
.
syntax
(
)
=
=
"
proto2
"
)
{
file_
-
>
syntax_
=
FileDescriptor
:
:
SYNTAX_PROTO2
;
}
else
if
(
proto
.
syntax
(
)
=
=
"
proto3
"
)
{
file_
-
>
syntax_
=
FileDescriptor
:
:
SYNTAX_PROTO3
;
}
else
{
file_
-
>
syntax_
=
FileDescriptor
:
:
SYNTAX_UNKNOWN
;
AddError
(
proto
.
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
Unrecognized
syntax
:
"
+
proto
.
syntax
(
)
)
;
}
result
-
>
name_
=
alloc
.
AllocateStrings
(
proto
.
name
(
)
)
;
if
(
proto
.
has_package
(
)
)
{
result
-
>
package_
=
alloc
.
AllocateStrings
(
proto
.
package
(
)
)
;
}
else
{
result
-
>
package_
=
alloc
.
AllocateStrings
(
"
"
)
;
}
result
-
>
pool_
=
pool_
;
if
(
result
-
>
name
(
)
.
find
(
'
\
0
'
)
!
=
std
:
:
string
:
:
npos
)
{
AddError
(
result
-
>
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
\
"
"
+
result
-
>
name
(
)
+
"
\
"
contains
null
character
.
"
)
;
return
nullptr
;
}
if
(
!
tables_
-
>
AddFile
(
result
)
)
{
AddError
(
proto
.
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
A
file
with
this
name
is
already
in
the
pool
.
"
)
;
return
nullptr
;
}
if
(
!
result
-
>
package
(
)
.
empty
(
)
)
{
if
(
std
:
:
count
(
result
-
>
package
(
)
.
begin
(
)
result
-
>
package
(
)
.
end
(
)
'
.
'
)
>
kPackageLimit
)
{
AddError
(
result
-
>
package
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Exceeds
Maximum
Package
Depth
"
)
;
return
nullptr
;
}
AddPackage
(
result
-
>
package
(
)
proto
result
)
;
}
std
:
:
set
<
std
:
:
string
>
seen_dependencies
;
result
-
>
dependency_count_
=
proto
.
dependency_size
(
)
;
result
-
>
dependencies_
=
alloc
.
AllocateArray
<
const
FileDescriptor
*
>
(
proto
.
dependency_size
(
)
)
;
result
-
>
dependencies_once_
=
nullptr
;
unused_dependency_
.
clear
(
)
;
std
:
:
set
<
int
>
weak_deps
;
for
(
int
i
=
0
;
i
<
proto
.
weak_dependency_size
(
)
;
+
+
i
)
{
weak_deps
.
insert
(
proto
.
weak_dependency
(
i
)
)
;
}
bool
need_lazy_deps
=
false
;
for
(
int
i
=
0
;
i
<
proto
.
dependency_size
(
)
;
i
+
+
)
{
if
(
!
seen_dependencies
.
insert
(
proto
.
dependency
(
i
)
)
.
second
)
{
AddTwiceListedError
(
proto
i
)
;
}
const
FileDescriptor
*
dependency
=
tables_
-
>
FindFile
(
proto
.
dependency
(
i
)
)
;
if
(
dependency
=
=
nullptr
&
&
pool_
-
>
underlay_
!
=
nullptr
)
{
dependency
=
pool_
-
>
underlay_
-
>
FindFileByName
(
proto
.
dependency
(
i
)
)
;
}
if
(
dependency
=
=
result
)
{
return
nullptr
;
}
if
(
dependency
=
=
nullptr
)
{
if
(
!
pool_
-
>
lazily_build_dependencies_
)
{
if
(
pool_
-
>
allow_unknown_
|
|
(
!
pool_
-
>
enforce_weak_
&
&
weak_deps
.
find
(
i
)
!
=
weak_deps
.
end
(
)
)
)
{
internal
:
:
FlatAllocator
lazy_dep_alloc
;
lazy_dep_alloc
.
PlanArray
<
FileDescriptor
>
(
1
)
;
lazy_dep_alloc
.
PlanArray
<
std
:
:
string
>
(
1
)
;
lazy_dep_alloc
.
FinalizePlanning
(
tables_
)
;
dependency
=
pool_
-
>
NewPlaceholderFileWithMutexHeld
(
proto
.
dependency
(
i
)
lazy_dep_alloc
)
;
}
else
{
AddImportError
(
proto
i
)
;
}
}
}
else
{
if
(
pool_
-
>
enforce_dependencies_
&
&
(
pool_
-
>
unused_import_track_files_
.
find
(
proto
.
name
(
)
)
!
=
pool_
-
>
unused_import_track_files_
.
end
(
)
)
&
&
(
dependency
-
>
public_dependency_count
(
)
=
=
0
)
)
{
unused_dependency_
.
insert
(
dependency
)
;
}
}
result
-
>
dependencies_
[
i
]
=
dependency
;
if
(
pool_
-
>
lazily_build_dependencies_
&
&
!
dependency
)
{
need_lazy_deps
=
true
;
}
}
if
(
need_lazy_deps
)
{
int
total_char_size
=
0
;
for
(
int
i
=
0
;
i
<
proto
.
dependency_size
(
)
;
i
+
+
)
{
if
(
result
-
>
dependencies_
[
i
]
=
=
nullptr
)
{
total_char_size
+
=
static_cast
<
int
>
(
proto
.
dependency
(
i
)
.
size
(
)
)
;
}
+
+
total_char_size
;
}
void
*
data
=
tables_
-
>
AllocateBytes
(
static_cast
<
int
>
(
sizeof
(
internal
:
:
once_flag
)
+
total_char_size
)
)
;
result
-
>
dependencies_once_
=
:
:
new
(
data
)
internal
:
:
once_flag
{
}
;
char
*
name_data
=
reinterpret_cast
<
char
*
>
(
result
-
>
dependencies_once_
+
1
)
;
for
(
int
i
=
0
;
i
<
proto
.
dependency_size
(
)
;
i
+
+
)
{
if
(
result
-
>
dependencies_
[
i
]
=
=
nullptr
)
{
memcpy
(
name_data
proto
.
dependency
(
i
)
.
c_str
(
)
proto
.
dependency
(
i
)
.
size
(
)
)
;
name_data
+
=
proto
.
dependency
(
i
)
.
size
(
)
;
}
*
name_data
+
+
=
'
\
0
'
;
}
}
int
public_dependency_count
=
0
;
result
-
>
public_dependencies_
=
alloc
.
AllocateArray
<
int
>
(
proto
.
public_dependency_size
(
)
)
;
for
(
int
i
=
0
;
i
<
proto
.
public_dependency_size
(
)
;
i
+
+
)
{
int
index
=
proto
.
public_dependency
(
i
)
;
if
(
index
>
=
0
&
&
index
<
proto
.
dependency_size
(
)
)
{
result
-
>
public_dependencies_
[
public_dependency_count
+
+
]
=
index
;
if
(
!
pool_
-
>
lazily_build_dependencies_
)
{
unused_dependency_
.
erase
(
result
-
>
dependency
(
index
)
)
;
}
}
else
{
AddError
(
proto
.
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
Invalid
public
dependency
index
.
"
)
;
}
}
result
-
>
public_dependency_count_
=
public_dependency_count
;
dependencies_
.
clear
(
)
;
if
(
!
pool_
-
>
lazily_build_dependencies_
)
{
for
(
int
i
=
0
;
i
<
result
-
>
dependency_count
(
)
;
i
+
+
)
{
RecordPublicDependencies
(
result
-
>
dependency
(
i
)
)
;
}
}
int
weak_dependency_count
=
0
;
result
-
>
weak_dependencies_
=
alloc
.
AllocateArray
<
int
>
(
proto
.
weak_dependency_size
(
)
)
;
for
(
int
i
=
0
;
i
<
proto
.
weak_dependency_size
(
)
;
i
+
+
)
{
int
index
=
proto
.
weak_dependency
(
i
)
;
if
(
index
>
=
0
&
&
index
<
proto
.
dependency_size
(
)
)
{
result
-
>
weak_dependencies_
[
weak_dependency_count
+
+
]
=
index
;
}
else
{
AddError
(
proto
.
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
Invalid
weak
dependency
index
.
"
)
;
}
}
result
-
>
weak_dependency_count_
=
weak_dependency_count
;
BUILD_ARRAY
(
proto
result
message_type
BuildMessage
nullptr
)
;
BUILD_ARRAY
(
proto
result
enum_type
BuildEnum
nullptr
)
;
BUILD_ARRAY
(
proto
result
service
BuildService
nullptr
)
;
BUILD_ARRAY
(
proto
result
extension
BuildExtension
nullptr
)
;
result
-
>
options_
=
nullptr
;
if
(
proto
.
has_options
(
)
)
{
AllocateOptions
(
proto
.
options
(
)
result
alloc
)
;
}
CrossLinkFile
(
result
proto
)
;
if
(
!
message_hints_
.
empty
(
)
)
{
SuggestFieldNumbers
(
result
proto
)
;
}
if
(
!
had_errors_
)
{
OptionInterpreter
option_interpreter
(
this
)
;
for
(
std
:
:
vector
<
OptionsToInterpret
>
:
:
iterator
iter
=
options_to_interpret_
.
begin
(
)
;
iter
!
=
options_to_interpret_
.
end
(
)
;
+
+
iter
)
{
option_interpreter
.
InterpretOptions
(
&
(
*
iter
)
)
;
}
options_to_interpret_
.
clear
(
)
;
if
(
info
!
=
nullptr
)
{
option_interpreter
.
UpdateSourceCodeInfo
(
info
)
;
}
}
if
(
!
had_errors_
&
&
!
pool_
-
>
lazily_build_dependencies_
)
{
ValidateFileOptions
(
result
proto
)
;
}
if
(
had_errors_
)
{
for
(
int
i
=
0
;
i
<
proto
.
message_type_size
(
)
;
+
+
i
)
{
DetectMapConflicts
(
result
-
>
message_type
(
i
)
proto
.
message_type
(
i
)
)
;
}
}
if
(
!
had_errors_
&
&
!
unused_dependency_
.
empty
(
)
&
&
!
pool_
-
>
lazily_build_dependencies_
)
{
LogUnusedDependency
(
proto
result
)
;
}
if
(
had_errors_
)
{
return
nullptr
;
}
else
{
return
result
;
}
}
const
std
:
:
string
*
DescriptorBuilder
:
:
AllocateNameStrings
(
const
std
:
:
string
&
scope
const
std
:
:
string
&
proto_name
internal
:
:
FlatAllocator
&
alloc
)
{
if
(
scope
.
empty
(
)
)
{
return
alloc
.
AllocateStrings
(
proto_name
proto_name
)
;
}
else
{
return
alloc
.
AllocateStrings
(
proto_name
StrCat
(
scope
"
.
"
proto_name
)
)
;
}
}
namespace
{
struct
IncrementWhenDestroyed
{
~
IncrementWhenDestroyed
(
)
{
+
+
to_increment
;
}
int
&
to_increment
;
}
;
}
void
DescriptorBuilder
:
:
BuildMessage
(
const
DescriptorProto
&
proto
const
Descriptor
*
parent
Descriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
{
const
std
:
:
string
&
scope
=
(
parent
=
=
nullptr
)
?
file_
-
>
package
(
)
:
parent
-
>
full_name
(
)
;
result
-
>
all_names_
=
AllocateNameStrings
(
scope
proto
.
name
(
)
alloc
)
;
ValidateSymbolName
(
proto
.
name
(
)
result
-
>
full_name
(
)
proto
)
;
result
-
>
file_
=
file_
;
result
-
>
containing_type_
=
parent
;
result
-
>
is_placeholder_
=
false
;
result
-
>
is_unqualified_placeholder_
=
false
;
result
-
>
well_known_type_
=
Descriptor
:
:
WELLKNOWNTYPE_UNSPECIFIED
;
result
-
>
options_
=
nullptr
;
auto
it
=
pool_
-
>
tables_
-
>
well_known_types_
.
find
(
result
-
>
full_name
(
)
)
;
if
(
it
!
=
pool_
-
>
tables_
-
>
well_known_types_
.
end
(
)
)
{
result
-
>
well_known_type_
=
it
-
>
second
;
}
result
-
>
sequential_field_limit_
=
0
;
for
(
int
i
=
0
;
i
<
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
&
&
i
<
proto
.
field_size
(
)
&
&
proto
.
field
(
i
)
.
number
(
)
=
=
i
+
1
;
+
+
i
)
{
result
-
>
sequential_field_limit_
=
i
+
1
;
}
BUILD_ARRAY
(
proto
result
oneof_decl
BuildOneof
result
)
;
BUILD_ARRAY
(
proto
result
field
BuildField
result
)
;
BUILD_ARRAY
(
proto
result
enum_type
BuildEnum
result
)
;
BUILD_ARRAY
(
proto
result
extension_range
BuildExtensionRange
result
)
;
BUILD_ARRAY
(
proto
result
extension
BuildExtension
result
)
;
BUILD_ARRAY
(
proto
result
reserved_range
BuildReservedRange
result
)
;
-
-
recursion_depth_
;
IncrementWhenDestroyed
revert
{
recursion_depth_
}
;
if
(
recursion_depth_
<
=
0
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
Reached
maximum
recursion
limit
for
nested
messages
.
"
)
;
result
-
>
nested_types_
=
nullptr
;
result
-
>
nested_type_count_
=
0
;
return
;
}
BUILD_ARRAY
(
proto
result
nested_type
BuildMessage
result
)
;
int
reserved_name_count
=
proto
.
reserved_name_size
(
)
;
result
-
>
reserved_name_count_
=
reserved_name_count
;
result
-
>
reserved_names_
=
alloc
.
AllocateArray
<
const
std
:
:
string
*
>
(
reserved_name_count
)
;
for
(
int
i
=
0
;
i
<
reserved_name_count
;
+
+
i
)
{
result
-
>
reserved_names_
[
i
]
=
alloc
.
AllocateStrings
(
proto
.
reserved_name
(
i
)
)
;
}
if
(
proto
.
has_options
(
)
)
{
AllocateOptions
(
proto
.
options
(
)
result
DescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
MessageOptions
"
alloc
)
;
}
AddSymbol
(
result
-
>
full_name
(
)
parent
result
-
>
name
(
)
proto
Symbol
(
result
)
)
;
for
(
int
i
=
0
;
i
<
proto
.
reserved_range_size
(
)
;
i
+
+
)
{
const
DescriptorProto_ReservedRange
&
range1
=
proto
.
reserved_range
(
i
)
;
for
(
int
j
=
i
+
1
;
j
<
proto
.
reserved_range_size
(
)
;
j
+
+
)
{
const
DescriptorProto_ReservedRange
&
range2
=
proto
.
reserved_range
(
j
)
;
if
(
range1
.
end
(
)
>
range2
.
start
(
)
&
&
range2
.
end
(
)
>
range1
.
start
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
.
reserved_range
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Reserved
range
0
to
1
overlaps
with
"
"
already
-
defined
range
2
to
3
.
"
range2
.
start
(
)
range2
.
end
(
)
-
1
range1
.
start
(
)
range1
.
end
(
)
-
1
)
)
;
}
}
}
HASH_SET
<
std
:
:
string
>
reserved_name_set
;
for
(
int
i
=
0
;
i
<
proto
.
reserved_name_size
(
)
;
i
+
+
)
{
const
std
:
:
string
&
name
=
proto
.
reserved_name
(
i
)
;
if
(
reserved_name_set
.
find
(
name
)
=
=
reserved_name_set
.
end
(
)
)
{
reserved_name_set
.
insert
(
name
)
;
}
else
{
AddError
(
name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
strings
:
:
Substitute
(
"
Field
name
\
"
0
\
"
is
reserved
multiple
times
.
"
name
)
)
;
}
}
for
(
int
i
=
0
;
i
<
result
-
>
field_count
(
)
;
i
+
+
)
{
const
FieldDescriptor
*
field
=
result
-
>
field
(
i
)
;
for
(
int
j
=
0
;
j
<
result
-
>
extension_range_count
(
)
;
j
+
+
)
{
const
Descriptor
:
:
ExtensionRange
*
range
=
result
-
>
extension_range
(
j
)
;
if
(
range
-
>
start
<
=
field
-
>
number
(
)
&
&
field
-
>
number
(
)
<
range
-
>
end
)
{
message_hints_
[
result
]
.
RequestHintOnFieldNumbers
(
proto
.
extension_range
(
j
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
)
;
AddError
(
field
-
>
full_name
(
)
proto
.
extension_range
(
j
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Extension
range
0
to
1
includes
field
\
"
2
\
"
(
3
)
.
"
range
-
>
start
range
-
>
end
-
1
field
-
>
name
(
)
field
-
>
number
(
)
)
)
;
}
}
for
(
int
j
=
0
;
j
<
result
-
>
reserved_range_count
(
)
;
j
+
+
)
{
const
Descriptor
:
:
ReservedRange
*
range
=
result
-
>
reserved_range
(
j
)
;
if
(
range
-
>
start
<
=
field
-
>
number
(
)
&
&
field
-
>
number
(
)
<
range
-
>
end
)
{
message_hints_
[
result
]
.
RequestHintOnFieldNumbers
(
proto
.
reserved_range
(
j
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
)
;
AddError
(
field
-
>
full_name
(
)
proto
.
reserved_range
(
j
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Field
\
"
0
\
"
uses
reserved
number
1
.
"
field
-
>
name
(
)
field
-
>
number
(
)
)
)
;
}
}
if
(
reserved_name_set
.
find
(
field
-
>
name
(
)
)
!
=
reserved_name_set
.
end
(
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
.
field
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NAME
strings
:
:
Substitute
(
"
Field
name
\
"
0
\
"
is
reserved
.
"
field
-
>
name
(
)
)
)
;
}
}
for
(
int
i
=
0
;
i
<
result
-
>
extension_range_count
(
)
;
i
+
+
)
{
const
Descriptor
:
:
ExtensionRange
*
range1
=
result
-
>
extension_range
(
i
)
;
for
(
int
j
=
0
;
j
<
result
-
>
reserved_range_count
(
)
;
j
+
+
)
{
const
Descriptor
:
:
ReservedRange
*
range2
=
result
-
>
reserved_range
(
j
)
;
if
(
range1
-
>
end
>
range2
-
>
start
&
&
range2
-
>
end
>
range1
-
>
start
)
{
AddError
(
result
-
>
full_name
(
)
proto
.
extension_range
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Extension
range
0
to
1
overlaps
with
"
"
reserved
range
2
to
3
.
"
range1
-
>
start
range1
-
>
end
-
1
range2
-
>
start
range2
-
>
end
-
1
)
)
;
}
}
for
(
int
j
=
i
+
1
;
j
<
result
-
>
extension_range_count
(
)
;
j
+
+
)
{
const
Descriptor
:
:
ExtensionRange
*
range2
=
result
-
>
extension_range
(
j
)
;
if
(
range1
-
>
end
>
range2
-
>
start
&
&
range2
-
>
end
>
range1
-
>
start
)
{
AddError
(
result
-
>
full_name
(
)
proto
.
extension_range
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Extension
range
0
to
1
overlaps
with
"
"
already
-
defined
range
2
to
3
.
"
range2
-
>
start
range2
-
>
end
-
1
range1
-
>
start
range1
-
>
end
-
1
)
)
;
}
}
}
}
void
DescriptorBuilder
:
:
BuildFieldOrExtension
(
const
FieldDescriptorProto
&
proto
Descriptor
*
parent
FieldDescriptor
*
result
bool
is_extension
internal
:
:
FlatAllocator
&
alloc
)
{
const
std
:
:
string
&
scope
=
(
parent
=
=
nullptr
)
?
file_
-
>
package
(
)
:
parent
-
>
full_name
(
)
;
auto
all_names
=
alloc
.
AllocateFieldNames
(
proto
.
name
(
)
scope
proto
.
has_json_name
(
)
?
&
proto
.
json_name
(
)
:
nullptr
)
;
result
-
>
all_names_
=
all_names
.
array
;
result
-
>
lowercase_name_index_
=
all_names
.
lowercase_index
;
result
-
>
camelcase_name_index_
=
all_names
.
camelcase_index
;
result
-
>
json_name_index_
=
all_names
.
json_index
;
ValidateSymbolName
(
proto
.
name
(
)
result
-
>
full_name
(
)
proto
)
;
result
-
>
file_
=
file_
;
result
-
>
number_
=
proto
.
number
(
)
;
result
-
>
is_extension_
=
is_extension
;
result
-
>
is_oneof_
=
false
;
result
-
>
proto3_optional_
=
proto
.
proto3_optional
(
)
;
if
(
proto
.
proto3_optional
(
)
&
&
file_
-
>
syntax
(
)
!
=
FileDescriptor
:
:
SYNTAX_PROTO3
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
The
[
proto3_optional
=
true
]
option
may
only
be
set
on
proto3
"
"
fields
not
"
+
result
-
>
full_name
(
)
)
;
}
result
-
>
has_json_name_
=
proto
.
has_json_name
(
)
;
result
-
>
type_
=
static_cast
<
FieldDescriptor
:
:
Type
>
(
implicit_cast
<
int
>
(
proto
.
type
(
)
)
)
;
result
-
>
label_
=
static_cast
<
FieldDescriptor
:
:
Label
>
(
implicit_cast
<
int
>
(
proto
.
label
(
)
)
)
;
if
(
result
-
>
label_
=
=
FieldDescriptor
:
:
LABEL_REQUIRED
)
{
if
(
result
-
>
is_extension_
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
The
extension
"
+
result
-
>
full_name
(
)
+
"
cannot
be
required
.
"
)
;
}
}
result
-
>
containing_type_
=
nullptr
;
result
-
>
type_once_
=
nullptr
;
result
-
>
default_value_enum_
=
nullptr
;
result
-
>
has_default_value_
=
proto
.
has_default_value
(
)
;
if
(
proto
.
has_default_value
(
)
&
&
result
-
>
is_repeated
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Repeated
fields
can
'
t
have
default
values
.
"
)
;
}
if
(
proto
.
has_type
(
)
)
{
if
(
proto
.
has_default_value
(
)
)
{
char
*
end_pos
=
nullptr
;
switch
(
result
-
>
cpp_type
(
)
)
{
case
FieldDescriptor
:
:
CPPTYPE_INT32
:
result
-
>
default_value_int32_t_
=
strtol
(
proto
.
default_value
(
)
.
c_str
(
)
&
end_pos
0
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_INT64
:
result
-
>
default_value_int64_t_
=
strto64
(
proto
.
default_value
(
)
.
c_str
(
)
&
end_pos
0
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_UINT32
:
result
-
>
default_value_uint32_t_
=
strtoul
(
proto
.
default_value
(
)
.
c_str
(
)
&
end_pos
0
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_UINT64
:
result
-
>
default_value_uint64_t_
=
strtou64
(
proto
.
default_value
(
)
.
c_str
(
)
&
end_pos
0
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_FLOAT
:
if
(
proto
.
default_value
(
)
=
=
"
inf
"
)
{
result
-
>
default_value_float_
=
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
;
}
else
if
(
proto
.
default_value
(
)
=
=
"
-
inf
"
)
{
result
-
>
default_value_float_
=
-
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
;
}
else
if
(
proto
.
default_value
(
)
=
=
"
nan
"
)
{
result
-
>
default_value_float_
=
std
:
:
numeric_limits
<
float
>
:
:
quiet_NaN
(
)
;
}
else
{
result
-
>
default_value_float_
=
io
:
:
SafeDoubleToFloat
(
io
:
:
NoLocaleStrtod
(
proto
.
default_value
(
)
.
c_str
(
)
&
end_pos
)
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_DOUBLE
:
if
(
proto
.
default_value
(
)
=
=
"
inf
"
)
{
result
-
>
default_value_double_
=
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
else
if
(
proto
.
default_value
(
)
=
=
"
-
inf
"
)
{
result
-
>
default_value_double_
=
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
else
if
(
proto
.
default_value
(
)
=
=
"
nan
"
)
{
result
-
>
default_value_double_
=
std
:
:
numeric_limits
<
double
>
:
:
quiet_NaN
(
)
;
}
else
{
result
-
>
default_value_double_
=
io
:
:
NoLocaleStrtod
(
proto
.
default_value
(
)
.
c_str
(
)
&
end_pos
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_BOOL
:
if
(
proto
.
default_value
(
)
=
=
"
true
"
)
{
result
-
>
default_value_bool_
=
true
;
}
else
if
(
proto
.
default_value
(
)
=
=
"
false
"
)
{
result
-
>
default_value_bool_
=
false
;
}
else
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Boolean
default
must
be
true
or
false
.
"
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_ENUM
:
result
-
>
default_value_enum_
=
nullptr
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_STRING
:
if
(
result
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_BYTES
)
{
result
-
>
default_value_string_
=
alloc
.
AllocateStrings
(
UnescapeCEscapeString
(
proto
.
default_value
(
)
)
)
;
}
else
{
result
-
>
default_value_string_
=
alloc
.
AllocateStrings
(
proto
.
default_value
(
)
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_MESSAGE
:
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Messages
can
'
t
have
default
values
.
"
)
;
result
-
>
has_default_value_
=
false
;
result
-
>
default_generated_instance_
=
nullptr
;
break
;
}
if
(
end_pos
!
=
nullptr
)
{
if
(
proto
.
default_value
(
)
.
empty
(
)
|
|
*
end_pos
!
=
'
\
0
'
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Couldn
'
t
parse
default
value
\
"
"
+
proto
.
default_value
(
)
+
"
\
"
.
"
)
;
}
}
}
else
{
switch
(
result
-
>
cpp_type
(
)
)
{
case
FieldDescriptor
:
:
CPPTYPE_INT32
:
result
-
>
default_value_int32_t_
=
0
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_INT64
:
result
-
>
default_value_int64_t_
=
0
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_UINT32
:
result
-
>
default_value_uint32_t_
=
0
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_UINT64
:
result
-
>
default_value_uint64_t_
=
0
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_FLOAT
:
result
-
>
default_value_float_
=
0
.
0f
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_DOUBLE
:
result
-
>
default_value_double_
=
0
.
0
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_BOOL
:
result
-
>
default_value_bool_
=
false
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_ENUM
:
result
-
>
default_value_enum_
=
nullptr
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_STRING
:
result
-
>
default_value_string_
=
&
internal
:
:
GetEmptyString
(
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_MESSAGE
:
result
-
>
default_generated_instance_
=
nullptr
;
break
;
}
}
}
if
(
result
-
>
number
(
)
<
=
0
)
{
message_hints_
[
parent
]
.
RequestHintOnFieldNumbers
(
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
)
;
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
Field
numbers
must
be
positive
integers
.
"
)
;
}
else
if
(
!
is_extension
&
&
result
-
>
number
(
)
>
FieldDescriptor
:
:
kMaxNumber
)
{
message_hints_
[
parent
]
.
RequestHintOnFieldNumbers
(
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
)
;
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Field
numbers
cannot
be
greater
than
0
.
"
FieldDescriptor
:
:
kMaxNumber
)
)
;
}
else
if
(
result
-
>
number
(
)
>
=
FieldDescriptor
:
:
kFirstReservedNumber
&
&
result
-
>
number
(
)
<
=
FieldDescriptor
:
:
kLastReservedNumber
)
{
message_hints_
[
parent
]
.
RequestHintOnFieldNumbers
(
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
)
;
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Field
numbers
0
through
1
are
reserved
for
the
protocol
"
"
buffer
library
implementation
.
"
FieldDescriptor
:
:
kFirstReservedNumber
FieldDescriptor
:
:
kLastReservedNumber
)
)
;
}
if
(
is_extension
)
{
if
(
!
proto
.
has_extendee
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
EXTENDEE
"
FieldDescriptorProto
.
extendee
not
set
for
extension
field
.
"
)
;
}
result
-
>
scope_
.
extension_scope
=
parent
;
if
(
proto
.
has_oneof_index
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
FieldDescriptorProto
.
oneof_index
should
not
be
set
for
"
"
extensions
.
"
)
;
}
}
else
{
if
(
proto
.
has_extendee
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
EXTENDEE
"
FieldDescriptorProto
.
extendee
set
for
non
-
extension
field
.
"
)
;
}
result
-
>
containing_type_
=
parent
;
if
(
proto
.
has_oneof_index
(
)
)
{
if
(
proto
.
oneof_index
(
)
<
0
|
|
proto
.
oneof_index
(
)
>
=
parent
-
>
oneof_decl_count
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
strings
:
:
Substitute
(
"
FieldDescriptorProto
.
oneof_index
0
is
"
"
out
of
range
for
type
\
"
1
\
"
.
"
proto
.
oneof_index
(
)
parent
-
>
name
(
)
)
)
;
}
else
{
result
-
>
is_oneof_
=
true
;
result
-
>
scope_
.
containing_oneof
=
parent
-
>
oneof_decl
(
proto
.
oneof_index
(
)
)
;
}
}
}
result
-
>
options_
=
nullptr
;
if
(
proto
.
has_options
(
)
)
{
AllocateOptions
(
proto
.
options
(
)
result
FieldDescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
FieldOptions
"
alloc
)
;
}
AddSymbol
(
result
-
>
full_name
(
)
parent
result
-
>
name
(
)
proto
Symbol
(
result
)
)
;
}
void
DescriptorBuilder
:
:
BuildExtensionRange
(
const
DescriptorProto
:
:
ExtensionRange
&
proto
const
Descriptor
*
parent
Descriptor
:
:
ExtensionRange
*
result
internal
:
:
FlatAllocator
&
alloc
)
{
result
-
>
start
=
proto
.
start
(
)
;
result
-
>
end
=
proto
.
end
(
)
;
if
(
result
-
>
start
<
=
0
)
{
message_hints_
[
parent
]
.
RequestHintOnFieldNumbers
(
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
result
-
>
start
result
-
>
end
)
;
AddError
(
parent
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
Extension
numbers
must
be
positive
integers
.
"
)
;
}
if
(
result
-
>
start
>
=
result
-
>
end
)
{
AddError
(
parent
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
Extension
range
end
number
must
be
greater
than
start
number
.
"
)
;
}
result
-
>
options_
=
nullptr
;
if
(
proto
.
has_options
(
)
)
{
std
:
:
vector
<
int
>
options_path
;
parent
-
>
GetLocationPath
(
&
options_path
)
;
options_path
.
push_back
(
DescriptorProto
:
:
kExtensionRangeFieldNumber
)
;
int
index
;
for
(
index
=
0
;
parent
-
>
extension_ranges_
+
index
!
=
result
;
index
+
+
)
{
}
options_path
.
push_back
(
index
)
;
options_path
.
push_back
(
DescriptorProto_ExtensionRange
:
:
kOptionsFieldNumber
)
;
AllocateOptionsImpl
(
parent
-
>
full_name
(
)
parent
-
>
full_name
(
)
proto
.
options
(
)
result
options_path
"
google
.
protobuf
.
ExtensionRangeOptions
"
alloc
)
;
}
}
void
DescriptorBuilder
:
:
BuildReservedRange
(
const
DescriptorProto
:
:
ReservedRange
&
proto
const
Descriptor
*
parent
Descriptor
:
:
ReservedRange
*
result
internal
:
:
FlatAllocator
&
)
{
result
-
>
start
=
proto
.
start
(
)
;
result
-
>
end
=
proto
.
end
(
)
;
if
(
result
-
>
start
<
=
0
)
{
message_hints_
[
parent
]
.
RequestHintOnFieldNumbers
(
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
result
-
>
start
result
-
>
end
)
;
AddError
(
parent
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
Reserved
numbers
must
be
positive
integers
.
"
)
;
}
}
void
DescriptorBuilder
:
:
BuildReservedRange
(
const
EnumDescriptorProto
:
:
EnumReservedRange
&
proto
const
EnumDescriptor
*
parent
EnumDescriptor
:
:
ReservedRange
*
result
internal
:
:
FlatAllocator
&
)
{
result
-
>
start
=
proto
.
start
(
)
;
result
-
>
end
=
proto
.
end
(
)
;
if
(
result
-
>
start
>
result
-
>
end
)
{
AddError
(
parent
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
Reserved
range
end
number
must
be
greater
than
start
number
.
"
)
;
}
}
void
DescriptorBuilder
:
:
BuildOneof
(
const
OneofDescriptorProto
&
proto
Descriptor
*
parent
OneofDescriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
{
result
-
>
all_names_
=
AllocateNameStrings
(
parent
-
>
full_name
(
)
proto
.
name
(
)
alloc
)
;
ValidateSymbolName
(
proto
.
name
(
)
result
-
>
full_name
(
)
proto
)
;
result
-
>
containing_type_
=
parent
;
result
-
>
field_count_
=
0
;
result
-
>
fields_
=
nullptr
;
result
-
>
options_
=
nullptr
;
if
(
proto
.
has_options
(
)
)
{
AllocateOptions
(
proto
.
options
(
)
result
OneofDescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
OneofOptions
"
alloc
)
;
}
AddSymbol
(
result
-
>
full_name
(
)
parent
result
-
>
name
(
)
proto
Symbol
(
result
)
)
;
}
void
DescriptorBuilder
:
:
CheckEnumValueUniqueness
(
const
EnumDescriptorProto
&
proto
const
EnumDescriptor
*
result
)
{
PrefixRemover
remover
(
result
-
>
name
(
)
)
;
std
:
:
map
<
std
:
:
string
const
EnumValueDescriptor
*
>
values
;
for
(
int
i
=
0
;
i
<
result
-
>
value_count
(
)
;
i
+
+
)
{
const
EnumValueDescriptor
*
value
=
result
-
>
value
(
i
)
;
std
:
:
string
stripped
=
EnumValueToPascalCase
(
remover
.
MaybeRemove
(
value
-
>
name
(
)
)
)
;
std
:
:
pair
<
std
:
:
map
<
std
:
:
string
const
EnumValueDescriptor
*
>
:
:
iterator
bool
>
insert_result
=
values
.
insert
(
std
:
:
make_pair
(
stripped
value
)
)
;
bool
inserted
=
insert_result
.
second
;
if
(
!
inserted
&
&
insert_result
.
first
-
>
second
-
>
name
(
)
!
=
value
-
>
name
(
)
&
&
insert_result
.
first
-
>
second
-
>
number
(
)
!
=
value
-
>
number
(
)
)
{
std
:
:
string
error_message
=
"
Enum
name
"
+
value
-
>
name
(
)
+
"
has
the
same
name
as
"
+
values
[
stripped
]
-
>
name
(
)
+
"
if
you
ignore
case
and
strip
out
the
enum
name
prefix
(
if
any
)
.
"
"
This
is
error
-
prone
and
can
lead
to
undefined
behavior
.
"
"
Please
avoid
doing
this
.
If
you
are
using
allow_alias
please
"
"
assign
the
same
numeric
value
to
both
enums
.
"
;
if
(
result
-
>
file
(
)
-
>
syntax
(
)
=
=
FileDescriptor
:
:
SYNTAX_PROTO2
)
{
AddWarning
(
value
-
>
full_name
(
)
proto
.
value
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NAME
error_message
)
;
}
else
{
AddError
(
value
-
>
full_name
(
)
proto
.
value
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NAME
error_message
)
;
}
}
}
}
void
DescriptorBuilder
:
:
BuildEnum
(
const
EnumDescriptorProto
&
proto
const
Descriptor
*
parent
EnumDescriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
{
const
std
:
:
string
&
scope
=
(
parent
=
=
nullptr
)
?
file_
-
>
package
(
)
:
parent
-
>
full_name
(
)
;
result
-
>
all_names_
=
AllocateNameStrings
(
scope
proto
.
name
(
)
alloc
)
;
ValidateSymbolName
(
proto
.
name
(
)
result
-
>
full_name
(
)
proto
)
;
result
-
>
file_
=
file_
;
result
-
>
containing_type_
=
parent
;
result
-
>
is_placeholder_
=
false
;
result
-
>
is_unqualified_placeholder_
=
false
;
if
(
proto
.
value_size
(
)
=
=
0
)
{
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Enums
must
contain
at
least
one
value
.
"
)
;
}
for
(
int
i
=
0
;
i
<
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
&
&
i
<
proto
.
value_size
(
)
&
&
proto
.
value
(
i
)
.
number
(
)
=
=
static_cast
<
int64_t
>
(
i
)
+
proto
.
value
(
0
)
.
number
(
)
;
+
+
i
)
{
result
-
>
sequential_value_limit_
=
i
;
}
BUILD_ARRAY
(
proto
result
value
BuildEnumValue
result
)
;
BUILD_ARRAY
(
proto
result
reserved_range
BuildReservedRange
result
)
;
int
reserved_name_count
=
proto
.
reserved_name_size
(
)
;
result
-
>
reserved_name_count_
=
reserved_name_count
;
result
-
>
reserved_names_
=
alloc
.
AllocateArray
<
const
std
:
:
string
*
>
(
reserved_name_count
)
;
for
(
int
i
=
0
;
i
<
reserved_name_count
;
+
+
i
)
{
result
-
>
reserved_names_
[
i
]
=
alloc
.
AllocateStrings
(
proto
.
reserved_name
(
i
)
)
;
}
CheckEnumValueUniqueness
(
proto
result
)
;
result
-
>
options_
=
nullptr
;
if
(
proto
.
has_options
(
)
)
{
AllocateOptions
(
proto
.
options
(
)
result
EnumDescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
EnumOptions
"
alloc
)
;
}
AddSymbol
(
result
-
>
full_name
(
)
parent
result
-
>
name
(
)
proto
Symbol
(
result
)
)
;
for
(
int
i
=
0
;
i
<
proto
.
reserved_range_size
(
)
;
i
+
+
)
{
const
EnumDescriptorProto_EnumReservedRange
&
range1
=
proto
.
reserved_range
(
i
)
;
for
(
int
j
=
i
+
1
;
j
<
proto
.
reserved_range_size
(
)
;
j
+
+
)
{
const
EnumDescriptorProto_EnumReservedRange
&
range2
=
proto
.
reserved_range
(
j
)
;
if
(
range1
.
end
(
)
>
=
range2
.
start
(
)
&
&
range2
.
end
(
)
>
=
range1
.
start
(
)
)
{
AddError
(
result
-
>
full_name
(
)
proto
.
reserved_range
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Reserved
range
0
to
1
overlaps
with
"
"
already
-
defined
range
2
to
3
.
"
range2
.
start
(
)
range2
.
end
(
)
range1
.
start
(
)
range1
.
end
(
)
)
)
;
}
}
}
HASH_SET
<
std
:
:
string
>
reserved_name_set
;
for
(
int
i
=
0
;
i
<
proto
.
reserved_name_size
(
)
;
i
+
+
)
{
const
std
:
:
string
&
name
=
proto
.
reserved_name
(
i
)
;
if
(
reserved_name_set
.
find
(
name
)
=
=
reserved_name_set
.
end
(
)
)
{
reserved_name_set
.
insert
(
name
)
;
}
else
{
AddError
(
name
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
strings
:
:
Substitute
(
"
Enum
value
\
"
0
\
"
is
reserved
multiple
times
.
"
name
)
)
;
}
}
for
(
int
i
=
0
;
i
<
result
-
>
value_count
(
)
;
i
+
+
)
{
const
EnumValueDescriptor
*
value
=
result
-
>
value
(
i
)
;
for
(
int
j
=
0
;
j
<
result
-
>
reserved_range_count
(
)
;
j
+
+
)
{
const
EnumDescriptor
:
:
ReservedRange
*
range
=
result
-
>
reserved_range
(
j
)
;
if
(
range
-
>
start
<
=
value
-
>
number
(
)
&
&
value
-
>
number
(
)
<
=
range
-
>
end
)
{
AddError
(
value
-
>
full_name
(
)
proto
.
reserved_range
(
j
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Enum
value
\
"
0
\
"
uses
reserved
number
1
.
"
value
-
>
name
(
)
value
-
>
number
(
)
)
)
;
}
}
if
(
reserved_name_set
.
find
(
value
-
>
name
(
)
)
!
=
reserved_name_set
.
end
(
)
)
{
AddError
(
value
-
>
full_name
(
)
proto
.
value
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NAME
strings
:
:
Substitute
(
"
Enum
value
\
"
0
\
"
is
reserved
.
"
value
-
>
name
(
)
)
)
;
}
}
}
void
DescriptorBuilder
:
:
BuildEnumValue
(
const
EnumValueDescriptorProto
&
proto
const
EnumDescriptor
*
parent
EnumValueDescriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
{
std
:
:
string
full_name
;
size_t
scope_len
=
parent
-
>
full_name
(
)
.
size
(
)
-
parent
-
>
name
(
)
.
size
(
)
;
full_name
.
reserve
(
scope_len
+
proto
.
name
(
)
.
size
(
)
)
;
full_name
.
append
(
parent
-
>
full_name
(
)
.
data
(
)
scope_len
)
;
full_name
.
append
(
proto
.
name
(
)
)
;
result
-
>
all_names_
=
alloc
.
AllocateStrings
(
proto
.
name
(
)
std
:
:
move
(
full_name
)
)
;
result
-
>
number_
=
proto
.
number
(
)
;
result
-
>
type_
=
parent
;
ValidateSymbolName
(
proto
.
name
(
)
result
-
>
full_name
(
)
proto
)
;
result
-
>
options_
=
nullptr
;
if
(
proto
.
has_options
(
)
)
{
AllocateOptions
(
proto
.
options
(
)
result
EnumValueDescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
EnumValueOptions
"
alloc
)
;
}
bool
added_to_outer_scope
=
AddSymbol
(
result
-
>
full_name
(
)
parent
-
>
containing_type
(
)
result
-
>
name
(
)
proto
Symbol
:
:
EnumValue
(
result
0
)
)
;
bool
added_to_inner_scope
=
file_tables_
-
>
AddAliasUnderParent
(
parent
result
-
>
name
(
)
Symbol
:
:
EnumValue
(
result
1
)
)
;
if
(
added_to_inner_scope
&
&
!
added_to_outer_scope
)
{
std
:
:
string
outer_scope
;
if
(
parent
-
>
containing_type
(
)
=
=
nullptr
)
{
outer_scope
=
file_
-
>
package
(
)
;
}
else
{
outer_scope
=
parent
-
>
containing_type
(
)
-
>
full_name
(
)
;
}
if
(
outer_scope
.
empty
(
)
)
{
outer_scope
=
"
the
global
scope
"
;
}
else
{
outer_scope
=
"
\
"
"
+
outer_scope
+
"
\
"
"
;
}
AddError
(
result
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Note
that
enum
values
use
C
+
+
scoping
rules
meaning
that
"
"
enum
values
are
siblings
of
their
type
not
children
of
it
.
"
"
Therefore
\
"
"
+
result
-
>
name
(
)
+
"
\
"
must
be
unique
within
"
+
outer_scope
+
"
not
just
within
\
"
"
+
parent
-
>
name
(
)
+
"
\
"
.
"
)
;
}
file_tables_
-
>
AddEnumValueByNumber
(
result
)
;
}
void
DescriptorBuilder
:
:
BuildService
(
const
ServiceDescriptorProto
&
proto
const
void
*
ServiceDescriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
{
result
-
>
all_names_
=
AllocateNameStrings
(
file_
-
>
package
(
)
proto
.
name
(
)
alloc
)
;
result
-
>
file_
=
file_
;
ValidateSymbolName
(
proto
.
name
(
)
result
-
>
full_name
(
)
proto
)
;
BUILD_ARRAY
(
proto
result
method
BuildMethod
result
)
;
result
-
>
options_
=
nullptr
;
if
(
proto
.
has_options
(
)
)
{
AllocateOptions
(
proto
.
options
(
)
result
ServiceDescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
ServiceOptions
"
alloc
)
;
}
AddSymbol
(
result
-
>
full_name
(
)
nullptr
result
-
>
name
(
)
proto
Symbol
(
result
)
)
;
}
void
DescriptorBuilder
:
:
BuildMethod
(
const
MethodDescriptorProto
&
proto
const
ServiceDescriptor
*
parent
MethodDescriptor
*
result
internal
:
:
FlatAllocator
&
alloc
)
{
result
-
>
service_
=
parent
;
result
-
>
all_names_
=
AllocateNameStrings
(
parent
-
>
full_name
(
)
proto
.
name
(
)
alloc
)
;
ValidateSymbolName
(
proto
.
name
(
)
result
-
>
full_name
(
)
proto
)
;
result
-
>
input_type_
.
Init
(
)
;
result
-
>
output_type_
.
Init
(
)
;
result
-
>
options_
=
nullptr
;
if
(
proto
.
has_options
(
)
)
{
AllocateOptions
(
proto
.
options
(
)
result
MethodDescriptorProto
:
:
kOptionsFieldNumber
"
google
.
protobuf
.
MethodOptions
"
alloc
)
;
}
result
-
>
client_streaming_
=
proto
.
client_streaming
(
)
;
result
-
>
server_streaming_
=
proto
.
server_streaming
(
)
;
AddSymbol
(
result
-
>
full_name
(
)
parent
result
-
>
name
(
)
proto
Symbol
(
result
)
)
;
}
#
undef
BUILD_ARRAY
void
DescriptorBuilder
:
:
CrossLinkFile
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
{
if
(
file
-
>
options_
=
=
nullptr
)
{
file
-
>
options_
=
&
FileOptions
:
:
default_instance
(
)
;
}
for
(
int
i
=
0
;
i
<
file
-
>
message_type_count
(
)
;
i
+
+
)
{
CrossLinkMessage
(
&
file
-
>
message_types_
[
i
]
proto
.
message_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
file
-
>
extension_count
(
)
;
i
+
+
)
{
CrossLinkField
(
&
file
-
>
extensions_
[
i
]
proto
.
extension
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
file
-
>
enum_type_count
(
)
;
i
+
+
)
{
CrossLinkEnum
(
&
file
-
>
enum_types_
[
i
]
proto
.
enum_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
file
-
>
service_count
(
)
;
i
+
+
)
{
CrossLinkService
(
&
file
-
>
services_
[
i
]
proto
.
service
(
i
)
)
;
}
}
void
DescriptorBuilder
:
:
CrossLinkMessage
(
Descriptor
*
message
const
DescriptorProto
&
proto
)
{
if
(
message
-
>
options_
=
=
nullptr
)
{
message
-
>
options_
=
&
MessageOptions
:
:
default_instance
(
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
nested_type_count
(
)
;
i
+
+
)
{
CrossLinkMessage
(
&
message
-
>
nested_types_
[
i
]
proto
.
nested_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
enum_type_count
(
)
;
i
+
+
)
{
CrossLinkEnum
(
&
message
-
>
enum_types_
[
i
]
proto
.
enum_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
field_count
(
)
;
i
+
+
)
{
CrossLinkField
(
&
message
-
>
fields_
[
i
]
proto
.
field
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
extension_count
(
)
;
i
+
+
)
{
CrossLinkField
(
&
message
-
>
extensions_
[
i
]
proto
.
extension
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
extension_range_count
(
)
;
i
+
+
)
{
CrossLinkExtensionRange
(
&
message
-
>
extension_ranges_
[
i
]
proto
.
extension_range
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
field_count
(
)
;
i
+
+
)
{
const
OneofDescriptor
*
oneof_decl
=
message
-
>
field
(
i
)
-
>
containing_oneof
(
)
;
if
(
oneof_decl
!
=
nullptr
)
{
if
(
oneof_decl
-
>
field_count
(
)
>
0
&
&
message
-
>
field
(
i
-
1
)
-
>
containing_oneof
(
)
!
=
oneof_decl
)
{
AddError
(
message
-
>
full_name
(
)
+
"
.
"
+
message
-
>
field
(
i
-
1
)
-
>
name
(
)
proto
.
field
(
i
-
1
)
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
strings
:
:
Substitute
(
"
Fields
in
the
same
oneof
must
be
defined
consecutively
.
"
"
\
"
0
\
"
cannot
be
defined
before
the
completion
of
the
"
"
\
"
1
\
"
oneof
definition
.
"
message
-
>
field
(
i
-
1
)
-
>
name
(
)
oneof_decl
-
>
name
(
)
)
)
;
}
auto
&
out_oneof_decl
=
message
-
>
oneof_decls_
[
oneof_decl
-
>
index
(
)
]
;
if
(
out_oneof_decl
.
field_count_
=
=
0
)
{
out_oneof_decl
.
fields_
=
message
-
>
field
(
i
)
;
}
if
(
!
had_errors_
)
{
GOOGLE_CHECK_EQ
(
out_oneof_decl
.
fields_
+
out_oneof_decl
.
field_count_
message
-
>
field
(
i
)
)
;
}
+
+
out_oneof_decl
.
field_count_
;
}
}
for
(
int
i
=
0
;
i
<
message
-
>
oneof_decl_count
(
)
;
i
+
+
)
{
OneofDescriptor
*
oneof_decl
=
&
message
-
>
oneof_decls_
[
i
]
;
if
(
oneof_decl
-
>
field_count
(
)
=
=
0
)
{
AddError
(
message
-
>
full_name
(
)
+
"
.
"
+
oneof_decl
-
>
name
(
)
proto
.
oneof_decl
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Oneof
must
have
at
least
one
field
.
"
)
;
}
if
(
oneof_decl
-
>
options_
=
=
nullptr
)
{
oneof_decl
-
>
options_
=
&
OneofOptions
:
:
default_instance
(
)
;
}
}
for
(
int
i
=
0
;
i
<
message
-
>
field_count
(
)
;
i
+
+
)
{
const
FieldDescriptor
*
field
=
message
-
>
field
(
i
)
;
if
(
field
-
>
proto3_optional_
)
{
if
(
!
field
-
>
containing_oneof
(
)
|
|
!
field
-
>
containing_oneof
(
)
-
>
is_synthetic
(
)
)
{
AddError
(
message
-
>
full_name
(
)
proto
.
field
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
Fields
with
proto3_optional
set
must
be
"
"
a
member
of
a
one
-
field
oneof
"
)
;
}
}
}
int
first_synthetic
=
-
1
;
for
(
int
i
=
0
;
i
<
message
-
>
oneof_decl_count
(
)
;
i
+
+
)
{
const
OneofDescriptor
*
oneof
=
message
-
>
oneof_decl
(
i
)
;
if
(
oneof
-
>
is_synthetic
(
)
)
{
if
(
first_synthetic
=
=
-
1
)
{
first_synthetic
=
i
;
}
}
else
{
if
(
first_synthetic
!
=
-
1
)
{
AddError
(
message
-
>
full_name
(
)
proto
.
oneof_decl
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
Synthetic
oneofs
must
be
after
all
other
oneofs
"
)
;
}
}
}
if
(
first_synthetic
=
=
-
1
)
{
message
-
>
real_oneof_decl_count_
=
message
-
>
oneof_decl_count_
;
}
else
{
message
-
>
real_oneof_decl_count_
=
first_synthetic
;
}
}
void
DescriptorBuilder
:
:
CrossLinkExtensionRange
(
Descriptor
:
:
ExtensionRange
*
range
const
DescriptorProto
:
:
ExtensionRange
&
)
{
if
(
range
-
>
options_
=
=
nullptr
)
{
range
-
>
options_
=
&
ExtensionRangeOptions
:
:
default_instance
(
)
;
}
}
void
DescriptorBuilder
:
:
CrossLinkField
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
{
if
(
field
-
>
options_
=
=
nullptr
)
{
field
-
>
options_
=
&
FieldOptions
:
:
default_instance
(
)
;
}
if
(
proto
.
has_extendee
(
)
)
{
Symbol
extendee
=
LookupSymbol
(
proto
.
extendee
(
)
field
-
>
full_name
(
)
DescriptorPool
:
:
PLACEHOLDER_EXTENDABLE_MESSAGE
)
;
if
(
extendee
.
IsNull
(
)
)
{
AddNotDefinedError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
EXTENDEE
proto
.
extendee
(
)
)
;
return
;
}
else
if
(
extendee
.
type
(
)
!
=
Symbol
:
:
MESSAGE
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
EXTENDEE
"
\
"
"
+
proto
.
extendee
(
)
+
"
\
"
is
not
a
message
type
.
"
)
;
return
;
}
field
-
>
containing_type_
=
extendee
.
descriptor
(
)
;
const
Descriptor
:
:
ExtensionRange
*
extension_range
=
field
-
>
containing_type
(
)
-
>
FindExtensionRangeContainingNumber
(
field
-
>
number
(
)
)
;
if
(
extension_range
=
=
nullptr
)
{
auto
skip_check
=
get_allow_unknown
(
pool_
)
&
&
proto
.
extendee
(
)
=
=
"
google
.
protobuf
.
bridge
.
MessageSet
"
;
if
(
!
skip_check
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
\
"
0
\
"
does
not
declare
1
as
an
"
"
extension
number
.
"
field
-
>
containing_type
(
)
-
>
full_name
(
)
field
-
>
number
(
)
)
)
;
}
}
}
if
(
field
-
>
containing_oneof
(
)
!
=
nullptr
)
{
if
(
field
-
>
label
(
)
!
=
FieldDescriptor
:
:
LABEL_OPTIONAL
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Fields
of
oneofs
must
themselves
have
label
LABEL_OPTIONAL
.
"
)
;
}
}
if
(
proto
.
has_type_name
(
)
)
{
bool
expecting_enum
=
(
proto
.
type
(
)
=
=
FieldDescriptorProto
:
:
TYPE_ENUM
)
|
|
proto
.
has_default_value
(
)
;
bool
is_weak
=
!
pool_
-
>
enforce_weak_
&
&
proto
.
options
(
)
.
weak
(
)
;
bool
is_lazy
=
pool_
-
>
lazily_build_dependencies_
&
&
!
is_weak
;
Symbol
type
=
LookupSymbol
(
proto
.
type_name
(
)
field
-
>
full_name
(
)
expecting_enum
?
DescriptorPool
:
:
PLACEHOLDER_ENUM
:
DescriptorPool
:
:
PLACEHOLDER_MESSAGE
LOOKUP_TYPES
!
is_lazy
)
;
if
(
type
.
IsNull
(
)
)
{
if
(
is_lazy
)
{
const
std
:
:
string
&
name
=
proto
.
type_name
(
)
;
int
name_sizes
=
static_cast
<
int
>
(
name
.
size
(
)
+
1
+
proto
.
default_value
(
)
.
size
(
)
+
1
)
;
field
-
>
type_once_
=
:
:
new
(
tables_
-
>
AllocateBytes
(
static_cast
<
int
>
(
sizeof
(
internal
:
:
once_flag
)
+
name_sizes
)
)
)
internal
:
:
once_flag
{
}
;
char
*
names
=
reinterpret_cast
<
char
*
>
(
field
-
>
type_once_
+
1
)
;
memcpy
(
names
name
.
c_str
(
)
name
.
size
(
)
+
1
)
;
memcpy
(
names
+
name
.
size
(
)
+
1
proto
.
default_value
(
)
.
c_str
(
)
proto
.
default_value
(
)
.
size
(
)
+
1
)
;
file_tables_
-
>
AddFieldByNumber
(
field
)
;
if
(
field
-
>
is_extension
(
)
)
{
tables_
-
>
AddExtension
(
field
)
;
}
return
;
}
else
{
if
(
is_weak
)
{
type
=
FindSymbol
(
kNonLinkedWeakMessageReplacementName
)
;
}
if
(
type
.
IsNull
(
)
)
{
AddNotDefinedError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
proto
.
type_name
(
)
)
;
return
;
}
}
}
if
(
!
proto
.
has_type
(
)
)
{
if
(
type
.
type
(
)
=
=
Symbol
:
:
MESSAGE
)
{
field
-
>
type_
=
FieldDescriptor
:
:
TYPE_MESSAGE
;
}
else
if
(
type
.
type
(
)
=
=
Symbol
:
:
ENUM
)
{
field
-
>
type_
=
FieldDescriptor
:
:
TYPE_ENUM
;
}
else
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
\
"
"
+
proto
.
type_name
(
)
+
"
\
"
is
not
a
type
.
"
)
;
return
;
}
}
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
field
-
>
type_descriptor_
.
message_type
=
type
.
descriptor
(
)
;
if
(
field
-
>
type_descriptor_
.
message_type
=
=
nullptr
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
\
"
"
+
proto
.
type_name
(
)
+
"
\
"
is
not
a
message
type
.
"
)
;
return
;
}
if
(
field
-
>
has_default_value
(
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Messages
can
'
t
have
default
values
.
"
)
;
}
}
else
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_ENUM
)
{
field
-
>
type_descriptor_
.
enum_type
=
type
.
enum_descriptor
(
)
;
if
(
field
-
>
type_descriptor_
.
enum_type
=
=
nullptr
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
\
"
"
+
proto
.
type_name
(
)
+
"
\
"
is
not
an
enum
type
.
"
)
;
return
;
}
if
(
field
-
>
enum_type
(
)
-
>
is_placeholder_
)
{
field
-
>
has_default_value_
=
false
;
}
if
(
field
-
>
has_default_value
(
)
)
{
if
(
!
io
:
:
Tokenizer
:
:
IsIdentifier
(
proto
.
default_value
(
)
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Default
value
for
an
enum
field
must
be
an
identifier
.
"
)
;
}
else
{
const
EnumValueDescriptor
*
default_value
=
LookupSymbolNoPlaceholder
(
proto
.
default_value
(
)
field
-
>
enum_type
(
)
-
>
full_name
(
)
)
.
enum_value_descriptor
(
)
;
if
(
default_value
!
=
nullptr
&
&
default_value
-
>
type
(
)
=
=
field
-
>
enum_type
(
)
)
{
field
-
>
default_value_enum_
=
default_value
;
}
else
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Enum
type
\
"
"
+
field
-
>
enum_type
(
)
-
>
full_name
(
)
+
"
\
"
has
no
value
named
\
"
"
+
proto
.
default_value
(
)
+
"
\
"
.
"
)
;
}
}
}
else
if
(
field
-
>
enum_type
(
)
-
>
value_count
(
)
>
0
)
{
field
-
>
default_value_enum_
=
field
-
>
enum_type
(
)
-
>
value
(
0
)
;
}
}
else
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Field
with
primitive
type
has
type_name
.
"
)
;
}
}
else
{
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
|
|
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_ENUM
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Field
with
message
or
enum
type
missing
type_name
.
"
)
;
}
}
if
(
!
file_tables_
-
>
AddFieldByNumber
(
field
)
)
{
const
FieldDescriptor
*
conflicting_field
=
file_tables_
-
>
FindFieldByNumber
(
field
-
>
containing_type
(
)
field
-
>
number
(
)
)
;
std
:
:
string
containing_type_name
=
field
-
>
containing_type
(
)
=
=
nullptr
?
"
unknown
"
:
field
-
>
containing_type
(
)
-
>
full_name
(
)
;
if
(
field
-
>
is_extension
(
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Extension
number
0
has
already
been
used
"
"
in
\
"
1
\
"
by
extension
\
"
2
\
"
.
"
field
-
>
number
(
)
containing_type_name
conflicting_field
-
>
full_name
(
)
)
)
;
}
else
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Field
number
0
has
already
been
used
in
"
"
\
"
1
\
"
by
field
\
"
2
\
"
.
"
field
-
>
number
(
)
containing_type_name
conflicting_field
-
>
name
(
)
)
)
;
}
}
else
{
if
(
field
-
>
is_extension
(
)
)
{
if
(
!
tables_
-
>
AddExtension
(
field
)
)
{
const
FieldDescriptor
*
conflicting_field
=
tables_
-
>
FindExtension
(
field
-
>
containing_type
(
)
field
-
>
number
(
)
)
;
std
:
:
string
containing_type_name
=
field
-
>
containing_type
(
)
=
=
nullptr
?
"
unknown
"
:
field
-
>
containing_type
(
)
-
>
full_name
(
)
;
std
:
:
string
error_msg
=
strings
:
:
Substitute
(
"
Extension
number
0
has
already
been
used
in
\
"
1
\
"
by
extension
"
"
\
"
2
\
"
defined
in
3
.
"
field
-
>
number
(
)
containing_type_name
conflicting_field
-
>
full_name
(
)
conflicting_field
-
>
file
(
)
-
>
name
(
)
)
;
AddWarning
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
error_msg
)
;
}
}
}
}
void
DescriptorBuilder
:
:
CrossLinkEnum
(
EnumDescriptor
*
enum_type
const
EnumDescriptorProto
&
proto
)
{
if
(
enum_type
-
>
options_
=
=
nullptr
)
{
enum_type
-
>
options_
=
&
EnumOptions
:
:
default_instance
(
)
;
}
for
(
int
i
=
0
;
i
<
enum_type
-
>
value_count
(
)
;
i
+
+
)
{
CrossLinkEnumValue
(
&
enum_type
-
>
values_
[
i
]
proto
.
value
(
i
)
)
;
}
}
void
DescriptorBuilder
:
:
CrossLinkEnumValue
(
EnumValueDescriptor
*
enum_value
const
EnumValueDescriptorProto
&
)
{
if
(
enum_value
-
>
options_
=
=
nullptr
)
{
enum_value
-
>
options_
=
&
EnumValueOptions
:
:
default_instance
(
)
;
}
}
void
DescriptorBuilder
:
:
CrossLinkService
(
ServiceDescriptor
*
service
const
ServiceDescriptorProto
&
proto
)
{
if
(
service
-
>
options_
=
=
nullptr
)
{
service
-
>
options_
=
&
ServiceOptions
:
:
default_instance
(
)
;
}
for
(
int
i
=
0
;
i
<
service
-
>
method_count
(
)
;
i
+
+
)
{
CrossLinkMethod
(
&
service
-
>
methods_
[
i
]
proto
.
method
(
i
)
)
;
}
}
void
DescriptorBuilder
:
:
CrossLinkMethod
(
MethodDescriptor
*
method
const
MethodDescriptorProto
&
proto
)
{
if
(
method
-
>
options_
=
=
nullptr
)
{
method
-
>
options_
=
&
MethodOptions
:
:
default_instance
(
)
;
}
Symbol
input_type
=
LookupSymbol
(
proto
.
input_type
(
)
method
-
>
full_name
(
)
DescriptorPool
:
:
PLACEHOLDER_MESSAGE
LOOKUP_ALL
!
pool_
-
>
lazily_build_dependencies_
)
;
if
(
input_type
.
IsNull
(
)
)
{
if
(
!
pool_
-
>
lazily_build_dependencies_
)
{
AddNotDefinedError
(
method
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
INPUT_TYPE
proto
.
input_type
(
)
)
;
}
else
{
method
-
>
input_type_
.
SetLazy
(
proto
.
input_type
(
)
file_
)
;
}
}
else
if
(
input_type
.
type
(
)
!
=
Symbol
:
:
MESSAGE
)
{
AddError
(
method
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
INPUT_TYPE
"
\
"
"
+
proto
.
input_type
(
)
+
"
\
"
is
not
a
message
type
.
"
)
;
}
else
{
method
-
>
input_type_
.
Set
(
input_type
.
descriptor
(
)
)
;
}
Symbol
output_type
=
LookupSymbol
(
proto
.
output_type
(
)
method
-
>
full_name
(
)
DescriptorPool
:
:
PLACEHOLDER_MESSAGE
LOOKUP_ALL
!
pool_
-
>
lazily_build_dependencies_
)
;
if
(
output_type
.
IsNull
(
)
)
{
if
(
!
pool_
-
>
lazily_build_dependencies_
)
{
AddNotDefinedError
(
method
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OUTPUT_TYPE
proto
.
output_type
(
)
)
;
}
else
{
method
-
>
output_type_
.
SetLazy
(
proto
.
output_type
(
)
file_
)
;
}
}
else
if
(
output_type
.
type
(
)
!
=
Symbol
:
:
MESSAGE
)
{
AddError
(
method
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OUTPUT_TYPE
"
\
"
"
+
proto
.
output_type
(
)
+
"
\
"
is
not
a
message
type
.
"
)
;
}
else
{
method
-
>
output_type_
.
Set
(
output_type
.
descriptor
(
)
)
;
}
}
void
DescriptorBuilder
:
:
SuggestFieldNumbers
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
{
for
(
int
message_index
=
0
;
message_index
<
file
-
>
message_type_count
(
)
;
message_index
+
+
)
{
const
Descriptor
*
message
=
&
file
-
>
message_types_
[
message_index
]
;
auto
*
hints
=
FindOrNull
(
message_hints_
message
)
;
if
(
!
hints
)
continue
;
constexpr
int
kMaxSuggestions
=
3
;
int
fields_to_suggest
=
std
:
:
min
(
kMaxSuggestions
hints
-
>
fields_to_suggest
)
;
if
(
fields_to_suggest
<
=
0
)
continue
;
struct
Range
{
int
from
;
int
to
;
}
;
std
:
:
vector
<
Range
>
used_ordinals
;
auto
add_ordinal
=
[
&
]
(
int
ordinal
)
{
if
(
ordinal
<
=
0
|
|
ordinal
>
FieldDescriptor
:
:
kMaxNumber
)
return
;
if
(
!
used_ordinals
.
empty
(
)
&
&
ordinal
=
=
used_ordinals
.
back
(
)
.
to
)
{
used_ordinals
.
back
(
)
.
to
=
ordinal
+
1
;
}
else
{
used_ordinals
.
push_back
(
{
ordinal
ordinal
+
1
}
)
;
}
}
;
auto
add_range
=
[
&
]
(
int
from
int
to
)
{
from
=
std
:
:
max
(
0
std
:
:
min
(
FieldDescriptor
:
:
kMaxNumber
+
1
from
)
)
;
to
=
std
:
:
max
(
0
std
:
:
min
(
FieldDescriptor
:
:
kMaxNumber
+
1
to
)
)
;
if
(
from
>
=
to
)
return
;
used_ordinals
.
push_back
(
{
from
to
}
)
;
}
;
for
(
int
i
=
0
;
i
<
message
-
>
field_count
(
)
;
i
+
+
)
{
add_ordinal
(
message
-
>
field
(
i
)
-
>
number
(
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
extension_count
(
)
;
i
+
+
)
{
add_ordinal
(
message
-
>
extension
(
i
)
-
>
number
(
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
reserved_range_count
(
)
;
i
+
+
)
{
auto
range
=
message
-
>
reserved_range
(
i
)
;
add_range
(
range
-
>
start
range
-
>
end
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
extension_range_count
(
)
;
i
+
+
)
{
auto
range
=
message
-
>
extension_range
(
i
)
;
add_range
(
range
-
>
start
range
-
>
end
)
;
}
used_ordinals
.
push_back
(
{
FieldDescriptor
:
:
kMaxNumber
FieldDescriptor
:
:
kMaxNumber
+
1
}
)
;
used_ordinals
.
push_back
(
{
FieldDescriptor
:
:
kFirstReservedNumber
FieldDescriptor
:
:
kLastReservedNumber
}
)
;
std
:
:
sort
(
used_ordinals
.
begin
(
)
used_ordinals
.
end
(
)
[
]
(
Range
lhs
Range
rhs
)
{
return
std
:
:
tie
(
lhs
.
from
lhs
.
to
)
<
std
:
:
tie
(
rhs
.
from
rhs
.
to
)
;
}
)
;
int
current_ordinal
=
1
;
std
:
:
stringstream
id_list
;
id_list
<
<
"
Suggested
field
numbers
for
"
<
<
message
-
>
full_name
(
)
<
<
"
:
"
;
const
char
*
separator
=
"
"
;
for
(
auto
&
current_range
:
used_ordinals
)
{
while
(
current_ordinal
<
current_range
.
from
&
&
fields_to_suggest
>
0
)
{
id_list
<
<
separator
<
<
current_ordinal
+
+
;
separator
=
"
"
;
fields_to_suggest
-
-
;
}
if
(
fields_to_suggest
=
=
0
)
break
;
current_ordinal
=
std
:
:
max
(
current_ordinal
current_range
.
to
)
;
}
if
(
hints
-
>
first_reason
)
{
AddError
(
message
-
>
full_name
(
)
*
hints
-
>
first_reason
hints
-
>
first_reason_location
id_list
.
str
(
)
)
;
}
}
}
#
define
VALIDATE_OPTIONS_FROM_ARRAY
(
descriptor
array_name
type
)
\
for
(
int
i
=
0
;
i
<
descriptor
-
>
array_name
#
#
_count
(
)
;
+
+
i
)
{
\
Validate
#
#
type
#
#
Options
(
descriptor
-
>
array_name
#
#
s_
+
i
\
proto
.
array_name
(
i
)
)
;
\
}
static
bool
IsLite
(
const
FileDescriptor
*
file
)
{
return
file
!
=
nullptr
&
&
&
file
-
>
options
(
)
!
=
&
FileOptions
:
:
default_instance
(
)
&
&
file
-
>
options
(
)
.
optimize_for
(
)
=
=
FileOptions
:
:
LITE_RUNTIME
;
}
void
DescriptorBuilder
:
:
ValidateFileOptions
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
{
VALIDATE_OPTIONS_FROM_ARRAY
(
file
message_type
Message
)
;
VALIDATE_OPTIONS_FROM_ARRAY
(
file
enum_type
Enum
)
;
VALIDATE_OPTIONS_FROM_ARRAY
(
file
service
Service
)
;
VALIDATE_OPTIONS_FROM_ARRAY
(
file
extension
Field
)
;
if
(
!
IsLite
(
file
)
)
{
for
(
int
i
=
0
;
i
<
file
-
>
dependency_count
(
)
;
i
+
+
)
{
if
(
IsLite
(
file
-
>
dependency
(
i
)
)
)
{
AddError
(
file
-
>
dependency
(
i
)
-
>
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
IMPORT
"
Files
that
do
not
use
optimize_for
=
LITE_RUNTIME
cannot
import
"
"
files
which
do
use
this
option
.
This
file
is
not
lite
but
it
"
"
imports
\
"
"
+
file
-
>
dependency
(
i
)
-
>
name
(
)
+
"
\
"
which
is
.
"
)
;
break
;
}
}
}
if
(
file
-
>
syntax
(
)
=
=
FileDescriptor
:
:
SYNTAX_PROTO3
)
{
ValidateProto3
(
file
proto
)
;
}
}
void
DescriptorBuilder
:
:
ValidateProto3
(
FileDescriptor
*
file
const
FileDescriptorProto
&
proto
)
{
for
(
int
i
=
0
;
i
<
file
-
>
extension_count
(
)
;
+
+
i
)
{
ValidateProto3Field
(
file
-
>
extensions_
+
i
proto
.
extension
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
file
-
>
message_type_count
(
)
;
+
+
i
)
{
ValidateProto3Message
(
file
-
>
message_types_
+
i
proto
.
message_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
file
-
>
enum_type_count
(
)
;
+
+
i
)
{
ValidateProto3Enum
(
file
-
>
enum_types_
+
i
proto
.
enum_type
(
i
)
)
;
}
}
static
std
:
:
string
ToLowercaseWithoutUnderscores
(
const
std
:
:
string
&
name
)
{
std
:
:
string
result
;
for
(
char
character
:
name
)
{
if
(
character
!
=
'
_
'
)
{
if
(
character
>
=
'
A
'
&
&
character
<
=
'
Z
'
)
{
result
.
push_back
(
character
-
'
A
'
+
'
a
'
)
;
}
else
{
result
.
push_back
(
character
)
;
}
}
}
return
result
;
}
void
DescriptorBuilder
:
:
ValidateProto3Message
(
Descriptor
*
message
const
DescriptorProto
&
proto
)
{
for
(
int
i
=
0
;
i
<
message
-
>
nested_type_count
(
)
;
+
+
i
)
{
ValidateProto3Message
(
message
-
>
nested_types_
+
i
proto
.
nested_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
enum_type_count
(
)
;
+
+
i
)
{
ValidateProto3Enum
(
message
-
>
enum_types_
+
i
proto
.
enum_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
field_count
(
)
;
+
+
i
)
{
ValidateProto3Field
(
message
-
>
fields_
+
i
proto
.
field
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
extension_count
(
)
;
+
+
i
)
{
ValidateProto3Field
(
message
-
>
extensions_
+
i
proto
.
extension
(
i
)
)
;
}
if
(
message
-
>
extension_range_count
(
)
>
0
)
{
AddError
(
message
-
>
full_name
(
)
proto
.
extension_range
(
0
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
Extension
ranges
are
not
allowed
in
proto3
.
"
)
;
}
if
(
message
-
>
options
(
)
.
message_set_wire_format
(
)
)
{
AddError
(
message
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
MessageSet
is
not
supported
in
proto3
.
"
)
;
}
std
:
:
map
<
std
:
:
string
const
FieldDescriptor
*
>
name_to_field
;
for
(
int
i
=
0
;
i
<
message
-
>
field_count
(
)
;
+
+
i
)
{
std
:
:
string
lowercase_name
=
ToLowercaseWithoutUnderscores
(
message
-
>
field
(
i
)
-
>
name
(
)
)
;
if
(
name_to_field
.
find
(
lowercase_name
)
!
=
name_to_field
.
end
(
)
)
{
AddError
(
message
-
>
full_name
(
)
proto
.
field
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
The
JSON
camel
-
case
name
of
field
\
"
"
+
message
-
>
field
(
i
)
-
>
name
(
)
+
"
\
"
conflicts
with
field
\
"
"
+
name_to_field
[
lowercase_name
]
-
>
name
(
)
+
"
\
"
.
This
is
not
"
+
"
allowed
in
proto3
.
"
)
;
}
else
{
name_to_field
[
lowercase_name
]
=
message
-
>
field
(
i
)
;
}
}
}
void
DescriptorBuilder
:
:
ValidateProto3Field
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
{
if
(
field
-
>
is_extension
(
)
&
&
!
AllowedExtendeeInProto3
(
field
-
>
containing_type
(
)
-
>
full_name
(
)
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
EXTENDEE
"
Extensions
in
proto3
are
only
allowed
for
defining
options
.
"
)
;
}
if
(
field
-
>
is_required
(
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Required
fields
are
not
allowed
in
proto3
.
"
)
;
}
if
(
field
-
>
has_default_value
(
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
DEFAULT_VALUE
"
Explicit
default
values
are
not
allowed
in
proto3
.
"
)
;
}
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_ENUM
&
&
field
-
>
enum_type
(
)
&
&
field
-
>
enum_type
(
)
-
>
file
(
)
-
>
syntax
(
)
!
=
FileDescriptor
:
:
SYNTAX_PROTO3
&
&
field
-
>
enum_type
(
)
-
>
file
(
)
-
>
syntax
(
)
!
=
FileDescriptor
:
:
SYNTAX_UNKNOWN
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Enum
type
\
"
"
+
field
-
>
enum_type
(
)
-
>
full_name
(
)
+
"
\
"
is
not
a
proto3
enum
but
is
used
in
\
"
"
+
field
-
>
containing_type
(
)
-
>
full_name
(
)
+
"
\
"
which
is
a
proto3
message
type
.
"
)
;
}
if
(
field
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_GROUP
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Groups
are
not
supported
in
proto3
syntax
.
"
)
;
}
}
void
DescriptorBuilder
:
:
ValidateProto3Enum
(
EnumDescriptor
*
enm
const
EnumDescriptorProto
&
proto
)
{
if
(
enm
-
>
value_count
(
)
>
0
&
&
enm
-
>
value
(
0
)
-
>
number
(
)
!
=
0
)
{
AddError
(
enm
-
>
full_name
(
)
proto
.
value
(
0
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
"
The
first
enum
value
must
be
zero
in
proto3
.
"
)
;
}
}
void
DescriptorBuilder
:
:
ValidateMessageOptions
(
Descriptor
*
message
const
DescriptorProto
&
proto
)
{
VALIDATE_OPTIONS_FROM_ARRAY
(
message
field
Field
)
;
VALIDATE_OPTIONS_FROM_ARRAY
(
message
nested_type
Message
)
;
VALIDATE_OPTIONS_FROM_ARRAY
(
message
enum_type
Enum
)
;
VALIDATE_OPTIONS_FROM_ARRAY
(
message
extension
Field
)
;
const
int64_t
max_extension_range
=
static_cast
<
int64_t
>
(
message
-
>
options
(
)
.
message_set_wire_format
(
)
?
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
:
FieldDescriptor
:
:
kMaxNumber
)
;
for
(
int
i
=
0
;
i
<
message
-
>
extension_range_count
(
)
;
+
+
i
)
{
if
(
message
-
>
extension_range
(
i
)
-
>
end
>
max_extension_range
+
1
)
{
AddError
(
message
-
>
full_name
(
)
proto
.
extension_range
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
strings
:
:
Substitute
(
"
Extension
numbers
cannot
be
greater
than
0
.
"
max_extension_range
)
)
;
}
ValidateExtensionRangeOptions
(
message
-
>
full_name
(
)
message
-
>
extension_ranges_
+
i
proto
.
extension_range
(
i
)
)
;
}
}
void
DescriptorBuilder
:
:
ValidateFieldOptions
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
{
if
(
pool_
-
>
lazily_build_dependencies_
&
&
(
!
field
|
|
!
field
-
>
message_type
(
)
)
)
{
return
;
}
if
(
field
-
>
options
(
)
.
lazy
(
)
|
|
field
-
>
options
(
)
.
unverified_lazy
(
)
)
{
if
(
field
-
>
type
(
)
!
=
FieldDescriptor
:
:
TYPE_MESSAGE
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
[
lazy
=
true
]
can
only
be
specified
for
submessage
fields
.
"
)
;
}
}
if
(
field
-
>
options
(
)
.
packed
(
)
&
&
!
field
-
>
is_packable
(
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
[
packed
=
true
]
can
only
be
specified
for
repeated
primitive
fields
.
"
)
;
}
if
(
field
-
>
containing_type_
!
=
nullptr
&
&
&
field
-
>
containing_type
(
)
-
>
options
(
)
!
=
&
MessageOptions
:
:
default_instance
(
)
&
&
field
-
>
containing_type
(
)
-
>
options
(
)
.
message_set_wire_format
(
)
)
{
if
(
field
-
>
is_extension
(
)
)
{
if
(
!
field
-
>
is_optional
(
)
|
|
field
-
>
type
(
)
!
=
FieldDescriptor
:
:
TYPE_MESSAGE
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Extensions
of
MessageSets
must
be
optional
messages
.
"
)
;
}
}
else
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
MessageSets
cannot
have
fields
only
extensions
.
"
)
;
}
}
if
(
IsLite
(
field
-
>
file
(
)
)
&
&
field
-
>
containing_type_
!
=
nullptr
&
&
!
IsLite
(
field
-
>
containing_type
(
)
-
>
file
(
)
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
EXTENDEE
"
Extensions
to
non
-
lite
types
can
only
be
declared
in
non
-
lite
"
"
files
.
Note
that
you
cannot
extend
a
non
-
lite
type
to
contain
"
"
a
lite
type
but
the
reverse
is
allowed
.
"
)
;
}
if
(
field
-
>
is_map
(
)
)
{
if
(
!
ValidateMapEntry
(
field
proto
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
map_entry
should
not
be
set
explicitly
.
Use
map
<
KeyType
"
"
ValueType
>
instead
.
"
)
;
}
}
ValidateJSType
(
field
proto
)
;
if
(
field
-
>
is_extension
(
)
&
&
(
field
-
>
has_json_name
(
)
&
&
field
-
>
json_name
(
)
!
=
ToJsonName
(
field
-
>
name
(
)
)
)
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
OPTION_NAME
"
option
json_name
is
not
allowed
on
extension
fields
.
"
)
;
}
}
void
DescriptorBuilder
:
:
ValidateEnumOptions
(
EnumDescriptor
*
enm
const
EnumDescriptorProto
&
proto
)
{
VALIDATE_OPTIONS_FROM_ARRAY
(
enm
value
EnumValue
)
;
if
(
!
enm
-
>
options
(
)
.
has_allow_alias
(
)
|
|
!
enm
-
>
options
(
)
.
allow_alias
(
)
)
{
std
:
:
map
<
int
std
:
:
string
>
used_values
;
for
(
int
i
=
0
;
i
<
enm
-
>
value_count
(
)
;
+
+
i
)
{
const
EnumValueDescriptor
*
enum_value
=
enm
-
>
value
(
i
)
;
if
(
used_values
.
find
(
enum_value
-
>
number
(
)
)
!
=
used_values
.
end
(
)
)
{
std
:
:
string
error
=
"
\
"
"
+
enum_value
-
>
full_name
(
)
+
"
\
"
uses
the
same
enum
value
as
\
"
"
+
used_values
[
enum_value
-
>
number
(
)
]
+
"
\
"
.
If
this
is
intended
set
"
"
'
option
allow_alias
=
true
;
'
to
the
enum
definition
.
"
;
if
(
!
enm
-
>
options
(
)
.
allow_alias
(
)
)
{
AddError
(
enm
-
>
full_name
(
)
proto
.
value
(
i
)
DescriptorPool
:
:
ErrorCollector
:
:
NUMBER
error
)
;
}
}
else
{
used_values
[
enum_value
-
>
number
(
)
]
=
enum_value
-
>
full_name
(
)
;
}
}
}
}
void
DescriptorBuilder
:
:
ValidateEnumValueOptions
(
EnumValueDescriptor
*
const
EnumValueDescriptorProto
&
)
{
}
void
DescriptorBuilder
:
:
ValidateExtensionRangeOptions
(
const
std
:
:
string
&
full_name
Descriptor
:
:
ExtensionRange
*
extension_range
const
DescriptorProto_ExtensionRange
&
proto
)
{
(
void
)
full_name
;
(
void
)
extension_range
;
}
void
DescriptorBuilder
:
:
ValidateServiceOptions
(
ServiceDescriptor
*
service
const
ServiceDescriptorProto
&
proto
)
{
if
(
IsLite
(
service
-
>
file
(
)
)
&
&
(
service
-
>
file
(
)
-
>
options
(
)
.
cc_generic_services
(
)
|
|
service
-
>
file
(
)
-
>
options
(
)
.
java_generic_services
(
)
)
)
{
AddError
(
service
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Files
with
optimize_for
=
LITE_RUNTIME
cannot
define
services
"
"
unless
you
set
both
options
cc_generic_services
and
"
"
java_generic_services
to
false
.
"
)
;
}
VALIDATE_OPTIONS_FROM_ARRAY
(
service
method
Method
)
;
}
void
DescriptorBuilder
:
:
ValidateMethodOptions
(
MethodDescriptor
*
const
MethodDescriptorProto
&
)
{
}
bool
DescriptorBuilder
:
:
ValidateMapEntry
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
{
const
Descriptor
*
message
=
field
-
>
message_type
(
)
;
if
(
message
-
>
extension_count
(
)
!
=
0
|
|
field
-
>
label
(
)
!
=
FieldDescriptor
:
:
LABEL_REPEATED
|
|
message
-
>
extension_range_count
(
)
!
=
0
|
|
message
-
>
nested_type_count
(
)
!
=
0
|
|
message
-
>
enum_type_count
(
)
!
=
0
|
|
message
-
>
field_count
(
)
!
=
2
|
|
message
-
>
name
(
)
!
=
ToCamelCase
(
field
-
>
name
(
)
false
)
+
"
Entry
"
|
|
field
-
>
containing_type
(
)
!
=
message
-
>
containing_type
(
)
)
{
return
false
;
}
const
FieldDescriptor
*
key
=
message
-
>
map_key
(
)
;
const
FieldDescriptor
*
value
=
message
-
>
map_value
(
)
;
if
(
key
-
>
label
(
)
!
=
FieldDescriptor
:
:
LABEL_OPTIONAL
|
|
key
-
>
number
(
)
!
=
1
|
|
key
-
>
name
(
)
!
=
"
key
"
)
{
return
false
;
}
if
(
value
-
>
label
(
)
!
=
FieldDescriptor
:
:
LABEL_OPTIONAL
|
|
value
-
>
number
(
)
!
=
2
|
|
value
-
>
name
(
)
!
=
"
value
"
)
{
return
false
;
}
switch
(
key
-
>
type
(
)
)
{
case
FieldDescriptor
:
:
TYPE_ENUM
:
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Key
in
map
fields
cannot
be
enum
types
.
"
)
;
break
;
case
FieldDescriptor
:
:
TYPE_FLOAT
:
case
FieldDescriptor
:
:
TYPE_DOUBLE
:
case
FieldDescriptor
:
:
TYPE_MESSAGE
:
case
FieldDescriptor
:
:
TYPE_GROUP
:
case
FieldDescriptor
:
:
TYPE_BYTES
:
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Key
in
map
fields
cannot
be
float
/
double
bytes
or
message
types
.
"
)
;
break
;
case
FieldDescriptor
:
:
TYPE_BOOL
:
case
FieldDescriptor
:
:
TYPE_INT32
:
case
FieldDescriptor
:
:
TYPE_INT64
:
case
FieldDescriptor
:
:
TYPE_SINT32
:
case
FieldDescriptor
:
:
TYPE_SINT64
:
case
FieldDescriptor
:
:
TYPE_STRING
:
case
FieldDescriptor
:
:
TYPE_UINT32
:
case
FieldDescriptor
:
:
TYPE_UINT64
:
case
FieldDescriptor
:
:
TYPE_FIXED32
:
case
FieldDescriptor
:
:
TYPE_FIXED64
:
case
FieldDescriptor
:
:
TYPE_SFIXED32
:
case
FieldDescriptor
:
:
TYPE_SFIXED64
:
break
;
}
if
(
value
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_ENUM
)
{
if
(
value
-
>
enum_type
(
)
-
>
value
(
0
)
-
>
number
(
)
!
=
0
)
{
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Enum
value
in
map
must
define
0
as
the
first
value
.
"
)
;
}
}
return
true
;
}
void
DescriptorBuilder
:
:
DetectMapConflicts
(
const
Descriptor
*
message
const
DescriptorProto
&
proto
)
{
std
:
:
map
<
std
:
:
string
const
Descriptor
*
>
seen_types
;
for
(
int
i
=
0
;
i
<
message
-
>
nested_type_count
(
)
;
+
+
i
)
{
const
Descriptor
*
nested
=
message
-
>
nested_type
(
i
)
;
std
:
:
pair
<
std
:
:
map
<
std
:
:
string
const
Descriptor
*
>
:
:
iterator
bool
>
result
=
seen_types
.
insert
(
std
:
:
make_pair
(
nested
-
>
name
(
)
nested
)
)
;
if
(
!
result
.
second
)
{
if
(
result
.
first
-
>
second
-
>
options
(
)
.
map_entry
(
)
|
|
nested
-
>
options
(
)
.
map_entry
(
)
)
{
AddError
(
message
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Expanded
map
entry
type
"
+
nested
-
>
name
(
)
+
"
conflicts
with
an
existing
nested
message
type
.
"
)
;
break
;
}
}
DetectMapConflicts
(
message
-
>
nested_type
(
i
)
proto
.
nested_type
(
i
)
)
;
}
for
(
int
i
=
0
;
i
<
message
-
>
field_count
(
)
;
+
+
i
)
{
const
FieldDescriptor
*
field
=
message
-
>
field
(
i
)
;
std
:
:
map
<
std
:
:
string
const
Descriptor
*
>
:
:
iterator
iter
=
seen_types
.
find
(
field
-
>
name
(
)
)
;
if
(
iter
!
=
seen_types
.
end
(
)
&
&
iter
-
>
second
-
>
options
(
)
.
map_entry
(
)
)
{
AddError
(
message
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Expanded
map
entry
type
"
+
iter
-
>
second
-
>
name
(
)
+
"
conflicts
with
an
existing
field
.
"
)
;
}
}
for
(
int
i
=
0
;
i
<
message
-
>
enum_type_count
(
)
;
+
+
i
)
{
const
EnumDescriptor
*
enum_desc
=
message
-
>
enum_type
(
i
)
;
std
:
:
map
<
std
:
:
string
const
Descriptor
*
>
:
:
iterator
iter
=
seen_types
.
find
(
enum_desc
-
>
name
(
)
)
;
if
(
iter
!
=
seen_types
.
end
(
)
&
&
iter
-
>
second
-
>
options
(
)
.
map_entry
(
)
)
{
AddError
(
message
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Expanded
map
entry
type
"
+
iter
-
>
second
-
>
name
(
)
+
"
conflicts
with
an
existing
enum
type
.
"
)
;
}
}
for
(
int
i
=
0
;
i
<
message
-
>
oneof_decl_count
(
)
;
+
+
i
)
{
const
OneofDescriptor
*
oneof_desc
=
message
-
>
oneof_decl
(
i
)
;
std
:
:
map
<
std
:
:
string
const
Descriptor
*
>
:
:
iterator
iter
=
seen_types
.
find
(
oneof_desc
-
>
name
(
)
)
;
if
(
iter
!
=
seen_types
.
end
(
)
&
&
iter
-
>
second
-
>
options
(
)
.
map_entry
(
)
)
{
AddError
(
message
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
NAME
"
Expanded
map
entry
type
"
+
iter
-
>
second
-
>
name
(
)
+
"
conflicts
with
an
existing
oneof
type
.
"
)
;
}
}
}
void
DescriptorBuilder
:
:
ValidateJSType
(
FieldDescriptor
*
field
const
FieldDescriptorProto
&
proto
)
{
FieldOptions
:
:
JSType
jstype
=
field
-
>
options
(
)
.
jstype
(
)
;
if
(
jstype
=
=
FieldOptions
:
:
JS_NORMAL
)
{
return
;
}
switch
(
field
-
>
type
(
)
)
{
case
FieldDescriptor
:
:
TYPE_UINT64
:
case
FieldDescriptor
:
:
TYPE_INT64
:
case
FieldDescriptor
:
:
TYPE_SINT64
:
case
FieldDescriptor
:
:
TYPE_FIXED64
:
case
FieldDescriptor
:
:
TYPE_SFIXED64
:
if
(
jstype
=
=
FieldOptions
:
:
JS_STRING
|
|
jstype
=
=
FieldOptions
:
:
JS_NUMBER
)
{
return
;
}
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
Illegal
jstype
for
int64
uint64
sint64
fixed64
"
"
or
sfixed64
field
:
"
+
FieldOptions_JSType_descriptor
(
)
-
>
value
(
jstype
)
-
>
name
(
)
)
;
break
;
default
:
AddError
(
field
-
>
full_name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
TYPE
"
jstype
is
only
allowed
on
int64
uint64
sint64
fixed64
"
"
or
sfixed64
fields
.
"
)
;
break
;
}
}
#
undef
VALIDATE_OPTIONS_FROM_ARRAY
DescriptorBuilder
:
:
OptionInterpreter
:
:
OptionInterpreter
(
DescriptorBuilder
*
builder
)
:
builder_
(
builder
)
{
GOOGLE_CHECK
(
builder_
)
;
}
DescriptorBuilder
:
:
OptionInterpreter
:
:
~
OptionInterpreter
(
)
{
}
bool
DescriptorBuilder
:
:
OptionInterpreter
:
:
InterpretOptions
(
OptionsToInterpret
*
options_to_interpret
)
{
Message
*
options
=
options_to_interpret
-
>
options
;
const
Message
*
original_options
=
options_to_interpret
-
>
original_options
;
bool
failed
=
false
;
options_to_interpret_
=
options_to_interpret
;
const
FieldDescriptor
*
uninterpreted_options_field
=
options
-
>
GetDescriptor
(
)
-
>
FindFieldByName
(
"
uninterpreted_option
"
)
;
GOOGLE_CHECK
(
uninterpreted_options_field
!
=
nullptr
)
<
<
"
No
field
named
\
"
uninterpreted_option
\
"
in
the
Options
proto
.
"
;
options
-
>
GetReflection
(
)
-
>
ClearField
(
options
uninterpreted_options_field
)
;
std
:
:
vector
<
int
>
src_path
=
options_to_interpret
-
>
element_path
;
src_path
.
push_back
(
uninterpreted_options_field
-
>
number
(
)
)
;
const
FieldDescriptor
*
original_uninterpreted_options_field
=
original_options
-
>
GetDescriptor
(
)
-
>
FindFieldByName
(
"
uninterpreted_option
"
)
;
GOOGLE_CHECK
(
original_uninterpreted_options_field
!
=
nullptr
)
<
<
"
No
field
named
\
"
uninterpreted_option
\
"
in
the
Options
proto
.
"
;
const
int
num_uninterpreted_options
=
original_options
-
>
GetReflection
(
)
-
>
FieldSize
(
*
original_options
original_uninterpreted_options_field
)
;
for
(
int
i
=
0
;
i
<
num_uninterpreted_options
;
+
+
i
)
{
src_path
.
push_back
(
i
)
;
uninterpreted_option_
=
down_cast
<
const
UninterpretedOption
*
>
(
&
original_options
-
>
GetReflection
(
)
-
>
GetRepeatedMessage
(
*
original_options
original_uninterpreted_options_field
i
)
)
;
if
(
!
InterpretSingleOption
(
options
src_path
options_to_interpret
-
>
element_path
)
)
{
failed
=
true
;
break
;
}
src_path
.
pop_back
(
)
;
}
uninterpreted_option_
=
nullptr
;
options_to_interpret_
=
nullptr
;
if
(
!
failed
)
{
std
:
:
unique_ptr
<
Message
>
unparsed_options
(
options
-
>
New
(
)
)
;
options
-
>
GetReflection
(
)
-
>
Swap
(
unparsed_options
.
get
(
)
options
)
;
std
:
:
string
buf
;
if
(
!
unparsed_options
-
>
AppendToString
(
&
buf
)
|
|
!
options
-
>
ParseFromString
(
buf
)
)
{
builder_
-
>
AddError
(
options_to_interpret
-
>
element_name
*
original_options
DescriptorPool
:
:
ErrorCollector
:
:
OTHER
"
Some
options
could
not
be
correctly
parsed
using
the
proto
"
"
descriptors
compiled
into
this
binary
.
\
n
"
"
Unparsed
options
:
"
+
unparsed_options
-
>
ShortDebugString
(
)
+
"
\
n
"
"
Parsing
attempt
:
"
+
options
-
>
ShortDebugString
(
)
)
;
options
-
>
GetReflection
(
)
-
>
Swap
(
unparsed_options
.
get
(
)
options
)
;
}
}
return
!
failed
;
}
bool
DescriptorBuilder
:
:
OptionInterpreter
:
:
InterpretSingleOption
(
Message
*
options
const
std
:
:
vector
<
int
>
&
src_path
const
std
:
:
vector
<
int
>
&
options_path
)
{
if
(
uninterpreted_option_
-
>
name_size
(
)
=
=
0
)
{
return
AddNameError
(
"
Option
must
have
a
name
.
"
)
;
}
if
(
uninterpreted_option_
-
>
name
(
0
)
.
name_part
(
)
=
=
"
uninterpreted_option
"
)
{
return
AddNameError
(
"
Option
must
not
use
reserved
name
"
"
\
"
uninterpreted_option
\
"
.
"
)
;
}
const
Descriptor
*
options_descriptor
=
nullptr
;
Symbol
symbol
=
builder_
-
>
FindSymbolNotEnforcingDeps
(
options
-
>
GetDescriptor
(
)
-
>
full_name
(
)
)
;
options_descriptor
=
symbol
.
descriptor
(
)
;
if
(
options_descriptor
=
=
nullptr
)
{
options_descriptor
=
options
-
>
GetDescriptor
(
)
;
}
GOOGLE_CHECK
(
options_descriptor
)
;
const
Descriptor
*
descriptor
=
options_descriptor
;
const
FieldDescriptor
*
field
=
nullptr
;
std
:
:
vector
<
const
FieldDescriptor
*
>
intermediate_fields
;
std
:
:
string
debug_msg_name
=
"
"
;
std
:
:
vector
<
int
>
dest_path
=
options_path
;
for
(
int
i
=
0
;
i
<
uninterpreted_option_
-
>
name_size
(
)
;
+
+
i
)
{
builder_
-
>
undefine_resolved_name_
.
clear
(
)
;
const
std
:
:
string
&
name_part
=
uninterpreted_option_
-
>
name
(
i
)
.
name_part
(
)
;
if
(
debug_msg_name
.
size
(
)
>
0
)
{
debug_msg_name
+
=
"
.
"
;
}
if
(
uninterpreted_option_
-
>
name
(
i
)
.
is_extension
(
)
)
{
debug_msg_name
+
=
"
(
"
+
name_part
+
"
)
"
;
symbol
=
builder_
-
>
LookupSymbol
(
name_part
options_to_interpret_
-
>
name_scope
)
;
field
=
symbol
.
field_descriptor
(
)
;
}
else
{
debug_msg_name
+
=
name_part
;
field
=
descriptor
-
>
FindFieldByName
(
name_part
)
;
}
if
(
field
=
=
nullptr
)
{
if
(
get_allow_unknown
(
builder_
-
>
pool_
)
)
{
AddWithoutInterpreting
(
*
uninterpreted_option_
options
)
;
return
true
;
}
else
if
(
!
(
builder_
-
>
undefine_resolved_name_
)
.
empty
(
)
)
{
return
AddNameError
(
"
Option
\
"
"
+
debug_msg_name
+
"
\
"
is
resolved
to
\
"
(
"
+
builder_
-
>
undefine_resolved_name_
+
"
)
\
"
which
is
not
defined
.
The
innermost
scope
is
searched
first
"
"
in
name
resolution
.
Consider
using
a
leading
'
.
'
(
i
.
e
.
\
"
(
.
"
+
debug_msg_name
.
substr
(
1
)
+
"
\
"
)
to
start
from
the
outermost
scope
.
"
)
;
}
else
{
return
AddNameError
(
"
Option
\
"
"
+
debug_msg_name
+
"
\
"
unknown
.
Ensure
that
your
proto
"
+
"
definition
file
imports
the
proto
which
defines
the
option
.
"
)
;
}
}
else
if
(
field
-
>
containing_type
(
)
!
=
descriptor
)
{
if
(
get_is_placeholder
(
field
-
>
containing_type
(
)
)
)
{
AddWithoutInterpreting
(
*
uninterpreted_option_
options
)
;
return
true
;
}
else
{
return
AddNameError
(
"
Option
field
\
"
"
+
debug_msg_name
+
"
\
"
is
not
a
field
or
extension
of
message
\
"
"
+
descriptor
-
>
name
(
)
+
"
\
"
.
"
)
;
}
}
else
{
dest_path
.
push_back
(
field
-
>
number
(
)
)
;
if
(
i
<
uninterpreted_option_
-
>
name_size
(
)
-
1
)
{
if
(
field
-
>
cpp_type
(
)
!
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
return
AddNameError
(
"
Option
\
"
"
+
debug_msg_name
+
"
\
"
is
an
atomic
type
not
a
message
.
"
)
;
}
else
if
(
field
-
>
is_repeated
(
)
)
{
return
AddNameError
(
"
Option
field
\
"
"
+
debug_msg_name
+
"
\
"
is
a
repeated
message
.
Repeated
message
"
"
options
must
be
initialized
using
an
"
"
aggregate
value
.
"
)
;
}
else
{
intermediate_fields
.
push_back
(
field
)
;
descriptor
=
field
-
>
message_type
(
)
;
}
}
}
}
if
(
!
field
-
>
is_repeated
(
)
&
&
!
ExamineIfOptionIsSet
(
intermediate_fields
.
begin
(
)
intermediate_fields
.
end
(
)
field
debug_msg_name
options
-
>
GetReflection
(
)
-
>
GetUnknownFields
(
*
options
)
)
)
{
return
false
;
}
std
:
:
unique_ptr
<
UnknownFieldSet
>
unknown_fields
(
new
UnknownFieldSet
(
)
)
;
if
(
!
SetOptionValue
(
field
unknown_fields
.
get
(
)
)
)
{
return
false
;
}
for
(
std
:
:
vector
<
const
FieldDescriptor
*
>
:
:
reverse_iterator
iter
=
intermediate_fields
.
rbegin
(
)
;
iter
!
=
intermediate_fields
.
rend
(
)
;
+
+
iter
)
{
std
:
:
unique_ptr
<
UnknownFieldSet
>
parent_unknown_fields
(
new
UnknownFieldSet
(
)
)
;
switch
(
(
*
iter
)
-
>
type
(
)
)
{
case
FieldDescriptor
:
:
TYPE_MESSAGE
:
{
std
:
:
string
*
outstr
=
parent_unknown_fields
-
>
AddLengthDelimited
(
(
*
iter
)
-
>
number
(
)
)
;
GOOGLE_CHECK
(
unknown_fields
-
>
SerializeToString
(
outstr
)
)
<
<
"
Unexpected
failure
while
serializing
option
submessage
"
<
<
debug_msg_name
<
<
"
\
"
.
"
;
break
;
}
case
FieldDescriptor
:
:
TYPE_GROUP
:
{
parent_unknown_fields
-
>
AddGroup
(
(
*
iter
)
-
>
number
(
)
)
-
>
MergeFrom
(
*
unknown_fields
)
;
break
;
}
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
Invalid
wire
type
for
CPPTYPE_MESSAGE
:
"
<
<
(
*
iter
)
-
>
type
(
)
;
return
false
;
}
unknown_fields
.
reset
(
parent_unknown_fields
.
release
(
)
)
;
}
options
-
>
GetReflection
(
)
-
>
MutableUnknownFields
(
options
)
-
>
MergeFrom
(
*
unknown_fields
)
;
if
(
field
-
>
is_repeated
(
)
)
{
int
index
=
repeated_option_counts_
[
dest_path
]
+
+
;
dest_path
.
push_back
(
index
)
;
}
interpreted_paths_
[
src_path
]
=
dest_path
;
return
true
;
}
void
DescriptorBuilder
:
:
OptionInterpreter
:
:
UpdateSourceCodeInfo
(
SourceCodeInfo
*
info
)
{
if
(
interpreted_paths_
.
empty
(
)
)
{
return
;
}
RepeatedPtrField
<
SourceCodeInfo_Location
>
*
locs
=
info
-
>
mutable_location
(
)
;
RepeatedPtrField
<
SourceCodeInfo_Location
>
new_locs
;
bool
copying
=
false
;
std
:
:
vector
<
int
>
pathv
;
bool
matched
=
false
;
for
(
RepeatedPtrField
<
SourceCodeInfo_Location
>
:
:
iterator
loc
=
locs
-
>
begin
(
)
;
loc
!
=
locs
-
>
end
(
)
;
loc
+
+
)
{
if
(
matched
)
{
bool
loc_matches
=
true
;
if
(
loc
-
>
path_size
(
)
<
static_cast
<
int64_t
>
(
pathv
.
size
(
)
)
)
{
loc_matches
=
false
;
}
else
{
for
(
size_t
j
=
0
;
j
<
pathv
.
size
(
)
;
j
+
+
)
{
if
(
loc
-
>
path
(
j
)
!
=
pathv
[
j
]
)
{
loc_matches
=
false
;
break
;
}
}
}
if
(
loc_matches
)
{
continue
;
}
matched
=
false
;
}
pathv
.
clear
(
)
;
for
(
int
j
=
0
;
j
<
loc
-
>
path_size
(
)
;
j
+
+
)
{
pathv
.
push_back
(
loc
-
>
path
(
j
)
)
;
}
std
:
:
map
<
std
:
:
vector
<
int
>
std
:
:
vector
<
int
>
>
:
:
iterator
entry
=
interpreted_paths_
.
find
(
pathv
)
;
if
(
entry
=
=
interpreted_paths_
.
end
(
)
)
{
if
(
copying
)
{
*
new_locs
.
Add
(
)
=
*
loc
;
}
continue
;
}
matched
=
true
;
if
(
!
copying
)
{
copying
=
true
;
new_locs
.
Reserve
(
locs
-
>
size
(
)
)
;
for
(
RepeatedPtrField
<
SourceCodeInfo_Location
>
:
:
iterator
it
=
locs
-
>
begin
(
)
;
it
!
=
loc
;
it
+
+
)
{
*
new_locs
.
Add
(
)
=
*
it
;
}
}
SourceCodeInfo_Location
*
replacement
=
new_locs
.
Add
(
)
;
*
replacement
=
*
loc
;
replacement
-
>
clear_path
(
)
;
for
(
std
:
:
vector
<
int
>
:
:
iterator
rit
=
entry
-
>
second
.
begin
(
)
;
rit
!
=
entry
-
>
second
.
end
(
)
;
rit
+
+
)
{
replacement
-
>
add_path
(
*
rit
)
;
}
}
if
(
copying
)
{
*
locs
=
new_locs
;
}
}
void
DescriptorBuilder
:
:
OptionInterpreter
:
:
AddWithoutInterpreting
(
const
UninterpretedOption
&
uninterpreted_option
Message
*
options
)
{
const
FieldDescriptor
*
field
=
options
-
>
GetDescriptor
(
)
-
>
FindFieldByName
(
"
uninterpreted_option
"
)
;
GOOGLE_CHECK
(
field
!
=
nullptr
)
;
options
-
>
GetReflection
(
)
-
>
AddMessage
(
options
field
)
-
>
CopyFrom
(
uninterpreted_option
)
;
}
bool
DescriptorBuilder
:
:
OptionInterpreter
:
:
ExamineIfOptionIsSet
(
std
:
:
vector
<
const
FieldDescriptor
*
>
:
:
const_iterator
intermediate_fields_iter
std
:
:
vector
<
const
FieldDescriptor
*
>
:
:
const_iterator
intermediate_fields_end
const
FieldDescriptor
*
innermost_field
const
std
:
:
string
&
debug_msg_name
const
UnknownFieldSet
&
unknown_fields
)
{
if
(
intermediate_fields_iter
=
=
intermediate_fields_end
)
{
for
(
int
i
=
0
;
i
<
unknown_fields
.
field_count
(
)
;
i
+
+
)
{
if
(
unknown_fields
.
field
(
i
)
.
number
(
)
=
=
innermost_field
-
>
number
(
)
)
{
return
AddNameError
(
"
Option
\
"
"
+
debug_msg_name
+
"
\
"
was
already
set
.
"
)
;
}
}
return
true
;
}
for
(
int
i
=
0
;
i
<
unknown_fields
.
field_count
(
)
;
i
+
+
)
{
if
(
unknown_fields
.
field
(
i
)
.
number
(
)
=
=
(
*
intermediate_fields_iter
)
-
>
number
(
)
)
{
const
UnknownField
*
unknown_field
=
&
unknown_fields
.
field
(
i
)
;
FieldDescriptor
:
:
Type
type
=
(
*
intermediate_fields_iter
)
-
>
type
(
)
;
switch
(
type
)
{
case
FieldDescriptor
:
:
TYPE_MESSAGE
:
if
(
unknown_field
-
>
type
(
)
=
=
UnknownField
:
:
TYPE_LENGTH_DELIMITED
)
{
UnknownFieldSet
intermediate_unknown_fields
;
if
(
intermediate_unknown_fields
.
ParseFromString
(
unknown_field
-
>
length_delimited
(
)
)
&
&
!
ExamineIfOptionIsSet
(
intermediate_fields_iter
+
1
intermediate_fields_end
innermost_field
debug_msg_name
intermediate_unknown_fields
)
)
{
return
false
;
}
}
break
;
case
FieldDescriptor
:
:
TYPE_GROUP
:
if
(
unknown_field
-
>
type
(
)
=
=
UnknownField
:
:
TYPE_GROUP
)
{
if
(
!
ExamineIfOptionIsSet
(
intermediate_fields_iter
+
1
intermediate_fields_end
innermost_field
debug_msg_name
unknown_field
-
>
group
(
)
)
)
{
return
false
;
}
}
break
;
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
Invalid
wire
type
for
CPPTYPE_MESSAGE
:
"
<
<
type
;
return
false
;
}
}
}
return
true
;
}
bool
DescriptorBuilder
:
:
OptionInterpreter
:
:
SetOptionValue
(
const
FieldDescriptor
*
option_field
UnknownFieldSet
*
unknown_fields
)
{
switch
(
option_field
-
>
cpp_type
(
)
)
{
case
FieldDescriptor
:
:
CPPTYPE_INT32
:
if
(
uninterpreted_option_
-
>
has_positive_int_value
(
)
)
{
if
(
uninterpreted_option_
-
>
positive_int_value
(
)
>
static_cast
<
uint64_t
>
(
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
)
{
return
AddValueError
(
"
Value
out
of
range
for
int32
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
else
{
SetInt32
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
positive_int_value
(
)
option_field
-
>
type
(
)
unknown_fields
)
;
}
}
else
if
(
uninterpreted_option_
-
>
has_negative_int_value
(
)
)
{
if
(
uninterpreted_option_
-
>
negative_int_value
(
)
<
static_cast
<
int64_t
>
(
std
:
:
numeric_limits
<
int32_t
>
:
:
min
(
)
)
)
{
return
AddValueError
(
"
Value
out
of
range
for
int32
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
else
{
SetInt32
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
negative_int_value
(
)
option_field
-
>
type
(
)
unknown_fields
)
;
}
}
else
{
return
AddValueError
(
"
Value
must
be
integer
for
int32
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_INT64
:
if
(
uninterpreted_option_
-
>
has_positive_int_value
(
)
)
{
if
(
uninterpreted_option_
-
>
positive_int_value
(
)
>
static_cast
<
uint64_t
>
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
)
)
{
return
AddValueError
(
"
Value
out
of
range
for
int64
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
else
{
SetInt64
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
positive_int_value
(
)
option_field
-
>
type
(
)
unknown_fields
)
;
}
}
else
if
(
uninterpreted_option_
-
>
has_negative_int_value
(
)
)
{
SetInt64
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
negative_int_value
(
)
option_field
-
>
type
(
)
unknown_fields
)
;
}
else
{
return
AddValueError
(
"
Value
must
be
integer
for
int64
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_UINT32
:
if
(
uninterpreted_option_
-
>
has_positive_int_value
(
)
)
{
if
(
uninterpreted_option_
-
>
positive_int_value
(
)
>
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
{
return
AddValueError
(
"
Value
out
of
range
for
uint32
option
\
"
"
+
option_field
-
>
name
(
)
+
"
\
"
.
"
)
;
}
else
{
SetUInt32
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
positive_int_value
(
)
option_field
-
>
type
(
)
unknown_fields
)
;
}
}
else
{
return
AddValueError
(
"
Value
must
be
non
-
negative
integer
for
uint32
"
"
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_UINT64
:
if
(
uninterpreted_option_
-
>
has_positive_int_value
(
)
)
{
SetUInt64
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
positive_int_value
(
)
option_field
-
>
type
(
)
unknown_fields
)
;
}
else
{
return
AddValueError
(
"
Value
must
be
non
-
negative
integer
for
uint64
"
"
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_FLOAT
:
{
float
value
;
if
(
uninterpreted_option_
-
>
has_double_value
(
)
)
{
value
=
uninterpreted_option_
-
>
double_value
(
)
;
}
else
if
(
uninterpreted_option_
-
>
has_positive_int_value
(
)
)
{
value
=
uninterpreted_option_
-
>
positive_int_value
(
)
;
}
else
if
(
uninterpreted_option_
-
>
has_negative_int_value
(
)
)
{
value
=
uninterpreted_option_
-
>
negative_int_value
(
)
;
}
else
{
return
AddValueError
(
"
Value
must
be
number
for
float
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
unknown_fields
-
>
AddFixed32
(
option_field
-
>
number
(
)
internal
:
:
WireFormatLite
:
:
EncodeFloat
(
value
)
)
;
break
;
}
case
FieldDescriptor
:
:
CPPTYPE_DOUBLE
:
{
double
value
;
if
(
uninterpreted_option_
-
>
has_double_value
(
)
)
{
value
=
uninterpreted_option_
-
>
double_value
(
)
;
}
else
if
(
uninterpreted_option_
-
>
has_positive_int_value
(
)
)
{
value
=
uninterpreted_option_
-
>
positive_int_value
(
)
;
}
else
if
(
uninterpreted_option_
-
>
has_negative_int_value
(
)
)
{
value
=
uninterpreted_option_
-
>
negative_int_value
(
)
;
}
else
{
return
AddValueError
(
"
Value
must
be
number
for
double
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
unknown_fields
-
>
AddFixed64
(
option_field
-
>
number
(
)
internal
:
:
WireFormatLite
:
:
EncodeDouble
(
value
)
)
;
break
;
}
case
FieldDescriptor
:
:
CPPTYPE_BOOL
:
uint64_t
value
;
if
(
!
uninterpreted_option_
-
>
has_identifier_value
(
)
)
{
return
AddValueError
(
"
Value
must
be
identifier
for
boolean
option
"
"
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
if
(
uninterpreted_option_
-
>
identifier_value
(
)
=
=
"
true
"
)
{
value
=
1
;
}
else
if
(
uninterpreted_option_
-
>
identifier_value
(
)
=
=
"
false
"
)
{
value
=
0
;
}
else
{
return
AddValueError
(
"
Value
must
be
\
"
true
\
"
or
\
"
false
\
"
for
boolean
"
"
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
unknown_fields
-
>
AddVarint
(
option_field
-
>
number
(
)
value
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_ENUM
:
{
if
(
!
uninterpreted_option_
-
>
has_identifier_value
(
)
)
{
return
AddValueError
(
"
Value
must
be
identifier
for
enum
-
valued
option
"
"
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
const
EnumDescriptor
*
enum_type
=
option_field
-
>
enum_type
(
)
;
const
std
:
:
string
&
value_name
=
uninterpreted_option_
-
>
identifier_value
(
)
;
const
EnumValueDescriptor
*
enum_value
=
nullptr
;
if
(
enum_type
-
>
file
(
)
-
>
pool
(
)
!
=
DescriptorPool
:
:
generated_pool
(
)
)
{
std
:
:
string
fully_qualified_name
=
enum_type
-
>
full_name
(
)
;
fully_qualified_name
.
resize
(
fully_qualified_name
.
size
(
)
-
enum_type
-
>
name
(
)
.
size
(
)
)
;
fully_qualified_name
+
=
value_name
;
Symbol
symbol
=
builder_
-
>
FindSymbolNotEnforcingDeps
(
fully_qualified_name
)
;
if
(
auto
*
candicate_descriptor
=
symbol
.
enum_value_descriptor
(
)
)
{
if
(
candicate_descriptor
-
>
type
(
)
!
=
enum_type
)
{
return
AddValueError
(
"
Enum
type
\
"
"
+
enum_type
-
>
full_name
(
)
+
"
\
"
has
no
value
named
\
"
"
+
value_name
+
"
\
"
for
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
This
appears
to
be
a
value
from
a
sibling
type
.
"
)
;
}
else
{
enum_value
=
candicate_descriptor
;
}
}
}
else
{
enum_value
=
enum_type
-
>
FindValueByName
(
value_name
)
;
}
if
(
enum_value
=
=
nullptr
)
{
return
AddValueError
(
"
Enum
type
\
"
"
+
option_field
-
>
enum_type
(
)
-
>
full_name
(
)
+
"
\
"
has
no
value
named
\
"
"
+
value_name
+
"
\
"
for
"
"
option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
else
{
unknown_fields
-
>
AddVarint
(
option_field
-
>
number
(
)
static_cast
<
uint64_t
>
(
static_cast
<
int64_t
>
(
enum_value
-
>
number
(
)
)
)
)
;
}
break
;
}
case
FieldDescriptor
:
:
CPPTYPE_STRING
:
if
(
!
uninterpreted_option_
-
>
has_string_value
(
)
)
{
return
AddValueError
(
"
Value
must
be
quoted
string
for
string
option
"
"
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
.
"
)
;
}
unknown_fields
-
>
AddLengthDelimited
(
option_field
-
>
number
(
)
uninterpreted_option_
-
>
string_value
(
)
)
;
break
;
case
FieldDescriptor
:
:
CPPTYPE_MESSAGE
:
if
(
!
SetAggregateOption
(
option_field
unknown_fields
)
)
{
return
false
;
}
break
;
}
return
true
;
}
class
DescriptorBuilder
:
:
OptionInterpreter
:
:
AggregateOptionFinder
:
public
TextFormat
:
:
Finder
{
public
:
DescriptorBuilder
*
builder_
;
const
Descriptor
*
FindAnyType
(
const
Message
&
const
std
:
:
string
&
prefix
const
std
:
:
string
&
name
)
const
override
{
if
(
prefix
!
=
internal
:
:
kTypeGoogleApisComPrefix
&
&
prefix
!
=
internal
:
:
kTypeGoogleProdComPrefix
)
{
return
nullptr
;
}
assert_mutex_held
(
builder_
-
>
pool_
)
;
return
builder_
-
>
FindSymbol
(
name
)
.
descriptor
(
)
;
}
const
FieldDescriptor
*
FindExtension
(
Message
*
message
const
std
:
:
string
&
name
)
const
override
{
assert_mutex_held
(
builder_
-
>
pool_
)
;
const
Descriptor
*
descriptor
=
message
-
>
GetDescriptor
(
)
;
Symbol
result
=
builder_
-
>
LookupSymbolNoPlaceholder
(
name
descriptor
-
>
full_name
(
)
)
;
if
(
auto
*
field
=
result
.
field_descriptor
(
)
)
{
return
field
;
}
else
if
(
result
.
type
(
)
=
=
Symbol
:
:
MESSAGE
&
&
descriptor
-
>
options
(
)
.
message_set_wire_format
(
)
)
{
const
Descriptor
*
foreign_type
=
result
.
descriptor
(
)
;
for
(
int
i
=
0
;
i
<
foreign_type
-
>
extension_count
(
)
;
i
+
+
)
{
const
FieldDescriptor
*
extension
=
foreign_type
-
>
extension
(
i
)
;
if
(
extension
-
>
containing_type
(
)
=
=
descriptor
&
&
extension
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_MESSAGE
&
&
extension
-
>
is_optional
(
)
&
&
extension
-
>
message_type
(
)
=
=
foreign_type
)
{
return
extension
;
}
}
}
return
nullptr
;
}
}
;
namespace
{
class
AggregateErrorCollector
:
public
io
:
:
ErrorCollector
{
public
:
std
:
:
string
error_
;
void
AddError
(
int
int
const
std
:
:
string
&
message
)
override
{
if
(
!
error_
.
empty
(
)
)
{
error_
+
=
"
;
"
;
}
error_
+
=
message
;
}
void
AddWarning
(
int
int
const
std
:
:
string
&
)
override
{
}
}
;
}
bool
DescriptorBuilder
:
:
OptionInterpreter
:
:
SetAggregateOption
(
const
FieldDescriptor
*
option_field
UnknownFieldSet
*
unknown_fields
)
{
if
(
!
uninterpreted_option_
-
>
has_aggregate_value
(
)
)
{
return
AddValueError
(
"
Option
\
"
"
+
option_field
-
>
full_name
(
)
+
"
\
"
is
a
message
.
To
set
the
entire
message
use
"
"
syntax
like
\
"
"
+
option_field
-
>
name
(
)
+
"
=
{
<
proto
text
format
>
}
\
"
.
"
"
To
set
fields
within
it
use
"
"
syntax
like
\
"
"
+
option_field
-
>
name
(
)
+
"
.
foo
=
value
\
"
.
"
)
;
}
const
Descriptor
*
type
=
option_field
-
>
message_type
(
)
;
std
:
:
unique_ptr
<
Message
>
dynamic
(
dynamic_factory_
.
GetPrototype
(
type
)
-
>
New
(
)
)
;
GOOGLE_CHECK
(
dynamic
.
get
(
)
!
=
nullptr
)
<
<
"
Could
not
create
an
instance
of
"
<
<
option_field
-
>
DebugString
(
)
;
AggregateErrorCollector
collector
;
AggregateOptionFinder
finder
;
finder
.
builder_
=
builder_
;
TextFormat
:
:
Parser
parser
;
parser
.
RecordErrorsTo
(
&
collector
)
;
parser
.
SetFinder
(
&
finder
)
;
if
(
!
parser
.
ParseFromString
(
uninterpreted_option_
-
>
aggregate_value
(
)
dynamic
.
get
(
)
)
)
{
AddValueError
(
"
Error
while
parsing
option
value
for
\
"
"
+
option_field
-
>
name
(
)
+
"
\
"
:
"
+
collector
.
error_
)
;
return
false
;
}
else
{
std
:
:
string
serial
;
dynamic
-
>
SerializeToString
(
&
serial
)
;
if
(
option_field
-
>
type
(
)
=
=
FieldDescriptor
:
:
TYPE_MESSAGE
)
{
unknown_fields
-
>
AddLengthDelimited
(
option_field
-
>
number
(
)
serial
)
;
}
else
{
GOOGLE_CHECK_EQ
(
option_field
-
>
type
(
)
FieldDescriptor
:
:
TYPE_GROUP
)
;
UnknownFieldSet
*
group
=
unknown_fields
-
>
AddGroup
(
option_field
-
>
number
(
)
)
;
group
-
>
ParseFromString
(
serial
)
;
}
return
true
;
}
}
void
DescriptorBuilder
:
:
OptionInterpreter
:
:
SetInt32
(
int
number
int32_t
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
{
switch
(
type
)
{
case
FieldDescriptor
:
:
TYPE_INT32
:
unknown_fields
-
>
AddVarint
(
number
static_cast
<
uint64_t
>
(
static_cast
<
int64_t
>
(
value
)
)
)
;
break
;
case
FieldDescriptor
:
:
TYPE_SFIXED32
:
unknown_fields
-
>
AddFixed32
(
number
static_cast
<
uint32_t
>
(
value
)
)
;
break
;
case
FieldDescriptor
:
:
TYPE_SINT32
:
unknown_fields
-
>
AddVarint
(
number
internal
:
:
WireFormatLite
:
:
ZigZagEncode32
(
value
)
)
;
break
;
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
Invalid
wire
type
for
CPPTYPE_INT32
:
"
<
<
type
;
break
;
}
}
void
DescriptorBuilder
:
:
OptionInterpreter
:
:
SetInt64
(
int
number
int64_t
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
{
switch
(
type
)
{
case
FieldDescriptor
:
:
TYPE_INT64
:
unknown_fields
-
>
AddVarint
(
number
static_cast
<
uint64_t
>
(
value
)
)
;
break
;
case
FieldDescriptor
:
:
TYPE_SFIXED64
:
unknown_fields
-
>
AddFixed64
(
number
static_cast
<
uint64_t
>
(
value
)
)
;
break
;
case
FieldDescriptor
:
:
TYPE_SINT64
:
unknown_fields
-
>
AddVarint
(
number
internal
:
:
WireFormatLite
:
:
ZigZagEncode64
(
value
)
)
;
break
;
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
Invalid
wire
type
for
CPPTYPE_INT64
:
"
<
<
type
;
break
;
}
}
void
DescriptorBuilder
:
:
OptionInterpreter
:
:
SetUInt32
(
int
number
uint32_t
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
{
switch
(
type
)
{
case
FieldDescriptor
:
:
TYPE_UINT32
:
unknown_fields
-
>
AddVarint
(
number
static_cast
<
uint64_t
>
(
value
)
)
;
break
;
case
FieldDescriptor
:
:
TYPE_FIXED32
:
unknown_fields
-
>
AddFixed32
(
number
static_cast
<
uint32_t
>
(
value
)
)
;
break
;
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
Invalid
wire
type
for
CPPTYPE_UINT32
:
"
<
<
type
;
break
;
}
}
void
DescriptorBuilder
:
:
OptionInterpreter
:
:
SetUInt64
(
int
number
uint64_t
value
FieldDescriptor
:
:
Type
type
UnknownFieldSet
*
unknown_fields
)
{
switch
(
type
)
{
case
FieldDescriptor
:
:
TYPE_UINT64
:
unknown_fields
-
>
AddVarint
(
number
value
)
;
break
;
case
FieldDescriptor
:
:
TYPE_FIXED64
:
unknown_fields
-
>
AddFixed64
(
number
value
)
;
break
;
default
:
GOOGLE_LOG
(
FATAL
)
<
<
"
Invalid
wire
type
for
CPPTYPE_UINT64
:
"
<
<
type
;
break
;
}
}
void
DescriptorBuilder
:
:
LogUnusedDependency
(
const
FileDescriptorProto
&
proto
const
FileDescriptor
*
result
)
{
(
void
)
result
;
if
(
!
unused_dependency_
.
empty
(
)
)
{
auto
itr
=
pool_
-
>
unused_import_track_files_
.
find
(
proto
.
name
(
)
)
;
bool
is_error
=
itr
!
=
pool_
-
>
unused_import_track_files_
.
end
(
)
&
&
itr
-
>
second
;
for
(
std
:
:
set
<
const
FileDescriptor
*
>
:
:
const_iterator
it
=
unused_dependency_
.
begin
(
)
;
it
!
=
unused_dependency_
.
end
(
)
;
+
+
it
)
{
std
:
:
string
error_message
=
"
Import
"
+
(
*
it
)
-
>
name
(
)
+
"
is
unused
.
"
;
if
(
is_error
)
{
AddError
(
(
*
it
)
-
>
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
IMPORT
error_message
)
;
}
else
{
AddWarning
(
(
*
it
)
-
>
name
(
)
proto
DescriptorPool
:
:
ErrorCollector
:
:
IMPORT
error_message
)
;
}
}
}
}
Symbol
DescriptorPool
:
:
CrossLinkOnDemandHelper
(
StringPiece
name
bool
expecting_enum
)
const
{
(
void
)
expecting_enum
;
auto
lookup_name
=
std
:
:
string
(
name
)
;
if
(
!
lookup_name
.
empty
(
)
&
&
lookup_name
[
0
]
=
=
'
.
'
)
{
lookup_name
=
lookup_name
.
substr
(
1
)
;
}
Symbol
result
=
tables_
-
>
FindByNameHelper
(
this
lookup_name
)
;
return
result
;
}
void
FieldDescriptor
:
:
InternalTypeOnceInit
(
)
const
{
GOOGLE_CHECK
(
file
(
)
-
>
finished_building_
=
=
true
)
;
const
EnumDescriptor
*
enum_type
=
nullptr
;
const
char
*
lazy_type_name
=
reinterpret_cast
<
const
char
*
>
(
type_once_
+
1
)
;
const
char
*
lazy_default_value_enum_name
=
lazy_type_name
+
strlen
(
lazy_type_name
)
+
1
;
Symbol
result
=
file
(
)
-
>
pool
(
)
-
>
CrossLinkOnDemandHelper
(
lazy_type_name
type_
=
=
FieldDescriptor
:
:
TYPE_ENUM
)
;
if
(
result
.
type
(
)
=
=
Symbol
:
:
MESSAGE
)
{
type_
=
FieldDescriptor
:
:
TYPE_MESSAGE
;
type_descriptor_
.
message_type
=
result
.
descriptor
(
)
;
}
else
if
(
result
.
type
(
)
=
=
Symbol
:
:
ENUM
)
{
type_
=
FieldDescriptor
:
:
TYPE_ENUM
;
enum_type
=
type_descriptor_
.
enum_type
=
result
.
enum_descriptor
(
)
;
}
if
(
enum_type
)
{
if
(
lazy_default_value_enum_name
[
0
]
!
=
'
\
0
'
)
{
std
:
:
string
name
=
enum_type
-
>
full_name
(
)
;
std
:
:
string
:
:
size_type
last_dot
=
name
.
find_last_of
(
'
.
'
)
;
if
(
last_dot
!
=
std
:
:
string
:
:
npos
)
{
name
=
name
.
substr
(
0
last_dot
)
+
"
.
"
+
lazy_default_value_enum_name
;
}
else
{
name
=
lazy_default_value_enum_name
;
}
Symbol
result
=
file
(
)
-
>
pool
(
)
-
>
CrossLinkOnDemandHelper
(
name
true
)
;
default_value_enum_
=
result
.
enum_value_descriptor
(
)
;
}
else
{
default_value_enum_
=
nullptr
;
}
if
(
!
default_value_enum_
)
{
GOOGLE_CHECK
(
enum_type
-
>
value_count
(
)
)
;
default_value_enum_
=
enum_type
-
>
value
(
0
)
;
}
}
}
void
FieldDescriptor
:
:
TypeOnceInit
(
const
FieldDescriptor
*
to_init
)
{
to_init
-
>
InternalTypeOnceInit
(
)
;
}
const
Descriptor
*
FieldDescriptor
:
:
message_type
(
)
const
{
if
(
type_once_
)
{
internal
:
:
call_once
(
*
type_once_
FieldDescriptor
:
:
TypeOnceInit
this
)
;
}
return
type_
=
=
TYPE_MESSAGE
|
|
type_
=
=
TYPE_GROUP
?
type_descriptor_
.
message_type
:
nullptr
;
}
const
EnumDescriptor
*
FieldDescriptor
:
:
enum_type
(
)
const
{
if
(
type_once_
)
{
internal
:
:
call_once
(
*
type_once_
FieldDescriptor
:
:
TypeOnceInit
this
)
;
}
return
type_
=
=
TYPE_ENUM
?
type_descriptor_
.
enum_type
:
nullptr
;
}
const
EnumValueDescriptor
*
FieldDescriptor
:
:
default_value_enum
(
)
const
{
if
(
type_once_
)
{
internal
:
:
call_once
(
*
type_once_
FieldDescriptor
:
:
TypeOnceInit
this
)
;
}
return
default_value_enum_
;
}
const
std
:
:
string
&
FieldDescriptor
:
:
PrintableNameForExtension
(
)
const
{
const
bool
is_message_set_extension
=
is_extension
(
)
&
&
containing_type
(
)
-
>
options
(
)
.
message_set_wire_format
(
)
&
&
type
(
)
=
=
FieldDescriptor
:
:
TYPE_MESSAGE
&
&
is_optional
(
)
&
&
extension_scope
(
)
=
=
message_type
(
)
;
return
is_message_set_extension
?
message_type
(
)
-
>
full_name
(
)
:
full_name
(
)
;
}
void
FileDescriptor
:
:
InternalDependenciesOnceInit
(
)
const
{
GOOGLE_CHECK
(
finished_building_
=
=
true
)
;
const
char
*
names_ptr
=
reinterpret_cast
<
const
char
*
>
(
dependencies_once_
+
1
)
;
for
(
int
i
=
0
;
i
<
dependency_count
(
)
;
i
+
+
)
{
const
char
*
name
=
names_ptr
;
names_ptr
+
=
strlen
(
name
)
+
1
;
if
(
name
[
0
]
!
=
'
\
0
'
)
{
dependencies_
[
i
]
=
pool_
-
>
FindFileByName
(
name
)
;
}
}
}
void
FileDescriptor
:
:
DependenciesOnceInit
(
const
FileDescriptor
*
to_init
)
{
to_init
-
>
InternalDependenciesOnceInit
(
)
;
}
const
FileDescriptor
*
FileDescriptor
:
:
dependency
(
int
index
)
const
{
if
(
dependencies_once_
)
{
internal
:
:
call_once
(
*
dependencies_once_
FileDescriptor
:
:
DependenciesOnceInit
this
)
;
}
return
dependencies_
[
index
]
;
}
const
Descriptor
*
MethodDescriptor
:
:
input_type
(
)
const
{
return
input_type_
.
Get
(
service
(
)
)
;
}
const
Descriptor
*
MethodDescriptor
:
:
output_type
(
)
const
{
return
output_type_
.
Get
(
service
(
)
)
;
}
namespace
internal
{
void
LazyDescriptor
:
:
Set
(
const
Descriptor
*
descriptor
)
{
GOOGLE_CHECK
(
!
once_
)
;
descriptor_
=
descriptor
;
}
void
LazyDescriptor
:
:
SetLazy
(
StringPiece
name
const
FileDescriptor
*
file
)
{
GOOGLE_CHECK
(
!
descriptor_
)
;
GOOGLE_CHECK
(
!
once_
)
;
GOOGLE_CHECK
(
file
&
&
file
-
>
pool_
)
;
GOOGLE_CHECK
(
file
-
>
pool_
-
>
lazily_build_dependencies_
)
;
GOOGLE_CHECK
(
!
file
-
>
finished_building_
)
;
once_
=
:
:
new
(
file
-
>
pool_
-
>
tables_
-
>
AllocateBytes
(
static_cast
<
int
>
(
sizeof
(
internal
:
:
once_flag
)
+
name
.
size
(
)
+
1
)
)
)
internal
:
:
once_flag
{
}
;
char
*
lazy_name
=
reinterpret_cast
<
char
*
>
(
once_
+
1
)
;
memcpy
(
lazy_name
name
.
data
(
)
name
.
size
(
)
)
;
lazy_name
[
name
.
size
(
)
]
=
0
;
}
void
LazyDescriptor
:
:
Once
(
const
ServiceDescriptor
*
service
)
{
if
(
once_
)
{
internal
:
:
call_once
(
*
once_
[
&
]
{
auto
*
file
=
service
-
>
file
(
)
;
GOOGLE_CHECK
(
file
-
>
finished_building_
)
;
const
char
*
lazy_name
=
reinterpret_cast
<
const
char
*
>
(
once_
+
1
)
;
descriptor_
=
file
-
>
pool_
-
>
CrossLinkOnDemandHelper
(
lazy_name
false
)
.
descriptor
(
)
;
}
)
;
}
}
}
}
}
#
include
<
google
/
protobuf
/
port_undef
.
inc
>
