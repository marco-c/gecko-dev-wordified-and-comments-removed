#
include
<
algorithm
>
#
include
<
google
/
protobuf
/
stubs
/
logging
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
common
.
h
>
#
include
<
google
/
protobuf
/
implicit_weak_message
.
h
>
#
include
<
google
/
protobuf
/
repeated_field
.
h
>
#
include
<
google
/
protobuf
/
port
.
h
>
#
include
<
google
/
protobuf
/
port_def
.
inc
>
namespace
google
{
namespace
protobuf
{
namespace
internal
{
void
*
*
RepeatedPtrFieldBase
:
:
InternalExtend
(
int
extend_amount
)
{
int
new_size
=
current_size_
+
extend_amount
;
if
(
total_size_
>
=
new_size
)
{
return
&
rep_
-
>
elements
[
current_size_
]
;
}
Rep
*
old_rep
=
rep_
;
Arena
*
arena
=
GetOwningArena
(
)
;
new_size
=
internal
:
:
CalculateReserveSize
<
void
*
kRepHeaderSize
>
(
total_size_
new_size
)
;
GOOGLE_CHECK_LE
(
static_cast
<
int64_t
>
(
new_size
)
static_cast
<
int64_t
>
(
(
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
-
kRepHeaderSize
)
/
sizeof
(
old_rep
-
>
elements
[
0
]
)
)
)
<
<
"
Requested
size
is
too
large
to
fit
into
size_t
.
"
;
size_t
bytes
=
kRepHeaderSize
+
sizeof
(
old_rep
-
>
elements
[
0
]
)
*
new_size
;
if
(
arena
=
=
nullptr
)
{
rep_
=
reinterpret_cast
<
Rep
*
>
(
:
:
operator
new
(
bytes
)
)
;
}
else
{
rep_
=
reinterpret_cast
<
Rep
*
>
(
Arena
:
:
CreateArray
<
char
>
(
arena
bytes
)
)
;
}
const
int
old_total_size
=
total_size_
;
total_size_
=
new_size
;
if
(
old_rep
)
{
if
(
old_rep
-
>
allocated_size
>
0
)
{
memcpy
(
rep_
-
>
elements
old_rep
-
>
elements
old_rep
-
>
allocated_size
*
sizeof
(
rep_
-
>
elements
[
0
]
)
)
;
}
rep_
-
>
allocated_size
=
old_rep
-
>
allocated_size
;
const
size_t
old_size
=
old_total_size
*
sizeof
(
rep_
-
>
elements
[
0
]
)
+
kRepHeaderSize
;
if
(
arena
=
=
nullptr
)
{
internal
:
:
SizedDelete
(
old_rep
old_size
)
;
}
else
{
arena_
-
>
ReturnArrayMemory
(
old_rep
old_size
)
;
}
}
else
{
rep_
-
>
allocated_size
=
0
;
}
return
&
rep_
-
>
elements
[
current_size_
]
;
}
void
RepeatedPtrFieldBase
:
:
Reserve
(
int
new_size
)
{
if
(
new_size
>
current_size_
)
{
InternalExtend
(
new_size
-
current_size_
)
;
}
}
void
RepeatedPtrFieldBase
:
:
DestroyProtos
(
)
{
GOOGLE_DCHECK
(
rep_
)
;
GOOGLE_DCHECK
(
arena_
=
=
nullptr
)
;
int
n
=
rep_
-
>
allocated_size
;
void
*
const
*
elements
=
rep_
-
>
elements
;
for
(
int
i
=
0
;
i
<
n
;
i
+
+
)
{
delete
static_cast
<
MessageLite
*
>
(
elements
[
i
]
)
;
}
const
size_t
size
=
total_size_
*
sizeof
(
elements
[
0
]
)
+
kRepHeaderSize
;
internal
:
:
SizedDelete
(
rep_
size
)
;
rep_
=
nullptr
;
}
void
*
RepeatedPtrFieldBase
:
:
AddOutOfLineHelper
(
void
*
obj
)
{
if
(
!
rep_
|
|
rep_
-
>
allocated_size
=
=
total_size_
)
{
InternalExtend
(
1
)
;
}
+
+
rep_
-
>
allocated_size
;
rep_
-
>
elements
[
current_size_
+
+
]
=
obj
;
return
obj
;
}
void
RepeatedPtrFieldBase
:
:
CloseGap
(
int
start
int
num
)
{
if
(
rep_
=
=
nullptr
)
return
;
for
(
int
i
=
start
+
num
;
i
<
rep_
-
>
allocated_size
;
+
+
i
)
rep_
-
>
elements
[
i
-
num
]
=
rep_
-
>
elements
[
i
]
;
current_size_
-
=
num
;
rep_
-
>
allocated_size
-
=
num
;
}
MessageLite
*
RepeatedPtrFieldBase
:
:
AddWeak
(
const
MessageLite
*
prototype
)
{
if
(
rep_
!
=
nullptr
&
&
current_size_
<
rep_
-
>
allocated_size
)
{
return
reinterpret_cast
<
MessageLite
*
>
(
rep_
-
>
elements
[
current_size_
+
+
]
)
;
}
if
(
!
rep_
|
|
rep_
-
>
allocated_size
=
=
total_size_
)
{
Reserve
(
total_size_
+
1
)
;
}
+
+
rep_
-
>
allocated_size
;
MessageLite
*
result
=
prototype
?
prototype
-
>
New
(
arena_
)
:
Arena
:
:
CreateMessage
<
ImplicitWeakMessage
>
(
arena_
)
;
rep_
-
>
elements
[
current_size_
+
+
]
=
result
;
return
result
;
}
}
}
}
#
include
<
google
/
protobuf
/
port_undef
.
inc
>
