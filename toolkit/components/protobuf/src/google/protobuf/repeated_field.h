#
ifndef
GOOGLE_PROTOBUF_REPEATED_FIELD_H__
#
define
GOOGLE_PROTOBUF_REPEATED_FIELD_H__
#
include
<
utility
>
#
ifdef
_MSC_VER
#
include
<
algorithm
>
#
endif
#
include
<
iterator
>
#
include
<
limits
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
google
/
protobuf
/
stubs
/
logging
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
common
.
h
>
#
include
<
google
/
protobuf
/
arena
.
h
>
#
include
<
google
/
protobuf
/
message_lite
.
h
>
#
include
<
google
/
protobuf
/
port
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
casts
.
h
>
#
include
<
type_traits
>
#
include
<
google
/
protobuf
/
port_def
.
inc
>
#
ifdef
SWIG
#
error
"
You
cannot
SWIG
proto
headers
"
#
endif
namespace
google
{
namespace
protobuf
{
class
Message
;
class
Reflection
;
template
<
typename
T
>
struct
WeakRepeatedPtrField
;
namespace
internal
{
class
MergePartialFromCodedStreamHelper
;
static
const
int
kMinRepeatedFieldAllocationSize
=
4
;
void
LogIndexOutOfBounds
(
int
index
int
size
)
;
template
<
typename
Iter
>
inline
int
CalculateReserve
(
Iter
begin
Iter
end
std
:
:
forward_iterator_tag
)
{
return
static_cast
<
int
>
(
std
:
:
distance
(
begin
end
)
)
;
}
template
<
typename
Iter
>
inline
int
CalculateReserve
(
Iter
Iter
std
:
:
input_iterator_tag
)
{
return
-
1
;
}
template
<
typename
Iter
>
inline
int
CalculateReserve
(
Iter
begin
Iter
end
)
{
typedef
typename
std
:
:
iterator_traits
<
Iter
>
:
:
iterator_category
Category
;
return
CalculateReserve
(
begin
end
Category
(
)
)
;
}
}
template
<
typename
Element
>
class
RepeatedField
final
{
static_assert
(
alignof
(
Arena
)
>
=
alignof
(
Element
)
"
We
only
support
types
that
have
an
alignment
smaller
than
Arena
"
)
;
public
:
RepeatedField
(
)
;
explicit
RepeatedField
(
Arena
*
arena
)
;
RepeatedField
(
const
RepeatedField
&
other
)
;
template
<
typename
Iter
>
RepeatedField
(
Iter
begin
const
Iter
&
end
)
;
~
RepeatedField
(
)
;
RepeatedField
&
operator
=
(
const
RepeatedField
&
other
)
;
RepeatedField
(
RepeatedField
&
&
other
)
noexcept
;
RepeatedField
&
operator
=
(
RepeatedField
&
&
other
)
noexcept
;
bool
empty
(
)
const
;
int
size
(
)
const
;
const
Element
&
Get
(
int
index
)
const
;
Element
*
Mutable
(
int
index
)
;
const
Element
&
operator
[
]
(
int
index
)
const
{
return
Get
(
index
)
;
}
Element
&
operator
[
]
(
int
index
)
{
return
*
Mutable
(
index
)
;
}
const
Element
&
at
(
int
index
)
const
;
Element
&
at
(
int
index
)
;
void
Set
(
int
index
const
Element
&
value
)
;
void
Add
(
const
Element
&
value
)
;
Element
*
Add
(
)
;
template
<
typename
Iter
>
void
Add
(
Iter
begin
Iter
end
)
;
void
RemoveLast
(
)
;
void
ExtractSubrange
(
int
start
int
num
Element
*
elements
)
;
void
Clear
(
)
;
void
MergeFrom
(
const
RepeatedField
&
other
)
;
void
CopyFrom
(
const
RepeatedField
&
other
)
;
void
Reserve
(
int
new_size
)
;
void
Truncate
(
int
new_size
)
;
void
AddAlreadyReserved
(
const
Element
&
value
)
;
Element
*
AddAlreadyReserved
(
)
;
Element
*
AddNAlreadyReserved
(
int
elements
)
;
int
Capacity
(
)
const
;
void
Resize
(
int
new_size
const
Element
&
value
)
;
Element
*
mutable_data
(
)
;
const
Element
*
data
(
)
const
;
void
Swap
(
RepeatedField
*
other
)
;
void
UnsafeArenaSwap
(
RepeatedField
*
other
)
;
void
SwapElements
(
int
index1
int
index2
)
;
typedef
Element
*
iterator
;
typedef
const
Element
*
const_iterator
;
typedef
Element
value_type
;
typedef
value_type
&
reference
;
typedef
const
value_type
&
const_reference
;
typedef
value_type
*
pointer
;
typedef
const
value_type
*
const_pointer
;
typedef
int
size_type
;
typedef
ptrdiff_t
difference_type
;
iterator
begin
(
)
;
const_iterator
begin
(
)
const
;
const_iterator
cbegin
(
)
const
;
iterator
end
(
)
;
const_iterator
end
(
)
const
;
const_iterator
cend
(
)
const
;
typedef
std
:
:
reverse_iterator
<
const_iterator
>
const_reverse_iterator
;
typedef
std
:
:
reverse_iterator
<
iterator
>
reverse_iterator
;
reverse_iterator
rbegin
(
)
{
return
reverse_iterator
(
end
(
)
)
;
}
const_reverse_iterator
rbegin
(
)
const
{
return
const_reverse_iterator
(
end
(
)
)
;
}
reverse_iterator
rend
(
)
{
return
reverse_iterator
(
begin
(
)
)
;
}
const_reverse_iterator
rend
(
)
const
{
return
const_reverse_iterator
(
begin
(
)
)
;
}
size_t
SpaceUsedExcludingSelfLong
(
)
const
;
int
SpaceUsedExcludingSelf
(
)
const
{
return
internal
:
:
ToIntSize
(
SpaceUsedExcludingSelfLong
(
)
)
;
}
iterator
erase
(
const_iterator
position
)
;
iterator
erase
(
const_iterator
first
const_iterator
last
)
;
Arena
*
GetArena
(
)
const
{
return
GetArenaNoVirtual
(
)
;
}
inline
void
InternalSwap
(
RepeatedField
*
other
)
;
private
:
static
const
int
kInitialSize
=
0
;
int
current_size_
;
int
total_size_
;
struct
Rep
{
Arena
*
arena
;
Element
elements
[
1
]
;
}
;
static
const
size_t
kRepHeaderSize
;
void
*
arena_or_elements_
;
Element
*
elements
(
)
const
{
GOOGLE_DCHECK_GT
(
total_size_
0
)
;
return
unsafe_elements
(
)
;
}
Element
*
unsafe_elements
(
)
const
{
return
static_cast
<
Element
*
>
(
arena_or_elements_
)
;
}
Rep
*
rep
(
)
const
{
char
*
addr
=
reinterpret_cast
<
char
*
>
(
elements
(
)
)
-
offsetof
(
Rep
elements
)
;
return
reinterpret_cast
<
Rep
*
>
(
addr
)
;
}
friend
class
Arena
;
typedef
void
InternalArenaConstructable_
;
void
MoveArray
(
Element
*
to
Element
*
from
int
size
)
;
void
CopyArray
(
Element
*
to
const
Element
*
from
int
size
)
;
inline
Arena
*
GetArenaNoVirtual
(
)
const
{
return
(
total_size_
=
=
0
)
?
static_cast
<
Arena
*
>
(
arena_or_elements_
)
:
rep
(
)
-
>
arena
;
}
void
InternalDeallocate
(
Rep
*
rep
int
size
)
{
if
(
rep
!
=
NULL
)
{
Element
*
e
=
&
rep
-
>
elements
[
0
]
;
Element
*
limit
=
&
rep
-
>
elements
[
size
]
;
for
(
;
e
<
limit
;
e
+
+
)
{
e
-
>
~
Element
(
)
;
}
if
(
rep
-
>
arena
=
=
NULL
)
{
#
if
defined
(
__GXX_DELETE_WITH_SIZE__
)
|
|
defined
(
__cpp_sized_deallocation
)
const
size_t
bytes
=
size
*
sizeof
(
*
e
)
+
kRepHeaderSize
;
:
:
operator
delete
(
static_cast
<
void
*
>
(
rep
)
bytes
)
;
#
else
:
:
operator
delete
(
static_cast
<
void
*
>
(
rep
)
)
;
#
endif
}
}
}
}
;
template
<
typename
Element
>
const
size_t
RepeatedField
<
Element
>
:
:
kRepHeaderSize
=
reinterpret_cast
<
size_t
>
(
&
reinterpret_cast
<
Rep
*
>
(
16
)
-
>
elements
[
0
]
)
-
16
;
namespace
internal
{
template
<
typename
It
>
class
RepeatedPtrIterator
;
template
<
typename
It
typename
VoidPtr
>
class
RepeatedPtrOverPtrsIterator
;
}
namespace
internal
{
template
<
typename
Element
bool
HasTrivialCopy
=
std
:
:
is_pod
<
Element
>
:
:
value
>
struct
ElementCopier
{
void
operator
(
)
(
Element
*
to
const
Element
*
from
int
array_size
)
;
}
;
}
namespace
internal
{
template
<
typename
T
>
struct
TypeImplementsMergeBehaviorProbeForMergeFrom
{
typedef
char
HasMerge
;
typedef
long
HasNoMerge
;
template
<
typename
U
typename
RetType
RetType
(
U
:
:
*
)
(
const
U
&
arg
)
>
struct
CheckType
;
template
<
typename
U
>
static
HasMerge
Check
(
CheckType
<
U
void
&
U
:
:
MergeFrom
>
*
)
;
template
<
typename
U
>
static
HasMerge
Check
(
CheckType
<
U
bool
&
U
:
:
MergeFrom
>
*
)
;
template
<
typename
U
>
static
HasNoMerge
Check
(
.
.
.
)
;
typedef
std
:
:
integral_constant
<
bool
(
sizeof
(
Check
<
T
>
(
0
)
)
=
=
sizeof
(
HasMerge
)
)
>
type
;
}
;
template
<
typename
T
typename
=
void
>
struct
TypeImplementsMergeBehavior
:
TypeImplementsMergeBehaviorProbeForMergeFrom
<
T
>
{
}
;
template
<
>
struct
TypeImplementsMergeBehavior
<
std
:
:
string
>
{
typedef
std
:
:
true_type
type
;
}
;
template
<
typename
T
>
struct
IsMovable
:
std
:
:
integral_constant
<
bool
std
:
:
is_move_constructible
<
T
>
:
:
value
&
&
std
:
:
is_move_assignable
<
T
>
:
:
value
>
{
}
;
class
PROTOBUF_EXPORT
RepeatedPtrFieldBase
{
protected
:
RepeatedPtrFieldBase
(
)
;
explicit
RepeatedPtrFieldBase
(
Arena
*
arena
)
;
~
RepeatedPtrFieldBase
(
)
{
#
ifndef
NDEBUG
if
(
arena_
)
(
void
)
arena_
-
>
SpaceAllocated
(
)
;
#
endif
}
public
:
template
<
typename
TypeHandler
>
void
Destroy
(
)
;
protected
:
bool
empty
(
)
const
;
int
size
(
)
const
;
template
<
typename
TypeHandler
>
const
typename
TypeHandler
:
:
Type
&
at
(
int
index
)
const
;
template
<
typename
TypeHandler
>
typename
TypeHandler
:
:
Type
&
at
(
int
index
)
;
template
<
typename
TypeHandler
>
typename
TypeHandler
:
:
Type
*
Mutable
(
int
index
)
;
template
<
typename
TypeHandler
>
void
Delete
(
int
index
)
;
template
<
typename
TypeHandler
>
typename
TypeHandler
:
:
Type
*
Add
(
typename
TypeHandler
:
:
Type
*
prototype
=
NULL
)
;
public
:
template
<
typename
TypeHandler
>
const
typename
TypeHandler
:
:
Type
&
Get
(
int
index
)
const
;
MessageLite
*
AddWeak
(
const
MessageLite
*
prototype
)
;
template
<
typename
TypeHandler
>
void
Clear
(
)
;
template
<
typename
TypeHandler
>
void
MergeFrom
(
const
RepeatedPtrFieldBase
&
other
)
;
inline
void
InternalSwap
(
RepeatedPtrFieldBase
*
other
)
;
protected
:
template
<
typename
TypeHandler
typename
std
:
:
enable_if
<
TypeHandler
:
:
Movable
:
:
value
>
:
:
type
*
=
nullptr
>
void
Add
(
typename
TypeHandler
:
:
Type
&
&
value
)
;
template
<
typename
TypeHandler
>
void
RemoveLast
(
)
;
template
<
typename
TypeHandler
>
void
CopyFrom
(
const
RepeatedPtrFieldBase
&
other
)
;
void
CloseGap
(
int
start
int
num
)
;
void
Reserve
(
int
new_size
)
;
int
Capacity
(
)
const
;
void
*
const
*
raw_data
(
)
const
;
void
*
*
raw_mutable_data
(
)
const
;
template
<
typename
TypeHandler
>
typename
TypeHandler
:
:
Type
*
*
mutable_data
(
)
;
template
<
typename
TypeHandler
>
const
typename
TypeHandler
:
:
Type
*
const
*
data
(
)
const
;
template
<
typename
TypeHandler
>
PROTOBUF_ALWAYS_INLINE
void
Swap
(
RepeatedPtrFieldBase
*
other
)
;
void
SwapElements
(
int
index1
int
index2
)
;
template
<
typename
TypeHandler
>
size_t
SpaceUsedExcludingSelfLong
(
)
const
;
template
<
typename
TypeHandler
>
typename
TypeHandler
:
:
Type
*
AddFromCleared
(
)
;
template
<
typename
TypeHandler
>
void
AddAllocated
(
typename
TypeHandler
:
:
Type
*
value
)
{
typename
TypeImplementsMergeBehavior
<
typename
TypeHandler
:
:
Type
>
:
:
type
t
;
AddAllocatedInternal
<
TypeHandler
>
(
value
t
)
;
}
template
<
typename
TypeHandler
>
void
UnsafeArenaAddAllocated
(
typename
TypeHandler
:
:
Type
*
value
)
;
template
<
typename
TypeHandler
>
typename
TypeHandler
:
:
Type
*
ReleaseLast
(
)
{
typename
TypeImplementsMergeBehavior
<
typename
TypeHandler
:
:
Type
>
:
:
type
t
;
return
ReleaseLastInternal
<
TypeHandler
>
(
t
)
;
}
template
<
typename
TypeHandler
>
typename
TypeHandler
:
:
Type
*
UnsafeArenaReleaseLast
(
)
;
int
ClearedCount
(
)
const
;
template
<
typename
TypeHandler
>
void
AddCleared
(
typename
TypeHandler
:
:
Type
*
value
)
;
template
<
typename
TypeHandler
>
typename
TypeHandler
:
:
Type
*
ReleaseCleared
(
)
;
template
<
typename
TypeHandler
>
void
AddAllocatedInternal
(
typename
TypeHandler
:
:
Type
*
value
std
:
:
true_type
)
;
template
<
typename
TypeHandler
>
void
AddAllocatedInternal
(
typename
TypeHandler
:
:
Type
*
value
std
:
:
false_type
)
;
template
<
typename
TypeHandler
>
PROTOBUF_NOINLINE
void
AddAllocatedSlowWithCopy
(
typename
TypeHandler
:
:
Type
*
value
Arena
*
value_arena
Arena
*
my_arena
)
;
template
<
typename
TypeHandler
>
PROTOBUF_NOINLINE
void
AddAllocatedSlowWithoutCopy
(
typename
TypeHandler
:
:
Type
*
value
)
;
template
<
typename
TypeHandler
>
typename
TypeHandler
:
:
Type
*
ReleaseLastInternal
(
std
:
:
true_type
)
;
template
<
typename
TypeHandler
>
typename
TypeHandler
:
:
Type
*
ReleaseLastInternal
(
std
:
:
false_type
)
;
template
<
typename
TypeHandler
>
PROTOBUF_NOINLINE
void
SwapFallback
(
RepeatedPtrFieldBase
*
other
)
;
inline
Arena
*
GetArenaNoVirtual
(
)
const
{
return
arena_
;
}
private
:
static
const
int
kInitialSize
=
0
;
Arena
*
arena_
;
int
current_size_
;
int
total_size_
;
struct
Rep
{
int
allocated_size
;
void
*
elements
[
1
]
;
}
;
static
const
size_t
kRepHeaderSize
=
sizeof
(
Rep
)
-
sizeof
(
void
*
)
;
Rep
*
rep_
;
template
<
typename
TypeHandler
>
static
inline
typename
TypeHandler
:
:
Type
*
cast
(
void
*
element
)
{
return
reinterpret_cast
<
typename
TypeHandler
:
:
Type
*
>
(
element
)
;
}
template
<
typename
TypeHandler
>
static
inline
const
typename
TypeHandler
:
:
Type
*
cast
(
const
void
*
element
)
{
return
reinterpret_cast
<
const
typename
TypeHandler
:
:
Type
*
>
(
element
)
;
}
void
MergeFromInternal
(
const
RepeatedPtrFieldBase
&
other
void
(
RepeatedPtrFieldBase
:
:
*
inner_loop
)
(
void
*
*
void
*
*
int
int
)
)
;
template
<
typename
TypeHandler
>
void
MergeFromInnerLoop
(
void
*
*
our_elems
void
*
*
other_elems
int
length
int
already_allocated
)
;
void
*
*
InternalExtend
(
int
extend_amount
)
;
friend
class
:
:
PROTOBUF_NAMESPACE_ID
:
:
Reflection
;
friend
class
ExtensionSet
;
friend
class
MapFieldBase
;
friend
class
MergePartialFromCodedStreamHelper
;
friend
class
AccessorHelper
;
template
<
typename
T
>
friend
struct
google
:
:
protobuf
:
:
WeakRepeatedPtrField
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
RepeatedPtrFieldBase
)
;
}
;
template
<
typename
GenericType
>
class
GenericTypeHandler
{
public
:
typedef
GenericType
Type
;
using
Movable
=
IsMovable
<
GenericType
>
;
static
inline
GenericType
*
New
(
Arena
*
arena
)
{
return
Arena
:
:
CreateMaybeMessage
<
Type
>
(
arena
)
;
}
static
inline
GenericType
*
New
(
Arena
*
arena
GenericType
&
&
value
)
{
return
Arena
:
:
Create
<
GenericType
>
(
arena
std
:
:
move
(
value
)
)
;
}
static
inline
GenericType
*
NewFromPrototype
(
const
GenericType
*
prototype
Arena
*
arena
=
NULL
)
;
static
inline
void
Delete
(
GenericType
*
value
Arena
*
arena
)
{
if
(
arena
=
=
NULL
)
{
delete
value
;
}
}
static
inline
Arena
*
GetArena
(
GenericType
*
value
)
{
return
Arena
:
:
GetArena
<
Type
>
(
value
)
;
}
static
inline
void
*
GetMaybeArenaPointer
(
GenericType
*
value
)
{
return
Arena
:
:
GetArena
<
Type
>
(
value
)
;
}
static
inline
void
Clear
(
GenericType
*
value
)
{
value
-
>
Clear
(
)
;
}
PROTOBUF_NOINLINE
static
void
Merge
(
const
GenericType
&
from
GenericType
*
to
)
;
static
inline
size_t
SpaceUsedLong
(
const
GenericType
&
value
)
{
return
value
.
SpaceUsedLong
(
)
;
}
}
;
template
<
typename
GenericType
>
GenericType
*
GenericTypeHandler
<
GenericType
>
:
:
NewFromPrototype
(
const
GenericType
*
Arena
*
arena
)
{
return
New
(
arena
)
;
}
template
<
typename
GenericType
>
void
GenericTypeHandler
<
GenericType
>
:
:
Merge
(
const
GenericType
&
from
GenericType
*
to
)
{
to
-
>
MergeFrom
(
from
)
;
}
template
<
>
MessageLite
*
GenericTypeHandler
<
MessageLite
>
:
:
NewFromPrototype
(
const
MessageLite
*
prototype
Arena
*
arena
)
;
template
<
>
inline
Arena
*
GenericTypeHandler
<
MessageLite
>
:
:
GetArena
(
MessageLite
*
value
)
{
return
value
-
>
GetArena
(
)
;
}
template
<
>
inline
void
*
GenericTypeHandler
<
MessageLite
>
:
:
GetMaybeArenaPointer
(
MessageLite
*
value
)
{
return
value
-
>
GetMaybeArenaPointer
(
)
;
}
template
<
>
void
GenericTypeHandler
<
MessageLite
>
:
:
Merge
(
const
MessageLite
&
from
MessageLite
*
to
)
;
template
<
>
inline
void
GenericTypeHandler
<
std
:
:
string
>
:
:
Clear
(
std
:
:
string
*
value
)
{
value
-
>
clear
(
)
;
}
template
<
>
void
GenericTypeHandler
<
std
:
:
string
>
:
:
Merge
(
const
std
:
:
string
&
from
std
:
:
string
*
to
)
;
template
<
>
PROTOBUF_EXPORT
Message
*
GenericTypeHandler
<
Message
>
:
:
NewFromPrototype
(
const
Message
*
prototype
Arena
*
arena
)
;
template
<
>
PROTOBUF_EXPORT
Arena
*
GenericTypeHandler
<
Message
>
:
:
GetArena
(
Message
*
value
)
;
template
<
>
PROTOBUF_EXPORT
void
*
GenericTypeHandler
<
Message
>
:
:
GetMaybeArenaPointer
(
Message
*
value
)
;
class
StringTypeHandler
{
public
:
typedef
std
:
:
string
Type
;
using
Movable
=
IsMovable
<
Type
>
;
static
inline
std
:
:
string
*
New
(
Arena
*
arena
)
{
return
Arena
:
:
Create
<
std
:
:
string
>
(
arena
)
;
}
static
inline
std
:
:
string
*
New
(
Arena
*
arena
std
:
:
string
&
&
value
)
{
return
Arena
:
:
Create
<
std
:
:
string
>
(
arena
std
:
:
move
(
value
)
)
;
}
static
inline
std
:
:
string
*
NewFromPrototype
(
const
std
:
:
string
*
Arena
*
arena
)
{
return
New
(
arena
)
;
}
static
inline
Arena
*
GetArena
(
std
:
:
string
*
)
{
return
NULL
;
}
static
inline
void
*
GetMaybeArenaPointer
(
std
:
:
string
*
)
{
return
NULL
;
}
static
inline
void
Delete
(
std
:
:
string
*
value
Arena
*
arena
)
{
if
(
arena
=
=
NULL
)
{
delete
value
;
}
}
static
inline
void
Clear
(
std
:
:
string
*
value
)
{
value
-
>
clear
(
)
;
}
static
inline
void
Merge
(
const
std
:
:
string
&
from
std
:
:
string
*
to
)
{
*
to
=
from
;
}
static
size_t
SpaceUsedLong
(
const
std
:
:
string
&
value
)
{
return
sizeof
(
value
)
+
StringSpaceUsedExcludingSelfLong
(
value
)
;
}
}
;
}
template
<
typename
Element
>
class
RepeatedPtrField
final
:
private
internal
:
:
RepeatedPtrFieldBase
{
public
:
RepeatedPtrField
(
)
;
explicit
RepeatedPtrField
(
Arena
*
arena
)
;
RepeatedPtrField
(
const
RepeatedPtrField
&
other
)
;
template
<
typename
Iter
>
RepeatedPtrField
(
Iter
begin
const
Iter
&
end
)
;
~
RepeatedPtrField
(
)
;
RepeatedPtrField
&
operator
=
(
const
RepeatedPtrField
&
other
)
;
RepeatedPtrField
(
RepeatedPtrField
&
&
other
)
noexcept
;
RepeatedPtrField
&
operator
=
(
RepeatedPtrField
&
&
other
)
noexcept
;
bool
empty
(
)
const
;
int
size
(
)
const
;
const
Element
&
Get
(
int
index
)
const
;
Element
*
Mutable
(
int
index
)
;
Element
*
Add
(
)
;
void
Add
(
Element
&
&
value
)
;
const
Element
&
operator
[
]
(
int
index
)
const
{
return
Get
(
index
)
;
}
Element
&
operator
[
]
(
int
index
)
{
return
*
Mutable
(
index
)
;
}
const
Element
&
at
(
int
index
)
const
;
Element
&
at
(
int
index
)
;
void
RemoveLast
(
)
;
void
DeleteSubrange
(
int
start
int
num
)
;
void
Clear
(
)
;
void
MergeFrom
(
const
RepeatedPtrField
&
other
)
;
void
CopyFrom
(
const
RepeatedPtrField
&
other
)
;
void
Reserve
(
int
new_size
)
;
int
Capacity
(
)
const
;
Element
*
*
mutable_data
(
)
;
const
Element
*
const
*
data
(
)
const
;
void
Swap
(
RepeatedPtrField
*
other
)
;
void
UnsafeArenaSwap
(
RepeatedPtrField
*
other
)
;
void
SwapElements
(
int
index1
int
index2
)
;
typedef
internal
:
:
RepeatedPtrIterator
<
Element
>
iterator
;
typedef
internal
:
:
RepeatedPtrIterator
<
const
Element
>
const_iterator
;
typedef
Element
value_type
;
typedef
value_type
&
reference
;
typedef
const
value_type
&
const_reference
;
typedef
value_type
*
pointer
;
typedef
const
value_type
*
const_pointer
;
typedef
int
size_type
;
typedef
ptrdiff_t
difference_type
;
iterator
begin
(
)
;
const_iterator
begin
(
)
const
;
const_iterator
cbegin
(
)
const
;
iterator
end
(
)
;
const_iterator
end
(
)
const
;
const_iterator
cend
(
)
const
;
typedef
std
:
:
reverse_iterator
<
const_iterator
>
const_reverse_iterator
;
typedef
std
:
:
reverse_iterator
<
iterator
>
reverse_iterator
;
reverse_iterator
rbegin
(
)
{
return
reverse_iterator
(
end
(
)
)
;
}
const_reverse_iterator
rbegin
(
)
const
{
return
const_reverse_iterator
(
end
(
)
)
;
}
reverse_iterator
rend
(
)
{
return
reverse_iterator
(
begin
(
)
)
;
}
const_reverse_iterator
rend
(
)
const
{
return
const_reverse_iterator
(
begin
(
)
)
;
}
typedef
internal
:
:
RepeatedPtrOverPtrsIterator
<
Element
*
void
*
>
pointer_iterator
;
typedef
internal
:
:
RepeatedPtrOverPtrsIterator
<
const
Element
*
const
const
void
*
const
>
const_pointer_iterator
;
pointer_iterator
pointer_begin
(
)
;
const_pointer_iterator
pointer_begin
(
)
const
;
pointer_iterator
pointer_end
(
)
;
const_pointer_iterator
pointer_end
(
)
const
;
size_t
SpaceUsedExcludingSelfLong
(
)
const
;
int
SpaceUsedExcludingSelf
(
)
const
{
return
internal
:
:
ToIntSize
(
SpaceUsedExcludingSelfLong
(
)
)
;
}
void
AddAllocated
(
Element
*
value
)
;
Element
*
ReleaseLast
(
)
;
void
UnsafeArenaAddAllocated
(
Element
*
value
)
;
Element
*
UnsafeArenaReleaseLast
(
)
;
void
ExtractSubrange
(
int
start
int
num
Element
*
*
elements
)
;
void
UnsafeArenaExtractSubrange
(
int
start
int
num
Element
*
*
elements
)
;
int
ClearedCount
(
)
const
;
void
AddCleared
(
Element
*
value
)
;
Element
*
ReleaseCleared
(
)
;
iterator
erase
(
const_iterator
position
)
;
iterator
erase
(
const_iterator
first
const_iterator
last
)
;
Arena
*
GetArena
(
)
const
{
return
GetArenaNoVirtual
(
)
;
}
void
InternalSwap
(
RepeatedPtrField
*
other
)
{
internal
:
:
RepeatedPtrFieldBase
:
:
InternalSwap
(
other
)
;
}
private
:
class
TypeHandler
;
inline
Arena
*
GetArenaNoVirtual
(
)
const
;
void
ExtractSubrangeInternal
(
int
start
int
num
Element
*
*
elements
std
:
:
true_type
)
;
void
ExtractSubrangeInternal
(
int
start
int
num
Element
*
*
elements
std
:
:
false_type
)
;
friend
class
Arena
;
template
<
typename
T
>
friend
struct
WeakRepeatedPtrField
;
typedef
void
InternalArenaConstructable_
;
}
;
template
<
typename
Element
>
inline
RepeatedField
<
Element
>
:
:
RepeatedField
(
)
:
current_size_
(
0
)
total_size_
(
0
)
arena_or_elements_
(
nullptr
)
{
}
template
<
typename
Element
>
inline
RepeatedField
<
Element
>
:
:
RepeatedField
(
Arena
*
arena
)
:
current_size_
(
0
)
total_size_
(
0
)
arena_or_elements_
(
arena
)
{
}
template
<
typename
Element
>
inline
RepeatedField
<
Element
>
:
:
RepeatedField
(
const
RepeatedField
&
other
)
:
current_size_
(
0
)
total_size_
(
0
)
arena_or_elements_
(
nullptr
)
{
if
(
other
.
current_size_
!
=
0
)
{
Reserve
(
other
.
size
(
)
)
;
AddNAlreadyReserved
(
other
.
size
(
)
)
;
CopyArray
(
Mutable
(
0
)
&
other
.
Get
(
0
)
other
.
size
(
)
)
;
}
}
template
<
typename
Element
>
template
<
typename
Iter
>
RepeatedField
<
Element
>
:
:
RepeatedField
(
Iter
begin
const
Iter
&
end
)
:
current_size_
(
0
)
total_size_
(
0
)
arena_or_elements_
(
nullptr
)
{
Add
(
begin
end
)
;
}
template
<
typename
Element
>
RepeatedField
<
Element
>
:
:
~
RepeatedField
(
)
{
if
(
total_size_
>
0
)
{
InternalDeallocate
(
rep
(
)
total_size_
)
;
}
}
template
<
typename
Element
>
inline
RepeatedField
<
Element
>
&
RepeatedField
<
Element
>
:
:
operator
=
(
const
RepeatedField
&
other
)
{
if
(
this
!
=
&
other
)
CopyFrom
(
other
)
;
return
*
this
;
}
template
<
typename
Element
>
inline
RepeatedField
<
Element
>
:
:
RepeatedField
(
RepeatedField
&
&
other
)
noexcept
:
RepeatedField
(
)
{
if
(
other
.
GetArenaNoVirtual
(
)
)
{
CopyFrom
(
other
)
;
}
else
{
InternalSwap
(
&
other
)
;
}
}
template
<
typename
Element
>
inline
RepeatedField
<
Element
>
&
RepeatedField
<
Element
>
:
:
operator
=
(
RepeatedField
&
&
other
)
noexcept
{
if
(
this
!
=
&
other
)
{
if
(
this
-
>
GetArenaNoVirtual
(
)
!
=
other
.
GetArenaNoVirtual
(
)
)
{
CopyFrom
(
other
)
;
}
else
{
InternalSwap
(
&
other
)
;
}
}
return
*
this
;
}
template
<
typename
Element
>
inline
bool
RepeatedField
<
Element
>
:
:
empty
(
)
const
{
return
current_size_
=
=
0
;
}
template
<
typename
Element
>
inline
int
RepeatedField
<
Element
>
:
:
size
(
)
const
{
return
current_size_
;
}
template
<
typename
Element
>
inline
int
RepeatedField
<
Element
>
:
:
Capacity
(
)
const
{
return
total_size_
;
}
template
<
typename
Element
>
inline
void
RepeatedField
<
Element
>
:
:
AddAlreadyReserved
(
const
Element
&
value
)
{
GOOGLE_DCHECK_LT
(
current_size_
total_size_
)
;
elements
(
)
[
current_size_
+
+
]
=
value
;
}
template
<
typename
Element
>
inline
Element
*
RepeatedField
<
Element
>
:
:
AddAlreadyReserved
(
)
{
GOOGLE_DCHECK_LT
(
current_size_
total_size_
)
;
return
&
elements
(
)
[
current_size_
+
+
]
;
}
template
<
typename
Element
>
inline
Element
*
RepeatedField
<
Element
>
:
:
AddNAlreadyReserved
(
int
n
)
{
GOOGLE_DCHECK_GE
(
total_size_
-
current_size_
n
)
<
<
total_size_
<
<
"
"
<
<
current_size_
;
Element
*
ret
=
unsafe_elements
(
)
+
current_size_
;
current_size_
+
=
n
;
return
ret
;
}
template
<
typename
Element
>
inline
void
RepeatedField
<
Element
>
:
:
Resize
(
int
new_size
const
Element
&
value
)
{
GOOGLE_DCHECK_GE
(
new_size
0
)
;
if
(
new_size
>
current_size_
)
{
Reserve
(
new_size
)
;
std
:
:
fill
(
&
elements
(
)
[
current_size_
]
&
elements
(
)
[
new_size
]
value
)
;
}
current_size_
=
new_size
;
}
template
<
typename
Element
>
inline
const
Element
&
RepeatedField
<
Element
>
:
:
Get
(
int
index
)
const
{
GOOGLE_DCHECK_GE
(
index
0
)
;
GOOGLE_DCHECK_LT
(
index
current_size_
)
;
return
elements
(
)
[
index
]
;
}
template
<
typename
Element
>
inline
const
Element
&
RepeatedField
<
Element
>
:
:
at
(
int
index
)
const
{
GOOGLE_CHECK_GE
(
index
0
)
;
GOOGLE_CHECK_LT
(
index
current_size_
)
;
return
elements
(
)
[
index
]
;
}
template
<
typename
Element
>
inline
Element
&
RepeatedField
<
Element
>
:
:
at
(
int
index
)
{
GOOGLE_CHECK_GE
(
index
0
)
;
GOOGLE_CHECK_LT
(
index
current_size_
)
;
return
elements
(
)
[
index
]
;
}
template
<
typename
Element
>
inline
Element
*
RepeatedField
<
Element
>
:
:
Mutable
(
int
index
)
{
GOOGLE_DCHECK_GE
(
index
0
)
;
GOOGLE_DCHECK_LT
(
index
current_size_
)
;
return
&
elements
(
)
[
index
]
;
}
template
<
typename
Element
>
inline
void
RepeatedField
<
Element
>
:
:
Set
(
int
index
const
Element
&
value
)
{
GOOGLE_DCHECK_GE
(
index
0
)
;
GOOGLE_DCHECK_LT
(
index
current_size_
)
;
elements
(
)
[
index
]
=
value
;
}
template
<
typename
Element
>
inline
void
RepeatedField
<
Element
>
:
:
Add
(
const
Element
&
value
)
{
if
(
current_size_
=
=
total_size_
)
Reserve
(
total_size_
+
1
)
;
elements
(
)
[
current_size_
+
+
]
=
value
;
}
template
<
typename
Element
>
inline
Element
*
RepeatedField
<
Element
>
:
:
Add
(
)
{
if
(
current_size_
=
=
total_size_
)
Reserve
(
total_size_
+
1
)
;
return
&
elements
(
)
[
current_size_
+
+
]
;
}
template
<
typename
Element
>
template
<
typename
Iter
>
inline
void
RepeatedField
<
Element
>
:
:
Add
(
Iter
begin
Iter
end
)
{
int
reserve
=
internal
:
:
CalculateReserve
(
begin
end
)
;
if
(
reserve
!
=
-
1
)
{
if
(
reserve
=
=
0
)
{
return
;
}
Reserve
(
reserve
+
size
(
)
)
;
std
:
:
copy
(
begin
end
elements
(
)
+
size
(
)
)
;
current_size_
=
reserve
+
size
(
)
;
}
else
{
for
(
;
begin
!
=
end
;
+
+
begin
)
{
Add
(
*
begin
)
;
}
}
}
template
<
typename
Element
>
inline
void
RepeatedField
<
Element
>
:
:
RemoveLast
(
)
{
GOOGLE_DCHECK_GT
(
current_size_
0
)
;
current_size_
-
-
;
}
template
<
typename
Element
>
void
RepeatedField
<
Element
>
:
:
ExtractSubrange
(
int
start
int
num
Element
*
elements
)
{
GOOGLE_DCHECK_GE
(
start
0
)
;
GOOGLE_DCHECK_GE
(
num
0
)
;
GOOGLE_DCHECK_LE
(
start
+
num
this
-
>
current_size_
)
;
if
(
elements
!
=
NULL
)
{
for
(
int
i
=
0
;
i
<
num
;
+
+
i
)
elements
[
i
]
=
this
-
>
Get
(
i
+
start
)
;
}
if
(
num
>
0
)
{
for
(
int
i
=
start
+
num
;
i
<
this
-
>
current_size_
;
+
+
i
)
this
-
>
Set
(
i
-
num
this
-
>
Get
(
i
)
)
;
this
-
>
Truncate
(
this
-
>
current_size_
-
num
)
;
}
}
template
<
typename
Element
>
inline
void
RepeatedField
<
Element
>
:
:
Clear
(
)
{
current_size_
=
0
;
}
template
<
typename
Element
>
inline
void
RepeatedField
<
Element
>
:
:
MergeFrom
(
const
RepeatedField
&
other
)
{
GOOGLE_DCHECK_NE
(
&
other
this
)
;
if
(
other
.
current_size_
!
=
0
)
{
int
existing_size
=
size
(
)
;
Reserve
(
existing_size
+
other
.
size
(
)
)
;
AddNAlreadyReserved
(
other
.
size
(
)
)
;
CopyArray
(
Mutable
(
existing_size
)
&
other
.
Get
(
0
)
other
.
size
(
)
)
;
}
}
template
<
typename
Element
>
inline
void
RepeatedField
<
Element
>
:
:
CopyFrom
(
const
RepeatedField
&
other
)
{
if
(
&
other
=
=
this
)
return
;
Clear
(
)
;
MergeFrom
(
other
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedField
<
Element
>
:
:
iterator
RepeatedField
<
Element
>
:
:
erase
(
const_iterator
position
)
{
return
erase
(
position
position
+
1
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedField
<
Element
>
:
:
iterator
RepeatedField
<
Element
>
:
:
erase
(
const_iterator
first
const_iterator
last
)
{
size_type
first_offset
=
first
-
cbegin
(
)
;
if
(
first
!
=
last
)
{
Truncate
(
std
:
:
copy
(
last
cend
(
)
begin
(
)
+
first_offset
)
-
cbegin
(
)
)
;
}
return
begin
(
)
+
first_offset
;
}
template
<
typename
Element
>
inline
Element
*
RepeatedField
<
Element
>
:
:
mutable_data
(
)
{
return
unsafe_elements
(
)
;
}
template
<
typename
Element
>
inline
const
Element
*
RepeatedField
<
Element
>
:
:
data
(
)
const
{
return
unsafe_elements
(
)
;
}
template
<
typename
Element
>
inline
void
RepeatedField
<
Element
>
:
:
InternalSwap
(
RepeatedField
*
other
)
{
GOOGLE_DCHECK
(
this
!
=
other
)
;
GOOGLE_DCHECK
(
GetArenaNoVirtual
(
)
=
=
other
-
>
GetArenaNoVirtual
(
)
)
;
std
:
:
swap
(
arena_or_elements_
other
-
>
arena_or_elements_
)
;
std
:
:
swap
(
current_size_
other
-
>
current_size_
)
;
std
:
:
swap
(
total_size_
other
-
>
total_size_
)
;
}
template
<
typename
Element
>
void
RepeatedField
<
Element
>
:
:
Swap
(
RepeatedField
*
other
)
{
if
(
this
=
=
other
)
return
;
if
(
GetArenaNoVirtual
(
)
=
=
other
-
>
GetArenaNoVirtual
(
)
)
{
InternalSwap
(
other
)
;
}
else
{
RepeatedField
<
Element
>
temp
(
other
-
>
GetArenaNoVirtual
(
)
)
;
temp
.
MergeFrom
(
*
this
)
;
CopyFrom
(
*
other
)
;
other
-
>
UnsafeArenaSwap
(
&
temp
)
;
}
}
template
<
typename
Element
>
void
RepeatedField
<
Element
>
:
:
UnsafeArenaSwap
(
RepeatedField
*
other
)
{
if
(
this
=
=
other
)
return
;
InternalSwap
(
other
)
;
}
template
<
typename
Element
>
void
RepeatedField
<
Element
>
:
:
SwapElements
(
int
index1
int
index2
)
{
using
std
:
:
swap
;
swap
(
elements
(
)
[
index1
]
elements
(
)
[
index2
]
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedField
<
Element
>
:
:
iterator
RepeatedField
<
Element
>
:
:
begin
(
)
{
return
unsafe_elements
(
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedField
<
Element
>
:
:
const_iterator
RepeatedField
<
Element
>
:
:
begin
(
)
const
{
return
unsafe_elements
(
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedField
<
Element
>
:
:
const_iterator
RepeatedField
<
Element
>
:
:
cbegin
(
)
const
{
return
unsafe_elements
(
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedField
<
Element
>
:
:
iterator
RepeatedField
<
Element
>
:
:
end
(
)
{
return
unsafe_elements
(
)
+
current_size_
;
}
template
<
typename
Element
>
inline
typename
RepeatedField
<
Element
>
:
:
const_iterator
RepeatedField
<
Element
>
:
:
end
(
)
const
{
return
unsafe_elements
(
)
+
current_size_
;
}
template
<
typename
Element
>
inline
typename
RepeatedField
<
Element
>
:
:
const_iterator
RepeatedField
<
Element
>
:
:
cend
(
)
const
{
return
unsafe_elements
(
)
+
current_size_
;
}
template
<
typename
Element
>
inline
size_t
RepeatedField
<
Element
>
:
:
SpaceUsedExcludingSelfLong
(
)
const
{
return
total_size_
>
0
?
(
total_size_
*
sizeof
(
Element
)
+
kRepHeaderSize
)
:
0
;
}
template
<
typename
Element
>
void
RepeatedField
<
Element
>
:
:
Reserve
(
int
new_size
)
{
if
(
total_size_
>
=
new_size
)
return
;
Rep
*
old_rep
=
total_size_
>
0
?
rep
(
)
:
NULL
;
Rep
*
new_rep
;
Arena
*
arena
=
GetArenaNoVirtual
(
)
;
new_size
=
std
:
:
max
(
internal
:
:
kMinRepeatedFieldAllocationSize
std
:
:
max
(
total_size_
*
2
new_size
)
)
;
GOOGLE_DCHECK_LE
(
static_cast
<
size_t
>
(
new_size
)
(
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
-
kRepHeaderSize
)
/
sizeof
(
Element
)
)
<
<
"
Requested
size
is
too
large
to
fit
into
size_t
.
"
;
size_t
bytes
=
kRepHeaderSize
+
sizeof
(
Element
)
*
static_cast
<
size_t
>
(
new_size
)
;
if
(
arena
=
=
NULL
)
{
new_rep
=
static_cast
<
Rep
*
>
(
:
:
operator
new
(
bytes
)
)
;
}
else
{
new_rep
=
reinterpret_cast
<
Rep
*
>
(
Arena
:
:
CreateArray
<
char
>
(
arena
bytes
)
)
;
}
new_rep
-
>
arena
=
arena
;
int
old_total_size
=
total_size_
;
total_size_
=
new_size
;
arena_or_elements_
=
new_rep
-
>
elements
;
Element
*
e
=
&
elements
(
)
[
0
]
;
Element
*
limit
=
e
+
total_size_
;
for
(
;
e
<
limit
;
e
+
+
)
{
new
(
e
)
Element
;
}
if
(
current_size_
>
0
)
{
MoveArray
(
&
elements
(
)
[
0
]
old_rep
-
>
elements
current_size_
)
;
}
InternalDeallocate
(
old_rep
old_total_size
)
;
}
template
<
typename
Element
>
inline
void
RepeatedField
<
Element
>
:
:
Truncate
(
int
new_size
)
{
GOOGLE_DCHECK_LE
(
new_size
current_size_
)
;
if
(
current_size_
>
0
)
{
current_size_
=
new_size
;
}
}
template
<
typename
Element
>
inline
void
RepeatedField
<
Element
>
:
:
MoveArray
(
Element
*
to
Element
*
from
int
array_size
)
{
CopyArray
(
to
from
array_size
)
;
}
template
<
typename
Element
>
inline
void
RepeatedField
<
Element
>
:
:
CopyArray
(
Element
*
to
const
Element
*
from
int
array_size
)
{
internal
:
:
ElementCopier
<
Element
>
(
)
(
to
from
array_size
)
;
}
namespace
internal
{
template
<
typename
Element
bool
HasTrivialCopy
>
void
ElementCopier
<
Element
HasTrivialCopy
>
:
:
operator
(
)
(
Element
*
to
const
Element
*
from
int
array_size
)
{
std
:
:
copy
(
from
from
+
array_size
to
)
;
}
template
<
typename
Element
>
struct
ElementCopier
<
Element
true
>
{
void
operator
(
)
(
Element
*
to
const
Element
*
from
int
array_size
)
{
memcpy
(
to
from
static_cast
<
size_t
>
(
array_size
)
*
sizeof
(
Element
)
)
;
}
}
;
}
namespace
internal
{
inline
RepeatedPtrFieldBase
:
:
RepeatedPtrFieldBase
(
)
:
arena_
(
NULL
)
current_size_
(
0
)
total_size_
(
0
)
rep_
(
NULL
)
{
}
inline
RepeatedPtrFieldBase
:
:
RepeatedPtrFieldBase
(
Arena
*
arena
)
:
arena_
(
arena
)
current_size_
(
0
)
total_size_
(
0
)
rep_
(
NULL
)
{
}
template
<
typename
TypeHandler
>
void
RepeatedPtrFieldBase
:
:
Destroy
(
)
{
if
(
rep_
!
=
NULL
&
&
arena_
=
=
NULL
)
{
int
n
=
rep_
-
>
allocated_size
;
void
*
const
*
elements
=
rep_
-
>
elements
;
for
(
int
i
=
0
;
i
<
n
;
i
+
+
)
{
TypeHandler
:
:
Delete
(
cast
<
TypeHandler
>
(
elements
[
i
]
)
NULL
)
;
}
#
if
defined
(
__GXX_DELETE_WITH_SIZE__
)
|
|
defined
(
__cpp_sized_deallocation
)
const
size_t
size
=
total_size_
*
sizeof
(
elements
[
0
]
)
+
kRepHeaderSize
;
:
:
operator
delete
(
static_cast
<
void
*
>
(
rep_
)
size
)
;
#
else
:
:
operator
delete
(
static_cast
<
void
*
>
(
rep_
)
)
;
#
endif
}
rep_
=
NULL
;
}
template
<
typename
TypeHandler
>
inline
void
RepeatedPtrFieldBase
:
:
Swap
(
RepeatedPtrFieldBase
*
other
)
{
if
(
other
-
>
GetArenaNoVirtual
(
)
=
=
GetArenaNoVirtual
(
)
)
{
InternalSwap
(
other
)
;
}
else
{
SwapFallback
<
TypeHandler
>
(
other
)
;
}
}
template
<
typename
TypeHandler
>
void
RepeatedPtrFieldBase
:
:
SwapFallback
(
RepeatedPtrFieldBase
*
other
)
{
GOOGLE_DCHECK
(
other
-
>
GetArenaNoVirtual
(
)
!
=
GetArenaNoVirtual
(
)
)
;
RepeatedPtrFieldBase
temp
(
other
-
>
GetArenaNoVirtual
(
)
)
;
temp
.
MergeFrom
<
TypeHandler
>
(
*
this
)
;
this
-
>
Clear
<
TypeHandler
>
(
)
;
this
-
>
MergeFrom
<
TypeHandler
>
(
*
other
)
;
other
-
>
Clear
<
TypeHandler
>
(
)
;
other
-
>
InternalSwap
(
&
temp
)
;
temp
.
Destroy
<
TypeHandler
>
(
)
;
}
inline
bool
RepeatedPtrFieldBase
:
:
empty
(
)
const
{
return
current_size_
=
=
0
;
}
inline
int
RepeatedPtrFieldBase
:
:
size
(
)
const
{
return
current_size_
;
}
template
<
typename
TypeHandler
>
inline
const
typename
TypeHandler
:
:
Type
&
RepeatedPtrFieldBase
:
:
Get
(
int
index
)
const
{
GOOGLE_DCHECK_GE
(
index
0
)
;
GOOGLE_DCHECK_LT
(
index
current_size_
)
;
return
*
cast
<
TypeHandler
>
(
rep_
-
>
elements
[
index
]
)
;
}
template
<
typename
TypeHandler
>
inline
const
typename
TypeHandler
:
:
Type
&
RepeatedPtrFieldBase
:
:
at
(
int
index
)
const
{
GOOGLE_CHECK_GE
(
index
0
)
;
GOOGLE_CHECK_LT
(
index
current_size_
)
;
return
*
cast
<
TypeHandler
>
(
rep_
-
>
elements
[
index
]
)
;
}
template
<
typename
TypeHandler
>
inline
typename
TypeHandler
:
:
Type
&
RepeatedPtrFieldBase
:
:
at
(
int
index
)
{
GOOGLE_CHECK_GE
(
index
0
)
;
GOOGLE_CHECK_LT
(
index
current_size_
)
;
return
*
cast
<
TypeHandler
>
(
rep_
-
>
elements
[
index
]
)
;
}
template
<
typename
TypeHandler
>
inline
typename
TypeHandler
:
:
Type
*
RepeatedPtrFieldBase
:
:
Mutable
(
int
index
)
{
GOOGLE_DCHECK_GE
(
index
0
)
;
GOOGLE_DCHECK_LT
(
index
current_size_
)
;
return
cast
<
TypeHandler
>
(
rep_
-
>
elements
[
index
]
)
;
}
template
<
typename
TypeHandler
>
inline
void
RepeatedPtrFieldBase
:
:
Delete
(
int
index
)
{
GOOGLE_DCHECK_GE
(
index
0
)
;
GOOGLE_DCHECK_LT
(
index
current_size_
)
;
TypeHandler
:
:
Delete
(
cast
<
TypeHandler
>
(
rep_
-
>
elements
[
index
]
)
arena_
)
;
}
template
<
typename
TypeHandler
>
inline
typename
TypeHandler
:
:
Type
*
RepeatedPtrFieldBase
:
:
Add
(
typename
TypeHandler
:
:
Type
*
prototype
)
{
if
(
rep_
!
=
NULL
&
&
current_size_
<
rep_
-
>
allocated_size
)
{
return
cast
<
TypeHandler
>
(
rep_
-
>
elements
[
current_size_
+
+
]
)
;
}
if
(
!
rep_
|
|
rep_
-
>
allocated_size
=
=
total_size_
)
{
Reserve
(
total_size_
+
1
)
;
}
+
+
rep_
-
>
allocated_size
;
typename
TypeHandler
:
:
Type
*
result
=
TypeHandler
:
:
NewFromPrototype
(
prototype
arena_
)
;
rep_
-
>
elements
[
current_size_
+
+
]
=
result
;
return
result
;
}
template
<
typename
TypeHandler
typename
std
:
:
enable_if
<
TypeHandler
:
:
Movable
:
:
value
>
:
:
type
*
>
inline
void
RepeatedPtrFieldBase
:
:
Add
(
typename
TypeHandler
:
:
Type
&
&
value
)
{
if
(
rep_
!
=
NULL
&
&
current_size_
<
rep_
-
>
allocated_size
)
{
*
cast
<
TypeHandler
>
(
rep_
-
>
elements
[
current_size_
+
+
]
)
=
std
:
:
move
(
value
)
;
return
;
}
if
(
!
rep_
|
|
rep_
-
>
allocated_size
=
=
total_size_
)
{
Reserve
(
total_size_
+
1
)
;
}
+
+
rep_
-
>
allocated_size
;
typename
TypeHandler
:
:
Type
*
result
=
TypeHandler
:
:
New
(
arena_
std
:
:
move
(
value
)
)
;
rep_
-
>
elements
[
current_size_
+
+
]
=
result
;
}
template
<
typename
TypeHandler
>
inline
void
RepeatedPtrFieldBase
:
:
RemoveLast
(
)
{
GOOGLE_DCHECK_GT
(
current_size_
0
)
;
TypeHandler
:
:
Clear
(
cast
<
TypeHandler
>
(
rep_
-
>
elements
[
-
-
current_size_
]
)
)
;
}
template
<
typename
TypeHandler
>
void
RepeatedPtrFieldBase
:
:
Clear
(
)
{
const
int
n
=
current_size_
;
GOOGLE_DCHECK_GE
(
n
0
)
;
if
(
n
>
0
)
{
void
*
const
*
elements
=
rep_
-
>
elements
;
int
i
=
0
;
do
{
TypeHandler
:
:
Clear
(
cast
<
TypeHandler
>
(
elements
[
i
+
+
]
)
)
;
}
while
(
i
<
n
)
;
current_size_
=
0
;
}
}
template
<
typename
TypeHandler
>
inline
void
RepeatedPtrFieldBase
:
:
MergeFrom
(
const
RepeatedPtrFieldBase
&
other
)
{
GOOGLE_DCHECK_NE
(
&
other
this
)
;
if
(
other
.
current_size_
=
=
0
)
return
;
MergeFromInternal
(
other
&
RepeatedPtrFieldBase
:
:
MergeFromInnerLoop
<
TypeHandler
>
)
;
}
inline
void
RepeatedPtrFieldBase
:
:
MergeFromInternal
(
const
RepeatedPtrFieldBase
&
other
void
(
RepeatedPtrFieldBase
:
:
*
inner_loop
)
(
void
*
*
void
*
*
int
int
)
)
{
int
other_size
=
other
.
current_size_
;
void
*
*
other_elements
=
other
.
rep_
-
>
elements
;
void
*
*
new_elements
=
InternalExtend
(
other_size
)
;
int
allocated_elems
=
rep_
-
>
allocated_size
-
current_size_
;
(
this
-
>
*
inner_loop
)
(
new_elements
other_elements
other_size
allocated_elems
)
;
current_size_
+
=
other_size
;
if
(
rep_
-
>
allocated_size
<
current_size_
)
{
rep_
-
>
allocated_size
=
current_size_
;
}
}
template
<
typename
TypeHandler
>
void
RepeatedPtrFieldBase
:
:
MergeFromInnerLoop
(
void
*
*
our_elems
void
*
*
other_elems
int
length
int
already_allocated
)
{
for
(
int
i
=
0
;
i
<
already_allocated
&
&
i
<
length
;
i
+
+
)
{
typename
TypeHandler
:
:
Type
*
other_elem
=
reinterpret_cast
<
typename
TypeHandler
:
:
Type
*
>
(
other_elems
[
i
]
)
;
typename
TypeHandler
:
:
Type
*
new_elem
=
reinterpret_cast
<
typename
TypeHandler
:
:
Type
*
>
(
our_elems
[
i
]
)
;
TypeHandler
:
:
Merge
(
*
other_elem
new_elem
)
;
}
Arena
*
arena
=
GetArenaNoVirtual
(
)
;
for
(
int
i
=
already_allocated
;
i
<
length
;
i
+
+
)
{
typename
TypeHandler
:
:
Type
*
other_elem
=
reinterpret_cast
<
typename
TypeHandler
:
:
Type
*
>
(
other_elems
[
i
]
)
;
typename
TypeHandler
:
:
Type
*
new_elem
=
TypeHandler
:
:
NewFromPrototype
(
other_elem
arena
)
;
TypeHandler
:
:
Merge
(
*
other_elem
new_elem
)
;
our_elems
[
i
]
=
new_elem
;
}
}
template
<
typename
TypeHandler
>
inline
void
RepeatedPtrFieldBase
:
:
CopyFrom
(
const
RepeatedPtrFieldBase
&
other
)
{
if
(
&
other
=
=
this
)
return
;
RepeatedPtrFieldBase
:
:
Clear
<
TypeHandler
>
(
)
;
RepeatedPtrFieldBase
:
:
MergeFrom
<
TypeHandler
>
(
other
)
;
}
inline
int
RepeatedPtrFieldBase
:
:
Capacity
(
)
const
{
return
total_size_
;
}
inline
void
*
const
*
RepeatedPtrFieldBase
:
:
raw_data
(
)
const
{
return
rep_
?
rep_
-
>
elements
:
NULL
;
}
inline
void
*
*
RepeatedPtrFieldBase
:
:
raw_mutable_data
(
)
const
{
return
rep_
?
const_cast
<
void
*
*
>
(
rep_
-
>
elements
)
:
NULL
;
}
template
<
typename
TypeHandler
>
inline
typename
TypeHandler
:
:
Type
*
*
RepeatedPtrFieldBase
:
:
mutable_data
(
)
{
return
reinterpret_cast
<
typename
TypeHandler
:
:
Type
*
*
>
(
raw_mutable_data
(
)
)
;
}
template
<
typename
TypeHandler
>
inline
const
typename
TypeHandler
:
:
Type
*
const
*
RepeatedPtrFieldBase
:
:
data
(
)
const
{
return
reinterpret_cast
<
const
typename
TypeHandler
:
:
Type
*
const
*
>
(
raw_data
(
)
)
;
}
inline
void
RepeatedPtrFieldBase
:
:
SwapElements
(
int
index1
int
index2
)
{
using
std
:
:
swap
;
swap
(
rep_
-
>
elements
[
index1
]
rep_
-
>
elements
[
index2
]
)
;
}
template
<
typename
TypeHandler
>
inline
size_t
RepeatedPtrFieldBase
:
:
SpaceUsedExcludingSelfLong
(
)
const
{
size_t
allocated_bytes
=
static_cast
<
size_t
>
(
total_size_
)
*
sizeof
(
void
*
)
;
if
(
rep_
!
=
NULL
)
{
for
(
int
i
=
0
;
i
<
rep_
-
>
allocated_size
;
+
+
i
)
{
allocated_bytes
+
=
TypeHandler
:
:
SpaceUsedLong
(
*
cast
<
TypeHandler
>
(
rep_
-
>
elements
[
i
]
)
)
;
}
allocated_bytes
+
=
kRepHeaderSize
;
}
return
allocated_bytes
;
}
template
<
typename
TypeHandler
>
inline
typename
TypeHandler
:
:
Type
*
RepeatedPtrFieldBase
:
:
AddFromCleared
(
)
{
if
(
rep_
!
=
NULL
&
&
current_size_
<
rep_
-
>
allocated_size
)
{
return
cast
<
TypeHandler
>
(
rep_
-
>
elements
[
current_size_
+
+
]
)
;
}
else
{
return
NULL
;
}
}
template
<
typename
TypeHandler
>
void
RepeatedPtrFieldBase
:
:
AddAllocatedInternal
(
typename
TypeHandler
:
:
Type
*
value
std
:
:
true_type
)
{
Arena
*
element_arena
=
reinterpret_cast
<
Arena
*
>
(
TypeHandler
:
:
GetMaybeArenaPointer
(
value
)
)
;
Arena
*
arena
=
GetArenaNoVirtual
(
)
;
if
(
arena
=
=
element_arena
&
&
rep_
&
&
rep_
-
>
allocated_size
<
total_size_
)
{
void
*
*
elems
=
rep_
-
>
elements
;
if
(
current_size_
<
rep_
-
>
allocated_size
)
{
elems
[
rep_
-
>
allocated_size
]
=
elems
[
current_size_
]
;
}
elems
[
current_size_
]
=
value
;
current_size_
=
current_size_
+
1
;
rep_
-
>
allocated_size
=
rep_
-
>
allocated_size
+
1
;
}
else
{
AddAllocatedSlowWithCopy
<
TypeHandler
>
(
value
TypeHandler
:
:
GetArena
(
value
)
arena
)
;
}
}
template
<
typename
TypeHandler
>
void
RepeatedPtrFieldBase
:
:
AddAllocatedSlowWithCopy
(
typename
TypeHandler
:
:
Type
*
value
Arena
*
value_arena
Arena
*
my_arena
)
{
if
(
my_arena
!
=
NULL
&
&
value_arena
=
=
NULL
)
{
my_arena
-
>
Own
(
value
)
;
}
else
if
(
my_arena
!
=
value_arena
)
{
typename
TypeHandler
:
:
Type
*
new_value
=
TypeHandler
:
:
NewFromPrototype
(
value
my_arena
)
;
TypeHandler
:
:
Merge
(
*
value
new_value
)
;
TypeHandler
:
:
Delete
(
value
value_arena
)
;
value
=
new_value
;
}
UnsafeArenaAddAllocated
<
TypeHandler
>
(
value
)
;
}
template
<
typename
TypeHandler
>
void
RepeatedPtrFieldBase
:
:
AddAllocatedInternal
(
typename
TypeHandler
:
:
Type
*
value
std
:
:
false_type
)
{
if
(
rep_
&
&
rep_
-
>
allocated_size
<
total_size_
)
{
void
*
*
elems
=
rep_
-
>
elements
;
if
(
current_size_
<
rep_
-
>
allocated_size
)
{
elems
[
rep_
-
>
allocated_size
]
=
elems
[
current_size_
]
;
}
elems
[
current_size_
]
=
value
;
current_size_
=
current_size_
+
1
;
+
+
rep_
-
>
allocated_size
;
}
else
{
UnsafeArenaAddAllocated
<
TypeHandler
>
(
value
)
;
}
}
template
<
typename
TypeHandler
>
void
RepeatedPtrFieldBase
:
:
UnsafeArenaAddAllocated
(
typename
TypeHandler
:
:
Type
*
value
)
{
if
(
!
rep_
|
|
current_size_
=
=
total_size_
)
{
Reserve
(
total_size_
+
1
)
;
+
+
rep_
-
>
allocated_size
;
}
else
if
(
rep_
-
>
allocated_size
=
=
total_size_
)
{
TypeHandler
:
:
Delete
(
cast
<
TypeHandler
>
(
rep_
-
>
elements
[
current_size_
]
)
arena_
)
;
}
else
if
(
current_size_
<
rep_
-
>
allocated_size
)
{
rep_
-
>
elements
[
rep_
-
>
allocated_size
]
=
rep_
-
>
elements
[
current_size_
]
;
+
+
rep_
-
>
allocated_size
;
}
else
{
+
+
rep_
-
>
allocated_size
;
}
rep_
-
>
elements
[
current_size_
+
+
]
=
value
;
}
template
<
typename
TypeHandler
>
inline
typename
TypeHandler
:
:
Type
*
RepeatedPtrFieldBase
:
:
ReleaseLastInternal
(
std
:
:
true_type
)
{
typename
TypeHandler
:
:
Type
*
result
=
UnsafeArenaReleaseLast
<
TypeHandler
>
(
)
;
Arena
*
arena
=
GetArenaNoVirtual
(
)
;
if
(
arena
=
=
NULL
)
{
return
result
;
}
else
{
typename
TypeHandler
:
:
Type
*
new_result
=
TypeHandler
:
:
NewFromPrototype
(
result
NULL
)
;
TypeHandler
:
:
Merge
(
*
result
new_result
)
;
return
new_result
;
}
}
template
<
typename
TypeHandler
>
inline
typename
TypeHandler
:
:
Type
*
RepeatedPtrFieldBase
:
:
ReleaseLastInternal
(
std
:
:
false_type
)
{
GOOGLE_DCHECK
(
GetArenaNoVirtual
(
)
=
=
NULL
)
<
<
"
ReleaseLast
(
)
called
on
a
RepeatedPtrField
that
is
on
an
arena
"
<
<
"
with
a
type
that
does
not
implement
MergeFrom
.
This
is
unsafe
;
"
<
<
"
please
implement
MergeFrom
for
your
type
.
"
;
return
UnsafeArenaReleaseLast
<
TypeHandler
>
(
)
;
}
template
<
typename
TypeHandler
>
inline
typename
TypeHandler
:
:
Type
*
RepeatedPtrFieldBase
:
:
UnsafeArenaReleaseLast
(
)
{
GOOGLE_DCHECK_GT
(
current_size_
0
)
;
typename
TypeHandler
:
:
Type
*
result
=
cast
<
TypeHandler
>
(
rep_
-
>
elements
[
-
-
current_size_
]
)
;
-
-
rep_
-
>
allocated_size
;
if
(
current_size_
<
rep_
-
>
allocated_size
)
{
rep_
-
>
elements
[
current_size_
]
=
rep_
-
>
elements
[
rep_
-
>
allocated_size
]
;
}
return
result
;
}
inline
int
RepeatedPtrFieldBase
:
:
ClearedCount
(
)
const
{
return
rep_
?
(
rep_
-
>
allocated_size
-
current_size_
)
:
0
;
}
template
<
typename
TypeHandler
>
inline
void
RepeatedPtrFieldBase
:
:
AddCleared
(
typename
TypeHandler
:
:
Type
*
value
)
{
GOOGLE_DCHECK
(
GetArenaNoVirtual
(
)
=
=
NULL
)
<
<
"
AddCleared
(
)
can
only
be
used
on
a
RepeatedPtrField
not
on
an
arena
.
"
;
GOOGLE_DCHECK
(
TypeHandler
:
:
GetArena
(
value
)
=
=
NULL
)
<
<
"
AddCleared
(
)
can
only
accept
values
not
on
an
arena
.
"
;
if
(
!
rep_
|
|
rep_
-
>
allocated_size
=
=
total_size_
)
{
Reserve
(
total_size_
+
1
)
;
}
rep_
-
>
elements
[
rep_
-
>
allocated_size
+
+
]
=
value
;
}
template
<
typename
TypeHandler
>
inline
typename
TypeHandler
:
:
Type
*
RepeatedPtrFieldBase
:
:
ReleaseCleared
(
)
{
GOOGLE_DCHECK
(
GetArenaNoVirtual
(
)
=
=
NULL
)
<
<
"
ReleaseCleared
(
)
can
only
be
used
on
a
RepeatedPtrField
not
on
"
<
<
"
an
arena
.
"
;
GOOGLE_DCHECK
(
GetArenaNoVirtual
(
)
=
=
NULL
)
;
GOOGLE_DCHECK
(
rep_
!
=
NULL
)
;
GOOGLE_DCHECK_GT
(
rep_
-
>
allocated_size
current_size_
)
;
return
cast
<
TypeHandler
>
(
rep_
-
>
elements
[
-
-
rep_
-
>
allocated_size
]
)
;
}
}
template
<
typename
Element
>
class
RepeatedPtrField
<
Element
>
:
:
TypeHandler
:
public
internal
:
:
GenericTypeHandler
<
Element
>
{
}
;
template
<
>
class
RepeatedPtrField
<
std
:
:
string
>
:
:
TypeHandler
:
public
internal
:
:
StringTypeHandler
{
}
;
template
<
typename
Element
>
inline
RepeatedPtrField
<
Element
>
:
:
RepeatedPtrField
(
)
:
RepeatedPtrFieldBase
(
)
{
}
template
<
typename
Element
>
inline
RepeatedPtrField
<
Element
>
:
:
RepeatedPtrField
(
Arena
*
arena
)
:
RepeatedPtrFieldBase
(
arena
)
{
}
template
<
typename
Element
>
inline
RepeatedPtrField
<
Element
>
:
:
RepeatedPtrField
(
const
RepeatedPtrField
&
other
)
:
RepeatedPtrFieldBase
(
)
{
MergeFrom
(
other
)
;
}
template
<
typename
Element
>
template
<
typename
Iter
>
inline
RepeatedPtrField
<
Element
>
:
:
RepeatedPtrField
(
Iter
begin
const
Iter
&
end
)
{
int
reserve
=
internal
:
:
CalculateReserve
(
begin
end
)
;
if
(
reserve
!
=
-
1
)
{
Reserve
(
reserve
)
;
}
for
(
;
begin
!
=
end
;
+
+
begin
)
{
*
Add
(
)
=
*
begin
;
}
}
template
<
typename
Element
>
RepeatedPtrField
<
Element
>
:
:
~
RepeatedPtrField
(
)
{
Destroy
<
TypeHandler
>
(
)
;
}
template
<
typename
Element
>
inline
RepeatedPtrField
<
Element
>
&
RepeatedPtrField
<
Element
>
:
:
operator
=
(
const
RepeatedPtrField
&
other
)
{
if
(
this
!
=
&
other
)
CopyFrom
(
other
)
;
return
*
this
;
}
template
<
typename
Element
>
inline
RepeatedPtrField
<
Element
>
:
:
RepeatedPtrField
(
RepeatedPtrField
&
&
other
)
noexcept
:
RepeatedPtrField
(
)
{
if
(
other
.
GetArenaNoVirtual
(
)
)
{
CopyFrom
(
other
)
;
}
else
{
InternalSwap
(
&
other
)
;
}
}
template
<
typename
Element
>
inline
RepeatedPtrField
<
Element
>
&
RepeatedPtrField
<
Element
>
:
:
operator
=
(
RepeatedPtrField
&
&
other
)
noexcept
{
if
(
this
!
=
&
other
)
{
if
(
this
-
>
GetArenaNoVirtual
(
)
!
=
other
.
GetArenaNoVirtual
(
)
)
{
CopyFrom
(
other
)
;
}
else
{
InternalSwap
(
&
other
)
;
}
}
return
*
this
;
}
template
<
typename
Element
>
inline
bool
RepeatedPtrField
<
Element
>
:
:
empty
(
)
const
{
return
RepeatedPtrFieldBase
:
:
empty
(
)
;
}
template
<
typename
Element
>
inline
int
RepeatedPtrField
<
Element
>
:
:
size
(
)
const
{
return
RepeatedPtrFieldBase
:
:
size
(
)
;
}
template
<
typename
Element
>
inline
const
Element
&
RepeatedPtrField
<
Element
>
:
:
Get
(
int
index
)
const
{
return
RepeatedPtrFieldBase
:
:
Get
<
TypeHandler
>
(
index
)
;
}
template
<
typename
Element
>
inline
const
Element
&
RepeatedPtrField
<
Element
>
:
:
at
(
int
index
)
const
{
return
RepeatedPtrFieldBase
:
:
at
<
TypeHandler
>
(
index
)
;
}
template
<
typename
Element
>
inline
Element
&
RepeatedPtrField
<
Element
>
:
:
at
(
int
index
)
{
return
RepeatedPtrFieldBase
:
:
at
<
TypeHandler
>
(
index
)
;
}
template
<
typename
Element
>
inline
Element
*
RepeatedPtrField
<
Element
>
:
:
Mutable
(
int
index
)
{
return
RepeatedPtrFieldBase
:
:
Mutable
<
TypeHandler
>
(
index
)
;
}
template
<
typename
Element
>
inline
Element
*
RepeatedPtrField
<
Element
>
:
:
Add
(
)
{
return
RepeatedPtrFieldBase
:
:
Add
<
TypeHandler
>
(
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
Add
(
Element
&
&
value
)
{
RepeatedPtrFieldBase
:
:
Add
<
TypeHandler
>
(
std
:
:
move
(
value
)
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
RemoveLast
(
)
{
RepeatedPtrFieldBase
:
:
RemoveLast
<
TypeHandler
>
(
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
DeleteSubrange
(
int
start
int
num
)
{
GOOGLE_DCHECK_GE
(
start
0
)
;
GOOGLE_DCHECK_GE
(
num
0
)
;
GOOGLE_DCHECK_LE
(
start
+
num
size
(
)
)
;
for
(
int
i
=
0
;
i
<
num
;
+
+
i
)
{
RepeatedPtrFieldBase
:
:
Delete
<
TypeHandler
>
(
start
+
i
)
;
}
ExtractSubrange
(
start
num
NULL
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
ExtractSubrange
(
int
start
int
num
Element
*
*
elements
)
{
typename
internal
:
:
TypeImplementsMergeBehavior
<
typename
TypeHandler
:
:
Type
>
:
:
type
t
;
ExtractSubrangeInternal
(
start
num
elements
t
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
ExtractSubrangeInternal
(
int
start
int
num
Element
*
*
elements
std
:
:
true_type
)
{
GOOGLE_DCHECK_GE
(
start
0
)
;
GOOGLE_DCHECK_GE
(
num
0
)
;
GOOGLE_DCHECK_LE
(
start
+
num
size
(
)
)
;
if
(
num
>
0
)
{
if
(
elements
!
=
NULL
)
{
if
(
GetArenaNoVirtual
(
)
!
=
NULL
)
{
for
(
int
i
=
0
;
i
<
num
;
+
+
i
)
{
Element
*
element
=
RepeatedPtrFieldBase
:
:
Mutable
<
TypeHandler
>
(
i
+
start
)
;
typename
TypeHandler
:
:
Type
*
new_value
=
TypeHandler
:
:
NewFromPrototype
(
element
NULL
)
;
TypeHandler
:
:
Merge
(
*
element
new_value
)
;
elements
[
i
]
=
new_value
;
}
}
else
{
for
(
int
i
=
0
;
i
<
num
;
+
+
i
)
{
elements
[
i
]
=
RepeatedPtrFieldBase
:
:
Mutable
<
TypeHandler
>
(
i
+
start
)
;
}
}
}
CloseGap
(
start
num
)
;
}
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
ExtractSubrangeInternal
(
int
start
int
num
Element
*
*
elements
std
:
:
false_type
)
{
GOOGLE_DCHECK
(
GetArenaNoVirtual
(
)
=
=
NULL
)
<
<
"
ExtractSubrange
(
)
when
arena
is
non
-
NULL
is
only
supported
when
"
<
<
"
the
Element
type
supplies
a
MergeFrom
(
)
operation
to
make
copies
.
"
;
UnsafeArenaExtractSubrange
(
start
num
elements
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
UnsafeArenaExtractSubrange
(
int
start
int
num
Element
*
*
elements
)
{
GOOGLE_DCHECK_GE
(
start
0
)
;
GOOGLE_DCHECK_GE
(
num
0
)
;
GOOGLE_DCHECK_LE
(
start
+
num
size
(
)
)
;
if
(
num
>
0
)
{
if
(
elements
!
=
NULL
)
{
for
(
int
i
=
0
;
i
<
num
;
+
+
i
)
{
elements
[
i
]
=
RepeatedPtrFieldBase
:
:
Mutable
<
TypeHandler
>
(
i
+
start
)
;
}
}
CloseGap
(
start
num
)
;
}
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
Clear
(
)
{
RepeatedPtrFieldBase
:
:
Clear
<
TypeHandler
>
(
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
MergeFrom
(
const
RepeatedPtrField
&
other
)
{
RepeatedPtrFieldBase
:
:
MergeFrom
<
TypeHandler
>
(
other
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
CopyFrom
(
const
RepeatedPtrField
&
other
)
{
RepeatedPtrFieldBase
:
:
CopyFrom
<
TypeHandler
>
(
other
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedPtrField
<
Element
>
:
:
iterator
RepeatedPtrField
<
Element
>
:
:
erase
(
const_iterator
position
)
{
return
erase
(
position
position
+
1
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedPtrField
<
Element
>
:
:
iterator
RepeatedPtrField
<
Element
>
:
:
erase
(
const_iterator
first
const_iterator
last
)
{
size_type
pos_offset
=
std
:
:
distance
(
cbegin
(
)
first
)
;
size_type
last_offset
=
std
:
:
distance
(
cbegin
(
)
last
)
;
DeleteSubrange
(
pos_offset
last_offset
-
pos_offset
)
;
return
begin
(
)
+
pos_offset
;
}
template
<
typename
Element
>
inline
Element
*
*
RepeatedPtrField
<
Element
>
:
:
mutable_data
(
)
{
return
RepeatedPtrFieldBase
:
:
mutable_data
<
TypeHandler
>
(
)
;
}
template
<
typename
Element
>
inline
const
Element
*
const
*
RepeatedPtrField
<
Element
>
:
:
data
(
)
const
{
return
RepeatedPtrFieldBase
:
:
data
<
TypeHandler
>
(
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
Swap
(
RepeatedPtrField
*
other
)
{
if
(
this
=
=
other
)
return
;
RepeatedPtrFieldBase
:
:
Swap
<
TypeHandler
>
(
other
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
UnsafeArenaSwap
(
RepeatedPtrField
*
other
)
{
if
(
this
=
=
other
)
return
;
RepeatedPtrFieldBase
:
:
InternalSwap
(
other
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
SwapElements
(
int
index1
int
index2
)
{
RepeatedPtrFieldBase
:
:
SwapElements
(
index1
index2
)
;
}
template
<
typename
Element
>
inline
Arena
*
RepeatedPtrField
<
Element
>
:
:
GetArenaNoVirtual
(
)
const
{
return
RepeatedPtrFieldBase
:
:
GetArenaNoVirtual
(
)
;
}
template
<
typename
Element
>
inline
size_t
RepeatedPtrField
<
Element
>
:
:
SpaceUsedExcludingSelfLong
(
)
const
{
return
RepeatedPtrFieldBase
:
:
SpaceUsedExcludingSelfLong
<
TypeHandler
>
(
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
AddAllocated
(
Element
*
value
)
{
RepeatedPtrFieldBase
:
:
AddAllocated
<
TypeHandler
>
(
value
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
UnsafeArenaAddAllocated
(
Element
*
value
)
{
RepeatedPtrFieldBase
:
:
UnsafeArenaAddAllocated
<
TypeHandler
>
(
value
)
;
}
template
<
typename
Element
>
inline
Element
*
RepeatedPtrField
<
Element
>
:
:
ReleaseLast
(
)
{
return
RepeatedPtrFieldBase
:
:
ReleaseLast
<
TypeHandler
>
(
)
;
}
template
<
typename
Element
>
inline
Element
*
RepeatedPtrField
<
Element
>
:
:
UnsafeArenaReleaseLast
(
)
{
return
RepeatedPtrFieldBase
:
:
UnsafeArenaReleaseLast
<
TypeHandler
>
(
)
;
}
template
<
typename
Element
>
inline
int
RepeatedPtrField
<
Element
>
:
:
ClearedCount
(
)
const
{
return
RepeatedPtrFieldBase
:
:
ClearedCount
(
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
AddCleared
(
Element
*
value
)
{
return
RepeatedPtrFieldBase
:
:
AddCleared
<
TypeHandler
>
(
value
)
;
}
template
<
typename
Element
>
inline
Element
*
RepeatedPtrField
<
Element
>
:
:
ReleaseCleared
(
)
{
return
RepeatedPtrFieldBase
:
:
ReleaseCleared
<
TypeHandler
>
(
)
;
}
template
<
typename
Element
>
inline
void
RepeatedPtrField
<
Element
>
:
:
Reserve
(
int
new_size
)
{
return
RepeatedPtrFieldBase
:
:
Reserve
(
new_size
)
;
}
template
<
typename
Element
>
inline
int
RepeatedPtrField
<
Element
>
:
:
Capacity
(
)
const
{
return
RepeatedPtrFieldBase
:
:
Capacity
(
)
;
}
namespace
internal
{
template
<
typename
Element
>
class
RepeatedPtrIterator
{
public
:
using
iterator
=
RepeatedPtrIterator
<
Element
>
;
using
iterator_category
=
std
:
:
random_access_iterator_tag
;
using
value_type
=
typename
std
:
:
remove_const
<
Element
>
:
:
type
;
using
difference_type
=
std
:
:
ptrdiff_t
;
using
pointer
=
Element
*
;
using
reference
=
Element
&
;
RepeatedPtrIterator
(
)
:
it_
(
NULL
)
{
}
explicit
RepeatedPtrIterator
(
void
*
const
*
it
)
:
it_
(
it
)
{
}
template
<
typename
OtherElement
>
RepeatedPtrIterator
(
const
RepeatedPtrIterator
<
OtherElement
>
&
other
)
:
it_
(
other
.
it_
)
{
if
(
false
)
{
implicit_cast
<
Element
*
>
(
static_cast
<
OtherElement
*
>
(
nullptr
)
)
;
}
}
reference
operator
*
(
)
const
{
return
*
reinterpret_cast
<
Element
*
>
(
*
it_
)
;
}
pointer
operator
-
>
(
)
const
{
return
&
(
operator
*
(
)
)
;
}
iterator
&
operator
+
+
(
)
{
+
+
it_
;
return
*
this
;
}
iterator
operator
+
+
(
int
)
{
return
iterator
(
it_
+
+
)
;
}
iterator
&
operator
-
-
(
)
{
-
-
it_
;
return
*
this
;
}
iterator
operator
-
-
(
int
)
{
return
iterator
(
it_
-
-
)
;
}
bool
operator
=
=
(
const
iterator
&
x
)
const
{
return
it_
=
=
x
.
it_
;
}
bool
operator
!
=
(
const
iterator
&
x
)
const
{
return
it_
!
=
x
.
it_
;
}
bool
operator
<
(
const
iterator
&
x
)
const
{
return
it_
<
x
.
it_
;
}
bool
operator
<
=
(
const
iterator
&
x
)
const
{
return
it_
<
=
x
.
it_
;
}
bool
operator
>
(
const
iterator
&
x
)
const
{
return
it_
>
x
.
it_
;
}
bool
operator
>
=
(
const
iterator
&
x
)
const
{
return
it_
>
=
x
.
it_
;
}
iterator
&
operator
+
=
(
difference_type
d
)
{
it_
+
=
d
;
return
*
this
;
}
friend
iterator
operator
+
(
iterator
it
const
difference_type
d
)
{
it
+
=
d
;
return
it
;
}
friend
iterator
operator
+
(
const
difference_type
d
iterator
it
)
{
it
+
=
d
;
return
it
;
}
iterator
&
operator
-
=
(
difference_type
d
)
{
it_
-
=
d
;
return
*
this
;
}
friend
iterator
operator
-
(
iterator
it
difference_type
d
)
{
it
-
=
d
;
return
it
;
}
reference
operator
[
]
(
difference_type
d
)
const
{
return
*
(
*
this
+
d
)
;
}
difference_type
operator
-
(
const
iterator
&
x
)
const
{
return
it_
-
x
.
it_
;
}
private
:
template
<
typename
OtherElement
>
friend
class
RepeatedPtrIterator
;
void
*
const
*
it_
;
}
;
template
<
typename
Element
typename
VoidPtr
>
class
RepeatedPtrOverPtrsIterator
{
public
:
using
iterator
=
RepeatedPtrOverPtrsIterator
<
Element
VoidPtr
>
;
using
iterator_category
=
std
:
:
random_access_iterator_tag
;
using
value_type
=
typename
std
:
:
remove_const
<
Element
>
:
:
type
;
using
difference_type
=
std
:
:
ptrdiff_t
;
using
pointer
=
Element
*
;
using
reference
=
Element
&
;
RepeatedPtrOverPtrsIterator
(
)
:
it_
(
NULL
)
{
}
explicit
RepeatedPtrOverPtrsIterator
(
VoidPtr
*
it
)
:
it_
(
it
)
{
}
reference
operator
*
(
)
const
{
return
*
reinterpret_cast
<
Element
*
>
(
it_
)
;
}
pointer
operator
-
>
(
)
const
{
return
&
(
operator
*
(
)
)
;
}
iterator
&
operator
+
+
(
)
{
+
+
it_
;
return
*
this
;
}
iterator
operator
+
+
(
int
)
{
return
iterator
(
it_
+
+
)
;
}
iterator
&
operator
-
-
(
)
{
-
-
it_
;
return
*
this
;
}
iterator
operator
-
-
(
int
)
{
return
iterator
(
it_
-
-
)
;
}
bool
operator
=
=
(
const
iterator
&
x
)
const
{
return
it_
=
=
x
.
it_
;
}
bool
operator
!
=
(
const
iterator
&
x
)
const
{
return
it_
!
=
x
.
it_
;
}
bool
operator
<
(
const
iterator
&
x
)
const
{
return
it_
<
x
.
it_
;
}
bool
operator
<
=
(
const
iterator
&
x
)
const
{
return
it_
<
=
x
.
it_
;
}
bool
operator
>
(
const
iterator
&
x
)
const
{
return
it_
>
x
.
it_
;
}
bool
operator
>
=
(
const
iterator
&
x
)
const
{
return
it_
>
=
x
.
it_
;
}
iterator
&
operator
+
=
(
difference_type
d
)
{
it_
+
=
d
;
return
*
this
;
}
friend
iterator
operator
+
(
iterator
it
difference_type
d
)
{
it
+
=
d
;
return
it
;
}
friend
iterator
operator
+
(
difference_type
d
iterator
it
)
{
it
+
=
d
;
return
it
;
}
iterator
&
operator
-
=
(
difference_type
d
)
{
it_
-
=
d
;
return
*
this
;
}
friend
iterator
operator
-
(
iterator
it
difference_type
d
)
{
it
-
=
d
;
return
it
;
}
reference
operator
[
]
(
difference_type
d
)
const
{
return
*
(
*
this
+
d
)
;
}
difference_type
operator
-
(
const
iterator
&
x
)
const
{
return
it_
-
x
.
it_
;
}
private
:
template
<
typename
OtherElement
>
friend
class
RepeatedPtrIterator
;
VoidPtr
*
it_
;
}
;
void
RepeatedPtrFieldBase
:
:
InternalSwap
(
RepeatedPtrFieldBase
*
other
)
{
GOOGLE_DCHECK
(
this
!
=
other
)
;
GOOGLE_DCHECK
(
GetArenaNoVirtual
(
)
=
=
other
-
>
GetArenaNoVirtual
(
)
)
;
std
:
:
swap
(
rep_
other
-
>
rep_
)
;
std
:
:
swap
(
current_size_
other
-
>
current_size_
)
;
std
:
:
swap
(
total_size_
other
-
>
total_size_
)
;
}
}
template
<
typename
Element
>
inline
typename
RepeatedPtrField
<
Element
>
:
:
iterator
RepeatedPtrField
<
Element
>
:
:
begin
(
)
{
return
iterator
(
raw_data
(
)
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedPtrField
<
Element
>
:
:
const_iterator
RepeatedPtrField
<
Element
>
:
:
begin
(
)
const
{
return
iterator
(
raw_data
(
)
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedPtrField
<
Element
>
:
:
const_iterator
RepeatedPtrField
<
Element
>
:
:
cbegin
(
)
const
{
return
begin
(
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedPtrField
<
Element
>
:
:
iterator
RepeatedPtrField
<
Element
>
:
:
end
(
)
{
return
iterator
(
raw_data
(
)
+
size
(
)
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedPtrField
<
Element
>
:
:
const_iterator
RepeatedPtrField
<
Element
>
:
:
end
(
)
const
{
return
iterator
(
raw_data
(
)
+
size
(
)
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedPtrField
<
Element
>
:
:
const_iterator
RepeatedPtrField
<
Element
>
:
:
cend
(
)
const
{
return
end
(
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedPtrField
<
Element
>
:
:
pointer_iterator
RepeatedPtrField
<
Element
>
:
:
pointer_begin
(
)
{
return
pointer_iterator
(
raw_mutable_data
(
)
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedPtrField
<
Element
>
:
:
const_pointer_iterator
RepeatedPtrField
<
Element
>
:
:
pointer_begin
(
)
const
{
return
const_pointer_iterator
(
const_cast
<
const
void
*
const
*
>
(
raw_data
(
)
)
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedPtrField
<
Element
>
:
:
pointer_iterator
RepeatedPtrField
<
Element
>
:
:
pointer_end
(
)
{
return
pointer_iterator
(
raw_mutable_data
(
)
+
size
(
)
)
;
}
template
<
typename
Element
>
inline
typename
RepeatedPtrField
<
Element
>
:
:
const_pointer_iterator
RepeatedPtrField
<
Element
>
:
:
pointer_end
(
)
const
{
return
const_pointer_iterator
(
const_cast
<
const
void
*
const
*
>
(
raw_data
(
)
+
size
(
)
)
)
;
}
namespace
internal
{
template
<
typename
T
>
class
RepeatedFieldBackInsertIterator
:
public
std
:
:
iterator
<
std
:
:
output_iterator_tag
T
>
{
public
:
explicit
RepeatedFieldBackInsertIterator
(
RepeatedField
<
T
>
*
const
mutable_field
)
:
field_
(
mutable_field
)
{
}
RepeatedFieldBackInsertIterator
<
T
>
&
operator
=
(
const
T
&
value
)
{
field_
-
>
Add
(
value
)
;
return
*
this
;
}
RepeatedFieldBackInsertIterator
<
T
>
&
operator
*
(
)
{
return
*
this
;
}
RepeatedFieldBackInsertIterator
<
T
>
&
operator
+
+
(
)
{
return
*
this
;
}
RepeatedFieldBackInsertIterator
<
T
>
&
operator
+
+
(
int
)
{
return
*
this
;
}
private
:
RepeatedField
<
T
>
*
field_
;
}
;
template
<
typename
T
>
class
RepeatedPtrFieldBackInsertIterator
:
public
std
:
:
iterator
<
std
:
:
output_iterator_tag
T
>
{
public
:
RepeatedPtrFieldBackInsertIterator
(
RepeatedPtrField
<
T
>
*
const
mutable_field
)
:
field_
(
mutable_field
)
{
}
RepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
=
(
const
T
&
value
)
{
*
field_
-
>
Add
(
)
=
value
;
return
*
this
;
}
RepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
=
(
const
T
*
const
ptr_to_value
)
{
*
field_
-
>
Add
(
)
=
*
ptr_to_value
;
return
*
this
;
}
RepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
=
(
T
&
&
value
)
{
*
field_
-
>
Add
(
)
=
std
:
:
move
(
value
)
;
return
*
this
;
}
RepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
*
(
)
{
return
*
this
;
}
RepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
+
+
(
)
{
return
*
this
;
}
RepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
+
+
(
int
)
{
return
*
this
;
}
private
:
RepeatedPtrField
<
T
>
*
field_
;
}
;
template
<
typename
T
>
class
AllocatedRepeatedPtrFieldBackInsertIterator
:
public
std
:
:
iterator
<
std
:
:
output_iterator_tag
T
>
{
public
:
explicit
AllocatedRepeatedPtrFieldBackInsertIterator
(
RepeatedPtrField
<
T
>
*
const
mutable_field
)
:
field_
(
mutable_field
)
{
}
AllocatedRepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
=
(
T
*
const
ptr_to_value
)
{
field_
-
>
AddAllocated
(
ptr_to_value
)
;
return
*
this
;
}
AllocatedRepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
*
(
)
{
return
*
this
;
}
AllocatedRepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
+
+
(
)
{
return
*
this
;
}
AllocatedRepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
+
+
(
int
)
{
return
*
this
;
}
private
:
RepeatedPtrField
<
T
>
*
field_
;
}
;
template
<
typename
T
>
class
UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator
:
public
std
:
:
iterator
<
std
:
:
output_iterator_tag
T
>
{
public
:
explicit
UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator
(
RepeatedPtrField
<
T
>
*
const
mutable_field
)
:
field_
(
mutable_field
)
{
}
UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
=
(
T
const
*
const
ptr_to_value
)
{
field_
-
>
UnsafeArenaAddAllocated
(
const_cast
<
T
*
>
(
ptr_to_value
)
)
;
return
*
this
;
}
UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
*
(
)
{
return
*
this
;
}
UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
+
+
(
)
{
return
*
this
;
}
UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator
<
T
>
&
operator
+
+
(
int
)
{
return
*
this
;
}
private
:
RepeatedPtrField
<
T
>
*
field_
;
}
;
}
template
<
typename
T
>
internal
:
:
RepeatedFieldBackInsertIterator
<
T
>
RepeatedFieldBackInserter
(
RepeatedField
<
T
>
*
const
mutable_field
)
{
return
internal
:
:
RepeatedFieldBackInsertIterator
<
T
>
(
mutable_field
)
;
}
template
<
typename
T
>
internal
:
:
RepeatedPtrFieldBackInsertIterator
<
T
>
RepeatedPtrFieldBackInserter
(
RepeatedPtrField
<
T
>
*
const
mutable_field
)
{
return
internal
:
:
RepeatedPtrFieldBackInsertIterator
<
T
>
(
mutable_field
)
;
}
template
<
typename
T
>
internal
:
:
RepeatedPtrFieldBackInsertIterator
<
T
>
RepeatedFieldBackInserter
(
RepeatedPtrField
<
T
>
*
const
mutable_field
)
{
return
internal
:
:
RepeatedPtrFieldBackInsertIterator
<
T
>
(
mutable_field
)
;
}
template
<
typename
T
>
internal
:
:
AllocatedRepeatedPtrFieldBackInsertIterator
<
T
>
AllocatedRepeatedPtrFieldBackInserter
(
RepeatedPtrField
<
T
>
*
const
mutable_field
)
{
return
internal
:
:
AllocatedRepeatedPtrFieldBackInsertIterator
<
T
>
(
mutable_field
)
;
}
template
<
typename
T
>
internal
:
:
UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator
<
T
>
UnsafeArenaAllocatedRepeatedPtrFieldBackInserter
(
RepeatedPtrField
<
T
>
*
const
mutable_field
)
{
return
internal
:
:
UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator
<
T
>
(
mutable_field
)
;
}
extern
template
class
PROTOBUF_EXPORT_TEMPLATE_DECLARE
RepeatedField
<
bool
>
;
extern
template
class
PROTOBUF_EXPORT_TEMPLATE_DECLARE
RepeatedField
<
int32
>
;
extern
template
class
PROTOBUF_EXPORT_TEMPLATE_DECLARE
RepeatedField
<
uint32
>
;
extern
template
class
PROTOBUF_EXPORT_TEMPLATE_DECLARE
RepeatedField
<
int64
>
;
extern
template
class
PROTOBUF_EXPORT_TEMPLATE_DECLARE
RepeatedField
<
uint64
>
;
extern
template
class
PROTOBUF_EXPORT_TEMPLATE_DECLARE
RepeatedField
<
float
>
;
extern
template
class
PROTOBUF_EXPORT_TEMPLATE_DECLARE
RepeatedField
<
double
>
;
extern
template
class
PROTOBUF_EXPORT_TEMPLATE_DECLARE
RepeatedPtrField
<
std
:
:
string
>
;
}
}
#
include
<
google
/
protobuf
/
port_undef
.
inc
>
#
endif
