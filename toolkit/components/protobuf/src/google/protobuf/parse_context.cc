#
include
<
google
/
protobuf
/
parse_context
.
h
>
#
include
<
google
/
protobuf
/
io
/
coded_stream
.
h
>
#
include
<
google
/
protobuf
/
io
/
zero_copy_stream
.
h
>
#
include
<
google
/
protobuf
/
arenastring
.
h
>
#
include
<
google
/
protobuf
/
endian
.
h
>
#
include
<
google
/
protobuf
/
message_lite
.
h
>
#
include
<
google
/
protobuf
/
repeated_field
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
strutil
.
h
>
#
include
<
google
/
protobuf
/
wire_format_lite
.
h
>
#
include
<
google
/
protobuf
/
port_def
.
inc
>
namespace
google
{
namespace
protobuf
{
namespace
internal
{
namespace
{
bool
ParseEndsInSlopRegion
(
const
char
*
begin
int
overrun
int
depth
)
{
constexpr
int
kSlopBytes
=
EpsCopyInputStream
:
:
kSlopBytes
;
GOOGLE_DCHECK_GE
(
overrun
0
)
;
GOOGLE_DCHECK_LE
(
overrun
kSlopBytes
)
;
auto
ptr
=
begin
+
overrun
;
auto
end
=
begin
+
kSlopBytes
;
while
(
ptr
<
end
)
{
uint32_t
tag
;
ptr
=
ReadTag
(
ptr
&
tag
)
;
if
(
ptr
=
=
nullptr
|
|
ptr
>
end
)
return
false
;
if
(
tag
=
=
0
)
return
true
;
switch
(
tag
&
7
)
{
case
0
:
{
uint64_t
val
;
ptr
=
VarintParse
(
ptr
&
val
)
;
if
(
ptr
=
=
nullptr
)
return
false
;
break
;
}
case
1
:
{
ptr
+
=
8
;
break
;
}
case
2
:
{
int32_t
size
=
ReadSize
(
&
ptr
)
;
if
(
ptr
=
=
nullptr
|
|
size
>
end
-
ptr
)
return
false
;
ptr
+
=
size
;
break
;
}
case
3
:
{
depth
+
+
;
break
;
}
case
4
:
{
if
(
-
-
depth
<
0
)
return
true
;
break
;
}
case
5
:
{
ptr
+
=
4
;
break
;
}
default
:
return
false
;
}
}
return
false
;
}
}
const
char
*
EpsCopyInputStream
:
:
NextBuffer
(
int
overrun
int
depth
)
{
if
(
next_chunk_
=
=
nullptr
)
return
nullptr
;
if
(
next_chunk_
!
=
buffer_
)
{
GOOGLE_DCHECK
(
size_
>
kSlopBytes
)
;
buffer_end_
=
next_chunk_
+
size_
-
kSlopBytes
;
auto
res
=
next_chunk_
;
next_chunk_
=
buffer_
;
if
(
aliasing_
=
=
kOnPatch
)
aliasing_
=
kNoDelta
;
return
res
;
}
std
:
:
memmove
(
buffer_
buffer_end_
kSlopBytes
)
;
if
(
overall_limit_
>
0
&
&
(
depth
<
0
|
|
!
ParseEndsInSlopRegion
(
buffer_
overrun
depth
)
)
)
{
const
void
*
data
;
while
(
StreamNext
(
&
data
)
)
{
if
(
size_
>
kSlopBytes
)
{
std
:
:
memcpy
(
buffer_
+
kSlopBytes
data
kSlopBytes
)
;
next_chunk_
=
static_cast
<
const
char
*
>
(
data
)
;
buffer_end_
=
buffer_
+
kSlopBytes
;
if
(
aliasing_
>
=
kNoDelta
)
aliasing_
=
kOnPatch
;
return
buffer_
;
}
else
if
(
size_
>
0
)
{
std
:
:
memcpy
(
buffer_
+
kSlopBytes
data
size_
)
;
next_chunk_
=
buffer_
;
buffer_end_
=
buffer_
+
size_
;
if
(
aliasing_
>
=
kNoDelta
)
aliasing_
=
kOnPatch
;
return
buffer_
;
}
GOOGLE_DCHECK
(
size_
=
=
0
)
<
<
size_
;
}
overall_limit_
=
0
;
}
if
(
aliasing_
=
=
kNoDelta
)
{
aliasing_
=
reinterpret_cast
<
std
:
:
uintptr_t
>
(
buffer_end_
)
-
reinterpret_cast
<
std
:
:
uintptr_t
>
(
buffer_
)
;
}
next_chunk_
=
nullptr
;
buffer_end_
=
buffer_
+
kSlopBytes
;
size_
=
0
;
return
buffer_
;
}
const
char
*
EpsCopyInputStream
:
:
Next
(
)
{
GOOGLE_DCHECK
(
limit_
>
kSlopBytes
)
;
auto
p
=
NextBuffer
(
0
-
1
)
;
if
(
p
=
=
nullptr
)
{
limit_end_
=
buffer_end_
;
SetEndOfStream
(
)
;
return
nullptr
;
}
limit_
-
=
buffer_end_
-
p
;
limit_end_
=
buffer_end_
+
std
:
:
min
(
0
limit_
)
;
return
p
;
}
std
:
:
pair
<
const
char
*
bool
>
EpsCopyInputStream
:
:
DoneFallback
(
int
overrun
int
depth
)
{
if
(
PROTOBUF_PREDICT_FALSE
(
overrun
>
limit_
)
)
return
{
nullptr
true
}
;
GOOGLE_DCHECK
(
overrun
!
=
limit_
)
;
GOOGLE_DCHECK
(
overrun
<
limit_
)
;
GOOGLE_DCHECK
(
limit_end_
=
=
buffer_end_
+
(
std
:
:
min
)
(
0
limit_
)
)
;
GOOGLE_DCHECK_GT
(
limit_
0
)
;
GOOGLE_DCHECK
(
limit_end_
=
=
buffer_end_
)
;
const
char
*
p
;
do
{
GOOGLE_DCHECK_GE
(
overrun
0
)
;
p
=
NextBuffer
(
overrun
depth
)
;
if
(
p
=
=
nullptr
)
{
if
(
PROTOBUF_PREDICT_FALSE
(
overrun
!
=
0
)
)
return
{
nullptr
true
}
;
GOOGLE_DCHECK_GT
(
limit_
0
)
;
limit_end_
=
buffer_end_
;
SetEndOfStream
(
)
;
return
{
buffer_end_
true
}
;
}
limit_
-
=
buffer_end_
-
p
;
p
+
=
overrun
;
overrun
=
p
-
buffer_end_
;
}
while
(
overrun
>
=
0
)
;
limit_end_
=
buffer_end_
+
std
:
:
min
(
0
limit_
)
;
return
{
p
false
}
;
}
const
char
*
EpsCopyInputStream
:
:
SkipFallback
(
const
char
*
ptr
int
size
)
{
return
AppendSize
(
ptr
size
[
]
(
const
char
*
int
)
{
}
)
;
}
const
char
*
EpsCopyInputStream
:
:
ReadStringFallback
(
const
char
*
ptr
int
size
std
:
:
string
*
str
)
{
str
-
>
clear
(
)
;
if
(
PROTOBUF_PREDICT_TRUE
(
size
<
=
buffer_end_
-
ptr
+
limit_
)
)
{
str
-
>
reserve
(
str
-
>
size
(
)
+
std
:
:
min
<
int
>
(
size
kSafeStringSize
)
)
;
}
return
AppendSize
(
ptr
size
[
str
]
(
const
char
*
p
int
s
)
{
str
-
>
append
(
p
s
)
;
}
)
;
}
const
char
*
EpsCopyInputStream
:
:
AppendStringFallback
(
const
char
*
ptr
int
size
std
:
:
string
*
str
)
{
if
(
PROTOBUF_PREDICT_TRUE
(
size
<
=
buffer_end_
-
ptr
+
limit_
)
)
{
str
-
>
reserve
(
str
-
>
size
(
)
+
std
:
:
min
<
int
>
(
size
kSafeStringSize
)
)
;
}
return
AppendSize
(
ptr
size
[
str
]
(
const
char
*
p
int
s
)
{
str
-
>
append
(
p
s
)
;
}
)
;
}
const
char
*
EpsCopyInputStream
:
:
InitFrom
(
io
:
:
ZeroCopyInputStream
*
zcis
)
{
zcis_
=
zcis
;
const
void
*
data
;
int
size
;
limit_
=
INT_MAX
;
if
(
zcis
-
>
Next
(
&
data
&
size
)
)
{
overall_limit_
-
=
size
;
if
(
size
>
kSlopBytes
)
{
auto
ptr
=
static_cast
<
const
char
*
>
(
data
)
;
limit_
-
=
size
-
kSlopBytes
;
limit_end_
=
buffer_end_
=
ptr
+
size
-
kSlopBytes
;
next_chunk_
=
buffer_
;
if
(
aliasing_
=
=
kOnPatch
)
aliasing_
=
kNoDelta
;
return
ptr
;
}
else
{
limit_end_
=
buffer_end_
=
buffer_
+
kSlopBytes
;
next_chunk_
=
buffer_
;
auto
ptr
=
buffer_
+
2
*
kSlopBytes
-
size
;
std
:
:
memcpy
(
ptr
data
size
)
;
return
ptr
;
}
}
overall_limit_
=
0
;
next_chunk_
=
nullptr
;
size_
=
0
;
limit_end_
=
buffer_end_
=
buffer_
;
return
buffer_
;
}
const
char
*
ParseContext
:
:
ReadSizeAndPushLimitAndDepth
(
const
char
*
ptr
int
*
old_limit
)
{
int
size
=
ReadSize
(
&
ptr
)
;
if
(
PROTOBUF_PREDICT_FALSE
(
!
ptr
)
)
{
*
old_limit
=
0
;
return
nullptr
;
}
*
old_limit
=
PushLimit
(
ptr
size
)
;
if
(
-
-
depth_
<
0
)
return
nullptr
;
return
ptr
;
}
const
char
*
ParseContext
:
:
ParseMessage
(
MessageLite
*
msg
const
char
*
ptr
)
{
int
old
;
ptr
=
ReadSizeAndPushLimitAndDepth
(
ptr
&
old
)
;
ptr
=
ptr
?
msg
-
>
_InternalParse
(
ptr
this
)
:
nullptr
;
depth_
+
+
;
if
(
!
PopLimit
(
old
)
)
return
nullptr
;
return
ptr
;
}
inline
void
WriteVarint
(
uint64_t
val
std
:
:
string
*
s
)
{
while
(
val
>
=
128
)
{
uint8_t
c
=
val
|
0x80
;
s
-
>
push_back
(
c
)
;
val
>
>
=
7
;
}
s
-
>
push_back
(
val
)
;
}
void
WriteVarint
(
uint32_t
num
uint64_t
val
std
:
:
string
*
s
)
{
WriteVarint
(
num
<
<
3
s
)
;
WriteVarint
(
val
s
)
;
}
void
WriteLengthDelimited
(
uint32_t
num
StringPiece
val
std
:
:
string
*
s
)
{
WriteVarint
(
(
num
<
<
3
)
+
2
s
)
;
WriteVarint
(
val
.
size
(
)
s
)
;
s
-
>
append
(
val
.
data
(
)
val
.
size
(
)
)
;
}
std
:
:
pair
<
const
char
*
uint32_t
>
VarintParseSlow32
(
const
char
*
p
uint32_t
res
)
{
for
(
std
:
:
uint32_t
i
=
2
;
i
<
5
;
i
+
+
)
{
uint32_t
byte
=
static_cast
<
uint8_t
>
(
p
[
i
]
)
;
res
+
=
(
byte
-
1
)
<
<
(
7
*
i
)
;
if
(
PROTOBUF_PREDICT_TRUE
(
byte
<
128
)
)
{
return
{
p
+
i
+
1
res
}
;
}
}
for
(
std
:
:
uint32_t
i
=
5
;
i
<
10
;
i
+
+
)
{
uint32_t
byte
=
static_cast
<
uint8_t
>
(
p
[
i
]
)
;
if
(
PROTOBUF_PREDICT_TRUE
(
byte
<
128
)
)
{
return
{
p
+
i
+
1
res
}
;
}
}
return
{
nullptr
0
}
;
}
std
:
:
pair
<
const
char
*
uint64_t
>
VarintParseSlow64
(
const
char
*
p
uint32_t
res32
)
{
uint64_t
res
=
res32
;
for
(
std
:
:
uint32_t
i
=
2
;
i
<
10
;
i
+
+
)
{
uint64_t
byte
=
static_cast
<
uint8_t
>
(
p
[
i
]
)
;
res
+
=
(
byte
-
1
)
<
<
(
7
*
i
)
;
if
(
PROTOBUF_PREDICT_TRUE
(
byte
<
128
)
)
{
return
{
p
+
i
+
1
res
}
;
}
}
return
{
nullptr
0
}
;
}
std
:
:
pair
<
const
char
*
uint32_t
>
ReadTagFallback
(
const
char
*
p
uint32_t
res
)
{
for
(
std
:
:
uint32_t
i
=
2
;
i
<
5
;
i
+
+
)
{
uint32_t
byte
=
static_cast
<
uint8_t
>
(
p
[
i
]
)
;
res
+
=
(
byte
-
1
)
<
<
(
7
*
i
)
;
if
(
PROTOBUF_PREDICT_TRUE
(
byte
<
128
)
)
{
return
{
p
+
i
+
1
res
}
;
}
}
return
{
nullptr
0
}
;
}
std
:
:
pair
<
const
char
*
int32_t
>
ReadSizeFallback
(
const
char
*
p
uint32_t
res
)
{
for
(
std
:
:
uint32_t
i
=
1
;
i
<
4
;
i
+
+
)
{
uint32_t
byte
=
static_cast
<
uint8_t
>
(
p
[
i
]
)
;
res
+
=
(
byte
-
1
)
<
<
(
7
*
i
)
;
if
(
PROTOBUF_PREDICT_TRUE
(
byte
<
128
)
)
{
return
{
p
+
i
+
1
res
}
;
}
}
std
:
:
uint32_t
byte
=
static_cast
<
uint8_t
>
(
p
[
4
]
)
;
if
(
PROTOBUF_PREDICT_FALSE
(
byte
>
=
8
)
)
return
{
nullptr
0
}
;
res
+
=
(
byte
-
1
)
<
<
28
;
if
(
PROTOBUF_PREDICT_FALSE
(
res
>
INT_MAX
-
ParseContext
:
:
kSlopBytes
)
)
{
return
{
nullptr
0
}
;
}
return
{
p
+
5
res
}
;
}
const
char
*
StringParser
(
const
char
*
begin
const
char
*
end
void
*
object
ParseContext
*
)
{
auto
str
=
static_cast
<
std
:
:
string
*
>
(
object
)
;
str
-
>
append
(
begin
end
-
begin
)
;
return
end
;
}
void
PrintUTF8ErrorLog
(
StringPiece
message_name
StringPiece
field_name
const
char
*
operation_str
bool
emit_stacktrace
)
;
bool
VerifyUTF8
(
StringPiece
str
const
char
*
field_name
)
{
if
(
!
IsStructurallyValidUTF8
(
str
)
)
{
PrintUTF8ErrorLog
(
"
"
field_name
"
parsing
"
false
)
;
return
false
;
}
return
true
;
}
const
char
*
InlineGreedyStringParser
(
std
:
:
string
*
s
const
char
*
ptr
ParseContext
*
ctx
)
{
int
size
=
ReadSize
(
&
ptr
)
;
if
(
!
ptr
)
return
nullptr
;
return
ctx
-
>
ReadString
(
ptr
size
s
)
;
}
template
<
typename
T
bool
sign
>
const
char
*
VarintParser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
ctx
-
>
ReadPackedVarint
(
ptr
[
object
]
(
uint64_t
varint
)
{
T
val
;
if
(
sign
)
{
if
(
sizeof
(
T
)
=
=
8
)
{
val
=
WireFormatLite
:
:
ZigZagDecode64
(
varint
)
;
}
else
{
val
=
WireFormatLite
:
:
ZigZagDecode32
(
varint
)
;
}
}
else
{
val
=
varint
;
}
static_cast
<
RepeatedField
<
T
>
*
>
(
object
)
-
>
Add
(
val
)
;
}
)
;
}
const
char
*
PackedInt32Parser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
VarintParser
<
int32_t
false
>
(
object
ptr
ctx
)
;
}
const
char
*
PackedUInt32Parser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
VarintParser
<
uint32_t
false
>
(
object
ptr
ctx
)
;
}
const
char
*
PackedInt64Parser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
VarintParser
<
int64_t
false
>
(
object
ptr
ctx
)
;
}
const
char
*
PackedUInt64Parser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
VarintParser
<
uint64_t
false
>
(
object
ptr
ctx
)
;
}
const
char
*
PackedSInt32Parser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
VarintParser
<
int32_t
true
>
(
object
ptr
ctx
)
;
}
const
char
*
PackedSInt64Parser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
VarintParser
<
int64_t
true
>
(
object
ptr
ctx
)
;
}
const
char
*
PackedEnumParser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
VarintParser
<
int
false
>
(
object
ptr
ctx
)
;
}
const
char
*
PackedBoolParser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
VarintParser
<
bool
false
>
(
object
ptr
ctx
)
;
}
template
<
typename
T
>
const
char
*
FixedParser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
int
size
=
ReadSize
(
&
ptr
)
;
return
ctx
-
>
ReadPackedFixed
(
ptr
size
static_cast
<
RepeatedField
<
T
>
*
>
(
object
)
)
;
}
const
char
*
PackedFixed32Parser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
FixedParser
<
uint32_t
>
(
object
ptr
ctx
)
;
}
const
char
*
PackedSFixed32Parser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
FixedParser
<
int32_t
>
(
object
ptr
ctx
)
;
}
const
char
*
PackedFixed64Parser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
FixedParser
<
uint64_t
>
(
object
ptr
ctx
)
;
}
const
char
*
PackedSFixed64Parser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
FixedParser
<
int64_t
>
(
object
ptr
ctx
)
;
}
const
char
*
PackedFloatParser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
FixedParser
<
float
>
(
object
ptr
ctx
)
;
}
const
char
*
PackedDoubleParser
(
void
*
object
const
char
*
ptr
ParseContext
*
ctx
)
{
return
FixedParser
<
double
>
(
object
ptr
ctx
)
;
}
class
UnknownFieldLiteParserHelper
{
public
:
explicit
UnknownFieldLiteParserHelper
(
std
:
:
string
*
unknown
)
:
unknown_
(
unknown
)
{
}
void
AddVarint
(
uint32_t
num
uint64_t
value
)
{
if
(
unknown_
=
=
nullptr
)
return
;
WriteVarint
(
num
*
8
unknown_
)
;
WriteVarint
(
value
unknown_
)
;
}
void
AddFixed64
(
uint32_t
num
uint64_t
value
)
{
if
(
unknown_
=
=
nullptr
)
return
;
WriteVarint
(
num
*
8
+
1
unknown_
)
;
char
buffer
[
8
]
;
io
:
:
CodedOutputStream
:
:
WriteLittleEndian64ToArray
(
value
reinterpret_cast
<
uint8_t
*
>
(
buffer
)
)
;
unknown_
-
>
append
(
buffer
8
)
;
}
const
char
*
ParseLengthDelimited
(
uint32_t
num
const
char
*
ptr
ParseContext
*
ctx
)
{
int
size
=
ReadSize
(
&
ptr
)
;
GOOGLE_PROTOBUF_PARSER_ASSERT
(
ptr
)
;
if
(
unknown_
=
=
nullptr
)
return
ctx
-
>
Skip
(
ptr
size
)
;
WriteVarint
(
num
*
8
+
2
unknown_
)
;
WriteVarint
(
size
unknown_
)
;
return
ctx
-
>
AppendString
(
ptr
size
unknown_
)
;
}
const
char
*
ParseGroup
(
uint32_t
num
const
char
*
ptr
ParseContext
*
ctx
)
{
if
(
unknown_
)
WriteVarint
(
num
*
8
+
3
unknown_
)
;
ptr
=
ctx
-
>
ParseGroup
(
this
ptr
num
*
8
+
3
)
;
GOOGLE_PROTOBUF_PARSER_ASSERT
(
ptr
)
;
if
(
unknown_
)
WriteVarint
(
num
*
8
+
4
unknown_
)
;
return
ptr
;
}
void
AddFixed32
(
uint32_t
num
uint32_t
value
)
{
if
(
unknown_
=
=
nullptr
)
return
;
WriteVarint
(
num
*
8
+
5
unknown_
)
;
char
buffer
[
4
]
;
io
:
:
CodedOutputStream
:
:
WriteLittleEndian32ToArray
(
value
reinterpret_cast
<
uint8_t
*
>
(
buffer
)
)
;
unknown_
-
>
append
(
buffer
4
)
;
}
const
char
*
_InternalParse
(
const
char
*
ptr
ParseContext
*
ctx
)
{
return
WireFormatParser
(
*
this
ptr
ctx
)
;
}
private
:
std
:
:
string
*
unknown_
;
}
;
const
char
*
UnknownGroupLiteParse
(
std
:
:
string
*
unknown
const
char
*
ptr
ParseContext
*
ctx
)
{
UnknownFieldLiteParserHelper
field_parser
(
unknown
)
;
return
WireFormatParser
(
field_parser
ptr
ctx
)
;
}
const
char
*
UnknownFieldParse
(
uint32_t
tag
std
:
:
string
*
unknown
const
char
*
ptr
ParseContext
*
ctx
)
{
UnknownFieldLiteParserHelper
field_parser
(
unknown
)
;
return
FieldParser
(
tag
field_parser
ptr
ctx
)
;
}
}
}
}
#
include
<
google
/
protobuf
/
port_undef
.
inc
>
