#
include
<
google
/
protobuf
/
dynamic_message
.
h
>
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
memory
>
#
include
<
new
>
#
include
<
unordered_map
>
#
include
<
google
/
protobuf
/
descriptor
.
h
>
#
include
<
google
/
protobuf
/
descriptor
.
pb
.
h
>
#
include
<
google
/
protobuf
/
generated_message_reflection
.
h
>
#
include
<
google
/
protobuf
/
generated_message_util
.
h
>
#
include
<
google
/
protobuf
/
unknown_field_set
.
h
>
#
include
<
google
/
protobuf
/
stubs
/
hash
.
h
>
#
include
<
google
/
protobuf
/
arenastring
.
h
>
#
include
<
google
/
protobuf
/
extension_set
.
h
>
#
include
<
google
/
protobuf
/
map_field
.
h
>
#
include
<
google
/
protobuf
/
map_field_inl
.
h
>
#
include
<
google
/
protobuf
/
map_type_handler
.
h
>
#
include
<
google
/
protobuf
/
reflection_ops
.
h
>
#
include
<
google
/
protobuf
/
repeated_field
.
h
>
#
include
<
google
/
protobuf
/
wire_format
.
h
>
#
include
<
google
/
protobuf
/
port_def
.
inc
>
namespace
google
{
namespace
protobuf
{
using
internal
:
:
DynamicMapField
;
using
internal
:
:
ExtensionSet
;
using
internal
:
:
MapField
;
using
internal
:
:
ArenaStringPtr
;
namespace
{
bool
IsMapFieldInApi
(
const
FieldDescriptor
*
field
)
{
return
field
-
>
is_map
(
)
;
}
inline
bool
HasHasbit
(
const
FieldDescriptor
*
field
)
{
return
(
field
-
>
has_optional_keyword
(
)
|
|
field
-
>
is_required
(
)
)
&
&
!
field
-
>
options
(
)
.
weak
(
)
;
}
inline
bool
InRealOneof
(
const
FieldDescriptor
*
field
)
{
return
field
-
>
containing_oneof
(
)
&
&
!
field
-
>
containing_oneof
(
)
-
>
is_synthetic
(
)
;
}
int
FieldSpaceUsed
(
const
FieldDescriptor
*
field
)
{
typedef
FieldDescriptor
FD
;
if
(
field
-
>
label
(
)
=
=
FD
:
:
LABEL_REPEATED
)
{
switch
(
field
-
>
cpp_type
(
)
)
{
case
FD
:
:
CPPTYPE_INT32
:
return
sizeof
(
RepeatedField
<
int32_t
>
)
;
case
FD
:
:
CPPTYPE_INT64
:
return
sizeof
(
RepeatedField
<
int64_t
>
)
;
case
FD
:
:
CPPTYPE_UINT32
:
return
sizeof
(
RepeatedField
<
uint32_t
>
)
;
case
FD
:
:
CPPTYPE_UINT64
:
return
sizeof
(
RepeatedField
<
uint64_t
>
)
;
case
FD
:
:
CPPTYPE_DOUBLE
:
return
sizeof
(
RepeatedField
<
double
>
)
;
case
FD
:
:
CPPTYPE_FLOAT
:
return
sizeof
(
RepeatedField
<
float
>
)
;
case
FD
:
:
CPPTYPE_BOOL
:
return
sizeof
(
RepeatedField
<
bool
>
)
;
case
FD
:
:
CPPTYPE_ENUM
:
return
sizeof
(
RepeatedField
<
int
>
)
;
case
FD
:
:
CPPTYPE_MESSAGE
:
if
(
IsMapFieldInApi
(
field
)
)
{
return
sizeof
(
DynamicMapField
)
;
}
else
{
return
sizeof
(
RepeatedPtrField
<
Message
>
)
;
}
case
FD
:
:
CPPTYPE_STRING
:
switch
(
field
-
>
options
(
)
.
ctype
(
)
)
{
default
:
case
FieldOptions
:
:
STRING
:
return
sizeof
(
RepeatedPtrField
<
std
:
:
string
>
)
;
}
break
;
}
}
else
{
switch
(
field
-
>
cpp_type
(
)
)
{
case
FD
:
:
CPPTYPE_INT32
:
return
sizeof
(
int32_t
)
;
case
FD
:
:
CPPTYPE_INT64
:
return
sizeof
(
int64_t
)
;
case
FD
:
:
CPPTYPE_UINT32
:
return
sizeof
(
uint32_t
)
;
case
FD
:
:
CPPTYPE_UINT64
:
return
sizeof
(
uint64_t
)
;
case
FD
:
:
CPPTYPE_DOUBLE
:
return
sizeof
(
double
)
;
case
FD
:
:
CPPTYPE_FLOAT
:
return
sizeof
(
float
)
;
case
FD
:
:
CPPTYPE_BOOL
:
return
sizeof
(
bool
)
;
case
FD
:
:
CPPTYPE_ENUM
:
return
sizeof
(
int
)
;
case
FD
:
:
CPPTYPE_MESSAGE
:
return
sizeof
(
Message
*
)
;
case
FD
:
:
CPPTYPE_STRING
:
switch
(
field
-
>
options
(
)
.
ctype
(
)
)
{
default
:
case
FieldOptions
:
:
STRING
:
return
sizeof
(
ArenaStringPtr
)
;
}
break
;
}
}
GOOGLE_LOG
(
DFATAL
)
<
<
"
Can
'
t
get
here
.
"
;
return
0
;
}
inline
int
DivideRoundingUp
(
int
i
int
j
)
{
return
(
i
+
(
j
-
1
)
)
/
j
;
}
static
const
int
kSafeAlignment
=
sizeof
(
uint64_t
)
;
static
const
int
kMaxOneofUnionSize
=
sizeof
(
uint64_t
)
;
inline
int
AlignTo
(
int
offset
int
alignment
)
{
return
DivideRoundingUp
(
offset
alignment
)
*
alignment
;
}
inline
int
AlignOffset
(
int
offset
)
{
return
AlignTo
(
offset
kSafeAlignment
)
;
}
#
define
bitsizeof
(
T
)
(
sizeof
(
T
)
*
8
)
}
class
DynamicMessage
:
public
Message
{
public
:
explicit
DynamicMessage
(
const
DynamicMessageFactory
:
:
TypeInfo
*
type_info
)
;
DynamicMessage
(
DynamicMessageFactory
:
:
TypeInfo
*
type_info
bool
lock_factory
)
;
~
DynamicMessage
(
)
override
;
void
CrossLinkPrototypes
(
)
;
Message
*
New
(
Arena
*
arena
)
const
override
;
int
GetCachedSize
(
)
const
override
;
void
SetCachedSize
(
int
size
)
const
override
;
Metadata
GetMetadata
(
)
const
override
;
#
if
defined
(
__cpp_lib_destroying_delete
)
&
&
defined
(
__cpp_sized_deallocation
)
static
void
operator
delete
(
DynamicMessage
*
msg
std
:
:
destroying_delete_t
)
;
#
else
#
ifndef
_MSC_VER
static
void
operator
delete
(
void
*
ptr
)
{
:
:
operator
delete
(
ptr
)
;
}
#
endif
#
endif
private
:
DynamicMessage
(
const
DynamicMessageFactory
:
:
TypeInfo
*
type_info
Arena
*
arena
)
;
void
SharedCtor
(
bool
lock_factory
)
;
friend
class
DynamicMessageFactory
;
bool
is_prototype
(
)
const
;
inline
void
*
OffsetToPointer
(
int
offset
)
{
return
reinterpret_cast
<
uint8_t
*
>
(
this
)
+
offset
;
}
inline
const
void
*
OffsetToPointer
(
int
offset
)
const
{
return
reinterpret_cast
<
const
uint8_t
*
>
(
this
)
+
offset
;
}
void
*
MutableRaw
(
int
i
)
;
void
*
MutableExtensionsRaw
(
)
;
void
*
MutableWeakFieldMapRaw
(
)
;
void
*
MutableOneofCaseRaw
(
int
i
)
;
void
*
MutableOneofFieldRaw
(
const
FieldDescriptor
*
f
)
;
const
DynamicMessageFactory
:
:
TypeInfo
*
type_info_
;
mutable
std
:
:
atomic
<
int
>
cached_byte_size_
;
GOOGLE_DISALLOW_EVIL_CONSTRUCTORS
(
DynamicMessage
)
;
}
;
struct
DynamicMessageFactory
:
:
TypeInfo
{
int
size
;
int
has_bits_offset
;
int
oneof_case_offset
;
int
extensions_offset
;
DynamicMessageFactory
*
factory
;
const
DescriptorPool
*
pool
;
const
Descriptor
*
type
;
std
:
:
unique_ptr
<
uint32_t
[
]
>
offsets
;
std
:
:
unique_ptr
<
uint32_t
[
]
>
has_bits_indices
;
std
:
:
unique_ptr
<
const
Reflection
>
reflection
;
const
DynamicMessage
*
prototype
;
int
weak_field_map_offset
;
TypeInfo
(
)
:
prototype
(
nullptr
)
{
}
~
TypeInfo
(
)
{
delete
prototype
;
}
}
;
DynamicMessage
:
:
DynamicMessage
(
const
DynamicMessageFactory
:
:
TypeInfo
*
type_info
)
:
type_info_
(
type_info
)
cached_byte_size_
(
0
)
{
SharedCtor
(
true
)
;
}
DynamicMessage
:
:
DynamicMessage
(
const
DynamicMessageFactory
:
:
TypeInfo
*
type_info
Arena
*
arena
)
:
Message
(
arena
)
type_info_
(
type_info
)
cached_byte_size_
(
0
)
{
SharedCtor
(
true
)
;
}
DynamicMessage
:
:
DynamicMessage
(
DynamicMessageFactory
:
:
TypeInfo
*
type_info
bool
lock_factory
)
:
type_info_
(
type_info
)
cached_byte_size_
(
0
)
{
type_info
-
>
prototype
=
this
;
SharedCtor
(
lock_factory
)
;
}
inline
void
*
DynamicMessage
:
:
MutableRaw
(
int
i
)
{
return
OffsetToPointer
(
type_info_
-
>
offsets
[
i
]
)
;
}
inline
void
*
DynamicMessage
:
:
MutableExtensionsRaw
(
)
{
return
OffsetToPointer
(
type_info_
-
>
extensions_offset
)
;
}
inline
void
*
DynamicMessage
:
:
MutableWeakFieldMapRaw
(
)
{
return
OffsetToPointer
(
type_info_
-
>
weak_field_map_offset
)
;
}
inline
void
*
DynamicMessage
:
:
MutableOneofCaseRaw
(
int
i
)
{
return
OffsetToPointer
(
type_info_
-
>
oneof_case_offset
+
sizeof
(
uint32_t
)
*
i
)
;
}
inline
void
*
DynamicMessage
:
:
MutableOneofFieldRaw
(
const
FieldDescriptor
*
f
)
{
return
OffsetToPointer
(
type_info_
-
>
offsets
[
type_info_
-
>
type
-
>
field_count
(
)
+
f
-
>
containing_oneof
(
)
-
>
index
(
)
]
)
;
}
void
DynamicMessage
:
:
SharedCtor
(
bool
lock_factory
)
{
const
Descriptor
*
descriptor
=
type_info_
-
>
type
;
int
oneof_count
=
0
;
for
(
int
i
=
0
;
i
<
descriptor
-
>
oneof_decl_count
(
)
;
+
+
i
)
{
if
(
descriptor
-
>
oneof_decl
(
i
)
-
>
is_synthetic
(
)
)
continue
;
new
(
MutableOneofCaseRaw
(
oneof_count
+
+
)
)
uint32_t
{
0
}
;
}
if
(
type_info_
-
>
extensions_offset
!
=
-
1
)
{
new
(
MutableExtensionsRaw
(
)
)
ExtensionSet
(
GetArenaForAllocation
(
)
)
;
}
for
(
int
i
=
0
;
i
<
descriptor
-
>
field_count
(
)
;
i
+
+
)
{
const
FieldDescriptor
*
field
=
descriptor
-
>
field
(
i
)
;
void
*
field_ptr
=
MutableRaw
(
i
)
;
if
(
InRealOneof
(
field
)
)
{
continue
;
}
switch
(
field
-
>
cpp_type
(
)
)
{
#
define
HANDLE_TYPE
(
CPPTYPE
TYPE
)
\
case
FieldDescriptor
:
:
CPPTYPE_
#
#
CPPTYPE
:
\
if
(
!
field
-
>
is_repeated
(
)
)
{
\
new
(
field_ptr
)
TYPE
(
field
-
>
default_value_
#
#
TYPE
(
)
)
;
\
}
else
{
\
new
(
field_ptr
)
RepeatedField
<
TYPE
>
(
GetArenaForAllocation
(
)
)
;
\
}
\
break
;
HANDLE_TYPE
(
INT32
int32_t
)
;
HANDLE_TYPE
(
INT64
int64_t
)
;
HANDLE_TYPE
(
UINT32
uint32_t
)
;
HANDLE_TYPE
(
UINT64
uint64_t
)
;
HANDLE_TYPE
(
DOUBLE
double
)
;
HANDLE_TYPE
(
FLOAT
float
)
;
HANDLE_TYPE
(
BOOL
bool
)
;
#
undef
HANDLE_TYPE
case
FieldDescriptor
:
:
CPPTYPE_ENUM
:
if
(
!
field
-
>
is_repeated
(
)
)
{
new
(
field_ptr
)
int
{
field
-
>
default_value_enum
(
)
-
>
number
(
)
}
;
}
else
{
new
(
field_ptr
)
RepeatedField
<
int
>
(
GetArenaForAllocation
(
)
)
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_STRING
:
switch
(
field
-
>
options
(
)
.
ctype
(
)
)
{
default
:
case
FieldOptions
:
:
STRING
:
if
(
!
field
-
>
is_repeated
(
)
)
{
ArenaStringPtr
*
asp
=
new
(
field_ptr
)
ArenaStringPtr
(
)
;
asp
-
>
InitDefault
(
)
;
}
else
{
new
(
field_ptr
)
RepeatedPtrField
<
std
:
:
string
>
(
GetArenaForAllocation
(
)
)
;
}
break
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_MESSAGE
:
{
if
(
!
field
-
>
is_repeated
(
)
)
{
new
(
field_ptr
)
Message
*
(
nullptr
)
;
}
else
{
if
(
IsMapFieldInApi
(
field
)
)
{
if
(
lock_factory
)
{
if
(
GetArenaForAllocation
(
)
!
=
nullptr
)
{
new
(
field_ptr
)
DynamicMapField
(
type_info_
-
>
factory
-
>
GetPrototype
(
field
-
>
message_type
(
)
)
GetArenaForAllocation
(
)
)
;
if
(
GetOwningArena
(
)
!
=
nullptr
)
{
GetOwningArena
(
)
-
>
OwnDestructor
(
static_cast
<
DynamicMapField
*
>
(
field_ptr
)
)
;
}
}
else
{
new
(
field_ptr
)
DynamicMapField
(
type_info_
-
>
factory
-
>
GetPrototype
(
field
-
>
message_type
(
)
)
)
;
}
}
else
{
if
(
GetArenaForAllocation
(
)
!
=
nullptr
)
{
new
(
field_ptr
)
DynamicMapField
(
type_info_
-
>
factory
-
>
GetPrototypeNoLock
(
field
-
>
message_type
(
)
)
GetArenaForAllocation
(
)
)
;
if
(
GetOwningArena
(
)
!
=
nullptr
)
{
GetOwningArena
(
)
-
>
OwnDestructor
(
static_cast
<
DynamicMapField
*
>
(
field_ptr
)
)
;
}
}
else
{
new
(
field_ptr
)
DynamicMapField
(
type_info_
-
>
factory
-
>
GetPrototypeNoLock
(
field
-
>
message_type
(
)
)
)
;
}
}
}
else
{
new
(
field_ptr
)
RepeatedPtrField
<
Message
>
(
GetArenaForAllocation
(
)
)
;
}
}
break
;
}
}
}
}
bool
DynamicMessage
:
:
is_prototype
(
)
const
{
return
type_info_
-
>
prototype
=
=
this
|
|
type_info_
-
>
prototype
=
=
nullptr
;
}
#
if
defined
(
__cpp_lib_destroying_delete
)
&
&
defined
(
__cpp_sized_deallocation
)
void
DynamicMessage
:
:
operator
delete
(
DynamicMessage
*
msg
std
:
:
destroying_delete_t
)
{
const
size_t
size
=
msg
-
>
type_info_
-
>
size
;
msg
-
>
~
DynamicMessage
(
)
;
:
:
operator
delete
(
msg
size
)
;
}
#
endif
DynamicMessage
:
:
~
DynamicMessage
(
)
{
const
Descriptor
*
descriptor
=
type_info_
-
>
type
;
_internal_metadata_
.
Delete
<
UnknownFieldSet
>
(
)
;
if
(
type_info_
-
>
extensions_offset
!
=
-
1
)
{
reinterpret_cast
<
ExtensionSet
*
>
(
MutableExtensionsRaw
(
)
)
-
>
~
ExtensionSet
(
)
;
}
for
(
int
i
=
0
;
i
<
descriptor
-
>
field_count
(
)
;
i
+
+
)
{
const
FieldDescriptor
*
field
=
descriptor
-
>
field
(
i
)
;
if
(
InRealOneof
(
field
)
)
{
void
*
field_ptr
=
MutableOneofCaseRaw
(
field
-
>
containing_oneof
(
)
-
>
index
(
)
)
;
if
(
*
(
reinterpret_cast
<
const
int32_t
*
>
(
field_ptr
)
)
=
=
field
-
>
number
(
)
)
{
field_ptr
=
MutableOneofFieldRaw
(
field
)
;
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_STRING
)
{
switch
(
field
-
>
options
(
)
.
ctype
(
)
)
{
default
:
case
FieldOptions
:
:
STRING
:
{
reinterpret_cast
<
ArenaStringPtr
*
>
(
field_ptr
)
-
>
Destroy
(
)
;
break
;
}
}
}
else
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
delete
*
reinterpret_cast
<
Message
*
*
>
(
field_ptr
)
;
}
}
continue
;
}
void
*
field_ptr
=
MutableRaw
(
i
)
;
if
(
field
-
>
is_repeated
(
)
)
{
switch
(
field
-
>
cpp_type
(
)
)
{
#
define
HANDLE_TYPE
(
UPPERCASE
LOWERCASE
)
\
case
FieldDescriptor
:
:
CPPTYPE_
#
#
UPPERCASE
:
\
reinterpret_cast
<
RepeatedField
<
LOWERCASE
>
*
>
(
field_ptr
)
\
-
>
~
RepeatedField
<
LOWERCASE
>
(
)
;
\
break
HANDLE_TYPE
(
INT32
int32_t
)
;
HANDLE_TYPE
(
INT64
int64_t
)
;
HANDLE_TYPE
(
UINT32
uint32_t
)
;
HANDLE_TYPE
(
UINT64
uint64_t
)
;
HANDLE_TYPE
(
DOUBLE
double
)
;
HANDLE_TYPE
(
FLOAT
float
)
;
HANDLE_TYPE
(
BOOL
bool
)
;
HANDLE_TYPE
(
ENUM
int
)
;
#
undef
HANDLE_TYPE
case
FieldDescriptor
:
:
CPPTYPE_STRING
:
switch
(
field
-
>
options
(
)
.
ctype
(
)
)
{
default
:
case
FieldOptions
:
:
STRING
:
reinterpret_cast
<
RepeatedPtrField
<
std
:
:
string
>
*
>
(
field_ptr
)
-
>
~
RepeatedPtrField
<
std
:
:
string
>
(
)
;
break
;
}
break
;
case
FieldDescriptor
:
:
CPPTYPE_MESSAGE
:
if
(
IsMapFieldInApi
(
field
)
)
{
reinterpret_cast
<
DynamicMapField
*
>
(
field_ptr
)
-
>
~
DynamicMapField
(
)
;
}
else
{
reinterpret_cast
<
RepeatedPtrField
<
Message
>
*
>
(
field_ptr
)
-
>
~
RepeatedPtrField
<
Message
>
(
)
;
}
break
;
}
}
else
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_STRING
)
{
switch
(
field
-
>
options
(
)
.
ctype
(
)
)
{
default
:
case
FieldOptions
:
:
STRING
:
{
reinterpret_cast
<
ArenaStringPtr
*
>
(
field_ptr
)
-
>
Destroy
(
)
;
break
;
}
}
}
else
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
)
{
if
(
!
is_prototype
(
)
)
{
Message
*
message
=
*
reinterpret_cast
<
Message
*
*
>
(
field_ptr
)
;
if
(
message
!
=
nullptr
)
{
delete
message
;
}
}
}
}
}
void
DynamicMessage
:
:
CrossLinkPrototypes
(
)
{
GOOGLE_CHECK
(
is_prototype
(
)
)
;
DynamicMessageFactory
*
factory
=
type_info_
-
>
factory
;
const
Descriptor
*
descriptor
=
type_info_
-
>
type
;
for
(
int
i
=
0
;
i
<
descriptor
-
>
field_count
(
)
;
i
+
+
)
{
const
FieldDescriptor
*
field
=
descriptor
-
>
field
(
i
)
;
if
(
field
-
>
cpp_type
(
)
=
=
FieldDescriptor
:
:
CPPTYPE_MESSAGE
&
&
!
field
-
>
options
(
)
.
weak
(
)
&
&
!
InRealOneof
(
field
)
&
&
!
field
-
>
is_repeated
(
)
)
{
void
*
field_ptr
=
MutableRaw
(
i
)
;
*
reinterpret_cast
<
const
Message
*
*
>
(
field_ptr
)
=
factory
-
>
GetPrototypeNoLock
(
field
-
>
message_type
(
)
)
;
}
}
}
Message
*
DynamicMessage
:
:
New
(
Arena
*
arena
)
const
{
if
(
arena
!
=
nullptr
)
{
void
*
new_base
=
Arena
:
:
CreateArray
<
char
>
(
arena
type_info_
-
>
size
)
;
memset
(
new_base
0
type_info_
-
>
size
)
;
return
new
(
new_base
)
DynamicMessage
(
type_info_
arena
)
;
}
else
{
void
*
new_base
=
operator
new
(
type_info_
-
>
size
)
;
memset
(
new_base
0
type_info_
-
>
size
)
;
return
new
(
new_base
)
DynamicMessage
(
type_info_
)
;
}
}
int
DynamicMessage
:
:
GetCachedSize
(
)
const
{
return
cached_byte_size_
.
load
(
std
:
:
memory_order_relaxed
)
;
}
void
DynamicMessage
:
:
SetCachedSize
(
int
size
)
const
{
cached_byte_size_
.
store
(
size
std
:
:
memory_order_relaxed
)
;
}
Metadata
DynamicMessage
:
:
GetMetadata
(
)
const
{
Metadata
metadata
;
metadata
.
descriptor
=
type_info_
-
>
type
;
metadata
.
reflection
=
type_info_
-
>
reflection
.
get
(
)
;
return
metadata
;
}
DynamicMessageFactory
:
:
DynamicMessageFactory
(
)
:
pool_
(
nullptr
)
delegate_to_generated_factory_
(
false
)
{
}
DynamicMessageFactory
:
:
DynamicMessageFactory
(
const
DescriptorPool
*
pool
)
:
pool_
(
pool
)
delegate_to_generated_factory_
(
false
)
{
}
DynamicMessageFactory
:
:
~
DynamicMessageFactory
(
)
{
for
(
auto
iter
=
prototypes_
.
begin
(
)
;
iter
!
=
prototypes_
.
end
(
)
;
+
+
iter
)
{
delete
iter
-
>
second
;
}
}
const
Message
*
DynamicMessageFactory
:
:
GetPrototype
(
const
Descriptor
*
type
)
{
MutexLock
lock
(
&
prototypes_mutex_
)
;
return
GetPrototypeNoLock
(
type
)
;
}
const
Message
*
DynamicMessageFactory
:
:
GetPrototypeNoLock
(
const
Descriptor
*
type
)
{
if
(
delegate_to_generated_factory_
&
&
type
-
>
file
(
)
-
>
pool
(
)
=
=
DescriptorPool
:
:
generated_pool
(
)
)
{
return
MessageFactory
:
:
generated_factory
(
)
-
>
GetPrototype
(
type
)
;
}
const
TypeInfo
*
*
target
=
&
prototypes_
[
type
]
;
if
(
*
target
!
=
nullptr
)
{
return
(
*
target
)
-
>
prototype
;
}
TypeInfo
*
type_info
=
new
TypeInfo
;
*
target
=
type_info
;
type_info
-
>
type
=
type
;
type_info
-
>
pool
=
(
pool_
=
=
nullptr
)
?
type
-
>
file
(
)
-
>
pool
(
)
:
pool_
;
type_info
-
>
factory
=
this
;
int
real_oneof_count
=
0
;
for
(
int
i
=
0
;
i
<
type
-
>
oneof_decl_count
(
)
;
i
+
+
)
{
if
(
!
type
-
>
oneof_decl
(
i
)
-
>
is_synthetic
(
)
)
{
real_oneof_count
+
+
;
}
}
uint32_t
*
offsets
=
new
uint32_t
[
type
-
>
field_count
(
)
+
real_oneof_count
]
;
type_info
-
>
offsets
.
reset
(
offsets
)
;
int
size
=
sizeof
(
DynamicMessage
)
;
size
=
AlignOffset
(
size
)
;
type_info
-
>
has_bits_offset
=
-
1
;
int
max_hasbit
=
0
;
for
(
int
i
=
0
;
i
<
type
-
>
field_count
(
)
;
i
+
+
)
{
if
(
HasHasbit
(
type
-
>
field
(
i
)
)
)
{
if
(
type_info
-
>
has_bits_offset
=
=
-
1
)
{
type_info
-
>
has_bits_offset
=
size
;
uint32_t
*
has_bits_indices
=
new
uint32_t
[
type
-
>
field_count
(
)
]
;
for
(
int
j
=
0
;
j
<
type
-
>
field_count
(
)
;
j
+
+
)
{
has_bits_indices
[
j
]
=
static_cast
<
uint32_t
>
(
-
1
)
;
}
type_info
-
>
has_bits_indices
.
reset
(
has_bits_indices
)
;
}
type_info
-
>
has_bits_indices
[
i
]
=
max_hasbit
+
+
;
}
}
if
(
max_hasbit
>
0
)
{
int
has_bits_array_size
=
DivideRoundingUp
(
max_hasbit
bitsizeof
(
uint32_t
)
)
;
size
+
=
has_bits_array_size
*
sizeof
(
uint32_t
)
;
size
=
AlignOffset
(
size
)
;
}
if
(
real_oneof_count
>
0
)
{
type_info
-
>
oneof_case_offset
=
size
;
size
+
=
real_oneof_count
*
sizeof
(
uint32_t
)
;
size
=
AlignOffset
(
size
)
;
}
if
(
type
-
>
extension_range_count
(
)
>
0
)
{
type_info
-
>
extensions_offset
=
size
;
size
+
=
sizeof
(
ExtensionSet
)
;
size
=
AlignOffset
(
size
)
;
}
else
{
type_info
-
>
extensions_offset
=
-
1
;
}
for
(
int
i
=
0
;
i
<
type
-
>
field_count
(
)
;
i
+
+
)
{
if
(
!
InRealOneof
(
type
-
>
field
(
i
)
)
)
{
int
field_size
=
FieldSpaceUsed
(
type
-
>
field
(
i
)
)
;
size
=
AlignTo
(
size
std
:
:
min
(
kSafeAlignment
field_size
)
)
;
offsets
[
i
]
=
size
;
size
+
=
field_size
;
}
}
for
(
int
i
=
0
;
i
<
type
-
>
oneof_decl_count
(
)
;
i
+
+
)
{
if
(
!
type
-
>
oneof_decl
(
i
)
-
>
is_synthetic
(
)
)
{
size
=
AlignTo
(
size
kSafeAlignment
)
;
offsets
[
type
-
>
field_count
(
)
+
i
]
=
size
;
size
+
=
kMaxOneofUnionSize
;
}
}
type_info
-
>
weak_field_map_offset
=
-
1
;
type_info
-
>
size
=
size
;
for
(
int
i
=
0
;
i
<
type
-
>
oneof_decl_count
(
)
;
i
+
+
)
{
if
(
type
-
>
oneof_decl
(
i
)
-
>
is_synthetic
(
)
)
continue
;
for
(
int
j
=
0
;
j
<
type
-
>
oneof_decl
(
i
)
-
>
field_count
(
)
;
j
+
+
)
{
const
FieldDescriptor
*
field
=
type
-
>
oneof_decl
(
i
)
-
>
field
(
j
)
;
offsets
[
field
-
>
index
(
)
]
=
internal
:
:
kInvalidFieldOffsetTag
;
}
}
void
*
base
=
operator
new
(
size
)
;
memset
(
base
0
size
)
;
DynamicMessage
*
prototype
=
new
(
base
)
DynamicMessage
(
type_info
false
)
;
internal
:
:
ReflectionSchema
schema
=
{
type_info
-
>
prototype
type_info
-
>
offsets
.
get
(
)
type_info
-
>
has_bits_indices
.
get
(
)
type_info
-
>
has_bits_offset
PROTOBUF_FIELD_OFFSET
(
DynamicMessage
_internal_metadata_
)
type_info
-
>
extensions_offset
type_info
-
>
oneof_case_offset
type_info
-
>
size
type_info
-
>
weak_field_map_offset
nullptr
0
}
;
type_info
-
>
reflection
.
reset
(
new
Reflection
(
type_info
-
>
type
schema
type_info
-
>
pool
this
)
)
;
prototype
-
>
CrossLinkPrototypes
(
)
;
return
prototype
;
}
}
}
#
include
<
google
/
protobuf
/
port_undef
.
inc
>
