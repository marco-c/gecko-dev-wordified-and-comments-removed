#
ifndef
GOOGLE_PROTOBUF_ARENA_H__
#
define
GOOGLE_PROTOBUF_ARENA_H__
#
include
<
limits
>
#
include
<
type_traits
>
#
include
<
utility
>
#
ifdef
max
#
undef
max
/
/
Visual
Studio
defines
this
macro
#
endif
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
_LIBCPP_STD_VER
)
&
&
!
_HAS_EXCEPTIONS
#
include
<
exception
>
#
include
<
typeinfo
>
namespace
std
{
using
type_info
=
:
:
type_info
;
}
#
else
#
include
<
typeinfo
>
#
endif
#
include
<
type_traits
>
#
include
<
google
/
protobuf
/
arena_impl
.
h
>
#
include
<
google
/
protobuf
/
port
.
h
>
#
include
<
google
/
protobuf
/
port_def
.
inc
>
#
ifdef
SWIG
#
error
"
You
cannot
SWIG
proto
headers
"
#
endif
namespace
google
{
namespace
protobuf
{
struct
ArenaOptions
;
}
}
namespace
google
{
namespace
protobuf
{
class
Arena
;
class
Message
;
class
MessageLite
;
template
<
typename
Key
typename
T
>
class
Map
;
namespace
arena_metrics
{
void
EnableArenaMetrics
(
ArenaOptions
*
options
)
;
}
namespace
internal
{
struct
ArenaStringPtr
;
class
LazyField
;
class
EpsCopyInputStream
;
template
<
typename
Type
>
class
GenericTypeHandler
;
template
<
typename
T
>
void
arena_destruct_object
(
void
*
object
)
{
reinterpret_cast
<
T
*
>
(
object
)
-
>
~
T
(
)
;
}
template
<
typename
T
>
void
arena_delete_object
(
void
*
object
)
{
delete
reinterpret_cast
<
T
*
>
(
object
)
;
}
inline
void
arena_free
(
void
*
object
size_t
size
)
{
#
if
defined
(
__GXX_DELETE_WITH_SIZE__
)
|
|
defined
(
__cpp_sized_deallocation
)
:
:
operator
delete
(
object
size
)
;
#
else
(
void
)
size
;
:
:
operator
delete
(
object
)
;
#
endif
}
}
struct
ArenaOptions
{
size_t
start_block_size
;
size_t
max_block_size
;
char
*
initial_block
;
size_t
initial_block_size
;
void
*
(
*
block_alloc
)
(
size_t
)
;
void
(
*
block_dealloc
)
(
void
*
size_t
)
;
ArenaOptions
(
)
:
start_block_size
(
kDefaultStartBlockSize
)
max_block_size
(
kDefaultMaxBlockSize
)
initial_block
(
NULL
)
initial_block_size
(
0
)
block_alloc
(
&
:
:
operator
new
)
block_dealloc
(
&
internal
:
:
arena_free
)
on_arena_init
(
NULL
)
on_arena_reset
(
NULL
)
on_arena_destruction
(
NULL
)
on_arena_allocation
(
NULL
)
{
}
private
:
void
*
(
*
on_arena_init
)
(
Arena
*
arena
)
;
void
(
*
on_arena_reset
)
(
Arena
*
arena
void
*
cookie
uint64
space_used
)
;
void
(
*
on_arena_destruction
)
(
Arena
*
arena
void
*
cookie
uint64
space_used
)
;
void
(
*
on_arena_allocation
)
(
const
std
:
:
type_info
*
allocated_type
uint64
alloc_size
void
*
cookie
)
;
static
const
size_t
kDefaultStartBlockSize
=
256
;
static
const
size_t
kDefaultMaxBlockSize
=
8192
;
friend
void
arena_metrics
:
:
EnableArenaMetrics
(
ArenaOptions
*
)
;
friend
class
Arena
;
friend
class
ArenaOptionsTestFriend
;
}
;
#
if
PROTOBUF_RTTI
#
define
RTTI_TYPE_ID
(
type
)
(
&
typeid
(
type
)
)
#
else
#
define
RTTI_TYPE_ID
(
type
)
(
NULL
)
#
endif
class
PROTOBUF_EXPORT
alignas
(
8
)
Arena
final
{
public
:
explicit
Arena
(
const
ArenaOptions
&
options
)
:
impl_
(
options
)
{
Init
(
options
)
;
}
static
const
size_t
kBlockOverhead
=
internal
:
:
ArenaImpl
:
:
kBlockHeaderSize
+
internal
:
:
ArenaImpl
:
:
kSerialArenaSize
;
Arena
(
)
:
impl_
(
ArenaOptions
(
)
)
{
Init
(
ArenaOptions
(
)
)
;
}
~
Arena
(
)
{
if
(
hooks_cookie_
)
{
CallDestructorHooks
(
)
;
}
}
void
Init
(
const
ArenaOptions
&
options
)
{
on_arena_allocation_
=
options
.
on_arena_allocation
;
on_arena_reset_
=
options
.
on_arena_reset
;
on_arena_destruction_
=
options
.
on_arena_destruction
;
if
(
options
.
on_arena_init
!
=
NULL
)
{
hooks_cookie_
=
options
.
on_arena_init
(
this
)
;
}
else
{
hooks_cookie_
=
NULL
;
}
}
template
<
typename
T
typename
.
.
.
Args
>
PROTOBUF_ALWAYS_INLINE
static
T
*
CreateMessage
(
Arena
*
arena
Args
&
&
.
.
.
args
)
{
static_assert
(
InternalHelper
<
T
>
:
:
is_arena_constructable
:
:
value
"
CreateMessage
can
only
construct
types
that
are
ArenaConstructable
"
)
;
return
Arena
:
:
CreateMaybeMessage
<
T
>
(
arena
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
PROTOBUF_ALWAYS_INLINE
static
T
*
Create
(
Arena
*
arena
Args
&
&
.
.
.
args
)
{
return
CreateNoMessage
<
T
>
(
arena
is_arena_constructable
<
T
>
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
static
T
*
CreateArray
(
Arena
*
arena
size_t
num_elements
)
{
static_assert
(
std
:
:
is_pod
<
T
>
:
:
value
"
CreateArray
requires
a
trivially
constructible
type
"
)
;
static_assert
(
std
:
:
is_trivially_destructible
<
T
>
:
:
value
"
CreateArray
requires
a
trivially
destructible
type
"
)
;
GOOGLE_CHECK_LE
(
num_elements
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
/
sizeof
(
T
)
)
<
<
"
Requested
size
is
too
large
to
fit
into
size_t
.
"
;
if
(
arena
=
=
NULL
)
{
return
static_cast
<
T
*
>
(
:
:
operator
new
[
]
(
num_elements
*
sizeof
(
T
)
)
)
;
}
else
{
return
arena
-
>
CreateInternalRawArray
<
T
>
(
num_elements
)
;
}
}
uint64
SpaceAllocated
(
)
const
{
return
impl_
.
SpaceAllocated
(
)
;
}
uint64
SpaceUsed
(
)
const
{
return
impl_
.
SpaceUsed
(
)
;
}
PROTOBUF_NOINLINE
uint64
Reset
(
)
{
if
(
on_arena_reset_
!
=
NULL
)
{
on_arena_reset_
(
this
hooks_cookie_
impl_
.
SpaceAllocated
(
)
)
;
}
return
impl_
.
Reset
(
)
;
}
template
<
typename
T
>
PROTOBUF_NOINLINE
void
Own
(
T
*
object
)
{
OwnInternal
(
object
std
:
:
is_convertible
<
T
*
Message
*
>
(
)
)
;
}
template
<
typename
T
>
PROTOBUF_NOINLINE
void
OwnDestructor
(
T
*
object
)
{
if
(
object
!
=
NULL
)
{
impl_
.
AddCleanup
(
object
&
internal
:
:
arena_destruct_object
<
T
>
)
;
}
}
PROTOBUF_NOINLINE
void
OwnCustomDestructor
(
void
*
object
void
(
*
destruct
)
(
void
*
)
)
{
impl_
.
AddCleanup
(
object
destruct
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
static
Arena
*
GetArena
(
const
T
*
value
)
{
return
GetArenaInternal
(
value
)
;
}
template
<
typename
T
>
class
InternalHelper
{
template
<
typename
U
>
static
char
DestructorSkippable
(
const
typename
U
:
:
DestructorSkippable_
*
)
;
template
<
typename
U
>
static
double
DestructorSkippable
(
.
.
.
)
;
typedef
std
:
:
integral_constant
<
bool
sizeof
(
DestructorSkippable
<
T
>
(
static_cast
<
const
T
*
>
(
0
)
)
)
=
=
sizeof
(
char
)
|
|
std
:
:
is_trivially_destructible
<
T
>
:
:
value
>
is_destructor_skippable
;
template
<
typename
U
>
static
char
ArenaConstructable
(
const
typename
U
:
:
InternalArenaConstructable_
*
)
;
template
<
typename
U
>
static
double
ArenaConstructable
(
.
.
.
)
;
typedef
std
:
:
integral_constant
<
bool
sizeof
(
ArenaConstructable
<
T
>
(
static_cast
<
const
T
*
>
(
0
)
)
)
=
=
sizeof
(
char
)
>
is_arena_constructable
;
template
<
typename
U
typename
std
:
:
enable_if
<
std
:
:
is_same
<
Arena
*
decltype
(
std
:
:
declval
<
const
U
>
(
)
.
GetArena
(
)
)
>
:
:
value
int
>
:
:
type
=
0
>
static
char
HasGetArena
(
decltype
(
&
U
:
:
GetArena
)
)
;
template
<
typename
U
>
static
double
HasGetArena
(
.
.
.
)
;
typedef
std
:
:
integral_constant
<
bool
sizeof
(
HasGetArena
<
T
>
(
nullptr
)
)
=
=
sizeof
(
char
)
>
has_get_arena
;
template
<
typename
.
.
.
Args
>
static
T
*
Construct
(
void
*
ptr
Args
&
&
.
.
.
args
)
{
return
new
(
ptr
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
static
Arena
*
GetArena
(
const
T
*
p
)
{
return
p
-
>
GetArenaNoVirtual
(
)
;
}
friend
class
Arena
;
}
;
template
<
typename
T
>
struct
is_arena_constructable
:
InternalHelper
<
T
>
:
:
is_arena_constructable
{
}
;
template
<
typename
T
>
struct
is_destructor_skippable
:
InternalHelper
<
T
>
:
:
is_destructor_skippable
{
}
;
private
:
template
<
typename
T
>
struct
has_get_arena
:
InternalHelper
<
T
>
:
:
has_get_arena
{
}
;
template
<
typename
T
typename
.
.
.
Args
>
PROTOBUF_ALWAYS_INLINE
static
T
*
CreateMessageInternal
(
Arena
*
arena
Args
&
&
.
.
.
args
)
{
static_assert
(
InternalHelper
<
T
>
:
:
is_arena_constructable
:
:
value
"
CreateMessage
can
only
construct
types
that
are
ArenaConstructable
"
)
;
if
(
arena
=
=
NULL
)
{
return
new
T
(
nullptr
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
else
{
return
arena
-
>
DoCreateMessage
<
T
>
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
static
T
*
CreateMessageInternal
(
Arena
*
arena
)
{
static_assert
(
InternalHelper
<
T
>
:
:
is_arena_constructable
:
:
value
"
CreateMessage
can
only
construct
types
that
are
ArenaConstructable
"
)
;
if
(
arena
=
=
NULL
)
{
return
new
T
(
)
;
}
else
{
return
arena
-
>
DoCreateMessage
<
T
>
(
)
;
}
}
template
<
typename
T
typename
.
.
.
Args
>
PROTOBUF_ALWAYS_INLINE
static
T
*
CreateInternal
(
Arena
*
arena
Args
&
&
.
.
.
args
)
{
if
(
arena
=
=
NULL
)
{
return
new
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
else
{
return
arena
-
>
DoCreate
<
T
>
(
std
:
:
is_trivially_destructible
<
T
>
:
:
value
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
void
CallDestructorHooks
(
)
;
void
OnArenaAllocation
(
const
std
:
:
type_info
*
allocated_type
size_t
n
)
const
;
inline
void
AllocHook
(
const
std
:
:
type_info
*
allocated_type
size_t
n
)
const
{
if
(
PROTOBUF_PREDICT_FALSE
(
hooks_cookie_
!
=
NULL
)
)
{
OnArenaAllocation
(
allocated_type
n
)
;
}
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
void
*
AllocateInternal
(
bool
skip_explicit_ownership
)
{
const
size_t
n
=
internal
:
:
AlignUpTo8
(
sizeof
(
T
)
)
;
AllocHook
(
RTTI_TYPE_ID
(
T
)
n
)
;
if
(
skip_explicit_ownership
)
{
return
AllocateAlignedNoHook
(
n
)
;
}
else
{
return
impl_
.
AllocateAlignedAndAddCleanup
(
n
&
internal
:
:
arena_destruct_object
<
T
>
)
;
}
}
template
<
typename
Msg
typename
.
.
.
Args
>
PROTOBUF_ALWAYS_INLINE
static
Msg
*
DoCreateMaybeMessage
(
Arena
*
arena
std
:
:
true_type
Args
&
&
.
.
.
args
)
{
return
CreateMessageInternal
<
Msg
>
(
arena
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
PROTOBUF_ALWAYS_INLINE
static
T
*
DoCreateMaybeMessage
(
Arena
*
arena
std
:
:
false_type
Args
&
&
.
.
.
args
)
{
return
CreateInternal
<
T
>
(
arena
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
PROTOBUF_ALWAYS_INLINE
static
T
*
CreateMaybeMessage
(
Arena
*
arena
Args
&
&
.
.
.
args
)
{
return
DoCreateMaybeMessage
<
T
>
(
arena
is_arena_constructable
<
T
>
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
PROTOBUF_ALWAYS_INLINE
static
T
*
CreateNoMessage
(
Arena
*
arena
std
:
:
true_type
Args
&
&
.
.
.
args
)
{
return
CreateInternal
<
T
>
(
arena
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
PROTOBUF_ALWAYS_INLINE
static
T
*
CreateNoMessage
(
Arena
*
arena
std
:
:
false_type
Args
&
&
.
.
.
args
)
{
return
CreateMaybeMessage
<
T
>
(
arena
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
T
*
CreateInternalRawArray
(
size_t
num_elements
)
{
GOOGLE_CHECK_LE
(
num_elements
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
/
sizeof
(
T
)
)
<
<
"
Requested
size
is
too
large
to
fit
into
size_t
.
"
;
const
size_t
n
=
internal
:
:
AlignUpTo8
(
sizeof
(
T
)
*
num_elements
)
;
AllocHook
(
RTTI_TYPE_ID
(
T
)
n
)
;
return
static_cast
<
T
*
>
(
AllocateAlignedNoHook
(
n
)
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
PROTOBUF_ALWAYS_INLINE
T
*
DoCreate
(
bool
skip_explicit_ownership
Args
&
&
.
.
.
args
)
{
return
new
(
AllocateInternal
<
T
>
(
skip_explicit_ownership
)
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
PROTOBUF_ALWAYS_INLINE
T
*
DoCreateMessage
(
Args
&
&
.
.
.
args
)
{
return
InternalHelper
<
T
>
:
:
Construct
(
AllocateInternal
<
T
>
(
InternalHelper
<
T
>
:
:
is_destructor_skippable
:
:
value
)
this
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
>
static
void
CreateInArenaStorage
(
T
*
ptr
Arena
*
arena
)
{
CreateInArenaStorageInternal
(
ptr
arena
typename
is_arena_constructable
<
T
>
:
:
type
(
)
)
;
RegisterDestructorInternal
(
ptr
arena
typename
InternalHelper
<
T
>
:
:
is_destructor_skippable
:
:
type
(
)
)
;
}
template
<
typename
T
>
static
void
CreateInArenaStorageInternal
(
T
*
ptr
Arena
*
arena
std
:
:
true_type
)
{
InternalHelper
<
T
>
:
:
Construct
(
ptr
arena
)
;
}
template
<
typename
T
>
static
void
CreateInArenaStorageInternal
(
T
*
ptr
Arena
*
std
:
:
false_type
)
{
new
(
ptr
)
T
(
)
;
}
template
<
typename
T
>
static
void
RegisterDestructorInternal
(
T
*
Arena
*
std
:
:
true_type
)
{
}
template
<
typename
T
>
static
void
RegisterDestructorInternal
(
T
*
ptr
Arena
*
arena
std
:
:
false_type
)
{
arena
-
>
OwnDestructor
(
ptr
)
;
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
void
OwnInternal
(
T
*
object
std
:
:
true_type
)
{
if
(
object
!
=
NULL
)
{
impl_
.
AddCleanup
(
object
&
internal
:
:
arena_delete_object
<
Message
>
)
;
}
}
template
<
typename
T
>
PROTOBUF_ALWAYS_INLINE
void
OwnInternal
(
T
*
object
std
:
:
false_type
)
{
if
(
object
!
=
NULL
)
{
impl_
.
AddCleanup
(
object
&
internal
:
:
arena_delete_object
<
T
>
)
;
}
}
template
<
typename
T
typename
std
:
:
enable_if
<
is_arena_constructable
<
T
>
:
:
value
int
>
:
:
type
=
0
>
PROTOBUF_ALWAYS_INLINE
static
Arena
*
GetArenaInternal
(
const
T
*
value
)
{
return
InternalHelper
<
T
>
:
:
GetArena
(
value
)
;
}
template
<
typename
T
typename
std
:
:
enable_if
<
!
is_arena_constructable
<
T
>
:
:
value
&
&
has_get_arena
<
T
>
:
:
value
int
>
:
:
type
=
0
>
PROTOBUF_ALWAYS_INLINE
static
Arena
*
GetArenaInternal
(
const
T
*
value
)
{
return
value
-
>
GetArena
(
)
;
}
template
<
typename
T
typename
std
:
:
enable_if
<
!
is_arena_constructable
<
T
>
:
:
value
&
&
!
has_get_arena
<
T
>
:
:
value
int
>
:
:
type
=
0
>
PROTOBUF_ALWAYS_INLINE
static
Arena
*
GetArenaInternal
(
const
T
*
value
)
{
(
void
)
value
;
return
nullptr
;
}
void
*
AllocateAligned
(
size_t
n
)
{
AllocHook
(
NULL
n
)
;
return
AllocateAlignedNoHook
(
internal
:
:
AlignUpTo8
(
n
)
)
;
}
void
*
AllocateAlignedNoHook
(
size_t
n
)
;
internal
:
:
ArenaImpl
impl_
;
void
(
*
on_arena_allocation_
)
(
const
std
:
:
type_info
*
allocated_type
uint64
alloc_size
void
*
cookie
)
;
void
(
*
on_arena_reset_
)
(
Arena
*
arena
void
*
cookie
uint64
space_used
)
;
void
(
*
on_arena_destruction_
)
(
Arena
*
arena
void
*
cookie
uint64
space_used
)
;
void
*
hooks_cookie_
;
template
<
typename
Type
>
friend
class
internal
:
:
GenericTypeHandler
;
friend
struct
internal
:
:
ArenaStringPtr
;
friend
class
internal
:
:
LazyField
;
friend
class
internal
:
:
EpsCopyInputStream
;
friend
class
MessageLite
;
template
<
typename
Key
typename
T
>
friend
class
Map
;
}
;
#
undef
RTTI_TYPE_ID
}
}
#
include
<
google
/
protobuf
/
port_undef
.
inc
>
#
endif
