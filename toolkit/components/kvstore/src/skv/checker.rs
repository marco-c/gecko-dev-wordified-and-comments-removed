use
crate
:
:
skv
:
:
{
connection
:
:
{
ConnectionIncident
ConnectionIncidents
ConnectionMaintenanceTask
}
maintenance
:
:
{
Maintenance
MaintenanceError
}
}
;
#
[
derive
(
Debug
)
]
pub
struct
Checker
{
checks
:
Checks
}
impl
ConnectionMaintenanceTask
for
Checker
{
type
Error
=
MaintenanceError
;
fn
run
(
self
conn
:
&
mut
rusqlite
:
:
Connection
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
let
maintenance
=
Maintenance
:
:
new
(
conn
)
;
if
self
.
checks
.
reindex
{
maintenance
.
reindex
(
)
?
;
}
match
self
.
checks
.
consistency
{
Some
(
ConsistencyCheck
:
:
Quick
)
=
>
maintenance
.
quick_check
(
)
?
Some
(
ConsistencyCheck
:
:
Full
)
=
>
maintenance
.
integrity_check
(
)
?
None
=
>
(
)
}
if
self
.
checks
.
foreign_keys
{
maintenance
.
foreign_key_check
(
)
?
;
}
Ok
(
(
)
)
}
}
pub
trait
IntoChecker
{
fn
into_checker
(
self
)
-
>
CheckerAction
;
}
impl
IntoChecker
for
ConnectionIncidents
<
'
_
>
{
fn
into_checker
(
self
)
-
>
CheckerAction
{
self
.
map
(
|
incidents
|
{
let
(
penalty
checks
)
=
incidents
.
iter
(
)
.
fold
(
(
Penalty
:
:
default
(
)
Checks
:
:
default
(
)
)
|
(
penalty
checks
)
incident
|
(
penalty
.
adding
(
incident
)
checks
.
adding
(
incident
)
)
)
;
if
penalty
<
Penalty
:
:
MIN
{
CheckerAction
:
:
Skip
}
else
if
penalty
<
Penalty
:
:
MAX
{
incidents
.
resolve
(
)
;
CheckerAction
:
:
Check
(
Checker
{
checks
}
)
}
else
{
incidents
.
resolve
(
)
;
CheckerAction
:
:
Replace
}
}
)
}
}
#
[
derive
(
Debug
)
]
pub
enum
CheckerAction
{
Skip
Check
(
Checker
)
Replace
}
#
[
derive
(
Clone
Copy
Debug
Default
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
struct
Penalty
(
usize
)
;
impl
Penalty
{
const
MIN
:
Self
=
Penalty
(
5
)
;
const
MAX
:
Self
=
Penalty
(
20
)
;
fn
adding
(
self
incident
:
ConnectionIncident
)
-
>
Self
{
Self
(
self
.
0
+
match
incident
{
ConnectionIncident
:
:
CorruptFile
=
>
3
ConnectionIncident
:
:
CorruptIndex
=
>
2
ConnectionIncident
:
:
CorruptForeignKey
=
>
1
}
)
}
}
const
_
:
(
)
=
{
assert
!
(
Penalty
:
:
MIN
.
0
<
Penalty
:
:
MAX
.
0
"
Penalty
:
:
MIN
should
be
less
than
Penalty
:
:
MAX
"
)
;
}
;
#
[
derive
(
Clone
Copy
Debug
Default
)
]
struct
Checks
{
reindex
:
bool
consistency
:
Option
<
ConsistencyCheck
>
foreign_keys
:
bool
}
impl
Checks
{
fn
adding
(
self
incident
:
ConnectionIncident
)
-
>
Self
{
match
incident
{
ConnectionIncident
:
:
CorruptFile
=
>
Self
{
consistency
:
Some
(
self
.
consistency
.
unwrap_or
(
ConsistencyCheck
:
:
Quick
)
.
and
(
ConsistencyCheck
:
:
Quick
)
)
.
.
self
}
ConnectionIncident
:
:
CorruptIndex
=
>
Self
{
reindex
:
true
consistency
:
Some
(
self
.
consistency
.
unwrap_or
(
ConsistencyCheck
:
:
Full
)
.
and
(
ConsistencyCheck
:
:
Full
)
)
.
.
self
}
ConnectionIncident
:
:
CorruptForeignKey
=
>
Self
{
foreign_keys
:
true
.
.
self
}
}
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
enum
ConsistencyCheck
{
Quick
Full
}
impl
ConsistencyCheck
{
fn
and
(
self
other
:
Self
)
-
>
Self
{
match
(
self
other
)
{
(
Self
:
:
Quick
Self
:
:
Quick
)
=
>
Self
:
:
Quick
_
=
>
Self
:
:
Full
}
}
}
