use
std
:
:
{
collections
:
:
btree_map
:
:
BTreeMap
fmt
:
:
Debug
future
:
:
Future
mem
num
:
:
NonZeroUsize
pin
:
:
Pin
sync
:
:
{
Arc
Mutex
}
task
:
:
{
Context
Poll
Waker
}
}
;
use
futures
:
:
future
:
:
{
self
Either
}
;
pub
struct
AbortController
{
state
:
Arc
<
Mutex
<
AbortState
>
>
}
impl
AbortController
{
pub
fn
new
(
)
-
>
Self
{
Self
{
state
:
Arc
:
:
new
(
Mutex
:
:
new
(
AbortState
:
:
Armed
{
next_id
:
NonZeroUsize
:
:
MIN
wakers
:
BTreeMap
:
:
new
(
)
}
)
)
}
}
pub
fn
signal
(
&
self
)
-
>
AbortSignal
{
AbortSignal
{
id
:
AbortSignalId
:
:
Unreserved
state
:
self
.
state
.
clone
(
)
}
}
pub
fn
abort
(
&
self
)
{
let
wakers
=
match
mem
:
:
replace
(
&
mut
*
self
.
state
.
lock
(
)
.
unwrap
(
)
AbortState
:
:
Aborted
)
{
AbortState
:
:
Aborted
=
>
return
AbortState
:
:
Armed
{
wakers
.
.
}
=
>
wakers
}
;
for
waker
in
wakers
.
into_values
(
)
{
waker
.
wake
(
)
}
}
}
impl
Default
for
AbortController
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
Debug
for
AbortController
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
f
.
write_str
(
"
AbortController
{
.
.
}
"
)
}
}
pub
struct
AbortSignal
{
id
:
AbortSignalId
state
:
Arc
<
Mutex
<
AbortState
>
>
}
impl
AbortSignal
{
pub
async
fn
aborting
<
T
E
F
>
(
self
f
:
F
)
-
>
Result
<
T
E
>
where
F
:
Future
<
Output
=
Result
<
T
E
>
>
E
:
From
<
AbortError
>
{
futures
:
:
pin_mut
!
(
f
)
;
match
future
:
:
select
(
f
self
)
.
await
{
Either
:
:
Left
(
(
result
_
)
)
=
>
result
Either
:
:
Right
(
(
_
_
)
)
=
>
Err
(
AbortError
)
?
}
}
}
impl
Clone
for
AbortSignal
{
fn
clone
(
&
self
)
-
>
Self
{
AbortSignal
{
id
:
AbortSignalId
:
:
Unreserved
state
:
Arc
:
:
clone
(
&
self
.
state
)
}
}
}
impl
Future
for
AbortSignal
{
type
Output
=
(
)
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
context
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
this
=
self
.
get_mut
(
)
;
let
mut
guard
=
this
.
state
.
lock
(
)
.
unwrap
(
)
;
let
AbortState
:
:
Armed
{
next_id
wakers
}
=
&
mut
*
guard
else
{
this
.
id
=
AbortSignalId
:
:
Unreserved
;
return
Poll
:
:
Ready
(
(
)
)
;
}
;
let
id
=
match
this
.
id
{
AbortSignalId
:
:
Reserved
(
id
)
=
>
id
AbortSignalId
:
:
Unreserved
=
>
{
let
this_id
=
*
next_id
;
*
next_id
=
this_id
.
checked_add
(
1
)
.
unwrap
(
)
;
this
.
id
=
AbortSignalId
:
:
Reserved
(
this_id
)
;
this_id
}
}
;
wakers
.
entry
(
id
)
.
and_modify
(
|
waker
|
{
waker
.
clone_from
(
context
.
waker
(
)
)
;
}
)
.
or_insert_with
(
|
|
context
.
waker
(
)
.
clone
(
)
)
;
Poll
:
:
Pending
}
}
impl
Drop
for
AbortSignal
{
fn
drop
(
&
mut
self
)
{
if
let
AbortSignalId
:
:
Reserved
(
id
)
=
self
.
id
{
if
let
AbortState
:
:
Armed
{
wakers
.
.
}
=
&
mut
*
self
.
state
.
lock
(
)
.
unwrap
(
)
{
wakers
.
remove
(
&
id
)
;
}
}
}
}
impl
Debug
for
AbortSignal
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
AbortSignal
{
{
id
:
{
:
?
}
.
.
}
}
"
self
.
id
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
enum
AbortSignalId
{
Unreserved
Reserved
(
NonZeroUsize
)
}
enum
AbortState
{
Armed
{
next_id
:
NonZeroUsize
wakers
:
BTreeMap
<
NonZeroUsize
Waker
>
}
Aborted
}
#
[
derive
(
thiserror
:
:
Error
Debug
)
]
#
[
error
(
"
operation
aborted
"
)
]
pub
struct
AbortError
;
