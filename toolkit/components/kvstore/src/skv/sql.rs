use
std
:
:
{
fmt
:
:
Display
ops
:
:
{
Bound
RangeBounds
}
}
;
use
rusqlite
:
:
ToSql
;
pub
struct
RangeFragment
<
'
a
T
>
{
column
:
&
'
a
str
start
:
Bound
<
&
'
a
T
>
end
:
Bound
<
&
'
a
T
>
}
impl
<
'
a
T
>
RangeFragment
<
'
a
T
>
where
T
:
ToSql
{
pub
fn
start_param
(
&
self
)
-
>
Option
<
(
&
'
static
str
&
dyn
ToSql
)
>
{
match
&
self
.
start
{
Bound
:
:
Included
(
key
)
|
Bound
:
:
Excluded
(
key
)
=
>
Some
(
(
"
:
start
"
key
)
)
Bound
:
:
Unbounded
=
>
None
}
}
pub
fn
end_param
(
&
self
)
-
>
Option
<
(
&
'
static
str
&
dyn
ToSql
)
>
{
match
&
self
.
end
{
Bound
:
:
Included
(
key
)
|
Bound
:
:
Excluded
(
key
)
=
>
Some
(
(
"
:
end
"
key
)
)
Bound
:
:
Unbounded
=
>
None
}
}
}
impl
<
'
a
T
>
RangeFragment
<
'
a
T
>
{
pub
fn
new
<
R
>
(
column
:
&
'
a
str
range
:
&
'
a
R
)
-
>
Self
where
R
:
RangeBounds
<
T
>
{
RangeFragment
{
column
start
:
range
.
start_bound
(
)
end
:
range
.
end_bound
(
)
}
}
}
impl
<
'
a
T
>
Display
for
RangeFragment
<
'
a
T
>
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
match
(
&
self
.
start
&
self
.
end
)
{
(
Bound
:
:
Unbounded
Bound
:
:
Unbounded
)
=
>
{
f
.
write_str
(
"
1
"
)
}
(
Bound
:
:
Unbounded
Bound
:
:
Included
(
_
)
)
=
>
write
!
(
f
"
(
{
0
}
<
=
:
end
)
"
self
.
column
)
(
Bound
:
:
Unbounded
Bound
:
:
Excluded
(
_
)
)
=
>
write
!
(
f
"
(
{
0
}
<
:
end
)
"
self
.
column
)
(
Bound
:
:
Included
(
_
)
Bound
:
:
Unbounded
)
=
>
write
!
(
f
"
(
{
0
}
>
=
:
start
)
"
self
.
column
)
(
Bound
:
:
Included
(
_
)
Bound
:
:
Included
(
_
)
)
=
>
{
write
!
(
f
"
(
{
0
}
BETWEEN
:
start
AND
:
end
)
"
self
.
column
)
}
(
Bound
:
:
Included
(
_
)
Bound
:
:
Excluded
(
_
)
)
=
>
{
write
!
(
f
"
(
{
0
}
>
=
:
start
AND
{
0
}
<
:
end
)
"
self
.
column
)
}
(
Bound
:
:
Excluded
(
_
)
Bound
:
:
Unbounded
)
=
>
write
!
(
f
"
(
{
0
}
>
:
start
)
"
self
.
column
)
(
Bound
:
:
Excluded
(
_
)
Bound
:
:
Included
(
_
)
)
=
>
{
write
!
(
f
"
(
{
0
}
>
:
start
AND
{
0
}
<
=
:
end
)
"
self
.
column
)
}
(
Bound
:
:
Excluded
(
_
)
Bound
:
:
Excluded
(
_
)
)
=
>
{
write
!
(
f
"
(
{
0
}
>
:
start
AND
{
0
}
<
:
end
)
"
self
.
column
)
}
}
}
}
