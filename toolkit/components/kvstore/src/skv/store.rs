use
std
:
:
{
borrow
:
:
Cow
mem
ops
:
:
Deref
path
:
:
{
Path
PathBuf
}
sync
:
:
{
atomic
:
:
{
self
AtomicUsize
}
Arc
Condvar
Mutex
}
}
;
use
rusqlite
:
:
OpenFlags
;
use
crate
:
:
skv
:
:
{
connection
:
:
{
Connection
ConnectionPath
ConnectionType
}
schema
:
:
{
Schema
SchemaError
}
}
;
#
[
derive
(
Debug
)
]
pub
struct
Store
{
state
:
Mutex
<
StoreState
>
waiter
:
OperationWaiter
}
impl
Store
{
pub
fn
new
(
path
:
StorePath
)
-
>
Self
{
Self
{
state
:
Mutex
:
:
new
(
StoreState
:
:
Created
(
path
)
)
waiter
:
OperationWaiter
:
:
new
(
)
}
}
fn
open
(
&
self
)
-
>
Result
<
OpenStoreGuard
<
'
_
>
StoreError
>
{
let
mut
state
=
self
.
state
.
lock
(
)
.
unwrap
(
)
;
Ok
(
match
&
*
state
{
StoreState
:
:
Created
(
path
)
=
>
{
let
store
=
Arc
:
:
new
(
OpenStore
:
:
new
(
path
)
?
)
;
*
state
=
StoreState
:
:
Open
(
store
.
clone
(
)
)
;
OpenStoreGuard
:
:
new
(
store
self
.
waiter
.
guard
(
)
)
}
StoreState
:
:
Open
(
store
)
=
>
OpenStoreGuard
:
:
new
(
store
.
clone
(
)
self
.
waiter
.
guard
(
)
)
StoreState
:
:
Closed
=
>
Err
(
StoreError
:
:
Closed
)
?
}
)
}
pub
fn
writer
(
&
self
)
-
>
Result
<
Writer
<
'
_
>
StoreError
>
{
Ok
(
Writer
(
self
.
open
(
)
?
)
)
}
pub
fn
reader
(
&
self
)
-
>
Result
<
Reader
<
'
_
>
StoreError
>
{
Ok
(
Reader
(
self
.
open
(
)
?
)
)
}
pub
fn
close
(
&
self
)
{
let
store
=
match
mem
:
:
replace
(
&
mut
*
self
.
state
.
lock
(
)
.
unwrap
(
)
StoreState
:
:
Closed
)
{
StoreState
:
:
Created
(
_
)
|
StoreState
:
:
Closed
=
>
return
StoreState
:
:
Open
(
store
)
=
>
store
}
;
store
.
reader
.
interrupt
(
)
;
self
.
waiter
.
wait
(
)
;
let
store
=
Arc
:
:
into_inner
(
store
)
.
expect
(
"
invariant
violation
"
)
;
store
.
close
(
)
;
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
pub
enum
StorePath
{
OnDisk
(
PathBuf
)
InMemory
(
usize
)
}
impl
StorePath
{
pub
const
IN_MEMORY_DATABASE_NAME
:
&
'
static
str
=
"
:
memory
:
"
;
const
DEFAULT_DATABASE_FILE_NAME
:
&
'
static
str
=
"
kvstore
.
sqlite
"
;
pub
fn
for_storage_dir
(
dir
:
impl
Into
<
PathBuf
>
)
-
>
Self
{
let
mut
path
=
dir
.
into
(
)
;
path
.
push
(
Self
:
:
DEFAULT_DATABASE_FILE_NAME
)
;
Self
:
:
OnDisk
(
path
)
}
pub
fn
for_in_memory
(
)
-
>
Self
{
static
NEXT_IN_MEMORY_DATABASE_ID
:
AtomicUsize
=
AtomicUsize
:
:
new
(
1
)
;
let
id
=
NEXT_IN_MEMORY_DATABASE_ID
.
fetch_add
(
1
atomic
:
:
Ordering
:
:
Relaxed
)
;
Self
:
:
InMemory
(
id
)
}
}
impl
ConnectionPath
for
StorePath
{
fn
as_path
(
&
self
)
-
>
Cow
<
'
_
Path
>
{
match
self
{
Self
:
:
OnDisk
(
buf
)
=
>
Cow
:
:
Borrowed
(
buf
.
as_path
(
)
)
Self
:
:
InMemory
(
id
)
=
>
{
Cow
:
:
Owned
(
format
!
(
"
file
:
kvstore
-
{
id
}
?
mode
=
memory
&
cache
=
shared
"
)
.
into
(
)
)
}
}
}
fn
flags
(
&
self
)
-
>
OpenFlags
{
match
self
{
Self
:
:
OnDisk
(
_
)
=
>
OpenFlags
:
:
empty
(
)
Self
:
:
InMemory
(
_
)
=
>
{
OpenFlags
:
:
SQLITE_OPEN_URI
}
}
}
}
struct
OpenStoreGuard
<
'
a
>
{
store
:
Arc
<
OpenStore
>
_guard
:
OperationGuard
<
'
a
>
}
impl
<
'
a
>
OpenStoreGuard
<
'
a
>
{
fn
new
(
store
:
Arc
<
OpenStore
>
guard
:
OperationGuard
<
'
a
>
)
-
>
Self
{
Self
{
store
_guard
:
guard
}
}
}
pub
struct
Writer
<
'
a
>
(
OpenStoreGuard
<
'
a
>
)
;
impl
<
'
a
>
Deref
for
Writer
<
'
a
>
{
type
Target
=
Connection
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
.
store
.
writer
}
}
pub
struct
Reader
<
'
a
>
(
OpenStoreGuard
<
'
a
>
)
;
impl
<
'
a
>
Deref
for
Reader
<
'
a
>
{
type
Target
=
Connection
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
.
store
.
reader
}
}
#
[
derive
(
Debug
)
]
enum
StoreState
{
Created
(
StorePath
)
Open
(
Arc
<
OpenStore
>
)
Closed
}
#
[
derive
(
Debug
)
]
struct
OpenStore
{
writer
:
Connection
reader
:
Connection
}
impl
OpenStore
{
fn
new
(
path
:
&
StorePath
)
-
>
Result
<
Self
StoreError
>
{
let
writer
=
Connection
:
:
new
:
:
<
Schema
>
(
path
ConnectionType
:
:
ReadWrite
)
?
;
let
reader
=
Connection
:
:
new
:
:
<
Schema
>
(
path
ConnectionType
:
:
ReadOnly
)
?
;
Ok
(
Self
{
writer
reader
}
)
}
fn
close
(
self
)
{
let
_
=
self
.
reader
.
into_inner
(
)
.
close
(
)
;
let
_
=
self
.
writer
.
into_inner
(
)
.
close
(
)
;
}
}
#
[
derive
(
Debug
)
]
struct
OperationWaiter
{
count
:
Mutex
<
usize
>
cvar
:
Condvar
}
impl
OperationWaiter
{
fn
new
(
)
-
>
Self
{
Self
{
count
:
Mutex
:
:
new
(
0
)
cvar
:
Condvar
:
:
new
(
)
}
}
fn
guard
(
&
self
)
-
>
OperationGuard
<
'
_
>
{
*
self
.
count
.
lock
(
)
.
unwrap
(
)
+
=
1
;
OperationGuard
(
self
)
}
fn
wait
(
&
self
)
{
let
mut
count
=
self
.
count
.
lock
(
)
.
unwrap
(
)
;
while
*
count
>
0
{
count
=
self
.
cvar
.
wait
(
count
)
.
unwrap
(
)
;
}
}
}
struct
OperationGuard
<
'
a
>
(
&
'
a
OperationWaiter
)
;
impl
<
'
a
>
Drop
for
OperationGuard
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
let
mut
count
=
self
.
0
.
count
.
lock
(
)
.
unwrap
(
)
;
*
count
-
=
1
;
if
*
count
=
=
0
{
self
.
0
.
cvar
.
notify_all
(
)
;
}
}
}
#
[
derive
(
thiserror
:
:
Error
Debug
)
]
pub
enum
StoreError
{
#
[
error
(
"
schema
:
{
0
}
"
)
]
Schema
(
#
[
from
]
SchemaError
)
#
[
error
(
"
closed
"
)
]
Closed
#
[
error
(
"
sqlite
:
{
0
}
"
)
]
Sqlite
(
#
[
from
]
rusqlite
:
:
Error
)
}
