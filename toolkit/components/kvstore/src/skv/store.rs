use
std
:
:
{
borrow
:
:
Cow
ffi
:
:
OsStr
fmt
:
:
Write
mem
ops
:
:
Deref
path
:
:
{
Path
PathBuf
}
sync
:
:
{
atomic
:
:
{
self
AtomicUsize
}
Arc
Condvar
Mutex
}
time
:
:
SystemTime
}
;
use
chrono
:
:
{
DateTime
Utc
}
;
use
rusqlite
:
:
OpenFlags
;
use
crate
:
:
skv
:
:
{
checker
:
:
{
Checker
CheckerAction
IntoChecker
}
connection
:
:
{
Connection
ConnectionIncident
ConnectionPath
ConnectionType
ToConnectionIncident
}
maintenance
:
:
MaintenanceError
schema
:
:
{
Schema
SchemaError
}
}
;
#
[
derive
(
Debug
)
]
pub
struct
Store
{
path
:
StorePath
state
:
Mutex
<
StoreState
>
waiter
:
OperationWaiter
}
impl
Store
{
pub
fn
new
(
path
:
StorePath
)
-
>
Self
{
Self
{
path
state
:
Mutex
:
:
new
(
StoreState
:
:
Created
)
waiter
:
OperationWaiter
:
:
new
(
)
}
}
fn
open
(
&
self
)
-
>
Result
<
OpenStoreGuard
<
'
_
>
StoreError
>
{
let
guard
=
{
let
mut
state
=
self
.
state
.
lock
(
)
.
unwrap
(
)
;
loop
{
let
result
=
match
&
*
state
{
StoreState
:
:
Created
=
>
{
let
store
=
Arc
:
:
new
(
OpenStore
:
:
new
(
&
self
.
path
)
?
)
;
*
state
=
StoreState
:
:
Open
(
store
)
;
continue
;
}
StoreState
:
:
Open
(
store
)
=
>
{
let
store
=
store
.
clone
(
)
;
match
store
.
writer
.
incidents
(
)
.
into_checker
(
)
{
CheckerAction
:
:
Skip
=
>
{
let
guard
=
OpenStoreGuard
:
:
new
(
store
self
.
waiter
.
guard
(
)
)
;
Ok
(
CheckedStore
:
:
Healthy
(
guard
)
)
}
CheckerAction
:
:
Check
(
checker
)
=
>
{
let
writer
=
Writer
(
OpenStoreGuard
:
:
new
(
store
.
clone
(
)
self
.
waiter
.
guard
(
)
)
)
;
*
state
=
StoreState
:
:
Maintenance
(
store
)
;
Err
(
UnhealthyStore
:
:
Check
(
writer
checker
)
)
}
CheckerAction
:
:
Replace
=
>
{
*
state
=
StoreState
:
:
Corrupt
;
Err
(
UnhealthyStore
:
:
Replace
(
store
)
)
}
}
}
StoreState
:
:
Maintenance
(
_
)
=
>
return
Err
(
StoreError
:
:
Busy
)
StoreState
:
:
Corrupt
=
>
return
Err
(
StoreError
:
:
Corrupt
)
StoreState
:
:
Closed
=
>
return
Err
(
StoreError
:
:
Closed
)
}
;
break
result
;
}
}
.
or_else
(
|
store
|
{
match
store
{
UnhealthyStore
:
:
Replace
(
store
)
=
>
{
Ok
(
CheckedStore
:
:
Corrupt
(
store
StoreError
:
:
Corrupt
)
)
}
UnhealthyStore
:
:
Check
(
writer
checker
)
=
>
{
let
result
=
writer
.
maintenance
(
checker
)
.
map_err
(
StoreError
:
:
Maintenance
)
;
{
let
mut
state
=
self
.
state
.
lock
(
)
.
unwrap
(
)
;
let
StoreState
:
:
Maintenance
(
store
)
=
&
*
state
else
{
return
result
.
and_then
(
|
_
|
{
Err
(
StoreError
:
:
Closed
)
}
)
;
}
;
let
store
=
store
.
clone
(
)
;
match
result
{
Ok
(
(
)
)
=
>
{
let
guard
=
OpenStoreGuard
:
:
new
(
store
.
clone
(
)
self
.
waiter
.
guard
(
)
)
;
*
state
=
StoreState
:
:
Open
(
store
)
;
Ok
(
CheckedStore
:
:
Healthy
(
guard
)
)
}
Err
(
err
)
=
>
{
*
state
=
StoreState
:
:
Corrupt
;
Ok
(
CheckedStore
:
:
Corrupt
(
store
err
)
)
}
}
}
}
}
}
)
?
;
match
guard
{
CheckedStore
:
:
Healthy
(
guard
)
=
>
Ok
(
guard
)
CheckedStore
:
:
Corrupt
(
store
err
)
=
>
{
store
.
reader
.
interrupt
(
)
;
store
.
writer
.
interrupt
(
)
;
self
.
waiter
.
wait
(
)
;
let
store
=
Arc
:
:
into_inner
(
store
)
.
expect
(
"
invariant
violation
"
)
;
store
.
close
(
)
;
if
let
Some
(
path
)
=
self
.
path
.
on_disk
(
)
{
rename_corrupt_database_file
(
&
path
)
;
}
Err
(
err
)
}
}
}
pub
fn
writer
(
&
self
)
-
>
Result
<
Writer
<
'
_
>
StoreError
>
{
Ok
(
Writer
(
self
.
open
(
)
?
)
)
}
pub
fn
reader
(
&
self
)
-
>
Result
<
Reader
<
'
_
>
StoreError
>
{
Ok
(
Reader
(
self
.
open
(
)
?
)
)
}
pub
fn
close
(
&
self
)
{
let
store
=
match
mem
:
:
replace
(
&
mut
*
self
.
state
.
lock
(
)
.
unwrap
(
)
StoreState
:
:
Closed
)
{
StoreState
:
:
Created
|
StoreState
:
:
Closed
|
StoreState
:
:
Corrupt
=
>
return
StoreState
:
:
Open
(
store
)
=
>
{
store
.
reader
.
interrupt
(
)
;
store
}
StoreState
:
:
Maintenance
(
store
)
=
>
{
store
.
reader
.
interrupt
(
)
;
store
.
writer
.
interrupt
(
)
;
store
}
}
;
self
.
waiter
.
wait
(
)
;
let
store
=
Arc
:
:
into_inner
(
store
)
.
expect
(
"
invariant
violation
"
)
;
store
.
close
(
)
;
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
pub
enum
StorePath
{
OnDisk
(
PathBuf
)
InMemory
(
usize
)
}
impl
StorePath
{
pub
const
IN_MEMORY_DATABASE_NAME
:
&
'
static
str
=
"
:
memory
:
"
;
const
DEFAULT_DATABASE_FILE_NAME
:
&
'
static
str
=
"
kvstore
.
sqlite
"
;
pub
fn
for_storage_dir
(
dir
:
impl
Into
<
PathBuf
>
)
-
>
Self
{
let
mut
path
=
dir
.
into
(
)
;
path
.
push
(
Self
:
:
DEFAULT_DATABASE_FILE_NAME
)
;
Self
:
:
OnDisk
(
path
)
}
pub
fn
for_in_memory
(
)
-
>
Self
{
static
NEXT_IN_MEMORY_DATABASE_ID
:
AtomicUsize
=
AtomicUsize
:
:
new
(
1
)
;
let
id
=
NEXT_IN_MEMORY_DATABASE_ID
.
fetch_add
(
1
atomic
:
:
Ordering
:
:
Relaxed
)
;
Self
:
:
InMemory
(
id
)
}
pub
fn
on_disk
(
&
self
)
-
>
Option
<
OnDiskStorePath
<
'
_
>
>
{
match
self
{
Self
:
:
OnDisk
(
buf
)
=
>
buf
.
file_name
(
)
.
map
(
|
name
|
OnDiskStorePath
:
:
new
(
buf
.
parent
(
)
name
.
into
(
)
)
)
Self
:
:
InMemory
(
_
)
=
>
None
}
}
}
impl
ConnectionPath
for
StorePath
{
fn
as_path
(
&
self
)
-
>
Cow
<
'
_
Path
>
{
match
self
{
Self
:
:
OnDisk
(
buf
)
=
>
Cow
:
:
Borrowed
(
buf
.
as_path
(
)
)
Self
:
:
InMemory
(
id
)
=
>
{
Cow
:
:
Owned
(
format
!
(
"
file
:
kvstore
-
{
id
}
?
mode
=
memory
&
cache
=
shared
"
)
.
into
(
)
)
}
}
}
fn
flags
(
&
self
)
-
>
OpenFlags
{
match
self
{
Self
:
:
OnDisk
(
_
)
=
>
OpenFlags
:
:
empty
(
)
Self
:
:
InMemory
(
_
)
=
>
{
OpenFlags
:
:
SQLITE_OPEN_URI
}
}
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
pub
struct
OnDiskStorePath
<
'
a
>
{
dir
:
Option
<
&
'
a
Path
>
name
:
Cow
<
'
a
OsStr
>
}
impl
<
'
a
>
OnDiskStorePath
<
'
a
>
{
fn
new
(
dir
:
Option
<
&
'
a
Path
>
name
:
Cow
<
'
a
OsStr
>
)
-
>
Self
{
Self
{
dir
name
}
}
pub
fn
wal
(
&
self
)
-
>
PathBuf
{
let
mut
name
=
self
.
name
.
clone
(
)
.
into_owned
(
)
;
write
!
(
&
mut
name
"
-
wal
"
)
.
unwrap
(
)
;
self
.
dir
.
map
(
|
dir
|
dir
.
join
(
&
name
)
)
.
unwrap_or
(
name
.
into
(
)
)
}
pub
fn
shm
(
&
self
)
-
>
PathBuf
{
let
mut
name
=
self
.
name
.
clone
(
)
.
into_owned
(
)
;
write
!
(
&
mut
name
"
-
shm
"
)
.
unwrap
(
)
;
self
.
dir
.
map
(
|
dir
|
dir
.
join
(
&
name
)
)
.
unwrap_or
(
name
.
into
(
)
)
}
pub
fn
to_corrupt
(
&
self
)
-
>
OnDiskStorePath
<
'
a
>
{
let
now
=
DateTime
:
:
<
Utc
>
:
:
from
(
SystemTime
:
:
now
(
)
)
;
let
mut
name
=
self
.
name
.
clone
(
)
.
into_owned
(
)
;
write
!
(
&
mut
name
"
.
corrupt
-
{
}
"
now
.
format
(
"
%
Y
%
m
%
d
%
H
%
M
%
S
"
)
)
.
unwrap
(
)
;
Self
:
:
new
(
self
.
dir
name
.
into
(
)
)
}
}
impl
<
'
a
>
ConnectionPath
for
OnDiskStorePath
<
'
a
>
{
fn
as_path
(
&
self
)
-
>
Cow
<
'
_
Path
>
{
match
self
.
dir
{
Some
(
dir
)
=
>
Cow
:
:
Owned
(
dir
.
join
(
&
self
.
name
)
)
None
=
>
Cow
:
:
Borrowed
(
Path
:
:
new
(
&
self
.
name
)
)
}
}
fn
flags
(
&
self
)
-
>
OpenFlags
{
OpenFlags
:
:
empty
(
)
}
}
fn
rename_corrupt_database_file
(
source
:
&
OnDiskStorePath
<
'
_
>
)
{
let
destination
=
source
.
to_corrupt
(
)
;
let
_
=
std
:
:
fs
:
:
rename
(
source
.
as_path
(
)
destination
.
as_path
(
)
)
;
let
_
=
std
:
:
fs
:
:
rename
(
source
.
wal
(
)
destination
.
wal
(
)
)
;
let
_
=
std
:
:
fs
:
:
rename
(
source
.
shm
(
)
destination
.
shm
(
)
)
;
}
struct
OpenStoreGuard
<
'
a
>
{
store
:
Arc
<
OpenStore
>
_guard
:
OperationGuard
<
'
a
>
}
impl
<
'
a
>
OpenStoreGuard
<
'
a
>
{
fn
new
(
store
:
Arc
<
OpenStore
>
guard
:
OperationGuard
<
'
a
>
)
-
>
Self
{
Self
{
store
_guard
:
guard
}
}
}
pub
struct
Writer
<
'
a
>
(
OpenStoreGuard
<
'
a
>
)
;
impl
<
'
a
>
Deref
for
Writer
<
'
a
>
{
type
Target
=
Connection
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
.
store
.
writer
}
}
pub
struct
Reader
<
'
a
>
(
OpenStoreGuard
<
'
a
>
)
;
impl
<
'
a
>
Deref
for
Reader
<
'
a
>
{
type
Target
=
Connection
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
.
store
.
reader
}
}
#
[
derive
(
Debug
)
]
enum
StoreState
{
Created
Open
(
Arc
<
OpenStore
>
)
Maintenance
(
Arc
<
OpenStore
>
)
Corrupt
Closed
}
#
[
derive
(
Debug
)
]
struct
OpenStore
{
writer
:
Connection
reader
:
Connection
}
impl
OpenStore
{
fn
new
(
path
:
&
StorePath
)
-
>
Result
<
Self
StoreError
>
{
Ok
(
match
Self
:
:
open
(
path
)
{
Ok
(
store
)
=
>
store
Err
(
StoreError
:
:
Sqlite
(
err
)
)
=
>
{
let
(
Some
(
code
)
Some
(
path
)
)
=
(
err
.
sqlite_error_code
(
)
path
.
on_disk
(
)
)
else
{
return
Err
(
err
.
into
(
)
)
;
}
;
match
code
{
rusqlite
:
:
ErrorCode
:
:
NotADatabase
|
rusqlite
:
:
ErrorCode
:
:
DatabaseCorrupt
=
>
{
rename_corrupt_database_file
(
&
path
)
;
Self
:
:
open
(
&
path
)
?
}
_
=
>
return
Err
(
err
.
into
(
)
)
}
}
Err
(
err
)
=
>
return
Err
(
err
)
}
)
}
fn
open
(
path
:
&
impl
ConnectionPath
)
-
>
Result
<
Self
StoreError
>
{
let
writer
=
Connection
:
:
new
:
:
<
Schema
>
(
path
ConnectionType
:
:
ReadWrite
)
?
;
let
reader
=
Connection
:
:
new
:
:
<
Schema
>
(
path
ConnectionType
:
:
ReadOnly
)
?
;
Ok
(
Self
{
writer
reader
}
)
}
fn
close
(
self
)
{
let
_
=
self
.
reader
.
into_inner
(
)
.
close
(
)
;
let
_
=
self
.
writer
.
into_inner
(
)
.
close
(
)
;
}
}
enum
UnhealthyStore
<
'
a
>
{
Check
(
Writer
<
'
a
>
Checker
)
Replace
(
Arc
<
OpenStore
>
)
}
enum
CheckedStore
<
'
a
>
{
Healthy
(
OpenStoreGuard
<
'
a
>
)
Corrupt
(
Arc
<
OpenStore
>
StoreError
)
}
#
[
derive
(
Debug
)
]
struct
OperationWaiter
{
count
:
Mutex
<
usize
>
cvar
:
Condvar
}
impl
OperationWaiter
{
fn
new
(
)
-
>
Self
{
Self
{
count
:
Mutex
:
:
new
(
0
)
cvar
:
Condvar
:
:
new
(
)
}
}
fn
guard
(
&
self
)
-
>
OperationGuard
<
'
_
>
{
*
self
.
count
.
lock
(
)
.
unwrap
(
)
+
=
1
;
OperationGuard
(
self
)
}
fn
wait
(
&
self
)
{
let
mut
count
=
self
.
count
.
lock
(
)
.
unwrap
(
)
;
while
*
count
>
0
{
count
=
self
.
cvar
.
wait
(
count
)
.
unwrap
(
)
;
}
}
}
struct
OperationGuard
<
'
a
>
(
&
'
a
OperationWaiter
)
;
impl
<
'
a
>
Drop
for
OperationGuard
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
let
mut
count
=
self
.
0
.
count
.
lock
(
)
.
unwrap
(
)
;
*
count
-
=
1
;
if
*
count
=
=
0
{
self
.
0
.
cvar
.
notify_all
(
)
;
}
}
}
#
[
derive
(
thiserror
:
:
Error
Debug
)
]
pub
enum
StoreError
{
#
[
error
(
"
schema
:
{
0
}
"
)
]
Schema
(
#
[
from
]
SchemaError
)
#
[
error
(
"
busy
"
)
]
Busy
#
[
error
(
"
maintenance
:
{
0
}
"
)
]
Maintenance
(
#
[
from
]
MaintenanceError
)
#
[
error
(
"
closed
"
)
]
Closed
#
[
error
(
"
corrupt
"
)
]
Corrupt
#
[
error
(
"
sqlite
:
{
0
}
"
)
]
Sqlite
(
#
[
from
]
rusqlite
:
:
Error
)
}
impl
ToConnectionIncident
for
StoreError
{
fn
to_incident
(
&
self
)
-
>
Option
<
ConnectionIncident
>
{
match
self
{
Self
:
:
Sqlite
(
err
)
=
>
err
.
to_incident
(
)
_
=
>
None
}
}
}
