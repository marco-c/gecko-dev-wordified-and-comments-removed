use
std
:
:
{
borrow
:
:
Cow
fmt
:
:
Debug
num
:
:
NonZero
path
:
:
Path
sync
:
:
Mutex
}
;
use
rusqlite
:
:
{
InterruptHandle
OpenFlags
Transaction
TransactionBehavior
}
;
pub
trait
ConnectionPath
{
fn
as_path
(
&
self
)
-
>
Cow
<
'
_
Path
>
;
fn
flags
(
&
self
)
-
>
OpenFlags
;
}
pub
trait
ConnectionOpener
{
const
MAX_SCHEMA_VERSION
:
u32
;
type
Error
:
From
<
rusqlite
:
:
Error
>
;
fn
setup
(
_conn
:
&
mut
rusqlite
:
:
Connection
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
Ok
(
(
)
)
}
fn
create
(
tx
:
&
mut
Transaction
<
'
_
>
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
fn
upgrade
(
tx
:
&
mut
Transaction
<
'
_
>
to_version
:
NonZero
<
u32
>
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
}
pub
struct
Connection
{
conn
:
Mutex
<
rusqlite
:
:
Connection
>
interrupt_handle
:
InterruptHandle
}
impl
Connection
{
pub
fn
new
<
O
P
>
(
path
:
&
P
type_
:
ConnectionType
)
-
>
Result
<
Self
O
:
:
Error
>
where
O
:
ConnectionOpener
P
:
ConnectionPath
{
let
mut
conn
=
rusqlite
:
:
Connection
:
:
open_with_flags
(
path
.
as_path
(
)
path
.
flags
(
)
.
union
(
type_
.
flags
(
)
)
)
?
;
O
:
:
setup
(
&
mut
conn
)
?
;
match
type_
{
ConnectionType
:
:
ReadOnly
=
>
Ok
(
Self
:
:
with_connection
(
conn
)
)
ConnectionType
:
:
ReadWrite
=
>
{
let
mut
tx
=
conn
.
transaction_with_behavior
(
TransactionBehavior
:
:
Exclusive
)
?
;
match
tx
.
query_row_and_then
(
"
PRAGMA
user_version
"
[
]
|
row
|
row
.
get
(
0
)
)
{
Ok
(
mut
version
1
.
.
)
=
>
{
while
version
<
O
:
:
MAX_SCHEMA_VERSION
{
O
:
:
upgrade
(
&
mut
tx
NonZero
:
:
new
(
version
+
1
)
.
unwrap
(
)
)
?
;
version
+
=
1
;
}
}
Ok
(
0
)
=
>
O
:
:
create
(
&
mut
tx
)
?
Err
(
err
)
=
>
Err
(
err
)
?
}
tx
.
execute_batch
(
&
format
!
(
"
PRAGMA
user_version
=
{
}
"
O
:
:
MAX_SCHEMA_VERSION
)
)
?
;
tx
.
commit
(
)
?
;
Ok
(
Self
:
:
with_connection
(
conn
)
)
}
}
}
fn
with_connection
(
conn
:
rusqlite
:
:
Connection
)
-
>
Self
{
let
interrupt_handle
=
conn
.
get_interrupt_handle
(
)
;
Self
{
conn
:
Mutex
:
:
new
(
conn
)
interrupt_handle
}
}
pub
fn
read
<
T
E
>
(
&
self
f
:
impl
FnOnce
(
&
rusqlite
:
:
Connection
)
-
>
Result
<
T
E
>
)
-
>
Result
<
T
E
>
{
let
conn
=
self
.
conn
.
lock
(
)
.
unwrap
(
)
;
f
(
&
*
conn
)
}
pub
fn
write
<
T
E
>
(
&
self
f
:
impl
FnOnce
(
&
mut
Transaction
<
'
_
>
)
-
>
Result
<
T
E
>
)
-
>
Result
<
T
E
>
where
E
:
From
<
rusqlite
:
:
Error
>
{
let
mut
conn
=
self
.
conn
.
lock
(
)
.
unwrap
(
)
;
let
mut
tx
=
conn
.
transaction_with_behavior
(
TransactionBehavior
:
:
Immediate
)
?
;
let
result
=
f
(
&
mut
tx
)
?
;
tx
.
commit
(
)
?
;
Ok
(
result
)
}
pub
fn
interrupt
(
&
self
)
{
self
.
interrupt_handle
.
interrupt
(
)
}
pub
fn
into_inner
(
self
)
-
>
rusqlite
:
:
Connection
{
Mutex
:
:
into_inner
(
self
.
conn
)
.
unwrap
(
)
}
}
impl
Debug
for
Connection
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
f
.
write_str
(
"
Connection
{
.
.
}
"
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
enum
ConnectionType
{
ReadOnly
ReadWrite
}
impl
ConnectionType
{
fn
flags
(
self
)
-
>
OpenFlags
{
match
self
{
ConnectionType
:
:
ReadOnly
=
>
{
OpenFlags
:
:
SQLITE_OPEN_NO_MUTEX
|
OpenFlags
:
:
SQLITE_OPEN_EXRESCODE
|
OpenFlags
:
:
SQLITE_OPEN_READ_ONLY
}
ConnectionType
:
:
ReadWrite
=
>
{
OpenFlags
:
:
SQLITE_OPEN_NO_MUTEX
|
OpenFlags
:
:
SQLITE_OPEN_EXRESCODE
|
OpenFlags
:
:
SQLITE_OPEN_CREATE
|
OpenFlags
:
:
SQLITE_OPEN_READ_WRITE
}
}
}
}
