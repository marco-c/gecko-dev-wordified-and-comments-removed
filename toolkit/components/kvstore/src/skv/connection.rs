use
std
:
:
{
borrow
:
:
Cow
fmt
:
:
Debug
num
:
:
NonZeroU32
path
:
:
Path
sync
:
:
Mutex
}
;
use
rusqlite
:
:
{
config
:
:
DbConfig
InterruptHandle
OpenFlags
Transaction
TransactionBehavior
}
;
use
crate
:
:
skv
;
pub
trait
ConnectionPath
{
fn
as_path
(
&
self
)
-
>
Cow
<
'
_
Path
>
;
fn
flags
(
&
self
)
-
>
OpenFlags
;
}
pub
trait
ToConnectionIncident
{
fn
to_incident
(
&
self
)
-
>
Option
<
ConnectionIncident
>
;
}
pub
trait
ConnectionMigrator
{
const
MAX_SCHEMA_VERSION
:
u32
;
type
Error
;
fn
create
(
tx
:
&
mut
Transaction
<
'
_
>
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
fn
upgrade
(
tx
:
&
mut
Transaction
<
'
_
>
to_version
:
NonZeroU32
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
}
pub
trait
ConnectionMaintenanceTask
{
type
Error
;
fn
run
(
self
conn
:
&
mut
rusqlite
:
:
Connection
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
}
pub
struct
Connection
{
conn
:
Mutex
<
rusqlite
:
:
Connection
>
interrupt_handle
:
InterruptHandle
incidents
:
Mutex
<
Vec
<
ConnectionIncident
>
>
}
impl
Connection
{
pub
fn
new
<
M
>
(
path
:
&
impl
ConnectionPath
type_
:
ConnectionType
)
-
>
Result
<
Self
M
:
:
Error
>
where
M
:
ConnectionMigrator
M
:
:
Error
:
From
<
rusqlite
:
:
Error
>
{
let
mut
conn
=
rusqlite
:
:
Connection
:
:
open_with_flags
(
path
.
as_path
(
)
path
.
flags
(
)
.
union
(
type_
.
flags
(
)
)
)
?
;
conn
.
execute_batch
(
"
PRAGMA
journal_mode
=
WAL
;
PRAGMA
journal_size_limit
=
524288
;
-
-
512
KB
.
PRAGMA
foreign_keys
=
ON
;
PRAGMA
temp_store
=
MEMORY
;
PRAGMA
secure_delete
=
ON
;
PRAGMA
auto_vacuum
=
INCREMENTAL
;
"
)
?
;
conn
.
set_db_config
(
DbConfig
:
:
SQLITE_DBCONFIG_DEFENSIVE
true
)
?
;
conn
.
set_db_config
(
DbConfig
:
:
SQLITE_DBCONFIG_DQS_DML
false
)
?
;
conn
.
set_db_config
(
DbConfig
:
:
SQLITE_DBCONFIG_DQS_DDL
false
)
?
;
conn
.
set_db_config
(
DbConfig
:
:
SQLITE_DBCONFIG_TRUSTED_SCHEMA
true
)
?
;
skv
:
:
functions
:
:
register
(
&
mut
conn
)
?
;
match
type_
{
ConnectionType
:
:
ReadOnly
=
>
Ok
(
Self
:
:
with_connection
(
conn
)
)
ConnectionType
:
:
ReadWrite
=
>
{
let
mut
tx
=
conn
.
transaction_with_behavior
(
TransactionBehavior
:
:
Exclusive
)
?
;
match
tx
.
query_row_and_then
(
"
PRAGMA
user_version
"
[
]
|
row
|
row
.
get
(
0
)
)
{
Ok
(
mut
version
1
.
.
)
=
>
{
while
version
<
M
:
:
MAX_SCHEMA_VERSION
{
M
:
:
upgrade
(
&
mut
tx
NonZeroU32
:
:
new
(
version
+
1
)
.
unwrap
(
)
)
?
;
version
+
=
1
;
}
}
Ok
(
0
)
=
>
M
:
:
create
(
&
mut
tx
)
?
Err
(
err
)
=
>
Err
(
err
)
?
}
tx
.
execute_batch
(
&
format
!
(
"
PRAGMA
user_version
=
{
}
;
"
M
:
:
MAX_SCHEMA_VERSION
)
)
?
;
tx
.
commit
(
)
?
;
Ok
(
Self
:
:
with_connection
(
conn
)
)
}
}
}
fn
with_connection
(
conn
:
rusqlite
:
:
Connection
)
-
>
Self
{
let
interrupt_handle
=
conn
.
get_interrupt_handle
(
)
;
Self
{
conn
:
Mutex
:
:
new
(
conn
)
interrupt_handle
incidents
:
Mutex
:
:
default
(
)
}
}
pub
fn
incidents
(
&
self
)
-
>
ConnectionIncidents
<
'
_
>
{
ConnectionIncidents
(
self
)
}
pub
fn
read
<
T
E
>
(
&
self
f
:
impl
FnOnce
(
&
rusqlite
:
:
Connection
)
-
>
Result
<
T
E
>
)
-
>
Result
<
T
E
>
where
E
:
ToConnectionIncident
{
self
.
reporting
(
|
conn
|
f
(
conn
)
)
}
pub
fn
write
<
T
E
>
(
&
self
f
:
impl
FnOnce
(
&
mut
Transaction
<
'
_
>
)
-
>
Result
<
T
E
>
)
-
>
Result
<
T
E
>
where
E
:
From
<
rusqlite
:
:
Error
>
+
ToConnectionIncident
{
self
.
reporting
(
|
conn
|
{
let
mut
tx
=
conn
.
transaction_with_behavior
(
TransactionBehavior
:
:
Immediate
)
?
;
let
value
=
f
(
&
mut
tx
)
?
;
tx
.
commit
(
)
?
;
Ok
(
value
)
}
)
}
pub
fn
maintenance
<
M
>
(
&
self
task
:
M
)
-
>
Result
<
(
)
M
:
:
Error
>
where
M
:
ConnectionMaintenanceTask
{
let
mut
conn
=
self
.
conn
.
lock
(
)
.
unwrap
(
)
;
task
.
run
(
&
mut
conn
)
}
pub
fn
interrupt
(
&
self
)
{
self
.
interrupt_handle
.
interrupt
(
)
}
pub
fn
into_inner
(
self
)
-
>
rusqlite
:
:
Connection
{
Mutex
:
:
into_inner
(
self
.
conn
)
.
unwrap
(
)
}
fn
reporting
<
T
E
>
(
&
self
f
:
impl
FnOnce
(
&
mut
rusqlite
:
:
Connection
)
-
>
Result
<
T
E
>
)
-
>
Result
<
T
E
>
where
E
:
ToConnectionIncident
{
let
result
=
{
let
mut
conn
=
self
.
conn
.
lock
(
)
.
unwrap
(
)
;
f
(
&
mut
*
conn
)
}
;
result
.
inspect_err
(
|
err
|
{
if
let
Some
(
incident
)
=
err
.
to_incident
(
)
{
self
.
incidents
.
lock
(
)
.
unwrap
(
)
.
push
(
incident
)
;
}
}
)
}
}
impl
Debug
for
Connection
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
f
.
write_str
(
"
Connection
{
.
.
}
"
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
ConnectionIncidents
<
'
a
>
(
&
'
a
Connection
)
;
impl
<
'
a
>
ConnectionIncidents
<
'
a
>
{
pub
fn
map
<
T
>
(
self
f
:
impl
FnOnce
(
UnresolvedIncidents
<
'
_
>
)
-
>
T
)
-
>
T
{
let
mut
incidents
=
self
.
0
.
incidents
.
lock
(
)
.
unwrap
(
)
;
f
(
UnresolvedIncidents
(
&
mut
incidents
)
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
UnresolvedIncidents
<
'
a
>
(
&
'
a
mut
Vec
<
ConnectionIncident
>
)
;
impl
<
'
a
>
UnresolvedIncidents
<
'
a
>
{
pub
fn
iter
(
&
self
)
-
>
impl
Iterator
<
Item
=
ConnectionIncident
>
+
'
_
{
self
.
0
.
iter
(
)
.
copied
(
)
}
pub
fn
resolve
(
self
)
{
self
.
0
.
clear
(
)
;
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
enum
ConnectionType
{
ReadOnly
ReadWrite
}
impl
ConnectionType
{
fn
flags
(
self
)
-
>
OpenFlags
{
match
self
{
ConnectionType
:
:
ReadOnly
=
>
{
OpenFlags
:
:
SQLITE_OPEN_NO_MUTEX
|
OpenFlags
:
:
SQLITE_OPEN_EXRESCODE
|
OpenFlags
:
:
SQLITE_OPEN_READ_ONLY
}
ConnectionType
:
:
ReadWrite
=
>
{
OpenFlags
:
:
SQLITE_OPEN_NO_MUTEX
|
OpenFlags
:
:
SQLITE_OPEN_EXRESCODE
|
OpenFlags
:
:
SQLITE_OPEN_CREATE
|
OpenFlags
:
:
SQLITE_OPEN_READ_WRITE
}
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
enum
ConnectionIncident
{
CorruptFile
CorruptIndex
CorruptForeignKey
}
impl
ToConnectionIncident
for
rusqlite
:
:
Error
{
fn
to_incident
(
&
self
)
-
>
Option
<
ConnectionIncident
>
{
let
Self
:
:
SqliteFailure
(
err
message
)
=
self
else
{
return
None
;
}
;
Some
(
match
(
err
.
code
err
.
extended_code
message
)
{
(
rusqlite
:
:
ErrorCode
:
:
DatabaseCorrupt
rusqlite
:
:
ffi
:
:
SQLITE_CORRUPT_INDEX
_
)
=
>
{
ConnectionIncident
:
:
CorruptIndex
}
(
rusqlite
:
:
ErrorCode
:
:
DatabaseCorrupt
_
_
)
=
>
ConnectionIncident
:
:
CorruptFile
(
rusqlite
:
:
ErrorCode
:
:
Unknown
_
Some
(
message
)
)
if
message
.
contains
(
"
foreign
key
mismatch
"
)
|
|
message
.
contains
(
"
no
such
table
"
)
=
>
{
ConnectionIncident
:
:
CorruptForeignKey
}
_
=
>
return
None
}
)
}
}
