extern
crate
xpcom
;
use
crossbeam_utils
:
:
atomic
:
:
AtomicCell
;
use
error
:
:
KeyValueError
;
use
moz_task
:
:
Task
;
use
nserror
:
:
{
nsresult
NS_ERROR_FAILURE
}
;
use
nsstring
:
:
nsCString
;
use
owned_value
:
:
owned_to_variant
;
use
rkv
:
:
backend
:
:
{
BackendInfo
SafeMode
SafeModeDatabase
SafeModeEnvironment
}
;
use
rkv
:
:
{
OwnedValue
StoreError
StoreOptions
Value
}
;
use
std
:
:
{
path
:
:
Path
str
sync
:
:
{
Arc
RwLock
}
}
;
use
storage_variant
:
:
VariantType
;
use
xpcom
:
:
{
interfaces
:
:
{
nsIKeyValueDatabaseCallback
nsIKeyValueEnumeratorCallback
nsIKeyValueVariantCallback
nsIKeyValueVoidCallback
nsIVariant
}
RefPtr
ThreadBoundRefPtr
}
;
use
KeyValueDatabase
;
use
KeyValueEnumerator
;
use
KeyValuePairResult
;
type
Manager
=
rkv
:
:
Manager
<
SafeModeEnvironment
>
;
type
Rkv
=
rkv
:
:
Rkv
<
SafeModeEnvironment
>
;
type
SingleStore
=
rkv
:
:
SingleStore
<
SafeModeDatabase
>
;
macro_rules
!
task_done
{
(
value
)
=
>
{
fn
done
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
/
/
If
TaskRunnable
.
run
(
)
calls
Task
.
done
(
)
to
return
a
result
/
/
on
the
main
thread
before
TaskRunnable
.
run
(
)
returns
on
the
database
/
/
thread
then
the
Task
will
get
dropped
on
the
database
thread
.
/
/
/
/
But
the
callback
is
an
nsXPCWrappedJS
that
isn
'
t
safe
to
release
/
/
on
the
database
thread
.
So
we
move
it
out
of
the
Task
here
to
ensure
/
/
it
gets
released
on
the
main
thread
.
let
threadbound
=
self
.
callback
.
swap
(
None
)
.
ok_or
(
NS_ERROR_FAILURE
)
?
;
let
callback
=
threadbound
.
get_ref
(
)
.
ok_or
(
NS_ERROR_FAILURE
)
?
;
match
self
.
result
.
swap
(
None
)
{
Some
(
Ok
(
value
)
)
=
>
unsafe
{
callback
.
Resolve
(
self
.
convert
(
value
)
?
.
coerce
(
)
)
}
Some
(
Err
(
err
)
)
=
>
unsafe
{
callback
.
Reject
(
&
*
nsCString
:
:
from
(
err
.
to_string
(
)
)
)
}
None
=
>
unsafe
{
callback
.
Reject
(
&
*
nsCString
:
:
from
(
"
unexpected
"
)
)
}
}
.
to_result
(
)
}
}
;
(
void
)
=
>
{
fn
done
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
/
/
If
TaskRunnable
.
run
(
)
calls
Task
.
done
(
)
to
return
a
result
/
/
on
the
main
thread
before
TaskRunnable
.
run
(
)
returns
on
the
database
/
/
thread
then
the
Task
will
get
dropped
on
the
database
thread
.
/
/
/
/
But
the
callback
is
an
nsXPCWrappedJS
that
isn
'
t
safe
to
release
/
/
on
the
database
thread
.
So
we
move
it
out
of
the
Task
here
to
ensure
/
/
it
gets
released
on
the
main
thread
.
let
threadbound
=
self
.
callback
.
swap
(
None
)
.
ok_or
(
NS_ERROR_FAILURE
)
?
;
let
callback
=
threadbound
.
get_ref
(
)
.
ok_or
(
NS_ERROR_FAILURE
)
?
;
match
self
.
result
.
swap
(
None
)
{
Some
(
Ok
(
(
)
)
)
=
>
unsafe
{
callback
.
Resolve
(
)
}
Some
(
Err
(
err
)
)
=
>
unsafe
{
callback
.
Reject
(
&
*
nsCString
:
:
from
(
err
.
to_string
(
)
)
)
}
None
=
>
unsafe
{
callback
.
Reject
(
&
*
nsCString
:
:
from
(
"
unexpected
"
)
)
}
}
.
to_result
(
)
}
}
;
}
type
RkvStoreTuple
=
(
Arc
<
RwLock
<
Rkv
>
>
SingleStore
)
;
const
RESIZE_RATIO
:
f32
=
0
.
85
;
const
INCREMENTAL_RESIZE_THRESHOLD
:
usize
=
52_428_800
;
const
INCREMENTAL_RESIZE_STEP
:
usize
=
5_242_880
;
const
PAGE_SIZE
:
usize
=
4096
;
const
PAGE_SIZE_MASK
:
usize
=
0b_1111_1111_1111
;
fn
round_to_pagesize
(
size
:
usize
)
-
>
usize
{
if
size
&
PAGE_SIZE_MASK
=
=
0
{
size
}
else
{
(
size
&
!
PAGE_SIZE_MASK
)
+
PAGE_SIZE
}
}
fn
active_resize
(
env
:
&
Rkv
)
-
>
Result
<
(
)
StoreError
>
{
let
info
=
env
.
info
(
)
?
;
let
current_size
=
info
.
map_size
(
)
;
let
size
=
if
current_size
<
INCREMENTAL_RESIZE_THRESHOLD
{
current_size
<
<
1
}
else
{
current_size
+
INCREMENTAL_RESIZE_STEP
}
;
env
.
set_map_size
(
size
)
?
;
Ok
(
(
)
)
}
fn
passive_resize
(
env
:
&
Rkv
wanted
:
usize
)
-
>
Result
<
(
)
StoreError
>
{
let
info
=
env
.
info
(
)
?
;
let
current_size
=
info
.
map_size
(
)
;
env
.
set_map_size
(
current_size
+
wanted
)
?
;
Ok
(
(
)
)
}
pub
struct
GetOrCreateTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueDatabaseCallback
>
>
>
path
:
nsCString
name
:
nsCString
result
:
AtomicCell
<
Option
<
Result
<
RkvStoreTuple
KeyValueError
>
>
>
}
impl
GetOrCreateTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueDatabaseCallback
>
path
:
nsCString
name
:
nsCString
)
-
>
GetOrCreateTask
{
GetOrCreateTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
path
name
result
:
AtomicCell
:
:
default
(
)
}
}
fn
convert
(
&
self
result
:
RkvStoreTuple
)
-
>
Result
<
RefPtr
<
KeyValueDatabase
>
KeyValueError
>
{
Ok
(
KeyValueDatabase
:
:
new
(
result
.
0
result
.
1
)
?
)
}
}
impl
Task
for
GetOrCreateTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
RkvStoreTuple
KeyValueError
>
{
let
store
;
let
mut
manager
=
Manager
:
:
singleton
(
)
.
write
(
)
?
;
let
path
=
Path
:
:
new
(
str
:
:
from_utf8
(
&
self
.
path
)
?
)
;
let
rkv
=
manager
.
get_or_create
(
path
Rkv
:
:
new
:
:
<
SafeMode
>
)
?
;
{
let
env
=
rkv
.
read
(
)
?
;
let
load_ratio
=
env
.
load_ratio
(
)
?
.
unwrap_or
(
0
.
0
)
;
if
load_ratio
>
RESIZE_RATIO
{
active_resize
(
&
env
)
?
;
}
store
=
env
.
open_single
(
str
:
:
from_utf8
(
&
self
.
name
)
?
StoreOptions
:
:
create
(
)
)
?
;
}
Ok
(
(
rkv
store
)
)
}
(
)
)
)
;
}
task_done
!
(
value
)
;
}
pub
struct
PutTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueVoidCallback
>
>
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
value
:
OwnedValue
result
:
AtomicCell
<
Option
<
Result
<
(
)
KeyValueError
>
>
>
}
impl
PutTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueVoidCallback
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
value
:
OwnedValue
)
-
>
PutTask
{
PutTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
rkv
store
key
value
result
:
AtomicCell
:
:
default
(
)
}
}
}
impl
Task
for
PutTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
(
)
KeyValueError
>
{
let
env
=
self
.
rkv
.
read
(
)
?
;
let
key
=
str
:
:
from_utf8
(
&
self
.
key
)
?
;
let
v
=
Value
:
:
from
(
&
self
.
value
)
;
let
mut
resized
=
false
;
loop
{
let
mut
writer
=
env
.
write
(
)
?
;
match
self
.
store
.
put
(
&
mut
writer
key
&
v
)
{
Ok
(
_
)
=
>
(
)
Err
(
StoreError
:
:
MapFull
)
if
!
resized
=
>
{
writer
.
abort
(
)
;
let
pair_size
=
key
.
len
(
)
+
v
.
serialized_size
(
)
.
map_err
(
StoreError
:
:
from
)
?
as
usize
;
let
wanted
=
round_to_pagesize
(
pair_size
)
;
passive_resize
(
&
env
wanted
)
?
;
resized
=
true
;
continue
;
}
Err
(
err
)
=
>
return
Err
(
KeyValueError
:
:
StoreError
(
err
)
)
}
writer
.
commit
(
)
?
;
break
;
}
Ok
(
(
)
)
}
(
)
)
)
;
}
task_done
!
(
void
)
;
}
pub
struct
WriteManyTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueVoidCallback
>
>
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
pairs
:
Vec
<
(
nsCString
Option
<
OwnedValue
>
)
>
result
:
AtomicCell
<
Option
<
Result
<
(
)
KeyValueError
>
>
>
}
impl
WriteManyTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueVoidCallback
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
pairs
:
Vec
<
(
nsCString
Option
<
OwnedValue
>
)
>
)
-
>
WriteManyTask
{
WriteManyTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
rkv
store
pairs
result
:
AtomicCell
:
:
default
(
)
}
}
fn
calc_pair_size
(
&
self
)
-
>
Result
<
usize
StoreError
>
{
let
mut
total
=
0
;
for
(
key
value
)
in
self
.
pairs
.
iter
(
)
{
if
let
Some
(
val
)
=
value
{
total
+
=
key
.
len
(
)
;
total
+
=
Value
:
:
from
(
val
)
.
serialized_size
(
)
.
map_err
(
StoreError
:
:
from
)
?
as
usize
;
}
}
Ok
(
total
)
}
}
impl
Task
for
WriteManyTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
(
)
KeyValueError
>
{
let
env
=
self
.
rkv
.
read
(
)
?
;
let
mut
resized
=
false
;
'
outer
:
loop
{
let
mut
writer
=
env
.
write
(
)
?
;
for
(
key
value
)
in
self
.
pairs
.
iter
(
)
{
let
key
=
str
:
:
from_utf8
(
key
)
?
;
match
value
{
Some
(
val
)
=
>
{
match
self
.
store
.
put
(
&
mut
writer
key
&
Value
:
:
from
(
val
)
)
{
Ok
(
_
)
=
>
(
)
Err
(
StoreError
:
:
MapFull
)
if
!
resized
=
>
{
writer
.
abort
(
)
;
let
pair_size
=
self
.
calc_pair_size
(
)
?
;
let
wanted
=
round_to_pagesize
(
pair_size
)
;
passive_resize
(
&
env
wanted
)
?
;
resized
=
true
;
continue
'
outer
;
}
Err
(
err
)
=
>
return
Err
(
KeyValueError
:
:
StoreError
(
err
)
)
}
}
None
=
>
{
match
self
.
store
.
delete
(
&
mut
writer
key
)
{
Ok
(
_
)
=
>
(
)
Err
(
StoreError
:
:
KeyValuePairNotFound
)
=
>
(
)
Err
(
err
)
=
>
return
Err
(
KeyValueError
:
:
StoreError
(
err
)
)
}
;
}
}
}
writer
.
commit
(
)
?
;
break
;
}
Ok
(
(
)
)
}
(
)
)
)
;
}
task_done
!
(
void
)
;
}
pub
struct
GetTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueVariantCallback
>
>
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
default_value
:
Option
<
OwnedValue
>
result
:
AtomicCell
<
Option
<
Result
<
Option
<
OwnedValue
>
KeyValueError
>
>
>
}
impl
GetTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueVariantCallback
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
default_value
:
Option
<
OwnedValue
>
)
-
>
GetTask
{
GetTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
rkv
store
key
default_value
result
:
AtomicCell
:
:
default
(
)
}
}
fn
convert
(
&
self
result
:
Option
<
OwnedValue
>
)
-
>
Result
<
RefPtr
<
nsIVariant
>
KeyValueError
>
{
Ok
(
match
result
{
Some
(
val
)
=
>
owned_to_variant
(
val
)
?
None
=
>
(
)
.
into_variant
(
)
}
)
}
}
impl
Task
for
GetTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
Option
<
OwnedValue
>
KeyValueError
>
{
let
key
=
str
:
:
from_utf8
(
&
self
.
key
)
?
;
let
env
=
self
.
rkv
.
read
(
)
?
;
let
reader
=
env
.
read
(
)
?
;
let
value
=
self
.
store
.
get
(
&
reader
key
)
?
;
Ok
(
match
value
{
Some
(
value
)
=
>
Some
(
OwnedValue
:
:
from
(
&
value
)
)
None
=
>
match
self
.
default_value
{
Some
(
ref
val
)
=
>
Some
(
val
.
clone
(
)
)
None
=
>
None
}
}
)
}
(
)
)
)
;
}
task_done
!
(
value
)
;
}
pub
struct
HasTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueVariantCallback
>
>
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
result
:
AtomicCell
<
Option
<
Result
<
bool
KeyValueError
>
>
>
}
impl
HasTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueVariantCallback
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
)
-
>
HasTask
{
HasTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
rkv
store
key
result
:
AtomicCell
:
:
default
(
)
}
}
fn
convert
(
&
self
result
:
bool
)
-
>
Result
<
RefPtr
<
nsIVariant
>
KeyValueError
>
{
Ok
(
result
.
into_variant
(
)
)
}
}
impl
Task
for
HasTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
bool
KeyValueError
>
{
let
key
=
str
:
:
from_utf8
(
&
self
.
key
)
?
;
let
env
=
self
.
rkv
.
read
(
)
?
;
let
reader
=
env
.
read
(
)
?
;
let
value
=
self
.
store
.
get
(
&
reader
key
)
?
;
Ok
(
value
.
is_some
(
)
)
}
(
)
)
)
;
}
task_done
!
(
value
)
;
}
pub
struct
DeleteTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueVoidCallback
>
>
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
result
:
AtomicCell
<
Option
<
Result
<
(
)
KeyValueError
>
>
>
}
impl
DeleteTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueVoidCallback
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
)
-
>
DeleteTask
{
DeleteTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
rkv
store
key
result
:
AtomicCell
:
:
default
(
)
}
}
}
impl
Task
for
DeleteTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
(
)
KeyValueError
>
{
let
key
=
str
:
:
from_utf8
(
&
self
.
key
)
?
;
let
env
=
self
.
rkv
.
read
(
)
?
;
let
mut
writer
=
env
.
write
(
)
?
;
match
self
.
store
.
delete
(
&
mut
writer
key
)
{
Ok
(
_
)
=
>
(
)
Err
(
StoreError
:
:
KeyValuePairNotFound
)
=
>
(
)
Err
(
err
)
=
>
return
Err
(
KeyValueError
:
:
StoreError
(
err
)
)
}
;
writer
.
commit
(
)
?
;
Ok
(
(
)
)
}
(
)
)
)
;
}
task_done
!
(
void
)
;
}
pub
struct
ClearTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueVoidCallback
>
>
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
result
:
AtomicCell
<
Option
<
Result
<
(
)
KeyValueError
>
>
>
}
impl
ClearTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueVoidCallback
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
)
-
>
ClearTask
{
ClearTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
rkv
store
result
:
AtomicCell
:
:
default
(
)
}
}
}
impl
Task
for
ClearTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
(
)
KeyValueError
>
{
let
env
=
self
.
rkv
.
read
(
)
?
;
let
mut
writer
=
env
.
write
(
)
?
;
self
.
store
.
clear
(
&
mut
writer
)
?
;
writer
.
commit
(
)
?
;
Ok
(
(
)
)
}
(
)
)
)
;
}
task_done
!
(
void
)
;
}
pub
struct
EnumerateTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueEnumeratorCallback
>
>
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
from_key
:
nsCString
to_key
:
nsCString
result
:
AtomicCell
<
Option
<
Result
<
Vec
<
KeyValuePairResult
>
KeyValueError
>
>
>
}
impl
EnumerateTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueEnumeratorCallback
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
from_key
:
nsCString
to_key
:
nsCString
)
-
>
EnumerateTask
{
EnumerateTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
rkv
store
from_key
to_key
result
:
AtomicCell
:
:
default
(
)
}
}
fn
convert
(
&
self
result
:
Vec
<
KeyValuePairResult
>
)
-
>
Result
<
RefPtr
<
KeyValueEnumerator
>
KeyValueError
>
{
Ok
(
KeyValueEnumerator
:
:
new
(
result
)
)
}
}
impl
Task
for
EnumerateTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
Vec
<
KeyValuePairResult
>
KeyValueError
>
{
let
env
=
self
.
rkv
.
read
(
)
?
;
let
reader
=
env
.
read
(
)
?
;
let
from_key
=
str
:
:
from_utf8
(
&
self
.
from_key
)
?
;
let
to_key
=
str
:
:
from_utf8
(
&
self
.
to_key
)
?
;
let
iterator
=
if
from_key
.
is_empty
(
)
{
self
.
store
.
iter_start
(
&
reader
)
?
}
else
{
self
.
store
.
iter_from
(
&
reader
&
from_key
)
?
}
;
let
pairs
:
Vec
<
KeyValuePairResult
>
=
iterator
.
map
(
|
result
|
match
result
{
Ok
(
(
key
val
)
)
=
>
Ok
(
(
str
:
:
from_utf8
(
&
key
)
val
)
)
Err
(
err
)
=
>
Err
(
err
)
}
)
.
take_while
(
|
result
|
match
result
{
Ok
(
(
key
_val
)
)
=
>
{
if
to_key
.
is_empty
(
)
{
true
}
else
{
match
*
key
{
Ok
(
key
)
=
>
key
<
to_key
Err
(
_err
)
=
>
true
}
}
}
Err
(
_
)
=
>
true
}
)
.
map
(
|
result
|
match
result
{
Ok
(
(
key
val
)
)
=
>
match
(
key
val
)
{
(
Ok
(
key
)
val
)
=
>
Ok
(
(
key
.
to_owned
(
)
OwnedValue
:
:
from
(
&
val
)
)
)
(
Err
(
err
)
_
)
=
>
Err
(
err
.
into
(
)
)
}
Err
(
err
)
=
>
Err
(
KeyValueError
:
:
StoreError
(
err
)
)
}
)
.
collect
(
)
;
Ok
(
pairs
)
}
(
)
)
)
;
}
task_done
!
(
value
)
;
}
