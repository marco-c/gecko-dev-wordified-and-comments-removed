extern
crate
xpcom
;
use
crossbeam_utils
:
:
atomic
:
:
AtomicCell
;
use
error
:
:
KeyValueError
;
use
moz_task
:
:
Task
;
use
nserror
:
:
{
nsresult
NsresultExt
NS_ERROR_FAILURE
}
;
use
nsstring
:
:
{
nsCString
nsString
}
;
use
owned_value
:
:
{
value_to_owned
OwnedValue
}
;
use
rkv
:
:
{
Manager
Rkv
SingleStore
StoreError
StoreOptions
Value
}
;
use
std
:
:
{
path
:
:
Path
str
sync
:
:
{
Arc
RwLock
}
}
;
use
storage_variant
:
:
VariantType
;
use
xpcom
:
:
{
interfaces
:
:
{
nsIKeyValueDatabaseCallback
nsIKeyValueEnumeratorCallback
nsIKeyValueVariantCallback
nsIKeyValueVoidCallback
nsIThread
nsIVariant
}
RefPtr
ThreadBoundRefPtr
}
;
use
KeyValueDatabase
;
use
KeyValueEnumerator
;
use
KeyValuePairResult
;
macro_rules
!
task_done
{
(
value
)
=
>
{
fn
done
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
/
/
If
TaskRunnable
.
run
(
)
calls
Task
.
done
(
)
to
return
a
result
/
/
on
the
main
thread
before
TaskRunnable
.
run
(
)
returns
on
the
database
/
/
thread
then
the
Task
will
get
dropped
on
the
database
thread
.
/
/
/
/
But
the
callback
is
an
nsXPCWrappedJS
that
isn
'
t
safe
to
release
/
/
on
the
database
thread
.
So
we
move
it
out
of
the
Task
here
to
ensure
/
/
it
gets
released
on
the
main
thread
.
let
threadbound
=
self
.
callback
.
swap
(
None
)
.
ok_or
(
NS_ERROR_FAILURE
)
?
;
let
callback
=
threadbound
.
get_ref
(
)
.
ok_or
(
NS_ERROR_FAILURE
)
?
;
match
self
.
result
.
swap
(
None
)
{
Some
(
Ok
(
value
)
)
=
>
unsafe
{
callback
.
Resolve
(
self
.
convert
(
value
)
?
.
coerce
(
)
)
}
Some
(
Err
(
err
)
)
=
>
unsafe
{
callback
.
Reject
(
&
*
nsCString
:
:
from
(
err
.
to_string
(
)
)
)
}
None
=
>
unsafe
{
callback
.
Reject
(
&
*
nsCString
:
:
from
(
"
unexpected
"
)
)
}
}
.
to_result
(
)
}
}
;
(
void
)
=
>
{
fn
done
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
/
/
If
TaskRunnable
.
run
(
)
calls
Task
.
done
(
)
to
return
a
result
/
/
on
the
main
thread
before
TaskRunnable
.
run
(
)
returns
on
the
database
/
/
thread
then
the
Task
will
get
dropped
on
the
database
thread
.
/
/
/
/
But
the
callback
is
an
nsXPCWrappedJS
that
isn
'
t
safe
to
release
/
/
on
the
database
thread
.
So
we
move
it
out
of
the
Task
here
to
ensure
/
/
it
gets
released
on
the
main
thread
.
let
threadbound
=
self
.
callback
.
swap
(
None
)
.
ok_or
(
NS_ERROR_FAILURE
)
?
;
let
callback
=
threadbound
.
get_ref
(
)
.
ok_or
(
NS_ERROR_FAILURE
)
?
;
match
self
.
result
.
swap
(
None
)
{
Some
(
Ok
(
(
)
)
)
=
>
unsafe
{
callback
.
Resolve
(
)
}
Some
(
Err
(
err
)
)
=
>
unsafe
{
callback
.
Reject
(
&
*
nsCString
:
:
from
(
err
.
to_string
(
)
)
)
}
None
=
>
unsafe
{
callback
.
Reject
(
&
*
nsCString
:
:
from
(
"
unexpected
"
)
)
}
}
.
to_result
(
)
}
}
;
}
type
RkvStoreTuple
=
(
Arc
<
RwLock
<
Rkv
>
>
SingleStore
)
;
pub
struct
GetOrCreateTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueDatabaseCallback
>
>
>
thread
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIThread
>
>
>
path
:
nsCString
name
:
nsCString
result
:
AtomicCell
<
Option
<
Result
<
RkvStoreTuple
KeyValueError
>
>
>
}
impl
GetOrCreateTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueDatabaseCallback
>
thread
:
RefPtr
<
nsIThread
>
path
:
nsCString
name
:
nsCString
)
-
>
GetOrCreateTask
{
GetOrCreateTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
thread
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
thread
)
)
)
path
name
result
:
AtomicCell
:
:
default
(
)
}
}
fn
convert
(
&
self
result
:
RkvStoreTuple
)
-
>
Result
<
RefPtr
<
KeyValueDatabase
>
KeyValueError
>
{
let
thread
=
self
.
thread
.
swap
(
None
)
.
ok_or
(
NS_ERROR_FAILURE
)
?
;
Ok
(
KeyValueDatabase
:
:
new
(
result
.
0
result
.
1
thread
)
)
}
}
impl
Task
for
GetOrCreateTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
RkvStoreTuple
KeyValueError
>
{
let
mut
writer
=
Manager
:
:
singleton
(
)
.
write
(
)
?
;
let
rkv
=
writer
.
get_or_create
(
Path
:
:
new
(
str
:
:
from_utf8
(
&
self
.
path
)
?
)
Rkv
:
:
new
)
?
;
let
store
=
rkv
.
write
(
)
?
.
open_single
(
str
:
:
from_utf8
(
&
self
.
name
)
?
StoreOptions
:
:
create
(
)
)
?
;
Ok
(
(
rkv
store
)
)
}
(
)
)
)
;
}
task_done
!
(
value
)
;
}
pub
struct
PutTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueVoidCallback
>
>
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
value
:
OwnedValue
result
:
AtomicCell
<
Option
<
Result
<
(
)
KeyValueError
>
>
>
}
impl
PutTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueVoidCallback
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
value
:
OwnedValue
)
-
>
PutTask
{
PutTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
rkv
store
key
value
result
:
AtomicCell
:
:
default
(
)
}
}
}
impl
Task
for
PutTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
(
)
KeyValueError
>
{
let
key
=
str
:
:
from_utf8
(
&
self
.
key
)
?
;
let
env
=
self
.
rkv
.
read
(
)
?
;
let
mut
writer
=
env
.
write
(
)
?
;
let
value
=
match
self
.
value
{
OwnedValue
:
:
Bool
(
val
)
=
>
Value
:
:
Bool
(
val
)
OwnedValue
:
:
I64
(
val
)
=
>
Value
:
:
I64
(
val
)
OwnedValue
:
:
F64
(
val
)
=
>
Value
:
:
F64
(
val
)
OwnedValue
:
:
Str
(
ref
val
)
=
>
Value
:
:
Str
(
&
val
)
}
;
self
.
store
.
put
(
&
mut
writer
key
&
value
)
?
;
writer
.
commit
(
)
?
;
Ok
(
(
)
)
}
(
)
)
)
;
}
task_done
!
(
void
)
;
}
pub
struct
GetTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueVariantCallback
>
>
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
default_value
:
Option
<
OwnedValue
>
result
:
AtomicCell
<
Option
<
Result
<
Option
<
OwnedValue
>
KeyValueError
>
>
>
}
impl
GetTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueVariantCallback
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
default_value
:
Option
<
OwnedValue
>
)
-
>
GetTask
{
GetTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
rkv
store
key
default_value
result
:
AtomicCell
:
:
default
(
)
}
}
fn
convert
(
&
self
result
:
Option
<
OwnedValue
>
)
-
>
Result
<
RefPtr
<
nsIVariant
>
KeyValueError
>
{
Ok
(
match
result
{
Some
(
OwnedValue
:
:
Bool
(
val
)
)
=
>
val
.
into_variant
(
)
Some
(
OwnedValue
:
:
I64
(
val
)
)
=
>
val
.
into_variant
(
)
Some
(
OwnedValue
:
:
F64
(
val
)
)
=
>
val
.
into_variant
(
)
Some
(
OwnedValue
:
:
Str
(
ref
val
)
)
=
>
nsString
:
:
from
(
val
)
.
into_variant
(
)
None
=
>
(
)
.
into_variant
(
)
}
)
}
}
impl
Task
for
GetTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
Option
<
OwnedValue
>
KeyValueError
>
{
let
key
=
str
:
:
from_utf8
(
&
self
.
key
)
?
;
let
env
=
self
.
rkv
.
read
(
)
?
;
let
reader
=
env
.
read
(
)
?
;
let
value
=
self
.
store
.
get
(
&
reader
key
)
?
;
Ok
(
match
value
{
Some
(
Value
:
:
Bool
(
val
)
)
=
>
Some
(
OwnedValue
:
:
Bool
(
val
)
)
Some
(
Value
:
:
I64
(
val
)
)
=
>
Some
(
OwnedValue
:
:
I64
(
val
)
)
Some
(
Value
:
:
F64
(
val
)
)
=
>
Some
(
OwnedValue
:
:
F64
(
val
)
)
Some
(
Value
:
:
Str
(
val
)
)
=
>
Some
(
OwnedValue
:
:
Str
(
val
.
to_owned
(
)
)
)
Some
(
_value
)
=
>
return
Err
(
KeyValueError
:
:
UnexpectedValue
)
None
=
>
match
self
.
default_value
{
Some
(
ref
val
)
=
>
Some
(
val
.
clone
(
)
)
None
=
>
None
}
}
)
}
(
)
)
)
;
}
task_done
!
(
value
)
;
}
pub
struct
HasTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueVariantCallback
>
>
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
result
:
AtomicCell
<
Option
<
Result
<
bool
KeyValueError
>
>
>
}
impl
HasTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueVariantCallback
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
)
-
>
HasTask
{
HasTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
rkv
store
key
result
:
AtomicCell
:
:
default
(
)
}
}
fn
convert
(
&
self
result
:
bool
)
-
>
Result
<
RefPtr
<
nsIVariant
>
KeyValueError
>
{
Ok
(
result
.
into_variant
(
)
)
}
}
impl
Task
for
HasTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
bool
KeyValueError
>
{
let
key
=
str
:
:
from_utf8
(
&
self
.
key
)
?
;
let
env
=
self
.
rkv
.
read
(
)
?
;
let
reader
=
env
.
read
(
)
?
;
let
value
=
self
.
store
.
get
(
&
reader
key
)
?
;
Ok
(
value
.
is_some
(
)
)
}
(
)
)
)
;
}
task_done
!
(
value
)
;
}
pub
struct
DeleteTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueVoidCallback
>
>
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
result
:
AtomicCell
<
Option
<
Result
<
(
)
KeyValueError
>
>
>
}
impl
DeleteTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueVoidCallback
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
key
:
nsCString
)
-
>
DeleteTask
{
DeleteTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
rkv
store
key
result
:
AtomicCell
:
:
default
(
)
}
}
}
impl
Task
for
DeleteTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
(
)
KeyValueError
>
{
let
key
=
str
:
:
from_utf8
(
&
self
.
key
)
?
;
let
env
=
self
.
rkv
.
read
(
)
?
;
let
mut
writer
=
env
.
write
(
)
?
;
match
self
.
store
.
delete
(
&
mut
writer
key
)
{
Ok
(
_
)
=
>
(
)
Err
(
StoreError
:
:
LmdbError
(
lmdb
:
:
Error
:
:
NotFound
)
)
=
>
(
)
Err
(
err
)
=
>
return
Err
(
KeyValueError
:
:
StoreError
(
err
)
)
}
;
writer
.
commit
(
)
?
;
Ok
(
(
)
)
}
(
)
)
)
;
}
task_done
!
(
void
)
;
}
pub
struct
EnumerateTask
{
callback
:
AtomicCell
<
Option
<
ThreadBoundRefPtr
<
nsIKeyValueEnumeratorCallback
>
>
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
from_key
:
nsCString
to_key
:
nsCString
result
:
AtomicCell
<
Option
<
Result
<
Vec
<
KeyValuePairResult
>
KeyValueError
>
>
>
}
impl
EnumerateTask
{
pub
fn
new
(
callback
:
RefPtr
<
nsIKeyValueEnumeratorCallback
>
rkv
:
Arc
<
RwLock
<
Rkv
>
>
store
:
SingleStore
from_key
:
nsCString
to_key
:
nsCString
)
-
>
EnumerateTask
{
EnumerateTask
{
callback
:
AtomicCell
:
:
new
(
Some
(
ThreadBoundRefPtr
:
:
new
(
callback
)
)
)
rkv
store
from_key
to_key
result
:
AtomicCell
:
:
default
(
)
}
}
fn
convert
(
&
self
result
:
Vec
<
KeyValuePairResult
>
)
-
>
Result
<
RefPtr
<
KeyValueEnumerator
>
KeyValueError
>
{
Ok
(
KeyValueEnumerator
:
:
new
(
result
)
)
}
}
impl
Task
for
EnumerateTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
Vec
<
KeyValuePairResult
>
KeyValueError
>
{
let
env
=
self
.
rkv
.
read
(
)
?
;
let
reader
=
env
.
read
(
)
?
;
let
from_key
=
str
:
:
from_utf8
(
&
self
.
from_key
)
?
;
let
to_key
=
str
:
:
from_utf8
(
&
self
.
to_key
)
?
;
let
iterator
=
if
from_key
.
is_empty
(
)
{
self
.
store
.
iter_start
(
&
reader
)
?
}
else
{
self
.
store
.
iter_from
(
&
reader
&
from_key
)
?
}
;
let
pairs
:
Vec
<
KeyValuePairResult
>
=
iterator
.
map
(
|
result
|
match
result
{
Ok
(
(
key
val
)
)
=
>
Ok
(
(
str
:
:
from_utf8
(
&
key
)
val
)
)
Err
(
err
)
=
>
Err
(
err
)
}
)
.
take_while
(
|
result
|
match
result
{
Ok
(
(
key
_val
)
)
=
>
{
if
to_key
.
is_empty
(
)
{
true
}
else
{
match
*
key
{
Ok
(
key
)
=
>
key
<
to_key
Err
(
_err
)
=
>
true
}
}
}
Err
(
_
)
=
>
true
}
)
.
map
(
|
result
|
match
result
{
Ok
(
(
key
val
)
)
=
>
match
(
key
value_to_owned
(
val
)
)
{
(
Ok
(
key
)
Ok
(
val
)
)
=
>
Ok
(
(
key
.
to_owned
(
)
val
)
)
(
Err
(
err
)
_
)
=
>
Err
(
err
.
into
(
)
)
(
_
Err
(
err
)
)
=
>
Err
(
err
)
}
Err
(
err
)
=
>
Err
(
KeyValueError
:
:
StoreError
(
err
)
)
}
)
.
collect
(
)
;
Ok
(
pairs
)
}
(
)
)
)
;
}
task_done
!
(
value
)
;
}
