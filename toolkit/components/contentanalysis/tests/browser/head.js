"
use
strict
"
;
const
{
MockRegistrar
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
sys
.
mjs
"
)
;
function
xpcWrap
(
obj
iface
)
{
let
ifacePointer
=
Cc
[
"
mozilla
.
org
/
supports
-
interface
-
pointer
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsInterfacePointer
)
;
ifacePointer
.
data
=
obj
;
if
(
iface
)
{
return
ifacePointer
.
data
.
QueryInterface
(
iface
)
;
}
return
ifacePointer
.
data
;
}
function
mockService
(
serviceNames
contractId
interfaceObj
mockService
)
{
let
newService
=
{
.
.
.
mockService
QueryInterface
:
ChromeUtils
.
generateQI
(
serviceNames
)
}
;
let
o
=
xpcWrap
(
newService
interfaceObj
)
;
let
cid
=
MockRegistrar
.
register
(
contractId
o
)
;
registerCleanupFunction
(
(
)
=
>
{
MockRegistrar
.
unregister
(
cid
)
;
}
)
;
return
newService
;
}
function
mockContentAnalysisService
(
mockCAService
)
{
return
mockService
(
[
"
nsIContentAnalysis
"
]
"
mozilla
.
org
/
contentanalysis
;
1
"
Ci
.
nsIContentAnalysis
mockCAService
)
;
}
function
makeContentAnalysisResponse
(
action
token
)
{
return
{
action
shouldAllowContent
:
action
!
=
Ci
.
nsIContentAnalysisResponse
.
eBlock
requestToken
:
token
acknowledge
:
_acknowledgement
=
>
{
}
}
;
}
async
function
waitForFileToAlmostMatchSize
(
filePath
expectedSize
)
{
const
maxSizeDifference
=
AppConstants
.
platform
=
=
"
macosx
"
?
100
:
3
;
await
TestUtils
.
waitForCondition
(
async
function
(
)
{
let
fileStat
=
await
IOUtils
.
stat
(
filePath
)
;
info
(
"
got
size
:
"
+
fileStat
.
size
+
"
expected
:
"
+
expectedSize
)
;
Assert
.
greater
(
fileStat
.
size
0
"
File
should
not
be
empty
:
"
+
fileStat
.
size
)
;
return
Math
.
abs
(
fileStat
.
size
-
expectedSize
)
<
=
maxSizeDifference
;
}
"
Sizes
should
(
almost
)
match
"
)
;
}
