"
use
strict
"
;
function
xpcWrap
(
obj
iface
)
{
let
ifacePointer
=
Cc
[
"
mozilla
.
org
/
supports
-
interface
-
pointer
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsInterfacePointer
)
;
ifacePointer
.
data
=
obj
;
if
(
iface
)
{
return
ifacePointer
.
data
.
QueryInterface
(
iface
)
;
}
return
ifacePointer
.
data
;
}
function
mockService
(
serviceNames
contractId
interfaceObj
mockService
)
{
let
newService
=
{
.
.
.
mockService
QueryInterface
:
ChromeUtils
.
generateQI
(
serviceNames
)
}
;
let
o
=
xpcWrap
(
newService
interfaceObj
)
;
const
{
MockRegistrar
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
sys
.
mjs
"
)
;
let
cid
=
MockRegistrar
.
register
(
contractId
o
)
;
registerCleanupFunction
(
(
)
=
>
{
MockRegistrar
.
unregister
(
cid
)
;
}
)
;
return
newService
;
}
async
function
mockContentAnalysisService
(
mockCAServiceTemplate
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
contentanalysis
.
enabled
"
true
]
]
}
)
;
registerCleanupFunction
(
async
function
(
)
{
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
let
realCAService
=
SpecialPowers
.
Cc
[
"
mozilla
.
org
/
contentanalysis
;
1
"
]
.
getService
(
SpecialPowers
.
Ci
.
nsIContentAnalysis
)
;
let
mockCAService
=
mockService
(
[
"
nsIContentAnalysis
"
]
"
mozilla
.
org
/
contentanalysis
;
1
"
Ci
.
nsIContentAnalysis
mockCAServiceTemplate
)
;
if
(
mockCAService
)
{
mockCAService
.
realCAService
=
realCAService
;
}
return
mockCAService
;
}
function
makeContentAnalysisResponse
(
action
token
)
{
return
{
action
shouldAllowContent
:
action
!
=
Ci
.
nsIContentAnalysisResponse
.
eBlock
requestToken
:
token
acknowledge
:
_acknowledgement
=
>
{
}
}
;
}
async
function
waitForFileToAlmostMatchSize
(
filePath
expectedSize
)
{
const
maxSizeDifference
=
AppConstants
.
platform
=
=
"
macosx
"
?
100
:
3
;
await
TestUtils
.
waitForCondition
(
async
function
(
)
{
let
fileStat
=
await
IOUtils
.
stat
(
filePath
)
;
info
(
"
got
size
:
"
+
fileStat
.
size
+
"
expected
:
"
+
expectedSize
)
;
Assert
.
greater
(
fileStat
.
size
0
"
File
should
not
be
empty
:
"
+
fileStat
.
size
)
;
return
Math
.
abs
(
fileStat
.
size
-
expectedSize
)
<
=
maxSizeDifference
;
}
"
Sizes
should
(
almost
)
match
"
)
;
}
function
makeMockContentAnalysis
(
)
{
return
{
isActive
:
true
mightBeActive
:
true
errorValue
:
undefined
waitForEventToFinish
:
false
eventTarget
:
new
EventTarget
(
)
setupForTest
(
shouldAllowRequest
waitForEvent
)
{
this
.
shouldAllowRequest
=
shouldAllowRequest
;
this
.
errorValue
=
undefined
;
this
.
waitForEvent
=
!
!
waitForEvent
;
this
.
clearCalls
(
)
;
}
setupForTestWithError
(
errorValue
)
{
this
.
errorValue
=
errorValue
;
this
.
clearCalls
(
)
;
}
clearCalls
(
)
{
this
.
calls
=
[
]
;
this
.
browsingContextsForURIs
=
[
]
;
}
getAction
(
)
{
if
(
this
.
shouldAllowRequest
=
=
=
undefined
)
{
this
.
shouldAllowRequest
=
true
;
}
return
this
.
shouldAllowRequest
?
Ci
.
nsIContentAnalysisResponse
.
eAllow
:
Ci
.
nsIContentAnalysisResponse
.
eBlock
;
}
async
analyzeContentRequest
(
request
_autoAcknowledge
)
{
info
(
"
Mock
ContentAnalysis
service
:
analyzeContentRequest
this
.
shouldAllowRequest
=
"
+
this
.
shouldAllowRequest
+
"
this
.
errorValue
=
"
+
this
.
errorValue
)
;
this
.
calls
.
push
(
request
)
;
if
(
this
.
errorValue
)
{
throw
this
.
errorValue
;
}
await
new
Promise
(
res
=
>
setTimeout
(
res
0
)
)
;
if
(
this
.
waitForEvent
)
{
let
waitPromise
=
new
Promise
(
res
=
>
{
this
.
eventTarget
.
addEventListener
(
"
returnContentAnalysisResponse
"
(
)
=
>
{
res
(
)
;
}
{
once
:
true
}
)
;
}
)
;
this
.
eventTarget
.
dispatchEvent
(
new
CustomEvent
(
"
inAnalyzeContentRequest
"
)
)
;
await
waitPromise
;
}
return
makeContentAnalysisResponse
(
this
.
getAction
(
)
request
.
requestToken
)
;
}
analyzeContentRequestCallback
(
request
autoAcknowledge
callback
)
{
info
(
"
Mock
ContentAnalysis
service
:
analyzeContentRequestCallback
this
.
shouldAllowRequest
=
"
+
this
.
shouldAllowRequest
+
"
this
.
errorValue
=
"
+
this
.
errorValue
+
"
this
.
waitForEvent
=
"
+
this
.
waitForEvent
)
;
this
.
calls
.
push
(
request
)
;
if
(
this
.
errorValue
)
{
throw
this
.
errorValue
;
}
setTimeout
(
async
(
)
=
>
{
if
(
this
.
waitForEvent
)
{
let
waitPromise
=
new
Promise
(
res
=
>
{
this
.
eventTarget
.
addEventListener
(
"
returnContentAnalysisResponse
"
(
)
=
>
{
res
(
)
;
}
{
once
:
true
}
)
;
}
)
;
this
.
eventTarget
.
dispatchEvent
(
new
CustomEvent
(
"
inAnalyzeContentRequest
"
)
)
;
await
waitPromise
;
}
let
isDir
=
false
;
try
{
isDir
=
(
await
IOUtils
.
stat
(
request
.
filePath
)
)
.
type
=
=
"
directory
"
;
}
catch
{
}
if
(
isDir
)
{
this
.
realCAService
.
analyzeContentRequestCallback
(
request
autoAcknowledge
callback
)
;
return
;
}
let
response
=
makeContentAnalysisResponse
(
this
.
getAction
(
)
request
.
requestToken
)
;
callback
.
contentResult
(
response
)
;
}
0
)
;
}
cancelAllRequests
(
)
{
}
getURIForBrowsingContext
(
aBrowsingContext
)
{
this
.
browsingContextsForURIs
.
push
(
aBrowsingContext
)
;
return
this
.
realCAService
.
getURIForBrowsingContext
(
aBrowsingContext
)
;
}
setCachedResponse
(
aURI
aClipboardSequenceNumber
aAction
)
{
return
this
.
realCAService
.
setCachedResponse
(
aURI
aClipboardSequenceNumber
aAction
)
;
}
getCachedResponse
(
aURI
aClipboardSequenceNumber
aAction
aIsValid
)
{
return
this
.
realCAService
.
getCachedResponse
(
aURI
aClipboardSequenceNumber
aAction
aIsValid
)
;
}
}
;
}
function
whenTabLoaded
(
aTab
aCallback
)
{
promiseTabLoadEvent
(
aTab
)
.
then
(
aCallback
)
;
}
function
promiseTabLoaded
(
aTab
)
{
return
new
Promise
(
resolve
=
>
{
whenTabLoaded
(
aTab
resolve
)
;
}
)
;
}
function
promiseTabLoadEvent
(
tab
url
)
{
info
(
"
Wait
tab
event
:
load
"
)
;
function
handle
(
loadedUrl
)
{
if
(
loadedUrl
=
=
=
"
about
:
blank
"
|
|
(
url
&
&
loadedUrl
!
=
=
url
)
)
{
info
(
Skipping
spurious
load
event
for
{
loadedUrl
}
)
;
return
false
;
}
info
(
"
Tab
event
received
:
load
"
)
;
return
true
;
}
let
loaded
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
handle
)
;
if
(
url
)
{
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
url
)
;
}
return
loaded
;
}
function
promisePopupShown
(
popup
)
{
return
BrowserTestUtils
.
waitForPopupEvent
(
popup
"
shown
"
)
;
}
function
promisePopupHidden
(
popup
)
{
return
BrowserTestUtils
.
waitForPopupEvent
(
popup
"
hidden
"
)
;
}
