"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
ContentAnalysis
:
"
moz
-
src
:
/
/
/
browser
/
components
/
contentanalysis
/
content
/
ContentAnalysis
.
sys
.
mjs
"
}
)
;
function
xpcWrap
(
obj
iface
)
{
let
ifacePointer
=
Cc
[
"
mozilla
.
org
/
supports
-
interface
-
pointer
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsInterfacePointer
)
;
ifacePointer
.
data
=
obj
;
if
(
iface
)
{
return
ifacePointer
.
data
.
QueryInterface
(
iface
)
;
}
return
ifacePointer
.
data
;
}
function
mockService
(
serviceNames
contractId
interfaceObj
mockService
)
{
let
newService
=
{
.
.
.
mockService
QueryInterface
:
ChromeUtils
.
generateQI
(
serviceNames
)
}
;
let
o
=
xpcWrap
(
newService
interfaceObj
)
;
const
{
MockRegistrar
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
sys
.
mjs
"
)
;
let
cid
=
MockRegistrar
.
registerEx
(
contractId
{
shouldCreateInstance
:
false
}
o
)
;
registerCleanupFunction
(
(
)
=
>
{
MockRegistrar
.
unregister
(
cid
)
;
}
)
;
return
newService
;
}
async
function
mockContentAnalysisService
(
mockCAServiceTemplate
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
contentanalysis
.
enabled
"
true
]
]
}
)
;
registerCleanupFunction
(
async
function
(
)
{
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
let
realCAService
=
SpecialPowers
.
Cc
[
"
mozilla
.
org
/
contentanalysis
;
1
"
]
.
getService
(
SpecialPowers
.
Ci
.
nsIContentAnalysis
)
;
let
mockCAService
=
mockService
(
[
"
nsIContentAnalysis
"
]
"
mozilla
.
org
/
contentanalysis
;
1
"
Ci
.
nsIContentAnalysis
mockCAServiceTemplate
)
;
if
(
mockCAService
)
{
mockCAService
.
realCAService
=
realCAService
;
}
return
mockCAService
;
}
async
function
waitForFileToAlmostMatchSize
(
filePath
expectedSize
)
{
const
maxSizeDifference
=
AppConstants
.
platform
=
=
"
macosx
"
?
100
:
3
;
await
TestUtils
.
waitForCondition
(
async
function
(
)
{
let
fileStat
=
await
IOUtils
.
stat
(
filePath
)
;
info
(
"
got
size
:
"
+
fileStat
.
size
+
"
expected
:
"
+
expectedSize
)
;
Assert
.
greater
(
fileStat
.
size
0
"
File
should
not
be
empty
:
"
+
fileStat
.
size
)
;
return
Math
.
abs
(
fileStat
.
size
-
expectedSize
)
<
=
maxSizeDifference
;
}
"
Sizes
should
(
almost
)
match
"
)
;
}
function
makeMockContentAnalysis
(
)
{
return
{
isActive
:
true
mightBeActive
:
true
errorValue
:
undefined
waitForEventToFinish
:
false
eventTarget
:
new
EventTarget
(
)
setupForTest
(
shouldAllowRequest
waitForEvent
showDialogs
)
{
this
.
shouldAllowRequest
=
shouldAllowRequest
;
this
.
errorValue
=
undefined
;
this
.
waitForEvent
=
!
!
waitForEvent
;
this
.
showDialogs
=
showDialogs
;
this
.
clearCalls
(
)
;
ContentAnalysis
.
setMockContentAnalysisForTest
(
this
.
showDialogs
?
this
:
undefined
)
;
ContentAnalysis
.
initialize
(
window
)
;
}
setupForTestWithError
(
errorValue
)
{
this
.
errorValue
=
errorValue
;
this
.
waitForEvent
=
false
;
this
.
showDialogs
=
false
;
this
.
clearCalls
(
)
;
}
clearCalls
(
)
{
this
.
calls
=
[
]
;
this
.
browsingContextsForURIs
=
[
]
;
this
.
agentCancelCalls
=
0
;
this
.
cancelledUserActions
=
[
]
;
this
.
cancelledRequestTokens
=
[
]
;
}
getAction
(
)
{
if
(
this
.
shouldAllowRequest
=
=
=
undefined
)
{
this
.
shouldAllowRequest
=
true
;
}
return
this
.
shouldAllowRequest
?
Ci
.
nsIContentAnalysisResponse
.
eAllow
:
Ci
.
nsIContentAnalysisResponse
.
eBlock
;
}
analyzeContentRequests
(
requests
autoAcknowledge
)
{
return
this
.
realCAService
.
analyzeContentRequests
(
requests
autoAcknowledge
)
;
}
analyzeBatchContentRequest
(
request
autoAcknowledge
)
{
return
this
.
realCAService
.
analyzeBatchContentRequest
(
request
autoAcknowledge
)
;
}
analyzeContentRequestsCallback
(
requests
autoAcknowledge
callback
)
{
if
(
this
.
errorValue
)
{
if
(
requests
.
length
!
=
1
)
{
is
(
requests
.
length
1
"
Test
framework
doesn
'
t
support
throwing
an
exception
from
a
multipart
request
"
)
;
}
requests
[
0
]
.
userActionId
=
"
user
-
action
-
for
-
error
"
;
requests
[
0
]
.
userActionRequestsCount
=
1
;
requests
[
0
]
.
requestToken
=
"
request
-
token
-
for
-
error
"
;
this
.
calls
.
push
(
requests
[
0
]
)
;
callback
.
error
(
this
.
errorValue
)
;
throw
this
.
errorValue
;
}
this
.
realCAService
.
analyzeContentRequestsCallback
(
requests
autoAcknowledge
callback
)
;
}
analyzeContentRequestPrivate
(
request
_autoAcknowledge
callback
)
{
info
(
Mock
ContentAnalysis
service
:
analyzeContentRequestPrivate
+
this
.
shouldAllowRequest
:
{
this
.
shouldAllowRequest
}
+
|
this
.
waitForEvent
:
{
this
.
waitForEvent
}
+
|
this
.
showDialogs
:
{
this
.
showDialogs
}
)
;
info
(
Request
type
:
{
request
.
analysisType
}
+
|
reason
:
{
request
.
reason
}
+
|
operation
:
{
request
.
operationTypeForDisplay
}
+
|
operation
string
:
'
{
request
.
operationDisplayString
}
'
)
;
info
(
Text
content
:
'
{
request
.
textContent
}
'
+
|
filePath
:
'
{
request
.
filePath
}
'
+
|
printDataHandle
:
{
request
.
printDataHandle
}
+
|
printDataSize
:
{
request
.
printDataSize
}
)
;
info
(
Printer
name
:
'
{
request
.
printerName
}
'
+
|
url
:
'
{
request
.
url
?
request
.
url
.
spec
:
"
"
}
'
+
|
Request
token
:
{
request
.
requestToken
}
+
|
user
action
ID
:
{
request
.
userActionId
}
+
|
user
action
count
:
{
request
.
userActionRequestsCount
}
)
;
if
(
this
.
errorValue
)
{
ok
(
!
this
.
errorValue
"
can
'
t
throw
an
exception
in
mock
analyzeContentRequestPrivate
"
)
;
}
this
.
calls
.
push
(
request
)
;
if
(
this
.
showDialogs
)
{
Services
.
obs
.
notifyObservers
(
request
"
dlp
-
request
-
made
"
)
;
}
setTimeout
(
async
(
)
=
>
{
if
(
this
.
waitForEvent
)
{
let
waitPromise
=
new
Promise
(
res
=
>
{
this
.
eventTarget
.
addEventListener
(
"
returnContentAnalysisResponse
"
(
)
=
>
{
res
(
)
;
}
{
once
:
true
}
)
;
}
)
;
this
.
eventTarget
.
dispatchEvent
(
new
CustomEvent
(
"
inAnalyzeContentRequest
"
)
)
;
await
waitPromise
;
}
let
response
=
this
.
realCAService
.
makeResponseForTest
(
this
.
getAction
(
)
request
.
requestToken
request
.
userActionId
)
;
if
(
this
.
showDialogs
)
{
Services
.
obs
.
notifyObservers
(
response
"
dlp
-
response
"
)
;
}
callback
.
contentResult
(
response
)
;
}
0
)
;
}
cancelAllRequests
(
)
{
}
getURIForBrowsingContext
(
aBrowsingContext
)
{
this
.
browsingContextsForURIs
.
push
(
aBrowsingContext
)
;
return
this
.
realCAService
.
getURIForBrowsingContext
(
aBrowsingContext
)
;
}
setCachedResponse
(
aURI
aClipboardSequenceNumber
aAction
)
{
return
this
.
realCAService
.
setCachedResponse
(
aURI
aClipboardSequenceNumber
aAction
)
;
}
getCachedResponse
(
aURI
aClipboardSequenceNumber
aAction
aIsValid
)
{
return
this
.
realCAService
.
getCachedResponse
(
aURI
aClipboardSequenceNumber
aAction
aIsValid
)
;
}
showBlockedRequestDialog
(
aRequest
)
{
info
(
got
showBlockedRequestDialog
for
request
{
aRequest
.
requestToken
}
)
;
}
sendCancelToAgent
(
aUserActionId
)
{
info
(
got
sendCancelToAgent
for
user
action
ID
{
aUserActionId
}
)
;
this
.
agentCancelCalls
=
this
.
agentCancelCalls
+
1
;
}
async
getDiagnosticInfo
(
)
{
return
{
connectedToAgent
:
true
agentPath
:
"
AFakePath
"
failedSignatureVerification
:
false
requestCount
:
this
.
calls
.
length
}
;
}
cancelRequestsByUserAction
(
aUserActionId
)
{
this
.
cancelledUserActions
.
push
(
aUserActionId
)
;
}
cancelRequestsByRequestToken
(
aRequestToken
)
{
this
.
cancelledRequestTokens
.
push
(
aRequestToken
)
;
}
cancelAllRequestsAssociatedWithUserAction
(
aUserActionId
)
{
return
this
.
realCAService
.
cancelAllRequestsAssociatedWithUserAction
(
aUserActionId
)
;
}
}
;
}
function
whenTabLoaded
(
aTab
aCallback
)
{
promiseTabLoadEvent
(
aTab
)
.
then
(
aCallback
)
;
}
function
promiseTabLoaded
(
aTab
)
{
return
new
Promise
(
resolve
=
>
{
whenTabLoaded
(
aTab
resolve
)
;
}
)
;
}
function
promiseTabLoadEvent
(
tab
url
)
{
info
(
"
Wait
tab
event
:
load
"
)
;
function
handle
(
loadedUrl
)
{
if
(
loadedUrl
=
=
=
"
about
:
blank
"
|
|
(
url
&
&
loadedUrl
!
=
=
url
)
)
{
info
(
Skipping
spurious
load
event
for
{
loadedUrl
}
)
;
return
false
;
}
info
(
"
Tab
event
received
:
load
"
)
;
return
true
;
}
let
loaded
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
handle
)
;
if
(
url
)
{
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
url
)
;
}
return
loaded
;
}
function
promisePopupShown
(
popup
)
{
return
BrowserTestUtils
.
waitForPopupEvent
(
popup
"
shown
"
)
;
}
function
promisePopupHidden
(
popup
)
{
return
BrowserTestUtils
.
waitForPopupEvent
(
popup
"
hidden
"
)
;
}
