#
ifndef
mozilla_contentanalysis_h
#
define
mozilla_contentanalysis_h
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
MoveOnlyFunction
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
MaybeDiscarded
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIContentAnalysis
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
<
atomic
>
#
include
<
regex
>
#
include
<
string
>
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
endif
class
nsBaseClipboard
;
class
nsIPrincipal
;
class
nsIPrintSettings
;
class
ContentAnalysisTest
;
namespace
mozilla
:
:
dom
{
class
CanonicalBrowsingContext
;
class
DataTransfer
;
class
WindowGlobalParent
;
}
namespace
content_analysis
:
:
sdk
{
class
Client
;
class
ContentAnalysisRequest
;
class
ContentAnalysisResponse
;
}
namespace
mozilla
:
:
contentanalysis
{
enum
class
DefaultResult
:
uint8_t
{
eBlock
=
0
eWarn
=
1
eAllow
=
2
eLastValue
=
2
}
;
class
ContentAnalysisDiagnosticInfo
final
:
public
nsIContentAnalysisDiagnosticInfo
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSICONTENTANALYSISDIAGNOSTICINFO
ContentAnalysisDiagnosticInfo
(
bool
aConnectedToAgent
nsString
aAgentPath
bool
aFailedSignatureVerification
int64_t
aRequestCount
)
:
mConnectedToAgent
(
aConnectedToAgent
)
mAgentPath
(
std
:
:
move
(
aAgentPath
)
)
mFailedSignatureVerification
(
aFailedSignatureVerification
)
mRequestCount
(
aRequestCount
)
{
}
private
:
~
ContentAnalysisDiagnosticInfo
(
)
=
default
;
bool
mConnectedToAgent
;
nsString
mAgentPath
;
bool
mFailedSignatureVerification
;
int64_t
mRequestCount
;
}
;
class
ContentAnalysisRequest
final
:
public
nsIContentAnalysisRequest
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSICONTENTANALYSISREQUEST
ContentAnalysisRequest
(
AnalysisType
aAnalysisType
nsString
aString
bool
aStringIsFilePath
nsCString
aSha256Digest
nsCOMPtr
<
nsIURI
>
aUrl
OperationType
aOperationType
dom
:
:
WindowGlobalParent
*
aWindowGlobalParent
)
;
ContentAnalysisRequest
(
const
nsTArray
<
uint8_t
>
aPrintData
nsCOMPtr
<
nsIURI
>
aUrl
nsString
aPrinterName
dom
:
:
WindowGlobalParent
*
aWindowGlobalParent
)
;
static
nsresult
GetFileDigest
(
const
nsAString
&
aFilePath
nsCString
&
aDigestString
)
;
private
:
~
ContentAnalysisRequest
(
)
;
ContentAnalysisRequest
(
const
ContentAnalysisRequest
&
)
=
delete
;
ContentAnalysisRequest
&
operator
=
(
ContentAnalysisRequest
&
)
=
delete
;
AnalysisType
mAnalysisType
;
nsString
mTextContent
;
nsString
mFilePath
;
nsCOMPtr
<
nsIURI
>
mUrl
;
nsCString
mSha256Digest
;
nsTArray
<
RefPtr
<
nsIClientDownloadResource
>
>
mResources
;
nsString
mEmail
;
nsCString
mRequestToken
;
OperationType
mOperationTypeForDisplay
;
nsString
mOperationDisplayString
;
nsString
mPrinterName
;
RefPtr
<
dom
:
:
WindowGlobalParent
>
mWindowGlobalParent
;
#
ifdef
XP_WIN
HANDLE
mPrintDataHandle
=
0
;
uint64_t
mPrintDataSize
=
0
;
#
endif
friend
class
:
:
ContentAnalysisTest
;
}
;
#
define
CONTENTANALYSIS_IID
\
{
\
0xa37bed74
0x4b50
0x443a
{
\
0xbf
0x58
0xf4
0xeb
0xbd
0x30
0x67
0xb4
\
}
\
}
class
ContentAnalysisResponse
;
class
ContentAnalysis
final
:
public
nsIContentAnalysis
{
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
CONTENTANALYSIS_IID
)
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSICONTENTANALYSIS
ContentAnalysis
(
)
;
nsCString
GetUserActionId
(
)
;
void
SetLastResult
(
nsresult
aLastResult
)
{
mLastResult
=
aLastResult
;
}
void
SetCachedDataTimeoutForTesting
(
uint32_t
aNewTimeout
)
;
void
ResetCachedDataTimeoutForTesting
(
)
;
#
if
defined
(
XP_WIN
)
struct
PrintAllowedResult
final
{
bool
mAllowed
;
dom
:
:
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
mCachedStaticDocumentBrowsingContext
;
PrintAllowedResult
(
bool
aAllowed
dom
:
:
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
aCachedStaticDocumentBrowsingContext
)
:
mAllowed
(
aAllowed
)
mCachedStaticDocumentBrowsingContext
(
aCachedStaticDocumentBrowsingContext
)
{
}
explicit
PrintAllowedResult
(
bool
aAllowed
)
:
PrintAllowedResult
(
aAllowed
dom
:
:
MaybeDiscardedBrowsingContext
(
)
)
{
}
}
;
struct
PrintAllowedError
final
{
nsresult
mError
;
dom
:
:
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
mCachedStaticDocumentBrowsingContext
;
PrintAllowedError
(
nsresult
aError
dom
:
:
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
aCachedStaticDocumentBrowsingContext
)
:
mError
(
aError
)
mCachedStaticDocumentBrowsingContext
(
aCachedStaticDocumentBrowsingContext
)
{
}
explicit
PrintAllowedError
(
nsresult
aError
)
:
PrintAllowedError
(
aError
dom
:
:
MaybeDiscardedBrowsingContext
(
)
)
{
}
}
;
using
PrintAllowedPromise
=
MozPromise
<
PrintAllowedResult
PrintAllowedError
true
>
;
MOZ_CAN_RUN_SCRIPT
static
RefPtr
<
PrintAllowedPromise
>
PrintToPDFToDetermineIfPrintAllowed
(
dom
:
:
CanonicalBrowsingContext
*
aBrowsingContext
nsIPrintSettings
*
aPrintSettings
)
;
#
endif
class
SafeContentAnalysisResultCallback
final
:
public
nsIContentAnalysisCallback
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSICONTENTANALYSISCALLBACK
explicit
SafeContentAnalysisResultCallback
(
std
:
:
function
<
void
(
RefPtr
<
nsIContentAnalysisResult
>
&
&
)
>
aResolver
)
:
mResolver
(
std
:
:
move
(
aResolver
)
)
{
}
void
Callback
(
RefPtr
<
nsIContentAnalysisResult
>
&
&
aResult
)
{
MOZ_ASSERT
(
mResolver
"
Called
SafeContentAnalysisResultCallback
twice
!
"
)
;
if
(
auto
resolver
=
std
:
:
move
(
mResolver
)
)
{
resolver
(
std
:
:
move
(
aResult
)
)
;
}
}
private
:
~
SafeContentAnalysisResultCallback
(
)
{
MOZ_ASSERT
(
!
mResolver
"
SafeContentAnalysisResultCallback
never
called
!
"
)
;
}
mozilla
:
:
MoveOnlyFunction
<
void
(
RefPtr
<
nsIContentAnalysisResult
>
&
&
)
>
mResolver
;
}
;
static
nsCOMPtr
<
nsIURI
>
GetURIForBrowsingContext
(
dom
:
:
CanonicalBrowsingContext
*
aBrowsingContext
)
;
static
bool
CheckClipboardContentAnalysisSync
(
nsBaseClipboard
*
aClipboard
mozilla
:
:
dom
:
:
WindowGlobalParent
*
aWindow
const
nsCOMPtr
<
nsITransferable
>
&
trans
nsIClipboard
:
:
ClipboardType
aClipboardType
)
;
static
void
CheckClipboardContentAnalysis
(
nsBaseClipboard
*
aClipboard
mozilla
:
:
dom
:
:
WindowGlobalParent
*
aWindow
nsITransferable
*
aTransferable
nsIClipboard
:
:
ClipboardType
aClipboardType
SafeContentAnalysisResultCallback
*
aResolver
)
;
static
constexpr
uint32_t
kDefaultCachedDataTimeoutInMs
=
5000
;
private
:
~
ContentAnalysis
(
)
;
ContentAnalysis
(
const
ContentAnalysis
&
)
=
delete
;
ContentAnalysis
&
operator
=
(
ContentAnalysis
&
)
=
delete
;
nsresult
CreateContentAnalysisClient
(
nsCString
&
&
aPipePathName
nsString
&
&
aClientSignatureSetting
bool
aIsPerUser
)
;
nsresult
AnalyzeContentRequestCallbackPrivate
(
nsIContentAnalysisRequest
*
aRequest
bool
aAutoAcknowledge
nsIContentAnalysisCallback
*
aCallback
)
;
nsresult
RunAnalyzeRequestTask
(
const
RefPtr
<
nsIContentAnalysisRequest
>
&
aRequest
bool
aAutoAcknowledge
int64_t
aRequestCount
const
RefPtr
<
nsIContentAnalysisCallback
>
&
aCallback
)
;
nsresult
RunAcknowledgeTask
(
nsIContentAnalysisAcknowledgement
*
aAcknowledgement
const
nsACString
&
aRequestToken
)
;
nsresult
CancelWithError
(
nsCString
aRequestToken
nsresult
aResult
)
;
void
GenerateUserActionId
(
)
;
static
RefPtr
<
ContentAnalysis
>
GetContentAnalysisFromService
(
)
;
static
void
DoAnalyzeRequest
(
nsCString
aRequestToken
content_analysis
:
:
sdk
:
:
ContentAnalysisRequest
&
&
aRequest
nsCOMPtr
<
nsIContentAnalysisRequest
>
aRequestToCache
const
std
:
:
shared_ptr
<
content_analysis
:
:
sdk
:
:
Client
>
&
aClient
)
;
void
IssueResponse
(
RefPtr
<
ContentAnalysisResponse
>
&
response
)
;
bool
LastRequestSucceeded
(
)
;
enum
UrlFilterResult
{
eCheck
eDeny
eAllow
}
;
UrlFilterResult
FilterByUrlLists
(
nsIContentAnalysisRequest
*
aRequest
)
;
void
EnsureParsedUrlFilters
(
)
;
Result
<
bool
nsresult
>
MaybeExpandAndAnalyzeFolderContentRequest
(
nsIContentAnalysisRequest
*
aRequest
bool
aAutoAcknowledge
nsIContentAnalysisCallback
*
aCallback
)
;
using
ClientPromise
=
MozPromise
<
std
:
:
shared_ptr
<
content_analysis
:
:
sdk
:
:
Client
>
nsresult
false
>
;
nsCString
mUserActionId
;
int64_t
mRequestCount
=
0
;
RefPtr
<
ClientPromise
:
:
Private
>
mCaClientPromise
;
bool
mClientCreationAttempted
;
bool
mSetByEnterprise
;
nsresult
mLastResult
=
NS_OK
;
class
CallbackData
final
{
public
:
CallbackData
(
nsMainThreadPtrHandle
<
nsIContentAnalysisCallback
>
&
&
aCallbackHolder
bool
aAutoAcknowledge
)
:
mCallbackHolder
(
aCallbackHolder
)
mAutoAcknowledge
(
aAutoAcknowledge
)
{
}
nsMainThreadPtrHandle
<
nsIContentAnalysisCallback
>
TakeCallbackHolder
(
)
{
return
std
:
:
move
(
mCallbackHolder
)
;
}
bool
AutoAcknowledge
(
)
const
{
return
mAutoAcknowledge
;
}
void
SetCanceled
(
)
{
mCallbackHolder
=
nullptr
;
}
bool
Canceled
(
)
const
{
return
!
mCallbackHolder
;
}
private
:
nsMainThreadPtrHandle
<
nsIContentAnalysisCallback
>
mCallbackHolder
;
bool
mAutoAcknowledge
;
}
;
DataMutex
<
nsTHashMap
<
nsCString
CallbackData
>
>
mCallbackMap
;
class
CachedData
final
{
public
:
nsCOMPtr
<
nsIContentAnalysisRequest
>
Request
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mRequest
;
}
void
SetData
(
nsCOMPtr
<
nsIContentAnalysisRequest
>
aRequest
nsIContentAnalysisResponse
:
:
Action
aResultAction
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mRequest
=
aRequest
;
mResultAction
=
Some
(
aResultAction
)
;
if
(
aResultAction
!
=
nsIContentAnalysisResponse
:
:
Action
:
:
eWarn
)
{
SetExpirationTimer
(
)
;
}
}
Maybe
<
nsIContentAnalysisResponse
:
:
Action
>
ResultAction
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mResultAction
;
}
void
SetExpirationTimer
(
)
;
void
Clear
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mRequest
=
nullptr
;
mResultAction
=
Nothing
(
)
;
if
(
mExpirationTimer
)
{
mExpirationTimer
-
>
Cancel
(
)
;
}
}
void
UpdateWarnAction
(
nsIContentAnalysisResponse
:
:
Action
aAction
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mRequest
)
;
MOZ_ASSERT
(
mResultAction
=
=
Some
(
nsIContentAnalysisResponse
:
:
Action
:
:
eWarn
)
)
;
mResultAction
=
Some
(
aAction
)
;
SetExpirationTimer
(
)
;
}
enum
class
CacheResult
:
uint8_t
{
CannotBeCached
=
0
DoesNotMatchExisting
=
1
Matches
=
2
}
;
CacheResult
CompareWithRequest
(
const
RefPtr
<
nsIContentAnalysisRequest
>
&
aRequest
)
;
private
:
nsCOMPtr
<
nsIContentAnalysisRequest
>
mRequest
;
Maybe
<
nsIContentAnalysisResponse
:
:
Action
>
mResultAction
;
nsCOMPtr
<
nsITimer
>
mExpirationTimer
;
uint32_t
mClearTimeout
=
kDefaultCachedDataTimeoutInMs
;
friend
class
ContentAnalysis
;
}
;
CachedData
mCachedData
;
struct
WarnResponseData
{
WarnResponseData
(
CallbackData
&
&
aCallbackData
RefPtr
<
ContentAnalysisResponse
>
aResponse
)
:
mCallbackData
(
std
:
:
move
(
aCallbackData
)
)
mResponse
(
aResponse
)
{
}
ContentAnalysis
:
:
CallbackData
mCallbackData
;
RefPtr
<
ContentAnalysisResponse
>
mResponse
;
}
;
DataMutex
<
nsTHashMap
<
nsCString
WarnResponseData
>
>
mWarnResponseDataMap
;
void
SendWarnResponse
(
nsCString
&
&
aResponseRequestToken
CallbackData
aCallbackData
RefPtr
<
ContentAnalysisResponse
>
&
aResponse
)
;
std
:
:
vector
<
std
:
:
regex
>
mAllowUrlList
;
std
:
:
vector
<
std
:
:
regex
>
mDenyUrlList
;
bool
mParsedUrlLists
=
false
;
friend
class
ContentAnalysisResponse
;
friend
class
AnalyzeFilesInDirectoryCallback
;
friend
class
:
:
ContentAnalysisTest
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
ContentAnalysis
CONTENTANALYSIS_IID
)
class
ContentAnalysisResponse
final
:
public
nsIContentAnalysisResponse
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSICONTENTANALYSISRESPONSE
static
RefPtr
<
ContentAnalysisResponse
>
FromAction
(
Action
aAction
const
nsACString
&
aRequestToken
)
;
void
SetOwner
(
RefPtr
<
ContentAnalysis
>
aOwner
)
;
void
DoNotAcknowledge
(
)
{
mDoNotAcknowledge
=
true
;
}
void
SetCancelError
(
CancelError
aCancelError
)
;
void
SetIsCachedResponse
(
)
{
mIsCachedResponse
=
true
;
}
private
:
~
ContentAnalysisResponse
(
)
=
default
;
ContentAnalysisResponse
(
const
ContentAnalysisResponse
&
)
=
delete
;
ContentAnalysisResponse
&
operator
=
(
ContentAnalysisResponse
&
)
=
delete
;
explicit
ContentAnalysisResponse
(
content_analysis
:
:
sdk
:
:
ContentAnalysisResponse
&
&
aResponse
)
;
ContentAnalysisResponse
(
Action
aAction
const
nsACString
&
aRequestToken
)
;
static
already_AddRefed
<
ContentAnalysisResponse
>
FromProtobuf
(
content_analysis
:
:
sdk
:
:
ContentAnalysisResponse
&
&
aResponse
)
;
void
ResolveWarnAction
(
bool
aAllowContent
)
;
Action
mAction
;
nsCString
mRequestToken
;
CancelError
mCancelError
=
CancelError
:
:
eUserInitiated
;
RefPtr
<
ContentAnalysis
>
mOwner
;
bool
mHasAcknowledged
=
false
;
bool
mDoNotAcknowledge
=
false
;
bool
mIsCachedResponse
=
false
;
friend
class
ContentAnalysis
;
}
;
class
ContentAnalysisAcknowledgement
final
:
public
nsIContentAnalysisAcknowledgement
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSICONTENTANALYSISACKNOWLEDGEMENT
ContentAnalysisAcknowledgement
(
Result
aResult
FinalAction
aFinalAction
)
;
private
:
~
ContentAnalysisAcknowledgement
(
)
=
default
;
Result
mResult
;
FinalAction
mFinalAction
;
}
;
class
ContentAnalysisCallback
final
:
public
nsIContentAnalysisCallback
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSICONTENTANALYSISCALLBACK
ContentAnalysisCallback
(
std
:
:
function
<
void
(
nsIContentAnalysisResponse
*
)
>
&
&
aContentResponseCallback
std
:
:
function
<
void
(
nsresult
)
>
&
&
aErrorCallback
)
:
mContentResponseCallback
(
std
:
:
move
(
aContentResponseCallback
)
)
mErrorCallback
(
std
:
:
move
(
aErrorCallback
)
)
{
}
private
:
~
ContentAnalysisCallback
(
)
=
default
;
explicit
ContentAnalysisCallback
(
RefPtr
<
dom
:
:
Promise
>
aPromise
)
;
std
:
:
function
<
void
(
nsIContentAnalysisResponse
*
)
>
mContentResponseCallback
;
std
:
:
function
<
void
(
nsresult
)
>
mErrorCallback
;
Maybe
<
nsMainThreadPtrHandle
<
dom
:
:
Promise
>
>
mPromise
;
friend
class
ContentAnalysis
;
}
;
}
#
endif
