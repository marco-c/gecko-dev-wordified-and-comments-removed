#
ifndef
CPPTL_JSON_H_INCLUDED
#
define
CPPTL_JSON_H_INCLUDED
#
if
!
defined
(
JSON_IS_AMALGAMATION
)
#
include
"
forwards
.
h
"
#
endif
#
if
!
defined
(
JSONCPP_NORETURN
)
#
if
defined
(
_MSC_VER
)
&
&
_MSC_VER
=
=
1800
#
define
JSONCPP_NORETURN
__declspec
(
noreturn
)
#
else
#
define
JSONCPP_NORETURN
[
[
noreturn
]
]
#
endif
#
endif
#
include
<
array
>
#
include
<
exception
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
ifndef
JSON_USE_CPPTL_SMALLMAP
#
include
<
map
>
#
else
#
include
<
cpptl
/
smallmap
.
h
>
#
endif
#
ifdef
JSON_USE_CPPTL
#
include
<
cpptl
/
forwards
.
h
>
#
endif
#
if
defined
(
JSONCPP_DISABLE_DLL_INTERFACE_WARNING
)
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4251
)
#
endif
#
pragma
pack
(
push
8
)
namespace
Json
{
#
if
JSON_USE_EXCEPTION
class
JSON_API
Exception
:
public
std
:
:
exception
{
public
:
Exception
(
String
msg
)
;
~
Exception
(
)
JSONCPP_NOEXCEPT
override
;
char
const
*
what
(
)
const
JSONCPP_NOEXCEPT
override
;
protected
:
String
msg_
;
}
;
class
JSON_API
RuntimeError
:
public
Exception
{
public
:
RuntimeError
(
String
const
&
msg
)
;
}
;
class
JSON_API
LogicError
:
public
Exception
{
public
:
LogicError
(
String
const
&
msg
)
;
}
;
#
endif
JSONCPP_NORETURN
void
throwRuntimeError
(
String
const
&
msg
)
;
JSONCPP_NORETURN
void
throwLogicError
(
String
const
&
msg
)
;
enum
ValueType
{
nullValue
=
0
intValue
uintValue
realValue
stringValue
booleanValue
arrayValue
objectValue
}
;
enum
CommentPlacement
{
commentBefore
=
0
commentAfterOnSameLine
commentAfter
numberOfCommentPlacement
}
;
enum
PrecisionType
{
significantDigits
=
0
decimalPlaces
}
;
class
JSON_API
StaticString
{
public
:
explicit
StaticString
(
const
char
*
czstring
)
:
c_str_
(
czstring
)
{
}
operator
const
char
*
(
)
const
{
return
c_str_
;
}
const
char
*
c_str
(
)
const
{
return
c_str_
;
}
private
:
const
char
*
c_str_
;
}
;
class
JSON_API
Value
{
friend
class
ValueIteratorBase
;
public
:
typedef
std
:
:
vector
<
String
>
Members
;
typedef
ValueIterator
iterator
;
typedef
ValueConstIterator
const_iterator
;
typedef
Json
:
:
UInt
UInt
;
typedef
Json
:
:
Int
Int
;
#
if
defined
(
JSON_HAS_INT64
)
typedef
Json
:
:
UInt64
UInt64
;
typedef
Json
:
:
Int64
Int64
;
#
endif
typedef
Json
:
:
LargestInt
LargestInt
;
typedef
Json
:
:
LargestUInt
LargestUInt
;
typedef
Json
:
:
ArrayIndex
ArrayIndex
;
typedef
std
:
:
string
value_type
;
#
if
JSON_USE_NULLREF
static
const
Value
&
null
;
static
const
Value
&
nullRef
;
#
endif
static
Value
const
&
nullSingleton
(
)
;
static
constexpr
LargestInt
minLargestInt
=
LargestInt
(
~
(
LargestUInt
(
-
1
)
/
2
)
)
;
static
constexpr
LargestInt
maxLargestInt
=
LargestInt
(
LargestUInt
(
-
1
)
/
2
)
;
static
constexpr
LargestUInt
maxLargestUInt
=
LargestUInt
(
-
1
)
;
static
constexpr
Int
minInt
=
Int
(
~
(
UInt
(
-
1
)
/
2
)
)
;
static
constexpr
Int
maxInt
=
Int
(
UInt
(
-
1
)
/
2
)
;
static
constexpr
UInt
maxUInt
=
UInt
(
-
1
)
;
#
if
defined
(
JSON_HAS_INT64
)
static
constexpr
Int64
minInt64
=
Int64
(
~
(
UInt64
(
-
1
)
/
2
)
)
;
static
constexpr
Int64
maxInt64
=
Int64
(
UInt64
(
-
1
)
/
2
)
;
static
constexpr
UInt64
maxUInt64
=
UInt64
(
-
1
)
;
#
endif
static
constexpr
UInt
defaultRealPrecision
=
17
;
static
constexpr
double
maxUInt64AsDouble
=
18446744073709551615
.
0
;
#
ifdef
__NVCC__
public
:
#
else
private
:
#
endif
#
ifndef
JSONCPP_DOC_EXCLUDE_IMPLEMENTATION
class
CZString
{
public
:
enum
DuplicationPolicy
{
noDuplication
=
0
duplicate
duplicateOnCopy
}
;
CZString
(
ArrayIndex
index
)
;
CZString
(
char
const
*
str
unsigned
length
DuplicationPolicy
allocate
)
;
CZString
(
CZString
const
&
other
)
;
CZString
(
CZString
&
&
other
)
;
~
CZString
(
)
;
CZString
&
operator
=
(
const
CZString
&
other
)
;
CZString
&
operator
=
(
CZString
&
&
other
)
;
bool
operator
<
(
CZString
const
&
other
)
const
;
bool
operator
=
=
(
CZString
const
&
other
)
const
;
ArrayIndex
index
(
)
const
;
char
const
*
data
(
)
const
;
unsigned
length
(
)
const
;
bool
isStaticString
(
)
const
;
private
:
void
swap
(
CZString
&
other
)
;
struct
StringStorage
{
unsigned
policy_
:
2
;
unsigned
length_
:
30
;
}
;
char
const
*
cstr_
;
union
{
ArrayIndex
index_
;
StringStorage
storage_
;
}
;
}
;
public
:
#
ifndef
JSON_USE_CPPTL_SMALLMAP
typedef
std
:
:
map
<
CZString
Value
>
ObjectValues
;
#
else
typedef
CppTL
:
:
SmallMap
<
CZString
Value
>
ObjectValues
;
#
endif
#
endif
public
:
Value
(
ValueType
type
=
nullValue
)
;
Value
(
Int
value
)
;
Value
(
UInt
value
)
;
#
if
defined
(
JSON_HAS_INT64
)
Value
(
Int64
value
)
;
Value
(
UInt64
value
)
;
#
endif
Value
(
double
value
)
;
Value
(
const
char
*
value
)
;
Value
(
const
char
*
begin
const
char
*
end
)
;
Value
(
const
StaticString
&
value
)
;
Value
(
const
String
&
value
)
;
#
ifdef
JSON_USE_CPPTL
Value
(
const
CppTL
:
:
ConstString
&
value
)
;
#
endif
Value
(
bool
value
)
;
Value
(
const
Value
&
other
)
;
Value
(
Value
&
&
other
)
;
~
Value
(
)
;
Value
&
operator
=
(
const
Value
&
other
)
;
Value
&
operator
=
(
Value
&
&
other
)
;
void
swap
(
Value
&
other
)
;
void
swapPayload
(
Value
&
other
)
;
void
copy
(
const
Value
&
other
)
;
void
copyPayload
(
const
Value
&
other
)
;
ValueType
type
(
)
const
;
bool
operator
<
(
const
Value
&
other
)
const
;
bool
operator
<
=
(
const
Value
&
other
)
const
;
bool
operator
>
=
(
const
Value
&
other
)
const
;
bool
operator
>
(
const
Value
&
other
)
const
;
bool
operator
=
=
(
const
Value
&
other
)
const
;
bool
operator
!
=
(
const
Value
&
other
)
const
;
int
compare
(
const
Value
&
other
)
const
;
const
char
*
asCString
(
)
const
;
#
if
JSONCPP_USING_SECURE_MEMORY
unsigned
getCStringLength
(
)
const
;
#
endif
String
asString
(
)
const
;
bool
getString
(
char
const
*
*
begin
char
const
*
*
end
)
const
;
#
ifdef
JSON_USE_CPPTL
CppTL
:
:
ConstString
asConstString
(
)
const
;
#
endif
Int
asInt
(
)
const
;
UInt
asUInt
(
)
const
;
#
if
defined
(
JSON_HAS_INT64
)
Int64
asInt64
(
)
const
;
UInt64
asUInt64
(
)
const
;
#
endif
LargestInt
asLargestInt
(
)
const
;
LargestUInt
asLargestUInt
(
)
const
;
float
asFloat
(
)
const
;
double
asDouble
(
)
const
;
bool
asBool
(
)
const
;
bool
isNull
(
)
const
;
bool
isBool
(
)
const
;
bool
isInt
(
)
const
;
bool
isInt64
(
)
const
;
bool
isUInt
(
)
const
;
bool
isUInt64
(
)
const
;
bool
isIntegral
(
)
const
;
bool
isDouble
(
)
const
;
bool
isNumeric
(
)
const
;
bool
isString
(
)
const
;
bool
isArray
(
)
const
;
bool
isObject
(
)
const
;
template
<
typename
T
>
T
as
(
)
const
=
delete
;
template
<
typename
T
>
bool
is
(
)
const
=
delete
;
bool
isConvertibleTo
(
ValueType
other
)
const
;
ArrayIndex
size
(
)
const
;
bool
empty
(
)
const
;
JSONCPP_OP_EXPLICIT
operator
bool
(
)
const
;
void
clear
(
)
;
void
resize
(
ArrayIndex
newSize
)
;
Value
&
operator
[
]
(
ArrayIndex
index
)
;
Value
&
operator
[
]
(
int
index
)
;
const
Value
&
operator
[
]
(
ArrayIndex
index
)
const
;
const
Value
&
operator
[
]
(
int
index
)
const
;
Value
get
(
ArrayIndex
index
const
Value
&
defaultValue
)
const
;
bool
isValidIndex
(
ArrayIndex
index
)
const
;
Value
&
append
(
const
Value
&
value
)
;
Value
&
append
(
Value
&
&
value
)
;
bool
insert
(
ArrayIndex
index
Value
newValue
)
;
Value
&
operator
[
]
(
const
char
*
key
)
;
const
Value
&
operator
[
]
(
const
char
*
key
)
const
;
Value
&
operator
[
]
(
const
String
&
key
)
;
const
Value
&
operator
[
]
(
const
String
&
key
)
const
;
Value
&
operator
[
]
(
const
StaticString
&
key
)
;
#
ifdef
JSON_USE_CPPTL
Value
&
operator
[
]
(
const
CppTL
:
:
ConstString
&
key
)
;
const
Value
&
operator
[
]
(
const
CppTL
:
:
ConstString
&
key
)
const
;
#
endif
Value
get
(
const
char
*
key
const
Value
&
defaultValue
)
const
;
Value
get
(
const
char
*
begin
const
char
*
end
const
Value
&
defaultValue
)
const
;
Value
get
(
const
String
&
key
const
Value
&
defaultValue
)
const
;
#
ifdef
JSON_USE_CPPTL
Value
get
(
const
CppTL
:
:
ConstString
&
key
const
Value
&
defaultValue
)
const
;
#
endif
Value
const
*
find
(
char
const
*
begin
char
const
*
end
)
const
;
Value
*
demand
(
char
const
*
begin
char
const
*
end
)
;
void
removeMember
(
const
char
*
key
)
;
void
removeMember
(
const
String
&
key
)
;
bool
removeMember
(
const
char
*
key
Value
*
removed
)
;
bool
removeMember
(
String
const
&
key
Value
*
removed
)
;
bool
removeMember
(
const
char
*
begin
const
char
*
end
Value
*
removed
)
;
bool
removeIndex
(
ArrayIndex
index
Value
*
removed
)
;
bool
isMember
(
const
char
*
key
)
const
;
bool
isMember
(
const
String
&
key
)
const
;
bool
isMember
(
const
char
*
begin
const
char
*
end
)
const
;
#
ifdef
JSON_USE_CPPTL
bool
isMember
(
const
CppTL
:
:
ConstString
&
key
)
const
;
#
endif
Members
getMemberNames
(
)
const
;
JSONCPP_DEPRECATED
(
"
Use
setComment
(
String
const
&
)
instead
.
"
)
void
setComment
(
const
char
*
comment
CommentPlacement
placement
)
{
setComment
(
String
(
comment
strlen
(
comment
)
)
placement
)
;
}
void
setComment
(
const
char
*
comment
size_t
len
CommentPlacement
placement
)
{
setComment
(
String
(
comment
len
)
placement
)
;
}
void
setComment
(
String
comment
CommentPlacement
placement
)
;
bool
hasComment
(
CommentPlacement
placement
)
const
;
String
getComment
(
CommentPlacement
placement
)
const
;
String
toStyledString
(
)
const
;
const_iterator
begin
(
)
const
;
const_iterator
end
(
)
const
;
iterator
begin
(
)
;
iterator
end
(
)
;
void
setOffsetStart
(
ptrdiff_t
start
)
;
void
setOffsetLimit
(
ptrdiff_t
limit
)
;
ptrdiff_t
getOffsetStart
(
)
const
;
ptrdiff_t
getOffsetLimit
(
)
const
;
private
:
void
setType
(
ValueType
v
)
{
bits_
.
value_type_
=
static_cast
<
unsigned
char
>
(
v
)
;
}
bool
isAllocated
(
)
const
{
return
bits_
.
allocated_
;
}
void
setIsAllocated
(
bool
v
)
{
bits_
.
allocated_
=
v
;
}
void
initBasic
(
ValueType
type
bool
allocated
=
false
)
;
void
dupPayload
(
const
Value
&
other
)
;
void
releasePayload
(
)
;
void
dupMeta
(
const
Value
&
other
)
;
Value
&
resolveReference
(
const
char
*
key
)
;
Value
&
resolveReference
(
const
char
*
key
const
char
*
end
)
;
union
ValueHolder
{
LargestInt
int_
;
LargestUInt
uint_
;
double
real_
;
bool
bool_
;
char
*
string_
;
ObjectValues
*
map_
;
}
value_
;
struct
{
unsigned
int
value_type_
:
8
;
unsigned
int
allocated_
:
1
;
}
bits_
;
class
Comments
{
public
:
Comments
(
)
=
default
;
Comments
(
const
Comments
&
that
)
;
Comments
(
Comments
&
&
that
)
;
Comments
&
operator
=
(
const
Comments
&
that
)
;
Comments
&
operator
=
(
Comments
&
&
that
)
;
bool
has
(
CommentPlacement
slot
)
const
;
String
get
(
CommentPlacement
slot
)
const
;
void
set
(
CommentPlacement
slot
String
comment
)
;
private
:
using
Array
=
std
:
:
array
<
String
numberOfCommentPlacement
>
;
std
:
:
unique_ptr
<
Array
>
ptr_
;
}
;
Comments
comments_
;
ptrdiff_t
start_
;
ptrdiff_t
limit_
;
}
;
template
<
>
inline
bool
Value
:
:
as
<
bool
>
(
)
const
{
return
asBool
(
)
;
}
template
<
>
inline
bool
Value
:
:
is
<
bool
>
(
)
const
{
return
isBool
(
)
;
}
template
<
>
inline
Int
Value
:
:
as
<
Int
>
(
)
const
{
return
asInt
(
)
;
}
template
<
>
inline
bool
Value
:
:
is
<
Int
>
(
)
const
{
return
isInt
(
)
;
}
template
<
>
inline
UInt
Value
:
:
as
<
UInt
>
(
)
const
{
return
asUInt
(
)
;
}
template
<
>
inline
bool
Value
:
:
is
<
UInt
>
(
)
const
{
return
isUInt
(
)
;
}
#
if
defined
(
JSON_HAS_INT64
)
template
<
>
inline
Int64
Value
:
:
as
<
Int64
>
(
)
const
{
return
asInt64
(
)
;
}
template
<
>
inline
bool
Value
:
:
is
<
Int64
>
(
)
const
{
return
isInt64
(
)
;
}
template
<
>
inline
UInt64
Value
:
:
as
<
UInt64
>
(
)
const
{
return
asUInt64
(
)
;
}
template
<
>
inline
bool
Value
:
:
is
<
UInt64
>
(
)
const
{
return
isUInt64
(
)
;
}
#
endif
template
<
>
inline
double
Value
:
:
as
<
double
>
(
)
const
{
return
asDouble
(
)
;
}
template
<
>
inline
bool
Value
:
:
is
<
double
>
(
)
const
{
return
isDouble
(
)
;
}
template
<
>
inline
String
Value
:
:
as
<
String
>
(
)
const
{
return
asString
(
)
;
}
template
<
>
inline
bool
Value
:
:
is
<
String
>
(
)
const
{
return
isString
(
)
;
}
template
<
>
inline
float
Value
:
:
as
<
float
>
(
)
const
{
return
asFloat
(
)
;
}
template
<
>
inline
const
char
*
Value
:
:
as
<
const
char
*
>
(
)
const
{
return
asCString
(
)
;
}
#
ifdef
JSON_USE_CPPTL
template
<
>
inline
CppTL
:
:
ConstString
Value
:
:
as
<
CppTL
:
:
ConstString
>
(
)
const
{
return
asConstString
(
)
;
}
#
endif
class
JSON_API
PathArgument
{
public
:
friend
class
Path
;
PathArgument
(
)
;
PathArgument
(
ArrayIndex
index
)
;
PathArgument
(
const
char
*
key
)
;
PathArgument
(
String
key
)
;
private
:
enum
Kind
{
kindNone
=
0
kindIndex
kindKey
}
;
String
key_
;
ArrayIndex
index_
{
}
;
Kind
kind_
{
kindNone
}
;
}
;
class
JSON_API
Path
{
public
:
Path
(
const
String
&
path
const
PathArgument
&
a1
=
PathArgument
(
)
const
PathArgument
&
a2
=
PathArgument
(
)
const
PathArgument
&
a3
=
PathArgument
(
)
const
PathArgument
&
a4
=
PathArgument
(
)
const
PathArgument
&
a5
=
PathArgument
(
)
)
;
const
Value
&
resolve
(
const
Value
&
root
)
const
;
Value
resolve
(
const
Value
&
root
const
Value
&
defaultValue
)
const
;
Value
&
make
(
Value
&
root
)
const
;
private
:
typedef
std
:
:
vector
<
const
PathArgument
*
>
InArgs
;
typedef
std
:
:
vector
<
PathArgument
>
Args
;
void
makePath
(
const
String
&
path
const
InArgs
&
in
)
;
void
addPathInArg
(
const
String
&
path
const
InArgs
&
in
InArgs
:
:
const_iterator
&
itInArg
PathArgument
:
:
Kind
kind
)
;
static
void
invalidPath
(
const
String
&
path
int
location
)
;
Args
args_
;
}
;
class
JSON_API
ValueIteratorBase
{
public
:
typedef
std
:
:
bidirectional_iterator_tag
iterator_category
;
typedef
unsigned
int
size_t
;
typedef
int
difference_type
;
typedef
ValueIteratorBase
SelfType
;
bool
operator
=
=
(
const
SelfType
&
other
)
const
{
return
isEqual
(
other
)
;
}
bool
operator
!
=
(
const
SelfType
&
other
)
const
{
return
!
isEqual
(
other
)
;
}
difference_type
operator
-
(
const
SelfType
&
other
)
const
{
return
other
.
computeDistance
(
*
this
)
;
}
Value
key
(
)
const
;
UInt
index
(
)
const
;
String
name
(
)
const
;
JSONCPP_DEPRECATED
(
"
Use
key
=
name
(
)
;
instead
.
"
)
char
const
*
memberName
(
)
const
;
char
const
*
memberName
(
char
const
*
*
end
)
const
;
protected
:
const
Value
&
deref
(
)
const
;
Value
&
deref
(
)
;
void
increment
(
)
;
void
decrement
(
)
;
difference_type
computeDistance
(
const
SelfType
&
other
)
const
;
bool
isEqual
(
const
SelfType
&
other
)
const
;
void
copy
(
const
SelfType
&
other
)
;
private
:
Value
:
:
ObjectValues
:
:
iterator
current_
;
bool
isNull_
{
true
}
;
public
:
ValueIteratorBase
(
)
;
explicit
ValueIteratorBase
(
const
Value
:
:
ObjectValues
:
:
iterator
&
current
)
;
}
;
class
JSON_API
ValueConstIterator
:
public
ValueIteratorBase
{
friend
class
Value
;
public
:
typedef
const
Value
value_type
;
typedef
const
Value
&
reference
;
typedef
const
Value
*
pointer
;
typedef
ValueConstIterator
SelfType
;
ValueConstIterator
(
)
;
ValueConstIterator
(
ValueIterator
const
&
other
)
;
private
:
explicit
ValueConstIterator
(
const
Value
:
:
ObjectValues
:
:
iterator
&
current
)
;
public
:
SelfType
&
operator
=
(
const
ValueIteratorBase
&
other
)
;
SelfType
operator
+
+
(
int
)
{
SelfType
temp
(
*
this
)
;
+
+
*
this
;
return
temp
;
}
SelfType
operator
-
-
(
int
)
{
SelfType
temp
(
*
this
)
;
-
-
*
this
;
return
temp
;
}
SelfType
&
operator
-
-
(
)
{
decrement
(
)
;
return
*
this
;
}
SelfType
&
operator
+
+
(
)
{
increment
(
)
;
return
*
this
;
}
reference
operator
*
(
)
const
{
return
deref
(
)
;
}
pointer
operator
-
>
(
)
const
{
return
&
deref
(
)
;
}
}
;
class
JSON_API
ValueIterator
:
public
ValueIteratorBase
{
friend
class
Value
;
public
:
typedef
Value
value_type
;
typedef
unsigned
int
size_t
;
typedef
int
difference_type
;
typedef
Value
&
reference
;
typedef
Value
*
pointer
;
typedef
ValueIterator
SelfType
;
ValueIterator
(
)
;
explicit
ValueIterator
(
const
ValueConstIterator
&
other
)
;
ValueIterator
(
const
ValueIterator
&
other
)
;
private
:
explicit
ValueIterator
(
const
Value
:
:
ObjectValues
:
:
iterator
&
current
)
;
public
:
SelfType
&
operator
=
(
const
SelfType
&
other
)
;
SelfType
operator
+
+
(
int
)
{
SelfType
temp
(
*
this
)
;
+
+
*
this
;
return
temp
;
}
SelfType
operator
-
-
(
int
)
{
SelfType
temp
(
*
this
)
;
-
-
*
this
;
return
temp
;
}
SelfType
&
operator
-
-
(
)
{
decrement
(
)
;
return
*
this
;
}
SelfType
&
operator
+
+
(
)
{
increment
(
)
;
return
*
this
;
}
reference
operator
*
(
)
{
return
deref
(
)
;
}
pointer
operator
-
>
(
)
{
return
&
deref
(
)
;
}
}
;
inline
void
swap
(
Value
&
a
Value
&
b
)
{
a
.
swap
(
b
)
;
}
}
#
pragma
pack
(
pop
)
#
if
defined
(
JSONCPP_DISABLE_DLL_INTERFACE_WARNING
)
#
pragma
warning
(
pop
)
#
endif
#
endif
