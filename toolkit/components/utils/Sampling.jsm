"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
crypto
"
"
TextEncoder
"
]
)
;
var
EXPORTED_SYMBOLS
=
[
"
Sampling
"
]
;
const
hashBits
=
48
;
const
hashLength
=
hashBits
/
4
;
const
hashMultiplier
=
Math
.
pow
(
2
hashBits
)
-
1
;
var
Sampling
=
{
fractionToKey
(
frac
)
{
if
(
frac
<
0
|
|
frac
>
1
)
{
throw
new
Error
(
frac
must
be
between
0
and
1
inclusive
(
got
{
frac
}
)
)
;
}
return
Math
.
floor
(
frac
*
hashMultiplier
)
.
toString
(
16
)
.
padStart
(
hashLength
"
0
"
)
;
}
bufferToHex
(
buffer
)
{
const
hexCodes
=
[
]
;
const
view
=
new
DataView
(
buffer
)
;
for
(
let
i
=
0
;
i
<
view
.
byteLength
;
i
+
=
4
)
{
const
value
=
view
.
getUint32
(
i
)
;
hexCodes
.
push
(
value
.
toString
(
16
)
.
padStart
(
8
"
0
"
)
)
;
}
return
hexCodes
.
join
(
"
"
)
;
}
isHashInBucket
(
inputHash
minBucket
maxBucket
bucketCount
)
{
const
minHash
=
Sampling
.
fractionToKey
(
minBucket
/
bucketCount
)
;
const
maxHash
=
Sampling
.
fractionToKey
(
maxBucket
/
bucketCount
)
;
return
(
minHash
<
=
inputHash
)
&
&
(
inputHash
<
maxHash
)
;
}
async
truncatedHash
(
data
)
{
const
hasher
=
crypto
.
subtle
;
const
input
=
new
TextEncoder
(
"
utf
-
8
"
)
.
encode
(
JSON
.
stringify
(
data
)
)
;
const
hash
=
await
hasher
.
digest
(
"
SHA
-
256
"
input
)
;
return
Sampling
.
bufferToHex
(
hash
)
.
slice
(
0
12
)
;
}
async
stableSample
(
input
rate
)
{
const
inputHash
=
await
Sampling
.
truncatedHash
(
input
)
;
const
samplePoint
=
Sampling
.
fractionToKey
(
rate
)
;
return
inputHash
<
samplePoint
;
}
async
bucketSample
(
input
start
count
total
)
{
const
inputHash
=
await
Sampling
.
truncatedHash
(
input
)
;
const
wrappedStart
=
start
%
total
;
const
end
=
wrappedStart
+
count
;
if
(
end
>
total
)
{
return
(
Sampling
.
isHashInBucket
(
inputHash
0
end
%
total
total
)
|
|
Sampling
.
isHashInBucket
(
inputHash
wrappedStart
total
total
)
)
;
}
return
Sampling
.
isHashInBucket
(
inputHash
wrappedStart
end
total
)
;
}
async
ratioSample
(
input
ratios
)
{
if
(
ratios
.
length
<
1
)
{
throw
new
Error
(
ratios
must
be
at
least
1
element
long
(
got
length
:
{
ratios
.
length
}
)
)
;
}
const
inputHash
=
await
Sampling
.
truncatedHash
(
input
)
;
const
ratioTotal
=
ratios
.
reduce
(
(
acc
ratio
)
=
>
acc
+
ratio
)
;
let
samplePoint
=
0
;
for
(
let
k
=
0
;
k
<
ratios
.
length
-
1
;
k
+
+
)
{
samplePoint
+
=
ratios
[
k
]
;
if
(
inputHash
<
=
Sampling
.
fractionToKey
(
samplePoint
/
ratioTotal
)
)
{
return
k
;
}
}
return
ratios
.
length
-
1
;
}
}
;
