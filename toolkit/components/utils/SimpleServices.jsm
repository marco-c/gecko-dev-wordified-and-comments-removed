"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
streamConv
"
"
mozilla
.
org
/
streamConverters
;
1
"
"
nsIStreamConverterService
"
)
;
const
ArrayBufferInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
io
/
arraybuffer
-
input
-
stream
;
1
"
"
nsIArrayBufferInputStream
"
"
setData
"
)
;
function
AddonLocalizationConverter
(
)
{
}
AddonLocalizationConverter
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIStreamConverter
]
)
FROM_TYPE
:
"
application
/
vnd
.
mozilla
.
webext
.
unlocalized
"
TO_TYPE
:
"
text
/
css
"
checkTypes
(
aFromType
aToType
)
{
if
(
aFromType
!
=
this
.
FROM_TYPE
)
{
throw
Components
.
Exception
(
"
Invalid
aFromType
value
"
Cr
.
NS_ERROR_INVALID_ARG
Components
.
stack
.
caller
.
caller
)
;
}
if
(
aToType
!
=
this
.
TO_TYPE
)
{
throw
Components
.
Exception
(
"
Invalid
aToType
value
"
Cr
.
NS_ERROR_INVALID_ARG
Components
.
stack
.
caller
.
caller
)
;
}
}
getAddon
(
aContext
)
{
let
uri
=
Services
.
io
.
newURI
(
"
/
"
null
aContext
)
;
let
addon
=
WebExtensionPolicy
.
getByURI
(
uri
)
;
if
(
!
addon
)
{
throw
new
Components
.
Exception
(
"
Invalid
context
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
return
addon
;
}
convertToStream
(
aAddon
aString
)
{
aString
=
aAddon
.
localize
(
aString
)
;
let
bytes
=
new
TextEncoder
(
)
.
encode
(
aString
)
.
buffer
;
return
new
ArrayBufferInputStream
(
bytes
0
bytes
.
byteLength
)
;
}
convert
(
aStream
aFromType
aToType
aContext
)
{
this
.
checkTypes
(
aFromType
aToType
)
;
let
addon
=
this
.
getAddon
(
aContext
)
;
let
count
=
aStream
.
available
(
)
;
let
string
=
count
?
new
TextDecoder
(
)
.
decode
(
NetUtil
.
readInputStream
(
aStream
count
)
)
:
"
"
;
return
this
.
convertToStream
(
addon
string
)
;
}
asyncConvertData
(
aFromType
aToType
aListener
aContext
)
{
this
.
checkTypes
(
aFromType
aToType
)
;
this
.
addon
=
this
.
getAddon
(
aContext
)
;
this
.
listener
=
aListener
;
}
onStartRequest
(
aRequest
aContext
)
{
this
.
parts
=
[
]
;
this
.
decoder
=
new
TextDecoder
(
)
;
}
onDataAvailable
(
aRequest
aContext
aInputStream
aOffset
aCount
)
{
let
bytes
=
NetUtil
.
readInputStream
(
aInputStream
aCount
)
;
this
.
parts
.
push
(
this
.
decoder
.
decode
(
bytes
{
stream
:
true
}
)
)
;
}
onStopRequest
(
aRequest
aContext
aStatusCode
)
{
try
{
this
.
listener
.
onStartRequest
(
aRequest
null
)
;
if
(
Components
.
isSuccessCode
(
aStatusCode
)
)
{
this
.
parts
.
push
(
this
.
decoder
.
decode
(
)
)
;
let
string
=
this
.
parts
.
join
(
"
"
)
;
let
stream
=
this
.
convertToStream
(
this
.
addon
string
)
;
this
.
listener
.
onDataAvailable
(
aRequest
null
stream
0
stream
.
available
(
)
)
;
}
}
catch
(
e
)
{
aStatusCode
=
e
.
result
|
|
Cr
.
NS_ERROR_FAILURE
;
}
this
.
listener
.
onStopRequest
(
aRequest
null
aStatusCode
)
;
}
}
;
function
HttpIndexViewer
(
)
{
}
HttpIndexViewer
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIDocumentLoaderFactory
]
)
createInstance
(
aCommand
aChannel
aLoadGroup
aContentType
aContainer
aExtraInfo
aDocListenerResult
)
{
aChannel
.
contentType
=
"
text
/
html
"
;
let
contract
=
Services
.
catMan
.
getCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
"
text
/
html
"
)
;
let
factory
=
Cc
[
contract
]
.
getService
(
Ci
.
nsIDocumentLoaderFactory
)
;
let
listener
=
{
}
;
let
res
=
factory
.
createInstance
(
"
view
"
aChannel
aLoadGroup
"
text
/
html
"
aContainer
aExtraInfo
listener
)
;
aDocListenerResult
.
value
=
streamConv
.
asyncConvertData
(
"
application
/
http
-
index
-
format
"
"
text
/
html
"
listener
.
value
null
)
;
return
res
;
}
}
;
var
EXPORTED_SYMBOLS
=
[
"
AddonLocalizationConverter
"
"
HttpIndexViewer
"
]
;
