use
crate
:
:
{
error
:
:
{
XULStoreError
XULStoreResult
}
statics
:
:
get_database
}
;
use
crossbeam_utils
:
:
atomic
:
:
AtomicCell
;
use
moz_task
:
:
{
dispatch_background_task_with_options
DispatchOptions
Task
TaskRunnable
}
;
use
nserror
:
:
nsresult
;
use
once_cell
:
:
sync
:
:
Lazy
;
use
rkv
:
:
{
StoreError
as
RkvStoreError
Value
}
;
use
std
:
:
{
collections
:
:
HashMap
sync
:
:
Mutex
thread
:
:
sleep
time
:
:
Duration
}
;
use
xpcom
:
:
RefPtr
;
static
CHANGES
:
Lazy
<
Mutex
<
Option
<
HashMap
<
String
Option
<
String
>
>
>
>
>
=
Lazy
:
:
new
(
|
|
Mutex
:
:
new
(
None
)
)
;
static
PERSIST
:
Lazy
<
Mutex
<
(
)
>
>
=
Lazy
:
:
new
(
|
|
Mutex
:
:
new
(
(
)
)
)
;
fn
sync_persist
(
)
-
>
XULStoreResult
<
(
)
>
{
let
writes
=
CHANGES
.
lock
(
)
?
.
take
(
)
;
let
writes
=
writes
.
ok_or
(
XULStoreError
:
:
Unavailable
)
?
;
let
db
=
get_database
(
)
?
;
let
env
=
db
.
rkv
.
read
(
)
?
;
let
mut
writer
=
env
.
write
(
)
?
;
for
(
key
value
)
in
writes
.
iter
(
)
{
match
value
{
Some
(
val
)
=
>
db
.
store
.
put
(
&
mut
writer
&
key
&
Value
:
:
Str
(
val
)
)
?
None
=
>
{
match
db
.
store
.
delete
(
&
mut
writer
&
key
)
{
Ok
(
_
)
=
>
(
)
Err
(
RkvStoreError
:
:
KeyValuePairNotFound
)
=
>
{
warn
!
(
"
tried
to
remove
key
that
isn
'
t
in
the
store
"
)
;
}
Err
(
err
)
=
>
return
Err
(
err
.
into
(
)
)
}
}
}
}
writer
.
commit
(
)
?
;
Ok
(
(
)
)
}
pub
(
crate
)
fn
flush_writes
(
)
-
>
XULStoreResult
<
(
)
>
{
let
_lock
=
PERSIST
.
lock
(
)
?
;
match
sync_persist
(
)
{
Ok
(
_
)
=
>
(
)
Err
(
XULStoreError
:
:
Unavailable
)
=
>
{
info
!
(
"
Unable
to
persist
xulstore
"
)
;
}
Err
(
err
)
=
>
return
Err
(
err
.
into
(
)
)
}
Ok
(
(
)
)
}
pub
(
crate
)
fn
persist
(
key
:
String
value
:
Option
<
String
>
)
-
>
XULStoreResult
<
(
)
>
{
let
mut
changes
=
CHANGES
.
lock
(
)
?
;
if
changes
.
is_none
(
)
{
*
changes
=
Some
(
HashMap
:
:
new
(
)
)
;
let
task
=
Box
:
:
new
(
PersistTask
:
:
new
(
)
)
;
dispatch_background_task_with_options
(
RefPtr
:
:
new
(
TaskRunnable
:
:
new
(
"
XULStore
:
:
Persist
"
task
)
?
.
coerce
(
)
)
DispatchOptions
:
:
default
(
)
.
may_block
(
true
)
)
?
;
}
changes
.
as_mut
(
)
.
unwrap
(
)
.
insert
(
key
value
)
;
Ok
(
(
)
)
}
pub
struct
PersistTask
{
result
:
AtomicCell
<
Option
<
Result
<
(
)
XULStoreError
>
>
>
}
impl
PersistTask
{
pub
fn
new
(
)
-
>
PersistTask
{
PersistTask
{
result
:
AtomicCell
:
:
default
(
)
}
}
}
impl
Task
for
PersistTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
(
)
XULStoreError
>
{
sleep
(
Duration
:
:
from_millis
(
200
)
)
;
let
_lock
=
PERSIST
.
lock
(
)
?
;
sync_persist
(
)
}
(
)
)
)
;
}
fn
done
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
match
self
.
result
.
swap
(
None
)
{
Some
(
Ok
(
(
)
)
)
=
>
(
)
Some
(
Err
(
err
)
)
=
>
error
!
(
"
removeDocument
error
:
{
}
"
err
)
None
=
>
error
!
(
"
removeDocument
error
:
unexpected
result
"
)
}
;
Ok
(
(
)
)
}
}
