use
crate
:
:
{
error
:
:
{
XULStoreError
XULStoreResult
}
statics
:
:
get_database
}
;
use
crossbeam_utils
:
:
atomic
:
:
AtomicCell
;
use
lmdb
:
:
Error
as
LmdbError
;
use
moz_task
:
:
{
dispatch_background_task_with_options
DispatchOptions
Task
TaskRunnable
}
;
use
nserror
:
:
nsresult
;
use
rkv
:
:
{
StoreError
as
RkvStoreError
Value
}
;
use
std
:
:
{
collections
:
:
HashMap
sync
:
:
Mutex
thread
:
:
sleep
time
:
:
Duration
}
;
use
xpcom
:
:
RefPtr
;
lazy_static
!
{
/
/
/
A
map
of
key
/
value
pairs
to
persist
.
Values
are
Options
so
we
can
/
/
/
use
the
same
structure
for
both
puts
and
deletes
with
a
None
value
/
/
/
identifying
a
key
that
should
be
deleted
from
the
database
.
/
/
/
/
/
/
This
is
a
map
rather
than
a
sequence
in
order
to
merge
consecutive
/
/
/
changes
to
the
same
key
i
.
e
.
when
a
consumer
sets
*
foo
*
to
bar
/
/
/
and
then
sets
it
again
to
baz
before
we
persist
the
first
change
.
/
/
/
/
/
/
In
that
case
there
'
s
no
point
in
setting
*
foo
*
to
bar
before
we
set
/
/
/
it
to
baz
and
the
map
ensures
we
only
ever
persist
the
latest
value
/
/
/
for
any
given
key
.
static
ref
CHANGES
:
Mutex
<
Option
<
HashMap
<
String
Option
<
String
>
>
>
>
=
{
Mutex
:
:
new
(
None
)
}
;
/
/
/
A
Mutex
that
prevents
two
PersistTasks
from
running
at
the
same
time
/
/
/
since
each
task
opens
the
database
and
we
need
to
ensure
there
is
only
/
/
/
one
open
database
handle
for
the
database
at
any
given
time
.
static
ref
PERSIST
:
Mutex
<
(
)
>
=
{
Mutex
:
:
new
(
(
)
)
}
;
}
fn
sync_persist
(
)
-
>
XULStoreResult
<
(
)
>
{
let
db
=
get_database
(
)
?
;
let
mut
writer
=
db
.
env
.
write
(
)
?
;
let
writes
=
CHANGES
.
lock
(
)
?
.
take
(
)
;
let
writes
=
writes
.
ok_or
(
XULStoreError
:
:
Unavailable
)
?
;
for
(
key
value
)
in
writes
.
iter
(
)
{
match
value
{
Some
(
val
)
=
>
db
.
store
.
put
(
&
mut
writer
&
key
&
Value
:
:
Str
(
val
)
)
?
None
=
>
{
match
db
.
store
.
delete
(
&
mut
writer
&
key
)
{
Ok
(
_
)
=
>
(
)
Err
(
RkvStoreError
:
:
LmdbError
(
LmdbError
:
:
NotFound
)
)
=
>
{
warn
!
(
"
tried
to
remove
key
that
isn
'
t
in
the
store
"
)
;
}
Err
(
err
)
=
>
return
Err
(
err
.
into
(
)
)
}
}
}
}
writer
.
commit
(
)
?
;
Ok
(
(
)
)
}
pub
(
crate
)
fn
flush_writes
(
)
-
>
XULStoreResult
<
(
)
>
{
let
_lock
=
PERSIST
.
lock
(
)
?
;
match
sync_persist
(
)
{
Ok
(
_
)
=
>
(
)
Err
(
XULStoreError
:
:
Unavailable
)
=
>
{
info
!
(
"
Unable
to
persist
xulstore
"
)
;
}
Err
(
err
)
=
>
return
Err
(
err
.
into
(
)
)
}
Ok
(
(
)
)
}
pub
(
crate
)
fn
persist
(
key
:
String
value
:
Option
<
String
>
)
-
>
XULStoreResult
<
(
)
>
{
let
mut
changes
=
CHANGES
.
lock
(
)
?
;
if
changes
.
is_none
(
)
{
*
changes
=
Some
(
HashMap
:
:
new
(
)
)
;
let
task
=
Box
:
:
new
(
PersistTask
:
:
new
(
)
)
;
dispatch_background_task_with_options
(
RefPtr
:
:
new
(
TaskRunnable
:
:
new
(
"
XULStore
:
:
Persist
"
task
)
?
.
coerce
(
)
)
DispatchOptions
:
:
default
(
)
.
may_block
(
true
)
)
?
;
}
changes
.
as_mut
(
)
.
unwrap
(
)
.
insert
(
key
value
)
;
Ok
(
(
)
)
}
pub
struct
PersistTask
{
result
:
AtomicCell
<
Option
<
Result
<
(
)
XULStoreError
>
>
>
}
impl
PersistTask
{
pub
fn
new
(
)
-
>
PersistTask
{
PersistTask
{
result
:
AtomicCell
:
:
default
(
)
}
}
}
impl
Task
for
PersistTask
{
fn
run
(
&
self
)
{
self
.
result
.
store
(
Some
(
|
|
-
>
Result
<
(
)
XULStoreError
>
{
sleep
(
Duration
:
:
from_millis
(
200
)
)
;
let
_lock
=
PERSIST
.
lock
(
)
?
;
sync_persist
(
)
}
(
)
)
)
;
}
fn
done
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
match
self
.
result
.
swap
(
None
)
{
Some
(
Ok
(
(
)
)
)
=
>
(
)
Some
(
Err
(
err
)
)
=
>
error
!
(
"
removeDocument
error
:
{
}
"
err
)
None
=
>
error
!
(
"
removeDocument
error
:
unexpected
result
"
)
}
;
Ok
(
(
)
)
}
}
