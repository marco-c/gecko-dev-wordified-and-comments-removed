"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
BroadcastConduit
"
"
ConduitsParent
"
]
;
const
{
ExtensionUtils
:
{
DefaultMap
DefaultWeakMap
}
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
{
BaseConduit
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ConduitsChild
.
jsm
"
)
;
const
BATCH_TIMEOUT_MS
=
250
;
const
ADDON_ENV
=
new
Set
(
[
"
addon_child
"
"
devtools_child
"
]
)
;
const
Hub
=
{
remotes
:
new
Map
(
)
conduits
:
new
Map
(
)
byMethod
:
new
Map
(
)
byActor
:
new
DefaultWeakMap
(
(
)
=
>
new
Set
(
)
)
onRemoteClosed
:
new
DefaultMap
(
(
)
=
>
new
Set
(
)
)
openConduit
(
conduit
)
{
this
.
conduits
.
set
(
conduit
.
id
conduit
)
;
for
(
let
name
of
conduit
.
address
.
recv
|
|
[
]
)
{
if
(
this
.
byMethod
.
get
(
name
)
)
{
throw
new
Error
(
Duplicate
BroadcastConduit
method
name
recv
{
name
}
)
;
}
this
.
byMethod
.
set
(
name
conduit
)
;
}
}
closeConduit
(
{
id
address
}
)
{
this
.
conduits
.
delete
(
id
)
;
for
(
let
name
of
address
.
recv
|
|
[
]
)
{
this
.
byMethod
.
remove
(
name
)
;
}
}
verifyEnv
(
{
actor
envType
extensionId
}
)
{
if
(
!
extensionId
|
|
!
ADDON_ENV
.
has
(
envType
)
)
{
return
false
;
}
let
windowGlobal
=
actor
.
manager
;
while
(
windowGlobal
)
{
let
{
browsingContext
:
bc
documentPrincipal
:
prin
}
=
windowGlobal
;
if
(
prin
.
addonId
!
=
=
extensionId
)
{
throw
new
Error
(
Bad
{
extensionId
}
principal
:
{
prin
.
URI
.
spec
}
)
;
}
if
(
bc
.
currentRemoteType
!
=
=
prin
.
addonPolicy
.
extension
.
remoteType
)
{
throw
new
Error
(
Bad
{
extensionId
}
process
:
{
bc
.
currentRemoteType
}
)
;
}
if
(
!
bc
.
parent
)
{
return
true
;
}
windowGlobal
=
bc
.
embedderWindowGlobal
;
}
throw
new
Error
(
Missing
WindowGlobalParent
for
{
extensionId
}
)
;
}
recvConduitOpened
(
address
actor
)
{
address
.
actor
=
actor
;
address
.
verified
=
this
.
verifyEnv
(
address
)
;
this
.
remotes
.
set
(
address
.
id
address
)
;
this
.
byActor
.
get
(
actor
)
.
add
(
address
)
;
}
recvConduitClosed
(
remote
)
{
this
.
remotes
.
delete
(
remote
.
id
)
;
this
.
byActor
.
get
(
remote
.
actor
)
.
delete
(
remote
)
;
remote
.
actor
=
null
;
for
(
let
conduit
of
this
.
onRemoteClosed
.
get
(
remote
.
id
)
)
{
conduit
.
subject
.
recvConduitClosed
(
remote
)
;
}
}
actorClosed
(
actor
)
{
for
(
let
remote
of
this
.
byActor
.
get
(
actor
)
)
{
this
.
recvConduitClosed
(
remote
)
;
}
this
.
byActor
.
delete
(
actor
)
;
}
}
;
class
BroadcastConduit
extends
BaseConduit
{
constructor
(
subject
address
)
{
super
(
subject
address
)
;
this
.
open
=
true
;
Hub
.
openConduit
(
this
)
;
}
_send
(
method
query
target
arg
=
{
}
)
{
if
(
!
this
.
open
)
{
throw
new
Error
(
send
{
method
}
on
closed
conduit
{
this
.
id
}
)
;
}
let
sender
=
this
.
id
;
let
{
actor
}
=
Hub
.
remotes
.
get
(
target
)
;
if
(
method
=
=
=
"
RunListener
"
&
&
arg
.
path
.
startsWith
(
"
webRequest
.
"
)
)
{
return
actor
.
batch
(
method
{
target
arg
query
sender
}
)
;
}
return
super
.
_send
(
method
query
actor
{
target
arg
query
sender
}
)
;
}
reportOnClosed
(
target
)
{
Hub
.
onRemoteClosed
.
get
(
target
)
.
add
(
this
)
;
}
async
close
(
)
{
this
.
open
=
false
;
Hub
.
closeConduit
(
this
)
;
}
}
class
ConduitsParent
extends
JSWindowActorParent
{
constructor
(
)
{
super
(
)
;
this
.
batchData
=
[
]
;
this
.
batchPromise
=
null
;
}
async
batch
(
name
data
)
{
let
num
=
this
.
batchData
.
length
;
this
.
batchData
.
push
(
data
)
;
if
(
!
num
)
{
let
resolve
;
this
.
batchPromise
=
new
Promise
(
r
=
>
(
resolve
=
r
)
)
;
let
send
=
(
)
=
>
{
resolve
(
this
.
manager
&
&
this
.
sendQuery
(
name
this
.
batchData
)
)
;
this
.
batchData
=
[
]
;
}
;
ChromeUtils
.
idleDispatch
(
send
{
timeout
:
BATCH_TIMEOUT_MS
}
)
;
}
let
results
=
await
this
.
batchPromise
;
return
results
&
&
results
[
num
]
;
}
async
receiveMessage
(
{
name
data
:
{
arg
query
sender
}
}
)
{
if
(
name
=
=
=
"
ConduitOpened
"
)
{
return
Hub
.
recvConduitOpened
(
arg
this
)
;
}
sender
=
Hub
.
remotes
.
get
(
sender
)
;
if
(
!
sender
|
|
sender
.
actor
!
=
=
this
)
{
throw
new
Error
(
Unknown
sender
or
wrong
actor
for
recv
{
name
}
)
;
}
if
(
name
=
=
=
"
ConduitClosed
"
)
{
return
Hub
.
recvConduitClosed
(
sender
)
;
}
let
conduit
=
Hub
.
byMethod
.
get
(
name
)
;
if
(
!
conduit
)
{
throw
new
Error
(
Parent
conduit
for
recv
{
name
}
not
found
)
;
}
return
conduit
.
_recv
(
name
arg
{
actor
:
this
query
sender
}
)
;
}
willDestroy
(
)
{
Hub
.
actorClosed
(
this
)
;
}
didDestroy
(
)
{
this
.
willDestroy
(
)
;
}
}
