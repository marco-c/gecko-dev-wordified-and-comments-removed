"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
BroadcastConduit
"
"
ConduitsParent
"
]
;
const
{
ExtensionUtils
:
{
DefaultWeakMap
ExtensionError
}
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
{
BaseConduit
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ConduitsChild
.
jsm
"
)
;
const
{
WebNavigationFrames
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
WebNavigationFrames
.
jsm
"
)
;
const
BATCH_TIMEOUT_MS
=
250
;
const
ADDON_ENV
=
new
Set
(
[
"
addon_child
"
"
devtools_child
"
]
)
;
const
Hub
=
{
remotes
:
new
Map
(
)
conduits
:
new
Map
(
)
byMethod
:
new
Map
(
)
byActor
:
new
DefaultWeakMap
(
(
)
=
>
new
Set
(
)
)
reportOnClosed
:
new
Map
(
)
openConduit
(
conduit
)
{
this
.
conduits
.
set
(
conduit
.
id
conduit
)
;
for
(
let
name
of
conduit
.
address
.
recv
|
|
[
]
)
{
if
(
this
.
byMethod
.
get
(
name
)
)
{
throw
new
Error
(
Duplicate
BroadcastConduit
method
name
recv
{
name
}
)
;
}
this
.
byMethod
.
set
(
name
conduit
)
;
}
}
closeConduit
(
{
id
address
}
)
{
this
.
conduits
.
delete
(
id
)
;
for
(
let
name
of
address
.
recv
|
|
[
]
)
{
this
.
byMethod
.
remove
(
name
)
;
}
}
verifyEnv
(
{
actor
envType
extensionId
}
)
{
if
(
!
extensionId
|
|
!
ADDON_ENV
.
has
(
envType
)
)
{
return
false
;
}
let
windowGlobal
=
actor
.
manager
;
while
(
windowGlobal
)
{
let
{
browsingContext
:
bc
documentPrincipal
:
prin
}
=
windowGlobal
;
if
(
prin
.
addonId
!
=
=
extensionId
)
{
throw
new
Error
(
Bad
{
extensionId
}
principal
:
{
prin
.
URI
.
spec
}
)
;
}
if
(
bc
.
currentRemoteType
!
=
=
prin
.
addonPolicy
.
extension
.
remoteType
)
{
throw
new
Error
(
Bad
{
extensionId
}
process
:
{
bc
.
currentRemoteType
}
)
;
}
if
(
!
bc
.
parent
)
{
return
true
;
}
windowGlobal
=
bc
.
embedderWindowGlobal
;
}
throw
new
Error
(
Missing
WindowGlobalParent
for
{
extensionId
}
)
;
}
fillInAddress
(
address
actor
)
{
address
.
actor
=
actor
;
address
.
verified
=
this
.
verifyEnv
(
address
)
;
address
.
frameId
=
WebNavigationFrames
.
getFrameId
(
actor
.
browsingContext
)
;
address
.
url
=
actor
.
browsingContext
.
currentURI
.
spec
;
}
recvConduitOpened
(
address
actor
)
{
this
.
fillInAddress
(
address
actor
)
;
this
.
remotes
.
set
(
address
.
id
address
)
;
this
.
byActor
.
get
(
actor
)
.
add
(
address
)
;
}
recvConduitClosed
(
remote
)
{
this
.
remotes
.
delete
(
remote
.
id
)
;
this
.
byActor
.
get
(
remote
.
actor
)
.
delete
(
remote
)
;
remote
.
actor
=
null
;
for
(
let
[
key
conduit
]
of
Hub
.
reportOnClosed
.
entries
(
)
)
{
if
(
remote
[
key
]
)
{
conduit
.
subject
.
recvConduitClosed
(
remote
)
;
}
}
}
actorClosed
(
actor
)
{
for
(
let
remote
of
this
.
byActor
.
get
(
actor
)
)
{
this
.
remotes
.
delete
(
remote
.
id
)
;
}
for
(
let
remote
of
this
.
byActor
.
get
(
actor
)
)
{
this
.
recvConduitClosed
(
remote
)
;
}
this
.
byActor
.
delete
(
actor
)
;
}
}
;
class
BroadcastConduit
extends
BaseConduit
{
constructor
(
subject
address
)
{
super
(
subject
address
)
;
for
(
let
name
of
address
.
cast
|
|
[
]
)
{
this
[
cast
{
name
}
]
=
this
.
_cast
.
bind
(
this
name
)
;
}
if
(
address
.
reportOnClosed
)
{
Hub
.
reportOnClosed
.
set
(
address
.
reportOnClosed
this
)
;
}
this
.
open
=
true
;
Hub
.
openConduit
(
this
)
;
}
_send
(
method
query
target
arg
=
{
}
)
{
if
(
!
this
.
open
)
{
throw
new
Error
(
send
{
method
}
on
closed
conduit
{
this
.
id
}
)
;
}
let
sender
=
this
.
id
;
let
{
actor
}
=
Hub
.
remotes
.
get
(
target
)
;
if
(
method
=
=
=
"
RunListener
"
&
&
arg
.
path
.
startsWith
(
"
webRequest
.
"
)
)
{
return
actor
.
batch
(
method
{
target
arg
query
sender
}
)
;
}
return
super
.
_send
(
method
query
actor
{
target
arg
query
sender
}
)
;
}
_cast
(
method
kind
arg
)
{
let
filters
=
{
port
:
remote
=
>
remote
.
portId
=
=
=
arg
.
portId
&
&
(
arg
.
source
=
=
null
|
|
remote
.
source
=
=
=
arg
.
source
)
messenger
:
r
=
>
r
.
verified
&
&
r
.
id
!
=
=
arg
.
sender
.
contextId
&
&
r
.
extensionId
=
=
=
arg
.
extensionId
&
&
r
.
recv
.
includes
(
method
)
&
&
(
r
.
envType
=
=
=
"
addon_child
"
|
|
arg
.
sender
.
envType
!
=
=
"
content_child
"
)
tab
:
remote
=
>
remote
.
extensionId
=
=
=
arg
.
extensionId
&
&
remote
.
actor
.
manager
.
browsingContext
.
top
.
id
=
=
=
arg
.
topBC
&
&
(
arg
.
frameId
=
=
null
|
|
remote
.
frameId
=
=
=
arg
.
frameId
)
&
&
remote
.
recv
.
includes
(
method
)
}
;
let
targets
=
Array
.
from
(
Hub
.
remotes
.
values
(
)
)
.
filter
(
filters
[
kind
]
)
;
let
promises
=
targets
.
map
(
c
=
>
this
.
_send
(
method
true
c
.
id
arg
)
)
;
return
arg
.
firstResponse
?
this
.
_raceResponses
(
promises
)
:
Promise
.
allSettled
(
promises
)
;
}
_raceResponses
(
promises
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
result
;
promises
.
map
(
p
=
>
p
.
then
(
value
=
>
{
if
(
value
.
response
)
{
resolve
(
value
)
;
}
else
if
(
value
.
received
)
{
result
=
value
;
}
}
)
.
catch
(
err
=
>
{
if
(
err
instanceof
ExtensionError
|
|
err
?
.
mozWebExtLocation
)
{
reject
(
err
)
;
}
else
{
Cu
.
reportError
(
err
)
;
}
}
)
)
;
Promise
.
allSettled
(
promises
)
.
then
(
(
)
=
>
resolve
(
result
)
)
;
}
)
;
}
async
close
(
)
{
this
.
open
=
false
;
Hub
.
closeConduit
(
this
)
;
}
}
class
ConduitsParent
extends
JSWindowActorParent
{
constructor
(
)
{
super
(
)
;
this
.
batchData
=
[
]
;
this
.
batchPromise
=
null
;
this
.
batchResolve
=
null
;
this
.
timerActive
=
false
;
}
batch
(
name
data
)
{
let
pos
=
this
.
batchData
.
length
;
this
.
batchData
.
push
(
data
)
;
let
sendNow
=
idleDispatch
=
>
{
if
(
this
.
batchData
.
length
&
&
this
.
manager
)
{
this
.
batchResolve
(
this
.
sendQuery
(
name
this
.
batchData
)
)
;
}
else
{
this
.
batchResolve
(
[
]
)
;
}
this
.
batchData
=
[
]
;
this
.
timerActive
=
!
idleDispatch
;
}
;
if
(
!
pos
)
{
this
.
batchPromise
=
new
Promise
(
r
=
>
(
this
.
batchResolve
=
r
)
)
;
if
(
!
this
.
timerActive
)
{
ChromeUtils
.
idleDispatch
(
sendNow
{
timeout
:
BATCH_TIMEOUT_MS
}
)
;
this
.
timerActive
=
true
;
}
}
if
(
data
.
arg
.
urgentSend
)
{
sendNow
(
false
)
;
}
return
this
.
batchPromise
.
then
(
results
=
>
results
[
pos
]
)
;
}
async
receiveMessage
(
{
name
data
:
{
arg
query
sender
}
}
)
{
if
(
name
=
=
=
"
ConduitOpened
"
)
{
return
Hub
.
recvConduitOpened
(
arg
this
)
;
}
sender
=
Hub
.
remotes
.
get
(
sender
)
;
if
(
!
sender
|
|
sender
.
actor
!
=
=
this
)
{
throw
new
Error
(
Unknown
sender
or
wrong
actor
for
recv
{
name
}
)
;
}
if
(
name
=
=
=
"
ConduitClosed
"
)
{
return
Hub
.
recvConduitClosed
(
sender
)
;
}
let
conduit
=
Hub
.
byMethod
.
get
(
name
)
;
if
(
!
conduit
)
{
throw
new
Error
(
Parent
conduit
for
recv
{
name
}
not
found
)
;
}
return
conduit
.
_recv
(
name
arg
{
actor
:
this
query
sender
}
)
;
}
didDestroy
(
)
{
Hub
.
actorClosed
(
this
)
;
}
}
