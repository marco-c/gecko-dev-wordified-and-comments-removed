"
use
strict
"
;
importScripts
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
"
resource
:
/
/
gre
/
modules
/
profiler_get_symbols
.
js
"
)
;
const
{
CompactSymbolTable
WasmMemBuffer
get_compact_symbol_table
}
=
wasm_bindgen
;
function
readFileInto
(
file
dataBuf
)
{
const
dataBufLen
=
dataBuf
.
byteLength
;
const
chunkSize
=
4
*
1024
*
1024
;
let
pos
=
0
;
while
(
pos
<
dataBufLen
)
{
const
chunkData
=
file
.
read
(
{
bytes
:
chunkSize
}
)
;
const
chunkBytes
=
chunkData
.
byteLength
;
if
(
chunkBytes
=
=
=
0
)
{
break
;
}
dataBuf
.
set
(
chunkData
pos
)
;
pos
+
=
chunkBytes
;
}
}
onmessage
=
async
e
=
>
{
try
{
const
{
binaryPath
debugPath
breakpadId
module
}
=
e
.
data
;
if
(
!
(
module
instanceof
WebAssembly
.
Module
)
)
{
throw
new
Error
(
"
invalid
WebAssembly
module
"
)
;
}
await
wasm_bindgen
(
module
)
;
const
binaryFile
=
OS
.
File
.
open
(
binaryPath
{
read
:
true
}
)
;
const
binaryData
=
new
WasmMemBuffer
(
binaryFile
.
stat
(
)
.
size
array
=
>
{
readFileInto
(
binaryFile
array
)
;
}
)
;
binaryFile
.
close
(
)
;
let
debugData
=
binaryData
;
if
(
debugPath
&
&
debugPath
!
=
=
binaryPath
)
{
const
debugFile
=
OS
.
File
.
open
(
debugPath
{
read
:
true
}
)
;
debugData
=
new
WasmMemBuffer
(
debugFile
.
stat
(
)
.
size
array
=
>
{
readFileInto
(
debugFile
array
)
;
}
)
;
debugFile
.
close
(
)
;
}
const
output
=
new
CompactSymbolTable
(
)
;
let
succeeded
;
try
{
succeeded
=
get_compact_symbol_table
(
binaryData
debugData
breakpadId
output
)
;
}
catch
(
e
)
{
succeeded
=
false
;
}
binaryData
.
free
(
)
;
if
(
debugData
!
=
binaryData
)
{
debugData
.
free
(
)
;
}
if
(
!
succeeded
)
{
output
.
free
(
)
;
throw
new
Error
(
"
get_compact_symbol_table
returned
false
"
)
;
}
const
result
=
[
output
.
take_addr
(
)
output
.
take_index
(
)
output
.
take_buffer
(
)
]
;
output
.
free
(
)
;
postMessage
(
{
result
}
result
.
map
(
r
=
>
r
.
buffer
)
)
;
}
catch
(
error
)
{
postMessage
(
{
error
:
error
.
toString
(
)
}
)
;
}
close
(
)
;
}
;
