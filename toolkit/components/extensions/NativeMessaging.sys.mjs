import
{
XPCOMUtils
}
from
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
;
import
{
AppConstants
}
from
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
;
import
{
EventEmitter
}
from
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
sys
.
mjs
"
;
import
{
ExtensionUtils
}
from
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
sys
.
mjs
"
;
const
MAX_READ
=
1024
*
1024
;
const
MAX_WRITE
=
0xffffffff
;
const
PREF_MAX_READ
=
"
webextensions
.
native
-
messaging
.
max
-
input
-
message
-
bytes
"
;
const
PREF_MAX_WRITE
=
"
webextensions
.
native
-
messaging
.
max
-
output
-
message
-
bytes
"
;
const
lazy
=
XPCOMUtils
.
declareLazy
(
{
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
sys
.
mjs
"
NativeManifests
:
"
resource
:
/
/
gre
/
modules
/
NativeManifests
.
sys
.
mjs
"
Subprocess
:
"
resource
:
/
/
gre
/
modules
/
Subprocess
.
sys
.
mjs
"
maxRead
:
{
pref
:
PREF_MAX_READ
default
:
MAX_READ
}
maxWrite
:
{
pref
:
PREF_MAX_WRITE
default
:
MAX_WRITE
}
portal
:
{
service
:
"
mozilla
.
org
/
extensions
/
native
-
messaging
-
portal
;
1
"
iid
:
Ci
.
nsINativeMessagingPortal
}
}
)
;
const
{
ExtensionError
promiseTimeout
}
=
ExtensionUtils
;
const
GRACEFUL_SHUTDOWN_TIME
=
3000
;
export
class
NativeApp
extends
EventEmitter
{
_throwGenericError
(
application
)
{
throw
new
ExtensionError
(
No
such
native
application
{
application
}
)
;
}
constructor
(
context
application
)
{
super
(
)
;
this
.
context
=
context
;
this
.
name
=
application
;
this
.
context
.
callOnClose
(
this
)
;
this
.
proc
=
null
;
this
.
readPromise
=
null
;
this
.
sendQueue
=
[
]
;
this
.
writePromise
=
null
;
this
.
cleanupStarted
=
false
;
this
.
portalSessionHandle
=
null
;
if
(
"
mozilla
.
org
/
extensions
/
native
-
messaging
-
portal
;
1
"
in
Cc
)
{
if
(
lazy
.
portal
.
shouldUse
(
)
)
{
this
.
startupPromise
=
this
.
_doInitPortal
(
)
.
catch
(
err
=
>
{
this
.
startupPromise
=
null
;
Cu
.
reportError
(
err
instanceof
Error
?
err
:
err
.
message
)
;
this
.
_cleanup
(
err
)
;
}
)
;
return
;
}
}
this
.
startupPromise
=
lazy
.
NativeManifests
.
lookupManifest
(
"
stdio
"
application
context
)
.
then
(
hostInfo
=
>
{
if
(
!
hostInfo
)
{
this
.
_throwGenericError
(
application
)
;
}
let
command
=
hostInfo
.
manifest
.
path
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
command
=
command
.
replaceAll
(
"
/
"
"
\
\
"
)
;
if
(
!
PathUtils
.
isAbsolute
(
command
)
)
{
const
parentPath
=
PathUtils
.
parent
(
hostInfo
.
path
.
replaceAll
(
"
/
"
"
\
\
"
)
)
;
command
=
{
parentPath
}
\
\
{
command
}
;
}
}
let
subprocessOpts
=
{
command
:
command
arguments
:
[
hostInfo
.
path
context
.
extension
.
id
]
workdir
:
PathUtils
.
parent
(
command
)
stderr
:
"
pipe
"
disclaim
:
true
}
;
return
lazy
.
Subprocess
.
call
(
subprocessOpts
)
;
}
)
.
then
(
proc
=
>
{
this
.
startupPromise
=
null
;
this
.
proc
=
proc
;
this
.
_startRead
(
)
;
this
.
_startWrite
(
)
;
this
.
_startStderrRead
(
)
;
}
)
.
catch
(
err
=
>
{
this
.
startupPromise
=
null
;
Cu
.
reportError
(
err
instanceof
Error
?
err
:
err
.
message
)
;
this
.
_cleanup
(
err
)
;
}
)
;
}
async
_doInitPortal
(
)
{
let
available
=
await
lazy
.
portal
.
available
;
if
(
!
available
)
{
Cu
.
reportError
(
"
Native
messaging
portal
is
not
available
"
)
;
this
.
_throwGenericError
(
this
.
name
)
;
}
let
handle
=
await
lazy
.
portal
.
createSession
(
this
.
name
)
;
this
.
portalSessionHandle
=
handle
;
let
hostInfo
=
null
;
let
path
;
try
{
let
manifest
=
await
lazy
.
portal
.
getManifest
(
handle
this
.
name
this
.
context
.
extension
.
id
)
;
path
=
manifest
.
substring
(
0
30
)
+
"
.
.
.
"
;
hostInfo
=
await
lazy
.
NativeManifests
.
parseManifest
(
"
stdio
"
path
this
.
name
this
.
context
JSON
.
parse
(
manifest
)
)
;
}
catch
(
ex
)
{
if
(
ex
instanceof
SyntaxError
&
&
ex
.
message
.
startsWith
(
"
JSON
.
parse
:
"
)
)
{
Cu
.
reportError
(
Error
parsing
native
manifest
{
path
}
:
{
ex
.
message
}
)
;
this
.
_throwGenericError
(
this
.
name
)
;
}
}
if
(
!
hostInfo
)
{
this
.
_throwGenericError
(
this
.
name
)
;
}
let
pipes
;
try
{
pipes
=
await
lazy
.
portal
.
start
(
handle
this
.
name
this
.
context
.
extension
.
id
)
;
}
catch
(
err
)
{
if
(
err
.
name
=
=
"
NotFoundError
"
)
{
this
.
_throwGenericError
(
this
.
name
)
;
}
else
{
throw
err
;
}
}
this
.
proc
=
await
lazy
.
Subprocess
.
connectRunning
(
[
pipes
.
stdin
pipes
.
stdout
pipes
.
stderr
]
)
;
this
.
startupPromise
=
null
;
this
.
_startRead
(
)
;
this
.
_startWrite
(
)
;
this
.
_startStderrRead
(
)
;
}
onConnect
(
portId
port
)
{
this
.
on
(
"
message
"
(
_
message
)
=
>
{
port
.
sendPortMessage
(
portId
new
StructuredCloneHolder
(
NativeMessaging
/
onConnect
/
{
this
.
name
}
null
message
)
)
;
}
)
;
this
.
once
(
"
disconnect
"
(
_
error
)
=
>
{
port
.
sendPortDisconnect
(
portId
error
&
&
new
ClonedErrorHolder
(
error
)
)
;
}
)
;
return
{
onPortMessage
:
holder
=
>
this
.
send
(
holder
)
onPortDisconnect
:
(
)
=
>
this
.
close
(
)
}
;
}
static
encodeMessage
(
context
message
)
{
message
=
context
.
jsonStringify
(
message
)
;
let
buffer
=
new
TextEncoder
(
)
.
encode
(
message
)
.
buffer
;
if
(
buffer
.
byteLength
>
lazy
.
maxWrite
)
{
throw
new
context
.
Error
(
"
Write
too
big
"
)
;
}
return
buffer
;
}
get
_isDisconnected
(
)
{
return
!
this
.
proc
&
&
!
this
.
startupPromise
;
}
_startRead
(
)
{
if
(
this
.
readPromise
)
{
throw
new
Error
(
"
Entered
_startRead
(
)
while
readPromise
is
non
-
null
"
)
;
}
this
.
readPromise
=
this
.
proc
.
stdout
.
readUint32
(
)
.
then
(
len
=
>
{
if
(
len
>
lazy
.
maxRead
)
{
throw
new
ExtensionError
(
Native
application
tried
to
send
a
message
of
{
len
}
bytes
which
exceeds
the
limit
of
{
lazy
.
maxRead
}
bytes
.
)
;
}
return
this
.
proc
.
stdout
.
readJSON
(
len
)
;
}
)
.
then
(
msg
=
>
{
this
.
emit
(
"
message
"
msg
)
;
this
.
readPromise
=
null
;
this
.
_startRead
(
)
;
}
)
.
catch
(
err
=
>
{
if
(
err
.
errorCode
!
=
lazy
.
Subprocess
.
ERROR_END_OF_FILE
)
{
Cu
.
reportError
(
err
instanceof
Error
?
err
:
err
.
message
)
;
}
this
.
_cleanup
(
err
)
;
}
)
;
}
_startWrite
(
)
{
if
(
!
this
.
sendQueue
.
length
)
{
return
;
}
if
(
this
.
writePromise
)
{
throw
new
Error
(
"
Entered
_startWrite
(
)
while
writePromise
is
non
-
null
"
)
;
}
let
buffer
=
this
.
sendQueue
.
shift
(
)
;
let
uintArray
=
Uint32Array
.
of
(
buffer
.
byteLength
)
;
this
.
writePromise
=
Promise
.
all
(
[
this
.
proc
.
stdin
.
write
(
uintArray
.
buffer
)
this
.
proc
.
stdin
.
write
(
buffer
)
]
)
.
then
(
(
)
=
>
{
this
.
writePromise
=
null
;
this
.
_startWrite
(
)
;
}
)
.
catch
(
err
=
>
{
Cu
.
reportError
(
err
.
message
)
;
this
.
_cleanup
(
err
)
;
}
)
;
}
_startStderrRead
(
)
{
let
proc
=
this
.
proc
;
let
app
=
this
.
name
;
(
async
function
(
)
{
let
partial
=
"
"
;
while
(
true
)
{
let
data
=
await
proc
.
stderr
.
readString
(
)
;
if
(
!
data
.
length
)
{
if
(
partial
)
{
Services
.
console
.
logStringMessage
(
stderr
output
from
native
app
{
app
}
:
{
partial
}
)
;
}
break
;
}
let
lines
=
data
.
split
(
/
\
r
?
\
n
/
)
;
lines
[
0
]
=
partial
+
lines
[
0
]
;
partial
=
lines
.
pop
(
)
;
for
(
let
line
of
lines
)
{
Services
.
console
.
logStringMessage
(
stderr
output
from
native
app
{
app
}
:
{
line
}
)
;
}
}
}
)
(
)
;
}
send
(
holder
)
{
if
(
this
.
_isDisconnected
)
{
throw
new
ExtensionError
(
"
Attempt
to
postMessage
on
disconnected
port
"
)
;
}
let
msg
=
holder
.
deserialize
(
globalThis
)
;
if
(
Cu
.
getClassName
(
msg
true
)
!
=
"
ArrayBuffer
"
)
{
throw
new
Error
(
"
The
message
to
the
native
messaging
host
is
not
an
ArrayBuffer
"
)
;
}
let
buffer
=
msg
;
if
(
buffer
.
byteLength
>
lazy
.
maxWrite
)
{
throw
new
ExtensionError
(
"
Write
too
big
"
)
;
}
this
.
sendQueue
.
push
(
buffer
)
;
if
(
!
this
.
startupPromise
&
&
!
this
.
writePromise
)
{
this
.
_startWrite
(
)
;
}
}
async
_cleanup
(
err
fromExtension
=
false
)
{
if
(
this
.
cleanupStarted
)
{
return
;
}
this
.
cleanupStarted
=
true
;
this
.
context
.
forgetOnClose
(
this
)
;
if
(
!
fromExtension
)
{
if
(
err
&
&
err
.
errorCode
=
=
lazy
.
Subprocess
.
ERROR_END_OF_FILE
)
{
err
=
null
;
}
this
.
emit
(
"
disconnect
"
err
)
;
}
await
this
.
startupPromise
;
if
(
this
.
portalSessionHandle
)
{
if
(
this
.
writePromise
)
{
await
this
.
writePromise
.
catch
(
Cu
.
reportError
)
;
}
await
lazy
.
portal
.
closeSession
(
this
.
portalSessionHandle
)
.
catch
(
Cu
.
reportError
)
;
this
.
portalSessionHandle
=
null
;
this
.
proc
?
.
kill
(
)
;
this
.
proc
=
null
;
return
;
}
if
(
!
this
.
proc
)
{
return
;
}
this
.
proc
.
stdin
.
close
(
)
.
catch
(
err
=
>
{
if
(
err
.
errorCode
!
=
lazy
.
Subprocess
.
ERROR_END_OF_FILE
)
{
Cu
.
reportError
(
err
)
;
}
}
)
;
let
exitPromise
=
Promise
.
race
(
[
this
.
proc
.
wait
(
)
.
then
(
(
)
=
>
{
this
.
proc
=
null
;
}
)
promiseTimeout
(
GRACEFUL_SHUTDOWN_TIME
)
.
then
(
(
)
=
>
{
if
(
this
.
proc
)
{
this
.
proc
.
kill
(
GRACEFUL_SHUTDOWN_TIME
)
;
return
promiseTimeout
(
2
*
GRACEFUL_SHUTDOWN_TIME
)
;
}
}
)
]
)
;
lazy
.
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
Native
Messaging
:
Wait
for
application
{
this
.
name
}
to
exit
exitPromise
)
;
}
close
(
)
{
this
.
_cleanup
(
null
true
)
;
}
sendMessage
(
holder
)
{
let
responsePromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
once
(
"
message
"
(
what
msg
)
=
>
{
resolve
(
msg
)
;
}
)
;
this
.
once
(
"
disconnect
"
(
what
err
)
=
>
{
reject
(
err
)
;
}
)
;
}
)
;
let
result
=
this
.
startupPromise
.
then
(
(
)
=
>
{
if
(
!
this
.
cleanupStarted
)
{
this
.
send
(
holder
)
;
}
return
responsePromise
;
}
)
;
result
.
then
(
(
)
=
>
{
this
.
_cleanup
(
)
;
}
(
)
=
>
{
responsePromise
.
catch
(
(
)
=
>
{
}
)
;
this
.
_cleanup
(
)
;
}
)
;
return
result
;
}
}
