#
ifndef
mozilla_extensions_MatchPattern_h
#
define
mozilla_extensions_MatchPattern_h
#
include
<
utility
>
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
MatchPatternBinding
.
h
"
#
include
"
mozilla
/
extensions
/
MatchGlob
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefCounted
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsICookie
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsWrapperCache
.
h
"
namespace
mozilla
{
namespace
extensions
{
using
dom
:
:
MatchPatternOptions
;
class
AtomSet
final
:
public
RefCounted
<
AtomSet
>
{
using
ArrayType
=
AutoTArray
<
RefPtr
<
nsAtom
>
1
>
;
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
AtomSet
)
explicit
AtomSet
(
const
nsTArray
<
nsString
>
&
aElems
)
;
explicit
AtomSet
(
const
char
*
*
aElems
)
;
MOZ_IMPLICIT
AtomSet
(
std
:
:
initializer_list
<
nsAtom
*
>
aIL
)
;
bool
Contains
(
const
nsAString
&
elem
)
const
{
RefPtr
<
nsAtom
>
atom
=
NS_AtomizeMainThread
(
elem
)
;
return
Contains
(
atom
)
;
}
bool
Contains
(
const
nsACString
&
aElem
)
const
{
RefPtr
<
nsAtom
>
atom
=
NS_Atomize
(
aElem
)
;
return
Contains
(
atom
)
;
}
bool
Contains
(
const
nsAtom
*
aAtom
)
const
{
return
mElems
.
ContainsSorted
(
aAtom
)
;
}
bool
Intersects
(
const
AtomSet
&
aOther
)
const
;
void
Add
(
nsAtom
*
aElem
)
;
void
Remove
(
nsAtom
*
aElem
)
;
void
Add
(
const
nsAString
&
aElem
)
{
RefPtr
<
nsAtom
>
atom
=
NS_AtomizeMainThread
(
aElem
)
;
return
Add
(
atom
)
;
}
void
Remove
(
const
nsAString
&
aElem
)
{
RefPtr
<
nsAtom
>
atom
=
NS_AtomizeMainThread
(
aElem
)
;
return
Remove
(
atom
)
;
}
template
<
const
char
*
*
schemes
>
[
[
nodiscard
]
]
static
nsresult
Get
(
RefPtr
<
AtomSet
>
&
aMatcherOut
)
{
static
RefPtr
<
AtomSet
>
sMatcher
;
if
(
MOZ_UNLIKELY
(
!
sMatcher
)
)
{
if
(
PastShutdownPhase
(
ShutdownPhase
:
:
XPCOMShutdownFinal
)
)
{
aMatcherOut
=
nullptr
;
return
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
}
sMatcher
=
new
AtomSet
(
schemes
)
;
ClearOnShutdown
(
&
sMatcher
)
;
}
MOZ_ASSERT
(
sMatcher
)
;
aMatcherOut
=
do_AddRef
(
sMatcher
)
;
return
NS_OK
;
}
void
Get
(
nsTArray
<
nsString
>
&
aResult
)
const
{
aResult
.
SetCapacity
(
mElems
.
Length
(
)
)
;
for
(
const
auto
&
atom
:
mElems
)
{
aResult
.
AppendElement
(
nsDependentAtomString
(
atom
)
)
;
}
}
auto
begin
(
)
const
-
>
decltype
(
std
:
:
declval
<
const
ArrayType
>
(
)
.
begin
(
)
)
{
return
mElems
.
begin
(
)
;
}
auto
end
(
)
const
-
>
decltype
(
std
:
:
declval
<
const
ArrayType
>
(
)
.
end
(
)
)
{
return
mElems
.
end
(
)
;
}
private
:
ArrayType
mElems
;
void
SortAndUniquify
(
)
;
}
;
class
URLInfo
final
{
public
:
MOZ_IMPLICIT
URLInfo
(
nsIURI
*
aURI
)
:
mURI
(
aURI
)
{
mHost
.
SetIsVoid
(
true
)
;
}
URLInfo
(
nsIURI
*
aURI
bool
aNoRef
)
:
URLInfo
(
aURI
)
{
if
(
aNoRef
)
{
mURINoRef
=
mURI
;
}
}
URLInfo
(
const
URLInfo
&
aOther
)
:
URLInfo
(
aOther
.
mURI
.
get
(
)
)
{
}
nsIURI
*
URI
(
)
const
{
return
mURI
;
}
nsAtom
*
Scheme
(
)
const
;
const
nsCString
&
Host
(
)
const
;
const
nsAtom
*
HostAtom
(
)
const
;
const
nsString
&
Path
(
)
const
;
const
nsString
&
FilePath
(
)
const
;
const
nsString
&
Spec
(
)
const
;
const
nsCString
&
CSpec
(
)
const
;
bool
InheritsPrincipal
(
)
const
;
private
:
nsIURI
*
URINoRef
(
)
const
;
nsCOMPtr
<
nsIURI
>
mURI
;
mutable
nsCOMPtr
<
nsIURI
>
mURINoRef
;
mutable
RefPtr
<
nsAtom
>
mScheme
;
mutable
nsCString
mHost
;
mutable
RefPtr
<
nsAtom
>
mHostAtom
;
mutable
nsString
mPath
;
mutable
nsString
mFilePath
;
mutable
nsString
mSpec
;
mutable
nsCString
mCSpec
;
mutable
Maybe
<
bool
>
mInheritsPrincipal
;
}
;
class
MOZ_STACK_CLASS
CookieInfo
final
{
public
:
MOZ_IMPLICIT
CookieInfo
(
nsICookie
*
aCookie
)
:
mCookie
(
aCookie
)
{
}
bool
IsSecure
(
)
const
;
bool
IsDomain
(
)
const
;
const
nsCString
&
Host
(
)
const
;
const
nsCString
&
RawHost
(
)
const
;
private
:
nsCOMPtr
<
nsICookie
>
mCookie
;
mutable
Maybe
<
bool
>
mIsSecure
;
mutable
Maybe
<
bool
>
mIsDomain
;
mutable
nsCString
mHost
;
mutable
nsCString
mRawHost
;
}
;
class
MatchPattern
final
:
public
nsISupports
public
nsWrapperCache
{
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
MatchPattern
)
static
already_AddRefed
<
MatchPattern
>
Constructor
(
dom
:
:
GlobalObject
&
aGlobal
const
nsAString
&
aPattern
const
MatchPatternOptions
&
aOptions
ErrorResult
&
aRv
)
;
bool
Matches
(
const
nsAString
&
aURL
bool
aExplicit
ErrorResult
&
aRv
)
const
;
bool
Matches
(
const
URLInfo
&
aURL
bool
aExplicit
=
false
)
const
;
bool
Matches
(
const
URLInfo
&
aURL
bool
aExplicit
ErrorResult
&
aRv
)
const
{
return
Matches
(
aURL
aExplicit
)
;
}
bool
MatchesCookie
(
const
CookieInfo
&
aCookie
)
const
;
bool
MatchesDomain
(
const
nsACString
&
aDomain
)
const
;
bool
Subsumes
(
const
MatchPattern
&
aPattern
)
const
;
bool
SubsumesDomain
(
const
MatchPattern
&
aPattern
)
const
;
bool
Overlaps
(
const
MatchPattern
&
aPattern
)
const
;
bool
DomainIsWildcard
(
)
const
{
return
mMatchSubdomain
&
&
mDomain
.
IsEmpty
(
)
;
}
void
GetPattern
(
nsAString
&
aPattern
)
const
{
aPattern
=
mPattern
;
}
nsISupports
*
GetParentObject
(
)
const
{
return
mParent
;
}
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
HandleObject
aGivenProto
)
override
;
protected
:
virtual
~
MatchPattern
(
)
=
default
;
private
:
explicit
MatchPattern
(
nsISupports
*
aParent
)
:
mParent
(
aParent
)
{
}
void
Init
(
JSContext
*
aCx
const
nsAString
&
aPattern
bool
aIgnorePath
bool
aRestrictSchemes
ErrorResult
&
aRv
)
;
nsCOMPtr
<
nsISupports
>
mParent
;
nsString
mPattern
;
RefPtr
<
AtomSet
>
mSchemes
;
nsCString
mDomain
;
bool
mMatchSubdomain
=
false
;
RefPtr
<
MatchGlob
>
mPath
;
public
:
static
bool
MatchesAllURLs
(
const
URLInfo
&
aURL
)
;
}
;
class
MatchPatternSet
final
:
public
nsISupports
public
nsWrapperCache
{
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
MatchPatternSet
)
using
ArrayType
=
nsTArray
<
RefPtr
<
MatchPattern
>
>
;
static
already_AddRefed
<
MatchPatternSet
>
Constructor
(
dom
:
:
GlobalObject
&
aGlobal
const
nsTArray
<
dom
:
:
OwningStringOrMatchPattern
>
&
aPatterns
const
MatchPatternOptions
&
aOptions
ErrorResult
&
aRv
)
;
bool
Matches
(
const
nsAString
&
aURL
bool
aExplicit
ErrorResult
&
aRv
)
const
;
bool
Matches
(
const
URLInfo
&
aURL
bool
aExplicit
=
false
)
const
;
bool
Matches
(
const
URLInfo
&
aURL
bool
aExplicit
ErrorResult
&
aRv
)
const
{
return
Matches
(
aURL
aExplicit
)
;
}
bool
MatchesCookie
(
const
CookieInfo
&
aCookie
)
const
;
bool
Subsumes
(
const
MatchPattern
&
aPattern
)
const
;
bool
SubsumesDomain
(
const
MatchPattern
&
aPattern
)
const
;
bool
Overlaps
(
const
MatchPattern
&
aPattern
)
const
;
bool
Overlaps
(
const
MatchPatternSet
&
aPatternSet
)
const
;
bool
OverlapsAll
(
const
MatchPatternSet
&
aPatternSet
)
const
;
void
GetPatterns
(
ArrayType
&
aPatterns
)
{
aPatterns
.
AppendElements
(
mPatterns
)
;
}
nsISupports
*
GetParentObject
(
)
const
{
return
mParent
;
}
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
HandleObject
aGivenProto
)
override
;
protected
:
virtual
~
MatchPatternSet
(
)
=
default
;
private
:
explicit
MatchPatternSet
(
nsISupports
*
aParent
ArrayType
&
&
aPatterns
)
:
mParent
(
aParent
)
mPatterns
(
std
:
:
forward
<
ArrayType
>
(
aPatterns
)
)
{
}
nsCOMPtr
<
nsISupports
>
mParent
;
ArrayType
mPatterns
;
}
;
}
}
#
endif
