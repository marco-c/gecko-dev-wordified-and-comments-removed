"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ExtensionShortcuts
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionParent
"
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionSettingsStore
"
"
resource
:
/
/
gre
/
modules
/
ExtensionSettingsStore
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
windowTracker
"
(
)
=
>
{
return
ExtensionParent
.
apiManager
.
global
.
windowTracker
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
browserActionFor
"
(
)
=
>
{
return
ExtensionParent
.
apiManager
.
global
.
browserActionFor
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
pageActionFor
"
(
)
=
>
{
return
ExtensionParent
.
apiManager
.
global
.
pageActionFor
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
sidebarActionFor
"
(
)
=
>
{
return
ExtensionParent
.
apiManager
.
global
.
sidebarActionFor
;
}
)
;
const
{
chromeModifierKeyMap
ExtensionError
}
=
ExtensionUtils
;
const
{
makeWidgetId
}
=
ExtensionCommon
;
const
EXECUTE_PAGE_ACTION
=
"
_execute_page_action
"
;
const
EXECUTE_BROWSER_ACTION
=
"
_execute_browser_action
"
;
const
EXECUTE_SIDEBAR_ACTION
=
"
_execute_sidebar_action
"
;
function
normalizeShortcut
(
shortcut
)
{
return
shortcut
?
shortcut
.
replace
(
/
\
s
+
/
g
"
"
)
:
null
;
}
class
ExtensionShortcuts
{
static
async
removeCommandsFromStorage
(
extensionId
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
ExtensionSettingsStore
.
getAllForExtension
(
extensionId
"
commands
"
)
.
forEach
(
key
=
>
{
ExtensionSettingsStore
.
removeSetting
(
extensionId
"
commands
"
key
)
;
}
)
;
}
constructor
(
{
extension
onCommand
}
)
{
this
.
keysetsMap
=
new
WeakMap
(
)
;
this
.
windowOpenListener
=
null
;
this
.
extension
=
extension
;
this
.
onCommand
=
onCommand
;
this
.
id
=
makeWidgetId
(
extension
.
id
)
;
}
async
allCommands
(
)
{
let
commands
=
await
this
.
commands
;
return
Array
.
from
(
commands
(
[
name
command
]
)
=
>
{
return
(
{
name
description
:
command
.
description
shortcut
:
command
.
shortcut
}
)
;
}
)
;
}
async
updateCommand
(
{
name
description
shortcut
}
)
{
let
{
extension
}
=
this
;
let
commands
=
await
this
.
commands
;
let
command
=
commands
.
get
(
name
)
;
if
(
!
command
)
{
throw
new
ExtensionError
(
Unknown
command
"
{
name
}
"
)
;
}
let
previousUpdates
=
await
ExtensionSettingsStore
.
getSetting
(
"
commands
"
name
extension
.
id
)
;
let
commandUpdates
=
(
previousUpdates
&
&
previousUpdates
.
value
)
|
|
{
}
;
if
(
description
&
&
description
!
=
command
.
description
)
{
commandUpdates
.
description
=
description
;
command
.
description
=
description
;
}
if
(
shortcut
&
&
shortcut
!
=
command
.
shortcut
)
{
shortcut
=
normalizeShortcut
(
shortcut
)
;
commandUpdates
.
shortcut
=
shortcut
;
command
.
shortcut
=
shortcut
;
}
await
ExtensionSettingsStore
.
addSetting
(
extension
.
id
"
commands
"
name
commandUpdates
)
;
this
.
registerKeys
(
commands
)
;
}
async
resetCommand
(
name
)
{
let
{
extension
manifestCommands
}
=
this
;
let
commands
=
await
this
.
commands
;
let
command
=
commands
.
get
(
name
)
;
if
(
!
command
)
{
throw
new
ExtensionError
(
Unknown
command
"
{
name
}
"
)
;
}
let
storedCommand
=
ExtensionSettingsStore
.
getSetting
(
"
commands
"
name
extension
.
id
)
;
if
(
storedCommand
&
&
storedCommand
.
value
)
{
commands
.
set
(
name
{
.
.
.
manifestCommands
.
get
(
name
)
}
)
;
ExtensionSettingsStore
.
removeSetting
(
extension
.
id
"
commands
"
name
)
;
this
.
registerKeys
(
commands
)
;
}
}
loadCommands
(
)
{
let
{
extension
}
=
this
;
this
.
manifestCommands
=
this
.
loadCommandsFromManifest
(
extension
.
manifest
)
;
this
.
commands
=
new
Promise
(
async
(
resolve
)
=
>
{
let
commands
=
new
Map
(
)
;
this
.
manifestCommands
.
forEach
(
(
command
name
)
=
>
{
commands
.
set
(
name
{
.
.
.
command
}
)
;
}
)
;
let
savedCommands
=
await
this
.
loadCommandsFromStorage
(
extension
.
id
)
;
savedCommands
.
forEach
(
(
update
name
)
=
>
{
let
command
=
commands
.
get
(
name
)
;
if
(
command
)
{
Object
.
assign
(
command
update
)
;
}
}
)
;
resolve
(
commands
)
;
}
)
;
}
registerKeys
(
commands
)
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
this
.
registerKeysToDocument
(
window
commands
)
;
}
}
async
register
(
)
{
let
commands
=
await
this
.
commands
;
this
.
registerKeys
(
commands
)
;
this
.
windowOpenListener
=
(
window
)
=
>
{
if
(
!
this
.
keysetsMap
.
has
(
window
)
)
{
this
.
registerKeysToDocument
(
window
commands
)
;
}
}
;
windowTracker
.
addOpenListener
(
this
.
windowOpenListener
)
;
}
unregister
(
)
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
if
(
this
.
keysetsMap
.
has
(
window
)
)
{
this
.
keysetsMap
.
get
(
window
)
.
remove
(
)
;
}
}
windowTracker
.
removeOpenListener
(
this
.
windowOpenListener
)
;
}
loadCommandsFromManifest
(
manifest
)
{
let
commands
=
new
Map
(
)
;
let
{
PlatformInfo
}
=
ExtensionParent
;
let
os
=
PlatformInfo
.
os
=
=
"
win
"
?
"
windows
"
:
PlatformInfo
.
os
;
for
(
let
[
name
command
]
of
Object
.
entries
(
manifest
.
commands
)
)
{
let
suggested_key
=
command
.
suggested_key
|
|
{
}
;
let
shortcut
=
normalizeShortcut
(
suggested_key
[
os
]
|
|
suggested_key
.
default
)
;
commands
.
set
(
name
{
description
:
command
.
description
shortcut
}
)
;
}
return
commands
;
}
async
loadCommandsFromStorage
(
extensionId
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
names
=
ExtensionSettingsStore
.
getAllForExtension
(
extensionId
"
commands
"
)
;
return
names
.
reduce
(
(
map
name
)
=
>
{
let
command
=
ExtensionSettingsStore
.
getSetting
(
"
commands
"
name
extensionId
)
.
value
;
return
map
.
set
(
name
command
)
;
}
new
Map
(
)
)
;
}
registerKeysToDocument
(
window
commands
)
{
let
doc
=
window
.
document
;
let
keyset
=
doc
.
createXULElement
(
"
keyset
"
)
;
keyset
.
id
=
ext
-
keyset
-
id
-
{
this
.
id
}
;
if
(
this
.
keysetsMap
.
has
(
window
)
)
{
this
.
keysetsMap
.
get
(
window
)
.
remove
(
)
;
}
let
sidebarKey
;
commands
.
forEach
(
(
command
name
)
=
>
{
if
(
command
.
shortcut
)
{
let
parts
=
command
.
shortcut
.
split
(
"
+
"
)
;
let
key
=
parts
.
pop
(
)
;
if
(
/
^
[
0
-
9
]
/
.
test
(
key
)
)
{
let
shortcutWithNumpad
=
command
.
shortcut
.
replace
(
/
[
0
-
9
]
/
"
Numpad
&
"
)
;
let
numpadKeyElement
=
this
.
buildKey
(
doc
name
shortcutWithNumpad
)
;
keyset
.
appendChild
(
numpadKeyElement
)
;
}
let
keyElement
=
this
.
buildKey
(
doc
name
command
.
shortcut
)
;
keyset
.
appendChild
(
keyElement
)
;
if
(
name
=
=
EXECUTE_SIDEBAR_ACTION
)
{
sidebarKey
=
keyElement
;
}
}
}
)
;
doc
.
documentElement
.
appendChild
(
keyset
)
;
if
(
sidebarKey
)
{
window
.
SidebarUI
.
updateShortcut
(
{
key
:
sidebarKey
}
)
;
}
this
.
keysetsMap
.
set
(
window
keyset
)
;
}
buildKey
(
doc
name
shortcut
)
{
let
keyElement
=
this
.
buildKeyFromShortcut
(
doc
name
shortcut
)
;
keyElement
.
setAttribute
(
"
oncommand
"
"
/
/
"
)
;
keyElement
.
addEventListener
(
"
command
"
(
event
)
=
>
{
let
action
;
if
(
name
=
=
EXECUTE_PAGE_ACTION
)
{
action
=
pageActionFor
(
this
.
extension
)
;
}
else
if
(
name
=
=
EXECUTE_BROWSER_ACTION
)
{
action
=
browserActionFor
(
this
.
extension
)
;
}
else
if
(
name
=
=
EXECUTE_SIDEBAR_ACTION
)
{
action
=
sidebarActionFor
(
this
.
extension
)
;
}
else
{
this
.
extension
.
tabManager
.
addActiveTabPermission
(
)
;
this
.
onCommand
(
name
)
;
return
;
}
if
(
action
)
{
let
win
=
event
.
target
.
ownerGlobal
;
action
.
triggerAction
(
win
)
;
}
}
)
;
return
keyElement
;
}
buildKeyFromShortcut
(
doc
name
shortcut
)
{
let
keyElement
=
doc
.
createXULElement
(
"
key
"
)
;
let
parts
=
shortcut
.
split
(
"
+
"
)
;
let
chromeKey
=
parts
.
pop
(
)
;
keyElement
.
setAttribute
(
"
modifiers
"
this
.
getModifiersAttribute
(
parts
)
)
;
if
(
name
=
=
EXECUTE_SIDEBAR_ACTION
&
&
!
chromeKey
.
startsWith
(
"
Numpad
"
)
)
{
let
id
=
ext
-
key
-
id
-
{
this
.
id
}
-
sidebar
-
action
;
keyElement
.
setAttribute
(
"
id
"
id
)
;
}
if
(
/
^
[
A
-
Z
]
/
.
test
(
chromeKey
)
)
{
keyElement
.
setAttribute
(
"
key
"
chromeKey
)
;
}
else
{
keyElement
.
setAttribute
(
"
keycode
"
this
.
getKeycodeAttribute
(
chromeKey
)
)
;
keyElement
.
setAttribute
(
"
event
"
"
keydown
"
)
;
}
return
keyElement
;
}
getKeycodeAttribute
(
chromeKey
)
{
if
(
/
^
[
0
-
9
]
/
.
test
(
chromeKey
)
)
{
return
VK_
{
chromeKey
}
;
}
return
VK
{
chromeKey
.
replace
(
/
(
[
A
-
Z
]
)
/
g
"
_
&
"
)
.
toUpperCase
(
)
}
;
}
getModifiersAttribute
(
chromeModifiers
)
{
return
Array
.
from
(
chromeModifiers
modifier
=
>
{
return
chromeModifierKeyMap
[
modifier
]
;
}
)
.
join
(
"
"
)
;
}
}
