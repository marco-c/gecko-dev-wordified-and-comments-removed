"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ExtensionShortcuts
"
"
ExtensionShortcutKeyMap
"
]
;
const
{
ExtensionCommon
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
{
ShortcutUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ShortcutUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionParent
"
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionSettingsStore
"
"
resource
:
/
/
gre
/
modules
/
ExtensionSettingsStore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
Object
.
defineProperties
(
this
{
windowTracker
:
{
get
(
)
{
return
ExtensionParent
.
apiManager
.
global
.
windowTracker
;
}
}
browserActionFor
:
{
get
(
)
{
return
ExtensionParent
.
apiManager
.
global
.
browserActionFor
;
}
}
pageActionFor
:
{
get
(
)
{
return
ExtensionParent
.
apiManager
.
global
.
pageActionFor
;
}
}
sidebarActionFor
:
{
get
(
)
{
return
ExtensionParent
.
apiManager
.
global
.
sidebarActionFor
;
}
}
}
)
;
const
{
ExtensionError
DefaultMap
}
=
ExtensionUtils
;
const
{
makeWidgetId
}
=
ExtensionCommon
;
const
EXECUTE_SIDEBAR_ACTION
=
"
_execute_sidebar_action
"
;
function
normalizeShortcut
(
shortcut
)
{
return
shortcut
?
shortcut
.
replace
(
/
\
s
+
/
g
"
"
)
:
"
"
;
}
class
ExtensionShortcutKeyMap
extends
DefaultMap
{
async
buildForAddonIds
(
addonIds
)
{
this
.
clear
(
)
;
for
(
const
addonId
of
addonIds
)
{
const
policy
=
WebExtensionPolicy
.
getByID
(
addonId
)
;
if
(
policy
?
.
extension
?
.
shortcuts
)
{
const
{
shortcuts
}
=
policy
.
extension
;
for
(
const
command
of
await
shortcuts
.
allCommands
(
)
)
{
this
.
recordShortcut
(
command
.
shortcut
policy
.
name
command
.
name
)
;
}
}
}
}
recordShortcut
(
shortcutString
addonName
commandName
)
{
if
(
!
shortcutString
)
{
return
;
}
const
valueSet
=
this
.
get
(
shortcutString
)
;
valueSet
.
add
(
{
addonName
commandName
}
)
;
}
removeShortcut
(
shortcutString
addonName
commandName
)
{
if
(
!
this
.
has
(
shortcutString
)
)
{
return
;
}
const
valueSet
=
this
.
get
(
shortcutString
)
;
for
(
const
entry
of
valueSet
.
values
(
)
)
{
if
(
entry
.
addonName
=
=
=
addonName
&
&
entry
.
commandName
=
=
=
commandName
)
{
valueSet
.
delete
(
entry
)
;
}
}
if
(
valueSet
.
size
=
=
=
0
)
{
this
.
delete
(
shortcutString
)
;
}
}
getFirstAddonName
(
shortcutString
)
{
if
(
this
.
has
(
shortcutString
)
)
{
return
this
.
get
(
shortcutString
)
.
values
(
)
.
next
(
)
.
value
.
addonName
;
}
return
null
;
}
has
(
shortcutString
)
{
const
platformShortcut
=
this
.
getPlatformShortcutString
(
shortcutString
)
;
return
super
.
has
(
platformShortcut
)
&
&
super
.
get
(
platformShortcut
)
.
size
>
0
;
}
constructor
(
)
{
super
(
)
;
this
.
_os
=
ExtensionParent
.
PlatformInfo
.
os
;
}
defaultConstructor
(
)
{
return
new
Set
(
)
;
}
getPlatformShortcutString
(
shortcutString
)
{
if
(
this
.
_os
=
=
"
mac
"
)
{
shortcutString
=
shortcutString
.
split
(
"
+
"
)
.
map
(
p
=
>
(
p
=
=
=
"
Ctrl
"
?
"
Command
"
:
p
)
)
.
join
(
"
+
"
)
;
}
return
shortcutString
;
}
get
(
shortcutString
)
{
const
platformShortcut
=
this
.
getPlatformShortcutString
(
shortcutString
)
;
return
super
.
get
(
platformShortcut
)
;
}
add
(
shortcutString
addonCommandValue
)
{
const
setValue
=
this
.
get
(
shortcutString
)
;
setValue
.
add
(
addonCommandValue
)
;
}
delete
(
shortcutString
)
{
const
platformShortcut
=
this
.
getPlatformShortcutString
(
shortcutString
)
;
super
.
delete
(
platformShortcut
)
;
}
}
class
ExtensionShortcuts
{
static
async
removeCommandsFromStorage
(
extensionId
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
ExtensionSettingsStore
.
getAllForExtension
(
extensionId
"
commands
"
)
.
forEach
(
key
=
>
{
ExtensionSettingsStore
.
removeSetting
(
extensionId
"
commands
"
key
)
;
}
)
;
}
constructor
(
{
extension
onCommand
}
)
{
this
.
keysetsMap
=
new
WeakMap
(
)
;
this
.
windowOpenListener
=
null
;
this
.
extension
=
extension
;
this
.
onCommand
=
onCommand
;
this
.
id
=
makeWidgetId
(
extension
.
id
)
;
}
async
allCommands
(
)
{
let
commands
=
await
this
.
commands
;
return
Array
.
from
(
commands
(
[
name
command
]
)
=
>
{
return
{
name
description
:
command
.
description
shortcut
:
command
.
shortcut
}
;
}
)
;
}
async
updateCommand
(
{
name
description
shortcut
}
)
{
let
{
extension
}
=
this
;
let
commands
=
await
this
.
commands
;
let
command
=
commands
.
get
(
name
)
;
if
(
!
command
)
{
throw
new
ExtensionError
(
Unknown
command
"
{
name
}
"
)
;
}
let
previousUpdates
=
await
ExtensionSettingsStore
.
getSetting
(
"
commands
"
name
extension
.
id
)
;
let
commandUpdates
=
(
previousUpdates
&
&
previousUpdates
.
value
)
|
|
{
}
;
if
(
description
&
&
description
!
=
command
.
description
)
{
commandUpdates
.
description
=
description
;
command
.
description
=
description
;
}
if
(
shortcut
!
=
null
&
&
shortcut
!
=
command
.
shortcut
)
{
shortcut
=
normalizeShortcut
(
shortcut
)
;
commandUpdates
.
shortcut
=
shortcut
;
command
.
shortcut
=
shortcut
;
}
await
ExtensionSettingsStore
.
addSetting
(
extension
.
id
"
commands
"
name
commandUpdates
)
;
this
.
registerKeys
(
commands
)
;
}
async
resetCommand
(
name
)
{
let
{
extension
manifestCommands
}
=
this
;
let
commands
=
await
this
.
commands
;
let
command
=
commands
.
get
(
name
)
;
if
(
!
command
)
{
throw
new
ExtensionError
(
Unknown
command
"
{
name
}
"
)
;
}
let
storedCommand
=
ExtensionSettingsStore
.
getSetting
(
"
commands
"
name
extension
.
id
)
;
if
(
storedCommand
&
&
storedCommand
.
value
)
{
commands
.
set
(
name
{
.
.
.
manifestCommands
.
get
(
name
)
}
)
;
ExtensionSettingsStore
.
removeSetting
(
extension
.
id
"
commands
"
name
)
;
this
.
registerKeys
(
commands
)
;
}
}
loadCommands
(
)
{
let
{
extension
}
=
this
;
this
.
manifestCommands
=
this
.
loadCommandsFromManifest
(
extension
.
manifest
)
;
this
.
commands
=
(
async
(
)
=
>
{
let
commands
=
new
Map
(
)
;
this
.
manifestCommands
.
forEach
(
(
command
name
)
=
>
{
commands
.
set
(
name
{
.
.
.
command
}
)
;
}
)
;
let
savedCommands
=
await
this
.
loadCommandsFromStorage
(
extension
.
id
)
;
savedCommands
.
forEach
(
(
update
name
)
=
>
{
let
command
=
commands
.
get
(
name
)
;
if
(
command
)
{
Object
.
assign
(
command
update
)
;
}
}
)
;
return
commands
;
}
)
(
)
;
}
registerKeys
(
commands
)
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
this
.
registerKeysToDocument
(
window
commands
)
;
}
}
async
register
(
)
{
let
commands
=
await
this
.
commands
;
this
.
registerKeys
(
commands
)
;
this
.
windowOpenListener
=
window
=
>
{
if
(
!
this
.
keysetsMap
.
has
(
window
)
)
{
this
.
registerKeysToDocument
(
window
commands
)
;
}
}
;
windowTracker
.
addOpenListener
(
this
.
windowOpenListener
)
;
}
unregister
(
)
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
if
(
this
.
keysetsMap
.
has
(
window
)
)
{
this
.
keysetsMap
.
get
(
window
)
.
remove
(
)
;
}
}
windowTracker
.
removeOpenListener
(
this
.
windowOpenListener
)
;
}
loadCommandsFromManifest
(
manifest
)
{
let
commands
=
new
Map
(
)
;
let
{
PlatformInfo
}
=
ExtensionParent
;
let
os
=
PlatformInfo
.
os
=
=
"
win
"
?
"
windows
"
:
PlatformInfo
.
os
;
for
(
let
[
name
command
]
of
Object
.
entries
(
manifest
.
commands
)
)
{
let
suggested_key
=
command
.
suggested_key
|
|
{
}
;
let
shortcut
=
normalizeShortcut
(
suggested_key
[
os
]
|
|
suggested_key
.
default
)
;
commands
.
set
(
name
{
description
:
command
.
description
shortcut
}
)
;
}
return
commands
;
}
async
loadCommandsFromStorage
(
extensionId
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
names
=
ExtensionSettingsStore
.
getAllForExtension
(
extensionId
"
commands
"
)
;
return
names
.
reduce
(
(
map
name
)
=
>
{
let
command
=
ExtensionSettingsStore
.
getSetting
(
"
commands
"
name
extensionId
)
.
value
;
return
map
.
set
(
name
command
)
;
}
new
Map
(
)
)
;
}
registerKeysToDocument
(
window
commands
)
{
if
(
!
this
.
extension
.
privateBrowsingAllowed
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
return
;
}
let
doc
=
window
.
document
;
let
keyset
=
doc
.
createXULElement
(
"
keyset
"
)
;
keyset
.
id
=
ext
-
keyset
-
id
-
{
this
.
id
}
;
if
(
this
.
keysetsMap
.
has
(
window
)
)
{
this
.
keysetsMap
.
get
(
window
)
.
remove
(
)
;
}
let
sidebarKey
;
commands
.
forEach
(
(
command
name
)
=
>
{
if
(
command
.
shortcut
)
{
let
parts
=
command
.
shortcut
.
split
(
"
+
"
)
;
let
key
=
parts
.
pop
(
)
;
if
(
/
^
[
0
-
9
]
/
.
test
(
key
)
)
{
let
shortcutWithNumpad
=
command
.
shortcut
.
replace
(
/
[
0
-
9
]
/
"
Numpad
&
"
)
;
let
numpadKeyElement
=
this
.
buildKey
(
doc
name
shortcutWithNumpad
)
;
keyset
.
appendChild
(
numpadKeyElement
)
;
}
let
keyElement
=
this
.
buildKey
(
doc
name
command
.
shortcut
)
;
keyset
.
appendChild
(
keyElement
)
;
if
(
name
=
=
EXECUTE_SIDEBAR_ACTION
)
{
sidebarKey
=
keyElement
;
}
}
}
)
;
doc
.
documentElement
.
appendChild
(
keyset
)
;
if
(
sidebarKey
)
{
window
.
SidebarUI
.
updateShortcut
(
{
key
:
sidebarKey
}
)
;
}
this
.
keysetsMap
.
set
(
window
keyset
)
;
}
buildKey
(
doc
name
shortcut
)
{
let
keyElement
=
this
.
buildKeyFromShortcut
(
doc
name
shortcut
)
;
keyElement
.
setAttribute
(
"
oncommand
"
"
/
/
"
)
;
keyElement
.
addEventListener
(
"
command
"
event
=
>
{
let
action
;
let
_execute_action
=
this
.
extension
.
manifestVersion
<
3
?
"
_execute_browser_action
"
:
"
_execute_action
"
;
let
actionFor
=
{
[
_execute_action
]
:
browserActionFor
_execute_page_action
:
pageActionFor
_execute_sidebar_action
:
sidebarActionFor
}
[
name
]
;
if
(
actionFor
)
{
action
=
actionFor
(
this
.
extension
)
;
let
win
=
event
.
target
.
ownerGlobal
;
action
.
triggerAction
(
win
)
;
}
else
{
this
.
extension
.
tabManager
.
addActiveTabPermission
(
)
;
this
.
onCommand
(
name
)
;
}
}
)
;
return
keyElement
;
}
buildKeyFromShortcut
(
doc
name
shortcut
)
{
let
keyElement
=
doc
.
createXULElement
(
"
key
"
)
;
let
parts
=
shortcut
.
split
(
"
+
"
)
;
let
chromeKey
=
parts
.
pop
(
)
;
keyElement
.
setAttribute
(
"
modifiers
"
ShortcutUtils
.
getModifiersAttribute
(
parts
)
)
;
if
(
name
=
=
EXECUTE_SIDEBAR_ACTION
&
&
!
chromeKey
.
startsWith
(
"
Numpad
"
)
)
{
let
id
=
ext
-
key
-
id
-
{
this
.
id
}
-
sidebar
-
action
;
keyElement
.
setAttribute
(
"
id
"
id
)
;
}
let
[
attribute
value
]
=
ShortcutUtils
.
getKeyAttribute
(
chromeKey
)
;
keyElement
.
setAttribute
(
attribute
value
)
;
if
(
attribute
=
=
"
keycode
"
)
{
keyElement
.
setAttribute
(
"
event
"
"
keydown
"
)
;
}
return
keyElement
;
}
}
