"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionStorageSync
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
const
global
=
this
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
KINTO_PROD_SERVER_URL
=
"
https
:
/
/
webextensions
.
settings
.
services
.
mozilla
.
com
/
v1
"
;
const
KINTO_DEV_SERVER_URL
=
"
https
:
/
/
webextensions
.
dev
.
mozaws
.
net
/
v1
"
;
const
KINTO_DEFAULT_SERVER_URL
=
AppConstants
.
RELEASE_OR_BETA
?
KINTO_PROD_SERVER_URL
:
KINTO_DEV_SERVER_URL
;
const
STORAGE_SYNC_ENABLED_PREF
=
"
webextensions
.
storage
.
sync
.
enabled
"
;
const
STORAGE_SYNC_SERVER_URL_PREF
=
"
webextensions
.
storage
.
sync
.
serverURL
"
;
const
STORAGE_SYNC_SCOPE
=
"
sync
:
addon_storage
"
;
const
STORAGE_SYNC_CRYPTO_COLLECTION_NAME
=
"
storage
-
sync
-
crypto
"
;
const
STORAGE_SYNC_CRYPTO_KEYRING_RECORD_ID
=
"
keys
"
;
const
FXA_OAUTH_OPTIONS
=
{
scope
:
STORAGE_SYNC_SCOPE
}
;
const
KINTO_REQUEST_TIMEOUT
=
30000
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
runSafeSyncWithoutClone
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AsyncShutdown
"
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CollectionKeyManager
"
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CommonUtils
"
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CryptoUtils
"
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
EncryptionRemoteTransformer
"
"
resource
:
/
/
services
-
sync
/
engines
/
extension
-
storage
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionStorage
"
"
resource
:
/
/
gre
/
modules
/
ExtensionStorage
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
KintoHttpClient
"
"
resource
:
/
/
services
-
common
/
kinto
-
http
-
client
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Kinto
"
"
resource
:
/
/
services
-
common
/
kinto
-
offline
-
client
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FirefoxAdapter
"
"
resource
:
/
/
services
-
common
/
kinto
-
storage
-
adapter
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Observers
"
"
resource
:
/
/
services
-
common
/
observers
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Sqlite
"
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
KeyRingEncryptionRemoteTransformer
"
"
resource
:
/
/
services
-
sync
/
engines
/
extension
-
storage
.
js
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
prefPermitsStorageSync
"
STORAGE_SYNC_ENABLED_PREF
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
prefStorageSyncServerURL
"
STORAGE_SYNC_SERVER_URL_PREF
KINTO_DEFAULT_SERVER_URL
)
;
const
extensionContexts
=
new
Map
(
)
;
const
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
Engine
.
Extension
-
Storage
"
)
;
const
storageSyncInit
=
Task
.
spawn
(
function
*
(
)
{
const
path
=
"
storage
-
sync
.
sqlite
"
;
const
opts
=
{
path
sharedMemoryCache
:
false
}
;
const
connection
=
yield
Sqlite
.
openConnection
(
opts
)
;
yield
FirefoxAdapter
.
_init
(
connection
)
;
return
{
connection
kinto
:
new
Kinto
(
{
adapter
:
FirefoxAdapter
adapterOptions
:
{
sqliteHandle
:
connection
}
timeout
:
KINTO_REQUEST_TIMEOUT
}
)
}
;
}
)
;
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
ExtensionStorageSync
:
close
Sqlite
handle
"
Task
.
async
(
function
*
(
)
{
const
ret
=
yield
storageSyncInit
;
const
{
connection
}
=
ret
;
yield
connection
.
close
(
)
;
}
)
)
;
function
keyToId
(
key
)
{
function
escapeChar
(
match
)
{
return
"
_
"
+
match
.
codePointAt
(
0
)
.
toString
(
16
)
.
toUpperCase
(
)
+
"
_
"
;
}
return
"
key
-
"
+
key
.
replace
(
/
[
^
a
-
zA
-
Z0
-
9
]
/
g
escapeChar
)
;
}
function
idToKey
(
id
)
{
function
unescapeNumber
(
match
group1
)
{
return
String
.
fromCodePoint
(
parseInt
(
group1
16
)
)
;
}
const
ESCAPED_ID_FORMAT
=
/
^
(
?
:
[
a
-
zA
-
Z0
-
9
]
|
_
[
0
-
9A
-
F
]
+
_
)
*
/
;
if
(
!
id
.
startsWith
(
"
key
-
"
)
)
{
return
null
;
}
const
unprefixed
=
id
.
slice
(
4
)
;
if
(
!
ESCAPED_ID_FORMAT
.
test
(
unprefixed
)
)
{
return
null
;
}
return
unprefixed
.
replace
(
/
_
(
[
0
-
9A
-
F
]
+
)
_
/
g
unescapeNumber
)
;
}
const
storageSyncIdSchema
=
{
generate
(
)
{
throw
new
Error
(
"
cannot
generate
IDs
"
)
;
}
validate
(
id
)
{
return
idToKey
(
id
)
!
=
=
null
;
}
}
;
const
cryptoCollectionIdSchema
=
{
generate
(
)
{
throw
new
Error
(
"
cannot
generate
IDs
for
system
collection
"
)
;
}
validate
(
id
)
{
return
true
;
}
}
;
let
cryptoCollection
CollectionKeyEncryptionRemoteTransformer
;
if
(
AppConstants
.
platform
!
=
"
android
"
)
{
cryptoCollection
=
this
.
cryptoCollection
=
{
getCollection
:
Task
.
async
(
function
*
(
)
{
const
{
kinto
}
=
yield
storageSyncInit
;
return
kinto
.
collection
(
STORAGE_SYNC_CRYPTO_COLLECTION_NAME
{
idSchema
:
cryptoCollectionIdSchema
remoteTransformers
:
[
new
KeyRingEncryptionRemoteTransformer
(
)
]
}
)
;
}
)
getKeyRingRecord
:
Task
.
async
(
function
*
(
)
{
const
collection
=
yield
this
.
getCollection
(
)
;
const
cryptoKeyRecord
=
yield
collection
.
getAny
(
STORAGE_SYNC_CRYPTO_KEYRING_RECORD_ID
)
;
let
data
=
cryptoKeyRecord
.
data
;
if
(
!
data
)
{
const
uuidgen
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
const
uuid
=
uuidgen
.
generateUUID
(
)
;
data
=
{
uuid
}
;
}
return
data
;
}
)
getKeyRing
:
Task
.
async
(
function
*
(
)
{
const
cryptoKeyRecord
=
yield
this
.
getKeyRingRecord
(
)
;
const
collectionKeys
=
new
CollectionKeyManager
(
)
;
if
(
cryptoKeyRecord
.
keys
)
{
collectionKeys
.
setContents
(
cryptoKeyRecord
.
keys
cryptoKeyRecord
.
last_modified
)
;
}
else
{
collectionKeys
.
generateDefaultKey
(
)
;
}
collectionKeys
.
uuid
=
cryptoKeyRecord
.
uuid
;
return
collectionKeys
;
}
)
updateKBHash
:
Task
.
async
(
function
*
(
kbHash
)
{
const
coll
=
yield
this
.
getCollection
(
)
;
yield
coll
.
update
(
{
id
:
STORAGE_SYNC_CRYPTO_KEYRING_RECORD_ID
kbHash
:
kbHash
}
{
patch
:
true
}
)
;
}
)
upsert
:
Task
.
async
(
function
*
(
record
)
{
const
collection
=
yield
this
.
getCollection
(
)
;
yield
collection
.
upsert
(
record
)
;
}
)
sync
:
Task
.
async
(
function
*
(
)
{
const
collection
=
yield
this
.
getCollection
(
)
;
return
yield
ExtensionStorageSync
.
_syncCollection
(
collection
{
strategy
:
"
server_wins
"
}
)
;
}
)
resetSyncStatus
:
Task
.
async
(
function
*
(
)
{
const
coll
=
yield
this
.
getCollection
(
)
;
yield
coll
.
db
.
resetSyncStatus
(
)
;
}
)
_clear
:
Task
.
async
(
function
*
(
)
{
const
collection
=
yield
this
.
getCollection
(
)
;
yield
collection
.
clear
(
)
;
}
)
}
;
CollectionKeyEncryptionRemoteTransformer
=
class
extends
EncryptionRemoteTransformer
{
constructor
(
extensionId
)
{
super
(
)
;
this
.
extensionId
=
extensionId
;
}
getKeys
(
)
{
const
self
=
this
;
return
Task
.
spawn
(
function
*
(
)
{
const
collectionKeys
=
yield
cryptoCollection
.
getKeyRing
(
)
;
if
(
!
collectionKeys
.
hasKeysFor
(
[
self
.
extensionId
]
)
)
{
throw
new
Error
(
tried
to
encrypt
records
for
{
this
.
extensionId
}
but
key
is
not
present
)
;
}
return
collectionKeys
.
keyForCollection
(
self
.
extensionId
)
;
}
)
;
}
}
;
global
.
CollectionKeyEncryptionRemoteTransformer
=
CollectionKeyEncryptionRemoteTransformer
;
}
function
cleanUpForContext
(
extension
context
)
{
const
contexts
=
extensionContexts
.
get
(
extension
)
;
if
(
!
contexts
)
{
Cu
.
reportError
(
new
Error
(
Internal
error
:
cannot
find
any
contexts
for
extension
{
extension
.
id
}
)
)
;
}
contexts
.
delete
(
context
)
;
if
(
contexts
.
size
=
=
=
0
)
{
extensionContexts
.
delete
(
extension
)
;
}
}
const
openCollection
=
Task
.
async
(
function
*
(
extension
context
)
{
let
collectionId
=
extension
.
id
;
const
{
kinto
}
=
yield
storageSyncInit
;
const
remoteTransformers
=
[
]
;
if
(
CollectionKeyEncryptionRemoteTransformer
)
{
remoteTransformers
.
push
(
new
CollectionKeyEncryptionRemoteTransformer
(
extension
.
id
)
)
;
}
const
coll
=
kinto
.
collection
(
collectionId
{
idSchema
:
storageSyncIdSchema
remoteTransformers
}
)
;
return
coll
;
}
)
;
function
extensionIdToCollectionId
(
user
extensionId
)
{
const
userFingerprint
=
CryptoUtils
.
hkdf
(
user
.
uid
undefined
"
identity
.
mozilla
.
com
/
picl
/
v1
/
chrome
.
storage
.
sync
.
collectionIds
"
2
*
32
)
;
let
data
=
new
TextEncoder
(
)
.
encode
(
userFingerprint
+
extensionId
)
;
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA256
)
;
hasher
.
update
(
data
data
.
length
)
;
return
CommonUtils
.
bytesAsHex
(
hasher
.
finish
(
false
)
)
;
}
function
ensureCryptoCollection
(
)
{
if
(
!
cryptoCollection
)
{
throw
new
Error
(
"
Call
to
ensureKeysFor
but
no
sync
code
;
are
you
on
Android
?
"
)
;
}
}
let
_fxaService
=
null
;
if
(
AppConstants
.
platform
!
=
"
android
"
)
{
_fxaService
=
fxAccounts
;
}
this
.
ExtensionStorageSync
=
{
_fxaService
listeners
:
new
WeakMap
(
)
syncAll
:
Task
.
async
(
function
*
(
)
{
const
extensions
=
extensionContexts
.
keys
(
)
;
const
extIds
=
Array
.
from
(
extensions
extension
=
>
extension
.
id
)
;
log
.
debug
(
Syncing
extension
settings
for
{
JSON
.
stringify
(
extIds
)
}
)
;
if
(
extIds
.
length
=
=
0
)
{
return
;
}
yield
this
.
ensureKeysFor
(
extIds
)
;
yield
this
.
checkSyncKeyRing
(
)
;
const
promises
=
Array
.
from
(
extensionContexts
.
keys
(
)
extension
=
>
{
return
openCollection
(
extension
)
.
then
(
coll
=
>
{
return
this
.
sync
(
extension
coll
)
;
}
)
;
}
)
;
yield
Promise
.
all
(
promises
)
;
}
)
sync
:
Task
.
async
(
function
*
(
extension
collection
)
{
const
signedInUser
=
yield
this
.
_fxaService
.
getSignedInUser
(
)
;
if
(
!
signedInUser
)
{
log
.
info
(
"
User
was
not
signed
into
FxA
;
cannot
sync
"
)
;
throw
new
Error
(
"
Not
signed
in
to
FxA
"
)
;
}
const
collectionId
=
extensionIdToCollectionId
(
signedInUser
extension
.
id
)
;
let
syncResults
;
try
{
syncResults
=
yield
this
.
_syncCollection
(
collection
{
strategy
:
"
client_wins
"
collection
:
collectionId
}
)
;
}
catch
(
err
)
{
log
.
warn
(
"
Syncing
failed
"
err
)
;
throw
err
;
}
let
changes
=
{
}
;
for
(
const
record
of
syncResults
.
created
)
{
changes
[
record
.
key
]
=
{
newValue
:
record
.
data
}
;
}
for
(
const
record
of
syncResults
.
updated
)
{
const
key
=
record
.
old
.
key
;
changes
[
key
]
=
{
oldValue
:
record
.
old
.
data
newValue
:
record
.
new
.
data
}
;
}
for
(
const
record
of
syncResults
.
deleted
)
{
changes
[
record
.
key
]
=
{
oldValue
:
record
.
data
}
;
}
for
(
const
conflict
of
syncResults
.
resolved
)
{
changes
[
conflict
.
remote
.
key
]
=
{
oldValue
:
conflict
.
local
.
data
newValue
:
conflict
.
remote
.
data
}
;
}
if
(
Object
.
keys
(
changes
)
.
length
>
0
)
{
this
.
notifyListeners
(
extension
changes
)
;
}
}
)
_syncCollection
:
Task
.
async
(
function
*
(
collection
options
)
{
return
yield
this
.
_requestWithToken
(
Syncing
{
collection
.
name
}
function
*
(
token
)
{
const
allOptions
=
Object
.
assign
(
{
}
{
remote
:
prefStorageSyncServerURL
headers
:
{
Authorization
:
"
Bearer
"
+
token
}
}
options
)
;
return
yield
collection
.
sync
(
allOptions
)
;
}
)
;
}
)
_requestWithToken
:
Task
.
async
(
function
*
(
description
f
)
{
const
fxaToken
=
yield
this
.
_fxaService
.
getOAuthToken
(
FXA_OAUTH_OPTIONS
)
;
try
{
return
yield
f
(
fxaToken
)
;
}
catch
(
e
)
{
log
.
error
(
{
description
}
:
request
failed
e
)
;
if
(
e
&
&
e
.
data
&
&
e
.
data
.
code
=
=
401
)
{
log
.
info
(
"
Token
might
have
expired
"
)
;
yield
this
.
_fxaService
.
removeCachedOAuthToken
(
{
token
:
fxaToken
}
)
;
const
newToken
=
yield
this
.
_fxaService
.
getOAuthToken
(
FXA_OAUTH_OPTIONS
)
;
return
yield
f
(
newToken
)
;
}
throw
e
;
}
}
)
_deleteBucket
:
Task
.
async
(
function
*
(
)
{
return
yield
this
.
_requestWithToken
(
"
Clearing
server
"
function
*
(
token
)
{
const
headers
=
{
Authorization
:
"
Bearer
"
+
token
}
;
const
kintoHttp
=
new
KintoHttpClient
(
prefStorageSyncServerURL
{
headers
:
headers
timeout
:
KINTO_REQUEST_TIMEOUT
}
)
;
return
yield
kintoHttp
.
deleteBucket
(
"
default
"
)
;
}
)
;
}
)
ensureKeysFor
:
Task
.
async
(
function
*
(
extIds
)
{
ensureCryptoCollection
(
)
;
const
collectionKeys
=
yield
cryptoCollection
.
getKeyRing
(
)
;
if
(
collectionKeys
.
hasKeysFor
(
extIds
)
)
{
return
collectionKeys
;
}
const
kbHash
=
yield
this
.
getKBHash
(
)
;
const
newKeys
=
yield
collectionKeys
.
ensureKeysFor
(
extIds
)
;
const
newRecord
=
{
id
:
STORAGE_SYNC_CRYPTO_KEYRING_RECORD_ID
keys
:
newKeys
.
asWBO
(
)
.
cleartext
uuid
:
collectionKeys
.
uuid
kbHash
:
kbHash
}
;
yield
cryptoCollection
.
upsert
(
newRecord
)
;
const
result
=
yield
this
.
_syncKeyRing
(
newRecord
)
;
if
(
result
.
resolved
.
length
!
=
0
)
{
return
yield
this
.
ensureKeysFor
(
extIds
)
;
}
return
newKeys
;
}
)
getKBHash
:
Task
.
async
(
function
*
(
)
{
const
signedInUser
=
yield
this
.
_fxaService
.
getSignedInUser
(
)
;
if
(
!
signedInUser
)
{
throw
new
Error
(
"
User
isn
'
t
signed
in
!
"
)
;
}
if
(
!
signedInUser
.
kB
)
{
throw
new
Error
(
"
User
doesn
'
t
have
kB
?
?
"
)
;
}
let
kBbytes
=
CommonUtils
.
hexToBytes
(
signedInUser
.
kB
)
;
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA256
)
;
return
CommonUtils
.
bytesAsHex
(
CryptoUtils
.
digestBytes
(
signedInUser
.
uid
+
kBbytes
hasher
)
)
;
}
)
updateKeyRingKB
:
Task
.
async
(
function
*
(
)
{
ensureCryptoCollection
(
)
;
const
signedInUser
=
yield
this
.
_fxaService
.
getSignedInUser
(
)
;
if
(
!
signedInUser
)
{
return
;
}
const
thisKBHash
=
yield
this
.
getKBHash
(
)
;
yield
cryptoCollection
.
updateKBHash
(
thisKBHash
)
;
}
)
checkSyncKeyRing
:
Task
.
async
(
function
*
(
)
{
ensureCryptoCollection
(
)
;
yield
this
.
updateKeyRingKB
(
)
;
const
cryptoKeyRecord
=
yield
cryptoCollection
.
getKeyRingRecord
(
)
;
if
(
cryptoKeyRecord
&
&
cryptoKeyRecord
.
_status
!
=
=
"
synced
"
)
{
yield
this
.
_syncKeyRing
(
cryptoKeyRecord
)
;
}
}
)
_syncKeyRing
:
Task
.
async
(
function
*
(
cryptoKeyRecord
)
{
ensureCryptoCollection
(
)
;
try
{
const
result
=
yield
cryptoCollection
.
sync
(
)
;
if
(
result
.
resolved
.
length
>
0
)
{
if
(
result
.
resolved
[
0
]
.
uuid
!
=
cryptoKeyRecord
.
uuid
)
{
log
.
info
(
"
Detected
a
new
UUID
.
Reseting
sync
status
for
everything
.
"
)
;
yield
cryptoCollection
.
resetSyncStatus
(
)
;
return
result
;
}
}
return
result
;
}
catch
(
e
)
{
if
(
KeyRingEncryptionRemoteTransformer
.
isOutdatedKB
(
e
)
)
{
const
isSessionValid
=
yield
this
.
_fxaService
.
sessionStatus
(
)
;
if
(
isSessionValid
)
{
yield
this
.
_deleteBucket
(
)
;
yield
cryptoCollection
.
resetSyncStatus
(
)
;
return
yield
cryptoCollection
.
sync
(
)
;
}
}
throw
e
;
}
}
)
getCollection
(
extension
context
)
{
if
(
prefPermitsStorageSync
!
=
=
true
)
{
return
Promise
.
reject
(
{
message
:
Please
set
{
STORAGE_SYNC_ENABLED_PREF
}
to
true
in
about
:
config
}
)
;
}
if
(
!
extensionContexts
.
has
(
extension
)
)
{
extensionContexts
.
set
(
extension
new
Set
(
)
)
;
}
const
contexts
=
extensionContexts
.
get
(
extension
)
;
if
(
!
contexts
.
has
(
context
)
)
{
contexts
.
add
(
context
)
;
context
.
callOnClose
(
{
close
:
(
)
=
>
cleanUpForContext
(
extension
context
)
}
)
;
}
return
openCollection
(
extension
context
)
;
}
set
:
Task
.
async
(
function
*
(
extension
items
context
)
{
const
coll
=
yield
this
.
getCollection
(
extension
context
)
;
const
keys
=
Object
.
keys
(
items
)
;
const
ids
=
keys
.
map
(
keyToId
)
;
const
changes
=
yield
coll
.
execute
(
txn
=
>
{
let
changes
=
{
}
;
for
(
let
[
i
key
]
of
keys
.
entries
(
)
)
{
const
id
=
ids
[
i
]
;
let
item
=
items
[
key
]
;
let
{
oldRecord
}
=
txn
.
upsert
(
{
id
key
data
:
item
}
)
;
changes
[
key
]
=
{
newValue
:
item
}
;
if
(
oldRecord
&
&
oldRecord
.
data
)
{
changes
[
key
]
.
oldValue
=
oldRecord
.
data
;
}
}
return
changes
;
}
{
preloadIds
:
ids
}
)
;
this
.
notifyListeners
(
extension
changes
)
;
}
)
remove
:
Task
.
async
(
function
*
(
extension
keys
context
)
{
const
coll
=
yield
this
.
getCollection
(
extension
context
)
;
keys
=
[
]
.
concat
(
keys
)
;
const
ids
=
keys
.
map
(
keyToId
)
;
let
changes
=
{
}
;
yield
coll
.
execute
(
txn
=
>
{
for
(
let
[
i
key
]
of
keys
.
entries
(
)
)
{
const
id
=
ids
[
i
]
;
const
res
=
txn
.
deleteAny
(
id
)
;
if
(
res
.
deleted
)
{
changes
[
key
]
=
{
oldValue
:
res
.
data
.
data
}
;
}
}
return
changes
;
}
{
preloadIds
:
ids
}
)
;
if
(
Object
.
keys
(
changes
)
.
length
>
0
)
{
this
.
notifyListeners
(
extension
changes
)
;
}
}
)
clear
:
Task
.
async
(
function
*
(
extension
context
)
{
const
coll
=
yield
this
.
getCollection
(
extension
context
)
;
const
res
=
yield
coll
.
list
(
)
;
const
records
=
res
.
data
;
const
keys
=
records
.
map
(
record
=
>
record
.
key
)
;
yield
this
.
remove
(
extension
keys
context
)
;
}
)
get
:
Task
.
async
(
function
*
(
extension
spec
context
)
{
const
coll
=
yield
this
.
getCollection
(
extension
context
)
;
let
keys
records
;
if
(
spec
=
=
=
null
)
{
records
=
{
}
;
const
res
=
yield
coll
.
list
(
)
;
for
(
let
record
of
res
.
data
)
{
records
[
record
.
key
]
=
record
.
data
;
}
return
records
;
}
if
(
typeof
spec
=
=
=
"
string
"
)
{
keys
=
[
spec
]
;
records
=
{
}
;
}
else
if
(
Array
.
isArray
(
spec
)
)
{
keys
=
spec
;
records
=
{
}
;
}
else
{
keys
=
Object
.
keys
(
spec
)
;
records
=
Cu
.
cloneInto
(
spec
global
)
;
}
for
(
let
key
of
keys
)
{
const
res
=
yield
coll
.
getAny
(
keyToId
(
key
)
)
;
if
(
res
.
data
&
&
res
.
data
.
_status
!
=
"
deleted
"
)
{
records
[
res
.
data
.
key
]
=
res
.
data
.
data
;
}
}
return
records
;
}
)
addOnChangedListener
(
extension
listener
context
)
{
let
listeners
=
this
.
listeners
.
get
(
extension
)
|
|
new
Set
(
)
;
listeners
.
add
(
listener
)
;
this
.
listeners
.
set
(
extension
listeners
)
;
return
this
.
getCollection
(
extension
context
)
;
}
removeOnChangedListener
(
extension
listener
)
{
let
listeners
=
this
.
listeners
.
get
(
extension
)
;
listeners
.
delete
(
listener
)
;
if
(
listeners
.
size
=
=
0
)
{
this
.
listeners
.
delete
(
extension
)
;
}
}
notifyListeners
(
extension
changes
)
{
Observers
.
notify
(
"
ext
.
storage
.
sync
-
changed
"
)
;
let
listeners
=
this
.
listeners
.
get
(
extension
)
|
|
new
Set
(
)
;
if
(
listeners
)
{
for
(
let
listener
of
listeners
)
{
runSafeSyncWithoutClone
(
listener
changes
)
;
}
}
}
}
;
