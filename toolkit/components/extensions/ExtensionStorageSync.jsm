"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionStorageSync
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
const
global
=
this
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
KINTO_PROD_SERVER_URL
=
"
https
:
/
/
webextensions
.
settings
.
services
.
mozilla
.
com
/
v1
"
;
const
KINTO_DEV_SERVER_URL
=
"
https
:
/
/
webextensions
.
dev
.
mozaws
.
net
/
v1
"
;
const
KINTO_DEFAULT_SERVER_URL
=
AppConstants
.
RELEASE_OR_BETA
?
KINTO_PROD_SERVER_URL
:
KINTO_DEV_SERVER_URL
;
const
STORAGE_SYNC_ENABLED_PREF
=
"
webextensions
.
storage
.
sync
.
enabled
"
;
const
STORAGE_SYNC_SERVER_URL_PREF
=
"
webextensions
.
storage
.
sync
.
serverURL
"
;
const
STORAGE_SYNC_SCOPE
=
"
sync
:
addon_storage
"
;
const
STORAGE_SYNC_CRYPTO_COLLECTION_NAME
=
"
storage
-
sync
-
crypto
"
;
const
STORAGE_SYNC_CRYPTO_KEYRING_RECORD_ID
=
"
keys
"
;
const
FXA_OAUTH_OPTIONS
=
{
scope
:
STORAGE_SYNC_SCOPE
}
;
const
KINTO_REQUEST_TIMEOUT
=
30000
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
runSafeSyncWithoutClone
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppsUtils
"
"
resource
:
/
/
gre
/
modules
/
AppsUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CollectionKeyManager
"
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CommonUtils
"
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CryptoUtils
"
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
EncryptionRemoteTransformer
"
"
resource
:
/
/
services
-
sync
/
engines
/
extension
-
storage
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionStorage
"
"
resource
:
/
/
gre
/
modules
/
ExtensionStorage
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
loadKinto
"
"
resource
:
/
/
services
-
common
/
kinto
-
offline
-
client
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Observers
"
"
resource
:
/
/
services
-
common
/
observers
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
KeyRingEncryptionRemoteTransformer
"
"
resource
:
/
/
services
-
sync
/
engines
/
extension
-
storage
.
js
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
prefPermitsStorageSync
"
STORAGE_SYNC_ENABLED_PREF
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
prefStorageSyncServerURL
"
STORAGE_SYNC_SERVER_URL_PREF
KINTO_DEFAULT_SERVER_URL
)
;
const
collectionPromises
=
new
Map
(
)
;
const
extensionContexts
=
new
WeakMap
(
)
;
const
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
Engine
.
Extension
-
Storage
"
)
;
function
keyToId
(
key
)
{
function
escapeChar
(
match
)
{
return
"
_
"
+
match
.
codePointAt
(
0
)
.
toString
(
16
)
.
toUpperCase
(
)
+
"
_
"
;
}
return
"
key
-
"
+
key
.
replace
(
/
[
^
a
-
zA
-
Z0
-
9
]
/
g
escapeChar
)
;
}
function
idToKey
(
id
)
{
function
unescapeNumber
(
match
group1
)
{
return
String
.
fromCodePoint
(
parseInt
(
group1
16
)
)
;
}
const
ESCAPED_ID_FORMAT
=
/
^
(
?
:
[
a
-
zA
-
Z0
-
9
]
|
_
[
0
-
9A
-
F
]
+
_
)
*
/
;
if
(
!
id
.
startsWith
(
"
key
-
"
)
)
{
return
null
;
}
const
unprefixed
=
id
.
slice
(
4
)
;
if
(
!
ESCAPED_ID_FORMAT
.
test
(
unprefixed
)
)
{
return
null
;
}
return
unprefixed
.
replace
(
/
_
(
[
0
-
9A
-
F
]
+
)
_
/
g
unescapeNumber
)
;
}
const
storageSyncIdSchema
=
{
generate
(
)
{
throw
new
Error
(
"
cannot
generate
IDs
"
)
;
}
validate
(
id
)
{
return
idToKey
(
id
)
!
=
=
null
;
}
}
;
function
makeKinto
(
)
{
const
Kinto
=
loadKinto
(
)
;
return
new
Kinto
(
{
adapter
:
Kinto
.
adapters
.
FirefoxAdapter
adapterOptions
:
{
path
:
"
storage
-
sync
.
sqlite
"
}
timeout
:
KINTO_REQUEST_TIMEOUT
}
)
;
}
const
cryptoCollectionIdSchema
=
{
generate
(
)
{
throw
new
Error
(
"
cannot
generate
IDs
for
system
collection
"
)
;
}
validate
(
id
)
{
return
true
;
}
}
;
const
cryptoCollection
=
this
.
cryptoCollection
=
{
refCount
:
0
_kintoCollectionPromise
:
null
incrementUses
:
Task
.
async
(
function
*
(
)
{
const
oldRefCount
=
this
.
refCount
;
this
.
refCount
+
=
1
;
if
(
oldRefCount
=
=
0
)
{
const
db
=
makeKinto
(
)
;
const
kintoCollection
=
db
.
collection
(
STORAGE_SYNC_CRYPTO_COLLECTION_NAME
{
idSchema
:
cryptoCollectionIdSchema
remoteTransformers
:
[
new
KeyRingEncryptionRemoteTransformer
(
)
]
}
)
;
this
.
_kintoCollectionPromise
=
kintoCollection
.
db
.
open
(
)
.
then
(
(
)
=
>
kintoCollection
)
;
}
}
)
decrementUses
:
Task
.
async
(
function
*
(
)
{
if
(
this
.
refCount
=
=
0
)
{
Cu
.
reportError
(
new
Error
(
"
too
many
decrementUses
(
)
of
cryptoCollection
!
"
)
)
;
return
;
}
this
.
refCount
-
=
1
;
if
(
this
.
refCount
=
=
0
)
{
const
oldPromise
=
this
.
_kintoCollectionPromise
;
this
.
_kintoCollectionPromise
=
null
;
const
collection
=
yield
oldPromise
;
yield
collection
.
db
.
close
(
)
;
}
}
)
getKeyRingRecord
:
Task
.
async
(
function
*
(
)
{
const
collection
=
yield
this
.
_kintoCollectionPromise
;
const
cryptoKeyRecord
=
yield
collection
.
getAny
(
STORAGE_SYNC_CRYPTO_KEYRING_RECORD_ID
)
;
return
cryptoKeyRecord
.
data
;
}
)
getKeyRing
:
Task
.
async
(
function
*
(
)
{
const
cryptoKeyRecord
=
yield
this
.
getKeyRingRecord
(
)
;
const
collectionKeys
=
new
CollectionKeyManager
(
)
;
if
(
cryptoKeyRecord
)
{
collectionKeys
.
setContents
(
cryptoKeyRecord
.
keys
cryptoKeyRecord
.
last_modified
)
;
}
else
{
collectionKeys
.
generateDefaultKey
(
)
;
}
return
collectionKeys
;
}
)
upsert
:
Task
.
async
(
function
*
(
record
)
{
const
collection
=
yield
this
.
_kintoCollectionPromise
;
yield
collection
.
upsert
(
record
)
;
}
)
sync
:
Task
.
async
(
function
*
(
)
{
if
(
!
this
.
_kintoCollectionPromise
)
{
throw
new
Error
(
"
tried
to
sync
without
any
live
uses
of
the
Kinto
collection
!
"
)
;
}
const
collection
=
yield
this
.
_kintoCollectionPromise
;
return
yield
ExtensionStorageSync
.
_syncCollection
(
collection
{
strategy
:
"
server_wins
"
}
)
;
}
)
_clear
:
Task
.
async
(
function
*
(
)
{
const
collection
=
yield
this
.
_kintoCollectionPromise
;
yield
collection
.
clear
(
)
;
}
)
}
;
class
CollectionKeyEncryptionRemoteTransformer
extends
EncryptionRemoteTransformer
{
constructor
(
extensionId
)
{
super
(
)
;
this
.
extensionId
=
extensionId
;
}
getKeys
(
)
{
const
self
=
this
;
return
Task
.
spawn
(
function
*
(
)
{
const
collectionKeys
=
yield
cryptoCollection
.
getKeyRing
(
)
;
if
(
!
collectionKeys
.
hasKeysFor
(
[
self
.
extensionId
]
)
)
{
throw
new
Error
(
tried
to
encrypt
records
for
{
this
.
extensionId
}
but
key
is
not
present
)
;
}
return
collectionKeys
.
keyForCollection
(
self
.
extensionId
)
;
}
)
;
}
}
global
.
CollectionKeyEncryptionRemoteTransformer
=
CollectionKeyEncryptionRemoteTransformer
;
const
closeExtensionCollection
=
Task
.
async
(
function
*
(
extension
)
{
const
collectionPromise
=
collectionPromises
.
get
(
extension
)
;
if
(
!
collectionPromise
)
{
Cu
.
reportError
(
new
Error
(
Internal
error
:
trying
to
close
extension
{
extension
.
id
}
+
"
that
doesn
'
t
have
a
collection
"
)
)
;
return
;
}
collectionPromises
.
delete
(
extension
)
;
const
coll
=
yield
collectionPromise
;
yield
coll
.
db
.
close
(
)
;
yield
cryptoCollection
.
decrementUses
(
)
;
}
)
;
function
cleanUpForContext
(
extension
context
)
{
const
contexts
=
extensionContexts
.
get
(
extension
)
;
if
(
!
contexts
)
{
Cu
.
reportError
(
new
Error
(
Internal
error
:
cannot
find
any
contexts
for
extension
{
extension
.
id
}
)
)
;
return
closeExtensionCollection
(
extension
)
;
}
contexts
.
delete
(
context
)
;
if
(
contexts
.
size
=
=
=
0
)
{
extensionContexts
.
delete
(
extension
)
;
return
closeExtensionCollection
(
extension
)
;
}
}
const
openCollection
=
Task
.
async
(
function
*
(
extension
context
)
{
let
collectionId
=
extension
.
id
;
const
db
=
makeKinto
(
)
;
const
coll
=
db
.
collection
(
collectionId
{
idSchema
:
storageSyncIdSchema
remoteTransformers
:
[
new
CollectionKeyEncryptionRemoteTransformer
(
extension
.
id
)
]
}
)
;
yield
coll
.
db
.
open
(
)
;
yield
cryptoCollection
.
incrementUses
(
)
;
return
coll
;
}
)
;
function
extensionIdToCollectionId
(
user
extensionId
)
{
const
userFingerprint
=
CryptoUtils
.
hkdf
(
user
.
uid
undefined
"
identity
.
mozilla
.
com
/
picl
/
v1
/
chrome
.
storage
.
sync
.
collectionIds
"
2
*
32
)
;
let
data
=
new
TextEncoder
(
)
.
encode
(
userFingerprint
+
extensionId
)
;
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA256
)
;
hasher
.
update
(
data
data
.
length
)
;
return
CommonUtils
.
bytesAsHex
(
hasher
.
finish
(
false
)
)
;
}
this
.
ExtensionStorageSync
=
{
_fxaService
:
fxAccounts
listeners
:
new
WeakMap
(
)
syncAll
:
Task
.
async
(
function
*
(
)
{
yield
cryptoCollection
.
incrementUses
(
)
;
try
{
const
extensions
=
collectionPromises
.
keys
(
)
;
const
extIds
=
Array
.
from
(
extensions
extension
=
>
extension
.
id
)
;
log
.
debug
(
Syncing
extension
settings
for
{
JSON
.
stringify
(
extIds
)
}
\
n
)
;
if
(
extIds
.
length
=
=
0
)
{
return
;
}
yield
this
.
ensureKeysFor
(
extIds
)
;
const
promises
=
Array
.
from
(
collectionPromises
.
entries
(
)
(
[
extension
collPromise
]
)
=
>
{
return
collPromise
.
then
(
coll
=
>
{
return
this
.
sync
(
extension
coll
)
;
}
)
;
}
)
;
yield
Promise
.
all
(
promises
)
;
}
finally
{
yield
cryptoCollection
.
decrementUses
(
)
;
}
}
)
sync
:
Task
.
async
(
function
*
(
extension
collection
)
{
const
signedInUser
=
yield
this
.
_fxaService
.
getSignedInUser
(
)
;
if
(
!
signedInUser
)
{
log
.
info
(
"
User
was
not
signed
into
FxA
;
cannot
sync
"
)
;
throw
new
Error
(
"
Not
signed
in
to
FxA
"
)
;
}
const
collectionId
=
extensionIdToCollectionId
(
signedInUser
extension
.
id
)
;
let
syncResults
;
try
{
syncResults
=
yield
this
.
_syncCollection
(
collection
{
strategy
:
"
client_wins
"
collection
:
collectionId
}
)
;
}
catch
(
err
)
{
log
.
warn
(
"
Syncing
failed
"
err
)
;
throw
err
;
}
let
changes
=
{
}
;
for
(
const
record
of
syncResults
.
created
)
{
changes
[
record
.
key
]
=
{
newValue
:
record
.
data
}
;
}
for
(
const
record
of
syncResults
.
updated
)
{
const
key
=
record
.
old
.
key
;
changes
[
key
]
=
{
oldValue
:
record
.
old
.
data
newValue
:
record
.
new
.
data
}
;
}
for
(
const
record
of
syncResults
.
deleted
)
{
changes
[
record
.
key
]
=
{
oldValue
:
record
.
data
}
;
}
for
(
const
conflict
of
syncResults
.
resolved
)
{
changes
[
conflict
.
remote
.
key
]
=
{
oldValue
:
conflict
.
local
.
data
newValue
:
conflict
.
remote
.
data
}
;
}
if
(
Object
.
keys
(
changes
)
.
length
>
0
)
{
this
.
notifyListeners
(
extension
changes
)
;
}
}
)
_syncCollection
:
Task
.
async
(
function
*
(
collection
options
)
{
return
yield
this
.
_requestWithToken
(
Syncing
{
collection
.
name
}
function
*
(
token
)
{
const
allOptions
=
Object
.
assign
(
{
}
{
remote
:
prefStorageSyncServerURL
headers
:
{
Authorization
:
"
Bearer
"
+
token
}
}
options
)
;
return
yield
collection
.
sync
(
allOptions
)
;
}
)
;
}
)
_requestWithToken
:
Task
.
async
(
function
*
(
description
f
)
{
const
fxaToken
=
yield
this
.
_fxaService
.
getOAuthToken
(
FXA_OAUTH_OPTIONS
)
;
try
{
return
yield
f
(
fxaToken
)
;
}
catch
(
e
)
{
log
.
error
(
{
description
}
:
request
failed
e
)
;
if
(
e
&
&
e
.
data
&
&
e
.
data
.
code
=
=
401
)
{
log
.
info
(
"
Token
might
have
expired
"
)
;
yield
this
.
_fxaService
.
removeCachedOAuthToken
(
{
token
:
fxaToken
}
)
;
const
newToken
=
yield
this
.
_fxaService
.
getOAuthToken
(
FXA_OAUTH_OPTIONS
)
;
return
yield
f
(
newToken
)
;
}
throw
e
;
}
}
)
ensureKeysFor
:
Task
.
async
(
function
*
(
extIds
)
{
const
collectionKeys
=
yield
cryptoCollection
.
getKeyRing
(
)
;
if
(
collectionKeys
.
hasKeysFor
(
extIds
)
)
{
return
collectionKeys
;
}
const
newKeys
=
yield
collectionKeys
.
ensureKeysFor
(
extIds
)
;
const
newRecord
=
{
id
:
STORAGE_SYNC_CRYPTO_KEYRING_RECORD_ID
keys
:
newKeys
.
asWBO
(
)
.
cleartext
}
;
yield
cryptoCollection
.
upsert
(
newRecord
)
;
const
result
=
yield
cryptoCollection
.
sync
(
)
;
if
(
result
.
resolved
.
length
!
=
0
)
{
return
yield
this
.
ensureKeysFor
(
extIds
)
;
}
return
newKeys
;
}
)
getCollection
(
extension
context
)
{
if
(
prefPermitsStorageSync
!
=
=
true
)
{
return
Promise
.
reject
(
{
message
:
Please
set
{
STORAGE_SYNC_ENABLED_PREF
}
to
true
in
about
:
config
}
)
;
}
if
(
!
collectionPromises
.
has
(
extension
)
)
{
const
collectionPromise
=
openCollection
(
extension
context
)
;
collectionPromises
.
set
(
extension
collectionPromise
)
;
collectionPromise
.
catch
(
Cu
.
reportError
)
;
}
if
(
!
extensionContexts
.
has
(
extension
)
)
{
extensionContexts
.
set
(
extension
new
Set
(
)
)
;
}
const
contexts
=
extensionContexts
.
get
(
extension
)
;
if
(
!
contexts
.
has
(
context
)
)
{
contexts
.
add
(
context
)
;
context
.
callOnClose
(
{
close
:
(
)
=
>
cleanUpForContext
(
extension
context
)
}
)
;
}
return
collectionPromises
.
get
(
extension
)
;
}
set
:
Task
.
async
(
function
*
(
extension
items
context
)
{
const
coll
=
yield
this
.
getCollection
(
extension
context
)
;
const
keys
=
Object
.
keys
(
items
)
;
const
ids
=
keys
.
map
(
keyToId
)
;
const
changes
=
yield
coll
.
execute
(
txn
=
>
{
let
changes
=
{
}
;
for
(
let
[
i
key
]
of
keys
.
entries
(
)
)
{
const
id
=
ids
[
i
]
;
let
item
=
items
[
key
]
;
let
{
oldRecord
}
=
txn
.
upsert
(
{
id
key
data
:
item
}
)
;
changes
[
key
]
=
{
newValue
:
item
}
;
if
(
oldRecord
&
&
oldRecord
.
data
)
{
changes
[
key
]
.
oldValue
=
oldRecord
.
data
;
}
}
return
changes
;
}
{
preloadIds
:
ids
}
)
;
this
.
notifyListeners
(
extension
changes
)
;
}
)
remove
:
Task
.
async
(
function
*
(
extension
keys
context
)
{
const
coll
=
yield
this
.
getCollection
(
extension
context
)
;
keys
=
[
]
.
concat
(
keys
)
;
const
ids
=
keys
.
map
(
keyToId
)
;
let
changes
=
{
}
;
yield
coll
.
execute
(
txn
=
>
{
for
(
let
[
i
key
]
of
keys
.
entries
(
)
)
{
const
id
=
ids
[
i
]
;
const
res
=
txn
.
deleteAny
(
id
)
;
if
(
res
.
deleted
)
{
changes
[
key
]
=
{
oldValue
:
res
.
data
.
data
}
;
}
}
return
changes
;
}
{
preloadIds
:
ids
}
)
;
if
(
Object
.
keys
(
changes
)
.
length
>
0
)
{
this
.
notifyListeners
(
extension
changes
)
;
}
}
)
clear
:
Task
.
async
(
function
*
(
extension
context
)
{
const
coll
=
yield
this
.
getCollection
(
extension
context
)
;
const
res
=
yield
coll
.
list
(
)
;
const
records
=
res
.
data
;
const
keys
=
records
.
map
(
record
=
>
record
.
key
)
;
yield
this
.
remove
(
extension
keys
context
)
;
}
)
get
:
Task
.
async
(
function
*
(
extension
spec
context
)
{
const
coll
=
yield
this
.
getCollection
(
extension
context
)
;
let
keys
records
;
if
(
spec
=
=
=
null
)
{
records
=
{
}
;
const
res
=
yield
coll
.
list
(
)
;
for
(
let
record
of
res
.
data
)
{
records
[
record
.
key
]
=
record
.
data
;
}
return
records
;
}
if
(
typeof
spec
=
=
=
"
string
"
)
{
keys
=
[
spec
]
;
records
=
{
}
;
}
else
if
(
Array
.
isArray
(
spec
)
)
{
keys
=
spec
;
records
=
{
}
;
}
else
{
keys
=
Object
.
keys
(
spec
)
;
records
=
Cu
.
cloneInto
(
spec
global
)
;
}
for
(
let
key
of
keys
)
{
const
res
=
yield
coll
.
getAny
(
keyToId
(
key
)
)
;
if
(
res
.
data
&
&
res
.
data
.
_status
!
=
"
deleted
"
)
{
records
[
res
.
data
.
key
]
=
res
.
data
.
data
;
}
}
return
records
;
}
)
addOnChangedListener
(
extension
listener
context
)
{
let
listeners
=
this
.
listeners
.
get
(
extension
)
|
|
new
Set
(
)
;
listeners
.
add
(
listener
)
;
this
.
listeners
.
set
(
extension
listeners
)
;
return
this
.
getCollection
(
extension
context
)
;
}
removeOnChangedListener
(
extension
listener
)
{
let
listeners
=
this
.
listeners
.
get
(
extension
)
;
listeners
.
delete
(
listener
)
;
if
(
listeners
.
size
=
=
0
)
{
this
.
listeners
.
delete
(
extension
)
;
}
}
notifyListeners
(
extension
changes
)
{
Observers
.
notify
(
"
ext
.
storage
.
sync
-
changed
"
)
;
let
listeners
=
this
.
listeners
.
get
(
extension
)
|
|
new
Set
(
)
;
if
(
listeners
)
{
for
(
let
listener
of
listeners
)
{
runSafeSyncWithoutClone
(
listener
changes
)
;
}
}
}
}
;
