"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExtensionStorageSync
"
"
extensionStorageSync
"
]
;
const
global
=
this
;
Cu
.
importGlobalProperties
(
[
"
atob
"
"
btoa
"
]
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
KINTO_PROD_SERVER_URL
=
"
https
:
/
/
webextensions
.
settings
.
services
.
mozilla
.
com
/
v1
"
;
const
KINTO_DEFAULT_SERVER_URL
=
KINTO_PROD_SERVER_URL
;
const
STORAGE_SYNC_ENABLED_PREF
=
"
webextensions
.
storage
.
sync
.
enabled
"
;
const
STORAGE_SYNC_SERVER_URL_PREF
=
"
webextensions
.
storage
.
sync
.
serverURL
"
;
const
STORAGE_SYNC_SCOPE
=
"
sync
:
addon_storage
"
;
const
STORAGE_SYNC_CRYPTO_COLLECTION_NAME
=
"
storage
-
sync
-
crypto
"
;
const
STORAGE_SYNC_CRYPTO_KEYRING_RECORD_ID
=
"
keys
"
;
const
STORAGE_SYNC_CRYPTO_SALT_LENGTH_BYTES
=
32
;
const
FXA_OAUTH_OPTIONS
=
{
scope
:
STORAGE_SYNC_SCOPE
}
;
const
HISTOGRAM_GET_OPS_SIZE
=
"
STORAGE_SYNC_GET_OPS_SIZE
"
;
const
HISTOGRAM_SET_OPS_SIZE
=
"
STORAGE_SYNC_SET_OPS_SIZE
"
;
const
HISTOGRAM_REMOVE_OPS
=
"
STORAGE_SYNC_REMOVE_OPS
"
;
const
SCALAR_EXTENSIONS_USING
=
"
storage
.
sync
.
api
.
usage
.
extensions_using
"
;
const
SCALAR_ITEMS_STORED
=
"
storage
.
sync
.
api
.
usage
.
items_stored
"
;
const
SCALAR_STORAGE_CONSUMED
=
"
storage
.
sync
.
api
.
usage
.
storage_consumed
"
;
const
KINTO_REQUEST_TIMEOUT
=
30000
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
BulkKeyBundle
:
"
resource
:
/
/
services
-
sync
/
keys
.
js
"
CollectionKeyManager
:
"
resource
:
/
/
services
-
sync
/
record
.
js
"
CommonUtils
:
"
resource
:
/
/
services
-
common
/
utils
.
js
"
CryptoUtils
:
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
ExtensionCommon
:
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
fxAccounts
:
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
KintoHttpClient
:
"
resource
:
/
/
services
-
common
/
kinto
-
http
-
client
.
js
"
Kinto
:
"
resource
:
/
/
services
-
common
/
kinto
-
offline
-
client
.
js
"
FirefoxAdapter
:
"
resource
:
/
/
services
-
common
/
kinto
-
storage
-
adapter
.
js
"
Observers
:
"
resource
:
/
/
services
-
common
/
observers
.
js
"
Utils
:
"
resource
:
/
/
services
-
sync
/
util
.
js
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
prefPermitsStorageSync
"
STORAGE_SYNC_ENABLED_PREF
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
prefStorageSyncServerURL
"
STORAGE_SYNC_SERVER_URL_PREF
KINTO_DEFAULT_SERVER_URL
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
WeaveCrypto
"
function
(
)
{
let
{
WeaveCrypto
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
crypto
/
WeaveCrypto
.
js
"
)
;
return
new
WeaveCrypto
(
)
;
}
)
;
const
{
DefaultMap
}
=
ExtensionUtils
;
const
extensionContexts
=
new
DefaultMap
(
(
)
=
>
new
Set
(
)
)
;
const
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
Engine
.
Extension
-
Storage
"
)
;
let
_fxaService
=
null
;
if
(
AppConstants
.
platform
!
=
"
android
"
)
{
_fxaService
=
fxAccounts
;
}
class
ServerKeyringDeleted
extends
Error
{
constructor
(
)
{
super
(
"
server
keyring
appears
to
have
disappeared
;
we
were
called
to
decrypt
null
"
)
;
}
}
function
throwIfNoFxA
(
fxAccounts
action
)
{
if
(
!
fxAccounts
)
{
throw
new
Error
(
{
action
}
is
impossible
because
FXAccounts
is
not
available
;
are
you
on
Android
?
)
;
}
}
var
extensionStorageSync
=
null
;
function
ciphertextHMAC
(
keyBundle
id
IV
ciphertext
)
{
const
hasher
=
keyBundle
.
sha256HMACHasher
;
return
CommonUtils
.
bytesAsHex
(
Utils
.
digestUTF8
(
id
+
IV
+
ciphertext
hasher
)
)
;
}
const
getKBHash
=
async
function
(
fxaService
)
{
const
signedInUser
=
await
fxaService
.
getSignedInUser
(
)
;
if
(
!
signedInUser
)
{
throw
new
Error
(
"
User
isn
'
t
signed
in
!
"
)
;
}
if
(
!
signedInUser
.
kExtKbHash
)
{
throw
new
Error
(
"
User
doesn
'
t
have
KbHash
?
?
"
)
;
}
return
signedInUser
.
kExtKbHash
;
}
;
class
EncryptionRemoteTransformer
{
async
encode
(
record
)
{
const
keyBundle
=
await
this
.
getKeys
(
)
;
if
(
record
.
ciphertext
)
{
throw
new
Error
(
"
Attempt
to
reencrypt
?
?
"
)
;
}
let
id
=
await
this
.
getEncodedRecordId
(
record
)
;
if
(
!
id
)
{
throw
new
Error
(
"
Record
ID
is
missing
or
invalid
"
)
;
}
let
IV
=
WeaveCrypto
.
generateRandomIV
(
)
;
let
ciphertext
=
await
WeaveCrypto
.
encrypt
(
JSON
.
stringify
(
record
)
keyBundle
.
encryptionKeyB64
IV
)
;
let
hmac
=
ciphertextHMAC
(
keyBundle
id
IV
ciphertext
)
;
const
encryptedResult
=
{
ciphertext
IV
hmac
id
}
;
encryptedResult
.
_status
=
record
.
_status
=
=
"
deleted
"
?
"
updated
"
:
record
.
_status
;
if
(
record
.
hasOwnProperty
(
"
last_modified
"
)
)
{
encryptedResult
.
last_modified
=
record
.
last_modified
;
}
return
encryptedResult
;
}
async
decode
(
record
)
{
if
(
!
record
.
ciphertext
)
{
if
(
record
.
deleted
)
{
return
record
;
}
throw
new
Error
(
"
No
ciphertext
:
nothing
to
decrypt
?
"
)
;
}
const
keyBundle
=
await
this
.
getKeys
(
)
;
let
computedHMAC
=
ciphertextHMAC
(
keyBundle
record
.
id
record
.
IV
record
.
ciphertext
)
;
if
(
computedHMAC
!
=
record
.
hmac
)
{
Utils
.
throwHMACMismatch
(
record
.
hmac
computedHMAC
)
;
}
let
cleartext
=
await
WeaveCrypto
.
decrypt
(
record
.
ciphertext
keyBundle
.
encryptionKeyB64
record
.
IV
)
;
let
jsonResult
=
JSON
.
parse
(
cleartext
)
;
if
(
!
jsonResult
|
|
typeof
jsonResult
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Decryption
failed
:
result
is
<
"
+
jsonResult
+
"
>
not
an
object
.
"
)
;
}
if
(
record
.
hasOwnProperty
(
"
last_modified
"
)
)
{
jsonResult
.
last_modified
=
record
.
last_modified
;
}
if
(
jsonResult
.
_status
=
=
"
deleted
"
)
{
jsonResult
.
deleted
=
true
;
}
return
jsonResult
;
}
getKeys
(
)
{
throw
new
Error
(
"
override
getKeys
in
a
subclass
"
)
;
}
getEncodedRecordId
(
record
)
{
return
Promise
.
resolve
(
record
.
id
)
;
}
}
global
.
EncryptionRemoteTransformer
=
EncryptionRemoteTransformer
;
class
KeyRingEncryptionRemoteTransformer
extends
EncryptionRemoteTransformer
{
constructor
(
fxaService
)
{
super
(
)
;
this
.
_fxaService
=
fxaService
;
}
getKeys
(
)
{
throwIfNoFxA
(
this
.
_fxaService
"
encrypting
chrome
.
storage
.
sync
records
"
)
;
const
self
=
this
;
return
(
async
function
(
)
{
const
user
=
await
self
.
_fxaService
.
getSignedInUser
(
)
;
if
(
!
user
)
{
throw
new
Error
(
"
user
isn
'
t
signed
in
to
FxA
;
can
'
t
sync
"
)
;
}
if
(
!
user
.
kExtSync
)
{
throw
new
Error
(
"
user
doesn
'
t
have
kExtSync
"
)
;
}
return
BulkKeyBundle
.
fromHexKey
(
user
.
kExtSync
)
;
}
)
(
)
;
}
async
encode
(
record
)
{
const
encoded
=
await
super
.
encode
(
record
)
;
encoded
.
kbHash
=
record
.
kbHash
;
return
encoded
;
}
async
decode
(
record
)
{
try
{
return
await
super
.
decode
(
record
)
;
}
catch
(
e
)
{
if
(
Utils
.
isHMACMismatch
(
e
)
)
{
const
currentKBHash
=
await
getKBHash
(
this
.
_fxaService
)
;
if
(
record
.
kbHash
!
=
currentKBHash
)
{
KeyRingEncryptionRemoteTransformer
.
throwOutdatedKB
(
currentKBHash
record
.
kbHash
)
;
}
}
throw
e
;
}
}
static
throwOutdatedKB
(
shouldBe
is
)
{
throw
new
Error
(
kB
hash
on
record
is
outdated
:
should
be
{
shouldBe
}
is
{
is
}
)
;
}
static
isOutdatedKB
(
exc
)
{
const
kbMessage
=
"
kB
hash
on
record
is
outdated
:
"
;
return
(
exc
&
&
exc
.
message
&
&
exc
.
message
.
indexOf
&
&
exc
.
message
.
indexOf
(
kbMessage
)
=
=
0
)
;
}
}
global
.
KeyRingEncryptionRemoteTransformer
=
KeyRingEncryptionRemoteTransformer
;
async
function
storageSyncInit
(
)
{
if
(
storageSyncInit
.
promise
=
=
=
undefined
)
{
const
path
=
"
storage
-
sync
.
sqlite
"
;
storageSyncInit
.
promise
=
FirefoxAdapter
.
openConnection
(
{
path
}
)
.
then
(
connection
=
>
{
return
{
connection
kinto
:
new
Kinto
(
{
adapter
:
FirefoxAdapter
adapterOptions
:
{
sqliteHandle
:
connection
}
timeout
:
KINTO_REQUEST_TIMEOUT
retry
:
0
}
)
}
;
}
)
.
catch
(
e
=
>
{
Cu
.
reportError
(
e
)
;
storageSyncInit
.
promise
=
undefined
;
throw
e
;
}
)
;
}
return
storageSyncInit
.
promise
;
}
function
keyToId
(
key
)
{
function
escapeChar
(
match
)
{
return
(
"
_
"
+
match
.
codePointAt
(
0
)
.
toString
(
16
)
.
toUpperCase
(
)
+
"
_
"
)
;
}
return
"
key
-
"
+
key
.
replace
(
/
[
^
a
-
zA
-
Z0
-
9
]
/
g
escapeChar
)
;
}
function
idToKey
(
id
)
{
function
unescapeNumber
(
match
group1
)
{
return
String
.
fromCodePoint
(
parseInt
(
group1
16
)
)
;
}
const
ESCAPED_ID_FORMAT
=
/
^
(
?
:
[
a
-
zA
-
Z0
-
9
]
|
_
[
0
-
9A
-
F
]
+
_
)
*
/
;
if
(
!
id
.
startsWith
(
"
key
-
"
)
)
{
return
null
;
}
const
unprefixed
=
id
.
slice
(
4
)
;
if
(
!
ESCAPED_ID_FORMAT
.
test
(
unprefixed
)
)
{
return
null
;
}
return
unprefixed
.
replace
(
/
_
(
[
0
-
9A
-
F
]
+
)
_
/
g
unescapeNumber
)
;
}
const
storageSyncIdSchema
=
{
generate
(
)
{
throw
new
Error
(
"
cannot
generate
IDs
"
)
;
}
validate
(
id
)
{
return
idToKey
(
id
)
!
=
=
null
;
}
}
;
const
cryptoCollectionIdSchema
=
{
generate
(
)
{
throw
new
Error
(
"
cannot
generate
IDs
for
system
collection
"
)
;
}
validate
(
id
)
{
return
true
;
}
}
;
class
CryptoCollection
{
constructor
(
fxaService
)
{
this
.
_fxaService
=
fxaService
;
}
async
getCollection
(
)
{
throwIfNoFxA
(
this
.
_fxaService
"
tried
to
access
cryptoCollection
"
)
;
const
{
kinto
}
=
await
storageSyncInit
(
)
;
return
kinto
.
collection
(
STORAGE_SYNC_CRYPTO_COLLECTION_NAME
{
idSchema
:
cryptoCollectionIdSchema
remoteTransformers
:
[
new
KeyRingEncryptionRemoteTransformer
(
this
.
_fxaService
)
]
}
)
;
}
getNewSalt
(
)
{
return
btoa
(
CryptoUtils
.
generateRandomBytesLegacy
(
STORAGE_SYNC_CRYPTO_SALT_LENGTH_BYTES
)
)
;
}
async
getKeyRingRecord
(
)
{
const
collection
=
await
this
.
getCollection
(
)
;
const
cryptoKeyRecord
=
await
collection
.
getAny
(
STORAGE_SYNC_CRYPTO_KEYRING_RECORD_ID
)
;
let
data
=
cryptoKeyRecord
.
data
;
if
(
!
data
)
{
const
uuidgen
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
const
uuid
=
uuidgen
.
generateUUID
(
)
.
toString
(
)
;
data
=
{
uuid
id
:
STORAGE_SYNC_CRYPTO_KEYRING_RECORD_ID
}
;
}
return
data
;
}
async
getSalts
(
)
{
const
cryptoKeyRecord
=
await
this
.
getKeyRingRecord
(
)
;
return
cryptoKeyRecord
&
&
cryptoKeyRecord
.
salts
;
}
async
_setSalt
(
extensionId
salt
)
{
const
cryptoKeyRecord
=
await
this
.
getKeyRingRecord
(
)
;
cryptoKeyRecord
.
salts
=
cryptoKeyRecord
.
salts
|
|
{
}
;
cryptoKeyRecord
.
salts
[
extensionId
]
=
salt
;
await
this
.
upsert
(
cryptoKeyRecord
)
;
}
extensionIdToCollectionId
(
extensionId
)
{
return
this
.
hashWithExtensionSalt
(
CommonUtils
.
encodeUTF8
(
extensionId
)
extensionId
)
.
then
(
hash
=
>
ext
-
{
hash
}
)
;
}
async
hashWithExtensionSalt
(
value
extensionId
)
{
const
salts
=
await
this
.
getSalts
(
)
;
const
saltBase64
=
salts
&
&
salts
[
extensionId
]
;
if
(
!
saltBase64
)
{
throw
new
Error
(
no
salt
available
for
{
extensionId
}
;
how
did
this
happen
?
)
;
}
const
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA256
)
;
const
salt
=
atob
(
saltBase64
)
;
const
message
=
{
salt
}
\
x00
{
value
}
;
const
hash
=
CryptoUtils
.
digestBytes
(
message
hasher
)
;
return
CommonUtils
.
encodeBase64URL
(
hash
false
)
;
}
async
getKeyRing
(
)
{
const
cryptoKeyRecord
=
await
this
.
getKeyRingRecord
(
)
;
const
collectionKeys
=
new
CollectionKeyManager
(
)
;
if
(
cryptoKeyRecord
.
keys
)
{
collectionKeys
.
setContents
(
cryptoKeyRecord
.
keys
cryptoKeyRecord
.
last_modified
)
;
}
else
{
await
collectionKeys
.
generateDefaultKey
(
)
;
}
collectionKeys
.
uuid
=
cryptoKeyRecord
.
uuid
;
return
collectionKeys
;
}
async
updateKBHash
(
kbHash
)
{
const
coll
=
await
this
.
getCollection
(
)
;
await
coll
.
update
(
{
id
:
STORAGE_SYNC_CRYPTO_KEYRING_RECORD_ID
kbHash
:
kbHash
}
{
patch
:
true
}
)
;
}
async
upsert
(
record
)
{
const
collection
=
await
this
.
getCollection
(
)
;
await
collection
.
upsert
(
record
)
;
}
async
sync
(
extensionStorageSync
)
{
const
collection
=
await
this
.
getCollection
(
)
;
return
extensionStorageSync
.
_syncCollection
(
collection
{
strategy
:
"
server_wins
"
}
)
;
}
async
resetSyncStatus
(
)
{
const
coll
=
await
this
.
getCollection
(
)
;
await
coll
.
db
.
resetSyncStatus
(
)
;
}
async
_clear
(
)
{
const
collection
=
await
this
.
getCollection
(
)
;
await
collection
.
clear
(
)
;
}
}
this
.
CryptoCollection
=
CryptoCollection
;
let
CollectionKeyEncryptionRemoteTransformer
=
class
extends
EncryptionRemoteTransformer
{
constructor
(
cryptoCollection
extensionId
)
{
super
(
)
;
this
.
cryptoCollection
=
cryptoCollection
;
this
.
extensionId
=
extensionId
;
}
async
getKeys
(
)
{
const
collectionKeys
=
await
this
.
cryptoCollection
.
getKeyRing
(
)
;
if
(
!
collectionKeys
.
hasKeysFor
(
[
this
.
extensionId
]
)
)
{
throw
new
Error
(
tried
to
encrypt
records
for
{
this
.
extensionId
}
but
key
is
not
present
)
;
}
return
collectionKeys
.
keyForCollection
(
this
.
extensionId
)
;
}
getEncodedRecordId
(
record
)
{
const
id
=
CommonUtils
.
encodeUTF8
(
record
.
id
)
;
return
this
.
cryptoCollection
.
hashWithExtensionSalt
(
id
this
.
extensionId
)
.
then
(
hash
=
>
id
-
{
hash
}
)
;
}
}
;
global
.
CollectionKeyEncryptionRemoteTransformer
=
CollectionKeyEncryptionRemoteTransformer
;
function
cleanUpForContext
(
extension
context
)
{
const
contexts
=
extensionContexts
.
get
(
extension
)
;
contexts
.
delete
(
context
)
;
if
(
contexts
.
size
=
=
=
0
)
{
extensionContexts
.
delete
(
extension
)
;
}
}
const
openCollection
=
async
function
(
cryptoCollection
extension
context
)
{
let
collectionId
=
extension
.
id
;
const
{
kinto
}
=
await
storageSyncInit
(
)
;
const
remoteTransformers
=
[
new
CollectionKeyEncryptionRemoteTransformer
(
cryptoCollection
extension
.
id
)
]
;
const
coll
=
kinto
.
collection
(
collectionId
{
idSchema
:
storageSyncIdSchema
remoteTransformers
}
)
;
return
coll
;
}
;
class
ExtensionStorageSync
{
constructor
(
fxaService
telemetry
)
{
this
.
_fxaService
=
fxaService
;
this
.
_telemetry
=
telemetry
;
this
.
cryptoCollection
=
new
CryptoCollection
(
fxaService
)
;
this
.
listeners
=
new
WeakMap
(
)
;
}
async
getExtensions
(
)
{
const
extensions
=
new
Set
(
extensionContexts
.
keys
(
)
)
;
const
allEnabledExtensions
=
await
AddonManager
.
getAddonsByTypes
(
[
"
extension
"
]
)
;
const
keysRecord
=
await
this
.
cryptoCollection
.
getKeyRingRecord
(
)
;
for
(
const
addon
of
allEnabledExtensions
)
{
if
(
this
.
hasSaltsFor
(
keysRecord
[
addon
.
id
]
)
)
{
const
policy
=
WebExtensionPolicy
.
getByID
(
addon
.
id
)
;
if
(
policy
&
&
policy
.
extension
)
{
extensions
.
add
(
policy
.
extension
)
;
}
}
}
return
extensions
;
}
async
syncAll
(
)
{
const
extensions
=
await
this
.
getExtensions
(
)
;
const
extIds
=
Array
.
from
(
extensions
extension
=
>
extension
.
id
)
;
log
.
debug
(
Syncing
extension
settings
for
{
JSON
.
stringify
(
extIds
)
}
)
;
if
(
!
extIds
.
length
)
{
return
;
}
await
this
.
ensureCanSync
(
extIds
)
;
await
this
.
checkSyncKeyRing
(
)
;
const
promises
=
Array
.
from
(
extensions
extension
=
>
{
return
openCollection
(
this
.
cryptoCollection
extension
)
.
then
(
coll
=
>
{
return
this
.
sync
(
extension
coll
)
;
}
)
;
}
)
;
await
Promise
.
all
(
promises
)
;
const
collection
=
await
this
.
cryptoCollection
.
getCollection
(
)
;
const
storage
=
await
collection
.
db
.
calculateStorage
(
)
;
this
.
_telemetry
.
scalarSet
(
SCALAR_EXTENSIONS_USING
storage
.
length
)
;
for
(
let
{
collectionName
size
numRecords
}
of
storage
)
{
this
.
_telemetry
.
keyedScalarSet
(
SCALAR_ITEMS_STORED
collectionName
numRecords
)
;
this
.
_telemetry
.
keyedScalarSet
(
SCALAR_STORAGE_CONSUMED
collectionName
size
)
;
}
}
async
sync
(
extension
collection
)
{
throwIfNoFxA
(
this
.
_fxaService
"
syncing
chrome
.
storage
.
sync
"
)
;
const
signedInUser
=
await
this
.
_fxaService
.
getSignedInUser
(
)
;
if
(
!
signedInUser
)
{
log
.
info
(
"
User
was
not
signed
into
FxA
;
cannot
sync
"
)
;
throw
new
Error
(
"
Not
signed
in
to
FxA
"
)
;
}
const
collectionId
=
await
this
.
cryptoCollection
.
extensionIdToCollectionId
(
extension
.
id
)
;
let
syncResults
;
try
{
syncResults
=
await
this
.
_syncCollection
(
collection
{
strategy
:
"
client_wins
"
collection
:
collectionId
}
)
;
}
catch
(
err
)
{
log
.
warn
(
"
Syncing
failed
"
err
)
;
throw
err
;
}
let
changes
=
{
}
;
for
(
const
record
of
syncResults
.
created
)
{
changes
[
record
.
key
]
=
{
newValue
:
record
.
data
}
;
}
for
(
const
record
of
syncResults
.
updated
)
{
const
key
=
record
.
old
.
key
;
changes
[
key
]
=
{
oldValue
:
record
.
old
.
data
newValue
:
record
.
new
.
data
}
;
}
for
(
const
record
of
syncResults
.
deleted
)
{
changes
[
record
.
key
]
=
{
oldValue
:
record
.
data
}
;
}
for
(
const
resolution
of
syncResults
.
resolved
)
{
const
accepted
=
resolution
.
accepted
;
changes
[
accepted
.
key
]
=
{
newValue
:
accepted
.
data
}
;
}
if
(
Object
.
keys
(
changes
)
.
length
)
{
this
.
notifyListeners
(
extension
changes
)
;
}
log
.
info
(
Successfully
synced
'
{
collection
.
name
}
'
)
;
}
_syncCollection
(
collection
options
)
{
return
this
.
_requestWithToken
(
Syncing
{
collection
.
name
}
function
(
token
)
{
const
allOptions
=
Object
.
assign
(
{
}
{
remote
:
prefStorageSyncServerURL
headers
:
{
Authorization
:
"
Bearer
"
+
token
}
}
options
)
;
return
collection
.
sync
(
allOptions
)
;
}
)
;
}
async
_requestWithToken
(
description
f
)
{
throwIfNoFxA
(
this
.
_fxaService
"
making
remote
requests
from
chrome
.
storage
.
sync
"
)
;
const
fxaToken
=
await
this
.
_fxaService
.
getOAuthToken
(
FXA_OAUTH_OPTIONS
)
;
try
{
return
await
f
(
fxaToken
)
;
}
catch
(
e
)
{
if
(
e
&
&
e
.
response
&
&
e
.
response
.
status
=
=
401
)
{
log
.
info
(
"
Token
might
have
expired
"
)
;
await
this
.
_fxaService
.
removeCachedOAuthToken
(
{
token
:
fxaToken
}
)
;
const
newToken
=
await
this
.
_fxaService
.
getOAuthToken
(
FXA_OAUTH_OPTIONS
)
;
return
f
(
newToken
)
;
}
log
.
error
(
{
description
}
:
request
failed
e
)
;
throw
e
;
}
}
_deleteBucket
(
)
{
log
.
error
(
"
Deleting
default
bucket
and
everything
in
it
"
)
;
return
this
.
_requestWithToken
(
"
Clearing
server
"
function
(
token
)
{
const
headers
=
{
Authorization
:
"
Bearer
"
+
token
}
;
const
kintoHttp
=
new
KintoHttpClient
(
prefStorageSyncServerURL
{
headers
:
headers
timeout
:
KINTO_REQUEST_TIMEOUT
}
)
;
return
kintoHttp
.
deleteBucket
(
"
default
"
)
;
}
)
;
}
async
ensureSaltsFor
(
keysRecord
extIds
)
{
const
newSalts
=
Object
.
assign
(
{
}
keysRecord
.
salts
)
;
for
(
let
collectionId
of
extIds
)
{
if
(
newSalts
[
collectionId
]
)
{
continue
;
}
newSalts
[
collectionId
]
=
this
.
cryptoCollection
.
getNewSalt
(
)
;
}
return
newSalts
;
}
hasSaltsFor
(
keysRecord
extIds
)
{
if
(
!
keysRecord
.
salts
)
{
return
false
;
}
for
(
let
collectionId
of
extIds
)
{
if
(
!
keysRecord
.
salts
[
collectionId
]
)
{
return
false
;
}
}
return
true
;
}
async
ensureCanSync
(
extIds
)
{
const
keysRecord
=
await
this
.
cryptoCollection
.
getKeyRingRecord
(
)
;
const
collectionKeys
=
await
this
.
cryptoCollection
.
getKeyRing
(
)
;
if
(
collectionKeys
.
hasKeysFor
(
extIds
)
&
&
this
.
hasSaltsFor
(
keysRecord
extIds
)
)
{
return
collectionKeys
;
}
log
.
info
(
Need
to
create
keys
and
/
or
salts
for
{
JSON
.
stringify
(
extIds
)
}
)
;
const
kbHash
=
await
getKBHash
(
this
.
_fxaService
)
;
const
newKeys
=
await
collectionKeys
.
ensureKeysFor
(
extIds
)
;
const
newSalts
=
await
this
.
ensureSaltsFor
(
keysRecord
extIds
)
;
const
newRecord
=
{
id
:
STORAGE_SYNC_CRYPTO_KEYRING_RECORD_ID
keys
:
newKeys
.
asWBO
(
)
.
cleartext
salts
:
newSalts
uuid
:
collectionKeys
.
uuid
kbHash
:
kbHash
}
;
await
this
.
cryptoCollection
.
upsert
(
newRecord
)
;
const
result
=
await
this
.
_syncKeyRing
(
newRecord
)
;
if
(
result
.
resolved
.
length
)
{
return
this
.
ensureCanSync
(
extIds
)
;
}
return
newKeys
;
}
async
updateKeyRingKB
(
)
{
throwIfNoFxA
(
this
.
_fxaService
'
use
of
chrome
.
storage
.
sync
"
keyring
"
'
)
;
const
signedInUser
=
await
this
.
_fxaService
.
getSignedInUser
(
)
;
if
(
!
signedInUser
)
{
return
;
}
const
thisKBHash
=
await
getKBHash
(
this
.
_fxaService
)
;
await
this
.
cryptoCollection
.
updateKBHash
(
thisKBHash
)
;
}
async
checkSyncKeyRing
(
)
{
await
this
.
updateKeyRingKB
(
)
;
const
cryptoKeyRecord
=
await
this
.
cryptoCollection
.
getKeyRingRecord
(
)
;
if
(
cryptoKeyRecord
&
&
cryptoKeyRecord
.
_status
!
=
=
"
synced
"
)
{
await
this
.
_syncKeyRing
(
cryptoKeyRecord
)
;
}
}
async
_syncKeyRing
(
cryptoKeyRecord
)
{
throwIfNoFxA
(
this
.
_fxaService
'
syncing
chrome
.
storage
.
sync
"
keyring
"
'
)
;
try
{
const
result
=
await
this
.
cryptoCollection
.
sync
(
this
)
;
if
(
result
.
resolved
.
length
)
{
const
resolutionIds
=
result
.
resolved
.
map
(
resolution
=
>
resolution
.
id
)
;
if
(
resolutionIds
>
1
)
{
log
.
error
(
Too
many
resolutions
for
sync
-
storage
-
crypto
collection
:
{
JSON
.
stringify
(
resolutionIds
)
}
)
;
}
const
keyResolution
=
result
.
resolved
[
0
]
;
if
(
keyResolution
.
id
!
=
STORAGE_SYNC_CRYPTO_KEYRING_RECORD_ID
)
{
log
.
error
(
Strange
conflict
in
sync
-
storage
-
crypto
collection
:
{
JSON
.
stringify
(
resolutionIds
)
}
)
;
}
if
(
keyResolution
.
accepted
=
=
=
null
)
{
log
.
error
(
"
Conflict
spotted
-
-
the
server
keyring
was
deleted
"
)
;
await
this
.
cryptoCollection
.
upsert
(
keyResolution
.
rejected
)
;
throw
new
ServerKeyringDeleted
(
)
;
}
if
(
keyResolution
.
accepted
.
uuid
!
=
cryptoKeyRecord
.
uuid
)
{
log
.
info
(
Detected
a
new
UUID
(
{
keyResolution
.
accepted
.
uuid
}
was
{
cryptoKeyRecord
.
uuid
}
)
.
Resetting
sync
status
for
everything
.
)
;
await
this
.
cryptoCollection
.
resetSyncStatus
(
)
;
return
result
;
}
}
return
result
;
}
catch
(
e
)
{
if
(
KeyRingEncryptionRemoteTransformer
.
isOutdatedKB
(
e
)
|
|
e
instanceof
ServerKeyringDeleted
|
|
e
.
message
.
includes
(
"
Server
has
been
flushed
.
"
)
)
{
const
isSessionValid
=
await
this
.
_fxaService
.
sessionStatus
(
)
;
if
(
isSessionValid
)
{
log
.
error
(
"
Couldn
'
t
decipher
old
keyring
;
deleting
the
default
bucket
and
resetting
sync
status
"
)
;
await
this
.
_deleteBucket
(
)
;
await
this
.
cryptoCollection
.
resetSyncStatus
(
)
;
return
this
.
cryptoCollection
.
sync
(
this
)
;
}
}
throw
e
;
}
}
registerInUse
(
extension
context
)
{
const
contexts
=
extensionContexts
.
get
(
extension
)
;
if
(
!
contexts
.
has
(
context
)
)
{
contexts
.
add
(
context
)
;
context
.
callOnClose
(
{
close
:
(
)
=
>
cleanUpForContext
(
extension
context
)
}
)
;
}
}
getCollection
(
extension
context
)
{
if
(
prefPermitsStorageSync
!
=
=
true
)
{
return
Promise
.
reject
(
{
message
:
Please
set
{
STORAGE_SYNC_ENABLED_PREF
}
to
true
in
about
:
config
}
)
;
}
this
.
registerInUse
(
extension
context
)
;
return
openCollection
(
this
.
cryptoCollection
extension
context
)
;
}
async
set
(
extension
items
context
)
{
const
coll
=
await
this
.
getCollection
(
extension
context
)
;
const
keys
=
Object
.
keys
(
items
)
;
const
ids
=
keys
.
map
(
keyToId
)
;
const
histogramSize
=
this
.
_telemetry
.
getKeyedHistogramById
(
HISTOGRAM_SET_OPS_SIZE
)
;
const
changes
=
await
coll
.
execute
(
txn
=
>
{
let
changes
=
{
}
;
for
(
let
[
i
key
]
of
keys
.
entries
(
)
)
{
const
id
=
ids
[
i
]
;
let
item
=
items
[
key
]
;
histogramSize
.
add
(
extension
.
id
JSON
.
stringify
(
item
)
.
length
)
;
let
{
oldRecord
}
=
txn
.
upsert
(
{
id
key
data
:
item
}
)
;
changes
[
key
]
=
{
newValue
:
item
}
;
if
(
oldRecord
&
&
oldRecord
.
data
)
{
changes
[
key
]
.
oldValue
=
oldRecord
.
data
;
}
}
return
changes
;
}
{
preloadIds
:
ids
}
)
;
this
.
notifyListeners
(
extension
changes
)
;
}
async
remove
(
extension
keys
context
)
{
const
coll
=
await
this
.
getCollection
(
extension
context
)
;
keys
=
[
]
.
concat
(
keys
)
;
const
ids
=
keys
.
map
(
keyToId
)
;
let
changes
=
{
}
;
await
coll
.
execute
(
txn
=
>
{
for
(
let
[
i
key
]
of
keys
.
entries
(
)
)
{
const
id
=
ids
[
i
]
;
const
res
=
txn
.
deleteAny
(
id
)
;
if
(
res
.
deleted
)
{
changes
[
key
]
=
{
oldValue
:
res
.
data
.
data
}
;
}
}
return
changes
;
}
{
preloadIds
:
ids
}
)
;
if
(
Object
.
keys
(
changes
)
.
length
)
{
this
.
notifyListeners
(
extension
changes
)
;
}
const
histogram
=
this
.
_telemetry
.
getKeyedHistogramById
(
HISTOGRAM_REMOVE_OPS
)
;
histogram
.
add
(
extension
.
id
keys
.
length
)
;
}
async
clearAll
(
)
{
const
extensions
=
await
this
.
getExtensions
(
)
;
const
extIds
=
Array
.
from
(
extensions
extension
=
>
extension
.
id
)
;
log
.
debug
(
Clearing
extension
data
for
{
JSON
.
stringify
(
extIds
)
}
)
;
if
(
extIds
.
length
)
{
const
promises
=
Array
.
from
(
extensions
extension
=
>
{
return
openCollection
(
this
.
cryptoCollection
extension
)
.
then
(
coll
=
>
{
return
coll
.
clear
(
)
;
}
)
;
}
)
;
await
Promise
.
all
(
promises
)
;
}
const
cc
=
await
this
.
cryptoCollection
.
getCollection
(
)
;
await
cc
.
clear
(
)
;
}
async
clear
(
extension
context
)
{
const
coll
=
await
this
.
getCollection
(
extension
context
)
;
const
res
=
await
coll
.
list
(
)
;
const
records
=
res
.
data
;
const
keys
=
records
.
map
(
record
=
>
record
.
key
)
;
await
this
.
remove
(
extension
keys
context
)
;
}
async
get
(
extension
spec
context
)
{
const
coll
=
await
this
.
getCollection
(
extension
context
)
;
const
histogramSize
=
this
.
_telemetry
.
getKeyedHistogramById
(
HISTOGRAM_GET_OPS_SIZE
)
;
let
keys
records
;
if
(
spec
=
=
=
null
)
{
records
=
{
}
;
const
res
=
await
coll
.
list
(
)
;
for
(
let
record
of
res
.
data
)
{
histogramSize
.
add
(
extension
.
id
JSON
.
stringify
(
record
.
data
)
.
length
)
;
records
[
record
.
key
]
=
record
.
data
;
}
return
records
;
}
if
(
typeof
spec
=
=
=
"
string
"
)
{
keys
=
[
spec
]
;
records
=
{
}
;
}
else
if
(
Array
.
isArray
(
spec
)
)
{
keys
=
spec
;
records
=
{
}
;
}
else
{
keys
=
Object
.
keys
(
spec
)
;
records
=
Cu
.
cloneInto
(
spec
global
)
;
}
for
(
let
key
of
keys
)
{
const
res
=
await
coll
.
getAny
(
keyToId
(
key
)
)
;
if
(
res
.
data
&
&
res
.
data
.
_status
!
=
"
deleted
"
)
{
histogramSize
.
add
(
extension
.
id
JSON
.
stringify
(
res
.
data
.
data
)
.
length
)
;
records
[
res
.
data
.
key
]
=
res
.
data
.
data
;
}
}
return
records
;
}
addOnChangedListener
(
extension
listener
context
)
{
let
listeners
=
this
.
listeners
.
get
(
extension
)
|
|
new
Set
(
)
;
listeners
.
add
(
listener
)
;
this
.
listeners
.
set
(
extension
listeners
)
;
this
.
registerInUse
(
extension
context
)
;
}
removeOnChangedListener
(
extension
listener
)
{
let
listeners
=
this
.
listeners
.
get
(
extension
)
;
listeners
.
delete
(
listener
)
;
if
(
listeners
.
size
=
=
0
)
{
this
.
listeners
.
delete
(
extension
)
;
}
}
notifyListeners
(
extension
changes
)
{
Observers
.
notify
(
"
ext
.
storage
.
sync
-
changed
"
)
;
let
listeners
=
this
.
listeners
.
get
(
extension
)
|
|
new
Set
(
)
;
if
(
listeners
)
{
for
(
let
listener
of
listeners
)
{
ExtensionCommon
.
runSafeSyncWithoutClone
(
listener
changes
)
;
}
}
}
}
this
.
ExtensionStorageSync
=
ExtensionStorageSync
;
extensionStorageSync
=
new
ExtensionStorageSync
(
_fxaService
Services
.
telemetry
)
;
