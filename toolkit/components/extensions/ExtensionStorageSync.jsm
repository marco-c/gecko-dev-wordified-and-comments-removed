"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionStorageSync
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
const
global
=
this
;
const
STORAGE_SYNC_ENABLED_PREF
=
"
webextensions
.
storage
.
sync
.
enabled
"
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
runSafeSyncWithoutClone
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppsUtils
"
"
resource
:
/
/
gre
/
modules
/
AppsUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionStorage
"
"
resource
:
/
/
gre
/
modules
/
ExtensionStorage
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
loadKinto
"
"
resource
:
/
/
services
-
common
/
kinto
-
offline
-
client
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Observers
"
"
resource
:
/
/
services
-
common
/
observers
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
prefPermitsStorageSync
"
STORAGE_SYNC_ENABLED_PREF
false
)
;
const
collectionPromises
=
new
Map
(
)
;
const
extensionContexts
=
new
WeakMap
(
)
;
function
keyToId
(
key
)
{
function
escapeChar
(
match
)
{
return
"
_
"
+
match
.
codePointAt
(
0
)
.
toString
(
16
)
.
toUpperCase
(
)
+
"
_
"
;
}
return
"
key
-
"
+
key
.
replace
(
/
[
^
a
-
zA
-
Z0
-
9
]
/
g
escapeChar
)
;
}
function
idToKey
(
id
)
{
function
unescapeNumber
(
match
group1
)
{
return
String
.
fromCodePoint
(
parseInt
(
group1
16
)
)
;
}
const
ESCAPED_ID_FORMAT
=
/
^
(
?
:
[
a
-
zA
-
Z0
-
9
]
|
_
[
0
-
9A
-
F
]
+
_
)
*
/
;
if
(
!
id
.
startsWith
(
"
key
-
"
)
)
{
return
null
;
}
const
unprefixed
=
id
.
slice
(
4
)
;
if
(
!
ESCAPED_ID_FORMAT
.
test
(
unprefixed
)
)
{
return
null
;
}
return
unprefixed
.
replace
(
/
_
(
[
0
-
9A
-
F
]
+
)
_
/
g
unescapeNumber
)
;
}
const
storageSyncIdSchema
=
{
generate
(
)
{
throw
new
Error
(
"
cannot
generate
IDs
"
)
;
}
validate
(
id
)
{
return
idToKey
(
id
)
!
=
=
null
;
}
}
;
function
makeKinto
(
)
{
const
Kinto
=
loadKinto
(
)
;
return
new
Kinto
(
{
adapter
:
Kinto
.
adapters
.
FirefoxAdapter
adapterOptions
:
{
path
:
"
storage
-
sync
.
sqlite
"
}
}
)
;
}
function
closeExtensionCollection
(
extension
)
{
const
collectionPromise
=
collectionPromises
.
get
(
extension
)
;
if
(
!
collectionPromise
)
{
Cu
.
reportError
(
new
Error
(
Internal
error
:
trying
to
close
extension
{
extension
.
id
}
+
"
that
doesn
'
t
have
a
collection
"
)
)
;
return
;
}
collectionPromises
.
delete
(
extension
)
;
return
collectionPromise
.
then
(
coll
=
>
{
return
coll
.
db
.
close
(
)
;
}
)
;
}
function
cleanUpForContext
(
extension
context
)
{
const
contexts
=
extensionContexts
.
get
(
extension
)
;
if
(
!
contexts
)
{
Cu
.
reportError
(
new
Error
(
Internal
error
:
cannot
find
any
contexts
for
extension
{
extension
.
id
}
)
)
;
return
closeExtensionCollection
(
extension
)
;
}
contexts
.
delete
(
context
)
;
if
(
contexts
.
size
=
=
=
0
)
{
extensionContexts
.
delete
(
extension
)
;
return
closeExtensionCollection
(
extension
)
;
}
}
const
openCollection
=
Task
.
async
(
function
*
(
extension
context
)
{
let
collectionId
=
extension
.
id
;
const
db
=
makeKinto
(
)
;
const
coll
=
db
.
collection
(
collectionId
{
idSchema
:
storageSyncIdSchema
}
)
;
yield
coll
.
db
.
open
(
)
;
return
coll
;
}
)
;
this
.
ExtensionStorageSync
=
{
listeners
:
new
WeakMap
(
)
getCollection
(
extension
context
)
{
if
(
prefPermitsStorageSync
!
=
=
true
)
{
return
Promise
.
reject
(
{
message
:
Please
set
{
STORAGE_SYNC_ENABLED_PREF
}
to
true
in
about
:
config
}
)
;
}
if
(
!
collectionPromises
.
has
(
extension
)
)
{
const
collectionPromise
=
openCollection
(
extension
context
)
;
collectionPromises
.
set
(
extension
collectionPromise
)
;
collectionPromise
.
catch
(
Cu
.
reportError
)
;
}
if
(
!
extensionContexts
.
has
(
extension
)
)
{
extensionContexts
.
set
(
extension
new
Set
(
)
)
;
}
const
contexts
=
extensionContexts
.
get
(
extension
)
;
if
(
!
contexts
.
has
(
context
)
)
{
contexts
.
add
(
context
)
;
context
.
callOnClose
(
{
close
:
(
)
=
>
cleanUpForContext
(
extension
context
)
}
)
;
}
return
collectionPromises
.
get
(
extension
)
;
}
set
:
Task
.
async
(
function
*
(
extension
items
context
)
{
const
coll
=
yield
this
.
getCollection
(
extension
context
)
;
const
keys
=
Object
.
keys
(
items
)
;
const
ids
=
keys
.
map
(
keyToId
)
;
const
changes
=
yield
coll
.
execute
(
txn
=
>
{
let
changes
=
{
}
;
for
(
let
[
i
key
]
of
keys
.
entries
(
)
)
{
const
id
=
ids
[
i
]
;
let
item
=
items
[
key
]
;
let
{
oldRecord
}
=
txn
.
upsert
(
{
id
key
data
:
item
}
)
;
changes
[
key
]
=
{
newValue
:
item
}
;
if
(
oldRecord
&
&
oldRecord
.
data
)
{
changes
[
key
]
.
oldValue
=
oldRecord
.
data
;
}
}
return
changes
;
}
{
preloadIds
:
ids
}
)
;
this
.
notifyListeners
(
extension
changes
)
;
}
)
remove
:
Task
.
async
(
function
*
(
extension
keys
context
)
{
const
coll
=
yield
this
.
getCollection
(
extension
context
)
;
keys
=
[
]
.
concat
(
keys
)
;
const
ids
=
keys
.
map
(
keyToId
)
;
let
changes
=
{
}
;
yield
coll
.
execute
(
txn
=
>
{
for
(
let
[
i
key
]
of
keys
.
entries
(
)
)
{
const
id
=
ids
[
i
]
;
const
res
=
txn
.
deleteAny
(
id
)
;
if
(
res
.
deleted
)
{
changes
[
key
]
=
{
oldValue
:
res
.
data
.
data
}
;
}
}
return
changes
;
}
{
preloadIds
:
ids
}
)
;
if
(
Object
.
keys
(
changes
)
.
length
>
0
)
{
this
.
notifyListeners
(
extension
changes
)
;
}
}
)
clear
:
Task
.
async
(
function
*
(
extension
context
)
{
const
coll
=
yield
this
.
getCollection
(
extension
context
)
;
const
res
=
yield
coll
.
list
(
)
;
const
records
=
res
.
data
;
const
keys
=
records
.
map
(
record
=
>
record
.
key
)
;
yield
this
.
remove
(
extension
keys
context
)
;
}
)
get
:
Task
.
async
(
function
*
(
extension
spec
context
)
{
const
coll
=
yield
this
.
getCollection
(
extension
context
)
;
let
keys
records
;
if
(
spec
=
=
=
null
)
{
records
=
{
}
;
const
res
=
yield
coll
.
list
(
)
;
for
(
let
record
of
res
.
data
)
{
records
[
record
.
key
]
=
record
.
data
;
}
return
records
;
}
if
(
typeof
spec
=
=
=
"
string
"
)
{
keys
=
[
spec
]
;
records
=
{
}
;
}
else
if
(
Array
.
isArray
(
spec
)
)
{
keys
=
spec
;
records
=
{
}
;
}
else
{
keys
=
Object
.
keys
(
spec
)
;
records
=
Cu
.
cloneInto
(
spec
global
)
;
}
for
(
let
key
of
keys
)
{
const
res
=
yield
coll
.
getAny
(
keyToId
(
key
)
)
;
if
(
res
.
data
&
&
res
.
data
.
_status
!
=
"
deleted
"
)
{
records
[
res
.
data
.
key
]
=
res
.
data
.
data
;
}
}
return
records
;
}
)
addOnChangedListener
(
extension
listener
)
{
let
listeners
=
this
.
listeners
.
get
(
extension
)
|
|
new
Set
(
)
;
listeners
.
add
(
listener
)
;
this
.
listeners
.
set
(
extension
listeners
)
;
}
removeOnChangedListener
(
extension
listener
)
{
let
listeners
=
this
.
listeners
.
get
(
extension
)
;
listeners
.
delete
(
listener
)
;
if
(
listeners
.
size
=
=
0
)
{
this
.
listeners
.
delete
(
extension
)
;
}
}
notifyListeners
(
extension
changes
)
{
Observers
.
notify
(
"
ext
.
storage
.
sync
-
changed
"
)
;
let
listeners
=
this
.
listeners
.
get
(
extension
)
|
|
new
Set
(
)
;
if
(
listeners
)
{
for
(
let
listener
of
listeners
)
{
runSafeSyncWithoutClone
(
listener
changes
)
;
}
}
}
}
;
