"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionChild
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MessageChannel
"
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Schemas
"
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
)
;
const
CATEGORY_EXTENSION_SCRIPTS_ADDON
=
"
webextension
-
scripts
-
addon
"
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
getInnerWindowID
BaseContext
ChildAPIManager
LocalAPIImplementation
Messenger
SchemaAPIManager
}
=
ExtensionUtils
;
XPCOMUtils
.
defineLazyGetter
(
this
"
findPathInObject
"
(
)
=
>
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
{
}
)
.
findPathInObject
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
GlobalManager
"
(
)
=
>
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
{
}
)
.
GlobalManager
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
Management
"
(
)
=
>
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
{
}
)
.
Management
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ParentAPIManager
"
(
)
=
>
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
{
}
)
.
ParentAPIManager
)
;
var
apiManager
=
new
class
extends
SchemaAPIManager
{
constructor
(
)
{
super
(
"
addon
"
)
;
this
.
initialized
=
false
;
}
generateAPIs
(
.
.
.
args
)
{
if
(
!
this
.
initialized
)
{
this
.
initialized
=
true
;
for
(
let
[
value
]
of
XPCOMUtils
.
enumerateCategoryEntries
(
CATEGORY_EXTENSION_SCRIPTS_ADDON
)
)
{
this
.
loadScript
(
value
)
;
}
}
return
super
.
generateAPIs
(
.
.
.
args
)
;
}
registerSchemaAPI
(
namespace
envType
getAPI
)
{
if
(
envType
=
=
"
addon_child
"
)
{
super
.
registerSchemaAPI
(
namespace
envType
getAPI
)
;
}
}
}
(
)
;
class
WannabeChildAPIManager
extends
ChildAPIManager
{
createProxyContextInConstructor
(
data
)
{
data
=
Object
.
assign
(
{
}
data
)
;
let
{
principal
}
=
data
;
delete
data
.
principal
;
data
=
Cu
.
cloneInto
(
data
{
}
)
;
data
.
principal
=
principal
;
data
.
cloneScopeInProcess
=
this
.
context
.
cloneScope
;
let
name
=
"
API
:
CreateProxyContext
"
;
let
target
=
this
.
context
.
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
chromeEventHandler
;
ParentAPIManager
.
receiveMessage
(
{
name
data
target
}
)
;
let
proxyContext
=
ParentAPIManager
.
proxyContexts
.
get
(
this
.
id
)
;
proxyContext
.
setContentWindow
(
this
.
context
.
contentWindow
)
;
this
.
context
.
callOnClose
(
{
close
:
proxyContext
.
unload
.
bind
(
proxyContext
)
}
)
;
}
getFallbackImplementation
(
namespace
name
)
{
let
shouldSynchronouslyUseParentAPI
=
true
;
if
(
namespace
=
=
"
test
"
&
&
name
!
=
"
onMessage
"
)
{
shouldSynchronouslyUseParentAPI
=
false
;
}
if
(
shouldSynchronouslyUseParentAPI
)
{
let
proxyContext
=
ParentAPIManager
.
proxyContexts
.
get
(
this
.
id
)
;
let
apiObj
=
findPathInObject
(
proxyContext
.
apiObj
namespace
false
)
;
if
(
apiObj
&
&
name
in
apiObj
)
{
return
new
LocalAPIImplementation
(
apiObj
name
this
.
context
)
;
}
}
return
super
.
getFallbackImplementation
(
namespace
name
)
;
}
}
class
ExtensionContext
extends
BaseContext
{
constructor
(
extension
params
)
{
super
(
"
addon_child
"
extension
)
;
if
(
Services
.
appinfo
.
processType
!
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
ExtensionContext
cannot
be
created
in
child
processes
"
)
;
}
let
{
viewType
uri
contentWindow
}
=
params
;
this
.
viewType
=
viewType
;
this
.
uri
=
uri
|
|
extension
.
baseURI
;
this
.
setContentWindow
(
contentWindow
)
;
let
sender
=
{
id
:
extension
.
uuid
}
;
if
(
uri
)
{
sender
.
url
=
uri
.
spec
;
}
Management
.
emit
(
"
page
-
load
"
this
params
sender
)
;
let
filter
=
{
extensionId
:
extension
.
id
}
;
let
optionalFilter
=
{
}
;
this
.
messenger
=
new
Messenger
(
this
[
Services
.
cpmm
this
.
messageManager
]
sender
filter
optionalFilter
)
;
let
localApis
=
{
}
;
apiManager
.
generateAPIs
(
this
localApis
)
;
this
.
childManager
=
new
WannabeChildAPIManager
(
this
this
.
messageManager
localApis
{
envType
:
"
addon_parent
"
viewType
url
:
uri
.
spec
}
)
;
let
chromeApiWrapper
=
Object
.
create
(
this
.
childManager
)
;
chromeApiWrapper
.
isChromeCompat
=
true
;
let
browserObj
=
Cu
.
createObjectIn
(
contentWindow
{
defineAs
:
"
browser
"
}
)
;
let
chromeObj
=
Cu
.
createObjectIn
(
contentWindow
{
defineAs
:
"
chrome
"
}
)
;
Schemas
.
inject
(
browserObj
this
.
childManager
)
;
Schemas
.
inject
(
chromeObj
chromeApiWrapper
)
;
if
(
viewType
=
=
"
background
"
)
{
apiManager
.
global
.
initializeBackgroundPage
(
contentWindow
)
;
}
if
(
this
.
externallyVisible
)
{
this
.
extension
.
views
.
add
(
this
)
;
}
}
get
cloneScope
(
)
{
return
this
.
contentWindow
;
}
get
principal
(
)
{
return
this
.
contentWindow
.
document
.
nodePrincipal
;
}
get
externallyVisible
(
)
{
return
true
;
}
shutdown
(
)
{
Management
.
emit
(
"
page
-
shutdown
"
this
)
;
this
.
unload
(
)
;
}
unload
(
)
{
if
(
this
.
unloaded
)
{
return
;
}
super
.
unload
(
)
;
this
.
childManager
.
close
(
)
;
if
(
this
.
externallyVisible
)
{
this
.
extension
.
views
.
delete
(
this
)
;
}
}
}
this
.
ExtensionChild
=
{
extensionContexts
:
new
Map
(
)
initOnce
(
)
{
MessageChannel
.
setupMessageManagers
(
[
Services
.
cpmm
]
)
;
}
createExtensionContext
(
extension
contentWindow
)
{
extension
=
GlobalManager
.
extensionMap
.
get
(
extension
.
id
)
;
let
windowId
=
getInnerWindowID
(
contentWindow
)
;
let
context
=
this
.
extensionContexts
.
get
(
windowId
)
;
if
(
context
)
{
if
(
context
.
extension
!
=
=
extension
)
{
Cu
.
reportError
(
"
A
different
extension
context
already
exists
in
this
frame
!
"
)
;
}
else
{
Cu
.
reportError
(
"
The
extension
context
was
already
initialized
in
this
frame
.
"
)
;
}
return
;
}
let
docShell
=
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
;
let
parentDocument
=
docShell
.
parent
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
contentViewer
.
DOMDocument
;
let
browser
=
docShell
.
chromeEventHandler
;
if
(
contentWindow
.
frameElement
&
&
parentDocument
.
documentURI
=
=
"
about
:
addons
"
)
{
browser
=
contentWindow
.
frameElement
;
}
let
viewType
=
"
tab
"
;
if
(
browser
.
hasAttribute
(
"
webextension
-
view
-
type
"
)
)
{
viewType
=
browser
.
getAttribute
(
"
webextension
-
view
-
type
"
)
;
}
else
if
(
browser
.
classList
.
contains
(
"
inline
-
options
-
browser
"
)
)
{
viewType
=
"
popup
"
;
}
let
uri
=
contentWindow
.
document
.
documentURIObject
;
context
=
new
ExtensionContext
(
extension
{
viewType
contentWindow
uri
docShell
}
)
;
this
.
extensionContexts
.
set
(
windowId
context
)
;
}
destroyExtensionContext
(
windowId
)
{
let
context
=
this
.
extensionContexts
.
get
(
windowId
)
;
if
(
context
)
{
context
.
unload
(
)
;
this
.
extensionContexts
.
delete
(
windowId
)
;
}
}
shutdownExtension
(
extensionId
)
{
for
(
let
[
windowId
context
]
of
this
.
extensionContexts
)
{
if
(
context
.
extension
.
id
=
=
extensionId
)
{
context
.
shutdown
(
)
;
this
.
extensionContexts
.
delete
(
windowId
)
;
}
}
}
}
;
if
(
Services
.
appinfo
.
processType
!
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
Object
.
keys
(
ExtensionChild
)
.
forEach
(
function
(
key
)
{
if
(
typeof
ExtensionChild
[
key
]
=
=
"
function
"
)
{
ExtensionChild
[
key
]
=
(
)
=
>
{
}
;
}
}
)
;
}
