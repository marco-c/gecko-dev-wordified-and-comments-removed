"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionStorage
"
"
resource
:
/
/
gre
/
modules
/
ExtensionStorage
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryStopwatch
"
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
)
;
var
{
ExtensionError
}
=
ExtensionUtils
;
const
storageGetHistogram
=
"
WEBEXT_STORAGE_LOCAL_GET_MS
"
;
const
storageSetHistogram
=
"
WEBEXT_STORAGE_LOCAL_SET_MS
"
;
this
.
storage
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
function
serialize
(
items
)
{
if
(
items
&
&
typeof
items
=
=
=
"
object
"
&
&
!
Array
.
isArray
(
items
)
)
{
let
result
=
{
}
;
for
(
let
[
key
value
]
of
Object
.
entries
(
items
)
)
{
try
{
result
[
key
]
=
new
StructuredCloneHolder
(
value
context
.
cloneScope
)
;
}
catch
(
e
)
{
throw
new
ExtensionError
(
String
(
e
)
)
;
}
}
return
result
;
}
return
items
;
}
function
deserialize
(
items
)
{
let
result
=
new
context
.
cloneScope
.
Object
(
)
;
for
(
let
[
key
value
]
of
Object
.
entries
(
items
)
)
{
if
(
value
&
&
typeof
value
=
=
=
"
object
"
&
&
Cu
.
getClassName
(
value
true
)
=
=
=
"
StructuredCloneHolder
"
)
{
value
=
value
.
deserialize
(
context
.
cloneScope
)
;
}
else
{
value
=
Cu
.
cloneInto
(
value
context
.
cloneScope
)
;
}
result
[
key
]
=
value
;
}
return
result
;
}
function
sanitize
(
items
)
{
if
(
typeof
items
!
=
"
object
"
|
|
items
=
=
=
null
|
|
Array
.
isArray
(
items
)
)
{
return
items
;
}
let
sanitized
=
{
}
;
for
(
let
[
key
value
]
of
Object
.
entries
(
items
)
)
{
sanitized
[
key
]
=
ExtensionStorage
.
sanitize
(
value
context
)
;
}
return
sanitized
;
}
return
{
storage
:
{
local
:
{
get
:
async
function
(
keys
)
{
const
stopwatchKey
=
{
}
;
TelemetryStopwatch
.
start
(
storageGetHistogram
stopwatchKey
)
;
try
{
let
result
=
await
context
.
childManager
.
callParentAsyncFunction
(
"
storage
.
local
.
get
"
[
serialize
(
keys
)
]
)
.
then
(
deserialize
)
;
TelemetryStopwatch
.
finish
(
storageGetHistogram
stopwatchKey
)
;
return
result
;
}
catch
(
e
)
{
TelemetryStopwatch
.
cancel
(
storageGetHistogram
stopwatchKey
)
;
throw
e
;
}
}
set
:
async
function
(
items
)
{
const
stopwatchKey
=
{
}
;
TelemetryStopwatch
.
start
(
storageSetHistogram
stopwatchKey
)
;
try
{
let
result
=
await
context
.
childManager
.
callParentAsyncFunction
(
"
storage
.
local
.
set
"
[
serialize
(
items
)
]
)
;
TelemetryStopwatch
.
finish
(
storageSetHistogram
stopwatchKey
)
;
return
result
;
}
catch
(
e
)
{
TelemetryStopwatch
.
cancel
(
storageSetHistogram
stopwatchKey
)
;
throw
e
;
}
}
}
sync
:
{
get
:
function
(
keys
)
{
keys
=
sanitize
(
keys
)
;
return
context
.
childManager
.
callParentAsyncFunction
(
"
storage
.
sync
.
get
"
[
keys
]
)
;
}
set
:
function
(
items
)
{
items
=
sanitize
(
items
)
;
return
context
.
childManager
.
callParentAsyncFunction
(
"
storage
.
sync
.
set
"
[
items
]
)
;
}
}
managed
:
{
get
(
keys
)
{
return
context
.
childManager
.
callParentAsyncFunction
(
"
storage
.
managed
.
get
"
[
serialize
(
keys
)
]
)
.
then
(
deserialize
)
;
}
set
(
items
)
{
return
Promise
.
reject
(
{
message
:
"
storage
.
managed
is
read
-
only
"
}
)
;
}
remove
(
keys
)
{
return
Promise
.
reject
(
{
message
:
"
storage
.
managed
is
read
-
only
"
}
)
;
}
clear
(
)
{
return
Promise
.
reject
(
{
message
:
"
storage
.
managed
is
read
-
only
"
}
)
;
}
}
onChanged
:
new
EventManager
(
context
"
storage
.
onChanged
"
fire
=
>
{
let
onChanged
=
(
data
area
)
=
>
{
let
changes
=
new
context
.
cloneScope
.
Object
(
)
;
for
(
let
[
key
value
]
of
Object
.
entries
(
data
)
)
{
changes
[
key
]
=
deserialize
(
value
)
;
}
fire
.
raw
(
changes
area
)
;
}
;
let
parent
=
context
.
childManager
.
getParentEvent
(
"
storage
.
onChanged
"
)
;
parent
.
addListener
(
onChanged
)
;
return
(
)
=
>
{
parent
.
removeListener
(
onChanged
)
;
}
;
}
)
.
api
(
)
}
}
;
}
}
;
