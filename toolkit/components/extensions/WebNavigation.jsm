"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
WebNavigation
"
"
WebNavigationManager
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserWindowTracker
"
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UrlbarUtils
"
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
WebNavigationFrames
"
"
resource
:
/
/
gre
/
modules
/
WebNavigationFrames
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ClickHandlerParent
"
"
resource
:
/
/
/
actors
/
ClickHandlerParent
.
jsm
"
)
;
const
RECENT_DATA_THRESHOLD
=
5
*
1000000
;
function
getBrowser
(
bc
)
{
return
bc
.
top
.
embedderElement
;
}
var
WebNavigationManager
=
{
listeners
:
new
Map
(
)
init
(
)
{
this
.
recentTabTransitionData
=
new
WeakMap
(
)
;
Services
.
obs
.
addObserver
(
this
"
urlbar
-
user
-
start
-
navigation
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
webNavigation
-
createdNavigationTarget
"
)
;
if
(
AppConstants
.
MOZ_BUILD_APP
=
=
"
browser
"
)
{
ClickHandlerParent
.
addContentClickListener
(
this
)
;
}
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
"
urlbar
-
user
-
start
-
navigation
"
)
;
Services
.
obs
.
removeObserver
(
this
"
webNavigation
-
createdNavigationTarget
"
)
;
if
(
AppConstants
.
MOZ_BUILD_APP
=
=
"
browser
"
)
{
ClickHandlerParent
.
removeContentClickListener
(
this
)
;
}
this
.
recentTabTransitionData
=
new
WeakMap
(
)
;
}
addListener
(
type
listener
filters
context
)
{
if
(
this
.
listeners
.
size
=
=
0
)
{
this
.
init
(
)
;
}
if
(
!
this
.
listeners
.
has
(
type
)
)
{
this
.
listeners
.
set
(
type
new
Map
(
)
)
;
}
let
listeners
=
this
.
listeners
.
get
(
type
)
;
listeners
.
set
(
listener
{
filters
context
}
)
;
}
removeListener
(
type
listener
)
{
let
listeners
=
this
.
listeners
.
get
(
type
)
;
if
(
!
listeners
)
{
return
;
}
listeners
.
delete
(
listener
)
;
if
(
listeners
.
size
=
=
0
)
{
this
.
listeners
.
delete
(
type
)
;
}
if
(
this
.
listeners
.
size
=
=
0
)
{
this
.
uninit
(
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
extIWebNavigation
"
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
observe
:
function
(
subject
topic
data
)
{
if
(
topic
=
=
"
urlbar
-
user
-
start
-
navigation
"
)
{
this
.
onURLBarUserStartNavigation
(
subject
.
wrappedJSObject
)
;
}
else
if
(
topic
=
=
"
webNavigation
-
createdNavigationTarget
"
)
{
const
{
createdTabBrowser
url
sourceFrameID
sourceTabBrowser
}
=
subject
.
wrappedJSObject
;
this
.
fire
(
"
onCreatedNavigationTarget
"
createdTabBrowser
null
{
sourceTabBrowser
sourceFrameId
:
sourceFrameID
url
}
)
;
}
}
onURLBarUserStartNavigation
(
acData
)
{
let
tabTransitionData
=
{
from_address_bar
:
true
}
;
if
(
!
acData
.
result
)
{
tabTransitionData
.
typed
=
true
;
}
else
{
switch
(
acData
.
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
tabTransitionData
.
keyword
=
true
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
tabTransitionData
.
generated
=
true
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
if
(
acData
.
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
{
tabTransitionData
.
auto_bookmark
=
true
;
}
else
{
tabTransitionData
.
typed
=
true
;
}
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
tabTransitionData
.
typed
=
true
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
case
UrlbarUtils
.
RESULT_TYPE
.
TIP
:
throw
new
Error
(
Unexpectedly
received
notification
for
{
acData
.
result
.
type
}
)
;
default
:
Cu
.
reportError
(
Received
unexpected
result
type
{
acData
.
result
.
type
}
falling
back
to
typed
transition
.
)
;
tabTransitionData
.
typed
=
true
;
}
}
this
.
setRecentTabTransitionData
(
tabTransitionData
)
;
}
setRecentTabTransitionData
(
tabTransitionData
)
{
let
window
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
window
&
&
window
.
gBrowser
&
&
window
.
gBrowser
.
selectedTab
&
&
window
.
gBrowser
.
selectedTab
.
linkedBrowser
)
{
let
browser
=
window
.
gBrowser
.
selectedTab
.
linkedBrowser
;
let
prevData
=
this
.
getAndForgetRecentTabTransitionData
(
browser
)
;
let
newData
=
Object
.
assign
(
{
time
:
Date
.
now
(
)
}
prevData
tabTransitionData
)
;
this
.
recentTabTransitionData
.
set
(
browser
newData
)
;
}
}
getAndForgetRecentTabTransitionData
(
browser
)
{
let
data
=
this
.
recentTabTransitionData
.
get
(
browser
)
;
this
.
recentTabTransitionData
.
delete
(
browser
)
;
if
(
!
data
|
|
data
.
time
-
Date
.
now
(
)
>
RECENT_DATA_THRESHOLD
)
{
return
{
}
;
}
return
data
;
}
onContentClick
(
target
data
)
{
if
(
data
.
href
&
&
!
data
.
bookmark
)
{
let
ownerWin
=
target
.
ownerGlobal
;
let
where
=
ownerWin
.
whereToOpenLink
(
data
)
;
if
(
where
=
=
"
current
"
)
{
this
.
setRecentTabTransitionData
(
{
link
:
true
}
)
;
}
}
}
onCreatedNavigationTarget
(
bc
sourceBC
url
)
{
if
(
!
this
.
listeners
.
size
)
{
return
;
}
let
browser
=
getBrowser
(
bc
)
;
this
.
fire
(
"
onCreatedNavigationTarget
"
browser
null
{
sourceTabBrowser
:
getBrowser
(
sourceBC
)
sourceFrameId
:
WebNavigationFrames
.
getFrameId
(
sourceBC
)
url
}
)
;
}
onStateChange
(
bc
requestURI
status
stateFlags
)
{
if
(
!
this
.
listeners
.
size
)
{
return
;
}
let
browser
=
getBrowser
(
bc
)
;
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
)
{
let
url
=
requestURI
.
spec
;
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
this
.
fire
(
"
onBeforeNavigate
"
browser
bc
{
url
}
)
;
}
else
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
if
(
Components
.
isSuccessCode
(
status
)
)
{
this
.
fire
(
"
onCompleted
"
browser
bc
{
url
}
)
;
}
else
{
let
error
=
Error
code
{
status
}
;
this
.
fire
(
"
onErrorOccurred
"
browser
bc
{
error
url
}
)
;
}
}
}
}
onDocumentChange
(
bc
frameTransitionData
location
)
{
if
(
!
this
.
listeners
.
size
)
{
return
;
}
let
browser
=
getBrowser
(
bc
)
;
let
extra
=
{
url
:
location
?
location
.
spec
:
"
"
frameTransitionData
tabTransitionData
:
this
.
getAndForgetRecentTabTransitionData
(
browser
)
}
;
this
.
fire
(
"
onCommitted
"
browser
bc
extra
)
;
}
onHistoryChange
(
bc
frameTransitionData
location
isHistoryStateUpdated
isReferenceFragmentUpdated
)
{
if
(
!
this
.
listeners
.
size
)
{
return
;
}
let
browser
=
getBrowser
(
bc
)
;
let
extra
=
{
url
:
location
?
location
.
spec
:
"
"
frameTransitionData
tabTransitionData
:
this
.
getAndForgetRecentTabTransitionData
(
browser
)
}
;
if
(
isReferenceFragmentUpdated
)
{
this
.
fire
(
"
onReferenceFragmentUpdated
"
browser
bc
extra
)
;
}
else
if
(
isHistoryStateUpdated
)
{
this
.
fire
(
"
onHistoryStateUpdated
"
browser
bc
extra
)
;
}
}
onDOMContentLoaded
(
bc
documentURI
)
{
if
(
!
this
.
listeners
.
size
)
{
return
;
}
let
browser
=
getBrowser
(
bc
)
;
this
.
fire
(
"
onDOMContentLoaded
"
browser
bc
{
url
:
documentURI
.
spec
}
)
;
}
fire
(
type
browser
bc
extra
)
{
if
(
!
browser
)
{
return
;
}
let
listeners
=
this
.
listeners
.
get
(
type
)
;
if
(
!
listeners
)
{
return
;
}
let
details
=
{
browser
}
;
if
(
bc
)
{
details
.
frameId
=
WebNavigationFrames
.
getFrameId
(
bc
)
;
details
.
parentFrameId
=
WebNavigationFrames
.
getParentFrameId
(
bc
)
;
}
for
(
let
prop
in
extra
)
{
details
[
prop
]
=
extra
[
prop
]
;
}
for
(
let
[
listener
{
filters
context
}
]
of
listeners
)
{
if
(
context
&
&
!
context
.
privateBrowsingAllowed
&
&
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
)
{
continue
;
}
if
(
!
filters
|
|
filters
.
matches
(
extra
.
url
)
)
{
listener
(
details
)
;
}
}
}
}
;
const
EVENTS
=
[
"
onBeforeNavigate
"
"
onCommitted
"
"
onDOMContentLoaded
"
"
onCompleted
"
"
onErrorOccurred
"
"
onReferenceFragmentUpdated
"
"
onHistoryStateUpdated
"
"
onCreatedNavigationTarget
"
]
;
var
WebNavigation
=
{
}
;
for
(
let
event
of
EVENTS
)
{
WebNavigation
[
event
]
=
{
addListener
:
WebNavigationManager
.
addListener
.
bind
(
WebNavigationManager
event
)
removeListener
:
WebNavigationManager
.
removeListener
.
bind
(
WebNavigationManager
event
)
}
;
}
