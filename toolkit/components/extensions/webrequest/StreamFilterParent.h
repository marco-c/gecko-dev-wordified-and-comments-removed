#
ifndef
mozilla_extensions_StreamFilterParent_h
#
define
mozilla_extensions_StreamFilterParent_h
#
include
"
StreamFilterBase
.
h
"
#
include
"
mozilla
/
extensions
/
PStreamFilterParent
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
WebRequestService
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsIThreadRetargetableStreamListener
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
if
defined
(
_MSC_VER
)
#
define
FUNC
__FUNCSIG__
#
else
#
define
FUNC
__PRETTY_FUNCTION__
#
endif
namespace
mozilla
{
namespace
dom
{
class
nsIContentParent
;
}
namespace
extensions
{
using
namespace
mozilla
:
:
dom
;
using
mozilla
:
:
ipc
:
:
IPCResult
;
class
StreamFilterParent
final
:
public
PStreamFilterParent
public
nsIStreamListener
public
nsIThreadRetargetableStreamListener
public
StreamFilterBase
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
explicit
StreamFilterParent
(
uint64_t
aChannelId
const
nsAString
&
aAddonId
)
;
enum
class
State
{
Uninitialized
Initialized
TransferringData
Suspended
Closed
Disconnecting
Disconnected
}
;
static
already_AddRefed
<
StreamFilterParent
>
Create
(
uint64_t
aChannelId
const
nsAString
&
aAddonId
)
{
RefPtr
<
StreamFilterParent
>
filter
=
new
StreamFilterParent
(
aChannelId
aAddonId
)
;
return
filter
.
forget
(
)
;
}
void
Init
(
already_AddRefed
<
nsIContentParent
>
aContentParent
)
;
protected
:
virtual
~
StreamFilterParent
(
)
;
virtual
IPCResult
RecvWrite
(
Data
&
&
aData
)
override
;
virtual
IPCResult
RecvFlushedData
(
)
override
;
virtual
IPCResult
RecvSuspend
(
)
override
;
virtual
IPCResult
RecvResume
(
)
override
;
virtual
IPCResult
RecvClose
(
)
override
;
virtual
IPCResult
RecvDisconnect
(
)
override
;
private
:
bool
IPCActive
(
)
{
return
(
mState
!
=
State
:
:
Closed
&
&
mState
!
=
State
:
:
Disconnecting
&
&
mState
!
=
State
:
:
Disconnected
)
;
}
void
DoInit
(
already_AddRefed
<
nsIContentParent
>
&
&
aContentParent
)
;
nsresult
FlushBufferedData
(
)
;
nsresult
Write
(
Data
&
aData
)
;
void
WriteMove
(
Data
&
&
aData
)
;
void
DoSendData
(
Data
&
&
aData
)
;
nsresult
EmitStopRequest
(
nsresult
aStatusCode
)
;
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
void
Broken
(
)
;
void
CheckResult
(
bool
aResult
)
{
if
(
NS_WARN_IF
(
!
aResult
)
)
{
Broken
(
)
;
}
}
void
AssertIsPBackgroundThread
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mPBackgroundThread
)
;
}
void
AssertIsIOThread
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mIOThread
)
;
}
void
AssertIsMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
template
<
typename
Function
>
void
RunOnMainThread
(
const
char
*
aName
Function
&
&
aFunc
)
{
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Network
Move
(
NS_NewRunnableFunction
(
aName
aFunc
)
)
)
;
}
template
<
typename
Function
>
void
RunOnPBackgroundThread
(
const
char
*
aName
Function
&
&
aFunc
)
{
mPBackgroundThread
-
>
Dispatch
(
Move
(
NS_NewRunnableFunction
(
aName
aFunc
)
)
NS_DISPATCH_NORMAL
)
;
}
template
<
typename
Function
>
void
RunOnIOThread
(
const
char
*
aName
Function
&
&
aFunc
)
{
mIOThread
-
>
Dispatch
(
Move
(
NS_NewRunnableFunction
(
aName
aFunc
)
)
NS_DISPATCH_NORMAL
)
;
}
const
uint64_t
mChannelId
;
const
nsCOMPtr
<
nsIAtom
>
mAddonId
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsCOMPtr
<
nsIStreamListener
>
mOrigListener
;
nsCOMPtr
<
nsIThread
>
mPBackgroundThread
;
nsCOMPtr
<
nsIThread
>
mIOThread
;
Mutex
mBufferMutex
;
bool
mReceivedStop
;
bool
mSentStop
;
nsCOMPtr
<
nsISupports
>
mContext
;
uint64_t
mOffset
;
volatile
State
mState
;
}
;
}
}
#
endif
