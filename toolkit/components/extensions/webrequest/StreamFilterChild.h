#
ifndef
mozilla_extensions_StreamFilterChild_h
#
define
mozilla_extensions_StreamFilterChild_h
#
include
"
StreamFilterBase
.
h
"
#
include
"
mozilla
/
extensions
/
PStreamFilterChild
.
h
"
#
include
"
mozilla
/
extensions
/
StreamFilter
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
dom
/
StreamFilterBinding
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
{
namespace
extensions
{
using
mozilla
:
:
dom
:
:
StreamFilterStatus
;
using
mozilla
:
:
ipc
:
:
IPCResult
;
class
StreamFilter
;
class
StreamFilterChild
final
:
public
PStreamFilterChild
public
StreamFilterBase
{
friend
class
StreamFilter
;
friend
class
PStreamFilterChild
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
StreamFilterChild
)
StreamFilterChild
(
)
:
mState
(
State
:
:
Uninitialized
)
mReceivedOnStop
(
false
)
{
}
enum
class
State
{
Uninitialized
Initialized
TransferringData
FinishedTransferringData
Suspending
Suspended
Resuming
Closing
Closed
Disconnecting
Disconnected
Error
}
;
void
Suspend
(
ErrorResult
&
aRv
)
;
void
Resume
(
ErrorResult
&
aRv
)
;
void
Disconnect
(
ErrorResult
&
aRv
)
;
void
Close
(
ErrorResult
&
aRv
)
;
void
Cleanup
(
)
;
void
Write
(
Data
&
&
aData
ErrorResult
&
aRv
)
;
State
GetState
(
)
const
{
return
mState
;
}
StreamFilterStatus
Status
(
)
const
;
void
RecvInitialized
(
bool
aSuccess
)
;
protected
:
virtual
IPCResult
RecvStartRequest
(
)
override
;
virtual
IPCResult
RecvData
(
Data
&
&
data
)
override
;
virtual
IPCResult
RecvStopRequest
(
const
nsresult
&
aStatus
)
override
;
virtual
IPCResult
RecvError
(
const
nsCString
&
aError
)
override
;
virtual
IPCResult
RecvClosed
(
)
override
;
virtual
IPCResult
RecvSuspended
(
)
override
;
virtual
IPCResult
RecvResumed
(
)
override
;
virtual
IPCResult
RecvFlushData
(
)
override
;
virtual
void
DeallocPStreamFilterChild
(
)
override
;
void
SetStreamFilter
(
StreamFilter
*
aStreamFilter
)
{
mStreamFilter
=
aStreamFilter
;
}
private
:
~
StreamFilterChild
(
)
{
}
void
SetNextState
(
)
;
void
MaybeStopRequest
(
)
;
void
EmitData
(
const
Data
&
aData
)
;
bool
CanFlushData
(
)
{
return
(
mState
=
=
State
:
:
TransferringData
|
|
mState
=
=
State
:
:
Resuming
)
;
}
void
FlushBufferedData
(
)
;
void
WriteBufferedData
(
)
;
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
State
mState
;
State
mNextState
;
bool
mReceivedOnStop
;
RefPtr
<
StreamFilter
>
mStreamFilter
;
}
;
}
}
#
endif
