"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
NativeManifests
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
Schemas
:
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
WindowsRegistry
:
"
resource
:
/
/
gre
/
modules
/
WindowsRegistry
.
jsm
"
}
)
;
const
DASHED
=
AppConstants
.
platform
=
=
=
"
linux
"
;
const
TYPES
=
{
stdio
:
DASHED
?
"
native
-
messaging
-
hosts
"
:
"
NativeMessagingHosts
"
storage
:
DASHED
?
"
managed
-
storage
"
:
"
ManagedStorage
"
pkcs11
:
DASHED
?
"
pkcs11
-
modules
"
:
"
PKCS11Modules
"
}
;
const
NATIVE_MANIFEST_SCHEMA
=
"
chrome
:
/
/
extensions
/
content
/
schemas
/
native_manifest
.
json
"
;
const
REGPATH
=
"
Software
\
\
Mozilla
"
;
this
.
NativeManifests
=
{
_initializePromise
:
null
_lookup
:
null
init
(
)
{
if
(
!
this
.
_initializePromise
)
{
let
platform
=
AppConstants
.
platform
;
if
(
platform
=
=
"
win
"
)
{
this
.
_lookup
=
this
.
_winLookup
;
}
else
if
(
platform
=
=
"
macosx
"
|
|
platform
=
=
"
linux
"
)
{
let
dirs
=
[
Services
.
dirsvc
.
get
(
"
XREUserNativeManifests
"
Ci
.
nsIFile
)
.
path
Services
.
dirsvc
.
get
(
"
XRESysNativeManifests
"
Ci
.
nsIFile
)
.
path
]
;
this
.
_lookup
=
(
type
name
context
)
=
>
this
.
_tryPaths
(
type
name
dirs
context
)
;
}
else
{
throw
new
Error
(
Native
manifests
are
not
supported
on
{
AppConstants
.
platform
}
)
;
}
this
.
_initializePromise
=
Schemas
.
load
(
NATIVE_MANIFEST_SCHEMA
)
;
}
return
this
.
_initializePromise
;
}
_winLookup
(
type
name
context
)
{
const
REGISTRY
=
Ci
.
nsIWindowsRegKey
;
let
regPath
=
{
REGPATH
}
\
\
{
TYPES
[
type
]
}
\
\
{
name
}
;
let
path
=
WindowsRegistry
.
readRegKey
(
REGISTRY
.
ROOT_KEY_CURRENT_USER
regPath
"
"
REGISTRY
.
WOW64_64
)
;
if
(
!
path
)
{
path
=
WindowsRegistry
.
readRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_LOCAL_MACHINE
regPath
"
"
REGISTRY
.
WOW64_64
)
;
}
if
(
!
path
)
{
return
null
;
}
return
this
.
_tryPath
(
type
path
name
context
)
.
then
(
manifest
=
>
manifest
?
{
path
manifest
}
:
null
)
;
}
_tryPath
(
type
path
name
context
)
{
return
Promise
.
resolve
(
)
.
then
(
(
)
=
>
OS
.
File
.
read
(
path
{
encoding
:
"
utf
-
8
"
}
)
)
.
then
(
data
=
>
{
let
manifest
;
try
{
manifest
=
JSON
.
parse
(
data
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Error
parsing
native
manifest
{
path
}
:
{
ex
.
message
}
)
;
return
null
;
}
let
normalized
=
Schemas
.
normalize
(
manifest
"
manifest
.
NativeManifest
"
context
)
;
if
(
normalized
.
error
)
{
Cu
.
reportError
(
normalized
.
error
)
;
return
null
;
}
manifest
=
normalized
.
value
;
if
(
manifest
.
type
!
=
=
type
)
{
Cu
.
reportError
(
Native
manifest
{
path
}
has
type
property
{
manifest
.
type
}
(
expected
{
type
}
)
)
;
return
null
;
}
if
(
manifest
.
name
!
=
=
name
)
{
Cu
.
reportError
(
Native
manifest
{
path
}
has
name
property
{
manifest
.
name
}
(
expected
{
name
}
)
)
;
return
null
;
}
if
(
manifest
.
allowed_extensions
&
&
!
manifest
.
allowed_extensions
.
includes
(
context
.
extension
.
id
)
)
{
Cu
.
reportError
(
This
extension
does
not
have
permission
to
use
native
manifest
{
path
}
)
;
return
null
;
}
return
manifest
;
}
)
.
catch
(
ex
=
>
{
if
(
ex
instanceof
OS
.
File
.
Error
&
&
ex
.
becauseNoSuchFile
)
{
return
null
;
}
throw
ex
;
}
)
;
}
async
_tryPaths
(
type
name
dirs
context
)
{
for
(
let
dir
of
dirs
)
{
let
path
=
OS
.
Path
.
join
(
dir
TYPES
[
type
]
{
name
}
.
json
)
;
let
manifest
=
await
this
.
_tryPath
(
type
path
name
context
)
;
if
(
manifest
)
{
return
{
path
manifest
}
;
}
}
return
null
;
}
lookupManifest
(
type
name
context
)
{
return
this
.
init
(
)
.
then
(
(
)
=
>
this
.
_lookup
(
type
name
context
)
)
;
}
}
;
