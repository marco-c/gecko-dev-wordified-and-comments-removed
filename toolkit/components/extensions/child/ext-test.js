"
use
strict
"
;
ChromeUtils
.
defineLazyGetter
(
this
"
isXpcshell
"
function
(
)
{
return
Services
.
env
.
exists
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
;
}
)
;
const
errorMatches
=
(
error
expectedError
context
)
=
>
{
if
(
typeof
error
=
=
=
"
object
"
&
&
error
!
=
=
null
&
&
!
context
.
principal
.
subsumes
(
Cu
.
getObjectPrincipal
(
error
)
)
)
{
Cu
.
reportError
(
"
Error
object
belongs
to
the
wrong
scope
.
"
)
;
return
false
;
}
if
(
typeof
expectedError
=
=
=
"
function
"
)
{
return
context
.
runSafeWithoutClone
(
expectedError
error
)
;
}
if
(
typeof
error
!
=
=
"
object
"
|
|
error
=
=
null
|
|
typeof
error
.
message
!
=
=
"
string
"
)
{
return
false
;
}
if
(
typeof
expectedError
=
=
=
"
string
"
)
{
return
error
.
message
=
=
=
expectedError
;
}
try
{
return
expectedError
.
test
(
error
.
message
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
false
;
}
;
function
useStringInsteadOfJSON
(
v
)
{
return
(
v
=
=
=
undefined
|
|
(
typeof
v
=
=
=
"
number
"
&
&
(
isNaN
(
v
)
|
|
!
isFinite
(
v
)
)
)
)
;
}
function
deepEquals
(
a
b
)
{
const
NON_JSON_PREFIX
=
"
#
NOT_JSON_SERIALIZABLE
#
"
;
function
replacer
(
key
value
)
{
if
(
typeof
value
=
=
"
object
"
&
&
value
!
=
=
null
&
&
!
Array
.
isArray
(
value
)
)
{
const
cls
=
ChromeUtils
.
getClassName
(
value
)
;
if
(
cls
=
=
=
"
Object
"
)
{
return
Object
.
fromEntries
(
Object
.
keys
(
value
)
.
sort
(
)
.
map
(
k
=
>
[
k
value
[
k
]
]
)
)
;
}
throw
new
ExtensionUtils
.
ExtensionError
(
Unsupported
obj
type
:
{
cls
}
)
;
}
if
(
useStringInsteadOfJSON
(
value
)
)
{
return
{
NON_JSON_PREFIX
}
{
value
}
;
}
return
value
;
}
return
JSON
.
stringify
(
a
replacer
)
=
=
=
JSON
.
stringify
(
b
replacer
)
;
}
const
toSource
=
value
=
>
{
function
cannotJSONserialize
(
v
)
{
return
(
useStringInsteadOfJSON
(
v
)
|
|
(
typeof
v
=
=
"
object
"
&
&
v
!
=
=
null
&
&
!
Array
.
isArray
(
v
)
&
&
ChromeUtils
.
getClassName
(
v
)
!
=
=
"
Object
"
)
)
;
}
try
{
if
(
cannotJSONserialize
(
value
)
)
{
return
String
(
value
)
;
}
const
replacer
=
(
k
v
)
=
>
(
cannotJSONserialize
(
v
)
?
String
(
v
)
:
v
)
;
return
JSON
.
stringify
(
value
replacer
)
;
}
catch
(
e
)
{
return
"
<
unknown
>
"
;
}
}
;
this
.
test
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
const
CONTEXT_DESTROYED
=
"
Test
context
destroyed
.
"
;
const
{
extension
}
=
context
;
let
running
=
false
;
let
testTasks
=
[
]
;
let
lastError
=
null
;
let
unnamed
=
0
;
async
function
runTasks
(
tests
)
{
testTasks
.
push
(
.
.
.
tests
)
;
if
(
running
)
{
return
;
}
let
onClosed
=
Promise
.
withResolvers
(
)
;
onClosed
.
close
=
(
)
=
>
onClosed
.
reject
(
CONTEXT_DESTROYED
)
;
context
.
callOnClose
(
onClosed
)
;
try
{
running
=
true
;
while
(
testTasks
.
length
)
{
let
task
=
testTasks
.
shift
(
)
;
let
name
=
task
.
name
|
|
unnamed_test_
{
+
+
unnamed
}
;
let
stack
=
getStack
(
context
.
getCaller
(
)
)
;
extension
.
emit
(
"
test
-
task
-
start
"
name
stack
)
;
lastError
=
null
;
try
{
await
Promise
.
race
(
[
task
(
)
onClosed
.
promise
]
)
;
if
(
!
context
.
active
)
{
assertTrue
(
false
CONTEXT_DESTROYED
)
;
throw
new
ExtensionUtils
.
ExtensionError
(
CONTEXT_DESTROYED
)
;
}
}
catch
(
e
)
{
lastError
=
Exception
running
{
name
}
:
{
e
.
message
}
;
Cu
.
reportError
(
lastError
)
;
}
finally
{
extension
.
emit
(
"
test
-
task
-
done
"
testTasks
.
length
name
!
lastError
lastError
?
?
{
name
}
PASS
stack
)
;
}
}
}
finally
{
context
.
forgetOnClose
(
onClosed
)
;
testTasks
.
length
=
0
;
running
=
false
;
}
}
function
getStack
(
savedFrame
=
null
)
{
if
(
savedFrame
)
{
return
ChromeUtils
.
createError
(
"
"
savedFrame
)
.
stack
.
replace
(
/
^
/
gm
"
"
)
;
}
return
new
context
.
Error
(
)
.
stack
.
replace
(
/
^
/
gm
"
"
)
;
}
function
assertTrue
(
value
msg
)
{
msg
=
msg
?
?
Assertion
{
value
?
"
PASS
"
:
"
FAIL
"
}
;
extension
.
emit
(
"
test
-
result
"
Boolean
(
value
)
String
(
msg
)
getStack
(
context
.
getCaller
(
)
)
)
;
if
(
!
value
)
{
lastError
=
msg
;
}
}
function
assertEq
(
eq
msg
expected
actual
)
{
let
stack
=
getStack
(
context
.
getCaller
(
)
)
;
extension
.
emit
(
"
test
-
eq
"
eq
String
(
msg
)
expected
actual
stack
)
;
if
(
!
eq
)
{
lastError
=
{
msg
}
-
Expected
:
{
expected
}
Actual
:
{
actual
}
;
}
}
class
TestEventManager
extends
EventManager
{
constructor
(
.
.
.
args
)
{
super
(
.
.
.
args
)
;
this
.
_listenerWrappers
=
new
Map
(
)
;
context
.
callOnClose
(
{
close
:
(
)
=
>
this
.
_listenerWrappers
.
clear
(
)
}
)
;
}
addListener
(
callback
.
.
.
args
)
{
const
listenerWrapper
=
function
(
.
.
.
args
)
{
try
{
callback
.
call
(
this
.
.
.
args
)
;
}
catch
(
e
)
{
assertTrue
(
false
{
e
}
\
n
{
e
.
stack
}
)
;
}
}
;
super
.
addListener
(
listenerWrapper
.
.
.
args
)
;
this
.
_listenerWrappers
.
set
(
callback
listenerWrapper
)
;
}
removeListener
(
callback
)
{
if
(
!
this
.
_listenerWrappers
.
has
(
callback
)
)
{
return
;
}
super
.
removeListener
(
this
.
_listenerWrappers
.
get
(
callback
)
)
;
this
.
_listenerWrappers
.
delete
(
callback
)
;
}
}
if
(
!
Cu
.
isInAutomation
&
&
!
isXpcshell
)
{
return
{
test
:
{
}
}
;
}
return
{
test
:
{
withHandlingUserInput
(
callback
)
{
if
(
!
Cu
.
isInAutomation
)
{
throw
new
ExtensionUtils
.
ExtensionError
(
"
withHandlingUserInput
can
only
be
called
in
automation
"
)
;
}
ExtensionCommon
.
withHandlingUserInput
(
context
.
contentWindow
callback
)
;
}
sendMessage
(
.
.
.
args
)
{
extension
.
emit
(
"
test
-
message
"
.
.
.
args
)
;
}
notifyPass
(
msg
)
{
extension
.
emit
(
"
test
-
done
"
true
msg
getStack
(
context
.
getCaller
(
)
)
)
;
}
notifyFail
(
msg
)
{
extension
.
emit
(
"
test
-
done
"
false
msg
getStack
(
context
.
getCaller
(
)
)
)
;
}
log
(
msg
)
{
extension
.
emit
(
"
test
-
log
"
true
msg
getStack
(
context
.
getCaller
(
)
)
)
;
}
fail
(
msg
)
{
assertTrue
(
false
msg
)
;
}
succeed
(
msg
)
{
assertTrue
(
true
msg
)
;
}
assertTrue
(
value
msg
)
{
assertTrue
(
value
msg
)
;
}
assertFalse
(
value
msg
)
{
assertTrue
(
!
value
msg
)
;
}
assertDeepEq
(
expected
actual
msg
)
{
function
ensureStructurallyCloneable
(
v
)
{
if
(
typeof
v
=
=
"
object
"
&
&
v
!
=
=
null
)
{
v
=
ChromeUtils
.
waiveXrays
(
v
)
;
}
new
StructuredCloneHolder
(
"
test
.
assertEq
"
null
v
globalThis
)
;
}
if
(
!
context
.
useWebIDLBindings
)
{
ensureStructurallyCloneable
(
expected
)
;
ensureStructurallyCloneable
(
actual
)
;
}
let
eq
=
deepEquals
(
actual
expected
)
;
assertEq
(
eq
msg
toSource
(
expected
)
toSource
(
actual
)
)
;
}
assertEq
(
expected
actual
msg
)
{
let
equal
=
expected
=
=
=
actual
;
expected
=
String
(
expected
)
;
actual
=
String
(
actual
)
;
if
(
!
equal
&
&
expected
=
=
=
actual
)
{
actual
+
=
"
(
different
)
"
;
}
assertEq
(
equal
msg
expected
actual
)
;
}
assertRejects
(
promise
expectedError
msg
)
{
promise
=
Promise
.
resolve
(
promise
)
;
return
promise
.
then
(
(
)
=
>
{
let
message
=
Promise
resolved
expected
rejection
'
{
toSource
(
expectedError
)
}
'
;
if
(
msg
)
{
message
+
=
:
{
msg
}
;
}
assertTrue
(
false
message
)
;
}
error
=
>
{
let
expected
=
toSource
(
expectedError
)
;
let
message
=
got
'
{
toSource
(
error
)
}
'
;
if
(
msg
)
{
message
+
=
:
{
msg
}
;
}
assertTrue
(
errorMatches
(
error
expectedError
context
)
Promise
rejected
expecting
rejection
to
match
'
{
expected
}
'
{
message
}
)
;
}
)
;
}
assertThrows
(
func
expectedError
msg
)
{
if
(
!
expectedError
)
{
if
(
ExtensionCommon
.
isInWPT
)
{
expectedError
=
/
.
*
/
;
}
else
{
throw
new
ExtensionUtils
.
ExtensionError
(
"
Missing
required
expectedError
"
)
;
}
}
try
{
func
(
)
;
let
message
=
Function
did
not
throw
expected
error
'
{
toSource
(
expectedError
)
}
'
;
if
(
msg
)
{
message
+
=
:
{
msg
}
;
}
assertTrue
(
false
message
)
;
}
catch
(
error
)
{
let
expected
=
toSource
(
expectedError
)
;
let
message
=
got
'
{
toSource
(
error
)
}
'
;
if
(
msg
)
{
message
+
=
:
{
msg
}
;
}
assertTrue
(
errorMatches
(
error
expectedError
context
)
Function
threw
expecting
error
to
match
'
{
expected
}
'
{
message
}
)
;
}
}
runTests
(
tests
)
{
return
runTasks
(
tests
)
;
}
onMessage
:
new
TestEventManager
(
{
context
name
:
"
test
.
onMessage
"
resetIdleOnEvent
:
true
register
:
fire
=
>
{
let
handler
=
(
event
.
.
.
args
)
=
>
{
fire
.
async
(
.
.
.
args
)
;
}
;
extension
.
on
(
"
test
-
harness
-
message
"
handler
)
;
return
(
)
=
>
{
extension
.
off
(
"
test
-
harness
-
message
"
handler
)
;
}
;
}
}
)
.
api
(
)
}
}
;
}
}
;
