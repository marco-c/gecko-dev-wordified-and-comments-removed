"
use
strict
"
;
var
USERSCRIPT_PREFNAME
=
"
extensions
.
webextensions
.
userScripts
.
enabled
"
;
var
USERSCRIPT_DISABLED_ERRORMSG
=
userScripts
APIs
are
currently
experimental
and
must
be
enabled
with
the
{
USERSCRIPT_PREFNAME
}
preference
.
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
userScriptsEnabled
"
USERSCRIPT_PREFNAME
false
)
;
Cu
.
importGlobalProperties
(
[
"
crypto
"
"
TextEncoder
"
]
)
;
var
{
DefaultMap
ExtensionError
getUniqueId
}
=
ExtensionUtils
;
class
UserScriptChild
{
constructor
(
{
context
scriptId
onScriptUnregister
}
)
{
this
.
context
=
context
;
this
.
scriptId
=
scriptId
;
this
.
onScriptUnregister
=
onScriptUnregister
;
this
.
unregistered
=
false
;
}
async
unregister
(
)
{
if
(
this
.
unregistered
)
{
throw
new
ExtensionError
(
"
User
script
already
unregistered
"
)
;
}
this
.
unregistered
=
true
;
await
this
.
context
.
childManager
.
callParentAsyncFunction
(
"
userScripts
.
unregister
"
[
this
.
scriptId
]
)
;
this
.
context
=
null
;
this
.
onScriptUnregister
(
)
;
}
api
(
)
{
const
{
context
}
=
this
;
return
{
unregister
:
(
)
=
>
{
return
context
.
wrapPromise
(
this
.
unregister
(
)
)
;
}
}
;
}
}
this
.
userScripts
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
if
(
context
.
extension
.
manifestVersion
!
=
=
2
)
{
return
{
}
;
}
const
blobURLsByHash
=
new
Map
(
)
;
const
userScriptsByBlobURL
=
new
DefaultMap
(
(
)
=
>
new
Set
(
)
)
;
function
revokeBlobURLs
(
scriptId
options
)
{
let
revokedUrls
=
new
Set
(
)
;
for
(
let
url
of
options
.
js
)
{
if
(
userScriptsByBlobURL
.
has
(
url
)
)
{
let
scriptIds
=
userScriptsByBlobURL
.
get
(
url
)
;
scriptIds
.
delete
(
scriptId
)
;
if
(
scriptIds
.
size
=
=
=
0
)
{
revokedUrls
.
add
(
url
)
;
userScriptsByBlobURL
.
delete
(
url
)
;
context
.
cloneScope
.
URL
.
revokeObjectURL
(
url
)
;
}
}
}
for
(
let
[
hash
url
]
of
blobURLsByHash
)
{
if
(
revokedUrls
.
has
(
url
)
)
{
blobURLsByHash
.
delete
(
hash
)
;
}
}
}
const
getBlobURL
=
async
(
text
scriptId
)
=
>
{
const
buffer
=
await
crypto
.
subtle
.
digest
(
"
SHA
-
1
"
new
TextEncoder
(
)
.
encode
(
text
)
)
;
const
hash
=
String
.
fromCharCode
(
.
.
.
new
Uint16Array
(
buffer
)
)
;
let
blobURL
=
blobURLsByHash
.
get
(
hash
)
;
if
(
blobURL
)
{
userScriptsByBlobURL
.
get
(
blobURL
)
.
add
(
scriptId
)
;
return
blobURL
;
}
const
blob
=
new
context
.
cloneScope
.
Blob
(
[
text
]
{
type
:
"
text
/
javascript
"
}
)
;
blobURL
=
context
.
cloneScope
.
URL
.
createObjectURL
(
blob
)
;
userScriptsByBlobURL
.
get
(
blobURL
)
.
add
(
scriptId
)
;
blobURLsByHash
.
set
(
hash
blobURL
)
;
return
blobURL
;
}
;
function
convertToAPIObject
(
scriptId
options
)
{
const
registeredScript
=
new
UserScriptChild
(
{
context
scriptId
onScriptUnregister
:
(
)
=
>
revokeBlobURLs
(
scriptId
options
)
}
)
;
const
scriptAPI
=
Cu
.
cloneInto
(
registeredScript
.
api
(
)
context
.
cloneScope
{
cloneFunctions
:
true
}
)
;
return
scriptAPI
;
}
context
.
callOnClose
(
{
close
(
)
{
if
(
!
context
.
cloneScope
)
{
return
;
}
for
(
let
blobURL
of
blobURLsByHash
.
values
(
)
)
{
context
.
cloneScope
.
URL
.
revokeObjectURL
(
blobURL
)
;
}
}
}
)
;
return
{
userScripts
:
{
register
(
options
)
{
if
(
!
userScriptsEnabled
)
{
throw
new
ExtensionError
(
USERSCRIPT_DISABLED_ERRORMSG
)
;
}
let
scriptId
=
getUniqueId
(
)
;
return
context
.
cloneScope
.
Promise
.
resolve
(
)
.
then
(
async
(
)
=
>
{
options
.
scriptId
=
scriptId
;
options
.
js
=
await
Promise
.
all
(
options
.
js
.
map
(
js
=
>
{
return
js
.
file
|
|
getBlobURL
(
js
.
code
scriptId
)
;
}
)
)
;
await
context
.
childManager
.
callParentAsyncFunction
(
"
userScripts
.
register
"
[
options
]
)
;
return
convertToAPIObject
(
scriptId
options
)
;
}
)
;
}
}
}
;
}
}
;
