"
use
strict
"
;
var
{
Constructor
:
CC
}
=
Components
;
ChromeUtils
.
defineModuleGetter
(
this
"
CommonUtils
"
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
redirectDomain
"
"
extensions
.
webextensions
.
identity
.
redirectDomain
"
)
;
let
CryptoHash
=
CC
(
"
mozilla
.
org
/
security
/
hash
;
1
"
"
nsICryptoHash
"
"
initWithString
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
"
TextEncoder
"
]
)
;
const
computeHash
=
str
=
>
{
let
byteArr
=
new
TextEncoder
(
)
.
encode
(
str
)
;
let
hash
=
new
CryptoHash
(
"
sha1
"
)
;
hash
.
update
(
byteArr
byteArr
.
length
)
;
return
CommonUtils
.
bytesAsHex
(
hash
.
finish
(
false
)
)
;
}
;
this
.
identity
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
let
{
extension
}
=
context
;
return
{
identity
:
{
getRedirectURL
:
function
(
path
=
"
"
)
{
let
hash
=
computeHash
(
extension
.
id
)
;
let
url
=
new
URL
(
https
:
/
/
{
hash
}
.
{
redirectDomain
}
/
)
;
url
.
pathname
=
path
;
return
url
.
href
;
}
launchWebAuthFlow
:
function
(
details
)
{
let
url
redirectURI
;
let
baseRedirectURL
=
this
.
getRedirectURL
(
)
;
let
loopbackURL
=
http
:
/
/
127
.
0
.
0
.
1
/
mozoauth2
/
{
computeHash
(
extension
.
id
)
}
;
try
{
url
=
new
URL
(
details
.
url
)
;
}
catch
(
e
)
{
return
Promise
.
reject
(
{
message
:
"
details
.
url
is
invalid
"
}
)
;
}
try
{
redirectURI
=
new
URL
(
url
.
searchParams
.
get
(
"
redirect_uri
"
)
|
|
baseRedirectURL
)
;
if
(
!
redirectURI
.
href
.
startsWith
(
baseRedirectURL
)
&
&
!
redirectURI
.
href
.
startsWith
(
loopbackURL
)
)
{
return
Promise
.
reject
(
{
message
:
"
redirect_uri
not
allowed
"
}
)
;
}
}
catch
(
e
)
{
return
Promise
.
reject
(
{
message
:
"
redirect_uri
is
invalid
"
}
)
;
}
return
context
.
childManager
.
callParentAsyncFunction
(
"
identity
.
launchWebAuthFlowInParent
"
[
details
redirectURI
.
href
]
)
;
}
}
}
;
}
}
;
