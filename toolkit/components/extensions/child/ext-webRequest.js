"
use
strict
"
;
var
{
ExtensionError
}
=
ExtensionUtils
;
this
.
webRequest
=
class
extends
ExtensionAPI
{
STREAM_FILTER_INACTIVE_STATUSES
=
[
"
closed
"
"
disconnected
"
"
failed
"
]
;
hasActiveStreamFilter
(
filtersWeakSet
)
{
const
iter
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
filtersWeakSet
)
;
for
(
let
filter
of
iter
)
{
if
(
!
this
.
STREAM_FILTER_INACTIVE_STATUSES
.
includes
(
filter
.
status
)
)
{
return
true
;
}
}
return
false
;
}
watchStreamFilterSuspendCancel
(
{
context
filters
onSuspend
onSuspendCanceled
}
)
{
if
(
!
context
.
isBackgroundContext
|
|
context
.
extension
.
persistentBackground
!
=
=
false
)
{
return
;
}
const
{
extension
}
=
context
;
const
cancelSuspendOnActiveStreamFilter
=
(
)
=
>
this
.
hasActiveStreamFilter
(
filters
)
;
context
.
callOnClose
(
{
close
(
)
{
extension
.
off
(
"
internal
:
stream
-
filter
-
suspend
-
cancel
"
cancelSuspendOnActiveStreamFilter
)
;
extension
.
off
(
"
background
-
script
-
suspend
"
onSuspend
)
;
extension
.
off
(
"
background
-
script
-
suspend
-
canceled
"
onSuspend
)
;
}
}
)
;
extension
.
on
(
"
internal
:
stream
-
filter
-
suspend
-
cancel
"
cancelSuspendOnActiveStreamFilter
)
;
extension
.
on
(
"
background
-
script
-
suspend
"
onSuspend
)
;
extension
.
on
(
"
background
-
script
-
suspend
-
canceled
"
onSuspendCanceled
)
;
}
getAPI
(
context
)
{
let
filters
=
new
WeakSet
(
)
;
context
.
callOnClose
(
{
close
(
)
{
for
(
let
filter
of
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
filters
)
)
{
try
{
filter
.
disconnect
(
)
;
}
catch
(
e
)
{
}
}
}
}
)
;
let
isSuspending
=
false
;
this
.
watchStreamFilterSuspendCancel
(
{
context
filters
onSuspend
:
(
)
=
>
(
isSuspending
=
true
)
onSuspendCanceled
:
(
)
=
>
(
isSuspending
=
false
)
}
)
;
function
filterResponseData
(
requestId
)
{
if
(
isSuspending
)
{
throw
new
ExtensionError
(
"
filterResponseData
method
calls
forbidden
while
background
extension
global
is
suspending
"
)
;
}
requestId
=
parseInt
(
requestId
10
)
;
let
streamFilter
=
context
.
cloneScope
.
StreamFilter
.
create
(
requestId
context
.
extension
.
id
)
;
filters
.
add
(
streamFilter
)
;
return
streamFilter
;
}
const
webRequest
=
{
onAuthRequired
:
new
EventManager
(
{
context
name
:
"
webRequest
.
onAuthRequired
"
resetIdleOnEvent
:
false
register
:
(
fire
filter
extra
)
=
>
{
const
listener
=
details
=
>
{
if
(
!
extra
.
includes
(
"
asyncBlocking
"
)
)
{
return
fire
.
raw
(
details
)
;
}
let
asyncCallback
;
const
promise
=
new
Promise
(
resolve
=
>
{
asyncCallback
=
Cu
.
exportFunction
(
value
=
>
{
resolve
(
value
)
;
}
context
.
cloneScope
)
;
}
)
;
fire
.
raw
(
details
asyncCallback
)
;
return
promise
;
}
;
const
parentEvent
=
context
.
childManager
.
getParentEvent
(
"
webRequest
.
onAuthRequired
"
)
;
parentEvent
.
addListener
(
listener
filter
extra
)
;
return
(
)
=
>
{
parentEvent
.
removeListener
(
listener
)
;
}
;
}
}
)
.
api
(
)
}
;
if
(
context
.
extension
.
manifestVersion
<
3
|
|
context
.
extension
.
hasPermission
(
"
webRequestFilterResponse
"
)
)
{
webRequest
.
filterResponseData
=
filterResponseData
;
}
else
{
webRequest
.
filterResponseData
=
(
)
=
>
{
throw
new
ExtensionError
(
'
Missing
required
"
webRequestFilterResponse
"
permission
'
)
;
}
;
}
return
{
webRequest
}
;
}
}
;
