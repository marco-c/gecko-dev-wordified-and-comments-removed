"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
Extension
"
"
ExtensionData
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
Cu
.
importGlobalProperties
(
[
"
TextEncoder
"
]
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionAPIs
"
"
resource
:
/
/
gre
/
modules
/
ExtensionAPI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionStorage
"
"
resource
:
/
/
gre
/
modules
/
ExtensionStorage
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Locale
"
"
resource
:
/
/
gre
/
modules
/
Locale
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MatchGlobs
"
"
resource
:
/
/
gre
/
modules
/
MatchPattern
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MatchPattern
"
"
resource
:
/
/
gre
/
modules
/
MatchPattern
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MessageChannel
"
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
require
"
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Schemas
"
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionContent
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionManagement
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
uuidGen
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
const
BASE_SCHEMA
=
"
chrome
:
/
/
extensions
/
content
/
schemas
/
manifest
.
json
"
;
const
CATEGORY_EXTENSION_SCHEMAS
=
"
webextension
-
schemas
"
;
const
CATEGORY_EXTENSION_SCRIPTS
=
"
webextension
-
scripts
"
;
let
schemaURLs
=
new
Set
(
)
;
if
(
!
AppConstants
.
RELEASE_OR_BETA
)
{
schemaURLs
.
add
(
"
chrome
:
/
/
extensions
/
content
/
schemas
/
experiments
.
json
"
)
;
}
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
BaseContext
EventEmitter
SchemaAPIManager
LocaleData
instanceOf
LocalAPIImplementation
flushJarCache
}
=
ExtensionUtils
;
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
ExtensionUtils
.
getConsole
)
;
const
LOGGER_ID_BASE
=
"
addons
.
webextension
.
"
;
const
UUID_MAP_PREF
=
"
extensions
.
webextensions
.
uuids
"
;
const
LEAVE_STORAGE_PREF
=
"
extensions
.
webextensions
.
keepStorageOnUninstall
"
;
const
LEAVE_UUID_PREF
=
"
extensions
.
webextensions
.
keepUuidOnUninstall
"
;
const
COMMENT_REGEXP
=
new
RegExp
(
String
.
raw
^
(
(
?
:
[
^
"
\
n
]
|
"
(
?
:
[
^
"
\
\
\
n
]
|
\
\
.
)
*
"
)
*
?
)
/
/
.
*
.
replace
(
/
\
s
+
/
g
"
"
)
"
gm
"
)
;
var
GlobalManager
;
var
Management
=
new
class
extends
SchemaAPIManager
{
constructor
(
)
{
super
(
"
main
"
)
;
this
.
initialized
=
null
;
}
lazyInit
(
)
{
if
(
this
.
initialized
)
{
return
this
.
initialized
;
}
let
promise
=
Schemas
.
load
(
BASE_SCHEMA
)
.
then
(
(
)
=
>
{
let
promises
=
[
]
;
for
(
let
[
url
]
of
XPCOMUtils
.
enumerateCategoryEntries
(
CATEGORY_EXTENSION_SCHEMAS
)
)
{
promises
.
push
(
Schemas
.
load
(
url
)
)
;
}
for
(
let
url
of
schemaURLs
)
{
promises
.
push
(
Schemas
.
load
(
url
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
)
;
for
(
let
[
value
]
of
XPCOMUtils
.
enumerateCategoryEntries
(
CATEGORY_EXTENSION_SCRIPTS
)
)
{
this
.
loadScript
(
value
)
;
}
this
.
initialized
=
promise
;
return
this
.
initialized
;
}
registerSchemaAPI
(
namespace
envType
getAPI
)
{
if
(
envType
=
=
"
addon_parent
"
|
|
envType
=
=
"
content_parent
"
)
{
super
.
registerSchemaAPI
(
namespace
envType
getAPI
)
;
}
}
}
(
)
;
let
ProxyMessenger
=
{
_initialized
:
false
init
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
let
pipmm
=
Services
.
ppmm
.
getChildAt
(
0
)
;
let
messageManagers
=
[
Services
.
mm
pipmm
]
;
MessageChannel
.
addListener
(
messageManagers
"
Extension
:
Connect
"
this
)
;
MessageChannel
.
addListener
(
messageManagers
"
Extension
:
Message
"
this
)
;
MessageChannel
.
addListener
(
messageManagers
"
Extension
:
Port
:
Disconnect
"
this
)
;
MessageChannel
.
addListener
(
messageManagers
"
Extension
:
Port
:
PostMessage
"
this
)
;
}
receiveMessage
(
{
target
messageName
channelId
sender
recipient
data
responseType
}
)
{
let
extension
=
GlobalManager
.
extensionMap
.
get
(
sender
.
extensionId
)
;
let
receiverMM
=
this
.
_getMessageManagerForRecipient
(
recipient
)
;
if
(
!
extension
|
|
!
receiverMM
)
{
return
Promise
.
reject
(
{
result
:
MessageChannel
.
RESULT_NO_HANDLER
message
:
"
No
matching
message
handler
for
the
given
recipient
.
"
}
)
;
}
if
(
(
messageName
=
=
"
Extension
:
Message
"
|
|
messageName
=
=
"
Extension
:
Connect
"
)
&
&
Management
.
global
.
tabGetSender
)
{
Management
.
global
.
tabGetSender
(
extension
target
sender
)
;
}
return
MessageChannel
.
sendMessage
(
receiverMM
messageName
data
{
sender
recipient
responseType
}
)
;
}
_getMessageManagerForRecipient
(
recipient
)
{
let
{
extensionId
tabId
}
=
recipient
;
if
(
tabId
)
{
let
tab
=
Management
.
global
.
TabManager
.
getTab
(
tabId
null
null
)
;
return
tab
&
&
tab
.
linkedBrowser
.
messageManager
;
}
if
(
extensionId
)
{
let
pipmm
=
Services
.
ppmm
.
getChildAt
(
0
)
;
return
pipmm
;
}
return
null
;
}
}
;
class
ProxyContext
extends
BaseContext
{
constructor
(
envType
extension
params
messageManager
principal
)
{
super
(
envType
extension
)
;
this
.
uri
=
NetUtil
.
newURI
(
params
.
url
)
;
this
.
messageManager
=
messageManager
;
this
.
principal_
=
principal
;
this
.
apiObj
=
{
}
;
GlobalManager
.
injectInObject
(
this
false
this
.
apiObj
)
;
this
.
listenerProxies
=
new
Map
(
)
;
this
.
sandbox
=
Cu
.
Sandbox
(
principal
{
}
)
;
Management
.
emit
(
"
proxy
-
context
-
load
"
this
)
;
}
get
principal
(
)
{
return
this
.
principal_
;
}
get
cloneScope
(
)
{
return
this
.
sandbox
;
}
shutdown
(
)
{
this
.
unload
(
)
;
}
unload
(
)
{
if
(
this
.
unloaded
)
{
return
;
}
super
.
unload
(
)
;
Management
.
emit
(
"
proxy
-
context
-
unload
"
this
)
;
}
}
class
ExtensionChildProxyContext
extends
ProxyContext
{
constructor
(
envType
extension
params
xulBrowser
)
{
super
(
envType
extension
params
xulBrowser
.
messageManager
extension
.
principal
)
;
this
.
viewType
=
params
.
viewType
;
this
.
xulBrowser
=
xulBrowser
;
if
(
params
.
cloneScopeInProcess
)
{
this
.
sandbox
=
params
.
cloneScopeInProcess
;
}
}
get
xulWindow
(
)
{
return
this
.
xulBrowser
.
ownerGlobal
;
}
get
windowId
(
)
{
if
(
!
Management
.
global
.
WindowManager
|
|
this
.
viewType
=
=
"
background
"
)
{
return
;
}
return
Management
.
global
.
WindowManager
.
getId
(
this
.
xulWindow
)
;
}
get
tabId
(
)
{
if
(
!
Management
.
global
.
TabManager
)
{
return
;
}
let
{
gBrowser
}
=
this
.
xulBrowser
.
ownerGlobal
;
let
tab
=
gBrowser
&
&
gBrowser
.
getTabForBrowser
(
this
.
xulBrowser
)
;
return
tab
&
&
Management
.
global
.
TabManager
.
getId
(
tab
)
;
}
shutdown
(
)
{
Management
.
emit
(
"
page
-
shutdown
"
this
)
;
super
.
shutdown
(
)
;
}
}
function
findPathInObject
(
obj
path
printErrors
=
true
)
{
for
(
let
elt
of
path
.
split
(
"
.
"
)
)
{
if
(
!
obj
|
|
!
(
elt
in
obj
)
)
{
if
(
printErrors
)
{
Cu
.
reportError
(
WebExtension
API
{
path
}
not
found
(
it
may
be
unimplemented
by
Firefox
)
.
)
;
}
return
null
;
}
obj
=
obj
[
elt
]
;
}
return
obj
;
}
var
ParentAPIManager
=
{
proxyContexts
:
new
Map
(
)
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
close
"
false
)
;
Services
.
mm
.
addMessageListener
(
"
API
:
CreateProxyContext
"
this
)
;
Services
.
mm
.
addMessageListener
(
"
API
:
CloseProxyContext
"
this
true
)
;
Services
.
mm
.
addMessageListener
(
"
API
:
Call
"
this
)
;
Services
.
mm
.
addMessageListener
(
"
API
:
AddListener
"
this
)
;
Services
.
mm
.
addMessageListener
(
"
API
:
RemoveListener
"
this
)
;
}
observe
(
subject
topic
data
)
{
let
mm
=
subject
;
for
(
let
[
childId
context
]
of
this
.
proxyContexts
)
{
if
(
context
.
messageManager
=
=
mm
)
{
this
.
closeProxyContext
(
childId
)
;
}
}
}
shutdownExtension
(
extensionId
)
{
for
(
let
[
childId
context
]
of
this
.
proxyContexts
)
{
if
(
context
.
extension
.
id
=
=
extensionId
)
{
context
.
shutdown
(
)
;
this
.
proxyContexts
.
delete
(
childId
)
;
}
}
}
receiveMessage
(
{
name
data
target
}
)
{
switch
(
name
)
{
case
"
API
:
CreateProxyContext
"
:
this
.
createProxyContext
(
data
target
)
;
break
;
case
"
API
:
CloseProxyContext
"
:
this
.
closeProxyContext
(
data
.
childId
)
;
break
;
case
"
API
:
Call
"
:
this
.
call
(
data
target
)
;
break
;
case
"
API
:
AddListener
"
:
this
.
addListener
(
data
target
)
;
break
;
case
"
API
:
RemoveListener
"
:
this
.
removeListener
(
data
)
;
break
;
}
}
createProxyContext
(
data
target
)
{
let
{
envType
extensionId
childId
principal
}
=
data
;
if
(
this
.
proxyContexts
.
has
(
childId
)
)
{
Cu
.
reportError
(
"
A
WebExtension
context
with
the
given
ID
already
exists
!
"
)
;
return
;
}
let
extension
=
GlobalManager
.
getExtension
(
extensionId
)
;
if
(
!
extension
)
{
Cu
.
reportError
(
No
WebExtension
found
with
ID
{
extensionId
}
)
;
return
;
}
let
context
;
if
(
envType
=
=
"
addon_parent
"
)
{
if
(
principal
.
URI
.
prePath
!
=
extension
.
baseURI
.
prePath
|
|
!
target
.
contentPrincipal
.
subsumes
(
principal
)
)
{
Cu
.
reportError
(
Refused
to
create
privileged
WebExtension
context
for
{
principal
.
URI
.
spec
}
)
;
return
;
}
context
=
new
ExtensionChildProxyContext
(
envType
extension
data
target
)
;
}
else
if
(
envType
=
=
"
content_parent
"
)
{
context
=
new
ProxyContext
(
envType
extension
data
target
.
messageManager
principal
)
;
}
else
{
Cu
.
reportError
(
Invalid
WebExtension
context
envType
:
{
envType
}
)
;
return
;
}
this
.
proxyContexts
.
set
(
childId
context
)
;
}
closeProxyContext
(
childId
)
{
let
context
=
this
.
proxyContexts
.
get
(
childId
)
;
if
(
!
context
)
{
return
;
}
context
.
unload
(
)
;
this
.
proxyContexts
.
delete
(
childId
)
;
}
call
(
data
target
)
{
let
context
=
this
.
proxyContexts
.
get
(
data
.
childId
)
;
if
(
!
context
)
{
Cu
.
reportError
(
"
WebExtension
context
not
found
!
"
)
;
return
;
}
function
callback
(
.
.
.
cbArgs
)
{
let
lastError
=
context
.
lastError
;
target
.
messageManager
.
sendAsyncMessage
(
"
API
:
CallResult
"
{
childId
:
data
.
childId
callId
:
data
.
callId
args
:
cbArgs
lastError
:
lastError
?
lastError
.
message
:
null
}
)
;
}
let
args
=
data
.
args
;
args
=
Cu
.
cloneInto
(
args
context
.
sandbox
)
;
if
(
data
.
callId
)
{
args
=
args
.
concat
(
callback
)
;
}
try
{
findPathInObject
(
context
.
apiObj
data
.
path
)
(
.
.
.
args
)
;
}
catch
(
e
)
{
let
msg
=
e
.
message
|
|
"
API
failed
"
;
target
.
messageManager
.
sendAsyncMessage
(
"
API
:
CallResult
"
{
childId
:
data
.
childId
callId
:
data
.
callId
lastError
:
msg
}
)
;
}
}
addListener
(
data
target
)
{
let
context
=
this
.
proxyContexts
.
get
(
data
.
childId
)
;
if
(
!
context
)
{
Cu
.
reportError
(
"
WebExtension
context
not
found
!
"
)
;
return
;
}
function
listener
(
.
.
.
listenerArgs
)
{
target
.
messageManager
.
sendAsyncMessage
(
"
API
:
RunListener
"
{
childId
:
data
.
childId
path
:
data
.
path
args
:
listenerArgs
}
)
;
}
context
.
listenerProxies
.
set
(
data
.
path
listener
)
;
let
args
=
Cu
.
cloneInto
(
data
.
args
context
.
sandbox
)
;
findPathInObject
(
context
.
apiObj
data
.
path
)
.
addListener
(
listener
.
.
.
args
)
;
}
removeListener
(
data
)
{
let
context
=
this
.
proxyContexts
.
get
(
data
.
childId
)
;
if
(
!
context
)
{
Cu
.
reportError
(
"
WebExtension
context
not
found
!
"
)
;
}
let
listener
=
context
.
listenerProxies
.
get
(
data
.
path
)
;
findPathInObject
(
context
.
apiObj
data
.
path
)
.
removeListener
(
listener
)
;
}
}
;
ParentAPIManager
.
init
(
)
;
var
UUIDMap
=
{
_read
(
)
{
let
pref
=
Preferences
.
get
(
UUID_MAP_PREF
"
{
}
"
)
;
try
{
return
JSON
.
parse
(
pref
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
Error
parsing
{
UUID_MAP_PREF
}
.
)
;
return
{
}
;
}
}
_write
(
map
)
{
Preferences
.
set
(
UUID_MAP_PREF
JSON
.
stringify
(
map
)
)
;
}
get
(
id
create
=
true
)
{
let
map
=
this
.
_read
(
)
;
if
(
id
in
map
)
{
return
map
[
id
]
;
}
let
uuid
=
null
;
if
(
create
)
{
uuid
=
uuidGen
.
generateUUID
(
)
.
number
;
uuid
=
uuid
.
slice
(
1
-
1
)
;
map
[
id
]
=
uuid
;
this
.
_write
(
map
)
;
}
return
uuid
;
}
remove
(
id
)
{
let
map
=
this
.
_read
(
)
;
delete
map
[
id
]
;
this
.
_write
(
map
)
;
}
}
;
function
getExtensionUUID
(
id
)
{
return
UUIDMap
.
get
(
id
true
)
;
}
var
UninstallObserver
=
{
initialized
:
false
init
(
)
{
if
(
!
this
.
initialized
)
{
AddonManager
.
addAddonListener
(
this
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
leaveStorage
"
LEAVE_STORAGE_PREF
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
leaveUuid
"
LEAVE_UUID_PREF
false
)
;
this
.
initialized
=
true
;
}
}
onUninstalling
(
addon
)
{
let
extension
=
GlobalManager
.
extensionMap
.
get
(
addon
.
id
)
;
if
(
extension
)
{
Management
.
emit
(
"
uninstall
"
extension
)
;
}
}
onUninstalled
(
addon
)
{
let
uuid
=
UUIDMap
.
get
(
addon
.
id
false
)
;
if
(
!
uuid
)
{
return
;
}
if
(
!
this
.
leaveStorage
)
{
ExtensionStorage
.
clear
(
addon
.
id
)
;
let
baseURI
=
NetUtil
.
newURI
(
moz
-
extension
:
/
/
{
uuid
}
/
)
;
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
baseURI
{
addonId
:
addon
.
id
}
)
;
Services
.
qms
.
clearStoragesForPrincipal
(
principal
)
;
let
attrs
=
JSON
.
stringify
(
{
addonId
:
addon
.
id
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
clear
-
origin
-
attributes
-
data
"
attrs
)
;
}
if
(
!
this
.
leaveUuid
)
{
UUIDMap
.
remove
(
addon
.
id
)
;
}
}
}
;
GlobalManager
=
{
extensionMap
:
new
Map
(
)
initialized
:
false
init
(
extension
)
{
if
(
this
.
extensionMap
.
size
=
=
0
)
{
UninstallObserver
.
init
(
)
;
ProxyMessenger
.
init
(
)
;
Management
.
on
(
"
extension
-
browser
-
inserted
"
this
.
_onExtensionBrowser
)
;
this
.
initialized
=
true
;
}
this
.
extensionMap
.
set
(
extension
.
id
extension
)
;
}
uninit
(
extension
)
{
this
.
extensionMap
.
delete
(
extension
.
id
)
;
if
(
this
.
extensionMap
.
size
=
=
0
&
&
this
.
initialized
)
{
Management
.
off
(
"
extension
-
browser
-
inserted
"
this
.
_onExtensionBrowser
)
;
this
.
initialized
=
false
;
}
}
_onExtensionBrowser
(
type
browser
)
{
let
global
=
browser
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
ExtensionContent
.
init
(
global
)
;
global
.
addEventListener
(
"
unload
"
function
(
)
{
ExtensionContent
.
uninit
(
this
)
;
}
)
;
}
getExtension
(
extensionId
)
{
return
this
.
extensionMap
.
get
(
extensionId
)
;
}
injectInObject
(
context
isChromeCompat
dest
)
{
let
apis
=
{
extensionTypes
:
{
}
}
;
Management
.
generateAPIs
(
context
apis
)
;
SchemaAPIManager
.
generateAPIs
(
context
context
.
extension
.
apis
apis
)
;
context
.
_unwrappedAPIs
=
apis
;
let
schemaWrapper
=
{
isChromeCompat
get
url
(
)
{
return
context
.
uri
.
spec
;
}
get
principal
(
)
{
return
context
.
principal
;
}
get
cloneScope
(
)
{
return
context
.
cloneScope
;
}
hasPermission
(
permission
)
{
return
context
.
extension
.
hasPermission
(
permission
)
;
}
shouldInject
(
namespace
name
allowedContexts
)
{
if
(
context
.
envType
=
=
=
"
content_parent
"
&
&
!
allowedContexts
.
includes
(
"
content
"
)
)
{
return
false
;
}
return
findPathInObject
(
apis
namespace
false
)
!
=
=
null
;
}
getImplementation
(
namespace
name
)
{
let
pathObj
=
findPathInObject
(
apis
namespace
)
;
return
new
LocalAPIImplementation
(
pathObj
name
context
)
;
}
}
;
Schemas
.
inject
(
dest
schemaWrapper
)
;
}
}
;
this
.
ExtensionData
=
class
{
constructor
(
rootURI
)
{
this
.
rootURI
=
rootURI
;
this
.
manifest
=
null
;
this
.
id
=
null
;
this
.
uuid
=
null
;
this
.
localeData
=
null
;
this
.
_promiseLocales
=
null
;
this
.
apiNames
=
new
Set
(
)
;
this
.
dependencies
=
new
Set
(
)
;
this
.
permissions
=
new
Set
(
)
;
this
.
errors
=
[
]
;
}
get
builtinMessages
(
)
{
return
null
;
}
get
logger
(
)
{
let
id
=
this
.
id
|
|
"
<
unknown
>
"
;
return
Log
.
repository
.
getLogger
(
LOGGER_ID_BASE
+
id
)
;
}
manifestError
(
message
)
{
this
.
packagingError
(
Reading
manifest
:
{
message
}
)
;
}
packagingError
(
message
)
{
this
.
errors
.
push
(
message
)
;
this
.
logger
.
error
(
Loading
extension
'
{
this
.
id
}
'
:
{
message
}
)
;
}
getURL
(
path
=
"
"
)
{
if
(
!
(
this
.
id
|
|
this
.
uuid
)
)
{
throw
new
Error
(
"
getURL
may
not
be
called
before
an
id
or
uuid
has
been
set
"
)
;
}
if
(
!
this
.
uuid
)
{
this
.
uuid
=
UUIDMap
.
get
(
this
.
id
)
;
}
return
moz
-
extension
:
/
/
{
this
.
uuid
}
/
{
path
}
;
}
readDirectory
(
path
)
{
return
Task
.
spawn
(
function
*
(
)
{
if
(
this
.
rootURI
instanceof
Ci
.
nsIFileURL
)
{
let
uri
=
NetUtil
.
newURI
(
this
.
rootURI
.
resolve
(
"
.
/
"
+
path
)
)
;
let
fullPath
=
uri
.
QueryInterface
(
Ci
.
nsIFileURL
)
.
file
.
path
;
let
iter
=
new
OS
.
File
.
DirectoryIterator
(
fullPath
)
;
let
results
=
[
]
;
try
{
yield
iter
.
forEach
(
entry
=
>
{
results
.
push
(
entry
)
;
}
)
;
}
catch
(
e
)
{
}
iter
.
close
(
)
;
return
results
;
}
let
uri
=
this
.
rootURI
.
QueryInterface
(
Ci
.
nsIJARURI
)
;
let
file
=
uri
.
JARFile
.
QueryInterface
(
Ci
.
nsIFileURL
)
.
file
;
let
zipReader
=
Cc
[
"
mozilla
.
org
/
libjar
/
zip
-
reader
;
1
"
]
.
createInstance
(
Ci
.
nsIZipReader
)
;
zipReader
.
open
(
file
)
;
try
{
let
results
=
[
]
;
path
=
{
uri
.
JAREntry
}
/
{
path
}
;
path
=
path
.
replace
(
/
\
/
\
/
+
/
g
"
/
"
)
.
replace
(
/
^
\
/
|
\
/
/
g
"
"
)
+
"
/
"
;
let
pattern
=
path
.
replace
(
/
[
[
\
]
(
)
?
*
~
|
\
\
]
/
g
"
\
\
&
"
)
;
let
enumerator
=
zipReader
.
findEntries
(
pattern
+
"
*
"
)
;
while
(
enumerator
.
hasMore
(
)
)
{
let
name
=
enumerator
.
getNext
(
)
;
if
(
!
name
.
startsWith
(
path
)
)
{
throw
new
Error
(
"
Unexpected
ZipReader
entry
"
)
;
}
name
=
name
.
slice
(
path
.
length
)
;
if
(
name
&
&
!
/
\
/
.
/
.
test
(
name
)
)
{
results
.
push
(
{
name
:
name
.
replace
(
"
/
"
"
"
)
isDir
:
name
.
endsWith
(
"
/
"
)
}
)
;
}
}
return
results
;
}
finally
{
zipReader
.
close
(
)
;
}
}
.
bind
(
this
)
)
;
}
readJSON
(
path
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
uri
=
this
.
rootURI
.
resolve
(
.
/
{
path
}
)
;
NetUtil
.
asyncFetch
(
{
uri
loadUsingSystemPrincipal
:
true
}
(
inputStream
status
)
=
>
{
if
(
!
Components
.
isSuccessCode
(
status
)
)
{
let
e
=
Components
.
Exception
(
"
"
status
)
;
reject
(
new
Error
(
Error
while
loading
'
{
uri
}
'
(
{
e
.
name
}
)
)
)
;
return
;
}
try
{
let
text
=
NetUtil
.
readInputStreamToString
(
inputStream
inputStream
.
available
(
)
{
charset
:
"
utf
-
8
"
}
)
;
text
=
text
.
replace
(
COMMENT_REGEXP
"
1
"
)
;
resolve
(
JSON
.
parse
(
text
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
;
}
)
;
}
readManifest
(
)
{
return
Promise
.
all
(
[
this
.
readJSON
(
"
manifest
.
json
"
)
Management
.
lazyInit
(
)
]
)
.
then
(
(
[
manifest
]
)
=
>
{
this
.
manifest
=
manifest
;
this
.
rawManifest
=
manifest
;
if
(
manifest
&
&
manifest
.
default_locale
)
{
return
this
.
initLocale
(
)
;
}
}
)
.
then
(
(
)
=
>
{
let
context
=
{
url
:
this
.
baseURI
&
&
this
.
baseURI
.
spec
principal
:
this
.
principal
logError
:
error
=
>
{
this
.
logger
.
warn
(
Loading
extension
'
{
this
.
id
}
'
:
Reading
manifest
:
{
error
}
)
;
}
preprocessors
:
{
}
}
;
if
(
this
.
localeData
)
{
context
.
preprocessors
.
localize
=
(
value
context
)
=
>
this
.
localize
(
value
)
;
}
let
normalized
=
Schemas
.
normalize
(
this
.
manifest
"
manifest
.
WebExtensionManifest
"
context
)
;
if
(
normalized
.
error
)
{
this
.
manifestError
(
normalized
.
error
)
;
}
else
{
this
.
manifest
=
normalized
.
value
;
}
try
{
if
(
!
this
.
id
&
&
this
.
manifest
.
applications
.
gecko
.
id
)
{
this
.
id
=
this
.
manifest
.
applications
.
gecko
.
id
;
}
}
catch
(
e
)
{
}
let
permissions
=
this
.
manifest
.
permissions
|
|
[
]
;
let
whitelist
=
[
]
;
for
(
let
perm
of
permissions
)
{
this
.
permissions
.
add
(
perm
)
;
let
match
=
/
^
(
\
w
+
)
(
?
:
\
.
(
\
w
+
)
(
?
:
\
.
\
w
+
)
*
)
?
/
.
exec
(
perm
)
;
if
(
!
match
)
{
whitelist
.
push
(
perm
)
;
}
else
if
(
match
[
1
]
=
=
"
experiments
"
&
&
match
[
2
]
)
{
this
.
apiNames
.
add
(
match
[
2
]
)
;
}
}
this
.
whiteListedHosts
=
new
MatchPattern
(
whitelist
)
;
for
(
let
api
of
this
.
apiNames
)
{
this
.
dependencies
.
add
(
{
api
}
experiments
.
addons
.
mozilla
.
org
)
;
}
return
this
.
manifest
;
}
)
;
}
localizeMessage
(
.
.
.
args
)
{
return
this
.
localeData
.
localizeMessage
(
.
.
.
args
)
;
}
localize
(
.
.
.
args
)
{
return
this
.
localeData
.
localize
(
.
.
.
args
)
;
}
get
defaultLocale
(
)
{
if
(
this
.
manifest
.
default_locale
!
=
null
)
{
return
this
.
normalizeLocaleCode
(
this
.
manifest
.
default_locale
)
;
}
return
null
;
}
normalizeLocaleCode
(
locale
)
{
return
String
.
replace
(
locale
/
_
/
g
"
-
"
)
;
}
readLocaleFile
(
locale
)
{
return
Task
.
spawn
(
function
*
(
)
{
let
locales
=
yield
this
.
promiseLocales
(
)
;
let
dir
=
locales
.
get
(
locale
)
|
|
locale
;
let
file
=
_locales
/
{
dir
}
/
messages
.
json
;
try
{
let
messages
=
yield
this
.
readJSON
(
file
)
;
return
this
.
localeData
.
addLocale
(
locale
messages
this
)
;
}
catch
(
e
)
{
this
.
packagingError
(
Loading
locale
file
{
file
}
:
{
e
}
)
;
return
new
Map
(
)
;
}
}
.
bind
(
this
)
)
;
}
promiseLocales
(
)
{
if
(
!
this
.
_promiseLocales
)
{
this
.
_promiseLocales
=
Task
.
spawn
(
function
*
(
)
{
let
locales
=
new
Map
(
)
;
let
entries
=
yield
this
.
readDirectory
(
"
_locales
"
)
;
for
(
let
file
of
entries
)
{
if
(
file
.
isDir
)
{
let
locale
=
this
.
normalizeLocaleCode
(
file
.
name
)
;
locales
.
set
(
locale
file
.
name
)
;
}
}
this
.
localeData
=
new
LocaleData
(
{
defaultLocale
:
this
.
defaultLocale
locales
builtinMessages
:
this
.
builtinMessages
}
)
;
return
locales
;
}
.
bind
(
this
)
)
;
}
return
this
.
_promiseLocales
;
}
initAllLocales
(
)
{
return
Task
.
spawn
(
function
*
(
)
{
let
locales
=
yield
this
.
promiseLocales
(
)
;
yield
Promise
.
all
(
Array
.
from
(
locales
.
keys
(
)
locale
=
>
this
.
readLocaleFile
(
locale
)
)
)
;
let
defaultLocale
=
this
.
defaultLocale
;
if
(
defaultLocale
)
{
if
(
!
locales
.
has
(
defaultLocale
)
)
{
this
.
manifestError
(
'
Value
for
"
default_locale
"
property
must
correspond
to
'
+
'
a
directory
in
"
_locales
/
"
.
Not
found
:
'
+
JSON
.
stringify
(
_locales
/
{
this
.
manifest
.
default_locale
}
/
)
)
;
}
}
else
if
(
locales
.
size
)
{
this
.
manifestError
(
'
The
"
default_locale
"
property
is
required
when
a
'
+
'
"
_locales
/
"
directory
is
present
.
'
)
;
}
return
this
.
localeData
.
messages
;
}
.
bind
(
this
)
)
;
}
initLocale
(
locale
=
this
.
defaultLocale
)
{
return
Task
.
spawn
(
function
*
(
)
{
if
(
locale
=
=
null
)
{
return
null
;
}
let
promises
=
[
this
.
readLocaleFile
(
locale
)
]
;
let
{
defaultLocale
}
=
this
;
if
(
locale
!
=
defaultLocale
&
&
!
this
.
localeData
.
has
(
defaultLocale
)
)
{
promises
.
push
(
this
.
readLocaleFile
(
defaultLocale
)
)
;
}
let
results
=
yield
Promise
.
all
(
promises
)
;
this
.
localeData
.
selectedLocale
=
locale
;
return
results
[
0
]
;
}
.
bind
(
this
)
)
;
}
}
;
class
MockExtension
{
constructor
(
file
rootURI
installType
)
{
this
.
id
=
null
;
this
.
file
=
file
;
this
.
rootURI
=
rootURI
;
this
.
installType
=
installType
;
this
.
addon
=
null
;
let
promiseEvent
=
eventName
=
>
new
Promise
(
resolve
=
>
{
let
onstartup
=
(
msg
extension
)
=
>
{
if
(
this
.
addon
&
&
extension
.
id
=
=
this
.
addon
.
id
)
{
Management
.
off
(
eventName
onstartup
)
;
this
.
id
=
extension
.
id
;
this
.
_extension
=
extension
;
resolve
(
extension
)
;
}
}
;
Management
.
on
(
eventName
onstartup
)
;
}
)
;
this
.
_extension
=
null
;
this
.
_extensionPromise
=
promiseEvent
(
"
startup
"
)
;
this
.
_readyPromise
=
promiseEvent
(
"
ready
"
)
;
}
testMessage
(
.
.
.
args
)
{
return
this
.
_extension
.
testMessage
(
.
.
.
args
)
;
}
on
(
.
.
.
args
)
{
this
.
_extensionPromise
.
then
(
extension
=
>
{
extension
.
on
(
.
.
.
args
)
;
}
)
;
}
off
(
.
.
.
args
)
{
this
.
_extensionPromise
.
then
(
extension
=
>
{
extension
.
off
(
.
.
.
args
)
;
}
)
;
}
startup
(
)
{
if
(
this
.
installType
=
=
"
temporary
"
)
{
return
AddonManager
.
installTemporaryAddon
(
this
.
file
)
.
then
(
addon
=
>
{
this
.
addon
=
addon
;
return
this
.
_readyPromise
;
}
)
;
}
else
if
(
this
.
installType
=
=
"
permanent
"
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
AddonManager
.
getInstallForFile
(
this
.
file
install
=
>
{
let
listener
=
{
onInstallFailed
:
reject
onInstallEnded
:
(
install
newAddon
)
=
>
{
this
.
addon
=
newAddon
;
resolve
(
this
.
_readyPromise
)
;
}
}
;
install
.
addListener
(
listener
)
;
install
.
install
(
)
;
}
)
;
}
)
;
}
throw
new
Error
(
"
installType
must
be
one
of
:
temporary
permanent
"
)
;
}
shutdown
(
)
{
this
.
addon
.
uninstall
(
)
;
return
this
.
cleanupGeneratedFile
(
)
;
}
cleanupGeneratedFile
(
)
{
flushJarCache
(
this
.
file
)
;
return
OS
.
File
.
remove
(
this
.
file
.
path
)
;
}
}
this
.
Extension
=
class
extends
ExtensionData
{
constructor
(
addonData
)
{
super
(
addonData
.
resourceURI
)
;
this
.
uuid
=
UUIDMap
.
get
(
addonData
.
id
)
;
if
(
addonData
.
cleanupFile
)
{
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
false
)
;
this
.
cleanupFile
=
addonData
.
cleanupFile
|
|
null
;
delete
addonData
.
cleanupFile
;
}
this
.
addonData
=
addonData
;
this
.
id
=
addonData
.
id
;
this
.
baseURI
=
NetUtil
.
newURI
(
this
.
getURL
(
"
"
)
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
this
.
principal
=
this
.
createPrincipal
(
)
;
this
.
views
=
new
Set
(
)
;
this
.
onStartup
=
null
;
this
.
hasShutdown
=
false
;
this
.
onShutdown
=
new
Set
(
)
;
this
.
uninstallURL
=
null
;
this
.
apis
=
[
]
;
this
.
whiteListedHosts
=
null
;
this
.
webAccessibleResources
=
null
;
this
.
emitter
=
new
EventEmitter
(
)
;
}
static
generateXPI
(
data
)
{
let
manifest
=
data
.
manifest
;
if
(
!
manifest
)
{
manifest
=
{
}
;
}
let
files
=
data
.
files
;
if
(
!
files
)
{
files
=
{
}
;
}
function
provide
(
obj
keys
value
override
=
false
)
{
if
(
keys
.
length
=
=
1
)
{
if
(
!
(
keys
[
0
]
in
obj
)
|
|
override
)
{
obj
[
keys
[
0
]
]
=
value
;
}
}
else
{
if
(
!
(
keys
[
0
]
in
obj
)
)
{
obj
[
keys
[
0
]
]
=
{
}
;
}
provide
(
obj
[
keys
[
0
]
]
keys
.
slice
(
1
)
value
override
)
;
}
}
provide
(
manifest
[
"
name
"
]
"
Generated
extension
"
)
;
provide
(
manifest
[
"
manifest_version
"
]
2
)
;
provide
(
manifest
[
"
version
"
]
"
1
.
0
"
)
;
if
(
data
.
background
)
{
let
bgScript
=
uuidGen
.
generateUUID
(
)
.
number
+
"
.
js
"
;
provide
(
manifest
[
"
background
"
"
scripts
"
]
[
bgScript
]
true
)
;
files
[
bgScript
]
=
data
.
background
;
}
provide
(
files
[
"
manifest
.
json
"
]
manifest
)
;
if
(
data
.
embedded
)
{
let
xpiFiles
=
{
"
install
.
rdf
"
:
<
?
xml
version
=
"
1
.
0
"
encoding
=
"
UTF
-
8
"
?
>
<
RDF
xmlns
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
02
/
22
-
rdf
-
syntax
-
ns
#
"
xmlns
:
em
=
"
http
:
/
/
www
.
mozilla
.
org
/
2004
/
em
-
rdf
#
"
>
<
Description
about
=
"
urn
:
mozilla
:
install
-
manifest
"
em
:
id
=
"
{
manifest
.
applications
.
gecko
.
id
}
"
em
:
name
=
"
{
manifest
.
name
}
"
em
:
type
=
"
2
"
em
:
version
=
"
{
manifest
.
version
}
"
em
:
description
=
"
"
em
:
hasEmbeddedWebExtension
=
"
true
"
em
:
bootstrap
=
"
true
"
>
<
!
-
-
Firefox
-
-
>
<
em
:
targetApplication
>
<
Description
em
:
id
=
"
{
ec8030f7
-
c20a
-
464f
-
9b0e
-
13a3a9e97384
}
"
em
:
minVersion
=
"
51
.
0a1
"
em
:
maxVersion
=
"
*
"
/
>
<
/
em
:
targetApplication
>
<
/
Description
>
<
/
RDF
>
"
bootstrap
.
js
"
:
function
install
(
)
{
}
function
uninstall
(
)
{
}
function
shutdown
(
)
{
}
function
startup
(
data
)
{
data
.
webExtension
.
startup
(
)
;
}
}
;
for
(
let
[
path
data
]
of
Object
.
entries
(
files
)
)
{
xpiFiles
[
webextension
/
{
path
}
]
=
data
;
}
files
=
xpiFiles
;
}
return
this
.
generateZipFile
(
files
)
;
}
static
generateZipFile
(
files
baseName
=
"
generated
-
extension
.
xpi
"
)
{
let
ZipWriter
=
Components
.
Constructor
(
"
mozilla
.
org
/
zipwriter
;
1
"
"
nsIZipWriter
"
)
;
let
zipW
=
new
ZipWriter
(
)
;
let
file
=
FileUtils
.
getFile
(
"
TmpD
"
[
baseName
]
)
;
file
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
FileUtils
.
PERMS_FILE
)
;
const
MODE_WRONLY
=
0x02
;
const
MODE_TRUNCATE
=
0x20
;
zipW
.
open
(
file
MODE_WRONLY
|
MODE_TRUNCATE
)
;
let
time
=
Date
.
now
(
)
*
1000
;
function
generateFile
(
filename
)
{
let
components
=
filename
.
split
(
"
/
"
)
;
let
path
=
"
"
;
for
(
let
component
of
components
.
slice
(
0
-
1
)
)
{
path
+
=
component
+
"
/
"
;
if
(
!
zipW
.
hasEntry
(
path
)
)
{
zipW
.
addEntryDirectory
(
path
time
false
)
;
}
}
}
for
(
let
filename
in
files
)
{
let
script
=
files
[
filename
]
;
if
(
typeof
(
script
)
=
=
"
function
"
)
{
script
=
"
(
"
+
script
.
toString
(
)
+
"
)
(
)
"
;
}
else
if
(
instanceOf
(
script
"
Object
"
)
|
|
instanceOf
(
script
"
Array
"
)
)
{
script
=
JSON
.
stringify
(
script
)
;
}
if
(
!
instanceOf
(
script
"
ArrayBuffer
"
)
)
{
script
=
new
TextEncoder
(
"
utf
-
8
"
)
.
encode
(
script
)
.
buffer
;
}
let
stream
=
Cc
[
"
mozilla
.
org
/
io
/
arraybuffer
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIArrayBufferInputStream
)
;
stream
.
setData
(
script
0
script
.
byteLength
)
;
generateFile
(
filename
)
;
zipW
.
addEntryStream
(
filename
time
0
stream
false
)
;
}
zipW
.
close
(
)
;
return
file
;
}
static
generate
(
data
)
{
let
file
=
this
.
generateXPI
(
data
)
;
flushJarCache
(
file
)
;
Services
.
ppmm
.
broadcastAsyncMessage
(
"
Extension
:
FlushJarCache
"
{
path
:
file
.
path
}
)
;
let
fileURI
=
Services
.
io
.
newFileURI
(
file
)
;
let
jarURI
=
Services
.
io
.
newURI
(
"
jar
:
"
+
fileURI
.
spec
+
"
!
/
"
null
null
)
;
if
(
data
.
useAddonManager
)
{
return
new
MockExtension
(
file
jarURI
data
.
useAddonManager
)
;
}
let
id
;
if
(
data
.
manifest
)
{
if
(
data
.
manifest
.
applications
&
&
data
.
manifest
.
applications
.
gecko
)
{
id
=
data
.
manifest
.
applications
.
gecko
.
id
;
}
else
if
(
data
.
manifest
.
browser_specific_settings
&
&
data
.
manifest
.
browser_specific_settings
.
gecko
)
{
id
=
data
.
manifest
.
browser_specific_settings
.
gecko
.
id
;
}
}
if
(
!
id
)
{
id
=
uuidGen
.
generateUUID
(
)
.
number
;
}
return
new
Extension
(
{
id
resourceURI
:
jarURI
cleanupFile
:
file
}
)
;
}
on
(
hook
f
)
{
return
this
.
emitter
.
on
(
hook
f
)
;
}
off
(
hook
f
)
{
return
this
.
emitter
.
off
(
hook
f
)
;
}
emit
(
.
.
.
args
)
{
return
this
.
emitter
.
emit
(
.
.
.
args
)
;
}
testMessage
(
.
.
.
args
)
{
Management
.
emit
(
"
test
-
message
"
this
.
.
.
args
)
;
}
createPrincipal
(
uri
=
this
.
baseURI
)
{
return
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
uri
{
addonId
:
this
.
id
}
)
;
}
isExtensionURL
(
url
)
{
let
uri
=
Services
.
io
.
newURI
(
url
null
null
)
;
let
common
=
this
.
baseURI
.
getCommonBaseSpec
(
uri
)
;
return
common
=
=
this
.
baseURI
.
spec
;
}
readManifest
(
)
{
return
super
.
readManifest
(
)
.
then
(
manifest
=
>
{
if
(
AppConstants
.
RELEASE_OR_BETA
)
{
return
manifest
;
}
return
Promise
.
all
(
Array
.
from
(
this
.
apiNames
api
=
>
ExtensionAPIs
.
load
(
api
)
)
)
.
then
(
apis
=
>
{
for
(
let
API
of
apis
)
{
this
.
apis
.
push
(
new
API
(
this
)
)
;
}
return
manifest
;
}
)
;
}
)
;
}
serialize
(
)
{
return
{
id
:
this
.
id
uuid
:
this
.
uuid
manifest
:
this
.
manifest
resourceURL
:
this
.
addonData
.
resourceURI
.
spec
baseURL
:
this
.
baseURI
.
spec
content_scripts
:
this
.
manifest
.
content_scripts
|
|
[
]
webAccessibleResources
:
this
.
webAccessibleResources
.
serialize
(
)
whiteListedHosts
:
this
.
whiteListedHosts
.
serialize
(
)
localeData
:
this
.
localeData
.
serialize
(
)
permissions
:
this
.
permissions
}
;
}
broadcast
(
msg
data
)
{
return
new
Promise
(
resolve
=
>
{
let
count
=
Services
.
ppmm
.
childCount
;
Services
.
ppmm
.
addMessageListener
(
msg
+
"
Complete
"
function
listener
(
)
{
count
-
-
;
if
(
count
=
=
0
)
{
Services
.
ppmm
.
removeMessageListener
(
msg
+
"
Complete
"
listener
)
;
resolve
(
)
;
}
}
)
;
Services
.
ppmm
.
broadcastAsyncMessage
(
msg
data
)
;
}
)
;
}
runManifest
(
manifest
)
{
let
strippedWebAccessibleResources
=
[
]
;
if
(
manifest
.
web_accessible_resources
)
{
strippedWebAccessibleResources
=
manifest
.
web_accessible_resources
.
map
(
path
=
>
path
.
replace
(
/
^
\
/
+
/
"
"
)
)
;
}
this
.
webAccessibleResources
=
new
MatchGlobs
(
strippedWebAccessibleResources
)
;
let
promises
=
[
]
;
for
(
let
directive
in
manifest
)
{
if
(
manifest
[
directive
]
!
=
=
null
)
{
promises
.
push
(
Management
.
emit
(
manifest_
{
directive
}
directive
this
manifest
)
)
;
}
}
let
data
=
Services
.
ppmm
.
initialProcessData
;
if
(
!
data
[
"
Extension
:
Extensions
"
]
)
{
data
[
"
Extension
:
Extensions
"
]
=
[
]
;
}
let
serial
=
this
.
serialize
(
)
;
data
[
"
Extension
:
Extensions
"
]
.
push
(
serial
)
;
return
this
.
broadcast
(
"
Extension
:
Startup
"
serial
)
.
then
(
(
)
=
>
{
return
Promise
.
all
(
promises
)
;
}
)
;
}
callOnClose
(
obj
)
{
this
.
onShutdown
.
add
(
obj
)
;
}
forgetOnClose
(
obj
)
{
this
.
onShutdown
.
delete
(
obj
)
;
}
get
builtinMessages
(
)
{
return
new
Map
(
[
[
"
extension_id
"
this
.
uuid
]
]
)
;
}
initLocale
(
locale
=
undefined
)
{
let
super_
=
super
.
initLocale
.
bind
(
this
)
;
return
Task
.
spawn
(
function
*
(
)
{
if
(
locale
=
=
=
undefined
)
{
let
locales
=
yield
this
.
promiseLocales
(
)
;
let
localeList
=
Array
.
from
(
locales
.
keys
(
)
locale
=
>
{
return
{
name
:
locale
locales
:
[
locale
]
}
;
}
)
;
let
match
=
Locale
.
findClosestLocale
(
localeList
)
;
locale
=
match
?
match
.
name
:
this
.
defaultLocale
;
}
return
super_
(
locale
)
;
}
.
bind
(
this
)
)
;
}
startup
(
)
{
let
started
=
false
;
return
this
.
readManifest
(
)
.
then
(
(
)
=
>
{
ExtensionManagement
.
startupExtension
(
this
.
uuid
this
.
addonData
.
resourceURI
this
)
;
started
=
true
;
if
(
!
this
.
hasShutdown
)
{
return
this
.
initLocale
(
)
;
}
}
)
.
then
(
(
)
=
>
{
if
(
this
.
errors
.
length
)
{
return
Promise
.
reject
(
{
errors
:
this
.
errors
}
)
;
}
if
(
this
.
hasShutdown
)
{
return
;
}
GlobalManager
.
init
(
this
)
;
this
.
emit
(
"
startup
"
this
)
;
Management
.
emit
(
"
startup
"
this
)
;
return
this
.
runManifest
(
this
.
manifest
)
;
}
)
.
then
(
(
)
=
>
{
Management
.
emit
(
"
ready
"
this
)
;
}
)
.
catch
(
e
=
>
{
dump
(
Extension
error
:
{
e
.
message
}
{
e
.
filename
|
|
e
.
fileName
}
:
{
e
.
lineNumber
}
:
:
{
e
.
stack
|
|
new
Error
(
)
.
stack
}
\
n
)
;
Cu
.
reportError
(
e
)
;
if
(
started
)
{
ExtensionManagement
.
shutdownExtension
(
this
.
uuid
)
;
}
this
.
cleanupGeneratedFile
(
)
;
throw
e
;
}
)
;
}
cleanupGeneratedFile
(
)
{
if
(
!
this
.
cleanupFile
)
{
return
;
}
let
file
=
this
.
cleanupFile
;
this
.
cleanupFile
=
null
;
Services
.
obs
.
removeObserver
(
this
"
xpcom
-
shutdown
"
)
;
this
.
broadcast
(
"
Extension
:
FlushJarCache
"
{
path
:
file
.
path
}
)
.
then
(
(
)
=
>
{
file
.
remove
(
false
)
;
}
)
;
}
shutdown
(
)
{
this
.
hasShutdown
=
true
;
if
(
!
this
.
manifest
)
{
ExtensionManagement
.
shutdownExtension
(
this
.
uuid
)
;
this
.
cleanupGeneratedFile
(
)
;
return
;
}
GlobalManager
.
uninit
(
this
)
;
for
(
let
obj
of
this
.
onShutdown
)
{
obj
.
close
(
)
;
}
for
(
let
api
of
this
.
apis
)
{
api
.
destroy
(
)
;
}
ParentAPIManager
.
shutdownExtension
(
this
.
id
)
;
Management
.
emit
(
"
shutdown
"
this
)
;
Services
.
ppmm
.
broadcastAsyncMessage
(
"
Extension
:
Shutdown
"
{
id
:
this
.
id
}
)
;
MessageChannel
.
abortResponses
(
{
extensionId
:
this
.
id
}
)
;
ExtensionManagement
.
shutdownExtension
(
this
.
uuid
)
;
this
.
cleanupGeneratedFile
(
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
xpcom
-
shutdown
"
)
{
this
.
cleanupGeneratedFile
(
)
;
}
}
hasPermission
(
perm
)
{
let
match
=
/
^
manifest
:
(
.
*
)
/
.
exec
(
perm
)
;
if
(
match
)
{
return
this
.
manifest
[
match
[
1
]
]
!
=
null
;
}
return
this
.
permissions
.
has
(
perm
)
;
}
get
name
(
)
{
return
this
.
manifest
.
name
;
}
}
;
