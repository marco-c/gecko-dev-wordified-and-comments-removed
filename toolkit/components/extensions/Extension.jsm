"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Dictionary
"
"
Extension
"
"
ExtensionData
"
"
Langpack
"
"
Management
"
"
ExtensionAddonObserver
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AddonManagerPrivate
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AddonSettings
:
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonSettings
.
jsm
"
AMTelemetry
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
E10SUtils
:
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
ExtensionPermissions
:
"
resource
:
/
/
gre
/
modules
/
ExtensionPermissions
.
jsm
"
ExtensionPreferencesManager
:
"
resource
:
/
/
gre
/
modules
/
ExtensionPreferencesManager
.
jsm
"
ExtensionProcessScript
:
"
resource
:
/
/
gre
/
modules
/
ExtensionProcessScript
.
jsm
"
ExtensionStorage
:
"
resource
:
/
/
gre
/
modules
/
ExtensionStorage
.
jsm
"
ExtensionStorageIDB
:
"
resource
:
/
/
gre
/
modules
/
ExtensionStorageIDB
.
jsm
"
ExtensionTelemetry
:
"
resource
:
/
/
gre
/
modules
/
ExtensionTelemetry
.
jsm
"
FileSource
:
"
resource
:
/
/
gre
/
modules
/
L10nRegistry
.
jsm
"
L10nRegistry
:
"
resource
:
/
/
gre
/
modules
/
L10nRegistry
.
jsm
"
LightweightThemeManager
:
"
resource
:
/
/
gre
/
modules
/
LightweightThemeManager
.
jsm
"
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
MessageChannel
:
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
PluralForm
:
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
Schemas
:
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
XPIProvider
:
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIProvider
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
OSPath
"
(
)
=
>
{
let
obj
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
/
ospath_unix
.
jsm
"
obj
)
;
return
obj
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
resourceProtocol
"
(
)
=
>
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
)
;
const
{
ExtensionCommon
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
const
{
ExtensionParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
aomStartup
:
[
"
mozilla
.
org
/
addons
/
addon
-
manager
-
startup
;
1
"
"
amIAddonManagerStartup
"
]
spellCheck
:
[
"
mozilla
.
org
/
spellchecker
/
engine
;
1
"
"
mozISpellCheckingEngine
"
]
uuidGen
:
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
]
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
processCount
"
"
dom
.
ipc
.
processCount
.
extension
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
allowPrivateBrowsingByDefault
"
"
extensions
.
allowPrivateBrowsingByDefault
"
true
)
;
var
{
GlobalManager
ParentAPIManager
StartupCache
apiManager
:
Management
}
=
ExtensionParent
;
const
{
getUniqueId
promiseTimeout
}
=
ExtensionUtils
;
const
{
EventEmitter
}
=
ExtensionCommon
;
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
ExtensionCommon
.
getConsole
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
LocaleData
"
(
)
=
>
ExtensionCommon
.
LocaleData
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
LAZY_NO_PROMPT_PERMISSIONS
"
async
(
)
=
>
{
await
Management
.
lazyInit
(
)
;
return
new
Set
(
Schemas
.
getPermissionNames
(
[
"
PermissionNoPrompt
"
"
OptionalPermissionNoPrompt
"
]
)
)
;
}
)
;
const
{
sharedData
}
=
Services
.
ppmm
;
const
PRIVATE_ALLOWED_PERMISSION
=
"
internal
:
privateBrowsingAllowed
"
;
const
WEBEXT_STORAGE_USER_CONTEXT_ID
=
-
1
>
>
>
0
;
const
CHILD_SHUTDOWN_TIMEOUT_MS
=
8000
;
const
PRIVILEGED_PERMS
=
new
Set
(
[
"
activityLog
"
"
mozillaAddons
"
"
geckoViewAddons
"
"
telemetry
"
"
urlbar
"
"
nativeMessagingFromContent
"
"
normandyAddonStudy
"
"
networkStatus
"
]
)
;
function
classifyPermission
(
perm
restrictSchemes
isPrivileged
)
{
let
match
=
/
^
(
\
w
+
)
(
?
:
\
.
(
\
w
+
)
(
?
:
\
.
\
w
+
)
*
)
?
/
.
exec
(
perm
)
;
if
(
!
match
)
{
try
{
let
{
pattern
}
=
new
MatchPattern
(
perm
{
restrictSchemes
ignorePath
:
true
}
)
;
return
{
origin
:
pattern
}
;
}
catch
(
e
)
{
return
{
invalid
:
perm
}
;
}
}
else
if
(
match
[
1
]
=
=
"
experiments
"
&
&
match
[
2
]
)
{
return
{
api
:
match
[
2
]
}
;
}
else
if
(
!
isPrivileged
&
&
PRIVILEGED_PERMS
.
has
(
match
[
1
]
)
)
{
return
{
invalid
:
perm
}
;
}
return
{
permission
:
perm
}
;
}
const
LOGGER_ID_BASE
=
"
addons
.
webextension
.
"
;
const
UUID_MAP_PREF
=
"
extensions
.
webextensions
.
uuids
"
;
const
LEAVE_STORAGE_PREF
=
"
extensions
.
webextensions
.
keepStorageOnUninstall
"
;
const
LEAVE_UUID_PREF
=
"
extensions
.
webextensions
.
keepUuidOnUninstall
"
;
const
COMMENT_REGEXP
=
new
RegExp
(
String
.
raw
^
(
(
?
:
[
^
"
\
n
]
|
"
(
?
:
[
^
"
\
\
\
n
]
|
\
\
.
)
*
"
)
*
?
)
/
/
.
*
.
replace
(
/
\
s
+
/
g
"
"
)
"
gm
"
)
;
var
UUIDMap
=
{
_read
(
)
{
let
pref
=
Services
.
prefs
.
getStringPref
(
UUID_MAP_PREF
"
{
}
"
)
;
try
{
return
JSON
.
parse
(
pref
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
Error
parsing
{
UUID_MAP_PREF
}
.
)
;
return
{
}
;
}
}
_write
(
map
)
{
Services
.
prefs
.
setStringPref
(
UUID_MAP_PREF
JSON
.
stringify
(
map
)
)
;
}
get
(
id
create
=
true
)
{
let
map
=
this
.
_read
(
)
;
if
(
id
in
map
)
{
return
map
[
id
]
;
}
let
uuid
=
null
;
if
(
create
)
{
uuid
=
uuidGen
.
generateUUID
(
)
.
number
;
uuid
=
uuid
.
slice
(
1
-
1
)
;
map
[
id
]
=
uuid
;
this
.
_write
(
map
)
;
}
return
uuid
;
}
remove
(
id
)
{
let
map
=
this
.
_read
(
)
;
delete
map
[
id
]
;
this
.
_write
(
map
)
;
}
}
;
var
ExtensionAddonObserver
=
{
initialized
:
false
init
(
)
{
if
(
!
this
.
initialized
)
{
AddonManager
.
addAddonListener
(
this
)
;
this
.
initialized
=
true
;
}
}
uninit
(
)
{
if
(
this
.
initialized
)
{
AddonManager
.
removeAddonListener
(
this
)
;
this
.
initialized
=
false
;
}
}
onEnabling
(
addon
)
{
if
(
addon
.
type
!
=
=
"
extension
"
)
{
return
;
}
Management
.
_callHandlers
(
[
addon
.
id
]
"
enabling
"
"
onEnabling
"
)
;
}
onDisabled
(
addon
)
{
if
(
addon
.
type
!
=
=
"
extension
"
)
{
return
;
}
if
(
Services
.
appinfo
.
inSafeMode
)
{
Management
.
_callHandlers
(
[
addon
.
id
]
"
disable
"
"
onDisable
"
)
;
}
}
onUninstalling
(
addon
)
{
let
extension
=
GlobalManager
.
extensionMap
.
get
(
addon
.
id
)
;
if
(
extension
)
{
Management
.
emit
(
"
uninstalling
"
extension
)
;
}
}
onUninstalled
(
addon
)
{
let
uuid
=
UUIDMap
.
get
(
addon
.
id
false
)
;
if
(
!
uuid
)
{
return
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
LEAVE_STORAGE_PREF
false
)
)
{
AsyncShutdown
.
profileChangeTeardown
.
addBlocker
(
Clear
Extension
Storage
{
addon
.
id
}
(
File
Backend
)
ExtensionStorage
.
clear
(
addon
.
id
{
shouldNotifyListeners
:
false
}
)
)
;
let
baseURI
=
Services
.
io
.
newURI
(
moz
-
extension
:
/
/
{
uuid
}
/
)
;
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
baseURI
{
}
)
;
Services
.
qms
.
clearStoragesForPrincipal
(
principal
)
;
let
storagePrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
baseURI
{
userContextId
:
WEBEXT_STORAGE_USER_CONTEXT_ID
}
)
;
Services
.
qms
.
clearStoragesForPrincipal
(
storagePrincipal
)
;
ExtensionStorageIDB
.
clearMigratedExtensionPref
(
addon
.
id
)
;
if
(
!
Services
.
lsm
.
nextGenLocalStorageEnabled
)
{
let
storage
=
Services
.
domStorageManager
.
getStorage
(
null
principal
principal
)
;
if
(
storage
)
{
storage
.
clear
(
)
;
}
}
Services
.
perms
.
removeFromPrincipal
(
principal
"
WebExtensions
-
unlimitedStorage
"
)
;
Services
.
perms
.
removeFromPrincipal
(
principal
"
indexedDB
"
)
;
Services
.
perms
.
removeFromPrincipal
(
principal
"
persistent
-
storage
"
)
;
}
ExtensionPermissions
.
removeAll
(
addon
.
id
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
LEAVE_UUID_PREF
false
)
)
{
UUIDMap
.
remove
(
addon
.
id
)
;
}
}
}
;
ExtensionAddonObserver
.
init
(
)
;
const
manifestTypes
=
new
Map
(
[
[
"
theme
"
"
manifest
.
ThemeManifest
"
]
[
"
langpack
"
"
manifest
.
WebExtensionLangpackManifest
"
]
[
"
dictionary
"
"
manifest
.
WebExtensionDictionaryManifest
"
]
[
"
extension
"
"
manifest
.
WebExtensionManifest
"
]
]
)
;
class
ExtensionData
{
constructor
(
rootURI
)
{
this
.
rootURI
=
rootURI
;
this
.
resourceURL
=
rootURI
.
spec
;
this
.
manifest
=
null
;
this
.
type
=
null
;
this
.
id
=
null
;
this
.
uuid
=
null
;
this
.
localeData
=
null
;
this
.
fluentL10n
=
null
;
this
.
_promiseLocales
=
null
;
this
.
apiNames
=
new
Set
(
)
;
this
.
dependencies
=
new
Set
(
)
;
this
.
permissions
=
new
Set
(
)
;
this
.
startupData
=
null
;
this
.
errors
=
[
]
;
this
.
warnings
=
[
]
;
}
get
builtinMessages
(
)
{
return
null
;
}
get
logger
(
)
{
let
id
=
this
.
id
|
|
"
<
unknown
>
"
;
return
Log
.
repository
.
getLogger
(
LOGGER_ID_BASE
+
id
)
;
}
manifestError
(
message
)
{
this
.
packagingError
(
Reading
manifest
:
{
message
}
)
;
}
manifestWarning
(
message
)
{
this
.
packagingWarning
(
Reading
manifest
:
{
message
}
)
;
}
packagingError
(
message
)
{
this
.
errors
.
push
(
message
)
;
this
.
logError
(
message
)
;
}
packagingWarning
(
message
)
{
this
.
warnings
.
push
(
message
)
;
this
.
logWarning
(
message
)
;
}
logWarning
(
message
)
{
this
.
_logMessage
(
message
"
warn
"
)
;
}
logError
(
message
)
{
this
.
_logMessage
(
message
"
error
"
)
;
}
_logMessage
(
message
severity
)
{
this
.
logger
[
severity
]
(
Loading
extension
'
{
this
.
id
}
'
:
{
message
}
)
;
}
getURL
(
path
=
"
"
)
{
if
(
!
(
this
.
id
|
|
this
.
uuid
)
)
{
throw
new
Error
(
"
getURL
may
not
be
called
before
an
id
or
uuid
has
been
set
"
)
;
}
if
(
!
this
.
uuid
)
{
this
.
uuid
=
UUIDMap
.
get
(
this
.
id
)
;
}
return
moz
-
extension
:
/
/
{
this
.
uuid
}
/
{
path
}
;
}
async
readDirectory
(
path
)
{
if
(
this
.
rootURI
instanceof
Ci
.
nsIFileURL
)
{
let
uri
=
Services
.
io
.
newURI
(
"
.
/
"
+
path
null
this
.
rootURI
)
;
let
fullPath
=
uri
.
QueryInterface
(
Ci
.
nsIFileURL
)
.
file
.
path
;
let
iter
=
new
OS
.
File
.
DirectoryIterator
(
fullPath
)
;
let
results
=
[
]
;
try
{
await
iter
.
forEach
(
entry
=
>
{
results
.
push
(
entry
)
;
}
)
;
}
catch
(
e
)
{
if
(
!
e
.
becauseNoSuchFile
)
{
Cu
.
reportError
(
e
)
;
}
}
iter
.
close
(
)
;
return
results
;
}
let
uri
=
this
.
rootURI
.
QueryInterface
(
Ci
.
nsIJARURI
)
;
let
entry
=
{
uri
.
JAREntry
}
/
{
path
}
/
.
replace
(
/
\
/
\
/
+
/
g
"
/
"
)
.
replace
(
/
^
\
/
/
"
"
)
;
uri
=
Services
.
io
.
newURI
(
jar
:
{
uri
.
JARFile
.
spec
}
!
/
{
entry
}
)
;
let
results
=
[
]
;
for
(
let
name
of
aomStartup
.
enumerateJARSubtree
(
uri
)
)
{
if
(
!
name
.
startsWith
(
entry
)
)
{
throw
new
Error
(
"
Unexpected
ZipReader
entry
"
)
;
}
name
=
name
.
slice
(
entry
.
length
)
;
if
(
name
&
&
!
/
\
/
.
/
.
test
(
name
)
)
{
results
.
push
(
{
name
:
name
.
replace
(
"
/
"
"
"
)
isDir
:
name
.
endsWith
(
"
/
"
)
}
)
;
}
}
return
results
;
}
readJSON
(
path
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
uri
=
this
.
rootURI
.
resolve
(
.
/
{
path
}
)
;
NetUtil
.
asyncFetch
(
{
uri
loadUsingSystemPrincipal
:
true
}
(
inputStream
status
)
=
>
{
if
(
!
Components
.
isSuccessCode
(
status
)
)
{
let
e
=
Components
.
Exception
(
"
"
status
)
;
reject
(
new
Error
(
Error
while
loading
'
{
uri
}
'
(
{
e
.
name
}
)
)
)
;
return
;
}
try
{
let
text
=
NetUtil
.
readInputStreamToString
(
inputStream
inputStream
.
available
(
)
{
charset
:
"
utf
-
8
"
}
)
;
text
=
text
.
replace
(
COMMENT_REGEXP
"
1
"
)
;
resolve
(
JSON
.
parse
(
text
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
;
}
)
;
}
get
restrictSchemes
(
)
{
return
!
this
.
hasPermission
(
"
mozillaAddons
"
)
;
}
permissionsObject
(
permissionsArray
)
{
let
permissions
=
new
Set
(
)
;
let
origins
=
new
Set
(
)
;
let
{
restrictSchemes
isPrivileged
}
=
this
;
for
(
let
perm
of
permissionsArray
|
|
[
]
)
{
let
type
=
classifyPermission
(
perm
restrictSchemes
isPrivileged
)
;
if
(
type
.
origin
)
{
origins
.
add
(
perm
)
;
}
else
if
(
type
.
permission
)
{
permissions
.
add
(
perm
)
;
}
}
return
{
permissions
origins
}
;
}
get
manifestPermissions
(
)
{
if
(
this
.
type
!
=
=
"
extension
"
)
{
return
null
;
}
let
{
permissions
origins
}
=
this
.
permissionsObject
(
this
.
manifest
.
permissions
)
;
if
(
this
.
manifest
.
devtools_page
&
&
!
this
.
manifest
.
optional_permissions
.
includes
(
"
devtools
"
)
)
{
permissions
.
add
(
"
devtools
"
)
;
}
for
(
let
entry
of
this
.
manifest
.
content_scripts
|
|
[
]
)
{
for
(
let
origin
of
entry
.
matches
)
{
origins
.
add
(
origin
)
;
}
}
return
{
permissions
:
Array
.
from
(
permissions
)
origins
:
Array
.
from
(
origins
)
}
;
}
get
manifestOptionalPermissions
(
)
{
if
(
this
.
type
!
=
=
"
extension
"
)
{
return
null
;
}
let
{
permissions
origins
}
=
this
.
permissionsObject
(
this
.
manifest
.
optional_permissions
)
;
return
{
permissions
:
Array
.
from
(
permissions
)
origins
:
Array
.
from
(
origins
)
}
;
}
get
activePermissions
(
)
{
if
(
this
.
type
!
=
=
"
extension
"
)
{
return
null
;
}
let
result
=
{
origins
:
this
.
allowedOrigins
.
patterns
.
map
(
matcher
=
>
matcher
.
pattern
)
.
filter
(
pattern
=
>
!
pattern
.
startsWith
(
"
moz
-
extension
:
"
)
)
apis
:
[
.
.
.
this
.
apiNames
]
}
;
const
EXP_PATTERN
=
/
^
experiments
\
.
\
w
+
/
;
result
.
permissions
=
[
.
.
.
this
.
permissions
]
.
filter
(
p
=
>
!
result
.
origins
.
includes
(
p
)
&
&
!
EXP_PATTERN
.
test
(
p
)
)
;
return
result
;
}
static
async
shouldPromptFor
(
permission
)
{
return
!
(
await
LAZY_NO_PROMPT_PERMISSIONS
)
.
has
(
permission
)
;
}
static
comparePermissions
(
oldPermissions
newPermissions
)
{
let
oldMatcher
=
new
MatchPatternSet
(
oldPermissions
.
origins
{
restrictSchemes
:
false
}
)
;
return
{
origins
:
newPermissions
.
origins
.
filter
(
perm
=
>
!
oldMatcher
.
subsumesDomain
(
new
MatchPattern
(
perm
{
restrictSchemes
:
false
}
)
)
)
permissions
:
newPermissions
.
permissions
.
filter
(
perm
=
>
!
oldPermissions
.
permissions
.
includes
(
perm
)
)
}
;
}
static
intersectPermissions
(
oldPermissions
newPermissions
)
{
let
matcher
=
new
MatchPatternSet
(
newPermissions
.
origins
{
restrictSchemes
:
false
}
)
;
return
{
origins
:
oldPermissions
.
origins
.
filter
(
perm
=
>
matcher
.
subsumesDomain
(
new
MatchPattern
(
perm
{
restrictSchemes
:
false
}
)
)
)
permissions
:
oldPermissions
.
permissions
.
filter
(
perm
=
>
newPermissions
.
permissions
.
includes
(
perm
)
)
}
;
}
static
async
migratePermissions
(
id
oldPermissions
oldOptionalPermissions
newPermissions
newOptionalPermissions
)
{
let
migrated
=
ExtensionData
.
intersectPermissions
(
oldPermissions
newOptionalPermissions
)
;
await
ExtensionPermissions
.
add
(
id
migrated
)
;
let
permSet
=
new
Set
(
newPermissions
.
permissions
.
concat
(
newOptionalPermissions
.
permissions
)
)
;
let
oldPerms
=
oldPermissions
.
permissions
.
concat
(
oldOptionalPermissions
.
permissions
)
;
let
removed
=
oldPerms
.
filter
(
x
=
>
!
permSet
.
has
(
x
)
)
;
await
ExtensionPreferencesManager
.
removeSettingsForPermissions
(
id
removed
)
;
await
ExtensionPermissions
.
remove
(
id
{
permissions
:
removed
origins
:
[
]
}
)
;
}
canUseExperiment
(
manifest
)
{
return
this
.
experimentsAllowed
&
&
manifest
.
experiment_apis
;
}
async
getLocalizedManifest
(
locale
)
{
if
(
!
this
.
type
|
|
!
this
.
localeData
)
{
throw
new
Error
(
"
The
extension
has
not
been
initialized
.
"
)
;
}
if
(
!
this
.
rawManifest
)
{
this
.
rawManifest
=
await
this
.
readJSON
(
"
manifest
.
json
"
)
;
}
if
(
!
this
.
localeData
.
has
(
locale
)
)
{
let
locales
=
await
this
.
promiseLocales
(
)
;
if
(
locales
.
get
(
locale
)
)
{
await
this
.
initLocale
(
locale
)
;
}
if
(
!
this
.
localeData
.
has
(
locale
)
)
{
throw
new
Error
(
The
extension
does
not
contain
the
locale
{
locale
}
)
;
}
}
let
normalized
=
await
this
.
_getNormalizedManifest
(
locale
)
;
if
(
normalized
.
error
)
{
throw
new
Error
(
normalized
.
error
)
;
}
return
normalized
.
value
;
}
async
_getNormalizedManifest
(
locale
)
{
let
manifestType
=
manifestTypes
.
get
(
this
.
type
)
;
let
context
=
{
url
:
this
.
baseURI
&
&
this
.
baseURI
.
spec
principal
:
this
.
principal
logError
:
error
=
>
{
this
.
manifestWarning
(
error
)
;
}
preprocessors
:
{
}
}
;
if
(
this
.
fluentL10n
|
|
this
.
localeData
)
{
context
.
preprocessors
.
localize
=
(
value
context
)
=
>
this
.
localize
(
value
locale
)
;
}
return
Schemas
.
normalize
(
this
.
rawManifest
manifestType
context
)
;
}
async
parseManifest
(
)
{
let
[
manifest
]
=
await
Promise
.
all
(
[
this
.
readJSON
(
"
manifest
.
json
"
)
Management
.
lazyInit
(
)
]
)
;
this
.
manifest
=
manifest
;
this
.
rawManifest
=
manifest
;
if
(
allowPrivateBrowsingByDefault
&
&
"
incognito
"
in
manifest
&
&
manifest
.
incognito
=
=
"
not_allowed
"
)
{
throw
new
Error
(
manifest
.
incognito
set
to
"
not_allowed
"
is
currently
unvailable
for
use
.
)
;
}
if
(
manifest
&
&
manifest
.
default_locale
)
{
await
this
.
initLocale
(
)
;
}
if
(
manifest
&
&
manifest
.
l10n_resources
&
&
"
isPrivileged
"
in
this
)
{
if
(
this
.
isPrivileged
)
{
this
.
fluentL10n
=
new
Localization
(
manifest
.
l10n_resources
true
)
;
}
else
{
Cu
.
reportError
(
"
Ignoring
l10n_resources
in
unprivileged
extension
"
)
;
}
}
if
(
this
.
manifest
.
theme
)
{
this
.
type
=
"
theme
"
;
}
else
if
(
this
.
manifest
.
langpack_id
)
{
this
.
type
=
"
langpack
"
;
}
else
if
(
this
.
manifest
.
dictionaries
)
{
this
.
type
=
"
dictionary
"
;
}
else
{
this
.
type
=
"
extension
"
;
}
let
normalized
=
await
this
.
_getNormalizedManifest
(
)
;
if
(
normalized
.
error
)
{
this
.
manifestError
(
normalized
.
error
)
;
return
null
;
}
manifest
=
normalized
.
value
;
let
id
;
try
{
if
(
manifest
.
applications
.
gecko
.
id
)
{
id
=
manifest
.
applications
.
gecko
.
id
;
}
}
catch
(
e
)
{
}
if
(
!
this
.
id
)
{
this
.
id
=
id
;
}
let
apiNames
=
new
Set
(
)
;
let
dependencies
=
new
Set
(
)
;
let
originPermissions
=
new
Set
(
)
;
let
permissions
=
new
Set
(
)
;
let
webAccessibleResources
=
[
]
;
let
schemaPromises
=
new
Map
(
)
;
let
result
=
{
apiNames
dependencies
id
manifest
modules
:
null
originPermissions
permissions
schemaURLs
:
null
type
:
this
.
type
webAccessibleResources
}
;
if
(
this
.
type
=
=
=
"
extension
"
)
{
let
{
isPrivileged
}
=
this
;
let
restrictSchemes
=
!
(
isPrivileged
&
&
manifest
.
permissions
.
includes
(
"
mozillaAddons
"
)
)
;
for
(
let
perm
of
manifest
.
permissions
)
{
if
(
perm
=
=
=
"
geckoProfiler
"
&
&
!
isPrivileged
)
{
const
acceptedExtensions
=
Services
.
prefs
.
getStringPref
(
"
extensions
.
geckoProfiler
.
acceptedExtensionIds
"
"
"
)
;
if
(
!
acceptedExtensions
.
split
(
"
"
)
.
includes
(
id
)
)
{
this
.
manifestError
(
"
Only
specific
extensions
are
allowed
to
access
the
geckoProfiler
.
"
)
;
continue
;
}
}
let
type
=
classifyPermission
(
perm
restrictSchemes
isPrivileged
)
;
if
(
type
.
origin
)
{
perm
=
type
.
origin
;
originPermissions
.
add
(
perm
)
;
}
else
if
(
type
.
api
)
{
apiNames
.
add
(
type
.
api
)
;
}
else
if
(
type
.
invalid
)
{
this
.
manifestWarning
(
Invalid
extension
permission
:
{
perm
}
)
;
continue
;
}
permissions
.
add
(
perm
)
;
}
if
(
this
.
id
)
{
let
matcher
=
new
MatchPattern
(
this
.
getURL
(
)
{
ignorePath
:
true
}
)
;
originPermissions
.
add
(
matcher
.
pattern
)
;
let
perms
=
await
ExtensionPermissions
.
get
(
this
.
id
)
;
for
(
let
perm
of
perms
.
permissions
)
{
permissions
.
add
(
perm
)
;
}
for
(
let
origin
of
perms
.
origins
)
{
originPermissions
.
add
(
origin
)
;
}
}
for
(
let
api
of
apiNames
)
{
dependencies
.
add
(
{
api
}
experiments
.
addons
.
mozilla
.
org
)
;
}
let
moduleData
=
data
=
>
(
{
url
:
this
.
rootURI
.
resolve
(
data
.
script
)
events
:
data
.
events
paths
:
data
.
paths
scopes
:
data
.
scopes
}
)
;
let
computeModuleInit
=
(
scope
modules
)
=
>
{
let
manager
=
new
ExtensionCommon
.
SchemaAPIManager
(
scope
)
;
return
manager
.
initModuleJSON
(
[
modules
]
)
;
}
;
result
.
contentScripts
=
[
]
;
for
(
let
options
of
manifest
.
content_scripts
|
|
[
]
)
{
result
.
contentScripts
.
push
(
{
allFrames
:
options
.
all_frames
matchAboutBlank
:
options
.
match_about_blank
frameID
:
options
.
frame_id
runAt
:
options
.
run_at
matches
:
options
.
matches
excludeMatches
:
options
.
exclude_matches
|
|
[
]
includeGlobs
:
options
.
include_globs
excludeGlobs
:
options
.
exclude_globs
jsPaths
:
options
.
js
|
|
[
]
cssPaths
:
options
.
css
|
|
[
]
}
)
;
}
if
(
this
.
canUseExperiment
(
manifest
)
)
{
let
parentModules
=
{
}
;
let
childModules
=
{
}
;
for
(
let
[
name
data
]
of
Object
.
entries
(
manifest
.
experiment_apis
)
)
{
let
schema
=
this
.
getURL
(
data
.
schema
)
;
if
(
!
schemaPromises
.
has
(
schema
)
)
{
schemaPromises
.
set
(
schema
this
.
readJSON
(
data
.
schema
)
.
then
(
json
=
>
Schemas
.
processSchema
(
json
)
)
)
;
}
if
(
data
.
parent
)
{
parentModules
[
name
]
=
moduleData
(
data
.
parent
)
;
}
if
(
data
.
child
)
{
childModules
[
name
]
=
moduleData
(
data
.
child
)
;
}
}
result
.
modules
=
{
child
:
computeModuleInit
(
"
addon_child
"
childModules
)
parent
:
computeModuleInit
(
"
addon_parent
"
parentModules
)
}
;
}
if
(
manifest
.
web_accessible_resources
)
{
webAccessibleResources
.
push
(
.
.
.
manifest
.
web_accessible_resources
.
map
(
path
=
>
path
.
replace
(
/
^
\
/
*
/
"
/
"
)
)
)
;
}
}
else
if
(
this
.
type
=
=
"
langpack
"
)
{
const
platform
=
AppConstants
.
platform
;
const
chromeEntries
=
[
]
;
for
(
const
[
language
entry
]
of
Object
.
entries
(
manifest
.
languages
)
)
{
for
(
const
[
alias
path
]
of
Object
.
entries
(
entry
.
chrome_resources
|
|
{
}
)
)
{
if
(
typeof
path
=
=
=
"
string
"
)
{
chromeEntries
.
push
(
[
"
locale
"
alias
language
path
]
)
;
}
else
if
(
platform
in
path
)
{
chromeEntries
.
push
(
[
"
locale
"
alias
language
path
[
platform
]
]
)
;
}
}
}
const
productCodeName
=
AppConstants
.
MOZ_BUILD_APP
.
replace
(
"
/
"
"
-
"
)
;
const
langpackId
=
langpack
-
{
manifest
.
langpack_id
}
-
{
productCodeName
}
;
const
l10nRegistrySources
=
{
}
;
const
entries
=
await
this
.
readDirectory
(
"
localization
"
)
;
if
(
entries
.
length
)
{
l10nRegistrySources
.
toolkit
=
"
"
;
}
if
(
manifest
.
sources
)
{
for
(
const
[
sourceName
{
base_path
}
]
of
Object
.
entries
(
manifest
.
sources
)
)
{
l10nRegistrySources
[
sourceName
]
=
base_path
;
}
}
const
languages
=
Object
.
keys
(
manifest
.
languages
)
;
this
.
startupData
=
{
chromeEntries
langpackId
l10nRegistrySources
languages
}
;
}
else
if
(
this
.
type
=
=
"
dictionary
"
)
{
let
dictionaries
=
{
}
;
for
(
let
[
lang
path
]
of
Object
.
entries
(
manifest
.
dictionaries
)
)
{
path
=
path
.
replace
(
/
^
\
/
+
/
"
"
)
;
let
dir
=
OSPath
.
dirname
(
path
)
;
if
(
dir
=
=
=
"
.
"
)
{
dir
=
"
"
;
}
let
leafName
=
OSPath
.
basename
(
path
)
;
let
affixPath
=
leafName
.
slice
(
0
-
3
)
+
"
aff
"
;
let
entries
=
Array
.
from
(
await
this
.
readDirectory
(
dir
)
entry
=
>
entry
.
name
)
;
if
(
!
entries
.
includes
(
leafName
)
)
{
this
.
manifestError
(
Invalid
dictionary
path
specified
for
'
{
lang
}
'
:
{
path
}
)
;
}
if
(
!
entries
.
includes
(
affixPath
)
)
{
this
.
manifestError
(
Invalid
dictionary
path
specified
for
'
{
lang
}
'
:
Missing
affix
file
:
{
path
}
)
;
}
dictionaries
[
lang
]
=
path
;
}
this
.
startupData
=
{
dictionaries
}
;
}
if
(
schemaPromises
.
size
)
{
let
schemas
=
new
Map
(
)
;
for
(
let
[
url
promise
]
of
schemaPromises
)
{
schemas
.
set
(
url
await
promise
)
;
}
result
.
schemaURLs
=
schemas
;
}
return
result
;
}
async
loadManifest
(
)
{
let
[
manifestData
]
=
await
Promise
.
all
(
[
this
.
parseManifest
(
)
Management
.
lazyInit
(
)
]
)
;
if
(
!
manifestData
)
{
return
;
}
if
(
!
this
.
id
)
{
this
.
id
=
manifestData
.
id
;
}
this
.
manifest
=
manifestData
.
manifest
;
this
.
apiNames
=
manifestData
.
apiNames
;
this
.
contentScripts
=
manifestData
.
contentScripts
;
this
.
dependencies
=
manifestData
.
dependencies
;
this
.
permissions
=
manifestData
.
permissions
;
this
.
schemaURLs
=
manifestData
.
schemaURLs
;
this
.
type
=
manifestData
.
type
;
this
.
modules
=
manifestData
.
modules
;
this
.
apiManager
=
this
.
getAPIManager
(
)
;
await
this
.
apiManager
.
lazyInit
(
)
;
this
.
webAccessibleResources
=
manifestData
.
webAccessibleResources
.
map
(
res
=
>
new
MatchGlob
(
res
)
)
;
this
.
allowedOrigins
=
new
MatchPatternSet
(
manifestData
.
originPermissions
{
restrictSchemes
:
this
.
restrictSchemes
}
)
;
return
this
.
manifest
;
}
hasPermission
(
perm
includeOptional
=
false
)
{
let
manifest_
=
"
manifest
:
"
;
if
(
perm
.
startsWith
(
manifest_
)
)
{
let
value
=
this
.
manifest
;
for
(
let
prop
of
perm
.
substr
(
manifest_
.
length
)
.
split
(
"
.
"
)
)
{
if
(
!
value
)
{
break
;
}
value
=
value
[
prop
]
;
}
return
value
!
=
null
;
}
if
(
this
.
permissions
.
has
(
perm
)
)
{
return
true
;
}
if
(
includeOptional
&
&
this
.
manifest
.
optional_permissions
.
includes
(
perm
)
)
{
return
true
;
}
return
false
;
}
getAPIManager
(
)
{
let
apiManagers
=
[
Management
]
;
for
(
let
id
of
this
.
dependencies
)
{
let
policy
=
WebExtensionPolicy
.
getByID
(
id
)
;
if
(
policy
)
{
if
(
policy
.
extension
.
experimentAPIManager
)
{
apiManagers
.
push
(
policy
.
extension
.
experimentAPIManager
)
;
}
else
if
(
AppConstants
.
DEBUG
)
{
Cu
.
reportError
(
Cannot
find
experimental
API
exported
from
{
id
}
)
;
}
}
}
if
(
this
.
modules
)
{
this
.
experimentAPIManager
=
new
ExtensionCommon
.
LazyAPIManager
(
"
main
"
this
.
modules
.
parent
this
.
schemaURLs
)
;
apiManagers
.
push
(
this
.
experimentAPIManager
)
;
}
if
(
apiManagers
.
length
=
=
1
)
{
return
apiManagers
[
0
]
;
}
return
new
ExtensionCommon
.
MultiAPIManager
(
"
main
"
apiManagers
.
reverse
(
)
)
;
}
localizeMessage
(
.
.
.
args
)
{
return
this
.
localeData
.
localizeMessage
(
.
.
.
args
)
;
}
localize
(
str
locale
)
{
if
(
this
.
fluentL10n
)
{
str
=
str
.
replace
(
/
__MSG_
(
[
-
A
-
Za
-
z0
-
9
_
]
+
?
)
__
/
g
(
matched
message
)
=
>
{
let
translation
=
this
.
fluentL10n
.
formatValueSync
(
message
)
;
return
translation
!
=
=
undefined
?
translation
:
matched
;
}
)
;
}
if
(
this
.
localeData
)
{
str
=
this
.
localeData
.
localize
(
str
locale
)
;
}
return
str
;
}
get
defaultLocale
(
)
{
if
(
this
.
manifest
.
default_locale
!
=
null
)
{
return
this
.
normalizeLocaleCode
(
this
.
manifest
.
default_locale
)
;
}
return
null
;
}
get
isAppProvided
(
)
{
return
this
.
addonData
.
builtIn
|
|
this
.
addonData
.
isSystem
;
}
normalizeLocaleCode
(
locale
)
{
return
locale
.
replace
(
/
_
/
g
"
-
"
)
;
}
async
readLocaleFile
(
locale
)
{
let
locales
=
await
this
.
promiseLocales
(
)
;
let
dir
=
locales
.
get
(
locale
)
|
|
locale
;
let
file
=
_locales
/
{
dir
}
/
messages
.
json
;
try
{
let
messages
=
await
this
.
readJSON
(
file
)
;
return
this
.
localeData
.
addLocale
(
locale
messages
this
)
;
}
catch
(
e
)
{
this
.
packagingError
(
Loading
locale
file
{
file
}
:
{
e
}
)
;
return
new
Map
(
)
;
}
}
async
_promiseLocaleMap
(
)
{
let
locales
=
new
Map
(
)
;
let
entries
=
await
this
.
readDirectory
(
"
_locales
"
)
;
for
(
let
file
of
entries
)
{
if
(
file
.
isDir
)
{
let
locale
=
this
.
normalizeLocaleCode
(
file
.
name
)
;
locales
.
set
(
locale
file
.
name
)
;
}
}
return
locales
;
}
_setupLocaleData
(
locales
)
{
if
(
this
.
localeData
)
{
return
this
.
localeData
.
locales
;
}
this
.
localeData
=
new
LocaleData
(
{
defaultLocale
:
this
.
defaultLocale
locales
builtinMessages
:
this
.
builtinMessages
}
)
;
return
locales
;
}
promiseLocales
(
)
{
if
(
!
this
.
_promiseLocales
)
{
this
.
_promiseLocales
=
(
async
(
)
=
>
{
let
locales
=
this
.
_promiseLocaleMap
(
)
;
return
this
.
_setupLocaleData
(
locales
)
;
}
)
(
)
;
}
return
this
.
_promiseLocales
;
}
async
initAllLocales
(
)
{
let
locales
=
await
this
.
promiseLocales
(
)
;
await
Promise
.
all
(
Array
.
from
(
locales
.
keys
(
)
locale
=
>
this
.
readLocaleFile
(
locale
)
)
)
;
let
defaultLocale
=
this
.
defaultLocale
;
if
(
defaultLocale
)
{
if
(
!
locales
.
has
(
defaultLocale
)
)
{
this
.
manifestError
(
'
Value
for
"
default_locale
"
property
must
correspond
to
'
+
'
a
directory
in
"
_locales
/
"
.
Not
found
:
'
+
JSON
.
stringify
(
_locales
/
{
this
.
manifest
.
default_locale
}
/
)
)
;
}
}
else
if
(
locales
.
size
)
{
this
.
manifestError
(
'
The
"
default_locale
"
property
is
required
when
a
'
+
'
"
_locales
/
"
directory
is
present
.
'
)
;
}
return
this
.
localeData
.
messages
;
}
async
initLocale
(
locale
=
this
.
defaultLocale
)
{
if
(
locale
=
=
null
)
{
return
null
;
}
let
promises
=
[
this
.
readLocaleFile
(
locale
)
]
;
let
{
defaultLocale
}
=
this
;
if
(
locale
!
=
defaultLocale
&
&
!
this
.
localeData
.
has
(
defaultLocale
)
)
{
promises
.
push
(
this
.
readLocaleFile
(
defaultLocale
)
)
;
}
let
results
=
await
Promise
.
all
(
promises
)
;
this
.
localeData
.
selectedLocale
=
locale
;
return
results
[
0
]
;
}
static
formatPermissionStrings
(
info
bundle
{
collapseOrigins
=
false
}
=
{
}
)
{
let
result
=
{
}
;
let
perms
=
info
.
permissions
|
|
{
origins
:
[
]
permissions
:
[
]
}
;
let
allUrls
=
false
wildcards
=
new
Set
(
)
sites
=
new
Set
(
)
;
for
(
let
permission
of
perms
.
origins
)
{
if
(
permission
=
=
"
<
all_urls
>
"
)
{
allUrls
=
true
;
break
;
}
let
match
=
/
^
[
a
-
z
*
]
+
:
\
/
\
/
(
[
^
/
]
*
)
\
/
|
^
about
:
/
.
exec
(
permission
)
;
if
(
!
match
)
{
throw
new
Error
(
Unparseable
host
permission
{
permission
}
)
;
}
if
(
!
match
[
1
]
|
|
match
[
1
]
=
=
"
*
"
)
{
allUrls
=
true
;
}
else
if
(
match
[
1
]
.
startsWith
(
"
*
.
"
)
)
{
wildcards
.
add
(
match
[
1
]
.
slice
(
2
)
)
;
}
else
{
sites
.
add
(
match
[
1
]
)
;
}
}
result
.
msgs
=
[
]
;
if
(
allUrls
)
{
result
.
msgs
.
push
(
bundle
.
GetStringFromName
(
"
webextPerms
.
hostDescription
.
allUrls
"
)
)
;
}
else
{
let
format
=
(
list
itemKey
moreKey
)
=
>
{
function
formatItems
(
items
)
{
result
.
msgs
.
push
(
.
.
.
items
.
map
(
item
=
>
bundle
.
formatStringFromName
(
itemKey
[
item
]
)
)
)
;
}
if
(
list
.
length
<
5
|
|
!
collapseOrigins
)
{
formatItems
(
list
)
;
}
else
{
formatItems
(
list
.
slice
(
0
3
)
)
;
let
remaining
=
list
.
length
-
3
;
result
.
msgs
.
push
(
PluralForm
.
get
(
remaining
bundle
.
GetStringFromName
(
moreKey
)
)
.
replace
(
"
#
1
"
remaining
)
)
;
}
}
;
format
(
Array
.
from
(
wildcards
)
"
webextPerms
.
hostDescription
.
wildcard
"
"
webextPerms
.
hostDescription
.
tooManyWildcards
"
)
;
format
(
Array
.
from
(
sites
)
"
webextPerms
.
hostDescription
.
oneSite
"
"
webextPerms
.
hostDescription
.
tooManySites
"
)
;
}
let
permissionKey
=
perm
=
>
webextPerms
.
description
.
{
perm
}
;
const
NATIVE_MSG_PERM
=
"
nativeMessaging
"
;
if
(
perms
.
permissions
.
includes
(
NATIVE_MSG_PERM
)
)
{
result
.
msgs
.
push
(
bundle
.
formatStringFromName
(
permissionKey
(
NATIVE_MSG_PERM
)
[
info
.
appName
]
)
)
;
}
let
permissionsCopy
=
perms
.
permissions
.
slice
(
0
)
;
for
(
let
permission
of
permissionsCopy
.
sort
(
)
)
{
if
(
permission
=
=
"
nativeMessaging
"
)
{
continue
;
}
try
{
result
.
msgs
.
push
(
bundle
.
GetStringFromName
(
permissionKey
(
permission
)
)
)
;
}
catch
(
err
)
{
}
}
const
haveAccessKeys
=
AppConstants
.
platform
!
=
=
"
android
"
;
result
.
header
=
bundle
.
formatStringFromName
(
"
webextPerms
.
header
"
[
"
<
>
"
]
)
;
result
.
text
=
info
.
unsigned
?
bundle
.
GetStringFromName
(
"
webextPerms
.
unsignedWarning
"
)
:
"
"
;
result
.
listIntro
=
bundle
.
GetStringFromName
(
"
webextPerms
.
listIntro
"
)
;
result
.
acceptText
=
bundle
.
GetStringFromName
(
"
webextPerms
.
add
.
label
"
)
;
result
.
cancelText
=
bundle
.
GetStringFromName
(
"
webextPerms
.
cancel
.
label
"
)
;
if
(
haveAccessKeys
)
{
result
.
acceptKey
=
bundle
.
GetStringFromName
(
"
webextPerms
.
add
.
accessKey
"
)
;
result
.
cancelKey
=
bundle
.
GetStringFromName
(
"
webextPerms
.
cancel
.
accessKey
"
)
;
}
if
(
info
.
type
=
=
"
sideload
"
)
{
result
.
header
=
bundle
.
formatStringFromName
(
"
webextPerms
.
sideloadHeader
"
[
"
<
>
"
]
)
;
let
key
=
!
result
.
msgs
.
length
?
"
webextPerms
.
sideloadTextNoPerms
"
:
"
webextPerms
.
sideloadText2
"
;
result
.
text
=
bundle
.
GetStringFromName
(
key
)
;
result
.
acceptText
=
bundle
.
GetStringFromName
(
"
webextPerms
.
sideloadEnable
.
label
"
)
;
result
.
cancelText
=
bundle
.
GetStringFromName
(
"
webextPerms
.
sideloadCancel
.
label
"
)
;
if
(
haveAccessKeys
)
{
result
.
acceptKey
=
bundle
.
GetStringFromName
(
"
webextPerms
.
sideloadEnable
.
accessKey
"
)
;
result
.
cancelKey
=
bundle
.
GetStringFromName
(
"
webextPerms
.
sideloadCancel
.
accessKey
"
)
;
}
}
else
if
(
info
.
type
=
=
"
update
"
)
{
result
.
header
=
bundle
.
formatStringFromName
(
"
webextPerms
.
updateText
"
[
"
<
>
"
]
)
;
result
.
text
=
"
"
;
result
.
acceptText
=
bundle
.
GetStringFromName
(
"
webextPerms
.
updateAccept
.
label
"
)
;
if
(
haveAccessKeys
)
{
result
.
acceptKey
=
bundle
.
GetStringFromName
(
"
webextPerms
.
updateAccept
.
accessKey
"
)
;
}
}
else
if
(
info
.
type
=
=
"
optional
"
)
{
result
.
header
=
bundle
.
formatStringFromName
(
"
webextPerms
.
optionalPermsHeader
"
[
"
<
>
"
]
)
;
result
.
text
=
"
"
;
result
.
listIntro
=
bundle
.
GetStringFromName
(
"
webextPerms
.
optionalPermsListIntro
"
)
;
result
.
acceptText
=
bundle
.
GetStringFromName
(
"
webextPerms
.
optionalPermsAllow
.
label
"
)
;
result
.
cancelText
=
bundle
.
GetStringFromName
(
"
webextPerms
.
optionalPermsDeny
.
label
"
)
;
if
(
haveAccessKeys
)
{
result
.
acceptKey
=
bundle
.
GetStringFromName
(
"
webextPerms
.
optionalPermsAllow
.
accessKey
"
)
;
result
.
cancelKey
=
bundle
.
GetStringFromName
(
"
webextPerms
.
optionalPermsDeny
.
accessKey
"
)
;
}
}
return
result
;
}
}
const
PROXIED_EVENTS
=
new
Set
(
[
"
test
-
harness
-
message
"
"
add
-
permissions
"
"
remove
-
permissions
"
]
)
;
class
BootstrapScope
{
install
(
data
reason
)
{
}
uninstall
(
data
reason
)
{
AsyncShutdown
.
profileChangeTeardown
.
addBlocker
(
Uninstalling
add
-
on
:
{
data
.
id
}
Management
.
emit
(
"
uninstall
"
{
id
:
data
.
id
}
)
.
then
(
(
)
=
>
{
Management
.
emit
(
"
uninstall
-
complete
"
{
id
:
data
.
id
}
)
;
}
)
)
;
}
fetchState
(
)
{
if
(
this
.
extension
)
{
return
{
state
:
this
.
extension
.
state
}
;
}
return
null
;
}
async
update
(
data
reason
)
{
if
(
data
.
oldPermissions
)
{
let
emptyPermissions
=
{
permissions
:
[
]
origins
:
[
]
}
;
await
ExtensionData
.
migratePermissions
(
data
.
id
data
.
oldPermissions
data
.
oldOptionalPermissions
data
.
userPermissions
|
|
emptyPermissions
data
.
optionalPermissions
|
|
emptyPermissions
)
;
}
return
Management
.
emit
(
"
update
"
{
id
:
data
.
id
resourceURI
:
data
.
resourceURI
}
)
;
}
startup
(
data
reason
)
{
this
.
extension
=
new
Extension
(
data
this
.
BOOTSTRAP_REASON_TO_STRING_MAP
[
reason
]
)
;
return
this
.
extension
.
startup
(
)
;
}
async
shutdown
(
data
reason
)
{
let
result
=
await
this
.
extension
.
shutdown
(
this
.
BOOTSTRAP_REASON_TO_STRING_MAP
[
reason
]
)
;
this
.
extension
=
null
;
return
result
;
}
}
XPCOMUtils
.
defineLazyGetter
(
BootstrapScope
.
prototype
"
BOOTSTRAP_REASON_TO_STRING_MAP
"
(
)
=
>
{
const
{
BOOTSTRAP_REASONS
}
=
AddonManagerPrivate
;
return
Object
.
freeze
(
{
[
BOOTSTRAP_REASONS
.
APP_STARTUP
]
:
"
APP_STARTUP
"
[
BOOTSTRAP_REASONS
.
APP_SHUTDOWN
]
:
"
APP_SHUTDOWN
"
[
BOOTSTRAP_REASONS
.
ADDON_ENABLE
]
:
"
ADDON_ENABLE
"
[
BOOTSTRAP_REASONS
.
ADDON_DISABLE
]
:
"
ADDON_DISABLE
"
[
BOOTSTRAP_REASONS
.
ADDON_INSTALL
]
:
"
ADDON_INSTALL
"
[
BOOTSTRAP_REASONS
.
ADDON_UNINSTALL
]
:
"
ADDON_UNINSTALL
"
[
BOOTSTRAP_REASONS
.
ADDON_UPGRADE
]
:
"
ADDON_UPGRADE
"
[
BOOTSTRAP_REASONS
.
ADDON_DOWNGRADE
]
:
"
ADDON_DOWNGRADE
"
}
)
;
}
)
;
class
DictionaryBootstrapScope
extends
BootstrapScope
{
install
(
data
reason
)
{
}
uninstall
(
data
reason
)
{
}
startup
(
data
reason
)
{
this
.
dictionary
=
new
Dictionary
(
data
)
;
return
this
.
dictionary
.
startup
(
this
.
BOOTSTRAP_REASON_TO_STRING_MAP
[
reason
]
)
;
}
shutdown
(
data
reason
)
{
this
.
dictionary
.
shutdown
(
this
.
BOOTSTRAP_REASON_TO_STRING_MAP
[
reason
]
)
;
this
.
dictionary
=
null
;
}
}
class
LangpackBootstrapScope
{
install
(
data
reason
)
{
}
uninstall
(
data
reason
)
{
}
startup
(
data
reason
)
{
this
.
langpack
=
new
Langpack
(
data
)
;
return
this
.
langpack
.
startup
(
)
;
}
shutdown
(
data
reason
)
{
this
.
langpack
.
shutdown
(
)
;
this
.
langpack
=
null
;
}
}
let
activeExtensionIDs
=
new
Set
(
)
;
let
pendingExtensions
=
new
Map
(
)
;
class
Extension
extends
ExtensionData
{
constructor
(
addonData
startupReason
)
{
super
(
addonData
.
resourceURI
)
;
this
.
startupStates
=
new
Set
(
)
;
this
.
state
=
"
Not
started
"
;
this
.
sharedDataKeys
=
new
Set
(
)
;
this
.
uuid
=
UUIDMap
.
get
(
addonData
.
id
)
;
this
.
instanceId
=
getUniqueId
(
)
;
this
.
MESSAGE_EMIT_EVENT
=
Extension
:
EmitEvent
:
{
this
.
instanceId
}
;
Services
.
ppmm
.
addMessageListener
(
this
.
MESSAGE_EMIT_EVENT
this
)
;
if
(
addonData
.
cleanupFile
)
{
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
)
;
this
.
cleanupFile
=
addonData
.
cleanupFile
|
|
null
;
delete
addonData
.
cleanupFile
;
}
if
(
addonData
.
TEST_NO_ADDON_MANAGER
)
{
this
.
dontSaveStartupData
=
true
;
}
this
.
addonData
=
addonData
;
this
.
startupData
=
addonData
.
startupData
|
|
{
}
;
this
.
startupReason
=
startupReason
;
if
(
[
"
ADDON_UPGRADE
"
"
ADDON_DOWNGRADE
"
]
.
includes
(
startupReason
)
)
{
StartupCache
.
clearAddonData
(
addonData
.
id
)
;
}
this
.
remote
=
!
WebExtensionPolicy
.
isExtensionProcess
;
this
.
remoteType
=
this
.
remote
?
E10SUtils
.
EXTENSION_REMOTE_TYPE
:
null
;
if
(
this
.
remote
&
&
processCount
!
=
=
1
)
{
throw
new
Error
(
"
Out
-
of
-
process
WebExtensions
are
not
supported
with
multiple
child
processes
"
)
;
}
this
.
parentMessageManager
=
null
;
this
.
id
=
addonData
.
id
;
this
.
version
=
addonData
.
version
;
this
.
baseURL
=
this
.
getURL
(
"
"
)
;
this
.
baseURI
=
Services
.
io
.
newURI
(
this
.
baseURL
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
this
.
principal
=
this
.
createPrincipal
(
)
;
this
.
views
=
new
Set
(
)
;
this
.
_backgroundPageFrameLoader
=
null
;
this
.
onStartup
=
null
;
this
.
hasShutdown
=
false
;
this
.
onShutdown
=
new
Set
(
)
;
this
.
uninstallURL
=
null
;
this
.
allowedOrigins
=
null
;
this
.
_optionalOrigins
=
null
;
this
.
webAccessibleResources
=
null
;
this
.
registeredContentScripts
=
new
Map
(
)
;
this
.
emitter
=
new
EventEmitter
(
)
;
if
(
this
.
startupData
.
lwtData
&
&
this
.
startupReason
=
=
"
APP_STARTUP
"
)
{
LightweightThemeManager
.
fallbackThemeData
=
this
.
startupData
.
lwtData
;
}
this
.
on
(
"
add
-
permissions
"
(
ignoreEvent
permissions
)
=
>
{
for
(
let
perm
of
permissions
.
permissions
)
{
this
.
permissions
.
add
(
perm
)
;
}
if
(
permissions
.
origins
.
length
)
{
let
patterns
=
this
.
allowedOrigins
.
patterns
.
map
(
host
=
>
host
.
pattern
)
;
this
.
allowedOrigins
=
new
MatchPatternSet
(
new
Set
(
[
.
.
.
patterns
.
.
.
permissions
.
origins
]
)
{
restrictSchemes
:
this
.
restrictSchemes
ignorePath
:
true
}
)
;
}
this
.
policy
.
permissions
=
Array
.
from
(
this
.
permissions
)
;
this
.
policy
.
allowedOrigins
=
this
.
allowedOrigins
;
this
.
cachePermissions
(
)
;
this
.
updatePermissions
(
)
;
}
)
;
this
.
on
(
"
remove
-
permissions
"
(
ignoreEvent
permissions
)
=
>
{
for
(
let
perm
of
permissions
.
permissions
)
{
this
.
permissions
.
delete
(
perm
)
;
}
let
origins
=
permissions
.
origins
.
map
(
origin
=
>
new
MatchPattern
(
origin
{
ignorePath
:
true
}
)
.
pattern
)
;
this
.
allowedOrigins
=
new
MatchPatternSet
(
this
.
allowedOrigins
.
patterns
.
filter
(
host
=
>
!
origins
.
includes
(
host
.
pattern
)
)
)
;
this
.
policy
.
permissions
=
Array
.
from
(
this
.
permissions
)
;
this
.
policy
.
allowedOrigins
=
this
.
allowedOrigins
;
this
.
cachePermissions
(
)
;
this
.
updatePermissions
(
)
;
}
)
;
}
set
state
(
startupState
)
{
this
.
startupStates
.
clear
(
)
;
this
.
startupStates
.
add
(
startupState
)
;
}
get
state
(
)
{
return
{
Array
.
from
(
this
.
startupStates
)
.
join
(
"
"
)
}
;
}
async
addStartupStatePromise
(
name
fn
)
{
this
.
startupStates
.
add
(
name
)
;
try
{
await
fn
(
)
;
}
finally
{
this
.
startupStates
.
delete
(
name
)
;
}
}
get
restrictSchemes
(
)
{
return
!
(
this
.
isPrivileged
&
&
this
.
hasPermission
(
"
mozillaAddons
"
)
)
;
}
static
getBootstrapScope
(
)
{
return
new
BootstrapScope
(
)
;
}
get
groupFrameLoader
(
)
{
let
frameLoader
=
this
.
_backgroundPageFrameLoader
;
for
(
let
view
of
this
.
views
)
{
if
(
view
.
viewType
=
=
=
"
background
"
&
&
view
.
xulBrowser
)
{
return
view
.
xulBrowser
.
frameLoader
;
}
if
(
!
frameLoader
&
&
view
.
xulBrowser
)
{
frameLoader
=
view
.
xulBrowser
.
frameLoader
;
}
}
return
frameLoader
|
|
ExtensionParent
.
DebugUtils
.
getFrameLoader
(
this
.
id
)
;
}
on
(
hook
f
)
{
return
this
.
emitter
.
on
(
hook
f
)
;
}
off
(
hook
f
)
{
return
this
.
emitter
.
off
(
hook
f
)
;
}
once
(
hook
f
)
{
return
this
.
emitter
.
once
(
hook
f
)
;
}
emit
(
event
.
.
.
args
)
{
if
(
PROXIED_EVENTS
.
has
(
event
)
)
{
Services
.
ppmm
.
broadcastAsyncMessage
(
this
.
MESSAGE_EMIT_EVENT
{
event
args
}
)
;
}
return
this
.
emitter
.
emit
(
event
.
.
.
args
)
;
}
receiveMessage
(
{
name
data
}
)
{
if
(
name
=
=
=
this
.
MESSAGE_EMIT_EVENT
)
{
this
.
emitter
.
emit
(
data
.
event
.
.
.
data
.
args
)
;
}
}
testMessage
(
.
.
.
args
)
{
this
.
emit
(
"
test
-
harness
-
message
"
.
.
.
args
)
;
}
createPrincipal
(
uri
=
this
.
baseURI
originAttributes
=
{
}
)
{
return
Services
.
scriptSecurityManager
.
createContentPrincipal
(
uri
originAttributes
)
;
}
isExtensionURL
(
url
)
{
let
uri
=
Services
.
io
.
newURI
(
url
)
;
let
common
=
this
.
baseURI
.
getCommonBaseSpec
(
uri
)
;
return
common
=
=
this
.
baseURL
;
}
checkLoadURL
(
url
options
=
{
}
)
{
if
(
url
.
startsWith
(
this
.
baseURL
)
)
{
return
true
;
}
return
ExtensionCommon
.
checkLoadURL
(
url
this
.
principal
options
)
;
}
async
promiseLocales
(
locale
)
{
let
locales
=
await
StartupCache
.
locales
.
get
(
[
this
.
id
"
all_locales
"
]
(
)
=
>
this
.
_promiseLocaleMap
(
)
)
;
return
this
.
_setupLocaleData
(
locales
)
;
}
readLocaleFile
(
locale
)
{
return
StartupCache
.
locales
.
get
(
[
this
.
id
this
.
version
locale
]
(
)
=
>
super
.
readLocaleFile
(
locale
)
)
.
then
(
result
=
>
{
this
.
localeData
.
messages
.
set
(
locale
result
)
;
}
)
;
}
get
manifestCacheKey
(
)
{
return
[
this
.
id
this
.
version
Services
.
locale
.
appLocaleAsBCP47
]
;
}
get
isPrivileged
(
)
{
return
(
this
.
addonData
.
signedState
=
=
=
AddonManager
.
SIGNEDSTATE_PRIVILEGED
|
|
this
.
addonData
.
signedState
=
=
=
AddonManager
.
SIGNEDSTATE_SYSTEM
|
|
this
.
addonData
.
builtIn
|
|
(
AddonSettings
.
EXPERIMENTS_ENABLED
&
&
this
.
addonData
.
temporarilyInstalled
)
)
;
}
get
experimentsAllowed
(
)
{
return
AddonSettings
.
EXPERIMENTS_ENABLED
|
|
this
.
isPrivileged
;
}
saveStartupData
(
)
{
if
(
this
.
dontSaveStartupData
)
{
return
;
}
XPIProvider
.
setStartupData
(
this
.
id
this
.
startupData
)
;
}
parseManifest
(
)
{
return
StartupCache
.
manifests
.
get
(
this
.
manifestCacheKey
(
)
=
>
super
.
parseManifest
(
)
)
;
}
async
cachePermissions
(
)
{
let
manifestData
=
await
this
.
parseManifest
(
)
;
manifestData
.
originPermissions
=
this
.
allowedOrigins
.
patterns
.
map
(
pat
=
>
pat
.
pattern
)
;
manifestData
.
permissions
=
this
.
permissions
;
return
StartupCache
.
manifests
.
set
(
this
.
manifestCacheKey
manifestData
)
;
}
async
loadManifest
(
)
{
let
manifest
=
await
super
.
loadManifest
(
)
;
if
(
this
.
errors
.
length
)
{
return
Promise
.
reject
(
{
errors
:
this
.
errors
}
)
;
}
return
manifest
;
}
get
extensionPageCSP
(
)
{
const
{
content_security_policy
}
=
this
.
manifest
;
if
(
content_security_policy
&
&
typeof
content_security_policy
=
=
=
"
object
"
)
{
return
content_security_policy
.
extension_pages
;
}
return
content_security_policy
;
}
get
contentScriptCSP
(
)
{
let
{
content_security_policy
}
=
this
.
manifest
;
if
(
content_security_policy
&
&
typeof
content_security_policy
=
=
=
"
object
"
)
{
return
(
content_security_policy
.
content_scripts
|
|
content_security_policy
.
isolated_world
)
;
}
}
get
backgroundScripts
(
)
{
return
this
.
manifest
.
background
&
&
this
.
manifest
.
background
.
scripts
;
}
get
optionalPermissions
(
)
{
return
this
.
manifest
.
optional_permissions
;
}
get
privateBrowsingAllowed
(
)
{
return
this
.
policy
.
privateBrowsingAllowed
;
}
canAccessWindow
(
window
)
{
return
this
.
policy
.
canAccessWindow
(
window
)
;
}
serialize
(
)
{
return
{
id
:
this
.
id
uuid
:
this
.
uuid
name
:
this
.
name
extensionPageCSP
:
this
.
extensionPageCSP
contentScriptCSP
:
this
.
contentScriptCSP
instanceId
:
this
.
instanceId
resourceURL
:
this
.
resourceURL
contentScripts
:
this
.
contentScripts
webAccessibleResources
:
this
.
webAccessibleResources
.
map
(
res
=
>
res
.
glob
)
allowedOrigins
:
this
.
allowedOrigins
.
patterns
.
map
(
pat
=
>
pat
.
pattern
)
permissions
:
this
.
permissions
optionalPermissions
:
this
.
optionalPermissions
isPrivileged
:
this
.
isPrivileged
}
;
}
serializeExtended
(
)
{
return
{
backgroundScripts
:
this
.
backgroundScripts
childModules
:
this
.
modules
&
&
this
.
modules
.
child
dependencies
:
this
.
dependencies
schemaURLs
:
this
.
schemaURLs
}
;
}
broadcast
(
msg
data
)
{
return
new
Promise
(
resolve
=
>
{
let
{
ppmm
}
=
Services
;
let
children
=
new
Set
(
)
;
for
(
let
i
=
0
;
i
<
ppmm
.
childCount
;
i
+
+
)
{
children
.
add
(
ppmm
.
getChildAt
(
i
)
)
;
}
let
maybeResolve
;
function
listener
(
data
)
{
children
.
delete
(
data
.
target
)
;
maybeResolve
(
)
;
}
function
observer
(
subject
topic
data
)
{
children
.
delete
(
subject
)
;
maybeResolve
(
)
;
}
maybeResolve
=
(
)
=
>
{
if
(
children
.
size
=
=
=
0
)
{
ppmm
.
removeMessageListener
(
msg
+
"
Complete
"
listener
)
;
Services
.
obs
.
removeObserver
(
observer
"
message
-
manager
-
close
"
)
;
Services
.
obs
.
removeObserver
(
observer
"
message
-
manager
-
disconnect
"
)
;
resolve
(
)
;
}
}
;
ppmm
.
addMessageListener
(
msg
+
"
Complete
"
listener
true
)
;
Services
.
obs
.
addObserver
(
observer
"
message
-
manager
-
close
"
)
;
Services
.
obs
.
addObserver
(
observer
"
message
-
manager
-
disconnect
"
)
;
ppmm
.
broadcastAsyncMessage
(
msg
data
)
;
}
)
;
}
setSharedData
(
key
value
)
{
key
=
extension
/
{
this
.
id
}
/
{
key
}
;
this
.
sharedDataKeys
.
add
(
key
)
;
sharedData
.
set
(
key
value
)
;
}
getSharedData
(
key
value
)
{
key
=
extension
/
{
this
.
id
}
/
{
key
}
;
return
sharedData
.
get
(
key
)
;
}
initSharedData
(
)
{
this
.
setSharedData
(
"
"
this
.
serialize
(
)
)
;
this
.
setSharedData
(
"
extendedData
"
this
.
serializeExtended
(
)
)
;
this
.
setSharedData
(
"
locales
"
this
.
localeData
.
serialize
(
)
)
;
this
.
setSharedData
(
"
manifest
"
this
.
manifest
)
;
this
.
updateContentScripts
(
)
;
}
updateContentScripts
(
)
{
this
.
setSharedData
(
"
contentScripts
"
this
.
registeredContentScripts
)
;
}
runManifest
(
manifest
)
{
let
promises
=
[
]
;
let
addPromise
=
(
name
fn
)
=
>
{
promises
.
push
(
this
.
addStartupStatePromise
(
name
fn
)
)
;
}
;
for
(
let
directive
in
manifest
)
{
if
(
manifest
[
directive
]
!
=
=
null
)
{
addPromise
(
asyncEmitManifestEntry
(
"
{
directive
}
"
)
(
)
=
>
Management
.
asyncEmitManifestEntry
(
this
directive
)
)
;
}
}
activeExtensionIDs
.
add
(
this
.
id
)
;
sharedData
.
set
(
"
extensions
/
activeIDs
"
activeExtensionIDs
)
;
pendingExtensions
.
delete
(
this
.
id
)
;
sharedData
.
set
(
"
extensions
/
pending
"
pendingExtensions
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
this
.
broadcast
(
"
Extension
:
Startup
"
this
.
id
)
;
return
Promise
.
all
(
promises
)
;
}
callOnClose
(
obj
)
{
this
.
onShutdown
.
add
(
obj
)
;
}
forgetOnClose
(
obj
)
{
this
.
onShutdown
.
delete
(
obj
)
;
}
get
builtinMessages
(
)
{
return
new
Map
(
[
[
"
extension_id
"
this
.
uuid
]
]
)
;
}
async
initLocale
(
locale
=
undefined
)
{
if
(
locale
=
=
=
undefined
)
{
let
locales
=
await
this
.
promiseLocales
(
)
;
let
matches
=
Services
.
locale
.
negotiateLanguages
(
Services
.
locale
.
appLocalesAsBCP47
Array
.
from
(
locales
.
keys
(
)
)
this
.
defaultLocale
)
;
locale
=
matches
[
0
]
;
}
return
super
.
initLocale
(
locale
)
;
}
updatePermissions
(
reason
)
{
const
{
principal
}
=
this
;
const
testPermission
=
perm
=
>
Services
.
perms
.
testPermissionFromPrincipal
(
principal
perm
)
;
const
addUnlimitedStoragePermissions
=
(
)
=
>
{
Services
.
perms
.
addFromPrincipal
(
principal
"
WebExtensions
-
unlimitedStorage
"
Services
.
perms
.
ALLOW_ACTION
)
;
Services
.
perms
.
addFromPrincipal
(
principal
"
indexedDB
"
Services
.
perms
.
ALLOW_ACTION
)
;
Services
.
perms
.
addFromPrincipal
(
principal
"
persistent
-
storage
"
Services
.
perms
.
ALLOW_ACTION
)
;
}
;
if
(
reason
!
=
=
"
APP_STARTUP
"
&
&
reason
!
=
=
"
APP_SHUTDOWN
"
)
{
if
(
this
.
hasPermission
(
"
unlimitedStorage
"
)
)
{
addUnlimitedStoragePermissions
(
)
;
}
else
{
Services
.
perms
.
removeFromPrincipal
(
principal
"
WebExtensions
-
unlimitedStorage
"
)
;
Services
.
perms
.
removeFromPrincipal
(
principal
"
indexedDB
"
)
;
Services
.
perms
.
removeFromPrincipal
(
principal
"
persistent
-
storage
"
)
;
}
}
else
if
(
reason
=
=
=
"
APP_STARTUP
"
&
&
this
.
hasPermission
(
"
unlimitedStorage
"
)
&
&
(
testPermission
(
"
indexedDB
"
)
!
=
=
Services
.
perms
.
ALLOW_ACTION
|
|
testPermission
(
"
persistent
-
storage
"
)
!
=
=
Services
.
perms
.
ALLOW_ACTION
)
)
{
addUnlimitedStoragePermissions
(
)
;
}
if
(
reason
!
=
=
"
APP_SHUTDOWN
"
)
{
if
(
this
.
hasPermission
(
"
geolocation
"
)
)
{
if
(
testPermission
(
"
geo
"
)
=
=
=
Services
.
perms
.
UNKNOWN_ACTION
)
{
Services
.
perms
.
addFromPrincipal
(
principal
"
geo
"
Services
.
perms
.
ALLOW_ACTION
Services
.
perms
.
EXPIRE_SESSION
)
;
}
}
else
if
(
reason
!
=
=
"
APP_STARTUP
"
&
&
testPermission
(
"
geo
"
)
=
=
=
Services
.
perms
.
ALLOW_ACTION
)
{
Services
.
perms
.
removeFromPrincipal
(
principal
"
geo
"
)
;
}
}
}
static
async
migratePrivateBrowsing
(
addonData
)
{
if
(
addonData
.
incognito
!
=
=
"
not_allowed
"
)
{
ExtensionPermissions
.
add
(
addonData
.
id
{
permissions
:
[
PRIVATE_ALLOWED_PERMISSION
]
origins
:
[
]
}
)
;
await
StartupCache
.
clearAddonData
(
addonData
.
id
)
;
AMTelemetry
.
recordActionEvent
(
{
extra
:
{
addonId
:
addonData
.
id
}
object
:
"
appUpgrade
"
action
:
"
privateBrowsingAllowed
"
value
:
"
on
"
}
)
;
}
}
async
startup
(
)
{
this
.
state
=
"
Startup
"
;
let
resolveReadyPromise
;
let
readyPromise
=
new
Promise
(
resolve
=
>
{
resolveReadyPromise
=
resolve
;
}
)
;
this
.
policy
=
new
WebExtensionPolicy
(
{
id
:
this
.
id
mozExtensionHostname
:
this
.
uuid
baseURL
:
this
.
resourceURL
isPrivileged
:
this
.
isPrivileged
allowedOrigins
:
new
MatchPatternSet
(
[
]
)
localizeCallback
(
)
{
}
readyPromise
}
)
;
this
.
policy
.
extension
=
this
;
if
(
!
WebExtensionPolicy
.
getByID
(
this
.
id
)
)
{
this
.
policy
.
active
=
true
;
}
pendingExtensions
.
set
(
this
.
id
{
mozExtensionHostname
:
this
.
uuid
baseURL
:
this
.
resourceURL
isPrivileged
:
this
.
isPrivileged
}
)
;
sharedData
.
set
(
"
extensions
/
pending
"
pendingExtensions
)
;
ExtensionTelemetry
.
extensionStartup
.
stopwatchStart
(
this
)
;
try
{
this
.
state
=
"
Startup
:
Loading
manifest
"
;
await
this
.
loadManifest
(
)
;
this
.
state
=
"
Startup
:
Loaded
manifest
"
;
if
(
!
this
.
hasShutdown
)
{
this
.
state
=
"
Startup
:
Init
locale
"
;
await
this
.
initLocale
(
)
;
this
.
state
=
"
Startup
:
Initted
locale
"
;
}
if
(
this
.
errors
.
length
)
{
return
Promise
.
reject
(
{
errors
:
this
.
errors
}
)
;
}
if
(
this
.
hasShutdown
)
{
return
;
}
if
(
!
allowPrivateBrowsingByDefault
)
{
let
isAllowed
=
this
.
permissions
.
has
(
PRIVATE_ALLOWED_PERMISSION
)
;
if
(
this
.
manifest
.
incognito
=
=
=
"
not_allowed
"
)
{
if
(
isAllowed
)
{
ExtensionPermissions
.
remove
(
this
.
id
{
permissions
:
[
PRIVATE_ALLOWED_PERMISSION
]
origins
:
[
]
}
)
;
this
.
permissions
.
delete
(
PRIVATE_ALLOWED_PERMISSION
)
;
}
}
else
if
(
!
isAllowed
&
&
this
.
isPrivileged
&
&
!
this
.
addonData
.
temporarilyInstalled
)
{
ExtensionPermissions
.
add
(
this
.
id
{
permissions
:
[
PRIVATE_ALLOWED_PERMISSION
]
origins
:
[
]
}
)
;
this
.
permissions
.
add
(
PRIVATE_ALLOWED_PERMISSION
)
;
}
}
if
(
this
.
manifest
.
devtools_page
&
&
!
this
.
manifest
.
optional_permissions
.
includes
(
"
devtools
"
)
)
{
ExtensionPermissions
.
add
(
this
.
id
{
permissions
:
[
"
devtools
"
]
origins
:
[
]
}
)
;
this
.
permissions
.
add
(
"
devtools
"
)
;
}
GlobalManager
.
init
(
this
)
;
this
.
initSharedData
(
)
;
this
.
policy
.
active
=
false
;
this
.
policy
=
ExtensionProcessScript
.
initExtension
(
this
)
;
this
.
policy
.
extension
=
this
;
this
.
updatePermissions
(
this
.
startupReason
)
;
if
(
this
.
hasPermission
(
"
storage
"
)
)
{
if
(
!
ExtensionStorageIDB
.
isBackendEnabled
)
{
this
.
setSharedData
(
"
storageIDBBackend
"
false
)
;
}
else
if
(
ExtensionStorageIDB
.
isMigratedExtension
(
this
)
)
{
this
.
setSharedData
(
"
storageIDBBackend
"
true
)
;
this
.
setSharedData
(
"
storageIDBPrincipal
"
ExtensionStorageIDB
.
getStoragePrincipal
(
this
)
)
;
}
else
if
(
this
.
startupReason
=
=
=
"
ADDON_INSTALL
"
&
&
!
Services
.
prefs
.
getBoolPref
(
LEAVE_STORAGE_PREF
false
)
)
{
ExtensionStorageIDB
.
setMigratedExtensionPref
(
this
true
)
;
this
.
setSharedData
(
"
storageIDBBackend
"
true
)
;
this
.
setSharedData
(
"
storageIDBPrincipal
"
ExtensionStorageIDB
.
getStoragePrincipal
(
this
)
)
;
}
}
resolveReadyPromise
(
this
.
policy
)
;
this
.
emit
(
"
startup
"
this
)
;
this
.
startupStates
.
clear
(
)
;
await
Promise
.
all
(
[
this
.
addStartupStatePromise
(
"
Startup
:
Emit
startup
"
(
)
=
>
Management
.
emit
(
"
startup
"
this
)
)
this
.
addStartupStatePromise
(
"
Startup
:
Run
manifest
"
(
)
=
>
this
.
runManifest
(
this
.
manifest
)
)
]
)
;
this
.
state
=
"
Startup
:
Ran
manifest
"
;
Management
.
emit
(
"
ready
"
this
)
;
this
.
emit
(
"
ready
"
)
;
this
.
state
=
"
Startup
:
Complete
"
;
}
catch
(
errors
)
{
this
.
state
=
Startup
:
Error
:
{
errors
}
;
for
(
let
e
of
[
]
.
concat
(
errors
)
)
{
dump
(
Extension
error
:
{
e
.
message
|
|
e
}
{
e
.
filename
|
|
e
.
fileName
}
:
{
e
.
lineNumber
}
:
:
{
e
.
stack
|
|
new
Error
(
)
.
stack
}
\
n
)
;
Cu
.
reportError
(
e
)
;
}
if
(
this
.
policy
)
{
this
.
policy
.
active
=
false
;
}
this
.
cleanupGeneratedFile
(
)
;
throw
errors
;
}
finally
{
ExtensionTelemetry
.
extensionStartup
.
stopwatchFinish
(
this
)
;
}
}
cleanupGeneratedFile
(
)
{
if
(
!
this
.
cleanupFile
)
{
return
;
}
let
file
=
this
.
cleanupFile
;
this
.
cleanupFile
=
null
;
Services
.
obs
.
removeObserver
(
this
"
xpcom
-
shutdown
"
)
;
return
this
.
broadcast
(
"
Extension
:
FlushJarCache
"
{
path
:
file
.
path
}
)
.
then
(
(
)
=
>
{
file
.
remove
(
false
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
async
shutdown
(
reason
)
{
this
.
state
=
"
Shutdown
"
;
this
.
hasShutdown
=
true
;
if
(
!
this
.
policy
)
{
return
;
}
if
(
this
.
hasPermission
(
"
storage
"
)
&
&
ExtensionStorageIDB
.
selectedBackendPromises
.
has
(
this
)
)
{
this
.
state
=
"
Shutdown
:
Storage
"
;
try
{
await
ExtensionStorageIDB
.
selectedBackendPromises
.
get
(
this
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
Error
while
waiting
for
extension
data
migration
on
shutdown
:
{
this
.
policy
.
debugName
}
-
{
err
.
message
}
:
:
{
err
.
stack
}
)
;
}
this
.
state
=
"
Shutdown
:
Storage
complete
"
;
}
if
(
this
.
rootURI
instanceof
Ci
.
nsIJARURI
)
{
this
.
state
=
"
Shutdown
:
Flush
jar
cache
"
;
let
file
=
this
.
rootURI
.
JARFile
.
QueryInterface
(
Ci
.
nsIFileURL
)
.
file
;
Services
.
ppmm
.
broadcastAsyncMessage
(
"
Extension
:
FlushJarCache
"
{
path
:
file
.
path
}
)
;
this
.
state
=
"
Shutdown
:
Flushed
jar
cache
"
;
}
const
isAppShutdown
=
reason
=
=
=
"
APP_SHUTDOWN
"
;
if
(
this
.
cleanupFile
|
|
!
isAppShutdown
)
{
StartupCache
.
clearAddonData
(
this
.
id
)
;
}
activeExtensionIDs
.
delete
(
this
.
id
)
;
sharedData
.
set
(
"
extensions
/
activeIDs
"
activeExtensionIDs
)
;
for
(
let
key
of
this
.
sharedDataKeys
)
{
sharedData
.
delete
(
key
)
;
}
Services
.
ppmm
.
removeMessageListener
(
this
.
MESSAGE_EMIT_EVENT
this
)
;
this
.
updatePermissions
(
reason
)
;
if
(
!
this
.
manifest
)
{
this
.
state
=
"
Shutdown
:
Complete
:
No
manifest
"
;
this
.
policy
.
active
=
false
;
return
this
.
cleanupGeneratedFile
(
)
;
}
GlobalManager
.
uninit
(
this
)
;
for
(
let
obj
of
this
.
onShutdown
)
{
obj
.
close
(
)
;
}
ParentAPIManager
.
shutdownExtension
(
this
.
id
reason
)
;
Management
.
emit
(
"
shutdown
"
this
)
;
this
.
emit
(
"
shutdown
"
isAppShutdown
)
;
const
TIMED_OUT
=
Symbol
(
)
;
this
.
state
=
"
Shutdown
:
Emit
shutdown
"
;
let
result
=
await
Promise
.
race
(
[
this
.
broadcast
(
"
Extension
:
Shutdown
"
{
id
:
this
.
id
}
)
promiseTimeout
(
CHILD_SHUTDOWN_TIMEOUT_MS
)
.
then
(
(
)
=
>
TIMED_OUT
)
]
)
;
this
.
state
=
Shutdown
:
Emitted
shutdown
:
{
result
=
=
=
TIMED_OUT
}
;
if
(
result
=
=
=
TIMED_OUT
)
{
Cu
.
reportError
(
Timeout
while
waiting
for
extension
child
to
shutdown
:
{
this
.
policy
.
debugName
}
)
;
}
MessageChannel
.
abortResponses
(
{
extensionId
:
this
.
id
}
)
;
this
.
policy
.
active
=
false
;
this
.
state
=
Shutdown
:
Complete
(
{
this
.
cleanupFile
}
)
;
return
this
.
cleanupGeneratedFile
(
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
"
xpcom
-
shutdown
"
)
{
this
.
cleanupGeneratedFile
(
)
;
}
}
get
name
(
)
{
return
this
.
manifest
.
name
;
}
get
optionalOrigins
(
)
{
if
(
this
.
_optionalOrigins
=
=
null
)
{
let
{
restrictSchemes
isPrivileged
}
=
this
;
let
origins
=
this
.
manifest
.
optional_permissions
.
filter
(
perm
=
>
classifyPermission
(
perm
restrictSchemes
isPrivileged
)
.
origin
)
;
this
.
_optionalOrigins
=
new
MatchPatternSet
(
origins
{
restrictSchemes
ignorePath
:
true
}
)
;
}
return
this
.
_optionalOrigins
;
}
}
class
Dictionary
extends
ExtensionData
{
constructor
(
addonData
startupReason
)
{
super
(
addonData
.
resourceURI
)
;
this
.
id
=
addonData
.
id
;
this
.
startupData
=
addonData
.
startupData
;
}
static
getBootstrapScope
(
)
{
return
new
DictionaryBootstrapScope
(
)
;
}
async
startup
(
reason
)
{
this
.
dictionaries
=
{
}
;
for
(
let
[
lang
path
]
of
Object
.
entries
(
this
.
startupData
.
dictionaries
)
)
{
let
uri
=
Services
.
io
.
newURI
(
path
.
slice
(
0
-
4
)
+
"
.
aff
"
null
this
.
rootURI
)
;
this
.
dictionaries
[
lang
]
=
uri
;
spellCheck
.
addDictionary
(
lang
uri
)
;
}
Management
.
emit
(
"
ready
"
this
)
;
}
async
shutdown
(
reason
)
{
if
(
reason
!
=
=
"
APP_SHUTDOWN
"
)
{
XPIProvider
.
unregisterDictionaries
(
this
.
dictionaries
)
;
}
}
}
class
Langpack
extends
ExtensionData
{
constructor
(
addonData
startupReason
)
{
super
(
addonData
.
resourceURI
)
;
this
.
startupData
=
addonData
.
startupData
;
this
.
manifestCacheKey
=
[
addonData
.
id
addonData
.
version
]
;
}
static
getBootstrapScope
(
)
{
return
new
LangpackBootstrapScope
(
)
;
}
async
promiseLocales
(
locale
)
{
let
locales
=
await
StartupCache
.
locales
.
get
(
[
this
.
id
"
all_locales
"
]
(
)
=
>
this
.
_promiseLocaleMap
(
)
)
;
return
this
.
_setupLocaleData
(
locales
)
;
}
parseManifest
(
)
{
return
StartupCache
.
manifests
.
get
(
this
.
manifestCacheKey
(
)
=
>
super
.
parseManifest
(
)
)
;
}
async
startup
(
reason
)
{
this
.
chromeRegistryHandle
=
null
;
if
(
this
.
startupData
.
chromeEntries
.
length
)
{
const
manifestURI
=
Services
.
io
.
newURI
(
"
manifest
.
json
"
null
this
.
rootURI
)
;
this
.
chromeRegistryHandle
=
aomStartup
.
registerChrome
(
manifestURI
this
.
startupData
.
chromeEntries
)
;
}
const
langpackId
=
this
.
startupData
.
langpackId
;
const
l10nRegistrySources
=
this
.
startupData
.
l10nRegistrySources
;
resourceProtocol
.
setSubstitution
(
langpackId
this
.
rootURI
)
;
for
(
const
[
sourceName
basePath
]
of
Object
.
entries
(
l10nRegistrySources
)
)
{
L10nRegistry
.
registerSource
(
new
FileSource
(
{
sourceName
}
-
{
langpackId
}
this
.
startupData
.
languages
resource
:
/
/
{
langpackId
}
/
{
basePath
}
localization
/
{
locale
}
/
)
)
;
}
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
langpack
:
this
}
}
"
webextension
-
langpack
-
startup
"
)
;
}
async
shutdown
(
reason
)
{
if
(
reason
=
=
=
"
APP_SHUTDOWN
"
)
{
return
;
}
for
(
const
sourceName
of
Object
.
keys
(
this
.
startupData
.
l10nRegistrySources
)
)
{
L10nRegistry
.
removeSource
(
{
sourceName
}
-
{
this
.
startupData
.
langpackId
}
)
;
}
if
(
this
.
chromeRegistryHandle
)
{
this
.
chromeRegistryHandle
.
destruct
(
)
;
this
.
chromeRegistryHandle
=
null
;
}
resourceProtocol
.
setSubstitution
(
this
.
startupData
.
langpackId
null
)
;
}
}
