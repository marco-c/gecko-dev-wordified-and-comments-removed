"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExtensionParent
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
BroadcastConduit
:
"
resource
:
/
/
gre
/
modules
/
ConduitsParent
.
jsm
"
DeferredTask
:
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
DevToolsShim
:
"
chrome
:
/
/
devtools
-
startup
/
content
/
DevToolsShim
.
jsm
"
ExtensionData
:
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
ExtensionActivityLog
:
"
resource
:
/
/
gre
/
modules
/
ExtensionActivityLog
.
jsm
"
GeckoViewConnection
:
"
resource
:
/
/
gre
/
modules
/
GeckoViewWebExtension
.
jsm
"
MessageManagerProxy
:
"
resource
:
/
/
gre
/
modules
/
MessageManagerProxy
.
jsm
"
NativeApp
:
"
resource
:
/
/
gre
/
modules
/
NativeMessaging
.
jsm
"
PerformanceCounters
:
"
resource
:
/
/
gre
/
modules
/
PerformanceCounters
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
Schemas
:
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
getErrorNameForTelemetry
:
"
resource
:
/
/
gre
/
modules
/
ExtensionTelemetry
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
lazy
{
aomStartup
:
[
"
mozilla
.
org
/
addons
/
addon
-
manager
-
startup
;
1
"
"
amIAddonManagerStartup
"
]
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
gTimingEnabled
"
"
extensions
.
webextensions
.
enablePerformanceCounters
"
false
)
;
const
{
ExtensionCommon
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
BaseContext
CanOfAPIs
SchemaAPIManager
SpreadArgs
defineLazyGetter
}
=
ExtensionCommon
;
var
{
DefaultMap
DefaultWeakMap
ExtensionError
promiseDocumentLoaded
promiseEvent
promiseObserved
}
=
ExtensionUtils
;
const
ERROR_NO_RECEIVERS
=
"
Could
not
establish
connection
.
Receiving
end
does
not
exist
.
"
;
const
BASE_SCHEMA
=
"
chrome
:
/
/
extensions
/
content
/
schemas
/
manifest
.
json
"
;
const
CATEGORY_EXTENSION_MODULES
=
"
webextension
-
modules
"
;
const
CATEGORY_EXTENSION_SCHEMAS
=
"
webextension
-
schemas
"
;
const
CATEGORY_EXTENSION_SCRIPTS
=
"
webextension
-
scripts
"
;
let
schemaURLs
=
new
Set
(
)
;
schemaURLs
.
add
(
"
chrome
:
/
/
extensions
/
content
/
schemas
/
experiments
.
json
"
)
;
let
GlobalManager
;
let
ParentAPIManager
;
let
StartupCache
;
function
verifyActorForContext
(
actor
context
)
{
if
(
JSWindowActorParent
.
isInstance
(
actor
)
)
{
let
target
=
actor
.
browsingContext
.
top
.
embedderElement
;
if
(
context
.
parentMessageManager
!
=
=
target
.
messageManager
)
{
throw
new
Error
(
"
Got
message
on
unexpected
message
manager
"
)
;
}
}
else
if
(
JSProcessActorParent
.
isInstance
(
actor
)
)
{
if
(
actor
.
manager
.
remoteType
!
=
=
context
.
extension
.
remoteType
)
{
throw
new
Error
(
"
Got
message
from
unexpected
process
"
)
;
}
}
}
let
apiManager
=
new
(
class
extends
SchemaAPIManager
{
constructor
(
)
{
super
(
"
main
"
lazy
.
Schemas
)
;
this
.
initialized
=
null
;
this
.
on
(
"
startup
"
(
e
extension
)
=
>
{
return
extension
.
apiManager
.
onStartup
(
extension
)
;
}
)
;
this
.
on
(
"
update
"
async
(
e
{
id
resourceURI
isPrivileged
}
)
=
>
{
let
modules
=
this
.
eventModules
.
get
(
"
update
"
)
;
if
(
modules
.
size
=
=
0
)
{
return
;
}
let
extension
=
new
lazy
.
ExtensionData
(
resourceURI
isPrivileged
)
;
await
extension
.
loadManifest
(
)
;
return
Promise
.
all
(
Array
.
from
(
modules
)
.
map
(
async
apiName
=
>
{
let
module
=
await
this
.
asyncLoadModule
(
apiName
)
;
module
.
onUpdate
(
id
extension
.
manifest
)
;
}
)
)
;
}
)
;
this
.
on
(
"
uninstall
"
(
e
{
id
}
)
=
>
{
let
modules
=
this
.
eventModules
.
get
(
"
uninstall
"
)
;
return
Promise
.
all
(
Array
.
from
(
modules
)
.
map
(
async
apiName
=
>
{
let
module
=
await
this
.
asyncLoadModule
(
apiName
)
;
return
module
.
onUninstall
(
id
)
;
}
)
)
;
}
)
;
let
disabledIds
=
lazy
.
AddonManager
.
getStartupChanges
(
lazy
.
AddonManager
.
STARTUP_CHANGE_DISABLED
)
;
if
(
disabledIds
.
length
)
{
this
.
_callHandlers
(
disabledIds
"
disable
"
"
onDisable
"
)
;
}
let
uninstalledIds
=
lazy
.
AddonManager
.
getStartupChanges
(
lazy
.
AddonManager
.
STARTUP_CHANGE_UNINSTALLED
)
;
if
(
uninstalledIds
.
length
)
{
this
.
_callHandlers
(
uninstalledIds
"
uninstall
"
"
onUninstall
"
)
;
}
}
getModuleJSONURLs
(
)
{
return
Array
.
from
(
Services
.
catMan
.
enumerateCategory
(
CATEGORY_EXTENSION_MODULES
)
(
{
value
}
)
=
>
value
)
;
}
lazyInit
(
)
{
if
(
this
.
initialized
)
{
return
this
.
initialized
;
}
let
modulesPromise
=
StartupCache
.
other
.
get
(
[
"
parentModules
"
]
(
)
=
>
this
.
loadModuleJSON
(
this
.
getModuleJSONURLs
(
)
)
)
;
let
scriptURLs
=
[
]
;
for
(
let
{
value
}
of
Services
.
catMan
.
enumerateCategory
(
CATEGORY_EXTENSION_SCRIPTS
)
)
{
scriptURLs
.
push
(
value
)
;
}
let
promise
=
(
async
(
)
=
>
{
let
scripts
=
await
Promise
.
all
(
scriptURLs
.
map
(
url
=
>
ChromeUtils
.
compileScript
(
url
)
)
)
;
this
.
initModuleData
(
await
modulesPromise
)
;
this
.
initGlobal
(
)
;
for
(
let
script
of
scripts
)
{
script
.
executeInGlobal
(
this
.
global
)
;
}
return
lazy
.
Schemas
.
load
(
BASE_SCHEMA
)
.
then
(
(
)
=
>
{
let
promises
=
[
]
;
for
(
let
{
value
}
of
Services
.
catMan
.
enumerateCategory
(
CATEGORY_EXTENSION_SCHEMAS
)
)
{
promises
.
push
(
lazy
.
Schemas
.
load
(
value
)
)
;
}
for
(
let
[
url
{
content
}
]
of
this
.
schemaURLs
)
{
promises
.
push
(
lazy
.
Schemas
.
load
(
url
content
)
)
;
}
for
(
let
url
of
schemaURLs
)
{
promises
.
push
(
lazy
.
Schemas
.
load
(
url
)
)
;
}
return
Promise
.
all
(
promises
)
.
then
(
(
)
=
>
{
lazy
.
Schemas
.
updateSharedSchemas
(
)
;
}
)
;
}
)
;
}
)
(
)
;
Services
.
mm
.
addMessageListener
(
"
Extension
:
GetFrameData
"
this
)
;
this
.
initialized
=
promise
;
return
this
.
initialized
;
}
receiveMessage
(
{
target
}
)
{
let
data
=
GlobalManager
.
frameData
.
get
(
target
)
|
|
{
}
;
Object
.
assign
(
data
this
.
global
.
tabTracker
.
getBrowserData
(
target
)
)
;
return
data
;
}
_callHandlers
(
ids
event
method
)
{
let
promises
=
Array
.
from
(
this
.
eventModules
.
get
(
event
)
)
.
map
(
async
modName
=
>
{
let
module
=
await
this
.
asyncLoadModule
(
modName
)
;
return
ids
.
map
(
id
=
>
module
[
method
]
(
id
)
)
;
}
)
.
flat
(
)
;
if
(
event
=
=
=
"
disable
"
)
{
promises
.
push
(
.
.
.
ids
.
map
(
id
=
>
this
.
emit
(
"
disable
"
id
)
)
)
;
}
if
(
event
=
=
=
"
enabling
"
)
{
promises
.
push
(
.
.
.
ids
.
map
(
id
=
>
this
.
emit
(
"
enabling
"
id
)
)
)
;
}
lazy
.
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
Extension
API
{
event
}
handlers
for
{
ids
.
join
(
"
"
)
}
Promise
.
all
(
promises
)
)
;
}
}
)
(
)
;
const
ProxyMessenger
=
{
ports
:
new
Map
(
)
init
(
)
{
this
.
conduit
=
new
lazy
.
BroadcastConduit
(
ProxyMessenger
{
id
:
"
ProxyMessenger
"
reportOnClosed
:
"
portId
"
recv
:
[
"
PortConnect
"
"
PortMessage
"
"
NativeMessage
"
"
RuntimeMessage
"
]
cast
:
[
"
PortConnect
"
"
PortMessage
"
"
PortDisconnect
"
"
RuntimeMessage
"
]
}
)
;
}
openNative
(
nativeApp
sender
)
{
let
context
=
ParentAPIManager
.
getContextById
(
sender
.
childId
)
;
if
(
context
.
extension
.
hasPermission
(
"
geckoViewAddons
"
)
)
{
return
new
lazy
.
GeckoViewConnection
(
this
.
getSender
(
context
.
extension
sender
)
sender
.
actor
.
browsingContext
.
top
.
embedderElement
nativeApp
context
.
extension
.
hasPermission
(
"
nativeMessagingFromContent
"
)
)
;
}
else
if
(
sender
.
verified
)
{
return
new
lazy
.
NativeApp
(
context
nativeApp
)
;
}
sender
=
this
.
getSender
(
context
.
extension
sender
)
;
throw
new
Error
(
Native
messaging
not
allowed
:
{
JSON
.
stringify
(
sender
)
}
)
;
}
recvNativeMessage
(
{
nativeApp
holder
}
{
sender
}
)
{
const
app
=
this
.
openNative
(
nativeApp
sender
)
;
const
promiseSendMessage
=
app
.
sendMessage
(
holder
)
;
const
sendMessagePort
=
{
native
:
true
senderChildId
:
sender
.
childId
}
;
this
.
trackNativeAppPort
(
sendMessagePort
)
;
const
untrackSendMessage
=
(
)
=
>
this
.
untrackNativeAppPort
(
sendMessagePort
)
;
promiseSendMessage
.
then
(
untrackSendMessage
untrackSendMessage
)
;
return
promiseSendMessage
;
}
getSender
(
extension
source
)
{
let
sender
=
{
contextId
:
source
.
id
id
:
source
.
extensionId
envType
:
source
.
envType
url
:
source
.
url
}
;
if
(
JSWindowActorParent
.
isInstance
(
source
.
actor
)
)
{
let
browser
=
source
.
actor
.
browsingContext
.
top
.
embedderElement
;
let
data
=
browser
&
&
apiManager
.
global
.
tabTracker
.
getBrowserData
(
browser
)
;
if
(
data
?
.
tabId
>
0
)
{
sender
.
tab
=
extension
.
tabManager
.
get
(
data
.
tabId
null
)
?
.
convert
(
)
;
sender
.
frameId
=
source
.
frameId
;
}
}
return
sender
;
}
getTopBrowsingContextId
(
tabId
)
{
let
tab
=
apiManager
.
global
.
tabTracker
.
getTab
(
tabId
null
)
;
if
(
!
tab
|
|
(
tab
.
browser
|
|
tab
)
.
getAttribute
(
"
pending
"
)
=
=
=
"
true
"
)
{
throw
new
ExtensionError
(
ERROR_NO_RECEIVERS
)
;
}
let
browser
=
tab
.
linkedBrowser
|
|
tab
.
browser
;
return
browser
.
browsingContext
.
id
;
}
async
normalizeArgs
(
arg
sender
)
{
arg
.
extensionId
=
arg
.
extensionId
|
|
sender
.
extensionId
;
let
extension
=
GlobalManager
.
extensionMap
.
get
(
arg
.
extensionId
)
;
if
(
!
extension
)
{
return
Promise
.
reject
(
{
message
:
ERROR_NO_RECEIVERS
}
)
;
}
await
extension
.
wakeupBackground
?
.
(
)
;
arg
.
sender
=
this
.
getSender
(
extension
sender
)
;
arg
.
topBC
=
arg
.
tabId
&
&
this
.
getTopBrowsingContextId
(
arg
.
tabId
)
;
return
arg
.
tabId
?
"
tab
"
:
"
messenger
"
;
}
async
recvRuntimeMessage
(
arg
{
sender
}
)
{
arg
.
firstResponse
=
true
;
let
kind
=
await
this
.
normalizeArgs
(
arg
sender
)
;
let
result
=
await
this
.
conduit
.
castRuntimeMessage
(
kind
arg
)
;
if
(
!
result
)
{
return
Promise
.
reject
(
{
message
:
ERROR_NO_RECEIVERS
}
)
;
}
return
result
.
value
;
}
async
recvPortConnect
(
arg
{
sender
}
)
{
if
(
arg
.
native
)
{
let
port
=
this
.
openNative
(
arg
.
name
sender
)
.
onConnect
(
arg
.
portId
this
)
;
port
.
senderChildId
=
sender
.
childId
;
port
.
native
=
true
;
this
.
ports
.
set
(
arg
.
portId
port
)
;
this
.
trackNativeAppPort
(
port
)
;
return
;
}
let
resolvePort
;
this
.
ports
.
set
(
arg
.
portId
new
Promise
(
res
=
>
(
resolvePort
=
res
)
)
)
;
let
kind
=
await
this
.
normalizeArgs
(
arg
sender
)
;
let
all
=
await
this
.
conduit
.
castPortConnect
(
kind
arg
)
;
resolvePort
(
)
;
if
(
!
all
.
some
(
x
=
>
x
.
value
)
)
{
throw
new
ExtensionError
(
ERROR_NO_RECEIVERS
)
;
}
}
async
recvPortMessage
(
{
holder
}
{
sender
}
)
{
if
(
sender
.
native
)
{
return
this
.
ports
.
get
(
sender
.
portId
)
?
.
onPortMessage
(
holder
)
;
}
await
this
.
ports
.
get
(
sender
.
portId
)
;
this
.
sendPortMessage
(
sender
.
portId
holder
!
sender
.
source
)
;
}
recvConduitClosed
(
sender
)
{
let
app
=
this
.
ports
.
get
(
sender
.
portId
)
;
if
(
this
.
ports
.
delete
(
sender
.
portId
)
&
&
sender
.
native
)
{
this
.
untrackNativeAppPort
(
app
)
;
return
app
.
onPortDisconnect
(
)
;
}
this
.
sendPortDisconnect
(
sender
.
portId
null
!
sender
.
source
)
;
}
sendPortMessage
(
portId
holder
source
=
true
)
{
this
.
conduit
.
castPortMessage
(
"
port
"
{
portId
source
holder
}
)
;
}
sendPortDisconnect
(
portId
error
source
=
true
)
{
let
port
=
this
.
ports
.
get
(
portId
)
;
this
.
untrackNativeAppPort
(
port
)
;
this
.
conduit
.
castPortDisconnect
(
"
port
"
{
portId
source
error
}
)
;
this
.
ports
.
delete
(
portId
)
;
}
trackNativeAppPort
(
port
)
{
if
(
!
port
?
.
native
)
{
return
;
}
try
{
let
context
=
ParentAPIManager
.
getContextById
(
port
.
senderChildId
)
;
context
?
.
trackNativeAppPort
(
port
)
;
}
catch
{
}
}
untrackNativeAppPort
(
port
)
{
if
(
!
port
?
.
native
)
{
return
;
}
try
{
let
context
=
ParentAPIManager
.
getContextById
(
port
.
senderChildId
)
;
context
?
.
untrackNativeAppPort
(
port
)
;
}
catch
{
}
}
}
;
ProxyMessenger
.
init
(
)
;
GlobalManager
=
{
extensionMap
:
new
Map
(
)
initialized
:
false
frameData
:
new
WeakMap
(
)
init
(
extension
)
{
if
(
this
.
extensionMap
.
size
=
=
0
)
{
apiManager
.
on
(
"
extension
-
browser
-
inserted
"
this
.
_onExtensionBrowser
)
;
this
.
initialized
=
true
;
Services
.
ppmm
.
addMessageListener
(
"
Extension
:
SendPerformanceCounter
"
this
)
;
}
this
.
extensionMap
.
set
(
extension
.
id
extension
)
;
}
uninit
(
extension
)
{
this
.
extensionMap
.
delete
(
extension
.
id
)
;
if
(
this
.
extensionMap
.
size
=
=
0
&
&
this
.
initialized
)
{
apiManager
.
off
(
"
extension
-
browser
-
inserted
"
this
.
_onExtensionBrowser
)
;
this
.
initialized
=
false
;
Services
.
ppmm
.
removeMessageListener
(
"
Extension
:
SendPerformanceCounter
"
this
)
;
}
}
async
receiveMessage
(
{
name
data
}
)
{
switch
(
name
)
{
case
"
Extension
:
SendPerformanceCounter
"
:
lazy
.
PerformanceCounters
.
merge
(
data
.
counters
)
;
break
;
}
}
_onExtensionBrowser
(
type
browser
data
=
{
}
)
{
data
.
viewType
=
browser
.
getAttribute
(
"
webextension
-
view
-
type
"
)
;
if
(
data
.
viewType
)
{
GlobalManager
.
frameData
.
set
(
browser
data
)
;
}
}
getExtension
(
extensionId
)
{
return
this
.
extensionMap
.
get
(
extensionId
)
;
}
}
;
class
ProxyContextParent
extends
BaseContext
{
constructor
(
envType
extension
params
xulBrowser
principal
)
{
super
(
envType
extension
)
;
this
.
childId
=
params
.
childId
;
this
.
uri
=
Services
.
io
.
newURI
(
params
.
url
)
;
this
.
incognito
=
params
.
incognito
;
this
.
listenerPromises
=
new
Set
(
)
;
this
.
messageManagerProxy
=
xulBrowser
&
&
new
lazy
.
MessageManagerProxy
(
xulBrowser
)
;
Object
.
defineProperty
(
this
"
principal
"
{
value
:
principal
enumerable
:
true
configurable
:
true
}
)
;
this
.
listenerProxies
=
new
Map
(
)
;
this
.
pendingEventBrowser
=
null
;
this
.
callContextData
=
null
;
this
.
activeNativePorts
=
new
WeakSet
(
)
;
this
.
runListenerPromises
=
new
Set
(
)
;
apiManager
.
emit
(
"
proxy
-
context
-
load
"
this
)
;
}
trackRunListenerPromise
(
runListenerPromise
)
{
if
(
!
this
.
extension
|
|
!
this
.
isBackgroundContext
|
|
this
.
extension
.
persistentBackground
)
{
return
;
}
const
clearFromSet
=
(
)
=
>
this
.
runListenerPromises
.
delete
(
runListenerPromise
)
;
runListenerPromise
.
then
(
clearFromSet
clearFromSet
)
;
this
.
runListenerPromises
.
add
(
runListenerPromise
)
;
}
get
pendingRunListenerPromisesCount
(
)
{
return
this
.
runListenerPromises
.
size
;
}
trackNativeAppPort
(
port
)
{
if
(
!
port
?
.
native
|
|
!
this
.
isBackgroundContext
|
|
this
.
extension
?
.
persistentBackground
|
|
!
this
.
extension
)
{
return
;
}
this
.
activeNativePorts
.
add
(
port
)
;
}
untrackNativeAppPort
(
port
)
{
this
.
activeNativePorts
.
delete
(
port
)
;
}
get
hasActiveNativeAppPorts
(
)
{
return
!
!
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
this
.
activeNativePorts
)
.
length
;
}
withCallContextData
(
{
isHandlingUserInput
}
callable
)
{
if
(
this
.
callContextData
)
{
Cu
.
reportError
(
Unexpected
pre
-
existing
callContextData
on
"
{
this
.
extension
?
.
policy
.
debugName
}
"
contextId
{
this
.
contextId
}
)
;
}
try
{
this
.
callContextData
=
{
isHandlingUserInput
}
;
return
callable
(
)
;
}
finally
{
this
.
callContextData
=
null
;
}
}
async
withPendingBrowser
(
browser
callable
)
{
let
savedBrowser
=
this
.
pendingEventBrowser
;
this
.
pendingEventBrowser
=
browser
;
try
{
let
result
=
await
callable
(
)
;
return
result
;
}
finally
{
this
.
pendingEventBrowser
=
savedBrowser
;
}
}
logActivity
(
type
name
data
)
{
}
get
cloneScope
(
)
{
return
this
.
sandbox
;
}
applySafe
(
callback
args
)
{
return
this
.
applySafeWithoutClone
(
callback
args
)
;
}
get
xulBrowser
(
)
{
return
this
.
messageManagerProxy
?
.
eventTarget
;
}
get
parentMessageManager
(
)
{
return
this
.
messageManagerProxy
?
.
messageManager
;
}
shutdown
(
)
{
this
.
unload
(
)
;
}
unload
(
)
{
if
(
this
.
unloaded
)
{
return
;
}
this
.
messageManagerProxy
?
.
dispose
(
)
;
super
.
unload
(
)
;
apiManager
.
emit
(
"
proxy
-
context
-
unload
"
this
)
;
}
}
defineLazyGetter
(
ProxyContextParent
.
prototype
"
apiCan
"
function
(
)
{
let
obj
=
{
}
;
let
can
=
new
CanOfAPIs
(
this
this
.
extension
.
apiManager
obj
)
;
return
can
;
}
)
;
defineLazyGetter
(
ProxyContextParent
.
prototype
"
apiObj
"
function
(
)
{
return
this
.
apiCan
.
root
;
}
)
;
defineLazyGetter
(
ProxyContextParent
.
prototype
"
sandbox
"
function
(
)
{
return
Cu
.
Sandbox
(
this
.
principal
{
sandboxName
:
this
.
uri
.
spec
wantGlobalProperties
:
[
"
Blob
"
"
URL
"
]
}
)
;
}
)
;
class
ContentScriptContextParent
extends
ProxyContextParent
{
}
class
ExtensionPageContextParent
extends
ProxyContextParent
{
constructor
(
envType
extension
params
xulBrowser
)
{
super
(
envType
extension
params
xulBrowser
extension
.
principal
)
;
this
.
viewType
=
params
.
viewType
;
this
.
extension
.
views
.
add
(
this
)
;
extension
.
emit
(
"
extension
-
proxy
-
context
-
load
"
this
)
;
}
get
appWindow
(
)
{
let
win
=
this
.
xulBrowser
.
ownerGlobal
;
return
win
.
browsingContext
.
topChromeWindow
;
}
get
currentWindow
(
)
{
if
(
this
.
viewType
!
=
=
"
background
"
)
{
return
this
.
appWindow
;
}
}
get
tabId
(
)
{
let
{
tabTracker
}
=
apiManager
.
global
;
let
data
=
tabTracker
.
getBrowserData
(
this
.
xulBrowser
)
;
if
(
data
.
tabId
>
=
0
)
{
return
data
.
tabId
;
}
}
onBrowserChange
(
browser
)
{
super
.
onBrowserChange
(
browser
)
;
this
.
xulBrowser
=
browser
;
}
unload
(
)
{
super
.
unload
(
)
;
this
.
extension
.
views
.
delete
(
this
)
;
}
shutdown
(
)
{
apiManager
.
emit
(
"
page
-
shutdown
"
this
)
;
super
.
shutdown
(
)
;
}
}
class
DevToolsExtensionPageContextParent
extends
ExtensionPageContextParent
{
constructor
(
.
.
.
params
)
{
super
(
.
.
.
params
)
;
this
.
_devToolsCommands
=
null
;
this
.
_onNavigatedListeners
=
null
;
this
.
_onResourceAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
)
;
}
set
devToolsToolbox
(
toolbox
)
{
if
(
this
.
_devToolsToolbox
)
{
throw
new
Error
(
"
Cannot
set
the
context
DevTools
toolbox
twice
"
)
;
}
this
.
_devToolsToolbox
=
toolbox
;
}
get
devToolsToolbox
(
)
{
return
this
.
_devToolsToolbox
;
}
async
addOnNavigatedListener
(
listener
)
{
if
(
!
this
.
_onNavigatedListeners
)
{
this
.
_onNavigatedListeners
=
new
Set
(
)
;
await
this
.
devToolsToolbox
.
resourceCommand
.
watchResources
(
[
this
.
devToolsToolbox
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
_onResourceAvailable
ignoreExistingResources
:
true
}
)
;
}
this
.
_onNavigatedListeners
.
add
(
listener
)
;
}
removeOnNavigatedListener
(
listener
)
{
if
(
this
.
_onNavigatedListeners
)
{
this
.
_onNavigatedListeners
.
delete
(
listener
)
;
}
}
async
getDevToolsCommands
(
)
{
if
(
this
.
_devToolsCommandsPromise
)
{
return
this
.
_devToolsCommandsPromise
;
}
if
(
this
.
_devToolsCommands
)
{
return
this
.
_devToolsCommands
;
}
this
.
_devToolsCommandsPromise
=
(
async
(
)
=
>
{
const
commands
=
await
lazy
.
DevToolsShim
.
createCommandsForTabForWebExtension
(
this
.
devToolsToolbox
.
descriptorFront
.
localTab
)
;
await
commands
.
targetCommand
.
startListening
(
)
;
this
.
_devToolsCommands
=
commands
;
this
.
_devToolsCommandsPromise
=
null
;
return
commands
;
}
)
(
)
;
return
this
.
_devToolsCommandsPromise
;
}
unload
(
)
{
if
(
!
this
.
devToolsToolbox
)
{
return
;
}
if
(
this
.
_onNavigatedListeners
)
{
this
.
devToolsToolbox
.
resourceCommand
.
unwatchResources
(
[
this
.
devToolsToolbox
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
_onResourceAvailable
}
)
;
}
if
(
this
.
_devToolsCommands
)
{
this
.
_devToolsCommands
.
destroy
(
)
;
this
.
_devToolsCommands
=
null
;
}
if
(
this
.
_onNavigatedListeners
)
{
this
.
_onNavigatedListeners
.
clear
(
)
;
this
.
_onNavigatedListeners
=
null
;
}
this
.
_devToolsToolbox
=
null
;
super
.
unload
(
)
;
}
async
_onResourceAvailable
(
resources
)
{
for
(
const
resource
of
resources
)
{
const
{
targetFront
}
=
resource
;
if
(
targetFront
.
isTopLevel
&
&
resource
.
name
=
=
=
"
dom
-
complete
"
)
{
const
url
=
targetFront
.
localTab
.
linkedBrowser
.
currentURI
.
spec
;
for
(
const
listener
of
this
.
_onNavigatedListeners
)
{
listener
(
url
)
;
}
}
}
}
}
class
BackgroundWorkerContextParent
extends
ProxyContextParent
{
constructor
(
envType
extension
params
)
{
super
(
envType
extension
params
null
extension
.
principal
)
;
this
.
viewType
=
params
.
viewType
;
this
.
workerDescriptorId
=
params
.
workerDescriptorId
;
this
.
extension
.
views
.
add
(
this
)
;
extension
.
emit
(
"
extension
-
proxy
-
context
-
load
"
this
)
;
}
}
ParentAPIManager
=
{
proxyContexts
:
new
Map
(
)
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
close
"
)
;
this
.
conduit
=
new
lazy
.
BroadcastConduit
(
this
{
id
:
"
ParentAPIManager
"
reportOnClosed
:
"
childId
"
recv
:
[
"
CreateProxyContext
"
"
ContextLoaded
"
"
APICall
"
"
AddListener
"
"
RemoveListener
"
]
send
:
[
"
CallResult
"
]
query
:
[
"
RunListener
"
"
StreamFilterSuspendCancel
"
]
}
)
;
}
attachMessageManager
(
extension
processMessageManager
)
{
extension
.
parentMessageManager
=
processMessageManager
;
}
async
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
"
message
-
manager
-
close
"
)
{
let
mm
=
subject
;
for
(
let
[
childId
context
]
of
this
.
proxyContexts
)
{
if
(
context
.
parentMessageManager
=
=
=
mm
)
{
this
.
closeProxyContext
(
childId
)
;
}
}
for
(
let
extension
of
GlobalManager
.
extensionMap
.
values
(
)
)
{
if
(
extension
.
parentMessageManager
=
=
=
mm
)
{
extension
.
parentMessageManager
=
null
;
}
}
}
}
shutdownExtension
(
extensionId
reason
)
{
if
(
[
"
ADDON_DISABLE
"
"
ADDON_UNINSTALL
"
]
.
includes
(
reason
)
)
{
apiManager
.
_callHandlers
(
[
extensionId
]
"
disable
"
"
onDisable
"
)
;
}
for
(
let
[
childId
context
]
of
this
.
proxyContexts
)
{
if
(
context
.
extension
.
id
=
=
extensionId
)
{
context
.
shutdown
(
)
;
this
.
proxyContexts
.
delete
(
childId
)
;
}
}
}
queryStreamFilterSuspendCancel
(
childId
)
{
return
this
.
conduit
.
queryStreamFilterSuspendCancel
(
childId
)
;
}
recvCreateProxyContext
(
data
{
actor
sender
}
)
{
let
{
envType
extensionId
childId
principal
}
=
data
;
let
target
=
actor
.
browsingContext
?
.
top
.
embedderElement
;
if
(
this
.
proxyContexts
.
has
(
childId
)
)
{
throw
new
Error
(
"
A
WebExtension
context
with
the
given
ID
already
exists
!
"
)
;
}
let
extension
=
GlobalManager
.
getExtension
(
extensionId
)
;
if
(
!
extension
)
{
throw
new
Error
(
No
WebExtension
found
with
ID
{
extensionId
}
)
;
}
let
context
;
if
(
envType
=
=
"
addon_parent
"
|
|
envType
=
=
"
devtools_parent
"
)
{
if
(
!
sender
.
verified
)
{
throw
new
Error
(
Bad
sender
context
envType
:
{
sender
.
envType
}
)
;
}
if
(
JSWindowActorParent
.
isInstance
(
actor
)
)
{
let
processMessageManager
=
target
.
messageManager
.
processMessageManager
|
|
Services
.
ppmm
.
getChildAt
(
0
)
;
if
(
!
extension
.
parentMessageManager
)
{
if
(
target
.
remoteType
=
=
=
extension
.
remoteType
)
{
this
.
attachMessageManager
(
extension
processMessageManager
)
;
}
}
if
(
processMessageManager
!
=
=
extension
.
parentMessageManager
)
{
throw
new
Error
(
"
Attempt
to
create
privileged
extension
parent
from
incorrect
child
process
"
)
;
}
}
else
if
(
JSProcessActorParent
.
isInstance
(
actor
)
)
{
if
(
actor
.
manager
.
remoteType
!
=
=
extension
.
remoteType
)
{
throw
new
Error
(
"
Attempt
to
create
privileged
extension
parent
from
incorrect
child
process
"
)
;
}
if
(
envType
!
=
=
"
addon_parent
"
)
{
throw
new
Error
(
Unexpected
envType
{
envType
}
on
an
extension
process
actor
)
;
}
}
if
(
envType
=
=
"
addon_parent
"
&
&
data
.
viewType
=
=
=
"
background_worker
"
)
{
context
=
new
BackgroundWorkerContextParent
(
envType
extension
data
)
;
}
else
if
(
envType
=
=
"
addon_parent
"
)
{
context
=
new
ExtensionPageContextParent
(
envType
extension
data
target
)
;
}
else
if
(
envType
=
=
"
devtools_parent
"
)
{
context
=
new
DevToolsExtensionPageContextParent
(
envType
extension
data
target
)
;
}
}
else
if
(
envType
=
=
"
content_parent
"
)
{
context
=
new
ContentScriptContextParent
(
envType
extension
data
target
principal
)
;
}
else
{
throw
new
Error
(
Invalid
WebExtension
context
envType
:
{
envType
}
)
;
}
this
.
proxyContexts
.
set
(
childId
context
)
;
}
recvContextLoaded
(
data
{
actor
sender
}
)
{
let
context
=
this
.
getContextById
(
data
.
childId
)
;
verifyActorForContext
(
actor
context
)
;
const
{
extension
}
=
context
;
extension
.
emit
(
"
extension
-
proxy
-
context
-
load
:
completed
"
context
)
;
}
recvConduitClosed
(
sender
)
{
this
.
closeProxyContext
(
sender
.
id
)
;
}
closeProxyContext
(
childId
)
{
let
context
=
this
.
proxyContexts
.
get
(
childId
)
;
if
(
context
)
{
context
.
unload
(
)
;
this
.
proxyContexts
.
delete
(
childId
)
;
}
}
async
retrievePerformanceCounters
(
)
{
return
lazy
.
PerformanceCounters
.
getData
(
)
;
}
async
callAndLog
(
context
data
callable
)
{
let
{
id
}
=
context
.
extension
;
const
{
alreadyLogged
}
=
data
.
options
|
|
{
}
;
if
(
!
alreadyLogged
)
{
lazy
.
ExtensionActivityLog
.
log
(
id
context
.
viewType
"
api_call
"
data
.
path
{
args
:
data
.
args
}
)
;
}
let
start
=
Cu
.
now
(
)
;
try
{
return
callable
(
)
;
}
finally
{
ChromeUtils
.
addProfilerMarker
(
"
ExtensionParent
"
{
startTime
:
start
}
{
id
}
api_call
:
{
data
.
path
}
)
;
if
(
lazy
.
gTimingEnabled
)
{
let
end
=
Cu
.
now
(
)
*
1000
;
lazy
.
PerformanceCounters
.
storeExecutionTime
(
id
data
.
path
end
-
start
*
1000
)
;
}
}
}
async
recvAPICall
(
data
{
actor
}
)
{
let
context
=
this
.
getContextById
(
data
.
childId
)
;
let
target
=
actor
.
browsingContext
?
.
top
.
embedderElement
;
verifyActorForContext
(
actor
context
)
;
let
reply
=
result
=
>
{
if
(
target
&
&
!
context
.
parentMessageManager
)
{
Services
.
console
.
logStringMessage
(
"
Cannot
send
function
call
result
:
other
side
closed
connection
"
+
(
call
data
:
{
uneval
(
{
path
:
data
.
path
args
:
data
.
args
}
)
}
)
)
;
return
;
}
this
.
conduit
.
sendCallResult
(
data
.
childId
{
childId
:
data
.
childId
callId
:
data
.
callId
path
:
data
.
path
.
.
.
result
}
)
;
}
;
try
{
let
args
=
data
.
args
;
let
{
isHandlingUserInput
=
false
}
=
data
.
options
|
|
{
}
;
let
pendingBrowser
=
context
.
pendingEventBrowser
;
let
fun
=
await
context
.
apiCan
.
asyncFindAPIPath
(
data
.
path
)
;
let
result
=
this
.
callAndLog
(
context
data
(
)
=
>
{
return
context
.
withPendingBrowser
(
pendingBrowser
(
)
=
>
context
.
withCallContextData
(
{
isHandlingUserInput
}
(
)
=
>
fun
(
.
.
.
args
)
)
)
;
}
)
;
if
(
data
.
callId
)
{
result
=
result
|
|
Promise
.
resolve
(
)
;
result
.
then
(
result
=
>
{
result
=
result
instanceof
SpreadArgs
?
[
.
.
.
result
]
:
[
result
]
;
let
holder
=
new
StructuredCloneHolder
(
result
)
;
reply
(
{
result
:
holder
}
)
;
}
error
=
>
{
error
=
context
.
normalizeError
(
error
)
;
reply
(
{
error
:
{
message
:
error
.
message
fileName
:
error
.
fileName
}
}
)
;
}
)
;
}
}
catch
(
e
)
{
if
(
data
.
callId
)
{
let
error
=
context
.
normalizeError
(
e
)
;
reply
(
{
error
:
{
message
:
error
.
message
}
}
)
;
}
else
{
Cu
.
reportError
(
e
)
;
}
}
}
async
recvAddListener
(
data
{
actor
}
)
{
let
context
=
this
.
getContextById
(
data
.
childId
)
;
verifyActorForContext
(
actor
context
)
;
let
{
childId
alreadyLogged
=
false
}
=
data
;
let
handlingUserInput
=
false
;
let
listener
=
async
(
.
.
.
listenerArgs
)
=
>
{
let
startTime
=
Cu
.
now
(
)
;
let
urgentSend
=
false
;
if
(
listenerArgs
[
0
]
&
&
data
.
path
.
startsWith
(
"
webRequest
.
"
)
)
{
urgentSend
=
listenerArgs
[
0
]
.
urgentSend
;
delete
listenerArgs
[
0
]
.
urgentSend
;
}
let
runListenerPromise
=
this
.
conduit
.
queryRunListener
(
childId
{
childId
handlingUserInput
listenerId
:
data
.
listenerId
path
:
data
.
path
urgentSend
get
args
(
)
{
return
new
StructuredCloneHolder
(
listenerArgs
)
;
}
}
)
;
context
.
trackRunListenerPromise
(
runListenerPromise
)
;
const
result
=
await
runListenerPromise
;
let
rv
=
result
&
&
result
.
deserialize
(
globalThis
)
;
ChromeUtils
.
addProfilerMarker
(
"
ExtensionParent
"
{
startTime
}
{
context
.
extension
.
id
}
api_event
:
{
data
.
path
}
)
;
lazy
.
ExtensionActivityLog
.
log
(
context
.
extension
.
id
context
.
viewType
"
api_event
"
data
.
path
{
args
:
listenerArgs
result
:
rv
}
)
;
return
rv
;
}
;
context
.
listenerProxies
.
set
(
data
.
listenerId
listener
)
;
let
args
=
data
.
args
;
let
promise
=
context
.
apiCan
.
asyncFindAPIPath
(
data
.
path
)
;
if
(
context
.
viewType
=
=
=
"
background
"
&
&
context
.
listenerPromises
)
{
const
{
listenerPromises
}
=
context
;
listenerPromises
.
add
(
promise
)
;
let
remove
=
(
)
=
>
{
listenerPromises
.
delete
(
promise
)
;
}
;
promise
.
then
(
remove
remove
)
;
}
let
handler
=
await
promise
;
if
(
handler
.
setUserInput
)
{
handlingUserInput
=
true
;
}
handler
.
addListener
(
listener
.
.
.
args
)
;
if
(
!
alreadyLogged
)
{
lazy
.
ExtensionActivityLog
.
log
(
context
.
extension
.
id
context
.
viewType
"
api_call
"
{
data
.
path
}
.
addListener
{
args
}
)
;
}
}
async
recvRemoveListener
(
data
)
{
let
context
=
this
.
getContextById
(
data
.
childId
)
;
let
listener
=
context
.
listenerProxies
.
get
(
data
.
listenerId
)
;
let
handler
=
await
context
.
apiCan
.
asyncFindAPIPath
(
data
.
path
)
;
handler
.
removeListener
(
listener
)
;
let
{
alreadyLogged
=
false
}
=
data
;
if
(
!
alreadyLogged
)
{
lazy
.
ExtensionActivityLog
.
log
(
context
.
extension
.
id
context
.
viewType
"
api_call
"
{
data
.
path
}
.
removeListener
{
args
:
[
]
}
)
;
}
}
getContextById
(
childId
)
{
let
context
=
this
.
proxyContexts
.
get
(
childId
)
;
if
(
!
context
)
{
throw
new
Error
(
"
WebExtension
context
not
found
!
"
)
;
}
return
context
;
}
}
;
ParentAPIManager
.
init
(
)
;
class
HiddenXULWindow
{
constructor
(
)
{
this
.
_windowlessBrowser
=
null
;
this
.
unloaded
=
false
;
this
.
waitInitialized
=
this
.
initWindowlessBrowser
(
)
;
}
shutdown
(
)
{
if
(
this
.
unloaded
)
{
throw
new
Error
(
"
Unable
to
shutdown
an
unloaded
HiddenXULWindow
instance
"
)
;
}
this
.
unloaded
=
true
;
this
.
waitInitialized
=
null
;
if
(
!
this
.
_windowlessBrowser
)
{
Cu
.
reportError
(
"
HiddenXULWindow
was
shut
down
while
it
was
loading
.
"
)
;
return
;
}
this
.
_windowlessBrowser
.
close
(
)
;
this
.
_windowlessBrowser
=
null
;
}
get
chromeDocument
(
)
{
return
this
.
_windowlessBrowser
.
document
;
}
async
initWindowlessBrowser
(
)
{
if
(
this
.
waitInitialized
)
{
throw
new
Error
(
"
HiddenXULWindow
already
initialized
"
)
;
}
let
windowlessBrowser
=
Services
.
appShell
.
createWindowlessBrowser
(
true
)
;
let
chromeShell
=
windowlessBrowser
.
docShell
;
chromeShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
if
(
lazy
.
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
let
attrs
=
chromeShell
.
getOriginAttributes
(
)
;
attrs
.
privateBrowsingId
=
1
;
chromeShell
.
setOriginAttributes
(
attrs
)
;
}
windowlessBrowser
.
browsingContext
.
useGlobalHistory
=
false
;
chromeShell
.
loadURI
(
"
chrome
:
/
/
extensions
/
content
/
dummy
.
xhtml
"
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
await
promiseObserved
(
"
chrome
-
document
-
global
-
created
"
win
=
>
win
.
document
=
=
chromeShell
.
document
)
;
await
promiseDocumentLoaded
(
windowlessBrowser
.
document
)
;
if
(
this
.
unloaded
)
{
windowlessBrowser
.
close
(
)
;
return
;
}
this
.
_windowlessBrowser
=
windowlessBrowser
;
}
async
createBrowserElement
(
xulAttributes
)
{
if
(
!
xulAttributes
|
|
Object
.
keys
(
xulAttributes
)
.
length
=
=
=
0
)
{
throw
new
Error
(
"
missing
mandatory
xulAttributes
parameter
"
)
;
}
await
this
.
waitInitialized
;
const
chromeDoc
=
this
.
chromeDocument
;
const
browser
=
chromeDoc
.
createXULElement
(
"
browser
"
)
;
browser
.
setAttribute
(
"
type
"
"
content
"
)
;
browser
.
setAttribute
(
"
disableglobalhistory
"
"
true
"
)
;
browser
.
setAttribute
(
"
messagemanagergroup
"
"
webext
-
browsers
"
)
;
for
(
const
[
name
value
]
of
Object
.
entries
(
xulAttributes
)
)
{
if
(
value
!
=
null
)
{
browser
.
setAttribute
(
name
value
)
;
}
}
let
awaitFrameLoader
=
Promise
.
resolve
(
)
;
if
(
browser
.
getAttribute
(
"
remote
"
)
=
=
=
"
true
"
)
{
awaitFrameLoader
=
promiseEvent
(
browser
"
XULFrameLoaderCreated
"
)
;
}
chromeDoc
.
documentElement
.
appendChild
(
browser
)
;
browser
.
getBoundingClientRect
(
)
;
await
awaitFrameLoader
;
return
browser
;
}
}
const
SharedWindow
=
{
_window
:
null
_count
:
0
acquire
(
)
{
if
(
this
.
_window
=
=
null
)
{
if
(
this
.
_count
!
=
0
)
{
throw
new
Error
(
Shared
window
already
exists
with
count
{
this
.
_count
}
)
;
}
this
.
_window
=
new
HiddenXULWindow
(
)
;
}
this
.
_count
+
+
;
return
this
.
_window
;
}
release
(
)
{
if
(
this
.
_count
<
1
)
{
throw
new
Error
(
Releasing
shared
window
with
count
{
this
.
_count
}
)
;
}
this
.
_count
-
-
;
if
(
this
.
_count
=
=
0
)
{
this
.
_window
.
shutdown
(
)
;
this
.
_window
=
null
;
}
}
}
;
class
HiddenExtensionPage
{
constructor
(
extension
viewType
)
{
if
(
!
extension
|
|
!
viewType
)
{
throw
new
Error
(
"
extension
and
viewType
parameters
are
mandatory
"
)
;
}
this
.
extension
=
extension
;
this
.
viewType
=
viewType
;
this
.
browser
=
null
;
this
.
unloaded
=
false
;
}
shutdown
(
)
{
if
(
this
.
unloaded
)
{
throw
new
Error
(
"
Unable
to
shutdown
an
unloaded
HiddenExtensionPage
instance
"
)
;
}
this
.
unloaded
=
true
;
if
(
this
.
browser
)
{
this
.
_releaseBrowser
(
)
;
}
}
_releaseBrowser
(
)
{
this
.
browser
.
remove
(
)
;
this
.
browser
=
null
;
SharedWindow
.
release
(
)
;
}
async
createBrowserElement
(
)
{
if
(
this
.
browser
)
{
throw
new
Error
(
"
createBrowserElement
called
twice
"
)
;
}
let
window
=
SharedWindow
.
acquire
(
)
;
try
{
this
.
browser
=
await
window
.
createBrowserElement
(
{
"
webextension
-
view
-
type
"
:
this
.
viewType
remote
:
this
.
extension
.
remote
?
"
true
"
:
null
remoteType
:
this
.
extension
.
remoteType
initialBrowsingContextGroupId
:
this
.
extension
.
browsingContextGroupId
}
)
;
}
catch
(
e
)
{
SharedWindow
.
release
(
)
;
throw
e
;
}
if
(
this
.
unloaded
)
{
this
.
_releaseBrowser
(
)
;
throw
new
Error
(
"
Extension
shut
down
before
browser
element
was
created
"
)
;
}
return
this
.
browser
;
}
}
const
DebugUtils
=
{
hiddenXULWindow
:
null
debugBrowserPromises
:
new
Map
(
)
debugActors
:
new
DefaultWeakMap
(
(
)
=
>
new
Set
(
)
)
_extensionUpdatedWatcher
:
null
watchExtensionUpdated
(
)
{
if
(
!
this
.
_extensionUpdatedWatcher
)
{
this
.
_extensionUpdatedWatcher
=
async
(
evt
extension
)
=
>
{
const
browserPromise
=
this
.
debugBrowserPromises
.
get
(
extension
.
id
)
;
if
(
browserPromise
)
{
const
browser
=
await
browserPromise
;
if
(
browser
.
isRemoteBrowser
!
=
=
extension
.
remote
&
&
this
.
debugBrowserPromises
.
get
(
extension
.
id
)
=
=
=
browserPromise
)
{
this
.
debugBrowserPromises
.
delete
(
extension
.
id
)
;
browser
.
remove
(
)
;
}
}
}
;
apiManager
.
on
(
"
ready
"
this
.
_extensionUpdatedWatcher
)
;
}
}
unwatchExtensionUpdated
(
)
{
if
(
this
.
_extensionUpdatedWatcher
)
{
apiManager
.
off
(
"
ready
"
this
.
_extensionUpdatedWatcher
)
;
delete
this
.
_extensionUpdatedWatcher
;
}
}
getExtensionManifestWarnings
(
id
)
{
const
addon
=
GlobalManager
.
extensionMap
.
get
(
id
)
;
if
(
addon
)
{
return
addon
.
warnings
;
}
return
[
]
;
}
hasPersistentBackgroundScript
(
addonId
)
{
const
policy
=
WebExtensionPolicy
.
getByID
(
addonId
)
;
if
(
policy
?
.
extension
?
.
type
!
=
=
"
extension
"
|
|
!
policy
?
.
extension
?
.
manifest
?
.
background
)
{
return
undefined
;
}
return
policy
.
extension
.
persistentBackground
;
}
isBackgroundScriptRunning
(
addonId
)
{
const
policy
=
WebExtensionPolicy
.
getByID
(
addonId
)
;
if
(
!
(
this
.
hasPersistentBackgroundScript
(
addonId
)
=
=
=
false
)
)
{
return
undefined
;
}
const
views
=
policy
?
.
extension
?
.
views
|
|
[
]
;
for
(
const
view
of
views
)
{
if
(
view
.
viewType
=
=
=
"
background
"
|
|
(
view
.
viewType
=
=
=
"
background_worker
"
&
&
!
view
.
unloaded
)
)
{
return
true
;
}
}
return
false
;
}
async
terminateBackgroundScript
(
addonId
)
{
if
(
this
.
hasPersistentBackgroundScript
(
addonId
)
=
=
=
false
)
{
const
policy
=
WebExtensionPolicy
.
getByID
(
addonId
)
;
return
policy
.
extension
.
terminateBackground
(
{
ignoreDevToolsAttached
:
true
}
)
;
}
throw
Error
(
Unable
to
terminate
background
script
for
{
addonId
}
)
;
}
hasDevToolsAttached
(
id
)
{
return
this
.
debugBrowserPromises
.
has
(
id
)
;
}
async
getExtensionProcessBrowser
(
webExtensionParentActor
)
{
const
extensionId
=
webExtensionParentActor
.
addonId
;
const
extension
=
GlobalManager
.
getExtension
(
extensionId
)
;
if
(
!
extension
)
{
throw
new
Error
(
Extension
not
found
:
{
extensionId
}
)
;
}
const
createBrowser
=
(
)
=
>
{
if
(
!
this
.
hiddenXULWindow
)
{
this
.
hiddenXULWindow
=
new
HiddenXULWindow
(
)
;
this
.
watchExtensionUpdated
(
)
;
}
return
this
.
hiddenXULWindow
.
createBrowserElement
(
{
"
webextension
-
addon
-
debug
-
target
"
:
extensionId
remote
:
extension
.
remote
?
"
true
"
:
null
remoteType
:
extension
.
remoteType
initialBrowsingContextGroupId
:
extension
.
browsingContextGroupId
}
)
;
}
;
let
browserPromise
=
this
.
debugBrowserPromises
.
get
(
extensionId
)
;
if
(
!
browserPromise
)
{
browserPromise
=
createBrowser
(
)
;
this
.
debugBrowserPromises
.
set
(
extensionId
browserPromise
)
;
browserPromise
.
then
(
browser
=
>
{
browserPromise
.
browser
=
browser
;
}
)
;
browserPromise
.
catch
(
e
=
>
{
Cu
.
reportError
(
e
)
;
this
.
debugBrowserPromises
.
delete
(
extensionId
)
;
}
)
;
}
this
.
debugActors
.
get
(
browserPromise
)
.
add
(
webExtensionParentActor
)
;
return
browserPromise
;
}
getFrameLoader
(
extensionId
)
{
let
promise
=
this
.
debugBrowserPromises
.
get
(
extensionId
)
;
return
promise
&
&
promise
.
browser
&
&
promise
.
browser
.
frameLoader
;
}
async
releaseExtensionProcessBrowser
(
webExtensionParentActor
)
{
const
extensionId
=
webExtensionParentActor
.
addonId
;
const
browserPromise
=
this
.
debugBrowserPromises
.
get
(
extensionId
)
;
if
(
browserPromise
)
{
const
actorsSet
=
this
.
debugActors
.
get
(
browserPromise
)
;
actorsSet
.
delete
(
webExtensionParentActor
)
;
if
(
actorsSet
.
size
=
=
=
0
)
{
this
.
debugActors
.
delete
(
browserPromise
)
;
this
.
debugBrowserPromises
.
delete
(
extensionId
)
;
await
browserPromise
.
then
(
browser
=
>
browser
.
remove
(
)
)
;
}
}
if
(
this
.
debugBrowserPromises
.
size
=
=
=
0
&
&
this
.
hiddenXULWindow
)
{
this
.
hiddenXULWindow
.
shutdown
(
)
;
this
.
hiddenXULWindow
=
null
;
this
.
unwatchExtensionUpdated
(
)
;
}
}
}
;
function
promiseMessageFromChild
(
messageManager
messageName
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
unregister
;
function
listener
(
message
)
{
unregister
(
)
;
resolve
(
message
.
data
)
;
}
function
observer
(
subject
topic
data
)
{
if
(
subject
=
=
=
messageManager
)
{
unregister
(
)
;
reject
(
new
Error
(
Message
manager
was
disconnected
before
receiving
{
messageName
}
)
)
;
}
}
unregister
=
(
)
=
>
{
Services
.
obs
.
removeObserver
(
observer
"
message
-
manager
-
close
"
)
;
messageManager
.
removeMessageListener
(
messageName
listener
)
;
}
;
messageManager
.
addMessageListener
(
messageName
listener
)
;
Services
.
obs
.
addObserver
(
observer
"
message
-
manager
-
close
"
)
;
}
)
;
}
async
function
promiseExtensionViewLoaded
(
browser
)
{
let
{
childId
}
=
await
promiseMessageFromChild
(
browser
.
messageManager
"
Extension
:
ExtensionViewLoaded
"
)
;
if
(
childId
)
{
return
ParentAPIManager
.
getContextById
(
childId
)
;
}
}
function
watchExtensionProxyContextLoad
(
{
extension
viewType
browser
}
onExtensionProxyContextLoaded
)
{
if
(
typeof
onExtensionProxyContextLoaded
!
=
=
"
function
"
)
{
throw
new
Error
(
"
Missing
onExtensionProxyContextLoaded
handler
"
)
;
}
const
listener
=
(
event
context
)
=
>
{
if
(
context
.
viewType
=
=
viewType
&
&
context
.
xulBrowser
=
=
browser
)
{
onExtensionProxyContextLoaded
(
context
)
;
}
}
;
extension
.
on
(
"
extension
-
proxy
-
context
-
load
"
listener
)
;
return
(
)
=
>
{
extension
.
off
(
"
extension
-
proxy
-
context
-
load
"
listener
)
;
}
;
}
function
watchExtensionWorkerContextLoaded
(
{
extension
}
onExtensionWorkerContextLoaded
)
{
if
(
typeof
onExtensionWorkerContextLoaded
!
=
=
"
function
"
)
{
throw
new
Error
(
"
Missing
onExtensionWorkerContextLoaded
handler
"
)
;
}
const
listener
=
(
event
context
)
=
>
{
if
(
context
.
viewType
=
=
"
background_worker
"
)
{
onExtensionWorkerContextLoaded
(
context
)
;
}
}
;
extension
.
on
(
"
extension
-
proxy
-
context
-
load
:
completed
"
listener
)
;
return
(
)
=
>
{
extension
.
off
(
"
extension
-
proxy
-
context
-
load
:
completed
"
listener
)
;
}
;
}
let
IconDetails
=
{
DEFAULT_ICON
:
"
chrome
:
/
/
mozapps
/
skin
/
extensions
/
extensionGeneric
.
svg
"
iconCache
:
new
DefaultWeakMap
(
(
)
=
>
{
return
new
DefaultMap
(
(
)
=
>
new
DefaultMap
(
(
)
=
>
new
Map
(
)
)
)
;
}
)
normalize
(
details
extension
context
=
null
)
{
if
(
!
details
.
imageData
&
&
details
.
path
!
=
null
)
{
let
key
=
details
.
path
;
if
(
typeof
key
!
=
=
"
string
"
)
{
key
=
uneval
(
key
)
;
}
let
icons
=
this
.
iconCache
.
get
(
extension
)
.
get
(
context
&
&
context
.
uri
.
spec
)
.
get
(
details
.
iconType
)
;
let
icon
=
icons
.
get
(
key
)
;
if
(
!
icon
)
{
icon
=
this
.
_normalize
(
details
extension
context
)
;
icons
.
set
(
key
icon
)
;
}
return
icon
;
}
return
this
.
_normalize
(
details
extension
context
)
;
}
_normalize
(
details
extension
context
=
null
)
{
let
result
=
{
}
;
try
{
let
{
imageData
path
themeIcons
}
=
details
;
if
(
imageData
)
{
if
(
typeof
imageData
=
=
"
string
"
)
{
imageData
=
{
"
19
"
:
imageData
}
;
}
for
(
let
size
of
Object
.
keys
(
imageData
)
)
{
result
[
size
]
=
imageData
[
size
]
;
}
}
let
baseURI
=
context
?
context
.
uri
:
extension
.
baseURI
;
if
(
path
!
=
null
)
{
if
(
typeof
path
!
=
"
object
"
)
{
path
=
{
"
19
"
:
path
}
;
}
for
(
let
size
of
Object
.
keys
(
path
)
)
{
let
url
=
path
[
size
]
;
if
(
url
)
{
url
=
baseURI
.
resolve
(
path
[
size
]
)
;
this
.
_checkURL
(
url
extension
)
;
}
result
[
size
]
=
url
|
|
this
.
DEFAULT_ICON
;
}
}
if
(
themeIcons
)
{
themeIcons
.
forEach
(
(
{
size
light
dark
}
)
=
>
{
let
lightURL
=
baseURI
.
resolve
(
light
)
;
let
darkURL
=
baseURI
.
resolve
(
dark
)
;
this
.
_checkURL
(
lightURL
extension
)
;
this
.
_checkURL
(
darkURL
extension
)
;
let
defaultURL
=
result
[
size
]
|
|
result
[
19
]
;
result
[
size
]
=
{
default
:
defaultURL
|
|
darkURL
light
:
lightURL
dark
:
darkURL
}
;
}
)
;
}
}
catch
(
e
)
{
if
(
context
)
{
throw
e
;
}
extension
.
manifestError
(
Invalid
icon
data
:
{
e
}
)
;
}
return
result
;
}
_checkURL
(
url
extension
)
{
if
(
!
extension
.
checkLoadURL
(
url
{
allowInheritsPrincipal
:
true
}
)
)
{
throw
new
ExtensionError
(
Illegal
URL
{
url
}
)
;
}
}
getPreferredIcon
(
icons
extension
=
null
size
=
16
)
{
const
DEFAULT
=
"
chrome
:
/
/
mozapps
/
skin
/
extensions
/
extensionGeneric
.
svg
"
;
let
bestSize
=
null
;
if
(
icons
[
size
]
)
{
bestSize
=
size
;
}
else
if
(
icons
[
2
*
size
]
)
{
bestSize
=
2
*
size
;
}
else
{
let
sizes
=
Object
.
keys
(
icons
)
.
map
(
key
=
>
parseInt
(
key
10
)
)
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
bestSize
=
sizes
.
find
(
candidate
=
>
candidate
>
size
)
|
|
sizes
.
pop
(
)
;
}
if
(
bestSize
)
{
return
{
size
:
bestSize
icon
:
icons
[
bestSize
]
|
|
DEFAULT
}
;
}
return
{
size
icon
:
DEFAULT
}
;
}
escapeUrl
(
url
)
{
return
url
.
replace
(
/
[
\
\
\
s
"
]
/
g
encodeURIComponent
)
;
}
}
;
StartupCache
=
{
STORE_NAMES
:
Object
.
freeze
(
[
"
general
"
"
locales
"
"
manifests
"
"
other
"
"
permissions
"
"
schemas
"
"
menus
"
]
)
_ensureDirectoryPromise
:
null
_saveTask
:
null
_ensureDirectory
(
)
{
if
(
this
.
_ensureDirectoryPromise
=
=
=
null
)
{
this
.
_ensureDirectoryPromise
=
IOUtils
.
makeDirectory
(
PathUtils
.
parent
(
this
.
file
)
{
ignoreExisting
:
true
createAncestors
:
true
}
)
;
}
return
this
.
_ensureDirectoryPromise
;
}
file
:
PathUtils
.
join
(
Services
.
dirsvc
.
get
(
"
ProfLD
"
Ci
.
nsIFile
)
.
path
"
startupCache
"
"
webext
.
sc
.
lz4
"
)
async
_saveNow
(
)
{
let
data
=
new
Uint8Array
(
lazy
.
aomStartup
.
encodeBlob
(
this
.
_data
)
)
;
await
this
.
_ensureDirectoryPromise
;
await
IOUtils
.
write
(
this
.
file
data
{
tmpPath
:
{
this
.
file
}
.
tmp
}
)
;
Services
.
telemetry
.
scalarSet
(
"
extensions
.
startupCache
.
write_byteLength
"
data
.
byteLength
)
;
}
save
(
)
{
this
.
_ensureDirectory
(
)
;
if
(
!
this
.
_saveTask
)
{
this
.
_saveTask
=
new
lazy
.
DeferredTask
(
(
)
=
>
this
.
_saveNow
(
)
5000
)
;
IOUtils
.
profileBeforeChange
.
addBlocker
(
"
Flush
WebExtension
StartupCache
"
async
(
)
=
>
{
await
this
.
_saveTask
.
finalize
(
)
;
this
.
_saveTask
=
null
;
}
)
;
}
return
this
.
_saveTask
.
arm
(
)
;
}
_data
:
null
async
_readData
(
)
{
let
result
=
new
Map
(
)
;
try
{
Glean
.
extensions
.
startupCacheLoadTime
.
start
(
)
;
let
{
buffer
}
=
await
IOUtils
.
read
(
this
.
file
)
;
result
=
lazy
.
aomStartup
.
decodeBlob
(
buffer
)
;
Glean
.
extensions
.
startupCacheLoadTime
.
stop
(
)
;
}
catch
(
e
)
{
Glean
.
extensions
.
startupCacheLoadTime
.
cancel
(
)
;
if
(
!
DOMException
.
isInstance
(
e
)
|
|
e
.
name
!
=
=
"
NotFoundError
"
)
{
Cu
.
reportError
(
e
)
;
}
Services
.
telemetry
.
keyedScalarAdd
(
"
extensions
.
startupCache
.
read_errors
"
lazy
.
getErrorNameForTelemetry
(
e
)
1
)
;
}
this
.
_data
=
result
;
return
result
;
}
get
dataPromise
(
)
{
if
(
!
this
.
_dataPromise
)
{
this
.
_dataPromise
=
this
.
_readData
(
)
;
}
return
this
.
_dataPromise
;
}
clearAddonData
(
id
)
{
return
Promise
.
all
(
[
this
.
general
.
delete
(
id
)
this
.
locales
.
delete
(
id
)
this
.
manifests
.
delete
(
id
)
this
.
permissions
.
delete
(
id
)
this
.
menus
.
delete
(
id
)
]
)
.
catch
(
e
=
>
{
}
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
"
startupcache
-
invalidate
"
)
{
this
.
_data
=
new
Map
(
)
;
this
.
_dataPromise
=
Promise
.
resolve
(
this
.
_data
)
;
}
}
get
(
extension
path
createFunc
)
{
return
this
.
general
.
get
(
[
extension
.
id
extension
.
version
.
.
.
path
]
createFunc
)
;
}
delete
(
extension
path
)
{
return
this
.
general
.
delete
(
[
extension
.
id
extension
.
version
.
.
.
path
]
)
;
}
}
;
Services
.
obs
.
addObserver
(
StartupCache
"
startupcache
-
invalidate
"
)
;
class
CacheStore
{
constructor
(
storeName
)
{
this
.
storeName
=
storeName
;
}
async
getStore
(
path
=
null
)
{
let
data
=
await
StartupCache
.
dataPromise
;
let
store
=
data
.
get
(
this
.
storeName
)
;
if
(
!
store
)
{
store
=
new
Map
(
)
;
data
.
set
(
this
.
storeName
store
)
;
}
let
key
=
path
;
if
(
Array
.
isArray
(
path
)
)
{
for
(
let
elem
of
path
.
slice
(
0
-
1
)
)
{
let
next
=
store
.
get
(
elem
)
;
if
(
!
next
)
{
next
=
new
Map
(
)
;
store
.
set
(
elem
next
)
;
}
store
=
next
;
}
key
=
path
[
path
.
length
-
1
]
;
}
return
[
store
key
]
;
}
async
get
(
path
createFunc
)
{
let
[
store
key
]
=
await
this
.
getStore
(
path
)
;
let
result
=
store
.
get
(
key
)
;
if
(
result
=
=
=
undefined
)
{
result
=
await
createFunc
(
path
)
;
store
.
set
(
key
result
)
;
StartupCache
.
save
(
)
;
}
return
result
;
}
async
set
(
path
value
)
{
let
[
store
key
]
=
await
this
.
getStore
(
path
)
;
store
.
set
(
key
value
)
;
StartupCache
.
save
(
)
;
}
async
getAll
(
)
{
let
[
store
]
=
await
this
.
getStore
(
)
;
return
new
Map
(
store
)
;
}
async
delete
(
path
)
{
let
[
store
key
]
=
await
this
.
getStore
(
path
)
;
if
(
store
.
delete
(
key
)
)
{
StartupCache
.
save
(
)
;
}
}
}
for
(
let
name
of
StartupCache
.
STORE_NAMES
)
{
StartupCache
[
name
]
=
new
CacheStore
(
name
)
;
}
var
ExtensionParent
=
{
GlobalManager
HiddenExtensionPage
IconDetails
ParentAPIManager
StartupCache
WebExtensionPolicy
apiManager
promiseExtensionViewLoaded
watchExtensionProxyContextLoad
watchExtensionWorkerContextLoaded
DebugUtils
}
;
ExtensionParent
.
_resetStartupPromises
=
(
)
=
>
{
ExtensionParent
.
browserPaintedPromise
=
promiseObserved
(
"
browser
-
delayed
-
startup
-
finished
"
)
.
then
(
(
)
=
>
{
}
)
;
ExtensionParent
.
browserStartupPromise
=
Promise
.
race
(
[
promiseObserved
(
"
sessionstore
-
windows
-
restored
"
)
promiseObserved
(
"
extensions
-
late
-
startup
"
)
]
)
.
then
(
(
)
=
>
{
}
)
;
}
;
ExtensionParent
.
_resetStartupPromises
(
)
;
XPCOMUtils
.
defineLazyGetter
(
ExtensionParent
"
PlatformInfo
"
(
)
=
>
{
return
Object
.
freeze
(
{
os
:
(
function
(
)
{
let
os
=
AppConstants
.
platform
;
if
(
os
=
=
"
macosx
"
)
{
os
=
"
mac
"
;
}
return
os
;
}
)
(
)
arch
:
(
function
(
)
{
let
abi
=
Services
.
appinfo
.
XPCOMABI
;
let
[
arch
]
=
abi
.
split
(
"
-
"
)
;
if
(
arch
=
=
"
x86
"
)
{
arch
=
"
x86
-
32
"
;
}
else
if
(
arch
=
=
"
x86_64
"
)
{
arch
=
"
x86
-
64
"
;
}
return
arch
;
}
)
(
)
}
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
ExtensionParent
"
extensionStylesheets
"
(
)
=
>
{
let
stylesheets
=
[
"
chrome
:
/
/
browser
/
content
/
extension
.
css
"
]
;
if
(
AppConstants
.
platform
=
=
=
"
macosx
"
)
{
stylesheets
.
push
(
"
chrome
:
/
/
browser
/
content
/
extension
-
mac
.
css
"
)
;
}
return
stylesheets
;
}
)
;
