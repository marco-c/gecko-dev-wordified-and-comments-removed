"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionParent
"
]
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
E10SUtils
"
"
resource
:
/
/
/
modules
/
E10SUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
IndexedDB
"
"
resource
:
/
/
gre
/
modules
/
IndexedDB
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MessageChannel
"
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NativeApp
"
"
resource
:
/
/
gre
/
modules
/
NativeMessaging
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Schemas
"
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gAddonPolicyService
"
"
mozilla
.
org
/
addons
/
policy
-
service
;
1
"
"
nsIAddonPolicyService
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
BaseContext
CanOfAPIs
SchemaAPIManager
SpreadArgs
}
=
ExtensionCommon
;
var
{
DefaultWeakMap
ExtensionError
MessageManagerProxy
defineLazyGetter
promiseDocumentLoaded
promiseEvent
promiseObserved
}
=
ExtensionUtils
;
const
BASE_SCHEMA
=
"
chrome
:
/
/
extensions
/
content
/
schemas
/
manifest
.
json
"
;
const
CATEGORY_EXTENSION_SCHEMAS
=
"
webextension
-
schemas
"
;
const
CATEGORY_EXTENSION_SCRIPTS
=
"
webextension
-
scripts
"
;
const
XUL_URL
=
"
data
:
application
/
vnd
.
mozilla
.
xul
+
xml
;
charset
=
utf
-
8
"
+
encodeURI
(
<
?
xml
version
=
"
1
.
0
"
?
>
<
window
id
=
"
documentElement
"
/
>
)
;
let
schemaURLs
=
new
Set
(
)
;
schemaURLs
.
add
(
"
chrome
:
/
/
extensions
/
content
/
schemas
/
experiments
.
json
"
)
;
let
GlobalManager
;
let
ParentAPIManager
;
let
ProxyMessenger
;
let
apiManager
=
new
class
extends
SchemaAPIManager
{
constructor
(
)
{
super
(
"
main
"
)
;
this
.
initialized
=
null
;
this
.
on
(
"
startup
"
(
event
extension
)
=
>
{
let
promises
=
[
]
;
for
(
let
apiName
of
this
.
eventModules
.
get
(
"
startup
"
)
)
{
promises
.
push
(
this
.
asyncGetAPI
(
apiName
extension
)
.
then
(
api
=
>
{
api
.
onStartup
(
extension
.
startupReason
)
;
}
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
)
;
}
lazyInit
(
)
{
if
(
this
.
initialized
)
{
return
this
.
initialized
;
}
let
scripts
=
[
]
;
for
(
let
[
value
]
of
XPCOMUtils
.
enumerateCategoryEntries
(
CATEGORY_EXTENSION_SCRIPTS
)
)
{
scripts
.
push
(
value
)
;
}
let
promise
=
Promise
.
all
(
scripts
.
map
(
url
=
>
ChromeUtils
.
compileScript
(
url
)
)
)
.
then
(
scripts
=
>
{
for
(
let
script
of
scripts
)
{
script
.
executeInGlobal
(
this
.
global
)
;
}
return
Schemas
.
load
(
BASE_SCHEMA
)
.
then
(
(
)
=
>
{
let
promises
=
[
]
;
for
(
let
[
url
]
of
XPCOMUtils
.
enumerateCategoryEntries
(
CATEGORY_EXTENSION_SCHEMAS
)
)
{
promises
.
push
(
Schemas
.
load
(
url
)
)
;
}
for
(
let
url
of
this
.
schemaURLs
)
{
promises
.
push
(
Schemas
.
load
(
url
)
)
;
}
for
(
let
url
of
schemaURLs
)
{
promises
.
push
(
Schemas
.
load
(
url
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
)
;
}
)
;
Services
.
mm
.
addMessageListener
(
"
Extension
:
GetTabAndWindowId
"
this
)
;
this
.
initialized
=
promise
;
return
this
.
initialized
;
}
receiveMessage
(
{
name
target
sync
}
)
{
if
(
name
=
=
=
"
Extension
:
GetTabAndWindowId
"
)
{
let
result
=
this
.
global
.
tabTracker
.
getBrowserData
(
target
)
;
if
(
result
.
tabId
)
{
if
(
sync
)
{
return
result
;
}
target
.
messageManager
.
sendAsyncMessage
(
"
Extension
:
SetFrameData
"
result
)
;
}
}
}
}
(
)
;
ProxyMessenger
=
{
_initialized
:
false
init
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
let
messageManagers
=
[
Services
.
mm
Services
.
ppmm
]
;
MessageChannel
.
addListener
(
messageManagers
"
Extension
:
Connect
"
this
)
;
MessageChannel
.
addListener
(
messageManagers
"
Extension
:
Message
"
this
)
;
MessageChannel
.
addListener
(
messageManagers
"
Extension
:
Port
:
Disconnect
"
this
)
;
MessageChannel
.
addListener
(
messageManagers
"
Extension
:
Port
:
PostMessage
"
this
)
;
}
receiveMessage
(
{
target
messageName
channelId
sender
recipient
data
responseType
}
)
{
if
(
recipient
.
toNativeApp
)
{
let
{
childId
toNativeApp
}
=
recipient
;
if
(
messageName
=
=
"
Extension
:
Message
"
)
{
let
context
=
ParentAPIManager
.
getContextById
(
childId
)
;
return
new
NativeApp
(
context
toNativeApp
)
.
sendMessage
(
data
)
;
}
if
(
messageName
=
=
"
Extension
:
Connect
"
)
{
let
context
=
ParentAPIManager
.
getContextById
(
childId
)
;
NativeApp
.
onConnectNative
(
context
target
.
messageManager
data
.
portId
sender
toNativeApp
)
;
return
true
;
}
return
;
}
let
extension
=
GlobalManager
.
extensionMap
.
get
(
sender
.
extensionId
)
;
let
receiverMM
=
this
.
getMessageManagerForRecipient
(
recipient
)
;
if
(
!
extension
|
|
!
receiverMM
)
{
return
Promise
.
reject
(
{
result
:
MessageChannel
.
RESULT_NO_HANDLER
message
:
"
No
matching
message
handler
for
the
given
recipient
.
"
}
)
;
}
if
(
(
messageName
=
=
"
Extension
:
Message
"
|
|
messageName
=
=
"
Extension
:
Connect
"
)
&
&
apiManager
.
global
.
tabGetSender
)
{
apiManager
.
global
.
tabGetSender
(
extension
target
sender
)
;
}
return
MessageChannel
.
sendMessage
(
receiverMM
messageName
data
{
sender
recipient
responseType
}
)
;
}
getMessageManagerForRecipient
(
recipient
)
{
let
{
tabId
}
=
recipient
;
if
(
tabId
)
{
let
tab
=
apiManager
.
global
.
tabTracker
.
getTab
(
tabId
null
)
;
return
tab
&
&
(
tab
.
linkedBrowser
|
|
tab
.
browser
)
.
messageManager
;
}
let
extension
=
GlobalManager
.
extensionMap
.
get
(
recipient
.
extensionId
)
;
if
(
extension
)
{
return
extension
.
parentMessageManager
;
}
return
null
;
}
}
;
GlobalManager
=
{
extensionMap
:
new
Map
(
)
initialized
:
false
init
(
extension
)
{
if
(
this
.
extensionMap
.
size
=
=
0
)
{
ProxyMessenger
.
init
(
)
;
apiManager
.
on
(
"
extension
-
browser
-
inserted
"
this
.
_onExtensionBrowser
)
;
this
.
initialized
=
true
;
}
this
.
extensionMap
.
set
(
extension
.
id
extension
)
;
}
uninit
(
extension
)
{
this
.
extensionMap
.
delete
(
extension
.
id
)
;
if
(
this
.
extensionMap
.
size
=
=
0
&
&
this
.
initialized
)
{
apiManager
.
off
(
"
extension
-
browser
-
inserted
"
this
.
_onExtensionBrowser
)
;
this
.
initialized
=
false
;
}
}
_onExtensionBrowser
(
type
browser
additionalData
=
{
}
)
{
browser
.
messageManager
.
loadFrameScript
(
data
:
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Services
.
obs
.
notifyObservers
(
this
"
tab
-
content
-
frameloader
-
created
"
"
"
)
;
false
)
;
let
viewType
=
browser
.
getAttribute
(
"
webextension
-
view
-
type
"
)
;
if
(
viewType
)
{
let
data
=
{
viewType
}
;
let
{
tabTracker
}
=
apiManager
.
global
;
Object
.
assign
(
data
tabTracker
.
getBrowserData
(
browser
)
additionalData
)
;
browser
.
messageManager
.
sendAsyncMessage
(
"
Extension
:
SetFrameData
"
data
)
;
}
}
getExtension
(
extensionId
)
{
return
this
.
extensionMap
.
get
(
extensionId
)
;
}
injectInObject
(
context
isChromeCompat
dest
)
{
SchemaAPIManager
.
generateAPIs
(
context
context
.
extension
.
apis
dest
)
;
}
}
;
class
ProxyContextParent
extends
BaseContext
{
constructor
(
envType
extension
params
xulBrowser
principal
)
{
super
(
envType
extension
)
;
this
.
uri
=
NetUtil
.
newURI
(
params
.
url
)
;
this
.
incognito
=
params
.
incognito
;
this
.
listenerPromises
=
new
Set
(
)
;
this
.
messageManagerProxy
=
new
MessageManagerProxy
(
xulBrowser
)
;
Object
.
defineProperty
(
this
"
principal
"
{
value
:
principal
enumerable
:
true
configurable
:
true
}
)
;
this
.
listenerProxies
=
new
Map
(
)
;
this
.
pendingEventBrowser
=
null
;
apiManager
.
emit
(
"
proxy
-
context
-
load
"
this
)
;
}
async
withPendingBrowser
(
browser
callable
)
{
let
savedBrowser
=
this
.
pendingEventBrowser
;
this
.
pendingEventBrowser
=
browser
;
try
{
let
result
=
await
callable
(
)
;
return
result
;
}
finally
{
this
.
pendingEventBrowser
=
savedBrowser
;
}
}
get
cloneScope
(
)
{
return
this
.
sandbox
;
}
get
xulBrowser
(
)
{
return
this
.
messageManagerProxy
.
eventTarget
;
}
get
parentMessageManager
(
)
{
return
this
.
messageManagerProxy
.
messageManager
;
}
shutdown
(
)
{
this
.
unload
(
)
;
}
unload
(
)
{
if
(
this
.
unloaded
)
{
return
;
}
this
.
messageManagerProxy
.
dispose
(
)
;
super
.
unload
(
)
;
apiManager
.
emit
(
"
proxy
-
context
-
unload
"
this
)
;
}
}
defineLazyGetter
(
ProxyContextParent
.
prototype
"
apiCan
"
function
(
)
{
let
obj
=
{
}
;
let
can
=
new
CanOfAPIs
(
this
apiManager
obj
)
;
GlobalManager
.
injectInObject
(
this
false
obj
)
;
return
can
;
}
)
;
defineLazyGetter
(
ProxyContextParent
.
prototype
"
apiObj
"
function
(
)
{
return
this
.
apiCan
.
root
;
}
)
;
defineLazyGetter
(
ProxyContextParent
.
prototype
"
sandbox
"
function
(
)
{
return
Cu
.
Sandbox
(
this
.
principal
)
;
}
)
;
class
ContentScriptContextParent
extends
ProxyContextParent
{
}
class
ExtensionPageContextParent
extends
ProxyContextParent
{
constructor
(
envType
extension
params
xulBrowser
)
{
super
(
envType
extension
params
xulBrowser
extension
.
principal
)
;
this
.
viewType
=
params
.
viewType
;
extension
.
emit
(
"
extension
-
proxy
-
context
-
load
"
this
)
;
}
get
xulWindow
(
)
{
let
win
=
this
.
xulBrowser
.
ownerGlobal
;
return
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
get
currentWindow
(
)
{
if
(
this
.
viewType
!
=
=
"
background
"
)
{
return
this
.
xulWindow
;
}
}
get
windowId
(
)
{
let
{
currentWindow
}
=
this
;
let
{
windowTracker
}
=
apiManager
.
global
;
if
(
currentWindow
&
&
windowTracker
)
{
return
windowTracker
.
getId
(
currentWindow
)
;
}
}
get
tabId
(
)
{
let
{
tabTracker
}
=
apiManager
.
global
;
let
data
=
tabTracker
.
getBrowserData
(
this
.
xulBrowser
)
;
if
(
data
.
tabId
>
=
0
)
{
return
data
.
tabId
;
}
}
onBrowserChange
(
browser
)
{
super
.
onBrowserChange
(
browser
)
;
this
.
xulBrowser
=
browser
;
}
shutdown
(
)
{
apiManager
.
emit
(
"
page
-
shutdown
"
this
)
;
super
.
shutdown
(
)
;
}
}
class
DevToolsExtensionPageContextParent
extends
ExtensionPageContextParent
{
set
devToolsToolbox
(
toolbox
)
{
if
(
this
.
_devToolsToolbox
)
{
throw
new
Error
(
"
Cannot
set
the
context
DevTools
toolbox
twice
"
)
;
}
this
.
_devToolsToolbox
=
toolbox
;
return
toolbox
;
}
get
devToolsToolbox
(
)
{
return
this
.
_devToolsToolbox
;
}
set
devToolsTarget
(
contextDevToolsTarget
)
{
if
(
this
.
_devToolsTarget
)
{
throw
new
Error
(
"
Cannot
set
the
context
DevTools
target
twice
"
)
;
}
this
.
_devToolsTarget
=
contextDevToolsTarget
;
return
contextDevToolsTarget
;
}
get
devToolsTarget
(
)
{
return
this
.
_devToolsTarget
;
}
shutdown
(
)
{
if
(
this
.
_devToolsTarget
)
{
this
.
_devToolsTarget
.
destroy
(
)
;
this
.
_devToolsTarget
=
null
;
}
this
.
_devToolsToolbox
=
null
;
super
.
shutdown
(
)
;
}
}
ParentAPIManager
=
{
proxyContexts
:
new
Map
(
)
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
close
"
)
;
Services
.
mm
.
addMessageListener
(
"
API
:
CreateProxyContext
"
this
)
;
Services
.
mm
.
addMessageListener
(
"
API
:
CloseProxyContext
"
this
true
)
;
Services
.
mm
.
addMessageListener
(
"
API
:
Call
"
this
)
;
Services
.
mm
.
addMessageListener
(
"
API
:
AddListener
"
this
)
;
Services
.
mm
.
addMessageListener
(
"
API
:
RemoveListener
"
this
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
"
message
-
manager
-
close
"
)
{
let
mm
=
subject
;
for
(
let
[
childId
context
]
of
this
.
proxyContexts
)
{
if
(
context
.
parentMessageManager
=
=
=
mm
)
{
this
.
closeProxyContext
(
childId
)
;
}
}
for
(
let
extension
of
GlobalManager
.
extensionMap
.
values
(
)
)
{
if
(
extension
.
parentMessageManager
=
=
=
mm
)
{
extension
.
parentMessageManager
=
null
;
}
}
}
}
shutdownExtension
(
extensionId
)
{
for
(
let
[
childId
context
]
of
this
.
proxyContexts
)
{
if
(
context
.
extension
.
id
=
=
extensionId
)
{
context
.
shutdown
(
)
;
this
.
proxyContexts
.
delete
(
childId
)
;
}
}
}
receiveMessage
(
{
name
data
target
}
)
{
try
{
switch
(
name
)
{
case
"
API
:
CreateProxyContext
"
:
this
.
createProxyContext
(
data
target
)
;
break
;
case
"
API
:
CloseProxyContext
"
:
this
.
closeProxyContext
(
data
.
childId
)
;
break
;
case
"
API
:
Call
"
:
this
.
call
(
data
target
)
;
break
;
case
"
API
:
AddListener
"
:
this
.
addListener
(
data
target
)
;
break
;
case
"
API
:
RemoveListener
"
:
this
.
removeListener
(
data
)
;
break
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
createProxyContext
(
data
target
)
{
let
{
envType
extensionId
childId
principal
}
=
data
;
if
(
this
.
proxyContexts
.
has
(
childId
)
)
{
throw
new
Error
(
"
A
WebExtension
context
with
the
given
ID
already
exists
!
"
)
;
}
let
extension
=
GlobalManager
.
getExtension
(
extensionId
)
;
if
(
!
extension
)
{
throw
new
Error
(
No
WebExtension
found
with
ID
{
extensionId
}
)
;
}
let
context
;
if
(
envType
=
=
"
addon_parent
"
|
|
envType
=
=
"
devtools_parent
"
)
{
let
processMessageManager
=
(
target
.
messageManager
.
processMessageManager
|
|
Services
.
ppmm
.
getChildAt
(
0
)
)
;
if
(
!
extension
.
parentMessageManager
)
{
let
expectedRemoteType
=
extension
.
remote
?
E10SUtils
.
EXTENSION_REMOTE_TYPE
:
null
;
if
(
target
.
remoteType
=
=
=
expectedRemoteType
)
{
extension
.
parentMessageManager
=
processMessageManager
;
}
}
if
(
processMessageManager
!
=
=
extension
.
parentMessageManager
)
{
throw
new
Error
(
"
Attempt
to
create
privileged
extension
parent
from
incorrect
child
process
"
)
;
}
if
(
envType
=
=
"
addon_parent
"
)
{
context
=
new
ExtensionPageContextParent
(
envType
extension
data
target
)
;
}
else
if
(
envType
=
=
"
devtools_parent
"
)
{
context
=
new
DevToolsExtensionPageContextParent
(
envType
extension
data
target
)
;
}
}
else
if
(
envType
=
=
"
content_parent
"
)
{
context
=
new
ContentScriptContextParent
(
envType
extension
data
target
principal
)
;
}
else
{
throw
new
Error
(
Invalid
WebExtension
context
envType
:
{
envType
}
)
;
}
this
.
proxyContexts
.
set
(
childId
context
)
;
}
closeProxyContext
(
childId
)
{
let
context
=
this
.
proxyContexts
.
get
(
childId
)
;
if
(
context
)
{
context
.
unload
(
)
;
this
.
proxyContexts
.
delete
(
childId
)
;
}
}
async
call
(
data
target
)
{
let
context
=
this
.
getContextById
(
data
.
childId
)
;
if
(
context
.
parentMessageManager
!
=
=
target
.
messageManager
)
{
throw
new
Error
(
"
Got
message
on
unexpected
message
manager
"
)
;
}
let
reply
=
result
=
>
{
if
(
!
context
.
parentMessageManager
)
{
Services
.
console
.
logStringMessage
(
"
Cannot
send
function
call
result
:
other
side
closed
connection
"
+
(
call
data
:
{
uneval
(
{
path
:
data
.
path
args
:
data
.
args
}
)
}
)
)
;
return
;
}
context
.
parentMessageManager
.
sendAsyncMessage
(
"
API
:
CallResult
"
Object
.
assign
(
{
childId
:
data
.
childId
callId
:
data
.
callId
}
result
)
)
;
}
;
try
{
let
args
=
Cu
.
cloneInto
(
data
.
args
context
.
sandbox
)
;
let
pendingBrowser
=
context
.
pendingEventBrowser
;
let
fun
=
await
context
.
apiCan
.
asyncFindAPIPath
(
data
.
path
)
;
let
result
=
context
.
withPendingBrowser
(
pendingBrowser
(
)
=
>
fun
(
.
.
.
args
)
)
;
if
(
data
.
callId
)
{
result
=
result
|
|
Promise
.
resolve
(
)
;
result
.
then
(
result
=
>
{
result
=
result
instanceof
SpreadArgs
?
[
.
.
.
result
]
:
[
result
]
;
let
holder
=
new
StructuredCloneHolder
(
result
)
;
reply
(
{
result
:
holder
}
)
;
}
error
=
>
{
error
=
context
.
normalizeError
(
error
)
;
reply
(
{
error
:
{
message
:
error
.
message
fileName
:
error
.
fileName
}
}
)
;
}
)
;
}
}
catch
(
e
)
{
if
(
data
.
callId
)
{
let
error
=
context
.
normalizeError
(
e
)
;
reply
(
{
error
:
{
message
:
error
.
message
}
}
)
;
}
else
{
Cu
.
reportError
(
e
)
;
}
}
}
async
addListener
(
data
target
)
{
let
context
=
this
.
getContextById
(
data
.
childId
)
;
if
(
context
.
parentMessageManager
!
=
=
target
.
messageManager
)
{
throw
new
Error
(
"
Got
message
on
unexpected
message
manager
"
)
;
}
let
{
childId
}
=
data
;
let
handlingUserInput
=
false
;
function
listener
(
.
.
.
listenerArgs
)
{
return
context
.
sendMessage
(
context
.
parentMessageManager
"
API
:
RunListener
"
{
childId
handlingUserInput
listenerId
:
data
.
listenerId
path
:
data
.
path
args
:
new
StructuredCloneHolder
(
listenerArgs
)
}
{
recipient
:
{
childId
}
}
)
;
}
context
.
listenerProxies
.
set
(
data
.
listenerId
listener
)
;
let
args
=
Cu
.
cloneInto
(
data
.
args
context
.
sandbox
)
;
let
promise
=
context
.
apiCan
.
asyncFindAPIPath
(
data
.
path
)
;
if
(
context
.
viewType
=
=
=
"
background
"
&
&
context
.
listenerPromises
)
{
const
{
listenerPromises
}
=
context
;
listenerPromises
.
add
(
promise
)
;
let
remove
=
(
)
=
>
{
listenerPromises
.
delete
(
promise
)
;
}
;
promise
.
then
(
remove
remove
)
;
}
let
handler
=
await
promise
;
if
(
handler
.
setUserInput
)
{
handlingUserInput
=
true
;
}
handler
.
addListener
(
listener
.
.
.
args
)
;
}
async
removeListener
(
data
)
{
let
context
=
this
.
getContextById
(
data
.
childId
)
;
let
listener
=
context
.
listenerProxies
.
get
(
data
.
listenerId
)
;
let
handler
=
await
context
.
apiCan
.
asyncFindAPIPath
(
data
.
path
)
;
handler
.
removeListener
(
listener
)
;
}
getContextById
(
childId
)
{
let
context
=
this
.
proxyContexts
.
get
(
childId
)
;
if
(
!
context
)
{
throw
new
Error
(
"
WebExtension
context
not
found
!
"
)
;
}
return
context
;
}
}
;
ParentAPIManager
.
init
(
)
;
class
HiddenXULWindow
{
constructor
(
)
{
this
.
_windowlessBrowser
=
null
;
this
.
waitInitialized
=
this
.
initWindowlessBrowser
(
)
;
}
shutdown
(
)
{
if
(
this
.
unloaded
)
{
throw
new
Error
(
"
Unable
to
shutdown
an
unloaded
HiddenXULWindow
instance
"
)
;
}
this
.
unloaded
=
true
;
this
.
chromeShell
=
null
;
this
.
waitInitialized
=
null
;
this
.
_windowlessBrowser
.
close
(
)
;
this
.
_windowlessBrowser
=
null
;
}
get
chromeDocument
(
)
{
return
this
.
_windowlessBrowser
.
document
;
}
async
initWindowlessBrowser
(
)
{
if
(
this
.
waitInitialized
)
{
throw
new
Error
(
"
HiddenXULWindow
already
initialized
"
)
;
}
let
windowlessBrowser
=
Services
.
appShell
.
createWindowlessBrowser
(
true
)
;
this
.
_windowlessBrowser
=
windowlessBrowser
;
this
.
chromeShell
=
this
.
_windowlessBrowser
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
if
(
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
let
attrs
=
this
.
chromeShell
.
getOriginAttributes
(
)
;
attrs
.
privateBrowsingId
=
1
;
this
.
chromeShell
.
setOriginAttributes
(
attrs
)
;
}
let
system
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
this
.
chromeShell
.
createAboutBlankContentViewer
(
system
)
;
this
.
chromeShell
.
useGlobalHistory
=
false
;
this
.
chromeShell
.
loadURI
(
XUL_URL
0
null
null
null
)
;
await
promiseObserved
(
"
chrome
-
document
-
global
-
created
"
win
=
>
win
.
document
=
=
this
.
chromeShell
.
document
)
;
return
promiseDocumentLoaded
(
windowlessBrowser
.
document
)
;
}
async
createBrowserElement
(
xulAttributes
)
{
if
(
!
xulAttributes
|
|
Object
.
keys
(
xulAttributes
)
.
length
=
=
=
0
)
{
throw
new
Error
(
"
missing
mandatory
xulAttributes
parameter
"
)
;
}
await
this
.
waitInitialized
;
const
chromeDoc
=
this
.
chromeDocument
;
const
browser
=
chromeDoc
.
createElement
(
"
browser
"
)
;
browser
.
setAttribute
(
"
type
"
"
content
"
)
;
browser
.
setAttribute
(
"
disableglobalhistory
"
"
true
"
)
;
for
(
const
[
name
value
]
of
Object
.
entries
(
xulAttributes
)
)
{
if
(
value
!
=
null
)
{
browser
.
setAttribute
(
name
value
)
;
}
}
let
awaitFrameLoader
=
Promise
.
resolve
(
)
;
if
(
browser
.
getAttribute
(
"
remote
"
)
=
=
=
"
true
"
)
{
awaitFrameLoader
=
promiseEvent
(
browser
"
XULFrameLoaderCreated
"
)
;
}
chromeDoc
.
documentElement
.
appendChild
(
browser
)
;
await
awaitFrameLoader
;
return
browser
;
}
}
class
HiddenExtensionPage
extends
HiddenXULWindow
{
constructor
(
extension
viewType
)
{
if
(
!
extension
|
|
!
viewType
)
{
throw
new
Error
(
"
extension
and
viewType
parameters
are
mandatory
"
)
;
}
super
(
)
;
this
.
extension
=
extension
;
this
.
viewType
=
viewType
;
this
.
browser
=
null
;
}
shutdown
(
)
{
if
(
this
.
unloaded
)
{
throw
new
Error
(
"
Unable
to
shutdown
an
unloaded
HiddenExtensionPage
instance
"
)
;
}
if
(
this
.
browser
)
{
this
.
browser
.
remove
(
)
;
this
.
browser
=
null
;
}
super
.
shutdown
(
)
;
}
async
createBrowserElement
(
)
{
if
(
this
.
browser
)
{
throw
new
Error
(
"
createBrowserElement
called
twice
"
)
;
}
this
.
browser
=
await
super
.
createBrowserElement
(
{
"
webextension
-
view
-
type
"
:
this
.
viewType
"
remote
"
:
this
.
extension
.
remote
?
"
true
"
:
null
"
remoteType
"
:
this
.
extension
.
remote
?
E10SUtils
.
EXTENSION_REMOTE_TYPE
:
null
}
)
;
return
this
.
browser
;
}
}
const
DebugUtils
=
{
hiddenXULWindow
:
null
debugBrowserPromises
:
new
Map
(
)
debugActors
:
new
DefaultWeakMap
(
(
)
=
>
new
Set
(
)
)
_extensionUpdatedWatcher
:
null
watchExtensionUpdated
(
)
{
if
(
!
this
.
_extensionUpdatedWatcher
)
{
this
.
_extensionUpdatedWatcher
=
async
(
evt
extension
)
=
>
{
const
browserPromise
=
this
.
debugBrowserPromises
.
get
(
extension
.
id
)
;
if
(
browserPromise
)
{
const
browser
=
await
browserPromise
;
if
(
browser
.
isRemoteBrowser
!
=
=
extension
.
remote
&
&
this
.
debugBrowserPromises
.
get
(
extension
.
id
)
=
=
=
browserPromise
)
{
this
.
debugBrowserPromises
.
delete
(
extension
.
id
)
;
browser
.
remove
(
)
;
}
}
}
;
apiManager
.
on
(
"
ready
"
this
.
_extensionUpdatedWatcher
)
;
}
}
unwatchExtensionUpdated
(
)
{
if
(
this
.
_extensionUpdatedWatcher
)
{
apiManager
.
off
(
"
ready
"
this
.
_extensionUpdatedWatcher
)
;
delete
this
.
_extensionUpdatedWatcher
;
}
}
async
getExtensionProcessBrowser
(
webExtensionParentActor
)
{
const
extensionId
=
webExtensionParentActor
.
addonId
;
const
extension
=
GlobalManager
.
getExtension
(
extensionId
)
;
if
(
!
extension
)
{
throw
new
Error
(
Extension
not
found
:
{
extensionId
}
)
;
}
const
createBrowser
=
(
)
=
>
{
if
(
!
this
.
hiddenXULWindow
)
{
this
.
hiddenXULWindow
=
new
HiddenXULWindow
(
)
;
this
.
watchExtensionUpdated
(
)
;
}
return
this
.
hiddenXULWindow
.
createBrowserElement
(
{
"
webextension
-
addon
-
debug
-
target
"
:
extensionId
"
remote
"
:
extension
.
remote
?
"
true
"
:
null
"
remoteType
"
:
extension
.
remote
?
E10SUtils
.
EXTENSION_REMOTE_TYPE
:
null
}
)
;
}
;
let
browserPromise
=
this
.
debugBrowserPromises
.
get
(
extensionId
)
;
if
(
!
browserPromise
)
{
browserPromise
=
createBrowser
(
)
;
this
.
debugBrowserPromises
.
set
(
extensionId
browserPromise
)
;
browserPromise
.
catch
(
(
)
=
>
{
this
.
debugBrowserPromises
.
delete
(
extensionId
)
;
}
)
;
}
this
.
debugActors
.
get
(
browserPromise
)
.
add
(
webExtensionParentActor
)
;
return
browserPromise
;
}
async
releaseExtensionProcessBrowser
(
webExtensionParentActor
)
{
const
extensionId
=
webExtensionParentActor
.
addonId
;
const
browserPromise
=
this
.
debugBrowserPromises
.
get
(
extensionId
)
;
if
(
browserPromise
)
{
const
actorsSet
=
this
.
debugActors
.
get
(
browserPromise
)
;
actorsSet
.
delete
(
webExtensionParentActor
)
;
if
(
actorsSet
.
size
=
=
=
0
)
{
this
.
debugActors
.
delete
(
browserPromise
)
;
this
.
debugBrowserPromises
.
delete
(
extensionId
)
;
await
browserPromise
.
then
(
(
browser
)
=
>
browser
.
remove
(
)
)
;
}
}
if
(
this
.
debugBrowserPromises
.
size
=
=
=
0
&
&
this
.
hiddenXULWindow
)
{
this
.
hiddenXULWindow
.
shutdown
(
)
;
this
.
hiddenXULWindow
=
null
;
this
.
unwatchExtensionUpdated
(
)
;
}
}
}
;
function
promiseExtensionViewLoaded
(
browser
)
{
return
new
Promise
(
resolve
=
>
{
browser
.
messageManager
.
addMessageListener
(
"
Extension
:
ExtensionViewLoaded
"
function
onLoad
(
{
data
}
)
{
browser
.
messageManager
.
removeMessageListener
(
"
Extension
:
ExtensionViewLoaded
"
onLoad
)
;
resolve
(
data
.
childId
&
&
ParentAPIManager
.
getContextById
(
data
.
childId
)
)
;
}
)
;
}
)
;
}
function
watchExtensionProxyContextLoad
(
{
extension
viewType
browser
}
onExtensionProxyContextLoaded
)
{
if
(
typeof
onExtensionProxyContextLoaded
!
=
=
"
function
"
)
{
throw
new
Error
(
"
Missing
onExtensionProxyContextLoaded
handler
"
)
;
}
const
listener
=
(
event
context
)
=
>
{
if
(
context
.
viewType
=
=
viewType
&
&
context
.
xulBrowser
=
=
browser
)
{
onExtensionProxyContextLoaded
(
context
)
;
}
}
;
extension
.
on
(
"
extension
-
proxy
-
context
-
load
"
listener
)
;
return
(
)
=
>
{
extension
.
off
(
"
extension
-
proxy
-
context
-
load
"
listener
)
;
}
;
}
let
gBaseManifestProperties
=
null
;
function
extensionNameFromURI
(
uri
)
{
let
id
=
null
;
try
{
id
=
gAddonPolicyService
.
extensionURIToAddonId
(
uri
)
;
}
catch
(
ex
)
{
if
(
ex
.
name
!
=
"
NS_ERROR_XPC_BAD_CONVERT_JS
"
)
{
Cu
.
reportError
(
"
Extension
cannot
be
found
in
AddonPolicyService
.
"
)
;
}
}
return
GlobalManager
.
getExtension
(
id
)
.
name
;
}
const
INTEGER
=
/
^
[
1
-
9
]
\
d
*
/
;
let
IconDetails
=
{
iconCache
:
new
DefaultWeakMap
(
(
)
=
>
new
Map
(
)
)
normalize
(
details
extension
context
=
null
)
{
if
(
!
details
.
imageData
&
&
typeof
details
.
path
=
=
=
"
string
"
)
{
let
icons
=
this
.
iconCache
.
get
(
extension
)
;
let
baseURI
=
context
?
context
.
uri
:
extension
.
baseURI
;
let
url
=
baseURI
.
resolve
(
details
.
path
)
;
let
icon
=
icons
.
get
(
url
)
;
if
(
!
icon
)
{
icon
=
this
.
_normalize
(
details
extension
context
)
;
icons
.
set
(
url
icon
)
;
}
return
icon
;
}
return
this
.
_normalize
(
details
extension
context
)
;
}
_normalize
(
details
extension
context
=
null
)
{
let
result
=
{
}
;
try
{
let
{
imageData
path
themeIcons
}
=
details
;
if
(
imageData
)
{
if
(
typeof
imageData
=
=
"
string
"
)
{
imageData
=
{
"
19
"
:
imageData
}
;
}
for
(
let
size
of
Object
.
keys
(
imageData
)
)
{
if
(
!
INTEGER
.
test
(
size
)
)
{
throw
new
ExtensionError
(
Invalid
icon
size
{
size
}
must
be
an
integer
)
;
}
result
[
size
]
=
imageData
[
size
]
;
}
}
let
baseURI
=
context
?
context
.
uri
:
extension
.
baseURI
;
if
(
path
)
{
if
(
typeof
path
!
=
"
object
"
)
{
path
=
{
"
19
"
:
path
}
;
}
for
(
let
size
of
Object
.
keys
(
path
)
)
{
if
(
!
INTEGER
.
test
(
size
)
)
{
throw
new
ExtensionError
(
Invalid
icon
size
{
size
}
must
be
an
integer
)
;
}
let
url
=
baseURI
.
resolve
(
path
[
size
]
)
;
this
.
_checkURL
(
url
extension
.
principal
)
;
result
[
size
]
=
url
;
}
}
if
(
themeIcons
)
{
themeIcons
.
forEach
(
(
{
size
light
dark
}
)
=
>
{
let
lightURL
=
baseURI
.
resolve
(
light
)
;
let
darkURL
=
baseURI
.
resolve
(
dark
)
;
this
.
_checkURL
(
lightURL
extension
.
principal
)
;
this
.
_checkURL
(
darkURL
extension
.
principal
)
;
let
defaultURL
=
result
[
size
]
;
result
[
size
]
=
{
"
default
"
:
defaultURL
|
|
lightURL
"
light
"
:
lightURL
"
dark
"
:
darkURL
}
;
}
)
;
}
}
catch
(
e
)
{
if
(
context
)
{
throw
e
;
}
extension
.
manifestError
(
Invalid
icon
data
:
{
e
}
)
;
}
return
result
;
}
_checkURL
(
url
principal
)
{
try
{
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
principal
url
Services
.
scriptSecurityManager
.
DISALLOW_SCRIPT
)
;
}
catch
(
e
)
{
throw
new
ExtensionError
(
Illegal
URL
{
url
}
)
;
}
}
getPreferredIcon
(
icons
extension
=
null
size
=
16
)
{
const
DEFAULT
=
"
chrome
:
/
/
browser
/
content
/
extension
.
svg
"
;
let
bestSize
=
null
;
if
(
icons
[
size
]
)
{
bestSize
=
size
;
}
else
if
(
icons
[
2
*
size
]
)
{
bestSize
=
2
*
size
;
}
else
{
let
sizes
=
Object
.
keys
(
icons
)
.
map
(
key
=
>
parseInt
(
key
10
)
)
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
bestSize
=
sizes
.
find
(
candidate
=
>
candidate
>
size
)
|
|
sizes
.
pop
(
)
;
}
if
(
bestSize
)
{
return
{
size
:
bestSize
icon
:
icons
[
bestSize
]
}
;
}
return
{
size
icon
:
DEFAULT
}
;
}
convertImageURLToDataURL
(
imageURL
contentWindow
browserWindow
size
=
18
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
image
=
new
contentWindow
.
Image
(
)
;
image
.
onload
=
function
(
)
{
let
canvas
=
contentWindow
.
document
.
createElement
(
"
canvas
"
)
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
let
dSize
=
size
*
browserWindow
.
devicePixelRatio
;
let
dWidth
dHeight
dx
dy
;
if
(
this
.
width
>
this
.
height
)
{
dWidth
=
dSize
;
dHeight
=
image
.
height
*
(
dSize
/
image
.
width
)
;
dx
=
0
;
dy
=
(
dSize
-
dHeight
)
/
2
;
}
else
{
dWidth
=
image
.
width
*
(
dSize
/
image
.
height
)
;
dHeight
=
dSize
;
dx
=
(
dSize
-
dWidth
)
/
2
;
dy
=
0
;
}
canvas
.
width
=
dSize
;
canvas
.
height
=
dSize
;
ctx
.
drawImage
(
this
0
0
this
.
width
this
.
height
dx
dy
dWidth
dHeight
)
;
resolve
(
canvas
.
toDataURL
(
"
image
/
png
"
)
)
;
}
;
image
.
onerror
=
reject
;
image
.
src
=
imageURL
;
}
)
;
}
escapeUrl
(
url
)
{
return
url
.
replace
(
/
[
\
\
\
s
"
]
/
g
encodeURIComponent
)
;
}
}
;
let
StartupCache
=
{
DB_NAME
:
"
ExtensionStartupCache
"
SCHEMA_VERSION
:
4
STORE_NAMES
:
Object
.
freeze
(
[
"
locales
"
"
manifests
"
"
schemas
"
]
)
dbPromise
:
null
initDB
(
db
)
{
for
(
let
name
of
StartupCache
.
STORE_NAMES
)
{
try
{
db
.
deleteObjectStore
(
name
)
;
}
catch
(
e
)
{
}
db
.
createObjectStore
(
name
{
keyPath
:
"
key
"
}
)
;
}
}
clearAddonData
(
id
)
{
let
range
=
IDBKeyRange
.
bound
(
[
id
]
[
id
"
\
uFFFF
"
]
)
;
return
Promise
.
all
(
[
this
.
locales
.
delete
(
range
)
this
.
manifests
.
delete
(
range
)
]
)
.
catch
(
e
=
>
{
this
.
dbPromise
=
this
.
reallyOpen
(
true
)
.
catch
(
e
=
>
{
}
)
;
}
)
;
}
async
reallyOpen
(
invalidate
=
false
)
{
if
(
this
.
dbPromise
)
{
let
db
=
await
this
.
dbPromise
;
db
.
close
(
)
;
}
if
(
invalidate
)
{
IndexedDB
.
deleteDatabase
(
this
.
DB_NAME
{
storage
:
"
persistent
"
}
)
;
}
return
IndexedDB
.
open
(
this
.
DB_NAME
{
storage
:
"
persistent
"
version
:
this
.
SCHEMA_VERSION
}
db
=
>
this
.
initDB
(
db
)
)
;
}
async
open
(
)
{
if
(
!
this
.
dbPromise
)
{
this
.
dbPromise
=
this
.
reallyOpen
(
)
;
}
return
this
.
dbPromise
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
"
startupcache
-
invalidate
"
)
{
this
.
dbPromise
=
this
.
reallyOpen
(
true
)
.
catch
(
e
=
>
{
}
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
StartupCache
"
startupcache
-
invalidate
"
)
;
class
CacheStore
{
constructor
(
storeName
)
{
this
.
storeName
=
storeName
;
}
async
get
(
key
createFunc
)
{
let
db
;
let
result
;
try
{
db
=
await
StartupCache
.
open
(
)
;
result
=
await
db
.
objectStore
(
this
.
storeName
)
.
get
(
key
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
createFunc
(
key
)
;
}
if
(
result
=
=
=
undefined
)
{
let
value
=
await
createFunc
(
key
)
;
result
=
{
key
value
}
;
try
{
db
.
objectStore
(
this
.
storeName
"
readwrite
"
)
.
put
(
result
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
return
result
&
&
result
.
value
;
}
async
getAll
(
)
{
let
result
=
new
Map
(
)
;
try
{
let
db
=
await
StartupCache
.
open
(
)
;
let
results
=
await
db
.
objectStore
(
this
.
storeName
)
.
getAll
(
)
;
for
(
let
{
key
value
}
of
results
)
{
result
.
set
(
key
value
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
result
;
}
async
delete
(
key
)
{
let
db
=
await
StartupCache
.
open
(
)
;
return
db
.
objectStore
(
this
.
storeName
"
readwrite
"
)
.
delete
(
key
)
;
}
}
for
(
let
name
of
StartupCache
.
STORE_NAMES
)
{
StartupCache
[
name
]
=
new
CacheStore
(
name
)
;
}
var
ExtensionParent
=
{
extensionNameFromURI
GlobalManager
HiddenExtensionPage
IconDetails
ParentAPIManager
StartupCache
WebExtensionPolicy
apiManager
get
baseManifestProperties
(
)
{
if
(
gBaseManifestProperties
)
{
return
gBaseManifestProperties
;
}
let
types
=
Schemas
.
schemaJSON
.
get
(
BASE_SCHEMA
)
[
0
]
.
types
;
let
manifest
=
types
.
find
(
type
=
>
type
.
id
=
=
=
"
WebExtensionManifest
"
)
;
if
(
!
manifest
)
{
throw
new
Error
(
"
Unable
to
find
base
manifest
properties
"
)
;
}
gBaseManifestProperties
=
Object
.
getOwnPropertyNames
(
manifest
.
properties
)
;
return
gBaseManifestProperties
;
}
promiseExtensionViewLoaded
watchExtensionProxyContextLoad
DebugUtils
}
;
XPCOMUtils
.
defineLazyGetter
(
ExtensionParent
"
PlatformInfo
"
(
)
=
>
{
return
Object
.
freeze
(
{
os
:
(
function
(
)
{
let
os
=
AppConstants
.
platform
;
if
(
os
=
=
"
macosx
"
)
{
os
=
"
mac
"
;
}
return
os
;
}
)
(
)
arch
:
(
function
(
)
{
let
abi
=
Services
.
appinfo
.
XPCOMABI
;
let
[
arch
]
=
abi
.
split
(
"
-
"
)
;
if
(
arch
=
=
"
x86
"
)
{
arch
=
"
x86
-
32
"
;
}
else
if
(
arch
=
=
"
x86_64
"
)
{
arch
=
"
x86
-
64
"
;
}
return
arch
;
}
)
(
)
}
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
ExtensionParent
"
extensionStylesheets
"
(
)
=
>
{
let
stylesheets
=
[
"
chrome
:
/
/
browser
/
content
/
extension
.
css
"
]
;
if
(
AppConstants
.
platform
=
=
=
"
macosx
"
)
{
stylesheets
.
push
(
"
chrome
:
/
/
browser
/
content
/
extension
-
mac
.
css
"
)
;
}
return
stylesheets
;
}
)
;
