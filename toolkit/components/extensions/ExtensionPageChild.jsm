"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExtensionPageChild
"
"
getContextChildManagerGetter
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionChildDevToolsUtils
"
"
resource
:
/
/
gre
/
modules
/
ExtensionChildDevToolsUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Schemas
"
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
)
;
const
CATEGORY_EXTENSION_SCRIPTS_ADDON
=
"
webextension
-
scripts
-
addon
"
;
const
CATEGORY_EXTENSION_SCRIPTS_DEVTOOLS
=
"
webextension
-
scripts
-
devtools
"
;
const
{
ExtensionCommon
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
const
{
ExtensionChild
ExtensionActivityLogChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionChild
.
jsm
"
)
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
{
getInnerWindowID
promiseEvent
}
=
ExtensionUtils
;
const
{
BaseContext
CanOfAPIs
SchemaAPIManager
defineLazyGetter
}
=
ExtensionCommon
;
const
{
ChildAPIManager
Messenger
}
=
ExtensionChild
;
var
ExtensionPageChild
;
const
initializeBackgroundPage
=
context
=
>
{
let
alertDisplayedWarning
=
false
;
const
innerWindowID
=
getInnerWindowID
(
context
.
contentWindow
)
;
function
logWarningMessage
(
{
text
filename
lineNumber
columnNumber
}
)
{
let
consoleMsg
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
consoleMsg
.
initWithWindowID
(
text
filename
null
lineNumber
columnNumber
Ci
.
nsIScriptError
.
warningFlag
"
webextension
"
innerWindowID
)
;
Services
.
console
.
logMessage
(
consoleMsg
)
;
}
function
ignoredSuspendListener
(
)
{
logWarningMessage
(
{
text
:
"
Background
event
page
was
not
terminated
on
idle
because
a
DevTools
toolbox
is
attached
to
the
extension
.
"
filename
:
context
.
contentWindow
.
location
.
href
}
)
;
}
if
(
!
context
.
extension
.
manifest
.
background
.
persistent
)
{
context
.
extension
.
on
(
"
background
-
script
-
suspend
-
ignored
"
ignoredSuspendListener
)
;
context
.
callOnClose
(
{
close
:
(
)
=
>
{
context
.
extension
.
off
(
"
background
-
script
-
suspend
-
ignored
"
ignoredSuspendListener
)
;
}
}
)
;
}
let
alertOverwrite
=
text
=
>
{
const
{
filename
columnNumber
lineNumber
}
=
Components
.
stack
.
caller
;
if
(
!
alertDisplayedWarning
)
{
context
.
childManager
.
callParentAsyncFunction
(
"
runtime
.
openBrowserConsole
"
[
]
)
;
logWarningMessage
(
{
text
:
"
alert
(
)
is
not
supported
in
background
windows
;
please
use
console
.
log
instead
.
"
filename
lineNumber
columnNumber
}
)
;
alertDisplayedWarning
=
true
;
}
logWarningMessage
(
{
text
filename
lineNumber
columnNumber
}
)
;
}
;
Cu
.
exportFunction
(
alertOverwrite
context
.
contentWindow
{
defineAs
:
"
alert
"
}
)
;
}
;
var
apiManager
=
new
(
class
extends
SchemaAPIManager
{
constructor
(
)
{
super
(
"
addon
"
Schemas
)
;
this
.
initialized
=
false
;
}
lazyInit
(
)
{
if
(
!
this
.
initialized
)
{
this
.
initialized
=
true
;
this
.
initGlobal
(
)
;
for
(
let
{
value
}
of
Services
.
catMan
.
enumerateCategory
(
CATEGORY_EXTENSION_SCRIPTS_ADDON
)
)
{
this
.
loadScript
(
value
)
;
}
}
}
}
)
(
)
;
var
devtoolsAPIManager
=
new
(
class
extends
SchemaAPIManager
{
constructor
(
)
{
super
(
"
devtools
"
Schemas
)
;
this
.
initialized
=
false
;
}
lazyInit
(
)
{
if
(
!
this
.
initialized
)
{
this
.
initialized
=
true
;
this
.
initGlobal
(
)
;
for
(
let
{
value
}
of
Services
.
catMan
.
enumerateCategory
(
CATEGORY_EXTENSION_SCRIPTS_DEVTOOLS
)
)
{
this
.
loadScript
(
value
)
;
}
}
}
}
)
(
)
;
function
getContextChildManagerGetter
(
{
envType
}
ChildAPIManagerClass
=
ChildAPIManager
)
{
return
function
(
)
{
let
apiManager
=
envType
=
=
=
"
devtools_parent
"
?
devtoolsAPIManager
:
this
.
extension
.
apiManager
;
apiManager
.
lazyInit
(
)
;
let
localApis
=
{
}
;
let
can
=
new
CanOfAPIs
(
this
apiManager
localApis
)
;
let
childManager
=
new
ChildAPIManagerClass
(
this
this
.
messageManager
can
{
envType
viewType
:
this
.
viewType
url
:
this
.
uri
.
spec
incognito
:
this
.
incognito
.
.
.
this
.
getCreateProxyContextData
?
.
(
)
}
)
;
this
.
callOnClose
(
childManager
)
;
return
childManager
;
}
;
}
class
ExtensionBaseContextChild
extends
BaseContext
{
constructor
(
extension
params
)
{
if
(
!
params
.
envType
)
{
throw
new
Error
(
"
Missing
envType
"
)
;
}
super
(
params
.
envType
extension
)
;
let
{
viewType
=
"
tab
"
uri
contentWindow
tabId
}
=
params
;
this
.
viewType
=
viewType
;
this
.
uri
=
uri
|
|
extension
.
baseURI
;
this
.
setContentWindow
(
contentWindow
)
;
this
.
browsingContextId
=
contentWindow
.
docShell
.
browsingContext
.
id
;
if
(
viewType
=
=
"
tab
"
)
{
Object
.
defineProperty
(
this
"
tabId
"
{
value
:
tabId
enumerable
:
true
configurable
:
true
}
)
;
}
Schemas
.
exportLazyGetter
(
contentWindow
"
browser
"
(
)
=
>
{
let
browserObj
=
Cu
.
createObjectIn
(
contentWindow
)
;
this
.
childManager
.
inject
(
browserObj
)
;
return
browserObj
;
}
)
;
Schemas
.
exportLazyGetter
(
contentWindow
"
chrome
"
(
)
=
>
{
let
chromeApiWrapper
=
Object
.
create
(
this
.
childManager
)
;
chromeApiWrapper
.
isChromeCompat
=
true
;
let
chromeObj
=
Cu
.
createObjectIn
(
contentWindow
)
;
chromeApiWrapper
.
inject
(
chromeObj
)
;
return
chromeObj
;
}
)
;
}
logActivity
(
type
name
data
)
{
ExtensionActivityLogChild
.
log
(
this
type
name
data
)
;
}
get
cloneScope
(
)
{
return
this
.
contentWindow
;
}
get
principal
(
)
{
return
this
.
contentWindow
.
document
.
nodePrincipal
;
}
get
tabId
(
)
{
return
-
1
;
}
shutdown
(
)
{
if
(
this
.
contentWindow
)
{
this
.
contentWindow
.
close
(
)
;
}
this
.
unload
(
)
;
}
unload
(
)
{
if
(
this
.
unloaded
)
{
return
;
}
super
.
unload
(
)
;
}
}
defineLazyGetter
(
ExtensionBaseContextChild
.
prototype
"
messenger
"
function
(
)
{
return
new
Messenger
(
this
)
;
}
)
;
class
ExtensionPageContextChild
extends
ExtensionBaseContextChild
{
constructor
(
extension
params
)
{
super
(
extension
Object
.
assign
(
params
{
envType
:
"
addon_child
"
}
)
)
;
if
(
this
.
viewType
=
=
"
background
"
)
{
initializeBackgroundPage
(
this
)
;
}
this
.
extension
.
views
.
add
(
this
)
;
}
unload
(
)
{
super
.
unload
(
)
;
this
.
extension
.
views
.
delete
(
this
)
;
}
}
defineLazyGetter
(
ExtensionPageContextChild
.
prototype
"
childManager
"
getContextChildManagerGetter
(
{
envType
:
"
addon_parent
"
}
)
)
;
class
DevToolsContextChild
extends
ExtensionBaseContextChild
{
constructor
(
extension
params
)
{
super
(
extension
Object
.
assign
(
params
{
envType
:
"
devtools_child
"
}
)
)
;
this
.
devtoolsToolboxInfo
=
params
.
devtoolsToolboxInfo
;
ExtensionChildDevToolsUtils
.
initThemeChangeObserver
(
params
.
devtoolsToolboxInfo
.
themeName
this
)
;
this
.
extension
.
devtoolsViews
.
add
(
this
)
;
}
unload
(
)
{
super
.
unload
(
)
;
this
.
extension
.
devtoolsViews
.
delete
(
this
)
;
}
}
defineLazyGetter
(
DevToolsContextChild
.
prototype
"
childManager
"
getContextChildManagerGetter
(
{
envType
:
"
devtools_parent
"
}
)
)
;
ExtensionPageChild
=
{
initialized
:
false
extensionContexts
:
new
Map
(
)
apiManager
_init
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
initialized
=
true
;
Services
.
obs
.
addObserver
(
this
"
inner
-
window
-
destroyed
"
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
"
inner
-
window
-
destroyed
"
)
{
let
windowId
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
;
this
.
destroyExtensionContext
(
windowId
)
;
}
}
expectViewLoad
(
global
viewType
)
{
if
(
[
"
popup
"
"
sidebar
"
]
.
includes
(
viewType
)
)
{
global
.
docShell
.
isAppTab
=
true
;
}
promiseEvent
(
global
"
DOMContentLoaded
"
true
event
=
>
event
.
target
.
location
!
=
"
about
:
blank
"
)
.
then
(
(
)
=
>
{
let
windowId
=
getInnerWindowID
(
global
.
content
)
;
let
context
=
this
.
extensionContexts
.
get
(
windowId
)
;
global
.
sendAsyncMessage
(
"
Extension
:
ExtensionViewLoaded
"
{
childId
:
context
&
&
context
.
childManager
.
id
}
)
;
}
)
;
}
initExtensionContext
(
extension
contentWindow
)
{
this
.
_init
(
)
;
if
(
!
WebExtensionPolicy
.
isExtensionProcess
)
{
throw
new
Error
(
"
Cannot
create
an
extension
page
context
in
current
process
"
)
;
}
let
windowId
=
getInnerWindowID
(
contentWindow
)
;
let
context
=
this
.
extensionContexts
.
get
(
windowId
)
;
if
(
context
)
{
if
(
context
.
extension
!
=
=
extension
)
{
throw
new
Error
(
"
A
different
extension
context
already
exists
for
this
frame
"
)
;
}
throw
new
Error
(
"
An
extension
context
was
already
initialized
for
this
frame
"
)
;
}
let
uri
=
contentWindow
.
document
.
documentURIObject
;
let
mm
=
contentWindow
.
docShell
.
messageManager
;
let
data
=
mm
.
sendSyncMessage
(
"
Extension
:
GetFrameData
"
)
[
0
]
;
if
(
!
data
)
{
let
policy
=
WebExtensionPolicy
.
getByHostname
(
uri
.
host
)
;
Cu
.
reportError
(
FrameData
missing
for
{
policy
?
.
id
}
page
{
uri
.
spec
}
)
;
}
let
{
viewType
tabId
devtoolsToolboxInfo
}
=
data
?
?
{
}
;
if
(
viewType
)
{
ExtensionPageChild
.
expectViewLoad
(
mm
viewType
)
;
}
if
(
devtoolsToolboxInfo
)
{
context
=
new
DevToolsContextChild
(
extension
{
viewType
contentWindow
uri
tabId
devtoolsToolboxInfo
}
)
;
}
else
{
context
=
new
ExtensionPageContextChild
(
extension
{
viewType
contentWindow
uri
tabId
}
)
;
}
this
.
extensionContexts
.
set
(
windowId
context
)
;
}
destroyExtensionContext
(
windowId
)
{
let
context
=
this
.
extensionContexts
.
get
(
windowId
)
;
if
(
context
)
{
context
.
unload
(
)
;
this
.
extensionContexts
.
delete
(
windowId
)
;
}
}
shutdownExtension
(
extensionId
)
{
for
(
let
[
windowId
context
]
of
this
.
extensionContexts
)
{
if
(
context
.
extension
.
id
=
=
extensionId
)
{
context
.
shutdown
(
)
;
this
.
extensionContexts
.
delete
(
windowId
)
;
}
}
}
}
;
