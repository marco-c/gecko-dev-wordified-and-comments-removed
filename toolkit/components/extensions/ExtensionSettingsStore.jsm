"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionSettingsStore
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
JSONFile
"
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
)
;
const
JSON_FILE_NAME
=
"
extension
-
settings
.
json
"
;
const
JSON_FILE_VERSION
=
2
;
const
STORE_PATH
=
OS
.
Path
.
join
(
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
.
path
JSON_FILE_NAME
)
;
let
_initializePromise
;
let
_store
=
{
}
;
function
dataPostProcessor
(
json
)
{
if
(
json
.
version
!
=
=
JSON_FILE_VERSION
)
{
for
(
let
storeType
in
json
)
{
for
(
let
setting
in
json
[
storeType
]
)
{
for
(
let
extData
of
json
[
storeType
]
[
setting
]
.
precedenceList
)
{
if
(
typeof
extData
.
installDate
!
=
"
number
"
)
{
extData
.
installDate
=
new
Date
(
extData
.
installDate
)
.
valueOf
(
)
;
}
}
}
}
json
.
version
=
JSON_FILE_VERSION
;
}
return
json
;
}
function
initialize
(
)
{
if
(
!
_initializePromise
)
{
_store
=
new
JSONFile
(
{
path
:
STORE_PATH
dataPostProcessor
}
)
;
_initializePromise
=
_store
.
load
(
)
;
}
return
_initializePromise
;
}
async
function
reloadFile
(
finalize
)
{
if
(
finalize
)
{
await
_store
.
finalize
(
)
;
}
_initializePromise
=
null
;
return
initialize
(
)
;
}
function
ensureType
(
type
)
{
if
(
!
_store
.
dataReady
)
{
throw
new
Error
(
"
The
ExtensionSettingsStore
was
accessed
before
the
initialize
promise
resolved
.
"
)
;
}
if
(
!
_store
.
data
[
type
]
)
{
_store
.
data
[
type
]
=
{
}
;
}
}
function
getTopItem
(
type
key
)
{
ensureType
(
type
)
;
let
keyInfo
=
_store
.
data
[
type
]
[
key
]
;
if
(
!
keyInfo
)
{
return
null
;
}
for
(
let
item
of
keyInfo
.
precedenceList
)
{
if
(
item
.
enabled
)
{
return
{
key
value
:
item
.
value
id
:
item
.
id
}
;
}
}
return
{
key
initialValue
:
keyInfo
.
initialValue
}
;
}
function
precedenceComparator
(
a
b
)
{
if
(
a
.
enabled
&
&
!
b
.
enabled
)
{
return
-
1
;
}
if
(
b
.
enabled
&
&
!
a
.
enabled
)
{
return
1
;
}
return
b
.
installDate
-
a
.
installDate
;
}
function
alterSetting
(
extension
type
key
action
)
{
let
returnItem
;
ensureType
(
type
)
;
let
keyInfo
=
_store
.
data
[
type
]
[
key
]
;
if
(
!
keyInfo
)
{
if
(
action
=
=
=
"
remove
"
)
{
return
null
;
}
throw
new
Error
(
Cannot
alter
the
setting
for
{
type
}
:
{
key
}
as
it
does
not
exist
.
)
;
}
let
id
=
extension
.
id
;
let
foundIndex
=
keyInfo
.
precedenceList
.
findIndex
(
item
=
>
item
.
id
=
=
id
)
;
if
(
foundIndex
=
=
=
-
1
)
{
if
(
action
=
=
=
"
remove
"
)
{
return
null
;
}
throw
new
Error
(
Cannot
alter
the
setting
for
{
type
}
:
{
key
}
as
it
does
not
exist
.
)
;
}
switch
(
action
)
{
case
"
remove
"
:
keyInfo
.
precedenceList
.
splice
(
foundIndex
1
)
;
break
;
case
"
enable
"
:
keyInfo
.
precedenceList
[
foundIndex
]
.
enabled
=
true
;
keyInfo
.
precedenceList
.
sort
(
precedenceComparator
)
;
foundIndex
=
keyInfo
.
precedenceList
.
findIndex
(
item
=
>
item
.
id
=
=
id
)
;
break
;
case
"
disable
"
:
keyInfo
.
precedenceList
[
foundIndex
]
.
enabled
=
false
;
keyInfo
.
precedenceList
.
sort
(
precedenceComparator
)
;
break
;
default
:
throw
new
Error
(
{
action
}
is
not
a
valid
action
for
alterSetting
.
)
;
}
if
(
foundIndex
=
=
=
0
)
{
returnItem
=
getTopItem
(
type
key
)
;
}
if
(
action
=
=
=
"
remove
"
&
&
keyInfo
.
precedenceList
.
length
=
=
=
0
)
{
delete
_store
.
data
[
type
]
[
key
]
;
}
_store
.
saveSoon
(
)
;
return
returnItem
;
}
this
.
ExtensionSettingsStore
=
{
initialize
(
)
{
return
initialize
(
)
;
}
async
addSetting
(
extension
type
key
value
initialValueCallback
callbackArgument
=
key
)
{
if
(
typeof
initialValueCallback
!
=
"
function
"
)
{
throw
new
Error
(
"
initialValueCallback
must
be
a
function
.
"
)
;
}
let
id
=
extension
.
id
;
ensureType
(
type
)
;
if
(
!
_store
.
data
[
type
]
[
key
]
)
{
let
initialValue
=
await
initialValueCallback
(
callbackArgument
)
;
_store
.
data
[
type
]
[
key
]
=
{
initialValue
precedenceList
:
[
]
}
;
}
let
keyInfo
=
_store
.
data
[
type
]
[
key
]
;
let
foundIndex
=
keyInfo
.
precedenceList
.
findIndex
(
item
=
>
item
.
id
=
=
id
)
;
if
(
foundIndex
=
=
=
-
1
)
{
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
keyInfo
.
precedenceList
.
push
(
{
id
installDate
:
addon
.
installDate
.
valueOf
(
)
value
enabled
:
true
}
)
;
}
else
{
keyInfo
.
precedenceList
[
foundIndex
]
.
value
=
value
;
}
keyInfo
.
precedenceList
.
sort
(
precedenceComparator
)
;
_store
.
saveSoon
(
)
;
if
(
keyInfo
.
precedenceList
[
0
]
.
id
=
=
id
)
{
return
{
id
key
value
}
;
}
return
null
;
}
removeSetting
(
extension
type
key
)
{
return
alterSetting
(
extension
type
key
"
remove
"
)
;
}
enable
(
extension
type
key
)
{
return
alterSetting
(
extension
type
key
"
enable
"
)
;
}
disable
(
extension
type
key
)
{
return
alterSetting
(
extension
type
key
"
disable
"
)
;
}
setByUser
(
type
key
)
{
let
{
precedenceList
}
=
(
_store
.
data
[
type
]
&
&
_store
.
data
[
type
]
[
key
]
)
|
|
{
}
;
if
(
!
precedenceList
)
{
return
;
}
for
(
let
item
of
precedenceList
)
{
item
.
enabled
=
false
;
}
_store
.
saveSoon
(
)
;
}
getAllForExtension
(
extension
type
)
{
ensureType
(
type
)
;
let
keysObj
=
_store
.
data
[
type
]
;
let
items
=
[
]
;
for
(
let
key
in
keysObj
)
{
if
(
keysObj
[
key
]
.
precedenceList
.
find
(
item
=
>
item
.
id
=
=
extension
.
id
)
)
{
items
.
push
(
key
)
;
}
}
return
items
;
}
getSetting
(
type
key
)
{
return
getTopItem
(
type
key
)
;
}
hasSetting
(
extension
type
key
)
{
return
this
.
getAllForExtension
(
extension
type
)
.
includes
(
key
)
;
}
async
getLevelOfControl
(
extension
type
key
)
{
ensureType
(
type
)
;
let
keyInfo
=
_store
.
data
[
type
]
[
key
]
;
if
(
!
keyInfo
|
|
!
keyInfo
.
precedenceList
.
length
)
{
return
"
controllable_by_this_extension
"
;
}
let
id
=
extension
.
id
;
let
enabledItems
=
keyInfo
.
precedenceList
.
filter
(
item
=
>
item
.
enabled
)
;
if
(
!
enabledItems
.
length
)
{
return
"
controllable_by_this_extension
"
;
}
let
topItem
=
enabledItems
[
0
]
;
if
(
topItem
.
id
=
=
id
)
{
return
"
controlled_by_this_extension
"
;
}
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
return
topItem
.
installDate
>
addon
.
installDate
.
valueOf
(
)
?
"
controlled_by_other_extensions
"
:
"
controllable_by_this_extension
"
;
}
_reloadFile
(
finalize
=
true
)
{
return
reloadFile
(
finalize
)
;
}
}
;
