"
use
strict
"
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Downloads
"
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
DownloadPaths
"
"
resource
:
/
/
gre
/
modules
/
DownloadPaths
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
{
ignoreEvent
}
=
ExtensionUtils
;
let
currentId
=
0
;
extensions
.
registerSchemaAPI
(
"
downloads
"
"
downloads
"
(
extension
context
)
=
>
{
return
{
downloads
:
{
download
(
options
)
{
if
(
options
.
filename
!
=
null
)
{
if
(
options
.
filename
.
length
=
=
0
)
{
return
Promise
.
reject
(
{
message
:
"
filename
must
not
be
empty
"
}
)
;
}
let
path
=
OS
.
Path
.
split
(
options
.
filename
)
;
if
(
path
.
absolute
)
{
return
Promise
.
reject
(
{
message
:
"
filename
must
not
be
an
absolute
path
"
}
)
;
}
if
(
path
.
components
.
some
(
component
=
>
component
=
=
"
.
.
"
)
)
{
return
Promise
.
reject
(
{
message
:
"
filename
must
not
contain
back
-
references
(
.
.
)
"
}
)
;
}
}
if
(
options
.
conflictAction
=
=
"
prompt
"
)
{
return
Promise
.
reject
(
{
message
:
"
conflictAction
prompt
not
yet
implemented
"
}
)
;
}
function
createTarget
(
downloadsDir
)
{
let
target
;
if
(
options
.
filename
)
{
target
=
OS
.
Path
.
join
(
downloadsDir
options
.
filename
)
;
}
else
{
let
uri
=
NetUtil
.
newURI
(
options
.
url
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
target
=
OS
.
Path
.
join
(
downloadsDir
uri
.
fileName
)
;
}
return
OS
.
File
.
exists
(
target
)
.
then
(
exists
=
>
{
if
(
exists
)
{
switch
(
options
.
conflictAction
)
{
case
"
uniquify
"
:
default
:
target
=
DownloadPaths
.
createNiceUniqueFile
(
new
FileUtils
.
File
(
target
)
)
.
path
;
break
;
case
"
overwrite
"
:
break
;
}
}
return
target
;
}
)
;
}
let
download
;
return
Downloads
.
getPreferredDownloadsDirectory
(
)
.
then
(
downloadsDir
=
>
createTarget
(
downloadsDir
)
)
.
then
(
target
=
>
Downloads
.
createDownload
(
{
source
:
options
.
url
target
:
target
}
)
)
.
then
(
dl
=
>
{
download
=
dl
;
return
Downloads
.
getList
(
Downloads
.
ALL
)
;
}
)
.
then
(
list
=
>
{
list
.
add
(
download
)
;
download
.
tryToKeepPartialData
=
true
;
download
.
start
(
)
;
return
currentId
+
+
;
}
)
;
}
onCreated
:
ignoreEvent
(
context
"
downloads
.
onCreated
"
)
onErased
:
ignoreEvent
(
context
"
downloads
.
onErased
"
)
onChanged
:
ignoreEvent
(
context
"
downloads
.
onChanged
"
)
onDeterminingFilename
:
ignoreEvent
(
context
"
downloads
.
onDeterminingFilename
"
)
}
}
;
}
)
;
