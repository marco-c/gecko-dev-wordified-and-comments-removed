"
use
strict
"
;
const
global
=
this
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
BaseContext
EventManager
SingletonEventManager
}
=
ExtensionUtils
;
class
StubContext
extends
BaseContext
{
constructor
(
)
{
super
(
)
;
this
.
sandbox
=
new
Cu
.
Sandbox
(
global
)
;
}
get
cloneScope
(
)
{
return
this
.
sandbox
;
}
get
extension
(
)
{
return
{
id
:
"
test
web
.
extension
"
}
;
}
}
add_task
(
function
*
test_post_unload_promises
(
)
{
let
context
=
new
StubContext
(
)
;
let
fail
=
result
=
>
{
ok
(
false
Unexpected
callback
:
{
result
}
)
;
}
;
let
promises
=
[
context
.
wrapPromise
(
Promise
.
resolve
(
)
)
context
.
wrapPromise
(
Promise
.
reject
(
{
message
:
"
"
}
)
)
.
catch
(
(
)
=
>
{
}
)
]
;
yield
Promise
.
all
(
promises
)
;
context
.
wrapPromise
(
Promise
.
resolve
(
"
resolved
"
)
)
.
then
(
fail
)
;
context
.
wrapPromise
(
Promise
.
reject
(
{
message
:
"
rejected
"
}
)
)
.
then
(
fail
fail
)
;
context
.
unload
(
)
;
yield
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
)
;
add_task
(
function
*
test_post_unload_listeners
(
)
{
let
context
=
new
StubContext
(
)
;
let
fireEvent
;
let
onEvent
=
new
EventManager
(
context
"
onEvent
"
fire
=
>
{
fireEvent
=
fire
;
return
(
)
=
>
{
}
;
}
)
;
let
fireSingleton
;
let
onSingleton
=
new
SingletonEventManager
(
context
"
onSingleton
"
callback
=
>
{
fireSingleton
=
(
)
=
>
{
Promise
.
resolve
(
)
.
then
(
callback
)
;
}
;
return
(
)
=
>
{
}
;
}
)
;
let
fail
=
event
=
>
{
ok
(
false
Unexpected
event
:
{
event
}
)
;
}
;
onEvent
.
addListener
(
fail
)
;
onSingleton
.
addListener
(
fail
)
;
let
promises
=
[
new
Promise
(
resolve
=
>
onEvent
.
addListener
(
resolve
)
)
new
Promise
(
resolve
=
>
onSingleton
.
addListener
(
resolve
)
)
]
;
fireEvent
(
"
onEvent
"
)
;
fireSingleton
(
"
onSingleton
"
)
;
onEvent
.
removeListener
(
fail
)
;
onSingleton
.
removeListener
(
fail
)
;
yield
Promise
.
all
(
promises
)
;
onEvent
.
addListener
(
fail
)
;
onSingleton
.
addListener
(
fail
)
;
fireEvent
(
"
onEvent
"
)
;
Promise
.
resolve
(
"
onEvent
"
)
.
then
(
fireEvent
)
;
fireSingleton
(
"
onSingleton
"
)
;
Promise
.
resolve
(
"
onSingleton
"
)
.
then
(
fireSingleton
)
;
context
.
unload
(
)
;
yield
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
)
;
