"
use
strict
"
;
const
global
=
this
;
const
{
ExtensionCommon
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
var
{
BaseContext
EventManager
}
=
ExtensionCommon
;
class
StubContext
extends
BaseContext
{
constructor
(
)
{
let
fakeExtension
=
{
id
:
"
test
web
.
extension
"
}
;
super
(
"
testEnv
"
fakeExtension
)
;
this
.
sandbox
=
Cu
.
Sandbox
(
global
)
;
}
get
cloneScope
(
)
{
return
this
.
sandbox
;
}
get
principal
(
)
{
return
Cu
.
getObjectPrincipal
(
this
.
sandbox
)
;
}
}
add_task
(
async
function
test_post_unload_promises
(
)
{
let
context
=
new
StubContext
(
)
;
let
fail
=
result
=
>
{
ok
(
false
Unexpected
callback
:
{
result
}
)
;
}
;
let
promises
=
[
context
.
wrapPromise
(
Promise
.
resolve
(
)
)
context
.
wrapPromise
(
Promise
.
reject
(
{
message
:
"
"
}
)
)
.
catch
(
(
)
=
>
{
}
)
]
;
await
Promise
.
all
(
promises
)
;
context
.
wrapPromise
(
Promise
.
resolve
(
"
resolved
"
)
)
.
then
(
fail
)
;
context
.
wrapPromise
(
Promise
.
reject
(
{
message
:
"
rejected
"
}
)
)
.
then
(
fail
fail
)
;
context
.
unload
(
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
)
;
add_task
(
async
function
test_post_unload_listeners
(
)
{
let
context
=
new
StubContext
(
)
;
let
fire
;
let
manager
=
new
EventManager
(
{
context
name
:
"
EventManager
"
register
:
_fire
=
>
{
fire
=
(
)
=
>
{
_fire
.
async
(
)
;
}
;
return
(
)
=
>
{
}
;
}
}
)
;
let
fail
=
event
=
>
{
ok
(
false
Unexpected
event
:
{
event
}
)
;
}
;
manager
.
addListener
(
fail
)
;
let
promise
=
new
Promise
(
resolve
=
>
manager
.
addListener
(
resolve
)
)
;
fire
(
)
;
manager
.
removeListener
(
fail
)
;
await
promise
;
manager
.
addListener
(
fail
)
;
fire
(
)
;
Promise
.
resolve
(
)
.
then
(
fire
)
;
context
.
unload
(
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
)
;
class
Context
extends
BaseContext
{
constructor
(
principal
)
{
let
fakeExtension
=
{
id
:
"
test
web
.
extension
"
}
;
super
(
"
testEnv
"
fakeExtension
)
;
Object
.
defineProperty
(
this
"
principal
"
{
value
:
principal
configurable
:
true
}
)
;
this
.
sandbox
=
Cu
.
Sandbox
(
principal
{
wantXrays
:
false
}
)
;
}
get
cloneScope
(
)
{
return
this
.
sandbox
;
}
}
let
ssm
=
Services
.
scriptSecurityManager
;
const
PRINCIPAL1
=
ssm
.
createCodebasePrincipalFromOrigin
(
"
http
:
/
/
www
.
example
.
org
"
)
;
const
PRINCIPAL2
=
ssm
.
createCodebasePrincipalFromOrigin
(
"
http
:
/
/
www
.
somethingelse
.
org
"
)
;
add_task
(
async
function
test_stringify_toJSON
(
)
{
let
context
=
new
Context
(
PRINCIPAL1
)
;
let
obj
=
Cu
.
evalInSandbox
(
"
(
{
hidden
:
true
toJSON
(
)
{
return
{
visible
:
true
}
;
}
}
)
"
context
.
sandbox
)
;
let
stringified
=
context
.
jsonStringify
(
obj
)
;
let
expected
=
JSON
.
stringify
(
{
visible
:
true
}
)
;
equal
(
stringified
expected
"
Stringified
object
with
toJSON
(
)
method
is
as
expected
"
)
;
}
)
;
add_task
(
async
function
test_stringify_inaccessible
(
)
{
let
context
=
new
Context
(
PRINCIPAL1
)
;
let
sandbox
=
context
.
sandbox
;
let
sandbox2
=
Cu
.
Sandbox
(
PRINCIPAL2
)
;
Cu
.
waiveXrays
(
sandbox
)
.
subobj
=
Cu
.
evalInSandbox
(
"
(
{
subobject
:
true
}
)
"
sandbox2
)
;
let
obj
=
Cu
.
evalInSandbox
(
"
(
{
local
:
true
nested
:
subobj
}
)
"
sandbox
)
;
Assert
.
throws
(
(
)
=
>
{
context
.
jsonStringify
(
obj
)
;
}
/
Permission
denied
to
access
property
"
toJSON
"
/
)
;
}
)
;
add_task
(
async
function
test_stringify_accessible
(
)
{
let
principal
=
Cu
.
getObjectPrincipal
(
Cu
.
Sandbox
(
[
PRINCIPAL1
PRINCIPAL2
]
)
)
;
let
context
=
new
Context
(
principal
)
;
let
sandbox
=
context
.
sandbox
;
let
sandbox2
=
Cu
.
Sandbox
(
PRINCIPAL2
)
;
Cu
.
waiveXrays
(
sandbox
)
.
subobj
=
Cu
.
evalInSandbox
(
"
(
{
subobject
:
true
}
)
"
sandbox2
)
;
let
obj
=
Cu
.
evalInSandbox
(
"
(
{
local
:
true
nested
:
subobj
}
)
"
sandbox
)
;
let
stringified
=
context
.
jsonStringify
(
obj
)
;
let
expected
=
JSON
.
stringify
(
{
local
:
true
nested
:
{
subobject
:
true
}
}
)
;
equal
(
stringified
expected
"
Stringified
object
with
accessible
property
is
as
expected
"
)
;
}
)
;
