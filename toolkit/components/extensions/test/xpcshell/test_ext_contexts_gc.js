"
use
strict
"
;
const
server
=
createHttpServer
(
)
;
server
.
registerDirectory
(
"
/
data
/
"
do_get_file
(
"
data
"
)
)
;
const
BASE_URL
=
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
/
data
;
ExtensionTestUtils
.
mockAppInfo
(
)
;
async
function
reloadTopContext
(
contentPage
)
{
await
contentPage
.
spawn
(
null
async
(
)
=
>
{
let
{
TestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
{
}
)
;
let
windowNukeObserved
=
TestUtils
.
topicObserved
(
"
inner
-
window
-
nuked
"
)
;
info
(
Reloading
top
-
level
document
)
;
this
.
content
.
location
.
reload
(
)
;
await
windowNukeObserved
;
info
(
Reloaded
top
-
level
document
)
;
}
)
;
}
async
function
assertContextReleased
(
contentPage
description
)
{
await
contentPage
.
spawn
(
description
async
assertionDescription
=
>
{
let
gcCount
=
0
;
while
(
gcCount
<
30
&
&
this
.
contextWeakRef
.
get
(
)
!
=
=
null
)
{
+
+
gcCount
;
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
Cu
.
forceGC
(
)
;
await
new
Promise
(
resolve
=
>
this
.
content
.
setTimeout
(
resolve
0
)
)
;
}
Assert
.
lessOrEqual
(
gcCount
3
Context
should
have
been
GCd
within
a
few
GC
attempts
.
)
;
Assert
.
ok
(
!
this
.
contextWeakRef
.
get
(
)
assertionDescription
)
;
}
)
;
}
add_task
(
async
function
test_ContentScriptContextChild_in_child_frame
(
)
{
let
extensionData
=
{
manifest
:
{
content_scripts
:
[
{
matches
:
[
"
http
:
/
/
*
/
*
/
file_iframe
.
html
"
]
js
:
[
"
content_script
.
js
"
]
all_frames
:
true
}
]
}
files
:
{
"
content_script
.
js
"
:
"
browser
.
test
.
sendMessage
(
'
contentScriptLoaded
'
)
;
"
}
}
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
extensionData
)
;
await
extension
.
startup
(
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
{
BASE_URL
}
/
file_toplevel
.
html
)
;
await
extension
.
awaitMessage
(
"
contentScriptLoaded
"
)
;
await
contentPage
.
spawn
(
extension
.
id
async
extensionId
=
>
{
let
{
DocumentManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionContent
.
jsm
"
{
}
)
;
let
frame
=
this
.
content
.
document
.
querySelector
(
"
iframe
[
src
*
=
'
file_iframe
.
html
'
]
"
)
;
let
context
=
DocumentManager
.
getContext
(
extensionId
frame
.
contentWindow
)
;
Assert
.
ok
(
context
"
Got
content
script
context
"
)
;
this
.
contextWeakRef
=
Cu
.
getWeakReference
(
context
)
;
frame
.
remove
(
)
;
}
)
;
await
assertContextReleased
(
contentPage
"
ContentScriptContextChild
should
have
been
released
"
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_ContentScriptContextChild_in_toplevel
(
)
{
let
extensionData
=
{
manifest
:
{
content_scripts
:
[
{
matches
:
[
"
http
:
/
/
*
/
*
/
file_sample
.
html
"
]
js
:
[
"
content_script
.
js
"
]
all_frames
:
true
}
]
}
files
:
{
"
content_script
.
js
"
:
"
browser
.
test
.
sendMessage
(
'
contentScriptLoaded
'
)
;
"
}
}
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
extensionData
)
;
await
extension
.
startup
(
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
{
BASE_URL
}
/
file_sample
.
html
)
;
await
extension
.
awaitMessage
(
"
contentScriptLoaded
"
)
;
await
contentPage
.
spawn
(
extension
.
id
async
extensionId
=
>
{
let
{
DocumentManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionContent
.
jsm
"
{
}
)
;
let
context
=
DocumentManager
.
getContext
(
extensionId
this
.
content
)
;
Assert
.
ok
(
context
"
Got
content
script
context
"
)
;
this
.
contextWeakRef
=
Cu
.
getWeakReference
(
context
)
;
}
)
;
await
reloadTopContext
(
contentPage
)
;
await
extension
.
awaitMessage
(
"
contentScriptLoaded
"
)
;
await
assertContextReleased
(
contentPage
"
ContentScriptContextChild
should
have
been
released
"
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_ExtensionPageContextChild_in_child_frame
(
)
{
let
extensionData
=
{
files
:
{
"
iframe
.
html
"
:
<
!
DOCTYPE
html
>
<
meta
charset
=
"
utf8
"
>
<
script
src
=
"
script
.
js
"
>
<
/
script
>
"
toplevel
.
html
"
:
<
!
DOCTYPE
html
>
<
meta
charset
=
"
utf8
"
>
<
iframe
src
=
"
iframe
.
html
"
>
<
/
iframe
>
"
script
.
js
"
:
"
browser
.
test
.
sendMessage
(
'
extensionPageLoaded
'
)
;
"
}
}
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
extensionData
)
;
await
extension
.
startup
(
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
moz
-
extension
:
/
/
{
extension
.
uuid
}
/
toplevel
.
html
{
extension
remote
:
extension
.
extension
.
remote
}
)
;
await
extension
.
awaitMessage
(
"
extensionPageLoaded
"
)
;
await
contentPage
.
spawn
(
extension
.
id
async
extensionId
=
>
{
let
{
ExtensionPageChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionPageChild
.
jsm
"
{
}
)
;
let
frame
=
this
.
content
.
document
.
querySelector
(
"
iframe
[
src
*
=
'
iframe
.
html
'
]
"
)
;
let
innerWindowID
=
frame
.
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
let
context
=
ExtensionPageChild
.
extensionContexts
.
get
(
innerWindowID
)
;
Assert
.
ok
(
context
"
Got
extension
page
context
for
child
frame
"
)
;
this
.
contextWeakRef
=
Cu
.
getWeakReference
(
context
)
;
frame
.
remove
(
)
;
}
)
;
await
assertContextReleased
(
contentPage
"
ExtensionPageContextChild
should
have
been
released
"
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_ExtensionPageContextChild_in_toplevel
(
)
{
let
extensionData
=
{
files
:
{
"
toplevel
.
html
"
:
<
!
DOCTYPE
html
>
<
meta
charset
=
"
utf8
"
>
<
iframe
src
=
"
iframe
.
html
"
>
<
/
iframe
>
<
script
src
=
"
script
.
js
"
>
<
/
script
>
"
script
.
js
"
:
"
browser
.
test
.
sendMessage
(
'
extensionPageLoaded
'
)
;
"
}
}
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
extensionData
)
;
await
extension
.
startup
(
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
moz
-
extension
:
/
/
{
extension
.
uuid
}
/
toplevel
.
html
{
extension
remote
:
extension
.
extension
.
remote
}
)
;
await
extension
.
awaitMessage
(
"
extensionPageLoaded
"
)
;
await
contentPage
.
spawn
(
extension
.
id
async
extensionId
=
>
{
let
{
ExtensionPageChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionPageChild
.
jsm
"
{
}
)
;
let
innerWindowID
=
this
.
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
let
context
=
ExtensionPageChild
.
extensionContexts
.
get
(
innerWindowID
)
;
Assert
.
ok
(
context
"
Got
extension
page
context
for
top
-
level
document
"
)
;
this
.
contextWeakRef
=
Cu
.
getWeakReference
(
context
)
;
}
)
;
await
reloadTopContext
(
contentPage
)
;
await
extension
.
awaitMessage
(
"
extensionPageLoaded
"
)
;
await
contentPage
.
spawn
(
null
async
(
)
=
>
{
let
start
=
Date
.
now
(
)
;
for
(
let
i
=
0
;
i
<
15
;
+
+
i
)
{
await
new
Promise
(
resolve
=
>
this
.
content
.
setTimeout
(
resolve
0
)
)
;
}
info
(
Going
to
GC
after
waiting
for
{
Date
.
now
(
)
-
start
}
ms
.
)
;
}
)
;
await
assertContextReleased
(
contentPage
"
ExtensionPageContextChild
should
have
been
released
"
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
