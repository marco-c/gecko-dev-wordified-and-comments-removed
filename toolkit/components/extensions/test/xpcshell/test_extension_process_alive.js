"
use
strict
"
;
class
ProcessWatcher
{
constructor
(
)
{
this
.
seenChildIDs
=
new
Map
(
)
;
this
.
onShutdownCallbacks
=
new
Set
(
)
;
Services
.
obs
.
addObserver
(
this
"
ipc
:
content
-
shutdown
"
)
;
this
.
deadDeadline
=
5000
;
}
unregister
(
)
{
Services
.
obs
.
removeObserver
(
this
"
ipc
:
content
-
shutdown
"
)
;
}
observe
(
subject
topic
data
)
{
const
childID
=
parseInt
(
data
10
)
;
const
abnormal
=
subject
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
.
get
(
"
abnormal
"
)
;
info
(
Observed
content
shutdown
childID
=
{
childID
}
abnormal
=
{
abnormal
}
)
;
this
.
seenChildIDs
.
set
(
childID
!
!
abnormal
)
;
for
(
let
onShutdownCallback
of
this
.
onShutdownCallbacks
)
{
onShutdownCallback
(
childID
)
;
}
}
isProcessAlive
(
childID
)
{
return
!
this
.
seenChildIDs
.
has
(
childID
)
;
}
async
waitForTermination
(
childID
expectAbnormal
=
false
)
{
Assert
.
ok
(
childID
waitForTermination
:
{
childID
}
)
;
if
(
!
this
.
isProcessAlive
(
childID
)
)
{
info
(
Process
has
already
shut
down
:
{
childID
}
)
;
}
else
{
info
(
Waiting
for
process
to
shut
down
:
{
childID
}
)
;
await
new
Promise
(
resolve
=
>
{
const
onShutdownCallback
=
_childID
=
>
{
if
(
_childID
=
=
=
childID
)
{
info
(
Process
has
shut
down
:
{
childID
}
)
;
this
.
onShutdownCallbacks
.
delete
(
onShutdownCallback
)
;
resolve
(
)
;
}
}
;
this
.
onShutdownCallbacks
.
add
(
onShutdownCallback
)
;
}
)
;
}
const
abnormal
=
this
.
seenChildIDs
.
get
(
childID
)
;
if
(
expectAbnormal
)
{
Assert
.
ok
(
abnormal
"
Process
should
have
ended
abnormally
.
"
)
;
}
else
if
(
AppConstants
.
platform
=
=
=
"
android
"
&
&
abnormal
)
{
Assert
.
ok
(
true
"
Process
should
have
ended
normally
but
did
not
.
"
)
;
}
else
{
Assert
.
ok
(
!
abnormal
"
Process
should
have
ended
normally
.
"
)
;
}
}
setExtProcessTerminationDeadline
(
deadline
)
{
const
MIN_DEADLINE
=
1000
;
const
MAX_DEADLINE
=
20000
;
if
(
deadline
<
MIN_DEADLINE
)
{
this
.
deadDeadline
=
MIN_DEADLINE
;
}
else
if
(
deadline
>
MAX_DEADLINE
)
{
this
.
deadDeadline
=
MAX_DEADLINE
;
}
else
{
this
.
deadDeadline
=
deadline
;
}
}
async
waitAndCheckIsProcessAlive
(
childID
)
{
Assert
.
ok
(
this
.
isProcessAlive
(
childID
)
Process
{
childID
}
is
alive
)
;
info
(
Waiting
for
{
this
.
deadDeadline
}
ms
and
process
{
childID
}
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
this
.
deadDeadline
)
)
;
Assert
.
ok
(
this
.
isProcessAlive
(
childID
)
Process
{
childID
}
still
alive
)
;
}
}
const
processWatcher
=
new
ProcessWatcher
(
)
;
registerCleanupFunction
(
(
)
=
>
processWatcher
.
unregister
(
)
)
;
function
pidOfContentPage
(
contentPage
)
{
return
contentPage
.
browsingContext
.
currentWindowGlobal
.
domProcess
.
childID
;
}
function
pidOfBackgroundPage
(
extension
)
{
return
extension
.
extension
.
backgroundContext
.
xulBrowser
.
browsingContext
.
currentWindowGlobal
.
domProcess
.
childID
;
}
async
function
loadExtensionAndGetPid
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
(
)
{
browser
.
test
.
sendMessage
(
"
bg_loaded
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
bg_loaded
"
)
;
let
pid
=
pidOfBackgroundPage
(
extension
)
;
await
extension
.
unload
(
)
;
return
pid
;
}
add_setup
(
async
function
setup_start_and_quit_addon_manager
(
)
{
ExtensionTestUtils
.
mockAppInfo
(
)
;
AddonTestUtils
.
init
(
globalThis
)
;
await
AddonTestUtils
.
promiseStartupManager
(
)
;
info
(
"
Starting
an
extension
to
load
the
extension
process
"
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
(
)
{
window
.
onload
=
(
)
=
>
browser
.
test
.
sendMessage
(
"
first_run
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
first_run
"
)
;
info
(
"
Fully
loaded
initial
extension
and
its
process
shutting
down
now
"
)
;
await
extension
.
unload
(
)
;
await
AddonTestUtils
.
promiseShutdownManager
(
)
;
}
)
;
add_task
(
{
pref_set
:
[
[
"
dom
.
ipc
.
keepProcessesAlive
.
extension
"
0
]
]
}
async
function
shutdown_extension_process_on_extension_background_unload
(
)
{
info
(
"
Starting
and
unloading
first
extension
"
)
;
let
pid1
=
await
loadExtensionAndGetPid
(
)
;
info
(
"
Extension
process
should
end
after
unloading
the
only
extension
doc
"
)
;
await
processWatcher
.
waitForTermination
(
pid1
)
;
}
)
;
add_task
(
{
pref_set
:
[
[
"
dom
.
ipc
.
keepProcessesAlive
.
extension
"
1
]
]
}
async
function
extension_process_reused_between_background_page_restarts
(
)
{
info
(
"
Starting
and
unloading
first
extension
"
)
;
let
pid1
=
await
loadExtensionAndGetPid
(
)
;
info
(
"
Process
should
be
alive
after
unloading
the
only
extension
(
1
)
"
)
;
await
processWatcher
.
waitAndCheckIsProcessAlive
(
pid1
)
;
info
(
"
Starting
and
unloading
second
extension
"
)
;
let
pid2
=
await
loadExtensionAndGetPid
(
)
;
Assert
.
equal
(
pid1
pid2
"
Extension
process
was
reused
"
)
;
info
(
"
Process
should
be
alive
after
unloading
the
only
extension
(
2
)
"
)
;
await
processWatcher
.
waitAndCheckIsProcessAlive
(
pid1
)
;
for
(
let
i
=
1
;
i
<
=
9
;
+
+
i
)
{
let
pid3
=
await
loadExtensionAndGetPid
(
)
;
Assert
.
equal
(
pid1
pid3
Extension
process
was
reused
at
attempt
{
i
}
)
;
}
info
(
"
Process
should
be
alive
after
unloading
the
only
extension
(
3
)
"
)
;
await
processWatcher
.
waitAndCheckIsProcessAlive
(
pid1
)
;
}
)
;
add_task
(
{
pref_set
:
[
[
"
dom
.
ipc
.
keepProcessesAlive
.
extension
"
0
]
]
}
async
function
shutdown_extension_process_on_last_extension_page_unload
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
files
:
{
"
page
.
html
"
:
<
!
DOCTYPE
html
>
<
script
src
=
"
page
.
js
"
>
<
/
script
>
"
page
.
js
"
:
(
)
=
>
browser
.
test
.
sendMessage
(
"
page_loaded
"
)
}
}
)
;
await
extension
.
startup
(
)
;
const
EXT_PAGE
=
moz
-
extension
:
/
/
{
extension
.
uuid
}
/
page
.
html
;
async
function
openOnlyExtensionPageAndGetPid
(
)
{
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
EXT_PAGE
)
;
await
extension
.
awaitMessage
(
"
page_loaded
"
)
;
let
pid
=
pidOfContentPage
(
contentPage
)
;
await
contentPage
.
close
(
)
;
return
pid
;
}
const
timeStart
=
Date
.
now
(
)
;
info
(
"
Opening
first
page
"
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
EXT_PAGE
)
;
await
extension
.
awaitMessage
(
"
page_loaded
"
)
;
let
pid1
=
pidOfContentPage
(
contentPage
)
;
info
(
"
Opening
and
closing
second
page
while
the
first
is
open
"
)
;
let
pid2
=
await
openOnlyExtensionPageAndGetPid
(
)
;
Assert
.
equal
(
pid1
pid2
"
Second
page
should
re
-
use
first
page
'
s
process
"
)
;
Assert
.
ok
(
processWatcher
.
isProcessAlive
(
pid1
)
"
Process
not
dead
"
)
;
await
contentPage
.
close
(
)
;
info
(
"
Closed
last
page
-
extension
process
should
terminate
"
)
;
await
processWatcher
.
waitForTermination
(
pid1
)
;
let
pid3
=
await
openOnlyExtensionPageAndGetPid
(
)
;
Assert
.
notEqual
(
pid2
pid3
"
Should
get
a
new
extension
process
"
)
;
await
extension
.
unload
(
)
;
await
processWatcher
.
waitForTermination
(
pid3
)
;
processWatcher
.
setExtProcessTerminationDeadline
(
Date
.
now
(
)
-
timeStart
)
;
}
)
;
add_task
(
{
pref_set
:
[
[
"
dom
.
ipc
.
keepProcessesAlive
.
extension
"
1
]
]
}
async
function
keep_extension_process_on_last_extension_page_unload
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
files
:
{
"
page
.
html
"
:
<
!
DOCTYPE
html
>
<
script
src
=
"
page
.
js
"
>
<
/
script
>
"
page
.
js
"
:
(
)
=
>
browser
.
test
.
sendMessage
(
"
page_loaded
"
)
}
}
)
;
await
extension
.
startup
(
)
;
const
EXT_PAGE
=
moz
-
extension
:
/
/
{
extension
.
uuid
}
/
page
.
html
;
async
function
openOnlyExtensionPageAndGetPid
(
)
{
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
EXT_PAGE
)
;
await
extension
.
awaitMessage
(
"
page_loaded
"
)
;
let
pid
=
pidOfContentPage
(
contentPage
)
;
await
contentPage
.
close
(
)
;
return
pid
;
}
info
(
"
Opening
and
closing
first
page
"
)
;
let
pid1
=
await
openOnlyExtensionPageAndGetPid
(
)
;
info
(
"
No
extension
pages
but
extension
process
should
still
be
alive
(
1
)
"
)
;
await
processWatcher
.
waitAndCheckIsProcessAlive
(
pid1
)
;
let
pid2
=
await
openOnlyExtensionPageAndGetPid
(
)
;
Assert
.
equal
(
pid1
pid2
"
Extension
process
is
reused
by
second
page
"
)
;
info
(
"
No
extension
pages
but
extension
process
should
still
be
alive
(
2
)
"
)
;
await
processWatcher
.
waitAndCheckIsProcessAlive
(
pid1
)
;
await
extension
.
unload
(
)
;
info
(
"
No
extensions
around
but
extension
process
should
still
be
alive
"
)
;
await
processWatcher
.
waitAndCheckIsProcessAlive
(
pid1
)
;
}
)
;
