"
use
strict
"
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
42
"
)
;
const
{
ExtensionStorage
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionStorage
.
jsm
"
)
;
const
{
TelemetryController
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
)
;
const
{
TelemetryTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
)
;
const
{
ExtensionStorageIDB
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionStorageIDB
.
jsm
"
)
;
const
{
getTrimmedString
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionTelemetry
.
jsm
"
null
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
}
)
;
const
{
promiseShutdownManager
promiseStartupManager
}
=
AddonTestUtils
;
const
{
IDB_MIGRATED_PREF_BRANCH
IDB_MIGRATE_RESULT_HISTOGRAM
}
=
ExtensionStorageIDB
;
const
CATEGORIES
=
[
"
success
"
"
failure
"
]
;
const
EVENT_CATEGORY
=
"
extensions
.
data
"
;
const
EVENT_OBJECT
=
"
storageLocal
"
;
const
EVENT_METHODS
=
[
"
migrateResult
"
]
;
const
LEAVE_STORAGE_PREF
=
"
extensions
.
webextensions
.
keepStorageOnUninstall
"
;
const
LEAVE_UUID_PREF
=
"
extensions
.
webextensions
.
keepUuidOnUninstall
"
;
const
TELEMETRY_EVENTS_FILTER
=
{
category
:
"
extensions
.
data
"
method
:
"
migrateResult
"
object
:
"
storageLocal
"
}
;
async
function
createExtensionJSONFileWithData
(
extensionId
data
)
{
await
ExtensionStorage
.
set
(
extensionId
data
)
;
const
jsonFile
=
await
ExtensionStorage
.
getFile
(
extensionId
)
;
await
jsonFile
.
_save
(
)
;
const
oldStorageFilename
=
ExtensionStorage
.
getStorageFile
(
extensionId
)
;
equal
(
await
OS
.
File
.
exists
(
oldStorageFilename
)
true
"
The
old
json
file
has
been
created
"
)
;
return
{
jsonFile
oldStorageFilename
}
;
}
function
clearMigrationHistogram
(
)
{
const
histogram
=
Services
.
telemetry
.
getHistogramById
(
IDB_MIGRATE_RESULT_HISTOGRAM
)
;
histogram
.
clear
(
)
;
equal
(
histogram
.
snapshot
(
)
.
sum
0
No
data
recorded
for
histogram
{
IDB_MIGRATE_RESULT_HISTOGRAM
}
)
;
}
function
assertMigrationHistogramCount
(
category
expectedCount
)
{
const
histogram
=
Services
.
telemetry
.
getHistogramById
(
IDB_MIGRATE_RESULT_HISTOGRAM
)
;
equal
(
histogram
.
snapshot
(
)
.
values
[
CATEGORIES
.
indexOf
(
category
)
]
expectedCount
Got
the
expected
count
on
category
"
{
category
}
"
for
histogram
{
IDB_MIGRATE_RESULT_HISTOGRAM
}
)
;
}
function
assertTelemetryEvents
(
extensionId
expectedEvents
)
{
const
snapshot
=
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
true
)
;
ok
(
snapshot
.
parent
&
&
snapshot
.
parent
.
length
>
0
"
Got
parent
telemetry
events
in
the
snapshot
"
)
;
const
migrateEvents
=
snapshot
.
parent
.
filter
(
(
[
timestamp
category
method
object
value
]
)
=
>
{
return
(
category
=
=
=
EVENT_CATEGORY
&
&
EVENT_METHODS
.
includes
(
method
)
&
&
object
=
=
=
EVENT_OBJECT
&
&
value
=
=
=
extensionId
)
;
}
)
.
map
(
event
=
>
{
return
{
method
:
event
[
2
]
extra
:
event
[
5
]
}
;
}
)
;
Assert
.
deepEqual
(
migrateEvents
expectedEvents
"
Got
the
expected
telemetry
events
"
)
;
}
add_task
(
async
function
setup
(
)
{
Services
.
prefs
.
setBoolPref
(
ExtensionStorageIDB
.
BACKEND_ENABLED_PREF
true
)
;
await
promiseStartupManager
(
)
;
await
TelemetryController
.
testSetup
(
)
;
const
oldCanRecordBase
=
Services
.
telemetry
.
canRecordBase
;
Services
.
telemetry
.
canRecordBase
=
true
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
telemetry
.
canRecordBase
=
oldCanRecordBase
;
}
)
;
}
)
;
add_task
(
async
function
test_no_migration_for_newly_installed_extensions
(
)
{
const
EXTENSION_ID
=
"
test
-
no
-
data
-
migration
mochi
.
test
"
;
await
createExtensionJSONFileWithData
(
EXTENSION_ID
{
test_old_data
:
"
test_old_value
"
}
)
;
const
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
temporary
"
manifest
:
{
permissions
:
[
"
storage
"
]
applications
:
{
gecko
:
{
id
:
EXTENSION_ID
}
}
}
async
background
(
)
{
const
data
=
await
browser
.
storage
.
local
.
get
(
)
;
browser
.
test
.
assertEq
(
Object
.
keys
(
data
)
.
length
0
"
Expect
the
storage
.
local
store
to
be
empty
"
)
;
browser
.
test
.
sendMessage
(
"
test
-
stored
-
data
:
done
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
equal
(
ExtensionStorageIDB
.
isMigratedExtension
(
extension
)
true
"
The
newly
installed
test
extension
is
marked
as
migrated
"
)
;
await
extension
.
awaitMessage
(
"
test
-
stored
-
data
:
done
"
)
;
await
extension
.
unload
(
)
;
await
TelemetryTestUtils
.
assertEvents
(
[
]
TELEMETRY_EVENTS_FILTER
)
;
}
)
;
add_task
(
async
function
test_data_migration_on_keep_storage_on_uninstall
(
)
{
Services
.
prefs
.
setBoolPref
(
LEAVE_STORAGE_PREF
true
)
;
const
EXTENSION_ID
=
"
new
-
extension
-
on
-
keep
-
storage
-
on
-
uninstall
mochi
.
test
"
;
await
createExtensionJSONFileWithData
(
EXTENSION_ID
{
test_key_string
:
"
test_value
"
}
)
;
const
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
temporary
"
manifest
:
{
permissions
:
[
"
storage
"
]
applications
:
{
gecko
:
{
id
:
EXTENSION_ID
}
}
}
async
background
(
)
{
const
storedData
=
await
browser
.
storage
.
local
.
get
(
)
;
browser
.
test
.
assertEq
(
"
test_value
"
storedData
.
test_key_string
"
Got
the
expected
data
after
the
storage
.
local
data
migration
"
)
;
browser
.
test
.
sendMessage
(
"
storage
-
local
-
data
-
migrated
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
storage
-
local
-
data
-
migrated
"
)
;
equal
(
ExtensionStorageIDB
.
isMigratedExtension
(
extension
)
true
"
The
newly
installed
test
extension
is
marked
as
migrated
"
)
;
await
extension
.
unload
(
)
;
await
TelemetryTestUtils
.
assertEvents
(
[
{
method
:
"
migrateResult
"
value
:
EXTENSION_ID
extra
:
{
backend
:
"
IndexedDB
"
data_migrated
:
"
y
"
has_jsonfile
:
"
y
"
has_olddata
:
"
y
"
}
}
]
TELEMETRY_EVENTS_FILTER
)
;
Services
.
prefs
.
clearUserPref
(
LEAVE_STORAGE_PREF
)
;
}
)
;
add_task
(
async
function
test_storage_local_data_migration
(
)
{
const
EXTENSION_ID
=
"
extension
-
to
-
be
-
migrated
mozilla
.
org
"
;
Services
.
prefs
.
setBoolPref
(
LEAVE_STORAGE_PREF
true
)
;
Services
.
prefs
.
setBoolPref
(
LEAVE_UUID_PREF
true
)
;
const
data
=
{
test_key_string
:
"
test_value1
"
test_key_number
:
1000
test_nested_data
:
{
nested_key
:
true
}
}
;
const
{
oldStorageFilename
}
=
await
createExtensionJSONFileWithData
(
EXTENSION_ID
data
)
;
async
function
background
(
)
{
const
storedData
=
await
browser
.
storage
.
local
.
get
(
)
;
browser
.
test
.
assertEq
(
"
test_value1
"
storedData
.
test_key_string
"
Got
the
expected
data
after
the
storage
.
local
data
migration
"
)
;
browser
.
test
.
assertEq
(
1000
storedData
.
test_key_number
"
Got
the
expected
data
after
the
storage
.
local
data
migration
"
)
;
browser
.
test
.
assertEq
(
true
storedData
.
test_nested_data
.
nested_key
"
Got
the
expected
data
after
the
storage
.
local
data
migration
"
)
;
browser
.
test
.
sendMessage
(
"
storage
-
local
-
data
-
migrated
"
)
;
}
clearMigrationHistogram
(
)
;
let
extensionDefinition
=
{
useAddonManager
:
"
temporary
"
manifest
:
{
permissions
:
[
"
storage
"
]
applications
:
{
gecko
:
{
id
:
EXTENSION_ID
}
}
}
}
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
extensionDefinition
)
;
Services
.
prefs
.
setBoolPref
(
ExtensionStorageIDB
.
BACKEND_ENABLED_PREF
false
)
;
await
extension
.
startup
(
)
;
ok
(
!
ExtensionStorageIDB
.
isMigratedExtension
(
extension
)
"
The
test
extension
should
be
using
the
JSONFile
backend
"
)
;
Services
.
prefs
.
setBoolPref
(
ExtensionStorageIDB
.
BACKEND_ENABLED_PREF
true
)
;
await
extension
.
upgrade
(
{
.
.
.
extensionDefinition
background
}
)
;
await
extension
.
awaitMessage
(
"
storage
-
local
-
data
-
migrated
"
)
;
ok
(
ExtensionStorageIDB
.
isMigratedExtension
(
extension
)
"
The
test
extension
should
be
using
the
IndexedDB
backend
"
)
;
const
storagePrincipal
=
ExtensionStorageIDB
.
getStoragePrincipal
(
extension
.
extension
)
;
const
idbConn
=
await
ExtensionStorageIDB
.
open
(
storagePrincipal
)
;
equal
(
await
idbConn
.
isEmpty
(
extension
.
extension
)
false
"
Data
stored
in
the
ExtensionStorageIDB
backend
as
expected
"
)
;
equal
(
await
OS
.
File
.
exists
(
oldStorageFilename
)
false
"
The
old
json
storage
file
name
should
not
exist
anymore
"
)
;
equal
(
await
OS
.
File
.
exists
(
{
oldStorageFilename
}
.
migrated
)
true
"
The
old
json
storage
file
name
should
have
been
renamed
as
.
migrated
"
)
;
equal
(
Services
.
prefs
.
getBoolPref
(
{
IDB_MIGRATED_PREF_BRANCH
}
.
{
EXTENSION_ID
}
false
)
true
Got
the
{
IDB_MIGRATED_PREF_BRANCH
}
preference
set
to
true
as
expected
)
;
assertMigrationHistogramCount
(
"
success
"
1
)
;
assertMigrationHistogramCount
(
"
failure
"
0
)
;
assertTelemetryEvents
(
EXTENSION_ID
[
{
method
:
"
migrateResult
"
extra
:
{
backend
:
"
IndexedDB
"
data_migrated
:
"
y
"
has_jsonfile
:
"
y
"
has_olddata
:
"
y
"
}
}
]
)
;
equal
(
Services
.
prefs
.
getBoolPref
(
{
IDB_MIGRATED_PREF_BRANCH
}
.
{
EXTENSION_ID
}
false
)
true
{
IDB_MIGRATED_PREF_BRANCH
}
should
still
be
true
on
keepStorageOnUninstall
=
true
)
;
await
extension
.
upgrade
(
{
.
.
.
extensionDefinition
background
}
)
;
await
extension
.
awaitMessage
(
"
storage
-
local
-
data
-
migrated
"
)
;
assertMigrationHistogramCount
(
"
success
"
1
)
;
assertMigrationHistogramCount
(
"
failure
"
0
)
;
const
snapshot
=
Services
.
telemetry
.
snapshotEvents
(
Ci
.
nsITelemetry
.
DATASET_PRERELEASE_CHANNELS
true
)
;
const
filterByCategory
=
(
[
timestamp
category
]
)
=
>
category
=
=
=
EVENT_CATEGORY
;
ok
(
!
snapshot
.
parent
|
|
snapshot
.
parent
.
filter
(
filterByCategory
)
.
length
=
=
=
0
"
No
telemetry
events
should
be
recorded
for
an
already
migrated
extension
"
)
;
Services
.
prefs
.
setBoolPref
(
LEAVE_STORAGE_PREF
false
)
;
Services
.
prefs
.
setBoolPref
(
LEAVE_UUID_PREF
false
)
;
await
extension
.
unload
(
)
;
equal
(
Services
.
prefs
.
getPrefType
(
{
IDB_MIGRATED_PREF_BRANCH
}
.
{
EXTENSION_ID
}
)
Services
.
prefs
.
PREF_INVALID
Got
the
{
IDB_MIGRATED_PREF_BRANCH
}
preference
has
been
cleared
on
addon
uninstall
)
;
}
)
;
add_task
(
async
function
test_extensionId_trimmed_in_telemetry_event
(
)
{
const
EXTENSION_ID
=
long
.
extension
.
id
{
Array
(
80
)
.
fill
(
"
a
"
)
.
join
(
"
"
)
}
;
const
data
=
{
test_key_string
:
"
test_value
"
}
;
await
createExtensionJSONFileWithData
(
EXTENSION_ID
data
)
;
async
function
background
(
)
{
const
storedData
=
await
browser
.
storage
.
local
.
get
(
"
test_key_string
"
)
;
browser
.
test
.
assertEq
(
"
test_value
"
storedData
.
test_key_string
"
Got
the
expected
data
after
the
storage
.
local
data
migration
"
)
;
browser
.
test
.
sendMessage
(
"
storage
-
local
-
data
-
migrated
"
)
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
permissions
:
[
"
storage
"
]
applications
:
{
gecko
:
{
id
:
EXTENSION_ID
}
}
}
background
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
storage
-
local
-
data
-
migrated
"
)
;
const
expectedTrimmedExtensionId
=
getTrimmedString
(
EXTENSION_ID
)
;
equal
(
expectedTrimmedExtensionId
.
length
80
"
The
trimmed
version
of
the
extensionId
should
be
80
chars
long
"
)
;
assertTelemetryEvents
(
expectedTrimmedExtensionId
[
{
method
:
"
migrateResult
"
extra
:
{
backend
:
"
IndexedDB
"
data_migrated
:
"
y
"
has_jsonfile
:
"
y
"
has_olddata
:
"
y
"
}
}
]
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_storage_local_corrupted_data_migration
(
)
{
const
EXTENSION_ID
=
"
extension
-
corrupted
-
data
-
migration
mozilla
.
org
"
;
const
invalidData
=
{
"
test_key_string
"
:
"
test_value1
"
;
const
oldStorageFilename
=
ExtensionStorage
.
getStorageFile
(
EXTENSION_ID
)
;
const
profileDir
=
OS
.
Constants
.
Path
.
profileDir
;
await
OS
.
File
.
makeDir
(
OS
.
Path
.
join
(
profileDir
"
browser
-
extension
-
data
"
EXTENSION_ID
)
{
from
:
profileDir
ignoreExisting
:
true
}
)
;
await
OS
.
File
.
writeAtomic
(
oldStorageFilename
invalidData
{
flush
:
true
}
)
;
equal
(
await
OS
.
File
.
read
(
oldStorageFilename
{
encoding
:
"
utf
-
8
"
}
)
invalidData
"
The
old
json
file
has
been
overwritten
with
invalid
data
"
)
;
async
function
background
(
)
{
const
storedData
=
await
browser
.
storage
.
local
.
get
(
)
;
browser
.
test
.
assertEq
(
Object
.
keys
(
storedData
)
.
length
0
"
No
data
should
be
found
on
invalid
data
migration
"
)
;
await
browser
.
storage
.
local
.
set
(
{
test_key_string_on_IDBBackend
:
"
expected
-
value
"
}
)
;
browser
.
test
.
sendMessage
(
"
storage
-
local
-
data
-
migrated
-
and
-
set
"
)
;
}
clearMigrationHistogram
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
permissions
:
[
"
storage
"
]
applications
:
{
gecko
:
{
id
:
EXTENSION_ID
}
}
}
background
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
storage
-
local
-
data
-
migrated
-
and
-
set
"
)
;
const
storagePrincipal
=
ExtensionStorageIDB
.
getStoragePrincipal
(
extension
.
extension
)
;
const
idbConn
=
await
ExtensionStorageIDB
.
open
(
storagePrincipal
)
;
equal
(
await
idbConn
.
isEmpty
(
extension
.
extension
)
false
"
Data
stored
in
the
ExtensionStorageIDB
backend
as
expected
"
)
;
equal
(
await
OS
.
File
.
exists
(
{
oldStorageFilename
}
.
corrupt
)
true
"
The
old
json
storage
should
still
be
available
if
failed
to
be
read
"
)
;
equal
(
Services
.
prefs
.
getBoolPref
(
{
IDB_MIGRATED_PREF_BRANCH
}
.
{
EXTENSION_ID
}
false
)
true
Got
the
{
IDB_MIGRATED_PREF_BRANCH
}
preference
set
to
true
as
expected
)
;
assertMigrationHistogramCount
(
"
success
"
1
)
;
assertMigrationHistogramCount
(
"
failure
"
0
)
;
assertTelemetryEvents
(
EXTENSION_ID
[
{
method
:
"
migrateResult
"
extra
:
{
backend
:
"
IndexedDB
"
data_migrated
:
"
y
"
has_jsonfile
:
"
y
"
has_olddata
:
"
n
"
}
}
]
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_storage_local_data_migration_failure
(
)
{
const
EXTENSION_ID
=
"
extension
-
data
-
migration
-
failure
mozilla
.
org
"
;
const
{
jsonFile
oldStorageFilename
}
=
await
createExtensionJSONFileWithData
(
EXTENSION_ID
{
}
)
;
jsonFile
.
data
.
set
(
"
fake_invalid_key
"
new
Error
(
)
)
;
async
function
background
(
)
{
await
browser
.
storage
.
local
.
set
(
{
test_key_string_on_JSONFileBackend
:
"
expected
-
value
"
}
)
;
browser
.
test
.
sendMessage
(
"
storage
-
local
-
data
-
migrated
-
and
-
set
"
)
;
}
clearMigrationHistogram
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
permissions
:
[
"
storage
"
]
applications
:
{
gecko
:
{
id
:
EXTENSION_ID
}
}
}
background
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
storage
-
local
-
data
-
migrated
-
and
-
set
"
)
;
const
storagePrincipal
=
ExtensionStorageIDB
.
getStoragePrincipal
(
extension
.
extension
)
;
const
idbConn
=
await
ExtensionStorageIDB
.
open
(
storagePrincipal
)
;
equal
(
await
idbConn
.
isEmpty
(
extension
.
extension
)
true
"
No
data
stored
in
the
ExtensionStorageIDB
backend
as
expected
"
)
;
equal
(
await
OS
.
File
.
exists
(
oldStorageFilename
)
true
"
The
old
json
storage
should
still
be
available
if
failed
to
be
read
"
)
;
await
extension
.
unload
(
)
;
assertTelemetryEvents
(
EXTENSION_ID
[
{
method
:
"
migrateResult
"
extra
:
{
backend
:
"
JSONFile
"
data_migrated
:
"
n
"
error_name
:
"
DataCloneError
"
has_jsonfile
:
"
y
"
has_olddata
:
"
y
"
}
}
]
)
;
assertMigrationHistogramCount
(
"
success
"
0
)
;
assertMigrationHistogramCount
(
"
failure
"
1
)
;
}
)
;
add_task
(
async
function
test_migration_aborted_on_shutdown
(
)
{
const
EXTENSION_ID
=
"
test
-
migration
-
aborted
-
on
-
shutdown
mochi
.
test
"
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
permissions
:
[
"
storage
"
]
applications
:
{
gecko
:
{
id
:
EXTENSION_ID
}
}
}
}
)
;
await
extension
.
startup
(
)
;
equal
(
extension
.
extension
.
hasShutdown
false
"
The
extension
is
still
running
"
)
;
await
extension
.
unload
(
)
;
equal
(
extension
.
extension
.
hasShutdown
true
"
The
extension
has
shutdown
"
)
;
const
result
=
await
ExtensionStorageIDB
.
selectBackend
(
{
extension
:
extension
.
extension
}
)
;
Assert
.
deepEqual
(
result
{
backendEnabled
:
false
}
"
Expect
migration
to
have
been
aborted
"
)
;
TelemetryTestUtils
.
assertEvents
(
[
{
value
:
EXTENSION_ID
extra
:
{
backend
:
"
JSONFile
"
error_name
:
"
DataMigrationAbortedError
"
}
}
]
TELEMETRY_EVENTS_FILTER
)
;
}
)
;
add_task
(
async
function
test_storage_local_data_migration_clear_pref
(
)
{
Services
.
prefs
.
clearUserPref
(
LEAVE_STORAGE_PREF
)
;
Services
.
prefs
.
clearUserPref
(
LEAVE_UUID_PREF
)
;
Services
.
prefs
.
clearUserPref
(
ExtensionStorageIDB
.
BACKEND_ENABLED_PREF
)
;
await
promiseShutdownManager
(
)
;
await
TelemetryController
.
testShutdown
(
)
;
}
)
;
add_task
(
async
function
setup_quota_manager_testing_prefs
(
)
{
Services
.
prefs
.
setBoolPref
(
"
dom
.
quotaManager
.
testing
"
true
)
;
Services
.
prefs
.
setIntPref
(
"
dom
.
quotaManager
.
temporaryStorage
.
fixedLimit
"
100
)
;
await
promiseQuotaManagerServiceReset
(
)
;
}
)
;
add_task
(
async
function
test_quota_exceeded_while_migrating_data
(
)
{
const
EXT_ID
=
"
test
-
data
-
migration
-
stuck
mochi
.
test
"
;
const
dataSize
=
1000
*
1024
;
await
createExtensionJSONFileWithData
(
EXT_ID
{
data
:
new
Array
(
dataSize
)
.
fill
(
"
x
"
)
.
join
(
"
"
)
}
)
;
const
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
permissions
:
[
"
storage
"
]
applications
:
{
gecko
:
{
id
:
EXT_ID
}
}
}
background
(
)
{
browser
.
test
.
onMessage
.
addListener
(
async
(
msg
dataSize
)
=
>
{
if
(
msg
!
=
=
"
verify
-
stored
-
data
"
)
{
return
;
}
const
res
=
await
browser
.
storage
.
local
.
get
(
)
;
browser
.
test
.
assertEq
(
res
.
data
&
&
res
.
data
.
length
dataSize
"
Got
the
expected
data
"
)
;
browser
.
test
.
sendMessage
(
"
verify
-
stored
-
data
:
done
"
)
;
}
)
;
browser
.
test
.
sendMessage
(
"
bg
-
page
:
ready
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
bg
-
page
:
ready
"
)
;
extension
.
sendMessage
(
"
verify
-
stored
-
data
"
dataSize
)
;
await
extension
.
awaitMessage
(
"
verify
-
stored
-
data
:
done
"
)
;
await
ok
(
!
ExtensionStorageIDB
.
isMigratedExtension
(
extension
)
"
The
extension
falls
back
to
the
JSONFile
backend
because
of
the
migration
failure
"
)
;
await
extension
.
unload
(
)
;
TelemetryTestUtils
.
assertEvents
(
[
{
value
:
EXT_ID
extra
:
{
backend
:
"
JSONFile
"
error_name
:
"
QuotaExceededError
"
}
}
]
TELEMETRY_EVENTS_FILTER
)
;
Services
.
prefs
.
clearUserPref
(
"
dom
.
quotaManager
.
temporaryStorage
.
fixedLimit
"
)
;
await
promiseQuotaManagerServiceClear
(
)
;
Services
.
prefs
.
clearUserPref
(
"
dom
.
quotaManager
.
testing
"
)
;
}
)
;
