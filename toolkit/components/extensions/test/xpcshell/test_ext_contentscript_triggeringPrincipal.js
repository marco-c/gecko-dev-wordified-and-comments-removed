"
use
strict
"
;
const
{
escaped
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
{
}
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
Services
.
prefs
.
setBoolPref
(
"
media
.
autoplay
.
enabled
"
true
)
;
Services
.
prefs
.
setIntPref
(
"
media
.
preload
.
default
"
3
)
;
Services
.
prefs
.
setIntPref
(
"
security
.
csp
.
reporting
.
script
-
sample
.
max
-
length
"
4096
)
;
ExtensionTestUtils
.
mockAppInfo
(
)
;
const
server
=
createHttpServer
(
)
;
server
.
registerDirectory
(
"
/
data
/
"
do_get_file
(
"
data
"
)
)
;
var
gContentSecurityPolicy
=
null
;
const
CSP_REPORT_PATH
=
"
/
csp
-
report
.
sjs
"
;
function
registerStaticPage
(
path
content
)
{
server
.
registerPathHandler
(
path
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
"
)
;
if
(
gContentSecurityPolicy
)
{
response
.
setHeader
(
"
Content
-
Security
-
Policy
"
gContentSecurityPolicy
)
;
}
response
.
write
(
content
)
;
}
)
;
}
const
BASE_URL
=
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
;
const
AUTOCLOSE_TAGS
=
new
Set
(
[
"
img
"
"
input
"
"
link
"
"
source
"
]
)
;
function
getElementData
(
test
opts
)
{
let
baseURL
=
typeof
BASE_URL
!
=
=
"
undefined
"
?
BASE_URL
:
location
.
href
;
let
{
srcAttr
src
}
=
test
;
src
=
new
URL
(
src
+
?
origin
=
{
encodeURIComponent
(
opts
.
origin
)
}
&
source
=
{
encodeURIComponent
(
opts
.
source
)
}
baseURL
)
.
href
;
let
haveSrc
=
false
;
function
rec
(
element
)
{
let
[
tagName
attrs
.
.
.
children
]
=
element
;
if
(
children
.
length
)
{
children
=
children
.
map
(
rec
)
;
}
else
if
(
!
haveSrc
)
{
attrs
=
Object
.
assign
(
{
[
srcAttr
]
:
src
}
attrs
)
;
haveSrc
=
true
;
}
return
{
tagName
attrs
children
}
;
}
return
rec
(
test
.
element
)
;
}
function
createElement
(
test
opts
)
{
let
srcElem
;
let
src
;
function
rec
(
{
tagName
attrs
children
}
)
{
let
elem
=
document
.
createElement
(
tagName
)
;
for
(
let
[
key
val
]
of
Object
.
entries
(
attrs
)
)
{
if
(
key
=
=
=
test
.
srcAttr
)
{
srcElem
=
elem
;
src
=
val
;
}
else
{
elem
.
setAttribute
(
key
val
)
;
}
}
for
(
let
child
of
children
)
{
elem
.
appendChild
(
rec
(
child
)
)
;
}
return
elem
;
}
let
elem
=
rec
(
getElementData
(
test
opts
)
)
;
return
{
elem
srcElem
src
}
;
}
function
toHTML
(
test
opts
)
{
function
rec
(
{
tagName
attrs
children
}
)
{
let
html
=
[
<
{
tagName
}
]
;
for
(
let
[
key
val
]
of
Object
.
entries
(
attrs
)
)
{
html
.
push
(
escaped
{
key
}
=
"
{
val
}
"
)
;
}
html
.
push
(
"
>
"
)
;
if
(
!
AUTOCLOSE_TAGS
.
has
(
tagName
)
)
{
for
(
let
child
of
children
)
{
html
.
push
(
rec
(
child
)
)
;
}
html
.
push
(
<
/
{
tagName
}
>
)
;
}
return
html
.
join
(
"
"
)
;
}
return
rec
(
getElementData
(
test
opts
)
)
;
}
function
testInlineCSS
(
)
{
let
urls
=
[
]
;
let
sources
=
[
]
;
let
i
=
0
;
let
url
=
(
origin
name
opts
=
{
}
)
=
>
{
let
source
=
{
origin
}
-
{
name
}
;
let
{
href
}
=
new
URL
(
css
-
{
i
+
+
}
.
png
?
origin
=
{
encodeURIComponent
(
origin
)
}
&
source
=
{
encodeURIComponent
(
source
)
}
location
.
href
)
;
urls
.
push
(
Object
.
assign
(
{
}
opts
{
href
origin
source
}
)
)
;
return
url
(
"
{
href
}
"
)
;
}
;
let
source
=
(
origin
css
)
=
>
{
sources
.
push
(
{
origin
css
}
)
;
return
css
;
}
;
let
laters
=
[
]
;
let
later
=
(
fn
)
=
>
{
laters
.
push
(
fn
)
;
}
;
{
let
li
=
document
.
createElement
(
"
li
"
)
;
li
.
setAttribute
(
"
style
"
source
(
"
contentScript
"
background
:
{
url
(
"
contentScript
"
"
li
.
style
-
first
"
)
}
)
)
;
li
.
style
.
wrappedJSObject
.
listStyleImage
=
url
(
"
page
"
"
li
.
style
.
listStyleImage
-
second
"
)
;
document
.
body
.
appendChild
(
li
)
;
}
{
let
li
=
document
.
createElement
(
"
li
"
)
;
li
.
wrappedJSObject
.
setAttribute
(
"
style
"
source
(
"
page
"
background
:
{
url
(
"
page
"
"
li
.
style
-
first
"
{
inline
:
true
}
)
}
)
)
;
li
.
style
.
listStyleImage
=
url
(
"
contentScript
"
"
li
.
style
.
listStyleImage
-
second
"
)
;
document
.
body
.
appendChild
(
li
)
;
}
{
let
li
=
document
.
createElement
(
"
li
"
)
;
document
.
body
.
appendChild
(
li
)
;
li
.
setAttribute
(
"
style
"
source
(
"
contentScript
"
background
:
{
url
(
"
contentScript
"
"
li
.
style
-
first
"
)
}
)
)
;
later
(
(
)
=
>
li
.
wrappedJSObject
.
setAttribute
(
"
style
"
source
(
"
page
"
background
:
{
url
(
"
page
"
"
li
.
style
-
second
"
{
inline
:
true
}
)
}
)
)
)
;
}
{
let
li
=
document
.
createElement
(
"
li
"
)
;
document
.
body
.
appendChild
(
li
)
;
li
.
wrappedJSObject
.
setAttribute
(
"
style
"
source
(
"
page
"
background
:
{
url
(
"
page
"
"
li
.
style
-
first
"
{
inline
:
true
}
)
}
)
)
;
later
(
(
)
=
>
li
.
setAttribute
(
"
style
"
source
(
"
contentScript
"
background
:
{
url
(
"
contentScript
"
"
li
.
style
-
second
"
)
}
)
)
)
;
}
{
let
li
=
document
.
createElement
(
"
li
"
)
;
document
.
body
.
appendChild
(
li
)
;
li
.
style
.
cssText
=
source
(
"
contentScript
"
background
:
{
url
(
"
contentScript
"
"
li
.
style
.
cssText
-
first
"
)
}
)
;
later
(
(
)
=
>
{
li
.
style
.
wrappedJSObject
.
cssText
=
background
:
{
url
(
"
page
"
"
li
.
style
.
cssText
-
second
"
)
}
;
}
)
;
}
let
divNum
=
0
;
function
getSelector
(
)
{
let
div
=
document
.
createElement
(
"
div
"
)
;
div
.
id
=
generated
-
div
-
{
divNum
+
+
}
;
document
.
body
.
appendChild
(
div
)
;
return
#
{
div
.
id
}
;
}
for
(
let
prop
of
[
"
textContent
"
"
innerHTML
"
]
)
{
{
let
sel
=
getSelector
(
)
;
let
style
=
document
.
createElement
(
"
style
"
)
;
style
[
prop
]
=
source
(
"
extension
"
{
sel
}
{
background
:
{
url
(
"
extension
"
style
-
{
prop
}
-
first
)
}
;
}
)
;
document
.
head
.
appendChild
(
style
)
;
later
(
(
)
=
>
{
style
.
wrappedJSObject
[
prop
]
=
source
(
"
page
"
{
sel
}
{
background
:
{
url
(
"
page
"
style
-
{
prop
}
-
second
{
inline
:
true
}
)
}
;
}
)
;
}
)
;
}
let
testModifyAfterInject
=
(
name
modifyFunc
)
=
>
{
let
sel
=
getSelector
(
)
;
let
style
=
document
.
createElement
(
"
style
"
)
;
style
[
prop
]
=
source
(
"
extension
"
{
sel
}
{
background
:
{
url
(
"
extension
"
style
-
{
name
}
-
{
prop
}
-
first
)
}
;
}
)
;
document
.
head
.
appendChild
(
style
)
;
later
(
(
)
=
>
{
modifyFunc
(
style
{
sel
}
{
background
:
{
url
(
"
page
"
style
-
{
name
}
-
{
prop
}
-
second
{
inline
:
true
}
)
}
;
}
)
;
source
(
"
page
"
style
.
textContent
)
;
}
)
;
}
;
testModifyAfterInject
(
"
appendChild
"
(
style
css
)
=
>
{
style
.
appendChild
(
document
.
createTextNode
(
css
)
)
;
}
)
;
testModifyAfterInject
(
"
insertAdjacentHTML
"
(
style
css
)
=
>
{
style
.
insertAdjacentHTML
(
"
beforeend
"
css
)
;
}
)
;
testModifyAfterInject
(
"
insertAdjacentText
"
(
style
css
)
=
>
{
style
.
insertAdjacentText
(
"
beforeend
"
css
)
;
}
)
;
{
let
sel
=
getSelector
(
)
;
let
style
=
document
.
createElement
(
"
style
"
)
;
style
[
prop
]
=
source
(
"
extension
"
{
sel
}
{
background
:
{
url
(
"
extension
"
style
-
{
prop
}
-
sheet
)
}
;
}
)
;
document
.
head
.
appendChild
(
style
)
;
browser
.
test
.
assertThrows
(
(
)
=
>
style
.
sheet
.
wrappedJSObject
.
cssRules
/
operation
is
insecure
/
"
Page
content
should
not
be
able
to
access
extension
-
generated
CSS
rules
"
)
;
style
.
sheet
.
insertRule
(
source
(
"
extension
"
{
sel
}
{
border
-
image
:
{
url
(
"
extension
"
style
-
{
prop
}
-
sheet
-
insertRule
)
}
;
}
)
)
;
}
}
setTimeout
(
(
)
=
>
{
for
(
let
fn
of
laters
)
{
fn
(
)
;
}
browser
.
test
.
sendMessage
(
"
css
-
sources
"
{
urls
sources
}
)
;
}
)
;
}
function
injectElements
(
tests
baseOpts
)
{
window
.
addEventListener
(
"
load
"
(
)
=
>
{
if
(
typeof
browser
=
=
=
"
object
"
)
{
try
{
testInlineCSS
(
)
;
}
catch
(
e
)
{
browser
.
test
.
fail
(
Error
:
{
e
}
:
:
{
e
.
stack
}
)
;
}
}
let
img
=
document
.
createElement
(
"
img
"
)
;
img
.
src
=
"
data
:
image
/
svg
+
xml
%
3Csvg
%
2F
%
3E
"
;
document
.
body
.
appendChild
(
img
)
;
let
rand
=
Math
.
random
(
)
;
let
cssText
=
font
-
face
{
font
-
family
:
"
DoesNotExist
{
rand
}
"
;
src
:
url
(
"
fonts
/
DoesNotExist
.
{
rand
}
.
woff
"
)
format
(
"
woff
"
)
;
font
-
weight
:
normal
;
font
-
style
:
normal
;
}
;
let
link
=
document
.
createElement
(
"
link
"
)
;
link
.
rel
=
"
stylesheet
"
;
link
.
href
=
"
data
:
text
/
css
;
base64
"
+
btoa
(
cssText
)
;
document
.
head
.
appendChild
(
link
)
;
let
style
=
document
.
createElement
(
"
style
"
)
;
style
.
textContent
=
cssText
;
document
.
head
.
appendChild
(
style
)
;
let
overrideOpts
=
opts
=
>
Object
.
assign
(
{
}
baseOpts
opts
)
;
let
opts
=
baseOpts
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
src
)
;
document
.
body
.
appendChild
(
elem
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
prop
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
srcElem
[
test
.
srcAttr
]
=
src
;
document
.
body
.
appendChild
(
elem
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
attr
-
after
-
inject
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
document
.
body
.
appendChild
(
elem
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
src
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
prop
-
after
-
inject
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
document
.
body
.
appendChild
(
elem
)
;
srcElem
[
test
.
srcAttr
]
=
src
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
relative
-
url
origin
:
"
page
"
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
src
=
src
.
replace
(
/
.
*
\
/
/
"
"
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
src
)
;
document
.
body
.
appendChild
(
elem
)
;
}
if
(
typeof
browser
!
=
=
"
undefined
"
)
{
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
content
-
attr
-
after
-
inject
origin
:
"
page
"
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
document
.
body
.
appendChild
(
elem
)
;
window
.
wrappedJSObject
.
elem
=
srcElem
;
window
.
wrappedJSObject
.
eval
(
elem
.
setAttribute
(
{
uneval
(
test
.
srcAttr
)
}
{
uneval
(
src
)
}
)
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
content
-
inject
-
after
-
attr
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
src
)
;
window
.
wrappedJSObject
.
elem
=
elem
;
window
.
wrappedJSObject
.
eval
(
document
.
body
.
appendChild
(
elem
)
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
inject
-
after
-
content
-
attr
origin
:
"
page
"
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
window
.
wrappedJSObject
.
elem
=
srcElem
;
window
.
wrappedJSObject
.
eval
(
elem
.
setAttribute
(
{
uneval
(
test
.
srcAttr
)
}
{
uneval
(
src
)
}
)
)
;
document
.
body
.
appendChild
(
elem
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
content
-
change
-
after
-
inject
origin
:
"
page
"
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
"
meh
.
txt
"
)
;
document
.
body
.
appendChild
(
elem
)
;
window
.
wrappedJSObject
.
elem
=
srcElem
;
window
.
wrappedJSObject
.
eval
(
elem
.
setAttribute
(
{
uneval
(
test
.
srcAttr
)
}
{
uneval
(
src
)
}
)
)
;
}
}
}
{
once
:
true
}
)
;
}
function
getInjectionScript
(
tests
opts
)
{
return
{
getElementData
}
{
createElement
}
{
testInlineCSS
}
(
{
injectElements
}
)
(
{
JSON
.
stringify
(
tests
)
}
{
JSON
.
stringify
(
opts
)
}
)
;
;
}
function
getOriginBase
(
origURL
)
{
let
url
=
new
URL
(
origURL
)
;
let
origin
=
url
.
searchParams
.
get
(
"
origin
"
)
;
url
.
searchParams
.
delete
(
"
origin
"
)
;
return
{
origin
baseURL
:
url
.
href
}
;
}
function
computeBaseURLs
(
tests
expectedSources
forbiddenSources
=
{
}
)
{
let
expectedURLs
=
new
Set
(
)
;
let
forbiddenURLs
=
new
Set
(
)
;
function
*
iterSources
(
test
sources
)
{
for
(
let
[
source
attrs
]
of
Object
.
entries
(
sources
)
)
{
if
(
Object
.
keys
(
attrs
)
.
every
(
attr
=
>
attrs
[
attr
]
=
=
=
test
[
attr
]
)
)
{
yield
{
BASE_URL
}
/
{
test
.
src
}
?
source
=
{
source
}
;
}
}
}
for
(
let
test
of
tests
)
{
for
(
let
urlPrefix
of
iterSources
(
test
expectedSources
)
)
{
expectedURLs
.
add
(
urlPrefix
)
;
}
for
(
let
urlPrefix
of
iterSources
(
test
forbiddenSources
)
)
{
forbiddenURLs
.
add
(
urlPrefix
)
;
}
}
return
{
expectedURLs
forbiddenURLs
blockedURLs
:
forbiddenURLs
}
;
}
function
computeExpectedForbiddenURLs
(
{
urls
sources
}
cspEnabled
=
false
)
{
let
expectedURLs
=
new
Set
(
)
;
let
forbiddenURLs
=
new
Set
(
)
;
let
blockedURLs
=
new
Set
(
)
;
let
blockedSources
=
new
Set
(
)
;
for
(
let
{
href
origin
inline
}
of
urls
)
{
let
{
baseURL
}
=
getOriginBase
(
href
)
;
if
(
cspEnabled
&
&
origin
=
=
=
"
page
"
)
{
if
(
inline
)
{
forbiddenURLs
.
add
(
baseURL
)
;
}
else
{
blockedURLs
.
add
(
baseURL
)
;
}
}
else
{
expectedURLs
.
add
(
baseURL
)
;
}
}
if
(
cspEnabled
)
{
for
(
let
{
origin
css
}
of
sources
)
{
if
(
origin
=
=
=
"
page
"
)
{
blockedSources
.
add
(
css
)
;
}
}
}
return
{
expectedURLs
forbiddenURLs
blockedURLs
blockedSources
}
;
}
function
awaitLoads
(
urlsPromise
origins
)
{
return
new
Promise
(
resolve
=
>
{
let
expectedURLs
forbiddenURLs
;
let
queuedChannels
=
[
]
;
let
observer
;
function
checkChannel
(
channel
)
{
let
origURL
=
channel
.
URI
.
spec
;
let
{
baseURL
origin
}
=
getOriginBase
(
origURL
)
;
if
(
forbiddenURLs
.
has
(
baseURL
)
)
{
ok
(
false
Got
unexpected
request
for
forbidden
URL
{
origURL
}
)
;
}
if
(
expectedURLs
.
has
(
baseURL
)
)
{
expectedURLs
.
delete
(
baseURL
)
;
equal
(
channel
.
loadInfo
.
triggeringPrincipal
.
origin
origins
[
origin
]
Got
expected
origin
for
URL
{
origURL
}
)
;
if
(
!
expectedURLs
.
size
)
{
Services
.
obs
.
removeObserver
(
observer
"
http
-
on
-
modify
-
request
"
)
;
info
(
"
Got
all
expected
requests
"
)
;
resolve
(
)
;
}
}
}
urlsPromise
.
then
(
urls
=
>
{
expectedURLs
=
new
Set
(
urls
.
expectedURLs
)
;
forbiddenURLs
=
new
Set
(
[
.
.
.
urls
.
forbiddenURLs
.
.
.
urls
.
blockedURLs
]
)
;
for
(
let
channel
of
queuedChannels
.
splice
(
0
)
)
{
checkChannel
(
channel
.
QueryInterface
(
Ci
.
nsIChannel
)
)
;
}
}
)
;
observer
=
(
channel
topic
data
)
=
>
{
if
(
expectedURLs
)
{
checkChannel
(
channel
.
QueryInterface
(
Ci
.
nsIChannel
)
)
;
}
else
{
queuedChannels
.
push
(
channel
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
"
http
-
on
-
modify
-
request
"
)
;
}
)
;
}
function
readUTF8InputStream
(
stream
)
{
let
buffer
=
NetUtil
.
readInputStream
(
stream
stream
.
available
(
)
)
;
return
new
TextDecoder
(
)
.
decode
(
buffer
)
;
}
function
awaitCSP
(
urlsPromise
)
{
return
new
Promise
(
resolve
=
>
{
let
expectedURLs
blockedURLs
blockedSources
;
let
queuedRequests
=
[
]
;
function
checkRequest
(
request
)
{
let
body
=
JSON
.
parse
(
readUTF8InputStream
(
request
.
bodyInputStream
)
)
;
let
report
=
body
[
"
csp
-
report
"
]
;
let
origURL
=
report
[
"
blocked
-
uri
"
]
;
if
(
origURL
!
=
=
"
inline
"
&
&
origURL
!
=
=
"
"
)
{
let
{
baseURL
}
=
getOriginBase
(
origURL
)
;
if
(
expectedURLs
.
has
(
baseURL
)
)
{
ok
(
false
Got
unexpected
CSP
report
for
allowed
URL
{
origURL
}
)
;
}
if
(
blockedURLs
.
has
(
baseURL
)
)
{
blockedURLs
.
delete
(
baseURL
)
;
info
(
Got
CSP
report
for
forbidden
URL
{
origURL
}
)
;
}
}
let
source
=
report
[
"
script
-
sample
"
]
;
if
(
source
)
{
if
(
blockedSources
.
has
(
source
)
)
{
blockedSources
.
delete
(
source
)
;
info
(
Got
CSP
report
for
forbidden
inline
source
{
JSON
.
stringify
(
source
)
}
)
;
}
}
if
(
!
blockedURLs
.
size
&
&
!
blockedSources
.
size
)
{
info
(
"
Got
all
expected
CSP
reports
"
)
;
resolve
(
)
;
}
}
urlsPromise
.
then
(
urls
=
>
{
blockedURLs
=
new
Set
(
urls
.
blockedURLs
)
;
blockedSources
=
new
Set
(
urls
.
blockedSources
)
;
(
{
expectedURLs
}
=
urls
)
;
for
(
let
request
of
queuedRequests
.
splice
(
0
)
)
{
checkRequest
(
request
)
;
}
}
)
;
server
.
registerPathHandler
(
CSP_REPORT_PATH
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
204
"
No
Content
"
)
;
if
(
expectedURLs
)
{
checkRequest
(
request
)
;
}
else
{
queuedRequests
.
push
(
request
)
;
}
}
)
;
}
)
;
}
const
TESTS
=
[
{
element
:
[
"
audio
"
{
}
]
src
:
"
audio
.
webm
"
}
{
element
:
[
"
audio
"
{
}
[
"
source
"
{
}
]
]
src
:
"
audio
-
source
.
webm
"
}
{
element
:
[
"
iframe
"
{
}
]
src
:
"
iframe
.
html
"
}
{
element
:
[
"
img
"
{
}
]
src
:
"
img
.
png
"
}
{
element
:
[
"
img
"
{
}
]
src
:
"
imgset
.
png
"
srcAttr
:
"
srcset
"
}
{
element
:
[
"
input
"
{
type
:
"
image
"
}
]
src
:
"
input
.
png
"
}
{
element
:
[
"
link
"
{
rel
:
"
stylesheet
"
}
]
src
:
"
link
.
css
"
srcAttr
:
"
href
"
}
{
element
:
[
"
picture
"
{
}
[
"
source
"
{
}
]
[
"
img
"
{
}
]
]
src
:
"
picture
.
png
"
srcAttr
:
"
srcset
"
}
{
element
:
[
"
script
"
{
}
]
src
:
"
script
.
js
"
liveSrc
:
false
}
{
element
:
[
"
video
"
{
}
]
src
:
"
video
.
webm
"
}
{
element
:
[
"
video
"
{
}
[
"
source
"
{
}
]
]
src
:
"
video
-
source
.
webm
"
}
]
;
for
(
let
test
of
TESTS
)
{
if
(
!
test
.
srcAttr
)
{
test
.
srcAttr
=
"
src
"
;
}
if
(
!
(
"
liveSrc
"
in
test
)
)
{
test
.
liveSrc
=
true
;
}
}
const
PAGE_SOURCES
=
{
"
contentScript
-
content
-
attr
-
after
-
inject
"
:
{
liveSrc
:
true
}
"
contentScript
-
content
-
change
-
after
-
inject
"
:
{
liveSrc
:
true
}
"
contentScript
-
inject
-
after
-
content
-
attr
"
:
{
}
"
contentScript
-
relative
-
url
"
:
{
}
"
pageHTML
"
:
{
}
"
pageScript
"
:
{
}
"
pageScript
-
attr
-
after
-
inject
"
:
{
}
"
pageScript
-
prop
"
:
{
}
"
pageScript
-
prop
-
after
-
inject
"
:
{
}
"
pageScript
-
relative
-
url
"
:
{
}
}
;
const
EXTENSION_SOURCES
=
{
"
contentScript
"
:
{
}
"
contentScript
-
attr
-
after
-
inject
"
:
{
liveSrc
:
true
}
"
contentScript
-
content
-
inject
-
after
-
attr
"
:
{
}
"
contentScript
-
prop
"
:
{
}
"
contentScript
-
prop
-
after
-
inject
"
:
{
}
}
;
const
SOURCES
=
Object
.
assign
(
{
}
PAGE_SOURCES
EXTENSION_SOURCES
)
;
registerStaticPage
(
"
/
page
.
html
"
<
!
DOCTYPE
html
>
<
html
lang
=
"
en
"
>
<
head
>
<
meta
charset
=
"
UTF
-
8
"
>
<
title
>
<
/
title
>
<
script
nonce
=
"
deadbeef
"
>
{
getInjectionScript
(
TESTS
{
source
:
"
pageScript
"
origin
:
"
page
"
}
)
}
<
/
script
>
<
/
head
>
<
body
>
{
TESTS
.
map
(
test
=
>
toHTML
(
test
{
source
:
"
pageHTML
"
origin
:
"
page
"
}
)
)
.
join
(
"
\
n
"
)
}
<
/
body
>
<
/
html
>
)
;
const
EXTENSION_DATA
=
{
manifest
:
{
content_scripts
:
[
{
"
matches
"
:
[
"
http
:
/
/
*
/
page
.
html
"
]
"
run_at
"
:
"
document_start
"
"
js
"
:
[
"
content_script
.
js
"
]
}
]
}
files
:
{
"
content_script
.
js
"
:
getInjectionScript
(
TESTS
{
source
:
"
contentScript
"
origin
:
"
contentScript
"
}
)
}
}
;
const
pageURL
=
{
BASE_URL
}
/
page
.
html
;
const
pageURI
=
Services
.
io
.
newURI
(
pageURL
)
;
function
mergeSources
(
a
b
)
{
return
{
expectedURLs
:
new
Set
(
[
.
.
.
a
.
expectedURLs
.
.
.
b
.
expectedURLs
]
)
forbiddenURLs
:
new
Set
(
[
.
.
.
a
.
forbiddenURLs
.
.
.
b
.
forbiddenURLs
]
)
blockedURLs
:
new
Set
(
[
.
.
.
a
.
blockedURLs
.
.
.
b
.
blockedURLs
]
)
blockedSources
:
a
.
blockedSources
|
|
b
.
blockedSources
}
;
}
function
getOrigins
(
extension
)
{
return
{
page
:
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
pageURI
{
}
)
.
origin
contentScript
:
Cu
.
getObjectPrincipal
(
Cu
.
Sandbox
(
[
extension
.
principal
pageURL
]
)
)
.
origin
extension
:
extension
.
principal
.
origin
}
;
}
add_task
(
async
function
test_contentscript_triggeringPrincipals
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
EXTENSION_DATA
)
;
await
extension
.
startup
(
)
;
let
urlsPromise
=
extension
.
awaitMessage
(
"
css
-
sources
"
)
.
then
(
msg
=
>
{
return
mergeSources
(
computeExpectedForbiddenURLs
(
msg
)
computeBaseURLs
(
TESTS
SOURCES
)
)
;
}
)
;
let
origins
=
getOrigins
(
extension
.
extension
)
;
let
finished
=
awaitLoads
(
urlsPromise
origins
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
pageURL
)
;
await
finished
;
await
extension
.
unload
(
)
;
await
contentPage
.
close
(
)
;
clearCache
(
)
;
}
)
;
add_task
(
async
function
test_contentscript_csp
(
)
{
let
chaosMode
=
parseInt
(
env
.
get
(
"
MOZ_CHAOSMODE
"
)
16
)
;
let
checkCSPReports
=
!
(
chaosMode
=
=
=
0
|
|
chaosMode
&
0x02
)
;
gContentSecurityPolicy
=
default
-
src
'
none
'
'
report
-
sample
'
;
script
-
src
'
nonce
-
deadbeef
'
'
unsafe
-
eval
'
'
report
-
sample
'
;
report
-
uri
{
CSP_REPORT_PATH
}
;
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
EXTENSION_DATA
)
;
await
extension
.
startup
(
)
;
let
urlsPromise
=
extension
.
awaitMessage
(
"
css
-
sources
"
)
.
then
(
msg
=
>
{
return
mergeSources
(
computeExpectedForbiddenURLs
(
msg
true
)
computeBaseURLs
(
TESTS
EXTENSION_SOURCES
PAGE_SOURCES
)
)
;
}
)
;
let
origins
=
getOrigins
(
extension
.
extension
)
;
let
finished
=
Promise
.
all
(
[
awaitLoads
(
urlsPromise
origins
)
checkCSPReports
&
&
awaitCSP
(
urlsPromise
)
]
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
pageURL
)
;
await
finished
;
await
extension
.
unload
(
)
;
await
contentPage
.
close
(
)
;
}
)
;
