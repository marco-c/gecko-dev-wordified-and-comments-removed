"
use
strict
"
;
const
{
escaped
}
=
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
{
}
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
Services
.
prefs
.
setBoolPref
(
"
media
.
autoplay
.
enabled
"
true
)
;
Services
.
prefs
.
setIntPref
(
"
media
.
preload
.
default
"
3
)
;
ExtensionTestUtils
.
mockAppInfo
(
)
;
const
server
=
createHttpServer
(
)
;
server
.
registerDirectory
(
"
/
data
/
"
do_get_file
(
"
data
"
)
)
;
var
gContentSecurityPolicy
=
null
;
const
CSP_REPORT_PATH
=
"
/
csp
-
report
.
sjs
"
;
function
registerStaticPage
(
path
content
)
{
server
.
registerPathHandler
(
path
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
"
)
;
if
(
gContentSecurityPolicy
)
{
response
.
setHeader
(
"
Content
-
Security
-
Policy
"
gContentSecurityPolicy
)
;
}
response
.
write
(
content
)
;
}
)
;
}
const
BASE_URL
=
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
;
const
AUTOCLOSE_TAGS
=
new
Set
(
[
"
img
"
"
input
"
"
link
"
"
source
"
]
)
;
function
getElementData
(
test
opts
)
{
let
baseURL
=
typeof
BASE_URL
!
=
=
"
undefined
"
?
BASE_URL
:
location
.
href
;
let
{
srcAttr
src
}
=
test
;
src
=
new
URL
(
src
+
?
origin
=
{
encodeURIComponent
(
opts
.
origin
)
}
&
source
=
{
encodeURIComponent
(
opts
.
source
)
}
baseURL
)
.
href
;
let
haveSrc
=
false
;
function
rec
(
element
)
{
let
[
tagName
attrs
.
.
.
children
]
=
element
;
if
(
children
.
length
)
{
children
=
children
.
map
(
rec
)
;
}
else
if
(
!
haveSrc
)
{
attrs
=
Object
.
assign
(
{
[
srcAttr
]
:
src
}
attrs
)
;
haveSrc
=
true
;
}
return
{
tagName
attrs
children
}
;
}
return
rec
(
test
.
element
)
;
}
function
createElement
(
test
opts
)
{
let
srcElem
;
let
src
;
function
rec
(
{
tagName
attrs
children
}
)
{
let
elem
=
document
.
createElement
(
tagName
)
;
for
(
let
[
key
val
]
of
Object
.
entries
(
attrs
)
)
{
if
(
key
=
=
=
test
.
srcAttr
)
{
srcElem
=
elem
;
src
=
val
;
}
else
{
elem
.
setAttribute
(
key
val
)
;
}
}
for
(
let
child
of
children
)
{
elem
.
appendChild
(
rec
(
child
)
)
;
}
return
elem
;
}
let
elem
=
rec
(
getElementData
(
test
opts
)
)
;
return
{
elem
srcElem
src
}
;
}
function
toHTML
(
test
opts
)
{
function
rec
(
{
tagName
attrs
children
}
)
{
let
html
=
[
<
{
tagName
}
]
;
for
(
let
[
key
val
]
of
Object
.
entries
(
attrs
)
)
{
html
.
push
(
escaped
{
key
}
=
"
{
val
}
"
)
;
}
html
.
push
(
"
>
"
)
;
if
(
!
AUTOCLOSE_TAGS
.
has
(
tagName
)
)
{
for
(
let
child
of
children
)
{
html
.
push
(
rec
(
child
)
)
;
}
html
.
push
(
<
/
{
tagName
}
>
)
;
}
return
html
.
join
(
"
"
)
;
}
return
rec
(
getElementData
(
test
opts
)
)
;
}
function
injectElements
(
tests
baseOpts
)
{
window
.
addEventListener
(
"
load
"
(
)
=
>
{
let
img
=
document
.
createElement
(
"
img
"
)
;
img
.
src
=
"
data
:
image
/
svg
+
xml
%
3Csvg
%
2F
%
3E
"
;
document
.
body
.
appendChild
(
img
)
;
let
rand
=
Math
.
random
(
)
;
let
link
=
document
.
createElement
(
"
link
"
)
;
link
.
rel
=
"
stylesheet
"
;
link
.
href
=
"
data
:
text
/
css
;
base64
"
+
btoa
(
font
-
face
{
font
-
family
:
"
DoesNotExist
{
rand
}
"
;
src
:
url
(
"
fonts
/
DoesNotExist
.
{
rand
}
.
woff
"
)
format
(
"
woff
"
)
;
font
-
weight
:
normal
;
font
-
style
:
normal
;
}
)
;
document
.
head
.
appendChild
(
link
)
;
let
overrideOpts
=
opts
=
>
Object
.
assign
(
{
}
baseOpts
opts
)
;
let
opts
=
baseOpts
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
src
)
;
document
.
body
.
appendChild
(
elem
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
prop
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
srcElem
[
test
.
srcAttr
]
=
src
;
document
.
body
.
appendChild
(
elem
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
attr
-
after
-
inject
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
document
.
body
.
appendChild
(
elem
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
src
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
prop
-
after
-
inject
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
document
.
body
.
appendChild
(
elem
)
;
srcElem
[
test
.
srcAttr
]
=
src
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
relative
-
url
origin
:
"
page
"
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
src
=
src
.
replace
(
/
.
*
\
/
/
"
"
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
src
)
;
document
.
body
.
appendChild
(
elem
)
;
}
if
(
typeof
browser
!
=
=
"
undefined
"
)
{
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
content
-
attr
-
after
-
inject
origin
:
"
page
"
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
document
.
body
.
appendChild
(
elem
)
;
window
.
wrappedJSObject
.
elem
=
srcElem
;
window
.
wrappedJSObject
.
eval
(
elem
.
setAttribute
(
{
uneval
(
test
.
srcAttr
)
}
{
uneval
(
src
)
}
)
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
content
-
inject
-
after
-
attr
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
src
)
;
window
.
wrappedJSObject
.
elem
=
elem
;
window
.
wrappedJSObject
.
eval
(
document
.
body
.
appendChild
(
elem
)
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
inject
-
after
-
content
-
attr
origin
:
"
page
"
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
window
.
wrappedJSObject
.
elem
=
srcElem
;
window
.
wrappedJSObject
.
eval
(
elem
.
setAttribute
(
{
uneval
(
test
.
srcAttr
)
}
{
uneval
(
src
)
}
)
)
;
document
.
body
.
appendChild
(
elem
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
content
-
change
-
after
-
inject
origin
:
"
page
"
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
"
meh
.
txt
"
)
;
document
.
body
.
appendChild
(
elem
)
;
window
.
wrappedJSObject
.
elem
=
srcElem
;
window
.
wrappedJSObject
.
eval
(
elem
.
setAttribute
(
{
uneval
(
test
.
srcAttr
)
}
{
uneval
(
src
)
}
)
)
;
}
}
}
{
once
:
true
}
)
;
}
function
getInjectionScript
(
tests
opts
)
{
return
{
getElementData
}
{
createElement
}
(
{
injectElements
}
)
(
{
JSON
.
stringify
(
tests
)
}
{
JSON
.
stringify
(
opts
)
}
)
;
;
}
function
computeBaseURLs
(
tests
expectedSources
forbiddenSources
=
{
}
)
{
let
expectedURLs
=
new
Set
(
)
;
let
forbiddenURLs
=
new
Set
(
)
;
function
*
iterSources
(
test
sources
)
{
for
(
let
[
source
attrs
]
of
Object
.
entries
(
sources
)
)
{
if
(
Object
.
keys
(
attrs
)
.
every
(
attr
=
>
attrs
[
attr
]
=
=
=
test
[
attr
]
)
)
{
yield
{
BASE_URL
}
/
{
test
.
src
}
?
source
=
{
source
}
;
}
}
}
for
(
let
test
of
tests
)
{
for
(
let
urlPrefix
of
iterSources
(
test
expectedSources
)
)
{
expectedURLs
.
add
(
urlPrefix
)
;
}
for
(
let
urlPrefix
of
iterSources
(
test
forbiddenSources
)
)
{
forbiddenURLs
.
add
(
urlPrefix
)
;
}
}
return
{
expectedURLs
forbiddenURLs
}
;
}
function
awaitLoads
(
{
expectedURLs
forbiddenURLs
}
origins
)
{
expectedURLs
=
new
Set
(
expectedURLs
)
;
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
channel
topic
data
)
=
>
{
channel
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
origURL
=
channel
.
URI
.
spec
;
let
url
=
new
URL
(
origURL
)
;
let
origin
=
url
.
searchParams
.
get
(
"
origin
"
)
;
url
.
searchParams
.
delete
(
"
origin
"
)
;
if
(
forbiddenURLs
.
has
(
url
.
href
)
)
{
ok
(
false
Got
unexpected
request
for
forbidden
URL
{
origURL
}
)
;
}
if
(
expectedURLs
.
has
(
url
.
href
)
)
{
expectedURLs
.
delete
(
url
.
href
)
;
equal
(
channel
.
loadInfo
.
triggeringPrincipal
.
origin
origins
[
origin
]
Got
expected
origin
for
URL
{
origURL
}
)
;
if
(
!
expectedURLs
.
size
)
{
Services
.
obs
.
removeObserver
(
observer
"
http
-
on
-
modify
-
request
"
)
;
do_print
(
"
Got
all
expected
requests
"
)
;
resolve
(
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
observer
"
http
-
on
-
modify
-
request
"
)
;
}
)
;
}
function
readUTF8InputStream
(
stream
)
{
let
buffer
=
NetUtil
.
readInputStream
(
stream
stream
.
available
(
)
)
;
return
new
TextDecoder
(
)
.
decode
(
buffer
)
;
}
function
awaitCSP
(
{
expectedURLs
forbiddenURLs
}
)
{
forbiddenURLs
=
new
Set
(
forbiddenURLs
)
;
return
new
Promise
(
resolve
=
>
{
server
.
registerPathHandler
(
CSP_REPORT_PATH
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
204
"
No
Content
"
)
;
let
body
=
JSON
.
parse
(
readUTF8InputStream
(
request
.
bodyInputStream
)
)
;
let
report
=
body
[
"
csp
-
report
"
]
;
let
origURL
=
report
[
"
blocked
-
uri
"
]
;
let
url
=
new
URL
(
origURL
)
;
url
.
searchParams
.
delete
(
"
origin
"
)
;
if
(
expectedURLs
.
has
(
url
.
href
)
)
{
ok
(
false
Got
unexpected
CSP
report
for
allowed
URL
{
origURL
}
)
;
}
if
(
forbiddenURLs
.
has
(
url
.
href
)
)
{
forbiddenURLs
.
delete
(
url
.
href
)
;
do_print
(
Got
CSP
report
for
forbidden
URL
{
origURL
}
)
;
if
(
!
forbiddenURLs
.
size
)
{
do_print
(
"
Got
all
expected
CSP
reports
"
)
;
resolve
(
)
;
}
}
}
)
;
}
)
;
}
const
TESTS
=
[
{
element
:
[
"
audio
"
{
}
]
src
:
"
audio
.
webm
"
}
{
element
:
[
"
audio
"
{
}
[
"
source
"
{
}
]
]
src
:
"
audio
-
source
.
webm
"
}
{
element
:
[
"
iframe
"
{
}
]
src
:
"
iframe
.
html
"
}
{
element
:
[
"
img
"
{
}
]
src
:
"
img
.
png
"
}
{
element
:
[
"
img
"
{
}
]
src
:
"
imgset
.
png
"
srcAttr
:
"
srcset
"
}
{
element
:
[
"
input
"
{
type
:
"
image
"
}
]
src
:
"
input
.
png
"
}
{
element
:
[
"
link
"
{
rel
:
"
stylesheet
"
}
]
src
:
"
link
.
css
"
srcAttr
:
"
href
"
}
{
element
:
[
"
picture
"
{
}
[
"
source
"
{
}
]
[
"
img
"
{
}
]
]
src
:
"
picture
.
png
"
srcAttr
:
"
srcset
"
}
{
element
:
[
"
script
"
{
}
]
src
:
"
script
.
js
"
liveSrc
:
false
}
{
element
:
[
"
video
"
{
}
]
src
:
"
video
.
webm
"
}
{
element
:
[
"
video
"
{
}
[
"
source
"
{
}
]
]
src
:
"
video
-
source
.
webm
"
}
]
;
for
(
let
test
of
TESTS
)
{
if
(
!
test
.
srcAttr
)
{
test
.
srcAttr
=
"
src
"
;
}
if
(
!
(
"
liveSrc
"
in
test
)
)
{
test
.
liveSrc
=
true
;
}
}
const
PAGE_SOURCES
=
{
"
contentScript
-
content
-
attr
-
after
-
inject
"
:
{
liveSrc
:
true
}
"
contentScript
-
content
-
change
-
after
-
inject
"
:
{
liveSrc
:
true
}
"
contentScript
-
inject
-
after
-
content
-
attr
"
:
{
}
"
contentScript
-
relative
-
url
"
:
{
}
"
pageHTML
"
:
{
}
"
pageScript
"
:
{
}
"
pageScript
-
attr
-
after
-
inject
"
:
{
}
"
pageScript
-
prop
"
:
{
}
"
pageScript
-
prop
-
after
-
inject
"
:
{
}
"
pageScript
-
relative
-
url
"
:
{
}
}
;
const
EXTENSION_SOURCES
=
{
"
contentScript
"
:
{
}
"
contentScript
-
attr
-
after
-
inject
"
:
{
liveSrc
:
true
}
"
contentScript
-
content
-
inject
-
after
-
attr
"
:
{
}
"
contentScript
-
prop
"
:
{
}
"
contentScript
-
prop
-
after
-
inject
"
:
{
}
}
;
const
SOURCES
=
Object
.
assign
(
{
}
PAGE_SOURCES
EXTENSION_SOURCES
)
;
registerStaticPage
(
"
/
page
.
html
"
<
!
DOCTYPE
html
>
<
html
lang
=
"
en
"
>
<
head
>
<
meta
charset
=
"
UTF
-
8
"
>
<
title
>
<
/
title
>
<
script
nonce
=
"
deadbeef
"
>
{
getInjectionScript
(
TESTS
{
source
:
"
pageScript
"
origin
:
"
page
"
}
)
}
<
/
script
>
<
/
head
>
<
body
>
{
TESTS
.
map
(
test
=
>
toHTML
(
test
{
source
:
"
pageHTML
"
origin
:
"
page
"
}
)
)
.
join
(
"
\
n
"
)
}
<
/
body
>
<
/
html
>
)
;
const
EXTENSION_DATA
=
{
manifest
:
{
content_scripts
:
[
{
"
matches
"
:
[
"
http
:
/
/
*
/
page
.
html
"
]
"
run_at
"
:
"
document_start
"
"
js
"
:
[
"
content_script
.
js
"
]
}
]
}
files
:
{
"
content_script
.
js
"
:
getInjectionScript
(
TESTS
{
source
:
"
contentScript
"
origin
:
"
extension
"
}
)
}
}
;
const
pageURL
=
{
BASE_URL
}
/
page
.
html
;
const
pageURI
=
Services
.
io
.
newURI
(
pageURL
)
;
add_task
(
async
function
test_contentscript_triggeringPrincipals
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
EXTENSION_DATA
)
;
await
extension
.
startup
(
)
;
let
origins
=
{
page
:
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
pageURI
{
}
)
.
origin
extension
:
Cu
.
getObjectPrincipal
(
Cu
.
Sandbox
(
[
extension
.
extension
.
principal
pageURL
]
)
)
.
origin
}
;
let
finished
=
awaitLoads
(
computeBaseURLs
(
TESTS
SOURCES
)
origins
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
pageURL
)
;
await
finished
;
await
extension
.
unload
(
)
;
await
contentPage
.
close
(
)
;
clearCache
(
)
;
}
)
;
add_task
(
async
function
test_contentscript_csp
(
)
{
let
chaosMode
=
parseInt
(
env
.
get
(
"
MOZ_CHAOSMODE
"
)
16
)
;
let
checkCSPReports
=
!
(
chaosMode
=
=
=
0
|
|
chaosMode
&
0x02
)
;
gContentSecurityPolicy
=
default
-
src
'
none
'
;
script
-
src
'
nonce
-
deadbeef
'
'
unsafe
-
eval
'
;
report
-
uri
{
CSP_REPORT_PATH
}
;
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
EXTENSION_DATA
)
;
await
extension
.
startup
(
)
;
let
origins
=
{
page
:
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
pageURI
{
}
)
.
origin
extension
:
Cu
.
getObjectPrincipal
(
Cu
.
Sandbox
(
[
extension
.
extension
.
principal
pageURL
]
)
)
.
origin
}
;
let
baseURLs
=
computeBaseURLs
(
TESTS
EXTENSION_SOURCES
PAGE_SOURCES
)
;
let
finished
=
Promise
.
all
(
[
awaitLoads
(
baseURLs
origins
)
checkCSPReports
&
&
awaitCSP
(
baseURLs
)
]
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
pageURL
)
;
await
finished
;
await
extension
.
unload
(
)
;
await
contentPage
.
close
(
)
;
}
)
;
