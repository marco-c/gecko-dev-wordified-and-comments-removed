"
use
strict
"
;
const
{
escaped
}
=
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
{
}
)
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
Services
.
prefs
.
setBoolPref
(
"
media
.
autoplay
.
enabled
"
true
)
;
Services
.
prefs
.
setIntPref
(
"
media
.
preload
.
default
"
3
)
;
ExtensionTestUtils
.
mockAppInfo
(
)
;
const
server
=
createHttpServer
(
)
;
server
.
registerDirectory
(
"
/
data
/
"
do_get_file
(
"
data
"
)
)
;
function
registerStaticPage
(
path
content
)
{
server
.
registerPathHandler
(
path
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
"
)
;
response
.
write
(
content
)
;
}
)
;
}
const
BASE_URL
=
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
;
const
AUTOCLOSE_TAGS
=
new
Set
(
[
"
img
"
"
source
"
]
)
;
function
getElementData
(
test
opts
)
{
let
baseURL
=
typeof
BASE_URL
!
=
=
"
undefined
"
?
BASE_URL
:
location
.
href
;
let
{
srcAttr
src
}
=
test
;
src
=
new
URL
(
src
+
?
origin
=
{
encodeURIComponent
(
opts
.
origin
)
}
&
source
=
{
encodeURIComponent
(
opts
.
source
)
}
baseURL
)
.
href
;
let
haveSrc
=
false
;
function
rec
(
element
)
{
let
[
tagName
attrs
.
.
.
children
]
=
element
;
if
(
children
.
length
)
{
children
=
children
.
map
(
rec
)
;
}
else
if
(
!
haveSrc
)
{
attrs
=
Object
.
assign
(
{
[
srcAttr
]
:
src
}
attrs
)
;
haveSrc
=
true
;
}
return
{
tagName
attrs
children
}
;
}
return
rec
(
test
.
element
)
;
}
function
createElement
(
test
opts
)
{
let
srcElem
;
let
src
;
function
rec
(
{
tagName
attrs
children
}
)
{
let
elem
=
document
.
createElement
(
tagName
)
;
for
(
let
[
key
val
]
of
Object
.
entries
(
attrs
)
)
{
if
(
key
=
=
=
test
.
srcAttr
)
{
srcElem
=
elem
;
src
=
val
;
}
else
{
elem
.
setAttribute
(
key
val
)
;
}
}
for
(
let
child
of
children
)
{
elem
.
appendChild
(
rec
(
child
)
)
;
}
return
elem
;
}
let
elem
=
rec
(
getElementData
(
test
opts
)
)
;
return
{
elem
srcElem
src
}
;
}
function
toHTML
(
test
opts
)
{
function
rec
(
{
tagName
attrs
children
}
)
{
let
html
=
[
<
{
tagName
}
]
;
for
(
let
[
key
val
]
of
Object
.
entries
(
attrs
)
)
{
html
.
push
(
escaped
{
key
}
=
"
{
val
}
"
)
;
}
html
.
push
(
"
>
"
)
;
if
(
!
AUTOCLOSE_TAGS
.
has
(
tagName
)
)
{
for
(
let
child
of
children
)
{
html
.
push
(
rec
(
child
)
)
;
}
html
.
push
(
<
/
{
tagName
}
>
)
;
}
return
html
.
join
(
"
"
)
;
}
return
rec
(
getElementData
(
test
opts
)
)
;
}
function
injectElements
(
tests
baseOpts
)
{
window
.
addEventListener
(
"
load
"
(
)
=
>
{
let
overrideOpts
=
opts
=
>
Object
.
assign
(
{
}
baseOpts
opts
)
;
let
opts
=
baseOpts
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
src
)
;
document
.
body
.
appendChild
(
elem
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
prop
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
srcElem
[
test
.
srcAttr
]
=
src
;
document
.
body
.
appendChild
(
elem
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
attr
-
after
-
inject
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
document
.
body
.
appendChild
(
elem
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
src
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
prop
-
after
-
inject
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
document
.
body
.
appendChild
(
elem
)
;
srcElem
[
test
.
srcAttr
]
=
src
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
relative
-
url
origin
:
"
page
"
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
src
=
src
.
replace
(
/
.
*
\
/
/
"
"
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
src
)
;
document
.
body
.
appendChild
(
elem
)
;
}
if
(
typeof
browser
!
=
=
"
undefined
"
)
{
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
content
-
attr
-
after
-
inject
origin
:
"
page
"
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
document
.
body
.
appendChild
(
elem
)
;
window
.
wrappedJSObject
.
elem
=
srcElem
;
window
.
wrappedJSObject
.
eval
(
elem
.
setAttribute
(
{
uneval
(
test
.
srcAttr
)
}
{
uneval
(
src
)
}
)
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
content
-
inject
-
after
-
attr
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
src
)
;
window
.
wrappedJSObject
.
elem
=
elem
;
window
.
wrappedJSObject
.
eval
(
document
.
body
.
appendChild
(
elem
)
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
inject
-
after
-
content
-
attr
origin
:
"
page
"
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
window
.
wrappedJSObject
.
elem
=
srcElem
;
window
.
wrappedJSObject
.
eval
(
elem
.
setAttribute
(
{
uneval
(
test
.
srcAttr
)
}
{
uneval
(
src
)
}
)
)
;
document
.
body
.
appendChild
(
elem
)
;
}
opts
=
overrideOpts
(
{
source
:
{
baseOpts
.
source
}
-
content
-
change
-
after
-
inject
origin
:
"
page
"
}
)
;
for
(
let
test
of
tests
)
{
let
{
elem
srcElem
src
}
=
createElement
(
test
opts
)
;
srcElem
.
setAttribute
(
test
.
srcAttr
"
meh
.
txt
"
)
;
document
.
body
.
appendChild
(
elem
)
;
window
.
wrappedJSObject
.
elem
=
srcElem
;
window
.
wrappedJSObject
.
eval
(
elem
.
setAttribute
(
{
uneval
(
test
.
srcAttr
)
}
{
uneval
(
src
)
}
)
)
;
}
}
}
{
once
:
true
}
)
;
}
function
getInjectionScript
(
tests
opts
)
{
return
{
getElementData
}
{
createElement
}
(
{
injectElements
}
)
(
{
JSON
.
stringify
(
tests
)
}
{
JSON
.
stringify
(
opts
)
}
)
;
;
}
function
awaitLoads
(
tests
sources
origins
)
{
let
expectedURLs
=
new
Set
(
)
;
for
(
let
test
of
tests
)
{
for
(
let
[
source
attrs
]
of
Object
.
entries
(
sources
)
)
{
if
(
Object
.
keys
(
attrs
)
.
every
(
attr
=
>
attrs
[
attr
]
=
=
=
test
[
attr
]
)
)
{
let
urlPrefix
=
{
BASE_URL
}
/
{
test
.
src
}
?
source
=
{
source
}
;
expectedURLs
.
add
(
urlPrefix
)
;
}
}
}
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
channel
topic
data
)
=
>
{
channel
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
url
=
new
URL
(
channel
.
URI
.
spec
)
;
let
origin
=
url
.
searchParams
.
get
(
"
origin
"
)
;
url
.
searchParams
.
delete
(
"
origin
"
)
;
if
(
expectedURLs
.
has
(
url
.
href
)
)
{
expectedURLs
.
delete
(
url
.
href
)
;
equal
(
channel
.
loadInfo
.
triggeringPrincipal
.
origin
origins
[
origin
]
Got
expected
origin
for
URL
{
channel
.
URI
.
spec
}
)
;
if
(
!
expectedURLs
.
size
)
{
Services
.
obs
.
removeObserver
(
observer
"
http
-
on
-
modify
-
request
"
)
;
resolve
(
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
observer
"
http
-
on
-
modify
-
request
"
)
;
}
)
;
}
add_task
(
async
function
test_contentscript_triggeringPrincipals
(
)
{
const
TESTS
=
[
{
element
:
[
"
audio
"
{
}
]
src
:
"
audio
.
webm
"
}
{
element
:
[
"
audio
"
{
}
[
"
source
"
{
}
]
]
src
:
"
audio
-
source
.
webm
"
}
{
element
:
[
"
iframe
"
{
}
]
src
:
"
iframe
.
html
"
}
{
element
:
[
"
img
"
{
}
]
src
:
"
img
.
png
"
}
{
element
:
[
"
img
"
{
}
]
src
:
"
imgset
.
png
"
srcAttr
:
"
srcset
"
}
{
element
:
[
"
script
"
{
}
]
src
:
"
script
.
js
"
liveSrc
:
false
}
{
element
:
[
"
video
"
{
}
]
src
:
"
video
.
webm
"
}
{
element
:
[
"
video
"
{
}
[
"
source
"
{
}
]
]
src
:
"
video
-
source
.
webm
"
}
]
;
const
SOURCES
=
{
"
contentScript
"
:
{
}
"
contentScript
-
attr
-
after
-
inject
"
:
{
liveSrc
:
true
}
"
contentScript
-
content
-
attr
-
after
-
inject
"
:
{
liveSrc
:
true
}
"
contentScript
-
content
-
change
-
after
-
inject
"
:
{
liveSrc
:
true
}
"
contentScript
-
content
-
inject
-
after
-
attr
"
:
{
}
"
contentScript
-
inject
-
after
-
content
-
attr
"
:
{
}
"
contentScript
-
prop
"
:
{
}
"
contentScript
-
prop
-
after
-
inject
"
:
{
}
"
contentScript
-
relative
-
url
"
:
{
}
"
pageHTML
"
:
{
}
"
pageScript
"
:
{
}
"
pageScript
-
attr
-
after
-
inject
"
:
{
}
"
pageScript
-
prop
"
:
{
}
"
pageScript
-
prop
-
after
-
inject
"
:
{
}
"
pageScript
-
relative
-
url
"
:
{
}
}
;
for
(
let
test
of
TESTS
)
{
if
(
!
test
.
srcAttr
)
{
test
.
srcAttr
=
"
src
"
;
}
if
(
!
(
"
liveSrc
"
in
test
)
)
{
test
.
liveSrc
=
true
;
}
}
registerStaticPage
(
"
/
page
.
html
"
<
!
DOCTYPE
html
>
<
html
lang
=
"
en
"
>
<
head
>
<
meta
charset
=
"
UTF
-
8
"
>
<
title
>
<
/
title
>
<
script
>
{
getInjectionScript
(
TESTS
{
source
:
"
pageScript
"
origin
:
"
page
"
}
)
}
<
/
script
>
<
/
head
>
<
body
>
{
TESTS
.
map
(
test
=
>
toHTML
(
test
{
source
:
"
pageHTML
"
origin
:
"
page
"
}
)
)
.
join
(
"
\
n
"
)
}
<
/
body
>
<
/
html
>
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
content_scripts
:
[
{
"
matches
"
:
[
"
http
:
/
/
*
/
page
.
html
"
]
"
run_at
"
:
"
document_start
"
"
js
"
:
[
"
content_script
.
js
"
]
}
]
}
files
:
{
"
content_script
.
js
"
:
getInjectionScript
(
TESTS
{
source
:
"
contentScript
"
origin
:
"
extension
"
}
)
}
}
)
;
await
extension
.
startup
(
)
;
const
pageURL
=
{
BASE_URL
}
/
page
.
html
;
const
pageURI
=
Services
.
io
.
newURI
(
pageURL
)
;
let
origins
=
{
page
:
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
pageURI
{
}
)
.
origin
extension
:
Cu
.
getObjectPrincipal
(
Cu
.
Sandbox
(
[
extension
.
extension
.
principal
pageURL
]
)
)
.
origin
}
;
let
finished
=
awaitLoads
(
TESTS
SOURCES
origins
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
pageURL
)
;
await
finished
;
await
extension
.
unload
(
)
;
await
contentPage
.
close
(
)
;
}
)
;
