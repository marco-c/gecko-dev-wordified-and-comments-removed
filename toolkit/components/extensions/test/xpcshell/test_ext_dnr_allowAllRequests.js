"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
}
)
;
add_setup
(
(
)
=
>
{
Services
.
prefs
.
setBoolPref
(
"
extensions
.
manifestV3
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
dnr
.
enabled
"
true
)
;
}
)
;
const
server
=
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
"
example
.
net
"
"
example
.
org
"
]
}
)
;
server
.
registerPathHandler
(
"
/
never_reached
"
(
req
res
)
=
>
{
Assert
.
ok
(
false
"
Server
should
never
have
been
reached
"
)
;
}
)
;
server
.
registerPathHandler
(
"
/
allowed
"
(
req
res
)
=
>
{
res
.
setHeader
(
"
Access
-
Control
-
Allow
-
Origin
"
"
*
"
)
;
res
.
setHeader
(
"
Access
-
Control
-
Max
-
Age
"
"
0
"
)
;
res
.
write
(
"
fetchAllowed
"
)
;
}
)
;
server
.
registerPathHandler
(
"
/
"
(
req
res
)
=
>
{
res
.
write
(
"
Dummy
page
"
)
;
}
)
;
server
.
registerPathHandler
(
"
/
echo_html
"
(
req
res
)
=
>
{
let
code
=
decodeURIComponent
(
req
.
queryString
)
;
res
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
;
charset
=
utf
-
8
"
)
;
if
(
req
.
hasHeader
(
"
prependhtml
"
)
)
{
code
=
req
.
getHeader
(
"
prependhtml
"
)
+
code
;
}
res
.
write
(
<
!
DOCTYPE
html
>
{
code
}
)
;
}
)
;
server
.
registerPathHandler
(
"
/
bfcache_test
"
(
req
res
)
=
>
{
res
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
;
charset
=
utf
-
8
"
)
;
res
.
write
(
<
body
>
<
script
>
/
/
false
at
initial
load
true
when
loaded
from
bfcache
.
onpageshow
=
e
=
>
document
.
body
.
textContent
=
e
.
persisted
;
<
/
script
>
)
;
}
)
;
async
function
waitForRequestAtServer
(
path
)
{
return
new
Promise
(
resolve
=
>
{
let
callCount
=
0
;
server
.
registerPathHandler
(
path
(
req
res
)
=
>
{
Assert
.
equal
(
+
+
callCount
1
Got
one
request
for
:
{
path
}
)
;
res
.
processAsync
(
)
;
resolve
(
{
req
res
}
)
;
}
)
;
}
)
;
}
const
FETCH_BLOCKED
=
"
TypeError
:
NetworkError
when
attempting
to
fetch
resource
.
"
;
function
urlEchoHtml
(
domain
html
)
{
return
http
:
/
/
{
domain
}
/
echo_html
?
{
encodeURIComponent
(
html
)
}
;
}
function
htmlEscape
(
html
)
{
return
html
.
replaceAll
(
"
&
"
"
&
amp
;
"
)
.
replaceAll
(
'
"
'
"
&
quot
;
"
)
.
replaceAll
(
"
'
"
"
&
#
39
;
"
)
.
replaceAll
(
"
<
"
"
&
lt
;
"
)
.
replaceAll
(
"
>
"
"
&
gt
;
"
)
;
}
const
ABOUT_SRCDOC_SAME_ORIGIN
=
"
about
:
srcdoc
(
same
-
origin
)
"
;
const
ABOUT_SRCDOC_CROSS_ORIGIN
=
"
about
:
srcdoc
(
cross
-
origin
)
"
;
async
function
testLoadInFrame
(
{
description
domains
=
[
"
example
.
com
"
]
htmlPrependedToEachFrame
=
"
"
jsForFrame
expectedResult
expectedError
}
)
{
const
frameJs
=
async
jsForFrame
=
>
{
let
result
=
{
}
;
try
{
result
.
returnValue
=
await
jsForFrame
(
)
;
}
catch
(
e
)
{
result
.
error
=
String
(
e
)
;
}
if
(
result
.
returnValue
!
=
=
"
delay_postMessage
"
)
{
top
.
postMessage
(
result
"
*
"
)
;
}
}
;
const
frameHtml
=
<
body
>
<
script
>
(
{
frameJs
}
)
(
{
jsForFrame
}
)
<
/
script
>
;
const
[
mainFrameDomain
.
.
.
subFramesDomains
]
=
domains
;
subFramesDomains
.
reverse
(
)
;
let
html
=
frameHtml
;
for
(
let
domain
of
subFramesDomains
)
{
html
=
htmlPrependedToEachFrame
+
html
;
if
(
domain
=
=
=
ABOUT_SRCDOC_SAME_ORIGIN
)
{
html
=
<
iframe
srcdoc
=
"
{
htmlEscape
(
html
)
}
"
>
<
/
iframe
>
;
}
else
if
(
domain
=
=
=
ABOUT_SRCDOC_CROSS_ORIGIN
)
{
html
=
<
iframe
srcdoc
=
"
{
htmlEscape
(
html
)
}
"
sandbox
=
"
allow
-
scripts
"
>
<
/
iframe
>
;
}
else
{
html
=
<
iframe
src
=
"
{
urlEchoHtml
(
domain
html
)
}
"
>
<
/
iframe
>
;
}
}
const
mainFrameJs
=
(
)
=
>
{
window
.
resultPromise
=
new
Promise
(
resolve
=
>
{
window
.
onmessage
=
e
=
>
resolve
(
e
.
data
)
;
}
)
;
}
;
const
mainFrameHtml
=
<
script
>
(
{
mainFrameJs
}
)
(
)
<
/
script
>
{
html
}
;
const
mainFrameUrl
=
urlEchoHtml
(
mainFrameDomain
mainFrameHtml
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
mainFrameUrl
)
;
let
result
=
await
contentPage
.
spawn
(
[
]
(
)
=
>
{
return
content
.
wrappedJSObject
.
resultPromise
;
}
)
;
await
contentPage
.
close
(
)
;
if
(
expectedError
)
{
Assert
.
deepEqual
(
result
{
error
:
expectedError
}
description
)
;
}
else
{
Assert
.
deepEqual
(
result
{
returnValue
:
expectedResult
}
description
)
;
}
}
async
function
loadExtensionWithDNRRules
(
rules
{
host_permissions
=
[
]
permissions
=
[
"
declarativeNetRequest
"
]
}
=
{
}
)
{
async
function
background
(
rules
)
{
try
{
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
rules
}
)
;
}
catch
(
e
)
{
browser
.
test
.
fail
(
Failed
to
register
DNR
rules
:
{
e
}
:
:
{
e
.
stack
}
)
;
}
browser
.
test
.
sendMessage
(
"
dnr_registered
"
)
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
:
(
{
background
}
)
(
{
JSON
.
stringify
(
rules
)
}
)
temporarilyInstalled
:
true
manifest
:
{
manifest_version
:
3
granted_host_permissions
:
true
host_permissions
permissions
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
dnr_registered
"
)
;
return
extension
;
}
add_task
(
async
function
allowAllRequests_allows_request
(
)
{
let
extension
=
await
loadExtensionWithDNRRules
(
[
{
id
:
1
condition
:
{
resourceTypes
:
[
"
main_frame
"
"
xmlhttprequest
"
]
}
action
:
{
type
:
"
block
"
}
}
{
id
:
2
condition
:
{
resourceTypes
:
[
"
main_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
{
id
:
3
priority
:
2
condition
:
{
requestDomains
:
[
"
example
.
com
"
]
}
action
:
{
type
:
"
block
"
}
}
]
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
http
:
/
/
example
.
com
/
"
)
;
Assert
.
equal
(
await
contentPage
.
spawn
(
[
]
(
)
=
>
content
.
document
.
URL
)
"
http
:
/
/
example
.
com
/
"
"
main_frame
request
should
have
been
allowed
by
allowAllRequests
"
)
;
async
function
checkCanFetch
(
url
)
{
return
contentPage
.
spawn
(
[
url
]
async
url
=
>
{
try
{
return
await
(
await
content
.
fetch
(
url
)
)
.
text
(
)
;
}
catch
(
e
)
{
return
e
.
toString
(
)
;
}
}
)
;
}
Assert
.
equal
(
await
checkCanFetch
(
"
http
:
/
/
example
.
com
/
never_reached
"
)
FETCH_BLOCKED
"
should
be
blocked
by
DNR
rule
3
"
)
;
Assert
.
equal
(
await
checkCanFetch
(
"
http
:
/
/
example
.
net
/
allowed
"
)
"
fetchAllowed
"
"
should
not
be
blocked
by
block
rule
due
to
allowAllRequests
rule
"
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
allowAllRequests_in_sub_frame
(
)
{
const
extension
=
await
loadExtensionWithDNRRules
(
[
{
id
:
1
condition
:
{
resourceTypes
:
[
"
xmlhttprequest
"
]
}
action
:
{
type
:
"
block
"
}
}
{
id
:
2
condition
:
{
requestDomains
:
[
"
example
.
com
"
]
resourceTypes
:
[
"
main_frame
"
"
sub_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
]
)
;
const
testFetch
=
async
(
)
=
>
{
return
(
await
fetch
(
"
http
:
/
/
example
.
com
/
allowed
"
)
)
.
text
(
)
;
}
;
await
testLoadInFrame
(
{
description
:
"
allowAllRequests
was
not
matched
anywhere
req
in
subframe
"
domains
:
[
"
example
.
net
"
"
example
.
org
"
]
jsForFrame
:
testFetch
expectedError
:
FETCH_BLOCKED
}
)
;
await
testLoadInFrame
(
{
description
:
"
allowAllRequests
for
main
frame
req
in
main
frame
"
domains
:
[
"
example
.
com
"
]
jsForFrame
:
testFetch
expectedResult
:
"
fetchAllowed
"
}
)
;
await
testLoadInFrame
(
{
description
:
"
allowAllRequests
for
main
frame
req
in
same
-
origin
frame
"
domains
:
[
"
example
.
com
"
"
example
.
com
"
]
jsForFrame
:
testFetch
expectedResult
:
"
fetchAllowed
"
}
)
;
await
testLoadInFrame
(
{
description
:
"
allowAllRequests
for
main
frame
req
in
cross
-
origin
frame
"
domains
:
[
"
example
.
com
"
"
example
.
net
"
]
jsForFrame
:
testFetch
expectedResult
:
"
fetchAllowed
"
}
)
;
await
testLoadInFrame
(
{
description
:
"
allowAllRequests
for
subframe
req
in
same
subframe
"
domains
:
[
"
example
.
net
"
"
example
.
com
"
]
jsForFrame
:
testFetch
expectedResult
:
"
fetchAllowed
"
}
)
;
await
testLoadInFrame
(
{
description
:
"
allowAllRequests
for
subframe
req
in
same
-
origin
subframe
"
domains
:
[
"
example
.
net
"
"
example
.
com
"
"
example
.
com
"
]
jsForFrame
:
testFetch
expectedResult
:
"
fetchAllowed
"
}
)
;
await
testLoadInFrame
(
{
description
:
"
allowAllRequests
for
subframe
req
in
cross
-
origin
subframe
"
domains
:
[
"
example
.
net
"
"
example
.
com
"
"
example
.
org
"
]
jsForFrame
:
testFetch
expectedResult
:
"
fetchAllowed
"
}
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
allowAllRequests_does_not_affect_other_extension
(
)
{
const
extension
=
await
loadExtensionWithDNRRules
(
[
{
id
:
1
condition
:
{
resourceTypes
:
[
"
xmlhttprequest
"
]
}
action
:
{
type
:
"
block
"
}
}
]
)
;
const
otherExtension
=
await
loadExtensionWithDNRRules
(
[
{
id
:
2
condition
:
{
resourceTypes
:
[
"
main_frame
"
"
sub_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
]
)
;
const
testFetch
=
async
(
)
=
>
{
return
(
await
fetch
(
"
http
:
/
/
example
.
com
/
allowed
"
)
)
.
text
(
)
;
}
;
await
testLoadInFrame
(
{
description
:
"
block
rule
from
extension
not
superseded
by
otherExtension
"
domains
:
[
"
example
.
net
"
"
example
.
org
"
]
jsForFrame
:
testFetch
expectedError
:
FETCH_BLOCKED
}
)
;
await
extension
.
unload
(
)
;
await
otherExtension
.
unload
(
)
;
}
)
;
add_task
(
async
function
allowAllRequests_multiple_frames_and_modifyHeaders
(
)
{
const
domains
=
[
"
example
.
com
"
"
example
.
com
"
"
example
.
net
"
"
example
.
org
"
]
;
const
rules
=
[
{
id
:
1
priority
:
3
condition
:
{
requestDomains
:
[
domains
[
1
]
]
resourceTypes
:
[
"
sub_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
{
id
:
2
priority
:
7
condition
:
{
requestDomains
:
[
domains
[
2
]
]
resourceTypes
:
[
"
sub_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
{
id
:
3
priority
:
5
condition
:
{
requestDomains
:
[
domains
[
3
]
]
resourceTypes
:
[
"
sub_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
]
;
for
(
let
i
=
1
;
i
<
=
9
;
+
+
i
)
{
rules
.
push
(
{
id
:
10
+
i
priority
:
i
condition
:
{
resourceTypes
:
[
"
xmlhttprequest
"
]
}
action
:
{
type
:
"
modifyHeaders
"
responseHeaders
:
[
{
operation
:
"
set
"
header
:
"
Access
-
Control
-
Expose
-
Headers
"
value
:
"
addedByDnr
"
}
{
operation
:
"
append
"
header
:
"
addedByDnr
"
value
:
{
i
}
}
]
}
}
)
;
}
const
extension
=
await
loadExtensionWithDNRRules
(
rules
{
host_permissions
:
[
"
<
all_urls
>
"
]
}
)
;
await
testLoadInFrame
(
{
description
:
"
Should
select
highest
-
prio
allowAllRequests
among
ancestors
"
domains
jsForFrame
:
async
(
)
=
>
{
let
res
=
await
fetch
(
"
http
:
/
/
example
.
com
/
allowed
"
)
;
return
res
.
headers
.
get
(
"
addedByDnr
"
)
;
}
expectedResult
:
"
9
8
"
}
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
allowAllRequests_initiatorDomains
(
)
{
const
rules
=
[
{
id
:
1
condition
:
{
initiatorDomains
:
[
"
example
.
com
"
]
resourceTypes
:
[
"
main_frame
"
"
sub_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
{
id
:
2
condition
:
{
initiatorDomains
:
[
"
example
.
net
"
]
resourceTypes
:
[
"
sub_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
{
id
:
3
condition
:
{
resourceTypes
:
[
"
xmlhttprequest
"
]
}
action
:
{
type
:
"
block
"
}
}
]
;
const
extension
=
await
loadExtensionWithDNRRules
(
rules
{
host_permissions
:
[
"
*
:
/
/
example
.
com
/
*
"
"
*
:
/
/
example
.
org
/
*
"
]
}
)
;
const
testCanFetch
=
async
(
)
=
>
{
return
(
await
fetch
(
"
http
:
/
/
example
.
com
/
allowed
"
)
)
.
text
(
)
;
}
;
await
testLoadInFrame
(
{
description
:
"
main_frame
request
does
not
have
an
initiator
"
domains
:
[
"
example
.
com
"
]
jsForFrame
:
testCanFetch
expectedError
:
FETCH_BLOCKED
}
)
;
await
testLoadInFrame
(
{
description
:
"
sub_frame
loaded
by
initiator
in
host_permissions
"
domains
:
[
"
example
.
com
"
"
example
.
org
"
]
jsForFrame
:
testCanFetch
expectedResult
:
"
fetchAllowed
"
}
)
;
await
testLoadInFrame
(
{
description
:
"
sub_frame
loaded
by
initiator
not
in
host_permissions
"
domains
:
[
"
example
.
net
"
"
example
.
org
"
]
jsForFrame
:
testCanFetch
expectedResult
:
"
fetchAllowed
"
}
)
;
await
testLoadInFrame
(
{
description
:
"
about
:
srcdoc
with
matching
initiator
"
domains
:
[
"
example
.
com
"
ABOUT_SRCDOC_SAME_ORIGIN
]
jsForFrame
:
testCanFetch
expectedError
:
FETCH_BLOCKED
}
)
;
await
testLoadInFrame
(
{
description
:
"
subframe
in
about
:
srcdoc
with
matching
initiator
"
domains
:
[
"
example
.
com
"
ABOUT_SRCDOC_SAME_ORIGIN
"
example
.
org
"
]
jsForFrame
:
testCanFetch
expectedResult
:
"
fetchAllowed
"
}
)
;
await
testLoadInFrame
(
{
description
:
"
subframe
in
opaque
about
:
srcdoc
despite
matching
initiator
"
domains
:
[
"
example
.
com
"
ABOUT_SRCDOC_CROSS_ORIGIN
"
example
.
org
"
]
jsForFrame
:
testCanFetch
expectedError
:
FETCH_BLOCKED
}
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
allowAllRequests_initiatorDomains_dnrWithHostAccess
(
)
{
const
rules
=
[
{
id
:
1
condition
:
{
initiatorDomains
:
[
"
example
.
net
"
]
resourceTypes
:
[
"
sub_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
{
id
:
2
condition
:
{
resourceTypes
:
[
"
xmlhttprequest
"
]
}
action
:
{
type
:
"
block
"
}
}
]
;
const
extension
=
await
loadExtensionWithDNRRules
(
rules
{
host_permissions
:
[
"
*
:
/
/
example
.
org
/
*
"
]
permissions
:
[
"
declarativeNetRequestWithHostAccess
"
]
}
)
;
const
testCanFetch
=
async
(
)
=
>
{
return
(
await
fetch
(
"
http
:
/
/
example
.
org
/
allowed
"
)
)
.
text
(
)
;
}
;
await
testLoadInFrame
(
{
description
:
"
frame
URL
in
host_permissions
despite
initiator
not
in
host_permissions
"
domains
:
[
"
example
.
com
"
"
example
.
net
"
"
example
.
org
"
]
jsForFrame
:
testCanFetch
expectedResult
:
"
fetchAllowed
"
}
)
;
await
testLoadInFrame
(
{
description
:
"
frame
URL
and
initiator
not
in
host_permissions
"
domains
:
[
"
example
.
net
"
"
example
.
com
"
"
example
.
org
"
]
jsForFrame
:
testCanFetch
expectedError
:
FETCH_BLOCKED
}
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
allowAllRequests_initiator_is_parent
(
)
{
const
domains
=
[
"
example
.
com
"
"
example
.
net
"
"
example
.
org
"
"
example
.
com
"
]
;
const
rules
=
[
{
id
:
1
condition
:
{
initiatorDomains
:
[
"
example
.
org
"
]
requestDomains
:
[
"
example
.
com
"
]
resourceTypes
:
[
"
sub_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
{
id
:
2
condition
:
{
resourceTypes
:
[
"
xmlhttprequest
"
]
}
action
:
{
type
:
"
block
"
}
}
{
id
:
3
priority
:
2
condition
:
{
initiatorDomains
:
[
"
example
.
org
"
]
requestDomains
:
[
"
example
.
com
"
]
resourceTypes
:
[
"
sub_frame
"
]
}
action
:
{
type
:
"
modifyHeaders
"
requestHeaders
:
[
{
operation
:
"
append
"
header
:
"
prependhtml
"
value
:
"
<
title
>
DNR
rule
3
for
initiator
example
.
org
<
/
title
>
"
}
]
}
}
{
id
:
4
condition
:
{
initiatorDomains
:
[
"
example
.
net
"
]
requestDomains
:
[
"
example
.
com
"
]
resourceTypes
:
[
"
sub_frame
"
]
}
action
:
{
type
:
"
modifyHeaders
"
requestHeaders
:
[
{
operation
:
"
append
"
header
:
"
prependhtml
"
value
:
"
<
title
>
DNR
rule
4
for
initiator
example
.
net
<
/
title
>
"
}
]
}
}
]
;
const
extension
=
await
loadExtensionWithDNRRules
(
rules
{
host_permissions
:
[
"
<
all_urls
>
"
]
}
)
;
const
jsNavigateOnMessage
=
(
)
=
>
{
window
.
onmessage
=
e
=
>
{
dump
(
\
nReceived
message
at
{
origin
}
from
{
e
.
origin
}
:
{
e
.
data
}
\
n
)
;
e
.
source
.
location
=
e
.
data
;
}
;
}
;
const
htmlNavigateOnMessage
=
<
script
>
(
{
jsNavigateOnMessage
}
)
(
)
<
/
script
>
;
await
testLoadInFrame
(
{
description
:
"
Sanity
check
:
navigation
matches
actual
initiator
(
parent
)
"
domains
jsForFrame
:
(
)
=
>
document
.
title
expectedResult
:
"
DNR
rule
3
for
initiator
example
.
org
"
}
)
;
await
testLoadInFrame
(
{
description
:
"
Sanity
check
:
navigation
matches
actual
initiator
(
ancestor
)
"
domains
htmlPrependedToEachFrame
:
htmlNavigateOnMessage
jsForFrame
:
(
)
=
>
{
if
(
location
.
hash
!
=
=
"
#
End
"
)
{
dump
(
"
Sanity
:
Trying
to
navigate
with
initiator
set
to
example
.
net
\
n
"
)
;
parent
.
parent
.
postMessage
(
document
.
URL
+
"
.
#
End
"
"
http
:
/
/
example
.
net
"
)
;
return
"
delay_postMessage
"
;
}
return
document
.
title
;
}
expectedResult
:
"
DNR
rule
4
for
initiator
example
.
net
"
}
)
;
await
testLoadInFrame
(
{
description
:
"
allowAllRequests
matches
parent
(
which
is
the
initiator
)
"
domains
jsForFrame
:
async
(
)
=
>
{
return
(
await
fetch
(
"
http
:
/
/
example
.
com
/
allowed
"
)
)
.
text
(
)
;
}
expectedResult
:
"
fetchAllowed
"
}
)
;
await
testLoadInFrame
(
{
description
:
"
allowAllRequests
matches
parent
(
not
actual
initiator
)
"
domains
htmlPrependedToEachFrame
:
htmlNavigateOnMessage
jsForFrame
:
async
(
)
=
>
{
if
(
location
.
hash
!
=
=
"
#
End
"
)
{
dump
(
"
Final
:
Trying
to
navigate
with
initiator
set
to
example
.
net
\
n
"
)
;
parent
.
parent
.
postMessage
(
document
.
URL
+
"
.
#
End
"
"
http
:
/
/
example
.
net
"
)
;
return
"
delay_postMessage
"
;
}
return
(
await
fetch
(
"
http
:
/
/
example
.
com
/
allowed
"
)
)
.
text
(
)
;
}
expectedResult
:
"
fetchAllowed
"
}
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
allowAllRequests_initiatorDomains_content_script
(
)
{
const
rules
=
[
{
id
:
1
condition
:
{
initiatorDomains
:
[
"
example
.
com
"
]
resourceTypes
:
[
"
sub_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
{
id
:
2
condition
:
{
resourceTypes
:
[
"
xmlhttprequest
"
]
}
action
:
{
type
:
"
block
"
}
}
{
id
:
3
condition
:
{
resourceTypes
:
[
"
sub_frame
"
]
requestDomains
:
[
"
example
.
com
"
]
}
action
:
{
type
:
"
redirect
"
redirect
:
{
transform
:
{
host
:
"
example
.
net
"
}
}
}
}
]
;
const
extension
=
await
loadExtensionWithDNRRules
(
rules
{
host_permissions
:
[
"
*
:
/
/
example
.
com
/
*
"
"
*
:
/
/
example
.
net
/
*
"
]
}
)
;
let
contentScriptExtension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
manifest_version
:
2
content_scripts
:
[
{
run_at
:
"
document_end
"
js
:
[
"
contentscript_load_frame
.
js
"
]
matches
:
[
"
http
:
/
/
*
/
?
test_contentscript_load_frame
"
]
}
{
all_frames
:
true
run_at
:
"
document_end
"
js
:
[
"
contentscript_in_iframe
.
js
"
]
matches
:
[
"
http
:
/
/
example
.
net
/
?
test_contentscript_triggered_frame
"
]
}
]
}
files
:
{
"
contentscript_load_frame
.
js
"
:
(
)
=
>
{
browser
.
test
.
log
(
"
Waiting
for
frame
then
contentscript_in_iframe
.
js
"
)
;
let
f
=
document
.
createElement
(
"
iframe
"
)
;
f
.
src
=
"
http
:
/
/
example
.
com
/
?
test_contentscript_triggered_frame
"
;
document
.
body
.
append
(
f
)
;
}
"
contentscript_in_iframe
.
js
"
:
async
(
)
=
>
{
browser
.
test
.
assertEq
(
"
example
.
net
"
location
.
host
"
redirect
rule
matched
because
initiator
is
void
for
content
-
script
-
triggered
navigation
"
)
;
async
function
isFetchOk
(
fetchPromise
)
{
try
{
await
fetchPromise
;
return
true
;
}
catch
(
e
)
{
await
browser
.
test
.
assertRejects
(
fetchPromise
/
NetworkError
/
)
;
return
false
;
}
}
browser
.
test
.
assertTrue
(
await
isFetchOk
(
content
.
fetch
(
"
http
:
/
/
example
.
net
/
allowed
"
)
)
"
frame
'
s
parent
origin
matches
initiatorDomains
(
content
script
fetch
)
"
)
;
browser
.
test
.
assertFalse
(
await
isFetchOk
(
fetch
(
"
http
:
/
/
example
.
net
/
allowed
"
)
)
"
MV2
content
script
fetch
(
)
is
not
associated
with
the
document
"
)
;
browser
.
test
.
sendMessage
(
"
contentscript_initiator
"
)
;
}
}
}
)
;
await
contentScriptExtension
.
startup
(
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
http
:
/
/
example
.
com
/
?
test_contentscript_load_frame
"
)
;
info
(
"
Waiting
for
page
load
will
continue
at
contentscript_load_frame
.
js
"
)
;
await
contentScriptExtension
.
awaitMessage
(
"
contentscript_initiator
"
)
;
await
contentScriptExtension
.
unload
(
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
allowAllRequests_during_and_after_navigation
(
)
{
let
extension
=
await
loadExtensionWithDNRRules
(
[
{
id
:
1
condition
:
{
resourceTypes
:
[
"
xmlhttprequest
"
]
}
action
:
{
type
:
"
block
"
}
}
{
id
:
2
condition
:
{
urlFilter
:
"
WITH_AAR
"
resourceTypes
:
[
"
sub_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
]
)
;
const
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
http
:
/
/
example
.
com
/
?
dummy_see_iframe_for_interesting_stuff
"
)
;
await
contentPage
.
spawn
(
[
]
async
(
)
=
>
{
let
f
=
content
.
document
.
createElement
(
"
iframe
"
)
;
f
.
id
=
"
frame_to_navigate
"
;
f
.
src
=
"
/
?
init_WITH_AAR
"
;
await
new
Promise
(
resolve
=
>
{
f
.
onload
=
resolve
;
content
.
document
.
body
.
append
(
f
)
;
}
)
;
}
)
;
async
function
navigateIframe
(
url
)
{
await
contentPage
.
spawn
(
[
url
]
url
=
>
{
let
f
=
content
.
document
.
getElementById
(
"
frame_to_navigate
"
)
;
content
.
frameLoadedPromise
=
new
Promise
(
resolve
=
>
{
f
.
addEventListener
(
"
load
"
resolve
{
once
:
true
}
)
;
}
)
;
f
.
contentWindow
.
location
.
href
=
url
;
}
)
;
}
async
function
waitForNavigationCompleted
(
expectLoad
=
true
)
{
await
contentPage
.
spawn
(
[
expectLoad
]
async
expectLoad
=
>
{
if
(
expectLoad
)
{
info
(
"
Waiting
for
frame
load
-
if
stuck
the
load
never
happened
\
n
"
)
;
return
content
.
frameLoadedPromise
.
then
(
(
)
=
>
{
}
)
;
}
let
f
=
content
.
document
.
createElement
(
"
iframe
"
)
;
f
.
src
=
"
/
?
dummy_no_dnr_matched_
"
+
Math
.
random
(
)
;
await
new
Promise
(
resolve
=
>
{
f
.
onload
=
resolve
;
content
.
document
.
body
.
append
(
f
)
;
}
)
;
f
.
remove
(
)
;
}
)
;
}
async
function
assertIframePath
(
expectedPath
description
)
{
let
actualPath
=
await
contentPage
.
spawn
(
[
]
(
)
=
>
{
return
content
.
frames
[
0
]
.
location
.
pathname
;
}
)
;
Assert
.
equal
(
actualPath
expectedPath
description
)
;
}
async
function
assertHasAAR
(
expected
description
)
{
let
actual
=
await
contentPage
.
spawn
(
[
]
async
(
)
=
>
{
try
{
await
(
await
content
.
frames
[
0
]
.
fetch
(
"
/
allowed
"
)
)
.
text
(
)
;
return
true
;
}
catch
(
e
)
{
Assert
.
equal
(
e
.
toString
(
)
"
TypeError
:
NetworkError
when
attempting
to
fetch
resource
.
"
"
Got
error
for
failed
fetch
"
)
;
return
false
;
}
}
)
;
Assert
.
equal
(
actual
expected
description
)
;
}
await
assertHasAAR
(
true
"
Initial
allowAllRequests
overrides
block
rule
"
)
;
const
PATH_1_NO_AAR
=
"
/
delayed
/
PATH_1_NO_AAR
"
;
const
PATH_2_WITH_AAR
=
"
/
delayed
/
PATH_2_WITH_AAR
"
;
const
PATH_3_NO_AAR
=
"
/
delayed
/
PATH_3_NO_AAR
"
;
info
(
"
First
:
transition
from
/
?
init_WITH_AAR
to
PATH_NOT_MATCHED_BY_DNR
.
"
)
;
{
let
promisedServerReq
=
waitForRequestAtServer
(
PATH_1_NO_AAR
)
;
await
navigateIframe
(
PATH_1_NO_AAR
)
;
let
serverReq
=
await
promisedServerReq
;
await
assertHasAAR
(
true
"
Initial
allowAllRequests
still
applies
despite
pending
navigation
"
)
;
await
assertIframePath
(
"
/
"
"
Frame
has
not
navigated
yet
"
)
;
serverReq
.
res
.
finish
(
)
;
await
waitForNavigationCompleted
(
)
;
await
assertIframePath
(
PATH_1_NO_AAR
"
Navigated
to
PATH_1_NO_AAR
"
)
;
await
assertHasAAR
(
false
"
Old
allowAllRequests
should
no
longer
apply
after
navigation
to
PATH_1_NO_AAR
"
)
;
}
info
(
"
Second
:
transition
from
PATH_1_NO_AAR
to
PATH_2_WITH_AAR
.
"
)
;
{
let
promisedServerReq
=
waitForRequestAtServer
(
PATH_2_WITH_AAR
)
;
await
navigateIframe
(
PATH_2_WITH_AAR
)
;
let
serverReq
=
await
promisedServerReq
;
await
assertHasAAR
(
false
"
No
allowAllRequests
yet
despite
pending
navigation
to
PATH_2_WITH_AAR
"
)
;
await
assertIframePath
(
PATH_1_NO_AAR
"
Frame
has
not
navigated
yet
"
)
;
serverReq
.
res
.
finish
(
)
;
await
waitForNavigationCompleted
(
)
;
await
assertIframePath
(
PATH_2_WITH_AAR
"
Navigated
to
PATH_2_WITH_AAR
"
)
;
await
assertHasAAR
(
true
"
allowAllRequests
should
apply
after
navigation
to
PATH_2_WITH_AAR
"
)
;
}
info
(
"
Third
:
AAR
still
applies
after
canceling
navigation
to
PATH_3_NO_AAR
.
"
)
;
{
let
promisedServerReq
=
waitForRequestAtServer
(
PATH_3_NO_AAR
)
;
await
navigateIframe
(
PATH_3_NO_AAR
)
;
let
serverReq
=
await
promisedServerReq
;
serverReq
.
res
.
setStatusLine
(
serverReq
.
req
.
httpVersion
204
"
No
Content
"
)
;
serverReq
.
res
.
finish
(
)
;
await
waitForNavigationCompleted
(
false
)
;
await
assertIframePath
(
PATH_2_WITH_AAR
"
HTTP
204
does
not
navigate
away
"
)
;
await
assertHasAAR
(
true
"
allowAllRequests
still
applied
after
aborted
navigation
to
PATH_3_NO_AAR
"
)
;
}
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
{
pref_set
:
[
[
"
browser
.
sessionhistory
.
max_total_viewers
"
3
]
]
}
async
function
allowAllRequests_and_bfcache_navigation
(
)
{
let
extension
=
await
loadExtensionWithDNRRules
(
[
{
id
:
1
condition
:
{
resourceTypes
:
[
"
xmlhttprequest
"
]
}
action
:
{
type
:
"
block
"
}
}
{
id
:
2
condition
:
{
urlFilter
:
"
aar_yes
"
resourceTypes
:
[
"
main_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
]
)
;
info
(
"
Navigating
to
initial
URL
:
1_aar_no
"
)
;
const
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
http
:
/
/
example
.
com
/
bfcache_test
?
1_aar_no
"
)
;
async
function
navigateBackInHistory
(
expectedUrl
)
{
await
contentPage
.
spawn
(
[
]
(
)
=
>
{
content
.
history
.
back
(
)
;
}
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
contentPage
.
browsingContext
.
currentURI
.
spec
=
=
=
expectedUrl
Waiting
for
history
.
back
(
)
to
trigger
navigation
to
{
expectedUrl
}
)
;
await
contentPage
.
spawn
(
[
expectedUrl
]
async
expectedUrl
=
>
{
Assert
.
equal
(
content
.
location
.
href
expectedUrl
"
URL
after
back
"
)
;
Assert
.
equal
(
content
.
document
.
body
.
textContent
"
true
"
"
from
bfcache
"
)
;
}
)
;
}
async
function
checkCanFetch
(
url
)
{
return
contentPage
.
spawn
(
[
url
]
async
url
=
>
{
try
{
return
await
(
await
content
.
fetch
(
url
)
)
.
text
(
)
;
}
catch
(
e
)
{
return
e
.
toString
(
)
;
}
}
)
;
}
info
(
"
Navigating
from
initial
URL
to
:
2_aar_yes
"
)
;
await
contentPage
.
loadURL
(
"
http
:
/
/
example
.
com
/
bfcache_test
?
2_aar_yes
"
)
;
info
(
"
Navigating
from
2_aar_yes
to
:
3_aar_no
"
)
;
await
contentPage
.
loadURL
(
"
http
:
/
/
example
.
com
/
bfcache_test
?
3_aar_no
"
)
;
info
(
"
Going
back
in
history
(
from
3_aar_no
to
2_aar_yes
)
"
)
;
await
navigateBackInHistory
(
"
http
:
/
/
example
.
com
/
bfcache_test
?
2_aar_yes
"
)
;
Assert
.
equal
(
await
checkCanFetch
(
"
http
:
/
/
example
.
com
/
allowed
"
)
"
fetchAllowed
"
"
after
history
.
back
(
)
allowAllRequests
should
apply
from
2_aar_yes
"
)
;
info
(
"
Going
back
in
history
(
from
2_aar_yes
to
1_aar_no
)
"
)
;
await
navigateBackInHistory
(
"
http
:
/
/
example
.
com
/
bfcache_test
?
1_aar_no
"
)
;
Assert
.
equal
(
await
checkCanFetch
(
"
http
:
/
/
example
.
net
/
never_reached
"
)
FETCH_BLOCKED
"
after
history
.
back
(
)
no
allowAllRequests
action
applied
at
1_aar_no
"
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
{
pref_set
:
[
[
"
dom
.
confirm_repost
.
testing
.
always_accept
"
true
]
]
}
async
function
allowAllRequests_navigate_with_http_method_POST
(
)
{
const
rules
=
[
{
id
:
1
condition
:
{
requestMethods
:
[
"
post
"
]
resourceTypes
:
[
"
main_frame
"
"
sub_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
{
id
:
2
condition
:
{
resourceTypes
:
[
"
xmlhttprequest
"
]
}
action
:
{
type
:
"
block
"
}
}
]
;
if
(
!
Services
.
appinfo
.
sessionHistoryInParent
)
{
rules
[
0
]
.
condition
.
requestMethods
=
[
"
get
"
]
;
rules
[
0
]
.
condition
.
urlFilter
=
"
do_post
|
"
;
info
(
WARNING
:
SHIP
is
disabled
.
POST
will
be
misinterpreted
as
GET
)
;
}
const
extension
=
await
loadExtensionWithDNRRules
(
rules
)
;
const
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
http
:
/
/
example
.
com
/
?
do_get
"
)
;
async
function
checkCanFetch
(
url
)
{
return
contentPage
.
spawn
(
[
url
]
async
url
=
>
{
try
{
return
await
(
await
content
.
fetch
(
url
)
)
.
text
(
)
;
}
catch
(
e
)
{
return
e
.
toString
(
)
;
}
}
)
;
}
Assert
.
equal
(
await
checkCanFetch
(
"
http
:
/
/
example
.
net
/
never_reached
"
)
FETCH_BLOCKED
"
main_frame
:
non
-
POST
not
matched
by
requestMethods
:
[
'
post
'
]
"
)
;
await
contentPage
.
spawn
(
[
]
(
)
=
>
{
let
form
=
content
.
document
.
createElement
(
"
form
"
)
;
form
.
action
=
"
/
?
do_post
"
;
form
.
method
=
"
POST
"
;
content
.
document
.
body
.
append
(
form
)
;
form
.
submit
(
)
;
}
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
contentPage
.
browsingContext
.
currentURI
.
pathQueryRef
=
=
=
"
/
?
do_post
"
"
Waiting
for
navigation
with
POST
to
complete
"
)
;
Assert
.
equal
(
await
checkCanFetch
(
"
http
:
/
/
example
.
net
/
allowed
"
)
"
fetchAllowed
"
"
main_frame
:
requestMethods
:
[
'
post
'
]
applies
to
POST
"
)
;
await
contentPage
.
spawn
(
[
]
(
)
=
>
{
content
.
history
.
back
(
)
;
}
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
contentPage
.
browsingContext
.
currentURI
.
pathQueryRef
=
=
=
"
/
?
do_get
"
"
Waiting
for
(
back
)
navigation
to
initial
GET
page
to
complete
"
)
;
Assert
.
equal
(
await
checkCanFetch
(
"
http
:
/
/
example
.
net
/
never_reached
"
)
FETCH_BLOCKED
"
main_frame
:
back
to
non
-
POST
not
matched
by
requestMethods
:
[
'
post
'
]
"
)
;
await
contentPage
.
spawn
(
[
]
(
)
=
>
{
content
.
history
.
forward
(
)
;
}
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
contentPage
.
browsingContext
.
currentURI
.
pathQueryRef
=
=
=
"
/
?
do_post
"
"
Waiting
for
(
forward
)
navigation
to
POST
page
to
complete
"
)
;
Assert
.
equal
(
await
checkCanFetch
(
"
http
:
/
/
example
.
net
/
allowed
"
)
"
fetchAllowed
"
"
main_frame
:
requestMethods
:
[
'
post
'
]
detects
POST
after
history
.
forward
(
)
"
)
;
await
contentPage
.
spawn
(
[
]
(
)
=
>
{
content
.
history
.
pushState
(
null
null
"
/
?
hist_p
"
)
;
}
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
contentPage
.
browsingContext
.
currentURI
.
pathQueryRef
=
=
=
"
/
?
hist_p
"
"
Waiting
for
history
.
pushState
to
have
changed
the
URL
"
)
;
Assert
.
equal
(
await
checkCanFetch
(
"
http
:
/
/
example
.
net
/
never_reached
"
)
FETCH_BLOCKED
"
history
.
pushState
drops
POST
not
matched
by
requestMethods
:
[
'
post
'
]
"
)
;
await
contentPage
.
close
(
)
;
await
testLoadInFrame
(
{
description
:
"
sub_frame
:
non
-
POST
not
matched
by
requestMethods
:
[
'
post
'
]
"
domains
:
[
"
example
.
com
"
"
example
.
com
"
]
jsForFrame
:
async
(
)
=
>
{
return
(
await
fetch
(
"
http
:
/
/
example
.
com
/
allowed
"
)
)
.
text
(
)
;
}
expectedError
:
FETCH_BLOCKED
}
)
;
await
testLoadInFrame
(
{
description
:
"
sub_frame
:
requestMethods
:
[
'
post
'
]
applies
to
POST
"
domains
:
[
"
example
.
com
"
"
example
.
com
"
]
jsForFrame
:
async
(
)
=
>
{
if
(
!
location
.
href
.
endsWith
(
"
?
do_post
"
)
)
{
dump
(
"
Triggering
navigation
with
POST
\
n
"
)
;
let
form
=
document
.
createElement
(
"
form
"
)
;
form
.
action
=
location
.
href
+
"
?
do_post
"
;
form
.
method
=
"
POST
"
;
document
.
body
.
append
(
form
)
;
form
.
submit
(
)
;
return
"
delay_postMessage
"
;
}
dump
(
"
Navigation
with
POST
completed
;
testing
fetch
(
)
.
.
.
\
n
"
)
;
return
(
await
fetch
(
"
http
:
/
/
example
.
com
/
allowed
"
)
)
.
text
(
)
;
}
expectedResult
:
"
fetchAllowed
"
}
)
;
await
extension
.
unload
(
)
;
}
)
;
