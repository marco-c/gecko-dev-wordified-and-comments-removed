"
use
strict
"
;
add_setup
(
(
)
=
>
{
Services
.
prefs
.
setBoolPref
(
"
extensions
.
manifestV3
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
dnr
.
enabled
"
true
)
;
}
)
;
const
server
=
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
"
example
.
net
"
"
example
.
org
"
"
redir
"
"
dummy
"
]
}
)
;
server
.
registerPathHandler
(
"
/
cors_202
"
(
req
res
)
=
>
{
res
.
setStatusLine
(
req
.
httpVersion
202
"
Accepted
"
)
;
res
.
setHeader
(
"
Access
-
Control
-
Allow
-
Origin
"
"
*
"
)
;
res
.
setHeader
(
"
Access
-
Control
-
Max
-
Age
"
"
0
"
)
;
res
.
write
(
"
cors_response
"
)
;
}
)
;
server
.
registerPathHandler
(
"
/
never_reached
"
(
req
res
)
=
>
{
Assert
.
ok
(
false
"
Server
should
never
have
been
reached
"
)
;
res
.
setHeader
(
"
Access
-
Control
-
Allow
-
Origin
"
"
*
"
)
;
res
.
setHeader
(
"
Access
-
Control
-
Max
-
Age
"
"
0
"
)
;
}
)
;
let
gPreflightCount
=
0
;
server
.
registerPathHandler
(
"
/
preflight_count
"
(
req
res
)
=
>
{
res
.
setHeader
(
"
Access
-
Control
-
Allow
-
Origin
"
"
*
"
)
;
res
.
setHeader
(
"
Access
-
Control
-
Max
-
Age
"
"
0
"
)
;
res
.
setHeader
(
"
Access
-
Control
-
Allow
-
Methods
"
"
NONSIMPLE
"
)
;
if
(
req
.
method
=
=
=
"
OPTIONS
"
)
{
+
+
gPreflightCount
;
}
else
{
res
.
setStatusLine
(
req
.
httpVersion
418
"
I
'
m
a
teapot
"
)
;
res
.
write
(
count
=
{
gPreflightCount
}
)
;
}
}
)
;
server
.
registerPathHandler
(
"
/
"
(
req
res
)
=
>
{
res
.
setHeader
(
"
Access
-
Control
-
Allow
-
Origin
"
"
*
"
)
;
res
.
setHeader
(
"
Access
-
Control
-
Max
-
Age
"
"
0
"
)
;
res
.
write
(
"
Dummy
page
"
)
;
}
)
;
async
function
contentFetch
(
initiatorURL
url
options
)
{
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
initiatorURL
)
;
Assert
.
equal
(
await
contentPage
.
spawn
(
null
(
)
=
>
content
.
document
.
URL
)
initiatorURL
Expected
document
load
at
:
{
initiatorURL
}
)
;
let
result
=
await
contentPage
.
spawn
(
{
url
options
}
async
args
=
>
{
try
{
let
req
=
await
content
.
fetch
(
args
.
url
args
.
options
)
;
return
{
status
:
req
.
status
url
:
req
.
url
body
:
await
req
.
text
(
)
}
;
}
catch
(
e
)
{
return
{
error
:
e
.
message
}
;
}
}
)
;
await
contentPage
.
close
(
)
;
return
result
;
}
async
function
checkCanFetchFromOtherExtension
(
)
{
let
otherExtension
=
ExtensionTestUtils
.
loadExtension
(
{
async
background
(
)
{
let
req
=
await
fetch
(
"
http
:
/
/
example
.
com
/
cors_202
"
{
method
:
"
get
"
}
)
;
browser
.
test
.
assertEq
(
202
req
.
status
"
not
blocked
by
other
extension
"
)
;
browser
.
test
.
assertEq
(
"
cors_response
"
await
req
.
text
(
)
)
;
browser
.
test
.
sendMessage
(
"
other_extension_done
"
)
;
}
}
)
;
await
otherExtension
.
startup
(
)
;
await
otherExtension
.
awaitMessage
(
"
other_extension_done
"
)
;
await
otherExtension
.
unload
(
)
;
}
add_task
(
async
function
block_request_with_dnr
(
)
{
async
function
background
(
)
{
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
requestMethods
:
[
"
get
"
]
}
action
:
{
type
:
"
block
"
}
}
{
id
:
2
condition
:
{
requestMethods
:
[
"
head
"
]
}
action
:
{
type
:
"
allow
"
}
}
]
}
)
;
{
let
req
=
await
fetch
(
"
http
:
/
/
example
.
com
/
cors_202
"
{
method
:
"
post
"
}
)
;
browser
.
test
.
assertEq
(
202
req
.
status
"
allowed
without
DNR
rule
"
)
;
browser
.
test
.
assertEq
(
"
cors_response
"
await
req
.
text
(
)
)
;
}
{
let
req
=
await
fetch
(
"
http
:
/
/
example
.
com
/
cors_202
"
{
method
:
"
head
"
}
)
;
browser
.
test
.
assertEq
(
202
req
.
status
"
allowed
by
DNR
rule
"
)
;
browser
.
test
.
assertEq
(
"
"
await
req
.
text
(
)
"
no
response
for
HEAD
"
)
;
}
await
browser
.
test
.
assertRejects
(
fetch
(
"
http
:
/
/
example
.
com
/
never_reached
"
{
method
:
"
get
"
}
)
"
NetworkError
when
attempting
to
fetch
resource
.
"
"
blocked
by
DNR
rule
"
)
;
browser
.
test
.
sendMessage
(
"
tested_dnr_block
"
)
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
allowInsecureRequests
:
true
background
manifest
:
{
manifest_version
:
3
permissions
:
[
"
declarativeNetRequest
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
tested_dnr_block
"
)
;
Assert
.
deepEqual
(
await
contentFetch
(
"
http
:
/
/
dummy
/
"
"
http
:
/
/
example
.
com
/
never_reached
"
)
{
error
:
"
NetworkError
when
attempting
to
fetch
resource
.
"
}
"
Blocked
by
DNR
with
declarativeNetRequestWithHostAccess
"
)
;
await
checkCanFetchFromOtherExtension
(
)
;
let
otherExtension
=
ExtensionTestUtils
.
loadExtension
(
{
async
background
(
)
{
await
browser
.
test
.
assertRejects
(
fetch
(
"
http
:
/
/
example
.
com
/
never_reached
"
{
method
:
"
get
"
}
)
"
NetworkError
when
attempting
to
fetch
resource
.
"
"
blocked
by
different
extension
with
declarativeNetRequest
permission
"
)
;
browser
.
test
.
sendMessage
(
"
other_extension_done
"
)
;
}
}
)
;
await
runWithPrefs
(
[
[
"
extensions
.
dnr
.
match_requests_from_other_extensions
"
true
]
]
async
(
)
=
>
{
info
(
"
Verifying
that
fetch
(
)
from
extension
is
intercepted
with
pref
"
)
;
await
otherExtension
.
startup
(
)
;
await
otherExtension
.
awaitMessage
(
"
other_extension_done
"
)
;
await
otherExtension
.
unload
(
)
;
}
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
block_with_declarativeNetRequestWithHostAccess
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
async
background
(
)
{
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
}
action
:
{
type
:
"
block
"
}
}
]
}
)
;
browser
.
test
.
sendMessage
(
"
dnr_registered
"
)
;
}
temporarilyInstalled
:
true
allowInsecureRequests
:
true
manifest
:
{
manifest_version
:
3
granted_host_permissions
:
true
host_permissions
:
[
"
<
all_urls
>
"
]
permissions
:
[
"
declarativeNetRequestWithHostAccess
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
dnr_registered
"
)
;
Assert
.
deepEqual
(
await
contentFetch
(
"
http
:
/
/
dummy
/
"
"
http
:
/
/
example
.
com
/
never_reached
"
)
{
error
:
"
NetworkError
when
attempting
to
fetch
resource
.
"
}
"
Blocked
by
DNR
with
declarativeNetRequestWithHostAccess
"
)
;
await
checkCanFetchFromOtherExtension
(
)
;
info
(
"
Verifying
that
access
is
not
allowed
despite
the
pref
being
true
"
)
;
await
runWithPrefs
(
[
[
"
extensions
.
dnr
.
match_requests_from_other_extensions
"
true
]
]
checkCanFetchFromOtherExtension
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
block_in_sandboxed_extension_page
(
)
{
const
filesWithSandbox
=
{
"
page_with_sandbox
.
html
"
:
<
!
DOCTYPE
html
>
<
meta
charset
=
"
utf
-
8
"
>
<
script
src
=
"
page_with_sandbox
.
js
"
>
<
/
script
>
<
iframe
src
=
"
sandbox
.
html
"
sandbox
=
"
allow
-
scripts
"
>
<
/
iframe
>
"
page_with_sandbox
.
js
"
:
(
)
=
>
{
window
.
onmessage
=
e
=
>
{
browser
.
test
.
assertEq
(
"
null
"
e
.
origin
"
Sender
has
opaque
origin
"
)
;
browser
.
test
.
sendMessage
(
"
fetch_result
"
e
.
data
)
;
}
;
}
"
sandbox
.
html
"
:
<
script
src
=
"
sandbox
.
js
"
>
<
/
script
>
"
sandbox
.
js
"
:
async
(
)
=
>
{
try
{
await
fetch
(
"
http
:
/
/
example
.
com
/
?
fetch_by_sandbox
"
)
;
parent
.
postMessage
(
"
FETCH_ALLOWED
"
"
*
"
)
;
}
catch
(
e
)
{
parent
.
postMessage
(
"
FETCH_BLOCKED
"
"
*
"
)
;
}
}
}
;
async
function
checkFetchInSandboxedExtensionPage
(
ext
)
{
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
moz
-
extension
:
/
/
{
ext
.
uuid
}
/
page_with_sandbox
.
html
)
;
let
result
=
await
ext
.
awaitMessage
(
"
fetch_result
"
)
;
await
contentPage
.
close
(
)
;
return
result
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
async
background
(
)
{
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
}
action
:
{
type
:
"
block
"
}
}
]
}
)
;
browser
.
test
.
sendMessage
(
"
dnr_registered
"
)
;
}
allowInsecureRequests
:
true
manifest
:
{
manifest_version
:
3
permissions
:
[
"
declarativeNetRequest
"
]
}
files
:
filesWithSandbox
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
dnr_registered
"
)
;
Assert
.
equal
(
await
checkFetchInSandboxedExtensionPage
(
extension
)
"
FETCH_BLOCKED
"
"
DNR
blocks
request
from
sandboxed
page
in
own
extension
"
)
;
let
otherExtension
=
ExtensionTestUtils
.
loadExtension
(
{
files
:
filesWithSandbox
}
)
;
await
otherExtension
.
startup
(
)
;
Assert
.
equal
(
await
checkFetchInSandboxedExtensionPage
(
otherExtension
)
"
FETCH_BLOCKED
"
"
DNR
can
block
request
from
sandboxed
page
in
other
extension
"
)
;
await
runWithPrefs
(
[
[
"
extensions
.
dnr
.
match_requests_from_other_extensions
"
true
]
]
async
(
)
=
>
{
info
(
"
Verifying
that
fetch
(
)
from
extension
sandbox
is
matched
via
pref
"
)
;
Assert
.
equal
(
await
checkFetchInSandboxedExtensionPage
(
otherExtension
)
"
FETCH_BLOCKED
"
"
DNR
can
block
request
from
sandboxed
page
in
other
extension
via
pref
"
)
;
}
)
;
await
extension
.
unload
(
)
;
Assert
.
equal
(
await
checkFetchInSandboxedExtensionPage
(
otherExtension
)
"
FETCH_ALLOWED
"
"
DNR
does
not
affect
sandboxed
extensions
after
unloading
the
DNR
extension
"
)
;
await
otherExtension
.
unload
(
)
;
}
)
;
add_task
(
async
function
upgradeScheme_declarativeNetRequestWithHostAccess
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
async
background
(
)
{
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
excludedRequestDomains
:
[
"
dummy
"
]
}
action
:
{
type
:
"
upgradeScheme
"
}
}
{
id
:
2
condition
:
{
urlFilter
:
"
|
https
:
*
"
}
action
:
{
type
:
"
redirect
"
redirect
:
{
url
:
"
http
:
/
/
dummy
/
cors_202
?
from_https
"
}
}
priority
:
2
}
]
}
)
;
let
req
=
await
fetch
(
"
http
:
/
/
redir
/
never_reached
"
)
;
browser
.
test
.
assertEq
(
"
http
:
/
/
dummy
/
cors_202
?
from_https
"
req
.
url
"
upgradeScheme
upgraded
to
https
"
)
;
browser
.
test
.
assertEq
(
"
cors_response
"
await
req
.
text
(
)
)
;
browser
.
test
.
sendMessage
(
"
tested_dnr_upgradeScheme
"
)
;
}
temporarilyInstalled
:
true
allowInsecureRequests
:
true
manifest
:
{
manifest_version
:
3
granted_host_permissions
:
true
host_permissions
:
[
"
*
:
/
/
dummy
/
*
"
"
*
:
/
/
redir
/
*
"
]
permissions
:
[
"
declarativeNetRequestWithHostAccess
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
tested_dnr_upgradeScheme
"
)
;
Assert
.
equal
(
(
await
contentFetch
(
"
http
:
/
/
redir
/
"
"
http
:
/
/
redir
/
never_reached
"
)
)
.
url
"
http
:
/
/
dummy
/
cors_202
?
from_https
"
"
upgradeScheme
+
host
access
should
upgrade
(
same
-
origin
request
)
"
)
;
Assert
.
equal
(
(
await
contentFetch
(
"
http
:
/
/
dummy
/
"
"
http
:
/
/
redir
/
never_reached
"
)
)
.
url
"
http
:
/
/
dummy
/
cors_202
?
from_https
"
"
upgradeScheme
+
host
access
should
upgrade
(
cross
-
origin
request
)
"
)
;
const
urlNoHostPerms
=
"
http
:
/
/
example
.
net
/
cors_202
?
missing_host_permission
"
;
Assert
.
equal
(
(
await
contentFetch
(
"
http
:
/
/
dummy
/
"
urlNoHostPerms
)
)
.
url
urlNoHostPerms
"
upgradeScheme
not
matched
when
extension
lacks
host
access
"
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
redirect_request_with_dnr
(
)
{
async
function
background
(
)
{
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
requestDomains
:
[
"
example
.
com
"
]
requestMethods
:
[
"
get
"
]
}
action
:
{
type
:
"
redirect
"
redirect
:
{
url
:
"
http
:
/
/
example
.
net
/
cors_202
?
1
"
}
}
}
{
id
:
2
condition
:
{
requestDomains
:
[
"
example
.
org
"
]
}
action
:
{
type
:
"
redirect
"
redirect
:
{
url
:
"
http
:
/
/
example
.
net
/
cors_202
?
2
"
}
}
}
]
}
)
;
{
let
req
=
await
fetch
(
"
http
:
/
/
example
.
com
/
never_reached
"
)
;
browser
.
test
.
assertEq
(
202
req
.
status
"
redirected
by
DNR
(
simple
)
"
)
;
browser
.
test
.
assertEq
(
"
http
:
/
/
example
.
net
/
cors_202
?
1
"
req
.
url
)
;
browser
.
test
.
assertEq
(
"
cors_response
"
await
req
.
text
(
)
)
;
}
{
let
req
=
await
fetch
(
"
http
:
/
/
example
.
com
/
never_reached
"
{
method
:
"
GeT
"
}
)
;
browser
.
test
.
assertEq
(
202
req
.
status
"
redirected
by
DNR
(
GeT
)
"
)
;
browser
.
test
.
assertEq
(
"
http
:
/
/
example
.
net
/
cors_202
?
1
"
req
.
url
)
;
browser
.
test
.
assertEq
(
"
cors_response
"
await
req
.
text
(
)
)
;
}
{
let
req
=
await
fetch
(
"
http
:
/
/
example
.
org
/
cors_202
?
noredir
"
)
;
browser
.
test
.
assertEq
(
202
req
.
status
"
not
redirected
by
DNR
"
)
;
browser
.
test
.
assertEq
(
"
http
:
/
/
example
.
org
/
cors_202
?
noredir
"
req
.
url
)
;
browser
.
test
.
assertEq
(
"
cors_response
"
await
req
.
text
(
)
)
;
}
browser
.
test
.
notifyPass
(
)
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
temporarilyInstalled
:
true
allowInsecureRequests
:
true
manifest
:
{
manifest_version
:
3
granted_host_permissions
:
true
host_permissions
:
[
"
*
:
/
/
example
.
com
/
*
"
]
permissions
:
[
"
declarativeNetRequest
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitFinish
(
)
;
let
otherExtension
=
ExtensionTestUtils
.
loadExtension
(
{
async
background
(
)
{
let
req
=
await
fetch
(
"
http
:
/
/
example
.
com
/
cors_202
?
other_ext
"
)
;
browser
.
test
.
assertEq
(
202
req
.
status
"
not
redirected
by
DNR
"
)
;
browser
.
test
.
assertEq
(
"
http
:
/
/
example
.
com
/
cors_202
?
other_ext
"
req
.
url
)
;
browser
.
test
.
assertEq
(
"
cors_response
"
await
req
.
text
(
)
)
;
browser
.
test
.
sendMessage
(
"
other_extension_done
"
)
;
}
}
)
;
await
otherExtension
.
startup
(
)
;
await
otherExtension
.
awaitMessage
(
"
other_extension_done
"
)
;
await
otherExtension
.
unload
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
redirect_request_with_dnr_cors_preflight
(
)
{
async
function
background
(
)
{
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
requestDomains
:
[
"
redir
"
]
excludedRequestMethods
:
[
"
options
"
]
}
action
:
{
type
:
"
redirect
"
redirect
:
{
url
:
"
http
:
/
/
example
.
com
/
preflight_count
"
}
}
}
{
id
:
2
condition
:
{
requestDomains
:
[
"
example
.
net
"
]
excludedRequestMethods
:
[
"
nonsimple
"
]
}
action
:
{
type
:
"
redirect
"
redirect
:
{
url
:
"
http
:
/
/
example
.
com
/
preflight_count
"
}
}
}
]
}
)
;
let
req
=
await
fetch
(
"
http
:
/
/
redir
/
never_reached
"
{
method
:
"
NONSIMPLE
"
}
)
;
browser
.
test
.
assertEq
(
"
count
=
1
"
await
req
.
text
(
)
"
Got
preflight
before
redirect
target
because
of
missing
host_permissions
"
)
;
browser
.
test
.
sendMessage
(
"
continue_preflight_tests
"
)
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
temporarilyInstalled
:
true
allowInsecureRequests
:
true
manifest
:
{
manifest_version
:
3
granted_host_permissions
:
true
host_permissions
:
[
"
*
:
/
/
redir
/
*
"
"
*
:
/
/
example
.
net
/
*
"
"
*
:
/
/
dummy
/
*
"
]
permissions
:
[
"
declarativeNetRequest
"
]
}
}
)
;
gPreflightCount
=
0
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
continue_preflight_tests
"
)
;
gPreflightCount
=
0
;
Assert
.
deepEqual
(
await
contentFetch
(
"
http
:
/
/
dummy
/
"
"
http
:
/
/
redir
/
never_reached
"
)
{
status
:
418
url
:
"
http
:
/
/
example
.
com
/
preflight_count
"
body
:
"
count
=
0
"
}
"
Simple
request
should
not
have
a
preflight
.
"
)
;
Assert
.
deepEqual
(
await
contentFetch
(
"
http
:
/
/
dummy
/
"
"
http
:
/
/
redir
/
never_reached
"
{
method
:
"
NONSIMPLE
"
}
)
{
status
:
418
url
:
"
http
:
/
/
example
.
com
/
preflight_count
"
body
:
"
count
=
1
"
}
"
Initial
URL
redirected
redirection
target
has
preflight
"
)
;
gPreflightCount
=
0
;
Assert
.
deepEqual
(
await
contentFetch
(
"
http
:
/
/
dummy
/
"
"
http
:
/
/
example
.
net
/
never_reached
"
{
method
:
"
NONSIMPLE
"
}
)
{
error
:
"
NetworkError
when
attempting
to
fetch
resource
.
"
}
"
Redirect
of
preflight
request
(
OPTIONS
)
should
be
a
CORS
failure
"
)
;
Assert
.
equal
(
gPreflightCount
0
"
Preflight
OPTIONS
has
been
intercepted
"
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
redirect_request_with_dnr_multiple_hops
(
)
{
async
function
background
(
)
{
let
hosts
=
[
"
example
.
com
"
"
example
.
net
"
"
example
.
org
"
"
redir
"
"
dummy
"
]
;
let
rules
=
[
]
;
for
(
let
i
=
1
;
i
<
hosts
.
length
;
+
+
i
)
{
const
from
=
hosts
[
i
-
1
]
;
const
to
=
hosts
[
i
]
;
const
end
=
hosts
.
length
-
1
=
=
=
i
;
rules
.
push
(
{
id
:
i
condition
:
{
requestDomains
:
[
from
]
}
action
:
{
type
:
"
redirect
"
redirect
:
{
url
:
end
?
http
:
/
/
{
to
}
/
?
end
:
http
:
/
/
{
to
}
/
never_reached
}
}
}
)
;
}
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
rules
}
)
;
let
req
=
await
fetch
(
"
http
:
/
/
example
.
com
/
never_reached
"
)
;
browser
.
test
.
assertEq
(
200
req
.
status
"
redirected
by
DNR
(
multiple
)
"
)
;
browser
.
test
.
assertEq
(
"
http
:
/
/
dummy
/
?
end
"
req
.
url
"
Last
URL
in
chain
"
)
;
browser
.
test
.
assertEq
(
"
Dummy
page
"
await
req
.
text
(
)
)
;
browser
.
test
.
notifyPass
(
)
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
temporarilyInstalled
:
true
allowInsecureRequests
:
true
manifest
:
{
manifest_version
:
3
granted_host_permissions
:
true
host_permissions
:
[
"
*
:
/
/
*
/
*
"
]
permissions
:
[
"
declarativeNetRequest
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitFinish
(
)
;
Assert
.
deepEqual
(
await
contentFetch
(
"
http
:
/
/
dummy
/
"
"
http
:
/
/
redir
/
never_reached
"
)
{
status
:
200
url
:
"
http
:
/
/
dummy
/
?
end
"
body
:
"
Dummy
page
"
}
"
Multiple
redirects
by
DNR
requested
from
web
origin
.
"
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
redirect_request_with_dnr_with_redirect_loop
(
)
{
async
function
background
(
)
{
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
regexFilter
:
"
^
(
.
+
)
"
requestMethods
:
[
"
post
"
]
}
action
:
{
type
:
"
redirect
"
redirect
:
{
regexSubstitution
:
"
\
\
1
?
loop
"
}
}
}
{
id
:
2
condition
:
{
requestDomains
:
[
"
redir
"
]
requestMethods
:
[
"
get
"
]
}
action
:
{
type
:
"
redirect
"
redirect
:
{
url
:
"
http
:
/
/
redir
/
cors_202
?
loop
"
}
}
}
]
}
)
;
await
browser
.
test
.
assertRejects
(
fetch
(
"
http
:
/
/
redir
/
cors_202
?
loop
"
{
method
:
"
post
"
}
)
"
NetworkError
when
attempting
to
fetch
resource
.
"
"
Redirect
loop
caught
(
redirect
target
differs
at
every
redirect
)
"
)
;
async
function
assertRedirect
(
url
expected
description
)
{
let
res
=
await
fetch
(
url
)
;
browser
.
test
.
assertDeepEq
(
expected
{
status
:
res
.
status
url
:
res
.
url
redirected
:
res
.
redirected
}
description
)
;
}
await
assertRedirect
(
"
http
:
/
/
redir
/
never_reached
?
"
{
status
:
202
url
:
"
http
:
/
/
redir
/
cors_202
?
loop
"
redirected
:
true
}
"
Redirect
loop
caught
(
initially
different
URL
)
"
)
;
await
assertRedirect
(
"
http
:
/
/
redir
/
cors_202
?
loop
"
{
status
:
202
url
:
"
http
:
/
/
redir
/
cors_202
?
loop
"
redirected
:
false
}
"
Redirect
loop
caught
(
redirect
target
same
as
initial
URL
)
"
)
;
browser
.
test
.
notifyPass
(
)
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
temporarilyInstalled
:
true
allowInsecureRequests
:
true
manifest
:
{
manifest_version
:
3
granted_host_permissions
:
true
host_permissions
:
[
"
*
:
/
/
redir
/
*
"
]
permissions
:
[
"
declarativeNetRequest
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitFinish
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
redirect_request_with_dnr_to_extensionPath
(
)
{
async
function
background
(
)
{
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
requestDomains
:
[
"
redir
"
]
requestMethods
:
[
"
post
"
]
}
action
:
{
type
:
"
redirect
"
redirect
:
{
extensionPath
:
"
/
war
.
txt
?
1
"
}
}
}
{
id
:
2
condition
:
{
requestDomains
:
[
"
redir
"
]
requestMethods
:
[
"
put
"
]
}
action
:
{
type
:
"
redirect
"
redirect
:
{
extensionPath
:
"
/
nonwar
.
txt
?
2
"
}
}
}
]
}
)
;
{
let
req
=
await
fetch
(
"
http
:
/
/
redir
/
never_reached
"
{
method
:
"
post
"
}
)
;
browser
.
test
.
assertEq
(
200
req
.
status
"
redirected
to
extensionPath
"
)
;
browser
.
test
.
assertEq
(
{
location
.
origin
}
/
war
.
txt
?
1
req
.
url
)
;
browser
.
test
.
assertEq
(
"
war_ext_res
"
await
req
.
text
(
)
)
;
}
await
browser
.
test
.
assertRejects
(
fetch
(
"
http
:
/
/
redir
/
never_reached
"
{
method
:
"
put
"
}
)
"
NetworkError
when
attempting
to
fetch
resource
.
"
"
Redirect
to
nowar
.
txt
but
pre
-
redirect
host
is
not
in
web_accessible_resources
[
]
.
matches
"
)
;
browser
.
test
.
notifyPass
(
)
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
temporarilyInstalled
:
true
allowInsecureRequests
:
true
manifest
:
{
manifest_version
:
3
granted_host_permissions
:
true
host_permissions
:
[
"
*
:
/
/
redir
/
*
"
"
*
:
/
/
dummy
/
*
"
]
permissions
:
[
"
declarativeNetRequest
"
]
web_accessible_resources
:
[
{
resources
:
[
"
war
.
txt
"
]
matches
:
[
"
*
:
/
/
redir
/
*
"
"
*
:
/
/
dummy
/
*
"
]
}
{
resources
:
[
"
nonwar
.
txt
"
]
extension_ids
:
[
"
*
"
]
}
]
}
files
:
{
"
war
.
txt
"
:
"
war_ext_res
"
"
nonwar
.
txt
"
:
"
non_war_ext_res
"
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitFinish
(
)
;
const
extPrefix
=
moz
-
extension
:
/
/
{
extension
.
uuid
}
;
Assert
.
deepEqual
(
await
contentFetch
(
"
http
:
/
/
dummy
/
"
"
http
:
/
/
redir
/
never_reached
"
{
method
:
"
post
"
}
)
{
status
:
200
url
:
{
extPrefix
}
/
war
.
txt
?
1
body
:
"
war_ext_res
"
}
"
Should
have
got
redirect
to
web_accessible_resources
(
war
.
txt
)
"
)
;
let
{
messages
}
=
await
promiseConsoleOutput
(
async
(
)
=
>
{
Assert
.
deepEqual
(
await
contentFetch
(
"
http
:
/
/
dummy
/
"
"
http
:
/
/
redir
/
never_reached
"
{
method
:
"
put
"
}
)
{
error
:
"
NetworkError
when
attempting
to
fetch
resource
.
"
}
"
Redirect
to
nowar
.
txt
without
matching
web_accessible_resources
[
]
.
matches
"
)
;
}
)
;
const
EXPECTED_SECURITY_ERROR
=
Content
at
http
:
/
/
redir
/
never_reached
may
not
load
or
link
to
{
extPrefix
}
/
nonwar
.
txt
?
2
.
;
Assert
.
equal
(
messages
.
filter
(
m
=
>
m
.
message
.
includes
(
EXPECTED_SECURITY_ERROR
)
)
.
length
1
Should
log
SecurityError
:
{
EXPECTED_SECURITY_ERROR
}
)
;
Assert
.
deepEqual
(
await
contentFetch
(
"
http
:
/
/
dummy
/
"
"
http
:
/
/
example
.
com
/
cors_202
"
{
method
:
"
post
"
}
)
{
status
:
202
url
:
"
http
:
/
/
example
.
com
/
cors_202
"
body
:
"
cors_response
"
}
"
Extension
should
not
have
redirected
due
to
lack
of
host
permissions
"
)
;
await
extension
.
unload
(
)
;
}
)
;
