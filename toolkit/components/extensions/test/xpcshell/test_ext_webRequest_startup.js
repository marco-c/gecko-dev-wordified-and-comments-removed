"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
42
"
"
42
"
)
;
let
{
promiseRestartManager
promiseShutdownManager
promiseStartupManager
}
=
AddonTestUtils
;
const
server
=
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
]
}
)
;
server
.
registerDirectory
(
"
/
data
/
"
do_get_file
(
"
data
"
)
)
;
let
scopes
=
AddonManager
.
SCOPE_PROFILE
|
AddonManager
.
SCOPE_APPLICATION
;
Services
.
prefs
.
setIntPref
(
"
extensions
.
enabledScopes
"
scopes
)
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
webextensions
.
background
-
delayed
-
startup
"
true
)
;
function
trackEvents
(
wrapper
)
{
let
events
=
new
Map
(
)
;
for
(
let
event
of
[
"
background
-
page
-
event
"
"
start
-
background
-
page
"
]
)
{
events
.
set
(
event
false
)
;
wrapper
.
extension
.
once
(
event
(
)
=
>
events
.
set
(
event
true
)
)
;
}
return
events
;
}
async
function
testPersistentRequestStartup
(
extension
events
expect
)
{
equal
(
events
.
get
(
"
background
-
page
-
event
"
)
expect
.
background
"
Should
have
gotten
a
background
page
event
"
)
;
equal
(
events
.
get
(
"
start
-
background
-
page
"
)
false
"
Background
page
should
not
be
started
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
browser
-
delayed
-
startup
-
finished
"
)
;
await
ExtensionParent
.
browserPaintedPromise
;
equal
(
events
.
get
(
"
start
-
background
-
page
"
)
expect
.
delayedStart
"
Should
have
gotten
start
-
background
-
page
event
"
)
;
if
(
expect
.
request
)
{
await
extension
.
awaitMessage
(
"
got
-
request
"
)
;
ok
(
true
"
Background
page
loaded
and
received
webRequest
event
"
)
;
}
}
add_task
(
async
function
test_1
(
)
{
await
promiseStartupManager
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
manifest
:
{
permissions
:
[
"
webRequest
"
"
http
:
/
/
example
.
com
/
"
]
}
background
(
)
{
browser
.
webRequest
.
onBeforeRequest
.
addListener
(
details
=
>
{
browser
.
test
.
sendMessage
(
"
got
-
request
"
)
;
}
{
urls
:
[
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
]
}
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
promiseRestartManager
(
)
;
await
extension
.
awaitStartup
(
)
;
let
events
=
trackEvents
(
extension
)
;
await
ExtensionTestUtils
.
fetch
(
"
http
:
/
/
example
.
com
/
"
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
)
;
await
testPersistentRequestStartup
(
extension
events
{
background
:
true
delayedStart
:
true
request
:
true
}
)
;
await
extension
.
unload
(
)
;
await
promiseShutdownManager
(
)
;
}
)
;
add_task
(
async
function
test_2
(
)
{
await
promiseStartupManager
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
manifest
:
{
permissions
:
[
"
webRequest
"
"
webRequestBlocking
"
"
http
:
/
/
test1
.
example
.
com
/
"
]
}
background
(
)
{
browser
.
webRequest
.
onBeforeRequest
.
addListener
(
details
=
>
{
browser
.
test
.
fail
(
"
Listener
should
not
have
been
called
"
)
;
}
{
urls
:
[
"
http
:
/
/
test1
.
example
.
com
/
*
"
]
}
[
"
blocking
"
]
)
;
browser
.
test
.
sendMessage
(
"
ready
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
ready
"
)
;
await
promiseRestartManager
(
)
;
await
extension
.
awaitStartup
(
)
;
let
events
=
trackEvents
(
extension
)
;
await
ExtensionTestUtils
.
fetch
(
"
http
:
/
/
example
.
com
/
"
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
)
;
await
testPersistentRequestStartup
(
extension
events
{
background
:
false
delayedStart
:
false
request
:
false
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
windows
-
restored
"
)
;
await
extension
.
awaitMessage
(
"
ready
"
)
;
await
extension
.
unload
(
)
;
await
promiseShutdownManager
(
)
;
}
)
;
add_task
(
async
function
test_3
(
)
{
const
DATA
=
<
!
DOCTYPE
html
>
<
html
>
<
body
>
<
h1
>
This
is
a
modified
page
<
/
h1
>
<
/
body
>
<
/
html
>
;
function
background
(
data
)
{
browser
.
webRequest
.
onBeforeRequest
.
addListener
(
details
=
>
{
let
filter
=
browser
.
webRequest
.
filterResponseData
(
details
.
requestId
)
;
filter
.
onstop
=
(
)
=
>
{
let
encoded
=
new
TextEncoder
(
"
utf
-
8
"
)
.
encode
(
data
)
;
filter
.
write
(
encoded
)
;
filter
.
close
(
)
;
}
;
}
{
urls
:
[
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
]
}
[
"
blocking
"
]
)
;
}
await
promiseStartupManager
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
manifest
:
{
permissions
:
[
"
webRequest
"
"
webRequestBlocking
"
"
http
:
/
/
example
.
com
/
"
]
}
background
:
(
{
background
}
)
(
{
uneval
(
DATA
)
}
)
}
)
;
await
extension
.
startup
(
)
;
await
promiseRestartManager
(
)
;
await
extension
.
awaitStartup
(
)
;
let
dataPromise
=
ExtensionTestUtils
.
fetch
(
"
http
:
/
/
example
.
com
/
"
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
browser
-
delayed
-
startup
-
finished
"
)
;
let
data
=
await
dataPromise
;
equal
(
data
DATA
"
Stream
filter
was
properly
installed
for
a
load
during
startup
"
)
;
await
extension
.
unload
(
)
;
await
promiseShutdownManager
(
)
;
}
)
;
add_task
(
async
function
test_persistent_listener_after_sideload_upgrade
(
)
{
let
id
=
"
permission
-
sideload
-
upgrade
test
"
;
let
extensionData
=
{
useAddonManager
:
"
permanent
"
manifest
:
{
version
:
"
1
.
0
"
applications
:
{
gecko
:
{
id
}
}
permissions
:
[
"
webRequest
"
"
http
:
/
/
example
.
com
/
"
]
}
background
(
)
{
browser
.
webRequest
.
onBeforeRequest
.
addListener
(
details
=
>
{
browser
.
test
.
sendMessage
(
"
got
-
request
"
)
;
}
{
urls
:
[
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
]
}
)
;
}
}
;
let
xpi
=
AddonTestUtils
.
createTempWebExtensionFile
(
extensionData
)
;
let
extension
=
ExtensionTestUtils
.
expectExtension
(
id
)
;
await
AddonTestUtils
.
manuallyInstall
(
xpi
)
;
await
promiseStartupManager
(
)
;
await
extension
.
awaitStartup
(
)
;
await
ExtensionTestUtils
.
fetch
(
"
http
:
/
/
example
.
com
/
"
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
)
;
await
extension
.
awaitMessage
(
"
got
-
request
"
)
;
await
promiseShutdownManager
(
)
;
extensionData
.
manifest
.
version
=
"
2
.
0
"
;
extensionData
.
manifest
.
permissions
=
[
"
http
:
/
/
example
.
com
/
"
]
;
extensionData
.
manifest
.
optional_permissions
=
[
"
webRequest
"
]
;
xpi
=
AddonTestUtils
.
createTempWebExtensionFile
(
extensionData
)
;
await
AddonTestUtils
.
manuallyInstall
(
xpi
)
;
ExtensionParent
.
_resetStartupPromises
(
)
;
await
promiseStartupManager
(
)
;
await
extension
.
awaitStartup
(
)
;
let
events
=
trackEvents
(
extension
)
;
let
policy
=
WebExtensionPolicy
.
getByID
(
id
)
;
ok
(
policy
.
hasPermission
(
"
webRequest
"
)
"
addon
webRequest
permission
added
"
)
;
await
ExtensionTestUtils
.
fetch
(
"
http
:
/
/
example
.
com
/
"
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
)
;
await
testPersistentRequestStartup
(
extension
events
{
background
:
true
delayedStart
:
true
request
:
true
}
)
;
await
extension
.
unload
(
)
;
await
promiseShutdownManager
(
)
;
}
)
;
async
function
installBuiltinExtension
(
extensionData
)
{
let
xpi
=
await
AddonTestUtils
.
createTempWebExtensionFile
(
extensionData
)
;
let
base
=
Services
.
io
.
newURI
(
jar
:
file
:
{
xpi
.
path
}
!
/
)
;
let
resProto
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
resProto
.
setSubstitution
(
"
ext
-
test
"
base
)
;
return
AddonManager
.
installBuiltinAddon
(
"
resource
:
/
/
ext
-
test
/
"
)
;
}
function
promisePostponeInstall
(
install
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
listener
=
{
onInstallFailed
:
(
)
=
>
{
install
.
removeListener
(
listener
)
;
reject
(
new
Error
(
"
extension
installation
should
not
have
failed
"
)
)
;
}
onInstallEnded
:
(
)
=
>
{
install
.
removeListener
(
listener
)
;
reject
(
new
Error
(
extension
installation
should
not
have
ended
for
{
install
.
addon
.
id
}
)
)
;
}
onInstallPostponed
:
(
)
=
>
{
install
.
removeListener
(
listener
)
;
resolve
(
)
;
}
}
;
install
.
addListener
(
listener
)
;
install
.
install
(
)
;
}
)
;
}
add_task
(
async
function
test_persistent_listener_after_builtin_location_upgrade
(
)
{
let
id
=
"
permission
-
builtin
-
upgrade
test
"
;
let
extensionData
=
{
useAddonManager
:
"
permanent
"
manifest
:
{
version
:
"
1
.
0
"
applications
:
{
gecko
:
{
id
}
}
permissions
:
[
"
webRequest
"
"
http
:
/
/
example
.
com
/
"
]
}
async
background
(
)
{
browser
.
runtime
.
onUpdateAvailable
.
addListener
(
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
postponed
"
)
;
}
)
;
browser
.
webRequest
.
onBeforeRequest
.
addListener
(
details
=
>
{
browser
.
test
.
sendMessage
(
"
got
-
request
"
)
;
}
{
urls
:
[
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
]
}
)
;
}
}
;
await
promiseStartupManager
(
)
;
let
promiseExtension
=
AddonTestUtils
.
promiseWebExtensionStartup
(
id
)
;
await
installBuiltinExtension
(
extensionData
)
;
let
extv1
=
await
promiseExtension
;
extensionData
.
manifest
.
version
=
"
2
.
0
"
;
let
xpi
=
AddonTestUtils
.
createTempWebExtensionFile
(
extensionData
)
;
let
install
=
await
AddonManager
.
getInstallForFile
(
xpi
)
;
let
promiseUpdate
=
new
Promise
(
resolve
=
>
extv1
.
once
(
"
test
-
message
"
(
kind
msg
)
=
>
{
if
(
msg
=
=
"
postponed
"
)
{
resolve
(
)
;
}
}
)
)
;
await
Promise
.
all
(
[
promisePostponeInstall
(
install
)
promiseUpdate
]
)
;
await
promiseShutdownManager
(
)
;
ExtensionParent
.
_resetStartupPromises
(
)
;
let
extension
=
ExtensionTestUtils
.
expectExtension
(
id
)
;
await
promiseStartupManager
(
)
;
await
extension
.
awaitStartup
(
)
;
let
events
=
trackEvents
(
extension
)
;
await
ExtensionTestUtils
.
fetch
(
"
http
:
/
/
example
.
com
/
"
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
)
;
await
testPersistentRequestStartup
(
extension
events
{
background
:
true
delayedStart
:
true
request
:
true
}
)
;
await
extension
.
unload
(
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
await
addon
.
uninstall
(
)
;
await
promiseShutdownManager
(
)
;
}
)
;
add_task
(
async
function
test_persistent_listener_after_staged_upgrade
(
)
{
AddonManager
.
checkUpdateSecurity
=
false
;
let
id
=
"
persistent
-
staged
-
upgrade
test
"
;
AddonTestUtils
.
registerJSON
(
server
"
/
test_update
.
json
"
{
addons
:
{
"
persistent
-
staged
-
upgrade
test
"
:
{
updates
:
[
{
version
:
"
2
.
0
"
update_link
:
"
http
:
/
/
example
.
com
/
addons
/
test_settings_staged_restart
.
xpi
"
}
]
}
}
}
)
;
let
extensionData
=
{
useAddonManager
:
"
permanent
"
manifest
:
{
version
:
"
2
.
0
"
applications
:
{
gecko
:
{
id
update_url
:
http
:
/
/
example
.
com
/
test_update
.
json
}
}
permissions
:
[
"
http
:
/
/
example
.
com
/
"
]
optional_permissions
:
[
"
webRequest
"
]
}
background
(
)
{
browser
.
webRequest
.
onBeforeRequest
.
addListener
(
details
=
>
{
browser
.
test
.
sendMessage
(
"
got
-
request
"
)
;
}
{
urls
:
[
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
]
}
)
;
browser
.
runtime
.
onUpdateAvailable
.
addListener
(
async
details
=
>
{
if
(
details
&
&
details
.
version
)
{
browser
.
test
.
assertEq
(
"
2
.
0
"
details
.
version
"
correct
version
"
)
;
browser
.
test
.
sendMessage
(
"
delay
"
)
;
}
}
)
;
}
}
;
server
.
registerFile
(
/
addons
/
test_settings_staged_restart
.
xpi
AddonTestUtils
.
createTempWebExtensionFile
(
extensionData
)
)
;
extensionData
.
manifest
.
version
=
"
1
.
0
"
;
extensionData
.
manifest
.
permissions
=
[
"
webRequest
"
"
http
:
/
/
example
.
com
/
"
]
;
delete
extensionData
.
manifest
.
optional_permissions
;
await
promiseStartupManager
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
extensionData
)
;
await
extension
.
startup
(
)
;
await
ExtensionTestUtils
.
fetch
(
"
http
:
/
/
example
.
com
/
"
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
)
;
await
extension
.
awaitMessage
(
"
got
-
request
"
)
;
ok
(
true
"
Initial
version
received
webRequest
event
"
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
Assert
.
equal
(
addon
.
version
"
1
.
0
"
"
1
.
0
is
loaded
"
)
;
let
update
=
await
AddonTestUtils
.
promiseFindAddonUpdates
(
addon
)
;
let
install
=
update
.
updateAvailable
;
Assert
.
ok
(
install
install
is
available
{
update
.
error
}
)
;
await
AddonTestUtils
.
promiseCompleteAllInstalls
(
[
install
]
)
;
Assert
.
equal
(
install
.
state
AddonManager
.
STATE_POSTPONED
"
update
is
staged
for
install
"
)
;
await
extension
.
awaitMessage
(
"
delay
"
)
;
await
promiseShutdownManager
(
)
;
ExtensionParent
.
_resetStartupPromises
(
)
;
await
promiseStartupManager
(
)
;
await
extension
.
awaitStartup
(
)
;
let
events
=
trackEvents
(
extension
)
;
let
policy
=
WebExtensionPolicy
.
getByID
(
id
)
;
ok
(
policy
.
hasPermission
(
"
webRequest
"
)
"
addon
webRequest
permission
added
"
)
;
await
ExtensionTestUtils
.
fetch
(
"
http
:
/
/
example
.
com
/
"
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
)
;
await
testPersistentRequestStartup
(
extension
events
{
background
:
true
delayedStart
:
true
request
:
true
}
)
;
await
extension
.
unload
(
)
;
await
promiseShutdownManager
(
)
;
AddonManager
.
checkUpdateSecurity
=
true
;
}
)
;
add_task
(
async
function
test_persistent_listener_after_permission_removal
(
)
{
let
id
=
"
persistent
-
staged
-
remove
test
"
;
AddonTestUtils
.
registerJSON
(
server
"
/
test_remove
.
json
"
{
addons
:
{
"
persistent
-
staged
-
remove
test
"
:
{
updates
:
[
{
version
:
"
2
.
0
"
update_link
:
"
http
:
/
/
example
.
com
/
addons
/
test_settings_staged_remove
.
xpi
"
}
]
}
}
}
)
;
let
extensionData
=
{
useAddonManager
:
"
permanent
"
manifest
:
{
version
:
"
2
.
0
"
applications
:
{
gecko
:
{
id
update_url
:
http
:
/
/
example
.
com
/
test_remove
.
json
}
}
permissions
:
[
"
tabs
"
"
http
:
/
/
example
.
com
/
"
]
}
background
(
)
{
browser
.
test
.
sendMessage
(
"
loaded
"
)
;
}
}
;
server
.
registerFile
(
/
addons
/
test_settings_staged_remove
.
xpi
AddonTestUtils
.
createTempWebExtensionFile
(
extensionData
)
)
;
await
promiseStartupManager
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
manifest
:
{
version
:
"
1
.
0
"
applications
:
{
gecko
:
{
id
update_url
:
http
:
/
/
example
.
com
/
test_remove
.
json
}
}
permissions
:
[
"
webRequest
"
"
http
:
/
/
example
.
com
/
"
]
}
background
(
)
{
browser
.
webRequest
.
onBeforeRequest
.
addListener
(
details
=
>
{
browser
.
test
.
sendMessage
(
"
got
-
request
"
)
;
}
{
urls
:
[
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
]
}
)
;
browser
.
runtime
.
onUpdateAvailable
.
addListener
(
async
details
=
>
{
if
(
details
&
&
details
.
version
)
{
browser
.
test
.
assertEq
(
"
2
.
0
"
details
.
version
"
correct
version
"
)
;
browser
.
test
.
sendMessage
(
"
delay
"
)
;
}
}
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
ExtensionTestUtils
.
fetch
(
"
http
:
/
/
example
.
com
/
"
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
)
;
await
extension
.
awaitMessage
(
"
got
-
request
"
)
;
ok
(
true
"
Initial
version
received
webRequest
event
"
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
Assert
.
equal
(
addon
.
version
"
1
.
0
"
"
1
.
0
is
loaded
"
)
;
let
update
=
await
AddonTestUtils
.
promiseFindAddonUpdates
(
addon
)
;
let
install
=
update
.
updateAvailable
;
Assert
.
ok
(
install
install
is
available
{
update
.
error
}
)
;
await
AddonTestUtils
.
promiseCompleteAllInstalls
(
[
install
]
)
;
Assert
.
equal
(
install
.
state
AddonManager
.
STATE_POSTPONED
"
update
is
staged
for
install
"
)
;
await
extension
.
awaitMessage
(
"
delay
"
)
;
await
promiseShutdownManager
(
)
;
await
promiseStartupManager
(
)
;
let
events
=
trackEvents
(
extension
)
;
await
extension
.
awaitStartup
(
)
;
let
policy
=
WebExtensionPolicy
.
getByID
(
id
)
;
ok
(
!
policy
.
hasPermission
(
"
webRequest
"
)
"
addon
webRequest
permission
removed
"
)
;
await
ExtensionTestUtils
.
fetch
(
"
http
:
/
/
example
.
com
/
"
"
http
:
/
/
example
.
com
/
data
/
file_sample
.
html
"
)
;
await
testPersistentRequestStartup
(
extension
events
{
background
:
false
delayedStart
:
false
request
:
false
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
windows
-
restored
"
)
;
await
extension
.
awaitMessage
(
"
loaded
"
)
;
ok
(
true
"
Background
page
loaded
"
)
;
await
extension
.
unload
(
)
;
await
promiseShutdownManager
(
)
;
}
)
;
