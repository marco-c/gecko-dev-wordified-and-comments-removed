"
use
strict
"
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
async
function
getColorFromAppliedTheme
(
)
{
const
{
LightweightThemeConsumer
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
LightweightThemeConsumer
.
sys
.
mjs
"
)
;
const
browser
=
Services
.
appShell
.
createWindowlessBrowser
(
true
)
;
const
document
=
browser
.
document
;
let
promise
=
new
Promise
(
resolve
=
>
{
document
.
defaultView
.
addEventListener
(
"
windowlwthemeupdate
"
resolve
{
once
:
true
}
)
;
}
)
;
new
LightweightThemeConsumer
(
document
)
;
info
(
"
Waiting
for
windowlwthemeupdate
from
LightweightThemeConsumer
"
)
;
await
promise
;
info
(
"
Got
windowlwthemeupdate
from
LightweightThemeConsumer
"
)
;
let
accentcolor
=
document
.
documentElement
.
style
.
getPropertyValue
(
"
-
-
lwt
-
accent
-
color
"
)
;
browser
.
close
(
)
;
return
accentcolor
;
}
function
loadStaticThemeExtension
(
manifest
)
{
const
extensionId
=
manifest
.
browser_specific_settings
.
gecko
.
id
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
useAddonManager
:
"
permanent
"
}
)
;
extension
.
onInstalling
=
function
(
addon
)
{
if
(
addon
.
id
=
=
=
extensionId
)
{
equal
(
addon
.
userDisabled
true
"
Static
theme
is
disabled
at
install
"
)
;
addon
.
__AddonInternal__
.
userDisabled
=
false
;
equal
(
addon
.
userDisabled
false
"
Static
theme
force
enabled
at
install
"
)
;
}
}
;
return
extension
;
}
add_setup
(
async
(
)
=
>
{
await
ExtensionTestUtils
.
startAddonManager
(
)
;
}
)
;
add_task
(
async
function
test_static_theme_startupData
(
)
{
const
DUMMY_COLOR
=
"
rgb
(
12
34
56
)
"
;
let
extension
=
loadStaticThemeExtension
(
{
browser_specific_settings
:
{
gecko
:
{
id
:
"
my
-
theme
"
}
}
theme
:
{
colors
:
{
frame
:
DUMMY_COLOR
}
}
}
)
;
await
extension
.
startup
(
)
;
let
startupDataOriginal
=
extension
.
extension
.
startupData
;
let
startupDataCopy
=
structuredClone
(
extension
.
extension
.
startupData
)
;
equal
(
await
getColorFromAppliedTheme
(
)
DUMMY_COLOR
"
Theme
applied
to
simulated
browser
window
"
)
;
equal
(
extension
.
extension
.
startupData
startupDataOriginal
"
startupData
should
be
the
same
value
(
extension
not
unloaded
)
"
)
;
Assert
.
deepEqual
(
extension
.
extension
.
startupData
startupDataCopy
"
startupData
should
not
have
been
changed
when
a
browser
window
was
opened
"
)
;
let
readyPromise
=
AddonTestUtils
.
promiseWebExtensionStartup
(
"
my
-
theme
"
)
;
info
(
"
Simulating
browser
restart
"
)
;
await
AddonTestUtils
.
promiseRestartManager
(
)
;
info
(
"
Waiting
for
theme
to
have
started
again
"
)
;
await
readyPromise
;
let
startupData
=
extension
.
extension
.
startupData
;
notEqual
(
startupData
startupDataOriginal
"
Not
trivially
equal
"
)
;
Assert
.
deepEqual
(
startupDataCopy
startupData
"
startupData
should
be
identical
when
the
theme
loads
again
"
)
;
ok
(
startupData
.
lwtData
"
startupData
.
lwtData
should
be
set
"
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_dynamic_theme_startupData
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
manifest_version
:
3
browser_specific_settings
:
{
gecko
:
{
id
:
"
my
-
dynamic
-
theme
"
}
}
permissions
:
[
"
theme
"
]
}
useAddonManager
:
"
permanent
"
background
(
)
{
browser
.
runtime
.
onInstalled
.
addListener
(
async
(
)
=
>
{
await
browser
.
theme
.
update
(
{
colors
:
{
frame
:
"
rgb
(
7
8
9
)
"
}
}
)
;
browser
.
test
.
sendMessage
(
"
onInstalled
"
)
;
}
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
onInstalled
"
)
;
equal
(
await
getColorFromAppliedTheme
(
)
"
rgb
(
7
8
9
)
"
"
Dynamic
theme
applies
to
simulated
browser
window
"
)
;
let
startupData
=
extension
.
extension
.
startupData
;
Assert
.
deepEqual
(
Object
.
keys
(
startupData
)
[
"
persistentListeners
"
]
"
startupData
should
not
have
unexpected
properties
from
ext
-
theme
.
js
"
)
;
assertPersistentListeners
(
extension
"
runtime
"
"
onInstalled
"
{
primed
:
false
persisted
:
true
}
)
;
await
extension
.
unload
(
)
;
}
)
;
