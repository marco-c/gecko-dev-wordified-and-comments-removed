"
use
strict
"
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
Subprocess
:
"
resource
:
/
/
gre
/
modules
/
Subprocess
.
sys
.
mjs
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
}
)
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
42
"
)
;
const
SESSION_HANDLE
=
"
/
org
/
freedesktop
/
portal
/
desktop
/
session
/
foobar
/
firefox_xpcshell_tests_mozilla_org_42
"
;
const
portalBusName
=
"
org
.
freedesktop
.
portal
.
Desktop
"
;
const
portalObjectPath
=
"
/
org
/
freedesktop
/
portal
/
desktop
"
;
const
portalInterfaceName
=
"
org
.
freedesktop
.
portal
.
WebExtensions
"
;
const
sessionInterfaceName
=
"
org
.
freedesktop
.
portal
.
Session
"
;
const
dbusMockInterface
=
"
org
.
freedesktop
.
DBus
.
Mock
"
;
const
addObjectMethod
=
{
dbusMockInterface
}
.
AddObject
;
const
addMethodMethod
=
{
dbusMockInterface
}
.
AddMethod
;
const
addPropertyMethod
=
{
dbusMockInterface
}
.
AddProperty
;
const
updatePropertiesMethod
=
{
dbusMockInterface
}
.
UpdateProperties
;
const
emitSignalDetailedMethod
=
{
dbusMockInterface
}
.
EmitSignalDetailed
;
const
getCallsMethod
=
{
dbusMockInterface
}
.
GetCalls
;
const
clearCallsMethod
=
{
dbusMockInterface
}
.
ClearCalls
;
const
resetMethod
=
{
dbusMockInterface
}
.
Reset
;
const
mockRequestObjectPath
=
"
/
org
/
freedesktop
/
portal
/
desktop
/
request
"
;
const
mockManifest
=
'
{
"
name
"
:
"
echo
"
"
description
"
:
"
a
native
connector
"
"
type
"
:
"
stdio
"
"
path
"
:
"
/
usr
/
bin
/
echo
"
"
allowed_extensions
"
:
[
"
native
tests
.
mozilla
.
org
"
]
}
'
;
const
nativeMessagingPref
=
"
widget
.
use
-
xdg
-
desktop
-
portal
.
native
-
messaging
"
;
var
DBUS_SESSION_BUS_ADDRESS
=
"
"
;
var
DBUS_SESSION_BUS_PID
=
0
;
var
DBUS_MOCK
=
null
;
var
FDS_MOCK
=
null
;
var
gdbusCmd
=
null
;
async
function
background
(
)
{
let
port
;
browser
.
test
.
onMessage
.
addListener
(
async
(
what
payload
)
=
>
{
if
(
what
=
=
"
request
"
)
{
await
browser
.
permissions
.
request
(
{
permissions
:
[
"
nativeMessaging
"
]
}
)
;
port
=
browser
.
runtime
.
connectNative
(
"
echo
"
)
;
port
.
onMessage
.
addListener
(
msg
=
>
{
browser
.
test
.
sendMessage
(
"
message
"
msg
)
;
}
)
;
browser
.
test
.
sendMessage
(
"
ready
"
)
;
}
else
if
(
what
=
=
"
send
"
)
{
if
(
payload
.
_json
)
{
let
json
=
payload
.
_json
;
payload
.
toJSON
=
(
)
=
>
json
;
delete
payload
.
_json
;
}
port
.
postMessage
(
payload
)
;
}
}
)
;
}
async
function
mockSetup
(
objectPath
methodName
args
)
{
let
mockProcess
=
await
lazy
.
Subprocess
.
call
(
{
command
:
gdbusCmd
arguments
:
[
"
call
"
"
-
-
session
"
"
-
d
"
portalBusName
"
-
o
"
objectPath
"
-
m
"
methodName
.
.
.
args
]
}
)
;
return
mockProcess
.
wait
(
)
;
}
add_setup
(
async
function
(
)
{
let
dbus
=
await
lazy
.
Subprocess
.
call
(
{
command
:
await
lazy
.
Subprocess
.
pathSearch
(
"
dbus
-
launch
"
)
}
)
;
let
stdout
=
await
dbus
.
stdout
.
readString
(
)
;
let
lines
=
stdout
.
split
(
"
\
n
"
)
;
for
(
let
i
in
lines
)
{
let
tokens
=
lines
[
i
]
.
split
(
"
=
"
)
;
switch
(
tokens
.
shift
(
)
)
{
case
"
DBUS_SESSION_BUS_ADDRESS
"
:
DBUS_SESSION_BUS_ADDRESS
=
tokens
.
join
(
"
=
"
)
;
break
;
case
"
DBUS_SESSION_BUS_PID
"
:
DBUS_SESSION_BUS_PID
=
tokens
.
join
(
)
;
break
;
default
:
}
}
let
prefValue
=
Services
.
prefs
.
getIntPref
(
nativeMessagingPref
0
)
;
gdbusCmd
=
await
lazy
.
Subprocess
.
pathSearch
(
"
gdbus
"
)
;
Services
.
prefs
.
setIntPref
(
nativeMessagingPref
2
)
;
Services
.
env
.
set
(
"
DBUS_SESSION_BUS_ADDRESS
"
DBUS_SESSION_BUS_ADDRESS
)
;
Services
.
env
.
set
(
"
GTK_USE_PORTAL
"
"
1
"
)
;
DBUS_MOCK
=
await
lazy
.
Subprocess
.
call
(
{
command
:
await
lazy
.
Subprocess
.
pathSearch
(
"
python3
"
)
arguments
:
[
"
-
m
"
"
dbusmock
"
portalBusName
portalObjectPath
portalInterfaceName
]
}
)
;
await
lazy
.
TestUtils
.
waitForCondition
(
async
(
)
=
>
{
let
res
=
await
mockSetup
(
portalObjectPath
"
org
.
freedesktop
.
DBus
.
Mock
.
GetCalls
"
[
]
)
;
return
res
.
exitCode
=
=
0
;
}
"
waiting
for
dbusmock
"
)
;
FDS_MOCK
=
await
lazy
.
Subprocess
.
call
(
{
command
:
await
lazy
.
Subprocess
.
pathSearch
(
"
tail
"
)
arguments
:
[
"
-
f
"
"
/
dev
/
null
"
]
stderr
:
"
pipe
"
}
)
;
registerCleanupFunction
(
async
function
(
)
{
await
FDS_MOCK
.
kill
(
)
;
await
mockSetup
(
portalObjectPath
resetMethod
[
]
)
;
await
DBUS_MOCK
.
kill
(
)
;
Services
.
prefs
.
setIntPref
(
nativeMessagingPref
prefValue
)
;
}
)
;
await
mockSetup
(
portalObjectPath
addPropertyMethod
[
portalInterfaceName
"
version
"
"
<
uint32
1
>
"
]
)
;
await
mockSetup
(
portalObjectPath
addMethodMethod
[
portalInterfaceName
"
CreateSession
"
"
a
{
sv
}
"
"
o
"
ret
=
"
{
SESSION_HANDLE
}
"
]
)
;
await
mockSetup
(
portalObjectPath
addObjectMethod
[
SESSION_HANDLE
sessionInterfaceName
"
a
{
sv
}
{
}
"
"
a
(
ssss
)
[
(
'
Close
'
'
'
'
'
'
'
)
]
"
]
)
;
await
mockSetup
(
portalObjectPath
addMethodMethod
[
portalInterfaceName
"
GetManifest
"
"
oss
"
"
s
"
ret
=
'
{
mockManifest
}
'
]
)
;
await
mockSetup
(
portalObjectPath
addMethodMethod
[
portalInterfaceName
"
Start
"
"
ossa
{
sv
}
"
"
o
"
ret
=
"
{
mockRequestObjectPath
}
/
foobar
"
]
)
;
await
mockSetup
(
portalObjectPath
addMethodMethod
[
portalInterfaceName
"
GetPipes
"
"
oa
{
sv
}
"
"
hhh
"
ret
=
(
dbus
.
types
.
UnixFd
(
{
FDS_MOCK
.
stdin
.
fd
}
)
dbus
.
types
.
UnixFd
(
{
FDS_MOCK
.
stdout
.
fd
}
)
dbus
.
types
.
UnixFd
(
{
FDS_MOCK
.
stderr
.
fd
}
)
)
]
)
;
optionalPermissionsPromptHandler
.
init
(
)
;
optionalPermissionsPromptHandler
.
acceptPrompt
=
true
;
await
AddonTestUtils
.
promiseStartupManager
(
)
;
await
setupHosts
(
[
]
)
;
}
)
;
async
function
verifyDbusMockCall
(
objectPath
method
offset
)
{
let
getCalls
=
await
lazy
.
Subprocess
.
call
(
{
command
:
gdbusCmd
arguments
:
[
"
call
"
"
-
-
session
"
"
-
d
"
portalBusName
"
-
o
"
objectPath
"
-
m
"
getCallsMethod
]
}
)
;
let
out
=
await
getCalls
.
stdout
.
readString
(
)
;
out
=
out
.
match
(
/
\
(
(
a
\
(
tsav
\
)
)
?
\
[
(
.
*
)
\
]
\
)
/
)
[
2
]
;
let
calls
=
out
.
matchAll
(
/
\
(
.
*
?
\
)
?
/
g
)
;
let
methodCalled
=
false
;
let
params
=
{
}
;
let
i
=
0
;
for
(
let
call
of
calls
)
{
if
(
i
+
+
<
offset
)
{
continue
;
}
let
matches
=
call
[
0
]
.
match
(
/
\
(
(
uint64
)
?
(
?
<
timestamp
>
\
d
+
)
'
(
?
<
method
>
\
w
+
)
'
(
av
)
?
\
[
(
?
<
params
>
.
*
)
\
]
\
)
?
/
)
;
ok
(
parseFloat
(
matches
.
groups
.
timestamp
)
"
timestamp
is
valid
"
)
;
if
(
matches
.
groups
.
method
=
=
method
)
{
methodCalled
=
true
;
params
=
matches
.
groups
.
params
;
break
;
}
}
if
(
method
)
{
ok
(
methodCalled
The
{
method
}
mock
was
called
)
;
}
else
{
equal
(
i
0
"
No
method
mock
was
called
"
)
;
}
return
{
offset
:
i
params
:
params
}
;
}
add_task
(
async
function
test_talk_to_portal
(
)
{
await
mockSetup
(
portalObjectPath
clearCallsMethod
[
]
)
;
await
mockSetup
(
portalObjectPath
updatePropertiesMethod
[
portalInterfaceName
"
{
'
version
'
:
<
uint32
1
>
}
"
]
)
;
let
dbusMonitor
=
await
lazy
.
Subprocess
.
call
(
{
command
:
await
lazy
.
Subprocess
.
pathSearch
(
"
dbus
-
monitor
"
)
arguments
:
[
"
-
-
session
"
interface
=
'
{
portalInterfaceName
}
'
member
=
'
CreateSession
'
]
}
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
manifest
:
{
applications
:
{
gecko
:
{
id
:
ID
}
}
optional_permissions
:
[
"
nativeMessaging
"
]
}
useAddonManager
:
"
temporary
"
}
)
;
await
extension
.
startup
(
)
;
await
withHandlingUserInput
(
extension
async
(
)
=
>
{
extension
.
sendMessage
(
"
request
"
)
;
await
extension
.
awaitMessage
(
"
ready
"
)
;
}
)
;
let
handleToken
=
"
"
;
let
senderName
=
"
"
;
let
result
=
await
verifyDbusMockCall
(
portalObjectPath
"
CreateSession
"
0
)
;
result
=
await
verifyDbusMockCall
(
portalObjectPath
"
GetManifest
"
result
.
offset
)
;
result
=
await
verifyDbusMockCall
(
portalObjectPath
"
Start
"
result
.
offset
)
;
let
match
=
result
.
params
.
match
(
/
{
'
handle_token
'
:
<
'
(
?
<
token
>
.
*
)
'
>
}
/
)
;
ok
(
match
"
Start
arguments
contain
a
handle
token
"
)
;
handleToken
=
match
.
groups
.
token
;
let
dbusMonitorOutput
=
await
dbusMonitor
.
stdout
.
readString
(
)
;
let
lines
=
dbusMonitorOutput
.
split
(
"
\
n
"
)
;
for
(
let
i
in
lines
)
{
let
line
=
lines
[
i
]
;
if
(
!
line
)
{
continue
;
}
if
(
line
.
startsWith
(
"
method
call
"
)
)
{
let
match
=
line
.
match
(
/
sender
=
(
\
S
*
)
/
)
;
ok
(
match
"
dbus
-
monitor
output
informs
us
of
the
sender
"
)
;
senderName
=
match
[
1
]
;
}
}
ok
(
senderName
"
Got
the
sender
name
"
)
;
await
dbusMonitor
.
kill
(
)
;
let
requestPath
=
{
mockRequestObjectPath
}
/
{
senderName
.
slice
(
1
)
.
replace
(
"
.
"
"
_
"
)
}
/
{
handleToken
}
;
await
mockSetup
(
portalObjectPath
addObjectMethod
[
requestPath
"
org
.
freedesktop
.
portal
.
Request
"
"
a
{
sv
}
{
}
"
"
a
(
ssss
)
[
]
"
]
)
;
let
waitForRequestObject
=
await
lazy
.
Subprocess
.
call
(
{
command
:
gdbusCmd
arguments
:
[
"
introspect
"
"
-
-
session
"
"
-
d
"
portalBusName
"
-
o
"
requestPath
"
-
p
"
]
}
)
;
await
waitForRequestObject
.
wait
(
)
;
await
mockSetup
(
requestPath
emitSignalDetailedMethod
[
"
org
.
freedesktop
.
portal
.
Request
"
"
Response
"
"
ua
{
sv
}
"
"
[
<
uint32
0
>
<
a
{
sv
}
{
}
>
]
"
{
'
destination
'
:
<
'
{
senderName
}
'
>
}
]
)
;
await
verifyDbusMockCall
(
portalObjectPath
"
GetPipes
"
result
.
offset
)
;
await
extension
.
unload
(
)
;
await
verifyDbusMockCall
(
SESSION_HANDLE
"
Close
"
0
)
;
}
)
;
add_task
(
async
function
test_portal_unavailable
(
)
{
await
mockSetup
(
portalObjectPath
clearCallsMethod
[
]
)
;
await
mockSetup
(
portalObjectPath
updatePropertiesMethod
[
portalInterfaceName
"
{
'
version
'
:
<
uint32
0
>
}
"
]
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
manifest
:
{
applications
:
{
gecko
:
{
id
:
ID
}
}
optional_permissions
:
[
"
nativeMessaging
"
]
}
useAddonManager
:
"
temporary
"
}
)
;
let
logged
=
false
;
function
listener
(
msg
)
{
logged
|
|
=
/
Native
messaging
portal
is
not
available
/
.
test
(
msg
.
message
)
;
}
Services
.
console
.
registerListener
(
listener
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
console
.
unregisterListener
(
listener
)
;
}
)
;
await
extension
.
startup
(
)
;
await
withHandlingUserInput
(
extension
async
(
)
=
>
{
extension
.
sendMessage
(
"
request
"
)
;
await
extension
.
awaitMessage
(
"
ready
"
)
;
}
)
;
ok
(
logged
"
Non
availability
of
the
portal
was
logged
"
)
;
await
verifyDbusMockCall
(
portalObjectPath
null
0
)
;
await
extension
.
unload
(
)
;
}
)
;
