"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LegacyExtensionsUtils
.
jsm
"
)
;
const
{
EmbeddedExtensionManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LegacyExtensionsUtils
.
jsm
"
{
}
)
;
add_task
(
async
function
test_embedded_webextension_utils
(
)
{
function
backgroundScript
(
)
{
let
port
=
browser
.
runtime
.
connect
(
)
;
port
.
onMessage
.
addListener
(
(
msg
)
=
>
{
if
(
msg
=
=
"
legacy_extension
-
>
webextension
"
)
{
port
.
postMessage
(
"
webextension
-
>
legacy_extension
"
)
;
port
.
disconnect
(
)
;
}
}
)
;
}
const
id
=
"
test
.
embedded
.
web
.
extension
"
;
let
fakeHybridAddonFile
=
Extension
.
generateZipFile
(
{
"
webextension
/
manifest
.
json
"
:
{
applications
:
{
gecko
:
{
id
}
}
name
:
"
embedded
webextension
name
"
manifest_version
:
2
version
:
"
1
.
0
"
background
:
{
scripts
:
[
"
bg
.
js
"
]
}
}
"
webextension
/
bg
.
js
"
:
new
{
backgroundScript
}
}
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
fakeHybridAddonFile
"
flush
-
cache
-
entry
"
)
;
fakeHybridAddonFile
.
remove
(
false
)
;
}
)
;
let
fileURI
=
Services
.
io
.
newFileURI
(
fakeHybridAddonFile
)
;
let
resourceURI
=
Services
.
io
.
newURI
(
jar
:
{
fileURI
.
spec
}
!
/
)
;
let
embeddedExtension
=
LegacyExtensionsUtils
.
getEmbeddedExtensionFor
(
{
id
resourceURI
}
)
;
ok
(
embeddedExtension
"
Got
the
embeddedExtension
object
"
)
;
equal
(
EmbeddedExtensionManager
.
embeddedExtensionsByAddonId
.
size
1
"
Got
the
expected
number
of
tracked
embedded
extension
instances
"
)
;
info
(
"
waiting
embeddedExtension
.
startup
"
)
;
let
embeddedExtensionAPI
=
await
embeddedExtension
.
startup
(
)
;
ok
(
embeddedExtensionAPI
"
Got
the
embeddedExtensionAPI
object
"
)
;
let
waitConnectPort
=
new
Promise
(
resolve
=
>
{
let
{
browser
}
=
embeddedExtensionAPI
;
browser
.
runtime
.
onConnect
.
addListener
(
port
=
>
{
resolve
(
port
)
;
}
)
;
}
)
;
let
port
=
await
waitConnectPort
;
ok
(
port
"
Got
the
Port
API
object
"
)
;
let
waitPortMessage
=
new
Promise
(
resolve
=
>
{
port
.
onMessage
.
addListener
(
(
msg
)
=
>
{
resolve
(
msg
)
;
}
)
;
}
)
;
port
.
postMessage
(
"
legacy_extension
-
>
webextension
"
)
;
let
msg
=
await
waitPortMessage
;
equal
(
msg
"
webextension
-
>
legacy_extension
"
"
LegacyExtensionContext
received
the
expected
message
from
the
webextension
"
)
;
let
waitForDisconnect
=
new
Promise
(
resolve
=
>
{
port
.
onDisconnect
.
addListener
(
resolve
)
;
}
)
;
info
(
"
Wait
for
the
disconnect
port
event
"
)
;
await
waitForDisconnect
;
info
(
"
Got
the
disconnect
port
event
"
)
;
await
embeddedExtension
.
shutdown
(
)
;
equal
(
EmbeddedExtensionManager
.
embeddedExtensionsByAddonId
.
size
0
"
EmbeddedExtension
instances
has
been
untracked
from
the
EmbeddedExtensionManager
"
)
;
}
)
;
async
function
createManifestErrorTestCase
(
id
xpi
expectedError
)
{
registerCleanupFunction
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
xpi
"
flush
-
cache
-
entry
"
)
;
xpi
.
remove
(
false
)
;
}
)
;
let
fileURI
=
Services
.
io
.
newFileURI
(
xpi
)
;
let
resourceURI
=
Services
.
io
.
newURI
(
jar
:
{
fileURI
.
spec
}
!
/
)
;
let
embeddedExtension
=
LegacyExtensionsUtils
.
getEmbeddedExtensionFor
(
{
id
resourceURI
}
)
;
await
Assert
.
rejects
(
embeddedExtension
.
startup
(
)
expectedError
"
embedded
extension
startup
rejected
"
)
;
await
embeddedExtension
.
shutdown
(
)
;
}
add_task
(
async
function
test_startup_error_empty_manifest
(
)
{
const
id
=
"
empty
-
manifest
test
.
embedded
.
web
.
extension
"
;
const
files
=
{
"
webextension
/
manifest
.
json
"
:
}
;
const
expectedError
=
/
NS_BASE_STREAM_CLOSED
/
;
let
fakeHybridAddonFile
=
Extension
.
generateZipFile
(
files
)
;
await
createManifestErrorTestCase
(
id
fakeHybridAddonFile
expectedError
)
;
}
)
;
add_task
(
async
function
test_startup_error_invalid_json_manifest
(
)
{
const
id
=
"
invalid
-
json
-
manifest
test
.
embedded
.
web
.
extension
"
;
const
files
=
{
"
webextension
/
manifest
.
json
"
:
{
"
name
"
:
}
}
;
const
expectedError
=
/
JSON
.
parse
:
/
;
let
fakeHybridAddonFile
=
Extension
.
generateZipFile
(
files
)
;
await
createManifestErrorTestCase
(
id
fakeHybridAddonFile
expectedError
)
;
}
)
;
add_task
(
async
function
test_startup_error_blocking_validation_errors
(
)
{
const
id
=
"
blocking
-
manifest
-
validation
-
error
test
.
embedded
.
web
.
extension
"
;
const
files
=
{
"
webextension
/
manifest
.
json
"
:
{
name
:
"
embedded
webextension
name
"
manifest_version
:
2
version
:
"
1
.
0
"
background
:
{
scripts
:
{
}
}
}
}
;
function
expectedError
(
actual
)
{
if
(
actual
.
errors
&
&
actual
.
errors
.
length
=
=
1
&
&
actual
.
errors
[
0
]
.
startsWith
(
"
Reading
manifest
:
"
)
)
{
return
true
;
}
return
false
;
}
let
fakeHybridAddonFile
=
Extension
.
generateZipFile
(
files
)
;
await
createManifestErrorTestCase
(
id
fakeHybridAddonFile
expectedError
)
;
}
)
;
