"
use
strict
"
;
const
{
ExtensionTestCommon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
ExtensionTestCommon
.
sys
.
mjs
"
)
;
add_setup
(
(
)
=
>
{
Services
.
prefs
.
setIntPref
(
"
extensions
.
background
.
idle
.
timeout
"
1000
)
;
}
)
;
async
function
loadEventPageAndExtensionPage
(
{
backgroundScript
extensionPageScript
}
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
startupReason
:
"
APP_STARTUP
"
delayedStartup
:
true
manifest
:
{
background
:
{
persistent
:
false
}
}
background
:
backgroundScript
files
:
{
"
page
.
html
"
:
<
!
DOCTYPE
html
>
<
script
src
=
"
page
.
js
"
>
<
/
script
>
"
page
.
js
"
:
extensionPageScript
}
}
)
;
await
ExtensionTestCommon
.
resetStartupPromises
(
)
;
await
extension
.
startup
(
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
moz
-
extension
:
/
/
{
extension
.
uuid
}
/
page
.
html
)
;
info
(
"
Extension
page
loaded
permitting
event
page
to
start
up
"
)
;
await
ExtensionTestCommon
.
notifyEarlyStartup
(
)
;
await
ExtensionTestCommon
.
notifyLateStartup
(
)
;
await
extension
.
awaitMessage
(
"
FINAL_SUSPEND
"
)
;
info
(
"
Received
FINAL_SUSPEND
awaiting
full
event
page
shutdown
.
"
)
;
await
promiseExtensionEvent
(
extension
"
shutdown
-
background
-
script
"
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
add_task
(
async
function
test_runtime_onMessage_cancels_suspend
(
)
{
await
loadEventPageAndExtensionPage
(
{
backgroundScript
(
)
{
browser
.
runtime
.
onMessage
.
addListener
(
msg
=
>
{
return
Promise
.
resolve
(
bg_pong
:
{
msg
}
)
;
}
)
;
}
extensionPageScript
(
)
{
let
cancelCount
=
0
;
browser
.
runtime
.
onSuspendCanceled
.
addListener
(
(
)
=
>
{
browser
.
test
.
assertEq
(
1
+
+
cancelCount
"
onSuspendCanceled
1x
"
)
;
}
)
;
let
suspendCount
=
0
;
let
firstSuspendTestCompleted
=
false
;
browser
.
runtime
.
onSuspend
.
addListener
(
async
(
)
=
>
{
if
(
+
+
suspendCount
=
=
=
1
)
{
browser
.
test
.
assertEq
(
0
cancelCount
"
Not
suspended
yet
"
)
;
let
res
=
await
browser
.
runtime
.
sendMessage
(
"
ping
"
)
;
browser
.
test
.
assertEq
(
1
cancelCount
"
onMessage
cancels
suspend
"
)
;
browser
.
test
.
assertEq
(
"
bg_pong
:
ping
"
res
"
onMessage
result
"
)
;
firstSuspendTestCompleted
=
true
;
}
else
{
browser
.
test
.
assertTrue
(
firstSuspendTestCompleted
"
First
test
done
"
)
;
browser
.
test
.
assertEq
(
2
suspendCount
"
Second
onSuspend
"
)
;
browser
.
test
.
sendMessage
(
"
FINAL_SUSPEND
"
)
;
}
}
)
;
browser
.
test
.
log
(
"
Waiting
for
background
to
be
suspended
"
)
;
}
}
)
;
}
)
;
add_task
(
async
function
test_runtime_onConnect_cancels_suspend
(
)
{
await
loadEventPageAndExtensionPage
(
{
backgroundScript
(
)
{
browser
.
runtime
.
onConnect
.
addListener
(
(
)
=
>
{
globalThis
.
notify_extensionPage_got_onConnect
(
)
;
}
)
;
}
extensionPageScript
(
)
{
let
cancelCount
=
0
;
browser
.
runtime
.
onSuspendCanceled
.
addListener
(
(
)
=
>
{
browser
.
test
.
assertEq
(
1
+
+
cancelCount
"
onSuspendCanceled
1x
"
)
;
}
)
;
let
suspendCount
=
0
;
let
firstSuspendTestCompleted
=
false
;
let
port
;
browser
.
runtime
.
onSuspend
.
addListener
(
async
(
)
=
>
{
if
(
+
+
suspendCount
=
=
=
1
)
{
browser
.
test
.
assertEq
(
0
cancelCount
"
Not
suspended
yet
"
)
;
for
(
let
i
=
0
;
i
<
2
;
+
+
i
)
{
await
new
Promise
(
resolve
=
>
{
let
bgGlobal
=
browser
.
extension
.
getBackgroundPage
(
)
;
browser
.
test
.
assertTrue
(
!
!
bgGlobal
"
Event
page
still
running
"
)
;
bgGlobal
.
notify_extensionPage_got_onConnect
=
resolve
;
port
=
browser
.
runtime
.
connect
(
{
}
)
;
}
)
;
}
browser
.
test
.
assertEq
(
1
cancelCount
"
onConnect
cancels
suspend
"
)
;
firstSuspendTestCompleted
=
true
;
}
else
{
browser
.
test
.
assertTrue
(
firstSuspendTestCompleted
"
First
test
done
"
)
;
browser
.
test
.
assertEq
(
2
suspendCount
"
Second
onSuspend
"
)
;
browser
.
test
.
assertEq
(
null
port
.
error
"
port
has
no
error
"
)
;
browser
.
test
.
sendMessage
(
"
FINAL_SUSPEND
"
)
;
}
}
)
;
browser
.
test
.
log
(
"
Waiting
for
background
to
be
suspended
"
)
;
}
}
)
;
}
)
;
add_task
(
async
function
test_runtime_Port_onMessage_cancels_suspend
(
)
{
await
loadEventPageAndExtensionPage
(
{
backgroundScript
(
)
{
browser
.
runtime
.
onConnect
.
addListener
(
port
=
>
{
port
.
onMessage
.
addListener
(
(
)
=
>
{
globalThis
.
notify_extensionPage_got_port_onMessage
(
)
;
}
)
;
}
)
;
}
extensionPageScript
(
)
{
let
cancelCount
=
0
;
browser
.
runtime
.
onSuspendCanceled
.
addListener
(
(
)
=
>
{
browser
.
test
.
assertEq
(
1
+
+
cancelCount
"
onSuspendCanceled
1x
"
)
;
}
)
;
let
suspendCount
=
0
;
let
firstSuspendTestCompleted
=
false
;
let
port
;
browser
.
runtime
.
onSuspend
.
addListener
(
async
(
)
=
>
{
if
(
+
+
suspendCount
=
=
=
1
)
{
browser
.
test
.
assertEq
(
0
cancelCount
"
Not
suspended
yet
"
)
;
browser
.
test
.
assertTrue
(
!
!
port
"
Should
run
after
we
opened
a
port
"
)
;
for
(
let
i
=
0
;
i
<
2
;
+
+
i
)
{
await
new
Promise
(
resolve
=
>
{
let
bgGlobal
=
browser
.
extension
.
getBackgroundPage
(
)
;
browser
.
test
.
assertTrue
(
!
!
bgGlobal
"
Event
page
still
running
"
)
;
bgGlobal
.
notify_extensionPage_got_port_onMessage
=
resolve
;
port
.
postMessage
(
"
"
)
;
}
)
;
}
browser
.
test
.
assertEq
(
1
cancelCount
"
port
.
onMessage
cancels
suspend
"
)
;
firstSuspendTestCompleted
=
true
;
}
else
{
browser
.
test
.
assertTrue
(
firstSuspendTestCompleted
"
First
test
done
"
)
;
browser
.
test
.
assertEq
(
2
suspendCount
"
Second
onSuspend
"
)
;
browser
.
test
.
sendMessage
(
"
FINAL_SUSPEND
"
)
;
}
}
)
;
browser
.
runtime
.
getBackgroundPage
(
bgGlobal
=
>
{
browser
.
test
.
assertTrue
(
!
!
bgGlobal
"
Event
page
has
started
"
)
;
port
=
browser
.
runtime
.
connect
(
{
}
)
;
browser
.
test
.
log
(
"
Waiting
for
background
to
be
suspended
"
)
;
}
)
;
}
}
)
;
}
)
;
