"
use
strict
"
;
const
server
=
createHttpServer
(
{
hosts
:
[
"
origin
.
example
.
net
"
"
example
.
com
"
]
}
)
;
server
.
registerPathHandler
(
"
/
home
"
(
)
=
>
{
}
)
;
server
.
registerPathHandler
(
"
/
dummy
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
setHeader
(
"
Access
-
Control
-
Allow
-
Origin
"
"
http
:
/
/
origin
.
example
.
net
"
)
;
response
.
write
(
"
Server
'
s
reply
"
)
;
}
)
;
const
EXPECT_TRUTHY
=
Symbol
(
"
EXPECT_TRUTHY
"
)
;
const
EXPECT_FALSEY
=
Symbol
(
"
EXPECT_FALSEY
"
)
;
const
EXPECTATION_BASIC_FETCH
=
{
id
:
EXPECT_TRUTHY
channel
:
EXPECT_TRUTHY
contentType
:
"
"
method
:
"
GET
"
type
:
"
xmlhttprequest
"
suspended
:
false
finalURI
:
EXPECT_TRUTHY
finalURL
:
"
http
:
/
/
example
.
com
/
dummy
"
statusCode
:
0
statusLine
:
"
"
errorString
:
null
onerror
:
null
onstart
:
null
onstop
:
null
proxyInfo
:
EXPECT_TRUTHY
remoteAddress
:
null
loadInfo
:
EXPECT_TRUTHY
isServiceWorkerScript
:
false
isSystemLoad
:
false
originURL
:
"
http
:
/
/
origin
.
example
.
net
/
home
"
documentURL
:
"
http
:
/
/
origin
.
example
.
net
/
home
"
originURI
:
EXPECT_TRUTHY
documentURI
:
EXPECT_TRUTHY
canModify
:
true
frameId
:
0
parentFrameId
:
-
1
browserElement
:
EXPECT_TRUTHY
frameAncestors
:
[
]
urlClassification
:
{
firstParty
:
[
]
thirdParty
:
[
]
}
thirdParty
:
true
requestSize
:
0
responseSize
:
0
}
;
const
EXPECTATION_BASIC_FETCH_COMPLETED
=
{
.
.
.
EXPECTATION_BASIC_FETCH
contentType
:
"
text
/
plain
"
statusCode
:
200
statusLine
:
"
HTTP
/
1
.
1
200
OK
"
remoteAddress
:
"
127
.
0
.
0
.
1
"
browserElement
:
EXPECT_FALSEY
requestSize
:
EXPECT_TRUTHY
responseSize
:
EXPECT_TRUTHY
}
;
const
EXPECTATION_BASIC_FETCH_ABORTED
=
{
.
.
.
EXPECTATION_BASIC_FETCH
errorString
:
"
NS_ERROR_ABORT
"
browserElement
:
EXPECT_FALSEY
}
;
const
EXPECTATION_INVALID_CHANNEL
=
{
id
:
EXPECT_TRUTHY
channel
:
EXPECT_FALSEY
contentType
:
"
"
method
:
"
"
type
:
"
other
"
suspended
:
false
finalURI
:
EXPECT_FALSEY
finalURL
:
"
"
statusCode
:
0
statusLine
:
"
"
errorString
:
"
NS_ERROR_UNEXPECTED
"
onerror
:
null
onstart
:
null
onstop
:
null
proxyInfo
:
null
remoteAddress
:
null
loadInfo
:
null
isServiceWorkerScript
:
false
isSystemLoad
:
false
originURL
:
"
"
documentURL
:
"
"
originURI
:
null
documentURI
:
null
canModify
:
false
frameId
:
0
parentFrameId
:
-
1
browserElement
:
EXPECT_FALSEY
frameAncestors
:
null
urlClassification
:
{
firstParty
:
[
]
thirdParty
:
[
]
}
thirdParty
:
false
requestSize
:
0
responseSize
:
0
}
;
function
channelWrapperEquals
(
channelWrapper
expectedProps
)
{
for
(
let
[
k
v
]
of
Object
.
entries
(
expectedProps
)
)
{
if
(
v
=
=
=
EXPECT_TRUTHY
)
{
Assert
.
ok
(
channelWrapper
[
k
]
ChannelWrapper
.
{
k
}
is
truthy
)
;
}
else
if
(
v
=
=
=
EXPECT_FALSEY
)
{
Assert
.
ok
(
!
channelWrapper
[
k
]
ChannelWrapper
.
{
k
}
is
falsey
)
;
}
else
{
Assert
.
deepEqual
(
channelWrapper
[
k
]
v
ChannelWrapper
.
{
k
}
)
;
}
}
}
let
gContentPage
;
async
function
forceChannelGC
(
)
{
await
Promise
.
resolve
(
)
;
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
}
function
checkChannelWrapperMethodsAfterGC
(
channelWrapper
)
{
const
dummyURI
=
Services
.
io
.
newURI
(
"
http
:
/
/
example
.
com
/
neverloaded
"
)
;
const
dummyPolicy
=
new
WebExtensionPolicy
(
{
id
:
"
dummyPolicy
"
mozExtensionHostname
:
"
c3c73091
-
8fab
-
4229
-
83cf
-
84c061dd9ead
"
baseURL
:
"
resource
:
/
/
modules
/
whatever_does_not_need_to_exist
"
allowedOrigins
:
new
MatchPatternSet
(
[
"
*
:
/
/
*
/
*
"
]
)
localizeCallback
:
(
)
=
>
"
"
}
)
;
Assert
.
throws
(
(
)
=
>
channelWrapper
.
cancel
(
0
)
/
NS_ERROR_UNEXPECTED
/
"
channelWrapper
.
cancel
(
)
throws
"
)
;
Assert
.
throws
(
(
)
=
>
channelWrapper
.
redirectTo
(
dummyURI
)
/
NS_ERROR_UNEXPECTED
/
"
channelWrapper
.
redirectTo
(
)
throws
"
)
;
Assert
.
throws
(
(
)
=
>
channelWrapper
.
upgradeToSecure
(
)
/
NS_ERROR_UNEXPECTED
/
"
channelWrapper
.
upgradeToSecure
(
)
throws
"
)
;
Assert
.
throws
(
(
)
=
>
channelWrapper
.
suspend
(
"
"
)
/
NS_ERROR_UNEXPECTED
/
"
channelWrapper
.
suspend
(
)
throws
"
)
;
Assert
.
equal
(
channelWrapper
.
resume
(
)
undefined
"
channelWrapper
.
resume
(
)
returns
"
)
;
Assert
.
equal
(
channelWrapper
.
matches
(
{
}
null
{
}
)
false
"
channelWrapper
.
matches
(
)
returns
"
)
;
Assert
.
equal
(
channelWrapper
.
registerTraceableChannel
(
dummyPolicy
null
)
undefined
"
registerTraceableChannel
(
)
returns
"
)
;
Assert
.
equal
(
channelWrapper
.
errorCheck
(
)
undefined
"
errorCheck
(
)
returns
"
)
;
Assert
.
throws
(
(
)
=
>
channelWrapper
.
getRequestHeaders
(
)
/
NS_ERROR_UNEXPECTED
/
"
channelWrapper
.
getRequestHeaders
(
)
throws
"
)
;
Assert
.
throws
(
(
)
=
>
channelWrapper
.
getRequestHeader
(
"
Content
-
Type
"
)
/
NS_ERROR_UNEXPECTED
/
"
channelWrapper
.
getRequestHeader
(
)
throws
"
)
;
Assert
.
throws
(
(
)
=
>
channelWrapper
.
getResponseHeaders
(
)
/
NS_ERROR_UNEXPECTED
/
"
channelWrapper
.
getResponseHeaders
(
)
throws
"
)
;
Assert
.
throws
(
(
)
=
>
channelWrapper
.
setRequestHeader
(
"
Content
-
Type
"
"
"
)
/
NS_ERROR_UNEXPECTED
/
"
channelWrapper
.
setRequestHeader
(
)
throws
"
)
;
Assert
.
throws
(
(
)
=
>
channelWrapper
.
setResponseHeader
(
"
Content
-
Type
"
"
"
)
/
NS_ERROR_UNEXPECTED
/
"
channelWrapper
.
setResponseHeader
(
)
throws
"
)
;
}
function
createChannel
(
url
)
{
const
dummyPrincipal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
}
)
;
return
Services
.
io
.
newChannelFromURI
(
Services
.
io
.
newURI
(
url
)
null
dummyPrincipal
dummyPrincipal
0
Ci
.
nsIContentPolicy
.
TYPE_FETCH
)
;
}
function
assertChannelWrapperUnsupportedForChannel
(
channel
)
{
let
channelWrapper
=
ChannelWrapper
.
get
(
channel
)
;
Assert
.
equal
(
channelWrapper
.
channel
null
ChannelWrapper
cannot
wrap
channel
for
{
channel
.
URI
.
spec
}
)
;
channelWrapperEquals
(
channelWrapper
EXPECTATION_INVALID_CHANNEL
)
;
}
add_setup
(
async
function
create_content_page
(
)
{
gContentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
http
:
/
/
origin
.
example
.
net
/
home
"
)
;
registerCleanupFunction
(
(
)
=
>
gContentPage
.
close
(
)
)
;
}
)
;
add_task
(
async
function
during_basic_fetch
(
)
{
let
promise
=
TestUtils
.
topicObserved
(
"
http
-
on
-
modify
-
request
"
channel
=
>
{
equal
(
channel
.
URI
.
spec
"
http
:
/
/
example
.
com
/
dummy
"
"
expected
URL
"
)
;
let
channelWrapper
=
ChannelWrapper
.
get
(
channel
)
;
channelWrapperEquals
(
channelWrapper
EXPECTATION_BASIC_FETCH
)
;
return
true
;
}
)
;
await
gContentPage
.
spawn
(
[
]
async
(
)
=
>
{
let
res
=
await
content
.
fetch
(
"
http
:
/
/
example
.
com
/
dummy
"
)
;
Assert
.
equal
(
await
res
.
text
(
)
"
Server
'
s
reply
"
"
Got
response
"
)
;
}
)
;
await
promise
;
}
)
;
add_task
(
async
function
after_basic_fetch
(
)
{
let
promise
=
TestUtils
.
topicObserved
(
"
http
-
on
-
modify
-
request
"
)
;
await
gContentPage
.
spawn
(
[
]
async
(
)
=
>
{
let
res
=
await
content
.
fetch
(
"
http
:
/
/
example
.
com
/
dummy
"
)
;
Assert
.
equal
(
await
res
.
text
(
)
"
Server
'
s
reply
"
"
Got
response
"
)
;
}
)
;
let
[
channel
]
=
await
promise
;
equal
(
channel
.
URI
.
spec
"
http
:
/
/
example
.
com
/
dummy
"
"
expected
URL
"
)
;
let
channelWrapper
=
ChannelWrapper
.
get
(
channel
)
;
channelWrapperEquals
(
channelWrapper
EXPECTATION_BASIC_FETCH_COMPLETED
)
;
}
)
;
add_task
(
async
function
after_cancel_request
(
)
{
let
channelWrapper
;
let
promise
=
TestUtils
.
topicObserved
(
"
http
-
on
-
modify
-
request
"
channel
=
>
{
equal
(
channel
.
URI
.
spec
"
http
:
/
/
example
.
com
/
dummy
"
"
expected
URL
"
)
;
channelWrapper
=
ChannelWrapper
.
get
(
channel
)
;
channel
.
cancel
(
Cr
.
NS_ERROR_ABORT
)
;
return
true
;
}
)
;
await
gContentPage
.
spawn
(
[
]
async
(
)
=
>
{
await
Assert
.
rejects
(
content
.
fetch
(
"
http
:
/
/
example
.
com
/
dummy
"
)
/
NetworkError
when
attempting
to
fetch
resource
.
/
"
Request
should
be
aborted
"
)
;
}
)
;
await
promise
;
channelWrapperEquals
(
channelWrapper
EXPECTATION_BASIC_FETCH_ABORTED
)
;
}
)
;
add_task
(
async
function
after_basic_fetch_and_gc
(
)
{
let
promise
=
TestUtils
.
topicObserved
(
"
http
-
on
-
modify
-
request
"
)
;
await
gContentPage
.
spawn
(
[
]
async
(
)
=
>
{
let
res
=
await
content
.
fetch
(
"
http
:
/
/
example
.
com
/
dummy
"
)
;
Assert
.
equal
(
await
res
.
text
(
)
"
Server
'
s
reply
"
"
Got
response
"
)
;
}
)
;
let
[
channel
]
=
await
promise
;
equal
(
channel
.
URI
.
spec
"
http
:
/
/
example
.
com
/
dummy
"
"
expected
URL
"
)
;
let
channelWrapper
=
ChannelWrapper
.
get
(
channel
)
;
Assert
.
equal
(
channelWrapper
.
channel
channel
"
channel
not
GC
'
d
yet
"
)
;
channel
=
promise
=
null
;
await
forceChannelGC
(
)
;
Assert
.
equal
(
channelWrapper
.
channel
null
"
Channel
has
been
GC
'
d
"
)
;
channelWrapperEquals
(
channelWrapper
EXPECTATION_INVALID_CHANNEL
)
;
checkChannelWrapperMethodsAfterGC
(
channelWrapper
)
;
}
)
;
add_task
(
async
function
getRegisteredChannel_after_response_start
(
)
{
const
dummyPolicy
=
new
WebExtensionPolicy
(
{
id
:
"
dummyPolicy
"
mozExtensionHostname
:
"
c3c73091
-
8fab
-
4229
-
83cf
-
84c061dd9ead
"
baseURL
:
"
resource
:
/
/
modules
/
whatever_does_not_need_to_exist
"
allowedOrigins
:
new
MatchPatternSet
(
[
"
*
:
/
/
*
/
*
"
]
)
localizeCallback
:
(
)
=
>
"
"
}
)
;
let
promise
=
TestUtils
.
topicObserved
(
"
http
-
on
-
modify
-
request
"
)
;
await
gContentPage
.
spawn
(
[
]
async
(
)
=
>
{
let
res
=
await
content
.
fetch
(
"
http
:
/
/
example
.
com
/
dummy
"
)
;
Assert
.
equal
(
await
res
.
text
(
)
"
Server
'
s
reply
"
"
Got
response
"
)
;
}
)
;
let
[
channel
]
=
await
promise
;
equal
(
channel
.
URI
.
spec
"
http
:
/
/
example
.
com
/
dummy
"
"
expected
URL
"
)
;
let
channelWrapper
=
ChannelWrapper
.
get
(
channel
)
;
let
channelId
=
channelWrapper
.
id
;
channelWrapper
.
registerTraceableChannel
(
dummyPolicy
null
)
;
Assert
.
equal
(
ChannelWrapper
.
getRegisteredChannel
(
channelId
dummyPolicy
null
)
channelWrapper
"
getRegisteredChannel
(
)
returns
wrapper
after
registerTraceableChannel
(
)
"
)
;
channelWrapper
.
channel
=
channel
;
channel
=
promise
=
null
;
await
forceChannelGC
(
)
;
Assert
.
equal
(
channelWrapper
.
channel
null
"
Channel
has
been
GC
'
d
"
)
;
Assert
.
equal
(
ChannelWrapper
.
getRegisteredChannel
(
channelId
dummyPolicy
null
)
null
"
getRegisteredChannel
(
)
returns
nothing
after
channel
was
GC
'
d
"
)
;
channelWrapperEquals
(
channelWrapper
EXPECTATION_INVALID_CHANNEL
)
;
checkChannelWrapperMethodsAfterGC
(
channelWrapper
)
;
}
)
;
add_task
(
async
function
ChannelWrapper_https_url
(
)
{
const
channel
=
createChannel
(
"
https
:
/
/
example
.
com
/
dummyhttps
"
)
;
let
channelWrapper
=
ChannelWrapper
.
get
(
channel
)
;
Assert
.
equal
(
channelWrapper
.
channel
channel
"
ChannelWrapper
can
wrap
channel
for
https
"
)
;
channelWrapperEquals
(
channelWrapper
{
.
.
.
EXPECTATION_INVALID_CHANNEL
channel
method
:
"
GET
"
type
:
"
xmlhttprequest
"
finalURI
:
EXPECT_TRUTHY
finalURL
:
"
https
:
/
/
example
.
com
/
dummyhttps
"
errorString
:
null
loadInfo
:
EXPECT_TRUTHY
canModify
:
true
thirdParty
:
true
}
)
;
channelWrapperEquals
(
channelWrapper
{
.
.
.
EXPECTATION_BASIC_FETCH
finalURL
:
"
https
:
/
/
example
.
com
/
dummyhttps
"
proxyInfo
:
null
originURL
:
"
"
documentURL
:
"
"
originURI
:
null
documentURI
:
null
browserElement
:
null
frameAncestors
:
null
}
)
;
}
)
;
add_task
(
async
function
ChannelWrapper_moz_extension_url
(
)
{
const
xpi
=
AddonTestUtils
.
createTempWebExtensionFile
(
{
}
)
;
const
dummyPolicy
=
new
WebExtensionPolicy
(
{
id
:
"
dummyPolicy
"
mozExtensionHostname
:
"
e17d45dd
-
fe2a
-
4ece
-
8794
-
d487062cadf4
"
baseURL
:
jar
:
{
Services
.
io
.
newFileURI
(
xpi
)
.
spec
}
!
/
allowedOrigins
:
new
MatchPatternSet
(
[
"
*
:
/
/
*
/
*
"
]
)
localizeCallback
:
(
)
=
>
"
"
}
)
;
dummyPolicy
.
active
=
true
;
const
channel
=
createChannel
(
"
moz
-
extension
:
/
/
e17d45dd
-
fe2a
-
4ece
-
8794
-
d487062cadf4
/
manifest
.
json
"
)
;
Assert
.
ok
(
channel
instanceof
Ci
.
nsIJARChannel
"
Is
nsIJARChannel
"
)
;
assertChannelWrapperUnsupportedForChannel
(
channel
)
;
dummyPolicy
.
active
=
false
;
}
)
;
add_task
(
async
function
ChannelWrapper_blob_url
(
)
{
const
blobUrl
=
await
gContentPage
.
spawn
(
[
]
(
)
=
>
{
return
content
.
URL
.
createObjectURL
(
new
content
.
Blob
(
new
content
.
Array
(
)
)
)
;
}
)
;
const
channel
=
createChannel
(
blobUrl
)
;
assertChannelWrapperUnsupportedForChannel
(
channel
)
;
}
)
;
add_task
(
async
function
ChannelWrapper_data_url
(
)
{
const
channel
=
createChannel
(
"
data
:
"
)
;
Assert
.
ok
(
channel
instanceof
Ci
.
nsIDataChannel
"
Is
nsIDataChannel
"
)
;
assertChannelWrapperUnsupportedForChannel
(
channel
)
;
}
)
;
add_task
(
async
function
ChannelWrapper_file_url
(
)
{
const
channel
=
createChannel
(
"
file
:
/
/
C
:
/
"
)
;
Assert
.
ok
(
channel
instanceof
Ci
.
nsIFileChannel
"
Is
nsIFileChannel
"
)
;
assertChannelWrapperUnsupportedForChannel
(
channel
)
;
}
)
;
add_task
(
async
function
ChannelWrapper_about_blank_url
(
)
{
const
channel
=
createChannel
(
"
about
:
blank
"
)
;
assertChannelWrapperUnsupportedForChannel
(
channel
)
;
}
)
;
add_task
(
async
function
ChannelWrapper_javascript_url
(
)
{
const
channel
=
createChannel
(
"
javascript
:
/
/
"
)
;
assertChannelWrapperUnsupportedForChannel
(
channel
)
;
}
)
;
add_task
(
async
function
ChannelWrapper_resource_url
(
)
{
const
channel
=
createChannel
(
"
resource
:
/
/
content
-
accessible
/
viewsource
.
css
"
)
;
assertChannelWrapperUnsupportedForChannel
(
channel
)
;
}
)
;
add_task
(
async
function
ChannelWrapper_chrome_url
(
)
{
const
channel
=
createChannel
(
"
chrome
:
/
/
extensions
/
content
/
schemas
/
web_request
.
json
"
)
;
assertChannelWrapperUnsupportedForChannel
(
channel
)
;
}
)
;
add_task
(
async
function
sanity_check_expectations_complete
(
)
{
const
channelWrapper
=
ChannelWrapper
.
get
(
createChannel
(
"
http
:
/
/
whatever
/
"
)
)
;
channelWrapper
.
channel
=
null
;
const
uncheckedKeys
=
new
Set
(
Object
.
keys
(
ChannelWrapper
.
prototype
)
)
;
const
channelWrapperWithSpy
=
new
Proxy
(
channelWrapper
{
get
(
target
prop
)
{
uncheckedKeys
.
delete
(
prop
)
;
let
value
=
Reflect
.
get
(
target
prop
target
)
;
return
typeof
value
=
=
"
function
"
?
value
.
bind
(
target
)
:
value
;
}
}
)
;
channelWrapperEquals
(
channelWrapperWithSpy
EXPECTATION_INVALID_CHANNEL
)
;
checkChannelWrapperMethodsAfterGC
(
channelWrapperWithSpy
)
;
Assert
.
deepEqual
(
Array
.
from
(
uncheckedKeys
)
[
]
"
All
ChannelWrapper
properties
and
methods
have
been
checked
"
)
;
Assert
.
deepEqual
(
Object
.
keys
(
EXPECTATION_BASIC_FETCH
)
Object
.
keys
(
EXPECTATION_INVALID_CHANNEL
)
"
EXPECTATION_BASIC_FETCH
has
same
properties
as
EXPECTATION_INVALID_CHANNEL
"
)
;
}
)
;
add_task
(
async
function
sanity_check_WebRequest_module_not_loaded
(
)
{
Assert
.
equal
(
Cu
.
isESModuleLoaded
(
"
resource
:
/
/
gre
/
modules
/
WebRequest
.
sys
.
mjs
"
)
false
"
WebRequest
.
sys
.
mjs
should
not
have
been
loaded
in
this
test
"
)
;
}
)
;
