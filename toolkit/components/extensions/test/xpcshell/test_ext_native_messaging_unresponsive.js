"
use
strict
"
;
const
WONTDIE_BODY
=
String
.
raw
import
signal
import
struct
import
sys
import
time
signal
.
signal
(
signal
.
SIGTERM
signal
.
SIG_IGN
)
def
spin
(
)
:
while
True
:
try
:
signal
.
pause
(
)
except
AttributeError
:
time
.
sleep
(
5
)
while
True
:
rawlen
=
sys
.
stdin
.
read
(
4
)
if
len
(
rawlen
)
=
=
0
:
spin
(
)
msglen
=
struct
.
unpack
(
'
I
'
rawlen
)
[
0
]
msg
=
sys
.
stdin
.
read
(
msglen
)
sys
.
stdout
.
write
(
struct
.
pack
(
'
I
'
msglen
)
)
sys
.
stdout
.
write
(
msg
)
;
const
SCRIPTS
=
[
{
name
:
"
wontdie
"
description
:
"
a
native
app
that
does
not
exit
when
stdin
closes
or
on
SIGTERM
"
script
:
WONTDIE_BODY
.
replace
(
/
^
{
2
}
/
gm
"
"
)
}
]
;
add_task
(
function
*
setup
(
)
{
yield
setupHosts
(
SCRIPTS
)
;
}
)
;
add_task
(
function
*
test_unresponsive_native_app
(
)
{
function
background
(
)
{
let
port
=
browser
.
runtime
.
connectNative
(
"
wontdie
"
)
;
const
MSG
=
"
echo
me
"
;
port
.
onMessage
.
addListener
(
msg
=
>
{
browser
.
test
.
assertEq
(
msg
MSG
"
Received
echoed
message
"
)
;
browser
.
test
.
sendMessage
(
"
ready
"
)
;
}
)
;
port
.
postMessage
(
MSG
)
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
manifest
:
{
applications
:
{
gecko
:
{
id
:
ID
}
}
permissions
:
[
"
nativeMessaging
"
]
}
}
)
;
yield
extension
.
startup
(
)
;
yield
extension
.
awaitMessage
(
"
ready
"
)
;
let
procCount
=
yield
getSubprocessCount
(
)
;
equal
(
procCount
1
"
subprocess
is
running
"
)
;
let
exitPromise
=
waitForSubprocessExit
(
)
;
yield
extension
.
unload
(
)
;
yield
exitPromise
;
procCount
=
yield
getSubprocessCount
(
)
;
equal
(
procCount
0
"
subprocess
was
succesfully
killed
"
)
;
}
)
;
