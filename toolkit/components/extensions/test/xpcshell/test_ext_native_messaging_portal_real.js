"
use
strict
"
;
const
{
PromiseTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
sys
.
mjs
"
)
;
PromiseTestUtils
.
allowMatchingRejectionsGlobally
(
/
Invalid
process
ID
/
)
;
const
NATIVE_APP_BASENAME
=
"
pingpong_nativemessaging_test
"
;
const
NATIVE_APP_PATH
=
do_get_file
(
"
data
/
pingpong_nativemessaging_test
.
py
"
)
.
path
;
info
(
This
test
will
launch
{
NATIVE_APP_PATH
}
)
;
const
EXTENSION_ID
=
"
native
-
messaging
-
portal
-
test
tests
.
mozilla
.
org
"
;
let
pingpong_manifest
=
{
"
name
"
:
"
{
NATIVE_APP_BASENAME
}
"
"
description
"
:
"
Example
host
for
native
messaging
"
"
path
"
:
"
{
NATIVE_APP_PATH
}
"
"
type
"
:
"
stdio
"
"
allowed_extensions
"
:
[
"
{
EXTENSION_ID
}
"
]
}
;
add_setup
(
async
function
setup
(
)
{
Assert
.
equal
(
Services
.
env
.
get
(
"
GTK_USE_PORTAL
"
)
1
"
GTK_USE_PORTAL
needs
to
be
set
.
"
)
;
Services
.
prefs
.
setIntPref
(
"
widget
.
use
-
xdg
-
desktop
-
portal
.
native
-
messaging
"
2
)
;
let
p
=
await
Subprocess
.
call
(
{
command
:
await
Subprocess
.
pathSearch
(
"
dbus
-
send
"
)
arguments
:
[
"
-
-
session
"
"
-
-
type
=
method_call
"
"
-
-
dest
=
org
.
freedesktop
.
impl
.
portal
.
PermissionStore
"
"
/
org
/
freedesktop
/
impl
/
portal
/
PermissionStore
"
"
org
.
freedesktop
.
impl
.
portal
.
PermissionStore
.
SetPermission
"
"
string
:
webextensions
"
"
boolean
:
true
"
"
string
:
pingpong_nativemessaging_test
"
"
string
:
"
"
array
:
string
:
yes
"
]
}
)
;
let
{
exitcode
}
=
await
p
.
wait
(
)
;
Assert
.
equal
(
exitcode
undefined
"
Dbus
call
to
allow
the
test
native
messaging
app
should
succeed
"
)
;
registerCleanupFunction
(
async
function
(
)
{
let
y
=
await
Subprocess
.
call
(
{
command
:
await
Subprocess
.
pathSearch
(
"
dbus
-
send
"
)
arguments
:
[
"
-
-
session
"
"
-
-
type
=
method_call
"
"
-
-
print
-
reply
"
"
-
-
dest
=
org
.
freedesktop
.
impl
.
portal
.
PermissionStore
"
"
/
org
/
freedesktop
/
impl
/
portal
/
PermissionStore
"
"
org
.
freedesktop
.
impl
.
portal
.
PermissionStore
.
DeletePermission
"
"
string
:
webextensions
"
"
string
:
pingpong_nativemessaging_test
"
"
string
:
"
]
}
)
;
let
{
exitcode
}
=
await
y
.
wait
(
)
;
Assert
.
equal
(
exitcode
undefined
"
Clean
-
up
of
store
permission
should
succeed
.
"
)
;
}
)
;
await
setupHosts
(
[
]
)
;
let
home
=
Services
.
env
.
get
(
"
HOME
"
)
;
Assert
.
notEqual
(
home
"
"
"
HOME
is
set
"
)
;
let
pingpong_manifest_file
=
home
+
/
.
mozilla
/
native
-
messaging
-
hosts
/
{
NATIVE_APP_BASENAME
}
.
json
;
await
IOUtils
.
writeUTF8
(
pingpong_manifest_file
pingpong_manifest
{
flush
:
true
}
)
;
registerCleanupFunction
(
async
function
(
)
{
await
IOUtils
.
remove
(
pingpong_manifest_file
)
;
}
)
;
}
)
;
async
function
background
(
)
{
try
{
let
res
=
await
browser
.
runtime
.
sendNativeMessage
(
"
pingpong_nativemessaging_test
"
"
ping
"
)
;
browser
.
test
.
assertEq
(
"
native
app
sends
pong
"
res
"
Expected
reply
from
native
messaging
host
"
)
;
await
browser
.
test
.
assertRejects
(
browser
.
runtime
.
sendNativeMessage
(
"
non_existent_nativemessaging_host
"
"
ping
"
)
"
No
such
native
application
non_existent_nativemessaging_host
"
"
Expected
error
for
non
-
existing
native
messaging
host
"
)
;
}
catch
(
e
)
{
browser
.
test
.
fail
(
Unexpected
error
:
{
e
}
)
;
}
browser
.
test
.
sendMessage
(
"
done
"
)
;
}
add_task
(
async
function
test_talk_to_native_application
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
manifest
:
{
browser_specific_settings
:
{
gecko
:
{
id
:
EXTENSION_ID
}
}
permissions
:
[
"
nativeMessaging
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
done
"
)
;
await
extension
.
unload
(
)
;
}
)
;
