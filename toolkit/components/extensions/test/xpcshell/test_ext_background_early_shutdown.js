"
use
strict
"
;
const
{
BrowserTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
jsm
"
)
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
43
"
)
;
let
{
promiseRestartManager
promiseShutdownManager
promiseStartupManager
}
=
AddonTestUtils
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
webextensions
.
background
-
delayed
-
startup
"
true
)
;
const
{
Management
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
)
;
function
crashFrame
(
browser
)
{
if
(
!
browser
.
isRemoteBrowser
)
{
throw
new
Error
(
"
<
browser
>
must
be
remote
"
)
;
}
BrowserTestUtils
.
sendAsyncMessage
(
browser
.
browsingContext
"
BrowserTestUtils
:
CrashFrame
"
{
}
)
;
}
add_task
(
async
function
test_unload_extension_before_background_page_startup
(
)
{
await
promiseStartupManager
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
background
(
)
{
browser
.
test
.
sendMessage
(
"
background_startup_observed
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
background_startup_observed
"
)
;
info
(
"
Starting
extension
whose
startup
will
be
interrupted
"
)
;
ExtensionParent
.
_resetStartupPromises
(
)
;
await
promiseRestartManager
(
)
;
await
extension
.
awaitStartup
(
)
;
let
extensionBrowserInsertions
=
0
;
let
onExtensionBrowserInserted
=
(
)
=
>
+
+
extensionBrowserInsertions
;
Management
.
on
(
"
extension
-
browser
-
inserted
"
onExtensionBrowserInserted
)
;
info
(
"
Unloading
extension
before
the
delayed
background
page
starts
loading
"
)
;
await
extension
.
addon
.
disable
(
)
;
await
extension
.
addon
.
enable
(
)
;
info
(
"
Forcing
pending
delayed
background
page
to
load
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
windows
-
restored
"
)
;
await
extension
.
awaitMessage
(
"
background_startup_observed
"
)
;
await
extension
.
unload
(
)
;
await
promiseShutdownManager
(
)
;
ExtensionParent
.
_resetStartupPromises
(
)
;
Management
.
off
(
"
extension
-
browser
-
inserted
"
onExtensionBrowserInserted
)
;
Assert
.
equal
(
extensionBrowserInsertions
1
"
Extension
browser
should
have
been
inserted
only
once
"
)
;
}
)
;
add_task
(
async
function
test_unload_extension_during_background_page_startup
(
)
{
await
promiseStartupManager
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
background
(
)
{
browser
.
test
.
sendMessage
(
"
background_starting
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
background_starting
"
)
;
ExtensionParent
.
_resetStartupPromises
(
)
;
await
promiseRestartManager
(
)
;
await
extension
.
awaitStartup
(
)
;
let
bgStartupPromise
=
new
Promise
(
resolve
=
>
{
function
onBackgroundPageDone
(
eventName
)
{
extension
.
extension
.
off
(
"
background
-
script
-
started
"
onBackgroundPageDone
)
;
extension
.
extension
.
off
(
"
background
-
script
-
aborted
"
onBackgroundPageDone
)
;
if
(
eventName
=
=
=
"
background
-
script
-
aborted
"
)
{
info
(
"
Background
script
startup
was
interrupted
"
)
;
resolve
(
"
bg_aborted
"
)
;
}
else
{
info
(
"
Background
script
startup
finished
normally
"
)
;
resolve
(
"
bg_fully_loaded
"
)
;
}
}
extension
.
extension
.
on
(
"
background
-
script
-
started
"
onBackgroundPageDone
)
;
extension
.
extension
.
on
(
"
background
-
script
-
aborted
"
onBackgroundPageDone
)
;
}
)
;
let
bgStartingPromise
=
new
Promise
(
resolve
=
>
{
let
backgroundLoadCount
=
0
;
let
backgroundPageUrl
=
extension
.
extension
.
baseURI
.
resolve
(
"
_generated_background_page
.
html
"
)
;
Management
.
once
(
"
extension
-
browser
-
inserted
"
(
eventName
browser
)
=
>
{
let
browserLoadURI
=
browser
.
loadURI
;
browser
.
loadURI
=
function
(
)
{
Assert
.
equal
(
+
+
backgroundLoadCount
1
"
loadURI
should
be
called
once
"
)
;
Assert
.
equal
(
arguments
[
0
]
backgroundPageUrl
"
Expected
background
page
"
)
;
arguments
[
0
]
=
"
about
:
blank
"
;
browserLoadURI
.
apply
(
this
arguments
)
;
if
(
browser
.
isRemote
)
{
crashFrame
(
browser
)
;
}
else
{
browser
.
remove
(
)
;
}
resolve
(
)
;
}
;
}
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
windows
-
restored
"
)
;
await
bgStartingPromise
;
await
extension
.
unload
(
)
;
await
promiseShutdownManager
(
)
;
info
(
"
Waiting
for
background
builder
to
finish
"
)
;
let
bgLoadState
=
await
bgStartupPromise
;
Assert
.
equal
(
bgLoadState
"
bg_aborted
"
"
Startup
should
be
interrupted
"
)
;
ExtensionParent
.
_resetStartupPromises
(
)
;
}
)
;
