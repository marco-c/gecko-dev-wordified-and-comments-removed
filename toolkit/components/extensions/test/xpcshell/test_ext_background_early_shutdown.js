"
use
strict
"
;
const
{
BrowserTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
sys
.
mjs
"
)
;
const
{
ExtensionTestCommon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
ExtensionTestCommon
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
MockRegistrar
:
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
sys
.
mjs
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
}
)
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
43
"
)
;
let
{
promiseRestartManager
promiseShutdownManager
promiseStartupManager
}
=
AddonTestUtils
;
const
{
ExtensionProcessCrashObserver
Management
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
sys
.
mjs
"
)
;
const
server
=
AddonTestUtils
.
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
]
}
)
;
function
registerSlowStyleSheet
(
)
{
let
allowStylesheetToLoad
;
let
stylesheetBlockerPromise
=
new
Promise
(
resolve
=
>
{
allowStylesheetToLoad
=
resolve
;
}
)
;
let
resolveFirstLoad
;
let
firstLoadPromise
=
new
Promise
(
resolve
=
>
{
resolveFirstLoad
=
resolve
;
}
)
;
let
requestCount
=
0
;
server
.
registerPathHandler
(
"
/
slow
.
css
"
(
request
response
)
=
>
{
response
.
setHeader
(
"
Cache
-
Control
"
"
no
-
cache
"
false
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
css
"
false
)
;
response
.
processAsync
(
)
;
+
+
requestCount
;
resolveFirstLoad
(
)
;
stylesheetBlockerPromise
.
then
(
(
)
=
>
{
response
.
write
(
"
body
{
color
:
rgb
(
1
2
3
)
;
}
"
)
;
response
.
finish
(
)
;
}
)
;
}
)
;
const
getRequestCount
=
(
)
=
>
requestCount
;
return
{
allowStylesheetToLoad
getRequestCount
firstLoadPromise
}
;
}
function
crashFrame
(
browser
)
{
if
(
!
browser
.
isRemoteBrowser
)
{
throw
new
Error
(
"
<
browser
>
must
be
remote
"
)
;
}
BrowserTestUtils
.
sendAsyncMessage
(
browser
.
browsingContext
"
BrowserTestUtils
:
CrashFrame
"
{
}
)
;
}
const
CAN_CRASH_EXTENSIONS
=
WebExtensionPolicy
.
useRemoteWebExtensions
;
add_setup
(
function
(
)
{
Services
.
prefs
.
setIntPref
(
"
extensions
.
webextensions
.
crash
.
threshold
"
100
)
;
}
)
;
add_setup
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_CRASHREPORTER
|
|
!
CAN_CRASH_EXTENSIONS
}
function
setup_crash_reporter_override_and_cleaner
(
)
{
const
crashIds
=
[
]
;
let
mockClassId
=
MockRegistrar
.
register
(
"
mozilla
.
org
/
crashservice
;
1
"
{
addCrash
(
processType
crashType
id
)
{
crashIds
.
push
(
id
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsICrashService
"
]
)
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
MockRegistrar
.
unregister
(
mockClassId
)
;
const
appinfo
=
Cc
[
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
]
.
getService
(
Ci
.
nsICrashReporter
)
;
info
(
Observed
{
crashIds
.
length
}
crash
dump
(
s
)
.
)
;
let
deletedCount
=
0
;
for
(
let
id
of
crashIds
)
{
info
(
Checking
whether
dumpID
{
id
}
should
be
removed
)
;
let
minidumpFile
=
appinfo
.
getMinidumpForID
(
id
)
;
let
extraFile
=
appinfo
.
getExtraFileForID
(
id
)
;
let
extra
;
try
{
extra
=
await
IOUtils
.
readJSON
(
extraFile
.
path
)
;
}
catch
(
e
)
{
info
(
Cannot
parse
crash
metadata
from
{
extraFile
.
path
}
:
:
{
e
}
\
n
)
;
continue
;
}
if
(
extra
.
TestKey
!
=
=
"
CrashFrame
"
)
{
info
(
Keeping
{
minidumpFile
.
path
}
;
we
did
not
trigger
the
crash
)
;
continue
;
}
info
(
Deleting
minidump
{
minidumpFile
.
path
}
and
{
extraFile
.
path
}
)
;
minidumpFile
.
remove
(
false
)
;
extraFile
.
remove
(
false
)
;
+
+
deletedCount
;
}
info
(
Removed
{
deletedCount
}
crash
dumps
out
of
{
crashIds
.
length
}
)
;
}
)
;
}
)
;
async
function
crashExtensionBackground
(
extension
bgBrowser
)
{
bgBrowser
?
?
=
extension
.
extension
.
backgroundContext
.
xulBrowser
;
let
byeProm
=
promiseExtensionEvent
(
extension
"
shutdown
-
background
-
script
"
)
;
if
(
CAN_CRASH_EXTENSIONS
)
{
info
(
"
Killing
background
page
through
process
crash
.
"
)
;
crashFrame
(
bgBrowser
)
;
}
else
{
info
(
"
Closing
background
page
by
destroying
<
browser
>
.
"
)
;
if
(
extension
.
extension
.
backgroundState
=
=
=
"
running
"
)
{
let
messageManager
=
bgBrowser
.
messageManager
;
TestUtils
.
topicObserved
(
"
message
-
manager
-
close
"
subject
=
>
subject
=
=
=
messageManager
)
.
then
(
(
)
=
>
{
Management
.
emit
(
"
extension
-
process
-
crash
"
{
childID
:
1337
}
)
;
}
)
;
}
bgBrowser
.
remove
(
)
;
}
info
(
"
Waiting
for
crash
to
be
detected
by
the
internals
"
)
;
await
byeProm
;
}
add_task
(
async
function
test_unload_extension_before_background_page_startup
(
)
{
await
promiseStartupManager
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
background
(
)
{
browser
.
test
.
sendMessage
(
"
background_startup_observed
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
background_startup_observed
"
)
;
info
(
"
Starting
extension
whose
startup
will
be
interrupted
"
)
;
await
promiseRestartManager
(
{
earlyStartup
:
false
}
)
;
await
extension
.
awaitStartup
(
)
;
let
extensionBrowserInsertions
=
0
;
let
onExtensionBrowserInserted
=
(
)
=
>
+
+
extensionBrowserInsertions
;
Management
.
on
(
"
extension
-
browser
-
inserted
"
onExtensionBrowserInserted
)
;
info
(
"
Unloading
extension
before
the
delayed
background
page
starts
loading
"
)
;
await
extension
.
addon
.
disable
(
)
;
await
extension
.
addon
.
enable
(
)
;
info
(
"
Forcing
pending
delayed
background
page
to
load
"
)
;
AddonTestUtils
.
notifyLateStartup
(
)
;
await
extension
.
awaitMessage
(
"
background_startup_observed
"
)
;
await
extension
.
unload
(
)
;
await
promiseShutdownManager
(
)
;
Management
.
off
(
"
extension
-
browser
-
inserted
"
onExtensionBrowserInserted
)
;
Assert
.
equal
(
extensionBrowserInsertions
1
"
Extension
browser
should
have
been
inserted
only
once
"
)
;
}
)
;
add_task
(
async
function
test_unload_extension_during_background_page_startup
(
)
{
await
promiseStartupManager
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
background
(
)
{
browser
.
test
.
sendMessage
(
"
background_starting
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
background_starting
"
)
;
await
promiseRestartManager
(
{
lateStartup
:
false
}
)
;
await
extension
.
awaitStartup
(
)
;
let
bgStartupPromise
=
new
Promise
(
resolve
=
>
{
function
onBackgroundPageDone
(
eventName
)
{
extension
.
extension
.
off
(
"
background
-
script
-
started
"
onBackgroundPageDone
)
;
extension
.
extension
.
off
(
"
background
-
script
-
aborted
"
onBackgroundPageDone
)
;
if
(
eventName
=
=
=
"
background
-
script
-
aborted
"
)
{
info
(
"
Background
script
startup
was
interrupted
"
)
;
resolve
(
"
bg_aborted
"
)
;
}
else
{
info
(
"
Background
script
startup
finished
normally
"
)
;
resolve
(
"
bg_fully_loaded
"
)
;
}
}
extension
.
extension
.
on
(
"
background
-
script
-
started
"
onBackgroundPageDone
)
;
extension
.
extension
.
on
(
"
background
-
script
-
aborted
"
onBackgroundPageDone
)
;
}
)
;
let
bgStartingPromise
=
new
Promise
(
resolve
=
>
{
let
backgroundLoadCount
=
0
;
let
backgroundPageUrl
=
extension
.
extension
.
baseURI
.
resolve
(
"
_generated_background_page
.
html
"
)
;
Management
.
once
(
"
extension
-
browser
-
inserted
"
(
eventName
browser
)
=
>
{
let
browserFixupAndLoadURIString
=
browser
.
fixupAndLoadURIString
;
browser
.
fixupAndLoadURIString
=
function
(
)
{
Assert
.
equal
(
+
+
backgroundLoadCount
1
"
loadURI
should
be
called
once
"
)
;
Assert
.
equal
(
arguments
[
0
]
backgroundPageUrl
"
Expected
background
page
"
)
;
arguments
[
0
]
=
"
about
:
blank
"
;
browserFixupAndLoadURIString
.
apply
(
this
arguments
)
;
if
(
CAN_CRASH_EXTENSIONS
)
{
crashFrame
(
browser
)
;
}
else
{
browser
.
remove
(
)
;
}
resolve
(
)
;
}
;
}
)
;
}
)
;
AddonTestUtils
.
notifyLateStartup
(
)
;
await
bgStartingPromise
;
await
extension
.
unload
(
)
;
await
promiseShutdownManager
(
)
;
info
(
"
Waiting
for
background
builder
to
finish
"
)
;
let
bgLoadState
=
await
bgStartupPromise
;
Assert
.
equal
(
bgLoadState
"
bg_aborted
"
"
Startup
should
be
interrupted
"
)
;
}
)
;
async
function
do_test_crash_while_starting_background
(
{
withContext
=
false
isEventPage
=
false
}
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
startupReason
:
"
APP_STARTUP
"
delayedStartup
:
true
manifest
:
{
background
:
{
page
:
"
background
.
html
"
persistent
:
!
isEventPage
}
}
files
:
{
"
background
.
html
"
:
<
!
DOCTYPE
html
>
<
meta
charset
=
"
utf
-
8
"
>
<
script
src
=
"
background
-
immediate
.
js
"
>
<
/
script
>
<
!
-
-
Delays
DOMContentLoaded
-
see
registerSlowStyleSheet
-
-
>
<
link
rel
=
"
stylesheet
"
href
=
"
http
:
/
/
example
.
com
/
slow
.
css
"
>
<
script
src
=
"
background
-
deferred
.
js
"
defer
>
<
/
script
>
"
background
-
immediate
.
js
"
:
String
.
raw
dump
(
"
background
-
immediate
.
js
is
executing
as
expected
.
\
n
"
)
;
if
(
{
!
!
withContext
}
)
{
/
/
Accessing
the
browser
API
triggers
context
creation
.
browser
.
test
.
sendMessage
(
"
background_started_to_load
"
)
;
}
"
background
-
deferred
.
js
"
:
(
)
=
>
{
dump
(
"
background
-
deferred
.
js
is
UNEXPECTEDLY
executing
.
\
n
"
)
;
browser
.
test
.
fail
(
"
Background
startup
should
have
been
interrupted
"
)
;
}
}
}
)
;
let
slowStyleSheet
=
registerSlowStyleSheet
(
)
;
await
ExtensionTestCommon
.
resetStartupPromises
(
)
;
await
extension
.
startup
(
)
;
function
assertBackgroundState
(
expected
message
)
{
Assert
.
equal
(
extension
.
extension
.
backgroundState
expected
message
)
;
}
assertBackgroundState
(
"
stopped
"
"
Background
should
not
have
started
yet
"
)
;
let
bgBrowserPromise
=
new
Promise
(
resolve
=
>
{
Management
.
once
(
"
extension
-
browser
-
inserted
"
(
eventName
browser
)
=
>
{
assertBackgroundState
(
"
starting
"
"
State
when
bg
<
browser
>
is
inserted
"
)
;
resolve
(
browser
)
;
}
)
;
}
)
;
info
(
"
Triggering
background
creation
.
.
.
"
)
;
await
ExtensionTestCommon
.
notifyEarlyStartup
(
)
;
await
ExtensionTestCommon
.
notifyLateStartup
(
)
;
let
bgBrowser
=
await
bgBrowserPromise
;
if
(
withContext
)
{
info
(
"
Waiting
for
background
-
immediate
.
js
to
notify
us
.
.
.
"
)
;
await
extension
.
awaitMessage
(
"
background_started_to_load
"
)
;
Assert
.
ok
(
extension
.
extension
.
backgroundContext
"
Context
exists
when
an
extension
API
was
called
"
)
;
await
slowStyleSheet
.
firstLoadPromise
;
}
else
{
await
slowStyleSheet
.
firstLoadPromise
;
Assert
.
ok
(
!
extension
.
extension
.
backgroundContext
"
Context
should
not
be
set
while
loading
"
)
;
}
assertBackgroundState
(
"
starting
"
"
Background
should
still
be
loading
"
)
;
await
crashExtensionBackground
(
extension
bgBrowser
)
;
assertBackgroundState
(
"
stopped
"
"
Background
state
after
crash
"
)
;
slowStyleSheet
.
allowStylesheetToLoad
(
)
;
await
extension
.
unload
(
)
;
Assert
.
equal
(
slowStyleSheet
.
getRequestCount
(
)
1
"
Expected
exactly
one
request
for
slow
.
css
from
background
page
"
)
;
}
add_task
(
async
function
test_crash_while_starting_background_without_context
(
)
{
await
do_test_crash_while_starting_background
(
{
withContext
:
false
}
)
;
}
)
;
add_task
(
async
function
test_crash_while_starting_background_with_context
(
)
{
await
do_test_crash_while_starting_background
(
{
withContext
:
true
}
)
;
}
)
;
add_task
(
async
function
test_crash_while_starting_event_page_without_context
(
)
{
await
do_test_crash_while_starting_background
(
{
withContext
:
false
isEventPage
:
true
}
)
;
}
)
;
add_task
(
async
function
test_crash_while_starting_event_page_with_context
(
)
{
await
do_test_crash_while_starting_background
(
{
withContext
:
true
isEventPage
:
true
}
)
;
}
)
;
async
function
do_test_crash_while_running_background
(
{
isEventPage
=
false
}
)
{
await
ExtensionTestCommon
.
resetStartupPromises
(
)
;
await
AddonTestUtils
.
notifyEarlyStartup
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
background
:
{
persistent
:
!
isEventPage
}
}
background
(
)
{
window
.
onload
=
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
background_has_fully_loaded
"
)
;
}
;
}
}
)
;
await
extension
.
startup
(
)
;
function
assertBackgroundState
(
expected
message
)
{
Assert
.
equal
(
extension
.
extension
.
backgroundState
expected
message
)
;
}
await
extension
.
awaitMessage
(
"
background_has_fully_loaded
"
)
;
assertBackgroundState
(
"
running
"
"
Background
should
have
started
"
)
;
await
crashExtensionBackground
(
extension
)
;
assertBackgroundState
(
"
stopped
"
"
Background
state
after
crash
"
)
;
await
extension
.
wakeupBackground
(
)
;
await
extension
.
awaitMessage
(
"
background_has_fully_loaded
"
)
;
assertBackgroundState
(
"
running
"
"
Background
resumed
after
crash
recovery
"
)
;
await
extension
.
terminateBackground
(
)
;
assertBackgroundState
(
"
stopped
"
"
Background
can
sleep
after
crash
recovery
"
)
;
await
extension
.
unload
(
)
;
}
add_task
(
async
function
test_crash_after_background_startup
(
)
{
await
do_test_crash_while_running_background
(
{
isEventPage
:
false
}
)
;
}
)
;
add_task
(
async
function
test_crash_after_event_page_startup
(
)
{
await
do_test_crash_while_running_background
(
{
isEventPage
:
true
}
)
;
}
)
;
add_task
(
async
function
test_crash_and_wakeup_via_persistent_listeners
(
)
{
await
ExtensionTestCommon
.
resetStartupPromises
(
)
;
await
AddonTestUtils
.
notifyEarlyStartup
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
background
:
{
persistent
:
false
}
optional_permissions
:
[
"
tabs
"
]
}
background
(
)
{
const
domreadyPromise
=
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
"
load
"
resolve
{
once
:
true
}
)
;
}
)
;
browser
.
permissions
.
onAdded
.
addListener
(
(
)
=
>
{
browser
.
test
.
log
(
"
permissions
.
onAdded
has
fired
"
)
;
domreadyPromise
.
then
(
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
event_fired
"
)
;
}
)
;
}
)
;
}
}
)
;
await
extension
.
startup
(
)
;
function
assertBackgroundState
(
expected
message
)
{
Assert
.
equal
(
extension
.
extension
.
backgroundState
expected
message
)
;
}
function
triggerEventInEventPage
(
)
{
Management
.
emit
(
"
change
-
permissions
"
{
extensionId
:
extension
.
id
added
:
{
origins
:
[
]
permissions
:
[
"
tabs
"
]
}
}
)
;
}
assertBackgroundState
(
"
running
"
"
Background
after
extension
.
startup
(
)
"
)
;
triggerEventInEventPage
(
)
;
await
extension
.
awaitMessage
(
"
event_fired
"
)
;
const
TEST_RESTART_ATTEMPTS
=
5
;
for
(
let
i
=
1
;
i
<
=
TEST_RESTART_ATTEMPTS
;
+
+
i
)
{
info
(
Testing
that
a
crashed
background
wakes
via
event
attempt
{
i
}
/
5
)
;
await
crashExtensionBackground
(
extension
)
;
assertBackgroundState
(
"
stopped
"
"
Background
state
after
crash
"
)
;
triggerEventInEventPage
(
)
;
await
extension
.
awaitMessage
(
"
event_fired
"
)
;
assertBackgroundState
(
"
running
"
"
Persistent
event
can
wake
up
event
page
"
)
;
}
await
extension
.
unload
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
CAN_CRASH_EXTENSIONS
pref_set
:
[
[
"
extensions
.
webextensions
.
crash
.
threshold
"
3
]
[
"
extensions
.
webextensions
.
crash
.
timeframe
"
60
*
1000
]
]
}
async
function
test_process_spawning_disabled_because_of_too_many_crashes
(
)
{
ExtensionProcessCrashObserver
.
enableProcessSpawning
(
)
;
Assert
.
equal
(
ExtensionProcessCrashObserver
.
processSpawningDisabled
false
"
Expect
process
spawning
to
be
enabled
"
)
;
await
ExtensionTestCommon
.
resetStartupPromises
(
)
;
await
AddonTestUtils
.
notifyEarlyStartup
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
background
:
{
persistent
:
false
}
optional_permissions
:
[
"
tabs
"
]
}
background
(
)
{
const
domreadyPromise
=
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
"
load
"
resolve
{
once
:
true
}
)
;
}
)
;
browser
.
permissions
.
onAdded
.
addListener
(
(
)
=
>
{
browser
.
test
.
log
(
"
permissions
.
onAdded
has
fired
"
)
;
domreadyPromise
.
then
(
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
event_fired
"
)
;
}
)
;
}
)
;
}
}
)
;
await
extension
.
startup
(
)
;
function
assertBackgroundState
(
expected
message
)
{
Assert
.
equal
(
extension
.
extension
.
backgroundState
expected
message
)
;
}
function
triggerEventInEventPage
(
)
{
Management
.
emit
(
"
change
-
permissions
"
{
extensionId
:
extension
.
id
added
:
{
origins
:
[
]
permissions
:
[
"
tabs
"
]
}
}
)
;
}
assertBackgroundState
(
"
running
"
"
Background
after
extension
.
startup
(
)
"
)
;
triggerEventInEventPage
(
)
;
await
extension
.
awaitMessage
(
"
event_fired
"
)
;
const
TEST_RESTART_ATTEMPTS
=
3
;
for
(
let
i
=
1
;
i
<
=
TEST_RESTART_ATTEMPTS
;
+
+
i
)
{
info
(
Crash
/
restart
extension
background
attempt
{
i
}
/
{
TEST_RESTART_ATTEMPTS
}
)
;
await
crashExtensionBackground
(
extension
)
;
assertBackgroundState
(
"
stopped
"
"
Background
state
after
crash
"
)
;
triggerEventInEventPage
(
)
;
await
extension
.
awaitMessage
(
"
event_fired
"
)
;
assertBackgroundState
(
"
running
"
"
Persistent
event
can
wake
up
event
page
"
)
;
}
info
(
"
Crash
one
more
time
"
)
;
await
crashExtensionBackground
(
extension
)
;
Assert
.
ok
(
ExtensionProcessCrashObserver
.
processSpawningDisabled
"
Expect
process
spawning
to
be
disabled
"
)
;
info
(
"
Trigger
an
event
which
shouldn
'
t
wake
up
the
event
page
"
)
;
triggerEventInEventPage
(
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
100
)
)
;
assertBackgroundState
(
"
stopped
"
"
Background
should
not
have
started
yet
"
)
;
info
(
"
Enable
process
spawning
"
)
;
ExtensionProcessCrashObserver
.
enableProcessSpawning
(
)
;
Assert
.
equal
(
ExtensionProcessCrashObserver
.
processSpawningDisabled
false
"
Expect
process
spawning
to
be
enabled
"
)
;
assertBackgroundState
(
"
stopped
"
"
Background
should
still
be
suspended
"
)
;
info
(
"
Trigger
an
event
which
should
wake
up
the
event
page
"
)
;
triggerEventInEventPage
(
)
;
await
extension
.
awaitMessage
(
"
event_fired
"
)
;
assertBackgroundState
(
"
running
"
"
Persistent
event
can
wake
up
event
page
"
)
;
info
(
"
Crash
again
"
)
;
await
crashExtensionBackground
(
extension
)
;
assertBackgroundState
(
"
stopped
"
"
Background
state
after
crash
"
)
;
Assert
.
equal
(
ExtensionProcessCrashObserver
.
processSpawningDisabled
false
"
Expect
process
spawning
to
be
enabled
"
)
;
info
(
"
Trigger
an
event
which
should
wake
up
the
event
page
again
"
)
;
triggerEventInEventPage
(
)
;
await
extension
.
awaitMessage
(
"
event_fired
"
)
;
assertBackgroundState
(
"
running
"
"
Persistent
event
can
wake
up
event
page
"
)
;
await
extension
.
unload
(
)
;
}
)
;
