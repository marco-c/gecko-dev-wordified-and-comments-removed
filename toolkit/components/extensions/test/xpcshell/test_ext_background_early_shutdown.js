"
use
strict
"
;
const
{
ExtensionTestCommon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
ExtensionTestCommon
.
sys
.
mjs
"
)
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
43
"
)
;
let
{
promiseRestartManager
promiseShutdownManager
promiseStartupManager
}
=
AddonTestUtils
;
const
{
ExtensionProcessCrashObserver
Management
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
sys
.
mjs
"
)
;
const
server
=
AddonTestUtils
.
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
]
}
)
;
function
registerSlowStyleSheet
(
)
{
let
allowStylesheetToLoad
;
let
stylesheetBlockerPromise
=
new
Promise
(
resolve
=
>
{
allowStylesheetToLoad
=
resolve
;
}
)
;
let
resolveFirstLoad
;
let
firstLoadPromise
=
new
Promise
(
resolve
=
>
{
resolveFirstLoad
=
resolve
;
}
)
;
let
requestCount
=
0
;
server
.
registerPathHandler
(
"
/
slow
.
css
"
(
request
response
)
=
>
{
response
.
setHeader
(
"
Cache
-
Control
"
"
no
-
cache
"
false
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
css
"
false
)
;
response
.
processAsync
(
)
;
+
+
requestCount
;
resolveFirstLoad
(
)
;
stylesheetBlockerPromise
.
then
(
(
)
=
>
{
response
.
write
(
"
body
{
color
:
rgb
(
1
2
3
)
;
}
"
)
;
response
.
finish
(
)
;
}
)
;
}
)
;
const
getRequestCount
=
(
)
=
>
requestCount
;
return
{
allowStylesheetToLoad
getRequestCount
firstLoadPromise
}
;
}
const
CAN_CRASH_EXTENSIONS
=
WebExtensionPolicy
.
useRemoteWebExtensions
;
add_setup
(
function
(
)
{
Services
.
prefs
.
setIntPref
(
"
extensions
.
webextensions
.
crash
.
threshold
"
100
)
;
do_get_profile
(
)
;
Services
.
fog
.
initializeFOG
(
)
;
Assert
.
equal
(
ExtensionProcessCrashObserver
.
appInForeground
AppConstants
.
platform
!
=
=
"
android
"
"
Expect
appInForeground
to
be
initially
true
on
desktop
and
false
on
android
builds
"
)
;
if
(
AppConstants
.
platform
=
=
=
"
android
"
)
{
info
(
"
Mock
geckoview
-
initial
-
foreground
observer
service
topic
"
)
;
ExtensionProcessCrashObserver
.
observe
(
null
"
geckoview
-
initial
-
foreground
"
)
;
Assert
.
equal
(
ExtensionProcessCrashObserver
.
appInForeground
true
"
Expect
appInForeground
to
be
true
after
geckoview
-
initial
-
foreground
topic
"
)
;
}
}
)
;
add_setup
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_CRASHREPORTER
|
|
!
CAN_CRASH_EXTENSIONS
}
setup_crash_reporter_override_and_cleaner
)
;
add_task
(
async
function
test_unload_extension_before_background_page_startup
(
)
{
await
promiseStartupManager
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
background
(
)
{
browser
.
test
.
sendMessage
(
"
background_startup_observed
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
background_startup_observed
"
)
;
info
(
"
Starting
extension
whose
startup
will
be
interrupted
"
)
;
await
promiseRestartManager
(
{
earlyStartup
:
false
}
)
;
await
extension
.
awaitStartup
(
)
;
let
extensionBrowserInsertions
=
0
;
let
onExtensionBrowserInserted
=
(
)
=
>
+
+
extensionBrowserInsertions
;
Management
.
on
(
"
extension
-
browser
-
inserted
"
onExtensionBrowserInserted
)
;
info
(
"
Unloading
extension
before
the
delayed
background
page
starts
loading
"
)
;
await
extension
.
addon
.
disable
(
)
;
await
extension
.
addon
.
enable
(
)
;
info
(
"
Forcing
pending
delayed
background
page
to
load
"
)
;
AddonTestUtils
.
notifyLateStartup
(
)
;
await
extension
.
awaitMessage
(
"
background_startup_observed
"
)
;
await
extension
.
unload
(
)
;
await
promiseShutdownManager
(
)
;
Management
.
off
(
"
extension
-
browser
-
inserted
"
onExtensionBrowserInserted
)
;
Assert
.
equal
(
extensionBrowserInsertions
1
"
Extension
browser
should
have
been
inserted
only
once
"
)
;
}
)
;
add_task
(
async
function
test_unload_extension_during_background_page_startup
(
)
{
await
promiseStartupManager
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
background
(
)
{
browser
.
test
.
sendMessage
(
"
background_starting
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
background_starting
"
)
;
await
promiseRestartManager
(
{
lateStartup
:
false
}
)
;
await
extension
.
awaitStartup
(
)
;
let
bgStartupPromise
=
new
Promise
(
resolve
=
>
{
function
onBackgroundPageDone
(
eventName
)
{
extension
.
extension
.
off
(
"
background
-
script
-
started
"
onBackgroundPageDone
)
;
extension
.
extension
.
off
(
"
background
-
script
-
aborted
"
onBackgroundPageDone
)
;
if
(
eventName
=
=
=
"
background
-
script
-
aborted
"
)
{
info
(
"
Background
script
startup
was
interrupted
"
)
;
resolve
(
"
bg_aborted
"
)
;
}
else
{
info
(
"
Background
script
startup
finished
normally
"
)
;
resolve
(
"
bg_fully_loaded
"
)
;
}
}
extension
.
extension
.
on
(
"
background
-
script
-
started
"
onBackgroundPageDone
)
;
extension
.
extension
.
on
(
"
background
-
script
-
aborted
"
onBackgroundPageDone
)
;
}
)
;
let
bgStartingPromise
=
new
Promise
(
resolve
=
>
{
let
backgroundLoadCount
=
0
;
let
backgroundPageUrl
=
extension
.
extension
.
baseURI
.
resolve
(
"
_generated_background_page
.
html
"
)
;
Management
.
once
(
"
extension
-
browser
-
inserted
"
(
eventName
browser
)
=
>
{
let
browserFixupAndLoadURIString
=
browser
.
fixupAndLoadURIString
;
browser
.
fixupAndLoadURIString
=
function
(
)
{
Assert
.
equal
(
+
+
backgroundLoadCount
1
"
loadURI
should
be
called
once
"
)
;
Assert
.
equal
(
arguments
[
0
]
backgroundPageUrl
"
Expected
background
page
"
)
;
arguments
[
0
]
=
"
about
:
blank
"
;
browserFixupAndLoadURIString
.
apply
(
this
arguments
)
;
if
(
CAN_CRASH_EXTENSIONS
)
{
crashFrame
(
browser
)
;
}
else
{
browser
.
remove
(
)
;
}
resolve
(
)
;
}
;
}
)
;
}
)
;
AddonTestUtils
.
notifyLateStartup
(
)
;
await
bgStartingPromise
;
await
extension
.
unload
(
)
;
await
promiseShutdownManager
(
)
;
info
(
"
Waiting
for
background
builder
to
finish
"
)
;
let
bgLoadState
=
await
bgStartupPromise
;
Assert
.
equal
(
bgLoadState
"
bg_aborted
"
"
Startup
should
be
interrupted
"
)
;
}
)
;
async
function
do_test_crash_while_starting_background
(
{
withContext
=
false
isEventPage
=
false
}
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
startupReason
:
"
APP_STARTUP
"
delayedStartup
:
true
manifest
:
{
background
:
{
page
:
"
background
.
html
"
persistent
:
!
isEventPage
}
}
files
:
{
"
background
.
html
"
:
<
!
DOCTYPE
html
>
<
meta
charset
=
"
utf
-
8
"
>
<
script
src
=
"
background
-
immediate
.
js
"
>
<
/
script
>
<
!
-
-
Delays
DOMContentLoaded
-
see
registerSlowStyleSheet
-
-
>
<
link
rel
=
"
stylesheet
"
href
=
"
http
:
/
/
example
.
com
/
slow
.
css
"
>
<
script
src
=
"
background
-
deferred
.
js
"
defer
>
<
/
script
>
"
background
-
immediate
.
js
"
:
String
.
raw
dump
(
"
background
-
immediate
.
js
is
executing
as
expected
.
\
n
"
)
;
if
(
{
!
!
withContext
}
)
{
/
/
Accessing
the
browser
API
triggers
context
creation
.
browser
.
test
.
sendMessage
(
"
background_started_to_load
"
)
;
}
"
background
-
deferred
.
js
"
:
(
)
=
>
{
dump
(
"
background
-
deferred
.
js
is
UNEXPECTEDLY
executing
.
\
n
"
)
;
browser
.
test
.
fail
(
"
Background
startup
should
have
been
interrupted
"
)
;
}
}
}
)
;
let
slowStyleSheet
=
registerSlowStyleSheet
(
)
;
await
ExtensionTestCommon
.
resetStartupPromises
(
)
;
await
extension
.
startup
(
)
;
function
assertBackgroundState
(
expected
message
)
{
Assert
.
equal
(
extension
.
extension
.
backgroundState
expected
message
)
;
}
assertBackgroundState
(
"
stopped
"
"
Background
should
not
have
started
yet
"
)
;
let
bgBrowserPromise
=
new
Promise
(
resolve
=
>
{
Management
.
once
(
"
extension
-
browser
-
inserted
"
(
eventName
browser
)
=
>
{
assertBackgroundState
(
"
starting
"
"
State
when
bg
<
browser
>
is
inserted
"
)
;
resolve
(
browser
)
;
}
)
;
}
)
;
info
(
"
Triggering
background
creation
.
.
.
"
)
;
await
ExtensionTestCommon
.
notifyEarlyStartup
(
)
;
await
ExtensionTestCommon
.
notifyLateStartup
(
)
;
let
bgBrowser
=
await
bgBrowserPromise
;
if
(
withContext
)
{
info
(
"
Waiting
for
background
-
immediate
.
js
to
notify
us
.
.
.
"
)
;
await
extension
.
awaitMessage
(
"
background_started_to_load
"
)
;
Assert
.
ok
(
extension
.
extension
.
backgroundContext
"
Context
exists
when
an
extension
API
was
called
"
)
;
await
slowStyleSheet
.
firstLoadPromise
;
}
else
{
await
slowStyleSheet
.
firstLoadPromise
;
Assert
.
ok
(
!
extension
.
extension
.
backgroundContext
"
Context
should
not
be
set
while
loading
"
)
;
}
assertBackgroundState
(
"
starting
"
"
Background
should
still
be
loading
"
)
;
await
crashExtensionBackground
(
extension
bgBrowser
)
;
assertBackgroundState
(
"
stopped
"
"
Background
state
after
crash
"
)
;
slowStyleSheet
.
allowStylesheetToLoad
(
)
;
await
extension
.
unload
(
)
;
Assert
.
equal
(
slowStyleSheet
.
getRequestCount
(
)
1
"
Expected
exactly
one
request
for
slow
.
css
from
background
page
"
)
;
}
add_task
(
{
pref_set
:
[
[
"
extensions
.
background
.
disableRestartPersistentAfterCrash
"
true
]
]
}
async
function
test_crash_while_starting_background_without_context
(
)
{
await
do_test_crash_while_starting_background
(
{
withContext
:
false
}
)
;
}
)
;
add_task
(
{
pref_set
:
[
[
"
extensions
.
background
.
disableRestartPersistentAfterCrash
"
true
]
]
}
async
function
test_crash_while_starting_background_with_context
(
)
{
await
do_test_crash_while_starting_background
(
{
withContext
:
true
}
)
;
}
)
;
add_task
(
async
function
test_crash_while_starting_event_page_without_context
(
)
{
await
do_test_crash_while_starting_background
(
{
withContext
:
false
isEventPage
:
true
}
)
;
}
)
;
add_task
(
async
function
test_crash_while_starting_event_page_with_context
(
)
{
await
do_test_crash_while_starting_background
(
{
withContext
:
true
isEventPage
:
true
}
)
;
}
)
;
async
function
do_test_crash_while_running_background
(
{
isEventPage
=
false
}
)
{
await
ExtensionTestCommon
.
resetStartupPromises
(
)
;
await
AddonTestUtils
.
notifyEarlyStartup
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
background
:
{
persistent
:
!
isEventPage
}
}
background
(
)
{
window
.
onload
=
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
background_has_fully_loaded
"
)
;
}
;
}
}
)
;
await
extension
.
startup
(
)
;
function
assertBackgroundState
(
expected
message
)
{
Assert
.
equal
(
extension
.
extension
.
backgroundState
expected
message
)
;
}
await
extension
.
awaitMessage
(
"
background_has_fully_loaded
"
)
;
assertBackgroundState
(
"
running
"
"
Background
should
have
started
"
)
;
await
crashExtensionBackground
(
extension
)
;
assertBackgroundState
(
"
stopped
"
"
Background
state
after
crash
"
)
;
await
extension
.
wakeupBackground
(
)
;
await
extension
.
awaitMessage
(
"
background_has_fully_loaded
"
)
;
assertBackgroundState
(
"
running
"
"
Background
resumed
after
crash
recovery
"
)
;
await
extension
.
terminateBackground
(
)
;
assertBackgroundState
(
"
stopped
"
"
Background
can
sleep
after
crash
recovery
"
)
;
await
extension
.
unload
(
)
;
}
add_task
(
{
pref_set
:
[
[
"
extensions
.
background
.
disableRestartPersistentAfterCrash
"
true
]
]
}
async
function
test_crash_after_background_startup
(
)
{
await
do_test_crash_while_running_background
(
{
isEventPage
:
false
}
)
;
}
)
;
add_task
(
async
function
test_crash_after_event_page_startup
(
)
{
await
do_test_crash_while_running_background
(
{
isEventPage
:
true
}
)
;
}
)
;
add_task
(
async
function
test_crash_and_wakeup_via_persistent_listeners
(
)
{
await
ExtensionTestCommon
.
resetStartupPromises
(
)
;
await
AddonTestUtils
.
notifyEarlyStartup
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
background
:
{
persistent
:
false
}
optional_permissions
:
[
"
tabs
"
]
}
background
(
)
{
const
domreadyPromise
=
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
"
load
"
resolve
{
once
:
true
}
)
;
}
)
;
browser
.
permissions
.
onAdded
.
addListener
(
(
)
=
>
{
browser
.
test
.
log
(
"
permissions
.
onAdded
has
fired
"
)
;
domreadyPromise
.
then
(
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
event_fired
"
)
;
}
)
;
}
)
;
}
}
)
;
await
extension
.
startup
(
)
;
function
assertBackgroundState
(
expected
message
)
{
Assert
.
equal
(
extension
.
extension
.
backgroundState
expected
message
)
;
}
function
triggerEventInEventPage
(
)
{
Management
.
emit
(
"
change
-
permissions
"
{
extensionId
:
extension
.
id
added
:
{
origins
:
[
]
permissions
:
[
"
tabs
"
]
}
}
)
;
}
assertBackgroundState
(
"
running
"
"
Background
after
extension
.
startup
(
)
"
)
;
triggerEventInEventPage
(
)
;
await
extension
.
awaitMessage
(
"
event_fired
"
)
;
const
TEST_RESTART_ATTEMPTS
=
5
;
for
(
let
i
=
1
;
i
<
=
TEST_RESTART_ATTEMPTS
;
+
+
i
)
{
info
(
Testing
that
a
crashed
background
wakes
via
event
attempt
{
i
}
/
5
)
;
await
crashExtensionBackground
(
extension
)
;
assertBackgroundState
(
"
stopped
"
"
Background
state
after
crash
"
)
;
triggerEventInEventPage
(
)
;
await
extension
.
awaitMessage
(
"
event_fired
"
)
;
assertBackgroundState
(
"
running
"
"
Persistent
event
can
wake
up
event
page
"
)
;
}
await
extension
.
unload
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
CAN_CRASH_EXTENSIONS
pref_set
:
[
[
"
extensions
.
webextensions
.
crash
.
threshold
"
3
]
[
"
extensions
.
webextensions
.
crash
.
timeframe
"
60
*
1000
]
]
}
async
function
test_process_spawning_disabled_because_of_too_many_crashes
(
)
{
ExtensionProcessCrashObserver
.
enableProcessSpawning
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
function
assertCrashThresholdTelemetry
(
{
expectToBeSet
}
)
{
equal
(
undefined
Glean
.
extensions
.
processEvent
.
crashed_over_threshold_bg
.
testGetValue
(
)
Initial
value
of
crashed_over_threshold_bg
.
)
;
if
(
expectToBeSet
)
{
Assert
.
greater
(
Glean
.
extensions
.
processEvent
.
crashed_over_threshold_fg
.
testGetValue
(
)
0
"
Expect
crashed_over_threshold_fg
count
to
be
set
.
"
)
;
return
;
}
equal
(
undefined
Glean
.
extensions
.
processEvent
.
crashed_over_threshold_fg
.
testGetValue
(
)
Initial
value
of
crashed_over_threshold_fg
.
)
;
}
assertCrashThresholdTelemetry
(
{
expectToBeSet
:
false
}
)
;
Assert
.
equal
(
ExtensionProcessCrashObserver
.
processSpawningDisabled
false
"
Expect
process
spawning
to
be
enabled
"
)
;
await
ExtensionTestCommon
.
resetStartupPromises
(
)
;
await
AddonTestUtils
.
notifyEarlyStartup
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
background
:
{
persistent
:
false
}
optional_permissions
:
[
"
tabs
"
]
}
background
(
)
{
const
domreadyPromise
=
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
"
load
"
resolve
{
once
:
true
}
)
;
}
)
;
browser
.
permissions
.
onAdded
.
addListener
(
(
)
=
>
{
browser
.
test
.
log
(
"
permissions
.
onAdded
has
fired
"
)
;
domreadyPromise
.
then
(
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
event_fired
"
)
;
}
)
;
}
)
;
}
}
)
;
await
extension
.
startup
(
)
;
function
assertBackgroundState
(
expected
message
)
{
Assert
.
equal
(
extension
.
extension
.
backgroundState
expected
message
)
;
}
function
triggerEventInEventPage
(
)
{
Management
.
emit
(
"
change
-
permissions
"
{
extensionId
:
extension
.
id
added
:
{
origins
:
[
]
permissions
:
[
"
tabs
"
]
}
}
)
;
}
assertBackgroundState
(
"
running
"
"
Background
after
extension
.
startup
(
)
"
)
;
triggerEventInEventPage
(
)
;
await
extension
.
awaitMessage
(
"
event_fired
"
)
;
const
TEST_RESTART_ATTEMPTS
=
3
;
for
(
let
i
=
1
;
i
<
=
TEST_RESTART_ATTEMPTS
;
+
+
i
)
{
info
(
Crash
/
restart
extension
background
attempt
{
i
}
/
{
TEST_RESTART_ATTEMPTS
}
)
;
await
crashExtensionBackground
(
extension
)
;
assertBackgroundState
(
"
stopped
"
"
Background
state
after
crash
"
)
;
triggerEventInEventPage
(
)
;
await
extension
.
awaitMessage
(
"
event_fired
"
)
;
assertBackgroundState
(
"
running
"
"
Persistent
event
can
wake
up
event
page
"
)
;
}
assertCrashThresholdTelemetry
(
{
expectToBeSet
:
false
}
)
;
info
(
"
Crash
one
more
time
"
)
;
await
crashExtensionBackground
(
extension
)
;
assertCrashThresholdTelemetry
(
{
expectToBeSet
:
true
}
)
;
Assert
.
ok
(
ExtensionProcessCrashObserver
.
processSpawningDisabled
"
Expect
process
spawning
to
be
disabled
"
)
;
info
(
"
Trigger
an
event
which
shouldn
'
t
wake
up
the
event
page
"
)
;
triggerEventInEventPage
(
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
100
)
)
;
assertBackgroundState
(
"
stopped
"
"
Background
should
not
have
started
yet
"
)
;
info
(
"
Enable
process
spawning
"
)
;
ExtensionProcessCrashObserver
.
enableProcessSpawning
(
)
;
Assert
.
equal
(
ExtensionProcessCrashObserver
.
processSpawningDisabled
false
"
Expect
process
spawning
to
be
enabled
"
)
;
assertBackgroundState
(
"
stopped
"
"
Background
should
still
be
suspended
"
)
;
info
(
"
Trigger
an
event
which
should
wake
up
the
event
page
"
)
;
triggerEventInEventPage
(
)
;
await
extension
.
awaitMessage
(
"
event_fired
"
)
;
assertBackgroundState
(
"
running
"
"
Persistent
event
can
wake
up
event
page
"
)
;
info
(
"
Crash
again
"
)
;
await
crashExtensionBackground
(
extension
)
;
assertBackgroundState
(
"
stopped
"
"
Background
state
after
crash
"
)
;
Assert
.
equal
(
ExtensionProcessCrashObserver
.
processSpawningDisabled
false
"
Expect
process
spawning
to
be
enabled
"
)
;
info
(
"
Trigger
an
event
which
should
wake
up
the
event
page
again
"
)
;
triggerEventInEventPage
(
)
;
await
extension
.
awaitMessage
(
"
event_fired
"
)
;
assertBackgroundState
(
"
running
"
"
Persistent
event
can
wake
up
event
page
"
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
CAN_CRASH_EXTENSIONS
pref_set
:
[
[
"
extensions
.
webextensions
.
crash
.
threshold
"
2
]
[
"
extensions
.
webextensions
.
crash
.
timeframe
"
60
*
1000
]
]
}
async
function
test_background_restarted_after_crash
(
)
{
ExtensionProcessCrashObserver
.
enableProcessSpawning
(
)
;
Assert
.
equal
(
ExtensionProcessCrashObserver
.
processSpawningDisabled
false
"
Expect
process
spawning
to
be
enabled
"
)
;
function
assertCrashThresholdTelemetry
(
{
fg
bg
}
)
{
if
(
fg
)
{
Assert
.
greater
(
Glean
.
extensions
.
processEvent
.
crashed_over_threshold_fg
.
testGetValue
(
)
0
"
Expect
crashed_over_threshold_fg
count
to
be
set
.
"
)
;
}
else
{
equal
(
undefined
Glean
.
extensions
.
processEvent
.
crashed_over_threshold_fg
.
testGetValue
(
)
Initial
value
of
crashed_over_threshold_fg
.
)
;
}
if
(
bg
)
{
Assert
.
greater
(
Glean
.
extensions
.
processEvent
.
crashed_over_threshold_bg
.
testGetValue
(
)
0
"
Expect
crashed_over_threshold_bg
count
to
be
set
.
"
)
;
}
else
{
equal
(
undefined
Glean
.
extensions
.
processEvent
.
crashed_over_threshold_bg
.
testGetValue
(
)
Initial
value
of
crashed_over_threshold_bg
.
)
;
}
}
await
ExtensionTestCommon
.
resetStartupPromises
(
)
;
await
AddonTestUtils
.
notifyEarlyStartup
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
background
:
{
persistent
:
true
}
}
background
(
)
{
window
.
addEventListener
(
"
load
"
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
persistentbg_started
"
)
;
}
{
once
:
true
}
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
persistentbg_started
"
)
;
function
assertBackgroundState
(
expected
message
)
{
Assert
.
equal
(
extension
.
extension
.
backgroundState
expected
message
)
;
}
async
function
assertStillStoppedAfterTimeout
(
timeout
=
100
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
timeout
)
)
;
assertBackgroundState
(
"
stopped
"
"
Background
should
still
be
stopped
"
)
;
}
async
function
mockCrashOnAndroidAppInBackground
(
)
{
info
(
"
Mock
application
-
background
observer
service
topic
"
)
;
ExtensionProcessCrashObserver
.
observe
(
null
"
application
-
background
"
)
;
Assert
.
equal
(
ExtensionProcessCrashObserver
.
appInForeground
false
"
Got
expected
value
set
on
ExtensionProcessCrashObserver
.
appInForeground
"
)
;
await
crashExtensionBackground
(
extension
)
;
assertBackgroundState
(
"
stopped
"
"
Persistent
Background
state
after
crash
while
in
the
background
"
)
;
await
assertStillStoppedAfterTimeout
(
)
;
info
(
"
Mock
application
-
foreground
observer
service
topic
"
)
;
ExtensionProcessCrashObserver
.
observe
(
null
"
application
-
foreground
"
)
;
Assert
.
equal
(
ExtensionProcessCrashObserver
.
appInForeground
true
"
Ensure
the
application
is
detected
as
being
in
foreground
"
)
;
}
assertBackgroundState
(
"
running
"
"
Background
after
extension
.
startup
(
)
"
)
;
info
(
"
Testing
that
a
crashed
persistent
background
is
restarted
after
a
crash
"
)
;
Assert
.
equal
(
ExtensionProcessCrashObserver
.
appInForeground
true
"
Ensure
the
application
is
detected
as
being
in
foreground
"
)
;
await
crashExtensionBackground
(
extension
)
;
await
extension
.
awaitMessage
(
"
persistentbg_started
"
)
;
assertBackgroundState
(
"
running
"
"
Persistent
Background
state
after
crash
"
)
;
if
(
ExtensionProcessCrashObserver
.
_isAndroid
)
{
await
mockCrashOnAndroidAppInBackground
(
)
;
}
else
{
await
crashExtensionBackground
(
extension
)
;
}
info
(
"
Wait
for
the
persistent
background
context
to
be
started
"
)
;
await
extension
.
awaitMessage
(
"
persistentbg_started
"
)
;
assertBackgroundState
(
"
running
"
"
Persistent
Background
state
after
crash
"
)
;
info
(
"
Mock
another
crash
to
be
exceeding
enforced
crash
threshold
"
)
;
assertCrashThresholdTelemetry
(
{
fg
:
false
bg
:
false
}
)
;
if
(
ExtensionProcessCrashObserver
.
_isAndroid
)
{
await
mockCrashOnAndroidAppInBackground
(
)
;
assertCrashThresholdTelemetry
(
{
fg
:
false
bg
:
true
}
)
;
}
else
{
await
crashExtensionBackground
(
extension
)
;
assertCrashThresholdTelemetry
(
{
fg
:
true
bg
:
false
}
)
;
}
Assert
.
ok
(
ExtensionProcessCrashObserver
.
processSpawningDisabled
"
Expect
process
spawning
to
be
disabled
"
)
;
assertBackgroundState
(
"
stopped
"
"
Persistent
Background
state
after
crash
exceeding
threshold
"
)
;
await
assertStillStoppedAfterTimeout
(
)
;
info
(
"
Enable
process
spawning
"
)
;
ExtensionProcessCrashObserver
.
enableProcessSpawning
(
)
;
Assert
.
equal
(
ExtensionProcessCrashObserver
.
processSpawningDisabled
false
"
Expect
process
spawning
to
be
enabled
"
)
;
info
(
"
Wait
for
Persistent
Background
Context
to
be
started
"
)
;
await
extension
.
awaitMessage
(
"
persistentbg_started
"
)
;
assertBackgroundState
(
"
running
"
"
Persistent
Background
to
be
running
"
)
;
await
crashExtensionBackground
(
extension
)
;
info
(
"
Wait
for
Persistent
Background
Context
to
be
started
"
)
;
await
extension
.
awaitMessage
(
"
persistentbg_started
"
)
;
assertBackgroundState
(
"
running
"
"
Persistent
Background
to
be
running
"
)
;
if
(
ExtensionProcessCrashObserver
.
_isAndroid
)
{
Assert
.
equal
(
ExtensionProcessCrashObserver
.
appInForeground
true
"
Ensure
the
application
is
detected
as
being
in
foreground
"
)
;
await
crashExtensionBackground
(
extension
)
;
info
(
"
Wait
for
Persistent
Background
Context
to
be
started
"
)
;
await
extension
.
awaitMessage
(
"
persistentbg_started
"
)
;
assertBackgroundState
(
"
running
"
"
Persistent
Background
to
be
running
"
)
;
await
crashExtensionBackground
(
extension
)
;
assertCrashThresholdTelemetry
(
{
fg
:
true
bg
:
true
}
)
;
Assert
.
ok
(
ExtensionProcessCrashObserver
.
processSpawningDisabled
"
Expect
process
spawning
to
be
disabled
"
)
;
await
assertStillStoppedAfterTimeout
(
)
;
}
await
extension
.
unload
(
)
;
}
)
;
