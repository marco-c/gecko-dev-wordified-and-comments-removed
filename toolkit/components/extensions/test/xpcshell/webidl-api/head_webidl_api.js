"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
ExtensionTestCommon
:
"
resource
:
/
/
testing
-
common
/
ExtensionTestCommon
.
jsm
"
}
)
;
function
getBackgroundServiceWorkerRegistration
(
extension
)
{
const
swm
=
Cc
[
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
]
.
getService
(
Ci
.
nsIServiceWorkerManager
)
;
const
swRegs
=
swm
.
getAllRegistrations
(
)
;
const
scope
=
moz
-
extension
:
/
/
{
extension
.
uuid
}
/
;
for
(
let
i
=
0
;
i
<
swRegs
.
length
;
i
+
+
)
{
let
regInfo
=
swRegs
.
queryElementAt
(
i
Ci
.
nsIServiceWorkerRegistrationInfo
)
;
if
(
regInfo
.
scope
=
=
=
scope
)
{
return
regInfo
;
}
}
}
function
waitForTerminatedWorkers
(
swRegInfo
)
{
info
(
Wait
all
{
swRegInfo
.
scope
}
workers
to
be
terminated
)
;
return
TestUtils
.
waitForCondition
(
(
)
=
>
{
const
{
evaluatingWorker
installingWorker
waitingWorker
activeWorker
}
=
swRegInfo
;
return
!
(
evaluatingWorker
|
|
installingWorker
|
|
waitingWorker
|
|
activeWorker
)
;
}
wait
workers
for
scope
{
swRegInfo
.
scope
}
to
be
terminated
)
;
}
function
unmockHandleAPIRequest
(
extPage
)
{
return
extPage
.
spawn
(
[
]
(
)
=
>
{
const
{
ExtensionAPIRequestHandler
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionProcessScript
.
jsm
"
)
;
if
(
ExtensionAPIRequestHandler
.
_handleAPIRequest_orig
)
{
ExtensionAPIRequestHandler
.
handleAPIRequest
=
ExtensionAPIRequestHandler
.
_handleAPIRequest_orig
;
delete
ExtensionAPIRequestHandler
.
_handleAPIRequest_orig
;
}
}
)
;
}
function
mockHandleAPIRequest
(
extPage
mockHandleAPIRequest
)
{
mockHandleAPIRequest
=
mockHandleAPIRequest
|
|
(
(
policy
request
)
=
>
{
const
ExtError
=
request
.
window
?
.
Error
|
|
Error
;
return
{
type
:
Ci
.
mozIExtensionAPIRequestResult
.
EXTENSION_ERROR
value
:
new
ExtError
(
"
mockHandleAPIRequest
not
defined
by
this
test
case
"
)
}
;
}
)
;
return
extPage
.
spawn
(
[
ExtensionTestCommon
.
serializeFunction
(
mockHandleAPIRequest
)
]
mockFnText
=
>
{
const
{
ExtensionAPIRequestHandler
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionProcessScript
.
jsm
"
)
;
mockFnText
=
(
(
)
=
>
{
return
(
{
mockFnText
}
)
;
}
)
(
)
;
;
const
mockFn
=
eval
(
mockFnText
)
;
if
(
!
ExtensionAPIRequestHandler
.
_handleAPIRequest_orig
)
{
ExtensionAPIRequestHandler
.
_handleAPIRequest_orig
=
ExtensionAPIRequestHandler
.
handleAPIRequest
;
}
ExtensionAPIRequestHandler
.
handleAPIRequest
=
function
(
policy
request
)
{
if
(
request
.
apiNamespace
=
=
=
"
test
"
)
{
return
this
.
_handleAPIRequest_orig
(
policy
request
)
;
}
return
mockFn
.
call
(
this
policy
request
)
;
}
;
}
)
;
}
async
function
runExtensionAPITest
(
testDescription
{
backgroundScript
assertResults
mockAPIRequestHandler
extensionId
=
"
test
-
ext
-
api
-
request
-
forward
mochitest
"
}
)
{
function
backgroundScriptWrapper
(
testParams
testFn
)
{
const
testLog
=
msg
=
>
{
dump
(
"
{
testParams
.
extensionId
}
"
:
{
msg
}
\
n
)
;
}
;
const
testAsserts
=
{
isErrorInstance
(
err
)
{
if
(
!
(
err
instanceof
Error
)
)
{
throw
new
Error
(
"
Unexpected
error
:
not
an
instance
of
Error
"
)
;
}
return
true
;
}
isInstanceOf
(
value
globalConstructorName
)
{
if
(
!
(
value
instanceof
self
[
globalConstructorName
]
)
)
{
throw
new
Error
(
Unexpected
error
:
expected
instance
of
{
globalConstructorName
}
)
;
}
return
true
;
}
equal
(
val
exp
msg
)
{
if
(
val
!
=
=
exp
)
{
throw
new
Error
(
Unexpected
error
:
expected
{
exp
}
but
got
{
val
}
.
{
msg
}
)
;
}
}
}
;
testLog
(
Evaluating
-
test
case
"
{
testParams
.
testDescription
}
"
)
;
self
.
onmessage
=
async
evt
=
>
{
testLog
(
Running
test
case
"
{
testParams
.
testDescription
}
"
)
;
let
testError
=
null
;
let
testResult
;
try
{
testResult
=
await
testFn
(
{
testLog
testAsserts
}
)
;
}
catch
(
err
)
{
testError
=
{
message
:
err
.
message
stack
:
err
.
stack
}
;
testLog
(
Unexpected
test
error
:
{
err
}
:
:
{
err
.
stack
}
\
n
)
;
}
evt
.
ports
[
0
]
.
postMessage
(
{
success
:
!
testError
testError
testResult
}
)
;
testLog
(
Test
case
"
{
testParams
.
testDescription
}
"
executed
)
;
}
;
testLog
(
Wait
onmessage
event
-
test
case
"
{
testParams
.
testDescription
}
"
)
;
}
async
function
assertTestResult
(
result
)
{
if
(
assertResults
)
{
await
assertResults
(
result
)
;
}
else
{
equal
(
result
.
testError
undefined
"
Expect
no
errors
"
)
;
ok
(
result
.
success
"
Test
completed
successfully
"
)
;
}
}
async
function
runTestCaseInWorker
(
page
)
{
info
(
*
*
*
Run
test
case
in
an
extension
service
worker
)
;
const
result
=
await
page
.
spawn
(
[
]
async
(
)
=
>
{
const
{
active
}
=
await
content
.
navigator
.
serviceWorker
.
ready
;
const
{
port1
port2
}
=
new
MessageChannel
(
)
;
return
new
Promise
(
resolve
=
>
{
port1
.
onmessage
=
evt
=
>
resolve
(
evt
.
data
)
;
active
.
postMessage
(
"
run
-
test
"
[
port2
]
)
;
}
)
;
}
)
;
info
(
*
*
*
Assert
test
case
results
got
from
extension
service
worker
)
;
await
assertTestResult
(
result
)
;
}
const
scriptFnParam
=
ExtensionTestCommon
.
serializeFunction
(
backgroundScript
)
;
const
testOptsParam
=
{
JSON
.
stringify
(
{
testDescription
extensionId
}
)
}
;
const
testExtData
=
{
useAddonManager
:
"
temporary
"
manifest
:
{
version
:
"
1
"
background
:
{
service_worker
:
"
test
-
sw
.
js
"
}
applications
:
{
gecko
:
{
id
:
extensionId
}
}
}
files
:
{
"
page
.
html
"
:
<
!
DOCTYPE
html
>
<
head
>
<
meta
charset
=
"
utf
-
8
"
>
<
/
head
>
<
body
>
<
script
src
=
"
test
-
sw
.
js
"
>
<
/
script
>
<
/
body
>
"
test
-
sw
.
js
"
:
(
{
backgroundScriptWrapper
}
)
(
{
testOptsParam
}
{
scriptFnParam
}
)
;
}
}
;
let
cleanupCalled
=
false
;
let
extension
;
let
page
;
let
swReg
;
async
function
testCleanup
(
)
{
if
(
cleanupCalled
)
{
return
;
}
cleanupCalled
=
true
;
await
unmockHandleAPIRequest
(
page
)
;
await
page
.
close
(
)
;
await
extension
.
unload
(
)
;
await
waitForTerminatedWorkers
(
swReg
)
;
}
info
(
Start
test
case
"
{
testDescription
}
"
)
;
extension
=
ExtensionTestUtils
.
loadExtension
(
testExtData
)
;
await
extension
.
startup
(
)
;
swReg
=
getBackgroundServiceWorkerRegistration
(
extension
)
;
ok
(
swReg
"
Extension
background
.
service_worker
should
be
registered
"
)
;
page
=
await
ExtensionTestUtils
.
loadContentPage
(
moz
-
extension
:
/
/
{
extension
.
uuid
}
/
page
.
html
{
extension
}
)
;
registerCleanupFunction
(
testCleanup
)
;
await
mockHandleAPIRequest
(
page
mockAPIRequestHandler
)
;
await
runTestCaseInWorker
(
page
)
;
await
testCleanup
(
)
;
info
(
End
test
case
"
{
testDescription
}
"
)
;
}
