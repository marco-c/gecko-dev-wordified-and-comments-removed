"
use
strict
"
;
const
{
ExtensionTestCommon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
ExtensionTestCommon
.
sys
.
mjs
"
)
;
const
{
ExtensionUserScripts
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUserScripts
.
sys
.
mjs
"
)
;
const
server
=
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
"
example
.
net
"
]
}
)
;
server
.
registerPathHandler
(
"
/
dummy
"
(
)
=
>
{
}
)
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
const
{
ExtensionPermissions
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ExtensionPermissions
.
sys
.
mjs
"
)
;
async
function
grantUserScriptsPermission
(
extensionId
)
{
await
ExtensionPermissions
.
add
(
extensionId
{
permissions
:
[
"
userScripts
"
]
origins
:
[
]
}
)
;
}
add_setup
(
async
(
)
=
>
{
await
ExtensionTestUtils
.
startAddonManager
(
)
;
}
)
;
add_task
(
async
function
test_runtime_messaging_errors
(
)
{
const
extensionId
=
"
test_runtime_messaging_errors
"
;
await
grantUserScriptsPermission
(
extensionId
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
manifest
:
{
browser_specific_settings
:
{
gecko
:
{
id
:
extensionId
}
}
manifest_version
:
3
optional_permissions
:
[
"
userScripts
"
]
host_permissions
:
[
"
*
:
/
/
example
.
com
/
*
"
]
content_scripts
:
[
{
js
:
[
"
contentscript_expose_test
.
js
"
]
matches
:
[
"
*
:
/
/
example
.
com
/
dummy
"
]
run_at
:
"
document_start
"
}
]
}
files
:
{
"
contentscript_expose_test
.
js
"
:
(
)
=
>
{
window
.
wrappedJSObject
.
contentscriptTest
=
cloneInto
(
browser
.
test
window
{
cloneFunctions
:
true
}
)
;
}
"
userscript
.
js
"
:
async
(
)
=
>
{
const
contentscriptTest
=
window
.
wrappedJSObject
.
contentscriptTest
;
function
assertThrows
(
cb
expectedError
desc
)
{
let
actualErrorMessage
;
try
{
cb
(
)
;
actualErrorMessage
=
"
Unexpectedly
not
thrown
"
;
}
catch
(
e
)
{
actualErrorMessage
=
e
.
message
;
}
contentscriptTest
.
assertEq
(
expectedError
actualErrorMessage
desc
)
;
}
async
function
assertRejects
(
promise
expectedError
desc
)
{
let
actualErrorMessage
;
try
{
await
promise
;
actualErrorMessage
=
"
Unexpectedly
not
rejected
"
;
}
catch
(
e
)
{
actualErrorMessage
=
e
.
message
;
}
contentscriptTest
.
assertEq
(
expectedError
actualErrorMessage
desc
)
;
}
try
{
assertThrows
(
(
)
=
>
browser
.
runtime
.
sendMessage
(
)
"
runtime
.
sendMessage
'
s
message
argument
is
missing
"
"
sendMessage
without
params
"
)
;
assertThrows
(
(
)
=
>
browser
.
runtime
.
sendMessage
(
"
extensionId
"
"
message
"
)
"
runtime
.
sendMessage
received
too
many
arguments
"
"
sendMessage
with
unsupported
extensionId
parameter
"
)
;
assertThrows
(
(
)
=
>
browser
.
runtime
.
sendMessage
(
"
message
"
{
}
)
"
runtime
.
sendMessage
received
too
many
arguments
"
"
sendMessage
with
unsupported
options
parameter
"
)
;
assertThrows
(
(
)
=
>
browser
.
runtime
.
sendMessage
(
location
)
"
Location
object
could
not
be
cloned
.
"
"
sendMessage
with
non
-
cloneable
message
"
)
;
await
assertRejects
(
browser
.
runtime
.
sendMessage
(
"
msg
"
)
"
Could
not
establish
connection
.
Receiving
end
does
not
exist
.
"
"
Expected
error
when
there
is
no
onUserScriptMessage
handler
"
)
;
assertThrows
(
(
)
=
>
browser
.
runtime
.
connect
(
"
extensionId
"
{
}
)
"
extensionId
is
not
supported
"
"
connect
with
unsupported
extensionId
parameter
"
)
;
assertThrows
(
(
)
=
>
browser
.
runtime
.
connect
(
"
extensionId
"
)
"
extensionId
is
not
supported
"
"
connect
with
unsupported
extensionId
parameter
and
no
options
"
)
;
assertThrows
(
(
)
=
>
browser
.
runtime
.
connect
(
{
unknownProp
:
true
}
)
Type
error
for
parameter
connectInfo
(
Unexpected
property
"
unknownProp
"
)
for
runtime
.
connect
.
"
connect
with
unrecognized
property
"
)
;
assertThrows
(
(
)
=
>
browser
.
runtime
.
connect
(
{
}
{
}
)
"
Incorrect
argument
types
for
runtime
.
connect
.
"
"
connect
with
too
many
parameters
"
)
;
}
catch
(
e
)
{
contentscriptTest
.
fail
(
Unexpected
error
in
userscript
.
js
:
{
e
}
)
;
}
contentscriptTest
.
sendMessage
(
"
done
"
)
;
}
}
async
background
(
)
{
await
browser
.
userScripts
.
configureWorld
(
{
messaging
:
true
}
)
;
await
browser
.
userScripts
.
register
(
[
{
id
:
"
error
checker
"
matches
:
[
"
*
:
/
/
example
.
com
/
dummy
"
]
js
:
[
{
file
:
"
userscript
.
js
"
}
]
}
]
)
;
browser
.
test
.
sendMessage
(
"
registered
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
registered
"
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
http
:
/
/
example
.
com
/
dummy
"
)
;
await
extension
.
awaitMessage
(
"
done
"
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_onUserScriptMessage
(
)
{
const
extensionId
=
"
test_onUserScriptMessage
"
;
await
grantUserScriptsPermission
(
extensionId
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
manifest
:
{
browser_specific_settings
:
{
gecko
:
{
id
:
extensionId
}
}
manifest_version
:
3
optional_permissions
:
[
"
userScripts
"
]
host_permissions
:
[
"
*
:
/
/
example
.
com
/
*
"
]
}
files
:
{
"
userscript
.
js
"
:
async
(
)
=
>
{
let
responses
=
[
await
browser
.
runtime
.
sendMessage
(
"
expectPromiseResult
"
)
await
browser
.
runtime
.
sendMessage
(
"
expectSendResponse
"
)
await
browser
.
runtime
.
sendMessage
(
"
expectSendResponseAsync
"
)
await
browser
.
runtime
.
sendMessage
(
"
expectDefaultResponse
"
)
]
;
browser
.
runtime
.
sendMessage
(
responses
)
;
}
}
background
(
)
{
browser
.
runtime
.
onUserScriptMessage
.
addListener
(
(
msg
sender
sendResponse
)
=
>
{
browser
.
test
.
assertEq
(
"
"
sender
.
userScriptWorldId
Expected
userScriptWorldId
in
onUserScriptMessage
for
:
{
msg
}
)
;
switch
(
msg
)
{
case
"
expectPromiseResult
"
:
return
Promise
.
resolve
(
"
Promise
"
)
;
case
"
expectSendResponse
"
:
sendResponse
(
"
sendResponse
"
)
;
return
;
case
"
expectSendResponseAsync
"
:
setTimeout
(
(
)
=
>
sendResponse
(
"
sendResponseAsync
"
)
50
)
;
return
true
;
case
"
expectDefaultResponse
"
:
return
;
default
:
browser
.
test
.
assertDeepEq
(
[
"
Promise
"
"
sendResponse
"
"
sendResponseAsync
"
undefined
]
msg
"
All
sendMessage
calls
got
the
expected
response
"
)
;
browser
.
test
.
sendMessage
(
"
testRuntimeSendMessage
:
done
"
)
;
}
}
)
;
browser
.
runtime
.
onInstalled
.
addListener
(
async
(
)
=
>
{
await
browser
.
userScripts
.
configureWorld
(
{
messaging
:
true
}
)
;
await
browser
.
userScripts
.
register
(
[
{
id
:
"
messaging
checker
"
matches
:
[
"
*
:
/
/
example
.
com
/
dummy
"
]
js
:
[
{
file
:
"
userscript
.
js
"
}
]
}
]
)
;
browser
.
test
.
sendMessage
(
"
registered
"
)
;
}
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
registered
"
)
;
async
function
testRuntimeSendMessage
(
)
{
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
http
:
/
/
example
.
com
/
dummy
"
)
;
await
extension
.
awaitMessage
(
"
testRuntimeSendMessage
:
done
"
)
;
await
contentPage
.
close
(
)
;
}
info
(
"
Loading
page
that
should
trigger
runtime
.
sendMessage
"
)
;
await
testRuntimeSendMessage
(
)
;
await
AddonTestUtils
.
promiseShutdownManager
(
)
;
ExtensionUserScripts
.
_getStoreForTesting
(
)
.
_uninitForTesting
(
)
;
await
AddonTestUtils
.
promiseStartupManager
(
)
;
await
extension
.
awaitStartup
(
)
;
ExtensionTestCommon
.
testAssertions
.
assertBackgroundStatusStopped
(
extension
)
;
info
(
"
Loading
page
that
should
load
user
script
and
wake
event
page
"
)
;
await
testRuntimeSendMessage
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_configureWorld_messaging_existing_world
(
)
{
const
extensionId
=
"
test_configureWorld_messaging_existing_world
"
;
await
grantUserScriptsPermission
(
extensionId
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
manifest
:
{
browser_specific_settings
:
{
gecko
:
{
id
:
extensionId
}
}
manifest_version
:
3
optional_permissions
:
[
"
userScripts
"
]
host_permissions
:
[
"
*
:
/
/
example
.
com
/
*
"
]
content_scripts
:
[
{
js
:
[
"
contentscript_result_reporter
.
js
"
]
matches
:
[
"
*
:
/
/
example
.
com
/
dummy
"
]
run_at
:
"
document_start
"
}
]
}
files
:
{
"
contentscript_result_reporter
.
js
"
:
(
)
=
>
{
window
.
wrappedJSObject
.
reportResultViaContentScript
=
exportFunction
(
msg
=
>
browser
.
runtime
.
sendMessage
(
msg
)
window
)
;
}
"
userscript
.
js
"
:
async
(
)
=
>
{
try
{
dump
(
"
Trying
to
call
sendMessage
(
initial_message
)
\
n
"
)
;
await
browser
.
runtime
.
sendMessage
(
"
initial_message
"
)
;
dump
(
"
Trying
to
call
sendMessage
(
after_messaging_false
)
\
n
"
)
;
await
browser
.
runtime
.
sendMessage
(
"
after_messaging_false
"
)
;
dump
(
"
Reloading
page
\
n
"
)
;
location
.
reload
(
)
;
}
catch
(
e
)
{
window
.
wrappedJSObject
.
reportResultViaContentScript
(
Result
:
{
e
}
)
;
}
}
}
async
background
(
)
{
let
msgCount
=
0
;
browser
.
runtime
.
onUserScriptMessage
.
addListener
(
async
(
msg
sender
)
=
>
{
+
+
msgCount
;
browser
.
test
.
assertEq
(
"
non_default_worldId
"
sender
.
userScriptWorldId
"
Expected
userScriptWorldId
in
onUserScriptMessage
"
)
;
if
(
msgCount
=
=
=
1
)
{
browser
.
test
.
assertEq
(
"
initial_message
"
msg
"
Initial
message
"
)
;
browser
.
test
.
log
(
"
Calling
configureWorld
with
messaging
=
false
"
)
;
await
browser
.
userScripts
.
configureWorld
(
{
worldId
:
"
non_default_worldId
"
messaging
:
false
}
)
;
return
;
}
if
(
msgCount
=
=
=
2
)
{
browser
.
test
.
assertEq
(
"
after_messaging_false
"
msg
"
Second
message
"
)
;
return
;
}
browser
.
test
.
fail
(
Unexpected
onUserScriptMessage
{
msgCount
}
:
{
msg
}
)
;
}
)
;
browser
.
runtime
.
onMessage
.
addListener
(
(
msg
sender
)
=
>
{
browser
.
test
.
assertFalse
(
"
userScriptWorldId
"
in
sender
"
No
userScriptWorldId
in
runtime
.
onMessage
"
)
;
browser
.
test
.
assertEq
(
2
msgCount
"
Should
reach
reportResultViaContentScript
after
reloading
page
"
)
;
browser
.
test
.
assertEq
(
"
Result
:
ReferenceError
:
browser
is
not
defined
"
msg
"
Expected
(
error
)
message
after
reload
when
messaging
=
false
"
)
;
browser
.
test
.
sendMessage
(
"
done
"
)
;
}
)
;
browser
.
runtime
.
onMessageExternal
.
addListener
(
msg
=
>
{
browser
.
test
.
fail
(
Unexpected
message
:
{
msg
}
)
;
}
)
;
await
browser
.
userScripts
.
configureWorld
(
{
messaging
:
true
}
)
;
await
browser
.
userScripts
.
register
(
[
{
id
:
"
Test
effect
of
configureWorld
(
messaging
=
false
)
and
reload
"
matches
:
[
"
*
:
/
/
example
.
com
/
dummy
"
]
js
:
[
{
file
:
"
userscript
.
js
"
}
]
worldId
:
"
non_default_worldId
"
}
]
)
;
browser
.
test
.
sendMessage
(
"
registered
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
registered
"
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
http
:
/
/
example
.
com
/
dummy
"
)
;
await
extension
.
awaitMessage
(
"
done
"
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_onUserScriptConnect
(
)
{
const
extensionId
=
"
test_onUserScriptConnect
"
;
await
grantUserScriptsPermission
(
extensionId
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
manifest
:
{
browser_specific_settings
:
{
gecko
:
{
id
:
extensionId
}
}
manifest_version
:
3
optional_permissions
:
[
"
userScripts
"
]
host_permissions
:
[
"
*
:
/
/
example
.
com
/
*
"
]
}
files
:
{
"
userscript
.
js
"
:
(
)
=
>
{
let
port
=
browser
.
runtime
.
connect
(
{
name
:
"
first_port
"
}
)
;
port
.
onMessage
.
addListener
(
msg
=
>
{
port
.
postMessage
(
{
messageBack
:
msg
}
)
;
}
)
;
port
.
onDisconnect
.
addListener
(
(
)
=
>
{
let
port2
=
browser
.
runtime
.
connect
(
{
name
:
"
second_port
"
}
)
;
port2
.
postMessage
(
{
errorFromFirstPort
:
port
.
error
}
)
;
port2
.
disconnect
(
)
;
}
)
;
}
}
background
(
)
{
browser
.
runtime
.
onUserScriptConnect
.
addListener
(
port
=
>
{
browser
.
test
.
assertEq
(
"
connect_world
"
port
.
sender
.
userScriptWorldId
Expected
userScriptWorldId
in
onUserScriptConnect
:
{
port
.
name
}
)
;
if
(
port
.
name
=
=
=
"
first_port
"
)
{
port
.
onMessage
.
addListener
(
msg
=
>
{
browser
.
test
.
assertDeepEq
(
{
messageBack
:
{
hi
:
1
}
}
msg
"
port
.
onMessage
triggered
from
user
script
"
)
;
port
.
disconnect
(
)
;
}
)
;
port
.
onDisconnect
.
addListener
(
(
)
=
>
{
browser
.
test
.
fail
(
Unexpected
port
.
onDisconnect
:
{
port
.
error
}
)
;
}
)
;
port
.
postMessage
(
{
hi
:
1
}
)
;
return
;
}
if
(
port
.
name
=
=
=
"
second_port
"
)
{
port
.
onMessage
.
addListener
(
msg
=
>
{
browser
.
test
.
assertDeepEq
(
{
errorFromFirstPort
:
null
}
msg
"
When
we
disconnect
first_port
other
port
.
error
should
be
null
"
)
;
browser
.
test
.
sendMessage
(
"
port
.
onMessage
:
done
"
)
;
}
)
;
port
.
onDisconnect
.
addListener
(
(
)
=
>
{
browser
.
test
.
assertDeepEq
(
null
port
.
error
"
Our
port
.
error
when
other
side
(
user
script
)
disconnects
"
)
;
browser
.
test
.
sendMessage
(
"
port
.
onDisconnect
:
done
"
)
;
}
)
;
return
;
}
browser
.
test
.
fail
(
Unexpected
port
:
{
port
.
name
}
)
;
}
)
;
browser
.
runtime
.
onInstalled
.
addListener
(
async
(
)
=
>
{
await
browser
.
userScripts
.
configureWorld
(
{
messaging
:
true
}
)
;
await
browser
.
userScripts
.
register
(
[
{
id
:
"
messaging
checker
"
matches
:
[
"
*
:
/
/
example
.
com
/
dummy
"
]
js
:
[
{
file
:
"
userscript
.
js
"
}
]
worldId
:
"
connect_world
"
}
]
)
;
browser
.
test
.
sendMessage
(
"
registered
"
)
;
}
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
registered
"
)
;
async
function
testRuntimeConnect
(
)
{
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
http
:
/
/
example
.
com
/
dummy
"
)
;
await
Promise
.
all
(
[
extension
.
awaitMessage
(
"
port
.
onMessage
:
done
"
)
extension
.
awaitMessage
(
"
port
.
onDisconnect
:
done
"
)
]
)
;
await
contentPage
.
close
(
)
;
}
info
(
"
Loading
page
that
should
trigger
runtime
.
connect
"
)
;
await
testRuntimeConnect
(
)
;
await
AddonTestUtils
.
promiseShutdownManager
(
)
;
ExtensionUserScripts
.
_getStoreForTesting
(
)
.
_uninitForTesting
(
)
;
await
AddonTestUtils
.
promiseStartupManager
(
)
;
await
extension
.
awaitStartup
(
)
;
ExtensionTestCommon
.
testAssertions
.
assertBackgroundStatusStopped
(
extension
)
;
info
(
"
Loading
page
that
should
load
user
script
and
wake
event
page
"
)
;
await
testRuntimeConnect
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
{
pref_set
:
[
[
"
docshell
.
shistory
.
bfcache
.
allow_unload_listeners
"
false
]
]
}
async
function
test_onUserScriptConnect_port_disconnect_on_navigate
(
)
{
const
extensionId
=
"
test_onUserScriptConnect_port_disconnect_on_navigate
"
;
await
grantUserScriptsPermission
(
extensionId
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
manifest
:
{
browser_specific_settings
:
{
gecko
:
{
id
:
extensionId
}
}
manifest_version
:
3
optional_permissions
:
[
"
userScripts
"
]
host_permissions
:
[
"
*
:
/
/
example
.
com
/
*
"
]
}
files
:
{
"
userscript
.
js
"
:
(
)
=
>
{
let
port
=
browser
.
runtime
.
connect
(
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
}
)
;
globalThis
.
portReference
=
port
;
port
.
onMessage
.
addListener
(
msg
=
>
{
dump
(
Will
navigate
elsewhere
after
bye
message
:
{
msg
}
\
n
)
;
location
.
search
=
"
?
something_else
"
;
}
)
;
}
}
async
background
(
)
{
browser
.
runtime
.
onUserScriptConnect
.
addListener
(
port
=
>
{
browser
.
test
.
assertEq
(
"
"
port
.
name
"
Got
default
port
.
name
"
)
;
browser
.
test
.
assertEq
(
"
"
port
.
sender
.
userScriptWorldId
"
Got
default
userScriptWorldId
"
)
;
port
.
onDisconnect
.
addListener
(
(
)
=
>
{
browser
.
test
.
assertDeepEq
(
null
port
.
error
"
Closing
port
due
to
a
navigation
is
not
an
error
"
)
;
browser
.
test
.
sendMessage
(
"
done
"
)
;
}
)
;
port
.
postMessage
(
"
bye
"
)
;
}
)
;
await
browser
.
userScripts
.
configureWorld
(
{
messaging
:
true
}
)
;
await
browser
.
userScripts
.
register
(
[
{
id
:
"
messaging
checker
"
matches
:
[
"
*
:
/
/
example
.
com
/
dummy
"
]
js
:
[
{
file
:
"
userscript
.
js
"
}
]
}
]
)
;
browser
.
test
.
sendMessage
(
"
registered
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
registered
"
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
http
:
/
/
example
.
com
/
dummy
"
)
;
await
extension
.
awaitMessage
(
"
done
"
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
