"
use
strict
"
;
const
server
=
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
"
restricted
"
]
}
)
;
server
.
registerPathHandler
(
"
/
"
(
req
res
)
=
>
{
res
.
setHeader
(
"
Access
-
Control
-
Allow
-
Origin
"
"
*
"
)
;
res
.
write
(
"
response
from
server
"
)
;
}
)
;
server
.
registerPathHandler
(
"
/
style_with_import
.
css
"
(
req
res
)
=
>
{
res
.
setHeader
(
"
Content
-
Type
"
"
text
/
css
"
)
;
res
.
setHeader
(
"
Access
-
Control
-
Allow
-
Origin
"
"
*
"
)
;
res
.
write
(
"
import
url
(
'
http
:
/
/
example
.
com
/
imported
.
css
'
)
;
"
)
;
}
)
;
server
.
registerPathHandler
(
"
/
imported
.
css
"
(
req
res
)
=
>
{
res
.
setHeader
(
"
Content
-
Type
"
"
text
/
css
"
)
;
res
.
setHeader
(
"
Access
-
Control
-
Allow
-
Origin
"
"
*
"
)
;
res
.
write
(
"
imported_stylesheet_here
{
}
"
)
;
}
)
;
add_setup
(
(
)
=
>
{
Services
.
prefs
.
setBoolPref
(
"
extensions
.
manifestV3
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
dnr
.
enabled
"
true
)
;
Services
.
prefs
.
setCharPref
(
"
extensions
.
webextensions
.
restrictedDomains
"
"
restricted
"
)
;
}
)
;
async
function
startDNRExtension
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
async
background
(
)
{
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
resourceTypes
:
[
"
xmlhttprequest
"
"
stylesheet
"
]
}
action
:
{
type
:
"
block
"
}
}
{
id
:
2
condition
:
{
urlFilter
:
"
blockme
"
resourceTypes
:
[
"
main_frame
"
]
}
action
:
{
type
:
"
block
"
}
}
]
}
)
;
browser
.
test
.
sendMessage
(
"
dnr_registered
"
)
;
}
manifest
:
{
manifest_version
:
3
permissions
:
[
"
declarativeNetRequest
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
dnr_registered
"
)
;
return
extension
;
}
add_task
(
async
function
dnr_ignores_system_requests
(
)
{
let
extension
=
await
startDNRExtension
(
)
;
Assert
.
equal
(
await
(
await
fetch
(
"
http
:
/
/
example
.
com
/
"
)
)
.
text
(
)
"
response
from
server
"
"
DNR
should
not
block
requests
from
system
principal
"
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
dnr_ignores_requests_to_restrictedDomains
(
)
{
let
extension
=
await
startDNRExtension
(
)
;
Assert
.
equal
(
await
ExtensionTestUtils
.
fetch
(
"
http
:
/
/
example
.
com
/
"
"
http
:
/
/
restricted
/
"
)
"
response
from
server
"
"
DNR
should
not
block
destination
in
restrictedDomains
"
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
dnr_ignores_initiator_from_restrictedDomains
(
)
{
let
extension
=
await
startDNRExtension
(
)
;
Assert
.
equal
(
await
ExtensionTestUtils
.
fetch
(
"
http
:
/
/
restricted
/
"
"
http
:
/
/
example
.
com
/
"
)
"
response
from
server
"
"
DNR
should
not
block
requests
initiated
from
a
page
in
restrictedDomains
"
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
dnr_ignores_navigation_to_restrictedDomains
(
)
{
let
extension
=
await
startDNRExtension
(
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
http
:
/
/
restricted
/
?
blockme
"
)
;
await
contentPage
.
spawn
(
null
(
)
=
>
{
const
{
document
}
=
content
;
Assert
.
equal
(
document
.
URL
"
http
:
/
/
restricted
/
?
blockme
"
"
Same
URL
"
)
;
Assert
.
equal
(
document
.
body
.
textContent
"
response
from
server
"
"
body
"
)
;
}
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
dnr_ignores_css_import_at_restrictedDomains
(
)
{
let
extension
=
await
startDNRExtension
(
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
http
:
/
/
restricted
/
"
)
;
await
contentPage
.
spawn
(
null
async
(
)
=
>
{
const
{
document
}
=
content
.
wrappedJSObject
;
const
style
=
document
.
createElement
(
"
link
"
)
;
style
.
rel
=
"
stylesheet
"
;
style
.
href
=
"
http
:
/
/
example
.
com
/
style_with_import
.
css
"
;
style
.
crossOrigin
=
"
anonymous
"
;
await
new
Promise
(
resolve
=
>
{
info
(
"
Waiting
for
style
sheet
to
load
.
.
.
"
)
;
style
.
onload
=
resolve
;
document
.
head
.
append
(
style
)
;
}
)
;
const
importRule
=
style
.
sheet
.
cssRules
[
0
]
;
Assert
.
equal
(
importRule
?
.
cssText
import
url
(
"
http
:
/
/
example
.
com
/
imported
.
css
"
)
;
"
Not
blocked
by
DNR
:
Loaded
style_with_import
.
css
"
)
;
const
importedStylesheet
=
Cu
.
unwaiveXrays
(
importRule
.
styleSheet
)
;
Assert
.
equal
(
importedStylesheet
.
cssRules
[
0
]
?
.
cssText
"
imported_stylesheet_here
{
}
"
"
Not
blocked
by
DNR
:
Loaded
import
.
css
"
)
;
}
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
{
pref_set
:
[
[
"
extensions
.
dnr
.
feedback
"
true
]
]
}
async
function
testMatchOutcome_and_restrictedDomains
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
async
background
(
)
{
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
}
action
:
{
type
:
"
block
"
}
}
]
}
)
;
const
type
=
"
other
"
;
browser
.
test
.
assertDeepEq
(
{
matchedRules
:
[
]
}
await
browser
.
declarativeNetRequest
.
testMatchOutcome
(
{
url
:
"
http
:
/
/
restricted
/
"
type
}
)
"
testMatchOutcome
ignores
restricted
url
"
)
;
browser
.
test
.
assertDeepEq
(
{
matchedRules
:
[
]
}
await
browser
.
declarativeNetRequest
.
testMatchOutcome
(
{
url
:
"
http
:
/
/
example
.
com
/
"
initiator
:
"
http
:
/
/
restricted
/
"
type
}
)
"
testMatchOutcome
ignores
restricted
initiator
"
)
;
browser
.
test
.
sendMessage
(
"
done
"
)
;
}
manifest
:
{
manifest_version
:
3
permissions
:
[
"
declarativeNetRequest
"
"
declarativeNetRequestFeedback
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
done
"
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
{
pref_set
:
[
[
"
security
.
allow_parent_unrestricted_js_loads
"
true
]
]
}
async
function
non_system_request_with_disallowed_scheme
(
)
{
let
extension
=
await
startDNRExtension
(
)
;
Assert
.
equal
(
await
(
await
fetch
(
"
http
:
/
/
example
.
com
/
"
)
)
.
text
(
)
"
response
from
server
"
"
DNR
should
not
block
requests
from
system
principal
"
)
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
"
about
:
logo
?
blockme
"
)
;
await
contentPage
.
spawn
(
null
async
(
)
=
>
{
const
{
document
}
=
content
;
Assert
.
ok
(
document
.
nodePrincipal
.
isContentPrincipal
"
about
:
logo
has
content
principal
(
not
system
or
NullPrincipal
)
)
"
)
;
Assert
.
equal
(
document
.
URL
"
about
:
logo
?
blockme
"
"
Same
URL
"
)
;
Assert
.
equal
(
await
(
await
content
.
fetch
(
"
http
:
/
/
example
.
com
/
"
)
)
.
text
(
)
"
response
from
server
"
"
fetch
(
)
at
about
:
logo
not
blocked
by
DNR
"
)
;
}
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
{
pref_set
:
[
[
"
extensions
.
dnr
.
feedback
"
true
]
]
}
async
function
testMatchOutcome_non_system_request_with_disallowed_scheme
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
async
background
(
)
{
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
}
action
:
{
type
:
"
block
"
}
}
]
}
)
;
const
type
=
"
other
"
;
browser
.
test
.
assertDeepEq
(
{
matchedRules
:
[
]
}
await
browser
.
declarativeNetRequest
.
testMatchOutcome
(
{
url
:
"
about
:
logo
"
type
}
)
"
testMatchOutcome
ignores
url
with
disallowed
schema
"
)
;
browser
.
test
.
assertDeepEq
(
{
matchedRules
:
[
]
}
await
browser
.
declarativeNetRequest
.
testMatchOutcome
(
{
url
:
"
http
:
/
/
example
.
com
/
"
initiator
:
"
about
:
logo
"
type
}
)
"
testMatchOutcome
ignores
initiator
with
disallowed
schema
"
)
;
browser
.
test
.
sendMessage
(
"
done
"
)
;
}
manifest
:
{
manifest_version
:
3
permissions
:
[
"
declarativeNetRequest
"
"
declarativeNetRequestFeedback
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
done
"
)
;
await
extension
.
unload
(
)
;
}
)
;
