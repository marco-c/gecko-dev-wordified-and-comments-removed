"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
ContentTaskUtils
"
"
resource
:
/
/
testing
-
common
/
ContentTaskUtils
.
jsm
"
)
;
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
telemetry
.
testing
.
overrideProductsCheck
"
true
)
;
const
IS_OOP
=
Services
.
prefs
.
getBoolPref
(
"
extensions
.
webextensions
.
remote
"
)
;
const
WEBEXT_EVENTPAGE_RUNNING_TIME_MS
=
"
WEBEXT_EVENTPAGE_RUNNING_TIME_MS
"
;
const
WEBEXT_EVENTPAGE_RUNNING_TIME_MS_BY_ADDONID
=
"
WEBEXT_EVENTPAGE_RUNNING_TIME_MS_BY_ADDONID
"
;
const
WEBEXT_EVENTPAGE_IDLE_RESULT_COUNT
=
"
WEBEXT_EVENTPAGE_IDLE_RESULT_COUNT
"
;
const
WEBEXT_EVENTPAGE_IDLE_RESULT_COUNT_BY_ADDONID
=
"
WEBEXT_EVENTPAGE_IDLE_RESULT_COUNT_BY_ADDONID
"
;
const
HISTOGRAM_EVENTPAGE_IDLE_RESULT_CATEGORIES
=
[
"
suspend
"
"
reset_other
"
"
reset_event
"
"
reset_listeners
"
"
reset_nativeapp
"
"
reset_streamfilter
"
]
;
function
valueSum
(
arr
)
{
return
Object
.
values
(
arr
)
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
;
}
function
clearHistograms
(
)
{
Services
.
telemetry
.
getSnapshotForHistograms
(
"
main
"
true
)
;
Services
.
telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
true
)
;
}
function
getSnapshots
(
process
)
{
return
Services
.
telemetry
.
getSnapshotForHistograms
(
"
main
"
false
)
[
process
]
;
}
function
getKeyedSnapshots
(
process
)
{
return
Services
.
telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
false
)
[
process
]
;
}
function
promiseTelemetryRecorded
(
id
process
expectedCount
)
{
let
condition
=
(
)
=
>
{
let
snapshot
=
Services
.
telemetry
.
getSnapshotForHistograms
(
"
main
"
false
)
[
process
]
[
id
]
;
return
snapshot
&
&
valueSum
(
snapshot
.
values
)
>
=
expectedCount
;
}
;
return
ContentTaskUtils
.
waitForCondition
(
condition
)
;
}
function
promiseKeyedTelemetryRecorded
(
id
process
expectedKey
expectedCount
)
{
let
condition
=
(
)
=
>
{
let
snapshot
=
Services
.
telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
false
)
[
process
]
[
id
]
;
return
(
snapshot
&
&
snapshot
[
expectedKey
]
&
&
valueSum
(
snapshot
[
expectedKey
]
.
values
)
>
=
expectedCount
)
;
}
;
return
ContentTaskUtils
.
waitForCondition
(
condition
)
;
}
function
assertHistogramSnapshot
(
histogramId
{
keyed
processSnapshot
expectedValue
}
msg
)
{
let
histogram
;
if
(
keyed
)
{
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
histogramId
)
;
}
else
{
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramId
)
;
}
let
res
=
processSnapshot
(
histogram
.
snapshot
(
)
)
;
Assert
.
deepEqual
(
res
expectedValue
msg
)
;
return
res
;
}
function
assertHistogramEmpty
(
histogramId
)
{
assertHistogramSnapshot
(
histogramId
{
processSnapshot
:
snapshot
=
>
snapshot
.
sum
expectedValue
:
0
}
No
data
recorded
for
histogram
:
{
histogramId
}
.
)
;
}
function
assertKeyedHistogramEmpty
(
histogramId
)
{
assertHistogramSnapshot
(
histogramId
{
keyed
:
true
processSnapshot
:
snapshot
=
>
Object
.
keys
(
snapshot
)
.
length
expectedValue
:
0
}
No
data
recorded
for
histogram
:
{
histogramId
}
.
)
;
}
function
assertHistogramCategoryNotEmpty
(
histogramId
{
category
categories
keyed
key
}
msg
)
{
let
message
=
msg
;
if
(
!
msg
)
{
message
=
Data
recorded
for
histogram
:
{
histogramId
}
category
"
{
category
}
"
;
if
(
keyed
)
{
message
+
=
key
"
{
key
}
"
;
}
}
assertHistogramSnapshot
(
histogramId
{
keyed
processSnapshot
:
snapshot
=
>
{
const
categoryIndex
=
categories
.
indexOf
(
category
)
;
if
(
keyed
)
{
return
{
[
key
]
:
snapshot
[
key
]
?
snapshot
[
key
]
.
values
[
categoryIndex
]
>
0
:
null
}
;
}
return
snapshot
.
values
[
categoryIndex
]
>
0
;
}
expectedValue
:
keyed
?
{
[
key
]
:
true
}
:
true
}
message
)
;
}
