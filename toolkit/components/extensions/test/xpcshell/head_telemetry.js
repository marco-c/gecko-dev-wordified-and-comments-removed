"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
ContentTaskUtils
:
"
resource
:
/
/
testing
-
common
/
ContentTaskUtils
.
sys
.
mjs
"
}
)
;
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
telemetry
.
testing
.
overrideProductsCheck
"
true
)
;
const
IS_OOP
=
Services
.
prefs
.
getBoolPref
(
"
extensions
.
webextensions
.
remote
"
)
;
const
WEBEXT_EVENTPAGE_RUNNING_TIME_MS
=
"
WEBEXT_EVENTPAGE_RUNNING_TIME_MS
"
;
const
WEBEXT_EVENTPAGE_RUNNING_TIME_MS_BY_ADDONID
=
"
WEBEXT_EVENTPAGE_RUNNING_TIME_MS_BY_ADDONID
"
;
const
WEBEXT_EVENTPAGE_IDLE_RESULT_COUNT
=
"
WEBEXT_EVENTPAGE_IDLE_RESULT_COUNT
"
;
const
WEBEXT_EVENTPAGE_IDLE_RESULT_COUNT_BY_ADDONID
=
"
WEBEXT_EVENTPAGE_IDLE_RESULT_COUNT_BY_ADDONID
"
;
const
HISTOGRAM_EVENTPAGE_IDLE_RESULT_CATEGORIES
=
[
"
suspend
"
"
reset_other
"
"
reset_event
"
"
reset_listeners
"
"
reset_nativeapp
"
"
reset_streamfilter
"
]
;
const
GLEAN_EVENTPAGE_IDLE_RESULT_CATEGORIES
=
[
.
.
.
HISTOGRAM_EVENTPAGE_IDLE_RESULT_CATEGORIES
"
__other__
"
]
;
function
valueSum
(
arr
)
{
return
Object
.
values
(
arr
)
.
reduce
(
(
a
b
)
=
>
a
+
b
0
)
;
}
function
clearHistograms
(
)
{
Services
.
telemetry
.
getSnapshotForHistograms
(
"
main
"
true
)
;
Services
.
telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
true
)
;
}
function
clearScalars
(
)
{
Services
.
telemetry
.
getSnapshotForScalars
(
"
main
"
true
)
;
Services
.
telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
true
)
;
}
function
getSnapshots
(
process
)
{
return
Services
.
telemetry
.
getSnapshotForHistograms
(
"
main
"
false
)
[
process
]
;
}
function
getKeyedSnapshots
(
process
)
{
return
Services
.
telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
false
)
[
process
]
;
}
function
promiseTelemetryRecorded
(
id
process
expectedCount
)
{
let
condition
=
(
)
=
>
{
let
snapshot
=
Services
.
telemetry
.
getSnapshotForHistograms
(
"
main
"
false
)
[
process
]
[
id
]
;
return
snapshot
&
&
valueSum
(
snapshot
.
values
)
>
=
expectedCount
;
}
;
return
ContentTaskUtils
.
waitForCondition
(
condition
)
;
}
function
promiseKeyedTelemetryRecorded
(
id
process
expectedKey
expectedCount
)
{
let
condition
=
(
)
=
>
{
let
snapshot
=
Services
.
telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
false
)
[
process
]
[
id
]
;
return
(
snapshot
&
&
snapshot
[
expectedKey
]
&
&
valueSum
(
snapshot
[
expectedKey
]
.
values
)
>
=
expectedCount
)
;
}
;
return
ContentTaskUtils
.
waitForCondition
(
condition
)
;
}
function
assertHistogramSnapshot
(
histogramId
{
keyed
processSnapshot
expectedValue
}
msg
)
{
let
histogram
;
if
(
keyed
)
{
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
histogramId
)
;
}
else
{
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramId
)
;
}
let
res
=
processSnapshot
(
histogram
.
snapshot
(
)
)
;
Assert
.
deepEqual
(
res
expectedValue
msg
)
;
return
res
;
}
function
assertHistogramEmpty
(
histogramId
)
{
assertHistogramSnapshot
(
histogramId
{
processSnapshot
:
snapshot
=
>
snapshot
.
sum
expectedValue
:
0
}
No
data
recorded
for
histogram
:
{
histogramId
}
.
)
;
}
function
assertKeyedHistogramEmpty
(
histogramId
)
{
assertHistogramSnapshot
(
histogramId
{
keyed
:
true
processSnapshot
:
snapshot
=
>
Object
.
keys
(
snapshot
)
.
length
expectedValue
:
0
}
No
data
recorded
for
histogram
:
{
histogramId
}
.
)
;
}
function
assertHistogramCategoryNotEmpty
(
histogramId
{
category
categories
keyed
key
}
msg
)
{
let
message
=
msg
;
if
(
!
msg
)
{
message
=
Data
recorded
for
histogram
:
{
histogramId
}
category
"
{
category
}
"
;
if
(
keyed
)
{
message
+
=
key
"
{
key
}
"
;
}
}
assertHistogramSnapshot
(
histogramId
{
keyed
processSnapshot
:
snapshot
=
>
{
const
categoryIndex
=
categories
.
indexOf
(
category
)
;
if
(
keyed
)
{
return
{
[
key
]
:
snapshot
[
key
]
?
snapshot
[
key
]
.
values
[
categoryIndex
]
>
0
:
null
}
;
}
return
snapshot
.
values
[
categoryIndex
]
>
0
;
}
expectedValue
:
keyed
?
{
[
key
]
:
true
}
:
true
}
message
)
;
}
function
setupTelemetryForTests
(
)
{
do_get_profile
(
)
;
Services
.
fog
.
initializeFOG
(
)
;
}
function
resetTelemetryData
(
)
{
Services
.
fog
.
testResetFOG
(
)
;
clearHistograms
(
)
;
clearScalars
(
)
;
}
function
assertValidGleanMetric
(
{
metricId
gleanMetric
gleanMetricConstructor
msg
}
)
{
const
{
GleanMetric
}
=
globalThis
;
if
(
!
(
gleanMetric
instanceof
GleanMetric
)
)
{
throw
new
Error
(
gleanMetric
"
{
metricId
}
"
{
gleanMetric
}
should
be
an
instance
of
GleanMetric
{
msg
}
)
;
}
if
(
gleanMetricConstructor
&
&
!
(
gleanMetric
instanceof
gleanMetricConstructor
)
)
{
throw
new
Error
(
gleanMetric
"
{
metricId
}
"
should
be
an
instance
of
the
given
GleanMetric
constructor
:
{
gleanMetric
}
not
an
instance
of
{
gleanMetricConstructor
}
{
msg
}
)
;
}
}
function
assertGleanMetricsNoSamples
(
{
metricId
gleanMetric
gleanMetricConstructor
message
}
)
{
const
msg
=
message
?
(
{
message
}
)
:
"
"
;
assertValidGleanMetric
(
{
metricId
gleanMetric
gleanMetricConstructor
msg
}
)
;
const
gleanData
=
gleanMetric
.
testGetValue
(
)
;
Assert
.
deepEqual
(
gleanData
undefined
Got
no
sample
for
Glean
metric
{
metricId
}
{
msg
}
)
;
}
function
assertGleanMetricsSamplesCount
(
{
metricId
gleanMetric
gleanMetricConstructor
expectedSamplesCount
message
}
)
{
const
msg
=
message
?
(
{
message
}
)
:
"
"
;
assertValidGleanMetric
(
{
metricId
gleanMetric
gleanMetricConstructor
msg
}
)
;
const
gleanData
=
gleanMetric
.
testGetValue
(
)
;
Assert
.
notEqual
(
gleanData
undefined
Got
some
sample
for
Glean
metric
{
metricId
}
{
msg
}
)
;
Assert
.
equal
(
valueSum
(
gleanData
.
values
)
expectedSamplesCount
Got
the
expected
number
of
samples
for
Glean
metric
{
metricId
}
{
msg
}
)
;
}
function
assertGleanLabeledCounter
(
{
metricId
gleanMetric
gleanMetricLabels
expectedLabelsValue
ignoreNonExpectedLabels
message
}
)
{
const
{
GleanLabeled
}
=
globalThis
;
const
msg
=
message
?
(
{
message
}
)
:
"
"
;
if
(
!
Array
.
isArray
(
gleanMetricLabels
)
|
|
!
gleanMetricLabels
.
length
)
{
throw
new
Error
(
Missing
mandatory
gleanMetricLabels
property
{
msg
}
:
{
gleanMetricLabels
}
)
;
}
if
(
!
(
gleanMetric
instanceof
GleanLabeled
)
)
{
throw
new
Error
(
Glean
metric
"
{
metricId
}
"
should
be
an
instance
of
GleanLabeled
:
{
gleanMetric
}
{
msg
}
)
;
}
for
(
const
label
of
gleanMetricLabels
)
{
const
expectedLabelValue
=
expectedLabelsValue
[
label
]
;
if
(
ignoreNonExpectedLabels
&
&
!
(
label
in
expectedLabelsValue
)
)
{
continue
;
}
Assert
.
deepEqual
(
gleanMetric
[
label
]
.
testGetValue
(
)
expectedLabelValue
Expect
Glean
"
{
metricId
}
"
metric
label
"
{
label
}
"
to
be
{
expectedLabelValue
>
0
?
expectedLabelValue
:
"
empty
"
}
)
;
}
}
function
assertGleanLabeledCounterEmpty
(
{
metricId
gleanMetric
gleanMetricLabels
message
}
)
{
assertGleanLabeledCounter
(
{
metricId
gleanMetric
gleanMetricLabels
expectedLabelsValue
:
{
}
message
}
)
;
}
function
assertGleanLabeledCounterNotEmpty
(
{
metricId
gleanMetric
expectedNotEmptyLabels
message
}
)
{
const
{
GleanLabeled
}
=
globalThis
;
const
msg
=
message
?
(
{
message
}
)
:
"
"
;
if
(
!
Array
.
isArray
(
expectedNotEmptyLabels
)
|
|
!
expectedNotEmptyLabels
.
length
)
{
throw
new
Error
(
Missing
mandatory
expectedNotEmptyLabels
property
{
msg
}
:
{
expectedNotEmptyLabels
}
)
;
}
if
(
!
(
gleanMetric
instanceof
GleanLabeled
)
)
{
throw
new
Error
(
Glean
metric
"
{
metricId
}
"
should
be
an
instance
of
GleanLabeled
:
{
gleanMetric
}
{
msg
}
)
;
}
for
(
const
label
of
expectedNotEmptyLabels
)
{
Assert
.
notEqual
(
gleanMetric
[
label
]
.
testGetValue
(
)
undefined
Expect
Glean
"
{
metricId
}
"
metric
label
"
{
label
}
"
to
not
be
empty
)
;
}
}
function
assertDNRTelemetryMetricsDefined
(
metrics
)
{
const
metricsNotFound
=
metrics
.
filter
(
metricDetails
=
>
{
const
{
metric
label
}
=
metricDetails
;
if
(
!
Glean
.
extensionsApisDnr
[
metric
]
)
{
return
true
;
}
if
(
label
)
{
return
!
Glean
.
extensionsApisDnr
[
metric
]
[
label
]
;
}
return
false
;
}
)
;
Assert
.
deepEqual
(
metricsNotFound
[
]
All
expected
extensionsApisDnr
Glean
metrics
should
be
found
)
;
}
function
assertDNRTelemetryMirrored
(
{
gleanMetric
gleanLabel
unifiedName
unifiedType
}
)
{
assertDNRTelemetryMetricsDefined
(
[
{
metric
:
gleanMetric
label
:
gleanLabel
}
]
)
;
const
gleanData
=
gleanLabel
?
Glean
.
extensionsApisDnr
[
gleanMetric
]
[
gleanLabel
]
.
testGetValue
(
)
:
Glean
.
extensionsApisDnr
[
gleanMetric
]
.
testGetValue
(
)
;
if
(
!
unifiedName
)
{
Assert
.
ok
(
false
Unexpected
missing
unifiedName
parameter
on
call
to
assertDNRTelemetryMirrored
)
;
return
;
}
let
unifiedData
;
switch
(
unifiedType
)
{
case
"
histogram
"
:
{
let
found
=
false
;
try
{
const
histogram
=
Services
.
telemetry
.
getHistogramById
(
unifiedName
)
;
found
=
!
!
histogram
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
Assert
.
ok
(
found
Expect
an
histogram
named
{
unifiedName
}
to
be
found
)
;
unifiedData
=
Services
.
telemetry
.
getSnapshotForHistograms
(
"
main
"
false
)
.
parent
[
unifiedName
]
;
break
;
}
case
"
keyedScalar
"
:
{
const
snapshot
=
Services
.
telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
false
)
;
if
(
unifiedName
in
(
snapshot
?
.
parent
|
|
{
}
)
)
{
unifiedData
=
snapshot
.
parent
[
unifiedName
]
[
gleanLabel
]
;
}
break
;
}
case
"
scalar
"
:
{
const
snapshot
=
Services
.
telemetry
.
getSnapshotForScalars
(
"
main
"
false
)
;
if
(
unifiedName
in
(
snapshot
?
.
parent
|
|
{
}
)
)
{
unifiedData
=
snapshot
.
parent
[
unifiedName
]
;
}
break
;
}
default
:
Assert
.
ok
(
false
Unexpected
unifiedType
{
unifiedType
}
on
call
to
assertDNRTelemetryMirrored
)
;
return
;
}
if
(
gleanData
=
=
undefined
)
{
Assert
.
deepEqual
(
unifiedData
undefined
Expect
mirrored
unified
telemetry
{
unifiedType
}
{
unifiedName
}
has
no
samples
as
Glean
{
gleanMetric
}
)
;
}
else
{
switch
(
unifiedType
)
{
case
"
histogram
"
:
{
Assert
.
deepEqual
(
valueSum
(
unifiedData
.
values
)
valueSum
(
gleanData
.
values
)
Expect
mirrored
unified
telemetry
{
unifiedType
}
{
unifiedName
}
has
samples
mirrored
from
Glean
{
gleanMetric
}
)
;
break
;
}
case
"
scalar
"
:
case
"
keyedScalar
"
:
{
Assert
.
deepEqual
(
unifiedData
gleanData
Expect
mirrored
unified
telemetry
{
unifiedType
}
{
unifiedName
}
has
samples
mirrored
from
Glean
{
gleanMetric
}
)
;
break
;
}
}
}
}
function
assertDNRTelemetryMetricsNoSamples
(
metrics
msg
)
{
assertDNRTelemetryMetricsDefined
(
metrics
)
;
for
(
const
metricDetails
of
metrics
)
{
const
{
metric
label
}
=
metricDetails
;
const
gleanData
=
label
?
Glean
.
extensionsApisDnr
[
metric
]
[
label
]
.
testGetValue
(
)
:
Glean
.
extensionsApisDnr
[
metric
]
.
testGetValue
(
)
;
Assert
.
deepEqual
(
gleanData
undefined
Expect
no
sample
for
Glean
metric
extensionApisDnr
.
{
metric
}
(
{
msg
}
)
:
{
gleanData
}
)
;
if
(
metricDetails
.
mirroredName
)
{
const
{
mirroredName
mirroredType
}
=
metricDetails
;
assertDNRTelemetryMirrored
(
{
gleanMetric
:
metric
gleanLabel
:
label
unifiedName
:
mirroredName
unifiedType
:
mirroredType
}
)
;
}
}
}
function
assertDNRTelemetryMetricsGetValueEq
(
metrics
msg
)
{
assertDNRTelemetryMetricsDefined
(
metrics
)
;
for
(
const
metricDetails
of
metrics
)
{
const
{
metric
label
expectedGetValue
}
=
metricDetails
;
const
gleanData
=
label
?
Glean
.
extensionsApisDnr
[
metric
]
[
label
]
.
testGetValue
(
)
:
Glean
.
extensionsApisDnr
[
metric
]
.
testGetValue
(
)
;
Assert
.
deepEqual
(
gleanData
expectedGetValue
Got
expected
value
set
on
Glean
metric
extensionApisDnr
.
{
metric
}
{
label
?
.
{
label
}
:
"
"
}
(
{
msg
}
)
)
;
if
(
metricDetails
.
mirroredName
)
{
const
{
mirroredName
mirroredType
}
=
metricDetails
;
assertDNRTelemetryMirrored
(
{
gleanMetric
:
metric
gleanLabel
:
label
unifiedName
:
mirroredName
unifiedType
:
mirroredType
}
)
;
}
}
}
function
assertDNRTelemetryMetricsSamplesCount
(
metrics
msg
)
{
assertDNRTelemetryMetricsDefined
(
metrics
)
;
const
labeledMetricsFound
=
metrics
.
filter
(
metric
=
>
!
!
metric
.
label
)
;
if
(
labeledMetricsFound
.
length
)
{
throw
new
Error
(
Unexpected
labeled
metrics
in
call
to
assertDNRTelemetryMetricsSamplesCount
:
{
labeledMetricsFound
}
)
;
}
for
(
const
metricDetails
of
metrics
)
{
const
{
metric
expectedSamplesCount
}
=
metricDetails
;
const
gleanData
=
Glean
.
extensionsApisDnr
[
metric
]
.
testGetValue
(
)
;
Assert
.
notEqual
(
gleanData
undefined
Got
some
sample
for
Glean
metric
extensionApisDnr
.
{
metric
}
:
{
gleanData
&
&
JSON
.
stringify
(
gleanData
)
}
)
;
Assert
.
equal
(
valueSum
(
gleanData
.
values
)
expectedSamplesCount
Got
the
expected
number
of
samples
for
Glean
metric
extensionsApisDnr
.
{
metric
}
(
{
msg
}
)
)
;
Assert
.
ok
(
!
gleanData
.
values
[
"
0
"
]
No
sample
for
Glean
metric
extensionsApisDnr
.
{
metric
}
should
be
collected
for
the
bucket
"
0
"
)
;
if
(
metricDetails
.
mirroredName
)
{
const
{
mirroredName
mirroredType
}
=
metricDetails
;
assertDNRTelemetryMirrored
(
{
gleanMetric
:
metric
unifiedName
:
mirroredName
unifiedType
:
mirroredType
}
)
;
}
}
}
