"
use
strict
"
;
add_setup
(
(
)
=
>
{
Services
.
prefs
.
setBoolPref
(
"
extensions
.
dnr
.
enabled
"
true
)
;
}
)
;
const
server
=
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
"
redir
"
]
}
)
;
server
.
registerPathHandler
(
"
/
never_reached
"
(
)
=
>
{
Assert
.
ok
(
false
"
Server
should
never
have
been
reached
"
)
;
}
)
;
server
.
registerPathHandler
(
"
/
source
"
(
req
res
)
=
>
{
res
.
setHeader
(
"
Access
-
Control
-
Allow
-
Origin
"
"
*
"
)
;
}
)
;
server
.
registerPathHandler
(
"
/
destination
"
(
req
res
)
=
>
{
res
.
setHeader
(
"
Access
-
Control
-
Allow
-
Origin
"
"
*
"
)
;
}
)
;
add_task
(
async
function
block_request_with_dnr
(
)
{
async
function
background
(
)
{
let
onBeforeRequestPromise
=
new
Promise
(
resolve
=
>
{
browser
.
webRequest
.
onBeforeRequest
.
addListener
(
resolve
{
urls
:
[
"
*
:
/
/
example
.
com
/
*
"
]
}
)
;
}
)
;
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
requestDomains
:
[
"
example
.
com
"
]
}
action
:
{
type
:
"
block
"
}
}
]
}
)
;
await
browser
.
test
.
assertRejects
(
fetch
(
"
http
:
/
/
example
.
com
/
never_reached
"
)
"
NetworkError
when
attempting
to
fetch
resource
.
"
"
blocked
by
DNR
rule
"
)
;
browser
.
test
.
log
(
"
Waiting
for
webRequest
.
onBeforeRequest
.
.
.
"
)
;
await
onBeforeRequestPromise
;
browser
.
test
.
log
(
"
Seen
webRequest
.
onBeforeRequest
!
"
)
;
browser
.
test
.
notifyPass
(
)
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
temporarilyInstalled
:
true
allowInsecureRequests
:
true
manifest
:
{
manifest_version
:
3
granted_host_permissions
:
true
host_permissions
:
[
"
*
:
/
/
example
.
com
/
*
"
]
permissions
:
[
"
declarativeNetRequest
"
"
webRequest
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitFinish
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
upgradeScheme_and_redirect_request_with_dnr
(
)
{
async
function
background
(
)
{
let
onBeforeRequestSeen
=
[
]
;
browser
.
webRequest
.
onBeforeRequest
.
addListener
(
d
=
>
{
onBeforeRequestSeen
.
push
(
d
.
url
)
;
return
{
cancel
:
true
}
;
}
{
urls
:
[
"
*
:
/
/
example
.
com
/
*
"
"
http
:
/
/
redir
/
here
"
]
}
[
"
blocking
"
]
)
;
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
requestDomains
:
[
"
example
.
com
"
]
}
action
:
{
type
:
"
upgradeScheme
"
}
}
{
id
:
2
condition
:
{
requestDomains
:
[
"
example
.
com
"
]
urlFilter
:
"
|
https
:
*
"
}
action
:
{
type
:
"
redirect
"
redirect
:
{
url
:
"
http
:
/
/
redir
/
here
"
}
}
priority
:
2
}
]
}
)
;
await
browser
.
test
.
assertRejects
(
fetch
(
"
http
:
/
/
example
.
com
/
never_reached
"
)
"
NetworkError
when
attempting
to
fetch
resource
.
"
"
although
initially
redirected
by
DNR
ultimately
blocked
by
webRequest
"
)
;
browser
.
test
.
assertDeepEq
(
[
"
http
:
/
/
example
.
com
/
never_reached
"
"
https
:
/
/
example
.
com
/
never_reached
"
"
http
:
/
/
redir
/
here
"
]
onBeforeRequestSeen
"
Expected
onBeforeRequest
events
"
)
;
browser
.
test
.
notifyPass
(
)
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
temporarilyInstalled
:
true
manifest
:
{
manifest_version
:
3
granted_host_permissions
:
true
host_permissions
:
[
"
*
:
/
/
example
.
com
/
*
"
"
*
:
/
/
redir
/
*
"
]
permissions
:
[
"
declarativeNetRequest
"
"
webRequest
"
"
webRequestBlocking
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitFinish
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
block_request_with_webRequest_after_allow_with_dnr
(
)
{
async
function
background
(
)
{
let
onBeforeRequestSeen
=
[
]
;
browser
.
webRequest
.
onBeforeRequest
.
addListener
(
d
=
>
{
onBeforeRequestSeen
.
push
(
d
.
url
)
;
return
{
cancel
:
!
d
.
url
.
includes
(
"
webRequestNoCancel
"
)
}
;
}
{
urls
:
[
"
*
:
/
/
example
.
com
/
*
"
]
}
[
"
blocking
"
]
)
;
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
requestMethods
:
[
"
get
"
]
}
action
:
{
type
:
"
allow
"
}
}
{
id
:
2
condition
:
{
requestMethods
:
[
"
put
"
]
}
action
:
{
type
:
"
modifyHeaders
"
requestHeaders
:
[
{
operation
:
"
set
"
header
:
"
x
"
value
:
"
y
"
}
]
}
}
]
}
)
;
await
browser
.
test
.
assertRejects
(
fetch
(
"
http
:
/
/
example
.
com
/
never_reached
?
1
"
{
method
:
"
get
"
}
)
"
NetworkError
when
attempting
to
fetch
resource
.
"
"
despite
DNR
'
allow
'
rule
still
blocked
by
webRequest
"
)
;
await
browser
.
test
.
assertRejects
(
fetch
(
"
http
:
/
/
example
.
com
/
never_reached
?
2
"
{
method
:
"
put
"
}
)
"
NetworkError
when
attempting
to
fetch
resource
.
"
"
despite
DNR
'
modifyHeaders
'
rule
still
blocked
by
webRequest
"
)
;
await
fetch
(
"
http
:
/
/
example
.
com
/
?
webRequestNoCancel1
"
{
method
:
"
get
"
}
)
;
await
fetch
(
"
http
:
/
/
example
.
com
/
?
webRequestNoCancel2
"
{
method
:
"
put
"
}
)
;
browser
.
test
.
assertDeepEq
(
[
"
http
:
/
/
example
.
com
/
never_reached
?
1
"
"
http
:
/
/
example
.
com
/
never_reached
?
2
"
"
http
:
/
/
example
.
com
/
?
webRequestNoCancel1
"
"
http
:
/
/
example
.
com
/
?
webRequestNoCancel2
"
]
onBeforeRequestSeen
"
Expected
onBeforeRequest
events
"
)
;
browser
.
test
.
notifyPass
(
)
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
temporarilyInstalled
:
true
allowInsecureRequests
:
true
manifest
:
{
manifest_version
:
3
granted_host_permissions
:
true
host_permissions
:
[
"
*
:
/
/
example
.
com
/
*
"
]
permissions
:
[
"
declarativeNetRequest
"
"
webRequest
"
"
webRequestBlocking
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitFinish
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
redirect_with_webRequest_after_failing_dnr_redirect
(
)
{
async
function
background
(
)
{
const
network_standard_url_max_length
=
1048576
;
const
VERY_LONG_STRING
=
"
x
"
.
repeat
(
network_standard_url_max_length
-
20
)
;
browser
.
webRequest
.
onBeforeRequest
.
addListener
(
(
)
=
>
{
return
{
redirectUrl
:
"
http
:
/
/
redir
/
destination
?
by
-
webrequest
"
}
;
}
{
urls
:
[
"
*
:
/
/
example
.
com
/
*
"
]
}
[
"
blocking
"
]
)
;
await
browser
.
declarativeNetRequest
.
updateSessionRules
(
{
addRules
:
[
{
id
:
1
condition
:
{
requestDomains
:
[
"
example
.
com
"
]
}
action
:
{
type
:
"
redirect
"
redirect
:
{
transform
:
{
host
:
"
redir
"
path
:
"
/
destination
"
queryTransform
:
{
addOrReplaceParams
:
[
{
key
:
"
dnr
"
value
:
VERY_LONG_STRING
replaceOnly
:
true
}
]
}
}
}
}
}
]
}
)
;
const
shortx
=
s
=
>
s
.
replace
(
/
x
{
10
}
/
g
xxx
=
>
x
{
{
xxx
.
length
}
}
)
;
browser
.
test
.
assertEq
(
"
http
:
/
/
redir
/
destination
?
1
"
shortx
(
(
await
fetch
(
"
http
:
/
/
example
.
com
/
never_reached
?
1
"
)
)
.
url
)
"
Successful
DNR
redirect
.
"
)
;
browser
.
test
.
assertEq
(
"
http
:
/
/
redir
/
destination
?
by
-
webrequest
"
shortx
(
(
await
fetch
(
"
http
:
/
/
example
.
com
/
source
?
dnr
"
)
)
.
url
)
"
When
DNR
fails
we
fall
back
to
webRequest
redirect
"
)
;
browser
.
test
.
notifyPass
(
)
;
}
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
temporarilyInstalled
:
true
allowInsecureRequests
:
true
manifest
:
{
manifest_version
:
3
granted_host_permissions
:
true
host_permissions
:
[
"
*
:
/
/
example
.
com
/
*
"
]
permissions
:
[
"
declarativeNetRequest
"
"
webRequest
"
"
webRequestBlocking
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitFinish
(
)
;
await
extension
.
unload
(
)
;
}
)
;
