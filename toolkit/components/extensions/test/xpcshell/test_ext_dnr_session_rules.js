"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
ExtensionDNR
:
"
resource
:
/
/
gre
/
modules
/
ExtensionDNR
.
sys
.
mjs
"
}
)
;
add_setup
(
(
)
=
>
{
Services
.
prefs
.
setBoolPref
(
"
extensions
.
manifestV3
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
extensions
.
dnr
.
enabled
"
true
)
;
}
)
;
function
makeDnrTestUtils
(
)
{
const
dnrTestUtils
=
{
}
;
const
dnr
=
browser
.
declarativeNetRequest
;
dnrTestUtils
.
makeRuleInput
=
id
=
>
{
return
{
id
condition
:
{
}
action
:
{
type
:
"
block
"
}
}
;
}
;
dnrTestUtils
.
makeRuleOutput
=
id
=
>
{
return
{
id
condition
:
{
urlFilter
:
null
regexFilter
:
null
isUrlFilterCaseSensitive
:
null
initiatorDomains
:
null
excludedInitiatorDomains
:
null
requestDomains
:
null
excludedRequestDomains
:
null
resourceTypes
:
null
excludedResourceTypes
:
null
requestMethods
:
null
excludedRequestMethods
:
null
domainType
:
null
tabIds
:
null
excludedTabIds
:
null
}
action
:
{
type
:
"
block
"
redirect
:
null
requestHeaders
:
null
responseHeaders
:
null
}
priority
:
1
}
;
}
;
function
serializeForLog
(
rule
)
{
let
str
=
JSON
.
stringify
(
rule
rep
=
>
rep
?
?
undefined
)
;
str
=
str
.
replace
(
/
x
{
10
}
/
g
xxx
=
>
x
{
{
xxx
.
length
}
}
)
;
return
str
;
}
async
function
testInvalidRule
(
rule
expectedError
isSchemaError
)
{
if
(
isSchemaError
)
{
browser
.
test
.
assertThrows
(
(
)
=
>
dnr
.
updateSessionRules
(
{
addRules
:
[
rule
]
}
)
expectedError
Rule
should
be
invalid
(
schema
-
validated
)
:
{
serializeForLog
(
rule
)
}
)
;
}
else
{
await
browser
.
test
.
assertRejects
(
dnr
.
updateSessionRules
(
{
addRules
:
[
rule
]
}
)
expectedError
Rule
should
be
invalid
:
{
serializeForLog
(
rule
)
}
)
;
}
}
async
function
testInvalidCondition
(
condition
expectedError
isSchemaError
)
{
await
testInvalidRule
(
{
id
:
1
condition
action
:
{
type
:
"
block
"
}
}
expectedError
isSchemaError
)
;
}
async
function
testInvalidAction
(
action
expectedError
isSchemaError
)
{
await
testInvalidRule
(
{
id
:
1
condition
:
{
}
action
}
expectedError
isSchemaError
)
;
}
async
function
testValidRule
(
rule
)
{
await
dnr
.
updateSessionRules
(
{
addRules
:
[
rule
]
}
)
;
const
expectedRule
=
dnrTestUtils
.
makeRuleOutput
(
)
;
expectedRule
.
id
=
rule
.
id
;
Object
.
assign
(
expectedRule
.
condition
rule
.
condition
)
;
Object
.
assign
(
expectedRule
.
action
rule
.
action
)
;
if
(
rule
.
action
.
redirect
)
{
expectedRule
.
action
.
redirect
=
{
extensionPath
:
null
url
:
null
transform
:
null
regexSubstitution
:
null
.
.
.
rule
.
action
.
redirect
}
;
if
(
rule
.
action
.
redirect
.
transform
)
{
expectedRule
.
action
.
redirect
.
transform
=
{
scheme
:
null
username
:
null
password
:
null
host
:
null
port
:
null
path
:
null
query
:
null
queryTransform
:
null
fragment
:
null
.
.
.
rule
.
action
.
redirect
.
transform
}
;
if
(
rule
.
action
.
redirect
.
transform
.
queryTransform
)
{
const
qt
=
{
removeParams
:
null
addOrReplaceParams
:
null
.
.
.
rule
.
action
.
redirect
.
transform
.
queryTransform
}
;
if
(
qt
.
addOrReplaceParams
)
{
qt
.
addOrReplaceParams
=
qt
.
addOrReplaceParams
.
map
(
v
=
>
(
{
key
:
null
value
:
null
replaceOnly
:
false
.
.
.
v
}
)
)
;
}
expectedRule
.
action
.
redirect
.
transform
.
queryTransform
=
qt
;
}
}
}
if
(
rule
.
action
.
requestHeaders
)
{
expectedRule
.
action
.
requestHeaders
=
rule
.
action
.
requestHeaders
.
map
(
h
=
>
(
{
header
:
null
operation
:
null
value
:
null
.
.
.
h
}
)
)
;
}
if
(
rule
.
action
.
responseHeaders
)
{
expectedRule
.
action
.
responseHeaders
=
rule
.
action
.
responseHeaders
.
map
(
h
=
>
(
{
header
:
null
operation
:
null
value
:
null
.
.
.
h
}
)
)
;
}
browser
.
test
.
assertDeepEq
(
[
expectedRule
]
await
dnr
.
getSessionRules
(
)
"
Rule
should
be
valid
"
)
;
await
dnr
.
updateSessionRules
(
{
removeRuleIds
:
[
rule
.
id
]
}
)
;
}
async
function
testValidCondition
(
condition
)
{
await
testValidRule
(
{
id
:
1
condition
action
:
{
type
:
"
block
"
}
}
)
;
}
async
function
testValidAction
(
action
)
{
await
testValidRule
(
{
id
:
1
condition
:
{
}
action
}
)
;
}
Object
.
assign
(
dnrTestUtils
{
testInvalidRule
testInvalidCondition
testInvalidAction
testValidRule
testValidCondition
testValidAction
}
)
;
return
dnrTestUtils
;
}
async
function
runAsDNRExtension
(
{
background
unloadTestAtEnd
=
true
}
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
background
:
(
{
background
}
)
(
(
{
makeDnrTestUtils
}
)
(
)
)
manifest
:
{
manifest_version
:
3
permissions
:
[
"
declarativeNetRequest
"
"
declarativeNetRequestFeedback
"
]
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitFinish
(
)
;
if
(
unloadTestAtEnd
)
{
await
extension
.
unload
(
)
;
}
return
extension
;
}
add_task
(
async
function
register_and_retrieve_session_rules
(
)
{
let
extension
=
await
runAsDNRExtension
(
{
background
:
async
dnrTestUtils
=
>
{
const
dnr
=
browser
.
declarativeNetRequest
;
const
RULE_1234_IN
=
dnrTestUtils
.
makeRuleInput
(
1234
)
;
const
RULE_4321_IN
=
dnrTestUtils
.
makeRuleInput
(
4321
)
;
const
RULE_9001_IN
=
dnrTestUtils
.
makeRuleInput
(
9001
)
;
const
RULE_1234_OUT
=
dnrTestUtils
.
makeRuleOutput
(
1234
)
;
const
RULE_4321_OUT
=
dnrTestUtils
.
makeRuleOutput
(
4321
)
;
const
RULE_9001_OUT
=
dnrTestUtils
.
makeRuleOutput
(
9001
)
;
await
dnr
.
updateSessionRules
(
{
addRules
:
[
RULE_4321_IN
RULE_1234_IN
]
removeRuleIds
:
[
1234567890
]
}
)
;
browser
.
test
.
assertDeepEq
(
[
RULE_4321_OUT
RULE_1234_OUT
]
await
dnr
.
getSessionRules
(
)
"
getSessionRules
(
)
returns
all
registered
session
rules
"
)
;
await
browser
.
test
.
assertRejects
(
dnr
.
updateSessionRules
(
{
addRules
:
[
RULE_9001_IN
RULE_1234_IN
]
removeRuleIds
:
[
RULE_4321_IN
.
id
]
}
)
"
Duplicate
rule
ID
:
1234
"
"
updateSessionRules
of
existing
rule
without
removeRuleIds
should
fail
"
)
;
browser
.
test
.
assertDeepEq
(
[
RULE_4321_OUT
RULE_1234_OUT
]
await
dnr
.
getSessionRules
(
)
"
session
rules
should
not
be
changed
if
an
error
has
occurred
"
)
;
await
dnr
.
updateSessionRules
(
{
addRules
:
[
RULE_9001_IN
RULE_4321_IN
]
removeRuleIds
:
[
RULE_4321_IN
.
id
]
}
)
;
browser
.
test
.
assertDeepEq
(
[
RULE_1234_OUT
RULE_9001_OUT
RULE_4321_OUT
]
await
dnr
.
getSessionRules
(
)
"
existing
session
rule
ID
can
be
re
-
used
for
a
new
rule
"
)
;
await
dnr
.
updateSessionRules
(
{
removeRuleIds
:
[
RULE_1234_IN
.
id
RULE_4321_IN
.
id
RULE_9001_IN
.
id
]
}
)
;
browser
.
test
.
assertDeepEq
(
[
]
await
dnr
.
getSessionRules
(
)
"
deleted
all
rules
"
)
;
browser
.
test
.
notifyPass
(
)
;
}
unloadTestAtEnd
:
false
}
)
;
const
realExtension
=
extension
.
extension
;
Assert
.
ok
(
ExtensionDNR
.
getRuleManager
(
realExtension
false
)
"
Rule
manager
exists
before
unload
"
)
;
await
extension
.
unload
(
)
;
Assert
.
ok
(
!
ExtensionDNR
.
getRuleManager
(
realExtension
false
)
"
Rule
manager
erased
after
unload
"
)
;
}
)
;
add_task
(
async
function
validate_resourceTypes
(
)
{
await
runAsDNRExtension
(
{
background
:
async
dnrTestUtils
=
>
{
const
{
testInvalidCondition
testInvalidRule
testValidRule
testValidCondition
}
=
dnrTestUtils
;
await
testInvalidCondition
(
{
resourceTypes
:
[
"
font
"
"
image
"
]
excludedResourceTypes
:
[
"
image
"
]
}
"
resourceTypes
and
excludedResourceTypes
should
not
overlap
"
)
;
await
testInvalidCondition
(
{
resourceTypes
:
[
]
excludedResourceTypes
:
[
"
image
"
]
}
/
resourceTypes
:
Array
requires
at
least
1
items
;
you
have
0
/
true
)
;
await
testValidCondition
(
{
resourceTypes
:
[
"
font
"
]
excludedResourceTypes
:
[
"
image
"
]
}
)
;
await
testValidCondition
(
{
resourceTypes
:
[
"
font
"
]
excludedResourceTypes
:
[
]
}
)
;
await
testInvalidRule
(
{
id
:
1
condition
:
{
}
action
:
{
type
:
"
allowAllRequests
"
}
}
"
An
allowAllRequests
rule
must
have
a
non
-
empty
resourceTypes
array
"
)
;
await
testInvalidRule
(
{
id
:
1
condition
:
{
resourceTypes
:
[
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
/
resourceTypes
:
Array
requires
at
least
1
items
;
you
have
0
/
true
)
;
await
testInvalidRule
(
{
id
:
1
condition
:
{
resourceTypes
:
[
"
main_frame
"
"
image
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
"
An
allowAllRequests
rule
may
only
include
main_frame
/
sub_frame
in
resourceTypes
"
)
;
await
testValidRule
(
{
id
:
1
condition
:
{
resourceTypes
:
[
"
main_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
)
;
await
testValidRule
(
{
id
:
1
condition
:
{
resourceTypes
:
[
"
sub_frame
"
]
}
action
:
{
type
:
"
allowAllRequests
"
}
}
)
;
browser
.
test
.
notifyPass
(
)
;
}
}
)
;
}
)
;
add_task
(
async
function
validate_requestMethods
(
)
{
await
runAsDNRExtension
(
{
background
:
async
dnrTestUtils
=
>
{
const
{
testInvalidCondition
testValidCondition
}
=
dnrTestUtils
;
await
testInvalidCondition
(
{
requestMethods
:
[
"
get
"
]
excludedRequestMethods
:
[
"
post
"
"
get
"
]
}
"
requestMethods
and
excludedRequestMethods
should
not
overlap
"
)
;
await
testInvalidCondition
(
{
requestMethods
:
[
]
}
/
requestMethods
:
Array
requires
at
least
1
items
;
you
have
0
/
true
)
;
await
testInvalidCondition
(
{
requestMethods
:
[
"
GET
"
]
}
"
request
methods
must
be
in
lower
case
"
)
;
await
testInvalidCondition
(
{
excludedRequestMethods
:
[
"
PUT
"
]
}
"
request
methods
must
be
in
lower
case
"
)
;
await
testValidCondition
(
{
excludedRequestMethods
:
[
]
}
)
;
await
testValidCondition
(
{
requestMethods
:
[
"
get
"
"
head
"
]
excludedRequestMethods
:
[
"
post
"
]
}
)
;
await
testValidCondition
(
{
requestMethods
:
[
"
connect
"
"
delete
"
"
options
"
"
patch
"
"
put
"
"
xxx
"
]
}
)
;
browser
.
test
.
notifyPass
(
)
;
}
}
)
;
}
)
;
add_task
(
async
function
validate_tabIds
(
)
{
await
runAsDNRExtension
(
{
background
:
async
dnrTestUtils
=
>
{
const
{
testInvalidCondition
testValidCondition
}
=
dnrTestUtils
;
await
testInvalidCondition
(
{
tabIds
:
[
1
]
excludedTabIds
:
[
1
]
}
"
tabIds
and
excludedTabIds
should
not
overlap
"
)
;
await
testInvalidCondition
(
{
tabIds
:
[
]
}
/
tabIds
:
Array
requires
at
least
1
items
;
you
have
0
/
true
)
;
await
testValidCondition
(
{
excludedTabIds
:
[
]
}
)
;
await
testValidCondition
(
{
tabIds
:
[
-
1
0
1
]
excludedTabIds
:
[
2
]
}
)
;
await
testValidCondition
(
{
tabIds
:
[
Number
.
MAX_SAFE_INTEGER
]
}
)
;
browser
.
test
.
notifyPass
(
)
;
}
}
)
;
}
)
;
add_task
(
async
function
validate_domains
(
)
{
await
runAsDNRExtension
(
{
background
:
async
dnrTestUtils
=
>
{
const
{
testInvalidCondition
testValidCondition
}
=
dnrTestUtils
;
await
testInvalidCondition
(
{
requestDomains
:
[
]
}
/
requestDomains
:
Array
requires
at
least
1
items
;
you
have
0
/
true
)
;
await
testInvalidCondition
(
{
initiatorDomains
:
[
]
}
/
initiatorDomains
:
Array
requires
at
least
1
items
;
you
have
0
/
true
)
;
await
testValidCondition
(
{
requestDomains
:
[
"
example
.
com
"
]
excludedRequestDomains
:
[
"
example
.
com
"
]
initiatorDomains
:
[
"
example
.
com
"
]
excludedInitiatorDomains
:
[
"
example
.
com
"
]
}
)
;
await
testValidCondition
(
{
excludedRequestDomains
:
[
]
excludedInitiatorDomains
:
[
]
}
)
;
await
testInvalidCondition
(
{
requestDomains
:
[
null
]
}
/
requestDomains
\
.
0
:
Expected
string
instead
of
null
/
true
)
;
await
testValidCondition
(
{
requestDomains
:
[
"
null
"
]
}
)
;
await
testInvalidCondition
(
{
requestDomains
:
[
"
1
.
2
"
]
}
/
requestDomains
\
.
0
:
Error
:
Invalid
domain
1
.
2
/
true
)
;
await
testValidCondition
(
{
requestDomains
:
[
"
0
.
0
.
1
.
2
"
]
}
)
;
await
testInvalidCondition
(
{
requestDomains
:
[
"
:
:
1
"
]
}
/
requestDomains
\
.
0
:
Error
:
Invalid
domain
:
:
1
/
true
)
;
await
testInvalidCondition
(
{
requestDomains
:
[
"
[
:
:
ffff
:
127
.
0
.
0
.
1
]
"
]
}
/
requestDomains
\
.
0
:
Error
:
Invalid
domain
\
[
:
:
ffff
:
127
\
.
0
\
.
0
\
.
1
\
]
/
true
)
;
await
testValidCondition
(
{
requestDomains
:
[
"
[
:
:
1
]
"
"
[
:
:
ffff
:
7f00
:
1
]
"
]
}
)
;
await
testInvalidCondition
(
{
requestDomains
:
[
"
stra
.
de
"
]
}
/
requestDomains
\
.
0
:
Error
:
Invalid
domain
stra
.
de
/
true
)
;
await
testValidCondition
(
{
requestDomains
:
[
"
xn
-
-
stra
-
yna
.
de
"
]
}
)
;
await
testInvalidCondition
(
{
requestDomains
:
[
"
a
.
com
:
1234
"
]
}
/
requestDomains
\
.
0
:
Error
:
Invalid
domain
a
.
com
:
1234
/
true
)
;
await
testInvalidCondition
(
{
requestDomains
:
[
"
UPPERCASE
"
]
}
/
requestDomains
\
.
0
:
Error
:
Invalid
domain
UPPERCASE
/
true
)
;
await
testInvalidCondition
(
{
requestDomains
:
[
"
ex
%
61mple
.
com
"
]
}
/
requestDomains
\
.
0
:
Error
:
Invalid
domain
ex
%
61mple
.
com
/
true
)
;
for
(
let
domainsKey
of
[
"
initiatorDomains
"
"
excludedInitiatorDomains
"
"
requestDomains
"
"
excludedRequestDomains
"
]
)
{
await
testInvalidCondition
(
{
[
domainsKey
]
:
[
"
"
]
}
new
RegExp
(
String
.
raw
{
domainsKey
}
\
.
0
:
Error
:
Invalid
domain
\
)
)
true
)
;
}
browser
.
test
.
notifyPass
(
)
;
}
}
)
;
}
)
;
add_task
(
async
function
validate_actions
(
)
{
await
runAsDNRExtension
(
{
background
:
async
dnrTestUtils
=
>
{
const
{
testInvalidAction
testValidAction
}
=
dnrTestUtils
;
await
testValidAction
(
{
type
:
"
allow
"
}
)
;
await
testValidAction
(
{
type
:
"
block
"
}
)
;
await
testValidAction
(
{
type
:
"
upgradeScheme
"
}
)
;
await
testValidAction
(
{
type
:
"
block
"
}
)
;
await
testInvalidAction
(
{
type
:
"
redirect
"
}
"
A
redirect
rule
must
have
a
non
-
empty
action
.
redirect
object
"
)
;
await
testInvalidAction
(
{
type
:
"
redirect
"
redirect
:
{
}
}
"
A
redirect
rule
must
have
a
non
-
empty
action
.
redirect
object
"
)
;
await
testInvalidAction
(
{
type
:
"
redirect
"
redirect
:
{
extensionPath
:
"
/
"
url
:
"
http
:
/
/
a
"
}
}
"
redirect
.
extensionPath
and
redirect
.
url
are
mutually
exclusive
"
)
;
await
testInvalidAction
(
{
type
:
"
redirect
"
redirect
:
{
extensionPath
:
"
"
url
:
"
http
:
/
/
a
"
}
}
"
redirect
.
extensionPath
and
redirect
.
url
are
mutually
exclusive
"
)
;
await
testInvalidAction
(
{
type
:
"
redirect
"
redirect
:
{
extensionPath
:
"
"
}
}
"
redirect
.
extensionPath
should
start
with
a
'
/
'
"
)
;
await
testInvalidAction
(
{
type
:
"
redirect
"
redirect
:
{
extensionPath
:
browser
.
runtime
.
getURL
(
"
/
"
)
}
}
"
redirect
.
extensionPath
should
start
with
a
'
/
'
"
)
;
await
testInvalidAction
(
{
type
:
"
redirect
"
redirect
:
{
url
:
"
javascript
:
"
}
}
/
Access
denied
for
URL
javascript
:
/
true
)
;
await
testInvalidAction
(
{
type
:
"
redirect
"
redirect
:
{
url
:
"
JAVASCRIPT
:
/
/
Hmmm
"
}
}
/
Access
denied
for
URL
javascript
:
\
/
\
/
Hmmm
/
true
)
;
await
testInvalidAction
(
{
type
:
"
redirect
"
redirect
:
{
url
:
"
about
:
addons
"
}
}
/
Access
denied
for
URL
about
:
addons
/
true
)
;
await
testInvalidAction
(
{
type
:
"
redirect
"
redirect
:
{
url
:
"
data
:
"
}
}
/
Access
denied
for
URL
data
:
/
true
)
;
await
testValidAction
(
{
type
:
"
redirect
"
redirect
:
{
extensionPath
:
"
/
foo
.
txt
"
}
}
)
;
await
testValidAction
(
{
type
:
"
redirect
"
redirect
:
{
url
:
"
https
:
/
/
example
.
com
/
"
}
}
)
;
await
testValidAction
(
{
type
:
"
redirect
"
redirect
:
{
url
:
browser
.
runtime
.
getURL
(
"
/
"
)
}
}
)
;
await
testValidAction
(
{
type
:
"
redirect
"
redirect
:
{
transform
:
{
}
}
}
)
;
await
testInvalidAction
(
{
type
:
"
modifyHeaders
"
}
"
A
modifyHeaders
rule
must
have
a
non
-
empty
requestHeaders
or
modifyHeaders
list
"
)
;
await
testInvalidAction
(
{
type
:
"
modifyHeaders
"
requestHeaders
:
[
]
}
/
requestHeaders
:
Array
requires
at
least
1
items
;
you
have
0
/
true
)
;
await
testInvalidAction
(
{
type
:
"
modifyHeaders
"
responseHeaders
:
[
]
}
/
responseHeaders
:
Array
requires
at
least
1
items
;
you
have
0
/
true
)
;
await
testInvalidAction
(
{
type
:
"
modifyHeaders
"
requestHeaders
:
[
{
header
:
"
"
operation
:
"
remove
"
}
]
}
"
header
must
be
non
-
empty
"
)
;
await
testInvalidAction
(
{
type
:
"
modifyHeaders
"
responseHeaders
:
[
{
header
:
"
"
operation
:
"
remove
"
}
]
}
"
header
must
be
non
-
empty
"
)
;
await
testInvalidAction
(
{
type
:
"
modifyHeaders
"
responseHeaders
:
[
{
header
:
"
x
"
operation
:
"
append
"
}
]
}
"
value
is
required
for
operations
append
/
set
"
)
;
await
testInvalidAction
(
{
type
:
"
modifyHeaders
"
responseHeaders
:
[
{
header
:
"
x
"
operation
:
"
set
"
}
]
}
"
value
is
required
for
operations
append
/
set
"
)
;
await
testInvalidAction
(
{
type
:
"
modifyHeaders
"
responseHeaders
:
[
{
header
:
"
x
"
operation
:
"
remove
"
value
:
"
x
"
}
]
}
"
value
must
not
be
provided
for
operation
remove
"
)
;
await
testInvalidAction
(
{
type
:
"
modifyHeaders
"
responseHeaders
:
[
{
header
:
"
x
"
operation
:
"
REMOVE
"
value
:
"
x
"
}
]
}
/
operation
:
Invalid
enumeration
value
"
REMOVE
"
/
true
)
;
await
testInvalidAction
(
{
type
:
"
modifyHeaders
"
requestHeaders
:
[
{
header
:
"
x
"
operation
:
"
append
"
value
:
"
x
"
}
]
}
/
operation
:
Invalid
enumeration
value
"
append
"
/
true
)
;
await
testValidAction
(
{
type
:
"
modifyHeaders
"
requestHeaders
:
[
{
header
:
"
x
"
operation
:
"
set
"
value
:
"
x
"
}
]
}
)
;
await
testValidAction
(
{
type
:
"
modifyHeaders
"
responseHeaders
:
[
{
header
:
"
x
"
operation
:
"
set
"
value
:
"
x
"
}
]
}
)
;
await
testValidAction
(
{
type
:
"
modifyHeaders
"
requestHeaders
:
[
{
header
:
"
y
"
operation
:
"
set
"
value
:
"
y
"
}
]
responseHeaders
:
[
{
header
:
"
z
"
operation
:
"
set
"
value
:
"
z
"
}
]
}
)
;
await
testValidAction
(
{
type
:
"
modifyHeaders
"
requestHeaders
:
[
{
header
:
"
reqh
"
operation
:
"
set
"
value
:
"
b
"
}
{
header
:
"
reqh
"
operation
:
"
remove
"
}
]
responseHeaders
:
[
{
header
:
"
resh
"
operation
:
"
set
"
value
:
"
b
"
}
{
header
:
"
resh
"
operation
:
"
append
"
value
:
"
b
"
}
{
header
:
"
resh
"
operation
:
"
remove
"
}
]
}
)
;
await
testInvalidAction
(
{
type
:
"
MODIFYHEADERS
"
}
/
type
:
Invalid
enumeration
value
"
MODIFYHEADERS
"
/
true
)
;
browser
.
test
.
notifyPass
(
)
;
}
}
)
;
}
)
;
add_task
(
async
function
validate_action_redirect_transform
(
)
{
await
runAsDNRExtension
(
{
background
:
async
dnrTestUtils
=
>
{
const
{
testInvalidAction
testValidAction
}
=
dnrTestUtils
;
const
GENERIC_TRANSFORM_ERROR
=
"
redirect
.
transform
does
not
describe
a
valid
URL
transformation
"
;
const
testValidTransform
=
transform
=
>
testValidAction
(
{
type
:
"
redirect
"
redirect
:
{
transform
}
}
)
;
const
testInvalidTransform
=
(
transform
expectedError
isSchemaError
)
=
>
testInvalidAction
(
{
type
:
"
redirect
"
redirect
:
{
transform
}
}
expectedError
?
?
GENERIC_TRANSFORM_ERROR
isSchemaError
)
;
const
VERY_LONG_STRING
=
"
x
"
.
repeat
(
1048576
)
;
await
testValidTransform
(
{
}
)
;
await
testValidTransform
(
{
scheme
:
"
http
"
}
)
;
await
testValidTransform
(
{
scheme
:
"
https
"
}
)
;
await
testValidTransform
(
{
scheme
:
"
moz
-
extension
"
}
)
;
await
testInvalidTransform
(
{
scheme
:
"
HTTPS
"
}
/
scheme
:
Invalid
enumeration
value
"
HTTPS
"
/
true
)
;
await
testInvalidTransform
(
{
scheme
:
"
javascript
"
}
/
scheme
:
Invalid
enumeration
value
"
javascript
"
/
true
)
;
await
testInvalidTransform
(
{
scheme
:
"
ftp
"
}
/
scheme
:
Invalid
enumeration
value
"
ftp
"
/
true
)
;
await
testValidTransform
(
{
host
:
"
example
.
com
"
}
)
;
await
testValidTransform
(
{
host
:
"
example
.
com
.
"
}
)
;
await
testValidTransform
(
{
host
:
"
localhost
"
}
)
;
await
testValidTransform
(
{
host
:
"
127
.
0
.
0
.
1
"
}
)
;
await
testValidTransform
(
{
host
:
"
[
:
:
1
]
"
}
)
;
await
testValidTransform
(
{
host
:
"
.
"
}
)
;
await
testValidTransform
(
{
host
:
"
stra
.
de
"
}
)
;
await
testValidTransform
(
{
host
:
"
xn
-
-
stra
-
yna
.
de
"
}
)
;
await
testInvalidTransform
(
{
host
:
"
:
:
1
"
}
)
;
await
testInvalidTransform
(
{
host
:
"
[
]
"
}
)
;
await
testInvalidTransform
(
{
host
:
"
/
"
}
)
;
await
testInvalidTransform
(
{
host
:
"
a
"
}
)
;
await
testInvalidTransform
(
{
host
:
"
foo
:
1234
"
}
)
;
await
testInvalidTransform
(
{
host
:
"
foo
:
"
}
)
;
await
testInvalidTransform
(
{
host
:
"
"
}
)
;
await
testInvalidTransform
(
{
host
:
VERY_LONG_STRING
}
)
;
await
testValidTransform
(
{
port
:
"
"
}
)
;
await
testValidTransform
(
{
port
:
"
0
"
}
)
;
await
testValidTransform
(
{
port
:
"
0700
"
}
)
;
await
testValidTransform
(
{
port
:
"
65535
"
}
)
;
const
PORT_ERR
=
"
redirect
.
transform
.
port
should
be
empty
or
an
integer
"
;
await
testInvalidTransform
(
{
port
:
"
65536
"
}
GENERIC_TRANSFORM_ERROR
)
;
await
testInvalidTransform
(
{
port
:
"
0
"
}
PORT_ERR
)
;
await
testInvalidTransform
(
{
port
:
"
0
"
}
PORT_ERR
)
;
await
testInvalidTransform
(
{
port
:
"
0
.
"
}
PORT_ERR
)
;
await
testInvalidTransform
(
{
port
:
"
0x1
"
}
PORT_ERR
)
;
await
testInvalidTransform
(
{
port
:
"
1
.
2
"
}
PORT_ERR
)
;
await
testInvalidTransform
(
{
port
:
"
-
1
"
}
PORT_ERR
)
;
await
testInvalidTransform
(
{
port
:
"
a
"
}
PORT_ERR
)
;
await
testInvalidTransform
(
{
host
:
"
[
:
:
1
"
port
:
"
2
]
"
}
PORT_ERR
)
;
await
testInvalidTransform
(
{
port
:
VERY_LONG_STRING
}
PORT_ERR
)
;
await
testValidTransform
(
{
path
:
"
"
}
)
;
await
testValidTransform
(
{
path
:
"
/
slash
"
}
)
;
await
testValidTransform
(
{
path
:
"
/
ref
#
ok
"
}
)
;
await
testValidTransform
(
{
path
:
"
/
\
n
\
t
\
x00
"
}
)
;
await
testValidTransform
(
{
path
:
"
noslash
"
}
)
;
await
testValidTransform
(
{
path
:
"
http
:
/
/
example
.
com
/
"
}
)
;
await
testInvalidTransform
(
{
path
:
VERY_LONG_STRING
}
)
;
await
testValidTransform
(
{
query
:
"
"
}
)
;
await
testValidTransform
(
{
query
:
"
?
suffix
"
}
)
;
await
testValidTransform
(
{
query
:
"
?
ref
#
ok
"
}
)
;
await
testValidTransform
(
{
query
:
"
?
\
n
\
t
\
x00
"
}
)
;
await
testInvalidTransform
(
{
query
:
"
noquestionmark
"
}
"
redirect
.
transform
.
query
should
be
empty
or
start
with
a
'
?
'
"
)
;
await
testInvalidTransform
(
{
query
:
"
?
"
+
VERY_LONG_STRING
}
)
;
await
testInvalidTransform
(
{
query
:
"
"
queryTransform
:
{
}
}
"
redirect
.
transform
.
query
and
redirect
.
transform
.
queryTransform
are
mutually
exclusive
"
)
;
await
testValidTransform
(
{
queryTransform
:
{
}
}
)
;
await
testValidTransform
(
{
queryTransform
:
{
removeParams
:
[
]
}
}
)
;
await
testValidTransform
(
{
queryTransform
:
{
removeParams
:
[
"
x
"
]
}
}
)
;
await
testValidTransform
(
{
queryTransform
:
{
addOrReplaceParams
:
[
]
}
}
)
;
await
testValidTransform
(
{
queryTransform
:
{
addOrReplaceParams
:
[
{
key
:
"
k
"
value
:
"
v
"
}
]
}
}
)
;
await
testValidTransform
(
{
queryTransform
:
{
addOrReplaceParams
:
[
{
key
:
"
k
"
value
:
"
v
"
replaceOnly
:
true
}
]
}
}
)
;
await
testInvalidTransform
(
{
queryTransform
:
{
addOrReplaceParams
:
[
{
key
:
"
k
"
value
:
VERY_LONG_STRING
}
]
}
}
)
;
await
testInvalidTransform
(
{
queryTransform
:
{
addOrReplaceParams
:
[
{
key
:
"
k
"
}
]
}
}
/
addOrReplaceParams
\
.
0
:
Property
"
value
"
is
required
/
true
)
;
await
testInvalidTransform
(
{
queryTransform
:
{
addOrReplaceParams
:
[
{
value
:
"
v
"
}
]
}
}
/
addOrReplaceParams
\
.
0
:
Property
"
key
"
is
required
/
true
)
;
await
testValidTransform
(
{
fragment
:
"
"
}
)
;
await
testValidTransform
(
{
fragment
:
"
#
suffix
"
}
)
;
await
testValidTransform
(
{
fragment
:
"
#
\
n
\
t
\
x00
"
}
)
;
await
testInvalidTransform
(
{
fragment
:
"
nohash
"
}
"
redirect
.
transform
.
fragment
should
be
empty
or
start
with
a
'
#
'
"
)
;
await
testInvalidTransform
(
{
fragment
:
"
#
"
+
VERY_LONG_STRING
}
)
;
await
testValidTransform
(
{
username
:
"
"
}
)
;
await
testValidTransform
(
{
username
:
"
username
"
}
)
;
await
testValidTransform
(
{
username
:
"
:
"
}
)
;
await
testInvalidTransform
(
{
username
:
VERY_LONG_STRING
}
)
;
await
testValidTransform
(
{
password
:
"
"
}
)
;
await
testValidTransform
(
{
password
:
"
pass
"
}
)
;
await
testValidTransform
(
{
password
:
"
:
"
}
)
;
await
testInvalidTransform
(
{
password
:
VERY_LONG_STRING
}
)
;
await
testValidTransform
(
{
scheme
:
"
http
"
username
:
"
a
"
password
:
"
b
"
host
:
"
c
"
port
:
"
12345
"
path
:
"
/
d
"
query
:
"
?
e
"
queryTransform
:
null
fragment
:
"
#
f
"
}
)
;
browser
.
test
.
notifyPass
(
)
;
}
}
)
;
}
)
;
