"
use
strict
"
;
ExtensionTestUtils
.
mockAppInfo
(
)
;
const
server
=
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
]
}
)
;
server
.
registerPathHandler
(
"
/
empty
"
(
)
=
>
{
}
)
;
server
.
registerPathHandler
(
"
/
parser_inserted
.
html
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
write
(
<
iframe
src
=
"
/
slow_frame
.
html
"
>
<
/
iframe
>
)
;
}
)
;
server
.
registerPathHandler
(
"
/
js_inserted
.
html
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
write
(
<
body
>
<
script
>
let
f
=
document
.
createElement
(
"
iframe
"
)
;
f
.
src
=
"
/
slow_frame
.
html
"
;
document
.
body
.
append
(
f
)
;
/
/
Reach
into
the
frame
'
s
content
window
in
case
it
could
potentially
/
/
affect
the
initialization
of
the
JS
execution
context
there
.
In
the
unit
/
/
tests
we
want
to
verify
that
content
scripts
do
NOT
execute
in
initial
/
/
about
:
blank
.
This
would
trivially
be
true
if
the
initial
about
:
blank
/
/
document
did
not
exist
.
For
example
on
Android
the
initial
about
:
blank
/
/
document
is
not
created
until
touched
by
JavaScript
.
f
.
contentWindow
.
dump
(
"
Hello
world
sync
\
\
n
"
)
;
/
/
Although
not
strictly
necessary
do
it
again
async
.
The
100ms
timer
here
/
/
is
slower
than
the
500ms
timer
of
slow_frame
.
html
so
this
should
still
/
/
be
touching
the
(
initial
)
about
:
blank
document
.
setTimeout
(
(
)
=
>
f
.
contentWindow
.
dump
(
"
Hello
world
async
\
\
n
"
)
100
)
;
<
/
script
>
)
;
}
)
;
server
.
registerPathHandler
(
"
/
slow_frame
.
html
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
setHeader
(
"
Cache
-
Control
"
"
no
-
cache
"
)
;
response
.
processAsync
(
)
;
info
(
"
[
server
]
received
request
for
slow_frame
.
html
"
)
;
setTimeout
(
(
)
=
>
{
info
(
"
[
server
]
sending
response
for
slow_frame
.
html
"
)
;
response
.
write
(
"
Response
of
slow_frame
"
)
;
response
.
finish
(
)
;
}
500
)
;
}
)
;
const
responsesToFinish
=
[
]
;
server
.
registerPathHandler
(
"
/
neverloading
.
html
"
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
setHeader
(
"
Cache
-
Control
"
"
no
-
cache
"
)
;
response
.
processAsync
(
)
;
responsesToFinish
.
push
(
response
)
;
}
)
;
registerCleanupFunction
(
(
)
=
>
{
responsesToFinish
.
forEach
(
response
=
>
response
.
finish
(
)
)
;
}
)
;
async
function
setupScriptInjectionDetector
(
contentPage
)
{
await
contentPage
.
spawn
(
[
]
(
)
=
>
{
const
{
ExtensionProcessScript
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ExtensionProcessScript
.
sys
.
mjs
"
)
;
if
(
ExtensionProcessScript
.
_test_only_pendingInjections
)
{
ExtensionProcessScript
.
_test_only_pendingInjections
.
length
=
0
;
return
;
}
const
pendingInjections
=
[
]
;
const
{
loadContentScript
}
=
ExtensionProcessScript
;
ExtensionProcessScript
.
loadContentScript
=
(
contentScript
window
)
=
>
{
let
promise
=
loadContentScript
(
contentScript
window
)
;
if
(
window
.
parent
!
=
=
window
)
{
let
url
=
window
.
document
?
.
URL
?
?
"
(
no
document
?
?
?
)
"
;
let
runAt
=
contentScript
.
runAt
;
let
injectionDescription
=
{
returnStatus
:
"
pending
"
runAt
url
}
;
pendingInjections
.
push
(
injectionDescription
)
;
promise
.
then
(
(
)
=
>
{
injectionDescription
.
returnStatus
=
"
resolved
"
;
}
(
)
=
>
{
injectionDescription
.
returnStatus
=
"
rejected
"
;
}
)
;
}
return
promise
;
}
;
ExtensionProcessScript
.
_test_only_pendingInjections
=
pendingInjections
;
}
)
;
}
async
function
getPendingScriptInjections
(
contentPage
)
{
return
contentPage
.
spawn
(
[
]
(
)
=
>
{
const
{
ExtensionProcessScript
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ExtensionProcessScript
.
sys
.
mjs
"
)
;
return
ExtensionProcessScript
.
_test_only_pendingInjections
.
slice
(
)
;
}
)
;
}
function
loadTestExtensionWithContentScripts
(
)
{
return
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
content_scripts
:
[
{
js
:
[
"
document_start
.
js
"
]
run_at
:
"
document_start
"
match_about_blank
:
true
all_frames
:
true
matches
:
[
"
*
:
/
/
example
.
com
/
*
"
]
}
{
js
:
[
"
document_end
.
js
"
]
run_at
:
"
document_end
"
match_about_blank
:
true
all_frames
:
true
matches
:
[
"
*
:
/
/
example
.
com
/
*
"
]
}
{
js
:
[
"
document_idle
.
js
"
]
run_at
:
"
document_idle
"
match_about_blank
:
true
all_frames
:
true
matches
:
[
"
*
:
/
/
example
.
com
/
*
"
]
}
]
}
files
:
{
"
document_start
.
js
"
:
(
)
=
>
{
if
(
top
!
=
=
window
)
{
browser
.
test
.
sendMessage
(
"
got_frame
"
"
document_start
"
document
.
URL
)
;
}
}
"
document_end
.
js
"
:
(
)
=
>
{
if
(
top
!
=
=
window
)
{
browser
.
test
.
sendMessage
(
"
got_frame
"
"
document_end
"
document
.
URL
)
;
}
}
"
document_idle
.
js
"
:
(
)
=
>
{
if
(
top
!
=
=
window
)
{
browser
.
test
.
sendMessage
(
"
got_frame
"
"
document_idle
"
document
.
URL
)
;
}
else
{
browser
.
test
.
sendMessage
(
"
contentscript_in_top
"
)
;
}
}
}
}
)
;
}
async
function
testLoadContentScripts
(
urlThatEmbedsSlowFrame
)
{
let
extension
=
loadTestExtensionWithContentScripts
(
)
;
const
seenScripts
=
[
]
;
const
donePromise
=
new
Promise
(
resolve
=
>
{
extension
.
onMessage
(
"
got_frame
"
(
runAt
url
)
=
>
{
seenScripts
.
push
(
{
runAt
url
}
)
;
if
(
runAt
=
=
=
"
document_idle
"
&
&
url
.
endsWith
(
"
/
slow_frame
.
html
"
)
)
{
resolve
(
)
;
}
}
)
;
}
)
;
await
extension
.
startup
(
)
;
const
URL_INITIAL
=
"
http
:
/
/
example
.
com
/
empty
"
;
const
URL_TOP
=
urlThatEmbedsSlowFrame
;
const
URL_FRAME
=
"
http
:
/
/
example
.
com
/
slow_frame
.
html
"
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
URL_INITIAL
)
;
await
extension
.
awaitMessage
(
"
contentscript_in_top
"
)
;
await
setupScriptInjectionDetector
(
contentPage
)
;
info
(
Navigating
to
{
URL_TOP
}
which
embeds
slow
-
loading
{
URL_FRAME
}
)
;
await
contentPage
.
loadURL
(
URL_TOP
)
;
await
extension
.
awaitMessage
(
"
contentscript_in_top
"
)
;
info
(
"
Waiting
for
the
last
content
script
to
execute
.
.
.
"
)
;
await
donePromise
;
Assert
.
deepEqual
(
seenScripts
[
{
runAt
:
"
document_start
"
url
:
URL_FRAME
}
{
runAt
:
"
document_end
"
url
:
URL_FRAME
}
{
runAt
:
"
document_idle
"
url
:
URL_FRAME
}
]
"
Expected
content
scripts
in
frames
"
)
;
Assert
.
deepEqual
(
await
getPendingScriptInjections
(
contentPage
)
[
{
returnStatus
:
"
resolved
"
runAt
:
"
document_start
"
url
:
URL_FRAME
}
{
returnStatus
:
"
resolved
"
runAt
:
"
document_end
"
url
:
URL_FRAME
}
{
returnStatus
:
"
resolved
"
runAt
:
"
document_idle
"
url
:
URL_FRAME
}
]
"
There
should
not
be
any
unexpected
pending
content
script
injections
"
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
add_task
(
async
function
test_slow_frame_in_html
(
)
{
await
testLoadContentScripts
(
"
http
:
/
/
example
.
com
/
parser_inserted
.
html
"
)
;
}
)
;
add_task
(
async
function
test_slow_frame_inserted_via_javascript
(
)
{
await
testLoadContentScripts
(
"
http
:
/
/
example
.
com
/
js_inserted
.
html
"
)
;
}
)
;
add_task
(
async
function
test_frame_unload_before_execute
(
)
{
const
URL_INITIAL
=
"
http
:
/
/
example
.
com
/
empty
"
;
let
contentPage
=
await
ExtensionTestUtils
.
loadContentPage
(
URL_INITIAL
)
;
await
setupScriptInjectionDetector
(
contentPage
)
;
await
contentPage
.
spawn
(
[
]
(
)
=
>
{
const
{
document
}
=
this
.
content
.
wrappedJSObject
;
let
f
=
document
.
createElement
(
"
iframe
"
)
;
f
.
id
=
"
neverloading_frame
"
;
f
.
src
=
"
/
neverloading
.
html
"
;
document
.
body
.
append
(
f
)
;
}
)
;
const
extension
=
loadTestExtensionWithContentScripts
(
)
;
const
seenScripts
=
[
]
;
extension
.
onMessage
(
"
got_frame
"
(
runAt
url
)
=
>
{
seenScripts
.
push
(
{
runAt
url
}
)
;
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
contentscript_in_top
"
)
;
info
(
"
Detected
content
script
attempt
in
top
doc
going
to
remove
the
frame
"
)
;
await
contentPage
.
spawn
(
[
]
async
(
)
=
>
{
const
{
TestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
)
;
let
f
=
this
.
content
.
document
.
querySelector
(
#
neverloading_frame
)
;
let
innerWindowId
=
f
.
contentWindow
.
windowGlobalChild
.
innerWindowId
;
let
frameNukedPromise
=
TestUtils
.
topicObserved
(
"
inner
-
window
-
nuked
"
subject
=
>
innerWindowId
=
=
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
)
;
f
.
remove
(
)
;
info
(
"
Removed
frame
waiting
to
ensure
that
it
was
fully
destroyed
"
)
;
await
frameNukedPromise
;
info
(
"
Frame
has
been
fully
destroyed
"
)
;
}
)
;
Assert
.
deepEqual
(
seenScripts
[
{
runAt
:
"
document_start
"
url
:
"
about
:
blank
"
}
]
"
Accounted
for
all
content
script
executions
"
)
;
Assert
.
deepEqual
(
await
getPendingScriptInjections
(
contentPage
)
[
{
returnStatus
:
"
resolved
"
runAt
:
"
document_start
"
url
:
"
about
:
blank
"
}
{
returnStatus
:
"
pending
"
runAt
:
"
document_end
"
url
:
"
about
:
blank
"
}
]
"
TODO
:
There
should
not
be
any
pending
content
script
injections
"
)
;
await
contentPage
.
close
(
)
;
await
extension
.
unload
(
)
;
}
)
;
