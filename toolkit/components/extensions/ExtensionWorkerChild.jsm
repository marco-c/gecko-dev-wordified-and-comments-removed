"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExtensionWorkerChild
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
ExtensionChild
ExtensionActivityLogChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionChild
.
jsm
"
)
;
const
{
ExtensionCommon
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
const
{
ExtensionPageChild
getContextChildManagerGetter
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionPageChild
.
jsm
"
)
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
{
BaseContext
defineLazyGetter
}
=
ExtensionCommon
;
const
{
ChildAPIManager
ChildLocalAPIImplementation
MessageEvent
Messenger
Port
ProxyAPIImplementation
SimpleEventAPI
}
=
ExtensionChild
;
const
{
DefaultMap
getUniqueId
}
=
ExtensionUtils
;
class
WorkerRuntimePortEvent
extends
SimpleEventAPI
{
api
(
)
{
return
{
.
.
.
super
.
api
(
)
createListenerForAPIRequest
:
(
.
.
.
args
)
=
>
this
.
createListenerForAPIRequest
(
.
.
.
args
)
}
;
}
createListenerForAPIRequest
(
request
)
{
const
{
eventListener
}
=
request
;
return
function
(
port
.
.
.
args
)
{
return
eventListener
.
callListener
(
args
{
apiObjectType
:
Ci
.
mozIExtensionListenerCallOptions
.
RUNTIME_PORT
apiObjectDescriptor
:
{
portId
:
port
.
portId
name
:
port
.
name
}
}
)
;
}
;
}
}
class
WorkerMessageEvent
extends
MessageEvent
{
api
(
)
{
return
{
.
.
.
super
.
api
(
)
createListenerForAPIRequest
:
(
.
.
.
args
)
=
>
this
.
createListenerForAPIRequest
(
.
.
.
args
)
}
;
}
createListenerForAPIRequest
(
request
)
{
const
{
eventListener
}
=
request
;
return
function
(
message
sender
)
{
return
eventListener
.
callListener
(
[
message
sender
]
{
eventListenerType
:
Ci
.
mozIExtensionListenerCallOptions
.
CALLBACK_SEND_RESPONSE
}
)
;
}
;
}
}
class
WorkerPortEvent
extends
SimpleEventAPI
{
api
(
)
{
return
{
.
.
.
super
.
api
(
)
createListenerForAPIRequest
:
(
.
.
.
args
)
=
>
this
.
createListenerForAPIRequest
(
.
.
.
args
)
}
;
}
createListenerForAPIRequest
(
request
)
{
const
{
eventListener
}
=
request
;
switch
(
this
.
name
)
{
case
"
Port
.
onDisconnect
"
:
return
function
(
port
)
{
eventListener
.
callListener
(
[
]
{
apiObjectType
:
Ci
.
mozIExtensionListenerCallOptions
.
RUNTIME_PORT
apiObjectDescriptor
:
{
portId
:
port
.
portId
name
:
port
.
name
}
}
)
;
}
;
case
"
Port
.
onMessage
"
:
return
function
(
message
port
)
{
eventListener
.
callListener
(
[
message
]
{
apiObjectType
:
Ci
.
mozIExtensionListenerCallOptions
.
RUNTIME_PORT
apiObjectDescriptor
:
{
portId
:
port
.
portId
name
:
port
.
name
}
}
)
;
}
;
}
return
undefined
;
}
}
class
WorkerPort
extends
Port
{
constructor
(
context
portId
name
native
sender
)
{
const
{
viewType
contextId
}
=
context
;
if
(
viewType
!
=
=
"
background_worker
"
)
{
throw
new
Error
(
Unexpected
viewType
"
{
viewType
}
"
on
context
{
contextId
}
)
;
}
super
(
context
portId
name
native
sender
)
;
this
.
portId
=
portId
;
}
initEventManagers
(
)
{
const
{
context
}
=
this
;
this
.
onMessage
=
new
WorkerPortEvent
(
context
"
Port
.
onMessage
"
)
;
this
.
onDisconnect
=
new
WorkerPortEvent
(
context
"
Port
.
onDisconnect
"
)
;
}
getAPI
(
)
{
const
api
=
super
.
getAPI
(
)
;
api
.
portId
=
this
.
portId
;
return
api
;
}
}
defineLazyGetter
(
WorkerPort
.
prototype
"
api
"
function
(
)
{
return
this
.
getAPI
(
)
;
}
)
;
class
WorkerMessenger
extends
Messenger
{
constructor
(
context
)
{
const
{
viewType
contextId
}
=
context
;
if
(
viewType
!
=
=
"
background_worker
"
)
{
throw
new
Error
(
Unexpected
viewType
"
{
viewType
}
"
on
context
{
contextId
}
)
;
}
super
(
context
)
;
this
.
portsById
=
new
Map
(
)
;
this
.
context
.
callOnClose
(
this
)
;
}
initEventManagers
(
)
{
const
{
context
}
=
this
;
this
.
onConnect
=
new
WorkerRuntimePortEvent
(
context
"
runtime
.
onConnect
"
)
;
this
.
onConnectEx
=
new
WorkerRuntimePortEvent
(
context
"
runtime
.
onConnectExternal
"
)
;
this
.
onMessage
=
new
WorkerMessageEvent
(
this
.
context
"
runtime
.
onMessage
"
)
;
this
.
onMessageEx
=
new
WorkerMessageEvent
(
context
"
runtime
.
onMessageExternal
"
)
;
}
close
(
)
{
this
.
portsById
.
clear
(
)
;
}
getPortById
(
portId
)
{
return
this
.
portsById
.
get
(
portId
)
;
}
connect
(
{
name
native
.
.
.
args
}
)
{
let
portId
=
getUniqueId
(
)
;
let
port
=
new
WorkerPort
(
this
.
context
portId
name
!
!
native
)
;
this
.
conduit
.
queryPortConnect
(
{
portId
name
native
.
.
.
args
}
)
.
catch
(
error
=
>
port
.
recvPortDisconnect
(
{
error
}
)
)
;
this
.
portsById
.
set
(
{
portId
}
port
)
;
return
{
portId
name
}
;
}
recvPortConnect
(
{
extensionId
portId
name
sender
}
)
{
let
event
=
sender
.
id
=
=
=
extensionId
?
this
.
onConnect
:
this
.
onConnectEx
;
if
(
this
.
context
.
active
&
&
event
.
fires
.
size
)
{
let
port
=
new
WorkerPort
(
this
.
context
portId
name
false
sender
)
;
this
.
portsById
.
set
(
{
port
.
portId
}
port
)
;
return
event
.
emit
(
port
)
.
length
;
}
}
}
class
ChildLocalWebIDLAPIImplementation
extends
ChildLocalAPIImplementation
{
constructor
(
pathObj
namespace
name
childApiManager
)
{
super
(
pathObj
namespace
name
childApiManager
)
;
this
.
childApiManager
=
childApiManager
;
}
createListenerForAPIRequest
(
request
)
{
return
this
.
pathObj
[
this
.
name
]
.
createListenerForAPIRequest
?
.
(
request
)
;
}
setProperty
(
)
{
throw
new
Error
(
"
Unexpected
call
to
setProperty
"
)
;
}
hasListener
(
listener
)
{
throw
new
Error
(
"
Unexpected
call
to
hasListener
"
)
;
}
}
class
ChildWebIDLObjectTypeImplementation
extends
ChildLocalWebIDLAPIImplementation
{
constructor
(
request
childApiManager
)
{
const
{
apiNamespace
apiName
apiObjectType
apiObjectId
}
=
request
;
const
api
=
childApiManager
.
getExtensionAPIInstance
(
apiNamespace
)
;
const
pathObj
=
api
.
getAPIObjectForRequest
?
.
(
childApiManager
.
context
request
)
;
if
(
!
pathObj
)
{
throw
new
Error
(
apiObject
instance
not
found
for
{
request
}
)
;
}
super
(
pathObj
apiNamespace
apiName
childApiManager
)
;
this
.
fullname
=
{
apiNamespace
}
.
{
apiObjectType
}
(
{
apiObjectId
}
)
.
{
apiName
}
;
}
}
class
WebIDLChildAPIManager
extends
ChildAPIManager
{
constructor
(
.
.
.
args
)
{
super
(
.
.
.
args
)
;
this
.
eventListenerWrappers
=
new
DefaultMap
(
(
)
=
>
new
WeakMap
(
)
)
;
}
getImplementation
(
namespace
name
)
{
this
.
apiCan
.
findAPIPath
(
{
namespace
}
.
{
name
}
)
;
let
obj
=
this
.
apiCan
.
findAPIPath
(
namespace
)
;
if
(
obj
&
&
name
in
obj
)
{
return
new
ChildLocalWebIDLAPIImplementation
(
obj
namespace
name
this
)
;
}
return
this
.
getFallbackImplementation
(
namespace
name
)
;
}
getImplementationForRequest
(
request
)
{
const
{
apiNamespace
apiName
apiObjectType
}
=
request
;
if
(
apiObjectType
)
{
return
new
ChildWebIDLObjectTypeImplementation
(
request
this
)
;
}
return
this
.
getImplementation
(
apiNamespace
apiName
)
;
}
handleWebIDLAPIRequest
(
request
)
{
try
{
const
impl
=
this
.
getImplementationForRequest
(
request
)
;
let
result
;
this
.
context
.
withAPIRequest
(
request
(
)
=
>
{
if
(
impl
instanceof
ProxyAPIImplementation
)
{
result
=
this
.
handleForProxyAPIImplementation
(
request
impl
)
;
}
else
{
result
=
this
.
callAPIImplementation
(
request
impl
)
;
}
}
)
;
return
{
type
:
Ci
.
mozIExtensionAPIRequestResult
.
RETURN_VALUE
value
:
result
}
;
}
catch
(
error
)
{
return
this
.
handleExtensionError
(
error
)
;
}
}
handleExtensionError
(
error
)
{
if
(
error
instanceof
this
.
context
.
Error
)
{
return
{
type
:
Ci
.
mozIExtensionAPIRequestResult
.
EXTENSION_ERROR
value
:
error
}
;
}
Cu
.
reportError
(
error
)
;
return
{
type
:
Ci
.
mozIExtensionAPIRequestResult
.
EXTENSION_ERROR
value
:
new
this
.
context
.
Error
(
"
An
unexpected
error
occurred
"
)
}
;
}
callAPIImplementation
(
request
impl
)
{
const
{
requestType
normalizedArgs
}
=
request
;
switch
(
requestType
)
{
case
"
callAsyncFunction
"
:
case
"
callFunction
"
:
case
"
callFunctionNoReturn
"
:
case
"
getProperty
"
:
return
impl
[
requestType
]
(
normalizedArgs
)
;
case
"
addListener
"
:
{
const
listener
=
this
.
getOrCreateListenerWrapper
(
request
impl
)
;
impl
.
addListener
(
listener
normalizedArgs
)
;
return
undefined
;
}
case
"
removeListener
"
:
{
const
listener
=
this
.
getListenerWrapper
(
request
)
;
if
(
listener
)
{
listener
.
_callOnClose
.
close
(
)
;
this
.
contet
.
forgetOnclose
(
listener
.
_callOnClose
)
;
this
.
forgetListenerWrapper
(
request
)
;
}
return
undefined
;
}
default
:
throw
new
Error
(
Unexpected
requestType
{
requestType
}
while
handling
"
{
request
}
"
)
;
}
}
handleForProxyAPIImplementation
(
request
impl
)
{
const
{
requestType
}
=
request
;
switch
(
requestType
)
{
case
"
callAsyncFunction
"
:
case
"
callFunctionNoReturn
"
:
case
"
addListener
"
:
case
"
removeListener
"
:
return
this
.
callAPIImplementation
(
request
impl
)
;
default
:
throw
new
Error
(
Unexpected
requestType
{
requestType
}
while
handling
"
{
request
}
"
)
;
}
}
getAPIPathForWebIDLRequest
(
request
)
{
const
{
apiNamespace
apiName
apiObjectType
}
=
request
;
if
(
apiObjectType
)
{
return
{
apiNamespace
}
.
{
apiObjectType
}
.
{
apiName
}
;
}
return
{
apiNamespace
}
.
{
apiName
}
;
}
getExtensionAPIInstance
(
namespace
)
{
return
this
.
apiCan
.
apis
.
get
(
namespace
)
;
}
getOrCreateListenerWrapper
(
request
impl
)
{
let
listener
=
this
.
getListenerWrapper
(
request
)
;
if
(
listener
)
{
return
listener
;
}
if
(
impl
instanceof
ChildLocalWebIDLAPIImplementation
)
{
listener
=
impl
.
createListenerForAPIRequest
(
request
)
;
}
const
{
eventListener
}
=
request
;
listener
=
listener
?
?
function
(
.
.
.
args
)
{
eventListener
.
callListener
(
args
)
;
}
;
listener
.
_callOnClose
=
{
close
:
(
)
=
>
{
this
.
eventListenerWrappers
.
delete
(
eventListener
)
;
try
{
impl
.
removeListener
(
listener
)
;
}
catch
(
err
)
{
if
(
impl
instanceof
ChildLocalWebIDLAPIImplementation
)
{
Cu
.
reportError
(
err
)
;
}
}
}
}
;
this
.
storeListenerWrapper
(
request
listener
)
;
this
.
context
.
callOnClose
(
listener
.
_callOnClose
)
;
return
listener
;
}
getListenerWrapper
(
request
)
{
const
{
eventListener
}
=
request
;
if
(
!
(
eventListener
instanceof
Ci
.
mozIExtensionEventListener
)
)
{
throw
new
Error
(
Unexpected
eventListener
type
for
request
:
{
request
}
)
;
}
const
apiPath
=
this
.
getAPIPathForWebIDLRequest
(
request
)
;
if
(
!
this
.
eventListenerWrappers
.
has
(
apiPath
)
)
{
return
undefined
;
}
return
this
.
eventListenerWrappers
.
get
(
apiPath
)
.
get
(
eventListener
)
;
}
storeListenerWrapper
(
request
listener
)
{
const
{
eventListener
}
=
request
;
if
(
!
(
eventListener
instanceof
Ci
.
mozIExtensionEventListener
)
)
{
throw
new
Error
(
Missing
eventListener
for
request
:
{
request
}
)
;
}
const
apiPath
=
this
.
getAPIPathForWebIDLRequest
(
request
)
;
this
.
eventListenerWrappers
.
get
(
apiPath
)
.
set
(
eventListener
listener
)
;
}
forgetListenerWrapper
(
request
)
{
const
{
eventListener
}
=
request
;
if
(
!
(
eventListener
instanceof
Ci
.
mozIExtensionEventListener
)
)
{
throw
new
Error
(
Missing
eventListener
for
request
:
{
request
}
)
;
}
const
apiPath
=
this
.
getAPIPathForWebIDLRequest
(
request
)
;
if
(
this
.
eventListenerWrappers
.
has
(
apiPath
)
)
{
this
.
eventListenerWrappers
.
get
(
apiPath
)
.
delete
(
eventListener
)
;
}
}
}
class
WorkerContextChild
extends
BaseContext
{
constructor
(
extension
{
serviceWorkerInfo
}
)
{
if
(
!
serviceWorkerInfo
?
.
scriptURL
|
|
!
serviceWorkerInfo
?
.
clientInfoId
|
|
!
serviceWorkerInfo
?
.
principal
)
{
throw
new
Error
(
"
Missing
or
invalid
serviceWorkerInfo
"
)
;
}
super
(
"
addon_child
"
extension
)
;
this
.
viewType
=
"
background_worker
"
;
this
.
uri
=
Services
.
io
.
newURI
(
serviceWorkerInfo
.
scriptURL
)
;
this
.
workerClientInfoId
=
serviceWorkerInfo
.
clientInfoId
;
this
.
workerDescriptorId
=
serviceWorkerInfo
.
descriptorId
;
this
.
workerPrincipal
=
serviceWorkerInfo
.
principal
;
this
.
incognito
=
serviceWorkerInfo
.
principal
.
privateBrowsingId
>
0
;
this
.
webidlAPIRequest
=
null
;
this
.
workerCloneScope
=
{
Promise
Error
:
ExtensionUtils
.
WorkerExtensionError
}
;
}
openConduit
(
subject
address
)
{
let
proc
=
ChromeUtils
.
domProcessChild
;
let
conduit
=
proc
.
getActor
(
"
ProcessConduits
"
)
.
openConduit
(
subject
{
id
:
subject
.
id
|
|
getUniqueId
(
)
extensionId
:
this
.
extension
.
id
envType
:
this
.
envType
workerScriptURL
:
this
.
uri
.
spec
.
.
.
address
}
)
;
this
.
callOnClose
(
conduit
)
;
conduit
.
setCloseCallback
(
(
)
=
>
{
this
.
forgetOnClose
(
conduit
)
;
}
)
;
return
conduit
;
}
notifyWorkerLoaded
(
)
{
this
.
childManager
.
conduit
.
sendContextLoaded
(
{
childId
:
this
.
childManager
.
id
extensionId
:
this
.
extension
.
id
}
)
;
}
withAPIRequest
(
request
callable
)
{
this
.
webidlAPIRequest
=
request
;
try
{
return
callable
(
)
;
}
finally
{
this
.
webidlAPIRequest
=
null
;
}
}
getAPIRequest
(
)
{
return
this
.
webidlAPIRequest
;
}
getCaller
(
)
{
return
this
.
webidlAPIRequest
?
.
callerSavedFrame
;
}
logActivity
(
type
name
data
)
{
ExtensionActivityLogChild
.
log
(
this
type
name
data
)
;
}
get
cloneScope
(
)
{
return
this
.
workerCloneScope
;
}
get
principal
(
)
{
return
this
.
workerPrincipal
;
}
get
tabId
(
)
{
return
-
1
;
}
get
useWebIDLBindings
(
)
{
return
true
;
}
shutdown
(
)
{
this
.
unload
(
)
;
}
unload
(
)
{
if
(
this
.
unloaded
)
{
return
;
}
super
.
unload
(
)
;
}
}
defineLazyGetter
(
WorkerContextChild
.
prototype
"
messenger
"
function
(
)
{
return
new
WorkerMessenger
(
this
)
;
}
)
;
defineLazyGetter
(
WorkerContextChild
.
prototype
"
childManager
"
getContextChildManagerGetter
(
{
envType
:
"
addon_parent
"
}
WebIDLChildAPIManager
)
)
;
var
ExtensionWorkerChild
=
{
extensionWorkerContexts
:
new
Map
(
)
apiManager
:
ExtensionPageChild
.
apiManager
initExtensionWorkerContext
(
extension
serviceWorkerInfo
)
{
if
(
!
WebExtensionPolicy
.
isExtensionProcess
)
{
throw
new
Error
(
"
Cannot
create
an
extension
worker
context
in
current
process
"
)
;
}
const
swId
=
serviceWorkerInfo
.
descriptorId
;
let
context
=
this
.
extensionWorkerContexts
.
get
(
swId
)
;
if
(
context
)
{
if
(
context
.
extension
!
=
=
extension
)
{
throw
new
Error
(
"
A
different
extension
context
already
exists
for
this
service
worker
"
)
;
}
throw
new
Error
(
"
An
extension
context
was
already
initialized
for
this
service
worker
"
)
;
}
context
=
new
WorkerContextChild
(
extension
{
serviceWorkerInfo
}
)
;
this
.
extensionWorkerContexts
.
set
(
swId
context
)
;
}
getExtensionWorkerContext
(
extension
serviceWorkerInfo
)
{
if
(
!
serviceWorkerInfo
)
{
return
null
;
}
const
context
=
this
.
extensionWorkerContexts
.
get
(
serviceWorkerInfo
.
descriptorId
)
;
if
(
context
?
.
extension
=
=
=
extension
)
{
return
context
;
}
return
null
;
}
notifyExtensionWorkerContextLoaded
(
descriptorId
policy
)
{
let
context
=
this
.
extensionWorkerContexts
.
get
(
descriptorId
)
;
if
(
context
)
{
if
(
context
.
extension
.
id
!
=
=
policy
.
id
)
{
Cu
.
reportError
(
new
Error
(
ServiceWorker
{
descriptorId
}
does
not
belong
to
the
expected
extension
:
{
policy
.
id
}
)
)
;
return
;
}
context
.
notifyWorkerLoaded
(
)
;
}
}
destroyExtensionWorkerContext
(
descriptorId
)
{
let
context
=
this
.
extensionWorkerContexts
.
get
(
descriptorId
)
;
if
(
context
)
{
context
.
unload
(
)
;
this
.
extensionWorkerContexts
.
delete
(
descriptorId
)
;
}
}
shutdownExtension
(
extensionId
)
{
for
(
let
[
workerClientInfoId
context
]
of
this
.
extensionWorkerContexts
)
{
if
(
context
.
extension
.
id
=
=
extensionId
)
{
context
.
shutdown
(
)
;
this
.
extensionWorkerContexts
.
delete
(
workerClientInfoId
)
;
}
}
}
}
;
