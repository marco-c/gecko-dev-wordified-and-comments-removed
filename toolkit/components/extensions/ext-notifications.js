"
use
strict
"
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
EventEmitter
"
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
var
{
EventManager
ignoreEvent
}
=
ExtensionUtils
;
var
notificationsMap
=
new
WeakMap
(
)
;
function
Notification
(
extension
id
options
)
{
this
.
extension
=
extension
;
this
.
id
=
id
;
this
.
options
=
options
;
let
imageURL
;
if
(
options
.
iconUrl
)
{
imageURL
=
this
.
extension
.
baseURI
.
resolve
(
options
.
iconUrl
)
;
}
try
{
let
svc
=
Cc
[
"
mozilla
.
org
/
alerts
-
service
;
1
"
]
.
getService
(
Ci
.
nsIAlertsService
)
;
svc
.
showAlertNotification
(
imageURL
options
.
title
options
.
message
true
this
.
id
this
this
.
id
)
;
}
catch
(
e
)
{
}
}
Notification
.
prototype
=
{
clear
(
)
{
try
{
let
svc
=
Cc
[
"
mozilla
.
org
/
alerts
-
service
;
1
"
]
.
getService
(
Ci
.
nsIAlertsService
)
;
svc
.
closeAlert
(
this
.
id
)
;
}
catch
(
e
)
{
}
notificationsMap
.
get
(
this
.
extension
)
.
delete
(
this
.
id
)
;
}
observe
(
subject
topic
data
)
{
let
notifications
=
notificationsMap
.
get
(
this
.
extension
)
;
let
emitAndDelete
=
event
=
>
{
notifications
.
emit
(
event
data
)
;
notifications
.
delete
(
this
.
id
)
;
}
;
if
(
!
notifications
)
{
return
;
}
if
(
topic
=
=
=
"
alertclickcallback
"
)
{
emitAndDelete
(
"
clicked
"
)
;
}
if
(
topic
=
=
=
"
alertfinished
"
)
{
emitAndDelete
(
"
closed
"
)
;
}
}
}
;
extensions
.
on
(
"
startup
"
(
type
extension
)
=
>
{
let
map
=
new
Map
(
)
;
EventEmitter
.
decorate
(
map
)
;
notificationsMap
.
set
(
extension
map
)
;
}
)
;
extensions
.
on
(
"
shutdown
"
(
type
extension
)
=
>
{
if
(
notificationsMap
.
has
(
extension
)
)
{
for
(
let
notification
of
notificationsMap
.
get
(
extension
)
.
values
(
)
)
{
notification
.
clear
(
)
;
}
notificationsMap
.
delete
(
extension
)
;
}
}
)
;
var
nextId
=
0
;
extensions
.
registerSchemaAPI
(
"
notifications
"
context
=
>
{
let
{
extension
}
=
context
;
return
{
notifications
:
{
create
:
function
(
notificationId
options
)
{
if
(
!
notificationId
)
{
notificationId
=
String
(
nextId
+
+
)
;
}
let
notifications
=
notificationsMap
.
get
(
extension
)
;
if
(
notifications
.
has
(
notificationId
)
)
{
notifications
.
get
(
notificationId
)
.
clear
(
)
;
}
let
notification
=
new
Notification
(
extension
notificationId
options
)
;
notificationsMap
.
get
(
extension
)
.
set
(
notificationId
notification
)
;
return
Promise
.
resolve
(
notificationId
)
;
}
clear
:
function
(
notificationId
)
{
let
notifications
=
notificationsMap
.
get
(
extension
)
;
if
(
notifications
.
has
(
notificationId
)
)
{
notifications
.
get
(
notificationId
)
.
clear
(
)
;
return
Promise
.
resolve
(
true
)
;
}
return
Promise
.
resolve
(
false
)
;
}
getAll
:
function
(
)
{
let
result
=
{
}
;
notificationsMap
.
get
(
extension
)
.
forEach
(
(
value
key
)
=
>
{
result
[
key
]
=
value
.
options
;
}
)
;
return
Promise
.
resolve
(
result
)
;
}
onClosed
:
new
EventManager
(
context
"
notifications
.
onClosed
"
fire
=
>
{
let
listener
=
(
event
notificationId
)
=
>
{
fire
(
notificationId
true
)
;
}
;
notificationsMap
.
get
(
extension
)
.
on
(
"
closed
"
listener
)
;
return
(
)
=
>
{
notificationsMap
.
get
(
extension
)
.
off
(
"
closed
"
listener
)
;
}
;
}
)
.
api
(
)
onClicked
:
new
EventManager
(
context
"
notifications
.
onClicked
"
fire
=
>
{
let
listener
=
(
event
notificationId
)
=
>
{
fire
(
notificationId
true
)
;
}
;
notificationsMap
.
get
(
extension
)
.
on
(
"
clicked
"
listener
)
;
return
(
)
=
>
{
notificationsMap
.
get
(
extension
)
.
off
(
"
clicked
"
listener
)
;
}
;
}
)
.
api
(
)
onButtonClicked
:
ignoreEvent
(
context
"
notifications
.
onButtonClicked
"
)
}
}
;
}
)
;
