"
use
strict
"
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
const
global
=
this
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
DefaultMap
instanceOf
}
=
ExtensionUtils
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
contentPolicyService
"
"
mozilla
.
org
/
addons
/
content
-
policy
;
1
"
"
nsIAddonContentPolicy
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
Schemas
"
]
;
const
{
DEBUG
}
=
AppConstants
;
function
readJSON
(
url
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
NetUtil
.
asyncFetch
(
{
uri
:
url
loadUsingSystemPrincipal
:
true
}
(
inputStream
status
)
=
>
{
if
(
!
Components
.
isSuccessCode
(
status
)
)
{
let
e
=
Components
.
Exception
(
"
"
status
)
;
reject
(
new
Error
(
Error
while
loading
'
{
url
}
'
(
{
e
.
name
}
)
)
)
;
return
;
}
try
{
let
text
=
NetUtil
.
readInputStreamToString
(
inputStream
inputStream
.
available
(
)
)
;
let
index
=
text
.
indexOf
(
"
[
"
)
;
text
=
text
.
slice
(
index
)
;
resolve
(
JSON
.
parse
(
text
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
;
}
)
;
}
function
exportLazyGetter
(
object
prop
getter
)
{
object
=
Cu
.
waiveXrays
(
object
)
;
let
redefine
=
value
=
>
{
if
(
value
=
=
=
undefined
)
{
delete
object
[
prop
]
;
}
else
{
Object
.
defineProperty
(
object
prop
{
enumerable
:
true
configurable
:
true
writable
:
true
value
}
)
;
}
getter
=
null
;
return
value
;
}
;
Object
.
defineProperty
(
object
prop
{
enumerable
:
true
configurable
:
true
get
:
Cu
.
exportFunction
(
function
(
)
{
return
redefine
(
getter
.
call
(
this
)
)
;
}
object
)
set
:
Cu
.
exportFunction
(
value
=
>
{
redefine
(
value
)
;
}
object
)
}
)
;
}
function
exportLazyProperty
(
object
prop
getter
)
{
object
=
Cu
.
waiveXrays
(
object
)
;
let
redefine
=
obj
=
>
{
let
desc
=
getter
.
call
(
obj
)
;
if
(
desc
=
=
=
undefined
)
{
delete
object
[
prop
]
;
}
else
{
let
defaults
=
{
configurable
:
true
enumerable
:
true
}
;
if
(
!
desc
.
set
&
&
!
desc
.
get
)
{
defaults
.
writable
=
true
;
}
Object
.
defineProperty
(
object
prop
Object
.
assign
(
defaults
desc
)
)
;
}
getter
=
null
;
}
;
Object
.
defineProperty
(
object
prop
{
enumerable
:
true
configurable
:
true
get
:
Cu
.
exportFunction
(
function
(
)
{
redefine
(
this
)
;
return
object
[
prop
]
;
}
object
)
set
:
Cu
.
exportFunction
(
function
(
value
)
{
redefine
(
this
)
;
object
[
prop
]
=
value
;
}
object
)
}
)
;
}
const
POSTPROCESSORS
=
{
convertImageDataToURL
(
imageData
context
)
{
let
document
=
context
.
cloneScope
.
document
;
let
canvas
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
imageData
.
width
;
canvas
.
height
=
imageData
.
height
;
canvas
.
getContext
(
"
2d
"
)
.
putImageData
(
imageData
0
0
)
;
return
canvas
.
toDataURL
(
"
image
/
png
"
)
;
}
}
;
function
parsePattern
(
pattern
)
{
let
flags
=
"
"
;
let
match
=
/
^
\
(
\
?
(
[
im
]
*
)
\
)
(
.
*
)
/
.
exec
(
pattern
)
;
if
(
match
)
{
[
flags
pattern
]
=
match
;
}
return
new
RegExp
(
pattern
flags
)
;
}
function
getValueBaseType
(
value
)
{
let
t
=
typeof
(
value
)
;
if
(
t
=
=
"
object
"
)
{
if
(
value
=
=
=
null
)
{
return
"
null
"
;
}
else
if
(
Array
.
isArray
(
value
)
)
{
return
"
array
"
;
}
else
if
(
Object
.
prototype
.
toString
.
call
(
value
)
=
=
"
[
object
ArrayBuffer
]
"
)
{
return
"
binary
"
;
}
}
else
if
(
t
=
=
"
number
"
)
{
if
(
value
%
1
=
=
0
)
{
return
"
integer
"
;
}
}
return
t
;
}
const
CONTEXT_FOR_VALIDATION
=
[
"
checkLoadURL
"
"
hasPermission
"
"
logError
"
]
;
const
CONTEXT_FOR_INJECTION
=
[
.
.
.
CONTEXT_FOR_VALIDATION
"
shouldInject
"
"
getImplementation
"
]
;
class
Context
{
constructor
(
params
overridableMethods
=
CONTEXT_FOR_VALIDATION
)
{
this
.
params
=
params
;
this
.
path
=
[
]
;
this
.
preprocessors
=
{
localize
(
value
context
)
{
return
value
;
}
}
;
this
.
postprocessors
=
POSTPROCESSORS
;
this
.
isChromeCompat
=
false
;
this
.
currentChoices
=
new
Set
(
)
;
this
.
choicePathIndex
=
0
;
for
(
let
method
of
overridableMethods
)
{
if
(
method
in
params
)
{
this
[
method
]
=
params
[
method
]
.
bind
(
params
)
;
}
}
let
props
=
[
"
preprocessors
"
"
isChromeCompat
"
]
;
for
(
let
prop
of
props
)
{
if
(
prop
in
params
)
{
if
(
prop
in
this
&
&
typeof
this
[
prop
]
=
=
"
object
"
)
{
Object
.
assign
(
this
[
prop
]
params
[
prop
]
)
;
}
else
{
this
[
prop
]
=
params
[
prop
]
;
}
}
}
}
get
choicePath
(
)
{
let
path
=
this
.
path
.
slice
(
this
.
choicePathIndex
)
;
return
path
.
join
(
"
.
"
)
;
}
get
cloneScope
(
)
{
return
this
.
params
.
cloneScope
;
}
get
url
(
)
{
return
this
.
params
.
url
;
}
get
principal
(
)
{
return
this
.
params
.
principal
|
|
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
}
)
;
}
checkLoadURL
(
url
)
{
let
ssm
=
Services
.
scriptSecurityManager
;
try
{
ssm
.
checkLoadURIStrWithPrincipal
(
this
.
principal
url
ssm
.
DISALLOW_INHERIT_PRINCIPAL
)
;
}
catch
(
e
)
{
return
false
;
}
return
true
;
}
hasPermission
(
permission
)
{
return
false
;
}
error
(
errorMessage
choicesMessage
=
undefined
)
{
if
(
choicesMessage
!
=
=
null
)
{
let
{
choicePath
}
=
this
;
if
(
choicePath
)
{
choicesMessage
=
.
{
choicePath
}
must
{
choicesMessage
}
;
}
this
.
currentChoices
.
add
(
choicesMessage
)
;
}
if
(
this
.
currentTarget
)
{
return
{
error
:
Error
processing
{
this
.
currentTarget
}
:
{
errorMessage
}
}
;
}
return
{
error
:
errorMessage
}
;
}
makeError
(
message
)
{
let
{
error
}
=
this
.
error
(
message
)
;
if
(
this
.
cloneScope
)
{
return
new
this
.
cloneScope
.
Error
(
error
)
;
}
return
error
;
}
logError
(
error
)
{
Cu
.
reportError
(
error
)
;
}
get
currentTarget
(
)
{
return
this
.
path
.
join
(
"
.
"
)
;
}
withChoices
(
callback
)
{
let
{
currentChoices
choicePathIndex
}
=
this
;
let
choices
=
new
Set
(
)
;
this
.
currentChoices
=
choices
;
this
.
choicePathIndex
=
this
.
path
.
length
;
try
{
let
result
=
callback
(
)
;
return
{
result
choices
:
Array
.
from
(
choices
)
}
;
}
finally
{
this
.
currentChoices
=
currentChoices
;
this
.
choicePathIndex
=
choicePathIndex
;
choices
=
Array
.
from
(
choices
)
;
if
(
choices
.
length
=
=
1
)
{
currentChoices
.
add
(
choices
[
0
]
)
;
}
else
if
(
choices
.
length
)
{
let
n
=
choices
.
length
-
1
;
choices
[
n
]
=
or
{
choices
[
n
]
}
;
this
.
error
(
null
must
either
[
{
choices
.
join
(
"
"
)
}
]
)
;
}
}
}
withPath
(
component
callback
)
{
this
.
path
.
push
(
component
)
;
try
{
return
callback
(
)
;
}
finally
{
this
.
path
.
pop
(
)
;
}
}
}
class
InjectionContext
extends
Context
{
constructor
(
params
)
{
super
(
params
CONTEXT_FOR_INJECTION
)
;
}
shouldInject
(
namespace
name
allowedContexts
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getImplementation
(
namespace
name
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
const
FORMATS
=
{
url
(
string
context
)
{
let
url
=
new
URL
(
string
)
.
href
;
if
(
!
context
.
checkLoadURL
(
url
)
)
{
throw
new
Error
(
Access
denied
for
URL
{
url
}
)
;
}
return
url
;
}
relativeUrl
(
string
context
)
{
if
(
!
context
.
url
)
{
try
{
new
URL
(
string
)
;
}
catch
(
e
)
{
return
string
;
}
}
let
url
=
new
URL
(
string
context
.
url
)
.
href
;
if
(
!
context
.
checkLoadURL
(
url
)
)
{
throw
new
Error
(
Access
denied
for
URL
{
url
}
)
;
}
return
url
;
}
strictRelativeUrl
(
string
context
)
{
if
(
!
string
.
startsWith
(
"
/
/
"
)
)
{
try
{
new
URL
(
string
)
;
}
catch
(
e
)
{
return
FORMATS
.
relativeUrl
(
string
context
)
;
}
}
throw
new
SyntaxError
(
String
{
JSON
.
stringify
(
string
)
}
must
be
a
relative
URL
)
;
}
contentSecurityPolicy
(
string
context
)
{
let
error
=
contentPolicyService
.
validateAddonCSP
(
string
)
;
if
(
error
!
=
null
)
{
throw
new
SyntaxError
(
error
)
;
}
return
string
;
}
date
(
string
context
)
{
const
PATTERN
=
/
^
\
d
{
4
}
-
\
d
{
2
}
-
\
d
{
2
}
(
T
\
d
{
2
}
:
\
d
{
2
}
:
\
d
{
2
}
(
\
.
\
d
{
3
}
)
?
(
Z
|
(
[
-
+
]
\
d
{
2
}
:
?
\
d
{
2
}
)
)
)
?
/
;
if
(
!
PATTERN
.
test
(
string
)
)
{
throw
new
Error
(
Invalid
date
string
{
string
}
)
;
}
if
(
isNaN
(
new
Date
(
string
)
)
)
{
throw
new
Error
(
Invalid
date
string
{
string
}
)
;
}
return
string
;
}
}
;
class
Entry
{
constructor
(
schema
=
{
}
)
{
this
.
deprecated
=
false
;
if
(
"
deprecated
"
in
schema
)
{
this
.
deprecated
=
schema
.
deprecated
;
}
this
.
preprocessor
=
schema
.
preprocess
|
|
null
;
this
.
postprocessor
=
schema
.
postprocess
|
|
null
;
this
.
allowedContexts
=
schema
.
allowedContexts
|
|
[
]
;
}
preprocess
(
value
context
)
{
if
(
this
.
preprocessor
)
{
return
context
.
preprocessors
[
this
.
preprocessor
]
(
value
context
)
;
}
return
value
;
}
postprocess
(
result
context
)
{
if
(
result
.
error
|
|
!
this
.
postprocessor
)
{
return
result
;
}
let
value
=
context
.
postprocessors
[
this
.
postprocessor
]
(
result
.
value
context
)
;
return
{
value
}
;
}
logDeprecation
(
context
value
=
null
)
{
let
message
=
"
This
property
is
deprecated
"
;
if
(
typeof
(
this
.
deprecated
)
=
=
"
string
"
)
{
message
=
this
.
deprecated
;
if
(
message
.
includes
(
"
{
value
}
"
)
)
{
try
{
value
=
JSON
.
stringify
(
value
)
;
}
catch
(
e
)
{
value
=
String
(
value
)
;
}
message
=
message
.
replace
(
/
\
\
{
value
\
}
/
g
(
)
=
>
value
)
;
}
}
context
.
logError
(
context
.
makeError
(
message
)
)
;
}
checkDeprecated
(
context
value
=
null
)
{
if
(
this
.
deprecated
)
{
this
.
logDeprecation
(
context
value
)
;
}
}
getDescriptor
(
path
context
)
{
return
undefined
;
}
}
class
Type
extends
Entry
{
static
get
EXTRA_PROPERTIES
(
)
{
return
[
"
description
"
"
deprecated
"
"
preprocess
"
"
postprocess
"
"
allowedContexts
"
]
;
}
static
parseSchema
(
schema
path
extraProperties
=
[
]
)
{
this
.
checkSchemaProperties
(
schema
path
extraProperties
)
;
return
new
this
(
schema
)
;
}
static
checkSchemaProperties
(
schema
path
extra
=
[
]
)
{
if
(
DEBUG
)
{
let
allowedSet
=
new
Set
(
[
.
.
.
this
.
EXTRA_PROPERTIES
.
.
.
extra
]
)
;
for
(
let
prop
of
Object
.
keys
(
schema
)
)
{
if
(
!
allowedSet
.
has
(
prop
)
)
{
throw
new
Error
(
Internal
error
:
Namespace
{
path
.
join
(
"
.
"
)
}
has
+
invalid
type
property
"
{
prop
}
"
+
in
type
"
{
schema
.
id
|
|
JSON
.
stringify
(
schema
)
}
"
)
;
}
}
}
}
normalize
(
value
context
)
{
return
context
.
error
(
"
invalid
type
"
)
;
}
checkBaseType
(
baseType
)
{
return
false
;
}
normalizeBase
(
type
value
context
)
{
if
(
this
.
checkBaseType
(
getValueBaseType
(
value
)
)
)
{
this
.
checkDeprecated
(
context
value
)
;
return
{
value
:
this
.
preprocess
(
value
context
)
}
;
}
let
choice
;
if
(
/
^
[
aeiou
]
/
.
test
(
type
)
)
{
choice
=
be
an
{
type
}
value
;
}
else
{
choice
=
be
a
{
type
}
value
;
}
return
context
.
error
(
Expected
{
type
}
instead
of
{
JSON
.
stringify
(
value
)
}
choice
)
;
}
}
class
AnyType
extends
Type
{
normalize
(
value
context
)
{
this
.
checkDeprecated
(
context
value
)
;
return
this
.
postprocess
(
{
value
}
context
)
;
}
checkBaseType
(
baseType
)
{
return
true
;
}
}
class
ChoiceType
extends
Type
{
static
get
EXTRA_PROPERTIES
(
)
{
return
[
"
choices
"
.
.
.
super
.
EXTRA_PROPERTIES
]
;
}
static
parseSchema
(
schema
path
extraProperties
=
[
]
)
{
this
.
checkSchemaProperties
(
schema
path
extraProperties
)
;
let
choices
=
schema
.
choices
.
map
(
t
=
>
Schemas
.
parseSchema
(
t
path
)
)
;
return
new
this
(
schema
choices
)
;
}
constructor
(
schema
choices
)
{
super
(
schema
)
;
this
.
choices
=
choices
;
}
extend
(
type
)
{
this
.
choices
.
push
(
.
.
.
type
.
choices
)
;
return
this
;
}
normalize
(
value
context
)
{
this
.
checkDeprecated
(
context
value
)
;
let
error
;
let
{
choices
result
}
=
context
.
withChoices
(
(
)
=
>
{
for
(
let
choice
of
this
.
choices
)
{
let
r
=
choice
.
normalize
(
value
context
)
;
if
(
!
r
.
error
)
{
return
r
;
}
error
=
r
;
}
}
)
;
if
(
result
)
{
return
result
;
}
if
(
choices
.
length
<
=
1
)
{
return
error
;
}
let
n
=
choices
.
length
-
1
;
choices
[
n
]
=
or
{
choices
[
n
]
}
;
let
message
=
Value
must
either
:
{
choices
.
join
(
"
"
)
}
;
return
context
.
error
(
message
null
)
;
}
checkBaseType
(
baseType
)
{
return
this
.
choices
.
some
(
t
=
>
t
.
checkBaseType
(
baseType
)
)
;
}
}
class
RefType
extends
Type
{
static
get
EXTRA_PROPERTIES
(
)
{
return
[
"
ref
"
.
.
.
super
.
EXTRA_PROPERTIES
]
;
}
static
parseSchema
(
schema
path
extraProperties
=
[
]
)
{
this
.
checkSchemaProperties
(
schema
path
extraProperties
)
;
let
ref
=
schema
.
ref
;
let
ns
=
path
[
0
]
;
if
(
ref
.
includes
(
"
.
"
)
)
{
[
ns
ref
]
=
ref
.
split
(
"
.
"
)
;
}
return
new
this
(
schema
ns
ref
)
;
}
constructor
(
schema
namespaceName
reference
)
{
super
(
schema
)
;
this
.
namespaceName
=
namespaceName
;
this
.
reference
=
reference
;
}
get
targetType
(
)
{
let
ns
=
Schemas
.
getNamespace
(
this
.
namespaceName
)
;
let
type
=
ns
.
get
(
this
.
reference
)
;
if
(
!
type
)
{
throw
new
Error
(
Internal
error
:
Type
{
this
.
reference
}
not
found
)
;
}
return
type
;
}
normalize
(
value
context
)
{
this
.
checkDeprecated
(
context
value
)
;
return
this
.
targetType
.
normalize
(
value
context
)
;
}
checkBaseType
(
baseType
)
{
return
this
.
targetType
.
checkBaseType
(
baseType
)
;
}
}
class
StringType
extends
Type
{
static
get
EXTRA_PROPERTIES
(
)
{
return
[
"
enum
"
"
minLength
"
"
maxLength
"
"
pattern
"
"
format
"
.
.
.
super
.
EXTRA_PROPERTIES
]
;
}
static
parseSchema
(
schema
path
extraProperties
=
[
]
)
{
this
.
checkSchemaProperties
(
schema
path
extraProperties
)
;
let
enumeration
=
schema
.
enum
|
|
null
;
if
(
enumeration
)
{
enumeration
=
enumeration
.
map
(
e
=
>
{
if
(
typeof
(
e
)
=
=
"
object
"
)
{
return
e
.
name
;
}
return
e
;
}
)
;
}
let
pattern
=
null
;
if
(
schema
.
pattern
)
{
try
{
pattern
=
parsePattern
(
schema
.
pattern
)
;
}
catch
(
e
)
{
throw
new
Error
(
Internal
error
:
Invalid
pattern
{
JSON
.
stringify
(
schema
.
pattern
)
}
)
;
}
}
let
format
=
null
;
if
(
schema
.
format
)
{
if
(
!
(
schema
.
format
in
FORMATS
)
)
{
throw
new
Error
(
Internal
error
:
Invalid
string
format
{
schema
.
format
}
)
;
}
format
=
FORMATS
[
schema
.
format
]
;
}
return
new
this
(
schema
schema
.
id
enumeration
schema
.
minLength
|
|
0
schema
.
maxLength
|
|
Infinity
pattern
format
)
;
}
constructor
(
schema
name
enumeration
minLength
maxLength
pattern
format
)
{
super
(
schema
)
;
this
.
name
=
name
;
this
.
enumeration
=
enumeration
;
this
.
minLength
=
minLength
;
this
.
maxLength
=
maxLength
;
this
.
pattern
=
pattern
;
this
.
format
=
format
;
}
normalize
(
value
context
)
{
let
r
=
this
.
normalizeBase
(
"
string
"
value
context
)
;
if
(
r
.
error
)
{
return
r
;
}
value
=
r
.
value
;
if
(
this
.
enumeration
)
{
if
(
this
.
enumeration
.
includes
(
value
)
)
{
return
this
.
postprocess
(
{
value
}
context
)
;
}
let
choices
=
this
.
enumeration
.
map
(
JSON
.
stringify
)
.
join
(
"
"
)
;
return
context
.
error
(
Invalid
enumeration
value
{
JSON
.
stringify
(
value
)
}
be
one
of
[
{
choices
}
]
)
;
}
if
(
value
.
length
<
this
.
minLength
)
{
return
context
.
error
(
String
{
JSON
.
stringify
(
value
)
}
is
too
short
(
must
be
{
this
.
minLength
}
)
be
longer
than
{
this
.
minLength
}
)
;
}
if
(
value
.
length
>
this
.
maxLength
)
{
return
context
.
error
(
String
{
JSON
.
stringify
(
value
)
}
is
too
long
(
must
be
{
this
.
maxLength
}
)
be
shorter
than
{
this
.
maxLength
}
)
;
}
if
(
this
.
pattern
&
&
!
this
.
pattern
.
test
(
value
)
)
{
return
context
.
error
(
String
{
JSON
.
stringify
(
value
)
}
must
match
{
this
.
pattern
}
match
the
pattern
{
this
.
pattern
.
toSource
(
)
}
)
;
}
if
(
this
.
format
)
{
try
{
r
.
value
=
this
.
format
(
r
.
value
context
)
;
}
catch
(
e
)
{
return
context
.
error
(
String
(
e
)
match
the
format
"
{
this
.
format
.
name
}
"
)
;
}
}
return
r
;
}
checkBaseType
(
baseType
)
{
return
baseType
=
=
"
string
"
;
}
getDescriptor
(
path
context
)
{
if
(
this
.
enumeration
)
{
let
obj
=
Cu
.
createObjectIn
(
context
.
cloneScope
)
;
for
(
let
e
of
this
.
enumeration
)
{
obj
[
e
.
toUpperCase
(
)
]
=
e
;
}
return
{
value
:
obj
}
;
}
}
}
let
FunctionEntry
;
let
SubModuleType
;
class
ObjectType
extends
Type
{
static
get
EXTRA_PROPERTIES
(
)
{
return
[
"
properties
"
"
patternProperties
"
.
.
.
super
.
EXTRA_PROPERTIES
]
;
}
static
parseSchema
(
schema
path
extraProperties
=
[
]
)
{
if
(
"
functions
"
in
schema
)
{
return
SubModuleType
.
parseSchema
(
schema
path
extraProperties
)
;
}
if
(
DEBUG
&
&
!
(
"
extend
"
in
schema
)
)
{
extraProperties
=
[
"
additionalProperties
"
"
isInstanceOf
"
.
.
.
extraProperties
]
;
}
this
.
checkSchemaProperties
(
schema
path
extraProperties
)
;
let
parseProperty
=
(
schema
extraProps
=
[
]
)
=
>
{
return
{
type
:
Schemas
.
parseSchema
(
schema
path
DEBUG
&
&
[
"
unsupported
"
"
onError
"
"
permissions
"
.
.
.
extraProps
]
)
optional
:
schema
.
optional
|
|
false
unsupported
:
schema
.
unsupported
|
|
false
onError
:
schema
.
onError
|
|
null
}
;
}
;
let
properties
=
Object
.
create
(
null
)
;
for
(
let
propName
of
Object
.
keys
(
schema
.
properties
|
|
{
}
)
)
{
properties
[
propName
]
=
parseProperty
(
schema
.
properties
[
propName
]
[
"
optional
"
]
)
;
}
let
patternProperties
=
[
]
;
for
(
let
propName
of
Object
.
keys
(
schema
.
patternProperties
|
|
{
}
)
)
{
let
pattern
;
try
{
pattern
=
parsePattern
(
propName
)
;
}
catch
(
e
)
{
throw
new
Error
(
Internal
error
:
Invalid
property
pattern
{
JSON
.
stringify
(
propName
)
}
)
;
}
patternProperties
.
push
(
{
pattern
type
:
parseProperty
(
schema
.
patternProperties
[
propName
]
)
}
)
;
}
let
additionalProperties
=
null
;
if
(
schema
.
additionalProperties
)
{
let
type
=
schema
.
additionalProperties
;
if
(
type
=
=
=
true
)
{
type
=
{
"
type
"
:
"
any
"
}
;
}
additionalProperties
=
Schemas
.
parseSchema
(
type
path
)
;
}
return
new
this
(
schema
properties
additionalProperties
patternProperties
schema
.
isInstanceOf
|
|
null
)
;
}
constructor
(
schema
properties
additionalProperties
patternProperties
isInstanceOf
)
{
super
(
schema
)
;
this
.
properties
=
properties
;
this
.
additionalProperties
=
additionalProperties
;
this
.
patternProperties
=
patternProperties
;
this
.
isInstanceOf
=
isInstanceOf
;
}
extend
(
type
)
{
for
(
let
key
of
Object
.
keys
(
type
.
properties
)
)
{
if
(
key
in
this
.
properties
)
{
throw
new
Error
(
InternalError
:
Attempt
to
extend
an
object
with
conflicting
property
"
{
key
}
"
)
;
}
this
.
properties
[
key
]
=
type
.
properties
[
key
]
;
}
this
.
patternProperties
.
push
(
.
.
.
type
.
patternProperties
)
;
return
this
;
}
checkBaseType
(
baseType
)
{
return
baseType
=
=
"
object
"
;
}
extractProperties
(
value
context
)
{
let
klass
=
Cu
.
getClassName
(
value
true
)
;
if
(
klass
!
=
"
Object
"
)
{
throw
context
.
error
(
Expected
a
plain
JavaScript
object
got
a
{
klass
}
be
a
plain
JavaScript
object
)
;
}
let
properties
=
Object
.
create
(
null
)
;
let
waived
=
Cu
.
waiveXrays
(
value
)
;
for
(
let
prop
of
Object
.
getOwnPropertyNames
(
waived
)
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
waived
prop
)
;
if
(
desc
.
get
|
|
desc
.
set
)
{
throw
context
.
error
(
"
Objects
cannot
have
getters
or
setters
on
properties
"
"
contain
no
getter
or
setter
properties
"
)
;
}
if
(
desc
.
enumerable
)
{
properties
[
prop
]
=
Cu
.
unwaiveXrays
(
desc
.
value
)
;
}
}
return
properties
;
}
checkProperty
(
context
prop
propType
result
properties
remainingProps
)
{
let
{
type
optional
unsupported
onError
}
=
propType
;
let
error
=
null
;
if
(
unsupported
)
{
if
(
prop
in
properties
)
{
error
=
context
.
error
(
Property
"
{
prop
}
"
is
unsupported
by
Firefox
not
contain
an
unsupported
"
{
prop
}
"
property
)
;
}
}
else
if
(
prop
in
properties
)
{
if
(
optional
&
&
(
properties
[
prop
]
=
=
=
null
|
|
properties
[
prop
]
=
=
=
undefined
)
)
{
result
[
prop
]
=
null
;
}
else
{
let
r
=
context
.
withPath
(
prop
(
)
=
>
type
.
normalize
(
properties
[
prop
]
context
)
)
;
if
(
r
.
error
)
{
error
=
r
;
}
else
{
result
[
prop
]
=
r
.
value
;
properties
[
prop
]
=
r
.
value
;
}
}
remainingProps
.
delete
(
prop
)
;
}
else
if
(
!
optional
)
{
error
=
context
.
error
(
Property
"
{
prop
}
"
is
required
contain
the
required
"
{
prop
}
"
property
)
;
}
else
if
(
optional
!
=
=
"
omit
-
key
-
if
-
missing
"
)
{
result
[
prop
]
=
null
;
}
if
(
error
)
{
if
(
onError
=
=
"
warn
"
)
{
context
.
logError
(
error
.
error
)
;
}
else
if
(
onError
!
=
"
ignore
"
)
{
throw
error
;
}
result
[
prop
]
=
null
;
}
}
normalize
(
value
context
)
{
try
{
let
v
=
this
.
normalizeBase
(
"
object
"
value
context
)
;
if
(
v
.
error
)
{
return
v
;
}
value
=
v
.
value
;
if
(
this
.
isInstanceOf
)
{
if
(
DEBUG
)
{
if
(
Object
.
keys
(
this
.
properties
)
.
length
|
|
this
.
patternProperties
.
length
|
|
!
(
this
.
additionalProperties
instanceof
AnyType
)
)
{
throw
new
Error
(
"
InternalError
:
isInstanceOf
can
only
be
used
"
+
"
with
objects
that
are
otherwise
unrestricted
"
)
;
}
}
if
(
!
instanceOf
(
value
this
.
isInstanceOf
)
)
{
return
context
.
error
(
Object
must
be
an
instance
of
{
this
.
isInstanceOf
}
be
an
instance
of
{
this
.
isInstanceOf
}
)
;
}
return
this
.
postprocess
(
{
value
}
context
)
;
}
let
properties
=
this
.
extractProperties
(
value
context
)
;
let
remainingProps
=
new
Set
(
Object
.
keys
(
properties
)
)
;
let
result
=
{
}
;
for
(
let
prop
of
Object
.
keys
(
this
.
properties
)
)
{
this
.
checkProperty
(
context
prop
this
.
properties
[
prop
]
result
properties
remainingProps
)
;
}
for
(
let
prop
of
Object
.
keys
(
properties
)
)
{
for
(
let
{
pattern
type
}
of
this
.
patternProperties
)
{
if
(
pattern
.
test
(
prop
)
)
{
this
.
checkProperty
(
context
prop
type
result
properties
remainingProps
)
;
}
}
}
if
(
this
.
additionalProperties
)
{
for
(
let
prop
of
remainingProps
)
{
let
type
=
this
.
additionalProperties
;
let
r
=
context
.
withPath
(
prop
(
)
=
>
type
.
normalize
(
properties
[
prop
]
context
)
)
;
if
(
r
.
error
)
{
return
r
;
}
result
[
prop
]
=
r
.
value
;
}
}
else
if
(
remainingProps
.
size
=
=
1
)
{
return
context
.
error
(
Unexpected
property
"
{
[
.
.
.
remainingProps
]
}
"
not
contain
an
unexpected
"
{
[
.
.
.
remainingProps
]
}
"
property
)
;
}
else
if
(
remainingProps
.
size
)
{
let
props
=
[
.
.
.
remainingProps
]
.
sort
(
)
.
join
(
"
"
)
;
return
context
.
error
(
Unexpected
properties
:
{
props
}
not
contain
the
unexpected
properties
[
{
props
}
]
)
;
}
return
this
.
postprocess
(
{
value
:
result
}
context
)
;
}
catch
(
e
)
{
if
(
e
.
error
)
{
return
e
;
}
throw
e
;
}
}
}
SubModuleType
=
class
SubModuleType
extends
Type
{
static
get
EXTRA_PROPERTIES
(
)
{
return
[
"
functions
"
"
events
"
"
properties
"
.
.
.
super
.
EXTRA_PROPERTIES
]
;
}
static
parseSchema
(
schema
path
extraProperties
=
[
]
)
{
this
.
checkSchemaProperties
(
schema
path
extraProperties
)
;
path
=
[
.
.
.
path
schema
.
id
]
;
let
functions
=
schema
.
functions
.
map
(
fun
=
>
FunctionEntry
.
parseSchema
(
fun
path
)
)
;
return
new
this
(
functions
)
;
}
constructor
(
functions
)
{
super
(
)
;
this
.
functions
=
functions
;
}
}
;
class
NumberType
extends
Type
{
normalize
(
value
context
)
{
let
r
=
this
.
normalizeBase
(
"
number
"
value
context
)
;
if
(
r
.
error
)
{
return
r
;
}
if
(
isNaN
(
r
.
value
)
|
|
!
Number
.
isFinite
(
r
.
value
)
)
{
return
context
.
error
(
"
NaN
and
infinity
are
not
valid
"
"
be
a
finite
number
"
)
;
}
return
r
;
}
checkBaseType
(
baseType
)
{
return
baseType
=
=
"
number
"
|
|
baseType
=
=
"
integer
"
;
}
}
class
IntegerType
extends
Type
{
static
get
EXTRA_PROPERTIES
(
)
{
return
[
"
minimum
"
"
maximum
"
.
.
.
super
.
EXTRA_PROPERTIES
]
;
}
static
parseSchema
(
schema
path
extraProperties
=
[
]
)
{
this
.
checkSchemaProperties
(
schema
path
extraProperties
)
;
return
new
this
(
schema
schema
.
minimum
|
|
-
Infinity
schema
.
maximum
|
|
Infinity
)
;
}
constructor
(
schema
minimum
maximum
)
{
super
(
schema
)
;
this
.
minimum
=
minimum
;
this
.
maximum
=
maximum
;
}
normalize
(
value
context
)
{
let
r
=
this
.
normalizeBase
(
"
integer
"
value
context
)
;
if
(
r
.
error
)
{
return
r
;
}
value
=
r
.
value
;
if
(
!
Number
.
isSafeInteger
(
value
)
)
{
return
context
.
error
(
"
Integer
is
out
of
range
"
"
be
a
valid
32
bit
signed
integer
"
)
;
}
if
(
value
<
this
.
minimum
)
{
return
context
.
error
(
Integer
{
value
}
is
too
small
(
must
be
at
least
{
this
.
minimum
}
)
be
at
least
{
this
.
minimum
}
)
;
}
if
(
value
>
this
.
maximum
)
{
return
context
.
error
(
Integer
{
value
}
is
too
big
(
must
be
at
most
{
this
.
maximum
}
)
be
no
greater
than
{
this
.
maximum
}
)
;
}
return
this
.
postprocess
(
r
context
)
;
}
checkBaseType
(
baseType
)
{
return
baseType
=
=
"
integer
"
;
}
}
class
BooleanType
extends
Type
{
normalize
(
value
context
)
{
return
this
.
normalizeBase
(
"
boolean
"
value
context
)
;
}
checkBaseType
(
baseType
)
{
return
baseType
=
=
"
boolean
"
;
}
}
class
ArrayType
extends
Type
{
static
get
EXTRA_PROPERTIES
(
)
{
return
[
"
items
"
"
minItems
"
"
maxItems
"
.
.
.
super
.
EXTRA_PROPERTIES
]
;
}
static
parseSchema
(
schema
path
extraProperties
=
[
]
)
{
this
.
checkSchemaProperties
(
schema
path
extraProperties
)
;
let
items
=
Schemas
.
parseSchema
(
schema
.
items
path
)
;
return
new
this
(
schema
items
schema
.
minItems
|
|
0
schema
.
maxItems
|
|
Infinity
)
;
}
constructor
(
schema
itemType
minItems
maxItems
)
{
super
(
schema
)
;
this
.
itemType
=
itemType
;
this
.
minItems
=
minItems
;
this
.
maxItems
=
maxItems
;
}
normalize
(
value
context
)
{
let
v
=
this
.
normalizeBase
(
"
array
"
value
context
)
;
if
(
v
.
error
)
{
return
v
;
}
value
=
v
.
value
;
let
result
=
[
]
;
for
(
let
[
i
element
]
of
value
.
entries
(
)
)
{
element
=
context
.
withPath
(
String
(
i
)
(
)
=
>
this
.
itemType
.
normalize
(
element
context
)
)
;
if
(
element
.
error
)
{
return
element
;
}
result
.
push
(
element
.
value
)
;
}
if
(
result
.
length
<
this
.
minItems
)
{
return
context
.
error
(
Array
requires
at
least
{
this
.
minItems
}
items
;
you
have
{
result
.
length
}
have
at
least
{
this
.
minItems
}
items
)
;
}
if
(
result
.
length
>
this
.
maxItems
)
{
return
context
.
error
(
Array
requires
at
most
{
this
.
maxItems
}
items
;
you
have
{
result
.
length
}
have
at
most
{
this
.
maxItems
}
items
)
;
}
return
this
.
postprocess
(
{
value
:
result
}
context
)
;
}
checkBaseType
(
baseType
)
{
return
baseType
=
=
"
array
"
;
}
}
class
FunctionType
extends
Type
{
static
get
EXTRA_PROPERTIES
(
)
{
return
[
"
parameters
"
"
async
"
"
returns
"
.
.
.
super
.
EXTRA_PROPERTIES
]
;
}
static
parseSchema
(
schema
path
extraProperties
=
[
]
)
{
this
.
checkSchemaProperties
(
schema
path
extraProperties
)
;
let
isAsync
=
!
!
schema
.
async
;
let
isExpectingCallback
=
typeof
schema
.
async
=
=
=
"
string
"
;
let
parameters
=
null
;
if
(
"
parameters
"
in
schema
)
{
parameters
=
[
]
;
for
(
let
param
of
schema
.
parameters
)
{
let
isCallback
=
isAsync
&
&
param
.
name
=
=
schema
.
async
;
if
(
isCallback
)
{
isExpectingCallback
=
false
;
}
parameters
.
push
(
{
type
:
Schemas
.
parseSchema
(
param
path
[
"
name
"
"
optional
"
"
default
"
]
)
name
:
param
.
name
optional
:
param
.
optional
=
=
null
?
isCallback
:
param
.
optional
default
:
param
.
default
=
=
undefined
?
null
:
param
.
default
}
)
;
}
}
let
hasAsyncCallback
=
false
;
if
(
isAsync
)
{
hasAsyncCallback
=
(
parameters
&
&
parameters
.
length
&
&
parameters
[
parameters
.
length
-
1
]
.
name
=
=
schema
.
async
)
;
}
if
(
DEBUG
)
{
if
(
isExpectingCallback
)
{
throw
new
Error
(
Internal
error
:
Expected
a
callback
parameter
+
with
name
{
schema
.
async
}
)
;
}
if
(
isAsync
&
&
schema
.
returns
)
{
throw
new
Error
(
"
Internal
error
:
Async
functions
must
not
"
+
"
have
return
values
.
"
)
;
}
if
(
isAsync
&
&
schema
.
allowAmbiguousOptionalArguments
&
&
!
hasAsyncCallback
)
{
throw
new
Error
(
"
Internal
error
:
Async
functions
with
ambiguous
"
+
"
arguments
must
declare
the
callback
as
the
last
parameter
"
)
;
}
}
return
new
this
(
schema
parameters
isAsync
hasAsyncCallback
)
;
}
constructor
(
schema
parameters
isAsync
hasAsyncCallback
)
{
super
(
schema
)
;
this
.
parameters
=
parameters
;
this
.
isAsync
=
isAsync
;
this
.
hasAsyncCallback
=
hasAsyncCallback
;
}
normalize
(
value
context
)
{
return
this
.
normalizeBase
(
"
function
"
value
context
)
;
}
checkBaseType
(
baseType
)
{
return
baseType
=
=
"
function
"
;
}
}
class
ValueProperty
extends
Entry
{
constructor
(
schema
name
value
)
{
super
(
schema
)
;
this
.
name
=
name
;
this
.
value
=
value
;
}
getDescriptor
(
path
context
)
{
return
{
value
:
this
.
value
}
;
}
}
class
TypeProperty
extends
Entry
{
constructor
(
schema
path
name
type
writable
)
{
super
(
schema
)
;
this
.
path
=
path
;
this
.
name
=
name
;
this
.
type
=
type
;
this
.
writable
=
writable
;
}
throwError
(
context
msg
)
{
throw
context
.
makeError
(
{
msg
}
for
{
this
.
path
.
join
(
"
.
"
)
}
.
{
this
.
name
}
.
)
;
}
getDescriptor
(
path
context
)
{
if
(
this
.
unsupported
)
{
return
;
}
let
apiImpl
=
context
.
getImplementation
(
path
.
join
(
"
.
"
)
this
.
name
)
;
let
getStub
=
(
)
=
>
{
this
.
checkDeprecated
(
context
)
;
return
apiImpl
.
getProperty
(
)
;
}
;
let
desc
=
{
get
:
Cu
.
exportFunction
(
getStub
context
.
cloneScope
)
}
;
if
(
this
.
writable
)
{
let
setStub
=
(
value
)
=
>
{
let
normalized
=
this
.
type
.
normalize
(
value
context
)
;
if
(
normalized
.
error
)
{
this
.
throwError
(
context
normalized
.
error
)
;
}
apiImpl
.
setProperty
(
normalized
.
value
)
;
}
;
desc
.
set
=
Cu
.
exportFunction
(
setStub
context
.
cloneScope
)
;
}
return
desc
;
}
}
class
SubModuleProperty
extends
Entry
{
constructor
(
schema
path
name
reference
properties
)
{
super
(
schema
)
;
this
.
name
=
name
;
this
.
path
=
path
;
this
.
namespaceName
=
path
.
join
(
"
.
"
)
;
this
.
reference
=
reference
;
this
.
properties
=
properties
;
}
getDescriptor
(
path
context
)
{
let
obj
=
Cu
.
createObjectIn
(
context
.
cloneScope
)
;
let
ns
=
Schemas
.
getNamespace
(
this
.
namespaceName
)
;
let
type
=
ns
.
get
(
this
.
reference
)
;
if
(
!
type
&
&
this
.
reference
.
includes
(
"
.
"
)
)
{
let
[
namespaceName
ref
]
=
this
.
reference
.
split
(
"
.
"
)
;
ns
=
Schemas
.
getNamespace
(
namespaceName
)
;
type
=
ns
.
get
(
ref
)
;
}
if
(
DEBUG
)
{
if
(
!
type
|
|
!
(
type
instanceof
SubModuleType
)
)
{
throw
new
Error
(
Internal
error
:
{
this
.
namespaceName
}
.
{
this
.
reference
}
+
is
not
a
sub
-
module
)
;
}
}
let
subpath
=
[
path
this
.
name
]
;
let
namespace
=
subpath
.
join
(
"
.
"
)
;
let
functions
=
type
.
functions
;
for
(
let
fun
of
functions
)
{
let
allowedContexts
=
fun
.
allowedContexts
.
length
?
fun
.
allowedContexts
:
ns
.
defaultContexts
;
if
(
context
.
shouldInject
(
namespace
fun
.
name
allowedContexts
)
)
{
exportLazyProperty
(
obj
fun
.
name
(
)
=
>
fun
.
getDescriptor
(
subpath
context
)
)
;
}
}
return
{
value
:
obj
}
;
}
}
class
CallEntry
extends
Entry
{
constructor
(
schema
path
name
parameters
allowAmbiguousOptionalArguments
)
{
super
(
schema
)
;
this
.
path
=
path
;
this
.
name
=
name
;
this
.
parameters
=
parameters
;
this
.
allowAmbiguousOptionalArguments
=
allowAmbiguousOptionalArguments
;
}
throwError
(
context
msg
)
{
throw
context
.
makeError
(
{
msg
}
for
{
this
.
path
.
join
(
"
.
"
)
}
.
{
this
.
name
}
.
)
;
}
checkParameters
(
args
context
)
{
let
fixedArgs
=
[
]
;
let
check
=
(
parameterIndex
argIndex
)
=
>
{
if
(
parameterIndex
=
=
this
.
parameters
.
length
)
{
if
(
argIndex
=
=
args
.
length
)
{
return
true
;
}
return
false
;
}
let
parameter
=
this
.
parameters
[
parameterIndex
]
;
if
(
parameter
.
optional
)
{
fixedArgs
[
parameterIndex
]
=
parameter
.
default
;
if
(
check
(
parameterIndex
+
1
argIndex
)
)
{
return
true
;
}
}
if
(
argIndex
=
=
args
.
length
)
{
return
false
;
}
let
arg
=
args
[
argIndex
]
;
if
(
!
parameter
.
type
.
checkBaseType
(
getValueBaseType
(
arg
)
)
)
{
if
(
parameter
.
optional
&
&
(
arg
=
=
=
null
|
|
arg
=
=
=
undefined
)
)
{
fixedArgs
[
parameterIndex
]
=
Cu
.
cloneInto
(
parameter
.
default
global
)
;
}
else
{
return
false
;
}
}
else
{
fixedArgs
[
parameterIndex
]
=
arg
;
}
return
check
(
parameterIndex
+
1
argIndex
+
1
)
;
}
;
if
(
this
.
allowAmbiguousOptionalArguments
)
{
if
(
this
.
hasAsyncCallback
&
&
typeof
(
args
[
args
.
length
-
1
]
)
!
=
"
function
"
)
{
args
.
push
(
null
)
;
}
return
args
;
}
let
success
=
check
(
0
0
)
;
if
(
!
success
)
{
this
.
throwError
(
context
"
Incorrect
argument
types
"
)
;
}
fixedArgs
=
fixedArgs
.
map
(
(
arg
parameterIndex
)
=
>
{
if
(
arg
=
=
=
null
)
{
return
null
;
}
let
parameter
=
this
.
parameters
[
parameterIndex
]
;
let
r
=
parameter
.
type
.
normalize
(
arg
context
)
;
if
(
r
.
error
)
{
this
.
throwError
(
context
Type
error
for
parameter
{
parameter
.
name
}
(
{
r
.
error
}
)
)
;
}
return
r
.
value
;
}
)
;
return
fixedArgs
;
}
}
FunctionEntry
=
class
FunctionEntry
extends
CallEntry
{
static
parseSchema
(
schema
path
)
{
return
new
this
(
schema
path
schema
.
name
Schemas
.
parseSchema
(
schema
path
[
"
name
"
"
unsupported
"
"
returns
"
"
permissions
"
"
allowAmbiguousOptionalArguments
"
]
)
schema
.
unsupported
|
|
false
schema
.
allowAmbiguousOptionalArguments
|
|
false
schema
.
returns
|
|
null
schema
.
permissions
|
|
null
)
;
}
constructor
(
schema
path
name
type
unsupported
allowAmbiguousOptionalArguments
returns
permissions
)
{
super
(
schema
path
name
type
.
parameters
allowAmbiguousOptionalArguments
)
;
this
.
unsupported
=
unsupported
;
this
.
returns
=
returns
;
this
.
permissions
=
permissions
;
this
.
isAsync
=
type
.
isAsync
;
this
.
hasAsyncCallback
=
type
.
hasAsyncCallback
;
}
getDescriptor
(
path
context
)
{
if
(
this
.
unsupported
)
{
return
;
}
if
(
this
.
permissions
&
&
!
this
.
permissions
.
some
(
perm
=
>
context
.
hasPermission
(
perm
)
)
)
{
return
;
}
let
apiImpl
=
context
.
getImplementation
(
path
.
join
(
"
.
"
)
this
.
name
)
;
let
stub
;
if
(
this
.
isAsync
)
{
stub
=
(
.
.
.
args
)
=
>
{
this
.
checkDeprecated
(
context
)
;
let
actuals
=
this
.
checkParameters
(
args
context
)
;
let
callback
=
null
;
if
(
this
.
hasAsyncCallback
)
{
callback
=
actuals
.
pop
(
)
;
}
if
(
callback
=
=
=
null
&
&
context
.
isChromeCompat
)
{
callback
=
(
)
=
>
{
}
;
}
return
apiImpl
.
callAsyncFunction
(
actuals
callback
)
;
}
;
}
else
if
(
!
this
.
returns
)
{
stub
=
(
.
.
.
args
)
=
>
{
this
.
checkDeprecated
(
context
)
;
let
actuals
=
this
.
checkParameters
(
args
context
)
;
return
apiImpl
.
callFunctionNoReturn
(
actuals
)
;
}
;
}
else
{
stub
=
(
.
.
.
args
)
=
>
{
this
.
checkDeprecated
(
context
)
;
let
actuals
=
this
.
checkParameters
(
args
context
)
;
return
apiImpl
.
callFunction
(
actuals
)
;
}
;
}
return
{
value
:
Cu
.
exportFunction
(
stub
context
.
cloneScope
)
}
;
}
}
;
class
Event
extends
CallEntry
{
static
parseSchema
(
event
path
)
{
let
extraParameters
=
Array
.
from
(
event
.
extraParameters
|
|
[
]
param
=
>
(
{
type
:
Schemas
.
parseSchema
(
param
path
[
"
name
"
"
optional
"
"
default
"
]
)
name
:
param
.
name
optional
:
param
.
optional
|
|
false
default
:
param
.
default
=
=
undefined
?
null
:
param
.
default
}
)
)
;
let
extraProperties
=
[
"
name
"
"
unsupported
"
"
permissions
"
"
extraParameters
"
"
returns
"
"
filters
"
]
;
return
new
this
(
event
path
event
.
name
Schemas
.
parseSchema
(
event
path
extraProperties
)
extraParameters
event
.
unsupported
|
|
false
event
.
permissions
|
|
null
)
;
}
constructor
(
schema
path
name
type
extraParameters
unsupported
permissions
)
{
super
(
schema
path
name
extraParameters
)
;
this
.
type
=
type
;
this
.
unsupported
=
unsupported
;
this
.
permissions
=
permissions
;
}
checkListener
(
listener
context
)
{
let
r
=
this
.
type
.
normalize
(
listener
context
)
;
if
(
r
.
error
)
{
this
.
throwError
(
context
"
Invalid
listener
"
)
;
}
return
r
.
value
;
}
getDescriptor
(
path
context
)
{
if
(
this
.
unsupported
)
{
return
;
}
if
(
this
.
permissions
&
&
!
this
.
permissions
.
some
(
perm
=
>
context
.
hasPermission
(
perm
)
)
)
{
return
;
}
let
apiImpl
=
context
.
getImplementation
(
path
.
join
(
"
.
"
)
this
.
name
)
;
let
addStub
=
(
listener
.
.
.
args
)
=
>
{
listener
=
this
.
checkListener
(
listener
context
)
;
let
actuals
=
this
.
checkParameters
(
args
context
)
;
apiImpl
.
addListener
(
listener
actuals
)
;
}
;
let
removeStub
=
(
listener
)
=
>
{
listener
=
this
.
checkListener
(
listener
context
)
;
apiImpl
.
removeListener
(
listener
)
;
}
;
let
hasStub
=
(
listener
)
=
>
{
listener
=
this
.
checkListener
(
listener
context
)
;
return
apiImpl
.
hasListener
(
listener
)
;
}
;
let
obj
=
Cu
.
createObjectIn
(
context
.
cloneScope
)
;
Cu
.
exportFunction
(
addStub
obj
{
defineAs
:
"
addListener
"
}
)
;
Cu
.
exportFunction
(
removeStub
obj
{
defineAs
:
"
removeListener
"
}
)
;
Cu
.
exportFunction
(
hasStub
obj
{
defineAs
:
"
hasListener
"
}
)
;
return
{
value
:
obj
}
;
}
}
const
TYPES
=
Object
.
freeze
(
Object
.
assign
(
Object
.
create
(
null
)
{
any
:
AnyType
array
:
ArrayType
boolean
:
BooleanType
function
:
FunctionType
integer
:
IntegerType
number
:
NumberType
object
:
ObjectType
string
:
StringType
}
)
)
;
const
LOADERS
=
{
events
:
"
loadEvent
"
functions
:
"
loadFunction
"
properties
:
"
loadProperty
"
types
:
"
loadType
"
}
;
class
Namespace
extends
Map
{
constructor
(
name
path
)
{
super
(
)
;
this
.
_lazySchemas
=
[
]
;
this
.
name
=
name
;
this
.
path
=
name
?
[
.
.
.
path
name
]
:
[
.
.
.
path
]
;
this
.
permissions
=
null
;
this
.
allowedContexts
=
[
]
;
this
.
defaultContexts
=
[
]
;
}
addSchema
(
schema
)
{
this
.
_lazySchemas
.
push
(
schema
)
;
for
(
let
prop
of
[
"
permissions
"
"
allowedContexts
"
"
defaultContexts
"
]
)
{
if
(
schema
[
prop
]
)
{
this
[
prop
]
=
schema
[
prop
]
;
}
}
}
init
(
)
{
if
(
!
this
.
_lazySchemas
)
{
return
;
}
for
(
let
type
of
Object
.
keys
(
LOADERS
)
)
{
this
[
type
]
=
new
DefaultMap
(
(
)
=
>
[
]
)
;
}
for
(
let
schema
of
this
.
_lazySchemas
)
{
for
(
let
type
of
schema
.
types
|
|
[
]
)
{
this
.
types
.
get
(
type
.
extend
|
|
type
.
id
)
.
push
(
type
)
;
}
for
(
let
[
name
prop
]
of
Object
.
entries
(
schema
.
properties
|
|
{
}
)
)
{
if
(
!
prop
.
unsupported
)
{
this
.
properties
.
get
(
name
)
.
push
(
prop
)
;
}
}
for
(
let
fun
of
schema
.
functions
|
|
[
]
)
{
this
.
functions
.
get
(
fun
.
name
)
.
push
(
fun
)
;
}
for
(
let
event
of
schema
.
events
|
|
[
]
)
{
this
.
events
.
get
(
event
.
name
)
.
push
(
event
)
;
}
}
for
(
let
type
of
Object
.
keys
(
LOADERS
)
)
{
for
(
let
key
of
this
[
type
]
.
keys
(
)
)
{
this
.
set
(
key
type
)
;
}
}
this
.
_lazySchemas
=
null
;
if
(
DEBUG
)
{
for
(
let
key
of
this
.
keys
(
)
)
{
this
.
get
(
key
)
;
}
}
}
initKey
(
key
type
)
{
let
loader
=
LOADERS
[
type
]
;
for
(
let
schema
of
this
[
type
]
.
get
(
key
)
)
{
this
.
set
(
key
this
[
loader
]
(
key
schema
)
)
;
}
return
this
.
get
(
key
)
;
}
loadType
(
name
type
)
{
if
(
"
extend
"
in
type
)
{
return
this
.
extendType
(
type
)
;
}
return
Schemas
.
parseSchema
(
type
this
.
path
[
"
id
"
]
)
;
}
extendType
(
type
)
{
let
targetType
=
this
.
get
(
type
.
extend
)
;
if
(
targetType
instanceof
ObjectType
)
{
type
.
type
=
"
object
"
;
}
else
if
(
DEBUG
)
{
if
(
!
targetType
)
{
throw
new
Error
(
Internal
error
:
Attempt
to
extend
a
nonexistant
type
{
type
.
extend
}
)
;
}
else
if
(
!
(
targetType
instanceof
ChoiceType
)
)
{
throw
new
Error
(
Internal
error
:
Attempt
to
extend
a
non
-
extensible
type
{
type
.
extend
}
)
;
}
}
let
parsed
=
Schemas
.
parseSchema
(
type
this
.
path
[
"
extend
"
]
)
;
if
(
DEBUG
&
&
parsed
.
constructor
!
=
=
targetType
.
constructor
)
{
throw
new
Error
(
Internal
error
:
Bad
attempt
to
extend
{
type
.
extend
}
)
;
}
targetType
.
extend
(
parsed
)
;
return
targetType
;
}
loadProperty
(
name
prop
)
{
if
(
"
ref
"
in
prop
)
{
if
(
!
prop
.
unsupported
)
{
return
new
SubModuleProperty
(
prop
this
.
path
name
prop
.
ref
prop
.
properties
|
|
{
}
)
;
}
}
else
if
(
"
value
"
in
prop
)
{
return
new
ValueProperty
(
prop
name
prop
.
value
)
;
}
else
{
let
type
=
Schemas
.
parseSchema
(
prop
[
this
.
name
]
[
"
optional
"
"
writable
"
]
)
;
return
new
TypeProperty
(
prop
this
.
path
name
type
prop
.
writable
|
|
false
)
;
}
}
loadFunction
(
name
fun
)
{
return
FunctionEntry
.
parseSchema
(
fun
this
.
path
)
;
}
loadEvent
(
name
event
)
{
return
Event
.
parseSchema
(
event
this
.
path
)
;
}
injectInto
(
dest
context
)
{
for
(
let
name
of
this
.
keys
(
)
)
{
exportLazyProperty
(
dest
name
(
)
=
>
{
let
entry
=
this
.
get
(
name
)
;
if
(
entry
.
permissions
&
&
!
entry
.
permissions
.
some
(
perm
=
>
context
.
hasPermission
(
perm
)
)
)
{
return
;
}
let
allowedContexts
=
entry
.
allowedContexts
;
if
(
!
allowedContexts
.
length
)
{
allowedContexts
=
this
.
defaultContexts
;
}
if
(
context
.
shouldInject
(
this
.
path
.
join
(
"
.
"
)
name
allowedContexts
)
)
{
return
entry
.
getDescriptor
(
this
.
path
context
)
;
}
}
)
;
}
}
getDescriptor
(
path
context
)
{
let
obj
=
Cu
.
createObjectIn
(
context
.
cloneScope
)
;
this
.
injectInto
(
obj
context
)
;
if
(
Object
.
keys
(
obj
)
.
length
)
{
return
{
value
:
obj
}
;
}
}
keys
(
)
{
this
.
init
(
)
;
return
super
.
keys
(
)
;
}
*
entries
(
)
{
for
(
let
key
of
this
.
keys
(
)
)
{
yield
[
key
this
.
get
(
key
)
]
;
}
}
get
(
key
)
{
this
.
init
(
)
;
let
value
=
super
.
get
(
key
)
;
if
(
typeof
value
=
=
=
"
string
"
)
{
value
=
this
.
initKey
(
key
value
)
;
}
return
value
;
}
getNamespace
(
name
)
{
let
subName
;
let
idx
=
name
.
indexOf
(
"
.
"
)
;
if
(
idx
>
0
)
{
subName
=
name
.
slice
(
idx
+
1
)
;
name
=
name
.
slice
(
0
idx
)
;
}
let
ns
=
super
.
get
(
name
)
;
if
(
!
ns
)
{
ns
=
new
Namespace
(
name
this
.
path
)
;
this
.
set
(
name
ns
)
;
}
if
(
subName
)
{
return
ns
.
getNamespace
(
subName
)
;
}
return
ns
;
}
has
(
key
)
{
this
.
init
(
)
;
return
super
.
has
(
key
)
;
}
}
this
.
Schemas
=
{
initialized
:
false
schemaJSON
:
new
Map
(
)
rootNamespace
:
new
Namespace
(
"
"
[
]
)
getNamespace
(
name
)
{
return
this
.
rootNamespace
.
getNamespace
(
name
)
;
}
parseSchema
(
schema
path
extraProperties
=
[
]
)
{
let
allowedProperties
=
DEBUG
&
&
new
Set
(
extraProperties
)
;
if
(
"
choices
"
in
schema
)
{
return
ChoiceType
.
parseSchema
(
schema
path
allowedProperties
)
;
}
else
if
(
"
ref
"
in
schema
)
{
return
RefType
.
parseSchema
(
schema
path
allowedProperties
)
;
}
let
type
=
TYPES
[
schema
.
type
]
;
if
(
DEBUG
)
{
allowedProperties
.
add
(
"
type
"
)
;
if
(
!
(
"
type
"
in
schema
)
)
{
throw
new
Error
(
Unexpected
value
for
type
:
{
JSON
.
stringify
(
schema
)
}
)
;
}
if
(
!
type
)
{
throw
new
Error
(
Unexpected
type
{
schema
.
type
}
)
;
}
}
return
type
.
parseSchema
(
schema
path
allowedProperties
)
;
}
init
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
initialized
=
true
;
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
)
{
let
data
=
Services
.
cpmm
.
initialProcessData
;
let
schemas
=
data
[
"
Extension
:
Schemas
"
]
;
if
(
schemas
)
{
this
.
schemaJSON
=
schemas
;
}
Services
.
cpmm
.
addMessageListener
(
"
Schema
:
Add
"
this
)
;
}
this
.
flushSchemas
(
)
;
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
Schema
:
Add
"
:
this
.
schemaJSON
.
set
(
msg
.
data
.
url
msg
.
data
.
schema
)
;
this
.
flushSchemas
(
)
;
break
;
case
"
Schema
:
Delete
"
:
this
.
schemaJSON
.
delete
(
msg
.
data
.
url
)
;
this
.
flushSchemas
(
)
;
break
;
}
}
flushSchemas
(
)
{
XPCOMUtils
.
defineLazyGetter
(
this
"
rootNamespace
"
(
)
=
>
this
.
parseSchemas
(
)
)
;
}
parseSchemas
(
)
{
Object
.
defineProperty
(
this
"
rootNamespace
"
{
enumerable
:
true
configurable
:
true
value
:
new
Namespace
(
"
"
[
]
)
}
)
;
for
(
let
json
of
this
.
schemaJSON
.
values
(
)
)
{
try
{
this
.
loadSchema
(
json
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
return
this
.
rootNamespace
;
}
loadSchema
(
json
)
{
for
(
let
namespace
of
json
)
{
this
.
getNamespace
(
namespace
.
namespace
)
.
addSchema
(
namespace
)
;
}
}
load
(
url
)
{
if
(
Services
.
appinfo
.
processType
!
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
)
{
return
readJSON
(
url
)
.
then
(
json
=
>
{
this
.
schemaJSON
.
set
(
url
json
)
;
let
data
=
Services
.
ppmm
.
initialProcessData
;
data
[
"
Extension
:
Schemas
"
]
=
this
.
schemaJSON
;
Services
.
ppmm
.
broadcastAsyncMessage
(
"
Schema
:
Add
"
{
url
schema
:
json
}
)
;
this
.
flushSchemas
(
)
;
}
)
;
}
}
unload
(
url
)
{
this
.
schemaJSON
.
delete
(
url
)
;
let
data
=
Services
.
ppmm
.
initialProcessData
;
data
[
"
Extension
:
Schemas
"
]
=
this
.
schemaJSON
;
Services
.
ppmm
.
broadcastAsyncMessage
(
"
Schema
:
Delete
"
{
url
}
)
;
this
.
flushSchemas
(
)
;
}
checkPermissions
(
namespace
wrapperFuncs
)
{
let
ns
=
this
.
getNamespace
(
namespace
)
;
if
(
ns
&
&
ns
.
permissions
)
{
return
ns
.
permissions
.
some
(
perm
=
>
wrapperFuncs
.
hasPermission
(
perm
)
)
;
}
return
true
;
}
exportLazyGetter
inject
(
dest
wrapperFuncs
)
{
let
context
=
new
InjectionContext
(
wrapperFuncs
)
;
this
.
rootNamespace
.
injectInto
(
dest
context
)
;
}
normalize
(
obj
typeName
context
)
{
let
[
namespaceName
prop
]
=
typeName
.
split
(
"
.
"
)
;
let
ns
=
this
.
getNamespace
(
namespaceName
)
;
let
type
=
ns
.
get
(
prop
)
;
return
type
.
normalize
(
obj
new
Context
(
context
)
)
;
}
}
;
