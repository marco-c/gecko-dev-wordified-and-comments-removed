"
use
strict
"
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
{
ExtensionParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
StartupCache
}
=
ExtensionParent
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
KeyValueService
:
"
resource
:
/
/
gre
/
modules
/
kvstore
.
jsm
"
}
)
;
class
Store
{
async
_init
(
)
{
const
{
path
:
storePath
}
=
lazy
.
FileUtils
.
getDir
(
"
ProfD
"
[
"
extension
-
store
"
]
)
;
await
IOUtils
.
makeDirectory
(
storePath
{
ignoreExisting
:
true
}
)
;
this
.
_store
=
await
lazy
.
KeyValueService
.
getOrCreate
(
storePath
"
scripting
-
contentScripts
"
)
;
}
lazyInit
(
)
{
if
(
!
this
.
_initPromise
)
{
this
.
_initPromise
=
this
.
_init
(
)
;
}
return
this
.
_initPromise
;
}
async
getAll
(
extensionId
)
{
await
this
.
lazyInit
(
)
;
const
pairs
=
await
this
.
getByExtensionId
(
extensionId
)
;
return
pairs
.
map
(
(
[
_
script
]
)
=
>
script
)
;
}
async
writeMany
(
extensionId
scripts
)
{
await
this
.
lazyInit
(
)
;
return
this
.
_store
.
writeMany
(
scripts
.
map
(
script
=
>
[
{
extensionId
}
/
{
script
.
id
}
JSON
.
stringify
(
script
)
]
)
)
;
}
async
deleteAll
(
extensionId
)
{
await
this
.
lazyInit
(
)
;
const
pairs
=
await
this
.
getByExtensionId
(
extensionId
)
;
return
Promise
.
all
(
pairs
.
map
(
(
[
key
_
]
)
=
>
this
.
_store
.
delete
(
key
)
)
)
;
}
async
getByExtensionId
(
extensionId
)
{
await
this
.
lazyInit
(
)
;
const
entries
=
[
]
;
const
enumerator
=
await
this
.
_store
.
enumerate
(
{
extensionId
}
/
{
extensionId
}
0
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
const
{
key
value
}
=
enumerator
.
getNext
(
)
;
entries
.
push
(
[
key
JSON
.
parse
(
value
)
]
)
;
}
return
entries
;
}
}
const
store
=
new
Store
(
)
;
const
makeInternalContentScript
=
(
extension
options
prependBaseURL
=
false
)
=
>
{
let
cssPaths
=
options
.
css
|
|
[
]
;
let
jsPaths
=
options
.
js
|
|
[
]
;
if
(
prependBaseURL
)
{
cssPaths
=
cssPaths
.
map
(
css
=
>
{
extension
.
baseURL
}
{
css
}
)
;
jsPaths
=
jsPaths
.
map
(
js
=
>
{
extension
.
baseURL
}
{
js
}
)
;
}
return
{
scriptId
:
ExtensionUtils
.
getUniqueId
(
)
options
:
{
id
:
options
.
id
allFrames
:
options
.
allFrames
|
|
false
checkPermissions
:
true
cssPaths
excludeMatches
:
options
.
excludeMatches
jsPaths
matchAboutBlank
:
true
matches
:
options
.
matches
originAttributesPatterns
:
null
persistAcrossSessions
:
options
.
persistAcrossSessions
runAt
:
options
.
runAt
|
|
"
document_idle
"
}
}
;
}
;
const
makePublicContentScript
=
(
extension
internalScript
)
=
>
{
let
script
=
{
id
:
internalScript
.
id
allFrames
:
internalScript
.
allFrames
matches
:
internalScript
.
matches
runAt
:
internalScript
.
runAt
persistAcrossSessions
:
internalScript
.
persistAcrossSessions
}
;
if
(
internalScript
.
cssPaths
.
length
)
{
script
.
css
=
internalScript
.
cssPaths
.
map
(
cssPath
=
>
cssPath
.
replace
(
extension
.
baseURL
"
"
)
)
;
}
if
(
internalScript
.
excludeMatches
?
.
length
)
{
script
.
excludeMatches
=
internalScript
.
excludeMatches
;
}
if
(
internalScript
.
jsPaths
.
length
)
{
script
.
js
=
internalScript
.
jsPaths
.
map
(
jsPath
=
>
jsPath
.
replace
(
extension
.
baseURL
"
"
)
)
;
}
return
script
;
}
;
const
ExtensionScriptingStore
=
{
async
initExtension
(
extension
)
{
let
scripts
;
switch
(
extension
.
startupReason
)
{
case
"
ADDON_INSTALL
"
:
case
"
ADDON_UPGRADE
"
:
case
"
ADDON_DOWNGRADE
"
:
StartupCache
.
general
.
set
(
[
extension
.
id
extension
.
version
"
scripting
"
"
hasPersistedScripts
"
]
false
)
;
store
.
deleteAll
(
extension
.
id
)
;
return
;
}
const
hasPersistedScripts
=
await
StartupCache
.
get
(
extension
[
"
scripting
"
"
hasPersistedScripts
"
]
async
(
)
=
>
{
scripts
=
await
store
.
getAll
(
extension
.
id
)
;
return
!
!
scripts
.
length
;
}
)
;
if
(
!
hasPersistedScripts
)
{
return
;
}
scripts
?
?
=
await
store
.
getAll
(
extension
.
id
)
;
scripts
.
forEach
(
script
=
>
{
const
{
scriptId
options
}
=
makeInternalContentScript
(
extension
script
true
)
;
extension
.
registeredContentScripts
.
set
(
scriptId
options
)
;
}
)
;
}
getInitialScriptIdsMap
(
extension
)
{
return
new
Map
(
Array
.
from
(
extension
.
registeredContentScripts
.
entries
(
)
(
[
scriptId
options
]
)
=
>
[
options
.
id
scriptId
]
)
)
;
}
async
persistAll
(
extension
)
{
const
scripts
=
Array
.
from
(
extension
.
registeredContentScripts
.
values
(
)
)
.
filter
(
options
=
>
options
.
persistAcrossSessions
)
.
map
(
options
=
>
makePublicContentScript
(
extension
options
)
)
;
await
store
.
deleteAll
(
extension
.
id
)
;
await
store
.
writeMany
(
extension
.
id
scripts
)
;
StartupCache
.
general
.
set
(
[
extension
.
id
extension
.
version
"
scripting
"
"
hasPersistedScripts
"
]
!
!
scripts
.
length
)
;
}
async
clearOnUninstall
(
extensionId
)
{
await
store
.
deleteAll
(
extensionId
)
;
}
_getStoreForTesting
(
)
{
return
store
;
}
}
;
var
EXPORTED_SYMBOLS
=
[
"
ExtensionScriptingStore
"
"
makeInternalContentScript
"
"
makePublicContentScript
"
]
;
