"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserActionBase
"
"
PageActionBase
"
]
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
{
ExtensionError
}
=
ExtensionUtils
;
const
{
ExtensionParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
const
{
IconDetails
StartupCache
}
=
ExtensionParent
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
MV2_ACTION_POPURL_RESTRICTED
"
"
extensions
.
manifestV2
.
actionsPopupURLRestricted
"
false
)
;
function
parseColor
(
color
kind
)
{
if
(
typeof
color
=
=
"
string
"
)
{
let
rgba
=
InspectorUtils
.
colorToRGBA
(
color
)
;
if
(
!
rgba
)
{
throw
new
ExtensionError
(
Invalid
badge
{
kind
}
color
:
"
{
color
}
"
)
;
}
color
=
[
rgba
.
r
rgba
.
g
rgba
.
b
Math
.
round
(
rgba
.
a
*
255
)
]
;
}
return
color
;
}
class
PanelActionBase
{
constructor
(
options
tabContext
extension
)
{
this
.
tabContext
=
tabContext
;
this
.
extension
=
extension
;
this
.
defaults
=
{
enabled
:
true
title
:
options
.
default_title
|
|
extension
.
name
popup
:
options
.
default_popup
|
|
"
"
}
;
this
.
globals
=
Object
.
create
(
this
.
defaults
)
;
this
.
tabContext
.
on
(
"
location
-
change
"
this
.
handleLocationChange
.
bind
(
this
)
)
;
this
.
tabContext
.
on
(
"
tab
-
select
"
(
evt
tab
)
=
>
{
this
.
updateOnChange
(
tab
)
;
}
)
;
extension
.
on
(
"
add
-
permissions
"
(
)
=
>
this
.
updateOnChange
(
)
)
;
extension
.
on
(
"
remove
-
permissions
"
(
)
=
>
this
.
updateOnChange
(
)
)
;
this
.
activeTabForPreload
=
null
;
}
onShutdown
(
)
{
this
.
tabContext
.
shutdown
(
)
;
}
setPropertyFromDetails
(
details
prop
value
)
{
return
this
.
setProperty
(
this
.
getTargetFromDetails
(
details
)
prop
value
)
;
}
setProperty
(
target
prop
value
)
{
let
values
=
this
.
getContextData
(
target
)
;
if
(
value
=
=
=
null
)
{
delete
values
[
prop
]
;
}
else
{
values
[
prop
]
=
value
;
}
this
.
updateOnChange
(
target
)
;
return
values
;
}
getContextData
(
target
)
{
if
(
target
)
{
return
this
.
tabContext
.
get
(
target
)
;
}
return
this
.
globals
;
}
getProperty
(
target
prop
)
{
return
this
.
getContextData
(
target
)
[
prop
]
;
}
getPropertyFromDetails
(
details
prop
)
{
return
this
.
getProperty
(
this
.
getTargetFromDetails
(
details
)
prop
)
;
}
enable
(
tabId
)
{
this
.
setPropertyFromDetails
(
{
tabId
}
"
enabled
"
true
)
;
}
disable
(
tabId
)
{
this
.
setPropertyFromDetails
(
{
tabId
}
"
enabled
"
false
)
;
}
getIcon
(
details
=
{
}
)
{
return
this
.
getPropertyFromDetails
(
details
"
icon
"
)
;
}
normalizeIcon
(
details
extension
context
)
{
let
icon
=
IconDetails
.
normalize
(
details
extension
context
)
;
if
(
!
Object
.
keys
(
icon
)
.
length
)
{
return
null
;
}
return
icon
;
}
handleLocationChange
(
eventType
tab
fromBrowse
)
{
if
(
fromBrowse
)
{
this
.
tabContext
.
clear
(
tab
)
;
}
}
getPopupUrl
(
tab
strict
=
false
)
{
if
(
!
this
.
isShownForTab
(
tab
)
)
{
if
(
strict
)
{
throw
new
ExtensionError
(
"
Popup
is
disabled
"
)
;
}
return
undefined
;
}
let
popupUrl
=
this
.
getProperty
(
tab
"
popup
"
)
;
if
(
strict
&
&
!
popupUrl
)
{
throw
new
ExtensionError
(
"
No
popup
URL
is
set
"
)
;
}
return
popupUrl
;
}
setActiveTabForPreload
(
tab
=
null
)
{
let
oldTab
=
this
.
activeTabForPreload
;
if
(
oldTab
=
=
=
tab
)
{
return
;
}
this
.
activeTabForPreload
=
tab
;
if
(
tab
)
{
this
.
extension
.
tabManager
.
addActiveTabPermission
(
tab
)
;
}
if
(
oldTab
)
{
this
.
extension
.
tabManager
.
revokeActiveTabPermission
(
oldTab
)
;
}
}
triggerClickOrPopup
(
tab
clickInfo
=
undefined
)
{
if
(
!
this
.
isShownForTab
(
tab
)
)
{
return
null
;
}
this
.
setActiveTabForPreload
(
null
)
;
this
.
extension
.
tabManager
.
addActiveTabPermission
(
tab
)
;
this
.
extension
.
tabManager
.
activateScripts
(
tab
)
;
let
popupUrl
=
this
.
getProperty
(
tab
"
popup
"
)
;
if
(
!
popupUrl
)
{
this
.
dispatchClick
(
tab
clickInfo
)
;
}
this
.
updateOnChange
(
tab
)
;
return
popupUrl
;
}
api
(
context
)
{
let
{
extension
}
=
context
;
return
{
setTitle
:
details
=
>
{
this
.
setPropertyFromDetails
(
details
"
title
"
details
.
title
)
;
}
getTitle
:
details
=
>
{
return
this
.
getPropertyFromDetails
(
details
"
title
"
)
;
}
setIcon
:
details
=
>
{
details
.
iconType
=
"
browserAction
"
;
this
.
setPropertyFromDetails
(
details
"
icon
"
this
.
normalizeIcon
(
details
extension
context
)
)
;
}
setPopup
:
details
=
>
{
let
url
=
details
.
popup
&
&
context
.
uri
.
resolve
(
details
.
popup
)
;
if
(
url
&
&
!
context
.
checkLoadURL
(
url
)
)
{
return
Promise
.
reject
(
{
message
:
Access
denied
for
URL
{
url
}
}
)
;
}
if
(
url
&
&
!
url
.
startsWith
(
extension
.
baseURI
.
spec
)
&
&
(
context
.
extension
.
manifestVersion
>
=
3
|
|
lazy
.
MV2_ACTION_POPURL_RESTRICTED
)
)
{
return
Promise
.
reject
(
{
message
:
Access
denied
for
URL
{
url
}
}
)
;
}
this
.
setPropertyFromDetails
(
details
"
popup
"
url
)
;
}
getPopup
:
details
=
>
{
return
this
.
getPropertyFromDetails
(
details
"
popup
"
)
;
}
}
;
}
updateOnChange
(
target
)
{
}
getTab
(
tabId
)
{
}
getWindow
(
windowId
)
{
}
getTargetFromDetails
(
{
tabId
windowId
}
)
{
return
null
;
}
dispatchClick
(
tab
clickInfo
)
{
}
isShownForTab
(
tab
)
{
return
false
;
}
}
class
PageActionBase
extends
PanelActionBase
{
constructor
(
tabContext
extension
)
{
const
options
=
extension
.
manifest
.
page_action
;
super
(
options
tabContext
extension
)
;
let
enabled
showMatches
hideMatches
;
let
show_matches
=
options
.
show_matches
|
|
[
]
;
let
hide_matches
=
options
.
hide_matches
|
|
[
]
;
if
(
!
show_matches
.
length
)
{
enabled
=
false
;
}
else
{
const
{
restrictSchemes
}
=
extension
;
showMatches
=
new
MatchPatternSet
(
show_matches
{
restrictSchemes
}
)
;
hideMatches
=
new
MatchPatternSet
(
hide_matches
{
restrictSchemes
}
)
;
}
this
.
defaults
=
{
.
.
.
this
.
defaults
enabled
showMatches
hideMatches
pinned
:
options
.
pinned
}
;
this
.
globals
=
Object
.
create
(
this
.
defaults
)
;
}
handleLocationChange
(
eventType
tab
fromBrowse
)
{
super
.
handleLocationChange
(
eventType
tab
fromBrowse
)
;
if
(
fromBrowse
=
=
=
false
)
{
let
tabData
=
this
.
tabContext
.
get
(
tab
)
;
if
(
tabData
.
patternMatching
!
=
=
undefined
)
{
tabData
.
patternMatching
=
undefined
;
}
}
if
(
tab
.
selected
)
{
this
.
isShownForTab
(
tab
)
;
this
.
updateOnChange
(
tab
)
;
}
}
isShownForTab
(
tab
)
{
let
tabData
=
this
.
getContextData
(
tab
)
;
if
(
tabData
.
enabled
!
=
=
undefined
)
{
return
tabData
.
enabled
;
}
if
(
tabData
.
patternMatching
=
=
=
undefined
)
{
let
uri
=
tab
.
linkedBrowser
.
currentURI
;
tabData
.
patternMatching
=
tabData
.
showMatches
.
matches
(
uri
)
&
&
!
tabData
.
hideMatches
.
matches
(
uri
)
;
}
return
tabData
.
patternMatching
;
}
async
loadIconData
(
)
{
const
{
extension
}
=
this
;
const
options
=
extension
.
manifest
.
page_action
;
this
.
defaults
.
icon
=
await
StartupCache
.
get
(
extension
[
"
pageAction
"
"
default_icon
"
]
(
)
=
>
this
.
normalizeIcon
(
{
path
:
options
.
default_icon
|
|
"
"
}
extension
null
)
)
;
}
getPinned
(
)
{
return
this
.
globals
.
pinned
;
}
getTargetFromDetails
(
{
tabId
windowId
}
)
{
if
(
tabId
!
=
null
)
{
return
this
.
getTab
(
tabId
)
;
}
return
null
;
}
api
(
context
)
{
return
{
.
.
.
super
.
api
(
context
)
show
:
(
.
.
.
args
)
=
>
this
.
enable
(
.
.
.
args
)
hide
:
(
.
.
.
args
)
=
>
this
.
disable
(
.
.
.
args
)
isShown
:
(
{
tabId
}
)
=
>
{
let
tab
=
this
.
getTab
(
tabId
)
;
return
this
.
isShownForTab
(
tab
)
;
}
}
;
}
}
class
BrowserActionBase
extends
PanelActionBase
{
constructor
(
tabContext
extension
)
{
const
options
=
extension
.
manifest
.
browser_action
|
|
extension
.
manifest
.
action
;
super
(
options
tabContext
extension
)
;
let
default_area
=
Services
.
policies
?
.
getExtensionSettings
(
extension
.
id
)
?
.
default_area
|
|
options
.
default_area
|
|
"
menupanel
"
;
this
.
defaults
=
{
.
.
.
this
.
defaults
badgeText
:
"
"
badgeBackgroundColor
:
[
0xd9
0
0
255
]
badgeDefaultColor
:
[
255
255
255
255
]
badgeTextColor
:
null
default_area
}
;
this
.
globals
=
Object
.
create
(
this
.
defaults
)
;
}
async
loadIconData
(
)
{
const
{
extension
}
=
this
;
const
options
=
extension
.
manifest
.
browser_action
|
|
extension
.
manifest
.
action
;
this
.
defaults
.
icon
=
await
StartupCache
.
get
(
extension
[
"
browserAction
"
"
default_icon
"
]
(
)
=
>
IconDetails
.
normalize
(
{
path
:
options
.
default_icon
|
|
extension
.
manifest
.
icons
iconType
:
"
browserAction
"
themeIcons
:
options
.
theme_icons
}
extension
)
)
;
}
handleLocationChange
(
eventType
tab
fromBrowse
)
{
super
.
handleLocationChange
(
eventType
tab
fromBrowse
)
;
if
(
fromBrowse
)
{
this
.
updateOnChange
(
tab
)
;
}
}
getTargetFromDetails
(
{
tabId
windowId
}
)
{
if
(
tabId
!
=
null
&
&
windowId
!
=
null
)
{
throw
new
ExtensionError
(
"
Only
one
of
tabId
and
windowId
can
be
specified
.
"
)
;
}
if
(
tabId
!
=
null
)
{
return
this
.
getTab
(
tabId
)
;
}
else
if
(
windowId
!
=
null
)
{
return
this
.
getWindow
(
windowId
)
;
}
return
null
;
}
getDefaultArea
(
)
{
return
this
.
globals
.
default_area
;
}
getTextColor
(
values
)
{
let
{
badgeTextColor
}
=
values
;
if
(
badgeTextColor
)
{
return
badgeTextColor
;
}
let
{
badgeDefaultColor
}
=
values
;
if
(
badgeDefaultColor
)
{
return
badgeDefaultColor
;
}
let
[
r
g
b
]
=
values
.
badgeBackgroundColor
.
slice
(
0
3
)
.
map
(
function
(
channel
)
{
channel
/
=
255
;
if
(
channel
<
=
0
.
03928
)
{
return
channel
/
12
.
92
;
}
return
(
(
channel
+
0
.
055
)
/
1
.
055
)
*
*
2
.
4
;
}
)
;
let
lum
=
0
.
2126
*
r
+
0
.
7152
*
g
+
0
.
0722
*
b
;
let
channel
=
1
.
05
*
0
.
05
<
(
lum
+
0
.
05
)
*
*
2
?
0
:
255
;
let
result
=
[
channel
channel
channel
255
]
;
while
(
!
Object
.
getOwnPropertyDescriptor
(
values
"
badgeDefaultColor
"
)
)
{
values
=
Object
.
getPrototypeOf
(
values
)
;
}
values
.
badgeDefaultColor
=
result
;
return
result
;
}
isShownForTab
(
tab
)
{
return
this
.
getProperty
(
tab
"
enabled
"
)
;
}
api
(
context
)
{
return
{
.
.
.
super
.
api
(
context
)
enable
:
(
.
.
.
args
)
=
>
this
.
enable
(
.
.
.
args
)
disable
:
(
.
.
.
args
)
=
>
this
.
disable
(
.
.
.
args
)
isEnabled
:
details
=
>
{
return
this
.
getPropertyFromDetails
(
details
"
enabled
"
)
;
}
setBadgeText
:
details
=
>
{
this
.
setPropertyFromDetails
(
details
"
badgeText
"
details
.
text
)
;
}
getBadgeText
:
details
=
>
{
return
this
.
getPropertyFromDetails
(
details
"
badgeText
"
)
;
}
setBadgeBackgroundColor
:
details
=
>
{
let
color
=
parseColor
(
details
.
color
"
background
"
)
;
let
values
=
this
.
setPropertyFromDetails
(
details
"
badgeBackgroundColor
"
color
)
;
if
(
color
=
=
=
null
)
{
delete
values
.
badgeDefaultColor
;
}
else
{
values
.
badgeDefaultColor
=
null
;
}
}
getBadgeBackgroundColor
:
details
=
>
{
return
this
.
getPropertyFromDetails
(
details
"
badgeBackgroundColor
"
)
;
}
setBadgeTextColor
:
details
=
>
{
let
color
=
parseColor
(
details
.
color
"
text
"
)
;
this
.
setPropertyFromDetails
(
details
"
badgeTextColor
"
color
)
;
}
getBadgeTextColor
:
details
=
>
{
let
target
=
this
.
getTargetFromDetails
(
details
)
;
let
values
=
this
.
getContextData
(
target
)
;
return
this
.
getTextColor
(
values
)
;
}
}
;
}
}
