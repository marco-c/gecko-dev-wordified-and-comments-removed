"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionManagement
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
E10SUtils
"
"
resource
:
/
/
/
modules
/
E10SUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionUtils
"
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
(
)
=
>
ExtensionUtils
.
getConsole
(
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
UUIDMap
"
(
)
=
>
{
let
{
UUIDMap
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
{
}
)
;
return
UUIDMap
;
}
)
;
const
{
appinfo
}
=
Services
;
const
isParentProcess
=
appinfo
.
processType
=
=
=
appinfo
.
PROCESS_TYPE_DEFAULT
;
var
ExtensionManagement
;
var
APIs
=
{
apis
:
new
Map
(
)
register
(
namespace
schema
script
)
{
if
(
this
.
apis
.
has
(
namespace
)
)
{
throw
new
Error
(
API
namespace
already
exists
:
{
namespace
}
)
;
}
this
.
apis
.
set
(
namespace
{
schema
script
}
)
;
}
unregister
(
namespace
)
{
if
(
!
this
.
apis
.
has
(
namespace
)
)
{
throw
new
Error
(
API
namespace
does
not
exist
:
{
namespace
}
)
;
}
this
.
apis
.
delete
(
namespace
)
;
}
}
;
function
getURLForExtension
(
id
path
=
"
"
)
{
let
uuid
=
UUIDMap
.
get
(
id
false
)
;
if
(
!
uuid
)
{
Cu
.
reportError
(
Called
getURLForExtension
on
unmapped
extension
{
id
}
)
;
return
null
;
}
return
moz
-
extension
:
/
/
{
uuid
}
/
{
path
}
;
}
var
Service
=
{
initialized
:
false
uuidMap
:
new
Map
(
)
init
(
)
{
let
aps
=
Cc
[
"
mozilla
.
org
/
addons
/
policy
-
service
;
1
"
]
.
getService
(
Ci
.
nsIAddonPolicyService
)
;
aps
=
aps
.
wrappedJSObject
;
this
.
aps
=
aps
;
aps
.
setExtensionURILoadCallback
(
this
.
extensionURILoadableByAnyone
.
bind
(
this
)
)
;
aps
.
setExtensionURIToAddonIdCallback
(
this
.
extensionURIToAddonID
.
bind
(
this
)
)
;
}
startupExtension
(
uuid
uri
extension
)
{
if
(
!
this
.
initialized
)
{
this
.
initialized
=
true
;
this
.
init
(
)
;
}
let
handler
=
Services
.
io
.
getProtocolHandler
(
"
moz
-
extension
"
)
;
handler
.
QueryInterface
(
Ci
.
nsISubstitutingProtocolHandler
)
;
handler
.
setSubstitution
(
uuid
uri
)
;
this
.
uuidMap
.
set
(
uuid
extension
)
;
this
.
aps
.
setAddonHasPermissionCallback
(
extension
.
id
extension
.
hasPermission
.
bind
(
extension
)
)
;
this
.
aps
.
setAddonLoadURICallback
(
extension
.
id
this
.
checkAddonMayLoad
.
bind
(
this
extension
)
)
;
this
.
aps
.
setAddonLocalizeCallback
(
extension
.
id
extension
.
localize
.
bind
(
extension
)
)
;
this
.
aps
.
setAddonCSP
(
extension
.
id
extension
.
manifest
.
content_security_policy
)
;
this
.
aps
.
setBackgroundPageUrlCallback
(
uuid
this
.
generateBackgroundPageUrl
.
bind
(
this
extension
)
)
;
}
shutdownExtension
(
uuid
)
{
let
extension
=
this
.
uuidMap
.
get
(
uuid
)
;
if
(
!
extension
)
{
return
;
}
this
.
uuidMap
.
delete
(
uuid
)
;
this
.
aps
.
setAddonHasPermissionCallback
(
extension
.
id
null
)
;
this
.
aps
.
setAddonLoadURICallback
(
extension
.
id
null
)
;
this
.
aps
.
setAddonLocalizeCallback
(
extension
.
id
null
)
;
this
.
aps
.
setAddonCSP
(
extension
.
id
null
)
;
this
.
aps
.
setBackgroundPageUrlCallback
(
uuid
null
)
;
let
handler
=
Services
.
io
.
getProtocolHandler
(
"
moz
-
extension
"
)
;
handler
.
QueryInterface
(
Ci
.
nsISubstitutingProtocolHandler
)
;
handler
.
setSubstitution
(
uuid
null
)
;
}
extensionURILoadableByAnyone
(
uri
)
{
let
uuid
=
uri
.
host
;
let
extension
=
this
.
uuidMap
.
get
(
uuid
)
;
if
(
!
extension
|
|
!
extension
.
webAccessibleResources
)
{
return
false
;
}
let
path
=
uri
.
QueryInterface
(
Ci
.
nsIURL
)
.
filePath
;
return
extension
.
webAccessibleResources
.
some
(
res
=
>
res
.
matches
(
path
)
)
;
}
checkAddonMayLoad
(
extension
uri
explicit
=
false
)
{
return
extension
.
whiteListedHosts
.
matchesIgnoringPath
(
uri
explicit
)
;
}
generateBackgroundPageUrl
(
extension
)
{
let
background_scripts
=
(
extension
.
manifest
.
background
&
&
extension
.
manifest
.
background
.
scripts
)
;
if
(
!
background_scripts
)
{
return
;
}
let
html
=
"
<
!
DOCTYPE
html
>
\
n
<
html
>
\
n
<
body
>
\
n
"
;
for
(
let
script
of
background_scripts
)
{
script
=
script
.
replace
(
/
"
/
g
"
&
quot
;
"
)
;
html
+
=
<
script
src
=
"
{
script
}
"
>
<
/
script
>
\
n
;
}
html
+
=
"
<
/
body
>
\
n
<
/
html
>
\
n
"
;
return
"
data
:
text
/
html
;
charset
=
utf
-
8
"
+
encodeURIComponent
(
html
)
;
}
extensionURIToAddonID
(
uri
)
{
let
uuid
=
uri
.
host
;
let
extension
=
this
.
uuidMap
.
get
(
uuid
)
;
return
extension
?
extension
.
id
:
undefined
;
}
}
;
let
cacheInvalidated
=
0
;
function
onCacheInvalidate
(
)
{
cacheInvalidated
+
+
;
}
Services
.
obs
.
addObserver
(
onCacheInvalidate
"
startupcache
-
invalidate
"
)
;
ExtensionManagement
=
{
get
cacheInvalidated
(
)
{
return
cacheInvalidated
;
}
get
isExtensionProcess
(
)
{
if
(
this
.
useRemoteWebExtensions
)
{
return
appinfo
.
remoteType
=
=
=
E10SUtils
.
EXTENSION_REMOTE_TYPE
;
}
return
isParentProcess
;
}
startupExtension
:
Service
.
startupExtension
.
bind
(
Service
)
shutdownExtension
:
Service
.
shutdownExtension
.
bind
(
Service
)
registerAPI
:
APIs
.
register
.
bind
(
APIs
)
unregisterAPI
:
APIs
.
unregister
.
bind
(
APIs
)
getURLForExtension
APIs
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
ExtensionManagement
"
useRemoteWebExtensions
"
"
extensions
.
webextensions
.
remote
"
false
)
;
