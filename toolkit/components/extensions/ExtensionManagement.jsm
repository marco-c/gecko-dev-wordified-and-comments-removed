"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionManagement
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
var
Frames
=
{
topWindowIds
:
new
Set
(
)
init
(
)
{
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
)
{
return
;
}
Services
.
mm
.
addMessageListener
(
"
Extension
:
TopWindowID
"
this
)
;
Services
.
mm
.
addMessageListener
(
"
Extension
:
RemoveTopWindowID
"
this
true
)
;
}
isTopWindowId
(
windowId
)
{
return
this
.
topWindowIds
.
has
(
windowId
)
;
}
getId
(
windowId
)
{
if
(
this
.
isTopWindowId
(
windowId
)
)
{
return
0
;
}
else
if
(
windowId
=
=
0
)
{
return
-
1
;
}
else
{
return
windowId
;
}
}
getParentId
(
parentWindowId
windowId
)
{
if
(
parentWindowId
=
=
windowId
)
{
return
-
1
;
}
return
this
.
getId
(
parentWindowId
)
;
}
receiveMessage
(
{
name
data
}
)
{
switch
(
name
)
{
case
"
Extension
:
TopWindowID
"
:
this
.
topWindowIds
.
add
(
data
.
windowId
)
;
break
;
case
"
Extension
:
RemoveTopWindowID
"
:
this
.
topWindowIds
.
delete
(
data
.
windowId
)
;
break
;
}
}
}
;
Frames
.
init
(
)
;
var
Scripts
=
{
scripts
:
new
Set
(
)
register
(
script
)
{
this
.
scripts
.
add
(
script
)
;
}
getScripts
(
)
{
return
this
.
scripts
;
}
}
;
var
Schemas
=
{
schemas
:
new
Set
(
)
register
(
schema
)
{
this
.
schemas
.
add
(
schema
)
;
}
getSchemas
(
)
{
return
this
.
schemas
;
}
}
;
var
Service
=
{
initialized
:
false
uuidMap
:
new
Map
(
)
init
(
)
{
let
aps
=
Cc
[
"
mozilla
.
org
/
addons
/
policy
-
service
;
1
"
]
.
getService
(
Ci
.
nsIAddonPolicyService
)
;
aps
=
aps
.
wrappedJSObject
;
this
.
aps
=
aps
;
aps
.
setExtensionURILoadCallback
(
this
.
extensionURILoadableByAnyone
.
bind
(
this
)
)
;
aps
.
setExtensionURIToAddonIdCallback
(
this
.
extensionURIToAddonID
.
bind
(
this
)
)
;
}
startupExtension
(
uuid
uri
extension
)
{
if
(
!
this
.
initialized
)
{
this
.
initialized
=
true
;
this
.
init
(
)
;
}
if
(
AppConstants
.
MOZ_B2G
&
&
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
&
&
uri
.
spec
.
startsWith
(
"
jar
:
file
:
/
/
"
)
)
{
uri
=
Services
.
io
.
newURI
(
"
jar
:
remoteopen
"
+
uri
.
spec
.
substr
(
"
jar
:
"
.
length
)
null
null
)
;
}
let
handler
=
Services
.
io
.
getProtocolHandler
(
"
moz
-
extension
"
)
;
handler
.
QueryInterface
(
Ci
.
nsISubstitutingProtocolHandler
)
;
handler
.
setSubstitution
(
uuid
uri
)
;
this
.
uuidMap
.
set
(
uuid
extension
)
;
this
.
aps
.
setAddonLoadURICallback
(
extension
.
id
this
.
checkAddonMayLoad
.
bind
(
this
extension
)
)
;
this
.
aps
.
setAddonLocalizeCallback
(
extension
.
id
extension
.
localize
.
bind
(
extension
)
)
;
this
.
aps
.
setAddonCSP
(
extension
.
id
extension
.
manifest
.
content_security_policy
)
;
}
shutdownExtension
(
uuid
)
{
let
extension
=
this
.
uuidMap
.
get
(
uuid
)
;
this
.
uuidMap
.
delete
(
uuid
)
;
this
.
aps
.
setAddonLoadURICallback
(
extension
.
id
null
)
;
this
.
aps
.
setAddonLocalizeCallback
(
extension
.
id
null
)
;
this
.
aps
.
setAddonCSP
(
extension
.
id
null
)
;
let
handler
=
Services
.
io
.
getProtocolHandler
(
"
moz
-
extension
"
)
;
handler
.
QueryInterface
(
Ci
.
nsISubstitutingProtocolHandler
)
;
handler
.
setSubstitution
(
uuid
null
)
;
}
extensionURILoadableByAnyone
(
uri
)
{
let
uuid
=
uri
.
host
;
let
extension
=
this
.
uuidMap
.
get
(
uuid
)
;
if
(
!
extension
|
|
!
extension
.
webAccessibleResources
)
{
return
false
;
}
let
path
=
uri
.
QueryInterface
(
Ci
.
nsIURL
)
.
filePath
;
if
(
path
.
length
>
0
&
&
path
[
0
]
=
=
"
/
"
)
{
path
=
path
.
substr
(
1
)
;
}
return
extension
.
webAccessibleResources
.
matches
(
path
)
;
}
checkAddonMayLoad
(
extension
uri
)
{
return
extension
.
whiteListedHosts
.
matchesIgnoringPath
(
uri
)
;
}
extensionURIToAddonID
(
uri
)
{
let
uuid
=
uri
.
host
;
let
extension
=
this
.
uuidMap
.
get
(
uuid
)
;
return
extension
?
extension
.
id
:
undefined
;
}
}
;
function
getAddonIdForWindow
(
window
)
{
let
principal
=
window
.
document
.
nodePrincipal
;
return
principal
.
originAttributes
.
addonId
;
}
const
API_LEVELS
=
Object
.
freeze
(
{
NO_PRIVILEGES
:
0
CONTENTSCRIPT_PRIVILEGES
:
1
FULL_PRIVILEGES
:
2
}
)
;
function
getAPILevelForWindow
(
window
addonId
)
{
const
{
NO_PRIVILEGES
CONTENTSCRIPT_PRIVILEGES
FULL_PRIVILEGES
}
=
API_LEVELS
;
if
(
!
addonId
|
|
getAddonIdForWindow
(
window
)
!
=
addonId
)
{
return
NO_PRIVILEGES
;
}
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
)
{
return
CONTENTSCRIPT_PRIVILEGES
;
}
let
docShell
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
;
if
(
docShell
.
sameTypeParent
)
{
let
parentWindow
=
docShell
.
sameTypeParent
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
let
parentDocument
=
parentWindow
.
document
;
let
parentIsSystemPrincipal
=
Services
.
scriptSecurityManager
.
isSystemPrincipal
(
parentDocument
.
nodePrincipal
)
;
if
(
parentDocument
.
location
.
href
=
=
"
about
:
addons
"
&
&
parentIsSystemPrincipal
)
{
return
FULL_PRIVILEGES
;
}
return
CONTENTSCRIPT_PRIVILEGES
;
}
return
FULL_PRIVILEGES
;
}
this
.
ExtensionManagement
=
{
startupExtension
:
Service
.
startupExtension
.
bind
(
Service
)
shutdownExtension
:
Service
.
shutdownExtension
.
bind
(
Service
)
registerScript
:
Scripts
.
register
.
bind
(
Scripts
)
getScripts
:
Scripts
.
getScripts
.
bind
(
Scripts
)
registerSchema
:
Schemas
.
register
.
bind
(
Schemas
)
getSchemas
:
Schemas
.
getSchemas
.
bind
(
Schemas
)
getFrameId
:
Frames
.
getId
.
bind
(
Frames
)
getParentFrameId
:
Frames
.
getParentId
.
bind
(
Frames
)
getAddonIdForWindow
getAPILevelForWindow
API_LEVELS
}
;
