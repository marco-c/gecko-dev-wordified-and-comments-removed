#
include
"
mozilla
/
extensions
/
ExtensionsChild
.
h
"
#
include
"
mozilla
/
extensions
/
ExtensionsParent
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
InProcessChild
.
h
"
#
include
"
mozilla
/
dom
/
InProcessParent
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
nsXULAppAPI
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
namespace
extensions
{
NS_IMPL_ISUPPORTS
(
ExtensionsChild
nsIObserver
)
ExtensionsChild
&
ExtensionsChild
:
:
Get
(
)
{
static
RefPtr
<
ExtensionsChild
>
sInstance
;
if
(
MOZ_UNLIKELY
(
!
sInstance
)
)
{
sInstance
=
new
ExtensionsChild
(
)
;
sInstance
-
>
Init
(
)
;
ClearOnShutdown
(
&
sInstance
)
;
}
return
*
sInstance
;
}
already_AddRefed
<
ExtensionsChild
>
ExtensionsChild
:
:
GetSingleton
(
)
{
return
do_AddRef
(
&
Get
(
)
)
;
}
void
ExtensionsChild
:
:
Init
(
)
{
if
(
XRE_IsContentProcess
(
)
)
{
ContentChild
:
:
GetSingleton
(
)
-
>
SendPExtensionsConstructor
(
this
)
;
}
else
{
InProcessChild
*
ipChild
=
InProcessChild
:
:
Singleton
(
)
;
InProcessParent
*
ipParent
=
InProcessParent
:
:
Singleton
(
)
;
if
(
!
ipChild
|
|
!
ipParent
)
{
return
;
}
RefPtr
parent
=
new
ExtensionsParent
(
)
;
ManagedEndpoint
<
PExtensionsParent
>
endpoint
=
ipChild
-
>
OpenPExtensionsEndpoint
(
this
)
;
ipParent
-
>
BindPExtensionsEndpoint
(
std
:
:
move
(
endpoint
)
parent
)
;
}
}
void
ExtensionsChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
}
NS_IMETHODIMP
ExtensionsChild
:
:
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
{
MOZ_ASSERT
(
strcmp
(
aTopic
"
app
-
startup
"
)
=
=
0
)
;
return
NS_OK
;
}
}
}
