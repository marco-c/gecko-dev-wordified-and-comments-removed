"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
MessageChannel
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionUtils
"
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
MessageManagerProxy
"
(
)
=
>
ExtensionUtils
.
MessageManagerProxy
)
;
class
FilteringMessageManager
{
constructor
(
messageName
callback
messageManager
)
{
this
.
messageName
=
messageName
;
this
.
callback
=
callback
;
this
.
messageManager
=
messageManager
;
this
.
messageManager
.
addMessageListener
(
this
.
messageName
this
true
)
;
this
.
handlers
=
new
Map
(
)
;
}
receiveMessage
(
{
data
target
}
)
{
let
handlers
=
Array
.
from
(
this
.
getHandlers
(
data
.
messageName
data
.
sender
data
.
recipient
)
)
;
data
.
target
=
target
;
this
.
callback
(
handlers
data
)
;
}
*
getHandlers
(
messageName
sender
recipient
)
{
let
handlers
=
this
.
handlers
.
get
(
messageName
)
|
|
new
Set
(
)
;
for
(
let
handler
of
handlers
)
{
if
(
MessageChannel
.
matchesFilter
(
handler
.
messageFilterStrict
|
|
{
}
recipient
)
&
&
MessageChannel
.
matchesFilter
(
handler
.
messageFilterPermissive
|
|
{
}
recipient
false
)
&
&
(
!
handler
.
filterMessage
|
|
handler
.
filterMessage
(
sender
recipient
)
)
)
{
yield
handler
;
}
}
}
addHandler
(
messageName
handler
)
{
if
(
!
this
.
handlers
.
has
(
messageName
)
)
{
this
.
handlers
.
set
(
messageName
new
Set
(
)
)
;
}
this
.
handlers
.
get
(
messageName
)
.
add
(
handler
)
;
}
removeHandler
(
messageName
handler
)
{
this
.
handlers
.
get
(
messageName
)
.
delete
(
handler
)
;
}
}
class
FilteringMessageManagerMap
extends
Map
{
constructor
(
messageName
callback
)
{
super
(
)
;
this
.
messageName
=
messageName
;
this
.
callback
=
callback
;
}
get
(
target
)
{
if
(
this
.
has
(
target
)
)
{
return
super
.
get
(
target
)
;
}
let
broker
=
new
FilteringMessageManager
(
this
.
messageName
this
.
callback
target
)
;
this
.
set
(
target
broker
)
;
if
(
target
instanceof
Ci
.
nsIDOMEventTarget
)
{
let
onUnload
=
event
=
>
{
target
.
removeEventListener
(
"
unload
"
onUnload
)
;
this
.
delete
(
target
)
;
}
;
target
.
addEventListener
(
"
unload
"
onUnload
)
;
}
return
broker
;
}
}
const
MESSAGE_MESSAGE
=
"
MessageChannel
:
Message
"
;
const
MESSAGE_RESPONSE
=
"
MessageChannel
:
Response
"
;
this
.
MessageChannel
=
{
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
close
"
false
)
;
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
disconnect
"
false
)
;
this
.
messageManagers
=
new
FilteringMessageManagerMap
(
MESSAGE_MESSAGE
this
.
_handleMessage
.
bind
(
this
)
)
;
this
.
responseManagers
=
new
FilteringMessageManagerMap
(
MESSAGE_RESPONSE
this
.
_handleResponse
.
bind
(
this
)
)
;
this
.
pendingResponses
=
new
Set
(
)
;
this
.
abortedResponses
=
new
ExtensionUtils
.
LimitedSet
(
30
)
;
}
RESULT_SUCCESS
:
0
RESULT_DISCONNECTED
:
1
RESULT_NO_HANDLER
:
2
RESULT_MULTIPLE_HANDLERS
:
3
RESULT_ERROR
:
4
RESULT_NO_RESPONSE
:
5
REASON_DISCONNECTED
:
{
result
:
1
message
:
"
Message
manager
disconnected
"
}
RESPONSE_SINGLE
:
0
RESPONSE_FIRST
:
1
RESPONSE_ALL
:
2
RESPONSE_NONE
:
3
setupMessageManagers
(
messageManagers
)
{
for
(
let
mm
of
messageManagers
)
{
this
.
messageManagers
.
get
(
mm
)
;
}
}
matchesFilter
(
filter
data
strict
=
true
)
{
if
(
strict
)
{
return
Object
.
keys
(
filter
)
.
every
(
key
=
>
{
return
key
in
data
&
&
data
[
key
]
=
=
=
filter
[
key
]
;
}
)
;
}
return
Object
.
keys
(
filter
)
.
every
(
key
=
>
{
return
!
(
key
in
data
)
|
|
data
[
key
]
=
=
=
filter
[
key
]
;
}
)
;
}
addListener
(
targets
messageName
handler
)
{
for
(
let
target
of
[
]
.
concat
(
targets
)
)
{
this
.
messageManagers
.
get
(
target
)
.
addHandler
(
messageName
handler
)
;
}
}
removeListener
(
targets
messageName
handler
)
{
for
(
let
target
of
[
]
.
concat
(
targets
)
)
{
if
(
this
.
messageManagers
.
has
(
target
)
)
{
this
.
messageManagers
.
get
(
target
)
.
removeHandler
(
messageName
handler
)
;
}
}
}
sendMessage
(
target
messageName
data
options
=
{
}
)
{
let
sender
=
options
.
sender
|
|
{
}
;
let
recipient
=
options
.
recipient
|
|
{
}
;
let
responseType
=
options
.
responseType
|
|
this
.
RESPONSE_SINGLE
;
let
channelId
=
ExtensionUtils
.
getUniqueId
(
)
;
let
message
=
{
messageName
channelId
sender
recipient
data
responseType
}
;
if
(
responseType
=
=
this
.
RESPONSE_NONE
)
{
try
{
target
.
sendAsyncMessage
(
MESSAGE_MESSAGE
message
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
Promise
.
reject
(
e
)
;
}
return
Promise
.
resolve
(
)
;
}
let
deferred
=
PromiseUtils
.
defer
(
)
;
deferred
.
sender
=
recipient
;
deferred
.
messageManager
=
target
;
this
.
_addPendingResponse
(
deferred
)
;
let
broker
=
this
.
responseManagers
.
get
(
target
)
;
broker
.
addHandler
(
channelId
deferred
)
;
let
cleanup
=
(
)
=
>
{
broker
.
removeHandler
(
channelId
deferred
)
;
}
;
deferred
.
promise
.
then
(
cleanup
cleanup
)
;
try
{
target
.
sendAsyncMessage
(
MESSAGE_MESSAGE
message
)
;
}
catch
(
e
)
{
deferred
.
reject
(
e
)
;
}
return
deferred
.
promise
;
}
_callHandlers
(
handlers
data
)
{
let
responseType
=
data
.
responseType
;
if
(
handlers
.
length
=
=
0
&
&
responseType
!
=
this
.
RESPONSE_ALL
)
{
return
Promise
.
reject
(
{
result
:
MessageChannel
.
RESULT_NO_HANDLER
message
:
"
No
matching
message
handler
"
}
)
;
}
if
(
responseType
=
=
this
.
RESPONSE_SINGLE
)
{
if
(
handlers
.
length
>
1
)
{
return
Promise
.
reject
(
{
result
:
MessageChannel
.
RESULT_MULTIPLE_HANDLERS
message
:
Multiple
matching
handlers
for
{
data
.
messageName
}
}
)
;
}
return
new
Promise
(
resolve
=
>
{
resolve
(
handlers
[
0
]
.
receiveMessage
(
data
)
)
;
}
)
;
}
let
responses
=
handlers
.
map
(
handler
=
>
{
try
{
return
handler
.
receiveMessage
(
data
)
;
}
catch
(
e
)
{
return
Promise
.
reject
(
e
)
;
}
}
)
;
responses
=
responses
.
filter
(
response
=
>
response
!
=
=
undefined
)
;
switch
(
responseType
)
{
case
this
.
RESPONSE_FIRST
:
if
(
responses
.
length
=
=
0
)
{
return
Promise
.
reject
(
{
result
:
MessageChannel
.
RESULT_NO_RESPONSE
message
:
"
No
handler
returned
a
response
"
}
)
;
}
return
Promise
.
race
(
responses
)
;
case
this
.
RESPONSE_ALL
:
return
Promise
.
all
(
responses
)
;
}
return
Promise
.
reject
(
{
message
:
"
Invalid
response
type
"
}
)
;
}
_handleMessage
(
handlers
data
)
{
if
(
data
.
responseType
=
=
this
.
RESPONSE_NONE
)
{
handlers
.
forEach
(
handler
=
>
{
new
Promise
(
resolve
=
>
{
resolve
(
handler
.
receiveMessage
(
data
)
)
;
}
)
.
catch
(
e
=
>
{
Cu
.
reportError
(
e
.
stack
?
{
e
}
\
n
{
e
.
stack
}
:
e
.
message
|
|
e
)
;
}
)
;
}
)
;
return
;
}
let
target
=
new
MessageManagerProxy
(
data
.
target
)
;
let
deferred
=
{
sender
:
data
.
sender
messageManager
:
target
}
;
deferred
.
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
deferred
.
reject
=
reject
;
this
.
_callHandlers
(
handlers
data
)
.
then
(
resolve
reject
)
;
}
)
.
then
(
value
=
>
{
let
response
=
{
result
:
this
.
RESULT_SUCCESS
messageName
:
data
.
channelId
recipient
:
{
}
value
}
;
target
.
sendAsyncMessage
(
MESSAGE_RESPONSE
response
)
;
}
error
=
>
{
if
(
target
.
isDisconnected
)
{
if
(
error
.
result
!
=
=
this
.
RESULT_DISCONNECTED
&
&
error
.
result
!
=
=
this
.
RESULT_NO_RESPONSE
)
{
Cu
.
reportError
(
Cu
.
getClassName
(
error
false
)
=
=
=
"
Object
"
?
error
.
message
:
error
)
;
}
return
;
}
let
response
=
{
result
:
this
.
RESULT_ERROR
messageName
:
data
.
channelId
recipient
:
{
}
error
:
{
}
}
;
if
(
error
&
&
typeof
(
error
)
=
=
"
object
"
)
{
if
(
error
.
result
)
{
response
.
result
=
error
.
result
;
}
for
(
let
key
of
[
"
fileName
"
"
filename
"
"
lineNumber
"
"
columnNumber
"
"
message
"
"
stack
"
"
result
"
]
)
{
if
(
key
in
error
)
{
response
.
error
[
key
]
=
error
[
key
]
;
}
}
}
target
.
sendAsyncMessage
(
MESSAGE_RESPONSE
response
)
;
}
)
.
catch
(
e
=
>
{
Cu
.
reportError
(
e
)
;
}
)
.
then
(
(
)
=
>
{
target
.
dispose
(
)
;
}
)
;
this
.
_addPendingResponse
(
deferred
)
;
}
_handleResponse
(
handlers
data
)
{
if
(
handlers
.
length
=
=
0
)
{
if
(
this
.
abortedResponses
.
has
(
data
.
messageName
)
)
{
this
.
abortedResponses
.
delete
(
data
.
messageName
)
;
Services
.
console
.
logStringMessage
(
Ignoring
response
to
aborted
listener
for
{
data
.
messageName
}
)
;
}
else
{
Cu
.
reportError
(
No
matching
message
response
handler
for
{
data
.
messageName
}
)
;
}
}
else
if
(
handlers
.
length
>
1
)
{
Cu
.
reportError
(
Multiple
matching
response
handlers
for
{
data
.
messageName
}
)
;
}
else
if
(
data
.
result
=
=
=
this
.
RESULT_SUCCESS
)
{
handlers
[
0
]
.
resolve
(
data
.
value
)
;
}
else
{
handlers
[
0
]
.
reject
(
data
.
error
)
;
}
}
_addPendingResponse
(
deferred
)
{
let
cleanup
=
(
)
=
>
{
this
.
pendingResponses
.
delete
(
deferred
)
;
}
;
this
.
pendingResponses
.
add
(
deferred
)
;
deferred
.
promise
.
then
(
cleanup
cleanup
)
;
}
abortResponses
(
sender
reason
=
this
.
REASON_DISCONNECTED
)
{
for
(
let
response
of
this
.
pendingResponses
)
{
if
(
this
.
matchesFilter
(
sender
response
.
sender
)
)
{
this
.
abortedResponses
.
add
(
response
.
channelId
)
;
response
.
reject
(
reason
)
;
}
}
}
abortMessageManager
(
target
reason
)
{
for
(
let
response
of
this
.
pendingResponses
)
{
if
(
MessageManagerProxy
.
matches
(
response
.
messageManager
target
)
)
{
this
.
abortedResponses
.
add
(
response
.
channelId
)
;
response
.
reject
(
reason
)
;
}
}
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
message
-
manager
-
close
"
:
case
"
message
-
manager
-
disconnect
"
:
try
{
if
(
this
.
responseManagers
.
has
(
subject
)
)
{
this
.
abortMessageManager
(
subject
this
.
REASON_DISCONNECTED
)
;
}
}
finally
{
this
.
responseManagers
.
delete
(
subject
)
;
this
.
messageManagers
.
delete
(
subject
)
;
}
break
;
}
}
}
;
MessageChannel
.
init
(
)
;
