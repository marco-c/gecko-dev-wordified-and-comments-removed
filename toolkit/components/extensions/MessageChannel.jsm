"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
MessageChannel
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
class
FilteringMessageManager
{
constructor
(
messageName
callback
messageManager
)
{
this
.
messageName
=
messageName
;
this
.
callback
=
callback
;
this
.
messageManager
=
messageManager
;
this
.
messageManager
.
addMessageListener
(
this
.
messageName
this
)
;
this
.
handlers
=
new
Map
(
)
;
}
receiveMessage
(
{
data
target
}
)
{
let
handlers
=
Array
.
from
(
this
.
getHandlers
(
data
.
messageName
data
.
recipient
)
)
;
let
result
=
{
}
;
if
(
handlers
.
length
=
=
0
)
{
result
.
error
=
{
result
:
MessageChannel
.
RESULT_NO_HANDLER
message
:
"
No
matching
message
handler
"
}
;
}
else
if
(
handlers
.
length
>
1
)
{
result
.
error
=
{
result
:
MessageChannel
.
RESULT_MULTIPLE_HANDLERS
message
:
Multiple
matching
handlers
for
{
data
.
messageName
}
}
;
}
else
{
result
.
handler
=
handlers
[
0
]
;
}
data
.
target
=
target
;
this
.
callback
(
result
data
)
;
}
*
getHandlers
(
messageName
recipient
)
{
let
handlers
=
this
.
handlers
.
get
(
messageName
)
|
|
new
Set
(
)
;
for
(
let
handler
of
handlers
)
{
if
(
MessageChannel
.
matchesFilter
(
handler
.
messageFilter
recipient
)
)
{
yield
handler
;
}
}
}
addHandler
(
messageName
handler
)
{
if
(
!
this
.
handlers
.
has
(
messageName
)
)
{
this
.
handlers
.
set
(
messageName
new
Set
(
)
)
;
}
this
.
handlers
.
get
(
messageName
)
.
add
(
handler
)
;
}
removeHandler
(
messageName
handler
)
{
this
.
handlers
.
get
(
messageName
)
.
delete
(
handler
)
;
}
}
class
FilteringMessageManagerMap
extends
Map
{
constructor
(
messageName
callback
)
{
super
(
)
;
this
.
messageName
=
messageName
;
this
.
callback
=
callback
;
}
get
(
target
)
{
if
(
this
.
has
(
target
)
)
{
return
super
.
get
(
target
)
;
}
let
broker
=
new
FilteringMessageManager
(
this
.
messageName
this
.
callback
target
)
;
this
.
set
(
target
broker
)
;
if
(
target
instanceof
Ci
.
nsIDOMEventTarget
)
{
let
onUnload
=
event
=
>
{
target
.
removeEventListener
(
"
unload
"
onUnload
)
;
this
.
delete
(
target
)
;
}
;
target
.
addEventListener
(
"
unload
"
onUnload
)
;
}
return
broker
;
}
}
const
MESSAGE_MESSAGE
=
"
MessageChannel
:
Message
"
;
const
MESSAGE_RESPONSE
=
"
MessageChannel
:
Response
"
;
let
gChannelId
=
0
;
this
.
MessageChannel
=
{
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
close
"
false
)
;
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
disconnect
"
false
)
;
this
.
messageManagers
=
new
FilteringMessageManagerMap
(
MESSAGE_MESSAGE
this
.
_handleMessage
.
bind
(
this
)
)
;
this
.
responseManagers
=
new
FilteringMessageManagerMap
(
MESSAGE_RESPONSE
this
.
_handleResponse
.
bind
(
this
)
)
;
this
.
pendingResponses
=
new
Set
(
)
;
}
RESULT_SUCCESS
:
0
RESULT_DISCONNECTED
:
1
RESULT_NO_HANDLER
:
2
RESULT_MULTIPLE_HANDLERS
:
3
RESULT_ERROR
:
4
REASON_DISCONNECTED
:
{
result
:
this
.
RESULT_DISCONNECTED
message
:
"
Message
manager
disconnected
"
}
matchesFilter
(
filter
data
)
{
return
Object
.
keys
(
filter
)
.
every
(
key
=
>
{
return
key
in
data
&
&
data
[
key
]
=
=
=
filter
[
key
]
;
}
)
;
}
addListener
(
target
messageName
handler
)
{
this
.
messageManagers
.
get
(
target
)
.
addHandler
(
messageName
handler
)
;
}
removeListener
(
target
messageName
handler
)
{
this
.
messageManagers
.
get
(
target
)
.
removeListener
(
messageName
handler
)
;
}
sendMessage
(
target
messageName
data
recipient
=
{
}
sender
=
{
}
)
{
let
channelId
=
gChannelId
+
+
;
let
message
=
{
messageName
channelId
sender
recipient
data
}
;
let
deferred
=
PromiseUtils
.
defer
(
)
;
deferred
.
messageFilter
=
{
}
;
deferred
.
sender
=
recipient
;
deferred
.
messageManager
=
target
;
this
.
_addPendingResponse
(
deferred
)
;
let
broker
=
this
.
responseManagers
.
get
(
target
)
;
broker
.
addHandler
(
channelId
deferred
)
;
let
cleanup
=
(
)
=
>
{
broker
.
removeHandler
(
channelId
deferred
)
;
}
;
deferred
.
promise
.
then
(
cleanup
cleanup
)
;
target
.
sendAsyncMessage
(
MESSAGE_MESSAGE
message
)
;
return
deferred
.
promise
;
}
_handleMessage
(
{
handler
error
}
data
)
{
let
{
target
}
=
data
;
if
(
!
(
target
instanceof
Ci
.
nsIMessageSender
)
)
{
target
=
target
.
messageManager
;
}
let
deferred
=
{
sender
:
data
.
sender
messageManager
:
target
}
;
deferred
.
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
deferred
.
reject
=
reject
;
if
(
handler
)
{
let
result
=
handler
.
receiveMessage
(
data
)
;
resolve
(
result
)
;
}
else
{
reject
(
error
)
;
}
}
)
.
then
(
value
=
>
{
let
response
=
{
result
:
this
.
RESULT_SUCCESS
messageName
:
data
.
channelId
recipient
:
{
}
value
}
;
target
.
sendAsyncMessage
(
MESSAGE_RESPONSE
response
)
;
}
error
=
>
{
let
response
=
{
result
:
this
.
RESULT_ERROR
messageName
:
data
.
channelId
recipient
:
{
}
error
}
;
if
(
error
&
&
typeof
(
error
)
=
=
"
object
"
)
{
if
(
error
.
result
)
{
response
.
result
=
error
.
result
;
}
}
target
.
sendAsyncMessage
(
MESSAGE_RESPONSE
response
)
;
}
)
;
this
.
_addPendingResponse
(
deferred
)
;
}
_handleResponse
(
{
handler
error
}
data
)
{
if
(
error
)
{
Cu
.
reportError
(
error
.
message
)
;
}
else
if
(
data
.
result
=
=
=
this
.
RESULT_SUCCESS
)
{
handler
.
resolve
(
data
.
value
)
;
}
else
{
handler
.
reject
(
data
)
;
}
}
_addPendingResponse
(
deferred
)
{
let
cleanup
=
(
)
=
>
{
this
.
pendingResponses
.
delete
(
deferred
)
;
}
;
this
.
pendingResponses
.
add
(
deferred
)
;
deferred
.
promise
.
then
(
cleanup
cleanup
)
;
}
abortResponses
(
sender
reason
=
this
.
REASON_DISCONNECTED
)
{
for
(
let
response
of
this
.
pendingResponses
)
{
if
(
this
.
matchesFilter
(
sender
response
.
sender
)
)
{
response
.
reject
(
reason
)
;
}
}
}
abortMessageManager
(
target
reason
)
{
for
(
let
response
of
this
.
pendingResponses
)
{
if
(
response
.
messageManager
=
=
=
target
)
{
response
.
reject
(
reason
)
;
}
}
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
message
-
manager
-
close
"
:
case
"
message
-
manager
-
disconnect
"
:
try
{
if
(
this
.
responseManagers
.
has
(
subject
)
)
{
this
.
abortMessageManager
(
subject
this
.
REASON_DISCONNECTED
)
;
}
}
finally
{
this
.
responseManagers
.
delete
(
subject
)
;
this
.
messageManagers
.
delete
(
subject
)
;
}
break
;
}
}
}
;
MessageChannel
.
init
(
)
;
