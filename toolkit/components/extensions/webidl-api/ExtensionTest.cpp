#
include
"
ExtensionTest
.
h
"
#
include
"
ExtensionEventManager
.
h
"
#
include
"
js
/
Equality
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
mozilla
/
dom
/
ExtensionTestBinding
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
js
/
RegExp
.
h
"
namespace
mozilla
{
namespace
extensions
{
bool
IsInAutomation
(
JSContext
*
aCx
JSObject
*
aGlobal
)
{
return
NS_IsMainThread
(
)
?
xpc
:
:
IsInAutomation
(
)
:
dom
:
:
WorkerGlobalScope
:
:
IsInAutomation
(
aCx
aGlobal
)
;
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ExtensionTest
)
;
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ExtensionTest
)
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
ExtensionTest
mGlobal
mExtensionBrowser
mOnMessageEventMgr
)
;
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ExtensionTest
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
ExtensionTest
:
:
ExtensionTest
(
nsIGlobalObject
*
aGlobal
ExtensionBrowser
*
aExtensionBrowser
)
:
mGlobal
(
aGlobal
)
mExtensionBrowser
(
aExtensionBrowser
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mGlobal
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mExtensionBrowser
)
;
}
bool
ExtensionTest
:
:
IsAllowed
(
JSContext
*
aCx
JSObject
*
aGlobal
)
{
if
(
PR_GetEnv
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
)
{
return
true
;
}
return
IsInAutomation
(
aCx
aGlobal
)
;
}
JSObject
*
ExtensionTest
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
ExtensionTest_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsIGlobalObject
*
ExtensionTest
:
:
GetParentObject
(
)
const
{
return
mGlobal
;
}
void
ExtensionTest
:
:
CallWebExtMethodAssertEq
(
JSContext
*
aCx
const
nsAString
&
aApiMethod
const
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aArgs
ErrorResult
&
aRv
)
{
uint32_t
argsCount
=
aArgs
.
Length
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
expectedVal
(
aCx
argsCount
>
0
?
aArgs
[
0
]
:
JS
:
:
UndefinedValue
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
actualVal
(
aCx
argsCount
>
1
?
aArgs
[
1
]
:
JS
:
:
UndefinedValue
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
messageVal
(
aCx
argsCount
>
2
?
aArgs
[
2
]
:
JS
:
:
UndefinedValue
(
)
)
;
bool
isEqual
;
if
(
NS_WARN_IF
(
!
JS
:
:
StrictlyEqual
(
aCx
actualVal
expectedVal
&
isEqual
)
)
)
{
ThrowUnexpectedError
(
aCx
aRv
)
;
return
;
}
JS
:
:
RootedString
expectedJSString
(
aCx
JS
:
:
ToString
(
aCx
expectedVal
)
)
;
JS
:
:
RootedString
actualJSString
(
aCx
JS
:
:
ToString
(
aCx
actualVal
)
)
;
JS
:
:
RootedString
messageJSString
(
aCx
JS
:
:
ToString
(
aCx
messageVal
)
)
;
nsString
expected
;
nsString
actual
;
nsString
message
;
if
(
NS_WARN_IF
(
!
AssignJSString
(
aCx
expected
expectedJSString
)
|
|
!
AssignJSString
(
aCx
actual
actualJSString
)
|
|
!
AssignJSString
(
aCx
message
messageJSString
)
)
)
{
ThrowUnexpectedError
(
aCx
aRv
)
;
return
;
}
if
(
!
isEqual
&
&
actual
.
Equals
(
expected
)
)
{
actual
.
AppendLiteral
(
"
(
different
)
"
)
;
}
if
(
NS_WARN_IF
(
!
dom
:
:
ToJSValue
(
aCx
expected
&
expectedVal
)
|
|
!
dom
:
:
ToJSValue
(
aCx
actual
&
actualVal
)
|
|
!
dom
:
:
ToJSValue
(
aCx
message
&
messageVal
)
)
)
{
ThrowUnexpectedError
(
aCx
aRv
)
;
return
;
}
dom
:
:
Sequence
<
JS
:
:
Value
>
args
;
if
(
NS_WARN_IF
(
!
args
.
AppendElement
(
expectedVal
fallible
)
|
|
!
args
.
AppendElement
(
actualVal
fallible
)
|
|
!
args
.
AppendElement
(
messageVal
fallible
)
)
)
{
ThrowUnexpectedError
(
aCx
aRv
)
;
return
;
}
CallWebExtMethodNoReturn
(
aCx
aApiMethod
args
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
bool
ExtensionTest
:
:
AssertMatchInternal
(
JSContext
*
aCx
const
JS
:
:
HandleValue
aActualValue
const
JS
:
:
HandleValue
aExpectedMatchValue
const
nsAString
&
aMessagePre
const
dom
:
:
Optional
<
nsAString
>
&
aMessage
UniquePtr
<
dom
:
:
SerializedStackHolder
>
aSerializedCallerStack
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JSString
*
>
actualToString
(
aCx
JS
:
:
ToString
(
aCx
aActualValue
)
)
;
NS_ENSURE_TRUE
(
actualToString
false
)
;
nsAutoJSString
actualString
;
NS_ENSURE_TRUE
(
actualString
.
init
(
aCx
actualToString
)
false
)
;
bool
matched
=
false
;
if
(
aExpectedMatchValue
.
isObject
(
)
)
{
JS
:
:
RootedObject
expectedMatchObj
(
aCx
&
aExpectedMatchValue
.
toObject
(
)
)
;
bool
isRegexp
;
NS_ENSURE_TRUE
(
JS
:
:
ObjectIsRegExp
(
aCx
expectedMatchObj
&
isRegexp
)
false
)
;
if
(
isRegexp
)
{
nsString
input
(
actualString
)
;
size_t
index
=
0
;
JS
:
:
RootedValue
rxResult
(
aCx
)
;
NS_ENSURE_TRUE
(
JS
:
:
ExecuteRegExpNoStatics
(
aCx
expectedMatchObj
input
.
BeginWriting
(
)
actualString
.
Length
(
)
&
index
true
&
rxResult
)
false
)
;
matched
=
!
rxResult
.
isNull
(
)
;
}
else
if
(
JS
:
:
IsCallable
(
expectedMatchObj
)
&
&
!
JS
:
:
IsConstructor
(
expectedMatchObj
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
retval
(
aCx
)
;
aRv
.
MightThrowJSException
(
)
;
if
(
!
JS
:
:
Call
(
aCx
JS
:
:
UndefinedHandleValue
expectedMatchObj
JS
:
:
HandleValueArray
(
aActualValue
)
&
retval
)
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
matched
=
false
;
}
else
{
matched
=
JS
:
:
ToBoolean
(
retval
)
;
}
}
else
if
(
JS
:
:
IsConstructor
(
expectedMatchObj
)
)
{
NS_ENSURE_TRUE
(
JS
:
:
InstanceofOperator
(
aCx
expectedMatchObj
aActualValue
&
matched
)
false
)
;
}
else
{
NS_ENSURE_TRUE
(
JS
:
:
StrictlyEqual
(
aCx
aActualValue
aExpectedMatchValue
&
matched
)
false
)
;
}
}
else
if
(
aExpectedMatchValue
.
isString
(
)
)
{
JS
:
:
Rooted
<
JSString
*
>
expectedToString
(
aCx
JS
:
:
ToString
(
aCx
aExpectedMatchValue
)
)
;
NS_ENSURE_TRUE
(
expectedToString
false
)
;
nsAutoJSString
expectedString
;
NS_ENSURE_TRUE
(
expectedString
.
init
(
aCx
expectedToString
)
false
)
;
JS
:
:
RootedValue
messageVal
(
aCx
)
;
if
(
aActualValue
.
isObject
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
actualValueObj
(
aCx
&
aActualValue
.
toObject
(
)
)
;
if
(
!
JS_GetProperty
(
aCx
actualValueObj
"
message
"
&
messageVal
)
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
matched
=
false
;
}
if
(
messageVal
.
isString
(
)
)
{
actualToString
.
set
(
messageVal
.
toString
(
)
)
;
NS_ENSURE_TRUE
(
actualString
.
init
(
aCx
actualToString
)
false
)
;
}
}
matched
=
expectedString
.
Equals
(
actualString
)
;
}
else
{
NS_ENSURE_TRUE
(
JS
:
:
StrictlyEqual
(
aCx
aActualValue
aExpectedMatchValue
&
matched
)
false
)
;
}
JS
:
:
Rooted
<
JSString
*
>
expectedToSource
(
aCx
JS_ValueToSource
(
aCx
aExpectedMatchValue
)
)
;
NS_ENSURE_TRUE
(
expectedToSource
false
)
;
nsAutoJSString
expectedSource
;
NS_ENSURE_TRUE
(
expectedSource
.
init
(
aCx
expectedToSource
)
false
)
;
nsString
message
;
message
.
AppendPrintf
(
"
%
s
to
match
'
%
s
'
got
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
aMessagePre
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
expectedSource
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
actualString
)
.
get
(
)
)
;
if
(
aMessage
.
WasPassed
(
)
)
{
message
.
AppendPrintf
(
"
:
%
s
"
NS_ConvertUTF16toUTF8
(
aMessage
.
Value
(
)
)
.
get
(
)
)
;
}
dom
:
:
Sequence
<
JS
:
:
Value
>
assertTrueArgs
;
JS
:
:
Rooted
<
JS
:
:
Value
>
arg0
(
aCx
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
arg1
(
aCx
)
;
NS_ENSURE_FALSE
(
!
dom
:
:
ToJSValue
(
aCx
matched
&
arg0
)
|
|
!
dom
:
:
ToJSValue
(
aCx
message
&
arg1
)
|
|
!
assertTrueArgs
.
AppendElement
(
arg0
fallible
)
|
|
!
assertTrueArgs
.
AppendElement
(
arg1
fallible
)
false
)
;
auto
request
=
CallFunctionNoReturn
(
u
"
assertTrue
"
_ns
)
;
IgnoredErrorResult
erv
;
if
(
aSerializedCallerStack
)
{
request
-
>
SetSerializedCallerStack
(
std
:
:
move
(
aSerializedCallerStack
)
)
;
}
request
-
>
Run
(
GetGlobalObject
(
)
aCx
assertTrueArgs
erv
)
;
NS_ENSURE_FALSE
(
erv
.
Failed
(
)
false
)
;
return
true
;
}
MOZ_CAN_RUN_SCRIPT
void
ExtensionTest
:
:
AssertThrows
(
JSContext
*
aCx
dom
:
:
Function
&
aFunction
const
JS
:
:
HandleValue
aExpectedError
const
dom
:
:
Optional
<
nsAString
>
&
aMessage
ErrorResult
&
aRv
)
{
ErrorResult
erv
;
erv
.
MightThrowJSException
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
ignoredRetval
(
aCx
)
;
aFunction
.
Call
(
{
}
&
ignoredRetval
erv
"
ExtensionTest
:
:
AssertThrows
"
dom
:
:
Function
:
:
eRethrowExceptions
)
;
bool
didThrow
=
false
;
JS
:
:
Rooted
<
JS
:
:
Value
>
exn
(
aCx
)
;
if
(
erv
.
MaybeSetPendingException
(
aCx
)
&
&
JS_GetPendingException
(
aCx
&
exn
)
)
{
JS_ClearPendingException
(
aCx
)
;
didThrow
=
true
;
}
if
(
!
didThrow
)
{
JS
:
:
Rooted
<
JSString
*
>
expectedErrorToSource
(
aCx
JS_ValueToSource
(
aCx
aExpectedError
)
)
;
if
(
NS_WARN_IF
(
!
expectedErrorToSource
)
)
{
ThrowUnexpectedError
(
aCx
aRv
)
;
return
;
}
nsAutoJSString
expectedErrorSource
;
if
(
NS_WARN_IF
(
!
expectedErrorSource
.
init
(
aCx
expectedErrorToSource
)
)
)
{
ThrowUnexpectedError
(
aCx
aRv
)
;
return
;
}
nsString
message
;
message
.
AppendPrintf
(
"
Function
did
not
throw
expected
error
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
expectedErrorSource
)
.
get
(
)
)
;
if
(
aMessage
.
WasPassed
(
)
)
{
message
.
AppendPrintf
(
"
:
%
s
"
NS_ConvertUTF16toUTF8
(
aMessage
.
Value
(
)
)
.
get
(
)
)
;
}
dom
:
:
Sequence
<
JS
:
:
Value
>
assertTrueArgs
;
JS
:
:
Rooted
<
JS
:
:
Value
>
arg0
(
aCx
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
arg1
(
aCx
)
;
if
(
NS_WARN_IF
(
!
dom
:
:
ToJSValue
(
aCx
false
&
arg0
)
|
|
!
dom
:
:
ToJSValue
(
aCx
message
&
arg1
)
|
|
!
assertTrueArgs
.
AppendElement
(
arg0
fallible
)
|
|
!
assertTrueArgs
.
AppendElement
(
arg1
fallible
)
)
)
{
ThrowUnexpectedError
(
aCx
aRv
)
;
return
;
}
CallWebExtMethodNoReturn
(
aCx
u
"
assertTrue
"
_ns
assertTrueArgs
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
ThrowUnexpectedError
(
aCx
aRv
)
;
}
return
;
}
if
(
NS_WARN_IF
(
!
AssertMatchInternal
(
aCx
exn
aExpectedError
u
"
Function
did
throw
expected
error
"
_ns
aMessage
nullptr
aRv
)
)
)
{
ThrowUnexpectedError
(
aCx
aRv
)
;
}
}
ExtensionEventManager
*
ExtensionTest
:
:
OnMessage
(
)
{
if
(
!
mOnMessageEventMgr
)
{
mOnMessageEventMgr
=
CreateEventManager
(
u
"
onMessage
"
_ns
)
;
}
return
mOnMessageEventMgr
;
}
}
}
