#
include
"
ExtensionEventListener
.
h
"
#
include
"
ExtensionPort
.
h
"
#
include
"
mozilla
/
dom
/
FunctionBinding
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsThreadManager
.
h
"
namespace
mozilla
{
namespace
extensions
{
NS_IMPL_ISUPPORTS
(
ExtensionEventListener
mozIExtensionEventListener
)
already_AddRefed
<
ExtensionEventListener
>
ExtensionEventListener
:
:
Create
(
nsIGlobalObject
*
aGlobal
dom
:
:
Function
*
aCallback
CleanupCallback
&
&
aCleanupCallback
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
dom
:
:
IsCurrentThreadRunningWorker
(
)
)
;
RefPtr
<
ExtensionEventListener
>
extCb
=
new
ExtensionEventListener
(
aGlobal
aCallback
)
;
auto
*
workerPrivate
=
dom
:
:
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
workerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
RefPtr
<
dom
:
:
StrongWorkerRef
>
workerRef
=
dom
:
:
StrongWorkerRef
:
:
Create
(
workerPrivate
"
ExtensionEventListener
"
std
:
:
move
(
aCleanupCallback
)
)
;
if
(
!
workerRef
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
extCb
-
>
mWorkerRef
=
new
dom
:
:
ThreadSafeWorkerRef
(
workerRef
)
;
return
extCb
.
forget
(
)
;
}
UniquePtr
<
dom
:
:
StructuredCloneHolder
>
ExtensionEventListener
:
:
SerializeCallArguments
(
const
nsTArray
<
JS
:
:
Value
>
&
aArgs
JSContext
*
aCx
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
jsval
(
aCx
)
;
if
(
NS_WARN_IF
(
!
dom
:
:
ToJSValue
(
aCx
aArgs
&
jsval
)
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
UniquePtr
<
dom
:
:
StructuredCloneHolder
>
argsHolder
=
MakeUnique
<
dom
:
:
StructuredCloneHolder
>
(
dom
:
:
StructuredCloneHolder
:
:
CloningSupported
dom
:
:
StructuredCloneHolder
:
:
TransferringNotSupported
JS
:
:
StructuredCloneScope
:
:
SameProcess
)
;
argsHolder
-
>
Write
(
aCx
jsval
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
return
argsHolder
;
}
NS_IMETHODIMP
ExtensionEventListener
:
:
CallListener
(
const
nsTArray
<
JS
:
:
Value
>
&
aArgs
ListenerCallOptions
*
aCallOptions
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromiseResult
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG_POINTER
(
aPromiseResult
)
;
APIObjectType
apiObjectType
=
APIObjectType
:
:
NONE
;
JS
:
:
Rooted
<
JS
:
:
Value
>
apiObjectDescriptor
(
aCx
)
;
if
(
aCallOptions
)
{
aCallOptions
-
>
GetApiObjectType
(
&
apiObjectType
)
;
aCallOptions
-
>
GetApiObjectDescriptor
(
&
apiObjectDescriptor
)
;
switch
(
apiObjectType
)
{
case
APIObjectType
:
:
NONE
:
if
(
NS_WARN_IF
(
!
apiObjectDescriptor
.
isNullOrUndefined
(
)
)
)
{
JS_ReportErrorASCII
(
aCx
"
Unexpected
non
-
null
apiObjectDescriptor
on
apiObjectType
=
NONE
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
break
;
case
APIObjectType
:
:
RUNTIME_PORT
:
if
(
NS_WARN_IF
(
apiObjectDescriptor
.
isNullOrUndefined
(
)
)
)
{
JS_ReportErrorASCII
(
aCx
"
Unexpected
null
apiObjectDescriptor
on
"
"
apiObjectType
=
RUNTIME_PORT
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
break
;
default
:
MOZ_CRASH
(
"
Unexpected
APIObjectType
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
IgnoredErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
retPromise
;
nsIGlobalObject
*
global
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
return
NS_ERROR_FAILURE
;
}
retPromise
=
dom
:
:
Promise
:
:
Create
(
global
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
dom
:
:
Sequence
<
JS
:
:
Value
>
args
;
if
(
!
args
.
AppendElements
(
aArgs
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
MutexAutoLock
lock
(
mMutex
)
;
if
(
NS_WARN_IF
(
!
mWorkerRef
)
)
{
return
NS_ERROR_ABORT
;
}
if
(
apiObjectType
!
=
APIObjectType
:
:
NONE
)
{
if
(
!
args
.
InsertElementAt
(
0
std
:
:
move
(
apiObjectDescriptor
)
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
UniquePtr
<
dom
:
:
StructuredCloneHolder
>
argsHolder
=
SerializeCallArguments
(
args
aCx
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
RefPtr
<
ExtensionListenerCallWorkerRunnable
>
runnable
=
new
ExtensionListenerCallWorkerRunnable
(
this
std
:
:
move
(
argsHolder
)
aCallOptions
retPromise
)
;
runnable
-
>
Dispatch
(
)
;
retPromise
.
forget
(
aPromiseResult
)
;
return
NS_OK
;
}
dom
:
:
WorkerPrivate
*
ExtensionEventListener
:
:
GetWorkerPrivate
(
)
const
{
MOZ_ASSERT
(
mWorkerRef
)
;
return
mWorkerRef
-
>
Private
(
)
;
}
void
ExtensionListenerCallWorkerRunnable
:
:
DeserializeCallArguments
(
JSContext
*
aCx
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aArgs
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
jsvalue
(
aCx
)
;
mArgsHolder
-
>
Read
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
aCx
&
jsvalue
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
nsresult
rv2
=
ExtensionAPIRequestForwarder
:
:
JSArrayToSequence
(
aCx
jsvalue
aArgs
)
;
if
(
NS_FAILED
(
rv2
)
)
{
aRv
.
Throw
(
rv2
)
;
}
}
bool
ExtensionListenerCallWorkerRunnable
:
:
WorkerRun
(
JSContext
*
aCx
dom
:
:
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
=
=
mWorkerPrivate
)
;
auto
global
=
mListener
-
>
GetGlobalObject
(
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
return
true
;
}
auto
fn
=
mListener
-
>
GetCallback
(
)
;
if
(
NS_WARN_IF
(
!
fn
)
)
{
return
true
;
}
IgnoredErrorResult
rv
;
dom
:
:
Sequence
<
JS
:
:
Value
>
argsSequence
;
dom
:
:
SequenceRooter
<
JS
:
:
Value
>
arguments
(
aCx
&
argsSequence
)
;
DeserializeCallArguments
(
aCx
argsSequence
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
true
;
}
RefPtr
<
dom
:
:
Promise
>
retPromise
;
RefPtr
<
dom
:
:
StrongWorkerRef
>
workerRef
;
retPromise
=
dom
:
:
Promise
:
:
Create
(
global
rv
)
;
if
(
retPromise
)
{
workerRef
=
dom
:
:
StrongWorkerRef
:
:
Create
(
aWorkerPrivate
"
ExtensionListenerCallWorkerRunnable
"
[
]
(
)
{
}
)
;
}
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
|
|
!
workerRef
)
)
{
auto
rejectMainThreadPromise
=
[
error
=
rv
.
Failed
(
)
?
rv
.
StealNSResult
(
)
:
NS_ERROR_UNEXPECTED
promiseResult
=
std
:
:
move
(
mPromiseResult
)
]
(
)
{
promiseResult
-
>
MaybeReject
(
error
)
;
}
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
__func__
std
:
:
move
(
rejectMainThreadPromise
)
)
;
NS_DispatchToMainThread
(
runnable
)
;
JS_ClearPendingException
(
aCx
)
;
return
true
;
}
ExtensionListenerCallPromiseResultHandler
:
:
Create
(
retPromise
this
new
dom
:
:
ThreadSafeWorkerRef
(
workerRef
)
)
;
if
(
mAPIObjectType
!
=
APIObjectType
:
:
NONE
)
{
IgnoredErrorResult
rv
;
MOZ_ASSERT
(
!
argsSequence
.
IsEmpty
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
apiObjectDescriptor
(
aCx
argsSequence
.
ElementAt
(
0
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
apiObjectValue
(
aCx
)
;
MOZ_ASSERT
(
mAPIObjectType
=
=
APIObjectType
:
:
RUNTIME_PORT
)
;
RefPtr
<
ExtensionPort
>
port
=
ExtensionPort
:
:
Create
(
global
apiObjectDescriptor
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
retPromise
-
>
MaybeReject
(
rv
.
StealNSResult
(
)
)
;
return
true
;
}
if
(
NS_WARN_IF
(
!
dom
:
:
ToJSValue
(
aCx
port
&
apiObjectValue
)
)
)
{
retPromise
-
>
MaybeReject
(
NS_ERROR_UNEXPECTED
)
;
return
true
;
}
argsSequence
.
ReplaceElementAt
(
0
apiObjectValue
)
;
}
dom
:
:
AutoEntryScript
aes
(
global
"
WebExtensionAPIEvent
"
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
retval
(
aCx
)
;
ErrorResult
erv
;
erv
.
MightThrowJSException
(
)
;
MOZ_KnownLive
(
fn
)
-
>
Call
(
argsSequence
&
retval
erv
"
WebExtensionAPIEvent
"
dom
:
:
Function
:
:
eRethrowExceptions
)
;
erv
.
WouldReportJSException
(
)
;
if
(
erv
.
Failed
(
)
)
{
retPromise
-
>
MaybeReject
(
std
:
:
move
(
erv
)
)
;
}
else
{
retPromise
-
>
MaybeResolve
(
retval
)
;
}
return
true
;
}
NS_IMPL_ISUPPORTS0
(
ExtensionListenerCallPromiseResultHandler
)
void
ExtensionListenerCallPromiseResultHandler
:
:
Create
(
const
RefPtr
<
dom
:
:
Promise
>
&
aPromise
const
RefPtr
<
ExtensionListenerCallWorkerRunnable
>
&
aWorkerRunnable
dom
:
:
ThreadSafeWorkerRef
*
aWorkerRef
)
{
MOZ_ASSERT
(
aPromise
)
;
MOZ_ASSERT
(
aWorkerRef
)
;
MOZ_ASSERT
(
aWorkerRef
-
>
Private
(
)
-
>
IsOnCurrentThread
(
)
)
;
RefPtr
<
ExtensionListenerCallPromiseResultHandler
>
handler
=
new
ExtensionListenerCallPromiseResultHandler
(
aWorkerRef
aWorkerRunnable
)
;
aPromise
-
>
AppendNativeHandler
(
handler
)
;
}
void
ExtensionListenerCallPromiseResultHandler
:
:
WorkerRunCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
PromiseCallbackType
aCallbackType
)
{
MOZ_ASSERT
(
mWorkerRef
)
;
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
JS
:
:
RootedValue
retval
(
aCx
aValue
)
;
if
(
retval
.
isObject
(
)
)
{
IgnoredErrorResult
rv
;
JS
:
:
Rooted
<
JSObject
*
>
errObj
(
aCx
&
retval
.
toObject
(
)
)
;
RefPtr
<
dom
:
:
ClonedErrorHolder
>
ceh
=
dom
:
:
ClonedErrorHolder
:
:
Create
(
aCx
errObj
rv
)
;
if
(
!
rv
.
Failed
(
)
&
&
ceh
)
{
JS
:
:
RootedObject
obj
(
aCx
)
;
Unused
<
<
NS_WARN_IF
(
!
ceh
-
>
WrapObject
(
aCx
nullptr
&
obj
)
)
;
retval
.
setObject
(
*
obj
)
;
}
}
UniquePtr
<
dom
:
:
StructuredCloneHolder
>
resHolder
=
MakeUnique
<
dom
:
:
StructuredCloneHolder
>
(
dom
:
:
StructuredCloneHolder
:
:
CloningSupported
dom
:
:
StructuredCloneHolder
:
:
TransferringNotSupported
JS
:
:
StructuredCloneScope
:
:
SameProcess
)
;
IgnoredErrorResult
erv
;
resHolder
-
>
Write
(
aCx
retval
erv
)
;
if
(
NS_WARN_IF
(
erv
.
Failed
(
)
)
)
{
auto
rejectMainThreadPromise
=
[
error
=
erv
.
StealNSResult
(
)
runnable
=
std
:
:
move
(
mWorkerRunnable
)
resHolder
=
std
:
:
move
(
resHolder
)
]
(
)
{
RefPtr
<
dom
:
:
Promise
>
promiseResult
=
std
:
:
move
(
runnable
-
>
mPromiseResult
)
;
promiseResult
-
>
MaybeReject
(
error
)
;
}
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
__func__
std
:
:
move
(
rejectMainThreadPromise
)
)
;
NS_DispatchToMainThread
(
runnable
)
;
JS_ClearPendingException
(
aCx
)
;
return
;
}
auto
resolveMainThreadPromise
=
[
callbackType
=
aCallbackType
resHolder
=
std
:
:
move
(
resHolder
)
runnable
=
std
:
:
move
(
mWorkerRunnable
)
workerRef
=
std
:
:
move
(
mWorkerRef
)
]
(
)
{
RefPtr
<
dom
:
:
Promise
>
promiseResult
=
std
:
:
move
(
runnable
-
>
mPromiseResult
)
;
auto
*
global
=
promiseResult
-
>
GetGlobalObject
(
)
;
dom
:
:
AutoEntryScript
aes
(
global
"
ExtensionListenerCallWorkerRunnable
:
:
WorkerRun
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
jsvalue
(
cx
)
;
IgnoredErrorResult
rv
;
{
Maybe
<
nsJSPrincipals
:
:
AutoSetActiveWorkerPrincipal
>
set
;
if
(
workerRef
)
{
set
.
emplace
(
workerRef
-
>
Private
(
)
-
>
GetPrincipal
(
)
)
;
}
resHolder
-
>
Read
(
global
cx
&
jsvalue
rv
)
;
}
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
promiseResult
-
>
MaybeReject
(
rv
.
StealNSResult
(
)
)
;
JS_ClearPendingException
(
cx
)
;
}
else
{
switch
(
callbackType
)
{
case
PromiseCallbackType
:
:
Resolve
:
promiseResult
-
>
MaybeResolve
(
jsvalue
)
;
break
;
case
PromiseCallbackType
:
:
Reject
:
promiseResult
-
>
MaybeReject
(
jsvalue
)
;
break
;
}
}
}
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
__func__
std
:
:
move
(
resolveMainThreadPromise
)
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
void
ExtensionListenerCallPromiseResultHandler
:
:
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
WorkerRunCallback
(
aCx
aValue
PromiseCallbackType
:
:
Resolve
)
;
}
void
ExtensionListenerCallPromiseResultHandler
:
:
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
WorkerRunCallback
(
aCx
aValue
PromiseCallbackType
:
:
Reject
)
;
}
}
}
