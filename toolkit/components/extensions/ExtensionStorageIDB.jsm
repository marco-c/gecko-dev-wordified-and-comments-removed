"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionStorageIDB
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
IndexedDB
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ContextualIdentityService
:
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
jsm
"
ExtensionStorage
:
"
resource
:
/
/
gre
/
modules
/
ExtensionStorage
.
jsm
"
ExtensionUtils
:
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
WEBEXT_STORAGE_USER_CONTEXT_ID
"
(
)
=
>
{
return
ContextualIdentityService
.
getDefaultPrivateIdentity
(
"
userContextIdInternal
.
webextStorageLocal
"
)
.
userContextId
;
}
)
;
const
IDB_NAME
=
"
webExtensions
-
storage
-
local
"
;
const
IDB_DATA_STORENAME
=
"
storage
-
local
-
data
"
;
const
IDB_VERSION
=
1
;
const
IDB_MIGRATE_RESULT_HISTOGRAM
=
"
WEBEXT_STORAGE_LOCAL_IDB_MIGRATE_RESULT_COUNT
"
;
const
BACKEND_ENABLED_PREF
=
"
extensions
.
webextensions
.
ExtensionStorageIDB
.
enabled
"
;
class
ExtensionStorageLocalIDB
extends
IndexedDB
{
onupgradeneeded
(
event
)
{
if
(
event
.
oldVersion
<
1
)
{
this
.
createObjectStore
(
IDB_DATA_STORENAME
)
;
}
}
static
openForPrincipal
(
storagePrincipal
)
{
return
super
.
openForPrincipal
(
storagePrincipal
IDB_NAME
IDB_VERSION
)
;
}
async
isEmpty
(
)
{
const
cursor
=
await
this
.
objectStore
(
IDB_DATA_STORENAME
"
readonly
"
)
.
openKeyCursor
(
)
;
return
cursor
.
done
;
}
async
set
(
items
{
serialize
}
=
{
}
)
{
const
changes
=
{
}
;
let
changed
=
false
;
const
transaction
=
this
.
transaction
(
IDB_DATA_STORENAME
"
readwrite
"
)
;
const
objectStore
=
transaction
.
objectStore
(
IDB_DATA_STORENAME
"
readwrite
"
)
;
for
(
let
key
of
Object
.
keys
(
items
)
)
{
try
{
let
oldValue
=
await
objectStore
.
get
(
key
)
;
await
objectStore
.
put
(
items
[
key
]
key
)
;
changes
[
key
]
=
{
oldValue
:
oldValue
&
&
serialize
?
serialize
(
oldValue
)
:
oldValue
newValue
:
serialize
?
serialize
(
items
[
key
]
)
:
items
[
key
]
}
;
changed
=
true
;
}
catch
(
err
)
{
transaction
.
abort
(
)
;
throw
new
ExtensionUtils
.
ExtensionError
(
String
(
err
)
)
;
}
}
return
changed
?
changes
:
null
;
}
async
get
(
keysOrItems
)
{
let
keys
;
let
defaultValues
;
if
(
Array
.
isArray
(
keysOrItems
)
)
{
keys
=
keysOrItems
;
}
else
if
(
keysOrItems
&
&
typeof
(
keysOrItems
)
=
=
=
"
object
"
)
{
keys
=
Object
.
keys
(
keysOrItems
)
;
defaultValues
=
keysOrItems
;
}
const
result
=
{
}
;
if
(
keys
=
=
null
)
{
const
cursor
=
await
this
.
objectStore
(
IDB_DATA_STORENAME
"
readonly
"
)
.
openCursor
(
)
;
while
(
!
cursor
.
done
)
{
result
[
cursor
.
key
]
=
cursor
.
value
;
await
cursor
.
continue
(
)
;
}
}
else
{
const
objectStore
=
this
.
objectStore
(
IDB_DATA_STORENAME
)
;
for
(
let
key
of
keys
)
{
const
storedValue
=
await
objectStore
.
get
(
key
)
;
if
(
storedValue
=
=
=
undefined
)
{
if
(
defaultValues
&
&
defaultValues
[
key
]
!
=
=
undefined
)
{
result
[
key
]
=
defaultValues
[
key
]
;
}
}
else
{
result
[
key
]
=
storedValue
;
}
}
}
return
result
;
}
async
remove
(
keys
)
{
keys
=
[
]
.
concat
(
keys
)
;
if
(
keys
.
length
=
=
=
0
)
{
return
null
;
}
const
changes
=
{
}
;
let
changed
=
false
;
const
objectStore
=
this
.
objectStore
(
IDB_DATA_STORENAME
"
readwrite
"
)
;
for
(
let
key
of
keys
)
{
let
oldValue
=
await
objectStore
.
get
(
key
)
;
changes
[
key
]
=
{
oldValue
}
;
if
(
oldValue
)
{
changed
=
true
;
}
await
objectStore
.
delete
(
key
)
;
}
return
changed
?
changes
:
null
;
}
async
clear
(
)
{
const
changes
=
{
}
;
let
changed
=
false
;
const
objectStore
=
this
.
objectStore
(
IDB_DATA_STORENAME
"
readwrite
"
)
;
const
cursor
=
await
objectStore
.
openCursor
(
)
;
while
(
!
cursor
.
done
)
{
changes
[
cursor
.
key
]
=
{
oldValue
:
cursor
.
value
}
;
changed
=
true
;
await
cursor
.
continue
(
)
;
}
await
objectStore
.
clear
(
)
;
return
changed
?
changes
:
null
;
}
}
async
function
migrateJSONFileData
(
extension
storagePrincipal
)
{
let
oldStoragePath
;
let
oldStorageExists
;
let
idbConn
;
let
jsonFile
;
let
hasEmptyIDB
;
let
oldDataRead
=
false
;
let
migrated
=
false
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
IDB_MIGRATE_RESULT_HISTOGRAM
)
;
try
{
idbConn
=
await
ExtensionStorageLocalIDB
.
openForPrincipal
(
storagePrincipal
)
;
hasEmptyIDB
=
await
idbConn
.
isEmpty
(
)
;
if
(
!
hasEmptyIDB
)
{
return
;
}
oldStoragePath
=
ExtensionStorage
.
getStorageFile
(
extension
.
id
)
;
oldStorageExists
=
await
OS
.
File
.
exists
(
oldStoragePath
)
;
if
(
oldStorageExists
)
{
Services
.
console
.
logStringMessage
(
Migrating
storage
.
local
data
for
{
extension
.
policy
.
debugName
}
.
.
.
)
;
jsonFile
=
await
ExtensionStorage
.
getFile
(
extension
.
id
)
;
const
data
=
{
}
;
for
(
let
[
key
value
]
of
jsonFile
.
data
.
entries
(
)
)
{
data
[
key
]
=
value
;
}
oldDataRead
=
true
;
await
idbConn
.
set
(
data
)
;
migrated
=
true
;
Services
.
console
.
logStringMessage
(
storage
.
local
data
successfully
migrated
to
IDB
Backend
for
{
extension
.
policy
.
debugName
}
.
)
;
}
}
catch
(
err
)
{
extension
.
logWarning
(
Error
on
migrating
storage
.
local
data
:
{
err
.
message
}
:
:
{
err
.
stack
}
)
;
if
(
oldDataRead
)
{
Services
.
qms
.
clearStoragesForPrincipal
(
storagePrincipal
)
;
histogram
.
add
(
"
failure
"
)
;
throw
err
;
}
}
finally
{
ExtensionStorage
.
clearCachedFile
(
extension
.
id
)
;
if
(
jsonFile
)
{
jsonFile
.
finalize
(
)
;
}
}
histogram
.
add
(
"
success
"
)
;
if
(
oldStorageExists
&
&
migrated
)
{
try
{
await
OS
.
File
.
remove
(
oldStoragePath
)
;
}
catch
(
err
)
{
extension
.
logWarning
(
err
.
message
)
;
}
}
}
this
.
ExtensionStorageIDB
=
{
BACKEND_ENABLED_PREF
IDB_MIGRATE_RESULT_HISTOGRAM
listeners
:
new
Map
(
)
selectedBackendPromises
:
new
WeakMap
(
)
init
(
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
isBackendEnabled
"
BACKEND_ENABLED_PREF
false
)
;
}
getStoragePrincipal
(
extension
)
{
return
extension
.
createPrincipal
(
extension
.
baseURI
{
userContextId
:
WEBEXT_STORAGE_USER_CONTEXT_ID
}
)
;
}
selectBackend
(
context
)
{
const
{
extension
}
=
context
;
if
(
!
this
.
selectedBackendPromises
.
has
(
extension
)
)
{
let
promise
;
if
(
context
.
childManager
)
{
return
context
.
childManager
.
callParentAsyncFunction
(
"
storage
.
local
.
IDBBackend
.
selectBackend
"
[
]
)
.
then
(
parentResult
=
>
{
let
result
;
if
(
!
parentResult
.
backendEnabled
)
{
result
=
{
backendEnabled
:
false
}
;
}
else
{
result
=
{
.
.
.
parentResult
storagePrincipal
:
parentResult
.
storagePrincipal
.
deserialize
(
this
)
}
;
}
this
.
selectedBackendPromises
.
set
(
extension
Promise
.
resolve
(
result
)
)
;
return
result
;
}
)
;
}
if
(
!
this
.
isBackendEnabled
)
{
promise
=
Promise
.
resolve
(
{
backendEnabled
:
false
}
)
;
}
else
{
const
storagePrincipal
=
this
.
getStoragePrincipal
(
extension
)
;
const
serializedPrincipal
=
new
StructuredCloneHolder
(
storagePrincipal
this
)
;
promise
=
migrateJSONFileData
(
extension
storagePrincipal
)
.
then
(
(
)
=
>
{
return
{
backendEnabled
:
true
storagePrincipal
:
serializedPrincipal
}
;
}
)
.
catch
(
err
=
>
{
extension
.
logWarning
(
"
JSONFile
backend
is
being
kept
enabled
by
an
unexpected
"
+
IDBBackend
failure
:
{
err
.
message
}
:
:
{
err
.
stack
}
)
;
return
{
backendEnabled
:
false
}
;
}
)
;
}
this
.
selectedBackendPromises
.
set
(
extension
promise
)
;
}
return
this
.
selectedBackendPromises
.
get
(
extension
)
;
}
open
(
storagePrincipal
)
{
return
ExtensionStorageLocalIDB
.
openForPrincipal
(
storagePrincipal
)
;
}
addOnChangedListener
(
extensionId
listener
)
{
let
listeners
=
this
.
listeners
.
get
(
extensionId
)
|
|
new
Set
(
)
;
listeners
.
add
(
listener
)
;
this
.
listeners
.
set
(
extensionId
listeners
)
;
}
removeOnChangedListener
(
extensionId
listener
)
{
let
listeners
=
this
.
listeners
.
get
(
extensionId
)
;
listeners
.
delete
(
listener
)
;
}
notifyListeners
(
extensionId
changes
)
{
let
listeners
=
this
.
listeners
.
get
(
extensionId
)
;
if
(
listeners
)
{
for
(
let
listener
of
listeners
)
{
listener
(
changes
)
;
}
}
}
hasListeners
(
extensionId
)
{
let
listeners
=
this
.
listeners
.
get
(
extensionId
)
;
return
listeners
&
&
listeners
.
size
>
0
;
}
}
;
ExtensionStorageIDB
.
init
(
)
;
