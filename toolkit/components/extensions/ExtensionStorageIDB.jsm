"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ExtensionStorageIDB
"
]
;
let
ExtensionStorageIDB
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
IndexedDB
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
IndexedDB
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ExtensionStorage
:
"
resource
:
/
/
gre
/
modules
/
ExtensionStorage
.
jsm
"
ExtensionUtils
:
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
getTrimmedString
:
"
resource
:
/
/
gre
/
modules
/
ExtensionTelemetry
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
}
)
;
const
WEBEXT_STORAGE_USER_CONTEXT_ID
=
-
1
>
>
>
0
;
const
IDB_NAME
=
"
webExtensions
-
storage
-
local
"
;
const
IDB_DATA_STORENAME
=
"
storage
-
local
-
data
"
;
const
IDB_VERSION
=
1
;
const
IDB_MIGRATE_RESULT_HISTOGRAM
=
"
WEBEXT_STORAGE_LOCAL_IDB_MIGRATE_RESULT_COUNT
"
;
const
BACKEND_ENABLED_PREF
=
"
extensions
.
webextensions
.
ExtensionStorageIDB
.
enabled
"
;
const
IDB_MIGRATED_PREF_BRANCH
=
"
extensions
.
webextensions
.
ExtensionStorageIDB
.
migrated
"
;
class
DataMigrationAbortedError
extends
Error
{
get
name
(
)
{
return
"
DataMigrationAbortedError
"
;
}
}
var
ErrorsTelemetry
=
{
initialized
:
false
lazyInit
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
initialized
=
true
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
extensions
.
data
"
true
)
;
this
.
resultHistogram
=
Services
.
telemetry
.
getHistogramById
(
IDB_MIGRATE_RESULT_HISTOGRAM
)
;
}
getErrorName
(
error
)
{
if
(
!
error
)
{
return
undefined
;
}
if
(
DOMException
.
isInstance
(
error
)
|
|
error
instanceof
DataMigrationAbortedError
)
{
if
(
error
.
name
.
length
>
80
)
{
return
getTrimmedString
(
error
.
name
)
;
}
return
error
.
name
;
}
return
"
OtherError
"
;
}
recordDataMigrationResult
(
telemetryData
)
{
try
{
const
{
backend
dataMigrated
extensionId
error
hasJSONFile
hasOldData
histogramCategory
}
=
telemetryData
;
this
.
lazyInit
(
)
;
this
.
resultHistogram
.
add
(
histogramCategory
)
;
const
extra
=
{
backend
}
;
if
(
dataMigrated
!
=
null
)
{
extra
.
data_migrated
=
dataMigrated
?
"
y
"
:
"
n
"
;
}
if
(
hasJSONFile
!
=
null
)
{
extra
.
has_jsonfile
=
hasJSONFile
?
"
y
"
:
"
n
"
;
}
if
(
hasOldData
!
=
null
)
{
extra
.
has_olddata
=
hasOldData
?
"
y
"
:
"
n
"
;
}
if
(
error
)
{
extra
.
error_name
=
this
.
getErrorName
(
error
)
;
}
Services
.
telemetry
.
recordEvent
(
"
extensions
.
data
"
"
migrateResult
"
"
storageLocal
"
getTrimmedString
(
extensionId
)
extra
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
recordStorageLocalError
(
{
extensionId
storageMethod
error
}
)
{
this
.
lazyInit
(
)
;
Services
.
telemetry
.
recordEvent
(
"
extensions
.
data
"
"
storageLocalError
"
storageMethod
getTrimmedString
(
extensionId
)
{
error_name
:
this
.
getErrorName
(
error
)
}
)
;
}
}
;
class
ExtensionStorageLocalIDB
extends
IndexedDB
{
onupgradeneeded
(
event
)
{
if
(
event
.
oldVersion
<
1
)
{
this
.
createObjectStore
(
IDB_DATA_STORENAME
)
;
}
}
static
openForPrincipal
(
storagePrincipal
)
{
return
super
.
openForPrincipal
(
storagePrincipal
IDB_NAME
IDB_VERSION
)
;
}
async
isEmpty
(
)
{
const
cursor
=
await
this
.
objectStore
(
IDB_DATA_STORENAME
"
readonly
"
)
.
openKeyCursor
(
)
;
return
cursor
.
done
;
}
async
set
(
items
{
serialize
}
=
{
}
)
{
const
changes
=
{
}
;
let
changed
=
false
;
const
transaction
=
this
.
transaction
(
IDB_DATA_STORENAME
"
readwrite
"
)
;
const
objectStore
=
transaction
.
objectStore
(
IDB_DATA_STORENAME
"
readwrite
"
)
;
const
transactionCompleted
=
transaction
.
promiseComplete
(
)
;
for
(
let
key
of
Object
.
keys
(
items
)
)
{
try
{
let
oldValue
=
await
objectStore
.
get
(
key
)
;
await
objectStore
.
put
(
items
[
key
]
key
)
;
changes
[
key
]
=
{
oldValue
:
oldValue
&
&
serialize
?
serialize
(
oldValue
)
:
oldValue
newValue
:
serialize
?
serialize
(
items
[
key
]
)
:
items
[
key
]
}
;
changed
=
true
;
}
catch
(
err
)
{
transactionCompleted
.
catch
(
err
=
>
{
}
)
;
transaction
.
abort
(
)
;
throw
err
;
}
}
await
transactionCompleted
;
return
changed
?
changes
:
null
;
}
async
get
(
keysOrItems
)
{
let
keys
;
let
defaultValues
;
if
(
typeof
keysOrItems
=
=
=
"
string
"
)
{
keys
=
[
keysOrItems
]
;
}
else
if
(
Array
.
isArray
(
keysOrItems
)
)
{
keys
=
keysOrItems
;
}
else
if
(
keysOrItems
&
&
typeof
keysOrItems
=
=
=
"
object
"
)
{
keys
=
Object
.
keys
(
keysOrItems
)
;
defaultValues
=
keysOrItems
;
}
const
result
=
{
}
;
if
(
keys
=
=
null
)
{
const
cursor
=
await
this
.
objectStore
(
IDB_DATA_STORENAME
"
readonly
"
)
.
openCursor
(
)
;
while
(
!
cursor
.
done
)
{
result
[
cursor
.
key
]
=
cursor
.
value
;
await
cursor
.
continue
(
)
;
}
}
else
{
const
objectStore
=
this
.
objectStore
(
IDB_DATA_STORENAME
)
;
for
(
let
key
of
keys
)
{
const
storedValue
=
await
objectStore
.
get
(
key
)
;
if
(
storedValue
=
=
=
undefined
)
{
if
(
defaultValues
&
&
defaultValues
[
key
]
!
=
=
undefined
)
{
result
[
key
]
=
defaultValues
[
key
]
;
}
}
else
{
result
[
key
]
=
storedValue
;
}
}
}
return
result
;
}
async
remove
(
keys
)
{
keys
=
[
]
.
concat
(
keys
)
;
if
(
keys
.
length
=
=
=
0
)
{
return
null
;
}
const
changes
=
{
}
;
let
changed
=
false
;
const
objectStore
=
this
.
objectStore
(
IDB_DATA_STORENAME
"
readwrite
"
)
;
let
promises
=
[
]
;
for
(
let
key
of
keys
)
{
promises
.
push
(
objectStore
.
getKey
(
key
)
.
then
(
async
foundKey
=
>
{
if
(
foundKey
=
=
=
key
)
{
changed
=
true
;
changes
[
key
]
=
{
oldValue
:
await
objectStore
.
get
(
key
)
}
;
return
objectStore
.
delete
(
key
)
;
}
}
)
)
;
}
await
Promise
.
all
(
promises
)
;
return
changed
?
changes
:
null
;
}
async
clear
(
)
{
const
changes
=
{
}
;
let
changed
=
false
;
const
objectStore
=
this
.
objectStore
(
IDB_DATA_STORENAME
"
readwrite
"
)
;
const
cursor
=
await
objectStore
.
openCursor
(
)
;
while
(
!
cursor
.
done
)
{
changes
[
cursor
.
key
]
=
{
oldValue
:
cursor
.
value
}
;
changed
=
true
;
await
cursor
.
continue
(
)
;
}
await
objectStore
.
clear
(
)
;
return
changed
?
changes
:
null
;
}
}
async
function
migrateJSONFileData
(
extension
storagePrincipal
)
{
let
oldStoragePath
;
let
oldStorageExists
;
let
idbConn
;
let
jsonFile
;
let
hasEmptyIDB
;
let
nonFatalError
;
let
dataMigrateCompleted
=
false
;
let
hasOldData
=
false
;
function
abortIfShuttingDown
(
)
{
if
(
extension
.
hasShutdown
|
|
Services
.
startup
.
shuttingDown
)
{
throw
new
DataMigrationAbortedError
(
"
extension
or
app
is
shutting
down
"
)
;
}
}
if
(
ExtensionStorageIDB
.
isMigratedExtension
(
extension
)
)
{
return
;
}
try
{
abortIfShuttingDown
(
)
;
idbConn
=
await
ExtensionStorageIDB
.
open
(
storagePrincipal
extension
.
hasPermission
(
"
unlimitedStorage
"
)
)
;
abortIfShuttingDown
(
)
;
hasEmptyIDB
=
await
idbConn
.
isEmpty
(
)
;
if
(
!
hasEmptyIDB
)
{
ExtensionStorageIDB
.
setMigratedExtensionPref
(
extension
true
)
;
return
;
}
}
catch
(
err
)
{
extension
.
logWarning
(
storage
.
local
data
migration
cancelled
unable
to
open
IDB
connection
:
{
err
.
message
}
:
:
{
err
.
stack
}
)
;
ErrorsTelemetry
.
recordDataMigrationResult
(
{
backend
:
"
JSONFile
"
extensionId
:
extension
.
id
error
:
err
histogramCategory
:
"
failure
"
}
)
;
throw
err
;
}
try
{
abortIfShuttingDown
(
)
;
oldStoragePath
=
ExtensionStorage
.
getStorageFile
(
extension
.
id
)
;
oldStorageExists
=
await
OS
.
File
.
exists
(
oldStoragePath
)
.
catch
(
fileErr
=
>
{
extension
.
logWarning
(
Unable
to
access
extension
storage
.
local
data
file
:
{
fileErr
.
message
}
:
:
{
fileErr
.
stack
}
)
;
return
false
;
}
)
;
if
(
oldStorageExists
)
{
abortIfShuttingDown
(
)
;
Services
.
console
.
logStringMessage
(
Migrating
storage
.
local
data
for
{
extension
.
policy
.
debugName
}
.
.
.
)
;
jsonFile
=
await
ExtensionStorage
.
getFile
(
extension
.
id
)
;
abortIfShuttingDown
(
)
;
const
data
=
{
}
;
for
(
let
[
key
value
]
of
jsonFile
.
data
.
entries
(
)
)
{
data
[
key
]
=
value
;
hasOldData
=
true
;
}
await
idbConn
.
set
(
data
)
;
Services
.
console
.
logStringMessage
(
storage
.
local
data
successfully
migrated
to
IDB
Backend
for
{
extension
.
policy
.
debugName
}
.
)
;
}
dataMigrateCompleted
=
true
;
}
catch
(
err
)
{
extension
.
logWarning
(
Error
on
migrating
storage
.
local
data
file
:
{
err
.
message
}
:
:
{
err
.
stack
}
)
;
if
(
oldStorageExists
&
&
!
dataMigrateCompleted
)
{
ErrorsTelemetry
.
recordDataMigrationResult
(
{
backend
:
"
JSONFile
"
dataMigrated
:
dataMigrateCompleted
extensionId
:
extension
.
id
error
:
err
hasJSONFile
:
oldStorageExists
hasOldData
histogramCategory
:
"
failure
"
}
)
;
await
new
Promise
(
resolve
=
>
{
let
req
=
Services
.
qms
.
clearStoragesForPrincipal
(
storagePrincipal
)
;
req
.
callback
=
resolve
;
}
)
;
throw
err
;
}
nonFatalError
=
err
;
}
finally
{
await
ExtensionStorage
.
clearCachedFile
(
extension
.
id
)
.
catch
(
err
=
>
{
extension
.
logWarning
(
err
.
message
)
;
}
)
;
}
if
(
oldStorageExists
&
&
dataMigrateCompleted
)
{
try
{
if
(
await
OS
.
File
.
exists
(
oldStoragePath
)
)
{
let
openInfo
=
await
OS
.
File
.
openUnique
(
{
oldStoragePath
}
.
migrated
{
humanReadable
:
true
}
)
;
await
openInfo
.
file
.
close
(
)
;
await
OS
.
File
.
move
(
oldStoragePath
openInfo
.
path
)
;
}
}
catch
(
err
)
{
nonFatalError
=
err
;
extension
.
logWarning
(
err
.
message
)
;
}
}
ExtensionStorageIDB
.
setMigratedExtensionPref
(
extension
true
)
;
ErrorsTelemetry
.
recordDataMigrationResult
(
{
backend
:
"
IndexedDB
"
dataMigrated
:
dataMigrateCompleted
extensionId
:
extension
.
id
error
:
nonFatalError
hasJSONFile
:
oldStorageExists
hasOldData
histogramCategory
:
"
success
"
}
)
;
}
ExtensionStorageIDB
=
{
BACKEND_ENABLED_PREF
IDB_MIGRATED_PREF_BRANCH
IDB_MIGRATE_RESULT_HISTOGRAM
listeners
:
new
Map
(
)
selectedBackendPromises
:
new
WeakMap
(
)
init
(
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
isBackendEnabled
"
BACKEND_ENABLED_PREF
false
)
;
}
isMigratedExtension
(
extension
)
{
return
Services
.
prefs
.
getBoolPref
(
{
IDB_MIGRATED_PREF_BRANCH
}
.
{
extension
.
id
}
false
)
;
}
setMigratedExtensionPref
(
extension
val
)
{
Services
.
prefs
.
setBoolPref
(
{
IDB_MIGRATED_PREF_BRANCH
}
.
{
extension
.
id
}
!
!
val
)
;
}
clearMigratedExtensionPref
(
extensionId
)
{
Services
.
prefs
.
clearUserPref
(
{
IDB_MIGRATED_PREF_BRANCH
}
.
{
extensionId
}
)
;
}
getStoragePrincipal
(
extension
)
{
return
extension
.
createPrincipal
(
extension
.
baseURI
{
userContextId
:
WEBEXT_STORAGE_USER_CONTEXT_ID
}
)
;
}
selectBackend
(
context
)
{
const
{
extension
}
=
context
;
if
(
!
this
.
selectedBackendPromises
.
has
(
extension
)
)
{
let
promise
;
if
(
context
.
childManager
)
{
return
context
.
childManager
.
callParentAsyncFunction
(
"
storage
.
local
.
IDBBackend
.
selectBackend
"
[
]
)
.
then
(
parentResult
=
>
{
let
result
;
if
(
!
parentResult
.
backendEnabled
)
{
result
=
{
backendEnabled
:
false
}
;
}
else
{
result
=
{
.
.
.
parentResult
storagePrincipal
:
parentResult
.
storagePrincipal
.
deserialize
(
this
true
)
}
;
}
this
.
selectedBackendPromises
.
set
(
extension
Promise
.
resolve
(
result
)
)
;
return
result
;
}
)
;
}
if
(
!
this
.
isBackendEnabled
)
{
promise
=
Promise
.
resolve
(
{
backendEnabled
:
false
}
)
;
}
else
{
const
storagePrincipal
=
this
.
getStoragePrincipal
(
extension
)
;
const
serializedPrincipal
=
new
StructuredCloneHolder
(
storagePrincipal
this
)
;
promise
=
migrateJSONFileData
(
extension
storagePrincipal
)
.
then
(
(
)
=
>
{
extension
.
setSharedData
(
"
storageIDBBackend
"
true
)
;
extension
.
setSharedData
(
"
storageIDBPrincipal
"
storagePrincipal
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
return
{
backendEnabled
:
true
storagePrincipal
:
serializedPrincipal
}
;
}
)
.
catch
(
err
=
>
{
extension
.
logWarning
(
"
JSONFile
backend
is
being
kept
enabled
by
an
unexpected
"
+
IDBBackend
failure
:
{
err
.
message
}
:
:
{
err
.
stack
}
)
;
extension
.
setSharedData
(
"
storageIDBBackend
"
false
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
return
{
backendEnabled
:
false
}
;
}
)
;
}
this
.
selectedBackendPromises
.
set
(
extension
promise
)
;
}
return
this
.
selectedBackendPromises
.
get
(
extension
)
;
}
persist
(
storagePrincipal
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
request
=
Services
.
qms
.
persist
(
storagePrincipal
)
;
request
.
callback
=
(
)
=
>
{
if
(
request
.
resultCode
=
=
=
Cr
.
NS_OK
)
{
resolve
(
)
;
}
else
{
reject
(
new
Error
(
Failed
to
persist
storage
for
principal
:
{
storagePrincipal
.
originNoSuffix
}
)
)
;
}
}
;
}
)
;
}
open
(
storagePrincipal
persisted
)
{
if
(
!
storagePrincipal
)
{
return
Promise
.
reject
(
new
Error
(
"
Unexpected
empty
principal
"
)
)
;
}
let
setPersistentMode
=
persisted
?
this
.
persist
(
storagePrincipal
)
:
Promise
.
resolve
(
)
;
return
setPersistentMode
.
then
(
(
)
=
>
ExtensionStorageLocalIDB
.
openForPrincipal
(
storagePrincipal
)
)
;
}
normalizeStorageError
(
{
error
extensionId
storageMethod
}
)
{
const
{
ExtensionError
}
=
ExtensionUtils
;
if
(
error
instanceof
ExtensionError
)
{
return
error
;
}
let
errorMessage
;
if
(
DOMException
.
isInstance
(
error
)
)
{
switch
(
error
.
name
)
{
case
"
DataCloneError
"
:
errorMessage
=
String
(
error
)
;
break
;
case
"
QuotaExceededError
"
:
errorMessage
=
{
error
.
name
}
:
storage
.
local
API
call
exceeded
its
quota
limitations
.
;
break
;
}
}
if
(
!
errorMessage
)
{
Cu
.
reportError
(
error
)
;
errorMessage
=
"
An
unexpected
error
occurred
"
;
ErrorsTelemetry
.
recordStorageLocalError
(
{
error
extensionId
storageMethod
}
)
;
}
return
new
ExtensionError
(
errorMessage
)
;
}
addOnChangedListener
(
extensionId
listener
)
{
let
listeners
=
this
.
listeners
.
get
(
extensionId
)
|
|
new
Set
(
)
;
listeners
.
add
(
listener
)
;
this
.
listeners
.
set
(
extensionId
listeners
)
;
}
removeOnChangedListener
(
extensionId
listener
)
{
let
listeners
=
this
.
listeners
.
get
(
extensionId
)
;
listeners
.
delete
(
listener
)
;
}
notifyListeners
(
extensionId
changes
)
{
let
listeners
=
this
.
listeners
.
get
(
extensionId
)
;
if
(
listeners
)
{
for
(
let
listener
of
listeners
)
{
listener
(
changes
)
;
}
}
}
hasListeners
(
extensionId
)
{
let
listeners
=
this
.
listeners
.
get
(
extensionId
)
;
return
listeners
&
&
listeners
.
size
>
0
;
}
}
;
ExtensionStorageIDB
.
init
(
)
;
