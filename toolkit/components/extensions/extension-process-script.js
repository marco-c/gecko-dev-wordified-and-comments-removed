"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionManagement
"
"
resource
:
/
/
gre
/
modules
/
ExtensionManagement
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MatchGlobs
"
"
resource
:
/
/
gre
/
modules
/
MatchPattern
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MatchPattern
"
"
resource
:
/
/
gre
/
modules
/
MatchPattern
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MessageChannel
"
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
WebNavigationFrames
"
"
resource
:
/
/
gre
/
modules
/
WebNavigationFrames
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionChild
"
"
resource
:
/
/
gre
/
modules
/
ExtensionChild
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionContent
"
"
resource
:
/
/
gre
/
modules
/
ExtensionContent
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionPageChild
"
"
resource
:
/
/
gre
/
modules
/
ExtensionPageChild
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionUtils
"
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
(
)
=
>
ExtensionUtils
.
getConsole
(
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
getInnerWindowID
"
(
)
=
>
ExtensionUtils
.
getInnerWindowID
)
;
const
isContentProcess
=
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
;
class
ScriptMatcher
{
constructor
(
extension
options
)
{
this
.
extension
=
extension
;
this
.
options
=
options
;
this
.
_script
=
null
;
this
.
allFrames
=
options
.
all_frames
;
this
.
matchAboutBlank
=
options
.
match_about_blank
;
this
.
frameId
=
options
.
frame_id
;
this
.
runAt
=
options
.
run_at
;
this
.
matches
=
new
MatchPattern
(
options
.
matches
)
;
this
.
excludeMatches
=
new
MatchPattern
(
options
.
exclude_matches
|
|
null
)
;
this
.
matchesHost
=
new
MatchPattern
(
options
.
matchesHost
|
|
null
)
;
this
.
includeGlobs
=
options
.
include_globs
&
&
new
MatchGlobs
(
options
.
include_globs
)
;
this
.
excludeGlobs
=
new
MatchGlobs
(
options
.
exclude_globs
)
;
}
toString
(
)
{
return
[
Script
{
js
:
[
{
this
.
options
.
js
}
]
matchAboutBlank
:
{
this
.
matchAboutBlank
}
runAt
:
{
this
.
runAt
}
matches
:
{
this
.
options
.
matches
}
}
]
;
}
get
script
(
)
{
if
(
!
this
.
_script
)
{
this
.
_script
=
new
ExtensionContent
.
Script
(
this
.
extension
.
realExtension
this
.
options
)
;
}
return
this
.
_script
;
}
preload
(
)
{
let
{
script
}
=
this
;
script
.
loadCSS
(
)
;
script
.
compileScripts
(
)
;
}
matchesLoadInfo
(
uri
loadInfo
)
{
if
(
!
this
.
matchesURI
(
uri
)
)
{
return
false
;
}
if
(
!
this
.
allFrames
&
&
!
loadInfo
.
isTopLevelLoad
)
{
return
false
;
}
return
true
;
}
matchesURI
(
uri
)
{
if
(
!
(
this
.
matches
.
matches
(
uri
)
|
|
this
.
matchesHost
.
matchesIgnoringPath
(
uri
)
)
)
{
return
false
;
}
if
(
this
.
excludeMatches
.
matches
(
uri
)
)
{
return
false
;
}
if
(
this
.
includeGlobs
!
=
null
&
&
!
this
.
includeGlobs
.
matches
(
uri
.
spec
)
)
{
return
false
;
}
if
(
this
.
excludeGlobs
.
matches
(
uri
.
spec
)
)
{
return
false
;
}
return
true
;
}
matchesWindow
(
window
)
{
if
(
!
this
.
allFrames
&
&
this
.
frameId
=
=
null
&
&
window
.
parent
!
=
=
window
)
{
return
false
;
}
let
uri
=
window
.
document
.
documentURIObject
;
let
principal
=
window
.
document
.
nodePrincipal
;
if
(
this
.
matchAboutBlank
)
{
if
(
uri
.
spec
=
=
=
"
about
:
blank
"
&
&
window
=
=
=
window
.
parent
&
&
principal
.
isNullPrincipal
)
{
return
true
;
}
if
(
[
"
about
:
blank
"
"
about
:
srcdoc
"
]
.
includes
(
uri
.
spec
)
)
{
uri
=
principal
.
URI
;
}
}
if
(
Services
.
netUtils
.
URIChainHasFlags
(
uri
Ci
.
nsIProtocolHandler
.
URI_INHERITS_SECURITY_CONTEXT
)
)
{
if
(
!
this
.
matchAboutBlank
)
{
return
false
;
}
uri
=
principal
.
URI
;
}
if
(
!
this
.
matchesURI
(
uri
)
)
{
return
false
;
}
if
(
this
.
frameId
!
=
null
&
&
WebNavigationFrames
.
getFrameId
(
window
)
!
=
=
this
.
frameId
)
{
return
false
;
}
if
(
window
.
navigator
.
mozAddonManager
!
=
=
undefined
)
{
return
false
;
}
return
true
;
}
injectInto
(
window
)
{
return
this
.
script
.
injectInto
(
window
)
;
}
}
function
getMessageManager
(
contentWindow
)
{
let
docShell
=
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
try
{
return
docShell
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
}
catch
(
e
)
{
return
null
;
}
}
var
DocumentManager
;
var
ExtensionManager
;
class
ExtensionGlobal
{
constructor
(
global
)
{
this
.
global
=
global
;
MessageChannel
.
addListener
(
global
"
Extension
:
Capture
"
this
)
;
MessageChannel
.
addListener
(
global
"
Extension
:
DetectLanguage
"
this
)
;
MessageChannel
.
addListener
(
global
"
Extension
:
Execute
"
this
)
;
MessageChannel
.
addListener
(
global
"
WebNavigation
:
GetFrame
"
this
)
;
MessageChannel
.
addListener
(
global
"
WebNavigation
:
GetAllFrames
"
this
)
;
}
uninit
(
)
{
}
get
messageFilterStrict
(
)
{
return
{
innerWindowID
:
getInnerWindowID
(
this
.
global
.
content
)
}
;
}
receiveMessage
(
{
target
messageName
recipient
data
}
)
{
switch
(
messageName
)
{
case
"
Extension
:
Capture
"
:
return
ExtensionContent
.
handleExtensionCapture
(
this
.
global
data
.
width
data
.
height
data
.
options
)
;
case
"
Extension
:
DetectLanguage
"
:
return
ExtensionContent
.
handleDetectLanguage
(
this
.
global
target
)
;
case
"
Extension
:
Execute
"
:
let
extension
=
ExtensionManager
.
get
(
recipient
.
extensionId
)
;
let
script
=
new
ScriptMatcher
(
extension
data
.
options
)
;
return
ExtensionContent
.
handleExtensionExecute
(
this
.
global
target
data
.
options
script
)
;
case
"
WebNavigation
:
GetFrame
"
:
return
ExtensionContent
.
handleWebNavigationGetFrame
(
this
.
global
data
.
options
)
;
case
"
WebNavigation
:
GetAllFrames
"
:
return
ExtensionContent
.
handleWebNavigationGetAllFrames
(
this
.
global
)
;
}
}
}
DocumentManager
=
{
globals
:
new
Map
(
)
earlyInit
(
)
{
Services
.
obs
.
addObserver
(
this
"
tab
-
content
-
frameloader
-
created
"
)
;
}
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
document
-
element
-
inserted
"
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
"
document
-
element
-
inserted
"
)
;
}
initMatchers
(
)
{
if
(
isContentProcess
)
{
Services
.
obs
.
addObserver
(
this
"
http
-
on
-
opening
-
request
"
)
;
}
}
uninitMatchers
(
)
{
if
(
isContentProcess
)
{
Services
.
obs
.
removeObserver
(
this
"
http
-
on
-
opening
-
request
"
)
;
}
}
initAboutBlankMatchers
(
)
{
Services
.
obs
.
addObserver
(
this
"
content
-
document
-
global
-
created
"
)
;
}
uninitAboutBlankMatchers
(
)
{
Services
.
obs
.
removeObserver
(
this
"
content
-
document
-
global
-
created
"
)
;
}
extensionProcessInitialized
:
false
initExtensionProcess
(
)
{
if
(
this
.
extensionProcessInitialized
|
|
!
ExtensionManagement
.
isExtensionProcess
)
{
return
;
}
this
.
extensionProcessInitialized
=
true
;
for
(
let
global
of
this
.
globals
.
keys
(
)
)
{
ExtensionPageChild
.
init
(
global
)
;
}
}
initGlobal
(
global
)
{
global
.
addEventListener
(
"
unload
"
event
=
>
{
this
.
uninitGlobal
(
global
)
;
}
)
;
this
.
globals
.
set
(
global
new
ExtensionGlobal
(
global
)
)
;
this
.
initExtensionProcess
(
)
;
if
(
this
.
extensionProcessInitialized
&
&
ExtensionManagement
.
isExtensionProcess
)
{
ExtensionPageChild
.
init
(
global
)
;
}
}
uninitGlobal
(
global
)
{
if
(
this
.
extensionProcessInitialized
)
{
ExtensionPageChild
.
uninit
(
global
)
;
}
this
.
globals
.
get
(
global
)
.
uninit
(
)
;
this
.
globals
.
delete
(
global
)
;
}
initExtension
(
extension
)
{
if
(
this
.
extensionCount
=
=
=
0
)
{
this
.
init
(
)
;
this
.
initExtensionProcess
(
)
;
}
this
.
extensionCount
+
+
;
for
(
let
script
of
extension
.
scripts
)
{
this
.
addContentScript
(
script
)
;
}
this
.
injectExtensionScripts
(
extension
)
;
}
uninitExtension
(
extension
)
{
for
(
let
script
of
extension
.
scripts
)
{
this
.
removeContentScript
(
script
)
;
}
this
.
extensionCount
-
-
;
if
(
this
.
extensionCount
=
=
=
0
)
{
this
.
uninit
(
)
;
}
}
extensionCount
:
0
matchAboutBlankCount
:
0
contentScripts
:
new
Set
(
)
addContentScript
(
script
)
{
if
(
this
.
contentScripts
.
size
=
=
0
)
{
this
.
initMatchers
(
)
;
}
if
(
script
.
matchAboutBlank
)
{
if
(
this
.
matchAboutBlankCount
=
=
0
)
{
this
.
initAboutBlankMatchers
(
)
;
}
this
.
matchAboutBlankCount
+
+
;
}
this
.
contentScripts
.
add
(
script
)
;
}
removeContentScript
(
script
)
{
this
.
contentScripts
.
delete
(
script
)
;
if
(
this
.
contentScripts
.
size
=
=
0
)
{
this
.
uninitMatchers
(
)
;
}
if
(
script
.
matchAboutBlank
)
{
this
.
matchAboutBlankCount
-
-
;
if
(
this
.
matchAboutBlankCount
=
=
0
)
{
this
.
uninitAboutBlankMatchers
(
)
;
}
}
}
observers
:
{
async
"
content
-
document
-
global
-
created
"
(
window
)
{
if
(
(
window
.
location
&
&
window
.
location
.
href
!
=
=
"
about
:
blank
"
)
|
|
!
this
.
globals
.
has
(
getMessageManager
(
window
)
)
)
{
return
;
}
await
new
Promise
(
resolve
=
>
window
.
addEventListener
(
"
DOMContentLoaded
"
resolve
{
once
:
true
capture
:
true
}
)
)
;
if
(
window
.
location
.
href
=
=
=
"
about
:
blank
"
)
{
this
.
injectWindowScripts
(
window
)
;
}
}
"
document
-
element
-
inserted
"
(
document
)
{
let
window
=
document
.
defaultView
;
if
(
!
document
.
location
|
|
!
window
|
|
!
this
.
globals
.
has
(
getMessageManager
(
window
)
)
)
{
return
;
}
this
.
injectWindowScripts
(
window
)
;
this
.
loadInto
(
window
)
;
}
"
http
-
on
-
opening
-
request
"
(
subject
topic
data
)
{
let
{
loadInfo
}
=
subject
.
QueryInterface
(
Ci
.
nsIChannel
)
;
if
(
loadInfo
)
{
let
{
externalContentPolicyType
:
type
}
=
loadInfo
;
if
(
type
=
=
=
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
|
|
type
=
=
=
Ci
.
nsIContentPolicy
.
TYPE_SUBDOCUMENT
)
{
this
.
preloadScripts
(
subject
.
URI
loadInfo
)
;
}
}
}
"
tab
-
content
-
frameloader
-
created
"
(
global
)
{
this
.
initGlobal
(
global
)
;
}
}
observe
(
subject
topic
data
)
{
this
.
observers
[
topic
]
.
call
(
this
subject
topic
data
)
;
}
injectExtensionScripts
(
extension
)
{
for
(
let
window
of
this
.
enumerateWindows
(
)
)
{
for
(
let
script
of
extension
.
scripts
)
{
if
(
script
.
matchesWindow
(
window
)
)
{
script
.
injectInto
(
window
)
;
}
}
}
}
injectWindowScripts
(
window
)
{
for
(
let
script
of
this
.
contentScripts
)
{
if
(
script
.
matchesWindow
(
window
)
)
{
script
.
injectInto
(
window
)
;
}
}
}
preloadScripts
(
uri
loadInfo
)
{
for
(
let
script
of
this
.
contentScripts
)
{
if
(
script
.
matchesLoadInfo
(
uri
loadInfo
)
)
{
script
.
preload
(
)
;
}
}
}
loadInto
(
window
)
{
let
extensionId
=
ExtensionManagement
.
getAddonIdForWindow
(
window
)
;
if
(
!
extensionId
)
{
return
;
}
let
extension
=
ExtensionManager
.
get
(
extensionId
)
;
if
(
!
extension
)
{
throw
new
Error
(
No
registered
extension
for
ID
{
extensionId
}
)
;
}
let
apiLevel
=
ExtensionManagement
.
getAPILevelForWindow
(
window
extensionId
)
;
const
levels
=
ExtensionManagement
.
API_LEVELS
;
if
(
apiLevel
=
=
=
levels
.
CONTENTSCRIPT_PRIVILEGES
)
{
ExtensionContent
.
initExtensionContext
(
extension
.
realExtension
window
)
;
}
else
if
(
apiLevel
=
=
=
levels
.
FULL_PRIVILEGES
)
{
ExtensionPageChild
.
initExtensionContext
(
extension
.
realExtension
window
)
;
}
else
{
throw
new
Error
(
Unexpected
window
with
extension
ID
{
extensionId
}
)
;
}
}
*
enumerateWindows
(
docShell
)
{
if
(
docShell
)
{
let
enum_
=
docShell
.
getDocShellEnumerator
(
docShell
.
typeContent
docShell
.
ENUMERATE_FORWARDS
)
;
for
(
let
docShell
of
XPCOMUtils
.
IterSimpleEnumerator
(
enum_
Ci
.
nsIInterfaceRequestor
)
)
{
yield
docShell
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
}
else
{
for
(
let
global
of
this
.
globals
.
keys
(
)
)
{
yield
*
this
.
enumerateWindows
(
global
.
docShell
)
;
}
}
}
}
;
class
StubExtension
{
constructor
(
data
)
{
this
.
data
=
data
;
this
.
id
=
data
.
id
;
this
.
uuid
=
data
.
uuid
;
this
.
instanceId
=
data
.
instanceId
;
this
.
manifest
=
data
.
manifest
;
this
.
scripts
=
data
.
content_scripts
.
map
(
scriptData
=
>
new
ScriptMatcher
(
this
scriptData
)
)
;
this
.
_realExtension
=
null
;
this
.
startup
(
)
;
}
startup
(
)
{
if
(
isContentProcess
)
{
let
uri
=
Services
.
io
.
newURI
(
this
.
data
.
resourceURL
)
;
ExtensionManagement
.
startupExtension
(
this
.
uuid
uri
this
)
;
}
}
shutdown
(
)
{
if
(
isContentProcess
)
{
ExtensionManagement
.
shutdownExtension
(
this
.
uuid
)
;
}
if
(
this
.
_realExtension
)
{
this
.
_realExtension
.
shutdown
(
)
;
}
}
get
realExtension
(
)
{
if
(
!
this
.
_realExtension
)
{
this
.
_realExtension
=
new
ExtensionChild
.
BrowserExtensionContent
(
this
.
data
)
;
}
return
this
.
_realExtension
;
}
hasPermission
(
.
.
.
args
)
{
return
this
.
realExtension
.
hasPermission
(
.
.
.
args
)
;
}
localize
(
.
.
.
args
)
{
return
this
.
realExtension
.
localize
(
.
.
.
args
)
;
}
get
whiteListedHosts
(
)
{
return
this
.
realExtension
.
whiteListedHosts
;
}
get
webAccessibleResources
(
)
{
return
this
.
realExtension
.
webAccessibleResources
;
}
}
ExtensionManager
=
{
extensions
:
new
Map
(
)
init
(
)
{
MessageChannel
.
setupMessageManagers
(
[
Services
.
cpmm
]
)
;
Services
.
cpmm
.
addMessageListener
(
"
Extension
:
Startup
"
this
)
;
Services
.
cpmm
.
addMessageListener
(
"
Extension
:
Shutdown
"
this
)
;
Services
.
cpmm
.
addMessageListener
(
"
Extension
:
FlushJarCache
"
this
)
;
let
procData
=
Services
.
cpmm
.
initialProcessData
|
|
{
}
;
for
(
let
data
of
procData
[
"
Extension
:
Extensions
"
]
|
|
[
]
)
{
let
extension
=
new
StubExtension
(
data
)
;
this
.
extensions
.
set
(
data
.
id
extension
)
;
DocumentManager
.
initExtension
(
extension
)
;
}
if
(
isContentProcess
)
{
if
(
!
procData
[
"
Extension
:
Schemas
"
]
)
{
procData
[
"
Extension
:
Schemas
"
]
=
new
Map
(
)
;
}
this
.
schemaJSON
=
procData
[
"
Extension
:
Schemas
"
]
;
Services
.
cpmm
.
addMessageListener
(
"
Schema
:
Add
"
this
)
;
}
}
get
(
extensionId
)
{
return
this
.
extensions
.
get
(
extensionId
)
;
}
receiveMessage
(
{
name
data
}
)
{
switch
(
name
)
{
case
"
Extension
:
Startup
"
:
{
let
extension
=
new
StubExtension
(
data
)
;
this
.
extensions
.
set
(
data
.
id
extension
)
;
DocumentManager
.
initExtension
(
extension
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
Extension
:
StartupComplete
"
)
;
break
;
}
case
"
Extension
:
Shutdown
"
:
{
let
extension
=
this
.
extensions
.
get
(
data
.
id
)
;
this
.
extensions
.
delete
(
data
.
id
)
;
extension
.
shutdown
(
)
;
DocumentManager
.
uninitExtension
(
extension
)
;
break
;
}
case
"
Extension
:
FlushJarCache
"
:
{
ExtensionUtils
.
flushJarCache
(
data
.
path
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
Extension
:
FlushJarCacheComplete
"
)
;
break
;
}
case
"
Schema
:
Add
"
:
{
this
.
schemaJSON
.
set
(
data
.
url
data
.
schema
)
;
break
;
}
}
}
}
;
DocumentManager
.
earlyInit
(
)
;
ExtensionManager
.
init
(
)
;
