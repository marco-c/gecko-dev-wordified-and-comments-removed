"
use
strict
"
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
idleService
"
"
mozilla
.
org
/
widget
/
useridleservice
;
1
"
Ci
.
nsIUserIdleService
)
;
var
{
DefaultWeakMap
}
=
ExtensionUtils
;
const
idleObserversMap
=
new
DefaultWeakMap
(
(
)
=
>
{
return
{
observer
:
null
detectionInterval
:
60
}
;
}
)
;
const
getIdleObserver
=
extension
=
>
{
let
observerInfo
=
idleObserversMap
.
get
(
extension
)
;
let
{
observer
detectionInterval
}
=
observerInfo
;
let
interval
=
extension
.
startupData
?
.
idleDetectionInterval
|
|
detectionInterval
;
if
(
!
observer
)
{
observer
=
new
(
class
extends
ExtensionCommon
.
EventEmitter
{
observe
(
subject
topic
)
{
if
(
topic
=
=
"
idle
"
|
|
topic
=
=
"
active
"
)
{
this
.
emit
(
"
stateChanged
"
topic
)
;
}
}
}
)
(
)
;
idleService
.
addIdleObserver
(
observer
interval
)
;
observerInfo
.
observer
=
observer
;
observerInfo
.
detectionInterval
=
interval
;
}
return
observer
;
}
;
this
.
idle
=
class
extends
ExtensionAPIPersistent
{
PERSISTENT_EVENTS
=
{
onStateChanged
(
{
fire
}
)
{
let
{
extension
}
=
this
;
let
listener
=
(
event
data
)
=
>
{
fire
.
sync
(
data
)
;
}
;
getIdleObserver
(
extension
)
.
on
(
"
stateChanged
"
listener
)
;
return
{
async
unregister
(
)
{
let
observerInfo
=
idleObserversMap
.
get
(
extension
)
;
let
{
observer
detectionInterval
}
=
observerInfo
;
if
(
observer
)
{
observer
.
off
(
"
stateChanged
"
listener
)
;
if
(
!
observer
.
has
(
"
stateChanged
"
)
)
{
idleService
.
removeIdleObserver
(
observer
detectionInterval
)
;
observerInfo
.
observer
=
null
;
}
}
}
convert
(
_fire
)
{
fire
=
_fire
;
}
}
;
}
}
;
getAPI
(
context
)
{
let
{
extension
}
=
context
;
let
self
=
this
;
return
{
idle
:
{
queryState
(
detectionIntervalInSeconds
)
{
if
(
idleService
.
idleTime
<
detectionIntervalInSeconds
*
1000
)
{
return
"
active
"
;
}
return
"
idle
"
;
}
setDetectionInterval
(
detectionIntervalInSeconds
)
{
let
observerInfo
=
idleObserversMap
.
get
(
extension
)
;
let
{
observer
detectionInterval
}
=
observerInfo
;
if
(
detectionInterval
=
=
detectionIntervalInSeconds
)
{
return
;
}
if
(
observer
)
{
idleService
.
removeIdleObserver
(
observer
detectionInterval
)
;
idleService
.
addIdleObserver
(
observer
detectionIntervalInSeconds
)
;
}
observerInfo
.
detectionInterval
=
detectionIntervalInSeconds
;
if
(
!
extension
.
persistentBackground
)
{
extension
.
startupData
.
idleDetectionInterval
=
detectionIntervalInSeconds
;
extension
.
saveStartupData
(
)
;
}
}
onStateChanged
:
new
EventManager
(
{
context
module
:
"
idle
"
event
:
"
onStateChanged
"
extensionApi
:
self
}
)
.
api
(
)
}
}
;
}
}
;
