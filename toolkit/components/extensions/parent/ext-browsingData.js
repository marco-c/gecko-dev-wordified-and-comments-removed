"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
LoginHelper
:
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
ServiceWorkerCleanUp
:
"
resource
:
/
/
gre
/
modules
/
ServiceWorkerCleanUp
.
jsm
"
BrowsingDataDelegate
:
"
resource
:
/
/
/
modules
/
ExtensionBrowsingData
.
jsm
"
}
)
;
const
YIELD_PERIOD
=
10
;
const
toPRTime
=
date
=
>
{
if
(
typeof
date
!
=
"
number
"
&
&
date
.
constructor
.
name
!
=
"
Date
"
)
{
throw
new
Error
(
"
Invalid
value
passed
to
toPRTime
"
)
;
}
return
date
*
1000
;
}
;
const
makeRange
=
options
=
>
{
return
options
.
since
=
=
null
?
null
:
[
toPRTime
(
options
.
since
)
toPRTime
(
Date
.
now
(
)
)
]
;
}
;
global
.
makeRange
=
makeRange
;
async
function
clearData
(
options
flags
)
{
if
(
options
.
hostnames
)
{
await
Promise
.
all
(
options
.
hostnames
.
map
(
host
=
>
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteDataFromHost
(
host
true
flags
resolve
)
;
}
)
)
)
;
return
;
}
if
(
options
.
since
)
{
const
range
=
makeRange
(
options
)
;
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteDataInTimeRange
(
.
.
.
range
true
flags
resolve
)
;
}
)
;
return
;
}
await
new
Promise
(
resolve
=
>
Services
.
clearData
.
deleteData
(
flags
resolve
)
)
;
}
const
clearCache
=
options
=
>
{
return
clearData
(
options
Ci
.
nsIClearDataService
.
CLEAR_ALL_CACHES
)
;
}
;
const
clearCookies
=
async
function
(
options
)
{
let
cookieMgr
=
Services
.
cookies
;
let
yieldCounter
=
0
;
if
(
options
.
since
|
|
options
.
hostnames
|
|
options
.
cookieStoreId
)
{
let
cookies
=
cookieMgr
.
cookies
;
if
(
!
options
.
cookieStoreId
|
|
isPrivateCookieStoreId
(
options
.
cookieStoreId
)
)
{
const
privateCookies
=
cookieMgr
.
getCookiesWithOriginAttributes
(
JSON
.
stringify
(
{
privateBrowsingId
:
1
}
)
)
;
cookies
=
cookies
.
concat
(
privateCookies
)
;
}
for
(
const
cookie
of
cookies
)
{
if
(
(
!
options
.
since
|
|
cookie
.
creationTime
>
=
toPRTime
(
options
.
since
)
)
&
&
(
!
options
.
hostnames
|
|
options
.
hostnames
.
includes
(
cookie
.
host
.
replace
(
/
^
\
.
/
"
"
)
)
)
&
&
(
!
options
.
cookieStoreId
|
|
getCookieStoreIdForOriginAttributes
(
cookie
.
originAttributes
)
=
=
=
options
.
cookieStoreId
)
)
{
cookieMgr
.
remove
(
cookie
.
host
cookie
.
name
cookie
.
path
cookie
.
originAttributes
)
;
if
(
+
+
yieldCounter
%
YIELD_PERIOD
=
=
0
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
}
}
}
else
{
cookieMgr
.
removeAll
(
)
;
}
}
;
async
function
clearQuotaManager
(
options
dataType
)
{
if
(
options
.
cookieStoreId
=
=
PRIVATE_STORE
)
{
return
;
}
let
promises
=
[
]
;
await
new
Promise
(
(
resolve
reject
)
=
>
{
Services
.
qms
.
getUsage
(
request
=
>
{
if
(
request
.
resultCode
!
=
Cr
.
NS_OK
)
{
reject
(
{
message
:
Clear
{
dataType
}
failed
}
)
;
return
;
}
for
(
let
item
of
request
.
result
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
item
.
origin
)
;
if
(
!
[
"
http
"
"
https
"
"
file
"
]
.
includes
(
principal
.
scheme
)
)
{
continue
;
}
let
host
=
principal
.
hostPort
;
if
(
(
!
options
.
hostnames
|
|
options
.
hostnames
.
includes
(
host
)
)
&
&
(
!
options
.
cookieStoreId
|
|
getCookieStoreIdForOriginAttributes
(
principal
.
originAttributes
)
=
=
=
options
.
cookieStoreId
)
)
{
promises
.
push
(
new
Promise
(
(
resolve
reject
)
=
>
{
let
clearRequest
;
if
(
dataType
=
=
=
"
indexedDB
"
)
{
clearRequest
=
Services
.
qms
.
clearStoragesForPrincipal
(
principal
null
"
idb
"
)
;
}
else
{
clearRequest
=
Services
.
qms
.
clearStoragesForPrincipal
(
principal
"
default
"
"
ls
"
)
;
}
clearRequest
.
callback
=
(
)
=
>
{
if
(
clearRequest
.
resultCode
=
=
Cr
.
NS_OK
)
{
resolve
(
)
;
}
else
{
reject
(
{
message
:
Clear
{
dataType
}
failed
}
)
;
}
}
;
}
)
)
;
}
}
resolve
(
)
;
}
)
;
}
)
;
return
Promise
.
all
(
promises
)
;
}
const
clearIndexedDB
=
async
function
(
options
)
{
return
clearQuotaManager
(
options
"
indexedDB
"
)
;
}
;
const
clearLocalStorage
=
async
function
(
options
)
{
if
(
options
.
since
)
{
return
Promise
.
reject
(
{
message
:
"
Firefox
does
not
support
clearing
localStorage
with
'
since
'
.
"
}
)
;
}
if
(
options
.
hostnames
)
{
for
(
let
hostname
of
options
.
hostnames
)
{
Services
.
obs
.
notifyObservers
(
null
"
extension
:
purge
-
localStorage
"
hostname
)
;
}
}
else
{
Services
.
obs
.
notifyObservers
(
null
"
extension
:
purge
-
localStorage
"
)
;
}
if
(
Services
.
domStorageManager
.
nextGenLocalStorageEnabled
)
{
return
clearQuotaManager
(
options
"
localStorage
"
)
;
}
}
;
const
clearPasswords
=
async
function
(
options
)
{
let
yieldCounter
=
0
;
for
(
let
login
of
await
LoginHelper
.
getAllUserFacingLogins
(
)
)
{
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
if
(
!
options
.
since
|
|
login
.
timePasswordChanged
>
=
options
.
since
)
{
Services
.
logins
.
removeLogin
(
login
)
;
if
(
+
+
yieldCounter
%
YIELD_PERIOD
=
=
0
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
}
}
}
;
const
clearServiceWorkers
=
options
=
>
{
if
(
!
options
.
hostnames
)
{
return
ServiceWorkerCleanUp
.
removeAll
(
)
;
}
return
Promise
.
all
(
options
.
hostnames
.
map
(
host
=
>
{
return
ServiceWorkerCleanUp
.
removeFromHost
(
host
)
;
}
)
)
;
}
;
class
BrowsingDataImpl
{
constructor
(
extension
)
{
this
.
extension
=
extension
;
this
.
platformDelegate
=
new
BrowsingDataDelegate
(
extension
)
;
}
handleRemoval
(
dataType
options
)
{
let
result
=
this
.
platformDelegate
.
handleRemoval
(
dataType
options
)
;
if
(
result
!
=
=
undefined
)
{
return
result
;
}
switch
(
dataType
)
{
case
"
cache
"
:
return
clearCache
(
options
)
;
case
"
cookies
"
:
return
clearCookies
(
options
)
;
case
"
indexedDB
"
:
return
clearIndexedDB
(
options
)
;
case
"
localStorage
"
:
return
clearLocalStorage
(
options
)
;
case
"
passwords
"
:
return
clearPasswords
(
options
)
;
case
"
pluginData
"
:
this
.
extension
?
.
logger
.
warn
(
"
pluginData
has
been
deprecated
(
along
with
Flash
plugin
support
)
"
)
;
return
Promise
.
resolve
(
)
;
case
"
serviceWorkers
"
:
return
clearServiceWorkers
(
options
)
;
default
:
return
undefined
;
}
}
doRemoval
(
options
dataToRemove
)
{
if
(
options
.
originTypes
&
&
(
options
.
originTypes
.
protectedWeb
|
|
options
.
originTypes
.
extension
)
)
{
return
Promise
.
reject
(
{
message
:
"
Firefox
does
not
support
protectedWeb
or
extension
as
originTypes
.
"
}
)
;
}
if
(
options
.
cookieStoreId
)
{
const
SUPPORTED_TYPES
=
[
"
cookies
"
"
indexedDB
"
]
;
if
(
Services
.
domStorageManager
.
nextGenLocalStorageEnabled
)
{
SUPPORTED_TYPES
.
push
(
"
localStorage
"
)
;
}
for
(
let
dataType
in
dataToRemove
)
{
if
(
dataToRemove
[
dataType
]
&
&
!
SUPPORTED_TYPES
.
includes
(
dataType
)
)
{
return
Promise
.
reject
(
{
message
:
Firefox
does
not
support
clearing
{
dataType
}
with
'
cookieStoreId
'
.
}
)
;
}
}
if
(
!
isPrivateCookieStoreId
(
options
.
cookieStoreId
)
&
&
!
isDefaultCookieStoreId
(
options
.
cookieStoreId
)
&
&
!
getContainerForCookieStoreId
(
options
.
cookieStoreId
)
)
{
return
Promise
.
reject
(
{
message
:
Invalid
cookieStoreId
:
{
options
.
cookieStoreId
}
}
)
;
}
}
let
removalPromises
=
[
]
;
let
invalidDataTypes
=
[
]
;
for
(
let
dataType
in
dataToRemove
)
{
if
(
dataToRemove
[
dataType
]
)
{
let
result
=
this
.
handleRemoval
(
dataType
options
)
;
if
(
result
=
=
=
undefined
)
{
invalidDataTypes
.
push
(
dataType
)
;
}
else
{
removalPromises
.
push
(
result
)
;
}
}
}
if
(
invalidDataTypes
.
length
)
{
this
.
extension
.
logger
.
warn
(
Firefox
does
not
support
dataTypes
:
{
invalidDataTypes
.
toString
(
)
}
.
)
;
}
return
Promise
.
all
(
removalPromises
)
;
}
settings
(
)
{
return
this
.
platformDelegate
.
settings
(
)
;
}
}
this
.
browsingData
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
const
impl
=
new
BrowsingDataImpl
(
context
.
extension
)
;
return
{
browsingData
:
{
settings
(
)
{
return
impl
.
settings
(
)
;
}
remove
(
options
dataToRemove
)
{
return
impl
.
doRemoval
(
options
dataToRemove
)
;
}
removeCache
(
options
)
{
return
impl
.
doRemoval
(
options
{
cache
:
true
}
)
;
}
removeCookies
(
options
)
{
return
impl
.
doRemoval
(
options
{
cookies
:
true
}
)
;
}
removeDownloads
(
options
)
{
return
impl
.
doRemoval
(
options
{
downloads
:
true
}
)
;
}
removeFormData
(
options
)
{
return
impl
.
doRemoval
(
options
{
formData
:
true
}
)
;
}
removeHistory
(
options
)
{
return
impl
.
doRemoval
(
options
{
history
:
true
}
)
;
}
removeIndexedDB
(
options
)
{
return
impl
.
doRemoval
(
options
{
indexedDB
:
true
}
)
;
}
removeLocalStorage
(
options
)
{
return
impl
.
doRemoval
(
options
{
localStorage
:
true
}
)
;
}
removePasswords
(
options
)
{
return
impl
.
doRemoval
(
options
{
passwords
:
true
}
)
;
}
removePluginData
(
options
)
{
return
impl
.
doRemoval
(
options
{
pluginData
:
true
}
)
;
}
}
}
;
}
}
;
