"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
ExtensionDNR
:
"
resource
:
/
/
gre
/
modules
/
ExtensionDNR
.
sys
.
mjs
"
}
)
;
var
{
ExtensionError
}
=
ExtensionUtils
;
const
PREF_DNR_FEEDBACK
=
"
extensions
.
dnr
.
feedback
"
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
dnrFeedbackEnabled
"
PREF_DNR_FEEDBACK
false
)
;
function
ensureDNRFeedbackEnabled
(
apiName
)
{
if
(
!
dnrFeedbackEnabled
)
{
throw
new
ExtensionError
(
{
apiName
}
is
only
available
when
the
"
{
PREF_DNR_FEEDBACK
}
"
preference
is
set
to
true
.
)
;
}
}
this
.
declarativeNetRequest
=
class
extends
ExtensionAPI
{
onManifestEntry
(
entryName
)
{
if
(
entryName
=
=
=
"
declarative_net_request
"
)
{
ExtensionDNR
.
validateManifestEntry
(
this
.
extension
)
;
}
}
onShutdown
(
)
{
ExtensionDNR
.
clearRuleManager
(
this
.
extension
)
;
}
getAPI
(
context
)
{
const
{
extension
}
=
this
;
return
{
declarativeNetRequest
:
{
updateDynamicRules
(
{
removeRuleIds
addRules
}
)
{
return
ExtensionDNR
.
updateDynamicRules
(
extension
{
removeRuleIds
addRules
}
)
;
}
updateSessionRules
(
{
removeRuleIds
addRules
}
)
{
const
ruleManager
=
ExtensionDNR
.
getRuleManager
(
extension
)
;
let
ruleValidator
=
new
ExtensionDNR
.
RuleValidator
(
ruleManager
.
getSessionRules
(
)
{
isSessionRuleset
:
true
}
)
;
if
(
removeRuleIds
)
{
ruleValidator
.
removeRuleIds
(
removeRuleIds
)
;
}
if
(
addRules
)
{
ruleValidator
.
addRules
(
addRules
)
;
}
let
failures
=
ruleValidator
.
getFailures
(
)
;
if
(
failures
.
length
)
{
throw
new
ExtensionError
(
failures
[
0
]
.
message
)
;
}
let
validatedRules
=
ruleValidator
.
getValidatedRules
(
)
;
let
ruleQuotaCounter
=
new
ExtensionDNR
.
RuleQuotaCounter
(
)
;
ruleQuotaCounter
.
tryAddRules
(
"
_session
"
validatedRules
)
;
ruleManager
.
setSessionRules
(
validatedRules
)
;
}
async
getEnabledRulesets
(
)
{
await
ExtensionDNR
.
ensureInitialized
(
extension
)
;
const
ruleManager
=
ExtensionDNR
.
getRuleManager
(
extension
)
;
return
ruleManager
.
enabledStaticRulesetIds
;
}
async
getAvailableStaticRuleCount
(
)
{
await
ExtensionDNR
.
ensureInitialized
(
extension
)
;
const
ruleManager
=
ExtensionDNR
.
getRuleManager
(
extension
)
;
return
ruleManager
.
availableStaticRuleCount
;
}
updateEnabledRulesets
(
{
disableRulesetIds
enableRulesetIds
}
)
{
return
ExtensionDNR
.
updateEnabledStaticRulesets
(
extension
{
disableRulesetIds
enableRulesetIds
}
)
;
}
async
getDynamicRules
(
)
{
await
ExtensionDNR
.
ensureInitialized
(
extension
)
;
return
ExtensionDNR
.
getRuleManager
(
extension
)
.
getDynamicRules
(
)
;
}
getSessionRules
(
)
{
return
ExtensionDNR
.
getRuleManager
(
extension
)
.
getSessionRules
(
)
;
}
isRegexSupported
(
regexOptions
)
{
const
{
regex
:
regexFilter
isCaseSensitive
:
isUrlFilterCaseSensitive
}
=
regexOptions
;
let
ruleValidator
=
new
ExtensionDNR
.
RuleValidator
(
[
]
)
;
ruleValidator
.
addRules
(
[
{
id
:
1
condition
:
{
regexFilter
isUrlFilterCaseSensitive
}
action
:
{
type
:
"
allow
"
}
}
]
)
;
let
failures
=
ruleValidator
.
getFailures
(
)
;
if
(
failures
.
length
)
{
return
{
isSupported
:
false
reason
:
"
syntaxError
"
}
;
}
return
{
isSupported
:
true
}
;
}
async
testMatchOutcome
(
request
options
)
{
ensureDNRFeedbackEnabled
(
"
declarativeNetRequest
.
testMatchOutcome
"
)
;
let
{
url
initiator
.
.
.
req
}
=
request
;
req
.
requestURI
=
Services
.
io
.
newURI
(
url
)
;
if
(
initiator
)
{
req
.
initiatorURI
=
Services
.
io
.
newURI
(
initiator
)
;
if
(
req
.
initiatorURI
.
schemeIs
(
"
data
"
)
)
{
req
.
initiatorURI
=
null
;
}
}
const
matchedRules
=
ExtensionDNR
.
getMatchedRulesForRequest
(
req
options
?
.
includeOtherExtensions
?
null
:
extension
)
.
map
(
matchedRule
=
>
{
const
result
=
{
ruleId
:
matchedRule
.
rule
.
id
rulesetId
:
matchedRule
.
ruleset
.
id
}
;
if
(
matchedRule
.
ruleManager
.
extension
!
=
=
extension
)
{
result
.
extensionId
=
matchedRule
.
ruleManager
.
extension
.
id
;
}
return
result
;
}
)
;
return
{
matchedRules
}
;
}
}
}
;
}
}
;
