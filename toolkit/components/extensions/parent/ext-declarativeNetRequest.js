"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
ExtensionDNR
:
"
resource
:
/
/
gre
/
modules
/
ExtensionDNR
.
sys
.
mjs
"
}
)
;
var
{
ExtensionError
}
=
ExtensionUtils
;
this
.
declarativeNetRequest
=
class
extends
ExtensionAPI
{
onShutdown
(
)
{
ExtensionDNR
.
clearRuleManager
(
this
.
extension
)
;
}
getAPI
(
context
)
{
const
{
extension
}
=
this
;
return
{
declarativeNetRequest
:
{
updateSessionRules
(
{
removeRuleIds
addRules
}
)
{
const
ruleManager
=
ExtensionDNR
.
getRuleManager
(
extension
)
;
let
ruleValidator
=
new
ExtensionDNR
.
RuleValidator
(
ruleManager
.
getSessionRules
(
)
)
;
if
(
removeRuleIds
)
{
ruleValidator
.
removeRuleIds
(
removeRuleIds
)
;
}
if
(
addRules
)
{
ruleValidator
.
addRules
(
addRules
)
;
}
let
failures
=
ruleValidator
.
getFailures
(
)
;
if
(
failures
.
length
)
{
throw
new
ExtensionError
(
failures
[
0
]
.
message
)
;
}
ruleManager
.
setSessionRules
(
ruleValidator
.
getValidatedRules
(
)
)
;
}
getSessionRules
(
)
{
return
ExtensionDNR
.
getRuleManager
(
extension
)
.
getSessionRules
(
)
;
}
async
testMatchOutcome
(
request
options
)
{
let
{
url
initiator
.
.
.
req
}
=
request
;
req
.
requestURI
=
Services
.
io
.
newURI
(
url
)
;
if
(
initiator
)
{
req
.
initiatorURI
=
Services
.
io
.
newURI
(
initiator
)
;
}
function
convertMatchedRule
(
matchedRule
)
{
const
result
=
{
ruleId
:
matchedRule
.
rule
.
id
rulesetId
:
matchedRule
.
ruleset
.
id
}
;
if
(
matchedRule
.
ruleManager
.
extension
!
=
=
extension
)
{
result
.
extensionId
=
matchedRule
.
ruleManager
.
extension
.
id
;
}
return
result
;
}
if
(
options
?
.
includeOtherExtensions
)
{
return
ExtensionDNR
.
getMatchedRulesForRequest
(
req
)
.
map
(
convertMatchedRule
)
;
}
return
ExtensionDNR
.
getMatchedRulesForRequest
(
req
extension
)
.
map
(
convertMatchedRule
)
;
}
}
}
;
}
}
;
