"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
{
DefaultMap
DefaultWeakMap
ExtensionError
getWinUtils
}
=
ExtensionUtils
;
var
{
defineLazyGetter
}
=
ExtensionCommon
;
class
TabBase
{
constructor
(
extension
nativeTab
id
)
{
this
.
extension
=
extension
;
this
.
tabManager
=
extension
.
tabManager
;
this
.
id
=
id
;
this
.
nativeTab
=
nativeTab
;
this
.
activeTabWindowID
=
null
;
}
sendMessage
(
context
messageName
data
=
{
}
options
=
null
)
{
let
{
browser
innerWindowID
}
=
this
;
options
=
Object
.
assign
(
{
}
options
)
;
options
.
recipient
=
Object
.
assign
(
{
innerWindowID
}
options
.
recipient
)
;
return
context
.
sendMessage
(
browser
.
messageManager
messageName
data
options
)
;
}
capture
(
context
options
=
null
)
{
if
(
!
options
)
{
options
=
{
}
;
}
if
(
options
.
format
=
=
null
)
{
options
.
format
=
"
png
"
;
}
if
(
options
.
quality
=
=
null
)
{
options
.
quality
=
92
;
}
let
message
=
{
options
width
:
this
.
width
height
:
this
.
height
}
;
return
this
.
sendMessage
(
context
"
Extension
:
Capture
"
message
)
;
}
get
innerWindowID
(
)
{
return
this
.
browser
.
innerWindowID
;
}
get
hasTabPermission
(
)
{
return
this
.
extension
.
hasPermission
(
"
tabs
"
)
|
|
this
.
hasActiveTabPermission
;
}
get
hasActiveTabPermission
(
)
{
return
(
this
.
extension
.
hasPermission
(
"
activeTab
"
)
&
&
this
.
activeTabWindowID
!
=
null
&
&
this
.
activeTabWindowID
=
=
=
this
.
innerWindowID
)
;
}
get
_incognito
(
)
{
return
PrivateBrowsingUtils
.
isBrowserPrivate
(
this
.
browser
)
;
}
get
_url
(
)
{
return
this
.
browser
.
currentURI
.
spec
;
}
get
url
(
)
{
if
(
this
.
hasTabPermission
)
{
return
this
.
_url
;
}
}
get
uri
(
)
{
if
(
this
.
hasTabPermission
)
{
return
this
.
browser
.
currentURI
;
}
}
get
_title
(
)
{
return
this
.
browser
.
contentTitle
|
|
this
.
nativeTab
.
label
;
}
get
title
(
)
{
if
(
this
.
hasTabPermission
)
{
return
this
.
_title
;
}
}
get
_favIconUrl
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
favIconUrl
(
)
{
if
(
this
.
hasTabPermission
)
{
return
this
.
_favIconUrl
;
}
}
get
lastAccessed
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
audible
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
browser
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
frameLoader
(
)
{
return
this
.
browser
.
frameLoader
;
}
get
cookieStoreId
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
openerTabId
(
)
{
return
null
;
}
get
discarded
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
height
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
hidden
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
index
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
mutedInfo
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
sharingState
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
pinned
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
active
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
highlighted
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
selected
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
status
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
width
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
window
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
windowId
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
isArticle
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
isInReaderMode
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
matches
(
queryInfo
)
{
const
PROPS
=
[
"
active
"
"
audible
"
"
cookieStoreId
"
"
discarded
"
"
hidden
"
"
highlighted
"
"
index
"
"
openerTabId
"
"
pinned
"
"
status
"
]
;
function
checkProperty
(
prop
obj
)
{
return
queryInfo
[
prop
]
!
=
null
&
&
queryInfo
[
prop
]
!
=
=
obj
[
prop
]
;
}
if
(
PROPS
.
some
(
prop
=
>
checkProperty
(
prop
this
)
)
)
{
return
false
;
}
if
(
checkProperty
(
"
muted
"
this
.
mutedInfo
)
)
{
return
false
;
}
let
state
=
this
.
sharingState
;
if
(
[
"
camera
"
"
microphone
"
]
.
some
(
prop
=
>
checkProperty
(
prop
state
)
)
)
{
return
false
;
}
if
(
queryInfo
.
screen
!
=
=
null
)
{
let
match
=
typeof
queryInfo
.
screen
=
=
"
boolean
"
?
queryInfo
.
screen
=
=
=
!
!
state
.
screen
:
queryInfo
.
screen
=
=
=
state
.
screen
;
if
(
!
match
)
{
return
false
;
}
}
if
(
queryInfo
.
url
&
&
!
queryInfo
.
url
.
matches
(
this
.
uri
)
)
{
return
false
;
}
if
(
queryInfo
.
title
&
&
!
queryInfo
.
title
.
matches
(
this
.
title
)
)
{
return
false
;
}
return
true
;
}
convert
(
fallbackTab
=
null
)
{
let
result
=
{
id
:
this
.
id
index
:
this
.
index
windowId
:
this
.
windowId
highlighted
:
this
.
highlighted
active
:
this
.
active
pinned
:
this
.
pinned
status
:
this
.
status
hidden
:
this
.
hidden
discarded
:
this
.
discarded
incognito
:
this
.
incognito
width
:
this
.
width
height
:
this
.
height
lastAccessed
:
this
.
lastAccessed
audible
:
this
.
audible
mutedInfo
:
this
.
mutedInfo
isArticle
:
this
.
isArticle
isInReaderMode
:
this
.
isInReaderMode
sharingState
:
this
.
sharingState
}
;
if
(
fallbackTab
&
&
(
!
result
.
width
|
|
!
result
.
height
)
)
{
result
.
width
=
fallbackTab
.
width
;
result
.
height
=
fallbackTab
.
height
;
}
let
opener
=
this
.
openerTabId
;
if
(
opener
)
{
result
.
openerTabId
=
opener
;
}
if
(
this
.
extension
.
hasPermission
(
"
cookies
"
)
)
{
result
.
cookieStoreId
=
this
.
cookieStoreId
;
}
if
(
this
.
hasTabPermission
)
{
for
(
let
prop
of
[
"
url
"
"
title
"
"
favIconUrl
"
]
)
{
let
val
=
this
[
_
{
prop
}
]
;
if
(
val
)
{
result
[
prop
]
=
val
;
}
}
}
return
result
;
}
_execute
(
context
details
kind
method
)
{
let
options
=
{
js
:
[
]
css
:
[
]
remove_css
:
method
=
=
"
removeCSS
"
}
;
if
(
(
details
.
code
=
=
=
null
)
=
=
(
details
.
file
=
=
=
null
)
)
{
return
Promise
.
reject
(
{
message
:
{
method
}
requires
either
a
'
code
'
or
a
'
file
'
property
but
not
both
}
)
;
}
if
(
details
.
frameId
!
=
=
null
&
&
details
.
allFrames
)
{
return
Promise
.
reject
(
{
message
:
'
frameId
'
and
'
allFrames
'
are
mutually
exclusive
}
)
;
}
options
.
hasActiveTabPermission
=
this
.
hasActiveTabPermission
;
options
.
matches
=
this
.
extension
.
whiteListedHosts
.
patterns
.
map
(
host
=
>
host
.
pattern
)
;
if
(
details
.
code
!
=
=
null
)
{
options
[
{
kind
}
Code
]
=
details
.
code
;
}
if
(
details
.
file
!
=
=
null
)
{
let
url
=
context
.
uri
.
resolve
(
details
.
file
)
;
if
(
!
this
.
extension
.
isExtensionURL
(
url
)
)
{
return
Promise
.
reject
(
{
message
:
"
Files
to
be
injected
must
be
within
the
extension
"
}
)
;
}
options
[
kind
]
.
push
(
url
)
;
}
if
(
details
.
allFrames
)
{
options
.
all_frames
=
details
.
allFrames
;
}
if
(
details
.
frameId
!
=
=
null
)
{
options
.
frame_id
=
details
.
frameId
;
}
if
(
details
.
matchAboutBlank
)
{
options
.
match_about_blank
=
details
.
matchAboutBlank
;
}
if
(
details
.
runAt
!
=
=
null
)
{
options
.
run_at
=
details
.
runAt
;
}
else
{
options
.
run_at
=
"
document_idle
"
;
}
if
(
details
.
cssOrigin
!
=
=
null
)
{
options
.
css_origin
=
details
.
cssOrigin
;
}
else
{
options
.
css_origin
=
"
author
"
;
}
options
.
wantReturnValue
=
true
;
return
this
.
sendMessage
(
context
"
Extension
:
Execute
"
{
options
}
)
;
}
executeScript
(
context
details
)
{
return
this
.
_execute
(
context
details
"
js
"
"
executeScript
"
)
;
}
insertCSS
(
context
details
)
{
return
this
.
_execute
(
context
details
"
css
"
"
insertCSS
"
)
.
then
(
(
)
=
>
{
}
)
;
}
removeCSS
(
context
details
)
{
return
this
.
_execute
(
context
details
"
css
"
"
removeCSS
"
)
.
then
(
(
)
=
>
{
}
)
;
}
}
defineLazyGetter
(
TabBase
.
prototype
"
incognito
"
function
(
)
{
return
this
.
_incognito
;
}
)
;
const
WINDOW_ID_NONE
=
-
1
;
const
WINDOW_ID_CURRENT
=
-
2
;
class
WindowBase
{
constructor
(
extension
window
id
)
{
this
.
extension
=
extension
;
this
.
window
=
window
;
this
.
id
=
id
;
}
get
xulWindow
(
)
{
return
this
.
window
.
document
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIXULWindow
)
;
}
isCurrentFor
(
context
)
{
if
(
context
&
&
context
.
currentWindow
)
{
return
this
.
window
=
=
=
context
.
currentWindow
;
}
return
this
.
isLastFocused
;
}
get
type
(
)
{
let
{
chromeFlags
}
=
this
.
xulWindow
;
if
(
chromeFlags
&
Ci
.
nsIWebBrowserChrome
.
CHROME_OPENAS_DIALOG
)
{
return
"
popup
"
;
}
return
"
normal
"
;
}
convert
(
getInfo
)
{
let
result
=
{
id
:
this
.
id
focused
:
this
.
focused
top
:
this
.
top
left
:
this
.
left
width
:
this
.
width
height
:
this
.
height
incognito
:
this
.
incognito
type
:
this
.
type
state
:
this
.
state
alwaysOnTop
:
this
.
alwaysOnTop
title
:
this
.
title
}
;
if
(
getInfo
&
&
getInfo
.
populate
)
{
result
.
tabs
=
Array
.
from
(
this
.
getTabs
(
)
tab
=
>
tab
.
convert
(
)
)
;
}
return
result
;
}
matches
(
queryInfo
context
)
{
if
(
queryInfo
.
lastFocusedWindow
!
=
=
null
&
&
queryInfo
.
lastFocusedWindow
!
=
=
this
.
isLastFocused
)
{
return
false
;
}
if
(
queryInfo
.
windowType
!
=
=
null
&
&
queryInfo
.
windowType
!
=
=
this
.
type
)
{
return
false
;
}
if
(
queryInfo
.
windowId
!
=
=
null
)
{
if
(
queryInfo
.
windowId
=
=
=
WINDOW_ID_CURRENT
)
{
if
(
!
this
.
isCurrentFor
(
context
)
)
{
return
false
;
}
}
else
if
(
queryInfo
.
windowId
!
=
=
this
.
id
)
{
return
false
;
}
}
if
(
queryInfo
.
currentWindow
!
=
=
null
&
&
queryInfo
.
currentWindow
!
=
=
this
.
isCurrentFor
(
context
)
)
{
return
false
;
}
return
true
;
}
get
focused
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
top
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
left
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
width
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
height
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
incognito
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
alwaysOnTop
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
isLastFocused
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
state
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
set
state
(
state
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
title
(
)
{
if
(
this
.
activeTab
&
&
this
.
activeTab
.
hasTabPermission
)
{
return
this
.
_title
;
}
}
static
getState
(
window
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getTabs
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getHighlightedTabs
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
activeTab
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getTabAtIndex
(
index
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
Object
.
assign
(
WindowBase
{
WINDOW_ID_NONE
WINDOW_ID_CURRENT
}
)
;
class
TabTrackerBase
extends
EventEmitter
{
on
(
.
.
.
args
)
{
if
(
!
this
.
initialized
)
{
this
.
init
(
)
;
}
return
super
.
on
(
.
.
.
args
)
;
}
init
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getId
(
nativeTab
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getTab
(
tabId
default_
=
undefined
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getBrowserData
(
browser
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
activeTab
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
class
StatusListener
{
constructor
(
listener
)
{
this
.
listener
=
listener
;
}
onStateChange
(
browser
webProgress
request
stateFlags
statusCode
)
{
if
(
!
webProgress
.
isTopLevel
)
{
return
;
}
let
status
;
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
)
{
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
status
=
"
loading
"
;
}
else
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
status
=
"
complete
"
;
}
}
else
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
statusCode
=
=
Cr
.
NS_BINDING_ABORTED
)
{
status
=
"
complete
"
;
}
if
(
status
)
{
this
.
listener
(
{
browser
status
}
)
;
}
}
onLocationChange
(
browser
webProgress
request
locationURI
flags
)
{
if
(
webProgress
.
isTopLevel
)
{
let
status
=
webProgress
.
isLoadingDocument
?
"
loading
"
:
"
complete
"
;
this
.
listener
(
{
browser
status
url
:
locationURI
.
spec
}
)
;
}
}
}
class
WindowTrackerBase
extends
EventEmitter
{
constructor
(
)
{
super
(
)
;
this
.
_handleWindowOpened
=
this
.
_handleWindowOpened
.
bind
(
this
)
;
this
.
_openListeners
=
new
Set
(
)
;
this
.
_closeListeners
=
new
Set
(
)
;
this
.
_listeners
=
new
DefaultMap
(
(
)
=
>
new
Set
(
)
)
;
this
.
_statusListeners
=
new
DefaultWeakMap
(
listener
=
>
{
return
new
StatusListener
(
listener
)
;
}
)
;
this
.
_windowIds
=
new
DefaultWeakMap
(
window
=
>
{
return
getWinUtils
(
window
)
.
outerWindowID
;
}
)
;
}
isBrowserWindow
(
window
)
{
let
{
documentElement
}
=
window
.
document
;
return
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
=
"
navigator
:
browser
"
;
}
*
browserWindows
(
includeIncomplete
=
false
)
{
let
e
=
Services
.
wm
.
getEnumerator
(
"
"
)
;
while
(
e
.
hasMoreElements
(
)
)
{
let
window
=
e
.
getNext
(
)
;
let
ok
=
includeIncomplete
;
if
(
window
.
document
.
readyState
=
=
=
"
complete
"
)
{
ok
=
this
.
isBrowserWindow
(
window
)
;
}
if
(
ok
)
{
yield
window
;
}
}
}
get
topWindow
(
)
{
return
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
}
getId
(
window
)
{
return
this
.
_windowIds
.
get
(
window
)
;
}
getCurrentWindow
(
context
)
{
return
(
context
&
&
context
.
currentWindow
)
|
|
this
.
topWindow
;
}
getWindow
(
id
context
strict
=
true
)
{
if
(
id
=
=
=
WINDOW_ID_CURRENT
)
{
return
this
.
getCurrentWindow
(
context
)
;
}
let
window
=
Services
.
wm
.
getOuterWindowWithId
(
id
)
;
if
(
window
&
&
!
window
.
closed
&
&
(
window
.
document
.
readyState
!
=
=
"
complete
"
|
|
this
.
isBrowserWindow
(
window
)
)
)
{
return
window
;
}
if
(
strict
)
{
throw
new
ExtensionError
(
Invalid
window
ID
:
{
id
}
)
;
}
}
get
_haveListeners
(
)
{
return
this
.
_openListeners
.
size
>
0
|
|
this
.
_closeListeners
.
size
>
0
;
}
addOpenListener
(
listener
)
{
if
(
!
this
.
_haveListeners
)
{
Services
.
ww
.
registerNotification
(
this
)
;
}
this
.
_openListeners
.
add
(
listener
)
;
for
(
let
window
of
this
.
browserWindows
(
true
)
)
{
if
(
window
.
document
.
readyState
!
=
=
"
complete
"
)
{
window
.
addEventListener
(
"
load
"
this
)
;
}
}
}
removeOpenListener
(
listener
)
{
this
.
_openListeners
.
delete
(
listener
)
;
if
(
!
this
.
_haveListeners
)
{
Services
.
ww
.
unregisterNotification
(
this
)
;
}
}
addCloseListener
(
listener
)
{
if
(
!
this
.
_haveListeners
)
{
Services
.
ww
.
registerNotification
(
this
)
;
}
this
.
_closeListeners
.
add
(
listener
)
;
}
removeCloseListener
(
listener
)
{
this
.
_closeListeners
.
delete
(
listener
)
;
if
(
!
this
.
_haveListeners
)
{
Services
.
ww
.
unregisterNotification
(
this
)
;
}
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
=
"
load
"
)
{
event
.
currentTarget
.
removeEventListener
(
event
.
type
this
)
;
let
window
=
event
.
target
.
defaultView
;
if
(
!
this
.
isBrowserWindow
(
window
)
)
{
return
;
}
for
(
let
listener
of
this
.
_openListeners
)
{
try
{
listener
(
window
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
}
observe
(
window
topic
)
{
if
(
topic
=
=
=
"
domwindowclosed
"
)
{
if
(
!
this
.
isBrowserWindow
(
window
)
)
{
return
;
}
window
.
removeEventListener
(
"
load
"
this
)
;
for
(
let
listener
of
this
.
_closeListeners
)
{
try
{
listener
(
window
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
else
if
(
topic
=
=
=
"
domwindowopened
"
)
{
window
.
addEventListener
(
"
load
"
this
)
;
}
}
addListener
(
type
listener
)
{
if
(
type
=
=
=
"
domwindowopened
"
)
{
return
this
.
addOpenListener
(
listener
)
;
}
else
if
(
type
=
=
=
"
domwindowclosed
"
)
{
return
this
.
addCloseListener
(
listener
)
;
}
if
(
this
.
_listeners
.
size
=
=
=
0
)
{
this
.
addOpenListener
(
this
.
_handleWindowOpened
)
;
}
if
(
type
=
=
=
"
status
"
)
{
listener
=
this
.
_statusListeners
.
get
(
listener
)
;
type
=
"
progress
"
;
}
this
.
_listeners
.
get
(
type
)
.
add
(
listener
)
;
for
(
let
window
of
this
.
browserWindows
(
)
)
{
this
.
_addWindowListener
(
window
type
listener
)
;
}
}
removeListener
(
type
listener
)
{
if
(
type
=
=
=
"
domwindowopened
"
)
{
return
this
.
removeOpenListener
(
listener
)
;
}
else
if
(
type
=
=
=
"
domwindowclosed
"
)
{
return
this
.
removeCloseListener
(
listener
)
;
}
if
(
type
=
=
=
"
status
"
)
{
listener
=
this
.
_statusListeners
.
get
(
listener
)
;
type
=
"
progress
"
;
}
let
listeners
=
this
.
_listeners
.
get
(
type
)
;
listeners
.
delete
(
listener
)
;
if
(
listeners
.
size
=
=
=
0
)
{
this
.
_listeners
.
delete
(
type
)
;
if
(
this
.
_listeners
.
size
=
=
=
0
)
{
this
.
removeOpenListener
(
this
.
_handleWindowOpened
)
;
}
}
let
useCapture
=
type
=
=
=
"
focus
"
|
|
type
=
=
=
"
blur
"
;
for
(
let
window
of
this
.
browserWindows
(
)
)
{
if
(
type
=
=
=
"
progress
"
)
{
this
.
removeProgressListener
(
window
listener
)
;
}
else
{
window
.
removeEventListener
(
type
listener
useCapture
)
;
}
}
}
_addWindowListener
(
window
eventType
listener
)
{
let
useCapture
=
eventType
=
=
=
"
focus
"
|
|
eventType
=
=
=
"
blur
"
;
if
(
eventType
=
=
=
"
progress
"
)
{
this
.
addProgressListener
(
window
listener
)
;
}
else
{
window
.
addEventListener
(
eventType
listener
useCapture
)
;
}
}
_handleWindowOpened
(
window
)
{
for
(
let
[
eventType
listeners
]
of
this
.
_listeners
)
{
for
(
let
listener
of
listeners
)
{
this
.
_addWindowListener
(
window
eventType
listener
)
;
}
}
}
addProgressListener
(
window
listener
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
removeProgressListener
(
window
listener
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
class
TabManagerBase
{
constructor
(
extension
)
{
this
.
extension
=
extension
;
this
.
_tabs
=
new
DefaultWeakMap
(
tab
=
>
this
.
wrapTab
(
tab
)
)
;
}
addActiveTabPermission
(
nativeTab
)
{
if
(
this
.
extension
.
hasPermission
(
"
activeTab
"
)
)
{
let
tab
=
this
.
getWrapper
(
nativeTab
)
;
tab
.
activeTabWindowID
=
tab
.
innerWindowID
;
}
}
revokeActiveTabPermission
(
nativeTab
)
{
this
.
getWrapper
(
nativeTab
)
.
activeTabWindowID
=
null
;
}
hasActiveTabPermission
(
nativeTab
)
{
return
this
.
getWrapper
(
nativeTab
)
.
hasActiveTabPermission
;
}
hasTabPermission
(
nativeTab
)
{
return
this
.
getWrapper
(
nativeTab
)
.
hasTabPermission
;
}
getWrapper
(
nativeTab
)
{
return
this
.
_tabs
.
get
(
nativeTab
)
;
}
convert
(
nativeTab
fallbackTab
=
null
)
{
return
this
.
getWrapper
(
nativeTab
)
.
convert
(
fallbackTab
&
&
this
.
getWrapper
(
fallbackTab
)
)
;
}
*
query
(
queryInfo
=
null
context
=
null
)
{
function
*
candidates
(
windowWrapper
)
{
if
(
queryInfo
)
{
let
{
active
highlighted
index
}
=
queryInfo
;
if
(
active
=
=
=
true
)
{
yield
windowWrapper
.
activeTab
;
return
;
}
if
(
index
!
=
null
)
{
let
tabWrapper
=
windowWrapper
.
getTabAtIndex
(
index
)
;
if
(
tabWrapper
)
{
yield
tabWrapper
;
}
return
;
}
if
(
highlighted
=
=
=
true
)
{
yield
*
windowWrapper
.
getHighlightedTabs
(
)
;
return
;
}
}
yield
*
windowWrapper
.
getTabs
(
)
;
}
let
windowWrappers
=
this
.
extension
.
windowManager
.
query
(
queryInfo
context
)
;
for
(
let
windowWrapper
of
windowWrappers
)
{
for
(
let
tabWrapper
of
candidates
(
windowWrapper
)
)
{
if
(
!
queryInfo
|
|
tabWrapper
.
matches
(
queryInfo
)
)
{
yield
tabWrapper
;
}
}
}
}
get
(
tabId
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
wrapTab
(
nativeTab
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
class
WindowManagerBase
{
constructor
(
extension
)
{
this
.
extension
=
extension
;
this
.
_windows
=
new
DefaultWeakMap
(
window
=
>
this
.
wrapWindow
(
window
)
)
;
}
convert
(
window
.
.
.
args
)
{
return
this
.
getWrapper
(
window
)
.
convert
(
.
.
.
args
)
;
}
getWrapper
(
window
)
{
return
this
.
_windows
.
get
(
window
)
;
}
*
query
(
queryInfo
=
null
context
=
null
)
{
function
*
candidates
(
windowManager
)
{
if
(
queryInfo
)
{
let
{
currentWindow
windowId
lastFocusedWindow
}
=
queryInfo
;
if
(
currentWindow
=
=
=
true
&
&
windowId
=
=
null
)
{
windowId
=
WINDOW_ID_CURRENT
;
}
if
(
windowId
!
=
null
)
{
let
window
=
global
.
windowTracker
.
getWindow
(
windowId
context
false
)
;
if
(
window
)
{
yield
windowManager
.
getWrapper
(
window
)
;
}
return
;
}
if
(
lastFocusedWindow
=
=
=
true
)
{
yield
windowManager
.
getWrapper
(
global
.
windowTracker
.
topWindow
)
;
return
;
}
}
yield
*
windowManager
.
getAll
(
)
;
}
for
(
let
windowWrapper
of
candidates
(
this
)
)
{
if
(
!
queryInfo
|
|
windowWrapper
.
matches
(
queryInfo
context
)
)
{
yield
windowWrapper
;
}
}
}
get
(
windowId
context
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getAll
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
wrapWindow
(
window
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
Object
.
assign
(
global
{
TabTrackerBase
TabManagerBase
TabBase
WindowTrackerBase
WindowManagerBase
WindowBase
}
)
;
