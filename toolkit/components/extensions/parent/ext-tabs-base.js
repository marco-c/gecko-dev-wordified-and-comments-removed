"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
containersEnabled
"
"
privacy
.
userContext
.
enabled
"
)
;
var
{
DefaultMap
DefaultWeakMap
ExtensionError
parseMatchPatterns
}
=
ExtensionUtils
;
var
{
defineLazyGetter
}
=
ExtensionCommon
;
class
TabBase
{
constructor
(
extension
nativeTab
id
)
{
this
.
extension
=
extension
;
this
.
tabManager
=
extension
.
tabManager
;
this
.
id
=
id
;
this
.
nativeTab
=
nativeTab
;
this
.
activeTabWindowID
=
null
;
if
(
!
extension
.
privateBrowsingAllowed
&
&
this
.
_incognito
)
{
throw
new
ExtensionError
(
Invalid
tab
ID
:
{
id
}
)
;
}
}
async
capture
(
context
zoom
options
)
{
let
win
=
this
.
browser
.
ownerGlobal
;
let
scale
=
options
?
.
scale
|
|
win
.
devicePixelRatio
;
let
rect
=
options
?
.
rect
&
&
win
.
DOMRect
.
fromRect
(
options
.
rect
)
;
let
resetScrollPosition
=
false
;
if
(
!
context
.
extension
.
restrictSchemes
)
{
resetScrollPosition
=
!
!
options
?
.
resetScrollPosition
;
}
let
wgp
=
this
.
browsingContext
.
currentWindowGlobal
;
let
image
=
await
wgp
.
drawSnapshot
(
rect
scale
*
zoom
"
white
"
resetScrollPosition
)
;
let
doc
=
Services
.
appShell
.
hiddenDOMWindow
.
document
;
let
canvas
=
doc
.
createElement
(
"
canvas
"
)
;
canvas
.
width
=
image
.
width
;
canvas
.
height
=
image
.
height
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
{
alpha
:
false
}
)
;
ctx
.
drawImage
(
image
0
0
)
;
image
.
close
(
)
;
return
canvas
.
toDataURL
(
image
/
{
options
?
.
format
}
options
?
.
quality
/
100
)
;
}
get
innerWindowID
(
)
{
return
this
.
browser
.
innerWindowID
;
}
get
hasTabPermission
(
)
{
return
(
this
.
extension
.
hasPermission
(
"
tabs
"
)
|
|
this
.
hasActiveTabPermission
|
|
this
.
matchesHostPermission
)
;
}
get
hasActiveTabPermission
(
)
{
return
(
(
this
.
extension
.
originControls
|
|
this
.
extension
.
hasPermission
(
"
activeTab
"
)
)
&
&
this
.
activeTabWindowID
!
=
null
&
&
this
.
activeTabWindowID
=
=
=
this
.
innerWindowID
)
;
}
get
matchesHostPermission
(
)
{
return
this
.
extension
.
allowedOrigins
.
matches
(
this
.
_uri
)
;
}
get
_incognito
(
)
{
return
PrivateBrowsingUtils
.
isBrowserPrivate
(
this
.
browser
)
;
}
get
_url
(
)
{
return
this
.
browser
.
currentURI
.
spec
;
}
get
url
(
)
{
if
(
this
.
hasTabPermission
)
{
return
this
.
_url
;
}
}
get
_uri
(
)
{
return
this
.
browser
.
currentURI
;
}
get
_title
(
)
{
return
this
.
browser
.
contentTitle
|
|
this
.
nativeTab
.
label
;
}
get
title
(
)
{
if
(
this
.
hasTabPermission
)
{
return
this
.
_title
;
}
}
get
_favIconUrl
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
favIconUrl
(
)
{
if
(
this
.
hasTabPermission
)
{
return
this
.
_favIconUrl
;
}
}
get
lastAccessed
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
audible
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
browser
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
browsingContext
(
)
{
return
this
.
browser
?
.
browsingContext
;
}
get
frameLoader
(
)
{
return
this
.
browser
&
&
this
.
browser
.
frameLoader
;
}
get
cookieStoreId
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
openerTabId
(
)
{
return
null
;
}
get
discarded
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
height
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
hidden
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
index
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
mutedInfo
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
sharingState
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
pinned
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
active
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
highlighted
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
status
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
width
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
window
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
windowId
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
attention
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
isArticle
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
isInReaderMode
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
successorTabId
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
matches
(
queryInfo
)
{
const
PROPS
=
[
"
active
"
"
audible
"
"
discarded
"
"
hidden
"
"
highlighted
"
"
index
"
"
openerTabId
"
"
pinned
"
"
status
"
]
;
function
checkProperty
(
prop
obj
)
{
return
queryInfo
[
prop
]
!
=
null
&
&
queryInfo
[
prop
]
!
=
=
obj
[
prop
]
;
}
if
(
PROPS
.
some
(
prop
=
>
checkProperty
(
prop
this
)
)
)
{
return
false
;
}
if
(
checkProperty
(
"
muted
"
this
.
mutedInfo
)
)
{
return
false
;
}
let
state
=
this
.
sharingState
;
if
(
[
"
camera
"
"
microphone
"
]
.
some
(
prop
=
>
checkProperty
(
prop
state
)
)
)
{
return
false
;
}
if
(
queryInfo
.
screen
!
=
=
null
)
{
let
match
=
typeof
queryInfo
.
screen
=
=
"
boolean
"
?
queryInfo
.
screen
=
=
=
!
!
state
.
screen
:
queryInfo
.
screen
=
=
=
state
.
screen
;
if
(
!
match
)
{
return
false
;
}
}
if
(
queryInfo
.
cookieStoreId
)
{
if
(
!
queryInfo
.
cookieStoreId
.
includes
(
this
.
cookieStoreId
)
)
{
return
false
;
}
}
if
(
queryInfo
.
url
|
|
queryInfo
.
title
)
{
if
(
!
this
.
hasTabPermission
)
{
return
false
;
}
if
(
queryInfo
.
url
&
&
!
queryInfo
.
url
.
matches
(
this
.
_uri
)
)
{
return
false
;
}
if
(
queryInfo
.
title
&
&
!
queryInfo
.
title
.
matches
(
this
.
_title
)
)
{
return
false
;
}
}
return
true
;
}
convert
(
fallbackTabSize
=
null
)
{
let
result
=
{
id
:
this
.
id
index
:
this
.
index
windowId
:
this
.
windowId
highlighted
:
this
.
highlighted
active
:
this
.
active
attention
:
this
.
attention
pinned
:
this
.
pinned
status
:
this
.
status
hidden
:
this
.
hidden
discarded
:
this
.
discarded
incognito
:
this
.
incognito
width
:
this
.
width
height
:
this
.
height
lastAccessed
:
this
.
lastAccessed
audible
:
this
.
audible
mutedInfo
:
this
.
mutedInfo
isArticle
:
this
.
isArticle
isInReaderMode
:
this
.
isInReaderMode
sharingState
:
this
.
sharingState
successorTabId
:
this
.
successorTabId
cookieStoreId
:
this
.
cookieStoreId
}
;
if
(
fallbackTabSize
&
&
(
!
result
.
width
|
|
!
result
.
height
)
)
{
result
.
width
=
fallbackTabSize
.
width
;
result
.
height
=
fallbackTabSize
.
height
;
}
let
opener
=
this
.
openerTabId
;
if
(
opener
)
{
result
.
openerTabId
=
opener
;
}
if
(
this
.
hasTabPermission
)
{
for
(
let
prop
of
[
"
url
"
"
title
"
"
favIconUrl
"
]
)
{
let
val
=
this
[
_
{
prop
}
]
;
if
(
val
)
{
result
[
prop
]
=
val
;
}
}
}
return
result
;
}
async
queryContent
(
message
options
)
{
let
{
frameIds
}
=
options
;
let
byProcess
=
new
DefaultMap
(
(
)
=
>
[
]
)
;
let
frameIdsSet
=
new
Set
(
frameIds
)
;
function
visit
(
bc
)
{
let
win
=
bc
.
currentWindowGlobal
;
let
frameId
=
bc
.
parent
?
bc
.
id
:
0
;
if
(
win
?
.
domProcess
&
&
(
!
frameIds
|
|
frameIdsSet
.
has
(
frameId
)
)
)
{
byProcess
.
get
(
win
.
domProcess
)
.
push
(
win
.
innerWindowId
)
;
frameIdsSet
.
delete
(
frameId
)
;
}
if
(
!
frameIds
|
|
frameIdsSet
.
size
>
0
)
{
bc
.
children
.
forEach
(
visit
)
;
}
}
visit
(
this
.
browsingContext
)
;
if
(
frameIdsSet
.
size
>
0
)
{
throw
new
ExtensionError
(
Invalid
frame
IDs
:
[
{
Array
.
from
(
frameIdsSet
)
.
join
(
"
"
)
}
]
.
)
;
}
let
promises
=
Array
.
from
(
byProcess
.
entries
(
)
(
[
proc
windows
]
)
=
>
proc
.
getActor
(
"
ExtensionContent
"
)
.
sendQuery
(
message
{
windows
options
}
)
)
;
let
results
=
await
Promise
.
all
(
promises
)
.
catch
(
err
=
>
{
if
(
err
.
name
=
=
=
"
DataCloneError
"
)
{
let
fileName
=
options
.
jsPaths
.
slice
(
-
1
)
[
0
]
|
|
"
<
anonymous
code
>
"
;
let
message
=
Script
'
{
fileName
}
'
result
is
non
-
structured
-
clonable
data
;
return
Promise
.
reject
(
{
message
fileName
}
)
;
}
throw
err
;
}
)
;
results
=
results
.
flat
(
)
;
if
(
!
results
.
length
)
{
let
errorMessage
=
"
Missing
host
permission
for
the
tab
"
;
if
(
!
frameIds
|
|
frameIds
.
length
>
1
|
|
frameIds
[
0
]
!
=
=
0
)
{
errorMessage
+
=
"
or
frames
"
;
}
throw
new
ExtensionError
(
errorMessage
)
;
}
if
(
frameIds
&
&
frameIds
.
length
=
=
=
1
&
&
results
.
length
>
1
)
{
throw
new
ExtensionError
(
"
Internal
error
:
multiple
windows
matched
"
)
;
}
return
results
;
}
_execute
(
context
details
kind
method
)
{
let
options
=
{
jsPaths
:
[
]
cssPaths
:
[
]
removeCSS
:
method
=
=
"
removeCSS
"
extensionId
:
context
.
extension
.
id
}
;
if
(
(
details
.
code
=
=
=
null
)
=
=
(
details
.
file
=
=
=
null
)
)
{
return
Promise
.
reject
(
{
message
:
{
method
}
requires
either
a
'
code
'
or
a
'
file
'
property
but
not
both
}
)
;
}
if
(
details
.
frameId
!
=
=
null
&
&
details
.
allFrames
)
{
return
Promise
.
reject
(
{
message
:
'
frameId
'
and
'
allFrames
'
are
mutually
exclusive
}
)
;
}
options
.
hasActiveTabPermission
=
this
.
hasActiveTabPermission
;
options
.
matches
=
this
.
extension
.
allowedOrigins
.
patterns
.
map
(
host
=
>
host
.
pattern
)
;
if
(
details
.
code
!
=
=
null
)
{
options
[
{
kind
}
Code
]
=
details
.
code
;
}
if
(
details
.
file
!
=
=
null
)
{
let
url
=
context
.
uri
.
resolve
(
details
.
file
)
;
if
(
!
this
.
extension
.
isExtensionURL
(
url
)
)
{
return
Promise
.
reject
(
{
message
:
"
Files
to
be
injected
must
be
within
the
extension
"
}
)
;
}
options
[
{
kind
}
Paths
]
.
push
(
url
)
;
}
if
(
details
.
allFrames
)
{
options
.
allFrames
=
true
;
}
else
if
(
details
.
frameId
!
=
=
null
)
{
options
.
frameIds
=
[
details
.
frameId
]
;
}
else
if
(
!
details
.
allFrames
)
{
options
.
frameIds
=
[
0
]
;
}
if
(
details
.
matchAboutBlank
)
{
options
.
matchAboutBlank
=
details
.
matchAboutBlank
;
}
if
(
details
.
runAt
!
=
=
null
)
{
options
.
runAt
=
details
.
runAt
;
}
else
{
options
.
runAt
=
"
document_idle
"
;
}
if
(
details
.
cssOrigin
!
=
=
null
)
{
options
.
cssOrigin
=
details
.
cssOrigin
;
}
else
{
options
.
cssOrigin
=
"
author
"
;
}
options
.
wantReturnValue
=
true
;
return
this
.
queryContent
(
"
Execute
"
options
)
;
}
executeScript
(
context
details
)
{
return
this
.
_execute
(
context
details
"
js
"
"
executeScript
"
)
;
}
insertCSS
(
context
details
)
{
return
this
.
_execute
(
context
details
"
css
"
"
insertCSS
"
)
.
then
(
(
)
=
>
{
}
)
;
}
removeCSS
(
context
details
)
{
return
this
.
_execute
(
context
details
"
css
"
"
removeCSS
"
)
.
then
(
(
)
=
>
{
}
)
;
}
}
defineLazyGetter
(
TabBase
.
prototype
"
incognito
"
function
(
)
{
return
this
.
_incognito
;
}
)
;
const
WINDOW_ID_NONE
=
-
1
;
const
WINDOW_ID_CURRENT
=
-
2
;
class
WindowBase
{
constructor
(
extension
window
id
)
{
if
(
!
extension
.
canAccessWindow
(
window
)
)
{
throw
new
ExtensionError
(
"
extension
cannot
access
window
"
)
;
}
this
.
extension
=
extension
;
this
.
window
=
window
;
this
.
id
=
id
;
}
get
appWindow
(
)
{
return
this
.
window
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIAppWindow
)
;
}
isCurrentFor
(
context
)
{
if
(
context
&
&
context
.
currentWindow
)
{
return
this
.
window
=
=
=
context
.
currentWindow
;
}
return
this
.
isLastFocused
;
}
get
type
(
)
{
let
{
chromeFlags
}
=
this
.
appWindow
;
if
(
chromeFlags
&
Ci
.
nsIWebBrowserChrome
.
CHROME_OPENAS_DIALOG
)
{
return
"
popup
"
;
}
return
"
normal
"
;
}
convert
(
getInfo
)
{
let
result
=
{
id
:
this
.
id
focused
:
this
.
focused
top
:
this
.
top
left
:
this
.
left
width
:
this
.
width
height
:
this
.
height
incognito
:
this
.
incognito
type
:
this
.
type
state
:
this
.
state
alwaysOnTop
:
this
.
alwaysOnTop
title
:
this
.
title
}
;
if
(
getInfo
&
&
getInfo
.
populate
)
{
result
.
tabs
=
Array
.
from
(
this
.
getTabs
(
)
tab
=
>
tab
.
convert
(
)
)
;
}
return
result
;
}
matches
(
queryInfo
context
)
{
if
(
queryInfo
.
lastFocusedWindow
!
=
=
null
&
&
queryInfo
.
lastFocusedWindow
!
=
=
this
.
isLastFocused
)
{
return
false
;
}
if
(
queryInfo
.
windowType
!
=
=
null
&
&
queryInfo
.
windowType
!
=
=
this
.
type
)
{
return
false
;
}
if
(
queryInfo
.
windowId
!
=
=
null
)
{
if
(
queryInfo
.
windowId
=
=
=
WINDOW_ID_CURRENT
)
{
if
(
!
this
.
isCurrentFor
(
context
)
)
{
return
false
;
}
}
else
if
(
queryInfo
.
windowId
!
=
=
this
.
id
)
{
return
false
;
}
}
if
(
queryInfo
.
currentWindow
!
=
=
null
&
&
queryInfo
.
currentWindow
!
=
=
this
.
isCurrentFor
(
context
)
)
{
return
false
;
}
return
true
;
}
get
focused
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
top
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
left
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
width
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
height
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
incognito
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
alwaysOnTop
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
isLastFocused
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
state
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
set
state
(
state
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
title
(
)
{
if
(
this
.
activeTab
&
&
this
.
activeTab
.
hasTabPermission
)
{
return
this
.
_title
;
}
}
static
getState
(
window
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getTabs
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getHighlightedTabs
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
activeTab
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getTabAtIndex
(
index
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
Object
.
assign
(
WindowBase
{
WINDOW_ID_NONE
WINDOW_ID_CURRENT
}
)
;
class
TabTrackerBase
extends
EventEmitter
{
on
(
.
.
.
args
)
{
if
(
!
this
.
initialized
)
{
this
.
init
(
)
;
}
return
super
.
on
(
.
.
.
args
)
;
}
init
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getId
(
nativeTab
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getTab
(
tabId
default_
=
undefined
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getBrowserData
(
browser
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
activeTab
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
class
StatusListener
{
constructor
(
listener
)
{
this
.
listener
=
listener
;
}
onStateChange
(
browser
webProgress
request
stateFlags
statusCode
)
{
if
(
!
webProgress
.
isTopLevel
)
{
return
;
}
let
status
;
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
)
{
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
status
=
"
loading
"
;
}
else
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
status
=
"
complete
"
;
}
}
else
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
statusCode
=
=
Cr
.
NS_BINDING_ABORTED
)
{
status
=
"
complete
"
;
}
if
(
status
)
{
this
.
listener
(
{
browser
status
}
)
;
}
}
onLocationChange
(
browser
webProgress
request
locationURI
flags
)
{
if
(
webProgress
.
isTopLevel
)
{
let
status
=
webProgress
.
isLoadingDocument
?
"
loading
"
:
"
complete
"
;
this
.
listener
(
{
browser
status
url
:
locationURI
.
spec
}
)
;
}
}
}
class
WindowTrackerBase
extends
EventEmitter
{
constructor
(
)
{
super
(
)
;
this
.
_handleWindowOpened
=
this
.
_handleWindowOpened
.
bind
(
this
)
;
this
.
_openListeners
=
new
Set
(
)
;
this
.
_closeListeners
=
new
Set
(
)
;
this
.
_listeners
=
new
DefaultMap
(
(
)
=
>
new
Set
(
)
)
;
this
.
_statusListeners
=
new
DefaultWeakMap
(
listener
=
>
{
return
new
StatusListener
(
listener
)
;
}
)
;
this
.
_windowIds
=
new
DefaultWeakMap
(
window
=
>
{
return
window
.
docShell
.
outerWindowID
;
}
)
;
}
isBrowserWindow
(
window
)
{
let
{
documentElement
}
=
window
.
document
;
return
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
=
"
navigator
:
browser
"
;
}
*
browserWindows
(
includeIncomplete
=
false
)
{
for
(
let
window
of
Services
.
wm
.
getEnumerator
(
"
"
)
)
{
let
ok
=
includeIncomplete
;
if
(
window
.
document
.
readyState
=
=
=
"
complete
"
)
{
ok
=
this
.
isBrowserWindow
(
window
)
;
}
if
(
ok
)
{
yield
window
;
}
}
}
get
topWindow
(
)
{
return
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
}
get
topNonPBWindow
(
)
{
return
Services
.
wm
.
getMostRecentNonPBWindow
(
"
navigator
:
browser
"
)
;
}
getTopWindow
(
context
)
{
if
(
context
&
&
!
context
.
privateBrowsingAllowed
)
{
return
this
.
topNonPBWindow
;
}
return
this
.
topWindow
;
}
getId
(
window
)
{
return
this
.
_windowIds
.
get
(
window
)
;
}
getCurrentWindow
(
context
)
{
return
(
context
&
&
context
.
currentWindow
)
|
|
this
.
getTopWindow
(
context
)
;
}
getWindow
(
id
context
strict
=
true
)
{
if
(
id
=
=
=
WINDOW_ID_CURRENT
)
{
return
this
.
getCurrentWindow
(
context
)
;
}
let
window
=
Services
.
wm
.
getOuterWindowWithId
(
id
)
;
if
(
window
&
&
!
window
.
closed
&
&
(
window
.
document
.
readyState
!
=
=
"
complete
"
|
|
this
.
isBrowserWindow
(
window
)
)
)
{
if
(
!
context
|
|
context
.
canAccessWindow
(
window
)
)
{
return
window
;
}
}
if
(
strict
)
{
throw
new
ExtensionError
(
Invalid
window
ID
:
{
id
}
)
;
}
}
get
_haveListeners
(
)
{
return
this
.
_openListeners
.
size
>
0
|
|
this
.
_closeListeners
.
size
>
0
;
}
addOpenListener
(
listener
)
{
if
(
!
this
.
_haveListeners
)
{
Services
.
ww
.
registerNotification
(
this
)
;
}
this
.
_openListeners
.
add
(
listener
)
;
for
(
let
window
of
this
.
browserWindows
(
true
)
)
{
if
(
window
.
document
.
readyState
!
=
=
"
complete
"
)
{
window
.
addEventListener
(
"
load
"
this
)
;
}
}
}
removeOpenListener
(
listener
)
{
this
.
_openListeners
.
delete
(
listener
)
;
if
(
!
this
.
_haveListeners
)
{
Services
.
ww
.
unregisterNotification
(
this
)
;
}
}
addCloseListener
(
listener
)
{
if
(
!
this
.
_haveListeners
)
{
Services
.
ww
.
registerNotification
(
this
)
;
}
this
.
_closeListeners
.
add
(
listener
)
;
}
removeCloseListener
(
listener
)
{
this
.
_closeListeners
.
delete
(
listener
)
;
if
(
!
this
.
_haveListeners
)
{
Services
.
ww
.
unregisterNotification
(
this
)
;
}
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
=
"
load
"
)
{
event
.
currentTarget
.
removeEventListener
(
event
.
type
this
)
;
let
window
=
event
.
target
.
defaultView
;
if
(
!
this
.
isBrowserWindow
(
window
)
)
{
return
;
}
for
(
let
listener
of
this
.
_openListeners
)
{
try
{
listener
(
window
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
}
observe
(
window
topic
)
{
if
(
topic
=
=
=
"
domwindowclosed
"
)
{
if
(
!
this
.
isBrowserWindow
(
window
)
)
{
return
;
}
window
.
removeEventListener
(
"
load
"
this
)
;
for
(
let
listener
of
this
.
_closeListeners
)
{
try
{
listener
(
window
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
else
if
(
topic
=
=
=
"
domwindowopened
"
)
{
window
.
addEventListener
(
"
load
"
this
)
;
}
}
addListener
(
type
listener
)
{
if
(
type
=
=
=
"
domwindowopened
"
)
{
return
this
.
addOpenListener
(
listener
)
;
}
else
if
(
type
=
=
=
"
domwindowclosed
"
)
{
return
this
.
addCloseListener
(
listener
)
;
}
if
(
this
.
_listeners
.
size
=
=
=
0
)
{
this
.
addOpenListener
(
this
.
_handleWindowOpened
)
;
}
if
(
type
=
=
=
"
status
"
)
{
listener
=
this
.
_statusListeners
.
get
(
listener
)
;
type
=
"
progress
"
;
}
this
.
_listeners
.
get
(
type
)
.
add
(
listener
)
;
for
(
let
window
of
this
.
browserWindows
(
)
)
{
this
.
_addWindowListener
(
window
type
listener
)
;
}
}
removeListener
(
type
listener
)
{
if
(
type
=
=
=
"
domwindowopened
"
)
{
return
this
.
removeOpenListener
(
listener
)
;
}
else
if
(
type
=
=
=
"
domwindowclosed
"
)
{
return
this
.
removeCloseListener
(
listener
)
;
}
if
(
type
=
=
=
"
status
"
)
{
listener
=
this
.
_statusListeners
.
get
(
listener
)
;
type
=
"
progress
"
;
}
let
listeners
=
this
.
_listeners
.
get
(
type
)
;
listeners
.
delete
(
listener
)
;
if
(
listeners
.
size
=
=
=
0
)
{
this
.
_listeners
.
delete
(
type
)
;
if
(
this
.
_listeners
.
size
=
=
=
0
)
{
this
.
removeOpenListener
(
this
.
_handleWindowOpened
)
;
}
}
let
useCapture
=
type
=
=
=
"
focus
"
|
|
type
=
=
=
"
blur
"
;
for
(
let
window
of
this
.
browserWindows
(
)
)
{
if
(
type
=
=
=
"
progress
"
)
{
this
.
removeProgressListener
(
window
listener
)
;
}
else
{
window
.
removeEventListener
(
type
listener
useCapture
)
;
}
}
}
_addWindowListener
(
window
eventType
listener
)
{
let
useCapture
=
eventType
=
=
=
"
focus
"
|
|
eventType
=
=
=
"
blur
"
;
if
(
eventType
=
=
=
"
progress
"
)
{
this
.
addProgressListener
(
window
listener
)
;
}
else
{
window
.
addEventListener
(
eventType
listener
useCapture
)
;
}
}
_handleWindowOpened
(
window
)
{
for
(
let
[
eventType
listeners
]
of
this
.
_listeners
)
{
for
(
let
listener
of
listeners
)
{
this
.
_addWindowListener
(
window
eventType
listener
)
;
}
}
}
addProgressListener
(
window
listener
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
removeProgressListener
(
window
listener
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
class
TabManagerBase
{
constructor
(
extension
)
{
this
.
extension
=
extension
;
this
.
_tabs
=
new
DefaultWeakMap
(
tab
=
>
this
.
wrapTab
(
tab
)
)
;
}
addActiveTabPermission
(
nativeTab
)
{
let
tab
=
this
.
getWrapper
(
nativeTab
)
;
if
(
this
.
extension
.
hasPermission
(
"
activeTab
"
)
|
|
(
this
.
extension
.
originControls
&
&
this
.
extension
.
optionalOrigins
.
matches
(
tab
.
_uri
)
)
)
{
tab
.
activeTabWindowID
=
tab
.
innerWindowID
;
}
}
revokeActiveTabPermission
(
nativeTab
)
{
this
.
getWrapper
(
nativeTab
)
.
activeTabWindowID
=
null
;
}
hasActiveTabPermission
(
nativeTab
)
{
return
this
.
getWrapper
(
nativeTab
)
.
hasActiveTabPermission
;
}
activateScripts
(
nativeTab
)
{
let
tab
=
this
.
getWrapper
(
nativeTab
)
;
if
(
this
.
extension
.
originControls
&
&
this
.
extension
.
optionalOrigins
.
matches
(
tab
.
_uri
)
&
&
!
tab
.
matchesHostPermission
&
&
(
this
.
extension
.
contentScripts
.
length
|
|
this
.
extension
.
registeredContentScripts
.
size
)
)
{
tab
.
queryContent
(
"
ActivateScripts
"
{
id
:
this
.
extension
.
id
}
)
;
}
}
hasTabPermission
(
nativeTab
)
{
return
this
.
getWrapper
(
nativeTab
)
.
hasTabPermission
;
}
getWrapper
(
nativeTab
)
{
if
(
this
.
canAccessTab
(
nativeTab
)
)
{
return
this
.
_tabs
.
get
(
nativeTab
)
;
}
}
canAccessTab
(
nativeTab
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
convert
(
nativeTab
fallbackTabSize
=
null
)
{
return
this
.
getWrapper
(
nativeTab
)
.
convert
(
fallbackTabSize
)
;
}
*
query
(
queryInfo
=
null
context
=
null
)
{
if
(
queryInfo
)
{
if
(
queryInfo
.
url
!
=
=
null
)
{
queryInfo
.
url
=
parseMatchPatterns
(
[
]
.
concat
(
queryInfo
.
url
)
{
restrictSchemes
:
false
}
)
;
}
if
(
queryInfo
.
cookieStoreId
!
=
=
null
)
{
queryInfo
.
cookieStoreId
=
[
]
.
concat
(
queryInfo
.
cookieStoreId
)
;
}
if
(
queryInfo
.
title
!
=
=
null
)
{
try
{
queryInfo
.
title
=
new
MatchGlob
(
queryInfo
.
title
)
;
}
catch
(
e
)
{
throw
new
ExtensionError
(
Invalid
title
:
{
queryInfo
.
title
}
)
;
}
}
}
function
*
candidates
(
windowWrapper
)
{
if
(
queryInfo
)
{
let
{
active
highlighted
index
}
=
queryInfo
;
if
(
active
=
=
=
true
)
{
let
{
activeTab
}
=
windowWrapper
;
if
(
activeTab
)
{
yield
activeTab
;
}
return
;
}
if
(
index
!
=
null
)
{
let
tabWrapper
=
windowWrapper
.
getTabAtIndex
(
index
)
;
if
(
tabWrapper
)
{
yield
tabWrapper
;
}
return
;
}
if
(
highlighted
=
=
=
true
)
{
yield
*
windowWrapper
.
getHighlightedTabs
(
)
;
return
;
}
}
yield
*
windowWrapper
.
getTabs
(
)
;
}
let
windowWrappers
=
this
.
extension
.
windowManager
.
query
(
queryInfo
context
)
;
for
(
let
windowWrapper
of
windowWrappers
)
{
for
(
let
tabWrapper
of
candidates
(
windowWrapper
)
)
{
if
(
!
queryInfo
|
|
tabWrapper
.
matches
(
queryInfo
)
)
{
yield
tabWrapper
;
}
}
}
}
get
(
tabId
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
wrapTab
(
nativeTab
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
class
WindowManagerBase
{
constructor
(
extension
)
{
this
.
extension
=
extension
;
this
.
_windows
=
new
DefaultWeakMap
(
window
=
>
this
.
wrapWindow
(
window
)
)
;
}
convert
(
window
.
.
.
args
)
{
return
this
.
getWrapper
(
window
)
.
convert
(
.
.
.
args
)
;
}
getWrapper
(
window
)
{
if
(
this
.
extension
.
canAccessWindow
(
window
)
)
{
return
this
.
_windows
.
get
(
window
)
;
}
}
canAccessWindow
(
window
context
)
{
return
(
(
context
&
&
context
.
canAccessWindow
(
window
)
)
|
|
this
.
extension
.
canAccessWindow
(
window
)
)
;
}
*
query
(
queryInfo
=
null
context
=
null
)
{
function
*
candidates
(
windowManager
)
{
if
(
queryInfo
)
{
let
{
currentWindow
windowId
lastFocusedWindow
}
=
queryInfo
;
if
(
currentWindow
=
=
=
true
&
&
windowId
=
=
null
)
{
windowId
=
WINDOW_ID_CURRENT
;
}
if
(
windowId
!
=
null
)
{
let
window
=
global
.
windowTracker
.
getWindow
(
windowId
context
false
)
;
if
(
window
)
{
yield
windowManager
.
getWrapper
(
window
)
;
}
return
;
}
if
(
lastFocusedWindow
=
=
=
true
)
{
let
window
=
global
.
windowTracker
.
getTopWindow
(
context
)
;
if
(
window
)
{
yield
windowManager
.
getWrapper
(
window
)
;
}
return
;
}
}
yield
*
windowManager
.
getAll
(
context
)
;
}
for
(
let
windowWrapper
of
candidates
(
this
)
)
{
if
(
!
queryInfo
|
|
windowWrapper
.
matches
(
queryInfo
context
)
)
{
yield
windowWrapper
;
}
}
}
get
(
windowId
context
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getAll
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
wrapWindow
(
window
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
function
getUserContextIdForCookieStoreId
(
extension
cookieStoreId
isPrivateBrowsing
)
{
if
(
!
extension
.
hasPermission
(
"
cookies
"
)
)
{
throw
new
ExtensionError
(
No
permission
for
cookieStoreId
:
{
cookieStoreId
}
)
;
}
if
(
!
isValidCookieStoreId
(
cookieStoreId
)
)
{
throw
new
ExtensionError
(
Illegal
cookieStoreId
:
{
cookieStoreId
}
)
;
}
if
(
isPrivateBrowsing
&
&
!
isPrivateCookieStoreId
(
cookieStoreId
)
)
{
throw
new
ExtensionError
(
Illegal
to
set
non
-
private
cookieStoreId
in
a
private
window
)
;
}
if
(
!
isPrivateBrowsing
&
&
isPrivateCookieStoreId
(
cookieStoreId
)
)
{
throw
new
ExtensionError
(
Illegal
to
set
private
cookieStoreId
in
a
non
-
private
window
)
;
}
if
(
isContainerCookieStoreId
(
cookieStoreId
)
)
{
if
(
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
throw
new
ExtensionError
(
Contextual
identities
are
unavailable
in
permanent
private
browsing
mode
)
;
}
if
(
!
containersEnabled
)
{
throw
new
ExtensionError
(
Contextual
identities
are
currently
disabled
)
;
}
let
userContextId
=
getContainerForCookieStoreId
(
cookieStoreId
)
;
if
(
!
userContextId
)
{
throw
new
ExtensionError
(
No
cookie
store
exists
with
ID
{
cookieStoreId
}
)
;
}
if
(
!
extension
.
canAccessContainer
(
userContextId
)
)
{
throw
new
ExtensionError
(
Cannot
access
{
cookieStoreId
}
)
;
}
return
userContextId
;
}
return
Services
.
scriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
;
}
Object
.
assign
(
global
{
TabTrackerBase
TabManagerBase
TabBase
WindowTrackerBase
WindowManagerBase
WindowBase
getUserContextIdForCookieStoreId
}
)
;
