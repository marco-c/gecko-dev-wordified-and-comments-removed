"
use
strict
"
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gCookiesRejectWhenInvalid
"
"
extensions
.
cookie
.
rejectWhenInvalid
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gCanUsePortInPartitionKey
"
"
privacy
.
dynamic_firstparty
.
use_site
.
include_port
"
false
)
;
var
{
ExtensionError
}
=
ExtensionUtils
;
const
SAME_SITE_STATUSES
=
new
Map
(
[
[
Ci
.
nsICookie
.
SAMESITE_NONE
"
no_restriction
"
]
[
Ci
.
nsICookie
.
SAMESITE_LAX
"
lax
"
]
[
Ci
.
nsICookie
.
SAMESITE_STRICT
"
strict
"
]
[
Ci
.
nsICookie
.
SAMESITE_UNSET
"
unspecified
"
]
]
)
;
const
isIPv4
=
host
=
>
{
let
match
=
/
^
(
\
d
+
)
\
.
(
\
d
+
)
\
.
(
\
d
+
)
\
.
(
\
d
+
)
/
.
exec
(
host
)
;
if
(
match
)
{
return
match
[
1
]
<
256
&
&
match
[
2
]
<
256
&
&
match
[
3
]
<
256
&
&
match
[
4
]
<
256
;
}
return
false
;
}
;
const
isIPv6
=
host
=
>
host
.
includes
(
"
:
"
)
;
const
addBracketIfIPv6
=
host
=
>
isIPv6
(
host
)
&
&
!
host
.
startsWith
(
"
[
"
)
?
[
{
host
}
]
:
host
;
const
dropBracketIfIPv6
=
host
=
>
isIPv6
(
host
)
&
&
host
.
startsWith
(
"
[
"
)
&
&
host
.
endsWith
(
"
]
"
)
?
host
.
slice
(
1
-
1
)
:
host
;
const
isSubdomain
=
(
otherDomain
baseDomain
)
=
>
{
return
otherDomain
=
=
baseDomain
|
|
otherDomain
.
endsWith
(
"
.
"
+
baseDomain
)
;
}
;
function
fromExtPartitionKey
(
extPartitionKey
cookieUrl
)
{
if
(
!
extPartitionKey
)
{
return
"
"
;
}
const
{
topLevelSite
hasCrossSiteAncestor
}
=
extPartitionKey
;
if
(
topLevelSite
)
{
try
{
if
(
cookieUrl
=
=
null
)
{
let
topLevelSiteURI
=
Services
.
io
.
newURI
(
topLevelSite
)
;
let
topLevelSiteFilter
=
Services
.
eTLD
.
getSite
(
topLevelSiteURI
)
;
if
(
gCanUsePortInPartitionKey
&
&
topLevelSiteURI
.
port
!
=
-
1
)
{
topLevelSiteFilter
+
=
:
{
topLevelSiteURI
.
port
}
;
}
return
topLevelSiteFilter
;
}
return
ChromeUtils
.
getPartitionKeyFromURL
(
topLevelSite
cookieUrl
hasCrossSiteAncestor
?
?
undefined
)
;
}
catch
(
e
)
{
throw
new
ExtensionError
(
"
Invalid
value
for
'
partitionKey
'
attribute
"
)
;
}
}
else
if
(
topLevelSite
=
=
null
&
&
hasCrossSiteAncestor
!
=
null
)
{
throw
new
ExtensionError
(
"
Invalid
value
for
'
partitionKey
'
attribute
"
)
;
}
return
"
"
;
}
function
getExtPartitionKey
(
cookie
)
{
let
partitionKey
=
cookie
.
originAttributes
.
partitionKey
;
if
(
!
partitionKey
)
{
return
null
;
}
if
(
!
partitionKey
.
startsWith
(
"
(
"
)
)
{
let
hasCrossSiteAncestor
=
!
isSubdomain
(
cookie
.
host
partitionKey
)
;
return
{
topLevelSite
:
https
:
/
/
{
partitionKey
}
hasCrossSiteAncestor
}
;
}
let
[
scheme
domain
opt1
opt2
]
=
partitionKey
.
slice
(
1
-
1
)
.
split
(
"
"
)
;
let
fbac
=
false
;
let
port
;
if
(
opt2
)
{
port
=
opt1
;
fbac
=
true
;
}
else
if
(
opt1
=
=
"
f
"
)
{
fbac
=
true
;
}
else
if
(
opt1
)
{
port
=
opt1
;
}
let
topLevelSite
=
{
scheme
}
:
/
/
{
domain
}
;
if
(
port
)
{
topLevelSite
+
=
:
{
port
}
;
}
let
hasCrossSiteAncestor
=
fbac
|
|
!
isSubdomain
(
cookie
.
host
domain
)
;
return
{
topLevelSite
hasCrossSiteAncestor
}
;
}
const
convertCookie
=
(
{
cookie
isPrivate
}
)
=
>
{
let
result
=
{
name
:
cookie
.
name
value
:
cookie
.
value
domain
:
addBracketIfIPv6
(
cookie
.
host
)
hostOnly
:
!
cookie
.
isDomain
path
:
cookie
.
path
secure
:
cookie
.
isSecure
httpOnly
:
cookie
.
isHttpOnly
sameSite
:
SAME_SITE_STATUSES
.
get
(
cookie
.
sameSite
)
session
:
cookie
.
isSession
firstPartyDomain
:
cookie
.
originAttributes
.
firstPartyDomain
|
|
"
"
partitionKey
:
getExtPartitionKey
(
cookie
)
}
;
if
(
!
cookie
.
isSession
)
{
result
.
expirationDate
=
cookie
.
expiry
/
1000
;
}
if
(
cookie
.
originAttributes
.
userContextId
)
{
result
.
storeId
=
getCookieStoreIdForContainer
(
cookie
.
originAttributes
.
userContextId
)
;
}
else
if
(
cookie
.
originAttributes
.
privateBrowsingId
|
|
isPrivate
)
{
result
.
storeId
=
PRIVATE_STORE
;
}
else
{
result
.
storeId
=
DEFAULT_STORE
;
}
return
result
;
}
;
const
checkSetCookiePermissions
=
(
extension
uri
cookie
)
=
>
{
if
(
uri
.
scheme
!
=
"
http
"
&
&
uri
.
scheme
!
=
"
https
"
)
{
return
false
;
}
if
(
!
extension
.
allowedOrigins
.
matches
(
uri
)
)
{
return
false
;
}
if
(
!
cookie
.
host
)
{
cookie
.
host
=
uri
.
host
;
return
true
;
}
if
(
cookie
.
host
.
length
>
1
)
{
cookie
.
host
=
cookie
.
host
.
replace
(
/
^
\
.
/
"
"
)
;
}
cookie
.
host
=
cookie
.
host
.
toLowerCase
(
)
;
cookie
.
host
=
dropBracketIfIPv6
(
cookie
.
host
)
;
if
(
cookie
.
host
!
=
uri
.
host
)
{
let
baseDomain
;
try
{
baseDomain
=
Services
.
eTLD
.
getBaseDomain
(
uri
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_HOST_IS_IP_ADDRESS
|
|
e
.
result
=
=
Cr
.
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
return
false
;
}
if
(
e
.
result
=
=
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
{
throw
new
ExtensionError
(
Invalid
domain
url
:
"
{
uri
.
prePath
}
"
)
;
}
throw
e
;
}
if
(
!
isSubdomain
(
cookie
.
host
baseDomain
)
|
|
!
isSubdomain
(
uri
.
host
cookie
.
host
)
)
{
return
false
;
}
}
if
(
isIPv6
(
cookie
.
host
)
|
|
isIPv4
(
cookie
.
host
)
)
{
return
true
;
}
cookie
.
host
=
"
.
"
+
cookie
.
host
;
return
true
;
}
;
const
oaFromDetails
=
(
details
context
allowPattern
)
=
>
{
let
originAttributes
=
{
userContextId
:
0
privateBrowsingId
:
0
firstPartyDomain
:
details
.
firstPartyDomain
?
?
"
"
partitionKey
:
fromExtPartitionKey
(
details
.
partitionKey
details
.
url
)
}
;
let
isPrivate
=
context
.
incognito
;
let
storeId
=
isPrivate
?
PRIVATE_STORE
:
DEFAULT_STORE
;
if
(
details
.
storeId
)
{
storeId
=
details
.
storeId
;
if
(
isDefaultCookieStoreId
(
storeId
)
)
{
isPrivate
=
false
;
}
else
if
(
isPrivateCookieStoreId
(
storeId
)
)
{
isPrivate
=
true
;
}
else
{
isPrivate
=
false
;
let
userContextId
=
getContainerForCookieStoreId
(
storeId
)
;
if
(
!
userContextId
)
{
throw
new
ExtensionError
(
Invalid
cookie
store
id
:
"
{
storeId
}
"
)
;
}
originAttributes
.
userContextId
=
userContextId
;
}
}
if
(
isPrivate
)
{
originAttributes
.
privateBrowsingId
=
1
;
if
(
!
context
.
privateBrowsingAllowed
)
{
throw
new
ExtensionError
(
"
Extension
disallowed
access
to
the
private
cookies
storeId
.
"
)
;
}
}
let
isPattern
=
false
;
let
topLevelSiteFilter
;
if
(
allowPattern
)
{
if
(
"
firstPartyDomain
"
in
details
&
&
details
.
firstPartyDomain
=
=
null
)
{
delete
originAttributes
.
firstPartyDomain
;
isPattern
=
true
;
}
if
(
details
.
partitionKey
&
&
details
.
partitionKey
.
topLevelSite
=
=
null
)
{
delete
originAttributes
.
partitionKey
;
isPattern
=
true
;
}
else
if
(
details
.
partitionKey
?
.
topLevelSite
&
&
details
.
url
=
=
null
)
{
topLevelSiteFilter
=
originAttributes
.
partitionKey
;
delete
originAttributes
.
partitionKey
;
isPattern
=
true
;
}
}
return
{
originAttributes
isPattern
isPrivate
storeId
topLevelSiteFilter
}
;
}
;
const
query
=
function
*
(
detailsIn
props
context
allowPattern
)
{
let
details
=
{
}
;
props
.
forEach
(
property
=
>
{
if
(
detailsIn
[
property
]
!
=
=
null
)
{
details
[
property
]
=
detailsIn
[
property
]
;
}
}
)
;
let
parsedOA
;
try
{
parsedOA
=
oaFromDetails
(
detailsIn
context
allowPattern
)
;
}
catch
(
e
)
{
if
(
e
.
message
.
startsWith
(
"
Invalid
cookie
store
id
"
)
)
{
return
;
}
throw
e
;
}
let
{
originAttributes
isPattern
isPrivate
storeId
topLevelSiteFilter
}
=
parsedOA
;
if
(
"
domain
"
in
details
)
{
details
.
domain
=
details
.
domain
.
toLowerCase
(
)
.
replace
(
/
^
\
.
/
"
"
)
;
details
.
domain
=
dropBracketIfIPv6
(
details
.
domain
)
;
}
let
cookies
;
let
host
;
let
url
;
if
(
"
url
"
in
details
)
{
url
=
URL
.
parse
(
details
.
url
)
;
if
(
url
)
{
host
=
dropBracketIfIPv6
(
url
.
hostname
)
;
}
else
{
return
;
}
}
else
if
(
"
domain
"
in
details
)
{
host
=
details
.
domain
;
}
if
(
host
&
&
!
isPattern
)
{
cookies
=
Services
.
cookies
.
getCookiesFromHost
(
host
originAttributes
true
)
;
}
else
{
cookies
=
Services
.
cookies
.
getCookiesWithOriginAttributes
(
JSON
.
stringify
(
originAttributes
)
host
true
)
;
}
function
matches
(
cookie
)
{
function
domainMatches
(
host
)
{
return
(
cookie
.
rawHost
=
=
host
|
|
(
cookie
.
isDomain
&
&
host
.
endsWith
(
cookie
.
host
)
)
)
;
}
function
pathMatches
(
path
)
{
let
cookiePath
=
cookie
.
path
.
replace
(
/
\
/
/
"
"
)
;
if
(
!
path
.
startsWith
(
cookiePath
)
)
{
return
false
;
}
if
(
path
.
length
=
=
cookiePath
.
length
)
{
return
true
;
}
return
path
[
cookiePath
.
length
]
=
=
=
"
/
"
;
}
if
(
url
)
{
if
(
!
domainMatches
(
host
)
)
{
return
false
;
}
if
(
cookie
.
isSecure
&
&
url
.
protocol
!
=
"
https
:
"
)
{
return
false
;
}
if
(
!
pathMatches
(
url
.
pathname
)
)
{
return
false
;
}
}
if
(
"
name
"
in
details
&
&
details
.
name
!
=
cookie
.
name
)
{
return
false
;
}
if
(
"
domain
"
in
details
&
&
!
isSubdomain
(
cookie
.
rawHost
details
.
domain
)
)
{
return
false
;
}
if
(
"
path
"
in
details
&
&
details
.
path
!
=
cookie
.
path
)
{
return
false
;
}
if
(
"
secure
"
in
details
&
&
details
.
secure
!
=
cookie
.
isSecure
)
{
return
false
;
}
if
(
"
session
"
in
details
&
&
details
.
session
!
=
cookie
.
isSession
)
{
return
false
;
}
if
(
!
context
.
extension
.
allowedOrigins
.
matchesCookie
(
cookie
)
)
{
return
false
;
}
if
(
topLevelSiteFilter
)
{
let
cookiePartitionKey
=
getExtPartitionKey
(
cookie
)
;
let
cookiePartitionSite
=
cookiePartitionKey
?
.
topLevelSite
;
if
(
!
cookiePartitionKey
|
|
topLevelSiteFilter
!
=
=
cookiePartitionSite
)
{
return
false
;
}
if
(
detailsIn
.
partitionKey
.
hasCrossSiteAncestor
!
=
null
&
&
detailsIn
.
partitionKey
.
hasCrossSiteAncestor
!
=
cookiePartitionKey
.
hasCrossSiteAncestor
)
{
return
false
;
}
}
return
true
;
}
for
(
const
cookie
of
cookies
)
{
if
(
matches
(
cookie
)
)
{
yield
{
cookie
isPrivate
storeId
}
;
}
}
}
;
const
validateFirstPartyDomain
=
details
=
>
{
if
(
details
.
firstPartyDomain
!
=
null
)
{
return
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
privacy
.
firstparty
.
isolate
"
)
)
{
throw
new
ExtensionError
(
"
First
-
Party
Isolation
is
enabled
but
the
required
'
firstPartyDomain
'
attribute
was
not
set
.
"
)
;
}
}
;
this
.
cookies
=
class
extends
ExtensionAPIPersistent
{
PERSISTENT_EVENTS
=
{
onChanged
(
{
fire
}
)
{
let
observer
=
(
subject
topic
)
=
>
{
let
notify
=
(
removed
cookie
cause
)
=
>
{
cookie
.
QueryInterface
(
Ci
.
nsICookie
)
;
if
(
this
.
extension
.
allowedOrigins
.
matchesCookie
(
cookie
)
)
{
fire
.
async
(
{
removed
cookie
:
convertCookie
(
{
cookie
isPrivate
:
topic
=
=
"
private
-
cookie
-
changed
"
}
)
cause
}
)
;
}
}
;
let
notification
=
subject
.
QueryInterface
(
Ci
.
nsICookieNotification
)
;
let
{
cookie
}
=
notification
;
let
{
COOKIE_DELETED
COOKIE_ADDED
COOKIE_CHANGED
COOKIES_BATCH_DELETED
}
=
Ci
.
nsICookieNotification
;
switch
(
notification
.
action
)
{
case
COOKIE_DELETED
:
notify
(
true
cookie
"
explicit
"
)
;
break
;
case
COOKIE_ADDED
:
notify
(
false
cookie
"
explicit
"
)
;
break
;
case
COOKIE_CHANGED
:
notify
(
true
cookie
"
overwrite
"
)
;
notify
(
false
cookie
"
explicit
"
)
;
break
;
case
COOKIES_BATCH_DELETED
:
let
cookieArray
=
notification
.
batchDeletedCookies
.
QueryInterface
(
Ci
.
nsIArray
)
;
for
(
let
i
=
0
;
i
<
cookieArray
.
length
;
i
+
+
)
{
let
cookie
=
cookieArray
.
queryElementAt
(
i
Ci
.
nsICookie
)
;
if
(
!
cookie
.
isSession
&
&
cookie
.
expiry
<
=
Date
.
now
(
)
)
{
notify
(
true
cookie
"
expired
"
)
;
}
else
{
notify
(
true
cookie
"
evicted
"
)
;
}
}
break
;
}
}
;
const
{
privateBrowsingAllowed
}
=
this
.
extension
;
Services
.
obs
.
addObserver
(
observer
"
cookie
-
changed
"
)
;
if
(
privateBrowsingAllowed
)
{
Services
.
obs
.
addObserver
(
observer
"
private
-
cookie
-
changed
"
)
;
}
return
{
unregister
(
)
{
Services
.
obs
.
removeObserver
(
observer
"
cookie
-
changed
"
)
;
if
(
privateBrowsingAllowed
)
{
Services
.
obs
.
removeObserver
(
observer
"
private
-
cookie
-
changed
"
)
;
}
}
convert
(
_fire
)
{
fire
=
_fire
;
}
}
;
}
}
;
getAPI
(
context
)
{
let
{
extension
}
=
context
;
let
self
=
{
cookies
:
{
get
:
function
(
details
)
{
validateFirstPartyDomain
(
details
)
;
let
allowed
=
[
"
url
"
"
name
"
]
;
for
(
let
cookie
of
query
(
details
allowed
context
)
)
{
return
Promise
.
resolve
(
convertCookie
(
cookie
)
)
;
}
return
Promise
.
resolve
(
null
)
;
}
getAll
:
function
(
details
)
{
if
(
!
(
"
firstPartyDomain
"
in
details
)
)
{
validateFirstPartyDomain
(
details
)
;
}
let
allowed
=
[
"
url
"
"
name
"
"
domain
"
"
path
"
"
secure
"
"
session
"
]
;
let
result
=
Array
.
from
(
query
(
details
allowed
context
true
)
convertCookie
)
;
return
Promise
.
resolve
(
result
)
;
}
set
:
function
(
details
)
{
validateFirstPartyDomain
(
details
)
;
if
(
details
.
firstPartyDomain
&
&
details
.
partitionKey
)
{
throw
new
ExtensionError
(
"
Partitioned
cookies
cannot
have
a
'
firstPartyDomain
'
attribute
.
"
)
;
}
let
uri
=
Services
.
io
.
newURI
(
details
.
url
)
;
let
path
;
if
(
details
.
path
!
=
=
null
)
{
path
=
details
.
path
;
}
else
{
path
=
uri
.
QueryInterface
(
Ci
.
nsIURL
)
.
directory
;
}
let
name
=
details
.
name
!
=
=
null
?
details
.
name
:
"
"
;
let
value
=
details
.
value
!
=
=
null
?
details
.
value
:
"
"
;
let
secure
=
details
.
secure
!
=
=
null
?
details
.
secure
:
false
;
let
httpOnly
=
details
.
httpOnly
!
=
=
null
?
details
.
httpOnly
:
false
;
let
isSession
=
details
.
expirationDate
=
=
=
null
;
let
expiry
=
isSession
?
Number
.
MAX_SAFE_INTEGER
:
Services
.
cookies
.
maybeCapExpiry
(
details
.
expirationDate
*
1000
)
;
let
{
originAttributes
}
=
oaFromDetails
(
details
context
)
;
let
cookieAttrs
=
{
host
:
details
.
domain
path
:
path
isSecure
:
secure
}
;
if
(
!
checkSetCookiePermissions
(
extension
uri
cookieAttrs
)
)
{
return
Promise
.
reject
(
{
message
:
Permission
denied
to
set
cookie
{
JSON
.
stringify
(
details
)
}
}
)
;
}
let
sameSite
=
Ci
.
nsICookie
.
SAMESITE_UNSET
;
for
(
const
[
k
v
]
of
SAME_SITE_STATUSES
)
{
if
(
details
.
sameSite
=
=
=
v
)
{
sameSite
=
k
;
break
;
}
}
let
schemeType
=
Ci
.
nsICookie
.
SCHEME_UNSET
;
if
(
uri
.
scheme
=
=
=
"
https
"
)
{
schemeType
=
Ci
.
nsICookie
.
SCHEME_HTTPS
;
}
else
if
(
uri
.
scheme
=
=
=
"
http
"
)
{
schemeType
=
Ci
.
nsICookie
.
SCHEME_HTTP
;
}
else
if
(
uri
.
scheme
=
=
=
"
file
"
)
{
schemeType
=
Ci
.
nsICookie
.
SCHEME_FILE
;
}
let
isPartitioned
=
originAttributes
.
partitionKey
?
.
length
>
0
;
let
fn
=
gCookiesRejectWhenInvalid
?
Services
.
cookies
.
add
:
Services
.
cookies
.
addForAddOn
;
let
cv
;
try
{
cv
=
fn
(
cookieAttrs
.
host
path
name
value
secure
httpOnly
isSession
expiry
originAttributes
sameSite
schemeType
isPartitioned
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
{
throw
new
ExtensionError
(
Invalid
domain
:
"
{
cookieAttrs
.
host
}
"
)
;
}
throw
e
;
}
if
(
cv
.
result
!
=
=
Ci
.
nsICookieValidation
.
eOK
)
{
if
(
gCookiesRejectWhenInvalid
)
{
return
Promise
.
reject
(
{
message
:
cv
.
errorString
}
)
;
}
Services
.
console
.
logStringMessage
(
Extension
{
extension
.
id
}
tried
to
create
an
invalid
cookie
:
{
cv
.
errorString
}
)
;
}
return
self
.
cookies
.
get
(
details
)
;
}
remove
:
function
(
details
)
{
validateFirstPartyDomain
(
details
)
;
let
allowed
=
[
"
url
"
"
name
"
]
;
for
(
let
{
cookie
storeId
}
of
query
(
details
allowed
context
)
)
{
Services
.
cookies
.
remove
(
cookie
.
host
cookie
.
name
cookie
.
path
cookie
.
originAttributes
)
;
return
Promise
.
resolve
(
{
url
:
details
.
url
name
:
details
.
name
storeId
firstPartyDomain
:
cookie
.
originAttributes
.
firstPartyDomain
partitionKey
:
getExtPartitionKey
(
cookie
)
}
)
;
}
return
Promise
.
resolve
(
null
)
;
}
getAllCookieStores
:
function
(
)
{
let
data
=
{
}
;
for
(
let
tab
of
extension
.
tabManager
.
query
(
)
)
{
if
(
!
(
tab
.
cookieStoreId
in
data
)
)
{
data
[
tab
.
cookieStoreId
]
=
[
]
;
}
data
[
tab
.
cookieStoreId
]
.
push
(
tab
.
id
)
;
}
let
result
=
[
]
;
for
(
let
key
in
data
)
{
result
.
push
(
{
id
:
key
tabIds
:
data
[
key
]
incognito
:
key
=
=
PRIVATE_STORE
}
)
;
}
return
Promise
.
resolve
(
result
)
;
}
onChanged
:
new
EventManager
(
{
context
module
:
"
cookies
"
event
:
"
onChanged
"
extensionApi
:
this
}
)
.
api
(
)
}
}
;
return
self
;
}
}
;
