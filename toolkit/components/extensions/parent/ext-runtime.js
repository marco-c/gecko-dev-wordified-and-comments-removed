"
use
strict
"
;
var
{
ExtensionParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AddonManagerPrivate
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
DevToolsShim
:
"
chrome
:
/
/
devtools
-
startup
/
content
/
DevToolsShim
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gRuntimeTimeout
"
"
extensions
.
webextensions
.
runtime
.
timeout
"
5000
)
;
this
.
runtime
=
class
extends
ExtensionAPIPersistent
{
PERSISTENT_EVENTS
=
{
onInstalled
(
{
fire
}
)
{
let
{
extension
}
=
this
;
let
temporary
=
!
!
extension
.
addonData
.
temporarilyInstalled
;
let
listener
=
(
)
=
>
{
switch
(
extension
.
startupReason
)
{
case
"
APP_STARTUP
"
:
if
(
AddonManagerPrivate
.
browserUpdated
)
{
fire
.
sync
(
{
reason
:
"
browser_update
"
temporary
}
)
;
}
break
;
case
"
ADDON_INSTALL
"
:
fire
.
sync
(
{
reason
:
"
install
"
temporary
}
)
;
break
;
case
"
ADDON_UPGRADE
"
:
fire
.
sync
(
{
reason
:
"
update
"
previousVersion
:
extension
.
addonData
.
oldVersion
temporary
}
)
;
break
;
}
}
;
extension
.
on
(
"
background
-
first
-
run
"
listener
)
;
return
{
unregister
(
)
{
extension
.
off
(
"
background
-
first
-
run
"
listener
)
;
}
convert
(
_fire
)
{
fire
=
_fire
;
}
}
;
}
onUpdateAvailable
(
{
fire
}
)
{
let
{
extension
}
=
this
;
let
instanceID
=
extension
.
addonData
.
instanceID
;
AddonManager
.
addUpgradeListener
(
instanceID
upgrade
=
>
{
extension
.
upgrade
=
upgrade
;
let
details
=
{
version
:
upgrade
.
version
}
;
fire
.
sync
(
details
)
;
}
)
;
return
{
unregister
(
)
{
AddonManager
.
removeUpgradeListener
(
instanceID
)
;
}
convert
(
_fire
)
{
fire
=
_fire
;
}
}
;
}
}
;
getAPI
(
context
)
{
let
{
extension
}
=
context
;
return
{
runtime
:
{
onStartup
:
new
EventManager
(
{
context
module
:
"
runtime
"
event
:
"
onStartup
"
register
:
fire
=
>
{
if
(
context
.
incognito
|
|
extension
.
startupReason
!
=
"
APP_STARTUP
"
)
{
return
(
)
=
>
{
}
;
}
let
listener
=
(
)
=
>
{
return
fire
.
sync
(
)
;
}
;
extension
.
on
(
"
background
-
first
-
run
"
listener
)
;
return
(
)
=
>
{
extension
.
off
(
"
background
-
first
-
run
"
listener
)
;
}
;
}
}
)
.
api
(
)
onInstalled
:
new
EventManager
(
{
context
module
:
"
runtime
"
event
:
"
onInstalled
"
extensionApi
:
this
}
)
.
api
(
)
onUpdateAvailable
:
new
EventManager
(
{
context
module
:
"
runtime
"
event
:
"
onUpdateAvailable
"
extensionApi
:
this
}
)
.
api
(
)
onSuspend
:
new
EventManager
(
{
context
name
:
"
runtime
.
onSuspend
"
resetIdleOnEvent
:
false
register
:
fire
=
>
{
let
listener
=
async
(
)
=
>
{
let
timedOut
=
false
;
async
function
promiseFire
(
)
{
try
{
await
fire
.
async
(
)
;
}
catch
(
e
)
{
}
}
await
Promise
.
race
(
[
promiseFire
(
)
ExtensionUtils
.
promiseTimeout
(
gRuntimeTimeout
)
.
then
(
(
)
=
>
{
timedOut
=
true
;
}
)
]
)
;
if
(
timedOut
)
{
Cu
.
reportError
(
runtime
.
onSuspend
in
{
extension
.
id
}
took
too
long
)
;
}
}
;
extension
.
on
(
"
background
-
script
-
suspend
"
listener
)
;
return
(
)
=
>
{
extension
.
off
(
"
background
-
script
-
suspend
"
listener
)
;
}
;
}
}
)
.
api
(
)
onSuspendCanceled
:
new
EventManager
(
{
context
name
:
"
runtime
.
onSuspendCanceled
"
register
:
fire
=
>
{
let
listener
=
(
)
=
>
{
fire
.
async
(
)
;
}
;
extension
.
on
(
"
background
-
script
-
suspend
-
canceled
"
listener
)
;
return
(
)
=
>
{
extension
.
off
(
"
background
-
script
-
suspend
-
canceled
"
listener
)
;
}
;
}
}
)
.
api
(
)
reload
:
async
(
)
=
>
{
if
(
extension
.
upgrade
)
{
extension
.
upgrade
.
install
(
)
;
}
else
{
let
addon
=
await
AddonManager
.
getAddonByID
(
extension
.
id
)
;
addon
.
reload
(
)
;
}
}
get
lastError
(
)
{
return
context
.
lastError
;
}
getBrowserInfo
:
function
(
)
{
const
{
name
vendor
version
appBuildID
}
=
Services
.
appinfo
;
const
info
=
{
name
vendor
version
buildID
:
appBuildID
}
;
return
Promise
.
resolve
(
info
)
;
}
getPlatformInfo
:
function
(
)
{
return
Promise
.
resolve
(
ExtensionParent
.
PlatformInfo
)
;
}
openOptionsPage
:
function
(
)
{
if
(
!
extension
.
manifest
.
options_ui
)
{
return
Promise
.
reject
(
{
message
:
"
No
options_ui
declared
"
}
)
;
}
return
openOptionsPage
(
extension
)
.
then
(
(
)
=
>
{
}
)
;
}
setUninstallURL
:
function
(
url
)
{
if
(
url
=
=
=
null
|
|
url
.
length
=
=
=
0
)
{
extension
.
uninstallURL
=
null
;
return
Promise
.
resolve
(
)
;
}
let
uri
;
try
{
uri
=
new
URL
(
url
)
;
}
catch
(
e
)
{
return
Promise
.
reject
(
{
message
:
Invalid
URL
:
{
JSON
.
stringify
(
url
)
}
}
)
;
}
if
(
uri
.
protocol
!
=
"
http
:
"
&
&
uri
.
protocol
!
=
"
https
:
"
)
{
return
Promise
.
reject
(
{
message
:
"
url
must
have
the
scheme
http
or
https
"
}
)
;
}
extension
.
uninstallURL
=
url
;
return
Promise
.
resolve
(
)
;
}
openBrowserConsole
(
)
{
if
(
AppConstants
.
platform
!
=
=
"
android
"
)
{
DevToolsShim
.
openBrowserConsole
(
)
;
}
}
async
internalWakeupBackground
(
)
{
if
(
extension
.
manifest
.
background
&
&
!
extension
.
manifest
.
background
.
service_worker
&
&
!
extension
.
persistentBackground
)
{
await
extension
.
wakeupBackground
(
)
;
}
}
}
}
;
}
}
;
