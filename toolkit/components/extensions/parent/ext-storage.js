"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
AddonManagerPrivate
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
sys
.
mjs
"
ExtensionStorage
:
"
resource
:
/
/
gre
/
modules
/
ExtensionStorage
.
sys
.
mjs
"
ExtensionStorageIDB
:
"
resource
:
/
/
gre
/
modules
/
ExtensionStorageIDB
.
sys
.
mjs
"
NativeManifests
:
"
resource
:
/
/
gre
/
modules
/
NativeManifests
.
sys
.
mjs
"
extensionStorageSession
:
"
resource
:
/
/
gre
/
modules
/
ExtensionStorage
.
sys
.
mjs
"
}
)
;
var
{
ExtensionError
}
=
ExtensionUtils
;
var
{
ignoreEvent
}
=
ExtensionCommon
;
ChromeUtils
.
defineLazyGetter
(
this
"
extensionStorageSync
"
(
)
=
>
{
if
(
Services
.
prefs
.
getBoolPref
(
"
webextensions
.
storage
.
sync
.
kinto
"
)
)
{
const
{
extensionStorageSyncKinto
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ExtensionStorageSyncKinto
.
sys
.
mjs
"
)
;
return
extensionStorageSyncKinto
;
}
const
{
extensionStorageSync
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ExtensionStorageSync
.
sys
.
mjs
"
)
;
return
extensionStorageSync
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
prefStorageSyncEnabled
"
"
webextensions
.
storage
.
sync
.
enabled
"
true
)
;
const
enforceNoTemporaryAddon
=
extensionId
=
>
{
const
EXCEPTION_MESSAGE
=
"
The
storage
API
will
not
work
with
a
temporary
addon
ID
.
"
+
"
Please
add
an
explicit
addon
ID
to
your
manifest
.
"
+
"
For
more
information
see
https
:
/
/
mzl
.
la
/
3lPk1aE
.
"
;
if
(
AddonManagerPrivate
.
isTemporaryInstallID
(
extensionId
)
)
{
throw
new
ExtensionError
(
EXCEPTION_MESSAGE
)
;
}
}
;
const
syncQuotasRecorded
=
new
WeakSet
(
)
;
const
QUOTA_BYTES_PER_ITEM
=
8_192
;
async
function
recordSyncQuotaTelemetry
(
extension
context
)
{
if
(
syncQuotasRecorded
.
has
(
extension
)
|
|
!
prefStorageSyncEnabled
)
{
return
;
}
syncQuotasRecorded
.
add
(
extension
)
;
let
items
=
await
extensionStorageSync
.
get
(
extension
null
context
)
;
let
items_over_quota
=
0
;
let
total_size_bytes
=
0
;
let
entries
=
Object
.
entries
(
items
)
;
for
(
let
[
key
value
]
of
entries
)
{
let
bytes
=
JSON
.
stringify
(
value
)
.
length
;
total_size_bytes
+
=
key
.
length
+
bytes
;
if
(
bytes
>
QUOTA_BYTES_PER_ITEM
)
{
items_over_quota
+
+
;
}
}
Glean
.
extensionsData
.
syncUsageQuotas
.
record
(
{
addon_id
:
extension
.
id
total_size_bytes
items_count
:
entries
.
length
items_over_quota
backend
:
extensionStorageSync
.
backend
}
)
;
}
const
managedStorage
=
new
WeakMap
(
)
;
const
lookupManagedStorage
=
async
(
extensionId
context
)
=
>
{
if
(
Services
.
policies
)
{
let
extensionPolicy
=
Services
.
policies
.
getExtensionPolicy
(
extensionId
)
;
if
(
extensionPolicy
)
{
return
ExtensionStorage
.
_serializableMap
(
extensionPolicy
)
;
}
}
let
info
=
await
NativeManifests
.
lookupManifest
(
"
storage
"
extensionId
context
)
;
if
(
info
)
{
return
ExtensionStorage
.
_serializableMap
(
info
.
manifest
.
data
)
;
}
return
null
;
}
;
this
.
storage
=
class
extends
ExtensionAPIPersistent
{
constructor
(
extension
)
{
super
(
extension
)
;
const
messageName
=
Extension
:
StorageLocalOnChanged
:
{
extension
.
uuid
}
;
Services
.
ppmm
.
addMessageListener
(
messageName
this
)
;
this
.
clearStorageChangedListener
=
(
)
=
>
{
Services
.
ppmm
.
removeMessageListener
(
messageName
this
)
;
}
;
}
PERSISTENT_EVENTS
=
{
onChanged
(
{
context
fire
}
)
{
let
unregisterLocal
=
this
.
registerLocalChangedListener
(
changes
=
>
{
fire
.
raw
(
changes
"
local
"
)
;
}
)
;
let
unregisterSession
;
if
(
!
context
|
|
context
.
envType
=
=
=
"
addon_parent
"
|
|
context
.
envType
=
=
=
"
devtools_parent
"
)
{
unregisterSession
=
extensionStorageSession
.
registerListener
(
this
.
extension
changes
=
>
fire
.
async
(
changes
"
session
"
)
)
;
}
let
unregisterSync
=
this
.
registerSyncChangedListener
(
changes
=
>
{
fire
.
async
(
changes
"
sync
"
)
;
}
)
;
return
{
unregister
(
)
{
unregisterLocal
(
)
;
unregisterSession
?
.
(
)
;
unregisterSync
(
)
;
}
convert
(
_fire
)
{
fire
=
_fire
;
}
}
;
}
"
local
.
onChanged
"
(
{
fire
}
)
{
let
unregister
=
this
.
registerLocalChangedListener
(
changes
=
>
{
fire
.
raw
(
changes
)
;
}
)
;
return
{
unregister
convert
(
_fire
)
{
fire
=
_fire
;
}
}
;
}
"
session
.
onChanged
"
(
{
fire
}
)
{
let
unregister
=
extensionStorageSession
.
registerListener
(
this
.
extension
changes
=
>
fire
.
async
(
changes
)
)
;
return
{
unregister
convert
(
_fire
)
{
fire
=
_fire
;
}
}
;
}
"
sync
.
onChanged
"
(
{
fire
}
)
{
let
unregister
=
this
.
registerSyncChangedListener
(
changes
=
>
{
fire
.
async
(
changes
)
;
}
)
;
return
{
unregister
convert
(
_fire
)
{
fire
=
_fire
;
}
}
;
}
}
;
registerLocalChangedListener
(
onStorageLocalChanged
)
{
const
extensionId
=
this
.
extension
.
id
;
ExtensionStorage
.
addOnChangedListener
(
extensionId
onStorageLocalChanged
)
;
ExtensionStorageIDB
.
addOnChangedListener
(
extensionId
onStorageLocalChanged
)
;
return
(
)
=
>
{
ExtensionStorage
.
removeOnChangedListener
(
extensionId
onStorageLocalChanged
)
;
ExtensionStorageIDB
.
removeOnChangedListener
(
extensionId
onStorageLocalChanged
)
;
}
;
}
registerSyncChangedListener
(
onStorageSyncChanged
)
{
const
{
extension
}
=
this
;
let
closeCallback
;
let
dummyContextForKinto
=
{
callOnClose
(
{
close
}
)
{
closeCallback
=
close
;
}
}
;
extensionStorageSync
.
addOnChangedListener
(
extension
onStorageSyncChanged
dummyContextForKinto
)
;
return
(
)
=
>
{
extensionStorageSync
.
removeOnChangedListener
(
extension
onStorageSyncChanged
)
;
closeCallback
?
.
(
)
;
}
;
}
onShutdown
(
)
{
const
{
clearStorageChangedListener
}
=
this
;
this
.
clearStorageChangedListener
=
null
;
if
(
clearStorageChangedListener
)
{
clearStorageChangedListener
(
)
;
}
}
receiveMessage
(
{
name
data
}
)
{
if
(
name
!
=
=
Extension
:
StorageLocalOnChanged
:
{
this
.
extension
.
uuid
}
)
{
return
;
}
ExtensionStorageIDB
.
notifyListeners
(
this
.
extension
.
id
data
)
;
}
getAPI
(
context
)
{
let
{
extension
}
=
context
;
return
{
storage
:
{
local
:
{
async
callMethodInParentProcess
(
method
args
)
{
const
res
=
await
ExtensionStorageIDB
.
selectBackend
(
{
extension
}
)
;
if
(
!
res
.
backendEnabled
)
{
return
ExtensionStorage
[
method
]
(
extension
.
id
.
.
.
args
)
;
}
const
persisted
=
extension
.
hasPermission
(
"
unlimitedStorage
"
)
;
const
db
=
await
ExtensionStorageIDB
.
open
(
res
.
storagePrincipal
.
deserialize
(
this
true
)
persisted
)
;
try
{
const
changes
=
await
db
[
method
]
(
.
.
.
args
)
;
if
(
changes
)
{
ExtensionStorageIDB
.
notifyListeners
(
extension
.
id
changes
)
;
}
return
changes
;
}
catch
(
err
)
{
const
normalizedError
=
ExtensionStorageIDB
.
normalizeStorageError
(
{
error
:
err
extensionId
:
extension
.
id
storageMethod
:
method
}
)
.
message
;
return
Promise
.
reject
(
{
message
:
String
(
normalizedError
)
}
)
;
}
}
JSONFileBackend
:
{
get
(
spec
)
{
return
ExtensionStorage
.
get
(
extension
.
id
spec
)
;
}
set
(
items
)
{
return
ExtensionStorage
.
set
(
extension
.
id
items
)
;
}
remove
(
keys
)
{
return
ExtensionStorage
.
remove
(
extension
.
id
keys
)
;
}
clear
(
)
{
return
ExtensionStorage
.
clear
(
extension
.
id
)
;
}
}
IDBBackend
:
{
selectBackend
(
)
{
return
ExtensionStorageIDB
.
selectBackend
(
context
)
;
}
}
onChanged
:
new
EventManager
(
{
context
module
:
"
storage
"
event
:
"
local
.
onChanged
"
extensionApi
:
this
}
)
.
api
(
)
}
session
:
{
get
QUOTA_BYTES
(
)
{
return
extensionStorageSession
.
QUOTA_BYTES
;
}
get
(
items
)
{
return
extensionStorageSession
.
get
(
extension
items
)
;
}
set
(
items
)
{
extensionStorageSession
.
set
(
extension
items
)
;
}
remove
(
keys
)
{
extensionStorageSession
.
remove
(
extension
keys
)
;
}
clear
(
)
{
extensionStorageSession
.
clear
(
extension
)
;
}
getBytesInUse
(
keys
)
{
return
extensionStorageSession
.
getBytesInUse
(
extension
keys
)
;
}
onChanged
:
new
EventManager
(
{
context
module
:
"
storage
"
event
:
"
session
.
onChanged
"
extensionApi
:
this
}
)
.
api
(
)
}
sync
:
{
get
(
spec
)
{
enforceNoTemporaryAddon
(
extension
.
id
)
;
recordSyncQuotaTelemetry
(
extension
context
)
;
return
extensionStorageSync
.
get
(
extension
spec
context
)
;
}
set
(
items
)
{
enforceNoTemporaryAddon
(
extension
.
id
)
;
recordSyncQuotaTelemetry
(
extension
context
)
;
return
extensionStorageSync
.
set
(
extension
items
context
)
;
}
remove
(
keys
)
{
enforceNoTemporaryAddon
(
extension
.
id
)
;
recordSyncQuotaTelemetry
(
extension
context
)
;
return
extensionStorageSync
.
remove
(
extension
keys
context
)
;
}
clear
(
)
{
enforceNoTemporaryAddon
(
extension
.
id
)
;
recordSyncQuotaTelemetry
(
extension
context
)
;
return
extensionStorageSync
.
clear
(
extension
context
)
;
}
getBytesInUse
(
keys
)
{
enforceNoTemporaryAddon
(
extension
.
id
)
;
recordSyncQuotaTelemetry
(
extension
context
)
;
return
extensionStorageSync
.
getBytesInUse
(
extension
keys
context
)
;
}
onChanged
:
new
EventManager
(
{
context
module
:
"
storage
"
event
:
"
sync
.
onChanged
"
extensionApi
:
this
}
)
.
api
(
)
}
managed
:
{
async
get
(
keys
)
{
enforceNoTemporaryAddon
(
extension
.
id
)
;
let
lookup
=
managedStorage
.
get
(
extension
)
;
if
(
!
lookup
)
{
lookup
=
lookupManagedStorage
(
extension
.
id
context
)
;
managedStorage
.
set
(
extension
lookup
)
;
}
let
data
=
await
lookup
;
if
(
!
data
)
{
return
Promise
.
reject
(
{
message
:
"
Managed
storage
manifest
not
found
"
}
)
;
}
return
ExtensionStorage
.
_filterProperties
(
extension
.
id
data
keys
)
;
}
onChanged
:
ignoreEvent
(
context
"
storage
.
managed
.
onChanged
"
)
}
onChanged
:
new
EventManager
(
{
context
module
:
"
storage
"
event
:
"
onChanged
"
extensionApi
:
this
}
)
.
api
(
)
}
}
;
}
}
;
