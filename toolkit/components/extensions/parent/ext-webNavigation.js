"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
MatchURLFilters
:
"
resource
:
/
/
gre
/
modules
/
MatchURLFilters
.
jsm
"
WebNavigation
:
"
resource
:
/
/
gre
/
modules
/
WebNavigation
.
jsm
"
WebNavigationFrames
:
"
resource
:
/
/
gre
/
modules
/
WebNavigationFrames
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
}
)
;
var
{
ExtensionError
}
=
ExtensionUtils
;
const
defaultTransitionTypes
=
{
topFrame
:
"
link
"
subFrame
:
"
auto_subframe
"
}
;
const
frameTransitions
=
{
anyFrame
:
{
qualifiers
:
[
"
server_redirect
"
"
client_redirect
"
"
forward_back
"
]
}
topFrame
:
{
types
:
[
"
reload
"
"
form_submit
"
]
}
}
;
const
tabTransitions
=
{
topFrame
:
{
qualifiers
:
[
"
from_address_bar
"
]
types
:
[
"
auto_bookmark
"
"
typed
"
"
keyword
"
"
generated
"
"
link
"
]
}
subFrame
:
{
types
:
[
"
manual_subframe
"
]
}
}
;
const
isTopLevelFrame
=
(
{
frameId
parentFrameId
}
)
=
>
{
return
frameId
=
=
0
&
&
parentFrameId
=
=
-
1
;
}
;
const
fillTransitionProperties
=
(
eventName
src
dst
)
=
>
{
if
(
eventName
=
=
"
onCommitted
"
|
|
eventName
=
=
"
onHistoryStateUpdated
"
|
|
eventName
=
=
"
onReferenceFragmentUpdated
"
)
{
let
frameTransitionData
=
src
.
frameTransitionData
|
|
{
}
;
let
tabTransitionData
=
src
.
tabTransitionData
|
|
{
}
;
let
transitionType
transitionQualifiers
=
[
]
;
for
(
let
qualifier
of
frameTransitions
.
anyFrame
.
qualifiers
)
{
if
(
frameTransitionData
[
qualifier
]
)
{
transitionQualifiers
.
push
(
qualifier
)
;
}
}
if
(
isTopLevelFrame
(
dst
)
)
{
for
(
let
type
of
frameTransitions
.
topFrame
.
types
)
{
if
(
frameTransitionData
[
type
]
)
{
transitionType
=
type
;
}
}
for
(
let
qualifier
of
tabTransitions
.
topFrame
.
qualifiers
)
{
if
(
tabTransitionData
[
qualifier
]
)
{
transitionQualifiers
.
push
(
qualifier
)
;
}
}
for
(
let
type
of
tabTransitions
.
topFrame
.
types
)
{
if
(
tabTransitionData
[
type
]
)
{
transitionType
=
type
;
}
}
if
(
!
transitionType
)
{
transitionType
=
defaultTransitionTypes
.
topFrame
;
}
}
else
{
transitionType
=
tabTransitionData
.
link
?
"
manual_subframe
"
:
defaultTransitionTypes
.
subFrame
;
}
dst
.
transitionType
=
transitionType
;
dst
.
transitionQualifiers
=
transitionQualifiers
;
}
}
;
class
WebNavigationEventManager
extends
EventManager
{
constructor
(
context
eventName
)
{
let
{
tabManager
}
=
context
.
extension
;
let
name
=
webNavigation
.
{
eventName
}
;
let
register
=
(
fire
urlFilters
)
=
>
{
let
filters
=
urlFilters
?
new
MatchURLFilters
(
urlFilters
.
url
)
:
null
;
let
listener
=
data
=
>
{
if
(
!
data
.
browser
)
{
return
;
}
if
(
context
&
&
!
context
.
privateBrowsingAllowed
&
&
PrivateBrowsingUtils
.
isBrowserPrivate
(
data
.
browser
)
)
{
return
;
}
if
(
filters
&
&
!
filters
.
matches
(
data
.
url
)
)
{
return
;
}
let
data2
=
{
url
:
data
.
url
timeStamp
:
Date
.
now
(
)
}
;
if
(
eventName
=
=
"
onErrorOccurred
"
)
{
data2
.
error
=
data
.
error
;
}
if
(
data
.
frameId
!
=
undefined
)
{
data2
.
frameId
=
data
.
frameId
;
data2
.
parentFrameId
=
data
.
parentFrameId
;
}
if
(
data
.
sourceFrameId
!
=
undefined
)
{
data2
.
sourceFrameId
=
data
.
sourceFrameId
;
}
const
chromeWin
=
data
.
browser
.
ownerGlobal
;
if
(
chromeWin
&
&
chromeWin
.
gBrowser
&
&
chromeWin
.
gBrowserInit
&
&
chromeWin
.
gBrowserInit
.
isAdoptingTab
(
)
&
&
chromeWin
.
gBrowser
.
selectedBrowser
=
=
=
data
.
browser
)
{
return
;
}
Object
.
assign
(
data2
tabTracker
.
getBrowserData
(
data
.
browser
)
)
;
if
(
data2
.
tabId
<
0
)
{
return
;
}
let
tab
=
tabTracker
.
getTab
(
data2
.
tabId
)
;
if
(
!
tabManager
.
canAccessTab
(
tab
)
)
{
return
;
}
if
(
data
.
sourceTabBrowser
)
{
data2
.
sourceTabId
=
tabTracker
.
getBrowserData
(
data
.
sourceTabBrowser
)
.
tabId
;
}
fillTransitionProperties
(
eventName
data
data2
)
;
fire
.
async
(
data2
)
;
}
;
WebNavigation
[
eventName
]
.
addListener
(
listener
)
;
return
(
)
=
>
{
WebNavigation
[
eventName
]
.
removeListener
(
listener
)
;
}
;
}
;
super
(
{
context
name
register
}
)
;
}
}
this
.
webNavigation
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
let
{
tabManager
}
=
context
.
extension
;
return
{
webNavigation
:
{
onTabReplaced
:
new
EventManager
(
{
context
name
:
"
webNavigation
.
onTabReplaced
"
register
:
fire
=
>
{
return
(
)
=
>
{
}
;
}
}
)
.
api
(
)
onBeforeNavigate
:
new
WebNavigationEventManager
(
context
"
onBeforeNavigate
"
)
.
api
(
)
onCommitted
:
new
WebNavigationEventManager
(
context
"
onCommitted
"
)
.
api
(
)
onDOMContentLoaded
:
new
WebNavigationEventManager
(
context
"
onDOMContentLoaded
"
)
.
api
(
)
onCompleted
:
new
WebNavigationEventManager
(
context
"
onCompleted
"
)
.
api
(
)
onErrorOccurred
:
new
WebNavigationEventManager
(
context
"
onErrorOccurred
"
)
.
api
(
)
onReferenceFragmentUpdated
:
new
WebNavigationEventManager
(
context
"
onReferenceFragmentUpdated
"
)
.
api
(
)
onHistoryStateUpdated
:
new
WebNavigationEventManager
(
context
"
onHistoryStateUpdated
"
)
.
api
(
)
onCreatedNavigationTarget
:
new
WebNavigationEventManager
(
context
"
onCreatedNavigationTarget
"
)
.
api
(
)
getAllFrames
(
{
tabId
}
)
{
let
tab
=
tabManager
.
get
(
tabId
)
;
if
(
tab
.
discarded
)
{
return
null
;
}
let
frames
=
WebNavigationFrames
.
getAllFrames
(
tab
.
browsingContext
)
;
return
frames
.
map
(
fd
=
>
(
{
tabId
.
.
.
fd
}
)
)
;
}
getFrame
(
{
tabId
frameId
}
)
{
let
tab
=
tabManager
.
get
(
tabId
)
;
if
(
tab
.
discarded
)
{
return
null
;
}
let
fd
=
WebNavigationFrames
.
getFrame
(
tab
.
browsingContext
frameId
)
;
if
(
!
fd
)
{
throw
new
ExtensionError
(
No
frame
found
with
frameId
:
{
frameId
}
)
;
}
return
{
tabId
.
.
.
fd
}
;
}
}
}
;
}
}
;
