"
use
strict
"
;
var
{
ExtensionParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
var
{
HiddenExtensionPage
promiseExtensionViewLoaded
watchExtensionWorkerContextLoaded
}
=
ExtensionParent
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionTelemetry
"
"
resource
:
/
/
gre
/
modules
/
ExtensionTelemetry
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
serviceWorkerManager
"
(
)
=
>
{
return
Cc
[
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
]
.
getService
(
Ci
.
nsIServiceWorkerManager
)
;
}
)
;
class
BackgroundPage
extends
HiddenExtensionPage
{
constructor
(
extension
options
)
{
super
(
extension
"
background
"
)
;
this
.
page
=
options
.
page
|
|
null
;
this
.
isGenerated
=
!
!
options
.
scripts
;
if
(
this
.
page
)
{
this
.
url
=
this
.
extension
.
baseURI
.
resolve
(
this
.
page
)
;
}
else
if
(
this
.
isGenerated
)
{
this
.
url
=
this
.
extension
.
baseURI
.
resolve
(
"
_generated_background_page
.
html
"
)
;
}
}
async
build
(
)
{
const
{
extension
}
=
this
;
ExtensionTelemetry
.
backgroundPageLoad
.
stopwatchStart
(
extension
this
)
;
let
context
;
try
{
await
this
.
createBrowserElement
(
)
;
if
(
!
this
.
browser
)
{
throw
new
Error
(
"
Extension
shut
down
before
the
background
page
was
created
"
)
;
}
extension
.
_backgroundPageFrameLoader
=
this
.
browser
.
frameLoader
;
extensions
.
emit
(
"
extension
-
browser
-
inserted
"
this
.
browser
)
;
let
contextPromise
=
promiseExtensionViewLoaded
(
this
.
browser
)
;
this
.
browser
.
loadURI
(
this
.
url
{
triggeringPrincipal
:
extension
.
principal
}
)
;
context
=
await
contextPromise
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
ExtensionTelemetry
.
backgroundPageLoad
.
stopwatchCancel
(
extension
this
)
;
if
(
extension
.
persistentListeners
)
{
EventManager
.
clearPrimedListeners
(
this
.
extension
false
)
;
}
extension
.
emit
(
"
background
-
script
-
aborted
"
)
;
return
;
}
ExtensionTelemetry
.
backgroundPageLoad
.
stopwatchFinish
(
extension
this
)
;
if
(
context
)
{
await
Promise
.
all
(
context
.
listenerPromises
)
;
context
.
listenerPromises
=
null
;
extensions
.
emit
(
devtools
:
background
-
script
-
status
extension
.
id
true
)
;
context
.
callOnClose
(
{
close
(
)
{
extensions
.
emit
(
devtools
:
background
-
script
-
status
extension
.
id
false
)
;
}
}
)
;
}
if
(
extension
.
persistentListeners
)
{
EventManager
.
clearPrimedListeners
(
extension
!
!
this
.
extension
)
;
}
extension
.
emit
(
"
background
-
script
-
started
"
)
;
}
shutdown
(
)
{
this
.
extension
.
_backgroundPageFrameLoader
=
null
;
super
.
shutdown
(
)
;
}
}
class
BackgroundWorker
{
constructor
(
extension
options
)
{
this
.
extension
=
extension
;
this
.
workerScript
=
options
.
service_worker
;
if
(
!
this
.
workerScript
)
{
throw
new
Error
(
"
Missing
mandatory
background
.
service_worker
property
"
)
;
}
}
get
registrationInfo
(
)
{
const
{
principal
}
=
this
.
extension
;
return
serviceWorkerManager
.
getRegistrationForAddonPrincipal
(
principal
)
;
}
getWorkerInfo
(
descriptorId
)
{
return
this
.
registrationInfo
?
.
getWorkerByID
(
descriptorId
)
;
}
validateWorkerInfoForContext
(
context
)
{
const
{
extension
}
=
this
;
if
(
!
this
.
getWorkerInfo
(
context
.
workerDescriptorId
)
)
{
throw
new
Error
(
ServiceWorkerInfo
not
found
for
{
extension
.
policy
.
debugName
}
contextId
{
context
.
contextId
}
)
;
}
}
async
build
(
)
{
const
{
extension
}
=
this
;
let
context
;
try
{
const
contextPromise
=
new
Promise
(
resolve
=
>
{
let
unwatch
=
watchExtensionWorkerContextLoaded
(
{
extension
viewType
:
"
background_worker
"
}
context
=
>
{
unwatch
(
)
;
this
.
validateWorkerInfoForContext
(
context
)
;
resolve
(
context
)
;
}
)
;
}
)
;
await
serviceWorkerManager
.
registerForAddonPrincipal
(
this
.
extension
.
principal
)
;
context
=
await
contextPromise
;
await
this
.
waitForActiveWorker
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
if
(
extension
.
persistentListeners
)
{
EventManager
.
clearPrimedListeners
(
this
.
extension
false
)
;
}
extension
.
emit
(
"
background
-
script
-
aborted
"
)
;
return
;
}
if
(
context
)
{
await
Promise
.
all
(
context
.
listenerPromises
)
;
context
.
listenerPromises
=
null
;
extensions
.
emit
(
devtools
:
background
-
script
-
status
extension
.
id
true
)
;
context
.
callOnClose
(
{
close
(
)
{
extensions
.
emit
(
devtools
:
background
-
script
-
status
extension
.
id
false
)
;
}
}
)
;
}
if
(
extension
.
persistentListeners
)
{
EventManager
.
clearPrimedListeners
(
extension
!
!
this
.
extension
)
;
}
extension
.
emit
(
"
background
-
script
-
started
"
)
;
}
shutdown
(
isAppShutdown
)
{
if
(
!
isAppShutdown
)
{
this
.
registrationInfo
?
.
forceShutdown
(
)
;
}
}
waitForActiveWorker
(
)
{
const
{
extension
registrationInfo
}
=
this
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
resolveOnActive
=
(
)
=
>
{
if
(
registrationInfo
.
activeWorker
?
.
state
=
=
=
Ci
.
nsIServiceWorkerInfo
.
STATE_ACTIVATED
)
{
resolve
(
)
;
return
true
;
}
return
false
;
}
;
const
rejectOnUnregistered
=
(
)
=
>
{
if
(
registrationInfo
.
unregistered
)
{
reject
(
new
Error
(
Background
service
worker
unregistered
for
"
{
extension
.
policy
.
debugName
}
"
)
)
;
return
true
;
}
return
false
;
}
;
if
(
resolveOnActive
(
)
|
|
rejectOnUnregistered
(
)
)
{
return
;
}
const
listener
=
{
onChange
(
)
{
if
(
resolveOnActive
(
)
|
|
rejectOnUnregistered
(
)
)
{
registrationInfo
.
removeListener
(
listener
)
;
}
}
}
;
registrationInfo
.
addListener
(
listener
)
;
}
)
;
}
}
this
.
backgroundPage
=
class
extends
ExtensionAPI
{
async
build
(
)
{
if
(
this
.
bgInstance
)
{
return
;
}
let
{
extension
}
=
this
;
let
{
manifest
}
=
extension
;
let
BackgroundClass
=
manifest
.
background
.
service_worker
?
BackgroundWorker
:
BackgroundPage
;
this
.
bgInstance
=
new
BackgroundClass
(
extension
manifest
.
background
)
;
return
this
.
bgInstance
.
build
(
)
;
}
async
primeBackground
(
isInStartup
=
true
)
{
let
{
extension
}
=
this
;
if
(
this
.
bgInstance
)
{
Cu
.
reportError
(
background
script
exists
before
priming
{
extension
.
id
}
)
;
}
this
.
bgInstance
=
null
;
if
(
PrivateBrowsingUtils
.
permanentPrivateBrowsing
&
&
!
extension
.
privateBrowsingAllowed
)
{
return
;
}
let
bgStartupPromise
=
new
Promise
(
resolve
=
>
{
let
done
=
(
)
=
>
{
extension
.
off
(
"
background
-
script
-
started
"
done
)
;
extension
.
off
(
"
background
-
script
-
aborted
"
done
)
;
extension
.
off
(
"
shutdown
"
done
)
;
resolve
(
)
;
}
;
extension
.
on
(
"
background
-
script
-
started
"
done
)
;
extension
.
on
(
"
background
-
script
-
aborted
"
done
)
;
extension
.
on
(
"
shutdown
"
done
)
;
}
)
;
extension
.
promiseBackgroundStarted
=
(
)
=
>
{
return
bgStartupPromise
;
}
;
extension
.
wakeupBackground
=
(
)
=
>
{
extension
.
emit
(
"
background
-
script
-
event
"
)
;
extension
.
wakeupBackground
=
(
)
=
>
bgStartupPromise
;
return
bgStartupPromise
;
}
;
extension
.
terminateBackground
=
async
(
)
=
>
{
await
bgStartupPromise
;
this
.
onShutdown
(
false
)
;
EventManager
.
clearPrimedListeners
(
this
.
extension
false
)
;
return
this
.
primeBackground
(
false
)
;
}
;
extension
.
once
(
"
terminate
-
background
-
script
"
async
(
)
=
>
{
if
(
!
this
.
extension
)
{
return
;
}
this
.
extension
.
terminateBackground
(
)
;
}
)
;
if
(
isInStartup
&
&
(
extension
.
testNoDelayedStartup
|
|
extension
.
startupReason
!
=
=
"
APP_STARTUP
"
|
|
extension
.
updateReason
)
)
{
return
this
.
build
(
)
;
}
EventManager
.
primeListeners
(
extension
isInStartup
)
;
extension
.
once
(
"
start
-
background
-
script
"
async
(
)
=
>
{
if
(
!
this
.
extension
)
{
return
;
}
await
this
.
build
(
)
;
}
)
;
extension
.
once
(
"
background
-
script
-
event
"
async
(
)
=
>
{
await
ExtensionParent
.
browserPaintedPromise
;
extension
.
emit
(
"
start
-
background
-
script
"
)
;
}
)
;
}
onShutdown
(
isAppShutdown
)
{
if
(
this
.
bgInstance
)
{
this
.
bgInstance
.
shutdown
(
isAppShutdown
)
;
this
.
bgInstance
=
null
;
this
.
extension
.
emit
(
"
shutdown
-
background
-
script
"
)
;
}
else
{
EventManager
.
clearPrimedListeners
(
this
.
extension
false
)
;
}
}
async
onManifestEntry
(
entryName
)
{
let
{
extension
}
=
this
;
await
this
.
primeBackground
(
)
;
ExtensionParent
.
browserStartupPromise
.
then
(
(
)
=
>
{
if
(
this
.
bgInstance
)
{
return
;
}
if
(
extension
.
persistentBackground
|
|
!
extension
.
persistentListeners
?
.
size
)
{
extension
.
emit
(
"
start
-
background
-
script
"
)
;
}
else
{
EventManager
.
clearPrimedListeners
(
extension
false
)
;
extension
.
persistentListeners
=
null
;
EventManager
.
primeListeners
(
extension
false
)
;
}
}
)
;
}
}
;
