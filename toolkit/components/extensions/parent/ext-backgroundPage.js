"
use
strict
"
;
var
{
ExtensionParent
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
sys
.
mjs
"
)
;
var
{
HiddenExtensionPage
promiseBackgroundViewLoaded
watchExtensionWorkerContextLoaded
}
=
ExtensionParent
;
ChromeUtils
.
defineESModuleGetters
(
this
{
ExtensionTelemetry
:
"
resource
:
/
/
gre
/
modules
/
ExtensionTelemetry
.
sys
.
mjs
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
serviceWorkerManager
"
(
)
=
>
{
return
Cc
[
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
]
.
getService
(
Ci
.
nsIServiceWorkerManager
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
backgroundIdleTimeout
"
"
extensions
.
background
.
idle
.
timeout
"
30000
null
delay
=
>
Math
.
min
(
Math
.
max
(
delay
100
)
5
*
60
*
1000
)
)
;
Cu
.
importGlobalProperties
(
[
"
DOMException
"
]
)
;
function
notifyBackgroundScriptStatus
(
addonId
isRunning
)
{
const
subject
=
{
addonId
isRunning
}
;
Services
.
obs
.
notifyObservers
(
subject
"
extension
:
background
-
script
-
status
"
)
;
}
function
msSinceProcessStartExcludingSuspend
(
)
{
let
now
;
try
{
now
=
Services
.
telemetry
.
msSinceProcessStartExcludingSuspend
(
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
return
now
;
}
const
BACKGROUND_STATE
=
{
STARTING
:
"
starting
"
RUNNING
:
"
running
"
SUSPENDING
:
"
suspending
"
STOPPED
:
"
stopped
"
}
;
class
BackgroundPage
extends
HiddenExtensionPage
{
constructor
(
extension
options
)
{
super
(
extension
"
background
"
)
;
this
.
page
=
options
.
page
|
|
null
;
this
.
isGenerated
=
!
!
options
.
scripts
;
this
.
msSinceCreated
=
null
;
if
(
this
.
page
)
{
this
.
url
=
this
.
extension
.
baseURI
.
resolve
(
this
.
page
)
;
}
else
if
(
this
.
isGenerated
)
{
this
.
url
=
this
.
extension
.
baseURI
.
resolve
(
"
_generated_background_page
.
html
"
)
;
}
}
async
build
(
)
{
const
{
extension
}
=
this
;
ExtensionTelemetry
.
backgroundPageLoad
.
stopwatchStart
(
extension
this
)
;
let
context
;
try
{
await
this
.
createBrowserElement
(
)
;
if
(
!
this
.
browser
)
{
throw
new
Error
(
"
Extension
shut
down
before
the
background
page
was
created
"
)
;
}
extension
.
_backgroundPageFrameLoader
=
this
.
browser
.
frameLoader
;
extensions
.
emit
(
"
extension
-
browser
-
inserted
"
this
.
browser
)
;
let
contextPromise
=
promiseBackgroundViewLoaded
(
this
.
browser
)
;
this
.
browser
.
fixupAndLoadURIString
(
this
.
url
{
triggeringPrincipal
:
extension
.
principal
}
)
;
context
=
await
contextPromise
;
this
.
msSinceCreated
=
msSinceProcessStartExcludingSuspend
(
)
;
ExtensionTelemetry
.
backgroundPageLoad
.
stopwatchFinish
(
extension
this
)
;
}
catch
(
e
)
{
ExtensionTelemetry
.
backgroundPageLoad
.
stopwatchCancel
(
extension
this
)
;
throw
e
;
}
return
context
;
}
shutdown
(
)
{
this
.
extension
.
_backgroundPageFrameLoader
=
null
;
super
.
shutdown
(
)
;
}
}
class
BackgroundWorker
{
constructor
(
extension
options
)
{
this
.
extension
=
extension
;
this
.
workerScript
=
options
.
service_worker
;
if
(
!
this
.
workerScript
)
{
throw
new
Error
(
"
Missing
mandatory
background
.
service_worker
property
"
)
;
}
}
get
registrationInfo
(
)
{
const
{
principal
}
=
this
.
extension
;
return
serviceWorkerManager
.
getRegistrationForAddonPrincipal
(
principal
)
;
}
getWorkerInfo
(
descriptorId
)
{
return
this
.
registrationInfo
?
.
getWorkerByID
(
descriptorId
)
;
}
validateWorkerInfoForContext
(
context
)
{
const
{
extension
}
=
this
;
if
(
!
this
.
getWorkerInfo
(
context
.
workerDescriptorId
)
)
{
throw
new
Error
(
ServiceWorkerInfo
not
found
for
{
extension
.
policy
.
debugName
}
contextId
{
context
.
contextId
}
)
;
}
}
async
build
(
)
{
const
{
extension
}
=
this
;
let
context
;
const
contextPromise
=
new
Promise
(
resolve
=
>
{
let
unwatch
=
watchExtensionWorkerContextLoaded
(
{
extension
viewType
:
"
background_worker
"
}
context
=
>
{
unwatch
(
)
;
this
.
validateWorkerInfoForContext
(
context
)
;
resolve
(
context
)
;
}
)
;
}
)
;
await
serviceWorkerManager
.
registerForAddonPrincipal
(
this
.
extension
.
principal
)
;
context
=
await
contextPromise
;
await
this
.
waitForActiveWorker
(
)
;
return
context
;
}
shutdown
(
isAppShutdown
)
{
if
(
!
isAppShutdown
)
{
this
.
registrationInfo
?
.
forceShutdown
(
)
;
}
}
waitForActiveWorker
(
)
{
const
{
extension
registrationInfo
}
=
this
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
resolveOnActive
=
(
)
=
>
{
if
(
registrationInfo
.
activeWorker
?
.
state
=
=
=
Ci
.
nsIServiceWorkerInfo
.
STATE_ACTIVATED
)
{
resolve
(
)
;
return
true
;
}
return
false
;
}
;
const
rejectOnUnregistered
=
(
)
=
>
{
if
(
registrationInfo
.
unregistered
)
{
reject
(
new
Error
(
Background
service
worker
unregistered
for
"
{
extension
.
policy
.
debugName
}
"
)
)
;
return
true
;
}
return
false
;
}
;
if
(
resolveOnActive
(
)
|
|
rejectOnUnregistered
(
)
)
{
return
;
}
const
listener
=
{
onChange
(
)
{
if
(
resolveOnActive
(
)
|
|
rejectOnUnregistered
(
)
)
{
registrationInfo
.
removeListener
(
listener
)
;
}
}
}
;
registrationInfo
.
addListener
(
listener
)
;
}
)
;
}
}
class
BackgroundContextOwner
{
backgroundBuilder
;
extension
;
bgInstance
=
null
;
context
=
null
;
canBePrimed
=
true
;
shouldPrimeBackground
=
true
;
constructor
(
backgroundBuilder
extension
)
{
this
.
backgroundBuilder
=
backgroundBuilder
;
this
.
extension
=
extension
;
this
.
onExtensionProcessCrashed
=
this
.
onExtensionProcessCrashed
.
bind
(
this
)
;
this
.
onExtensionEnableProcessSpawning
=
this
.
onExtensionEnableProcessSpawning
.
bind
(
this
)
;
extension
.
backgroundState
=
BACKGROUND_STATE
.
STOPPED
;
extensions
.
on
(
"
extension
-
process
-
crash
"
this
.
onExtensionProcessCrashed
)
;
extensions
.
on
(
"
extension
-
enable
-
process
-
spawning
"
this
.
onExtensionEnableProcessSpawning
)
;
}
setBgStateStarting
(
bgInstance
)
{
if
(
!
this
.
extension
)
{
throw
new
Error
(
Cannot
start
background
after
extension
shutdown
.
)
;
}
if
(
this
.
bgInstance
)
{
throw
new
Error
(
Cannot
start
multiple
background
instances
)
;
}
this
.
extension
.
backgroundState
=
BACKGROUND_STATE
.
STARTING
;
this
.
bgInstance
=
bgInstance
;
this
.
canBePrimed
=
false
;
}
setBgStateRunning
(
context
)
{
if
(
!
this
.
extension
)
{
throw
new
Error
(
Extension
has
shut
down
before
startup
completion
.
)
;
}
if
(
this
.
context
)
{
throw
new
Error
(
Context
already
set
before
at
startup
completion
.
)
;
}
if
(
!
context
)
{
throw
new
Error
(
Context
not
found
at
startup
completion
.
)
;
}
if
(
context
.
unloaded
)
{
throw
new
Error
(
Context
has
unloaded
before
startup
completion
.
)
;
}
this
.
extension
.
backgroundState
=
BACKGROUND_STATE
.
RUNNING
;
this
.
context
=
context
;
context
.
callOnClose
(
this
)
;
EventManager
.
clearPrimedListeners
(
this
.
extension
true
)
;
notifyBackgroundScriptStatus
(
this
.
extension
.
id
true
)
;
this
.
extension
.
emit
(
"
background
-
script
-
started
"
)
;
}
setBgStateStopped
(
isAppShutdown
)
{
const
backgroundState
=
this
.
extension
.
backgroundState
;
if
(
this
.
context
)
{
this
.
context
.
forgetOnClose
(
this
)
;
this
.
context
=
null
;
notifyBackgroundScriptStatus
(
this
.
extension
.
id
false
)
;
}
if
(
backgroundState
=
=
=
BACKGROUND_STATE
.
STOPPED
|
|
backgroundState
=
=
=
BACKGROUND_STATE
.
STARTING
)
{
EventManager
.
clearPrimedListeners
(
this
.
extension
false
)
;
}
this
.
backgroundBuilder
.
clearIdleTimer
(
)
;
const
bgInstance
=
this
.
bgInstance
;
if
(
bgInstance
)
{
this
.
bgInstance
=
null
;
isAppShutdown
|
|
=
Services
.
startup
.
shuttingDown
;
bgInstance
.
shutdown
(
isAppShutdown
)
;
this
.
backgroundBuilder
.
onBgInstanceShutdown
(
bgInstance
)
;
}
this
.
extension
.
backgroundState
=
BACKGROUND_STATE
.
STOPPED
;
if
(
backgroundState
=
=
=
BACKGROUND_STATE
.
STARTING
)
{
this
.
extension
.
emit
(
"
background
-
script
-
aborted
"
)
;
}
if
(
this
.
extension
.
hasShutdown
)
{
this
.
extension
=
null
;
}
else
if
(
this
.
extension
.
persistentBackground
)
{
}
else
if
(
this
.
shouldPrimeBackground
)
{
this
.
backgroundBuilder
.
primeBackground
(
false
)
;
}
else
{
this
.
canBePrimed
=
true
;
}
}
close
(
)
{
if
(
this
.
context
)
{
this
.
context
.
forgetOnClose
(
this
)
;
this
.
context
=
null
;
notifyBackgroundScriptStatus
(
this
.
extension
.
id
false
)
;
}
}
onExtensionEnableProcessSpawning
(
)
{
if
(
!
this
.
canBePrimed
)
{
return
;
}
this
.
shouldPrimeBackground
=
true
;
this
.
backgroundBuilder
.
primeBackground
(
false
)
;
}
onExtensionProcessCrashed
(
eventName
data
)
{
this
.
shouldPrimeBackground
=
!
data
.
processSpawningDisabled
;
if
(
this
.
bgInstance
)
{
this
.
setBgStateStopped
(
)
;
}
}
onShutdown
(
isAppShutdown
)
{
if
(
this
.
extension
)
{
this
.
setBgStateStopped
(
isAppShutdown
)
;
}
extensions
.
off
(
"
extension
-
process
-
crash
"
this
.
onExtensionProcessCrashed
)
;
extensions
.
off
(
"
extension
-
enable
-
process
-
spawning
"
this
.
onExtensionEnableProcessSpawning
)
;
}
}
class
BackgroundBuilder
{
constructor
(
extension
)
{
this
.
extension
=
extension
;
this
.
backgroundContextOwner
=
new
BackgroundContextOwner
(
this
extension
)
;
}
async
build
(
)
{
if
(
this
.
backgroundContextOwner
.
bgInstance
)
{
return
;
}
let
{
extension
}
=
this
;
let
{
manifest
}
=
extension
;
extension
.
backgroundState
=
BACKGROUND_STATE
.
STARTING
;
this
.
isWorker
=
Boolean
(
manifest
.
background
.
service_worker
)
;
let
BackgroundClass
=
this
.
isWorker
?
BackgroundWorker
:
BackgroundPage
;
const
bgInstance
=
new
BackgroundClass
(
extension
manifest
.
background
)
;
this
.
backgroundContextOwner
.
setBgStateStarting
(
bgInstance
)
;
let
context
;
try
{
context
=
await
bgInstance
.
build
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
if
(
this
.
backgroundContextOwner
.
bgInstance
=
=
=
bgInstance
)
{
this
.
backgroundContextOwner
.
setBgStateStopped
(
)
;
}
return
;
}
if
(
context
)
{
await
Promise
.
all
(
context
.
listenerPromises
)
;
context
.
listenerPromises
=
null
;
}
if
(
this
.
backgroundContextOwner
.
bgInstance
!
=
=
bgInstance
)
{
return
;
}
try
{
this
.
backgroundContextOwner
.
setBgStateRunning
(
context
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
this
.
backgroundContextOwner
.
setBgStateStopped
(
)
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
timer
-
callback
"
)
{
let
{
extension
}
=
this
;
this
.
clearIdleTimer
(
)
;
extension
?
.
terminateBackground
(
)
;
}
}
clearIdleTimer
(
)
{
this
.
backgroundTimer
?
.
cancel
(
)
;
this
.
backgroundTimer
=
null
;
}
resetIdleTimer
(
)
{
this
.
clearIdleTimer
(
)
;
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
init
(
this
backgroundIdleTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
this
.
backgroundTimer
=
timer
;
}
primeBackground
(
isInStartup
=
true
)
{
let
{
extension
}
=
this
;
if
(
this
.
backgroundContextOwner
.
bgInstance
)
{
throw
new
Error
(
bgInstance
exists
before
priming
{
extension
.
id
}
)
;
}
let
bgStartupPromise
=
new
Promise
(
resolve
=
>
{
let
done
=
(
)
=
>
{
extension
.
off
(
"
background
-
script
-
started
"
done
)
;
extension
.
off
(
"
background
-
script
-
aborted
"
done
)
;
extension
.
off
(
"
shutdown
"
done
)
;
resolve
(
)
;
}
;
extension
.
on
(
"
background
-
script
-
started
"
done
)
;
extension
.
on
(
"
background
-
script
-
aborted
"
done
)
;
extension
.
on
(
"
shutdown
"
done
)
;
}
)
;
extension
.
promiseBackgroundStarted
=
(
)
=
>
{
return
bgStartupPromise
;
}
;
extension
.
wakeupBackground
=
(
)
=
>
{
if
(
extension
.
hasShutdown
)
{
return
Promise
.
reject
(
new
Error
(
"
wakeupBackground
called
while
the
extension
was
already
shutting
down
"
)
)
;
}
extension
.
emit
(
"
background
-
script
-
event
"
)
;
extension
.
wakeupBackground
=
(
)
=
>
bgStartupPromise
;
return
bgStartupPromise
;
}
;
let
resetBackgroundIdle
=
(
eventName
resetIdleDetails
)
=
>
{
this
.
clearIdleTimer
(
)
;
if
(
!
this
.
extension
|
|
extension
.
persistentBackground
)
{
return
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
"
extensions
.
background
.
idle
.
enabled
"
true
)
)
{
return
;
}
if
(
extension
.
backgroundState
=
=
BACKGROUND_STATE
.
SUSPENDING
)
{
extension
.
backgroundState
=
BACKGROUND_STATE
.
RUNNING
;
extension
.
emit
(
"
background
-
script
-
suspend
-
canceled
"
)
;
}
this
.
resetIdleTimer
(
)
;
if
(
eventName
=
=
=
"
background
-
script
-
reset
-
idle
"
&
&
!
this
.
isWorker
)
{
let
category
=
"
reset_other
"
;
switch
(
resetIdleDetails
?
.
reason
)
{
case
"
event
"
:
category
=
"
reset_event
"
;
break
;
case
"
hasActiveNativeAppPorts
"
:
category
=
"
reset_nativeapp
"
;
break
;
case
"
hasActiveStreamFilter
"
:
category
=
"
reset_streamfilter
"
;
break
;
case
"
pendingListeners
"
:
category
=
"
reset_listeners
"
;
break
;
}
ExtensionTelemetry
.
eventPageIdleResult
.
histogramAdd
(
{
extension
category
}
)
;
}
}
;
extension
.
on
(
"
background
-
script
-
reset
-
idle
"
resetBackgroundIdle
)
;
extension
.
once
(
"
background
-
script
-
started
"
resetBackgroundIdle
)
;
extension
.
terminateBackground
=
async
(
{
ignoreDevToolsAttached
=
false
disableResetIdleForTest
=
false
}
=
{
}
)
=
>
{
await
bgStartupPromise
;
if
(
!
this
.
extension
|
|
this
.
extension
.
hasShutdown
)
{
return
;
}
if
(
extension
.
backgroundState
!
=
BACKGROUND_STATE
.
RUNNING
)
{
return
;
}
if
(
!
ignoreDevToolsAttached
&
&
ExtensionParent
.
DebugUtils
.
hasDevToolsAttached
(
extension
.
id
)
)
{
extension
.
emit
(
"
background
-
script
-
suspend
-
ignored
"
)
;
return
;
}
if
(
!
disableResetIdleForTest
&
&
extension
.
backgroundContext
?
.
hasActiveNativeAppPorts
)
{
extension
.
emit
(
"
background
-
script
-
reset
-
idle
"
{
reason
:
"
hasActiveNativeAppPorts
"
}
)
;
return
;
}
if
(
!
disableResetIdleForTest
&
&
extension
.
backgroundContext
?
.
pendingRunListenerPromisesCount
)
{
extension
.
emit
(
"
background
-
script
-
reset
-
idle
"
{
reason
:
"
pendingListeners
"
pendingListeners
:
extension
.
backgroundContext
.
pendingRunListenerPromisesCount
}
)
;
extension
.
backgroundContext
.
clearPendingRunListenerPromises
(
)
;
return
;
}
const
childId
=
extension
.
backgroundContext
?
.
childId
;
if
(
childId
!
=
=
undefined
&
&
extension
.
hasPermission
(
"
webRequestBlocking
"
)
&
&
(
extension
.
manifestVersion
<
=
3
|
|
extension
.
hasPermission
(
"
webRequestFilterResponse
"
)
)
)
{
const
hasActiveStreamFilter
=
await
ExtensionParent
.
ParentAPIManager
.
queryStreamFilterSuspendCancel
(
extension
.
backgroundContext
.
childId
)
.
catch
(
err
=
>
{
if
(
extension
.
backgroundState
=
=
BACKGROUND_STATE
.
STOPPED
&
&
DOMException
.
isInstance
(
err
)
&
&
err
.
name
=
=
=
"
AbortError
"
)
{
return
false
;
}
Cu
.
reportError
(
err
)
;
return
false
;
}
)
;
if
(
!
disableResetIdleForTest
&
&
hasActiveStreamFilter
)
{
extension
.
emit
(
"
background
-
script
-
reset
-
idle
"
{
reason
:
"
hasActiveStreamFilter
"
}
)
;
return
;
}
if
(
extension
.
backgroundState
!
=
=
BACKGROUND_STATE
.
RUNNING
|
|
extension
.
hasShutdown
)
{
return
;
}
}
extension
.
backgroundState
=
BACKGROUND_STATE
.
SUSPENDING
;
this
.
clearIdleTimer
(
)
;
await
extension
.
emit
(
"
background
-
script
-
suspend
"
)
;
if
(
extension
.
backgroundState
!
=
BACKGROUND_STATE
.
SUSPENDING
)
{
return
;
}
extension
.
off
(
"
background
-
script
-
reset
-
idle
"
resetBackgroundIdle
)
;
if
(
!
this
.
isWorker
)
{
ExtensionTelemetry
.
eventPageIdleResult
.
histogramAdd
(
{
extension
category
:
"
suspend
"
}
)
;
}
this
.
backgroundContextOwner
.
setBgStateStopped
(
false
)
;
if
(
extension
.
persistentBackground
&
&
this
.
extension
)
{
this
.
primeBackground
(
false
)
;
}
}
;
EventManager
.
primeListeners
(
extension
isInStartup
)
;
if
(
!
isInStartup
)
{
this
.
backgroundContextOwner
.
canBePrimed
=
false
;
}
extension
.
once
(
"
start
-
background
-
script
"
async
(
)
=
>
{
if
(
!
this
.
extension
|
|
this
.
extension
.
hasShutdown
)
{
return
;
}
await
this
.
build
(
)
;
}
)
;
extension
.
once
(
"
background
-
script
-
event
"
async
(
)
=
>
{
await
ExtensionParent
.
browserPaintedPromise
;
extension
.
emit
(
"
start
-
background
-
script
"
)
;
}
)
;
}
onBgInstanceShutdown
(
bgInstance
)
{
const
{
msSinceCreated
}
=
bgInstance
;
const
{
extension
}
=
this
;
extension
.
emit
(
"
shutdown
-
background
-
script
"
)
;
if
(
msSinceCreated
)
{
const
now
=
msSinceProcessStartExcludingSuspend
(
)
;
if
(
now
&
&
!
(
this
.
isWorker
|
|
extension
.
persistentBackground
)
)
{
ExtensionTelemetry
.
eventPageRunningTime
.
histogramAdd
(
{
extension
value
:
now
-
msSinceCreated
}
)
;
}
}
}
}
this
.
backgroundPage
=
class
extends
ExtensionAPI
{
async
onManifestEntry
(
entryName
)
{
let
{
extension
}
=
this
;
if
(
PrivateBrowsingUtils
.
permanentPrivateBrowsing
&
&
!
extension
.
privateBrowsingAllowed
)
{
return
;
}
this
.
backgroundBuilder
=
new
BackgroundBuilder
(
extension
)
;
extension
.
once
(
"
background
-
script
-
started
"
(
)
=
>
{
extension
.
emit
(
"
background
-
first
-
run
"
)
;
}
)
;
this
.
backgroundBuilder
.
primeBackground
(
)
;
if
(
extension
.
testNoDelayedStartup
|
|
extension
.
startupReason
!
=
=
"
APP_STARTUP
"
|
|
extension
.
updateReason
)
{
await
this
.
backgroundBuilder
.
build
(
)
;
return
;
}
ExtensionParent
.
browserStartupPromise
.
then
(
(
)
=
>
{
if
(
!
this
.
backgroundBuilder
|
|
this
.
backgroundBuilder
.
backgroundContextOwner
.
bgInstance
|
|
!
this
.
backgroundBuilder
.
backgroundContextOwner
.
canBePrimed
)
{
return
;
}
this
.
backgroundBuilder
.
backgroundContextOwner
.
canBePrimed
=
false
;
if
(
extension
.
persistentBackground
|
|
!
extension
.
persistentListeners
?
.
size
|
|
(
extension
.
startupReason
=
=
"
APP_STARTUP
"
&
&
extension
.
persistentListeners
?
.
get
(
"
runtime
"
)
.
has
(
"
onStartup
"
)
)
)
{
extension
.
emit
(
"
start
-
background
-
script
"
)
;
}
else
{
EventManager
.
clearPrimedListeners
(
extension
false
)
;
extension
.
persistentListeners
=
null
;
EventManager
.
primeListeners
(
extension
false
)
;
}
}
)
;
}
onShutdown
(
isAppShutdown
)
{
if
(
this
.
backgroundBuilder
)
{
this
.
backgroundBuilder
.
backgroundContextOwner
.
onShutdown
(
isAppShutdown
)
;
this
.
backgroundBuilder
=
null
;
}
}
}
;
