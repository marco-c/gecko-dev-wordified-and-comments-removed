"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
LightweightThemeManager
:
"
resource
:
/
/
gre
/
modules
/
LightweightThemeManager
.
sys
.
mjs
"
}
)
;
const
onUpdatedEmitter
=
new
EventEmitter
(
)
;
const
emptyTheme
=
{
details
:
{
colors
:
null
images
:
null
properties
:
null
}
}
;
let
defaultTheme
=
emptyTheme
;
let
windowOverrides
=
new
WeakMap
(
)
;
class
Theme
{
constructor
(
{
extension
details
darkDetails
windowId
experiment
startupData
}
)
{
this
.
extension
=
extension
;
this
.
details
=
details
;
this
.
darkDetails
=
darkDetails
;
this
.
windowId
=
windowId
;
if
(
startupData
?
.
lwtData
)
{
this
.
lwtData
=
startupData
.
lwtData
;
this
.
experiment
=
startupData
.
lwtData
.
experiment
;
}
else
{
this
.
lwtData
=
null
;
this
.
experiment
=
null
;
if
(
experiment
)
{
if
(
extension
.
canUseThemeExperiment
(
)
)
{
this
.
experiment
=
experiment
;
}
else
{
const
{
logger
}
=
this
.
extension
;
logger
.
warn
(
"
This
extension
is
not
allowed
to
run
theme
experiments
"
)
;
return
;
}
}
}
this
.
load
(
)
;
}
load
(
)
{
if
(
!
this
.
lwtData
)
{
this
.
lwtData
=
LightweightThemeManager
.
themeDataFrom
(
this
.
details
this
.
darkDetails
this
.
experiment
this
.
extension
.
baseURI
this
.
extension
.
id
this
.
extension
.
version
this
.
extension
.
logger
)
;
if
(
this
.
extension
.
type
=
=
=
"
theme
"
)
{
this
.
extension
.
startupData
=
{
lwtData
:
this
.
lwtData
}
;
this
.
extension
.
saveStartupData
(
)
;
}
}
if
(
this
.
windowId
)
{
let
browserWindow
=
windowTracker
.
getWindow
(
this
.
windowId
)
;
this
.
lwtData
.
window
=
browserWindow
.
docShell
.
outerWindowID
;
windowOverrides
.
set
(
browserWindow
this
)
;
}
else
{
windowOverrides
=
new
WeakMap
(
)
;
defaultTheme
=
this
;
LightweightThemeManager
.
fallbackThemeData
=
this
.
lwtData
;
}
onUpdatedEmitter
.
emit
(
"
theme
-
updated
"
this
.
details
this
.
windowId
)
;
Services
.
obs
.
notifyObservers
(
this
.
lwtData
"
lightweight
-
theme
-
styling
-
update
"
)
;
}
static
unload
(
browserWindow
)
{
let
lwtData
=
{
theme
:
null
}
;
if
(
browserWindow
)
{
lwtData
.
window
=
browserWindow
.
docShell
?
.
outerWindowID
;
windowOverrides
.
delete
(
browserWindow
)
;
onUpdatedEmitter
.
emit
(
"
theme
-
updated
"
{
}
windowTracker
.
getId
(
browserWindow
)
)
;
}
else
{
windowOverrides
=
new
WeakMap
(
)
;
defaultTheme
=
emptyTheme
;
LightweightThemeManager
.
fallbackThemeData
=
null
;
onUpdatedEmitter
.
emit
(
"
theme
-
updated
"
{
}
)
;
}
Services
.
obs
.
notifyObservers
(
lwtData
"
lightweight
-
theme
-
styling
-
update
"
)
;
}
}
this
.
theme
=
class
extends
ExtensionAPIPersistent
{
PERSISTENT_EVENTS
=
{
onUpdated
(
{
fire
context
}
)
{
let
callback
=
(
event
theme
windowId
)
=
>
{
if
(
windowId
)
{
if
(
windowTracker
.
getWindow
(
windowId
context
false
)
)
{
fire
.
async
(
{
theme
windowId
}
)
;
}
}
else
{
fire
.
async
(
{
theme
}
)
;
}
}
;
onUpdatedEmitter
.
on
(
"
theme
-
updated
"
callback
)
;
return
{
unregister
(
)
{
onUpdatedEmitter
.
off
(
"
theme
-
updated
"
callback
)
;
}
convert
(
_fire
_context
)
{
fire
=
_fire
;
context
=
_context
;
}
}
;
}
}
;
onManifestEntry
(
)
{
let
{
extension
}
=
this
;
let
{
manifest
}
=
extension
;
defaultTheme
=
new
Theme
(
{
extension
details
:
manifest
.
theme
darkDetails
:
manifest
.
dark_theme
experiment
:
manifest
.
theme_experiment
startupData
:
extension
.
startupData
}
)
;
}
onShutdown
(
isAppShutdown
)
{
if
(
isAppShutdown
)
{
return
;
}
let
{
extension
}
=
this
;
for
(
let
browserWindow
of
ChromeUtils
.
nondeterministicGetWeakMapKeys
(
windowOverrides
)
)
{
let
theme
=
windowOverrides
.
get
(
browserWindow
)
;
if
(
theme
.
extension
=
=
=
extension
)
{
Theme
.
unload
(
browserWindow
)
;
}
}
if
(
defaultTheme
.
extension
=
=
=
extension
)
{
Theme
.
unload
(
)
;
}
}
getAPI
(
context
)
{
let
{
extension
}
=
context
;
return
{
theme
:
{
getCurrent
:
windowId
=
>
{
if
(
!
windowId
)
{
windowId
=
windowTracker
.
getId
(
windowTracker
.
topWindow
)
;
}
const
browserWindow
=
windowTracker
.
getWindow
(
windowId
context
)
;
if
(
windowOverrides
.
has
(
browserWindow
)
)
{
return
Promise
.
resolve
(
windowOverrides
.
get
(
browserWindow
)
.
details
)
;
}
return
Promise
.
resolve
(
defaultTheme
.
details
)
;
}
update
:
(
windowId
details
)
=
>
{
if
(
windowId
)
{
const
browserWindow
=
windowTracker
.
getWindow
(
windowId
context
)
;
if
(
!
browserWindow
)
{
return
Promise
.
reject
(
Invalid
window
ID
:
{
windowId
}
)
;
}
}
new
Theme
(
{
extension
details
windowId
experiment
:
this
.
extension
.
manifest
.
theme_experiment
}
)
;
}
reset
:
windowId
=
>
{
if
(
windowId
)
{
const
browserWindow
=
windowTracker
.
getWindow
(
windowId
context
)
;
const
theme
=
windowOverrides
.
get
(
browserWindow
)
|
|
defaultTheme
;
if
(
theme
.
extension
=
=
=
extension
)
{
Theme
.
unload
(
browserWindow
)
;
}
return
;
}
if
(
defaultTheme
.
extension
=
=
=
extension
)
{
Theme
.
unload
(
)
;
}
}
onUpdated
:
new
EventManager
(
{
context
module
:
"
theme
"
event
:
"
onUpdated
"
extensionApi
:
this
}
)
.
api
(
)
}
}
;
}
}
;
