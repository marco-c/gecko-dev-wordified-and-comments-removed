"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
ProxyScriptContext
"
"
resource
:
/
/
gre
/
modules
/
ProxyScriptContext
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ProxyChannelFilter
"
"
resource
:
/
/
gre
/
modules
/
ProxyScriptContext
.
jsm
"
)
;
const
proxyScriptContextMap
=
new
WeakMap
(
)
;
class
ProxyFilterEventManager
extends
EventManager
{
constructor
(
context
eventName
)
{
let
name
=
proxy
.
{
eventName
}
;
let
register
=
(
fire
filterProps
extraInfoSpec
=
[
]
)
=
>
{
let
listener
=
(
data
)
=
>
{
return
fire
.
sync
(
data
)
;
}
;
let
filter
=
{
.
.
.
filterProps
}
;
if
(
filter
.
urls
)
{
let
perms
=
new
MatchPatternSet
(
[
.
.
.
context
.
extension
.
whiteListedHosts
.
patterns
.
.
.
context
.
extension
.
optionalOrigins
.
patterns
]
)
;
filter
.
urls
=
new
MatchPatternSet
(
filter
.
urls
)
;
if
(
!
perms
.
overlapsAll
(
filter
.
urls
)
)
{
throw
new
context
.
cloneScope
.
Error
(
"
The
proxy
.
addListener
filter
doesn
'
t
overlap
with
host
permissions
.
"
)
;
}
}
let
proxyFilter
=
new
ProxyChannelFilter
(
context
listener
filter
extraInfoSpec
)
;
return
(
)
=
>
{
proxyFilter
.
destroy
(
)
;
}
;
}
;
super
(
{
context
name
register
}
)
;
}
}
this
.
proxy
=
class
extends
ExtensionAPI
{
onShutdown
(
)
{
let
{
extension
}
=
this
;
let
proxyScriptContext
=
proxyScriptContextMap
.
get
(
extension
)
;
if
(
proxyScriptContext
)
{
proxyScriptContext
.
unload
(
)
;
proxyScriptContextMap
.
delete
(
extension
)
;
}
}
getAPI
(
context
)
{
let
{
extension
}
=
context
;
let
onError
=
new
EventManager
(
{
context
name
:
"
proxy
.
onError
"
register
:
fire
=
>
{
let
listener
=
(
name
error
)
=
>
{
fire
.
async
(
error
)
;
}
;
extension
.
on
(
"
proxy
-
error
"
listener
)
;
return
(
)
=
>
{
extension
.
off
(
"
proxy
-
error
"
listener
)
;
}
;
}
}
)
.
api
(
)
;
return
{
proxy
:
{
register
(
url
)
{
this
.
unregister
(
)
;
let
proxyScriptContext
=
new
ProxyScriptContext
(
extension
url
)
;
if
(
proxyScriptContext
.
load
(
)
)
{
proxyScriptContextMap
.
set
(
extension
proxyScriptContext
)
;
}
}
unregister
(
)
{
if
(
proxyScriptContextMap
.
has
(
extension
)
)
{
proxyScriptContextMap
.
get
(
extension
)
.
unload
(
)
;
proxyScriptContextMap
.
delete
(
extension
)
;
}
}
registerProxyScript
(
url
)
{
this
.
register
(
url
)
;
}
onRequest
:
new
ProxyFilterEventManager
(
context
"
onRequest
"
)
.
api
(
)
onError
onProxyError
:
onError
}
}
;
}
}
;
