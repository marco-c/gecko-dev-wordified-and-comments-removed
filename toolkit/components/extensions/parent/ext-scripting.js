"
use
strict
"
;
const
{
ExtensionScriptingStore
makeInternalContentScript
makePublicContentScript
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionScriptingStore
.
jsm
"
)
;
var
{
ExtensionError
parseMatchPatterns
}
=
ExtensionUtils
;
const
gScriptIdsMap
=
new
Map
(
)
;
const
execute
=
(
context
details
kind
method
)
=
>
{
const
{
tabManager
}
=
context
.
extension
;
let
options
=
{
jsPaths
:
[
]
cssPaths
:
[
]
removeCSS
:
method
=
=
"
removeCSS
"
extensionId
:
context
.
extension
.
id
}
;
const
{
tabId
frameIds
allFrames
}
=
details
.
target
;
const
tab
=
tabManager
.
get
(
tabId
)
;
options
.
hasActiveTabPermission
=
tab
.
hasActiveTabPermission
;
options
.
matches
=
tab
.
extension
.
allowedOrigins
.
patterns
.
map
(
host
=
>
host
.
pattern
)
;
const
codeKey
=
kind
=
=
=
"
js
"
?
"
func
"
:
"
css
"
;
if
(
(
details
.
files
=
=
=
null
)
=
=
(
details
[
codeKey
]
=
=
=
null
)
)
{
throw
new
ExtensionError
(
Exactly
one
of
files
and
{
codeKey
}
must
be
specified
.
)
;
}
if
(
details
[
codeKey
]
)
{
options
[
{
kind
}
Code
]
=
details
[
codeKey
]
;
}
if
(
details
.
files
)
{
for
(
const
file
of
details
.
files
)
{
let
url
=
context
.
uri
.
resolve
(
file
)
;
if
(
!
tab
.
extension
.
isExtensionURL
(
url
)
)
{
throw
new
ExtensionError
(
"
Files
to
be
injected
must
be
within
the
extension
"
)
;
}
options
[
{
kind
}
Paths
]
.
push
(
url
)
;
}
}
if
(
allFrames
&
&
frameIds
)
{
throw
new
ExtensionError
(
"
Cannot
specify
both
'
allFrames
'
and
'
frameIds
'
.
"
)
;
}
if
(
allFrames
)
{
options
.
allFrames
=
allFrames
;
}
else
if
(
frameIds
)
{
options
.
frameIds
=
frameIds
;
}
else
{
options
.
frameIds
=
[
0
]
;
}
options
.
runAt
=
details
.
injectImmediately
?
"
document_start
"
:
"
document_idle
"
;
options
.
matchAboutBlank
=
true
;
options
.
wantReturnValue
=
true
;
options
.
returnResultsWithFrameIds
=
kind
=
=
=
"
js
"
;
if
(
details
.
origin
)
{
options
.
cssOrigin
=
details
.
origin
.
toLowerCase
(
)
;
}
else
{
options
.
cssOrigin
=
"
author
"
;
}
if
(
options
.
frameIds
&
&
options
.
frameIds
.
length
=
=
=
0
)
{
return
[
]
;
}
return
tab
.
queryContent
(
"
Execute
"
options
)
;
}
;
const
ensureValidScriptId
=
id
=
>
{
if
(
!
id
.
length
|
|
id
.
startsWith
(
"
_
"
)
)
{
throw
new
ExtensionError
(
"
Invalid
content
script
id
.
"
)
;
}
}
;
const
ensureValidScriptParams
=
(
extension
script
)
=
>
{
if
(
!
script
.
js
?
.
length
&
&
!
script
.
css
?
.
length
)
{
throw
new
ExtensionError
(
"
At
least
one
js
or
css
must
be
specified
.
"
)
;
}
if
(
!
script
.
matches
?
.
length
)
{
throw
new
ExtensionError
(
"
matches
must
be
specified
.
"
)
;
}
parseMatchPatterns
(
script
.
matches
{
restrictSchemes
:
extension
.
restrictSchemes
}
)
;
if
(
script
.
excludeMatches
)
{
parseMatchPatterns
(
script
.
excludeMatches
{
restrictSchemes
:
extension
.
restrictSchemes
}
)
;
}
}
;
this
.
scripting
=
class
extends
ExtensionAPI
{
constructor
(
extension
)
{
super
(
extension
)
;
gScriptIdsMap
.
set
(
extension
ExtensionScriptingStore
.
getInitialScriptIdsMap
(
extension
)
)
;
}
onShutdown
(
)
{
gScriptIdsMap
.
delete
(
this
.
extension
)
;
}
getAPI
(
context
)
{
const
{
extension
}
=
context
;
return
{
scripting
:
{
executeScriptInternal
:
async
details
=
>
{
return
execute
(
context
details
"
js
"
"
executeScript
"
)
;
}
insertCSS
:
async
details
=
>
{
return
execute
(
context
details
"
css
"
"
insertCSS
"
)
.
then
(
(
)
=
>
{
}
)
;
}
removeCSS
:
async
details
=
>
{
return
execute
(
context
details
"
css
"
"
removeCSS
"
)
.
then
(
(
)
=
>
{
}
)
;
}
registerContentScripts
:
async
scripts
=
>
{
const
scriptIdsMap
=
gScriptIdsMap
.
get
(
extension
)
;
const
scriptsToRegister
=
new
Map
(
)
;
for
(
const
script
of
scripts
)
{
ensureValidScriptId
(
script
.
id
)
;
if
(
scriptIdsMap
.
has
(
script
.
id
)
)
{
throw
new
ExtensionError
(
Content
script
with
id
"
{
script
.
id
}
"
is
already
registered
.
)
;
}
if
(
scriptsToRegister
.
has
(
script
.
id
)
)
{
throw
new
ExtensionError
(
Script
ID
"
{
script
.
id
}
"
found
more
than
once
in
'
scripts
'
array
.
)
;
}
ensureValidScriptParams
(
extension
script
)
;
scriptsToRegister
.
set
(
script
.
id
makeInternalContentScript
(
extension
script
)
)
;
}
for
(
const
[
id
{
scriptId
options
}
]
of
scriptsToRegister
)
{
scriptIdsMap
.
set
(
id
scriptId
)
;
extension
.
registeredContentScripts
.
set
(
scriptId
options
)
;
}
extension
.
updateContentScripts
(
)
;
ExtensionScriptingStore
.
persistAll
(
extension
)
;
await
extension
.
broadcast
(
"
Extension
:
RegisterContentScripts
"
{
id
:
extension
.
id
scripts
:
Array
.
from
(
scriptsToRegister
.
values
(
)
)
}
)
;
}
getRegisteredContentScripts
:
async
details
=
>
{
const
scriptIdsMap
=
gScriptIdsMap
.
get
(
extension
)
;
return
Array
.
from
(
scriptIdsMap
.
entries
(
)
)
.
filter
(
(
[
id
scriptId
]
)
=
>
!
details
?
.
ids
|
|
details
.
ids
.
includes
(
id
)
)
.
map
(
(
[
id
scriptId
]
)
=
>
{
const
options
=
extension
.
registeredContentScripts
.
get
(
scriptId
)
;
return
makePublicContentScript
(
extension
options
)
;
}
)
;
}
unregisterContentScripts
:
async
details
=
>
{
const
scriptIdsMap
=
gScriptIdsMap
.
get
(
extension
)
;
let
ids
=
[
]
;
if
(
details
?
.
ids
)
{
for
(
const
id
of
details
.
ids
)
{
ensureValidScriptId
(
id
)
;
if
(
!
scriptIdsMap
.
has
(
id
)
)
{
throw
new
ExtensionError
(
Content
script
with
id
"
{
id
}
"
does
not
exist
.
)
;
}
}
ids
=
details
.
ids
;
}
else
{
ids
=
Array
.
from
(
scriptIdsMap
.
keys
(
)
)
;
}
if
(
ids
.
length
=
=
=
0
)
{
return
;
}
const
scriptIds
=
[
]
;
for
(
const
id
of
ids
)
{
const
scriptId
=
scriptIdsMap
.
get
(
id
)
;
extension
.
registeredContentScripts
.
delete
(
scriptId
)
;
scriptIdsMap
.
delete
(
id
)
;
scriptIds
.
push
(
scriptId
)
;
}
extension
.
updateContentScripts
(
)
;
ExtensionScriptingStore
.
persistAll
(
extension
)
;
await
extension
.
broadcast
(
"
Extension
:
UnregisterContentScripts
"
{
id
:
extension
.
id
scriptIds
}
)
;
}
updateContentScripts
:
async
scripts
=
>
{
const
scriptIdsMap
=
gScriptIdsMap
.
get
(
extension
)
;
const
scriptsToUpdate
=
new
Map
(
)
;
for
(
const
script
of
scripts
)
{
ensureValidScriptId
(
script
.
id
)
;
if
(
!
scriptIdsMap
.
has
(
script
.
id
)
)
{
throw
new
ExtensionError
(
Content
script
with
id
"
{
script
.
id
}
"
does
not
exist
.
)
;
}
if
(
scriptsToUpdate
.
has
(
script
.
id
)
)
{
throw
new
ExtensionError
(
Script
ID
"
{
script
.
id
}
"
found
more
than
once
in
'
scripts
'
array
.
)
;
}
const
scriptId
=
scriptIdsMap
.
get
(
script
.
id
)
;
const
options
=
extension
.
registeredContentScripts
.
get
(
scriptId
)
;
script
.
allFrames
?
?
=
options
.
allFrames
;
script
.
css
?
?
=
options
.
cssPaths
;
script
.
excludeMatches
?
?
=
options
.
excludeMatches
;
script
.
js
?
?
=
options
.
jsPaths
;
script
.
matches
?
?
=
options
.
matches
;
script
.
runAt
?
?
=
options
.
runAt
;
script
.
persistAcrossSessions
?
?
=
options
.
persistAcrossSessions
;
ensureValidScriptParams
(
extension
script
)
;
scriptsToUpdate
.
set
(
script
.
id
{
.
.
.
makeInternalContentScript
(
extension
script
)
scriptId
}
)
;
}
for
(
const
{
scriptId
options
}
of
scriptsToUpdate
.
values
(
)
)
{
extension
.
registeredContentScripts
.
set
(
scriptId
options
)
;
}
extension
.
updateContentScripts
(
)
;
ExtensionScriptingStore
.
persistAll
(
extension
)
;
await
extension
.
broadcast
(
"
Extension
:
UpdateContentScripts
"
{
id
:
extension
.
id
scripts
:
Array
.
from
(
scriptsToUpdate
.
values
(
)
)
}
)
;
}
}
}
;
}
}
;
