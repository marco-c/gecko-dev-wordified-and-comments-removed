"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
WebRequest
:
"
resource
:
/
/
gre
/
modules
/
WebRequest
.
sys
.
mjs
"
}
)
;
var
{
parseMatchPatterns
DefaultMap
}
=
ExtensionUtils
;
const
MAX_HANDLER_BEHAVIOR_CHANGED_CALLS_PER_10_MINUTES
=
20
;
const
TIME_10_MINUTES_IN_MS
=
10
*
60
*
1000
;
const
handlerBehaviorChangedTimeStampsMap
=
new
DefaultMap
(
(
)
=
>
[
]
)
;
function
clearOldTimeStamps
(
timestamps
now
)
{
while
(
timestamps
.
length
)
{
if
(
timestamps
[
0
]
<
now
-
TIME_10_MINUTES_IN_MS
)
{
timestamps
.
shift
(
)
;
}
else
{
break
;
}
}
}
function
handlerBehaviorChangedCallAllowed
(
timestamps
)
{
return
timestamps
.
length
<
MAX_HANDLER_BEHAVIOR_CHANGED_CALLS_PER_10_MINUTES
;
}
function
registerEvent
(
extension
eventName
fire
filter
info
remoteTab
=
null
)
{
let
listener
=
async
data
=
>
{
let
event
=
data
.
serialize
(
eventName
)
;
if
(
data
.
registerTraceableChannel
)
{
if
(
fire
.
wakeup
)
{
await
fire
.
wakeup
(
)
;
}
data
.
registerTraceableChannel
(
extension
.
policy
remoteTab
)
;
}
return
fire
.
sync
(
event
)
;
}
;
let
filter2
=
{
}
;
if
(
filter
.
urls
)
{
let
perms
=
new
MatchPatternSet
(
[
.
.
.
extension
.
allowedOrigins
.
patterns
.
.
.
extension
.
optionalOrigins
.
patterns
]
)
;
filter2
.
urls
=
parseMatchPatterns
(
filter
.
urls
)
;
if
(
!
perms
.
overlapsAll
(
filter2
.
urls
)
)
{
Cu
.
reportError
(
"
The
webRequest
.
addListener
filter
doesn
'
t
overlap
with
host
permissions
.
"
)
;
}
}
if
(
filter
.
types
)
{
filter2
.
types
=
filter
.
types
;
}
if
(
filter
.
tabId
!
=
=
undefined
)
{
filter2
.
tabId
=
filter
.
tabId
;
}
if
(
filter
.
windowId
!
=
=
undefined
)
{
filter2
.
windowId
=
filter
.
windowId
;
}
if
(
filter
.
incognito
!
=
=
undefined
)
{
filter2
.
incognito
=
filter
.
incognito
;
}
let
blockingAllowed
=
eventName
=
=
"
onAuthRequired
"
?
extension
.
hasPermission
(
"
webRequestBlocking
"
)
|
|
extension
.
hasPermission
(
"
webRequestAuthProvider
"
)
:
extension
.
hasPermission
(
"
webRequestBlocking
"
)
;
let
info2
=
[
]
;
if
(
info
)
{
for
(
let
desc
of
info
)
{
if
(
(
desc
=
=
"
blocking
"
|
|
desc
=
=
"
asyncBlocking
"
)
&
&
!
blockingAllowed
)
{
Cu
.
reportError
(
"
Using
webRequest
.
addListener
with
the
blocking
option
"
+
"
requires
the
'
webRequestBlocking
'
permission
.
"
)
;
}
else
{
info2
.
push
(
desc
)
;
}
}
}
let
listenerDetails
=
{
addonId
:
extension
.
id
policy
:
extension
.
policy
blockingAllowed
}
;
WebRequest
[
eventName
]
.
addListener
(
listener
filter2
info2
listenerDetails
)
;
return
{
unregister
:
(
)
=
>
{
WebRequest
[
eventName
]
.
removeListener
(
listener
)
;
}
convert
(
_fire
context
)
{
fire
=
_fire
;
remoteTab
=
context
.
xulBrowser
.
frameLoader
.
remoteTab
;
}
}
;
}
function
makeWebRequestEventAPI
(
context
event
extensionApi
)
{
return
new
EventManager
(
{
context
module
:
"
webRequest
"
event
extensionApi
}
)
.
api
(
)
;
}
function
makeWebRequestEventRegistrar
(
event
)
{
return
function
(
{
fire
context
}
params
)
{
const
{
extension
}
=
this
;
const
[
filter
info
]
=
params
;
let
remoteTab
;
if
(
context
)
{
remoteTab
=
context
.
xulBrowser
.
frameLoader
.
remoteTab
;
}
return
registerEvent
(
extension
event
fire
filter
info
remoteTab
)
;
}
;
}
this
.
webRequest
=
class
extends
ExtensionAPIPersistent
{
primeListener
(
event
fire
params
isInStartup
)
{
if
(
!
isInStartup
|
|
params
[
1
]
?
.
some
(
v
=
>
v
=
=
=
"
blocking
"
|
|
v
=
=
=
"
asyncBlocking
"
)
)
{
return
super
.
primeListener
(
event
fire
params
isInStartup
)
;
}
}
PERSISTENT_EVENTS
=
{
onBeforeRequest
:
makeWebRequestEventRegistrar
(
"
onBeforeRequest
"
)
onBeforeSendHeaders
:
makeWebRequestEventRegistrar
(
"
onBeforeSendHeaders
"
)
onSendHeaders
:
makeWebRequestEventRegistrar
(
"
onSendHeaders
"
)
onHeadersReceived
:
makeWebRequestEventRegistrar
(
"
onHeadersReceived
"
)
onAuthRequired
:
makeWebRequestEventRegistrar
(
"
onAuthRequired
"
)
onBeforeRedirect
:
makeWebRequestEventRegistrar
(
"
onBeforeRedirect
"
)
onResponseStarted
:
makeWebRequestEventRegistrar
(
"
onResponseStarted
"
)
onErrorOccurred
:
makeWebRequestEventRegistrar
(
"
onErrorOccurred
"
)
onCompleted
:
makeWebRequestEventRegistrar
(
"
onCompleted
"
)
}
;
getAPI
(
context
)
{
return
{
webRequest
:
{
onBeforeRequest
:
makeWebRequestEventAPI
(
context
"
onBeforeRequest
"
this
)
onBeforeSendHeaders
:
makeWebRequestEventAPI
(
context
"
onBeforeSendHeaders
"
this
)
onSendHeaders
:
makeWebRequestEventAPI
(
context
"
onSendHeaders
"
this
)
onHeadersReceived
:
makeWebRequestEventAPI
(
context
"
onHeadersReceived
"
this
)
onAuthRequired
:
makeWebRequestEventAPI
(
context
"
onAuthRequired
"
this
)
onBeforeRedirect
:
makeWebRequestEventAPI
(
context
"
onBeforeRedirect
"
this
)
onResponseStarted
:
makeWebRequestEventAPI
(
context
"
onResponseStarted
"
this
)
onErrorOccurred
:
makeWebRequestEventAPI
(
context
"
onErrorOccurred
"
this
)
onCompleted
:
makeWebRequestEventAPI
(
context
"
onCompleted
"
this
)
getSecurityInfo
:
(
requestId
options
)
=
>
{
options
?
?
=
{
}
;
return
WebRequest
.
getSecurityInfo
(
{
id
:
requestId
policy
:
context
.
extension
.
policy
remoteTab
:
context
.
xulBrowser
.
frameLoader
.
remoteTab
options
}
)
;
}
handlerBehaviorChanged
:
(
)
=
>
{
let
timestamps
=
handlerBehaviorChangedTimeStampsMap
.
get
(
context
.
extension
.
id
)
;
const
now
=
Date
.
now
(
)
;
clearOldTimeStamps
(
timestamps
now
)
;
if
(
!
handlerBehaviorChangedCallAllowed
(
timestamps
)
)
{
context
.
extension
.
logger
.
warn
(
The
number
of
webRequest
.
handlerBehaviorChanged
calls
exceeds
the
limit
:
{
MAX_HANDLER_BEHAVIOR_CHANGED_CALLS_PER_10_MINUTES
}
calls
per
10
minutes
)
;
return
;
}
timestamps
.
push
(
now
)
;
ChromeUtils
.
clearResourceCache
(
false
)
;
}
}
}
;
}
}
;
