"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
BaseConduit
"
"
ConduitsChild
"
]
;
class
BaseConduit
{
constructor
(
subject
address
)
{
this
.
subject
=
subject
;
this
.
address
=
address
;
this
.
id
=
address
.
id
;
for
(
let
name
of
address
.
send
|
|
[
]
)
{
this
[
send
{
name
}
]
=
this
.
_send
.
bind
(
this
name
false
)
;
}
for
(
let
name
of
address
.
query
|
|
[
]
)
{
this
[
query
{
name
}
]
=
this
.
_send
.
bind
(
this
name
true
)
;
}
this
.
recv
=
new
Map
(
)
;
for
(
let
name
of
address
.
recv
|
|
[
]
)
{
let
method
=
this
.
subject
[
recv
{
name
}
]
;
if
(
!
method
)
{
throw
new
Error
(
recv
{
name
}
not
found
for
conduit
{
this
.
id
}
)
;
}
this
.
recv
.
set
(
name
method
.
bind
(
this
.
subject
)
)
;
}
}
_send
(
method
query
actor
data
)
{
if
(
query
)
{
return
actor
.
sendQuery
(
method
data
)
;
}
actor
.
sendAsyncMessage
(
method
data
)
;
}
async
_recv
(
name
arg
meta
)
{
let
method
=
this
.
recv
.
get
(
name
)
;
if
(
!
method
)
{
throw
new
Error
(
recv
{
name
}
not
found
for
conduit
{
this
.
id
}
)
;
}
try
{
return
await
method
(
arg
meta
)
;
}
catch
(
e
)
{
if
(
meta
.
query
)
{
return
Promise
.
reject
(
e
)
;
}
Cu
.
reportError
(
e
)
;
}
}
}
class
PointConduit
extends
BaseConduit
{
constructor
(
subject
address
actor
)
{
super
(
subject
address
)
;
this
.
actor
=
actor
;
this
.
actor
.
sendAsyncMessage
(
"
ConduitOpened
"
{
arg
:
address
}
)
;
}
_send
(
method
query
arg
=
{
}
)
{
if
(
!
this
.
actor
)
{
throw
new
Error
(
send
{
method
}
on
closed
conduit
{
this
.
id
}
)
;
}
let
sender
=
this
.
id
;
return
super
.
_send
(
method
query
this
.
actor
{
arg
query
sender
}
)
;
}
close
(
silent
=
false
)
{
let
{
actor
}
=
this
;
if
(
actor
)
{
this
.
actor
=
null
;
actor
.
conduits
.
delete
(
this
.
id
)
;
if
(
!
silent
)
{
actor
.
sendAsyncMessage
(
"
ConduitClosed
"
{
arg
:
this
.
id
}
)
;
}
}
}
}
class
ConduitsChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
conduits
=
new
Map
(
)
;
}
openConduit
(
subject
address
)
{
let
conduit
=
new
PointConduit
(
subject
address
this
)
;
this
.
conduits
.
set
(
conduit
.
id
conduit
)
;
return
conduit
;
}
receiveMessage
(
{
name
data
:
{
target
arg
query
sender
}
}
)
{
let
conduit
=
this
.
conduits
.
get
(
target
)
;
if
(
!
conduit
)
{
throw
new
Error
(
{
name
}
for
closed
conduit
{
target
}
:
{
uneval
(
arg
)
}
)
;
}
return
conduit
.
_recv
(
name
arg
{
sender
query
actor
:
this
}
)
;
}
willDestroy
(
)
{
for
(
let
conduit
of
this
.
conduits
.
values
(
)
)
{
conduit
.
close
(
true
)
;
}
this
.
conduits
.
clear
(
)
;
}
didDestroy
(
)
{
this
.
willDestroy
(
)
;
}
}
