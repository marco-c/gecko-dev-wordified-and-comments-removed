"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExtensionCommon
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
ConsoleAPI
:
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
MessageChannel
:
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
Schemas
:
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
SchemaRoot
:
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
styleSheetService
"
"
mozilla
.
org
/
content
/
style
-
sheet
-
service
;
1
"
"
nsIStyleSheetService
"
)
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
DefaultMap
DefaultWeakMap
ExtensionError
filterStack
getInnerWindowID
getUniqueId
getWinUtils
}
=
ExtensionUtils
;
function
getConsole
(
)
{
return
new
ConsoleAPI
(
{
maxLogLevelPref
:
"
extensions
.
webextensions
.
log
.
level
"
prefix
:
"
WebExtensions
"
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
getConsole
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
DELAYED_BG_STARTUP
"
"
extensions
.
webextensions
.
background
-
delayed
-
startup
"
)
;
var
ExtensionCommon
;
function
runSafeSyncWithoutClone
(
f
.
.
.
args
)
{
try
{
return
f
(
.
.
.
args
)
;
}
catch
(
e
)
{
dump
(
Extension
error
:
{
e
}
{
e
.
fileName
}
{
e
.
lineNumber
}
\
n
[
[
Exception
stack
\
n
{
filterStack
(
e
)
}
Current
stack
\
n
{
filterStack
(
Error
(
)
)
}
]
]
\
n
)
;
Cu
.
reportError
(
e
)
;
}
}
function
instanceOf
(
value
type
)
{
return
(
value
&
&
typeof
value
=
=
=
"
object
"
&
&
ChromeUtils
.
getClassName
(
value
)
=
=
=
type
)
;
}
function
normalizeTime
(
date
)
{
return
new
Date
(
(
typeof
date
=
=
"
string
"
&
&
/
^
\
d
+
/
.
test
(
date
)
)
?
parseInt
(
date
10
)
:
date
)
;
}
function
withHandlingUserInput
(
window
callable
)
{
let
handle
=
getWinUtils
(
window
)
.
setHandlingUserInput
(
true
)
;
try
{
return
callable
(
)
;
}
finally
{
handle
.
destruct
(
)
;
}
}
function
defineLazyGetter
(
object
prop
getter
)
{
let
redefine
=
(
obj
value
)
=
>
{
Object
.
defineProperty
(
obj
prop
{
enumerable
:
true
configurable
:
true
writable
:
true
value
}
)
;
return
value
;
}
;
Object
.
defineProperty
(
object
prop
{
enumerable
:
true
configurable
:
true
get
(
)
{
return
redefine
(
this
getter
.
call
(
this
)
)
;
}
set
(
value
)
{
redefine
(
this
value
)
;
}
}
)
;
}
function
checkLoadURL
(
url
principal
options
)
{
let
ssm
=
Services
.
scriptSecurityManager
;
let
flags
=
ssm
.
STANDARD
;
if
(
!
options
.
allowScript
)
{
flags
|
=
ssm
.
DISALLOW_SCRIPT
;
}
if
(
!
options
.
allowInheritsPrincipal
)
{
flags
|
=
ssm
.
DISALLOW_INHERIT_PRINCIPAL
;
}
if
(
options
.
dontReportErrors
)
{
flags
|
=
ssm
.
DONT_REPORT_ERRORS
;
}
try
{
ssm
.
checkLoadURIWithPrincipal
(
principal
Services
.
io
.
newURI
(
url
)
flags
)
;
}
catch
(
e
)
{
return
false
;
}
return
true
;
}
function
makeWidgetId
(
id
)
{
id
=
id
.
toLowerCase
(
)
;
return
id
.
replace
(
/
[
^
a
-
z0
-
9_
-
]
/
g
"
_
"
)
;
}
class
SpreadArgs
extends
Array
{
constructor
(
args
)
{
super
(
)
;
this
.
push
(
.
.
.
args
)
;
}
}
class
NoCloneSpreadArgs
{
constructor
(
args
)
{
this
.
unwrappedValues
=
args
;
}
[
Symbol
.
iterator
]
(
)
{
return
this
.
unwrappedValues
[
Symbol
.
iterator
]
(
)
;
}
}
const
LISTENERS
=
Symbol
(
"
listeners
"
)
;
const
ONCE_MAP
=
Symbol
(
"
onceMap
"
)
;
class
EventEmitter
{
constructor
(
)
{
this
[
LISTENERS
]
=
new
Map
(
)
;
this
[
ONCE_MAP
]
=
new
WeakMap
(
)
;
}
has
(
event
)
{
return
this
[
LISTENERS
]
.
has
(
event
)
;
}
on
(
event
listener
)
{
let
listeners
=
this
[
LISTENERS
]
.
get
(
event
)
;
if
(
!
listeners
)
{
listeners
=
new
Set
(
)
;
this
[
LISTENERS
]
.
set
(
event
listeners
)
;
}
listeners
.
add
(
listener
)
;
}
off
(
event
listener
)
{
let
set
=
this
[
LISTENERS
]
.
get
(
event
)
;
if
(
set
)
{
set
.
delete
(
listener
)
;
set
.
delete
(
this
[
ONCE_MAP
]
.
get
(
listener
)
)
;
if
(
!
set
.
size
)
{
this
[
LISTENERS
]
.
delete
(
event
)
;
}
}
}
once
(
event
listener
)
{
let
wrapper
=
(
.
.
.
args
)
=
>
{
this
.
off
(
event
wrapper
)
;
this
[
ONCE_MAP
]
.
delete
(
listener
)
;
return
listener
(
.
.
.
args
)
;
}
;
this
[
ONCE_MAP
]
.
set
(
listener
wrapper
)
;
this
.
on
(
event
wrapper
)
;
}
emit
(
event
.
.
.
args
)
{
let
listeners
=
this
[
LISTENERS
]
.
get
(
event
)
;
if
(
listeners
)
{
let
promises
=
[
]
;
for
(
let
listener
of
listeners
)
{
try
{
let
result
=
listener
(
event
.
.
.
args
)
;
if
(
result
!
=
=
undefined
)
{
promises
.
push
(
result
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
if
(
promises
.
length
)
{
return
Promise
.
all
(
promises
)
;
}
}
}
}
class
ExtensionAPI
extends
EventEmitter
{
constructor
(
extension
)
{
super
(
)
;
this
.
extension
=
extension
;
extension
.
once
(
"
shutdown
"
(
)
=
>
{
if
(
this
.
onShutdown
)
{
this
.
onShutdown
(
extension
.
shutdownReason
)
;
}
this
.
extension
=
null
;
}
)
;
}
destroy
(
)
{
}
onManifestEntry
(
entry
)
{
}
getAPI
(
context
)
{
throw
new
Error
(
"
Not
Implemented
"
)
;
}
}
class
InnerWindowReference
{
constructor
(
contentWindow
innerWindowID
)
{
this
.
contentWindow
=
contentWindow
;
this
.
innerWindowID
=
innerWindowID
;
this
.
needWindowIDCheck
=
false
;
contentWindow
.
addEventListener
(
"
pagehide
"
this
{
mozSystemGroup
:
true
}
false
)
;
contentWindow
.
addEventListener
(
"
pageshow
"
this
{
mozSystemGroup
:
true
}
false
)
;
}
get
(
)
{
if
(
!
this
.
needWindowIDCheck
|
|
getInnerWindowID
(
this
.
contentWindow
)
=
=
=
this
.
innerWindowID
)
{
return
this
.
contentWindow
;
}
return
null
;
}
invalidate
(
)
{
if
(
this
.
contentWindow
&
&
!
Cu
.
isDeadWrapper
(
this
.
contentWindow
)
)
{
this
.
contentWindow
.
removeEventListener
(
"
pagehide
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
contentWindow
.
removeEventListener
(
"
pageshow
"
this
{
mozSystemGroup
:
true
}
)
;
}
this
.
contentWindow
=
null
;
this
.
needWindowIDCheck
=
false
;
}
handleEvent
(
event
)
{
if
(
this
.
contentWindow
)
{
this
.
needWindowIDCheck
=
event
.
type
=
=
=
"
pagehide
"
;
}
else
{
event
.
currentTarget
.
removeEventListener
(
"
pagehide
"
this
{
mozSystemGroup
:
true
}
)
;
event
.
currentTarget
.
removeEventListener
(
"
pageshow
"
this
{
mozSystemGroup
:
true
}
)
;
}
}
}
class
BaseContext
{
constructor
(
envType
extension
)
{
this
.
envType
=
envType
;
this
.
onClose
=
new
Set
(
)
;
this
.
checkedLastError
=
false
;
this
.
_lastError
=
null
;
this
.
contextId
=
getUniqueId
(
)
;
this
.
unloaded
=
false
;
this
.
extension
=
extension
;
this
.
jsonSandbox
=
null
;
this
.
active
=
true
;
this
.
incognito
=
null
;
this
.
messageManager
=
null
;
this
.
contentWindow
=
null
;
this
.
innerWindowID
=
0
;
this
.
cloneScopeError
=
null
;
this
.
cloneScopePromise
=
null
;
}
get
Error
(
)
{
return
this
.
cloneScopeError
|
|
this
.
cloneScope
.
Error
;
}
get
Promise
(
)
{
return
this
.
cloneScopePromise
|
|
this
.
cloneScope
.
Promise
;
}
get
privateBrowsingAllowed
(
)
{
return
this
.
extension
.
privateBrowsingAllowed
;
}
canAccessWindow
(
window
)
{
return
this
.
extension
.
canAccessWindow
(
window
)
;
}
setContentWindow
(
contentWindow
)
{
if
(
!
this
.
canAccessWindow
(
contentWindow
)
)
{
throw
new
Error
(
"
BaseContext
attempted
to
load
when
extension
is
not
allowed
due
to
incognito
settings
.
"
)
;
}
this
.
innerWindowID
=
getInnerWindowID
(
contentWindow
)
;
this
.
messageManager
=
contentWindow
.
docShell
.
messageManager
;
if
(
this
.
incognito
=
=
null
)
{
this
.
incognito
=
PrivateBrowsingUtils
.
isContentWindowPrivate
(
contentWindow
)
;
}
MessageChannel
.
setupMessageManagers
(
[
this
.
messageManager
]
)
;
let
windowRef
=
new
InnerWindowReference
(
contentWindow
this
.
innerWindowID
)
;
Object
.
defineProperty
(
this
"
active
"
{
configurable
:
true
enumerable
:
true
get
:
(
)
=
>
windowRef
.
get
(
)
!
=
=
null
}
)
;
Object
.
defineProperty
(
this
"
contentWindow
"
{
configurable
:
true
enumerable
:
true
get
:
(
)
=
>
windowRef
.
get
(
)
}
)
;
this
.
callOnClose
(
{
close
:
(
)
=
>
{
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
windowRef
.
invalidate
(
)
;
windowRef
=
null
;
Object
.
defineProperty
(
this
"
contentWindow
"
{
value
:
null
}
)
;
Object
.
defineProperty
(
this
"
active
"
{
value
:
false
}
)
;
}
)
;
}
}
)
;
}
get
cloneScope
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
principal
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
runSafe
(
callback
.
.
.
args
)
{
return
this
.
applySafe
(
callback
args
)
;
}
runSafeWithoutClone
(
callback
.
.
.
args
)
{
return
this
.
applySafeWithoutClone
(
callback
args
)
;
}
applySafe
(
callback
args
caller
)
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
"
context
.
runSafe
called
after
context
unloaded
"
caller
)
;
}
else
if
(
!
this
.
active
)
{
Cu
.
reportError
(
"
context
.
runSafe
called
while
context
is
inactive
"
caller
)
;
}
else
{
try
{
let
{
cloneScope
}
=
this
;
args
=
args
.
map
(
arg
=
>
Cu
.
cloneInto
(
arg
cloneScope
)
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
this
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
return
this
.
applySafeWithoutClone
(
callback
args
caller
)
;
}
}
applySafeWithoutClone
(
callback
args
caller
)
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
"
context
.
runSafeWithoutClone
called
after
context
unloaded
"
caller
)
;
}
else
if
(
!
this
.
active
)
{
Cu
.
reportError
(
"
context
.
runSafeWithoutClone
called
while
context
is
inactive
"
caller
)
;
}
else
{
try
{
return
Reflect
.
apply
(
callback
null
args
)
;
}
catch
(
e
)
{
dump
(
Extension
error
:
{
e
}
{
e
.
fileName
}
{
e
.
lineNumber
}
\
n
[
[
Exception
stack
\
n
{
filterStack
(
e
)
}
Current
stack
\
n
{
filterStack
(
Error
(
)
)
}
]
]
\
n
)
;
Cu
.
reportError
(
e
)
;
}
}
}
checkLoadURL
(
url
options
=
{
}
)
{
if
(
url
.
startsWith
(
this
.
extension
.
baseURL
)
)
{
return
true
;
}
return
checkLoadURL
(
url
this
.
principal
options
)
;
}
jsonStringify
(
.
.
.
args
)
{
if
(
!
this
.
jsonSandbox
)
{
this
.
jsonSandbox
=
Cu
.
Sandbox
(
this
.
principal
{
sameZoneAs
:
this
.
cloneScope
wantXrays
:
false
}
)
;
}
return
Cu
.
waiveXrays
(
this
.
jsonSandbox
.
JSON
)
.
stringify
(
.
.
.
args
)
;
}
callOnClose
(
obj
)
{
this
.
onClose
.
add
(
obj
)
;
}
forgetOnClose
(
obj
)
{
this
.
onClose
.
delete
(
obj
)
;
}
sendMessage
(
target
messageName
data
options
=
{
}
)
{
options
.
recipient
=
Object
.
assign
(
{
extensionId
:
this
.
extension
.
id
}
options
.
recipient
)
;
options
.
sender
=
options
.
sender
|
|
{
}
;
options
.
sender
.
extensionId
=
this
.
extension
.
id
;
options
.
sender
.
contextId
=
this
.
contextId
;
return
MessageChannel
.
sendMessage
(
target
messageName
data
options
)
;
}
get
lastError
(
)
{
this
.
checkedLastError
=
true
;
return
this
.
_lastError
;
}
set
lastError
(
val
)
{
this
.
checkedLastError
=
false
;
this
.
_lastError
=
val
;
}
normalizeError
(
error
caller
)
{
if
(
error
instanceof
this
.
Error
)
{
return
error
;
}
let
message
fileName
;
if
(
error
&
&
typeof
error
=
=
=
"
object
"
)
{
const
isPlain
=
ChromeUtils
.
getClassName
(
error
)
=
=
=
"
Object
"
;
if
(
isPlain
&
&
error
.
mozWebExtLocation
)
{
caller
=
error
.
mozWebExtLocation
;
}
if
(
isPlain
&
&
caller
&
&
(
error
.
mozWebExtLocation
|
|
!
error
.
fileName
)
)
{
caller
=
Cu
.
cloneInto
(
caller
this
.
cloneScope
)
;
return
ChromeUtils
.
createError
(
error
.
message
caller
)
;
}
if
(
isPlain
|
|
error
instanceof
ExtensionError
|
|
this
.
principal
.
subsumes
(
Cu
.
getObjectPrincipal
(
error
)
)
)
{
message
=
error
.
message
;
fileName
=
error
.
fileName
;
}
}
if
(
!
message
)
{
Cu
.
reportError
(
error
)
;
message
=
"
An
unexpected
error
occurred
"
;
}
return
new
this
.
Error
(
message
fileName
)
;
}
withLastError
(
error
caller
callback
)
{
this
.
lastError
=
this
.
normalizeError
(
error
)
;
try
{
return
callback
(
)
;
}
finally
{
if
(
!
this
.
checkedLastError
)
{
Cu
.
reportError
(
Unchecked
lastError
value
:
{
this
.
lastError
}
caller
)
;
}
this
.
lastError
=
null
;
}
}
getCaller
(
)
{
return
ChromeUtils
.
getCallerLocation
(
this
.
principal
)
;
}
wrapPromise
(
promise
callback
=
null
)
{
let
caller
=
this
.
getCaller
(
)
;
let
applySafe
=
this
.
applySafe
.
bind
(
this
)
;
if
(
Cu
.
getGlobalForObject
(
promise
)
=
=
=
this
.
cloneScope
)
{
applySafe
=
this
.
applySafeWithoutClone
.
bind
(
this
)
;
}
if
(
callback
)
{
promise
.
then
(
args
=
>
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
Promise
resolved
after
context
unloaded
\
n
caller
)
;
}
else
if
(
!
this
.
active
)
{
Cu
.
reportError
(
Promise
resolved
while
context
is
inactive
\
n
caller
)
;
}
else
if
(
args
instanceof
NoCloneSpreadArgs
)
{
this
.
applySafeWithoutClone
(
callback
args
.
unwrappedValues
caller
)
;
}
else
if
(
args
instanceof
SpreadArgs
)
{
applySafe
(
callback
args
caller
)
;
}
else
{
applySafe
(
callback
[
args
]
caller
)
;
}
}
error
=
>
{
this
.
withLastError
(
error
caller
(
)
=
>
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
Promise
rejected
after
context
unloaded
\
n
caller
)
;
}
else
if
(
!
this
.
active
)
{
Cu
.
reportError
(
Promise
rejected
while
context
is
inactive
\
n
caller
)
;
}
else
{
this
.
applySafeWithoutClone
(
callback
[
]
caller
)
;
}
}
)
;
}
)
;
}
else
{
return
new
this
.
Promise
(
(
resolve
reject
)
=
>
{
promise
.
then
(
value
=
>
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
Promise
resolved
after
context
unloaded
\
n
caller
)
;
}
else
if
(
!
this
.
active
)
{
Cu
.
reportError
(
Promise
resolved
while
context
is
inactive
\
n
caller
)
;
}
else
if
(
value
instanceof
NoCloneSpreadArgs
)
{
let
values
=
value
.
unwrappedValues
;
this
.
applySafeWithoutClone
(
resolve
values
.
length
=
=
1
?
[
values
[
0
]
]
:
[
values
]
caller
)
;
}
else
if
(
value
instanceof
SpreadArgs
)
{
applySafe
(
resolve
value
.
length
=
=
1
?
value
:
[
value
]
caller
)
;
}
else
{
applySafe
(
resolve
[
value
]
caller
)
;
}
}
value
=
>
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
Promise
rejected
after
context
unloaded
:
{
value
&
&
value
.
message
}
\
n
caller
)
;
}
else
if
(
!
this
.
active
)
{
Cu
.
reportError
(
Promise
rejected
while
context
is
inactive
:
{
value
&
&
value
.
message
}
\
n
caller
)
;
}
else
{
this
.
applySafeWithoutClone
(
reject
[
this
.
normalizeError
(
value
caller
)
]
caller
)
;
}
}
)
;
}
)
;
}
}
unload
(
)
{
this
.
unloaded
=
true
;
MessageChannel
.
abortResponses
(
{
extensionId
:
this
.
extension
.
id
contextId
:
this
.
contextId
}
)
;
for
(
let
obj
of
this
.
onClose
)
{
obj
.
close
(
)
;
}
this
.
onClose
.
clear
(
)
;
}
close
(
)
{
this
.
unload
(
)
;
}
}
class
SchemaAPIInterface
{
callFunction
(
args
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
callFunctionNoReturn
(
args
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
callAsyncFunction
(
args
callback
requireUserInput
=
false
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getProperty
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
setProperty
(
value
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
addListener
(
listener
args
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
hasListener
(
listener
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
removeListener
(
listener
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
revoke
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
class
LocalAPIImplementation
extends
SchemaAPIInterface
{
constructor
(
pathObj
name
context
)
{
super
(
)
;
this
.
pathObj
=
pathObj
;
this
.
name
=
name
;
this
.
context
=
context
;
}
revoke
(
)
{
if
(
this
.
pathObj
[
this
.
name
]
[
Schemas
.
REVOKE
]
)
{
this
.
pathObj
[
this
.
name
]
[
Schemas
.
REVOKE
]
(
)
;
}
this
.
pathObj
=
null
;
this
.
name
=
null
;
this
.
context
=
null
;
}
callFunction
(
args
)
{
try
{
return
this
.
pathObj
[
this
.
name
]
(
.
.
.
args
)
;
}
catch
(
e
)
{
throw
this
.
context
.
normalizeError
(
e
)
;
}
}
callFunctionNoReturn
(
args
)
{
try
{
this
.
pathObj
[
this
.
name
]
(
.
.
.
args
)
;
}
catch
(
e
)
{
throw
this
.
context
.
normalizeError
(
e
)
;
}
}
callAsyncFunction
(
args
callback
requireUserInput
)
{
let
promise
;
try
{
if
(
requireUserInput
)
{
if
(
!
getWinUtils
(
this
.
context
.
contentWindow
)
.
isHandlingUserInput
)
{
throw
new
ExtensionError
(
{
this
.
name
}
may
only
be
called
from
a
user
input
handler
)
;
}
}
promise
=
this
.
pathObj
[
this
.
name
]
(
.
.
.
args
)
|
|
Promise
.
resolve
(
)
;
}
catch
(
e
)
{
promise
=
Promise
.
reject
(
e
)
;
}
return
this
.
context
.
wrapPromise
(
promise
callback
)
;
}
getProperty
(
)
{
return
this
.
pathObj
[
this
.
name
]
;
}
setProperty
(
value
)
{
this
.
pathObj
[
this
.
name
]
=
value
;
}
addListener
(
listener
args
)
{
try
{
this
.
pathObj
[
this
.
name
]
.
addListener
.
call
(
null
listener
.
.
.
args
)
;
}
catch
(
e
)
{
throw
this
.
context
.
normalizeError
(
e
)
;
}
}
hasListener
(
listener
)
{
return
this
.
pathObj
[
this
.
name
]
.
hasListener
.
call
(
null
listener
)
;
}
removeListener
(
listener
)
{
this
.
pathObj
[
this
.
name
]
.
removeListener
.
call
(
null
listener
)
;
}
}
function
deepCopy
(
dest
source
)
{
for
(
let
prop
in
source
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
source
prop
)
;
if
(
typeof
(
desc
.
value
)
=
=
"
object
"
)
{
if
(
!
(
prop
in
dest
)
)
{
dest
[
prop
]
=
{
}
;
}
deepCopy
(
dest
[
prop
]
source
[
prop
]
)
;
}
else
{
Object
.
defineProperty
(
dest
prop
desc
)
;
}
}
}
function
getChild
(
map
key
)
{
let
child
=
map
.
children
.
get
(
key
)
;
if
(
!
child
)
{
child
=
{
modules
:
new
Set
(
)
children
:
new
Map
(
)
}
;
map
.
children
.
set
(
key
child
)
;
}
return
child
;
}
function
getPath
(
map
path
)
{
for
(
let
key
of
path
)
{
map
=
getChild
(
map
key
)
;
}
return
map
;
}
function
mergePaths
(
dest
source
)
{
for
(
let
name
of
source
.
modules
)
{
dest
.
modules
.
add
(
name
)
;
}
for
(
let
[
name
child
]
of
source
.
children
.
entries
(
)
)
{
mergePaths
(
getChild
(
dest
name
)
child
)
;
}
}
class
CanOfAPIs
{
constructor
(
context
apiManager
root
)
{
this
.
context
=
context
;
this
.
scopeName
=
context
.
envType
;
this
.
apiManager
=
apiManager
;
this
.
root
=
root
;
this
.
apiPaths
=
new
Map
(
)
;
this
.
apis
=
new
Map
(
)
;
}
loadAPI
(
name
)
{
if
(
this
.
apis
.
has
(
name
)
)
{
return
;
}
let
{
extension
}
=
this
.
context
;
let
api
=
this
.
apiManager
.
getAPI
(
name
extension
this
.
scopeName
)
;
if
(
!
api
)
{
return
;
}
this
.
apis
.
set
(
name
api
)
;
deepCopy
(
this
.
root
api
.
getAPI
(
this
.
context
)
)
;
}
async
asyncLoadAPI
(
name
)
{
if
(
this
.
apis
.
has
(
name
)
)
{
return
;
}
let
{
extension
}
=
this
.
context
;
if
(
!
Schemas
.
checkPermissions
(
name
extension
)
)
{
return
;
}
let
api
=
await
this
.
apiManager
.
asyncGetAPI
(
name
extension
this
.
scopeName
)
;
if
(
this
.
apis
.
has
(
name
)
)
{
return
;
}
this
.
apis
.
set
(
name
api
)
;
deepCopy
(
this
.
root
api
.
getAPI
(
this
.
context
)
)
;
}
findAPIPath
(
path
)
{
if
(
this
.
apiPaths
.
has
(
path
)
)
{
return
this
.
apiPaths
.
get
(
path
)
;
}
let
obj
=
this
.
root
;
let
modules
=
this
.
apiManager
.
modulePaths
;
let
parts
=
path
.
split
(
"
.
"
)
;
for
(
let
[
i
key
]
of
parts
.
entries
(
)
)
{
if
(
!
obj
)
{
return
;
}
modules
=
getChild
(
modules
key
)
;
for
(
let
name
of
modules
.
modules
)
{
if
(
!
this
.
apis
.
has
(
name
)
)
{
this
.
loadAPI
(
name
)
;
}
}
if
(
!
(
key
in
obj
)
&
&
i
<
parts
.
length
-
1
)
{
obj
[
key
]
=
{
}
;
}
obj
=
obj
[
key
]
;
}
this
.
apiPaths
.
set
(
path
obj
)
;
return
obj
;
}
async
asyncFindAPIPath
(
path
)
{
if
(
this
.
apiPaths
.
has
(
path
)
)
{
return
this
.
apiPaths
.
get
(
path
)
;
}
let
obj
=
this
.
root
;
let
modules
=
this
.
apiManager
.
modulePaths
;
let
parts
=
path
.
split
(
"
.
"
)
;
for
(
let
[
i
key
]
of
parts
.
entries
(
)
)
{
if
(
!
obj
)
{
return
;
}
modules
=
getChild
(
modules
key
)
;
for
(
let
name
of
modules
.
modules
)
{
if
(
!
this
.
apis
.
has
(
name
)
)
{
await
this
.
asyncLoadAPI
(
name
)
;
}
}
if
(
!
(
key
in
obj
)
&
&
i
<
parts
.
length
-
1
)
{
obj
[
key
]
=
{
}
;
}
if
(
typeof
obj
[
key
]
=
=
=
"
function
"
)
{
obj
=
obj
[
key
]
.
bind
(
obj
)
;
}
else
{
obj
=
obj
[
key
]
;
}
}
this
.
apiPaths
.
set
(
path
obj
)
;
return
obj
;
}
}
class
SchemaAPIManager
extends
EventEmitter
{
constructor
(
processType
schema
)
{
super
(
)
;
this
.
processType
=
processType
;
this
.
global
=
null
;
if
(
schema
)
{
this
.
schema
=
schema
;
}
this
.
modules
=
new
Map
(
)
;
this
.
modulePaths
=
{
children
:
new
Map
(
)
modules
:
new
Set
(
)
}
;
this
.
manifestKeys
=
new
Map
(
)
;
this
.
eventModules
=
new
DefaultMap
(
(
)
=
>
new
Set
(
)
)
;
this
.
_modulesJSONLoaded
=
false
;
this
.
schemaURLs
=
new
Map
(
)
;
this
.
apis
=
new
DefaultWeakMap
(
(
)
=
>
new
Map
(
)
)
;
this
.
_scriptScopes
=
[
]
;
}
onStartup
(
extension
)
{
let
promises
=
[
]
;
for
(
let
apiName
of
this
.
eventModules
.
get
(
"
startup
"
)
)
{
promises
.
push
(
extension
.
apiManager
.
asyncGetAPI
(
apiName
extension
)
.
then
(
api
=
>
{
if
(
api
)
{
api
.
onStartup
(
)
;
}
}
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
async
loadModuleJSON
(
urls
)
{
let
promises
=
urls
.
map
(
url
=
>
fetch
(
url
)
.
then
(
resp
=
>
resp
.
json
(
)
)
)
;
return
this
.
initModuleJSON
(
await
Promise
.
all
(
promises
)
)
;
}
initModuleJSON
(
blobs
)
{
for
(
let
json
of
blobs
)
{
this
.
registerModules
(
json
)
;
}
this
.
_modulesJSONLoaded
=
true
;
return
new
StructuredCloneHolder
(
{
modules
:
this
.
modules
modulePaths
:
this
.
modulePaths
manifestKeys
:
this
.
manifestKeys
eventModules
:
this
.
eventModules
schemaURLs
:
this
.
schemaURLs
}
)
;
}
initModuleData
(
moduleData
)
{
if
(
!
this
.
_modulesJSONLoaded
)
{
let
data
=
moduleData
.
deserialize
(
{
}
true
)
;
this
.
modules
=
data
.
modules
;
this
.
modulePaths
=
data
.
modulePaths
;
this
.
manifestKeys
=
data
.
manifestKeys
;
this
.
eventModules
=
new
DefaultMap
(
(
)
=
>
new
Set
(
)
data
.
eventModules
)
;
this
.
schemaURLs
=
data
.
schemaURLs
;
}
this
.
_modulesJSONLoaded
=
true
;
}
registerModules
(
obj
)
{
for
(
let
[
name
details
]
of
Object
.
entries
(
obj
)
)
{
details
.
namespaceName
=
name
;
if
(
this
.
modules
.
has
(
name
)
)
{
throw
new
Error
(
Module
'
{
name
}
'
already
registered
)
;
}
this
.
modules
.
set
(
name
details
)
;
if
(
details
.
schema
)
{
let
content
=
(
details
.
scopes
&
&
(
details
.
scopes
.
includes
(
"
content_parent
"
)
|
|
details
.
scopes
.
includes
(
"
content_child
"
)
)
)
;
this
.
schemaURLs
.
set
(
details
.
schema
{
content
}
)
;
}
for
(
let
event
of
details
.
events
|
|
[
]
)
{
this
.
eventModules
.
get
(
event
)
.
add
(
name
)
;
}
for
(
let
key
of
details
.
manifest
|
|
[
]
)
{
if
(
this
.
manifestKeys
.
has
(
key
)
)
{
throw
new
Error
(
Manifest
key
'
{
key
}
'
already
registered
by
'
{
this
.
manifestKeys
.
get
(
key
)
}
'
)
;
}
this
.
manifestKeys
.
set
(
key
name
)
;
}
for
(
let
path
of
details
.
paths
|
|
[
]
)
{
getPath
(
this
.
modulePaths
path
)
.
modules
.
add
(
name
)
;
}
}
}
emitManifestEntry
(
extension
entry
)
{
let
apiName
=
this
.
manifestKeys
.
get
(
entry
)
;
if
(
apiName
)
{
let
api
=
extension
.
apiManager
.
getAPI
(
apiName
extension
)
;
return
api
.
onManifestEntry
(
entry
)
;
}
}
async
asyncEmitManifestEntry
(
extension
entry
)
{
let
apiName
=
this
.
manifestKeys
.
get
(
entry
)
;
if
(
apiName
)
{
let
api
=
await
extension
.
apiManager
.
asyncGetAPI
(
apiName
extension
)
;
return
api
.
onManifestEntry
(
entry
)
;
}
}
getAPI
(
name
extension
scope
=
null
)
{
if
(
!
this
.
_checkGetAPI
(
name
extension
scope
)
)
{
return
;
}
let
apis
=
this
.
apis
.
get
(
extension
)
;
if
(
apis
.
has
(
name
)
)
{
return
apis
.
get
(
name
)
;
}
let
module
=
this
.
loadModule
(
name
)
;
let
api
=
new
module
(
extension
)
;
apis
.
set
(
name
api
)
;
return
api
;
}
async
asyncGetAPI
(
name
extension
scope
=
null
)
{
if
(
!
this
.
_checkGetAPI
(
name
extension
scope
)
)
{
return
;
}
let
apis
=
this
.
apis
.
get
(
extension
)
;
if
(
apis
.
has
(
name
)
)
{
return
apis
.
get
(
name
)
;
}
let
module
=
await
this
.
asyncLoadModule
(
name
)
;
if
(
apis
.
has
(
name
)
)
{
return
apis
.
get
(
name
)
;
}
let
api
=
new
module
(
extension
)
;
apis
.
set
(
name
api
)
;
return
api
;
}
loadModule
(
name
)
{
let
module
=
this
.
modules
.
get
(
name
)
;
if
(
module
.
loaded
)
{
return
this
.
global
[
name
]
;
}
this
.
_checkLoadModule
(
module
name
)
;
this
.
initGlobal
(
)
;
Services
.
scriptloader
.
loadSubScript
(
module
.
url
this
.
global
)
;
module
.
loaded
=
true
;
return
this
.
global
[
name
]
;
}
asyncLoadModule
(
name
)
{
let
module
=
this
.
modules
.
get
(
name
)
;
if
(
module
.
loaded
)
{
return
Promise
.
resolve
(
this
.
global
[
name
]
)
;
}
if
(
module
.
asyncLoaded
)
{
return
module
.
asyncLoaded
;
}
this
.
_checkLoadModule
(
module
name
)
;
module
.
asyncLoaded
=
ChromeUtils
.
compileScript
(
module
.
url
)
.
then
(
script
=
>
{
this
.
initGlobal
(
)
;
script
.
executeInGlobal
(
this
.
global
)
;
module
.
loaded
=
true
;
return
this
.
global
[
name
]
;
}
)
;
return
module
.
asyncLoaded
;
}
getModule
(
name
)
{
return
this
.
modules
.
get
(
name
)
;
}
_checkGetAPI
(
name
extension
scope
=
null
)
{
let
module
=
this
.
getModule
(
name
)
;
if
(
module
.
permissions
&
&
!
module
.
permissions
.
some
(
perm
=
>
extension
.
hasPermission
(
perm
)
)
)
{
return
false
;
}
if
(
!
scope
)
{
return
true
;
}
if
(
!
module
.
scopes
.
includes
(
scope
)
)
{
return
false
;
}
if
(
!
Schemas
.
checkPermissions
(
module
.
namespaceName
extension
)
)
{
return
false
;
}
return
true
;
}
_checkLoadModule
(
module
name
)
{
if
(
!
module
)
{
throw
new
Error
(
Module
'
{
name
}
'
does
not
exist
)
;
}
if
(
module
.
asyncLoaded
)
{
throw
new
Error
(
Module
'
{
name
}
'
currently
being
lazily
loaded
)
;
}
if
(
this
.
global
&
&
this
.
global
[
name
]
)
{
throw
new
Error
(
Module
'
{
name
}
'
conflicts
with
existing
global
property
)
;
}
}
_createExtGlobal
(
)
{
let
global
=
Cu
.
Sandbox
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
{
wantXrays
:
false
wantGlobalProperties
:
[
"
ChromeUtils
"
]
sandboxName
:
Namespace
of
ext
-
*
.
js
scripts
for
{
this
.
processType
}
(
from
:
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
)
}
)
;
Object
.
assign
(
global
{
Cc
ChromeWorker
Ci
Cr
Cu
ExtensionAPI
ExtensionCommon
MatchGlob
MatchPattern
MatchPatternSet
StructuredCloneHolder
XPCOMUtils
extensions
:
this
global
}
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
global
)
;
XPCOMUtils
.
defineLazyGetter
(
global
"
console
"
getConsole
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
global
{
ExtensionUtils
:
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
XPCOMUtils
:
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
}
)
;
return
global
;
}
initGlobal
(
)
{
if
(
!
this
.
global
)
{
this
.
global
=
this
.
_createExtGlobal
(
)
;
}
}
loadScript
(
scriptUrl
)
{
let
scope
=
Cu
.
createObjectIn
(
this
.
global
)
;
Services
.
scriptloader
.
loadSubScript
(
scriptUrl
scope
)
;
this
.
_scriptScopes
.
push
(
scope
)
;
}
}
class
LazyAPIManager
extends
SchemaAPIManager
{
constructor
(
processType
moduleData
schemaURLs
)
{
super
(
processType
)
;
this
.
initialized
=
false
;
this
.
initModuleData
(
moduleData
)
;
this
.
schemaURLs
=
schemaURLs
;
}
}
defineLazyGetter
(
LazyAPIManager
.
prototype
"
schema
"
function
(
)
{
let
root
=
new
SchemaRoot
(
Schemas
.
rootSchema
this
.
schemaURLs
)
;
root
.
parseSchemas
(
)
;
return
root
;
}
)
;
class
MultiAPIManager
extends
SchemaAPIManager
{
constructor
(
processType
children
)
{
super
(
processType
)
;
this
.
initialized
=
false
;
this
.
children
=
children
;
}
async
lazyInit
(
)
{
if
(
!
this
.
initialized
)
{
this
.
initialized
=
true
;
for
(
let
child
of
this
.
children
)
{
if
(
child
.
lazyInit
)
{
let
res
=
child
.
lazyInit
(
)
;
if
(
res
&
&
typeof
res
.
then
=
=
=
"
function
"
)
{
await
res
;
}
}
mergePaths
(
this
.
modulePaths
child
.
modulePaths
)
;
}
}
}
onStartup
(
extension
)
{
return
Promise
.
all
(
this
.
children
.
map
(
child
=
>
child
.
onStartup
(
extension
)
)
)
;
}
getModule
(
name
)
{
for
(
let
child
of
this
.
children
)
{
if
(
child
.
modules
.
has
(
name
)
)
{
return
child
.
modules
.
get
(
name
)
;
}
}
}
loadModule
(
name
)
{
for
(
let
child
of
this
.
children
)
{
if
(
child
.
modules
.
has
(
name
)
)
{
return
child
.
loadModule
(
name
)
;
}
}
}
asyncLoadModule
(
name
)
{
for
(
let
child
of
this
.
children
)
{
if
(
child
.
modules
.
has
(
name
)
)
{
return
child
.
asyncLoadModule
(
name
)
;
}
}
}
}
defineLazyGetter
(
MultiAPIManager
.
prototype
"
schema
"
function
(
)
{
let
bases
=
this
.
children
.
map
(
child
=
>
child
.
schema
)
;
if
(
bases
[
bases
.
length
-
1
]
=
=
=
Schemas
)
{
bases
.
pop
(
)
;
}
if
(
bases
.
length
=
=
=
1
)
{
bases
=
bases
[
0
]
;
}
return
new
SchemaRoot
(
bases
new
Map
(
)
)
;
}
)
;
function
LocaleData
(
data
)
{
this
.
defaultLocale
=
data
.
defaultLocale
;
this
.
selectedLocale
=
data
.
selectedLocale
;
this
.
locales
=
data
.
locales
|
|
new
Map
(
)
;
this
.
warnedMissingKeys
=
new
Set
(
)
;
this
.
messages
=
data
.
messages
|
|
new
Map
(
)
;
if
(
data
.
builtinMessages
)
{
this
.
messages
.
set
(
this
.
BUILTIN
data
.
builtinMessages
)
;
}
}
LocaleData
.
prototype
=
{
serialize
(
)
{
return
{
defaultLocale
:
this
.
defaultLocale
selectedLocale
:
this
.
selectedLocale
messages
:
this
.
messages
locales
:
this
.
locales
}
;
}
BUILTIN
:
"
BUILTIN_MESSAGES
"
has
(
locale
)
{
return
this
.
messages
.
has
(
locale
)
;
}
localizeMessage
(
message
substitutions
=
[
]
options
=
{
}
)
{
let
defaultOptions
=
{
defaultValue
:
"
"
cloneScope
:
null
}
;
let
locales
=
this
.
availableLocales
;
if
(
options
.
locale
)
{
locales
=
new
Set
(
[
this
.
BUILTIN
options
.
locale
this
.
defaultLocale
]
.
filter
(
locale
=
>
this
.
messages
.
has
(
locale
)
)
)
;
}
options
=
Object
.
assign
(
defaultOptions
options
)
;
message
=
message
.
toLowerCase
(
)
;
for
(
let
locale
of
locales
)
{
let
messages
=
this
.
messages
.
get
(
locale
)
;
if
(
messages
.
has
(
message
)
)
{
let
str
=
messages
.
get
(
message
)
;
if
(
!
str
.
includes
(
"
"
)
)
{
return
str
;
}
if
(
!
Array
.
isArray
(
substitutions
)
)
{
substitutions
=
[
substitutions
]
;
}
let
replacer
=
(
matched
index
dollarSigns
)
=
>
{
if
(
index
)
{
index
=
parseInt
(
index
10
)
-
1
;
return
index
in
substitutions
?
substitutions
[
index
]
:
"
"
;
}
return
dollarSigns
;
}
;
return
str
.
replace
(
/
\
(
?
:
(
[
1
-
9
]
\
d
*
)
|
(
\
+
)
)
/
g
replacer
)
;
}
}
if
(
message
=
=
"
ui_locale
"
)
{
return
this
.
uiLocale
;
}
else
if
(
message
.
startsWith
(
"
bidi_
"
)
)
{
let
rtl
=
Services
.
locale
.
isAppLocaleRTL
;
if
(
message
=
=
"
bidi_dir
"
)
{
return
rtl
?
"
rtl
"
:
"
ltr
"
;
}
else
if
(
message
=
=
"
bidi_reversed_dir
"
)
{
return
rtl
?
"
ltr
"
:
"
rtl
"
;
}
else
if
(
message
=
=
"
bidi_start_edge
"
)
{
return
rtl
?
"
right
"
:
"
left
"
;
}
else
if
(
message
=
=
"
bidi_end_edge
"
)
{
return
rtl
?
"
left
"
:
"
right
"
;
}
}
if
(
!
this
.
warnedMissingKeys
.
has
(
message
)
)
{
let
error
=
Unknown
localization
message
{
message
}
;
if
(
options
.
cloneScope
)
{
error
=
new
options
.
cloneScope
.
Error
(
error
)
;
}
Cu
.
reportError
(
error
)
;
this
.
warnedMissingKeys
.
add
(
message
)
;
}
return
options
.
defaultValue
;
}
localize
(
str
locale
=
this
.
selectedLocale
)
{
if
(
!
str
)
{
return
str
;
}
return
str
.
replace
(
/
__MSG_
(
[
A
-
Za
-
z0
-
9
_
]
+
?
)
__
/
g
(
matched
message
)
=
>
{
return
this
.
localizeMessage
(
message
[
]
{
locale
defaultValue
:
matched
}
)
;
}
)
;
}
addLocale
(
locale
messages
extension
)
{
let
result
=
new
Map
(
)
;
let
isPlainObject
=
obj
=
>
(
obj
&
&
typeof
obj
=
=
=
"
object
"
&
&
ChromeUtils
.
getClassName
(
obj
)
=
=
=
"
Object
"
)
;
if
(
!
isPlainObject
(
messages
)
)
{
extension
.
packagingError
(
Invalid
locale
data
for
{
locale
}
)
;
return
result
;
}
for
(
let
key
of
Object
.
keys
(
messages
)
)
{
let
msg
=
messages
[
key
]
;
if
(
!
isPlainObject
(
msg
)
|
|
typeof
(
msg
.
message
)
!
=
"
string
"
)
{
extension
.
packagingError
(
Invalid
locale
message
data
for
{
locale
}
message
{
JSON
.
stringify
(
key
)
}
)
;
continue
;
}
let
placeholders
=
new
Map
(
)
;
if
(
isPlainObject
(
msg
.
placeholders
)
)
{
for
(
let
key
of
Object
.
keys
(
msg
.
placeholders
)
)
{
placeholders
.
set
(
key
.
toLowerCase
(
)
msg
.
placeholders
[
key
]
)
;
}
}
let
replacer
=
(
match
name
)
=
>
{
let
replacement
=
placeholders
.
get
(
name
.
toLowerCase
(
)
)
;
if
(
isPlainObject
(
replacement
)
&
&
"
content
"
in
replacement
)
{
return
replacement
.
content
;
}
return
"
"
;
}
;
let
value
=
msg
.
message
.
replace
(
/
\
(
[
A
-
Za
-
z0
-
9
_
]
+
)
\
/
g
replacer
)
;
result
.
set
(
key
.
toLowerCase
(
)
value
)
;
}
this
.
messages
.
set
(
locale
result
)
;
return
result
;
}
get
acceptLanguages
(
)
{
let
result
=
Services
.
prefs
.
getComplexValue
(
"
intl
.
accept_languages
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
return
result
.
split
(
/
\
s
*
\
s
*
/
g
)
;
}
get
uiLocale
(
)
{
return
Services
.
locale
.
appLocaleAsBCP47
;
}
}
;
defineLazyGetter
(
LocaleData
.
prototype
"
availableLocales
"
function
(
)
{
return
new
Set
(
[
this
.
BUILTIN
this
.
selectedLocale
this
.
defaultLocale
]
.
filter
(
locale
=
>
this
.
messages
.
has
(
locale
)
)
)
;
}
)
;
class
EventManager
{
constructor
(
params
)
{
if
(
arguments
.
length
>
1
)
{
[
this
.
context
this
.
name
this
.
register
]
=
arguments
;
this
.
inputHandling
=
false
;
this
.
persistent
=
null
;
}
else
{
let
{
context
name
register
inputHandling
=
false
persistent
=
null
}
=
params
;
this
.
context
=
context
;
this
.
name
=
name
;
this
.
register
=
register
;
this
.
inputHandling
=
inputHandling
;
this
.
persistent
=
persistent
;
}
if
(
!
DELAYED_BG_STARTUP
)
{
this
.
persistent
=
null
;
}
this
.
unregister
=
new
Map
(
)
;
this
.
remove
=
new
Map
(
)
;
if
(
this
.
persistent
)
{
if
(
this
.
context
.
viewType
!
=
=
"
background
"
)
{
this
.
persistent
=
null
;
}
if
(
AppConstants
.
DEBUG
)
{
if
(
this
.
context
.
envType
!
=
=
"
addon_parent
"
)
{
throw
new
Error
(
"
Persistent
event
managers
can
only
be
created
for
addon_parent
"
)
;
}
if
(
!
this
.
persistent
.
module
|
|
!
this
.
persistent
.
event
)
{
throw
new
Error
(
"
Persistent
event
manager
must
specify
module
and
event
"
)
;
}
}
}
}
static
_initPersistentListeners
(
extension
)
{
if
(
extension
.
persistentListeners
)
{
return
;
}
let
listeners
=
new
DefaultMap
(
(
)
=
>
new
DefaultMap
(
(
)
=
>
new
Map
(
)
)
)
;
extension
.
persistentListeners
=
listeners
;
let
{
persistentListeners
}
=
extension
.
startupData
;
if
(
!
persistentListeners
)
{
return
;
}
for
(
let
[
module
entry
]
of
Object
.
entries
(
persistentListeners
)
)
{
for
(
let
[
event
paramlists
]
of
Object
.
entries
(
entry
)
)
{
for
(
let
paramlist
of
paramlists
)
{
let
key
=
uneval
(
paramlist
)
;
listeners
.
get
(
module
)
.
get
(
event
)
.
set
(
key
{
params
:
paramlist
}
)
;
}
}
}
}
static
_writePersistentListeners
(
extension
)
{
let
startupListeners
=
{
}
;
for
(
let
[
module
moduleEntry
]
of
extension
.
persistentListeners
)
{
startupListeners
[
module
]
=
{
}
;
for
(
let
[
event
eventEntry
]
of
moduleEntry
)
{
startupListeners
[
module
]
[
event
]
=
Array
.
from
(
eventEntry
.
values
(
)
listener
=
>
listener
.
params
)
;
}
}
extension
.
startupData
.
persistentListeners
=
startupListeners
;
extension
.
saveStartupData
(
)
;
}
static
primeListeners
(
extension
)
{
EventManager
.
_initPersistentListeners
(
extension
)
;
for
(
let
[
module
moduleEntry
]
of
extension
.
persistentListeners
)
{
let
api
=
extension
.
apiManager
.
getAPI
(
module
extension
"
addon_parent
"
)
;
for
(
let
[
event
eventEntry
]
of
moduleEntry
)
{
for
(
let
listener
of
eventEntry
.
values
(
)
)
{
let
primed
=
{
pendingEvents
:
[
]
}
;
listener
.
primed
=
primed
;
let
bgStartupPromise
=
new
Promise
(
r
=
>
extension
.
once
(
"
startup
"
r
)
)
;
let
wakeup
=
(
)
=
>
{
extension
.
emit
(
"
background
-
page
-
event
"
)
;
return
bgStartupPromise
;
}
;
let
fireEvent
=
(
.
.
.
args
)
=
>
new
Promise
(
(
resolve
reject
)
=
>
{
primed
.
pendingEvents
.
push
(
{
args
resolve
reject
}
)
;
extension
.
emit
(
"
background
-
page
-
event
"
)
;
}
)
;
let
fire
=
{
wakeup
sync
:
fireEvent
async
:
fireEvent
}
;
let
{
unregister
convert
}
=
api
.
primeListener
(
extension
event
fire
listener
.
params
)
;
Object
.
assign
(
primed
{
unregister
convert
}
)
;
}
}
}
}
static
clearOnePrimedListener
(
extension
module
event
args
=
[
]
)
{
let
key
=
uneval
(
args
)
;
let
listener
=
extension
.
persistentListeners
.
get
(
module
)
.
get
(
event
)
.
get
(
key
)
;
if
(
listener
.
primed
)
{
listener
.
primed
=
null
;
}
}
static
clearPrimedListeners
(
extension
)
{
for
(
let
[
module
moduleEntry
]
of
extension
.
persistentListeners
)
{
for
(
let
[
event
listeners
]
of
moduleEntry
)
{
for
(
let
[
key
listener
]
of
listeners
)
{
let
{
primed
}
=
listener
;
if
(
!
primed
)
{
continue
;
}
for
(
let
evt
of
primed
.
pendingEvents
)
{
evt
.
reject
(
new
Error
(
"
listener
not
re
-
registered
"
)
)
;
}
EventManager
.
clearPersistentListener
(
extension
module
event
key
)
;
primed
.
unregister
(
)
;
}
}
}
}
static
savePersistentListener
(
extension
module
event
args
=
[
]
)
{
EventManager
.
_initPersistentListeners
(
extension
)
;
let
key
=
uneval
(
args
)
;
extension
.
persistentListeners
.
get
(
module
)
.
get
(
event
)
.
set
(
key
{
params
:
args
}
)
;
EventManager
.
_writePersistentListeners
(
extension
)
;
}
static
clearPersistentListener
(
extension
module
event
key
=
uneval
(
[
]
)
)
{
let
listeners
=
extension
.
persistentListeners
.
get
(
module
)
.
get
(
event
)
;
listeners
.
delete
(
key
)
;
if
(
listeners
.
size
=
=
0
)
{
let
moduleEntry
=
extension
.
persistentListeners
.
get
(
module
)
;
moduleEntry
.
delete
(
event
)
;
if
(
moduleEntry
.
size
=
=
0
)
{
extension
.
persistentListeners
.
delete
(
module
)
;
}
}
EventManager
.
_writePersistentListeners
(
extension
)
;
}
addListener
(
callback
.
.
.
args
)
{
if
(
this
.
unregister
.
has
(
callback
)
)
{
return
;
}
let
shouldFire
=
(
)
=
>
{
if
(
this
.
context
.
unloaded
)
{
dump
(
{
this
.
name
}
event
fired
after
context
unloaded
.
\
n
)
;
}
else
if
(
!
this
.
context
.
active
)
{
dump
(
{
this
.
name
}
event
fired
while
context
is
inactive
.
\
n
)
;
}
else
if
(
this
.
unregister
.
has
(
callback
)
)
{
return
true
;
}
return
false
;
}
;
let
fire
=
{
sync
:
(
.
.
.
args
)
=
>
{
if
(
shouldFire
(
)
)
{
return
this
.
context
.
applySafe
(
callback
args
)
;
}
}
async
:
(
.
.
.
args
)
=
>
{
return
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
if
(
shouldFire
(
)
)
{
return
this
.
context
.
applySafe
(
callback
args
)
;
}
}
)
;
}
raw
:
(
.
.
.
args
)
=
>
{
if
(
!
shouldFire
(
)
)
{
throw
new
Error
(
"
Called
raw
(
)
on
unloaded
/
inactive
context
"
)
;
}
return
Reflect
.
apply
(
callback
null
args
)
;
}
asyncWithoutClone
:
(
.
.
.
args
)
=
>
{
return
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
if
(
shouldFire
(
)
)
{
return
this
.
context
.
applySafeWithoutClone
(
callback
args
)
;
}
}
)
;
}
}
;
let
{
extension
}
=
this
.
context
;
let
unregister
=
null
;
let
recordStartupData
=
false
;
if
(
this
.
persistent
)
{
recordStartupData
=
true
;
let
{
module
event
}
=
this
.
persistent
;
let
key
=
uneval
(
args
)
;
EventManager
.
_initPersistentListeners
(
extension
)
;
let
listener
=
extension
.
persistentListeners
.
get
(
module
)
.
get
(
event
)
.
get
(
key
)
;
if
(
listener
)
{
let
{
primed
}
=
listener
;
if
(
primed
)
{
listener
.
primed
=
null
;
primed
.
convert
(
fire
this
.
context
)
;
unregister
=
primed
.
unregister
;
for
(
let
evt
of
primed
.
pendingEvents
)
{
evt
.
resolve
(
fire
.
async
(
.
.
.
evt
.
args
)
)
;
}
}
recordStartupData
=
false
;
this
.
remove
.
set
(
callback
(
)
=
>
{
EventManager
.
clearPersistentListener
(
extension
module
event
uneval
(
args
)
)
;
}
)
;
}
}
if
(
!
unregister
)
{
unregister
=
this
.
register
(
fire
.
.
.
args
)
;
}
this
.
unregister
.
set
(
callback
unregister
)
;
this
.
context
.
callOnClose
(
this
)
;
if
(
recordStartupData
)
{
let
{
module
event
}
=
this
.
persistent
;
EventManager
.
savePersistentListener
(
extension
module
event
args
)
;
this
.
remove
.
set
(
callback
(
)
=
>
{
EventManager
.
clearPersistentListener
(
extension
module
event
uneval
(
args
)
)
;
}
)
;
}
}
removeListener
(
callback
clearPersistentListener
=
true
)
{
if
(
!
this
.
unregister
.
has
(
callback
)
)
{
return
;
}
let
unregister
=
this
.
unregister
.
get
(
callback
)
;
this
.
unregister
.
delete
(
callback
)
;
try
{
unregister
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
clearPersistentListener
&
&
this
.
remove
.
has
(
callback
)
)
{
let
cleanup
=
this
.
remove
.
get
(
callback
)
;
this
.
remove
.
delete
(
callback
)
;
cleanup
(
)
;
}
if
(
this
.
unregister
.
size
=
=
0
)
{
this
.
context
.
forgetOnClose
(
this
)
;
}
}
hasListener
(
callback
)
{
return
this
.
unregister
.
has
(
callback
)
;
}
revoke
(
)
{
for
(
let
callback
of
this
.
unregister
.
keys
(
)
)
{
this
.
removeListener
(
callback
false
)
;
}
}
close
(
)
{
this
.
revoke
(
)
;
}
api
(
)
{
return
{
addListener
:
(
.
.
.
args
)
=
>
this
.
addListener
(
.
.
.
args
)
removeListener
:
(
.
.
.
args
)
=
>
this
.
removeListener
(
.
.
.
args
)
hasListener
:
(
.
.
.
args
)
=
>
this
.
hasListener
(
.
.
.
args
)
setUserInput
:
this
.
inputHandling
[
Schemas
.
REVOKE
]
:
(
)
=
>
this
.
revoke
(
)
}
;
}
}
function
ignoreEvent
(
context
name
)
{
return
{
addListener
:
function
(
callback
)
{
let
id
=
context
.
extension
.
id
;
let
frame
=
Components
.
stack
.
caller
;
let
msg
=
In
add
-
on
{
id
}
attempting
to
use
listener
"
{
name
}
"
which
is
unimplemented
.
;
let
scriptError
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
scriptError
.
init
(
msg
frame
.
filename
null
frame
.
lineNumber
frame
.
columnNumber
Ci
.
nsIScriptError
.
warningFlag
"
content
javascript
"
)
;
Services
.
console
.
logMessage
(
scriptError
)
;
}
removeListener
:
function
(
callback
)
{
}
hasListener
:
function
(
callback
)
{
}
}
;
}
const
stylesheetMap
=
new
DefaultMap
(
url
=
>
{
let
uri
=
Services
.
io
.
newURI
(
url
)
;
return
styleSheetService
.
preloadSheet
(
uri
styleSheetService
.
AGENT_SHEET
)
;
}
)
;
ExtensionCommon
=
{
BaseContext
CanOfAPIs
EventManager
ExtensionAPI
EventEmitter
LocalAPIImplementation
LocaleData
NoCloneSpreadArgs
SchemaAPIInterface
SchemaAPIManager
SpreadArgs
checkLoadURL
defineLazyGetter
getConsole
ignoreEvent
instanceOf
makeWidgetId
normalizeTime
runSafeSyncWithoutClone
stylesheetMap
withHandlingUserInput
MultiAPIManager
LazyAPIManager
}
;
