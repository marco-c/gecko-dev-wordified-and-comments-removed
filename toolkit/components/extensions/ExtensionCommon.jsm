"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionCommon
"
]
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ConsoleAPI
:
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
MessageChannel
:
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
Schemas
:
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
styleSheetService
"
"
mozilla
.
org
/
content
/
style
-
sheet
-
service
;
1
"
"
nsIStyleSheetService
"
)
;
const
global
=
Cu
.
getGlobalForObject
(
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
DefaultMap
DefaultWeakMap
EventEmitter
ExtensionError
defineLazyGetter
filterStack
getConsole
getInnerWindowID
getUniqueId
getWinUtils
}
=
ExtensionUtils
;
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
getConsole
)
;
var
ExtensionCommon
;
class
SpreadArgs
extends
Array
{
constructor
(
args
)
{
super
(
)
;
this
.
push
(
.
.
.
args
)
;
}
}
class
NoCloneSpreadArgs
{
constructor
(
args
)
{
this
.
unwrappedValues
=
args
;
}
[
Symbol
.
iterator
]
(
)
{
return
this
.
unwrappedValues
[
Symbol
.
iterator
]
(
)
;
}
}
class
ExtensionAPI
extends
ExtensionUtils
.
EventEmitter
{
constructor
(
extension
)
{
super
(
)
;
this
.
extension
=
extension
;
extension
.
once
(
"
shutdown
"
(
)
=
>
{
if
(
this
.
onShutdown
)
{
this
.
onShutdown
(
extension
.
shutdownReason
)
;
}
this
.
extension
=
null
;
}
)
;
}
destroy
(
)
{
}
onManifestEntry
(
entry
)
{
}
getAPI
(
context
)
{
throw
new
Error
(
"
Not
Implemented
"
)
;
}
}
var
ExtensionAPIs
=
{
apis
:
new
Map
(
)
load
(
apiName
)
{
let
api
=
this
.
apis
.
get
(
apiName
)
;
if
(
api
.
loadPromise
)
{
return
api
.
loadPromise
;
}
let
{
script
schema
}
=
api
;
let
addonId
=
{
apiName
}
experiments
.
addons
.
mozilla
.
org
;
api
.
sandbox
=
Cu
.
Sandbox
(
global
{
wantXrays
:
false
sandboxName
:
script
addonId
metadata
:
{
addonID
:
addonId
}
}
)
;
api
.
sandbox
.
ExtensionAPI
=
ExtensionAPI
;
XPCOMUtils
.
defineLazyGetter
(
api
.
sandbox
"
console
"
(
)
=
>
{
return
new
ConsoleAPI
(
{
prefix
:
addonId
}
)
;
}
)
;
Services
.
scriptloader
.
loadSubScript
(
script
api
.
sandbox
"
UTF
-
8
"
)
;
api
.
loadPromise
=
Schemas
.
load
(
schema
)
.
then
(
(
)
=
>
{
let
API
=
Cu
.
evalInSandbox
(
"
API
"
api
.
sandbox
)
;
API
.
prototype
.
namespace
=
apiName
;
return
API
;
}
)
;
return
api
.
loadPromise
;
}
unload
(
apiName
)
{
let
api
=
this
.
apis
.
get
(
apiName
)
;
let
{
schema
}
=
api
;
Schemas
.
unload
(
schema
)
;
Cu
.
nukeSandbox
(
api
.
sandbox
)
;
api
.
sandbox
=
null
;
api
.
loadPromise
=
null
;
}
register
(
namespace
schema
script
)
{
if
(
this
.
apis
.
has
(
namespace
)
)
{
throw
new
Error
(
API
namespace
already
exists
:
{
namespace
}
)
;
}
this
.
apis
.
set
(
namespace
{
schema
script
}
)
;
}
unregister
(
namespace
)
{
if
(
!
this
.
apis
.
has
(
namespace
)
)
{
throw
new
Error
(
API
namespace
does
not
exist
:
{
namespace
}
)
;
}
this
.
apis
.
delete
(
namespace
)
;
}
}
;
class
BaseContext
{
constructor
(
envType
extension
)
{
this
.
envType
=
envType
;
this
.
onClose
=
new
Set
(
)
;
this
.
checkedLastError
=
false
;
this
.
_lastError
=
null
;
this
.
contextId
=
getUniqueId
(
)
;
this
.
unloaded
=
false
;
this
.
extension
=
extension
;
this
.
jsonSandbox
=
null
;
this
.
active
=
true
;
this
.
incognito
=
null
;
this
.
messageManager
=
null
;
this
.
docShell
=
null
;
this
.
contentWindow
=
null
;
this
.
innerWindowID
=
0
;
}
setContentWindow
(
contentWindow
)
{
let
{
document
}
=
contentWindow
;
let
{
docShell
}
=
document
;
this
.
innerWindowID
=
getInnerWindowID
(
contentWindow
)
;
this
.
messageManager
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
if
(
this
.
incognito
=
=
null
)
{
this
.
incognito
=
PrivateBrowsingUtils
.
isContentWindowPrivate
(
contentWindow
)
;
}
MessageChannel
.
setupMessageManagers
(
[
this
.
messageManager
]
)
;
let
onPageShow
=
event
=
>
{
if
(
!
event
|
|
event
.
target
=
=
=
document
)
{
this
.
docShell
=
docShell
;
this
.
contentWindow
=
contentWindow
;
this
.
active
=
true
;
}
}
;
let
onPageHide
=
event
=
>
{
if
(
!
event
|
|
event
.
target
=
=
=
document
)
{
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
this
.
docShell
=
null
;
this
.
contentWindow
=
null
;
this
.
active
=
false
;
}
)
;
}
}
;
onPageShow
(
)
;
contentWindow
.
addEventListener
(
"
pagehide
"
onPageHide
true
)
;
contentWindow
.
addEventListener
(
"
pageshow
"
onPageShow
true
)
;
this
.
callOnClose
(
{
close
:
(
)
=
>
{
onPageHide
(
)
;
if
(
this
.
active
)
{
contentWindow
.
removeEventListener
(
"
pagehide
"
onPageHide
true
)
;
contentWindow
.
removeEventListener
(
"
pageshow
"
onPageShow
true
)
;
}
}
}
)
;
}
get
cloneScope
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
principal
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
runSafe
(
callback
.
.
.
args
)
{
return
this
.
applySafe
(
callback
args
)
;
}
runSafeWithoutClone
(
callback
.
.
.
args
)
{
return
this
.
applySafeWithoutClone
(
callback
args
)
;
}
applySafe
(
callback
args
)
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
"
context
.
runSafe
called
after
context
unloaded
"
)
;
}
else
if
(
!
this
.
active
)
{
Cu
.
reportError
(
"
context
.
runSafe
called
while
context
is
inactive
"
)
;
}
else
{
try
{
let
{
cloneScope
}
=
this
;
args
=
args
.
map
(
arg
=
>
Cu
.
cloneInto
(
arg
cloneScope
)
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
this
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
return
this
.
applySafeWithoutClone
(
callback
args
)
;
}
}
applySafeWithoutClone
(
callback
args
)
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
"
context
.
runSafeWithoutClone
called
after
context
unloaded
"
)
;
}
else
if
(
!
this
.
active
)
{
Cu
.
reportError
(
"
context
.
runSafeWithoutClone
called
while
context
is
inactive
"
)
;
}
else
{
try
{
return
Reflect
.
apply
(
callback
null
args
)
;
}
catch
(
e
)
{
dump
(
Extension
error
:
{
e
}
{
e
.
fileName
}
{
e
.
lineNumber
}
\
n
[
[
Exception
stack
\
n
{
filterStack
(
e
)
}
Current
stack
\
n
{
filterStack
(
Error
(
)
)
}
]
]
\
n
)
;
Cu
.
reportError
(
e
)
;
}
}
}
checkLoadURL
(
url
options
=
{
}
)
{
if
(
url
.
startsWith
(
this
.
extension
.
baseURL
)
)
{
return
true
;
}
return
ExtensionUtils
.
checkLoadURL
(
url
this
.
principal
options
)
;
}
jsonStringify
(
.
.
.
args
)
{
if
(
!
this
.
jsonSandbox
)
{
this
.
jsonSandbox
=
Cu
.
Sandbox
(
this
.
principal
{
sameZoneAs
:
this
.
cloneScope
wantXrays
:
false
}
)
;
}
return
Cu
.
waiveXrays
(
this
.
jsonSandbox
.
JSON
)
.
stringify
(
.
.
.
args
)
;
}
callOnClose
(
obj
)
{
this
.
onClose
.
add
(
obj
)
;
}
forgetOnClose
(
obj
)
{
this
.
onClose
.
delete
(
obj
)
;
}
sendMessage
(
target
messageName
data
options
=
{
}
)
{
options
.
recipient
=
Object
.
assign
(
{
extensionId
:
this
.
extension
.
id
}
options
.
recipient
)
;
options
.
sender
=
options
.
sender
|
|
{
}
;
options
.
sender
.
extensionId
=
this
.
extension
.
id
;
options
.
sender
.
contextId
=
this
.
contextId
;
return
MessageChannel
.
sendMessage
(
target
messageName
data
options
)
;
}
get
lastError
(
)
{
this
.
checkedLastError
=
true
;
return
this
.
_lastError
;
}
set
lastError
(
val
)
{
this
.
checkedLastError
=
false
;
this
.
_lastError
=
val
;
}
normalizeError
(
error
)
{
if
(
error
instanceof
this
.
cloneScope
.
Error
)
{
return
error
;
}
let
message
fileName
;
if
(
error
&
&
typeof
error
=
=
=
"
object
"
&
&
(
ChromeUtils
.
getClassName
(
error
)
=
=
=
"
Object
"
|
|
error
instanceof
ExtensionError
|
|
this
.
principal
.
subsumes
(
Cu
.
getObjectPrincipal
(
error
)
)
)
)
{
message
=
error
.
message
;
fileName
=
error
.
fileName
;
}
else
{
Cu
.
reportError
(
error
)
;
}
message
=
message
|
|
"
An
unexpected
error
occurred
"
;
return
new
this
.
cloneScope
.
Error
(
message
fileName
)
;
}
withLastError
(
error
callback
)
{
this
.
lastError
=
this
.
normalizeError
(
error
)
;
try
{
return
callback
(
)
;
}
finally
{
if
(
!
this
.
checkedLastError
)
{
Cu
.
reportError
(
Unchecked
lastError
value
:
{
this
.
lastError
}
)
;
}
this
.
lastError
=
null
;
}
}
wrapPromise
(
promise
callback
=
null
)
{
let
applySafe
=
this
.
applySafe
.
bind
(
this
)
;
if
(
Cu
.
getGlobalForObject
(
promise
)
=
=
=
this
.
cloneScope
)
{
applySafe
=
this
.
applySafeWithoutClone
.
bind
(
this
)
;
}
if
(
callback
)
{
promise
.
then
(
args
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
resolved
after
context
unloaded
\
n
)
;
}
else
if
(
!
this
.
active
)
{
dump
(
Promise
resolved
while
context
is
inactive
\
n
)
;
}
else
if
(
args
instanceof
NoCloneSpreadArgs
)
{
this
.
applySafeWithoutClone
(
callback
args
.
unwrappedValues
)
;
}
else
if
(
args
instanceof
SpreadArgs
)
{
applySafe
(
callback
args
)
;
}
else
{
applySafe
(
callback
[
args
]
)
;
}
}
error
=
>
{
this
.
withLastError
(
error
(
)
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
rejected
after
context
unloaded
\
n
)
;
}
else
if
(
!
this
.
active
)
{
dump
(
Promise
rejected
while
context
is
inactive
\
n
)
;
}
else
{
this
.
applySafeWithoutClone
(
callback
[
]
)
;
}
}
)
;
}
)
;
}
else
{
return
new
this
.
cloneScope
.
Promise
(
(
resolve
reject
)
=
>
{
promise
.
then
(
value
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
resolved
after
context
unloaded
\
n
)
;
}
else
if
(
!
this
.
active
)
{
dump
(
Promise
resolved
while
context
is
inactive
\
n
)
;
}
else
if
(
value
instanceof
NoCloneSpreadArgs
)
{
let
values
=
value
.
unwrappedValues
;
this
.
applySafeWithoutClone
(
resolve
values
.
length
=
=
1
?
[
values
[
0
]
]
:
[
values
]
)
;
}
else
if
(
value
instanceof
SpreadArgs
)
{
applySafe
(
resolve
value
.
length
=
=
1
?
value
:
[
value
]
)
;
}
else
{
applySafe
(
resolve
[
value
]
)
;
}
}
value
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
rejected
after
context
unloaded
:
{
value
&
&
value
.
message
}
\
n
)
;
}
else
if
(
!
this
.
active
)
{
dump
(
Promise
rejected
while
context
is
inactive
:
{
value
&
&
value
.
message
}
\
n
)
;
}
else
{
this
.
applySafeWithoutClone
(
reject
[
this
.
normalizeError
(
value
)
]
)
;
}
}
)
;
}
)
;
}
}
unload
(
)
{
this
.
unloaded
=
true
;
MessageChannel
.
abortResponses
(
{
extensionId
:
this
.
extension
.
id
contextId
:
this
.
contextId
}
)
;
for
(
let
obj
of
this
.
onClose
)
{
obj
.
close
(
)
;
}
}
close
(
)
{
this
.
unload
(
)
;
}
}
class
SchemaAPIInterface
{
callFunction
(
args
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
callFunctionNoReturn
(
args
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
callAsyncFunction
(
args
callback
requireUserInput
=
false
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getProperty
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
setProperty
(
value
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
addListener
(
listener
args
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
hasListener
(
listener
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
removeListener
(
listener
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
revoke
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
class
LocalAPIImplementation
extends
SchemaAPIInterface
{
constructor
(
pathObj
name
context
)
{
super
(
)
;
this
.
pathObj
=
pathObj
;
this
.
name
=
name
;
this
.
context
=
context
;
}
revoke
(
)
{
if
(
this
.
pathObj
[
this
.
name
]
[
Schemas
.
REVOKE
]
)
{
this
.
pathObj
[
this
.
name
]
[
Schemas
.
REVOKE
]
(
)
;
}
this
.
pathObj
=
null
;
this
.
name
=
null
;
this
.
context
=
null
;
}
callFunction
(
args
)
{
return
this
.
pathObj
[
this
.
name
]
(
.
.
.
args
)
;
}
callFunctionNoReturn
(
args
)
{
this
.
pathObj
[
this
.
name
]
(
.
.
.
args
)
;
}
callAsyncFunction
(
args
callback
requireUserInput
)
{
let
promise
;
try
{
if
(
requireUserInput
)
{
if
(
!
getWinUtils
(
this
.
context
.
contentWindow
)
.
isHandlingUserInput
)
{
throw
new
ExtensionError
(
{
this
.
name
}
may
only
be
called
from
a
user
input
handler
)
;
}
}
promise
=
this
.
pathObj
[
this
.
name
]
(
.
.
.
args
)
|
|
Promise
.
resolve
(
)
;
}
catch
(
e
)
{
promise
=
Promise
.
reject
(
e
)
;
}
return
this
.
context
.
wrapPromise
(
promise
callback
)
;
}
getProperty
(
)
{
return
this
.
pathObj
[
this
.
name
]
;
}
setProperty
(
value
)
{
this
.
pathObj
[
this
.
name
]
=
value
;
}
addListener
(
listener
args
)
{
try
{
this
.
pathObj
[
this
.
name
]
.
addListener
.
call
(
null
listener
.
.
.
args
)
;
}
catch
(
e
)
{
throw
this
.
context
.
normalizeError
(
e
)
;
}
}
hasListener
(
listener
)
{
return
this
.
pathObj
[
this
.
name
]
.
hasListener
.
call
(
null
listener
)
;
}
removeListener
(
listener
)
{
this
.
pathObj
[
this
.
name
]
.
removeListener
.
call
(
null
listener
)
;
}
}
function
deepCopy
(
dest
source
)
{
for
(
let
prop
in
source
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
source
prop
)
;
if
(
typeof
(
desc
.
value
)
=
=
"
object
"
)
{
if
(
!
(
prop
in
dest
)
)
{
dest
[
prop
]
=
{
}
;
}
deepCopy
(
dest
[
prop
]
source
[
prop
]
)
;
}
else
{
Object
.
defineProperty
(
dest
prop
desc
)
;
}
}
}
function
getChild
(
map
key
)
{
let
child
=
map
.
children
.
get
(
key
)
;
if
(
!
child
)
{
child
=
{
modules
:
new
Set
(
)
children
:
new
Map
(
)
}
;
map
.
children
.
set
(
key
child
)
;
}
return
child
;
}
function
getPath
(
map
path
)
{
for
(
let
key
of
path
)
{
map
=
getChild
(
map
key
)
;
}
return
map
;
}
class
CanOfAPIs
{
constructor
(
context
apiManager
root
)
{
this
.
context
=
context
;
this
.
scopeName
=
context
.
envType
;
this
.
apiManager
=
apiManager
;
this
.
root
=
root
;
this
.
apiPaths
=
new
Map
(
)
;
this
.
apis
=
new
Map
(
)
;
}
loadAPI
(
name
)
{
if
(
this
.
apis
.
has
(
name
)
)
{
return
;
}
let
{
extension
}
=
this
.
context
;
let
api
=
this
.
apiManager
.
getAPI
(
name
extension
this
.
scopeName
)
;
if
(
!
api
)
{
return
;
}
this
.
apis
.
set
(
name
api
)
;
deepCopy
(
this
.
root
api
.
getAPI
(
this
.
context
)
)
;
}
async
asyncLoadAPI
(
name
)
{
if
(
this
.
apis
.
has
(
name
)
)
{
return
;
}
let
{
extension
}
=
this
.
context
;
if
(
!
Schemas
.
checkPermissions
(
name
extension
)
)
{
return
;
}
let
api
=
await
this
.
apiManager
.
asyncGetAPI
(
name
extension
this
.
scopeName
)
;
if
(
this
.
apis
.
has
(
name
)
)
{
return
;
}
this
.
apis
.
set
(
name
api
)
;
deepCopy
(
this
.
root
api
.
getAPI
(
this
.
context
)
)
;
}
findAPIPath
(
path
)
{
if
(
this
.
apiPaths
.
has
(
path
)
)
{
return
this
.
apiPaths
.
get
(
path
)
;
}
let
obj
=
this
.
root
;
let
modules
=
this
.
apiManager
.
modulePaths
;
for
(
let
key
of
path
.
split
(
"
.
"
)
)
{
if
(
!
obj
)
{
return
;
}
modules
=
getChild
(
modules
key
)
;
for
(
let
name
of
modules
.
modules
)
{
if
(
!
this
.
apis
.
has
(
name
)
)
{
this
.
loadAPI
(
name
)
;
}
}
obj
=
obj
[
key
]
;
}
this
.
apiPaths
.
set
(
path
obj
)
;
return
obj
;
}
async
asyncFindAPIPath
(
path
)
{
if
(
this
.
apiPaths
.
has
(
path
)
)
{
return
this
.
apiPaths
.
get
(
path
)
;
}
let
obj
=
this
.
root
;
let
modules
=
this
.
apiManager
.
modulePaths
;
for
(
let
key
of
path
.
split
(
"
.
"
)
)
{
if
(
!
obj
)
{
return
;
}
modules
=
getChild
(
modules
key
)
;
for
(
let
name
of
modules
.
modules
)
{
if
(
!
this
.
apis
.
has
(
name
)
)
{
await
this
.
asyncLoadAPI
(
name
)
;
}
}
if
(
typeof
obj
[
key
]
=
=
=
"
function
"
)
{
obj
=
obj
[
key
]
.
bind
(
obj
)
;
}
else
{
obj
=
obj
[
key
]
;
}
}
this
.
apiPaths
.
set
(
path
obj
)
;
return
obj
;
}
}
class
SchemaAPIManager
extends
EventEmitter
{
constructor
(
processType
schema
)
{
super
(
)
;
this
.
processType
=
processType
;
this
.
global
=
null
;
this
.
schema
=
schema
;
this
.
modules
=
new
Map
(
)
;
this
.
modulePaths
=
{
children
:
new
Map
(
)
modules
:
new
Set
(
)
}
;
this
.
manifestKeys
=
new
Map
(
)
;
this
.
eventModules
=
new
DefaultMap
(
(
)
=
>
new
Set
(
)
)
;
this
.
_modulesJSONLoaded
=
false
;
this
.
schemaURLs
=
new
Map
(
)
;
this
.
apis
=
new
DefaultWeakMap
(
(
)
=
>
new
Map
(
)
)
;
this
.
_scriptScopes
=
[
]
;
}
onStartup
(
extension
)
{
let
promises
=
[
]
;
for
(
let
apiName
of
this
.
eventModules
.
get
(
"
startup
"
)
)
{
promises
.
push
(
this
.
asyncGetAPI
(
apiName
extension
)
.
then
(
api
=
>
{
if
(
api
)
{
api
.
onStartup
(
)
;
}
}
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
async
loadModuleJSON
(
urls
)
{
function
fetchJSON
(
url
)
{
return
fetch
(
url
)
.
then
(
resp
=
>
resp
.
json
(
)
)
;
}
for
(
let
json
of
await
Promise
.
all
(
urls
.
map
(
fetchJSON
)
)
)
{
this
.
registerModules
(
json
)
;
}
this
.
_modulesJSONLoaded
=
true
;
return
new
StructuredCloneHolder
(
{
modules
:
this
.
modules
modulePaths
:
this
.
modulePaths
manifestKeys
:
this
.
manifestKeys
eventModules
:
this
.
eventModules
schemaURLs
:
this
.
schemaURLs
}
)
;
}
initModuleData
(
moduleData
)
{
if
(
!
this
.
_modulesJSONLoaded
)
{
let
data
=
moduleData
.
deserialize
(
{
}
)
;
this
.
modules
=
data
.
modules
;
this
.
modulePaths
=
data
.
modulePaths
;
this
.
manifestKeys
=
data
.
manifestKeys
;
this
.
eventModules
=
new
DefaultMap
(
(
)
=
>
new
Set
(
)
data
.
eventModules
)
;
this
.
schemaURLs
=
data
.
schemaURLs
;
}
this
.
_modulesJSONLoaded
=
true
;
}
registerModules
(
obj
)
{
for
(
let
[
name
details
]
of
Object
.
entries
(
obj
)
)
{
details
.
namespaceName
=
name
;
if
(
this
.
modules
.
has
(
name
)
)
{
throw
new
Error
(
Module
'
{
name
}
'
already
registered
)
;
}
this
.
modules
.
set
(
name
details
)
;
if
(
details
.
schema
)
{
let
content
=
(
details
.
scopes
&
&
(
details
.
scopes
.
includes
(
"
content_parent
"
)
|
|
details
.
scopes
.
includes
(
"
content_child
"
)
)
)
;
this
.
schemaURLs
.
set
(
details
.
schema
{
content
}
)
;
}
for
(
let
event
of
details
.
events
|
|
[
]
)
{
this
.
eventModules
.
get
(
event
)
.
add
(
name
)
;
}
for
(
let
key
of
details
.
manifest
|
|
[
]
)
{
if
(
this
.
manifestKeys
.
has
(
key
)
)
{
throw
new
Error
(
Manifest
key
'
{
key
}
'
already
registered
by
'
{
this
.
manifestKeys
.
get
(
key
)
}
'
)
;
}
this
.
manifestKeys
.
set
(
key
name
)
;
}
for
(
let
path
of
details
.
paths
|
|
[
]
)
{
getPath
(
this
.
modulePaths
path
)
.
modules
.
add
(
name
)
;
}
}
}
emitManifestEntry
(
extension
entry
)
{
let
apiName
=
this
.
manifestKeys
.
get
(
entry
)
;
if
(
apiName
)
{
let
api
=
this
.
getAPI
(
apiName
extension
)
;
return
api
.
onManifestEntry
(
entry
)
;
}
}
async
asyncEmitManifestEntry
(
extension
entry
)
{
let
apiName
=
this
.
manifestKeys
.
get
(
entry
)
;
if
(
apiName
)
{
let
api
=
await
this
.
asyncGetAPI
(
apiName
extension
)
;
return
api
.
onManifestEntry
(
entry
)
;
}
}
getAPI
(
name
extension
scope
=
null
)
{
if
(
!
this
.
_checkGetAPI
(
name
extension
scope
)
)
{
return
;
}
let
apis
=
this
.
apis
.
get
(
extension
)
;
if
(
apis
.
has
(
name
)
)
{
return
apis
.
get
(
name
)
;
}
let
module
=
this
.
loadModule
(
name
)
;
let
api
=
new
module
(
extension
)
;
apis
.
set
(
name
api
)
;
return
api
;
}
async
asyncGetAPI
(
name
extension
scope
=
null
)
{
if
(
!
this
.
_checkGetAPI
(
name
extension
scope
)
)
{
return
;
}
let
apis
=
this
.
apis
.
get
(
extension
)
;
if
(
apis
.
has
(
name
)
)
{
return
apis
.
get
(
name
)
;
}
let
module
=
await
this
.
asyncLoadModule
(
name
)
;
if
(
apis
.
has
(
name
)
)
{
return
apis
.
get
(
name
)
;
}
let
api
=
new
module
(
extension
)
;
apis
.
set
(
name
api
)
;
return
api
;
}
loadModule
(
name
)
{
let
module
=
this
.
modules
.
get
(
name
)
;
if
(
module
.
loaded
)
{
return
this
.
global
[
name
]
;
}
this
.
_checkLoadModule
(
module
name
)
;
this
.
initGlobal
(
)
;
Services
.
scriptloader
.
loadSubScript
(
module
.
url
this
.
global
"
UTF
-
8
"
)
;
module
.
loaded
=
true
;
return
this
.
global
[
name
]
;
}
asyncLoadModule
(
name
)
{
let
module
=
this
.
modules
.
get
(
name
)
;
if
(
module
.
loaded
)
{
return
Promise
.
resolve
(
this
.
global
[
name
]
)
;
}
if
(
module
.
asyncLoaded
)
{
return
module
.
asyncLoaded
;
}
this
.
_checkLoadModule
(
module
name
)
;
module
.
asyncLoaded
=
ChromeUtils
.
compileScript
(
module
.
url
)
.
then
(
script
=
>
{
this
.
initGlobal
(
)
;
script
.
executeInGlobal
(
this
.
global
)
;
module
.
loaded
=
true
;
return
this
.
global
[
name
]
;
}
)
;
return
module
.
asyncLoaded
;
}
_checkGetAPI
(
name
extension
scope
=
null
)
{
let
module
=
this
.
modules
.
get
(
name
)
;
if
(
module
.
permissions
&
&
!
module
.
permissions
.
some
(
perm
=
>
extension
.
hasPermission
(
perm
)
)
)
{
return
false
;
}
if
(
!
scope
)
{
return
true
;
}
if
(
!
module
.
scopes
.
includes
(
scope
)
)
{
return
false
;
}
if
(
!
Schemas
.
checkPermissions
(
module
.
namespaceName
extension
)
)
{
return
false
;
}
return
true
;
}
_checkLoadModule
(
module
name
)
{
if
(
!
module
)
{
throw
new
Error
(
Module
'
{
name
}
'
does
not
exist
)
;
}
if
(
module
.
asyncLoaded
)
{
throw
new
Error
(
Module
'
{
name
}
'
currently
being
lazily
loaded
)
;
}
if
(
this
.
global
&
&
this
.
global
[
name
]
)
{
throw
new
Error
(
Module
'
{
name
}
'
conflicts
with
existing
global
property
)
;
}
}
_createExtGlobal
(
)
{
let
global
=
Cu
.
Sandbox
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
{
wantXrays
:
false
sandboxName
:
Namespace
of
ext
-
*
.
js
scripts
for
{
this
.
processType
}
(
from
:
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
)
}
)
;
Object
.
assign
(
global
{
Cc
ChromeUtils
ChromeWorker
Ci
Cr
Cu
ExtensionAPI
ExtensionCommon
MatchGlob
MatchPattern
MatchPatternSet
StructuredCloneHolder
XPCOMUtils
extensions
:
this
global
}
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
global
)
;
XPCOMUtils
.
defineLazyGetter
(
global
"
console
"
getConsole
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
global
{
ExtensionUtils
:
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
XPCOMUtils
:
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
}
)
;
return
global
;
}
initGlobal
(
)
{
if
(
!
this
.
global
)
{
this
.
global
=
this
.
_createExtGlobal
(
)
;
}
}
loadScript
(
scriptUrl
)
{
let
scope
=
Cu
.
createObjectIn
(
this
.
global
)
;
Services
.
scriptloader
.
loadSubScript
(
scriptUrl
scope
"
UTF
-
8
"
)
;
this
.
_scriptScopes
.
push
(
scope
)
;
}
static
generateAPIs
(
context
apis
obj
)
{
function
hasPermission
(
perm
)
{
return
context
.
extension
.
hasPermission
(
perm
true
)
;
}
for
(
let
api
of
apis
)
{
if
(
Schemas
.
checkPermissions
(
api
.
namespace
{
hasPermission
}
)
)
{
api
=
api
.
getAPI
(
context
)
;
deepCopy
(
obj
api
)
;
}
}
}
}
function
LocaleData
(
data
)
{
this
.
defaultLocale
=
data
.
defaultLocale
;
this
.
selectedLocale
=
data
.
selectedLocale
;
this
.
locales
=
data
.
locales
|
|
new
Map
(
)
;
this
.
warnedMissingKeys
=
new
Set
(
)
;
this
.
messages
=
data
.
messages
|
|
new
Map
(
)
;
if
(
data
.
builtinMessages
)
{
this
.
messages
.
set
(
this
.
BUILTIN
data
.
builtinMessages
)
;
}
}
LocaleData
.
prototype
=
{
serialize
(
)
{
return
{
defaultLocale
:
this
.
defaultLocale
selectedLocale
:
this
.
selectedLocale
messages
:
this
.
messages
locales
:
this
.
locales
}
;
}
BUILTIN
:
"
BUILTIN_MESSAGES
"
has
(
locale
)
{
return
this
.
messages
.
has
(
locale
)
;
}
localizeMessage
(
message
substitutions
=
[
]
options
=
{
}
)
{
let
defaultOptions
=
{
defaultValue
:
"
"
cloneScope
:
null
}
;
let
locales
=
this
.
availableLocales
;
if
(
options
.
locale
)
{
locales
=
new
Set
(
[
this
.
BUILTIN
options
.
locale
this
.
defaultLocale
]
.
filter
(
locale
=
>
this
.
messages
.
has
(
locale
)
)
)
;
}
options
=
Object
.
assign
(
defaultOptions
options
)
;
message
=
message
.
toLowerCase
(
)
;
for
(
let
locale
of
locales
)
{
let
messages
=
this
.
messages
.
get
(
locale
)
;
if
(
messages
.
has
(
message
)
)
{
let
str
=
messages
.
get
(
message
)
;
if
(
!
str
.
includes
(
"
"
)
)
{
return
str
;
}
if
(
!
Array
.
isArray
(
substitutions
)
)
{
substitutions
=
[
substitutions
]
;
}
let
replacer
=
(
matched
index
dollarSigns
)
=
>
{
if
(
index
)
{
index
=
parseInt
(
index
10
)
-
1
;
return
index
in
substitutions
?
substitutions
[
index
]
:
"
"
;
}
return
dollarSigns
;
}
;
return
str
.
replace
(
/
\
(
?
:
(
[
1
-
9
]
\
d
*
)
|
(
\
+
)
)
/
g
replacer
)
;
}
}
if
(
message
=
=
"
ui_locale
"
)
{
return
this
.
uiLocale
;
}
else
if
(
message
.
startsWith
(
"
bidi_
"
)
)
{
let
rtl
=
Services
.
locale
.
isAppLocaleRTL
;
if
(
message
=
=
"
bidi_dir
"
)
{
return
rtl
?
"
rtl
"
:
"
ltr
"
;
}
else
if
(
message
=
=
"
bidi_reversed_dir
"
)
{
return
rtl
?
"
ltr
"
:
"
rtl
"
;
}
else
if
(
message
=
=
"
bidi_start_edge
"
)
{
return
rtl
?
"
right
"
:
"
left
"
;
}
else
if
(
message
=
=
"
bidi_end_edge
"
)
{
return
rtl
?
"
left
"
:
"
right
"
;
}
}
if
(
!
this
.
warnedMissingKeys
.
has
(
message
)
)
{
let
error
=
Unknown
localization
message
{
message
}
;
if
(
options
.
cloneScope
)
{
error
=
new
options
.
cloneScope
.
Error
(
error
)
;
}
Cu
.
reportError
(
error
)
;
this
.
warnedMissingKeys
.
add
(
message
)
;
}
return
options
.
defaultValue
;
}
localize
(
str
locale
=
this
.
selectedLocale
)
{
if
(
!
str
)
{
return
str
;
}
return
str
.
replace
(
/
__MSG_
(
[
A
-
Za
-
z0
-
9
_
]
+
?
)
__
/
g
(
matched
message
)
=
>
{
return
this
.
localizeMessage
(
message
[
]
{
locale
defaultValue
:
matched
}
)
;
}
)
;
}
addLocale
(
locale
messages
extension
)
{
let
result
=
new
Map
(
)
;
let
isPlainObject
=
obj
=
>
(
obj
&
&
typeof
obj
=
=
=
"
object
"
&
&
ChromeUtils
.
getClassName
(
obj
)
=
=
=
"
Object
"
)
;
if
(
!
isPlainObject
(
messages
)
)
{
extension
.
packagingError
(
Invalid
locale
data
for
{
locale
}
)
;
return
result
;
}
for
(
let
key
of
Object
.
keys
(
messages
)
)
{
let
msg
=
messages
[
key
]
;
if
(
!
isPlainObject
(
msg
)
|
|
typeof
(
msg
.
message
)
!
=
"
string
"
)
{
extension
.
packagingError
(
Invalid
locale
message
data
for
{
locale
}
message
{
JSON
.
stringify
(
key
)
}
)
;
continue
;
}
let
placeholders
=
new
Map
(
)
;
if
(
isPlainObject
(
msg
.
placeholders
)
)
{
for
(
let
key
of
Object
.
keys
(
msg
.
placeholders
)
)
{
placeholders
.
set
(
key
.
toLowerCase
(
)
msg
.
placeholders
[
key
]
)
;
}
}
let
replacer
=
(
match
name
)
=
>
{
let
replacement
=
placeholders
.
get
(
name
.
toLowerCase
(
)
)
;
if
(
isPlainObject
(
replacement
)
&
&
"
content
"
in
replacement
)
{
return
replacement
.
content
;
}
return
"
"
;
}
;
let
value
=
msg
.
message
.
replace
(
/
\
(
[
A
-
Za
-
z0
-
9
_
]
+
)
\
/
g
replacer
)
;
result
.
set
(
key
.
toLowerCase
(
)
value
)
;
}
this
.
messages
.
set
(
locale
result
)
;
return
result
;
}
get
acceptLanguages
(
)
{
let
result
=
Services
.
prefs
.
getComplexValue
(
"
intl
.
accept_languages
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
return
result
.
split
(
/
\
s
*
\
s
*
/
g
)
;
}
get
uiLocale
(
)
{
return
Services
.
locale
.
getAppLocaleAsBCP47
(
)
;
}
}
;
defineLazyGetter
(
LocaleData
.
prototype
"
availableLocales
"
function
(
)
{
return
new
Set
(
[
this
.
BUILTIN
this
.
selectedLocale
this
.
defaultLocale
]
.
filter
(
locale
=
>
this
.
messages
.
has
(
locale
)
)
)
;
}
)
;
function
EventManager
(
context
name
register
)
{
this
.
context
=
context
;
this
.
name
=
name
;
this
.
register
=
register
;
this
.
unregister
=
new
Map
(
)
;
this
.
inputHandling
=
false
;
}
EventManager
.
prototype
=
{
addListener
(
callback
.
.
.
args
)
{
if
(
this
.
unregister
.
has
(
callback
)
)
{
return
;
}
let
shouldFire
=
(
)
=
>
{
if
(
this
.
context
.
unloaded
)
{
dump
(
{
this
.
name
}
event
fired
after
context
unloaded
.
\
n
)
;
}
else
if
(
!
this
.
context
.
active
)
{
dump
(
{
this
.
name
}
event
fired
while
context
is
inactive
.
\
n
)
;
}
else
if
(
this
.
unregister
.
has
(
callback
)
)
{
return
true
;
}
return
false
;
}
;
let
fire
=
{
sync
:
(
.
.
.
args
)
=
>
{
if
(
shouldFire
(
)
)
{
return
this
.
context
.
applySafe
(
callback
args
)
;
}
}
async
:
(
.
.
.
args
)
=
>
{
return
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
if
(
shouldFire
(
)
)
{
return
this
.
context
.
applySafe
(
callback
args
)
;
}
}
)
;
}
raw
:
(
.
.
.
args
)
=
>
{
if
(
!
shouldFire
(
)
)
{
throw
new
Error
(
"
Called
raw
(
)
on
unloaded
/
inactive
context
"
)
;
}
return
Reflect
.
apply
(
callback
null
args
)
;
}
asyncWithoutClone
:
(
.
.
.
args
)
=
>
{
return
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
if
(
shouldFire
(
)
)
{
return
this
.
context
.
applySafeWithoutClone
(
callback
args
)
;
}
}
)
;
}
}
;
let
unregister
=
this
.
register
(
fire
.
.
.
args
)
;
this
.
unregister
.
set
(
callback
unregister
)
;
this
.
context
.
callOnClose
(
this
)
;
}
removeListener
(
callback
)
{
if
(
!
this
.
unregister
.
has
(
callback
)
)
{
return
;
}
let
unregister
=
this
.
unregister
.
get
(
callback
)
;
this
.
unregister
.
delete
(
callback
)
;
try
{
unregister
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
this
.
unregister
.
size
=
=
0
)
{
this
.
context
.
forgetOnClose
(
this
)
;
}
}
hasListener
(
callback
)
{
return
this
.
unregister
.
has
(
callback
)
;
}
revoke
(
)
{
for
(
let
callback
of
this
.
unregister
.
keys
(
)
)
{
this
.
removeListener
(
callback
)
;
}
}
close
(
)
{
this
.
revoke
(
)
;
}
api
(
)
{
return
{
addListener
:
(
.
.
.
args
)
=
>
this
.
addListener
(
.
.
.
args
)
removeListener
:
(
.
.
.
args
)
=
>
this
.
removeListener
(
.
.
.
args
)
hasListener
:
(
.
.
.
args
)
=
>
this
.
hasListener
(
.
.
.
args
)
setUserInput
:
this
.
inputHandling
[
Schemas
.
REVOKE
]
:
(
)
=
>
this
.
revoke
(
)
}
;
}
}
;
function
ignoreEvent
(
context
name
)
{
return
{
addListener
:
function
(
callback
)
{
let
id
=
context
.
extension
.
id
;
let
frame
=
Components
.
stack
.
caller
;
let
msg
=
In
add
-
on
{
id
}
attempting
to
use
listener
"
{
name
}
"
which
is
unimplemented
.
;
let
scriptError
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
scriptError
.
init
(
msg
frame
.
filename
null
frame
.
lineNumber
frame
.
columnNumber
Ci
.
nsIScriptError
.
warningFlag
"
content
javascript
"
)
;
Services
.
console
.
logMessage
(
scriptError
)
;
}
removeListener
:
function
(
callback
)
{
}
hasListener
:
function
(
callback
)
{
}
}
;
}
const
stylesheetMap
=
new
DefaultMap
(
url
=
>
{
let
uri
=
Services
.
io
.
newURI
(
url
)
;
return
styleSheetService
.
preloadSheet
(
uri
styleSheetService
.
AGENT_SHEET
)
;
}
)
;
ExtensionCommon
=
{
BaseContext
CanOfAPIs
EventManager
ExtensionAPI
ExtensionAPIs
LocalAPIImplementation
LocaleData
NoCloneSpreadArgs
SchemaAPIInterface
SchemaAPIManager
SpreadArgs
ignoreEvent
stylesheetMap
}
;
