"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionCommon
"
]
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MessageChannel
"
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Schemas
"
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
EventEmitter
ExtensionError
SpreadArgs
getConsole
getInnerWindowID
getUniqueId
runSafeSync
runSafeSyncWithoutClone
instanceOf
}
=
ExtensionUtils
;
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
getConsole
)
;
class
BaseContext
{
constructor
(
envType
extension
)
{
this
.
envType
=
envType
;
this
.
onClose
=
new
Set
(
)
;
this
.
checkedLastError
=
false
;
this
.
_lastError
=
null
;
this
.
contextId
=
getUniqueId
(
)
;
this
.
unloaded
=
false
;
this
.
extension
=
extension
;
this
.
jsonSandbox
=
null
;
this
.
active
=
true
;
this
.
incognito
=
null
;
this
.
messageManager
=
null
;
this
.
docShell
=
null
;
this
.
contentWindow
=
null
;
this
.
innerWindowID
=
0
;
}
setContentWindow
(
contentWindow
)
{
let
{
document
}
=
contentWindow
;
let
docShell
=
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
;
this
.
innerWindowID
=
getInnerWindowID
(
contentWindow
)
;
this
.
messageManager
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
if
(
this
.
incognito
=
=
null
)
{
this
.
incognito
=
PrivateBrowsingUtils
.
isContentWindowPrivate
(
contentWindow
)
;
}
MessageChannel
.
setupMessageManagers
(
[
this
.
messageManager
]
)
;
let
onPageShow
=
event
=
>
{
if
(
!
event
|
|
event
.
target
=
=
=
document
)
{
this
.
docShell
=
docShell
;
this
.
contentWindow
=
contentWindow
;
this
.
active
=
true
;
}
}
;
let
onPageHide
=
event
=
>
{
if
(
!
event
|
|
event
.
target
=
=
=
document
)
{
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
this
.
docShell
=
null
;
this
.
contentWindow
=
null
;
this
.
active
=
false
;
}
)
;
}
}
;
onPageShow
(
)
;
contentWindow
.
addEventListener
(
"
pagehide
"
onPageHide
true
)
;
contentWindow
.
addEventListener
(
"
pageshow
"
onPageShow
true
)
;
this
.
callOnClose
(
{
close
:
(
)
=
>
{
onPageHide
(
)
;
if
(
this
.
active
)
{
contentWindow
.
removeEventListener
(
"
pagehide
"
onPageHide
true
)
;
contentWindow
.
removeEventListener
(
"
pageshow
"
onPageShow
true
)
;
}
}
}
)
;
}
get
cloneScope
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
principal
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
runSafe
(
.
.
.
args
)
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
"
context
.
runSafe
called
after
context
unloaded
"
)
;
}
else
if
(
!
this
.
active
)
{
Cu
.
reportError
(
"
context
.
runSafe
called
while
context
is
inactive
"
)
;
}
else
{
return
runSafeSync
(
this
.
.
.
args
)
;
}
}
runSafeWithoutClone
(
.
.
.
args
)
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
"
context
.
runSafeWithoutClone
called
after
context
unloaded
"
)
;
}
else
if
(
!
this
.
active
)
{
Cu
.
reportError
(
"
context
.
runSafeWithoutClone
called
while
context
is
inactive
"
)
;
}
else
{
return
runSafeSyncWithoutClone
(
.
.
.
args
)
;
}
}
checkLoadURL
(
url
options
=
{
}
)
{
let
ssm
=
Services
.
scriptSecurityManager
;
let
flags
=
ssm
.
STANDARD
;
if
(
!
options
.
allowScript
)
{
flags
|
=
ssm
.
DISALLOW_SCRIPT
;
}
if
(
!
options
.
allowInheritsPrincipal
)
{
flags
|
=
ssm
.
DISALLOW_INHERIT_PRINCIPAL
;
}
if
(
options
.
dontReportErrors
)
{
flags
|
=
ssm
.
DONT_REPORT_ERRORS
;
}
try
{
ssm
.
checkLoadURIStrWithPrincipal
(
this
.
principal
url
flags
)
;
}
catch
(
e
)
{
return
false
;
}
return
true
;
}
jsonStringify
(
.
.
.
args
)
{
if
(
!
this
.
jsonSandbox
)
{
this
.
jsonSandbox
=
Cu
.
Sandbox
(
this
.
principal
{
sameZoneAs
:
this
.
cloneScope
wantXrays
:
false
}
)
;
}
return
Cu
.
waiveXrays
(
this
.
jsonSandbox
.
JSON
)
.
stringify
(
.
.
.
args
)
;
}
callOnClose
(
obj
)
{
this
.
onClose
.
add
(
obj
)
;
}
forgetOnClose
(
obj
)
{
this
.
onClose
.
delete
(
obj
)
;
}
sendMessage
(
target
messageName
data
options
=
{
}
)
{
options
.
recipient
=
options
.
recipient
|
|
{
}
;
options
.
sender
=
options
.
sender
|
|
{
}
;
options
.
recipient
.
extensionId
=
this
.
extension
.
id
;
options
.
sender
.
extensionId
=
this
.
extension
.
id
;
options
.
sender
.
contextId
=
this
.
contextId
;
return
MessageChannel
.
sendMessage
(
target
messageName
data
options
)
;
}
get
lastError
(
)
{
this
.
checkedLastError
=
true
;
return
this
.
_lastError
;
}
set
lastError
(
val
)
{
this
.
checkedLastError
=
false
;
this
.
_lastError
=
val
;
}
normalizeError
(
error
)
{
if
(
error
instanceof
this
.
cloneScope
.
Error
)
{
return
error
;
}
let
message
;
if
(
instanceOf
(
error
"
Object
"
)
|
|
error
instanceof
ExtensionError
)
{
message
=
error
.
message
;
}
else
if
(
typeof
error
=
=
"
object
"
&
&
this
.
principal
.
subsumes
(
Cu
.
getObjectPrincipal
(
error
)
)
)
{
message
=
error
.
message
;
}
else
{
Cu
.
reportError
(
error
)
;
}
message
=
message
|
|
"
An
unexpected
error
occurred
"
;
return
new
this
.
cloneScope
.
Error
(
message
)
;
}
withLastError
(
error
callback
)
{
this
.
lastError
=
this
.
normalizeError
(
error
)
;
try
{
return
callback
(
)
;
}
finally
{
if
(
!
this
.
checkedLastError
)
{
Cu
.
reportError
(
Unchecked
lastError
value
:
{
this
.
lastError
}
)
;
}
this
.
lastError
=
null
;
}
}
wrapPromise
(
promise
callback
=
null
)
{
let
runSafe
=
this
.
runSafe
.
bind
(
this
)
;
if
(
promise
instanceof
this
.
cloneScope
.
Promise
)
{
runSafe
=
this
.
runSafeWithoutClone
.
bind
(
this
)
;
}
if
(
callback
)
{
promise
.
then
(
args
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
resolved
after
context
unloaded
\
n
)
;
}
else
if
(
!
this
.
active
)
{
dump
(
Promise
resolved
while
context
is
inactive
\
n
)
;
}
else
if
(
args
instanceof
SpreadArgs
)
{
runSafe
(
callback
.
.
.
args
)
;
}
else
{
runSafe
(
callback
args
)
;
}
}
error
=
>
{
this
.
withLastError
(
error
(
)
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
rejected
after
context
unloaded
\
n
)
;
}
else
if
(
!
this
.
active
)
{
dump
(
Promise
rejected
while
context
is
inactive
\
n
)
;
}
else
{
this
.
runSafeWithoutClone
(
callback
)
;
}
}
)
;
}
)
;
}
else
{
return
new
this
.
cloneScope
.
Promise
(
(
resolve
reject
)
=
>
{
promise
.
then
(
value
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
resolved
after
context
unloaded
\
n
)
;
}
else
if
(
!
this
.
active
)
{
dump
(
Promise
resolved
while
context
is
inactive
\
n
)
;
}
else
if
(
value
instanceof
SpreadArgs
)
{
runSafe
(
resolve
value
.
length
=
=
1
?
value
[
0
]
:
value
)
;
}
else
{
runSafe
(
resolve
value
)
;
}
}
value
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
rejected
after
context
unloaded
:
{
value
&
&
value
.
message
}
\
n
)
;
}
else
if
(
!
this
.
active
)
{
dump
(
Promise
rejected
while
context
is
inactive
:
{
value
&
&
value
.
message
}
\
n
)
;
}
else
{
this
.
runSafeWithoutClone
(
reject
this
.
normalizeError
(
value
)
)
;
}
}
)
;
}
)
;
}
}
unload
(
)
{
this
.
unloaded
=
true
;
MessageChannel
.
abortResponses
(
{
extensionId
:
this
.
extension
.
id
contextId
:
this
.
contextId
}
)
;
for
(
let
obj
of
this
.
onClose
)
{
obj
.
close
(
)
;
}
}
close
(
)
{
this
.
unload
(
)
;
}
}
class
SchemaAPIInterface
{
callFunction
(
args
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
callFunctionNoReturn
(
args
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
callAsyncFunction
(
args
callback
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getProperty
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
setProperty
(
value
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
addListener
(
listener
args
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
hasListener
(
listener
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
removeListener
(
listener
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
class
LocalAPIImplementation
extends
SchemaAPIInterface
{
constructor
(
pathObj
name
context
)
{
super
(
)
;
this
.
pathObj
=
pathObj
;
this
.
name
=
name
;
this
.
context
=
context
;
}
callFunction
(
args
)
{
return
this
.
pathObj
[
this
.
name
]
(
.
.
.
args
)
;
}
callFunctionNoReturn
(
args
)
{
this
.
pathObj
[
this
.
name
]
(
.
.
.
args
)
;
}
callAsyncFunction
(
args
callback
)
{
let
promise
;
try
{
promise
=
this
.
pathObj
[
this
.
name
]
(
.
.
.
args
)
|
|
Promise
.
resolve
(
)
;
}
catch
(
e
)
{
promise
=
Promise
.
reject
(
e
)
;
}
return
this
.
context
.
wrapPromise
(
promise
callback
)
;
}
getProperty
(
)
{
return
this
.
pathObj
[
this
.
name
]
;
}
setProperty
(
value
)
{
this
.
pathObj
[
this
.
name
]
=
value
;
}
addListener
(
listener
args
)
{
try
{
this
.
pathObj
[
this
.
name
]
.
addListener
.
call
(
null
listener
.
.
.
args
)
;
}
catch
(
e
)
{
throw
this
.
context
.
normalizeError
(
e
)
;
}
}
hasListener
(
listener
)
{
return
this
.
pathObj
[
this
.
name
]
.
hasListener
.
call
(
null
listener
)
;
}
removeListener
(
listener
)
{
this
.
pathObj
[
this
.
name
]
.
removeListener
.
call
(
null
listener
)
;
}
}
class
SchemaAPIManager
extends
EventEmitter
{
constructor
(
processType
)
{
super
(
)
;
this
.
processType
=
processType
;
this
.
global
=
this
.
_createExtGlobal
(
)
;
this
.
_scriptScopes
=
[
]
;
this
.
_schemaApis
=
{
addon_parent
:
[
]
addon_child
:
[
]
content_parent
:
[
]
content_child
:
[
]
}
;
}
_createExtGlobal
(
)
{
let
global
=
Cu
.
Sandbox
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
{
wantXrays
:
false
sandboxName
:
Namespace
of
ext
-
*
.
js
scripts
for
{
this
.
processType
}
}
)
;
Object
.
assign
(
global
{
global
Cc
Ci
Cu
Cr
XPCOMUtils
extensions
:
this
}
)
;
XPCOMUtils
.
defineLazyGetter
(
global
"
console
"
getConsole
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
global
"
require
"
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
return
global
;
}
loadScript
(
scriptUrl
)
{
let
scope
=
Cu
.
createObjectIn
(
this
.
global
)
;
Services
.
scriptloader
.
loadSubScript
(
scriptUrl
scope
"
UTF
-
8
"
)
;
this
.
_scriptScopes
.
push
(
scope
)
;
}
registerSchemaAPI
(
namespace
envType
getAPI
)
{
this
.
_schemaApis
[
envType
]
.
push
(
{
namespace
getAPI
}
)
;
}
generateAPIs
(
context
obj
)
{
let
apis
=
this
.
_schemaApis
[
context
.
envType
]
;
if
(
!
apis
)
{
Cu
.
reportError
(
No
APIs
have
been
registered
for
{
context
.
envType
}
)
;
return
;
}
SchemaAPIManager
.
generateAPIs
(
context
apis
obj
)
;
}
static
generateAPIs
(
context
apis
obj
)
{
function
copy
(
dest
source
)
{
for
(
let
prop
in
source
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
source
prop
)
;
if
(
typeof
(
desc
.
value
)
=
=
"
object
"
)
{
if
(
!
(
prop
in
dest
)
)
{
dest
[
prop
]
=
{
}
;
}
copy
(
dest
[
prop
]
source
[
prop
]
)
;
}
else
{
Object
.
defineProperty
(
dest
prop
desc
)
;
}
}
}
for
(
let
api
of
apis
)
{
if
(
Schemas
.
checkPermissions
(
api
.
namespace
context
.
extension
)
)
{
api
=
api
.
getAPI
(
context
)
;
copy
(
obj
api
)
;
}
}
}
}
const
ExtensionCommon
=
{
BaseContext
LocalAPIImplementation
SchemaAPIInterface
SchemaAPIManager
}
;
