"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionPreferencesManager
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
const
{
Management
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
{
}
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionSettingsStore
"
"
resource
:
/
/
gre
/
modules
/
ExtensionSettingsStore
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
defaultPreferences
"
function
(
)
{
return
new
Preferences
(
{
defaultBranch
:
true
}
)
;
}
)
;
Management
.
on
(
"
shutdown
"
(
type
extension
)
=
>
{
switch
(
extension
.
shutdownReason
)
{
case
"
ADDON_DISABLE
"
:
case
"
ADDON_DOWNGRADE
"
:
case
"
ADDON_UPGRADE
"
:
this
.
ExtensionPreferencesManager
.
disableAll
(
extension
)
;
break
;
case
"
ADDON_UNINSTALL
"
:
this
.
ExtensionPreferencesManager
.
removeAll
(
extension
)
;
break
;
}
}
)
;
Management
.
on
(
"
startup
"
(
type
extension
)
=
>
{
if
(
[
"
ADDON_ENABLE
"
"
ADDON_UPGRADE
"
"
ADDON_DOWNGRADE
"
]
.
includes
(
extension
.
startupReason
)
)
{
this
.
ExtensionPreferencesManager
.
enableAll
(
extension
)
;
}
}
)
;
const
STORE_TYPE
=
"
prefs
"
;
let
settingsMap
=
new
Map
(
)
;
function
initialValueCallback
(
)
{
let
initialValue
=
{
}
;
for
(
let
pref
of
this
.
prefNames
)
{
initialValue
[
pref
]
=
Preferences
.
get
(
pref
)
;
}
return
initialValue
;
}
function
setPrefs
(
setting
item
)
{
let
prefs
=
item
.
initialValue
|
|
setting
.
setCallback
(
item
.
value
)
;
for
(
let
pref
in
prefs
)
{
if
(
prefs
[
pref
]
=
=
=
undefined
)
{
Preferences
.
reset
(
pref
)
;
}
else
{
Preferences
.
set
(
pref
prefs
[
pref
]
)
;
}
}
}
async
function
processSetting
(
extension
name
action
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
expectedItem
=
ExtensionSettingsStore
.
getSetting
(
STORE_TYPE
name
)
;
let
item
=
ExtensionSettingsStore
[
action
]
(
extension
STORE_TYPE
name
)
;
if
(
item
)
{
let
setting
=
settingsMap
.
get
(
name
)
;
let
expectedPrefs
=
expectedItem
.
initialValue
|
|
setting
.
setCallback
(
expectedItem
.
value
)
;
if
(
Object
.
keys
(
expectedPrefs
)
.
some
(
pref
=
>
expectedPrefs
[
pref
]
&
&
Preferences
.
get
(
pref
)
!
=
expectedPrefs
[
pref
]
)
)
{
return
false
;
}
setPrefs
(
setting
item
)
;
return
true
;
}
return
false
;
}
this
.
ExtensionPreferencesManager
=
{
addSetting
(
name
setting
)
{
settingsMap
.
set
(
name
setting
)
;
}
getDefaultValue
(
prefName
)
{
return
defaultPreferences
.
get
(
prefName
)
;
}
async
setSetting
(
extension
name
value
)
{
let
setting
=
settingsMap
.
get
(
name
)
;
await
ExtensionSettingsStore
.
initialize
(
)
;
let
item
=
await
ExtensionSettingsStore
.
addSetting
(
extension
STORE_TYPE
name
value
initialValueCallback
.
bind
(
setting
)
)
;
if
(
item
)
{
setPrefs
(
setting
item
)
;
return
true
;
}
return
false
;
}
disableSetting
(
extension
name
)
{
return
processSetting
(
extension
name
"
disable
"
)
;
}
enableSetting
(
extension
name
)
{
return
processSetting
(
extension
name
"
enable
"
)
;
}
removeSetting
(
extension
name
)
{
return
processSetting
(
extension
name
"
removeSetting
"
)
;
}
async
disableAll
(
extension
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
settings
=
ExtensionSettingsStore
.
getAllForExtension
(
extension
STORE_TYPE
)
;
let
disablePromises
=
[
]
;
for
(
let
name
of
settings
)
{
disablePromises
.
push
(
this
.
disableSetting
(
extension
name
)
)
;
}
await
Promise
.
all
(
disablePromises
)
;
}
async
enableAll
(
extension
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
settings
=
ExtensionSettingsStore
.
getAllForExtension
(
extension
STORE_TYPE
)
;
let
enablePromises
=
[
]
;
for
(
let
name
of
settings
)
{
enablePromises
.
push
(
this
.
enableSetting
(
extension
name
)
)
;
}
await
Promise
.
all
(
enablePromises
)
;
}
async
removeAll
(
extension
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
settings
=
ExtensionSettingsStore
.
getAllForExtension
(
extension
STORE_TYPE
)
;
let
removePromises
=
[
]
;
for
(
let
name
of
settings
)
{
removePromises
.
push
(
this
.
removeSetting
(
extension
name
)
)
;
}
await
Promise
.
all
(
removePromises
)
;
}
async
getLevelOfControl
(
extension
name
)
{
for
(
let
prefName
of
settingsMap
.
get
(
name
)
.
prefNames
)
{
if
(
Preferences
.
locked
(
prefName
)
)
{
return
"
not_controllable
"
;
}
}
await
ExtensionSettingsStore
.
initialize
(
)
;
return
ExtensionSettingsStore
.
getLevelOfControl
(
extension
STORE_TYPE
name
)
;
}
}
;
