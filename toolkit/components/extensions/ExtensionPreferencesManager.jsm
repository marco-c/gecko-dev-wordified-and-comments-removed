"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ExtensionPreferencesManager
"
]
;
let
ExtensionPreferencesManager
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
Management
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionSettingsStore
"
"
resource
:
/
/
gre
/
modules
/
ExtensionSettingsStore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionCommon
"
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
{
ExtensionError
}
=
ExtensionUtils
;
XPCOMUtils
.
defineLazyGetter
(
this
"
defaultPreferences
"
function
(
)
{
return
new
Preferences
(
{
defaultBranch
:
true
}
)
;
}
)
;
Management
.
on
(
"
uninstall
"
async
(
type
{
id
}
)
=
>
{
await
Management
.
asyncLoadSettingsModules
(
)
;
return
ExtensionPreferencesManager
.
removeAll
(
id
)
;
}
)
;
Management
.
on
(
"
disable
"
async
(
type
id
)
=
>
{
await
Management
.
asyncLoadSettingsModules
(
)
;
return
ExtensionPreferencesManager
.
disableAll
(
id
)
;
}
)
;
Management
.
on
(
"
enabling
"
async
(
type
id
)
=
>
{
await
Management
.
asyncLoadSettingsModules
(
)
;
return
ExtensionPreferencesManager
.
enableAll
(
id
)
;
}
)
;
Management
.
on
(
"
change
-
permissions
"
(
type
change
)
=
>
{
if
(
!
change
.
removed
)
{
return
;
}
ExtensionPreferencesManager
.
removeSettingsForPermissions
(
change
.
extensionId
change
.
removed
.
permissions
)
;
}
)
;
const
STORE_TYPE
=
"
prefs
"
;
let
settingsMap
=
new
Map
(
)
;
function
initialValueCallback
(
)
{
let
initialValue
=
{
}
;
for
(
let
pref
of
this
.
prefNames
)
{
if
(
Preferences
.
isSet
(
pref
)
)
{
initialValue
[
pref
]
=
Preferences
.
get
(
pref
)
;
}
}
return
initialValue
;
}
function
settingsUpdate
(
initialValue
)
{
for
(
let
pref
of
this
.
prefNames
)
{
try
{
if
(
initialValue
[
pref
]
!
=
=
undefined
&
&
initialValue
[
pref
]
=
=
=
defaultPreferences
.
get
(
pref
)
)
{
initialValue
[
pref
]
=
undefined
;
}
}
catch
(
e
)
{
}
}
return
initialValue
;
}
function
setPrefs
(
name
setting
item
)
{
let
prefs
=
item
.
initialValue
|
|
setting
.
setCallback
(
item
.
value
)
;
let
changed
=
false
;
for
(
let
pref
of
setting
.
prefNames
)
{
if
(
prefs
[
pref
]
=
=
=
undefined
)
{
if
(
Preferences
.
isSet
(
pref
)
)
{
changed
=
true
;
Preferences
.
reset
(
pref
)
;
}
}
else
if
(
Preferences
.
get
(
pref
)
!
=
prefs
[
pref
]
)
{
Preferences
.
set
(
pref
prefs
[
pref
]
)
;
changed
=
true
;
}
}
if
(
changed
&
&
typeof
setting
.
onPrefsChanged
=
=
"
function
"
)
{
setting
.
onPrefsChanged
(
item
)
;
}
Management
.
emit
(
extension
-
setting
-
changed
:
{
name
}
)
;
}
async
function
processSetting
(
id
name
action
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
expectedItem
=
ExtensionSettingsStore
.
getSetting
(
STORE_TYPE
name
)
;
let
item
=
ExtensionSettingsStore
[
action
]
(
id
STORE_TYPE
name
)
;
if
(
item
)
{
let
setting
=
settingsMap
.
get
(
name
)
;
let
expectedPrefs
=
expectedItem
.
initialValue
|
|
setting
.
setCallback
(
expectedItem
.
value
)
;
if
(
Object
.
keys
(
expectedPrefs
)
.
some
(
pref
=
>
expectedPrefs
[
pref
]
&
&
Preferences
.
get
(
pref
)
!
=
expectedPrefs
[
pref
]
)
)
{
return
false
;
}
setPrefs
(
name
setting
item
)
;
return
true
;
}
return
false
;
}
ExtensionPreferencesManager
=
{
addSetting
(
name
setting
)
{
settingsMap
.
set
(
name
setting
)
;
}
getDefaultValue
(
prefName
)
{
return
defaultPreferences
.
get
(
prefName
)
;
}
async
getManagedPrefDetails
(
)
{
await
Management
.
asyncLoadSettingsModules
(
)
;
let
prefs
=
new
Map
(
)
;
settingsMap
.
forEach
(
(
setting
name
)
=
>
{
for
(
let
prefName
of
setting
.
prefNames
)
{
prefs
.
set
(
prefName
name
)
;
}
}
)
;
return
prefs
;
}
async
setSetting
(
id
name
value
)
{
let
setting
=
settingsMap
.
get
(
name
)
;
await
ExtensionSettingsStore
.
initialize
(
)
;
let
item
=
await
ExtensionSettingsStore
.
addSetting
(
id
STORE_TYPE
name
value
initialValueCallback
.
bind
(
setting
)
name
settingsUpdate
.
bind
(
setting
)
)
;
if
(
item
)
{
setPrefs
(
name
setting
item
)
;
return
true
;
}
return
false
;
}
disableSetting
(
id
name
)
{
return
processSetting
(
id
name
"
disable
"
)
;
}
enableSetting
(
id
name
)
{
return
processSetting
(
id
name
"
enable
"
)
;
}
selectSetting
(
id
name
)
{
return
processSetting
(
id
name
"
select
"
)
;
}
removeSetting
(
id
name
)
{
return
processSetting
(
id
name
"
removeSetting
"
)
;
}
async
disableAll
(
id
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
settings
=
ExtensionSettingsStore
.
getAllForExtension
(
id
STORE_TYPE
)
;
let
disablePromises
=
[
]
;
for
(
let
name
of
settings
)
{
disablePromises
.
push
(
this
.
disableSetting
(
id
name
)
)
;
}
await
Promise
.
all
(
disablePromises
)
;
}
async
enableAll
(
id
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
settings
=
ExtensionSettingsStore
.
getAllForExtension
(
id
STORE_TYPE
)
;
let
enablePromises
=
[
]
;
for
(
let
name
of
settings
)
{
enablePromises
.
push
(
this
.
enableSetting
(
id
name
)
)
;
}
await
Promise
.
all
(
enablePromises
)
;
}
async
removeAll
(
id
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
settings
=
ExtensionSettingsStore
.
getAllForExtension
(
id
STORE_TYPE
)
;
let
removePromises
=
[
]
;
for
(
let
name
of
settings
)
{
removePromises
.
push
(
this
.
removeSetting
(
id
name
)
)
;
}
await
Promise
.
all
(
removePromises
)
;
}
async
removeSettingsForPermissions
(
id
permissions
)
{
if
(
!
permissions
|
|
!
permissions
.
length
)
{
return
;
}
await
Management
.
asyncLoadSettingsModules
(
)
;
let
removePromises
=
[
]
;
settingsMap
.
forEach
(
(
setting
name
)
=
>
{
if
(
permissions
.
includes
(
setting
.
permission
)
)
{
removePromises
.
push
(
this
.
removeSetting
(
id
name
)
)
;
}
}
)
;
return
Promise
.
all
(
removePromises
)
;
}
async
getSetting
(
name
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
return
ExtensionSettingsStore
.
getSetting
(
STORE_TYPE
name
)
;
}
async
getLevelOfControl
(
id
name
storeType
=
STORE_TYPE
)
{
if
(
storeType
=
=
=
STORE_TYPE
)
{
let
setting
=
settingsMap
.
get
(
name
)
;
if
(
!
setting
)
{
return
"
not_controllable
"
;
}
for
(
let
prefName
of
setting
.
prefNames
)
{
if
(
Preferences
.
locked
(
prefName
)
)
{
return
"
not_controllable
"
;
}
}
}
await
ExtensionSettingsStore
.
initialize
(
)
;
return
ExtensionSettingsStore
.
getLevelOfControl
(
id
storeType
name
)
;
}
getSettingsAPI
(
extensionId
name
callback
storeType
readOnly
=
false
validate
)
{
if
(
arguments
.
length
>
1
)
{
Services
.
console
.
logStringMessage
(
ExtensionPreferencesManager
.
getSettingsAPI
for
{
name
}
should
be
updated
to
use
a
single
paramater
object
.
)
;
}
return
ExtensionPreferencesManager
.
_getInternalSettingsAPI
(
arguments
.
length
=
=
=
1
?
extensionId
:
{
extensionId
name
callback
storeType
readOnly
validate
}
)
.
api
;
}
getPrimedSettingsListener
(
config
)
{
let
{
name
extension
}
=
config
;
if
(
!
name
|
|
!
extension
)
{
throw
new
Error
(
name
and
extension
are
required
for
getPrimedSettingListener
)
;
}
if
(
!
settingsMap
.
get
(
name
)
)
{
throw
new
Error
(
addSetting
must
be
called
prior
to
getPrimedSettingListener
)
;
}
return
ExtensionPreferencesManager
.
_getInternalSettingsAPI
(
{
name
extension
}
)
.
registerEvent
;
}
_getInternalSettingsAPI
(
params
)
{
let
{
extensionId
context
extension
module
name
callback
storeType
readOnly
=
false
onChange
validate
}
=
params
;
if
(
context
)
{
extension
=
context
.
extension
;
}
if
(
!
extensionId
&
&
extension
)
{
extensionId
=
extension
.
id
;
}
const
checkScope
=
details
=
>
{
let
{
scope
}
=
details
;
if
(
scope
&
&
scope
!
=
=
"
regular
"
)
{
throw
new
ExtensionError
(
Firefox
does
not
support
the
{
scope
}
settings
scope
.
)
;
}
}
;
let
setting
=
settingsMap
.
get
(
name
)
;
readOnly
=
readOnly
|
|
!
!
setting
?
.
readOnly
;
validate
=
validate
|
|
setting
?
.
validate
|
|
(
(
)
=
>
{
}
)
;
let
getValue
=
callback
|
|
setting
?
.
getCallback
;
if
(
!
getValue
|
|
typeof
getValue
!
=
=
"
function
"
)
{
throw
new
Error
(
Invalid
get
callback
for
setting
{
name
}
in
{
module
}
)
;
}
let
settingsAPI
=
{
async
get
(
details
)
{
validate
(
extension
)
;
let
levelOfControl
=
details
.
incognito
?
"
not_controllable
"
:
await
ExtensionPreferencesManager
.
getLevelOfControl
(
extensionId
name
storeType
)
;
levelOfControl
=
readOnly
&
&
levelOfControl
=
=
=
"
controllable_by_this_extension
"
?
"
not_controllable
"
:
levelOfControl
;
return
{
levelOfControl
value
:
await
getValue
(
)
}
;
}
set
(
details
)
{
validate
(
extension
)
;
checkScope
(
details
)
;
if
(
!
readOnly
)
{
return
ExtensionPreferencesManager
.
setSetting
(
extensionId
name
details
.
value
)
;
}
return
false
;
}
clear
(
details
)
{
validate
(
extension
)
;
checkScope
(
details
)
;
if
(
!
readOnly
)
{
return
ExtensionPreferencesManager
.
removeSetting
(
extensionId
name
)
;
}
return
false
;
}
onChange
}
;
let
registerEvent
=
fire
=
>
{
let
listener
=
async
(
)
=
>
{
fire
.
async
(
await
settingsAPI
.
get
(
{
}
)
)
;
}
;
Management
.
on
(
extension
-
setting
-
changed
:
{
name
}
listener
)
;
return
{
unregister
:
(
)
=
>
{
Management
.
off
(
extension
-
setting
-
changed
:
{
name
}
listener
)
;
}
convert
(
_fire
)
{
fire
=
_fire
;
}
}
;
}
;
if
(
onChange
=
=
=
undefined
&
&
context
)
{
if
(
setting
)
{
settingsAPI
.
onChange
=
new
ExtensionCommon
.
EventManager
(
{
context
module
event
:
name
name
:
{
name
}
.
onChange
register
:
fire
=
>
{
return
registerEvent
(
fire
)
.
unregister
;
}
}
)
.
api
(
)
;
}
else
{
Services
.
console
.
logStringMessage
(
ExtensionPreferencesManager
API
{
name
}
created
but
addSetting
was
not
called
.
)
;
}
}
return
{
api
:
settingsAPI
registerEvent
}
;
}
}
;
