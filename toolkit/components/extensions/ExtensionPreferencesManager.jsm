"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExtensionPreferencesManager
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
Management
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
null
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionSettingsStore
"
"
resource
:
/
/
gre
/
modules
/
ExtensionSettingsStore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionCommon
"
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
{
ExtensionError
}
=
ExtensionUtils
;
XPCOMUtils
.
defineLazyGetter
(
this
"
defaultPreferences
"
function
(
)
{
return
new
Preferences
(
{
defaultBranch
:
true
}
)
;
}
)
;
Management
.
on
(
"
uninstall
"
(
type
{
id
}
)
=
>
{
ExtensionPreferencesManager
.
removeAll
(
id
)
;
}
)
;
Management
.
on
(
"
disable
"
(
type
id
)
=
>
{
ExtensionPreferencesManager
.
disableAll
(
id
)
;
}
)
;
Management
.
on
(
"
startup
"
async
(
type
extension
)
=
>
{
if
(
extension
.
startupReason
=
=
"
ADDON_ENABLE
"
)
{
ExtensionPreferencesManager
.
enableAll
(
extension
.
id
)
;
}
}
)
;
const
STORE_TYPE
=
"
prefs
"
;
let
settingsMap
=
new
Map
(
)
;
function
initialValueCallback
(
)
{
let
initialValue
=
{
}
;
for
(
let
pref
of
this
.
prefNames
)
{
if
(
Preferences
.
isSet
(
pref
)
)
{
initialValue
[
pref
]
=
Preferences
.
get
(
pref
)
;
}
}
return
initialValue
;
}
function
settingsUpdate
(
initialValue
)
{
for
(
let
pref
of
this
.
prefNames
)
{
try
{
if
(
initialValue
[
pref
]
!
=
=
undefined
&
&
initialValue
[
pref
]
=
=
=
defaultPreferences
.
get
(
pref
)
)
{
initialValue
[
pref
]
=
undefined
;
}
}
catch
(
e
)
{
}
}
return
initialValue
;
}
function
setPrefs
(
name
setting
item
)
{
let
prefs
=
item
.
initialValue
|
|
setting
.
setCallback
(
item
.
value
)
;
let
changed
=
false
;
for
(
let
pref
of
setting
.
prefNames
)
{
if
(
prefs
[
pref
]
=
=
=
undefined
)
{
if
(
Preferences
.
isSet
(
pref
)
)
{
changed
=
true
;
Preferences
.
reset
(
pref
)
;
}
}
else
if
(
Preferences
.
get
(
pref
)
!
=
prefs
[
pref
]
)
{
Preferences
.
set
(
pref
prefs
[
pref
]
)
;
changed
=
true
;
}
}
if
(
changed
&
&
typeof
setting
.
onPrefsChanged
=
=
"
function
"
)
{
setting
.
onPrefsChanged
(
item
)
;
}
Management
.
emit
(
extension
-
setting
-
changed
:
{
name
}
)
;
}
async
function
processSetting
(
id
name
action
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
expectedItem
=
ExtensionSettingsStore
.
getSetting
(
STORE_TYPE
name
)
;
let
item
=
ExtensionSettingsStore
[
action
]
(
id
STORE_TYPE
name
)
;
if
(
item
)
{
let
setting
=
settingsMap
.
get
(
name
)
;
let
expectedPrefs
=
expectedItem
.
initialValue
|
|
setting
.
setCallback
(
expectedItem
.
value
)
;
if
(
Object
.
keys
(
expectedPrefs
)
.
some
(
pref
=
>
expectedPrefs
[
pref
]
&
&
Preferences
.
get
(
pref
)
!
=
expectedPrefs
[
pref
]
)
)
{
return
false
;
}
setPrefs
(
name
setting
item
)
;
return
true
;
}
return
false
;
}
this
.
ExtensionPreferencesManager
=
{
addSetting
(
name
setting
)
{
settingsMap
.
set
(
name
setting
)
;
}
getDefaultValue
(
prefName
)
{
return
defaultPreferences
.
get
(
prefName
)
;
}
async
setSetting
(
id
name
value
)
{
let
setting
=
settingsMap
.
get
(
name
)
;
await
ExtensionSettingsStore
.
initialize
(
)
;
let
item
=
await
ExtensionSettingsStore
.
addSetting
(
id
STORE_TYPE
name
value
initialValueCallback
.
bind
(
setting
)
name
settingsUpdate
.
bind
(
setting
)
)
;
if
(
item
)
{
setPrefs
(
name
setting
item
)
;
return
true
;
}
return
false
;
}
disableSetting
(
id
name
)
{
return
processSetting
(
id
name
"
disable
"
)
;
}
enableSetting
(
id
name
)
{
return
processSetting
(
id
name
"
enable
"
)
;
}
removeSetting
(
id
name
)
{
return
processSetting
(
id
name
"
removeSetting
"
)
;
}
async
disableAll
(
id
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
settings
=
ExtensionSettingsStore
.
getAllForExtension
(
id
STORE_TYPE
)
;
let
disablePromises
=
[
]
;
for
(
let
name
of
settings
)
{
disablePromises
.
push
(
this
.
disableSetting
(
id
name
)
)
;
}
await
Promise
.
all
(
disablePromises
)
;
}
async
enableAll
(
id
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
settings
=
ExtensionSettingsStore
.
getAllForExtension
(
id
STORE_TYPE
)
;
let
enablePromises
=
[
]
;
for
(
let
name
of
settings
)
{
enablePromises
.
push
(
this
.
enableSetting
(
id
name
)
)
;
}
await
Promise
.
all
(
enablePromises
)
;
}
async
removeAll
(
id
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
settings
=
ExtensionSettingsStore
.
getAllForExtension
(
id
STORE_TYPE
)
;
let
removePromises
=
[
]
;
for
(
let
name
of
settings
)
{
removePromises
.
push
(
this
.
removeSetting
(
id
name
)
)
;
}
await
Promise
.
all
(
removePromises
)
;
}
async
getSetting
(
name
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
return
ExtensionSettingsStore
.
getSetting
(
STORE_TYPE
name
)
;
}
async
getLevelOfControl
(
id
name
storeType
=
STORE_TYPE
)
{
if
(
storeType
=
=
=
STORE_TYPE
)
{
let
setting
=
settingsMap
.
get
(
name
)
;
if
(
!
setting
)
{
return
"
not_controllable
"
;
}
for
(
let
prefName
of
setting
.
prefNames
)
{
if
(
Preferences
.
locked
(
prefName
)
)
{
return
"
not_controllable
"
;
}
}
}
await
ExtensionSettingsStore
.
initialize
(
)
;
return
ExtensionSettingsStore
.
getLevelOfControl
(
id
storeType
name
)
;
}
getSettingsAPI
(
extensionId
name
callback
storeType
readOnly
=
false
validate
=
(
)
=
>
{
}
)
{
if
(
arguments
.
length
>
1
)
{
Services
.
console
.
logStringMessage
(
ExtensionPreferencesManager
.
getSettingsAPI
for
{
name
}
should
be
updated
to
use
a
single
paramater
object
.
)
;
}
return
ExtensionPreferencesManager
.
_getSettingsAPI
(
arguments
.
length
=
=
=
1
?
extensionId
:
{
extensionId
name
callback
storeType
readOnly
validate
}
)
;
}
_getSettingsAPI
(
params
)
{
let
{
extensionId
context
name
callback
storeType
readOnly
=
false
onChange
validate
=
(
)
=
>
{
}
}
=
params
;
if
(
!
extensionId
)
{
extensionId
=
context
.
extension
.
id
;
}
const
checkScope
=
details
=
>
{
let
{
scope
}
=
details
;
if
(
scope
&
&
scope
!
=
=
"
regular
"
)
{
throw
new
ExtensionError
(
Firefox
does
not
support
the
{
scope
}
settings
scope
.
)
;
}
}
;
let
settingsAPI
=
{
async
get
(
details
)
{
validate
(
)
;
let
levelOfControl
=
details
.
incognito
?
"
not_controllable
"
:
await
ExtensionPreferencesManager
.
getLevelOfControl
(
extensionId
name
storeType
)
;
levelOfControl
=
readOnly
&
&
levelOfControl
=
=
=
"
controllable_by_this_extension
"
?
"
not_controllable
"
:
levelOfControl
;
return
{
levelOfControl
value
:
await
callback
(
)
}
;
}
set
(
details
)
{
validate
(
)
;
checkScope
(
details
)
;
if
(
!
readOnly
)
{
return
ExtensionPreferencesManager
.
setSetting
(
extensionId
name
details
.
value
)
;
}
return
false
;
}
clear
(
details
)
{
validate
(
)
;
checkScope
(
details
)
;
if
(
!
readOnly
)
{
return
ExtensionPreferencesManager
.
removeSetting
(
extensionId
name
)
;
}
return
false
;
}
onChange
}
;
if
(
onChange
=
=
=
undefined
&
&
context
)
{
let
setting
=
settingsMap
.
get
(
name
)
;
if
(
!
setting
)
{
Services
.
console
.
logStringMessage
(
ExtensionPreferencesManager
API
{
name
}
created
but
addSetting
was
not
called
.
)
;
return
settingsAPI
;
}
settingsAPI
.
onChange
=
new
ExtensionCommon
.
EventManager
(
{
context
name
:
{
name
}
.
onChange
register
:
fire
=
>
{
let
listener
=
async
(
)
=
>
{
fire
.
async
(
await
settingsAPI
.
get
(
{
}
)
)
;
}
;
Management
.
on
(
extension
-
setting
-
changed
:
{
name
}
listener
)
;
return
(
)
=
>
{
Management
.
off
(
extension
-
setting
-
changed
:
{
name
}
listener
)
;
}
;
}
}
)
.
api
(
)
;
}
return
settingsAPI
;
}
}
;
