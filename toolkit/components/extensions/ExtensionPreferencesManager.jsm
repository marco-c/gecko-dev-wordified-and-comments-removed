"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExtensionPreferencesManager
"
]
;
const
{
Management
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
{
}
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionSettingsStore
"
"
resource
:
/
/
gre
/
modules
/
ExtensionSettingsStore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
defaultPreferences
"
function
(
)
{
return
new
Preferences
(
{
defaultBranch
:
true
}
)
;
}
)
;
Management
.
on
(
"
uninstall
"
(
type
{
id
}
)
=
>
{
ExtensionPreferencesManager
.
removeAll
(
id
)
;
}
)
;
Management
.
on
(
"
shutdown
"
(
type
extension
)
=
>
{
if
(
extension
.
shutdownReason
=
=
"
ADDON_DISABLE
"
)
{
this
.
ExtensionPreferencesManager
.
disableAll
(
extension
.
id
)
;
}
}
)
;
Management
.
on
(
"
startup
"
async
(
type
extension
)
=
>
{
if
(
extension
.
startupReason
=
=
"
ADDON_ENABLE
"
)
{
this
.
ExtensionPreferencesManager
.
enableAll
(
extension
.
id
)
;
}
}
)
;
const
STORE_TYPE
=
"
prefs
"
;
let
settingsMap
=
new
Map
(
)
;
function
initialValueCallback
(
)
{
let
initialValue
=
{
}
;
for
(
let
pref
of
this
.
prefNames
)
{
initialValue
[
pref
]
=
Preferences
.
get
(
pref
)
;
}
return
initialValue
;
}
function
setPrefs
(
setting
item
)
{
let
prefs
=
item
.
initialValue
|
|
setting
.
setCallback
(
item
.
value
)
;
let
changed
=
false
;
for
(
let
pref
in
prefs
)
{
if
(
prefs
[
pref
]
=
=
=
undefined
)
{
if
(
Preferences
.
isSet
(
pref
)
)
{
changed
=
true
;
Preferences
.
reset
(
pref
)
;
}
}
else
if
(
Preferences
.
get
(
pref
)
!
=
prefs
[
pref
]
)
{
Preferences
.
set
(
pref
prefs
[
pref
]
)
;
changed
=
true
;
}
}
if
(
changed
&
&
typeof
setting
.
onPrefsChanged
=
=
"
function
"
)
{
setting
.
onPrefsChanged
(
item
)
;
}
}
async
function
processSetting
(
id
name
action
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
expectedItem
=
ExtensionSettingsStore
.
getSetting
(
STORE_TYPE
name
)
;
let
item
=
ExtensionSettingsStore
[
action
]
(
id
STORE_TYPE
name
)
;
if
(
item
)
{
let
setting
=
settingsMap
.
get
(
name
)
;
let
expectedPrefs
=
expectedItem
.
initialValue
|
|
setting
.
setCallback
(
expectedItem
.
value
)
;
if
(
Object
.
keys
(
expectedPrefs
)
.
some
(
pref
=
>
(
expectedPrefs
[
pref
]
&
&
Preferences
.
get
(
pref
)
!
=
expectedPrefs
[
pref
]
)
)
)
{
return
false
;
}
setPrefs
(
setting
item
)
;
return
true
;
}
return
false
;
}
this
.
ExtensionPreferencesManager
=
{
addSetting
(
name
setting
)
{
settingsMap
.
set
(
name
setting
)
;
}
getDefaultValue
(
prefName
)
{
return
defaultPreferences
.
get
(
prefName
)
;
}
async
setSetting
(
id
name
value
)
{
let
setting
=
settingsMap
.
get
(
name
)
;
await
ExtensionSettingsStore
.
initialize
(
)
;
let
item
=
await
ExtensionSettingsStore
.
addSetting
(
id
STORE_TYPE
name
value
initialValueCallback
.
bind
(
setting
)
)
;
if
(
item
)
{
setPrefs
(
setting
item
)
;
return
true
;
}
return
false
;
}
disableSetting
(
id
name
)
{
return
processSetting
(
id
name
"
disable
"
)
;
}
enableSetting
(
id
name
)
{
return
processSetting
(
id
name
"
enable
"
)
;
}
removeSetting
(
id
name
)
{
return
processSetting
(
id
name
"
removeSetting
"
)
;
}
async
disableAll
(
id
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
settings
=
ExtensionSettingsStore
.
getAllForExtension
(
id
STORE_TYPE
)
;
let
disablePromises
=
[
]
;
for
(
let
name
of
settings
)
{
disablePromises
.
push
(
this
.
disableSetting
(
id
name
)
)
;
}
await
Promise
.
all
(
disablePromises
)
;
}
async
enableAll
(
id
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
settings
=
ExtensionSettingsStore
.
getAllForExtension
(
id
STORE_TYPE
)
;
let
enablePromises
=
[
]
;
for
(
let
name
of
settings
)
{
enablePromises
.
push
(
this
.
enableSetting
(
id
name
)
)
;
}
await
Promise
.
all
(
enablePromises
)
;
}
async
removeAll
(
id
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
settings
=
ExtensionSettingsStore
.
getAllForExtension
(
id
STORE_TYPE
)
;
let
removePromises
=
[
]
;
for
(
let
name
of
settings
)
{
removePromises
.
push
(
this
.
removeSetting
(
id
name
)
)
;
}
await
Promise
.
all
(
removePromises
)
;
}
async
getSetting
(
name
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
return
ExtensionSettingsStore
.
getSetting
(
STORE_TYPE
name
)
;
}
async
getLevelOfControl
(
id
name
storeType
=
STORE_TYPE
)
{
if
(
storeType
=
=
=
STORE_TYPE
)
{
let
setting
=
settingsMap
.
get
(
name
)
;
if
(
!
setting
)
{
return
"
not_controllable
"
;
}
for
(
let
prefName
of
setting
.
prefNames
)
{
if
(
Preferences
.
locked
(
prefName
)
)
{
return
"
not_controllable
"
;
}
}
}
await
ExtensionSettingsStore
.
initialize
(
)
;
return
ExtensionSettingsStore
.
getLevelOfControl
(
id
storeType
name
)
;
}
getSettingsAPI
(
extensionId
name
callback
storeType
readOnly
=
false
validate
=
(
)
=
>
{
}
)
{
return
{
async
get
(
details
)
{
validate
(
)
;
let
levelOfControl
=
details
.
incognito
?
"
not_controllable
"
:
await
ExtensionPreferencesManager
.
getLevelOfControl
(
extensionId
name
storeType
)
;
levelOfControl
=
(
readOnly
&
&
levelOfControl
=
=
=
"
controllable_by_this_extension
"
)
?
"
not_controllable
"
:
levelOfControl
;
return
{
levelOfControl
value
:
await
callback
(
)
}
;
}
set
(
details
)
{
validate
(
)
;
if
(
!
readOnly
)
{
return
ExtensionPreferencesManager
.
setSetting
(
extensionId
name
details
.
value
)
;
}
return
false
;
}
clear
(
details
)
{
validate
(
)
;
if
(
!
readOnly
)
{
return
ExtensionPreferencesManager
.
removeSetting
(
extensionId
name
)
;
}
return
false
;
}
}
;
}
}
;
