"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionPreferencesManager
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionSettingsStore
"
"
resource
:
/
/
gre
/
modules
/
ExtensionSettingsStore
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
defaultPreferences
"
function
(
)
{
return
new
Preferences
(
{
defaultBranch
:
true
}
)
;
}
)
;
const
STORE_TYPE
=
"
prefs
"
;
let
settingsMap
=
new
Map
(
)
;
function
initialValueCallback
(
)
{
let
initialValue
=
{
}
;
for
(
let
pref
of
this
.
prefNames
)
{
initialValue
[
pref
]
=
Preferences
.
get
(
pref
)
;
}
return
initialValue
;
}
function
setPrefs
(
prefsObject
)
{
for
(
let
pref
in
prefsObject
)
{
if
(
prefsObject
[
pref
]
=
=
=
undefined
)
{
Preferences
.
reset
(
pref
)
;
}
else
{
Preferences
.
set
(
pref
prefsObject
[
pref
]
)
;
}
}
}
this
.
ExtensionPreferencesManager
=
{
addSetting
(
name
setting
)
{
settingsMap
.
set
(
name
setting
)
;
}
getDefaultValue
(
prefName
)
{
return
defaultPreferences
.
get
(
prefName
)
;
}
async
setSetting
(
extension
name
value
)
{
let
setting
=
settingsMap
.
get
(
name
)
;
let
item
=
await
ExtensionSettingsStore
.
addSetting
(
extension
STORE_TYPE
name
value
initialValueCallback
.
bind
(
setting
)
)
;
if
(
item
)
{
let
prefs
=
await
setting
.
setCallback
(
item
.
value
)
;
setPrefs
(
prefs
)
;
return
true
;
}
return
false
;
}
async
unsetSetting
(
extension
name
)
{
let
item
=
await
ExtensionSettingsStore
.
removeSetting
(
extension
STORE_TYPE
name
)
;
if
(
item
)
{
let
prefs
=
item
.
initialValue
|
|
await
settingsMap
.
get
(
name
)
.
setCallback
(
item
.
value
)
;
setPrefs
(
prefs
)
;
}
}
async
unsetAll
(
extension
)
{
let
settings
=
await
ExtensionSettingsStore
.
getAllForExtension
(
extension
STORE_TYPE
)
;
for
(
let
name
of
settings
)
{
await
this
.
unsetSetting
(
extension
name
)
;
}
}
async
getLevelOfControl
(
extension
name
)
{
for
(
let
prefName
of
settingsMap
.
get
(
name
)
.
prefNames
)
{
if
(
Preferences
.
locked
(
prefName
)
)
{
return
"
not_controllable
"
;
}
}
return
await
ExtensionSettingsStore
.
getLevelOfControl
(
extension
STORE_TYPE
name
)
;
}
}
;
