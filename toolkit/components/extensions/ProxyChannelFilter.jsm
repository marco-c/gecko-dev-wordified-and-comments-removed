"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ProxyChannelFilter
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionParent
"
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
ProxyService
"
"
mozilla
.
org
/
network
/
protocol
-
proxy
-
service
;
1
"
"
nsIProtocolProxyService
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
tabTracker
"
(
)
=
>
{
return
ExtensionParent
.
apiManager
.
global
.
tabTracker
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
getCookieStoreIdForOriginAttributes
"
(
)
=
>
{
return
ExtensionParent
.
apiManager
.
global
.
getCookieStoreIdForOriginAttributes
;
}
)
;
const
{
TRANSPARENT_PROXY_RESOLVES_HOST
}
=
Ci
.
nsIProxyInfo
;
const
PROXY_TIMEOUT_SEC
=
10
;
const
{
ExtensionError
}
=
ExtensionUtils
;
const
PROXY_TYPES
=
Object
.
freeze
(
{
DIRECT
:
"
direct
"
HTTPS
:
"
https
"
PROXY
:
"
http
"
HTTP
:
"
http
"
SOCKS
:
"
socks
"
SOCKS4
:
"
socks4
"
}
)
;
const
ProxyInfoData
=
{
validate
(
proxyData
)
{
if
(
proxyData
.
type
&
&
proxyData
.
type
.
toLowerCase
(
)
=
=
=
"
direct
"
)
{
return
{
type
:
proxyData
.
type
}
;
}
for
(
let
prop
of
[
"
type
"
"
host
"
"
port
"
"
username
"
"
password
"
"
proxyDNS
"
"
failoverTimeout
"
"
proxyAuthorizationHeader
"
"
connectionIsolationKey
"
]
)
{
this
[
prop
]
(
proxyData
)
;
}
return
proxyData
;
}
type
(
proxyData
)
{
let
{
type
}
=
proxyData
;
if
(
typeof
type
!
=
=
"
string
"
|
|
!
PROXY_TYPES
.
hasOwnProperty
(
type
.
toUpperCase
(
)
)
)
{
throw
new
ExtensionError
(
ProxyInfoData
:
Invalid
proxy
server
type
:
"
{
type
}
"
)
;
}
proxyData
.
type
=
PROXY_TYPES
[
type
.
toUpperCase
(
)
]
;
}
host
(
proxyData
)
{
let
{
host
}
=
proxyData
;
if
(
typeof
host
!
=
=
"
string
"
|
|
host
.
includes
(
"
"
)
)
{
throw
new
ExtensionError
(
ProxyInfoData
:
Invalid
proxy
server
host
:
"
{
host
}
"
)
;
}
if
(
!
host
.
length
)
{
throw
new
ExtensionError
(
"
ProxyInfoData
:
Proxy
server
host
cannot
be
empty
"
)
;
}
proxyData
.
host
=
host
;
}
port
(
proxyData
)
{
let
port
=
Number
.
parseInt
(
proxyData
.
port
10
)
;
if
(
!
Number
.
isInteger
(
port
)
)
{
throw
new
ExtensionError
(
ProxyInfoData
:
Invalid
proxy
server
port
:
"
{
port
}
"
)
;
}
if
(
port
<
1
|
|
port
>
0xffff
)
{
throw
new
ExtensionError
(
ProxyInfoData
:
Proxy
server
port
{
port
}
outside
range
1
to
65535
)
;
}
proxyData
.
port
=
port
;
}
username
(
proxyData
)
{
let
{
username
}
=
proxyData
;
if
(
username
!
=
=
undefined
&
&
typeof
username
!
=
=
"
string
"
)
{
throw
new
ExtensionError
(
ProxyInfoData
:
Invalid
proxy
server
username
:
"
{
username
}
"
)
;
}
}
password
(
proxyData
)
{
let
{
password
}
=
proxyData
;
if
(
password
!
=
=
undefined
&
&
typeof
password
!
=
=
"
string
"
)
{
throw
new
ExtensionError
(
ProxyInfoData
:
Invalid
proxy
server
password
:
"
{
password
}
"
)
;
}
}
proxyDNS
(
proxyData
)
{
let
{
proxyDNS
type
}
=
proxyData
;
if
(
proxyDNS
!
=
=
undefined
)
{
if
(
typeof
proxyDNS
!
=
=
"
boolean
"
)
{
throw
new
ExtensionError
(
ProxyInfoData
:
Invalid
proxyDNS
value
:
"
{
proxyDNS
}
"
)
;
}
if
(
proxyDNS
&
&
type
!
=
=
PROXY_TYPES
.
SOCKS
&
&
type
!
=
=
PROXY_TYPES
.
SOCKS4
)
{
throw
new
ExtensionError
(
ProxyInfoData
:
proxyDNS
can
only
be
true
for
SOCKS
proxy
servers
)
;
}
}
}
failoverTimeout
(
proxyData
)
{
let
{
failoverTimeout
}
=
proxyData
;
if
(
failoverTimeout
!
=
=
undefined
&
&
(
!
Number
.
isInteger
(
failoverTimeout
)
|
|
failoverTimeout
<
1
)
)
{
throw
new
ExtensionError
(
ProxyInfoData
:
Invalid
failover
timeout
:
"
{
failoverTimeout
}
"
)
;
}
}
proxyAuthorizationHeader
(
proxyData
)
{
let
{
proxyauthorizationheader
}
=
proxyData
;
if
(
proxyauthorizationheader
!
=
=
undefined
&
&
typeof
username
!
=
=
"
string
"
)
{
throw
new
ExtensionError
(
ProxyInfoData
:
Invalid
proxy
server
authorization
header
:
"
{
proxyauthorizationheader
}
"
)
;
}
}
connectionIsolationKey
(
proxyData
)
{
let
{
connectionisolationkey
}
=
proxyData
;
if
(
connectionisolationkey
!
=
=
undefined
&
&
typeof
username
!
=
=
"
string
"
)
{
throw
new
ExtensionError
(
ProxyInfoData
:
Invalid
proxy
server
authorization
header
:
"
{
connectionisolationkey
}
"
)
;
}
}
createProxyInfoFromData
(
proxyDataList
defaultProxyInfo
proxyDataListIndex
=
0
)
{
if
(
proxyDataListIndex
>
=
proxyDataList
.
length
)
{
return
defaultProxyInfo
;
}
let
proxyData
=
proxyDataList
[
proxyDataListIndex
]
;
if
(
proxyData
=
=
null
)
{
return
null
;
}
let
{
type
host
port
username
password
proxyDNS
failoverTimeout
proxyAuthorizationHeader
connectionIsolationKey
}
=
ProxyInfoData
.
validate
(
proxyData
)
;
if
(
type
=
=
=
PROXY_TYPES
.
DIRECT
&
&
defaultProxyInfo
)
{
return
defaultProxyInfo
;
}
let
failoverProxy
=
this
.
createProxyInfoFromData
(
proxyDataList
defaultProxyInfo
proxyDataListIndex
+
1
)
;
if
(
type
=
=
=
PROXY_TYPES
.
SOCKS
|
|
type
=
=
=
PROXY_TYPES
.
SOCKS4
)
{
return
ProxyService
.
newProxyInfoWithAuth
(
type
host
port
username
password
proxyAuthorizationHeader
connectionIsolationKey
proxyDNS
?
TRANSPARENT_PROXY_RESOLVES_HOST
:
0
failoverTimeout
?
failoverTimeout
:
PROXY_TIMEOUT_SEC
failoverProxy
)
;
}
return
ProxyService
.
newProxyInfo
(
type
host
port
proxyAuthorizationHeader
connectionIsolationKey
proxyDNS
?
TRANSPARENT_PROXY_RESOLVES_HOST
:
0
failoverTimeout
?
failoverTimeout
:
PROXY_TIMEOUT_SEC
failoverProxy
)
;
}
}
;
function
normalizeFilter
(
filter
)
{
if
(
!
filter
)
{
filter
=
{
}
;
}
return
{
urls
:
filter
.
urls
|
|
null
types
:
filter
.
types
|
|
null
incognito
:
filter
.
incognito
!
=
=
undefined
?
filter
.
incognito
:
null
}
;
}
class
ProxyChannelFilter
{
constructor
(
context
extension
listener
filter
extraInfoSpec
)
{
this
.
context
=
context
;
this
.
extension
=
extension
;
this
.
filter
=
normalizeFilter
(
filter
)
;
this
.
listener
=
listener
;
this
.
extraInfoSpec
=
extraInfoSpec
|
|
[
]
;
ProxyService
.
registerChannelFilter
(
this
0
)
;
}
getRequestData
(
channel
extraData
)
{
let
originAttributes
=
channel
.
loadInfo
&
&
channel
.
loadInfo
.
originAttributes
;
let
data
=
{
requestId
:
String
(
channel
.
id
)
url
:
channel
.
finalURL
method
:
channel
.
method
type
:
channel
.
type
fromCache
:
!
!
channel
.
fromCache
incognito
:
originAttributes
&
&
originAttributes
.
privateBrowsingId
>
0
thirdParty
:
channel
.
thirdParty
originUrl
:
channel
.
originURL
|
|
undefined
documentUrl
:
channel
.
documentURL
|
|
undefined
frameId
:
channel
.
windowId
parentFrameId
:
channel
.
parentWindowId
frameAncestors
:
channel
.
frameAncestors
|
|
undefined
timeStamp
:
Date
.
now
(
)
.
.
.
extraData
}
;
if
(
originAttributes
&
&
this
.
extension
.
hasPermission
(
"
cookies
"
)
)
{
data
.
cookieStoreId
=
getCookieStoreIdForOriginAttributes
(
originAttributes
)
;
}
if
(
this
.
extraInfoSpec
.
includes
(
"
requestHeaders
"
)
)
{
data
.
requestHeaders
=
channel
.
getRequestHeaders
(
)
;
}
if
(
this
.
extension
.
isPrivileged
)
{
data
.
urlClassification
=
{
firstParty
:
channel
.
urlClassification
.
firstParty
.
filter
(
c
=
>
!
c
.
startsWith
(
"
socialtracking
"
)
)
thirdParty
:
channel
.
urlClassification
.
thirdParty
.
filter
(
c
=
>
!
c
.
startsWith
(
"
socialtracking
"
)
)
}
;
}
return
data
;
}
async
applyFilter
(
service
channel
defaultProxyInfo
proxyFilter
)
{
let
proxyInfo
;
try
{
let
wrapper
=
ChannelWrapper
.
get
(
channel
)
;
let
browserData
=
{
tabId
:
-
1
windowId
:
-
1
}
;
if
(
wrapper
.
browserElement
)
{
browserData
=
tabTracker
.
getBrowserData
(
wrapper
.
browserElement
)
;
}
let
{
filter
}
=
this
;
if
(
filter
.
tabId
!
=
null
&
&
browserData
.
tabId
!
=
=
filter
.
tabId
)
{
return
;
}
if
(
filter
.
windowId
!
=
null
&
&
browserData
.
windowId
!
=
=
filter
.
windowId
)
{
return
;
}
if
(
wrapper
.
matches
(
filter
this
.
extension
.
policy
{
isProxy
:
true
}
)
)
{
let
data
=
this
.
getRequestData
(
wrapper
{
tabId
:
browserData
.
tabId
}
)
;
let
ret
=
await
this
.
listener
(
data
)
;
if
(
ret
=
=
null
)
{
proxyInfo
=
ret
;
return
;
}
if
(
typeof
ret
!
=
=
"
object
"
)
{
throw
new
ExtensionError
(
"
ProxyInfoData
:
proxyData
must
be
an
object
or
array
of
objects
"
)
;
}
if
(
!
Array
.
isArray
(
ret
)
)
{
ret
=
[
ret
]
;
}
proxyInfo
=
ProxyInfoData
.
createProxyInfoFromData
(
ret
defaultProxyInfo
)
;
}
}
catch
(
e
)
{
if
(
!
this
.
context
)
{
this
.
extension
.
logError
(
proxy
-
error
before
extension
startup
:
{
e
}
)
;
return
;
}
let
error
=
this
.
context
.
normalizeError
(
e
)
;
this
.
extension
.
emit
(
"
proxy
-
error
"
{
message
:
error
.
message
fileName
:
error
.
fileName
lineNumber
:
error
.
lineNumber
stack
:
error
.
stack
}
)
;
}
finally
{
proxyFilter
.
onProxyFilterResult
(
proxyInfo
!
=
=
undefined
?
proxyInfo
:
defaultProxyInfo
)
;
}
}
destroy
(
)
{
ProxyService
.
unregisterFilter
(
this
)
;
}
}
