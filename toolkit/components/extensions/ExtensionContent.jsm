"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExtensionContent
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ExtensionProcessScript
:
"
resource
:
/
/
gre
/
modules
/
ExtensionProcessScript
.
jsm
"
ExtensionTelemetry
:
"
resource
:
/
/
gre
/
modules
/
ExtensionTelemetry
.
jsm
"
LanguageDetector
:
"
resource
:
/
/
/
modules
/
translation
/
LanguageDetector
.
jsm
"
MessageChannel
:
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
Schemas
:
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
WebNavigationFrames
:
"
resource
:
/
/
gre
/
modules
/
WebNavigationFrames
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
styleSheetService
"
"
mozilla
.
org
/
content
/
style
-
sheet
-
service
;
1
"
"
nsIStyleSheetService
"
)
;
const
Timer
=
Components
.
Constructor
(
"
mozilla
.
org
/
timer
;
1
"
"
nsITimer
"
"
initWithCallback
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionChild
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
crypto
"
"
TextEncoder
"
]
)
;
const
{
DefaultMap
DefaultWeakMap
getInnerWindowID
getWinUtils
promiseDocumentIdle
promiseDocumentLoaded
promiseDocumentReady
}
=
ExtensionUtils
;
const
{
BaseContext
CanOfAPIs
SchemaAPIManager
defineLazyGetter
runSafeSyncWithoutClone
}
=
ExtensionCommon
;
const
{
BrowserExtensionContent
ChildAPIManager
Messenger
}
=
ExtensionChild
;
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
ExtensionCommon
.
getConsole
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
isContentScriptProcess
"
(
)
=
>
{
return
Services
.
appinfo
.
processType
=
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
|
|
!
WebExtensionPolicy
.
useRemoteWebExtensions
;
}
)
;
var
DocumentManager
;
const
CATEGORY_EXTENSION_SCRIPTS_CONTENT
=
"
webextension
-
scripts
-
content
"
;
var
apiManager
=
new
class
extends
SchemaAPIManager
{
constructor
(
)
{
super
(
"
content
"
Schemas
)
;
this
.
initialized
=
false
;
}
lazyInit
(
)
{
if
(
!
this
.
initialized
)
{
this
.
initialized
=
true
;
this
.
initGlobal
(
)
;
for
(
let
{
value
}
of
Services
.
catMan
.
enumerateCategory
(
CATEGORY_EXTENSION_SCRIPTS_CONTENT
)
)
{
this
.
loadScript
(
value
)
;
}
}
}
}
(
)
;
const
SCRIPT_EXPIRY_TIMEOUT_MS
=
5
*
60
*
1000
;
const
SCRIPT_CLEAR_TIMEOUT_MS
=
5
*
1000
;
const
CSS_EXPIRY_TIMEOUT_MS
=
30
*
60
*
1000
;
const
CSSCODE_EXPIRY_TIMEOUT_MS
=
10
*
60
*
1000
;
const
scriptCaches
=
new
WeakSet
(
)
;
const
sheetCacheDocuments
=
new
DefaultWeakMap
(
(
)
=
>
new
WeakSet
(
)
)
;
class
CacheMap
extends
DefaultMap
{
constructor
(
timeout
getter
extension
)
{
super
(
getter
)
;
this
.
expiryTimeout
=
timeout
;
scriptCaches
.
add
(
this
)
;
extension
.
once
(
"
shutdown
"
(
)
=
>
{
this
.
clear
(
-
1
)
;
}
)
;
}
get
(
url
)
{
let
promise
=
super
.
get
(
url
)
;
promise
.
lastUsed
=
Date
.
now
(
)
;
if
(
promise
.
timer
)
{
promise
.
timer
.
cancel
(
)
;
}
promise
.
timer
=
Timer
(
this
.
delete
.
bind
(
this
url
)
this
.
expiryTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
return
promise
;
}
delete
(
url
)
{
if
(
this
.
has
(
url
)
)
{
super
.
get
(
url
)
.
timer
.
cancel
(
)
;
}
super
.
delete
(
url
)
;
}
clear
(
timeout
=
SCRIPT_CLEAR_TIMEOUT_MS
)
{
let
now
=
Date
.
now
(
)
;
for
(
let
[
url
promise
]
of
this
.
entries
(
)
)
{
if
(
timeout
=
=
=
-
1
|
|
(
now
-
promise
.
lastUsed
>
=
timeout
)
)
{
this
.
delete
(
url
)
;
}
}
}
}
class
ScriptCache
extends
CacheMap
{
constructor
(
options
extension
)
{
super
(
SCRIPT_EXPIRY_TIMEOUT_MS
null
extension
)
;
this
.
options
=
options
;
}
defaultConstructor
(
url
)
{
let
promise
=
ChromeUtils
.
compileScript
(
url
this
.
options
)
;
promise
.
then
(
script
=
>
{
promise
.
script
=
script
;
}
)
;
return
promise
;
}
}
class
BaseCSSCache
extends
CacheMap
{
constructor
(
expiryTimeout
defaultConstructor
extension
)
{
super
(
expiryTimeout
defaultConstructor
extension
)
;
}
addDocument
(
key
document
)
{
sheetCacheDocuments
.
get
(
this
.
get
(
key
)
)
.
add
(
document
)
;
}
deleteDocument
(
key
document
)
{
sheetCacheDocuments
.
get
(
this
.
get
(
key
)
)
.
delete
(
document
)
;
}
delete
(
key
)
{
if
(
this
.
has
(
key
)
)
{
let
promise
=
this
.
get
(
key
)
;
let
docs
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
sheetCacheDocuments
.
get
(
promise
)
)
;
if
(
docs
.
length
)
{
return
;
}
}
super
.
delete
(
key
)
;
}
}
class
CSSCache
extends
BaseCSSCache
{
constructor
(
sheetType
extension
)
{
super
(
CSS_EXPIRY_TIMEOUT_MS
url
=
>
{
let
uri
=
Services
.
io
.
newURI
(
url
)
;
return
styleSheetService
.
preloadSheetAsync
(
uri
sheetType
)
.
then
(
sheet
=
>
{
return
{
url
sheet
}
;
}
)
;
}
extension
)
;
}
}
class
CSSCodeCache
extends
BaseCSSCache
{
constructor
(
sheetType
extension
)
{
super
(
CSSCODE_EXPIRY_TIMEOUT_MS
(
hash
)
=
>
{
if
(
!
this
.
has
(
hash
)
)
{
throw
new
Error
(
"
Unexistent
cached
cssCode
stylesheet
:
"
+
Error
(
)
.
stack
)
;
}
return
super
.
get
(
hash
)
;
}
extension
)
;
this
.
sheetType
=
sheetType
;
}
addCSSCode
(
hash
cssCode
)
{
if
(
this
.
has
(
hash
)
)
{
return
;
}
const
uri
=
Services
.
io
.
newURI
(
"
data
:
text
/
css
;
charset
=
utf
-
8
"
+
encodeURIComponent
(
cssCode
)
)
;
const
value
=
styleSheetService
.
preloadSheetAsync
(
uri
this
.
sheetType
)
.
then
(
sheet
=
>
{
return
{
sheet
uri
}
;
}
)
;
super
.
set
(
hash
value
)
;
}
}
defineLazyGetter
(
BrowserExtensionContent
.
prototype
"
staticScripts
"
function
(
)
{
return
new
ScriptCache
(
{
hasReturnValue
:
false
}
this
)
;
}
)
;
defineLazyGetter
(
BrowserExtensionContent
.
prototype
"
dynamicScripts
"
function
(
)
{
return
new
ScriptCache
(
{
hasReturnValue
:
true
}
this
)
;
}
)
;
defineLazyGetter
(
BrowserExtensionContent
.
prototype
"
userCSS
"
function
(
)
{
return
new
CSSCache
(
Ci
.
nsIStyleSheetService
.
USER_SHEET
this
)
;
}
)
;
defineLazyGetter
(
BrowserExtensionContent
.
prototype
"
authorCSS
"
function
(
)
{
return
new
CSSCache
(
Ci
.
nsIStyleSheetService
.
AUTHOR_SHEET
this
)
;
}
)
;
defineLazyGetter
(
BrowserExtensionContent
.
prototype
"
userCSSCode
"
function
(
)
{
return
new
CSSCodeCache
(
Ci
.
nsIStyleSheetService
.
USER_SHEET
this
)
;
}
)
;
defineLazyGetter
(
BrowserExtensionContent
.
prototype
"
authorCSSCode
"
function
(
)
{
return
new
CSSCodeCache
(
Ci
.
nsIStyleSheetService
.
AUTHOR_SHEET
this
)
;
}
)
;
class
Script
{
constructor
(
extension
matcher
)
{
this
.
extension
=
extension
;
this
.
matcher
=
matcher
;
this
.
runAt
=
this
.
matcher
.
runAt
;
this
.
js
=
this
.
matcher
.
jsPaths
;
this
.
css
=
this
.
matcher
.
cssPaths
.
slice
(
)
;
this
.
cssCodeHash
=
null
;
this
.
removeCSS
=
this
.
matcher
.
removeCSS
;
this
.
cssOrigin
=
this
.
matcher
.
cssOrigin
;
this
.
cssCache
=
extension
[
this
.
cssOrigin
=
=
=
"
user
"
?
"
userCSS
"
:
"
authorCSS
"
]
;
this
.
cssCodeCache
=
extension
[
this
.
cssOrigin
=
=
=
"
user
"
?
"
userCSSCode
"
:
"
authorCSSCode
"
]
;
this
.
scriptCache
=
extension
[
matcher
.
wantReturnValue
?
"
dynamicScripts
"
:
"
staticScripts
"
]
;
if
(
matcher
.
wantReturnValue
)
{
this
.
compileScripts
(
)
;
this
.
loadCSS
(
)
;
}
}
get
requiresCleanup
(
)
{
return
!
this
.
removeCSS
&
&
(
this
.
css
.
length
>
0
|
|
this
.
cssCodeHash
)
;
}
async
addCSSCode
(
cssCode
)
{
if
(
!
cssCode
)
{
return
;
}
const
buffer
=
await
crypto
.
subtle
.
digest
(
"
SHA
-
1
"
new
TextEncoder
(
)
.
encode
(
cssCode
)
)
;
this
.
cssCodeHash
=
String
.
fromCharCode
(
.
.
.
new
Uint16Array
(
buffer
)
)
;
this
.
cssCodeCache
.
addCSSCode
(
this
.
cssCodeHash
cssCode
)
;
}
compileScripts
(
)
{
return
this
.
js
.
map
(
url
=
>
this
.
scriptCache
.
get
(
url
)
)
;
}
loadCSS
(
)
{
return
this
.
css
.
map
(
url
=
>
this
.
cssCache
.
get
(
url
)
)
;
}
preload
(
)
{
this
.
loadCSS
(
)
;
this
.
compileScripts
(
)
;
}
cleanup
(
window
)
{
if
(
this
.
requiresCleanup
)
{
if
(
window
)
{
let
winUtils
=
getWinUtils
(
window
)
;
let
type
=
this
.
cssOrigin
=
=
=
"
user
"
?
winUtils
.
USER_SHEET
:
winUtils
.
AUTHOR_SHEET
;
for
(
let
url
of
this
.
css
)
{
this
.
cssCache
.
deleteDocument
(
url
window
.
document
)
;
runSafeSyncWithoutClone
(
winUtils
.
removeSheetUsingURIString
url
type
)
;
}
const
{
cssCodeHash
}
=
this
;
if
(
cssCodeHash
&
&
this
.
cssCodeCache
.
has
(
cssCodeHash
)
)
{
this
.
cssCodeCache
.
get
(
cssCodeHash
)
.
then
(
(
{
uri
}
)
=
>
{
runSafeSyncWithoutClone
(
winUtils
.
removeSheet
uri
type
)
;
}
)
;
this
.
cssCodeCache
.
deleteDocument
(
cssCodeHash
window
.
document
)
;
}
}
this
.
cssCodeCache
.
clear
(
CSSCODE_EXPIRY_TIMEOUT_MS
)
;
this
.
cssCache
.
clear
(
CSS_EXPIRY_TIMEOUT_MS
)
;
}
}
matchesWindow
(
window
)
{
return
this
.
matcher
.
matchesWindow
(
window
)
;
}
async
injectInto
(
window
)
{
if
(
!
isContentScriptProcess
)
{
return
;
}
let
context
=
this
.
extension
.
getContext
(
window
)
;
try
{
if
(
this
.
runAt
=
=
=
"
document_end
"
)
{
await
promiseDocumentReady
(
window
.
document
)
;
}
else
if
(
this
.
runAt
=
=
=
"
document_idle
"
)
{
await
Promise
.
race
(
[
promiseDocumentIdle
(
window
)
promiseDocumentLoaded
(
window
.
document
)
]
)
;
}
return
this
.
inject
(
context
)
;
}
catch
(
e
)
{
return
Promise
.
reject
(
context
.
normalizeError
(
e
)
)
;
}
}
async
inject
(
context
)
{
DocumentManager
.
lazyInit
(
)
;
if
(
this
.
requiresCleanup
)
{
context
.
addScript
(
this
)
;
}
const
{
cssCodeHash
}
=
this
;
let
cssPromise
;
if
(
this
.
css
.
length
|
|
cssCodeHash
)
{
let
window
=
context
.
contentWindow
;
let
winUtils
=
getWinUtils
(
window
)
;
let
type
=
this
.
cssOrigin
=
=
=
"
user
"
?
winUtils
.
USER_SHEET
:
winUtils
.
AUTHOR_SHEET
;
if
(
this
.
removeCSS
)
{
for
(
let
url
of
this
.
css
)
{
this
.
cssCache
.
deleteDocument
(
url
window
.
document
)
;
runSafeSyncWithoutClone
(
winUtils
.
removeSheetUsingURIString
url
type
)
;
}
if
(
cssCodeHash
&
&
this
.
cssCodeCache
.
has
(
cssCodeHash
)
)
{
const
{
uri
}
=
await
this
.
cssCodeCache
.
get
(
cssCodeHash
)
;
this
.
cssCodeCache
.
deleteDocument
(
cssCodeHash
window
.
document
)
;
runSafeSyncWithoutClone
(
winUtils
.
removeSheet
uri
type
)
;
}
}
else
{
cssPromise
=
Promise
.
all
(
this
.
loadCSS
(
)
)
.
then
(
sheets
=
>
{
let
window
=
context
.
contentWindow
;
if
(
!
window
)
{
return
;
}
for
(
let
{
url
sheet
}
of
sheets
)
{
this
.
cssCache
.
addDocument
(
url
window
.
document
)
;
runSafeSyncWithoutClone
(
winUtils
.
addSheet
sheet
type
)
;
}
}
)
;
if
(
cssCodeHash
)
{
cssPromise
=
cssPromise
.
then
(
async
(
)
=
>
{
const
{
sheet
}
=
await
this
.
cssCodeCache
.
get
(
cssCodeHash
)
;
this
.
cssCodeCache
.
addDocument
(
cssCodeHash
window
.
document
)
;
runSafeSyncWithoutClone
(
winUtils
.
addSheet
sheet
type
)
;
}
)
;
}
if
(
this
.
css
.
length
>
0
)
{
context
.
contentWindow
.
document
.
blockParsing
(
cssPromise
{
blockScriptCreated
:
false
}
)
;
}
}
}
let
scripts
=
this
.
getCompiledScripts
(
context
)
;
if
(
scripts
instanceof
Promise
)
{
scripts
=
await
scripts
;
}
let
result
;
const
{
extension
}
=
context
;
ExtensionTelemetry
.
contentScriptInjection
.
stopwatchStart
(
extension
context
)
;
try
{
for
(
let
script
of
scripts
)
{
result
=
script
.
executeInGlobal
(
context
.
cloneScope
)
;
}
if
(
this
.
matcher
.
jsCode
)
{
result
=
Cu
.
evalInSandbox
(
this
.
matcher
.
jsCode
context
.
cloneScope
"
latest
"
)
;
}
}
finally
{
ExtensionTelemetry
.
contentScriptInjection
.
stopwatchFinish
(
extension
context
)
;
}
await
cssPromise
;
return
result
;
}
getCompiledScripts
(
context
)
{
let
scriptPromises
=
this
.
compileScripts
(
)
;
let
scripts
=
scriptPromises
.
map
(
promise
=
>
promise
.
script
)
;
if
(
!
scripts
.
every
(
script
=
>
script
)
)
{
let
promise
=
Promise
.
all
(
scriptPromises
)
;
const
{
document
}
=
context
.
contentWindow
;
if
(
this
.
runAt
=
=
=
"
document_start
"
&
&
document
.
readyState
!
=
=
"
complete
"
)
{
document
.
blockParsing
(
promise
{
blockScriptCreated
:
false
}
)
;
}
return
promise
;
}
return
scripts
;
}
}
class
UserScript
extends
Script
{
constructor
(
extension
matcher
)
{
super
(
extension
matcher
)
;
this
.
scriptMetadata
=
matcher
.
userScriptOptions
.
scriptMetadata
;
this
.
apiScriptURL
=
extension
.
manifest
.
user_scripts
&
&
extension
.
manifest
.
user_scripts
.
api_script
;
if
(
this
.
apiScriptURL
)
{
this
.
js
=
[
this
.
apiScriptURL
]
.
concat
(
this
.
js
)
;
}
this
.
sandboxes
=
new
DefaultWeakMap
(
(
context
)
=
>
{
return
this
.
createSandbox
(
context
)
;
}
)
;
}
async
inject
(
context
)
{
const
{
extension
}
=
context
;
DocumentManager
.
lazyInit
(
)
;
let
scripts
=
this
.
getCompiledScripts
(
context
)
;
if
(
scripts
instanceof
Promise
)
{
scripts
=
await
scripts
;
}
let
apiScript
sandboxScripts
;
if
(
this
.
apiScriptURL
)
{
[
apiScript
.
.
.
sandboxScripts
]
=
scripts
;
}
else
{
sandboxScripts
=
scripts
;
}
if
(
apiScript
)
{
context
.
executeAPIScript
(
apiScript
)
;
}
ExtensionTelemetry
.
userScriptInjection
.
stopwatchStart
(
extension
context
)
;
try
{
let
userScriptSandbox
=
this
.
sandboxes
.
get
(
context
)
;
context
.
callOnClose
(
{
close
:
(
)
=
>
{
this
.
sandboxes
.
delete
(
context
)
;
Cu
.
nukeSandbox
(
userScriptSandbox
)
;
}
}
)
;
if
(
apiScript
)
{
context
.
userScriptsEvents
.
emit
(
"
on
-
before
-
script
"
this
.
scriptMetadata
userScriptSandbox
)
;
}
for
(
let
script
of
sandboxScripts
)
{
script
.
executeInGlobal
(
userScriptSandbox
)
;
}
}
finally
{
ExtensionTelemetry
.
userScriptInjection
.
stopwatchFinish
(
extension
context
)
;
}
}
createSandbox
(
context
)
{
const
{
contentWindow
}
=
context
;
const
contentPrincipal
=
contentWindow
.
document
.
nodePrincipal
;
const
ssm
=
Services
.
scriptSecurityManager
;
let
principal
;
if
(
ssm
.
isSystemPrincipal
(
contentPrincipal
)
)
{
principal
=
ssm
.
createNullPrincipal
(
contentPrincipal
.
originAttributes
)
;
}
else
{
principal
=
[
contentPrincipal
]
;
}
const
sandbox
=
Cu
.
Sandbox
(
principal
{
sandboxName
:
User
Script
registered
by
{
this
.
extension
.
policy
.
debugName
}
sandboxPrototype
:
contentWindow
sameZoneAs
:
contentWindow
wantXrays
:
true
wantGlobalProperties
:
[
"
XMLHttpRequest
"
"
fetch
"
]
originAttributes
:
contentPrincipal
.
originAttributes
metadata
:
{
"
inner
-
window
-
id
"
:
context
.
innerWindowID
addonId
:
this
.
extension
.
policy
.
id
}
}
)
;
return
sandbox
;
}
}
var
contentScripts
=
new
DefaultWeakMap
(
matcher
=
>
{
const
extension
=
ExtensionProcessScript
.
extensions
.
get
(
matcher
.
extension
)
;
if
(
"
userScriptOptions
"
in
matcher
)
{
return
new
UserScript
(
extension
matcher
)
;
}
return
new
Script
(
extension
matcher
)
;
}
)
;
class
ContentScriptContextChild
extends
BaseContext
{
constructor
(
extension
contentWindow
)
{
super
(
"
content_child
"
extension
)
;
this
.
setContentWindow
(
contentWindow
)
;
let
frameId
=
WebNavigationFrames
.
getFrameId
(
contentWindow
)
;
this
.
frameId
=
frameId
;
this
.
scripts
=
[
]
;
let
contentPrincipal
=
contentWindow
.
document
.
nodePrincipal
;
let
ssm
=
Services
.
scriptSecurityManager
;
let
attrs
=
contentPrincipal
.
originAttributes
;
let
extensionPrincipal
=
ssm
.
createCodebasePrincipal
(
this
.
extension
.
baseURI
attrs
)
;
this
.
isExtensionPage
=
contentPrincipal
.
equals
(
extensionPrincipal
)
;
if
(
this
.
isExtensionPage
)
{
this
.
sandbox
=
Cu
.
Sandbox
(
contentWindow
{
sandboxName
:
Web
-
Accessible
Extension
Page
{
extension
.
policy
.
debugName
}
sandboxPrototype
:
contentWindow
sameZoneAs
:
contentWindow
wantXrays
:
false
isWebExtensionContentScript
:
true
}
)
;
}
else
{
let
principal
;
if
(
ssm
.
isSystemPrincipal
(
contentPrincipal
)
)
{
principal
=
ssm
.
createNullPrincipal
(
attrs
)
;
}
else
{
principal
=
[
contentPrincipal
extensionPrincipal
]
;
}
let
metadata
=
{
"
inner
-
window
-
id
"
:
this
.
innerWindowID
addonId
:
extensionPrincipal
.
addonId
}
;
this
.
sandbox
=
Cu
.
Sandbox
(
principal
{
metadata
sandboxName
:
Content
Script
{
extension
.
policy
.
debugName
}
sandboxPrototype
:
contentWindow
sameZoneAs
:
contentWindow
wantXrays
:
true
isWebExtensionContentScript
:
true
wantExportHelpers
:
true
wantGlobalProperties
:
[
"
XMLHttpRequest
"
"
fetch
"
]
originAttributes
:
attrs
}
)
;
this
.
cloneScopePromise
=
this
.
sandbox
.
Promise
;
this
.
cloneScopeError
=
this
.
sandbox
.
Error
;
Cu
.
evalInSandbox
(
this
.
content
=
{
XMLHttpRequest
:
window
.
XMLHttpRequest
fetch
:
window
.
fetch
.
bind
(
window
)
}
;
window
.
JSON
=
JSON
;
window
.
XMLHttpRequest
=
XMLHttpRequest
;
window
.
fetch
=
fetch
;
this
.
sandbox
)
;
}
Object
.
defineProperty
(
this
"
principal
"
{
value
:
Cu
.
getObjectPrincipal
(
this
.
sandbox
)
enumerable
:
true
configurable
:
true
}
)
;
this
.
url
=
contentWindow
.
location
.
href
;
defineLazyGetter
(
this
"
chromeObj
"
(
)
=
>
{
let
chromeObj
=
Cu
.
createObjectIn
(
this
.
sandbox
)
;
this
.
childManager
.
inject
(
chromeObj
)
;
return
chromeObj
;
}
)
;
Schemas
.
exportLazyGetter
(
this
.
sandbox
"
browser
"
(
)
=
>
this
.
chromeObj
)
;
Schemas
.
exportLazyGetter
(
this
.
sandbox
"
chrome
"
(
)
=
>
this
.
chromeObj
)
;
this
.
hasUserScriptAPIs
=
false
;
defineLazyGetter
(
this
"
userScriptsEvents
"
(
)
=
>
{
return
new
ExtensionCommon
.
EventEmitter
(
)
;
}
)
;
}
injectAPI
(
)
{
if
(
!
this
.
isExtensionPage
)
{
throw
new
Error
(
"
Cannot
inject
extension
API
into
non
-
extension
window
"
)
;
}
Schemas
.
exportLazyGetter
(
this
.
contentWindow
"
browser
"
(
)
=
>
this
.
chromeObj
)
;
Schemas
.
exportLazyGetter
(
this
.
contentWindow
"
chrome
"
(
)
=
>
this
.
chromeObj
)
;
}
get
cloneScope
(
)
{
return
this
.
sandbox
;
}
async
executeAPIScript
(
apiScript
)
{
if
(
apiScript
&
&
!
this
.
hasUserScriptAPIs
)
{
this
.
hasUserScriptAPIs
=
true
;
apiScript
.
executeInGlobal
(
this
.
cloneScope
)
;
}
}
addScript
(
script
)
{
if
(
script
.
requiresCleanup
)
{
this
.
scripts
.
push
(
script
)
;
}
}
close
(
)
{
super
.
unload
(
)
;
for
(
let
script
of
this
.
scripts
)
{
script
.
cleanup
(
this
.
contentWindow
)
;
}
if
(
this
.
contentWindow
)
{
if
(
this
.
isExtensionPage
)
{
Cu
.
createObjectIn
(
this
.
contentWindow
{
defineAs
:
"
browser
"
}
)
;
Cu
.
createObjectIn
(
this
.
contentWindow
{
defineAs
:
"
chrome
"
}
)
;
}
}
Cu
.
nukeSandbox
(
this
.
sandbox
)
;
this
.
sandbox
=
null
;
}
}
defineLazyGetter
(
ContentScriptContextChild
.
prototype
"
messenger
"
function
(
)
{
let
sender
=
{
id
:
this
.
extension
.
id
frameId
:
this
.
frameId
url
:
this
.
url
}
;
let
filter
=
{
extensionId
:
this
.
extension
.
id
}
;
let
optionalFilter
=
{
frameId
:
this
.
frameId
}
;
return
new
Messenger
(
this
[
this
.
messageManager
]
sender
filter
optionalFilter
)
;
}
)
;
defineLazyGetter
(
ContentScriptContextChild
.
prototype
"
childManager
"
function
(
)
{
apiManager
.
lazyInit
(
)
;
let
localApis
=
{
}
;
let
can
=
new
CanOfAPIs
(
this
apiManager
localApis
)
;
let
childManager
=
new
ChildAPIManager
(
this
this
.
messageManager
can
{
envType
:
"
content_parent
"
url
:
this
.
url
}
)
;
this
.
callOnClose
(
childManager
)
;
return
childManager
;
}
)
;
DocumentManager
=
{
contexts
:
new
Map
(
)
initialized
:
false
lazyInit
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
initialized
=
true
;
Services
.
obs
.
addObserver
(
this
"
inner
-
window
-
destroyed
"
)
;
Services
.
obs
.
addObserver
(
this
"
memory
-
pressure
"
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
"
inner
-
window
-
destroyed
"
)
;
Services
.
obs
.
removeObserver
(
this
"
memory
-
pressure
"
)
;
}
observers
:
{
"
inner
-
window
-
destroyed
"
(
subject
topic
data
)
{
let
windowId
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
;
MessageChannel
.
abortResponses
(
{
innerWindowID
:
windowId
}
)
;
if
(
this
.
contexts
.
has
(
windowId
)
)
{
let
extensions
=
this
.
contexts
.
get
(
windowId
)
;
for
(
let
context
of
extensions
.
values
(
)
)
{
context
.
close
(
)
;
}
this
.
contexts
.
delete
(
windowId
)
;
}
}
"
memory
-
pressure
"
(
subject
topic
data
)
{
let
timeout
=
data
=
=
=
"
heap
-
minimize
"
?
0
:
undefined
;
for
(
let
cache
of
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
scriptCaches
)
)
{
cache
.
clear
(
timeout
)
;
}
}
}
observe
(
subject
topic
data
)
{
this
.
observers
[
topic
]
.
call
(
this
subject
topic
data
)
;
}
shutdownExtension
(
extension
)
{
for
(
let
extensions
of
this
.
contexts
.
values
(
)
)
{
let
context
=
extensions
.
get
(
extension
)
;
if
(
context
)
{
context
.
close
(
)
;
extensions
.
delete
(
extension
)
;
}
}
}
getContexts
(
window
)
{
let
winId
=
getInnerWindowID
(
window
)
;
let
extensions
=
this
.
contexts
.
get
(
winId
)
;
if
(
!
extensions
)
{
extensions
=
new
Map
(
)
;
this
.
contexts
.
set
(
winId
extensions
)
;
}
return
extensions
;
}
getContext
(
extensionId
window
)
{
for
(
let
[
extension
context
]
of
this
.
getContexts
(
window
)
)
{
if
(
extension
.
id
=
=
=
extensionId
)
{
return
context
;
}
}
}
getContentScriptGlobals
(
window
)
{
let
extensions
=
this
.
contexts
.
get
(
getInnerWindowID
(
window
)
)
;
if
(
extensions
)
{
return
Array
.
from
(
extensions
.
values
(
)
ctx
=
>
ctx
.
sandbox
)
;
}
return
[
]
;
}
initExtensionContext
(
extension
window
)
{
extension
.
getContext
(
window
)
.
injectAPI
(
)
;
}
}
;
var
ExtensionContent
=
{
BrowserExtensionContent
contentScripts
shutdownExtension
(
extension
)
{
DocumentManager
.
shutdownExtension
(
extension
)
;
}
getContentScriptGlobals
(
window
)
{
return
DocumentManager
.
getContentScriptGlobals
(
window
)
;
}
initExtensionContext
(
extension
window
)
{
DocumentManager
.
initExtensionContext
(
extension
window
)
;
}
getContext
(
extension
window
)
{
let
extensions
=
DocumentManager
.
getContexts
(
window
)
;
let
context
=
extensions
.
get
(
extension
)
;
if
(
!
context
)
{
context
=
new
ContentScriptContextChild
(
extension
window
)
;
extensions
.
set
(
extension
context
)
;
}
return
context
;
}
handleExtensionCapture
(
global
width
height
options
)
{
let
win
=
global
.
content
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
let
canvas
=
win
.
document
.
createElementNS
(
XHTML_NS
"
canvas
"
)
;
canvas
.
width
=
width
;
canvas
.
height
=
height
;
canvas
.
mozOpaque
=
true
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
scale
(
canvas
.
width
/
win
.
innerWidth
canvas
.
height
/
win
.
innerHeight
)
;
ctx
.
drawWindow
(
win
win
.
scrollX
win
.
scrollY
win
.
innerWidth
win
.
innerHeight
"
#
fff
"
)
;
return
canvas
.
toDataURL
(
image
/
{
options
.
format
}
options
.
quality
/
100
)
;
}
handleDetectLanguage
(
global
target
)
{
let
doc
=
target
.
content
.
document
;
return
promiseDocumentReady
(
doc
)
.
then
(
(
)
=
>
{
let
elem
=
doc
.
documentElement
;
let
language
=
(
elem
.
getAttribute
(
"
xml
:
lang
"
)
|
|
elem
.
getAttribute
(
"
lang
"
)
|
|
doc
.
contentLanguage
|
|
null
)
;
let
tld
=
doc
.
location
.
hostname
.
match
(
/
[
a
-
z
]
*
/
)
[
0
]
;
let
encoder
=
Cu
.
createDocumentEncoder
(
"
text
/
plain
"
)
;
encoder
.
init
(
doc
"
text
/
plain
"
Ci
.
nsIDocumentEncoder
.
SkipInvisibleContent
)
;
let
text
=
encoder
.
encodeToStringWithMaxLength
(
60
*
1024
)
;
let
encoding
=
doc
.
characterSet
;
return
LanguageDetector
.
detectLanguage
(
{
language
tld
text
encoding
}
)
.
then
(
result
=
>
result
.
language
=
=
=
"
un
"
?
"
und
"
:
result
.
language
)
;
}
)
;
}
async
handleExtensionExecute
(
global
target
options
script
)
{
let
executeInWin
=
(
window
)
=
>
{
if
(
script
.
matchesWindow
(
window
)
)
{
return
script
.
injectInto
(
window
)
;
}
return
null
;
}
;
let
promises
;
try
{
promises
=
Array
.
from
(
this
.
enumerateWindows
(
global
.
docShell
)
executeInWin
)
.
filter
(
promise
=
>
promise
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
Promise
.
reject
(
{
message
:
"
An
unexpected
error
occurred
"
}
)
;
}
if
(
!
promises
.
length
)
{
if
(
options
.
frameID
)
{
return
Promise
.
reject
(
{
message
:
Frame
not
found
or
missing
host
permission
}
)
;
}
let
frames
=
options
.
allFrames
?
"
and
any
iframes
"
:
"
"
;
return
Promise
.
reject
(
{
message
:
Missing
host
permission
for
the
tab
{
frames
}
}
)
;
}
if
(
!
options
.
allFrames
&
&
promises
.
length
>
1
)
{
return
Promise
.
reject
(
{
message
:
Internal
error
:
Script
matched
multiple
windows
}
)
;
}
let
result
=
await
Promise
.
all
(
promises
)
;
try
{
Cu
.
cloneInto
(
result
target
)
;
}
catch
(
e
)
{
const
{
jsPaths
}
=
options
;
const
fileName
=
jsPaths
.
length
?
jsPaths
[
jsPaths
.
length
-
1
]
:
"
<
anonymous
code
>
"
;
const
message
=
Script
'
{
fileName
}
'
result
is
non
-
structured
-
clonable
data
;
return
Promise
.
reject
(
{
message
fileName
}
)
;
}
return
result
;
}
handleWebNavigationGetFrame
(
global
{
frameId
}
)
{
return
WebNavigationFrames
.
getFrame
(
global
.
docShell
frameId
)
;
}
handleWebNavigationGetAllFrames
(
global
)
{
return
WebNavigationFrames
.
getAllFrames
(
global
.
docShell
)
;
}
async
receiveMessage
(
global
name
target
data
recipient
)
{
switch
(
name
)
{
case
"
Extension
:
Capture
"
:
return
this
.
handleExtensionCapture
(
global
data
.
width
data
.
height
data
.
options
)
;
case
"
Extension
:
DetectLanguage
"
:
return
this
.
handleDetectLanguage
(
global
target
)
;
case
"
Extension
:
Execute
"
:
let
policy
=
WebExtensionPolicy
.
getByID
(
recipient
.
extensionId
)
;
let
matcher
=
new
WebExtensionContentScript
(
policy
data
.
options
)
;
Object
.
assign
(
matcher
{
wantReturnValue
:
data
.
options
.
wantReturnValue
removeCSS
:
data
.
options
.
removeCSS
cssOrigin
:
data
.
options
.
cssOrigin
jsCode
:
data
.
options
.
jsCode
}
)
;
let
script
=
contentScripts
.
get
(
matcher
)
;
await
script
.
addCSSCode
(
data
.
options
.
cssCode
)
;
delete
data
.
options
.
cssCode
;
return
this
.
handleExtensionExecute
(
global
target
data
.
options
script
)
;
case
"
WebNavigation
:
GetFrame
"
:
return
this
.
handleWebNavigationGetFrame
(
global
data
.
options
)
;
case
"
WebNavigation
:
GetAllFrames
"
:
return
this
.
handleWebNavigationGetAllFrames
(
global
)
;
}
return
null
;
}
*
enumerateWindows
(
docShell
)
{
let
enum_
=
docShell
.
getDocShellEnumerator
(
docShell
.
typeContent
docShell
.
ENUMERATE_FORWARDS
)
;
for
(
let
docShell
of
enum_
)
{
try
{
yield
docShell
.
domWindow
;
}
catch
(
e
)
{
}
}
}
}
;
