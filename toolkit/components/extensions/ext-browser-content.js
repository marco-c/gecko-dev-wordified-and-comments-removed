"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
clearTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
require
"
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
colorUtils
"
(
)
=
>
{
return
require
(
"
devtools
/
shared
/
css
/
color
"
)
.
colorUtils
;
}
)
;
const
{
stylesheetMap
}
=
ExtensionUtils
;
const
RESIZE_TIMEOUT
=
100
;
const
BrowserListener
=
{
init
(
{
allowScriptsToClose
fixedWidth
maxHeight
maxWidth
stylesheets
}
)
{
this
.
fixedWidth
=
fixedWidth
;
this
.
stylesheets
=
stylesheets
|
|
[
]
;
this
.
maxWidth
=
maxWidth
;
this
.
maxHeight
=
maxHeight
;
this
.
oldBackground
=
null
;
if
(
allowScriptsToClose
)
{
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
allowScriptsToClose
(
)
;
}
addEventListener
(
"
DOMWindowCreated
"
this
true
)
;
addEventListener
(
"
load
"
this
true
)
;
addEventListener
(
"
DOMContentLoaded
"
this
true
)
;
addEventListener
(
"
DOMWindowClose
"
this
true
)
;
addEventListener
(
"
MozScrolledAreaChanged
"
this
true
)
;
}
destroy
(
)
{
removeEventListener
(
"
DOMWindowCreated
"
this
true
)
;
removeEventListener
(
"
load
"
this
true
)
;
removeEventListener
(
"
DOMContentLoaded
"
this
true
)
;
removeEventListener
(
"
DOMWindowClose
"
this
true
)
;
removeEventListener
(
"
MozScrolledAreaChanged
"
this
true
)
;
}
receiveMessage
(
{
name
data
}
)
{
if
(
name
=
=
=
"
Extension
:
InitBrowser
"
)
{
this
.
init
(
data
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
DOMWindowCreated
"
:
if
(
event
.
target
=
=
=
content
.
document
)
{
let
winUtils
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
for
(
let
url
of
this
.
stylesheets
)
{
winUtils
.
addSheet
(
stylesheetMap
.
get
(
url
)
winUtils
.
AGENT_SHEET
)
;
}
}
break
;
case
"
DOMWindowClose
"
:
if
(
event
.
target
=
=
=
content
)
{
event
.
preventDefault
(
)
;
sendAsyncMessage
(
"
Extension
:
DOMWindowClose
"
)
;
}
break
;
case
"
DOMContentLoaded
"
:
if
(
event
.
target
=
=
=
content
.
document
)
{
sendAsyncMessage
(
"
Extension
:
BrowserContentLoaded
"
{
url
:
content
.
location
.
href
}
)
;
this
.
handleDOMChange
(
true
)
;
}
break
;
case
"
load
"
:
if
(
event
.
target
.
contentWindow
=
=
=
content
)
{
sendAsyncMessage
(
"
Extension
:
BrowserContentLoaded
"
{
url
:
content
.
location
.
href
}
)
;
}
else
if
(
event
.
target
!
=
=
content
.
document
)
{
break
;
}
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
this
.
handleDOMChange
(
true
)
;
}
)
;
new
content
.
MutationObserver
(
this
.
handleDOMChange
.
bind
(
this
)
)
.
observe
(
content
.
document
.
documentElement
{
attributes
:
true
characterData
:
true
childList
:
true
subtree
:
true
}
)
;
break
;
case
"
MozScrolledAreaChanged
"
:
this
.
handleDOMChange
(
)
;
break
;
}
}
handleDOMChange
(
ignoreThrottling
=
false
)
{
if
(
ignoreThrottling
&
&
this
.
resizeTimeout
)
{
clearTimeout
(
this
.
resizeTimeout
)
;
this
.
resizeTimeout
=
null
;
}
if
(
this
.
resizeTimeout
=
=
null
)
{
this
.
resizeTimeout
=
setTimeout
(
(
)
=
>
{
try
{
if
(
content
)
{
this
.
_handleDOMChange
(
"
delayed
"
)
;
}
}
finally
{
this
.
resizeTimeout
=
null
;
}
}
RESIZE_TIMEOUT
)
;
this
.
_handleDOMChange
(
)
;
}
}
_handleDOMChange
(
detail
)
{
let
doc
=
content
.
document
;
let
body
=
doc
.
body
;
if
(
!
body
|
|
doc
.
compatMode
=
=
=
"
BackCompat
"
)
{
body
=
doc
.
documentElement
;
}
let
result
;
if
(
this
.
fixedWidth
)
{
let
getHeight
=
elem
=
>
elem
.
getBoundingClientRect
(
elem
)
.
height
;
let
bodyPadding
=
getHeight
(
doc
.
documentElement
)
-
getHeight
(
body
)
;
let
height
=
Math
.
ceil
(
body
.
scrollHeight
+
bodyPadding
)
;
result
=
{
height
detail
}
;
}
else
{
let
background
=
doc
.
defaultView
.
getComputedStyle
(
body
)
.
backgroundColor
;
let
bgColor
=
colorUtils
.
colorToRGBA
(
background
)
;
if
(
bgColor
.
a
!
=
=
1
)
{
background
=
null
;
}
if
(
background
!
=
=
this
.
oldBackground
)
{
sendAsyncMessage
(
"
Extension
:
BrowserBackgroundChanged
"
{
background
}
)
;
}
this
.
oldBackground
=
background
;
let
{
contentViewer
}
=
docShell
;
let
ratio
=
content
.
devicePixelRatio
;
let
w
=
{
}
h
=
{
}
;
contentViewer
.
getContentSizeConstrained
(
this
.
maxWidth
*
ratio
this
.
maxHeight
*
ratio
w
h
)
;
let
width
=
Math
.
ceil
(
w
.
value
/
ratio
)
;
let
height
=
Math
.
ceil
(
h
.
value
/
ratio
)
;
result
=
{
width
height
detail
}
;
}
sendAsyncMessage
(
"
Extension
:
BrowserResized
"
result
)
;
}
}
;
addMessageListener
(
"
Extension
:
InitBrowser
"
BrowserListener
)
;
