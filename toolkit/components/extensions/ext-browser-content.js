"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
ExtensionCommon
:
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
sys
.
mjs
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
}
)
;
const
RESIZE_TIMEOUT
=
100
;
const
BrowserListener
=
{
init
(
{
allowScriptsToClose
blockParser
fixedWidth
maxHeight
maxWidth
stylesheets
isInline
}
)
{
this
.
fixedWidth
=
fixedWidth
;
this
.
stylesheets
=
stylesheets
|
|
[
]
;
this
.
isInline
=
isInline
;
this
.
maxWidth
=
maxWidth
;
this
.
maxHeight
=
maxHeight
;
this
.
blockParser
=
blockParser
;
this
.
needsResize
=
fixedWidth
|
|
maxHeight
|
|
maxWidth
;
this
.
oldBackground
=
null
;
if
(
allowScriptsToClose
)
{
content
.
windowUtils
.
allowScriptsToClose
(
)
;
}
if
(
this
.
blockParser
)
{
this
.
blockingPromise
=
new
Promise
(
resolve
=
>
{
this
.
unblockParser
=
resolve
;
}
)
;
addEventListener
(
"
DOMDocElementInserted
"
this
true
)
;
}
addEventListener
(
"
load
"
this
true
)
;
addEventListener
(
"
DOMWindowCreated
"
this
true
)
;
addEventListener
(
"
DOMContentLoaded
"
this
true
)
;
addEventListener
(
"
MozScrolledAreaChanged
"
this
true
)
;
}
destroy
(
)
{
if
(
this
.
blockParser
)
{
removeEventListener
(
"
DOMDocElementInserted
"
this
true
)
;
}
removeEventListener
(
"
load
"
this
true
)
;
removeEventListener
(
"
DOMWindowCreated
"
this
true
)
;
removeEventListener
(
"
DOMContentLoaded
"
this
true
)
;
removeEventListener
(
"
MozScrolledAreaChanged
"
this
true
)
;
}
receiveMessage
(
{
name
data
}
)
{
if
(
name
=
=
=
"
Extension
:
InitBrowser
"
)
{
this
.
init
(
data
)
;
}
else
if
(
name
=
=
=
"
Extension
:
UnblockParser
"
)
{
if
(
this
.
unblockParser
)
{
this
.
unblockParser
(
)
;
this
.
blockingPromise
=
null
;
}
}
else
if
(
name
=
=
=
"
Extension
:
GrabFocus
"
)
{
content
.
window
.
requestAnimationFrame
(
(
)
=
>
{
Services
.
focus
.
focusedWindow
=
content
.
window
;
}
)
;
}
}
loadStylesheets
(
)
{
let
{
windowUtils
}
=
content
;
for
(
let
url
of
this
.
stylesheets
)
{
windowUtils
.
addSheet
(
ExtensionCommon
.
stylesheetMap
.
get
(
url
)
windowUtils
.
AUTHOR_SHEET
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
DOMDocElementInserted
"
:
if
(
this
.
blockingPromise
)
{
const
doc
=
event
.
target
;
const
policy
=
doc
?
.
nodePrincipal
?
.
addonPolicy
;
event
.
target
.
blockParsing
(
this
.
blockingPromise
)
.
then
(
(
)
=
>
{
policy
?
.
weakExtension
?
.
get
(
)
?
.
untrackBlockedParsingDocument
(
doc
)
;
}
)
;
policy
?
.
weakExtension
?
.
get
(
)
?
.
trackBlockedParsingDocument
(
doc
)
;
}
break
;
case
"
DOMWindowCreated
"
:
if
(
event
.
target
=
=
=
content
.
document
)
{
this
.
loadStylesheets
(
)
;
}
break
;
case
"
DOMContentLoaded
"
:
if
(
event
.
target
=
=
=
content
.
document
)
{
sendAsyncMessage
(
"
Extension
:
BrowserContentLoaded
"
{
url
:
content
.
location
.
href
}
)
;
if
(
this
.
needsResize
)
{
this
.
handleDOMChange
(
true
)
;
}
}
break
;
case
"
load
"
:
if
(
event
.
target
.
contentWindow
=
=
=
content
)
{
if
(
this
.
isInline
)
{
this
.
loadStylesheets
(
)
;
}
sendAsyncMessage
(
"
Extension
:
BrowserContentLoaded
"
{
url
:
content
.
location
.
href
}
)
;
}
else
if
(
event
.
target
!
=
=
content
.
document
)
{
break
;
}
if
(
!
this
.
needsResize
)
{
break
;
}
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
this
.
handleDOMChange
(
true
)
;
}
)
;
new
content
.
MutationObserver
(
this
.
handleDOMChange
.
bind
(
this
)
)
.
observe
(
content
.
document
.
documentElement
{
attributes
:
true
characterData
:
true
childList
:
true
subtree
:
true
}
)
;
break
;
case
"
MozScrolledAreaChanged
"
:
if
(
this
.
needsResize
)
{
this
.
handleDOMChange
(
)
;
}
break
;
}
}
handleDOMChange
(
ignoreThrottling
=
false
)
{
if
(
ignoreThrottling
&
&
this
.
resizeTimeout
)
{
clearTimeout
(
this
.
resizeTimeout
)
;
this
.
resizeTimeout
=
null
;
}
if
(
this
.
resizeTimeout
=
=
null
)
{
this
.
resizeTimeout
=
setTimeout
(
(
)
=
>
{
try
{
if
(
content
)
{
this
.
_handleDOMChange
(
"
delayed
"
)
;
}
}
finally
{
this
.
resizeTimeout
=
null
;
}
}
RESIZE_TIMEOUT
)
;
this
.
_handleDOMChange
(
)
;
}
}
_handleDOMChange
(
detail
)
{
let
doc
=
content
.
document
;
let
body
=
doc
.
body
;
if
(
!
body
|
|
doc
.
compatMode
=
=
=
"
BackCompat
"
)
{
body
=
doc
.
documentElement
;
}
let
result
;
const
zoom
=
content
.
browsingContext
.
fullZoom
;
if
(
this
.
fixedWidth
)
{
let
getHeight
=
elem
=
>
elem
.
getBoundingClientRect
(
elem
)
.
height
;
let
bodyPadding
=
getHeight
(
doc
.
documentElement
)
-
getHeight
(
body
)
;
if
(
body
!
=
=
doc
.
documentElement
)
{
let
bs
=
content
.
getComputedStyle
(
body
)
;
let
ds
=
content
.
getComputedStyle
(
doc
.
documentElement
)
;
let
p
=
parseFloat
(
bs
.
marginTop
)
+
parseFloat
(
bs
.
marginBottom
)
+
parseFloat
(
ds
.
marginTop
)
+
parseFloat
(
ds
.
marginBottom
)
+
parseFloat
(
ds
.
paddingTop
)
+
parseFloat
(
ds
.
paddingBottom
)
;
bodyPadding
=
Math
.
min
(
p
bodyPadding
)
;
}
let
height
=
Math
.
ceil
(
(
body
.
scrollHeight
+
bodyPadding
)
*
zoom
)
;
result
=
{
height
detail
}
;
}
else
{
let
background
=
content
.
windowUtils
.
canvasBackgroundColor
;
if
(
background
!
=
=
this
.
oldBackground
)
{
sendAsyncMessage
(
"
Extension
:
BrowserBackgroundChanged
"
{
background
}
)
;
}
this
.
oldBackground
=
background
;
let
w
=
{
}
h
=
{
}
;
docShell
.
docViewer
.
getContentSize
(
this
.
maxWidth
this
.
maxHeight
0
w
h
)
;
let
width
=
Math
.
ceil
(
w
.
value
*
zoom
)
;
let
height
=
Math
.
ceil
(
h
.
value
*
zoom
)
;
result
=
{
width
height
detail
}
;
}
sendAsyncMessage
(
"
Extension
:
BrowserResized
"
result
)
;
}
}
;
addMessageListener
(
"
Extension
:
InitBrowser
"
BrowserListener
)
;
addMessageListener
(
"
Extension
:
UnblockParser
"
BrowserListener
)
;
addMessageListener
(
"
Extension
:
GrabFocus
"
BrowserListener
)
;
void
content
;
