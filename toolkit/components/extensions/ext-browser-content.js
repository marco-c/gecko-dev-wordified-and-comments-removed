"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
clearTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
require
"
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
{
getWinUtils
stylesheetMap
}
=
ExtensionUtils
;
const
RESIZE_TIMEOUT
=
100
;
const
isOpaque
=
function
(
color
)
{
try
{
if
(
/
(
rgba
|
hsla
)
/
i
.
test
(
color
)
)
{
let
numberRe
=
/
(
\
.
\
d
+
|
\
d
+
\
.
?
\
d
*
)
%
?
/
g
;
let
opacity
=
color
.
match
(
numberRe
)
[
3
]
;
if
(
opacity
.
includes
(
"
%
"
)
)
{
opacity
=
opacity
.
slice
(
0
-
1
)
;
opacity
=
opacity
/
100
;
}
return
opacity
*
1
>
=
1
;
}
else
if
(
/
^
#
[
a
-
f0
-
9
]
{
4
}
/
i
.
test
(
color
)
)
{
return
color
.
toUpperCase
(
)
.
endsWith
(
"
F
"
)
;
}
else
if
(
/
^
#
[
a
-
f0
-
9
]
{
8
}
/
i
.
test
(
color
)
)
{
return
color
.
toUpperCase
(
)
.
endsWith
(
"
FF
"
)
;
}
}
catch
(
e
)
{
}
return
true
;
}
;
const
BrowserListener
=
{
init
(
{
allowScriptsToClose
blockParser
fixedWidth
maxHeight
maxWidth
stylesheets
isInline
}
)
{
this
.
fixedWidth
=
fixedWidth
;
this
.
stylesheets
=
stylesheets
|
|
[
]
;
this
.
isInline
=
isInline
;
this
.
maxWidth
=
maxWidth
;
this
.
maxHeight
=
maxHeight
;
this
.
oldBackground
=
null
;
if
(
allowScriptsToClose
)
{
getWinUtils
(
content
)
.
allowScriptsToClose
(
)
;
}
docShell
.
isAppTab
=
true
;
if
(
blockParser
)
{
this
.
blockingPromise
=
new
Promise
(
resolve
=
>
{
this
.
unblockParser
=
resolve
;
}
)
;
}
addEventListener
(
"
DOMWindowCreated
"
this
true
)
;
addEventListener
(
"
load
"
this
true
)
;
addEventListener
(
"
DOMContentLoaded
"
this
true
)
;
addEventListener
(
"
DOMWindowClose
"
this
true
)
;
addEventListener
(
"
MozScrolledAreaChanged
"
this
true
)
;
addEventListener
(
"
DOMDocElementInserted
"
this
true
)
;
}
destroy
(
)
{
removeEventListener
(
"
DOMWindowCreated
"
this
true
)
;
removeEventListener
(
"
load
"
this
true
)
;
removeEventListener
(
"
DOMContentLoaded
"
this
true
)
;
removeEventListener
(
"
DOMWindowClose
"
this
true
)
;
removeEventListener
(
"
MozScrolledAreaChanged
"
this
true
)
;
removeEventListener
(
"
DOMDocElementInserted
"
this
true
)
;
}
receiveMessage
(
{
name
data
}
)
{
if
(
name
=
=
=
"
Extension
:
InitBrowser
"
)
{
this
.
init
(
data
)
;
}
else
if
(
name
=
=
=
"
Extension
:
UnblockParser
"
)
{
if
(
this
.
unblockParser
)
{
this
.
unblockParser
(
)
;
this
.
blockingPromise
=
null
;
}
}
}
loadStylesheets
(
)
{
let
winUtils
=
getWinUtils
(
content
)
;
for
(
let
url
of
this
.
stylesheets
)
{
winUtils
.
addSheet
(
stylesheetMap
.
get
(
url
)
winUtils
.
AGENT_SHEET
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
DOMDocElementInserted
"
:
if
(
this
.
blockingPromise
)
{
event
.
target
.
blockParsing
(
this
.
blockingPromise
)
;
}
break
;
case
"
DOMWindowCreated
"
:
if
(
event
.
target
=
=
=
content
.
document
)
{
this
.
loadStylesheets
(
)
;
}
break
;
case
"
DOMWindowClose
"
:
if
(
event
.
target
=
=
=
content
)
{
event
.
preventDefault
(
)
;
sendAsyncMessage
(
"
Extension
:
DOMWindowClose
"
)
;
}
break
;
case
"
DOMContentLoaded
"
:
if
(
event
.
target
=
=
=
content
.
document
)
{
sendAsyncMessage
(
"
Extension
:
BrowserContentLoaded
"
{
url
:
content
.
location
.
href
}
)
;
this
.
handleDOMChange
(
true
)
;
}
break
;
case
"
load
"
:
if
(
event
.
target
.
contentWindow
=
=
=
content
)
{
if
(
this
.
isInline
)
{
this
.
loadStylesheets
(
)
;
}
sendAsyncMessage
(
"
Extension
:
BrowserContentLoaded
"
{
url
:
content
.
location
.
href
}
)
;
}
else
if
(
event
.
target
!
=
=
content
.
document
)
{
break
;
}
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
this
.
handleDOMChange
(
true
)
;
}
)
;
new
content
.
MutationObserver
(
this
.
handleDOMChange
.
bind
(
this
)
)
.
observe
(
content
.
document
.
documentElement
{
attributes
:
true
characterData
:
true
childList
:
true
subtree
:
true
}
)
;
break
;
case
"
MozScrolledAreaChanged
"
:
this
.
handleDOMChange
(
)
;
break
;
}
}
handleDOMChange
(
ignoreThrottling
=
false
)
{
if
(
ignoreThrottling
&
&
this
.
resizeTimeout
)
{
clearTimeout
(
this
.
resizeTimeout
)
;
this
.
resizeTimeout
=
null
;
}
if
(
this
.
resizeTimeout
=
=
null
)
{
this
.
resizeTimeout
=
setTimeout
(
(
)
=
>
{
try
{
if
(
content
)
{
this
.
_handleDOMChange
(
"
delayed
"
)
;
}
}
finally
{
this
.
resizeTimeout
=
null
;
}
}
RESIZE_TIMEOUT
)
;
this
.
_handleDOMChange
(
)
;
}
}
_handleDOMChange
(
detail
)
{
let
doc
=
content
.
document
;
let
body
=
doc
.
body
;
if
(
!
body
|
|
doc
.
compatMode
=
=
=
"
BackCompat
"
)
{
body
=
doc
.
documentElement
;
}
let
result
;
if
(
this
.
fixedWidth
)
{
let
getHeight
=
elem
=
>
elem
.
getBoundingClientRect
(
elem
)
.
height
;
let
bodyPadding
=
getHeight
(
doc
.
documentElement
)
-
getHeight
(
body
)
;
let
height
=
Math
.
ceil
(
body
.
scrollHeight
+
bodyPadding
)
;
result
=
{
height
detail
}
;
}
else
{
let
background
=
doc
.
defaultView
.
getComputedStyle
(
body
)
.
backgroundColor
;
if
(
!
isOpaque
(
background
)
)
{
background
=
null
;
}
if
(
background
!
=
=
this
.
oldBackground
)
{
sendAsyncMessage
(
"
Extension
:
BrowserBackgroundChanged
"
{
background
}
)
;
}
this
.
oldBackground
=
background
;
let
{
contentViewer
}
=
docShell
;
let
ratio
=
content
.
devicePixelRatio
;
let
w
=
{
}
h
=
{
}
;
contentViewer
.
getContentSizeConstrained
(
this
.
maxWidth
*
ratio
this
.
maxHeight
*
ratio
w
h
)
;
let
width
=
Math
.
ceil
(
w
.
value
/
ratio
)
;
let
height
=
Math
.
ceil
(
h
.
value
/
ratio
)
;
result
=
{
width
height
detail
}
;
}
sendAsyncMessage
(
"
Extension
:
BrowserResized
"
result
)
;
}
}
;
addMessageListener
(
"
Extension
:
InitBrowser
"
BrowserListener
)
;
addMessageListener
(
"
Extension
:
UnblockParser
"
BrowserListener
)
;
