"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
LegacyExtensionsUtils
"
]
;
ChromeUtils
.
defineModuleGetter
(
this
"
Extension
"
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionChild
"
"
resource
:
/
/
gre
/
modules
/
ExtensionChild
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
var
{
BaseContext
}
=
ExtensionCommon
;
var
LegacyExtensionContext
=
class
extends
BaseContext
{
constructor
(
targetExtension
)
{
super
(
"
legacy_extension
"
targetExtension
)
;
let
addonPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
Object
.
defineProperty
(
this
"
principal
"
{
value
:
addonPrincipal
enumerable
:
true
configurable
:
true
}
)
;
let
cloneScope
=
Cu
.
Sandbox
(
this
.
principal
{
}
)
;
Cu
.
setSandboxMetadata
(
cloneScope
{
addonId
:
targetExtension
.
id
}
)
;
Object
.
defineProperty
(
this
"
cloneScope
"
{
value
:
cloneScope
enumerable
:
true
configurable
:
true
writable
:
true
}
)
;
let
sender
=
{
id
:
targetExtension
.
id
}
;
let
filter
=
{
extensionId
:
targetExtension
.
id
}
;
this
.
messenger
=
new
ExtensionChild
.
Messenger
(
this
[
Services
.
cpmm
]
sender
filter
)
;
this
.
api
=
{
browser
:
{
runtime
:
{
onConnect
:
this
.
messenger
.
onConnect
(
"
runtime
.
onConnect
"
)
onMessage
:
this
.
messenger
.
onMessage
(
"
runtime
.
onMessage
"
)
}
}
}
;
}
unload
(
)
{
if
(
this
.
unloaded
)
{
throw
new
Error
(
"
Error
trying
to
unload
LegacyExtensionContext
twice
.
"
)
;
}
super
.
unload
(
)
;
Cu
.
nukeSandbox
(
this
.
cloneScope
)
;
this
.
cloneScope
=
null
;
}
}
;
var
EmbeddedExtensionManager
;
class
EmbeddedExtension
{
constructor
(
{
id
resourceURI
version
}
)
{
this
.
addonId
=
id
;
this
.
resourceURI
=
resourceURI
;
this
.
version
=
version
;
this
.
started
=
false
;
}
startup
(
reason
addonData
=
{
}
)
{
if
(
this
.
started
)
{
return
Promise
.
reject
(
new
Error
(
"
This
embedded
extension
has
already
been
started
"
)
)
;
}
this
.
startupPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
embeddedExtensionURI
=
Services
.
io
.
newURI
(
"
webextension
/
"
null
this
.
resourceURI
)
;
let
{
builtIn
signedState
temporarilyInstalled
}
=
addonData
;
this
.
extension
=
new
Extension
(
{
builtIn
signedState
temporarilyInstalled
id
:
this
.
addonId
resourceURI
:
embeddedExtensionURI
version
:
this
.
version
}
)
;
this
.
extension
.
isEmbedded
=
true
;
const
onBeforeStarted
=
(
)
=
>
{
this
.
extension
.
off
(
"
startup
"
onBeforeStarted
)
;
this
.
started
=
true
;
this
.
startupPromise
=
null
;
this
.
context
=
new
LegacyExtensionContext
(
this
.
extension
)
;
this
.
extension
.
callOnClose
(
{
close
:
(
)
=
>
{
this
.
context
.
unload
(
)
;
}
}
)
;
resolve
(
this
.
context
.
api
)
;
}
;
this
.
extension
.
on
(
"
startup
"
onBeforeStarted
)
;
this
.
extension
.
startup
(
reason
)
.
catch
(
(
err
)
=
>
{
this
.
started
=
false
;
this
.
startupPromise
=
null
;
this
.
extension
.
off
(
"
startup
"
onBeforeStarted
)
;
reject
(
err
)
;
}
)
;
}
)
;
return
this
.
startupPromise
;
}
async
shutdown
(
reason
)
{
EmbeddedExtensionManager
.
untrackEmbeddedExtension
(
this
)
;
if
(
this
.
extension
&
&
!
this
.
extension
.
hasShutdown
)
{
let
{
extension
}
=
this
;
this
.
extension
=
null
;
await
extension
.
shutdown
(
reason
)
;
}
return
undefined
;
}
}
EmbeddedExtensionManager
=
{
embeddedExtensionsByAddonId
:
new
Map
(
)
untrackEmbeddedExtension
(
embeddedExtensionInstance
)
{
let
id
=
embeddedExtensionInstance
.
addonId
;
if
(
this
.
embeddedExtensionsByAddonId
.
get
(
id
)
=
=
embeddedExtensionInstance
)
{
this
.
embeddedExtensionsByAddonId
.
delete
(
id
)
;
}
}
getEmbeddedExtensionFor
(
{
id
resourceURI
version
}
)
{
let
embeddedExtension
=
this
.
embeddedExtensionsByAddonId
.
get
(
id
)
;
if
(
!
embeddedExtension
)
{
embeddedExtension
=
new
EmbeddedExtension
(
{
id
resourceURI
version
}
)
;
this
.
embeddedExtensionsByAddonId
.
set
(
id
embeddedExtension
)
;
}
return
embeddedExtension
;
}
}
;
var
LegacyExtensionsUtils
=
{
getEmbeddedExtensionFor
:
(
addon
)
=
>
{
return
EmbeddedExtensionManager
.
getEmbeddedExtensionFor
(
addon
)
;
}
}
;
