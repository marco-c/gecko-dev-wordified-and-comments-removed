"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionUtils
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
const
INTEGER
=
/
^
[
1
-
9
]
\
d
*
/
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ConsoleAPI
"
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LanguageDetector
"
"
resource
:
/
/
/
modules
/
translation
/
LanguageDetector
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Locale
"
"
resource
:
/
/
gre
/
modules
/
Locale
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MessageChannel
"
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Schemas
"
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
styleSheetService
"
"
mozilla
.
org
/
content
/
style
-
sheet
-
service
;
1
"
"
nsIStyleSheetService
"
)
;
function
getConsole
(
)
{
return
new
ConsoleAPI
(
{
maxLogLevelPref
:
"
extensions
.
webextensions
.
log
.
level
"
prefix
:
"
WebExtensions
"
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
getConsole
)
;
function
filterStack
(
error
)
{
return
String
(
error
.
stack
)
.
replace
(
/
(
^
.
*
(
Task
\
.
jsm
|
Promise
-
backend
\
.
js
)
.
*
\
n
)
+
/
gm
"
<
Promise
Chain
>
\
n
"
)
;
}
function
runSafeSyncWithoutClone
(
f
.
.
.
args
)
{
try
{
return
f
(
.
.
.
args
)
;
}
catch
(
e
)
{
dump
(
Extension
error
:
{
e
}
{
e
.
fileName
}
{
e
.
lineNumber
}
\
n
[
[
Exception
stack
\
n
{
filterStack
(
e
)
}
Current
stack
\
n
{
filterStack
(
Error
(
)
)
}
]
]
\
n
)
;
Cu
.
reportError
(
e
)
;
}
}
function
runSafeWithoutClone
(
f
.
.
.
args
)
{
if
(
typeof
(
f
)
!
=
"
function
"
)
{
dump
(
Extension
error
:
expected
function
\
n
{
filterStack
(
Error
(
)
)
}
)
;
return
;
}
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
runSafeSyncWithoutClone
(
f
.
.
.
args
)
;
}
)
;
}
function
runSafeSync
(
context
f
.
.
.
args
)
{
if
(
context
.
unloaded
)
{
Cu
.
reportError
(
"
runSafeSync
called
after
context
unloaded
"
)
;
return
;
}
try
{
args
=
Cu
.
cloneInto
(
args
context
.
cloneScope
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
context
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
return
runSafeSyncWithoutClone
(
f
.
.
.
args
)
;
}
function
runSafe
(
context
f
.
.
.
args
)
{
try
{
args
=
Cu
.
cloneInto
(
args
context
.
cloneScope
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
context
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
if
(
context
.
unloaded
)
{
dump
(
runSafe
failure
:
context
is
already
unloaded
{
filterStack
(
new
Error
(
)
)
}
\
n
)
;
return
undefined
;
}
return
runSafeWithoutClone
(
f
.
.
.
args
)
;
}
function
getInnerWindowID
(
window
)
{
return
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
}
function
instanceOf
(
value
type
)
{
return
{
}
.
toString
.
call
(
value
)
=
=
[
object
{
type
}
]
;
}
function
extend
(
obj
.
.
.
args
)
{
for
(
let
arg
of
args
)
{
let
props
=
[
.
.
.
Object
.
getOwnPropertyNames
(
arg
)
.
.
.
Object
.
getOwnPropertySymbols
(
arg
)
]
;
for
(
let
prop
of
props
)
{
let
descriptor
=
Object
.
getOwnPropertyDescriptor
(
arg
prop
)
;
Object
.
defineProperty
(
obj
prop
descriptor
)
;
}
}
return
obj
;
}
class
DefaultWeakMap
extends
WeakMap
{
constructor
(
defaultConstructor
init
)
{
super
(
init
)
;
this
.
defaultConstructor
=
defaultConstructor
;
}
get
(
key
)
{
if
(
!
this
.
has
(
key
)
)
{
this
.
set
(
key
this
.
defaultConstructor
(
)
)
;
}
return
super
.
get
(
key
)
;
}
}
class
DefaultMap
extends
Map
{
constructor
(
defaultConstructor
init
)
{
super
(
init
)
;
this
.
defaultConstructor
=
defaultConstructor
;
}
get
(
key
)
{
if
(
!
this
.
has
(
key
)
)
{
this
.
set
(
key
this
.
defaultConstructor
(
key
)
)
;
}
return
super
.
get
(
key
)
;
}
}
class
SpreadArgs
extends
Array
{
constructor
(
args
)
{
super
(
)
;
this
.
push
(
.
.
.
args
)
;
}
}
let
gContextId
=
0
;
class
BaseContext
{
constructor
(
envType
extension
)
{
this
.
envType
=
envType
;
this
.
onClose
=
new
Set
(
)
;
this
.
checkedLastError
=
false
;
this
.
_lastError
=
null
;
this
.
contextId
=
{
+
+
gContextId
}
-
{
Services
.
appinfo
.
uniqueProcessID
}
;
this
.
unloaded
=
false
;
this
.
extension
=
extension
;
this
.
jsonSandbox
=
null
;
this
.
active
=
true
;
this
.
messageManager
=
null
;
this
.
docShell
=
null
;
this
.
contentWindow
=
null
;
this
.
innerWindowID
=
0
;
}
setContentWindow
(
contentWindow
)
{
let
{
document
}
=
contentWindow
;
let
docShell
=
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
;
this
.
innerWindowID
=
getInnerWindowID
(
contentWindow
)
;
this
.
messageManager
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
let
onPageShow
=
event
=
>
{
if
(
!
event
|
|
event
.
target
=
=
=
document
)
{
this
.
docShell
=
docShell
;
this
.
contentWindow
=
contentWindow
;
this
.
active
=
true
;
}
}
;
let
onPageHide
=
event
=
>
{
if
(
!
event
|
|
event
.
target
=
=
=
document
)
{
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
this
.
docShell
=
null
;
this
.
contentWindow
=
null
;
this
.
active
=
false
;
}
)
;
}
}
;
onPageShow
(
)
;
contentWindow
.
addEventListener
(
"
pagehide
"
onPageHide
true
)
;
contentWindow
.
addEventListener
(
"
pageshow
"
onPageShow
true
)
;
this
.
callOnClose
(
{
close
:
(
)
=
>
{
onPageHide
(
)
;
if
(
this
.
active
)
{
contentWindow
.
removeEventListener
(
"
pagehide
"
onPageHide
true
)
;
contentWindow
.
removeEventListener
(
"
pageshow
"
onPageShow
true
)
;
}
}
}
)
;
}
get
cloneScope
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
principal
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
runSafe
(
.
.
.
args
)
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
"
context
.
runSafe
called
after
context
unloaded
"
)
;
}
else
if
(
!
this
.
active
)
{
Cu
.
reportError
(
"
context
.
runSafe
called
while
context
is
inactive
"
)
;
}
else
{
return
runSafeSync
(
this
.
.
.
args
)
;
}
}
runSafeWithoutClone
(
.
.
.
args
)
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
"
context
.
runSafeWithoutClone
called
after
context
unloaded
"
)
;
}
else
if
(
!
this
.
active
)
{
Cu
.
reportError
(
"
context
.
runSafeWithoutClone
called
while
context
is
inactive
"
)
;
}
else
{
return
runSafeSyncWithoutClone
(
.
.
.
args
)
;
}
}
checkLoadURL
(
url
options
=
{
}
)
{
let
ssm
=
Services
.
scriptSecurityManager
;
let
flags
=
ssm
.
STANDARD
;
if
(
!
options
.
allowScript
)
{
flags
|
=
ssm
.
DISALLOW_SCRIPT
;
}
if
(
!
options
.
allowInheritsPrincipal
)
{
flags
|
=
ssm
.
DISALLOW_INHERIT_PRINCIPAL
;
}
if
(
options
.
dontReportErrors
)
{
flags
|
=
ssm
.
DONT_REPORT_ERRORS
;
}
try
{
ssm
.
checkLoadURIStrWithPrincipal
(
this
.
principal
url
flags
)
;
}
catch
(
e
)
{
return
false
;
}
return
true
;
}
jsonStringify
(
.
.
.
args
)
{
if
(
!
this
.
jsonSandbox
)
{
this
.
jsonSandbox
=
Cu
.
Sandbox
(
this
.
principal
{
sameZoneAs
:
this
.
cloneScope
wantXrays
:
false
}
)
;
}
return
Cu
.
waiveXrays
(
this
.
jsonSandbox
.
JSON
)
.
stringify
(
.
.
.
args
)
;
}
callOnClose
(
obj
)
{
this
.
onClose
.
add
(
obj
)
;
}
forgetOnClose
(
obj
)
{
this
.
onClose
.
delete
(
obj
)
;
}
sendMessage
(
target
messageName
data
options
=
{
}
)
{
options
.
recipient
=
options
.
recipient
|
|
{
}
;
options
.
sender
=
options
.
sender
|
|
{
}
;
options
.
recipient
.
extensionId
=
this
.
extension
.
id
;
options
.
sender
.
extensionId
=
this
.
extension
.
id
;
options
.
sender
.
contextId
=
this
.
contextId
;
return
MessageChannel
.
sendMessage
(
target
messageName
data
options
)
;
}
get
lastError
(
)
{
this
.
checkedLastError
=
true
;
return
this
.
_lastError
;
}
set
lastError
(
val
)
{
this
.
checkedLastError
=
false
;
this
.
_lastError
=
val
;
}
normalizeError
(
error
)
{
if
(
error
instanceof
this
.
cloneScope
.
Error
)
{
return
error
;
}
let
message
;
if
(
instanceOf
(
error
"
Object
"
)
)
{
message
=
error
.
message
;
}
else
if
(
typeof
error
=
=
"
object
"
&
&
this
.
principal
.
subsumes
(
Cu
.
getObjectPrincipal
(
error
)
)
)
{
message
=
error
.
message
;
}
else
{
Cu
.
reportError
(
error
)
;
}
message
=
message
|
|
"
An
unexpected
error
occurred
"
;
return
new
this
.
cloneScope
.
Error
(
message
)
;
}
withLastError
(
error
callback
)
{
this
.
lastError
=
this
.
normalizeError
(
error
)
;
try
{
return
callback
(
)
;
}
finally
{
if
(
!
this
.
checkedLastError
)
{
Cu
.
reportError
(
Unchecked
lastError
value
:
{
this
.
lastError
}
)
;
}
this
.
lastError
=
null
;
}
}
wrapPromise
(
promise
callback
=
null
)
{
let
runSafe
=
this
.
runSafe
.
bind
(
this
)
;
if
(
promise
instanceof
this
.
cloneScope
.
Promise
)
{
runSafe
=
this
.
runSafeWithoutClone
.
bind
(
this
)
;
}
if
(
callback
)
{
promise
.
then
(
args
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
resolved
after
context
unloaded
\
n
)
;
}
else
if
(
!
this
.
active
)
{
dump
(
Promise
resolved
while
context
is
inactive
\
n
)
;
}
else
if
(
args
instanceof
SpreadArgs
)
{
runSafe
(
callback
.
.
.
args
)
;
}
else
{
runSafe
(
callback
args
)
;
}
}
error
=
>
{
this
.
withLastError
(
error
(
)
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
rejected
after
context
unloaded
\
n
)
;
}
else
if
(
!
this
.
active
)
{
dump
(
Promise
rejected
while
context
is
inactive
\
n
)
;
}
else
{
this
.
runSafeWithoutClone
(
callback
)
;
}
}
)
;
}
)
;
}
else
{
return
new
this
.
cloneScope
.
Promise
(
(
resolve
reject
)
=
>
{
promise
.
then
(
value
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
resolved
after
context
unloaded
\
n
)
;
}
else
if
(
!
this
.
active
)
{
dump
(
Promise
resolved
while
context
is
inactive
\
n
)
;
}
else
if
(
value
instanceof
SpreadArgs
)
{
runSafe
(
resolve
value
.
length
=
=
1
?
value
[
0
]
:
value
)
;
}
else
{
runSafe
(
resolve
value
)
;
}
}
value
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
rejected
after
context
unloaded
:
{
value
&
&
value
.
message
}
\
n
)
;
}
else
if
(
!
this
.
active
)
{
dump
(
Promise
rejected
while
context
is
inactive
:
{
value
&
&
value
.
message
}
\
n
)
;
}
else
{
this
.
runSafeWithoutClone
(
reject
this
.
normalizeError
(
value
)
)
;
}
}
)
;
}
)
;
}
}
unload
(
)
{
this
.
unloaded
=
true
;
MessageChannel
.
abortResponses
(
{
extensionId
:
this
.
extension
.
id
contextId
:
this
.
contextId
}
)
;
for
(
let
obj
of
this
.
onClose
)
{
obj
.
close
(
)
;
}
}
}
let
IconDetails
=
{
normalize
(
details
extension
context
=
null
)
{
let
result
=
{
}
;
try
{
if
(
details
.
imageData
)
{
let
imageData
=
details
.
imageData
;
if
(
instanceOf
(
imageData
"
ImageData
"
)
)
{
imageData
=
{
"
19
"
:
imageData
}
;
}
for
(
let
size
of
Object
.
keys
(
imageData
)
)
{
if
(
!
INTEGER
.
test
(
size
)
)
{
throw
new
Error
(
Invalid
icon
size
{
size
}
must
be
an
integer
)
;
}
result
[
size
]
=
this
.
convertImageDataToDataURL
(
imageData
[
size
]
context
)
;
}
}
if
(
details
.
path
)
{
let
path
=
details
.
path
;
if
(
typeof
path
!
=
"
object
"
)
{
path
=
{
"
19
"
:
path
}
;
}
let
baseURI
=
context
?
context
.
uri
:
extension
.
baseURI
;
for
(
let
size
of
Object
.
keys
(
path
)
)
{
if
(
!
INTEGER
.
test
(
size
)
)
{
throw
new
Error
(
Invalid
icon
size
{
size
}
must
be
an
integer
)
;
}
let
url
=
baseURI
.
resolve
(
path
[
size
]
)
;
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
extension
.
principal
url
Services
.
scriptSecurityManager
.
DISALLOW_SCRIPT
)
;
result
[
size
]
=
url
;
}
}
}
catch
(
e
)
{
if
(
context
)
{
throw
e
;
}
extension
.
manifestError
(
Invalid
icon
data
:
{
e
}
)
;
}
return
result
;
}
getPreferredIcon
(
icons
extension
=
null
size
=
16
)
{
const
DEFAULT
=
"
chrome
:
/
/
browser
/
content
/
extension
.
svg
"
;
let
bestSize
=
null
;
if
(
icons
[
size
]
)
{
bestSize
=
size
;
}
else
if
(
icons
[
2
*
size
]
)
{
bestSize
=
2
*
size
;
}
else
{
let
sizes
=
Object
.
keys
(
icons
)
.
map
(
key
=
>
parseInt
(
key
10
)
)
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
bestSize
=
sizes
.
find
(
candidate
=
>
candidate
>
size
)
|
|
sizes
.
pop
(
)
;
}
if
(
bestSize
)
{
return
{
size
:
bestSize
icon
:
icons
[
bestSize
]
}
;
}
return
{
size
icon
:
DEFAULT
}
;
}
convertImageURLToDataURL
(
imageURL
contentWindow
browserWindow
size
=
18
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
image
=
new
contentWindow
.
Image
(
)
;
image
.
onload
=
function
(
)
{
let
canvas
=
contentWindow
.
document
.
createElement
(
"
canvas
"
)
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
let
dSize
=
size
*
browserWindow
.
devicePixelRatio
;
let
dWidth
dHeight
dx
dy
;
if
(
this
.
width
>
this
.
height
)
{
dWidth
=
dSize
;
dHeight
=
image
.
height
*
(
dSize
/
image
.
width
)
;
dx
=
0
;
dy
=
(
dSize
-
dHeight
)
/
2
;
}
else
{
dWidth
=
image
.
width
*
(
dSize
/
image
.
height
)
;
dHeight
=
dSize
;
dx
=
(
dSize
-
dWidth
)
/
2
;
dy
=
0
;
}
ctx
.
drawImage
(
this
0
0
this
.
width
this
.
height
dx
dy
dWidth
dHeight
)
;
resolve
(
canvas
.
toDataURL
(
"
image
/
png
"
)
)
;
}
;
image
.
onerror
=
reject
;
image
.
src
=
imageURL
;
}
)
;
}
convertImageDataToDataURL
(
imageData
context
)
{
let
document
=
context
.
contentWindow
.
document
;
let
canvas
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
imageData
.
width
;
canvas
.
height
=
imageData
.
height
;
canvas
.
getContext
(
"
2d
"
)
.
putImageData
(
imageData
0
0
)
;
return
canvas
.
toDataURL
(
"
image
/
png
"
)
;
}
}
;
const
LISTENERS
=
Symbol
(
"
listeners
"
)
;
class
EventEmitter
{
constructor
(
)
{
this
[
LISTENERS
]
=
new
Map
(
)
;
}
on
(
event
listener
)
{
if
(
!
this
[
LISTENERS
]
.
has
(
event
)
)
{
this
[
LISTENERS
]
.
set
(
event
new
Set
(
)
)
;
}
this
[
LISTENERS
]
.
get
(
event
)
.
add
(
listener
)
;
}
off
(
event
listener
)
{
if
(
this
[
LISTENERS
]
.
has
(
event
)
)
{
let
set
=
this
[
LISTENERS
]
.
get
(
event
)
;
set
.
delete
(
listener
)
;
if
(
!
set
.
size
)
{
this
[
LISTENERS
]
.
delete
(
event
)
;
}
}
}
emit
(
event
.
.
.
args
)
{
let
listeners
=
this
[
LISTENERS
]
.
get
(
event
)
|
|
new
Set
(
)
;
let
promises
=
Array
.
from
(
listeners
listener
=
>
{
return
runSafeSyncWithoutClone
(
listener
event
.
.
.
args
)
;
}
)
;
return
Promise
.
all
(
promises
)
;
}
}
function
LocaleData
(
data
)
{
this
.
defaultLocale
=
data
.
defaultLocale
;
this
.
selectedLocale
=
data
.
selectedLocale
;
this
.
locales
=
data
.
locales
|
|
new
Map
(
)
;
this
.
warnedMissingKeys
=
new
Set
(
)
;
this
.
messages
=
data
.
messages
|
|
new
Map
(
)
;
if
(
data
.
builtinMessages
)
{
this
.
messages
.
set
(
this
.
BUILTIN
data
.
builtinMessages
)
;
}
}
LocaleData
.
prototype
=
{
serialize
(
)
{
return
{
defaultLocale
:
this
.
defaultLocale
selectedLocale
:
this
.
selectedLocale
messages
:
this
.
messages
locales
:
this
.
locales
}
;
}
BUILTIN
:
"
BUILTIN_MESSAGES
"
has
(
locale
)
{
return
this
.
messages
.
has
(
locale
)
;
}
localizeMessage
(
message
substitutions
=
[
]
options
=
{
}
)
{
let
defaultOptions
=
{
locale
:
this
.
selectedLocale
defaultValue
:
"
"
cloneScope
:
null
}
;
options
=
Object
.
assign
(
defaultOptions
options
)
;
let
locales
=
new
Set
(
[
this
.
BUILTIN
options
.
locale
this
.
defaultLocale
]
.
filter
(
locale
=
>
this
.
messages
.
has
(
locale
)
)
)
;
message
=
message
.
toLowerCase
(
)
;
for
(
let
locale
of
locales
)
{
let
messages
=
this
.
messages
.
get
(
locale
)
;
if
(
messages
.
has
(
message
)
)
{
let
str
=
messages
.
get
(
message
)
;
if
(
!
Array
.
isArray
(
substitutions
)
)
{
substitutions
=
[
substitutions
]
;
}
let
replacer
=
(
matched
index
dollarSigns
)
=
>
{
if
(
index
)
{
index
=
parseInt
(
index
10
)
-
1
;
return
index
in
substitutions
?
substitutions
[
index
]
:
"
"
;
}
return
dollarSigns
;
}
;
return
str
.
replace
(
/
\
(
?
:
(
[
1
-
9
]
\
d
*
)
|
(
\
+
)
)
/
g
replacer
)
;
}
}
if
(
message
=
=
"
ui_locale
"
)
{
return
this
.
uiLocale
;
}
else
if
(
message
.
startsWith
(
"
bidi_
"
)
)
{
let
registry
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIXULChromeRegistry
)
;
let
rtl
=
registry
.
isLocaleRTL
(
"
global
"
)
;
if
(
message
=
=
"
bidi_dir
"
)
{
return
rtl
?
"
rtl
"
:
"
ltr
"
;
}
else
if
(
message
=
=
"
bidi_reversed_dir
"
)
{
return
rtl
?
"
ltr
"
:
"
rtl
"
;
}
else
if
(
message
=
=
"
bidi_start_edge
"
)
{
return
rtl
?
"
right
"
:
"
left
"
;
}
else
if
(
message
=
=
"
bidi_end_edge
"
)
{
return
rtl
?
"
left
"
:
"
right
"
;
}
}
if
(
!
this
.
warnedMissingKeys
.
has
(
message
)
)
{
let
error
=
Unknown
localization
message
{
message
}
;
if
(
options
.
cloneScope
)
{
error
=
new
options
.
cloneScope
.
Error
(
error
)
;
}
Cu
.
reportError
(
error
)
;
this
.
warnedMissingKeys
.
add
(
message
)
;
}
return
options
.
defaultValue
;
}
localize
(
str
locale
=
this
.
selectedLocale
)
{
if
(
!
str
)
{
return
str
;
}
return
str
.
replace
(
/
__MSG_
(
[
A
-
Za
-
z0
-
9
_
]
+
?
)
__
/
g
(
matched
message
)
=
>
{
return
this
.
localizeMessage
(
message
[
]
{
locale
defaultValue
:
matched
}
)
;
}
)
;
}
addLocale
(
locale
messages
extension
)
{
let
result
=
new
Map
(
)
;
if
(
!
instanceOf
(
messages
"
Object
"
)
)
{
extension
.
packagingError
(
Invalid
locale
data
for
{
locale
}
)
;
return
result
;
}
for
(
let
key
of
Object
.
keys
(
messages
)
)
{
let
msg
=
messages
[
key
]
;
if
(
!
instanceOf
(
msg
"
Object
"
)
|
|
typeof
(
msg
.
message
)
!
=
"
string
"
)
{
extension
.
packagingError
(
Invalid
locale
message
data
for
{
locale
}
message
{
JSON
.
stringify
(
key
)
}
)
;
continue
;
}
let
placeholders
=
new
Map
(
)
;
if
(
instanceOf
(
msg
.
placeholders
"
Object
"
)
)
{
for
(
let
key
of
Object
.
keys
(
msg
.
placeholders
)
)
{
placeholders
.
set
(
key
.
toLowerCase
(
)
msg
.
placeholders
[
key
]
)
;
}
}
let
replacer
=
(
match
name
)
=
>
{
let
replacement
=
placeholders
.
get
(
name
.
toLowerCase
(
)
)
;
if
(
instanceOf
(
replacement
"
Object
"
)
&
&
"
content
"
in
replacement
)
{
return
replacement
.
content
;
}
return
"
"
;
}
;
let
value
=
msg
.
message
.
replace
(
/
\
(
[
A
-
Za
-
z0
-
9
_
]
+
)
\
/
g
replacer
)
;
result
.
set
(
key
.
toLowerCase
(
)
value
)
;
}
this
.
messages
.
set
(
locale
result
)
;
return
result
;
}
get
acceptLanguages
(
)
{
let
result
=
Preferences
.
get
(
"
intl
.
accept_languages
"
"
"
Ci
.
nsIPrefLocalizedString
)
;
return
result
.
split
(
/
\
s
*
\
s
*
/
g
)
;
}
get
uiLocale
(
)
{
return
Locale
.
getLocale
(
)
.
replace
(
/
-
/
g
"
_
"
)
;
}
}
;
function
EventManager
(
context
name
register
)
{
this
.
context
=
context
;
this
.
name
=
name
;
this
.
register
=
register
;
this
.
unregister
=
null
;
this
.
callbacks
=
new
Set
(
)
;
}
EventManager
.
prototype
=
{
addListener
(
callback
)
{
if
(
typeof
(
callback
)
!
=
"
function
"
)
{
dump
(
Expected
function
\
n
{
Error
(
)
.
stack
}
)
;
return
;
}
if
(
this
.
context
.
unloaded
)
{
dump
(
Cannot
add
listener
to
{
this
.
name
}
after
context
unloaded
)
;
return
;
}
if
(
!
this
.
callbacks
.
size
)
{
this
.
context
.
callOnClose
(
this
)
;
let
fireFunc
=
this
.
fire
.
bind
(
this
)
;
let
fireWithoutClone
=
this
.
fireWithoutClone
.
bind
(
this
)
;
fireFunc
.
withoutClone
=
fireWithoutClone
;
this
.
unregister
=
this
.
register
(
fireFunc
)
;
}
this
.
callbacks
.
add
(
callback
)
;
}
removeListener
(
callback
)
{
if
(
!
this
.
callbacks
.
size
)
{
return
;
}
this
.
callbacks
.
delete
(
callback
)
;
if
(
this
.
callbacks
.
size
=
=
0
)
{
this
.
unregister
(
)
;
this
.
unregister
=
null
;
this
.
context
.
forgetOnClose
(
this
)
;
}
}
hasListener
(
callback
)
{
return
this
.
callbacks
.
has
(
callback
)
;
}
fire
(
.
.
.
args
)
{
for
(
let
callback
of
this
.
callbacks
)
{
Promise
.
resolve
(
callback
)
.
then
(
callback
=
>
{
if
(
this
.
context
.
unloaded
)
{
dump
(
{
this
.
name
}
event
fired
after
context
unloaded
.
\
n
)
;
}
else
if
(
this
.
callbacks
.
has
(
callback
)
)
{
this
.
context
.
runSafe
(
callback
.
.
.
args
)
;
}
}
)
;
}
}
fireWithoutClone
(
.
.
.
args
)
{
for
(
let
callback
of
this
.
callbacks
)
{
this
.
context
.
runSafeWithoutClone
(
callback
.
.
.
args
)
;
}
}
close
(
)
{
if
(
this
.
callbacks
.
size
)
{
this
.
unregister
(
)
;
}
this
.
callbacks
.
clear
(
)
;
this
.
register
=
null
;
this
.
unregister
=
null
;
}
api
(
)
{
return
{
addListener
:
callback
=
>
this
.
addListener
(
callback
)
removeListener
:
callback
=
>
this
.
removeListener
(
callback
)
hasListener
:
callback
=
>
this
.
hasListener
(
callback
)
}
;
}
}
;
function
SingletonEventManager
(
context
name
register
)
{
this
.
context
=
context
;
this
.
name
=
name
;
this
.
register
=
register
;
this
.
unregister
=
new
Map
(
)
;
}
SingletonEventManager
.
prototype
=
{
addListener
(
callback
.
.
.
args
)
{
let
wrappedCallback
=
(
.
.
.
args
)
=
>
{
if
(
this
.
context
.
unloaded
)
{
dump
(
{
this
.
name
}
event
fired
after
context
unloaded
.
\
n
)
;
}
else
if
(
this
.
unregister
.
has
(
callback
)
)
{
return
callback
(
.
.
.
args
)
;
}
}
;
let
unregister
=
this
.
register
(
wrappedCallback
.
.
.
args
)
;
this
.
unregister
.
set
(
callback
unregister
)
;
this
.
context
.
callOnClose
(
this
)
;
}
removeListener
(
callback
)
{
if
(
!
this
.
unregister
.
has
(
callback
)
)
{
return
;
}
let
unregister
=
this
.
unregister
.
get
(
callback
)
;
this
.
unregister
.
delete
(
callback
)
;
unregister
(
)
;
}
hasListener
(
callback
)
{
return
this
.
unregister
.
has
(
callback
)
;
}
close
(
)
{
for
(
let
unregister
of
this
.
unregister
.
values
(
)
)
{
unregister
(
)
;
}
}
api
(
)
{
return
{
addListener
:
(
.
.
.
args
)
=
>
this
.
addListener
(
.
.
.
args
)
removeListener
:
(
.
.
.
args
)
=
>
this
.
removeListener
(
.
.
.
args
)
hasListener
:
(
.
.
.
args
)
=
>
this
.
hasListener
(
.
.
.
args
)
}
;
}
}
;
function
ignoreEvent
(
context
name
)
{
return
{
addListener
:
function
(
callback
)
{
let
id
=
context
.
extension
.
id
;
let
frame
=
Components
.
stack
.
caller
;
let
msg
=
In
add
-
on
{
id
}
attempting
to
use
listener
"
{
name
}
"
which
is
unimplemented
.
;
let
scriptError
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
scriptError
.
init
(
msg
frame
.
filename
null
frame
.
lineNumber
frame
.
columnNumber
Ci
.
nsIScriptError
.
warningFlag
"
content
javascript
"
)
;
let
consoleService
=
Cc
[
"
mozilla
.
org
/
consoleservice
;
1
"
]
.
getService
(
Ci
.
nsIConsoleService
)
;
consoleService
.
logMessage
(
scriptError
)
;
}
removeListener
:
function
(
callback
)
{
}
hasListener
:
function
(
callback
)
{
}
}
;
}
function
injectAPI
(
source
dest
)
{
for
(
let
prop
in
source
)
{
if
(
prop
[
0
]
=
=
"
_
"
)
{
continue
;
}
let
desc
=
Object
.
getOwnPropertyDescriptor
(
source
prop
)
;
if
(
typeof
(
desc
.
value
)
=
=
"
function
"
)
{
Cu
.
exportFunction
(
desc
.
value
dest
{
defineAs
:
prop
}
)
;
}
else
if
(
typeof
(
desc
.
value
)
=
=
"
object
"
)
{
let
obj
=
Cu
.
createObjectIn
(
dest
{
defineAs
:
prop
}
)
;
injectAPI
(
desc
.
value
obj
)
;
}
else
{
Object
.
defineProperty
(
dest
prop
desc
)
;
}
}
}
function
promiseDocumentReady
(
doc
)
{
if
(
doc
.
readyState
=
=
"
interactive
"
|
|
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
addEventListener
(
"
DOMContentLoaded
"
function
onReady
(
event
)
{
if
(
event
.
target
=
=
=
event
.
currentTarget
)
{
doc
.
removeEventListener
(
"
DOMContentLoaded
"
onReady
true
)
;
resolve
(
doc
)
;
}
}
true
)
;
}
)
;
}
function
promiseDocumentLoaded
(
doc
)
{
if
(
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
defaultView
.
addEventListener
(
"
load
"
function
onReady
(
event
)
{
doc
.
defaultView
.
removeEventListener
(
"
load
"
onReady
)
;
resolve
(
doc
)
;
}
)
;
}
)
;
}
function
promiseEvent
(
element
eventName
useCapture
=
true
test
=
event
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
function
listener
(
event
)
{
if
(
test
(
event
)
)
{
element
.
removeEventListener
(
eventName
listener
useCapture
)
;
resolve
(
event
)
;
}
}
element
.
addEventListener
(
eventName
listener
useCapture
)
;
}
)
;
}
function
promiseObserved
(
topic
test
=
(
)
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
test
(
subject
data
)
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
{
subject
data
}
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
topic
false
)
;
}
)
;
}
let
gNextPortId
=
1
;
function
Port
(
context
senderMM
receiverMMs
name
id
sender
recipient
)
{
this
.
context
=
context
;
this
.
senderMM
=
senderMM
;
this
.
receiverMMs
=
receiverMMs
;
this
.
name
=
name
;
this
.
id
=
id
;
this
.
sender
=
sender
;
this
.
recipient
=
recipient
;
this
.
disconnected
=
false
;
this
.
disconnectListeners
=
new
Set
(
)
;
this
.
handlerBase
=
{
messageFilterStrict
:
{
portId
:
id
}
filterMessage
:
(
sender
recipient
)
=
>
{
if
(
!
sender
.
contextId
)
{
Cu
.
reportError
(
"
Missing
sender
.
contextId
in
message
to
Port
"
)
;
return
false
;
}
return
sender
.
contextId
!
=
=
this
.
context
.
contextId
;
}
}
;
this
.
disconnectHandler
=
Object
.
assign
(
{
receiveMessage
:
(
)
=
>
this
.
disconnectByOtherEnd
(
)
}
this
.
handlerBase
)
;
MessageChannel
.
addListener
(
this
.
receiverMMs
"
Extension
:
Port
:
Disconnect
"
this
.
disconnectHandler
)
;
this
.
context
.
callOnClose
(
this
)
;
}
Port
.
prototype
=
{
api
(
)
{
let
portObj
=
Cu
.
createObjectIn
(
this
.
context
.
cloneScope
)
;
let
publicAPI
=
{
name
:
this
.
name
disconnect
:
(
)
=
>
{
this
.
disconnect
(
)
;
}
postMessage
:
json
=
>
{
if
(
this
.
disconnected
)
{
throw
new
this
.
context
.
cloneScope
.
Error
(
"
Attempt
to
postMessage
on
disconnected
port
"
)
;
}
this
.
_sendMessage
(
"
Extension
:
Port
:
PostMessage
"
json
)
;
}
onDisconnect
:
new
EventManager
(
this
.
context
"
Port
.
onDisconnect
"
fire
=
>
{
let
listener
=
(
)
=
>
{
if
(
this
.
context
.
active
&
&
!
this
.
disconnected
)
{
fire
.
withoutClone
(
portObj
)
;
}
}
;
this
.
disconnectListeners
.
add
(
listener
)
;
return
(
)
=
>
{
this
.
disconnectListeners
.
delete
(
listener
)
;
}
;
}
)
.
api
(
)
onMessage
:
new
EventManager
(
this
.
context
"
Port
.
onMessage
"
fire
=
>
{
let
handler
=
Object
.
assign
(
{
receiveMessage
:
(
{
data
}
)
=
>
{
if
(
this
.
context
.
active
&
&
!
this
.
disconnected
)
{
fire
(
data
)
;
}
}
}
this
.
handlerBase
)
;
MessageChannel
.
addListener
(
this
.
receiverMMs
"
Extension
:
Port
:
PostMessage
"
handler
)
;
return
(
)
=
>
{
MessageChannel
.
removeListener
(
this
.
receiverMMs
"
Extension
:
Port
:
PostMessage
"
handler
)
;
}
;
}
)
.
api
(
)
}
;
if
(
this
.
sender
)
{
publicAPI
.
sender
=
this
.
sender
;
}
injectAPI
(
publicAPI
portObj
)
;
return
portObj
;
}
_sendMessage
(
message
data
)
{
let
options
=
{
recipient
:
Object
.
assign
(
{
}
this
.
recipient
{
portId
:
this
.
id
}
)
responseType
:
MessageChannel
.
RESPONSE_NONE
}
;
return
this
.
context
.
sendMessage
(
this
.
senderMM
message
data
options
)
;
}
handleDisconnection
(
)
{
MessageChannel
.
removeListener
(
this
.
receiverMMs
"
Extension
:
Port
:
Disconnect
"
this
.
disconnectHandler
)
;
this
.
context
.
forgetOnClose
(
this
)
;
this
.
disconnected
=
true
;
}
disconnectByOtherEnd
(
)
{
if
(
this
.
disconnected
)
{
return
;
}
for
(
let
listener
of
this
.
disconnectListeners
)
{
listener
(
)
;
}
this
.
handleDisconnection
(
)
;
}
disconnect
(
)
{
if
(
this
.
disconnected
)
{
return
;
}
this
.
handleDisconnection
(
)
;
this
.
_sendMessage
(
"
Extension
:
Port
:
Disconnect
"
null
)
;
}
close
(
)
{
this
.
disconnect
(
)
;
}
}
;
function
getMessageManager
(
target
)
{
if
(
target
instanceof
Ci
.
nsIFrameLoaderOwner
)
{
return
target
.
QueryInterface
(
Ci
.
nsIFrameLoaderOwner
)
.
frameLoader
.
messageManager
;
}
return
target
.
QueryInterface
(
Ci
.
nsIMessageSender
)
;
}
function
Messenger
(
context
messageManagers
sender
filter
optionalFilter
)
{
this
.
context
=
context
;
this
.
messageManagers
=
messageManagers
;
this
.
sender
=
sender
;
this
.
filter
=
filter
;
this
.
optionalFilter
=
optionalFilter
;
MessageChannel
.
setupMessageManagers
(
messageManagers
)
;
}
Messenger
.
prototype
=
{
_sendMessage
(
messageManager
message
data
recipient
)
{
let
options
=
{
recipient
sender
:
this
.
sender
responseType
:
MessageChannel
.
RESPONSE_FIRST
}
;
return
this
.
context
.
sendMessage
(
messageManager
message
data
options
)
;
}
sendMessage
(
messageManager
msg
recipient
responseCallback
)
{
let
promise
=
this
.
_sendMessage
(
messageManager
"
Extension
:
Message
"
msg
recipient
)
.
catch
(
error
=
>
{
if
(
error
.
result
=
=
MessageChannel
.
RESULT_NO_HANDLER
)
{
return
Promise
.
reject
(
{
message
:
"
Could
not
establish
connection
.
Receiving
end
does
not
exist
.
"
}
)
;
}
else
if
(
error
.
result
!
=
MessageChannel
.
RESULT_NO_RESPONSE
)
{
return
Promise
.
reject
(
{
message
:
error
.
message
}
)
;
}
}
)
;
return
this
.
context
.
wrapPromise
(
promise
responseCallback
)
;
}
onMessage
(
name
)
{
return
new
SingletonEventManager
(
this
.
context
name
callback
=
>
{
let
listener
=
{
messageFilterPermissive
:
this
.
optionalFilter
messageFilterStrict
:
this
.
filter
filterMessage
:
(
sender
recipient
)
=
>
{
return
sender
.
contextId
!
=
=
this
.
context
.
contextId
;
}
receiveMessage
:
(
{
target
data
:
message
sender
recipient
}
)
=
>
{
if
(
!
this
.
context
.
active
)
{
return
;
}
let
sendResponse
;
let
response
=
undefined
;
let
promise
=
new
Promise
(
resolve
=
>
{
sendResponse
=
value
=
>
{
resolve
(
value
)
;
response
=
promise
;
}
;
}
)
;
message
=
Cu
.
cloneInto
(
message
this
.
context
.
cloneScope
)
;
sender
=
Cu
.
cloneInto
(
sender
this
.
context
.
cloneScope
)
;
sendResponse
=
Cu
.
exportFunction
(
sendResponse
this
.
context
.
cloneScope
)
;
let
result
=
callback
(
message
sender
sendResponse
)
;
if
(
result
instanceof
this
.
context
.
cloneScope
.
Promise
)
{
return
result
;
}
else
if
(
result
=
=
=
true
)
{
return
promise
;
}
return
response
;
}
}
;
MessageChannel
.
addListener
(
this
.
messageManagers
"
Extension
:
Message
"
listener
)
;
return
(
)
=
>
{
MessageChannel
.
removeListener
(
this
.
messageManagers
"
Extension
:
Message
"
listener
)
;
}
;
}
)
.
api
(
)
;
}
connect
(
messageManager
name
recipient
)
{
let
portId
=
{
gNextPortId
+
+
}
-
{
Services
.
appinfo
.
uniqueProcessID
}
;
let
port
=
new
Port
(
this
.
context
messageManager
this
.
messageManagers
name
portId
null
recipient
)
;
let
msg
=
{
name
portId
}
;
this
.
_sendMessage
(
messageManager
"
Extension
:
Connect
"
msg
recipient
)
.
catch
(
e
=
>
port
.
disconnectByOtherEnd
(
)
)
;
return
port
.
api
(
)
;
}
onConnect
(
name
)
{
return
new
SingletonEventManager
(
this
.
context
name
callback
=
>
{
let
listener
=
{
messageFilterPermissive
:
this
.
optionalFilter
messageFilterStrict
:
this
.
filter
filterMessage
:
(
sender
recipient
)
=
>
{
return
sender
.
contextId
!
=
=
this
.
context
.
contextId
;
}
receiveMessage
:
(
{
target
data
:
message
sender
}
)
=
>
{
let
{
name
portId
}
=
message
;
let
mm
=
getMessageManager
(
target
)
;
let
recipient
=
Object
.
assign
(
{
}
sender
)
;
if
(
recipient
.
tab
)
{
recipient
.
tabId
=
recipient
.
tab
.
id
;
delete
recipient
.
tab
;
}
let
port
=
new
Port
(
this
.
context
mm
this
.
messageManagers
name
portId
sender
recipient
)
;
this
.
context
.
runSafeWithoutClone
(
callback
port
.
api
(
)
)
;
return
true
;
}
}
;
MessageChannel
.
addListener
(
this
.
messageManagers
"
Extension
:
Connect
"
listener
)
;
return
(
)
=
>
{
MessageChannel
.
removeListener
(
this
.
messageManagers
"
Extension
:
Connect
"
listener
)
;
}
;
}
)
.
api
(
)
;
}
}
;
function
flushJarCache
(
jarFile
)
{
Services
.
obs
.
notifyObservers
(
jarFile
"
flush
-
cache
-
entry
"
null
)
;
}
const
PlatformInfo
=
Object
.
freeze
(
{
os
:
(
function
(
)
{
let
os
=
AppConstants
.
platform
;
if
(
os
=
=
"
macosx
"
)
{
os
=
"
mac
"
;
}
return
os
;
}
)
(
)
arch
:
(
function
(
)
{
let
abi
=
Services
.
appinfo
.
XPCOMABI
;
let
[
arch
]
=
abi
.
split
(
"
-
"
)
;
if
(
arch
=
=
"
x86
"
)
{
arch
=
"
x86
-
32
"
;
}
else
if
(
arch
=
=
"
x86_64
"
)
{
arch
=
"
x86
-
64
"
;
}
return
arch
;
}
)
(
)
}
)
;
function
detectLanguage
(
text
)
{
return
LanguageDetector
.
detectLanguage
(
text
)
.
then
(
result
=
>
(
{
isReliable
:
result
.
confident
languages
:
result
.
languages
.
map
(
lang
=
>
{
return
{
language
:
lang
.
languageCode
percentage
:
lang
.
percent
}
;
}
)
}
)
)
;
}
class
SchemaAPIInterface
{
callFunction
(
args
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
callFunctionNoReturn
(
args
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
callAsyncFunction
(
args
callback
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
getProperty
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
setProperty
(
value
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
addListener
(
listener
args
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
hasListener
(
listener
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
removeListener
(
listener
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
class
LocalAPIImplementation
extends
SchemaAPIInterface
{
constructor
(
pathObj
name
context
)
{
super
(
)
;
this
.
pathObj
=
pathObj
;
this
.
name
=
name
;
this
.
context
=
context
;
}
callFunction
(
args
)
{
return
this
.
pathObj
[
this
.
name
]
(
.
.
.
args
)
;
}
callFunctionNoReturn
(
args
)
{
this
.
pathObj
[
this
.
name
]
(
.
.
.
args
)
;
}
callAsyncFunction
(
args
callback
)
{
let
promise
;
try
{
promise
=
this
.
pathObj
[
this
.
name
]
(
.
.
.
args
)
|
|
Promise
.
resolve
(
)
;
}
catch
(
e
)
{
promise
=
Promise
.
reject
(
e
)
;
}
return
this
.
context
.
wrapPromise
(
promise
callback
)
;
}
getProperty
(
)
{
return
this
.
pathObj
[
this
.
name
]
;
}
setProperty
(
value
)
{
this
.
pathObj
[
this
.
name
]
=
value
;
}
addListener
(
listener
args
)
{
this
.
pathObj
[
this
.
name
]
.
addListener
.
call
(
null
listener
.
.
.
args
)
;
}
hasListener
(
listener
)
{
return
this
.
pathObj
[
this
.
name
]
.
hasListener
.
call
(
null
listener
)
;
}
removeListener
(
listener
)
{
this
.
pathObj
[
this
.
name
]
.
removeListener
.
call
(
null
listener
)
;
}
}
let
nextId
=
1
;
class
ProxyAPIImplementation
extends
SchemaAPIInterface
{
constructor
(
namespace
name
childApiManager
)
{
super
(
)
;
this
.
path
=
{
namespace
}
.
{
name
}
;
this
.
childApiManager
=
childApiManager
;
}
callFunctionNoReturn
(
args
)
{
this
.
childApiManager
.
callParentFunctionNoReturn
(
this
.
path
args
)
;
}
callAsyncFunction
(
args
callback
)
{
return
this
.
childApiManager
.
callParentAsyncFunction
(
this
.
path
args
callback
)
;
}
addListener
(
listener
args
)
{
let
set
=
this
.
childApiManager
.
listeners
.
get
(
this
.
path
)
;
if
(
!
set
)
{
set
=
new
Set
(
)
;
this
.
childApiManager
.
listeners
.
set
(
this
.
path
set
)
;
}
set
.
add
(
listener
)
;
if
(
set
.
size
=
=
1
)
{
args
=
args
.
slice
(
1
)
;
this
.
childApiManager
.
messageManager
.
sendAsyncMessage
(
"
API
:
AddListener
"
{
childId
:
this
.
childApiManager
.
id
path
:
this
.
path
args
}
)
;
}
}
removeListener
(
listener
)
{
let
set
=
this
.
childApiManager
.
listeners
.
get
(
this
.
path
)
;
if
(
!
set
)
{
return
;
}
set
.
delete
(
listener
)
;
if
(
set
.
size
=
=
0
)
{
this
.
childApiManager
.
messageManager
.
sendAsyncMessage
(
"
API
:
RemoveListener
"
{
childId
:
this
.
childApiManager
.
id
path
:
this
.
path
}
)
;
}
}
hasListener
(
listener
)
{
let
set
=
this
.
childApiManager
.
listeners
.
get
(
this
.
path
)
;
return
set
?
set
.
has
(
listener
)
:
false
;
}
}
class
ChildAPIManager
{
constructor
(
context
messageManager
localApis
contextData
)
{
this
.
context
=
context
;
this
.
messageManager
=
messageManager
;
this
.
localApis
=
localApis
;
let
id
=
String
(
context
.
extension
.
id
)
+
"
.
"
+
String
(
context
.
contextId
)
;
this
.
id
=
id
;
let
data
=
{
childId
:
id
extensionId
:
context
.
extension
.
id
principal
:
context
.
principal
}
;
Object
.
assign
(
data
contextData
)
;
messageManager
.
addMessageListener
(
"
API
:
RunListener
"
this
)
;
messageManager
.
addMessageListener
(
"
API
:
CallResult
"
this
)
;
this
.
listeners
=
new
Map
(
)
;
this
.
callPromises
=
new
Map
(
)
;
this
.
createProxyContextInConstructor
(
data
)
;
}
createProxyContextInConstructor
(
data
)
{
this
.
messageManager
.
sendAsyncMessage
(
"
API
:
CreateProxyContext
"
data
)
;
}
receiveMessage
(
{
name
data
}
)
{
if
(
data
.
childId
!
=
this
.
id
)
{
return
;
}
switch
(
name
)
{
case
"
API
:
RunListener
"
:
let
listeners
=
this
.
listeners
.
get
(
data
.
path
)
;
for
(
let
callback
of
listeners
)
{
runSafe
(
this
.
context
callback
.
.
.
data
.
args
)
;
}
break
;
case
"
API
:
CallResult
"
:
let
deferred
=
this
.
callPromises
.
get
(
data
.
callId
)
;
if
(
data
.
lastError
)
{
deferred
.
reject
(
{
message
:
data
.
lastError
}
)
;
}
else
{
deferred
.
resolve
(
new
SpreadArgs
(
data
.
args
)
)
;
}
this
.
callPromises
.
delete
(
data
.
callId
)
;
break
;
}
}
callParentFunctionNoReturn
(
path
args
)
{
this
.
messageManager
.
sendAsyncMessage
(
"
API
:
Call
"
{
childId
:
this
.
id
path
args
}
)
;
}
callParentAsyncFunction
(
path
args
callback
)
{
let
callId
=
nextId
+
+
;
let
deferred
=
PromiseUtils
.
defer
(
)
;
this
.
callPromises
.
set
(
callId
deferred
)
;
this
.
messageManager
.
sendAsyncMessage
(
"
API
:
Call
"
{
childId
:
this
.
id
callId
path
args
}
)
;
return
this
.
context
.
wrapPromise
(
deferred
.
promise
callback
)
;
}
getParentEvent
(
path
)
{
let
parsed
=
/
^
(
.
+
)
\
.
(
on
[
A
-
Z
]
[
^
.
]
+
)
/
.
exec
(
path
)
;
if
(
!
parsed
)
{
throw
new
Error
(
"
getParentEvent
:
Invalid
event
name
:
"
+
path
)
;
}
let
[
namespace
name
]
=
parsed
;
let
impl
=
new
ProxyAPIImplementation
(
namespace
name
this
)
;
return
{
addListener
:
(
listener
.
.
.
args
)
=
>
impl
.
addListener
(
listener
args
)
removeListener
:
(
listener
)
=
>
impl
.
removeListener
(
listener
)
hasListener
:
(
listener
)
=
>
impl
.
hasListener
(
listener
)
}
;
}
close
(
)
{
this
.
messageManager
.
sendAsyncMessage
(
"
API
:
CloseProxyContext
"
{
childId
:
this
.
id
}
)
;
}
get
cloneScope
(
)
{
return
this
.
context
.
cloneScope
;
}
get
principal
(
)
{
return
this
.
context
.
principal
;
}
shouldInject
(
namespace
name
allowedContexts
)
{
if
(
this
.
context
.
envType
=
=
=
"
content_child
"
&
&
!
allowedContexts
.
includes
(
"
content
"
)
)
{
return
false
;
}
if
(
allowedContexts
.
includes
(
"
addon_parent_only
"
)
)
{
return
false
;
}
return
true
;
}
getImplementation
(
namespace
name
)
{
let
pathObj
=
this
.
localApis
;
if
(
pathObj
)
{
for
(
let
part
of
namespace
.
split
(
"
.
"
)
)
{
pathObj
=
pathObj
[
part
]
;
if
(
!
pathObj
)
{
break
;
}
}
if
(
pathObj
&
&
name
in
pathObj
)
{
return
new
LocalAPIImplementation
(
pathObj
name
this
.
context
)
;
}
}
return
this
.
getFallbackImplementation
(
namespace
name
)
;
}
getFallbackImplementation
(
namespace
name
)
{
return
new
ProxyAPIImplementation
(
namespace
name
this
)
;
}
hasPermission
(
permission
)
{
return
this
.
context
.
extension
.
hasPermission
(
permission
)
;
}
}
class
SchemaAPIManager
extends
EventEmitter
{
constructor
(
processType
)
{
super
(
)
;
this
.
processType
=
processType
;
this
.
global
=
this
.
_createExtGlobal
(
)
;
this
.
_scriptScopes
=
[
]
;
this
.
_schemaApis
=
{
addon_parent
:
[
]
addon_child
:
[
]
content_parent
:
[
]
content_child
:
[
]
}
;
}
_createExtGlobal
(
)
{
let
global
=
Cu
.
Sandbox
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
{
wantXrays
:
false
sandboxName
:
Namespace
of
ext
-
*
.
js
scripts
for
{
this
.
processType
}
}
)
;
Object
.
defineProperty
(
global
"
console
"
{
get
(
)
{
return
console
;
}
}
)
;
global
.
extensions
=
this
;
global
.
global
=
global
;
global
.
Cc
=
Cc
;
global
.
Ci
=
Ci
;
global
.
Cu
=
Cu
;
global
.
Cr
=
Cr
;
XPCOMUtils
.
defineLazyModuleGetter
(
global
"
require
"
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
global
.
XPCOMUtils
=
XPCOMUtils
;
return
global
;
}
loadScript
(
scriptUrl
)
{
let
scope
=
Cu
.
createObjectIn
(
this
.
global
)
;
Services
.
scriptloader
.
loadSubScript
(
scriptUrl
scope
"
UTF
-
8
"
)
;
this
.
_scriptScopes
.
push
(
scope
)
;
}
registerSchemaAPI
(
namespace
envType
getAPI
)
{
this
.
_schemaApis
[
envType
]
.
push
(
{
namespace
getAPI
}
)
;
}
generateAPIs
(
context
obj
)
{
let
apis
=
this
.
_schemaApis
[
context
.
envType
]
;
if
(
!
apis
)
{
Cu
.
reportError
(
No
APIs
have
been
registered
for
{
context
.
envType
}
)
;
return
;
}
SchemaAPIManager
.
generateAPIs
(
context
apis
obj
)
;
}
static
generateAPIs
(
context
apis
obj
)
{
function
copy
(
dest
source
)
{
for
(
let
prop
in
source
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
source
prop
)
;
if
(
typeof
(
desc
.
value
)
=
=
"
object
"
)
{
if
(
!
(
prop
in
dest
)
)
{
dest
[
prop
]
=
{
}
;
}
copy
(
dest
[
prop
]
source
[
prop
]
)
;
}
else
{
Object
.
defineProperty
(
dest
prop
desc
)
;
}
}
}
for
(
let
api
of
apis
)
{
if
(
Schemas
.
checkPermissions
(
api
.
namespace
context
.
extension
)
)
{
api
=
api
.
getAPI
(
context
)
;
copy
(
obj
api
)
;
}
}
}
}
function
normalizeTime
(
date
)
{
return
new
Date
(
(
typeof
date
=
=
"
string
"
&
&
/
^
\
d
+
/
.
test
(
date
)
)
?
parseInt
(
date
10
)
:
date
)
;
}
const
stylesheetMap
=
new
DefaultMap
(
url
=
>
{
let
uri
=
NetUtil
.
newURI
(
url
)
;
return
styleSheetService
.
preloadSheet
(
uri
styleSheetService
.
AGENT_SHEET
)
;
}
)
;
this
.
ExtensionUtils
=
{
detectLanguage
extend
flushJarCache
getConsole
getInnerWindowID
ignoreEvent
injectAPI
instanceOf
normalizeTime
promiseDocumentLoaded
promiseDocumentReady
promiseEvent
promiseObserved
runSafe
runSafeSync
runSafeSyncWithoutClone
runSafeWithoutClone
stylesheetMap
BaseContext
DefaultWeakMap
EventEmitter
EventManager
IconDetails
LocalAPIImplementation
LocaleData
Messenger
PlatformInfo
SchemaAPIInterface
SingletonEventManager
SpreadArgs
ChildAPIManager
SchemaAPIManager
}
;
