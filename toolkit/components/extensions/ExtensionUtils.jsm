"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionUtils
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
const
INTEGER
=
/
^
[
1
-
9
]
\
d
*
/
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ConsoleAPI
"
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LanguageDetector
"
"
resource
:
/
/
/
modules
/
translation
/
LanguageDetector
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Locale
"
"
resource
:
/
/
gre
/
modules
/
Locale
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MessageChannel
"
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Schemas
"
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
styleSheetService
"
"
mozilla
.
org
/
content
/
style
-
sheet
-
service
;
1
"
"
nsIStyleSheetService
"
)
;
function
getConsole
(
)
{
return
new
ConsoleAPI
(
{
maxLogLevelPref
:
"
extensions
.
webextensions
.
log
.
level
"
prefix
:
"
WebExtensions
"
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
getConsole
)
;
let
nextId
=
0
;
const
{
uniqueProcessID
}
=
Services
.
appinfo
;
function
getUniqueId
(
)
{
return
{
nextId
+
+
}
-
{
uniqueProcessID
}
;
}
class
ExtensionError
extends
Error
{
}
function
filterStack
(
error
)
{
return
String
(
error
.
stack
)
.
replace
(
/
(
^
.
*
(
Task
\
.
jsm
|
Promise
-
backend
\
.
js
)
.
*
\
n
)
+
/
gm
"
<
Promise
Chain
>
\
n
"
)
;
}
function
runSafeSyncWithoutClone
(
f
.
.
.
args
)
{
try
{
return
f
(
.
.
.
args
)
;
}
catch
(
e
)
{
dump
(
Extension
error
:
{
e
}
{
e
.
fileName
}
{
e
.
lineNumber
}
\
n
[
[
Exception
stack
\
n
{
filterStack
(
e
)
}
Current
stack
\
n
{
filterStack
(
Error
(
)
)
}
]
]
\
n
)
;
Cu
.
reportError
(
e
)
;
}
}
function
runSafeWithoutClone
(
f
.
.
.
args
)
{
if
(
typeof
(
f
)
!
=
"
function
"
)
{
dump
(
Extension
error
:
expected
function
\
n
{
filterStack
(
Error
(
)
)
}
)
;
return
;
}
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
runSafeSyncWithoutClone
(
f
.
.
.
args
)
;
}
)
;
}
function
runSafeSync
(
context
f
.
.
.
args
)
{
if
(
context
.
unloaded
)
{
Cu
.
reportError
(
"
runSafeSync
called
after
context
unloaded
"
)
;
return
;
}
try
{
args
=
Cu
.
cloneInto
(
args
context
.
cloneScope
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
context
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
return
runSafeSyncWithoutClone
(
f
.
.
.
args
)
;
}
function
runSafe
(
context
f
.
.
.
args
)
{
try
{
args
=
Cu
.
cloneInto
(
args
context
.
cloneScope
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
context
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
if
(
context
.
unloaded
)
{
dump
(
runSafe
failure
:
context
is
already
unloaded
{
filterStack
(
new
Error
(
)
)
}
\
n
)
;
return
undefined
;
}
return
runSafeWithoutClone
(
f
.
.
.
args
)
;
}
function
getInnerWindowID
(
window
)
{
return
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
}
function
instanceOf
(
value
type
)
{
return
{
}
.
toString
.
call
(
value
)
=
=
[
object
{
type
}
]
;
}
function
extend
(
obj
.
.
.
args
)
{
for
(
let
arg
of
args
)
{
let
props
=
[
.
.
.
Object
.
getOwnPropertyNames
(
arg
)
.
.
.
Object
.
getOwnPropertySymbols
(
arg
)
]
;
for
(
let
prop
of
props
)
{
let
descriptor
=
Object
.
getOwnPropertyDescriptor
(
arg
prop
)
;
Object
.
defineProperty
(
obj
prop
descriptor
)
;
}
}
return
obj
;
}
class
DefaultWeakMap
extends
WeakMap
{
constructor
(
defaultConstructor
init
)
{
super
(
init
)
;
this
.
defaultConstructor
=
defaultConstructor
;
}
get
(
key
)
{
if
(
!
this
.
has
(
key
)
)
{
this
.
set
(
key
this
.
defaultConstructor
(
key
)
)
;
}
return
super
.
get
(
key
)
;
}
}
class
DefaultMap
extends
Map
{
constructor
(
defaultConstructor
init
)
{
super
(
init
)
;
this
.
defaultConstructor
=
defaultConstructor
;
}
get
(
key
)
{
if
(
!
this
.
has
(
key
)
)
{
this
.
set
(
key
this
.
defaultConstructor
(
key
)
)
;
}
return
super
.
get
(
key
)
;
}
}
class
SpreadArgs
extends
Array
{
constructor
(
args
)
{
super
(
)
;
this
.
push
(
.
.
.
args
)
;
}
}
let
IconDetails
=
{
normalize
(
details
extension
context
=
null
)
{
let
result
=
{
}
;
try
{
if
(
details
.
imageData
)
{
let
imageData
=
details
.
imageData
;
if
(
typeof
imageData
=
=
"
string
"
)
{
imageData
=
{
"
19
"
:
imageData
}
;
}
for
(
let
size
of
Object
.
keys
(
imageData
)
)
{
if
(
!
INTEGER
.
test
(
size
)
)
{
throw
new
ExtensionError
(
Invalid
icon
size
{
size
}
must
be
an
integer
)
;
}
result
[
size
]
=
imageData
[
size
]
;
}
}
if
(
details
.
path
)
{
let
path
=
details
.
path
;
if
(
typeof
path
!
=
"
object
"
)
{
path
=
{
"
19
"
:
path
}
;
}
let
baseURI
=
context
?
context
.
uri
:
extension
.
baseURI
;
for
(
let
size
of
Object
.
keys
(
path
)
)
{
if
(
!
INTEGER
.
test
(
size
)
)
{
throw
new
ExtensionError
(
Invalid
icon
size
{
size
}
must
be
an
integer
)
;
}
let
url
=
baseURI
.
resolve
(
path
[
size
]
)
;
try
{
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
extension
.
principal
url
Services
.
scriptSecurityManager
.
DISALLOW_SCRIPT
)
;
}
catch
(
e
)
{
throw
new
ExtensionError
(
Illegal
URL
{
url
}
)
;
}
result
[
size
]
=
url
;
}
}
}
catch
(
e
)
{
if
(
context
)
{
throw
e
;
}
extension
.
manifestError
(
Invalid
icon
data
:
{
e
}
)
;
}
return
result
;
}
getPreferredIcon
(
icons
extension
=
null
size
=
16
)
{
const
DEFAULT
=
"
chrome
:
/
/
browser
/
content
/
extension
.
svg
"
;
let
bestSize
=
null
;
if
(
icons
[
size
]
)
{
bestSize
=
size
;
}
else
if
(
icons
[
2
*
size
]
)
{
bestSize
=
2
*
size
;
}
else
{
let
sizes
=
Object
.
keys
(
icons
)
.
map
(
key
=
>
parseInt
(
key
10
)
)
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
bestSize
=
sizes
.
find
(
candidate
=
>
candidate
>
size
)
|
|
sizes
.
pop
(
)
;
}
if
(
bestSize
)
{
return
{
size
:
bestSize
icon
:
icons
[
bestSize
]
}
;
}
return
{
size
icon
:
DEFAULT
}
;
}
convertImageURLToDataURL
(
imageURL
contentWindow
browserWindow
size
=
18
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
image
=
new
contentWindow
.
Image
(
)
;
image
.
onload
=
function
(
)
{
let
canvas
=
contentWindow
.
document
.
createElement
(
"
canvas
"
)
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
let
dSize
=
size
*
browserWindow
.
devicePixelRatio
;
let
dWidth
dHeight
dx
dy
;
if
(
this
.
width
>
this
.
height
)
{
dWidth
=
dSize
;
dHeight
=
image
.
height
*
(
dSize
/
image
.
width
)
;
dx
=
0
;
dy
=
(
dSize
-
dHeight
)
/
2
;
}
else
{
dWidth
=
image
.
width
*
(
dSize
/
image
.
height
)
;
dHeight
=
dSize
;
dx
=
(
dSize
-
dWidth
)
/
2
;
dy
=
0
;
}
ctx
.
drawImage
(
this
0
0
this
.
width
this
.
height
dx
dy
dWidth
dHeight
)
;
resolve
(
canvas
.
toDataURL
(
"
image
/
png
"
)
)
;
}
;
image
.
onerror
=
reject
;
image
.
src
=
imageURL
;
}
)
;
}
escapeUrl
(
url
)
{
return
url
.
replace
(
/
[
\
\
\
s
"
]
/
g
encodeURIComponent
)
;
}
}
;
const
LISTENERS
=
Symbol
(
"
listeners
"
)
;
class
EventEmitter
{
constructor
(
)
{
this
[
LISTENERS
]
=
new
Map
(
)
;
}
on
(
event
listener
)
{
if
(
!
this
[
LISTENERS
]
.
has
(
event
)
)
{
this
[
LISTENERS
]
.
set
(
event
new
Set
(
)
)
;
}
this
[
LISTENERS
]
.
get
(
event
)
.
add
(
listener
)
;
}
off
(
event
listener
)
{
if
(
this
[
LISTENERS
]
.
has
(
event
)
)
{
let
set
=
this
[
LISTENERS
]
.
get
(
event
)
;
set
.
delete
(
listener
)
;
if
(
!
set
.
size
)
{
this
[
LISTENERS
]
.
delete
(
event
)
;
}
}
}
emit
(
event
.
.
.
args
)
{
let
listeners
=
this
[
LISTENERS
]
.
get
(
event
)
|
|
new
Set
(
)
;
let
promises
=
Array
.
from
(
listeners
listener
=
>
{
return
runSafeSyncWithoutClone
(
listener
event
.
.
.
args
)
;
}
)
;
return
Promise
.
all
(
promises
)
;
}
}
function
LocaleData
(
data
)
{
this
.
defaultLocale
=
data
.
defaultLocale
;
this
.
selectedLocale
=
data
.
selectedLocale
;
this
.
locales
=
data
.
locales
|
|
new
Map
(
)
;
this
.
warnedMissingKeys
=
new
Set
(
)
;
this
.
messages
=
data
.
messages
|
|
new
Map
(
)
;
if
(
data
.
builtinMessages
)
{
this
.
messages
.
set
(
this
.
BUILTIN
data
.
builtinMessages
)
;
}
}
LocaleData
.
prototype
=
{
serialize
(
)
{
return
{
defaultLocale
:
this
.
defaultLocale
selectedLocale
:
this
.
selectedLocale
messages
:
this
.
messages
locales
:
this
.
locales
}
;
}
BUILTIN
:
"
BUILTIN_MESSAGES
"
has
(
locale
)
{
return
this
.
messages
.
has
(
locale
)
;
}
localizeMessage
(
message
substitutions
=
[
]
options
=
{
}
)
{
let
defaultOptions
=
{
locale
:
this
.
selectedLocale
defaultValue
:
"
"
cloneScope
:
null
}
;
options
=
Object
.
assign
(
defaultOptions
options
)
;
let
locales
=
new
Set
(
[
this
.
BUILTIN
options
.
locale
this
.
defaultLocale
]
.
filter
(
locale
=
>
this
.
messages
.
has
(
locale
)
)
)
;
message
=
message
.
toLowerCase
(
)
;
for
(
let
locale
of
locales
)
{
let
messages
=
this
.
messages
.
get
(
locale
)
;
if
(
messages
.
has
(
message
)
)
{
let
str
=
messages
.
get
(
message
)
;
if
(
!
Array
.
isArray
(
substitutions
)
)
{
substitutions
=
[
substitutions
]
;
}
let
replacer
=
(
matched
index
dollarSigns
)
=
>
{
if
(
index
)
{
index
=
parseInt
(
index
10
)
-
1
;
return
index
in
substitutions
?
substitutions
[
index
]
:
"
"
;
}
return
dollarSigns
;
}
;
return
str
.
replace
(
/
\
(
?
:
(
[
1
-
9
]
\
d
*
)
|
(
\
+
)
)
/
g
replacer
)
;
}
}
if
(
message
=
=
"
ui_locale
"
)
{
return
this
.
uiLocale
;
}
else
if
(
message
.
startsWith
(
"
bidi_
"
)
)
{
let
registry
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIXULChromeRegistry
)
;
let
rtl
=
registry
.
isLocaleRTL
(
"
global
"
)
;
if
(
message
=
=
"
bidi_dir
"
)
{
return
rtl
?
"
rtl
"
:
"
ltr
"
;
}
else
if
(
message
=
=
"
bidi_reversed_dir
"
)
{
return
rtl
?
"
ltr
"
:
"
rtl
"
;
}
else
if
(
message
=
=
"
bidi_start_edge
"
)
{
return
rtl
?
"
right
"
:
"
left
"
;
}
else
if
(
message
=
=
"
bidi_end_edge
"
)
{
return
rtl
?
"
left
"
:
"
right
"
;
}
}
if
(
!
this
.
warnedMissingKeys
.
has
(
message
)
)
{
let
error
=
Unknown
localization
message
{
message
}
;
if
(
options
.
cloneScope
)
{
error
=
new
options
.
cloneScope
.
Error
(
error
)
;
}
Cu
.
reportError
(
error
)
;
this
.
warnedMissingKeys
.
add
(
message
)
;
}
return
options
.
defaultValue
;
}
localize
(
str
locale
=
this
.
selectedLocale
)
{
if
(
!
str
)
{
return
str
;
}
return
str
.
replace
(
/
__MSG_
(
[
A
-
Za
-
z0
-
9
_
]
+
?
)
__
/
g
(
matched
message
)
=
>
{
return
this
.
localizeMessage
(
message
[
]
{
locale
defaultValue
:
matched
}
)
;
}
)
;
}
addLocale
(
locale
messages
extension
)
{
let
result
=
new
Map
(
)
;
if
(
!
instanceOf
(
messages
"
Object
"
)
)
{
extension
.
packagingError
(
Invalid
locale
data
for
{
locale
}
)
;
return
result
;
}
for
(
let
key
of
Object
.
keys
(
messages
)
)
{
let
msg
=
messages
[
key
]
;
if
(
!
instanceOf
(
msg
"
Object
"
)
|
|
typeof
(
msg
.
message
)
!
=
"
string
"
)
{
extension
.
packagingError
(
Invalid
locale
message
data
for
{
locale
}
message
{
JSON
.
stringify
(
key
)
}
)
;
continue
;
}
let
placeholders
=
new
Map
(
)
;
if
(
instanceOf
(
msg
.
placeholders
"
Object
"
)
)
{
for
(
let
key
of
Object
.
keys
(
msg
.
placeholders
)
)
{
placeholders
.
set
(
key
.
toLowerCase
(
)
msg
.
placeholders
[
key
]
)
;
}
}
let
replacer
=
(
match
name
)
=
>
{
let
replacement
=
placeholders
.
get
(
name
.
toLowerCase
(
)
)
;
if
(
instanceOf
(
replacement
"
Object
"
)
&
&
"
content
"
in
replacement
)
{
return
replacement
.
content
;
}
return
"
"
;
}
;
let
value
=
msg
.
message
.
replace
(
/
\
(
[
A
-
Za
-
z0
-
9
_
]
+
)
\
/
g
replacer
)
;
result
.
set
(
key
.
toLowerCase
(
)
value
)
;
}
this
.
messages
.
set
(
locale
result
)
;
return
result
;
}
get
acceptLanguages
(
)
{
let
result
=
Preferences
.
get
(
"
intl
.
accept_languages
"
"
"
Ci
.
nsIPrefLocalizedString
)
;
return
result
.
split
(
/
\
s
*
\
s
*
/
g
)
;
}
get
uiLocale
(
)
{
return
Locale
.
getLocale
(
)
.
replace
(
/
-
/
g
"
_
"
)
;
}
}
;
function
SingletonEventManager
(
context
name
register
)
{
this
.
context
=
context
;
this
.
name
=
name
;
this
.
register
=
register
;
this
.
unregister
=
new
Map
(
)
;
}
SingletonEventManager
.
prototype
=
{
addListener
(
callback
.
.
.
args
)
{
if
(
this
.
unregister
.
has
(
callback
)
)
{
return
;
}
let
shouldFire
=
(
)
=
>
{
if
(
this
.
context
.
unloaded
)
{
dump
(
{
this
.
name
}
event
fired
after
context
unloaded
.
\
n
)
;
}
else
if
(
!
this
.
context
.
active
)
{
dump
(
{
this
.
name
}
event
fired
while
context
is
inactive
.
\
n
)
;
}
else
if
(
this
.
unregister
.
has
(
callback
)
)
{
return
true
;
}
return
false
;
}
;
let
fire
=
{
sync
:
(
.
.
.
args
)
=
>
{
if
(
shouldFire
(
)
)
{
return
this
.
context
.
runSafe
(
callback
.
.
.
args
)
;
}
}
async
:
(
.
.
.
args
)
=
>
{
return
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
if
(
shouldFire
(
)
)
{
return
this
.
context
.
runSafe
(
callback
.
.
.
args
)
;
}
}
)
;
}
raw
:
(
.
.
.
args
)
=
>
{
if
(
!
shouldFire
(
)
)
{
throw
new
Error
(
"
Called
raw
(
)
on
unloaded
/
inactive
context
"
)
;
}
return
callback
(
.
.
.
args
)
;
}
asyncWithoutClone
:
(
.
.
.
args
)
=
>
{
return
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
if
(
shouldFire
(
)
)
{
return
this
.
context
.
runSafeWithoutClone
(
callback
.
.
.
args
)
;
}
}
)
;
}
}
;
let
unregister
=
this
.
register
(
fire
.
.
.
args
)
;
this
.
unregister
.
set
(
callback
unregister
)
;
this
.
context
.
callOnClose
(
this
)
;
}
removeListener
(
callback
)
{
if
(
!
this
.
unregister
.
has
(
callback
)
)
{
return
;
}
let
unregister
=
this
.
unregister
.
get
(
callback
)
;
this
.
unregister
.
delete
(
callback
)
;
unregister
(
)
;
if
(
this
.
unregister
.
size
=
=
0
)
{
this
.
context
.
forgetOnClose
(
this
)
;
}
}
hasListener
(
callback
)
{
return
this
.
unregister
.
has
(
callback
)
;
}
close
(
)
{
for
(
let
unregister
of
this
.
unregister
.
values
(
)
)
{
unregister
(
)
;
}
}
api
(
)
{
return
{
addListener
:
(
.
.
.
args
)
=
>
this
.
addListener
(
.
.
.
args
)
removeListener
:
(
.
.
.
args
)
=
>
this
.
removeListener
(
.
.
.
args
)
hasListener
:
(
.
.
.
args
)
=
>
this
.
hasListener
(
.
.
.
args
)
}
;
}
}
;
function
ignoreEvent
(
context
name
)
{
return
{
addListener
:
function
(
callback
)
{
let
id
=
context
.
extension
.
id
;
let
frame
=
Components
.
stack
.
caller
;
let
msg
=
In
add
-
on
{
id
}
attempting
to
use
listener
"
{
name
}
"
which
is
unimplemented
.
;
let
scriptError
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
scriptError
.
init
(
msg
frame
.
filename
null
frame
.
lineNumber
frame
.
columnNumber
Ci
.
nsIScriptError
.
warningFlag
"
content
javascript
"
)
;
let
consoleService
=
Cc
[
"
mozilla
.
org
/
consoleservice
;
1
"
]
.
getService
(
Ci
.
nsIConsoleService
)
;
consoleService
.
logMessage
(
scriptError
)
;
}
removeListener
:
function
(
callback
)
{
}
hasListener
:
function
(
callback
)
{
}
}
;
}
function
injectAPI
(
source
dest
)
{
for
(
let
prop
in
source
)
{
if
(
prop
[
0
]
=
=
"
_
"
)
{
continue
;
}
let
desc
=
Object
.
getOwnPropertyDescriptor
(
source
prop
)
;
if
(
typeof
(
desc
.
value
)
=
=
"
function
"
)
{
Cu
.
exportFunction
(
desc
.
value
dest
{
defineAs
:
prop
}
)
;
}
else
if
(
typeof
(
desc
.
value
)
=
=
"
object
"
)
{
let
obj
=
Cu
.
createObjectIn
(
dest
{
defineAs
:
prop
}
)
;
injectAPI
(
desc
.
value
obj
)
;
}
else
{
Object
.
defineProperty
(
dest
prop
desc
)
;
}
}
}
class
LimitedSet
extends
Set
{
constructor
(
limit
iterable
=
undefined
)
{
super
(
iterable
)
;
this
.
limit
=
limit
;
}
truncate
(
limit
)
{
for
(
let
item
of
this
)
{
if
(
this
.
size
<
=
limit
)
{
break
;
}
this
.
delete
(
item
)
;
}
}
add
(
item
)
{
if
(
!
this
.
has
(
item
)
&
&
this
.
size
>
=
this
.
limit
)
{
this
.
truncate
(
this
.
limit
-
1
)
;
}
super
.
add
(
item
)
;
}
}
function
promiseDocumentReady
(
doc
)
{
if
(
doc
.
readyState
=
=
"
interactive
"
|
|
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
addEventListener
(
"
DOMContentLoaded
"
function
onReady
(
event
)
{
if
(
event
.
target
=
=
=
event
.
currentTarget
)
{
doc
.
removeEventListener
(
"
DOMContentLoaded
"
onReady
true
)
;
resolve
(
doc
)
;
}
}
true
)
;
}
)
;
}
function
promiseDocumentLoaded
(
doc
)
{
if
(
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
defaultView
.
addEventListener
(
"
load
"
function
(
event
)
{
resolve
(
doc
)
;
}
{
once
:
true
}
)
;
}
)
;
}
function
promiseEvent
(
element
eventName
useCapture
=
true
test
=
event
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
function
listener
(
event
)
{
if
(
test
(
event
)
)
{
element
.
removeEventListener
(
eventName
listener
useCapture
)
;
resolve
(
event
)
;
}
}
element
.
addEventListener
(
eventName
listener
useCapture
)
;
}
)
;
}
function
promiseObserved
(
topic
test
=
(
)
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
test
(
subject
data
)
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
{
subject
data
}
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
topic
false
)
;
}
)
;
}
function
getMessageManager
(
target
)
{
if
(
target
instanceof
Ci
.
nsIFrameLoaderOwner
)
{
return
target
.
QueryInterface
(
Ci
.
nsIFrameLoaderOwner
)
.
frameLoader
.
messageManager
;
}
return
target
.
QueryInterface
(
Ci
.
nsIMessageSender
)
;
}
function
flushJarCache
(
jarPath
)
{
Services
.
obs
.
notifyObservers
(
null
"
flush
-
cache
-
entry
"
jarPath
)
;
}
const
PlatformInfo
=
Object
.
freeze
(
{
os
:
(
function
(
)
{
let
os
=
AppConstants
.
platform
;
if
(
os
=
=
"
macosx
"
)
{
os
=
"
mac
"
;
}
return
os
;
}
)
(
)
arch
:
(
function
(
)
{
let
abi
=
Services
.
appinfo
.
XPCOMABI
;
let
[
arch
]
=
abi
.
split
(
"
-
"
)
;
if
(
arch
=
=
"
x86
"
)
{
arch
=
"
x86
-
32
"
;
}
else
if
(
arch
=
=
"
x86_64
"
)
{
arch
=
"
x86
-
64
"
;
}
return
arch
;
}
)
(
)
}
)
;
function
detectLanguage
(
text
)
{
return
LanguageDetector
.
detectLanguage
(
text
)
.
then
(
result
=
>
(
{
isReliable
:
result
.
confident
languages
:
result
.
languages
.
map
(
lang
=
>
{
return
{
language
:
lang
.
languageCode
percentage
:
lang
.
percent
}
;
}
)
}
)
)
;
}
function
normalizeTime
(
date
)
{
return
new
Date
(
(
typeof
date
=
=
"
string
"
&
&
/
^
\
d
+
/
.
test
(
date
)
)
?
parseInt
(
date
10
)
:
date
)
;
}
const
stylesheetMap
=
new
DefaultMap
(
url
=
>
{
let
uri
=
NetUtil
.
newURI
(
url
)
;
return
styleSheetService
.
preloadSheet
(
uri
styleSheetService
.
AGENT_SHEET
)
;
}
)
;
function
defineLazyGetter
(
object
prop
getter
)
{
let
redefine
=
(
obj
value
)
=
>
{
Object
.
defineProperty
(
obj
prop
{
enumerable
:
true
configurable
:
true
writable
:
true
value
}
)
;
return
value
;
}
;
Object
.
defineProperty
(
object
prop
{
enumerable
:
true
configurable
:
true
get
(
)
{
return
redefine
(
this
getter
.
call
(
this
)
)
;
}
set
(
value
)
{
redefine
(
this
value
)
;
}
}
)
;
}
function
findPathInObject
(
obj
path
printErrors
=
true
)
{
let
parent
;
for
(
let
elt
of
path
.
split
(
"
.
"
)
)
{
if
(
!
obj
|
|
!
(
elt
in
obj
)
)
{
if
(
printErrors
)
{
Cu
.
reportError
(
WebExtension
API
{
path
}
not
found
(
it
may
be
unimplemented
by
Firefox
)
.
)
;
}
return
null
;
}
parent
=
obj
;
obj
=
obj
[
elt
]
;
}
if
(
typeof
obj
=
=
=
"
function
"
)
{
return
obj
.
bind
(
parent
)
;
}
return
obj
;
}
class
MessageManagerProxy
{
constructor
(
target
)
{
this
.
listeners
=
new
DefaultMap
(
(
)
=
>
new
Map
(
)
)
;
if
(
target
instanceof
Ci
.
nsIMessageSender
)
{
Object
.
defineProperty
(
this
"
messageManager
"
{
value
:
target
configurable
:
true
writable
:
true
}
)
;
}
else
{
this
.
addListeners
(
target
)
;
}
}
dispose
(
)
{
if
(
this
.
eventTarget
)
{
this
.
removeListeners
(
this
.
eventTarget
)
;
this
.
eventTarget
=
null
;
}
else
{
this
.
messageManager
=
null
;
}
}
static
matches
(
target
messageManager
)
{
return
target
=
=
=
messageManager
|
|
target
.
messageManager
=
=
=
messageManager
;
}
get
messageManager
(
)
{
return
this
.
eventTarget
&
&
this
.
eventTarget
.
messageManager
;
}
sendAsyncMessage
(
.
.
.
args
)
{
if
(
this
.
messageManager
)
{
return
this
.
messageManager
.
sendAsyncMessage
(
.
.
.
args
)
;
}
Cu
.
reportError
(
Cannot
send
message
:
Other
side
disconnected
:
{
uneval
(
args
)
}
)
;
}
get
isDisconnected
(
)
{
return
!
this
.
messageManager
;
}
addMessageListener
(
message
listener
listenWhenClosed
=
false
)
{
this
.
messageManager
.
addMessageListener
(
message
listener
listenWhenClosed
)
;
this
.
listeners
.
get
(
message
)
.
set
(
listener
listenWhenClosed
)
;
}
removeMessageListener
(
message
listener
)
{
this
.
messageManager
.
removeMessageListener
(
message
listener
)
;
let
listeners
=
this
.
listeners
.
get
(
message
)
;
listeners
.
delete
(
listener
)
;
if
(
!
listeners
.
size
)
{
this
.
listeners
.
delete
(
message
)
;
}
}
*
iterListeners
(
)
{
for
(
let
[
message
listeners
]
of
this
.
listeners
)
{
for
(
let
[
listener
listenWhenClosed
]
of
listeners
)
{
yield
{
message
listener
listenWhenClosed
}
;
}
}
}
addListeners
(
target
)
{
target
.
addEventListener
(
"
SwapDocShells
"
this
)
;
for
(
let
{
message
listener
listenWhenClosed
}
of
this
.
iterListeners
(
)
)
{
target
.
addMessageListener
(
message
listener
listenWhenClosed
)
;
}
this
.
eventTarget
=
target
;
}
removeListeners
(
target
)
{
target
.
removeEventListener
(
"
SwapDocShells
"
this
)
;
for
(
let
{
message
listener
}
of
this
.
iterListeners
(
)
)
{
target
.
removeMessageListener
(
message
listener
)
;
}
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
SwapDocShells
"
)
{
this
.
removeListeners
(
this
.
eventTarget
)
;
this
.
addListeners
(
event
.
detail
)
;
}
}
}
this
.
ExtensionUtils
=
{
defineLazyGetter
detectLanguage
extend
findPathInObject
flushJarCache
getConsole
getInnerWindowID
getMessageManager
getUniqueId
ignoreEvent
injectAPI
instanceOf
normalizeTime
promiseDocumentLoaded
promiseDocumentReady
promiseEvent
promiseObserved
runSafe
runSafeSync
runSafeSyncWithoutClone
runSafeWithoutClone
stylesheetMap
DefaultMap
DefaultWeakMap
EventEmitter
ExtensionError
IconDetails
LimitedSet
LocaleData
MessageManagerProxy
PlatformInfo
SingletonEventManager
SpreadArgs
}
;
