"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionUtils
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
const
INTEGER
=
/
^
[
1
-
9
]
\
d
*
/
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ConsoleAPI
"
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LanguageDetector
"
"
resource
:
/
/
/
modules
/
translation
/
LanguageDetector
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Locale
"
"
resource
:
/
/
gre
/
modules
/
Locale
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MessageChannel
"
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
function
getConsole
(
)
{
return
new
ConsoleAPI
(
{
maxLogLevelPref
:
"
extensions
.
webextensions
.
log
.
level
"
prefix
:
"
WebExtensions
"
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
getConsole
)
;
function
filterStack
(
error
)
{
return
String
(
error
.
stack
)
.
replace
(
/
(
^
.
*
(
Task
\
.
jsm
|
Promise
-
backend
\
.
js
)
.
*
\
n
)
+
/
gm
"
<
Promise
Chain
>
\
n
"
)
;
}
function
runSafeSyncWithoutClone
(
f
.
.
.
args
)
{
try
{
return
f
(
.
.
.
args
)
;
}
catch
(
e
)
{
dump
(
Extension
error
:
{
e
}
{
e
.
fileName
}
{
e
.
lineNumber
}
\
n
[
[
Exception
stack
\
n
{
filterStack
(
e
)
}
Current
stack
\
n
{
filterStack
(
Error
(
)
)
}
]
]
\
n
)
;
Cu
.
reportError
(
e
)
;
}
}
function
runSafeWithoutClone
(
f
.
.
.
args
)
{
if
(
typeof
(
f
)
!
=
"
function
"
)
{
dump
(
Extension
error
:
expected
function
\
n
{
filterStack
(
Error
(
)
)
}
)
;
return
;
}
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
runSafeSyncWithoutClone
(
f
.
.
.
args
)
;
}
)
;
}
function
runSafeSync
(
context
f
.
.
.
args
)
{
if
(
context
.
unloaded
)
{
Cu
.
reportError
(
"
runSafeSync
called
after
context
unloaded
"
)
;
return
;
}
try
{
args
=
Cu
.
cloneInto
(
args
context
.
cloneScope
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
context
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
return
runSafeSyncWithoutClone
(
f
.
.
.
args
)
;
}
function
runSafe
(
context
f
.
.
.
args
)
{
try
{
args
=
Cu
.
cloneInto
(
args
context
.
cloneScope
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
context
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
if
(
context
.
unloaded
)
{
dump
(
runSafe
failure
:
context
is
already
unloaded
{
filterStack
(
new
Error
(
)
)
}
\
n
)
;
return
undefined
;
}
return
runSafeWithoutClone
(
f
.
.
.
args
)
;
}
function
getInnerWindowID
(
window
)
{
return
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
}
function
instanceOf
(
value
type
)
{
return
{
}
.
toString
.
call
(
value
)
=
=
[
object
{
type
}
]
;
}
function
extend
(
obj
.
.
.
args
)
{
for
(
let
arg
of
args
)
{
let
props
=
[
.
.
.
Object
.
getOwnPropertyNames
(
arg
)
.
.
.
Object
.
getOwnPropertySymbols
(
arg
)
]
;
for
(
let
prop
of
props
)
{
let
descriptor
=
Object
.
getOwnPropertyDescriptor
(
arg
prop
)
;
Object
.
defineProperty
(
obj
prop
descriptor
)
;
}
}
return
obj
;
}
function
DefaultWeakMap
(
defaultValue
)
{
this
.
defaultValue
=
defaultValue
;
this
.
weakmap
=
new
WeakMap
(
)
;
}
DefaultWeakMap
.
prototype
=
{
get
(
key
)
{
if
(
this
.
weakmap
.
has
(
key
)
)
{
return
this
.
weakmap
.
get
(
key
)
;
}
return
this
.
defaultValue
;
}
set
(
key
value
)
{
if
(
key
)
{
this
.
weakmap
.
set
(
key
value
)
;
}
else
{
this
.
defaultValue
=
value
;
}
}
}
;
class
SpreadArgs
extends
Array
{
constructor
(
args
)
{
super
(
)
;
this
.
push
(
.
.
.
args
)
;
}
}
let
gContextId
=
0
;
class
BaseContext
{
constructor
(
extensionId
)
{
this
.
onClose
=
new
Set
(
)
;
this
.
checkedLastError
=
false
;
this
.
_lastError
=
null
;
this
.
contextId
=
{
+
+
gContextId
}
-
{
Services
.
appinfo
.
uniqueProcessID
}
;
this
.
unloaded
=
false
;
this
.
extensionId
=
extensionId
;
this
.
jsonSandbox
=
null
;
this
.
active
=
true
;
this
.
docShell
=
null
;
this
.
contentWindow
=
null
;
this
.
innerWindowID
=
0
;
}
setContentWindow
(
contentWindow
)
{
let
{
document
}
=
contentWindow
;
let
docShell
=
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
;
this
.
innerWindowID
=
getInnerWindowID
(
contentWindow
)
;
let
onPageShow
=
event
=
>
{
if
(
!
event
|
|
event
.
target
=
=
=
document
)
{
this
.
docShell
=
docShell
;
this
.
contentWindow
=
contentWindow
;
this
.
active
=
true
;
}
}
;
let
onPageHide
=
event
=
>
{
if
(
!
event
|
|
event
.
target
=
=
=
document
)
{
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
this
.
docShell
=
null
;
this
.
contentWindow
=
null
;
this
.
active
=
false
;
}
)
;
}
}
;
onPageShow
(
)
;
contentWindow
.
addEventListener
(
"
pagehide
"
onPageHide
true
)
;
contentWindow
.
addEventListener
(
"
pageshow
"
onPageShow
true
)
;
this
.
callOnClose
(
{
close
:
(
)
=
>
{
onPageHide
(
)
;
if
(
this
.
active
)
{
contentWindow
.
removeEventListener
(
"
pagehide
"
onPageHide
true
)
;
contentWindow
.
removeEventListener
(
"
pageshow
"
onPageShow
true
)
;
}
}
}
)
;
}
get
cloneScope
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
principal
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
runSafe
(
.
.
.
args
)
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
"
context
.
runSafe
called
after
context
unloaded
"
)
;
}
else
{
return
runSafeSync
(
this
.
.
.
args
)
;
}
}
runSafeWithoutClone
(
.
.
.
args
)
{
if
(
this
.
unloaded
)
{
Cu
.
reportError
(
"
context
.
runSafeWithoutClone
called
after
context
unloaded
"
)
;
}
else
{
return
runSafeSyncWithoutClone
(
.
.
.
args
)
;
}
}
checkLoadURL
(
url
options
=
{
}
)
{
let
ssm
=
Services
.
scriptSecurityManager
;
let
flags
=
ssm
.
STANDARD
;
if
(
!
options
.
allowScript
)
{
flags
|
=
ssm
.
DISALLOW_SCRIPT
;
}
if
(
!
options
.
allowInheritsPrincipal
)
{
flags
|
=
ssm
.
DISALLOW_INHERIT_PRINCIPAL
;
}
if
(
options
.
dontReportErrors
)
{
flags
|
=
ssm
.
DONT_REPORT_ERRORS
;
}
try
{
ssm
.
checkLoadURIStrWithPrincipal
(
this
.
principal
url
flags
)
;
}
catch
(
e
)
{
return
false
;
}
return
true
;
}
jsonStringify
(
.
.
.
args
)
{
if
(
!
this
.
jsonSandbox
)
{
this
.
jsonSandbox
=
Cu
.
Sandbox
(
this
.
principal
{
sameZoneAs
:
this
.
cloneScope
wantXrays
:
false
}
)
;
}
return
Cu
.
waiveXrays
(
this
.
jsonSandbox
.
JSON
)
.
stringify
(
.
.
.
args
)
;
}
callOnClose
(
obj
)
{
this
.
onClose
.
add
(
obj
)
;
}
forgetOnClose
(
obj
)
{
this
.
onClose
.
delete
(
obj
)
;
}
sendMessage
(
target
messageName
data
options
=
{
}
)
{
options
.
recipient
=
options
.
recipient
|
|
{
}
;
options
.
sender
=
options
.
sender
|
|
{
}
;
options
.
recipient
.
extensionId
=
this
.
extension
.
id
;
options
.
sender
.
extensionId
=
this
.
extension
.
id
;
options
.
sender
.
contextId
=
this
.
contextId
;
return
MessageChannel
.
sendMessage
(
target
messageName
data
options
)
;
}
get
lastError
(
)
{
this
.
checkedLastError
=
true
;
return
this
.
_lastError
;
}
set
lastError
(
val
)
{
this
.
checkedLastError
=
false
;
this
.
_lastError
=
val
;
}
normalizeError
(
error
)
{
if
(
error
instanceof
this
.
cloneScope
.
Error
)
{
return
error
;
}
if
(
!
instanceOf
(
error
"
Object
"
)
)
{
Cu
.
reportError
(
error
)
;
error
=
{
message
:
"
An
unexpected
error
occurred
"
}
;
}
return
new
this
.
cloneScope
.
Error
(
error
.
message
)
;
}
withLastError
(
error
callback
)
{
this
.
lastError
=
this
.
normalizeError
(
error
)
;
try
{
return
callback
(
)
;
}
finally
{
if
(
!
this
.
checkedLastError
)
{
Cu
.
reportError
(
Unchecked
lastError
value
:
{
this
.
lastError
}
)
;
}
this
.
lastError
=
null
;
}
}
wrapPromise
(
promise
callback
=
null
)
{
let
runSafe
=
this
.
runSafe
.
bind
(
this
)
;
if
(
promise
instanceof
this
.
cloneScope
.
Promise
)
{
runSafe
=
this
.
runSafeWithoutClone
.
bind
(
this
)
;
}
if
(
callback
)
{
promise
.
then
(
args
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
resolved
after
context
unloaded
\
n
)
;
}
else
if
(
args
instanceof
SpreadArgs
)
{
runSafe
(
callback
.
.
.
args
)
;
}
else
{
runSafe
(
callback
args
)
;
}
}
error
=
>
{
this
.
withLastError
(
error
(
)
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
rejected
after
context
unloaded
\
n
)
;
}
else
{
this
.
runSafeWithoutClone
(
callback
)
;
}
}
)
;
}
)
;
}
else
{
return
new
this
.
cloneScope
.
Promise
(
(
resolve
reject
)
=
>
{
promise
.
then
(
value
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
resolved
after
context
unloaded
\
n
)
;
}
else
{
runSafe
(
resolve
value
)
;
}
}
value
=
>
{
if
(
this
.
unloaded
)
{
dump
(
Promise
rejected
after
context
unloaded
\
n
)
;
}
else
{
this
.
runSafeWithoutClone
(
reject
this
.
normalizeError
(
value
)
)
;
}
}
)
;
}
)
;
}
}
unload
(
)
{
this
.
unloaded
=
true
;
MessageChannel
.
abortResponses
(
{
extensionId
:
this
.
extensionId
contextId
:
this
.
contextId
}
)
;
for
(
let
obj
of
this
.
onClose
)
{
obj
.
close
(
)
;
}
}
}
let
IconDetails
=
{
normalize
(
details
extension
context
=
null
)
{
let
result
=
{
}
;
try
{
if
(
details
.
imageData
)
{
let
imageData
=
details
.
imageData
;
if
(
instanceOf
(
imageData
"
ImageData
"
)
)
{
imageData
=
{
"
19
"
:
imageData
}
;
}
for
(
let
size
of
Object
.
keys
(
imageData
)
)
{
if
(
!
INTEGER
.
test
(
size
)
)
{
throw
new
Error
(
Invalid
icon
size
{
size
}
must
be
an
integer
)
;
}
result
[
size
]
=
this
.
convertImageDataToDataURL
(
imageData
[
size
]
context
)
;
}
}
if
(
details
.
path
)
{
let
path
=
details
.
path
;
if
(
typeof
path
!
=
"
object
"
)
{
path
=
{
"
19
"
:
path
}
;
}
let
baseURI
=
context
?
context
.
uri
:
extension
.
baseURI
;
for
(
let
size
of
Object
.
keys
(
path
)
)
{
if
(
!
INTEGER
.
test
(
size
)
)
{
throw
new
Error
(
Invalid
icon
size
{
size
}
must
be
an
integer
)
;
}
let
url
=
baseURI
.
resolve
(
path
[
size
]
)
;
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
extension
.
principal
url
Services
.
scriptSecurityManager
.
DISALLOW_SCRIPT
)
;
result
[
size
]
=
url
;
}
}
}
catch
(
e
)
{
if
(
context
)
{
throw
e
;
}
extension
.
manifestError
(
Invalid
icon
data
:
{
e
}
)
;
}
return
result
;
}
getPreferredIcon
(
icons
extension
=
null
size
=
16
)
{
const
DEFAULT
=
"
chrome
:
/
/
browser
/
content
/
extension
.
svg
"
;
let
bestSize
=
null
;
if
(
icons
[
size
]
)
{
bestSize
=
size
;
}
else
if
(
icons
[
2
*
size
]
)
{
bestSize
=
2
*
size
;
}
else
{
let
sizes
=
Object
.
keys
(
icons
)
.
map
(
key
=
>
parseInt
(
key
10
)
)
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
bestSize
=
sizes
.
find
(
candidate
=
>
candidate
>
size
)
|
|
sizes
.
pop
(
)
;
}
if
(
bestSize
)
{
return
{
size
:
bestSize
icon
:
icons
[
bestSize
]
}
;
}
return
{
size
icon
:
DEFAULT
}
;
}
convertImageURLToDataURL
(
imageURL
context
browserWindow
size
=
18
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
image
=
new
context
.
contentWindow
.
Image
(
)
;
image
.
onload
=
function
(
)
{
let
canvas
=
context
.
contentWindow
.
document
.
createElement
(
"
canvas
"
)
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
let
dSize
=
size
*
browserWindow
.
devicePixelRatio
;
let
dWidth
dHeight
dx
dy
;
if
(
this
.
width
>
this
.
height
)
{
dWidth
=
dSize
;
dHeight
=
image
.
height
*
(
dSize
/
image
.
width
)
;
dx
=
0
;
dy
=
(
dSize
-
dHeight
)
/
2
;
}
else
{
dWidth
=
image
.
width
*
(
dSize
/
image
.
height
)
;
dHeight
=
dSize
;
dx
=
(
dSize
-
dWidth
)
/
2
;
dy
=
0
;
}
ctx
.
drawImage
(
this
0
0
this
.
width
this
.
height
dx
dy
dWidth
dHeight
)
;
resolve
(
canvas
.
toDataURL
(
"
image
/
png
"
)
)
;
}
;
image
.
onerror
=
reject
;
image
.
src
=
imageURL
;
}
)
;
}
convertImageDataToDataURL
(
imageData
context
)
{
let
document
=
context
.
contentWindow
.
document
;
let
canvas
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
imageData
.
width
;
canvas
.
height
=
imageData
.
height
;
canvas
.
getContext
(
"
2d
"
)
.
putImageData
(
imageData
0
0
)
;
return
canvas
.
toDataURL
(
"
image
/
png
"
)
;
}
}
;
const
LISTENERS
=
Symbol
(
"
listeners
"
)
;
class
EventEmitter
{
constructor
(
)
{
this
[
LISTENERS
]
=
new
Map
(
)
;
}
on
(
event
listener
)
{
if
(
!
this
[
LISTENERS
]
.
has
(
event
)
)
{
this
[
LISTENERS
]
.
set
(
event
new
Set
(
)
)
;
}
this
[
LISTENERS
]
.
get
(
event
)
.
add
(
listener
)
;
}
off
(
event
listener
)
{
if
(
this
[
LISTENERS
]
.
has
(
event
)
)
{
let
set
=
this
[
LISTENERS
]
.
get
(
event
)
;
set
.
delete
(
listener
)
;
if
(
!
set
.
size
)
{
this
[
LISTENERS
]
.
delete
(
event
)
;
}
}
}
emit
(
event
.
.
.
args
)
{
let
listeners
=
this
[
LISTENERS
]
.
get
(
event
)
|
|
new
Set
(
)
;
let
promises
=
Array
.
from
(
listeners
listener
=
>
{
return
runSafeSyncWithoutClone
(
listener
event
.
.
.
args
)
;
}
)
;
return
Promise
.
all
(
promises
)
;
}
}
function
LocaleData
(
data
)
{
this
.
defaultLocale
=
data
.
defaultLocale
;
this
.
selectedLocale
=
data
.
selectedLocale
;
this
.
locales
=
data
.
locales
|
|
new
Map
(
)
;
this
.
warnedMissingKeys
=
new
Set
(
)
;
this
.
messages
=
data
.
messages
|
|
new
Map
(
)
;
if
(
data
.
builtinMessages
)
{
this
.
messages
.
set
(
this
.
BUILTIN
data
.
builtinMessages
)
;
}
}
LocaleData
.
prototype
=
{
serialize
(
)
{
return
{
defaultLocale
:
this
.
defaultLocale
selectedLocale
:
this
.
selectedLocale
messages
:
this
.
messages
locales
:
this
.
locales
}
;
}
BUILTIN
:
"
BUILTIN_MESSAGES
"
has
(
locale
)
{
return
this
.
messages
.
has
(
locale
)
;
}
localizeMessage
(
message
substitutions
=
[
]
options
=
{
}
)
{
let
defaultOptions
=
{
locale
:
this
.
selectedLocale
defaultValue
:
"
"
cloneScope
:
null
}
;
options
=
Object
.
assign
(
defaultOptions
options
)
;
let
locales
=
new
Set
(
[
this
.
BUILTIN
options
.
locale
this
.
defaultLocale
]
.
filter
(
locale
=
>
this
.
messages
.
has
(
locale
)
)
)
;
message
=
message
.
toLowerCase
(
)
;
for
(
let
locale
of
locales
)
{
let
messages
=
this
.
messages
.
get
(
locale
)
;
if
(
messages
.
has
(
message
)
)
{
let
str
=
messages
.
get
(
message
)
;
if
(
!
Array
.
isArray
(
substitutions
)
)
{
substitutions
=
[
substitutions
]
;
}
let
replacer
=
(
matched
index
dollarSigns
)
=
>
{
if
(
index
)
{
index
=
parseInt
(
index
10
)
-
1
;
return
index
in
substitutions
?
substitutions
[
index
]
:
"
"
;
}
return
dollarSigns
;
}
;
return
str
.
replace
(
/
\
(
?
:
(
[
1
-
9
]
\
d
*
)
|
(
\
+
)
)
/
g
replacer
)
;
}
}
if
(
message
=
=
"
ui_locale
"
)
{
return
this
.
uiLocale
;
}
else
if
(
message
.
startsWith
(
"
bidi_
"
)
)
{
let
registry
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIXULChromeRegistry
)
;
let
rtl
=
registry
.
isLocaleRTL
(
"
global
"
)
;
if
(
message
=
=
"
bidi_dir
"
)
{
return
rtl
?
"
rtl
"
:
"
ltr
"
;
}
else
if
(
message
=
=
"
bidi_reversed_dir
"
)
{
return
rtl
?
"
ltr
"
:
"
rtl
"
;
}
else
if
(
message
=
=
"
bidi_start_edge
"
)
{
return
rtl
?
"
right
"
:
"
left
"
;
}
else
if
(
message
=
=
"
bidi_end_edge
"
)
{
return
rtl
?
"
left
"
:
"
right
"
;
}
}
if
(
!
this
.
warnedMissingKeys
.
has
(
message
)
)
{
let
error
=
Unknown
localization
message
{
message
}
;
if
(
options
.
cloneScope
)
{
error
=
new
options
.
cloneScope
.
Error
(
error
)
;
}
Cu
.
reportError
(
error
)
;
this
.
warnedMissingKeys
.
add
(
message
)
;
}
return
options
.
defaultValue
;
}
localize
(
str
locale
=
this
.
selectedLocale
)
{
if
(
!
str
)
{
return
str
;
}
return
str
.
replace
(
/
__MSG_
(
[
A
-
Za
-
z0
-
9
_
]
+
?
)
__
/
g
(
matched
message
)
=
>
{
return
this
.
localizeMessage
(
message
[
]
{
locale
defaultValue
:
matched
}
)
;
}
)
;
}
addLocale
(
locale
messages
extension
)
{
let
result
=
new
Map
(
)
;
if
(
!
instanceOf
(
messages
"
Object
"
)
)
{
extension
.
packagingError
(
Invalid
locale
data
for
{
locale
}
)
;
return
result
;
}
for
(
let
key
of
Object
.
keys
(
messages
)
)
{
let
msg
=
messages
[
key
]
;
if
(
!
instanceOf
(
msg
"
Object
"
)
|
|
typeof
(
msg
.
message
)
!
=
"
string
"
)
{
extension
.
packagingError
(
Invalid
locale
message
data
for
{
locale
}
message
{
JSON
.
stringify
(
key
)
}
)
;
continue
;
}
let
placeholders
=
new
Map
(
)
;
if
(
instanceOf
(
msg
.
placeholders
"
Object
"
)
)
{
for
(
let
key
of
Object
.
keys
(
msg
.
placeholders
)
)
{
placeholders
.
set
(
key
.
toLowerCase
(
)
msg
.
placeholders
[
key
]
)
;
}
}
let
replacer
=
(
match
name
)
=
>
{
let
replacement
=
placeholders
.
get
(
name
.
toLowerCase
(
)
)
;
if
(
instanceOf
(
replacement
"
Object
"
)
&
&
"
content
"
in
replacement
)
{
return
replacement
.
content
;
}
return
"
"
;
}
;
let
value
=
msg
.
message
.
replace
(
/
\
(
[
A
-
Za
-
z0
-
9
_
]
+
)
\
/
g
replacer
)
;
result
.
set
(
key
.
toLowerCase
(
)
value
)
;
}
this
.
messages
.
set
(
locale
result
)
;
return
result
;
}
get
acceptLanguages
(
)
{
let
result
=
Preferences
.
get
(
"
intl
.
accept_languages
"
"
"
Ci
.
nsIPrefLocalizedString
)
;
return
result
.
split
(
/
\
s
*
\
s
*
/
g
)
;
}
get
uiLocale
(
)
{
return
Locale
.
getLocale
(
)
.
replace
(
/
-
/
g
"
_
"
)
;
}
}
;
function
EventManager
(
context
name
register
)
{
this
.
context
=
context
;
this
.
name
=
name
;
this
.
register
=
register
;
this
.
unregister
=
null
;
this
.
callbacks
=
new
Set
(
)
;
}
EventManager
.
prototype
=
{
addListener
(
callback
)
{
if
(
typeof
(
callback
)
!
=
"
function
"
)
{
dump
(
Expected
function
\
n
{
Error
(
)
.
stack
}
)
;
return
;
}
if
(
!
this
.
callbacks
.
size
)
{
this
.
context
.
callOnClose
(
this
)
;
let
fireFunc
=
this
.
fire
.
bind
(
this
)
;
let
fireWithoutClone
=
this
.
fireWithoutClone
.
bind
(
this
)
;
fireFunc
.
withoutClone
=
fireWithoutClone
;
this
.
unregister
=
this
.
register
(
fireFunc
)
;
}
this
.
callbacks
.
add
(
callback
)
;
}
removeListener
(
callback
)
{
if
(
!
this
.
callbacks
.
size
)
{
return
;
}
this
.
callbacks
.
delete
(
callback
)
;
if
(
this
.
callbacks
.
size
=
=
0
)
{
this
.
unregister
(
)
;
this
.
context
.
forgetOnClose
(
this
)
;
}
}
hasListener
(
callback
)
{
return
this
.
callbacks
.
has
(
callback
)
;
}
fire
(
.
.
.
args
)
{
for
(
let
callback
of
this
.
callbacks
)
{
Promise
.
resolve
(
callback
)
.
then
(
callback
=
>
{
if
(
this
.
context
.
unloaded
)
{
dump
(
{
this
.
name
}
event
fired
after
context
unloaded
.
\
n
)
;
}
else
if
(
this
.
callbacks
.
has
(
callback
)
)
{
this
.
context
.
runSafe
(
callback
.
.
.
args
)
;
}
}
)
;
}
}
fireWithoutClone
(
.
.
.
args
)
{
for
(
let
callback
of
this
.
callbacks
)
{
this
.
context
.
runSafeWithoutClone
(
callback
.
.
.
args
)
;
}
}
close
(
)
{
if
(
this
.
callbacks
.
size
)
{
this
.
unregister
(
)
;
}
this
.
callbacks
=
Object
.
freeze
(
[
]
)
;
}
api
(
)
{
return
{
addListener
:
callback
=
>
this
.
addListener
(
callback
)
removeListener
:
callback
=
>
this
.
removeListener
(
callback
)
hasListener
:
callback
=
>
this
.
hasListener
(
callback
)
}
;
}
}
;
function
SingletonEventManager
(
context
name
register
)
{
this
.
context
=
context
;
this
.
name
=
name
;
this
.
register
=
register
;
this
.
unregister
=
new
Map
(
)
;
context
.
callOnClose
(
this
)
;
}
SingletonEventManager
.
prototype
=
{
addListener
(
callback
.
.
.
args
)
{
let
wrappedCallback
=
(
.
.
.
args
)
=
>
{
if
(
this
.
context
.
unloaded
)
{
dump
(
{
this
.
name
}
event
fired
after
context
unloaded
.
\
n
)
;
}
else
if
(
this
.
unregister
.
has
(
callback
)
)
{
return
callback
(
.
.
.
args
)
;
}
}
;
let
unregister
=
this
.
register
(
wrappedCallback
.
.
.
args
)
;
this
.
unregister
.
set
(
callback
unregister
)
;
}
removeListener
(
callback
)
{
if
(
!
this
.
unregister
.
has
(
callback
)
)
{
return
;
}
let
unregister
=
this
.
unregister
.
get
(
callback
)
;
this
.
unregister
.
delete
(
callback
)
;
unregister
(
)
;
}
hasListener
(
callback
)
{
return
this
.
unregister
.
has
(
callback
)
;
}
close
(
)
{
for
(
let
unregister
of
this
.
unregister
.
values
(
)
)
{
unregister
(
)
;
}
}
api
(
)
{
return
{
addListener
:
(
.
.
.
args
)
=
>
this
.
addListener
(
.
.
.
args
)
removeListener
:
(
.
.
.
args
)
=
>
this
.
removeListener
(
.
.
.
args
)
hasListener
:
(
.
.
.
args
)
=
>
this
.
hasListener
(
.
.
.
args
)
}
;
}
}
;
function
ignoreEvent
(
context
name
)
{
return
{
addListener
:
function
(
callback
)
{
let
id
=
context
.
extension
.
id
;
let
frame
=
Components
.
stack
.
caller
;
let
msg
=
In
add
-
on
{
id
}
attempting
to
use
listener
"
{
name
}
"
which
is
unimplemented
.
;
let
winID
=
context
.
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
let
scriptError
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
scriptError
.
initWithWindowID
(
msg
frame
.
filename
null
frame
.
lineNumber
frame
.
columnNumber
Ci
.
nsIScriptError
.
warningFlag
"
content
javascript
"
winID
)
;
let
consoleService
=
Cc
[
"
mozilla
.
org
/
consoleservice
;
1
"
]
.
getService
(
Ci
.
nsIConsoleService
)
;
consoleService
.
logMessage
(
scriptError
)
;
}
removeListener
:
function
(
callback
)
{
}
hasListener
:
function
(
callback
)
{
}
}
;
}
function
injectAPI
(
source
dest
)
{
for
(
let
prop
in
source
)
{
if
(
prop
[
0
]
=
=
"
_
"
)
{
continue
;
}
let
desc
=
Object
.
getOwnPropertyDescriptor
(
source
prop
)
;
if
(
typeof
(
desc
.
value
)
=
=
"
function
"
)
{
Cu
.
exportFunction
(
desc
.
value
dest
{
defineAs
:
prop
}
)
;
}
else
if
(
typeof
(
desc
.
value
)
=
=
"
object
"
)
{
let
obj
=
Cu
.
createObjectIn
(
dest
{
defineAs
:
prop
}
)
;
injectAPI
(
desc
.
value
obj
)
;
}
else
{
Object
.
defineProperty
(
dest
prop
desc
)
;
}
}
}
function
promiseDocumentReady
(
doc
)
{
if
(
doc
.
readyState
=
=
"
interactive
"
|
|
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
addEventListener
(
"
DOMContentLoaded
"
function
onReady
(
event
)
{
if
(
event
.
target
=
=
=
event
.
currentTarget
)
{
doc
.
removeEventListener
(
"
DOMContentLoaded
"
onReady
true
)
;
resolve
(
doc
)
;
}
}
true
)
;
}
)
;
}
function
promiseDocumentLoaded
(
doc
)
{
if
(
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
defaultView
.
addEventListener
(
"
load
"
function
onReady
(
event
)
{
doc
.
defaultView
.
removeEventListener
(
"
load
"
onReady
)
;
resolve
(
doc
)
;
}
)
;
}
)
;
}
function
promiseObserved
(
topic
test
=
(
)
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
test
(
subject
data
)
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
{
subject
data
}
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
topic
false
)
;
}
)
;
}
let
gNextPortId
=
1
;
function
Port
(
context
messageManager
name
id
sender
)
{
this
.
context
=
context
;
this
.
messageManager
=
messageManager
;
this
.
name
=
name
;
this
.
id
=
id
;
this
.
listenerName
=
Extension
:
Port
-
{
this
.
id
}
;
this
.
disconnectName
=
Extension
:
Disconnect
-
{
this
.
id
}
;
this
.
sender
=
sender
;
this
.
disconnected
=
false
;
this
.
messageManager
.
addMessageListener
(
this
.
disconnectName
this
true
)
;
this
.
disconnectListeners
=
new
Set
(
)
;
}
Port
.
prototype
=
{
api
(
)
{
let
portObj
=
Cu
.
createObjectIn
(
this
.
context
.
cloneScope
)
;
this
.
context
.
callOnClose
(
this
)
;
let
publicAPI
=
{
name
:
this
.
name
disconnect
:
(
)
=
>
{
this
.
disconnect
(
)
;
}
postMessage
:
json
=
>
{
if
(
this
.
disconnected
)
{
throw
new
this
.
context
.
contentWindow
.
Error
(
"
Attempt
to
postMessage
on
disconnected
port
"
)
;
}
this
.
messageManager
.
sendAsyncMessage
(
this
.
listenerName
json
)
;
}
onDisconnect
:
new
EventManager
(
this
.
context
"
Port
.
onDisconnect
"
fire
=
>
{
let
listener
=
(
)
=
>
{
if
(
!
this
.
disconnected
)
{
fire
(
)
;
}
}
;
this
.
disconnectListeners
.
add
(
listener
)
;
return
(
)
=
>
{
this
.
disconnectListeners
.
delete
(
listener
)
;
}
;
}
)
.
api
(
)
onMessage
:
new
EventManager
(
this
.
context
"
Port
.
onMessage
"
fire
=
>
{
let
listener
=
(
{
data
}
)
=
>
{
if
(
!
this
.
context
.
active
)
{
Cu
.
reportError
(
"
Message
received
on
port
for
an
inactive
content
script
"
)
;
}
else
if
(
!
this
.
disconnected
)
{
fire
(
data
)
;
}
}
;
this
.
messageManager
.
addMessageListener
(
this
.
listenerName
listener
)
;
return
(
)
=
>
{
this
.
messageManager
.
removeMessageListener
(
this
.
listenerName
listener
)
;
}
;
}
)
.
api
(
)
}
;
if
(
this
.
sender
)
{
publicAPI
.
sender
=
this
.
sender
;
}
injectAPI
(
publicAPI
portObj
)
;
return
portObj
;
}
handleDisconnection
(
)
{
this
.
messageManager
.
removeMessageListener
(
this
.
disconnectName
this
)
;
this
.
context
.
forgetOnClose
(
this
)
;
this
.
disconnected
=
true
;
}
receiveMessage
(
msg
)
{
if
(
msg
.
name
=
=
this
.
disconnectName
)
{
this
.
disconnectByOtherEnd
(
)
;
}
}
disconnectByOtherEnd
(
)
{
if
(
this
.
disconnected
)
{
return
;
}
for
(
let
listener
of
this
.
disconnectListeners
)
{
listener
(
)
;
}
this
.
handleDisconnection
(
)
;
}
disconnect
(
)
{
if
(
this
.
disconnected
)
{
return
;
}
this
.
handleDisconnection
(
)
;
this
.
messageManager
.
sendAsyncMessage
(
this
.
disconnectName
)
;
}
close
(
)
{
this
.
disconnect
(
)
;
}
}
;
function
getMessageManager
(
target
)
{
if
(
target
instanceof
Ci
.
nsIFrameLoaderOwner
)
{
return
target
.
QueryInterface
(
Ci
.
nsIFrameLoaderOwner
)
.
frameLoader
.
messageManager
;
}
return
target
;
}
function
Messenger
(
context
messageManagers
sender
filter
delegate
)
{
this
.
context
=
context
;
this
.
messageManagers
=
messageManagers
;
this
.
sender
=
sender
;
this
.
filter
=
filter
;
this
.
delegate
=
delegate
;
MessageChannel
.
setupMessageManagers
(
messageManagers
)
;
}
Messenger
.
prototype
=
{
_sendMessage
(
messageManager
message
data
recipient
)
{
let
options
=
{
recipient
sender
:
this
.
sender
responseType
:
MessageChannel
.
RESPONSE_FIRST
}
;
return
this
.
context
.
sendMessage
(
messageManager
message
data
options
)
;
}
sendMessage
(
messageManager
msg
recipient
responseCallback
)
{
let
promise
=
this
.
_sendMessage
(
messageManager
"
Extension
:
Message
"
msg
recipient
)
.
catch
(
error
=
>
{
if
(
error
.
result
=
=
MessageChannel
.
RESULT_NO_HANDLER
)
{
return
Promise
.
reject
(
{
message
:
"
Could
not
establish
connection
.
Receiving
end
does
not
exist
.
"
}
)
;
}
else
if
(
error
.
result
!
=
MessageChannel
.
RESULT_NO_RESPONSE
)
{
return
Promise
.
reject
(
{
message
:
error
.
message
}
)
;
}
}
)
;
return
this
.
context
.
wrapPromise
(
promise
responseCallback
)
;
}
onMessage
(
name
)
{
return
new
SingletonEventManager
(
this
.
context
name
callback
=
>
{
let
listener
=
{
messageFilterPermissive
:
this
.
filter
receiveMessage
:
(
{
target
data
:
message
sender
recipient
}
)
=
>
{
if
(
!
this
.
context
.
active
)
{
return
;
}
if
(
this
.
delegate
)
{
this
.
delegate
.
getSender
(
this
.
context
target
sender
)
;
}
let
sendResponse
;
let
response
=
undefined
;
let
promise
=
new
Promise
(
resolve
=
>
{
sendResponse
=
value
=
>
{
resolve
(
value
)
;
response
=
promise
;
}
;
}
)
;
message
=
Cu
.
cloneInto
(
message
this
.
context
.
cloneScope
)
;
sender
=
Cu
.
cloneInto
(
sender
this
.
context
.
cloneScope
)
;
sendResponse
=
Cu
.
exportFunction
(
sendResponse
this
.
context
.
cloneScope
)
;
let
result
=
callback
(
message
sender
sendResponse
)
;
if
(
result
instanceof
this
.
context
.
cloneScope
.
Promise
)
{
return
result
;
}
else
if
(
result
=
=
=
true
)
{
return
promise
;
}
return
response
;
}
}
;
MessageChannel
.
addListener
(
this
.
messageManagers
"
Extension
:
Message
"
listener
)
;
return
(
)
=
>
{
MessageChannel
.
removeListener
(
this
.
messageManagers
"
Extension
:
Message
"
listener
)
;
}
;
}
)
.
api
(
)
;
}
connect
(
messageManager
name
recipient
)
{
let
portId
=
{
gNextPortId
+
+
}
-
{
Services
.
appinfo
.
uniqueProcessID
}
;
let
port
=
new
Port
(
this
.
context
messageManager
name
portId
null
)
;
let
msg
=
{
name
portId
}
;
this
.
_sendMessage
(
messageManager
"
Extension
:
Connect
"
msg
recipient
)
.
catch
(
e
=
>
port
.
disconnectByOtherEnd
(
)
)
;
return
port
.
api
(
)
;
}
onConnect
(
name
)
{
return
new
SingletonEventManager
(
this
.
context
name
callback
=
>
{
let
listener
=
{
messageFilterPermissive
:
this
.
filter
receiveMessage
:
(
{
target
data
:
message
sender
recipient
}
)
=
>
{
let
{
name
portId
}
=
message
;
let
mm
=
getMessageManager
(
target
)
;
if
(
this
.
delegate
)
{
this
.
delegate
.
getSender
(
this
.
context
target
sender
)
;
}
let
port
=
new
Port
(
this
.
context
mm
name
portId
sender
)
;
this
.
context
.
runSafeWithoutClone
(
callback
port
.
api
(
)
)
;
return
true
;
}
}
;
MessageChannel
.
addListener
(
this
.
messageManagers
"
Extension
:
Connect
"
listener
)
;
return
(
)
=
>
{
MessageChannel
.
removeListener
(
this
.
messageManagers
"
Extension
:
Connect
"
listener
)
;
}
;
}
)
.
api
(
)
;
}
}
;
function
flushJarCache
(
jarFile
)
{
Services
.
obs
.
notifyObservers
(
jarFile
"
flush
-
cache
-
entry
"
null
)
;
}
const
PlatformInfo
=
Object
.
freeze
(
{
os
:
(
function
(
)
{
let
os
=
AppConstants
.
platform
;
if
(
os
=
=
"
macosx
"
)
{
os
=
"
mac
"
;
}
return
os
;
}
)
(
)
arch
:
(
function
(
)
{
let
abi
=
Services
.
appinfo
.
XPCOMABI
;
let
[
arch
]
=
abi
.
split
(
"
-
"
)
;
if
(
arch
=
=
"
x86
"
)
{
arch
=
"
x86
-
32
"
;
}
else
if
(
arch
=
=
"
x86_64
"
)
{
arch
=
"
x86
-
64
"
;
}
return
arch
;
}
)
(
)
}
)
;
function
detectLanguage
(
text
)
{
return
LanguageDetector
.
detectLanguage
(
text
)
.
then
(
result
=
>
(
{
isReliable
:
result
.
confident
languages
:
result
.
languages
.
map
(
lang
=
>
{
return
{
language
:
lang
.
languageCode
percentage
:
lang
.
percent
}
;
}
)
}
)
)
;
}
let
nextId
=
1
;
class
ChildAPIManager
{
constructor
(
context
messageManager
namespaces
contextData
)
{
this
.
context
=
context
;
this
.
messageManager
=
messageManager
;
this
.
namespaces
=
namespaces
;
let
id
=
String
(
context
.
extension
.
id
)
+
"
.
"
+
String
(
context
.
contextId
)
;
this
.
id
=
id
;
let
data
=
{
childId
:
id
extensionId
:
context
.
extension
.
id
principal
:
context
.
principal
}
;
Object
.
assign
(
data
contextData
)
;
messageManager
.
sendAsyncMessage
(
"
API
:
CreateProxyContext
"
data
)
;
messageManager
.
addMessageListener
(
"
API
:
RunListener
"
this
)
;
messageManager
.
addMessageListener
(
"
API
:
CallResult
"
this
)
;
this
.
listeners
=
new
Map
(
)
;
this
.
callPromises
=
new
Map
(
)
;
}
receiveMessage
(
{
name
data
}
)
{
if
(
data
.
childId
!
=
this
.
id
)
{
return
;
}
switch
(
name
)
{
case
"
API
:
RunListener
"
:
let
ref
=
data
.
path
.
concat
(
data
.
name
)
.
join
(
"
.
"
)
;
let
listeners
=
this
.
listeners
.
get
(
ref
)
;
for
(
let
callback
of
listeners
)
{
runSafe
(
this
.
context
callback
.
.
.
data
.
args
)
;
}
break
;
case
"
API
:
CallResult
"
:
let
deferred
=
this
.
callPromises
.
get
(
data
.
callId
)
;
if
(
data
.
lastError
)
{
deferred
.
reject
(
{
message
:
data
.
lastError
}
)
;
}
else
{
deferred
.
resolve
(
new
SpreadArgs
(
data
.
args
)
)
;
}
this
.
callPromises
.
delete
(
data
.
callId
)
;
break
;
}
}
close
(
)
{
this
.
messageManager
.
sendAsyncMessage
(
"
API
:
CloseProxyContext
"
{
childId
:
this
.
id
}
)
;
}
get
cloneScope
(
)
{
return
this
.
context
.
cloneScope
;
}
callFunction
(
path
name
args
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
callFunctionNoReturn
(
path
name
args
)
{
this
.
messageManager
.
sendAsyncMessage
(
"
API
:
Call
"
{
childId
:
this
.
id
path
name
args
}
)
;
}
callAsyncFunction
(
path
name
args
callback
)
{
let
callId
=
nextId
+
+
;
let
deferred
=
PromiseUtils
.
defer
(
)
;
this
.
callPromises
.
set
(
callId
deferred
)
;
this
.
messageManager
.
sendAsyncMessage
(
"
API
:
Call
"
{
childId
:
this
.
id
callId
path
name
args
}
)
;
return
this
.
context
.
wrapPromise
(
deferred
.
promise
callback
)
;
}
shouldInject
(
namespace
name
)
{
return
this
.
namespaces
.
includes
(
namespace
)
;
}
hasPermission
(
permission
)
{
return
this
.
context
.
extension
.
permissions
.
has
(
permission
)
;
}
getProperty
(
path
name
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
setProperty
(
path
name
value
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
addListener
(
path
name
listener
args
)
{
let
ref
=
path
.
concat
(
name
)
.
join
(
"
.
"
)
;
let
set
;
if
(
this
.
listeners
.
has
(
ref
)
)
{
set
=
this
.
listeners
.
get
(
ref
)
;
}
else
{
set
=
new
Set
(
)
;
this
.
listeners
.
set
(
ref
set
)
;
}
set
.
add
(
listener
)
;
if
(
set
.
size
=
=
1
)
{
args
=
args
.
slice
(
1
)
;
this
.
messageManager
.
sendAsyncMessage
(
"
API
:
AddListener
"
{
childId
:
this
.
id
path
name
args
}
)
;
}
}
removeListener
(
path
name
listener
)
{
let
ref
=
path
.
concat
(
name
)
.
join
(
"
.
"
)
;
let
set
=
this
.
listeners
.
get
(
ref
)
|
|
new
Set
(
)
;
set
.
remove
(
listener
)
;
if
(
set
.
size
=
=
0
)
{
this
.
messageManager
.
sendAsyncMessage
(
"
Extension
:
RemoveListener
"
{
childId
:
this
.
id
path
name
}
)
;
}
}
hasListener
(
path
name
listener
)
{
let
ref
=
path
.
concat
(
name
)
.
join
(
"
.
"
)
;
let
set
=
this
.
listeners
.
get
(
ref
)
|
|
new
Set
(
)
;
return
set
.
has
(
listener
)
;
}
}
function
normalizeTime
(
date
)
{
return
new
Date
(
(
typeof
date
=
=
"
string
"
&
&
/
^
\
d
+
/
.
test
(
date
)
)
?
parseInt
(
date
10
)
:
date
)
;
}
this
.
ExtensionUtils
=
{
detectLanguage
extend
flushJarCache
getConsole
getInnerWindowID
ignoreEvent
injectAPI
instanceOf
normalizeTime
promiseDocumentLoaded
promiseDocumentReady
promiseObserved
runSafe
runSafeSync
runSafeSyncWithoutClone
runSafeWithoutClone
BaseContext
DefaultWeakMap
EventEmitter
EventManager
IconDetails
LocaleData
Messenger
PlatformInfo
SingletonEventManager
SpreadArgs
ChildAPIManager
}
;
