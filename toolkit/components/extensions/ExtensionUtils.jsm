"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionUtils
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ConsoleAPI
"
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MessageChannel
"
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
)
;
function
getConsole
(
)
{
return
new
ConsoleAPI
(
{
maxLogLevelPref
:
"
extensions
.
webextensions
.
log
.
level
"
prefix
:
"
WebExtensions
"
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
getConsole
)
;
let
nextId
=
0
;
XPCOMUtils
.
defineLazyGetter
(
this
"
uniqueProcessID
"
(
)
=
>
Services
.
appinfo
.
uniqueProcessID
)
;
function
getUniqueId
(
)
{
return
{
nextId
+
+
}
-
{
uniqueProcessID
}
;
}
class
ExtensionError
extends
Error
{
}
function
filterStack
(
error
)
{
return
String
(
error
.
stack
)
.
replace
(
/
(
^
.
*
(
Task
\
.
jsm
|
Promise
-
backend
\
.
js
)
.
*
\
n
)
+
/
gm
"
<
Promise
Chain
>
\
n
"
)
;
}
function
runSafeSyncWithoutClone
(
f
.
.
.
args
)
{
try
{
return
f
(
.
.
.
args
)
;
}
catch
(
e
)
{
dump
(
Extension
error
:
{
e
}
{
e
.
fileName
}
{
e
.
lineNumber
}
\
n
[
[
Exception
stack
\
n
{
filterStack
(
e
)
}
Current
stack
\
n
{
filterStack
(
Error
(
)
)
}
]
]
\
n
)
;
Cu
.
reportError
(
e
)
;
}
}
function
runSafeWithoutClone
(
f
.
.
.
args
)
{
if
(
typeof
(
f
)
!
=
"
function
"
)
{
dump
(
Extension
error
:
expected
function
\
n
{
filterStack
(
Error
(
)
)
}
)
;
return
;
}
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
runSafeSyncWithoutClone
(
f
.
.
.
args
)
;
}
)
;
}
function
runSafeSync
(
context
f
.
.
.
args
)
{
if
(
context
.
unloaded
)
{
Cu
.
reportError
(
"
runSafeSync
called
after
context
unloaded
"
)
;
return
;
}
try
{
args
=
Cu
.
cloneInto
(
args
context
.
cloneScope
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
context
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
return
runSafeSyncWithoutClone
(
f
.
.
.
args
)
;
}
function
runSafe
(
context
f
.
.
.
args
)
{
try
{
args
=
Cu
.
cloneInto
(
args
context
.
cloneScope
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
context
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
if
(
context
.
unloaded
)
{
dump
(
runSafe
failure
:
context
is
already
unloaded
{
filterStack
(
new
Error
(
)
)
}
\
n
)
;
return
undefined
;
}
return
runSafeWithoutClone
(
f
.
.
.
args
)
;
}
function
instanceOf
(
value
type
)
{
return
{
}
.
toString
.
call
(
value
)
=
=
[
object
{
type
}
]
;
}
class
DefaultWeakMap
extends
WeakMap
{
constructor
(
defaultConstructor
init
)
{
super
(
init
)
;
this
.
defaultConstructor
=
defaultConstructor
;
}
get
(
key
)
{
if
(
!
this
.
has
(
key
)
)
{
this
.
set
(
key
this
.
defaultConstructor
(
key
)
)
;
}
return
super
.
get
(
key
)
;
}
}
class
DefaultMap
extends
Map
{
constructor
(
defaultConstructor
init
)
{
super
(
init
)
;
this
.
defaultConstructor
=
defaultConstructor
;
}
get
(
key
)
{
if
(
!
this
.
has
(
key
)
)
{
this
.
set
(
key
this
.
defaultConstructor
(
key
)
)
;
}
return
super
.
get
(
key
)
;
}
}
const
_winUtils
=
new
DefaultWeakMap
(
win
=
>
{
return
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
)
;
const
getWinUtils
=
win
=
>
_winUtils
.
get
(
win
)
;
function
getInnerWindowID
(
window
)
{
return
getWinUtils
(
window
)
.
currentInnerWindowID
;
}
function
withHandlingUserInput
(
window
callable
)
{
let
handle
=
getWinUtils
(
window
)
.
setHandlingUserInput
(
true
)
;
try
{
return
callable
(
)
;
}
finally
{
handle
.
destruct
(
)
;
}
}
const
LISTENERS
=
Symbol
(
"
listeners
"
)
;
const
ONCE_MAP
=
Symbol
(
"
onceMap
"
)
;
class
EventEmitter
{
constructor
(
)
{
this
[
LISTENERS
]
=
new
Map
(
)
;
this
[
ONCE_MAP
]
=
new
WeakMap
(
)
;
}
on
(
event
listener
)
{
if
(
!
this
[
LISTENERS
]
.
has
(
event
)
)
{
this
[
LISTENERS
]
.
set
(
event
new
Set
(
)
)
;
}
this
[
LISTENERS
]
.
get
(
event
)
.
add
(
listener
)
;
}
off
(
event
listener
)
{
if
(
this
[
LISTENERS
]
.
has
(
event
)
)
{
let
set
=
this
[
LISTENERS
]
.
get
(
event
)
;
set
.
delete
(
listener
)
;
set
.
delete
(
this
[
ONCE_MAP
]
.
get
(
listener
)
)
;
if
(
!
set
.
size
)
{
this
[
LISTENERS
]
.
delete
(
event
)
;
}
}
}
once
(
event
listener
)
{
let
wrapper
=
(
.
.
.
args
)
=
>
{
this
.
off
(
event
wrapper
)
;
this
[
ONCE_MAP
]
.
delete
(
listener
)
;
return
listener
(
.
.
.
args
)
;
}
;
this
[
ONCE_MAP
]
.
set
(
listener
wrapper
)
;
this
.
on
(
event
wrapper
)
;
}
emit
(
event
.
.
.
args
)
{
let
listeners
=
this
[
LISTENERS
]
.
get
(
event
)
|
|
new
Set
(
)
;
let
promises
=
Array
.
from
(
listeners
listener
=
>
{
return
runSafeSyncWithoutClone
(
listener
event
.
.
.
args
)
;
}
)
;
return
Promise
.
all
(
promises
)
;
}
}
class
LimitedSet
extends
Set
{
constructor
(
limit
iterable
=
undefined
)
{
super
(
iterable
)
;
this
.
limit
=
limit
;
}
truncate
(
limit
)
{
for
(
let
item
of
this
)
{
if
(
this
.
size
<
=
limit
)
{
break
;
}
this
.
delete
(
item
)
;
}
}
add
(
item
)
{
if
(
!
this
.
has
(
item
)
&
&
this
.
size
>
=
this
.
limit
)
{
this
.
truncate
(
this
.
limit
-
1
)
;
}
super
.
add
(
item
)
;
}
}
function
promiseDocumentReady
(
doc
)
{
if
(
doc
.
readyState
=
=
"
interactive
"
|
|
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
addEventListener
(
"
DOMContentLoaded
"
function
onReady
(
event
)
{
if
(
event
.
target
=
=
=
event
.
currentTarget
)
{
doc
.
removeEventListener
(
"
DOMContentLoaded
"
onReady
true
)
;
resolve
(
doc
)
;
}
}
true
)
;
}
)
;
}
function
promiseDocumentLoaded
(
doc
)
{
if
(
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
defaultView
.
addEventListener
(
"
load
"
function
(
event
)
{
resolve
(
doc
)
;
}
{
once
:
true
}
)
;
}
)
;
}
function
promiseEvent
(
element
eventName
useCapture
=
true
test
=
event
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
function
listener
(
event
)
{
if
(
test
(
event
)
)
{
element
.
removeEventListener
(
eventName
listener
useCapture
)
;
resolve
(
event
)
;
}
}
element
.
addEventListener
(
eventName
listener
useCapture
)
;
}
)
;
}
function
promiseObserved
(
topic
test
=
(
)
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
test
(
subject
data
)
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
{
subject
data
}
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
topic
)
;
}
)
;
}
function
getMessageManager
(
target
)
{
if
(
target
instanceof
Ci
.
nsIFrameLoaderOwner
)
{
return
target
.
QueryInterface
(
Ci
.
nsIFrameLoaderOwner
)
.
frameLoader
.
messageManager
;
}
return
target
.
QueryInterface
(
Ci
.
nsIMessageSender
)
;
}
function
flushJarCache
(
jarPath
)
{
Services
.
obs
.
notifyObservers
(
null
"
flush
-
cache
-
entry
"
jarPath
)
;
}
function
normalizeTime
(
date
)
{
return
new
Date
(
(
typeof
date
=
=
"
string
"
&
&
/
^
\
d
+
/
.
test
(
date
)
)
?
parseInt
(
date
10
)
:
date
)
;
}
function
defineLazyGetter
(
object
prop
getter
)
{
let
redefine
=
(
obj
value
)
=
>
{
Object
.
defineProperty
(
obj
prop
{
enumerable
:
true
configurable
:
true
writable
:
true
value
}
)
;
return
value
;
}
;
Object
.
defineProperty
(
object
prop
{
enumerable
:
true
configurable
:
true
get
(
)
{
return
redefine
(
this
getter
.
call
(
this
)
)
;
}
set
(
value
)
{
redefine
(
this
value
)
;
}
}
)
;
}
class
MessageManagerProxy
{
constructor
(
target
)
{
this
.
listeners
=
new
DefaultMap
(
(
)
=
>
new
Map
(
)
)
;
if
(
target
instanceof
Ci
.
nsIMessageSender
)
{
Object
.
defineProperty
(
this
"
messageManager
"
{
value
:
target
configurable
:
true
writable
:
true
}
)
;
}
else
{
this
.
addListeners
(
target
)
;
}
}
dispose
(
)
{
if
(
this
.
eventTarget
)
{
this
.
removeListeners
(
this
.
eventTarget
)
;
this
.
eventTarget
=
null
;
}
else
{
this
.
messageManager
=
null
;
}
}
static
matches
(
target
messageManager
)
{
return
target
=
=
=
messageManager
|
|
target
.
messageManager
=
=
=
messageManager
;
}
get
messageManager
(
)
{
return
this
.
eventTarget
&
&
this
.
eventTarget
.
messageManager
;
}
sendAsyncMessage
(
.
.
.
args
)
{
if
(
this
.
messageManager
)
{
return
this
.
messageManager
.
sendAsyncMessage
(
.
.
.
args
)
;
}
Cu
.
reportError
(
Cannot
send
message
:
Other
side
disconnected
:
{
uneval
(
args
)
}
)
;
}
get
isDisconnected
(
)
{
return
!
this
.
messageManager
;
}
addMessageListener
(
message
listener
listenWhenClosed
=
false
)
{
this
.
messageManager
.
addMessageListener
(
message
listener
listenWhenClosed
)
;
this
.
listeners
.
get
(
message
)
.
set
(
listener
listenWhenClosed
)
;
}
removeMessageListener
(
message
listener
)
{
this
.
messageManager
.
removeMessageListener
(
message
listener
)
;
let
listeners
=
this
.
listeners
.
get
(
message
)
;
listeners
.
delete
(
listener
)
;
if
(
!
listeners
.
size
)
{
this
.
listeners
.
delete
(
message
)
;
}
}
*
iterListeners
(
)
{
for
(
let
[
message
listeners
]
of
this
.
listeners
)
{
for
(
let
[
listener
listenWhenClosed
]
of
listeners
)
{
yield
{
message
listener
listenWhenClosed
}
;
}
}
}
addListeners
(
target
)
{
target
.
addEventListener
(
"
SwapDocShells
"
this
)
;
for
(
let
{
message
listener
listenWhenClosed
}
of
this
.
iterListeners
(
)
)
{
target
.
addMessageListener
(
message
listener
listenWhenClosed
)
;
}
this
.
eventTarget
=
target
;
}
removeListeners
(
target
)
{
target
.
removeEventListener
(
"
SwapDocShells
"
this
)
;
for
(
let
{
message
listener
}
of
this
.
iterListeners
(
)
)
{
target
.
removeMessageListener
(
message
listener
)
;
}
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
SwapDocShells
"
)
{
this
.
removeListeners
(
this
.
eventTarget
)
;
this
.
addListeners
(
event
.
detail
)
;
}
}
}
this
.
ExtensionUtils
=
{
defineLazyGetter
flushJarCache
getConsole
getInnerWindowID
getMessageManager
getUniqueId
filterStack
getWinUtils
instanceOf
normalizeTime
promiseDocumentLoaded
promiseDocumentReady
promiseEvent
promiseObserved
runSafe
runSafeSync
runSafeSyncWithoutClone
runSafeWithoutClone
withHandlingUserInput
DefaultMap
DefaultWeakMap
EventEmitter
ExtensionError
LimitedSet
MessageManagerProxy
}
;
