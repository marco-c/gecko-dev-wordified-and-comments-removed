"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExtensionUtils
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
idleTimeout
"
(
)
=
>
Services
.
appinfo
.
name
=
=
=
"
XPCShell
"
?
500
:
undefined
)
;
const
appinfo
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
let
nextId
=
0
;
const
uniqueProcessID
=
appinfo
.
uniqueProcessID
;
const
processIDMask
=
(
uniqueProcessID
&
0xffff
)
*
2
*
*
37
;
function
getUniqueId
(
)
{
return
processIDMask
+
nextId
+
+
;
}
function
promiseTimeout
(
delay
)
{
return
new
Promise
(
resolve
=
>
lazy
.
setTimeout
(
resolve
delay
)
)
;
}
class
ExtensionError
extends
DOMException
{
constructor
(
message
)
{
super
(
message
"
ExtensionError
"
)
;
}
static
[
Symbol
.
hasInstance
]
(
e
)
{
return
DOMException
.
isInstance
(
e
)
&
&
e
.
name
=
=
=
"
ExtensionError
"
;
}
}
function
filterStack
(
error
)
{
return
String
(
error
.
stack
)
.
replace
(
/
(
^
.
*
(
Task
\
.
jsm
|
Promise
-
backend
\
.
js
)
.
*
\
n
)
+
/
gm
"
<
Promise
Chain
>
\
n
"
)
;
}
class
WorkerExtensionError
extends
DOMException
{
constructor
(
message
)
{
super
(
message
"
Error
"
)
;
}
}
class
DefaultWeakMap
extends
WeakMap
{
constructor
(
defaultConstructor
=
undefined
init
=
undefined
)
{
super
(
init
)
;
if
(
defaultConstructor
)
{
this
.
defaultConstructor
=
defaultConstructor
;
}
}
get
(
key
)
{
let
value
=
super
.
get
(
key
)
;
if
(
value
=
=
=
undefined
&
&
!
this
.
has
(
key
)
)
{
value
=
this
.
defaultConstructor
(
key
)
;
this
.
set
(
key
value
)
;
}
return
value
;
}
}
class
DefaultMap
extends
Map
{
constructor
(
defaultConstructor
=
undefined
init
=
undefined
)
{
super
(
init
)
;
if
(
defaultConstructor
)
{
this
.
defaultConstructor
=
defaultConstructor
;
}
}
get
(
key
)
{
let
value
=
super
.
get
(
key
)
;
if
(
value
=
=
=
undefined
&
&
!
this
.
has
(
key
)
)
{
value
=
this
.
defaultConstructor
(
key
)
;
this
.
set
(
key
value
)
;
}
return
value
;
}
}
function
getInnerWindowID
(
window
)
{
return
window
.
windowGlobalChild
?
.
innerWindowId
;
}
class
LimitedSet
extends
Set
{
constructor
(
limit
slop
=
Math
.
round
(
limit
*
0
.
25
)
iterable
=
undefined
)
{
super
(
iterable
)
;
this
.
limit
=
limit
;
this
.
slop
=
slop
;
}
truncate
(
limit
)
{
for
(
let
item
of
this
)
{
if
(
this
.
size
>
limit
)
{
this
.
delete
(
item
)
;
}
}
}
add
(
item
)
{
if
(
this
.
size
>
=
this
.
limit
+
this
.
slop
&
&
!
this
.
has
(
item
)
)
{
this
.
truncate
(
this
.
limit
-
1
)
;
}
super
.
add
(
item
)
;
}
}
function
promiseDocumentReady
(
doc
)
{
if
(
doc
.
readyState
=
=
"
interactive
"
|
|
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
addEventListener
(
"
DOMContentLoaded
"
function
onReady
(
event
)
{
if
(
event
.
target
=
=
=
event
.
currentTarget
)
{
doc
.
removeEventListener
(
"
DOMContentLoaded
"
onReady
true
)
;
resolve
(
doc
)
;
}
}
true
)
;
}
)
;
}
function
promiseDocumentIdle
(
window
)
{
return
window
.
document
.
documentReadyForIdle
.
then
(
(
)
=
>
{
return
new
Promise
(
resolve
=
>
window
.
requestIdleCallback
(
resolve
{
timeout
:
lazy
.
idleTimeout
}
)
)
;
}
)
;
}
function
promiseDocumentLoaded
(
doc
)
{
if
(
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
defaultView
.
addEventListener
(
"
load
"
(
)
=
>
resolve
(
doc
)
{
once
:
true
}
)
;
}
)
;
}
function
promiseEvent
(
element
eventName
useCapture
=
true
test
=
event
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
function
listener
(
event
)
{
if
(
test
(
event
)
)
{
element
.
removeEventListener
(
eventName
listener
useCapture
)
;
resolve
(
event
)
;
}
}
element
.
addEventListener
(
eventName
listener
useCapture
)
;
}
)
;
}
function
promiseObserved
(
topic
test
=
(
)
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
test
(
subject
data
)
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
{
subject
data
}
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
topic
)
;
}
)
;
}
function
getMessageManager
(
target
)
{
if
(
target
.
frameLoader
)
{
return
target
.
frameLoader
.
messageManager
;
}
return
target
;
}
function
flushJarCache
(
jarPath
)
{
Services
.
obs
.
notifyObservers
(
null
"
flush
-
cache
-
entry
"
jarPath
)
;
}
function
parseMatchPatterns
(
patterns
options
)
{
try
{
return
new
MatchPatternSet
(
patterns
options
)
;
}
catch
(
e
)
{
let
pattern
;
for
(
pattern
of
patterns
)
{
try
{
new
MatchPattern
(
pattern
options
)
;
}
catch
(
e
)
{
throw
new
ExtensionError
(
Invalid
url
pattern
:
{
pattern
}
)
;
}
}
throw
e
;
}
}
async
function
makeDataURI
(
iconUrl
)
{
let
response
;
try
{
response
=
await
fetch
(
iconUrl
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
;
}
let
buffer
=
await
response
.
arrayBuffer
(
)
;
let
contentType
=
response
.
headers
.
get
(
"
content
-
type
"
)
;
let
bytes
=
new
Uint8Array
(
buffer
)
;
let
str
=
String
.
fromCharCode
.
apply
(
null
bytes
)
;
return
data
:
{
contentType
}
;
base64
{
btoa
(
str
)
}
;
}
var
ExtensionUtils
=
{
flushJarCache
getInnerWindowID
getMessageManager
getUniqueId
filterStack
makeDataURI
parseMatchPatterns
promiseDocumentIdle
promiseDocumentLoaded
promiseDocumentReady
promiseEvent
promiseObserved
promiseTimeout
DefaultMap
DefaultWeakMap
ExtensionError
LimitedSet
WorkerExtensionError
}
;
