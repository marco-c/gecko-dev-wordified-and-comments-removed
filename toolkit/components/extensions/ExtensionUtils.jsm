"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionUtils
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
const
INTEGER
=
/
^
[
1
-
9
]
\
d
*
/
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ConsoleAPI
"
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionManagement
"
"
resource
:
/
/
gre
/
modules
/
ExtensionManagement
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
IndexedDB
"
"
resource
:
/
/
gre
/
modules
/
IndexedDB
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LanguageDetector
"
"
resource
:
/
/
/
modules
/
translation
/
LanguageDetector
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Locale
"
"
resource
:
/
/
gre
/
modules
/
Locale
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MessageChannel
"
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Schemas
"
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
styleSheetService
"
"
mozilla
.
org
/
content
/
style
-
sheet
-
service
;
1
"
"
nsIStyleSheetService
"
)
;
function
getConsole
(
)
{
return
new
ConsoleAPI
(
{
maxLogLevelPref
:
"
extensions
.
webextensions
.
log
.
level
"
prefix
:
"
WebExtensions
"
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
getConsole
)
;
let
nextId
=
0
;
XPCOMUtils
.
defineLazyGetter
(
this
"
uniqueProcessID
"
(
)
=
>
Services
.
appinfo
.
uniqueProcessID
)
;
function
getUniqueId
(
)
{
return
{
nextId
+
+
}
-
{
uniqueProcessID
}
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
gAllowedThemeProperties
"
(
)
=
>
{
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
let
propertiesInBaseManifest
=
ExtensionParent
.
baseManifestProperties
;
return
propertiesInBaseManifest
.
filter
(
prop
=
>
{
const
propertiesToRemove
=
[
"
background
"
"
content_scripts
"
"
permissions
"
]
;
return
!
propertiesToRemove
.
includes
(
prop
)
;
}
)
;
}
)
;
function
validateThemeManifest
(
manifestProperties
)
{
let
invalidProps
=
[
]
;
for
(
let
propName
of
manifestProperties
)
{
if
(
propName
!
=
"
theme
"
&
&
!
gAllowedThemeProperties
.
includes
(
propName
)
)
{
invalidProps
.
push
(
propName
)
;
}
}
return
invalidProps
;
}
let
StartupCache
=
{
DB_NAME
:
"
ExtensionStartupCache
"
SCHEMA_VERSION
:
1
STORE_NAMES
:
Object
.
freeze
(
[
"
locales
"
"
manifests
"
"
schemas
"
]
)
dbPromise
:
null
cacheInvalidated
:
0
initDB
(
db
)
{
for
(
let
name
of
StartupCache
.
STORE_NAMES
)
{
try
{
db
.
deleteObjectStore
(
name
)
;
}
catch
(
e
)
{
}
db
.
createObjectStore
(
name
)
;
}
}
clearAddonData
(
id
)
{
let
range
=
IDBKeyRange
.
bound
(
[
id
]
[
id
"
\
uFFFF
"
]
)
;
return
Promise
.
all
(
[
this
.
locales
.
delete
(
range
)
this
.
manifests
.
delete
(
range
)
]
)
.
catch
(
e
=
>
{
}
)
;
}
async
reallyOpen
(
invalidate
=
false
)
{
if
(
this
.
dbPromise
)
{
let
db
=
await
this
.
dbPromise
;
db
.
close
(
)
;
}
if
(
invalidate
)
{
this
.
cacheInvalidated
=
ExtensionManagement
.
cacheInvalidated
;
if
(
Services
.
appinfo
.
processType
=
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
IndexedDB
.
deleteDatabase
(
this
.
DB_NAME
{
storage
:
"
persistent
"
}
)
;
}
}
return
IndexedDB
.
open
(
this
.
DB_NAME
{
storage
:
"
persistent
"
version
:
this
.
SCHEMA_VERSION
}
db
=
>
this
.
initDB
(
db
)
)
;
}
async
open
(
)
{
if
(
ExtensionManagement
.
cacheInvalidated
>
this
.
cacheInvalidated
)
{
this
.
dbPromise
=
this
.
reallyOpen
(
true
)
;
}
else
if
(
!
this
.
dbPromise
)
{
this
.
dbPromise
=
this
.
reallyOpen
(
)
;
}
return
this
.
dbPromise
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
"
startupcache
-
invalidate
"
)
{
this
.
dbPromise
=
this
.
reallyOpen
(
true
)
.
catch
(
e
=
>
{
}
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
StartupCache
"
startupcache
-
invalidate
"
false
)
;
class
CacheStore
{
constructor
(
storeName
)
{
this
.
storeName
=
storeName
;
}
async
get
(
key
createFunc
)
{
let
db
;
let
value
;
try
{
db
=
await
StartupCache
.
open
(
)
;
value
=
await
db
.
objectStore
(
this
.
storeName
)
.
get
(
key
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
createFunc
(
key
)
;
}
if
(
value
=
=
=
undefined
)
{
value
=
await
createFunc
(
key
)
;
db
.
objectStore
(
this
.
storeName
"
readwrite
"
)
.
put
(
value
key
)
;
}
return
value
;
}
async
delete
(
key
)
{
let
db
=
await
StartupCache
.
open
(
)
;
return
db
.
objectStore
(
this
.
storeName
"
readwrite
"
)
.
delete
(
key
)
;
}
}
for
(
let
name
of
StartupCache
.
STORE_NAMES
)
{
StartupCache
[
name
]
=
new
CacheStore
(
name
)
;
}
class
ExtensionError
extends
Error
{
}
function
filterStack
(
error
)
{
return
String
(
error
.
stack
)
.
replace
(
/
(
^
.
*
(
Task
\
.
jsm
|
Promise
-
backend
\
.
js
)
.
*
\
n
)
+
/
gm
"
<
Promise
Chain
>
\
n
"
)
;
}
function
runSafeSyncWithoutClone
(
f
.
.
.
args
)
{
try
{
return
f
(
.
.
.
args
)
;
}
catch
(
e
)
{
dump
(
Extension
error
:
{
e
}
{
e
.
fileName
}
{
e
.
lineNumber
}
\
n
[
[
Exception
stack
\
n
{
filterStack
(
e
)
}
Current
stack
\
n
{
filterStack
(
Error
(
)
)
}
]
]
\
n
)
;
Cu
.
reportError
(
e
)
;
}
}
function
runSafeWithoutClone
(
f
.
.
.
args
)
{
if
(
typeof
(
f
)
!
=
"
function
"
)
{
dump
(
Extension
error
:
expected
function
\
n
{
filterStack
(
Error
(
)
)
}
)
;
return
;
}
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
runSafeSyncWithoutClone
(
f
.
.
.
args
)
;
}
)
;
}
function
runSafeSync
(
context
f
.
.
.
args
)
{
if
(
context
.
unloaded
)
{
Cu
.
reportError
(
"
runSafeSync
called
after
context
unloaded
"
)
;
return
;
}
try
{
args
=
Cu
.
cloneInto
(
args
context
.
cloneScope
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
context
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
return
runSafeSyncWithoutClone
(
f
.
.
.
args
)
;
}
function
runSafe
(
context
f
.
.
.
args
)
{
try
{
args
=
Cu
.
cloneInto
(
args
context
.
cloneScope
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
context
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
if
(
context
.
unloaded
)
{
dump
(
runSafe
failure
:
context
is
already
unloaded
{
filterStack
(
new
Error
(
)
)
}
\
n
)
;
return
undefined
;
}
return
runSafeWithoutClone
(
f
.
.
.
args
)
;
}
function
instanceOf
(
value
type
)
{
return
{
}
.
toString
.
call
(
value
)
=
=
[
object
{
type
}
]
;
}
function
extend
(
obj
.
.
.
args
)
{
for
(
let
arg
of
args
)
{
let
props
=
[
.
.
.
Object
.
getOwnPropertyNames
(
arg
)
.
.
.
Object
.
getOwnPropertySymbols
(
arg
)
]
;
for
(
let
prop
of
props
)
{
let
descriptor
=
Object
.
getOwnPropertyDescriptor
(
arg
prop
)
;
Object
.
defineProperty
(
obj
prop
descriptor
)
;
}
}
return
obj
;
}
class
DefaultWeakMap
extends
WeakMap
{
constructor
(
defaultConstructor
init
)
{
super
(
init
)
;
this
.
defaultConstructor
=
defaultConstructor
;
}
get
(
key
)
{
if
(
!
this
.
has
(
key
)
)
{
this
.
set
(
key
this
.
defaultConstructor
(
key
)
)
;
}
return
super
.
get
(
key
)
;
}
}
class
DefaultMap
extends
Map
{
constructor
(
defaultConstructor
init
)
{
super
(
init
)
;
this
.
defaultConstructor
=
defaultConstructor
;
}
get
(
key
)
{
if
(
!
this
.
has
(
key
)
)
{
this
.
set
(
key
this
.
defaultConstructor
(
key
)
)
;
}
return
super
.
get
(
key
)
;
}
}
const
_winUtils
=
new
DefaultWeakMap
(
win
=
>
{
return
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
)
;
const
getWinUtils
=
win
=
>
_winUtils
.
get
(
win
)
;
function
getInnerWindowID
(
window
)
{
return
getWinUtils
(
window
)
.
currentInnerWindowID
;
}
class
SpreadArgs
extends
Array
{
constructor
(
args
)
{
super
(
)
;
this
.
push
(
.
.
.
args
)
;
}
}
let
IconDetails
=
{
normalize
(
details
extension
context
=
null
)
{
let
result
=
{
}
;
try
{
if
(
details
.
imageData
)
{
let
imageData
=
details
.
imageData
;
if
(
typeof
imageData
=
=
"
string
"
)
{
imageData
=
{
"
19
"
:
imageData
}
;
}
for
(
let
size
of
Object
.
keys
(
imageData
)
)
{
if
(
!
INTEGER
.
test
(
size
)
)
{
throw
new
ExtensionError
(
Invalid
icon
size
{
size
}
must
be
an
integer
)
;
}
result
[
size
]
=
imageData
[
size
]
;
}
}
if
(
details
.
path
)
{
let
path
=
details
.
path
;
if
(
typeof
path
!
=
"
object
"
)
{
path
=
{
"
19
"
:
path
}
;
}
let
baseURI
=
context
?
context
.
uri
:
extension
.
baseURI
;
for
(
let
size
of
Object
.
keys
(
path
)
)
{
if
(
!
INTEGER
.
test
(
size
)
)
{
throw
new
ExtensionError
(
Invalid
icon
size
{
size
}
must
be
an
integer
)
;
}
let
url
=
baseURI
.
resolve
(
path
[
size
]
)
;
try
{
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
extension
.
principal
url
Services
.
scriptSecurityManager
.
DISALLOW_SCRIPT
)
;
}
catch
(
e
)
{
throw
new
ExtensionError
(
Illegal
URL
{
url
}
)
;
}
result
[
size
]
=
url
;
}
}
}
catch
(
e
)
{
if
(
context
)
{
throw
e
;
}
extension
.
manifestError
(
Invalid
icon
data
:
{
e
}
)
;
}
return
result
;
}
getPreferredIcon
(
icons
extension
=
null
size
=
16
)
{
const
DEFAULT
=
"
chrome
:
/
/
browser
/
content
/
extension
.
svg
"
;
let
bestSize
=
null
;
if
(
icons
[
size
]
)
{
bestSize
=
size
;
}
else
if
(
icons
[
2
*
size
]
)
{
bestSize
=
2
*
size
;
}
else
{
let
sizes
=
Object
.
keys
(
icons
)
.
map
(
key
=
>
parseInt
(
key
10
)
)
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
bestSize
=
sizes
.
find
(
candidate
=
>
candidate
>
size
)
|
|
sizes
.
pop
(
)
;
}
if
(
bestSize
)
{
return
{
size
:
bestSize
icon
:
icons
[
bestSize
]
}
;
}
return
{
size
icon
:
DEFAULT
}
;
}
convertImageURLToDataURL
(
imageURL
contentWindow
browserWindow
size
=
18
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
image
=
new
contentWindow
.
Image
(
)
;
image
.
onload
=
function
(
)
{
let
canvas
=
contentWindow
.
document
.
createElement
(
"
canvas
"
)
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
let
dSize
=
size
*
browserWindow
.
devicePixelRatio
;
let
dWidth
dHeight
dx
dy
;
if
(
this
.
width
>
this
.
height
)
{
dWidth
=
dSize
;
dHeight
=
image
.
height
*
(
dSize
/
image
.
width
)
;
dx
=
0
;
dy
=
(
dSize
-
dHeight
)
/
2
;
}
else
{
dWidth
=
image
.
width
*
(
dSize
/
image
.
height
)
;
dHeight
=
dSize
;
dx
=
(
dSize
-
dWidth
)
/
2
;
dy
=
0
;
}
canvas
.
width
=
dSize
;
canvas
.
height
=
dSize
;
ctx
.
drawImage
(
this
0
0
this
.
width
this
.
height
dx
dy
dWidth
dHeight
)
;
resolve
(
canvas
.
toDataURL
(
"
image
/
png
"
)
)
;
}
;
image
.
onerror
=
reject
;
image
.
src
=
imageURL
;
}
)
;
}
escapeUrl
(
url
)
{
return
url
.
replace
(
/
[
\
\
\
s
"
]
/
g
encodeURIComponent
)
;
}
}
;
const
LISTENERS
=
Symbol
(
"
listeners
"
)
;
const
ONCE_MAP
=
Symbol
(
"
onceMap
"
)
;
class
EventEmitter
{
constructor
(
)
{
this
[
LISTENERS
]
=
new
Map
(
)
;
this
[
ONCE_MAP
]
=
new
WeakMap
(
)
;
}
on
(
event
listener
)
{
if
(
!
this
[
LISTENERS
]
.
has
(
event
)
)
{
this
[
LISTENERS
]
.
set
(
event
new
Set
(
)
)
;
}
this
[
LISTENERS
]
.
get
(
event
)
.
add
(
listener
)
;
}
off
(
event
listener
)
{
if
(
this
[
LISTENERS
]
.
has
(
event
)
)
{
let
set
=
this
[
LISTENERS
]
.
get
(
event
)
;
set
.
delete
(
listener
)
;
set
.
delete
(
this
[
ONCE_MAP
]
.
get
(
listener
)
)
;
if
(
!
set
.
size
)
{
this
[
LISTENERS
]
.
delete
(
event
)
;
}
}
}
once
(
event
listener
)
{
let
wrapper
=
(
.
.
.
args
)
=
>
{
this
.
off
(
event
wrapper
)
;
this
[
ONCE_MAP
]
.
delete
(
listener
)
;
return
listener
(
.
.
.
args
)
;
}
;
this
[
ONCE_MAP
]
.
set
(
listener
wrapper
)
;
this
.
on
(
event
wrapper
)
;
}
emit
(
event
.
.
.
args
)
{
let
listeners
=
this
[
LISTENERS
]
.
get
(
event
)
|
|
new
Set
(
)
;
let
promises
=
Array
.
from
(
listeners
listener
=
>
{
return
runSafeSyncWithoutClone
(
listener
event
.
.
.
args
)
;
}
)
;
return
Promise
.
all
(
promises
)
;
}
}
function
LocaleData
(
data
)
{
this
.
defaultLocale
=
data
.
defaultLocale
;
this
.
selectedLocale
=
data
.
selectedLocale
;
this
.
locales
=
data
.
locales
|
|
new
Map
(
)
;
this
.
warnedMissingKeys
=
new
Set
(
)
;
this
.
messages
=
data
.
messages
|
|
new
Map
(
)
;
if
(
data
.
builtinMessages
)
{
this
.
messages
.
set
(
this
.
BUILTIN
data
.
builtinMessages
)
;
}
}
LocaleData
.
prototype
=
{
serialize
(
)
{
return
{
defaultLocale
:
this
.
defaultLocale
selectedLocale
:
this
.
selectedLocale
messages
:
this
.
messages
locales
:
this
.
locales
}
;
}
BUILTIN
:
"
BUILTIN_MESSAGES
"
has
(
locale
)
{
return
this
.
messages
.
has
(
locale
)
;
}
localizeMessage
(
message
substitutions
=
[
]
options
=
{
}
)
{
let
defaultOptions
=
{
locale
:
this
.
selectedLocale
defaultValue
:
"
"
cloneScope
:
null
}
;
options
=
Object
.
assign
(
defaultOptions
options
)
;
let
locales
=
new
Set
(
[
this
.
BUILTIN
options
.
locale
this
.
defaultLocale
]
.
filter
(
locale
=
>
this
.
messages
.
has
(
locale
)
)
)
;
message
=
message
.
toLowerCase
(
)
;
for
(
let
locale
of
locales
)
{
let
messages
=
this
.
messages
.
get
(
locale
)
;
if
(
messages
.
has
(
message
)
)
{
let
str
=
messages
.
get
(
message
)
;
if
(
!
Array
.
isArray
(
substitutions
)
)
{
substitutions
=
[
substitutions
]
;
}
let
replacer
=
(
matched
index
dollarSigns
)
=
>
{
if
(
index
)
{
index
=
parseInt
(
index
10
)
-
1
;
return
index
in
substitutions
?
substitutions
[
index
]
:
"
"
;
}
return
dollarSigns
;
}
;
return
str
.
replace
(
/
\
(
?
:
(
[
1
-
9
]
\
d
*
)
|
(
\
+
)
)
/
g
replacer
)
;
}
}
if
(
message
=
=
"
ui_locale
"
)
{
return
this
.
uiLocale
;
}
else
if
(
message
.
startsWith
(
"
bidi_
"
)
)
{
let
rtl
=
Services
.
locale
.
isAppLocaleRTL
;
if
(
message
=
=
"
bidi_dir
"
)
{
return
rtl
?
"
rtl
"
:
"
ltr
"
;
}
else
if
(
message
=
=
"
bidi_reversed_dir
"
)
{
return
rtl
?
"
ltr
"
:
"
rtl
"
;
}
else
if
(
message
=
=
"
bidi_start_edge
"
)
{
return
rtl
?
"
right
"
:
"
left
"
;
}
else
if
(
message
=
=
"
bidi_end_edge
"
)
{
return
rtl
?
"
left
"
:
"
right
"
;
}
}
if
(
!
this
.
warnedMissingKeys
.
has
(
message
)
)
{
let
error
=
Unknown
localization
message
{
message
}
;
if
(
options
.
cloneScope
)
{
error
=
new
options
.
cloneScope
.
Error
(
error
)
;
}
Cu
.
reportError
(
error
)
;
this
.
warnedMissingKeys
.
add
(
message
)
;
}
return
options
.
defaultValue
;
}
localize
(
str
locale
=
this
.
selectedLocale
)
{
if
(
!
str
)
{
return
str
;
}
return
str
.
replace
(
/
__MSG_
(
[
A
-
Za
-
z0
-
9
_
]
+
?
)
__
/
g
(
matched
message
)
=
>
{
return
this
.
localizeMessage
(
message
[
]
{
locale
defaultValue
:
matched
}
)
;
}
)
;
}
addLocale
(
locale
messages
extension
)
{
let
result
=
new
Map
(
)
;
if
(
!
instanceOf
(
messages
"
Object
"
)
)
{
extension
.
packagingError
(
Invalid
locale
data
for
{
locale
}
)
;
return
result
;
}
for
(
let
key
of
Object
.
keys
(
messages
)
)
{
let
msg
=
messages
[
key
]
;
if
(
!
instanceOf
(
msg
"
Object
"
)
|
|
typeof
(
msg
.
message
)
!
=
"
string
"
)
{
extension
.
packagingError
(
Invalid
locale
message
data
for
{
locale
}
message
{
JSON
.
stringify
(
key
)
}
)
;
continue
;
}
let
placeholders
=
new
Map
(
)
;
if
(
instanceOf
(
msg
.
placeholders
"
Object
"
)
)
{
for
(
let
key
of
Object
.
keys
(
msg
.
placeholders
)
)
{
placeholders
.
set
(
key
.
toLowerCase
(
)
msg
.
placeholders
[
key
]
)
;
}
}
let
replacer
=
(
match
name
)
=
>
{
let
replacement
=
placeholders
.
get
(
name
.
toLowerCase
(
)
)
;
if
(
instanceOf
(
replacement
"
Object
"
)
&
&
"
content
"
in
replacement
)
{
return
replacement
.
content
;
}
return
"
"
;
}
;
let
value
=
msg
.
message
.
replace
(
/
\
(
[
A
-
Za
-
z0
-
9
_
]
+
)
\
/
g
replacer
)
;
result
.
set
(
key
.
toLowerCase
(
)
value
)
;
}
this
.
messages
.
set
(
locale
result
)
;
return
result
;
}
get
acceptLanguages
(
)
{
let
result
=
Preferences
.
get
(
"
intl
.
accept_languages
"
"
"
Ci
.
nsIPrefLocalizedString
)
;
return
result
.
split
(
/
\
s
*
\
s
*
/
g
)
;
}
get
uiLocale
(
)
{
return
Locale
.
getLocale
(
)
.
replace
(
/
-
/
g
"
_
"
)
;
}
}
;
function
SingletonEventManager
(
context
name
register
)
{
this
.
context
=
context
;
this
.
name
=
name
;
this
.
register
=
register
;
this
.
unregister
=
new
Map
(
)
;
}
SingletonEventManager
.
prototype
=
{
addListener
(
callback
.
.
.
args
)
{
if
(
this
.
unregister
.
has
(
callback
)
)
{
return
;
}
let
shouldFire
=
(
)
=
>
{
if
(
this
.
context
.
unloaded
)
{
dump
(
{
this
.
name
}
event
fired
after
context
unloaded
.
\
n
)
;
}
else
if
(
!
this
.
context
.
active
)
{
dump
(
{
this
.
name
}
event
fired
while
context
is
inactive
.
\
n
)
;
}
else
if
(
this
.
unregister
.
has
(
callback
)
)
{
return
true
;
}
return
false
;
}
;
let
fire
=
{
sync
:
(
.
.
.
args
)
=
>
{
if
(
shouldFire
(
)
)
{
return
this
.
context
.
runSafe
(
callback
.
.
.
args
)
;
}
}
async
:
(
.
.
.
args
)
=
>
{
return
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
if
(
shouldFire
(
)
)
{
return
this
.
context
.
runSafe
(
callback
.
.
.
args
)
;
}
}
)
;
}
raw
:
(
.
.
.
args
)
=
>
{
if
(
!
shouldFire
(
)
)
{
throw
new
Error
(
"
Called
raw
(
)
on
unloaded
/
inactive
context
"
)
;
}
return
callback
(
.
.
.
args
)
;
}
asyncWithoutClone
:
(
.
.
.
args
)
=
>
{
return
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
if
(
shouldFire
(
)
)
{
return
this
.
context
.
runSafeWithoutClone
(
callback
.
.
.
args
)
;
}
}
)
;
}
}
;
let
unregister
=
this
.
register
(
fire
.
.
.
args
)
;
this
.
unregister
.
set
(
callback
unregister
)
;
this
.
context
.
callOnClose
(
this
)
;
}
removeListener
(
callback
)
{
if
(
!
this
.
unregister
.
has
(
callback
)
)
{
return
;
}
let
unregister
=
this
.
unregister
.
get
(
callback
)
;
this
.
unregister
.
delete
(
callback
)
;
try
{
unregister
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
this
.
unregister
.
size
=
=
0
)
{
this
.
context
.
forgetOnClose
(
this
)
;
}
}
hasListener
(
callback
)
{
return
this
.
unregister
.
has
(
callback
)
;
}
revoke
(
)
{
for
(
let
callback
of
this
.
unregister
.
keys
(
)
)
{
this
.
removeListener
(
callback
)
;
}
}
close
(
)
{
this
.
revoke
(
)
;
}
api
(
)
{
return
{
addListener
:
(
.
.
.
args
)
=
>
this
.
addListener
(
.
.
.
args
)
removeListener
:
(
.
.
.
args
)
=
>
this
.
removeListener
(
.
.
.
args
)
hasListener
:
(
.
.
.
args
)
=
>
this
.
hasListener
(
.
.
.
args
)
[
Schemas
.
REVOKE
]
:
(
)
=
>
this
.
revoke
(
)
}
;
}
}
;
function
ignoreEvent
(
context
name
)
{
return
{
addListener
:
function
(
callback
)
{
let
id
=
context
.
extension
.
id
;
let
frame
=
Components
.
stack
.
caller
;
let
msg
=
In
add
-
on
{
id
}
attempting
to
use
listener
"
{
name
}
"
which
is
unimplemented
.
;
let
scriptError
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
scriptError
.
init
(
msg
frame
.
filename
null
frame
.
lineNumber
frame
.
columnNumber
Ci
.
nsIScriptError
.
warningFlag
"
content
javascript
"
)
;
let
consoleService
=
Cc
[
"
mozilla
.
org
/
consoleservice
;
1
"
]
.
getService
(
Ci
.
nsIConsoleService
)
;
consoleService
.
logMessage
(
scriptError
)
;
}
removeListener
:
function
(
callback
)
{
}
hasListener
:
function
(
callback
)
{
}
}
;
}
function
injectAPI
(
source
dest
)
{
for
(
let
prop
in
source
)
{
if
(
prop
[
0
]
=
=
"
_
"
)
{
continue
;
}
let
desc
=
Object
.
getOwnPropertyDescriptor
(
source
prop
)
;
if
(
typeof
(
desc
.
value
)
=
=
"
function
"
)
{
Cu
.
exportFunction
(
desc
.
value
dest
{
defineAs
:
prop
}
)
;
}
else
if
(
typeof
(
desc
.
value
)
=
=
"
object
"
)
{
let
obj
=
Cu
.
createObjectIn
(
dest
{
defineAs
:
prop
}
)
;
injectAPI
(
desc
.
value
obj
)
;
}
else
{
Object
.
defineProperty
(
dest
prop
desc
)
;
}
}
}
class
LimitedSet
extends
Set
{
constructor
(
limit
iterable
=
undefined
)
{
super
(
iterable
)
;
this
.
limit
=
limit
;
}
truncate
(
limit
)
{
for
(
let
item
of
this
)
{
if
(
this
.
size
<
=
limit
)
{
break
;
}
this
.
delete
(
item
)
;
}
}
add
(
item
)
{
if
(
!
this
.
has
(
item
)
&
&
this
.
size
>
=
this
.
limit
)
{
this
.
truncate
(
this
.
limit
-
1
)
;
}
super
.
add
(
item
)
;
}
}
function
promiseDocumentReady
(
doc
)
{
if
(
doc
.
readyState
=
=
"
interactive
"
|
|
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
addEventListener
(
"
DOMContentLoaded
"
function
onReady
(
event
)
{
if
(
event
.
target
=
=
=
event
.
currentTarget
)
{
doc
.
removeEventListener
(
"
DOMContentLoaded
"
onReady
true
)
;
resolve
(
doc
)
;
}
}
true
)
;
}
)
;
}
function
promiseDocumentLoaded
(
doc
)
{
if
(
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
defaultView
.
addEventListener
(
"
load
"
function
(
event
)
{
resolve
(
doc
)
;
}
{
once
:
true
}
)
;
}
)
;
}
function
promiseEvent
(
element
eventName
useCapture
=
true
test
=
event
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
function
listener
(
event
)
{
if
(
test
(
event
)
)
{
element
.
removeEventListener
(
eventName
listener
useCapture
)
;
resolve
(
event
)
;
}
}
element
.
addEventListener
(
eventName
listener
useCapture
)
;
}
)
;
}
function
promiseObserved
(
topic
test
=
(
)
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
test
(
subject
data
)
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
{
subject
data
}
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
topic
false
)
;
}
)
;
}
function
getMessageManager
(
target
)
{
if
(
target
instanceof
Ci
.
nsIFrameLoaderOwner
)
{
return
target
.
QueryInterface
(
Ci
.
nsIFrameLoaderOwner
)
.
frameLoader
.
messageManager
;
}
return
target
.
QueryInterface
(
Ci
.
nsIMessageSender
)
;
}
function
flushJarCache
(
jarPath
)
{
Services
.
obs
.
notifyObservers
(
null
"
flush
-
cache
-
entry
"
jarPath
)
;
}
function
PlatformInfo
(
)
{
return
Object
.
freeze
(
{
os
:
(
function
(
)
{
let
os
=
AppConstants
.
platform
;
if
(
os
=
=
"
macosx
"
)
{
os
=
"
mac
"
;
}
return
os
;
}
)
(
)
arch
:
(
function
(
)
{
let
abi
=
Services
.
appinfo
.
XPCOMABI
;
let
[
arch
]
=
abi
.
split
(
"
-
"
)
;
if
(
arch
=
=
"
x86
"
)
{
arch
=
"
x86
-
32
"
;
}
else
if
(
arch
=
=
"
x86_64
"
)
{
arch
=
"
x86
-
64
"
;
}
return
arch
;
}
)
(
)
}
)
;
}
function
detectLanguage
(
text
)
{
return
LanguageDetector
.
detectLanguage
(
text
)
.
then
(
result
=
>
(
{
isReliable
:
result
.
confident
languages
:
result
.
languages
.
map
(
lang
=
>
{
return
{
language
:
lang
.
languageCode
percentage
:
lang
.
percent
}
;
}
)
}
)
)
;
}
function
normalizeTime
(
date
)
{
return
new
Date
(
(
typeof
date
=
=
"
string
"
&
&
/
^
\
d
+
/
.
test
(
date
)
)
?
parseInt
(
date
10
)
:
date
)
;
}
const
stylesheetMap
=
new
DefaultMap
(
url
=
>
{
let
uri
=
NetUtil
.
newURI
(
url
)
;
return
styleSheetService
.
preloadSheet
(
uri
styleSheetService
.
AGENT_SHEET
)
;
}
)
;
function
defineLazyGetter
(
object
prop
getter
)
{
let
redefine
=
(
obj
value
)
=
>
{
Object
.
defineProperty
(
obj
prop
{
enumerable
:
true
configurable
:
true
writable
:
true
value
}
)
;
return
value
;
}
;
Object
.
defineProperty
(
object
prop
{
enumerable
:
true
configurable
:
true
get
(
)
{
return
redefine
(
this
getter
.
call
(
this
)
)
;
}
set
(
value
)
{
redefine
(
this
value
)
;
}
}
)
;
}
function
findPathInObject
(
obj
path
printErrors
=
true
)
{
let
parent
;
for
(
let
elt
of
path
.
split
(
"
.
"
)
)
{
if
(
!
obj
|
|
!
(
elt
in
obj
)
)
{
if
(
printErrors
)
{
Cu
.
reportError
(
WebExtension
API
{
path
}
not
found
(
it
may
be
unimplemented
by
Firefox
)
.
)
;
}
return
null
;
}
parent
=
obj
;
obj
=
obj
[
elt
]
;
}
if
(
typeof
obj
=
=
=
"
function
"
)
{
return
obj
.
bind
(
parent
)
;
}
return
obj
;
}
class
MessageManagerProxy
{
constructor
(
target
)
{
this
.
listeners
=
new
DefaultMap
(
(
)
=
>
new
Map
(
)
)
;
if
(
target
instanceof
Ci
.
nsIMessageSender
)
{
Object
.
defineProperty
(
this
"
messageManager
"
{
value
:
target
configurable
:
true
writable
:
true
}
)
;
}
else
{
this
.
addListeners
(
target
)
;
}
}
dispose
(
)
{
if
(
this
.
eventTarget
)
{
this
.
removeListeners
(
this
.
eventTarget
)
;
this
.
eventTarget
=
null
;
}
else
{
this
.
messageManager
=
null
;
}
}
static
matches
(
target
messageManager
)
{
return
target
=
=
=
messageManager
|
|
target
.
messageManager
=
=
=
messageManager
;
}
get
messageManager
(
)
{
return
this
.
eventTarget
&
&
this
.
eventTarget
.
messageManager
;
}
sendAsyncMessage
(
.
.
.
args
)
{
if
(
this
.
messageManager
)
{
return
this
.
messageManager
.
sendAsyncMessage
(
.
.
.
args
)
;
}
Cu
.
reportError
(
Cannot
send
message
:
Other
side
disconnected
:
{
uneval
(
args
)
}
)
;
}
get
isDisconnected
(
)
{
return
!
this
.
messageManager
;
}
addMessageListener
(
message
listener
listenWhenClosed
=
false
)
{
this
.
messageManager
.
addMessageListener
(
message
listener
listenWhenClosed
)
;
this
.
listeners
.
get
(
message
)
.
set
(
listener
listenWhenClosed
)
;
}
removeMessageListener
(
message
listener
)
{
this
.
messageManager
.
removeMessageListener
(
message
listener
)
;
let
listeners
=
this
.
listeners
.
get
(
message
)
;
listeners
.
delete
(
listener
)
;
if
(
!
listeners
.
size
)
{
this
.
listeners
.
delete
(
message
)
;
}
}
*
iterListeners
(
)
{
for
(
let
[
message
listeners
]
of
this
.
listeners
)
{
for
(
let
[
listener
listenWhenClosed
]
of
listeners
)
{
yield
{
message
listener
listenWhenClosed
}
;
}
}
}
addListeners
(
target
)
{
target
.
addEventListener
(
"
SwapDocShells
"
this
)
;
for
(
let
{
message
listener
listenWhenClosed
}
of
this
.
iterListeners
(
)
)
{
target
.
addMessageListener
(
message
listener
listenWhenClosed
)
;
}
this
.
eventTarget
=
target
;
}
removeListeners
(
target
)
{
target
.
removeEventListener
(
"
SwapDocShells
"
this
)
;
for
(
let
{
message
listener
}
of
this
.
iterListeners
(
)
)
{
target
.
removeMessageListener
(
message
listener
)
;
}
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
SwapDocShells
"
)
{
this
.
removeListeners
(
this
.
eventTarget
)
;
this
.
addListeners
(
event
.
detail
)
;
}
}
}
function
classifyPermission
(
perm
)
{
let
match
=
/
^
(
\
w
+
)
(
?
:
\
.
(
\
w
+
)
(
?
:
\
.
\
w
+
)
*
)
?
/
.
exec
(
perm
)
;
if
(
!
match
)
{
return
{
origin
:
perm
}
;
}
else
if
(
match
[
1
]
=
=
"
experiments
"
&
&
match
[
2
]
)
{
return
{
api
:
match
[
2
]
}
;
}
return
{
permission
:
perm
}
;
}
this
.
ExtensionUtils
=
{
classifyPermission
defineLazyGetter
detectLanguage
extend
findPathInObject
flushJarCache
getConsole
getInnerWindowID
getMessageManager
getUniqueId
filterStack
getWinUtils
ignoreEvent
injectAPI
instanceOf
normalizeTime
promiseDocumentLoaded
promiseDocumentReady
promiseEvent
promiseObserved
runSafe
runSafeSync
runSafeSyncWithoutClone
runSafeWithoutClone
stylesheetMap
validateThemeManifest
DefaultMap
DefaultWeakMap
EventEmitter
ExtensionError
IconDetails
LimitedSet
LocaleData
MessageManagerProxy
SingletonEventManager
SpreadArgs
StartupCache
}
;
XPCOMUtils
.
defineLazyGetter
(
this
.
ExtensionUtils
"
PlatformInfo
"
PlatformInfo
)
;
