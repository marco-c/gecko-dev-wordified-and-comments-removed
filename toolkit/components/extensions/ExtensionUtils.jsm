"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionUtils
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
const
INTEGER
=
/
^
[
1
-
9
]
\
d
*
/
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ConsoleAPI
"
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionManagement
"
"
resource
:
/
/
gre
/
modules
/
ExtensionManagement
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
IndexedDB
"
"
resource
:
/
/
gre
/
modules
/
IndexedDB
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MessageChannel
"
"
resource
:
/
/
gre
/
modules
/
MessageChannel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Schemas
"
"
resource
:
/
/
gre
/
modules
/
Schemas
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
styleSheetService
"
"
mozilla
.
org
/
content
/
style
-
sheet
-
service
;
1
"
"
nsIStyleSheetService
"
)
;
function
getConsole
(
)
{
return
new
ConsoleAPI
(
{
maxLogLevelPref
:
"
extensions
.
webextensions
.
log
.
level
"
prefix
:
"
WebExtensions
"
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
getConsole
)
;
let
nextId
=
0
;
XPCOMUtils
.
defineLazyGetter
(
this
"
uniqueProcessID
"
(
)
=
>
Services
.
appinfo
.
uniqueProcessID
)
;
function
getUniqueId
(
)
{
return
{
nextId
+
+
}
-
{
uniqueProcessID
}
;
}
let
StartupCache
=
{
DB_NAME
:
"
ExtensionStartupCache
"
SCHEMA_VERSION
:
2
STORE_NAMES
:
Object
.
freeze
(
[
"
locales
"
"
manifests
"
"
schemas
"
]
)
dbPromise
:
null
cacheInvalidated
:
0
initDB
(
db
)
{
for
(
let
name
of
StartupCache
.
STORE_NAMES
)
{
try
{
db
.
deleteObjectStore
(
name
)
;
}
catch
(
e
)
{
}
db
.
createObjectStore
(
name
{
keyPath
:
"
key
"
}
)
;
}
}
clearAddonData
(
id
)
{
let
range
=
IDBKeyRange
.
bound
(
[
id
]
[
id
"
\
uFFFF
"
]
)
;
return
Promise
.
all
(
[
this
.
locales
.
delete
(
range
)
this
.
manifests
.
delete
(
range
)
]
)
.
catch
(
e
=
>
{
}
)
;
}
async
reallyOpen
(
invalidate
=
false
)
{
if
(
this
.
dbPromise
)
{
let
db
=
await
this
.
dbPromise
;
db
.
close
(
)
;
}
if
(
invalidate
)
{
this
.
cacheInvalidated
=
ExtensionManagement
.
cacheInvalidated
;
if
(
Services
.
appinfo
.
processType
=
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
IndexedDB
.
deleteDatabase
(
this
.
DB_NAME
{
storage
:
"
persistent
"
}
)
;
}
}
return
IndexedDB
.
open
(
this
.
DB_NAME
{
storage
:
"
persistent
"
version
:
this
.
SCHEMA_VERSION
}
db
=
>
this
.
initDB
(
db
)
)
;
}
async
open
(
)
{
if
(
ExtensionManagement
.
cacheInvalidated
>
this
.
cacheInvalidated
)
{
this
.
dbPromise
=
this
.
reallyOpen
(
true
)
;
}
else
if
(
!
this
.
dbPromise
)
{
this
.
dbPromise
=
this
.
reallyOpen
(
)
;
}
return
this
.
dbPromise
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
"
startupcache
-
invalidate
"
)
{
this
.
dbPromise
=
this
.
reallyOpen
(
true
)
.
catch
(
e
=
>
{
}
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
StartupCache
"
startupcache
-
invalidate
"
)
;
class
CacheStore
{
constructor
(
storeName
)
{
this
.
storeName
=
storeName
;
}
async
get
(
key
createFunc
)
{
let
db
;
let
result
;
try
{
db
=
await
StartupCache
.
open
(
)
;
result
=
await
db
.
objectStore
(
this
.
storeName
)
.
get
(
key
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
createFunc
(
key
)
;
}
if
(
result
=
=
=
undefined
)
{
let
value
=
await
createFunc
(
key
)
;
result
=
{
key
value
}
;
db
.
objectStore
(
this
.
storeName
"
readwrite
"
)
.
put
(
result
)
;
}
return
result
&
&
result
.
value
;
}
async
getAll
(
)
{
let
result
=
new
Map
(
)
;
try
{
let
db
=
await
StartupCache
.
open
(
)
;
let
results
=
await
db
.
objectStore
(
this
.
storeName
)
.
getAll
(
)
;
for
(
let
{
key
value
}
of
results
)
{
result
.
set
(
key
value
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
result
;
}
async
delete
(
key
)
{
let
db
=
await
StartupCache
.
open
(
)
;
return
db
.
objectStore
(
this
.
storeName
"
readwrite
"
)
.
delete
(
key
)
;
}
}
for
(
let
name
of
StartupCache
.
STORE_NAMES
)
{
StartupCache
[
name
]
=
new
CacheStore
(
name
)
;
}
class
ExtensionError
extends
Error
{
}
function
filterStack
(
error
)
{
return
String
(
error
.
stack
)
.
replace
(
/
(
^
.
*
(
Task
\
.
jsm
|
Promise
-
backend
\
.
js
)
.
*
\
n
)
+
/
gm
"
<
Promise
Chain
>
\
n
"
)
;
}
function
runSafeSyncWithoutClone
(
f
.
.
.
args
)
{
try
{
return
f
(
.
.
.
args
)
;
}
catch
(
e
)
{
dump
(
Extension
error
:
{
e
}
{
e
.
fileName
}
{
e
.
lineNumber
}
\
n
[
[
Exception
stack
\
n
{
filterStack
(
e
)
}
Current
stack
\
n
{
filterStack
(
Error
(
)
)
}
]
]
\
n
)
;
Cu
.
reportError
(
e
)
;
}
}
function
runSafeWithoutClone
(
f
.
.
.
args
)
{
if
(
typeof
(
f
)
!
=
"
function
"
)
{
dump
(
Extension
error
:
expected
function
\
n
{
filterStack
(
Error
(
)
)
}
)
;
return
;
}
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
runSafeSyncWithoutClone
(
f
.
.
.
args
)
;
}
)
;
}
function
runSafeSync
(
context
f
.
.
.
args
)
{
if
(
context
.
unloaded
)
{
Cu
.
reportError
(
"
runSafeSync
called
after
context
unloaded
"
)
;
return
;
}
try
{
args
=
Cu
.
cloneInto
(
args
context
.
cloneScope
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
context
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
return
runSafeSyncWithoutClone
(
f
.
.
.
args
)
;
}
function
runSafe
(
context
f
.
.
.
args
)
{
try
{
args
=
Cu
.
cloneInto
(
args
context
.
cloneScope
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
dump
(
runSafe
failure
:
cloning
into
{
context
.
cloneScope
}
:
{
e
}
\
n
\
n
{
filterStack
(
Error
(
)
)
}
)
;
}
if
(
context
.
unloaded
)
{
dump
(
runSafe
failure
:
context
is
already
unloaded
{
filterStack
(
new
Error
(
)
)
}
\
n
)
;
return
undefined
;
}
return
runSafeWithoutClone
(
f
.
.
.
args
)
;
}
function
instanceOf
(
value
type
)
{
return
{
}
.
toString
.
call
(
value
)
=
=
[
object
{
type
}
]
;
}
function
extend
(
obj
.
.
.
args
)
{
for
(
let
arg
of
args
)
{
let
props
=
[
.
.
.
Object
.
getOwnPropertyNames
(
arg
)
.
.
.
Object
.
getOwnPropertySymbols
(
arg
)
]
;
for
(
let
prop
of
props
)
{
let
descriptor
=
Object
.
getOwnPropertyDescriptor
(
arg
prop
)
;
Object
.
defineProperty
(
obj
prop
descriptor
)
;
}
}
return
obj
;
}
class
DefaultWeakMap
extends
WeakMap
{
constructor
(
defaultConstructor
init
)
{
super
(
init
)
;
this
.
defaultConstructor
=
defaultConstructor
;
}
get
(
key
)
{
if
(
!
this
.
has
(
key
)
)
{
this
.
set
(
key
this
.
defaultConstructor
(
key
)
)
;
}
return
super
.
get
(
key
)
;
}
}
class
DefaultMap
extends
Map
{
constructor
(
defaultConstructor
init
)
{
super
(
init
)
;
this
.
defaultConstructor
=
defaultConstructor
;
}
get
(
key
)
{
if
(
!
this
.
has
(
key
)
)
{
this
.
set
(
key
this
.
defaultConstructor
(
key
)
)
;
}
return
super
.
get
(
key
)
;
}
}
const
_winUtils
=
new
DefaultWeakMap
(
win
=
>
{
return
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
)
;
const
getWinUtils
=
win
=
>
_winUtils
.
get
(
win
)
;
function
getInnerWindowID
(
window
)
{
return
getWinUtils
(
window
)
.
currentInnerWindowID
;
}
class
SpreadArgs
extends
Array
{
constructor
(
args
)
{
super
(
)
;
this
.
push
(
.
.
.
args
)
;
}
}
let
IconDetails
=
{
iconCache
:
new
DefaultWeakMap
(
(
)
=
>
new
Map
(
)
)
normalize
(
details
extension
context
=
null
)
{
if
(
!
details
.
imageData
&
&
typeof
details
.
path
=
=
=
"
string
"
)
{
let
icons
=
this
.
iconCache
.
get
(
extension
)
;
let
baseURI
=
context
?
context
.
uri
:
extension
.
baseURI
;
let
url
=
baseURI
.
resolve
(
details
.
path
)
;
let
icon
=
icons
.
get
(
url
)
;
if
(
!
icon
)
{
icon
=
this
.
_normalize
(
details
extension
context
)
;
icons
.
set
(
url
icon
)
;
}
return
icon
;
}
return
this
.
_normalize
(
details
extension
context
)
;
}
_normalize
(
details
extension
context
=
null
)
{
let
result
=
{
}
;
try
{
if
(
details
.
imageData
)
{
let
imageData
=
details
.
imageData
;
if
(
typeof
imageData
=
=
"
string
"
)
{
imageData
=
{
"
19
"
:
imageData
}
;
}
for
(
let
size
of
Object
.
keys
(
imageData
)
)
{
if
(
!
INTEGER
.
test
(
size
)
)
{
throw
new
ExtensionError
(
Invalid
icon
size
{
size
}
must
be
an
integer
)
;
}
result
[
size
]
=
imageData
[
size
]
;
}
}
if
(
details
.
path
)
{
let
path
=
details
.
path
;
if
(
typeof
path
!
=
"
object
"
)
{
path
=
{
"
19
"
:
path
}
;
}
let
baseURI
=
context
?
context
.
uri
:
extension
.
baseURI
;
for
(
let
size
of
Object
.
keys
(
path
)
)
{
if
(
!
INTEGER
.
test
(
size
)
)
{
throw
new
ExtensionError
(
Invalid
icon
size
{
size
}
must
be
an
integer
)
;
}
let
url
=
baseURI
.
resolve
(
path
[
size
]
)
;
try
{
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
extension
.
principal
url
Services
.
scriptSecurityManager
.
DISALLOW_SCRIPT
)
;
}
catch
(
e
)
{
throw
new
ExtensionError
(
Illegal
URL
{
url
}
)
;
}
result
[
size
]
=
url
;
}
}
}
catch
(
e
)
{
if
(
context
)
{
throw
e
;
}
extension
.
manifestError
(
Invalid
icon
data
:
{
e
}
)
;
}
return
result
;
}
getPreferredIcon
(
icons
extension
=
null
size
=
16
)
{
const
DEFAULT
=
"
chrome
:
/
/
browser
/
content
/
extension
.
svg
"
;
let
bestSize
=
null
;
if
(
icons
[
size
]
)
{
bestSize
=
size
;
}
else
if
(
icons
[
2
*
size
]
)
{
bestSize
=
2
*
size
;
}
else
{
let
sizes
=
Object
.
keys
(
icons
)
.
map
(
key
=
>
parseInt
(
key
10
)
)
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
bestSize
=
sizes
.
find
(
candidate
=
>
candidate
>
size
)
|
|
sizes
.
pop
(
)
;
}
if
(
bestSize
)
{
return
{
size
:
bestSize
icon
:
icons
[
bestSize
]
}
;
}
return
{
size
icon
:
DEFAULT
}
;
}
convertImageURLToDataURL
(
imageURL
contentWindow
browserWindow
size
=
18
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
image
=
new
contentWindow
.
Image
(
)
;
image
.
onload
=
function
(
)
{
let
canvas
=
contentWindow
.
document
.
createElement
(
"
canvas
"
)
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
let
dSize
=
size
*
browserWindow
.
devicePixelRatio
;
let
dWidth
dHeight
dx
dy
;
if
(
this
.
width
>
this
.
height
)
{
dWidth
=
dSize
;
dHeight
=
image
.
height
*
(
dSize
/
image
.
width
)
;
dx
=
0
;
dy
=
(
dSize
-
dHeight
)
/
2
;
}
else
{
dWidth
=
image
.
width
*
(
dSize
/
image
.
height
)
;
dHeight
=
dSize
;
dx
=
(
dSize
-
dWidth
)
/
2
;
dy
=
0
;
}
canvas
.
width
=
dSize
;
canvas
.
height
=
dSize
;
ctx
.
drawImage
(
this
0
0
this
.
width
this
.
height
dx
dy
dWidth
dHeight
)
;
resolve
(
canvas
.
toDataURL
(
"
image
/
png
"
)
)
;
}
;
image
.
onerror
=
reject
;
image
.
src
=
imageURL
;
}
)
;
}
escapeUrl
(
url
)
{
return
url
.
replace
(
/
[
\
\
\
s
"
]
/
g
encodeURIComponent
)
;
}
}
;
const
LISTENERS
=
Symbol
(
"
listeners
"
)
;
const
ONCE_MAP
=
Symbol
(
"
onceMap
"
)
;
class
EventEmitter
{
constructor
(
)
{
this
[
LISTENERS
]
=
new
Map
(
)
;
this
[
ONCE_MAP
]
=
new
WeakMap
(
)
;
}
on
(
event
listener
)
{
if
(
!
this
[
LISTENERS
]
.
has
(
event
)
)
{
this
[
LISTENERS
]
.
set
(
event
new
Set
(
)
)
;
}
this
[
LISTENERS
]
.
get
(
event
)
.
add
(
listener
)
;
}
off
(
event
listener
)
{
if
(
this
[
LISTENERS
]
.
has
(
event
)
)
{
let
set
=
this
[
LISTENERS
]
.
get
(
event
)
;
set
.
delete
(
listener
)
;
set
.
delete
(
this
[
ONCE_MAP
]
.
get
(
listener
)
)
;
if
(
!
set
.
size
)
{
this
[
LISTENERS
]
.
delete
(
event
)
;
}
}
}
once
(
event
listener
)
{
let
wrapper
=
(
.
.
.
args
)
=
>
{
this
.
off
(
event
wrapper
)
;
this
[
ONCE_MAP
]
.
delete
(
listener
)
;
return
listener
(
.
.
.
args
)
;
}
;
this
[
ONCE_MAP
]
.
set
(
listener
wrapper
)
;
this
.
on
(
event
wrapper
)
;
}
emit
(
event
.
.
.
args
)
{
let
listeners
=
this
[
LISTENERS
]
.
get
(
event
)
|
|
new
Set
(
)
;
let
promises
=
Array
.
from
(
listeners
listener
=
>
{
return
runSafeSyncWithoutClone
(
listener
event
.
.
.
args
)
;
}
)
;
return
Promise
.
all
(
promises
)
;
}
}
function
ignoreEvent
(
context
name
)
{
return
{
addListener
:
function
(
callback
)
{
let
id
=
context
.
extension
.
id
;
let
frame
=
Components
.
stack
.
caller
;
let
msg
=
In
add
-
on
{
id
}
attempting
to
use
listener
"
{
name
}
"
which
is
unimplemented
.
;
let
scriptError
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
scriptError
.
init
(
msg
frame
.
filename
null
frame
.
lineNumber
frame
.
columnNumber
Ci
.
nsIScriptError
.
warningFlag
"
content
javascript
"
)
;
let
consoleService
=
Cc
[
"
mozilla
.
org
/
consoleservice
;
1
"
]
.
getService
(
Ci
.
nsIConsoleService
)
;
consoleService
.
logMessage
(
scriptError
)
;
}
removeListener
:
function
(
callback
)
{
}
hasListener
:
function
(
callback
)
{
}
}
;
}
function
injectAPI
(
source
dest
)
{
for
(
let
prop
in
source
)
{
if
(
prop
[
0
]
=
=
"
_
"
)
{
continue
;
}
let
desc
=
Object
.
getOwnPropertyDescriptor
(
source
prop
)
;
if
(
typeof
(
desc
.
value
)
=
=
"
function
"
)
{
Cu
.
exportFunction
(
desc
.
value
dest
{
defineAs
:
prop
}
)
;
}
else
if
(
typeof
(
desc
.
value
)
=
=
"
object
"
)
{
let
obj
=
Cu
.
createObjectIn
(
dest
{
defineAs
:
prop
}
)
;
injectAPI
(
desc
.
value
obj
)
;
}
else
{
Object
.
defineProperty
(
dest
prop
desc
)
;
}
}
}
class
LimitedSet
extends
Set
{
constructor
(
limit
iterable
=
undefined
)
{
super
(
iterable
)
;
this
.
limit
=
limit
;
}
truncate
(
limit
)
{
for
(
let
item
of
this
)
{
if
(
this
.
size
<
=
limit
)
{
break
;
}
this
.
delete
(
item
)
;
}
}
add
(
item
)
{
if
(
!
this
.
has
(
item
)
&
&
this
.
size
>
=
this
.
limit
)
{
this
.
truncate
(
this
.
limit
-
1
)
;
}
super
.
add
(
item
)
;
}
}
function
promiseDocumentReady
(
doc
)
{
if
(
doc
.
readyState
=
=
"
interactive
"
|
|
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
addEventListener
(
"
DOMContentLoaded
"
function
onReady
(
event
)
{
if
(
event
.
target
=
=
=
event
.
currentTarget
)
{
doc
.
removeEventListener
(
"
DOMContentLoaded
"
onReady
true
)
;
resolve
(
doc
)
;
}
}
true
)
;
}
)
;
}
function
promiseDocumentLoaded
(
doc
)
{
if
(
doc
.
readyState
=
=
"
complete
"
)
{
return
Promise
.
resolve
(
doc
)
;
}
return
new
Promise
(
resolve
=
>
{
doc
.
defaultView
.
addEventListener
(
"
load
"
function
(
event
)
{
resolve
(
doc
)
;
}
{
once
:
true
}
)
;
}
)
;
}
function
promiseEvent
(
element
eventName
useCapture
=
true
test
=
event
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
function
listener
(
event
)
{
if
(
test
(
event
)
)
{
element
.
removeEventListener
(
eventName
listener
useCapture
)
;
resolve
(
event
)
;
}
}
element
.
addEventListener
(
eventName
listener
useCapture
)
;
}
)
;
}
function
promiseObserved
(
topic
test
=
(
)
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
test
(
subject
data
)
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
{
subject
data
}
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
topic
)
;
}
)
;
}
function
getMessageManager
(
target
)
{
if
(
target
instanceof
Ci
.
nsIFrameLoaderOwner
)
{
return
target
.
QueryInterface
(
Ci
.
nsIFrameLoaderOwner
)
.
frameLoader
.
messageManager
;
}
return
target
.
QueryInterface
(
Ci
.
nsIMessageSender
)
;
}
function
flushJarCache
(
jarPath
)
{
Services
.
obs
.
notifyObservers
(
null
"
flush
-
cache
-
entry
"
jarPath
)
;
}
function
PlatformInfo
(
)
{
return
Object
.
freeze
(
{
os
:
(
function
(
)
{
let
os
=
AppConstants
.
platform
;
if
(
os
=
=
"
macosx
"
)
{
os
=
"
mac
"
;
}
return
os
;
}
)
(
)
arch
:
(
function
(
)
{
let
abi
=
Services
.
appinfo
.
XPCOMABI
;
let
[
arch
]
=
abi
.
split
(
"
-
"
)
;
if
(
arch
=
=
"
x86
"
)
{
arch
=
"
x86
-
32
"
;
}
else
if
(
arch
=
=
"
x86_64
"
)
{
arch
=
"
x86
-
64
"
;
}
return
arch
;
}
)
(
)
}
)
;
}
function
normalizeTime
(
date
)
{
return
new
Date
(
(
typeof
date
=
=
"
string
"
&
&
/
^
\
d
+
/
.
test
(
date
)
)
?
parseInt
(
date
10
)
:
date
)
;
}
const
stylesheetMap
=
new
DefaultMap
(
url
=
>
{
let
uri
=
Services
.
io
.
newURI
(
url
)
;
return
styleSheetService
.
preloadSheet
(
uri
styleSheetService
.
AGENT_SHEET
)
;
}
)
;
function
defineLazyGetter
(
object
prop
getter
)
{
let
redefine
=
(
obj
value
)
=
>
{
Object
.
defineProperty
(
obj
prop
{
enumerable
:
true
configurable
:
true
writable
:
true
value
}
)
;
return
value
;
}
;
Object
.
defineProperty
(
object
prop
{
enumerable
:
true
configurable
:
true
get
(
)
{
return
redefine
(
this
getter
.
call
(
this
)
)
;
}
set
(
value
)
{
redefine
(
this
value
)
;
}
}
)
;
}
function
findPathInObject
(
obj
path
printErrors
=
true
)
{
let
parent
;
for
(
let
elt
of
path
.
split
(
"
.
"
)
)
{
if
(
!
obj
|
|
!
(
elt
in
obj
)
)
{
if
(
printErrors
)
{
Cu
.
reportError
(
WebExtension
API
{
path
}
not
found
(
it
may
be
unimplemented
by
Firefox
)
.
)
;
}
return
null
;
}
parent
=
obj
;
obj
=
obj
[
elt
]
;
}
if
(
typeof
obj
=
=
=
"
function
"
)
{
return
obj
.
bind
(
parent
)
;
}
return
obj
;
}
class
MessageManagerProxy
{
constructor
(
target
)
{
this
.
listeners
=
new
DefaultMap
(
(
)
=
>
new
Map
(
)
)
;
if
(
target
instanceof
Ci
.
nsIMessageSender
)
{
Object
.
defineProperty
(
this
"
messageManager
"
{
value
:
target
configurable
:
true
writable
:
true
}
)
;
}
else
{
this
.
addListeners
(
target
)
;
}
}
dispose
(
)
{
if
(
this
.
eventTarget
)
{
this
.
removeListeners
(
this
.
eventTarget
)
;
this
.
eventTarget
=
null
;
}
else
{
this
.
messageManager
=
null
;
}
}
static
matches
(
target
messageManager
)
{
return
target
=
=
=
messageManager
|
|
target
.
messageManager
=
=
=
messageManager
;
}
get
messageManager
(
)
{
return
this
.
eventTarget
&
&
this
.
eventTarget
.
messageManager
;
}
sendAsyncMessage
(
.
.
.
args
)
{
if
(
this
.
messageManager
)
{
return
this
.
messageManager
.
sendAsyncMessage
(
.
.
.
args
)
;
}
Cu
.
reportError
(
Cannot
send
message
:
Other
side
disconnected
:
{
uneval
(
args
)
}
)
;
}
get
isDisconnected
(
)
{
return
!
this
.
messageManager
;
}
addMessageListener
(
message
listener
listenWhenClosed
=
false
)
{
this
.
messageManager
.
addMessageListener
(
message
listener
listenWhenClosed
)
;
this
.
listeners
.
get
(
message
)
.
set
(
listener
listenWhenClosed
)
;
}
removeMessageListener
(
message
listener
)
{
this
.
messageManager
.
removeMessageListener
(
message
listener
)
;
let
listeners
=
this
.
listeners
.
get
(
message
)
;
listeners
.
delete
(
listener
)
;
if
(
!
listeners
.
size
)
{
this
.
listeners
.
delete
(
message
)
;
}
}
*
iterListeners
(
)
{
for
(
let
[
message
listeners
]
of
this
.
listeners
)
{
for
(
let
[
listener
listenWhenClosed
]
of
listeners
)
{
yield
{
message
listener
listenWhenClosed
}
;
}
}
}
addListeners
(
target
)
{
target
.
addEventListener
(
"
SwapDocShells
"
this
)
;
for
(
let
{
message
listener
listenWhenClosed
}
of
this
.
iterListeners
(
)
)
{
target
.
addMessageListener
(
message
listener
listenWhenClosed
)
;
}
this
.
eventTarget
=
target
;
}
removeListeners
(
target
)
{
target
.
removeEventListener
(
"
SwapDocShells
"
this
)
;
for
(
let
{
message
listener
}
of
this
.
iterListeners
(
)
)
{
target
.
removeMessageListener
(
message
listener
)
;
}
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
SwapDocShells
"
)
{
this
.
removeListeners
(
this
.
eventTarget
)
;
this
.
addListeners
(
event
.
detail
)
;
}
}
}
function
classifyPermission
(
perm
)
{
let
match
=
/
^
(
\
w
+
)
(
?
:
\
.
(
\
w
+
)
(
?
:
\
.
\
w
+
)
*
)
?
/
.
exec
(
perm
)
;
if
(
!
match
)
{
return
{
origin
:
perm
}
;
}
else
if
(
match
[
1
]
=
=
"
experiments
"
&
&
match
[
2
]
)
{
return
{
api
:
match
[
2
]
}
;
}
return
{
permission
:
perm
}
;
}
this
.
ExtensionUtils
=
{
classifyPermission
defineLazyGetter
extend
findPathInObject
flushJarCache
getConsole
getInnerWindowID
getMessageManager
getUniqueId
filterStack
getWinUtils
ignoreEvent
injectAPI
instanceOf
normalizeTime
promiseDocumentLoaded
promiseDocumentReady
promiseEvent
promiseObserved
runSafe
runSafeSync
runSafeSyncWithoutClone
runSafeWithoutClone
stylesheetMap
DefaultMap
DefaultWeakMap
EventEmitter
ExtensionError
IconDetails
LimitedSet
MessageManagerProxy
SpreadArgs
StartupCache
}
;
XPCOMUtils
.
defineLazyGetter
(
this
.
ExtensionUtils
"
PlatformInfo
"
PlatformInfo
)
;
