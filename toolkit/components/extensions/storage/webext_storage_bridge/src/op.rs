use
std
:
:
{
borrow
:
:
Borrow
fmt
:
:
Write
mem
result
str
sync
:
:
{
Arc
Weak
}
}
;
use
atomic_refcell
:
:
AtomicRefCell
;
use
moz_task
:
:
{
Task
ThreadPtrHandle
ThreadPtrHolder
}
;
use
nserror
:
:
nsresult
;
use
nsstring
:
:
nsCString
;
use
serde
:
:
Serialize
;
use
serde_json
:
:
Value
as
JsonValue
;
use
storage_variant
:
:
VariantType
;
use
xpcom
:
:
{
interfaces
:
:
{
mozIExtensionStorageCallback
mozIExtensionStorageListener
}
RefPtr
XpCom
}
;
use
crate
:
:
error
:
:
{
Error
Result
}
;
use
crate
:
:
store
:
:
LazyStore
;
pub
enum
StorageOp
{
Get
{
ext_id
:
String
keys
:
JsonValue
}
Set
{
ext_id
:
String
value
:
JsonValue
}
Remove
{
ext_id
:
String
keys
:
JsonValue
}
Clear
{
ext_id
:
String
}
}
impl
StorageOp
{
pub
fn
name
(
&
self
)
-
>
&
'
static
str
{
match
self
{
StorageOp
:
:
Get
{
.
.
}
=
>
"
webext_storage
:
:
get
"
StorageOp
:
:
Set
{
.
.
}
=
>
"
webext_storage
:
:
set
"
StorageOp
:
:
Remove
{
.
.
}
=
>
"
webext_storage
:
:
remove
"
StorageOp
:
:
Clear
{
.
.
}
=
>
"
webext_storage
:
:
clear
"
}
}
}
#
[
derive
(
Default
)
]
pub
struct
StorageResult
{
pub
changes
:
Option
<
String
>
pub
value
:
Option
<
String
>
}
impl
StorageResult
{
pub
fn
with_changes
<
T
:
Borrow
<
S
>
S
:
Serialize
>
(
changes
:
T
)
-
>
Result
<
Self
>
{
Ok
(
StorageResult
{
changes
:
Some
(
serde_json
:
:
to_string
(
changes
.
borrow
(
)
)
?
)
value
:
None
}
)
}
pub
fn
with_value
<
T
:
Borrow
<
S
>
S
:
Serialize
>
(
value
:
T
)
-
>
Result
<
Self
>
{
Ok
(
StorageResult
{
changes
:
None
value
:
Some
(
serde_json
:
:
to_string
(
value
.
borrow
(
)
)
?
)
}
)
}
}
pub
struct
StorageTask
{
name
:
&
'
static
str
store
:
Weak
<
LazyStore
>
op
:
AtomicRefCell
<
Option
<
StorageOp
>
>
callback
:
ThreadPtrHandle
<
mozIExtensionStorageCallback
>
result
:
AtomicRefCell
<
Result
<
StorageResult
>
>
}
impl
StorageTask
{
pub
fn
new
(
store
:
Weak
<
LazyStore
>
op
:
StorageOp
callback
:
&
mozIExtensionStorageCallback
)
-
>
Result
<
Self
>
{
let
name
=
op
.
name
(
)
;
Ok
(
Self
{
name
store
op
:
AtomicRefCell
:
:
new
(
Some
(
op
)
)
callback
:
ThreadPtrHolder
:
:
new
(
cstr
!
(
"
mozIExtensionStorageCallback
"
)
RefPtr
:
:
new
(
callback
)
)
?
result
:
AtomicRefCell
:
:
new
(
Err
(
Error
:
:
DidNotRun
(
name
)
)
)
}
)
}
fn
store
(
&
self
)
-
>
Result
<
Arc
<
LazyStore
>
>
{
match
self
.
store
.
upgrade
(
)
{
Some
(
store
)
=
>
Ok
(
store
)
None
=
>
Err
(
Error
:
:
AlreadyTornDown
)
}
}
fn
run_with_op
(
&
self
op
:
StorageOp
)
-
>
Result
<
StorageResult
>
{
Ok
(
match
op
{
StorageOp
:
:
Set
{
ext_id
value
}
=
>
{
StorageResult
:
:
with_changes
(
self
.
store
(
)
?
.
get
(
)
?
.
set
(
&
ext_id
value
)
?
)
}
StorageOp
:
:
Get
{
ext_id
keys
}
=
>
{
StorageResult
:
:
with_value
(
self
.
store
(
)
?
.
get
(
)
?
.
get
(
&
ext_id
keys
)
?
)
}
StorageOp
:
:
Remove
{
ext_id
keys
}
=
>
{
StorageResult
:
:
with_changes
(
self
.
store
(
)
?
.
get
(
)
?
.
remove
(
&
ext_id
keys
)
?
)
}
StorageOp
:
:
Clear
{
ext_id
}
=
>
{
StorageResult
:
:
with_changes
(
self
.
store
(
)
?
.
get
(
)
?
.
clear
(
&
ext_id
)
?
)
}
}
?
)
}
}
impl
Task
for
StorageTask
{
fn
run
(
&
self
)
{
*
self
.
result
.
borrow_mut
(
)
=
match
mem
:
:
take
(
&
mut
*
self
.
op
.
borrow_mut
(
)
)
{
Some
(
op
)
=
>
self
.
run_with_op
(
op
)
None
=
>
Err
(
Error
:
:
AlreadyRan
(
self
.
name
)
)
}
;
}
fn
done
(
&
self
)
-
>
result
:
:
Result
<
(
)
nsresult
>
{
let
callback
=
self
.
callback
.
get
(
)
.
unwrap
(
)
;
match
mem
:
:
replace
(
&
mut
*
self
.
result
.
borrow_mut
(
)
Err
(
Error
:
:
AlreadyRan
(
self
.
name
)
)
)
{
Ok
(
StorageResult
{
changes
value
}
)
=
>
{
if
let
(
Some
(
listener
)
Some
(
json
)
)
=
(
callback
.
query_interface
:
:
<
mozIExtensionStorageListener
>
(
)
changes
)
{
let
_
=
unsafe
{
listener
.
OnChanged
(
&
*
nsCString
:
:
from
(
json
)
)
}
;
}
let
result
=
value
.
map
(
nsCString
:
:
from
)
.
into_variant
(
)
;
unsafe
{
callback
.
HandleSuccess
(
result
.
coerce
(
)
)
}
}
Err
(
err
)
=
>
{
let
mut
message
=
nsCString
:
:
new
(
)
;
write
!
(
message
"
{
}
"
err
)
.
unwrap
(
)
;
unsafe
{
callback
.
HandleError
(
err
.
into
(
)
&
*
message
)
}
}
}
.
to_result
(
)
}
}
pub
struct
TeardownTask
{
store
:
AtomicRefCell
<
Option
<
Arc
<
LazyStore
>
>
>
callback
:
ThreadPtrHandle
<
mozIExtensionStorageCallback
>
result
:
AtomicRefCell
<
Result
<
(
)
>
>
}
impl
TeardownTask
{
pub
fn
new
(
store
:
Arc
<
LazyStore
>
callback
:
&
mozIExtensionStorageCallback
)
-
>
Result
<
Self
>
{
Ok
(
Self
{
store
:
AtomicRefCell
:
:
new
(
Some
(
store
)
)
callback
:
ThreadPtrHolder
:
:
new
(
cstr
!
(
"
mozIExtensionStorageCallback
"
)
RefPtr
:
:
new
(
callback
)
)
?
result
:
AtomicRefCell
:
:
new
(
Err
(
Error
:
:
DidNotRun
(
Self
:
:
name
(
)
)
)
)
}
)
}
pub
fn
name
(
)
-
>
&
'
static
str
{
"
webext_storage
:
:
teardown
"
}
fn
run_with_store
(
&
self
store
:
Arc
<
LazyStore
>
)
-
>
Result
<
(
)
>
{
match
Arc
:
:
try_unwrap
(
store
)
{
Ok
(
store
)
=
>
store
.
teardown
(
)
Err
(
_
)
=
>
{
Err
(
Error
:
:
DidNotRun
(
Self
:
:
name
(
)
)
)
}
}
}
}
impl
Task
for
TeardownTask
{
fn
run
(
&
self
)
{
*
self
.
result
.
borrow_mut
(
)
=
match
mem
:
:
take
(
&
mut
*
self
.
store
.
borrow_mut
(
)
)
{
Some
(
store
)
=
>
self
.
run_with_store
(
store
)
None
=
>
Err
(
Error
:
:
AlreadyRan
(
Self
:
:
name
(
)
)
)
}
;
}
fn
done
(
&
self
)
-
>
result
:
:
Result
<
(
)
nsresult
>
{
let
callback
=
self
.
callback
.
get
(
)
.
unwrap
(
)
;
match
mem
:
:
replace
(
&
mut
*
self
.
result
.
borrow_mut
(
)
Err
(
Error
:
:
AlreadyRan
(
Self
:
:
name
(
)
)
)
)
{
Ok
(
(
)
)
=
>
unsafe
{
callback
.
HandleSuccess
(
(
)
.
into_variant
(
)
.
coerce
(
)
)
}
Err
(
err
)
=
>
{
let
mut
message
=
nsCString
:
:
new
(
)
;
write
!
(
message
"
{
}
"
err
)
.
unwrap
(
)
;
unsafe
{
callback
.
HandleError
(
err
.
into
(
)
&
*
message
)
}
}
}
.
to_result
(
)
}
}
