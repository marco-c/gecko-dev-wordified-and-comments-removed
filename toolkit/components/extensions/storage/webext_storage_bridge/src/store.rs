use
std
:
:
{
fs
:
:
remove_file
mem
path
:
:
PathBuf
sync
:
:
{
Arc
Mutex
MutexGuard
}
}
;
use
golden_gate
:
:
{
ApplyResults
BridgedEngine
Guid
IncomingBso
}
;
use
interrupt_support
:
:
SqlInterruptHandle
;
use
once_cell
:
:
sync
:
:
OnceCell
;
use
webext_storage
:
:
store
:
:
Store
;
use
crate
:
:
error
:
:
{
Error
Result
}
;
pub
struct
LazyStoreConfig
{
pub
path
:
PathBuf
pub
kinto_path
:
PathBuf
}
#
[
derive
(
Default
)
]
pub
struct
LazyStore
{
store
:
OnceCell
<
InterruptStore
>
config
:
OnceCell
<
LazyStoreConfig
>
}
struct
InterruptStore
{
inner
:
Mutex
<
Store
>
handle
:
Arc
<
SqlInterruptHandle
>
}
impl
LazyStore
{
pub
fn
configure
(
&
self
config
:
LazyStoreConfig
)
-
>
Result
<
(
)
>
{
self
.
config
.
set
(
config
)
.
map_err
(
|
_
|
Error
:
:
AlreadyConfigured
)
}
pub
fn
interrupt
(
&
self
)
{
if
let
Some
(
outer
)
=
self
.
store
.
get
(
)
{
outer
.
handle
.
interrupt
(
)
;
}
}
pub
fn
get
(
&
self
)
-
>
Result
<
MutexGuard
<
'
_
Store
>
>
{
Ok
(
self
.
store
.
get_or_try_init
(
|
|
match
self
.
config
.
get
(
)
{
Some
(
config
)
=
>
{
let
store
=
init_store
(
config
)
?
;
let
handle
=
store
.
interrupt_handle
(
)
;
Ok
(
InterruptStore
{
inner
:
Mutex
:
:
new
(
store
)
handle
}
)
}
None
=
>
Err
(
Error
:
:
NotConfigured
)
}
)
?
.
inner
.
lock
(
)
.
unwrap
(
)
)
}
pub
fn
teardown
(
self
)
-
>
Result
<
(
)
>
{
if
let
Some
(
store
)
=
self
.
store
.
into_inner
(
)
.
map
(
|
outer
|
outer
.
inner
.
into_inner
(
)
.
unwrap
(
)
)
{
if
let
Err
(
(
store
error
)
)
=
store
.
close
(
)
{
mem
:
:
forget
(
store
)
;
return
Err
(
error
.
into
(
)
)
;
}
}
Ok
(
(
)
)
}
}
impl
BridgedEngine
for
LazyStore
{
type
Error
=
Error
;
fn
last_sync
(
&
self
)
-
>
Result
<
i64
>
{
Ok
(
self
.
get
(
)
?
.
bridged_engine
(
)
.
last_sync
(
)
?
)
}
fn
set_last_sync
(
&
self
last_sync_millis
:
i64
)
-
>
Result
<
(
)
>
{
Ok
(
self
.
get
(
)
?
.
bridged_engine
(
)
.
set_last_sync
(
last_sync_millis
)
?
)
}
fn
sync_id
(
&
self
)
-
>
Result
<
Option
<
String
>
>
{
Ok
(
self
.
get
(
)
?
.
bridged_engine
(
)
.
sync_id
(
)
?
)
}
fn
reset_sync_id
(
&
self
)
-
>
Result
<
String
>
{
Ok
(
self
.
get
(
)
?
.
bridged_engine
(
)
.
reset_sync_id
(
)
?
)
}
fn
ensure_current_sync_id
(
&
self
new_sync_id
:
&
str
)
-
>
Result
<
String
>
{
Ok
(
self
.
get
(
)
?
.
bridged_engine
(
)
.
ensure_current_sync_id
(
new_sync_id
)
?
)
}
fn
sync_started
(
&
self
)
-
>
Result
<
(
)
>
{
Ok
(
self
.
get
(
)
?
.
bridged_engine
(
)
.
sync_started
(
)
?
)
}
fn
store_incoming
(
&
self
envelopes
:
Vec
<
IncomingBso
>
)
-
>
Result
<
(
)
>
{
Ok
(
self
.
get
(
)
?
.
bridged_engine
(
)
.
store_incoming
(
envelopes
)
?
)
}
fn
apply
(
&
self
)
-
>
Result
<
ApplyResults
>
{
Ok
(
self
.
get
(
)
?
.
bridged_engine
(
)
.
apply
(
)
?
)
}
fn
set_uploaded
(
&
self
server_modified_millis
:
i64
ids
:
&
[
Guid
]
)
-
>
Result
<
(
)
>
{
Ok
(
self
.
get
(
)
?
.
bridged_engine
(
)
.
set_uploaded
(
server_modified_millis
ids
)
?
)
}
fn
sync_finished
(
&
self
)
-
>
Result
<
(
)
>
{
Ok
(
self
.
get
(
)
?
.
bridged_engine
(
)
.
sync_finished
(
)
?
)
}
fn
reset
(
&
self
)
-
>
Result
<
(
)
>
{
Ok
(
self
.
get
(
)
?
.
bridged_engine
(
)
.
reset
(
)
?
)
}
fn
wipe
(
&
self
)
-
>
Result
<
(
)
>
{
Ok
(
self
.
get
(
)
?
.
bridged_engine
(
)
.
wipe
(
)
?
)
}
}
fn
init_store
(
config
:
&
LazyStoreConfig
)
-
>
Result
<
Store
>
{
let
should_migrate
=
config
.
kinto_path
.
exists
(
)
&
&
!
config
.
path
.
exists
(
)
;
let
store
=
Store
:
:
new
(
&
config
.
path
)
?
;
if
should_migrate
{
match
store
.
migrate
(
&
config
.
kinto_path
)
{
Ok
(
(
)
)
=
>
{
println
!
(
"
extension
-
storage
:
migration
complete
"
)
;
Ok
(
store
)
}
Err
(
e
)
=
>
{
println
!
(
"
extension
-
storage
:
migration
failure
:
{
}
"
e
)
;
if
let
Err
(
(
store
e
)
)
=
store
.
close
(
)
{
println
!
(
"
extension
-
storage
:
failed
to
close
the
store
after
migration
failure
:
{
}
"
e
)
;
mem
:
:
drop
(
store
)
;
}
if
let
Err
(
e
)
=
remove_file
(
&
config
.
path
)
{
println
!
(
"
Failed
to
remove
file
after
failed
migration
:
{
}
"
e
)
;
}
Err
(
Error
:
:
MigrationFailed
(
e
)
)
}
}
}
else
{
Ok
(
store
)
}
}
