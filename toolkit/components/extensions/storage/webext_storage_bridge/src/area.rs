use
std
:
:
{
cell
:
:
{
Ref
RefCell
}
ffi
:
:
OsString
mem
str
sync
:
:
Arc
}
;
use
moz_task
:
:
{
self
DispatchOptions
TaskRunnable
}
;
use
nserror
:
:
{
nsresult
NS_OK
}
;
use
nsstring
:
:
{
nsACString
nsString
}
;
use
xpcom
:
:
{
interfaces
:
:
{
mozIExtensionStorageCallback
nsIFile
nsISerialEventTarget
}
RefPtr
}
;
use
crate
:
:
error
:
:
{
Error
Result
}
;
use
crate
:
:
op
:
:
{
StorageOp
StorageTask
TeardownTask
}
;
use
crate
:
:
store
:
:
{
LazyStore
LazyStoreConfig
}
;
#
[
derive
(
xpcom
)
]
#
[
xpimplements
(
mozIConfigurableExtensionStorageArea
mozIInterruptible
)
]
#
[
refcnt
=
"
nonatomic
"
]
pub
struct
InitStorageSyncArea
{
queue
:
RefPtr
<
nsISerialEventTarget
>
store
:
RefCell
<
Option
<
Arc
<
LazyStore
>
>
>
}
impl
StorageSyncArea
{
pub
fn
new
(
)
-
>
Result
<
RefPtr
<
StorageSyncArea
>
>
{
let
queue
=
moz_task
:
:
create_background_task_queue
(
cstr
!
(
"
StorageSyncArea
"
)
)
?
;
Ok
(
StorageSyncArea
:
:
allocate
(
InitStorageSyncArea
{
queue
store
:
RefCell
:
:
new
(
Some
(
Arc
:
:
default
(
)
)
)
}
)
)
}
fn
store
(
&
self
)
-
>
Result
<
Ref
<
'
_
Arc
<
LazyStore
>
>
>
{
let
maybe_store
=
self
.
store
.
borrow
(
)
;
if
maybe_store
.
is_some
(
)
{
Ok
(
Ref
:
:
map
(
maybe_store
|
s
|
s
.
as_ref
(
)
.
unwrap
(
)
)
)
}
else
{
Err
(
Error
:
:
AlreadyTornDown
)
}
}
fn
dispatch
(
&
self
op
:
StorageOp
callback
:
&
mozIExtensionStorageCallback
)
-
>
Result
<
(
)
>
{
let
name
=
op
.
name
(
)
;
let
task
=
StorageTask
:
:
new
(
Arc
:
:
downgrade
(
&
*
self
.
store
(
)
?
)
op
callback
)
?
;
let
runnable
=
TaskRunnable
:
:
new
(
name
Box
:
:
new
(
task
)
)
?
;
runnable
.
dispatch_with_options
(
self
.
queue
.
coerce
(
)
DispatchOptions
:
:
new
(
)
.
may_block
(
true
)
)
?
;
Ok
(
(
)
)
}
xpcom_method
!
(
configure
=
>
Configure
(
database_file
:
*
const
nsIFile
)
)
;
fn
configure
(
&
self
database_file
:
&
nsIFile
)
-
>
Result
<
(
)
>
{
let
mut
raw_path
=
nsString
:
:
new
(
)
;
unsafe
{
database_file
.
GetPath
(
&
mut
*
raw_path
)
}
.
to_result
(
)
?
;
let
native_path
=
{
#
[
cfg
(
windows
)
]
{
use
std
:
:
os
:
:
windows
:
:
prelude
:
:
*
;
OsString
:
:
from_wide
(
&
*
raw_path
)
}
#
[
cfg
(
not
(
windows
)
)
]
OsString
:
:
from
(
String
:
:
from_utf16
(
&
*
raw_path
)
?
)
}
;
self
.
store
(
)
?
.
configure
(
LazyStoreConfig
{
path
:
native_path
.
into
(
)
}
)
?
;
Ok
(
(
)
)
}
xpcom_method
!
(
set
=
>
Set
(
ext_id
:
*
const
:
:
nsstring
:
:
nsACString
json
:
*
const
:
:
nsstring
:
:
nsACString
callback
:
*
const
mozIExtensionStorageCallback
)
)
;
fn
set
(
&
self
ext_id
:
&
nsACString
json
:
&
nsACString
callback
:
&
mozIExtensionStorageCallback
)
-
>
Result
<
(
)
>
{
self
.
dispatch
(
StorageOp
:
:
Set
{
ext_id
:
str
:
:
from_utf8
(
&
*
ext_id
)
?
.
into
(
)
value
:
serde_json
:
:
from_str
(
str
:
:
from_utf8
(
&
*
json
)
?
)
?
}
callback
)
?
;
Ok
(
(
)
)
}
xpcom_method
!
(
get
=
>
Get
(
ext_id
:
*
const
:
:
nsstring
:
:
nsACString
json
:
*
const
:
:
nsstring
:
:
nsACString
callback
:
*
const
mozIExtensionStorageCallback
)
)
;
fn
get
(
&
self
ext_id
:
&
nsACString
json
:
&
nsACString
callback
:
&
mozIExtensionStorageCallback
)
-
>
Result
<
(
)
>
{
self
.
dispatch
(
StorageOp
:
:
Get
{
ext_id
:
str
:
:
from_utf8
(
&
*
ext_id
)
?
.
into
(
)
keys
:
serde_json
:
:
from_str
(
str
:
:
from_utf8
(
&
*
json
)
?
)
?
}
callback
)
}
xpcom_method
!
(
remove
=
>
Remove
(
ext_id
:
*
const
:
:
nsstring
:
:
nsACString
json
:
*
const
:
:
nsstring
:
:
nsACString
callback
:
*
const
mozIExtensionStorageCallback
)
)
;
fn
remove
(
&
self
ext_id
:
&
nsACString
json
:
&
nsACString
callback
:
&
mozIExtensionStorageCallback
)
-
>
Result
<
(
)
>
{
self
.
dispatch
(
StorageOp
:
:
Remove
{
ext_id
:
str
:
:
from_utf8
(
&
*
ext_id
)
?
.
into
(
)
keys
:
serde_json
:
:
from_str
(
str
:
:
from_utf8
(
&
*
json
)
?
)
?
}
callback
)
}
xpcom_method
!
(
clear
=
>
Clear
(
ext_id
:
*
const
:
:
nsstring
:
:
nsACString
callback
:
*
const
mozIExtensionStorageCallback
)
)
;
fn
clear
(
&
self
ext_id
:
&
nsACString
callback
:
&
mozIExtensionStorageCallback
)
-
>
Result
<
(
)
>
{
self
.
dispatch
(
StorageOp
:
:
Clear
{
ext_id
:
str
:
:
from_utf8
(
&
*
ext_id
)
?
.
into
(
)
}
callback
)
}
xpcom_method
!
(
wipe_all
=
>
WipeAll
(
callback
:
*
const
mozIExtensionStorageCallback
)
)
;
fn
wipe_all
(
&
self
callback
:
&
mozIExtensionStorageCallback
)
-
>
Result
<
(
)
>
{
self
.
dispatch
(
StorageOp
:
:
WipeAll
callback
)
}
xpcom_method
!
(
teardown
=
>
Teardown
(
callback
:
*
const
mozIExtensionStorageCallback
)
)
;
fn
teardown
(
&
self
callback
:
&
mozIExtensionStorageCallback
)
-
>
Result
<
(
)
>
{
let
mut
maybe_store
=
self
.
store
.
borrow_mut
(
)
;
match
mem
:
:
take
(
&
mut
*
maybe_store
)
{
Some
(
store
)
=
>
{
store
.
interrupt
(
)
;
teardown
(
&
self
.
queue
store
callback
)
?
;
}
None
=
>
return
Err
(
Error
:
:
AlreadyTornDown
)
}
Ok
(
(
)
)
}
}
fn
teardown
(
queue
:
&
nsISerialEventTarget
store
:
Arc
<
LazyStore
>
callback
:
&
mozIExtensionStorageCallback
)
-
>
Result
<
(
)
>
{
let
task
=
TeardownTask
:
:
new
(
store
callback
)
?
;
let
runnable
=
TaskRunnable
:
:
new
(
TeardownTask
:
:
name
(
)
Box
:
:
new
(
task
)
)
?
;
runnable
.
dispatch_with_options
(
queue
.
coerce
(
)
DispatchOptions
:
:
new
(
)
.
may_block
(
true
)
)
?
;
Ok
(
(
)
)
}
impl
StorageSyncArea
{
xpcom_method
!
(
interrupt
=
>
Interrupt
(
)
)
;
fn
interrupt
(
&
self
)
-
>
Result
<
(
)
>
{
self
.
store
(
)
?
.
interrupt
(
)
;
Ok
(
(
)
)
}
}
