"
use
strict
"
;
const
{
PerformanceStats
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PerformanceStats
.
jsm
"
{
}
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
;
const
{
ObjectUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
{
}
)
;
const
{
ExtensionParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
{
}
)
;
const
{
WebExtensionPolicy
}
=
Cu
.
getGlobalForObject
(
Services
)
;
const
TEST_DRIVER_TOPIC
=
"
test
-
about
:
performance
-
test
-
driver
"
;
const
UPDATE_COMPLETE_TOPIC
=
"
about
:
performance
-
update
-
complete
"
;
const
BUFFER_SAMPLING_RATE_MS
=
1000
;
const
BUFFER_DURATION_MS
=
10000
;
const
UPDATE_INTERVAL_MS
=
2000
;
const
BRAND_BUNDLE
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
const
BRAND_NAME
=
BRAND_BUNDLE
.
GetStringFromName
(
"
brandShortName
"
)
;
const
MAX_NUMBER_OF_ITEMS_TO_DISPLAY
=
3
;
const
MAX_FREQUENCY_FOR_NO_IMPACT
=
.
05
;
const
MAX_FREQUENCY_FOR_RARE
=
.
1
;
const
MAX_FREQUENCY_FOR_FREQUENT
=
.
5
;
const
MIN_PROPORTION_FOR_MAJOR_IMPACT
=
.
05
;
const
MIN_PROPORTION_FOR_NOTICEABLE_IMPACT
=
.
1
;
const
MODE_GLOBAL
=
"
global
"
;
const
MODE_RECENT
=
"
recent
"
;
function
performanceCountersEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
dom
.
performance
.
enable_scheduler_timing
"
false
)
;
}
function
extensionCountersEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
extensions
.
webextensions
.
enablePerformanceCounters
"
false
)
;
}
let
tabFinder
=
{
update
(
)
{
this
.
_map
=
new
Map
(
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
let
tabbrowser
=
win
.
gBrowser
;
for
(
let
browser
of
tabbrowser
.
browsers
)
{
let
id
=
browser
.
outerWindowID
;
if
(
id
!
=
null
)
{
this
.
_map
.
set
(
id
browser
)
;
}
}
if
(
tabbrowser
.
_preloadedBrowser
)
{
let
browser
=
tabbrowser
.
_preloadedBrowser
;
if
(
browser
.
outerWindowID
)
this
.
_map
.
set
(
browser
.
outerWindowID
browser
)
;
}
}
}
get
(
id
)
{
let
browser
=
this
.
_map
.
get
(
id
)
;
if
(
!
browser
)
{
return
null
;
}
let
tabbrowser
=
browser
.
getTabBrowser
(
)
;
if
(
!
tabbrowser
)
return
{
tabbrowser
:
null
tab
:
{
getAttribute
(
)
{
return
"
"
;
}
linkedBrowser
:
browser
}
}
;
return
{
tabbrowser
tab
:
tabbrowser
.
getTabForBrowser
(
browser
)
}
;
}
getAny
(
ids
)
{
for
(
let
id
of
ids
)
{
let
result
=
this
.
get
(
id
)
;
if
(
result
)
{
return
result
;
}
}
return
null
;
}
}
;
function
wait
(
ms
=
0
)
{
try
{
let
resolve
;
let
p
=
new
Promise
(
resolve_
=
>
{
resolve
=
resolve_
;
}
)
;
setTimeout
(
resolve
ms
)
;
return
p
;
}
catch
(
e
)
{
dump
(
"
WARNING
:
wait
aborted
because
of
an
invalid
Window
state
in
aboutPerformance
.
js
.
\
n
"
)
;
return
undefined
;
}
}
function
Delta
(
diff
kind
snapshotDate
ageMap
alertMap
)
{
if
(
kind
!
=
"
webpages
"
)
{
throw
new
TypeError
(
Unknown
kind
:
{
kind
}
)
;
}
this
.
kind
=
kind
;
this
.
diff
=
diff
;
this
.
key
=
kind
+
diff
.
key
;
let
creationDate
=
snapshotDate
;
for
(
let
groupId
of
diff
.
groupIds
)
{
let
date
=
ageMap
.
get
(
groupId
)
;
if
(
date
&
&
date
<
=
creationDate
)
{
creationDate
=
date
;
}
}
this
.
creationDate
=
creationDate
;
this
.
age
=
snapshotDate
-
creationDate
;
this
.
readableName
=
null
;
this
.
fullName
=
null
;
this
.
_initialized
=
false
;
this
.
_show
=
false
;
this
.
alerts
=
(
alertMap
.
get
(
this
.
key
)
|
|
[
]
)
.
slice
(
)
;
switch
(
this
.
slowness
)
{
case
0
:
break
;
case
1
:
this
.
alerts
[
0
]
=
(
this
.
alerts
[
0
]
|
|
0
)
+
1
;
break
;
case
2
:
this
.
alerts
[
1
]
=
(
this
.
alerts
[
1
]
|
|
0
)
+
1
;
break
;
default
:
throw
new
Error
(
)
;
}
}
Delta
.
prototype
=
{
get
show
(
)
{
this
.
_ensureInitialized
(
)
;
return
this
.
_show
;
}
get
slowness
(
)
{
if
(
Delta
.
compare
(
this
Delta
.
MAX_DELTA_FOR_GOOD_RECENT_PERFORMANCE
)
<
=
0
)
{
return
0
;
}
if
(
Delta
.
compare
(
this
Delta
.
MAX_DELTA_FOR_AVERAGE_RECENT_PERFORMANCE
)
<
=
0
)
{
return
1
;
}
return
2
;
}
_ensureInitialized
(
)
{
if
(
!
this
.
_initialized
)
{
throw
new
Error
(
)
;
}
}
promiseInit
(
)
{
if
(
this
.
kind
=
=
"
webpages
"
)
{
return
this
.
_initWebpage
(
)
;
}
throw
new
TypeError
(
)
;
}
_initWebpage
(
)
{
this
.
_initialized
=
true
;
let
found
=
tabFinder
.
getAny
(
this
.
diff
.
windowIds
)
;
if
(
!
found
|
|
found
.
tab
.
linkedBrowser
.
contentTitle
=
=
null
)
{
return
;
}
this
.
readableName
=
found
.
tab
.
linkedBrowser
.
contentTitle
;
this
.
fullName
=
this
.
diff
.
names
.
join
(
"
"
)
;
this
.
_show
=
true
;
}
toString
(
)
{
return
[
Delta
]
{
this
.
diff
.
key
}
=
>
{
this
.
readableName
}
{
this
.
fullName
}
;
}
}
;
Delta
.
compare
=
function
(
a
b
)
{
return
(
(
a
.
diff
.
jank
.
longestDuration
-
b
.
diff
.
jank
.
longestDuration
)
|
|
(
a
.
diff
.
jank
.
totalUserTime
-
b
.
diff
.
jank
.
totalUserTime
)
|
|
(
a
.
diff
.
jank
.
totalSystemTime
-
b
.
diff
.
jank
.
totalSystemTime
)
|
|
(
a
.
diff
.
cpow
.
totalCPOWTime
-
b
.
diff
.
cpow
.
totalCPOWTime
)
|
|
(
a
.
diff
.
ticks
.
ticks
-
b
.
diff
.
ticks
.
ticks
)
|
|
0
)
;
}
;
Delta
.
revCompare
=
function
(
a
b
)
{
return
-
Delta
.
compare
(
a
b
)
;
}
;
Delta
.
MAX_DELTA_FOR_GOOD_RECENT_PERFORMANCE
=
{
diff
:
{
cpow
:
{
totalCPOWTime
:
0
}
jank
:
{
longestDuration
:
3
totalUserTime
:
Number
.
POSITIVE_INFINITY
totalSystemTime
:
Number
.
POSITIVE_INFINITY
}
ticks
:
{
ticks
:
Number
.
POSITIVE_INFINITY
}
}
}
;
Delta
.
MAX_DELTA_FOR_AVERAGE_RECENT_PERFORMANCE
=
{
diff
:
{
cpow
:
{
totalCPOWTime
:
Number
.
POSITIVE_INFINITY
}
jank
:
{
longestDuration
:
7
totalUserTime
:
Number
.
POSITIVE_INFINITY
totalSystemTime
:
Number
.
POSITIVE_INFINITY
}
ticks
:
{
ticks
:
Number
.
POSITIVE_INFINITY
}
}
}
;
var
State
=
{
_monitor
:
PerformanceStats
.
getMonitor
(
[
"
jank
"
"
cpow
"
"
ticks
"
]
)
_buffer
:
[
]
_oldest
:
null
_latest
:
null
_alerts
:
new
Map
(
)
_firstSeen
:
new
Map
(
)
async
_promiseSnapshot
(
)
{
if
(
!
performanceCountersEnabled
(
)
)
{
return
this
.
_monitor
.
promiseSnapshot
(
)
;
}
let
addons
=
WebExtensionPolicy
.
getActiveExtensions
(
)
;
let
addonHosts
=
new
Map
(
)
;
for
(
let
addon
of
addons
)
addonHosts
.
set
(
addon
.
mozExtensionHostname
addon
.
id
)
;
let
counters
=
await
ChromeUtils
.
requestPerformanceMetrics
(
)
;
let
tabs
=
{
}
;
for
(
let
counter
of
counters
)
{
let
{
items
host
windowId
duration
isWorker
isTopLevel
}
=
counter
;
if
(
isWorker
&
&
(
windowId
=
=
18446744073709552000
|
|
!
windowId
)
)
windowId
=
1
;
let
dispatchCount
=
0
;
for
(
let
{
count
}
of
items
)
{
dispatchCount
+
=
count
;
}
let
tab
;
let
id
=
windowId
;
if
(
addonHosts
.
has
(
host
)
)
{
id
=
addonHosts
.
get
(
host
)
;
}
if
(
id
in
tabs
)
{
tab
=
tabs
[
id
]
;
}
else
{
tab
=
{
windowId
host
dispatchCount
:
0
duration
:
0
children
:
[
]
}
;
tabs
[
id
]
=
tab
;
}
tab
.
dispatchCount
+
=
dispatchCount
;
tab
.
duration
+
=
duration
;
if
(
!
isTopLevel
)
{
tab
.
children
.
push
(
{
host
isWorker
dispatchCount
duration
}
)
;
}
}
if
(
extensionCountersEnabled
(
)
)
{
let
extCounters
=
await
ExtensionParent
.
ParentAPIManager
.
retrievePerformanceCounters
(
)
;
for
(
let
[
id
apiMap
]
of
extCounters
)
{
let
dispatchCount
=
0
duration
=
0
;
for
(
let
[
counter
]
of
apiMap
)
{
dispatchCount
+
=
counter
.
calls
;
duration
+
=
counter
.
duration
;
}
let
tab
;
if
(
id
in
tabs
)
{
tab
=
tabs
[
id
]
;
}
else
{
tab
=
{
windowId
:
0
host
:
id
dispatchCount
:
0
duration
:
0
children
:
[
]
}
;
tabs
[
id
]
=
tab
;
}
tab
.
dispatchCount
+
=
dispatchCount
;
tab
.
duration
+
=
duration
;
}
}
return
{
tabs
date
:
Cu
.
now
(
)
}
;
}
async
update
(
)
{
if
(
this
.
_buffer
.
length
=
=
0
)
{
if
(
this
.
_oldest
)
{
throw
new
Error
(
"
Internal
Error
we
shouldn
'
t
have
a
_oldest
value
yet
.
"
)
;
}
this
.
_latest
=
this
.
_oldest
=
await
this
.
_promiseSnapshot
(
)
;
this
.
_buffer
.
push
(
this
.
_oldest
)
;
await
wait
(
BUFFER_SAMPLING_RATE_MS
*
1
.
1
)
;
}
let
now
=
Cu
.
now
(
)
;
let
latestInBuffer
=
this
.
_buffer
[
this
.
_buffer
.
length
-
1
]
;
let
deltaT
=
now
-
latestInBuffer
.
date
;
if
(
deltaT
>
BUFFER_SAMPLING_RATE_MS
)
{
this
.
_latest
=
await
this
.
_promiseSnapshot
(
)
;
this
.
_buffer
.
push
(
this
.
_latest
)
;
}
let
oldestInBuffer
=
this
.
_buffer
[
0
]
;
if
(
oldestInBuffer
.
date
+
BUFFER_DURATION_MS
<
this
.
_latest
.
date
)
{
this
.
_buffer
.
shift
(
)
;
}
}
promiseDeltaSinceStartOfTime
(
)
{
return
this
.
_promiseDeltaSince
(
this
.
_oldest
)
;
}
promiseDeltaSinceStartOfBuffer
(
)
{
return
this
.
_promiseDeltaSince
(
this
.
_buffer
[
0
]
)
;
}
async
_promiseDeltaSince
(
oldest
)
{
let
current
=
this
.
_latest
;
if
(
!
oldest
)
{
throw
new
TypeError
(
)
;
}
if
(
!
current
)
{
throw
new
TypeError
(
)
;
}
tabFinder
.
update
(
)
;
let
oldFirstSeen
=
this
.
_firstSeen
;
let
cleanedUpFirstSeen
=
new
Map
(
)
;
let
oldAlerts
=
this
.
_alerts
;
let
cleanedUpAlerts
=
new
Map
(
)
;
let
result
=
{
webpages
:
[
]
deltas
:
new
Set
(
)
duration
:
current
.
date
-
oldest
.
date
}
;
for
(
let
kind
of
[
"
webpages
"
]
)
{
for
(
let
[
key
value
]
of
current
[
kind
]
)
{
let
item
=
ObjectUtils
.
strict
(
new
Delta
(
value
.
subtract
(
oldest
[
kind
]
.
get
(
key
)
)
kind
current
.
date
oldFirstSeen
oldAlerts
)
)
;
await
item
.
promiseInit
(
)
;
if
(
!
item
.
show
)
{
continue
;
}
result
[
kind
]
.
push
(
item
)
;
result
.
deltas
.
add
(
item
.
key
)
;
for
(
let
groupId
of
item
.
diff
.
groupIds
)
{
cleanedUpFirstSeen
.
set
(
groupId
item
.
creationDate
)
;
}
cleanedUpAlerts
.
set
(
item
.
key
item
.
alerts
)
;
}
}
this
.
_firstSeen
=
cleanedUpFirstSeen
;
this
.
_alerts
=
cleanedUpAlerts
;
return
result
;
}
_trackingState
:
new
Map
(
)
isTracker
(
host
)
{
if
(
!
this
.
_trackingState
.
has
(
host
)
)
{
this
.
_trackingState
.
set
(
host
false
)
;
if
(
host
.
startsWith
(
"
about
:
"
)
|
|
host
.
startsWith
(
"
moz
-
nullprincipal
"
)
)
return
false
;
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
"
http
:
/
/
"
+
host
)
;
let
classifier
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
dbservice
;
1
"
]
.
getService
(
Ci
.
nsIURIClassifier
)
;
classifier
.
classify
(
principal
null
true
(
aErrorCode
aList
aProvider
aFullHash
)
=
>
{
this
.
_trackingState
.
set
(
host
aErrorCode
=
=
Cr
.
NS_ERROR_TRACKING_URI
)
;
}
)
;
}
return
this
.
_trackingState
.
get
(
host
)
;
}
getCounters
(
)
{
tabFinder
.
update
(
)
;
let
oldestInBuffer
=
this
.
_buffer
[
0
]
.
tabs
;
let
previous
=
this
.
_buffer
[
Math
.
max
(
this
.
_buffer
.
length
-
2
0
)
]
.
tabs
;
let
current
=
this
.
_latest
.
tabs
;
return
Object
.
keys
(
current
)
.
map
(
function
(
id
)
{
let
tab
=
current
[
id
]
;
let
oldest
=
oldestInBuffer
[
id
]
;
let
prev
=
previous
[
id
]
;
let
dispatches
=
tab
.
dispatchCount
;
let
host
=
tab
.
host
;
let
name
=
{
host
}
(
{
id
}
)
;
let
image
=
"
chrome
:
/
/
mozapps
/
skin
/
places
/
defaultFavicon
.
svg
"
;
let
found
=
tabFinder
.
get
(
parseInt
(
id
)
)
;
if
(
found
)
{
if
(
found
.
tabbrowser
)
{
name
=
found
.
tab
.
getAttribute
(
"
label
"
)
;
image
=
found
.
tab
.
getAttribute
(
"
image
"
)
;
}
else
{
name
=
"
Preloaded
:
"
+
found
.
tab
.
linkedBrowser
.
contentTitle
;
}
}
else
if
(
id
=
=
1
)
{
name
=
BRAND_NAME
;
image
=
"
chrome
:
/
/
branding
/
content
/
icon32
.
png
"
;
}
else
if
(
/
^
[
a
-
f0
-
9
]
{
8
}
(
-
[
a
-
f0
-
9
]
{
4
}
)
{
3
}
-
[
a
-
f0
-
9
]
{
12
}
/
.
test
(
host
)
)
{
let
addon
=
WebExtensionPolicy
.
getByHostname
(
host
)
;
name
=
{
addon
.
name
}
(
{
addon
.
id
}
)
;
image
=
"
chrome
:
/
/
mozapps
/
skin
/
extensions
/
extensionGeneric
-
16
.
svg
"
;
}
else
if
(
id
=
=
0
&
&
!
tab
.
isWorker
)
{
name
=
"
Ghost
windows
"
;
}
return
(
{
id
name
image
totalDispatches
:
dispatches
totalDuration
:
tab
.
duration
durationSincePrevious
:
prev
?
tab
.
duration
-
prev
.
duration
:
NaN
dispatchesSincePrevious
:
prev
?
dispatches
-
prev
.
dispatchCount
:
NaN
dispatchesSinceStartOfBuffer
:
oldest
?
dispatches
-
oldest
.
dispatchCount
:
NaN
children
:
tab
.
children
}
)
;
}
)
;
}
}
;
var
View
=
{
DOMCache
:
{
_map
:
new
Map
(
)
get
(
deltaKey
)
{
return
this
.
_map
.
get
(
deltaKey
)
;
}
set
(
deltaKey
value
)
{
this
.
_map
.
set
(
deltaKey
value
)
;
}
trimTo
(
set
)
{
let
remove
=
[
]
;
for
(
let
key
of
this
.
_map
.
keys
(
)
)
{
if
(
!
set
.
has
(
key
)
)
{
remove
.
push
(
key
)
;
}
}
for
(
let
key
of
remove
)
{
this
.
_map
.
delete
(
key
)
;
}
}
}
updateCategory
(
subset
id
nature
currentMode
)
{
subset
=
subset
.
slice
(
)
.
sort
(
Delta
.
revCompare
)
;
this
.
_setupStructure
(
id
)
;
let
toAdd
=
[
]
;
for
(
let
delta
of
subset
)
{
if
(
!
(
delta
instanceof
Delta
)
)
{
throw
new
TypeError
(
)
;
}
let
cachedElements
=
this
.
_grabOrCreateElements
(
delta
nature
)
;
toAdd
.
push
(
cachedElements
)
;
cachedElements
.
eltTitle
.
textContent
=
delta
.
readableName
;
cachedElements
.
eltName
.
textContent
=
Full
name
:
{
delta
.
fullName
}
.
;
cachedElements
.
eltLoaded
.
textContent
=
Measure
start
:
{
Math
.
round
(
delta
.
age
/
1000
)
}
seconds
ago
.
;
let
processes
=
delta
.
diff
.
processes
.
map
(
proc
=
>
{
proc
.
processId
}
(
{
proc
.
isChildProcess
?
"
child
"
:
"
parent
"
}
)
)
;
cachedElements
.
eltProcess
.
textContent
=
Processes
:
{
processes
.
join
(
"
"
)
}
;
let
eltImpact
=
cachedElements
.
eltImpact
;
if
(
currentMode
=
=
MODE_RECENT
)
{
cachedElements
.
eltRoot
.
setAttribute
(
"
impact
"
delta
.
diff
.
jank
.
longestDuration
+
1
)
;
if
(
Delta
.
compare
(
delta
Delta
.
MAX_DELTA_FOR_GOOD_RECENT_PERFORMANCE
)
<
=
0
)
{
eltImpact
.
textContent
=
currently
performs
well
.
;
}
else
if
(
Delta
.
compare
(
delta
Delta
.
MAX_DELTA_FOR_AVERAGE_RECENT_PERFORMANCE
)
)
{
eltImpact
.
textContent
=
may
currently
be
slowing
down
{
BRAND_NAME
}
.
;
}
else
{
eltImpact
.
textContent
=
is
currently
considerably
slowing
down
{
BRAND_NAME
}
.
;
}
cachedElements
.
eltFPS
.
textContent
=
Impact
on
framerate
:
{
delta
.
diff
.
jank
.
longestDuration
+
1
}
/
{
delta
.
diff
.
jank
.
durations
.
length
}
;
cachedElements
.
eltCPU
.
textContent
=
CPU
usage
:
{
Math
.
ceil
(
delta
.
diff
.
jank
.
totalCPUTime
/
delta
.
diff
.
deltaT
/
10
)
}
%
.
;
cachedElements
.
eltSystem
.
textContent
=
System
usage
:
{
Math
.
ceil
(
delta
.
diff
.
jank
.
totalSystemTime
/
delta
.
diff
.
deltaT
/
10
)
}
%
.
;
cachedElements
.
eltCPOW
.
textContent
=
Blocking
process
calls
:
{
Math
.
ceil
(
delta
.
diff
.
cpow
.
totalCPOWTime
/
delta
.
diff
.
deltaT
/
10
)
}
%
.
;
}
else
{
if
(
delta
.
alerts
.
length
=
=
0
)
{
eltImpact
.
textContent
=
"
has
performed
well
so
far
.
"
;
cachedElements
.
eltFPS
.
textContent
=
Impact
on
framerate
:
no
impact
.
;
cachedElements
.
eltRoot
.
setAttribute
(
"
impact
"
0
)
;
}
else
{
let
impact
=
0
;
let
sum
=
delta
.
alerts
[
0
]
+
delta
.
alerts
[
1
]
;
let
frequency
=
sum
*
1000
/
delta
.
diff
.
deltaT
;
let
describeFrequency
;
if
(
frequency
<
=
MAX_FREQUENCY_FOR_NO_IMPACT
)
{
describeFrequency
=
has
no
impact
on
the
performance
of
{
BRAND_NAME
}
.
;
}
else
{
let
describeImpact
;
if
(
frequency
<
=
MAX_FREQUENCY_FOR_RARE
)
{
describeFrequency
=
rarely
slows
down
{
BRAND_NAME
}
.
;
impact
+
=
1
;
}
else
if
(
frequency
<
=
MAX_FREQUENCY_FOR_FREQUENT
)
{
describeFrequency
=
has
slown
down
{
BRAND_NAME
}
frequently
.
;
impact
+
=
2
.
5
;
}
else
{
describeFrequency
=
seems
to
have
slown
down
{
BRAND_NAME
}
very
often
.
;
impact
+
=
5
;
}
if
(
delta
.
alerts
[
1
]
/
sum
>
MIN_PROPORTION_FOR_MAJOR_IMPACT
)
{
describeImpact
=
"
When
this
happens
the
slowdown
is
generally
important
.
"
;
impact
*
=
2
;
}
else
{
describeImpact
=
"
When
this
happens
the
slowdown
is
generally
noticeable
.
"
;
}
eltImpact
.
textContent
=
{
describeFrequency
}
{
describeImpact
}
;
cachedElements
.
eltFPS
.
textContent
=
Impact
on
framerate
:
{
delta
.
alerts
[
1
]
|
|
0
}
high
-
impacts
{
delta
.
alerts
[
0
]
|
|
0
}
medium
-
impact
.
;
}
cachedElements
.
eltRoot
.
setAttribute
(
"
impact
"
Math
.
round
(
impact
)
)
;
}
cachedElements
.
eltCPU
.
textContent
=
CPU
usage
:
{
Math
.
ceil
(
delta
.
diff
.
jank
.
totalCPUTime
/
delta
.
diff
.
deltaT
/
10
)
}
%
(
total
{
delta
.
diff
.
jank
.
totalUserTime
}
ms
)
.
;
cachedElements
.
eltSystem
.
textContent
=
System
usage
:
{
Math
.
ceil
(
delta
.
diff
.
jank
.
totalSystemTime
/
delta
.
diff
.
deltaT
/
10
)
}
%
(
total
{
delta
.
diff
.
jank
.
totalSystemTime
}
ms
)
.
;
cachedElements
.
eltCPOW
.
textContent
=
Blocking
process
calls
:
{
Math
.
ceil
(
delta
.
diff
.
cpow
.
totalCPOWTime
/
delta
.
diff
.
deltaT
/
10
)
}
%
(
total
{
delta
.
diff
.
cpow
.
totalCPOWTime
}
ms
)
.
;
}
}
this
.
_insertElements
(
toAdd
id
)
;
}
_insertElements
(
elements
id
)
{
let
eltContainer
=
document
.
getElementById
(
id
)
;
eltContainer
.
classList
.
remove
(
"
measuring
"
)
;
eltContainer
.
eltVisibleContent
.
innerHTML
=
"
"
;
eltContainer
.
eltHiddenContent
.
innerHTML
=
"
"
;
eltContainer
.
appendChild
(
eltContainer
.
eltShowMore
)
;
for
(
let
i
=
0
;
i
<
elements
.
length
&
&
i
<
MAX_NUMBER_OF_ITEMS_TO_DISPLAY
;
+
+
i
)
{
let
cachedElements
=
elements
[
i
]
;
eltContainer
.
eltVisibleContent
.
appendChild
(
cachedElements
.
eltRoot
)
;
}
for
(
let
i
=
MAX_NUMBER_OF_ITEMS_TO_DISPLAY
;
i
<
elements
.
length
;
+
+
i
)
{
let
cachedElements
=
elements
[
i
]
;
eltContainer
.
eltHiddenContent
.
appendChild
(
cachedElements
.
eltRoot
)
;
}
if
(
elements
.
length
<
=
MAX_NUMBER_OF_ITEMS_TO_DISPLAY
)
{
eltContainer
.
eltShowMore
.
classList
.
add
(
"
hidden
"
)
;
}
else
{
eltContainer
.
eltShowMore
.
classList
.
remove
(
"
hidden
"
)
;
}
if
(
elements
.
length
=
=
0
)
{
eltContainer
.
textContent
=
"
Nothing
"
;
}
}
_setupStructure
(
id
)
{
let
eltContainer
=
document
.
getElementById
(
id
)
;
if
(
!
eltContainer
.
eltVisibleContent
)
{
eltContainer
.
eltVisibleContent
=
document
.
createElement
(
"
ul
"
)
;
eltContainer
.
eltVisibleContent
.
classList
.
add
(
"
visible_items
"
)
;
eltContainer
.
appendChild
(
eltContainer
.
eltVisibleContent
)
;
}
if
(
!
eltContainer
.
eltHiddenContent
)
{
eltContainer
.
eltHiddenContent
=
document
.
createElement
(
"
ul
"
)
;
eltContainer
.
eltHiddenContent
.
classList
.
add
(
"
hidden
"
)
;
eltContainer
.
eltHiddenContent
.
classList
.
add
(
"
hidden_additional_items
"
)
;
eltContainer
.
appendChild
(
eltContainer
.
eltHiddenContent
)
;
}
if
(
!
eltContainer
.
eltShowMore
)
{
eltContainer
.
eltShowMore
=
document
.
createElement
(
"
button
"
)
;
eltContainer
.
eltShowMore
.
textContent
=
"
Show
all
"
;
eltContainer
.
eltShowMore
.
classList
.
add
(
"
show_all_items
"
)
;
eltContainer
.
appendChild
(
eltContainer
.
eltShowMore
)
;
eltContainer
.
eltShowMore
.
addEventListener
(
"
click
"
function
(
)
{
if
(
eltContainer
.
eltHiddenContent
.
classList
.
contains
(
"
hidden
"
)
)
{
eltContainer
.
eltHiddenContent
.
classList
.
remove
(
"
hidden
"
)
;
eltContainer
.
eltShowMore
.
textContent
=
"
Hide
"
;
}
else
{
eltContainer
.
eltHiddenContent
.
classList
.
add
(
"
hidden
"
)
;
eltContainer
.
eltShowMore
.
textContent
=
"
Show
all
"
;
}
}
)
;
}
return
eltContainer
;
}
_grabOrCreateElements
(
delta
nature
)
{
let
cachedElements
=
this
.
DOMCache
.
get
(
delta
.
key
)
;
if
(
cachedElements
)
{
if
(
cachedElements
.
eltRoot
.
parentElement
)
{
cachedElements
.
eltRoot
.
parentElement
.
removeChild
(
cachedElements
.
eltRoot
)
;
}
}
else
{
this
.
DOMCache
.
set
(
delta
.
key
cachedElements
=
{
}
)
;
let
eltDelta
=
document
.
createElement
(
"
li
"
)
;
eltDelta
.
classList
.
add
(
"
delta
"
)
;
cachedElements
.
eltRoot
=
eltDelta
;
let
eltSpan
=
document
.
createElement
(
"
span
"
)
;
eltDelta
.
appendChild
(
eltSpan
)
;
let
eltSummary
=
document
.
createElement
(
"
span
"
)
;
eltSummary
.
classList
.
add
(
"
summary
"
)
;
eltSpan
.
appendChild
(
eltSummary
)
;
let
eltTitle
=
document
.
createElement
(
"
span
"
)
;
eltTitle
.
classList
.
add
(
"
title
"
)
;
eltSummary
.
appendChild
(
eltTitle
)
;
cachedElements
.
eltTitle
=
eltTitle
;
let
eltImpact
=
document
.
createElement
(
"
span
"
)
;
eltImpact
.
classList
.
add
(
"
impact
"
)
;
eltSummary
.
appendChild
(
eltImpact
)
;
cachedElements
.
eltImpact
=
eltImpact
;
let
eltShowMore
=
document
.
createElement
(
"
a
"
)
;
eltShowMore
.
classList
.
add
(
"
more
"
)
;
eltSpan
.
appendChild
(
eltShowMore
)
;
eltShowMore
.
textContent
=
"
more
"
;
eltShowMore
.
href
=
"
"
;
eltShowMore
.
addEventListener
(
"
click
"
(
)
=
>
{
if
(
eltDetails
.
classList
.
contains
(
"
hidden
"
)
)
{
eltDetails
.
classList
.
remove
(
"
hidden
"
)
;
eltShowMore
.
textContent
=
"
less
"
;
}
else
{
eltDetails
.
classList
.
add
(
"
hidden
"
)
;
eltShowMore
.
textContent
=
"
more
"
;
}
}
)
;
if
(
nature
=
=
"
webpages
"
)
{
eltSpan
.
appendChild
(
document
.
createElement
(
"
br
"
)
)
;
let
eltCloseTab
=
document
.
createElement
(
"
button
"
)
;
eltCloseTab
.
textContent
=
"
Close
tab
"
;
eltSpan
.
appendChild
(
eltCloseTab
)
;
let
windowIds
=
delta
.
diff
.
windowIds
;
eltCloseTab
.
addEventListener
(
"
click
"
(
)
=
>
{
let
found
=
tabFinder
.
getAny
(
windowIds
)
;
if
(
!
found
)
{
return
;
}
let
{
tabbrowser
tab
}
=
found
;
tabbrowser
.
removeTab
(
tab
)
;
}
)
;
let
eltReloadTab
=
document
.
createElement
(
"
button
"
)
;
eltReloadTab
.
textContent
=
"
Reload
tab
"
;
eltSpan
.
appendChild
(
eltReloadTab
)
;
eltReloadTab
.
addEventListener
(
"
click
"
(
)
=
>
{
let
found
=
tabFinder
.
getAny
(
windowIds
)
;
if
(
!
found
)
{
return
;
}
let
{
tabbrowser
tab
}
=
found
;
tabbrowser
.
reloadTab
(
tab
)
;
}
)
;
}
let
eltDetails
=
document
.
createElement
(
"
ul
"
)
;
eltDetails
.
classList
.
add
(
"
details
"
)
;
eltDetails
.
classList
.
add
(
"
hidden
"
)
;
eltSpan
.
appendChild
(
eltDetails
)
;
for
(
let
[
name
className
]
of
[
[
"
eltName
"
"
name
"
]
[
"
eltFPS
"
"
fps
"
]
[
"
eltCPU
"
"
cpu
"
]
[
"
eltSystem
"
"
system
"
]
[
"
eltCPOW
"
"
cpow
"
]
[
"
eltLoaded
"
"
loaded
"
]
[
"
eltProcess
"
"
process
"
]
]
)
{
let
elt
=
document
.
createElement
(
"
li
"
)
;
elt
.
classList
.
add
(
className
)
;
eltDetails
.
appendChild
(
elt
)
;
cachedElements
[
name
]
=
elt
;
}
}
return
cachedElements
;
}
_fragment
:
document
.
createDocumentFragment
(
)
commit
(
)
{
let
tbody
=
document
.
getElementById
(
"
dispatch
-
tbody
"
)
;
while
(
tbody
.
firstChild
)
tbody
.
firstChild
.
remove
(
)
;
tbody
.
appendChild
(
this
.
_fragment
)
;
this
.
_fragment
=
document
.
createDocumentFragment
(
)
;
}
appendRow
(
name
totalValue
recentValue
classes
image
=
"
"
)
{
let
row
=
document
.
createElement
(
"
tr
"
)
;
let
elt
=
document
.
createElement
(
"
td
"
)
;
elt
.
textContent
=
name
;
row
.
appendChild
(
elt
)
;
if
(
image
)
elt
.
style
.
backgroundImage
=
url
(
'
{
image
}
'
)
;
if
(
classes
)
elt
.
classList
.
add
(
.
.
.
classes
)
;
elt
=
document
.
createElement
(
"
td
"
)
;
elt
.
textContent
=
totalValue
;
row
.
appendChild
(
elt
)
;
elt
=
document
.
createElement
(
"
td
"
)
;
elt
.
textContent
=
recentValue
;
row
.
appendChild
(
elt
)
;
this
.
_fragment
.
appendChild
(
row
)
;
return
row
;
}
}
;
var
Control
=
{
init
(
)
{
this
.
_initAutorefresh
(
)
;
this
.
_initDisplayMode
(
)
;
let
tbody
=
document
.
getElementById
(
"
dispatch
-
tbody
"
)
;
tbody
.
addEventListener
(
"
click
"
(
)
=
>
{
let
row
=
event
.
target
.
parentNode
;
if
(
this
.
selectedRow
)
{
this
.
selectedRow
.
removeAttribute
(
"
selected
"
)
;
}
if
(
row
.
windowId
)
{
row
.
setAttribute
(
"
selected
"
"
true
"
)
;
this
.
selectedRow
=
row
;
}
else
if
(
this
.
selectedRow
)
{
this
.
selectedRow
=
null
;
}
}
)
;
}
async
update
(
)
{
let
mode
=
this
.
_displayMode
;
if
(
this
.
_autoRefreshInterval
|
|
!
State
.
_buffer
[
0
]
)
{
await
State
.
update
(
)
;
if
(
document
.
hidden
)
return
;
}
await
wait
(
0
)
;
if
(
!
performanceCountersEnabled
(
)
)
{
let
state
=
await
(
mode
=
=
MODE_GLOBAL
?
State
.
promiseDeltaSinceStartOfTime
(
)
:
State
.
promiseDeltaSinceStartOfBuffer
(
)
)
;
for
(
let
category
of
[
"
webpages
"
]
)
{
await
wait
(
0
)
;
await
View
.
updateCategory
(
state
[
category
]
category
category
mode
)
;
}
await
wait
(
0
)
;
View
.
DOMCache
.
trimTo
(
state
.
deltas
)
;
}
else
{
let
selectedId
=
-
1
;
if
(
this
.
selectedRow
)
{
selectedId
=
this
.
selectedRow
.
windowId
;
this
.
selectedRow
=
null
;
}
let
counters
=
this
.
_sortCounters
(
State
.
getCounters
(
)
)
;
for
(
let
{
id
name
image
totalDispatches
dispatchesSincePrevious
totalDuration
durationSincePrevious
children
}
of
counters
)
{
function
dispatchesAndDuration
(
dispatches
duration
)
{
let
result
=
dispatches
;
if
(
duration
)
{
duration
/
=
1000
;
duration
=
Math
.
round
(
duration
)
;
if
(
duration
)
result
+
=
(
{
duration
/
1000
}
s
)
;
else
result
+
=
"
(
<
1ms
)
"
;
}
return
result
;
}
let
row
=
View
.
appendRow
(
name
dispatchesAndDuration
(
totalDispatches
totalDuration
)
dispatchesAndDuration
(
dispatchesSincePrevious
durationSincePrevious
)
null
image
)
;
row
.
windowId
=
id
;
if
(
id
=
=
selectedId
)
{
row
.
setAttribute
(
"
selected
"
"
true
"
)
;
this
.
selectedRow
=
row
;
}
children
.
sort
(
(
a
b
)
=
>
b
.
dispatchCount
-
a
.
dispatchCount
)
;
for
(
let
row
of
children
)
{
let
host
=
row
.
host
.
replace
(
/
^
blob
:
https
?
:
\
/
\
/
/
"
"
)
;
let
classes
=
[
"
indent
"
]
;
if
(
State
.
isTracker
(
host
)
)
classes
.
push
(
"
tracking
"
)
;
if
(
row
.
isWorker
)
classes
.
push
(
"
worker
"
)
;
View
.
appendRow
(
row
.
host
dispatchesAndDuration
(
row
.
dispatchCount
row
.
duration
)
"
"
classes
)
;
}
}
View
.
commit
(
)
;
}
await
wait
(
0
)
;
Services
.
obs
.
notifyObservers
(
null
UPDATE_COMPLETE_TOPIC
mode
)
;
}
_sortCounters
(
counters
)
{
return
counters
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
dispatchesSinceStartOfBuffer
!
=
b
.
dispatchesSinceStartOfBuffer
)
return
b
.
dispatchesSinceStartOfBuffer
-
a
.
dispatchesSinceStartOfBuffer
;
if
(
a
.
totalDispatches
!
=
b
.
totalDispatches
)
return
b
.
totalDispatches
-
a
.
totalDispatches
;
return
a
.
name
.
localeCompare
(
b
.
name
)
;
}
)
;
}
_setOptions
(
options
)
{
dump
(
about
:
performance
_setOptions
{
JSON
.
stringify
(
options
)
}
\
n
)
;
let
eltRefresh
=
document
.
getElementById
(
"
check
-
autorefresh
"
)
;
if
(
(
options
.
autoRefresh
>
0
)
!
=
eltRefresh
.
checked
)
{
eltRefresh
.
click
(
)
;
}
let
eltCheckRecent
=
document
.
getElementById
(
"
check
-
display
-
recent
"
)
;
if
(
!
!
options
.
displayRecent
!
=
eltCheckRecent
.
checked
)
{
eltCheckRecent
.
click
(
)
;
}
}
_initAutorefresh
(
)
{
let
onRefreshChange
=
(
shouldUpdateNow
=
false
)
=
>
{
if
(
eltRefresh
.
checked
=
=
!
!
this
.
_autoRefreshInterval
)
{
return
;
}
if
(
eltRefresh
.
checked
)
{
this
.
_autoRefreshInterval
=
window
.
setInterval
(
(
)
=
>
Control
.
update
(
)
UPDATE_INTERVAL_MS
)
;
if
(
shouldUpdateNow
)
{
Control
.
update
(
)
;
}
}
else
{
window
.
clearInterval
(
this
.
_autoRefreshInterval
)
;
this
.
_autoRefreshInterval
=
null
;
}
}
;
let
eltRefresh
=
document
.
getElementById
(
"
check
-
autorefresh
"
)
;
eltRefresh
.
addEventListener
(
"
change
"
(
)
=
>
onRefreshChange
(
true
)
)
;
onRefreshChange
(
false
)
;
}
_autoRefreshInterval
:
null
_initDisplayMode
(
)
{
let
onModeChange
=
(
shouldUpdateNow
)
=
>
{
if
(
eltCheckRecent
.
checked
)
{
this
.
_displayMode
=
MODE_RECENT
;
}
else
{
this
.
_displayMode
=
MODE_GLOBAL
;
}
if
(
shouldUpdateNow
)
{
Control
.
update
(
)
;
}
}
;
let
eltCheckRecent
=
document
.
getElementById
(
"
check
-
display
-
recent
"
)
;
let
eltLabelRecent
=
document
.
getElementById
(
"
label
-
display
-
recent
"
)
;
eltCheckRecent
.
addEventListener
(
"
click
"
(
)
=
>
onModeChange
(
true
)
)
;
eltLabelRecent
.
textContent
=
Display
only
the
latest
{
Math
.
round
(
BUFFER_DURATION_MS
/
1000
)
}
s
;
onModeChange
(
false
)
;
}
_displayMode
:
MODE_GLOBAL
}
;
var
go
=
async
function
(
)
{
Control
.
init
(
)
;
if
(
performanceCountersEnabled
(
)
)
{
let
opt
=
document
.
querySelector
(
"
.
options
"
)
;
opt
.
style
.
display
=
"
none
"
;
opt
.
nextElementSibling
.
style
.
display
=
"
none
"
;
}
else
{
document
.
getElementById
(
"
dispatch
-
table
"
)
.
parentNode
.
style
.
display
=
"
none
"
;
}
let
testUpdate
=
function
(
subject
topic
value
)
{
let
options
=
JSON
.
parse
(
value
)
;
Control
.
_setOptions
(
options
)
;
Control
.
update
(
)
;
}
;
Services
.
obs
.
addObserver
(
testUpdate
TEST_DRIVER_TOPIC
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
Services
.
obs
.
removeObserver
(
testUpdate
TEST_DRIVER_TOPIC
)
)
;
await
Control
.
update
(
)
;
await
wait
(
BUFFER_SAMPLING_RATE_MS
*
1
.
1
)
;
await
Control
.
update
(
)
;
}
;
