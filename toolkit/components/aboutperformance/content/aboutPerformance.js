"
use
strict
"
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
const
{
AddonManager
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
{
}
)
;
const
{
AddonWatcher
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonWatcher
.
jsm
"
{
}
)
;
const
{
PerformanceStats
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PerformanceStats
.
jsm
"
{
}
)
;
const
{
Services
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
;
const
{
Task
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
{
}
)
;
const
{
ObjectUtils
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
{
}
)
;
const
TEST_DRIVER_TOPIC
=
"
test
-
about
:
performance
-
test
-
driver
"
;
const
UPDATE_COMPLETE_TOPIC
=
"
about
:
performance
-
update
-
complete
"
;
const
BUFFER_SAMPLING_RATE_MS
=
1000
;
const
BUFFER_DURATION_MS
=
10000
;
const
UPDATE_INTERVAL_MS
=
5000
;
const
BRAND_BUNDLE
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
const
BRAND_NAME
=
BRAND_BUNDLE
.
GetStringFromName
(
"
brandShortName
"
)
;
const
MAX_NUMBER_OF_ITEMS_TO_DISPLAY
=
3
;
const
MAX_FREQUENCY_FOR_NO_IMPACT
=
.
05
;
const
MAX_FREQUENCY_FOR_RARE
=
.
1
;
const
MAX_FREQUENCY_FOR_FREQUENT
=
.
5
;
const
MIN_PROPORTION_FOR_MAJOR_IMPACT
=
.
05
;
const
MIN_PROPORTION_FOR_NOTICEABLE_IMPACT
=
.
1
;
const
MODE_GLOBAL
=
"
global
"
;
const
MODE_RECENT
=
"
recent
"
;
let
tabFinder
=
{
update
:
function
(
)
{
this
.
_map
=
new
Map
(
)
;
let
windows
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windows
.
hasMoreElements
(
)
)
{
let
win
=
windows
.
getNext
(
)
;
let
tabbrowser
=
win
.
gBrowser
;
for
(
let
browser
of
tabbrowser
.
browsers
)
{
let
id
=
browser
.
outerWindowID
;
if
(
id
!
=
null
)
{
this
.
_map
.
set
(
id
browser
)
;
}
}
}
}
get
:
function
(
id
)
{
let
browser
=
this
.
_map
.
get
(
id
)
;
if
(
!
browser
)
{
return
null
;
}
let
tabbrowser
=
browser
.
getTabBrowser
(
)
;
return
{
tabbrowser
tab
:
tabbrowser
.
getTabForBrowser
(
browser
)
}
;
}
getAny
:
function
(
ids
)
{
for
(
let
id
of
ids
)
{
let
result
=
this
.
get
(
id
)
;
if
(
result
)
{
return
result
;
}
}
return
null
;
}
}
;
function
wait
(
ms
=
0
)
{
return
new
Promise
(
resolve
=
>
setTimeout
(
resolve
ms
)
)
;
}
function
Delta
(
diff
kind
snapshotDate
ageMap
alertMap
)
{
if
(
kind
!
=
"
addons
"
&
&
kind
!
=
"
webpages
"
)
{
throw
new
TypeError
(
Unknown
kind
:
{
kind
}
)
;
}
this
.
kind
=
kind
;
this
.
diff
=
diff
;
this
.
key
=
kind
+
diff
.
key
;
let
creationDate
=
snapshotDate
;
for
(
let
groupId
of
diff
.
groupIds
)
{
let
date
=
ageMap
.
get
(
groupId
)
;
if
(
date
&
&
date
<
=
creationDate
)
{
creationDate
=
date
;
}
}
this
.
creationDate
=
creationDate
;
this
.
age
=
snapshotDate
-
creationDate
;
this
.
readableName
=
null
;
this
.
fullName
=
null
;
this
.
_initialized
=
false
;
this
.
_show
=
false
;
this
.
alerts
=
(
alertMap
.
get
(
this
.
key
)
|
|
[
]
)
.
slice
(
)
;
switch
(
this
.
slowness
)
{
case
0
:
break
;
case
1
:
this
.
alerts
[
0
]
=
(
this
.
alerts
[
0
]
|
|
0
)
+
1
;
break
;
case
2
:
this
.
alerts
[
1
]
=
(
this
.
alerts
[
1
]
|
|
0
)
+
1
;
break
;
default
:
throw
new
Error
(
)
;
}
}
Delta
.
prototype
=
{
get
show
(
)
{
this
.
_ensureInitialized
(
)
;
return
this
.
_show
;
}
get
slowness
(
)
{
if
(
Delta
.
compare
(
this
Delta
.
MAX_DELTA_FOR_GOOD_RECENT_PERFORMANCE
)
<
=
0
)
{
return
0
;
}
if
(
Delta
.
compare
(
this
Delta
.
MAX_DELTA_FOR_AVERAGE_RECENT_PERFORMANCE
)
<
=
0
)
{
return
1
;
}
return
2
;
}
_ensureInitialized
(
)
{
if
(
!
this
.
_initialized
)
{
throw
new
Error
(
)
;
}
}
promiseInit
:
function
(
)
{
if
(
this
.
kind
=
=
"
webpages
"
)
{
return
this
.
_initWebpage
(
)
;
}
else
if
(
this
.
kind
=
=
"
addons
"
)
{
return
this
.
_promiseInitAddon
(
)
;
}
throw
new
TypeError
(
)
;
}
_initWebpage
:
function
(
)
{
this
.
_initialized
=
true
;
let
found
=
tabFinder
.
getAny
(
this
.
diff
.
windowIds
)
;
if
(
!
found
|
|
found
.
tab
.
linkedBrowser
.
contentTitle
=
=
null
)
{
return
;
}
this
.
readableName
=
found
.
tab
.
linkedBrowser
.
contentTitle
;
this
.
fullName
=
this
.
diff
.
names
.
join
(
"
"
)
;
this
.
_show
=
true
;
}
_promiseInitAddon
:
Task
.
async
(
function
*
(
)
{
let
found
=
yield
(
new
Promise
(
resolve
=
>
AddonManager
.
getAddonByID
(
this
.
diff
.
addonId
a
=
>
{
if
(
a
)
{
this
.
readableName
=
a
.
name
;
resolve
(
true
)
;
}
else
{
resolve
(
false
)
;
}
}
)
)
)
;
this
.
_initialized
=
true
;
this
.
_show
=
found
;
this
.
fullName
=
this
.
diff
.
addonId
;
}
)
toString
:
function
(
)
{
return
[
Delta
]
{
this
.
diff
.
key
}
=
>
{
this
.
readableName
}
{
this
.
fullName
}
;
}
}
;
Delta
.
compare
=
function
(
a
b
)
{
return
(
(
a
.
diff
.
jank
.
longestDuration
-
b
.
diff
.
jank
.
longestDuration
)
|
|
(
a
.
diff
.
jank
.
totalUserTime
-
b
.
diff
.
jank
.
totalUserTime
)
|
|
(
a
.
diff
.
jank
.
totalSystemTime
-
b
.
diff
.
jank
.
totalSystemTime
)
|
|
(
a
.
diff
.
cpow
.
totalCPOWTime
-
b
.
diff
.
cpow
.
totalCPOWTime
)
|
|
(
a
.
diff
.
ticks
.
ticks
-
b
.
diff
.
ticks
.
ticks
)
|
|
0
)
;
}
;
Delta
.
revCompare
=
function
(
a
b
)
{
return
-
Delta
.
compare
(
a
b
)
;
}
;
Delta
.
MAX_DELTA_FOR_GOOD_RECENT_PERFORMANCE
=
{
diff
:
{
cpow
:
{
totalCPOWTime
:
0
}
jank
:
{
longestDuration
:
3
totalUserTime
:
Number
.
POSITIVE_INFINITY
totalSystemTime
:
Number
.
POSITIVE_INFINITY
}
ticks
:
{
ticks
:
Number
.
POSITIVE_INFINITY
}
}
}
;
Delta
.
MAX_DELTA_FOR_AVERAGE_RECENT_PERFORMANCE
=
{
diff
:
{
cpow
:
{
totalCPOWTime
:
Number
.
POSITIVE_INFINITY
}
jank
:
{
longestDuration
:
7
totalUserTime
:
Number
.
POSITIVE_INFINITY
totalSystemTime
:
Number
.
POSITIVE_INFINITY
}
ticks
:
{
ticks
:
Number
.
POSITIVE_INFINITY
}
}
}
;
var
State
=
{
_monitor
:
PerformanceStats
.
getMonitor
(
[
"
jank
"
"
cpow
"
"
ticks
"
]
)
_buffer
:
[
]
_oldest
:
null
_latest
:
null
_alerts
:
new
Map
(
)
_firstSeen
:
new
Map
(
)
update
:
Task
.
async
(
function
*
(
)
{
if
(
this
.
_buffer
.
length
=
=
0
)
{
if
(
this
.
_oldest
)
{
throw
new
Error
(
"
Internal
Error
we
shouldn
'
t
have
a
_oldest
value
yet
.
"
)
;
}
this
.
_latest
=
this
.
_oldest
=
yield
this
.
_monitor
.
promiseSnapshot
(
)
;
this
.
_buffer
.
push
(
this
.
_oldest
)
;
yield
new
Promise
(
resolve
=
>
setTimeout
(
resolve
BUFFER_SAMPLING_RATE_MS
*
1
.
1
)
)
;
}
let
now
=
Cu
.
now
(
)
;
let
latestInBuffer
=
this
.
_buffer
[
this
.
_buffer
.
length
-
1
]
;
let
deltaT
=
now
-
latestInBuffer
.
date
;
if
(
deltaT
>
BUFFER_SAMPLING_RATE_MS
)
{
this
.
_latest
=
yield
this
.
_monitor
.
promiseSnapshot
(
)
;
this
.
_buffer
.
push
(
this
.
_latest
)
;
}
let
oldestInBuffer
=
this
.
_buffer
[
0
]
;
if
(
oldestInBuffer
.
date
+
BUFFER_DURATION_MS
<
this
.
_latest
.
date
)
{
this
.
_buffer
.
shift
(
)
;
}
}
)
promiseDeltaSinceStartOfTime
:
function
(
)
{
return
this
.
_promiseDeltaSince
(
this
.
_oldest
)
;
}
promiseDeltaSinceStartOfBuffer
:
function
(
)
{
return
this
.
_promiseDeltaSince
(
this
.
_buffer
[
0
]
)
;
}
_promiseDeltaSince
:
Task
.
async
(
function
*
(
oldest
)
{
let
current
=
this
.
_latest
;
if
(
!
oldest
)
{
throw
new
TypeError
(
)
;
}
if
(
!
current
)
{
throw
new
TypeError
(
)
;
}
tabFinder
.
update
(
)
;
let
oldFirstSeen
=
this
.
_firstSeen
;
let
cleanedUpFirstSeen
=
new
Map
(
)
;
let
oldAlerts
=
this
.
_alerts
;
let
cleanedUpAlerts
=
new
Map
(
)
;
let
result
=
{
addons
:
[
]
webpages
:
[
]
deltas
:
new
Set
(
)
duration
:
current
.
date
-
oldest
.
date
}
;
for
(
let
kind
of
[
"
webpages
"
"
addons
"
]
)
{
for
(
let
[
key
value
]
of
current
[
kind
]
)
{
let
item
=
ObjectUtils
.
strict
(
new
Delta
(
value
.
subtract
(
oldest
[
kind
]
.
get
(
key
)
)
kind
current
.
date
oldFirstSeen
oldAlerts
)
)
;
yield
item
.
promiseInit
(
)
;
if
(
!
item
.
show
)
{
continue
;
}
result
[
kind
]
.
push
(
item
)
;
result
.
deltas
.
add
(
item
.
key
)
;
for
(
let
groupId
of
item
.
diff
.
groupIds
)
{
cleanedUpFirstSeen
.
set
(
groupId
item
.
creationDate
)
;
}
cleanedUpAlerts
.
set
(
item
.
key
item
.
alerts
)
;
}
}
this
.
_firstSeen
=
cleanedUpFirstSeen
;
this
.
_alerts
=
cleanedUpAlerts
;
return
result
;
}
)
}
;
var
View
=
{
DOMCache
:
{
_map
:
new
Map
(
)
get
:
function
(
deltaKey
)
{
return
this
.
_map
.
get
(
deltaKey
)
;
}
set
:
function
(
deltaKey
value
)
{
this
.
_map
.
set
(
deltaKey
value
)
;
}
trimTo
:
function
(
set
)
{
let
remove
=
[
]
;
for
(
let
key
of
this
.
_map
.
keys
(
)
)
{
if
(
!
set
.
has
(
key
)
)
{
remove
.
push
(
key
)
;
}
}
for
(
let
key
of
remove
)
{
this
.
_map
.
delete
(
key
)
;
}
}
}
updateCategory
:
function
(
subset
id
nature
currentMode
)
{
subset
=
subset
.
slice
(
)
.
sort
(
Delta
.
revCompare
)
;
let
watcherAlerts
=
null
;
if
(
nature
=
=
"
addons
"
)
{
watcherAlerts
=
AddonWatcher
.
alerts
;
}
let
eltContainer
=
this
.
_setupStructure
(
id
)
;
let
toAdd
=
[
]
;
for
(
let
delta
of
subset
)
{
if
(
!
(
delta
instanceof
Delta
)
)
{
throw
new
TypeError
(
)
;
}
let
cachedElements
=
this
.
_grabOrCreateElements
(
delta
nature
)
;
toAdd
.
push
(
cachedElements
)
;
cachedElements
.
eltTitle
.
textContent
=
delta
.
readableName
;
cachedElements
.
eltName
.
textContent
=
Full
name
:
{
delta
.
fullName
}
.
;
cachedElements
.
eltLoaded
.
textContent
=
Measure
start
:
{
Math
.
round
(
delta
.
age
/
1000
)
}
seconds
ago
.
let
processes
=
[
for
(
proc
of
delta
.
diff
.
processes
)
{
proc
.
processId
}
(
{
proc
.
isChildProcess
?
"
child
"
:
"
parent
"
}
)
]
;
cachedElements
.
eltProcess
.
textContent
=
Processes
:
{
processes
.
join
(
"
"
)
}
;
let
jankSuffix
=
"
"
;
let
cpowSuffix
=
"
"
;
if
(
watcherAlerts
)
{
let
deltaAlerts
=
watcherAlerts
.
get
(
delta
.
diff
.
addonId
)
;
if
(
deltaAlerts
)
{
jankSuffix
=
(
{
deltaAlerts
.
alerts
.
longestDuration
|
|
0
}
alerts
)
;
cpowSuffix
=
(
{
deltaAlerts
.
alerts
.
totalCPOWTime
|
|
0
}
alerts
)
;
}
}
let
eltImpact
=
cachedElements
.
eltImpact
;
if
(
currentMode
=
=
MODE_RECENT
)
{
cachedElements
.
eltRoot
.
setAttribute
(
"
impact
"
delta
.
diff
.
jank
.
longestDuration
+
1
)
;
if
(
Delta
.
compare
(
delta
Delta
.
MAX_DELTA_FOR_GOOD_RECENT_PERFORMANCE
)
<
=
0
)
{
eltImpact
.
textContent
=
currently
performs
well
.
;
}
else
if
(
Delta
.
compare
(
delta
Delta
.
MAX_DELTA_FOR_AVERAGE_RECENT_PERFORMANCE
)
)
{
eltImpact
.
textContent
=
may
currently
be
slowing
down
{
BRAND_NAME
}
.
;
}
else
{
eltImpact
.
textContent
=
is
currently
considerably
slowing
down
{
BRAND_NAME
}
.
;
}
cachedElements
.
eltFPS
.
textContent
=
Impact
on
framerate
:
{
delta
.
diff
.
jank
.
longestDuration
+
1
}
/
{
delta
.
diff
.
jank
.
durations
.
length
}
{
jankSuffix
}
.
;
cachedElements
.
eltCPU
.
textContent
=
CPU
usage
:
{
Math
.
ceil
(
delta
.
diff
.
jank
.
totalCPUTime
/
delta
.
diff
.
deltaT
)
}
%
.
;
cachedElements
.
eltSystem
.
textContent
=
System
usage
:
{
Math
.
ceil
(
delta
.
diff
.
jank
.
totalSystemTime
/
delta
.
diff
.
deltaT
)
}
%
.
;
cachedElements
.
eltCPOW
.
textContent
=
Blocking
process
calls
:
{
Math
.
ceil
(
delta
.
diff
.
cpow
.
totalCPOWTime
/
delta
.
diff
.
deltaT
)
}
%
{
cpowSuffix
}
.
;
}
else
{
if
(
delta
.
alerts
.
length
=
=
0
)
{
eltImpact
.
textContent
=
"
has
performed
well
so
far
.
"
;
cachedElements
.
eltFPS
.
textContent
=
Impact
on
framerate
:
no
impact
.
;
cachedElements
.
eltRoot
.
setAttribute
(
"
impact
"
0
)
;
}
else
{
let
impact
=
0
;
let
sum
=
delta
.
alerts
[
0
]
+
delta
.
alerts
[
1
]
;
let
frequency
=
sum
*
1000
/
delta
.
diff
.
deltaT
;
let
describeFrequency
;
if
(
frequency
<
=
MAX_FREQUENCY_FOR_NO_IMPACT
)
{
describeFrequency
=
has
no
impact
on
the
performance
of
{
BRAND_NAME
}
.
}
else
{
let
describeImpact
;
if
(
frequency
<
=
MAX_FREQUENCY_FOR_RARE
)
{
describeFrequency
=
rarely
slows
down
{
BRAND_NAME
}
.
;
impact
+
=
1
;
}
else
if
(
frequency
<
=
MAX_FREQUENCY_FOR_FREQUENT
)
{
describeFrequency
=
has
slown
down
{
BRAND_NAME
}
frequently
.
;
impact
+
=
2
.
5
;
}
else
{
describeFrequency
=
seems
to
have
slown
down
{
BRAND_NAME
}
very
often
.
;
impact
+
=
5
;
}
if
(
delta
.
alerts
[
1
]
/
sum
>
MIN_PROPORTION_FOR_MAJOR_IMPACT
)
{
describeImpact
=
"
When
this
happens
the
slowdown
is
generally
important
.
"
impact
*
=
2
;
}
else
{
describeImpact
=
"
When
this
happens
the
slowdown
is
generally
noticeable
.
"
}
eltImpact
.
textContent
=
{
describeFrequency
}
{
describeImpact
}
;
cachedElements
.
eltFPS
.
textContent
=
Impact
on
framerate
:
{
delta
.
alerts
[
1
]
|
|
0
}
high
-
impacts
{
delta
.
alerts
[
0
]
|
|
0
}
medium
-
impact
{
jankSuffix
}
.
;
}
cachedElements
.
eltRoot
.
setAttribute
(
"
impact
"
Math
.
round
(
impact
)
)
;
}
let
result
=
delta
.
diff
.
jank
.
totalCPUTime
/
delta
.
diff
.
deltaT
;
cachedElements
.
eltCPU
.
textContent
=
CPU
usage
:
{
Math
.
ceil
(
delta
.
diff
.
jank
.
totalCPUTime
/
delta
.
diff
.
deltaT
)
}
%
(
total
{
delta
.
diff
.
jank
.
totalUserTime
}
ms
)
.
;
cachedElements
.
eltSystem
.
textContent
=
System
usage
:
{
Math
.
ceil
(
delta
.
diff
.
jank
.
totalSystemTime
/
delta
.
diff
.
deltaT
)
}
%
(
total
{
delta
.
diff
.
jank
.
totalSystemTime
}
ms
)
.
;
cachedElements
.
eltCPOW
.
textContent
=
Blocking
process
calls
:
{
Math
.
ceil
(
delta
.
diff
.
cpow
.
totalCPOWTime
/
delta
.
diff
.
deltaT
)
}
%
(
total
{
delta
.
diff
.
cpow
.
totalCPOWTime
}
ms
)
{
cpowSuffix
}
.
;
}
}
this
.
_insertElements
(
toAdd
id
)
;
}
_insertElements
:
function
(
elements
id
)
{
let
eltContainer
=
document
.
getElementById
(
id
)
;
eltContainer
.
classList
.
remove
(
"
measuring
"
)
;
eltContainer
.
eltVisibleContent
.
innerHTML
=
"
"
;
eltContainer
.
eltHiddenContent
.
innerHTML
=
"
"
;
eltContainer
.
appendChild
(
eltContainer
.
eltShowMore
)
;
for
(
let
i
=
0
;
i
<
elements
.
length
&
&
i
<
MAX_NUMBER_OF_ITEMS_TO_DISPLAY
;
+
+
i
)
{
let
cachedElements
=
elements
[
i
]
;
eltContainer
.
eltVisibleContent
.
appendChild
(
cachedElements
.
eltRoot
)
;
}
for
(
let
i
=
MAX_NUMBER_OF_ITEMS_TO_DISPLAY
;
i
<
elements
.
length
;
+
+
i
)
{
let
cachedElements
=
elements
[
i
]
;
eltContainer
.
eltHiddenContent
.
appendChild
(
cachedElements
.
eltRoot
)
;
}
if
(
elements
.
length
<
=
MAX_NUMBER_OF_ITEMS_TO_DISPLAY
)
{
eltContainer
.
eltShowMore
.
classList
.
add
(
"
hidden
"
)
;
}
else
{
eltContainer
.
eltShowMore
.
classList
.
remove
(
"
hidden
"
)
;
}
if
(
elements
.
length
=
=
0
)
{
eltContainer
.
textContent
=
"
Nothing
"
;
}
}
_setupStructure
:
function
(
id
)
{
let
eltContainer
=
document
.
getElementById
(
id
)
;
if
(
!
eltContainer
.
eltVisibleContent
)
{
eltContainer
.
eltVisibleContent
=
document
.
createElement
(
"
ul
"
)
;
eltContainer
.
eltVisibleContent
.
classList
.
add
(
"
visible_items
"
)
;
eltContainer
.
appendChild
(
eltContainer
.
eltVisibleContent
)
;
}
if
(
!
eltContainer
.
eltHiddenContent
)
{
eltContainer
.
eltHiddenContent
=
document
.
createElement
(
"
ul
"
)
;
eltContainer
.
eltHiddenContent
.
classList
.
add
(
"
hidden
"
)
;
eltContainer
.
eltHiddenContent
.
classList
.
add
(
"
hidden_additional_items
"
)
;
eltContainer
.
appendChild
(
eltContainer
.
eltHiddenContent
)
;
}
if
(
!
eltContainer
.
eltShowMore
)
{
eltContainer
.
eltShowMore
=
document
.
createElement
(
"
button
"
)
;
eltContainer
.
eltShowMore
.
textContent
=
"
Show
all
"
;
eltContainer
.
eltShowMore
.
classList
.
add
(
"
show_all_items
"
)
;
eltContainer
.
appendChild
(
eltContainer
.
eltShowMore
)
;
eltContainer
.
eltShowMore
.
addEventListener
(
"
click
"
function
(
)
{
if
(
eltContainer
.
eltHiddenContent
.
classList
.
contains
(
"
hidden
"
)
)
{
eltContainer
.
eltHiddenContent
.
classList
.
remove
(
"
hidden
"
)
;
eltContainer
.
eltShowMore
.
textContent
=
"
Hide
"
;
}
else
{
eltContainer
.
eltHiddenContent
.
classList
.
add
(
"
hidden
"
)
;
eltContainer
.
eltShowMore
.
textContent
=
"
Show
all
"
;
}
}
)
;
}
return
eltContainer
;
}
_grabOrCreateElements
:
function
(
delta
nature
)
{
let
cachedElements
=
this
.
DOMCache
.
get
(
delta
.
key
)
;
if
(
cachedElements
)
{
if
(
cachedElements
.
eltRoot
.
parentElement
)
{
cachedElements
.
eltRoot
.
parentElement
.
removeChild
(
cachedElements
.
eltRoot
)
;
}
}
else
{
this
.
DOMCache
.
set
(
delta
.
key
cachedElements
=
{
}
)
;
let
eltDelta
=
document
.
createElement
(
"
li
"
)
;
eltDelta
.
classList
.
add
(
"
delta
"
)
;
cachedElements
.
eltRoot
=
eltDelta
;
let
eltSpan
=
document
.
createElement
(
"
span
"
)
;
eltDelta
.
appendChild
(
eltSpan
)
;
let
eltSummary
=
document
.
createElement
(
"
span
"
)
;
eltSummary
.
classList
.
add
(
"
summary
"
)
;
eltSpan
.
appendChild
(
eltSummary
)
;
let
eltTitle
=
document
.
createElement
(
"
span
"
)
;
eltTitle
.
classList
.
add
(
"
title
"
)
;
eltSummary
.
appendChild
(
eltTitle
)
;
cachedElements
.
eltTitle
=
eltTitle
;
let
eltImpact
=
document
.
createElement
(
"
span
"
)
;
eltImpact
.
classList
.
add
(
"
impact
"
)
;
eltSummary
.
appendChild
(
eltImpact
)
;
cachedElements
.
eltImpact
=
eltImpact
;
let
eltShowMore
=
document
.
createElement
(
"
a
"
)
;
eltShowMore
.
classList
.
add
(
"
more
"
)
;
eltSpan
.
appendChild
(
eltShowMore
)
;
eltShowMore
.
textContent
=
"
more
"
;
eltShowMore
.
href
=
"
"
;
eltShowMore
.
addEventListener
(
"
click
"
(
)
=
>
{
if
(
eltDetails
.
classList
.
contains
(
"
hidden
"
)
)
{
eltDetails
.
classList
.
remove
(
"
hidden
"
)
;
eltShowMore
.
textContent
=
"
less
"
;
}
else
{
eltDetails
.
classList
.
add
(
"
hidden
"
)
;
eltShowMore
.
textContent
=
"
more
"
;
}
}
)
;
if
(
nature
=
=
"
addons
"
)
{
eltSpan
.
appendChild
(
document
.
createElement
(
"
br
"
)
)
;
let
eltDisable
=
document
.
createElement
(
"
button
"
)
;
eltDisable
.
textContent
=
"
Disable
"
;
eltSpan
.
appendChild
(
eltDisable
)
;
let
eltUninstall
=
document
.
createElement
(
"
button
"
)
;
eltUninstall
.
textContent
=
"
Uninstall
"
;
eltSpan
.
appendChild
(
eltUninstall
)
;
let
eltRestart
=
document
.
createElement
(
"
button
"
)
;
eltRestart
.
textContent
=
Restart
{
BRAND_NAME
}
to
apply
your
changes
.
eltRestart
.
classList
.
add
(
"
hidden
"
)
;
eltSpan
.
appendChild
(
eltRestart
)
;
eltRestart
.
addEventListener
(
"
click
"
(
)
=
>
{
Services
.
startup
.
quit
(
Services
.
startup
.
eForceQuit
|
Services
.
startup
.
eRestart
)
;
}
)
;
AddonManager
.
getAddonByID
(
delta
.
diff
.
addonId
addon
=
>
{
eltDisable
.
addEventListener
(
"
click
"
(
)
=
>
{
addon
.
userDisabled
=
true
;
if
(
addon
.
pendingOperations
=
=
addon
.
PENDING_NONE
)
{
return
;
}
eltDisable
.
classList
.
add
(
"
hidden
"
)
;
eltUninstall
.
classList
.
add
(
"
hidden
"
)
;
eltRestart
.
classList
.
remove
(
"
hidden
"
)
;
}
)
;
eltUninstall
.
addEventListener
(
"
click
"
(
)
=
>
{
addon
.
uninstall
(
)
;
if
(
addon
.
pendingOperations
=
=
addon
.
PENDING_NONE
)
{
return
;
}
eltDisable
.
classList
.
add
(
"
hidden
"
)
;
eltUninstall
.
classList
.
add
(
"
hidden
"
)
;
eltRestart
.
classList
.
remove
(
"
hidden
"
)
;
}
)
;
}
)
;
}
else
if
(
nature
=
=
"
webpages
"
)
{
eltSpan
.
appendChild
(
document
.
createElement
(
"
br
"
)
)
;
let
eltCloseTab
=
document
.
createElement
(
"
button
"
)
;
eltCloseTab
.
textContent
=
"
Close
tab
"
;
eltSpan
.
appendChild
(
eltCloseTab
)
;
let
windowIds
=
delta
.
diff
.
windowIds
;
eltCloseTab
.
addEventListener
(
"
click
"
(
)
=
>
{
let
found
=
tabFinder
.
getAny
(
windowIds
)
;
if
(
!
found
)
{
return
;
}
let
{
tabbrowser
tab
}
=
found
;
tabbrowser
.
removeTab
(
tab
)
;
}
)
;
let
eltReloadTab
=
document
.
createElement
(
"
button
"
)
;
eltReloadTab
.
textContent
=
"
Reload
tab
"
;
eltSpan
.
appendChild
(
eltReloadTab
)
;
eltReloadTab
.
addEventListener
(
"
click
"
(
)
=
>
{
let
found
=
tabFinder
.
getAny
(
windowIds
)
;
if
(
!
found
)
{
return
;
}
let
{
tabbrowser
tab
}
=
found
;
tabbrowser
.
reloadTab
(
tab
)
;
}
)
;
}
let
eltDetails
=
document
.
createElement
(
"
ul
"
)
;
eltDetails
.
classList
.
add
(
"
details
"
)
;
eltDetails
.
classList
.
add
(
"
hidden
"
)
;
eltSpan
.
appendChild
(
eltDetails
)
;
for
(
let
[
name
className
]
of
[
[
"
eltName
"
"
name
"
]
[
"
eltFPS
"
"
fps
"
]
[
"
eltCPU
"
"
cpu
"
]
[
"
eltSystem
"
"
system
"
]
[
"
eltCPOW
"
"
cpow
"
]
[
"
eltLoaded
"
"
loaded
"
]
[
"
eltProcess
"
"
process
"
]
]
)
{
let
elt
=
document
.
createElement
(
"
li
"
)
;
elt
.
classList
.
add
(
className
)
;
eltDetails
.
appendChild
(
elt
)
;
cachedElements
[
name
]
=
elt
;
}
}
return
cachedElements
;
}
}
;
var
Control
=
{
init
:
function
(
)
{
this
.
_initAutorefresh
(
)
;
this
.
_initDisplayMode
(
)
;
}
update
:
Task
.
async
(
function
*
(
)
{
let
mode
=
this
.
_displayMode
;
if
(
this
.
_autoRefreshInterval
|
|
!
State
.
_buffer
[
0
]
)
{
yield
State
.
update
(
)
;
}
yield
wait
(
0
)
;
let
state
=
yield
(
mode
=
=
MODE_GLOBAL
?
State
.
promiseDeltaSinceStartOfTime
(
)
:
State
.
promiseDeltaSinceStartOfBuffer
(
)
)
;
for
(
let
category
of
[
"
webpages
"
"
addons
"
]
)
{
yield
wait
(
0
)
;
yield
View
.
updateCategory
(
state
[
category
]
category
category
mode
)
;
}
yield
wait
(
0
)
;
View
.
DOMCache
.
trimTo
(
state
.
deltas
)
;
yield
wait
(
0
)
;
Services
.
obs
.
notifyObservers
(
null
UPDATE_COMPLETE_TOPIC
mode
)
;
}
)
_setOptions
:
function
(
options
)
{
dump
(
about
:
performance
_setOptions
{
JSON
.
stringify
(
options
)
}
\
n
)
;
let
eltRefresh
=
document
.
getElementById
(
"
check
-
autorefresh
"
)
;
if
(
(
options
.
autoRefresh
>
0
)
!
=
eltRefresh
.
checked
)
{
eltRefresh
.
click
(
)
;
}
let
eltCheckRecent
=
document
.
getElementById
(
"
check
-
display
-
recent
"
)
;
if
(
!
!
options
.
displayRecent
!
=
eltCheckRecent
.
checked
)
{
eltCheckRecent
.
click
(
)
;
}
}
_initAutorefresh
:
function
(
)
{
let
onRefreshChange
=
(
shouldUpdateNow
=
false
)
=
>
{
if
(
eltRefresh
.
checked
=
=
!
!
this
.
_autoRefreshInterval
)
{
return
;
}
if
(
eltRefresh
.
checked
)
{
this
.
_autoRefreshInterval
=
window
.
setInterval
(
(
)
=
>
Control
.
update
(
)
UPDATE_INTERVAL_MS
)
;
if
(
shouldUpdateNow
)
{
Control
.
update
(
)
;
}
}
else
{
window
.
clearInterval
(
this
.
_autoRefreshInterval
)
;
this
.
_autoRefreshInterval
=
null
;
}
}
let
eltRefresh
=
document
.
getElementById
(
"
check
-
autorefresh
"
)
;
eltRefresh
.
addEventListener
(
"
change
"
(
)
=
>
onRefreshChange
(
true
)
)
;
onRefreshChange
(
false
)
;
}
_autoRefreshInterval
:
null
_initDisplayMode
:
function
(
)
{
let
onModeChange
=
(
shouldUpdateNow
)
=
>
{
if
(
eltCheckRecent
.
checked
)
{
this
.
_displayMode
=
MODE_RECENT
;
}
else
{
this
.
_displayMode
=
MODE_GLOBAL
;
}
if
(
shouldUpdateNow
)
{
Control
.
update
(
)
;
}
}
;
let
eltCheckRecent
=
document
.
getElementById
(
"
check
-
display
-
recent
"
)
;
let
eltLabelRecent
=
document
.
getElementById
(
"
label
-
display
-
recent
"
)
;
eltCheckRecent
.
addEventListener
(
"
click
"
(
)
=
>
onModeChange
(
true
)
)
;
eltLabelRecent
.
textContent
=
Display
only
the
latest
{
Math
.
round
(
BUFFER_DURATION_MS
/
1000
)
}
s
;
onModeChange
(
false
)
;
}
_displayMode
:
MODE_GLOBAL
}
;
var
go
=
Task
.
async
(
function
*
(
)
{
Control
.
init
(
)
;
let
testUpdate
=
function
(
subject
topic
value
)
{
let
options
=
JSON
.
parse
(
value
)
;
Control
.
_setOptions
(
options
)
;
Control
.
update
(
)
;
}
;
Services
.
obs
.
addObserver
(
testUpdate
TEST_DRIVER_TOPIC
false
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
Services
.
obs
.
removeObserver
(
testUpdate
TEST_DRIVER_TOPIC
)
)
;
yield
Control
.
update
(
)
;
yield
new
Promise
(
resolve
=
>
setTimeout
(
resolve
BUFFER_SAMPLING_RATE_MS
*
1
.
1
)
)
;
yield
Control
.
update
(
)
;
}
)
;
