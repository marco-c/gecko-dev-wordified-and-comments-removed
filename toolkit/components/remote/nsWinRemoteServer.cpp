#
include
"
nsWinRemoteServer
.
h
"
#
include
"
RemoteUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIWindowMediator
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsICommandLineRunner
.
h
"
#
include
"
nsICommandLine
.
h
"
#
include
"
nsCommandLine
.
h
"
#
include
"
nsIDocShell
.
h
"
HWND
hwndForDOMWindow
(
mozIDOMWindowProxy
*
window
)
{
if
(
!
window
)
{
return
0
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
pidomwindow
=
nsPIDOMWindowOuter
:
:
From
(
window
)
;
nsCOMPtr
<
nsIBaseWindow
>
ppBaseWindow
=
do_QueryInterface
(
pidomwindow
-
>
GetDocShell
(
)
)
;
if
(
!
ppBaseWindow
)
{
return
0
;
}
nsCOMPtr
<
nsIWidget
>
ppWidget
;
ppBaseWindow
-
>
GetMainWidget
(
getter_AddRefs
(
ppWidget
)
)
;
return
(
HWND
)
(
ppWidget
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
)
;
}
static
nsresult
GetMostRecentWindow
(
mozIDOMWindowProxy
*
*
aWindow
)
{
nsresult
rv
;
nsCOMPtr
<
nsIWindowMediator
>
med
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
med
)
return
med
-
>
GetMostRecentWindow
(
nullptr
aWindow
)
;
return
NS_ERROR_FAILURE
;
}
template
<
typename
T
>
class
CommandLineParserWin
final
{
int
mArgc
;
T
*
*
mArgv
;
void
Release
(
)
{
if
(
mArgv
)
{
while
(
mArgc
)
{
delete
[
]
mArgv
[
-
-
mArgc
]
;
}
delete
[
]
mArgv
;
mArgv
=
nullptr
;
}
}
public
:
CommandLineParserWin
(
)
:
mArgc
(
0
)
mArgv
(
nullptr
)
{
}
~
CommandLineParserWin
(
)
{
Release
(
)
;
}
CommandLineParserWin
(
const
CommandLineParserWin
&
)
=
delete
;
CommandLineParserWin
(
CommandLineParserWin
&
&
)
=
delete
;
CommandLineParserWin
&
operator
=
(
const
CommandLineParserWin
&
)
=
delete
;
CommandLineParserWin
&
operator
=
(
CommandLineParserWin
&
&
)
=
delete
;
int
Argc
(
)
const
{
return
mArgc
;
}
const
T
*
const
*
Argv
(
)
const
{
return
mArgv
;
}
void
HandleCommandLine
(
const
T
*
aCmdLineString
)
;
}
;
template
<
typename
T
>
void
CommandLineParserWin
<
T
>
:
:
HandleCommandLine
(
const
T
*
aCmdLineString
)
{
Release
(
)
;
int
justCounting
=
1
;
int
init
=
1
;
int
between
quoted
bSlashCount
;
const
T
*
p
;
nsTAutoString
<
T
>
arg
;
while
(
1
)
{
if
(
init
)
{
p
=
aCmdLineString
;
between
=
1
;
mArgc
=
quoted
=
bSlashCount
=
0
;
init
=
0
;
}
if
(
between
)
{
if
(
*
p
!
=
0
&
&
!
isspace
(
*
p
)
)
{
between
=
0
;
arg
.
Truncate
(
)
;
switch
(
*
p
)
{
case
'
\
\
'
:
bSlashCount
=
1
;
break
;
case
'
"
'
:
quoted
=
1
;
break
;
default
:
arg
+
=
*
p
;
break
;
}
}
else
{
}
}
else
{
if
(
*
p
=
=
0
|
|
(
!
quoted
&
&
isspace
(
*
p
)
)
)
{
while
(
bSlashCount
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
-
;
}
if
(
!
justCounting
)
{
mArgv
[
mArgc
]
=
new
T
[
arg
.
Length
(
)
+
1
]
;
memcpy
(
mArgv
[
mArgc
]
arg
.
get
(
)
(
arg
.
Length
(
)
+
1
)
*
sizeof
(
T
)
)
;
}
mArgc
+
+
;
between
=
1
;
}
else
{
switch
(
*
p
)
{
case
'
"
'
:
while
(
bSlashCount
>
1
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
=
2
;
}
if
(
bSlashCount
)
{
arg
+
=
'
"
'
;
bSlashCount
=
0
;
}
else
{
if
(
quoted
)
{
if
(
*
(
p
+
1
)
=
=
'
"
'
)
{
bSlashCount
=
1
;
}
else
{
quoted
=
0
;
}
}
else
{
quoted
=
1
;
}
}
break
;
case
'
\
\
'
:
bSlashCount
+
+
;
break
;
default
:
while
(
bSlashCount
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
-
;
}
arg
+
=
*
p
;
break
;
}
}
}
if
(
*
p
)
{
p
+
+
;
}
else
{
if
(
justCounting
)
{
mArgv
=
new
T
*
[
mArgc
]
;
justCounting
=
0
;
init
=
1
;
}
else
{
break
;
}
}
}
}
LRESULT
CALLBACK
WindowProc
(
HWND
msgWindow
UINT
msg
WPARAM
wp
LPARAM
lp
)
{
if
(
msg
=
=
WM_COPYDATA
)
{
COPYDATASTRUCT
*
cds
=
(
COPYDATASTRUCT
*
)
lp
;
nsCOMPtr
<
nsIFile
>
workingDir
;
if
(
1
>
=
cds
-
>
dwData
)
{
char
*
wdpath
=
(
char
*
)
cds
-
>
lpData
;
while
(
*
wdpath
)
+
+
wdpath
;
+
+
wdpath
;
NS_NewLocalFile
(
NS_ConvertUTF8toUTF16
(
wdpath
)
false
getter_AddRefs
(
workingDir
)
)
;
}
CommandLineParserWin
<
char
>
parser
;
parser
.
HandleCommandLine
(
reinterpret_cast
<
char
*
>
(
cds
-
>
lpData
)
)
;
nsCOMPtr
<
nsICommandLineRunner
>
cmdLine
(
new
nsCommandLine
(
)
)
;
if
(
NS_SUCCEEDED
(
cmdLine
-
>
Init
(
parser
.
Argc
(
)
parser
.
Argv
(
)
workingDir
nsICommandLine
:
:
STATE_REMOTE_AUTO
)
)
)
{
cmdLine
-
>
Run
(
)
;
}
else
{
NS_ERROR
(
"
Error
initializing
command
line
.
"
)
;
}
nsCOMPtr
<
mozIDOMWindowProxy
>
win
;
GetMostRecentWindow
(
getter_AddRefs
(
win
)
)
;
return
win
?
(
LRESULT
)
hwndForDOMWindow
(
win
)
:
0
;
}
return
DefWindowProc
(
msgWindow
msg
wp
lp
)
;
}
nsresult
nsWinRemoteServer
:
:
Startup
(
const
char
*
aAppName
const
char
*
aProfileName
)
{
nsString
className
;
BuildClassName
(
aAppName
aProfileName
className
)
;
WNDCLASSW
classStruct
=
{
0
&
WindowProc
0
0
0
0
0
0
0
className
.
get
(
)
}
;
NS_ENSURE_TRUE
(
:
:
RegisterClassW
(
&
classStruct
)
NS_ERROR_FAILURE
)
;
mHandle
=
:
:
CreateWindowW
(
className
.
get
(
)
0
WS_CAPTION
0
0
0
0
0
0
0
0
)
;
return
mHandle
?
NS_OK
:
NS_ERROR_FAILURE
;
}
void
nsWinRemoteServer
:
:
Shutdown
(
)
{
DestroyWindow
(
mHandle
)
;
mHandle
=
nullptr
;
}
