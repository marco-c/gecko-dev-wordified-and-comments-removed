#
include
"
nsWinRemoteServer
.
h
"
#
include
"
nsWinRemoteUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIWindowMediator
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsICommandLineRunner
.
h
"
#
include
"
nsICommandLine
.
h
"
#
include
"
nsCommandLine
.
h
"
#
include
"
nsIDocShell
.
h
"
HWND
hwndForDOMWindow
(
mozIDOMWindowProxy
*
window
)
{
if
(
!
window
)
{
return
0
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
pidomwindow
=
nsPIDOMWindowOuter
:
:
From
(
window
)
;
nsCOMPtr
<
nsIBaseWindow
>
ppBaseWindow
=
do_QueryInterface
(
pidomwindow
-
>
GetDocShell
(
)
)
;
if
(
!
ppBaseWindow
)
{
return
0
;
}
nsCOMPtr
<
nsIWidget
>
ppWidget
;
ppBaseWindow
-
>
GetMainWidget
(
getter_AddRefs
(
ppWidget
)
)
;
return
(
HWND
)
(
ppWidget
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
)
;
}
static
nsresult
GetMostRecentWindow
(
mozIDOMWindowProxy
*
*
aWindow
)
{
nsresult
rv
;
nsCOMPtr
<
nsIWindowMediator
>
med
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
med
)
return
med
-
>
GetMostRecentWindow
(
nullptr
aWindow
)
;
return
NS_ERROR_FAILURE
;
}
void
HandleCommandLine
(
const
char
*
aCmdLineString
nsIFile
*
aWorkingDir
uint32_t
aState
)
{
nsresult
rv
;
int
justCounting
=
1
;
char
*
*
argv
=
0
;
int
init
=
1
;
int
between
quoted
bSlashCount
;
int
argc
;
const
char
*
p
;
nsAutoCString
arg
;
nsCOMPtr
<
nsICommandLineRunner
>
cmdLine
(
new
nsCommandLine
(
)
)
;
while
(
1
)
{
if
(
init
)
{
p
=
aCmdLineString
;
between
=
1
;
argc
=
quoted
=
bSlashCount
=
0
;
init
=
0
;
}
if
(
between
)
{
if
(
*
p
!
=
0
&
&
!
isspace
(
*
p
)
)
{
between
=
0
;
arg
=
"
"
;
switch
(
*
p
)
{
case
'
\
\
'
:
bSlashCount
=
1
;
break
;
case
'
"
'
:
quoted
=
1
;
break
;
default
:
arg
+
=
*
p
;
break
;
}
}
else
{
}
}
else
{
if
(
*
p
=
=
0
|
|
(
!
quoted
&
&
isspace
(
*
p
)
)
)
{
while
(
bSlashCount
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
-
;
}
if
(
!
justCounting
)
{
argv
[
argc
]
=
new
char
[
arg
.
Length
(
)
+
1
]
;
strcpy
(
argv
[
argc
]
arg
.
get
(
)
)
;
}
argc
+
+
;
between
=
1
;
}
else
{
switch
(
*
p
)
{
case
'
"
'
:
while
(
bSlashCount
>
1
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
=
2
;
}
if
(
bSlashCount
)
{
arg
+
=
'
"
'
;
bSlashCount
=
0
;
}
else
{
if
(
quoted
)
{
if
(
*
(
p
+
1
)
=
=
'
"
'
)
{
bSlashCount
=
1
;
}
else
{
quoted
=
0
;
}
}
else
{
quoted
=
1
;
}
}
break
;
case
'
\
\
'
:
bSlashCount
+
+
;
break
;
default
:
while
(
bSlashCount
)
{
arg
+
=
'
\
\
'
;
bSlashCount
-
-
;
}
arg
+
=
*
p
;
break
;
}
}
}
if
(
*
p
)
{
p
+
+
;
}
else
{
if
(
justCounting
)
{
argv
=
new
char
*
[
argc
]
;
justCounting
=
0
;
init
=
1
;
}
else
{
break
;
}
}
}
rv
=
cmdLine
-
>
Init
(
argc
argv
aWorkingDir
aState
)
;
while
(
argc
)
{
delete
[
]
argv
[
-
-
argc
]
;
}
delete
[
]
argv
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
Error
initializing
command
line
.
"
)
;
return
;
}
cmdLine
-
>
Run
(
)
;
}
LRESULT
CALLBACK
WindowProc
(
HWND
msgWindow
UINT
msg
WPARAM
wp
LPARAM
lp
)
{
if
(
msg
=
=
WM_COPYDATA
)
{
COPYDATASTRUCT
*
cds
=
(
COPYDATASTRUCT
*
)
lp
;
nsCOMPtr
<
nsIFile
>
workingDir
;
if
(
1
>
=
cds
-
>
dwData
)
{
char
*
wdpath
=
(
char
*
)
cds
-
>
lpData
;
while
(
*
wdpath
)
+
+
wdpath
;
+
+
wdpath
;
NS_NewLocalFile
(
NS_ConvertUTF8toUTF16
(
wdpath
)
false
getter_AddRefs
(
workingDir
)
)
;
}
HandleCommandLine
(
(
char
*
)
cds
-
>
lpData
workingDir
nsICommandLine
:
:
STATE_REMOTE_AUTO
)
;
nsCOMPtr
<
mozIDOMWindowProxy
>
win
;
GetMostRecentWindow
(
getter_AddRefs
(
win
)
)
;
return
win
?
(
LRESULT
)
hwndForDOMWindow
(
win
)
:
0
;
}
return
DefWindowProc
(
msgWindow
msg
wp
lp
)
;
}
nsresult
nsWinRemoteServer
:
:
Startup
(
const
char
*
aAppName
const
char
*
aProfileName
)
{
nsString
className
;
BuildClassName
(
aAppName
aProfileName
className
)
;
WNDCLASSW
classStruct
=
{
0
&
WindowProc
0
0
0
0
0
0
0
className
.
get
(
)
}
;
NS_ENSURE_TRUE
(
:
:
RegisterClassW
(
&
classStruct
)
NS_ERROR_FAILURE
)
;
mHandle
=
:
:
CreateWindowW
(
className
.
get
(
)
0
WS_CAPTION
0
0
0
0
0
0
0
0
)
;
return
mHandle
?
NS_OK
:
NS_ERROR_FAILURE
;
}
void
nsWinRemoteServer
:
:
Shutdown
(
)
{
DestroyWindow
(
mHandle
)
;
mHandle
=
nullptr
;
}
