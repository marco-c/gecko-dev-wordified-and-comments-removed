"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
LoginExport
"
]
;
let
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
}
)
;
class
LoginExport
{
static
_buildCSVRow
(
login
columns
)
{
let
row
=
[
]
;
for
(
let
columnName
of
columns
)
{
let
columnValue
=
login
[
columnName
]
;
if
(
typeof
columnValue
=
=
"
string
"
)
{
columnValue
=
columnValue
.
split
(
'
"
'
)
.
join
(
'
"
"
'
)
;
}
if
(
columnValue
!
=
=
null
&
&
columnValue
!
=
undefined
)
{
row
.
push
(
"
{
columnValue
}
"
)
;
}
else
{
row
.
push
(
"
"
)
;
}
}
return
row
;
}
static
async
exportAsCSV
(
path
logins
=
null
)
{
if
(
!
logins
)
{
logins
=
await
Services
.
logins
.
getAllLoginsAsync
(
)
;
}
let
columns
=
[
"
origin
"
"
username
"
"
password
"
"
httpRealm
"
"
formActionOrigin
"
"
guid
"
"
timeCreated
"
"
timeLastUsed
"
"
timePasswordChanged
"
]
;
let
csvHeader
=
columns
.
map
(
name
=
>
{
if
(
name
=
=
"
origin
"
)
{
return
'
"
url
"
'
;
}
return
"
{
name
}
"
;
}
)
;
let
rows
=
[
]
;
rows
.
push
(
csvHeader
)
;
for
(
let
login
of
logins
)
{
rows
.
push
(
LoginExport
.
_buildCSVRow
(
login
columns
)
)
;
}
let
csvAsString
=
rows
.
map
(
e
=
>
e
.
join
(
"
"
)
)
.
join
(
"
\
r
\
n
"
)
;
await
OS
.
File
.
writeAtomic
(
path
new
TextEncoder
(
)
.
encode
(
csvAsString
)
{
tmpPath
:
path
+
"
.
tmp
"
}
)
;
}
}
