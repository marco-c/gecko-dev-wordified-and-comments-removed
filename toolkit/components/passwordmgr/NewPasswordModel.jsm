const
EXPORTED_SYMBOLS
=
[
"
NewPasswordModel
"
]
;
ChromeUtils
.
defineModuleGetter
(
this
"
fathom
"
"
resource
:
/
/
gre
/
modules
/
third_party
/
fathom
/
fathom
.
jsm
"
)
;
const
{
dom
element
out
rule
ruleset
score
type
utils
:
{
identity
isVisible
min
setDefault
}
clusters
:
{
euclidean
}
}
=
fathom
;
const
DEVELOPMENT
=
false
;
const
coefficients
=
{
new
:
[
[
"
hasNewLabel
"
2
.
531618356704712
]
[
"
hasConfirmLabel
"
1
.
9212454557418823
]
[
"
hasCurrentLabel
"
-
1
.
5062531232833862
]
[
"
closestLabelMatchesNew
"
2
.
4905529022216797
]
[
"
closestLabelMatchesConfirm
"
2
.
188796281814575
]
[
"
closestLabelMatchesCurrent
"
-
2
.
5512311458587646
]
[
"
hasNewAriaLabel
"
1
.
9324924945831299
]
[
"
hasConfirmAriaLabel
"
1
.
7427018880844116
]
[
"
hasCurrentAriaLabel
"
-
0
.
45434775948524475
]
[
"
hasNewPlaceholder
"
1
.
3900811672210693
]
[
"
hasConfirmPlaceholder
"
2
.
120662212371826
]
[
"
hasCurrentPlaceholder
"
-
2
.
464745283126831
]
[
"
forgotPasswordInFormLinkTextContent
"
-
0
.
34269317984580994
]
[
"
forgotPasswordInFormLinkHref
"
-
1
.
100291132926941
]
[
"
forgotPasswordInFormLinkTitle
"
-
2
.
5948476791381836
]
[
"
forgotInFormLinkTextContent
"
-
1
.
104567050933838
]
[
"
forgotInFormLinkHref
"
0
.
43580958247184753
]
[
"
forgotPasswordInFormButtonTextContent
"
-
2
.
2410218715667725
]
[
"
forgotPasswordOnPageLinkTextContent
"
-
0
.
7233141660690308
]
[
"
forgotPasswordOnPageLinkHref
"
-
0
.
3587746322154999
]
[
"
forgotPasswordOnPageLinkTitle
"
0
.
5892723798751831
]
[
"
forgotPasswordOnPageButtonTextContent
"
-
0
.
0006637098849751055
]
[
"
elementAttrsMatchNew
"
2
.
36958646774292
]
[
"
elementAttrsMatchConfirm
"
1
.
79710853099823
]
[
"
elementAttrsMatchCurrent
"
-
2
.
0240602493286133
]
[
"
elementAttrsMatchPassword1
"
1
.
9658048152923584
]
[
"
elementAttrsMatchPassword2
"
1
.
6933585405349731
]
[
"
elementAttrsMatchLogin
"
1
.
1432386636734009
]
[
"
formAttrsMatchRegister
"
1
.
8227713108062744
]
[
"
formHasRegisterAction
"
1
.
9209907054901123
]
[
"
formButtonIsRegister
"
2
.
889024496078491
]
[
"
formAttrsMatchLogin
"
-
1
.
166875958442688
]
[
"
formHasLoginAction
"
-
0
.
4696630537509918
]
[
"
formButtonIsLogin
"
-
2
.
284656524658203
]
[
"
hasAutocompleteCurrentPassword
"
-
0
.
04689808934926987
]
[
"
formHasRememberMeCheckbox
"
0
.
5008370280265808
]
[
"
formHasRememberMeLabel
"
-
0
.
022740153595805168
]
[
"
formHasNewsletterCheckbox
"
1
.
5111156702041626
]
[
"
formHasNewsletterLabel
"
2
.
277301549911499
]
[
"
closestHeaderAboveIsLoginy
"
-
2
.
2182235717773438
]
[
"
closestHeaderAboveIsRegistery
"
1
.
930107593536377
]
[
"
nextInputIsConfirmy
"
2
.
5108766555786133
]
]
}
;
const
biases
=
[
[
"
new
"
0
.
08310158550739288
]
]
;
const
passwordStringRegex
=
/
password
|
passwort
|
|
mot
de
passe
|
|
|
|
wachtwoord
|
senha
|
|
parol
|
|
contrase
a
|
heslo
|
|
kodeord
|
|
pass
code
|
Kata
sandi
|
has
o
|
|
ifre
/
i
;
const
passwordAttrRegex
=
/
pw
|
pwd
|
passwd
|
pass
/
i
;
const
newStringRegex
=
/
new
|
erstellen
|
create
|
choose
|
|
/
i
;
const
newAttrRegex
=
/
new
/
i
;
const
confirmStringRegex
=
/
wiederholen
|
wiederholung
|
confirm
|
repeat
|
confirmation
|
verify
|
retype
|
repite
|
|
|
|
re
-
enter
|
|
bevestigen
|
confirme
|
|
tassyklamak
|
|
je
t
jednou
|
gentag
|
re
-
type
|
confirmar
|
R
p
ter
|
conferma
|
Repeta
i
|
again
|
reenter
/
i
;
const
confirmAttrRegex
=
/
confirm
|
retype
/
i
;
const
currentAttrAndStringRegex
=
/
current
|
old
/
i
;
const
forgotStringRegex
=
/
vergessen
|
vergeten
|
forgot
|
oubli
|
dimenticata
|
Esqueceu
|
esqueci
|
|
|
|
Zapomenut
|
lost
|
|
|
|
|
|
help
|
|
|
|
Unuttu
|
perdus
|
|
reset
|
recover
|
change
|
remind
|
find
|
request
|
restore
|
trouble
/
i
;
const
forgotHrefRegex
=
/
forgot
|
reset
|
recover
|
change
|
lost
|
remind
|
find
|
request
|
restore
/
i
;
const
password1Regex
=
/
pw1
|
pwd1
|
pass1
|
passwd1
|
password1
|
pwone
|
pwdone
|
passone
|
passwdone
|
passwordone
|
pwfirst
|
pwdfirst
|
passfirst
|
passwdfirst
|
passwordfirst
/
i
;
const
password2Regex
=
/
pw2
|
pwd2
|
pass2
|
passwd2
|
password2
|
pwtwo
|
pwdtwo
|
passtwo
|
passwdtwo
|
passwordtwo
|
pwsecond
|
pwdsecond
|
passsecond
|
passwdsecond
|
passwordsecond
/
i
;
const
loginRegex
=
/
login
|
log
in
|
log
on
|
log
-
on
|
|
sign
in
|
sigin
|
sign
\
/
in
|
sign
-
in
|
sign
on
|
sign
-
on
|
|
|
P
ihl
sit
se
|
P
ihlaste
|
|
|
entrar
|
|
|
inloggen
|
|
accedi
|
|
Giri
Yap
|
|
connecter
|
connectez
-
vous
|
Connexion
|
/
i
;
const
loginFormAttrRegex
=
/
login
|
log
in
|
log
on
|
log
-
on
|
sign
in
|
sigin
|
sign
\
/
in
|
sign
-
in
|
sign
on
|
sign
-
on
/
i
;
const
registerStringRegex
=
/
create
[
a
-
zA
-
Z
\
s
]
+
account
|
Zugang
anlegen
|
Angaben
pr
fen
|
Konto
erstellen
|
register
|
sign
up
|
|
|
|
cadastr
|
|
|
Bellige
alynmak
|
|
|
|
Cr
er
mon
compte
|
Mendaftar
|
|
inschrijving
|
Zarejestruj
si
|
Deschide
i
un
cont
|
|
|
ye
Ol
|
registr
|
new
account
|
|
Schrijf
je
/
i
;
const
registerActionRegex
=
/
register
|
signup
|
sign
-
up
|
create
-
account
|
account
\
/
create
|
join
|
new_account
|
user
\
/
create
|
sign
\
/
up
|
membership
\
/
create
/
i
;
const
registerFormAttrRegex
=
/
signup
|
join
|
register
|
regform
|
registration
|
new_user
|
AccountCreate
|
create_customer
|
CreateAccount
|
CreateAcct
|
create
-
account
|
reg
-
form
|
newuser
|
new
-
reg
|
new
-
form
|
new_membership
/
i
;
const
rememberMeAttrRegex
=
/
remember
|
auto_login
|
auto
-
login
|
save_mail
|
save
-
mail
|
ricordami
|
manter
|
mantenha
|
savelogin
|
auto
login
/
i
;
const
rememberMeStringRegex
=
/
remember
me
|
keep
me
logged
in
|
keep
me
signed
in
|
save
email
address
|
save
id
|
stay
signed
in
|
ricordami
|
ID
|
|
|
|
|
|
lembrar
|
manter
conectado
|
mantenha
-
me
conectado
|
|
|
|
|
|
/
i
;
const
newsletterStringRegex
=
/
newsletter
|
/
i
;
const
passwordStringAndAttrRegex
=
new
RegExp
(
passwordStringRegex
.
source
+
"
|
"
+
passwordAttrRegex
.
source
"
i
"
)
;
function
makeRuleset
(
coeffs
biases
)
{
let
elementToSelectors
;
function
clearCache
(
)
{
elementToSelectors
=
new
WeakMap
(
)
;
}
function
hasLabelMatchingRegex
(
element
regex
)
{
const
labels
=
element
.
labels
;
if
(
labels
!
=
=
null
&
&
labels
.
length
)
{
return
regex
.
test
(
labels
[
0
]
.
textContent
)
;
}
let
labelledBy
=
element
.
getAttribute
(
"
aria
-
labelledby
"
)
;
if
(
labelledBy
!
=
=
null
)
{
labelledBy
=
labelledBy
.
split
(
"
"
)
.
map
(
id
=
>
element
.
getRootNode
(
)
.
getElementById
(
id
)
)
.
filter
(
el
=
>
el
)
;
if
(
labelledBy
.
length
=
=
=
1
)
{
return
regex
.
test
(
labelledBy
[
0
]
.
textContent
)
;
}
else
if
(
labelledBy
.
length
>
1
)
{
return
regex
.
test
(
min
(
labelledBy
node
=
>
euclidean
(
node
element
)
)
.
textContent
)
;
}
}
const
parentElement
=
element
.
parentElement
;
if
(
!
parentElement
)
{
return
false
;
}
if
(
parentElement
.
tagName
=
=
=
"
TD
"
&
&
parentElement
.
parentElement
)
{
return
regex
.
test
(
parentElement
.
parentElement
.
textContent
)
;
}
if
(
parentElement
.
tagName
=
=
=
"
DD
"
&
&
parentElement
.
previousElementSibling
)
{
return
regex
.
test
(
parentElement
.
previousElementSibling
.
textContent
)
;
}
return
false
;
}
function
closestLabelMatchesRegex
(
element
regex
)
{
const
previousElementSibling
=
element
.
previousElementSibling
;
if
(
previousElementSibling
!
=
=
null
&
&
previousElementSibling
.
tagName
=
=
=
"
LABEL
"
)
{
return
regex
.
test
(
previousElementSibling
.
textContent
)
;
}
const
nextElementSibling
=
element
.
nextElementSibling
;
if
(
nextElementSibling
!
=
=
null
&
&
nextElementSibling
.
tagName
=
=
=
"
LABEL
"
)
{
return
regex
.
test
(
nextElementSibling
.
textContent
)
;
}
const
closestLabelWithinForm
=
closestSelectorElementWithinElement
(
element
element
.
form
"
label
"
)
;
return
containsRegex
(
regex
closestLabelWithinForm
closestLabelWithinForm
=
>
closestLabelWithinForm
.
textContent
)
;
}
function
containsRegex
(
regex
thingOrNull
thingToString
=
identity
)
{
return
thingOrNull
!
=
=
null
&
&
regex
.
test
(
thingToString
(
thingOrNull
)
)
;
}
function
closestSelectorElementWithinElement
(
toElement
withinElement
querySelector
)
{
if
(
withinElement
!
=
=
null
)
{
let
nodeList
=
Array
.
from
(
withinElement
.
querySelectorAll
(
querySelector
)
)
;
if
(
nodeList
.
length
)
{
return
min
(
nodeList
node
=
>
euclidean
(
node
toElement
)
)
;
}
}
return
null
;
}
function
hasAriaLabelMatchingRegex
(
element
regex
)
{
return
containsRegex
(
regex
element
.
getAttribute
(
"
aria
-
label
"
)
)
;
}
function
hasPlaceholderMatchingRegex
(
element
regex
)
{
return
containsRegex
(
regex
element
.
getAttribute
(
"
placeholder
"
)
)
;
}
function
testRegexesAgainstAnchorPropertyWithinElement
(
property
element
.
.
.
regexes
)
{
return
hasSomeMatchingPredicateForSelectorWithinElement
(
element
"
a
"
anchor
=
>
{
const
propertyValue
=
anchor
[
property
]
;
return
regexes
.
every
(
regex
=
>
regex
.
test
(
propertyValue
)
)
;
}
)
;
}
function
testFormButtonsAgainst
(
element
stringRegex
)
{
const
form
=
element
.
form
;
if
(
form
!
=
=
null
)
{
let
inputs
=
Array
.
from
(
form
.
querySelectorAll
(
"
input
[
type
=
submit
]
input
[
type
=
button
]
"
)
)
;
inputs
=
inputs
.
filter
(
input
=
>
{
return
stringRegex
.
test
(
input
.
value
)
;
}
)
;
if
(
inputs
.
length
)
{
return
true
;
}
return
hasSomeMatchingPredicateForSelectorWithinElement
(
form
"
button
"
button
=
>
{
return
(
stringRegex
.
test
(
button
.
value
)
|
|
stringRegex
.
test
(
button
.
textContent
)
|
|
stringRegex
.
test
(
button
.
id
)
|
|
stringRegex
.
test
(
button
.
title
)
)
;
}
)
;
}
return
false
;
}
function
hasAutocompleteCurrentPassword
(
fnode
)
{
return
fnode
.
element
.
autocomplete
=
=
=
"
current
-
password
"
;
}
function
getElementDescendants
(
element
selector
)
{
const
selectorToDescendants
=
setDefault
(
elementToSelectors
element
(
)
=
>
new
Map
(
)
)
;
return
setDefault
(
selectorToDescendants
selector
(
)
=
>
Array
.
from
(
element
.
querySelectorAll
(
selector
)
)
)
;
}
function
nextInputIsConfirmy
(
fnode
)
{
const
form
=
fnode
.
element
.
form
;
const
me
=
fnode
.
element
;
if
(
form
!
=
=
null
)
{
let
afterMe
=
false
;
for
(
const
formEl
of
form
.
elements
)
{
if
(
formEl
=
=
=
me
)
{
afterMe
=
true
;
}
else
if
(
afterMe
)
{
if
(
formEl
.
type
=
=
=
"
password
"
&
&
!
formEl
.
disabled
&
&
formEl
.
getAttribute
(
"
aria
-
hidden
"
)
!
=
=
"
true
"
)
{
return
elementAttrsMatchRegex
(
formEl
confirmAttrRegex
)
;
}
break
;
}
}
}
return
false
;
}
function
hasSomeMatchingPredicateForSelectorWithinElement
(
element
selector
matchingPredicate
)
{
if
(
element
=
=
=
null
)
{
return
false
;
}
const
elements
=
getElementDescendants
(
element
selector
)
;
return
elements
.
some
(
matchingPredicate
)
;
}
function
textContentMatchesRegexes
(
element
.
.
.
regexes
)
{
const
textContent
=
element
.
textContent
;
return
regexes
.
every
(
regex
=
>
regex
.
test
(
textContent
)
)
;
}
function
closestHeaderAboveMatchesRegex
(
element
regex
)
{
const
closestHeader
=
closestHeaderAbove
(
element
)
;
if
(
closestHeader
!
=
=
null
)
{
return
regex
.
test
(
closestHeader
.
textContent
)
;
}
return
false
;
}
function
closestHeaderAbove
(
element
)
{
let
headers
=
Array
.
from
(
element
.
ownerDocument
.
querySelectorAll
(
"
h1
h2
h3
h4
h5
h6
div
[
class
*
=
heading
]
div
[
class
*
=
header
]
div
[
class
*
=
title
]
legend
"
)
)
;
for
(
let
i
=
headers
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
const
header
=
headers
[
i
]
;
if
(
element
.
compareDocumentPosition
(
header
)
&
Node
.
DOCUMENT_POSITION_PRECEDING
)
{
return
header
;
}
}
return
null
;
}
function
elementAttrsMatchRegex
(
element
regex
)
{
if
(
element
!
=
=
null
)
{
return
(
regex
.
test
(
element
.
id
)
|
|
regex
.
test
(
element
.
name
)
|
|
regex
.
test
(
element
.
className
)
)
;
}
return
false
;
}
function
*
simpleScoringRulesTakingType
(
inType
ruleMap
)
{
for
(
const
[
name
scoringCallback
]
of
Object
.
entries
(
ruleMap
)
)
{
yield
rule
(
type
(
inType
)
score
(
scoringCallback
)
{
name
}
)
;
}
}
return
ruleset
(
[
rule
(
DEVELOPMENT
?
dom
(
"
input
[
type
=
password
]
:
not
(
[
disabled
]
[
aria
-
hidden
=
true
]
)
"
)
.
when
(
isVisible
)
:
element
(
"
input
"
)
type
(
"
new
"
)
.
note
(
clearCache
)
)
.
.
.
simpleScoringRulesTakingType
(
"
new
"
{
hasNewLabel
:
fnode
=
>
hasLabelMatchingRegex
(
fnode
.
element
newStringRegex
)
hasConfirmLabel
:
fnode
=
>
hasLabelMatchingRegex
(
fnode
.
element
confirmStringRegex
)
hasCurrentLabel
:
fnode
=
>
hasLabelMatchingRegex
(
fnode
.
element
currentAttrAndStringRegex
)
closestLabelMatchesNew
:
fnode
=
>
closestLabelMatchesRegex
(
fnode
.
element
newStringRegex
)
closestLabelMatchesConfirm
:
fnode
=
>
closestLabelMatchesRegex
(
fnode
.
element
confirmStringRegex
)
closestLabelMatchesCurrent
:
fnode
=
>
closestLabelMatchesRegex
(
fnode
.
element
currentAttrAndStringRegex
)
hasNewAriaLabel
:
fnode
=
>
hasAriaLabelMatchingRegex
(
fnode
.
element
newStringRegex
)
hasConfirmAriaLabel
:
fnode
=
>
hasAriaLabelMatchingRegex
(
fnode
.
element
confirmStringRegex
)
hasCurrentAriaLabel
:
fnode
=
>
hasAriaLabelMatchingRegex
(
fnode
.
element
currentAttrAndStringRegex
)
hasNewPlaceholder
:
fnode
=
>
hasPlaceholderMatchingRegex
(
fnode
.
element
newStringRegex
)
hasConfirmPlaceholder
:
fnode
=
>
hasPlaceholderMatchingRegex
(
fnode
.
element
confirmStringRegex
)
hasCurrentPlaceholder
:
fnode
=
>
hasPlaceholderMatchingRegex
(
fnode
.
element
currentAttrAndStringRegex
)
forgotPasswordInFormLinkTextContent
:
fnode
=
>
testRegexesAgainstAnchorPropertyWithinElement
(
"
textContent
"
fnode
.
element
.
form
passwordStringRegex
forgotStringRegex
)
forgotPasswordInFormLinkHref
:
fnode
=
>
testRegexesAgainstAnchorPropertyWithinElement
(
"
href
"
fnode
.
element
.
form
passwordStringAndAttrRegex
forgotHrefRegex
)
forgotPasswordInFormLinkTitle
:
fnode
=
>
testRegexesAgainstAnchorPropertyWithinElement
(
"
title
"
fnode
.
element
.
form
passwordStringRegex
forgotStringRegex
)
forgotInFormLinkTextContent
:
fnode
=
>
testRegexesAgainstAnchorPropertyWithinElement
(
"
textContent
"
fnode
.
element
.
form
forgotStringRegex
)
forgotInFormLinkHref
:
fnode
=
>
testRegexesAgainstAnchorPropertyWithinElement
(
"
href
"
fnode
.
element
.
form
forgotHrefRegex
)
forgotPasswordInFormButtonTextContent
:
fnode
=
>
hasSomeMatchingPredicateForSelectorWithinElement
(
fnode
.
element
.
form
"
button
"
button
=
>
textContentMatchesRegexes
(
button
passwordStringRegex
forgotStringRegex
)
)
forgotPasswordOnPageLinkTextContent
:
fnode
=
>
testRegexesAgainstAnchorPropertyWithinElement
(
"
textContent
"
fnode
.
element
.
ownerDocument
passwordStringRegex
forgotStringRegex
)
forgotPasswordOnPageLinkHref
:
fnode
=
>
testRegexesAgainstAnchorPropertyWithinElement
(
"
href
"
fnode
.
element
.
ownerDocument
passwordStringAndAttrRegex
forgotHrefRegex
)
forgotPasswordOnPageLinkTitle
:
fnode
=
>
testRegexesAgainstAnchorPropertyWithinElement
(
"
title
"
fnode
.
element
.
ownerDocument
passwordStringRegex
forgotStringRegex
)
forgotPasswordOnPageButtonTextContent
:
fnode
=
>
hasSomeMatchingPredicateForSelectorWithinElement
(
fnode
.
element
.
ownerDocument
"
button
"
button
=
>
textContentMatchesRegexes
(
button
passwordStringRegex
forgotStringRegex
)
)
elementAttrsMatchNew
:
fnode
=
>
elementAttrsMatchRegex
(
fnode
.
element
newAttrRegex
)
elementAttrsMatchConfirm
:
fnode
=
>
elementAttrsMatchRegex
(
fnode
.
element
confirmAttrRegex
)
elementAttrsMatchCurrent
:
fnode
=
>
elementAttrsMatchRegex
(
fnode
.
element
currentAttrAndStringRegex
)
elementAttrsMatchPassword1
:
fnode
=
>
elementAttrsMatchRegex
(
fnode
.
element
password1Regex
)
elementAttrsMatchPassword2
:
fnode
=
>
elementAttrsMatchRegex
(
fnode
.
element
password2Regex
)
elementAttrsMatchLogin
:
fnode
=
>
elementAttrsMatchRegex
(
fnode
.
element
loginRegex
)
formAttrsMatchRegister
:
fnode
=
>
elementAttrsMatchRegex
(
fnode
.
element
.
form
registerFormAttrRegex
)
formHasRegisterAction
:
fnode
=
>
containsRegex
(
registerActionRegex
fnode
.
element
.
form
form
=
>
form
.
action
)
formButtonIsRegister
:
fnode
=
>
testFormButtonsAgainst
(
fnode
.
element
registerStringRegex
)
formAttrsMatchLogin
:
fnode
=
>
elementAttrsMatchRegex
(
fnode
.
element
.
form
loginFormAttrRegex
)
formHasLoginAction
:
fnode
=
>
containsRegex
(
loginRegex
fnode
.
element
.
form
form
=
>
form
.
action
)
formButtonIsLogin
:
fnode
=
>
testFormButtonsAgainst
(
fnode
.
element
loginRegex
)
hasAutocompleteCurrentPassword
formHasRememberMeCheckbox
:
fnode
=
>
hasSomeMatchingPredicateForSelectorWithinElement
(
fnode
.
element
.
form
"
input
[
type
=
checkbox
]
"
checkbox
=
>
rememberMeAttrRegex
.
test
(
checkbox
.
id
)
|
|
rememberMeAttrRegex
.
test
(
checkbox
.
name
)
)
formHasRememberMeLabel
:
fnode
=
>
hasSomeMatchingPredicateForSelectorWithinElement
(
fnode
.
element
.
form
"
label
"
label
=
>
rememberMeStringRegex
.
test
(
label
.
textContent
)
)
formHasNewsletterCheckbox
:
fnode
=
>
hasSomeMatchingPredicateForSelectorWithinElement
(
fnode
.
element
.
form
"
input
[
type
=
checkbox
]
"
checkbox
=
>
checkbox
.
id
.
includes
(
"
newsletter
"
)
|
|
checkbox
.
name
.
includes
(
"
newsletter
"
)
)
formHasNewsletterLabel
:
fnode
=
>
hasSomeMatchingPredicateForSelectorWithinElement
(
fnode
.
element
.
form
"
label
"
label
=
>
newsletterStringRegex
.
test
(
label
.
textContent
)
)
closestHeaderAboveIsLoginy
:
fnode
=
>
closestHeaderAboveMatchesRegex
(
fnode
.
element
loginRegex
)
closestHeaderAboveIsRegistery
:
fnode
=
>
closestHeaderAboveMatchesRegex
(
fnode
.
element
registerStringRegex
)
nextInputIsConfirmy
}
)
rule
(
type
(
"
new
"
)
out
(
"
new
"
)
)
]
coeffs
biases
)
;
}
this
.
NewPasswordModel
=
{
type
:
"
new
"
rules
:
makeRuleset
(
[
.
.
.
coefficients
.
new
]
biases
)
}
;
