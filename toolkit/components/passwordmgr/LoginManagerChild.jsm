"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
LoginManagerChild
"
"
LoginFormState
"
]
;
const
PASSWORD_INPUT_ADDED_COALESCING_THRESHOLD_MS
=
1
;
const
AUTOCOMPLETE_AFTER_RIGHT_CLICK_THRESHOLD_MS
=
400
;
const
AUTOFILL_STATE
=
"
autofill
"
;
const
SUBMIT_FORM_SUBMIT
=
1
;
const
SUBMIT_PAGE_NAVIGATION
=
2
;
const
SUBMIT_FORM_IS_REMOVED
=
3
;
const
LOG_MESSAGE_FORM_SUBMISSION
=
"
form
submission
"
;
const
LOG_MESSAGE_FIELD_EDIT
=
"
field
edit
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
PrivateBrowsingUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
{
CreditCard
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
CreditCard
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
DeferredTask
:
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
FormLikeFactory
:
"
resource
:
/
/
gre
/
modules
/
FormLikeFactory
.
jsm
"
LoginFormFactory
:
"
resource
:
/
/
gre
/
modules
/
LoginFormFactory
.
jsm
"
LoginRecipesContent
:
"
resource
:
/
/
gre
/
modules
/
LoginRecipes
.
jsm
"
LoginHelper
:
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
InsecurePasswordUtils
:
"
resource
:
/
/
gre
/
modules
/
InsecurePasswordUtils
.
jsm
"
ContentDOMReference
:
"
resource
:
/
/
gre
/
modules
/
ContentDOMReference
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
gFormFillService
"
"
mozilla
.
org
/
satchel
/
form
-
fill
-
controller
;
1
"
"
nsIFormFillController
"
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
log
"
(
)
=
>
{
let
logger
=
lazy
.
LoginHelper
.
createLogger
(
"
LoginManagerChild
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
Services
.
cpmm
.
addMessageListener
(
"
clearRecipeCache
"
(
)
=
>
{
lazy
.
LoginRecipesContent
.
_clearRecipeCache
(
)
;
}
)
;
let
gLastRightClickTimeStamp
=
Number
.
NEGATIVE_INFINITY
;
class
WeakFieldSet
extends
WeakSet
{
add
(
value
)
{
if
(
!
HTMLInputElement
.
isInstance
(
value
)
)
{
throw
new
Error
(
"
Non
-
field
type
added
to
a
WeakFieldSet
"
)
;
}
super
.
add
(
value
)
;
}
}
const
observer
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
if
(
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
|
|
!
(
aWebProgress
.
loadType
&
Ci
.
nsIDocShell
.
LOAD_CMD_PUSHSTATE
)
)
{
return
;
}
const
window
=
aWebProgress
.
DOMWindow
;
lazy
.
log
(
"
onLocationChange
handled
:
"
aLocation
.
displaySpec
window
.
document
)
;
LoginManagerChild
.
forWindow
(
window
)
.
_onNavigation
(
window
.
document
)
;
}
onStateChange
(
aWebProgress
aRequest
aState
aStatus
)
{
const
window
=
aWebProgress
.
DOMWindow
;
const
loginManagerChild
=
(
)
=
>
LoginManagerChild
.
forWindow
(
window
)
;
if
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_RESTORING
&
&
aState
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
loginManagerChild
(
)
.
_onDocumentRestored
(
window
.
document
)
;
return
;
}
if
(
!
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
)
{
return
;
}
let
channel
=
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
triggeringPrincipal
=
channel
.
loadInfo
.
triggeringPrincipal
;
if
(
triggeringPrincipal
.
isNullPrincipal
|
|
triggeringPrincipal
.
equals
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
)
{
return
;
}
if
(
!
(
aWebProgress
.
loadType
&
Ci
.
nsIDocShell
.
LOAD_CMD_NORMAL
)
)
{
lazy
.
log
(
loadType
isn
'
t
LOAD_CMD_NORMAL
:
{
aWebProgress
.
loadType
}
.
)
;
return
;
}
lazy
.
log
(
Handled
channel
:
{
channel
}
)
;
loginManagerChild
(
)
.
_onNavigation
(
window
.
document
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
autocomplete
-
did
-
enter
-
text
"
:
{
let
input
=
subject
.
QueryInterface
(
Ci
.
nsIAutoCompleteInput
)
;
let
{
selectedIndex
}
=
input
.
popup
;
if
(
selectedIndex
<
0
)
{
break
;
}
let
{
focusedInput
}
=
lazy
.
gFormFillService
;
if
(
focusedInput
.
nodePrincipal
.
isNullPrincipal
)
{
return
;
}
let
window
=
focusedInput
.
ownerGlobal
;
let
loginManagerChild
=
LoginManagerChild
.
forWindow
(
window
)
;
let
style
=
input
.
controller
.
getStyleAt
(
selectedIndex
)
;
if
(
style
=
=
"
login
"
|
|
style
=
=
"
loginWithOrigin
"
)
{
let
details
=
JSON
.
parse
(
input
.
controller
.
getCommentAt
(
selectedIndex
)
)
;
loginManagerChild
.
onFieldAutoComplete
(
focusedInput
details
.
guid
)
;
}
else
if
(
style
=
=
"
generatedPassword
"
)
{
loginManagerChild
.
_filledWithGeneratedPassword
(
focusedInput
)
;
}
break
;
}
}
}
handleEvent
(
aEvent
)
{
if
(
!
aEvent
.
isTrusted
)
{
return
;
}
if
(
!
lazy
.
LoginHelper
.
enabled
)
{
return
;
}
const
ownerDocument
=
aEvent
.
target
.
ownerDocument
;
const
window
=
ownerDocument
.
defaultView
;
const
loginManagerChild
=
LoginManagerChild
.
forWindow
(
window
)
;
const
docState
=
loginManagerChild
.
stateForDocument
(
ownerDocument
)
;
const
field
=
aEvent
.
composedTarget
;
switch
(
aEvent
.
type
)
{
case
"
blur
"
:
{
if
(
docState
.
generatedPasswordFields
.
has
(
field
)
)
{
docState
.
_togglePasswordFieldMasking
(
field
false
)
;
}
break
;
}
case
"
change
"
:
{
let
formLikeRoot
=
lazy
.
FormLikeFactory
.
findRootForField
(
field
)
;
if
(
!
docState
.
fieldModificationsByRootElement
.
get
(
formLikeRoot
)
)
{
lazy
.
log
(
"
Ignoring
change
event
on
form
that
hasn
'
t
been
user
-
modified
.
"
)
;
if
(
field
.
hasBeenTypePassword
)
{
loginManagerChild
.
_ignorePasswordEdit
(
)
;
}
break
;
}
docState
.
storeUserInput
(
field
)
;
let
detail
=
{
possibleValues
:
{
usernames
:
docState
.
possibleUsernames
passwords
:
docState
.
possiblePasswords
}
}
;
loginManagerChild
.
sendAsyncMessage
(
"
PasswordManager
:
updateDoorhangerSuggestions
"
detail
)
;
if
(
field
.
hasBeenTypePassword
)
{
let
triggeredByFillingGenerated
=
docState
.
generatedPasswordFields
.
has
(
field
)
;
if
(
triggeredByFillingGenerated
)
{
loginManagerChild
.
_passwordEditedOrGenerated
(
field
{
triggeredByFillingGenerated
}
)
;
}
else
{
loginManagerChild
.
_ignorePasswordEdit
(
)
;
}
}
break
;
}
case
"
input
"
:
{
let
isPasswordType
=
lazy
.
LoginHelper
.
isPasswordFieldType
(
field
)
;
if
(
docState
.
generatedPasswordFields
.
has
(
field
)
&
&
loginManagerChild
.
_doesEventClearPrevFieldValue
(
aEvent
)
)
{
docState
.
_stopTreatingAsGeneratedPasswordField
(
field
)
;
}
if
(
!
isPasswordType
&
&
!
lazy
.
LoginHelper
.
isUsernameFieldType
(
field
)
)
{
break
;
}
let
formLikeRoot
=
lazy
.
FormLikeFactory
.
findRootForField
(
field
)
;
if
(
formLikeRoot
!
=
=
aEvent
.
currentTarget
)
{
break
;
}
let
alreadyModified
=
docState
.
fieldModificationsByRootElement
.
get
(
formLikeRoot
)
;
let
{
login
:
filledLogin
userTriggered
:
fillWasUserTriggered
}
=
docState
.
fillsByRootElement
.
get
(
formLikeRoot
)
|
|
{
}
;
let
isAutofillInput
=
filledLogin
&
&
!
fillWasUserTriggered
;
if
(
!
alreadyModified
&
&
isAutofillInput
)
{
if
(
isPasswordType
&
&
filledLogin
.
password
=
=
field
.
value
)
{
lazy
.
log
(
"
Ignoring
password
input
event
that
doesn
'
t
change
autofilled
values
.
"
)
;
break
;
}
if
(
!
isPasswordType
&
&
filledLogin
.
usernameField
&
&
filledLogin
.
username
=
=
field
.
value
)
{
lazy
.
log
(
"
Ignoring
username
input
event
that
doesn
'
t
change
autofilled
values
.
"
)
;
break
;
}
}
docState
.
fieldModificationsByRootElement
.
set
(
formLikeRoot
true
)
;
let
alreadyModifiedFormLessField
=
true
;
if
(
!
HTMLFormElement
.
isInstance
(
formLikeRoot
)
)
{
alreadyModifiedFormLessField
=
docState
.
formlessModifiedPasswordFields
.
has
(
field
)
;
if
(
!
alreadyModifiedFormLessField
)
{
docState
.
formlessModifiedPasswordFields
.
add
(
field
)
;
}
}
if
(
lazy
.
LoginHelper
.
formRemovalCaptureEnabled
&
&
(
!
alreadyModified
|
|
!
alreadyModifiedFormLessField
)
)
{
ownerDocument
.
setNotifyFetchSuccess
(
true
)
;
}
if
(
isPasswordType
&
&
loginManagerChild
.
_doesEventClearPrevFieldValue
(
aEvent
)
&
&
filledLogin
&
&
filledLogin
.
password
!
=
=
field
.
value
)
{
docState
.
fillsByRootElement
.
delete
(
formLikeRoot
)
;
}
if
(
!
lazy
.
LoginHelper
.
passwordEditCaptureEnabled
)
{
break
;
}
if
(
field
.
hasBeenTypePassword
)
{
let
form
=
lazy
.
LoginFormFactory
.
createFromField
(
field
)
;
if
(
docState
.
generatedPasswordFields
.
has
(
field
)
&
&
docState
.
_getFormFields
(
form
)
.
confirmPasswordField
=
=
=
field
)
{
break
;
}
loginManagerChild
.
_passwordEditedOrGenerated
(
field
)
;
}
else
{
let
[
usernameField
passwordField
]
=
docState
.
getUserNameAndPasswordFields
(
field
)
;
if
(
field
=
=
usernameField
&
&
passwordField
?
.
value
)
{
loginManagerChild
.
_passwordEditedOrGenerated
(
passwordField
{
triggeredByFillingGenerated
:
docState
.
generatedPasswordFields
.
has
(
passwordField
)
}
)
;
}
}
break
;
}
case
"
keydown
"
:
{
if
(
field
.
value
&
&
(
aEvent
.
keyCode
=
=
aEvent
.
DOM_VK_TAB
|
|
aEvent
.
keyCode
=
=
aEvent
.
DOM_VK_RETURN
)
)
{
const
autofillForm
=
lazy
.
LoginHelper
.
autofillForms
&
&
!
PrivateBrowsingUtils
.
isContentWindowPrivate
(
ownerDocument
.
defaultView
)
;
if
(
autofillForm
)
{
loginManagerChild
.
onUsernameAutocompleted
(
field
)
;
}
}
break
;
}
case
"
focus
"
:
{
docState
.
onFocus
(
field
aEvent
.
target
)
;
break
;
}
case
"
mousedown
"
:
{
if
(
aEvent
.
button
=
=
2
)
{
gLastRightClickTimeStamp
=
Date
.
now
(
)
;
}
break
;
}
default
:
{
throw
new
Error
(
"
Unexpected
event
"
)
;
}
}
}
}
;
Services
.
obs
.
addObserver
(
observer
"
autocomplete
-
did
-
enter
-
text
"
)
;
class
LoginFormState
{
fillsByRootElement
=
new
WeakMap
(
)
;
generatedPasswordFields
=
new
WeakFieldSet
(
)
;
lastSubmittedValuesByRootElement
=
new
WeakMap
(
)
;
fieldModificationsByRootElement
=
new
WeakMap
(
)
;
loginFormRootElements
=
new
WeakSet
(
)
;
possibleUsernames
=
new
Set
(
)
;
possiblePasswords
=
new
Set
(
)
;
formLikeByObservedNode
=
new
WeakMap
(
)
;
formlessModifiedPasswordFields
=
new
WeakFieldSet
(
)
;
#
cachedIsInferredUsernameField
=
new
WeakMap
(
)
;
cachedIsInferredEmailField
=
new
WeakMap
(
)
;
#
cachedIsInferredLoginForm
=
new
WeakMap
(
)
;
mockUsernameOnlyField
=
null
;
numFormHasPossibleUsernameEvent
=
0
;
captureLoginTimeStamp
=
0
;
storeUserInput
(
field
)
{
if
(
field
.
value
&
&
lazy
.
LoginHelper
.
captureInputChanges
)
{
if
(
lazy
.
LoginHelper
.
isPasswordFieldType
(
field
)
)
{
this
.
possiblePasswords
.
add
(
field
.
value
)
;
}
else
if
(
lazy
.
LoginHelper
.
isUsernameFieldType
(
field
)
)
{
this
.
possibleUsernames
.
add
(
field
.
value
)
;
}
}
}
isProbablyAnEmailField
(
inputElement
)
{
let
result
=
this
.
cachedIsInferredEmailField
.
get
(
inputElement
)
;
if
(
result
=
=
=
undefined
)
{
result
=
lazy
.
LoginHelper
.
isInferredEmailField
(
inputElement
)
;
this
.
cachedIsInferredEmailField
.
set
(
inputElement
result
)
;
}
return
result
;
}
isProbablyAUsernameField
(
inputElement
)
{
let
result
=
this
.
#
cachedIsInferredUsernameField
.
get
(
inputElement
)
;
if
(
result
=
=
=
undefined
)
{
result
=
lazy
.
LoginHelper
.
isInferredUsernameField
(
inputElement
)
;
this
.
#
cachedIsInferredUsernameField
.
set
(
inputElement
result
)
;
}
return
result
;
}
#
isProbablyAUsernameLoginForm
(
formElement
inputElement
)
{
let
result
=
this
.
#
cachedIsInferredLoginForm
.
get
(
formElement
)
;
if
(
result
=
=
=
undefined
)
{
result
=
false
;
if
(
this
.
isProbablyAUsernameField
(
inputElement
)
|
|
lazy
.
LoginHelper
.
isInferredLoginForm
(
formElement
)
)
{
if
(
!
lazy
.
LoginHelper
.
isInferredNonUsernameField
(
inputElement
)
)
{
result
=
true
;
}
}
this
.
#
cachedIsInferredLoginForm
.
set
(
formElement
result
)
;
}
return
result
;
}
#
isLoginAlreadyFilled
(
aUsernameField
)
{
let
formLikeRoot
=
lazy
.
FormLikeFactory
.
findRootForField
(
aUsernameField
)
;
let
existingLoginForm
=
lazy
.
LoginFormFactory
.
getForRootElement
(
formLikeRoot
)
;
if
(
!
existingLoginForm
)
{
throw
new
Error
(
"
#
isLoginAlreadyFilled
called
with
a
username
field
with
"
+
"
no
rootElement
LoginForm
"
)
;
}
let
{
login
:
filledLogin
}
=
this
.
fillsByRootElement
.
get
(
formLikeRoot
)
|
|
{
}
;
if
(
!
filledLogin
)
{
return
false
;
}
let
autoFilledUsernameField
=
filledLogin
.
usernameField
?
.
get
(
)
;
let
autoFilledPasswordField
=
filledLogin
.
passwordField
?
.
get
(
)
;
if
(
!
autoFilledUsernameField
|
|
autoFilledUsernameField
!
=
aUsernameField
|
|
autoFilledUsernameField
.
value
!
=
filledLogin
.
username
|
|
(
autoFilledPasswordField
&
&
autoFilledPasswordField
.
value
!
=
filledLogin
.
password
)
)
{
return
false
;
}
return
true
;
}
_togglePasswordFieldMasking
(
passwordField
unmask
)
{
let
{
editor
}
=
passwordField
;
if
(
passwordField
.
type
!
=
"
password
"
)
{
lazy
.
log
(
"
Field
isn
'
t
type
=
password
.
"
)
;
return
;
}
if
(
!
unmask
&
&
!
editor
)
{
return
;
}
if
(
unmask
)
{
editor
.
unmask
(
0
)
;
return
;
}
if
(
editor
.
autoMaskingEnabled
)
{
return
;
}
editor
.
mask
(
)
;
}
_treatAsGeneratedPasswordField
(
passwordField
)
{
this
.
generatedPasswordFields
.
add
(
passwordField
)
;
for
(
let
eventType
of
[
"
blur
"
"
focus
"
]
)
{
passwordField
.
addEventListener
(
eventType
observer
{
capture
:
true
mozSystemGroup
:
true
}
)
;
}
if
(
passwordField
.
ownerDocument
.
activeElement
=
=
passwordField
)
{
this
.
_togglePasswordFieldMasking
(
passwordField
true
)
;
}
}
_formHasModifiedFields
(
form
)
{
const
doc
=
form
.
rootElement
.
ownerDocument
;
let
userHasInteracted
;
const
testOnlyUserHasInteracted
=
lazy
.
LoginHelper
.
testOnlyUserHasInteractedWithDocument
;
if
(
Cu
.
isInAutomation
&
&
testOnlyUserHasInteracted
!
=
=
null
)
{
userHasInteracted
=
testOnlyUserHasInteracted
;
}
else
{
userHasInteracted
=
!
lazy
.
LoginHelper
.
userInputRequiredToCapture
|
|
this
.
captureLoginTimeStamp
!
=
doc
.
lastUserGestureTimeStamp
;
}
lazy
.
log
(
_formHasModifiedFields
:
userHasInteracted
:
{
userHasInteracted
}
.
)
;
if
(
!
userHasInteracted
)
{
return
false
;
}
let
fieldsModified
=
this
.
fieldModificationsByRootElement
.
get
(
form
.
rootElement
)
;
if
(
!
fieldsModified
)
{
fieldsModified
=
Array
.
from
(
form
.
elements
)
.
some
(
field
=
>
field
.
defaultValue
!
=
=
undefined
&
&
field
.
value
!
=
=
field
.
defaultValue
)
;
}
return
fieldsModified
;
}
_stopTreatingAsGeneratedPasswordField
(
passwordField
)
{
this
.
generatedPasswordFields
.
delete
(
passwordField
)
;
for
(
let
eventType
of
[
"
blur
"
"
focus
"
]
)
{
passwordField
.
removeEventListener
(
eventType
observer
{
capture
:
true
mozSystemGroup
:
true
}
)
;
}
this
.
_togglePasswordFieldMasking
(
passwordField
false
)
;
}
onFocus
(
field
focusedField
)
{
if
(
field
.
hasBeenTypePassword
&
&
this
.
generatedPasswordFields
.
has
(
field
)
)
{
this
.
_togglePasswordFieldMasking
(
field
true
)
;
return
;
}
this
.
#
onUsernameFocus
(
focusedField
)
;
}
#
onUsernameFocus
(
focusedField
)
{
if
(
!
focusedField
.
mozIsTextField
(
true
)
|
|
focusedField
.
hasBeenTypePassword
|
|
focusedField
.
readOnly
)
{
return
;
}
if
(
this
.
#
isLoginAlreadyFilled
(
focusedField
)
)
{
lazy
.
log
(
"
Login
already
filled
.
"
)
;
return
;
}
let
timeDiff
=
Date
.
now
(
)
-
gLastRightClickTimeStamp
;
if
(
timeDiff
<
AUTOCOMPLETE_AFTER_RIGHT_CLICK_THRESHOLD_MS
)
{
lazy
.
log
(
Not
opening
autocomplete
after
focus
since
a
context
menu
was
opened
within
{
timeDiff
}
ms
.
)
;
return
;
}
lazy
.
log
(
"
Opening
the
autocomplete
popup
.
"
)
;
lazy
.
gFormFillService
.
showPopup
(
)
;
}
static
#
removeFillFieldHighlight
(
event
)
{
let
winUtils
=
event
.
target
.
ownerGlobal
.
windowUtils
;
winUtils
.
removeManuallyManagedState
(
event
.
target
AUTOFILL_STATE
)
;
}
static
_highlightFilledField
(
element
)
{
let
winUtils
=
element
.
ownerGlobal
.
windowUtils
;
winUtils
.
addManuallyManagedState
(
element
AUTOFILL_STATE
)
;
element
.
addEventListener
(
"
input
"
LoginFormState
.
#
removeFillFieldHighlight
{
mozSystemGroup
:
true
once
:
true
}
)
;
}
getUsernameFieldFromUsernameOnlyForm
(
formElement
recipe
=
null
)
{
if
(
!
HTMLFormElement
.
isInstance
(
formElement
)
)
{
return
null
;
}
let
candidate
=
null
;
for
(
let
element
of
formElement
.
elements
)
{
if
(
element
.
hasBeenTypePassword
)
{
return
null
;
}
if
(
!
lazy
.
LoginHelper
.
isUsernameFieldType
(
element
)
)
{
continue
;
}
if
(
recipe
?
.
notUsernameSelector
&
&
element
.
matches
(
recipe
.
notUsernameSelector
)
)
{
continue
;
}
if
(
candidate
)
{
return
null
;
}
candidate
=
element
;
}
if
(
candidate
&
&
this
.
#
isProbablyAUsernameLoginForm
(
formElement
candidate
)
)
{
return
candidate
;
}
return
null
;
}
static
_getPasswordFields
(
form
{
fieldOverrideRecipe
=
null
minPasswordLength
=
0
ignoreConnect
=
false
}
=
{
}
)
{
let
pwFields
=
[
]
;
for
(
let
i
=
0
;
i
<
form
.
elements
.
length
;
i
+
+
)
{
let
element
=
form
.
elements
[
i
]
;
if
(
!
HTMLInputElement
.
isInstance
(
element
)
|
|
!
element
.
hasBeenTypePassword
|
|
(
!
element
.
isConnected
&
&
!
ignoreConnect
)
)
{
continue
;
}
if
(
fieldOverrideRecipe
?
.
notPasswordSelector
&
&
element
.
matches
(
fieldOverrideRecipe
.
notPasswordSelector
)
)
{
lazy
.
log
(
Skipping
password
field
with
id
:
{
element
.
id
}
name
:
{
element
.
name
}
due
to
recipe
{
fieldOverrideRecipe
}
.
)
;
continue
;
}
if
(
minPasswordLength
&
&
element
.
value
.
trim
(
)
.
length
<
minPasswordLength
)
{
lazy
.
log
(
Skipping
password
field
with
id
:
{
element
.
id
}
name
:
{
element
.
name
}
as
value
is
too
short
.
)
;
continue
;
}
pwFields
[
pwFields
.
length
]
=
{
index
:
i
element
}
;
}
if
(
!
pwFields
.
length
)
{
lazy
.
log
(
"
Form
ignored
no
password
fields
.
"
)
;
return
null
;
}
if
(
pwFields
.
length
>
5
)
{
lazy
.
log
(
Form
ignored
too
many
password
fields
:
{
pwFields
.
length
}
.
)
;
return
null
;
}
return
pwFields
;
}
compareAndUpdatePreviouslySentValues
(
formLikeRoot
usernameValue
passwordValue
dismissed
=
false
triggeredByFillingGenerated
=
false
)
{
const
lastSentValues
=
this
.
lastSubmittedValuesByRootElement
.
get
(
formLikeRoot
)
;
if
(
lastSentValues
)
{
if
(
dismissed
&
&
!
lastSentValues
.
dismissed
)
{
dismissed
=
false
;
}
if
(
lastSentValues
.
username
=
=
usernameValue
&
&
lastSentValues
.
password
=
=
passwordValue
&
&
lastSentValues
.
dismissed
=
=
dismissed
&
&
lastSentValues
.
triggeredByFillingGenerated
=
=
triggeredByFillingGenerated
)
{
lazy
.
log
(
"
compareAndUpdatePreviouslySentValues
:
values
are
equivalent
returning
true
.
"
)
;
return
true
;
}
}
this
.
lastSubmittedValuesByRootElement
.
set
(
formLikeRoot
{
username
:
usernameValue
password
:
passwordValue
dismissed
triggeredByFillingGenerated
}
)
;
lazy
.
log
(
"
compareAndUpdatePreviouslySentValues
:
values
not
equivalent
returning
false
.
"
)
;
return
false
;
}
fillConfirmFieldWithGeneratedPassword
(
passwordField
)
{
let
form
=
lazy
.
LoginFormFactory
.
createFromField
(
passwordField
)
;
let
confirmPasswordInput
=
null
;
let
MAX_CONFIRM_PASSWORD_DISTANCE
=
3
;
let
startIndex
=
form
.
elements
.
indexOf
(
passwordField
)
;
if
(
startIndex
=
=
-
1
)
{
throw
new
Error
(
"
Password
field
is
not
in
the
form
'
s
elements
collection
"
)
;
}
let
previousGeneratedPasswordField
=
form
.
elements
.
some
(
inp
=
>
inp
!
=
=
passwordField
&
&
this
.
generatedPasswordFields
.
has
(
inp
)
)
;
if
(
previousGeneratedPasswordField
)
{
lazy
.
log
(
"
Previously
-
filled
generated
password
input
found
.
"
)
;
return
;
}
let
afterFields
=
form
.
elements
.
slice
(
startIndex
+
1
)
.
filter
(
elem
=
>
elem
.
type
!
=
=
"
hidden
"
)
;
let
acFieldName
=
passwordField
.
getAutocompleteInfo
(
)
?
.
fieldName
;
if
(
acFieldName
=
=
"
new
-
password
"
)
{
let
matchIndex
=
afterFields
.
findIndex
(
elem
=
>
lazy
.
LoginHelper
.
isPasswordFieldType
(
elem
)
&
&
elem
.
getAutocompleteInfo
(
)
.
fieldName
=
=
acFieldName
&
&
!
elem
.
disabled
&
&
!
elem
.
readOnly
)
;
if
(
matchIndex
>
=
0
&
&
matchIndex
<
MAX_CONFIRM_PASSWORD_DISTANCE
)
{
confirmPasswordInput
=
afterFields
[
matchIndex
]
;
}
}
if
(
!
confirmPasswordInput
)
{
for
(
let
idx
=
0
;
idx
<
Math
.
min
(
MAX_CONFIRM_PASSWORD_DISTANCE
afterFields
.
length
)
;
idx
+
+
)
{
if
(
lazy
.
LoginHelper
.
isPasswordFieldType
(
afterFields
[
idx
]
)
&
&
!
afterFields
[
idx
]
.
disabled
&
&
!
afterFields
[
idx
]
.
readOnly
)
{
confirmPasswordInput
=
afterFields
[
idx
]
;
break
;
}
}
}
if
(
confirmPasswordInput
&
&
!
confirmPasswordInput
.
value
)
{
this
.
_treatAsGeneratedPasswordField
(
confirmPasswordInput
)
;
confirmPasswordInput
.
setUserInput
(
passwordField
.
value
)
;
LoginFormState
.
_highlightFilledField
(
confirmPasswordInput
)
;
}
}
_getFormFields
(
form
isSubmission
recipes
{
ignoreConnect
=
false
}
=
{
}
)
{
let
usernameField
=
null
;
let
newPasswordField
=
null
;
let
oldPasswordField
=
null
;
let
confirmPasswordField
=
null
;
let
emptyResult
=
{
usernameField
:
null
newPasswordField
:
null
oldPasswordField
:
null
confirmPasswordField
:
null
}
;
let
pwFields
=
null
;
let
fieldOverrideRecipe
=
lazy
.
LoginRecipesContent
.
getFieldOverrides
(
recipes
form
)
;
if
(
fieldOverrideRecipe
)
{
lazy
.
log
(
"
fieldOverrideRecipe
found
"
fieldOverrideRecipe
)
;
let
pwOverrideField
=
lazy
.
LoginRecipesContent
.
queryLoginField
(
form
fieldOverrideRecipe
.
passwordSelector
)
;
if
(
pwOverrideField
)
{
lazy
.
log
(
"
pwOverrideField
found
"
pwOverrideField
)
;
let
formLike
=
lazy
.
LoginFormFactory
.
createFromField
(
pwOverrideField
)
;
pwFields
=
[
{
index
:
[
.
.
.
formLike
.
elements
]
.
indexOf
(
pwOverrideField
)
element
:
pwOverrideField
}
]
;
}
let
usernameOverrideField
=
lazy
.
LoginRecipesContent
.
queryLoginField
(
form
fieldOverrideRecipe
.
usernameSelector
)
;
if
(
usernameOverrideField
)
{
usernameField
=
usernameOverrideField
;
}
}
if
(
!
pwFields
)
{
const
minSubmitPasswordLength
=
2
;
pwFields
=
LoginFormState
.
_getPasswordFields
(
form
{
fieldOverrideRecipe
minPasswordLength
:
isSubmission
?
minSubmitPasswordLength
:
0
ignoreConnect
}
)
;
}
if
(
!
pwFields
)
{
if
(
!
lazy
.
LoginHelper
.
usernameOnlyFormEnabled
)
{
return
emptyResult
;
}
usernameField
=
this
.
getUsernameFieldFromUsernameOnlyForm
(
form
.
rootElement
fieldOverrideRecipe
)
;
if
(
usernameField
)
{
lazy
.
log
(
Found
username
field
with
name
:
{
usernameField
.
name
}
.
)
;
}
return
{
.
.
.
emptyResult
usernameField
}
;
}
if
(
!
usernameField
)
{
for
(
let
i
=
pwFields
[
0
]
.
index
-
1
;
i
>
=
0
;
i
-
-
)
{
let
element
=
form
.
elements
[
i
]
;
if
(
!
lazy
.
LoginHelper
.
isUsernameFieldType
(
element
{
ignoreConnect
}
)
)
{
continue
;
}
if
(
fieldOverrideRecipe
?
.
notUsernameSelector
&
&
element
.
matches
(
fieldOverrideRecipe
.
notUsernameSelector
)
)
{
continue
;
}
if
(
!
usernameField
)
{
usernameField
=
element
;
}
if
(
this
.
isProbablyAUsernameField
(
element
)
)
{
usernameField
=
element
;
break
;
}
else
if
(
this
.
isProbablyAnEmailField
(
element
)
)
{
usernameField
=
element
;
}
}
}
if
(
!
usernameField
)
{
lazy
.
log
(
"
No
username
field
found
.
"
)
;
}
else
{
lazy
.
log
(
Found
username
field
with
name
:
{
usernameField
.
name
}
.
)
;
}
let
pwGeneratedFields
=
pwFields
.
filter
(
pwField
=
>
this
.
generatedPasswordFields
.
has
(
pwField
.
element
)
)
;
if
(
pwGeneratedFields
.
length
)
{
[
newPasswordField
confirmPasswordField
]
=
pwGeneratedFields
.
map
(
pwField
=
>
pwField
.
element
)
;
let
idx
=
pwFields
.
findIndex
(
pwField
=
>
pwField
.
element
=
=
=
newPasswordField
)
;
if
(
idx
>
0
)
{
oldPasswordField
=
pwFields
[
idx
-
1
]
.
element
;
}
return
{
.
.
.
emptyResult
usernameField
newPasswordField
oldPasswordField
:
oldPasswordField
|
|
null
confirmPasswordField
:
confirmPasswordField
|
|
null
}
;
}
if
(
!
isSubmission
|
|
pwFields
.
length
=
=
1
)
{
let
passwordField
=
pwFields
[
0
]
.
element
;
lazy
.
log
(
Found
Password
field
with
name
:
{
passwordField
.
name
}
.
)
;
return
{
.
.
.
emptyResult
usernameField
newPasswordField
:
passwordField
oldPasswordField
:
null
}
;
}
let
pw1
=
pwFields
[
0
]
.
element
.
value
;
let
pw2
=
pwFields
[
1
]
?
pwFields
[
1
]
.
element
.
value
:
null
;
let
pw3
=
pwFields
[
2
]
?
pwFields
[
2
]
.
element
.
value
:
null
;
if
(
pwFields
.
length
=
=
3
)
{
if
(
pw1
=
=
pw2
&
&
pw2
=
=
pw3
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
null
;
}
else
if
(
pw1
=
=
pw2
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
pwFields
[
2
]
.
element
;
}
else
if
(
pw2
=
=
pw3
)
{
oldPasswordField
=
pwFields
[
0
]
.
element
;
newPasswordField
=
pwFields
[
2
]
.
element
;
}
else
if
(
pw1
=
=
pw3
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
pwFields
[
1
]
.
element
;
}
else
{
lazy
.
log
(
Form
ignored
-
-
all
3
pw
fields
differ
.
)
;
return
emptyResult
;
}
}
else
if
(
pw1
=
=
pw2
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
null
;
}
else
{
oldPasswordField
=
pwFields
[
0
]
.
element
;
newPasswordField
=
pwFields
[
1
]
.
element
;
}
lazy
.
log
(
New
Password
field
id
:
{
newPasswordField
.
id
}
name
:
{
newPasswordField
.
name
}
.
)
;
lazy
.
log
(
oldPasswordField
?
Old
Password
field
id
:
{
oldPasswordField
.
id
}
name
:
{
oldPasswordField
.
name
}
.
:
"
No
Old
password
field
.
"
)
;
return
{
.
.
.
emptyResult
usernameField
newPasswordField
oldPasswordField
}
;
}
getUserNameAndPasswordFields
(
aField
)
{
const
noResult
=
[
null
null
null
]
;
if
(
!
HTMLInputElement
.
isInstance
(
aField
)
)
{
throw
new
Error
(
"
getUserNameAndPasswordFields
:
input
element
required
"
)
;
}
if
(
aField
.
nodePrincipal
.
isNullPrincipal
|
|
!
aField
.
isConnected
)
{
return
noResult
;
}
if
(
!
aField
.
hasBeenTypePassword
&
&
!
lazy
.
LoginHelper
.
isUsernameFieldType
(
aField
)
)
{
return
noResult
;
}
const
form
=
lazy
.
LoginFormFactory
.
createFromField
(
aField
)
;
const
doc
=
aField
.
ownerDocument
;
const
formOrigin
=
lazy
.
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
const
recipes
=
lazy
.
LoginRecipesContent
.
getRecipes
(
formOrigin
doc
.
defaultView
)
;
const
{
usernameField
newPasswordField
oldPasswordField
}
=
this
.
_getFormFields
(
form
false
recipes
)
;
return
[
usernameField
newPasswordField
oldPasswordField
]
;
}
getFieldContext
(
aField
)
{
if
(
!
HTMLInputElement
.
isInstance
(
aField
)
|
|
(
!
aField
.
hasBeenTypePassword
&
&
!
lazy
.
LoginHelper
.
isUsernameFieldType
(
aField
)
)
|
|
aField
.
nodePrincipal
.
isNullPrincipal
|
|
aField
.
nodePrincipal
.
schemeIs
(
"
about
"
)
|
|
!
aField
.
ownerDocument
)
{
return
null
;
}
let
{
hasBeenTypePassword
}
=
aField
;
const
LOGIN_FIELD_ORDER
=
[
"
username
"
"
new
-
password
"
"
current
-
password
"
]
;
let
usernameAndPasswordFields
=
this
.
getUserNameAndPasswordFields
(
aField
)
;
let
fieldNameHint
;
let
indexOfFieldInUsernameAndPasswordFields
=
usernameAndPasswordFields
.
indexOf
(
aField
)
;
if
(
indexOfFieldInUsernameAndPasswordFields
=
=
-
1
)
{
fieldNameHint
=
hasBeenTypePassword
?
"
current
-
password
"
:
"
other
"
;
}
else
{
fieldNameHint
=
LOGIN_FIELD_ORDER
[
indexOfFieldInUsernameAndPasswordFields
]
;
}
let
[
newPasswordField
]
=
usernameAndPasswordFields
;
return
{
activeField
:
{
disabled
:
aField
.
disabled
|
|
aField
.
readOnly
fieldNameHint
}
passwordField
:
{
found
:
!
!
newPasswordField
disabled
:
newPasswordField
&
&
(
newPasswordField
.
disabled
|
|
newPasswordField
.
readOnly
)
}
}
;
}
}
class
LoginManagerChild
extends
JSWindowActorChild
{
#
deferredPasswordAddedTasksByRootElement
=
new
WeakMap
(
)
;
#
visibleTasksByDocument
=
new
WeakMap
(
)
;
#
loginFormStateByDocument
=
new
WeakMap
(
)
;
#
fieldsWithPasswordGenerationForcedOn
=
new
WeakSet
(
)
;
static
forWindow
(
window
)
{
return
window
.
windowGlobalChild
?
.
getActor
(
"
LoginManager
"
)
;
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
PasswordManager
:
fillForm
"
:
{
this
.
fillForm
(
{
loginFormOrigin
:
msg
.
data
.
loginFormOrigin
loginsFound
:
lazy
.
LoginHelper
.
vanillaObjectsToLogins
(
msg
.
data
.
logins
)
recipes
:
msg
.
data
.
recipes
inputElementIdentifier
:
msg
.
data
.
inputElementIdentifier
originMatches
:
msg
.
data
.
originMatches
style
:
msg
.
data
.
style
}
)
;
break
;
}
case
"
PasswordManager
:
useGeneratedPassword
"
:
{
this
.
#
onUseGeneratedPassword
(
msg
.
data
.
inputElementIdentifier
)
;
break
;
}
case
"
PasswordManager
:
repopulateAutocompletePopup
"
:
{
this
.
repopulateAutocompletePopup
(
)
;
break
;
}
case
"
PasswordManager
:
formIsPending
"
:
{
return
this
.
#
visibleTasksByDocument
.
has
(
this
.
document
)
;
}
case
"
PasswordManager
:
formProcessed
"
:
{
this
.
notifyObserversOfFormProcessed
(
msg
.
data
.
formid
)
;
break
;
}
}
return
undefined
;
}
#
onUseGeneratedPassword
(
inputElementIdentifier
)
{
let
inputElement
=
lazy
.
ContentDOMReference
.
resolve
(
inputElementIdentifier
)
;
if
(
!
inputElement
)
{
lazy
.
log
(
"
Could
not
resolve
inputElementIdentifier
to
a
living
element
.
"
)
;
return
;
}
if
(
inputElement
!
=
lazy
.
gFormFillService
.
focusedInput
)
{
lazy
.
log
(
"
Could
not
open
popup
on
input
that
'
s
no
longer
focused
.
"
)
;
return
;
}
this
.
#
fieldsWithPasswordGenerationForcedOn
.
add
(
inputElement
)
;
this
.
repopulateAutocompletePopup
(
)
;
}
repopulateAutocompletePopup
(
)
{
lazy
.
gFormFillService
.
QueryInterface
(
Ci
.
nsIAutoCompleteInput
)
;
lazy
.
gFormFillService
.
controller
.
resetInternalState
(
)
;
lazy
.
gFormFillService
.
showPopup
(
)
;
}
shouldIgnoreLoginManagerEvent
(
event
)
{
let
nodePrincipal
=
event
.
target
.
nodePrincipal
;
return
(
nodePrincipal
.
isSystemPrincipal
|
|
nodePrincipal
.
isNullPrincipal
|
|
nodePrincipal
.
schemeIs
(
"
about
"
)
)
;
}
handleEvent
(
event
)
{
if
(
AppConstants
.
platform
=
=
"
android
"
&
&
Services
.
prefs
.
getBoolPref
(
"
reftest
.
remote
"
false
)
)
{
return
;
}
if
(
this
.
shouldIgnoreLoginManagerEvent
(
event
)
)
{
return
;
}
switch
(
event
.
type
)
{
case
"
DOMDocFetchSuccess
"
:
{
this
.
#
onDOMDocFetchSuccess
(
event
)
;
break
;
}
case
"
DOMFormBeforeSubmit
"
:
{
this
.
#
onDOMFormBeforeSubmit
(
event
)
;
break
;
}
case
"
DOMFormHasPassword
"
:
{
this
.
#
onDOMFormHasPassword
(
event
)
;
let
formLike
=
lazy
.
LoginFormFactory
.
createFromForm
(
event
.
originalTarget
)
;
lazy
.
InsecurePasswordUtils
.
reportInsecurePasswords
(
formLike
)
;
break
;
}
case
"
DOMFormHasPossibleUsername
"
:
{
this
.
#
onDOMFormHasPossibleUsername
(
event
)
;
break
;
}
case
"
DOMFormRemoved
"
:
case
"
DOMInputPasswordRemoved
"
:
{
this
.
#
onDOMFormRemoved
(
event
)
;
break
;
}
case
"
DOMInputPasswordAdded
"
:
{
this
.
#
onDOMInputPasswordAdded
(
event
this
.
document
.
defaultView
)
;
let
formLike
=
lazy
.
LoginFormFactory
.
createFromField
(
event
.
originalTarget
)
;
lazy
.
InsecurePasswordUtils
.
reportInsecurePasswords
(
formLike
)
;
break
;
}
}
}
notifyObserversOfFormProcessed
(
formid
)
{
Services
.
obs
.
notifyObservers
(
this
"
passwordmgr
-
processed
-
form
"
formid
)
;
}
_getLoginDataFromParent
(
form
options
)
{
let
actionOrigin
=
lazy
.
LoginHelper
.
getFormActionOrigin
(
form
)
;
let
messageData
=
{
actionOrigin
options
}
;
let
resultPromise
=
this
.
sendQuery
(
"
PasswordManager
:
findLogins
"
messageData
)
;
return
resultPromise
.
then
(
result
=
>
{
return
{
form
importable
:
result
.
importable
loginsFound
:
lazy
.
LoginHelper
.
vanillaObjectsToLogins
(
result
.
logins
)
recipes
:
result
.
recipes
}
;
}
)
;
}
setupProgressListener
(
window
)
{
if
(
!
lazy
.
LoginHelper
.
formlessCaptureEnabled
)
{
return
;
}
let
docShell
;
for
(
let
browsingContext
=
BrowsingContext
.
getFromWindow
(
window
)
;
browsingContext
?
.
docShell
;
browsingContext
=
browsingContext
.
parent
)
{
docShell
=
browsingContext
.
docShell
;
}
try
{
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
observer
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
|
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
catch
(
ex
)
{
}
}
#
onDOMDocFetchSuccess
(
event
)
{
let
document
=
event
.
target
;
let
docState
=
this
.
stateForDocument
(
document
)
;
let
weakModificationsRootElements
=
ChromeUtils
.
nondeterministicGetWeakMapKeys
(
docState
.
fieldModificationsByRootElement
)
;
lazy
.
log
(
modificationsByRootElement
approx
size
:
{
weakModificationsRootElements
.
length
}
.
)
;
document
.
setNotifyFormOrPasswordRemoved
(
true
)
;
this
.
docShell
.
chromeEventHandler
.
addEventListener
(
"
DOMFormRemoved
"
this
true
)
;
this
.
docShell
.
chromeEventHandler
.
addEventListener
(
"
DOMInputPasswordRemoved
"
this
true
)
;
for
(
let
rootElement
of
weakModificationsRootElements
)
{
if
(
HTMLFormElement
.
isInstance
(
rootElement
)
)
{
let
formLike
=
lazy
.
LoginFormFactory
.
createFromForm
(
rootElement
)
;
docState
.
formLikeByObservedNode
.
set
(
rootElement
formLike
)
;
}
}
let
weakFormlessModifiedPasswordFields
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
docState
.
formlessModifiedPasswordFields
)
;
lazy
.
log
(
formlessModifiedPasswordFields
approx
size
:
{
weakFormlessModifiedPasswordFields
.
length
}
.
)
;
for
(
let
passwordField
of
weakFormlessModifiedPasswordFields
)
{
let
formLike
=
lazy
.
LoginFormFactory
.
createFromField
(
passwordField
)
;
if
(
formLike
.
elements
.
length
)
{
docState
.
formLikeByObservedNode
.
set
(
passwordField
formLike
)
;
}
}
document
.
setNotifyFetchSuccess
(
false
)
;
}
#
onDOMFormRemoved
(
event
)
{
let
document
=
event
.
composedTarget
.
ownerDocument
;
let
docState
=
this
.
stateForDocument
(
document
)
;
let
formLike
=
docState
.
formLikeByObservedNode
.
get
(
event
.
target
)
;
if
(
!
formLike
)
{
return
;
}
lazy
.
log
(
"
Form
is
removed
.
"
)
;
this
.
_onFormSubmit
(
formLike
SUBMIT_FORM_IS_REMOVED
)
;
docState
.
formLikeByObservedNode
.
delete
(
event
.
target
)
;
let
weakObserveredNodes
=
ChromeUtils
.
nondeterministicGetWeakMapKeys
(
docState
.
formLikeByObservedNode
)
;
if
(
!
weakObserveredNodes
.
length
)
{
document
.
setNotifyFormOrPasswordRemoved
(
false
)
;
this
.
docShell
.
chromeEventHandler
.
removeEventListener
(
"
DOMFormRemoved
"
this
)
;
this
.
docShell
.
chromeEventHandler
.
removeEventListener
(
"
DOMInputPasswordRemoved
"
this
)
;
}
}
#
onDOMFormBeforeSubmit
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
formLike
=
lazy
.
LoginFormFactory
.
createFromForm
(
event
.
target
)
;
this
.
_onFormSubmit
(
formLike
SUBMIT_FORM_SUBMIT
)
;
}
onDocumentVisibilityChange
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
document
=
event
.
target
;
let
onVisibleTasks
=
this
.
#
visibleTasksByDocument
.
get
(
document
)
;
if
(
!
onVisibleTasks
)
{
return
;
}
for
(
let
task
of
onVisibleTasks
)
{
lazy
.
log
(
"
onDocumentVisibilityChange
:
executing
queued
task
.
"
)
;
task
(
)
;
}
this
.
#
visibleTasksByDocument
.
delete
(
document
)
;
}
_deferHandlingEventUntilDocumentVisible
(
event
document
fn
)
{
lazy
.
log
(
Defer
handling
event
document
.
visibilityState
:
{
document
.
visibilityState
}
defer
handling
{
event
.
type
}
.
)
;
let
onVisibleTasks
=
this
.
#
visibleTasksByDocument
.
get
(
document
)
;
if
(
!
onVisibleTasks
)
{
lazy
.
log
(
"
Defer
handling
first
queued
event
and
register
the
visibilitychange
handler
.
"
)
;
onVisibleTasks
=
[
]
;
this
.
#
visibleTasksByDocument
.
set
(
document
onVisibleTasks
)
;
document
.
addEventListener
(
"
visibilitychange
"
event
=
>
{
this
.
onDocumentVisibilityChange
(
event
)
;
}
{
once
:
true
}
)
;
}
onVisibleTasks
.
push
(
fn
)
;
}
#
getIsPrimaryPasswordSet
(
)
{
return
Services
.
cpmm
.
sharedData
.
get
(
"
isPrimaryPasswordSet
"
)
;
}
#
onDOMFormHasPassword
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
const
isPrimaryPasswordSet
=
this
.
#
getIsPrimaryPasswordSet
(
)
;
let
document
=
event
.
target
.
ownerDocument
;
lazy
.
log
(
#
onDOMFormHasPassword
:
visibilityState
:
{
document
.
visibilityState
}
isPrimaryPasswordSet
:
{
isPrimaryPasswordSet
}
.
)
;
if
(
document
.
visibilityState
=
=
"
visible
"
|
|
isPrimaryPasswordSet
)
{
this
.
_processDOMFormHasPasswordEvent
(
event
)
;
}
else
{
this
.
_deferHandlingEventUntilDocumentVisible
(
event
document
(
)
=
>
{
this
.
_processDOMFormHasPasswordEvent
(
event
)
;
}
)
;
}
}
_processDOMFormHasPasswordEvent
(
event
)
{
let
form
=
event
.
target
;
let
formLike
=
lazy
.
LoginFormFactory
.
createFromForm
(
form
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike
)
;
}
#
onDOMFormHasPossibleUsername
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
const
isPrimaryPasswordSet
=
this
.
#
getIsPrimaryPasswordSet
(
)
;
let
document
=
event
.
target
.
ownerDocument
;
lazy
.
log
(
#
onDOMFormHasPossibleUsername
:
visibilityState
:
{
document
.
visibilityState
}
isPrimaryPasswordSet
:
{
isPrimaryPasswordSet
}
.
)
;
let
docState
=
this
.
stateForDocument
(
document
)
;
Services
.
telemetry
.
getHistogramById
(
"
PWMGR_NUM_FORM_HAS_POSSIBLE_USERNAME_EVENT_PER_DOC
"
)
.
add
(
+
+
docState
.
numFormHasPossibleUsernameEvent
)
;
if
(
docState
.
numFormHasPossibleUsernameEvent
>
lazy
.
LoginHelper
.
usernameOnlyFormLookupThreshold
)
{
return
;
}
if
(
document
.
visibilityState
=
=
"
visible
"
|
|
isPrimaryPasswordSet
)
{
this
.
_processDOMFormHasPossibleUsernameEvent
(
event
)
;
}
else
{
this
.
_deferHandlingEventUntilDocumentVisible
(
event
document
(
)
=
>
{
this
.
_processDOMFormHasPossibleUsernameEvent
(
event
)
;
}
)
;
}
}
_processDOMFormHasPossibleUsernameEvent
(
event
)
{
let
form
=
event
.
target
;
let
formLike
=
lazy
.
LoginFormFactory
.
createFromForm
(
form
)
;
let
docState
=
this
.
stateForDocument
(
form
.
ownerDocument
)
;
let
usernameField
=
docState
.
getUsernameFieldFromUsernameOnlyForm
(
form
{
}
)
;
if
(
usernameField
)
{
lazy
.
log
(
"
A
username
-
only
form
is
found
.
"
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike
)
;
}
Services
.
telemetry
.
getHistogramById
(
"
PWMGR_IS_USERNAME_ONLY_FORM
"
)
.
add
(
!
!
usernameField
)
;
}
#
onDOMInputPasswordAdded
(
event
window
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
this
.
setupProgressListener
(
window
)
;
let
pwField
=
event
.
originalTarget
;
if
(
pwField
.
form
)
{
return
;
}
let
document
=
pwField
.
ownerDocument
;
const
isPrimaryPasswordSet
=
this
.
#
getIsPrimaryPasswordSet
(
)
;
lazy
.
log
(
#
onDOMInputPasswordAdded
visibilityState
:
{
document
.
visibilityState
}
isPrimaryPasswordSet
:
{
isPrimaryPasswordSet
}
.
)
;
if
(
document
.
visibilityState
=
=
"
visible
"
|
|
isPrimaryPasswordSet
)
{
this
.
_processDOMInputPasswordAddedEvent
(
event
)
;
}
else
{
this
.
_deferHandlingEventUntilDocumentVisible
(
event
document
(
)
=
>
{
this
.
_processDOMInputPasswordAddedEvent
(
event
)
;
}
)
;
}
}
_processDOMInputPasswordAddedEvent
(
event
)
{
let
pwField
=
event
.
originalTarget
;
let
formLike
=
lazy
.
LoginFormFactory
.
createFromField
(
pwField
)
;
let
deferredTask
=
this
.
#
deferredPasswordAddedTasksByRootElement
.
get
(
formLike
.
rootElement
)
;
if
(
!
deferredTask
)
{
lazy
.
log
(
"
Creating
a
DeferredTask
to
call
_fetchLoginsFromParentAndFillForm
soon
.
"
)
;
lazy
.
LoginFormFactory
.
setForRootElement
(
formLike
.
rootElement
formLike
)
;
deferredTask
=
new
lazy
.
DeferredTask
(
(
)
=
>
{
let
formLike2
=
lazy
.
LoginFormFactory
.
getForRootElement
(
formLike
.
rootElement
)
;
lazy
.
log
(
"
Running
deferred
processing
of
onDOMInputPasswordAdded
.
"
)
;
this
.
#
deferredPasswordAddedTasksByRootElement
.
delete
(
formLike2
.
rootElement
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike2
)
;
}
PASSWORD_INPUT_ADDED_COALESCING_THRESHOLD_MS
0
)
;
this
.
#
deferredPasswordAddedTasksByRootElement
.
set
(
formLike
.
rootElement
deferredTask
)
;
}
let
window
=
pwField
.
ownerGlobal
;
if
(
deferredTask
.
isArmed
)
{
lazy
.
log
(
"
DeferredTask
is
already
armed
so
just
updating
the
LoginForm
.
"
)
;
lazy
.
LoginFormFactory
.
setForRootElement
(
formLike
.
rootElement
formLike
)
;
}
else
if
(
[
"
interactive
"
"
complete
"
]
.
includes
(
window
.
document
.
readyState
)
)
{
lazy
.
log
(
"
Arming
the
DeferredTask
we
just
created
since
document
.
readyState
=
=
'
interactive
'
or
'
complete
'
.
"
)
;
deferredTask
.
arm
(
)
;
}
else
{
window
.
addEventListener
(
"
DOMContentLoaded
"
function
(
)
{
lazy
.
log
(
"
Arming
the
onDOMInputPasswordAdded
DeferredTask
due
to
DOMContentLoaded
.
"
)
;
deferredTask
.
arm
(
)
;
}
{
once
:
true
}
)
;
}
}
_fetchLoginsFromParentAndFillForm
(
form
)
{
if
(
!
lazy
.
LoginHelper
.
enabled
)
{
return
;
}
form
.
rootElement
.
addEventListener
(
"
input
"
observer
{
capture
:
true
mozSystemGroup
:
true
}
)
;
form
.
rootElement
.
addEventListener
(
"
change
"
observer
{
capture
:
true
mozSystemGroup
:
true
}
)
;
this
.
_getLoginDataFromParent
(
form
{
showPrimaryPassword
:
true
}
)
.
then
(
this
.
loginsFound
.
bind
(
this
)
)
.
catch
(
Cu
.
reportError
)
;
}
isPasswordGenerationForcedOn
(
passwordField
)
{
return
this
.
#
fieldsWithPasswordGenerationForcedOn
.
has
(
passwordField
)
;
}
stateForDocument
(
document
)
{
let
loginFormState
=
this
.
#
loginFormStateByDocument
.
get
(
document
)
;
if
(
!
loginFormState
)
{
loginFormState
=
new
LoginFormState
(
)
;
this
.
#
loginFormStateByDocument
.
set
(
document
loginFormState
)
;
}
return
loginFormState
;
}
fillForm
(
{
loginFormOrigin
loginsFound
recipes
inputElementIdentifier
originMatches
style
}
)
{
if
(
!
inputElementIdentifier
)
{
lazy
.
log
(
"
No
input
element
specified
.
"
)
;
return
;
}
let
inputElement
=
lazy
.
ContentDOMReference
.
resolve
(
inputElementIdentifier
)
;
if
(
!
inputElement
)
{
lazy
.
log
(
"
Could
not
resolve
inputElementIdentifier
to
a
living
element
.
"
)
;
return
;
}
if
(
!
originMatches
)
{
if
(
lazy
.
LoginHelper
.
getLoginOrigin
(
inputElement
.
ownerDocument
.
documentURI
)
!
=
loginFormOrigin
)
{
lazy
.
log
(
"
The
requested
origin
doesn
'
t
match
the
one
from
the
"
"
document
.
This
may
mean
we
navigated
to
a
document
from
a
different
"
"
site
before
we
had
a
chance
to
indicate
this
change
in
the
user
"
"
interface
.
"
)
;
return
;
}
}
let
clobberUsername
=
true
;
let
form
=
lazy
.
LoginFormFactory
.
createFromField
(
inputElement
)
;
if
(
inputElement
.
hasBeenTypePassword
)
{
clobberUsername
=
false
;
}
this
.
_fillForm
(
form
loginsFound
recipes
{
inputElement
autofillForm
:
true
clobberUsername
clobberPassword
:
true
userTriggered
:
true
style
}
)
;
}
loginsFound
(
{
form
importable
loginsFound
recipes
}
)
{
let
doc
=
form
.
ownerDocument
;
let
autofillForm
=
lazy
.
LoginHelper
.
autofillForms
&
&
!
PrivateBrowsingUtils
.
isContentWindowPrivate
(
doc
.
defaultView
)
;
let
formOrigin
=
lazy
.
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
lazy
.
LoginRecipesContent
.
cacheRecipes
(
formOrigin
doc
.
defaultView
recipes
)
;
this
.
_fillForm
(
form
loginsFound
recipes
{
autofillForm
importable
}
)
;
}
onFieldAutoComplete
(
acInputField
loginGUID
)
{
if
(
!
lazy
.
LoginHelper
.
enabled
)
{
return
;
}
if
(
!
Document
.
isInstance
(
acInputField
.
ownerDocument
)
)
{
return
;
}
if
(
!
lazy
.
LoginFormFactory
.
createFromField
(
acInputField
)
)
{
return
;
}
if
(
lazy
.
LoginHelper
.
isUsernameFieldType
(
acInputField
)
)
{
this
.
onUsernameAutocompleted
(
acInputField
loginGUID
)
;
}
else
if
(
acInputField
.
hasBeenTypePassword
)
{
const
docState
=
this
.
stateForDocument
(
acInputField
.
ownerDocument
)
;
docState
.
_stopTreatingAsGeneratedPasswordField
(
acInputField
)
;
LoginFormState
.
_highlightFilledField
(
acInputField
)
;
}
}
onUsernameAutocompleted
(
acInputField
loginGUID
=
null
)
{
lazy
.
log
(
Autocompleting
input
field
with
name
:
{
acInputField
.
name
}
)
;
let
acForm
=
lazy
.
LoginFormFactory
.
createFromField
(
acInputField
)
;
let
doc
=
acForm
.
ownerDocument
;
let
formOrigin
=
lazy
.
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
let
recipes
=
lazy
.
LoginRecipesContent
.
getRecipes
(
formOrigin
doc
.
defaultView
)
;
const
docState
=
this
.
stateForDocument
(
acInputField
.
ownerDocument
)
;
let
{
usernameField
newPasswordField
:
passwordField
}
=
docState
.
_getFormFields
(
acForm
false
recipes
)
;
if
(
usernameField
=
=
acInputField
)
{
if
(
passwordField
)
{
this
.
_getLoginDataFromParent
(
acForm
{
guid
:
loginGUID
showPrimaryPassword
:
false
}
)
.
then
(
(
{
form
loginsFound
recipes
}
)
=
>
{
if
(
!
loginGUID
)
{
loginsFound
=
this
.
_filterForExactFormOriginLogins
(
loginsFound
acForm
)
;
let
searchString
=
usernameField
.
value
.
toLowerCase
(
)
;
loginsFound
=
loginsFound
.
filter
(
l
=
>
l
.
username
.
toLowerCase
(
)
=
=
searchString
)
;
}
this
.
_fillForm
(
form
loginsFound
recipes
{
autofillForm
:
true
clobberPassword
:
true
userTriggered
:
true
}
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
else
if
(
loginGUID
!
=
=
null
)
{
LoginFormState
.
_highlightFilledField
(
usernameField
)
;
}
}
else
{
}
}
_isAutocompleteDisabled
(
element
)
{
return
element
?
.
autocomplete
=
=
"
off
"
;
}
_onDocumentRestored
(
aDocument
)
{
let
rootElsWeakSet
=
lazy
.
LoginFormFactory
.
getRootElementsWeakSetForDocument
(
aDocument
)
;
let
weakLoginFormRootElements
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
rootElsWeakSet
)
;
lazy
.
log
(
loginFormRootElements
approx
size
:
{
weakLoginFormRootElements
.
length
}
.
)
;
for
(
let
formRoot
of
weakLoginFormRootElements
)
{
if
(
!
formRoot
.
isConnected
)
{
continue
;
}
let
formLike
=
lazy
.
LoginFormFactory
.
getForRootElement
(
formRoot
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike
)
;
}
}
_onNavigation
(
aDocument
)
{
let
rootElsWeakSet
=
lazy
.
LoginFormFactory
.
getRootElementsWeakSetForDocument
(
aDocument
)
;
let
weakLoginFormRootElements
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
rootElsWeakSet
)
;
lazy
.
log
(
root
elements
approx
size
:
{
weakLoginFormRootElements
.
length
}
)
;
for
(
let
formRoot
of
weakLoginFormRootElements
)
{
if
(
!
formRoot
.
isConnected
)
{
continue
;
}
let
formLike
=
lazy
.
LoginFormFactory
.
getForRootElement
(
formRoot
)
;
this
.
_onFormSubmit
(
formLike
SUBMIT_PAGE_NAVIGATION
)
;
}
}
_onFormSubmit
(
form
reason
)
{
lazy
.
log
(
"
Detected
form
submission
.
"
)
;
this
.
_maybeSendFormInteractionMessage
(
form
"
PasswordManager
:
ShowDoorhanger
"
{
targetField
:
null
isSubmission
:
true
ignoreConnect
:
reason
=
=
SUBMIT_FORM_IS_REMOVED
}
)
;
}
_maybeSendFormInteractionMessage
(
form
messageName
{
targetField
isSubmission
triggeredByFillingGenerated
ignoreConnect
}
)
{
let
logMessagePrefix
=
isSubmission
?
LOG_MESSAGE_FORM_SUBMISSION
:
LOG_MESSAGE_FIELD_EDIT
;
let
doc
=
form
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
passwordField
=
null
;
if
(
targetField
?
.
hasBeenTypePassword
)
{
passwordField
=
targetField
;
}
let
origin
=
lazy
.
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
if
(
!
origin
)
{
lazy
.
log
(
{
logMessagePrefix
}
ignored
-
-
invalid
origin
.
)
;
return
;
}
let
recipes
=
lazy
.
LoginRecipesContent
.
getRecipes
(
origin
win
)
;
const
docState
=
this
.
stateForDocument
(
form
.
ownerDocument
)
;
let
fields
=
{
targetField
.
.
.
docState
.
_getFormFields
(
form
true
recipes
{
ignoreConnect
}
)
}
;
if
(
passwordField
&
&
passwordField
!
=
fields
.
newPasswordField
&
&
passwordField
!
=
fields
.
oldPasswordField
&
&
passwordField
!
=
fields
.
confirmPasswordField
)
{
fields
.
newPasswordField
=
passwordField
;
}
if
(
fields
.
newPasswordField
=
=
null
)
{
if
(
isSubmission
&
&
fields
.
usernameField
)
{
lazy
.
log
(
"
_onFormSubmit
:
username
-
only
form
.
Record
the
username
field
but
not
sending
prompt
.
"
)
;
docState
.
mockUsernameOnlyField
=
{
name
:
fields
.
usernameField
.
name
value
:
fields
.
usernameField
.
value
}
;
}
return
;
}
this
.
_maybeSendFormInteractionMessageContinue
(
form
messageName
{
.
.
.
fields
isSubmission
triggeredByFillingGenerated
}
)
;
if
(
isSubmission
)
{
this
.
sendAsyncMessage
(
"
PasswordManager
:
onFormSubmit
"
{
}
{
fields
isSubmission
triggeredByFillingGenerated
}
)
;
}
}
_maybeSendFormInteractionMessageContinue
(
form
messageName
{
targetField
usernameField
newPasswordField
oldPasswordField
confirmPasswordField
isSubmission
triggeredByFillingGenerated
}
)
{
let
logMessagePrefix
=
isSubmission
?
LOG_MESSAGE_FORM_SUBMISSION
:
LOG_MESSAGE_FIELD_EDIT
;
let
doc
=
form
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
detail
=
{
messageSent
:
false
}
;
try
{
if
(
!
triggeredByFillingGenerated
&
&
PrivateBrowsingUtils
.
isContentWindowPrivate
(
win
)
&
&
!
lazy
.
LoginHelper
.
privateBrowsingCaptureEnabled
)
{
lazy
.
log
(
{
logMessagePrefix
}
ignored
in
private
browsing
mode
.
)
;
return
;
}
if
(
!
lazy
.
LoginHelper
.
enabled
)
{
return
;
}
let
fullyMungedPattern
=
/
^
\
*
+
|
^
+
|
^
\
.
+
/
;
if
(
isSubmission
&
&
newPasswordField
?
.
value
.
match
(
fullyMungedPattern
)
)
{
lazy
.
log
(
"
New
password
looks
munged
.
Not
sending
prompt
.
"
)
;
return
;
}
let
docState
=
this
.
stateForDocument
(
doc
)
;
if
(
!
usernameField
)
{
if
(
docState
.
mockUsernameOnlyField
)
{
usernameField
=
docState
.
mockUsernameOnlyField
;
}
}
if
(
usernameField
?
.
value
.
match
(
/
\
.
{
3
}
|
\
*
{
3
}
|
{
3
}
/
)
)
{
lazy
.
log
(
usernameField
with
name
{
usernameField
.
name
}
looks
munged
setting
to
null
.
)
;
usernameField
=
null
;
}
if
(
(
this
.
_isAutocompleteDisabled
(
form
)
|
|
this
.
_isAutocompleteDisabled
(
usernameField
)
|
|
this
.
_isAutocompleteDisabled
(
newPasswordField
)
|
|
this
.
_isAutocompleteDisabled
(
oldPasswordField
)
)
&
&
!
lazy
.
LoginHelper
.
storeWhenAutocompleteOff
)
{
lazy
.
log
(
{
logMessagePrefix
}
ignored
-
-
autocomplete
=
off
found
.
)
;
return
;
}
let
mockUsername
=
usernameField
?
{
name
:
usernameField
.
name
value
:
usernameField
.
value
}
:
null
;
let
mockPassword
=
{
name
:
newPasswordField
.
name
value
:
newPasswordField
.
value
}
;
let
mockOldPassword
=
oldPasswordField
?
{
name
:
oldPasswordField
.
name
value
:
oldPasswordField
.
value
}
:
null
;
let
usernameValue
=
usernameField
?
.
value
;
let
dismissedPrompt
=
!
isSubmission
;
let
newPasswordFieldValue
=
newPasswordField
.
value
;
if
(
(
!
dismissedPrompt
&
&
CreditCard
.
isValidNumber
(
usernameValue
)
&
&
newPasswordFieldValue
.
trim
(
)
.
match
(
/
^
[
0
-
9
]
{
3
}
/
)
)
|
|
(
CreditCard
.
isValidNumber
(
newPasswordFieldValue
)
&
&
newPasswordField
.
getAutocompleteInfo
(
)
.
fieldName
=
=
"
cc
-
number
"
)
)
{
dismissedPrompt
=
true
;
}
const
fieldsModified
=
docState
.
_formHasModifiedFields
(
form
)
;
if
(
!
fieldsModified
&
&
lazy
.
LoginHelper
.
userInputRequiredToCapture
)
{
if
(
targetField
)
{
throw
new
Error
(
"
No
user
input
on
targetField
"
)
;
}
lazy
.
log
(
{
logMessagePrefix
}
ignored
-
-
submitting
values
that
are
not
changed
by
the
user
.
)
;
return
;
}
if
(
docState
.
compareAndUpdatePreviouslySentValues
(
form
.
rootElement
usernameValue
newPasswordField
.
value
dismissedPrompt
triggeredByFillingGenerated
)
)
{
lazy
.
log
(
{
logMessagePrefix
}
ignored
-
-
already
submitted
with
the
same
username
and
password
.
)
;
return
;
}
let
{
login
:
autoFilledLogin
}
=
docState
.
fillsByRootElement
.
get
(
form
.
rootElement
)
|
|
{
}
;
let
browsingContextId
=
win
.
windowGlobalChild
.
browsingContext
.
id
;
let
formActionOrigin
=
lazy
.
LoginHelper
.
getFormActionOrigin
(
form
)
;
detail
=
{
browsingContextId
formActionOrigin
autoFilledLoginGuid
:
autoFilledLogin
&
&
autoFilledLogin
.
guid
usernameField
:
mockUsername
newPasswordField
:
mockPassword
oldPasswordField
:
mockOldPassword
dismissedPrompt
triggeredByFillingGenerated
possibleValues
:
{
usernames
:
docState
.
possibleUsernames
passwords
:
docState
.
possiblePasswords
}
messageSent
:
true
}
;
if
(
messageName
=
=
"
PasswordManager
:
ShowDoorhanger
"
)
{
docState
.
captureLoginTimeStamp
=
doc
.
lastUserGestureTimeStamp
;
}
this
.
sendAsyncMessage
(
messageName
detail
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
throw
ex
;
}
finally
{
detail
.
form
=
form
;
const
evt
=
new
CustomEvent
(
messageName
{
detail
}
)
;
win
.
windowRoot
.
dispatchEvent
(
evt
)
;
}
}
_doesEventClearPrevFieldValue
(
{
target
data
inputType
}
)
{
return
(
!
target
.
value
|
|
(
data
&
&
data
=
=
target
.
value
&
&
inputType
!
=
=
"
insertReplacementText
"
)
)
;
}
_filledWithGeneratedPassword
(
passwordField
)
{
LoginFormState
.
_highlightFilledField
(
passwordField
)
;
this
.
_passwordEditedOrGenerated
(
passwordField
{
triggeredByFillingGenerated
:
true
}
)
;
let
docState
=
this
.
stateForDocument
(
passwordField
.
ownerDocument
)
;
docState
.
fillConfirmFieldWithGeneratedPassword
(
passwordField
)
;
}
_ignorePasswordEdit
(
)
{
if
(
Cu
.
isInAutomation
)
{
this
.
sendAsyncMessage
(
"
PasswordManager
:
onIgnorePasswordEdit
"
{
}
)
;
}
}
_passwordEditedOrGenerated
(
passwordField
{
triggeredByFillingGenerated
=
false
}
=
{
}
)
{
lazy
.
log
(
Password
field
with
name
{
passwordField
.
name
}
was
filled
or
edited
.
)
;
if
(
!
lazy
.
LoginHelper
.
enabled
&
&
triggeredByFillingGenerated
)
{
throw
new
Error
(
"
A
generated
password
was
filled
while
the
password
manager
was
disabled
.
"
)
;
}
let
loginForm
=
lazy
.
LoginFormFactory
.
createFromField
(
passwordField
)
;
if
(
triggeredByFillingGenerated
)
{
LoginFormState
.
_highlightFilledField
(
passwordField
)
;
let
docState
=
this
.
stateForDocument
(
passwordField
.
ownerDocument
)
;
docState
.
_treatAsGeneratedPasswordField
(
passwordField
)
;
this
.
#
fieldsWithPasswordGenerationForcedOn
.
delete
(
passwordField
)
;
}
this
.
_maybeSendFormInteractionMessage
(
loginForm
"
PasswordManager
:
onPasswordEditedOrGenerated
"
{
targetField
:
passwordField
isSubmission
:
false
triggeredByFillingGenerated
}
)
;
}
_filterForExactFormOriginLogins
(
logins
form
)
{
let
loginOrigin
=
lazy
.
LoginHelper
.
getLoginOrigin
(
form
.
ownerDocument
.
documentURI
)
;
let
formActionOrigin
=
lazy
.
LoginHelper
.
getFormActionOrigin
(
form
)
;
logins
=
logins
.
filter
(
l
=
>
{
let
formActionMatches
=
lazy
.
LoginHelper
.
isOriginMatching
(
l
.
formActionOrigin
formActionOrigin
{
schemeUpgrades
:
lazy
.
LoginHelper
.
schemeUpgrades
acceptWildcardMatch
:
true
acceptDifferentSubdomains
:
true
}
)
;
let
formOriginMatches
=
lazy
.
LoginHelper
.
isOriginMatching
(
l
.
origin
loginOrigin
{
schemeUpgrades
:
lazy
.
LoginHelper
.
schemeUpgrades
acceptWildcardMatch
:
true
acceptDifferentSubdomains
:
false
}
)
;
return
formActionMatches
&
&
formOriginMatches
;
}
)
;
logins
=
lazy
.
LoginHelper
.
dedupeLogins
(
logins
[
"
username
"
]
[
"
scheme
"
"
timePasswordChanged
"
]
loginOrigin
formActionOrigin
)
;
return
logins
;
}
_fillForm
(
form
foundLogins
recipes
{
inputElement
=
null
autofillForm
=
false
importable
=
null
clobberUsername
=
false
clobberPassword
=
false
userTriggered
=
false
style
=
null
}
=
{
}
)
{
if
(
HTMLFormElement
.
isInstance
(
form
)
)
{
throw
new
Error
(
"
_fillForm
should
only
be
called
with
LoginForm
objects
"
)
;
}
lazy
.
log
(
Found
{
form
.
elements
.
length
}
form
elements
.
)
;
let
autofillResult
=
-
1
;
const
AUTOFILL_RESULT
=
{
FILLED
:
0
NO_PASSWORD_FIELD
:
1
PASSWORD_DISABLED_READONLY
:
2
NO_LOGINS_FIT
:
3
NO_SAVED_LOGINS
:
4
EXISTING_PASSWORD
:
5
EXISTING_USERNAME
:
6
MULTIPLE_LOGINS
:
7
NO_AUTOFILL_FORMS
:
8
AUTOCOMPLETE_OFF
:
9
INSECURE
:
10
PASSWORD_AUTOCOMPLETE_NEW_PASSWORD
:
11
TYPE_NO_LONGER_PASSWORD
:
12
FORM_IN_CROSSORIGIN_SUBFRAME
:
13
FILLED_USERNAME_ONLY_FORM
:
14
}
;
const
docState
=
this
.
stateForDocument
(
form
.
ownerDocument
)
;
let
{
usernameField
newPasswordField
:
passwordField
}
=
docState
.
_getFormFields
(
form
false
recipes
)
;
try
{
if
(
!
foundLogins
.
length
&
&
!
(
importable
?
.
state
=
=
=
"
import
"
&
&
importable
?
.
browsers
)
&
&
lazy
.
InsecurePasswordUtils
.
isFormSecure
(
form
)
)
{
autofillResult
=
AUTOFILL_RESULT
.
NO_SAVED_LOGINS
;
return
;
}
if
(
inputElement
)
{
if
(
inputElement
.
hasBeenTypePassword
)
{
passwordField
=
inputElement
;
if
(
!
clobberUsername
)
{
usernameField
=
null
;
}
}
else
if
(
lazy
.
LoginHelper
.
isUsernameFieldType
(
inputElement
)
)
{
usernameField
=
inputElement
;
}
else
{
throw
new
Error
(
"
Unexpected
input
element
type
.
"
)
;
}
}
if
(
passwordField
=
=
null
&
&
usernameField
=
=
null
)
{
lazy
.
log
(
"
Not
filling
form
no
password
and
username
field
found
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
NO_PASSWORD_FIELD
;
return
;
}
if
(
usernameField
)
{
lazy
.
gFormFillService
.
markAsLoginManagerField
(
usernameField
)
;
usernameField
.
addEventListener
(
"
keydown
"
observer
)
;
}
if
(
passwordField
?
.
disabled
|
|
passwordField
?
.
readOnly
)
{
lazy
.
log
(
"
Not
filling
form
password
field
disabled
or
read
-
only
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
PASSWORD_DISABLED_READONLY
;
return
;
}
if
(
!
userTriggered
&
&
!
form
.
rootElement
.
ownerGlobal
.
windowGlobalChild
.
sameOriginWithTop
)
{
lazy
.
log
(
"
Not
filling
form
;
it
is
in
a
cross
-
origin
subframe
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
FORM_IN_CROSSORIGIN_SUBFRAME
;
return
;
}
if
(
!
userTriggered
)
{
foundLogins
=
this
.
_filterForExactFormOriginLogins
(
foundLogins
form
)
;
}
if
(
!
foundLogins
.
length
)
{
autofillResult
=
AUTOFILL_RESULT
.
NO_SAVED_LOGINS
;
return
;
}
if
(
!
userTriggered
&
&
!
lazy
.
LoginHelper
.
insecureAutofill
&
&
!
lazy
.
InsecurePasswordUtils
.
isFormSecure
(
form
)
)
{
lazy
.
log
(
"
Not
filling
form
since
it
'
s
insecure
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
INSECURE
;
return
;
}
let
maxUsernameLen
=
Number
.
MAX_VALUE
;
let
maxPasswordLen
=
Number
.
MAX_VALUE
;
if
(
usernameField
?
.
maxLength
>
=
0
)
{
maxUsernameLen
=
usernameField
.
maxLength
;
}
if
(
passwordField
?
.
maxLength
>
=
0
)
{
maxPasswordLen
=
passwordField
.
maxLength
;
}
let
logins
=
foundLogins
.
filter
(
function
(
l
)
{
let
fit
=
l
.
username
.
length
<
=
maxUsernameLen
&
&
l
.
password
.
length
<
=
maxPasswordLen
;
if
(
!
fit
)
{
lazy
.
log
(
Ignored
login
:
won
'
t
fit
{
l
.
username
.
length
}
.
)
;
}
return
fit
;
}
this
)
;
if
(
!
logins
.
length
)
{
lazy
.
log
(
"
Form
not
filled
none
of
the
logins
fit
in
the
field
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
NO_LOGINS_FIT
;
return
;
}
const
passwordACFieldName
=
passwordField
?
.
getAutocompleteInfo
(
)
.
fieldName
;
if
(
passwordField
)
{
if
(
!
userTriggered
&
&
passwordField
.
type
!
=
"
password
"
)
{
lazy
.
log
(
"
Not
autofilling
password
field
isn
'
t
currently
type
=
password
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
TYPE_NO_LONGER_PASSWORD
;
return
;
}
if
(
!
userTriggered
&
&
passwordACFieldName
=
=
"
new
-
password
"
)
{
lazy
.
log
(
"
Not
filling
form
password
field
has
the
autocomplete
new
-
password
value
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
PASSWORD_AUTOCOMPLETE_NEW_PASSWORD
;
return
;
}
if
(
passwordField
.
value
&
&
!
clobberPassword
)
{
lazy
.
log
(
"
Form
not
filled
the
password
field
was
already
filled
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
EXISTING_PASSWORD
;
return
;
}
}
let
selectedLogin
;
if
(
!
clobberUsername
&
&
usernameField
&
&
(
usernameField
.
value
|
|
usernameField
.
disabled
|
|
usernameField
.
readOnly
)
)
{
let
username
=
usernameField
.
value
.
toLowerCase
(
)
;
let
matchingLogins
=
logins
.
filter
(
l
=
>
l
.
username
.
toLowerCase
(
)
=
=
username
)
;
if
(
!
matchingLogins
.
length
)
{
lazy
.
log
(
"
Password
not
filled
.
None
of
the
stored
logins
match
the
username
already
present
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
EXISTING_USERNAME
;
return
;
}
for
(
let
l
of
matchingLogins
)
{
if
(
l
.
username
=
=
usernameField
.
value
)
{
selectedLogin
=
l
;
}
}
if
(
!
selectedLogin
)
{
selectedLogin
=
matchingLogins
[
0
]
;
}
}
else
if
(
logins
.
length
=
=
1
)
{
selectedLogin
=
logins
[
0
]
;
}
else
{
let
matchingLogins
;
if
(
usernameField
)
{
matchingLogins
=
logins
.
filter
(
l
=
>
l
.
username
)
;
}
else
{
matchingLogins
=
logins
.
filter
(
l
=
>
!
l
.
username
)
;
}
if
(
matchingLogins
.
length
!
=
1
)
{
lazy
.
log
(
"
Multiple
logins
for
form
so
not
filling
any
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
MULTIPLE_LOGINS
;
return
;
}
selectedLogin
=
matchingLogins
[
0
]
;
}
if
(
!
autofillForm
)
{
lazy
.
log
(
"
autofillForms
=
false
but
form
can
be
filled
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
NO_AUTOFILL_FORMS
;
return
;
}
if
(
!
userTriggered
&
&
passwordACFieldName
=
=
"
off
"
&
&
!
lazy
.
LoginHelper
.
autofillAutocompleteOff
)
{
lazy
.
log
(
"
Not
autofilling
the
login
because
we
'
re
respecting
autocomplete
=
off
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
AUTOCOMPLETE_OFF
;
return
;
}
let
willAutofill
=
usernameField
|
|
passwordField
.
value
!
=
selectedLogin
.
password
;
if
(
willAutofill
)
{
let
autoFilledLogin
=
{
guid
:
selectedLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
.
guid
username
:
selectedLogin
.
username
usernameField
:
usernameField
?
Cu
.
getWeakReference
(
usernameField
)
:
null
password
:
selectedLogin
.
password
passwordField
:
passwordField
?
Cu
.
getWeakReference
(
passwordField
)
:
null
}
;
lazy
.
log
(
"
Saving
autoFilledLogin
"
autoFilledLogin
.
guid
"
for
"
form
.
rootElement
)
;
docState
.
fillsByRootElement
.
set
(
form
.
rootElement
{
login
:
autoFilledLogin
userTriggered
}
)
;
}
if
(
usernameField
)
{
let
disabledOrReadOnly
=
usernameField
.
disabled
|
|
usernameField
.
readOnly
;
if
(
selectedLogin
.
username
&
&
!
disabledOrReadOnly
)
{
let
userNameDiffers
=
selectedLogin
.
username
!
=
usernameField
.
value
;
let
userEnteredDifferentCase
=
userTriggered
&
&
userNameDiffers
&
&
usernameField
.
value
.
toLowerCase
(
)
=
=
selectedLogin
.
username
.
toLowerCase
(
)
;
if
(
!
userEnteredDifferentCase
&
&
userNameDiffers
)
{
usernameField
.
setUserInput
(
selectedLogin
.
username
)
;
}
LoginFormState
.
_highlightFilledField
(
usernameField
)
;
}
}
if
(
passwordField
)
{
if
(
passwordField
.
value
!
=
selectedLogin
.
password
)
{
docState
.
_stopTreatingAsGeneratedPasswordField
(
passwordField
)
;
passwordField
.
setUserInput
(
selectedLogin
.
password
)
;
}
LoginFormState
.
_highlightFilledField
(
passwordField
)
;
}
if
(
style
=
=
=
"
generatedPassword
"
)
{
this
.
_filledWithGeneratedPassword
(
passwordField
)
;
}
lazy
.
log
(
"
_fillForm
succeeded
"
)
;
if
(
passwordField
)
{
autofillResult
=
AUTOFILL_RESULT
.
FILLED
;
}
else
if
(
usernameField
)
{
autofillResult
=
AUTOFILL_RESULT
.
FILLED_USERNAME_ONLY_FORM
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
throw
ex
;
}
finally
{
if
(
autofillResult
=
=
-
1
)
{
throw
new
Error
(
"
_fillForm
:
autofillResult
must
be
specified
"
)
;
}
if
(
!
userTriggered
)
{
Services
.
telemetry
.
getHistogramById
(
"
PWMGR_FORM_AUTOFILL_RESULT
"
)
.
add
(
autofillResult
)
;
if
(
usernameField
)
{
let
focusedElement
=
lazy
.
gFormFillService
.
focusedInput
;
if
(
usernameField
=
=
focusedElement
&
&
!
[
AUTOFILL_RESULT
.
FILLED
AUTOFILL_STATE
.
FILLED_USERNAME_ONLY_FORM
]
.
includes
(
autofillResult
)
)
{
lazy
.
log
(
"
Opening
username
autocomplete
popup
since
the
form
wasn
'
t
autofilled
.
"
)
;
lazy
.
gFormFillService
.
showPopup
(
)
;
}
}
}
if
(
usernameField
)
{
lazy
.
log
(
"
Attaching
event
listeners
to
usernameField
.
"
)
;
usernameField
.
addEventListener
(
"
focus
"
observer
)
;
usernameField
.
addEventListener
(
"
mousedown
"
observer
)
;
}
this
.
sendAsyncMessage
(
"
PasswordManager
:
formProcessed
"
{
formid
:
form
.
rootElement
.
id
}
)
;
}
}
}
