"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
LoginManagerChild
"
]
;
const
PASSWORD_INPUT_ADDED_COALESCING_THRESHOLD_MS
=
1
;
const
AUTOCOMPLETE_AFTER_RIGHT_CLICK_THRESHOLD_MS
=
400
;
const
AUTOFILL_STATE
=
"
autofill
"
;
const
SUBMIT_FORM_SUBMIT
=
1
;
const
SUBMIT_PAGE_NAVIGATION
=
2
;
const
SUBMIT_FORM_IS_REMOVED
=
3
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
PrivateBrowsingUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
{
CreditCard
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
CreditCard
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FormLikeFactory
"
"
resource
:
/
/
gre
/
modules
/
FormLikeFactory
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginFormFactory
"
"
resource
:
/
/
gre
/
modules
/
LoginFormFactory
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginRecipesContent
"
"
resource
:
/
/
gre
/
modules
/
LoginRecipes
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
InsecurePasswordUtils
"
"
resource
:
/
/
gre
/
modules
/
InsecurePasswordUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ContentDOMReference
"
"
resource
:
/
/
gre
/
modules
/
ContentDOMReference
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gFormFillService
"
"
mozilla
.
org
/
satchel
/
form
-
fill
-
controller
;
1
"
"
nsIFormFillController
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
logger
=
LoginHelper
.
createLogger
(
"
LoginManagerChild
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
Services
.
cpmm
.
addMessageListener
(
"
clearRecipeCache
"
(
)
=
>
{
LoginRecipesContent
.
_clearRecipeCache
(
)
;
}
)
;
let
gLastRightClickTimeStamp
=
Number
.
NEGATIVE_INFINITY
;
let
gKeyDownEnterForInput
=
null
;
class
WeakFieldSet
extends
WeakSet
{
add
(
value
)
{
if
(
ChromeUtils
.
getClassName
(
value
)
!
=
"
HTMLInputElement
"
)
{
throw
new
Error
(
"
Non
-
field
type
added
to
a
WeakFieldSet
"
)
;
}
super
.
add
(
value
)
;
}
}
const
observer
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
if
(
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
|
|
!
(
aWebProgress
.
loadType
&
Ci
.
nsIDocShell
.
LOAD_CMD_PUSHSTATE
)
)
{
return
;
}
log
(
"
onLocationChange
handled
:
"
aLocation
.
displaySpec
aWebProgress
.
DOMWindow
.
document
)
;
LoginManagerChild
.
forWindow
(
aWebProgress
.
DOMWindow
)
.
_onNavigation
(
aWebProgress
.
DOMWindow
.
document
)
;
}
onStateChange
(
aWebProgress
aRequest
aState
aStatus
)
{
if
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_RESTORING
&
&
aState
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
LoginManagerChild
.
forWindow
(
aWebProgress
.
DOMWindow
)
.
_onDocumentRestored
(
aWebProgress
.
DOMWindow
.
document
)
;
return
;
}
if
(
!
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
)
{
return
;
}
let
channel
=
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
triggeringPrincipal
=
channel
.
loadInfo
.
triggeringPrincipal
;
if
(
triggeringPrincipal
.
isNullPrincipal
|
|
triggeringPrincipal
.
equals
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
)
{
return
;
}
if
(
!
(
aWebProgress
.
loadType
&
Ci
.
nsIDocShell
.
LOAD_CMD_NORMAL
)
)
{
log
(
"
onStateChange
:
loadType
isn
'
t
LOAD_CMD_NORMAL
:
"
aWebProgress
.
loadType
)
;
return
;
}
log
(
"
onStateChange
handled
:
"
channel
)
;
LoginManagerChild
.
forWindow
(
aWebProgress
.
DOMWindow
)
.
_onNavigation
(
aWebProgress
.
DOMWindow
.
document
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
autocomplete
-
did
-
enter
-
text
"
:
{
let
input
=
subject
.
QueryInterface
(
Ci
.
nsIAutoCompleteInput
)
;
let
{
selectedIndex
}
=
input
.
popup
;
if
(
selectedIndex
<
0
)
{
break
;
}
let
{
focusedInput
}
=
gFormFillService
;
if
(
focusedInput
.
nodePrincipal
.
isNullPrincipal
)
{
return
;
}
let
window
=
focusedInput
.
ownerGlobal
;
let
loginManagerChild
=
LoginManagerChild
.
forWindow
(
window
)
;
let
style
=
input
.
controller
.
getStyleAt
(
selectedIndex
)
;
if
(
style
=
=
"
login
"
|
|
style
=
=
"
loginWithOrigin
"
)
{
let
details
=
JSON
.
parse
(
input
.
controller
.
getCommentAt
(
selectedIndex
)
)
;
loginManagerChild
.
onFieldAutoComplete
(
focusedInput
details
.
guid
)
;
}
else
if
(
style
=
=
"
generatedPassword
"
)
{
loginManagerChild
.
_filledWithGeneratedPassword
(
focusedInput
)
;
}
break
;
}
}
}
handleEvent
(
aEvent
)
{
if
(
!
aEvent
.
isTrusted
)
{
return
;
}
if
(
!
LoginHelper
.
enabled
)
{
return
;
}
let
ownerDocument
=
aEvent
.
target
.
ownerDocument
;
let
window
=
ownerDocument
.
defaultView
;
let
docState
=
LoginManagerChild
.
forWindow
(
window
)
.
stateForDocument
(
ownerDocument
)
;
switch
(
aEvent
.
type
)
{
case
"
blur
"
:
{
if
(
docState
.
generatedPasswordFields
.
has
(
aEvent
.
composedTarget
)
)
{
let
unmask
=
false
;
LoginManagerChild
.
forWindow
(
window
)
.
_togglePasswordFieldMasking
(
aEvent
.
composedTarget
unmask
)
;
}
break
;
}
case
"
change
"
:
{
let
formLikeRoot
=
FormLikeFactory
.
findRootForField
(
aEvent
.
composedTarget
)
;
if
(
!
docState
.
fieldModificationsByRootElement
.
get
(
formLikeRoot
)
)
{
log
(
"
Ignoring
change
event
on
form
that
hasn
'
t
been
user
-
modified
"
)
;
if
(
aEvent
.
composedTarget
.
hasBeenTypePassword
)
{
LoginManagerChild
.
forWindow
(
window
)
.
_ignorePasswordEdit
(
)
;
}
break
;
}
this
.
_storeUserInput
(
docState
aEvent
.
composedTarget
)
;
let
detail
=
{
possibleValues
:
{
usernames
:
docState
.
possibleUsernames
passwords
:
docState
.
possiblePasswords
}
}
;
LoginManagerChild
.
forWindow
(
window
)
.
sendAsyncMessage
(
"
PasswordManager
:
updateDoorhangerSuggestions
"
detail
)
;
if
(
aEvent
.
composedTarget
.
hasBeenTypePassword
)
{
let
triggeredByFillingGenerated
=
docState
.
generatedPasswordFields
.
has
(
aEvent
.
composedTarget
)
;
if
(
triggeredByFillingGenerated
)
{
LoginManagerChild
.
forWindow
(
window
)
.
_passwordEditedOrGenerated
(
aEvent
.
composedTarget
{
triggeredByFillingGenerated
}
)
;
}
else
{
LoginManagerChild
.
forWindow
(
window
)
.
_ignorePasswordEdit
(
)
;
}
}
break
;
}
case
"
input
"
:
{
let
field
=
aEvent
.
composedTarget
;
let
isPasswordType
=
LoginHelper
.
isPasswordFieldType
(
field
)
;
let
loginManagerChild
=
LoginManagerChild
.
forWindow
(
window
)
;
if
(
docState
.
generatedPasswordFields
.
has
(
field
)
&
&
loginManagerChild
.
_doesEventClearPrevFieldValue
(
aEvent
)
)
{
loginManagerChild
.
_stopTreatingAsGeneratedPasswordField
(
field
)
;
}
if
(
!
isPasswordType
&
&
!
LoginHelper
.
isUsernameFieldType
(
field
)
)
{
break
;
}
let
formLikeRoot
=
FormLikeFactory
.
findRootForField
(
field
)
;
if
(
formLikeRoot
!
=
=
aEvent
.
currentTarget
)
{
break
;
}
let
alreadyModified
=
docState
.
fieldModificationsByRootElement
.
get
(
formLikeRoot
)
;
let
{
login
:
filledLogin
userTriggered
:
fillWasUserTriggered
}
=
docState
.
fillsByRootElement
.
get
(
formLikeRoot
)
|
|
{
}
;
let
isAutofillInput
=
filledLogin
&
&
!
fillWasUserTriggered
;
if
(
!
alreadyModified
&
&
isAutofillInput
)
{
if
(
isPasswordType
&
&
filledLogin
.
password
=
=
field
.
value
)
{
log
(
"
Ignoring
password
input
event
that
doesn
'
t
change
autofilled
values
"
)
;
break
;
}
if
(
!
isPasswordType
&
&
filledLogin
.
usernameField
&
&
filledLogin
.
username
=
=
field
.
value
)
{
log
(
"
Ignoring
username
input
event
that
doesn
'
t
change
autofilled
values
"
)
;
break
;
}
}
docState
.
fieldModificationsByRootElement
.
set
(
formLikeRoot
true
)
;
let
alreadyModifiedFormLessField
=
true
;
if
(
ChromeUtils
.
getClassName
(
formLikeRoot
)
!
=
=
"
HTMLFormElement
"
)
{
alreadyModifiedFormLessField
=
docState
.
formlessModifiedPasswordFields
.
has
(
field
)
;
if
(
!
alreadyModifiedFormLessField
)
{
docState
.
formlessModifiedPasswordFields
.
add
(
field
)
;
}
}
if
(
LoginHelper
.
formRemovalCaptureEnabled
&
&
(
!
alreadyModified
|
|
!
alreadyModifiedFormLessField
)
)
{
ownerDocument
.
setNotifyFetchSuccess
(
true
)
;
}
if
(
isPasswordType
&
&
loginManagerChild
.
_doesEventClearPrevFieldValue
(
aEvent
)
&
&
filledLogin
&
&
filledLogin
.
password
!
=
=
field
.
value
)
{
docState
.
fillsByRootElement
.
delete
(
formLikeRoot
)
;
}
if
(
!
LoginHelper
.
passwordEditCaptureEnabled
)
{
break
;
}
if
(
field
.
hasBeenTypePassword
)
{
let
form
=
LoginFormFactory
.
createFromField
(
field
)
;
if
(
docState
.
generatedPasswordFields
.
has
(
field
)
&
&
LoginManagerChild
.
forWindow
(
window
)
.
_getFormFields
(
form
)
.
confirmPasswordField
=
=
=
field
)
{
break
;
}
LoginManagerChild
.
forWindow
(
window
)
.
_passwordEditedOrGenerated
(
field
)
;
}
else
{
let
[
usernameField
passwordField
]
=
LoginManagerChild
.
forWindow
(
window
)
.
getUserNameAndPasswordFields
(
field
)
;
if
(
usernameField
&
&
field
=
=
usernameField
&
&
passwordField
&
&
passwordField
.
value
)
{
LoginManagerChild
.
forWindow
(
window
)
.
_passwordEditedOrGenerated
(
passwordField
{
triggeredByFillingGenerated
:
docState
.
generatedPasswordFields
.
has
(
passwordField
)
}
)
;
}
}
break
;
}
case
"
keydown
"
:
{
if
(
aEvent
.
composedTarget
.
value
&
&
(
aEvent
.
keyCode
=
=
aEvent
.
DOM_VK_TAB
|
|
aEvent
.
keyCode
=
=
aEvent
.
DOM_VK_RETURN
)
)
{
const
autofillForm
=
LoginHelper
.
autofillForms
&
&
!
PrivateBrowsingUtils
.
isContentWindowPrivate
(
ownerDocument
.
defaultView
)
;
if
(
autofillForm
)
{
LoginManagerChild
.
forWindow
(
window
)
.
onUsernameAutocompleted
(
aEvent
.
composedTarget
)
;
}
}
break
;
}
case
"
focus
"
:
{
if
(
aEvent
.
composedTarget
.
hasBeenTypePassword
&
&
docState
.
generatedPasswordFields
.
has
(
aEvent
.
composedTarget
)
)
{
let
unmask
=
true
;
LoginManagerChild
.
forWindow
(
window
)
.
_togglePasswordFieldMasking
(
aEvent
.
composedTarget
unmask
)
;
break
;
}
LoginManagerChild
.
forWindow
(
window
)
.
_onUsernameFocus
(
aEvent
)
;
break
;
}
case
"
mousedown
"
:
{
if
(
aEvent
.
button
=
=
2
)
{
gLastRightClickTimeStamp
=
Date
.
now
(
)
;
}
break
;
}
default
:
{
throw
new
Error
(
"
Unexpected
event
"
)
;
}
}
}
_storeUserInput
(
docState
field
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
signon
.
capture
.
inputChanges
.
enabled
"
false
)
|
|
!
field
.
value
)
{
return
;
}
if
(
LoginHelper
.
isPasswordFieldType
(
field
)
)
{
docState
.
possiblePasswords
.
add
(
field
.
value
)
;
}
else
if
(
LoginHelper
.
isUsernameFieldType
(
field
)
)
{
docState
.
possibleUsernames
.
add
(
field
.
value
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
observer
"
autocomplete
-
did
-
enter
-
text
"
)
;
this
.
LoginManagerChild
=
class
LoginManagerChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
_deferredPasswordAddedTasksByRootElement
=
new
WeakMap
(
)
;
this
.
_visibleTasksByDocument
=
new
WeakMap
(
)
;
this
.
_loginFormStateByDocument
=
new
WeakMap
(
)
;
this
.
_fieldsWithPasswordGenerationForcedOn
=
new
WeakSet
(
)
;
}
static
forWindow
(
window
)
{
let
windowGlobal
=
window
.
windowGlobalChild
;
if
(
windowGlobal
)
{
return
windowGlobal
.
getActor
(
"
LoginManager
"
)
;
}
return
null
;
}
_compareAndUpdatePreviouslySentValues
(
formLikeRoot
usernameValue
passwordValue
dismissed
=
false
triggeredByFillingGenerated
=
false
)
{
let
state
=
this
.
stateForDocument
(
formLikeRoot
.
ownerDocument
)
;
const
lastSentValues
=
state
.
lastSubmittedValuesByRootElement
.
get
(
formLikeRoot
)
;
if
(
lastSentValues
)
{
if
(
dismissed
&
&
!
lastSentValues
.
dismissed
)
{
dismissed
=
false
;
}
if
(
lastSentValues
.
username
=
=
usernameValue
&
&
lastSentValues
.
password
=
=
passwordValue
&
&
lastSentValues
.
dismissed
=
=
dismissed
&
&
lastSentValues
.
triggeredByFillingGenerated
=
=
triggeredByFillingGenerated
)
{
log
(
"
_compareAndUpdatePreviouslySentValues
:
values
are
equivalent
returning
true
"
)
;
return
true
;
}
}
state
.
lastSubmittedValuesByRootElement
.
set
(
formLikeRoot
{
username
:
usernameValue
password
:
passwordValue
dismissed
triggeredByFillingGenerated
}
)
;
log
(
"
_compareAndUpdatePreviouslySentValues
:
values
not
equivalent
returning
false
"
)
;
return
false
;
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
PasswordManager
:
fillForm
"
:
{
this
.
fillForm
(
{
loginFormOrigin
:
msg
.
data
.
loginFormOrigin
loginsFound
:
LoginHelper
.
vanillaObjectsToLogins
(
msg
.
data
.
logins
)
recipes
:
msg
.
data
.
recipes
inputElementIdentifier
:
msg
.
data
.
inputElementIdentifier
originMatches
:
msg
.
data
.
originMatches
style
:
msg
.
data
.
style
}
)
;
break
;
}
case
"
PasswordManager
:
useGeneratedPassword
"
:
{
let
inputElement
=
ContentDOMReference
.
resolve
(
msg
.
data
.
inputElementIdentifier
)
;
if
(
!
inputElement
)
{
log
(
"
Could
not
resolve
inputElementIdentifier
to
a
living
element
.
"
)
;
break
;
}
if
(
inputElement
!
=
gFormFillService
.
focusedInput
)
{
log
(
"
Could
not
open
popup
on
input
that
'
s
no
longer
focused
"
)
;
break
;
}
this
.
_fieldsWithPasswordGenerationForcedOn
.
add
(
inputElement
)
;
this
.
repopulateAutocompletePopup
(
)
;
break
;
}
case
"
PasswordManager
:
repopulateAutocompletePopup
"
:
{
this
.
repopulateAutocompletePopup
(
)
;
break
;
}
case
"
PasswordManager
:
formIsPending
"
:
{
return
this
.
_visibleTasksByDocument
.
has
(
this
.
document
)
;
}
case
"
PasswordManager
:
formProcessed
"
:
{
this
.
notifyObserversOfFormProcessed
(
msg
.
data
.
formid
)
;
break
;
}
}
return
undefined
;
}
repopulateAutocompletePopup
(
)
{
gFormFillService
.
QueryInterface
(
Ci
.
nsIAutoCompleteInput
)
;
gFormFillService
.
controller
.
resetInternalState
(
)
;
gFormFillService
.
showPopup
(
)
;
}
shouldIgnoreLoginManagerEvent
(
event
)
{
let
nodePrincipal
=
event
.
target
.
nodePrincipal
;
return
(
nodePrincipal
.
isSystemPrincipal
|
|
nodePrincipal
.
isNullPrincipal
|
|
nodePrincipal
.
schemeIs
(
"
about
"
)
)
;
}
handleEvent
(
event
)
{
if
(
AppConstants
.
platform
=
=
"
android
"
&
&
Services
.
prefs
.
getBoolPref
(
"
reftest
.
remote
"
false
)
)
{
return
;
}
switch
(
event
.
type
)
{
case
"
DOMDocFetchSuccess
"
:
{
if
(
this
.
shouldIgnoreLoginManagerEvent
(
event
)
)
{
break
;
}
this
.
onDOMDocFetchSuccess
(
event
)
;
break
;
}
case
"
DOMFormBeforeSubmit
"
:
{
if
(
this
.
shouldIgnoreLoginManagerEvent
(
event
)
)
{
break
;
}
this
.
onDOMFormBeforeSubmit
(
event
)
;
break
;
}
case
"
DOMFormHasPassword
"
:
{
if
(
this
.
shouldIgnoreLoginManagerEvent
(
event
)
)
{
break
;
}
this
.
onDOMFormHasPassword
(
event
)
;
let
formLike
=
LoginFormFactory
.
createFromForm
(
event
.
originalTarget
)
;
InsecurePasswordUtils
.
reportInsecurePasswords
(
formLike
)
;
break
;
}
case
"
DOMFormHasPossibleUsername
"
:
{
if
(
this
.
shouldIgnoreLoginManagerEvent
(
event
)
)
{
break
;
}
this
.
onDOMFormHasPossibleUsername
(
event
)
;
break
;
}
case
"
DOMFormRemoved
"
:
case
"
DOMInputPasswordRemoved
"
:
{
if
(
this
.
shouldIgnoreLoginManagerEvent
(
event
)
)
{
break
;
}
this
.
onDOMFormRemoved
(
event
)
;
break
;
}
case
"
DOMInputPasswordAdded
"
:
{
if
(
this
.
shouldIgnoreLoginManagerEvent
(
event
)
)
{
break
;
}
this
.
onDOMInputPasswordAdded
(
event
this
.
document
.
defaultView
)
;
let
formLike
=
LoginFormFactory
.
createFromField
(
event
.
originalTarget
)
;
InsecurePasswordUtils
.
reportInsecurePasswords
(
formLike
)
;
break
;
}
}
}
notifyObserversOfFormProcessed
(
formid
)
{
Services
.
obs
.
notifyObservers
(
this
"
passwordmgr
-
processed
-
form
"
formid
)
;
}
_getLoginDataFromParent
(
form
options
)
{
let
actionOrigin
=
LoginHelper
.
getFormActionOrigin
(
form
)
;
let
messageData
=
{
actionOrigin
options
}
;
let
resultPromise
=
this
.
sendQuery
(
"
PasswordManager
:
findLogins
"
messageData
)
;
return
resultPromise
.
then
(
result
=
>
{
return
{
form
importable
:
result
.
importable
loginsFound
:
LoginHelper
.
vanillaObjectsToLogins
(
result
.
logins
)
recipes
:
result
.
recipes
}
;
}
)
;
}
setupProgressListener
(
window
)
{
if
(
!
LoginHelper
.
formlessCaptureEnabled
)
{
return
;
}
let
docShell
;
for
(
let
browsingContext
=
BrowsingContext
.
getFromWindow
(
window
)
;
browsingContext
&
&
browsingContext
.
docShell
;
browsingContext
=
browsingContext
.
parent
)
{
docShell
=
browsingContext
.
docShell
;
}
try
{
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
observer
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
|
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
catch
(
ex
)
{
}
}
onDOMDocFetchSuccess
(
event
)
{
let
document
=
event
.
target
;
let
docState
=
this
.
stateForDocument
(
document
)
;
let
weakModificationsRootElements
=
ChromeUtils
.
nondeterministicGetWeakMapKeys
(
docState
.
fieldModificationsByRootElement
)
;
log
(
"
onDOMDocFetchSuccess
:
modificationsByRootElement
approx
size
:
"
weakModificationsRootElements
.
length
"
document
:
"
document
)
;
document
.
setNotifyFormOrPasswordRemoved
(
true
)
;
this
.
docShell
.
chromeEventHandler
.
addEventListener
(
"
DOMFormRemoved
"
this
true
)
;
this
.
docShell
.
chromeEventHandler
.
addEventListener
(
"
DOMInputPasswordRemoved
"
this
true
)
;
for
(
let
rootElement
of
weakModificationsRootElements
)
{
if
(
ChromeUtils
.
getClassName
(
rootElement
)
=
=
=
"
HTMLFormElement
"
)
{
let
formLike
=
LoginFormFactory
.
createFromForm
(
rootElement
)
;
docState
.
formLikeByObservedNode
.
set
(
rootElement
formLike
)
;
}
}
let
weakFormlessModifiedPasswordFields
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
docState
.
formlessModifiedPasswordFields
)
;
log
(
"
onDOMDocFetchSuccess
:
formlessModifiedPasswordFields
approx
size
:
"
weakFormlessModifiedPasswordFields
.
length
"
document
:
"
document
)
;
for
(
let
passwordField
of
weakFormlessModifiedPasswordFields
)
{
let
formLike
=
LoginFormFactory
.
createFromField
(
passwordField
)
;
if
(
formLike
.
elements
.
length
)
{
docState
.
formLikeByObservedNode
.
set
(
passwordField
formLike
)
;
}
}
document
.
setNotifyFetchSuccess
(
false
)
;
}
onDOMFormRemoved
(
event
)
{
let
document
=
event
.
composedTarget
.
ownerDocument
;
let
docState
=
this
.
stateForDocument
(
document
)
;
let
formLike
=
docState
.
formLikeByObservedNode
.
get
(
event
.
target
)
;
if
(
!
formLike
)
{
return
;
}
log
(
"
form
is
removed
"
)
;
this
.
_onFormSubmit
(
formLike
SUBMIT_FORM_IS_REMOVED
)
;
docState
.
formLikeByObservedNode
.
delete
(
event
.
target
)
;
let
weakObserveredNodes
=
ChromeUtils
.
nondeterministicGetWeakMapKeys
(
docState
.
formLikeByObservedNode
)
;
if
(
!
weakObserveredNodes
.
length
)
{
document
.
setNotifyFormOrPasswordRemoved
(
false
)
;
this
.
docShell
.
chromeEventHandler
.
removeEventListener
(
"
DOMFormRemoved
"
this
)
;
this
.
docShell
.
chromeEventHandler
.
removeEventListener
(
"
DOMInputPasswordRemoved
"
this
)
;
}
}
onDOMFormBeforeSubmit
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
log
(
"
notified
before
form
submission
"
)
;
let
formLike
=
LoginFormFactory
.
createFromForm
(
event
.
target
)
;
this
.
_onFormSubmit
(
formLike
SUBMIT_FORM_SUBMIT
)
;
}
onDocumentVisibilityChange
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
document
=
event
.
target
;
let
onVisibleTasks
=
this
.
_visibleTasksByDocument
.
get
(
document
)
;
if
(
!
onVisibleTasks
)
{
return
;
}
for
(
let
task
of
onVisibleTasks
)
{
log
(
"
onDocumentVisibilityChange
executing
queued
task
"
)
;
task
(
)
;
}
this
.
_visibleTasksByDocument
.
delete
(
document
)
;
}
_deferHandlingEventUntilDocumentVisible
(
event
document
fn
)
{
log
(
document
.
visibilityState
:
{
document
.
visibilityState
}
defer
handling
{
event
.
type
}
)
;
let
onVisibleTasks
=
this
.
_visibleTasksByDocument
.
get
(
document
)
;
if
(
!
onVisibleTasks
)
{
log
(
deferHandling
first
queued
event
register
the
visibilitychange
handler
)
;
onVisibleTasks
=
[
]
;
this
.
_visibleTasksByDocument
.
set
(
document
onVisibleTasks
)
;
document
.
addEventListener
(
"
visibilitychange
"
event
=
>
{
this
.
onDocumentVisibilityChange
(
event
)
;
}
{
once
:
true
}
)
;
}
onVisibleTasks
.
push
(
fn
)
;
}
onDOMFormHasPassword
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
isMasterPasswordSet
=
Services
.
cpmm
.
sharedData
.
get
(
"
isMasterPasswordSet
"
)
;
let
document
=
event
.
target
.
ownerDocument
;
log
(
"
onDOMFormHasPassword
visibilityState
:
"
document
.
visibilityState
"
isMasterPasswordSet
:
"
isMasterPasswordSet
)
;
if
(
document
.
visibilityState
=
=
"
visible
"
|
|
isMasterPasswordSet
)
{
this
.
_processDOMFormHasPasswordEvent
(
event
)
;
}
else
{
this
.
_deferHandlingEventUntilDocumentVisible
(
event
document
(
)
=
>
{
this
.
_processDOMFormHasPasswordEvent
(
event
)
;
}
)
;
}
}
_processDOMFormHasPasswordEvent
(
event
)
{
let
form
=
event
.
target
;
let
formLike
=
LoginFormFactory
.
createFromForm
(
form
)
;
log
(
"
_processDOMFormHasPasswordEvent
:
"
form
formLike
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike
)
;
}
onDOMFormHasPossibleUsername
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
isMasterPasswordSet
=
Services
.
cpmm
.
sharedData
.
get
(
"
isMasterPasswordSet
"
)
;
let
document
=
event
.
target
.
ownerDocument
;
log
(
"
onDOMFormHasPossibleUsername
visibilityState
:
"
document
.
visibilityState
"
isMasterPasswordSet
:
"
isMasterPasswordSet
)
;
let
docState
=
this
.
stateForDocument
(
document
)
;
Services
.
telemetry
.
getHistogramById
(
"
PWMGR_NUM_FORM_HAS_POSSIBLE_USERNAME_EVENT_PER_DOC
"
)
.
add
(
+
+
docState
.
numFormHasPossibleUsernameEvent
)
;
if
(
document
.
visibilityState
=
=
"
visible
"
|
|
isMasterPasswordSet
)
{
this
.
_processDOMFormHasPossibleUsernameEvent
(
event
)
;
}
else
{
this
.
_deferHandlingEventUntilDocumentVisible
(
event
document
(
)
=
>
{
this
.
_processDOMFormHasPossibleUsernameEvent
(
event
)
;
}
)
;
}
}
_processDOMFormHasPossibleUsernameEvent
(
event
)
{
let
form
=
event
.
target
;
let
formLike
=
LoginFormFactory
.
createFromForm
(
form
)
;
log
(
"
_processDOMFormHasPossibleUsernameEvent
:
"
form
formLike
)
;
let
usernameField
=
this
.
getUsernameFieldFromUsernameOnlyForm
(
form
{
}
)
;
if
(
usernameField
)
{
log
(
"
_processDOMFormHasPossibleUsernameEvent
:
A
username
-
only
form
is
found
"
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike
)
;
}
Services
.
telemetry
.
getHistogramById
(
"
PWMGR_IS_USERNAME_ONLY_FORM
"
)
.
add
(
!
!
usernameField
)
;
}
onDOMInputPasswordAdded
(
event
window
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
this
.
setupProgressListener
(
window
)
;
let
pwField
=
event
.
originalTarget
;
if
(
pwField
.
form
)
{
return
;
}
let
document
=
pwField
.
ownerDocument
;
let
isMasterPasswordSet
=
Services
.
cpmm
.
sharedData
.
get
(
"
isMasterPasswordSet
"
)
;
log
(
"
onDOMInputPasswordAdded
visibilityState
:
"
document
.
visibilityState
"
isMasterPasswordSet
:
"
isMasterPasswordSet
)
;
if
(
document
.
visibilityState
=
=
"
visible
"
|
|
isMasterPasswordSet
)
{
this
.
_processDOMInputPasswordAddedEvent
(
event
)
;
}
else
{
this
.
_deferHandlingEventUntilDocumentVisible
(
event
document
(
)
=
>
{
this
.
_processDOMInputPasswordAddedEvent
(
event
)
;
}
)
;
}
}
_processDOMInputPasswordAddedEvent
(
event
)
{
let
pwField
=
event
.
originalTarget
;
let
formLike
=
LoginFormFactory
.
createFromField
(
pwField
)
;
log
(
"
_processDOMInputPasswordAddedEvent
:
"
pwField
formLike
)
;
let
deferredTask
=
this
.
_deferredPasswordAddedTasksByRootElement
.
get
(
formLike
.
rootElement
)
;
if
(
!
deferredTask
)
{
log
(
"
Creating
a
DeferredTask
to
call
_fetchLoginsFromParentAndFillForm
soon
"
)
;
LoginFormFactory
.
setForRootElement
(
formLike
.
rootElement
formLike
)
;
deferredTask
=
new
DeferredTask
(
(
)
=
>
{
let
formLike2
=
LoginFormFactory
.
getForRootElement
(
formLike
.
rootElement
)
;
log
(
"
Running
deferred
processing
of
onDOMInputPasswordAdded
"
formLike2
)
;
this
.
_deferredPasswordAddedTasksByRootElement
.
delete
(
formLike2
.
rootElement
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike2
)
;
}
PASSWORD_INPUT_ADDED_COALESCING_THRESHOLD_MS
0
)
;
this
.
_deferredPasswordAddedTasksByRootElement
.
set
(
formLike
.
rootElement
deferredTask
)
;
}
let
window
=
pwField
.
ownerGlobal
;
if
(
deferredTask
.
isArmed
)
{
log
(
"
DeferredTask
is
already
armed
so
just
updating
the
LoginForm
"
)
;
LoginFormFactory
.
setForRootElement
(
formLike
.
rootElement
formLike
)
;
}
else
if
(
[
"
interactive
"
"
complete
"
]
.
includes
(
window
.
document
.
readyState
)
)
{
log
(
"
Arming
the
DeferredTask
we
just
created
since
document
.
readyState
=
=
'
interactive
'
or
'
complete
'
"
)
;
deferredTask
.
arm
(
)
;
}
else
{
window
.
addEventListener
(
"
DOMContentLoaded
"
function
(
)
{
log
(
"
Arming
the
onDOMInputPasswordAdded
DeferredTask
due
to
DOMContentLoaded
"
)
;
deferredTask
.
arm
(
)
;
}
{
once
:
true
}
)
;
}
}
_fetchLoginsFromParentAndFillForm
(
form
)
{
if
(
!
LoginHelper
.
enabled
)
{
return
;
}
form
.
rootElement
.
addEventListener
(
"
input
"
observer
{
capture
:
true
mozSystemGroup
:
true
}
)
;
form
.
rootElement
.
addEventListener
(
"
change
"
observer
{
capture
:
true
mozSystemGroup
:
true
}
)
;
this
.
_getLoginDataFromParent
(
form
{
showMasterPassword
:
true
}
)
.
then
(
this
.
loginsFound
.
bind
(
this
)
)
.
catch
(
Cu
.
reportError
)
;
}
isPasswordGenerationForcedOn
(
passwordField
)
{
return
this
.
_fieldsWithPasswordGenerationForcedOn
.
has
(
passwordField
)
;
}
stateForDocument
(
document
)
{
let
loginFormState
=
this
.
_loginFormStateByDocument
.
get
(
document
)
;
if
(
!
loginFormState
)
{
loginFormState
=
{
fillsByRootElement
:
new
WeakMap
(
)
generatedPasswordFields
:
new
WeakFieldSet
(
)
lastSubmittedValuesByRootElement
:
new
WeakMap
(
)
fieldModificationsByRootElement
:
new
WeakMap
(
)
loginFormRootElements
:
new
WeakSet
(
)
possibleUsernames
:
new
Set
(
)
possiblePasswords
:
new
Set
(
)
formLikeByObservedNode
:
new
WeakMap
(
)
formlessModifiedPasswordFields
:
new
WeakFieldSet
(
)
cachedIsInferredUsernameField
:
new
WeakMap
(
)
cachedIsInferredEmailField
:
new
WeakMap
(
)
cachedIsInferredLoginForm
:
new
WeakMap
(
)
mockUsernameOnlyField
:
null
numFormHasPossibleUsernameEvent
:
0
}
;
this
.
_loginFormStateByDocument
.
set
(
document
loginFormState
)
;
}
return
loginFormState
;
}
fillForm
(
{
loginFormOrigin
loginsFound
recipes
inputElementIdentifier
originMatches
style
}
)
{
if
(
!
inputElementIdentifier
)
{
log
(
"
fillForm
:
No
input
element
specified
"
)
;
return
;
}
let
inputElement
=
ContentDOMReference
.
resolve
(
inputElementIdentifier
)
;
if
(
!
inputElement
)
{
log
(
"
fillForm
:
Could
not
resolve
inputElementIdentifier
to
a
living
element
.
"
)
;
return
;
}
if
(
!
originMatches
)
{
if
(
!
inputElement
|
|
LoginHelper
.
getLoginOrigin
(
inputElement
.
ownerDocument
.
documentURI
)
!
=
loginFormOrigin
)
{
log
(
"
fillForm
:
The
requested
origin
doesn
'
t
match
the
one
from
the
"
"
document
.
This
may
mean
we
navigated
to
a
document
from
a
different
"
"
site
before
we
had
a
chance
to
indicate
this
change
in
the
user
"
"
interface
.
"
)
;
return
;
}
}
let
clobberUsername
=
true
;
let
form
=
LoginFormFactory
.
createFromField
(
inputElement
)
;
if
(
inputElement
.
hasBeenTypePassword
)
{
clobberUsername
=
false
;
}
this
.
_fillForm
(
form
loginsFound
recipes
{
inputElement
autofillForm
:
true
clobberUsername
clobberPassword
:
true
userTriggered
:
true
style
}
)
;
}
loginsFound
(
{
form
importable
loginsFound
recipes
}
)
{
let
doc
=
form
.
ownerDocument
;
let
autofillForm
=
LoginHelper
.
autofillForms
&
&
!
PrivateBrowsingUtils
.
isContentWindowPrivate
(
doc
.
defaultView
)
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
LoginRecipesContent
.
cacheRecipes
(
formOrigin
doc
.
defaultView
recipes
)
;
this
.
_fillForm
(
form
loginsFound
recipes
{
autofillForm
importable
}
)
;
}
_onUsernameFocus
(
event
)
{
let
focusedField
=
event
.
target
;
if
(
!
focusedField
.
mozIsTextField
(
true
)
|
|
focusedField
.
hasBeenTypePassword
|
|
focusedField
.
readOnly
)
{
return
;
}
if
(
this
.
_isLoginAlreadyFilled
(
focusedField
)
)
{
log
(
"
_onUsernameFocus
:
Already
filled
"
)
;
return
;
}
let
timeDiff
=
Date
.
now
(
)
-
gLastRightClickTimeStamp
;
if
(
timeDiff
<
AUTOCOMPLETE_AFTER_RIGHT_CLICK_THRESHOLD_MS
)
{
log
(
"
Not
opening
autocomplete
after
focus
since
a
context
menu
was
opened
within
"
timeDiff
"
ms
"
)
;
return
;
}
log
(
"
maybeOpenAutocompleteAfterFocus
:
Opening
the
autocomplete
popup
"
)
;
gFormFillService
.
showPopup
(
)
;
}
onFieldAutoComplete
(
acInputField
loginGUID
)
{
if
(
!
LoginHelper
.
enabled
)
{
return
;
}
if
(
ChromeUtils
.
getClassName
(
acInputField
.
ownerDocument
)
!
=
"
HTMLDocument
"
)
{
return
;
}
if
(
!
LoginFormFactory
.
createFromField
(
acInputField
)
)
{
return
;
}
if
(
LoginHelper
.
isUsernameFieldType
(
acInputField
)
)
{
this
.
onUsernameAutocompleted
(
acInputField
loginGUID
)
;
}
else
if
(
acInputField
.
hasBeenTypePassword
)
{
this
.
_stopTreatingAsGeneratedPasswordField
(
acInputField
)
;
this
.
_highlightFilledField
(
acInputField
)
;
}
}
onUsernameAutocompleted
(
acInputField
loginGUID
=
null
)
{
log
(
"
onUsernameAutocompleted
:
"
acInputField
)
;
let
acForm
=
LoginFormFactory
.
createFromField
(
acInputField
)
;
let
doc
=
acForm
.
ownerDocument
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
let
recipes
=
LoginRecipesContent
.
getRecipes
(
this
formOrigin
doc
.
defaultView
)
;
let
{
usernameField
newPasswordField
:
passwordField
}
=
this
.
_getFormFields
(
acForm
false
recipes
)
;
if
(
usernameField
=
=
acInputField
)
{
if
(
passwordField
)
{
this
.
_getLoginDataFromParent
(
acForm
{
guid
:
loginGUID
showMasterPassword
:
false
}
)
.
then
(
(
{
form
loginsFound
recipes
}
)
=
>
{
if
(
!
loginGUID
)
{
loginsFound
=
this
.
_filterForExactFormOriginLogins
(
loginsFound
acForm
)
;
let
searchString
=
usernameField
.
value
.
toLowerCase
(
)
;
loginsFound
=
loginsFound
.
filter
(
l
=
>
l
.
username
.
toLowerCase
(
)
=
=
searchString
)
;
}
this
.
_fillForm
(
form
loginsFound
recipes
{
autofillForm
:
true
clobberPassword
:
true
userTriggered
:
true
}
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
else
if
(
loginGUID
!
=
=
null
)
{
this
.
_highlightFilledField
(
usernameField
)
;
}
}
else
{
}
}
_getPasswordFields
(
form
{
fieldOverrideRecipe
=
null
minPasswordLength
=
0
ignoreConnect
=
false
}
=
{
}
)
{
let
pwFields
=
[
]
;
for
(
let
i
=
0
;
i
<
form
.
elements
.
length
;
i
+
+
)
{
let
element
=
form
.
elements
[
i
]
;
if
(
ChromeUtils
.
getClassName
(
element
)
!
=
=
"
HTMLInputElement
"
|
|
!
element
.
hasBeenTypePassword
|
|
(
!
element
.
isConnected
&
&
!
ignoreConnect
)
)
{
continue
;
}
if
(
fieldOverrideRecipe
&
&
fieldOverrideRecipe
.
notPasswordSelector
&
&
element
.
matches
(
fieldOverrideRecipe
.
notPasswordSelector
)
)
{
log
(
"
skipping
password
field
(
id
/
name
is
"
element
.
id
"
/
"
element
.
name
+
"
)
due
to
recipe
:
"
fieldOverrideRecipe
)
;
continue
;
}
if
(
minPasswordLength
&
&
element
.
value
.
trim
(
)
.
length
<
minPasswordLength
)
{
log
(
"
skipping
password
field
(
id
/
name
is
"
element
.
id
"
/
"
element
.
name
+
"
)
as
value
is
too
short
:
"
element
.
value
.
trim
(
)
.
length
)
;
continue
;
}
pwFields
[
pwFields
.
length
]
=
{
index
:
i
element
}
;
}
if
(
!
pwFields
.
length
)
{
log
(
"
(
form
ignored
-
-
no
password
fields
.
)
"
)
;
return
null
;
}
else
if
(
pwFields
.
length
>
5
)
{
log
(
"
(
form
ignored
-
-
too
many
password
fields
.
[
got
"
pwFields
.
length
"
]
)
"
)
;
return
null
;
}
return
pwFields
;
}
_getFormFields
(
form
isSubmission
recipes
{
ignoreConnect
=
false
}
=
{
}
)
{
let
usernameField
=
null
;
let
newPasswordField
=
null
;
let
oldPasswordField
=
null
;
let
confirmPasswordField
=
null
;
let
emptyResult
=
{
usernameField
:
null
newPasswordField
:
null
oldPasswordField
:
null
confirmPasswordField
:
null
}
;
let
pwFields
=
null
;
let
fieldOverrideRecipe
=
LoginRecipesContent
.
getFieldOverrides
(
recipes
form
)
;
if
(
fieldOverrideRecipe
)
{
log
(
"
Has
fieldOverrideRecipe
"
fieldOverrideRecipe
)
;
let
pwOverrideField
=
LoginRecipesContent
.
queryLoginField
(
form
fieldOverrideRecipe
.
passwordSelector
)
;
if
(
pwOverrideField
)
{
log
(
"
Has
pwOverrideField
"
pwOverrideField
)
;
let
formLike
=
LoginFormFactory
.
createFromField
(
pwOverrideField
)
;
pwFields
=
[
{
index
:
[
.
.
.
formLike
.
elements
]
.
indexOf
(
pwOverrideField
)
element
:
pwOverrideField
}
]
;
}
let
usernameOverrideField
=
LoginRecipesContent
.
queryLoginField
(
form
fieldOverrideRecipe
.
usernameSelector
)
;
if
(
usernameOverrideField
)
{
usernameField
=
usernameOverrideField
;
}
}
if
(
!
pwFields
)
{
const
minSubmitPasswordLength
=
2
;
pwFields
=
this
.
_getPasswordFields
(
form
{
fieldOverrideRecipe
minPasswordLength
:
isSubmission
?
minSubmitPasswordLength
:
0
ignoreConnect
}
)
;
}
if
(
!
pwFields
)
{
if
(
!
LoginHelper
.
usernameOnlyFormEnabled
)
{
return
emptyResult
;
}
usernameField
=
this
.
getUsernameFieldFromUsernameOnlyForm
(
form
.
rootElement
fieldOverrideRecipe
)
;
if
(
usernameField
)
{
let
acFieldName
=
usernameField
.
getAutocompleteInfo
(
)
.
fieldName
;
log
(
"
Username
field
"
usernameField
"
has
name
/
value
/
autocomplete
:
"
usernameField
.
name
"
/
"
usernameField
.
value
"
/
"
acFieldName
)
;
}
return
{
.
.
.
emptyResult
usernameField
}
;
}
if
(
!
usernameField
)
{
for
(
let
i
=
pwFields
[
0
]
.
index
-
1
;
i
>
=
0
;
i
-
-
)
{
let
element
=
form
.
elements
[
i
]
;
if
(
!
LoginHelper
.
isUsernameFieldType
(
element
{
ignoreConnect
}
)
)
{
continue
;
}
if
(
fieldOverrideRecipe
&
&
fieldOverrideRecipe
.
notUsernameSelector
&
&
element
.
matches
(
fieldOverrideRecipe
.
notUsernameSelector
)
)
{
continue
;
}
if
(
!
usernameField
)
{
usernameField
=
element
;
}
if
(
this
.
isProbablyAUsernameField
(
element
)
)
{
usernameField
=
element
;
break
;
}
else
if
(
this
.
isProbablyAnEmailField
(
element
)
)
{
usernameField
=
element
;
}
}
}
if
(
!
usernameField
)
{
log
(
"
(
form
-
-
no
username
field
found
)
"
)
;
}
else
{
let
acFieldName
=
usernameField
.
getAutocompleteInfo
(
)
.
fieldName
;
log
(
"
Username
field
"
usernameField
"
has
name
/
value
/
autocomplete
:
"
usernameField
.
name
"
/
"
usernameField
.
value
"
/
"
acFieldName
)
;
}
let
{
generatedPasswordFields
}
=
this
.
stateForDocument
(
form
.
ownerDocument
)
;
let
pwGeneratedFields
=
pwFields
.
filter
(
pwField
=
>
generatedPasswordFields
.
has
(
pwField
.
element
)
)
;
if
(
pwGeneratedFields
.
length
)
{
[
newPasswordField
confirmPasswordField
]
=
pwGeneratedFields
.
map
(
pwField
=
>
pwField
.
element
)
;
let
idx
=
pwFields
.
findIndex
(
pwField
=
>
pwField
.
element
=
=
=
newPasswordField
)
;
if
(
idx
>
0
)
{
oldPasswordField
=
pwFields
[
idx
-
1
]
.
element
;
}
return
{
.
.
.
emptyResult
usernameField
newPasswordField
oldPasswordField
:
oldPasswordField
|
|
null
confirmPasswordField
:
confirmPasswordField
|
|
null
}
;
}
if
(
!
isSubmission
|
|
pwFields
.
length
=
=
1
)
{
let
passwordField
=
pwFields
[
0
]
.
element
;
log
(
"
Password
field
"
passwordField
"
has
name
:
"
passwordField
.
name
)
;
return
{
.
.
.
emptyResult
usernameField
newPasswordField
:
passwordField
oldPasswordField
:
null
}
;
}
let
pw1
=
pwFields
[
0
]
.
element
.
value
;
let
pw2
=
pwFields
[
1
]
?
pwFields
[
1
]
.
element
.
value
:
null
;
let
pw3
=
pwFields
[
2
]
?
pwFields
[
2
]
.
element
.
value
:
null
;
if
(
pwFields
.
length
=
=
3
)
{
if
(
pw1
=
=
pw2
&
&
pw2
=
=
pw3
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
null
;
}
else
if
(
pw1
=
=
pw2
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
pwFields
[
2
]
.
element
;
}
else
if
(
pw2
=
=
pw3
)
{
oldPasswordField
=
pwFields
[
0
]
.
element
;
newPasswordField
=
pwFields
[
2
]
.
element
;
}
else
if
(
pw1
=
=
pw3
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
pwFields
[
1
]
.
element
;
}
else
{
log
(
"
(
form
ignored
-
-
all
3
pw
fields
differ
)
"
)
;
return
emptyResult
;
}
}
else
if
(
pw1
=
=
pw2
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
null
;
}
else
{
oldPasswordField
=
pwFields
[
0
]
.
element
;
newPasswordField
=
pwFields
[
1
]
.
element
;
}
log
(
"
Password
field
(
new
)
id
/
name
is
:
"
newPasswordField
.
id
"
/
"
newPasswordField
.
name
)
;
if
(
oldPasswordField
)
{
log
(
"
Password
field
(
old
)
id
/
name
is
:
"
oldPasswordField
.
id
"
/
"
oldPasswordField
.
name
)
;
}
else
{
log
(
"
Password
field
(
old
)
:
"
oldPasswordField
)
;
}
return
{
.
.
.
emptyResult
usernameField
newPasswordField
oldPasswordField
}
;
}
_isAutocompleteDisabled
(
element
)
{
return
element
&
&
element
.
autocomplete
=
=
"
off
"
;
}
_onDocumentRestored
(
aDocument
)
{
let
rootElsWeakSet
=
LoginFormFactory
.
getRootElementsWeakSetForDocument
(
aDocument
)
;
let
weakLoginFormRootElements
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
rootElsWeakSet
)
;
log
(
"
_onDocumentRestored
:
loginFormRootElements
approx
size
:
"
weakLoginFormRootElements
.
length
"
document
:
"
aDocument
)
;
for
(
let
formRoot
of
weakLoginFormRootElements
)
{
if
(
!
formRoot
.
isConnected
)
{
continue
;
}
let
formLike
=
LoginFormFactory
.
getForRootElement
(
formRoot
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike
)
;
}
}
_onNavigation
(
aDocument
)
{
let
rootElsWeakSet
=
LoginFormFactory
.
getRootElementsWeakSetForDocument
(
aDocument
)
;
let
weakLoginFormRootElements
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
rootElsWeakSet
)
;
log
(
"
_onNavigation
:
root
elements
approx
size
:
"
weakLoginFormRootElements
.
length
"
document
:
"
aDocument
)
;
for
(
let
formRoot
of
weakLoginFormRootElements
)
{
if
(
!
formRoot
.
isConnected
)
{
continue
;
}
let
formLike
=
LoginFormFactory
.
getForRootElement
(
formRoot
)
;
this
.
_onFormSubmit
(
formLike
SUBMIT_PAGE_NAVIGATION
)
;
}
}
_onFormSubmit
(
form
reason
)
{
log
(
"
_onFormSubmit
"
form
)
;
this
.
_maybeSendFormInteractionMessage
(
form
"
PasswordManager
:
onFormSubmit
"
{
targetField
:
null
isSubmission
:
true
ignoreConnect
:
reason
=
=
SUBMIT_FORM_IS_REMOVED
}
)
;
}
_maybeSendFormInteractionMessage
(
form
messageName
{
targetField
isSubmission
triggeredByFillingGenerated
ignoreConnect
}
)
{
let
doc
=
form
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
passwordField
=
null
;
if
(
targetField
&
&
targetField
.
hasBeenTypePassword
)
{
passwordField
=
targetField
;
}
let
logMessagePrefix
=
isSubmission
?
"
form
submission
"
:
"
field
edit
"
;
let
dismissedPrompt
=
!
isSubmission
;
let
detail
=
{
messageSent
:
false
}
;
try
{
if
(
!
triggeredByFillingGenerated
&
&
PrivateBrowsingUtils
.
isContentWindowPrivate
(
win
)
&
&
!
LoginHelper
.
privateBrowsingCaptureEnabled
)
{
log
(
(
{
logMessagePrefix
}
ignored
in
private
browsing
mode
)
)
;
return
;
}
if
(
!
LoginHelper
.
enabled
)
{
return
;
}
let
origin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
if
(
!
origin
)
{
log
(
(
{
logMessagePrefix
}
ignored
-
-
invalid
origin
)
)
;
return
;
}
let
formActionOrigin
=
LoginHelper
.
getFormActionOrigin
(
form
)
;
let
recipes
=
LoginRecipesContent
.
getRecipes
(
this
origin
win
)
;
let
{
usernameField
newPasswordField
oldPasswordField
confirmPasswordField
}
=
this
.
_getFormFields
(
form
true
recipes
{
ignoreConnect
}
)
;
if
(
passwordField
&
&
passwordField
!
=
newPasswordField
&
&
passwordField
!
=
oldPasswordField
&
&
passwordField
!
=
confirmPasswordField
)
{
newPasswordField
=
passwordField
;
}
let
docState
=
this
.
stateForDocument
(
doc
)
;
if
(
newPasswordField
=
=
null
)
{
if
(
isSubmission
&
&
usernameField
)
{
log
(
"
_onFormSubmit
:
username
-
only
form
.
Record
the
username
field
but
not
sending
prompt
"
)
;
docState
.
mockUsernameOnlyField
=
{
name
:
usernameField
.
name
value
:
usernameField
.
value
}
;
}
return
;
}
let
fullyMungedPattern
=
/
^
\
*
+
|
^
+
|
^
\
.
+
/
;
if
(
isSubmission
&
&
newPasswordField
?
.
value
.
match
(
fullyMungedPattern
)
)
{
log
(
"
new
password
looks
munged
.
Not
sending
prompt
"
)
;
return
;
}
if
(
!
usernameField
)
{
if
(
docState
.
mockUsernameOnlyField
)
{
usernameField
=
docState
.
mockUsernameOnlyField
;
}
}
if
(
usernameField
&
&
usernameField
.
value
.
match
(
/
\
.
{
3
}
|
\
*
{
3
}
|
{
3
}
/
)
)
{
log
(
usernameField
.
value
"
{
usernameField
.
value
}
"
looks
munged
setting
to
null
)
;
usernameField
=
null
;
}
if
(
(
this
.
_isAutocompleteDisabled
(
form
)
|
|
this
.
_isAutocompleteDisabled
(
usernameField
)
|
|
this
.
_isAutocompleteDisabled
(
newPasswordField
)
|
|
this
.
_isAutocompleteDisabled
(
oldPasswordField
)
)
&
&
!
LoginHelper
.
storeWhenAutocompleteOff
)
{
log
(
(
{
logMessagePrefix
}
ignored
-
-
autocomplete
=
off
found
)
)
;
return
;
}
let
mockUsername
=
usernameField
?
{
name
:
usernameField
.
name
value
:
usernameField
.
value
}
:
null
;
let
mockPassword
=
{
name
:
newPasswordField
.
name
value
:
newPasswordField
.
value
}
;
let
mockOldPassword
=
oldPasswordField
?
{
name
:
oldPasswordField
.
name
value
:
oldPasswordField
.
value
}
:
null
;
let
usernameValue
=
usernameField
?
usernameField
.
value
:
null
;
let
newPasswordFieldValue
=
newPasswordField
.
value
;
if
(
(
!
dismissedPrompt
&
&
CreditCard
.
isValidNumber
(
usernameValue
)
&
&
newPasswordFieldValue
.
trim
(
)
.
match
(
/
^
[
0
-
9
]
{
3
}
/
)
)
|
|
(
CreditCard
.
isValidNumber
(
newPasswordFieldValue
)
&
&
newPasswordField
.
getAutocompleteInfo
(
)
.
fieldName
=
=
"
cc
-
number
"
)
)
{
dismissedPrompt
=
true
;
}
let
fieldsModified
=
this
.
_formHasModifiedFields
(
form
)
;
if
(
!
fieldsModified
&
&
LoginHelper
.
userInputRequiredToCapture
)
{
if
(
targetField
)
{
throw
new
Error
(
"
No
user
input
on
targetField
"
)
;
}
log
(
(
{
logMessagePrefix
}
ignored
-
-
submitting
values
that
are
not
changed
by
the
user
)
)
;
return
;
}
if
(
this
.
_compareAndUpdatePreviouslySentValues
(
form
.
rootElement
usernameValue
newPasswordField
.
value
dismissedPrompt
triggeredByFillingGenerated
)
)
{
log
(
(
{
logMessagePrefix
}
ignored
-
-
already
submitted
with
the
same
username
and
password
)
)
;
return
;
}
let
{
login
:
autoFilledLogin
}
=
docState
.
fillsByRootElement
.
get
(
form
.
rootElement
)
|
|
{
}
;
let
browsingContextId
=
win
.
windowGlobalChild
.
browsingContext
.
id
;
detail
=
{
browsingContextId
formActionOrigin
autoFilledLoginGuid
:
autoFilledLogin
&
&
autoFilledLogin
.
guid
usernameField
:
mockUsername
newPasswordField
:
mockPassword
oldPasswordField
:
mockOldPassword
dismissedPrompt
triggeredByFillingGenerated
possibleValues
:
{
usernames
:
docState
.
possibleUsernames
passwords
:
docState
.
possiblePasswords
}
messageSent
:
true
}
;
this
.
sendAsyncMessage
(
messageName
detail
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
throw
ex
;
}
finally
{
detail
.
form
=
form
;
const
evt
=
new
CustomEvent
(
messageName
{
detail
}
)
;
win
.
windowRoot
.
dispatchEvent
(
evt
)
;
}
}
_treatAsGeneratedPasswordField
(
passwordField
)
{
let
docState
=
this
.
stateForDocument
(
passwordField
.
ownerDocument
)
;
docState
.
generatedPasswordFields
.
add
(
passwordField
)
;
for
(
let
eventType
of
[
"
blur
"
"
focus
"
]
)
{
passwordField
.
addEventListener
(
eventType
observer
{
capture
:
true
mozSystemGroup
:
true
}
)
;
}
if
(
passwordField
.
ownerDocument
.
activeElement
=
=
passwordField
)
{
this
.
_togglePasswordFieldMasking
(
passwordField
true
)
;
}
}
_doesEventClearPrevFieldValue
(
{
target
data
inputType
}
)
{
return
(
!
target
.
value
|
|
(
data
&
&
data
=
=
target
.
value
&
&
inputType
!
=
=
"
insertReplacementText
"
)
)
;
}
_stopTreatingAsGeneratedPasswordField
(
passwordField
)
{
log
(
"
_stopTreatingAsGeneratedPasswordField
"
)
;
let
fields
=
this
.
stateForDocument
(
passwordField
.
ownerDocument
)
.
generatedPasswordFields
;
fields
.
delete
(
passwordField
)
;
for
(
let
eventType
of
[
"
blur
"
"
focus
"
]
)
{
passwordField
.
removeEventListener
(
eventType
observer
{
capture
:
true
mozSystemGroup
:
true
}
)
;
}
this
.
_togglePasswordFieldMasking
(
passwordField
false
)
;
}
_filledWithGeneratedPassword
(
passwordField
)
{
this
.
_highlightFilledField
(
passwordField
)
;
this
.
_passwordEditedOrGenerated
(
passwordField
{
triggeredByFillingGenerated
:
true
}
)
;
this
.
_fillConfirmFieldWithGeneratedPassword
(
passwordField
)
;
}
_ignorePasswordEdit
(
)
{
if
(
Cu
.
isInAutomation
)
{
this
.
sendAsyncMessage
(
"
PasswordManager
:
onIgnorePasswordEdit
"
{
}
)
;
}
}
_passwordEditedOrGenerated
(
passwordField
{
triggeredByFillingGenerated
=
false
}
=
{
}
)
{
log
(
"
_passwordEditedOrGenerated
"
passwordField
)
;
if
(
!
LoginHelper
.
enabled
&
&
triggeredByFillingGenerated
)
{
throw
new
Error
(
"
A
generated
password
was
filled
while
the
password
manager
was
disabled
.
"
)
;
}
let
loginForm
=
LoginFormFactory
.
createFromField
(
passwordField
)
;
if
(
triggeredByFillingGenerated
)
{
this
.
_highlightFilledField
(
passwordField
)
;
this
.
_treatAsGeneratedPasswordField
(
passwordField
)
;
this
.
_fieldsWithPasswordGenerationForcedOn
.
delete
(
passwordField
)
;
}
this
.
_maybeSendFormInteractionMessage
(
loginForm
"
PasswordManager
:
onPasswordEditedOrGenerated
"
{
targetField
:
passwordField
isSubmission
:
false
triggeredByFillingGenerated
}
)
;
}
_fillConfirmFieldWithGeneratedPassword
(
passwordField
)
{
let
form
=
LoginFormFactory
.
createFromField
(
passwordField
)
;
let
confirmPasswordInput
=
null
;
let
docState
=
this
.
stateForDocument
(
passwordField
.
ownerDocument
)
;
let
MAX_CONFIRM_PASSWORD_DISTANCE
=
3
;
let
startIndex
=
form
.
elements
.
indexOf
(
passwordField
)
;
if
(
startIndex
=
=
-
1
)
{
throw
new
Error
(
"
Password
field
is
not
in
the
form
'
s
elements
collection
"
)
;
}
let
previousGeneratedPasswordField
=
form
.
elements
.
some
(
inp
=
>
inp
!
=
=
passwordField
&
&
docState
.
generatedPasswordFields
.
has
(
inp
)
)
;
if
(
previousGeneratedPasswordField
)
{
log
(
"
_fillConfirmFieldWithGeneratedPassword
previously
-
filled
generated
password
input
found
"
)
;
return
;
}
let
afterFields
=
form
.
elements
.
slice
(
startIndex
+
1
)
.
filter
(
elem
=
>
elem
.
type
!
=
=
"
hidden
"
)
;
let
acFieldName
=
passwordField
.
getAutocompleteInfo
(
)
?
.
fieldName
;
if
(
acFieldName
&
&
acFieldName
=
=
"
new
-
password
"
)
{
let
matchIndex
=
afterFields
.
findIndex
(
elem
=
>
LoginHelper
.
isPasswordFieldType
(
elem
)
&
&
elem
.
getAutocompleteInfo
(
)
.
fieldName
=
=
acFieldName
&
&
!
elem
.
disabled
&
&
!
elem
.
readOnly
)
;
if
(
matchIndex
>
=
0
&
&
matchIndex
<
MAX_CONFIRM_PASSWORD_DISTANCE
)
{
confirmPasswordInput
=
afterFields
[
matchIndex
]
;
}
}
if
(
!
confirmPasswordInput
)
{
for
(
let
idx
=
0
;
idx
<
Math
.
min
(
MAX_CONFIRM_PASSWORD_DISTANCE
afterFields
.
length
)
;
idx
+
+
)
{
if
(
LoginHelper
.
isPasswordFieldType
(
afterFields
[
idx
]
)
&
&
!
afterFields
[
idx
]
.
disabled
&
&
!
afterFields
[
idx
]
.
readOnly
)
{
confirmPasswordInput
=
afterFields
[
idx
]
;
break
;
}
}
}
if
(
confirmPasswordInput
&
&
!
confirmPasswordInput
.
value
)
{
this
.
_treatAsGeneratedPasswordField
(
confirmPasswordInput
)
;
confirmPasswordInput
.
setUserInput
(
passwordField
.
value
)
;
this
.
_highlightFilledField
(
confirmPasswordInput
)
;
}
}
_togglePasswordFieldMasking
(
passwordField
unmask
)
{
let
{
editor
}
=
passwordField
;
if
(
passwordField
.
type
!
=
"
password
"
)
{
log
(
"
_togglePasswordFieldMasking
:
Field
isn
'
t
type
=
password
"
)
;
return
;
}
if
(
!
unmask
&
&
!
editor
)
{
return
;
}
if
(
unmask
)
{
editor
.
unmask
(
0
)
;
return
;
}
if
(
editor
.
autoMaskingEnabled
)
{
return
;
}
editor
.
mask
(
)
;
}
_removeFillFieldHighlight
(
event
)
{
let
winUtils
=
event
.
target
.
ownerGlobal
.
windowUtils
;
winUtils
.
removeManuallyManagedState
(
event
.
target
AUTOFILL_STATE
)
;
}
_highlightFilledField
(
element
)
{
let
winUtils
=
element
.
ownerGlobal
.
windowUtils
;
winUtils
.
addManuallyManagedState
(
element
AUTOFILL_STATE
)
;
element
.
addEventListener
(
"
input
"
this
.
_removeFillFieldHighlight
{
mozSystemGroup
:
true
once
:
true
}
)
;
}
_filterForExactFormOriginLogins
(
logins
form
)
{
let
loginOrigin
=
LoginHelper
.
getLoginOrigin
(
form
.
ownerDocument
.
documentURI
)
;
let
formActionOrigin
=
LoginHelper
.
getFormActionOrigin
(
form
)
;
logins
=
logins
.
filter
(
l
=
>
{
let
formActionMatches
=
LoginHelper
.
isOriginMatching
(
l
.
formActionOrigin
formActionOrigin
{
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
acceptWildcardMatch
:
true
acceptDifferentSubdomains
:
true
}
)
;
let
formOriginMatches
=
LoginHelper
.
isOriginMatching
(
l
.
origin
loginOrigin
{
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
acceptWildcardMatch
:
true
acceptDifferentSubdomains
:
false
}
)
;
return
formActionMatches
&
&
formOriginMatches
;
}
)
;
logins
=
LoginHelper
.
dedupeLogins
(
logins
[
"
username
"
]
[
"
scheme
"
"
timePasswordChanged
"
]
loginOrigin
formActionOrigin
)
;
return
logins
;
}
_fillForm
(
form
foundLogins
recipes
{
inputElement
=
null
autofillForm
=
false
importable
=
null
clobberUsername
=
false
clobberPassword
=
false
userTriggered
=
false
style
=
null
}
=
{
}
)
{
if
(
ChromeUtils
.
getClassName
(
form
)
=
=
=
"
HTMLFormElement
"
)
{
throw
new
Error
(
"
_fillForm
should
only
be
called
with
LoginForm
objects
"
)
;
}
log
(
"
_fillForm
"
form
.
elements
)
;
let
autofillResult
=
-
1
;
const
AUTOFILL_RESULT
=
{
FILLED
:
0
NO_PASSWORD_FIELD
:
1
PASSWORD_DISABLED_READONLY
:
2
NO_LOGINS_FIT
:
3
NO_SAVED_LOGINS
:
4
EXISTING_PASSWORD
:
5
EXISTING_USERNAME
:
6
MULTIPLE_LOGINS
:
7
NO_AUTOFILL_FORMS
:
8
AUTOCOMPLETE_OFF
:
9
INSECURE
:
10
PASSWORD_AUTOCOMPLETE_NEW_PASSWORD
:
11
TYPE_NO_LONGER_PASSWORD
:
12
FORM_IN_CROSSORIGIN_SUBFRAME
:
13
FILLED_USERNAME_ONLY_FORM
:
14
}
;
let
{
usernameField
newPasswordField
:
passwordField
}
=
this
.
_getFormFields
(
form
false
recipes
)
;
try
{
if
(
!
foundLogins
.
length
&
&
!
(
importable
?
.
state
=
=
=
"
import
"
&
&
importable
?
.
browsers
)
&
&
(
InsecurePasswordUtils
.
isFormSecure
(
form
)
|
|
!
LoginHelper
.
showInsecureFieldWarning
)
)
{
autofillResult
=
AUTOFILL_RESULT
.
NO_SAVED_LOGINS
;
return
;
}
if
(
inputElement
)
{
if
(
inputElement
.
hasBeenTypePassword
)
{
passwordField
=
inputElement
;
if
(
!
clobberUsername
)
{
usernameField
=
null
;
}
}
else
if
(
LoginHelper
.
isUsernameFieldType
(
inputElement
)
)
{
usernameField
=
inputElement
;
}
else
{
throw
new
Error
(
"
Unexpected
input
element
type
.
"
)
;
}
}
if
(
passwordField
=
=
null
&
&
usernameField
=
=
null
)
{
log
(
"
not
filling
form
no
password
and
username
field
found
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
NO_PASSWORD_FIELD
;
return
;
}
if
(
passwordField
?
.
disabled
|
|
passwordField
?
.
readOnly
)
{
log
(
"
not
filling
form
password
field
disabled
or
read
-
only
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
PASSWORD_DISABLED_READONLY
;
return
;
}
if
(
usernameField
)
{
gFormFillService
.
markAsLoginManagerField
(
usernameField
)
;
usernameField
.
addEventListener
(
"
keydown
"
observer
)
;
}
if
(
!
userTriggered
&
&
!
form
.
rootElement
.
ownerGlobal
.
windowGlobalChild
.
sameOriginWithTop
)
{
log
(
"
not
filling
form
;
it
is
in
a
cross
-
origin
subframe
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
FORM_IN_CROSSORIGIN_SUBFRAME
;
return
;
}
if
(
!
userTriggered
)
{
foundLogins
=
this
.
_filterForExactFormOriginLogins
(
foundLogins
form
)
;
}
if
(
!
foundLogins
.
length
)
{
autofillResult
=
AUTOFILL_RESULT
.
NO_SAVED_LOGINS
;
return
;
}
if
(
!
userTriggered
&
&
!
LoginHelper
.
insecureAutofill
&
&
!
InsecurePasswordUtils
.
isFormSecure
(
form
)
)
{
log
(
"
not
filling
form
since
it
'
s
insecure
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
INSECURE
;
return
;
}
let
maxUsernameLen
=
Number
.
MAX_VALUE
;
let
maxPasswordLen
=
Number
.
MAX_VALUE
;
if
(
usernameField
?
.
maxLength
>
=
0
)
{
maxUsernameLen
=
usernameField
.
maxLength
;
}
if
(
passwordField
?
.
maxLength
>
=
0
)
{
maxPasswordLen
=
passwordField
.
maxLength
;
}
let
logins
=
foundLogins
.
filter
(
function
(
l
)
{
let
fit
=
l
.
username
.
length
<
=
maxUsernameLen
&
&
l
.
password
.
length
<
=
maxPasswordLen
;
if
(
!
fit
)
{
log
(
"
Ignored
"
l
.
username
"
login
:
won
'
t
fit
"
)
;
}
return
fit
;
}
this
)
;
if
(
!
logins
.
length
)
{
log
(
"
form
not
filled
none
of
the
logins
fit
in
the
field
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
NO_LOGINS_FIT
;
return
;
}
const
passwordACFieldName
=
passwordField
?
.
getAutocompleteInfo
(
)
.
fieldName
;
if
(
passwordField
)
{
if
(
!
userTriggered
&
&
passwordField
.
type
!
=
"
password
"
)
{
log
(
"
not
autofilling
password
field
isn
'
t
currently
type
=
password
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
TYPE_NO_LONGER_PASSWORD
;
return
;
}
if
(
!
userTriggered
&
&
passwordACFieldName
=
=
"
new
-
password
"
)
{
log
(
"
not
filling
form
password
field
has
the
autocomplete
new
-
password
value
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
PASSWORD_AUTOCOMPLETE_NEW_PASSWORD
;
return
;
}
if
(
passwordField
.
value
&
&
!
clobberPassword
)
{
log
(
"
form
not
filled
the
password
field
was
already
filled
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
EXISTING_PASSWORD
;
return
;
}
}
let
selectedLogin
;
if
(
!
clobberUsername
&
&
usernameField
&
&
(
usernameField
.
value
|
|
usernameField
.
disabled
|
|
usernameField
.
readOnly
)
)
{
let
username
=
usernameField
.
value
.
toLowerCase
(
)
;
let
matchingLogins
=
logins
.
filter
(
l
=
>
l
.
username
.
toLowerCase
(
)
=
=
username
)
;
if
(
!
matchingLogins
.
length
)
{
log
(
"
Password
not
filled
.
None
of
the
stored
logins
match
the
username
already
present
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
EXISTING_USERNAME
;
return
;
}
for
(
let
l
of
matchingLogins
)
{
if
(
l
.
username
=
=
usernameField
.
value
)
{
selectedLogin
=
l
;
}
}
if
(
!
selectedLogin
)
{
selectedLogin
=
matchingLogins
[
0
]
;
}
}
else
if
(
logins
.
length
=
=
1
)
{
selectedLogin
=
logins
[
0
]
;
}
else
{
let
matchingLogins
;
if
(
usernameField
)
{
matchingLogins
=
logins
.
filter
(
l
=
>
l
.
username
)
;
}
else
{
matchingLogins
=
logins
.
filter
(
l
=
>
!
l
.
username
)
;
}
if
(
matchingLogins
.
length
!
=
1
)
{
log
(
"
Multiple
logins
for
form
so
not
filling
any
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
MULTIPLE_LOGINS
;
return
;
}
selectedLogin
=
matchingLogins
[
0
]
;
}
if
(
!
autofillForm
)
{
log
(
"
autofillForms
=
false
but
form
can
be
filled
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
NO_AUTOFILL_FORMS
;
return
;
}
if
(
!
userTriggered
&
&
passwordACFieldName
=
=
"
off
"
&
&
!
LoginHelper
.
autofillAutocompleteOff
)
{
log
(
"
Not
autofilling
the
login
because
we
'
re
respecting
autocomplete
=
off
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
AUTOCOMPLETE_OFF
;
return
;
}
let
doc
=
form
.
ownerDocument
;
let
willAutofill
=
usernameField
|
|
passwordField
.
value
!
=
selectedLogin
.
password
;
if
(
willAutofill
)
{
let
autoFilledLogin
=
{
guid
:
selectedLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
.
guid
username
:
selectedLogin
.
username
usernameField
:
usernameField
?
Cu
.
getWeakReference
(
usernameField
)
:
null
password
:
selectedLogin
.
password
passwordField
:
passwordField
?
Cu
.
getWeakReference
(
passwordField
)
:
null
}
;
log
(
"
Saving
autoFilledLogin
"
autoFilledLogin
.
guid
"
for
"
form
.
rootElement
)
;
this
.
stateForDocument
(
doc
)
.
fillsByRootElement
.
set
(
form
.
rootElement
{
login
:
autoFilledLogin
userTriggered
}
)
;
}
if
(
usernameField
)
{
let
disabledOrReadOnly
=
usernameField
.
disabled
|
|
usernameField
.
readOnly
;
if
(
selectedLogin
.
username
&
&
!
disabledOrReadOnly
)
{
let
userNameDiffers
=
selectedLogin
.
username
!
=
usernameField
.
value
;
let
userEnteredDifferentCase
=
userTriggered
&
&
userNameDiffers
&
&
usernameField
.
value
.
toLowerCase
(
)
=
=
selectedLogin
.
username
.
toLowerCase
(
)
;
if
(
!
userEnteredDifferentCase
&
&
userNameDiffers
)
{
usernameField
.
setUserInput
(
selectedLogin
.
username
)
;
}
this
.
_highlightFilledField
(
usernameField
)
;
}
}
if
(
passwordField
)
{
if
(
passwordField
.
value
!
=
selectedLogin
.
password
)
{
this
.
_stopTreatingAsGeneratedPasswordField
(
passwordField
)
;
passwordField
.
setUserInput
(
selectedLogin
.
password
)
;
}
this
.
_highlightFilledField
(
passwordField
)
;
}
if
(
style
&
&
style
=
=
=
"
generatedPassword
"
)
{
this
.
_filledWithGeneratedPassword
(
passwordField
)
;
}
log
(
"
_fillForm
succeeded
"
)
;
if
(
passwordField
)
{
autofillResult
=
AUTOFILL_RESULT
.
FILLED
;
}
else
if
(
usernameField
)
{
autofillResult
=
AUTOFILL_RESULT
.
FILLED_USERNAME_ONLY_FORM
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
throw
ex
;
}
finally
{
if
(
autofillResult
=
=
-
1
)
{
throw
new
Error
(
"
_fillForm
:
autofillResult
must
be
specified
"
)
;
}
if
(
!
userTriggered
)
{
Services
.
telemetry
.
getHistogramById
(
"
PWMGR_FORM_AUTOFILL_RESULT
"
)
.
add
(
autofillResult
)
;
if
(
usernameField
)
{
let
focusedElement
=
gFormFillService
.
focusedInput
;
if
(
usernameField
=
=
focusedElement
&
&
!
[
AUTOFILL_RESULT
.
FILLED
AUTOFILL_STATE
.
FILLED_USERNAME_ONLY_FORM
]
.
includes
(
autofillResult
)
)
{
log
(
"
_fillForm
:
Opening
username
autocomplete
popup
since
the
form
wasn
'
t
autofilled
"
)
;
gFormFillService
.
showPopup
(
)
;
}
}
}
if
(
usernameField
)
{
log
(
"
_fillForm
:
Attaching
event
listeners
to
usernameField
"
)
;
usernameField
.
addEventListener
(
"
focus
"
observer
)
;
usernameField
.
addEventListener
(
"
mousedown
"
observer
)
;
}
this
.
sendAsyncMessage
(
"
PasswordManager
:
formProcessed
"
{
formid
:
form
.
rootElement
.
id
}
)
;
}
}
_formHasModifiedFields
(
form
)
{
let
doc
=
form
.
rootElement
.
ownerDocument
;
let
userHasInteracted
;
let
testOnlyUserHasInteracted
=
LoginHelper
.
testOnlyUserHasInteractedWithDocument
;
if
(
Cu
.
isInAutomation
&
&
testOnlyUserHasInteracted
!
=
=
null
)
{
userHasInteracted
=
testOnlyUserHasInteracted
;
}
else
{
userHasInteracted
=
doc
.
userHasInteracted
;
}
log
(
"
_formHasModifiedFields
userHasInteracted
:
"
userHasInteracted
)
;
if
(
!
userHasInteracted
)
{
return
false
;
}
let
state
=
this
.
stateForDocument
(
doc
)
;
let
fieldsModified
=
state
.
fieldModificationsByRootElement
.
get
(
form
.
rootElement
)
;
if
(
!
fieldsModified
)
{
fieldsModified
=
Array
.
from
(
form
.
elements
)
.
some
(
field
=
>
field
.
defaultValue
!
=
=
undefined
&
&
field
.
value
!
=
=
field
.
defaultValue
)
;
}
return
fieldsModified
;
}
_isLoginAlreadyFilled
(
aUsernameField
)
{
let
formLikeRoot
=
FormLikeFactory
.
findRootForField
(
aUsernameField
)
;
let
existingLoginForm
=
LoginFormFactory
.
getForRootElement
(
formLikeRoot
)
;
if
(
!
existingLoginForm
)
{
throw
new
Error
(
"
_isLoginAlreadyFilled
called
with
a
username
field
with
"
+
"
no
rootElement
LoginForm
"
)
;
}
log
(
"
_isLoginAlreadyFilled
:
existingLoginForm
"
existingLoginForm
)
;
let
{
login
:
filledLogin
}
=
this
.
stateForDocument
(
aUsernameField
.
ownerDocument
)
.
fillsByRootElement
.
get
(
formLikeRoot
)
|
|
{
}
;
if
(
!
filledLogin
)
{
return
false
;
}
let
autoFilledUsernameField
=
filledLogin
.
usernameField
?
.
get
(
)
;
let
autoFilledPasswordField
=
filledLogin
.
passwordField
?
.
get
(
)
;
if
(
!
autoFilledUsernameField
|
|
autoFilledUsernameField
!
=
aUsernameField
|
|
autoFilledUsernameField
.
value
!
=
filledLogin
.
username
|
|
(
autoFilledPasswordField
&
&
autoFilledPasswordField
.
value
!
=
filledLogin
.
password
)
)
{
return
false
;
}
return
true
;
}
getUserNameAndPasswordFields
(
aField
)
{
let
noResult
=
[
null
null
null
]
;
if
(
ChromeUtils
.
getClassName
(
aField
)
!
=
=
"
HTMLInputElement
"
)
{
throw
new
Error
(
"
getUserNameAndPasswordFields
:
input
element
required
"
)
;
}
if
(
aField
.
nodePrincipal
.
isNullPrincipal
|
|
!
aField
.
isConnected
)
{
return
noResult
;
}
if
(
!
aField
.
hasBeenTypePassword
&
&
!
LoginHelper
.
isUsernameFieldType
(
aField
)
)
{
return
noResult
;
}
let
form
=
LoginFormFactory
.
createFromField
(
aField
)
;
let
doc
=
aField
.
ownerDocument
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
let
recipes
=
LoginRecipesContent
.
getRecipes
(
this
formOrigin
doc
.
defaultView
)
;
let
{
usernameField
newPasswordField
oldPasswordField
}
=
this
.
_getFormFields
(
form
false
recipes
)
;
return
[
usernameField
newPasswordField
oldPasswordField
]
;
}
getFieldContext
(
aField
)
{
if
(
ChromeUtils
.
getClassName
(
aField
)
!
=
=
"
HTMLInputElement
"
|
|
(
!
aField
.
hasBeenTypePassword
&
&
!
LoginHelper
.
isUsernameFieldType
(
aField
)
)
|
|
aField
.
nodePrincipal
.
isNullPrincipal
|
|
aField
.
nodePrincipal
.
schemeIs
(
"
about
"
)
|
|
!
aField
.
ownerDocument
)
{
return
null
;
}
let
{
hasBeenTypePassword
}
=
aField
;
const
LOGIN_FIELD_ORDER
=
[
"
username
"
"
new
-
password
"
"
current
-
password
"
]
;
let
usernameAndPasswordFields
=
this
.
getUserNameAndPasswordFields
(
aField
)
;
let
fieldNameHint
;
let
indexOfFieldInUsernameAndPasswordFields
=
usernameAndPasswordFields
.
indexOf
(
aField
)
;
if
(
indexOfFieldInUsernameAndPasswordFields
=
=
-
1
)
{
fieldNameHint
=
hasBeenTypePassword
?
"
current
-
password
"
:
"
other
"
;
}
else
{
fieldNameHint
=
LOGIN_FIELD_ORDER
[
indexOfFieldInUsernameAndPasswordFields
]
;
}
let
[
newPasswordField
]
=
usernameAndPasswordFields
;
return
{
activeField
:
{
disabled
:
aField
.
disabled
|
|
aField
.
readOnly
fieldNameHint
}
passwordField
:
{
found
:
!
!
newPasswordField
disabled
:
newPasswordField
&
&
(
newPasswordField
.
disabled
|
|
newPasswordField
.
readOnly
)
}
}
;
}
getUsernameFieldFromUsernameOnlyForm
(
formElement
recipe
=
null
)
{
if
(
ChromeUtils
.
getClassName
(
formElement
)
!
=
=
"
HTMLFormElement
"
)
{
return
null
;
}
let
candidate
=
null
;
for
(
let
element
of
formElement
.
elements
)
{
if
(
ChromeUtils
.
getClassName
(
element
)
!
=
=
"
HTMLInputElement
"
)
{
continue
;
}
if
(
element
.
hasBeenTypePassword
)
{
return
null
;
}
if
(
!
LoginHelper
.
isUsernameFieldType
(
element
)
)
{
continue
;
}
if
(
recipe
?
.
notUsernameSelector
&
&
element
.
matches
(
recipe
.
notUsernameSelector
)
)
{
continue
;
}
if
(
candidate
)
{
return
null
;
}
candidate
=
element
;
}
if
(
candidate
&
&
this
.
isProbablyAUsernameLoginForm
(
formElement
candidate
)
)
{
return
candidate
;
}
return
null
;
}
isProbablyAUsernameField
(
inputElement
)
{
let
docState
=
this
.
stateForDocument
(
inputElement
.
ownerDocument
)
;
let
result
=
docState
.
cachedIsInferredUsernameField
.
get
(
inputElement
)
;
if
(
result
=
=
=
undefined
)
{
result
=
LoginHelper
.
isInferredUsernameField
(
inputElement
)
;
docState
.
cachedIsInferredUsernameField
.
set
(
inputElement
result
)
;
}
return
result
;
}
isProbablyAnEmailField
(
inputElement
)
{
let
docState
=
this
.
stateForDocument
(
inputElement
.
ownerDocument
)
;
let
result
=
docState
.
cachedIsInferredEmailField
.
get
(
inputElement
)
;
if
(
result
=
=
=
undefined
)
{
result
=
LoginHelper
.
isInferredEmailField
(
inputElement
)
;
docState
.
cachedIsInferredEmailField
.
set
(
inputElement
result
)
;
}
return
result
;
}
isProbablyAUsernameLoginForm
(
formElement
inputElement
)
{
let
docState
=
this
.
stateForDocument
(
formElement
.
ownerDocument
)
;
let
result
=
docState
.
cachedIsInferredLoginForm
.
get
(
formElement
)
;
if
(
result
=
=
=
undefined
)
{
result
=
false
;
if
(
this
.
isProbablyAUsernameField
(
inputElement
)
|
|
LoginHelper
.
isInferredLoginForm
(
formElement
)
)
{
if
(
!
LoginHelper
.
isInferredNonUsernameField
(
inputElement
)
)
{
result
=
true
;
}
}
docState
.
cachedIsInferredLoginForm
.
set
(
formElement
result
)
;
}
return
result
;
}
}
;
