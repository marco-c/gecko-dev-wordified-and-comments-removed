"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
LoginManagerChild
"
]
;
const
PASSWORD_INPUT_ADDED_COALESCING_THRESHOLD_MS
=
1
;
const
AUTOCOMPLETE_AFTER_RIGHT_CLICK_THRESHOLD_MS
=
400
;
const
AUTOFILL_STATE
=
"
-
moz
-
autofill
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
PrivateBrowsingUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
{
CreditCard
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
CreditCard
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FormLikeFactory
"
"
resource
:
/
/
gre
/
modules
/
FormLikeFactory
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginFormFactory
"
"
resource
:
/
/
gre
/
modules
/
LoginFormFactory
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginRecipesContent
"
"
resource
:
/
/
gre
/
modules
/
LoginRecipes
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
InsecurePasswordUtils
"
"
resource
:
/
/
gre
/
modules
/
InsecurePasswordUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ContentDOMReference
"
"
resource
:
/
/
gre
/
modules
/
ContentDOMReference
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AutoCompleteChild
"
"
resource
:
/
/
gre
/
actors
/
AutoCompleteChild
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gFormFillService
"
"
mozilla
.
org
/
satchel
/
form
-
fill
-
controller
;
1
"
"
nsIFormFillController
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
logger
=
LoginHelper
.
createLogger
(
"
LoginManagerChild
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
Services
.
cpmm
.
addMessageListener
(
"
clearRecipeCache
"
(
)
=
>
{
LoginRecipesContent
.
_clearRecipeCache
(
)
;
}
)
;
let
gLastRightClickTimeStamp
=
Number
.
NEGATIVE_INFINITY
;
let
gKeyDownEnterForInput
=
null
;
const
observer
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
if
(
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
|
|
!
(
aWebProgress
.
loadType
&
Ci
.
nsIDocShell
.
LOAD_CMD_PUSHSTATE
)
)
{
return
;
}
log
(
"
onLocationChange
handled
:
"
aLocation
.
displaySpec
aWebProgress
.
DOMWindow
.
document
)
;
LoginManagerChild
.
forWindow
(
aWebProgress
.
DOMWindow
)
.
_onNavigation
(
aWebProgress
.
DOMWindow
.
document
)
;
}
onStateChange
(
aWebProgress
aRequest
aState
aStatus
)
{
if
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_RESTORING
&
&
aState
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
LoginManagerChild
.
forWindow
(
aWebProgress
.
DOMWindow
)
.
_onDocumentRestored
(
aWebProgress
.
DOMWindow
.
document
)
;
return
;
}
if
(
!
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
)
{
return
;
}
let
channel
=
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
triggeringPrincipal
=
channel
.
loadInfo
.
triggeringPrincipal
;
if
(
triggeringPrincipal
.
isNullPrincipal
|
|
triggeringPrincipal
.
equals
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
)
{
return
;
}
if
(
!
(
aWebProgress
.
loadType
&
Ci
.
nsIDocShell
.
LOAD_CMD_NORMAL
)
)
{
log
(
"
onStateChange
:
loadType
isn
'
t
LOAD_CMD_NORMAL
:
"
aWebProgress
.
loadType
)
;
return
;
}
log
(
"
onStateChange
handled
:
"
channel
)
;
LoginManagerChild
.
forWindow
(
aWebProgress
.
DOMWindow
)
.
_onNavigation
(
aWebProgress
.
DOMWindow
.
document
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
autocomplete
-
did
-
enter
-
text
"
:
{
let
input
=
subject
.
QueryInterface
(
Ci
.
nsIAutoCompleteInput
)
;
let
{
selectedIndex
}
=
input
.
popup
;
if
(
selectedIndex
<
0
)
{
break
;
}
let
{
focusedInput
}
=
gFormFillService
;
if
(
focusedInput
.
nodePrincipal
.
isNullPrincipal
)
{
return
;
}
let
window
=
focusedInput
.
ownerGlobal
;
let
loginManagerChild
=
LoginManagerChild
.
forWindow
(
window
)
;
let
style
=
input
.
controller
.
getStyleAt
(
selectedIndex
)
;
if
(
style
=
=
"
login
"
|
|
style
=
=
"
loginWithOrigin
"
)
{
let
details
=
JSON
.
parse
(
input
.
controller
.
getCommentAt
(
selectedIndex
)
)
;
loginManagerChild
.
onFieldAutoComplete
(
focusedInput
details
.
guid
)
;
}
else
if
(
style
=
=
"
generatedPassword
"
)
{
loginManagerChild
.
_highlightFilledField
(
focusedInput
)
;
loginManagerChild
.
_generatedPasswordFilledOrEdited
(
focusedInput
)
;
}
break
;
}
}
}
handleEvent
(
aEvent
)
{
if
(
!
aEvent
.
isTrusted
)
{
return
;
}
if
(
!
LoginHelper
.
enabled
)
{
return
;
}
let
window
=
aEvent
.
target
.
ownerDocument
.
defaultView
;
switch
(
aEvent
.
type
)
{
case
"
blur
"
:
{
let
unmask
=
false
;
LoginManagerChild
.
forWindow
(
window
)
.
_togglePasswordFieldMasking
(
aEvent
.
target
unmask
)
;
break
;
}
case
"
change
"
:
{
LoginManagerChild
.
forWindow
(
window
)
.
_generatedPasswordFilledOrEdited
(
aEvent
.
target
)
;
break
;
}
case
"
input
"
:
{
LoginManagerChild
.
forWindow
(
window
)
.
_maybeStopTreatingAsGeneratedPasswordField
(
aEvent
)
;
break
;
}
case
"
keydown
"
:
{
if
(
aEvent
.
keyCode
=
=
aEvent
.
DOM_VK_TAB
|
|
aEvent
.
keyCode
=
=
aEvent
.
DOM_VK_RETURN
)
{
LoginManagerChild
.
forWindow
(
window
)
.
onUsernameAutocompleted
(
aEvent
.
target
)
;
}
break
;
}
case
"
focus
"
:
{
if
(
aEvent
.
target
.
type
=
=
"
password
"
)
{
let
unmask
=
true
;
LoginManagerChild
.
forWindow
(
window
)
.
_togglePasswordFieldMasking
(
aEvent
.
target
unmask
)
;
break
;
}
LoginManagerChild
.
forWindow
(
window
)
.
_onUsernameFocus
(
aEvent
)
;
break
;
}
case
"
mousedown
"
:
{
if
(
aEvent
.
button
=
=
2
)
{
gLastRightClickTimeStamp
=
Date
.
now
(
)
;
}
break
;
}
default
:
{
throw
new
Error
(
"
Unexpected
event
"
)
;
}
}
}
}
;
Services
.
obs
.
addObserver
(
observer
"
autocomplete
-
did
-
enter
-
text
"
)
;
let
gAutoCompleteListener
=
{
keyDownEnterForInput
:
null
added
:
false
init
(
)
{
if
(
!
this
.
added
)
{
AutoCompleteChild
.
addPopupStateListener
(
(
.
.
.
args
)
=
>
{
this
.
popupStateListener
(
.
.
.
args
)
;
}
)
;
this
.
added
=
true
;
}
}
popupStateListener
(
messageName
data
target
)
{
switch
(
messageName
)
{
case
"
FormAutoComplete
:
PopupOpened
"
:
{
let
{
chromeEventHandler
}
=
target
.
docShell
;
chromeEventHandler
.
addEventListener
(
"
keydown
"
this
true
)
;
break
;
}
case
"
FormAutoComplete
:
PopupClosed
"
:
{
this
.
onPopupClosed
(
data
.
selectedRowStyle
target
)
;
let
{
chromeEventHandler
}
=
target
.
docShell
;
chromeEventHandler
.
removeEventListener
(
"
keydown
"
this
true
)
;
break
;
}
}
}
handleEvent
(
event
)
{
if
(
event
.
type
!
=
"
keydown
"
)
{
return
;
}
let
focusedElement
=
gFormFillService
.
focusedInput
;
if
(
event
.
keyCode
!
=
event
.
DOM_VK_RETURN
|
|
focusedElement
!
=
event
.
target
)
{
this
.
keyDownEnterForInput
=
null
;
return
;
}
this
.
keyDownEnterForInput
=
focusedElement
;
}
onPopupClosed
(
selectedRowStyle
window
)
{
let
focusedElement
=
gFormFillService
.
focusedInput
;
let
eventTarget
=
this
.
keyDownEnterForInput
;
if
(
!
eventTarget
|
|
eventTarget
!
=
=
focusedElement
|
|
selectedRowStyle
!
=
"
loginsFooter
"
)
{
this
.
keyDownEnterForInput
=
null
;
return
;
}
let
loginManager
=
window
.
getWindowGlobalChild
(
)
.
getActor
(
"
LoginManager
"
)
;
let
hostname
=
eventTarget
.
ownerDocument
.
documentURIObject
.
host
;
loginManager
.
sendAsyncMessage
(
"
PasswordManager
:
OpenPreferences
"
{
hostname
entryPoint
:
"
autocomplete
"
}
)
;
}
}
;
this
.
LoginManagerChild
=
class
LoginManagerChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
_deferredPasswordAddedTasksByRootElement
=
new
WeakMap
(
)
;
this
.
_visibleTasksByDocument
=
new
WeakMap
(
)
;
this
.
_loginFormStateByDocument
=
new
WeakMap
(
)
;
}
static
forWindow
(
window
)
{
let
windowGlobal
=
window
.
getWindowGlobalChild
(
)
;
if
(
windowGlobal
)
{
return
windowGlobal
.
getActor
(
"
LoginManager
"
)
;
}
return
null
;
}
_compareAndUpdatePreviouslySentValues
(
formLikeRoot
usernameValue
passwordValue
dismissed
=
false
)
{
let
state
=
this
.
stateForDocument
(
formLikeRoot
.
ownerDocument
)
;
const
lastSentValues
=
state
.
lastSubmittedValuesByRootElement
.
get
(
formLikeRoot
)
;
if
(
lastSentValues
)
{
if
(
dismissed
&
&
!
lastSentValues
.
dismissed
)
{
dismissed
=
false
;
}
if
(
lastSentValues
.
username
=
=
usernameValue
&
&
lastSentValues
.
password
=
=
passwordValue
&
&
lastSentValues
.
dismissed
=
=
dismissed
)
{
log
(
"
_compareAndUpdatePreviouslySentValues
:
values
are
equivalent
returning
true
"
)
;
return
true
;
}
}
state
.
lastSubmittedValuesByRootElement
.
set
(
formLikeRoot
{
username
:
usernameValue
password
:
passwordValue
dismissed
}
)
;
log
(
"
_compareAndUpdatePreviouslySentValues
:
values
not
equivalent
returning
false
"
)
;
return
false
;
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
PasswordManager
:
fillForm
"
:
{
this
.
fillForm
(
{
loginFormOrigin
:
msg
.
data
.
loginFormOrigin
loginsFound
:
LoginHelper
.
vanillaObjectsToLogins
(
msg
.
data
.
logins
)
recipes
:
msg
.
data
.
recipes
inputElementIdentifier
:
msg
.
data
.
inputElementIdentifier
originMatches
:
msg
.
data
.
originMatches
}
)
;
break
;
}
case
"
PasswordManager
:
fillGeneratedPassword
"
:
{
let
generatedLogin
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
generatedLogin
.
init
(
msg
.
data
.
origin
"
"
null
"
"
msg
.
data
.
password
)
;
this
.
fillForm
(
{
loginFormOrigin
:
msg
.
data
.
origin
loginsFound
:
[
generatedLogin
]
recipes
:
msg
.
data
.
recipes
inputElementIdentifier
:
msg
.
data
.
inputElementIdentifier
originMatches
:
msg
.
data
.
originMatches
}
)
;
let
inputElement
=
ContentDOMReference
.
resolve
(
msg
.
data
.
inputElementIdentifier
)
;
if
(
inputElement
)
{
this
.
_generatedPasswordFilledOrEdited
(
inputElement
)
;
}
else
{
log
(
"
Could
not
resolve
inputElementIdentifier
to
a
living
element
.
"
)
;
}
break
;
}
case
"
PasswordManager
:
formIsPending
"
:
{
return
this
.
_visibleTasksByDocument
.
has
(
this
.
document
)
;
}
case
"
PasswordManager
:
formProcessed
"
:
{
this
.
notifyObserversOfFormProcessed
(
msg
.
data
.
formid
)
;
break
;
}
}
return
undefined
;
}
notifyObserversOfFormProcessed
(
formid
)
{
Services
.
obs
.
notifyObservers
(
this
"
passwordmgr
-
processed
-
form
"
formid
)
;
}
_getLoginDataFromParent
(
form
options
)
{
let
doc
=
form
.
ownerDocument
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
if
(
!
formOrigin
)
{
throw
new
Error
(
"
_getLoginDataFromParent
:
A
form
origin
is
required
"
)
;
}
let
actionOrigin
=
LoginHelper
.
getFormActionOrigin
(
form
)
;
let
messageData
=
{
formOrigin
actionOrigin
options
}
;
let
resultPromise
=
this
.
sendQuery
(
"
PasswordManager
:
findLogins
"
messageData
)
;
return
resultPromise
.
then
(
result
=
>
{
return
{
form
loginsFound
:
LoginHelper
.
vanillaObjectsToLogins
(
result
.
logins
)
recipes
:
result
.
recipes
}
;
}
)
;
}
_autoCompleteSearchAsync
(
aSearchString
aPreviousResult
aElement
)
{
let
doc
=
aElement
.
ownerDocument
;
let
form
=
LoginFormFactory
.
createFromField
(
aElement
)
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
let
actionOrigin
=
LoginHelper
.
getFormActionOrigin
(
form
)
;
let
autocompleteInfo
=
aElement
.
getAutocompleteInfo
(
)
;
let
previousResult
=
aPreviousResult
?
{
searchString
:
aPreviousResult
.
searchString
logins
:
LoginHelper
.
loginsToVanillaObjects
(
aPreviousResult
.
logins
)
}
:
null
;
let
messageData
=
{
autocompleteInfo
formOrigin
actionOrigin
searchString
:
aSearchString
previousResult
isSecure
:
InsecurePasswordUtils
.
isFormSecure
(
form
)
isPasswordField
:
aElement
.
type
=
=
"
password
"
}
;
if
(
LoginHelper
.
showAutoCompleteFooter
)
{
gAutoCompleteListener
.
init
(
)
;
}
let
resultPromise
=
this
.
sendQuery
(
"
PasswordManager
:
autoCompleteLogins
"
messageData
)
;
return
resultPromise
.
then
(
result
=
>
{
return
{
generatedPassword
:
result
.
generatedPassword
logins
:
LoginHelper
.
vanillaObjectsToLogins
(
result
.
logins
)
}
;
}
)
;
}
setupProgressListener
(
window
)
{
if
(
!
LoginHelper
.
formlessCaptureEnabled
)
{
return
;
}
try
{
let
webProgress
=
window
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
observer
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
|
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
catch
(
ex
)
{
}
}
onDOMFormBeforeSubmit
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
log
(
"
notified
before
form
submission
"
)
;
let
formLike
=
LoginFormFactory
.
createFromForm
(
event
.
target
)
;
this
.
_onFormSubmit
(
formLike
)
;
}
onDocumentVisibilityChange
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
document
=
event
.
target
;
let
onVisibleTasks
=
this
.
_visibleTasksByDocument
.
get
(
document
)
;
if
(
!
onVisibleTasks
)
{
return
;
}
for
(
let
task
of
onVisibleTasks
)
{
log
(
"
onDocumentVisibilityChange
executing
queued
task
"
)
;
task
(
)
;
}
this
.
_visibleTasksByDocument
.
delete
(
document
)
;
}
_deferHandlingEventUntilDocumentVisible
(
event
document
fn
)
{
log
(
document
.
visibilityState
:
{
document
.
visibilityState
}
defer
handling
{
event
.
type
}
)
;
let
onVisibleTasks
=
this
.
_visibleTasksByDocument
.
get
(
document
)
;
if
(
!
onVisibleTasks
)
{
log
(
deferHandling
first
queued
event
register
the
visibilitychange
handler
)
;
onVisibleTasks
=
[
]
;
this
.
_visibleTasksByDocument
.
set
(
document
onVisibleTasks
)
;
document
.
addEventListener
(
"
visibilitychange
"
event
=
>
{
this
.
onDocumentVisibilityChange
(
event
)
;
}
{
once
:
true
}
)
;
}
onVisibleTasks
.
push
(
fn
)
;
}
onDOMFormHasPassword
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
isMasterPasswordSet
=
Services
.
cpmm
.
sharedData
.
get
(
"
isMasterPasswordSet
"
)
;
let
document
=
event
.
target
.
ownerDocument
;
log
(
"
onDOMFormHasPassword
visibilityState
:
"
document
.
visibilityState
"
isMasterPasswordSet
:
"
isMasterPasswordSet
)
;
if
(
document
.
visibilityState
=
=
"
visible
"
|
|
isMasterPasswordSet
)
{
this
.
_processDOMFormHasPasswordEvent
(
event
)
;
}
else
{
this
.
_deferHandlingEventUntilDocumentVisible
(
event
document
(
)
=
>
{
this
.
_processDOMFormHasPasswordEvent
(
event
)
;
}
)
;
}
}
_processDOMFormHasPasswordEvent
(
event
)
{
let
form
=
event
.
target
;
let
formLike
=
LoginFormFactory
.
createFromForm
(
form
)
;
log
(
"
_processDOMFormHasPasswordEvent
:
"
form
formLike
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike
)
;
}
onDOMInputPasswordAdded
(
event
topWindow
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
this
.
setupProgressListener
(
topWindow
)
;
let
pwField
=
event
.
originalTarget
;
if
(
pwField
.
form
)
{
return
;
}
let
document
=
pwField
.
ownerDocument
;
let
isMasterPasswordSet
=
Services
.
cpmm
.
sharedData
.
get
(
"
isMasterPasswordSet
"
)
;
log
(
"
onDOMInputPasswordAdded
visibilityState
:
"
document
.
visibilityState
"
isMasterPasswordSet
:
"
isMasterPasswordSet
)
;
if
(
document
.
visibilityState
=
=
"
visible
"
|
|
isMasterPasswordSet
)
{
this
.
_processDOMInputPasswordAddedEvent
(
event
topWindow
)
;
}
else
{
this
.
_deferHandlingEventUntilDocumentVisible
(
event
document
(
)
=
>
{
this
.
_processDOMInputPasswordAddedEvent
(
event
topWindow
)
;
}
)
;
}
}
_processDOMInputPasswordAddedEvent
(
event
topWindow
)
{
let
pwField
=
event
.
originalTarget
;
let
formLike
=
LoginFormFactory
.
createFromField
(
pwField
)
;
log
(
"
_processDOMInputPasswordAddedEvent
:
"
pwField
formLike
)
;
let
deferredTask
=
this
.
_deferredPasswordAddedTasksByRootElement
.
get
(
formLike
.
rootElement
)
;
if
(
!
deferredTask
)
{
log
(
"
Creating
a
DeferredTask
to
call
_fetchLoginsFromParentAndFillForm
soon
"
)
;
LoginFormFactory
.
setForRootElement
(
formLike
.
rootElement
formLike
)
;
deferredTask
=
new
DeferredTask
(
(
)
=
>
{
let
formLike2
=
LoginFormFactory
.
getForRootElement
(
formLike
.
rootElement
)
;
log
(
"
Running
deferred
processing
of
onDOMInputPasswordAdded
"
formLike2
)
;
this
.
_deferredPasswordAddedTasksByRootElement
.
delete
(
formLike2
.
rootElement
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike2
)
;
}
PASSWORD_INPUT_ADDED_COALESCING_THRESHOLD_MS
0
)
;
this
.
_deferredPasswordAddedTasksByRootElement
.
set
(
formLike
.
rootElement
deferredTask
)
;
}
let
window
=
pwField
.
ownerGlobal
;
if
(
deferredTask
.
isArmed
)
{
log
(
"
DeferredTask
is
already
armed
so
just
updating
the
LoginForm
"
)
;
LoginFormFactory
.
setForRootElement
(
formLike
.
rootElement
formLike
)
;
}
else
if
(
window
.
document
.
readyState
=
=
"
complete
"
)
{
log
(
"
Arming
the
DeferredTask
we
just
created
since
document
.
readyState
=
=
'
complete
'
"
)
;
deferredTask
.
arm
(
)
;
}
else
{
window
.
addEventListener
(
"
DOMContentLoaded
"
function
(
)
{
log
(
"
Arming
the
onDOMInputPasswordAdded
DeferredTask
due
to
DOMContentLoaded
"
)
;
deferredTask
.
arm
(
)
;
}
{
once
:
true
}
)
;
}
}
_fetchLoginsFromParentAndFillForm
(
form
)
{
if
(
!
LoginHelper
.
enabled
)
{
return
;
}
this
.
_getLoginDataFromParent
(
form
{
showMasterPassword
:
true
}
)
.
then
(
this
.
loginsFound
.
bind
(
this
)
)
.
catch
(
Cu
.
reportError
)
;
}
stateForDocument
(
document
)
{
let
loginFormState
=
this
.
_loginFormStateByDocument
.
get
(
document
)
;
if
(
!
loginFormState
)
{
loginFormState
=
{
fillsByRootElement
:
new
WeakMap
(
)
lastSubmittedValuesByRootElement
:
new
WeakMap
(
)
loginFormRootElements
:
new
WeakSet
(
)
}
;
this
.
_loginFormStateByDocument
.
set
(
document
loginFormState
)
;
}
return
loginFormState
;
}
fillForm
(
{
loginFormOrigin
loginsFound
recipes
inputElementIdentifier
originMatches
}
)
{
if
(
!
inputElementIdentifier
)
{
log
(
"
fillForm
:
No
input
element
specified
"
)
;
return
;
}
let
inputElement
=
ContentDOMReference
.
resolve
(
inputElementIdentifier
)
;
if
(
!
inputElement
)
{
log
(
"
fillForm
:
Could
not
resolve
inputElementIdentifier
to
a
living
element
.
"
)
;
return
;
}
if
(
!
originMatches
)
{
if
(
!
inputElement
|
|
LoginHelper
.
getLoginOrigin
(
inputElement
.
ownerDocument
.
documentURI
)
!
=
loginFormOrigin
)
{
log
(
"
fillForm
:
The
requested
origin
doesn
'
t
match
the
one
from
the
"
"
document
.
This
may
mean
we
navigated
to
a
document
from
a
different
"
"
site
before
we
had
a
chance
to
indicate
this
change
in
the
user
"
"
interface
.
"
)
;
return
;
}
}
let
clobberUsername
=
true
;
let
form
=
LoginFormFactory
.
createFromField
(
inputElement
)
;
if
(
inputElement
.
type
=
=
"
password
"
)
{
clobberUsername
=
false
;
}
this
.
_fillForm
(
form
loginsFound
recipes
{
inputElement
autofillForm
:
true
clobberUsername
clobberPassword
:
true
userTriggered
:
true
}
)
;
}
loginsFound
(
{
form
loginsFound
recipes
}
)
{
let
doc
=
form
.
ownerDocument
;
let
autofillForm
=
LoginHelper
.
autofillForms
&
&
!
PrivateBrowsingUtils
.
isContentWindowPrivate
(
doc
.
defaultView
)
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
LoginRecipesContent
.
cacheRecipes
(
formOrigin
doc
.
defaultView
recipes
)
;
this
.
_fillForm
(
form
loginsFound
recipes
{
autofillForm
}
)
;
}
_onUsernameFocus
(
event
)
{
let
focusedField
=
event
.
target
;
if
(
!
focusedField
.
mozIsTextField
(
true
)
|
|
focusedField
.
readOnly
)
{
return
;
}
if
(
this
.
_isLoginAlreadyFilled
(
focusedField
)
)
{
log
(
"
_onUsernameFocus
:
Already
filled
"
)
;
return
;
}
let
timeDiff
=
Date
.
now
(
)
-
gLastRightClickTimeStamp
;
if
(
timeDiff
<
AUTOCOMPLETE_AFTER_RIGHT_CLICK_THRESHOLD_MS
)
{
log
(
"
Not
opening
autocomplete
after
focus
since
a
context
menu
was
opened
within
"
timeDiff
"
ms
"
)
;
return
;
}
log
(
"
maybeOpenAutocompleteAfterFocus
:
Opening
the
autocomplete
popup
"
)
;
gFormFillService
.
showPopup
(
)
;
}
onFieldAutoComplete
(
acInputField
loginGUID
)
{
if
(
!
LoginHelper
.
enabled
)
{
return
;
}
if
(
ChromeUtils
.
getClassName
(
acInputField
.
ownerDocument
)
!
=
"
HTMLDocument
"
)
{
return
;
}
if
(
!
LoginFormFactory
.
createFromField
(
acInputField
)
)
{
return
;
}
if
(
LoginHelper
.
isUsernameFieldType
(
acInputField
)
)
{
this
.
onUsernameAutocompleted
(
acInputField
loginGUID
)
;
}
else
if
(
acInputField
.
hasBeenTypePassword
)
{
this
.
_stopTreatingAsGeneratedPasswordField
(
acInputField
)
;
this
.
_highlightFilledField
(
acInputField
)
;
}
}
onUsernameAutocompleted
(
acInputField
loginGUID
=
null
)
{
log
(
"
onUsernameAutocompleted
:
"
acInputField
)
;
let
acForm
=
LoginFormFactory
.
createFromField
(
acInputField
)
;
let
doc
=
acForm
.
ownerDocument
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
let
recipes
=
LoginRecipesContent
.
getRecipes
(
this
formOrigin
doc
.
defaultView
)
;
let
[
usernameField
passwordField
ignored
]
=
this
.
_getFormFields
(
acForm
false
recipes
)
;
if
(
usernameField
=
=
acInputField
&
&
passwordField
)
{
this
.
_getLoginDataFromParent
(
acForm
{
guid
:
loginGUID
showMasterPassword
:
false
}
)
.
then
(
(
{
form
loginsFound
recipes
}
)
=
>
{
if
(
!
loginGUID
)
{
loginsFound
=
this
.
_filterForExactFormOriginLogins
(
loginsFound
acForm
)
;
let
searchString
=
usernameField
.
value
.
toLowerCase
(
)
;
loginsFound
=
loginsFound
.
filter
(
l
=
>
l
.
username
.
toLowerCase
(
)
=
=
searchString
)
;
}
this
.
_fillForm
(
form
loginsFound
recipes
{
autofillForm
:
true
clobberPassword
:
true
userTriggered
:
true
}
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
else
{
}
}
_getPasswordFields
(
form
{
fieldOverrideRecipe
=
null
minPasswordLength
=
0
}
=
{
}
)
{
let
pwFields
=
[
]
;
for
(
let
i
=
0
;
i
<
form
.
elements
.
length
;
i
+
+
)
{
let
element
=
form
.
elements
[
i
]
;
if
(
ChromeUtils
.
getClassName
(
element
)
!
=
=
"
HTMLInputElement
"
|
|
element
.
type
!
=
"
password
"
|
|
!
element
.
isConnected
)
{
continue
;
}
if
(
fieldOverrideRecipe
&
&
fieldOverrideRecipe
.
notPasswordSelector
&
&
element
.
matches
(
fieldOverrideRecipe
.
notPasswordSelector
)
)
{
log
(
"
skipping
password
field
(
id
/
name
is
"
element
.
id
"
/
"
element
.
name
+
"
)
due
to
recipe
:
"
fieldOverrideRecipe
)
;
continue
;
}
if
(
minPasswordLength
&
&
element
.
value
.
trim
(
)
.
length
<
minPasswordLength
)
{
log
(
"
skipping
password
field
(
id
/
name
is
"
element
.
id
"
/
"
element
.
name
+
"
)
as
value
is
too
short
:
"
element
.
value
.
trim
(
)
.
length
)
;
continue
;
}
pwFields
[
pwFields
.
length
]
=
{
index
:
i
element
}
;
}
if
(
!
pwFields
.
length
)
{
log
(
"
(
form
ignored
-
-
no
password
fields
.
)
"
)
;
return
null
;
}
else
if
(
pwFields
.
length
>
3
)
{
log
(
"
(
form
ignored
-
-
too
many
password
fields
.
[
got
"
pwFields
.
length
"
]
)
"
)
;
return
null
;
}
return
pwFields
;
}
_getFormFields
(
form
isSubmission
recipes
)
{
let
usernameField
=
null
;
let
pwFields
=
null
;
let
fieldOverrideRecipe
=
LoginRecipesContent
.
getFieldOverrides
(
recipes
form
)
;
if
(
fieldOverrideRecipe
)
{
let
pwOverrideField
=
LoginRecipesContent
.
queryLoginField
(
form
fieldOverrideRecipe
.
passwordSelector
)
;
if
(
pwOverrideField
)
{
let
formLike
=
LoginFormFactory
.
createFromField
(
pwOverrideField
)
;
pwFields
=
[
{
index
:
[
.
.
.
formLike
.
elements
]
.
indexOf
(
pwOverrideField
)
element
:
pwOverrideField
}
]
;
}
let
usernameOverrideField
=
LoginRecipesContent
.
queryLoginField
(
form
fieldOverrideRecipe
.
usernameSelector
)
;
if
(
usernameOverrideField
)
{
usernameField
=
usernameOverrideField
;
}
}
if
(
!
pwFields
)
{
const
minSubmitPasswordLength
=
2
;
pwFields
=
this
.
_getPasswordFields
(
form
{
fieldOverrideRecipe
minPasswordLength
:
isSubmission
?
minSubmitPasswordLength
:
0
}
)
;
}
if
(
!
pwFields
)
{
return
[
null
null
null
]
;
}
if
(
!
usernameField
)
{
for
(
let
i
=
pwFields
[
0
]
.
index
-
1
;
i
>
=
0
;
i
-
-
)
{
let
element
=
form
.
elements
[
i
]
;
if
(
!
LoginHelper
.
isUsernameFieldType
(
element
)
)
{
continue
;
}
if
(
fieldOverrideRecipe
&
&
fieldOverrideRecipe
.
notUsernameSelector
&
&
element
.
matches
(
fieldOverrideRecipe
.
notUsernameSelector
)
)
{
continue
;
}
usernameField
=
element
;
break
;
}
}
if
(
!
usernameField
)
{
log
(
"
(
form
-
-
no
username
field
found
)
"
)
;
}
else
{
let
acFieldName
=
usernameField
.
getAutocompleteInfo
(
)
.
fieldName
;
log
(
"
Username
field
"
usernameField
"
has
name
/
value
/
autocomplete
:
"
usernameField
.
name
"
/
"
usernameField
.
value
"
/
"
acFieldName
)
;
}
if
(
!
isSubmission
|
|
pwFields
.
length
=
=
1
)
{
let
passwordField
=
pwFields
[
0
]
.
element
;
log
(
"
Password
field
"
passwordField
"
has
name
:
"
passwordField
.
name
)
;
return
[
usernameField
passwordField
null
]
;
}
let
oldPasswordField
newPasswordField
;
let
pw1
=
pwFields
[
0
]
.
element
.
value
;
let
pw2
=
pwFields
[
1
]
.
element
.
value
;
let
pw3
=
pwFields
[
2
]
?
pwFields
[
2
]
.
element
.
value
:
null
;
if
(
pwFields
.
length
=
=
3
)
{
if
(
pw1
=
=
pw2
&
&
pw2
=
=
pw3
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
null
;
}
else
if
(
pw1
=
=
pw2
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
pwFields
[
2
]
.
element
;
}
else
if
(
pw2
=
=
pw3
)
{
oldPasswordField
=
pwFields
[
0
]
.
element
;
newPasswordField
=
pwFields
[
2
]
.
element
;
}
else
if
(
pw1
=
=
pw3
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
pwFields
[
1
]
.
element
;
}
else
{
log
(
"
(
form
ignored
-
-
all
3
pw
fields
differ
)
"
)
;
return
[
null
null
null
]
;
}
}
else
if
(
pw1
=
=
pw2
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
null
;
}
else
{
oldPasswordField
=
pwFields
[
0
]
.
element
;
newPasswordField
=
pwFields
[
1
]
.
element
;
}
log
(
"
Password
field
(
new
)
id
/
name
is
:
"
newPasswordField
.
id
"
/
"
newPasswordField
.
name
)
;
if
(
oldPasswordField
)
{
log
(
"
Password
field
(
old
)
id
/
name
is
:
"
oldPasswordField
.
id
"
/
"
oldPasswordField
.
name
)
;
}
else
{
log
(
"
Password
field
(
old
)
:
"
oldPasswordField
)
;
}
return
[
usernameField
newPasswordField
oldPasswordField
]
;
}
_isAutocompleteDisabled
(
element
)
{
return
element
&
&
element
.
autocomplete
=
=
"
off
"
;
}
_onDocumentRestored
(
aDocument
)
{
let
rootElsWeakSet
=
LoginFormFactory
.
getRootElementsWeakSetForDocument
(
aDocument
)
;
let
weakLoginFormRootElements
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
rootElsWeakSet
)
;
log
(
"
_onDocumentRestored
:
loginFormRootElements
approx
size
:
"
weakLoginFormRootElements
.
length
"
document
:
"
aDocument
)
;
for
(
let
formRoot
of
weakLoginFormRootElements
)
{
if
(
!
formRoot
.
isConnected
)
{
continue
;
}
let
formLike
=
LoginFormFactory
.
getForRootElement
(
formRoot
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike
)
;
}
}
_onNavigation
(
aDocument
)
{
let
rootElsWeakSet
=
LoginFormFactory
.
getRootElementsWeakSetForDocument
(
aDocument
)
;
let
weakLoginFormRootElements
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
rootElsWeakSet
)
;
log
(
"
_onNavigation
:
root
elements
approx
size
:
"
weakLoginFormRootElements
.
length
"
document
:
"
aDocument
)
;
for
(
let
formRoot
of
weakLoginFormRootElements
)
{
if
(
!
formRoot
.
isConnected
)
{
continue
;
}
let
formLike
=
LoginFormFactory
.
getForRootElement
(
formRoot
)
;
this
.
_onFormSubmit
(
formLike
)
;
}
}
_onFormSubmit
(
form
)
{
log
(
"
_onFormSubmit
"
form
)
;
let
doc
=
form
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
if
(
PrivateBrowsingUtils
.
isContentWindowPrivate
(
win
)
&
&
!
LoginHelper
.
privateBrowsingCaptureEnabled
)
{
log
(
"
(
form
submission
ignored
in
private
browsing
mode
)
"
)
;
return
;
}
if
(
!
LoginHelper
.
enabled
)
{
return
;
}
let
origin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
if
(
!
origin
)
{
log
(
"
(
form
submission
ignored
-
-
invalid
origin
)
"
)
;
return
;
}
let
formActionOrigin
=
LoginHelper
.
getFormActionOrigin
(
form
)
;
let
recipes
=
LoginRecipesContent
.
getRecipes
(
this
origin
win
)
;
let
[
usernameField
newPasswordField
oldPasswordField
]
=
this
.
_getFormFields
(
form
true
recipes
)
;
if
(
newPasswordField
=
=
null
)
{
return
;
}
if
(
usernameField
&
&
usernameField
.
value
.
match
(
/
[
\
*
]
{
3
}
/
)
)
{
log
(
usernameField
.
value
"
{
usernameField
.
value
}
"
looks
munged
setting
to
null
)
;
usernameField
=
null
;
}
if
(
(
this
.
_isAutocompleteDisabled
(
form
)
|
|
this
.
_isAutocompleteDisabled
(
usernameField
)
|
|
this
.
_isAutocompleteDisabled
(
newPasswordField
)
|
|
this
.
_isAutocompleteDisabled
(
oldPasswordField
)
)
&
&
!
LoginHelper
.
storeWhenAutocompleteOff
)
{
log
(
"
(
form
submission
ignored
-
-
autocomplete
=
off
found
)
"
)
;
return
;
}
let
mockUsername
=
usernameField
?
{
name
:
usernameField
.
name
value
:
usernameField
.
value
}
:
null
;
let
mockPassword
=
{
name
:
newPasswordField
.
name
value
:
newPasswordField
.
value
}
;
let
mockOldPassword
=
oldPasswordField
?
{
name
:
oldPasswordField
.
name
value
:
oldPasswordField
.
value
}
:
null
;
let
usernameValue
=
usernameField
?
usernameField
.
value
:
null
;
let
formLikeRoot
=
FormLikeFactory
.
findRootForField
(
newPasswordField
)
;
let
dismissedPrompt
=
false
;
let
newPasswordFieldValue
=
newPasswordField
.
value
;
if
(
(
CreditCard
.
isValidNumber
(
usernameValue
)
&
&
newPasswordFieldValue
.
trim
(
)
.
match
(
/
^
[
0
-
9
]
{
3
}
/
)
)
|
|
(
CreditCard
.
isValidNumber
(
newPasswordFieldValue
)
&
&
newPasswordField
.
getAutocompleteInfo
(
)
.
fieldName
=
=
"
cc
-
number
"
)
)
{
dismissedPrompt
=
true
;
}
if
(
this
.
_compareAndUpdatePreviouslySentValues
(
formLikeRoot
usernameValue
newPasswordField
.
value
dismissedPrompt
)
)
{
log
(
"
(
form
submission
ignored
-
-
already
submitted
with
the
same
username
and
password
)
"
)
;
return
;
}
let
openerTopWindowID
=
null
;
if
(
win
.
opener
)
{
openerTopWindowID
=
win
.
opener
.
top
.
windowUtils
.
outerWindowID
;
}
let
autoFilledLogin
=
this
.
stateForDocument
(
doc
)
.
fillsByRootElement
.
get
(
form
.
rootElement
)
;
this
.
sendAsyncMessage
(
"
PasswordManager
:
onFormSubmit
"
{
origin
formActionOrigin
autoFilledLoginGuid
:
autoFilledLogin
&
&
autoFilledLogin
.
guid
usernameField
:
mockUsername
newPasswordField
:
mockPassword
oldPasswordField
:
mockOldPassword
openerTopWindowID
dismissedPrompt
}
)
;
}
_maybeStopTreatingAsGeneratedPasswordField
(
event
)
{
let
passwordField
=
event
.
target
;
let
{
value
}
=
passwordField
;
if
(
!
value
|
|
(
event
.
data
&
&
event
.
data
=
=
value
)
)
{
this
.
_stopTreatingAsGeneratedPasswordField
(
passwordField
)
;
}
}
_stopTreatingAsGeneratedPasswordField
(
passwordField
)
{
log
(
"
_stopTreatingAsGeneratedPasswordField
"
)
;
for
(
let
eventType
of
[
"
blur
"
"
change
"
"
focus
"
"
input
"
]
)
{
passwordField
.
removeEventListener
(
eventType
observer
{
capture
:
true
mozSystemGroup
:
true
}
)
;
}
this
.
_togglePasswordFieldMasking
(
passwordField
false
)
;
}
_generatedPasswordFilledOrEdited
(
passwordField
)
{
log
(
"
_generatedPasswordFilledOrEdited
"
passwordField
)
;
if
(
!
LoginHelper
.
enabled
)
{
throw
new
Error
(
"
A
generated
password
was
filled
while
the
password
manager
was
disabled
.
"
)
;
}
let
win
=
passwordField
.
ownerGlobal
;
let
formLikeRoot
=
FormLikeFactory
.
findRootForField
(
passwordField
)
;
this
.
_highlightFilledField
(
passwordField
)
;
for
(
let
eventType
of
[
"
blur
"
"
change
"
"
focus
"
"
input
"
]
)
{
passwordField
.
addEventListener
(
eventType
observer
{
capture
:
true
mozSystemGroup
:
true
}
)
;
}
this
.
_togglePasswordFieldMasking
(
passwordField
true
)
;
if
(
PrivateBrowsingUtils
.
isContentWindowPrivate
(
win
)
)
{
log
(
"
_generatedPasswordFilledOrEdited
:
not
automatically
saving
the
password
in
private
browsing
mode
"
)
;
return
;
}
let
loginForm
=
LoginFormFactory
.
createFromField
(
passwordField
)
;
let
formActionOrigin
=
LoginHelper
.
getFormActionOrigin
(
loginForm
)
;
let
origin
=
LoginHelper
.
getLoginOrigin
(
passwordField
.
ownerDocument
.
documentURI
)
;
let
recipes
=
LoginRecipesContent
.
getRecipes
(
this
origin
win
)
;
let
[
usernameField
]
=
this
.
_getFormFields
(
loginForm
false
recipes
)
;
let
username
=
(
usernameField
&
&
usernameField
.
value
)
|
|
"
"
;
if
(
this
.
_compareAndUpdatePreviouslySentValues
(
formLikeRoot
username
passwordField
.
value
true
)
)
{
log
(
"
(
generatedPasswordFilledOrEdited
ignored
-
-
already
messaged
with
the
same
password
value
)
"
)
;
return
;
}
let
openerTopWindowID
=
null
;
if
(
win
.
opener
)
{
openerTopWindowID
=
win
.
opener
.
top
.
windowUtils
.
outerWindowID
;
}
this
.
sendAsyncMessage
(
"
PasswordManager
:
onGeneratedPasswordFilledOrEdited
"
{
formActionOrigin
openerTopWindowID
password
:
passwordField
.
value
username
:
(
usernameField
&
&
usernameField
.
value
)
|
|
"
"
}
)
;
}
_togglePasswordFieldMasking
(
passwordField
unmask
)
{
let
{
editor
}
=
passwordField
;
if
(
passwordField
.
type
!
=
"
password
"
)
{
log
(
"
_togglePasswordFieldMasking
:
Field
isn
'
t
type
=
password
"
)
;
return
;
}
if
(
!
unmask
&
&
!
editor
)
{
return
;
}
if
(
unmask
)
{
editor
.
unmask
(
0
)
;
return
;
}
if
(
editor
.
autoMaskingEnabled
)
{
return
;
}
editor
.
mask
(
)
;
}
_removeFillFieldHighlight
(
event
)
{
let
winUtils
=
event
.
target
.
ownerGlobal
.
windowUtils
;
winUtils
.
removeManuallyManagedState
(
event
.
target
AUTOFILL_STATE
)
;
}
_highlightFilledField
(
element
)
{
let
winUtils
=
element
.
ownerGlobal
.
windowUtils
;
winUtils
.
addManuallyManagedState
(
element
AUTOFILL_STATE
)
;
element
.
addEventListener
(
"
input
"
this
.
_removeFillFieldHighlight
{
mozSystemGroup
:
true
once
:
true
}
)
;
}
_filterForExactFormOriginLogins
(
logins
form
)
{
let
loginOrigin
=
LoginHelper
.
getLoginOrigin
(
form
.
ownerDocument
.
documentURI
)
;
let
formActionOrigin
=
LoginHelper
.
getFormActionOrigin
(
form
)
;
logins
=
logins
.
filter
(
l
=
>
{
let
formActionMatches
=
LoginHelper
.
isOriginMatching
(
l
.
formActionOrigin
formActionOrigin
{
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
acceptWildcardMatch
:
true
acceptDifferentSubdomains
:
false
}
)
;
let
formOriginMatches
=
LoginHelper
.
isOriginMatching
(
l
.
origin
loginOrigin
{
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
acceptWildcardMatch
:
true
acceptDifferentSubdomains
:
false
}
)
;
return
formActionMatches
&
&
formOriginMatches
;
}
)
;
logins
=
LoginHelper
.
dedupeLogins
(
logins
[
"
username
"
]
[
"
scheme
"
"
timePasswordChanged
"
]
loginOrigin
formActionOrigin
)
;
return
logins
;
}
_fillForm
(
form
foundLogins
recipes
{
inputElement
=
null
autofillForm
=
false
clobberUsername
=
false
clobberPassword
=
false
userTriggered
=
false
}
=
{
}
)
{
if
(
ChromeUtils
.
getClassName
(
form
)
=
=
=
"
HTMLFormElement
"
)
{
throw
new
Error
(
"
_fillForm
should
only
be
called
with
LoginForm
objects
"
)
;
}
log
(
"
_fillForm
"
form
.
elements
)
;
let
usernameField
;
let
autofillResult
=
-
1
;
const
AUTOFILL_RESULT
=
{
FILLED
:
0
NO_PASSWORD_FIELD
:
1
PASSWORD_DISABLED_READONLY
:
2
NO_LOGINS_FIT
:
3
NO_SAVED_LOGINS
:
4
EXISTING_PASSWORD
:
5
EXISTING_USERNAME
:
6
MULTIPLE_LOGINS
:
7
NO_AUTOFILL_FORMS
:
8
AUTOCOMPLETE_OFF
:
9
INSECURE
:
10
PASSWORD_AUTOCOMPLETE_NEW_PASSWORD
:
11
}
;
try
{
if
(
!
foundLogins
.
length
&
&
(
InsecurePasswordUtils
.
isFormSecure
(
form
)
|
|
!
LoginHelper
.
showInsecureFieldWarning
)
)
{
autofillResult
=
AUTOFILL_RESULT
.
NO_SAVED_LOGINS
;
return
;
}
let
passwordField
;
[
usernameField
passwordField
]
=
this
.
_getFormFields
(
form
false
recipes
)
;
if
(
inputElement
)
{
if
(
inputElement
.
type
=
=
"
password
"
)
{
passwordField
=
inputElement
;
if
(
!
clobberUsername
)
{
usernameField
=
null
;
}
}
else
if
(
LoginHelper
.
isUsernameFieldType
(
inputElement
)
)
{
usernameField
=
inputElement
;
}
else
{
throw
new
Error
(
"
Unexpected
input
element
type
.
"
)
;
}
}
if
(
passwordField
=
=
null
)
{
log
(
"
not
filling
form
no
password
field
found
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
NO_PASSWORD_FIELD
;
return
;
}
if
(
passwordField
.
disabled
|
|
passwordField
.
readOnly
)
{
log
(
"
not
filling
form
password
field
disabled
or
read
-
only
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
PASSWORD_DISABLED_READONLY
;
return
;
}
if
(
usernameField
)
{
gFormFillService
.
markAsLoginManagerField
(
usernameField
)
;
usernameField
.
addEventListener
(
"
keydown
"
observer
)
;
}
if
(
!
userTriggered
)
{
foundLogins
=
this
.
_filterForExactFormOriginLogins
(
foundLogins
form
)
;
}
if
(
!
foundLogins
.
length
)
{
autofillResult
=
AUTOFILL_RESULT
.
NO_SAVED_LOGINS
;
return
;
}
if
(
!
userTriggered
&
&
!
LoginHelper
.
insecureAutofill
&
&
!
InsecurePasswordUtils
.
isFormSecure
(
form
)
)
{
log
(
"
not
filling
form
since
it
'
s
insecure
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
INSECURE
;
return
;
}
let
maxUsernameLen
=
Number
.
MAX_VALUE
;
let
maxPasswordLen
=
Number
.
MAX_VALUE
;
if
(
usernameField
&
&
usernameField
.
maxLength
>
=
0
)
{
maxUsernameLen
=
usernameField
.
maxLength
;
}
if
(
passwordField
.
maxLength
>
=
0
)
{
maxPasswordLen
=
passwordField
.
maxLength
;
}
let
logins
=
foundLogins
.
filter
(
function
(
l
)
{
let
fit
=
l
.
username
.
length
<
=
maxUsernameLen
&
&
l
.
password
.
length
<
=
maxPasswordLen
;
if
(
!
fit
)
{
log
(
"
Ignored
"
l
.
username
"
login
:
won
'
t
fit
"
)
;
}
return
fit
;
}
this
)
;
if
(
!
logins
.
length
)
{
log
(
"
form
not
filled
none
of
the
logins
fit
in
the
field
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
NO_LOGINS_FIT
;
return
;
}
const
passwordACFieldName
=
passwordField
.
getAutocompleteInfo
(
)
.
fieldName
;
if
(
!
userTriggered
&
&
passwordACFieldName
=
=
"
new
-
password
"
)
{
log
(
"
not
filling
form
password
field
has
the
autocomplete
new
-
password
value
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
PASSWORD_AUTOCOMPLETE_NEW_PASSWORD
;
return
;
}
if
(
passwordField
.
value
&
&
!
clobberPassword
)
{
log
(
"
form
not
filled
the
password
field
was
already
filled
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
EXISTING_PASSWORD
;
return
;
}
let
selectedLogin
;
if
(
!
clobberUsername
&
&
usernameField
&
&
(
usernameField
.
value
|
|
usernameField
.
disabled
|
|
usernameField
.
readOnly
)
)
{
let
username
=
usernameField
.
value
.
toLowerCase
(
)
;
let
matchingLogins
=
logins
.
filter
(
l
=
>
l
.
username
.
toLowerCase
(
)
=
=
username
)
;
if
(
!
matchingLogins
.
length
)
{
log
(
"
Password
not
filled
.
None
of
the
stored
logins
match
the
username
already
present
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
EXISTING_USERNAME
;
return
;
}
for
(
let
l
of
matchingLogins
)
{
if
(
l
.
username
=
=
usernameField
.
value
)
{
selectedLogin
=
l
;
}
}
if
(
!
selectedLogin
)
{
selectedLogin
=
matchingLogins
[
0
]
;
}
}
else
if
(
logins
.
length
=
=
1
)
{
selectedLogin
=
logins
[
0
]
;
}
else
{
let
matchingLogins
;
if
(
usernameField
)
{
matchingLogins
=
logins
.
filter
(
l
=
>
l
.
username
)
;
}
else
{
matchingLogins
=
logins
.
filter
(
l
=
>
!
l
.
username
)
;
}
if
(
matchingLogins
.
length
!
=
1
)
{
log
(
"
Multiple
logins
for
form
so
not
filling
any
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
MULTIPLE_LOGINS
;
return
;
}
selectedLogin
=
matchingLogins
[
0
]
;
}
if
(
!
autofillForm
)
{
log
(
"
autofillForms
=
false
but
form
can
be
filled
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
NO_AUTOFILL_FORMS
;
return
;
}
if
(
!
userTriggered
&
&
passwordACFieldName
=
=
"
off
"
&
&
!
LoginHelper
.
autofillAutocompleteOff
)
{
log
(
"
Not
autofilling
the
login
because
we
'
re
respecting
autocomplete
=
off
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
AUTOCOMPLETE_OFF
;
return
;
}
if
(
usernameField
)
{
let
disabledOrReadOnly
=
usernameField
.
disabled
|
|
usernameField
.
readOnly
;
let
userNameDiffers
=
selectedLogin
.
username
!
=
usernameField
.
value
;
let
userEnteredDifferentCase
=
userTriggered
&
&
userNameDiffers
&
&
usernameField
.
value
.
toLowerCase
(
)
=
=
selectedLogin
.
username
.
toLowerCase
(
)
;
if
(
!
disabledOrReadOnly
)
{
if
(
!
userEnteredDifferentCase
&
&
userNameDiffers
)
{
usernameField
.
setUserInput
(
selectedLogin
.
username
)
;
}
this
.
_highlightFilledField
(
usernameField
)
;
}
}
let
doc
=
form
.
ownerDocument
;
if
(
passwordField
.
value
!
=
selectedLogin
.
password
)
{
this
.
_stopTreatingAsGeneratedPasswordField
(
passwordField
)
;
passwordField
.
setUserInput
(
selectedLogin
.
password
)
;
let
autoFilledLogin
=
{
guid
:
selectedLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
.
guid
username
:
selectedLogin
.
username
usernameField
:
usernameField
?
Cu
.
getWeakReference
(
usernameField
)
:
null
password
:
selectedLogin
.
password
passwordField
:
Cu
.
getWeakReference
(
passwordField
)
}
;
log
(
"
Saving
autoFilledLogin
"
autoFilledLogin
.
guid
"
for
"
form
.
rootElement
)
;
this
.
stateForDocument
(
doc
)
.
fillsByRootElement
.
set
(
form
.
rootElement
autoFilledLogin
)
;
}
this
.
_highlightFilledField
(
passwordField
)
;
log
(
"
_fillForm
succeeded
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
FILLED
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
throw
ex
;
}
finally
{
if
(
autofillResult
=
=
-
1
)
{
throw
new
Error
(
"
_fillForm
:
autofillResult
must
be
specified
"
)
;
}
if
(
!
userTriggered
)
{
Services
.
telemetry
.
getHistogramById
(
"
PWMGR_FORM_AUTOFILL_RESULT
"
)
.
add
(
autofillResult
)
;
if
(
usernameField
)
{
let
focusedElement
=
gFormFillService
.
focusedInput
;
if
(
usernameField
=
=
focusedElement
&
&
autofillResult
!
=
=
AUTOFILL_RESULT
.
FILLED
)
{
log
(
"
_fillForm
:
Opening
username
autocomplete
popup
since
the
form
wasn
'
t
autofilled
"
)
;
gFormFillService
.
showPopup
(
)
;
}
}
}
if
(
usernameField
)
{
log
(
"
_fillForm
:
Attaching
event
listeners
to
usernameField
"
)
;
usernameField
.
addEventListener
(
"
focus
"
observer
)
;
usernameField
.
addEventListener
(
"
mousedown
"
observer
)
;
}
this
.
sendAsyncMessage
(
"
PasswordManager
:
formProcessed
"
{
formid
:
form
.
rootElement
.
id
}
)
;
}
}
_isLoginAlreadyFilled
(
aUsernameField
)
{
let
formLikeRoot
=
FormLikeFactory
.
findRootForField
(
aUsernameField
)
;
let
existingLoginForm
=
LoginFormFactory
.
getForRootElement
(
formLikeRoot
)
;
if
(
!
existingLoginForm
)
{
throw
new
Error
(
"
_isLoginAlreadyFilled
called
with
a
username
field
with
"
+
"
no
rootElement
LoginForm
"
)
;
}
log
(
"
_isLoginAlreadyFilled
:
existingLoginForm
"
existingLoginForm
)
;
let
filledLogin
=
this
.
stateForDocument
(
aUsernameField
.
ownerDocument
)
.
fillsByRootElement
.
get
(
formLikeRoot
)
;
if
(
!
filledLogin
)
{
return
false
;
}
let
autoFilledUsernameField
=
filledLogin
.
usernameField
?
filledLogin
.
usernameField
.
get
(
)
:
null
;
let
autoFilledPasswordField
=
filledLogin
.
passwordField
.
get
(
)
;
if
(
!
autoFilledUsernameField
|
|
autoFilledUsernameField
!
=
aUsernameField
|
|
autoFilledUsernameField
.
value
!
=
filledLogin
.
username
|
|
!
autoFilledPasswordField
|
|
autoFilledPasswordField
.
value
!
=
filledLogin
.
password
)
{
return
false
;
}
return
true
;
}
getUserNameAndPasswordFields
(
aField
)
{
if
(
ChromeUtils
.
getClassName
(
aField
)
!
=
=
"
HTMLInputElement
"
|
|
(
aField
.
type
!
=
"
password
"
&
&
!
LoginHelper
.
isUsernameFieldType
(
aField
)
)
|
|
aField
.
nodePrincipal
.
isNullPrincipal
|
|
!
aField
.
ownerDocument
)
{
return
[
null
null
null
]
;
}
let
form
=
LoginFormFactory
.
createFromField
(
aField
)
;
let
doc
=
aField
.
ownerDocument
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
let
recipes
=
LoginRecipesContent
.
getRecipes
(
this
formOrigin
doc
.
defaultView
)
;
return
this
.
_getFormFields
(
form
false
recipes
)
;
}
getFieldContext
(
aField
)
{
if
(
ChromeUtils
.
getClassName
(
aField
)
!
=
=
"
HTMLInputElement
"
|
|
(
aField
.
type
!
=
"
password
"
&
&
!
LoginHelper
.
isUsernameFieldType
(
aField
)
)
|
|
aField
.
nodePrincipal
.
isNullPrincipal
|
|
aField
.
nodePrincipal
.
schemeIs
(
"
about
"
)
|
|
!
aField
.
ownerDocument
)
{
return
null
;
}
let
[
usernameField
newPasswordField
]
=
this
.
getUserNameAndPasswordFields
(
aField
)
;
if
(
aField
.
type
!
=
"
password
"
)
{
usernameField
=
aField
;
}
return
{
usernameField
:
{
found
:
!
!
usernameField
disabled
:
usernameField
&
&
(
usernameField
.
disabled
|
|
usernameField
.
readOnly
)
}
passwordField
:
{
found
:
!
!
newPasswordField
disabled
:
newPasswordField
&
&
(
newPasswordField
.
disabled
|
|
newPasswordField
.
readOnly
)
}
}
;
}
}
;
