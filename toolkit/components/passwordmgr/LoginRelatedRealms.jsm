"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
LoginHelper
:
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
log
"
(
)
=
>
{
let
logger
=
lazy
.
LoginHelper
.
createLogger
(
"
LoginRelatedRealms
"
)
;
return
logger
;
}
)
;
const
EXPORTED_SYMBOLS
=
[
"
LoginRelatedRealmsParent
"
]
;
class
LoginRelatedRealmsParent
extends
JSWindowActorParent
{
_sharedCredentialsClient
=
null
;
_relatedDomainsList
=
[
[
]
]
;
onRemoteSettingsSync
(
aEvent
)
{
let
{
data
:
{
current
}
}
=
aEvent
;
this
.
_relatedDomainsList
=
current
;
}
async
getSharedCredentialsCollection
(
)
{
if
(
!
this
.
_sharedCredentialsClient
)
{
this
.
_sharedCredentialsClient
=
lazy
.
RemoteSettings
(
lazy
.
LoginHelper
.
relatedRealmsCollection
)
;
this
.
_sharedCredentialsClient
.
on
(
"
sync
"
event
=
>
this
.
onRemoteSettingsSync
(
event
)
)
;
this
.
_relatedDomainsList
=
await
this
.
_sharedCredentialsClient
.
get
(
)
;
lazy
.
log
.
debug
(
"
Initialized
related
realms
"
this
.
_relatedDomainsList
)
;
}
lazy
.
log
.
debug
(
"
this
.
_relatedDomainsList
"
this
.
_relatedDomainsList
)
;
return
this
.
_relatedDomainsList
;
}
async
findRelatedRealms
(
formOrigin
)
{
try
{
let
formOriginURI
=
Services
.
io
.
newURI
(
formOrigin
)
;
let
originDomain
=
formOriginURI
.
host
;
let
[
{
relatedRealms
}
=
{
}
]
=
await
this
.
getSharedCredentialsCollection
(
)
;
if
(
!
relatedRealms
)
{
return
[
]
;
}
let
filterOriginIndex
;
let
shouldInclude
=
false
;
let
filteredRealms
=
relatedRealms
.
filter
(
_realms
=
>
{
for
(
let
relatedOrigin
of
_realms
)
{
if
(
shouldInclude
)
{
return
false
;
}
if
(
Services
.
eTLD
.
hasRootDomain
(
originDomain
relatedOrigin
)
)
{
shouldInclude
=
true
;
break
;
}
}
return
shouldInclude
;
}
)
;
filteredRealms
=
filteredRealms
.
flat
(
)
;
filterOriginIndex
=
filteredRealms
.
indexOf
(
originDomain
)
;
if
(
filterOriginIndex
!
=
=
-
1
)
{
filteredRealms
.
splice
(
filterOriginIndex
1
)
;
}
return
filteredRealms
;
}
catch
(
e
)
{
lazy
.
log
.
error
(
e
)
;
return
[
]
;
}
}
}
