"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginImport
"
"
resource
:
/
/
gre
/
modules
/
LoginImport
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginStore
"
"
resource
:
/
/
gre
/
modules
/
LoginStore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gUUIDGenerator
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
this
.
LoginManagerStorage_json
=
function
(
)
{
}
;
this
.
LoginManagerStorage_json
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
c00c432d
-
a0c9
-
46d7
-
bef6
-
9c45b4d07341
}
"
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsILoginManagerStorage
]
)
__crypto
:
null
get
_crypto
(
)
{
if
(
!
this
.
__crypto
)
this
.
__crypto
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
crypto
/
SDR
;
1
"
]
.
getService
(
Ci
.
nsILoginManagerCrypto
)
;
return
this
.
__crypto
;
}
initialize
(
)
{
try
{
this
.
_crypto
;
let
jsonPath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
logins
.
json
"
)
;
this
.
_store
=
new
LoginStore
(
jsonPath
)
;
return
(
async
(
)
=
>
{
this
.
log
(
"
Opening
database
at
"
this
.
_store
.
path
)
;
await
this
.
_store
.
load
(
)
;
try
{
if
(
Services
.
prefs
.
getBoolPref
(
"
signon
.
importedFromSqlite
"
)
)
{
return
;
}
}
catch
(
ex
)
{
}
let
sqlitePath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
signons
.
sqlite
"
)
;
if
(
await
OS
.
File
.
exists
(
sqlitePath
)
)
{
let
loginImport
=
new
LoginImport
(
this
.
_store
sqlitePath
)
;
await
loginImport
.
import
(
)
.
catch
(
Cu
.
reportError
)
;
this
.
_store
.
saveSoon
(
)
;
}
Services
.
prefs
.
setBoolPref
(
"
signon
.
importedFromSqlite
"
true
)
;
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
}
catch
(
e
)
{
this
.
log
(
"
Initialization
failed
:
"
e
)
;
throw
new
Error
(
"
Initialization
failed
"
)
;
}
}
terminate
(
)
{
this
.
_store
.
_saver
.
disarm
(
)
;
return
this
.
_store
.
_save
(
)
;
}
addLogin
(
login
preEncrypted
=
false
)
{
this
.
_store
.
ensureDataReady
(
)
;
LoginHelper
.
checkLoginValues
(
login
)
;
let
[
encUsername
encPassword
encType
]
=
preEncrypted
?
[
login
.
username
login
.
password
this
.
_crypto
.
defaultEncType
]
:
this
.
_encryptLogin
(
login
)
;
let
loginClone
=
login
.
clone
(
)
;
loginClone
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
if
(
loginClone
.
guid
)
{
let
guid
=
loginClone
.
guid
;
if
(
!
this
.
_isGuidUnique
(
guid
)
)
{
let
existing
=
this
.
_searchLogins
(
{
guid
}
)
[
0
]
;
if
(
this
.
_decryptLogins
(
existing
)
.
length
)
{
throw
new
Error
(
"
specified
GUID
already
exists
"
)
;
}
let
foundIndex
=
this
.
_store
.
data
.
logins
.
findIndex
(
l
=
>
l
.
guid
=
=
guid
)
;
if
(
foundIndex
=
=
-
1
)
{
throw
new
Error
(
"
can
'
t
find
a
matching
GUID
to
remove
"
)
;
}
this
.
_store
.
data
.
logins
.
splice
(
foundIndex
1
)
;
}
}
else
{
loginClone
.
guid
=
gUUIDGenerator
.
generateUUID
(
)
.
toString
(
)
;
}
let
currentTime
=
Date
.
now
(
)
;
if
(
!
loginClone
.
timeCreated
)
loginClone
.
timeCreated
=
currentTime
;
if
(
!
loginClone
.
timeLastUsed
)
loginClone
.
timeLastUsed
=
currentTime
;
if
(
!
loginClone
.
timePasswordChanged
)
loginClone
.
timePasswordChanged
=
currentTime
;
if
(
!
loginClone
.
timesUsed
)
loginClone
.
timesUsed
=
1
;
this
.
_store
.
data
.
logins
.
push
(
{
id
:
this
.
_store
.
data
.
nextId
+
+
hostname
:
loginClone
.
hostname
httpRealm
:
loginClone
.
httpRealm
formSubmitURL
:
loginClone
.
formSubmitURL
usernameField
:
loginClone
.
usernameField
passwordField
:
loginClone
.
passwordField
encryptedUsername
:
encUsername
encryptedPassword
:
encPassword
guid
:
loginClone
.
guid
encType
timeCreated
:
loginClone
.
timeCreated
timeLastUsed
:
loginClone
.
timeLastUsed
timePasswordChanged
:
loginClone
.
timePasswordChanged
timesUsed
:
loginClone
.
timesUsed
}
)
;
this
.
_store
.
saveSoon
(
)
;
LoginHelper
.
notifyStorageChanged
(
"
addLogin
"
loginClone
)
;
return
loginClone
;
}
removeLogin
(
login
)
{
this
.
_store
.
ensureDataReady
(
)
;
let
[
idToDelete
storedLogin
]
=
this
.
_getIdForLogin
(
login
)
;
if
(
!
idToDelete
)
throw
new
Error
(
"
No
matching
logins
"
)
;
let
foundIndex
=
this
.
_store
.
data
.
logins
.
findIndex
(
l
=
>
l
.
id
=
=
idToDelete
)
;
if
(
foundIndex
!
=
-
1
)
{
this
.
_store
.
data
.
logins
.
splice
(
foundIndex
1
)
;
this
.
_store
.
saveSoon
(
)
;
}
LoginHelper
.
notifyStorageChanged
(
"
removeLogin
"
storedLogin
)
;
}
modifyLogin
(
oldLogin
newLoginData
)
{
this
.
_store
.
ensureDataReady
(
)
;
let
[
idToModify
oldStoredLogin
]
=
this
.
_getIdForLogin
(
oldLogin
)
;
if
(
!
idToModify
)
throw
new
Error
(
"
No
matching
logins
"
)
;
let
newLogin
=
LoginHelper
.
buildModifiedLogin
(
oldStoredLogin
newLoginData
)
;
if
(
newLogin
.
guid
!
=
oldStoredLogin
.
guid
&
&
!
this
.
_isGuidUnique
(
newLogin
.
guid
)
)
{
throw
new
Error
(
"
specified
GUID
already
exists
"
)
;
}
if
(
!
newLogin
.
matches
(
oldLogin
true
)
)
{
let
logins
=
this
.
findLogins
(
{
}
newLogin
.
hostname
newLogin
.
formSubmitURL
newLogin
.
httpRealm
)
;
if
(
logins
.
some
(
login
=
>
newLogin
.
matches
(
login
true
)
)
)
throw
new
Error
(
"
This
login
already
exists
.
"
)
;
}
let
[
encUsername
encPassword
encType
]
=
this
.
_encryptLogin
(
newLogin
)
;
for
(
let
loginItem
of
this
.
_store
.
data
.
logins
)
{
if
(
loginItem
.
id
=
=
idToModify
)
{
loginItem
.
hostname
=
newLogin
.
hostname
;
loginItem
.
httpRealm
=
newLogin
.
httpRealm
;
loginItem
.
formSubmitURL
=
newLogin
.
formSubmitURL
;
loginItem
.
usernameField
=
newLogin
.
usernameField
;
loginItem
.
passwordField
=
newLogin
.
passwordField
;
loginItem
.
encryptedUsername
=
encUsername
;
loginItem
.
encryptedPassword
=
encPassword
;
loginItem
.
guid
=
newLogin
.
guid
;
loginItem
.
encType
=
encType
;
loginItem
.
timeCreated
=
newLogin
.
timeCreated
;
loginItem
.
timeLastUsed
=
newLogin
.
timeLastUsed
;
loginItem
.
timePasswordChanged
=
newLogin
.
timePasswordChanged
;
loginItem
.
timesUsed
=
newLogin
.
timesUsed
;
this
.
_store
.
saveSoon
(
)
;
break
;
}
}
LoginHelper
.
notifyStorageChanged
(
"
modifyLogin
"
[
oldStoredLogin
newLogin
]
)
;
}
getAllLogins
(
count
)
{
let
[
logins
ids
]
=
this
.
_searchLogins
(
{
}
)
;
logins
=
this
.
_decryptLogins
(
logins
)
;
this
.
log
(
"
_getAllLogins
:
returning
"
logins
.
length
"
logins
.
"
)
;
if
(
count
)
count
.
value
=
logins
.
length
;
return
logins
;
}
searchLogins
(
count
matchData
)
{
let
realMatchData
=
{
}
;
let
options
=
{
}
;
let
propEnum
=
matchData
.
enumerator
;
while
(
propEnum
.
hasMoreElements
(
)
)
{
let
prop
=
propEnum
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIProperty
)
;
switch
(
prop
.
name
)
{
case
"
schemeUpgrades
"
:
{
options
[
prop
.
name
]
=
prop
.
value
;
break
;
}
default
:
{
realMatchData
[
prop
.
name
]
=
prop
.
value
;
break
;
}
}
}
let
[
logins
ids
]
=
this
.
_searchLogins
(
realMatchData
options
)
;
logins
=
this
.
_decryptLogins
(
logins
)
;
count
.
value
=
logins
.
length
;
return
logins
;
}
_searchLogins
(
matchData
aOptions
=
{
schemeUpgrades
:
false
}
)
{
this
.
_store
.
ensureDataReady
(
)
;
function
match
(
aLogin
)
{
for
(
let
field
in
matchData
)
{
let
wantedValue
=
matchData
[
field
]
;
switch
(
field
)
{
case
"
formSubmitURL
"
:
if
(
wantedValue
!
=
null
)
{
if
(
aLogin
.
formSubmitURL
=
=
"
"
)
{
break
;
}
if
(
!
LoginHelper
.
isOriginMatching
(
aLogin
[
field
]
wantedValue
aOptions
)
)
{
return
false
;
}
break
;
}
case
"
hostname
"
:
if
(
wantedValue
!
=
null
)
{
if
(
!
LoginHelper
.
isOriginMatching
(
aLogin
[
field
]
wantedValue
aOptions
)
)
{
return
false
;
}
break
;
}
case
"
httpRealm
"
:
case
"
id
"
:
case
"
usernameField
"
:
case
"
passwordField
"
:
case
"
encryptedUsername
"
:
case
"
encryptedPassword
"
:
case
"
guid
"
:
case
"
encType
"
:
case
"
timeCreated
"
:
case
"
timeLastUsed
"
:
case
"
timePasswordChanged
"
:
case
"
timesUsed
"
:
if
(
wantedValue
=
=
null
&
&
aLogin
[
field
]
)
{
return
false
;
}
else
if
(
aLogin
[
field
]
!
=
wantedValue
)
{
return
false
;
}
break
;
default
:
throw
new
Error
(
"
Unexpected
field
:
"
+
field
)
;
}
}
return
true
;
}
let
foundLogins
=
[
]
foundIds
=
[
]
;
for
(
let
loginItem
of
this
.
_store
.
data
.
logins
)
{
if
(
match
(
loginItem
)
)
{
let
login
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
login
.
init
(
loginItem
.
hostname
loginItem
.
formSubmitURL
loginItem
.
httpRealm
loginItem
.
encryptedUsername
loginItem
.
encryptedPassword
loginItem
.
usernameField
loginItem
.
passwordField
)
;
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
login
.
guid
=
loginItem
.
guid
;
login
.
timeCreated
=
loginItem
.
timeCreated
;
login
.
timeLastUsed
=
loginItem
.
timeLastUsed
;
login
.
timePasswordChanged
=
loginItem
.
timePasswordChanged
;
login
.
timesUsed
=
loginItem
.
timesUsed
;
foundLogins
.
push
(
login
)
;
foundIds
.
push
(
loginItem
.
id
)
;
}
}
this
.
log
(
"
_searchLogins
:
returning
"
foundLogins
.
length
"
logins
for
"
matchData
"
with
options
"
aOptions
)
;
return
[
foundLogins
foundIds
]
;
}
removeAllLogins
(
)
{
this
.
_store
.
ensureDataReady
(
)
;
this
.
log
(
"
Removing
all
logins
"
)
;
this
.
_store
.
data
.
logins
=
[
]
;
this
.
_store
.
saveSoon
(
)
;
LoginHelper
.
notifyStorageChanged
(
"
removeAllLogins
"
null
)
;
}
findLogins
(
count
hostname
formSubmitURL
httpRealm
)
{
let
loginData
=
{
hostname
formSubmitURL
httpRealm
}
;
let
matchData
=
{
}
;
for
(
let
field
of
[
"
hostname
"
"
formSubmitURL
"
"
httpRealm
"
]
)
if
(
loginData
[
field
]
!
=
"
"
)
matchData
[
field
]
=
loginData
[
field
]
;
let
[
logins
ids
]
=
this
.
_searchLogins
(
matchData
)
;
logins
=
this
.
_decryptLogins
(
logins
)
;
this
.
log
(
"
_findLogins
:
returning
"
logins
.
length
"
logins
"
)
;
count
.
value
=
logins
.
length
;
return
logins
;
}
countLogins
(
hostname
formSubmitURL
httpRealm
)
{
let
loginData
=
{
hostname
formSubmitURL
httpRealm
}
;
let
matchData
=
{
}
;
for
(
let
field
of
[
"
hostname
"
"
formSubmitURL
"
"
httpRealm
"
]
)
if
(
loginData
[
field
]
!
=
"
"
)
matchData
[
field
]
=
loginData
[
field
]
;
let
[
logins
ids
]
=
this
.
_searchLogins
(
matchData
)
;
this
.
log
(
"
_countLogins
:
counted
logins
:
"
logins
.
length
)
;
return
logins
.
length
;
}
get
uiBusy
(
)
{
return
this
.
_crypto
.
uiBusy
;
}
get
isLoggedIn
(
)
{
return
this
.
_crypto
.
isLoggedIn
;
}
_getIdForLogin
(
login
)
{
let
matchData
=
{
}
;
for
(
let
field
of
[
"
hostname
"
"
formSubmitURL
"
"
httpRealm
"
]
)
if
(
login
[
field
]
!
=
"
"
)
matchData
[
field
]
=
login
[
field
]
;
let
[
logins
ids
]
=
this
.
_searchLogins
(
matchData
)
;
let
id
=
null
;
let
foundLogin
=
null
;
for
(
let
i
=
0
;
i
<
logins
.
length
;
i
+
+
)
{
let
[
decryptedLogin
]
=
this
.
_decryptLogins
(
[
logins
[
i
]
]
)
;
if
(
!
decryptedLogin
|
|
!
decryptedLogin
.
equals
(
login
)
)
continue
;
foundLogin
=
decryptedLogin
;
id
=
ids
[
i
]
;
break
;
}
return
[
id
foundLogin
]
;
}
_isGuidUnique
(
guid
)
{
this
.
_store
.
ensureDataReady
(
)
;
return
this
.
_store
.
data
.
logins
.
every
(
l
=
>
l
.
guid
!
=
guid
)
;
}
_encryptLogin
(
login
)
{
let
encUsername
=
this
.
_crypto
.
encrypt
(
login
.
username
)
;
let
encPassword
=
this
.
_crypto
.
encrypt
(
login
.
password
)
;
let
encType
=
this
.
_crypto
.
defaultEncType
;
return
[
encUsername
encPassword
encType
]
;
}
_decryptLogins
(
logins
)
{
let
result
=
[
]
;
for
(
let
login
of
logins
)
{
try
{
login
.
username
=
this
.
_crypto
.
decrypt
(
login
.
username
)
;
login
.
password
=
this
.
_crypto
.
decrypt
(
login
.
password
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_FAILURE
)
continue
;
throw
e
;
}
result
.
push
(
login
)
;
}
return
result
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
this
.
LoginManagerStorage_json
.
prototype
"
log
"
(
)
=
>
{
let
logger
=
LoginHelper
.
createLogger
(
"
Login
storage
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
LoginManagerStorage_json
]
)
;
