const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
function
LoginManagerCrypto_SDR
(
)
{
this
.
init
(
)
;
}
LoginManagerCrypto_SDR
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
dc6c2976
-
0f73
-
4f1f
-
b9ff
-
3d72b4e28309
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsILoginManagerCrypto
]
)
__decoderRing
:
null
get
_decoderRing
(
)
{
if
(
!
this
.
__decoderRing
)
{
this
.
__decoderRing
=
Cc
[
"
mozilla
.
org
/
security
/
sdr
;
1
"
]
.
getService
(
Ci
.
nsISecretDecoderRing
)
;
}
return
this
.
__decoderRing
;
}
__utfConverter
:
null
get
_utfConverter
(
)
{
if
(
!
this
.
__utfConverter
)
{
this
.
__utfConverter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
this
.
__utfConverter
.
charset
=
"
UTF
-
8
"
;
}
return
this
.
__utfConverter
;
}
_utfConverterReset
(
)
{
this
.
__utfConverter
=
null
;
}
_uiBusy
:
false
init
(
)
{
let
tokenDB
=
Cc
[
"
mozilla
.
org
/
security
/
pk11tokendb
;
1
"
]
.
getService
(
Ci
.
nsIPK11TokenDB
)
;
let
token
=
tokenDB
.
getInternalKeyToken
(
)
;
if
(
token
.
needsUserInit
)
{
this
.
log
(
"
Initializing
key3
.
db
with
default
blank
password
.
"
)
;
token
.
initPassword
(
"
"
)
;
}
}
encrypt
(
plainText
)
{
let
cipherText
=
null
;
let
wasLoggedIn
=
this
.
isLoggedIn
;
let
canceledMP
=
false
;
this
.
_uiBusy
=
true
;
try
{
let
plainOctet
=
this
.
_utfConverter
.
ConvertFromUnicode
(
plainText
)
;
plainOctet
+
=
this
.
_utfConverter
.
Finish
(
)
;
cipherText
=
this
.
_decoderRing
.
encryptString
(
plainOctet
)
;
}
catch
(
e
)
{
this
.
log
(
"
Failed
to
encrypt
string
.
(
"
+
e
.
name
+
"
)
"
)
;
if
(
e
.
result
=
=
Cr
.
NS_ERROR_FAILURE
)
{
canceledMP
=
true
;
throw
Components
.
Exception
(
"
User
canceled
master
password
entry
"
Cr
.
NS_ERROR_ABORT
)
;
}
else
{
throw
Components
.
Exception
(
"
Couldn
'
t
encrypt
string
"
Cr
.
NS_ERROR_FAILURE
)
;
}
}
finally
{
this
.
_uiBusy
=
false
;
if
(
!
wasLoggedIn
&
&
this
.
isLoggedIn
)
{
this
.
_notifyObservers
(
"
passwordmgr
-
crypto
-
login
"
)
;
}
else
if
(
canceledMP
)
{
this
.
_notifyObservers
(
"
passwordmgr
-
crypto
-
loginCanceled
"
)
;
}
}
return
cipherText
;
}
async
encryptMany
(
plaintexts
)
{
if
(
!
Array
.
isArray
(
plaintexts
)
|
|
!
plaintexts
.
length
)
{
throw
Components
.
Exception
(
"
Need
at
least
one
plaintext
to
encrypt
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
cipherTexts
;
let
wasLoggedIn
=
this
.
isLoggedIn
;
let
canceledMP
=
false
;
this
.
_uiBusy
=
true
;
try
{
cipherTexts
=
await
this
.
_decoderRing
.
asyncEncryptStrings
(
plaintexts
.
length
plaintexts
)
;
}
catch
(
e
)
{
this
.
log
(
"
Failed
to
encrypt
strings
.
(
"
+
e
.
name
+
"
)
"
)
;
if
(
e
.
result
=
=
Cr
.
NS_ERROR_FAILURE
)
{
canceledMP
=
true
;
throw
Components
.
Exception
(
"
User
canceled
master
password
entry
"
Cr
.
NS_ERROR_ABORT
)
;
}
else
{
throw
Components
.
Exception
(
"
Couldn
'
t
encrypt
strings
"
Cr
.
NS_ERROR_FAILURE
)
;
}
}
finally
{
this
.
_uiBusy
=
false
;
if
(
!
wasLoggedIn
&
&
this
.
isLoggedIn
)
{
this
.
_notifyObservers
(
"
passwordmgr
-
crypto
-
login
"
)
;
}
else
if
(
canceledMP
)
{
this
.
_notifyObservers
(
"
passwordmgr
-
crypto
-
loginCanceled
"
)
;
}
}
return
cipherTexts
;
}
decrypt
(
cipherText
)
{
let
plainText
=
null
;
let
wasLoggedIn
=
this
.
isLoggedIn
;
let
canceledMP
=
false
;
this
.
_uiBusy
=
true
;
try
{
let
plainOctet
;
plainOctet
=
this
.
_decoderRing
.
decryptString
(
cipherText
)
;
plainText
=
this
.
_utfConverter
.
ConvertToUnicode
(
plainOctet
)
;
}
catch
(
e
)
{
this
.
log
(
"
Failed
to
decrypt
string
:
"
+
cipherText
+
"
(
"
+
e
.
name
+
"
)
"
)
;
this
.
_utfConverterReset
(
)
;
if
(
e
.
result
=
=
Cr
.
NS_ERROR_NOT_AVAILABLE
)
{
canceledMP
=
true
;
throw
Components
.
Exception
(
"
User
canceled
master
password
entry
"
Cr
.
NS_ERROR_ABORT
)
;
}
else
{
throw
Components
.
Exception
(
"
Couldn
'
t
decrypt
string
"
Cr
.
NS_ERROR_FAILURE
)
;
}
}
finally
{
this
.
_uiBusy
=
false
;
if
(
!
wasLoggedIn
&
&
this
.
isLoggedIn
)
{
this
.
_notifyObservers
(
"
passwordmgr
-
crypto
-
login
"
)
;
}
else
if
(
canceledMP
)
{
this
.
_notifyObservers
(
"
passwordmgr
-
crypto
-
loginCanceled
"
)
;
}
}
return
plainText
;
}
get
uiBusy
(
)
{
return
this
.
_uiBusy
;
}
get
isLoggedIn
(
)
{
let
tokenDB
=
Cc
[
"
mozilla
.
org
/
security
/
pk11tokendb
;
1
"
]
.
getService
(
Ci
.
nsIPK11TokenDB
)
;
let
token
=
tokenDB
.
getInternalKeyToken
(
)
;
return
!
token
.
hasPassword
|
|
token
.
isLoggedIn
(
)
;
}
get
defaultEncType
(
)
{
return
Ci
.
nsILoginManagerCrypto
.
ENCTYPE_SDR
;
}
_notifyObservers
(
topic
)
{
this
.
log
(
"
Prompted
for
a
master
password
notifying
for
"
+
topic
)
;
Services
.
obs
.
notifyObservers
(
null
topic
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
this
.
LoginManagerCrypto_SDR
.
prototype
"
log
"
(
)
=
>
{
let
logger
=
LoginHelper
.
createLogger
(
"
Login
crypto
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
LoginManagerCrypto_SDR
"
]
;
