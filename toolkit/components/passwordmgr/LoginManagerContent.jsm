"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
LoginManagerContent
"
"
LoginFormFactory
"
"
UserAutoCompleteResult
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
const
PASSWORD_INPUT_ADDED_COALESCING_THRESHOLD_MS
=
1
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
InsecurePasswordUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormLikeFactory
"
"
resource
:
/
/
gre
/
modules
/
FormLikeFactory
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LoginRecipesContent
"
"
resource
:
/
/
gre
/
modules
/
LoginRecipes
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
InsecurePasswordUtils
"
"
resource
:
/
/
gre
/
modules
/
InsecurePasswordUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gNetUtil
"
"
mozilla
.
org
/
network
/
util
;
1
"
"
nsINetUtil
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
logger
=
LoginHelper
.
createLogger
(
"
LoginManagerContent
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
var
gEnabled
gAutofillForms
gStoreWhenAutocompleteOff
;
var
observer
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsIFormSubmitObserver
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
notify
(
formElement
aWindow
actionURI
)
{
log
(
"
observer
notified
for
form
submission
.
"
)
;
try
{
let
formLike
=
LoginFormFactory
.
createFromForm
(
formElement
)
;
LoginManagerContent
.
_onFormSubmit
(
formLike
)
;
}
catch
(
e
)
{
log
(
"
Caught
error
in
onFormSubmit
(
"
e
.
lineNumber
"
)
:
"
e
.
message
)
;
Cu
.
reportError
(
e
)
;
}
return
true
;
}
onPrefChange
(
)
{
gEnabled
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
rememberSignons
"
)
;
gAutofillForms
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
autofillForms
"
)
;
gStoreWhenAutocompleteOff
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
storeWhenAutocompleteOff
"
)
;
}
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
if
(
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
|
|
!
(
aWebProgress
.
loadType
&
Ci
.
nsIDocShell
.
LOAD_CMD_PUSHSTATE
)
)
{
return
;
}
log
(
"
onLocationChange
handled
:
"
aLocation
.
spec
aWebProgress
.
DOMWindow
.
document
)
;
LoginManagerContent
.
_onNavigation
(
aWebProgress
.
DOMWindow
.
document
)
;
}
onStateChange
(
aWebProgress
aRequest
aState
aStatus
)
{
if
(
!
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
)
{
return
;
}
let
channel
=
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
triggeringPrincipal
=
channel
.
loadInfo
.
triggeringPrincipal
;
if
(
triggeringPrincipal
.
isNullPrincipal
|
|
triggeringPrincipal
.
equals
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
)
{
return
;
}
if
(
!
(
aWebProgress
.
loadType
&
Ci
.
nsIDocShell
.
LOAD_CMD_NORMAL
)
)
{
log
(
"
onStateChange
:
loadType
isn
'
t
LOAD_CMD_NORMAL
:
"
aWebProgress
.
loadType
)
;
return
;
}
log
(
"
onStateChange
handled
:
"
channel
)
;
LoginManagerContent
.
_onNavigation
(
aWebProgress
.
DOMWindow
.
document
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
"
earlyformsubmit
"
false
)
;
var
prefBranch
=
Services
.
prefs
.
getBranch
(
"
signon
.
"
)
;
prefBranch
.
addObserver
(
"
"
observer
.
onPrefChange
false
)
;
observer
.
onPrefChange
(
)
;
function
messageManagerFromWindow
(
win
)
{
return
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
}
var
LoginManagerContent
=
{
__formFillService
:
null
get
_formFillService
(
)
{
if
(
!
this
.
__formFillService
)
this
.
__formFillService
=
Cc
[
"
mozilla
.
org
/
satchel
/
form
-
fill
-
controller
;
1
"
]
.
getService
(
Ci
.
nsIFormFillController
)
;
return
this
.
__formFillService
;
}
_getRandomId
(
)
{
return
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
}
_messages
:
[
"
RemoteLogins
:
loginsFound
"
"
RemoteLogins
:
loginsAutoCompleted
"
]
_formLikeByRootElement
:
new
WeakMap
(
)
_deferredPasswordAddedTasksByRootElement
:
new
WeakMap
(
)
_requests
:
new
Map
(
)
_managers
:
new
Map
(
)
_takeRequest
(
msg
)
{
let
data
=
msg
.
data
;
let
request
=
this
.
_requests
.
get
(
data
.
requestId
)
;
this
.
_requests
.
delete
(
data
.
requestId
)
;
let
count
=
this
.
_managers
.
get
(
msg
.
target
)
;
if
(
-
-
count
=
=
=
0
)
{
this
.
_managers
.
delete
(
msg
.
target
)
;
for
(
let
message
of
this
.
_messages
)
msg
.
target
.
removeMessageListener
(
message
this
)
;
}
else
{
this
.
_managers
.
set
(
msg
.
target
count
)
;
}
return
request
;
}
_sendRequest
(
messageManager
requestData
name
messageData
)
{
let
count
;
if
(
!
(
count
=
this
.
_managers
.
get
(
messageManager
)
)
)
{
this
.
_managers
.
set
(
messageManager
1
)
;
for
(
let
message
of
this
.
_messages
)
messageManager
.
addMessageListener
(
message
this
)
;
}
else
{
this
.
_managers
.
set
(
messageManager
+
+
count
)
;
}
let
requestId
=
this
.
_getRandomId
(
)
;
messageData
.
requestId
=
requestId
;
messageManager
.
sendAsyncMessage
(
name
messageData
)
;
let
deferred
=
Promise
.
defer
(
)
;
requestData
.
promise
=
deferred
;
this
.
_requests
.
set
(
requestId
requestData
)
;
return
deferred
.
promise
;
}
receiveMessage
(
msg
window
)
{
if
(
msg
.
name
=
=
"
RemoteLogins
:
fillForm
"
)
{
this
.
fillForm
(
{
topDocument
:
window
.
document
loginFormOrigin
:
msg
.
data
.
loginFormOrigin
loginsFound
:
LoginHelper
.
vanillaObjectsToLogins
(
msg
.
data
.
logins
)
recipes
:
msg
.
data
.
recipes
inputElement
:
msg
.
objects
.
inputElement
}
)
;
return
;
}
let
request
=
this
.
_takeRequest
(
msg
)
;
switch
(
msg
.
name
)
{
case
"
RemoteLogins
:
loginsFound
"
:
{
let
loginsFound
=
LoginHelper
.
vanillaObjectsToLogins
(
msg
.
data
.
logins
)
;
request
.
promise
.
resolve
(
{
form
:
request
.
form
loginsFound
recipes
:
msg
.
data
.
recipes
}
)
;
break
;
}
case
"
RemoteLogins
:
loginsAutoCompleted
"
:
{
let
loginsFound
=
LoginHelper
.
vanillaObjectsToLogins
(
msg
.
data
.
logins
)
;
let
messageManager
=
msg
.
target
;
request
.
promise
.
resolve
(
{
logins
:
loginsFound
messageManager
}
)
;
break
;
}
}
}
_getLoginDataFromParent
(
form
options
)
{
let
doc
=
form
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
formOrigin
=
LoginUtils
.
_getPasswordOrigin
(
doc
.
documentURI
)
;
if
(
!
formOrigin
)
{
return
Promise
.
reject
(
"
_getLoginDataFromParent
:
A
form
origin
is
required
"
)
;
}
let
actionOrigin
=
LoginUtils
.
_getActionOrigin
(
form
)
;
let
messageManager
=
messageManagerFromWindow
(
win
)
;
let
requestData
=
{
form
}
;
let
messageData
=
{
formOrigin
actionOrigin
options
}
;
return
this
.
_sendRequest
(
messageManager
requestData
"
RemoteLogins
:
findLogins
"
messageData
)
;
}
_autoCompleteSearchAsync
(
aSearchString
aPreviousResult
aElement
aRect
)
{
let
doc
=
aElement
.
ownerDocument
;
let
form
=
LoginFormFactory
.
createFromField
(
aElement
)
;
let
win
=
doc
.
defaultView
;
let
formOrigin
=
LoginUtils
.
_getPasswordOrigin
(
doc
.
documentURI
)
;
let
actionOrigin
=
LoginUtils
.
_getActionOrigin
(
form
)
;
let
messageManager
=
messageManagerFromWindow
(
win
)
;
let
previousResult
=
aPreviousResult
?
{
searchString
:
aPreviousResult
.
searchString
logins
:
LoginHelper
.
loginsToVanillaObjects
(
aPreviousResult
.
logins
)
}
:
null
;
let
requestData
=
{
}
;
let
messageData
=
{
formOrigin
actionOrigin
searchString
:
aSearchString
previousResult
rect
:
aRect
isSecure
:
InsecurePasswordUtils
.
isFormSecure
(
form
)
isPasswordField
:
aElement
.
type
=
=
"
password
"
}
;
return
this
.
_sendRequest
(
messageManager
requestData
"
RemoteLogins
:
autoCompleteLogins
"
messageData
)
;
}
setupProgressListener
(
window
)
{
if
(
!
LoginHelper
.
formlessCaptureEnabled
)
{
return
;
}
try
{
let
webProgress
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
observer
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
|
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
catch
(
ex
)
{
}
}
onDOMFormHasPassword
(
event
window
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
form
=
event
.
target
;
let
formLike
=
LoginFormFactory
.
createFromForm
(
form
)
;
log
(
"
onDOMFormHasPassword
:
"
form
formLike
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike
window
)
;
}
onDOMInputPasswordAdded
(
event
window
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
pwField
=
event
.
target
;
if
(
pwField
.
form
)
{
return
;
}
this
.
setupProgressListener
(
window
)
;
let
formLike
=
LoginFormFactory
.
createFromField
(
pwField
)
;
log
(
"
onDOMInputPasswordAdded
:
"
pwField
formLike
)
;
let
deferredTask
=
this
.
_deferredPasswordAddedTasksByRootElement
.
get
(
formLike
.
rootElement
)
;
if
(
!
deferredTask
)
{
log
(
"
Creating
a
DeferredTask
to
call
_fetchLoginsFromParentAndFillForm
soon
"
)
;
this
.
_formLikeByRootElement
.
set
(
formLike
.
rootElement
formLike
)
;
deferredTask
=
new
DeferredTask
(
function
*
deferredInputProcessing
(
)
{
let
formLike2
=
this
.
_formLikeByRootElement
.
get
(
formLike
.
rootElement
)
;
log
(
"
Running
deferred
processing
of
onDOMInputPasswordAdded
"
formLike2
)
;
this
.
_deferredPasswordAddedTasksByRootElement
.
delete
(
formLike2
.
rootElement
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike2
window
)
;
}
.
bind
(
this
)
PASSWORD_INPUT_ADDED_COALESCING_THRESHOLD_MS
)
;
this
.
_deferredPasswordAddedTasksByRootElement
.
set
(
formLike
.
rootElement
deferredTask
)
;
}
if
(
deferredTask
.
isArmed
)
{
log
(
"
DeferredTask
is
already
armed
so
just
updating
the
FormLike
"
)
;
this
.
_formLikeByRootElement
.
set
(
formLike
.
rootElement
formLike
)
;
}
else
if
(
window
.
document
.
readyState
=
=
"
complete
"
)
{
log
(
"
Arming
the
DeferredTask
we
just
created
since
document
.
readyState
=
=
'
complete
'
"
)
;
deferredTask
.
arm
(
)
;
}
else
{
window
.
addEventListener
(
"
DOMContentLoaded
"
function
(
)
{
log
(
"
Arming
the
onDOMInputPasswordAdded
DeferredTask
due
to
DOMContentLoaded
"
)
;
deferredTask
.
arm
(
)
;
}
{
once
:
true
}
)
;
}
}
_fetchLoginsFromParentAndFillForm
(
form
window
)
{
this
.
_detectInsecureFormLikes
(
window
)
;
let
messageManager
=
messageManagerFromWindow
(
window
)
;
messageManager
.
sendAsyncMessage
(
"
LoginStats
:
LoginEncountered
"
)
;
if
(
!
gEnabled
)
{
return
;
}
this
.
_getLoginDataFromParent
(
form
{
showMasterPassword
:
true
}
)
.
then
(
this
.
loginsFound
.
bind
(
this
)
)
.
then
(
null
Cu
.
reportError
)
;
}
onPageShow
(
event
window
)
{
this
.
_detectInsecureFormLikes
(
window
)
;
}
loginFormStateByDocument
:
new
WeakMap
(
)
stateForDocument
(
document
)
{
let
loginFormState
=
this
.
loginFormStateByDocument
.
get
(
document
)
;
if
(
!
loginFormState
)
{
loginFormState
=
{
loginFormRootElements
:
new
Set
(
)
}
;
this
.
loginFormStateByDocument
.
set
(
document
loginFormState
)
;
}
return
loginFormState
;
}
_detectInsecureFormLikes
(
topWindow
)
{
log
(
"
_detectInsecureFormLikes
"
topWindow
.
location
.
href
)
;
let
hasInsecureLoginForms
=
(
thisWindow
)
=
>
{
let
doc
=
thisWindow
.
document
;
let
hasLoginForm
=
this
.
stateForDocument
(
doc
)
.
loginFormRootElements
.
size
>
0
;
return
(
hasLoginForm
&
&
!
thisWindow
.
isSecureContext
)
|
|
Array
.
some
(
thisWindow
.
frames
frame
=
>
hasInsecureLoginForms
(
frame
)
)
;
}
;
let
messageManager
=
messageManagerFromWindow
(
topWindow
)
;
messageManager
.
sendAsyncMessage
(
"
RemoteLogins
:
insecureLoginFormPresent
"
{
hasInsecureLoginForms
:
hasInsecureLoginForms
(
topWindow
)
}
)
;
}
fillForm
(
{
topDocument
loginFormOrigin
loginsFound
recipes
inputElement
}
)
{
if
(
!
inputElement
)
{
log
(
"
fillForm
:
No
input
element
specified
"
)
;
return
;
}
if
(
LoginUtils
.
_getPasswordOrigin
(
topDocument
.
documentURI
)
!
=
loginFormOrigin
)
{
if
(
!
inputElement
|
|
LoginUtils
.
_getPasswordOrigin
(
inputElement
.
ownerDocument
.
documentURI
)
!
=
loginFormOrigin
)
{
log
(
"
fillForm
:
The
requested
origin
doesn
'
t
match
the
one
form
the
"
"
document
.
This
may
mean
we
navigated
to
a
document
from
a
different
"
"
site
before
we
had
a
chance
to
indicate
this
change
in
the
user
"
"
interface
.
"
)
;
return
;
}
}
let
clobberUsername
=
true
;
let
options
=
{
inputElement
}
;
let
form
=
LoginFormFactory
.
createFromField
(
inputElement
)
;
if
(
inputElement
.
type
=
=
"
password
"
)
{
clobberUsername
=
false
;
}
this
.
_fillForm
(
form
true
clobberUsername
true
true
loginsFound
recipes
options
)
;
}
loginsFound
(
{
form
loginsFound
recipes
}
)
{
let
doc
=
form
.
ownerDocument
;
let
autofillForm
=
gAutofillForms
&
&
!
PrivateBrowsingUtils
.
isContentWindowPrivate
(
doc
.
defaultView
)
;
this
.
_fillForm
(
form
autofillForm
false
false
false
loginsFound
recipes
)
;
}
onUsernameInput
(
event
)
{
if
(
!
event
.
isTrusted
)
return
;
if
(
!
gEnabled
)
return
;
var
acInputField
=
event
.
target
;
if
(
!
(
acInputField
.
ownerDocument
instanceof
Ci
.
nsIDOMHTMLDocument
)
)
return
;
if
(
!
LoginHelper
.
isUsernameFieldType
(
acInputField
)
)
return
;
var
acForm
=
LoginFormFactory
.
createFromField
(
acInputField
)
;
if
(
!
acForm
)
return
;
if
(
!
acInputField
.
value
)
return
;
log
(
"
onUsernameInput
from
"
event
.
type
)
;
let
doc
=
acForm
.
ownerDocument
;
let
messageManager
=
messageManagerFromWindow
(
doc
.
defaultView
)
;
let
recipes
=
messageManager
.
sendSyncMessage
(
"
RemoteLogins
:
findRecipes
"
{
formOrigin
:
LoginUtils
.
_getPasswordOrigin
(
doc
.
documentURI
)
}
)
[
0
]
;
var
[
usernameField
passwordField
ignored
]
=
this
.
_getFormFields
(
acForm
false
recipes
)
;
if
(
usernameField
=
=
acInputField
&
&
passwordField
)
{
this
.
_getLoginDataFromParent
(
acForm
{
showMasterPassword
:
false
}
)
.
then
(
(
{
form
loginsFound
recipes
}
)
=
>
{
this
.
_fillForm
(
form
true
false
true
true
loginsFound
recipes
)
;
}
)
.
then
(
null
Cu
.
reportError
)
;
}
else
{
}
}
_getPasswordFields
(
form
{
fieldOverrideRecipe
=
null
skipEmptyFields
=
false
}
=
{
}
)
{
let
pwFields
=
[
]
;
for
(
let
i
=
0
;
i
<
form
.
elements
.
length
;
i
+
+
)
{
let
element
=
form
.
elements
[
i
]
;
if
(
!
(
element
instanceof
Ci
.
nsIDOMHTMLInputElement
)
|
|
element
.
type
!
=
"
password
"
)
{
continue
;
}
if
(
fieldOverrideRecipe
&
&
fieldOverrideRecipe
.
notPasswordSelector
&
&
element
.
matches
(
fieldOverrideRecipe
.
notPasswordSelector
)
)
{
log
(
"
skipping
password
field
(
id
/
name
is
"
element
.
id
"
/
"
element
.
name
+
"
)
due
to
recipe
:
"
fieldOverrideRecipe
)
;
continue
;
}
if
(
skipEmptyFields
&
&
!
element
.
value
.
trim
(
)
)
{
continue
;
}
pwFields
[
pwFields
.
length
]
=
{
index
:
i
element
}
;
}
if
(
pwFields
.
length
=
=
0
)
{
log
(
"
(
form
ignored
-
-
no
password
fields
.
)
"
)
;
return
null
;
}
else
if
(
pwFields
.
length
>
3
)
{
log
(
"
(
form
ignored
-
-
too
many
password
fields
.
[
got
"
pwFields
.
length
"
]
)
"
)
;
return
null
;
}
return
pwFields
;
}
_getFormFields
(
form
isSubmission
recipes
)
{
var
usernameField
=
null
;
var
pwFields
=
null
;
var
fieldOverrideRecipe
=
LoginRecipesContent
.
getFieldOverrides
(
recipes
form
)
;
if
(
fieldOverrideRecipe
)
{
var
pwOverrideField
=
LoginRecipesContent
.
queryLoginField
(
form
fieldOverrideRecipe
.
passwordSelector
)
;
if
(
pwOverrideField
)
{
let
formLike
=
LoginFormFactory
.
createFromField
(
pwOverrideField
)
;
pwFields
=
[
{
index
:
[
.
.
.
formLike
.
elements
]
.
indexOf
(
pwOverrideField
)
element
:
pwOverrideField
}
]
;
}
var
usernameOverrideField
=
LoginRecipesContent
.
queryLoginField
(
form
fieldOverrideRecipe
.
usernameSelector
)
;
if
(
usernameOverrideField
)
{
usernameField
=
usernameOverrideField
;
}
}
if
(
!
pwFields
)
{
pwFields
=
this
.
_getPasswordFields
(
form
{
fieldOverrideRecipe
skipEmptyFields
:
isSubmission
}
)
;
}
if
(
!
pwFields
)
{
return
[
null
null
null
]
;
}
if
(
!
usernameField
)
{
for
(
var
i
=
pwFields
[
0
]
.
index
-
1
;
i
>
=
0
;
i
-
-
)
{
var
element
=
form
.
elements
[
i
]
;
if
(
!
LoginHelper
.
isUsernameFieldType
(
element
)
)
{
continue
;
}
if
(
fieldOverrideRecipe
&
&
fieldOverrideRecipe
.
notUsernameSelector
&
&
element
.
matches
(
fieldOverrideRecipe
.
notUsernameSelector
)
)
{
continue
;
}
usernameField
=
element
;
break
;
}
}
if
(
!
usernameField
)
log
(
"
(
form
-
-
no
username
field
found
)
"
)
;
else
log
(
"
Username
field
"
usernameField
"
has
name
/
value
:
"
usernameField
.
name
"
/
"
usernameField
.
value
)
;
if
(
!
isSubmission
|
|
pwFields
.
length
=
=
1
)
{
var
passwordField
=
pwFields
[
0
]
.
element
;
log
(
"
Password
field
"
passwordField
"
has
name
:
"
passwordField
.
name
)
;
return
[
usernameField
passwordField
null
]
;
}
var
oldPasswordField
newPasswordField
;
var
pw1
=
pwFields
[
0
]
.
element
.
value
;
var
pw2
=
pwFields
[
1
]
.
element
.
value
;
var
pw3
=
(
pwFields
[
2
]
?
pwFields
[
2
]
.
element
.
value
:
null
)
;
if
(
pwFields
.
length
=
=
3
)
{
if
(
pw1
=
=
pw2
&
&
pw2
=
=
pw3
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
null
;
}
else
if
(
pw1
=
=
pw2
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
pwFields
[
2
]
.
element
;
}
else
if
(
pw2
=
=
pw3
)
{
oldPasswordField
=
pwFields
[
0
]
.
element
;
newPasswordField
=
pwFields
[
2
]
.
element
;
}
else
if
(
pw1
=
=
pw3
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
pwFields
[
1
]
.
element
;
}
else
{
log
(
"
(
form
ignored
-
-
all
3
pw
fields
differ
)
"
)
;
return
[
null
null
null
]
;
}
}
else
if
(
pw1
=
=
pw2
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
null
;
}
else
{
oldPasswordField
=
pwFields
[
0
]
.
element
;
newPasswordField
=
pwFields
[
1
]
.
element
;
}
log
(
"
Password
field
(
new
)
id
/
name
is
:
"
newPasswordField
.
id
"
/
"
newPasswordField
.
name
)
;
if
(
oldPasswordField
)
{
log
(
"
Password
field
(
old
)
id
/
name
is
:
"
oldPasswordField
.
id
"
/
"
oldPasswordField
.
name
)
;
}
else
{
log
(
"
Password
field
(
old
)
:
"
oldPasswordField
)
;
}
return
[
usernameField
newPasswordField
oldPasswordField
]
;
}
_isAutocompleteDisabled
(
element
)
{
return
element
&
&
element
.
autocomplete
=
=
"
off
"
;
}
_onNavigation
(
aDocument
)
{
let
state
=
this
.
stateForDocument
(
aDocument
)
;
let
loginFormRootElements
=
state
.
loginFormRootElements
;
log
(
"
_onNavigation
:
state
:
"
state
"
loginFormRootElements
size
:
"
loginFormRootElements
.
size
"
document
:
"
aDocument
)
;
for
(
let
formRoot
of
state
.
loginFormRootElements
)
{
if
(
formRoot
instanceof
Ci
.
nsIDOMHTMLFormElement
)
{
log
(
"
Ignoring
navigation
for
the
form
root
to
avoid
multiple
prompts
"
+
"
since
it
was
for
a
real
<
form
>
"
)
;
continue
;
}
let
formLike
=
this
.
_formLikeByRootElement
.
get
(
formRoot
)
;
this
.
_onFormSubmit
(
formLike
)
;
}
}
_onFormSubmit
(
form
)
{
log
(
"
_onFormSubmit
"
form
)
;
var
doc
=
form
.
ownerDocument
;
var
win
=
doc
.
defaultView
;
if
(
PrivateBrowsingUtils
.
isContentWindowPrivate
(
win
)
)
{
log
(
"
(
form
submission
ignored
in
private
browsing
mode
)
"
)
;
return
;
}
if
(
!
gEnabled
)
return
;
var
hostname
=
LoginUtils
.
_getPasswordOrigin
(
doc
.
documentURI
)
;
if
(
!
hostname
)
{
log
(
"
(
form
submission
ignored
-
-
invalid
hostname
)
"
)
;
return
;
}
let
formSubmitURL
=
LoginUtils
.
_getActionOrigin
(
form
)
;
let
messageManager
=
messageManagerFromWindow
(
win
)
;
let
recipes
=
messageManager
.
sendSyncMessage
(
"
RemoteLogins
:
findRecipes
"
{
formOrigin
:
hostname
}
)
[
0
]
;
var
[
usernameField
newPasswordField
oldPasswordField
]
=
this
.
_getFormFields
(
form
true
recipes
)
;
if
(
newPasswordField
=
=
null
)
return
;
if
(
(
this
.
_isAutocompleteDisabled
(
form
)
|
|
this
.
_isAutocompleteDisabled
(
usernameField
)
|
|
this
.
_isAutocompleteDisabled
(
newPasswordField
)
|
|
this
.
_isAutocompleteDisabled
(
oldPasswordField
)
)
&
&
!
gStoreWhenAutocompleteOff
)
{
log
(
"
(
form
submission
ignored
-
-
autocomplete
=
off
found
)
"
)
;
return
;
}
let
mockUsername
=
usernameField
?
{
name
:
usernameField
.
name
value
:
usernameField
.
value
}
:
null
;
let
mockPassword
=
{
name
:
newPasswordField
.
name
value
:
newPasswordField
.
value
}
;
let
mockOldPassword
=
oldPasswordField
?
{
name
:
oldPasswordField
.
name
value
:
oldPasswordField
.
value
}
:
null
;
let
openerTopWindow
=
win
.
opener
?
win
.
opener
.
top
:
null
;
messageManager
.
sendAsyncMessage
(
"
RemoteLogins
:
onFormSubmit
"
{
hostname
formSubmitURL
usernameField
:
mockUsername
newPasswordField
:
mockPassword
oldPasswordField
:
mockOldPassword
}
{
openerTopWindow
}
)
;
}
_fillForm
(
form
autofillForm
clobberUsername
clobberPassword
userTriggered
foundLogins
recipes
{
inputElement
}
=
{
}
)
{
log
(
"
_fillForm
"
form
.
elements
)
;
let
ignoreAutocomplete
=
true
;
const
AUTOFILL_RESULT
=
{
FILLED
:
0
NO_PASSWORD_FIELD
:
1
PASSWORD_DISABLED_READONLY
:
2
NO_LOGINS_FIT
:
3
NO_SAVED_LOGINS
:
4
EXISTING_PASSWORD
:
5
EXISTING_USERNAME
:
6
MULTIPLE_LOGINS
:
7
NO_AUTOFILL_FORMS
:
8
AUTOCOMPLETE_OFF
:
9
INSECURE
:
10
}
;
function
recordAutofillResult
(
result
)
{
if
(
userTriggered
)
{
return
;
}
const
autofillResultHist
=
Services
.
telemetry
.
getHistogramById
(
"
PWMGR_FORM_AUTOFILL_RESULT
"
)
;
autofillResultHist
.
add
(
result
)
;
}
try
{
if
(
foundLogins
.
length
=
=
0
&
&
(
InsecurePasswordUtils
.
isFormSecure
(
form
)
|
|
!
LoginHelper
.
showInsecureFieldWarning
)
)
{
recordAutofillResult
(
AUTOFILL_RESULT
.
NO_SAVED_LOGINS
)
;
return
;
}
var
[
usernameField
passwordField
ignored
]
=
this
.
_getFormFields
(
form
false
recipes
)
;
if
(
inputElement
)
{
if
(
inputElement
.
type
=
=
"
password
"
)
{
passwordField
=
inputElement
;
if
(
!
clobberUsername
)
{
usernameField
=
null
;
}
}
else
if
(
LoginHelper
.
isUsernameFieldType
(
inputElement
)
)
{
usernameField
=
inputElement
;
}
else
{
throw
new
Error
(
"
Unexpected
input
element
type
.
"
)
;
}
}
if
(
passwordField
=
=
null
)
{
log
(
"
not
filling
form
no
password
field
found
"
)
;
recordAutofillResult
(
AUTOFILL_RESULT
.
NO_PASSWORD_FIELD
)
;
return
;
}
this
.
_formFillService
.
markAsLoginManagerField
(
passwordField
)
;
if
(
passwordField
.
disabled
|
|
passwordField
.
readOnly
)
{
log
(
"
not
filling
form
password
field
disabled
or
read
-
only
"
)
;
recordAutofillResult
(
AUTOFILL_RESULT
.
PASSWORD_DISABLED_READONLY
)
;
return
;
}
if
(
usernameField
)
{
this
.
_formFillService
.
markAsLoginManagerField
(
usernameField
)
;
}
if
(
foundLogins
.
length
=
=
0
)
{
recordAutofillResult
(
AUTOFILL_RESULT
.
NO_SAVED_LOGINS
)
;
return
;
}
if
(
!
userTriggered
&
&
!
LoginHelper
.
insecureAutofill
&
&
!
InsecurePasswordUtils
.
isFormSecure
(
form
)
)
{
log
(
"
not
filling
form
since
it
'
s
insecure
"
)
;
recordAutofillResult
(
AUTOFILL_RESULT
.
INSECURE
)
;
return
;
}
var
isAutocompleteOff
=
false
;
if
(
this
.
_isAutocompleteDisabled
(
form
)
|
|
this
.
_isAutocompleteDisabled
(
usernameField
)
|
|
this
.
_isAutocompleteDisabled
(
passwordField
)
)
{
isAutocompleteOff
=
true
;
}
var
maxUsernameLen
=
Number
.
MAX_VALUE
;
var
maxPasswordLen
=
Number
.
MAX_VALUE
;
if
(
usernameField
&
&
usernameField
.
maxLength
>
=
0
)
maxUsernameLen
=
usernameField
.
maxLength
;
if
(
passwordField
.
maxLength
>
=
0
)
maxPasswordLen
=
passwordField
.
maxLength
;
var
logins
=
foundLogins
.
filter
(
function
(
l
)
{
var
fit
=
(
l
.
username
.
length
<
=
maxUsernameLen
&
&
l
.
password
.
length
<
=
maxPasswordLen
)
;
if
(
!
fit
)
log
(
"
Ignored
"
l
.
username
"
login
:
won
'
t
fit
"
)
;
return
fit
;
}
this
)
;
if
(
logins
.
length
=
=
0
)
{
log
(
"
form
not
filled
none
of
the
logins
fit
in
the
field
"
)
;
recordAutofillResult
(
AUTOFILL_RESULT
.
NO_LOGINS_FIT
)
;
return
;
}
if
(
passwordField
.
value
&
&
!
clobberPassword
)
{
log
(
"
form
not
filled
the
password
field
was
already
filled
"
)
;
recordAutofillResult
(
AUTOFILL_RESULT
.
EXISTING_PASSWORD
)
;
return
;
}
var
selectedLogin
;
if
(
!
clobberUsername
&
&
usernameField
&
&
(
usernameField
.
value
|
|
usernameField
.
disabled
|
|
usernameField
.
readOnly
)
)
{
var
username
=
usernameField
.
value
.
toLowerCase
(
)
;
let
matchingLogins
=
logins
.
filter
(
l
=
>
l
.
username
.
toLowerCase
(
)
=
=
username
)
;
if
(
matchingLogins
.
length
=
=
0
)
{
log
(
"
Password
not
filled
.
None
of
the
stored
logins
match
the
username
already
present
.
"
)
;
recordAutofillResult
(
AUTOFILL_RESULT
.
EXISTING_USERNAME
)
;
return
;
}
for
(
let
l
of
matchingLogins
)
{
if
(
l
.
username
=
=
usernameField
.
value
)
{
selectedLogin
=
l
;
}
}
if
(
!
selectedLogin
)
{
selectedLogin
=
matchingLogins
[
0
]
;
}
}
else
if
(
logins
.
length
=
=
1
)
{
selectedLogin
=
logins
[
0
]
;
}
else
{
let
matchingLogins
;
if
(
usernameField
)
matchingLogins
=
logins
.
filter
(
l
=
>
l
.
username
)
;
else
matchingLogins
=
logins
.
filter
(
l
=
>
!
l
.
username
)
;
if
(
matchingLogins
.
length
!
=
1
)
{
log
(
"
Multiple
logins
for
form
so
not
filling
any
.
"
)
;
recordAutofillResult
(
AUTOFILL_RESULT
.
MULTIPLE_LOGINS
)
;
return
;
}
selectedLogin
=
matchingLogins
[
0
]
;
}
if
(
!
autofillForm
)
{
log
(
"
autofillForms
=
false
but
form
can
be
filled
"
)
;
recordAutofillResult
(
AUTOFILL_RESULT
.
NO_AUTOFILL_FORMS
)
;
return
;
}
if
(
isAutocompleteOff
&
&
!
ignoreAutocomplete
)
{
log
(
"
Not
filling
the
login
because
we
'
re
respecting
autocomplete
=
off
"
)
;
recordAutofillResult
(
AUTOFILL_RESULT
.
AUTOCOMPLETE_OFF
)
;
return
;
}
if
(
usernameField
)
{
let
disabledOrReadOnly
=
usernameField
.
disabled
|
|
usernameField
.
readOnly
;
let
userNameDiffers
=
selectedLogin
.
username
!
=
usernameField
.
value
;
let
userEnteredDifferentCase
=
userTriggered
&
&
userNameDiffers
&
&
usernameField
.
value
.
toLowerCase
(
)
=
=
selectedLogin
.
username
.
toLowerCase
(
)
;
if
(
!
disabledOrReadOnly
&
&
!
userEnteredDifferentCase
&
&
userNameDiffers
)
{
usernameField
.
setUserInput
(
selectedLogin
.
username
)
;
}
}
if
(
passwordField
.
value
!
=
selectedLogin
.
password
)
{
passwordField
.
setUserInput
(
selectedLogin
.
password
)
;
}
log
(
"
_fillForm
succeeded
"
)
;
recordAutofillResult
(
AUTOFILL_RESULT
.
FILLED
)
;
let
doc
=
form
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
messageManager
=
messageManagerFromWindow
(
win
)
;
messageManager
.
sendAsyncMessage
(
"
LoginStats
:
LoginFillSuccessful
"
)
;
}
finally
{
Services
.
obs
.
notifyObservers
(
form
.
rootElement
"
passwordmgr
-
processed
-
form
"
null
)
;
}
}
getFieldContext
(
aField
)
{
if
(
!
(
aField
instanceof
Ci
.
nsIDOMHTMLInputElement
)
|
|
(
aField
.
type
!
=
"
password
"
&
&
!
LoginHelper
.
isUsernameFieldType
(
aField
)
)
|
|
!
aField
.
ownerDocument
)
{
return
null
;
}
let
form
=
LoginFormFactory
.
createFromField
(
aField
)
;
let
doc
=
aField
.
ownerDocument
;
let
messageManager
=
messageManagerFromWindow
(
doc
.
defaultView
)
;
let
recipes
=
messageManager
.
sendSyncMessage
(
"
RemoteLogins
:
findRecipes
"
{
formOrigin
:
LoginUtils
.
_getPasswordOrigin
(
doc
.
documentURI
)
}
)
[
0
]
;
let
[
usernameField
newPasswordField
]
=
this
.
_getFormFields
(
form
false
recipes
)
;
if
(
aField
.
type
!
=
"
password
"
)
{
usernameField
=
aField
;
}
return
{
usernameField
:
{
found
:
!
!
usernameField
disabled
:
usernameField
&
&
(
usernameField
.
disabled
|
|
usernameField
.
readOnly
)
}
passwordField
:
{
found
:
!
!
newPasswordField
disabled
:
newPasswordField
&
&
(
newPasswordField
.
disabled
|
|
newPasswordField
.
readOnly
)
}
}
;
}
}
;
var
LoginUtils
=
{
_getPasswordOrigin
(
uriString
allowJS
)
{
var
realm
=
"
"
;
try
{
var
uri
=
Services
.
io
.
newURI
(
uriString
)
;
if
(
allowJS
&
&
uri
.
scheme
=
=
"
javascript
"
)
return
"
javascript
:
"
;
realm
=
uri
.
scheme
+
"
:
/
/
"
+
uri
.
hostPort
;
}
catch
(
e
)
{
log
(
"
Couldn
'
t
parse
origin
for
"
uriString
e
)
;
realm
=
null
;
}
return
realm
;
}
_getActionOrigin
(
form
)
{
var
uriString
=
form
.
action
;
if
(
uriString
=
=
"
"
)
uriString
=
form
.
baseURI
;
return
this
.
_getPasswordOrigin
(
uriString
true
)
;
}
}
;
function
UserAutoCompleteResult
(
aSearchString
matchingLogins
{
isSecure
messageManager
isPasswordField
}
)
{
function
loginSort
(
a
b
)
{
var
userA
=
a
.
username
.
toLowerCase
(
)
;
var
userB
=
b
.
username
.
toLowerCase
(
)
;
if
(
userA
<
userB
)
return
-
1
;
if
(
userA
>
userB
)
return
1
;
return
0
;
}
function
findDuplicates
(
loginList
)
{
let
seen
=
new
Set
(
)
;
let
duplicates
=
new
Set
(
)
;
for
(
let
login
of
loginList
)
{
if
(
seen
.
has
(
login
.
username
)
)
{
duplicates
.
add
(
login
.
username
)
;
}
seen
.
add
(
login
.
username
)
;
}
return
duplicates
;
}
this
.
_showInsecureFieldWarning
=
(
!
isSecure
&
&
LoginHelper
.
showInsecureFieldWarning
)
?
1
:
0
;
this
.
searchString
=
aSearchString
;
this
.
logins
=
matchingLogins
.
sort
(
loginSort
)
;
this
.
matchCount
=
matchingLogins
.
length
+
this
.
_showInsecureFieldWarning
;
this
.
_messageManager
=
messageManager
;
this
.
_stringBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
passwordmgr
/
locale
/
passwordmgr
.
properties
"
)
;
this
.
_dateAndTimeFormatter
=
new
Intl
.
DateTimeFormat
(
undefined
{
day
:
"
numeric
"
month
:
"
short
"
year
:
"
numeric
"
}
)
;
this
.
_isPasswordField
=
isPasswordField
;
this
.
_duplicateUsernames
=
findDuplicates
(
matchingLogins
)
;
if
(
this
.
matchCount
>
0
)
{
this
.
searchResult
=
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
;
this
.
defaultIndex
=
0
;
}
}
UserAutoCompleteResult
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIAutoCompleteResult
Ci
.
nsISupportsWeakReference
]
)
logins
:
null
get
wrappedJSObject
(
)
{
return
this
;
}
searchString
:
null
searchResult
:
Ci
.
nsIAutoCompleteResult
.
RESULT_NOMATCH
defaultIndex
:
-
1
errorDescription
:
"
"
matchCount
:
0
getValueAt
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
matchCount
)
{
throw
new
Error
(
"
Index
out
of
range
.
"
)
;
}
if
(
this
.
_showInsecureFieldWarning
&
&
index
=
=
=
0
)
{
return
"
"
;
}
let
selectedLogin
=
this
.
logins
[
index
-
this
.
_showInsecureFieldWarning
]
;
return
this
.
_isPasswordField
?
selectedLogin
.
password
:
selectedLogin
.
username
;
}
getLabelAt
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
matchCount
)
{
throw
new
Error
(
"
Index
out
of
range
.
"
)
;
}
if
(
this
.
_showInsecureFieldWarning
&
&
index
=
=
=
0
)
{
return
this
.
_stringBundle
.
GetStringFromName
(
"
insecureFieldWarningDescription
"
)
;
}
let
that
=
this
;
function
getLocalizedString
(
key
formatArgs
)
{
if
(
formatArgs
)
{
return
that
.
_stringBundle
.
formatStringFromName
(
key
formatArgs
formatArgs
.
length
)
;
}
return
that
.
_stringBundle
.
GetStringFromName
(
key
)
;
}
let
login
=
this
.
logins
[
index
-
this
.
_showInsecureFieldWarning
]
;
let
username
=
login
.
username
;
if
(
!
username
|
|
this
.
_duplicateUsernames
.
has
(
username
)
)
{
if
(
!
username
)
{
username
=
getLocalizedString
(
"
noUsername
"
)
;
}
let
meta
=
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
let
time
=
this
.
_dateAndTimeFormatter
.
format
(
new
Date
(
meta
.
timePasswordChanged
)
)
;
username
=
getLocalizedString
(
"
loginHostAge
"
[
username
time
]
)
;
}
return
username
;
}
getCommentAt
(
index
)
{
return
"
"
;
}
getStyleAt
(
index
)
{
if
(
index
=
=
0
&
&
this
.
_showInsecureFieldWarning
)
{
return
"
insecureWarning
"
;
}
return
"
login
"
;
}
getImageAt
(
index
)
{
return
"
"
;
}
getFinalCompleteValueAt
(
index
)
{
return
this
.
getValueAt
(
index
)
;
}
removeValueAt
(
index
removeFromDB
)
{
if
(
index
<
0
|
|
index
>
=
this
.
matchCount
)
{
throw
new
Error
(
"
Index
out
of
range
.
"
)
;
}
if
(
this
.
_showInsecureFieldWarning
&
&
index
=
=
=
0
)
{
return
;
}
if
(
this
.
_showInsecureFieldWarning
)
{
index
-
-
;
}
var
[
removedLogin
]
=
this
.
logins
.
splice
(
index
1
)
;
this
.
matchCount
-
-
;
if
(
this
.
defaultIndex
>
this
.
logins
.
length
)
this
.
defaultIndex
-
-
;
if
(
removeFromDB
)
{
if
(
this
.
_messageManager
)
{
let
vanilla
=
LoginHelper
.
loginToVanillaObject
(
removedLogin
)
;
this
.
_messageManager
.
sendAsyncMessage
(
"
RemoteLogins
:
removeLogin
"
{
login
:
vanilla
}
)
;
}
else
{
Services
.
logins
.
removeLogin
(
removedLogin
)
;
}
}
}
}
;
var
LoginFormFactory
=
{
createFromForm
(
aForm
)
{
let
formLike
=
FormLikeFactory
.
createFromForm
(
aForm
)
;
formLike
.
action
=
LoginUtils
.
_getActionOrigin
(
aForm
)
;
let
state
=
LoginManagerContent
.
stateForDocument
(
formLike
.
ownerDocument
)
;
state
.
loginFormRootElements
.
add
(
formLike
.
rootElement
)
;
log
(
"
adding
"
formLike
.
rootElement
"
to
loginFormRootElements
for
"
formLike
.
ownerDocument
)
;
LoginManagerContent
.
_formLikeByRootElement
.
set
(
formLike
.
rootElement
formLike
)
;
return
formLike
;
}
createFromField
(
aField
)
{
if
(
!
(
aField
instanceof
Ci
.
nsIDOMHTMLInputElement
)
|
|
(
aField
.
type
!
=
"
password
"
&
&
!
LoginHelper
.
isUsernameFieldType
(
aField
)
)
|
|
!
aField
.
ownerDocument
)
{
throw
new
Error
(
"
createFromField
requires
a
password
or
username
field
in
a
document
"
)
;
}
if
(
aField
.
form
)
{
return
this
.
createFromForm
(
aField
.
form
)
;
}
let
formLike
=
FormLikeFactory
.
createFromField
(
aField
)
;
formLike
.
action
=
LoginUtils
.
_getPasswordOrigin
(
aField
.
ownerDocument
.
baseURI
)
;
log
(
"
Created
non
-
form
FormLike
for
rootElement
:
"
aField
.
ownerDocument
.
documentElement
)
;
let
state
=
LoginManagerContent
.
stateForDocument
(
formLike
.
ownerDocument
)
;
state
.
loginFormRootElements
.
add
(
formLike
.
rootElement
)
;
log
(
"
adding
"
formLike
.
rootElement
"
to
loginFormRootElements
for
"
formLike
.
ownerDocument
)
;
LoginManagerContent
.
_formLikeByRootElement
.
set
(
formLike
.
rootElement
formLike
)
;
return
formLike
;
}
}
;
