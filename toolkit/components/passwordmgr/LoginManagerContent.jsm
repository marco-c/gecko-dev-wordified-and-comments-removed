"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
LoginManagerContent
"
"
LoginFormFactory
"
"
UserAutoCompleteResult
"
]
;
const
PASSWORD_INPUT_ADDED_COALESCING_THRESHOLD_MS
=
1
;
const
AUTOCOMPLETE_AFTER_RIGHT_CLICK_THRESHOLD_MS
=
400
;
const
AUTOFILL_STATE
=
"
-
moz
-
autofill
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
PrivateBrowsingUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FormLikeFactory
"
"
resource
:
/
/
gre
/
modules
/
FormLikeFactory
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginRecipesContent
"
"
resource
:
/
/
gre
/
modules
/
LoginRecipes
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
InsecurePasswordUtils
"
"
resource
:
/
/
gre
/
modules
/
InsecurePasswordUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gNetUtil
"
"
mozilla
.
org
/
network
/
util
;
1
"
"
nsINetUtil
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
logger
=
LoginHelper
.
createLogger
(
"
LoginManagerContent
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
Services
.
cpmm
.
addMessageListener
(
"
clearRecipeCache
"
(
)
=
>
{
LoginRecipesContent
.
_clearRecipeCache
(
)
;
}
)
;
var
gLastRightClickTimeStamp
=
Number
.
NEGATIVE_INFINITY
;
var
observer
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsIFormSubmitObserver
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
notify
(
formElement
aWindow
actionURI
)
{
log
(
"
observer
notified
for
form
submission
.
"
)
;
try
{
let
formLike
=
LoginFormFactory
.
createFromForm
(
formElement
)
;
LoginManagerContent
.
_onFormSubmit
(
formLike
)
;
}
catch
(
e
)
{
log
(
"
Caught
error
in
onFormSubmit
(
"
e
.
lineNumber
"
)
:
"
e
.
message
)
;
Cu
.
reportError
(
e
)
;
}
return
true
;
}
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
if
(
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
|
|
!
(
aWebProgress
.
loadType
&
Ci
.
nsIDocShell
.
LOAD_CMD_PUSHSTATE
)
)
{
return
;
}
log
(
"
onLocationChange
handled
:
"
aLocation
.
displaySpec
aWebProgress
.
DOMWindow
.
document
)
;
LoginManagerContent
.
_onNavigation
(
aWebProgress
.
DOMWindow
.
document
)
;
}
onStateChange
(
aWebProgress
aRequest
aState
aStatus
)
{
if
(
!
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
)
{
return
;
}
let
channel
=
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
triggeringPrincipal
=
channel
.
loadInfo
.
triggeringPrincipal
;
if
(
triggeringPrincipal
.
isNullPrincipal
|
|
triggeringPrincipal
.
equals
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
)
{
return
;
}
if
(
!
(
aWebProgress
.
loadType
&
Ci
.
nsIDocShell
.
LOAD_CMD_NORMAL
)
)
{
log
(
"
onStateChange
:
loadType
isn
'
t
LOAD_CMD_NORMAL
:
"
aWebProgress
.
loadType
)
;
return
;
}
log
(
"
onStateChange
handled
:
"
channel
)
;
LoginManagerContent
.
_onNavigation
(
aWebProgress
.
DOMWindow
.
document
)
;
}
handleEvent
(
aEvent
)
{
if
(
!
aEvent
.
isTrusted
)
{
return
;
}
if
(
!
LoginHelper
.
enabled
)
{
return
;
}
switch
(
aEvent
.
type
)
{
case
"
focus
"
:
{
LoginManagerContent
.
_onUsernameFocus
(
aEvent
)
;
break
;
}
case
"
mousedown
"
:
{
if
(
aEvent
.
button
=
=
2
)
{
gLastRightClickTimeStamp
=
Date
.
now
(
)
;
}
break
;
}
default
:
{
throw
new
Error
(
"
Unexpected
event
"
)
;
}
}
}
}
;
Services
.
obs
.
addObserver
(
observer
"
earlyformsubmit
"
)
;
var
LoginManagerContent
=
{
__formFillService
:
null
get
_formFillService
(
)
{
if
(
!
this
.
__formFillService
)
{
this
.
__formFillService
=
Cc
[
"
mozilla
.
org
/
satchel
/
form
-
fill
-
controller
;
1
"
]
.
getService
(
Ci
.
nsIFormFillController
)
;
}
return
this
.
__formFillService
;
}
_getRandomId
(
)
{
return
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
}
_messages
:
[
"
RemoteLogins
:
loginsFound
"
"
RemoteLogins
:
loginsAutoCompleted
"
]
_formLikeByRootElement
:
new
WeakMap
(
)
_deferredPasswordAddedTasksByRootElement
:
new
WeakMap
(
)
_requests
:
new
Map
(
)
_managers
:
new
Map
(
)
_takeRequest
(
msg
)
{
let
data
=
msg
.
data
;
let
request
=
this
.
_requests
.
get
(
data
.
requestId
)
;
this
.
_requests
.
delete
(
data
.
requestId
)
;
let
count
=
this
.
_managers
.
get
(
msg
.
target
)
;
if
(
-
-
count
=
=
=
0
)
{
this
.
_managers
.
delete
(
msg
.
target
)
;
for
(
let
message
of
this
.
_messages
)
{
msg
.
target
.
removeMessageListener
(
message
this
)
;
}
}
else
{
this
.
_managers
.
set
(
msg
.
target
count
)
;
}
return
request
;
}
_sendRequest
(
messageManager
requestData
name
messageData
)
{
let
count
;
if
(
!
(
count
=
this
.
_managers
.
get
(
messageManager
)
)
)
{
this
.
_managers
.
set
(
messageManager
1
)
;
for
(
let
message
of
this
.
_messages
)
{
messageManager
.
addMessageListener
(
message
this
)
;
}
}
else
{
this
.
_managers
.
set
(
messageManager
+
+
count
)
;
}
let
requestId
=
this
.
_getRandomId
(
)
;
messageData
.
requestId
=
requestId
;
messageManager
.
sendAsyncMessage
(
name
messageData
)
;
let
deferred
=
PromiseUtils
.
defer
(
)
;
requestData
.
promise
=
deferred
;
this
.
_requests
.
set
(
requestId
requestData
)
;
return
deferred
.
promise
;
}
receiveMessage
(
msg
topWindow
)
{
if
(
msg
.
name
=
=
"
RemoteLogins
:
fillForm
"
)
{
this
.
fillForm
(
{
topDocument
:
topWindow
.
document
loginFormOrigin
:
msg
.
data
.
loginFormOrigin
loginsFound
:
LoginHelper
.
vanillaObjectsToLogins
(
msg
.
data
.
logins
)
recipes
:
msg
.
data
.
recipes
inputElement
:
msg
.
objects
.
inputElement
}
)
;
return
;
}
let
request
=
this
.
_takeRequest
(
msg
)
;
switch
(
msg
.
name
)
{
case
"
RemoteLogins
:
loginsFound
"
:
{
let
loginsFound
=
LoginHelper
.
vanillaObjectsToLogins
(
msg
.
data
.
logins
)
;
request
.
promise
.
resolve
(
{
form
:
request
.
form
loginsFound
recipes
:
msg
.
data
.
recipes
}
)
;
break
;
}
case
"
RemoteLogins
:
loginsAutoCompleted
"
:
{
let
loginsFound
=
LoginHelper
.
vanillaObjectsToLogins
(
msg
.
data
.
logins
)
;
let
messageManager
=
msg
.
target
;
request
.
promise
.
resolve
(
{
logins
:
loginsFound
messageManager
}
)
;
break
;
}
}
}
_getLoginDataFromParent
(
form
options
)
{
let
doc
=
form
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
if
(
!
formOrigin
)
{
return
Promise
.
reject
(
"
_getLoginDataFromParent
:
A
form
origin
is
required
"
)
;
}
let
actionOrigin
=
LoginHelper
.
getFormActionOrigin
(
form
)
;
let
messageManager
=
win
.
docShell
.
messageManager
;
let
requestData
=
{
form
}
;
let
messageData
=
{
formOrigin
actionOrigin
options
}
;
return
this
.
_sendRequest
(
messageManager
requestData
"
RemoteLogins
:
findLogins
"
messageData
)
;
}
_autoCompleteSearchAsync
(
aSearchString
aPreviousResult
aElement
aRect
)
{
let
doc
=
aElement
.
ownerDocument
;
let
form
=
LoginFormFactory
.
createFromField
(
aElement
)
;
let
win
=
doc
.
defaultView
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
let
actionOrigin
=
LoginHelper
.
getFormActionOrigin
(
form
)
;
let
messageManager
=
win
.
docShell
.
messageManager
;
let
previousResult
=
aPreviousResult
?
{
searchString
:
aPreviousResult
.
searchString
logins
:
LoginHelper
.
loginsToVanillaObjects
(
aPreviousResult
.
logins
)
}
:
null
;
let
requestData
=
{
}
;
let
messageData
=
{
formOrigin
actionOrigin
searchString
:
aSearchString
previousResult
rect
:
aRect
isSecure
:
InsecurePasswordUtils
.
isFormSecure
(
form
)
isPasswordField
:
aElement
.
type
=
=
"
password
"
}
;
return
this
.
_sendRequest
(
messageManager
requestData
"
RemoteLogins
:
autoCompleteLogins
"
messageData
)
;
}
setupEventListeners
(
global
)
{
global
.
addEventListener
(
"
pageshow
"
(
event
)
=
>
{
this
.
onPageShow
(
event
)
;
}
)
;
global
.
addEventListener
(
"
blur
"
(
event
)
=
>
{
this
.
onUsernameInput
(
event
)
;
}
)
;
}
setupProgressListener
(
window
)
{
if
(
!
LoginHelper
.
formlessCaptureEnabled
)
{
return
;
}
try
{
let
webProgress
=
window
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
observer
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
|
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
catch
(
ex
)
{
}
}
onDOMFormHasPassword
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
form
=
event
.
target
;
let
formLike
=
LoginFormFactory
.
createFromForm
(
form
)
;
log
(
"
onDOMFormHasPassword
:
"
form
formLike
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike
)
;
}
onDOMInputPasswordAdded
(
event
topWindow
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
pwField
=
event
.
originalTarget
;
if
(
pwField
.
form
)
{
return
;
}
this
.
setupProgressListener
(
topWindow
)
;
let
formLike
=
LoginFormFactory
.
createFromField
(
pwField
)
;
log
(
"
onDOMInputPasswordAdded
:
"
pwField
formLike
)
;
let
deferredTask
=
this
.
_deferredPasswordAddedTasksByRootElement
.
get
(
formLike
.
rootElement
)
;
if
(
!
deferredTask
)
{
log
(
"
Creating
a
DeferredTask
to
call
_fetchLoginsFromParentAndFillForm
soon
"
)
;
this
.
_formLikeByRootElement
.
set
(
formLike
.
rootElement
formLike
)
;
deferredTask
=
new
DeferredTask
(
(
)
=
>
{
let
formLike2
=
this
.
_formLikeByRootElement
.
get
(
formLike
.
rootElement
)
;
log
(
"
Running
deferred
processing
of
onDOMInputPasswordAdded
"
formLike2
)
;
this
.
_deferredPasswordAddedTasksByRootElement
.
delete
(
formLike2
.
rootElement
)
;
this
.
_fetchLoginsFromParentAndFillForm
(
formLike2
)
;
}
PASSWORD_INPUT_ADDED_COALESCING_THRESHOLD_MS
0
)
;
this
.
_deferredPasswordAddedTasksByRootElement
.
set
(
formLike
.
rootElement
deferredTask
)
;
}
let
window
=
pwField
.
ownerGlobal
;
if
(
deferredTask
.
isArmed
)
{
log
(
"
DeferredTask
is
already
armed
so
just
updating
the
FormLike
"
)
;
this
.
_formLikeByRootElement
.
set
(
formLike
.
rootElement
formLike
)
;
}
else
if
(
window
.
document
.
readyState
=
=
"
complete
"
)
{
log
(
"
Arming
the
DeferredTask
we
just
created
since
document
.
readyState
=
=
'
complete
'
"
)
;
deferredTask
.
arm
(
)
;
}
else
{
window
.
addEventListener
(
"
DOMContentLoaded
"
function
(
)
{
log
(
"
Arming
the
onDOMInputPasswordAdded
DeferredTask
due
to
DOMContentLoaded
"
)
;
deferredTask
.
arm
(
)
;
}
{
once
:
true
}
)
;
}
}
_fetchLoginsFromParentAndFillForm
(
form
)
{
let
window
=
form
.
ownerDocument
.
defaultView
;
this
.
_detectInsecureFormLikes
(
window
.
top
)
;
let
messageManager
=
window
.
docShell
.
messageManager
;
messageManager
.
sendAsyncMessage
(
"
LoginStats
:
LoginEncountered
"
)
;
if
(
!
LoginHelper
.
enabled
)
{
return
;
}
this
.
_getLoginDataFromParent
(
form
{
showMasterPassword
:
true
}
)
.
then
(
this
.
loginsFound
.
bind
(
this
)
)
.
catch
(
Cu
.
reportError
)
;
}
onPageShow
(
event
)
{
let
window
=
event
.
target
.
ownerGlobal
;
this
.
_detectInsecureFormLikes
(
window
)
;
}
loginFormStateByDocument
:
new
WeakMap
(
)
stateForDocument
(
document
)
{
let
loginFormState
=
this
.
loginFormStateByDocument
.
get
(
document
)
;
if
(
!
loginFormState
)
{
loginFormState
=
{
fillsByRootElement
:
new
WeakMap
(
)
loginFormRootElements
:
new
WeakSet
(
)
}
;
this
.
loginFormStateByDocument
.
set
(
document
loginFormState
)
;
}
return
loginFormState
;
}
_detectInsecureFormLikes
(
topWindow
)
{
log
(
"
_detectInsecureFormLikes
"
topWindow
.
location
.
href
)
;
let
hasInsecureLoginForms
=
(
thisWindow
)
=
>
{
let
doc
=
thisWindow
.
document
;
let
rootElsWeakSet
=
this
.
stateForDocument
(
doc
)
.
loginFormRootElements
;
let
hasLoginForm
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
rootElsWeakSet
)
.
filter
(
el
=
>
el
.
isConnected
)
.
length
>
0
;
return
(
hasLoginForm
&
&
!
thisWindow
.
isSecureContext
)
|
|
Array
.
some
(
thisWindow
.
frames
frame
=
>
hasInsecureLoginForms
(
frame
)
)
;
}
;
let
messageManager
=
topWindow
.
docShell
.
messageManager
;
messageManager
.
sendAsyncMessage
(
"
RemoteLogins
:
insecureLoginFormPresent
"
{
hasInsecureLoginForms
:
hasInsecureLoginForms
(
topWindow
)
}
)
;
}
fillForm
(
{
topDocument
loginFormOrigin
loginsFound
recipes
inputElement
}
)
{
if
(
!
inputElement
)
{
log
(
"
fillForm
:
No
input
element
specified
"
)
;
return
;
}
if
(
LoginHelper
.
getLoginOrigin
(
topDocument
.
documentURI
)
!
=
loginFormOrigin
)
{
if
(
!
inputElement
|
|
LoginHelper
.
getLoginOrigin
(
inputElement
.
ownerDocument
.
documentURI
)
!
=
loginFormOrigin
)
{
log
(
"
fillForm
:
The
requested
origin
doesn
'
t
match
the
one
from
the
"
"
document
.
This
may
mean
we
navigated
to
a
document
from
a
different
"
"
site
before
we
had
a
chance
to
indicate
this
change
in
the
user
"
"
interface
.
"
)
;
return
;
}
}
let
clobberUsername
=
true
;
let
form
=
LoginFormFactory
.
createFromField
(
inputElement
)
;
if
(
inputElement
.
type
=
=
"
password
"
)
{
clobberUsername
=
false
;
}
this
.
_fillForm
(
form
loginsFound
recipes
{
inputElement
autofillForm
:
true
clobberUsername
clobberPassword
:
true
userTriggered
:
true
}
)
;
}
loginsFound
(
{
form
loginsFound
recipes
}
)
{
let
doc
=
form
.
ownerDocument
;
let
autofillForm
=
LoginHelper
.
autofillForms
&
&
!
PrivateBrowsingUtils
.
isContentWindowPrivate
(
doc
.
defaultView
)
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
LoginRecipesContent
.
cacheRecipes
(
formOrigin
doc
.
defaultView
recipes
)
;
this
.
_fillForm
(
form
loginsFound
recipes
{
autofillForm
}
)
;
}
_onUsernameFocus
(
event
)
{
let
focusedField
=
event
.
target
;
if
(
!
focusedField
.
mozIsTextField
(
true
)
|
|
focusedField
.
readOnly
)
{
return
;
}
if
(
this
.
_isLoginAlreadyFilled
(
focusedField
)
)
{
log
(
"
_onUsernameFocus
:
Already
filled
"
)
;
return
;
}
let
timeDiff
=
Date
.
now
(
)
-
gLastRightClickTimeStamp
;
if
(
timeDiff
<
AUTOCOMPLETE_AFTER_RIGHT_CLICK_THRESHOLD_MS
)
{
log
(
"
Not
opening
autocomplete
after
focus
since
a
context
menu
was
opened
within
"
timeDiff
"
ms
"
)
;
return
;
}
log
(
"
maybeOpenAutocompleteAfterFocus
:
Opening
the
autocomplete
popup
"
)
;
this
.
_formFillService
.
showPopup
(
)
;
}
onDOMAutoComplete
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
if
(
!
LoginHelper
.
enabled
)
{
return
;
}
let
acInputField
=
event
.
target
;
if
(
ChromeUtils
.
getClassName
(
acInputField
.
ownerDocument
)
!
=
"
HTMLDocument
"
)
{
return
;
}
if
(
!
LoginFormFactory
.
createFromField
(
acInputField
)
)
{
return
;
}
if
(
LoginHelper
.
isUsernameFieldType
(
acInputField
)
)
{
this
.
onUsernameInput
(
event
)
;
}
}
onUsernameInput
(
event
)
{
let
acInputField
=
event
.
target
;
if
(
!
acInputField
.
value
)
{
return
;
}
log
(
"
onUsernameInput
from
"
event
.
type
)
;
let
acForm
=
LoginFormFactory
.
createFromField
(
acInputField
)
;
let
doc
=
acForm
.
ownerDocument
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
let
recipes
=
LoginRecipesContent
.
getRecipes
(
formOrigin
doc
.
defaultView
)
;
var
[
usernameField
passwordField
ignored
]
=
this
.
_getFormFields
(
acForm
false
recipes
)
;
if
(
usernameField
=
=
acInputField
&
&
passwordField
)
{
this
.
_getLoginDataFromParent
(
acForm
{
showMasterPassword
:
false
}
)
.
then
(
(
{
form
loginsFound
recipes
}
)
=
>
{
this
.
_fillForm
(
form
loginsFound
recipes
{
autofillForm
:
true
clobberPassword
:
true
userTriggered
:
true
}
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
else
{
}
}
_getPasswordFields
(
form
{
fieldOverrideRecipe
=
null
skipEmptyFields
=
false
}
=
{
}
)
{
let
pwFields
=
[
]
;
for
(
let
i
=
0
;
i
<
form
.
elements
.
length
;
i
+
+
)
{
let
element
=
form
.
elements
[
i
]
;
if
(
ChromeUtils
.
getClassName
(
element
)
!
=
=
"
HTMLInputElement
"
|
|
element
.
type
!
=
"
password
"
|
|
!
element
.
isConnected
)
{
continue
;
}
if
(
fieldOverrideRecipe
&
&
fieldOverrideRecipe
.
notPasswordSelector
&
&
element
.
matches
(
fieldOverrideRecipe
.
notPasswordSelector
)
)
{
log
(
"
skipping
password
field
(
id
/
name
is
"
element
.
id
"
/
"
element
.
name
+
"
)
due
to
recipe
:
"
fieldOverrideRecipe
)
;
continue
;
}
if
(
skipEmptyFields
&
&
!
element
.
value
.
trim
(
)
)
{
continue
;
}
pwFields
[
pwFields
.
length
]
=
{
index
:
i
element
}
;
}
if
(
pwFields
.
length
=
=
0
)
{
log
(
"
(
form
ignored
-
-
no
password
fields
.
)
"
)
;
return
null
;
}
else
if
(
pwFields
.
length
>
3
)
{
log
(
"
(
form
ignored
-
-
too
many
password
fields
.
[
got
"
pwFields
.
length
"
]
)
"
)
;
return
null
;
}
return
pwFields
;
}
_getFormFields
(
form
isSubmission
recipes
)
{
var
usernameField
=
null
;
var
pwFields
=
null
;
var
fieldOverrideRecipe
=
LoginRecipesContent
.
getFieldOverrides
(
recipes
form
)
;
if
(
fieldOverrideRecipe
)
{
var
pwOverrideField
=
LoginRecipesContent
.
queryLoginField
(
form
fieldOverrideRecipe
.
passwordSelector
)
;
if
(
pwOverrideField
)
{
let
formLike
=
LoginFormFactory
.
createFromField
(
pwOverrideField
)
;
pwFields
=
[
{
index
:
[
.
.
.
formLike
.
elements
]
.
indexOf
(
pwOverrideField
)
element
:
pwOverrideField
}
]
;
}
var
usernameOverrideField
=
LoginRecipesContent
.
queryLoginField
(
form
fieldOverrideRecipe
.
usernameSelector
)
;
if
(
usernameOverrideField
)
{
usernameField
=
usernameOverrideField
;
}
}
if
(
!
pwFields
)
{
pwFields
=
this
.
_getPasswordFields
(
form
{
fieldOverrideRecipe
skipEmptyFields
:
isSubmission
}
)
;
}
if
(
!
pwFields
)
{
return
[
null
null
null
]
;
}
if
(
!
usernameField
)
{
for
(
var
i
=
pwFields
[
0
]
.
index
-
1
;
i
>
=
0
;
i
-
-
)
{
var
element
=
form
.
elements
[
i
]
;
if
(
!
LoginHelper
.
isUsernameFieldType
(
element
)
)
{
continue
;
}
if
(
fieldOverrideRecipe
&
&
fieldOverrideRecipe
.
notUsernameSelector
&
&
element
.
matches
(
fieldOverrideRecipe
.
notUsernameSelector
)
)
{
continue
;
}
usernameField
=
element
;
break
;
}
}
if
(
!
usernameField
)
{
log
(
"
(
form
-
-
no
username
field
found
)
"
)
;
}
else
{
log
(
"
Username
field
"
usernameField
"
has
name
/
value
:
"
usernameField
.
name
"
/
"
usernameField
.
value
)
;
}
if
(
!
isSubmission
|
|
pwFields
.
length
=
=
1
)
{
var
passwordField
=
pwFields
[
0
]
.
element
;
log
(
"
Password
field
"
passwordField
"
has
name
:
"
passwordField
.
name
)
;
return
[
usernameField
passwordField
null
]
;
}
var
oldPasswordField
newPasswordField
;
var
pw1
=
pwFields
[
0
]
.
element
.
value
;
var
pw2
=
pwFields
[
1
]
.
element
.
value
;
var
pw3
=
(
pwFields
[
2
]
?
pwFields
[
2
]
.
element
.
value
:
null
)
;
if
(
pwFields
.
length
=
=
3
)
{
if
(
pw1
=
=
pw2
&
&
pw2
=
=
pw3
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
null
;
}
else
if
(
pw1
=
=
pw2
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
pwFields
[
2
]
.
element
;
}
else
if
(
pw2
=
=
pw3
)
{
oldPasswordField
=
pwFields
[
0
]
.
element
;
newPasswordField
=
pwFields
[
2
]
.
element
;
}
else
if
(
pw1
=
=
pw3
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
pwFields
[
1
]
.
element
;
}
else
{
log
(
"
(
form
ignored
-
-
all
3
pw
fields
differ
)
"
)
;
return
[
null
null
null
]
;
}
}
else
if
(
pw1
=
=
pw2
)
{
newPasswordField
=
pwFields
[
0
]
.
element
;
oldPasswordField
=
null
;
}
else
{
oldPasswordField
=
pwFields
[
0
]
.
element
;
newPasswordField
=
pwFields
[
1
]
.
element
;
}
log
(
"
Password
field
(
new
)
id
/
name
is
:
"
newPasswordField
.
id
"
/
"
newPasswordField
.
name
)
;
if
(
oldPasswordField
)
{
log
(
"
Password
field
(
old
)
id
/
name
is
:
"
oldPasswordField
.
id
"
/
"
oldPasswordField
.
name
)
;
}
else
{
log
(
"
Password
field
(
old
)
:
"
oldPasswordField
)
;
}
return
[
usernameField
newPasswordField
oldPasswordField
]
;
}
_isAutocompleteDisabled
(
element
)
{
return
element
&
&
element
.
autocomplete
=
=
"
off
"
;
}
_onNavigation
(
aDocument
)
{
let
state
=
this
.
stateForDocument
(
aDocument
)
;
let
rootElsWeakSet
=
state
.
loginFormRootElements
;
let
weakLoginFormRootElements
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
rootElsWeakSet
)
;
log
(
"
_onNavigation
:
state
:
"
state
"
loginFormRootElements
approx
size
:
"
weakLoginFormRootElements
.
length
"
document
:
"
aDocument
)
;
for
(
let
formRoot
of
weakLoginFormRootElements
)
{
if
(
!
formRoot
.
isConnected
)
{
continue
;
}
if
(
ChromeUtils
.
getClassName
(
formRoot
)
=
=
=
"
HTMLFormElement
"
)
{
log
(
"
Ignoring
navigation
for
the
form
root
to
avoid
multiple
prompts
"
+
"
since
it
was
for
a
real
<
form
>
"
)
;
continue
;
}
let
formLike
=
this
.
_formLikeByRootElement
.
get
(
formRoot
)
;
this
.
_onFormSubmit
(
formLike
)
;
}
}
_onFormSubmit
(
form
)
{
log
(
"
_onFormSubmit
"
form
)
;
var
doc
=
form
.
ownerDocument
;
var
win
=
doc
.
defaultView
;
if
(
PrivateBrowsingUtils
.
isContentWindowPrivate
(
win
)
&
&
!
LoginHelper
.
privateBrowsingCaptureEnabled
)
{
log
(
"
(
form
submission
ignored
in
private
browsing
mode
)
"
)
;
return
;
}
if
(
!
LoginHelper
.
enabled
)
{
return
;
}
var
hostname
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
if
(
!
hostname
)
{
log
(
"
(
form
submission
ignored
-
-
invalid
hostname
)
"
)
;
return
;
}
let
formSubmitURL
=
LoginHelper
.
getFormActionOrigin
(
form
)
;
let
messageManager
=
win
.
docShell
.
messageManager
;
let
recipes
=
LoginRecipesContent
.
getRecipes
(
hostname
win
)
;
var
[
usernameField
newPasswordField
oldPasswordField
]
=
this
.
_getFormFields
(
form
true
recipes
)
;
if
(
newPasswordField
=
=
null
)
{
return
;
}
if
(
(
this
.
_isAutocompleteDisabled
(
form
)
|
|
this
.
_isAutocompleteDisabled
(
usernameField
)
|
|
this
.
_isAutocompleteDisabled
(
newPasswordField
)
|
|
this
.
_isAutocompleteDisabled
(
oldPasswordField
)
)
&
&
!
LoginHelper
.
storeWhenAutocompleteOff
)
{
log
(
"
(
form
submission
ignored
-
-
autocomplete
=
off
found
)
"
)
;
return
;
}
let
mockUsername
=
usernameField
?
{
name
:
usernameField
.
name
value
:
usernameField
.
value
}
:
null
;
let
mockPassword
=
{
name
:
newPasswordField
.
name
value
:
newPasswordField
.
value
}
;
let
mockOldPassword
=
oldPasswordField
?
{
name
:
oldPasswordField
.
name
value
:
oldPasswordField
.
value
}
:
null
;
let
openerTopWindowID
=
null
;
if
(
win
.
opener
)
{
openerTopWindowID
=
win
.
opener
.
top
.
windowUtils
.
outerWindowID
;
}
messageManager
.
sendAsyncMessage
(
"
RemoteLogins
:
onFormSubmit
"
{
hostname
formSubmitURL
usernameField
:
mockUsername
newPasswordField
:
mockPassword
oldPasswordField
:
mockOldPassword
openerTopWindowID
}
)
;
}
_removeFillFieldHighlight
(
event
)
{
let
winUtils
=
event
.
target
.
ownerGlobal
.
windowUtils
;
winUtils
.
removeManuallyManagedState
(
event
.
target
AUTOFILL_STATE
)
;
}
_highlightFilledField
(
element
)
{
let
winUtils
=
element
.
ownerGlobal
.
windowUtils
;
winUtils
.
addManuallyManagedState
(
element
AUTOFILL_STATE
)
;
element
.
addEventListener
(
"
input
"
this
.
_removeFillFieldHighlight
{
mozSystemGroup
:
true
once
:
true
}
)
;
}
_fillForm
(
form
foundLogins
recipes
{
inputElement
=
null
autofillForm
=
false
clobberUsername
=
false
clobberPassword
=
false
userTriggered
=
false
}
=
{
}
)
{
if
(
ChromeUtils
.
getClassName
(
form
)
=
=
=
"
HTMLFormElement
"
)
{
throw
new
Error
(
"
_fillForm
should
only
be
called
with
FormLike
objects
"
)
;
}
log
(
"
_fillForm
"
form
.
elements
)
;
let
ignoreAutocomplete
=
true
;
let
autofillResult
=
-
1
;
const
AUTOFILL_RESULT
=
{
FILLED
:
0
NO_PASSWORD_FIELD
:
1
PASSWORD_DISABLED_READONLY
:
2
NO_LOGINS_FIT
:
3
NO_SAVED_LOGINS
:
4
EXISTING_PASSWORD
:
5
EXISTING_USERNAME
:
6
MULTIPLE_LOGINS
:
7
NO_AUTOFILL_FORMS
:
8
AUTOCOMPLETE_OFF
:
9
INSECURE
:
10
}
;
try
{
if
(
foundLogins
.
length
=
=
0
&
&
(
InsecurePasswordUtils
.
isFormSecure
(
form
)
|
|
!
LoginHelper
.
showInsecureFieldWarning
)
)
{
autofillResult
=
AUTOFILL_RESULT
.
NO_SAVED_LOGINS
;
return
;
}
var
[
usernameField
passwordField
ignored
]
=
this
.
_getFormFields
(
form
false
recipes
)
;
if
(
inputElement
)
{
if
(
inputElement
.
type
=
=
"
password
"
)
{
passwordField
=
inputElement
;
if
(
!
clobberUsername
)
{
usernameField
=
null
;
}
}
else
if
(
LoginHelper
.
isUsernameFieldType
(
inputElement
)
)
{
usernameField
=
inputElement
;
}
else
{
throw
new
Error
(
"
Unexpected
input
element
type
.
"
)
;
}
}
if
(
passwordField
=
=
null
)
{
log
(
"
not
filling
form
no
password
field
found
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
NO_PASSWORD_FIELD
;
return
;
}
if
(
passwordField
.
disabled
|
|
passwordField
.
readOnly
)
{
log
(
"
not
filling
form
password
field
disabled
or
read
-
only
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
PASSWORD_DISABLED_READONLY
;
return
;
}
if
(
usernameField
)
{
this
.
_formFillService
.
markAsLoginManagerField
(
usernameField
)
;
}
if
(
foundLogins
.
length
=
=
0
)
{
autofillResult
=
AUTOFILL_RESULT
.
NO_SAVED_LOGINS
;
return
;
}
if
(
!
userTriggered
&
&
!
LoginHelper
.
insecureAutofill
&
&
!
InsecurePasswordUtils
.
isFormSecure
(
form
)
)
{
log
(
"
not
filling
form
since
it
'
s
insecure
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
INSECURE
;
return
;
}
var
isAutocompleteOff
=
false
;
if
(
this
.
_isAutocompleteDisabled
(
form
)
|
|
this
.
_isAutocompleteDisabled
(
usernameField
)
|
|
this
.
_isAutocompleteDisabled
(
passwordField
)
)
{
isAutocompleteOff
=
true
;
}
var
maxUsernameLen
=
Number
.
MAX_VALUE
;
var
maxPasswordLen
=
Number
.
MAX_VALUE
;
if
(
usernameField
&
&
usernameField
.
maxLength
>
=
0
)
{
maxUsernameLen
=
usernameField
.
maxLength
;
}
if
(
passwordField
.
maxLength
>
=
0
)
{
maxPasswordLen
=
passwordField
.
maxLength
;
}
var
logins
=
foundLogins
.
filter
(
function
(
l
)
{
var
fit
=
(
l
.
username
.
length
<
=
maxUsernameLen
&
&
l
.
password
.
length
<
=
maxPasswordLen
)
;
if
(
!
fit
)
{
log
(
"
Ignored
"
l
.
username
"
login
:
won
'
t
fit
"
)
;
}
return
fit
;
}
this
)
;
if
(
logins
.
length
=
=
0
)
{
log
(
"
form
not
filled
none
of
the
logins
fit
in
the
field
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
NO_LOGINS_FIT
;
return
;
}
if
(
passwordField
.
value
&
&
!
clobberPassword
)
{
log
(
"
form
not
filled
the
password
field
was
already
filled
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
EXISTING_PASSWORD
;
return
;
}
var
selectedLogin
;
if
(
!
clobberUsername
&
&
usernameField
&
&
(
usernameField
.
value
|
|
usernameField
.
disabled
|
|
usernameField
.
readOnly
)
)
{
var
username
=
usernameField
.
value
.
toLowerCase
(
)
;
let
matchingLogins
=
logins
.
filter
(
l
=
>
l
.
username
.
toLowerCase
(
)
=
=
username
)
;
if
(
matchingLogins
.
length
=
=
0
)
{
log
(
"
Password
not
filled
.
None
of
the
stored
logins
match
the
username
already
present
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
EXISTING_USERNAME
;
return
;
}
for
(
let
l
of
matchingLogins
)
{
if
(
l
.
username
=
=
usernameField
.
value
)
{
selectedLogin
=
l
;
}
}
if
(
!
selectedLogin
)
{
selectedLogin
=
matchingLogins
[
0
]
;
}
}
else
if
(
logins
.
length
=
=
1
)
{
selectedLogin
=
logins
[
0
]
;
}
else
{
let
matchingLogins
;
if
(
usernameField
)
{
matchingLogins
=
logins
.
filter
(
l
=
>
l
.
username
)
;
}
else
{
matchingLogins
=
logins
.
filter
(
l
=
>
!
l
.
username
)
;
}
if
(
matchingLogins
.
length
!
=
1
)
{
log
(
"
Multiple
logins
for
form
so
not
filling
any
.
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
MULTIPLE_LOGINS
;
return
;
}
selectedLogin
=
matchingLogins
[
0
]
;
}
if
(
!
autofillForm
)
{
log
(
"
autofillForms
=
false
but
form
can
be
filled
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
NO_AUTOFILL_FORMS
;
return
;
}
if
(
isAutocompleteOff
&
&
!
ignoreAutocomplete
)
{
log
(
"
Not
filling
the
login
because
we
'
re
respecting
autocomplete
=
off
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
AUTOCOMPLETE_OFF
;
return
;
}
if
(
usernameField
)
{
let
disabledOrReadOnly
=
usernameField
.
disabled
|
|
usernameField
.
readOnly
;
let
userNameDiffers
=
selectedLogin
.
username
!
=
usernameField
.
value
;
let
userEnteredDifferentCase
=
userTriggered
&
&
userNameDiffers
&
&
usernameField
.
value
.
toLowerCase
(
)
=
=
selectedLogin
.
username
.
toLowerCase
(
)
;
if
(
!
disabledOrReadOnly
)
{
if
(
!
userEnteredDifferentCase
&
&
userNameDiffers
)
{
usernameField
.
setUserInput
(
selectedLogin
.
username
)
;
}
this
.
_highlightFilledField
(
usernameField
)
;
}
}
let
doc
=
form
.
ownerDocument
;
if
(
passwordField
.
value
!
=
selectedLogin
.
password
)
{
passwordField
.
setUserInput
(
selectedLogin
.
password
)
;
let
autoFilledLogin
=
{
guid
:
selectedLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
.
guid
username
:
selectedLogin
.
username
usernameField
:
usernameField
?
Cu
.
getWeakReference
(
usernameField
)
:
null
password
:
selectedLogin
.
password
passwordField
:
Cu
.
getWeakReference
(
passwordField
)
}
;
log
(
"
Saving
autoFilledLogin
"
autoFilledLogin
.
guid
"
for
"
form
.
rootElement
)
;
this
.
stateForDocument
(
doc
)
.
fillsByRootElement
.
set
(
form
.
rootElement
autoFilledLogin
)
;
}
this
.
_highlightFilledField
(
passwordField
)
;
log
(
"
_fillForm
succeeded
"
)
;
autofillResult
=
AUTOFILL_RESULT
.
FILLED
;
let
win
=
doc
.
defaultView
;
let
messageManager
=
win
.
docShell
.
messageManager
;
messageManager
.
sendAsyncMessage
(
"
LoginStats
:
LoginFillSuccessful
"
)
;
}
finally
{
if
(
autofillResult
=
=
-
1
)
{
throw
new
Error
(
"
_fillForm
:
autofillResult
must
be
specified
"
)
;
}
if
(
!
userTriggered
)
{
Services
.
telemetry
.
getHistogramById
(
"
PWMGR_FORM_AUTOFILL_RESULT
"
)
.
add
(
autofillResult
)
;
if
(
usernameField
)
{
let
focusedElement
=
this
.
_formFillService
.
focusedInput
;
if
(
usernameField
=
=
focusedElement
&
&
autofillResult
!
=
=
AUTOFILL_RESULT
.
FILLED
)
{
log
(
"
_fillForm
:
Opening
username
autocomplete
popup
since
the
form
wasn
'
t
autofilled
"
)
;
this
.
_formFillService
.
showPopup
(
)
;
}
}
}
if
(
usernameField
)
{
log
(
"
_fillForm
:
Attaching
event
listeners
to
usernameField
"
)
;
usernameField
.
addEventListener
(
"
focus
"
observer
)
;
usernameField
.
addEventListener
(
"
mousedown
"
observer
)
;
}
Services
.
obs
.
notifyObservers
(
form
.
rootElement
"
passwordmgr
-
processed
-
form
"
)
;
}
}
_isLoginAlreadyFilled
(
aUsernameField
)
{
let
formLikeRoot
=
FormLikeFactory
.
findRootForField
(
aUsernameField
)
;
let
existingFormLike
=
this
.
_formLikeByRootElement
.
get
(
formLikeRoot
)
;
if
(
!
existingFormLike
)
{
throw
new
Error
(
"
_isLoginAlreadyFilled
called
with
a
username
field
with
"
+
"
no
rootElement
FormLike
"
)
;
}
log
(
"
_isLoginAlreadyFilled
:
existingFormLike
"
existingFormLike
)
;
let
filledLogin
=
this
.
stateForDocument
(
aUsernameField
.
ownerDocument
)
.
fillsByRootElement
.
get
(
formLikeRoot
)
;
if
(
!
filledLogin
)
{
return
false
;
}
let
autoFilledUsernameField
=
filledLogin
.
usernameField
?
filledLogin
.
usernameField
.
get
(
)
:
null
;
let
autoFilledPasswordField
=
filledLogin
.
passwordField
.
get
(
)
;
if
(
!
autoFilledUsernameField
|
|
autoFilledUsernameField
!
=
aUsernameField
|
|
autoFilledUsernameField
.
value
!
=
filledLogin
.
username
|
|
!
autoFilledPasswordField
|
|
autoFilledPasswordField
.
value
!
=
filledLogin
.
password
)
{
return
false
;
}
return
true
;
}
getUserNameAndPasswordFields
(
aField
)
{
if
(
ChromeUtils
.
getClassName
(
aField
)
!
=
=
"
HTMLInputElement
"
|
|
(
aField
.
type
!
=
"
password
"
&
&
!
LoginHelper
.
isUsernameFieldType
(
aField
)
)
|
|
aField
.
nodePrincipal
.
isNullPrincipal
|
|
!
aField
.
ownerDocument
)
{
return
[
null
null
null
]
;
}
let
form
=
LoginFormFactory
.
createFromField
(
aField
)
;
let
doc
=
aField
.
ownerDocument
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
doc
.
documentURI
)
;
let
recipes
=
LoginRecipesContent
.
getRecipes
(
formOrigin
doc
.
defaultView
)
;
return
this
.
_getFormFields
(
form
false
recipes
)
;
}
getFieldContext
(
aField
)
{
if
(
ChromeUtils
.
getClassName
(
aField
)
!
=
=
"
HTMLInputElement
"
|
|
(
aField
.
type
!
=
"
password
"
&
&
!
LoginHelper
.
isUsernameFieldType
(
aField
)
)
|
|
aField
.
nodePrincipal
.
isNullPrincipal
|
|
!
aField
.
ownerDocument
)
{
return
null
;
}
let
[
usernameField
newPasswordField
]
=
this
.
getUserNameAndPasswordFields
(
aField
)
;
if
(
aField
.
type
!
=
"
password
"
)
{
usernameField
=
aField
;
}
return
{
usernameField
:
{
found
:
!
!
usernameField
disabled
:
usernameField
&
&
(
usernameField
.
disabled
|
|
usernameField
.
readOnly
)
}
passwordField
:
{
found
:
!
!
newPasswordField
disabled
:
newPasswordField
&
&
(
newPasswordField
.
disabled
|
|
newPasswordField
.
readOnly
)
}
}
;
}
}
;
function
UserAutoCompleteResult
(
aSearchString
matchingLogins
{
isSecure
messageManager
isPasswordField
}
)
{
function
loginSort
(
a
b
)
{
var
userA
=
a
.
username
.
toLowerCase
(
)
;
var
userB
=
b
.
username
.
toLowerCase
(
)
;
if
(
userA
<
userB
)
{
return
-
1
;
}
if
(
userA
>
userB
)
{
return
1
;
}
return
0
;
}
function
findDuplicates
(
loginList
)
{
let
seen
=
new
Set
(
)
;
let
duplicates
=
new
Set
(
)
;
for
(
let
login
of
loginList
)
{
if
(
seen
.
has
(
login
.
username
)
)
{
duplicates
.
add
(
login
.
username
)
;
}
seen
.
add
(
login
.
username
)
;
}
return
duplicates
;
}
this
.
_showInsecureFieldWarning
=
(
!
isSecure
&
&
LoginHelper
.
showInsecureFieldWarning
)
?
1
:
0
;
this
.
searchString
=
aSearchString
;
this
.
logins
=
matchingLogins
.
sort
(
loginSort
)
;
this
.
matchCount
=
matchingLogins
.
length
+
this
.
_showInsecureFieldWarning
;
this
.
_messageManager
=
messageManager
;
this
.
_stringBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
passwordmgr
/
locale
/
passwordmgr
.
properties
"
)
;
this
.
_dateAndTimeFormatter
=
new
Services
.
intl
.
DateTimeFormat
(
undefined
{
dateStyle
:
"
medium
"
}
)
;
this
.
_isPasswordField
=
isPasswordField
;
this
.
_duplicateUsernames
=
findDuplicates
(
matchingLogins
)
;
if
(
this
.
matchCount
>
0
)
{
this
.
searchResult
=
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
;
this
.
defaultIndex
=
0
;
}
}
UserAutoCompleteResult
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAutoCompleteResult
Ci
.
nsISupportsWeakReference
]
)
logins
:
null
get
wrappedJSObject
(
)
{
return
this
;
}
searchString
:
null
searchResult
:
Ci
.
nsIAutoCompleteResult
.
RESULT_NOMATCH
defaultIndex
:
-
1
errorDescription
:
"
"
matchCount
:
0
getValueAt
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
matchCount
)
{
throw
new
Error
(
"
Index
out
of
range
.
"
)
;
}
if
(
this
.
_showInsecureFieldWarning
&
&
index
=
=
=
0
)
{
return
"
"
;
}
let
selectedLogin
=
this
.
logins
[
index
-
this
.
_showInsecureFieldWarning
]
;
return
this
.
_isPasswordField
?
selectedLogin
.
password
:
selectedLogin
.
username
;
}
getLabelAt
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
matchCount
)
{
throw
new
Error
(
"
Index
out
of
range
.
"
)
;
}
let
getLocalizedString
=
(
key
formatArgs
=
null
)
=
>
{
if
(
formatArgs
)
{
return
this
.
_stringBundle
.
formatStringFromName
(
key
formatArgs
formatArgs
.
length
)
;
}
return
this
.
_stringBundle
.
GetStringFromName
(
key
)
;
}
;
if
(
this
.
_showInsecureFieldWarning
&
&
index
=
=
=
0
)
{
let
learnMoreString
=
getLocalizedString
(
"
insecureFieldWarningLearnMore
"
)
;
return
getLocalizedString
(
"
insecureFieldWarningDescription2
"
[
learnMoreString
]
)
;
}
let
login
=
this
.
logins
[
index
-
this
.
_showInsecureFieldWarning
]
;
let
username
=
login
.
username
;
if
(
!
username
|
|
this
.
_duplicateUsernames
.
has
(
username
)
)
{
if
(
!
username
)
{
username
=
getLocalizedString
(
"
noUsername
"
)
;
}
let
meta
=
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
let
time
=
this
.
_dateAndTimeFormatter
.
format
(
new
Date
(
meta
.
timePasswordChanged
)
)
;
username
=
getLocalizedString
(
"
loginHostAge
"
[
username
time
]
)
;
}
return
username
;
}
getCommentAt
(
index
)
{
return
"
"
;
}
getStyleAt
(
index
)
{
if
(
index
=
=
0
&
&
this
.
_showInsecureFieldWarning
)
{
return
"
insecureWarning
"
;
}
return
"
login
"
;
}
getImageAt
(
index
)
{
return
"
"
;
}
getFinalCompleteValueAt
(
index
)
{
return
this
.
getValueAt
(
index
)
;
}
removeValueAt
(
index
removeFromDB
)
{
if
(
index
<
0
|
|
index
>
=
this
.
matchCount
)
{
throw
new
Error
(
"
Index
out
of
range
.
"
)
;
}
if
(
this
.
_showInsecureFieldWarning
&
&
index
=
=
=
0
)
{
return
;
}
if
(
this
.
_showInsecureFieldWarning
)
{
index
-
-
;
}
var
[
removedLogin
]
=
this
.
logins
.
splice
(
index
1
)
;
this
.
matchCount
-
-
;
if
(
this
.
defaultIndex
>
this
.
logins
.
length
)
{
this
.
defaultIndex
-
-
;
}
if
(
removeFromDB
)
{
if
(
this
.
_messageManager
)
{
let
vanilla
=
LoginHelper
.
loginToVanillaObject
(
removedLogin
)
;
this
.
_messageManager
.
sendAsyncMessage
(
"
RemoteLogins
:
removeLogin
"
{
login
:
vanilla
}
)
;
}
else
{
Services
.
logins
.
removeLogin
(
removedLogin
)
;
}
}
}
}
;
var
LoginFormFactory
=
{
createFromForm
(
aForm
)
{
let
formLike
=
FormLikeFactory
.
createFromForm
(
aForm
)
;
formLike
.
action
=
LoginHelper
.
getFormActionOrigin
(
aForm
)
;
let
state
=
LoginManagerContent
.
stateForDocument
(
formLike
.
ownerDocument
)
;
state
.
loginFormRootElements
.
add
(
formLike
.
rootElement
)
;
log
(
"
adding
"
formLike
.
rootElement
"
to
loginFormRootElements
for
"
formLike
.
ownerDocument
)
;
LoginManagerContent
.
_formLikeByRootElement
.
set
(
formLike
.
rootElement
formLike
)
;
return
formLike
;
}
createFromField
(
aField
)
{
if
(
ChromeUtils
.
getClassName
(
aField
)
!
=
=
"
HTMLInputElement
"
|
|
(
aField
.
type
!
=
"
password
"
&
&
!
LoginHelper
.
isUsernameFieldType
(
aField
)
)
|
|
!
aField
.
ownerDocument
)
{
throw
new
Error
(
"
createFromField
requires
a
password
or
username
field
in
a
document
"
)
;
}
if
(
aField
.
form
)
{
return
this
.
createFromForm
(
aField
.
form
)
;
}
let
formLike
=
FormLikeFactory
.
createFromField
(
aField
)
;
formLike
.
action
=
LoginHelper
.
getLoginOrigin
(
aField
.
ownerDocument
.
baseURI
)
;
log
(
"
Created
non
-
form
FormLike
for
rootElement
:
"
aField
.
ownerDocument
.
documentElement
)
;
let
state
=
LoginManagerContent
.
stateForDocument
(
formLike
.
ownerDocument
)
;
state
.
loginFormRootElements
.
add
(
formLike
.
rootElement
)
;
log
(
"
adding
"
formLike
.
rootElement
"
to
loginFormRootElements
for
"
formLike
.
ownerDocument
)
;
LoginManagerContent
.
_formLikeByRootElement
.
set
(
formLike
.
rootElement
formLike
)
;
return
formLike
;
}
}
;
