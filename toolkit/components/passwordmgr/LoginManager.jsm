"
use
strict
"
;
const
PERMISSION_SAVE_LOGINS
=
"
login
-
saving
"
;
const
MAX_DATE_MS
=
8640000000000000
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginFormFactory
"
"
resource
:
/
/
gre
/
modules
/
LoginFormFactory
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
InsecurePasswordUtils
"
"
resource
:
/
/
gre
/
modules
/
InsecurePasswordUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
logger
=
LoginHelper
.
createLogger
(
"
LoginManager
"
)
;
return
logger
;
}
)
;
const
MS_PER_DAY
=
24
*
60
*
60
*
1000
;
if
(
Services
.
appinfo
.
processType
!
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
LoginManager
.
jsm
should
only
run
in
the
parent
process
"
)
;
}
function
LoginManager
(
)
{
this
.
init
(
)
;
}
LoginManager
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
cb9e0de8
-
3598
-
4ed7
-
857b
-
827f011ad5d8
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsILoginManager
"
"
nsISupportsWeakReference
"
"
nsIInterfaceRequestor
"
]
)
getInterface
(
aIID
)
{
if
(
aIID
.
equals
(
Ci
.
mozIStorageConnection
)
&
&
this
.
_storage
)
{
let
ir
=
this
.
_storage
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
return
ir
.
getInterface
(
aIID
)
;
}
if
(
aIID
.
equals
(
Ci
.
nsIVariant
)
)
{
return
this
;
}
throw
new
Components
.
Exception
(
"
Interface
not
available
"
Cr
.
NS_ERROR_NO_INTERFACE
)
;
}
_storage
:
null
init
(
)
{
this
.
_observer
.
_pwmgr
=
this
;
Services
.
obs
.
addObserver
(
this
.
_observer
"
xpcom
-
shutdown
"
)
;
Services
.
obs
.
addObserver
(
this
.
_observer
"
passwordmgr
-
storage
-
replace
"
)
;
this
.
_initStorage
(
)
;
Services
.
obs
.
addObserver
(
this
.
_observer
"
gather
-
telemetry
"
)
;
}
_initStorage
(
)
{
this
.
_storage
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
storage
/
default
;
1
"
]
.
createInstance
(
Ci
.
nsILoginManagerStorage
)
;
this
.
initializationPromise
=
this
.
_storage
.
initialize
(
)
;
this
.
initializationPromise
.
then
(
(
)
=
>
{
log
.
debug
(
"
initializationPromise
is
resolved
updating
isMasterPasswordSet
in
sharedData
"
)
;
Services
.
ppmm
.
sharedData
.
set
(
"
isMasterPasswordSet
"
LoginHelper
.
isMasterPasswordSet
(
)
)
;
}
)
;
}
_observer
:
{
_pwmgr
:
null
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
xpcom
-
shutdown
"
)
{
delete
this
.
_pwmgr
.
_storage
;
this
.
_pwmgr
=
null
;
}
else
if
(
topic
=
=
"
passwordmgr
-
storage
-
replace
"
)
{
(
async
(
)
=
>
{
await
this
.
_pwmgr
.
_storage
.
terminate
(
)
;
this
.
_pwmgr
.
_initStorage
(
)
;
await
this
.
_pwmgr
.
initializationPromise
;
Services
.
obs
.
notifyObservers
(
null
"
passwordmgr
-
storage
-
replace
-
complete
"
)
;
}
)
(
)
;
}
else
if
(
topic
=
=
"
gather
-
telemetry
"
)
{
this
.
_pwmgr
.
_gatherTelemetry
(
data
?
parseInt
(
data
)
:
new
Date
(
)
.
getTime
(
)
)
;
}
else
{
log
.
debug
(
"
Oops
!
Unexpected
notification
:
"
topic
)
;
}
}
}
async
_gatherTelemetry
(
referenceTimeMs
)
{
function
clearAndGetHistogram
(
histogramId
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramId
)
;
histogram
.
clear
(
)
;
return
histogram
;
}
clearAndGetHistogram
(
"
PWMGR_BLOCKLIST_NUM_SITES
"
)
.
add
(
this
.
getAllDisabledHosts
(
)
.
length
)
;
clearAndGetHistogram
(
"
PWMGR_NUM_SAVED_PASSWORDS
"
)
.
add
(
this
.
countLogins
(
"
"
"
"
"
"
)
)
;
clearAndGetHistogram
(
"
PWMGR_NUM_HTTPAUTH_PASSWORDS
"
)
.
add
(
this
.
countLogins
(
"
"
null
"
"
)
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
"
PWMGR_BLOCKLIST_NUM_SITES
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
"
PWMGR_NUM_SAVED_PASSWORDS
"
)
;
clearAndGetHistogram
(
"
PWMGR_SAVING_ENABLED
"
)
.
add
(
LoginHelper
.
enabled
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
"
PWMGR_SAVING_ENABLED
"
)
;
if
(
!
this
.
isLoggedIn
)
{
return
;
}
let
logins
=
await
this
.
getAllLoginsAsync
(
)
;
let
usernamePresentHistogram
=
clearAndGetHistogram
(
"
PWMGR_USERNAME_PRESENT
"
)
;
let
loginLastUsedDaysHistogram
=
clearAndGetHistogram
(
"
PWMGR_LOGIN_LAST_USED_DAYS
"
)
;
let
originCount
=
new
Map
(
)
;
for
(
let
login
of
logins
)
{
usernamePresentHistogram
.
add
(
!
!
login
.
username
)
;
let
origin
=
login
.
origin
;
originCount
.
set
(
origin
(
originCount
.
get
(
origin
)
|
|
0
)
+
1
)
;
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
let
timeLastUsedAgeMs
=
referenceTimeMs
-
login
.
timeLastUsed
;
if
(
timeLastUsedAgeMs
>
0
)
{
loginLastUsedDaysHistogram
.
add
(
Math
.
floor
(
timeLastUsedAgeMs
/
MS_PER_DAY
)
)
;
}
}
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
"
PWMGR_LOGIN_LAST_USED_DAYS
"
)
;
let
passwordsCountHistogram
=
clearAndGetHistogram
(
"
PWMGR_NUM_PASSWORDS_PER_HOSTNAME
"
)
;
for
(
let
count
of
originCount
.
values
(
)
)
{
passwordsCountHistogram
.
add
(
count
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
"
PWMGR_NUM_PASSWORDS_PER_HOSTNAME
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
passwordmgr
-
gather
-
telemetry
-
complete
"
)
;
}
_checkLogin
(
login
)
{
if
(
login
.
origin
=
=
null
|
|
!
login
.
origin
.
length
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
a
null
or
empty
origin
.
"
)
;
}
if
(
login
.
username
=
=
null
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
a
null
username
.
"
)
;
}
if
(
login
.
password
=
=
null
|
|
!
login
.
password
.
length
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
a
null
or
empty
password
.
"
)
;
}
if
(
login
.
formActionOrigin
|
|
login
.
formActionOrigin
=
=
"
"
)
{
if
(
login
.
httpRealm
!
=
null
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
both
a
httpRealm
and
formActionOrigin
.
"
)
;
}
}
else
if
(
login
.
httpRealm
)
{
if
(
login
.
formActionOrigin
!
=
null
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
both
a
httpRealm
and
formActionOrigin
.
"
)
;
}
}
else
{
throw
new
Error
(
"
Can
'
t
add
a
login
without
a
httpRealm
or
formActionOrigin
.
"
)
;
}
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
for
(
let
pname
of
[
"
timeCreated
"
"
timeLastUsed
"
"
timePasswordChanged
"
]
)
{
if
(
login
[
pname
]
>
MAX_DATE_MS
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
invalid
date
properties
.
"
)
;
}
}
}
initializationPromise
:
null
addLogin
(
login
)
{
this
.
_checkLogin
(
login
)
;
let
logins
=
this
.
findLogins
(
login
.
origin
login
.
formActionOrigin
login
.
httpRealm
)
;
let
matchingLogin
=
logins
.
find
(
l
=
>
login
.
matches
(
l
true
)
)
;
if
(
matchingLogin
)
{
throw
LoginHelper
.
createLoginAlreadyExistsError
(
matchingLogin
.
guid
)
;
}
log
.
debug
(
"
Adding
login
"
)
;
return
this
.
_storage
.
addLogin
(
login
)
;
}
async
addLogins
(
logins
)
{
let
crypto
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
crypto
/
SDR
;
1
"
]
.
getService
(
Ci
.
nsILoginManagerCrypto
)
;
let
plaintexts
=
logins
.
map
(
l
=
>
l
.
username
)
.
concat
(
logins
.
map
(
l
=
>
l
.
password
)
)
;
let
ciphertexts
=
await
crypto
.
encryptMany
(
plaintexts
)
;
let
usernames
=
ciphertexts
.
slice
(
0
logins
.
length
)
;
let
passwords
=
ciphertexts
.
slice
(
logins
.
length
)
;
let
resultLogins
=
[
]
;
for
(
let
i
=
0
;
i
<
logins
.
length
;
i
+
+
)
{
try
{
this
.
_checkLogin
(
logins
[
i
]
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
continue
;
}
let
plaintextUsername
=
logins
[
i
]
.
username
;
let
plaintextPassword
=
logins
[
i
]
.
password
;
logins
[
i
]
.
username
=
usernames
[
i
]
;
logins
[
i
]
.
password
=
passwords
[
i
]
;
log
.
debug
(
"
Adding
login
"
)
;
let
resultLogin
=
this
.
_storage
.
addLogin
(
logins
[
i
]
true
plaintextUsername
plaintextPassword
)
;
logins
[
i
]
.
username
=
plaintextUsername
;
logins
[
i
]
.
password
=
plaintextPassword
;
resultLogin
.
username
=
plaintextUsername
;
resultLogin
.
password
=
plaintextPassword
;
resultLogins
.
push
(
resultLogin
)
;
}
return
resultLogins
;
}
removeLogin
(
login
)
{
log
.
debug
(
"
Removing
login
"
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
.
guid
)
;
return
this
.
_storage
.
removeLogin
(
login
)
;
}
modifyLogin
(
oldLogin
newLogin
)
{
log
.
debug
(
"
Modifying
login
"
oldLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
.
guid
)
;
return
this
.
_storage
.
modifyLogin
(
oldLogin
newLogin
)
;
}
recordPasswordUse
(
login
privateContextWithoutExplicitConsent
loginType
filled
)
{
log
.
debug
(
"
Recording
password
use
"
loginType
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
.
guid
)
;
if
(
!
privateContextWithoutExplicitConsent
)
{
this
.
_storage
.
recordPasswordUse
(
login
)
;
}
Services
.
telemetry
.
recordEvent
(
"
pwmgr
"
"
saved_login_used
"
loginType
null
{
filled
:
"
"
+
filled
}
)
;
}
getAllLogins
(
)
{
log
.
debug
(
"
Getting
a
list
of
all
logins
"
)
;
return
this
.
_storage
.
getAllLogins
(
)
;
}
async
getAllLoginsAsync
(
)
{
log
.
debug
(
"
Getting
a
list
of
all
logins
asynchronously
"
)
;
return
this
.
_storage
.
getAllLoginsAsync
(
)
;
}
removeAllUserFacingLogins
(
)
{
log
.
debug
(
"
Removing
all
user
facing
logins
"
)
;
this
.
_storage
.
removeAllUserFacingLogins
(
)
;
}
removeAllLogins
(
)
{
log
.
debug
(
"
Removing
all
logins
from
local
store
including
FxA
key
"
)
;
this
.
_storage
.
removeAllLogins
(
)
;
}
getAllDisabledHosts
(
)
{
log
.
debug
(
"
Getting
a
list
of
all
disabled
origins
"
)
;
let
disabledHosts
=
[
]
;
for
(
let
perm
of
Services
.
perms
.
all
)
{
if
(
perm
.
type
=
=
PERMISSION_SAVE_LOGINS
&
&
perm
.
capability
=
=
Services
.
perms
.
DENY_ACTION
)
{
disabledHosts
.
push
(
perm
.
principal
.
URI
.
displayPrePath
)
;
}
}
log
.
debug
(
"
getAllDisabledHosts
:
returning
"
disabledHosts
.
length
"
disabled
hosts
.
"
)
;
return
disabledHosts
;
}
findLogins
(
origin
formActionOrigin
httpRealm
)
{
log
.
debug
(
"
Searching
for
logins
matching
origin
:
"
origin
"
formActionOrigin
:
"
formActionOrigin
"
httpRealm
:
"
httpRealm
)
;
return
this
.
_storage
.
findLogins
(
origin
formActionOrigin
httpRealm
)
;
}
async
searchLoginsAsync
(
matchData
)
{
log
.
debug
(
"
searchLoginsAsync
:
"
matchData
)
;
if
(
!
matchData
.
origin
)
{
throw
new
Error
(
"
searchLoginsAsync
:
An
origin
is
required
"
)
;
}
return
this
.
_storage
.
searchLoginsAsync
(
matchData
)
;
}
searchLogins
(
matchData
)
{
log
.
debug
(
"
Searching
for
logins
"
)
;
matchData
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
if
(
!
matchData
.
hasKey
(
"
guid
"
)
)
{
if
(
!
matchData
.
hasKey
(
"
origin
"
)
)
{
log
.
warn
(
"
searchLogins
:
An
origin
is
recommended
"
)
;
}
}
return
this
.
_storage
.
searchLogins
(
matchData
)
;
}
countLogins
(
origin
formActionOrigin
httpRealm
)
{
log
.
debug
(
"
Counting
logins
matching
origin
:
"
origin
"
formActionOrigin
:
"
formActionOrigin
"
httpRealm
:
"
httpRealm
)
;
return
this
.
_storage
.
countLogins
(
origin
formActionOrigin
httpRealm
)
;
}
async
getSyncID
(
)
{
return
this
.
_storage
.
getSyncID
(
)
;
}
async
setSyncID
(
id
)
{
await
this
.
_storage
.
setSyncID
(
id
)
;
}
async
getLastSync
(
)
{
return
this
.
_storage
.
getLastSync
(
)
;
}
async
setLastSync
(
timestamp
)
{
await
this
.
_storage
.
setLastSync
(
timestamp
)
;
}
get
uiBusy
(
)
{
return
this
.
_storage
.
uiBusy
;
}
get
isLoggedIn
(
)
{
return
this
.
_storage
.
isLoggedIn
;
}
getLoginSavingEnabled
(
origin
)
{
log
.
debug
(
"
Checking
if
logins
to
"
origin
"
can
be
saved
.
"
)
;
if
(
!
LoginHelper
.
enabled
)
{
return
false
;
}
let
uri
=
Services
.
io
.
newURI
(
origin
)
;
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
uri
{
}
)
;
return
(
Services
.
perms
.
testPermissionFromPrincipal
(
principal
PERMISSION_SAVE_LOGINS
)
!
=
Services
.
perms
.
DENY_ACTION
)
;
}
setLoginSavingEnabled
(
origin
enabled
)
{
LoginHelper
.
checkOriginValue
(
origin
)
;
let
uri
=
Services
.
io
.
newURI
(
origin
)
;
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
uri
{
}
)
;
if
(
enabled
)
{
Services
.
perms
.
removeFromPrincipal
(
principal
PERMISSION_SAVE_LOGINS
)
;
}
else
{
Services
.
perms
.
addFromPrincipal
(
principal
PERMISSION_SAVE_LOGINS
Services
.
perms
.
DENY_ACTION
)
;
}
log
.
debug
(
"
Login
saving
for
"
origin
"
now
enabled
?
"
enabled
)
;
LoginHelper
.
notifyStorageChanged
(
enabled
?
"
hostSavingEnabled
"
:
"
hostSavingDisabled
"
origin
)
;
}
}
;
const
EXPORTED_SYMBOLS
=
[
"
LoginManager
"
]
;
