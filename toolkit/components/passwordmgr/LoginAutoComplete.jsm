"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
LoginAutoComplete
"
"
LoginAutoCompleteResult
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AutoCompleteChild
"
"
resource
:
/
/
gre
/
actors
/
AutoCompleteChild
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserUtils
"
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
InsecurePasswordUtils
"
"
resource
:
/
/
gre
/
modules
/
InsecurePasswordUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginFormFactory
"
"
resource
:
/
/
gre
/
modules
/
LoginFormFactory
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginManagerChild
"
"
resource
:
/
/
gre
/
modules
/
LoginManagerChild
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NewPasswordModel
"
"
resource
:
/
/
gre
/
modules
/
NewPasswordModel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
formFillController
"
"
mozilla
.
org
/
satchel
/
form
-
fill
-
controller
;
1
"
Ci
.
nsIFormFillController
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
SHOULD_SHOW_ORIGIN
"
"
signon
.
showAutoCompleteOrigins
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
return
LoginHelper
.
createLogger
(
"
LoginAutoComplete
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
passwordMgrBundle
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
passwordmgr
/
locale
/
passwordmgr
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
dateAndTimeFormatter
"
(
)
=
>
{
return
new
Services
.
intl
.
DateTimeFormat
(
undefined
{
dateStyle
:
"
medium
"
}
)
;
}
)
;
function
loginSort
(
formHostPort
a
b
)
{
let
maybeHostPortA
=
LoginHelper
.
maybeGetHostPortForURL
(
a
.
origin
)
;
let
maybeHostPortB
=
LoginHelper
.
maybeGetHostPortForURL
(
b
.
origin
)
;
if
(
formHostPort
=
=
maybeHostPortA
&
&
formHostPort
!
=
maybeHostPortB
)
{
return
-
1
;
}
if
(
formHostPort
!
=
maybeHostPortA
&
&
formHostPort
=
=
maybeHostPortB
)
{
return
1
;
}
if
(
a
.
httpRealm
!
=
=
b
.
httpRealm
)
{
if
(
b
.
httpRealm
=
=
=
null
)
{
return
1
;
}
if
(
a
.
httpRealm
=
=
=
null
)
{
return
-
1
;
}
}
let
userA
=
a
.
username
.
toLowerCase
(
)
;
let
userB
=
b
.
username
.
toLowerCase
(
)
;
if
(
userA
<
userB
)
{
return
-
1
;
}
if
(
userA
>
userB
)
{
return
1
;
}
return
0
;
}
function
findDuplicates
(
loginList
)
{
let
seen
=
new
Set
(
)
;
let
duplicates
=
new
Set
(
)
;
for
(
let
login
of
loginList
)
{
if
(
seen
.
has
(
login
.
username
)
)
{
duplicates
.
add
(
login
.
username
)
;
}
seen
.
add
(
login
.
username
)
;
}
return
duplicates
;
}
function
getLocalizedString
(
key
formatArgs
=
null
)
{
if
(
formatArgs
)
{
return
passwordMgrBundle
.
formatStringFromName
(
key
formatArgs
)
;
}
return
passwordMgrBundle
.
GetStringFromName
(
key
)
;
}
class
AutocompleteItem
{
constructor
(
style
)
{
this
.
comment
=
"
"
;
this
.
style
=
style
;
this
.
value
=
"
"
;
}
removeFromStorage
(
)
{
}
}
class
InsecureLoginFormAutocompleteItem
extends
AutocompleteItem
{
constructor
(
)
{
super
(
"
insecureWarning
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
label
"
(
)
=
>
{
let
learnMoreString
=
getLocalizedString
(
"
insecureFieldWarningLearnMore
"
)
;
return
getLocalizedString
(
"
insecureFieldWarningDescription2
"
[
learnMoreString
]
)
;
}
)
;
}
}
class
LoginAutocompleteItem
extends
AutocompleteItem
{
constructor
(
login
hasBeenTypePassword
duplicateUsernames
actor
isOriginMatched
)
{
super
(
SHOULD_SHOW_ORIGIN
?
"
loginWithOrigin
"
:
"
login
"
)
;
this
.
_login
=
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
this
.
_actor
=
actor
;
this
.
_isDuplicateUsername
=
login
.
username
&
&
duplicateUsernames
.
has
(
login
.
username
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
label
"
(
)
=
>
{
let
username
=
login
.
username
;
if
(
!
username
|
|
this
.
_isDuplicateUsername
)
{
if
(
!
username
)
{
username
=
getLocalizedString
(
"
noUsername
"
)
;
}
let
time
=
dateAndTimeFormatter
.
format
(
new
Date
(
login
.
timePasswordChanged
)
)
;
username
=
getLocalizedString
(
"
loginHostAge
"
[
username
time
]
)
;
}
return
username
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
value
"
(
)
=
>
{
return
hasBeenTypePassword
?
login
.
password
:
login
.
username
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
comment
"
(
)
=
>
{
return
JSON
.
stringify
(
{
guid
:
login
.
guid
login
isDuplicateUsername
:
this
.
_isDuplicateUsername
isOriginMatched
comment
:
isOriginMatched
&
&
login
.
httpRealm
=
=
=
null
?
getLocalizedString
(
"
displaySameOrigin
"
)
:
login
.
displayOrigin
}
)
;
}
)
;
}
removeFromStorage
(
)
{
if
(
this
.
_actor
)
{
let
vanilla
=
LoginHelper
.
loginToVanillaObject
(
this
.
_login
)
;
this
.
_actor
.
sendAsyncMessage
(
"
PasswordManager
:
removeLogin
"
{
login
:
vanilla
}
)
;
}
else
{
Services
.
logins
.
removeLogin
(
this
.
_login
)
;
}
}
}
class
GeneratedPasswordAutocompleteItem
extends
AutocompleteItem
{
constructor
(
generatedPassword
willAutoSaveGeneratedPassword
)
{
super
(
"
generatedPassword
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
comment
"
(
)
=
>
{
return
JSON
.
stringify
(
{
generatedPassword
willAutoSaveGeneratedPassword
}
)
;
}
)
;
this
.
value
=
generatedPassword
;
XPCOMUtils
.
defineLazyGetter
(
this
"
label
"
(
)
=
>
{
return
getLocalizedString
(
"
useASecurelyGeneratedPassword
"
)
;
}
)
;
}
}
class
ImportableLearnMoreAutocompleteItem
extends
AutocompleteItem
{
constructor
(
)
{
super
(
"
importableLearnMore
"
)
;
}
}
class
ImportableLoginsAutocompleteItem
extends
AutocompleteItem
{
constructor
(
browserId
hostname
actor
)
{
super
(
"
importableLogins
"
)
;
this
.
label
=
browserId
;
this
.
comment
=
hostname
;
this
.
_actor
=
actor
;
this
.
_actor
.
sendAsyncMessage
(
"
PasswordManager
:
decreaseSuggestImportCount
"
1
)
;
}
removeFromStorage
(
)
{
this
.
_actor
.
sendAsyncMessage
(
"
PasswordManager
:
decreaseSuggestImportCount
"
100
)
;
}
}
class
LoginsFooterAutocompleteItem
extends
AutocompleteItem
{
constructor
(
formHostname
telemetryEventData
)
{
super
(
"
loginsFooter
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
comment
"
(
)
=
>
{
return
JSON
.
stringify
(
{
.
.
.
telemetryEventData
formHostname
}
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
label
"
(
)
=
>
{
return
getLocalizedString
(
"
viewSavedLogins
.
label
"
)
;
}
)
;
}
}
function
LoginAutoCompleteResult
(
aSearchString
matchingLogins
formOrigin
{
generatedPassword
willAutoSaveGeneratedPassword
importable
isSecure
actor
hasBeenTypePassword
hostname
telemetryEventData
}
)
{
let
hidingFooterOnPWFieldAutoOpened
=
false
;
const
importableBrowsers
=
importable
?
.
state
=
=
=
"
import
"
&
&
importable
?
.
browsers
;
function
isFooterEnabled
(
)
{
if
(
!
LoginHelper
.
showAutoCompleteFooter
|
|
!
LoginHelper
.
enabled
)
{
return
false
;
}
if
(
hasBeenTypePassword
&
&
aSearchString
&
&
!
generatedPassword
)
{
log
.
debug
(
"
Hiding
footer
:
non
-
empty
password
field
"
)
;
return
false
;
}
if
(
!
importableBrowsers
&
&
!
matchingLogins
.
length
&
&
!
generatedPassword
&
&
hasBeenTypePassword
&
&
formFillController
.
passwordPopupAutomaticallyOpened
)
{
hidingFooterOnPWFieldAutoOpened
=
true
;
log
.
debug
(
"
Hiding
footer
:
no
logins
and
the
popup
was
opened
upon
focus
of
the
pw
.
field
"
)
;
return
false
;
}
return
true
;
}
this
.
searchString
=
aSearchString
;
this
.
_rows
=
[
]
;
if
(
!
isSecure
&
&
LoginHelper
.
showInsecureFieldWarning
)
{
this
.
_rows
.
push
(
new
InsecureLoginFormAutocompleteItem
(
)
)
;
}
let
formHostPort
=
LoginHelper
.
maybeGetHostPortForURL
(
formOrigin
)
;
let
logins
=
matchingLogins
.
sort
(
loginSort
.
bind
(
null
formHostPort
)
)
;
let
duplicateUsernames
=
findDuplicates
(
matchingLogins
)
;
for
(
let
login
of
logins
)
{
let
item
=
new
LoginAutocompleteItem
(
login
hasBeenTypePassword
duplicateUsernames
actor
LoginHelper
.
isOriginMatching
(
login
.
origin
formOrigin
{
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
}
)
)
;
this
.
_rows
.
push
(
item
)
;
}
if
(
isFooterEnabled
(
)
)
{
if
(
generatedPassword
)
{
this
.
_rows
.
push
(
new
GeneratedPasswordAutocompleteItem
(
generatedPassword
willAutoSaveGeneratedPassword
)
)
;
}
if
(
!
logins
.
length
&
&
importableBrowsers
)
{
this
.
_rows
.
push
(
.
.
.
importableBrowsers
.
map
(
browserId
=
>
new
ImportableLoginsAutocompleteItem
(
browserId
hostname
actor
)
)
)
;
this
.
_rows
.
push
(
new
ImportableLearnMoreAutocompleteItem
(
)
)
;
}
this
.
_rows
.
push
(
new
LoginsFooterAutocompleteItem
(
hostname
telemetryEventData
)
)
;
}
if
(
this
.
matchCount
>
0
)
{
this
.
searchResult
=
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
;
this
.
defaultIndex
=
0
;
}
else
if
(
hidingFooterOnPWFieldAutoOpened
)
{
this
.
searchResult
=
Ci
.
nsIAutoCompleteResult
.
RESULT_FAILURE
;
this
.
defaultIndex
=
-
1
;
}
}
LoginAutoCompleteResult
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIAutoCompleteResult
"
"
nsISupportsWeakReference
"
]
)
get
logins
(
)
{
return
this
.
_rows
.
filter
(
item
=
>
{
return
item
.
constructor
=
=
=
LoginAutocompleteItem
;
}
)
.
map
(
item
=
>
item
.
_login
)
;
}
get
wrappedJSObject
(
)
{
return
this
;
}
searchString
:
null
searchResult
:
Ci
.
nsIAutoCompleteResult
.
RESULT_NOMATCH
defaultIndex
:
-
1
errorDescription
:
"
"
get
matchCount
(
)
{
return
this
.
_rows
.
length
;
}
getValueAt
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
matchCount
)
{
throw
new
Error
(
"
Index
out
of
range
.
"
)
;
}
return
this
.
_rows
[
index
]
.
value
;
}
getLabelAt
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
matchCount
)
{
throw
new
Error
(
"
Index
out
of
range
.
"
)
;
}
return
this
.
_rows
[
index
]
.
label
;
}
getCommentAt
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
matchCount
)
{
throw
new
Error
(
"
Index
out
of
range
.
"
)
;
}
return
this
.
_rows
[
index
]
.
comment
;
}
getStyleAt
(
index
)
{
return
this
.
_rows
[
index
]
.
style
;
}
getImageAt
(
index
)
{
return
"
"
;
}
getFinalCompleteValueAt
(
index
)
{
return
this
.
getValueAt
(
index
)
;
}
isRemovableAt
(
index
)
{
return
true
;
}
removeValueAt
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
matchCount
)
{
throw
new
Error
(
"
Index
out
of
range
.
"
)
;
}
let
[
removedItem
]
=
this
.
_rows
.
splice
(
index
1
)
;
if
(
this
.
defaultIndex
>
this
.
_rows
.
length
)
{
this
.
defaultIndex
-
-
;
}
removedItem
.
removeFromStorage
(
)
;
}
}
;
function
LoginAutoComplete
(
)
{
this
.
_cachedNewPasswordScore
=
new
WeakMap
(
)
;
}
LoginAutoComplete
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
2bdac17c
-
53f1
-
4896
-
a521
-
682ccdeef3a8
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsILoginAutoCompleteSearch
"
]
)
_autoCompleteLookupPromise
:
null
_cachedNewPasswordScore
:
null
startSearch
(
aSearchString
aPreviousResult
aElement
aCallback
)
{
let
{
isNullPrincipal
}
=
aElement
.
nodePrincipal
;
if
(
aElement
.
nodePrincipal
.
schemeIs
(
"
about
"
)
)
{
return
;
}
let
searchStartTimeMS
=
Services
.
telemetry
.
msSystemNow
(
)
;
let
isSecure
=
!
isNullPrincipal
;
let
form
=
LoginFormFactory
.
createFromField
(
aElement
)
;
if
(
isSecure
)
{
isSecure
=
InsecurePasswordUtils
.
isFormSecure
(
form
)
;
}
let
{
hasBeenTypePassword
}
=
aElement
;
let
hostname
=
aElement
.
ownerDocument
.
documentURIObject
.
host
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
aElement
.
ownerDocument
.
documentURI
)
;
let
loginManagerActor
=
LoginManagerChild
.
forWindow
(
aElement
.
ownerGlobal
)
;
let
completeSearch
=
async
autoCompleteLookupPromise
=
>
{
this
.
_autoCompleteLookupPromise
=
autoCompleteLookupPromise
;
let
{
generatedPassword
importable
logins
willAutoSaveGeneratedPassword
}
=
await
autoCompleteLookupPromise
;
if
(
this
.
_autoCompleteLookupPromise
!
=
=
autoCompleteLookupPromise
)
{
log
.
debug
(
"
ignoring
result
from
previous
search
"
)
;
return
;
}
let
telemetryEventData
=
{
acFieldName
:
aElement
.
getAutocompleteInfo
(
)
.
fieldName
hadPrevious
:
!
!
aPreviousResult
typeWasPassword
:
aElement
.
hasBeenTypePassword
fieldType
:
aElement
.
type
searchStartTimeMS
stringLength
:
aSearchString
.
length
}
;
this
.
_autoCompleteLookupPromise
=
null
;
let
results
=
new
LoginAutoCompleteResult
(
aSearchString
logins
formOrigin
{
generatedPassword
willAutoSaveGeneratedPassword
importable
actor
:
loginManagerActor
isSecure
hasBeenTypePassword
hostname
telemetryEventData
}
)
;
aCallback
.
onSearchCompletion
(
results
)
;
}
;
if
(
isNullPrincipal
)
{
completeSearch
(
Promise
.
resolve
(
{
logins
:
[
]
}
)
)
;
return
;
}
if
(
hasBeenTypePassword
&
&
aSearchString
&
&
!
loginManagerActor
.
isPasswordGenerationForcedOn
(
aElement
)
)
{
completeSearch
(
Promise
.
resolve
(
{
logins
:
[
]
}
)
)
;
return
;
}
if
(
!
LoginHelper
.
enabled
)
{
completeSearch
(
Promise
.
resolve
(
{
logins
:
[
]
}
)
)
;
return
;
}
let
previousResult
;
if
(
aPreviousResult
)
{
previousResult
=
{
searchString
:
aPreviousResult
.
searchString
logins
:
LoginHelper
.
loginsToVanillaObjects
(
aPreviousResult
.
wrappedJSObject
.
logins
)
}
;
}
else
{
previousResult
=
null
;
}
let
acLookupPromise
=
this
.
_requestAutoCompleteResultsFromParent
(
{
searchString
:
aSearchString
previousResult
inputElement
:
aElement
form
hasBeenTypePassword
}
)
;
completeSearch
(
acLookupPromise
)
.
catch
(
log
.
error
.
bind
(
log
)
)
;
}
stopSearch
(
)
{
this
.
_autoCompleteLookupPromise
=
null
;
}
async
_requestAutoCompleteResultsFromParent
(
{
searchString
previousResult
inputElement
form
hasBeenTypePassword
}
)
{
let
actionOrigin
=
LoginHelper
.
getFormActionOrigin
(
form
)
;
let
autocompleteInfo
=
inputElement
.
getAutocompleteInfo
(
)
;
let
loginManagerActor
=
LoginManagerChild
.
forWindow
(
inputElement
.
ownerGlobal
)
;
let
forcePasswordGeneration
=
false
;
let
isProbablyANewPasswordField
=
false
;
if
(
hasBeenTypePassword
)
{
forcePasswordGeneration
=
loginManagerActor
.
isPasswordGenerationForcedOn
(
inputElement
)
;
isProbablyANewPasswordField
=
autocompleteInfo
.
fieldName
=
=
"
new
-
password
"
|
|
this
.
_isProbablyANewPasswordField
(
inputElement
)
;
}
let
messageData
=
{
actionOrigin
searchString
previousResult
forcePasswordGeneration
hasBeenTypePassword
isSecure
:
InsecurePasswordUtils
.
isFormSecure
(
form
)
isProbablyANewPasswordField
}
;
if
(
LoginHelper
.
showAutoCompleteFooter
)
{
gAutoCompleteListener
.
init
(
)
;
}
log
.
debug
(
"
LoginAutoComplete
search
:
"
{
forcePasswordGeneration
isSecure
:
messageData
.
isSecure
hasBeenTypePassword
isProbablyANewPasswordField
searchString
:
hasBeenTypePassword
?
"
*
"
.
repeat
(
searchString
.
length
)
:
searchString
}
)
;
let
result
=
await
loginManagerActor
.
sendQuery
(
"
PasswordManager
:
autoCompleteLogins
"
messageData
)
;
return
{
generatedPassword
:
result
.
generatedPassword
importable
:
result
.
importable
logins
:
LoginHelper
.
vanillaObjectsToLogins
(
result
.
logins
)
willAutoSaveGeneratedPassword
:
result
.
willAutoSaveGeneratedPassword
}
;
}
_isProbablyANewPasswordField
(
inputElement
)
{
const
threshold
=
LoginHelper
.
generationConfidenceThreshold
;
if
(
threshold
=
=
-
1
)
{
return
false
;
}
let
score
=
this
.
_cachedNewPasswordScore
.
get
(
inputElement
)
;
if
(
score
)
{
return
score
>
=
threshold
;
}
const
{
rules
type
}
=
NewPasswordModel
;
const
results
=
rules
.
against
(
inputElement
)
;
score
=
results
.
get
(
inputElement
)
.
scoreFor
(
type
)
;
this
.
_cachedNewPasswordScore
.
set
(
inputElement
score
)
;
return
score
>
=
threshold
;
}
}
;
let
gAutoCompleteListener
=
{
keyDownEnterForInput
:
null
added
:
false
init
(
)
{
if
(
!
this
.
added
)
{
AutoCompleteChild
.
addPopupStateListener
(
this
)
;
this
.
added
=
true
;
}
}
popupStateChanged
(
messageName
data
target
)
{
switch
(
messageName
)
{
case
"
FormAutoComplete
:
PopupOpened
"
:
{
let
{
chromeEventHandler
}
=
target
.
docShell
;
chromeEventHandler
.
addEventListener
(
"
keydown
"
this
true
)
;
break
;
}
case
"
FormAutoComplete
:
PopupClosed
"
:
{
this
.
onPopupClosed
(
data
target
)
;
let
{
chromeEventHandler
}
=
target
.
docShell
;
chromeEventHandler
.
removeEventListener
(
"
keydown
"
this
true
)
;
break
;
}
}
}
handleEvent
(
event
)
{
if
(
event
.
type
!
=
"
keydown
"
)
{
return
;
}
let
focusedElement
=
formFillController
.
focusedInput
;
if
(
event
.
keyCode
!
=
event
.
DOM_VK_RETURN
|
|
focusedElement
!
=
event
.
target
)
{
this
.
keyDownEnterForInput
=
null
;
return
;
}
this
.
keyDownEnterForInput
=
focusedElement
;
}
onPopupClosed
(
{
selectedRowComment
selectedRowStyle
}
window
)
{
let
focusedElement
=
formFillController
.
focusedInput
;
let
eventTarget
=
this
.
keyDownEnterForInput
;
this
.
keyDownEnterForInput
=
null
;
if
(
!
eventTarget
|
|
eventTarget
!
=
=
focusedElement
)
{
return
;
}
let
loginManager
=
window
.
windowGlobalChild
.
getActor
(
"
LoginManager
"
)
;
switch
(
selectedRowStyle
)
{
case
"
importableLearnMore
"
:
loginManager
.
sendAsyncMessage
(
"
PasswordManager
:
OpenImportableLearnMore
"
{
}
)
;
break
;
case
"
importableLogins
"
:
loginManager
.
sendAsyncMessage
(
"
PasswordManager
:
HandleImportable
"
{
browserId
:
selectedRowComment
}
)
;
break
;
case
"
loginsFooter
"
:
loginManager
.
sendAsyncMessage
(
"
PasswordManager
:
OpenPreferences
"
{
entryPoint
:
"
autocomplete
"
}
)
;
break
;
}
}
}
;
