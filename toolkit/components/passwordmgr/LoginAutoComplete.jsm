"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
LoginAutoComplete
"
"
LoginAutoCompleteResult
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
InsecurePasswordUtils
:
"
resource
:
/
/
gre
/
modules
/
InsecurePasswordUtils
.
jsm
"
LoginFormFactory
:
"
resource
:
/
/
gre
/
modules
/
LoginFormFactory
.
jsm
"
LoginHelper
:
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
LoginManagerChild
:
"
resource
:
/
/
gre
/
modules
/
LoginManagerChild
.
jsm
"
NewPasswordModel
:
"
resource
:
/
/
gre
/
modules
/
NewPasswordModel
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
formFillController
"
"
mozilla
.
org
/
satchel
/
form
-
fill
-
controller
;
1
"
Ci
.
nsIFormFillController
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
log
"
(
)
=
>
{
return
lazy
.
LoginHelper
.
createLogger
(
"
LoginAutoComplete
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
passwordMgrBundle
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
passwordmgr
/
locale
/
passwordmgr
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
dateAndTimeFormatter
"
(
)
=
>
{
return
new
Services
.
intl
.
DateTimeFormat
(
undefined
{
dateStyle
:
"
medium
"
}
)
;
}
)
;
function
loginSort
(
formHostPort
a
b
)
{
let
maybeHostPortA
=
lazy
.
LoginHelper
.
maybeGetHostPortForURL
(
a
.
origin
)
;
let
maybeHostPortB
=
lazy
.
LoginHelper
.
maybeGetHostPortForURL
(
b
.
origin
)
;
if
(
formHostPort
=
=
maybeHostPortA
&
&
formHostPort
!
=
maybeHostPortB
)
{
return
-
1
;
}
if
(
formHostPort
!
=
maybeHostPortA
&
&
formHostPort
=
=
maybeHostPortB
)
{
return
1
;
}
if
(
a
.
httpRealm
!
=
=
b
.
httpRealm
)
{
if
(
b
.
httpRealm
=
=
=
null
)
{
return
1
;
}
if
(
a
.
httpRealm
=
=
=
null
)
{
return
-
1
;
}
}
let
userA
=
a
.
username
.
toLowerCase
(
)
;
let
userB
=
b
.
username
.
toLowerCase
(
)
;
if
(
userA
<
userB
)
{
return
-
1
;
}
if
(
userA
>
userB
)
{
return
1
;
}
return
0
;
}
function
findDuplicates
(
loginList
)
{
let
seen
=
new
Set
(
)
;
let
duplicates
=
new
Set
(
)
;
for
(
let
login
of
loginList
)
{
if
(
seen
.
has
(
login
.
username
)
)
{
duplicates
.
add
(
login
.
username
)
;
}
seen
.
add
(
login
.
username
)
;
}
return
duplicates
;
}
function
getLocalizedString
(
key
.
.
.
formatArgs
)
{
if
(
formatArgs
.
length
)
{
return
lazy
.
passwordMgrBundle
.
formatStringFromName
(
key
formatArgs
)
;
}
return
lazy
.
passwordMgrBundle
.
GetStringFromName
(
key
)
;
}
class
AutocompleteItem
{
constructor
(
style
)
{
this
.
comment
=
"
"
;
this
.
style
=
style
;
this
.
value
=
"
"
;
}
removeFromStorage
(
)
{
}
}
class
GenericAutocompleteItem
extends
AutocompleteItem
{
constructor
(
icon
title
subtitle
fillMessageName
fillMessageData
)
{
super
(
"
generic
"
)
;
this
.
comment
=
JSON
.
stringify
(
{
icon
title
subtitle
fillMessageName
fillMessageData
}
)
;
}
}
class
InsecureLoginFormAutocompleteItem
extends
AutocompleteItem
{
constructor
(
)
{
super
(
"
insecureWarning
"
)
;
this
.
label
=
getLocalizedString
(
"
insecureFieldWarningDescription2
"
getLocalizedString
(
"
insecureFieldWarningLearnMore
"
)
)
;
}
}
class
LoginAutocompleteItem
extends
AutocompleteItem
{
login
;
#
actor
;
constructor
(
login
hasBeenTypePassword
duplicateUsernames
actor
isOriginMatched
)
{
super
(
"
loginWithOrigin
"
)
;
this
.
login
=
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
this
.
#
actor
=
actor
;
const
isDuplicateUsername
=
login
.
username
&
&
duplicateUsernames
.
has
(
login
.
username
)
;
let
username
=
login
.
username
?
login
.
username
:
getLocalizedString
(
"
noUsername
"
)
;
if
(
!
login
.
username
|
|
isDuplicateUsername
)
{
const
time
=
lazy
.
dateAndTimeFormatter
.
format
(
new
Date
(
login
.
timePasswordChanged
)
)
;
username
=
getLocalizedString
(
"
loginHostAge
"
username
time
)
;
}
this
.
label
=
username
;
this
.
value
=
hasBeenTypePassword
?
login
.
password
:
login
.
username
;
this
.
comment
=
JSON
.
stringify
(
{
guid
:
login
.
guid
login
isDuplicateUsername
isOriginMatched
comment
:
isOriginMatched
&
&
login
.
httpRealm
=
=
=
null
?
getLocalizedString
(
"
displaySameOrigin
"
)
:
login
.
displayOrigin
}
)
;
}
removeFromStorage
(
)
{
if
(
this
.
#
actor
)
{
let
vanilla
=
lazy
.
LoginHelper
.
loginToVanillaObject
(
this
.
login
)
;
this
.
#
actor
.
sendAsyncMessage
(
"
PasswordManager
:
removeLogin
"
{
login
:
vanilla
}
)
;
}
else
{
Services
.
logins
.
removeLogin
(
this
.
login
)
;
}
}
}
class
GeneratedPasswordAutocompleteItem
extends
AutocompleteItem
{
constructor
(
generatedPassword
willAutoSaveGeneratedPassword
)
{
super
(
"
generatedPassword
"
)
;
this
.
label
=
getLocalizedString
(
"
useASecurelyGeneratedPassword
"
)
;
this
.
value
=
generatedPassword
;
this
.
comment
=
JSON
.
stringify
(
{
generatedPassword
willAutoSaveGeneratedPassword
}
)
;
}
}
class
ImportableLearnMoreAutocompleteItem
extends
AutocompleteItem
{
constructor
(
)
{
super
(
"
importableLearnMore
"
)
;
this
.
comment
=
JSON
.
stringify
(
{
fillMessageName
:
"
PasswordManager
:
OpenImportableLearnMore
"
}
)
;
}
}
class
ImportableLoginsAutocompleteItem
extends
AutocompleteItem
{
#
actor
;
constructor
(
browserId
hostname
actor
)
{
super
(
"
importableLogins
"
)
;
this
.
label
=
browserId
;
this
.
comment
=
JSON
.
stringify
(
{
hostname
fillMessageName
:
"
PasswordManager
:
HandleImportable
"
fillMessageData
:
{
browserId
}
}
)
;
this
.
#
actor
=
actor
;
this
.
#
actor
.
sendAsyncMessage
(
"
PasswordManager
:
decreaseSuggestImportCount
"
1
)
;
}
removeFromStorage
(
)
{
this
.
#
actor
.
sendAsyncMessage
(
"
PasswordManager
:
decreaseSuggestImportCount
"
100
)
;
}
}
class
LoginsFooterAutocompleteItem
extends
AutocompleteItem
{
constructor
(
formHostname
telemetryEventData
)
{
super
(
"
loginsFooter
"
)
;
this
.
label
=
getLocalizedString
(
"
viewSavedLogins
.
label
"
)
;
this
.
comment
=
JSON
.
stringify
(
{
telemetryEventData
formHostname
fillMessageName
:
"
PasswordManager
:
OpenPreferences
"
fillMessageData
:
{
entryPoint
:
"
autocomplete
"
}
}
)
;
}
}
class
LoginAutoCompleteResult
{
#
rows
=
[
]
;
constructor
(
aSearchString
matchingLogins
autocompleteItems
formOrigin
{
generatedPassword
willAutoSaveGeneratedPassword
importable
isSecure
actor
hasBeenTypePassword
hostname
telemetryEventData
}
)
{
let
hidingFooterOnPWFieldAutoOpened
=
false
;
const
importableBrowsers
=
importable
?
.
state
=
=
=
"
import
"
&
&
importable
?
.
browsers
;
function
isFooterEnabled
(
)
{
if
(
!
lazy
.
LoginHelper
.
showAutoCompleteFooter
|
|
!
lazy
.
LoginHelper
.
enabled
)
{
return
false
;
}
if
(
hasBeenTypePassword
&
&
aSearchString
&
&
!
generatedPassword
)
{
lazy
.
log
.
debug
(
"
Hiding
footer
:
non
-
empty
password
field
"
)
;
return
false
;
}
if
(
!
autocompleteItems
?
.
length
&
&
!
importableBrowsers
&
&
!
matchingLogins
.
length
&
&
!
generatedPassword
&
&
hasBeenTypePassword
&
&
lazy
.
formFillController
.
passwordPopupAutomaticallyOpened
)
{
hidingFooterOnPWFieldAutoOpened
=
true
;
lazy
.
log
.
debug
(
"
Hiding
footer
:
no
logins
and
the
popup
was
opened
upon
focus
of
the
pw
.
field
"
)
;
return
false
;
}
return
true
;
}
this
.
searchString
=
aSearchString
;
if
(
!
isSecure
)
{
this
.
#
rows
.
push
(
new
InsecureLoginFormAutocompleteItem
(
)
)
;
}
let
formHostPort
=
lazy
.
LoginHelper
.
maybeGetHostPortForURL
(
formOrigin
)
;
let
logins
=
matchingLogins
.
sort
(
loginSort
.
bind
(
null
formHostPort
)
)
;
let
duplicateUsernames
=
findDuplicates
(
matchingLogins
)
;
for
(
let
login
of
logins
)
{
let
item
=
new
LoginAutocompleteItem
(
login
hasBeenTypePassword
duplicateUsernames
actor
lazy
.
LoginHelper
.
isOriginMatching
(
login
.
origin
formOrigin
{
schemeUpgrades
:
lazy
.
LoginHelper
.
schemeUpgrades
}
)
)
;
this
.
#
rows
.
push
(
item
)
;
}
if
(
isFooterEnabled
(
)
)
{
if
(
autocompleteItems
)
{
this
.
#
rows
.
push
(
.
.
.
autocompleteItems
.
map
(
item
=
>
new
GenericAutocompleteItem
(
item
.
icon
item
.
title
item
.
subtitle
item
.
fillMessageName
item
.
fillMessageData
)
)
)
;
}
if
(
generatedPassword
)
{
this
.
#
rows
.
push
(
new
GeneratedPasswordAutocompleteItem
(
generatedPassword
willAutoSaveGeneratedPassword
)
)
;
}
if
(
!
logins
.
length
&
&
importableBrowsers
)
{
this
.
#
rows
.
push
(
.
.
.
importableBrowsers
.
map
(
browserId
=
>
new
ImportableLoginsAutocompleteItem
(
browserId
hostname
actor
)
)
)
;
this
.
#
rows
.
push
(
new
ImportableLearnMoreAutocompleteItem
(
)
)
;
}
this
.
#
rows
.
push
(
new
LoginsFooterAutocompleteItem
(
hostname
telemetryEventData
)
)
;
}
if
(
this
.
matchCount
>
0
)
{
this
.
searchResult
=
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
;
this
.
defaultIndex
=
0
;
}
else
if
(
hidingFooterOnPWFieldAutoOpened
)
{
this
.
searchResult
=
Ci
.
nsIAutoCompleteResult
.
RESULT_FAILURE
;
this
.
defaultIndex
=
-
1
;
}
}
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIAutoCompleteResult
"
"
nsISupportsWeakReference
"
]
)
;
get
logins
(
)
{
return
this
.
#
rows
.
filter
(
item
=
>
item
instanceof
LoginAutocompleteItem
)
.
map
(
item
=
>
item
.
login
)
;
}
get
wrappedJSObject
(
)
{
return
this
;
}
searchString
=
null
;
searchResult
=
Ci
.
nsIAutoCompleteResult
.
RESULT_NOMATCH
;
defaultIndex
=
-
1
;
errorDescription
=
"
"
;
get
matchCount
(
)
{
return
this
.
#
rows
.
length
;
}
#
throwOnBadIndex
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
matchCount
)
{
throw
new
Error
(
"
Index
out
of
range
.
"
)
;
}
}
getValueAt
(
index
)
{
this
.
#
throwOnBadIndex
(
index
)
;
return
this
.
#
rows
[
index
]
.
value
;
}
getLabelAt
(
index
)
{
this
.
#
throwOnBadIndex
(
index
)
;
return
this
.
#
rows
[
index
]
.
label
;
}
getCommentAt
(
index
)
{
this
.
#
throwOnBadIndex
(
index
)
;
return
this
.
#
rows
[
index
]
.
comment
;
}
getStyleAt
(
index
)
{
this
.
#
throwOnBadIndex
(
index
)
;
return
this
.
#
rows
[
index
]
.
style
;
}
getImageAt
(
index
)
{
this
.
#
throwOnBadIndex
(
index
)
;
return
"
"
;
}
getFinalCompleteValueAt
(
index
)
{
return
this
.
getValueAt
(
index
)
;
}
isRemovableAt
(
index
)
{
this
.
#
throwOnBadIndex
(
index
)
;
return
true
;
}
removeValueAt
(
index
)
{
this
.
#
throwOnBadIndex
(
index
)
;
let
[
removedItem
]
=
this
.
#
rows
.
splice
(
index
1
)
;
if
(
this
.
defaultIndex
>
this
.
#
rows
.
length
)
{
this
.
defaultIndex
-
-
;
}
removedItem
.
removeFromStorage
(
)
;
}
}
class
LoginAutoComplete
{
#
cachedNewPasswordScore
=
new
WeakMap
(
)
;
#
autoCompleteLookupPromise
=
null
;
classID
=
Components
.
ID
(
"
{
2bdac17c
-
53f1
-
4896
-
a521
-
682ccdeef3a8
}
"
)
;
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsILoginAutoCompleteSearch
"
]
)
;
startSearch
(
aSearchString
aPreviousResult
aElement
aCallback
)
{
let
{
isNullPrincipal
}
=
aElement
.
nodePrincipal
;
if
(
aElement
.
nodePrincipal
.
schemeIs
(
"
about
"
)
|
|
aElement
.
nodePrincipal
.
isSystemPrincipal
)
{
return
;
}
let
searchStartTimeMS
=
Services
.
telemetry
.
msSystemNow
(
)
;
let
form
=
lazy
.
LoginFormFactory
.
createFromField
(
aElement
)
;
let
isSecure
=
!
isNullPrincipal
&
&
lazy
.
InsecurePasswordUtils
.
isFormSecure
(
form
)
;
let
{
hasBeenTypePassword
}
=
aElement
;
let
hostname
=
aElement
.
ownerDocument
.
documentURIObject
.
host
;
let
formOrigin
=
lazy
.
LoginHelper
.
getLoginOrigin
(
aElement
.
ownerDocument
.
documentURI
)
;
let
loginManagerActor
=
lazy
.
LoginManagerChild
.
forWindow
(
aElement
.
ownerGlobal
)
;
let
completeSearch
=
async
autoCompleteLookupPromise
=
>
{
this
.
#
autoCompleteLookupPromise
=
autoCompleteLookupPromise
;
let
{
generatedPassword
importable
logins
autocompleteItems
willAutoSaveGeneratedPassword
}
=
await
autoCompleteLookupPromise
;
if
(
this
.
#
autoCompleteLookupPromise
!
=
=
autoCompleteLookupPromise
)
{
lazy
.
log
.
debug
(
"
Ignoring
result
from
previous
search
.
"
)
;
return
;
}
let
telemetryEventData
=
{
acFieldName
:
aElement
.
getAutocompleteInfo
(
)
.
fieldName
hadPrevious
:
!
!
aPreviousResult
typeWasPassword
:
aElement
.
hasBeenTypePassword
fieldType
:
aElement
.
type
searchStartTimeMS
stringLength
:
aSearchString
.
length
}
;
this
.
#
autoCompleteLookupPromise
=
null
;
let
results
=
new
LoginAutoCompleteResult
(
aSearchString
logins
autocompleteItems
formOrigin
{
generatedPassword
willAutoSaveGeneratedPassword
importable
actor
:
loginManagerActor
isSecure
hasBeenTypePassword
hostname
telemetryEventData
}
)
;
aCallback
.
onSearchCompletion
(
results
)
;
}
;
if
(
isNullPrincipal
)
{
completeSearch
(
Promise
.
resolve
(
{
logins
:
[
]
}
)
)
;
return
;
}
if
(
hasBeenTypePassword
&
&
aSearchString
&
&
!
loginManagerActor
.
isPasswordGenerationForcedOn
(
aElement
)
)
{
completeSearch
(
Promise
.
resolve
(
{
logins
:
[
]
}
)
)
;
return
;
}
if
(
!
lazy
.
LoginHelper
.
enabled
)
{
completeSearch
(
Promise
.
resolve
(
{
logins
:
[
]
}
)
)
;
return
;
}
let
previousResult
;
if
(
aPreviousResult
)
{
previousResult
=
{
searchString
:
aPreviousResult
.
searchString
logins
:
lazy
.
LoginHelper
.
loginsToVanillaObjects
(
aPreviousResult
.
wrappedJSObject
.
logins
)
}
;
}
else
{
previousResult
=
null
;
}
let
acLookupPromise
=
this
.
#
requestAutoCompleteResultsFromParent
(
{
searchString
:
aSearchString
previousResult
inputElement
:
aElement
form
hasBeenTypePassword
}
)
;
completeSearch
(
acLookupPromise
)
.
catch
(
lazy
.
log
.
error
.
bind
(
lazy
.
log
)
)
;
}
stopSearch
(
)
{
this
.
#
autoCompleteLookupPromise
=
null
;
}
async
#
requestAutoCompleteResultsFromParent
(
{
searchString
previousResult
inputElement
form
hasBeenTypePassword
}
)
{
let
actionOrigin
=
lazy
.
LoginHelper
.
getFormActionOrigin
(
form
)
;
let
autocompleteInfo
=
inputElement
.
getAutocompleteInfo
(
)
;
let
loginManagerActor
=
lazy
.
LoginManagerChild
.
forWindow
(
inputElement
.
ownerGlobal
)
;
let
forcePasswordGeneration
=
false
;
let
isProbablyANewPasswordField
=
false
;
if
(
hasBeenTypePassword
)
{
forcePasswordGeneration
=
loginManagerActor
.
isPasswordGenerationForcedOn
(
inputElement
)
;
isProbablyANewPasswordField
=
autocompleteInfo
.
fieldName
=
=
"
new
-
password
"
|
|
this
.
isProbablyANewPasswordField
(
inputElement
)
;
}
const
scenario
=
loginManagerActor
.
getScenario
(
inputElement
)
;
const
messageData
=
{
actionOrigin
searchString
previousResult
forcePasswordGeneration
hasBeenTypePassword
isProbablyANewPasswordField
scenarioName
:
scenario
?
.
constructor
.
name
}
;
if
(
lazy
.
LoginHelper
.
showAutoCompleteFooter
)
{
gAutoCompleteListener
.
init
(
)
;
}
lazy
.
log
.
debug
(
"
LoginAutoComplete
search
:
"
{
forcePasswordGeneration
hasBeenTypePassword
isProbablyANewPasswordField
searchStringLength
:
searchString
.
length
}
)
;
let
result
=
await
loginManagerActor
.
sendQuery
(
"
PasswordManager
:
autoCompleteLogins
"
messageData
)
;
return
{
generatedPassword
:
result
.
generatedPassword
importable
:
result
.
importable
autocompleteItems
:
result
.
autocompleteItems
logins
:
lazy
.
LoginHelper
.
vanillaObjectsToLogins
(
result
.
logins
)
willAutoSaveGeneratedPassword
:
result
.
willAutoSaveGeneratedPassword
}
;
}
isProbablyANewPasswordField
(
inputElement
)
{
const
threshold
=
lazy
.
LoginHelper
.
generationConfidenceThreshold
;
if
(
threshold
=
=
-
1
)
{
return
false
;
}
let
score
=
this
.
#
cachedNewPasswordScore
.
get
(
inputElement
)
;
if
(
score
)
{
return
score
>
=
threshold
;
}
const
{
rules
type
}
=
lazy
.
NewPasswordModel
;
const
results
=
rules
.
against
(
inputElement
)
;
score
=
results
.
get
(
inputElement
)
.
scoreFor
(
type
)
;
this
.
#
cachedNewPasswordScore
.
set
(
inputElement
score
)
;
return
score
>
=
threshold
;
}
}
let
gAutoCompleteListener
=
{
added
:
false
fillRequestId
:
0
init
(
)
{
if
(
!
this
.
added
)
{
Services
.
obs
.
addObserver
(
this
"
autocomplete
-
will
-
enter
-
text
"
)
;
this
.
added
=
true
;
}
}
async
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
autocomplete
-
will
-
enter
-
text
"
:
{
await
this
.
sendFillRequestToLoginManagerParent
(
subject
data
)
;
break
;
}
}
}
async
sendFillRequestToLoginManagerParent
(
input
comment
)
{
if
(
!
comment
)
{
return
;
}
if
(
input
!
=
lazy
.
formFillController
.
controller
.
input
)
{
return
;
}
const
{
fillMessageName
fillMessageData
}
=
JSON
.
parse
(
comment
?
?
"
{
}
"
)
;
if
(
!
fillMessageName
)
{
return
;
}
this
.
fillRequestId
+
+
;
const
fillRequestId
=
this
.
fillRequestId
;
const
child
=
lazy
.
LoginManagerChild
.
forWindow
(
input
.
focusedInput
.
ownerGlobal
)
;
const
value
=
await
child
.
sendQuery
(
fillMessageName
fillMessageData
?
?
{
}
)
;
if
(
fillRequestId
!
=
this
.
fillRequestId
)
{
return
;
}
if
(
typeof
value
!
=
=
"
string
"
)
{
return
;
}
input
.
textValue
=
value
;
input
.
selectTextRange
(
value
.
length
value
.
length
)
;
}
}
;
