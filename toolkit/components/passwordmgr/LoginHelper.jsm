"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
LoginHelper
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
var
LoginHelper
=
{
debug
:
Services
.
prefs
.
getBoolPref
(
"
signon
.
debug
"
)
formlessCaptureEnabled
:
Services
.
prefs
.
getBoolPref
(
"
signon
.
formlessCapture
.
enabled
"
)
schemeUpgrades
:
Services
.
prefs
.
getBoolPref
(
"
signon
.
schemeUpgrades
"
)
insecureAutofill
:
Services
.
prefs
.
getBoolPref
(
"
signon
.
autofillForms
.
http
"
)
createLogger
(
aLogPrefix
)
{
let
getMaxLogLevel
=
(
)
=
>
{
return
this
.
debug
?
"
debug
"
:
"
warn
"
;
}
;
let
logger
;
function
getConsole
(
)
{
if
(
!
logger
)
{
let
ConsoleAPI
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
.
ConsoleAPI
;
let
consoleOptions
=
{
maxLogLevel
:
getMaxLogLevel
(
)
prefix
:
aLogPrefix
}
;
logger
=
new
ConsoleAPI
(
consoleOptions
)
;
}
return
logger
;
}
Services
.
prefs
.
addObserver
(
"
signon
.
"
(
)
=
>
{
this
.
debug
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
debug
"
)
;
this
.
formlessCaptureEnabled
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
formlessCapture
.
enabled
"
)
;
this
.
schemeUpgrades
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
schemeUpgrades
"
)
;
this
.
insecureAutofill
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
autofillForms
.
http
"
)
;
if
(
logger
)
{
logger
.
maxLogLevel
=
getMaxLogLevel
(
)
;
}
}
)
;
return
{
log
:
(
.
.
.
args
)
=
>
{
if
(
this
.
debug
)
{
getConsole
(
)
.
log
(
.
.
.
args
)
;
}
}
error
:
(
.
.
.
args
)
=
>
{
getConsole
(
)
.
error
(
.
.
.
args
)
;
}
debug
:
(
.
.
.
args
)
=
>
{
if
(
this
.
debug
)
{
getConsole
(
)
.
debug
(
.
.
.
args
)
;
}
}
warn
:
(
.
.
.
args
)
=
>
{
if
(
this
.
debug
)
{
getConsole
(
)
.
warn
(
.
.
.
args
)
;
}
}
}
;
}
checkHostnameValue
(
aHostname
)
{
if
(
aHostname
=
=
"
.
"
|
|
aHostname
.
includes
(
"
\
r
"
)
|
|
aHostname
.
includes
(
"
\
n
"
)
|
|
aHostname
.
includes
(
"
\
0
"
)
)
{
throw
new
Error
(
"
Invalid
hostname
"
)
;
}
}
checkLoginValues
(
aLogin
)
{
function
badCharacterPresent
(
l
c
)
{
return
(
(
l
.
formSubmitURL
&
&
l
.
formSubmitURL
.
includes
(
c
)
)
|
|
(
l
.
httpRealm
&
&
l
.
httpRealm
.
includes
(
c
)
)
|
|
l
.
hostname
.
includes
(
c
)
|
|
l
.
usernameField
.
includes
(
c
)
|
|
l
.
passwordField
.
includes
(
c
)
)
;
}
if
(
badCharacterPresent
(
aLogin
"
\
0
"
)
)
{
throw
new
Error
(
"
login
values
can
'
t
contain
nulls
"
)
;
}
if
(
aLogin
.
username
.
includes
(
"
\
0
"
)
|
|
aLogin
.
password
.
includes
(
"
\
0
"
)
)
{
throw
new
Error
(
"
login
values
can
'
t
contain
nulls
"
)
;
}
if
(
badCharacterPresent
(
aLogin
"
\
r
"
)
|
|
badCharacterPresent
(
aLogin
"
\
n
"
)
)
{
throw
new
Error
(
"
login
values
can
'
t
contain
newlines
"
)
;
}
if
(
aLogin
.
usernameField
=
=
"
.
"
|
|
aLogin
.
formSubmitURL
=
=
"
.
"
)
{
throw
new
Error
(
"
login
values
can
'
t
be
periods
"
)
;
}
if
(
aLogin
.
hostname
.
includes
(
"
(
"
)
)
{
throw
new
Error
(
"
bad
parens
in
hostname
"
)
;
}
}
newPropertyBag
(
aProperties
)
{
let
propertyBag
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
if
(
aProperties
)
{
for
(
let
[
name
value
]
of
Object
.
entries
(
aProperties
)
)
{
propertyBag
.
setProperty
(
name
value
)
;
}
}
return
propertyBag
.
QueryInterface
(
Ci
.
nsIPropertyBag
)
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag2
)
;
}
searchLoginsWithObject
(
aSearchOptions
)
{
return
Services
.
logins
.
searchLogins
(
{
}
this
.
newPropertyBag
(
aSearchOptions
)
)
;
}
maybeGetHostPortForURL
(
aURL
)
{
try
{
let
uri
=
Services
.
io
.
newURI
(
aURL
)
;
return
uri
.
hostPort
;
}
catch
(
ex
)
{
}
return
aURL
;
}
isOriginMatching
(
aLoginOrigin
aSearchOrigin
aOptions
=
{
schemeUpgrades
:
false
}
)
{
if
(
aLoginOrigin
=
=
aSearchOrigin
)
{
return
true
;
}
if
(
!
aOptions
)
{
return
false
;
}
if
(
aOptions
.
schemeUpgrades
)
{
try
{
let
loginURI
=
Services
.
io
.
newURI
(
aLoginOrigin
)
;
let
searchURI
=
Services
.
io
.
newURI
(
aSearchOrigin
)
;
if
(
loginURI
.
scheme
=
=
"
http
"
&
&
searchURI
.
scheme
=
=
"
https
"
&
&
loginURI
.
hostPort
=
=
searchURI
.
hostPort
)
{
return
true
;
}
}
catch
(
ex
)
{
return
false
;
}
}
return
false
;
}
doLoginsMatch
(
aLogin1
aLogin2
{
ignorePassword
=
false
ignoreSchemes
=
false
}
)
{
if
(
aLogin1
.
httpRealm
!
=
aLogin2
.
httpRealm
|
|
aLogin1
.
username
!
=
aLogin2
.
username
)
return
false
;
if
(
!
ignorePassword
&
&
aLogin1
.
password
!
=
aLogin2
.
password
)
return
false
;
if
(
ignoreSchemes
)
{
let
login1HostPort
=
this
.
maybeGetHostPortForURL
(
aLogin1
.
hostname
)
;
let
login2HostPort
=
this
.
maybeGetHostPortForURL
(
aLogin2
.
hostname
)
;
if
(
login1HostPort
!
=
login2HostPort
)
return
false
;
if
(
aLogin1
.
formSubmitURL
!
=
"
"
&
&
aLogin2
.
formSubmitURL
!
=
"
"
&
&
this
.
maybeGetHostPortForURL
(
aLogin1
.
formSubmitURL
)
!
=
this
.
maybeGetHostPortForURL
(
aLogin2
.
formSubmitURL
)
)
{
return
false
;
}
}
else
{
if
(
aLogin1
.
hostname
!
=
aLogin2
.
hostname
)
return
false
;
if
(
aLogin1
.
formSubmitURL
!
=
"
"
&
&
aLogin2
.
formSubmitURL
!
=
"
"
&
&
aLogin1
.
formSubmitURL
!
=
aLogin2
.
formSubmitURL
)
return
false
;
}
return
true
;
}
buildModifiedLogin
(
aOldStoredLogin
aNewLoginData
)
{
function
bagHasProperty
(
aPropName
)
{
try
{
aNewLoginData
.
getProperty
(
aPropName
)
;
return
true
;
}
catch
(
ex
)
{
}
return
false
;
}
aOldStoredLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
let
newLogin
;
if
(
aNewLoginData
instanceof
Ci
.
nsILoginInfo
)
{
newLogin
=
aOldStoredLogin
.
clone
(
)
;
newLogin
.
init
(
aNewLoginData
.
hostname
aNewLoginData
.
formSubmitURL
aNewLoginData
.
httpRealm
aNewLoginData
.
username
aNewLoginData
.
password
aNewLoginData
.
usernameField
aNewLoginData
.
passwordField
)
;
newLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
if
(
newLogin
.
password
!
=
aOldStoredLogin
.
password
)
{
newLogin
.
timePasswordChanged
=
Date
.
now
(
)
;
}
}
else
if
(
aNewLoginData
instanceof
Ci
.
nsIPropertyBag
)
{
newLogin
=
aOldStoredLogin
.
clone
(
)
;
newLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
if
(
bagHasProperty
(
"
password
"
)
)
{
let
newPassword
=
aNewLoginData
.
getProperty
(
"
password
"
)
;
if
(
newPassword
!
=
aOldStoredLogin
.
password
)
{
newLogin
.
timePasswordChanged
=
Date
.
now
(
)
;
}
}
let
propEnum
=
aNewLoginData
.
enumerator
;
while
(
propEnum
.
hasMoreElements
(
)
)
{
let
prop
=
propEnum
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIProperty
)
;
switch
(
prop
.
name
)
{
case
"
hostname
"
:
case
"
httpRealm
"
:
case
"
formSubmitURL
"
:
case
"
username
"
:
case
"
password
"
:
case
"
usernameField
"
:
case
"
passwordField
"
:
case
"
guid
"
:
case
"
timeCreated
"
:
case
"
timeLastUsed
"
:
case
"
timePasswordChanged
"
:
case
"
timesUsed
"
:
newLogin
[
prop
.
name
]
=
prop
.
value
;
break
;
case
"
timesUsedIncrement
"
:
newLogin
.
timesUsed
+
=
prop
.
value
;
break
;
default
:
throw
new
Error
(
"
Unexpected
propertybag
item
:
"
+
prop
.
name
)
;
}
}
}
else
{
throw
new
Error
(
"
newLoginData
needs
an
expected
interface
!
"
)
;
}
if
(
newLogin
.
hostname
=
=
null
|
|
newLogin
.
hostname
.
length
=
=
0
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
a
null
or
empty
hostname
.
"
)
;
}
if
(
newLogin
.
username
=
=
null
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
a
null
username
.
"
)
;
}
if
(
newLogin
.
password
=
=
null
|
|
newLogin
.
password
.
length
=
=
0
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
a
null
or
empty
password
.
"
)
;
}
if
(
newLogin
.
formSubmitURL
|
|
newLogin
.
formSubmitURL
=
=
"
"
)
{
if
(
newLogin
.
httpRealm
!
=
null
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
both
a
httpRealm
and
formSubmitURL
.
"
)
;
}
}
else
if
(
newLogin
.
httpRealm
)
{
if
(
newLogin
.
formSubmitURL
!
=
null
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
both
a
httpRealm
and
formSubmitURL
.
"
)
;
}
}
else
{
throw
new
Error
(
"
Can
'
t
add
a
login
without
a
httpRealm
or
formSubmitURL
.
"
)
;
}
this
.
checkLoginValues
(
newLogin
)
;
return
newLogin
;
}
dedupeLogins
(
logins
uniqueKeys
=
[
"
username
"
"
password
"
]
resolveBy
=
[
"
timeLastUsed
"
]
preferredOrigin
=
undefined
)
{
const
KEY_DELIMITER
=
"
:
"
;
if
(
!
preferredOrigin
&
&
resolveBy
.
includes
(
"
scheme
"
)
)
{
throw
new
Error
(
"
dedupeLogins
:
preferredOrigin
is
required
in
order
to
"
+
"
prefer
schemes
which
match
it
.
"
)
;
}
let
preferredOriginScheme
;
if
(
preferredOrigin
)
{
try
{
preferredOriginScheme
=
Services
.
io
.
newURI
(
preferredOrigin
)
.
scheme
;
}
catch
(
ex
)
{
}
}
if
(
!
preferredOriginScheme
&
&
resolveBy
.
includes
(
"
scheme
"
)
)
{
log
.
warn
(
"
dedupeLogins
:
Deduping
with
a
scheme
preference
but
couldn
'
t
"
+
"
get
the
preferred
origin
scheme
.
"
)
;
}
let
loginsByKeys
=
new
Map
(
)
;
function
getKey
(
login
uniqueKeys
)
{
return
uniqueKeys
.
reduce
(
(
prev
key
)
=
>
prev
+
KEY_DELIMITER
+
login
[
key
]
"
"
)
;
}
function
isLoginPreferred
(
existingLogin
login
)
{
if
(
!
resolveBy
|
|
resolveBy
.
length
=
=
0
)
{
return
false
;
}
for
(
let
preference
of
resolveBy
)
{
switch
(
preference
)
{
case
"
scheme
"
:
{
if
(
!
preferredOriginScheme
)
{
break
;
}
try
{
let
existingLoginURI
=
Services
.
io
.
newURI
(
existingLogin
.
hostname
)
;
let
loginURI
=
Services
.
io
.
newURI
(
login
.
hostname
)
;
if
(
loginURI
.
scheme
=
=
existingLoginURI
.
scheme
|
|
(
loginURI
.
scheme
!
=
preferredOriginScheme
&
&
existingLoginURI
.
scheme
!
=
preferredOriginScheme
)
)
{
break
;
}
return
loginURI
.
scheme
=
=
preferredOriginScheme
;
}
catch
(
ex
)
{
log
.
debug
(
"
dedupeLogins
/
shouldReplaceExisting
:
Error
comparing
schemes
:
"
existingLogin
.
hostname
login
.
hostname
"
preferredOrigin
:
"
preferredOrigin
ex
)
;
}
break
;
}
case
"
timeLastUsed
"
:
case
"
timePasswordChanged
"
:
{
let
loginDate
=
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
[
preference
]
;
let
storedLoginDate
=
existingLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
[
preference
]
;
if
(
loginDate
=
=
storedLoginDate
)
{
break
;
}
return
loginDate
>
storedLoginDate
;
}
default
:
{
throw
new
Error
(
"
dedupeLogins
:
Invalid
resolveBy
preference
:
"
+
preference
)
;
}
}
}
return
false
;
}
for
(
let
login
of
logins
)
{
let
key
=
getKey
(
login
uniqueKeys
)
;
if
(
loginsByKeys
.
has
(
key
)
)
{
if
(
!
isLoginPreferred
(
loginsByKeys
.
get
(
key
)
login
)
)
{
continue
;
}
}
loginsByKeys
.
set
(
key
login
)
;
}
return
[
.
.
.
loginsByKeys
.
values
(
)
]
;
}
openPasswordManager
(
window
filterString
=
"
"
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
Toolkit
:
PasswordManager
"
)
;
if
(
win
)
{
win
.
setFilter
(
filterString
)
;
win
.
focus
(
)
;
}
else
{
window
.
openDialog
(
"
chrome
:
/
/
passwordmgr
/
content
/
passwordManager
.
xul
"
"
Toolkit
:
PasswordManager
"
"
"
{
filterString
}
)
;
}
}
isUsernameFieldType
(
element
)
{
if
(
ChromeUtils
.
getClassName
(
element
)
!
=
=
"
HTMLInputElement
"
)
return
false
;
let
fieldType
=
(
element
.
hasAttribute
(
"
type
"
)
?
element
.
getAttribute
(
"
type
"
)
.
toLowerCase
(
)
:
element
.
type
)
;
if
(
fieldType
=
=
"
text
"
|
|
fieldType
=
=
"
email
"
|
|
fieldType
=
=
"
url
"
|
|
fieldType
=
=
"
tel
"
|
|
fieldType
=
=
"
number
"
)
{
return
true
;
}
return
false
;
}
async
maybeImportLogins
(
loginDatas
)
{
let
loginsToAdd
=
[
]
;
let
loginMap
=
new
Map
(
)
;
for
(
let
loginData
of
loginDatas
)
{
let
login
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
login
.
init
(
loginData
.
hostname
loginData
.
formSubmitURL
|
|
(
typeof
(
loginData
.
httpRealm
)
=
=
"
string
"
?
null
:
"
"
)
typeof
(
loginData
.
httpRealm
)
=
=
"
string
"
?
loginData
.
httpRealm
:
null
loginData
.
username
loginData
.
password
loginData
.
usernameElement
|
|
"
"
loginData
.
passwordElement
|
|
"
"
)
;
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
login
.
timeCreated
=
loginData
.
timeCreated
;
login
.
timeLastUsed
=
loginData
.
timeLastUsed
|
|
loginData
.
timeCreated
;
login
.
timePasswordChanged
=
loginData
.
timePasswordChanged
|
|
loginData
.
timeCreated
;
login
.
timesUsed
=
loginData
.
timesUsed
|
|
1
;
try
{
this
.
checkLoginValues
(
login
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
continue
;
}
let
newLogins
=
loginMap
.
get
(
login
.
hostname
)
|
|
[
]
;
if
(
!
newLogins
)
{
loginMap
.
set
(
login
.
hostname
newLogins
)
;
}
else
{
if
(
newLogins
.
some
(
l
=
>
login
.
matches
(
l
false
)
)
)
{
continue
;
}
let
foundMatchingNewLogin
=
false
;
for
(
let
newLogin
of
newLogins
)
{
if
(
login
.
username
=
=
newLogin
.
username
)
{
foundMatchingNewLogin
=
true
;
newLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
if
(
login
.
password
!
=
newLogin
.
password
&
login
.
timePasswordChanged
>
newLogin
.
timePasswordChanged
)
{
newLogin
.
password
=
login
.
password
;
newLogin
.
timePasswordChanged
=
login
.
timePasswordChanged
;
}
}
}
if
(
foundMatchingNewLogin
)
{
continue
;
}
}
let
existingLogins
=
Services
.
logins
.
findLogins
(
{
}
login
.
hostname
login
.
formSubmitURL
login
.
httpRealm
)
;
if
(
existingLogins
.
some
(
l
=
>
login
.
matches
(
l
false
)
)
)
{
continue
;
}
let
foundMatchingLogin
=
false
;
for
(
let
existingLogin
of
existingLogins
)
{
if
(
login
.
username
=
=
existingLogin
.
username
)
{
foundMatchingLogin
=
true
;
existingLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
if
(
login
.
password
!
=
existingLogin
.
password
&
login
.
timePasswordChanged
>
existingLogin
.
timePasswordChanged
)
{
let
propBag
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
propBag
.
setProperty
(
"
password
"
login
.
password
)
;
propBag
.
setProperty
(
"
timePasswordChanged
"
login
.
timePasswordChanged
)
;
Services
.
logins
.
modifyLogin
(
existingLogin
propBag
)
;
}
}
}
if
(
foundMatchingLogin
)
{
continue
;
}
newLogins
.
push
(
login
)
;
loginsToAdd
.
push
(
login
)
;
}
if
(
!
loginsToAdd
.
length
)
{
return
[
]
;
}
return
Services
.
logins
.
addLogins
(
loginsToAdd
)
;
}
loginsToVanillaObjects
(
logins
)
{
return
logins
.
map
(
this
.
loginToVanillaObject
)
;
}
loginToVanillaObject
(
login
)
{
let
obj
=
{
}
;
for
(
let
i
in
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
)
{
if
(
typeof
login
[
i
]
!
=
=
"
function
"
)
{
obj
[
i
]
=
login
[
i
]
;
}
}
return
obj
;
}
vanillaObjectToLogin
(
login
)
{
let
formLogin
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
formLogin
.
init
(
login
.
hostname
login
.
formSubmitURL
login
.
httpRealm
login
.
username
login
.
password
login
.
usernameField
login
.
passwordField
)
;
formLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
for
(
let
prop
of
[
"
guid
"
"
timeCreated
"
"
timeLastUsed
"
"
timePasswordChanged
"
"
timesUsed
"
]
)
{
formLogin
[
prop
]
=
login
[
prop
]
;
}
return
formLogin
;
}
vanillaObjectsToLogins
(
logins
)
{
return
logins
.
map
(
this
.
vanillaObjectToLogin
)
;
}
isMasterPasswordSet
(
)
{
let
tokenDB
=
Cc
[
"
mozilla
.
org
/
security
/
pk11tokendb
;
1
"
]
.
getService
(
Ci
.
nsIPK11TokenDB
)
;
let
token
=
tokenDB
.
getInternalKeyToken
(
)
;
return
token
.
hasPassword
;
}
notifyStorageChanged
(
changeType
data
)
{
let
dataObject
=
data
;
if
(
Array
.
isArray
(
data
)
)
{
dataObject
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
dataObject
.
appendElement
(
data
[
i
]
)
;
}
}
else
if
(
typeof
(
data
)
=
=
"
string
"
)
{
dataObject
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
dataObject
.
data
=
data
;
}
Services
.
obs
.
notifyObservers
(
dataObject
"
passwordmgr
-
storage
-
changed
"
changeType
)
;
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
LoginHelper
"
showInsecureFieldWarning
"
"
security
.
insecure_field_warning
.
contextual
.
enabled
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
logger
=
LoginHelper
.
createLogger
(
"
LoginHelper
"
)
;
return
logger
;
}
)
;
