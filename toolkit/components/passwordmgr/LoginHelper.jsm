"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
LoginHelper
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OSKeyStore
"
"
resource
:
/
/
gre
/
modules
/
OSKeyStore
.
jsm
"
)
;
class
ImportRowProcessor
{
uniqueLoginIdentifiers
=
new
Set
(
)
;
originToRows
=
new
Map
(
)
;
summary
=
[
]
;
mandatoryFields
=
[
"
origin
"
"
password
"
]
;
checkNonUniqueGuidError
(
loginData
)
{
if
(
loginData
.
guid
)
{
if
(
this
.
uniqueLoginIdentifiers
.
has
(
loginData
.
guid
)
)
{
this
.
addLoginToSummary
(
{
.
.
.
loginData
}
"
error
"
)
;
return
true
;
}
this
.
uniqueLoginIdentifiers
.
add
(
loginData
.
guid
)
;
}
return
false
;
}
checkMissingMandatoryFieldsError
(
loginData
)
{
loginData
.
origin
=
LoginHelper
.
getLoginOrigin
(
loginData
.
origin
)
;
for
(
let
mandatoryField
of
this
.
mandatoryFields
)
{
if
(
!
loginData
[
mandatoryField
]
)
{
const
missingFieldRow
=
this
.
addLoginToSummary
(
{
.
.
.
loginData
}
"
error_missing_field
"
)
;
missingFieldRow
.
field_name
=
mandatoryField
;
return
true
;
}
}
return
false
;
}
async
checkExistingEntry
(
loginData
)
{
if
(
loginData
.
guid
)
{
let
existingLogins
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
:
loginData
.
guid
origin
:
loginData
.
origin
}
)
;
if
(
existingLogins
.
length
)
{
log
.
debug
(
"
maybeImportLogins
:
Found
existing
login
with
GUID
"
)
;
let
existingLogin
=
existingLogins
[
0
]
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
if
(
loginData
.
username
!
=
=
existingLogin
.
username
|
|
loginData
.
password
!
=
=
existingLogin
.
password
|
|
loginData
.
httpRealm
!
=
=
existingLogin
.
httpRealm
|
|
loginData
.
formActionOrigin
!
=
=
existingLogin
.
formActionOrigin
|
|
{
loginData
.
timeCreated
}
!
=
=
{
existingLogin
.
timeCreated
}
|
|
{
loginData
.
timePasswordChanged
}
!
=
=
{
existingLogin
.
timePasswordChanged
}
)
{
let
propBag
=
LoginHelper
.
newPropertyBag
(
loginData
)
;
this
.
addLoginToSummary
(
{
.
.
.
existingLogin
}
"
modified
"
propBag
)
;
return
true
;
}
this
.
addLoginToSummary
(
{
.
.
.
existingLogin
}
"
no_change
"
)
;
return
true
;
}
}
return
false
;
}
checkConflictingOriginWithPreviousRows
(
login
)
{
let
rowsPerOrigin
=
this
.
originToRows
.
get
(
login
.
origin
)
;
if
(
rowsPerOrigin
)
{
if
(
rowsPerOrigin
.
some
(
r
=
>
login
.
matches
(
r
.
login
false
)
)
)
{
this
.
addLoginToSummary
(
login
"
no_change
"
)
;
return
true
;
}
for
(
let
row
of
rowsPerOrigin
)
{
let
newLogin
=
row
.
login
;
if
(
login
.
username
=
=
newLogin
.
username
)
{
this
.
addLoginToSummary
(
login
"
no_change
"
)
;
return
true
;
}
}
}
return
false
;
}
checkConflictingWithExistingLogins
(
login
)
{
let
existingLogins
=
Services
.
logins
.
findLogins
(
login
.
origin
login
.
formActionOrigin
login
.
httpRealm
)
;
if
(
existingLogins
.
some
(
l
=
>
login
.
matches
(
l
false
)
)
)
{
this
.
addLoginToSummary
(
login
"
no_change
"
)
;
return
true
;
}
let
foundMatchingLogin
=
false
;
for
(
let
existingLogin
of
existingLogins
)
{
if
(
login
.
username
=
=
existingLogin
.
username
)
{
foundMatchingLogin
=
true
;
existingLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
if
(
(
login
.
password
!
=
existingLogin
.
password
)
&
(
login
.
timePasswordChanged
>
existingLogin
.
timePasswordChanged
)
)
{
let
propBag
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
propBag
.
setProperty
(
"
password
"
login
.
password
)
;
propBag
.
setProperty
(
"
timePasswordChanged
"
login
.
timePasswordChanged
)
;
this
.
addLoginToSummary
(
{
.
.
.
existingLogin
}
"
modified
"
propBag
)
;
return
true
;
}
}
}
if
(
foundMatchingLogin
)
{
this
.
addLoginToSummary
(
login
"
no_change
"
)
;
return
true
;
}
return
false
;
}
checkLoginValuesError
(
login
loginData
)
{
try
{
LoginHelper
.
checkLoginValues
(
login
)
;
}
catch
(
e
)
{
this
.
addLoginToSummary
(
{
.
.
.
loginData
}
"
error
"
)
;
Cu
.
reportError
(
e
)
;
return
true
;
}
return
false
;
}
createNewLogin
(
loginData
)
{
let
login
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
login
.
init
(
loginData
.
origin
loginData
.
formActionOrigin
loginData
.
httpRealm
loginData
.
username
loginData
.
password
loginData
.
usernameElement
|
|
"
"
loginData
.
passwordElement
|
|
"
"
)
;
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
login
.
timeCreated
=
loginData
.
timeCreated
;
login
.
timeLastUsed
=
loginData
.
timeLastUsed
|
|
loginData
.
timeCreated
;
login
.
timePasswordChanged
=
loginData
.
timePasswordChanged
|
|
loginData
.
timeCreated
;
login
.
timesUsed
=
loginData
.
timesUsed
|
|
1
;
login
.
guid
=
loginData
.
guid
|
|
null
;
return
login
;
}
cleanupActionAndRealmFields
(
loginData
)
{
const
cleanOrigin
=
loginData
.
formActionOrigin
?
LoginHelper
.
getLoginOrigin
(
loginData
.
formActionOrigin
true
)
:
"
"
;
loginData
.
formActionOrigin
=
cleanOrigin
|
|
(
typeof
loginData
.
httpRealm
=
=
"
string
"
?
null
:
"
"
)
;
loginData
.
httpRealm
=
typeof
loginData
.
httpRealm
=
=
"
string
"
?
loginData
.
httpRealm
:
null
;
}
addLoginToSummary
(
login
result
propBag
)
{
let
rows
=
this
.
originToRows
.
get
(
login
.
origin
)
|
|
[
]
;
if
(
rows
.
length
=
=
=
0
)
{
this
.
originToRows
.
set
(
login
.
origin
rows
)
;
}
const
newSummaryRow
=
{
result
login
propBag
}
;
rows
.
push
(
newSummaryRow
)
;
this
.
summary
.
push
(
newSummaryRow
)
;
return
newSummaryRow
;
}
markLastTimePasswordChangedAsModified
(
)
{
const
originUserToRowMap
=
new
Map
(
)
;
for
(
let
currentRow
of
this
.
summary
)
{
if
(
currentRow
.
result
=
=
=
"
added
"
|
|
currentRow
.
result
=
=
=
"
modified
"
|
|
currentRow
.
result
=
=
=
"
no_change
"
)
{
const
originAndUser
=
currentRow
.
login
.
origin
+
currentRow
.
login
.
username
;
let
lastTimeChangedRow
=
originUserToRowMap
.
get
(
originAndUser
)
;
if
(
lastTimeChangedRow
)
{
if
(
(
currentRow
.
login
.
password
!
=
lastTimeChangedRow
.
login
.
password
)
&
(
currentRow
.
login
.
timePasswordChanged
>
lastTimeChangedRow
.
login
.
timePasswordChanged
)
)
{
lastTimeChangedRow
.
result
=
"
no_change
"
;
currentRow
.
result
=
"
added
"
;
originUserToRowMap
.
set
(
originAndUser
currentRow
)
;
}
}
else
{
originUserToRowMap
.
set
(
originAndUser
currentRow
)
;
}
}
}
}
async
processLoginsAndBuildSummary
(
)
{
this
.
markLastTimePasswordChangedAsModified
(
)
;
for
(
let
summaryRow
of
this
.
summary
)
{
try
{
if
(
summaryRow
.
result
=
=
=
"
added
"
)
{
summaryRow
.
login
=
await
Services
.
logins
.
addLogin
(
summaryRow
.
login
)
;
}
else
if
(
summaryRow
.
result
=
=
=
"
modified
"
)
{
Services
.
logins
.
modifyLogin
(
summaryRow
.
login
summaryRow
.
propBag
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
summaryRow
.
result
=
"
error
"
;
}
}
return
this
.
summary
;
}
}
this
.
LoginHelper
=
{
debug
:
null
enabled
:
null
storageEnabled
:
null
formlessCaptureEnabled
:
null
formRemovalCaptureEnabled
:
null
generationAvailable
:
null
generationConfidenceThreshold
:
null
generationEnabled
:
null
improvedPasswordRulesEnabled
:
null
improvedPasswordRulesCollection
:
"
password
-
rules
"
includeOtherSubdomainsInLookup
:
null
insecureAutofill
:
null
privateBrowsingCaptureEnabled
:
null
remoteRecipesEnabled
:
null
remoteRecipesCollection
:
"
password
-
recipes
"
relatedRealmsEnabled
:
null
relatedRealmsCollection
:
"
websites
-
with
-
shared
-
credential
-
backends
"
schemeUpgrades
:
null
showAutoCompleteFooter
:
null
showAutoCompleteImport
:
null
testOnlyUserHasInteractedWithDocument
:
null
userInputRequiredToCapture
:
null
captureInputChanges
:
null
init
(
)
{
Services
.
prefs
.
addObserver
(
"
signon
.
"
(
)
=
>
this
.
updateSignonPrefs
(
)
)
;
this
.
updateSignonPrefs
(
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
pwmgr
"
true
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
form_autocomplete
"
true
)
;
}
updateSignonPrefs
(
)
{
this
.
autofillForms
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
autofillForms
"
)
;
this
.
autofillAutocompleteOff
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
autofillForms
.
autocompleteOff
"
)
;
this
.
captureInputChanges
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
capture
.
inputChanges
.
enabled
"
)
;
this
.
debug
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
debug
"
)
;
this
.
enabled
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
rememberSignons
"
)
;
this
.
storageEnabled
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
storeSignons
"
true
)
;
this
.
formlessCaptureEnabled
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
formlessCapture
.
enabled
"
)
;
this
.
formRemovalCaptureEnabled
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
formRemovalCapture
.
enabled
"
)
;
this
.
generationAvailable
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
generation
.
available
"
)
;
this
.
generationConfidenceThreshold
=
parseFloat
(
Services
.
prefs
.
getStringPref
(
"
signon
.
generation
.
confidenceThreshold
"
)
)
;
this
.
generationEnabled
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
generation
.
enabled
"
)
;
this
.
improvedPasswordRulesEnabled
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
improvedPasswordRules
.
enabled
"
)
;
this
.
insecureAutofill
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
autofillForms
.
http
"
)
;
this
.
includeOtherSubdomainsInLookup
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
includeOtherSubdomainsInLookup
"
)
;
this
.
passwordEditCaptureEnabled
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
passwordEditCapture
.
enabled
"
)
;
this
.
privateBrowsingCaptureEnabled
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
privateBrowsingCapture
.
enabled
"
)
;
this
.
schemeUpgrades
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
schemeUpgrades
"
)
;
this
.
showAutoCompleteFooter
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
showAutoCompleteFooter
"
)
;
this
.
showAutoCompleteImport
=
Services
.
prefs
.
getStringPref
(
"
signon
.
showAutoCompleteImport
"
"
"
)
;
this
.
storeWhenAutocompleteOff
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
storeWhenAutocompleteOff
"
)
;
this
.
suggestImportCount
=
Services
.
prefs
.
getIntPref
(
"
signon
.
suggestImportCount
"
0
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
signon
.
testOnlyUserHasInteractedByPrefValue
"
false
)
)
{
this
.
testOnlyUserHasInteractedWithDocument
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
testOnlyUserHasInteractedWithDocument
"
false
)
;
log
.
debug
(
"
updateSignonPrefs
using
pref
value
for
testOnlyUserHasInteractedWithDocument
"
this
.
testOnlyUserHasInteractedWithDocument
)
;
}
else
{
this
.
testOnlyUserHasInteractedWithDocument
=
null
;
}
this
.
userInputRequiredToCapture
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
userInputRequiredToCapture
.
enabled
"
)
;
this
.
usernameOnlyFormEnabled
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
usernameOnlyForm
.
enabled
"
)
;
this
.
usernameOnlyFormLookupThreshold
=
Services
.
prefs
.
getIntPref
(
"
signon
.
usernameOnlyForm
.
lookupThreshold
"
)
;
this
.
remoteRecipesEnabled
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
recipes
.
remoteRecipes
.
enabled
"
)
;
this
.
relatedRealmsEnabled
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
relatedRealms
.
enabled
"
)
;
}
createLogger
(
aLogPrefix
)
{
let
getMaxLogLevel
=
(
)
=
>
{
return
this
.
debug
?
"
Debug
"
:
"
Warn
"
;
}
;
let
consoleOptions
=
{
maxLogLevel
:
getMaxLogLevel
(
)
prefix
:
aLogPrefix
}
;
let
logger
=
console
.
createInstance
(
consoleOptions
)
;
Services
.
prefs
.
addObserver
(
"
signon
.
debug
"
(
)
=
>
{
this
.
debug
=
Services
.
prefs
.
getBoolPref
(
"
signon
.
debug
"
)
;
if
(
logger
)
{
logger
.
maxLogLevel
=
getMaxLogLevel
(
)
;
}
}
)
;
return
logger
;
}
checkOriginValue
(
aOrigin
)
{
if
(
aOrigin
=
=
"
.
"
|
|
aOrigin
.
includes
(
"
\
r
"
)
|
|
aOrigin
.
includes
(
"
\
n
"
)
|
|
aOrigin
.
includes
(
"
\
0
"
)
)
{
throw
new
Error
(
"
Invalid
origin
"
)
;
}
}
checkLoginValues
(
aLogin
)
{
function
badCharacterPresent
(
l
c
)
{
return
(
(
l
.
formActionOrigin
&
&
l
.
formActionOrigin
.
includes
(
c
)
)
|
|
(
l
.
httpRealm
&
&
l
.
httpRealm
.
includes
(
c
)
)
|
|
l
.
origin
.
includes
(
c
)
|
|
l
.
usernameField
.
includes
(
c
)
|
|
l
.
passwordField
.
includes
(
c
)
)
;
}
if
(
badCharacterPresent
(
aLogin
"
\
0
"
)
)
{
throw
new
Error
(
"
login
values
can
'
t
contain
nulls
"
)
;
}
if
(
!
aLogin
.
password
|
|
typeof
aLogin
.
password
!
=
"
string
"
)
{
throw
new
Error
(
"
passwords
must
be
non
-
empty
strings
"
)
;
}
if
(
aLogin
.
username
.
includes
(
"
\
0
"
)
|
|
aLogin
.
password
.
includes
(
"
\
0
"
)
)
{
throw
new
Error
(
"
login
values
can
'
t
contain
nulls
"
)
;
}
if
(
badCharacterPresent
(
aLogin
"
\
r
"
)
|
|
badCharacterPresent
(
aLogin
"
\
n
"
)
)
{
throw
new
Error
(
"
login
values
can
'
t
contain
newlines
"
)
;
}
if
(
aLogin
.
usernameField
=
=
"
.
"
|
|
aLogin
.
formActionOrigin
=
=
"
.
"
)
{
throw
new
Error
(
"
login
values
can
'
t
be
periods
"
)
;
}
if
(
aLogin
.
origin
.
includes
(
"
(
"
)
)
{
throw
new
Error
(
"
bad
parens
in
origin
"
)
;
}
}
newPropertyBag
(
aProperties
)
{
let
propertyBag
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
if
(
aProperties
)
{
for
(
let
[
name
value
]
of
Object
.
entries
(
aProperties
)
)
{
propertyBag
.
setProperty
(
name
value
)
;
}
}
return
propertyBag
.
QueryInterface
(
Ci
.
nsIPropertyBag
)
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag2
)
;
}
searchLoginsWithObject
(
aSearchOptions
)
{
return
Services
.
logins
.
searchLogins
(
this
.
newPropertyBag
(
aSearchOptions
)
)
;
}
maybeGetHostPortForURL
(
aURL
)
{
try
{
let
uri
=
Services
.
io
.
newURI
(
aURL
)
;
return
uri
.
hostPort
;
}
catch
(
ex
)
{
}
return
aURL
;
}
getLoginOrigin
(
uriString
allowJS
=
false
)
{
let
realm
=
"
"
;
try
{
let
uri
=
Services
.
io
.
newURI
(
uriString
)
;
if
(
allowJS
&
&
uri
.
scheme
=
=
"
javascript
"
)
{
return
"
javascript
:
"
;
}
realm
=
uri
.
scheme
+
"
:
/
/
"
+
uri
.
displayHostPort
;
}
catch
(
e
)
{
log
.
warn
(
"
Couldn
'
t
parse
origin
for
"
uriString
e
)
;
realm
=
null
;
}
return
realm
;
}
getFormActionOrigin
(
form
)
{
let
uriString
=
form
.
action
;
if
(
uriString
=
=
"
"
)
{
uriString
=
form
.
baseURI
;
}
return
this
.
getLoginOrigin
(
uriString
true
)
;
}
isOriginMatching
(
aLoginOrigin
aSearchOrigin
aOptions
=
{
schemeUpgrades
:
false
acceptWildcardMatch
:
false
acceptDifferentSubdomains
:
false
acceptRelatedRealms
:
false
relatedRealms
:
[
]
}
)
{
if
(
aLoginOrigin
=
=
aSearchOrigin
)
{
return
true
;
}
if
(
!
aOptions
)
{
return
false
;
}
if
(
aOptions
.
acceptWildcardMatch
&
&
aLoginOrigin
=
=
"
"
)
{
return
true
;
}
if
(
!
aOptions
.
acceptDifferentSubdomains
&
&
!
aOptions
.
schemeUpgrades
)
{
return
false
;
}
try
{
let
loginURI
=
Services
.
io
.
newURI
(
aLoginOrigin
)
;
let
searchURI
=
Services
.
io
.
newURI
(
aSearchOrigin
)
;
let
schemeMatches
=
loginURI
.
scheme
=
=
"
http
"
&
&
searchURI
.
scheme
=
=
"
https
"
;
if
(
aOptions
.
acceptDifferentSubdomains
)
{
let
loginBaseDomain
=
Services
.
eTLD
.
getBaseDomain
(
loginURI
)
;
let
searchBaseDomain
=
Services
.
eTLD
.
getBaseDomain
(
searchURI
)
;
if
(
loginBaseDomain
=
=
searchBaseDomain
&
&
(
loginURI
.
scheme
=
=
searchURI
.
scheme
|
|
(
aOptions
.
schemeUpgrades
&
&
schemeMatches
)
)
)
{
return
true
;
}
if
(
aOptions
.
acceptRelatedRealms
&
&
aOptions
.
relatedRealms
.
length
&
&
(
loginURI
.
scheme
=
=
searchURI
.
scheme
|
|
(
aOptions
.
schemeUpgrades
&
&
schemeMatches
)
)
)
{
for
(
let
relatedOrigin
of
aOptions
.
relatedRealms
)
{
if
(
Services
.
eTLD
.
hasRootDomain
(
loginURI
.
host
relatedOrigin
)
)
{
return
true
;
}
}
}
}
if
(
aOptions
.
schemeUpgrades
&
&
loginURI
.
host
=
=
searchURI
.
host
&
&
schemeMatches
&
&
loginURI
.
port
=
=
searchURI
.
port
)
{
return
true
;
}
}
catch
(
ex
)
{
return
false
;
}
return
false
;
}
doLoginsMatch
(
aLogin1
aLogin2
{
ignorePassword
=
false
ignoreSchemes
=
false
}
)
{
if
(
aLogin1
.
httpRealm
!
=
aLogin2
.
httpRealm
|
|
aLogin1
.
username
!
=
aLogin2
.
username
)
{
return
false
;
}
if
(
!
ignorePassword
&
&
aLogin1
.
password
!
=
aLogin2
.
password
)
{
return
false
;
}
if
(
ignoreSchemes
)
{
let
login1HostPort
=
this
.
maybeGetHostPortForURL
(
aLogin1
.
origin
)
;
let
login2HostPort
=
this
.
maybeGetHostPortForURL
(
aLogin2
.
origin
)
;
if
(
login1HostPort
!
=
login2HostPort
)
{
return
false
;
}
if
(
aLogin1
.
formActionOrigin
!
=
"
"
&
&
aLogin2
.
formActionOrigin
!
=
"
"
&
&
this
.
maybeGetHostPortForURL
(
aLogin1
.
formActionOrigin
)
!
=
this
.
maybeGetHostPortForURL
(
aLogin2
.
formActionOrigin
)
)
{
return
false
;
}
}
else
{
if
(
aLogin1
.
origin
!
=
aLogin2
.
origin
)
{
return
false
;
}
if
(
aLogin1
.
formActionOrigin
!
=
"
"
&
&
aLogin2
.
formActionOrigin
!
=
"
"
&
&
aLogin1
.
formActionOrigin
!
=
aLogin2
.
formActionOrigin
)
{
return
false
;
}
}
return
true
;
}
buildModifiedLogin
(
aOldStoredLogin
aNewLoginData
)
{
function
bagHasProperty
(
aPropName
)
{
try
{
aNewLoginData
.
getProperty
(
aPropName
)
;
return
true
;
}
catch
(
ex
)
{
}
return
false
;
}
aOldStoredLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
let
newLogin
;
if
(
aNewLoginData
instanceof
Ci
.
nsILoginInfo
)
{
newLogin
=
aOldStoredLogin
.
clone
(
)
;
newLogin
.
init
(
aNewLoginData
.
origin
aNewLoginData
.
formActionOrigin
aNewLoginData
.
httpRealm
aNewLoginData
.
username
aNewLoginData
.
password
aNewLoginData
.
usernameField
aNewLoginData
.
passwordField
)
;
newLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
if
(
newLogin
.
password
!
=
aOldStoredLogin
.
password
)
{
newLogin
.
timePasswordChanged
=
Date
.
now
(
)
;
}
}
else
if
(
aNewLoginData
instanceof
Ci
.
nsIPropertyBag
)
{
newLogin
=
aOldStoredLogin
.
clone
(
)
;
newLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
if
(
bagHasProperty
(
"
password
"
)
)
{
let
newPassword
=
aNewLoginData
.
getProperty
(
"
password
"
)
;
if
(
newPassword
!
=
aOldStoredLogin
.
password
)
{
newLogin
.
timePasswordChanged
=
Date
.
now
(
)
;
}
}
for
(
let
prop
of
aNewLoginData
.
enumerator
)
{
switch
(
prop
.
name
)
{
case
"
origin
"
:
case
"
httpRealm
"
:
case
"
formActionOrigin
"
:
case
"
username
"
:
case
"
password
"
:
case
"
usernameField
"
:
case
"
passwordField
"
:
case
"
guid
"
:
case
"
timeCreated
"
:
case
"
timeLastUsed
"
:
case
"
timePasswordChanged
"
:
case
"
timesUsed
"
:
newLogin
[
prop
.
name
]
=
prop
.
value
;
break
;
case
"
timesUsedIncrement
"
:
newLogin
.
timesUsed
+
=
prop
.
value
;
break
;
default
:
throw
new
Error
(
"
Unexpected
propertybag
item
:
"
+
prop
.
name
)
;
}
}
}
else
{
throw
new
Error
(
"
newLoginData
needs
an
expected
interface
!
"
)
;
}
if
(
newLogin
.
origin
=
=
null
|
|
!
newLogin
.
origin
.
length
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
a
null
or
empty
origin
.
"
)
;
}
if
(
newLogin
.
username
=
=
null
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
a
null
username
.
"
)
;
}
if
(
newLogin
.
password
=
=
null
|
|
!
newLogin
.
password
.
length
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
a
null
or
empty
password
.
"
)
;
}
if
(
newLogin
.
formActionOrigin
|
|
newLogin
.
formActionOrigin
=
=
"
"
)
{
if
(
newLogin
.
httpRealm
!
=
null
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
both
a
httpRealm
and
formActionOrigin
.
"
)
;
}
}
else
if
(
newLogin
.
httpRealm
)
{
if
(
newLogin
.
formActionOrigin
!
=
null
)
{
throw
new
Error
(
"
Can
'
t
add
a
login
with
both
a
httpRealm
and
formActionOrigin
.
"
)
;
}
}
else
{
throw
new
Error
(
"
Can
'
t
add
a
login
without
a
httpRealm
or
formActionOrigin
.
"
)
;
}
this
.
checkLoginValues
(
newLogin
)
;
return
newLogin
;
}
shadowHTTPLogins
(
logins
)
{
let
hasHTTPSByHostPortUsername
=
new
Map
(
)
;
for
(
let
login
of
logins
)
{
let
key
=
this
.
getUniqueKeyForLogin
(
login
[
"
hostPort
"
"
username
"
]
)
;
let
hasHTTPSlogin
=
hasHTTPSByHostPortUsername
.
get
(
key
)
|
|
false
;
let
loginURI
=
Services
.
io
.
newURI
(
login
.
origin
)
;
hasHTTPSByHostPortUsername
.
set
(
key
loginURI
.
scheme
=
=
"
https
"
|
|
hasHTTPSlogin
)
;
}
return
logins
.
filter
(
login
=
>
{
let
key
=
this
.
getUniqueKeyForLogin
(
login
[
"
hostPort
"
"
username
"
]
)
;
let
loginURI
=
Services
.
io
.
newURI
(
login
.
origin
)
;
if
(
loginURI
.
scheme
=
=
"
http
"
&
&
hasHTTPSByHostPortUsername
.
get
(
key
)
)
{
return
false
;
}
return
true
;
}
)
;
}
getUniqueKeyForLogin
(
login
uniqueKeys
)
{
const
KEY_DELIMITER
=
"
:
"
;
return
uniqueKeys
.
reduce
(
(
prev
key
)
=
>
{
let
val
=
null
;
if
(
key
=
=
"
hostPort
"
)
{
val
=
Services
.
io
.
newURI
(
login
.
origin
)
.
hostPort
;
}
else
{
val
=
login
[
key
]
;
}
return
prev
+
KEY_DELIMITER
+
val
;
}
"
"
)
;
}
dedupeLogins
(
logins
uniqueKeys
=
[
"
username
"
"
password
"
]
resolveBy
=
[
"
timeLastUsed
"
]
preferredOrigin
=
undefined
preferredFormActionOrigin
=
undefined
)
{
if
(
!
preferredOrigin
)
{
if
(
resolveBy
.
includes
(
"
scheme
"
)
)
{
throw
new
Error
(
"
dedupeLogins
:
preferredOrigin
is
required
in
order
to
"
+
"
prefer
schemes
which
match
it
.
"
)
;
}
if
(
resolveBy
.
includes
(
"
subdomain
"
)
)
{
throw
new
Error
(
"
dedupeLogins
:
preferredOrigin
is
required
in
order
to
"
+
"
prefer
subdomains
which
match
it
.
"
)
;
}
}
let
preferredOriginScheme
;
if
(
preferredOrigin
)
{
try
{
preferredOriginScheme
=
Services
.
io
.
newURI
(
preferredOrigin
)
.
scheme
;
}
catch
(
ex
)
{
}
}
if
(
!
preferredOriginScheme
&
&
resolveBy
.
includes
(
"
scheme
"
)
)
{
log
.
warn
(
"
dedupeLogins
:
Deduping
with
a
scheme
preference
but
couldn
'
t
"
+
"
get
the
preferred
origin
scheme
.
"
)
;
}
let
loginsByKeys
=
new
Map
(
)
;
function
isLoginPreferred
(
existingLogin
login
)
{
if
(
!
resolveBy
|
|
!
resolveBy
.
length
)
{
return
false
;
}
for
(
let
preference
of
resolveBy
)
{
switch
(
preference
)
{
case
"
actionOrigin
"
:
{
if
(
!
preferredFormActionOrigin
)
{
break
;
}
if
(
LoginHelper
.
isOriginMatching
(
existingLogin
.
formActionOrigin
preferredFormActionOrigin
{
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
}
)
&
&
!
LoginHelper
.
isOriginMatching
(
login
.
formActionOrigin
preferredFormActionOrigin
{
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
}
)
)
{
return
false
;
}
break
;
}
case
"
scheme
"
:
{
if
(
!
preferredOriginScheme
)
{
break
;
}
try
{
let
existingLoginURI
=
Services
.
io
.
newURI
(
existingLogin
.
origin
)
;
let
loginURI
=
Services
.
io
.
newURI
(
login
.
origin
)
;
if
(
loginURI
.
scheme
=
=
existingLoginURI
.
scheme
|
|
(
loginURI
.
scheme
!
=
preferredOriginScheme
&
&
existingLoginURI
.
scheme
!
=
preferredOriginScheme
)
)
{
break
;
}
return
loginURI
.
scheme
=
=
preferredOriginScheme
;
}
catch
(
ex
)
{
log
.
debug
(
"
dedupeLogins
/
shouldReplaceExisting
:
Error
comparing
schemes
:
"
existingLogin
.
origin
login
.
origin
"
preferredOrigin
:
"
preferredOrigin
ex
)
;
}
break
;
}
case
"
subdomain
"
:
{
let
existingLoginURI
=
Services
.
io
.
newURI
(
existingLogin
.
origin
)
;
let
newLoginURI
=
Services
.
io
.
newURI
(
login
.
origin
)
;
let
preferredOriginURI
=
Services
.
io
.
newURI
(
preferredOrigin
)
;
if
(
existingLoginURI
.
hostPort
!
=
preferredOriginURI
.
hostPort
&
&
newLoginURI
.
hostPort
=
=
preferredOriginURI
.
hostPort
)
{
return
true
;
}
if
(
existingLoginURI
.
host
!
=
preferredOriginURI
.
host
&
&
newLoginURI
.
host
=
=
preferredOriginURI
.
host
)
{
return
true
;
}
if
(
existingLoginURI
.
host
=
=
preferredOriginURI
.
host
&
&
newLoginURI
.
host
!
=
preferredOriginURI
.
host
)
{
return
false
;
}
break
;
}
case
"
timeLastUsed
"
:
case
"
timePasswordChanged
"
:
{
let
loginDate
=
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
[
preference
]
;
let
storedLoginDate
=
existingLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
[
preference
]
;
if
(
loginDate
=
=
storedLoginDate
)
{
break
;
}
return
loginDate
>
storedLoginDate
;
}
default
:
{
throw
new
Error
(
"
dedupeLogins
:
Invalid
resolveBy
preference
:
"
+
preference
)
;
}
}
}
return
false
;
}
for
(
let
login
of
logins
)
{
let
key
=
this
.
getUniqueKeyForLogin
(
login
uniqueKeys
)
;
if
(
loginsByKeys
.
has
(
key
)
)
{
if
(
!
isLoginPreferred
(
loginsByKeys
.
get
(
key
)
login
)
)
{
continue
;
}
}
loginsByKeys
.
set
(
key
login
)
;
}
return
[
.
.
.
loginsByKeys
.
values
(
)
]
;
}
openPasswordManager
(
window
{
filterString
=
"
"
entryPoint
=
"
"
}
=
{
}
)
{
const
params
=
new
URLSearchParams
(
{
.
.
.
(
filterString
&
&
{
filter
:
filterString
}
)
.
.
.
(
entryPoint
&
&
{
entryPoint
}
)
}
)
;
const
separator
=
params
.
toString
(
)
?
"
?
"
:
"
"
;
const
destination
=
about
:
logins
{
separator
}
{
params
}
;
window
.
openTrustedLinkIn
(
destination
"
tab
"
)
;
}
isPasswordFieldType
(
element
{
ignoreConnect
=
false
}
=
{
}
)
{
if
(
ChromeUtils
.
getClassName
(
element
)
!
=
=
"
HTMLInputElement
"
)
{
return
false
;
}
if
(
!
element
.
isConnected
&
&
!
ignoreConnect
)
{
return
false
;
}
if
(
!
element
.
hasBeenTypePassword
)
{
return
false
;
}
let
acInfo
=
element
.
getAutocompleteInfo
(
)
;
if
(
!
acInfo
)
{
return
false
;
}
return
true
;
}
isUsernameFieldType
(
element
{
ignoreConnect
=
false
}
=
{
}
)
{
if
(
ChromeUtils
.
getClassName
(
element
)
!
=
=
"
HTMLInputElement
"
)
{
return
false
;
}
if
(
!
element
.
isConnected
&
&
!
ignoreConnect
)
{
return
false
;
}
if
(
element
.
hasBeenTypePassword
)
{
return
false
;
}
let
fieldType
=
element
.
hasAttribute
(
"
type
"
)
?
element
.
getAttribute
(
"
type
"
)
.
toLowerCase
(
)
:
element
.
type
;
if
(
!
(
fieldType
=
=
"
text
"
|
|
fieldType
=
=
"
email
"
|
|
fieldType
=
=
"
url
"
|
|
fieldType
=
=
"
tel
"
|
|
fieldType
=
=
"
number
"
)
)
{
return
false
;
}
let
acFieldName
=
element
.
getAutocompleteInfo
(
)
.
fieldName
;
if
(
!
(
acFieldName
=
=
"
username
"
|
|
acFieldName
=
=
"
email
"
|
|
acFieldName
=
=
"
tel
"
|
|
acFieldName
=
=
"
tel
-
national
"
|
|
acFieldName
=
=
"
off
"
|
|
acFieldName
=
=
"
on
"
|
|
acFieldName
=
=
"
"
)
)
{
return
false
;
}
return
true
;
}
isInferredLoginForm
(
formElement
)
{
const
loginExpr
=
/
login
|
log
in
|
log
on
|
log
-
on
|
sign
in
|
sigin
|
sign
\
/
in
|
sign
-
in
|
sign
on
|
sign
-
on
/
i
;
if
(
this
.
_elementAttrsMatchRegex
(
formElement
loginExpr
)
)
{
return
true
;
}
return
false
;
}
isInferredUsernameField
(
element
)
{
const
expr
=
/
username
/
i
;
let
ac
=
element
.
getAutocompleteInfo
(
)
?
.
fieldName
;
if
(
ac
&
&
ac
=
=
"
username
"
)
{
return
true
;
}
if
(
this
.
_elementAttrsMatchRegex
(
element
expr
)
|
|
this
.
_hasLabelMatchingRegex
(
element
expr
)
)
{
return
true
;
}
return
false
;
}
isInferredNonUsernameField
(
element
)
{
const
expr
=
/
search
|
code
/
i
;
if
(
this
.
_elementAttrsMatchRegex
(
element
expr
)
|
|
this
.
_hasLabelMatchingRegex
(
element
expr
)
)
{
return
true
;
}
return
false
;
}
isInferredEmailField
(
element
)
{
const
expr
=
/
email
/
i
;
if
(
element
.
type
=
=
"
email
"
)
{
return
true
;
}
let
ac
=
element
.
getAutocompleteInfo
(
)
?
.
fieldName
;
if
(
ac
&
&
ac
=
=
"
email
"
)
{
return
true
;
}
if
(
this
.
_elementAttrsMatchRegex
(
element
expr
)
|
|
this
.
_hasLabelMatchingRegex
(
element
expr
)
)
{
return
true
;
}
return
false
;
}
_elementAttrsMatchRegex
(
element
regex
)
{
if
(
regex
.
test
(
element
.
id
)
|
|
regex
.
test
(
element
.
name
)
|
|
regex
.
test
(
element
.
className
)
)
{
return
true
;
}
let
placeholder
=
element
.
getAttribute
(
"
placeholder
"
)
;
if
(
placeholder
&
&
regex
.
test
(
placeholder
)
)
{
return
true
;
}
return
false
;
}
_hasLabelMatchingRegex
(
element
regex
)
{
if
(
element
.
labels
!
=
=
null
&
&
element
.
labels
.
length
)
{
if
(
regex
.
test
(
element
.
labels
[
0
]
.
textContent
)
)
{
return
true
;
}
}
return
false
;
}
async
maybeImportLogins
(
loginDatas
)
{
this
.
importing
=
true
;
try
{
const
processor
=
new
ImportRowProcessor
(
)
;
for
(
let
rawLoginData
of
loginDatas
)
{
let
loginData
=
ChromeUtils
.
shallowClone
(
rawLoginData
)
;
if
(
processor
.
checkNonUniqueGuidError
(
loginData
)
)
{
continue
;
}
if
(
processor
.
checkMissingMandatoryFieldsError
(
loginData
)
)
{
continue
;
}
processor
.
cleanupActionAndRealmFields
(
loginData
)
;
if
(
await
processor
.
checkExistingEntry
(
loginData
)
)
{
continue
;
}
let
login
=
processor
.
createNewLogin
(
loginData
)
;
if
(
processor
.
checkLoginValuesError
(
login
loginData
)
)
{
continue
;
}
if
(
processor
.
checkConflictingOriginWithPreviousRows
(
login
)
)
{
continue
;
}
if
(
processor
.
checkConflictingWithExistingLogins
(
login
)
)
{
continue
;
}
processor
.
addLoginToSummary
(
login
"
added
"
)
;
}
return
await
processor
.
processLoginsAndBuildSummary
(
)
;
}
finally
{
this
.
importing
=
false
;
}
}
loginsToVanillaObjects
(
logins
)
{
return
logins
.
map
(
this
.
loginToVanillaObject
)
;
}
loginToVanillaObject
(
login
)
{
let
obj
=
{
}
;
for
(
let
i
in
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
)
{
if
(
typeof
login
[
i
]
!
=
=
"
function
"
)
{
obj
[
i
]
=
login
[
i
]
;
}
}
return
obj
;
}
vanillaObjectToLogin
(
login
)
{
let
formLogin
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
formLogin
.
init
(
login
.
origin
login
.
formActionOrigin
login
.
httpRealm
login
.
username
login
.
password
login
.
usernameField
login
.
passwordField
)
;
formLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
for
(
let
prop
of
[
"
guid
"
"
timeCreated
"
"
timeLastUsed
"
"
timePasswordChanged
"
"
timesUsed
"
]
)
{
formLogin
[
prop
]
=
login
[
prop
]
;
}
return
formLogin
;
}
vanillaObjectsToLogins
(
vanillaObjects
)
{
const
logins
=
[
]
;
for
(
const
vanillaObject
of
vanillaObjects
)
{
logins
.
push
(
this
.
vanillaObjectToLogin
(
vanillaObject
)
)
;
}
return
logins
;
}
isMasterPasswordSet
(
)
{
let
tokenDB
=
Cc
[
"
mozilla
.
org
/
security
/
pk11tokendb
;
1
"
]
.
getService
(
Ci
.
nsIPK11TokenDB
)
;
let
token
=
tokenDB
.
getInternalKeyToken
(
)
;
return
token
.
hasPassword
;
}
async
requestReauth
(
browser
OSReauthEnabled
expirationTime
messageText
captionText
)
{
let
isAuthorized
=
false
;
let
telemetryEvent
;
let
tokendb
=
Cc
[
"
mozilla
.
org
/
security
/
pk11tokendb
;
1
"
]
.
createInstance
(
Ci
.
nsIPK11TokenDB
)
;
let
token
=
tokendb
.
getInternalKeyToken
(
)
;
if
(
expirationTime
&
&
Date
.
now
(
)
<
expirationTime
)
{
isAuthorized
=
true
;
telemetryEvent
=
{
object
:
token
.
hasPassword
?
"
master_password
"
:
"
os_auth
"
method
:
"
reauthenticate
"
value
:
"
success_no_prompt
"
}
;
return
{
isAuthorized
telemetryEvent
}
;
}
if
(
!
token
.
hasPassword
&
&
!
OSReauthEnabled
)
{
isAuthorized
=
true
;
telemetryEvent
=
{
object
:
"
os_auth
"
method
:
"
reauthenticate
"
value
:
"
success_disabled
"
}
;
return
{
isAuthorized
telemetryEvent
}
;
}
if
(
!
token
.
hasPassword
&
&
OSReauthEnabled
)
{
let
result
=
await
OSKeyStore
.
ensureLoggedIn
(
messageText
captionText
browser
.
ownerGlobal
false
)
;
isAuthorized
=
result
.
authenticated
;
telemetryEvent
=
{
object
:
"
os_auth
"
method
:
"
reauthenticate
"
value
:
result
.
auth_details
extra
:
result
.
auth_details_extra
}
;
return
{
isAuthorized
telemetryEvent
}
;
}
token
.
checkPassword
(
"
"
)
;
if
(
Services
.
logins
.
uiBusy
)
{
isAuthorized
=
false
;
return
{
isAuthorized
telemetryEvent
}
;
}
try
{
token
.
login
(
true
)
;
}
catch
(
e
)
{
}
isAuthorized
=
token
.
isLoggedIn
(
)
;
telemetryEvent
=
{
object
:
"
master_password
"
method
:
"
reauthenticate
"
value
:
isAuthorized
?
"
success
"
:
"
fail
"
}
;
return
{
isAuthorized
telemetryEvent
}
;
}
notifyStorageChanged
(
changeType
data
)
{
if
(
this
.
importing
)
{
return
;
}
let
dataObject
=
data
;
if
(
Array
.
isArray
(
data
)
)
{
dataObject
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
dataObject
.
appendElement
(
data
[
i
]
)
;
}
}
else
if
(
typeof
data
=
=
"
string
"
)
{
dataObject
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
dataObject
.
data
=
data
;
}
Services
.
obs
.
notifyObservers
(
dataObject
"
passwordmgr
-
storage
-
changed
"
changeType
)
;
}
isUserFacingLogin
(
login
)
{
return
login
.
origin
!
=
"
chrome
:
/
/
FirefoxAccounts
"
;
}
async
getAllUserFacingLogins
(
)
{
try
{
let
logins
=
await
Services
.
logins
.
getAllLoginsAsync
(
)
;
return
logins
.
filter
(
this
.
isUserFacingLogin
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_ABORT
)
{
return
[
]
;
}
throw
e
;
}
}
createLoginAlreadyExistsError
(
guid
)
{
let
guidSupportsString
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
guidSupportsString
.
data
=
guid
;
return
Components
.
Exception
(
"
This
login
already
exists
.
"
{
data
:
guidSupportsString
}
)
;
}
getBrowserForPrompt
(
browser
)
{
let
chromeWindow
=
browser
.
ownerGlobal
;
let
openerBrowsingContext
=
browser
.
browsingContext
.
opener
;
let
openerBrowser
=
openerBrowsingContext
?
openerBrowsingContext
.
top
.
embedderElement
:
null
;
if
(
openerBrowser
)
{
let
chromeDoc
=
chromeWindow
.
document
.
documentElement
;
if
(
chromeDoc
.
getAttribute
(
"
chromehidden
"
)
&
&
!
browser
.
canGoBack
)
{
log
.
debug
(
"
Using
opener
window
for
prompt
.
"
)
;
return
openerBrowser
;
}
}
return
browser
;
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
LoginHelper
"
showInsecureFieldWarning
"
"
security
.
insecure_field_warning
.
contextual
.
enabled
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
processName
=
Services
.
appinfo
.
processType
=
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
?
"
Main
"
:
"
Content
"
;
return
LoginHelper
.
createLogger
(
LoginHelper
(
{
processName
}
)
)
;
}
)
;
LoginHelper
.
init
(
)
;
