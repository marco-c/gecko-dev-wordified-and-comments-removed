"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
PasswordGenerator
"
]
;
const
DEFAULT_PASSWORD_LENGTH
=
15
;
const
MAX_UINT8
=
Math
.
pow
(
2
8
)
-
1
;
const
MAX_UINT32
=
Math
.
pow
(
2
32
)
-
1
;
const
LOWER_CASE_ALPHA
=
"
abcdefghijkmnpqrstuvwxyz
"
;
const
UPPER_CASE_ALPHA
=
"
ABCDEFGHJKLMNPQRSTUVWXYZ
"
;
const
DIGITS
=
"
23456789
"
;
const
SPECIAL_CHARACTERS
=
"
-
~
!
#
%
^
&
*
_
+
=
|
(
)
{
}
[
:
;
\
"
'
<
>
.
?
]
"
;
const
REQUIRED_CHARACTER_CLASSES
=
[
LOWER_CASE_ALPHA
UPPER_CASE_ALPHA
DIGITS
]
;
const
REQUIRED
=
"
required
"
;
const
MAX_LENGTH
=
"
maxlength
"
;
const
MIN_LENGTH
=
"
minlength
"
;
const
MAX_CONSECUTIVE
=
"
max
-
consecutive
"
;
const
UPPER
=
"
upper
"
;
const
LOWER
=
"
lower
"
;
const
DIGIT
=
"
digit
"
;
const
SPECIAL
=
"
special
"
;
const
DEFAULT_RULES
=
new
Map
(
)
;
DEFAULT_RULES
.
set
(
MIN_LENGTH
REQUIRED_CHARACTER_CLASSES
.
length
)
;
DEFAULT_RULES
.
set
(
MAX_LENGTH
MAX_UINT8
)
;
DEFAULT_RULES
.
set
(
REQUIRED
[
UPPER
LOWER
DIGIT
]
)
;
const
PasswordGenerator
=
{
generatePassword
(
{
length
=
DEFAULT_PASSWORD_LENGTH
rules
=
DEFAULT_RULES
}
)
{
rules
=
new
Map
(
[
.
.
.
DEFAULT_RULES
.
.
.
rules
]
)
;
if
(
rules
.
get
(
MIN_LENGTH
)
>
length
)
{
length
=
rules
.
get
(
MIN_LENGTH
)
;
}
if
(
rules
.
get
(
MAX_LENGTH
)
<
length
)
{
length
=
rules
.
get
(
MAX_LENGTH
)
;
}
let
password
=
"
"
;
let
requiredClasses
=
[
]
;
let
allRequiredCharacters
=
"
"
;
this
.
_addRequiredClassesAndCharacters
(
rules
requiredClasses
)
;
for
(
const
charClassString
of
requiredClasses
)
{
password
+
=
charClassString
[
this
.
_randomUInt8Index
(
charClassString
.
length
)
]
;
if
(
Array
.
isArray
(
charClassString
)
)
{
allRequiredCharacters
+
=
charClassString
.
join
(
"
"
)
;
}
else
{
allRequiredCharacters
+
=
charClassString
;
}
}
while
(
password
.
length
<
length
)
{
password
+
=
allRequiredCharacters
[
this
.
_randomUInt8Index
(
allRequiredCharacters
.
length
)
]
;
}
password
=
this
.
_shuffleString
(
password
)
;
if
(
rules
.
has
(
MAX_CONSECUTIVE
)
)
{
const
DEFAULT_NUMBER_OF_SHUFFLES
=
15
;
let
shuffleCount
=
0
;
let
consecutiveFlag
=
this
.
_checkConsecutiveCharacters
(
password
rules
.
get
(
MAX_CONSECUTIVE
)
)
;
while
(
!
consecutiveFlag
)
{
password
=
this
.
_shuffleString
(
password
)
;
consecutiveFlag
=
this
.
_checkConsecutiveCharacters
(
password
rules
.
get
(
MAX_CONSECUTIVE
)
)
;
+
+
shuffleCount
;
if
(
shuffleCount
=
=
=
DEFAULT_NUMBER_OF_SHUFFLES
)
{
consecutiveFlag
=
true
;
}
}
}
return
password
;
}
_addRequiredClassesAndCharacters
(
rules
requiredClasses
)
{
for
(
const
charClass
of
rules
.
get
(
REQUIRED
)
)
{
if
(
charClass
=
=
=
UPPER
)
{
requiredClasses
.
push
(
UPPER_CASE_ALPHA
)
;
}
else
if
(
charClass
=
=
=
LOWER
)
{
requiredClasses
.
push
(
LOWER_CASE_ALPHA
)
;
}
else
if
(
charClass
=
=
=
DIGIT
)
{
requiredClasses
.
push
(
DIGITS
)
;
}
else
if
(
charClass
=
=
=
SPECIAL
)
{
requiredClasses
.
push
(
SPECIAL_CHARACTERS
)
;
}
else
{
requiredClasses
.
push
(
charClass
)
;
}
}
}
_randomUInt8Index
(
range
)
{
if
(
range
>
MAX_UINT8
)
{
throw
new
Error
(
"
range
cannot
fit
into
uint8
"
)
;
}
const
MAX_ACCEPTABLE_VALUE
=
Math
.
floor
(
MAX_UINT8
/
range
)
*
range
-
1
;
const
randomValueArr
=
new
Uint8Array
(
1
)
;
do
{
crypto
.
getRandomValues
(
randomValueArr
)
;
}
while
(
randomValueArr
[
0
]
>
MAX_ACCEPTABLE_VALUE
)
;
return
randomValueArr
[
0
]
%
range
;
}
_shuffleString
(
str
)
{
let
arr
=
Array
.
from
(
str
)
;
const
randomValues
=
new
Uint32Array
(
arr
.
length
-
1
)
;
crypto
.
getRandomValues
(
randomValues
)
;
for
(
let
i
=
arr
.
length
-
1
;
i
>
0
;
i
-
-
)
{
const
j
=
Math
.
floor
(
(
randomValues
[
i
-
1
]
/
MAX_UINT32
)
*
(
i
+
1
)
)
;
[
arr
[
i
]
arr
[
j
]
]
=
[
arr
[
j
]
arr
[
i
]
]
;
}
return
arr
.
join
(
"
"
)
;
}
_checkConsecutiveCharacters
(
generatedPassword
value
)
{
let
max
=
0
;
for
(
let
start
=
0
end
=
1
;
end
<
generatedPassword
.
length
;
)
{
if
(
generatedPassword
[
end
]
=
=
=
generatedPassword
[
start
]
)
{
if
(
max
<
end
-
start
+
1
)
{
max
=
end
-
start
+
1
;
if
(
max
>
value
)
{
return
false
;
}
}
end
+
+
;
}
else
{
start
=
end
+
+
;
}
}
return
true
;
}
_getUpperCaseCharacters
(
)
{
return
UPPER_CASE_ALPHA
;
}
_getLowerCaseCharacters
(
)
{
return
LOWER_CASE_ALPHA
;
}
_getDigits
(
)
{
return
DIGITS
;
}
_getSpecialCharacters
(
)
{
return
SPECIAL_CHARACTERS
;
}
}
;
