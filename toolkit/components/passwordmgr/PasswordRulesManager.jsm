"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
LoginHelper
:
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
PasswordGenerator
:
"
resource
:
/
/
gre
/
modules
/
PasswordGenerator
.
jsm
"
PasswordRulesParser
:
"
resource
:
/
/
gre
/
modules
/
PasswordRulesParser
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
log
"
(
)
=
>
{
let
logger
=
lazy
.
LoginHelper
.
createLogger
(
"
PasswordRulesManager
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
const
IMPROVED_PASSWORD_GENERATION_HISTOGRAM
=
"
PWMGR_NUM_IMPROVED_GENERATED_PASSWORDS
"
;
const
EXPORTED_SYMBOLS
=
[
"
PasswordRulesManagerParent
"
]
;
class
PasswordRulesManagerParent
extends
JSWindowActorParent
{
_passwordRulesClient
=
null
;
async
initPasswordRulesCollection
(
)
{
if
(
!
this
.
_passwordRulesClient
)
{
this
.
_passwordRulesClient
=
lazy
.
RemoteSettings
(
lazy
.
LoginHelper
.
improvedPasswordRulesCollection
)
;
}
}
_transformRulesToMap
(
rules
)
{
let
map
=
new
Map
(
)
;
for
(
let
rule
of
rules
)
{
let
{
_name
value
}
=
rule
;
if
(
_name
=
=
=
"
minlength
"
|
|
_name
=
=
=
"
maxlength
"
|
|
_name
=
=
=
"
max
-
consecutive
"
)
{
map
.
set
(
_name
value
)
;
}
else
{
let
_value
=
[
]
;
if
(
map
.
get
(
_name
)
)
{
_value
=
map
.
get
(
_name
)
;
}
for
(
let
_class
of
value
)
{
let
{
_name
:
_className
}
=
_class
;
if
(
_className
)
{
_value
.
push
(
_className
)
;
}
else
{
let
{
_characters
}
=
_class
;
_value
.
push
(
_characters
)
;
}
}
map
.
set
(
_name
_value
)
;
}
}
return
map
;
}
async
generatePassword
(
uri
)
{
await
this
.
initPasswordRulesCollection
(
)
;
let
originDisplayHost
=
uri
.
displayHost
;
let
records
=
await
this
.
_passwordRulesClient
.
get
(
)
;
let
currentRecord
;
for
(
let
record
of
records
)
{
if
(
Services
.
eTLD
.
hasRootDomain
(
originDisplayHost
record
.
Domain
)
)
{
currentRecord
=
record
;
break
;
}
}
let
isCustomRule
=
false
;
if
(
currentRecord
?
.
Domain
)
{
isCustomRule
=
true
;
lazy
.
log
(
Password
rules
for
{
currentRecord
.
Domain
}
:
{
currentRecord
[
"
password
-
rules
"
]
}
.
)
;
let
currentRules
=
lazy
.
PasswordRulesParser
.
parsePasswordRules
(
currentRecord
[
"
password
-
rules
"
]
)
;
let
mapOfRules
=
this
.
_transformRulesToMap
(
currentRules
)
;
Services
.
telemetry
.
getHistogramById
(
IMPROVED_PASSWORD_GENERATION_HISTOGRAM
)
.
add
(
isCustomRule
)
;
return
lazy
.
PasswordGenerator
.
generatePassword
(
{
rules
:
mapOfRules
}
)
;
}
lazy
.
log
(
No
password
rules
for
specified
origin
generating
standard
password
.
)
;
Services
.
telemetry
.
getHistogramById
(
IMPROVED_PASSWORD_GENERATION_HISTOGRAM
)
.
add
(
isCustomRule
)
;
return
lazy
.
PasswordGenerator
.
generatePassword
(
{
}
)
;
}
}
