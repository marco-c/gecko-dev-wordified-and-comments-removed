"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
LoginCSVImport
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
LoginHelper
:
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
ResponsivenessMonitor
:
"
resource
:
/
/
gre
/
modules
/
ResponsivenessMonitor
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
d3
"
(
)
=
>
{
let
d3Scope
=
Cu
.
Sandbox
(
null
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
global
/
content
/
third_party
/
d3
/
d3
.
js
"
d3Scope
)
;
return
Cu
.
waiveXrays
(
d3Scope
.
d3
)
;
}
)
;
const
FIELD_TO_CSV_COLUMNS
=
{
origin
:
[
"
url
"
"
login_uri
"
]
username
:
[
"
username
"
"
login_username
"
]
password
:
[
"
password
"
"
login_password
"
]
httpRealm
:
[
"
httpRealm
"
]
formActionOrigin
:
[
"
formActionOrigin
"
]
guid
:
[
"
guid
"
]
timeCreated
:
[
"
timeCreated
"
]
timeLastUsed
:
[
"
timeLastUsed
"
]
timePasswordChanged
:
[
"
timePasswordChanged
"
]
}
;
class
LoginCSVImport
{
static
get
MIGRATION_HISTOGRAM_KEY
(
)
{
return
"
login_csv
"
;
}
static
_getCSVColumnToFieldMap
(
)
{
let
csvColumnToField
=
new
Map
(
)
;
for
(
let
[
field
columns
]
of
Object
.
entries
(
FIELD_TO_CSV_COLUMNS
)
)
{
for
(
let
column
of
columns
)
{
csvColumnToField
.
set
(
column
field
)
;
}
}
return
csvColumnToField
;
}
static
_getVanillaLoginFromCSVObject
(
csvObject
csvColumnToFieldMap
)
{
let
vanillaLogin
=
Object
.
create
(
null
)
;
for
(
let
columnName
of
Object
.
keys
(
csvObject
)
)
{
let
fieldName
=
csvColumnToFieldMap
.
get
(
columnName
)
;
if
(
!
fieldName
)
{
continue
;
}
if
(
typeof
vanillaLogin
[
fieldName
]
!
=
"
undefined
"
&
&
vanillaLogin
[
fieldName
]
!
=
=
csvObject
[
columnName
]
)
{
return
{
}
;
}
vanillaLogin
[
fieldName
]
=
csvObject
[
columnName
]
;
}
if
(
vanillaLogin
.
httpRealm
=
=
=
"
"
)
{
vanillaLogin
.
httpRealm
=
null
;
}
return
vanillaLogin
;
}
static
async
importFromCSV
(
filePath
)
{
TelemetryStopwatch
.
startKeyed
(
"
FX_MIGRATION_LOGINS_IMPORT_MS
"
LoginCSVImport
.
MIGRATION_HISTOGRAM_KEY
)
;
let
responsivenessMonitor
=
new
ResponsivenessMonitor
(
)
;
let
csvColumnToFieldMap
=
LoginCSVImport
.
_getCSVColumnToFieldMap
(
)
;
let
csvString
=
await
OS
.
File
.
read
(
filePath
{
encoding
:
"
utf
-
8
"
}
)
;
let
parsedLines
=
d3
.
csv
.
parse
(
csvString
)
;
let
fieldsInFile
=
new
Set
(
Object
.
keys
(
parsedLines
[
0
]
|
|
{
}
)
.
map
(
col
=
>
csvColumnToFieldMap
.
get
(
col
)
)
)
;
if
(
parsedLines
[
0
]
&
&
(
!
fieldsInFile
.
has
(
"
origin
"
)
|
|
!
fieldsInFile
.
has
(
"
username
"
)
|
|
!
fieldsInFile
.
has
(
"
password
"
)
)
)
{
TelemetryStopwatch
.
cancelKeyed
(
"
FX_MIGRATION_LOGINS_IMPORT_MS
"
LoginCSVImport
.
MIGRATION_HISTOGRAM_KEY
)
;
throw
new
Error
(
"
CSV
file
must
contain
origin
username
and
password
columns
"
)
;
}
let
loginsToImport
=
parsedLines
.
map
(
csvObject
=
>
{
return
LoginCSVImport
.
_getVanillaLoginFromCSVObject
(
csvObject
csvColumnToFieldMap
)
;
}
)
;
let
summary
=
await
LoginHelper
.
maybeImportLogins
(
loginsToImport
)
;
try
{
Services
.
telemetry
.
getKeyedHistogramById
(
"
FX_MIGRATION_LOGINS_QUANTITY
"
)
.
add
(
LoginCSVImport
.
MIGRATION_HISTOGRAM_KEY
parsedLines
.
length
)
;
let
accumulatedDelay
=
responsivenessMonitor
.
finish
(
)
;
Services
.
telemetry
.
getKeyedHistogramById
(
"
FX_MIGRATION_LOGINS_JANK_MS
"
)
.
add
(
LoginCSVImport
.
MIGRATION_HISTOGRAM_KEY
accumulatedDelay
)
;
TelemetryStopwatch
.
finishKeyed
(
"
FX_MIGRATION_LOGINS_IMPORT_MS
"
LoginCSVImport
.
MIGRATION_HISTOGRAM_KEY
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
return
summary
;
}
}
