"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
LoginCSVImport
"
"
ImportFailedException
"
"
ImportFailedErrorType
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
LoginHelper
:
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
ResponsivenessMonitor
:
"
resource
:
/
/
gre
/
modules
/
ResponsivenessMonitor
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
d3
"
(
)
=
>
{
let
d3Scope
=
Cu
.
Sandbox
(
null
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
global
/
content
/
third_party
/
d3
/
d3
.
js
"
d3Scope
)
;
return
Cu
.
waiveXrays
(
d3Scope
.
d3
)
;
}
)
;
const
FIELD_TO_CSV_COLUMNS
=
{
origin
:
[
"
url
"
"
login_uri
"
]
username
:
[
"
username
"
"
login_username
"
]
password
:
[
"
password
"
"
login_password
"
]
httpRealm
:
[
"
httprealm
"
]
formActionOrigin
:
[
"
formactionorigin
"
]
guid
:
[
"
guid
"
]
timeCreated
:
[
"
timecreated
"
]
timeLastUsed
:
[
"
timelastused
"
]
timePasswordChanged
:
[
"
timepasswordchanged
"
]
}
;
const
ImportFailedErrorType
=
Object
.
freeze
(
{
CONFLICTING_VALUES_ERROR
:
"
CONFLICTING_VALUES_ERROR
"
FILE_FORMAT_ERROR
:
"
FILE_FORMAT_ERROR
"
FILE_PERMISSIONS_ERROR
:
"
FILE_PERMISSIONS_ERROR
"
UNABLE_TO_READ_ERROR
:
"
UNABLE_TO_READ_ERROR
"
}
)
;
class
ImportFailedException
extends
Error
{
constructor
(
errorType
message
)
{
super
(
message
!
=
null
?
message
:
errorType
)
;
this
.
errorType
=
errorType
;
}
}
class
LoginCSVImport
{
static
_getCSVColumnToFieldMap
(
)
{
let
csvColumnToField
=
new
Map
(
)
;
for
(
let
[
field
columns
]
of
Object
.
entries
(
FIELD_TO_CSV_COLUMNS
)
)
{
for
(
let
column
of
columns
)
{
csvColumnToField
.
set
(
column
.
toLowerCase
(
)
field
)
;
}
}
return
csvColumnToField
;
}
static
_getVanillaLoginFromCSVObject
(
csvObject
csvColumnToFieldMap
)
{
let
vanillaLogin
=
Object
.
create
(
null
)
;
for
(
let
columnName
of
Object
.
keys
(
csvObject
)
)
{
let
fieldName
=
csvColumnToFieldMap
.
get
(
columnName
.
toLowerCase
(
)
)
;
if
(
!
fieldName
)
{
continue
;
}
if
(
typeof
vanillaLogin
[
fieldName
]
!
=
"
undefined
"
&
&
vanillaLogin
[
fieldName
]
!
=
=
csvObject
[
columnName
]
)
{
return
{
}
;
}
vanillaLogin
[
fieldName
]
=
csvObject
[
columnName
]
;
}
if
(
vanillaLogin
.
httpRealm
=
=
=
"
"
)
{
vanillaLogin
.
httpRealm
=
null
;
}
return
vanillaLogin
;
}
static
_recordHistogramTelemetry
(
histogram
report
)
{
for
(
let
reportRow
of
report
)
{
let
{
result
}
=
reportRow
;
if
(
result
.
includes
(
"
error
"
)
)
{
histogram
.
add
(
"
error
"
)
;
}
else
{
histogram
.
add
(
result
)
;
}
}
}
static
async
importFromCSV
(
filePath
)
{
TelemetryStopwatch
.
start
(
"
PWMGR_IMPORT_LOGINS_FROM_FILE_MS
"
)
;
let
responsivenessMonitor
=
new
ResponsivenessMonitor
(
)
;
let
csvColumnToFieldMap
=
LoginCSVImport
.
_getCSVColumnToFieldMap
(
)
;
let
csvFieldToColumnMap
=
new
Map
(
)
;
let
csvString
;
try
{
csvString
=
await
OS
.
File
.
read
(
filePath
{
encoding
:
"
utf
-
8
"
}
)
;
}
catch
(
ex
)
{
TelemetryStopwatch
.
cancel
(
"
PWMGR_IMPORT_LOGINS_FROM_FILE_MS
"
)
;
Cu
.
reportError
(
ex
)
;
throw
new
ImportFailedException
(
ImportFailedErrorType
.
FILE_PERMISSIONS_ERROR
)
;
}
let
parsedLines
;
let
headerLine
;
if
(
filePath
.
endsWith
(
"
.
csv
"
)
)
{
headerLine
=
d3
.
csv
.
parseRows
(
csvString
)
[
0
]
;
parsedLines
=
d3
.
csv
.
parse
(
csvString
)
;
}
else
if
(
filePath
.
endsWith
(
"
.
tsv
"
)
)
{
headerLine
=
d3
.
tsv
.
parseRows
(
csvString
)
[
0
]
;
parsedLines
=
d3
.
tsv
.
parse
(
csvString
)
;
}
if
(
parsedLines
&
&
headerLine
)
{
for
(
const
columnName
of
headerLine
)
{
const
fieldName
=
csvColumnToFieldMap
.
get
(
columnName
.
toLocaleLowerCase
(
)
)
;
if
(
fieldName
)
{
if
(
!
csvFieldToColumnMap
.
has
(
fieldName
)
)
{
csvFieldToColumnMap
.
set
(
fieldName
columnName
)
;
}
else
{
TelemetryStopwatch
.
cancel
(
"
PWMGR_IMPORT_LOGINS_FROM_FILE_MS
"
)
;
throw
new
ImportFailedException
(
ImportFailedErrorType
.
CONFLICTING_VALUES_ERROR
)
;
}
}
}
}
if
(
csvFieldToColumnMap
.
size
=
=
=
0
)
{
TelemetryStopwatch
.
cancel
(
"
PWMGR_IMPORT_LOGINS_FROM_FILE_MS
"
)
;
throw
new
ImportFailedException
(
ImportFailedErrorType
.
FILE_FORMAT_ERROR
)
;
}
if
(
parsedLines
[
0
]
&
&
(
!
csvFieldToColumnMap
.
has
(
"
origin
"
)
|
|
!
csvFieldToColumnMap
.
has
(
"
username
"
)
|
|
!
csvFieldToColumnMap
.
has
(
"
password
"
)
)
)
{
TelemetryStopwatch
.
cancel
(
"
PWMGR_IMPORT_LOGINS_FROM_FILE_MS
"
)
;
throw
new
ImportFailedException
(
ImportFailedErrorType
.
FILE_FORMAT_ERROR
)
;
}
let
loginsToImport
=
parsedLines
.
map
(
csvObject
=
>
{
return
LoginCSVImport
.
_getVanillaLoginFromCSVObject
(
csvObject
csvColumnToFieldMap
)
;
}
)
;
let
report
=
await
LoginHelper
.
maybeImportLogins
(
loginsToImport
)
;
for
(
const
reportRow
of
report
)
{
if
(
reportRow
.
result
=
=
=
"
error_missing_field
"
)
{
reportRow
.
field_name
=
csvFieldToColumnMap
.
get
(
reportRow
.
field_name
)
;
}
}
try
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
PWMGR_IMPORT_LOGINS_FROM_FILE_CATEGORICAL
"
)
;
this
.
_recordHistogramTelemetry
(
histogram
report
)
;
let
accumulatedDelay
=
responsivenessMonitor
.
finish
(
)
;
Services
.
telemetry
.
getHistogramById
(
"
PWMGR_IMPORT_LOGINS_FROM_FILE_JANK_MS
"
)
.
add
(
accumulatedDelay
)
;
TelemetryStopwatch
.
finish
(
"
PWMGR_IMPORT_LOGINS_FROM_FILE_MS
"
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
LoginCSVImport
.
lastImportReport
=
report
;
return
report
;
}
}
