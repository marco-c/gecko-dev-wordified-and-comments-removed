const
{
LoginTestUtils
}
=
SpecialPowers
.
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
LoginTestUtils
.
sys
.
mjs
"
)
;
const
Services
=
SpecialPowers
.
Services
;
LoginTestUtils
.
setAssertReporter
(
SpecialPowers
.
wrapCallback
(
(
err
message
stack
)
=
>
{
SimpleTest
.
record
(
!
err
err
?
err
.
message
:
message
null
stack
)
;
}
)
)
;
const
{
LoginHelper
}
=
SpecialPowers
.
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
sys
.
mjs
"
)
;
const
{
LENGTH
:
GENERATED_PASSWORD_LENGTH
REGEX
:
GENERATED_PASSWORD_REGEX
}
=
LoginTestUtils
.
generation
;
const
LOGIN_FIELD_UTILS
=
LoginTestUtils
.
loginField
;
const
TESTS_DIR
=
"
/
tests
/
toolkit
/
components
/
passwordmgr
/
test
/
"
;
function
recreateTree
(
element
)
{
element
.
outerHTML
=
element
.
outerHTML
;
}
function
_checkArrayValues
(
actualValues
expectedValues
msg
)
{
is
(
actualValues
.
length
expectedValues
.
length
"
Checking
array
values
:
"
+
msg
)
;
for
(
let
i
=
0
;
i
<
expectedValues
.
length
;
i
+
+
)
{
is
(
actualValues
[
i
]
expectedValues
[
i
]
msg
+
"
Checking
array
entry
#
"
+
i
)
;
}
}
function
checkAutoCompleteResults
(
actualValues
expectedValues
hostname
msg
)
{
if
(
hostname
=
=
=
null
)
{
_checkArrayValues
(
actualValues
expectedValues
msg
)
;
return
;
}
isnot
(
actualValues
.
length
0
"
There
should
be
items
in
the
autocomplete
popup
:
"
+
JSON
.
stringify
(
actualValues
)
)
;
let
footerResult
=
actualValues
[
actualValues
.
length
-
1
]
;
is
(
footerResult
"
Manage
Passwords
"
"
the
footer
text
is
shown
correctly
"
)
;
if
(
actualValues
.
length
=
=
1
)
{
is
(
expectedValues
.
length
0
"
If
only
the
footer
is
present
then
there
should
be
no
expectedValues
"
)
;
info
(
"
Only
the
footer
is
present
in
the
popup
"
)
;
return
;
}
_checkArrayValues
(
actualValues
.
slice
(
0
-
1
)
expectedValues
msg
)
;
}
async
function
untilAutocompletePopupClosed
(
)
{
return
SimpleTest
.
promiseWaitForCondition
(
async
(
)
=
>
{
const
popupState
=
await
getPopupState
(
)
;
return
!
popupState
.
open
;
}
"
Wait
for
autocomplete
popup
to
be
closed
"
)
;
}
function
getIframeBrowsingContext
(
window
iframeNumber
=
0
)
{
let
bc
=
SpecialPowers
.
wrap
(
window
)
.
windowGlobalChild
.
browsingContext
;
return
SpecialPowers
.
unwrap
(
bc
.
children
[
iframeNumber
]
)
;
}
function
setUserInputValues
(
parentNode
selectorValues
userInput
=
true
)
{
for
(
let
[
selector
newValue
]
of
Object
.
entries
(
selectorValues
)
)
{
info
(
setUserInputValues
selector
:
{
selector
}
)
;
try
{
let
field
=
SpecialPowers
.
wrap
(
parentNode
.
querySelector
(
selector
)
)
;
if
(
field
.
value
=
=
newValue
)
{
field
.
value
+
=
"
#
"
;
}
if
(
userInput
)
{
field
.
setUserInput
(
newValue
)
;
}
else
{
field
.
value
=
newValue
;
}
}
catch
(
ex
)
{
info
(
ex
.
message
)
;
info
(
ex
.
stack
)
;
ok
(
false
setUserInputValues
:
Couldn
'
t
set
value
of
field
:
{
ex
.
message
}
)
;
}
}
}
function
getSubmitMessage
(
aFilterFn
=
undefined
)
{
info
(
"
getSubmitMessage
"
)
;
return
new
Promise
(
resolve
=
>
{
PWMGR_COMMON_PARENT
.
addMessageListener
(
"
formSubmissionProcessed
"
function
processed
(
.
.
.
args
)
{
if
(
aFilterFn
&
&
!
aFilterFn
(
.
.
.
args
)
)
{
return
;
}
info
(
"
got
formSubmissionProcessed
"
)
;
PWMGR_COMMON_PARENT
.
removeMessageListener
(
"
formSubmissionProcessed
"
processed
)
;
resolve
(
args
[
0
]
)
;
}
)
;
}
)
;
}
function
getPasswordEditedMessage
(
)
{
info
(
"
getPasswordEditedMessage
"
)
;
return
new
Promise
(
resolve
=
>
{
PWMGR_COMMON_PARENT
.
addMessageListener
(
"
passwordEditedOrGenerated
"
function
listener
(
.
.
.
args
)
{
info
(
"
got
passwordEditedOrGenerated
"
)
;
PWMGR_COMMON_PARENT
.
removeMessageListener
(
"
passwordEditedOrGenerated
"
listener
)
;
resolve
(
args
[
0
]
)
;
}
)
;
}
)
;
}
function
createLoginForm
(
{
num
=
1
action
=
"
"
autocomplete
=
null
username
=
{
}
password
=
{
}
}
=
{
}
)
{
username
.
name
|
|
=
"
uname
"
;
username
.
type
|
|
=
"
text
"
;
username
.
id
|
|
=
null
;
username
.
value
|
|
=
null
;
username
.
autocomplete
|
|
=
null
;
password
.
name
|
|
=
"
pword
"
;
password
.
type
|
|
=
"
password
"
;
password
.
id
|
|
=
null
;
password
.
value
|
|
=
null
;
password
.
label
|
|
=
null
;
password
.
autocomplete
|
|
=
null
;
password
.
readonly
|
|
=
null
;
password
.
disabled
|
|
=
null
;
info
(
Creating
login
form
{
JSON
.
stringify
(
{
num
action
username
password
}
)
}
)
;
const
form
=
document
.
createElement
(
"
form
"
)
;
form
.
id
=
form
{
num
}
;
form
.
action
=
action
;
form
.
onsubmit
=
(
)
=
>
false
;
if
(
autocomplete
!
=
null
)
{
form
.
setAttribute
(
"
autocomplete
"
autocomplete
)
;
}
const
usernameInput
=
document
.
createElement
(
"
input
"
)
;
usernameInput
.
type
=
username
.
type
;
usernameInput
.
name
=
username
.
name
;
if
(
username
.
id
!
=
null
)
{
usernameInput
.
id
=
username
.
id
;
}
if
(
username
.
value
!
=
null
)
{
usernameInput
.
value
=
username
.
value
;
}
if
(
username
.
autocomplete
!
=
null
)
{
usernameInput
.
setAttribute
(
"
autocomplete
"
username
.
autocomplete
)
;
}
form
.
appendChild
(
usernameInput
)
;
if
(
password
)
{
const
passwordInput
=
document
.
createElement
(
"
input
"
)
;
passwordInput
.
type
=
password
.
type
;
passwordInput
.
name
=
password
.
name
;
if
(
password
.
id
!
=
null
)
{
passwordInput
.
id
=
password
.
id
;
}
if
(
password
.
value
!
=
null
)
{
passwordInput
.
value
=
password
.
value
;
}
if
(
password
.
autocomplete
!
=
null
)
{
passwordInput
.
setAttribute
(
"
autocomplete
"
password
.
autocomplete
)
;
}
if
(
password
.
readonly
!
=
null
)
{
passwordInput
.
setAttribute
(
"
readonly
"
password
.
readonly
)
;
}
if
(
password
.
disabled
!
=
null
)
{
passwordInput
.
setAttribute
(
"
disabled
"
password
.
disabled
)
;
}
if
(
password
.
label
!
=
null
)
{
const
passwordLabel
=
document
.
createElement
(
"
label
"
)
;
passwordLabel
.
innerText
=
password
.
label
;
passwordLabel
.
appendChild
(
passwordInput
)
;
form
.
appendChild
(
passwordLabel
)
;
}
else
{
form
.
appendChild
(
passwordInput
)
;
}
}
const
submitButton
=
document
.
createElement
(
"
button
"
)
;
submitButton
.
type
=
"
submit
"
;
submitButton
.
name
=
"
submit
"
;
submitButton
.
innerText
=
"
Submit
"
;
form
.
appendChild
(
submitButton
)
;
const
content
=
document
.
getElementById
(
"
content
"
)
;
const
oldForm
=
document
.
getElementById
(
form
.
id
)
;
if
(
oldForm
)
{
content
.
replaceChild
(
form
oldForm
)
;
}
else
{
content
.
appendChild
(
form
)
;
}
return
form
;
}
function
checkLoginForm
(
usernameField
expectedUsername
passwordField
expectedPassword
)
{
let
formID
=
usernameField
.
parentNode
.
id
;
is
(
usernameField
.
value
expectedUsername
"
Checking
"
+
formID
+
"
username
is
:
"
+
expectedUsername
)
;
is
(
passwordField
.
value
expectedPassword
"
Checking
"
+
formID
+
"
password
is
:
"
+
expectedPassword
)
;
}
function
ensureCondition
(
condition
errorMsg
=
"
Condition
did
not
last
.
"
retryTimes
=
10
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
tries
=
0
;
let
conditionFailed
=
false
;
let
interval
=
setInterval
(
async
function
(
)
{
try
{
const
conditionPassed
=
await
condition
(
)
;
conditionFailed
|
|
=
!
conditionPassed
;
}
catch
(
e
)
{
ok
(
false
e
+
"
\
n
"
+
e
.
stack
)
;
conditionFailed
=
true
;
}
if
(
conditionFailed
|
|
tries
>
=
retryTimes
)
{
ok
(
!
conditionFailed
errorMsg
)
;
clearInterval
(
interval
)
;
if
(
conditionFailed
)
{
reject
(
errorMsg
)
;
}
else
{
resolve
(
)
;
}
}
tries
+
+
;
}
100
)
;
}
)
;
}
function
ensureLoginFormStaysFilledWith
(
usernameField
expectedUsername
passwordField
expectedPassword
)
{
return
ensureCondition
(
(
)
=
>
{
return
(
Object
.
is
(
usernameField
.
value
expectedUsername
)
&
&
Object
.
is
(
passwordField
.
value
expectedPassword
)
)
;
}
Ensuring
form
{
usernameField
.
parentNode
.
id
}
stays
filled
with
"
{
expectedUsername
}
:
{
expectedPassword
}
"
)
;
}
function
checkLoginFormInFrame
(
iframeBC
usernameFieldId
expectedUsername
passwordFieldId
expectedPassword
)
{
return
SpecialPowers
.
spawn
(
iframeBC
[
usernameFieldId
expectedUsername
passwordFieldId
expectedPassword
]
(
usernameFieldIdF
expectedUsernameF
passwordFieldIdF
expectedPasswordF
)
=
>
{
let
usernameField
=
this
.
content
.
document
.
getElementById
(
usernameFieldIdF
)
;
let
passwordField
=
this
.
content
.
document
.
getElementById
(
passwordFieldIdF
)
;
let
formID
=
usernameField
.
parentNode
.
id
;
Assert
.
equal
(
usernameField
.
value
expectedUsernameF
"
Checking
"
+
formID
+
"
username
is
:
"
+
expectedUsernameF
)
;
Assert
.
equal
(
passwordField
.
value
expectedPasswordF
"
Checking
"
+
formID
+
"
password
is
:
"
+
expectedPasswordF
)
;
}
)
;
}
async
function
checkUnmodifiedFormInFrame
(
bc
formNum
)
{
return
SpecialPowers
.
spawn
(
bc
[
formNum
]
formNumF
=
>
{
let
form
=
this
.
content
.
document
.
getElementById
(
form
{
formNumF
}
)
;
ok
(
form
"
Locating
form
"
+
formNumF
)
;
const
elements
=
form
.
nodeName
=
=
=
"
form
"
?
form
.
elements
:
form
.
querySelectorAll
(
"
input
"
)
;
for
(
const
ele
of
elements
)
{
if
(
ele
.
type
=
=
"
submit
"
|
|
ele
.
type
=
=
"
reset
"
)
{
continue
;
}
is
(
ele
.
value
ele
.
defaultValue
"
Test
to
default
value
of
field
"
+
ele
.
name
+
"
in
form
"
+
formNumF
)
;
}
}
)
;
}
async
function
checkLoginFormInFrameWithElementValues
(
browsingContext
formNum
.
.
.
values
)
{
return
SpecialPowers
.
spawn
(
browsingContext
[
formNum
values
]
function
checkFormWithElementValues
(
formNumF
valuesF
)
{
let
[
val1F
val2F
val3F
]
=
valuesF
;
let
doc
=
this
.
content
.
document
;
let
e
;
let
form
=
doc
.
getElementById
(
"
form
"
+
formNumF
)
;
ok
(
form
"
Locating
form
"
+
formNumF
)
;
let
numToCheck
=
arguments
.
length
-
1
;
const
elements
=
form
.
nodeName
=
=
=
"
form
"
?
form
.
elements
:
form
.
querySelectorAll
(
"
input
"
)
;
if
(
!
numToCheck
-
-
)
{
return
;
}
e
=
elements
[
0
]
;
if
(
val1F
=
=
null
)
{
is
(
e
.
value
e
.
defaultValue
"
Test
default
value
of
field
"
+
e
.
name
+
"
in
form
"
+
formNumF
)
;
}
else
{
is
(
e
.
value
val1F
"
Test
value
of
field
"
+
e
.
name
+
"
in
form
"
+
formNumF
)
;
}
if
(
!
numToCheck
-
-
)
{
return
;
}
e
=
elements
[
1
]
;
if
(
val2F
=
=
null
)
{
is
(
e
.
value
e
.
defaultValue
"
Test
default
value
of
field
"
+
e
.
name
+
"
in
form
"
+
formNumF
)
;
}
else
{
is
(
e
.
value
val2F
"
Test
value
of
field
"
+
e
.
name
+
"
in
form
"
+
formNumF
)
;
}
if
(
!
numToCheck
-
-
)
{
return
;
}
e
=
elements
[
2
]
;
if
(
val3F
=
=
null
)
{
is
(
e
.
value
e
.
defaultValue
"
Test
default
value
of
field
"
+
e
.
name
+
"
in
form
"
+
formNumF
)
;
}
else
{
is
(
e
.
value
val3F
"
Test
value
of
field
"
+
e
.
name
+
"
in
form
"
+
formNumF
)
;
}
}
)
;
}
function
checkForm
(
formNum
val1
val2
val3
)
{
var
e
form
=
document
.
getElementById
(
"
form
"
+
formNum
)
;
ok
(
form
"
Locating
form
"
+
formNum
)
;
var
numToCheck
=
arguments
.
length
-
1
;
if
(
!
numToCheck
-
-
)
{
return
;
}
e
=
form
.
elements
[
0
]
;
if
(
val1
=
=
null
)
{
is
(
e
.
value
e
.
defaultValue
"
Test
default
value
of
field
"
+
e
.
name
+
"
in
form
"
+
formNum
)
;
}
else
{
is
(
e
.
value
val1
"
Test
value
of
field
"
+
e
.
name
+
"
in
form
"
+
formNum
)
;
}
if
(
!
numToCheck
-
-
)
{
return
;
}
e
=
form
.
elements
[
1
]
;
if
(
val2
=
=
null
)
{
is
(
e
.
value
e
.
defaultValue
"
Test
default
value
of
field
"
+
e
.
name
+
"
in
form
"
+
formNum
)
;
}
else
{
is
(
e
.
value
val2
"
Test
value
of
field
"
+
e
.
name
+
"
in
form
"
+
formNum
)
;
}
if
(
!
numToCheck
-
-
)
{
return
;
}
e
=
form
.
elements
[
2
]
;
if
(
val3
=
=
null
)
{
is
(
e
.
value
e
.
defaultValue
"
Test
default
value
of
field
"
+
e
.
name
+
"
in
form
"
+
formNum
)
;
}
else
{
is
(
e
.
value
val3
"
Test
value
of
field
"
+
e
.
name
+
"
in
form
"
+
formNum
)
;
}
}
function
checkUnmodifiedForm
(
formNum
)
{
var
form
=
document
.
getElementById
(
"
form
"
+
formNum
)
;
ok
(
form
"
Locating
form
"
+
formNum
)
;
for
(
var
i
=
0
;
i
<
form
.
elements
.
length
;
i
+
+
)
{
var
ele
=
form
.
elements
[
i
]
;
if
(
ele
.
type
=
=
"
submit
"
|
|
ele
.
type
=
=
"
reset
"
)
{
continue
;
}
is
(
ele
.
value
ele
.
defaultValue
"
Test
to
default
value
of
field
"
+
ele
.
name
+
"
in
form
"
+
formNum
)
;
}
}
function
registerRunTests
(
existingPasswordFieldsCount
=
0
callback
)
{
return
new
Promise
(
resolve
=
>
{
function
onDOMContentLoaded
(
)
{
var
form
=
document
.
createElement
(
"
form
"
)
;
form
.
id
=
"
observerforcer
"
;
var
username
=
document
.
createElement
(
"
input
"
)
;
username
.
name
=
"
testuser
"
;
form
.
appendChild
(
username
)
;
var
password
=
document
.
createElement
(
"
input
"
)
;
password
.
name
=
"
testpass
"
;
password
.
type
=
"
password
"
;
form
.
appendChild
(
password
)
;
let
foundForcer
=
false
;
var
observer
=
SpecialPowers
.
wrapCallback
(
function
(
_subject
_topic
data
)
{
if
(
data
=
=
=
"
observerforcer
"
)
{
foundForcer
=
true
;
}
else
{
existingPasswordFieldsCount
-
-
;
}
if
(
!
foundForcer
|
|
existingPasswordFieldsCount
>
0
)
{
return
;
}
SpecialPowers
.
removeObserver
(
observer
"
passwordmgr
-
processed
-
form
"
)
;
form
.
remove
(
)
;
SimpleTest
.
executeSoon
(
(
)
=
>
{
callback
?
.
(
)
;
resolve
(
)
;
}
)
;
}
)
;
SpecialPowers
.
addObserver
(
observer
"
passwordmgr
-
processed
-
form
"
)
;
document
.
body
.
appendChild
(
form
)
;
}
if
(
document
.
readyState
=
=
"
complete
"
|
|
document
.
readyState
=
=
"
interactive
"
)
{
onDOMContentLoaded
(
)
;
}
else
{
window
.
addEventListener
(
"
DOMContentLoaded
"
onDOMContentLoaded
)
;
}
}
)
;
}
function
enablePrimaryPassword
(
)
{
setPrimaryPassword
(
true
)
;
}
function
disablePrimaryPassword
(
)
{
setPrimaryPassword
(
false
)
;
}
function
setPrimaryPassword
(
enable
)
{
PWMGR_COMMON_PARENT
.
sendAsyncMessage
(
"
setPrimaryPassword
"
{
enable
}
)
;
}
function
isLoggedIn
(
)
{
return
PWMGR_COMMON_PARENT
.
sendQuery
(
"
isLoggedIn
"
)
;
}
function
logoutPrimaryPassword
(
)
{
runInParent
(
function
parent_logoutPrimaryPassword
(
)
{
var
sdr
=
Cc
[
"
mozilla
.
org
/
security
/
sdr
;
1
"
]
.
getService
(
Ci
.
nsISecretDecoderRing
)
;
sdr
.
logoutAndTeardown
(
)
;
}
)
;
}
function
promiseFormsProcessedInSameProcess
(
expectedCount
=
1
)
{
var
processedCount
=
0
;
return
new
Promise
(
resolve
=
>
{
function
onProcessedForm
(
subject
_topic
data
)
{
processedCount
+
+
;
if
(
processedCount
=
=
expectedCount
)
{
info
(
{
processedCount
}
form
(
s
)
processed
)
;
SpecialPowers
.
removeObserver
(
onProcessedForm
"
passwordmgr
-
processed
-
form
"
)
;
resolve
(
SpecialPowers
.
Cu
.
waiveXrays
(
subject
)
data
)
;
}
}
SpecialPowers
.
addObserver
(
onProcessedForm
"
passwordmgr
-
processed
-
form
"
)
;
}
)
;
}
async
function
promiseFormsProcessed
(
expectedCount
=
1
)
{
info
(
waiting
for
{
expectedCount
}
forms
to
be
processed
)
;
var
processedCount
=
0
;
return
new
Promise
(
resolve
=
>
{
PWMGR_COMMON_PARENT
.
addMessageListener
(
"
formProcessed
"
function
formProcessed
(
)
{
processedCount
+
+
;
info
(
processed
form
{
processedCount
}
of
{
expectedCount
}
)
;
if
(
processedCount
=
=
expectedCount
)
{
info
(
processing
of
{
expectedCount
}
forms
complete
)
;
PWMGR_COMMON_PARENT
.
removeMessageListener
(
"
formProcessed
"
formProcessed
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
async
function
loadFormIntoWindow
(
origin
html
win
expectedCount
=
1
task
)
{
let
loadedPromise
=
new
Promise
(
resolve
=
>
{
win
.
addEventListener
(
"
load
"
function
(
event
)
{
if
(
event
.
target
.
location
.
href
.
endsWith
(
"
blank
.
html
"
)
)
{
resolve
(
)
;
}
}
{
once
:
true
}
)
;
}
)
;
let
processedPromise
=
promiseFormsProcessed
(
expectedCount
)
;
win
.
location
=
origin
+
"
/
tests
/
toolkit
/
components
/
passwordmgr
/
test
/
mochitest
/
blank
.
html
"
;
info
(
Waiting
for
window
to
load
for
origin
:
{
origin
}
)
;
await
loadedPromise
;
await
SpecialPowers
.
spawn
(
win
[
html
task
?
.
toString
(
)
]
function
(
contentHtml
contentTask
=
null
)
{
this
.
content
.
document
.
documentElement
.
innerHTML
=
contentHtml
;
if
(
contentTask
)
{
const
runnableTask
=
eval
(
(
(
)
=
>
{
return
(
{
contentTask
}
)
;
}
)
(
)
;
)
;
runnableTask
.
call
(
this
)
;
}
}
)
;
info
(
"
Waiting
for
the
form
to
be
processed
"
)
;
await
processedPromise
;
}
async
function
getTelemetryEvents
(
options
)
{
let
events
=
await
PWMGR_COMMON_PARENT
.
sendQuery
(
"
getTelemetryEvents
"
options
)
;
info
(
"
CONTENT
:
getTelemetryEvents
gotResult
:
"
+
JSON
.
stringify
(
events
)
)
;
return
events
;
}
function
loadRecipes
(
recipes
)
{
info
(
"
Loading
recipes
"
)
;
return
PWMGR_COMMON_PARENT
.
sendQuery
(
"
loadRecipes
"
recipes
)
;
}
function
resetRecipes
(
)
{
info
(
"
Resetting
recipes
"
)
;
return
PWMGR_COMMON_PARENT
.
sendQuery
(
"
resetRecipes
"
)
;
}
async
function
promiseStorageChanged
(
expectedChangeTypes
)
{
let
result
=
await
PWMGR_COMMON_PARENT
.
sendQuery
(
"
storageChanged
"
{
expectedChangeTypes
}
)
;
if
(
result
)
{
ok
(
false
result
)
;
}
}
async
function
promisePromptShown
(
expectedTopic
)
{
let
topic
=
await
PWMGR_COMMON_PARENT
.
sendQuery
(
"
promptShown
"
)
;
is
(
topic
expectedTopic
"
Check
expected
prompt
topic
"
)
;
}
function
runInParent
(
aFunctionOrURL
)
{
let
chromeScript
=
SpecialPowers
.
loadChromeScript
(
aFunctionOrURL
)
;
SimpleTest
.
registerCleanupFunction
(
(
)
=
>
{
chromeScript
.
destroy
(
)
;
}
)
;
return
chromeScript
;
}
function
manageLoginsInParent
(
)
{
return
runInParent
(
function
addLoginsInParentInner
(
)
{
addMessageListener
(
"
removeAllUserFacingLogins
"
(
)
=
>
{
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
}
)
;
addMessageListener
(
"
getLogins
"
async
(
)
=
>
{
const
logins
=
await
Services
.
logins
.
getAllLogins
(
)
;
return
logins
.
map
(
(
{
origin
formActionOrigin
httpRealm
username
password
usernameField
passwordField
}
)
=
>
[
origin
formActionOrigin
httpRealm
username
password
usernameField
passwordField
]
)
;
}
)
;
addMessageListener
(
"
addLogins
"
async
logins
=
>
{
let
nsLoginInfo
=
Components
.
Constructor
(
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
Ci
.
nsILoginInfo
"
init
"
)
;
const
loginInfos
=
logins
.
map
(
login
=
>
new
nsLoginInfo
(
.
.
.
login
)
)
;
try
{
await
Services
.
logins
.
addLogins
(
loginInfos
)
;
}
catch
(
e
)
{
assert
.
ok
(
false
"
addLogins
threw
:
"
+
e
)
;
}
}
)
;
}
)
;
}
async
function
addLoginsInParent
(
.
.
.
aLogins
)
{
const
script
=
manageLoginsInParent
(
)
;
await
script
.
sendQuery
(
"
addLogins
"
aLogins
)
;
return
script
;
}
async
function
setStoredLoginsAsync
(
.
.
.
aLogins
)
{
const
script
=
manageLoginsInParent
(
)
;
script
.
sendQuery
(
"
removeAllUserFacingLogins
"
)
;
await
script
.
sendQuery
(
"
addLogins
"
aLogins
)
;
return
script
;
}
async
function
setStoredLoginsDuringTest
(
.
.
.
logins
)
{
const
script
=
manageLoginsInParent
(
)
;
const
loginsBefore
=
await
script
.
sendQuery
(
"
getLogins
"
)
;
await
script
.
sendQuery
(
"
removeAllUserFacingLogins
"
)
;
await
script
.
sendQuery
(
"
addLogins
"
logins
)
;
SimpleTest
.
registerCleanupFunction
(
async
(
)
=
>
{
await
script
.
sendQuery
(
"
removeAllUserFacingLogins
"
)
;
await
script
.
sendQuery
(
"
addLogins
"
loginsBefore
)
;
}
)
;
}
async
function
setStoredLoginsDuringTask
(
.
.
.
logins
)
{
const
script
=
manageLoginsInParent
(
)
;
const
loginsBefore
=
await
script
.
sendQuery
(
"
getLogins
"
)
;
await
script
.
sendQuery
(
"
removeAllUserFacingLogins
"
)
;
await
script
.
sendQuery
(
"
addLogins
"
logins
)
;
SimpleTest
.
registerTaskCleanupFunction
(
async
(
)
=
>
{
await
script
.
sendQuery
(
"
removeAllUserFacingLogins
"
)
;
await
script
.
sendQuery
(
"
addLogins
"
loginsBefore
)
;
}
)
;
}
function
getLogins
(
)
{
const
script
=
manageLoginsInParent
(
)
;
return
script
.
sendQuery
(
"
getLogins
"
)
;
}
var
gTestDependsOnDeprecatedLogin
=
false
;
function
setFormAndWaitForFieldFilled
(
form
{
fieldSelector
fieldValue
formId
}
)
{
document
.
querySelector
(
"
#
content
"
)
.
innerHTML
=
form
;
return
SimpleTest
.
promiseWaitForCondition
(
(
)
=
>
{
let
ancestor
=
formId
?
document
.
querySelector
(
"
#
"
+
formId
)
:
document
.
documentElement
;
return
ancestor
.
querySelector
(
fieldSelector
)
.
value
=
=
fieldValue
;
}
"
Wait
for
password
manager
to
fill
form
"
)
;
}
async
function
runChecksAfterCommonInit
(
aFunction
=
null
)
{
SimpleTest
.
waitForExplicitFinish
(
)
;
await
PWMGR_COMMON_PARENT
.
sendQuery
(
"
setupParent
"
{
testDependsOnDeprecatedLogin
:
gTestDependsOnDeprecatedLogin
}
)
;
if
(
aFunction
)
{
await
registerRunTests
(
0
aFunction
)
;
}
return
PWMGR_COMMON_PARENT
;
}
const
PWMGR_COMMON_PARENT
=
runInParent
(
SimpleTest
.
getTestFileURL
(
"
pwmgr_common_parent
.
js
"
)
)
;
SimpleTest
.
registerCleanupFunction
(
(
)
=
>
{
SpecialPowers
.
flushPrefEnv
(
)
;
PWMGR_COMMON_PARENT
.
sendAsyncMessage
(
"
cleanup
"
)
;
runInParent
(
function
cleanupParent
(
)
{
const
{
LoginManagerParent
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
LoginManagerParent
.
sys
.
mjs
"
)
;
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
let
disabledHosts
=
Services
.
logins
.
getAllDisabledHosts
(
)
;
disabledHosts
.
forEach
(
host
=
>
Services
.
logins
.
setLoginSavingEnabled
(
host
true
)
)
;
let
authMgr
=
Cc
[
"
mozilla
.
org
/
network
/
http
-
auth
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIHttpAuthManager
)
;
authMgr
.
clearAll
(
)
;
if
(
LoginManagerParent
.
_recipeManager
!
=
=
null
)
{
LoginManagerParent
.
_recipeManager
.
reset
(
)
;
}
let
chromeWin
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
chromeWin
&
&
chromeWin
.
PopupNotifications
)
{
let
notes
=
chromeWin
.
PopupNotifications
.
_currentNotifications
;
if
(
notes
.
length
)
{
dump
(
"
Removing
"
+
notes
.
length
+
"
popup
notifications
.
\
n
"
)
;
}
for
(
let
note
of
notes
)
{
note
.
remove
(
)
;
}
}
Services
.
telemetry
.
clearEvents
(
)
;
}
)
;
}
)
;
function
loginToVanillaObject
(
login
)
{
let
obj
=
{
}
;
for
(
let
i
in
SpecialPowers
.
do_QueryInterface
(
login
SpecialPowers
.
Ci
.
nsILoginMetaInfo
)
)
{
if
(
typeof
login
[
i
]
!
=
=
"
function
"
)
{
obj
[
i
]
=
login
[
i
]
;
}
}
return
obj
;
}
this
.
LoginManager
=
new
Proxy
(
{
}
{
get
(
_target
prop
_receiver
)
{
return
(
.
.
.
args
)
=
>
{
let
loginInfoIndices
=
[
]
;
let
cloneableArgs
=
args
.
map
(
(
val
index
)
=
>
{
if
(
SpecialPowers
.
call_Instanceof
(
val
SpecialPowers
.
Ci
.
nsILoginInfo
)
)
{
loginInfoIndices
.
push
(
index
)
;
return
loginToVanillaObject
(
val
)
;
}
return
val
;
}
)
;
return
PWMGR_COMMON_PARENT
.
sendQuery
(
"
proxyLoginManager
"
{
args
:
cloneableArgs
loginInfoIndices
methodName
:
prop
}
)
;
}
;
}
}
)
;
function
setContentForTask
(
html
)
{
const
content
=
document
.
querySelector
(
"
#
content
"
)
;
const
innerHTMLBefore
=
content
.
innerHTML
|
|
"
"
;
SimpleTest
.
registerCurrentTaskCleanupFunction
(
(
)
=
>
(
content
.
innerHTML
=
innerHTMLBefore
)
)
;
if
(
html
.
content
?
.
cloneNode
)
{
const
clone
=
html
.
content
.
cloneNode
(
true
)
;
content
.
replaceChildren
(
clone
)
;
}
else
{
content
.
innerHTML
=
html
;
}
return
content
.
firstElementChild
;
}
async
function
setPreferencesForTask
(
.
.
.
preferences
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
preferences
}
)
;
SimpleTest
.
registerCurrentTaskCleanupFunction
(
(
)
=
>
SpecialPowers
.
popPrefEnv
)
;
}
let
gPwmgrCommonCapturedAutofillResults
=
{
}
;
PWMGR_COMMON_PARENT
.
addMessageListener
(
"
formProcessed
"
(
{
formId
autofillResult
}
)
=
>
{
if
(
formId
=
=
=
"
observerforcer
"
)
{
return
;
}
gPwmgrCommonCapturedAutofillResults
[
formId
]
=
autofillResult
;
}
)
;
SimpleTest
.
registerTaskCleanupFunction
(
(
)
=
>
{
gPwmgrCommonCapturedAutofillResults
=
{
}
;
}
)
;
async
function
formAutofillResult
(
formId
)
{
if
(
formId
in
gPwmgrCommonCapturedAutofillResults
)
{
const
autofillResult
=
gPwmgrCommonCapturedAutofillResults
[
formId
]
;
delete
gPwmgrCommonCapturedAutofillResults
[
formId
]
;
return
autofillResult
;
}
return
new
Promise
(
resolve
=
>
{
PWMGR_COMMON_PARENT
.
addMessageListener
(
"
formProcessed
"
(
{
formId
:
id
autofillResult
}
)
=
>
{
if
(
id
!
=
=
formId
)
{
return
;
}
delete
gPwmgrCommonCapturedAutofillResults
[
formId
]
;
resolve
(
autofillResult
)
;
}
{
once
:
true
}
)
;
}
)
;
}
