"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginStore
"
"
resource
:
/
/
gre
/
modules
/
LoginStore
.
jsm
"
)
;
const
{
TestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
;
const
{
TelemetryTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
)
;
const
rawLogin1
=
{
id
:
1
hostname
:
"
http
:
/
/
www
.
example
.
com
"
httpRealm
:
null
formSubmitURL
:
"
http
:
/
/
www
.
example
.
com
"
usernameField
:
"
field_
"
+
String
.
fromCharCode
(
533
537
7570
345
)
passwordField
:
"
field_
"
+
String
.
fromCharCode
(
421
259
349
537
)
encryptedUsername
:
"
(
test
)
"
encryptedPassword
:
"
(
test
)
"
guid
:
"
(
test
)
"
encType
:
Ci
.
nsILoginManagerCrypto
.
ENCTYPE_SDR
timeCreated
:
Date
.
now
(
)
timeLastUsed
:
Date
.
now
(
)
timePasswordChanged
:
Date
.
now
(
)
timesUsed
:
1
}
;
const
rawLogin2
=
{
id
:
2
hostname
:
"
http
:
/
/
www
.
example2
.
com
"
httpRealm
:
null
formSubmitURL
:
"
http
:
/
/
www
.
example2
.
com
"
usernameField
:
"
field_2
"
+
String
.
fromCharCode
(
533
537
7570
345
)
passwordField
:
"
field_2
"
+
String
.
fromCharCode
(
421
259
349
537
)
encryptedUsername
:
"
(
test2
)
"
encryptedPassword
:
"
(
test2
)
"
guid
:
"
(
test2
)
"
encType
:
Ci
.
nsILoginManagerCrypto
.
ENCTYPE_SDR
timeCreated
:
Date
.
now
(
)
timeLastUsed
:
Date
.
now
(
)
timePasswordChanged
:
Date
.
now
(
)
timesUsed
:
1
}
;
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
telemetry
.
testing
.
overrideProductsCheck
"
true
)
;
add_task
(
async
function
test_logins_store_missing_or_corrupt_with_backup
(
)
{
let
loginsStorePath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
logins
.
json
"
)
;
let
loginsStoreBackup
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
logins
-
backup
.
json
"
)
;
let
store
=
new
LoginStore
(
loginsStorePath
loginsStoreBackup
)
;
await
store
.
load
(
)
;
Assert
.
equal
(
false
await
OS
.
File
.
exists
(
store
.
path
)
)
;
Assert
.
equal
(
false
await
OS
.
File
.
exists
(
store
.
_options
.
backupTo
)
)
;
store
.
data
.
logins
.
push
(
rawLogin1
)
;
await
store
.
_save
(
)
;
Assert
.
equal
(
true
await
OS
.
File
.
exists
(
store
.
path
)
)
;
store
.
data
.
logins
.
push
(
rawLogin2
)
;
await
store
.
_save
(
)
;
Assert
.
equal
(
true
await
OS
.
File
.
exists
(
store
.
_options
.
backupTo
)
)
;
await
OS
.
File
.
remove
(
store
.
path
)
;
store
.
data
.
logins
=
[
]
;
store
.
dataReady
=
false
;
Assert
.
equal
(
false
await
OS
.
File
.
exists
(
store
.
path
)
)
;
Assert
.
equal
(
true
await
OS
.
File
.
exists
(
store
.
_options
.
backupTo
)
)
;
Services
.
telemetry
.
clearEvents
(
)
;
await
store
.
load
(
)
;
await
OS
.
File
.
exists
(
store
.
path
)
;
Assert
.
equal
(
true
await
OS
.
File
.
exists
(
store
.
_options
.
backupTo
)
)
;
Assert
.
equal
(
store
.
data
.
logins
.
length
1
"
Logins
backup
was
used
successfully
when
logins
.
json
was
missing
"
)
;
TelemetryTestUtils
.
assertEvents
(
[
[
"
jsonfile
"
"
load
"
"
logins
"
]
[
"
jsonfile
"
"
load
"
"
logins
"
"
used_backup
"
]
]
{
}
{
clear
:
true
}
)
;
info
(
"
Telemetry
was
recorded
accurately
when
logins
-
backup
.
json
is
used
when
logins
.
json
was
missing
"
)
;
let
string
=
'
{
"
logins
"
:
[
{
"
hostname
"
:
"
http
:
/
/
www
.
example
.
com
"
"
id
"
:
1
'
;
await
OS
.
File
.
writeAtomic
(
store
.
path
new
TextEncoder
(
)
.
encode
(
string
)
{
tmpPath
:
store
.
path
+
"
.
tmp
"
}
)
;
Services
.
telemetry
.
clearEvents
(
)
;
store
.
data
.
logins
=
[
]
;
store
.
dataReady
=
false
;
await
store
.
load
(
)
;
await
OS
.
File
.
exists
(
store
.
path
+
"
.
corrupt
"
)
;
await
OS
.
File
.
exists
(
store
.
path
)
;
Assert
.
equal
(
true
await
OS
.
File
.
exists
(
store
.
_options
.
backupTo
)
)
;
Assert
.
equal
(
store
.
data
.
logins
.
length
1
"
Logins
backup
was
used
successfully
when
logins
.
json
was
corrupt
"
)
;
TelemetryTestUtils
.
assertEvents
(
[
[
"
jsonfile
"
"
load
"
"
logins
"
"
"
]
[
"
jsonfile
"
"
load
"
"
logins
"
"
invalid_json
"
]
[
"
jsonfile
"
"
load
"
"
logins
"
"
used_backup
"
]
]
{
}
{
clear
:
true
}
)
;
info
(
"
Telemetry
was
recorded
accurately
when
logins
-
backup
.
json
is
used
when
logins
.
json
was
corrupt
"
)
;
await
OS
.
File
.
remove
(
store
.
path
+
"
.
corrupt
"
)
;
await
OS
.
File
.
remove
(
store
.
path
)
;
store
.
data
.
logins
=
[
]
;
store
.
dataReady
=
false
;
Assert
.
equal
(
false
await
OS
.
File
.
exists
(
store
.
path
)
)
;
Assert
.
equal
(
true
await
OS
.
File
.
exists
(
store
.
_options
.
backupTo
)
)
;
store
.
ensureDataReady
(
)
;
await
OS
.
File
.
exists
(
store
.
path
)
;
Assert
.
equal
(
true
await
OS
.
File
.
exists
(
store
.
_options
.
backupTo
)
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
store
.
data
.
logins
.
length
=
=
1
;
}
)
;
await
OS
.
File
.
writeAtomic
(
store
.
path
new
TextEncoder
(
)
.
encode
(
string
)
{
tmpPath
:
store
.
path
+
"
.
tmp
"
}
)
;
store
.
data
.
logins
=
[
]
;
store
.
dataReady
=
false
;
store
.
ensureDataReady
(
)
;
Assert
.
equal
(
true
await
OS
.
File
.
exists
(
store
.
path
+
"
.
corrupt
"
)
)
;
await
OS
.
File
.
exists
(
store
.
path
)
;
Assert
.
equal
(
true
await
OS
.
File
.
exists
(
store
.
_options
.
backupTo
)
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
store
.
data
.
logins
.
length
=
=
1
;
}
)
;
}
)
;
