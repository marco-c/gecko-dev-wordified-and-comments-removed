"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginStore
"
"
resource
:
/
/
gre
/
modules
/
LoginStore
.
jsm
"
)
;
const
TEST_STORE_FILE_NAME
=
"
test
-
logins
.
json
"
;
add_task
(
async
function
test_save_reload
(
)
{
let
storeForSave
=
new
LoginStore
(
getTempFile
(
TEST_STORE_FILE_NAME
)
.
path
)
;
await
storeForSave
.
load
(
)
;
let
rawLoginData
=
{
id
:
storeForSave
.
data
.
nextId
+
+
hostname
:
"
http
:
/
/
www
.
example
.
com
"
httpRealm
:
null
formSubmitURL
:
"
http
:
/
/
www
.
example
.
com
"
usernameField
:
"
field_
"
+
String
.
fromCharCode
(
533
537
7570
345
)
passwordField
:
"
field_
"
+
String
.
fromCharCode
(
421
259
349
537
)
encryptedUsername
:
"
(
test
)
"
encryptedPassword
:
"
(
test
)
"
guid
:
"
(
test
)
"
encType
:
Ci
.
nsILoginManagerCrypto
.
ENCTYPE_SDR
timeCreated
:
Date
.
now
(
)
timeLastUsed
:
Date
.
now
(
)
timePasswordChanged
:
Date
.
now
(
)
timesUsed
:
1
}
;
storeForSave
.
data
.
logins
.
push
(
rawLoginData
)
;
await
storeForSave
.
_save
(
)
;
let
storeForLoad
=
new
LoginStore
(
storeForSave
.
path
)
;
await
storeForLoad
.
load
(
)
;
Assert
.
equal
(
storeForLoad
.
data
.
logins
.
length
1
)
;
Assert
.
deepEqual
(
storeForLoad
.
data
.
logins
[
0
]
rawLoginData
)
;
storeForLoad
=
new
LoginStore
(
storeForSave
.
path
)
;
storeForLoad
.
ensureDataReady
(
)
;
Assert
.
equal
(
storeForLoad
.
data
.
logins
.
length
1
)
;
Assert
.
deepEqual
(
storeForLoad
.
data
.
logins
[
0
]
rawLoginData
)
;
}
)
;
add_task
(
async
function
test_load_empty
(
)
{
let
store
=
new
LoginStore
(
getTempFile
(
TEST_STORE_FILE_NAME
)
.
path
)
;
Assert
.
equal
(
false
await
OS
.
File
.
exists
(
store
.
path
)
)
;
await
store
.
load
(
)
;
Assert
.
equal
(
false
await
OS
.
File
.
exists
(
store
.
path
)
)
;
Assert
.
equal
(
store
.
data
.
logins
.
length
0
)
;
}
)
;
add_task
(
async
function
test_save_empty
(
)
{
let
store
=
new
LoginStore
(
getTempFile
(
TEST_STORE_FILE_NAME
)
.
path
)
;
await
store
.
load
(
)
;
let
createdFile
=
await
OS
.
File
.
open
(
store
.
path
{
create
:
true
}
)
;
await
createdFile
.
close
(
)
;
await
store
.
_save
(
)
;
Assert
.
ok
(
await
OS
.
File
.
exists
(
store
.
path
)
)
;
}
)
;
add_task
(
async
function
test_load_string_predefined
(
)
{
let
store
=
new
LoginStore
(
getTempFile
(
TEST_STORE_FILE_NAME
)
.
path
)
;
let
string
=
'
{
"
logins
"
:
[
{
'
+
'
"
id
"
:
1
'
+
'
"
hostname
"
:
"
http
:
/
/
www
.
example
.
com
"
'
+
'
"
httpRealm
"
:
null
'
+
'
"
formSubmitURL
"
:
"
http
:
/
/
www
.
example
.
com
"
'
+
'
"
usernameField
"
:
"
usernameField
"
'
+
'
"
passwordField
"
:
"
passwordField
"
'
+
'
"
encryptedUsername
"
:
"
(
test
)
"
'
+
'
"
encryptedPassword
"
:
"
(
test
)
"
'
+
'
"
guid
"
:
"
(
test
)
"
'
+
'
"
encType
"
:
1
'
+
'
"
timeCreated
"
:
1262304000000
'
+
'
"
timeLastUsed
"
:
1262390400000
'
+
'
"
timePasswordChanged
"
:
1262476800000
'
+
'
"
timesUsed
"
:
1
}
]
"
disabledHosts
"
:
[
'
+
'
"
http
:
/
/
www
.
example
.
org
"
]
}
'
;
await
OS
.
File
.
writeAtomic
(
store
.
path
new
TextEncoder
(
)
.
encode
(
string
)
{
tmpPath
:
store
.
path
+
"
.
tmp
"
}
)
;
await
store
.
load
(
)
;
Assert
.
equal
(
store
.
data
.
logins
.
length
1
)
;
Assert
.
deepEqual
(
store
.
data
.
logins
[
0
]
{
id
:
1
hostname
:
"
http
:
/
/
www
.
example
.
com
"
httpRealm
:
null
formSubmitURL
:
"
http
:
/
/
www
.
example
.
com
"
usernameField
:
"
usernameField
"
passwordField
:
"
passwordField
"
encryptedUsername
:
"
(
test
)
"
encryptedPassword
:
"
(
test
)
"
guid
:
"
(
test
)
"
encType
:
Ci
.
nsILoginManagerCrypto
.
ENCTYPE_SDR
timeCreated
:
1262304000000
timeLastUsed
:
1262390400000
timePasswordChanged
:
1262476800000
timesUsed
:
1
}
)
;
}
)
;
add_task
(
async
function
test_load_string_malformed
(
)
{
let
store
=
new
LoginStore
(
getTempFile
(
TEST_STORE_FILE_NAME
)
.
path
)
;
let
string
=
'
{
"
logins
"
:
[
{
"
hostname
"
:
"
http
:
/
/
www
.
example
.
com
"
'
+
'
"
id
"
:
1
'
;
await
OS
.
File
.
writeAtomic
(
store
.
path
new
TextEncoder
(
)
.
encode
(
string
)
{
tmpPath
:
store
.
path
+
"
.
tmp
"
}
)
;
await
store
.
load
(
)
;
Assert
.
ok
(
await
OS
.
File
.
exists
(
store
.
path
+
"
.
corrupt
"
)
)
;
await
OS
.
File
.
remove
(
store
.
path
+
"
.
corrupt
"
)
;
Assert
.
equal
(
store
.
data
.
logins
.
length
0
)
;
}
)
;
add_task
(
async
function
test_load_string_malformed_sync
(
)
{
let
store
=
new
LoginStore
(
getTempFile
(
TEST_STORE_FILE_NAME
)
.
path
)
;
let
string
=
'
{
"
logins
"
:
[
{
"
hostname
"
:
"
http
:
/
/
www
.
example
.
com
"
'
+
'
"
id
"
:
1
'
;
await
OS
.
File
.
writeAtomic
(
store
.
path
new
TextEncoder
(
)
.
encode
(
string
)
{
tmpPath
:
store
.
path
+
"
.
tmp
"
}
)
;
store
.
ensureDataReady
(
)
;
Assert
.
ok
(
await
OS
.
File
.
exists
(
store
.
path
+
"
.
corrupt
"
)
)
;
await
OS
.
File
.
remove
(
store
.
path
+
"
.
corrupt
"
)
;
Assert
.
equal
(
store
.
data
.
logins
.
length
0
)
;
}
)
;
