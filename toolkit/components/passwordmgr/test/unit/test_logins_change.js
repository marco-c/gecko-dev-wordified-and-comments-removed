"
use
strict
"
;
const
MAX_DATE_MS
=
8640000000000000
;
async
function
checkLoginInvalid
(
aLoginInfo
aExpectedError
)
{
await
Assert
.
rejects
(
Services
.
logins
.
addLoginAsync
(
aLoginInfo
)
aExpectedError
)
;
LoginTestUtils
.
checkLogins
(
[
]
)
;
let
testLogin
=
TestData
.
formLogin
(
{
origin
:
"
http
:
/
/
modify
.
example
.
com
"
}
)
;
await
Services
.
logins
.
addLoginAsync
(
testLogin
)
;
Assert
.
throws
(
(
)
=
>
Services
.
logins
.
modifyLogin
(
testLogin
aLoginInfo
)
aExpectedError
)
;
Assert
.
throws
(
(
)
=
>
Services
.
logins
.
modifyLogin
(
testLogin
newPropertyBag
(
{
origin
:
aLoginInfo
.
origin
formActionOrigin
:
aLoginInfo
.
formActionOrigin
httpRealm
:
aLoginInfo
.
httpRealm
username
:
aLoginInfo
.
username
password
:
aLoginInfo
.
password
usernameField
:
aLoginInfo
.
usernameField
passwordField
:
aLoginInfo
.
passwordField
}
)
)
aExpectedError
)
;
LoginTestUtils
.
checkLogins
(
[
testLogin
]
)
;
Services
.
logins
.
removeLogin
(
testLogin
)
;
}
function
compareAttributes
(
objectA
objectB
attributes
)
{
if
(
objectA
=
=
objectB
)
{
return
false
;
}
return
attributes
.
every
(
attr
=
>
objectA
[
attr
]
=
=
objectB
[
attr
]
)
;
}
add_task
(
async
function
test_addLogin_removeLogin
(
)
{
await
Services
.
logins
.
addLogins
(
TestData
.
loginList
(
)
)
;
LoginTestUtils
.
checkLogins
(
TestData
.
loginList
(
)
)
;
for
(
let
loginInfo
of
TestData
.
loginList
(
)
)
{
await
Assert
.
rejects
(
Services
.
logins
.
addLoginAsync
(
loginInfo
)
/
This
login
already
exists
.
/
)
;
}
for
(
let
loginInfo
of
TestData
.
loginList
(
)
)
{
Services
.
logins
.
removeLogin
(
loginInfo
)
;
}
LoginTestUtils
.
checkLogins
(
[
]
)
;
}
)
;
add_task
(
async
function
add_login_works_with_empty_array
(
)
{
const
result
=
await
Services
.
logins
.
addLogins
(
[
]
)
;
Assert
.
equal
(
result
.
length
0
"
no
logins
added
"
)
;
}
)
;
add_task
(
async
function
duplicated_logins_are_not_added
(
)
{
const
login
=
TestData
.
formLogin
(
{
username
:
"
user
"
}
)
;
await
Services
.
logins
.
addLogins
(
[
login
]
)
;
const
result
=
await
Services
.
logins
.
addLogins
(
[
login
]
)
;
Assert
.
equal
(
result
0
"
no
logins
added
"
)
;
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
}
)
;
add_task
(
async
function
logins_containing_nul_in_username_are_not_added
(
)
{
const
result
=
await
Services
.
logins
.
addLogins
(
[
TestData
.
formLogin
(
{
username
:
"
user
\
0name
"
}
)
]
)
;
Assert
.
equal
(
result
0
"
no
logins
added
"
)
;
}
)
;
add_task
(
async
function
logins_containing_nul_in_password_are_not_added
(
)
{
const
result
=
await
Services
.
logins
.
addLogins
(
[
TestData
.
formLogin
(
{
password
:
"
pass
\
0word
"
}
)
]
)
;
Assert
.
equal
(
result
0
"
no
logins
added
"
)
;
}
)
;
add_task
(
async
function
return_value_includes_plaintext_username_and_password
(
)
{
const
login
=
TestData
.
formLogin
(
{
}
)
;
const
[
result
]
=
await
Services
.
logins
.
addLogins
(
[
login
]
)
;
Assert
.
equal
(
result
.
username
login
.
username
"
plaintext
username
is
set
"
)
;
Assert
.
equal
(
result
.
password
login
.
password
"
plaintext
password
is
set
"
)
;
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
}
)
;
add_task
(
async
function
event_data_includes_plaintext_username_and_password
(
)
{
const
login
=
TestData
.
formLogin
(
{
}
)
;
const
TestObserver
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
observe
(
subject
topic
data
)
{
Assert
.
ok
(
subject
instanceof
Ci
.
nsILoginInfo
)
;
Assert
.
ok
(
subject
instanceof
Ci
.
nsILoginMetaInfo
)
;
Assert
.
equal
(
subject
.
username
login
.
username
"
plaintext
username
is
set
"
)
;
Assert
.
equal
(
subject
.
password
login
.
password
"
plaintext
password
is
set
"
)
;
}
}
;
Services
.
obs
.
addObserver
(
TestObserver
"
passwordmgr
-
storage
-
changed
"
)
;
await
Services
.
logins
.
addLogins
(
[
login
]
)
;
Services
.
obs
.
removeObserver
(
TestObserver
"
passwordmgr
-
storage
-
changed
"
)
;
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
}
)
;
add_task
(
async
function
test_invalid_httpRealm_formActionOrigin
(
)
{
await
checkLoginInvalid
(
TestData
.
formLogin
(
{
formActionOrigin
:
null
}
)
/
without
a
httpRealm
or
formActionOrigin
/
)
;
await
checkLoginInvalid
(
TestData
.
authLogin
(
{
httpRealm
:
"
"
}
)
/
without
a
httpRealm
or
formActionOrigin
/
)
;
let
login
=
TestData
.
formLogin
(
{
formActionOrigin
:
"
"
}
)
;
login
.
httpRealm
=
"
"
;
await
checkLoginInvalid
(
login
/
both
a
httpRealm
and
formActionOrigin
/
)
;
login
=
TestData
.
formLogin
(
)
;
login
.
httpRealm
=
"
The
HTTP
Realm
"
;
await
checkLoginInvalid
(
login
/
both
a
httpRealm
and
formActionOrigin
/
)
;
login
=
TestData
.
formLogin
(
)
;
login
.
httpRealm
=
"
"
;
await
checkLoginInvalid
(
login
/
both
a
httpRealm
and
formActionOrigin
/
)
;
login
=
TestData
.
authLogin
(
)
;
login
.
formActionOrigin
=
"
"
;
await
checkLoginInvalid
(
login
/
both
a
httpRealm
and
formActionOrigin
/
)
;
}
)
;
add_task
(
async
function
test_missing_properties
(
)
{
await
checkLoginInvalid
(
TestData
.
formLogin
(
{
origin
:
null
}
)
/
null
or
empty
origin
/
)
;
await
checkLoginInvalid
(
TestData
.
formLogin
(
{
origin
:
"
"
}
)
/
null
or
empty
origin
/
)
;
await
checkLoginInvalid
(
TestData
.
formLogin
(
{
username
:
null
}
)
/
null
username
/
)
;
await
checkLoginInvalid
(
TestData
.
formLogin
(
{
password
:
null
}
)
/
null
or
empty
password
/
)
;
await
checkLoginInvalid
(
TestData
.
formLogin
(
{
password
:
"
"
}
)
/
null
or
empty
password
/
)
;
}
)
;
add_task
(
async
function
test_invalid_characters
(
)
{
let
loginList
=
[
TestData
.
authLogin
(
{
origin
:
"
http
:
/
/
null
\
0X
.
example
.
com
"
}
)
TestData
.
authLogin
(
{
httpRealm
:
"
realm
\
0
"
}
)
TestData
.
formLogin
(
{
formActionOrigin
:
"
http
:
/
/
null
\
0X
.
example
.
com
"
}
)
TestData
.
formLogin
(
{
usernameField
:
"
field
\
0_null
"
}
)
TestData
.
formLogin
(
{
usernameField
:
"
.
\
0
"
}
)
TestData
.
formLogin
(
{
passwordField
:
"
field
\
0_null
"
}
)
TestData
.
formLogin
(
{
username
:
"
user
\
0name
"
}
)
TestData
.
formLogin
(
{
password
:
"
pass
\
0word
"
}
)
]
;
for
(
let
loginInfo
of
loginList
)
{
await
checkLoginInvalid
(
loginInfo
/
login
values
can
'
t
contain
nulls
/
)
;
}
}
)
;
add_task
(
function
test_removeLogin_nonexisting
(
)
{
Assert
.
throws
(
(
)
=
>
Services
.
logins
.
removeLogin
(
TestData
.
formLogin
(
)
)
/
No
matching
logins
/
)
;
}
)
;
add_task
(
async
function
test_removeAllUserFacingLogins
(
)
{
await
Services
.
logins
.
addLogins
(
TestData
.
loginList
(
)
)
;
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
LoginTestUtils
.
checkLogins
(
[
]
)
;
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
}
)
;
add_task
(
async
function
test_modifyLogin_nsILoginInfo
(
)
{
let
loginInfo
=
TestData
.
formLogin
(
)
;
let
updatedLoginInfo
=
TestData
.
formLogin
(
{
username
:
"
new
username
"
password
:
"
new
password
"
usernameField
:
"
new_form_field_username
"
passwordField
:
"
new_form_field_password
"
}
)
;
let
differentLoginInfo
=
TestData
.
authLogin
(
)
;
Assert
.
throws
(
(
)
=
>
Services
.
logins
.
modifyLogin
(
loginInfo
updatedLoginInfo
)
/
No
matching
logins
/
)
;
await
Services
.
logins
.
addLoginAsync
(
loginInfo
)
;
Services
.
logins
.
modifyLogin
(
loginInfo
updatedLoginInfo
)
;
LoginTestUtils
.
checkLogins
(
[
updatedLoginInfo
]
)
;
Assert
.
throws
(
(
)
=
>
Services
.
logins
.
modifyLogin
(
loginInfo
updatedLoginInfo
)
/
No
matching
logins
/
)
;
Services
.
logins
.
modifyLogin
(
updatedLoginInfo
differentLoginInfo
)
;
LoginTestUtils
.
checkLogins
(
[
differentLoginInfo
]
)
;
await
Services
.
logins
.
addLoginAsync
(
loginInfo
)
;
LoginTestUtils
.
checkLogins
(
[
loginInfo
differentLoginInfo
]
)
;
Assert
.
throws
(
(
)
=
>
Services
.
logins
.
modifyLogin
(
loginInfo
differentLoginInfo
)
/
already
exists
/
)
;
LoginTestUtils
.
checkLogins
(
[
loginInfo
differentLoginInfo
]
)
;
LoginTestUtils
.
clearData
(
)
;
}
)
;
add_task
(
async
function
test_modifyLogin_nsIProperyBag
(
)
{
let
loginInfo
=
TestData
.
formLogin
(
)
;
let
updatedLoginInfo
=
TestData
.
formLogin
(
{
username
:
"
new
username
"
password
:
"
new
password
"
usernameField
:
"
"
passwordField
:
"
new_form_field_password
"
}
)
;
let
differentLoginInfo
=
TestData
.
authLogin
(
)
;
let
differentLoginProperties
=
newPropertyBag
(
{
origin
:
differentLoginInfo
.
origin
formActionOrigin
:
differentLoginInfo
.
formActionOrigin
httpRealm
:
differentLoginInfo
.
httpRealm
username
:
differentLoginInfo
.
username
password
:
differentLoginInfo
.
password
usernameField
:
differentLoginInfo
.
usernameField
passwordField
:
differentLoginInfo
.
passwordField
}
)
;
Assert
.
throws
(
(
)
=
>
Services
.
logins
.
modifyLogin
(
loginInfo
newPropertyBag
(
)
)
/
No
matching
logins
/
)
;
await
Services
.
logins
.
addLoginAsync
(
loginInfo
)
;
Services
.
logins
.
modifyLogin
(
loginInfo
newPropertyBag
(
{
username
:
"
new
username
"
password
:
"
new
password
"
usernameField
:
"
"
passwordField
:
"
new_form_field_password
"
}
)
)
;
LoginTestUtils
.
checkLogins
(
[
updatedLoginInfo
]
)
;
Assert
.
throws
(
(
)
=
>
Services
.
logins
.
modifyLogin
(
loginInfo
newPropertyBag
(
)
)
/
No
matching
logins
/
)
;
Services
.
logins
.
modifyLogin
(
updatedLoginInfo
newPropertyBag
(
)
)
;
Assert
.
throws
(
(
)
=
>
Services
.
logins
.
modifyLogin
(
loginInfo
newPropertyBag
(
{
usernameField
:
null
}
)
)
/
No
matching
logins
/
)
;
Services
.
logins
.
modifyLogin
(
updatedLoginInfo
differentLoginProperties
)
;
LoginTestUtils
.
checkLogins
(
[
differentLoginInfo
]
)
;
await
Services
.
logins
.
addLoginAsync
(
loginInfo
)
;
LoginTestUtils
.
checkLogins
(
[
loginInfo
differentLoginInfo
]
)
;
Assert
.
throws
(
(
)
=
>
Services
.
logins
.
modifyLogin
(
loginInfo
differentLoginProperties
)
/
already
exists
/
)
;
LoginTestUtils
.
checkLogins
(
[
loginInfo
differentLoginInfo
]
)
;
LoginTestUtils
.
clearData
(
)
;
}
)
;
add_task
(
function
test_deduplicate_logins
(
)
{
let
keyCombinations
=
[
{
keyset
:
[
"
username
"
"
password
"
]
results
:
17
}
{
keyset
:
[
"
origin
"
"
username
"
]
results
:
21
}
{
keyset
:
[
"
origin
"
"
username
"
"
password
"
]
results
:
22
}
{
keyset
:
[
"
origin
"
"
username
"
"
password
"
"
formActionOrigin
"
]
results
:
27
}
]
;
let
logins
=
TestData
.
loginList
(
)
;
for
(
let
testCase
of
keyCombinations
)
{
let
deduped
=
LoginHelper
.
dedupeLogins
(
logins
testCase
.
keyset
)
;
Assert
.
equal
(
deduped
.
length
testCase
.
results
"
Correct
amount
of
results
.
"
)
;
Assert
.
ok
(
deduped
.
every
(
loginA
=
>
deduped
.
every
(
loginB
=
>
!
compareAttributes
(
loginA
loginB
testCase
.
keyset
)
)
)
"
Every
login
is
unique
.
"
)
;
}
}
)
;
add_task
(
function
test_deduplicate_keeps_most_recent
(
)
{
let
logins
=
[
TestData
.
formLogin
(
{
timeLastUsed
:
Date
.
UTC
(
2004
11
4
0
0
0
)
}
)
TestData
.
formLogin
(
{
formActionOrigin
:
"
http
:
/
/
example
.
com
"
timeLastUsed
:
Date
.
UTC
(
2015
11
4
0
0
0
)
}
)
]
;
let
deduped
=
LoginHelper
.
dedupeLogins
(
logins
)
;
Assert
.
equal
(
deduped
.
length
1
"
Deduplicated
the
logins
array
.
"
)
;
let
loginTimeLastUsed
=
deduped
[
0
]
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
.
timeLastUsed
;
Assert
.
equal
(
loginTimeLastUsed
Date
.
UTC
(
2015
11
4
0
0
0
)
"
Most
recent
login
was
kept
.
"
)
;
deduped
=
LoginHelper
.
dedupeLogins
(
logins
.
reverse
(
)
)
;
Assert
.
equal
(
deduped
.
length
1
"
Deduplicated
the
reversed
logins
array
.
"
)
;
loginTimeLastUsed
=
deduped
[
0
]
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
.
timeLastUsed
;
Assert
.
equal
(
loginTimeLastUsed
Date
.
UTC
(
2015
11
4
0
0
0
)
"
Most
recent
login
was
kept
.
"
)
;
}
)
;
add_task
(
async
function
test_addLogin_badDates
(
)
{
LoginTestUtils
.
clearData
(
)
;
let
now
=
Date
.
now
(
)
;
let
defaultLoginDates
=
{
timeCreated
:
now
timeLastUsed
:
now
timePasswordChanged
:
now
}
;
let
defaultsLogin
=
TestData
.
formLogin
(
)
;
for
(
let
pname
of
[
"
timeCreated
"
"
timeLastUsed
"
"
timePasswordChanged
"
]
)
{
Assert
.
ok
(
!
defaultsLogin
[
pname
]
)
;
}
Assert
.
ok
(
!
!
(
await
Services
.
logins
.
addLoginAsync
(
defaultsLogin
)
)
"
Sanity
check
adding
defaults
formLogin
"
)
;
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
for
(
let
pname
of
[
"
timeCreated
"
"
timeLastUsed
"
"
timePasswordChanged
"
]
)
{
let
loginInfo
=
TestData
.
formLogin
(
Object
.
assign
(
{
}
defaultLoginDates
{
[
pname
]
:
0
}
)
)
;
Assert
.
ok
(
!
!
(
await
Services
.
logins
.
addLoginAsync
(
loginInfo
)
)
"
Check
0
value
for
"
+
pname
)
;
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
}
for
(
let
pname
of
[
"
timeCreated
"
"
timeLastUsed
"
"
timePasswordChanged
"
]
)
{
let
loginInfo
=
TestData
.
formLogin
(
Object
.
assign
(
{
}
defaultLoginDates
{
[
pname
]
:
-
1
}
)
)
;
Assert
.
ok
(
!
!
(
await
Services
.
logins
.
addLoginAsync
(
loginInfo
)
)
"
Check
-
1
value
for
"
+
pname
)
;
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
}
for
(
let
pname
of
[
"
timeCreated
"
"
timeLastUsed
"
"
timePasswordChanged
"
]
)
{
let
loginInfo
=
TestData
.
formLogin
(
Object
.
assign
(
{
}
defaultLoginDates
{
[
pname
]
:
MAX_DATE_MS
+
1
}
)
)
;
await
Assert
.
rejects
(
Services
.
logins
.
addLoginAsync
(
loginInfo
)
/
invalid
date
properties
/
)
;
Assert
.
equal
(
Services
.
logins
.
getAllLogins
(
)
.
length
0
)
;
}
LoginTestUtils
.
checkLogins
(
[
]
)
;
}
)
;
add_task
(
async
function
test_addLogins_badDates
(
)
{
LoginTestUtils
.
clearData
(
)
;
let
defaultsLogin
=
TestData
.
formLogin
(
{
username
:
"
defaults
"
}
)
;
await
Services
.
logins
.
addLoginAsync
(
defaultsLogin
)
;
let
timeCreatedLogin
=
TestData
.
formLogin
(
{
username
:
"
tc
"
timeCreated
:
-
11644473600000
}
)
;
await
Assert
.
rejects
(
Services
.
logins
.
addLoginAsync
(
timeCreatedLogin
)
/
Can
\
'
t
add
a
login
with
invalid
date
properties
.
/
)
;
let
timeLastUsedLogin
=
TestData
.
formLogin
(
{
username
:
"
tlu
"
timeLastUsed
:
-
11644473600000
}
)
;
await
Assert
.
rejects
(
Services
.
logins
.
addLoginAsync
(
timeLastUsedLogin
)
/
Can
\
'
t
add
a
login
with
invalid
date
properties
.
/
)
;
let
timePasswordChangedLogin
=
TestData
.
formLogin
(
{
username
:
"
tpc
"
timePasswordChanged
:
-
11644473600000
}
)
;
await
Assert
.
rejects
(
Services
.
logins
.
addLoginAsync
(
timePasswordChangedLogin
)
/
Can
\
'
t
add
a
login
with
invalid
date
properties
.
/
)
;
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
}
)
;
