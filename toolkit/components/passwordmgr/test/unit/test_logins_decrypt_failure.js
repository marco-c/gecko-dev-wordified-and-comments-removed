"
use
strict
"
;
function
resetPrimaryPassword
(
)
{
let
token
=
Cc
[
"
mozilla
.
org
/
security
/
pk11tokendb
;
1
"
]
.
getService
(
Ci
.
nsIPK11TokenDB
)
.
getInternalKeyToken
(
)
;
token
.
reset
(
)
;
token
.
initPassword
(
"
"
)
;
}
add_task
(
async
function
test_logins_decrypt_failure
(
)
{
let
logins
=
TestData
.
loginList
(
)
;
await
Services
.
logins
.
addLogins
(
logins
)
;
resetPrimaryPassword
(
)
;
let
savedLogins
=
await
Services
.
logins
.
getAllLogins
(
)
;
Assert
.
equal
(
savedLogins
.
length
0
"
getAllLogins
length
"
)
;
const
result
=
await
Services
.
logins
.
searchLoginsAsync
(
{
}
)
;
Assert
.
equal
(
result
.
length
0
)
;
Assert
.
throws
(
(
)
=
>
Services
.
logins
.
modifyLogin
(
logins
[
0
]
newPropertyBag
(
)
)
/
No
matching
logins
/
)
;
Assert
.
throws
(
(
)
=
>
Services
.
logins
.
removeLogin
(
logins
[
0
]
)
/
No
matching
logins
/
)
;
Assert
.
equal
(
Services
.
logins
.
countLogins
(
"
"
"
"
"
"
)
logins
.
length
)
;
await
Services
.
logins
.
addLogins
(
logins
)
;
await
LoginTestUtils
.
checkLogins
(
logins
)
;
Assert
.
equal
(
(
await
Services
.
logins
.
getAllLogins
(
)
)
.
length
logins
.
length
"
getAllLogins
length
"
)
;
Assert
.
equal
(
Services
.
logins
.
countLogins
(
"
"
"
"
"
"
)
logins
.
length
*
2
)
;
Assert
.
equal
(
(
await
Services
.
logins
.
searchLoginsAsync
(
{
origin
:
"
http
:
/
/
www
.
example
.
com
"
}
)
)
.
length
1
)
;
let
matchData
=
{
origin
:
"
http
:
/
/
www
.
example
.
com
"
}
;
const
result2
=
await
Services
.
logins
.
searchLoginsAsync
(
matchData
)
;
Assert
.
equal
(
result2
.
length
1
)
;
for
(
let
loginInfo
of
TestData
.
loginList
(
)
)
{
Services
.
logins
.
removeLogin
(
loginInfo
)
;
}
Assert
.
equal
(
(
await
Services
.
logins
.
getAllLogins
(
)
)
.
length
0
)
;
Assert
.
equal
(
Services
.
logins
.
countLogins
(
"
"
"
"
"
"
)
logins
.
length
)
;
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
Assert
.
equal
(
(
await
Services
.
logins
.
getAllLogins
(
)
)
.
length
0
)
;
Assert
.
equal
(
Services
.
logins
.
countLogins
(
"
"
"
"
"
"
)
0
)
;
}
)
;
add_task
(
async
function
test_add_logins_with_decrypt_failure
(
)
{
let
login
=
new
LoginInfo
(
"
http
:
/
/
www
.
example2
.
com
"
"
http
:
/
/
www
.
example2
.
com
"
null
"
the
username
"
"
the
password
for
www
.
example
.
com
"
"
form_field_username
"
"
form_field_password
"
)
;
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
login
.
guid
=
"
{
4bc50d2f
-
dbb6
-
4aa3
-
807c
-
c4c2065a2c35
}
"
;
let
loginDupeGuid
=
new
LoginInfo
(
"
http
:
/
/
www
.
example3
.
com
"
"
http
:
/
/
www
.
example3
.
com
"
null
"
the
username
"
"
the
password
"
"
form_field_username
"
"
form_field_password
"
)
;
loginDupeGuid
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
loginDupeGuid
.
guid
=
login
.
guid
;
await
Services
.
logins
.
addLoginAsync
(
login
)
;
const
result
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
:
login
.
guid
}
)
;
equal
(
result
.
length
1
)
;
await
Assert
.
rejects
(
Services
.
logins
.
addLoginAsync
(
login
)
/
This
login
already
exists
.
/
)
;
await
Assert
.
rejects
(
Services
.
logins
.
addLoginAsync
(
loginDupeGuid
)
/
specified
GUID
already
exists
/
)
;
resetPrimaryPassword
(
)
;
const
result1
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
:
login
.
guid
}
)
;
equal
(
result1
.
length
0
)
;
await
Services
.
logins
.
addLoginAsync
(
login
)
;
const
result2
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
:
login
.
guid
}
)
;
equal
(
result2
.
length
1
)
;
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
}
)
;
add_task
(
async
function
test_sync_metadata_with_decrypt_failure
(
)
{
await
Services
.
logins
.
setSyncID
(
"
sync
-
id
"
)
;
await
Services
.
logins
.
setLastSync
(
123
)
;
equal
(
await
Services
.
logins
.
getSyncID
(
)
"
sync
-
id
"
)
;
equal
(
await
Services
.
logins
.
getLastSync
(
)
123
)
;
resetPrimaryPassword
(
)
;
equal
(
await
Services
.
logins
.
getSyncID
(
)
null
)
;
equal
(
await
Services
.
logins
.
getLastSync
(
)
123
)
;
await
Services
.
logins
.
setSyncID
(
"
new
-
id
"
)
;
equal
(
await
Services
.
logins
.
getSyncID
(
)
"
new
-
id
"
)
;
}
)
;
