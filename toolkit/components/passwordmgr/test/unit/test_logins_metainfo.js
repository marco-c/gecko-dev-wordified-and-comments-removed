"
use
strict
"
;
const
gLooksLikeUUIDRegex
=
/
^
\
{
\
w
{
8
}
-
\
w
{
4
}
-
\
w
{
4
}
-
\
w
{
4
}
-
\
w
{
12
}
\
}
/
;
async
function
retrieveOriginMatching
(
origin
)
{
let
logins
=
await
Services
.
logins
.
searchLoginsAsync
(
{
origin
}
)
;
Assert
.
equal
(
logins
.
length
1
)
;
return
logins
[
0
]
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
}
function
assertMetaInfoEqual
(
aActual
aExpected
)
{
Assert
.
notEqual
(
aActual
aExpected
)
;
Assert
.
ok
(
aActual
.
equals
(
aExpected
)
)
;
Assert
.
equal
(
aActual
.
guid
aExpected
.
guid
)
;
Assert
.
equal
(
aActual
.
timeCreated
aExpected
.
timeCreated
)
;
Assert
.
equal
(
aActual
.
timeLastUsed
aExpected
.
timeLastUsed
)
;
Assert
.
equal
(
aActual
.
timePasswordChanged
aExpected
.
timePasswordChanged
)
;
Assert
.
equal
(
aActual
.
timesUsed
aExpected
.
timesUsed
)
;
}
let
gLoginInfo1
;
let
gLoginInfo2
;
let
gLoginInfo3
;
let
gLoginMetaInfo1
;
let
gLoginMetaInfo2
;
let
gLoginMetaInfo3
;
add_task
(
function
test_initialize
(
)
{
let
baseTimeMs
=
Date
.
now
(
)
-
600000
;
gLoginInfo1
=
TestData
.
formLogin
(
)
;
gLoginInfo2
=
TestData
.
formLogin
(
{
origin
:
"
http
:
/
/
other
.
example
.
com
"
guid
:
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
timeCreated
:
baseTimeMs
timeLastUsed
:
baseTimeMs
+
2
timePasswordChanged
:
baseTimeMs
+
1
timesUsed
:
2
}
)
;
gLoginInfo3
=
TestData
.
authLogin
(
)
;
}
)
;
add_task
(
async
function
test_addLogin_metainfo
(
)
{
await
Services
.
logins
.
addLoginAsync
(
gLoginInfo1
)
;
Assert
.
equal
(
gLoginInfo1
.
guid
null
)
;
Assert
.
equal
(
gLoginInfo1
.
timeCreated
0
)
;
Assert
.
equal
(
gLoginInfo1
.
timeLastUsed
0
)
;
Assert
.
equal
(
gLoginInfo1
.
timePasswordChanged
0
)
;
Assert
.
equal
(
gLoginInfo1
.
timesUsed
0
)
;
gLoginMetaInfo1
=
await
retrieveOriginMatching
(
gLoginInfo1
.
origin
)
;
Assert
.
ok
(
gLooksLikeUUIDRegex
.
test
(
gLoginMetaInfo1
.
guid
)
)
;
let
creationTime
=
gLoginMetaInfo1
.
timeCreated
;
LoginTestUtils
.
assertTimeIsAboutNow
(
creationTime
)
;
Assert
.
equal
(
gLoginMetaInfo1
.
timeLastUsed
creationTime
)
;
Assert
.
equal
(
gLoginMetaInfo1
.
timePasswordChanged
creationTime
)
;
Assert
.
equal
(
gLoginMetaInfo1
.
timesUsed
1
)
;
let
originalLogin
=
gLoginInfo2
.
clone
(
)
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
await
Services
.
logins
.
addLoginAsync
(
gLoginInfo2
)
;
assertMetaInfoEqual
(
gLoginInfo2
originalLogin
)
;
gLoginMetaInfo2
=
await
retrieveOriginMatching
(
gLoginInfo2
.
origin
)
;
assertMetaInfoEqual
(
gLoginMetaInfo2
gLoginInfo2
)
;
await
Services
.
logins
.
addLoginAsync
(
gLoginInfo3
)
;
gLoginMetaInfo3
=
await
retrieveOriginMatching
(
gLoginInfo3
.
origin
)
;
await
LoginTestUtils
.
checkLogins
(
[
gLoginInfo1
gLoginInfo2
gLoginInfo3
]
)
;
}
)
;
add_task
(
async
function
test_addLogin_metainfo_duplicate
(
)
{
let
loginInfo
=
TestData
.
formLogin
(
{
origin
:
"
http
:
/
/
duplicate
.
example
.
com
"
guid
:
gLoginMetaInfo2
.
guid
}
)
;
await
Assert
.
rejects
(
Services
.
logins
.
addLoginAsync
(
loginInfo
)
/
specified
GUID
already
exists
/
)
;
await
LoginTestUtils
.
checkLogins
(
[
gLoginInfo1
gLoginInfo2
gLoginInfo3
]
)
;
}
)
;
add_task
(
async
function
test_modifyLogin_nsILoginInfo_metainfo_ignored
(
)
{
let
newLoginInfo
=
gLoginInfo1
.
clone
(
)
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
newLoginInfo
.
guid
=
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
;
newLoginInfo
.
timeCreated
=
Date
.
now
(
)
;
newLoginInfo
.
timeLastUsed
=
Date
.
now
(
)
;
newLoginInfo
.
timePasswordChanged
=
Date
.
now
(
)
;
newLoginInfo
.
timesUsed
=
12
;
await
Services
.
logins
.
modifyLoginAsync
(
gLoginInfo1
newLoginInfo
)
;
newLoginInfo
=
await
retrieveOriginMatching
(
gLoginInfo1
.
origin
)
;
assertMetaInfoEqual
(
newLoginInfo
gLoginMetaInfo1
)
;
}
)
;
add_task
(
async
function
test_modifyLogin_nsIProperyBag_metainfo
(
)
{
let
newTimeMs
=
Date
.
now
(
)
+
120000
;
let
newUUIDValue
=
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
;
await
Services
.
logins
.
modifyLoginAsync
(
gLoginInfo1
newPropertyBag
(
{
guid
:
newUUIDValue
timeCreated
:
newTimeMs
timeLastUsed
:
newTimeMs
+
2
timePasswordChanged
:
newTimeMs
+
1
timesUsed
:
2
}
)
)
;
gLoginMetaInfo1
=
await
retrieveOriginMatching
(
gLoginInfo1
.
origin
)
;
Assert
.
equal
(
gLoginMetaInfo1
.
guid
newUUIDValue
)
;
Assert
.
equal
(
gLoginMetaInfo1
.
timeCreated
newTimeMs
)
;
Assert
.
equal
(
gLoginMetaInfo1
.
timeLastUsed
newTimeMs
+
2
)
;
Assert
.
equal
(
gLoginMetaInfo1
.
timePasswordChanged
newTimeMs
+
1
)
;
Assert
.
equal
(
gLoginMetaInfo1
.
timesUsed
2
)
;
let
originalLogin
=
gLoginInfo2
.
clone
(
)
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
await
Services
.
logins
.
modifyLoginAsync
(
gLoginInfo2
newPropertyBag
(
{
password
:
"
new
password
"
}
)
)
;
gLoginInfo2
.
password
=
"
new
password
"
;
gLoginMetaInfo2
=
await
retrieveOriginMatching
(
gLoginInfo2
.
origin
)
;
Assert
.
equal
(
gLoginMetaInfo2
.
password
gLoginInfo2
.
password
)
;
Assert
.
equal
(
gLoginMetaInfo2
.
timeCreated
originalLogin
.
timeCreated
)
;
Assert
.
equal
(
gLoginMetaInfo2
.
timeLastUsed
originalLogin
.
timeLastUsed
)
;
LoginTestUtils
.
assertTimeIsAboutNow
(
gLoginMetaInfo2
.
timePasswordChanged
)
;
await
Services
.
logins
.
modifyLoginAsync
(
gLoginInfo2
newPropertyBag
(
{
password
:
"
other
password
"
timePasswordChanged
:
newTimeMs
}
)
)
;
gLoginInfo2
.
password
=
"
other
password
"
;
gLoginMetaInfo2
=
await
retrieveOriginMatching
(
gLoginInfo2
.
origin
)
;
Assert
.
equal
(
gLoginMetaInfo2
.
password
gLoginInfo2
.
password
)
;
Assert
.
equal
(
gLoginMetaInfo2
.
timeCreated
originalLogin
.
timeCreated
)
;
Assert
.
equal
(
gLoginMetaInfo2
.
timeLastUsed
originalLogin
.
timeLastUsed
)
;
Assert
.
equal
(
gLoginMetaInfo2
.
timePasswordChanged
newTimeMs
)
;
await
Services
.
logins
.
modifyLoginAsync
(
gLoginInfo2
newPropertyBag
(
{
timesUsedIncrement
:
2
}
)
)
;
gLoginMetaInfo2
=
await
retrieveOriginMatching
(
gLoginInfo2
.
origin
)
;
Assert
.
equal
(
gLoginMetaInfo2
.
timeCreated
originalLogin
.
timeCreated
)
;
Assert
.
equal
(
gLoginMetaInfo2
.
timeLastUsed
originalLogin
.
timeLastUsed
)
;
Assert
.
equal
(
gLoginMetaInfo2
.
timePasswordChanged
newTimeMs
)
;
Assert
.
equal
(
gLoginMetaInfo2
.
timesUsed
4
)
;
}
)
;
add_task
(
async
function
test_modifyLogin_nsIProperyBag_metainfo_duplicate
(
)
{
await
Assert
.
rejects
(
Services
.
logins
.
modifyLoginAsync
(
gLoginInfo1
newPropertyBag
(
{
guid
:
gLoginInfo2
.
guid
}
)
)
/
specified
GUID
already
exists
/
)
;
await
LoginTestUtils
.
checkLogins
(
[
gLoginInfo1
gLoginInfo2
gLoginInfo3
]
)
;
}
)
;
add_task
(
async
function
test_searchLogins_metainfo
(
)
{
let
logins
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
:
gLoginMetaInfo1
.
guid
}
)
;
Assert
.
equal
(
logins
.
length
1
)
;
let
foundLogin
=
logins
[
0
]
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
assertMetaInfoEqual
(
foundLogin
gLoginMetaInfo1
)
;
logins
=
await
Services
.
logins
.
searchLoginsAsync
(
{
timePasswordChanged
:
gLoginMetaInfo2
.
timePasswordChanged
}
)
;
Assert
.
equal
(
logins
.
length
1
)
;
foundLogin
=
logins
[
0
]
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
assertMetaInfoEqual
(
foundLogin
gLoginMetaInfo2
)
;
logins
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
:
gLoginMetaInfo3
.
guid
timePasswordChanged
:
gLoginMetaInfo3
.
timePasswordChanged
}
)
;
Assert
.
equal
(
logins
.
length
1
)
;
foundLogin
=
logins
[
0
]
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
assertMetaInfoEqual
(
foundLogin
gLoginMetaInfo3
)
;
}
)
;
add_task
(
async
function
test_storage_metainfo
(
)
{
await
LoginTestUtils
.
reloadData
(
)
;
await
LoginTestUtils
.
checkLogins
(
[
gLoginInfo1
gLoginInfo2
gLoginInfo3
]
)
;
assertMetaInfoEqual
(
await
retrieveOriginMatching
(
gLoginInfo1
.
origin
)
gLoginMetaInfo1
)
;
assertMetaInfoEqual
(
await
retrieveOriginMatching
(
gLoginInfo2
.
origin
)
gLoginMetaInfo2
)
;
assertMetaInfoEqual
(
await
retrieveOriginMatching
(
gLoginInfo3
.
origin
)
gLoginMetaInfo3
)
;
}
)
;
