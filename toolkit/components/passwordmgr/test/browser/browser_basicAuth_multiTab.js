"
use
-
strict
"
;
const
ORIGIN1
=
"
https
:
/
/
example
.
com
"
;
const
ORIGIN2
=
"
https
:
/
/
example
.
org
"
;
const
AUTH_PATH
=
"
/
browser
/
toolkit
/
components
/
passwordmgr
/
test
/
browser
/
authenticate
.
sjs
"
;
async
function
openTabWithAuthPrompt
(
origin
authOptions
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
https
:
/
/
example
.
com
"
)
;
let
promptPromise
=
PromptTestUtils
.
waitForPrompt
(
tab
.
linkedBrowser
{
modalType
:
Services
.
prompt
.
MODAL_TYPE_TAB
promptType
:
"
promptUserAndPass
"
}
)
;
let
url
=
new
URL
(
origin
+
AUTH_PATH
)
;
Object
.
entries
(
authOptions
)
.
forEach
(
(
[
key
value
]
)
=
>
url
.
searchParams
.
append
(
key
value
)
)
;
let
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
url
.
toString
(
)
)
;
info
(
"
Loading
"
+
url
.
toString
(
)
)
;
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
url
.
toString
(
)
)
;
return
{
origin
tab
authOptions
loadPromise
promptPromise
}
;
}
async
function
testTabAuthed
(
expectAuthed
{
tab
loadPromise
authOptions
}
)
{
await
loadPromise
;
ok
(
true
"
Tab
loads
after
auth
"
)
;
let
{
loginResult
user
pass
}
=
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
(
)
=
>
{
let
result
=
{
}
;
result
.
loginResult
=
content
.
document
.
getElementById
(
"
ok
"
)
.
innerText
;
result
.
user
=
content
.
document
.
getElementById
(
"
user
"
)
.
innerText
;
result
.
pass
=
content
.
document
.
getElementById
(
"
pass
"
)
.
innerText
;
return
result
;
}
)
;
is
(
loginResult
=
=
"
PASS
"
expectAuthed
"
Site
has
expected
auth
state
"
)
;
is
(
user
expectAuthed
?
authOptions
.
user
:
"
"
"
Sent
correct
user
"
)
;
is
(
pass
expectAuthed
?
authOptions
.
pass
:
"
"
"
Sent
correct
password
"
)
;
}
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
prompts
.
modalType
.
httpAuth
"
Services
.
prompt
.
MODAL_TYPE_TAB
]
]
}
)
;
}
)
;
add_task
(
async
function
test
(
)
{
let
tabA
=
await
openTabWithAuthPrompt
(
ORIGIN1
{
user
:
"
userA
"
pass
:
"
passA
"
realm
:
"
realmA
"
}
)
;
let
tabB
=
await
openTabWithAuthPrompt
(
ORIGIN2
{
user
:
"
userB
"
pass
:
"
passB
"
realm
:
"
realmB
"
}
)
;
let
tabC
=
await
openTabWithAuthPrompt
(
ORIGIN2
{
user
:
"
userB
"
pass
:
"
passB
"
realm
:
"
realmB
"
}
)
;
let
tabs
=
[
tabA
tabB
tabC
]
;
info
(
Opening
{
tabs
.
length
}
tabs
with
auth
prompts
)
;
let
prompts
=
await
Promise
.
all
(
tabs
.
map
(
tab
=
>
tab
.
promptPromise
)
)
;
is
(
prompts
.
length
tabs
.
length
"
Should
have
one
prompt
per
tab
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
proton
.
modals
.
enabled
"
false
)
)
{
for
(
let
i
=
0
;
i
<
prompts
.
length
;
i
+
+
)
{
let
titleEl
=
prompts
[
i
]
.
ui
.
prompt
.
document
.
querySelector
(
"
#
titleText
"
)
;
is
(
titleEl
.
textContent
new
URL
(
tabs
[
i
]
.
origin
)
.
host
"
Prompt
matches
the
tab
'
s
host
"
)
;
}
}
else
{
for
(
let
i
=
0
;
i
<
prompts
.
length
;
i
+
+
)
{
ok
(
prompts
[
i
]
.
args
.
text
.
startsWith
(
tabs
[
i
]
.
origin
)
"
Prompt
matches
the
tabs
origin
"
)
;
}
}
let
[
promptA
promptB
promptC
]
=
prompts
;
await
PromptTestUtils
.
handlePrompt
(
promptB
{
loginInput
:
tabB
.
authOptions
.
user
passwordInput
:
tabB
.
authOptions
.
pass
}
)
;
await
testTabAuthed
(
true
tabB
)
;
await
PromptTestUtils
.
handlePrompt
(
promptA
{
loginInput
:
tabA
.
authOptions
.
user
passwordInput
:
tabA
.
authOptions
.
pass
}
)
;
await
testTabAuthed
(
true
tabA
)
;
await
PromptTestUtils
.
handlePrompt
(
promptC
{
buttonNumClick
:
1
}
)
;
await
testTabAuthed
(
false
tabC
)
;
tabs
.
forEach
(
(
{
tab
}
)
=
>
BrowserTestUtils
.
removeTab
(
tab
)
)
;
}
)
;
