"
use
strict
"
;
let
proxyChannel
;
function
initProxy
(
)
{
return
new
Promise
(
resolve
=
>
{
let
proxyChannel
;
let
proxyCallback
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIProtocolProxyCallback
"
]
)
onProxyAvailable
(
req
uri
pi
status
)
{
class
ProxyChannelListener
{
onStartRequest
(
request
)
{
resolve
(
proxyChannel
)
;
}
onStopRequest
(
request
status
)
{
}
}
proxyChannel
=
Services
.
io
.
newChannel
(
"
http
:
/
/
mochi
.
test
:
8888
"
null
null
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
null
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
Ci
.
nsIContentPolicy
.
TYPE_OTHER
)
;
proxyChannel
.
asyncOpen
(
new
ProxyChannelListener
(
)
)
;
}
}
;
let
pps
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
-
proxy
-
service
;
1
"
]
.
getService
(
)
;
let
channel
=
Services
.
io
.
newChannel
(
"
http
:
/
/
example
.
com
"
null
null
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
null
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
Ci
.
nsIContentPolicy
.
TYPE_OTHER
)
;
pps
.
asyncResolve
(
channel
0
proxyCallback
)
;
}
)
;
}
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
prompts
.
modalType
.
httpAuth
"
Services
.
prompt
.
MODAL_TYPE_TAB
]
]
}
)
;
proxyChannel
=
await
initProxy
(
)
;
}
)
;
function
getAuthPromptCallback
(
)
{
let
callbackResolver
;
let
promise
=
new
Promise
(
resolve
=
>
{
callbackResolver
=
resolve
;
}
)
;
let
callback
=
{
onAuthAvailable
(
context
authInfo
)
{
callbackResolver
(
authInfo
)
;
}
}
;
return
{
callback
promise
}
;
}
add_task
(
async
function
testProxyAuthPromptMerge
(
)
{
let
tabA
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
https
:
/
/
example
.
com
"
)
;
let
tabB
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
https
:
/
/
example
.
org
"
)
;
const
promptFac
=
Cc
[
"
mozilla
.
org
/
passwordmanager
/
authpromptfactory
;
1
"
]
.
getService
(
Ci
.
nsIPromptFactory
)
;
let
prompter
=
promptFac
.
getPrompt
(
window
Ci
.
nsIAuthPrompt2
)
;
let
level
=
Ci
.
nsIAuthPrompt2
.
LEVEL_NONE
;
let
proxyAuthinfo
=
{
username
:
"
"
password
:
"
"
domain
:
"
"
flags
:
Ci
.
nsIAuthInformation
.
AUTH_PROXY
authenticationScheme
:
"
basic
"
realm
:
"
"
}
;
let
promptOpened
=
PromptTestUtils
.
waitForPrompt
(
null
{
modalType
:
Services
.
prompt
.
MODAL_TYPE_WINDOW
}
)
;
let
cbWinPrompt
=
getAuthPromptCallback
(
)
;
info
(
"
asyncPromptAuth
no
parent
"
)
;
prompter
.
asyncPromptAuth
(
proxyChannel
cbWinPrompt
.
callback
null
level
proxyAuthinfo
)
;
let
prompt
=
await
promptOpened
;
prompter
.
QueryInterface
(
Ci
.
nsILoginManagerAuthPrompter
)
.
browser
=
tabA
.
linkedBrowser
;
let
cbNoPrompt
=
getAuthPromptCallback
(
)
;
info
(
"
asyncPromptAuth
tabA
parent
"
)
;
prompter
.
asyncPromptAuth
(
proxyChannel
cbNoPrompt
.
callback
null
level
proxyAuthinfo
)
;
prompter
.
QueryInterface
(
Ci
.
nsILoginManagerAuthPrompter
)
.
browser
=
tabB
.
linkedBrowser
;
let
cbNoPrompt2
=
getAuthPromptCallback
(
)
;
info
(
"
asyncPromptAuth
tabB
parent
"
)
;
prompter
.
asyncPromptAuth
(
proxyChannel
cbNoPrompt2
.
callback
null
level
proxyAuthinfo
)
;
PromptTestUtils
.
handlePrompt
(
prompt
{
}
)
;
let
authInfo1
=
await
cbWinPrompt
.
promise
;
ok
(
authInfo1
"
Received
callback
from
first
proxy
auth
call
.
"
)
;
let
authInfo2
=
await
cbNoPrompt
.
promise
;
ok
(
authInfo2
"
Received
callback
from
second
proxy
auth
call
.
"
)
;
let
authInfo3
=
await
cbNoPrompt2
.
promise
;
ok
(
authInfo3
"
Received
callback
from
third
proxy
auth
call
.
"
)
;
BrowserTestUtils
.
removeTab
(
tabA
)
;
BrowserTestUtils
.
removeTab
(
tabB
)
;
}
)
;
