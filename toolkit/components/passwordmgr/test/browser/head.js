const
DIRECTORY_PATH
=
"
/
browser
/
toolkit
/
components
/
passwordmgr
/
test
/
browser
/
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
LoginTestUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
ContentTaskUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
this
)
;
add_task
(
async
function
common_initialize
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
signon
.
rememberSignons
"
true
]
]
}
)
;
}
)
;
registerCleanupFunction
(
async
function
cleanup_removeAllLoginsAndResetRecipes
(
)
{
await
SpecialPowers
.
popPrefEnv
(
)
;
Services
.
logins
.
removeAllLogins
(
)
;
clearHttpAuths
(
)
;
let
recipeParent
=
LoginTestUtils
.
recipes
.
getRecipeParent
(
)
;
if
(
!
recipeParent
)
{
return
;
}
await
recipeParent
.
then
(
recipeParentResult
=
>
recipeParentResult
.
reset
(
)
)
;
}
)
;
function
testSubmittingLoginForm
(
aPageFile
aTaskFn
aOrigin
=
"
http
:
/
/
example
.
com
"
)
{
return
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
aOrigin
+
DIRECTORY_PATH
+
aPageFile
}
async
function
(
browser
)
{
ok
(
true
"
loaded
"
+
aPageFile
)
;
let
fieldValues
=
await
ContentTask
.
spawn
(
browser
undefined
async
function
(
)
{
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
(
content
.
location
.
pathname
.
endsWith
(
"
/
formsubmit
.
sjs
"
)
&
&
content
.
document
.
readyState
=
=
"
complete
"
)
;
}
"
Wait
for
form
submission
load
(
formsubmit
.
sjs
)
"
)
;
let
username
=
content
.
document
.
getElementById
(
"
user
"
)
.
textContent
;
let
password
=
content
.
document
.
getElementById
(
"
pass
"
)
.
textContent
;
return
{
username
password
}
;
}
)
;
ok
(
true
"
form
submission
loaded
"
)
;
if
(
aTaskFn
)
{
await
aTaskFn
(
fieldValues
)
;
}
return
fieldValues
;
}
)
;
}
function
checkOnlyLoginWasUsedTwice
(
{
justChanged
}
)
{
let
logins
=
Services
.
logins
.
getAllLogins
(
)
;
is
(
logins
.
length
1
"
Should
only
have
1
login
"
)
;
ok
(
logins
[
0
]
instanceof
Ci
.
nsILoginMetaInfo
"
metainfo
QI
"
)
;
is
(
logins
[
0
]
.
timesUsed
2
"
check
.
timesUsed
for
existing
login
submission
"
)
;
ok
(
logins
[
0
]
.
timeCreated
<
logins
[
0
]
.
timeLastUsed
"
timeLastUsed
bumped
"
)
;
if
(
justChanged
)
{
is
(
logins
[
0
]
.
timeLastUsed
logins
[
0
]
.
timePasswordChanged
"
timeLastUsed
=
=
timePasswordChanged
"
)
;
}
else
{
is
(
logins
[
0
]
.
timeCreated
logins
[
0
]
.
timePasswordChanged
"
timeChanged
not
updated
"
)
;
}
}
function
clearHttpAuths
(
)
{
let
authMgr
=
Cc
[
"
mozilla
.
org
/
network
/
http
-
auth
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIHttpAuthManager
)
;
authMgr
.
clearAll
(
)
;
}
const
REMEMBER_BUTTON
=
"
button
"
;
const
NEVER_MENUITEM
=
0
;
const
CHANGE_BUTTON
=
"
button
"
;
const
DONT_CHANGE_BUTTON
=
"
secondaryButton
"
;
function
getCaptureDoorhanger
(
aKind
popupNotifications
=
PopupNotifications
browser
=
null
)
{
ok
(
true
"
Looking
for
"
+
aKind
+
"
popup
notification
"
)
;
let
notification
=
popupNotifications
.
getNotification
(
"
password
"
browser
)
;
if
(
notification
)
{
is
(
notification
.
options
.
passwordNotificationType
aKind
"
Notification
type
matches
.
"
)
;
if
(
aKind
=
=
"
password
-
change
"
)
{
is
(
notification
.
mainAction
.
label
"
Update
"
"
Main
action
label
matches
update
doorhanger
.
"
)
;
}
else
if
(
aKind
=
=
"
password
-
save
"
)
{
is
(
notification
.
mainAction
.
label
"
Save
"
"
Main
action
label
matches
save
doorhanger
.
"
)
;
}
}
return
notification
;
}
function
clickDoorhangerButton
(
aPopup
aButtonIndex
)
{
ok
(
true
"
Looking
for
action
at
index
"
+
aButtonIndex
)
;
let
notifications
=
aPopup
.
owner
.
panel
.
children
;
ok
(
notifications
.
length
>
0
"
at
least
one
notification
displayed
"
)
;
ok
(
true
notifications
.
length
+
"
notification
(
s
)
"
)
;
let
notification
=
notifications
[
0
]
;
if
(
aButtonIndex
=
=
"
button
"
)
{
ok
(
true
"
Triggering
main
action
"
)
;
notification
.
button
.
doCommand
(
)
;
}
else
if
(
aButtonIndex
=
=
"
secondaryButton
"
)
{
ok
(
true
"
Triggering
secondary
action
"
)
;
notification
.
secondaryButton
.
doCommand
(
)
;
}
else
{
ok
(
true
"
Triggering
menuitem
#
"
+
aButtonIndex
)
;
notification
.
menupopup
.
querySelectorAll
(
"
menuitem
"
)
[
aButtonIndex
]
.
doCommand
(
)
;
}
}
async
function
checkDoorhangerUsernamePassword
(
username
password
)
{
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
(
document
.
getElementById
(
"
password
-
notification
-
username
"
)
.
value
=
=
username
)
;
}
"
Wait
for
nsLoginManagerPrompter
writeDataToUI
(
)
"
)
;
is
(
document
.
getElementById
(
"
password
-
notification
-
username
"
)
.
value
username
"
Check
doorhanger
username
"
)
;
is
(
document
.
getElementById
(
"
password
-
notification
-
password
"
)
.
value
password
"
Check
doorhanger
password
"
)
;
}
async
function
waitForPasswordManagerDialog
(
)
{
let
win
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
win
=
Services
.
wm
.
getMostRecentWindow
(
"
Toolkit
:
PasswordManager
"
)
;
return
win
&
&
win
.
document
.
getElementById
(
"
filter
"
)
;
}
"
Waiting
for
the
password
manager
dialog
to
open
"
)
;
return
win
;
}
async
function
openPasswordContextMenu
(
browser
passwordInput
assertCallback
=
null
)
{
const
CONTEXT_MENU
=
document
.
getElementById
(
"
contentAreaContextMenu
"
)
;
const
POPUP_HEADER
=
document
.
getElementById
(
"
fill
-
login
"
)
;
let
contextMenuShownPromise
=
BrowserTestUtils
.
waitForEvent
(
CONTEXT_MENU
"
popupshown
"
)
;
let
eventDetails
=
{
type
:
"
mousedown
"
button
:
2
}
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
passwordInput
eventDetails
browser
)
;
eventDetails
=
{
type
:
"
contextmenu
"
button
:
2
}
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
passwordInput
eventDetails
browser
)
;
await
contextMenuShownPromise
;
if
(
assertCallback
)
{
let
shouldContinue
=
await
assertCallback
(
)
;
if
(
!
shouldContinue
)
{
return
;
}
}
let
popupShownPromise
=
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
POPUP_HEADER
.
open
)
;
EventUtils
.
synthesizeMouseAtCenter
(
POPUP_HEADER
{
}
)
;
await
popupShownPromise
;
}
