const
DIRECTORY_PATH
=
"
/
browser
/
toolkit
/
components
/
passwordmgr
/
test
/
browser
/
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
this
)
;
const
{
LoginManagerParent
:
LMP
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoginManagerParent
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
LoginTestUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
ContentTaskUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
this
)
;
add_task
(
async
function
common_initialize
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
signon
.
rememberSignons
"
true
]
]
}
)
;
}
)
;
registerCleanupFunction
(
async
function
cleanup_removeAllLoginsAndResetRecipes
(
)
{
await
SpecialPowers
.
popPrefEnv
(
)
;
Services
.
logins
.
removeAllLogins
(
)
;
clearHttpAuths
(
)
;
Services
.
telemetry
.
clearEvents
(
)
;
LMP
.
_generatedPasswordsByPrincipalOrigin
.
clear
(
)
;
let
recipeParent
=
LoginTestUtils
.
recipes
.
getRecipeParent
(
)
;
if
(
!
recipeParent
)
{
return
;
}
await
recipeParent
.
then
(
recipeParentResult
=
>
recipeParentResult
.
reset
(
)
)
;
}
)
;
function
verifyLogins
(
expectedLogins
=
[
]
)
{
let
allLogins
=
Services
.
logins
.
getAllLogins
(
)
;
is
(
allLogins
.
length
expectedLogins
.
length
"
Check
actual
number
of
logins
matches
the
number
of
provided
expected
property
-
sets
"
)
;
for
(
let
i
=
0
;
i
<
expectedLogins
.
length
;
i
+
+
)
{
let
expected
=
expectedLogins
[
i
]
;
if
(
expected
)
{
let
login
=
allLogins
[
i
]
;
if
(
typeof
expected
.
timesUsed
!
=
=
"
undefined
"
)
{
is
(
login
.
timesUsed
expected
.
timesUsed
"
Check
timesUsed
"
)
;
}
if
(
typeof
expected
.
passwordLength
!
=
=
"
undefined
"
)
{
is
(
login
.
password
.
length
expected
.
passwordLength
"
Check
passwordLength
"
)
;
}
if
(
typeof
expected
.
username
!
=
=
"
undefined
"
)
{
is
(
login
.
username
expected
.
username
"
Check
username
"
)
;
}
if
(
typeof
expected
.
password
!
=
=
"
undefined
"
)
{
info
(
verifyLogins
login
has
password
:
{
login
.
password
}
expects
:
{
expected
.
password
}
)
;
is
(
login
.
password
expected
.
password
"
Check
password
"
)
;
}
if
(
typeof
expected
.
usedSince
!
=
=
"
undefined
"
)
{
ok
(
login
.
timeLastUsed
>
expected
.
usedSince
"
Check
timeLastUsed
"
)
;
}
if
(
typeof
expected
.
passwordChangedSince
!
=
=
"
undefined
"
)
{
ok
(
login
.
timePasswordChanged
>
expected
.
passwordChangedSince
"
Check
timePasswordChanged
"
)
;
}
}
}
}
function
testSubmittingLoginForm
(
aPageFile
aTaskFn
aOrigin
=
"
http
:
/
/
example
.
com
"
)
{
return
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
aOrigin
+
DIRECTORY_PATH
+
aPageFile
}
async
function
(
browser
)
{
ok
(
true
"
loaded
"
+
aPageFile
)
;
let
fieldValues
=
await
ContentTask
.
spawn
(
browser
undefined
async
function
(
)
{
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
(
content
.
location
.
pathname
.
endsWith
(
"
/
formsubmit
.
sjs
"
)
&
&
content
.
document
.
readyState
=
=
"
complete
"
)
;
}
"
Wait
for
form
submission
load
(
formsubmit
.
sjs
)
"
)
;
let
username
=
content
.
document
.
getElementById
(
"
user
"
)
.
textContent
;
let
password
=
content
.
document
.
getElementById
(
"
pass
"
)
.
textContent
;
return
{
username
password
}
;
}
)
;
ok
(
true
"
form
submission
loaded
"
)
;
if
(
aTaskFn
)
{
await
aTaskFn
(
fieldValues
)
;
}
return
fieldValues
;
}
)
;
}
function
checkOnlyLoginWasUsedTwice
(
{
justChanged
}
)
{
let
logins
=
Services
.
logins
.
getAllLogins
(
)
;
is
(
logins
.
length
1
"
Should
only
have
1
login
"
)
;
ok
(
logins
[
0
]
instanceof
Ci
.
nsILoginMetaInfo
"
metainfo
QI
"
)
;
is
(
logins
[
0
]
.
timesUsed
2
"
check
.
timesUsed
for
existing
login
submission
"
)
;
ok
(
logins
[
0
]
.
timeCreated
<
logins
[
0
]
.
timeLastUsed
"
timeLastUsed
bumped
"
)
;
if
(
justChanged
)
{
is
(
logins
[
0
]
.
timeLastUsed
logins
[
0
]
.
timePasswordChanged
"
timeLastUsed
=
=
timePasswordChanged
"
)
;
}
else
{
is
(
logins
[
0
]
.
timeCreated
logins
[
0
]
.
timePasswordChanged
"
timeChanged
not
updated
"
)
;
}
}
function
clearHttpAuths
(
)
{
let
authMgr
=
Cc
[
"
mozilla
.
org
/
network
/
http
-
auth
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIHttpAuthManager
)
;
authMgr
.
clearAll
(
)
;
}
const
REMEMBER_BUTTON
=
"
button
"
;
const
NEVER_MENUITEM
=
0
;
const
CHANGE_BUTTON
=
"
button
"
;
const
DONT_CHANGE_BUTTON
=
"
secondaryButton
"
;
function
getCaptureDoorhanger
(
aKind
popupNotifications
=
PopupNotifications
browser
=
null
)
{
ok
(
true
"
Looking
for
"
+
aKind
+
"
popup
notification
"
)
;
let
notification
=
popupNotifications
.
getNotification
(
"
password
"
browser
)
;
if
(
notification
)
{
is
(
notification
.
options
.
passwordNotificationType
aKind
"
Notification
type
matches
.
"
)
;
if
(
aKind
=
=
"
password
-
change
"
)
{
is
(
notification
.
mainAction
.
label
"
Update
"
"
Main
action
label
matches
update
doorhanger
.
"
)
;
}
else
if
(
aKind
=
=
"
password
-
save
"
)
{
is
(
notification
.
mainAction
.
label
"
Save
"
"
Main
action
label
matches
save
doorhanger
.
"
)
;
}
}
return
notification
;
}
async
function
getCaptureDoorhangerThatMayOpen
(
aKind
popupNotifications
=
PopupNotifications
browser
=
null
)
{
let
notif
=
getCaptureDoorhanger
(
aKind
popupNotifications
browser
)
;
if
(
notif
&
&
!
notif
.
dismissed
)
{
if
(
popupNotifications
.
panel
.
state
!
=
=
"
open
"
)
{
await
BrowserTestUtils
.
waitForEvent
(
popupNotifications
.
panel
"
popupshown
"
)
;
}
}
return
notif
;
}
function
clickDoorhangerButton
(
aPopup
aButtonIndex
)
{
ok
(
true
"
Looking
for
action
at
index
"
+
aButtonIndex
)
;
let
notifications
=
aPopup
.
owner
.
panel
.
children
;
ok
(
notifications
.
length
>
0
"
at
least
one
notification
displayed
"
)
;
ok
(
true
notifications
.
length
+
"
notification
(
s
)
"
)
;
let
notification
=
notifications
[
0
]
;
if
(
aButtonIndex
=
=
"
button
"
)
{
ok
(
true
"
Triggering
main
action
"
)
;
notification
.
button
.
doCommand
(
)
;
}
else
if
(
aButtonIndex
=
=
"
secondaryButton
"
)
{
ok
(
true
"
Triggering
secondary
action
"
)
;
notification
.
secondaryButton
.
doCommand
(
)
;
}
else
{
ok
(
true
"
Triggering
menuitem
#
"
+
aButtonIndex
)
;
notification
.
menupopup
.
querySelectorAll
(
"
menuitem
"
)
[
aButtonIndex
]
.
doCommand
(
)
;
}
}
async
function
cleanupDoorhanger
(
notif
)
{
let
PN
=
notif
?
notif
.
owner
:
PopupNotifications
;
if
(
notif
)
{
notif
.
remove
(
)
;
}
let
promiseHidden
=
PN
.
isPanelOpen
?
BrowserTestUtils
.
waitForEvent
(
PN
.
panel
"
popuphidden
"
)
:
Promise
.
resolve
;
PN
.
panel
.
hidePopup
(
)
;
await
promiseHidden
;
}
async
function
checkDoorhangerUsernamePassword
(
username
password
)
{
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
(
document
.
getElementById
(
"
password
-
notification
-
username
"
)
.
value
=
=
username
)
;
}
"
Wait
for
nsLoginManagerPrompter
writeDataToUI
(
)
"
)
;
is
(
document
.
getElementById
(
"
password
-
notification
-
username
"
)
.
value
username
"
Check
doorhanger
username
"
)
;
is
(
document
.
getElementById
(
"
password
-
notification
-
password
"
)
.
value
password
"
Check
doorhanger
password
"
)
;
}
async
function
waitForPasswordManagerDialog
(
openingFunc
)
{
let
win
;
await
openingFunc
(
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
win
=
Services
.
wm
.
getMostRecentWindow
(
"
Toolkit
:
PasswordManager
"
)
;
return
win
&
&
win
.
document
.
getElementById
(
"
filter
"
)
;
}
"
Waiting
for
the
password
manager
dialog
to
open
"
)
;
return
{
filterValue
:
win
.
document
.
getElementById
(
"
filter
"
)
.
value
async
close
(
)
{
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
}
;
}
async
function
waitForPasswordManagerTab
(
openingFunc
waitForFilter
)
{
info
(
"
waiting
for
new
tab
to
open
"
)
;
let
tabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
null
)
;
await
openingFunc
(
)
;
let
tab
=
await
tabPromise
;
ok
(
tab
"
got
password
management
tab
"
)
;
let
filterValue
;
if
(
waitForFilter
)
{
filterValue
=
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
null
async
(
)
=
>
{
let
loginFilter
=
Cu
.
waiveXrays
(
content
.
document
.
querySelector
(
"
login
-
filter
"
)
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
!
!
loginFilter
.
value
"
wait
for
login
-
filter
to
have
a
value
"
)
;
return
loginFilter
.
value
;
}
)
;
}
return
{
filterValue
close
(
)
{
BrowserTestUtils
.
removeTab
(
tab
)
;
}
}
;
}
function
openPasswordManager
(
openingFunc
waitForFilter
)
{
return
Services
.
prefs
.
getCharPref
(
"
signon
.
management
.
overrideURI
"
)
?
waitForPasswordManagerTab
(
openingFunc
waitForFilter
)
:
waitForPasswordManagerDialog
(
openingFunc
)
;
}
async
function
openACPopup
(
popup
browser
inputSelector
)
{
let
promiseShown
=
BrowserTestUtils
.
waitForEvent
(
popup
"
popupshown
"
)
;
await
SimpleTest
.
promiseFocus
(
browser
)
;
info
(
"
content
window
focused
"
)
;
await
ContentTask
.
spawn
(
browser
[
inputSelector
]
function
openAutocomplete
(
sel
)
{
content
.
document
.
querySelector
(
sel
)
.
focus
(
)
;
}
)
;
let
shown
=
await
promiseShown
;
ok
(
shown
"
autocomplete
popup
shown
"
)
;
return
shown
;
}
async
function
openPasswordContextMenu
(
browser
passwordInput
assertCallback
=
null
)
{
const
doc
=
browser
.
ownerDocument
;
const
CONTEXT_MENU
=
doc
.
getElementById
(
"
contentAreaContextMenu
"
)
;
const
POPUP_HEADER
=
doc
.
getElementById
(
"
fill
-
login
"
)
;
const
LOGIN_POPUP
=
doc
.
getElementById
(
"
fill
-
login
-
popup
"
)
;
let
contextMenuShownPromise
=
BrowserTestUtils
.
waitForEvent
(
CONTEXT_MENU
"
popupshown
"
)
;
let
eventDetails
=
{
type
:
"
mousedown
"
button
:
2
}
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
passwordInput
eventDetails
browser
)
;
eventDetails
=
{
type
:
"
contextmenu
"
button
:
2
}
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
passwordInput
eventDetails
browser
)
;
await
contextMenuShownPromise
;
if
(
assertCallback
)
{
let
shouldContinue
=
await
assertCallback
(
)
;
if
(
!
shouldContinue
)
{
return
;
}
}
let
popupShownPromise
=
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
POPUP_HEADER
.
open
&
&
BrowserTestUtils
.
is_visible
(
LOGIN_POPUP
)
)
;
EventUtils
.
synthesizeMouseAtCenter
(
POPUP_HEADER
{
}
browser
.
ownerGlobal
)
;
await
popupShownPromise
;
}
async
function
doFillGeneratedPasswordContextMenuItem
(
browser
passwordInput
)
{
await
SimpleTest
.
promiseFocus
(
browser
)
;
await
openPasswordContextMenu
(
browser
passwordInput
)
;
let
loginPopup
=
document
.
getElementById
(
"
fill
-
login
-
popup
"
)
;
let
generatedPasswordItem
=
document
.
getElementById
(
"
fill
-
login
-
generated
-
password
"
)
;
let
generatedPasswordSeparator
=
document
.
getElementById
(
"
generated
-
password
-
separator
"
)
;
ok
(
BrowserTestUtils
.
is_visible
(
loginPopup
)
"
Popup
is
visible
"
)
;
ok
(
BrowserTestUtils
.
is_visible
(
generatedPasswordItem
)
"
generated
password
item
is
visible
"
)
;
ok
(
BrowserTestUtils
.
is_visible
(
generatedPasswordSeparator
)
"
separator
is
visible
"
)
;
let
passwordChangedPromise
=
ContentTask
.
spawn
(
browser
[
passwordInput
]
async
function
(
passwordInput
)
{
let
input
=
content
.
document
.
querySelector
(
passwordInput
)
;
await
ContentTaskUtils
.
waitForEvent
(
input
"
input
"
)
;
}
)
;
generatedPasswordItem
.
doCommand
(
)
;
info
(
"
Waiting
for
input
event
"
)
;
await
passwordChangedPromise
;
document
.
getElementById
(
"
contentAreaContextMenu
"
)
.
hidePopup
(
)
;
}
