"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
LoginManagerContextMenu
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginManagerParent
"
"
resource
:
/
/
gre
/
modules
/
LoginManagerParent
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
return
LoginHelper
.
createLogger
(
"
LoginManagerContextMenu
"
)
;
}
)
;
this
.
LoginManagerContextMenu
=
{
addLoginsToMenu
(
inputElementIdentifier
browser
formOrigin
)
{
let
foundLogins
=
this
.
_findLogins
(
formOrigin
)
;
if
(
!
foundLogins
.
length
)
{
return
null
;
}
let
fragment
=
browser
.
ownerDocument
.
createDocumentFragment
(
)
;
let
duplicateUsernames
=
this
.
_findDuplicates
(
foundLogins
)
;
for
(
let
login
of
foundLogins
)
{
let
item
=
fragment
.
ownerDocument
.
createXULElement
(
"
menuitem
"
)
;
let
username
=
login
.
username
;
if
(
!
username
|
|
duplicateUsernames
.
has
(
username
)
)
{
if
(
!
username
)
{
username
=
this
.
_getLocalizedString
(
"
noUsername
"
)
;
}
let
meta
=
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
let
time
=
this
.
dateAndTimeFormatter
.
format
(
new
Date
(
meta
.
timePasswordChanged
)
)
;
username
=
this
.
_getLocalizedString
(
"
loginHostAge
"
[
username
time
]
)
;
}
item
.
setAttribute
(
"
label
"
username
)
;
item
.
setAttribute
(
"
class
"
"
context
-
login
-
item
"
)
;
item
.
addEventListener
(
"
command
"
function
(
login
event
)
{
this
.
_fillTargetField
(
login
inputElementIdentifier
browser
formOrigin
)
;
}
.
bind
(
this
login
)
)
;
fragment
.
appendChild
(
item
)
;
}
return
fragment
;
}
clearLoginsFromMenu
(
document
)
{
let
loginItems
=
document
.
getElementsByClassName
(
"
context
-
login
-
item
"
)
;
while
(
loginItems
.
item
(
0
)
)
{
loginItems
.
item
(
0
)
.
remove
(
)
;
}
}
async
fillGeneratedPassword
(
inputElementIdentifier
documentURI
browser
)
{
let
browsingContextId
=
inputElementIdentifier
.
browsingContextId
;
let
browsingContext
=
BrowsingContext
.
get
(
browsingContextId
)
;
if
(
!
browsingContext
)
{
return
;
}
let
actor
=
browsingContext
.
currentWindowGlobal
.
getActor
(
"
LoginManager
"
)
;
if
(
!
actor
)
{
return
;
}
let
password
=
actor
.
getGeneratedPassword
(
)
;
let
origin
=
LoginHelper
.
getLoginOrigin
(
documentURI
.
spec
)
;
log
.
debug
(
"
fillGeneratedPassword
into
:
"
inputElementIdentifier
origin
)
;
let
recipes
=
[
]
;
let
formHost
;
try
{
formHost
=
documentURI
.
hostPort
;
let
recipeManager
=
await
LoginManagerParent
.
recipeParentPromise
;
recipes
=
recipeManager
.
getRecipesForHost
(
formHost
)
;
}
catch
(
ex
)
{
log
.
debug
(
"
Couldnt
get
recipes
for
formHost
:
"
formHost
ex
)
;
}
let
browserURI
=
browser
.
browsingContext
.
currentWindowGlobal
.
documentURI
;
let
originMatches
=
LoginHelper
.
getLoginOrigin
(
browserURI
)
=
=
origin
;
actor
.
sendAsyncMessage
(
"
PasswordManager
:
fillGeneratedPassword
"
{
password
origin
originMatches
inputElementIdentifier
recipes
}
)
;
}
_findLogins
(
formOrigin
)
{
let
searchParams
=
{
origin
:
formOrigin
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
}
;
let
logins
=
LoginHelper
.
searchLoginsWithObject
(
searchParams
)
;
let
resolveBy
=
[
"
scheme
"
"
timePasswordChanged
"
]
;
logins
=
LoginHelper
.
dedupeLogins
(
logins
[
"
username
"
"
password
"
]
resolveBy
formOrigin
)
;
logins
.
sort
(
(
loginA
loginB
)
=
>
{
let
result
=
loginA
.
username
.
localeCompare
(
loginB
.
username
)
;
if
(
result
)
{
if
(
!
loginA
.
username
)
{
return
1
;
}
if
(
!
loginB
.
username
)
{
return
-
1
;
}
return
result
;
}
let
metaA
=
loginA
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
let
metaB
=
loginB
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
return
metaB
.
timePasswordChanged
-
metaA
.
timePasswordChanged
;
}
)
;
return
logins
;
}
_findDuplicates
(
loginList
)
{
let
seen
=
new
Set
(
)
;
let
duplicates
=
new
Set
(
)
;
for
(
let
login
of
loginList
)
{
if
(
seen
.
has
(
login
.
username
)
)
{
duplicates
.
add
(
login
.
username
)
;
}
seen
.
add
(
login
.
username
)
;
}
return
duplicates
;
}
_fillTargetField
(
login
inputElementIdentifier
browser
formOrigin
)
{
let
browsingContextId
=
inputElementIdentifier
.
browsingContextId
;
let
browsingContext
=
BrowsingContext
.
get
(
browsingContextId
)
;
if
(
!
browsingContext
)
{
return
;
}
let
actor
=
browsingContext
.
currentWindowGlobal
.
getActor
(
"
LoginManager
"
)
;
if
(
!
actor
)
{
return
;
}
actor
.
fillForm
(
{
browser
inputElementIdentifier
loginFormOrigin
:
formOrigin
login
}
)
.
catch
(
Cu
.
reportError
)
;
}
_getLocalizedString
(
key
formatArgs
)
{
if
(
formatArgs
)
{
return
this
.
_stringBundle
.
formatStringFromName
(
key
formatArgs
)
;
}
return
this
.
_stringBundle
.
GetStringFromName
(
key
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
LoginManagerContextMenu
"
_stringBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
passwordmgr
/
locale
/
passwordmgr
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
LoginManagerContextMenu
"
dateAndTimeFormatter
"
function
(
)
{
return
new
Services
.
intl
.
DateTimeFormat
(
undefined
{
dateStyle
:
"
medium
"
}
)
;
}
)
;
