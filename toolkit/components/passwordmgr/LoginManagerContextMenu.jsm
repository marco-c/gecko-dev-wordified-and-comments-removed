"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
LoginManagerContextMenu
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginManagerParent
"
"
resource
:
/
/
gre
/
modules
/
LoginManagerParent
.
jsm
"
)
;
var
LoginManagerContextMenu
=
{
addLoginsToMenu
(
inputElement
browser
documentURI
)
{
let
foundLogins
=
this
.
_findLogins
(
documentURI
)
;
if
(
!
foundLogins
.
length
)
{
return
null
;
}
let
fragment
=
browser
.
ownerDocument
.
createDocumentFragment
(
)
;
let
duplicateUsernames
=
this
.
_findDuplicates
(
foundLogins
)
;
for
(
let
login
of
foundLogins
)
{
let
item
=
fragment
.
ownerDocument
.
createXULElement
(
"
menuitem
"
)
;
let
username
=
login
.
username
;
if
(
!
username
|
|
duplicateUsernames
.
has
(
username
)
)
{
if
(
!
username
)
{
username
=
this
.
_getLocalizedString
(
"
noUsername
"
)
;
}
let
meta
=
login
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
let
time
=
this
.
dateAndTimeFormatter
.
format
(
new
Date
(
meta
.
timePasswordChanged
)
)
;
username
=
this
.
_getLocalizedString
(
"
loginHostAge
"
[
username
time
]
)
;
}
item
.
setAttribute
(
"
label
"
username
)
;
item
.
setAttribute
(
"
class
"
"
context
-
login
-
item
"
)
;
item
.
addEventListener
(
"
command
"
function
(
login
event
)
{
this
.
_fillTargetField
(
login
inputElement
browser
documentURI
)
;
}
.
bind
(
this
login
)
)
;
fragment
.
appendChild
(
item
)
;
}
return
fragment
;
}
clearLoginsFromMenu
(
document
)
{
let
loginItems
=
document
.
getElementsByClassName
(
"
context
-
login
-
item
"
)
;
while
(
loginItems
.
item
(
0
)
)
{
loginItems
.
item
(
0
)
.
remove
(
)
;
}
}
_findLogins
(
documentURI
)
{
let
searchParams
=
{
hostname
:
documentURI
.
displayPrePath
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
}
;
let
logins
=
LoginHelper
.
searchLoginsWithObject
(
searchParams
)
;
let
resolveBy
=
[
"
scheme
"
"
timePasswordChanged
"
]
;
logins
=
LoginHelper
.
dedupeLogins
(
logins
[
"
username
"
"
password
"
]
resolveBy
documentURI
.
displayPrePath
)
;
logins
.
sort
(
(
loginA
loginB
)
=
>
{
let
result
=
loginA
.
username
.
localeCompare
(
loginB
.
username
)
;
if
(
result
)
{
if
(
!
loginA
.
username
)
{
return
1
;
}
if
(
!
loginB
.
username
)
{
return
-
1
;
}
return
result
;
}
let
metaA
=
loginA
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
let
metaB
=
loginB
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
;
return
metaB
.
timePasswordChanged
-
metaA
.
timePasswordChanged
;
}
)
;
return
logins
;
}
_findDuplicates
(
loginList
)
{
let
seen
=
new
Set
(
)
;
let
duplicates
=
new
Set
(
)
;
for
(
let
login
of
loginList
)
{
if
(
seen
.
has
(
login
.
username
)
)
{
duplicates
.
add
(
login
.
username
)
;
}
seen
.
add
(
login
.
username
)
;
}
return
duplicates
;
}
_fillTargetField
(
login
inputElement
browser
documentURI
)
{
LoginManagerParent
.
fillForm
(
{
browser
loginFormOrigin
:
documentURI
.
displayPrePath
login
inputElement
}
)
.
catch
(
Cu
.
reportError
)
;
}
_getLocalizedString
(
key
formatArgs
)
{
if
(
formatArgs
)
{
return
this
.
_stringBundle
.
formatStringFromName
(
key
formatArgs
formatArgs
.
length
)
;
}
return
this
.
_stringBundle
.
GetStringFromName
(
key
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
LoginManagerContextMenu
"
_stringBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
passwordmgr
/
locale
/
passwordmgr
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
LoginManagerContextMenu
"
dateAndTimeFormatter
"
function
(
)
{
return
new
Services
.
intl
.
DateTimeFormat
(
undefined
{
dateStyle
:
"
medium
"
}
)
;
}
)
;
