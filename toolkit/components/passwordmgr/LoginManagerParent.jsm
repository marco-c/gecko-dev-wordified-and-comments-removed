"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AutoCompletePopup
"
"
resource
:
/
/
gre
/
modules
/
AutoCompletePopup
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
logger
=
LoginHelper
.
createLogger
(
"
LoginManagerParent
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
LoginManagerParent
"
]
;
var
LoginManagerParent
=
{
_recipeManager
:
null
_lastMPLoginCancelled
:
Math
.
NEGATIVE_INFINITY
_searchAndDedupeLogins
(
formOrigin
actionOrigin
)
{
let
logins
;
try
{
logins
=
LoginHelper
.
searchLoginsWithObject
(
{
hostname
:
formOrigin
formSubmitURL
:
actionOrigin
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
}
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_ABORT
)
{
log
(
"
User
cancelled
master
password
prompt
.
"
)
;
this
.
_lastMPLoginCancelled
=
Date
.
now
(
)
;
return
[
]
;
}
throw
e
;
}
let
resolveBy
=
[
"
scheme
"
"
timePasswordChanged
"
]
;
return
LoginHelper
.
dedupeLogins
(
logins
[
"
username
"
]
resolveBy
formOrigin
)
;
}
receiveMessage
(
msg
)
{
let
data
=
msg
.
data
;
switch
(
msg
.
name
)
{
case
"
RemoteLogins
:
findLogins
"
:
{
this
.
sendLoginDataToChild
(
data
.
options
.
showMasterPassword
data
.
formOrigin
data
.
actionOrigin
data
.
requestId
msg
.
target
.
messageManager
)
;
break
;
}
case
"
RemoteLogins
:
findRecipes
"
:
{
let
formHost
=
(
new
URL
(
data
.
formOrigin
)
)
.
host
;
return
this
.
_recipeManager
.
getRecipesForHost
(
formHost
)
;
}
case
"
RemoteLogins
:
onFormSubmit
"
:
{
this
.
onFormSubmit
(
data
.
hostname
data
.
formSubmitURL
data
.
usernameField
data
.
newPasswordField
data
.
oldPasswordField
data
.
openerTopWindowID
msg
.
target
)
;
break
;
}
case
"
RemoteLogins
:
insecureLoginFormPresent
"
:
{
this
.
setHasInsecureLoginForms
(
msg
.
target
data
.
hasInsecureLoginForms
)
;
break
;
}
case
"
RemoteLogins
:
autoCompleteLogins
"
:
{
this
.
doAutocompleteSearch
(
data
msg
.
target
)
;
break
;
}
case
"
RemoteLogins
:
removeLogin
"
:
{
let
login
=
LoginHelper
.
vanillaObjectToLogin
(
data
.
login
)
;
AutoCompletePopup
.
removeLogin
(
login
)
;
break
;
}
}
return
undefined
;
}
async
fillForm
(
{
browser
loginFormOrigin
login
inputElement
}
)
{
let
recipes
=
[
]
;
if
(
loginFormOrigin
)
{
let
formHost
;
try
{
formHost
=
(
new
URL
(
loginFormOrigin
)
)
.
host
;
let
recipeManager
=
await
this
.
recipeParentPromise
;
recipes
=
recipeManager
.
getRecipesForHost
(
formHost
)
;
}
catch
(
ex
)
{
}
}
let
jsLogins
=
[
LoginHelper
.
loginToVanillaObject
(
login
)
]
;
let
objects
=
inputElement
?
{
inputElement
}
:
null
;
browser
.
messageManager
.
sendAsyncMessage
(
"
RemoteLogins
:
fillForm
"
{
loginFormOrigin
logins
:
jsLogins
recipes
}
objects
)
;
}
async
sendLoginDataToChild
(
showMasterPassword
formOrigin
actionOrigin
requestId
target
)
{
let
recipes
=
[
]
;
if
(
formOrigin
)
{
let
formHost
;
try
{
formHost
=
(
new
URL
(
formOrigin
)
)
.
host
;
let
recipeManager
=
await
this
.
recipeParentPromise
;
recipes
=
recipeManager
.
getRecipesForHost
(
formHost
)
;
}
catch
(
ex
)
{
}
}
if
(
!
showMasterPassword
&
&
!
Services
.
logins
.
isLoggedIn
)
{
try
{
target
.
sendAsyncMessage
(
"
RemoteLogins
:
loginsFound
"
{
requestId
logins
:
[
]
recipes
}
)
;
}
catch
(
e
)
{
log
(
"
error
sending
message
to
target
"
e
)
;
}
return
;
}
if
(
Services
.
logins
.
uiBusy
)
{
log
(
"
deferring
sendLoginDataToChild
for
"
formOrigin
)
;
let
self
=
this
;
let
observer
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
observe
(
subject
topic
data
)
{
log
(
"
Got
deferred
sendLoginDataToChild
notification
:
"
topic
)
;
Services
.
obs
.
removeObserver
(
this
"
passwordmgr
-
crypto
-
login
"
)
;
Services
.
obs
.
removeObserver
(
this
"
passwordmgr
-
crypto
-
loginCanceled
"
)
;
if
(
topic
=
=
"
passwordmgr
-
crypto
-
loginCanceled
"
)
{
target
.
sendAsyncMessage
(
"
RemoteLogins
:
loginsFound
"
{
requestId
logins
:
[
]
recipes
}
)
;
return
;
}
self
.
sendLoginDataToChild
(
showMasterPassword
formOrigin
actionOrigin
requestId
target
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
"
passwordmgr
-
crypto
-
login
"
)
;
Services
.
obs
.
addObserver
(
observer
"
passwordmgr
-
crypto
-
loginCanceled
"
)
;
return
;
}
let
logins
=
this
.
_searchAndDedupeLogins
(
formOrigin
actionOrigin
)
;
log
(
"
sendLoginDataToChild
:
"
logins
.
length
"
deduped
logins
"
)
;
var
jsLogins
=
LoginHelper
.
loginsToVanillaObjects
(
logins
)
;
target
.
sendAsyncMessage
(
"
RemoteLogins
:
loginsFound
"
{
requestId
logins
:
jsLogins
recipes
}
)
;
}
doAutocompleteSearch
(
{
formOrigin
actionOrigin
searchString
previousResult
rect
requestId
isSecure
isPasswordField
}
target
)
{
if
(
!
Services
.
logins
.
isLoggedIn
)
{
let
timeDiff
=
Date
.
now
(
)
-
this
.
_lastMPLoginCancelled
;
if
(
timeDiff
<
this
.
_repromptTimeout
)
{
log
(
"
Not
searching
logins
for
autocomplete
since
the
master
password
"
+
prompt
was
last
cancelled
{
Math
.
round
(
timeDiff
/
1000
)
}
seconds
ago
.
)
;
target
.
messageManager
.
sendAsyncMessage
(
"
RemoteLogins
:
loginsAutoCompleted
"
{
requestId
logins
:
[
]
}
)
;
return
;
}
}
let
searchStringLower
=
searchString
.
toLowerCase
(
)
;
let
logins
;
if
(
previousResult
&
&
searchStringLower
.
startsWith
(
previousResult
.
searchString
.
toLowerCase
(
)
)
)
{
log
(
"
Using
previous
autocomplete
result
"
)
;
logins
=
LoginHelper
.
vanillaObjectsToLogins
(
previousResult
.
logins
)
;
}
else
{
log
(
"
Creating
new
autocomplete
search
result
.
"
)
;
logins
=
this
.
_searchAndDedupeLogins
(
formOrigin
actionOrigin
)
;
}
let
matchingLogins
=
logins
.
filter
(
function
(
fullMatch
)
{
let
match
=
fullMatch
.
username
;
if
(
isPasswordField
)
{
return
true
;
}
return
match
&
&
match
.
toLowerCase
(
)
.
startsWith
(
searchStringLower
)
;
}
)
;
var
jsLogins
=
LoginHelper
.
loginsToVanillaObjects
(
matchingLogins
)
;
target
.
messageManager
.
sendAsyncMessage
(
"
RemoteLogins
:
loginsAutoCompleted
"
{
requestId
logins
:
jsLogins
}
)
;
}
onFormSubmit
(
hostname
formSubmitURL
usernameField
newPasswordField
oldPasswordField
openerTopWindowID
target
)
{
function
getPrompter
(
)
{
var
prompterSvc
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
prompter
;
1
"
]
.
createInstance
(
Ci
.
nsILoginManagerPrompter
)
;
prompterSvc
.
init
(
target
.
ownerGlobal
)
;
prompterSvc
.
browser
=
target
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
if
(
!
win
.
gBrowser
&
&
!
win
.
getBrowser
)
{
continue
;
}
let
tabbrowser
=
win
.
gBrowser
|
|
win
.
getBrowser
(
)
;
if
(
tabbrowser
)
{
let
browser
=
tabbrowser
.
getBrowserForOuterWindowID
(
openerTopWindowID
)
;
if
(
browser
)
{
prompterSvc
.
openerBrowser
=
browser
;
break
;
}
}
}
return
prompterSvc
;
}
function
recordLoginUse
(
login
)
{
if
(
!
target
|
|
PrivateBrowsingUtils
.
isBrowserPrivate
(
target
)
)
{
return
;
}
let
propBag
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
propBag
.
setProperty
(
"
timeLastUsed
"
Date
.
now
(
)
)
;
propBag
.
setProperty
(
"
timesUsedIncrement
"
1
)
;
Services
.
logins
.
modifyLogin
(
login
propBag
)
;
}
if
(
!
Services
.
logins
.
getLoginSavingEnabled
(
hostname
)
)
{
log
(
"
(
form
submission
ignored
-
-
saving
is
disabled
for
:
"
hostname
"
)
"
)
;
return
;
}
var
formLogin
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
formLogin
.
init
(
hostname
formSubmitURL
null
(
usernameField
?
usernameField
.
value
:
"
"
)
newPasswordField
.
value
(
usernameField
?
usernameField
.
name
:
"
"
)
newPasswordField
.
name
)
;
let
logins
=
this
.
_searchAndDedupeLogins
(
hostname
formSubmitURL
)
;
if
(
!
usernameField
&
&
oldPasswordField
&
&
logins
.
length
>
0
)
{
var
prompter
=
getPrompter
(
)
;
if
(
logins
.
length
=
=
1
)
{
var
oldLogin
=
logins
[
0
]
;
if
(
oldLogin
.
password
=
=
formLogin
.
password
)
{
recordLoginUse
(
oldLogin
)
;
log
(
"
(
Not
prompting
to
save
/
change
since
we
have
no
username
and
the
"
+
"
only
saved
password
matches
the
new
password
)
"
)
;
return
;
}
formLogin
.
username
=
oldLogin
.
username
;
formLogin
.
usernameField
=
oldLogin
.
usernameField
;
prompter
.
promptToChangePassword
(
oldLogin
formLogin
)
;
}
else
{
prompter
.
promptToChangePasswordWithUsernames
(
logins
logins
.
length
formLogin
)
;
}
return
;
}
var
existingLogin
=
null
;
for
(
let
login
of
logins
)
{
let
same
;
if
(
!
login
.
username
&
&
formLogin
.
username
)
{
var
restoreMe
=
formLogin
.
username
;
formLogin
.
username
=
"
"
;
same
=
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
false
ignoreSchemes
:
LoginHelper
.
schemeUpgrades
}
)
;
formLogin
.
username
=
restoreMe
;
}
else
if
(
!
formLogin
.
username
&
&
login
.
username
)
{
formLogin
.
username
=
login
.
username
;
same
=
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
false
ignoreSchemes
:
LoginHelper
.
schemeUpgrades
}
)
;
formLogin
.
username
=
"
"
;
}
else
{
same
=
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
true
ignoreSchemes
:
LoginHelper
.
schemeUpgrades
}
)
;
}
if
(
same
)
{
existingLogin
=
login
;
break
;
}
}
if
(
existingLogin
)
{
log
(
"
Found
an
existing
login
matching
this
form
submission
"
)
;
if
(
existingLogin
.
password
!
=
formLogin
.
password
)
{
log
(
"
.
.
.
passwords
differ
prompting
to
change
.
"
)
;
prompter
=
getPrompter
(
)
;
prompter
.
promptToChangePassword
(
existingLogin
formLogin
)
;
}
else
if
(
!
existingLogin
.
username
&
&
formLogin
.
username
)
{
log
(
"
.
.
.
empty
username
update
prompting
to
change
.
"
)
;
prompter
=
getPrompter
(
)
;
prompter
.
promptToChangePassword
(
existingLogin
formLogin
)
;
}
else
{
recordLoginUse
(
existingLogin
)
;
}
return
;
}
prompter
=
getPrompter
(
)
;
prompter
.
promptToSavePassword
(
formLogin
)
;
}
loginFormStateByBrowser
:
new
WeakMap
(
)
stateForBrowser
(
browser
)
{
let
loginFormState
=
this
.
loginFormStateByBrowser
.
get
(
browser
)
;
if
(
!
loginFormState
)
{
loginFormState
=
{
}
;
this
.
loginFormStateByBrowser
.
set
(
browser
loginFormState
)
;
}
return
loginFormState
;
}
hasInsecureLoginForms
(
browser
)
{
return
!
!
this
.
stateForBrowser
(
browser
)
.
hasInsecureLoginForms
;
}
setHasInsecureLoginForms
(
browser
hasInsecureLoginForms
)
{
let
state
=
this
.
stateForBrowser
(
browser
)
;
state
.
hasInsecureLoginForms
=
hasInsecureLoginForms
;
browser
.
dispatchEvent
(
new
browser
.
ownerGlobal
.
CustomEvent
(
"
InsecureLoginFormsStateChange
"
)
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
LoginManagerParent
"
recipeParentPromise
"
function
(
)
{
const
{
LoginRecipesParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoginRecipes
.
jsm
"
)
;
this
.
_recipeManager
=
new
LoginRecipesParent
(
{
defaults
:
Services
.
prefs
.
getStringPref
(
"
signon
.
recipes
.
path
"
)
}
)
;
return
this
.
_recipeManager
.
initializationPromise
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
LoginManagerParent
"
_repromptTimeout
"
"
signon
.
masterPasswordReprompt
.
timeout_ms
"
900000
)
;
