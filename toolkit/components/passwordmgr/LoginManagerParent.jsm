"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AutoCompletePopup
"
"
resource
:
/
/
gre
/
modules
/
AutoCompletePopup
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PasswordGenerator
"
"
resource
:
/
/
gre
/
modules
/
PasswordGenerator
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
logger
=
LoginHelper
.
createLogger
(
"
LoginManagerParent
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
INCLUDE_OTHER_SUBDOMAINS_IN_LOOKUP
"
"
signon
.
includeOtherSubdomainsInLookup
"
false
)
;
const
EXPORTED_SYMBOLS
=
[
"
LoginManagerParent
"
]
;
this
.
LoginManagerParent
=
{
_generatedPasswordsByPrincipalOrigin
:
new
Map
(
)
_recipeManager
:
null
_lastMPLoginCancelled
:
Math
.
NEGATIVE_INFINITY
_searchAndDedupeLogins
(
formOrigin
{
acceptDifferentSubdomains
formActionOrigin
httpRealm
ignoreActionAndRealm
}
=
{
}
)
{
let
logins
;
let
matchData
=
{
origin
:
formOrigin
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
acceptDifferentSubdomains
}
;
if
(
!
ignoreActionAndRealm
)
{
if
(
typeof
formActionOrigin
!
=
"
undefined
"
)
{
matchData
.
formActionOrigin
=
formActionOrigin
;
}
else
if
(
typeof
httpRealm
!
=
"
undefined
"
)
{
matchData
.
httpRealm
=
httpRealm
;
}
}
try
{
logins
=
LoginHelper
.
searchLoginsWithObject
(
matchData
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_ABORT
)
{
log
(
"
User
cancelled
master
password
prompt
.
"
)
;
this
.
_lastMPLoginCancelled
=
Date
.
now
(
)
;
return
[
]
;
}
throw
e
;
}
logins
=
LoginHelper
.
shadowHTTPLogins
(
logins
)
;
let
resolveBy
=
[
"
actionOrigin
"
"
scheme
"
"
subdomain
"
"
timePasswordChanged
"
]
;
return
LoginHelper
.
dedupeLogins
(
logins
[
"
username
"
"
password
"
]
resolveBy
formOrigin
formActionOrigin
)
;
}
receiveMessage
(
msg
)
{
let
data
=
msg
.
data
;
switch
(
msg
.
name
)
{
case
"
PasswordManager
:
findLogins
"
:
{
this
.
sendLoginDataToChild
(
data
.
formOrigin
data
.
actionOrigin
data
.
requestId
msg
.
target
.
messageManager
data
.
options
)
;
break
;
}
case
"
PasswordManager
:
findRecipes
"
:
{
let
formHost
=
new
URL
(
data
.
formOrigin
)
.
host
;
return
this
.
_recipeManager
.
getRecipesForHost
(
formHost
)
;
}
case
"
PasswordManager
:
onFormSubmit
"
:
{
this
.
onFormSubmit
(
msg
.
target
data
)
;
break
;
}
case
"
PasswordManager
:
onGeneratedPasswordFilled
"
:
{
this
.
_onGeneratedPasswordFilled
(
data
)
;
break
;
}
case
"
PasswordManager
:
insecureLoginFormPresent
"
:
{
this
.
setHasInsecureLoginForms
(
msg
.
target
data
.
hasInsecureLoginForms
)
;
break
;
}
case
"
PasswordManager
:
autoCompleteLogins
"
:
{
this
.
doAutocompleteSearch
(
data
msg
.
target
)
;
break
;
}
case
"
PasswordManager
:
removeLogin
"
:
{
let
login
=
LoginHelper
.
vanillaObjectToLogin
(
data
.
login
)
;
AutoCompletePopup
.
removeLogin
(
login
)
;
break
;
}
case
"
PasswordManager
:
OpenPreferences
"
:
{
LoginHelper
.
openPasswordManager
(
msg
.
target
.
ownerGlobal
{
filterString
:
msg
.
data
.
hostname
entryPoint
:
msg
.
data
.
entryPoint
}
)
;
break
;
}
}
return
undefined
;
}
async
fillForm
(
{
browser
loginFormOrigin
login
inputElementIdentifier
}
)
{
let
recipes
=
[
]
;
if
(
loginFormOrigin
)
{
let
formHost
;
try
{
formHost
=
new
URL
(
loginFormOrigin
)
.
host
;
let
recipeManager
=
await
this
.
recipeParentPromise
;
recipes
=
recipeManager
.
getRecipesForHost
(
formHost
)
;
}
catch
(
ex
)
{
}
}
let
jsLogins
=
[
LoginHelper
.
loginToVanillaObject
(
login
)
]
;
browser
.
messageManager
.
sendAsyncMessage
(
"
PasswordManager
:
fillForm
"
{
inputElementIdentifier
loginFormOrigin
logins
:
jsLogins
recipes
}
)
;
}
async
sendLoginDataToChild
(
formOrigin
actionOrigin
requestId
target
{
guid
showMasterPassword
}
)
{
let
recipes
=
[
]
;
if
(
formOrigin
)
{
let
formHost
;
try
{
formHost
=
new
URL
(
formOrigin
)
.
host
;
let
recipeManager
=
await
this
.
recipeParentPromise
;
recipes
=
recipeManager
.
getRecipesForHost
(
formHost
)
;
}
catch
(
ex
)
{
}
}
if
(
!
showMasterPassword
&
&
!
Services
.
logins
.
isLoggedIn
)
{
try
{
target
.
sendAsyncMessage
(
"
PasswordManager
:
loginsFound
"
{
requestId
logins
:
[
]
recipes
}
)
;
}
catch
(
e
)
{
log
(
"
error
sending
message
to
target
"
e
)
;
}
return
;
}
if
(
Services
.
logins
.
uiBusy
)
{
log
(
"
deferring
sendLoginDataToChild
for
"
formOrigin
)
;
let
self
=
this
;
let
observer
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
observe
(
subject
topic
data
)
{
log
(
"
Got
deferred
sendLoginDataToChild
notification
:
"
topic
)
;
Services
.
obs
.
removeObserver
(
this
"
passwordmgr
-
crypto
-
login
"
)
;
Services
.
obs
.
removeObserver
(
this
"
passwordmgr
-
crypto
-
loginCanceled
"
)
;
if
(
topic
=
=
"
passwordmgr
-
crypto
-
loginCanceled
"
)
{
target
.
sendAsyncMessage
(
"
PasswordManager
:
loginsFound
"
{
requestId
logins
:
[
]
recipes
}
)
;
return
;
}
self
.
sendLoginDataToChild
(
formOrigin
actionOrigin
requestId
target
{
showMasterPassword
}
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
"
passwordmgr
-
crypto
-
login
"
)
;
Services
.
obs
.
addObserver
(
observer
"
passwordmgr
-
crypto
-
loginCanceled
"
)
;
return
;
}
let
logins
=
null
;
if
(
guid
)
{
logins
=
LoginHelper
.
searchLoginsWithObject
(
{
guid
}
)
;
}
else
{
logins
=
this
.
_searchAndDedupeLogins
(
formOrigin
{
formActionOrigin
:
actionOrigin
ignoreActionAndRealm
:
true
acceptDifferentSubdomains
:
INCLUDE_OTHER_SUBDOMAINS_IN_LOOKUP
}
)
;
}
log
(
"
sendLoginDataToChild
:
"
logins
.
length
"
deduped
logins
"
)
;
let
jsLogins
=
LoginHelper
.
loginsToVanillaObjects
(
logins
)
;
target
.
sendAsyncMessage
(
"
PasswordManager
:
loginsFound
"
{
requestId
logins
:
jsLogins
recipes
}
)
;
}
doAutocompleteSearch
(
{
autocompleteInfo
browsingContextId
formOrigin
actionOrigin
searchString
previousResult
requestId
isSecure
isPasswordField
}
target
)
{
if
(
!
Services
.
logins
.
isLoggedIn
)
{
let
timeDiff
=
Date
.
now
(
)
-
this
.
_lastMPLoginCancelled
;
if
(
timeDiff
<
this
.
_repromptTimeout
)
{
log
(
"
Not
searching
logins
for
autocomplete
since
the
master
password
"
+
prompt
was
last
cancelled
{
Math
.
round
(
timeDiff
/
1000
)
}
seconds
ago
.
)
;
target
.
messageManager
.
sendAsyncMessage
(
"
PasswordManager
:
loginsAutoCompleted
"
{
requestId
logins
:
[
]
}
)
;
return
;
}
}
let
searchStringLower
=
searchString
.
toLowerCase
(
)
;
let
logins
;
if
(
previousResult
&
&
searchStringLower
.
startsWith
(
previousResult
.
searchString
.
toLowerCase
(
)
)
)
{
log
(
"
Using
previous
autocomplete
result
"
)
;
logins
=
LoginHelper
.
vanillaObjectsToLogins
(
previousResult
.
logins
)
;
}
else
{
log
(
"
Creating
new
autocomplete
search
result
.
"
)
;
logins
=
this
.
_searchAndDedupeLogins
(
formOrigin
{
formActionOrigin
:
actionOrigin
ignoreActionAndRealm
:
true
acceptDifferentSubdomains
:
INCLUDE_OTHER_SUBDOMAINS_IN_LOOKUP
}
)
;
}
let
matchingLogins
=
logins
.
filter
(
function
(
fullMatch
)
{
let
match
=
fullMatch
.
username
;
if
(
isPasswordField
)
{
return
true
;
}
return
match
&
&
match
.
toLowerCase
(
)
.
startsWith
(
searchStringLower
)
;
}
)
;
let
generatedPassword
=
null
;
if
(
isPasswordField
&
&
autocompleteInfo
.
fieldName
=
=
"
new
-
password
"
&
&
Services
.
logins
.
getLoginSavingEnabled
(
formOrigin
)
)
{
generatedPassword
=
this
.
getGeneratedPassword
(
browsingContextId
)
;
}
let
jsLogins
=
LoginHelper
.
loginsToVanillaObjects
(
matchingLogins
)
;
target
.
messageManager
.
sendAsyncMessage
(
"
PasswordManager
:
loginsAutoCompleted
"
{
requestId
generatedPassword
logins
:
jsLogins
}
)
;
}
get
_browsingContextGlobal
(
)
{
return
BrowsingContext
;
}
getGeneratedPassword
(
browsingContextId
)
{
if
(
!
LoginHelper
.
enabled
|
|
!
LoginHelper
.
generationAvailable
|
|
!
LoginHelper
.
generationEnabled
)
{
return
null
;
}
let
browsingContext
=
BrowsingContext
.
get
(
browsingContextId
)
;
if
(
!
browsingContext
)
{
return
null
;
}
let
framePrincipalOrigin
=
browsingContext
.
currentWindowGlobal
.
documentPrincipal
.
origin
;
let
generatedPW
=
this
.
_generatedPasswordsByPrincipalOrigin
.
get
(
framePrincipalOrigin
)
;
if
(
generatedPW
)
{
return
generatedPW
.
value
;
}
generatedPW
=
{
value
:
PasswordGenerator
.
generatePassword
(
)
filled
:
false
}
;
this
.
_generatedPasswordsByPrincipalOrigin
.
set
(
framePrincipalOrigin
generatedPW
)
;
return
generatedPW
.
value
;
}
onFormSubmit
(
browser
{
origin
formActionOrigin
autoFilledLoginGuid
usernameField
newPasswordField
oldPasswordField
openerTopWindowID
dismissedPrompt
}
)
{
function
getPrompter
(
)
{
let
prompterSvc
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
prompter
;
1
"
]
.
createInstance
(
Ci
.
nsILoginManagerPrompter
)
;
prompterSvc
.
init
(
browser
.
ownerGlobal
)
;
prompterSvc
.
browser
=
browser
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
let
tabbrowser
=
win
.
gBrowser
;
if
(
tabbrowser
)
{
let
browser
=
tabbrowser
.
getBrowserForOuterWindowID
(
openerTopWindowID
)
;
if
(
browser
)
{
prompterSvc
.
openerBrowser
=
browser
;
break
;
}
}
}
return
prompterSvc
;
}
function
recordLoginUse
(
login
)
{
if
(
!
browser
|
|
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
)
{
return
;
}
let
propBag
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
propBag
.
setProperty
(
"
timeLastUsed
"
Date
.
now
(
)
)
;
propBag
.
setProperty
(
"
timesUsedIncrement
"
1
)
;
Services
.
logins
.
modifyLogin
(
login
propBag
)
;
}
if
(
!
Services
.
logins
.
getLoginSavingEnabled
(
origin
)
)
{
log
(
"
(
form
submission
ignored
-
-
saving
is
disabled
for
:
"
origin
"
)
"
)
;
return
;
}
let
formLogin
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
formLogin
.
init
(
origin
formActionOrigin
null
usernameField
?
usernameField
.
value
:
"
"
newPasswordField
.
value
usernameField
?
usernameField
.
name
:
"
"
newPasswordField
.
name
)
;
if
(
autoFilledLoginGuid
)
{
let
loginsForGuid
=
LoginHelper
.
searchLoginsWithObject
(
{
guid
:
autoFilledLoginGuid
}
)
;
if
(
loginsForGuid
.
length
=
=
1
&
&
loginsForGuid
[
0
]
.
password
=
=
formLogin
.
password
&
&
(
!
formLogin
.
username
|
|
loginsForGuid
[
0
]
.
username
=
=
formLogin
.
username
)
)
{
log
(
"
The
filled
login
matches
the
form
submission
.
Nothing
to
change
.
"
)
;
recordLoginUse
(
loginsForGuid
[
0
]
)
;
return
;
}
}
let
logins
=
this
.
_searchAndDedupeLogins
(
origin
{
formActionOrigin
}
)
;
if
(
!
usernameField
&
&
oldPasswordField
&
&
logins
.
length
>
0
)
{
let
prompter
=
getPrompter
(
)
;
if
(
logins
.
length
=
=
1
)
{
let
oldLogin
=
logins
[
0
]
;
if
(
oldLogin
.
password
=
=
formLogin
.
password
)
{
recordLoginUse
(
oldLogin
)
;
log
(
"
(
Not
prompting
to
save
/
change
since
we
have
no
username
and
the
"
+
"
only
saved
password
matches
the
new
password
)
"
)
;
return
;
}
formLogin
.
username
=
oldLogin
.
username
;
formLogin
.
usernameField
=
oldLogin
.
usernameField
;
prompter
.
promptToChangePassword
(
oldLogin
formLogin
dismissedPrompt
)
;
}
else
{
prompter
.
promptToChangePasswordWithUsernames
(
logins
formLogin
)
;
}
return
;
}
let
existingLogin
=
null
;
for
(
let
login
of
logins
)
{
let
same
;
if
(
!
login
.
username
&
&
formLogin
.
username
)
{
let
restoreMe
=
formLogin
.
username
;
formLogin
.
username
=
"
"
;
same
=
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
false
ignoreSchemes
:
LoginHelper
.
schemeUpgrades
}
)
;
formLogin
.
username
=
restoreMe
;
}
else
if
(
!
formLogin
.
username
&
&
login
.
username
)
{
formLogin
.
username
=
login
.
username
;
same
=
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
false
ignoreSchemes
:
LoginHelper
.
schemeUpgrades
}
)
;
formLogin
.
username
=
"
"
;
}
else
{
same
=
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
true
ignoreSchemes
:
LoginHelper
.
schemeUpgrades
}
)
;
}
if
(
same
)
{
existingLogin
=
login
;
break
;
}
}
if
(
existingLogin
)
{
log
(
"
Found
an
existing
login
matching
this
form
submission
"
)
;
if
(
existingLogin
.
password
!
=
formLogin
.
password
)
{
log
(
"
.
.
.
passwords
differ
prompting
to
change
.
"
)
;
let
prompter
=
getPrompter
(
)
;
prompter
.
promptToChangePassword
(
existingLogin
formLogin
dismissedPrompt
)
;
}
else
if
(
!
existingLogin
.
username
&
&
formLogin
.
username
)
{
log
(
"
.
.
.
empty
username
update
prompting
to
change
.
"
)
;
let
prompter
=
getPrompter
(
)
;
prompter
.
promptToChangePassword
(
existingLogin
formLogin
dismissedPrompt
)
;
}
else
{
recordLoginUse
(
existingLogin
)
;
}
return
;
}
let
prompter
=
getPrompter
(
)
;
prompter
.
promptToSavePassword
(
formLogin
dismissedPrompt
)
;
}
_onGeneratedPasswordFilled
(
{
browsingContextId
formActionOrigin
}
)
{
let
browsingContext
=
BrowsingContext
.
get
(
browsingContextId
)
;
let
{
originNoSuffix
}
=
browsingContext
.
currentWindowGlobal
.
documentPrincipal
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
originNoSuffix
)
;
if
(
!
formOrigin
)
{
log
(
"
_onGeneratedPasswordFilled
:
Invalid
form
origin
:
"
browsingContext
.
currentWindowGlobal
.
documentPrincipal
)
;
return
;
}
let
framePrincipalOrigin
=
browsingContext
.
currentWindowGlobal
.
documentPrincipal
.
origin
;
let
generatedPW
=
this
.
_generatedPasswordsByPrincipalOrigin
.
get
(
framePrincipalOrigin
)
;
if
(
!
generatedPW
.
filled
)
{
Services
.
telemetry
.
recordEvent
(
"
pwmgr
"
"
autocomplete_field
"
"
generatedpassword
"
)
;
log
(
"
autocomplete_field
telemetry
event
recorded
"
)
;
generatedPW
.
filled
=
true
;
}
if
(
!
Services
.
logins
.
getLoginSavingEnabled
(
formOrigin
)
)
{
log
(
"
_onGeneratedPasswordFilled
:
saving
is
disabled
for
:
"
formOrigin
)
;
return
;
}
let
logins
=
this
.
_searchAndDedupeLogins
(
formOrigin
{
acceptDifferentSubdomains
:
false
httpRealm
:
null
ignoreActionAndRealm
:
false
}
)
;
if
(
logins
.
length
>
0
)
{
log
(
"
_onGeneratedPasswordFilled
:
Login
already
saved
for
this
site
"
)
;
return
;
}
let
password
=
generatedPW
.
value
;
let
formLogin
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
formLogin
.
init
(
formOrigin
formActionOrigin
null
"
"
password
)
;
Services
.
logins
.
addLogin
(
formLogin
)
;
}
loginFormStateByBrowser
:
new
WeakMap
(
)
stateForBrowser
(
browser
)
{
let
loginFormState
=
this
.
loginFormStateByBrowser
.
get
(
browser
)
;
if
(
!
loginFormState
)
{
loginFormState
=
{
}
;
this
.
loginFormStateByBrowser
.
set
(
browser
loginFormState
)
;
}
return
loginFormState
;
}
hasInsecureLoginForms
(
browser
)
{
return
!
!
this
.
stateForBrowser
(
browser
)
.
hasInsecureLoginForms
;
}
setHasInsecureLoginForms
(
browser
hasInsecureLoginForms
)
{
let
state
=
this
.
stateForBrowser
(
browser
)
;
state
.
hasInsecureLoginForms
=
hasInsecureLoginForms
;
browser
.
dispatchEvent
(
new
browser
.
ownerGlobal
.
CustomEvent
(
"
InsecureLoginFormsStateChange
"
)
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
LoginManagerParent
"
recipeParentPromise
"
function
(
)
{
const
{
LoginRecipesParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoginRecipes
.
jsm
"
)
;
this
.
_recipeManager
=
new
LoginRecipesParent
(
{
defaults
:
Services
.
prefs
.
getStringPref
(
"
signon
.
recipes
.
path
"
)
}
)
;
return
this
.
_recipeManager
.
initializationPromise
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
LoginManagerParent
"
_repromptTimeout
"
"
signon
.
masterPasswordReprompt
.
timeout_ms
"
900000
)
;
