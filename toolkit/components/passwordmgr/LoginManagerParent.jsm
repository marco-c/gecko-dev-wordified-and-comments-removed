"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
LoginInfo
=
new
Components
.
Constructor
(
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
Ci
.
nsILoginInfo
"
init
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
LoginRelatedRealmsParent
"
(
)
=
>
{
const
{
LoginRelatedRealmsParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoginRelatedRealms
.
jsm
"
)
;
return
new
LoginRelatedRealmsParent
(
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
PasswordRulesManager
"
(
)
=
>
{
const
{
PasswordRulesManagerParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PasswordRulesManager
.
jsm
"
)
;
return
new
PasswordRulesManagerParent
(
)
;
}
)
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
ChromeMigrationUtils
:
"
resource
:
/
/
/
modules
/
ChromeMigrationUtils
.
jsm
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
LoginHelper
:
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
MigrationUtils
:
"
resource
:
/
/
/
modules
/
MigrationUtils
.
jsm
"
PasswordGenerator
:
"
resource
:
/
/
gre
/
modules
/
PasswordGenerator
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
prompterSvc
"
"
mozilla
.
org
/
login
-
manager
/
prompter
;
1
"
Ci
.
nsILoginManagerPrompter
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
log
"
(
)
=
>
{
let
logger
=
lazy
.
LoginHelper
.
createLogger
(
"
LoginManagerParent
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
debug
"
(
)
=
>
{
let
logger
=
lazy
.
LoginHelper
.
createLogger
(
"
LoginManagerParent
"
)
;
return
logger
.
debug
.
bind
(
logger
)
;
}
)
;
const
EXPORTED_SYMBOLS
=
[
"
LoginManagerParent
"
]
;
let
gListenerForTests
=
null
;
let
gGeneratedPasswordsByPrincipalOrigin
=
new
Map
(
)
;
let
gRecipeManager
=
null
;
let
gLastMPLoginCancelled
=
Number
.
NEGATIVE_INFINITY
;
let
gGeneratedPasswordObserver
=
{
addedObserver
:
false
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
last
-
pb
-
context
-
exited
"
)
{
for
(
let
principalOrigin
of
gGeneratedPasswordsByPrincipalOrigin
.
keys
(
)
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
principalOrigin
)
;
if
(
!
principal
.
privateBrowsingId
)
{
continue
;
}
gGeneratedPasswordsByPrincipalOrigin
.
delete
(
principalOrigin
)
;
}
return
;
}
if
(
topic
=
=
"
passwordmgr
-
autosaved
-
login
-
merged
"
|
|
(
topic
=
=
"
passwordmgr
-
storage
-
changed
"
&
&
data
=
=
"
removeLogin
"
)
)
{
let
{
origin
guid
}
=
subject
;
let
generatedPW
=
gGeneratedPasswordsByPrincipalOrigin
.
get
(
origin
)
;
if
(
generatedPW
&
&
(
guid
=
=
generatedPW
.
storageGUID
|
|
topic
=
=
"
passwordmgr
-
autosaved
-
login
-
merged
"
)
)
{
lazy
.
log
(
Removing
storageGUID
for
generated
-
password
cache
entry
on
origin
:
{
origin
}
.
)
;
generatedPW
.
storageGUID
=
null
;
}
}
}
}
;
Services
.
ppmm
.
addMessageListener
(
"
PasswordManager
:
findRecipes
"
message
=
>
{
let
formHost
=
new
URL
(
message
.
data
.
formOrigin
)
.
host
;
return
gRecipeManager
?
.
getRecipesForHost
(
formHost
)
?
?
[
]
;
}
)
;
async
function
getImportableLogins
(
formOrigin
)
{
const
state
=
lazy
.
LoginHelper
.
suggestImportCount
>
0
&
&
lazy
.
LoginHelper
.
showAutoCompleteImport
;
return
state
?
{
browsers
:
await
lazy
.
ChromeMigrationUtils
.
getImportableLogins
(
formOrigin
)
state
}
:
null
;
}
class
LoginManagerParent
extends
JSWindowActorParent
{
possibleValues
=
{
usernames
:
new
Set
(
)
passwords
:
new
Set
(
)
}
;
static
setListenerForTests
(
listener
)
{
gListenerForTests
=
listener
;
}
static
get
_recipeManager
(
)
{
return
gRecipeManager
;
}
static
getGeneratedPasswordsByPrincipalOrigin
(
)
{
return
gGeneratedPasswordsByPrincipalOrigin
;
}
getRootBrowser
(
)
{
let
browsingContext
=
null
;
if
(
this
.
_overrideBrowsingContextId
)
{
browsingContext
=
BrowsingContext
.
get
(
this
.
_overrideBrowsingContextId
)
;
}
else
{
browsingContext
=
this
.
browsingContext
.
top
;
}
return
browsingContext
.
embedderElement
;
}
static
async
searchAndDedupeLogins
(
formOrigin
{
acceptDifferentSubdomains
formActionOrigin
httpRealm
ignoreActionAndRealm
relatedRealms
}
=
{
}
)
{
let
logins
;
let
matchData
=
{
origin
:
formOrigin
schemeUpgrades
:
lazy
.
LoginHelper
.
schemeUpgrades
acceptDifferentSubdomains
}
;
if
(
!
ignoreActionAndRealm
)
{
if
(
typeof
formActionOrigin
!
=
"
undefined
"
)
{
matchData
.
formActionOrigin
=
formActionOrigin
;
}
else
if
(
typeof
httpRealm
!
=
"
undefined
"
)
{
matchData
.
httpRealm
=
httpRealm
;
}
}
if
(
lazy
.
LoginHelper
.
relatedRealmsEnabled
)
{
matchData
.
acceptRelatedRealms
=
lazy
.
LoginHelper
.
relatedRealmsEnabled
;
matchData
.
relatedRealms
=
relatedRealms
;
}
try
{
logins
=
await
Services
.
logins
.
searchLoginsAsync
(
matchData
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_ABORT
)
{
lazy
.
log
(
"
User
cancelled
primary
password
prompt
.
"
)
;
gLastMPLoginCancelled
=
Date
.
now
(
)
;
return
[
]
;
}
throw
e
;
}
logins
=
lazy
.
LoginHelper
.
shadowHTTPLogins
(
logins
)
;
let
resolveBy
=
[
"
subdomain
"
"
actionOrigin
"
"
scheme
"
"
timePasswordChanged
"
]
;
return
lazy
.
LoginHelper
.
dedupeLogins
(
logins
[
"
username
"
"
password
"
]
resolveBy
formOrigin
formActionOrigin
)
;
}
async
receiveMessage
(
msg
)
{
let
data
=
msg
.
data
;
if
(
data
.
origin
|
|
data
.
formOrigin
)
{
throw
new
Error
(
"
The
child
process
should
not
send
an
origin
to
the
parent
process
.
See
bug
1513003
"
)
;
}
let
context
=
{
}
;
XPCOMUtils
.
defineLazyGetter
(
context
"
origin
"
(
)
=
>
{
let
origin
=
lazy
.
LoginHelper
.
getLoginOrigin
(
this
.
manager
.
documentPrincipal
?
.
originNoSuffix
)
;
if
(
!
origin
)
{
throw
new
Error
(
"
An
origin
is
required
.
Message
name
:
"
+
msg
.
name
)
;
}
return
origin
;
}
)
;
switch
(
msg
.
name
)
{
case
"
PasswordManager
:
updateDoorhangerSuggestions
"
:
{
this
.
#
onUpdateDoorhangerSuggestions
(
data
.
possibleValues
)
;
break
;
}
case
"
PasswordManager
:
decreaseSuggestImportCount
"
:
{
this
.
decreaseSuggestImportCount
(
data
)
;
break
;
}
case
"
PasswordManager
:
findLogins
"
:
{
return
this
.
sendLoginDataToChild
(
context
.
origin
data
.
actionOrigin
data
.
options
)
;
}
case
"
PasswordManager
:
onFormSubmit
"
:
{
this
.
#
onFormSubmit
(
context
)
;
break
;
}
case
"
PasswordManager
:
onPasswordEditedOrGenerated
"
:
{
this
.
#
onPasswordEditedOrGenerated
(
context
data
)
;
break
;
}
case
"
PasswordManager
:
onIgnorePasswordEdit
"
:
{
this
.
#
onIgnorePasswordEdit
(
)
;
break
;
}
case
"
PasswordManager
:
ShowDoorhanger
"
:
{
this
.
#
onShowDoorhanger
(
context
data
)
;
break
;
}
case
"
PasswordManager
:
autoCompleteLogins
"
:
{
return
this
.
doAutocompleteSearch
(
context
.
origin
data
)
;
}
case
"
PasswordManager
:
removeLogin
"
:
{
this
.
#
onRemoveLogin
(
data
.
login
)
;
break
;
}
case
"
PasswordManager
:
OpenImportableLearnMore
"
:
{
this
.
#
onOpenImportableLearnMore
(
)
;
break
;
}
case
"
PasswordManager
:
HandleImportable
"
:
{
await
this
.
#
onHandleImportable
(
data
.
browserId
)
;
break
;
}
case
"
PasswordManager
:
OpenPreferences
"
:
{
this
.
#
onOpenPreferences
(
data
.
hostname
data
.
entryPoint
)
;
break
;
}
case
"
PasswordManager
:
formProcessed
"
:
{
this
.
#
onFormProcessed
(
data
.
formid
)
;
break
;
}
}
return
undefined
;
}
#
onUpdateDoorhangerSuggestions
(
possibleValues
)
{
this
.
possibleValues
.
usernames
=
possibleValues
.
usernames
;
this
.
possibleValues
.
passwords
=
possibleValues
.
passwords
;
}
#
onFormSubmit
(
context
)
{
Services
.
obs
.
notifyObservers
(
null
"
passwordmgr
-
form
-
submission
-
detected
"
context
.
origin
)
;
}
#
onPasswordEditedOrGenerated
(
context
data
)
{
lazy
.
log
(
"
#
onPasswordEditedOrGenerated
:
Received
PasswordManager
.
"
)
;
if
(
gListenerForTests
)
{
lazy
.
log
(
"
#
onPasswordEditedOrGenerated
:
Calling
gListenerForTests
.
"
)
;
gListenerForTests
(
"
PasswordEditedOrGenerated
"
{
}
)
;
}
let
browser
=
this
.
getRootBrowser
(
)
;
this
.
_onPasswordEditedOrGenerated
(
browser
context
.
origin
data
)
;
}
#
onIgnorePasswordEdit
(
)
{
lazy
.
log
(
"
#
onIgnorePasswordEdit
:
Received
PasswordManager
.
"
)
;
if
(
gListenerForTests
)
{
lazy
.
log
(
"
#
onIgnorePasswordEdit
:
Calling
gListenerForTests
.
"
)
;
gListenerForTests
(
"
PasswordIgnoreEdit
"
{
}
)
;
}
}
#
onShowDoorhanger
(
context
data
)
{
const
browser
=
this
.
getRootBrowser
(
)
;
const
submitPromise
=
this
.
showDoorhanger
(
browser
context
.
origin
data
)
;
if
(
gListenerForTests
)
{
submitPromise
.
then
(
(
)
=
>
{
gListenerForTests
(
"
ShowDoorhanger
"
{
origin
:
context
.
origin
data
}
)
;
}
)
;
}
}
#
onRemoveLogin
(
login
)
{
login
=
lazy
.
LoginHelper
.
vanillaObjectToLogin
(
login
)
;
Services
.
logins
.
removeLogin
(
login
)
;
}
#
onOpenImportableLearnMore
(
)
{
const
window
=
this
.
getRootBrowser
(
)
.
ownerGlobal
;
window
.
openTrustedLinkIn
(
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
password
-
import
"
"
tab
"
{
relatedToCurrent
:
true
}
)
;
}
async
#
onHandleImportable
(
browserId
)
{
const
migrator
=
await
lazy
.
MigrationUtils
.
getMigrator
(
browserId
)
;
const
profiles
=
await
migrator
.
getSourceProfiles
(
)
;
if
(
profiles
.
length
=
=
1
&
&
lazy
.
NimbusFeatures
[
"
password
-
autocomplete
"
]
.
getVariable
(
"
directMigrateSingleProfile
"
)
)
{
const
loginAdded
=
new
Promise
(
resolve
=
>
{
const
obs
=
(
_subject
_topic
data
)
=
>
{
if
(
data
=
=
"
addLogin
"
)
{
Services
.
obs
.
removeObserver
(
obs
"
passwordmgr
-
storage
-
changed
"
)
;
resolve
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
obs
"
passwordmgr
-
storage
-
changed
"
)
;
}
)
;
await
migrator
.
migrate
(
lazy
.
MigrationUtils
.
resourceTypes
.
PASSWORDS
null
profiles
[
0
]
)
;
await
loginAdded
;
this
.
sendAsyncMessage
(
"
PasswordManager
:
repopulateAutocompletePopup
"
)
;
}
else
{
lazy
.
MigrationUtils
.
showMigrationWizard
(
this
.
getRootBrowser
(
)
.
ownerGlobal
[
lazy
.
MigrationUtils
.
MIGRATION_ENTRYPOINT_PASSWORDS
browserId
]
)
;
}
}
#
onOpenPreferences
(
hostname
entryPoint
)
{
const
window
=
this
.
getRootBrowser
(
)
.
ownerGlobal
;
lazy
.
LoginHelper
.
openPasswordManager
(
window
{
filterString
:
hostname
entryPoint
}
)
;
}
#
onFormProcessed
(
formid
)
{
const
topActor
=
this
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
LoginManager
"
)
;
topActor
.
sendAsyncMessage
(
"
PasswordManager
:
formProcessed
"
{
formid
}
)
;
if
(
gListenerForTests
)
{
gListenerForTests
(
"
FormProcessed
"
{
browsingContext
:
this
.
browsingContext
}
)
;
}
}
decreaseSuggestImportCount
(
count
)
{
if
(
this
.
_suggestImportTimer
)
{
this
.
_suggestImportTimer
.
delay
=
LoginManagerParent
.
SUGGEST_IMPORT_DEBOUNCE_MS
;
this
.
_suggestImportCount
=
Math
.
max
(
count
this
.
_suggestImportCount
)
;
return
;
}
this
.
_suggestImportTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_suggestImportTimer
.
init
(
(
)
=
>
{
this
.
_suggestImportTimer
=
null
;
Services
.
prefs
.
setIntPref
(
"
signon
.
suggestImportCount
"
lazy
.
LoginHelper
.
suggestImportCount
-
this
.
_suggestImportCount
)
;
}
LoginManagerParent
.
SUGGEST_IMPORT_DEBOUNCE_MS
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
this
.
_suggestImportCount
=
count
;
}
async
#
getRecipesForHost
(
origin
)
{
let
recipes
;
if
(
origin
)
{
try
{
const
formHost
=
new
URL
(
origin
)
.
host
;
let
recipeManager
=
await
LoginManagerParent
.
recipeParentPromise
;
recipes
=
recipeManager
.
getRecipesForHost
(
formHost
)
;
}
catch
(
ex
)
{
}
}
return
recipes
?
?
[
]
;
}
async
fillForm
(
{
browser
loginFormOrigin
login
inputElementIdentifier
style
}
)
{
const
recipes
=
await
this
.
#
getRecipesForHost
(
loginFormOrigin
)
;
const
jsLogins
=
[
lazy
.
LoginHelper
.
loginToVanillaObject
(
login
)
]
;
const
browserURI
=
browser
.
currentURI
.
spec
;
const
originMatches
=
lazy
.
LoginHelper
.
getLoginOrigin
(
browserURI
)
=
=
loginFormOrigin
;
this
.
sendAsyncMessage
(
"
PasswordManager
:
fillForm
"
{
inputElementIdentifier
loginFormOrigin
originMatches
logins
:
jsLogins
recipes
style
}
)
;
}
async
sendLoginDataToChild
(
formOrigin
actionOrigin
{
guid
showPrimaryPassword
}
)
{
const
recipes
=
await
this
.
#
getRecipesForHost
(
formOrigin
)
;
if
(
!
showPrimaryPassword
&
&
!
Services
.
logins
.
isLoggedIn
)
{
return
{
logins
:
[
]
recipes
}
;
}
if
(
Services
.
logins
.
uiBusy
)
{
lazy
.
log
(
"
UI
is
busy
.
Deferring
sendLoginDataToChild
for
form
:
"
formOrigin
)
;
let
uiBusyPromiseResolve
;
const
uiBusyPromise
=
new
Promise
(
resolve
=
>
{
uiBusyPromiseResolve
=
resolve
;
}
)
;
const
self
=
this
;
const
observer
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
observe
(
_subject
topic
_data
)
{
lazy
.
log
(
"
Got
deferred
sendLoginDataToChild
notification
:
"
topic
)
;
Services
.
obs
.
removeObserver
(
this
"
passwordmgr
-
crypto
-
login
"
)
;
Services
.
obs
.
removeObserver
(
this
"
passwordmgr
-
crypto
-
loginCanceled
"
)
;
if
(
topic
=
=
"
passwordmgr
-
crypto
-
loginCanceled
"
)
{
uiBusyPromiseResolve
(
{
logins
:
[
]
recipes
}
)
;
return
;
}
const
result
=
self
.
sendLoginDataToChild
(
formOrigin
actionOrigin
{
showPrimaryPassword
}
)
;
uiBusyPromiseResolve
(
result
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
"
passwordmgr
-
crypto
-
login
"
)
;
Services
.
obs
.
addObserver
(
observer
"
passwordmgr
-
crypto
-
loginCanceled
"
)
;
return
uiBusyPromise
;
}
let
logins
=
null
;
if
(
guid
)
{
logins
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
origin
:
formOrigin
}
)
;
}
else
{
let
relatedRealmsOrigins
=
[
]
;
if
(
lazy
.
LoginHelper
.
relatedRealmsEnabled
)
{
relatedRealmsOrigins
=
await
lazy
.
LoginRelatedRealmsParent
.
findRelatedRealms
(
formOrigin
)
;
}
logins
=
await
LoginManagerParent
.
searchAndDedupeLogins
(
formOrigin
{
formActionOrigin
:
actionOrigin
ignoreActionAndRealm
:
true
acceptDifferentSubdomains
:
lazy
.
LoginHelper
.
includeOtherSubdomainsInLookup
relatedRealms
:
relatedRealmsOrigins
}
)
;
if
(
lazy
.
LoginHelper
.
relatedRealmsEnabled
)
{
lazy
.
debug
(
"
Adding
related
logins
on
page
load
"
logins
.
map
(
l
=
>
l
.
origin
)
)
;
}
}
lazy
.
log
(
Deduped
{
logins
.
length
}
logins
.
)
;
let
jsLogins
=
lazy
.
LoginHelper
.
loginsToVanillaObjects
(
logins
)
;
return
{
importable
:
await
getImportableLogins
(
formOrigin
)
logins
:
jsLogins
recipes
}
;
}
async
doAutocompleteSearch
(
formOrigin
{
actionOrigin
searchString
previousResult
forcePasswordGeneration
hasBeenTypePassword
isProbablyANewPasswordField
}
)
{
if
(
!
Services
.
logins
.
isLoggedIn
)
{
if
(
Services
.
logins
.
uiBusy
)
{
lazy
.
log
(
"
Not
searching
logins
for
autocomplete
since
the
primary
password
prompt
is
already
showing
.
"
)
;
return
{
logins
:
[
]
}
;
}
const
timeDiff
=
Date
.
now
(
)
-
gLastMPLoginCancelled
;
if
(
timeDiff
<
LoginManagerParent
.
_repromptTimeout
)
{
lazy
.
log
(
Not
searching
logins
for
autocomplete
since
the
primary
password
prompt
was
last
cancelled
{
Math
.
round
(
timeDiff
/
1000
)
}
seconds
ago
.
)
;
return
{
logins
:
[
]
}
;
}
}
const
searchStringLower
=
searchString
.
toLowerCase
(
)
;
let
logins
;
if
(
previousResult
&
&
searchStringLower
.
startsWith
(
previousResult
.
searchString
.
toLowerCase
(
)
)
)
{
lazy
.
log
(
"
Using
previous
autocomplete
result
.
"
)
;
logins
=
lazy
.
LoginHelper
.
vanillaObjectsToLogins
(
previousResult
.
logins
)
;
}
else
{
lazy
.
log
(
"
Creating
new
autocomplete
search
result
.
"
)
;
let
relatedRealmsOrigins
=
[
]
;
if
(
lazy
.
LoginHelper
.
relatedRealmsEnabled
)
{
relatedRealmsOrigins
=
await
lazy
.
LoginRelatedRealmsParent
.
findRelatedRealms
(
formOrigin
)
;
}
logins
=
await
LoginManagerParent
.
searchAndDedupeLogins
(
formOrigin
{
formActionOrigin
:
actionOrigin
ignoreActionAndRealm
:
true
acceptDifferentSubdomains
:
lazy
.
LoginHelper
.
includeOtherSubdomainsInLookup
relatedRealms
:
relatedRealmsOrigins
}
)
;
}
const
matchingLogins
=
logins
.
filter
(
fullMatch
=
>
{
if
(
hasBeenTypePassword
)
{
return
true
;
}
const
match
=
fullMatch
.
username
;
return
match
&
&
match
.
toLowerCase
(
)
.
startsWith
(
searchStringLower
)
;
}
)
;
let
generatedPassword
=
null
;
let
willAutoSaveGeneratedPassword
=
false
;
if
(
Services
.
logins
.
isLoggedIn
&
&
(
forcePasswordGeneration
|
|
(
isProbablyANewPasswordField
&
&
Services
.
logins
.
getLoginSavingEnabled
(
formOrigin
)
)
)
)
{
generatedPassword
=
await
this
.
getGeneratedPassword
(
)
;
const
potentialConflictingLogins
=
await
Services
.
logins
.
searchLoginsAsync
(
{
origin
:
formOrigin
formActionOrigin
:
actionOrigin
httpRealm
:
null
}
)
;
willAutoSaveGeneratedPassword
=
!
potentialConflictingLogins
.
find
(
login
=
>
login
.
username
=
=
"
"
)
;
}
let
jsLogins
=
lazy
.
LoginHelper
.
loginsToVanillaObjects
(
matchingLogins
)
;
return
{
generatedPassword
importable
:
await
getImportableLogins
(
formOrigin
)
logins
:
jsLogins
willAutoSaveGeneratedPassword
}
;
}
static
get
_browsingContextGlobal
(
)
{
return
BrowsingContext
;
}
useBrowsingContext
(
browsingContextId
=
0
)
{
this
.
_overrideBrowsingContextId
=
browsingContextId
;
}
getBrowsingContextToUse
(
)
{
if
(
this
.
_overrideBrowsingContextId
)
{
return
BrowsingContext
.
get
(
this
.
_overrideBrowsingContextId
)
;
}
return
this
.
browsingContext
;
}
async
getGeneratedPassword
(
)
{
if
(
!
lazy
.
LoginHelper
.
enabled
|
|
!
lazy
.
LoginHelper
.
generationAvailable
|
|
!
lazy
.
LoginHelper
.
generationEnabled
)
{
return
null
;
}
let
browsingContext
=
this
.
getBrowsingContextToUse
(
)
;
if
(
!
browsingContext
)
{
return
null
;
}
let
framePrincipalOrigin
=
browsingContext
.
currentWindowGlobal
.
documentPrincipal
.
origin
;
let
generatedPW
=
gGeneratedPasswordsByPrincipalOrigin
.
get
(
framePrincipalOrigin
)
;
if
(
generatedPW
)
{
return
generatedPW
.
value
;
}
generatedPW
=
{
autocompleteShown
:
false
edited
:
false
filled
:
false
storageGUID
:
null
}
;
if
(
lazy
.
LoginHelper
.
improvedPasswordRulesEnabled
)
{
generatedPW
.
value
=
await
lazy
.
PasswordRulesManager
.
generatePassword
(
browsingContext
.
currentWindowGlobal
.
documentURI
)
;
}
else
{
generatedPW
.
value
=
lazy
.
PasswordGenerator
.
generatePassword
(
{
}
)
;
}
if
(
!
gGeneratedPasswordObserver
.
addedObserver
)
{
Services
.
obs
.
addObserver
(
gGeneratedPasswordObserver
"
passwordmgr
-
autosaved
-
login
-
merged
"
)
;
Services
.
obs
.
addObserver
(
gGeneratedPasswordObserver
"
passwordmgr
-
storage
-
changed
"
)
;
Services
.
obs
.
addObserver
(
gGeneratedPasswordObserver
"
last
-
pb
-
context
-
exited
"
)
;
gGeneratedPasswordObserver
.
addedObserver
=
true
;
}
gGeneratedPasswordsByPrincipalOrigin
.
set
(
framePrincipalOrigin
generatedPW
)
;
return
generatedPW
.
value
;
}
maybeRecordPasswordGenerationShownTelemetryEvent
(
autocompleteResults
)
{
if
(
!
autocompleteResults
.
some
(
r
=
>
r
.
style
=
=
"
generatedPassword
"
)
)
{
return
;
}
let
browsingContext
=
this
.
getBrowsingContextToUse
(
)
;
let
framePrincipalOrigin
=
browsingContext
.
currentWindowGlobal
.
documentPrincipal
.
origin
;
let
generatedPW
=
gGeneratedPasswordsByPrincipalOrigin
.
get
(
framePrincipalOrigin
)
;
if
(
generatedPW
.
autocompleteShown
)
{
return
;
}
generatedPW
.
autocompleteShown
=
true
;
Services
.
telemetry
.
recordEvent
(
"
pwmgr
"
"
autocomplete_shown
"
"
generatedpassword
"
)
;
}
_getPrompter
(
)
{
return
lazy
.
prompterSvc
;
}
#
findSameLogin
(
logins
formLogin
)
{
return
logins
.
find
(
login
=
>
{
let
same
;
if
(
!
login
.
username
&
&
formLogin
.
username
)
{
let
restoreMe
=
formLogin
.
username
;
formLogin
.
username
=
"
"
;
same
=
lazy
.
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
false
ignoreSchemes
:
lazy
.
LoginHelper
.
schemeUpgrades
}
)
;
formLogin
.
username
=
restoreMe
;
}
else
if
(
!
formLogin
.
username
&
&
login
.
username
)
{
formLogin
.
username
=
login
.
username
;
same
=
lazy
.
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
false
ignoreSchemes
:
lazy
.
LoginHelper
.
schemeUpgrades
}
)
;
formLogin
.
username
=
"
"
;
}
else
{
same
=
lazy
.
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
true
ignoreSchemes
:
lazy
.
LoginHelper
.
schemeUpgrades
}
)
;
}
return
same
;
}
)
;
}
async
showDoorhanger
(
browser
formOrigin
{
browsingContextId
formActionOrigin
autoFilledLoginGuid
usernameField
newPasswordField
oldPasswordField
dismissedPrompt
}
)
{
function
recordLoginUse
(
login
)
{
Services
.
logins
.
recordPasswordUse
(
login
browser
&
&
lazy
.
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
login
.
username
?
"
form_login
"
:
"
form_password
"
!
!
autoFilledLoginGuid
)
;
}
if
(
!
lazy
.
LoginHelper
.
storageEnabled
)
{
return
;
}
if
(
!
Services
.
logins
.
getLoginSavingEnabled
(
formOrigin
)
)
{
lazy
.
log
(
Form
submission
ignored
because
saving
is
disabled
for
origin
:
{
formOrigin
}
.
)
;
return
;
}
let
browsingContext
=
BrowsingContext
.
get
(
browsingContextId
)
;
let
framePrincipalOrigin
=
browsingContext
.
currentWindowGlobal
.
documentPrincipal
.
origin
;
let
formLogin
=
new
LoginInfo
(
formOrigin
formActionOrigin
null
usernameField
?
.
value
?
?
"
"
newPasswordField
.
value
usernameField
?
.
name
?
?
"
"
newPasswordField
.
name
)
;
let
notifySaved
=
false
;
if
(
autoFilledLoginGuid
)
{
let
loginsForGuid
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
:
autoFilledLoginGuid
origin
:
formOrigin
}
)
;
if
(
loginsForGuid
.
length
=
=
1
&
&
loginsForGuid
[
0
]
.
password
=
=
formLogin
.
password
&
&
(
!
formLogin
.
username
|
|
loginsForGuid
[
0
]
.
username
=
=
formLogin
.
username
)
)
{
lazy
.
log
(
"
The
filled
login
matches
the
form
submission
.
Nothing
to
change
.
"
)
;
recordLoginUse
(
loginsForGuid
[
0
]
)
;
return
;
}
}
let
existingLogin
=
null
;
let
canMatchExistingLogin
=
true
;
const
logins
=
await
LoginManagerParent
.
searchAndDedupeLogins
(
formOrigin
{
formActionOrigin
}
)
;
const
generatedPW
=
gGeneratedPasswordsByPrincipalOrigin
.
get
(
framePrincipalOrigin
)
;
const
autoSavedStorageGUID
=
generatedPW
?
.
storageGUID
?
?
"
"
;
if
(
!
usernameField
&
&
oldPasswordField
&
&
logins
.
length
)
{
if
(
logins
.
length
=
=
1
)
{
existingLogin
=
logins
[
0
]
;
if
(
existingLogin
.
password
=
=
formLogin
.
password
)
{
recordLoginUse
(
existingLogin
)
;
lazy
.
log
(
"
Not
prompting
to
save
/
change
since
we
have
no
username
and
the
only
saved
password
matches
the
new
password
.
"
)
;
return
;
}
formLogin
.
username
=
existingLogin
.
username
;
formLogin
.
usernameField
=
existingLogin
.
usernameField
;
}
else
if
(
!
generatedPW
|
|
generatedPW
.
value
!
=
newPasswordField
.
value
)
{
canMatchExistingLogin
=
false
;
}
}
if
(
canMatchExistingLogin
&
&
!
existingLogin
)
{
existingLogin
=
this
.
#
findSameLogin
(
logins
formLogin
)
;
}
const
promptBrowser
=
lazy
.
LoginHelper
.
getBrowserForPrompt
(
browser
)
;
const
prompter
=
this
.
_getPrompter
(
browser
)
;
if
(
!
canMatchExistingLogin
)
{
prompter
.
promptToChangePasswordWithUsernames
(
promptBrowser
logins
formLogin
)
;
return
;
}
if
(
existingLogin
)
{
lazy
.
log
(
"
Found
an
existing
login
matching
this
form
submission
.
"
)
;
if
(
existingLogin
.
password
!
=
formLogin
.
password
)
{
lazy
.
log
(
"
Passwords
differ
prompting
to
change
.
"
)
;
prompter
.
promptToChangePassword
(
promptBrowser
existingLogin
formLogin
dismissedPrompt
notifySaved
autoSavedStorageGUID
autoFilledLoginGuid
this
.
possibleValues
)
;
}
else
if
(
!
existingLogin
.
username
&
&
formLogin
.
username
)
{
lazy
.
log
(
"
Empty
username
update
prompting
to
change
.
"
)
;
prompter
.
promptToChangePassword
(
promptBrowser
existingLogin
formLogin
dismissedPrompt
notifySaved
autoSavedStorageGUID
autoFilledLoginGuid
this
.
possibleValues
)
;
}
else
{
recordLoginUse
(
existingLogin
)
;
}
return
;
}
prompter
.
promptToSavePassword
(
promptBrowser
formLogin
dismissedPrompt
notifySaved
autoFilledLoginGuid
this
.
possibleValues
)
;
}
async
_onPasswordEditedOrGenerated
(
browser
formOrigin
{
formActionOrigin
autoFilledLoginGuid
newPasswordField
usernameField
=
null
oldPasswordField
triggeredByFillingGenerated
=
false
}
)
{
lazy
.
log
(
_onPasswordEditedOrGenerated
:
triggeredByFillingGenerated
:
{
triggeredByFillingGenerated
}
.
)
;
if
(
!
lazy
.
LoginHelper
.
storageEnabled
)
{
return
;
}
if
(
!
Services
.
logins
.
getLoginSavingEnabled
(
formOrigin
)
)
{
lazy
.
log
(
Saving
is
disabled
for
origin
:
{
formOrigin
}
.
)
;
return
;
}
if
(
!
newPasswordField
.
value
)
{
lazy
.
log
(
"
The
password
field
is
empty
.
"
)
;
return
;
}
if
(
!
browser
)
{
lazy
.
log
(
"
The
browser
is
gone
.
"
)
;
return
;
}
let
browsingContext
=
this
.
getBrowsingContextToUse
(
)
;
if
(
!
browsingContext
)
{
return
;
}
if
(
!
triggeredByFillingGenerated
&
&
!
Services
.
logins
.
isLoggedIn
)
{
lazy
.
log
(
"
Edited
field
is
not
a
generated
password
field
and
Primary
Password
is
locked
.
"
)
;
return
;
}
let
framePrincipalOrigin
=
browsingContext
.
currentWindowGlobal
.
documentPrincipal
.
origin
;
lazy
.
log
(
"
Got
framePrincipalOrigin
:
"
framePrincipalOrigin
)
;
let
formLogin
=
new
LoginInfo
(
formOrigin
formActionOrigin
null
usernameField
?
.
value
?
?
"
"
newPasswordField
.
value
usernameField
?
.
name
?
?
"
"
newPasswordField
.
name
)
;
let
existingLogin
=
null
;
let
canMatchExistingLogin
=
true
;
let
shouldAutoSaveLogin
=
triggeredByFillingGenerated
;
let
autoSavedLogin
=
null
;
let
notifySaved
=
false
;
if
(
autoFilledLoginGuid
)
{
let
[
matchedLogin
]
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
:
autoFilledLoginGuid
origin
:
formOrigin
}
)
;
if
(
matchedLogin
&
&
matchedLogin
.
password
=
=
formLogin
.
password
&
&
(
!
formLogin
.
username
|
|
matchedLogin
.
username
=
=
formLogin
.
username
)
)
{
lazy
.
log
(
"
The
filled
login
matches
the
changed
fields
.
Nothing
to
change
.
"
)
;
existingLogin
=
matchedLogin
;
}
}
let
generatedPW
=
gGeneratedPasswordsByPrincipalOrigin
.
get
(
framePrincipalOrigin
)
;
let
logins
=
await
LoginManagerParent
.
searchAndDedupeLogins
(
formOrigin
{
formActionOrigin
}
)
;
let
formLoginWithoutUsername
;
if
(
triggeredByFillingGenerated
&
&
generatedPW
)
{
lazy
.
log
(
"
Got
cached
generatedPW
.
"
)
;
formLoginWithoutUsername
=
new
LoginInfo
(
formOrigin
formActionOrigin
null
"
"
newPasswordField
.
value
)
;
if
(
newPasswordField
.
value
!
=
generatedPW
.
value
)
{
lazy
.
log
(
"
The
field
containing
the
generated
password
has
changed
.
"
)
;
if
(
!
generatedPW
.
edited
)
{
Services
.
telemetry
.
recordEvent
(
"
pwmgr
"
"
filled_field_edited
"
"
generatedpassword
"
)
;
lazy
.
log
(
"
filled_field_edited
telemetry
event
recorded
.
"
)
;
generatedPW
.
edited
=
true
;
}
}
if
(
!
generatedPW
.
filled
)
{
if
(
generatedPW
.
storageGUID
)
{
throw
new
Error
(
"
Generated
password
was
saved
in
storage
without
being
filled
first
"
)
;
}
Services
.
telemetry
.
recordEvent
(
"
pwmgr
"
"
autocomplete_field
"
"
generatedpassword
"
)
;
lazy
.
log
(
"
autocomplete_field
telemetry
event
recorded
.
"
)
;
generatedPW
.
filled
=
true
;
}
if
(
generatedPW
.
storageGUID
)
{
[
autoSavedLogin
]
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
:
generatedPW
.
storageGUID
origin
:
formOrigin
}
)
;
if
(
autoSavedLogin
)
{
lazy
.
log
(
"
login
to
change
is
the
auto
-
saved
login
.
"
)
;
existingLogin
=
autoSavedLogin
;
}
}
generatedPW
.
value
=
newPasswordField
.
value
;
if
(
!
existingLogin
)
{
lazy
.
log
(
"
Did
not
match
generated
-
password
login
.
"
)
;
let
matchedLogin
=
logins
.
find
(
login
=
>
formLoginWithoutUsername
.
matches
(
login
true
)
)
;
if
(
matchedLogin
)
{
shouldAutoSaveLogin
=
false
;
if
(
matchedLogin
.
password
=
=
formLoginWithoutUsername
.
password
)
{
lazy
.
log
(
"
Matching
login
already
saved
.
"
)
;
existingLogin
=
matchedLogin
;
}
lazy
.
log
(
"
_onPasswordEditedOrGenerated
:
Login
with
empty
username
already
saved
for
this
site
.
"
)
;
}
}
}
if
(
!
triggeredByFillingGenerated
&
&
!
existingLogin
&
&
!
usernameField
&
&
oldPasswordField
&
&
logins
.
length
)
{
if
(
logins
.
length
=
=
1
)
{
existingLogin
=
logins
[
0
]
;
if
(
existingLogin
.
password
=
=
formLogin
.
password
)
{
lazy
.
log
(
"
Not
prompting
to
save
/
change
since
we
have
no
username
and
the
"
+
"
only
saved
password
matches
the
new
password
.
"
)
;
return
;
}
formLogin
.
username
=
existingLogin
.
username
;
formLogin
.
usernameField
=
existingLogin
.
usernameField
;
}
else
if
(
!
generatedPW
|
|
generatedPW
.
value
!
=
newPasswordField
.
value
)
{
canMatchExistingLogin
=
false
;
}
}
if
(
canMatchExistingLogin
&
&
!
existingLogin
)
{
existingLogin
=
this
.
#
findSameLogin
(
logins
formLogin
)
;
if
(
existingLogin
)
{
lazy
.
log
(
"
Matched
saved
login
.
"
)
;
}
}
if
(
shouldAutoSaveLogin
)
{
if
(
existingLogin
&
&
existingLogin
=
=
autoSavedLogin
&
&
existingLogin
.
password
!
=
=
formLogin
.
password
)
{
lazy
.
log
(
"
Updating
auto
-
saved
login
.
"
)
;
Services
.
logins
.
modifyLogin
(
existingLogin
lazy
.
LoginHelper
.
newPropertyBag
(
{
password
:
formLogin
.
password
}
)
)
;
notifySaved
=
true
;
existingLogin
.
password
=
formLogin
.
password
;
}
else
if
(
!
autoSavedLogin
)
{
lazy
.
log
(
"
Auto
-
saving
new
login
with
empty
username
.
"
)
;
existingLogin
=
Services
.
logins
.
addLogin
(
formLoginWithoutUsername
)
;
generatedPW
.
storageGUID
=
existingLogin
.
guid
;
notifySaved
=
true
;
}
}
else
{
lazy
.
log
(
"
Not
auto
-
saving
this
login
.
"
)
;
}
const
prompter
=
this
.
_getPrompter
(
browser
)
;
const
promptBrowser
=
lazy
.
LoginHelper
.
getBrowserForPrompt
(
browser
)
;
if
(
existingLogin
)
{
let
autoSavedStorageGUID
=
"
"
;
if
(
generatedPW
&
&
generatedPW
.
value
=
=
existingLogin
.
password
&
&
generatedPW
.
storageGUID
=
=
existingLogin
.
guid
)
{
autoSavedStorageGUID
=
generatedPW
.
storageGUID
;
}
if
(
(
shouldAutoSaveLogin
&
&
!
formLogin
.
username
)
|
|
existingLogin
.
password
!
=
formLogin
.
password
)
{
lazy
.
log
(
promptToChangePassword
with
autoSavedStorageGUID
:
{
autoSavedStorageGUID
}
)
;
prompter
.
promptToChangePassword
(
promptBrowser
existingLogin
formLogin
true
notifySaved
autoSavedStorageGUID
autoFilledLoginGuid
this
.
possibleValues
)
;
}
else
if
(
!
existingLogin
.
username
&
&
formLogin
.
username
)
{
lazy
.
log
(
"
Empty
username
update
prompting
to
change
.
"
)
;
prompter
.
promptToChangePassword
(
promptBrowser
existingLogin
formLogin
true
notifySaved
autoSavedStorageGUID
autoFilledLoginGuid
this
.
possibleValues
)
;
}
else
{
lazy
.
log
(
"
No
change
to
existing
login
.
"
)
;
let
popupNotifications
=
promptBrowser
.
ownerGlobal
.
PopupNotifications
;
let
notif
=
popupNotifications
.
getNotification
(
"
password
"
browser
)
;
lazy
.
log
(
_onPasswordEditedOrGenerated
:
Has
doorhanger
?
{
notif
&
&
notif
.
dismissed
}
)
;
if
(
notif
&
&
notif
.
dismissed
)
{
prompter
.
promptToChangePassword
(
promptBrowser
existingLogin
formLogin
true
notifySaved
autoSavedStorageGUID
autoFilledLoginGuid
this
.
possibleValues
)
;
}
}
return
;
}
lazy
.
log
(
"
No
matching
login
to
save
/
update
.
"
)
;
prompter
.
promptToSavePassword
(
promptBrowser
formLogin
true
notifySaved
autoFilledLoginGuid
this
.
possibleValues
)
;
}
static
get
recipeParentPromise
(
)
{
if
(
!
gRecipeManager
)
{
const
{
LoginRecipesParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoginRecipes
.
jsm
"
)
;
gRecipeManager
=
new
LoginRecipesParent
(
{
defaults
:
Services
.
prefs
.
getStringPref
(
"
signon
.
recipes
.
path
"
)
}
)
;
}
return
gRecipeManager
.
initializationPromise
;
}
}
LoginManagerParent
.
SUGGEST_IMPORT_DEBOUNCE_MS
=
10000
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
LoginManagerParent
"
_repromptTimeout
"
"
signon
.
masterPasswordReprompt
.
timeout_ms
"
900000
)
;
