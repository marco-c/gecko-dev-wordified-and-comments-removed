"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
LoginInfo
=
new
Components
.
Constructor
(
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
Ci
.
nsILoginInfo
"
init
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PasswordGenerator
"
"
resource
:
/
/
gre
/
modules
/
PasswordGenerator
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
prompterSvc
"
"
mozilla
.
org
/
login
-
manager
/
prompter
;
1
"
Ci
.
nsILoginManagerPrompter
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
logger
=
LoginHelper
.
createLogger
(
"
LoginManagerParent
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
const
EXPORTED_SYMBOLS
=
[
"
LoginManagerParent
"
]
;
let
gListenerForTests
=
null
;
let
gGeneratedPasswordsByPrincipalOrigin
=
new
Map
(
)
;
let
gRecipeManager
=
null
;
let
gLastMPLoginCancelled
=
Math
.
NEGATIVE_INFINITY
;
let
gGeneratedPasswordObserver
=
{
addedObserver
:
false
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
passwordmgr
-
autosaved
-
login
-
merged
"
|
|
(
topic
=
=
"
passwordmgr
-
storage
-
changed
"
&
&
data
=
=
"
removeLogin
"
)
)
{
let
{
origin
guid
}
=
subject
;
let
generatedPW
=
gGeneratedPasswordsByPrincipalOrigin
.
get
(
origin
)
;
if
(
generatedPW
&
&
(
guid
=
=
generatedPW
.
storageGUID
|
|
topic
=
=
"
passwordmgr
-
autosaved
-
login
-
merged
"
)
)
{
log
(
"
Removing
storageGUID
for
generated
-
password
cache
entry
on
origin
:
"
origin
)
;
generatedPW
.
storageGUID
=
null
;
}
}
}
}
;
Services
.
ppmm
.
addMessageListener
(
"
PasswordManager
:
findRecipes
"
message
=
>
{
let
formHost
=
new
URL
(
message
.
data
.
formOrigin
)
.
host
;
return
gRecipeManager
.
getRecipesForHost
(
formHost
)
;
}
)
;
class
LoginManagerParent
extends
JSWindowActorParent
{
static
setListenerForTests
(
listener
)
{
gListenerForTests
=
listener
;
}
static
getGeneratedPasswordsByPrincipalOrigin
(
)
{
return
gGeneratedPasswordsByPrincipalOrigin
;
}
getRootBrowser
(
)
{
let
browsingContext
=
null
;
if
(
this
.
_overrideBrowsingContextId
)
{
browsingContext
=
BrowsingContext
.
get
(
this
.
_overrideBrowsingContextId
)
;
}
else
{
browsingContext
=
this
.
browsingContext
.
top
;
}
return
browsingContext
.
embedderElement
;
}
static
async
searchAndDedupeLogins
(
formOrigin
{
acceptDifferentSubdomains
formActionOrigin
httpRealm
ignoreActionAndRealm
}
=
{
}
)
{
let
logins
;
let
matchData
=
{
origin
:
formOrigin
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
acceptDifferentSubdomains
}
;
if
(
!
ignoreActionAndRealm
)
{
if
(
typeof
formActionOrigin
!
=
"
undefined
"
)
{
matchData
.
formActionOrigin
=
formActionOrigin
;
}
else
if
(
typeof
httpRealm
!
=
"
undefined
"
)
{
matchData
.
httpRealm
=
httpRealm
;
}
}
try
{
logins
=
await
Services
.
logins
.
searchLoginsAsync
(
matchData
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_ABORT
)
{
log
(
"
User
cancelled
master
password
prompt
.
"
)
;
gLastMPLoginCancelled
=
Date
.
now
(
)
;
return
[
]
;
}
throw
e
;
}
logins
=
LoginHelper
.
shadowHTTPLogins
(
logins
)
;
let
resolveBy
=
[
"
subdomain
"
"
actionOrigin
"
"
scheme
"
"
timePasswordChanged
"
]
;
return
LoginHelper
.
dedupeLogins
(
logins
[
"
username
"
"
password
"
]
resolveBy
formOrigin
formActionOrigin
)
;
}
receiveMessage
(
msg
)
{
let
data
=
msg
.
data
;
switch
(
msg
.
name
)
{
case
"
PasswordManager
:
findLogins
"
:
{
return
this
.
sendLoginDataToChild
(
data
.
formOrigin
data
.
actionOrigin
data
.
options
)
;
}
case
"
PasswordManager
:
onFormSubmit
"
:
{
let
browser
=
this
.
getRootBrowser
(
)
;
let
submitPromise
=
this
.
onFormSubmit
(
browser
data
)
;
if
(
gListenerForTests
)
{
submitPromise
.
then
(
(
)
=
>
{
gListenerForTests
(
"
FormSubmit
"
data
)
;
}
)
;
}
break
;
}
case
"
PasswordManager
:
onPasswordEditedOrGenerated
"
:
{
log
(
"
Received
PasswordManager
:
onPasswordEditedOrGenerated
"
)
;
if
(
gListenerForTests
)
{
log
(
"
calling
gListenerForTests
"
)
;
gListenerForTests
(
"
PasswordEditedOrGenerated
"
{
}
)
;
}
let
browser
=
this
.
getRootBrowser
(
)
;
this
.
_onPasswordEditedOrGenerated
(
browser
data
)
;
break
;
}
case
"
PasswordManager
:
autoCompleteLogins
"
:
{
return
this
.
doAutocompleteSearch
(
data
)
;
}
case
"
PasswordManager
:
removeLogin
"
:
{
let
login
=
LoginHelper
.
vanillaObjectToLogin
(
data
.
login
)
;
Services
.
logins
.
removeLogin
(
login
)
;
break
;
}
case
"
PasswordManager
:
OpenPreferences
"
:
{
let
window
=
this
.
getRootBrowser
(
)
.
ownerGlobal
;
LoginHelper
.
openPasswordManager
(
window
{
filterString
:
msg
.
data
.
hostname
entryPoint
:
msg
.
data
.
entryPoint
}
)
;
break
;
}
case
"
PasswordManager
:
formProcessed
"
:
{
let
topActor
=
this
.
browsingContext
.
top
.
currentWindowGlobal
.
getActor
(
"
LoginManager
"
)
;
topActor
.
sendAsyncMessage
(
"
PasswordManager
:
formProcessed
"
{
formid
:
data
.
formid
}
)
;
if
(
gListenerForTests
)
{
gListenerForTests
(
"
FormProcessed
"
{
browsingContext
:
this
.
browsingContext
}
)
;
}
break
;
}
}
return
undefined
;
}
async
fillForm
(
{
browser
loginFormOrigin
login
inputElementIdentifier
}
)
{
let
recipes
=
[
]
;
if
(
loginFormOrigin
)
{
let
formHost
;
try
{
formHost
=
new
URL
(
loginFormOrigin
)
.
host
;
let
recipeManager
=
await
LoginManagerParent
.
recipeParentPromise
;
recipes
=
recipeManager
.
getRecipesForHost
(
formHost
)
;
}
catch
(
ex
)
{
}
}
let
jsLogins
=
[
LoginHelper
.
loginToVanillaObject
(
login
)
]
;
let
browserURI
=
browser
.
currentURI
.
spec
;
let
originMatches
=
LoginHelper
.
getLoginOrigin
(
browserURI
)
=
=
loginFormOrigin
;
this
.
sendAsyncMessage
(
"
PasswordManager
:
fillForm
"
{
inputElementIdentifier
loginFormOrigin
originMatches
logins
:
jsLogins
recipes
}
)
;
}
async
sendLoginDataToChild
(
formOrigin
actionOrigin
{
guid
showMasterPassword
}
)
{
let
recipes
=
[
]
;
let
formHost
;
try
{
formHost
=
new
URL
(
formOrigin
)
.
host
;
let
recipeManager
=
await
LoginManagerParent
.
recipeParentPromise
;
recipes
=
recipeManager
.
getRecipesForHost
(
formHost
)
;
}
catch
(
ex
)
{
}
if
(
!
showMasterPassword
&
&
!
Services
.
logins
.
isLoggedIn
)
{
return
{
logins
:
[
]
recipes
}
;
}
if
(
Services
.
logins
.
uiBusy
)
{
log
(
"
deferring
sendLoginDataToChild
for
"
formOrigin
)
;
let
uiBusyPromiseResolve
;
let
uiBusyPromise
=
new
Promise
(
resolve
=
>
{
uiBusyPromiseResolve
=
resolve
;
}
)
;
let
self
=
this
;
let
observer
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
observe
(
subject
topic
data
)
{
log
(
"
Got
deferred
sendLoginDataToChild
notification
:
"
topic
)
;
Services
.
obs
.
removeObserver
(
this
"
passwordmgr
-
crypto
-
login
"
)
;
Services
.
obs
.
removeObserver
(
this
"
passwordmgr
-
crypto
-
loginCanceled
"
)
;
if
(
topic
=
=
"
passwordmgr
-
crypto
-
loginCanceled
"
)
{
uiBusyPromiseResolve
(
{
logins
:
[
]
recipes
}
)
;
return
;
}
let
result
=
self
.
sendLoginDataToChild
(
formOrigin
actionOrigin
{
showMasterPassword
}
)
;
uiBusyPromiseResolve
(
result
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
"
passwordmgr
-
crypto
-
login
"
)
;
Services
.
obs
.
addObserver
(
observer
"
passwordmgr
-
crypto
-
loginCanceled
"
)
;
return
uiBusyPromise
;
}
let
logins
=
null
;
if
(
guid
)
{
logins
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
origin
:
formOrigin
}
)
;
}
else
{
logins
=
await
LoginManagerParent
.
searchAndDedupeLogins
(
formOrigin
{
formActionOrigin
:
actionOrigin
ignoreActionAndRealm
:
true
acceptDifferentSubdomains
:
LoginHelper
.
includeOtherSubdomainsInLookup
}
)
;
}
log
(
"
sendLoginDataToChild
:
"
logins
.
length
"
deduped
logins
"
)
;
let
jsLogins
=
LoginHelper
.
loginsToVanillaObjects
(
logins
)
;
return
{
logins
:
jsLogins
recipes
}
;
}
async
doAutocompleteSearch
(
{
autocompleteInfo
formOrigin
actionOrigin
searchString
previousResult
forcePasswordGeneration
isSecure
isPasswordField
}
)
{
if
(
!
Services
.
logins
.
isLoggedIn
)
{
if
(
Services
.
logins
.
uiBusy
)
{
log
(
"
Not
searching
logins
for
autocomplete
since
the
master
password
prompt
is
already
showing
"
)
;
return
{
logins
:
[
]
}
;
}
let
timeDiff
=
Date
.
now
(
)
-
gLastMPLoginCancelled
;
if
(
timeDiff
<
LoginManagerParent
.
_repromptTimeout
)
{
log
(
"
Not
searching
logins
for
autocomplete
since
the
master
password
"
+
prompt
was
last
cancelled
{
Math
.
round
(
timeDiff
/
1000
)
}
seconds
ago
.
)
;
return
{
logins
:
[
]
}
;
}
}
let
searchStringLower
=
searchString
.
toLowerCase
(
)
;
let
logins
;
if
(
previousResult
&
&
searchStringLower
.
startsWith
(
previousResult
.
searchString
.
toLowerCase
(
)
)
)
{
log
(
"
Using
previous
autocomplete
result
"
)
;
logins
=
LoginHelper
.
vanillaObjectsToLogins
(
previousResult
.
logins
)
;
}
else
{
log
(
"
Creating
new
autocomplete
search
result
.
"
)
;
logins
=
await
LoginManagerParent
.
searchAndDedupeLogins
(
formOrigin
{
formActionOrigin
:
actionOrigin
ignoreActionAndRealm
:
true
acceptDifferentSubdomains
:
LoginHelper
.
includeOtherSubdomainsInLookup
}
)
;
}
let
matchingLogins
=
logins
.
filter
(
function
(
fullMatch
)
{
let
match
=
fullMatch
.
username
;
if
(
isPasswordField
)
{
return
true
;
}
return
match
&
&
match
.
toLowerCase
(
)
.
startsWith
(
searchStringLower
)
;
}
)
;
let
generatedPassword
=
null
;
let
willAutoSaveGeneratedPassword
=
false
;
if
(
forcePasswordGeneration
|
|
(
isPasswordField
&
&
autocompleteInfo
.
fieldName
=
=
"
new
-
password
"
&
&
Services
.
logins
.
getLoginSavingEnabled
(
formOrigin
)
)
)
{
generatedPassword
=
this
.
getGeneratedPassword
(
)
;
let
potentialConflictingLogins
=
LoginHelper
.
searchLoginsWithObject
(
{
origin
:
formOrigin
formActionOrigin
:
actionOrigin
httpRealm
:
null
}
)
;
willAutoSaveGeneratedPassword
=
!
potentialConflictingLogins
.
find
(
login
=
>
login
.
username
=
=
"
"
)
;
}
let
jsLogins
=
LoginHelper
.
loginsToVanillaObjects
(
matchingLogins
)
;
return
{
generatedPassword
logins
:
jsLogins
willAutoSaveGeneratedPassword
}
;
}
static
get
_browsingContextGlobal
(
)
{
return
BrowsingContext
;
}
useBrowsingContext
(
browsingContextId
=
0
)
{
this
.
_overrideBrowsingContextId
=
browsingContextId
;
}
getBrowsingContextToUse
(
)
{
if
(
this
.
_overrideBrowsingContextId
)
{
return
BrowsingContext
.
get
(
this
.
_overrideBrowsingContextId
)
;
}
return
this
.
browsingContext
;
}
getGeneratedPassword
(
)
{
if
(
!
LoginHelper
.
enabled
|
|
!
LoginHelper
.
generationAvailable
|
|
!
LoginHelper
.
generationEnabled
)
{
return
null
;
}
let
browsingContext
=
this
.
getBrowsingContextToUse
(
)
;
if
(
!
browsingContext
)
{
return
null
;
}
let
framePrincipalOrigin
=
browsingContext
.
currentWindowGlobal
.
documentPrincipal
.
origin
;
let
generatedPW
=
gGeneratedPasswordsByPrincipalOrigin
.
get
(
framePrincipalOrigin
)
;
if
(
generatedPW
)
{
return
generatedPW
.
value
;
}
generatedPW
=
{
edited
:
false
filled
:
false
storageGUID
:
null
value
:
PasswordGenerator
.
generatePassword
(
)
}
;
if
(
!
gGeneratedPasswordObserver
.
addedObserver
)
{
Services
.
obs
.
addObserver
(
gGeneratedPasswordObserver
"
passwordmgr
-
autosaved
-
login
-
merged
"
)
;
Services
.
obs
.
addObserver
(
gGeneratedPasswordObserver
"
passwordmgr
-
storage
-
changed
"
)
;
gGeneratedPasswordObserver
.
addedObserver
=
true
;
}
gGeneratedPasswordsByPrincipalOrigin
.
set
(
framePrincipalOrigin
generatedPW
)
;
return
generatedPW
.
value
;
}
_getPrompter
(
)
{
return
prompterSvc
;
}
async
onFormSubmit
(
browser
{
origin
browsingContextId
formActionOrigin
autoFilledLoginGuid
usernameField
newPasswordField
oldPasswordField
dismissedPrompt
}
)
{
function
recordLoginUse
(
login
)
{
if
(
!
browser
|
|
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
)
{
return
;
}
Services
.
logins
.
recordPasswordUse
(
login
)
;
}
if
(
!
LoginHelper
.
storageEnabled
)
{
return
;
}
if
(
!
Services
.
logins
.
getLoginSavingEnabled
(
origin
)
)
{
log
(
"
(
form
submission
ignored
-
-
saving
is
disabled
for
:
"
origin
"
)
"
)
;
return
;
}
let
browsingContext
=
BrowsingContext
.
get
(
browsingContextId
)
;
let
framePrincipalOrigin
=
browsingContext
.
currentWindowGlobal
.
documentPrincipal
.
origin
;
log
(
"
onFormSubmit
got
framePrincipalOrigin
:
"
framePrincipalOrigin
)
;
let
formLogin
=
new
LoginInfo
(
origin
formActionOrigin
null
usernameField
?
usernameField
.
value
:
"
"
newPasswordField
.
value
usernameField
?
usernameField
.
name
:
"
"
newPasswordField
.
name
)
;
if
(
autoFilledLoginGuid
)
{
let
loginsForGuid
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
:
autoFilledLoginGuid
origin
}
)
;
if
(
loginsForGuid
.
length
=
=
1
&
&
loginsForGuid
[
0
]
.
password
=
=
formLogin
.
password
&
&
(
!
formLogin
.
username
|
|
loginsForGuid
[
0
]
.
username
=
=
formLogin
.
username
)
)
{
log
(
"
The
filled
login
matches
the
form
submission
.
Nothing
to
change
.
"
)
;
recordLoginUse
(
loginsForGuid
[
0
]
)
;
return
;
}
}
let
existingLogin
=
null
;
let
canMatchExistingLogin
=
true
;
let
logins
=
await
LoginManagerParent
.
searchAndDedupeLogins
(
origin
{
formActionOrigin
}
)
;
let
generatedPW
=
gGeneratedPasswordsByPrincipalOrigin
.
get
(
framePrincipalOrigin
)
;
let
autoSavedStorageGUID
=
"
"
;
if
(
generatedPW
&
&
generatedPW
.
storageGUID
)
{
autoSavedStorageGUID
=
generatedPW
.
storageGUID
;
}
if
(
!
usernameField
&
&
oldPasswordField
&
&
logins
.
length
)
{
if
(
logins
.
length
=
=
1
)
{
existingLogin
=
logins
[
0
]
;
if
(
existingLogin
.
password
=
=
formLogin
.
password
)
{
recordLoginUse
(
existingLogin
)
;
log
(
"
(
Not
prompting
to
save
/
change
since
we
have
no
username
and
the
"
+
"
only
saved
password
matches
the
new
password
)
"
)
;
return
;
}
formLogin
.
username
=
existingLogin
.
username
;
formLogin
.
usernameField
=
existingLogin
.
usernameField
;
}
else
if
(
!
generatedPW
|
|
generatedPW
.
value
!
=
newPasswordField
.
value
)
{
canMatchExistingLogin
=
false
;
}
}
if
(
canMatchExistingLogin
&
&
!
existingLogin
)
{
for
(
let
login
of
logins
)
{
let
same
;
if
(
!
login
.
username
&
&
formLogin
.
username
)
{
let
restoreMe
=
formLogin
.
username
;
formLogin
.
username
=
"
"
;
same
=
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
false
ignoreSchemes
:
LoginHelper
.
schemeUpgrades
}
)
;
formLogin
.
username
=
restoreMe
;
}
else
if
(
!
formLogin
.
username
&
&
login
.
username
)
{
formLogin
.
username
=
login
.
username
;
same
=
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
false
ignoreSchemes
:
LoginHelper
.
schemeUpgrades
}
)
;
formLogin
.
username
=
"
"
;
}
else
{
same
=
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
true
ignoreSchemes
:
LoginHelper
.
schemeUpgrades
}
)
;
}
if
(
same
)
{
existingLogin
=
login
;
break
;
}
}
}
let
promptBrowser
=
LoginHelper
.
getBrowserForPrompt
(
browser
)
;
let
prompter
=
this
.
_getPrompter
(
browser
)
;
if
(
!
canMatchExistingLogin
)
{
prompter
.
promptToChangePasswordWithUsernames
(
promptBrowser
logins
formLogin
)
;
return
;
}
if
(
existingLogin
)
{
log
(
"
Found
an
existing
login
matching
this
form
submission
"
)
;
if
(
existingLogin
.
password
!
=
formLogin
.
password
)
{
log
(
"
.
.
.
passwords
differ
prompting
to
change
.
"
)
;
prompter
.
promptToChangePassword
(
promptBrowser
existingLogin
formLogin
dismissedPrompt
false
autoSavedStorageGUID
)
;
}
else
if
(
!
existingLogin
.
username
&
&
formLogin
.
username
)
{
log
(
"
.
.
.
empty
username
update
prompting
to
change
.
"
)
;
let
prompter
=
this
.
_getPrompter
(
browser
)
;
prompter
.
promptToChangePassword
(
promptBrowser
existingLogin
formLogin
dismissedPrompt
false
autoSavedStorageGUID
)
;
}
else
{
recordLoginUse
(
existingLogin
)
;
}
return
;
}
prompter
.
promptToSavePassword
(
promptBrowser
formLogin
dismissedPrompt
)
;
}
async
_onPasswordEditedOrGenerated
(
browser
{
origin
formActionOrigin
autoFilledLoginGuid
newPasswordField
usernameField
=
null
oldPasswordField
triggeredByFillingGenerated
=
false
}
)
{
log
(
"
_onPasswordEditedOrGenerated
triggeredByFillingGenerated
:
"
triggeredByFillingGenerated
)
;
if
(
!
LoginHelper
.
storageEnabled
)
{
return
;
}
if
(
!
Services
.
logins
.
getLoginSavingEnabled
(
origin
)
)
{
log
(
"
_onPasswordEditedOrGenerated
:
saving
is
disabled
for
:
"
origin
)
;
return
;
}
if
(
!
newPasswordField
.
value
)
{
log
(
"
_onPasswordEditedOrGenerated
:
The
password
field
is
empty
"
)
;
return
;
}
let
browsingContext
=
this
.
getBrowsingContextToUse
(
)
;
if
(
!
browsingContext
)
{
return
;
}
let
framePrincipalOrigin
=
browsingContext
.
currentWindowGlobal
.
documentPrincipal
.
origin
;
log
(
"
_onPasswordEditedOrGenerated
:
got
framePrincipalOrigin
:
"
framePrincipalOrigin
)
;
let
{
originNoSuffix
}
=
browsingContext
.
currentWindowGlobal
.
documentPrincipal
;
let
formOrigin
=
LoginHelper
.
getLoginOrigin
(
originNoSuffix
)
;
if
(
formOrigin
!
=
=
origin
)
{
log
(
"
_onPasswordEditedOrGenerated
:
Invalid
form
origin
:
"
browsingContext
.
currentWindowGlobal
.
documentPrincipal
)
;
return
;
}
let
formLogin
=
new
LoginInfo
(
origin
formActionOrigin
null
usernameField
?
usernameField
.
value
:
"
"
newPasswordField
.
value
usernameField
?
usernameField
.
name
:
"
"
newPasswordField
.
name
)
;
let
existingLogin
=
null
;
let
canMatchExistingLogin
=
true
;
let
shouldAutoSaveLogin
=
triggeredByFillingGenerated
;
let
autoSavedLogin
=
null
;
if
(
autoFilledLoginGuid
)
{
let
[
matchedLogin
]
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
:
autoFilledLoginGuid
origin
}
)
;
if
(
matchedLogin
&
&
matchedLogin
.
password
=
=
formLogin
.
password
&
&
(
!
formLogin
.
username
|
|
matchedLogin
.
username
=
=
formLogin
.
username
)
)
{
log
(
"
The
filled
login
matches
the
changed
fields
.
Nothing
to
change
.
"
)
;
return
;
}
}
let
generatedPW
=
gGeneratedPasswordsByPrincipalOrigin
.
get
(
framePrincipalOrigin
)
;
let
logins
=
await
LoginManagerParent
.
searchAndDedupeLogins
(
origin
{
formActionOrigin
}
)
;
let
formLoginWithoutUsername
;
if
(
triggeredByFillingGenerated
&
&
generatedPW
)
{
log
(
"
Got
cached
generatedPW
"
)
;
formLoginWithoutUsername
=
new
LoginInfo
(
formOrigin
formActionOrigin
null
"
"
newPasswordField
.
value
)
;
if
(
newPasswordField
.
value
!
=
generatedPW
.
value
)
{
log
(
"
The
field
containing
the
generated
password
has
changed
"
)
;
if
(
!
generatedPW
.
edited
)
{
Services
.
telemetry
.
recordEvent
(
"
pwmgr
"
"
filled_field_edited
"
"
generatedpassword
"
)
;
log
(
"
filled_field_edited
telemetry
event
recorded
"
)
;
generatedPW
.
edited
=
true
;
}
}
if
(
!
generatedPW
.
filled
)
{
if
(
generatedPW
.
storageGUID
)
{
throw
new
Error
(
"
Generated
password
was
saved
in
storage
without
being
filled
first
"
)
;
}
Services
.
telemetry
.
recordEvent
(
"
pwmgr
"
"
autocomplete_field
"
"
generatedpassword
"
)
;
log
(
"
autocomplete_field
telemetry
event
recorded
"
)
;
generatedPW
.
filled
=
true
;
}
if
(
generatedPW
.
storageGUID
)
{
[
autoSavedLogin
]
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
:
generatedPW
.
storageGUID
origin
:
formOrigin
}
)
;
if
(
autoSavedLogin
)
{
log
(
"
_onPasswordEditedOrGenerated
:
login
to
change
is
the
auto
-
saved
login
"
)
;
existingLogin
=
autoSavedLogin
;
}
}
generatedPW
.
value
=
newPasswordField
.
value
;
if
(
!
existingLogin
)
{
log
(
"
_onPasswordEditedOrGenerated
:
Didnt
match
generated
-
password
login
"
)
;
let
matchedLogin
=
logins
.
find
(
login
=
>
formLoginWithoutUsername
.
matches
(
login
true
)
)
;
if
(
matchedLogin
)
{
shouldAutoSaveLogin
=
false
;
if
(
matchedLogin
.
password
=
=
formLoginWithoutUsername
.
password
)
{
log
(
"
_onPasswordEditedOrGenerated
:
Matching
login
already
saved
"
)
;
return
;
}
log
(
"
_onPasswordEditedOrGenerated
:
Login
with
empty
username
already
saved
for
this
site
"
)
;
}
}
}
if
(
!
triggeredByFillingGenerated
&
&
!
existingLogin
&
&
!
usernameField
&
&
oldPasswordField
&
&
logins
.
length
)
{
if
(
logins
.
length
=
=
1
)
{
existingLogin
=
logins
[
0
]
;
if
(
existingLogin
.
password
=
=
formLogin
.
password
)
{
log
(
"
(
Not
prompting
to
save
/
change
since
we
have
no
username
and
the
"
+
"
only
saved
password
matches
the
new
password
)
"
)
;
return
;
}
formLogin
.
username
=
existingLogin
.
username
;
formLogin
.
usernameField
=
existingLogin
.
usernameField
;
}
else
if
(
!
generatedPW
|
|
generatedPW
.
value
!
=
newPasswordField
.
value
)
{
canMatchExistingLogin
=
false
;
}
}
if
(
canMatchExistingLogin
&
&
!
existingLogin
)
{
for
(
let
login
of
logins
)
{
let
same
;
if
(
!
login
.
username
&
&
formLogin
.
username
)
{
let
restoreMe
=
formLogin
.
username
;
formLogin
.
username
=
"
"
;
same
=
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
false
ignoreSchemes
:
LoginHelper
.
schemeUpgrades
}
)
;
formLogin
.
username
=
restoreMe
;
}
else
if
(
!
formLogin
.
username
&
&
login
.
username
)
{
formLogin
.
username
=
login
.
username
;
same
=
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
false
ignoreSchemes
:
LoginHelper
.
schemeUpgrades
}
)
;
formLogin
.
username
=
"
"
;
}
else
{
same
=
LoginHelper
.
doLoginsMatch
(
formLogin
login
{
ignorePassword
:
true
ignoreSchemes
:
LoginHelper
.
schemeUpgrades
}
)
;
}
if
(
same
)
{
existingLogin
=
login
;
log
(
"
_onPasswordEditedOrGenerated
:
matched
saved
login
"
)
;
break
;
}
}
}
if
(
shouldAutoSaveLogin
)
{
if
(
existingLogin
&
&
existingLogin
=
=
autoSavedLogin
)
{
log
(
"
_onPasswordEditedOrGenerated
:
updating
auto
-
saved
login
with
changed
password
"
)
;
Services
.
logins
.
modifyLogin
(
existingLogin
LoginHelper
.
newPropertyBag
(
{
password
:
formLogin
.
password
}
)
)
;
existingLogin
.
password
=
formLogin
.
password
;
}
else
{
log
(
"
_onPasswordEditedOrGenerated
:
auto
-
saving
new
login
with
empty
username
"
)
;
existingLogin
=
Services
.
logins
.
addLogin
(
formLoginWithoutUsername
)
;
generatedPW
.
storageGUID
=
existingLogin
.
guid
;
}
}
else
{
log
(
"
_onPasswordEditedOrGenerated
:
not
auto
-
saving
this
login
"
)
;
}
let
prompter
=
this
.
_getPrompter
(
browser
)
;
let
promptBrowser
=
LoginHelper
.
getBrowserForPrompt
(
browser
)
;
if
(
existingLogin
)
{
let
autoSavedStorageGUID
=
"
"
;
if
(
generatedPW
&
&
generatedPW
.
value
=
=
existingLogin
.
password
&
&
generatedPW
.
storageGUID
=
=
existingLogin
.
guid
)
{
autoSavedStorageGUID
=
generatedPW
.
storageGUID
;
}
if
(
(
shouldAutoSaveLogin
&
&
!
formLogin
.
username
)
|
|
existingLogin
.
password
!
=
formLogin
.
password
)
{
log
(
"
_onPasswordEditedOrGenerated
:
promptToChangePassword
with
autoSavedStorageGUID
:
"
+
autoSavedStorageGUID
)
;
prompter
.
promptToChangePassword
(
promptBrowser
existingLogin
formLogin
true
shouldAutoSaveLogin
autoSavedStorageGUID
)
;
}
else
if
(
!
existingLogin
.
username
&
&
formLogin
.
username
)
{
log
(
"
.
.
.
empty
username
update
prompting
to
change
.
"
)
;
prompter
.
promptToChangePassword
(
promptBrowser
existingLogin
formLogin
true
shouldAutoSaveLogin
autoSavedStorageGUID
)
;
}
else
{
log
(
"
_onPasswordEditedOrGenerated
:
No
change
to
existing
login
"
)
;
}
return
;
}
log
(
"
_onPasswordEditedOrGenerated
:
no
matching
login
to
save
/
update
"
)
;
prompter
.
promptToSavePassword
(
promptBrowser
formLogin
true
shouldAutoSaveLogin
)
;
}
static
get
recipeParentPromise
(
)
{
if
(
!
gRecipeManager
)
{
const
{
LoginRecipesParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoginRecipes
.
jsm
"
)
;
gRecipeManager
=
new
LoginRecipesParent
(
{
defaults
:
Services
.
prefs
.
getStringPref
(
"
signon
.
recipes
.
path
"
)
}
)
;
}
return
gRecipeManager
.
initializationPromise
;
}
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
LoginManagerParent
"
_repromptTimeout
"
"
signon
.
masterPasswordReprompt
.
timeout_ms
"
900000
)
;
