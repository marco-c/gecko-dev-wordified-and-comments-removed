const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
PrivateBrowsingUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
strBundle
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
passwordmgr
/
locale
/
passwordmgr
.
properties
"
)
;
}
)
;
const
LoginInfo
=
Components
.
Constructor
(
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
"
nsILoginInfo
"
"
init
"
)
;
const
BRAND_BUNDLE
=
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
;
const
VISIBILITY_TOGGLE_MAX_PW_AGE_MS
=
2
*
60
*
1000
;
const
PROMPT_DISPLAYED
=
0
;
const
PROMPT_ADD_OR_UPDATE
=
1
;
const
PROMPT_NOTNOW
=
2
;
const
PROMPT_NEVER
=
3
;
const
NOTIFICATION_TIMEOUT_MS
=
10
*
1000
;
const
ATTENTION_NOTIFICATION_TIMEOUT_MS
=
60
*
1000
;
class
LoginManagerPrompter
{
get
classID
(
)
{
return
Components
.
ID
(
"
{
c47ff942
-
9678
-
44a5
-
bc9b
-
05e0d676c79c
}
"
)
;
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
Ci
.
nsILoginManagerPrompter
]
)
;
}
promptToSavePassword
(
aBrowser
aLogin
dismissed
=
false
notifySaved
=
false
)
{
log
.
debug
(
"
promptToSavePassword
"
)
;
let
inPrivateBrowsing
=
PrivateBrowsingUtils
.
isBrowserPrivate
(
aBrowser
)
;
LoginManagerPrompter
.
_showLoginCaptureDoorhanger
(
aBrowser
aLogin
"
password
-
save
"
{
dismissed
:
inPrivateBrowsing
|
|
dismissed
extraAttr
:
notifySaved
?
"
attention
"
:
"
"
}
{
notifySaved
}
)
;
Services
.
obs
.
notifyObservers
(
aLogin
"
passwordmgr
-
prompt
-
save
"
)
;
}
static
_showLoginCaptureDoorhanger
(
browser
login
type
showOptions
=
{
}
{
notifySaved
=
false
messageStringID
autoSavedLoginGuid
=
"
"
}
=
{
}
)
{
log
.
debug
(
_showLoginCaptureDoorhanger
got
autoSavedLoginGuid
:
{
autoSavedLoginGuid
}
)
;
let
saveMsgNames
=
{
prompt
:
login
.
username
=
=
=
"
"
?
"
saveLoginMsgNoUser
"
:
"
saveLoginMsg
"
buttonLabel
:
"
saveLoginButtonAllow
.
label
"
buttonAccessKey
:
"
saveLoginButtonAllow
.
accesskey
"
secondaryButtonLabel
:
"
saveLoginButtonDeny
.
label
"
secondaryButtonAccessKey
:
"
saveLoginButtonDeny
.
accesskey
"
}
;
let
changeMsgNames
=
{
prompt
:
login
.
username
=
=
=
"
"
?
"
updateLoginMsgNoUser
"
:
"
updateLoginMsg
"
buttonLabel
:
"
updateLoginButtonText
"
buttonAccessKey
:
"
updateLoginButtonAccessKey
"
secondaryButtonLabel
:
"
updateLoginButtonDeny
.
label
"
secondaryButtonAccessKey
:
"
updateLoginButtonDeny
.
accesskey
"
}
;
let
initialMsgNames
=
type
=
=
"
password
-
save
"
?
saveMsgNames
:
changeMsgNames
;
if
(
messageStringID
)
{
changeMsgNames
.
prompt
=
messageStringID
;
}
let
brandBundle
=
Services
.
strings
.
createBundle
(
BRAND_BUNDLE
)
;
let
brandShortName
=
brandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
let
host
=
this
.
_getShortDisplayHost
(
login
.
origin
)
;
let
promptMsg
=
type
=
=
"
password
-
save
"
?
this
.
_getLocalizedString
(
saveMsgNames
.
prompt
[
brandShortName
host
]
)
:
this
.
_getLocalizedString
(
changeMsgNames
.
prompt
)
;
let
histogramName
=
type
=
=
"
password
-
save
"
?
"
PWMGR_PROMPT_REMEMBER_ACTION
"
:
"
PWMGR_PROMPT_UPDATE_ACTION
"
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramName
)
;
histogram
.
add
(
PROMPT_DISPLAYED
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
histogramName
)
;
let
chromeDoc
=
browser
.
ownerDocument
;
let
currentNotification
;
let
updateButtonStatus
=
element
=
>
{
let
mainActionButton
=
element
.
button
;
if
(
!
login
.
password
.
length
)
{
mainActionButton
.
setAttribute
(
"
disabled
"
true
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
classList
.
add
(
"
popup
-
notification
-
invalid
-
input
"
)
;
}
else
{
mainActionButton
.
removeAttribute
(
"
disabled
"
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
classList
.
remove
(
"
popup
-
notification
-
invalid
-
input
"
)
;
}
}
;
let
updateButtonLabel
=
(
)
=
>
{
if
(
!
currentNotification
)
{
Cu
.
reportError
(
"
updateButtonLabel
no
currentNotification
"
)
;
}
let
foundLogins
=
LoginHelper
.
searchLoginsWithObject
(
{
formActionOrigin
:
login
.
formActionOrigin
origin
:
login
.
origin
httpRealm
:
login
.
httpRealm
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
}
)
;
let
logins
=
this
.
_filterUpdatableLogins
(
login
foundLogins
autoSavedLoginGuid
)
;
let
msgNames
=
!
logins
.
length
?
saveMsgNames
:
changeMsgNames
;
let
label
=
this
.
_getLocalizedString
(
msgNames
.
buttonLabel
)
;
let
accessKey
=
this
.
_getLocalizedString
(
msgNames
.
buttonAccessKey
)
;
currentNotification
.
mainAction
.
label
=
label
;
currentNotification
.
mainAction
.
accessKey
=
accessKey
;
let
element
=
[
.
.
.
currentNotification
.
owner
.
panel
.
childNodes
]
.
find
(
n
=
>
n
.
notification
=
=
currentNotification
)
;
if
(
element
)
{
element
.
setAttribute
(
"
buttonlabel
"
label
)
;
element
.
setAttribute
(
"
buttonaccesskey
"
accessKey
)
;
updateButtonStatus
(
element
)
;
}
}
;
let
writeDataToUI
=
(
)
=
>
{
let
nameField
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
;
nameField
.
placeholder
=
usernamePlaceholder
;
nameField
.
value
=
login
.
username
;
let
toggleCheckbox
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
visibilityToggle
"
)
;
toggleCheckbox
.
removeAttribute
(
"
checked
"
)
;
let
passwordField
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
;
passwordField
.
type
=
"
password
"
;
passwordField
.
value
=
login
.
password
;
updateButtonLabel
(
)
;
}
;
let
readDataFromUI
=
(
)
=
>
{
login
.
username
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
value
;
login
.
password
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
value
;
}
;
let
onInput
=
(
)
=
>
{
readDataFromUI
(
)
;
updateButtonLabel
(
)
;
}
;
let
onKeyUp
=
e
=
>
{
if
(
e
.
key
=
=
"
Enter
"
)
{
e
.
target
.
closest
(
"
popupnotification
"
)
.
button
.
doCommand
(
)
;
}
}
;
let
onVisibilityToggle
=
commandEvent
=
>
{
let
passwordField
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
;
let
selectionStart
=
passwordField
.
selectionStart
;
let
selectionEnd
=
passwordField
.
selectionEnd
;
passwordField
.
setAttribute
(
"
type
"
commandEvent
.
target
.
checked
?
"
"
:
"
password
"
)
;
if
(
!
passwordField
.
hasAttribute
(
"
focused
"
)
)
{
return
;
}
passwordField
.
selectionStart
=
selectionStart
;
passwordField
.
selectionEnd
=
selectionEnd
;
}
;
let
persistData
=
(
)
=
>
{
let
foundLogins
=
LoginHelper
.
searchLoginsWithObject
(
{
formActionOrigin
:
login
.
formActionOrigin
origin
:
login
.
origin
httpRealm
:
login
.
httpRealm
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
}
)
;
let
logins
=
this
.
_filterUpdatableLogins
(
login
foundLogins
autoSavedLoginGuid
)
;
let
resolveBy
=
[
"
scheme
"
"
timePasswordChanged
"
]
;
logins
=
LoginHelper
.
dedupeLogins
(
logins
[
"
username
"
]
resolveBy
login
.
origin
)
;
logins
.
sort
(
l
=
>
(
l
.
username
=
=
login
.
username
?
-
1
:
1
)
)
;
log
.
debug
(
persistData
:
Matched
{
logins
.
length
}
logins
)
;
let
loginToRemove
;
let
loginToUpdate
=
logins
.
shift
(
)
;
if
(
logins
.
length
&
&
logins
[
0
]
.
guid
=
=
autoSavedLoginGuid
)
{
loginToRemove
=
logins
.
shift
(
)
;
}
if
(
logins
.
length
)
{
log
.
warn
(
logins
.
length
"
other
updatable
logins
!
"
logins
.
map
(
l
=
>
l
.
guid
)
"
loginToUpdate
:
"
loginToUpdate
&
&
loginToUpdate
.
guid
"
loginToRemove
:
"
loginToRemove
&
&
loginToRemove
.
guid
)
;
}
if
(
!
loginToUpdate
)
{
Services
.
logins
.
addLogin
(
new
LoginInfo
(
login
.
origin
login
.
formActionOrigin
login
.
httpRealm
login
.
username
login
.
password
login
.
usernameField
login
.
passwordField
)
)
;
}
else
if
(
loginToUpdate
.
password
=
=
login
.
password
&
&
loginToUpdate
.
username
=
=
login
.
username
)
{
log
.
debug
(
"
persistData
:
Touch
matched
login
"
loginToUpdate
.
guid
)
;
Services
.
logins
.
recordPasswordUse
(
loginToUpdate
)
;
}
else
{
log
.
debug
(
"
persistData
:
Update
matched
login
"
loginToUpdate
.
guid
)
;
this
.
_updateLogin
(
loginToUpdate
login
)
;
if
(
loginToRemove
&
&
loginToRemove
.
guid
=
=
autoSavedLoginGuid
)
{
Services
.
obs
.
notifyObservers
(
loginToRemove
"
passwordmgr
-
autosaved
-
login
-
merged
"
)
;
}
}
if
(
loginToRemove
)
{
log
.
debug
(
"
persistData
:
removing
login
"
loginToRemove
.
guid
)
;
Services
.
logins
.
removeLogin
(
loginToRemove
)
;
}
}
;
let
mainAction
=
{
label
:
this
.
_getLocalizedString
(
initialMsgNames
.
buttonLabel
)
accessKey
:
this
.
_getLocalizedString
(
initialMsgNames
.
buttonAccessKey
)
callback
:
(
)
=
>
{
histogram
.
add
(
PROMPT_ADD_OR_UPDATE
)
;
if
(
histogramName
=
=
"
PWMGR_PROMPT_REMEMBER_ACTION
"
)
{
Services
.
obs
.
notifyObservers
(
browser
"
LoginStats
:
NewSavedPassword
"
)
;
}
readDataFromUI
(
)
;
persistData
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
histogramName
)
;
browser
.
focus
(
)
;
}
}
;
let
secondaryActions
=
[
{
label
:
this
.
_getLocalizedString
(
initialMsgNames
.
secondaryButtonLabel
)
accessKey
:
this
.
_getLocalizedString
(
initialMsgNames
.
secondaryButtonAccessKey
)
callback
:
(
)
=
>
{
histogram
.
add
(
PROMPT_NOTNOW
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
histogramName
)
;
browser
.
focus
(
)
;
}
}
]
;
if
(
type
=
=
"
password
-
save
"
)
{
secondaryActions
.
push
(
{
label
:
this
.
_getLocalizedString
(
"
saveLoginButtonNever
.
label
"
)
accessKey
:
this
.
_getLocalizedString
(
"
saveLoginButtonNever
.
accesskey
"
)
callback
:
(
)
=
>
{
histogram
.
add
(
PROMPT_NEVER
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
histogramName
)
;
Services
.
logins
.
setLoginSavingEnabled
(
login
.
origin
false
)
;
browser
.
focus
(
)
;
}
}
)
;
}
let
usernamePlaceholder
=
this
.
_getLocalizedString
(
"
noUsernamePlaceholder
"
)
;
let
togglePasswordLabel
=
this
.
_getLocalizedString
(
"
togglePasswordLabel
"
)
;
let
togglePasswordAccessKey
=
this
.
_getLocalizedString
(
"
togglePasswordAccessKey2
"
)
;
let
{
PopupNotifications
}
=
browser
.
ownerGlobal
.
wrappedJSObject
;
let
notificationID
=
"
password
"
;
const
timeoutMs
=
showOptions
.
dismissed
&
&
showOptions
.
extraAttr
=
=
"
attention
"
?
ATTENTION_NOTIFICATION_TIMEOUT_MS
:
NOTIFICATION_TIMEOUT_MS
;
PopupNotifications
.
show
(
browser
notificationID
promptMsg
"
password
-
notification
-
icon
"
mainAction
secondaryActions
Object
.
assign
(
{
timeout
:
Date
.
now
(
)
+
timeoutMs
persistWhileVisible
:
true
passwordNotificationType
:
type
hideClose
:
true
eventCallback
(
topic
)
{
switch
(
topic
)
{
case
"
showing
"
:
currentNotification
=
this
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
removeAttribute
(
"
focused
"
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
removeAttribute
(
"
focused
"
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
addEventListener
(
"
input
"
onInput
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
addEventListener
(
"
keyup
"
onKeyUp
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
addEventListener
(
"
keyup
"
onKeyUp
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
addEventListener
(
"
input
"
onInput
)
;
let
toggleBtn
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
visibilityToggle
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
signon
.
rememberSignons
.
visibilityToggle
"
)
)
{
toggleBtn
.
addEventListener
(
"
command
"
onVisibilityToggle
)
;
toggleBtn
.
setAttribute
(
"
label
"
togglePasswordLabel
)
;
toggleBtn
.
setAttribute
(
"
accesskey
"
togglePasswordAccessKey
)
;
let
hideToggle
=
LoginHelper
.
isMasterPasswordSet
(
)
|
|
(
this
.
timeShown
&
&
this
.
wasDismissed
)
|
|
(
messageStringID
=
=
"
updateLoginMsgAddUsername
"
&
&
login
.
timePasswordChanged
<
Date
.
now
(
)
-
VISIBILITY_TOGGLE_MAX_PW_AGE_MS
)
;
toggleBtn
.
setAttribute
(
"
hidden
"
hideToggle
)
;
}
break
;
case
"
shown
"
:
{
writeDataToUI
(
)
;
let
anchorIcon
=
this
.
anchorElement
;
if
(
anchorIcon
&
&
this
.
options
.
extraAttr
=
=
"
attention
"
)
{
anchorIcon
.
removeAttribute
(
"
extraAttr
"
)
;
delete
this
.
options
.
extraAttr
;
}
break
;
}
case
"
dismissed
"
:
this
.
wasDismissed
=
true
;
readDataFromUI
(
)
;
case
"
removed
"
:
currentNotification
=
null
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
removeEventListener
(
"
input
"
onInput
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
removeEventListener
(
"
keyup
"
onKeyUp
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
removeEventListener
(
"
input
"
onInput
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
removeEventListener
(
"
keyup
"
onKeyUp
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
visibilityToggle
"
)
.
removeEventListener
(
"
command
"
onVisibilityToggle
)
;
break
;
}
return
false
;
}
}
showOptions
)
)
;
if
(
notifySaved
)
{
let
notification
=
PopupNotifications
.
getNotification
(
notificationID
)
;
let
anchor
=
notification
.
anchorElement
;
anchor
.
ownerGlobal
.
ConfirmationHint
.
show
(
anchor
"
passwordSaved
"
)
;
}
}
promptToChangePassword
(
aBrowser
aOldLogin
aNewLogin
dismissed
=
false
notifySaved
=
false
autoSavedLoginGuid
=
"
"
)
{
let
login
=
aOldLogin
.
clone
(
)
;
login
.
origin
=
aNewLogin
.
origin
;
login
.
formActionOrigin
=
aNewLogin
.
formActionOrigin
;
login
.
password
=
aNewLogin
.
password
;
login
.
username
=
aNewLogin
.
username
;
let
messageStringID
;
if
(
aOldLogin
.
username
=
=
=
"
"
&
&
login
.
username
!
=
=
"
"
&
&
login
.
password
=
=
aOldLogin
.
password
)
{
messageStringID
=
"
updateLoginMsgAddUsername
"
;
}
LoginManagerPrompter
.
_showLoginCaptureDoorhanger
(
aBrowser
login
"
password
-
change
"
{
dismissed
extraAttr
:
notifySaved
?
"
attention
"
:
"
"
}
{
notifySaved
messageStringID
autoSavedLoginGuid
}
)
;
let
oldGUID
=
aOldLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
.
guid
;
Services
.
obs
.
notifyObservers
(
aNewLogin
"
passwordmgr
-
prompt
-
change
"
oldGUID
)
;
}
promptToChangePasswordWithUsernames
(
browser
logins
aNewLogin
)
{
log
.
debug
(
"
promptToChangePasswordWithUsernames
with
count
:
"
logins
.
length
)
;
var
usernames
=
logins
.
map
(
l
=
>
l
.
username
|
|
LoginManagerPrompter
.
_getLocalizedString
(
"
noUsername
"
)
)
;
var
dialogText
=
LoginManagerPrompter
.
_getLocalizedString
(
"
userSelectText2
"
)
;
var
dialogTitle
=
LoginManagerPrompter
.
_getLocalizedString
(
"
passwordChangeTitle
"
)
;
var
selectedIndex
=
{
value
:
null
}
;
var
ok
=
Services
.
prompt
.
select
(
browser
.
ownerGlobal
dialogTitle
dialogText
usernames
selectedIndex
)
;
if
(
ok
)
{
var
selectedLogin
=
logins
[
selectedIndex
.
value
]
;
log
.
debug
(
"
Updating
password
for
user
"
selectedLogin
.
username
)
;
var
newLoginWithUsername
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
newLoginWithUsername
.
init
(
aNewLogin
.
origin
aNewLogin
.
formActionOrigin
aNewLogin
.
httpRealm
selectedLogin
.
username
aNewLogin
.
password
selectedLogin
.
usernameField
aNewLogin
.
passwordField
)
;
LoginManagerPrompter
.
_updateLogin
(
selectedLogin
newLoginWithUsername
)
;
}
}
static
_updateLogin
(
login
aNewLogin
)
{
var
now
=
Date
.
now
(
)
;
var
propBag
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
propBag
.
setProperty
(
"
formActionOrigin
"
aNewLogin
.
formActionOrigin
)
;
propBag
.
setProperty
(
"
origin
"
aNewLogin
.
origin
)
;
propBag
.
setProperty
(
"
password
"
aNewLogin
.
password
)
;
propBag
.
setProperty
(
"
username
"
aNewLogin
.
username
)
;
propBag
.
setProperty
(
"
timePasswordChanged
"
now
)
;
propBag
.
setProperty
(
"
timeLastUsed
"
now
)
;
propBag
.
setProperty
(
"
timesUsedIncrement
"
1
)
;
Services
.
logins
.
modifyLogin
(
login
propBag
)
;
}
static
_getLocalizedString
(
key
formatArgs
)
{
if
(
formatArgs
)
{
return
strBundle
.
formatStringFromName
(
key
formatArgs
)
;
}
return
strBundle
.
GetStringFromName
(
key
)
;
}
static
_getShortDisplayHost
(
aURIString
)
{
var
displayHost
;
var
idnService
=
Cc
[
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIDNService
)
;
try
{
var
uri
=
Services
.
io
.
newURI
(
aURIString
)
;
var
baseDomain
=
Services
.
eTLD
.
getBaseDomain
(
uri
)
;
displayHost
=
idnService
.
convertToDisplayIDN
(
baseDomain
{
}
)
;
}
catch
(
e
)
{
log
.
warn
(
"
_getShortDisplayHost
couldn
'
t
process
"
aURIString
)
;
}
if
(
!
displayHost
)
{
displayHost
=
aURIString
;
}
return
displayHost
;
}
static
_filterUpdatableLogins
(
aLogin
aLoginList
includeGUID
)
{
return
aLoginList
.
filter
(
l
=
>
l
.
username
=
=
aLogin
.
username
|
|
(
l
.
password
=
=
aLogin
.
password
&
&
!
l
.
username
)
|
|
(
includeGUID
&
&
includeGUID
=
=
l
.
guid
)
)
;
}
}
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
return
LoginHelper
.
createLogger
(
"
LoginManagerPrompter
"
)
;
}
)
;
const
EXPORTED_SYMBOLS
=
[
"
LoginManagerPrompter
"
]
;
