const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
PrivateBrowsingUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
{
PromptUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
SharedPromptUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
const
LoginInfo
=
Components
.
Constructor
(
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
"
nsILoginInfo
"
"
init
"
)
;
const
BRAND_BUNDLE
=
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
;
const
PROMPT_DISPLAYED
=
0
;
const
PROMPT_ADD_OR_UPDATE
=
1
;
const
PROMPT_NOTNOW
=
2
;
const
PROMPT_NEVER
=
3
;
function
LoginManagerPromptFactory
(
)
{
Services
.
obs
.
addObserver
(
this
"
quit
-
application
-
granted
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
passwordmgr
-
crypto
-
login
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
passwordmgr
-
crypto
-
loginCanceled
"
true
)
;
}
LoginManagerPromptFactory
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
749e62f4
-
60ae
-
4569
-
a8a2
-
de78b649660e
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIPromptFactory
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
_asyncPrompts
:
{
}
_asyncPromptInProgress
:
false
observe
(
subject
topic
data
)
{
this
.
log
(
"
Observed
:
"
+
topic
)
;
if
(
topic
=
=
"
quit
-
application
-
granted
"
)
{
this
.
_cancelPendingPrompts
(
)
;
}
else
if
(
topic
=
=
"
passwordmgr
-
crypto
-
login
"
)
{
this
.
_doAsyncPrompt
(
)
;
}
else
if
(
topic
=
=
"
passwordmgr
-
crypto
-
loginCanceled
"
)
{
this
.
_cancelPendingPrompts
(
)
;
}
}
getPrompt
(
aWindow
aIID
)
{
var
prompt
=
new
LoginManagerPrompter
(
)
.
QueryInterface
(
aIID
)
;
prompt
.
init
(
aWindow
this
)
;
return
prompt
;
}
_doAsyncPrompt
(
)
{
if
(
this
.
_asyncPromptInProgress
)
{
this
.
log
(
"
_doAsyncPrompt
bypassed
already
in
progress
"
)
;
return
;
}
var
hashKey
=
null
;
for
(
hashKey
in
this
.
_asyncPrompts
)
{
break
;
}
if
(
!
hashKey
)
{
this
.
log
(
"
_doAsyncPrompt
:
run
bypassed
no
prompts
in
the
queue
"
)
;
return
;
}
var
prompt
=
this
.
_asyncPrompts
[
hashKey
]
;
var
prompter
=
prompt
.
prompter
;
var
[
hostname
httpRealm
]
=
prompter
.
_getAuthTarget
(
prompt
.
channel
prompt
.
authInfo
)
;
var
hasLogins
=
(
Services
.
logins
.
countLogins
(
hostname
null
httpRealm
)
>
0
)
;
if
(
!
hasLogins
&
&
LoginHelper
.
schemeUpgrades
&
&
hostname
.
startsWith
(
"
https
:
/
/
"
)
)
{
let
httpHostname
=
hostname
.
replace
(
/
^
https
:
\
/
\
/
/
"
http
:
/
/
"
)
;
hasLogins
=
(
Services
.
logins
.
countLogins
(
httpHostname
null
httpRealm
)
>
0
)
;
}
if
(
hasLogins
&
&
Services
.
logins
.
uiBusy
)
{
this
.
log
(
"
_doAsyncPrompt
:
run
bypassed
master
password
UI
busy
"
)
;
return
;
}
let
browser
=
prompter
.
_browser
;
let
baseDomain
=
null
;
if
(
browser
)
{
try
{
baseDomain
=
Services
.
eTLD
.
getBaseDomainFromHost
(
hostname
)
;
}
catch
(
e
)
{
baseDomain
=
hostname
;
}
if
(
!
browser
.
canceledAuthenticationPromptCounter
)
{
browser
.
canceledAuthenticationPromptCounter
=
{
}
;
}
if
(
!
browser
.
canceledAuthenticationPromptCounter
[
baseDomain
]
)
{
browser
.
canceledAuthenticationPromptCounter
[
baseDomain
]
=
0
;
}
}
var
self
=
this
;
var
runnable
=
{
cancel
:
false
run
(
)
{
var
ok
=
false
;
if
(
!
this
.
cancel
)
{
try
{
self
.
log
(
"
_doAsyncPrompt
:
run
-
performing
the
prompt
for
'
"
+
hashKey
+
"
'
"
)
;
ok
=
prompter
.
promptAuth
(
prompt
.
channel
prompt
.
level
prompt
.
authInfo
)
;
}
catch
(
e
)
{
if
(
e
instanceof
Components
.
Exception
&
&
e
.
result
=
=
Cr
.
NS_ERROR_NOT_AVAILABLE
)
{
self
.
log
(
"
_doAsyncPrompt
:
run
bypassed
UI
is
not
available
in
this
context
"
)
;
}
else
{
Cu
.
reportError
(
"
LoginManagerPrompter
:
"
+
"
_doAsyncPrompt
:
run
:
"
+
e
+
"
\
n
"
)
;
}
}
delete
self
.
_asyncPrompts
[
hashKey
]
;
prompt
.
inProgress
=
false
;
self
.
_asyncPromptInProgress
=
false
;
if
(
browser
)
{
if
(
ok
&
&
(
prompt
.
authInfo
.
username
|
|
prompt
.
authInfo
.
password
)
)
{
browser
.
canceledAuthenticationPromptCounter
[
baseDomain
]
=
0
;
}
else
{
browser
.
canceledAuthenticationPromptCounter
[
baseDomain
]
+
=
1
;
}
}
}
for
(
var
consumer
of
prompt
.
consumers
)
{
if
(
!
consumer
.
callback
)
{
continue
;
}
self
.
log
(
"
Calling
back
to
"
+
consumer
.
callback
+
"
ok
=
"
+
ok
)
;
try
{
if
(
ok
)
{
consumer
.
callback
.
onAuthAvailable
(
consumer
.
context
prompt
.
authInfo
)
;
}
else
{
consumer
.
callback
.
onAuthCancelled
(
consumer
.
context
!
this
.
cancel
)
;
}
}
catch
(
e
)
{
}
}
self
.
_doAsyncPrompt
(
)
;
}
}
;
var
cancelDialogLimit
=
Services
.
prefs
.
getIntPref
(
"
prompts
.
authentication_dialog_abuse_limit
"
)
;
let
cancelationCounter
=
browser
.
canceledAuthenticationPromptCounter
[
baseDomain
]
;
this
.
log
(
"
cancelationCounter
=
"
cancelationCounter
)
;
if
(
cancelDialogLimit
&
&
cancelationCounter
>
=
cancelDialogLimit
)
{
this
.
log
(
"
Blocking
auth
dialog
due
to
exceeding
dialog
bloat
limit
"
)
;
delete
this
.
_asyncPrompts
[
hashKey
]
;
runnable
.
cancel
=
true
;
}
else
{
this
.
_asyncPromptInProgress
=
true
;
prompt
.
inProgress
=
true
;
}
Services
.
tm
.
dispatchToMainThread
(
runnable
)
;
this
.
log
(
"
_doAsyncPrompt
:
run
dispatched
"
)
;
}
_cancelPendingPrompts
(
)
{
this
.
log
(
"
Canceling
all
pending
prompts
.
.
.
"
)
;
var
asyncPrompts
=
this
.
_asyncPrompts
;
this
.
__proto__
.
_asyncPrompts
=
{
}
;
for
(
var
hashKey
in
asyncPrompts
)
{
let
prompt
=
asyncPrompts
[
hashKey
]
;
if
(
prompt
.
inProgress
)
{
this
.
log
(
"
skipping
a
prompt
in
progress
"
)
;
continue
;
}
for
(
var
consumer
of
prompt
.
consumers
)
{
if
(
!
consumer
.
callback
)
{
continue
;
}
this
.
log
(
"
Canceling
async
auth
prompt
callback
"
+
consumer
.
callback
)
;
try
{
consumer
.
callback
.
onAuthCancelled
(
consumer
.
context
true
)
;
}
catch
(
e
)
{
}
}
}
}
}
;
XPCOMUtils
.
defineLazyGetter
(
this
.
LoginManagerPromptFactory
.
prototype
"
log
"
(
)
=
>
{
let
logger
=
LoginHelper
.
createLogger
(
"
Login
PromptFactory
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
function
LoginManagerPrompter
(
)
{
}
LoginManagerPrompter
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
8aa66d77
-
1bbb
-
45a6
-
991e
-
b8f47751c291
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAuthPrompt
Ci
.
nsIAuthPrompt2
Ci
.
nsILoginManagerPrompter
]
)
_factory
:
null
_chromeWindow
:
null
_browser
:
null
_openerBrowser
:
null
__strBundle
:
null
get
_strBundle
(
)
{
if
(
!
this
.
__strBundle
)
{
this
.
__strBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
passwordmgr
/
locale
/
passwordmgr
.
properties
"
)
;
if
(
!
this
.
__strBundle
)
{
throw
new
Error
(
"
String
bundle
for
Login
Manager
not
present
!
"
)
;
}
}
return
this
.
__strBundle
;
}
__ellipsis
:
null
get
_ellipsis
(
)
{
if
(
!
this
.
__ellipsis
)
{
this
.
__ellipsis
=
"
\
u2026
"
;
try
{
this
.
__ellipsis
=
Services
.
prefs
.
getComplexValue
(
"
intl
.
ellipsis
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
}
catch
(
e
)
{
}
}
return
this
.
__ellipsis
;
}
get
_inPrivateBrowsing
(
)
{
if
(
this
.
_chromeWindow
)
{
return
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
_chromeWindow
)
;
}
this
.
log
(
"
We
have
no
chromeWindow
so
assume
we
'
re
in
a
private
context
"
)
;
return
true
;
}
get
_allowRememberLogin
(
)
{
if
(
!
this
.
_inPrivateBrowsing
)
{
return
true
;
}
return
LoginHelper
.
privateBrowsingCaptureEnabled
;
}
prompt
(
aDialogTitle
aText
aPasswordRealm
aSavePassword
aDefaultText
aResult
)
{
if
(
aSavePassword
!
=
Ci
.
nsIAuthPrompt
.
SAVE_PASSWORD_NEVER
)
{
throw
new
Components
.
Exception
(
"
prompt
only
supports
SAVE_PASSWORD_NEVER
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
this
.
log
(
"
=
=
=
=
=
prompt
(
)
called
=
=
=
=
=
"
)
;
if
(
aDefaultText
)
{
aResult
.
value
=
aDefaultText
;
}
return
Services
.
prompt
.
prompt
(
this
.
_chromeWindow
aDialogTitle
aText
aResult
null
{
}
)
;
}
promptUsernameAndPassword
(
aDialogTitle
aText
aPasswordRealm
aSavePassword
aUsername
aPassword
)
{
this
.
log
(
"
=
=
=
=
=
promptUsernameAndPassword
(
)
called
=
=
=
=
=
"
)
;
if
(
aSavePassword
=
=
Ci
.
nsIAuthPrompt
.
SAVE_PASSWORD_FOR_SESSION
)
{
throw
new
Components
.
Exception
(
"
promptUsernameAndPassword
doesn
'
t
support
SAVE_PASSWORD_FOR_SESSION
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
var
selectedLogin
=
null
;
var
checkBox
=
{
value
:
false
}
;
var
checkBoxLabel
=
null
;
var
[
hostname
realm
unused
]
=
this
.
_getRealmInfo
(
aPasswordRealm
)
;
if
(
hostname
)
{
var
canRememberLogin
=
false
;
if
(
this
.
_allowRememberLogin
)
{
canRememberLogin
=
(
aSavePassword
=
=
Ci
.
nsIAuthPrompt
.
SAVE_PASSWORD_PERMANENTLY
)
&
&
Services
.
logins
.
getLoginSavingEnabled
(
hostname
)
;
}
if
(
canRememberLogin
)
{
checkBoxLabel
=
this
.
_getLocalizedString
(
"
rememberPassword
"
)
;
}
var
foundLogins
=
Services
.
logins
.
findLogins
(
{
}
hostname
null
realm
)
;
if
(
foundLogins
.
length
>
0
)
{
selectedLogin
=
foundLogins
[
0
]
;
if
(
aUsername
.
value
)
{
selectedLogin
=
this
.
_repickSelectedLogin
(
foundLogins
aUsername
.
value
)
;
}
if
(
selectedLogin
)
{
checkBox
.
value
=
true
;
aUsername
.
value
=
selectedLogin
.
username
;
if
(
!
aPassword
.
value
)
{
aPassword
.
value
=
selectedLogin
.
password
;
}
}
}
}
var
ok
=
Services
.
prompt
.
promptUsernameAndPassword
(
this
.
_chromeWindow
aDialogTitle
aText
aUsername
aPassword
checkBoxLabel
checkBox
)
;
if
(
!
ok
|
|
!
checkBox
.
value
|
|
!
hostname
)
{
return
ok
;
}
if
(
!
aPassword
.
value
)
{
this
.
log
(
"
No
password
entered
so
won
'
t
offer
to
save
.
"
)
;
return
ok
;
}
selectedLogin
=
this
.
_repickSelectedLogin
(
foundLogins
aUsername
.
value
)
;
let
newLogin
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
newLogin
.
init
(
hostname
null
realm
aUsername
.
value
aPassword
.
value
"
"
"
"
)
;
if
(
!
selectedLogin
)
{
this
.
log
(
"
New
login
seen
for
"
+
realm
)
;
Services
.
logins
.
addLogin
(
newLogin
)
;
}
else
if
(
aPassword
.
value
!
=
selectedLogin
.
password
)
{
this
.
log
(
"
Updating
password
for
"
+
realm
)
;
this
.
_updateLogin
(
selectedLogin
newLogin
)
;
}
else
{
this
.
log
(
"
Login
unchanged
no
further
action
needed
.
"
)
;
this
.
_updateLogin
(
selectedLogin
)
;
}
return
ok
;
}
promptPassword
(
aDialogTitle
aText
aPasswordRealm
aSavePassword
aPassword
)
{
this
.
log
(
"
=
=
=
=
=
promptPassword
called
(
)
=
=
=
=
=
"
)
;
if
(
aSavePassword
=
=
Ci
.
nsIAuthPrompt
.
SAVE_PASSWORD_FOR_SESSION
)
{
throw
new
Components
.
Exception
(
"
promptPassword
doesn
'
t
support
SAVE_PASSWORD_FOR_SESSION
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
var
checkBox
=
{
value
:
false
}
;
var
checkBoxLabel
=
null
;
var
[
hostname
realm
username
]
=
this
.
_getRealmInfo
(
aPasswordRealm
)
;
username
=
decodeURIComponent
(
username
)
;
if
(
hostname
&
&
!
this
.
_inPrivateBrowsing
)
{
var
canRememberLogin
=
(
aSavePassword
=
=
Ci
.
nsIAuthPrompt
.
SAVE_PASSWORD_PERMANENTLY
)
&
&
Services
.
logins
.
getLoginSavingEnabled
(
hostname
)
;
if
(
canRememberLogin
)
{
checkBoxLabel
=
this
.
_getLocalizedString
(
"
rememberPassword
"
)
;
}
if
(
!
aPassword
.
value
)
{
var
foundLogins
=
Services
.
logins
.
findLogins
(
{
}
hostname
null
realm
)
;
for
(
var
i
=
0
;
i
<
foundLogins
.
length
;
+
+
i
)
{
if
(
foundLogins
[
i
]
.
username
=
=
username
)
{
aPassword
.
value
=
foundLogins
[
i
]
.
password
;
return
true
;
}
}
}
}
var
ok
=
Services
.
prompt
.
promptPassword
(
this
.
_chromeWindow
aDialogTitle
aText
aPassword
checkBoxLabel
checkBox
)
;
if
(
ok
&
&
checkBox
.
value
&
&
hostname
&
&
aPassword
.
value
)
{
var
newLogin
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
newLogin
.
init
(
hostname
null
realm
username
aPassword
.
value
"
"
"
"
)
;
this
.
log
(
"
New
login
seen
for
"
+
realm
)
;
Services
.
logins
.
addLogin
(
newLogin
)
;
}
return
ok
;
}
_getRealmInfo
(
aRealmString
)
{
var
httpRealm
=
/
^
.
+
\
(
.
+
\
)
/
;
if
(
httpRealm
.
test
(
aRealmString
)
)
{
return
[
null
null
null
]
;
}
var
uri
=
Services
.
io
.
newURI
(
aRealmString
)
;
var
pathname
=
"
"
;
if
(
uri
.
pathQueryRef
!
=
"
/
"
)
{
pathname
=
uri
.
pathQueryRef
;
}
var
formattedHostname
=
this
.
_getFormattedHostname
(
uri
)
;
return
[
formattedHostname
formattedHostname
+
pathname
uri
.
username
]
;
}
promptAuth
(
aChannel
aLevel
aAuthInfo
)
{
var
selectedLogin
=
null
;
var
checkbox
=
{
value
:
false
}
;
var
checkboxLabel
=
null
;
var
epicfail
=
false
;
var
canAutologin
=
false
;
var
notifyObj
;
var
foundLogins
;
try
{
this
.
log
(
"
=
=
=
=
=
promptAuth
called
=
=
=
=
=
"
)
;
this
.
_removeLoginNotifications
(
)
;
var
[
hostname
httpRealm
]
=
this
.
_getAuthTarget
(
aChannel
aAuthInfo
)
;
foundLogins
=
LoginHelper
.
searchLoginsWithObject
(
{
hostname
httpRealm
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
}
)
;
this
.
log
(
"
found
"
foundLogins
.
length
"
matching
logins
.
"
)
;
let
resolveBy
=
[
"
scheme
"
"
timePasswordChanged
"
]
;
foundLogins
=
LoginHelper
.
dedupeLogins
(
foundLogins
[
"
username
"
]
resolveBy
hostname
)
;
this
.
log
(
foundLogins
.
length
"
matching
logins
remain
after
deduping
"
)
;
if
(
foundLogins
.
length
>
0
)
{
selectedLogin
=
foundLogins
[
0
]
;
this
.
_SetAuthInfo
(
aAuthInfo
selectedLogin
.
username
selectedLogin
.
password
)
;
if
(
aAuthInfo
.
flags
&
Ci
.
nsIAuthInformation
.
AUTH_PROXY
&
&
!
(
aAuthInfo
.
flags
&
Ci
.
nsIAuthInformation
.
PREVIOUS_FAILED
)
&
&
Services
.
prefs
.
getBoolPref
(
"
signon
.
autologin
.
proxy
"
)
&
&
!
this
.
_inPrivateBrowsing
)
{
this
.
log
(
"
Autologin
enabled
skipping
auth
prompt
.
"
)
;
canAutologin
=
true
;
}
checkbox
.
value
=
true
;
}
var
canRememberLogin
=
Services
.
logins
.
getLoginSavingEnabled
(
hostname
)
;
if
(
!
this
.
_allowRememberLogin
)
{
canRememberLogin
=
false
;
}
notifyObj
=
this
.
_getPopupNote
(
)
;
if
(
canRememberLogin
&
&
!
notifyObj
)
{
checkboxLabel
=
this
.
_getLocalizedString
(
"
rememberPassword
"
)
;
}
}
catch
(
e
)
{
epicfail
=
true
;
Cu
.
reportError
(
"
LoginManagerPrompter
:
"
+
"
Epic
fail
in
promptAuth
:
"
+
e
+
"
\
n
"
)
;
}
var
ok
=
canAutologin
;
if
(
!
ok
)
{
if
(
this
.
_chromeWindow
)
{
PromptUtils
.
fireDialogEvent
(
this
.
_chromeWindow
"
DOMWillOpenModalDialog
"
this
.
_browser
)
;
}
ok
=
Services
.
prompt
.
promptAuth
(
this
.
_chromeWindow
aChannel
aLevel
aAuthInfo
checkboxLabel
checkbox
)
;
}
var
rememberLogin
=
notifyObj
?
canRememberLogin
:
checkbox
.
value
;
if
(
!
ok
|
|
!
rememberLogin
|
|
epicfail
)
{
return
ok
;
}
try
{
var
[
username
password
]
=
this
.
_GetAuthInfo
(
aAuthInfo
)
;
if
(
!
password
)
{
this
.
log
(
"
No
password
entered
so
won
'
t
offer
to
save
.
"
)
;
return
ok
;
}
selectedLogin
=
this
.
_repickSelectedLogin
(
foundLogins
username
)
;
let
newLogin
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
newLogin
.
init
(
hostname
null
httpRealm
username
password
"
"
"
"
)
;
if
(
!
selectedLogin
)
{
this
.
log
(
"
New
login
seen
for
"
+
username
+
"
"
+
hostname
+
"
(
"
+
httpRealm
+
"
)
"
)
;
if
(
notifyObj
)
{
this
.
_showLoginCaptureDoorhanger
(
newLogin
"
password
-
save
"
{
dismissed
:
this
.
_inPrivateBrowsing
}
)
;
Services
.
obs
.
notifyObservers
(
newLogin
"
passwordmgr
-
prompt
-
save
"
)
;
}
else
{
Services
.
logins
.
addLogin
(
newLogin
)
;
}
}
else
if
(
password
!
=
selectedLogin
.
password
)
{
this
.
log
(
"
Updating
password
for
"
+
username
+
"
"
+
hostname
+
"
(
"
+
httpRealm
+
"
)
"
)
;
if
(
notifyObj
)
{
this
.
_showChangeLoginNotification
(
notifyObj
selectedLogin
newLogin
)
;
}
else
{
this
.
_updateLogin
(
selectedLogin
newLogin
)
;
}
}
else
{
this
.
log
(
"
Login
unchanged
no
further
action
needed
.
"
)
;
this
.
_updateLogin
(
selectedLogin
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
"
LoginManagerPrompter
:
"
+
"
Fail2
in
promptAuth
:
"
+
e
+
"
\
n
"
)
;
}
return
ok
;
}
asyncPromptAuth
(
aChannel
aCallback
aContext
aLevel
aAuthInfo
)
{
var
cancelable
=
null
;
try
{
this
.
log
(
"
=
=
=
=
=
asyncPromptAuth
called
=
=
=
=
=
"
)
;
this
.
_removeLoginNotifications
(
)
;
cancelable
=
this
.
_newAsyncPromptConsumer
(
aCallback
aContext
)
;
var
[
hostname
httpRealm
]
=
this
.
_getAuthTarget
(
aChannel
aAuthInfo
)
;
var
hashKey
=
aLevel
+
"
|
"
+
hostname
+
"
|
"
+
httpRealm
;
this
.
log
(
"
Async
prompt
key
=
"
+
hashKey
)
;
var
asyncPrompt
=
this
.
_factory
.
_asyncPrompts
[
hashKey
]
;
if
(
asyncPrompt
)
{
this
.
log
(
"
Prompt
bound
to
an
existing
one
in
the
queue
callback
=
"
+
aCallback
)
;
asyncPrompt
.
consumers
.
push
(
cancelable
)
;
return
cancelable
;
}
this
.
log
(
"
Adding
new
prompt
to
the
queue
callback
=
"
+
aCallback
)
;
asyncPrompt
=
{
consumers
:
[
cancelable
]
channel
:
aChannel
authInfo
:
aAuthInfo
level
:
aLevel
inProgress
:
false
prompter
:
this
}
;
this
.
_factory
.
_asyncPrompts
[
hashKey
]
=
asyncPrompt
;
this
.
_factory
.
_doAsyncPrompt
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
LoginManagerPrompter
:
"
+
"
asyncPromptAuth
:
"
+
e
+
"
\
nFalling
back
to
promptAuth
\
n
"
)
;
throw
e
;
}
return
cancelable
;
}
init
(
aWindow
=
null
aFactory
=
null
)
{
if
(
!
aWindow
)
{
this
.
_chromeWindow
=
null
;
this
.
_browser
=
null
;
}
else
if
(
aWindow
.
isChromeWindow
)
{
this
.
_chromeWindow
=
aWindow
;
this
.
_browser
=
null
;
}
else
{
let
{
win
browser
}
=
this
.
_getChromeWindow
(
aWindow
)
;
this
.
_chromeWindow
=
win
;
this
.
_browser
=
browser
;
}
this
.
_openerBrowser
=
null
;
this
.
_factory
=
aFactory
|
|
null
;
this
.
log
(
"
=
=
=
=
=
initialized
=
=
=
=
=
"
)
;
}
set
browser
(
aBrowser
)
{
this
.
_browser
=
aBrowser
;
}
set
openerBrowser
(
aOpenerBrowser
)
{
this
.
_openerBrowser
=
aOpenerBrowser
;
}
promptToSavePassword
(
aLogin
)
{
this
.
log
(
"
promptToSavePassword
"
)
;
var
notifyObj
=
this
.
_getPopupNote
(
)
;
if
(
notifyObj
)
{
this
.
_showLoginCaptureDoorhanger
(
aLogin
"
password
-
save
"
{
dismissed
:
this
.
_inPrivateBrowsing
}
)
;
Services
.
obs
.
notifyObservers
(
aLogin
"
passwordmgr
-
prompt
-
save
"
)
;
}
else
{
this
.
_showSaveLoginDialog
(
aLogin
)
;
}
}
_showLoginCaptureDoorhanger
(
login
type
options
=
{
}
)
{
let
{
browser
}
=
this
.
_getNotifyWindow
(
)
;
if
(
!
browser
)
{
return
;
}
let
saveMsgNames
=
{
prompt
:
login
.
username
=
=
=
"
"
?
"
saveLoginMsgNoUser
"
:
"
saveLoginMsg
"
buttonLabel
:
"
saveLoginButtonAllow
.
label
"
buttonAccessKey
:
"
saveLoginButtonAllow
.
accesskey
"
secondaryButtonLabel
:
"
saveLoginButtonDeny
.
label
"
secondaryButtonAccessKey
:
"
saveLoginButtonDeny
.
accesskey
"
}
;
let
changeMsgNames
=
{
prompt
:
login
.
username
=
=
=
"
"
?
"
updateLoginMsgNoUser
"
:
"
updateLoginMsg
"
buttonLabel
:
"
updateLoginButtonText
"
buttonAccessKey
:
"
updateLoginButtonAccessKey
"
secondaryButtonLabel
:
"
updateLoginButtonDeny
.
label
"
secondaryButtonAccessKey
:
"
updateLoginButtonDeny
.
accesskey
"
}
;
let
initialMsgNames
=
type
=
=
"
password
-
save
"
?
saveMsgNames
:
changeMsgNames
;
let
brandBundle
=
Services
.
strings
.
createBundle
(
BRAND_BUNDLE
)
;
let
brandShortName
=
brandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
let
host
=
this
.
_getShortDisplayHost
(
login
.
hostname
)
;
let
promptMsg
=
type
=
=
"
password
-
save
"
?
this
.
_getLocalizedString
(
saveMsgNames
.
prompt
[
brandShortName
host
]
)
:
this
.
_getLocalizedString
(
changeMsgNames
.
prompt
)
;
let
histogramName
=
type
=
=
"
password
-
save
"
?
"
PWMGR_PROMPT_REMEMBER_ACTION
"
:
"
PWMGR_PROMPT_UPDATE_ACTION
"
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramName
)
;
histogram
.
add
(
PROMPT_DISPLAYED
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
histogramName
)
;
let
chromeDoc
=
browser
.
ownerDocument
;
let
currentNotification
;
let
updateButtonStatus
=
(
element
)
=
>
{
let
mainActionButton
=
element
.
button
;
if
(
login
.
password
.
length
=
=
0
)
{
mainActionButton
.
setAttribute
(
"
disabled
"
true
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
classList
.
add
(
"
popup
-
notification
-
invalid
-
input
"
)
;
}
else
{
mainActionButton
.
removeAttribute
(
"
disabled
"
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
classList
.
remove
(
"
popup
-
notification
-
invalid
-
input
"
)
;
}
}
;
let
updateButtonLabel
=
(
)
=
>
{
let
foundLogins
=
LoginHelper
.
searchLoginsWithObject
(
{
formSubmitURL
:
login
.
formSubmitURL
hostname
:
login
.
hostname
httpRealm
:
login
.
httpRealm
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
}
)
;
let
logins
=
this
.
_filterUpdatableLogins
(
login
foundLogins
)
;
let
msgNames
=
(
logins
.
length
=
=
0
)
?
saveMsgNames
:
changeMsgNames
;
let
label
=
this
.
_getLocalizedString
(
msgNames
.
buttonLabel
)
;
let
accessKey
=
this
.
_getLocalizedString
(
msgNames
.
buttonAccessKey
)
;
currentNotification
.
mainAction
.
label
=
label
;
currentNotification
.
mainAction
.
accessKey
=
accessKey
;
let
element
=
[
.
.
.
currentNotification
.
owner
.
panel
.
childNodes
]
.
find
(
n
=
>
n
.
notification
=
=
currentNotification
)
;
if
(
element
)
{
element
.
setAttribute
(
"
buttonlabel
"
label
)
;
element
.
setAttribute
(
"
buttonaccesskey
"
accessKey
)
;
updateButtonStatus
(
element
)
;
}
}
;
let
writeDataToUI
=
(
)
=
>
{
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
setAttribute
(
"
placeholder
"
usernamePlaceholder
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
setAttribute
(
"
value
"
login
.
username
)
;
let
toggleCheckbox
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
visibilityToggle
"
)
;
toggleCheckbox
.
removeAttribute
(
"
checked
"
)
;
let
passwordField
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
;
passwordField
.
setAttribute
(
"
type
"
"
password
"
)
;
passwordField
.
setAttribute
(
"
value
"
login
.
password
)
;
updateButtonLabel
(
)
;
}
;
let
readDataFromUI
=
(
)
=
>
{
login
.
username
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
value
;
login
.
password
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
value
;
}
;
let
onInput
=
(
)
=
>
{
readDataFromUI
(
)
;
updateButtonLabel
(
)
;
}
;
let
onVisibilityToggle
=
(
commandEvent
)
=
>
{
let
passwordField
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
;
let
selectionStart
=
passwordField
.
selectionStart
;
let
selectionEnd
=
passwordField
.
selectionEnd
;
passwordField
.
setAttribute
(
"
type
"
commandEvent
.
target
.
checked
?
"
"
:
"
password
"
)
;
if
(
!
passwordField
.
hasAttribute
(
"
focused
"
)
)
{
return
;
}
passwordField
.
selectionStart
=
selectionStart
;
passwordField
.
selectionEnd
=
selectionEnd
;
}
;
let
persistData
=
(
)
=
>
{
let
foundLogins
=
LoginHelper
.
searchLoginsWithObject
(
{
formSubmitURL
:
login
.
formSubmitURL
hostname
:
login
.
hostname
httpRealm
:
login
.
httpRealm
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
}
)
;
let
logins
=
this
.
_filterUpdatableLogins
(
login
foundLogins
)
;
let
resolveBy
=
[
"
scheme
"
"
timePasswordChanged
"
]
;
logins
=
LoginHelper
.
dedupeLogins
(
logins
[
"
username
"
]
resolveBy
login
.
hostname
)
;
if
(
logins
.
length
=
=
0
)
{
Services
.
logins
.
addLogin
(
new
LoginInfo
(
login
.
hostname
login
.
formSubmitURL
login
.
httpRealm
login
.
username
login
.
password
login
.
usernameField
login
.
passwordField
)
)
;
}
else
if
(
logins
.
length
=
=
1
)
{
if
(
logins
[
0
]
.
password
=
=
login
.
password
&
&
logins
[
0
]
.
username
=
=
login
.
username
)
{
this
.
_updateLogin
(
logins
[
0
]
)
;
}
else
{
this
.
_updateLogin
(
logins
[
0
]
login
)
;
}
}
else
{
Cu
.
reportError
(
"
Unexpected
match
of
multiple
logins
.
"
)
;
}
}
;
let
mainAction
=
{
label
:
this
.
_getLocalizedString
(
initialMsgNames
.
buttonLabel
)
accessKey
:
this
.
_getLocalizedString
(
initialMsgNames
.
buttonAccessKey
)
callback
:
(
)
=
>
{
histogram
.
add
(
PROMPT_ADD_OR_UPDATE
)
;
if
(
histogramName
=
=
"
PWMGR_PROMPT_REMEMBER_ACTION
"
)
{
Services
.
obs
.
notifyObservers
(
null
"
LoginStats
:
NewSavedPassword
"
)
;
}
readDataFromUI
(
)
;
persistData
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
histogramName
)
;
browser
.
focus
(
)
;
}
}
;
let
secondaryActions
=
[
{
label
:
this
.
_getLocalizedString
(
initialMsgNames
.
secondaryButtonLabel
)
accessKey
:
this
.
_getLocalizedString
(
initialMsgNames
.
secondaryButtonAccessKey
)
callback
:
(
)
=
>
{
histogram
.
add
(
PROMPT_NOTNOW
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
histogramName
)
;
browser
.
focus
(
)
;
}
}
]
;
if
(
type
=
=
"
password
-
save
"
)
{
secondaryActions
.
push
(
{
label
:
this
.
_getLocalizedString
(
"
saveLoginButtonNever
.
label
"
)
accessKey
:
this
.
_getLocalizedString
(
"
saveLoginButtonNever
.
accesskey
"
)
callback
:
(
)
=
>
{
histogram
.
add
(
PROMPT_NEVER
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
histogramName
)
;
Services
.
logins
.
setLoginSavingEnabled
(
login
.
hostname
false
)
;
browser
.
focus
(
)
;
}
}
)
;
}
let
usernamePlaceholder
=
this
.
_getLocalizedString
(
"
noUsernamePlaceholder
"
)
;
let
togglePasswordLabel
=
this
.
_getLocalizedString
(
"
togglePasswordLabel
"
)
;
let
togglePasswordAccessKey
=
this
.
_getLocalizedString
(
"
togglePasswordAccessKey2
"
)
;
this
.
_getPopupNote
(
)
.
show
(
browser
"
password
"
promptMsg
"
password
-
notification
-
icon
"
mainAction
secondaryActions
Object
.
assign
(
{
timeout
:
Date
.
now
(
)
+
10000
persistWhileVisible
:
true
passwordNotificationType
:
type
hideClose
:
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
permissionPrompts
.
showCloseButton
"
)
eventCallback
(
topic
)
{
switch
(
topic
)
{
case
"
showing
"
:
currentNotification
=
this
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
removeAttribute
(
"
focused
"
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
removeAttribute
(
"
focused
"
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
addEventListener
(
"
input
"
onInput
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
addEventListener
(
"
input
"
onInput
)
;
let
toggleBtn
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
visibilityToggle
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
signon
.
rememberSignons
.
visibilityToggle
"
)
)
{
toggleBtn
.
addEventListener
(
"
command
"
onVisibilityToggle
)
;
toggleBtn
.
setAttribute
(
"
label
"
togglePasswordLabel
)
;
toggleBtn
.
setAttribute
(
"
accesskey
"
togglePasswordAccessKey
)
;
toggleBtn
.
setAttribute
(
"
hidden
"
LoginHelper
.
isMasterPasswordSet
(
)
)
;
}
if
(
this
.
wasDismissed
)
{
chromeDoc
.
getElementById
(
"
password
-
notification
-
visibilityToggle
"
)
.
setAttribute
(
"
hidden
"
true
)
;
}
break
;
case
"
shown
"
:
writeDataToUI
(
)
;
break
;
case
"
dismissed
"
:
this
.
wasDismissed
=
true
;
readDataFromUI
(
)
;
case
"
removed
"
:
currentNotification
=
null
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
removeEventListener
(
"
input
"
onInput
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
removeEventListener
(
"
input
"
onInput
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
visibilityToggle
"
)
.
removeEventListener
(
"
command
"
onVisibilityToggle
)
;
break
;
}
return
false
;
}
}
options
)
)
;
}
_removeLoginNotifications
(
)
{
var
popupNote
=
this
.
_getPopupNote
(
)
;
if
(
popupNote
)
{
popupNote
=
popupNote
.
getNotification
(
"
password
"
)
;
}
if
(
popupNote
)
{
popupNote
.
remove
(
)
;
}
}
_showSaveLoginDialog
(
aLogin
)
{
const
buttonFlags
=
Ci
.
nsIPrompt
.
BUTTON_POS_1_DEFAULT
+
(
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_0
)
+
(
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_1
)
+
(
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_2
)
;
var
displayHost
=
this
.
_getShortDisplayHost
(
aLogin
.
hostname
)
;
var
dialogText
;
if
(
aLogin
.
username
)
{
var
displayUser
=
this
.
_sanitizeUsername
(
aLogin
.
username
)
;
dialogText
=
this
.
_getLocalizedString
(
"
rememberPasswordMsg
"
[
displayUser
displayHost
]
)
;
}
else
{
dialogText
=
this
.
_getLocalizedString
(
"
rememberPasswordMsgNoUsername
"
[
displayHost
]
)
;
}
var
dialogTitle
=
this
.
_getLocalizedString
(
"
savePasswordTitle
"
)
;
var
neverButtonText
=
this
.
_getLocalizedString
(
"
neverForSiteButtonText
"
)
;
var
rememberButtonText
=
this
.
_getLocalizedString
(
"
rememberButtonText
"
)
;
var
notNowButtonText
=
this
.
_getLocalizedString
(
"
notNowButtonText
"
)
;
this
.
log
(
"
Prompting
user
to
save
/
ignore
login
"
)
;
var
userChoice
=
Services
.
prompt
.
confirmEx
(
this
.
_chromeWindow
dialogTitle
dialogText
buttonFlags
rememberButtonText
notNowButtonText
neverButtonText
null
{
}
)
;
if
(
userChoice
=
=
2
)
{
this
.
log
(
"
Disabling
"
+
aLogin
.
hostname
+
"
logins
by
request
.
"
)
;
Services
.
logins
.
setLoginSavingEnabled
(
aLogin
.
hostname
false
)
;
}
else
if
(
userChoice
=
=
0
)
{
this
.
log
(
"
Saving
login
for
"
+
aLogin
.
hostname
)
;
Services
.
logins
.
addLogin
(
aLogin
)
;
}
else
{
this
.
log
(
"
Ignoring
login
.
"
)
;
}
Services
.
obs
.
notifyObservers
(
aLogin
"
passwordmgr
-
prompt
-
save
"
)
;
}
promptToChangePassword
(
aOldLogin
aNewLogin
)
{
this
.
log
(
"
promptToChangePassword
"
)
;
let
notifyObj
=
this
.
_getPopupNote
(
)
;
if
(
notifyObj
)
{
this
.
_showChangeLoginNotification
(
notifyObj
aOldLogin
aNewLogin
)
;
}
else
{
this
.
_showChangeLoginDialog
(
aOldLogin
aNewLogin
)
;
}
}
_showChangeLoginNotification
(
aNotifyObj
aOldLogin
aNewLogin
)
{
aOldLogin
.
hostname
=
aNewLogin
.
hostname
;
aOldLogin
.
formSubmitURL
=
aNewLogin
.
formSubmitURL
;
aOldLogin
.
password
=
aNewLogin
.
password
;
aOldLogin
.
username
=
aNewLogin
.
username
;
this
.
_showLoginCaptureDoorhanger
(
aOldLogin
"
password
-
change
"
)
;
let
oldGUID
=
aOldLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
.
guid
;
Services
.
obs
.
notifyObservers
(
aNewLogin
"
passwordmgr
-
prompt
-
change
"
oldGUID
)
;
}
_showChangeLoginDialog
(
aOldLogin
aNewLogin
)
{
const
buttonFlags
=
Ci
.
nsIPrompt
.
STD_YES_NO_BUTTONS
;
var
dialogText
;
if
(
aOldLogin
.
username
)
{
dialogText
=
this
.
_getLocalizedString
(
"
updatePasswordMsg
"
[
aOldLogin
.
username
]
)
;
}
else
{
dialogText
=
this
.
_getLocalizedString
(
"
updatePasswordMsgNoUser
"
)
;
}
var
dialogTitle
=
this
.
_getLocalizedString
(
"
passwordChangeTitle
"
)
;
var
ok
=
!
Services
.
prompt
.
confirmEx
(
this
.
_chromeWindow
dialogTitle
dialogText
buttonFlags
null
null
null
null
{
}
)
;
if
(
ok
)
{
this
.
log
(
"
Updating
password
for
user
"
+
aOldLogin
.
username
)
;
this
.
_updateLogin
(
aOldLogin
aNewLogin
)
;
}
let
oldGUID
=
aOldLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
.
guid
;
Services
.
obs
.
notifyObservers
(
aNewLogin
"
passwordmgr
-
prompt
-
change
"
oldGUID
)
;
}
promptToChangePasswordWithUsernames
(
logins
count
aNewLogin
)
{
this
.
log
(
"
promptToChangePasswordWithUsernames
with
count
:
"
count
)
;
var
usernames
=
logins
.
map
(
l
=
>
l
.
username
|
|
this
.
_getLocalizedString
(
"
noUsername
"
)
)
;
var
dialogText
=
this
.
_getLocalizedString
(
"
userSelectText2
"
)
;
var
dialogTitle
=
this
.
_getLocalizedString
(
"
passwordChangeTitle
"
)
;
var
selectedIndex
=
{
value
:
null
}
;
var
ok
=
Services
.
prompt
.
select
(
this
.
_chromeWindow
dialogTitle
dialogText
usernames
.
length
usernames
selectedIndex
)
;
if
(
ok
)
{
var
selectedLogin
=
logins
[
selectedIndex
.
value
]
;
this
.
log
(
"
Updating
password
for
user
"
+
selectedLogin
.
username
)
;
var
newLoginWithUsername
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
newLoginWithUsername
.
init
(
aNewLogin
.
hostname
aNewLogin
.
formSubmitURL
aNewLogin
.
httpRealm
selectedLogin
.
username
aNewLogin
.
password
selectedLogin
.
usernameField
aNewLogin
.
passwordField
)
;
this
.
_updateLogin
(
selectedLogin
newLoginWithUsername
)
;
}
}
_updateLogin
(
login
aNewLogin
=
null
)
{
var
now
=
Date
.
now
(
)
;
var
propBag
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
if
(
aNewLogin
)
{
propBag
.
setProperty
(
"
formSubmitURL
"
aNewLogin
.
formSubmitURL
)
;
propBag
.
setProperty
(
"
hostname
"
aNewLogin
.
hostname
)
;
propBag
.
setProperty
(
"
password
"
aNewLogin
.
password
)
;
propBag
.
setProperty
(
"
username
"
aNewLogin
.
username
)
;
propBag
.
setProperty
(
"
timePasswordChanged
"
now
)
;
}
propBag
.
setProperty
(
"
timeLastUsed
"
now
)
;
propBag
.
setProperty
(
"
timesUsedIncrement
"
1
)
;
Services
.
logins
.
modifyLogin
(
login
propBag
)
;
}
_getChromeWindow
(
aWindow
)
{
if
(
!
Cu
.
isCrossProcessWrapper
(
aWindow
)
)
{
let
browser
=
aWindow
.
docShell
.
chromeEventHandler
;
if
(
!
browser
)
{
return
null
;
}
let
chromeWin
=
browser
.
ownerGlobal
;
if
(
!
chromeWin
)
{
return
null
;
}
return
{
win
:
chromeWin
browser
}
;
}
return
null
;
}
_getNotifyWindow
(
)
{
if
(
this
.
_openerBrowser
)
{
let
chromeDoc
=
this
.
_chromeWindow
.
document
.
documentElement
;
if
(
chromeDoc
.
getAttribute
(
"
chromehidden
"
)
&
&
!
this
.
_browser
.
canGoBack
)
{
this
.
log
(
"
Using
opener
window
for
notification
prompt
.
"
)
;
return
{
win
:
this
.
_openerBrowser
.
ownerGlobal
browser
:
this
.
_openerBrowser
}
;
}
}
return
{
win
:
this
.
_chromeWindow
browser
:
this
.
_browser
}
;
}
_getPopupNote
(
)
{
let
popupNote
=
null
;
try
{
let
{
win
:
notifyWin
}
=
this
.
_getNotifyWindow
(
)
;
popupNote
=
notifyWin
.
wrappedJSObject
.
PopupNotifications
;
}
catch
(
e
)
{
this
.
log
(
"
Popup
notifications
not
available
on
window
"
)
;
}
return
popupNote
;
}
_repickSelectedLogin
(
foundLogins
username
)
{
for
(
var
i
=
0
;
i
<
foundLogins
.
length
;
i
+
+
)
{
if
(
foundLogins
[
i
]
.
username
=
=
username
)
{
return
foundLogins
[
i
]
;
}
}
return
null
;
}
_getLocalizedString
(
key
formatArgs
)
{
if
(
formatArgs
)
{
return
this
.
_strBundle
.
formatStringFromName
(
key
formatArgs
formatArgs
.
length
)
;
}
return
this
.
_strBundle
.
GetStringFromName
(
key
)
;
}
_sanitizeUsername
(
username
)
{
if
(
username
.
length
>
30
)
{
username
=
username
.
substring
(
0
30
)
;
username
+
=
this
.
_ellipsis
;
}
return
username
.
replace
(
/
[
'
"
]
/
g
"
"
)
;
}
_getFormattedHostname
(
aURI
)
{
let
uri
;
if
(
aURI
instanceof
Ci
.
nsIURI
)
{
uri
=
aURI
;
}
else
{
uri
=
Services
.
io
.
newURI
(
aURI
)
;
}
return
uri
.
scheme
+
"
:
/
/
"
+
uri
.
displayHostPort
;
}
_getShortDisplayHost
(
aURIString
)
{
var
displayHost
;
var
idnService
=
Cc
[
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIDNService
)
;
try
{
var
uri
=
Services
.
io
.
newURI
(
aURIString
)
;
var
baseDomain
=
Services
.
eTLD
.
getBaseDomain
(
uri
)
;
displayHost
=
idnService
.
convertToDisplayIDN
(
baseDomain
{
}
)
;
}
catch
(
e
)
{
this
.
log
(
"
_getShortDisplayHost
couldn
'
t
process
"
+
aURIString
)
;
}
if
(
!
displayHost
)
{
displayHost
=
aURIString
;
}
return
displayHost
;
}
_getAuthTarget
(
aChannel
aAuthInfo
)
{
var
hostname
realm
;
if
(
aAuthInfo
.
flags
&
Ci
.
nsIAuthInformation
.
AUTH_PROXY
)
{
this
.
log
(
"
getAuthTarget
is
for
proxy
auth
"
)
;
if
(
!
(
aChannel
instanceof
Ci
.
nsIProxiedChannel
)
)
{
throw
new
Error
(
"
proxy
auth
needs
nsIProxiedChannel
"
)
;
}
var
info
=
aChannel
.
proxyInfo
;
if
(
!
info
)
{
throw
new
Error
(
"
proxy
auth
needs
nsIProxyInfo
"
)
;
}
var
idnService
=
Cc
[
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIDNService
)
;
hostname
=
"
moz
-
proxy
:
/
/
"
+
idnService
.
convertUTF8toACE
(
info
.
host
)
+
"
:
"
+
info
.
port
;
realm
=
aAuthInfo
.
realm
;
if
(
!
realm
)
{
realm
=
hostname
;
}
return
[
hostname
realm
]
;
}
hostname
=
this
.
_getFormattedHostname
(
aChannel
.
URI
)
;
realm
=
aAuthInfo
.
realm
;
if
(
!
realm
)
{
realm
=
hostname
;
}
return
[
hostname
realm
]
;
}
_GetAuthInfo
(
aAuthInfo
)
{
var
username
password
;
var
flags
=
aAuthInfo
.
flags
;
if
(
flags
&
Ci
.
nsIAuthInformation
.
NEED_DOMAIN
&
&
aAuthInfo
.
domain
)
{
username
=
aAuthInfo
.
domain
+
"
\
\
"
+
aAuthInfo
.
username
;
}
else
{
username
=
aAuthInfo
.
username
;
}
password
=
aAuthInfo
.
password
;
return
[
username
password
]
;
}
_SetAuthInfo
(
aAuthInfo
username
password
)
{
var
flags
=
aAuthInfo
.
flags
;
if
(
flags
&
Ci
.
nsIAuthInformation
.
NEED_DOMAIN
)
{
var
idx
=
username
.
indexOf
(
"
\
\
"
)
;
if
(
idx
=
=
-
1
)
{
aAuthInfo
.
username
=
username
;
}
else
{
aAuthInfo
.
domain
=
username
.
substring
(
0
idx
)
;
aAuthInfo
.
username
=
username
.
substring
(
idx
+
1
)
;
}
}
else
{
aAuthInfo
.
username
=
username
;
}
aAuthInfo
.
password
=
password
;
}
_newAsyncPromptConsumer
(
aCallback
aContext
)
{
return
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsICancelable
]
)
callback
:
aCallback
context
:
aContext
cancel
(
)
{
this
.
callback
.
onAuthCancelled
(
this
.
context
false
)
;
this
.
callback
=
null
;
this
.
context
=
null
;
}
}
;
}
_filterUpdatableLogins
(
aLogin
aLoginList
)
{
return
aLoginList
.
filter
(
l
=
>
l
.
username
=
=
aLogin
.
username
|
|
(
l
.
password
=
=
aLogin
.
password
&
&
!
l
.
username
)
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
this
.
LoginManagerPrompter
.
prototype
"
log
"
(
)
=
>
{
let
logger
=
LoginHelper
.
createLogger
(
"
LoginManagerPrompter
"
)
;
return
logger
.
log
.
bind
(
logger
)
;
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
LoginManagerPromptFactory
"
"
LoginManagerPrompter
"
]
;
