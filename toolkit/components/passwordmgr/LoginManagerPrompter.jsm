const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
PrivateBrowsingUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
usernameAutocompleteSearch
"
"
mozilla
.
org
/
autocomplete
/
search
;
1
?
name
=
login
-
doorhanger
-
username
"
"
nsIAutoCompleteSimpleSearch
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
strBundle
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
passwordmgr
/
locale
/
passwordmgr
.
properties
"
)
;
}
)
;
const
LoginInfo
=
Components
.
Constructor
(
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
"
nsILoginInfo
"
"
init
"
)
;
const
BRAND_BUNDLE
=
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
;
const
VISIBILITY_TOGGLE_MAX_PW_AGE_MS
=
2
*
60
*
1000
;
const
PROMPT_DISPLAYED
=
0
;
const
PROMPT_ADD_OR_UPDATE
=
1
;
const
PROMPT_NOTNOW_OR_DONTUPDATE
=
2
;
const
PROMPT_NEVER
=
3
;
const
PROMPT_DELETE
=
3
;
const
NOTIFICATION_TIMEOUT_MS
=
10
*
1000
;
const
ATTENTION_NOTIFICATION_TIMEOUT_MS
=
60
*
1000
;
function
autocompleteSelected
(
popup
)
{
let
doc
=
popup
.
ownerDocument
;
let
nameField
=
doc
.
getElementById
(
"
password
-
notification
-
username
"
)
;
let
passwordField
=
doc
.
getElementById
(
"
password
-
notification
-
password
"
)
;
let
activeElement
=
nameField
.
ownerDocument
.
activeElement
;
if
(
activeElement
=
=
nameField
)
{
popup
.
onUsernameSelect
(
)
;
}
else
if
(
activeElement
=
=
passwordField
)
{
popup
.
onPasswordSelect
(
)
;
}
}
const
observer
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
]
)
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
autocomplete
-
did
-
enter
-
text
"
:
{
let
input
=
subject
.
QueryInterface
(
Ci
.
nsIAutoCompleteInput
)
;
autocompleteSelected
(
input
.
popupElement
)
;
break
;
}
}
}
}
;
class
LoginManagerPrompter
{
get
classID
(
)
{
return
Components
.
ID
(
"
{
c47ff942
-
9678
-
44a5
-
bc9b
-
05e0d676c79c
}
"
)
;
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
"
nsILoginManagerPrompter
"
]
)
;
}
promptToSavePassword
(
aBrowser
aLogin
dismissed
=
false
notifySaved
=
false
autoFilledLoginGuid
=
"
"
possibleValues
=
undefined
)
{
log
.
debug
(
"
promptToSavePassword
"
)
;
let
inPrivateBrowsing
=
PrivateBrowsingUtils
.
isBrowserPrivate
(
aBrowser
)
;
LoginManagerPrompter
.
_showLoginCaptureDoorhanger
(
aBrowser
aLogin
"
password
-
save
"
{
dismissed
:
inPrivateBrowsing
|
|
dismissed
extraAttr
:
notifySaved
?
"
attention
"
:
"
"
}
possibleValues
{
notifySaved
autoFilledLoginGuid
}
)
;
Services
.
obs
.
notifyObservers
(
aLogin
"
passwordmgr
-
prompt
-
save
"
)
;
}
static
_showLoginCaptureDoorhanger
(
browser
login
type
showOptions
=
{
}
possibleValues
=
undefined
{
notifySaved
=
false
messageStringID
autoSavedLoginGuid
=
"
"
autoFilledLoginGuid
=
"
"
}
=
{
}
)
{
log
.
debug
(
_showLoginCaptureDoorhanger
got
autoSavedLoginGuid
:
{
autoSavedLoginGuid
}
)
;
log
.
debug
(
_showLoginCaptureDoorhanger
got
autoFilledLoginGuid
:
{
autoFilledLoginGuid
}
)
;
let
saveMsgNames
=
{
prompt
:
login
.
username
=
=
=
"
"
?
"
saveLoginMsgNoUser
"
:
"
saveLoginMsg
"
buttonLabel
:
"
saveLoginButtonAllow
.
label
"
buttonAccessKey
:
"
saveLoginButtonAllow
.
accesskey
"
secondaryButtonLabel
:
"
saveLoginButtonDeny
.
label
"
secondaryButtonAccessKey
:
"
saveLoginButtonDeny
.
accesskey
"
}
;
let
changeMsgNames
=
{
prompt
:
login
.
username
=
=
=
"
"
?
"
updateLoginMsgNoUser
"
:
"
updateLoginMsg
"
buttonLabel
:
"
updateLoginButtonText
"
buttonAccessKey
:
"
updateLoginButtonAccessKey
"
secondaryButtonLabel
:
"
updateLoginButtonDeny
.
label
"
secondaryButtonAccessKey
:
"
updateLoginButtonDeny
.
accesskey
"
}
;
let
initialMsgNames
=
type
=
=
"
password
-
save
"
?
saveMsgNames
:
changeMsgNames
;
if
(
messageStringID
)
{
changeMsgNames
.
prompt
=
messageStringID
;
}
let
brandBundle
=
Services
.
strings
.
createBundle
(
BRAND_BUNDLE
)
;
let
brandShortName
=
brandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
let
host
=
this
.
_getShortDisplayHost
(
login
.
origin
)
;
let
promptMsg
=
type
=
=
"
password
-
save
"
?
this
.
_getLocalizedString
(
saveMsgNames
.
prompt
[
brandShortName
host
]
)
:
this
.
_getLocalizedString
(
changeMsgNames
.
prompt
)
;
let
histogramName
=
type
=
=
"
password
-
save
"
?
"
PWMGR_PROMPT_REMEMBER_ACTION
"
:
"
PWMGR_PROMPT_UPDATE_ACTION
"
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramName
)
;
let
chromeDoc
=
browser
.
ownerDocument
;
let
currentNotification
;
let
wasModifiedEvent
=
{
did_edit_un
:
"
false
"
did_select_un
:
"
false
"
did_edit_pw
:
"
false
"
did_select_pw
:
"
false
"
}
;
let
updateButtonStatus
=
element
=
>
{
let
mainActionButton
=
element
.
button
;
if
(
!
login
.
password
.
length
)
{
mainActionButton
.
setAttribute
(
"
disabled
"
true
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
classList
.
add
(
"
popup
-
notification
-
invalid
-
input
"
)
;
}
else
{
mainActionButton
.
removeAttribute
(
"
disabled
"
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
classList
.
remove
(
"
popup
-
notification
-
invalid
-
input
"
)
;
}
}
;
let
updateButtonLabel
=
(
)
=
>
{
if
(
!
currentNotification
)
{
Cu
.
reportError
(
"
updateButtonLabel
no
currentNotification
"
)
;
}
let
foundLogins
=
LoginHelper
.
searchLoginsWithObject
(
{
formActionOrigin
:
login
.
formActionOrigin
origin
:
login
.
origin
httpRealm
:
login
.
httpRealm
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
}
)
;
let
logins
=
this
.
_filterUpdatableLogins
(
login
foundLogins
autoSavedLoginGuid
)
;
let
msgNames
=
!
logins
.
length
?
saveMsgNames
:
changeMsgNames
;
let
label
=
this
.
_getLocalizedString
(
msgNames
.
buttonLabel
)
;
let
accessKey
=
this
.
_getLocalizedString
(
msgNames
.
buttonAccessKey
)
;
currentNotification
.
mainAction
.
label
=
label
;
currentNotification
.
mainAction
.
accessKey
=
accessKey
;
let
element
=
[
.
.
.
currentNotification
.
owner
.
panel
.
childNodes
]
.
find
(
n
=
>
n
.
notification
=
=
currentNotification
)
;
if
(
element
)
{
element
.
setAttribute
(
"
buttonlabel
"
label
)
;
element
.
setAttribute
(
"
buttonaccesskey
"
accessKey
)
;
updateButtonStatus
(
element
)
;
}
}
;
let
writeDataToUI
=
(
)
=
>
{
let
nameField
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
;
nameField
.
placeholder
=
usernamePlaceholder
;
nameField
.
value
=
login
.
username
;
let
toggleCheckbox
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
visibilityToggle
"
)
;
toggleCheckbox
.
removeAttribute
(
"
checked
"
)
;
let
passwordField
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
;
passwordField
.
type
=
"
password
"
;
passwordField
.
value
=
login
.
password
;
updateButtonLabel
(
)
;
}
;
let
readDataFromUI
=
(
)
=
>
{
login
.
username
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
value
;
login
.
password
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
value
;
}
;
let
onInput
=
(
)
=
>
{
readDataFromUI
(
)
;
updateButtonLabel
(
)
;
}
;
let
onUsernameInput
=
(
)
=
>
{
wasModifiedEvent
.
did_edit_un
=
"
true
"
;
wasModifiedEvent
.
did_select_un
=
"
false
"
;
onInput
(
)
;
}
;
let
onUsernameSelect
=
(
)
=
>
{
wasModifiedEvent
.
did_edit_un
=
"
false
"
;
wasModifiedEvent
.
did_select_un
=
"
true
"
;
}
;
let
onPasswordInput
=
(
)
=
>
{
wasModifiedEvent
.
did_edit_pw
=
"
true
"
;
wasModifiedEvent
.
did_select_pw
=
"
false
"
;
onInput
(
)
;
}
;
let
onPasswordSelect
=
(
)
=
>
{
wasModifiedEvent
.
did_edit_pw
=
"
false
"
;
wasModifiedEvent
.
did_select_pw
=
"
true
"
;
}
;
let
onKeyUp
=
e
=
>
{
if
(
e
.
key
=
=
"
Enter
"
)
{
e
.
target
.
closest
(
"
popupnotification
"
)
.
button
.
doCommand
(
)
;
}
}
;
let
onVisibilityToggle
=
commandEvent
=
>
{
let
passwordField
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
;
let
selectionStart
=
passwordField
.
selectionStart
;
let
selectionEnd
=
passwordField
.
selectionEnd
;
passwordField
.
setAttribute
(
"
type
"
commandEvent
.
target
.
checked
?
"
"
:
"
password
"
)
;
if
(
!
passwordField
.
hasAttribute
(
"
focused
"
)
)
{
return
;
}
passwordField
.
selectionStart
=
selectionStart
;
passwordField
.
selectionEnd
=
selectionEnd
;
}
;
let
togglePopup
=
event
=
>
{
event
.
target
.
parentElement
.
getElementsByClassName
(
"
ac
-
has
-
end
-
icon
"
)
[
0
]
.
toggleHistoryPopup
(
)
;
}
;
let
persistData
=
(
)
=
>
{
let
foundLogins
=
LoginHelper
.
searchLoginsWithObject
(
{
formActionOrigin
:
login
.
formActionOrigin
origin
:
login
.
origin
httpRealm
:
login
.
httpRealm
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
}
)
;
let
logins
=
this
.
_filterUpdatableLogins
(
login
foundLogins
autoSavedLoginGuid
)
;
let
resolveBy
=
[
"
scheme
"
"
timePasswordChanged
"
]
;
logins
=
LoginHelper
.
dedupeLogins
(
logins
[
"
username
"
]
resolveBy
login
.
origin
)
;
logins
.
sort
(
l
=
>
(
l
.
username
=
=
login
.
username
?
-
1
:
1
)
)
;
log
.
debug
(
persistData
:
Matched
{
logins
.
length
}
logins
)
;
let
loginToRemove
;
let
loginToUpdate
=
logins
.
shift
(
)
;
if
(
logins
.
length
&
&
logins
[
0
]
.
guid
=
=
autoSavedLoginGuid
)
{
loginToRemove
=
logins
.
shift
(
)
;
}
if
(
logins
.
length
)
{
log
.
warn
(
logins
.
length
"
other
updatable
logins
!
"
logins
.
map
(
l
=
>
l
.
guid
)
"
loginToUpdate
:
"
loginToUpdate
&
&
loginToUpdate
.
guid
"
loginToRemove
:
"
loginToRemove
&
&
loginToRemove
.
guid
)
;
}
if
(
!
loginToUpdate
)
{
Services
.
logins
.
addLogin
(
new
LoginInfo
(
login
.
origin
login
.
formActionOrigin
login
.
httpRealm
login
.
username
login
.
password
login
.
usernameField
login
.
passwordField
)
)
;
}
else
if
(
loginToUpdate
.
password
=
=
login
.
password
&
&
loginToUpdate
.
username
=
=
login
.
username
)
{
log
.
debug
(
"
persistData
:
Touch
matched
login
"
loginToUpdate
.
guid
)
;
Services
.
logins
.
recordPasswordUse
(
loginToUpdate
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
loginToUpdate
.
username
?
"
form_password
"
:
"
form_login
"
!
!
autoFilledLoginGuid
)
;
}
else
{
log
.
debug
(
"
persistData
:
Update
matched
login
"
loginToUpdate
.
guid
)
;
this
.
_updateLogin
(
loginToUpdate
login
)
;
if
(
loginToRemove
&
&
loginToRemove
.
guid
=
=
autoSavedLoginGuid
)
{
Services
.
obs
.
notifyObservers
(
loginToRemove
"
passwordmgr
-
autosaved
-
login
-
merged
"
)
;
}
}
if
(
loginToRemove
)
{
log
.
debug
(
"
persistData
:
removing
login
"
loginToRemove
.
guid
)
;
Services
.
logins
.
removeLogin
(
loginToRemove
)
;
}
}
;
let
mainAction
=
{
label
:
this
.
_getLocalizedString
(
initialMsgNames
.
buttonLabel
)
accessKey
:
this
.
_getLocalizedString
(
initialMsgNames
.
buttonAccessKey
)
callback
:
(
)
=
>
{
readDataFromUI
(
)
;
if
(
type
=
=
"
password
-
save
"
&
&
!
Services
.
policies
.
isAllowed
(
"
removeMasterPassword
"
)
)
{
if
(
!
LoginHelper
.
isMasterPasswordSet
(
)
)
{
browser
.
ownerGlobal
.
openDialog
(
"
chrome
:
/
/
mozapps
/
content
/
preferences
/
changemp
.
xhtml
"
"
"
"
centerscreen
chrome
modal
titlebar
"
)
;
if
(
!
LoginHelper
.
isMasterPasswordSet
(
)
)
{
return
;
}
}
}
histogram
.
add
(
PROMPT_ADD_OR_UPDATE
)
;
if
(
histogramName
=
=
"
PWMGR_PROMPT_REMEMBER_ACTION
"
)
{
Services
.
obs
.
notifyObservers
(
browser
"
LoginStats
:
NewSavedPassword
"
)
;
}
else
if
(
histogramName
=
=
"
PWMGR_PROMPT_UPDATE_ACTION
"
)
{
Services
.
obs
.
notifyObservers
(
browser
"
LoginStats
:
LoginUpdateSaved
"
)
;
}
else
{
throw
new
Error
(
"
Unknown
histogram
"
)
;
}
let
eventObject
;
if
(
type
=
=
"
password
-
change
"
)
{
eventObject
=
"
update
"
;
}
else
if
(
type
=
=
"
password
-
save
"
)
{
eventObject
=
"
save
"
;
}
else
{
throw
new
Error
(
Unexpected
doorhanger
type
.
Expected
either
'
password
-
save
'
or
'
password
-
change
'
got
{
type
}
)
;
}
Services
.
telemetry
.
recordEvent
(
"
pwmgr
"
"
doorhanger_submitted
"
eventObject
null
wasModifiedEvent
)
;
persistData
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
histogramName
)
;
browser
.
focus
(
)
;
}
}
;
let
secondaryActions
=
[
{
label
:
this
.
_getLocalizedString
(
initialMsgNames
.
secondaryButtonLabel
)
accessKey
:
this
.
_getLocalizedString
(
initialMsgNames
.
secondaryButtonAccessKey
)
callback
:
(
)
=
>
{
histogram
.
add
(
PROMPT_NOTNOW_OR_DONTUPDATE
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
histogramName
)
;
browser
.
focus
(
)
;
}
}
]
;
if
(
type
=
=
"
password
-
save
"
)
{
secondaryActions
.
push
(
{
label
:
this
.
_getLocalizedString
(
"
saveLoginButtonNever
.
label
"
)
accessKey
:
this
.
_getLocalizedString
(
"
saveLoginButtonNever
.
accesskey
"
)
callback
:
(
)
=
>
{
histogram
.
add
(
PROMPT_NEVER
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
histogramName
)
;
Services
.
logins
.
setLoginSavingEnabled
(
login
.
origin
false
)
;
browser
.
focus
(
)
;
}
}
)
;
}
if
(
type
=
=
"
password
-
change
"
)
{
secondaryActions
.
push
(
{
label
:
this
.
_getLocalizedString
(
"
updateLoginButtonDelete
.
label
"
)
accessKey
:
this
.
_getLocalizedString
(
"
updateLoginButtonDelete
.
accesskey
"
)
callback
:
async
(
)
=
>
{
histogram
.
add
(
PROMPT_DELETE
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
histogramName
)
;
const
matchingLogins
=
await
Services
.
logins
.
searchLoginsAsync
(
{
guid
:
login
.
guid
origin
:
login
.
origin
}
)
;
Services
.
logins
.
removeLogin
(
matchingLogins
[
0
]
)
;
browser
.
focus
(
)
;
const
anchor
=
browser
.
ownerDocument
.
getElementById
(
"
identity
-
icon
"
)
;
log
.
debug
(
"
Showing
the
ConfirmationHint
"
)
;
anchor
.
ownerGlobal
.
ConfirmationHint
.
show
(
anchor
"
loginRemoved
"
{
hideArrow
:
true
}
)
;
}
}
)
;
}
let
usernamePlaceholder
=
this
.
_getLocalizedString
(
"
noUsernamePlaceholder
"
)
;
let
togglePasswordLabel
=
this
.
_getLocalizedString
(
"
togglePasswordLabel
"
)
;
let
togglePasswordAccessKey
=
this
.
_getLocalizedString
(
"
togglePasswordAccessKey2
"
)
;
let
{
PopupNotifications
}
=
browser
.
ownerGlobal
.
wrappedJSObject
;
let
notificationID
=
"
password
"
;
const
timeoutMs
=
showOptions
.
dismissed
&
&
showOptions
.
extraAttr
=
=
"
attention
"
?
ATTENTION_NOTIFICATION_TIMEOUT_MS
:
NOTIFICATION_TIMEOUT_MS
;
let
options
=
Object
.
assign
(
{
timeout
:
Date
.
now
(
)
+
timeoutMs
persistWhileVisible
:
true
passwordNotificationType
:
type
hideClose
:
true
eventCallback
(
topic
)
{
switch
(
topic
)
{
case
"
showing
"
:
log
.
debug
(
"
showing
"
)
;
currentNotification
=
this
;
if
(
!
this
.
timeShown
)
{
histogram
.
add
(
PROMPT_DISPLAYED
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
telemetry
:
histogram
"
histogramName
)
;
}
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
removeAttribute
(
"
focused
"
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
removeAttribute
(
"
focused
"
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
addEventListener
(
"
input
"
onUsernameInput
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
.
addEventListener
(
"
keyup
"
onKeyUp
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
addEventListener
(
"
keyup
"
onKeyUp
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
.
addEventListener
(
"
input
"
onPasswordInput
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
-
dropmarker
"
)
.
addEventListener
(
"
click
"
togglePopup
)
;
LoginManagerPrompter
.
_getUsernameSuggestions
(
login
possibleValues
?
.
usernames
)
.
then
(
usernameSuggestions
=
>
{
let
dropmarker
=
chromeDoc
?
.
getElementById
(
"
password
-
notification
-
username
-
dropmarker
"
)
;
if
(
dropmarker
)
{
dropmarker
.
hidden
=
!
usernameSuggestions
.
length
;
}
let
usernameField
=
chromeDoc
?
.
getElementById
(
"
password
-
notification
-
username
"
)
;
if
(
usernameField
)
{
usernameField
.
classList
.
toggle
(
"
ac
-
has
-
end
-
icon
"
!
!
usernameSuggestions
.
length
)
;
}
}
)
;
let
toggleBtn
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
visibilityToggle
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
signon
.
rememberSignons
.
visibilityToggle
"
)
)
{
toggleBtn
.
addEventListener
(
"
command
"
onVisibilityToggle
)
;
toggleBtn
.
setAttribute
(
"
label
"
togglePasswordLabel
)
;
toggleBtn
.
setAttribute
(
"
accesskey
"
togglePasswordAccessKey
)
;
let
hideToggle
=
LoginHelper
.
isMasterPasswordSet
(
)
|
|
!
!
autoFilledLoginGuid
|
|
(
this
.
timeShown
&
&
this
.
wasDismissed
)
|
|
(
messageStringID
=
=
"
updateLoginMsgAddUsername
"
&
&
login
.
timePasswordChanged
<
Date
.
now
(
)
-
VISIBILITY_TOGGLE_MAX_PW_AGE_MS
)
;
toggleBtn
.
setAttribute
(
"
hidden
"
hideToggle
)
;
}
let
popup
=
chromeDoc
.
getElementById
(
"
PopupAutoComplete
"
)
;
popup
.
onUsernameSelect
=
onUsernameSelect
;
popup
.
onPasswordSelect
=
onPasswordSelect
;
LoginManagerPrompter
.
_setUsernameAutocomplete
(
login
possibleValues
?
.
usernames
)
;
break
;
case
"
shown
"
:
{
log
.
debug
(
"
shown
"
)
;
writeDataToUI
(
)
;
let
anchorIcon
=
this
.
anchorElement
;
if
(
anchorIcon
&
&
this
.
options
.
extraAttr
=
=
"
attention
"
)
{
anchorIcon
.
removeAttribute
(
"
extraAttr
"
)
;
delete
this
.
options
.
extraAttr
;
}
break
;
}
case
"
dismissed
"
:
this
.
wasDismissed
=
true
;
case
"
removed
"
:
{
log
.
debug
(
topic
)
;
currentNotification
=
null
;
let
usernameField
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
"
)
;
usernameField
.
removeEventListener
(
"
input
"
onUsernameInput
)
;
usernameField
.
removeEventListener
(
"
keyup
"
onKeyUp
)
;
let
passwordField
=
chromeDoc
.
getElementById
(
"
password
-
notification
-
password
"
)
;
passwordField
.
removeEventListener
(
"
input
"
onPasswordInput
)
;
passwordField
.
removeEventListener
(
"
keyup
"
onKeyUp
)
;
passwordField
.
removeEventListener
(
"
command
"
onVisibilityToggle
)
;
chromeDoc
.
getElementById
(
"
password
-
notification
-
username
-
dropmarker
"
)
.
removeEventListener
(
"
click
"
togglePopup
)
;
break
;
}
}
return
false
;
}
}
showOptions
)
;
let
notification
=
PopupNotifications
.
show
(
browser
notificationID
promptMsg
"
password
-
notification
-
icon
"
mainAction
secondaryActions
options
)
;
if
(
notifySaved
)
{
let
anchor
=
notification
.
anchorElement
;
log
.
debug
(
"
Showing
the
ConfirmationHint
"
)
;
anchor
.
ownerGlobal
.
ConfirmationHint
.
show
(
anchor
"
passwordSaved
"
)
;
}
}
promptToChangePassword
(
aBrowser
aOldLogin
aNewLogin
dismissed
=
false
notifySaved
=
false
autoSavedLoginGuid
=
"
"
autoFilledLoginGuid
=
"
"
possibleValues
=
undefined
)
{
let
login
=
aOldLogin
.
clone
(
)
;
login
.
origin
=
aNewLogin
.
origin
;
login
.
formActionOrigin
=
aNewLogin
.
formActionOrigin
;
login
.
password
=
aNewLogin
.
password
;
login
.
username
=
aNewLogin
.
username
;
let
messageStringID
;
if
(
aOldLogin
.
username
=
=
=
"
"
&
&
login
.
username
!
=
=
"
"
&
&
login
.
password
=
=
aOldLogin
.
password
)
{
messageStringID
=
"
updateLoginMsgAddUsername
"
;
}
LoginManagerPrompter
.
_showLoginCaptureDoorhanger
(
aBrowser
login
"
password
-
change
"
{
dismissed
extraAttr
:
notifySaved
?
"
attention
"
:
"
"
}
possibleValues
{
notifySaved
messageStringID
autoSavedLoginGuid
autoFilledLoginGuid
}
)
;
let
oldGUID
=
aOldLogin
.
QueryInterface
(
Ci
.
nsILoginMetaInfo
)
.
guid
;
Services
.
obs
.
notifyObservers
(
aNewLogin
"
passwordmgr
-
prompt
-
change
"
oldGUID
)
;
}
promptToChangePasswordWithUsernames
(
browser
logins
aNewLogin
)
{
log
.
debug
(
"
promptToChangePasswordWithUsernames
with
count
:
"
logins
.
length
)
;
var
usernames
=
logins
.
map
(
l
=
>
l
.
username
|
|
LoginManagerPrompter
.
_getLocalizedString
(
"
noUsername
"
)
)
;
var
dialogText
=
LoginManagerPrompter
.
_getLocalizedString
(
"
userSelectText2
"
)
;
var
dialogTitle
=
LoginManagerPrompter
.
_getLocalizedString
(
"
passwordChangeTitle
"
)
;
var
selectedIndex
=
{
value
:
null
}
;
var
ok
=
Services
.
prompt
.
select
(
browser
.
ownerGlobal
dialogTitle
dialogText
usernames
selectedIndex
)
;
if
(
ok
)
{
var
selectedLogin
=
logins
[
selectedIndex
.
value
]
;
log
.
debug
(
"
Updating
password
for
user
"
selectedLogin
.
username
)
;
var
newLoginWithUsername
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
newLoginWithUsername
.
init
(
aNewLogin
.
origin
aNewLogin
.
formActionOrigin
aNewLogin
.
httpRealm
selectedLogin
.
username
aNewLogin
.
password
selectedLogin
.
usernameField
aNewLogin
.
passwordField
)
;
LoginManagerPrompter
.
_updateLogin
(
selectedLogin
newLoginWithUsername
)
;
}
}
static
_updateLogin
(
login
aNewLogin
)
{
var
now
=
Date
.
now
(
)
;
var
propBag
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
propBag
.
setProperty
(
"
formActionOrigin
"
aNewLogin
.
formActionOrigin
)
;
propBag
.
setProperty
(
"
origin
"
aNewLogin
.
origin
)
;
propBag
.
setProperty
(
"
password
"
aNewLogin
.
password
)
;
propBag
.
setProperty
(
"
username
"
aNewLogin
.
username
)
;
propBag
.
setProperty
(
"
timePasswordChanged
"
now
)
;
propBag
.
setProperty
(
"
timeLastUsed
"
now
)
;
propBag
.
setProperty
(
"
timesUsedIncrement
"
1
)
;
Services
.
logins
.
modifyLogin
(
login
propBag
)
;
}
static
_getLocalizedString
(
key
formatArgs
)
{
if
(
formatArgs
)
{
return
strBundle
.
formatStringFromName
(
key
formatArgs
)
;
}
return
strBundle
.
GetStringFromName
(
key
)
;
}
static
_getShortDisplayHost
(
aURIString
)
{
var
displayHost
;
var
idnService
=
Cc
[
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIDNService
)
;
try
{
var
uri
=
Services
.
io
.
newURI
(
aURIString
)
;
var
baseDomain
=
Services
.
eTLD
.
getBaseDomain
(
uri
)
;
displayHost
=
idnService
.
convertToDisplayIDN
(
baseDomain
{
}
)
;
}
catch
(
e
)
{
log
.
warn
(
"
_getShortDisplayHost
couldn
'
t
process
"
aURIString
)
;
}
if
(
!
displayHost
)
{
displayHost
=
aURIString
;
}
return
displayHost
;
}
static
_filterUpdatableLogins
(
aLogin
aLoginList
includeGUID
)
{
return
aLoginList
.
filter
(
l
=
>
l
.
username
=
=
aLogin
.
username
|
|
(
l
.
password
=
=
aLogin
.
password
&
&
!
l
.
username
)
|
|
(
includeGUID
&
&
includeGUID
=
=
l
.
guid
)
)
;
}
static
async
_setUsernameAutocomplete
(
login
possibleUsernames
=
new
Set
(
)
)
{
let
result
=
Cc
[
"
mozilla
.
org
/
autocomplete
/
simple
-
result
;
1
"
]
.
createInstance
(
Ci
.
nsIAutoCompleteSimpleResult
)
;
result
.
setDefaultIndex
(
0
)
;
let
usernames
=
await
this
.
_getUsernameSuggestions
(
login
possibleUsernames
)
;
for
(
let
{
text
style
}
of
usernames
)
{
let
value
=
text
;
let
comment
=
"
"
;
let
image
=
"
"
;
let
_style
=
style
;
result
.
appendMatch
(
value
comment
image
_style
)
;
}
if
(
usernames
.
length
)
{
result
.
setSearchResult
(
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
)
;
}
else
{
result
.
setSearchResult
(
Ci
.
nsIAutoCompleteResult
.
RESULT_NOMATCH
)
;
}
usernameAutocompleteSearch
.
overrideNextResult
(
result
)
;
}
static
async
_getUsernameSuggestions
(
login
possibleUsernames
=
new
Set
(
)
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
signon
.
capture
.
inputChanges
.
enabled
"
)
)
{
return
[
]
;
}
if
(
!
Services
.
logins
.
isLoggedIn
)
{
return
[
]
;
}
let
baseDomainLogins
=
await
Services
.
logins
.
searchLoginsAsync
(
{
origin
:
login
.
origin
schemeUpgrades
:
LoginHelper
.
schemeUpgrades
acceptDifferentSubdomains
:
true
}
)
;
let
saved
=
baseDomainLogins
.
map
(
login
=
>
{
return
{
text
:
login
.
username
style
:
"
login
"
}
;
}
)
;
let
possible
=
[
.
.
.
possibleUsernames
]
.
map
(
username
=
>
{
return
{
text
:
username
style
:
"
possible
-
username
"
}
;
}
)
;
return
possible
.
concat
(
saved
)
.
reduce
(
(
acc
next
)
=
>
{
let
alreadyInAcc
=
acc
.
findIndex
(
entry
=
>
entry
.
text
=
=
next
.
text
)
!
=
-
1
;
if
(
!
alreadyInAcc
)
{
acc
.
push
(
next
)
;
}
else
if
(
next
.
style
=
=
"
possible
-
username
"
)
{
let
existingIndex
=
acc
.
findIndex
(
entry
=
>
entry
.
text
=
=
next
.
text
)
;
acc
[
existingIndex
]
=
next
;
}
return
acc
;
}
[
]
)
.
filter
(
suggestion
=
>
!
!
suggestion
.
text
)
;
}
}
Services
.
obs
.
addObserver
(
observer
"
autocomplete
-
did
-
enter
-
text
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
return
LoginHelper
.
createLogger
(
"
LoginManagerPrompter
"
)
;
}
)
;
const
EXPORTED_SYMBOLS
=
[
"
LoginManagerPrompter
"
]
;
