#
include
"
GeckoTrace
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
StaticPrefs_toolkit
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
ipc
/
UtilityProcessChild
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessChild
.
h
"
#
include
"
opentelemetry
/
context
/
runtime_context
.
h
"
#
include
"
opentelemetry
/
sdk
/
common
/
global_log_handler
.
h
"
#
include
"
opentelemetry
/
sdk
/
trace
/
random_id_generator_factory
.
h
"
#
include
"
opentelemetry
/
sdk
/
trace
/
samplers
/
always_on_factory
.
h
"
#
include
"
opentelemetry
/
sdk
/
trace
/
tracer_provider
.
h
"
#
include
"
opentelemetry
/
semconv
/
service_attributes
.
h
"
#
include
"
opentelemetry
/
trace
/
provider
.
h
"
#
include
"
SemanticConventions
.
h
"
#
include
"
SpanProcessing
.
h
"
namespace
otel
=
opentelemetry
;
namespace
otel_sdk_log
=
opentelemetry
:
:
sdk
:
:
common
:
:
internal_log
;
namespace
mozilla
:
:
gecko_trace
{
LazyLogModule
gLog
(
"
gecko
-
trace
"
)
;
namespace
{
static
otel_sdk_log
:
:
LogLevel
ToOTelLevel
(
mozilla
:
:
LogLevel
aMozLevel
)
{
using
OTelLevel
=
otel_sdk_log
:
:
LogLevel
;
using
MozLevel
=
mozilla
:
:
LogLevel
;
switch
(
aMozLevel
)
{
case
MozLevel
:
:
Error
:
return
OTelLevel
:
:
Error
;
case
MozLevel
:
:
Warning
:
return
OTelLevel
:
:
Warning
;
case
MozLevel
:
:
Info
:
return
OTelLevel
:
:
Info
;
case
MozLevel
:
:
Debug
:
[
[
fallthrough
]
]
;
case
MozLevel
:
:
Verbose
:
return
OTelLevel
:
:
Debug
;
case
MozLevel
:
:
Disabled
:
[
[
fallthrough
]
]
;
default
:
return
OTelLevel
:
:
None
;
}
}
static
mozilla
:
:
LogLevel
ToMozLevel
(
otel_sdk_log
:
:
LogLevel
aOTelLevel
)
{
using
OTelLevel
=
otel_sdk_log
:
:
LogLevel
;
using
MozLevel
=
mozilla
:
:
LogLevel
;
switch
(
aOTelLevel
)
{
case
OTelLevel
:
:
Error
:
return
MozLevel
:
:
Error
;
case
OTelLevel
:
:
Warning
:
return
MozLevel
:
:
Warning
;
case
OTelLevel
:
:
Info
:
return
MozLevel
:
:
Info
;
case
OTelLevel
:
:
Debug
:
return
MozLevel
:
:
Debug
;
default
:
return
MozLevel
:
:
Disabled
;
}
}
class
OTelScopeAdapter
final
:
public
Scope
{
public
:
explicit
OTelScopeAdapter
(
std
:
:
unique_ptr
<
otel
:
:
context
:
:
Token
>
token
)
:
mToken
(
std
:
:
move
(
token
)
)
{
}
private
:
std
:
:
unique_ptr
<
otel
:
:
context
:
:
Token
>
mToken
;
}
;
class
OTelSpanAdapter
final
:
public
Span
{
public
:
explicit
OTelSpanAdapter
(
std
:
:
shared_ptr
<
otel
:
:
trace
:
:
Span
>
span
)
:
mSpan
(
std
:
:
move
(
span
)
)
{
}
void
AddEvent
(
const
SpanEvent
&
aEvent
)
override
{
class
KeyValueAdapter
:
public
otel
:
:
common
:
:
KeyValueIterable
{
public
:
explicit
KeyValueAdapter
(
const
SpanEvent
&
aEvent
)
:
mEvent
(
aEvent
)
{
}
bool
ForEachKeyValue
(
otel
:
:
nostd
:
:
function_ref
<
bool
(
string_view
otel
:
:
common
:
:
AttributeValue
)
>
callback
)
const
noexcept
override
{
return
mEvent
.
ForEachKeyValue
(
[
&
]
(
string_view
aName
const
AttributeValue
&
aValue
)
{
return
aValue
.
match
(
[
&
]
(
bool
aBool
)
{
return
callback
(
aName
aBool
)
;
}
[
&
]
(
int64_t
aInt
)
{
return
callback
(
aName
aInt
)
;
}
[
&
]
(
string_view
aStr
)
{
return
callback
(
aName
aStr
)
;
}
[
&
]
(
mozilla
:
:
Span
<
const
bool
>
aBoolSpan
)
{
return
callback
(
aName
aBoolSpan
)
;
}
[
&
]
(
mozilla
:
:
Span
<
const
int64_t
>
aIntSpan
)
{
return
callback
(
aName
aIntSpan
)
;
}
[
&
]
(
mozilla
:
:
Span
<
const
string_view
>
aStringSpan
)
{
return
callback
(
aName
aStringSpan
)
;
}
)
;
}
)
;
}
size_t
size
(
)
const
noexcept
override
{
return
mEvent
.
Size
(
)
;
}
private
:
const
SpanEvent
&
mEvent
;
}
;
KeyValueAdapter
adapter
(
aEvent
)
;
mSpan
-
>
AddEvent
(
aEvent
.
GetEventName
(
)
adapter
)
;
}
std
:
:
shared_ptr
<
Scope
>
Enter
(
)
override
{
auto
token
=
otel
:
:
context
:
:
RuntimeContext
:
:
Attach
(
otel
:
:
context
:
:
RuntimeContext
:
:
GetCurrent
(
)
.
SetValue
(
otel
:
:
trace
:
:
kSpanKey
mSpan
)
)
;
return
std
:
:
make_shared
<
OTelScopeAdapter
>
(
std
:
:
move
(
token
)
)
;
}
private
:
std
:
:
shared_ptr
<
otel
:
:
trace
:
:
Span
>
mSpan
;
}
;
class
OTelTracerAdapter
final
:
public
Tracer
{
public
:
explicit
OTelTracerAdapter
(
std
:
:
shared_ptr
<
otel
:
:
trace
:
:
Tracer
>
tracer
)
:
mTracer
(
std
:
:
move
(
tracer
)
)
{
}
std
:
:
shared_ptr
<
Span
>
StartSpan
(
string_view
aName
)
override
{
return
std
:
:
make_shared
<
OTelSpanAdapter
>
(
mTracer
-
>
StartSpan
(
aName
)
)
;
}
private
:
std
:
:
shared_ptr
<
otel
:
:
trace
:
:
Tracer
>
mTracer
;
}
;
class
OTelToMozLogHandler
final
:
public
otel_sdk_log
:
:
LogHandler
{
public
:
void
Handle
(
otel_sdk_log
:
:
LogLevel
aLevel
const
char
*
aFile
int
aLine
const
char
*
aMsg
const
otel
:
:
sdk
:
:
common
:
:
AttributeMap
&
)
noexcept
override
{
static
LazyLogModule
sOTelLog
(
"
opentelemetry
"
)
;
MOZ_LOG
(
sOTelLog
ToMozLevel
(
aLevel
)
(
"
%
s
"
aMsg
)
)
;
}
}
;
}
void
SpanEvent
:
:
Emit
(
)
{
Tracer
:
:
GetCurrentSpan
(
)
-
>
AddEvent
(
*
this
)
;
}
std
:
:
shared_ptr
<
gecko_trace
:
:
Span
>
Tracer
:
:
GetCurrentSpan
(
)
{
auto
active
=
otel
:
:
context
:
:
RuntimeContext
:
:
GetValue
(
otel
:
:
trace
:
:
kSpanKey
)
;
if
(
std
:
:
holds_alternative
<
std
:
:
shared_ptr
<
otel
:
:
trace
:
:
Span
>
>
(
active
)
)
{
return
std
:
:
make_shared
<
OTelSpanAdapter
>
(
std
:
:
get
<
std
:
:
shared_ptr
<
otel
:
:
trace
:
:
Span
>
>
(
active
)
)
;
}
static
thread_local
auto
sDefaultOTelSpan
=
std
:
:
make_shared
<
OTelSpanAdapter
>
(
std
:
:
make_shared
<
otel
:
:
trace
:
:
DefaultSpan
>
(
otel
:
:
trace
:
:
SpanContext
:
:
GetInvalid
(
)
)
)
;
return
sDefaultOTelSpan
;
}
std
:
:
shared_ptr
<
Tracer
>
TracerProvider
:
:
GetTracer
(
string_view
aComponentName
)
{
auto
otelTracer
=
otel
:
:
trace
:
:
Provider
:
:
GetTracerProvider
(
)
-
>
GetTracer
(
aComponentName
)
;
return
std
:
:
make_shared
<
OTelTracerAdapter
>
(
otelTracer
)
;
}
void
SetOpenTelemetryInternalLogLevel
(
mozilla
:
:
LogLevel
aLogLevel
)
{
otel_sdk_log
:
:
GlobalLogHandler
:
:
SetLogLevel
(
ToOTelLevel
(
aLogLevel
)
)
;
}
void
InitializeTracerProvider
(
)
{
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Default
:
[
[
fallthrough
]
]
;
case
GeckoProcessType_Content
:
[
[
fallthrough
]
]
;
case
GeckoProcessType_Socket
:
[
[
fallthrough
]
]
;
case
GeckoProcessType_Utility
:
break
;
default
:
MOZ_LOG
(
gLog
LogLevel
:
:
Warning
(
"
InitializeTracerProvider
:
Unsupported
process
type
%
s
-
"
"
tracing
disabled
"
XRE_GetProcessTypeString
(
)
)
)
;
return
;
}
auto
processor
=
std
:
:
make_unique
<
LocalSpanProcessor
>
(
std
:
:
make_unique
<
ProtobufExporter
>
(
[
]
(
ipc
:
:
ByteBuf
&
&
aBuffer
)
{
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Default
:
recv_gecko_trace_export
(
aBuffer
.
mData
aBuffer
.
mLen
)
;
return
true
;
case
GeckoProcessType_Content
:
return
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendGeckoTraceExport
(
std
:
:
move
(
aBuffer
)
)
;
case
GeckoProcessType_Socket
:
return
net
:
:
SocketProcessChild
:
:
GetSingleton
(
)
-
>
SendGeckoTraceExport
(
std
:
:
move
(
aBuffer
)
)
;
case
GeckoProcessType_Utility
:
return
ipc
:
:
UtilityProcessChild
:
:
GetSingleton
(
)
-
>
SendGeckoTraceExport
(
std
:
:
move
(
aBuffer
)
)
;
default
:
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
unsupported
process
type
"
)
)
;
return
false
;
}
}
)
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
otel
:
:
sdk
:
:
trace
:
:
SpanProcessor
>
>
processors
{
}
;
processors
.
push_back
(
std
:
:
move
(
processor
)
)
;
auto
resource
=
otel
:
:
sdk
:
:
resource
:
:
Resource
:
:
Create
(
{
{
otel
:
:
semconv
:
:
service
:
:
kServiceName
"
Firefox
"
}
{
semantic_conventions
:
:
kProcessID
XRE_GetChildID
(
)
}
{
semantic_conventions
:
:
kProcessType
XRE_GetProcessTypeString
(
)
}
}
)
;
bool
tracingEnabled
=
StaticPrefs
:
:
toolkit_gecko_trace_enable
(
)
;
auto
configurator
=
otel
:
:
sdk
:
:
instrumentationscope
:
:
ScopeConfigurator
<
otel
:
:
sdk
:
:
trace
:
:
TracerConfig
>
:
:
Builder
(
tracingEnabled
?
otel
:
:
sdk
:
:
trace
:
:
TracerConfig
:
:
Enabled
(
)
:
otel
:
:
sdk
:
:
trace
:
:
TracerConfig
:
:
Disabled
(
)
)
.
Build
(
)
;
auto
context
=
std
:
:
make_unique
<
otel
:
:
sdk
:
:
trace
:
:
TracerContext
>
(
std
:
:
move
(
processors
)
resource
otel
:
:
sdk
:
:
trace
:
:
AlwaysOnSamplerFactory
:
:
Create
(
)
otel
:
:
sdk
:
:
trace
:
:
RandomIdGeneratorFactory
:
:
Create
(
)
std
:
:
make_unique
<
otel
:
:
sdk
:
:
instrumentationscope
:
:
ScopeConfigurator
<
otel
:
:
sdk
:
:
trace
:
:
TracerConfig
>
>
(
configurator
)
)
;
auto
tracerProvider
=
std
:
:
make_shared
<
otel
:
:
sdk
:
:
trace
:
:
TracerProvider
>
(
std
:
:
move
(
context
)
)
;
otel
:
:
trace
:
:
Provider
:
:
SetTracerProvider
(
tracerProvider
)
;
}
void
InitializeShutdownHandlers
(
)
{
const
auto
shutdownTracerProvider
=
[
]
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
Shutting
down
tracer
provider
"
)
)
;
otel
:
:
trace
:
:
Provider
:
:
SetTracerProvider
(
std
:
:
make_shared
<
otel
:
:
trace
:
:
NoopTracerProvider
>
(
)
)
;
}
;
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Default
:
RunOnShutdown
(
shutdownTracerProvider
ShutdownPhase
:
:
XPCOMWillShutdown
)
;
break
;
case
GeckoProcessType_Content
:
RunOnShutdown
(
shutdownTracerProvider
ShutdownPhase
:
:
AppShutdownConfirmed
)
;
break
;
default
:
RunOnShutdown
(
shutdownTracerProvider
ShutdownPhase
:
:
XPCOMShutdownFinal
)
;
break
;
}
}
void
Init
(
)
{
otel_sdk_log
:
:
GlobalLogHandler
:
:
SetLogHandler
(
std
:
:
make_shared
<
OTelToMozLogHandler
>
(
)
)
;
InitializeTracerProvider
(
)
;
InitializeShutdownHandlers
(
)
;
}
}
