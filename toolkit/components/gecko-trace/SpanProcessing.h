#
ifndef
GECKO_TRACE_SPAN_EXPORTERS_H
#
define
GECKO_TRACE_SPAN_EXPORTERS_H
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
ipc
/
ByteBuf
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
opentelemetry
/
exporters
/
otlp
/
otlp_recordable
.
h
"
#
include
"
opentelemetry
/
exporters
/
otlp
/
otlp_recordable_utils
.
h
"
#
include
"
opentelemetry
/
proto
/
collector
/
trace
/
v1
/
trace_service
.
pb
.
h
"
#
include
"
opentelemetry
/
sdk
/
trace
/
exporter
.
h
"
#
include
"
opentelemetry
/
sdk
/
trace
/
processor
.
h
"
namespace
otel
=
opentelemetry
;
namespace
mozilla
:
:
gecko_trace
{
namespace
{
nsCString
ToHex
(
const
nsCString
&
aRawId
)
{
nsCString
hexId
{
}
;
constexpr
char
kHex
[
]
=
"
0123456789abcdef
"
;
for
(
size_t
i
=
0
;
i
<
aRawId
.
Length
(
)
;
+
+
i
)
{
hexId
.
Append
(
kHex
[
(
aRawId
[
i
]
>
>
4
)
&
0xF
]
)
;
hexId
.
Append
(
kHex
[
(
aRawId
[
i
]
>
>
0
)
&
0xF
]
)
;
}
return
hexId
;
}
}
extern
LazyLogModule
gLog
;
class
ProtobufExporter
:
public
otel
:
:
sdk
:
:
trace
:
:
SpanExporter
{
public
:
using
IPCExporter
=
std
:
:
function
<
bool
(
ipc
:
:
ByteBuf
&
&
)
>
;
explicit
ProtobufExporter
(
IPCExporter
&
&
aIPCExporter
)
:
mIPCExporter
(
aIPCExporter
)
{
}
std
:
:
unique_ptr
<
otel
:
:
sdk
:
:
trace
:
:
Recordable
>
MakeRecordable
(
)
noexcept
override
{
return
std
:
:
make_unique
<
otel
:
:
exporter
:
:
otlp
:
:
OtlpRecordable
>
(
)
;
}
otel
:
:
sdk
:
:
common
:
:
ExportResult
Export
(
const
otel
:
:
nostd
:
:
span
<
std
:
:
unique_ptr
<
otel
:
:
sdk
:
:
trace
:
:
Recordable
>
>
&
spans
)
noexcept
override
{
MOZ_ASSERT
(
!
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownNetTeardown
)
)
;
otel
:
:
proto
:
:
collector
:
:
trace
:
:
v1
:
:
ExportTraceServiceRequest
request
;
otel
:
:
exporter
:
:
otlp
:
:
OtlpRecordableUtils
:
:
PopulateRequest
(
spans
&
request
)
;
ipc
:
:
ByteBuf
buffer
;
const
size_t
size
=
request
.
ByteSizeLong
(
)
;
buffer
.
Allocate
(
size
)
;
if
(
!
request
.
SerializeToArray
(
buffer
.
mData
int
(
size
)
)
)
{
return
otel
:
:
sdk
:
:
common
:
:
ExportResult
:
:
kFailure
;
}
if
(
!
mIPCExporter
(
std
:
:
move
(
buffer
)
)
)
{
return
otel
:
:
sdk
:
:
common
:
:
ExportResult
:
:
kFailure
;
}
return
otel
:
:
sdk
:
:
common
:
:
ExportResult
:
:
kSuccess
;
}
bool
ForceFlush
(
std
:
:
chrono
:
:
microseconds
=
std
:
:
chrono
:
:
microseconds
:
:
max
(
)
)
noexcept
override
{
return
true
;
}
bool
Shutdown
(
std
:
:
chrono
:
:
microseconds
=
std
:
:
chrono
:
:
microseconds
:
:
max
(
)
)
noexcept
override
{
return
true
;
}
private
:
IPCExporter
mIPCExporter
;
}
;
class
LocalSpanProcessor
final
:
public
otel
:
:
sdk
:
:
trace
:
:
SpanProcessor
{
public
:
explicit
LocalSpanProcessor
(
std
:
:
unique_ptr
<
ProtobufExporter
>
exporter
)
:
mExporter
(
std
:
:
move
(
exporter
)
)
{
}
std
:
:
unique_ptr
<
otel
:
:
sdk
:
:
trace
:
:
Recordable
>
MakeRecordable
(
)
noexcept
override
{
return
mExporter
-
>
MakeRecordable
(
)
;
}
void
OnStart
(
otel
:
:
sdk
:
:
trace
:
:
Recordable
&
span
const
otel
:
:
trace
:
:
SpanContext
&
)
noexcept
override
{
MutexAutoLock
lock
{
mMutex
}
;
auto
&
otlpSpan
=
static_cast
<
otel
:
:
exporter
:
:
otlp
:
:
OtlpRecordable
&
>
(
span
)
;
const
nsCString
traceId
{
otlpSpan
.
span
(
)
.
trace_id
(
)
}
;
if
(
mShutDown
)
{
const
nsCString
spanId
{
otlpSpan
.
span
(
)
.
span_id
(
)
}
;
MOZ_LOG
(
gLog
LogLevel
:
:
Warning
(
"
[
%
s
%
s
]
"
"
LocalSpanProcessor
is
shutdown
dropping
span
"
ToHex
(
traceId
)
.
get
(
)
ToHex
(
spanId
)
.
get
(
)
)
)
;
return
;
}
auto
&
entry
=
mActiveTraces
.
LookupOrInsertWith
(
traceId
[
&
]
{
return
ActiveTrace
{
}
;
}
)
;
entry
.
activeSpans
+
+
;
}
void
OnEnd
(
std
:
:
unique_ptr
<
otel
:
:
sdk
:
:
trace
:
:
Recordable
>
&
&
span
)
noexcept
override
{
MutexAutoLock
lock
{
mMutex
}
;
std
:
:
unique_ptr
<
otel
:
:
exporter
:
:
otlp
:
:
OtlpRecordable
>
otlpSpan
{
static_cast
<
otel
:
:
exporter
:
:
otlp
:
:
OtlpRecordable
*
>
(
span
.
release
(
)
)
}
;
MOZ_ASSERT
(
otlpSpan
)
;
const
nsCString
traceId
{
otlpSpan
-
>
span
(
)
.
trace_id
(
)
}
;
if
(
mShutDown
)
{
const
nsCString
spanId
{
otlpSpan
-
>
span
(
)
.
span_id
(
)
}
;
MOZ_LOG
(
gLog
LogLevel
:
:
Warning
(
"
[
%
s
%
s
]
"
"
LocalSpanProcessor
is
shutdown
dropping
span
"
ToHex
(
traceId
)
.
get
(
)
ToHex
(
spanId
)
.
get
(
)
)
)
;
return
;
}
auto
entry
=
mActiveTraces
.
Lookup
(
traceId
)
;
if
(
!
entry
)
{
return
;
}
MOZ_ASSERT
(
entry
-
>
activeSpans
>
0
)
;
entry
-
>
activeSpans
-
-
;
entry
-
>
numberOfEvents
+
=
otlpSpan
-
>
span
(
)
.
events_size
(
)
;
entry
-
>
endedSpans
.
AppendElement
(
std
:
:
move
(
otlpSpan
)
)
;
if
(
entry
-
>
activeSpans
=
=
0
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
Ended
trace
with
trace
ID
:
%
s
"
ToHex
(
traceId
)
.
get
(
)
)
)
;
if
(
entry
-
>
numberOfEvents
>
0
)
{
mExporter
-
>
Export
(
otel
:
:
nostd
:
:
span
(
entry
-
>
endedSpans
.
Elements
(
)
entry
-
>
endedSpans
.
Length
(
)
)
)
;
}
else
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
Trace
ID
:
%
s
contained
no
events
dropping
"
ToHex
(
traceId
)
.
get
(
)
)
)
;
}
mActiveTraces
.
Remove
(
traceId
)
;
}
}
bool
ForceFlush
(
std
:
:
chrono
:
:
microseconds
timeout
=
std
:
:
chrono
:
:
microseconds
:
:
max
(
)
)
noexcept
override
{
return
mExporter
-
>
ForceFlush
(
timeout
)
;
}
bool
Shutdown
(
std
:
:
chrono
:
:
microseconds
=
std
:
:
chrono
:
:
microseconds
:
:
max
(
)
)
noexcept
override
{
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownNetTeardown
)
)
{
return
true
;
}
MutexAutoLock
lock
{
mMutex
}
;
if
(
mShutDown
)
{
return
true
;
}
mShutDown
=
true
;
for
(
auto
iter
=
mActiveTraces
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
&
endedSpans
=
iter
.
Data
(
)
.
endedSpans
;
mExporter
-
>
Export
(
otel
:
:
nostd
:
:
span
(
endedSpans
.
Elements
(
)
endedSpans
.
Length
(
)
)
)
;
iter
.
Remove
(
)
;
}
return
mExporter
-
>
Shutdown
(
)
;
}
private
:
struct
ActiveTrace
{
nsTArray
<
std
:
:
unique_ptr
<
otel
:
:
sdk
:
:
trace
:
:
Recordable
>
>
endedSpans
;
uint32_t
activeSpans
=
0
;
uint32_t
numberOfEvents
=
0
;
}
;
Mutex
mMutex
{
"
LocalSpanProcessor
:
:
mMutex
"
}
;
bool
mShutDown
MOZ_GUARDED_BY
(
mMutex
)
{
false
}
;
nsTHashMap
<
nsCString
ActiveTrace
>
mActiveTraces
MOZ_GUARDED_BY
(
mMutex
)
;
const
std
:
:
unique_ptr
<
otel
:
:
sdk
:
:
trace
:
:
SpanExporter
>
mExporter
;
}
;
}
#
endif
