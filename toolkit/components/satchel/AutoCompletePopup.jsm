"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AutoCompletePopup
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
AutoCompleteResultView
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAutoCompleteController
Ci
.
nsIAutoCompleteInput
]
)
results
:
[
]
get
matchCount
(
)
{
return
this
.
results
.
length
;
}
getValueAt
(
index
)
{
return
this
.
results
[
index
]
.
value
;
}
getFinalCompleteValueAt
(
index
)
{
return
this
.
results
[
index
]
.
value
;
}
getLabelAt
(
index
)
{
return
this
.
results
[
index
]
.
comment
;
}
getCommentAt
(
index
)
{
return
this
.
results
[
index
]
.
label
;
}
getStyleAt
(
index
)
{
return
this
.
results
[
index
]
.
style
;
}
getImageAt
(
index
)
{
return
this
.
results
[
index
]
.
image
;
}
handleEnter
(
aIsPopupSelection
)
{
AutoCompletePopup
.
handleEnter
(
aIsPopupSelection
)
;
}
stopSearch
(
)
{
}
searchString
:
"
"
get
controller
(
)
{
return
this
;
}
get
popup
(
)
{
return
null
;
}
_focus
(
)
{
AutoCompletePopup
.
requestFocus
(
)
;
}
clearResults
(
)
{
this
.
results
=
[
]
;
}
setResults
(
results
)
{
this
.
results
=
results
;
}
}
;
this
.
AutoCompletePopup
=
{
MESSAGES
:
[
"
FormAutoComplete
:
SelectBy
"
"
FormAutoComplete
:
GetSelectedIndex
"
"
FormAutoComplete
:
SetSelectedIndex
"
"
FormAutoComplete
:
MaybeOpenPopup
"
"
FormAutoComplete
:
ClosePopup
"
"
FormAutoComplete
:
Disconnect
"
"
FormAutoComplete
:
RemoveEntry
"
"
FormAutoComplete
:
Invalidate
"
]
init
(
)
{
for
(
let
msg
of
this
.
MESSAGES
)
{
Services
.
mm
.
addMessageListener
(
msg
this
)
;
}
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
disconnect
"
)
;
}
uninit
(
)
{
for
(
let
msg
of
this
.
MESSAGES
)
{
Services
.
mm
.
removeMessageListener
(
msg
this
)
;
}
Services
.
obs
.
removeObserver
(
this
"
message
-
manager
-
disconnect
"
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
message
-
manager
-
disconnect
"
:
{
if
(
this
.
openedPopup
)
{
this
.
openedPopup
.
closePopup
(
)
;
}
break
;
}
}
}
handleEvent
(
evt
)
{
switch
(
evt
.
type
)
{
case
"
popupshowing
"
:
{
this
.
sendMessageToBrowser
(
"
FormAutoComplete
:
PopupOpened
"
)
;
break
;
}
case
"
popuphidden
"
:
{
let
selectedIndex
=
this
.
openedPopup
.
selectedIndex
;
let
selectedRowStyle
=
selectedIndex
!
=
-
1
?
AutoCompleteResultView
.
getStyleAt
(
selectedIndex
)
:
"
"
;
this
.
sendMessageToBrowser
(
"
FormAutoComplete
:
PopupClosed
"
{
selectedRowStyle
}
)
;
AutoCompleteResultView
.
clearResults
(
)
;
this
.
openedPopup
.
adjustHeight
(
)
;
this
.
openedPopup
=
null
;
this
.
weakBrowser
=
null
;
evt
.
target
.
removeEventListener
(
"
popuphidden
"
this
)
;
evt
.
target
.
removeEventListener
(
"
popupshowing
"
this
)
;
break
;
}
}
}
showPopupWithResults
(
{
browser
rect
dir
results
}
)
{
if
(
!
results
.
length
|
|
this
.
openedPopup
)
{
return
;
}
let
window
=
browser
.
ownerGlobal
;
if
(
Services
.
focus
.
activeWindow
!
=
=
window
.
top
&
&
Services
.
focus
.
focusedWindow
.
top
!
=
=
window
.
top
)
{
return
;
}
let
resultStyles
=
new
Set
(
results
.
map
(
r
=
>
r
.
style
)
.
filter
(
r
=
>
!
!
r
)
)
;
this
.
weakBrowser
=
Cu
.
getWeakReference
(
browser
)
;
this
.
openedPopup
=
browser
.
autoCompletePopup
;
this
.
openedPopup
.
setAttribute
(
"
resultstyles
"
[
.
.
.
resultStyles
]
.
join
(
"
"
)
)
;
this
.
openedPopup
.
hidden
=
false
;
this
.
openedPopup
.
setAttribute
(
"
width
"
Math
.
max
(
100
rect
.
width
)
)
;
this
.
openedPopup
.
style
.
direction
=
dir
;
AutoCompleteResultView
.
setResults
(
results
)
;
this
.
openedPopup
.
view
=
AutoCompleteResultView
;
this
.
openedPopup
.
selectedIndex
=
-
1
;
if
(
results
.
length
)
{
this
.
openedPopup
.
mInput
=
AutoCompleteResultView
;
if
(
resultStyles
.
size
&
&
(
resultStyles
.
has
(
"
autofill
-
profile
"
)
|
|
resultStyles
.
has
(
"
loginsFooter
"
)
)
)
{
this
.
openedPopup
.
_normalMaxRows
=
this
.
openedPopup
.
maxRows
;
this
.
openedPopup
.
mInput
.
maxRows
=
100
;
}
this
.
openedPopup
.
addEventListener
(
"
popuphidden
"
this
)
;
this
.
openedPopup
.
addEventListener
(
"
popupshowing
"
this
)
;
this
.
openedPopup
.
openPopupAtScreenRect
(
"
after_start
"
rect
.
left
rect
.
top
rect
.
width
rect
.
height
false
false
)
;
this
.
openedPopup
.
invalidate
(
)
;
}
else
{
this
.
closePopup
(
)
;
}
}
invalidate
(
results
)
{
if
(
!
this
.
openedPopup
)
{
return
;
}
if
(
!
results
.
length
)
{
this
.
closePopup
(
)
;
}
else
{
AutoCompleteResultView
.
setResults
(
results
)
;
this
.
openedPopup
.
invalidate
(
)
;
}
}
closePopup
(
)
{
if
(
this
.
openedPopup
)
{
this
.
openedPopup
.
hidePopup
(
)
;
}
}
removeLogin
(
login
)
{
Services
.
logins
.
removeLogin
(
login
)
;
}
receiveMessage
(
message
)
{
if
(
!
message
.
target
.
autoCompletePopup
)
{
return
false
;
}
switch
(
message
.
name
)
{
case
"
FormAutoComplete
:
SelectBy
"
:
{
if
(
this
.
openedPopup
)
{
this
.
openedPopup
.
selectBy
(
message
.
data
.
reverse
message
.
data
.
page
)
;
}
break
;
}
case
"
FormAutoComplete
:
GetSelectedIndex
"
:
{
if
(
this
.
openedPopup
)
{
return
this
.
openedPopup
.
selectedIndex
;
}
return
-
1
;
}
case
"
FormAutoComplete
:
SetSelectedIndex
"
:
{
let
{
index
}
=
message
.
data
;
if
(
this
.
openedPopup
)
{
this
.
openedPopup
.
selectedIndex
=
index
;
}
break
;
}
case
"
FormAutoComplete
:
MaybeOpenPopup
"
:
{
let
{
results
rect
dir
}
=
message
.
data
;
this
.
showPopupWithResults
(
{
browser
:
message
.
target
rect
dir
results
}
)
;
break
;
}
case
"
FormAutoComplete
:
Invalidate
"
:
{
let
{
results
}
=
message
.
data
;
this
.
invalidate
(
results
)
;
break
;
}
case
"
FormAutoComplete
:
ClosePopup
"
:
{
this
.
closePopup
(
)
;
break
;
}
case
"
FormAutoComplete
:
Disconnect
"
:
{
AutoCompleteResultView
.
clearResults
(
)
;
break
;
}
}
return
false
;
}
handleEnter
(
aIsPopupSelection
)
{
if
(
this
.
openedPopup
)
{
this
.
sendMessageToBrowser
(
"
FormAutoComplete
:
HandleEnter
"
{
selectedIndex
:
this
.
openedPopup
.
selectedIndex
isPopupSelection
:
aIsPopupSelection
}
)
;
}
}
sendMessageToBrowser
(
msgName
data
)
{
let
browser
=
this
.
weakBrowser
?
this
.
weakBrowser
.
get
(
)
:
null
;
if
(
!
browser
)
{
return
;
}
if
(
browser
.
messageManager
)
{
browser
.
messageManager
.
sendAsyncMessage
(
msgName
data
)
;
}
else
{
Cu
.
reportError
(
AutoCompletePopup
:
No
messageManager
for
message
"
{
msgName
}
"
)
;
}
}
stopSearch
(
)
{
}
requestFocus
(
)
{
if
(
this
.
openedPopup
)
{
this
.
sendMessageToBrowser
(
"
FormAutoComplete
:
Focus
"
)
;
}
}
}
;
