"
use
strict
"
;
const
linePrototype
=
{
record
:
{
writable
:
true
}
}
;
function
getExpectedLinesAndStats
(
lines
searchText
)
{
const
collator
=
new
Intl
.
Collator
(
)
;
const
expectedMatchingLines
=
lines
.
filter
(
line
=
>
{
const
matchFn
=
loginMatch
(
searchText
)
;
return
matchFn
(
line
.
record
)
;
}
)
.
sort
(
(
a
b
)
=
>
collator
.
compare
(
a
.
id
b
.
id
)
)
;
const
expectedStats
=
{
total
:
lines
.
length
/
3
count
:
expectedMatchingLines
.
length
/
3
}
;
return
{
expectedMatchingLines
expectedStats
}
;
}
function
getActualLinesAndStats
(
dataSourceBase
searchText
)
{
const
actualStats
=
{
total
:
0
count
:
0
}
;
const
actualMatchingLines
=
Array
.
from
(
dataSourceBase
.
enumerateLinesForMatchingRecords
(
searchText
actualStats
loginMatch
(
searchText
.
toUpperCase
(
)
)
)
)
;
return
{
actualMatchingLines
actualStats
}
;
}
add_task
(
function
test_enumerateLinesWithSearchText
(
)
{
const
dataSourceBase
=
new
DataSourceBase
(
{
refreshSingleLineOnScreen
:
(
)
=
>
{
}
refreshAllLinesOnScreen
:
(
)
=
>
{
}
setLayout
:
(
)
=
>
{
}
}
)
;
const
lines
=
addLinesToDataSource
(
dataSourceBase
linePrototype
)
;
for
(
const
searchText
of
[
"
"
"
EXAMPLE
.
COM
"
]
)
{
const
{
expectedMatchingLines
expectedStats
}
=
getExpectedLinesAndStats
(
lines
searchText
)
;
const
{
actualMatchingLines
actualStats
}
=
getActualLinesAndStats
(
dataSourceBase
searchText
)
;
Assert
.
equal
(
expectedStats
.
total
actualStats
.
total
"
DataSourceBase
searched
through
all
lines
"
)
;
Assert
.
equal
(
expectedStats
.
count
actualStats
.
count
"
DataSourceBase
counted
correct
number
of
matching
lines
"
)
;
for
(
let
i
=
0
;
i
<
expectedMatchingLines
;
i
+
+
)
{
Assert
.
equal
(
expectedMatchingLines
[
i
]
.
id
actualMatchingLines
.
lines
[
i
]
.
id
DataSourceBase
correctly
matched
line
{
actualMatchingLines
.
lines
[
i
]
.
id
}
with
the
search
text
'
{
searchText
}
'
)
;
}
}
}
)
;
