const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormHistory
"
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
)
;
function
FormHistoryStartup
(
)
{
}
FormHistoryStartup
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
3A0012EB
-
007F
-
4BB8
-
AA81
-
A07385F77A25
}
"
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
Ci
.
nsIFrameMessageListener
]
)
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
nsPref
:
changed
"
:
FormHistory
.
updatePrefs
(
)
;
break
;
case
"
idle
-
daily
"
:
case
"
formhistory
-
expire
-
now
"
:
FormHistory
.
expireOldEntries
(
)
;
break
;
case
"
profile
-
before
-
change
"
:
FormHistory
.
shutdown
(
)
;
break
;
case
"
profile
-
after
-
change
"
:
this
.
init
(
)
;
default
:
break
;
}
}
inited
:
false
pendingQuery
:
null
init
(
)
{
if
(
this
.
inited
)
return
;
this
.
inited
=
true
;
Services
.
prefs
.
addObserver
(
"
browser
.
formfill
.
"
this
true
)
;
Services
.
obs
.
addObserver
(
this
"
profile
-
before
-
change
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
formhistory
-
expire
-
now
"
true
)
;
let
messageManager
=
Cc
[
"
mozilla
.
org
/
globalmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsIMessageListenerManager
)
;
messageManager
.
loadFrameScript
(
"
chrome
:
/
/
satchel
/
content
/
formSubmitListener
.
js
"
true
)
;
messageManager
.
addMessageListener
(
"
FormHistory
:
FormSubmitEntries
"
this
)
;
for
(
let
manager
of
[
messageManager
Services
.
ppmm
]
)
{
manager
.
addMessageListener
(
"
FormHistory
:
AutoCompleteSearchAsync
"
this
)
;
manager
.
addMessageListener
(
"
FormHistory
:
RemoveEntry
"
this
)
;
}
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
FormHistory
:
FormSubmitEntries
"
:
{
let
entries
=
message
.
data
;
let
changes
=
entries
.
map
(
function
(
entry
)
{
return
{
op
:
"
bump
"
fieldname
:
entry
.
name
value
:
entry
.
value
}
}
)
;
FormHistory
.
update
(
changes
)
;
break
;
}
case
"
FormHistory
:
AutoCompleteSearchAsync
"
:
{
let
{
id
searchString
params
}
=
message
.
data
;
if
(
this
.
pendingQuery
)
{
this
.
pendingQuery
.
cancel
(
)
;
this
.
pendingQuery
=
null
;
}
let
mm
;
if
(
message
.
target
instanceof
Ci
.
nsIMessageListenerManager
)
{
mm
=
message
.
target
;
}
else
{
mm
=
message
.
target
.
messageManager
;
}
let
results
=
[
]
;
let
processResults
=
{
handleResult
:
aResult
=
>
{
results
.
push
(
aResult
)
;
}
handleCompletion
:
aReason
=
>
{
if
(
query
=
=
this
.
pendingQuery
)
{
this
.
pendingQuery
=
null
;
if
(
!
aReason
)
{
mm
.
sendAsyncMessage
(
"
FormHistory
:
AutoCompleteSearchResults
"
{
id
results
}
)
;
}
}
}
}
;
let
query
=
FormHistory
.
getAutoCompleteResults
(
searchString
params
processResults
)
;
this
.
pendingQuery
=
query
;
break
;
}
case
"
FormHistory
:
RemoveEntry
"
:
{
let
{
inputName
value
}
=
message
.
data
;
FormHistory
.
update
(
{
op
:
"
remove
"
fieldname
:
inputName
value
}
)
;
break
;
}
}
}
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
FormHistoryStartup
]
)
;
