var
testnum
=
0
;
var
dbConnection
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
function
countDeletedEntries
(
expected
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
stmt
=
dbConnection
.
createAsyncStatement
(
"
SELECT
COUNT
(
*
)
AS
numEntries
FROM
moz_deleted_formhistory
"
)
;
stmt
.
executeAsync
(
{
handleResult
(
resultSet
)
{
do_check_eq
(
expected
resultSet
.
getNextRow
(
)
.
getResultByName
(
"
numEntries
"
)
)
;
resolve
(
)
;
}
handleError
(
error
)
{
do_throw
(
"
Error
occurred
counting
deleted
entries
:
"
+
error
)
;
reject
(
)
;
}
handleCompletion
(
)
{
stmt
.
finalize
(
)
;
}
}
)
;
}
)
;
}
function
checkTimeDeleted
(
guid
checkFunction
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
stmt
=
dbConnection
.
createAsyncStatement
(
"
SELECT
timeDeleted
FROM
moz_deleted_formhistory
WHERE
guid
=
:
guid
"
)
;
stmt
.
params
.
guid
=
guid
;
stmt
.
executeAsync
(
{
handleResult
(
resultSet
)
{
checkFunction
(
resultSet
.
getNextRow
(
)
.
getResultByName
(
"
timeDeleted
"
)
)
;
resolve
(
)
;
}
handleError
(
error
)
{
do_throw
(
"
Error
occurred
getting
deleted
entries
:
"
+
error
)
;
reject
(
)
;
}
handleCompletion
(
)
{
stmt
.
finalize
(
)
;
}
}
)
;
}
)
;
}
function
promiseUpdateEntry
(
op
name
value
)
{
var
change
=
{
op
}
;
if
(
name
!
=
=
null
)
{
change
.
fieldname
=
name
;
}
if
(
value
!
=
=
null
)
{
change
.
value
=
value
;
}
return
promiseUpdate
(
change
)
;
}
function
promiseUpdate
(
change
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
FormHistory
.
update
(
change
{
handleError
(
error
)
{
this
.
_error
=
error
;
}
handleCompletion
(
reason
)
{
if
(
reason
)
{
reject
(
this
.
_error
)
;
}
else
{
resolve
(
)
;
}
}
}
)
;
}
)
;
}
function
promiseSearchEntries
(
terms
params
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
results
=
[
]
;
FormHistory
.
search
(
terms
params
{
handleResult
:
result
=
>
results
.
push
(
result
)
handleError
(
error
)
{
do_throw
(
"
Error
occurred
searching
form
history
:
"
+
error
)
;
reject
(
error
)
;
}
handleCompletion
(
reason
)
{
if
(
!
reason
)
{
resolve
(
results
)
;
}
}
}
)
;
}
)
;
}
function
promiseCountEntries
(
name
value
checkFn
)
{
return
new
Promise
(
resolve
=
>
{
countEntries
(
name
value
function
(
result
)
{
checkFn
(
result
)
;
resolve
(
)
;
}
)
;
}
)
;
}
add_task
(
async
function
(
)
{
let
oldSupportsDeletedTable
=
FormHistory
.
_supportsDeletedTable
;
FormHistory
.
_supportsDeletedTable
=
true
;
try
{
var
testfile
=
do_get_file
(
"
formhistory_apitest
.
sqlite
"
)
;
var
profileDir
=
dirSvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
var
destFile
=
profileDir
.
clone
(
)
;
destFile
.
append
(
"
formhistory
.
sqlite
"
)
;
if
(
destFile
.
exists
(
)
)
{
destFile
.
remove
(
false
)
;
}
testfile
.
copyTo
(
profileDir
"
formhistory
.
sqlite
"
)
;
function
checkExists
(
num
)
{
do_check_true
(
num
>
0
)
;
}
function
checkNotExists
(
num
)
{
do_check_true
(
num
=
=
0
)
;
}
testnum
+
+
;
await
promiseCountEntries
(
"
name
-
A
"
null
checkExists
)
;
await
promiseCountEntries
(
"
name
-
B
"
null
checkExists
)
;
await
promiseCountEntries
(
"
name
-
C
"
null
checkExists
)
;
await
promiseCountEntries
(
"
name
-
D
"
null
checkExists
)
;
await
promiseCountEntries
(
"
name
-
A
"
"
value
-
A
"
checkExists
)
;
await
promiseCountEntries
(
"
name
-
B
"
"
value
-
B1
"
checkExists
)
;
await
promiseCountEntries
(
"
name
-
B
"
"
value
-
B2
"
checkExists
)
;
await
promiseCountEntries
(
"
name
-
C
"
"
value
-
C
"
checkExists
)
;
await
promiseCountEntries
(
"
name
-
D
"
"
value
-
D
"
checkExists
)
;
let
dbFile
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
.
clone
(
)
;
dbFile
.
append
(
"
formhistory
.
sqlite
"
)
;
dbConnection
=
Services
.
storage
.
openUnsharedDatabase
(
dbFile
)
;
let
deferred
=
Promise
.
defer
(
)
;
let
stmt
=
dbConnection
.
createAsyncStatement
(
"
DELETE
FROM
moz_deleted_formhistory
"
)
;
stmt
.
executeAsync
(
{
handleResult
(
resultSet
)
{
}
handleError
(
error
)
{
do_throw
(
"
Error
occurred
counting
deleted
all
entries
:
"
+
error
)
;
}
handleCompletion
(
)
{
stmt
.
finalize
(
)
;
deferred
.
resolve
(
)
;
}
}
)
;
await
deferred
.
promise
;
testnum
+
+
;
await
promiseCountEntries
(
"
blah
"
null
checkNotExists
)
;
await
promiseCountEntries
(
"
"
null
checkNotExists
)
;
await
promiseCountEntries
(
"
name
-
A
"
"
blah
"
checkNotExists
)
;
await
promiseCountEntries
(
"
name
-
A
"
"
"
checkNotExists
)
;
await
promiseCountEntries
(
"
name
-
A
"
null
checkExists
)
;
await
promiseCountEntries
(
"
blah
"
"
value
-
A
"
checkNotExists
)
;
await
promiseCountEntries
(
"
"
"
value
-
A
"
checkNotExists
)
;
await
promiseCountEntries
(
null
"
value
-
A
"
checkExists
)
;
deferred
=
Promise
.
defer
(
)
;
await
FormHistory
.
count
(
{
fieldname
:
null
value
:
null
}
{
handleResult
:
result
=
>
checkNotExists
(
result
)
handleError
(
error
)
{
do_throw
(
"
Error
occurred
searching
form
history
:
"
+
error
)
;
}
handleCompletion
(
reason
)
{
if
(
!
reason
)
{
deferred
.
resolve
(
)
}
}
}
)
;
await
deferred
.
promise
;
testnum
+
+
;
await
promiseUpdateEntry
(
"
remove
"
"
name
-
A
"
null
)
;
await
promiseCountEntries
(
"
name
-
A
"
"
value
-
A
"
checkNotExists
)
;
await
promiseCountEntries
(
"
name
-
B
"
"
value
-
B1
"
checkExists
)
;
await
promiseCountEntries
(
"
name
-
B
"
"
value
-
B2
"
checkExists
)
;
await
promiseCountEntries
(
"
name
-
C
"
"
value
-
C
"
checkExists
)
;
await
promiseCountEntries
(
"
name
-
D
"
"
value
-
D
"
checkExists
)
;
await
countDeletedEntries
(
1
)
;
testnum
+
+
;
await
promiseUpdateEntry
(
"
remove
"
"
name
-
B
"
null
)
;
await
promiseCountEntries
(
"
name
-
A
"
"
value
-
A
"
checkNotExists
)
;
await
promiseCountEntries
(
"
name
-
B
"
"
value
-
B1
"
checkNotExists
)
;
await
promiseCountEntries
(
"
name
-
B
"
"
value
-
B2
"
checkNotExists
)
;
await
promiseCountEntries
(
"
name
-
C
"
"
value
-
C
"
checkExists
)
;
await
promiseCountEntries
(
"
name
-
D
"
"
value
-
D
"
checkExists
)
;
await
countDeletedEntries
(
3
)
;
testnum
+
+
;
await
promiseCountEntries
(
"
time
-
A
"
null
checkExists
)
;
await
promiseCountEntries
(
"
time
-
B
"
null
checkExists
)
;
await
promiseCountEntries
(
"
time
-
C
"
null
checkExists
)
;
await
promiseCountEntries
(
"
time
-
D
"
null
checkExists
)
;
await
promiseUpdate
(
{
op
:
"
remove
"
firstUsedStart
:
1050
firstUsedEnd
:
2000
}
)
;
await
promiseCountEntries
(
"
time
-
A
"
null
checkExists
)
;
await
promiseCountEntries
(
"
time
-
B
"
null
checkExists
)
;
await
promiseCountEntries
(
"
time
-
C
"
null
checkNotExists
)
;
await
promiseCountEntries
(
"
time
-
D
"
null
checkExists
)
;
await
countDeletedEntries
(
4
)
;
testnum
+
+
;
await
promiseUpdate
(
{
op
:
"
remove
"
firstUsedStart
:
1000
firstUsedEnd
:
2000
}
)
;
await
promiseCountEntries
(
"
time
-
A
"
null
checkNotExists
)
;
await
promiseCountEntries
(
"
time
-
B
"
null
checkNotExists
)
;
await
promiseCountEntries
(
"
time
-
C
"
null
checkNotExists
)
;
await
promiseCountEntries
(
"
time
-
D
"
null
checkExists
)
;
await
countDeletedEntries
(
6
)
;
testnum
+
+
;
await
promiseUpdateEntry
(
"
remove
"
null
null
)
;
await
promiseCountEntries
(
"
name
-
C
"
null
checkNotExists
)
;
await
promiseCountEntries
(
"
name
-
D
"
null
checkNotExists
)
;
await
promiseCountEntries
(
"
name
-
C
"
"
value
-
C
"
checkNotExists
)
;
await
promiseCountEntries
(
"
name
-
D
"
"
value
-
D
"
checkNotExists
)
;
await
promiseCountEntries
(
null
null
checkNotExists
)
;
await
countDeletedEntries
(
6
)
;
testnum
+
+
;
await
promiseUpdateEntry
(
"
add
"
"
newname
-
A
"
"
newvalue
-
A
"
)
;
await
promiseCountEntries
(
"
newname
-
A
"
"
newvalue
-
A
"
checkExists
)
;
testnum
+
+
;
await
promiseUpdateEntry
(
"
remove
"
"
newname
-
A
"
"
newvalue
-
A
"
)
;
await
promiseCountEntries
(
"
newname
-
A
"
"
newvalue
-
A
"
checkNotExists
)
;
testnum
+
+
;
await
promiseUpdateEntry
(
"
add
"
"
field1
"
"
value1
"
)
;
await
promiseCountEntries
(
"
field1
"
"
value1
"
checkExists
)
;
let
processFirstResult
=
function
processResults
(
results
)
{
if
(
results
.
length
>
0
)
{
let
result
=
results
[
0
]
;
return
[
result
.
timesUsed
result
.
firstUsed
result
.
lastUsed
result
.
guid
]
;
}
return
undefined
;
}
let
results
=
await
promiseSearchEntries
(
[
"
timesUsed
"
"
firstUsed
"
"
lastUsed
"
]
{
fieldname
:
"
field1
"
value
:
"
value1
"
}
)
;
let
[
timesUsed
firstUsed
lastUsed
]
=
processFirstResult
(
results
)
;
do_check_eq
(
1
timesUsed
)
;
do_check_true
(
firstUsed
>
0
)
;
do_check_true
(
lastUsed
>
0
)
;
await
promiseCountEntries
(
null
null
num
=
>
do_check_eq
(
num
1
)
)
;
testnum
+
+
;
await
promiseUpdateEntry
(
"
add
"
"
field1
"
"
value1b
"
)
;
await
promiseCountEntries
(
"
field1
"
"
value1
"
checkExists
)
;
await
promiseCountEntries
(
"
field1
"
"
value1b
"
checkExists
)
;
await
promiseCountEntries
(
null
null
num
=
>
do_check_eq
(
num
2
)
)
;
testnum
+
+
;
results
=
await
promiseSearchEntries
(
[
"
guid
"
]
{
fieldname
:
"
field1
"
value
:
"
value1
"
}
)
;
let
guid
=
processFirstResult
(
results
)
[
3
]
;
await
promiseUpdate
(
{
op
:
"
update
"
guid
value
:
"
modifiedValue
"
}
)
;
await
promiseCountEntries
(
"
field1
"
"
modifiedValue
"
checkExists
)
;
await
promiseCountEntries
(
"
field1
"
"
value1
"
checkNotExists
)
;
await
promiseCountEntries
(
"
field1
"
"
value1b
"
checkExists
)
;
await
promiseCountEntries
(
null
null
num
=
>
do_check_eq
(
num
2
)
)
;
testnum
+
+
;
await
promiseUpdate
(
{
op
:
"
add
"
fieldname
:
"
field2
"
value
:
"
value2
"
timesUsed
:
20
firstUsed
:
100
lastUsed
:
500
}
)
;
results
=
await
promiseSearchEntries
(
[
"
timesUsed
"
"
firstUsed
"
"
lastUsed
"
]
{
fieldname
:
"
field2
"
value
:
"
value2
"
}
)
;
[
timesUsed
firstUsed
lastUsed
]
=
processFirstResult
(
results
)
;
do_check_eq
(
20
timesUsed
)
;
do_check_eq
(
100
firstUsed
)
;
do_check_eq
(
500
lastUsed
)
;
await
promiseCountEntries
(
null
null
num
=
>
do_check_eq
(
num
3
)
)
;
testnum
+
+
;
await
promiseUpdate
(
{
op
:
"
bump
"
fieldname
:
"
field2
"
value
:
"
value2
"
timesUsed
:
20
firstUsed
:
100
lastUsed
:
500
}
)
;
results
=
await
promiseSearchEntries
(
[
"
timesUsed
"
"
firstUsed
"
"
lastUsed
"
]
{
fieldname
:
"
field2
"
value
:
"
value2
"
}
)
;
[
timesUsed
firstUsed
lastUsed
]
=
processFirstResult
(
results
)
;
do_check_eq
(
21
timesUsed
)
;
do_check_eq
(
100
firstUsed
)
;
do_check_true
(
lastUsed
>
500
)
;
await
promiseCountEntries
(
null
null
num
=
>
do_check_eq
(
num
3
)
)
;
testnum
+
+
;
await
promiseUpdate
(
{
op
:
"
bump
"
fieldname
:
"
field3
"
value
:
"
value3
"
timesUsed
:
10
firstUsed
:
50
lastUsed
:
400
}
)
;
results
=
await
promiseSearchEntries
(
[
"
timesUsed
"
"
firstUsed
"
"
lastUsed
"
]
{
fieldname
:
"
field3
"
value
:
"
value3
"
}
)
;
[
timesUsed
firstUsed
lastUsed
]
=
processFirstResult
(
results
)
;
do_check_eq
(
10
timesUsed
)
;
do_check_eq
(
50
firstUsed
)
;
do_check_eq
(
400
lastUsed
)
;
await
promiseCountEntries
(
null
null
num
=
>
do_check_eq
(
num
4
)
)
;
testnum
+
+
;
results
=
await
promiseSearchEntries
(
[
"
guid
"
]
{
fieldname
:
"
field3
"
value
:
"
value3
"
}
)
;
guid
=
processFirstResult
(
results
)
[
3
]
;
await
promiseUpdate
(
{
op
:
"
bump
"
guid
timesUsed
:
20
firstUsed
:
55
lastUsed
:
400
}
)
;
results
=
await
promiseSearchEntries
(
[
"
timesUsed
"
"
firstUsed
"
"
lastUsed
"
]
{
fieldname
:
"
field3
"
value
:
"
value3
"
}
)
;
[
timesUsed
firstUsed
lastUsed
]
=
processFirstResult
(
results
)
;
do_check_eq
(
11
timesUsed
)
;
do_check_eq
(
50
firstUsed
)
;
do_check_true
(
lastUsed
>
400
)
;
await
promiseCountEntries
(
null
null
num
=
>
do_check_eq
(
num
4
)
)
;
testnum
+
+
;
await
countDeletedEntries
(
7
)
;
results
=
await
promiseSearchEntries
(
[
"
guid
"
]
{
fieldname
:
"
field1
"
value
:
"
value1b
"
}
)
;
guid
=
processFirstResult
(
results
)
[
3
]
;
await
promiseUpdate
(
{
op
:
"
remove
"
guid
}
)
;
await
promiseCountEntries
(
"
field1
"
"
modifiedValue
"
checkExists
)
;
await
promiseCountEntries
(
"
field1
"
"
value1b
"
checkNotExists
)
;
await
promiseCountEntries
(
null
null
num
=
>
do_check_eq
(
num
3
)
)
;
await
countDeletedEntries
(
8
)
;
await
checkTimeDeleted
(
guid
timeDeleted
=
>
do_check_true
(
timeDeleted
>
10000
)
)
;
testnum
+
+
;
await
promiseUpdate
(
{
op
:
"
add
"
fieldname
:
"
field4
"
value
:
"
value4
"
timesUsed
:
5
firstUsed
:
230
lastUsed
:
600
}
)
;
await
promiseCountEntries
(
null
null
num
=
>
do_check_eq
(
num
4
)
)
;
testnum
+
+
;
await
promiseUpdate
(
{
op
:
"
remove
"
firstUsedStart
:
60
firstUsedEnd
:
250
}
)
;
await
promiseCountEntries
(
"
field1
"
"
modifiedValue
"
checkExists
)
;
await
promiseCountEntries
(
"
field2
"
"
value2
"
checkNotExists
)
;
await
promiseCountEntries
(
"
field3
"
"
value3
"
checkExists
)
;
await
promiseCountEntries
(
"
field4
"
"
value4
"
checkNotExists
)
;
await
promiseCountEntries
(
null
null
num
=
>
do_check_eq
(
num
2
)
)
;
await
countDeletedEntries
(
10
)
;
testnum
+
+
;
await
promiseUpdate
(
[
{
op
:
"
add
"
fieldname
:
"
field5
"
value
:
"
value5
"
timesUsed
:
5
firstUsed
:
230
lastUsed
:
600
}
{
op
:
"
add
"
fieldname
:
"
field6
"
value
:
"
value6
"
timesUsed
:
12
firstUsed
:
430
lastUsed
:
700
}
]
)
;
await
promiseCountEntries
(
null
null
num
=
>
do_check_eq
(
num
4
)
)
;
await
promiseUpdate
(
[
{
op
:
"
bump
"
fieldname
:
"
field5
"
value
:
"
value5
"
}
{
op
:
"
bump
"
fieldname
:
"
field6
"
value
:
"
value6
"
}
]
)
;
results
=
await
promiseSearchEntries
(
[
"
fieldname
"
"
timesUsed
"
"
firstUsed
"
"
lastUsed
"
]
{
}
)
;
do_check_eq
(
6
results
[
2
]
.
timesUsed
)
;
do_check_eq
(
13
results
[
3
]
.
timesUsed
)
;
do_check_eq
(
230
results
[
2
]
.
firstUsed
)
;
do_check_eq
(
430
results
[
3
]
.
firstUsed
)
;
do_check_true
(
results
[
2
]
.
lastUsed
>
600
)
;
do_check_true
(
results
[
3
]
.
lastUsed
>
700
)
;
await
promiseCountEntries
(
null
null
num
=
>
do_check_eq
(
num
4
)
)
;
testnum
+
+
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
formfill
.
enable
"
false
)
;
Assert
.
rejects
(
promiseUpdate
(
{
op
:
"
bump
"
fieldname
:
"
field5
"
value
:
"
value5
"
}
)
function
(
err
)
{
return
err
.
result
=
=
Ci
.
mozIStorageError
.
MISUSE
;
}
"
bumping
when
form
history
is
disabled
should
fail
"
)
;
Assert
.
rejects
(
promiseUpdate
(
{
op
:
"
add
"
fieldname
:
"
field5
"
value
:
"
value5
"
}
)
function
(
err
)
{
return
err
.
result
=
=
Ci
.
mozIStorageError
.
MISUSE
;
}
"
Adding
when
form
history
is
disabled
should
fail
"
)
;
Assert
.
rejects
(
promiseUpdate
(
[
{
op
:
"
update
"
fieldname
:
"
field5
"
value
:
"
value5
"
}
{
op
:
"
remove
"
fieldname
:
"
field5
"
value
:
"
value5
"
}
]
)
function
(
err
)
{
return
err
.
result
=
=
Ci
.
mozIStorageError
.
MISUSE
;
}
"
mixed
operations
when
form
history
is
disabled
should
fail
"
)
;
Assert
.
rejects
(
promiseUpdate
(
[
null
undefined
"
"
1
{
}
{
op
:
"
remove
"
fieldname
:
"
field5
"
value
:
"
value5
"
}
]
)
function
(
err
)
{
return
err
.
result
=
=
Ci
.
mozIStorageError
.
MISUSE
;
}
"
Invalid
entries
when
form
history
is
disabled
should
fail
"
)
;
await
promiseUpdate
(
[
{
op
:
"
remove
"
fieldname
:
"
field5
"
value
:
null
}
{
op
:
"
remove
"
fieldname
:
null
value
:
null
}
]
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
formfill
.
enable
"
)
;
}
catch
(
e
)
{
throw
"
FAILED
in
test
#
"
+
testnum
+
"
-
-
"
+
e
;
}
finally
{
FormHistory
.
_supportsDeletedTable
=
oldSupportsDeletedTable
;
dbConnection
.
asyncClose
(
do_test_finished
)
;
}
}
)
;
function
run_test
(
)
{
return
run_next_test
(
)
;
}
