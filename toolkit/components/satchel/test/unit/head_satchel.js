const
CURRENT_SCHEMA
=
5
;
const
PR_HOURS
=
60
*
60
*
1000000
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
FormHistory
:
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
FormHistoryTestUtils
:
"
resource
:
/
/
testing
-
common
/
FormHistoryTestUtils
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
}
)
;
do_get_profile
(
)
;
var
formHistoryStartup
=
Cc
[
"
mozilla
.
org
/
satchel
/
form
-
history
-
startup
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
;
formHistoryStartup
.
observe
(
null
"
profile
-
after
-
change
"
null
)
;
function
getDBVersion
(
dbfile
)
{
let
dbConnection
=
Services
.
storage
.
openDatabase
(
dbfile
)
;
let
version
=
dbConnection
.
schemaVersion
;
dbConnection
.
close
(
)
;
return
version
;
}
async
function
getDBSchemaVersion
(
path
)
{
let
db
=
await
Sqlite
.
openConnection
(
{
path
}
)
;
try
{
return
await
db
.
getSchemaVersion
(
)
;
}
finally
{
await
db
.
close
(
)
;
}
}
function
getFormHistoryDBVersion
(
)
{
let
profileDir
=
do_get_profile
(
)
;
let
dbFile
=
profileDir
.
clone
(
)
;
dbFile
.
append
(
"
formhistory
.
sqlite
"
)
;
return
getDBVersion
(
dbFile
)
;
}
const
isGUID
=
/
[
A
-
Za
-
z0
-
9
\
+
\
/
]
{
16
}
/
;
function
searchEntries
(
terms
params
iter
)
{
let
results
=
[
]
;
FormHistory
.
search
(
terms
params
{
handleResult
:
result
=
>
results
.
push
(
result
)
handleError
(
error
)
{
do_throw
(
"
Error
occurred
searching
form
history
:
"
+
error
)
;
}
handleCompletion
(
reason
)
{
if
(
!
reason
)
{
iter
.
next
(
results
)
;
}
}
}
)
;
}
function
countEntries
(
name
value
then
)
{
let
obj
=
{
}
;
if
(
name
!
=
=
null
)
{
obj
.
fieldname
=
name
;
}
if
(
value
!
=
=
null
)
{
obj
.
value
=
value
;
}
let
count
=
0
;
FormHistory
.
count
(
obj
{
handleResult
:
result
=
>
(
count
=
result
)
handleError
(
error
)
{
do_throw
(
"
Error
occurred
searching
form
history
:
"
+
error
)
;
}
handleCompletion
(
reason
)
{
if
(
!
reason
)
{
then
(
count
)
;
}
}
}
)
;
}
function
updateEntry
(
op
name
value
then
)
{
let
obj
=
{
op
}
;
if
(
name
!
=
=
null
)
{
obj
.
fieldname
=
name
;
}
if
(
value
!
=
=
null
)
{
obj
.
value
=
value
;
}
updateFormHistory
(
obj
then
)
;
}
function
addEntry
(
name
value
then
)
{
let
now
=
Date
.
now
(
)
*
1000
;
updateFormHistory
(
{
op
:
"
add
"
fieldname
:
name
value
timesUsed
:
1
firstUsed
:
now
lastUsed
:
now
}
then
)
;
}
function
promiseCountEntries
(
name
value
checkFn
=
(
)
=
>
{
}
)
{
return
new
Promise
(
resolve
=
>
{
countEntries
(
name
value
function
(
result
)
{
checkFn
(
result
)
;
resolve
(
result
)
;
}
)
;
}
)
;
}
function
promiseUpdateEntry
(
op
name
value
)
{
return
new
Promise
(
res
=
>
{
updateEntry
(
op
name
value
res
)
;
}
)
;
}
function
promiseAddEntry
(
name
value
)
{
return
new
Promise
(
res
=
>
{
addEntry
(
name
value
res
)
;
}
)
;
}
function
updateFormHistory
(
changes
then
)
{
FormHistory
.
update
(
changes
{
handleError
(
error
)
{
do_throw
(
"
Error
occurred
updating
form
history
:
"
+
error
)
;
}
handleCompletion
(
reason
)
{
if
(
!
reason
)
{
then
(
)
;
}
}
}
)
;
}
function
promiseUpdate
(
change
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
FormHistory
.
update
(
change
{
handleError
(
error
)
{
this
.
_error
=
error
;
}
handleCompletion
(
reason
)
{
if
(
reason
)
{
reject
(
this
.
_error
)
;
}
else
{
resolve
(
)
;
}
}
}
)
;
}
)
;
}
function
do_log_info
(
aMessage
)
{
print
(
"
TEST
-
INFO
|
"
+
_TEST_FILE
+
"
|
"
+
aMessage
)
;
}
async
function
copyToProfile
(
aFilename
aDestFilename
{
overwriteExisting
=
false
}
=
{
}
)
{
let
curDir
=
await
OS
.
File
.
getCurrentDirectory
(
)
;
let
srcPath
=
OS
.
Path
.
join
(
curDir
aFilename
)
;
Assert
.
ok
(
await
OS
.
File
.
exists
(
srcPath
)
"
Database
file
found
"
)
;
let
destPath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
aDestFilename
)
;
let
exists
=
await
OS
.
File
.
exists
(
destPath
)
;
if
(
exists
)
{
if
(
overwriteExisting
)
{
await
OS
.
file
.
remove
(
destPath
)
;
}
else
{
throw
new
Error
(
"
The
file
should
not
exist
"
)
;
}
}
await
OS
.
File
.
copy
(
srcPath
destPath
)
;
info
(
Copied
{
aFilename
}
to
{
destPath
}
)
;
return
destPath
;
}
