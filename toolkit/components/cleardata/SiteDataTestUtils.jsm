"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SiteDataTestUtils
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
BrowserTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
swm
"
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
"
nsIServiceWorkerManager
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
indexedDB
"
"
Blob
"
]
)
;
var
SiteDataTestUtils
=
{
persist
(
origin
value
=
Services
.
perms
.
ALLOW_ACTION
)
{
return
new
Promise
(
resolve
=
>
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
Services
.
perms
.
addFromPrincipal
(
principal
"
persistent
-
storage
"
value
)
;
Services
.
qms
.
persist
(
principal
)
.
callback
=
(
)
=
>
resolve
(
)
;
}
)
;
}
addToIndexedDB
(
origin
size
=
1024
)
{
return
new
Promise
(
resolve
=
>
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
let
request
=
indexedDB
.
openForPrincipal
(
principal
"
TestDatabase
"
1
)
;
request
.
onupgradeneeded
=
function
(
e
)
{
let
db
=
e
.
target
.
result
;
db
.
createObjectStore
(
"
TestStore
"
)
;
}
;
request
.
onsuccess
=
function
(
e
)
{
let
db
=
e
.
target
.
result
;
let
tx
=
db
.
transaction
(
"
TestStore
"
"
readwrite
"
)
;
let
store
=
tx
.
objectStore
(
"
TestStore
"
)
;
tx
.
oncomplete
=
resolve
;
let
buffer
=
new
ArrayBuffer
(
size
)
;
let
blob
=
new
Blob
(
[
buffer
]
)
;
store
.
add
(
blob
Cu
.
now
(
)
)
;
}
;
}
)
;
}
addToCookies
(
{
origin
host
path
=
"
path
"
originAttributes
=
{
}
name
=
"
foo
"
value
=
"
bar
"
}
)
{
if
(
origin
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
host
=
principal
.
host
;
path
=
principal
.
URI
.
pathQueryRef
;
originAttributes
=
Object
.
keys
(
originAttributes
)
.
length
?
originAttributes
:
principal
.
originAttributes
;
}
Services
.
cookies
.
add
(
host
path
name
value
false
false
false
Math
.
floor
(
Date
.
now
(
)
/
1000
)
+
24
*
60
*
60
originAttributes
Ci
.
nsICookie
.
SAMESITE_NONE
Ci
.
nsICookie
.
SCHEME_UNSET
)
;
}
addToLocalStorage
(
origin
key
=
"
foo
"
value
=
"
bar
"
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
let
storage
=
Services
.
domStorageManager
.
createStorage
(
null
principal
principal
"
"
)
;
storage
.
setItem
(
key
value
)
;
}
hasLocalStorage
(
origin
testEntries
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
let
storage
=
Services
.
domStorageManager
.
createStorage
(
null
principal
principal
"
"
)
;
if
(
!
storage
.
length
)
{
return
false
;
}
if
(
!
testEntries
)
{
return
true
;
}
return
(
storage
.
length
>
=
testEntries
.
length
&
&
testEntries
.
every
(
(
{
key
value
}
)
=
>
storage
.
getItem
(
key
)
=
=
value
)
)
;
}
addServiceWorker
(
path
)
{
let
uri
=
Services
.
io
.
newURI
(
path
)
;
return
BrowserTestUtils
.
withNewTab
(
uri
.
prePath
async
function
(
browser
)
{
return
browser
.
ownerGlobal
.
SpecialPowers
.
spawn
(
browser
[
{
path
}
]
async
(
{
path
:
p
}
)
=
>
{
let
r
=
await
content
.
navigator
.
serviceWorker
.
register
(
p
)
;
return
new
Promise
(
resolve
=
>
{
let
worker
=
r
.
installing
|
|
r
.
waiting
|
|
r
.
active
;
if
(
worker
.
state
=
=
"
activated
"
)
{
resolve
(
)
;
}
else
{
worker
.
addEventListener
(
"
statechange
"
(
)
=
>
{
if
(
worker
.
state
=
=
"
activated
"
)
{
resolve
(
)
;
}
}
)
;
}
}
)
;
}
)
;
}
)
;
}
hasCookies
(
origin
testEntries
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
let
filterFn
=
cookie
=
>
{
return
(
ChromeUtils
.
isOriginAttributesEqual
(
principal
.
originAttributes
cookie
.
originAttributes
)
&
&
cookie
.
host
.
includes
(
principal
.
host
)
)
;
}
;
if
(
!
testEntries
)
{
return
Services
.
cookies
.
cookies
.
some
(
filterFn
)
;
}
let
cookies
=
Services
.
cookies
.
cookies
.
filter
(
filterFn
)
;
if
(
cookies
.
length
<
testEntries
.
length
)
{
return
false
;
}
return
testEntries
.
every
(
(
{
key
value
}
)
=
>
cookies
.
some
(
cookie
=
>
cookie
.
name
=
=
key
&
&
cookie
.
value
=
=
value
)
)
;
}
hasIndexedDB
(
origin
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
return
new
Promise
(
resolve
=
>
{
let
data
=
true
;
let
request
=
indexedDB
.
openForPrincipal
(
principal
"
TestDatabase
"
1
)
;
request
.
onupgradeneeded
=
function
(
e
)
{
data
=
false
;
}
;
request
.
onsuccess
=
function
(
e
)
{
resolve
(
data
)
;
}
;
}
)
;
}
_getCacheStorage
(
where
lci
)
{
switch
(
where
)
{
case
"
disk
"
:
return
Services
.
cache2
.
diskCacheStorage
(
lci
)
;
case
"
memory
"
:
return
Services
.
cache2
.
memoryCacheStorage
(
lci
)
;
case
"
pin
"
:
return
Services
.
cache2
.
pinningCacheStorage
(
lci
)
;
}
return
null
;
}
hasCacheEntry
(
path
where
lci
=
Services
.
loadContextInfo
.
default
)
{
let
storage
=
this
.
_getCacheStorage
(
where
lci
)
;
return
storage
.
exists
(
Services
.
io
.
newURI
(
path
)
"
"
)
;
}
addCacheEntry
(
path
where
lci
=
Services
.
loadContextInfo
.
default
)
{
return
new
Promise
(
resolve
=
>
{
function
CacheListener
(
)
{
}
CacheListener
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsICacheEntryOpenCallback
"
]
)
onCacheEntryCheck
(
entry
)
{
return
Ci
.
nsICacheEntryOpenCallback
.
ENTRY_WANTED
;
}
onCacheEntryAvailable
(
entry
isnew
status
)
{
resolve
(
)
;
}
}
;
let
storage
=
this
.
_getCacheStorage
(
where
lci
)
;
storage
.
asyncOpenURI
(
Services
.
io
.
newURI
(
path
)
"
"
Ci
.
nsICacheStorage
.
OPEN_NORMALLY
new
CacheListener
(
)
)
;
}
)
;
}
hasServiceWorkers
(
origin
)
{
let
serviceWorkers
=
swm
.
getAllRegistrations
(
)
;
for
(
let
i
=
0
;
i
<
serviceWorkers
.
length
;
i
+
+
)
{
let
sw
=
serviceWorkers
.
queryElementAt
(
i
Ci
.
nsIServiceWorkerRegistrationInfo
)
;
if
(
sw
.
principal
.
origin
=
=
origin
)
{
return
true
;
}
}
return
false
;
}
promiseServiceWorkerRegistered
(
url
)
{
if
(
!
(
url
instanceof
Ci
.
nsIURI
)
)
{
url
=
Services
.
io
.
newURI
(
url
)
;
}
return
new
Promise
(
resolve
=
>
{
let
listener
=
{
onRegister
:
registration
=
>
{
if
(
registration
.
principal
.
host
!
=
url
.
host
)
{
return
;
}
swm
.
removeListener
(
listener
)
;
resolve
(
registration
)
;
}
}
;
swm
.
addListener
(
listener
)
;
}
)
;
}
promiseServiceWorkerUnregistered
(
url
)
{
if
(
!
(
url
instanceof
Ci
.
nsIURI
)
)
{
url
=
Services
.
io
.
newURI
(
url
)
;
}
return
new
Promise
(
resolve
=
>
{
let
listener
=
{
onUnregister
:
registration
=
>
{
if
(
registration
.
principal
.
host
!
=
url
.
host
)
{
return
;
}
swm
.
removeListener
(
listener
)
;
resolve
(
registration
)
;
}
}
;
swm
.
addListener
(
listener
)
;
}
)
;
}
getQuotaUsage
(
origin
)
{
return
new
Promise
(
resolve
=
>
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
Services
.
qms
.
getUsageForPrincipal
(
principal
request
=
>
resolve
(
request
.
result
.
usage
)
)
;
}
)
;
}
clear
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_COOKIES
|
Ci
.
nsIClearDataService
.
CLEAR_ALL_CACHES
|
Ci
.
nsIClearDataService
.
CLEAR_MEDIA_DEVICES
|
Ci
.
nsIClearDataService
.
CLEAR_DOM_STORAGES
|
Ci
.
nsIClearDataService
.
CLEAR_PREDICTOR_NETWORK_DATA
|
Ci
.
nsIClearDataService
.
CLEAR_SECURITY_SETTINGS
|
Ci
.
nsIClearDataService
.
CLEAR_EME
|
Ci
.
nsIClearDataService
.
CLEAR_STORAGE_ACCESS
resolve
)
;
}
)
;
}
}
;
