"
use
strict
"
;
const
{
SiteDataTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
SiteDataTestUtils
.
sys
.
mjs
"
)
;
const
uuidGenerator
=
Services
.
uuid
;
const
ORIGIN_A
=
"
https
:
/
/
example
.
net
"
;
const
ORIGIN_B
=
"
https
:
/
/
example
.
org
"
;
const
PREFLIGHT_URL_PATH
=
"
/
browser
/
toolkit
/
components
/
cleardata
/
tests
/
browser
/
file_cors_preflight
.
sjs
"
;
const
PREFLIGHT_URL_A
=
ORIGIN_A
+
PREFLIGHT_URL_PATH
;
const
PREFLIGHT_URL_B
=
ORIGIN_B
+
PREFLIGHT_URL_PATH
;
function
testPreflightCached
(
browser
url
token
isCached
)
{
return
SpecialPowers
.
spawn
(
browser
[
url
token
isCached
]
async
(
url
token
isCached
)
=
>
{
let
response
=
await
content
.
fetch
(
new
content
.
Request
(
{
url
}
?
token
=
{
token
}
{
mode
:
"
cors
"
method
:
"
GET
"
headers
:
[
[
"
x
-
test
-
header
"
"
check
"
]
]
}
)
)
;
let
expected
=
isCached
?
"
0
"
:
"
1
"
;
is
(
await
response
.
text
(
)
expected
Preflight
cache
for
{
url
}
{
isCached
?
"
HIT
"
:
"
MISS
"
}
.
)
;
}
)
;
}
async
function
testDeleteAll
(
clearDataFlag
{
deleteBy
=
"
all
"
hasUserInput
=
false
}
=
{
}
)
{
await
BrowserTestUtils
.
withNewTab
(
"
https
:
/
/
example
.
com
"
async
browser
=
>
{
let
token
=
uuidGenerator
.
generateUUID
(
)
.
toString
(
)
;
await
testPreflightCached
(
browser
PREFLIGHT_URL_A
token
false
)
;
await
testPreflightCached
(
browser
PREFLIGHT_URL_B
token
false
)
;
await
testPreflightCached
(
browser
PREFLIGHT_URL_A
token
true
)
;
await
testPreflightCached
(
browser
PREFLIGHT_URL_B
token
true
)
;
await
new
Promise
(
resolve
=
>
{
if
(
deleteBy
=
=
"
principal
"
)
{
Services
.
clearData
.
deleteDataFromPrincipal
(
browser
.
contentPrincipal
hasUserInput
clearDataFlag
value
=
>
{
Assert
.
equal
(
value
0
)
;
resolve
(
)
;
}
)
;
}
else
if
(
deleteBy
=
=
"
baseDomain
"
)
{
Services
.
clearData
.
deleteDataFromBaseDomain
(
browser
.
contentPrincipal
.
baseDomain
hasUserInput
clearDataFlag
value
=
>
{
Assert
.
equal
(
value
0
)
;
resolve
(
)
;
}
)
;
}
else
{
Services
.
clearData
.
deleteData
(
clearDataFlag
value
=
>
{
Assert
.
equal
(
value
0
)
;
resolve
(
)
;
}
)
;
}
}
)
;
let
clearedAll
=
deleteBy
=
=
"
all
"
|
|
hasUserInput
;
await
testPreflightCached
(
browser
PREFLIGHT_URL_A
token
!
clearedAll
)
;
await
testPreflightCached
(
browser
PREFLIGHT_URL_B
token
!
clearedAll
)
;
}
)
;
SiteDataTestUtils
.
clear
(
)
;
}
add_task
(
async
function
test_deleteAll
(
)
{
let
{
CLEAR_ALL
CLEAR_ALL_CACHES
CLEAR_PREFLIGHT_CACHE
}
=
Ci
.
nsIClearDataService
;
for
(
let
flag
of
[
CLEAR_ALL
CLEAR_ALL_CACHES
CLEAR_PREFLIGHT_CACHE
]
)
{
await
testDeleteAll
(
flag
)
;
}
}
)
;
add_task
(
async
function
test_deleteByPrincipal
(
)
{
let
{
CLEAR_ALL
CLEAR_ALL_CACHES
CLEAR_PREFLIGHT_CACHE
}
=
Ci
.
nsIClearDataService
;
for
(
let
flag
of
[
CLEAR_ALL
CLEAR_ALL_CACHES
CLEAR_PREFLIGHT_CACHE
]
)
{
for
(
let
hasUserInput
of
[
true
false
]
)
{
await
testDeleteAll
(
flag
{
deleteBy
:
"
principal
"
hasUserInput
}
)
;
}
}
}
)
;
add_task
(
async
function
test_deletePrivateBrowsingCache
(
)
{
async
function
deletePrivateBrowsingCache
(
token
)
{
const
browser
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
;
const
tab
=
(
browser
.
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
browser
.
gBrowser
"
https
:
/
/
example
.
com
"
)
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
await
testPreflightCached
(
tab
.
linkedBrowser
PREFLIGHT_URL_A
token
false
)
;
await
testPreflightCached
(
tab
.
linkedBrowser
PREFLIGHT_URL_B
token
false
)
;
await
testPreflightCached
(
tab
.
linkedBrowser
PREFLIGHT_URL_A
token
true
)
;
await
testPreflightCached
(
tab
.
linkedBrowser
PREFLIGHT_URL_B
token
true
)
;
await
browser
.
close
(
)
;
}
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
security
.
https_first_pbm
"
false
]
]
}
)
;
let
token
=
uuidGenerator
.
generateUUID
(
)
.
toString
(
)
;
await
deletePrivateBrowsingCache
(
token
)
;
await
deletePrivateBrowsingCache
(
token
)
;
await
SpecialPowers
.
clearUserPref
(
"
dom
.
security
.
https_first_pbm
"
)
;
}
)
;
