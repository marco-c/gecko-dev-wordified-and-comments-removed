#
include
"
nsPerformanceStats
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
processthreadsapi
.
h
>
#
include
<
windows
.
h
>
#
else
#
include
<
unistd
.
h
>
#
endif
#
if
defined
(
XP_MACOSX
)
#
include
<
mach
/
mach_init
.
h
>
#
include
<
mach
/
mach_interface
.
h
>
#
include
<
mach
/
mach_port
.
h
>
#
include
<
mach
/
mach_types
.
h
>
#
include
<
mach
/
message
.
h
>
#
include
<
mach
/
thread_info
.
h
>
#
elif
defined
(
XP_UNIX
)
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
resource
.
h
>
#
endif
namespace
{
already_AddRefed
<
nsPIDOMWindow
>
GetPrivateWindow
(
JSContext
*
cx
)
{
nsCOMPtr
<
nsPIDOMWindow
>
win
=
xpc
:
:
CurrentWindowOrNull
(
cx
)
;
if
(
!
win
)
{
return
nullptr
;
}
win
=
win
-
>
GetOuterWindow
(
)
;
if
(
!
win
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindow
>
top
=
win
-
>
GetTop
(
)
;
if
(
!
top
)
{
return
nullptr
;
}
return
top
.
forget
(
)
;
}
bool
URLForGlobal
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
global
nsAString
&
url
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
nsContentUtils
:
:
ObjectPrincipal
(
global
)
;
if
(
!
principal
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
principal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
uri
)
{
return
false
;
}
nsAutoCString
spec
;
rv
=
uri
-
>
GetSpec
(
spec
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
url
.
Assign
(
NS_ConvertUTF8toUTF16
(
spec
)
)
;
return
true
;
}
void
CompartmentName
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
global
nsAString
&
name
)
{
if
(
URLForGlobal
(
cx
global
name
)
)
{
return
;
}
nsAutoCString
cname
;
xpc
:
:
GetCurrentCompartmentName
(
cx
cname
)
;
name
.
Assign
(
NS_ConvertUTF8toUTF16
(
cname
)
)
;
}
void
GenerateUniqueGroupId
(
const
JSRuntime
*
rt
uint64_t
uid
uint64_t
processId
nsAString
&
groupId
)
{
uint64_t
runtimeId
=
reinterpret_cast
<
uintptr_t
>
(
rt
)
;
groupId
.
AssignLiteral
(
"
process
:
"
)
;
groupId
.
AppendInt
(
processId
)
;
groupId
.
AppendLiteral
(
"
thread
:
"
)
;
groupId
.
AppendInt
(
runtimeId
)
;
groupId
.
AppendLiteral
(
"
group
:
"
)
;
groupId
.
AppendInt
(
uid
)
;
}
}
PerformanceData
:
:
PerformanceData
(
)
:
mTotalUserTime
(
0
)
mTotalSystemTime
(
0
)
mTotalCPOWTime
(
0
)
mTicks
(
0
)
{
mozilla
:
:
PodArrayZero
(
mDurations
)
;
}
const
nsAString
&
nsPerformanceGroupDetails
:
:
Name
(
)
const
{
return
mName
;
}
const
nsAString
&
nsPerformanceGroupDetails
:
:
GroupId
(
)
const
{
return
mGroupId
;
}
const
nsAString
&
nsPerformanceGroupDetails
:
:
AddonId
(
)
const
{
return
mAddonId
;
}
uint64_t
nsPerformanceGroupDetails
:
:
WindowId
(
)
const
{
return
mWindowId
;
}
uint64_t
nsPerformanceGroupDetails
:
:
ProcessId
(
)
const
{
return
mProcessId
;
}
bool
nsPerformanceGroupDetails
:
:
IsSystem
(
)
const
{
return
mIsSystem
;
}
bool
nsPerformanceGroupDetails
:
:
IsAddon
(
)
const
{
return
mAddonId
.
Length
(
)
!
=
0
;
}
bool
nsPerformanceGroupDetails
:
:
IsWindow
(
)
const
{
return
mWindowId
!
=
0
;
}
class
nsPerformanceStats
:
public
nsIPerformanceStats
public
nsPerformanceGroupDetails
{
public
:
nsPerformanceStats
(
const
nsAString
&
aName
const
nsAString
&
aGroupId
const
nsAString
&
aAddonId
const
uint64_t
aWindowId
const
uint64_t
aProcessId
const
bool
aIsSystem
const
PerformanceData
&
aPerformanceData
)
:
nsPerformanceGroupDetails
(
aName
aGroupId
aAddonId
aWindowId
aProcessId
aIsSystem
)
mPerformanceData
(
aPerformanceData
)
{
}
nsPerformanceStats
(
const
nsPerformanceGroupDetails
&
item
const
PerformanceData
&
aPerformanceData
)
:
nsPerformanceGroupDetails
(
item
)
mPerformanceData
(
aPerformanceData
)
{
}
NS_DECL_ISUPPORTS
NS_IMETHOD
GetName
(
nsAString
&
aName
)
override
{
aName
.
Assign
(
nsPerformanceGroupDetails
:
:
Name
(
)
)
;
return
NS_OK
;
}
;
NS_IMETHOD
GetGroupId
(
nsAString
&
aGroupId
)
override
{
aGroupId
.
Assign
(
nsPerformanceGroupDetails
:
:
GroupId
(
)
)
;
return
NS_OK
;
}
;
NS_IMETHOD
GetAddonId
(
nsAString
&
aAddonId
)
override
{
aAddonId
.
Assign
(
nsPerformanceGroupDetails
:
:
AddonId
(
)
)
;
return
NS_OK
;
}
;
NS_IMETHOD
GetWindowId
(
uint64_t
*
aWindowId
)
override
{
*
aWindowId
=
nsPerformanceGroupDetails
:
:
WindowId
(
)
;
return
NS_OK
;
}
NS_IMETHOD
GetIsSystem
(
bool
*
_retval
)
override
{
*
_retval
=
nsPerformanceGroupDetails
:
:
IsSystem
(
)
;
return
NS_OK
;
}
NS_IMETHOD
GetTotalUserTime
(
uint64_t
*
aTotalUserTime
)
override
{
*
aTotalUserTime
=
mPerformanceData
.
mTotalUserTime
;
return
NS_OK
;
}
;
NS_IMETHOD
GetTotalSystemTime
(
uint64_t
*
aTotalSystemTime
)
override
{
*
aTotalSystemTime
=
mPerformanceData
.
mTotalSystemTime
;
return
NS_OK
;
}
;
NS_IMETHOD
GetTotalCPOWTime
(
uint64_t
*
aCpowTime
)
override
{
*
aCpowTime
=
mPerformanceData
.
mTotalCPOWTime
;
return
NS_OK
;
}
;
NS_IMETHOD
GetTicks
(
uint64_t
*
aTicks
)
override
{
*
aTicks
=
mPerformanceData
.
mTicks
;
return
NS_OK
;
}
;
NS_IMETHOD
GetDurations
(
uint32_t
*
aCount
uint64_t
*
*
aNumberOfOccurrences
)
override
{
const
size_t
length
=
mozilla
:
:
ArrayLength
(
mPerformanceData
.
mDurations
)
;
if
(
aCount
)
{
*
aCount
=
length
;
}
*
aNumberOfOccurrences
=
new
uint64_t
[
length
]
;
for
(
size_t
i
=
0
;
i
<
length
;
+
+
i
)
{
(
*
aNumberOfOccurrences
)
[
i
]
=
mPerformanceData
.
mDurations
[
i
]
;
}
return
NS_OK
;
}
;
NS_IMETHODIMP
GetProcessId
(
uint64_t
*
processId
)
override
{
*
processId
=
nsPerformanceGroupDetails
:
:
ProcessId
(
)
;
return
NS_OK
;
}
private
:
PerformanceData
mPerformanceData
;
virtual
~
nsPerformanceStats
(
)
{
}
}
;
NS_IMPL_ISUPPORTS
(
nsPerformanceStats
nsIPerformanceStats
)
class
nsPerformanceSnapshot
:
public
nsIPerformanceSnapshot
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIPERFORMANCESNAPSHOT
nsPerformanceSnapshot
(
)
{
}
void
AppendComponentsStats
(
nsIPerformanceStats
*
stats
)
;
void
SetProcessStats
(
nsIPerformanceStats
*
group
)
;
private
:
virtual
~
nsPerformanceSnapshot
(
)
{
}
private
:
nsCOMArray
<
nsIPerformanceStats
>
mComponentsData
;
nsCOMPtr
<
nsIPerformanceStats
>
mProcessData
;
}
;
NS_IMPL_ISUPPORTS
(
nsPerformanceSnapshot
nsIPerformanceSnapshot
)
NS_IMETHODIMP
nsPerformanceSnapshot
:
:
GetComponentsData
(
nsIArray
*
*
aComponents
)
{
const
size_t
length
=
mComponentsData
.
Length
(
)
;
nsCOMPtr
<
nsIMutableArray
>
components
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
)
;
for
(
size_t
i
=
0
;
i
<
length
;
+
+
i
)
{
nsCOMPtr
<
nsIPerformanceStats
>
stats
=
mComponentsData
[
i
]
;
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
components
-
>
AppendElement
(
stats
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
components
.
forget
(
aComponents
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPerformanceSnapshot
:
:
GetProcessData
(
nsIPerformanceStats
*
*
aProcess
)
{
NS_IF_ADDREF
(
*
aProcess
=
mProcessData
)
;
return
NS_OK
;
}
void
nsPerformanceSnapshot
:
:
AppendComponentsStats
(
nsIPerformanceStats
*
stats
)
{
mComponentsData
.
AppendElement
(
stats
)
;
}
void
nsPerformanceSnapshot
:
:
SetProcessStats
(
nsIPerformanceStats
*
stats
)
{
mProcessData
=
stats
;
}
NS_IMPL_ISUPPORTS
(
nsPerformanceStatsService
nsIPerformanceStatsService
nsIObserver
)
nsPerformanceStatsService
:
:
nsPerformanceStatsService
(
)
:
mIsAvailable
(
false
)
#
if
defined
(
XP_WIN
)
mProcessId
(
GetCurrentProcessId
(
)
)
#
else
mProcessId
(
getpid
(
)
)
#
endif
mRuntime
(
xpc
:
:
GetJSRuntime
(
)
)
mUIdCounter
(
0
)
mTopGroup
(
nsPerformanceGroup
:
:
Make
(
mRuntime
this
NS_LITERAL_STRING
(
"
<
process
>
"
)
NS_LITERAL_STRING
(
"
"
)
0
mProcessId
true
nsPerformanceGroup
:
:
GroupScope
:
:
RUNTIME
)
)
mProcessStayed
(
0
)
mProcessMoved
(
0
)
mProcessUpdateCounter
(
0
)
mIsMonitoringPerCompartment
(
false
)
{
}
nsPerformanceStatsService
:
:
~
nsPerformanceStatsService
(
)
{
}
void
nsPerformanceStatsService
:
:
Dispose
(
)
{
RefPtr
<
nsPerformanceStatsService
>
kungFuDeathGrip
(
this
)
;
mIsAvailable
=
false
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
"
profile
-
before
-
change
"
)
;
obs
-
>
RemoveObserver
(
this
"
quit
-
application
"
)
;
obs
-
>
RemoveObserver
(
this
"
quit
-
application
-
granted
"
)
;
obs
-
>
RemoveObserver
(
this
"
content
-
child
-
shutdown
"
)
;
obs
-
>
RemoveObserver
(
this
"
xpcom
-
will
-
shutdown
"
)
;
}
js
:
:
DisposePerformanceMonitoring
(
mRuntime
)
;
mozilla
:
:
Unused
<
<
js
:
:
SetStopwatchIsMonitoringCPOW
(
mRuntime
false
)
;
mozilla
:
:
Unused
<
<
js
:
:
SetStopwatchIsMonitoringJank
(
mRuntime
false
)
;
mozilla
:
:
Unused
<
<
js
:
:
SetStopwatchStartCallback
(
mRuntime
nullptr
nullptr
)
;
mozilla
:
:
Unused
<
<
js
:
:
SetStopwatchCommitCallback
(
mRuntime
nullptr
nullptr
)
;
mozilla
:
:
Unused
<
<
js
:
:
SetGetPerformanceGroupsCallback
(
mRuntime
nullptr
nullptr
)
;
mTopGroup
-
>
Dispose
(
)
;
mTopGroup
=
nullptr
;
GroupVector
groups
;
for
(
auto
iter
=
mGroups
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
groups
.
append
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
}
for
(
auto
iter
=
groups
.
begin
(
)
;
iter
<
groups
.
end
(
)
;
iter
+
+
)
{
RefPtr
<
nsPerformanceGroup
>
group
=
*
iter
;
group
-
>
Dispose
(
)
;
}
}
nsresult
nsPerformanceStatsService
:
:
Init
(
)
{
nsresult
rv
=
InitInternal
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
Dispose
(
)
;
}
return
rv
;
}
nsresult
nsPerformanceStatsService
:
:
InitInternal
(
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
this
"
profile
-
before
-
change
"
false
)
;
obs
-
>
AddObserver
(
this
"
quit
-
application
-
granted
"
false
)
;
obs
-
>
AddObserver
(
this
"
quit
-
application
"
false
)
;
obs
-
>
AddObserver
(
this
"
content
-
child
-
shutdown
"
false
)
;
obs
-
>
AddObserver
(
this
"
xpcom
-
will
-
shutdown
"
false
)
;
}
if
(
!
js
:
:
SetStopwatchStartCallback
(
mRuntime
StopwatchStartCallback
this
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
js
:
:
SetStopwatchCommitCallback
(
mRuntime
StopwatchCommitCallback
this
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
js
:
:
SetGetPerformanceGroupsCallback
(
mRuntime
GetPerformanceGroupsCallback
this
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mTopGroup
-
>
setIsActive
(
true
)
;
mIsAvailable
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPerformanceStatsService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
strcmp
(
aTopic
"
profile
-
before
-
change
"
)
=
=
0
|
|
strcmp
(
aTopic
"
quit
-
application
"
)
=
=
0
|
|
strcmp
(
aTopic
"
quit
-
application
-
granted
"
)
=
=
0
|
|
strcmp
(
aTopic
"
content
-
child
-
shutdown
"
)
=
=
0
|
|
strcmp
(
aTopic
"
xpcom
-
will
-
shutdown
"
)
=
=
0
)
;
Dispose
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPerformanceStatsService
:
:
GetIsMonitoringCPOW
(
JSContext
*
cx
bool
*
aIsStopwatchActive
)
{
if
(
!
mIsAvailable
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
JSRuntime
*
runtime
=
JS_GetRuntime
(
cx
)
;
*
aIsStopwatchActive
=
js
:
:
GetStopwatchIsMonitoringCPOW
(
runtime
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPerformanceStatsService
:
:
SetIsMonitoringCPOW
(
JSContext
*
cx
bool
aIsStopwatchActive
)
{
if
(
!
mIsAvailable
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
JSRuntime
*
runtime
=
JS_GetRuntime
(
cx
)
;
if
(
!
js
:
:
SetStopwatchIsMonitoringCPOW
(
runtime
aIsStopwatchActive
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPerformanceStatsService
:
:
GetIsMonitoringJank
(
JSContext
*
cx
bool
*
aIsStopwatchActive
)
{
if
(
!
mIsAvailable
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
JSRuntime
*
runtime
=
JS_GetRuntime
(
cx
)
;
*
aIsStopwatchActive
=
js
:
:
GetStopwatchIsMonitoringJank
(
runtime
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPerformanceStatsService
:
:
SetIsMonitoringJank
(
JSContext
*
cx
bool
aIsStopwatchActive
)
{
if
(
!
mIsAvailable
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
JSRuntime
*
runtime
=
JS_GetRuntime
(
cx
)
;
if
(
!
js
:
:
SetStopwatchIsMonitoringJank
(
runtime
aIsStopwatchActive
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPerformanceStatsService
:
:
GetIsMonitoringPerCompartment
(
JSContext
*
bool
*
aIsMonitoringPerCompartment
)
{
if
(
!
mIsAvailable
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aIsMonitoringPerCompartment
=
mIsMonitoringPerCompartment
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPerformanceStatsService
:
:
SetIsMonitoringPerCompartment
(
JSContext
*
bool
aIsMonitoringPerCompartment
)
{
if
(
!
mIsAvailable
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
aIsMonitoringPerCompartment
=
=
mIsMonitoringPerCompartment
)
{
return
NS_OK
;
}
for
(
auto
iter
=
mGroups
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
nsPerformanceGroup
>
group
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
if
(
group
-
>
Scope
(
)
=
=
nsPerformanceGroup
:
:
GroupScope
:
:
COMPARTMENT
)
{
group
-
>
setIsActive
(
aIsMonitoringPerCompartment
)
;
}
}
mIsMonitoringPerCompartment
=
aIsMonitoringPerCompartment
;
return
NS_OK
;
}
nsresult
nsPerformanceStatsService
:
:
UpdateTelemetry
(
)
{
const
double
processStayed
=
mProcessStayed
;
const
double
processMoved
=
mProcessMoved
;
if
(
processStayed
<
=
0
|
|
processMoved
<
=
0
|
|
processStayed
+
processMoved
<
=
0
)
{
return
NS_OK
;
}
const
double
proportion
=
(
100
*
processStayed
)
/
(
processStayed
+
processMoved
)
;
if
(
proportion
<
0
|
|
proportion
>
100
)
{
return
NS_OK
;
}
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
PERF_MONITORING_TEST_CPU_RESCHEDULING_PROPORTION_MOVED
(
uint32_t
)
proportion
)
;
return
NS_OK
;
}
nsIPerformanceStats
*
nsPerformanceStatsService
:
:
GetStatsForGroup
(
const
js
:
:
PerformanceGroup
*
group
)
{
return
GetStatsForGroup
(
nsPerformanceGroup
:
:
Get
(
group
)
)
;
}
nsIPerformanceStats
*
nsPerformanceStatsService
:
:
GetStatsForGroup
(
const
nsPerformanceGroup
*
group
)
{
return
new
nsPerformanceStats
(
*
group
group
-
>
data
)
;
}
NS_IMETHODIMP
nsPerformanceStatsService
:
:
GetSnapshot
(
JSContext
*
cx
nsIPerformanceSnapshot
*
*
aSnapshot
)
{
if
(
!
mIsAvailable
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
nsPerformanceSnapshot
>
snapshot
=
new
nsPerformanceSnapshot
(
)
;
snapshot
-
>
SetProcessStats
(
GetStatsForGroup
(
mTopGroup
)
)
;
for
(
auto
iter
=
mGroups
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
*
entry
=
iter
.
Get
(
)
;
nsPerformanceGroup
*
group
=
entry
-
>
GetKey
(
)
;
if
(
group
-
>
isActive
(
)
)
{
snapshot
-
>
AppendComponentsStats
(
GetStatsForGroup
(
group
)
)
;
}
}
js
:
:
GetPerfMonitoringTestCpuRescheduling
(
JS_GetRuntime
(
cx
)
&
mProcessStayed
&
mProcessMoved
)
;
if
(
+
+
mProcessUpdateCounter
%
10
=
=
0
)
{
mozilla
:
:
Unused
<
<
UpdateTelemetry
(
)
;
}
snapshot
.
forget
(
aSnapshot
)
;
return
NS_OK
;
}
uint64_t
nsPerformanceStatsService
:
:
GetNextId
(
)
{
return
+
+
mUIdCounter
;
}
bool
nsPerformanceStatsService
:
:
GetPerformanceGroupsCallback
(
JSContext
*
cx
JSGroupVector
&
out
void
*
closure
)
{
RefPtr
<
nsPerformanceStatsService
>
self
=
reinterpret_cast
<
nsPerformanceStatsService
*
>
(
closure
)
;
return
self
-
>
GetPerformanceGroups
(
cx
out
)
;
}
bool
nsPerformanceStatsService
:
:
GetPerformanceGroups
(
JSContext
*
cx
JSGroupVector
&
out
)
{
JS
:
:
RootedObject
global
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
if
(
!
global
)
{
return
true
;
}
out
.
append
(
mTopGroup
)
;
nsAutoString
name
;
CompartmentName
(
cx
global
name
)
;
bool
isSystem
=
nsContentUtils
:
:
IsSystemPrincipal
(
nsContentUtils
:
:
ObjectPrincipal
(
global
)
)
;
JSAddonId
*
jsaddonId
=
AddonIdOfObject
(
global
)
;
nsString
addonId
;
if
(
jsaddonId
)
{
AssignJSFlatString
(
addonId
(
JSFlatString
*
)
jsaddonId
)
;
auto
entry
=
mAddonIdToGroup
.
PutEntry
(
addonId
)
;
if
(
!
entry
-
>
mGroup
)
{
nsString
addonName
=
name
;
addonName
.
AppendLiteral
(
"
(
as
addon
"
)
;
addonName
.
Append
(
addonId
)
;
addonName
.
AppendLiteral
(
"
)
"
)
;
entry
-
>
mGroup
=
nsPerformanceGroup
:
:
Make
(
mRuntime
this
addonName
addonId
0
mProcessId
isSystem
nsPerformanceGroup
:
:
GroupScope
:
:
ADDON
)
;
}
out
.
append
(
entry
-
>
mGroup
)
;
}
nsCOMPtr
<
nsPIDOMWindow
>
ptop
=
GetPrivateWindow
(
cx
)
;
uint64_t
windowId
=
0
;
if
(
ptop
)
{
windowId
=
ptop
-
>
WindowID
(
)
;
auto
entry
=
mWindowIdToGroup
.
PutEntry
(
windowId
)
;
if
(
!
entry
-
>
mGroup
)
{
nsString
windowName
=
name
;
windowName
.
AppendLiteral
(
"
(
as
window
"
)
;
windowName
.
AppendInt
(
windowId
)
;
windowName
.
AppendLiteral
(
"
)
"
)
;
entry
-
>
mGroup
=
nsPerformanceGroup
:
:
Make
(
mRuntime
this
windowName
EmptyString
(
)
windowId
mProcessId
isSystem
nsPerformanceGroup
:
:
GroupScope
:
:
WINDOW
)
;
}
out
.
append
(
entry
-
>
mGroup
)
;
}
auto
group
=
nsPerformanceGroup
:
:
Make
(
mRuntime
this
name
addonId
windowId
mProcessId
isSystem
nsPerformanceGroup
:
:
GroupScope
:
:
COMPARTMENT
)
;
out
.
append
(
group
)
;
return
true
;
}
bool
nsPerformanceStatsService
:
:
StopwatchStartCallback
(
uint64_t
iteration
void
*
closure
)
{
RefPtr
<
nsPerformanceStatsService
>
self
=
reinterpret_cast
<
nsPerformanceStatsService
*
>
(
closure
)
;
return
self
-
>
StopwatchStart
(
iteration
)
;
}
bool
nsPerformanceStatsService
:
:
StopwatchStart
(
uint64_t
iteration
)
{
mIteration
=
iteration
;
nsresult
rv
=
GetResources
(
&
mUserTimeStart
&
mSystemTimeStart
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
return
true
;
}
bool
nsPerformanceStatsService
:
:
StopwatchCommitCallback
(
uint64_t
iteration
JSGroupVector
&
recentGroups
void
*
closure
)
{
RefPtr
<
nsPerformanceStatsService
>
self
=
reinterpret_cast
<
nsPerformanceStatsService
*
>
(
closure
)
;
return
self
-
>
StopwatchCommit
(
iteration
recentGroups
)
;
}
bool
nsPerformanceStatsService
:
:
StopwatchCommit
(
uint64_t
iteration
JSGroupVector
&
recentGroups
)
{
MOZ_ASSERT
(
iteration
=
=
mIteration
)
;
MOZ_ASSERT
(
recentGroups
.
length
(
)
>
0
)
;
uint64_t
userTimeStop
systemTimeStop
;
nsresult
rv
=
GetResources
(
&
userTimeStop
&
systemTimeStop
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
uint64_t
userTimeDelta
=
0
;
if
(
userTimeStop
>
mUserTimeStart
)
userTimeDelta
=
userTimeStop
-
mUserTimeStart
;
uint64_t
systemTimeDelta
=
0
;
if
(
systemTimeStop
>
mSystemTimeStart
)
systemTimeDelta
=
systemTimeStop
-
mSystemTimeStart
;
MOZ_ASSERT
(
mTopGroup
-
>
isUsedInThisIteration
(
)
)
;
const
uint64_t
totalRecentCycles
=
mTopGroup
-
>
recentCycles
(
iteration
)
;
MOZ_ASSERT
(
mTopGroup
-
>
recentTicks
(
iteration
)
>
0
)
;
for
(
auto
iter
=
recentGroups
.
begin
(
)
;
iter
!
=
recentGroups
.
end
(
)
;
+
+
iter
)
{
RefPtr
<
nsPerformanceGroup
>
group
=
nsPerformanceGroup
:
:
Get
(
*
iter
)
;
CommitGroup
(
iteration
userTimeDelta
systemTimeDelta
totalRecentCycles
group
)
;
}
MOZ_ASSERT
(
!
mTopGroup
-
>
isUsedInThisIteration
(
)
)
;
MOZ_ASSERT
(
mTopGroup
-
>
recentTicks
(
iteration
)
=
=
0
)
;
return
true
;
}
void
nsPerformanceStatsService
:
:
CommitGroup
(
uint64_t
iteration
uint64_t
totalUserTimeDelta
uint64_t
totalSystemTimeDelta
uint64_t
totalCyclesDelta
nsPerformanceGroup
*
group
)
{
MOZ_ASSERT
(
group
-
>
isUsedInThisIteration
(
)
)
;
const
uint64_t
ticksDelta
=
group
-
>
recentTicks
(
iteration
)
;
const
uint64_t
cpowTimeDelta
=
group
-
>
recentCPOW
(
iteration
)
;
const
uint64_t
cyclesDelta
=
group
-
>
recentCycles
(
iteration
)
;
group
-
>
resetRecentData
(
)
;
if
(
group
-
>
iteration
(
)
!
=
iteration
)
{
return
;
}
MOZ_ASSERT
(
ticksDelta
!
=
0
)
;
MOZ_ASSERT
(
cyclesDelta
<
=
totalCyclesDelta
)
;
if
(
cyclesDelta
=
=
0
|
|
totalCyclesDelta
=
=
0
)
{
return
;
}
double
proportion
=
(
double
)
cyclesDelta
/
(
double
)
totalCyclesDelta
;
MOZ_ASSERT
(
proportion
<
=
1
)
;
const
uint64_t
userTimeDelta
=
proportion
*
totalUserTimeDelta
;
const
uint64_t
systemTimeDelta
=
proportion
*
totalSystemTimeDelta
;
group
-
>
data
.
mTotalUserTime
+
=
userTimeDelta
;
group
-
>
data
.
mTotalSystemTime
+
=
systemTimeDelta
;
group
-
>
data
.
mTotalCPOWTime
+
=
cpowTimeDelta
;
group
-
>
data
.
mTicks
+
=
ticksDelta
;
const
uint64_t
totalTimeDelta
=
userTimeDelta
+
systemTimeDelta
+
cpowTimeDelta
;
uint64_t
duration
=
1000
;
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
group
-
>
data
.
mDurations
)
&
&
duration
<
totalTimeDelta
;
+
+
i
duration
*
=
2
)
{
group
-
>
data
.
mDurations
[
i
]
+
+
;
}
}
nsresult
nsPerformanceStatsService
:
:
GetResources
(
uint64_t
*
userTime
uint64_t
*
systemTime
)
const
{
MOZ_ASSERT
(
userTime
)
;
MOZ_ASSERT
(
systemTime
)
;
#
if
defined
(
XP_MACOSX
)
mach_msg_type_number_t
count
=
THREAD_BASIC_INFO_COUNT
;
thread_basic_info_data_t
info
;
mach_port_t
port
=
mach_thread_self
(
)
;
kern_return_t
err
=
thread_info
(
port
THREAD_BASIC_INFO
(
thread_info_t
)
&
info
&
count
)
;
mach_port_deallocate
(
mach_task_self
(
)
port
)
;
if
(
err
!
=
KERN_SUCCESS
)
return
NS_ERROR_FAILURE
;
*
userTime
=
info
.
user_time
.
microseconds
+
info
.
user_time
.
seconds
*
1000000
;
*
systemTime
=
info
.
system_time
.
microseconds
+
info
.
system_time
.
seconds
*
1000000
;
#
elif
defined
(
XP_UNIX
)
struct
rusage
rusage
;
#
if
defined
(
RUSAGE_THREAD
)
int
err
=
getrusage
(
RUSAGE_THREAD
&
rusage
)
;
#
else
int
err
=
getrusage
(
RUSAGE_SELF
&
rusage
)
;
#
endif
if
(
err
)
return
NS_ERROR_FAILURE
;
*
userTime
=
rusage
.
ru_utime
.
tv_usec
+
rusage
.
ru_utime
.
tv_sec
*
1000000
;
*
systemTime
=
rusage
.
ru_stime
.
tv_usec
+
rusage
.
ru_stime
.
tv_sec
*
1000000
;
#
elif
defined
(
XP_WIN
)
FILETIME
creationFileTime
;
FILETIME
exitFileTime
;
FILETIME
kernelFileTime
;
FILETIME
userFileTime
;
BOOL
success
=
GetThreadTimes
(
GetCurrentThread
(
)
&
creationFileTime
&
exitFileTime
&
kernelFileTime
&
userFileTime
)
;
if
(
!
success
)
return
NS_ERROR_FAILURE
;
ULARGE_INTEGER
kernelTimeInt
;
kernelTimeInt
.
LowPart
=
kernelFileTime
.
dwLowDateTime
;
kernelTimeInt
.
HighPart
=
kernelFileTime
.
dwHighDateTime
;
*
systemTime
=
kernelTimeInt
.
QuadPart
/
10
;
ULARGE_INTEGER
userTimeInt
;
userTimeInt
.
LowPart
=
userFileTime
.
dwLowDateTime
;
userTimeInt
.
HighPart
=
userFileTime
.
dwHighDateTime
;
*
userTime
=
userTimeInt
.
QuadPart
/
10
;
#
endif
return
NS_OK
;
}
nsPerformanceGroup
*
nsPerformanceGroup
:
:
Make
(
JSRuntime
*
rt
nsPerformanceStatsService
*
service
const
nsAString
&
name
const
nsAString
&
addonId
uint64_t
windowId
uint64_t
processId
bool
isSystem
GroupScope
scope
)
{
nsString
groupId
;
:
:
GenerateUniqueGroupId
(
rt
service
-
>
GetNextId
(
)
processId
groupId
)
;
return
new
nsPerformanceGroup
(
service
name
groupId
addonId
windowId
processId
isSystem
scope
)
;
}
nsPerformanceGroup
:
:
nsPerformanceGroup
(
nsPerformanceStatsService
*
service
const
nsAString
&
name
const
nsAString
&
groupId
const
nsAString
&
addonId
uint64_t
windowId
uint64_t
processId
bool
isSystem
GroupScope
scope
)
:
nsPerformanceGroupDetails
(
name
groupId
addonId
windowId
processId
isSystem
)
mService
(
service
)
mScope
(
scope
)
{
mozilla
:
:
Unused
<
<
mService
-
>
mGroups
.
PutEntry
(
this
)
;
#
if
defined
(
DEBUG
)
if
(
scope
=
=
GroupScope
:
:
ADDON
)
{
MOZ_ASSERT
(
IsAddon
(
)
)
;
MOZ_ASSERT
(
!
IsWindow
(
)
)
;
}
else
if
(
scope
=
=
GroupScope
:
:
WINDOW
)
{
MOZ_ASSERT
(
IsWindow
(
)
)
;
MOZ_ASSERT
(
!
IsAddon
(
)
)
;
}
else
if
(
scope
=
=
GroupScope
:
:
RUNTIME
)
{
MOZ_ASSERT
(
!
IsWindow
(
)
)
;
MOZ_ASSERT
(
!
IsAddon
(
)
)
;
}
#
endif
setIsActive
(
mScope
!
=
GroupScope
:
:
COMPARTMENT
|
|
mService
-
>
mIsMonitoringPerCompartment
)
;
}
void
nsPerformanceGroup
:
:
Dispose
(
)
{
if
(
!
mService
)
{
return
;
}
RefPtr
<
nsPerformanceStatsService
>
service
;
service
.
swap
(
mService
)
;
service
-
>
mGroups
.
RemoveEntry
(
this
)
;
if
(
mScope
=
=
GroupScope
:
:
ADDON
)
{
MOZ_ASSERT
(
IsAddon
(
)
)
;
service
-
>
mAddonIdToGroup
.
RemoveEntry
(
AddonId
(
)
)
;
}
else
if
(
mScope
=
=
GroupScope
:
:
WINDOW
)
{
MOZ_ASSERT
(
IsWindow
(
)
)
;
service
-
>
mWindowIdToGroup
.
RemoveEntry
(
WindowId
(
)
)
;
}
}
nsPerformanceGroup
:
:
~
nsPerformanceGroup
(
)
{
Dispose
(
)
;
}
nsPerformanceGroup
:
:
GroupScope
nsPerformanceGroup
:
:
Scope
(
)
const
{
return
mScope
;
}
