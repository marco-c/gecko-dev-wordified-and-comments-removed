#
ifndef
nsPerformanceStats_h
#
define
nsPerformanceStats_h
#
include
"
jsapi
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIPerformanceStats
.
h
"
class
nsPerformanceGroup
;
class
nsPerformanceGroupDetails
;
typedef
mozilla
:
:
Vector
<
RefPtr
<
js
:
:
PerformanceGroup
>
>
JSGroupVector
;
typedef
mozilla
:
:
Vector
<
RefPtr
<
nsPerformanceGroup
>
>
GroupVector
;
class
nsPerformanceObservationTarget
final
:
public
nsIPerformanceObservable
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIPERFORMANCEOBSERVABLE
bool
HasObservers
(
)
const
;
void
NotifyJankObservers
(
nsIPerformanceGroupDetails
*
source
nsIPerformanceAlert
*
gravity
)
;
void
SetTarget
(
nsPerformanceGroupDetails
*
details
)
;
private
:
~
nsPerformanceObservationTarget
(
)
{
}
mozilla
:
:
Vector
<
nsCOMPtr
<
nsIPerformanceObserver
>
>
mObservers
;
RefPtr
<
nsPerformanceGroupDetails
>
mDetails
;
}
;
class
nsGroupHolder
{
public
:
nsGroupHolder
(
)
:
mGroup
(
nullptr
)
mPendingObservationTarget
(
nullptr
)
{
}
nsPerformanceObservationTarget
*
ObservationTarget
(
)
;
class
nsPerformanceGroup
*
GetGroup
(
)
;
void
SetGroup
(
class
nsPerformanceGroup
*
)
;
private
:
class
nsPerformanceGroup
*
mGroup
;
RefPtr
<
nsPerformanceObservationTarget
>
mPendingObservationTarget
;
}
;
class
nsPerformanceStatsService
final
:
public
nsIPerformanceStatsService
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIPERFORMANCESTATSSERVICE
NS_DECL_NSIOBSERVER
nsPerformanceStatsService
(
)
;
nsresult
Init
(
)
;
static
bool
IsJankCritical
(
)
;
private
:
nsresult
InitInternal
(
)
;
void
Dispose
(
)
;
~
nsPerformanceStatsService
(
)
;
protected
:
friend
nsPerformanceGroup
;
bool
mIsAvailable
;
const
uint64_t
mProcessId
;
JSRuntime
*
const
mRuntime
;
uint64_t
GetNextId
(
)
;
uint64_t
mUIdCounter
;
static
nsIPerformanceStats
*
GetStatsForGroup
(
const
js
:
:
PerformanceGroup
*
group
)
;
static
nsIPerformanceStats
*
GetStatsForGroup
(
const
nsPerformanceGroup
*
group
)
;
bool
GetPerformanceGroups
(
JSContext
*
cx
JSGroupVector
&
)
;
static
bool
GetPerformanceGroupsCallback
(
JSContext
*
cx
JSGroupVector
&
void
*
closure
)
;
struct
AddonIdToGroup
:
public
nsStringHashKey
public
nsGroupHolder
{
explicit
AddonIdToGroup
(
const
nsAString
*
key
)
:
nsStringHashKey
(
key
)
{
}
}
;
nsTHashtable
<
AddonIdToGroup
>
mAddonIdToGroup
;
struct
WindowIdToGroup
:
public
nsUint64HashKey
public
nsGroupHolder
{
explicit
WindowIdToGroup
(
const
uint64_t
*
key
)
:
nsUint64HashKey
(
key
)
{
}
}
;
nsTHashtable
<
WindowIdToGroup
>
mWindowIdToGroup
;
struct
Groups
:
public
nsPtrHashKey
<
nsPerformanceGroup
>
{
explicit
Groups
(
const
nsPerformanceGroup
*
key
)
:
nsPtrHashKey
<
nsPerformanceGroup
>
(
key
)
{
}
}
;
nsTHashtable
<
Groups
>
mGroups
;
RefPtr
<
nsPerformanceGroup
>
mTopGroup
;
nsresult
GetResources
(
uint64_t
*
userTime
uint64_t
*
systemTime
)
const
;
uint64_t
mUserTimeStart
;
uint64_t
mSystemTimeStart
;
bool
mIsJankCritical
;
uint64_t
mUserInputCount
;
static
bool
StopwatchStartCallback
(
uint64_t
iteration
void
*
closure
)
;
bool
StopwatchStart
(
uint64_t
iteration
)
;
static
bool
StopwatchCommitCallback
(
uint64_t
iteration
JSGroupVector
&
recentGroups
void
*
closure
)
;
bool
StopwatchCommit
(
uint64_t
iteration
JSGroupVector
&
recentGroups
)
;
uint64_t
mIteration
;
void
CommitGroup
(
uint64_t
iteration
uint64_t
userTime
uint64_t
systemTime
uint64_t
cycles
bool
isJankVisible
nsPerformanceGroup
*
group
)
;
nsresult
UpdateTelemetry
(
)
;
uint64_t
mProcessStayed
;
uint64_t
mProcessMoved
;
uint32_t
mProcessUpdateCounter
;
bool
mIsMonitoringPerCompartment
;
static
bool
IsAnimating
(
)
;
static
bool
IsHandlingUserInput
(
)
;
public
:
void
NotifyJankObservers
(
)
;
private
:
GroupVector
mPendingAlerts
;
RefPtr
<
class
PendingAlertsCollector
>
mPendingAlertsCollector
;
struct
UniversalTargets
{
UniversalTargets
(
)
;
RefPtr
<
nsPerformanceObservationTarget
>
mAddons
;
RefPtr
<
nsPerformanceObservationTarget
>
mWindows
;
}
;
UniversalTargets
mUniversalTargets
;
uint64_t
mJankAlertThreshold
;
uint32_t
mJankAlertBufferingDelay
;
}
;
struct
PerformanceData
{
uint64_t
mDurations
[
10
]
;
uint64_t
mTotalUserTime
;
uint64_t
mTotalSystemTime
;
uint64_t
mTotalCPOWTime
;
uint64_t
mTicks
;
PerformanceData
(
)
;
PerformanceData
(
const
PerformanceData
&
from
)
=
default
;
PerformanceData
&
operator
=
(
const
PerformanceData
&
from
)
=
default
;
}
;
class
nsPerformanceGroupDetails
final
:
public
nsIPerformanceGroupDetails
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIPERFORMANCEGROUPDETAILS
nsPerformanceGroupDetails
(
const
nsAString
&
aName
const
nsAString
&
aGroupId
const
nsAString
&
aAddonId
const
uint64_t
aWindowId
const
uint64_t
aProcessId
const
bool
aIsSystem
)
:
mName
(
aName
)
mGroupId
(
aGroupId
)
mAddonId
(
aAddonId
)
mWindowId
(
aWindowId
)
mProcessId
(
aProcessId
)
mIsSystem
(
aIsSystem
)
{
}
public
:
const
nsAString
&
Name
(
)
const
;
const
nsAString
&
GroupId
(
)
const
;
const
nsAString
&
AddonId
(
)
const
;
uint64_t
WindowId
(
)
const
;
uint64_t
ProcessId
(
)
const
;
bool
IsAddon
(
)
const
;
bool
IsWindow
(
)
const
;
bool
IsSystem
(
)
const
;
bool
IsContentProcess
(
)
const
;
private
:
~
nsPerformanceGroupDetails
(
)
{
}
const
nsString
mName
;
const
nsString
mGroupId
;
const
nsString
mAddonId
;
const
uint64_t
mWindowId
;
const
uint64_t
mProcessId
;
const
bool
mIsSystem
;
}
;
enum
class
PerformanceGroupScope
{
RUNTIME
WINDOW
ADDON
COMPARTMENT
}
;
class
nsPerformanceGroup
final
:
public
js
:
:
PerformanceGroup
{
public
:
typedef
PerformanceGroupScope
GroupScope
;
static
nsPerformanceGroup
*
Make
(
JSRuntime
*
rt
nsPerformanceStatsService
*
service
const
nsAString
&
name
const
nsAString
&
addonId
uint64_t
windowId
uint64_t
processId
bool
isSystem
GroupScope
scope
)
;
static
inline
nsPerformanceGroup
*
Get
(
js
:
:
PerformanceGroup
*
self
)
{
return
static_cast
<
nsPerformanceGroup
*
>
(
self
)
;
}
static
inline
const
nsPerformanceGroup
*
Get
(
const
js
:
:
PerformanceGroup
*
self
)
{
return
static_cast
<
const
nsPerformanceGroup
*
>
(
self
)
;
}
PerformanceData
data
;
GroupScope
Scope
(
)
const
;
nsPerformanceGroupDetails
*
Details
(
)
const
;
void
Dispose
(
)
;
void
SetObservationTarget
(
nsPerformanceObservationTarget
*
)
;
bool
HasPendingAlert
(
)
const
;
void
SetHasPendingAlert
(
bool
value
)
;
protected
:
nsPerformanceGroup
(
nsPerformanceStatsService
*
service
const
nsAString
&
name
const
nsAString
&
groupId
const
nsAString
&
addonId
uint64_t
windowId
uint64_t
processId
bool
isSystem
GroupScope
scope
)
;
virtual
void
Delete
(
)
override
{
delete
this
;
}
~
nsPerformanceGroup
(
)
;
private
:
RefPtr
<
nsPerformanceGroupDetails
>
mDetails
;
RefPtr
<
nsPerformanceStatsService
>
mService
;
const
GroupScope
mScope
;
public
:
nsPerformanceObservationTarget
*
ObservationTarget
(
)
const
;
void
RecordJank
(
uint64_t
jank
)
;
uint64_t
HighestRecentJank
(
)
;
void
RecordCPOW
(
uint64_t
cpow
)
;
uint64_t
HighestRecentCPOW
(
)
;
void
RecordJankVisibility
(
)
;
bool
RecentJankVisibility
(
)
;
void
ResetHighest
(
)
;
private
:
RefPtr
<
class
nsPerformanceObservationTarget
>
mObservationTarget
;
uint64_t
mHighestJank
;
uint64_t
mHighestCPOW
;
bool
mIsJankVisible
;
bool
mHasPendingAlert
;
}
;
namespace
{
const
uint64_t
MAX_DURATION_OF_INTERACTION_MS
=
150
;
}
#
endif
