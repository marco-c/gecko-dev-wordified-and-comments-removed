#
include
"
mozilla
/
PerformanceUtils
.
h
"
#
include
"
mozilla
/
dom
/
DOMTypes
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContextGroup
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
WorkerDebugger
.
h
"
#
include
"
mozilla
/
dom
/
WorkerDebuggerManager
.
h
"
#
include
"
MediaDecoder
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
nsGlobalWindowOuter
.
h
"
#
include
"
nsWindowSizes
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
nsTArray
<
RefPtr
<
PerformanceInfoPromise
>
>
CollectPerformanceInfo
(
)
{
nsTArray
<
RefPtr
<
PerformanceInfoPromise
>
>
promises
;
RefPtr
<
mozilla
:
:
dom
:
:
WorkerDebuggerManager
>
wdm
=
WorkerDebuggerManager
:
:
GetOrCreate
(
)
;
if
(
NS_WARN_IF
(
!
wdm
)
)
{
return
promises
;
}
for
(
uint32_t
i
=
0
;
i
<
wdm
-
>
GetDebuggersLength
(
)
;
i
+
+
)
{
const
RefPtr
<
WorkerDebugger
>
debugger
=
wdm
-
>
GetDebuggerAt
(
i
)
;
promises
.
AppendElement
(
debugger
-
>
ReportPerformanceInfo
(
)
)
;
}
nsTArray
<
RefPtr
<
BrowsingContextGroup
>
>
groups
;
BrowsingContextGroup
:
:
GetAllGroups
(
groups
)
;
nsTArray
<
DocGroup
*
>
docGroups
;
for
(
auto
&
browsingContextGroup
:
groups
)
{
browsingContextGroup
-
>
GetDocGroups
(
docGroups
)
;
}
for
(
DocGroup
*
docGroup
:
docGroups
)
{
promises
.
AppendElement
(
docGroup
-
>
ReportPerformanceInfo
(
)
)
;
}
return
promises
;
}
static
void
AddWindowTabSizes
(
nsGlobalWindowOuter
*
aWindow
nsTabSizes
*
aSizes
)
{
Document
*
document
=
aWindow
-
>
GetDocument
(
)
;
if
(
document
&
&
document
-
>
GetCachedSizes
(
aSizes
)
)
{
return
;
}
nsTabSizes
sizes
;
SizeOfState
state
(
moz_malloc_size_of
)
;
nsWindowSizes
windowSizes
(
state
)
;
aWindow
-
>
AddSizeOfIncludingThis
(
windowSizes
)
;
nsGlobalWindowInner
*
inner
=
aWindow
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
inner
!
=
nullptr
)
{
inner
-
>
AddSizeOfIncludingThis
(
windowSizes
)
;
}
windowSizes
.
addToTabSizes
(
&
sizes
)
;
if
(
document
)
{
document
-
>
SetCachedSizes
(
&
sizes
)
;
}
aSizes
-
>
mDom
+
=
sizes
.
mDom
;
aSizes
-
>
mStyle
+
=
sizes
.
mStyle
;
aSizes
-
>
mOther
+
=
sizes
.
mOther
;
}
RefPtr
<
MemoryPromise
>
CollectMemoryInfo
(
const
RefPtr
<
DocGroup
>
&
aDocGroup
const
RefPtr
<
AbstractThread
>
&
aEventTarget
)
{
nsTabSizes
sizes
;
using
WindowSet
=
mozilla
:
:
HashSet
<
nsGlobalWindowOuter
*
>
;
WindowSet
windowsVisited
;
for
(
const
auto
&
document
:
*
aDocGroup
)
{
nsGlobalWindowOuter
*
window
=
document
?
nsGlobalWindowOuter
:
:
Cast
(
document
-
>
GetWindow
(
)
)
:
nullptr
;
if
(
window
)
{
WindowSet
:
:
AddPtr
p
=
windowsVisited
.
lookupForAdd
(
window
)
;
if
(
!
p
)
{
AddWindowTabSizes
(
window
&
sizes
)
;
if
(
!
windowsVisited
.
add
(
p
window
)
)
{
break
;
}
}
}
}
using
ZoneSet
=
mozilla
:
:
HashSet
<
JS
:
:
Zone
*
>
;
using
SharedSet
=
mozilla
:
:
HashSet
<
void
*
>
;
ZoneSet
zonesVisited
;
SharedSet
sharedVisited
;
uint64_t
jsMemUsed
=
0
;
nsTArray
<
RefPtr
<
MediaMemoryPromise
>
>
mediaMemoryPromises
;
for
(
auto
*
doc
:
*
aDocGroup
)
{
bool
unused
;
nsIGlobalObject
*
globalObject
=
doc
-
>
GetScriptHandlingObject
(
unused
)
;
if
(
globalObject
)
{
JSObject
*
object
=
globalObject
-
>
GetGlobalJSObject
(
)
;
if
(
object
!
=
nullptr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
We
cannot
get
the
object
zone
on
another
thread
"
)
;
JS
:
:
Zone
*
zone
=
JS
:
:
GetObjectZone
(
object
)
;
ZoneSet
:
:
AddPtr
addZone
=
zonesVisited
.
lookupForAdd
(
zone
)
;
if
(
!
addZone
)
{
jsMemUsed
+
=
js
:
:
GetMemoryUsageForZone
(
zone
)
;
if
(
!
zonesVisited
.
add
(
addZone
zone
)
)
{
break
;
}
const
js
:
:
gc
:
:
SharedMemoryMap
&
shared
=
js
:
:
GetSharedMemoryUsageForZone
(
zone
)
;
for
(
auto
iter
=
shared
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
void
*
sharedMem
=
iter
.
get
(
)
.
key
(
)
;
SharedSet
:
:
AddPtr
addShared
=
sharedVisited
.
lookupForAdd
(
sharedMem
)
;
if
(
addShared
)
{
jsMemUsed
-
=
iter
.
get
(
)
.
value
(
)
.
nbytes
;
}
else
if
(
!
sharedVisited
.
add
(
addShared
sharedMem
)
)
{
break
;
}
}
}
}
}
mediaMemoryPromises
.
AppendElement
(
GetMediaMemorySizes
(
doc
)
)
;
}
return
MediaMemoryPromise
:
:
All
(
aEventTarget
mediaMemoryPromises
)
-
>
Then
(
aEventTarget
__func__
[
jsMemUsed
sizes
]
(
const
nsTArray
<
MediaMemoryInfo
>
mediaArray
)
{
size_t
audioSize
=
0
;
size_t
videoSize
=
0
;
size_t
resourcesSize
=
0
;
for
(
auto
media
:
mediaArray
)
{
audioSize
+
=
media
.
audioSize
(
)
;
videoSize
+
=
media
.
videoSize
(
)
;
resourcesSize
+
=
media
.
resourcesSize
(
)
;
}
return
MemoryPromise
:
:
CreateAndResolve
(
PerformanceMemoryInfo
(
MediaMemoryInfo
(
audioSize
videoSize
resourcesSize
)
sizes
.
mDom
sizes
.
mStyle
sizes
.
mOther
jsMemUsed
)
__func__
)
;
}
[
]
(
const
nsresult
rv
)
{
return
MemoryPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
)
;
}
}
