#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
PerformanceUtils
.
h
"
#
include
"
mozilla
/
PerformanceMetricsCollector
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
WorkerDebugger
.
h
"
#
include
"
mozilla
/
dom
/
WorkerDebuggerManager
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
mozilla
:
:
LazyLogModule
sPerfLog
(
"
PerformanceMetricsCollector
"
)
;
#
ifdef
LOG
#
undef
LOG
#
endif
#
define
LOG
(
args
)
MOZ_LOG
(
sPerfLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
namespace
mozilla
{
AggregatedResults
:
:
AggregatedResults
(
nsID
aUUID
PerformanceMetricsCollector
*
aCollector
dom
:
:
Promise
*
aPromise
)
:
mPromise
(
aPromise
)
mPendingResults
(
0
)
mCollector
(
aCollector
)
mUUID
(
aUUID
)
{
MOZ_ASSERT
(
aCollector
)
;
MOZ_ASSERT
(
aPromise
)
;
}
void
AggregatedResults
:
:
Abort
(
nsresult
aReason
)
{
MOZ_ASSERT
(
mPromise
)
;
MOZ_ASSERT
(
NS_FAILED
(
aReason
)
)
;
mPromise
-
>
MaybeReject
(
aReason
)
;
mPromise
=
nullptr
;
mPendingResults
=
0
;
}
void
AggregatedResults
:
:
AppendResult
(
const
nsTArray
<
dom
:
:
PerformanceInfo
>
&
aMetrics
)
{
if
(
!
mPromise
)
{
return
;
}
MOZ_ASSERT
(
mPendingResults
>
0
)
;
for
(
const
PerformanceInfo
&
result
:
aMetrics
)
{
mozilla
:
:
dom
:
:
Sequence
<
mozilla
:
:
dom
:
:
CategoryDispatchDictionary
>
items
;
for
(
const
CategoryDispatch
&
entry
:
result
.
items
(
)
)
{
uint32_t
count
=
entry
.
count
(
)
;
if
(
count
=
=
0
)
{
continue
;
}
CategoryDispatchDictionary
*
item
=
items
.
AppendElement
(
fallible
)
;
if
(
NS_WARN_IF
(
!
item
)
)
{
Abort
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
item
-
>
mCategory
=
entry
.
category
(
)
;
item
-
>
mCount
=
count
;
}
PerformanceInfoDictionary
*
data
=
mData
.
AppendElement
(
fallible
)
;
if
(
NS_WARN_IF
(
!
data
)
)
{
Abort
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
data
-
>
mPid
=
result
.
pid
(
)
;
data
-
>
mWindowId
=
result
.
windowId
(
)
;
data
-
>
mHost
.
Assign
(
result
.
host
(
)
)
;
data
-
>
mDuration
=
result
.
duration
(
)
;
data
-
>
mIsWorker
=
result
.
isWorker
(
)
;
data
-
>
mIsTopLevel
=
result
.
isTopLevel
(
)
;
data
-
>
mItems
=
items
;
}
mPendingResults
-
-
;
if
(
mPendingResults
)
{
return
;
}
LOG
(
(
"
[
%
s
]
All
data
collected
resolving
promise
"
nsIDToCString
(
mUUID
)
.
get
(
)
)
)
;
mPromise
-
>
MaybeResolve
(
mData
)
;
mCollector
-
>
ForgetAggregatedResults
(
mUUID
)
;
}
void
AggregatedResults
:
:
SetNumResultsRequired
(
uint32_t
aNumResultsRequired
)
{
MOZ_ASSERT
(
!
mPendingResults
&
&
aNumResultsRequired
)
;
mPendingResults
=
aNumResultsRequired
;
}
PerformanceMetricsCollector
*
gInstance
=
nullptr
;
PerformanceMetricsCollector
:
:
~
PerformanceMetricsCollector
(
)
{
MOZ_ASSERT
(
gInstance
=
=
this
)
;
gInstance
=
nullptr
;
}
void
PerformanceMetricsCollector
:
:
ForgetAggregatedResults
(
const
nsID
&
aUUID
)
{
MOZ_ASSERT
(
gInstance
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
RefPtr
<
PerformanceMetricsCollector
>
kungFuDeathGrip
=
this
;
LOG
(
(
"
[
%
s
]
Removing
from
the
table
"
nsIDToCString
(
aUUID
)
.
get
(
)
)
)
;
mAggregatedResults
.
Remove
(
aUUID
)
;
}
void
PerformanceMetricsCollector
:
:
RequestMetrics
(
dom
:
:
Promise
*
aPromise
)
{
MOZ_ASSERT
(
aPromise
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
RefPtr
<
PerformanceMetricsCollector
>
pmc
=
gInstance
;
if
(
!
pmc
)
{
pmc
=
new
PerformanceMetricsCollector
(
)
;
gInstance
=
pmc
;
}
pmc
-
>
RequestMetricsInternal
(
aPromise
)
;
}
void
PerformanceMetricsCollector
:
:
RequestMetricsInternal
(
dom
:
:
Promise
*
aPromise
)
{
nsID
uuid
;
nsresult
rv
=
nsContentUtils
:
:
GenerateUUIDInPlace
(
uuid
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aPromise
-
>
MaybeReject
(
rv
)
;
return
;
}
LOG
(
(
"
[
%
s
]
Requesting
Performance
Metrics
"
nsIDToCString
(
uuid
)
.
get
(
)
)
)
;
nsTArray
<
ContentParent
*
>
children
;
ContentParent
:
:
GetAll
(
children
)
;
uint32_t
numChildren
=
children
.
Length
(
)
;
LOG
(
(
"
[
%
s
]
Expecting
%
d
results
back
"
nsIDToCString
(
uuid
)
.
get
(
)
numChildren
+
1
)
)
;
UniquePtr
<
AggregatedResults
>
results
=
MakeUnique
<
AggregatedResults
>
(
uuid
this
aPromise
)
;
results
-
>
SetNumResultsRequired
(
numChildren
+
1
)
;
mAggregatedResults
.
Put
(
uuid
std
:
:
move
(
results
)
)
;
for
(
uint32_t
i
=
0
;
i
<
numChildren
;
i
+
+
)
{
if
(
NS_WARN_IF
(
!
children
[
i
]
-
>
SendRequestPerformanceMetrics
(
uuid
)
)
)
{
LOG
(
(
"
[
%
s
]
Failed
to
send
request
to
child
%
d
"
nsIDToCString
(
uuid
)
.
get
(
)
i
)
)
;
mAggregatedResults
.
GetValue
(
uuid
)
-
>
get
(
)
-
>
Abort
(
NS_ERROR_FAILURE
)
;
return
;
}
}
nsTArray
<
PerformanceInfo
>
info
;
CollectPerformanceInfo
(
info
)
;
DataReceived
(
uuid
info
)
;
}
nsresult
PerformanceMetricsCollector
:
:
DataReceived
(
const
nsID
&
aUUID
const
nsTArray
<
PerformanceInfo
>
&
aMetrics
)
{
MOZ_ASSERT
(
gInstance
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
gInstance
-
>
DataReceivedInternal
(
aUUID
aMetrics
)
;
}
nsresult
PerformanceMetricsCollector
:
:
DataReceivedInternal
(
const
nsID
&
aUUID
const
nsTArray
<
PerformanceInfo
>
&
aMetrics
)
{
MOZ_ASSERT
(
gInstance
=
=
this
)
;
UniquePtr
<
AggregatedResults
>
*
results
=
mAggregatedResults
.
GetValue
(
aUUID
)
;
if
(
!
results
)
{
return
NS_ERROR_FAILURE
;
}
LOG
(
(
"
[
%
s
]
Received
one
PerformanceInfo
array
"
nsIDToCString
(
aUUID
)
.
get
(
)
)
)
;
AggregatedResults
*
aggregatedResults
=
results
-
>
get
(
)
;
MOZ_ASSERT
(
aggregatedResults
)
;
aggregatedResults
-
>
AppendResult
(
aMetrics
)
;
return
NS_OK
;
}
}
