"
use
strict
"
;
const
paymentSrv
=
Cc
[
"
mozilla
.
org
/
dom
/
payments
/
payment
-
request
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPaymentRequestService
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MasterPassword
"
"
resource
:
/
/
formautofill
/
MasterPassword
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
profileStorage
"
(
)
=
>
{
let
profileStorage
;
try
{
profileStorage
=
ChromeUtils
.
import
(
"
resource
:
/
/
formautofill
/
FormAutofillStorage
.
jsm
"
{
}
)
.
profileStorage
;
profileStorage
.
initialize
(
)
;
}
catch
(
ex
)
{
profileStorage
=
null
;
Cu
.
reportError
(
ex
)
;
}
return
profileStorage
;
}
)
;
var
paymentDialogWrapper
=
{
componentsLoaded
:
new
Map
(
)
frame
:
null
mm
:
null
request
:
null
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
async
_convertProfileAddressToPaymentAddress
(
guid
)
{
let
addressData
=
profileStorage
.
addresses
.
get
(
guid
)
;
if
(
!
addressData
)
{
throw
new
Error
(
Shipping
address
not
found
:
{
guid
}
)
;
}
let
address
=
this
.
createPaymentAddress
(
{
country
:
addressData
.
country
addressLines
:
addressData
[
"
street
-
address
"
]
.
split
(
"
\
n
"
)
region
:
addressData
[
"
address
-
level1
"
]
city
:
addressData
[
"
address
-
level2
"
]
postalCode
:
addressData
[
"
postal
-
code
"
]
organization
:
addressData
.
organization
recipient
:
addressData
.
name
phone
:
addressData
.
tel
}
)
;
return
address
;
}
async
_convertProfileBasicCardToPaymentMethodData
(
guid
cardSecurityCode
)
{
let
cardData
=
profileStorage
.
creditCards
.
get
(
guid
)
;
if
(
!
cardData
)
{
throw
new
Error
(
Basic
card
not
found
in
storage
:
{
guid
}
)
;
}
let
cardNumber
;
try
{
cardNumber
=
await
MasterPassword
.
decrypt
(
cardData
[
"
cc
-
number
-
encrypted
"
]
true
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_ABORT
)
{
throw
ex
;
}
return
null
;
}
let
methodData
=
this
.
createBasicCardResponseData
(
{
cardholderName
:
cardData
[
"
cc
-
name
"
]
cardNumber
expiryMonth
:
cardData
[
"
cc
-
exp
-
month
"
]
.
toString
(
)
.
padStart
(
2
"
0
"
)
expiryYear
:
cardData
[
"
cc
-
exp
-
year
"
]
.
toString
(
)
cardSecurityCode
}
)
;
return
methodData
;
}
init
(
requestId
frame
)
{
if
(
!
requestId
|
|
typeof
(
requestId
)
!
=
"
string
"
)
{
throw
new
Error
(
"
Invalid
PaymentRequest
ID
"
)
;
}
this
.
request
=
paymentSrv
.
getPaymentRequestById
(
requestId
)
;
if
(
!
this
.
request
)
{
throw
new
Error
(
PaymentRequest
not
found
:
{
requestId
}
)
;
}
this
.
frame
=
frame
;
this
.
mm
=
frame
.
frameLoader
.
messageManager
;
this
.
mm
.
addMessageListener
(
"
paymentContentToChrome
"
this
)
;
this
.
mm
.
loadFrameScript
(
"
chrome
:
/
/
payments
/
content
/
paymentDialogFrameScript
.
js
"
true
)
;
this
.
frame
.
src
=
"
resource
:
/
/
payments
/
paymentRequest
.
xhtml
"
;
}
createShowResponse
(
{
acceptStatus
methodName
=
"
"
methodData
=
null
payerName
=
"
"
payerEmail
=
"
"
payerPhone
=
"
"
}
)
{
let
showResponse
=
this
.
createComponentInstance
(
Ci
.
nsIPaymentShowActionResponse
)
;
showResponse
.
init
(
this
.
request
.
requestId
acceptStatus
methodName
methodData
payerName
payerEmail
payerPhone
)
;
return
showResponse
;
}
createBasicCardResponseData
(
{
cardholderName
=
"
"
cardNumber
expiryMonth
=
"
"
expiryYear
=
"
"
cardSecurityCode
=
"
"
billingAddress
=
null
}
)
{
const
basicCardResponseData
=
Cc
[
"
mozilla
.
org
/
dom
/
payments
/
basiccard
-
response
-
data
;
1
"
]
.
createInstance
(
Ci
.
nsIBasicCardResponseData
)
;
basicCardResponseData
.
initData
(
cardholderName
cardNumber
expiryMonth
expiryYear
cardSecurityCode
billingAddress
)
;
return
basicCardResponseData
;
}
createPaymentAddress
(
{
country
=
"
"
addressLines
=
[
]
region
=
"
"
city
=
"
"
dependentLocality
=
"
"
postalCode
=
"
"
sortingCode
=
"
"
languageCode
=
"
"
organization
=
"
"
recipient
=
"
"
phone
=
"
"
}
)
{
const
paymentAddress
=
Cc
[
"
mozilla
.
org
/
dom
/
payments
/
payment
-
address
;
1
"
]
.
createInstance
(
Ci
.
nsIPaymentAddress
)
;
const
addressLine
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
for
(
let
line
of
addressLines
)
{
const
address
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
address
.
data
=
line
;
addressLine
.
appendElement
(
address
)
;
}
paymentAddress
.
init
(
country
addressLine
region
city
dependentLocality
postalCode
sortingCode
languageCode
organization
recipient
phone
)
;
return
paymentAddress
;
}
createComponentInstance
(
componentInterface
)
{
let
componentName
;
switch
(
componentInterface
)
{
case
Ci
.
nsIPaymentShowActionResponse
:
{
componentName
=
"
mozilla
.
org
/
dom
/
payments
/
payment
-
show
-
action
-
response
;
1
"
;
break
;
}
case
Ci
.
nsIGeneralResponseData
:
{
componentName
=
"
mozilla
.
org
/
dom
/
payments
/
general
-
response
-
data
;
1
"
;
break
;
}
}
let
component
=
this
.
componentsLoaded
.
get
(
componentName
)
;
if
(
!
component
)
{
component
=
Cc
[
componentName
]
;
this
.
componentsLoaded
.
set
(
componentName
component
)
;
}
return
component
.
createInstance
(
componentInterface
)
;
}
fetchSavedAddresses
(
)
{
let
savedAddresses
=
{
}
;
for
(
let
address
of
profileStorage
.
addresses
.
getAll
(
)
)
{
savedAddresses
[
address
.
guid
]
=
address
;
}
return
savedAddresses
;
}
fetchSavedPaymentCards
(
)
{
let
savedBasicCards
=
{
}
;
for
(
let
card
of
profileStorage
.
creditCards
.
getAll
(
)
)
{
savedBasicCards
[
card
.
guid
]
=
card
;
delete
card
[
"
cc
-
number
-
encrypted
"
]
;
}
return
savedBasicCards
;
}
onAutofillStorageChange
(
)
{
this
.
mm
.
sendAsyncMessage
(
"
paymentChromeToContent
"
{
messageType
:
"
updateState
"
data
:
{
savedAddresses
:
this
.
fetchSavedAddresses
(
)
savedBasicCards
:
this
.
fetchSavedPaymentCards
(
)
}
}
)
;
}
initializeFrame
(
)
{
let
requestSerialized
=
JSON
.
parse
(
JSON
.
stringify
(
this
.
request
)
)
;
let
displayHost
=
this
.
request
.
topLevelPrincipal
.
URI
.
displayHost
;
requestSerialized
.
topLevelPrincipal
=
{
URI
:
{
displayHost
}
}
;
this
.
mm
.
sendAsyncMessage
(
"
paymentChromeToContent
"
{
messageType
:
"
showPaymentRequest
"
data
:
{
request
:
requestSerialized
savedAddresses
:
this
.
fetchSavedAddresses
(
)
savedBasicCards
:
this
.
fetchSavedPaymentCards
(
)
}
}
)
;
Services
.
obs
.
addObserver
(
this
"
formautofill
-
storage
-
changed
"
true
)
;
}
debugFrame
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
false
)
)
{
Cu
.
reportError
(
"
devtools
.
chrome
.
enabled
must
be
enabled
to
debug
the
frame
"
)
;
return
;
}
let
chromeWindow
=
Services
.
wm
.
getMostRecentWindow
(
null
)
;
let
{
gDevToolsBrowser
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
framework
/
gDevTools
.
jsm
"
{
}
)
;
gDevToolsBrowser
.
openContentProcessToolbox
(
{
selectedBrowser
:
chromeWindow
.
document
.
getElementById
(
"
paymentRequestFrame
"
)
.
frameLoader
}
)
;
}
onPaymentCancel
(
)
{
const
showResponse
=
this
.
createShowResponse
(
{
acceptStatus
:
Ci
.
nsIPaymentActionResponse
.
PAYMENT_REJECTED
}
)
;
paymentSrv
.
respondPayment
(
showResponse
)
;
window
.
close
(
)
;
}
async
onPay
(
{
selectedPaymentCardGUID
:
paymentCardGUID
selectedPaymentCardSecurityCode
:
cardSecurityCode
}
)
{
let
methodData
=
await
this
.
_convertProfileBasicCardToPaymentMethodData
(
paymentCardGUID
cardSecurityCode
)
;
if
(
!
methodData
)
{
Cu
.
reportError
(
"
Bug
1429265
/
Bug
1429205
:
User
canceled
master
password
entry
"
)
;
return
;
}
this
.
pay
(
{
methodName
:
"
basic
-
card
"
methodData
}
)
;
}
pay
(
{
payerName
payerEmail
payerPhone
methodName
methodData
}
)
{
const
showResponse
=
this
.
createShowResponse
(
{
acceptStatus
:
Ci
.
nsIPaymentActionResponse
.
PAYMENT_ACCEPTED
payerName
payerEmail
payerPhone
methodName
methodData
}
)
;
paymentSrv
.
respondPayment
(
showResponse
)
;
}
async
onChangeShippingAddress
(
{
shippingAddressGUID
}
)
{
let
address
=
await
this
.
_convertProfileAddressToPaymentAddress
(
shippingAddressGUID
)
;
paymentSrv
.
changeShippingAddress
(
this
.
request
.
requestId
address
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
formautofill
-
storage
-
changed
"
:
{
if
(
data
=
=
"
notifyUsed
"
)
{
break
;
}
this
.
onAutofillStorageChange
(
)
;
break
;
}
}
}
receiveMessage
(
{
data
}
)
{
let
{
messageType
}
=
data
;
switch
(
messageType
)
{
case
"
debugFrame
"
:
{
this
.
debugFrame
(
)
;
break
;
}
case
"
initializeRequest
"
:
{
this
.
initializeFrame
(
)
;
break
;
}
case
"
changeShippingAddress
"
:
{
this
.
onChangeShippingAddress
(
data
)
;
break
;
}
case
"
paymentCancel
"
:
{
this
.
onPaymentCancel
(
)
;
break
;
}
case
"
pay
"
:
{
this
.
onPay
(
data
)
;
break
;
}
}
}
}
;
if
(
"
document
"
in
this
)
{
let
frame
=
document
.
getElementById
(
"
paymentRequestFrame
"
)
;
let
requestId
=
(
new
URLSearchParams
(
window
.
location
.
search
)
)
.
get
(
"
requestId
"
)
;
paymentDialogWrapper
.
init
(
requestId
frame
)
;
}
