"
use
strict
"
;
class
ShippingOptionPicker
extends
PaymentStateSubscriberMixin
(
HTMLElement
)
{
constructor
(
)
{
super
(
)
;
this
.
dropdown
=
document
.
createElement
(
"
rich
-
select
"
)
;
this
.
dropdown
.
addEventListener
(
"
change
"
this
)
;
}
connectedCallback
(
)
{
this
.
appendChild
(
this
.
dropdown
)
;
super
.
connectedCallback
(
)
;
}
render
(
state
)
{
let
{
shippingOptions
}
=
state
.
request
.
paymentDetails
;
let
desiredOptions
=
[
]
;
for
(
let
option
of
shippingOptions
)
{
let
optionEl
=
this
.
dropdown
.
getOptionByValue
(
option
.
id
)
;
if
(
!
optionEl
)
{
optionEl
=
document
.
createElement
(
"
shipping
-
option
"
)
;
optionEl
.
value
=
option
.
id
;
}
optionEl
.
label
=
option
.
label
;
optionEl
.
amountCurrency
=
option
.
amount
.
currency
;
optionEl
.
amountValue
=
option
.
amount
.
value
;
desiredOptions
.
push
(
optionEl
)
;
}
let
el
=
null
;
while
(
(
el
=
this
.
dropdown
.
popupBox
.
querySelector
(
"
:
scope
>
shipping
-
option
"
)
)
)
{
el
.
remove
(
)
;
}
for
(
let
option
of
desiredOptions
)
{
this
.
dropdown
.
popupBox
.
appendChild
(
option
)
;
}
let
selectedShippingOption
=
state
.
selectedShippingOption
;
let
selectedOptionEl
=
this
.
dropdown
.
getOptionByValue
(
selectedShippingOption
)
;
if
(
selectedShippingOption
&
&
!
selectedOptionEl
)
{
throw
new
Error
(
Selected
shipping
option
{
selectedShippingOption
}
+
does
not
exist
in
option
elements
)
;
}
this
.
dropdown
.
selectedOption
=
selectedOptionEl
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
change
"
:
{
this
.
onChange
(
event
)
;
break
;
}
}
}
onChange
(
event
)
{
let
select
=
event
.
target
;
let
selectedOptionId
=
select
.
selectedOption
&
&
select
.
selectedOption
.
value
;
this
.
requestStore
.
setState
(
{
selectedShippingOption
:
selectedOptionId
}
)
;
}
}
customElements
.
define
(
"
shipping
-
option
-
picker
"
ShippingOptionPicker
)
;
