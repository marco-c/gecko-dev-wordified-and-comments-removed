const
{
PrintUtils
Services
AppConstants
}
=
window
.
docShell
.
chromeEventHandler
.
ownerGlobal
;
ChromeUtils
.
defineModuleGetter
(
this
"
DownloadPaths
"
"
resource
:
/
/
gre
/
modules
/
DownloadPaths
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
const
PDF_JS_URI
=
"
resource
:
/
/
pdf
.
js
/
web
/
viewer
.
html
"
;
const
INPUT_DELAY_MS
=
Cu
.
isInAutomation
?
100
:
500
;
const
MM_PER_POINT
=
25
.
4
/
72
;
const
INCHES_PER_POINT
=
1
/
72
;
const
INCHES_PER_MM
=
1
/
25
.
4
;
const
ourBrowser
=
window
.
docShell
.
chromeEventHandler
;
const
PSSVC
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
var
logger
=
(
function
(
)
{
const
getMaxLogLevel
=
(
)
=
>
Services
.
prefs
.
getBoolPref
(
"
print
.
debug
"
false
)
?
"
all
"
:
"
warn
"
;
let
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
let
_logger
=
new
ConsoleAPI
(
{
prefix
:
"
printUI
"
maxLogLevel
:
getMaxLogLevel
(
)
}
)
;
function
onPrefChange
(
)
{
if
(
_logger
)
{
_logger
.
maxLogLevel
=
getMaxLogLevel
(
)
;
}
}
Services
.
prefs
.
addObserver
(
"
print
.
debug
"
onPrefChange
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
Services
.
prefs
.
removeObserver
(
"
print
.
debug
"
onPrefChange
)
;
}
)
;
return
_logger
;
}
)
(
)
;
function
serializeSettings
(
settings
logPrefix
)
{
let
re
=
/
^
(
k
[
A
-
Z
]
|
resolution
)
/
;
let
types
=
new
Set
(
[
"
string
"
"
boolean
"
"
number
"
"
undefined
"
]
)
;
let
nameValues
=
{
}
;
for
(
let
key
in
settings
)
{
try
{
if
(
!
re
.
test
(
key
)
&
&
types
.
has
(
typeof
settings
[
key
]
)
)
{
nameValues
[
key
]
=
settings
[
key
]
;
}
}
catch
(
e
)
{
logger
.
warn
(
"
Exception
accessing
setting
:
"
key
e
)
;
}
}
return
JSON
.
stringify
(
nameValues
null
2
)
;
}
let
printPending
=
false
;
let
deferredTasks
=
[
]
;
function
createDeferredTask
(
fn
timeout
)
{
let
task
=
new
DeferredTask
(
fn
timeout
)
;
deferredTasks
.
push
(
task
)
;
return
task
;
}
function
cancelDeferredTasks
(
)
{
for
(
let
task
of
deferredTasks
)
{
task
.
disarm
(
)
;
}
PrintEventHandler
.
_updatePrintPreviewTask
?
.
disarm
(
)
;
deferredTasks
=
[
]
;
}
document
.
addEventListener
(
"
DOMContentLoaded
"
e
=
>
{
window
.
_initialized
=
PrintEventHandler
.
init
(
)
.
catch
(
e
=
>
Cu
.
reportError
(
e
)
)
;
ourBrowser
.
setAttribute
(
"
flex
"
"
0
"
)
;
ourBrowser
.
classList
.
add
(
"
printSettingsBrowser
"
)
;
ourBrowser
.
closest
(
"
.
dialogBox
"
)
?
.
classList
.
add
(
"
printDialogBox
"
)
;
}
{
once
:
true
}
)
;
window
.
addEventListener
(
"
dialogclosing
"
(
)
=
>
{
cancelDeferredTasks
(
)
;
}
)
;
window
.
addEventListener
(
"
unload
"
e
=
>
{
document
.
textContent
=
"
"
;
}
{
once
:
true
}
)
;
var
PrintEventHandler
=
{
settings
:
null
defaultSettings
:
null
allPaperSizes
:
{
}
previewIsEmpty
:
false
_delayedChanges
:
{
}
_userChangedSettings
:
{
}
settingFlags
:
{
margins
:
Ci
.
nsIPrintSettings
.
kInitSaveMargins
customMargins
:
Ci
.
nsIPrintSettings
.
kInitSaveMargins
orientation
:
Ci
.
nsIPrintSettings
.
kInitSaveOrientation
paperId
:
Ci
.
nsIPrintSettings
.
kInitSavePaperSize
|
Ci
.
nsIPrintSettings
.
kInitSaveUnwriteableMargins
printInColor
:
Ci
.
nsIPrintSettings
.
kInitSaveInColor
scaling
:
Ci
.
nsIPrintSettings
.
kInitSaveScaling
shrinkToFit
:
Ci
.
nsIPrintSettings
.
kInitSaveShrinkToFit
printDuplex
:
Ci
.
nsIPrintSettings
.
kInitSaveDuplex
printFootersHeaders
:
Ci
.
nsIPrintSettings
.
kInitSaveHeaderLeft
|
Ci
.
nsIPrintSettings
.
kInitSaveHeaderCenter
|
Ci
.
nsIPrintSettings
.
kInitSaveHeaderRight
|
Ci
.
nsIPrintSettings
.
kInitSaveFooterLeft
|
Ci
.
nsIPrintSettings
.
kInitSaveFooterCenter
|
Ci
.
nsIPrintSettings
.
kInitSaveFooterRight
printBackgrounds
:
Ci
.
nsIPrintSettings
.
kInitSaveBGColors
|
Ci
.
nsIPrintSettings
.
kInitSaveBGImages
}
topContentTitle
:
null
topCurrentURI
:
null
activeContentTitle
:
null
activeCurrentURI
:
null
get
activeURI
(
)
{
return
this
.
viewSettings
.
sourceVersion
=
=
"
selection
"
?
this
.
activeCurrentURI
:
this
.
topCurrentURI
;
}
get
activeTitle
(
)
{
return
this
.
viewSettings
.
sourceVersion
=
=
"
selection
"
?
this
.
activeContentTitle
:
this
.
topContentTitle
;
}
_nonFlaggedUpdatePreviewSettings
:
new
Set
(
[
"
pageRanges
"
"
numPagesPerSheet
"
"
sourceVersion
"
]
)
_noPreviewUpdateSettings
:
new
Set
(
[
"
numCopies
"
"
printDuplex
"
]
)
async
init
(
)
{
Services
.
telemetry
.
scalarAdd
(
"
printing
.
preview_opened_tm
"
1
)
;
this
.
printPreviewEl
=
ourBrowser
.
parentElement
.
querySelector
(
"
print
-
preview
"
)
;
let
sourceBrowsingContext
=
this
.
printPreviewEl
.
getSourceBrowsingContext
(
)
;
let
args
=
window
.
arguments
[
0
]
;
this
.
printFrameOnly
=
args
.
getProperty
(
"
printFrameOnly
"
)
;
this
.
printSelectionOnly
=
args
.
getProperty
(
"
printSelectionOnly
"
)
;
this
.
isArticle
=
args
.
getProperty
(
"
isArticle
"
)
;
this
.
hasSelection
=
await
this
.
checkForSelection
(
sourceBrowsingContext
)
;
let
sourcePrincipal
=
sourceBrowsingContext
.
currentWindowGlobal
.
documentPrincipal
;
let
sourceIsPdf
=
!
sourcePrincipal
.
isNullPrincipal
&
&
sourcePrincipal
.
spec
=
=
PDF_JS_URI
;
this
.
activeContentTitle
=
sourceBrowsingContext
.
currentWindowContext
.
documentTitle
;
this
.
activeCurrentURI
=
sourceBrowsingContext
.
currentWindowContext
.
documentURI
.
spec
;
let
topWindowContext
=
sourceBrowsingContext
.
top
.
currentWindowContext
;
this
.
topContentTitle
=
topWindowContext
.
documentTitle
;
this
.
topCurrentURI
=
topWindowContext
.
documentURI
.
spec
;
let
canPrintSelectionOnly
=
this
.
hasSelection
&
&
this
.
printPreviewEl
.
canPrintSelectionOnly
;
if
(
!
canPrintSelectionOnly
&
&
!
this
.
isArticle
)
{
document
.
getElementById
(
"
source
-
version
-
section
"
)
.
hidden
=
true
;
}
else
{
document
.
getElementById
(
"
source
-
version
-
selection
"
)
.
hidden
=
!
canPrintSelectionOnly
;
document
.
getElementById
(
"
source
-
version
-
simplified
"
)
.
hidden
=
!
this
.
isArticle
;
}
sourceBrowsingContext
=
undefined
;
this
.
printProgressIndicator
=
document
.
getElementById
(
"
print
-
progress
"
)
;
this
.
printForm
=
document
.
getElementById
(
"
print
"
)
;
if
(
sourceIsPdf
)
{
this
.
printForm
.
removeNonPdfSettings
(
)
;
}
await
ourBrowser
.
_dialogReady
;
let
destinations
defaultSystemPrinter
fallbackPaperList
selectedPrinter
printersByName
;
try
{
(
{
destinations
defaultSystemPrinter
fallbackPaperList
selectedPrinter
printersByName
}
=
await
this
.
getPrintDestinations
(
)
)
;
}
catch
(
e
)
{
this
.
reportPrintingError
(
"
PRINT_DESTINATIONS
"
)
;
throw
e
;
}
PrintSettingsViewProxy
.
availablePrinters
=
printersByName
;
PrintSettingsViewProxy
.
fallbackPaperList
=
fallbackPaperList
;
PrintSettingsViewProxy
.
defaultSystemPrinter
=
defaultSystemPrinter
;
PrintSettingsViewProxy
.
_sourceVersion
=
canPrintSelectionOnly
&
&
this
.
printSelectionOnly
?
"
selection
"
:
"
source
"
;
logger
.
debug
(
"
availablePrinters
:
"
Object
.
keys
(
printersByName
)
)
;
logger
.
debug
(
"
defaultSystemPrinter
:
"
defaultSystemPrinter
)
;
document
.
addEventListener
(
"
print
"
async
(
)
=
>
{
let
cancelButton
=
document
.
getElementById
(
"
cancel
-
button
"
)
;
document
.
l10n
.
setAttributes
(
cancelButton
cancelButton
.
dataset
.
closeL10nId
)
;
let
didPrint
=
await
this
.
print
(
)
;
if
(
!
didPrint
)
{
this
.
printForm
.
enable
(
)
;
}
document
.
l10n
.
setAttributes
(
cancelButton
cancelButton
.
dataset
.
cancelL10nId
)
;
}
)
;
this
.
_createDelayedSettingsChangeTask
(
)
;
document
.
addEventListener
(
"
update
-
print
-
settings
"
e
=
>
{
this
.
handleSettingsChange
(
e
.
detail
)
;
}
)
;
document
.
addEventListener
(
"
cancel
-
print
-
settings
"
e
=
>
{
this
.
_delayedSettingsChangeTask
.
disarm
(
)
;
for
(
let
setting
of
Object
.
keys
(
e
.
detail
)
)
{
delete
this
.
_delayedChanges
[
setting
]
;
}
}
)
;
document
.
addEventListener
(
"
cancel
-
print
"
(
)
=
>
this
.
cancelPrint
(
)
)
;
document
.
addEventListener
(
"
open
-
system
-
dialog
"
async
(
)
=
>
{
let
sourceBrowser
=
this
.
printPreviewEl
.
getSourceBrowsingContext
(
)
.
top
.
embedderElement
;
let
dialogBoxManager
=
PrintUtils
.
getTabDialogBox
(
sourceBrowser
)
.
getTabDialogManager
(
)
;
dialogBoxManager
.
hideDialog
(
sourceBrowser
)
;
let
settings
=
this
.
settings
.
printerName
=
=
PrintUtils
.
SAVE_TO_PDF_PRINTER
?
PrintUtils
.
getPrintSettings
(
this
.
viewSettings
.
defaultSystemPrinter
)
:
this
.
settings
.
clone
(
)
;
settings
.
showPrintProgress
=
false
;
settings
.
isPrintSelectionRBEnabled
=
this
.
hasSelection
;
settings
.
title
=
this
.
activeTitle
;
const
PRINTPROMPTSVC
=
Cc
[
"
mozilla
.
org
/
embedcomp
/
printingprompt
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintingPromptService
)
;
try
{
Services
.
telemetry
.
scalarAdd
(
"
printing
.
dialog_opened_via_preview_tm
"
1
)
;
await
this
.
_showPrintDialog
(
PRINTPROMPTSVC
window
settings
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_ABORT
)
{
Services
.
telemetry
.
scalarAdd
(
"
printing
.
dialog_via_preview_cancelled_tm
"
1
)
;
window
.
close
(
)
;
return
;
}
throw
e
;
}
await
this
.
print
(
settings
)
;
}
)
;
let
settingsToChange
=
await
this
.
refreshSettings
(
selectedPrinter
.
value
)
;
await
this
.
updateSettings
(
settingsToChange
true
)
;
let
initialPreviewDone
=
this
.
_updatePrintPreview
(
)
;
this
.
_createUpdatePrintPreviewTask
(
initialPreviewDone
)
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
available
-
destinations
"
{
detail
:
destinations
}
)
)
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
print
-
settings
"
{
detail
:
this
.
viewSettings
}
)
)
;
document
.
body
.
removeAttribute
(
"
loading
"
)
;
await
new
Promise
(
resolve
=
>
window
.
requestAnimationFrame
(
resolve
)
)
;
window
.
focus
(
)
;
let
fm
=
Services
.
focus
;
fm
.
setFocus
(
document
.
getElementById
(
"
printer
-
picker
"
)
fm
.
FLAG_SHOWRING
)
;
await
initialPreviewDone
;
}
async
checkForSelection
(
browsingContext
)
{
try
{
let
sourceActor
=
browsingContext
.
currentWindowGlobal
.
getActor
(
"
PrintingSelection
"
)
;
return
await
sourceActor
.
sendQuery
(
"
PrintingSelection
:
HasSelection
"
{
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
false
;
}
async
print
(
systemDialogSettings
)
{
this
.
printForm
.
disable
(
)
;
if
(
Object
.
keys
(
this
.
_delayedChanges
)
.
length
)
{
let
task
=
this
.
_delayedSettingsChangeTask
;
this
.
_createDelayedSettingsChangeTask
(
)
;
await
task
.
finalize
(
)
;
}
if
(
this
.
settings
.
pageRanges
.
length
)
{
let
task
=
this
.
_updatePrintPreviewTask
;
this
.
_createUpdatePrintPreviewTask
(
)
;
await
task
.
finalize
(
)
;
}
if
(
!
this
.
printForm
.
checkValidity
(
)
|
|
this
.
previewIsEmpty
)
{
return
false
;
}
let
settings
=
systemDialogSettings
|
|
this
.
settings
;
if
(
settings
.
printerName
=
=
PrintUtils
.
SAVE_TO_PDF_PRINTER
)
{
try
{
settings
.
toFileName
=
await
pickFileName
(
this
.
activeTitle
this
.
activeURI
)
;
}
catch
(
e
)
{
return
false
;
}
}
await
window
.
_initialized
;
Services
.
prefs
.
setStringPref
(
"
print_printer
"
settings
.
printerName
)
;
try
{
this
.
settings
.
showPrintProgress
=
false
;
let
l10nId
=
settings
.
printerName
=
=
PrintUtils
.
SAVE_TO_PDF_PRINTER
?
"
printui
-
print
-
progress
-
indicator
-
saving
"
:
"
printui
-
print
-
progress
-
indicator
"
;
document
.
l10n
.
setAttributes
(
this
.
printProgressIndicator
l10nId
)
;
this
.
printProgressIndicator
.
hidden
=
false
;
let
bc
=
this
.
printPreviewEl
.
currentBrowsingContext
;
await
this
.
_doPrint
(
bc
settings
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
settings
.
printerName
=
=
PrintUtils
.
SAVE_TO_PDF_PRINTER
)
{
let
prefName
=
"
print
.
printer_
"
+
settings
.
printerName
.
replace
(
/
/
g
"
_
"
)
+
"
.
print_to_filename
"
;
Services
.
prefs
.
clearUserPref
(
prefName
)
;
}
window
.
close
(
)
;
return
true
;
}
_doPrint
(
aBrowsingContext
aSettings
)
{
return
aBrowsingContext
.
print
(
aSettings
)
;
}
cancelPrint
(
)
{
Services
.
telemetry
.
scalarAdd
(
"
printing
.
preview_cancelled_tm
"
1
)
;
window
.
close
(
)
;
}
async
refreshSettings
(
printerName
)
{
this
.
currentPrinterName
=
printerName
;
let
currentPrinter
;
try
{
currentPrinter
=
await
PrintSettingsViewProxy
.
resolvePropertiesForPrinter
(
printerName
)
;
}
catch
(
e
)
{
this
.
reportPrintingError
(
"
PRINTER_PROPERTIES
"
)
;
throw
e
;
}
if
(
this
.
currentPrinterName
!
=
printerName
)
{
return
{
}
;
}
this
.
settings
=
currentPrinter
.
settings
;
this
.
defaultSettings
=
currentPrinter
.
defaultSettings
;
this
.
settings
.
printSelectionOnly
=
this
.
printSelectionOnly
;
logger
.
debug
(
"
currentPrinter
name
:
"
printerName
)
;
logger
.
debug
(
"
settings
:
"
serializeSettings
(
this
.
settings
)
)
;
this
.
viewSettings
=
new
Proxy
(
this
.
settings
PrintSettingsViewProxy
)
;
return
this
.
getSettingsToUpdate
(
)
;
}
getSettingsToUpdate
(
)
{
let
settingsToUpdate
=
Object
.
assign
(
{
}
this
.
_userChangedSettings
)
;
if
(
!
this
.
viewSettings
.
supportsColor
)
{
settingsToUpdate
.
printInColor
=
false
;
}
else
if
(
!
this
.
viewSettings
.
supportsMonochrome
)
{
settingsToUpdate
.
printInColor
=
true
;
}
if
(
settingsToUpdate
.
sourceVersion
=
=
"
simplified
"
)
{
if
(
this
.
viewSettings
.
printBackgrounds
)
{
this
.
_userChangedSettings
.
printBackgrounds
=
true
;
}
settingsToUpdate
.
printBackgrounds
=
false
;
}
if
(
settingsToUpdate
.
printInColor
!
=
this
.
_userChangedSettings
.
printInColor
)
{
delete
this
.
_userChangedSettings
.
printInColor
;
}
let
paperId
=
settingsToUpdate
.
paperId
|
|
this
.
viewSettings
.
paperId
;
logger
.
debug
(
"
Using
paperId
:
"
paperId
)
;
logger
.
debug
(
"
Available
paper
sizes
:
"
PrintSettingsViewProxy
.
availablePaperSizes
)
;
let
matchedPaper
=
paperId
&
&
PrintSettingsViewProxy
.
availablePaperSizes
[
paperId
]
;
if
(
!
matchedPaper
)
{
let
paperWidth
paperHeight
paperSizeUnit
;
if
(
settingsToUpdate
.
paperId
)
{
paperId
=
settingsToUpdate
.
paperId
;
let
cachedPaperWrapper
=
this
.
allPaperSizes
[
paperId
]
;
paperWidth
=
cachedPaperWrapper
.
paper
.
width
*
MM_PER_POINT
;
paperHeight
=
cachedPaperWrapper
.
paper
.
height
*
MM_PER_POINT
;
paperSizeUnit
=
PrintEventHandler
.
settings
.
kPaperSizeMillimeters
;
}
else
{
paperId
=
this
.
viewSettings
.
paperId
;
logger
.
debug
(
"
No
paperId
or
matchedPaper
get
a
new
default
from
viewSettings
:
"
paperId
)
;
paperWidth
=
this
.
viewSettings
.
paperWidth
;
paperHeight
=
this
.
viewSettings
.
paperHeight
;
paperSizeUnit
=
this
.
viewSettings
.
paperSizeUnit
;
}
matchedPaper
=
PrintSettingsViewProxy
.
getBestPaperMatch
(
paperWidth
paperHeight
paperSizeUnit
)
;
}
if
(
!
matchedPaper
)
{
matchedPaper
=
Object
.
values
(
PrintSettingsViewProxy
.
availablePaperSizes
)
[
0
]
;
delete
this
.
_userChangedSettings
.
paperId
;
}
if
(
matchedPaper
.
id
!
=
=
paperId
)
{
logger
.
log
(
Requested
paperId
:
"
{
paperId
}
"
missing
on
this
printer
using
:
{
matchedPaper
.
id
}
instead
)
;
delete
this
.
_userChangedSettings
.
paperId
;
}
settingsToUpdate
.
paperId
=
matchedPaper
.
id
;
return
settingsToUpdate
;
}
_createDelayedSettingsChangeTask
(
)
{
this
.
_delayedSettingsChangeTask
=
createDeferredTask
(
async
(
)
=
>
{
if
(
Object
.
keys
(
this
.
_delayedChanges
)
.
length
)
{
let
changes
=
this
.
_delayedChanges
;
this
.
_delayedChanges
=
{
}
;
await
this
.
onUserSettingsChange
(
changes
)
;
}
}
INPUT_DELAY_MS
)
;
}
_createUpdatePrintPreviewTask
(
initialPreviewDone
=
null
)
{
this
.
_updatePrintPreviewTask
=
new
DeferredTask
(
async
(
)
=
>
{
await
initialPreviewDone
;
await
this
.
_updatePrintPreview
(
)
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
preview
-
updated
"
)
)
;
}
0
)
;
}
_scheduleDelayedSettingsChange
(
changes
)
{
Object
.
assign
(
this
.
_delayedChanges
changes
)
;
this
.
_delayedSettingsChangeTask
.
disarm
(
)
;
this
.
_delayedSettingsChangeTask
.
arm
(
)
;
}
handleSettingsChange
(
changedSettings
=
{
}
)
{
let
delayedChanges
=
{
}
;
let
instantChanges
=
{
}
;
for
(
let
[
setting
value
]
of
Object
.
entries
(
changedSettings
)
)
{
switch
(
setting
)
{
case
"
pageRanges
"
:
case
"
scaling
"
:
delayedChanges
[
setting
]
=
value
;
break
;
case
"
customMargins
"
:
delete
this
.
_delayedChanges
.
margins
;
changedSettings
.
margins
=
=
"
custom
"
?
(
delayedChanges
[
setting
]
=
value
)
:
(
instantChanges
[
setting
]
=
value
)
;
break
;
default
:
instantChanges
[
setting
]
=
value
;
break
;
}
}
if
(
Object
.
keys
(
delayedChanges
)
.
length
)
{
this
.
_scheduleDelayedSettingsChange
(
delayedChanges
)
;
}
if
(
Object
.
keys
(
instantChanges
)
.
length
)
{
this
.
onUserSettingsChange
(
instantChanges
)
;
}
}
async
onUserSettingsChange
(
changedSettings
=
{
}
)
{
let
previewableChange
=
false
;
for
(
let
[
setting
value
]
of
Object
.
entries
(
changedSettings
)
)
{
Services
.
telemetry
.
keyedScalarAdd
(
"
printing
.
settings_changed
"
setting
1
)
;
this
.
_userChangedSettings
[
setting
]
=
value
;
if
(
!
this
.
_noPreviewUpdateSettings
.
has
(
setting
)
)
{
previewableChange
=
true
;
}
}
if
(
changedSettings
.
printerName
)
{
logger
.
debug
(
"
onUserSettingsChange
changing
to
printerName
:
"
changedSettings
.
printerName
)
;
this
.
printForm
.
printerChanging
=
true
;
this
.
printForm
.
disable
(
el
=
>
el
.
id
!
=
"
printer
-
picker
"
)
;
let
{
printerName
}
=
changedSettings
;
changedSettings
=
await
this
.
refreshSettings
(
printerName
)
;
if
(
printerName
!
=
this
.
currentPrinterName
)
{
return
;
}
this
.
printForm
.
printerChanging
=
false
;
this
.
printForm
.
enable
(
)
;
}
else
{
changedSettings
=
this
.
getSettingsToUpdate
(
)
;
}
let
shouldPreviewUpdate
=
(
await
this
.
updateSettings
(
changedSettings
!
!
changedSettings
.
printerName
)
)
&
&
previewableChange
;
if
(
shouldPreviewUpdate
&
&
!
printPending
)
{
this
.
updatePrintPreview
(
)
;
}
document
.
dispatchEvent
(
new
CustomEvent
(
"
print
-
settings
"
{
detail
:
this
.
viewSettings
}
)
)
;
}
async
updateSettings
(
changedSettings
=
{
}
printerChanged
=
false
)
{
let
updatePreviewWithoutFlag
=
false
;
let
flags
=
0
;
logger
.
debug
(
"
updateSettings
"
changedSettings
printerChanged
)
;
if
(
printerChanged
|
|
changedSettings
.
paperId
)
{
try
{
let
paperWrapper
=
await
PrintSettingsViewProxy
.
fetchPaperMargins
(
changedSettings
.
paperId
|
|
this
.
viewSettings
.
paperId
)
;
let
paperHeightInInches
=
paperWrapper
.
paper
.
height
*
INCHES_PER_POINT
;
let
paperWidthInInches
=
paperWrapper
.
paper
.
width
*
INCHES_PER_POINT
;
let
height
=
(
changedSettings
.
orientation
|
|
this
.
viewSettings
.
orientation
)
=
=
0
?
paperHeightInInches
:
paperWidthInInches
;
let
width
=
(
changedSettings
.
orientation
|
|
this
.
viewSettings
.
orientation
)
=
=
0
?
paperWidthInInches
:
paperHeightInInches
;
if
(
parseFloat
(
this
.
viewSettings
.
customMargins
.
marginTop
)
+
parseFloat
(
this
.
viewSettings
.
customMargins
.
marginBottom
)
>
height
-
paperWrapper
.
unwriteableMarginTop
-
paperWrapper
.
unwriteableMarginBottom
|
|
this
.
viewSettings
.
customMargins
.
marginTop
<
0
|
|
this
.
viewSettings
.
customMargins
.
marginBottom
<
0
)
{
let
{
marginTop
marginBottom
}
=
this
.
viewSettings
.
defaultMargins
;
changedSettings
.
marginTop
=
changedSettings
.
customMarginTop
=
marginTop
;
changedSettings
.
marginBottom
=
changedSettings
.
customMarginBottom
=
marginBottom
;
delete
this
.
_userChangedSettings
.
customMargins
;
}
if
(
parseFloat
(
this
.
viewSettings
.
customMargins
.
marginRight
)
+
parseFloat
(
this
.
viewSettings
.
customMargins
.
marginLeft
)
>
width
-
paperWrapper
.
unwriteableMarginRight
-
paperWrapper
.
unwriteableMarginLeft
|
|
this
.
viewSettings
.
customMargins
.
marginLeft
<
0
|
|
this
.
viewSettings
.
customMargins
.
marginRight
<
0
)
{
let
{
marginLeft
marginRight
}
=
this
.
viewSettings
.
defaultMargins
;
changedSettings
.
marginLeft
=
changedSettings
.
customMarginLeft
=
marginLeft
;
changedSettings
.
marginRight
=
changedSettings
.
customMarginRight
=
marginRight
;
delete
this
.
_userChangedSettings
.
customMargins
;
}
}
catch
(
e
)
{
this
.
reportPrintingError
(
"
PAPER_MARGINS
"
)
;
throw
e
;
}
}
for
(
let
[
setting
value
]
of
Object
.
entries
(
changedSettings
)
)
{
if
(
this
.
viewSettings
[
setting
]
!
=
value
|
|
(
printerChanged
&
&
setting
=
=
"
paperId
"
)
)
{
if
(
setting
=
=
"
pageRanges
"
)
{
if
(
!
this
.
viewSettings
[
setting
]
.
length
&
&
!
value
.
length
)
{
continue
;
}
}
this
.
viewSettings
[
setting
]
=
value
;
if
(
setting
in
this
.
settingFlags
&
&
setting
in
this
.
_userChangedSettings
)
{
flags
|
=
this
.
settingFlags
[
setting
]
;
}
updatePreviewWithoutFlag
|
=
this
.
_nonFlaggedUpdatePreviewSettings
.
has
(
setting
)
;
}
}
let
shouldPreviewUpdate
=
flags
|
|
printerChanged
|
|
updatePreviewWithoutFlag
;
logger
.
debug
(
"
updateSettings
calculated
flags
:
"
flags
"
shouldPreviewUpdate
:
"
shouldPreviewUpdate
)
;
if
(
flags
)
{
this
.
saveSettingsToPrefs
(
flags
)
;
}
return
shouldPreviewUpdate
;
}
saveSettingsToPrefs
(
flags
)
{
PSSVC
.
savePrintSettingsToPrefs
(
this
.
settings
true
flags
)
;
}
async
updatePrintPreview
(
)
{
this
.
_updatePrintPreviewTask
.
arm
(
)
;
}
async
_updatePrintPreview
(
)
{
let
{
settings
}
=
this
;
settings
.
showPrintProgress
=
false
;
const
isFirstCall
=
!
this
.
printInitiationTime
;
if
(
isFirstCall
)
{
let
params
=
new
URLSearchParams
(
location
.
search
)
;
this
.
printInitiationTime
=
parseInt
(
params
.
get
(
"
printInitiationTime
"
)
10
)
;
const
elapsed
=
Date
.
now
(
)
-
this
.
printInitiationTime
;
Services
.
telemetry
.
getHistogramById
(
"
PRINT_INIT_TO_PLATFORM_SENT_SETTINGS_MS
"
)
.
add
(
elapsed
)
;
}
let
totalPageCount
sheetCount
isEmpty
orientation
;
try
{
let
{
sourceVersion
}
=
this
.
viewSettings
;
let
sourceURI
=
this
.
activeURI
;
this
.
_lastPrintPreviewSettings
=
settings
;
(
{
totalPageCount
sheetCount
isEmpty
orientation
}
=
await
this
.
printPreviewEl
.
printPreview
(
settings
{
sourceVersion
sourceURI
}
)
)
;
}
catch
(
e
)
{
this
.
reportPrintingError
(
"
PRINT_PREVIEW
"
)
;
Cu
.
reportError
(
e
)
;
throw
e
;
}
if
(
orientation
!
=
"
unspecified
"
)
{
const
kIPrintSettings
=
Ci
.
nsIPrintSettings
;
settings
.
orientation
=
orientation
=
=
"
landscape
"
?
kIPrintSettings
.
kLandscapeOrientation
:
kIPrintSettings
.
kPortraitOrientation
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
hide
-
orientation
"
)
)
;
}
this
.
previewIsEmpty
=
isEmpty
;
if
(
this
.
previewIsEmpty
)
{
this
.
viewSettings
.
pageRanges
=
[
]
;
this
.
updatePrintPreview
(
)
;
}
settings
.
isPrintSelectionRBEnabled
=
this
.
hasSelection
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
page
-
count
"
{
detail
:
{
sheetCount
totalPages
:
totalPageCount
}
}
)
)
;
if
(
isFirstCall
)
{
const
elapsed
=
Date
.
now
(
)
-
this
.
printInitiationTime
;
Services
.
telemetry
.
getHistogramById
(
"
PRINT_INIT_TO_PREVIEW_DOC_SHOWN_MS
"
)
.
add
(
elapsed
)
;
}
}
async
getPrintDestinations
(
)
{
const
printerList
=
Cc
[
"
mozilla
.
org
/
gfx
/
printerlist
;
1
"
]
.
createInstance
(
Ci
.
nsIPrinterList
)
;
let
printers
;
if
(
Cu
.
isInAutomation
)
{
printers
=
window
.
_mockPrinters
|
|
[
]
;
}
else
{
try
{
printers
=
await
printerList
.
printers
;
}
catch
(
e
)
{
this
.
reportPrintingError
(
"
PRINTER_LIST
"
)
;
throw
e
;
}
}
let
fallbackPaperList
;
try
{
fallbackPaperList
=
await
printerList
.
fallbackPaperList
;
}
catch
(
e
)
{
this
.
reportPrintingError
(
"
FALLBACK_PAPER_LIST
"
)
;
throw
e
;
}
let
lastUsedPrinterName
;
try
{
lastUsedPrinterName
=
PSSVC
.
lastUsedPrinterName
;
}
catch
(
e
)
{
this
.
reportPrintingError
(
"
LAST_USED_PRINTER
"
)
;
throw
e
;
}
const
defaultPrinterName
=
printerList
.
systemDefaultPrinterName
;
const
printersByName
=
{
}
;
let
lastUsedPrinter
;
let
defaultSystemPrinter
;
let
saveToPdfPrinter
=
{
nameId
:
"
printui
-
destination
-
pdf
-
label
"
value
:
PrintUtils
.
SAVE_TO_PDF_PRINTER
}
;
printersByName
[
PrintUtils
.
SAVE_TO_PDF_PRINTER
]
=
{
supportsColor
:
true
supportsMonochrome
:
false
name
:
PrintUtils
.
SAVE_TO_PDF_PRINTER
}
;
if
(
lastUsedPrinterName
=
=
PrintUtils
.
SAVE_TO_PDF_PRINTER
)
{
lastUsedPrinter
=
saveToPdfPrinter
;
}
let
destinations
=
[
saveToPdfPrinter
.
.
.
printers
.
map
(
printer
=
>
{
printer
.
QueryInterface
(
Ci
.
nsIPrinter
)
;
const
{
name
}
=
printer
;
printersByName
[
printer
.
name
]
=
{
printer
}
;
const
destination
=
{
name
value
:
name
}
;
if
(
name
=
=
lastUsedPrinterName
)
{
lastUsedPrinter
=
destination
;
}
if
(
name
=
=
defaultPrinterName
)
{
defaultSystemPrinter
=
destination
;
}
return
destination
;
}
)
]
;
let
selectedPrinter
=
lastUsedPrinter
|
|
defaultSystemPrinter
|
|
saveToPdfPrinter
;
return
{
destinations
fallbackPaperList
selectedPrinter
printersByName
defaultSystemPrinter
}
;
}
getMarginPresets
(
marginSize
paperWrapper
)
{
switch
(
marginSize
)
{
case
"
minimum
"
:
{
let
marginSource
=
paperWrapper
|
|
this
.
defaultSettings
;
return
{
marginTop
:
marginSource
.
unwriteableMarginTop
marginRight
:
marginSource
.
unwriteableMarginRight
marginBottom
:
marginSource
.
unwriteableMarginBottom
marginLeft
:
marginSource
.
unwriteableMarginLeft
}
;
}
case
"
none
"
:
return
{
marginTop
:
0
marginLeft
:
0
marginBottom
:
0
marginRight
:
0
}
;
case
"
custom
"
:
return
{
marginTop
:
PrintSettingsViewProxy
.
_lastCustomMarginValues
.
marginTop
?
?
this
.
settings
.
marginTop
marginBottom
:
PrintSettingsViewProxy
.
_lastCustomMarginValues
.
marginBottom
?
?
this
.
settings
.
marginBottom
marginLeft
:
PrintSettingsViewProxy
.
_lastCustomMarginValues
.
marginLeft
?
?
this
.
settings
.
marginLeft
marginRight
:
PrintSettingsViewProxy
.
_lastCustomMarginValues
.
marginRight
?
?
this
.
settings
.
marginRight
}
;
default
:
{
let
minimum
=
this
.
getMarginPresets
(
"
minimum
"
paperWrapper
)
;
return
{
marginTop
:
!
isNaN
(
minimum
.
marginTop
)
?
Math
.
max
(
minimum
.
marginTop
this
.
defaultSettings
.
marginTop
)
:
this
.
defaultSettings
.
marginTop
marginRight
:
!
isNaN
(
minimum
.
marginRight
)
?
Math
.
max
(
minimum
.
marginRight
this
.
defaultSettings
.
marginRight
)
:
this
.
defaultSettings
.
marginRight
marginBottom
:
!
isNaN
(
minimum
.
marginBottom
)
?
Math
.
max
(
minimum
.
marginBottom
this
.
defaultSettings
.
marginBottom
)
:
this
.
defaultSettings
.
marginBottom
marginLeft
:
!
isNaN
(
minimum
.
marginLeft
)
?
Math
.
max
(
minimum
.
marginLeft
this
.
defaultSettings
.
marginLeft
)
:
this
.
defaultSettings
.
marginLeft
}
;
}
}
}
reportPrintingError
(
aMessage
)
{
logger
.
debug
(
"
reportPrintingError
:
"
aMessage
)
;
Services
.
telemetry
.
keyedScalarAdd
(
"
printing
.
error
"
aMessage
1
)
;
}
async
_showPrintDialog
(
aPrintingPromptService
aWindow
aSettings
)
{
return
aPrintingPromptService
.
showPrintDialog
(
aWindow
aSettings
)
;
}
}
;
var
PrintSettingsViewProxy
=
{
get
defaultHeadersAndFooterValues
(
)
{
const
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
let
settingValues
=
{
}
;
for
(
let
[
name
pref
]
of
Object
.
entries
(
this
.
headerFooterSettingsPrefs
)
)
{
settingValues
[
name
]
=
defaultBranch
.
getStringPref
(
pref
)
;
}
Object
.
defineProperty
(
this
"
defaultHeadersAndFooterValues
"
{
value
:
settingValues
}
)
;
return
settingValues
;
}
headerFooterSettingsPrefs
:
{
footerStrCenter
:
"
print
.
print_footercenter
"
footerStrLeft
:
"
print
.
print_footerleft
"
footerStrRight
:
"
print
.
print_footerright
"
headerStrCenter
:
"
print
.
print_headercenter
"
headerStrLeft
:
"
print
.
print_headerleft
"
headerStrRight
:
"
print
.
print_headerright
"
}
_lastCustomMarginValues
:
{
marginTop
:
null
marginBottom
:
null
marginLeft
:
null
marginRight
:
null
}
knownSaveToFilePrinters
:
new
Set
(
[
"
Microsoft
Print
to
PDF
"
"
Adobe
PDF
"
"
Bullzip
PDF
Printer
"
"
CutePDF
Writer
"
"
doPDF
"
"
Foxit
Reader
PDF
Printer
"
"
Nitro
PDF
Creator
"
"
novaPDF
"
"
PDF
-
XChange
"
"
PDF24
PDF
"
"
PDFCreator
"
"
PrimoPDF
"
"
Soda
PDF
"
"
Solid
PDF
Creator
"
"
Universal
Document
Converter
"
"
Microsoft
XPS
Document
Writer
"
]
)
getBestPaperMatch
(
paperWidth
paperHeight
paperSizeUnit
)
{
let
paperSizes
=
Object
.
values
(
this
.
availablePaperSizes
)
;
if
(
!
(
paperWidth
&
&
paperHeight
)
)
{
return
null
;
}
let
unitsPerPoint
;
let
altUnitsPerPoint
;
if
(
paperSizeUnit
=
=
PrintEventHandler
.
settings
.
kPaperSizeMillimeters
)
{
unitsPerPoint
=
MM_PER_POINT
;
altUnitsPerPoint
=
INCHES_PER_POINT
;
}
else
{
unitsPerPoint
=
INCHES_PER_POINT
;
altUnitsPerPoint
=
MM_PER_POINT
;
}
const
equal
=
(
a
b
)
=
>
Math
.
abs
(
a
-
b
)
<
1
;
const
findMatch
=
(
widthPts
heightPts
)
=
>
paperSizes
.
find
(
paperWrapper
=
>
{
let
result
=
equal
(
widthPts
paperWrapper
.
paper
.
width
)
&
&
equal
(
heightPts
paperWrapper
.
paper
.
height
)
;
return
result
;
}
)
;
let
matchedPaper
=
findMatch
(
paperWidth
/
unitsPerPoint
paperHeight
/
unitsPerPoint
)
|
|
findMatch
(
paperWidth
/
altUnitsPerPoint
paperHeight
/
altUnitsPerPoint
)
;
if
(
matchedPaper
)
{
return
matchedPaper
;
}
return
null
;
}
async
fetchPaperMargins
(
paperId
)
{
let
paperWrapper
=
this
.
availablePaperSizes
[
paperId
]
;
if
(
!
paperWrapper
)
{
throw
new
Error
(
"
Can
'
t
fetchPaperMargins
:
"
+
paperId
)
;
}
if
(
paperWrapper
.
_resolved
)
{
return
paperWrapper
;
}
let
margins
;
try
{
margins
=
await
paperWrapper
.
paper
.
unwriteableMargin
;
}
catch
(
e
)
{
this
.
reportPrintingError
(
"
UNWRITEABLE_MARGIN
"
)
;
throw
e
;
}
margins
.
QueryInterface
(
Ci
.
nsIPaperMargin
)
;
paperWrapper
.
unwriteableMarginTop
=
margins
.
top
*
INCHES_PER_POINT
;
paperWrapper
.
unwriteableMarginRight
=
margins
.
right
*
INCHES_PER_POINT
;
paperWrapper
.
unwriteableMarginBottom
=
margins
.
bottom
*
INCHES_PER_POINT
;
paperWrapper
.
unwriteableMarginLeft
=
margins
.
left
*
INCHES_PER_POINT
;
paperWrapper
.
_resolved
=
true
;
return
paperWrapper
;
}
async
resolvePropertiesForPrinter
(
printerName
)
{
let
printerInfo
=
this
.
availablePrinters
[
printerName
]
;
if
(
printerInfo
.
_resolved
)
{
this
.
availablePaperSizes
=
printerInfo
.
availablePaperSizes
;
return
printerInfo
;
}
if
(
printerInfo
.
printer
)
{
let
basePrinterInfo
;
try
{
[
printerInfo
.
supportsDuplex
printerInfo
.
supportsColor
printerInfo
.
supportsMonochrome
basePrinterInfo
]
=
await
Promise
.
all
(
[
printerInfo
.
printer
.
supportsDuplex
printerInfo
.
printer
.
supportsColor
printerInfo
.
printer
.
supportsMonochrome
printerInfo
.
printer
.
printerInfo
]
)
;
}
catch
(
e
)
{
this
.
reportPrintingError
(
"
PRINTER_SETTINGS
"
)
;
throw
e
;
}
basePrinterInfo
.
QueryInterface
(
Ci
.
nsIPrinterInfo
)
;
basePrinterInfo
.
defaultSettings
.
QueryInterface
(
Ci
.
nsIPrintSettings
)
;
printerInfo
.
paperList
=
basePrinterInfo
.
paperList
;
printerInfo
.
defaultSettings
=
basePrinterInfo
.
defaultSettings
;
}
else
if
(
printerName
=
=
PrintUtils
.
SAVE_TO_PDF_PRINTER
)
{
printerInfo
.
defaultSettings
=
PSSVC
.
newPrintSettings
;
printerInfo
.
defaultSettings
.
printerName
=
printerName
;
printerInfo
.
defaultSettings
.
toFileName
=
"
"
;
printerInfo
.
defaultSettings
.
outputFormat
=
Ci
.
nsIPrintSettings
.
kOutputFormatPDF
;
printerInfo
.
defaultSettings
.
printToFile
=
true
;
printerInfo
.
paperList
=
this
.
fallbackPaperList
;
}
printerInfo
.
settings
=
printerInfo
.
defaultSettings
.
clone
(
)
;
printerInfo
.
settings
.
printToFile
=
printerName
=
=
PrintUtils
.
SAVE_TO_PDF_PRINTER
;
let
flags
=
printerInfo
.
settings
.
kInitSaveAll
^
printerInfo
.
settings
.
kInitSavePrintToFile
;
PSSVC
.
initPrintSettingsFromPrefs
(
printerInfo
.
settings
true
flags
)
;
printerInfo
.
settings
.
isInitializedFromPrinter
=
true
;
printerInfo
.
settings
.
toFileName
=
"
"
;
if
(
!
printerInfo
.
paperList
?
.
length
)
{
logger
.
warn
(
"
Printer
has
empty
paperList
:
"
printerInfo
.
printer
.
id
"
using
fallbackPaperList
"
)
;
printerInfo
.
paperList
=
this
.
fallbackPaperList
;
}
let
sizeUnit
=
printerInfo
.
settings
.
paperSizeUnit
=
=
printerInfo
.
settings
.
kPaperSizeMillimeters
?
printerInfo
.
settings
.
kPaperSizeMillimeters
:
printerInfo
.
settings
.
kPaperSizeInches
;
let
papersById
=
(
printerInfo
.
availablePaperSizes
=
{
}
)
;
this
.
availablePaperSizes
=
papersById
;
for
(
let
paper
of
printerInfo
.
paperList
)
{
paper
.
QueryInterface
(
Ci
.
nsIPaper
)
;
if
(
!
papersById
[
paper
.
id
]
)
{
papersById
[
paper
.
id
]
=
{
paper
id
:
paper
.
id
name
:
paper
.
name
sizeUnit
}
;
}
}
Object
.
assign
(
PrintEventHandler
.
allPaperSizes
papersById
)
;
printerInfo
.
_resolved
=
true
;
logger
.
debug
(
"
Resolved
printerInfo
:
"
printerInfo
)
;
return
printerInfo
;
}
get
(
target
name
)
{
switch
(
name
)
{
case
"
currentPaper
"
:
{
let
paperId
=
this
.
get
(
target
"
paperId
"
)
;
return
paperId
&
&
this
.
availablePaperSizes
[
paperId
]
;
}
case
"
marginPresets
"
:
let
paperWrapper
=
this
.
get
(
target
"
currentPaper
"
)
;
return
{
none
:
PrintEventHandler
.
getMarginPresets
(
"
none
"
paperWrapper
)
minimum
:
PrintEventHandler
.
getMarginPresets
(
"
minimum
"
paperWrapper
)
default
:
PrintEventHandler
.
getMarginPresets
(
"
default
"
paperWrapper
)
custom
:
PrintEventHandler
.
getMarginPresets
(
"
custom
"
paperWrapper
)
}
;
case
"
marginOptions
"
:
{
let
allMarginPresets
=
this
.
get
(
target
"
marginPresets
"
)
;
let
uniqueMargins
=
new
Set
(
)
;
let
marginsEnabled
=
{
}
;
for
(
let
name
of
[
"
none
"
"
default
"
"
minimum
"
"
custom
"
]
)
{
let
{
marginTop
marginLeft
marginBottom
marginRight
}
=
allMarginPresets
[
name
]
;
let
key
=
[
marginTop
marginLeft
marginBottom
marginRight
]
.
join
(
"
"
)
;
marginsEnabled
[
name
]
=
!
uniqueMargins
.
has
(
key
)
|
|
name
=
=
"
custom
"
;
uniqueMargins
.
add
(
key
)
;
}
return
marginsEnabled
;
}
case
"
margins
"
:
let
marginSettings
=
{
marginTop
:
target
.
marginTop
marginLeft
:
target
.
marginLeft
marginBottom
:
target
.
marginBottom
marginRight
:
target
.
marginRight
}
;
let
allMarginPresets
=
this
.
get
(
target
"
marginPresets
"
)
;
for
(
let
presetName
of
[
"
none
"
"
minimum
"
"
default
"
]
)
{
let
marginPresets
=
allMarginPresets
[
presetName
]
;
if
(
Object
.
keys
(
marginSettings
)
.
every
(
name
=
>
marginSettings
[
name
]
.
toFixed
(
2
)
=
=
marginPresets
[
name
]
.
toFixed
(
2
)
)
)
{
return
presetName
;
}
}
return
"
custom
"
;
case
"
defaultMargins
"
:
return
PrintEventHandler
.
getMarginPresets
(
"
default
"
this
.
get
(
target
"
currentPaper
"
)
)
;
case
"
customMargins
"
:
return
PrintEventHandler
.
getMarginPresets
(
"
custom
"
this
.
get
(
target
"
currentPaper
"
)
)
;
case
"
paperSizes
"
:
return
Object
.
values
(
this
.
availablePaperSizes
)
.
sort
(
(
a
b
)
=
>
a
.
name
.
localeCompare
(
b
.
name
)
)
.
map
(
paper
=
>
{
return
{
name
:
paper
.
name
value
:
paper
.
id
}
;
}
)
;
case
"
supportsDuplex
"
:
return
this
.
availablePrinters
[
target
.
printerName
]
.
supportsDuplex
;
case
"
printDuplex
"
:
switch
(
target
.
duplex
)
{
case
Ci
.
nsIPrintSettings
.
kDuplexNone
:
break
;
case
Ci
.
nsIPrintSettings
.
kDuplexFlipOnLongEdge
:
return
"
long
-
edge
"
;
case
Ci
.
nsIPrintSettings
.
kDuplexFlipOnShortEdge
:
return
"
short
-
edge
"
;
default
:
logger
.
warn
(
"
Unexpected
duplex
value
:
"
target
.
duplex
)
;
}
return
"
off
"
;
case
"
printBackgrounds
"
:
return
target
.
printBGImages
|
|
target
.
printBGColors
;
case
"
printFootersHeaders
"
:
return
Object
.
keys
(
this
.
headerFooterSettingsPrefs
)
.
some
(
name
=
>
!
!
target
[
name
]
)
;
case
"
supportsColor
"
:
return
this
.
availablePrinters
[
target
.
printerName
]
.
supportsColor
;
case
"
willSaveToFile
"
:
return
(
target
.
outputFormat
=
=
Ci
.
nsIPrintSettings
.
kOutputFormatPDF
|
|
this
.
knownSaveToFilePrinters
.
has
(
target
.
printerName
)
)
;
case
"
supportsMonochrome
"
:
return
this
.
availablePrinters
[
target
.
printerName
]
.
supportsMonochrome
;
case
"
defaultSystemPrinter
"
:
return
(
this
.
defaultSystemPrinter
?
.
value
|
|
Object
.
getOwnPropertyNames
(
this
.
availablePrinters
)
.
find
(
name
=
>
name
!
=
PrintUtils
.
SAVE_TO_PDF_PRINTER
)
)
;
case
"
numCopies
"
:
return
this
.
get
(
target
"
willSaveToFile
"
)
?
1
:
target
.
numCopies
;
case
"
sourceVersion
"
:
return
this
.
_sourceVersion
;
}
return
target
[
name
]
;
}
set
(
target
name
value
)
{
switch
(
name
)
{
case
"
margins
"
:
if
(
!
[
"
default
"
"
minimum
"
"
none
"
"
custom
"
]
.
includes
(
value
)
)
{
logger
.
warn
(
"
Unexpected
margin
preset
name
:
"
value
)
;
value
=
"
default
"
;
}
let
paperWrapper
=
this
.
get
(
target
"
currentPaper
"
)
;
let
marginPresets
=
PrintEventHandler
.
getMarginPresets
(
value
paperWrapper
)
;
for
(
let
[
settingName
presetValue
]
of
Object
.
entries
(
marginPresets
)
)
{
target
[
settingName
]
=
presetValue
;
}
break
;
case
"
paperId
"
:
{
let
paperId
=
value
;
let
paperWrapper
=
this
.
availablePaperSizes
[
paperId
]
;
let
unitsPerPoint
=
paperWrapper
.
sizeUnit
=
=
target
.
kPaperSizeMillimeters
?
MM_PER_POINT
:
INCHES_PER_POINT
;
target
.
paperSizeUnit
=
paperWrapper
.
sizeUnit
;
target
.
paperWidth
=
paperWrapper
.
paper
.
width
*
unitsPerPoint
;
target
.
paperHeight
=
paperWrapper
.
paper
.
height
*
unitsPerPoint
;
target
.
unwriteableMarginTop
=
paperWrapper
.
unwriteableMarginTop
;
target
.
unwriteableMarginRight
=
paperWrapper
.
unwriteableMarginRight
;
target
.
unwriteableMarginBottom
=
paperWrapper
.
unwriteableMarginBottom
;
target
.
unwriteableMarginLeft
=
paperWrapper
.
unwriteableMarginLeft
;
target
.
paperId
=
paperWrapper
.
paper
.
id
;
this
.
set
(
target
"
margins
"
this
.
get
(
target
"
margins
"
)
)
;
break
;
}
case
"
printerName
"
:
break
;
case
"
printBackgrounds
"
:
target
.
printBGImages
=
value
;
target
.
printBGColors
=
value
;
break
;
case
"
printDuplex
"
:
{
let
duplex
=
(
function
(
)
{
switch
(
value
)
{
case
"
off
"
:
break
;
case
"
long
-
edge
"
:
return
Ci
.
nsIPrintSettings
.
kDuplexFlipOnLongEdge
;
case
"
short
-
edge
"
:
return
Ci
.
nsIPrintSettings
.
kDuplexFlipOnShortEdge
;
default
:
logger
.
warn
(
"
Unexpected
duplex
name
:
"
value
)
;
}
return
Ci
.
nsIPrintSettings
.
kDuplexNone
;
}
)
(
)
;
target
.
duplex
=
duplex
;
break
;
}
case
"
printFootersHeaders
"
:
for
(
let
[
settingName
defaultValue
]
of
Object
.
entries
(
this
.
defaultHeadersAndFooterValues
)
)
{
target
[
settingName
]
=
value
?
defaultValue
:
"
"
;
}
break
;
case
"
customMargins
"
:
if
(
value
!
=
null
)
{
for
(
let
[
settingName
newVal
]
of
Object
.
entries
(
value
)
)
{
target
[
settingName
]
=
newVal
;
this
.
_lastCustomMarginValues
[
settingName
]
=
newVal
;
}
}
break
;
case
"
customMarginTop
"
:
case
"
customMarginBottom
"
:
case
"
customMarginLeft
"
:
case
"
customMarginRight
"
:
let
customMarginName
=
"
margin
"
+
name
.
substring
(
12
)
;
this
.
set
(
target
"
customMargins
"
Object
.
assign
(
{
}
this
.
get
(
target
"
customMargins
"
)
{
[
customMarginName
]
:
value
}
)
)
;
break
;
case
"
sourceVersion
"
:
this
.
_sourceVersion
=
value
;
this
.
set
(
target
"
printSelectionOnly
"
value
=
=
"
selection
"
)
;
if
(
value
=
=
"
simplified
"
)
{
this
.
set
(
target
"
printBackgrounds
"
false
)
;
}
break
;
default
:
target
[
name
]
=
value
;
}
}
}
;
function
PrintUIControlMixin
(
superClass
)
{
return
class
PrintUIControl
extends
superClass
{
connectedCallback
(
)
{
this
.
setAttribute
(
"
autocomplete
"
"
off
"
)
;
this
.
initialize
(
)
;
this
.
render
(
)
;
}
initialize
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
if
(
this
.
templateId
)
{
let
template
=
this
.
ownerDocument
.
getElementById
(
this
.
templateId
)
;
let
templateContent
=
template
.
content
;
this
.
appendChild
(
templateContent
.
cloneNode
(
true
)
)
;
}
document
.
addEventListener
(
"
print
-
settings
"
(
{
detail
:
settings
}
)
=
>
{
this
.
update
(
settings
)
;
}
)
;
this
.
addEventListener
(
"
input
"
this
)
;
}
render
(
)
{
}
update
(
settings
)
{
}
dispatchSettingsChange
(
changedSettings
)
{
this
.
dispatchEvent
(
new
CustomEvent
(
"
update
-
print
-
settings
"
{
bubbles
:
true
detail
:
changedSettings
}
)
)
;
}
cancelSettingsChange
(
changedSettings
)
{
this
.
dispatchEvent
(
new
CustomEvent
(
"
cancel
-
print
-
settings
"
{
bubbles
:
true
detail
:
changedSettings
}
)
)
;
}
handleEvent
(
event
)
{
}
}
;
}
class
PrintUIForm
extends
PrintUIControlMixin
(
HTMLFormElement
)
{
initialize
(
)
{
super
.
initialize
(
)
;
this
.
addEventListener
(
"
submit
"
this
)
;
this
.
addEventListener
(
"
click
"
this
)
;
this
.
addEventListener
(
"
revalidate
"
this
)
;
this
.
_printerDestination
=
this
.
querySelector
(
"
#
destination
"
)
;
this
.
printButton
=
this
.
querySelector
(
"
#
print
-
button
"
)
;
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
this
.
printButton
.
parentElement
.
append
(
this
.
printButton
)
;
}
this
.
querySelector
(
"
#
pages
-
per
-
sheet
"
)
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
print
.
pages_per_sheet
.
enabled
"
false
)
;
}
removeNonPdfSettings
(
)
{
let
selectors
=
[
"
#
margins
"
"
#
headers
-
footers
"
"
#
backgrounds
"
"
#
source
-
version
-
selection
"
]
;
for
(
let
selector
of
selectors
)
{
this
.
querySelector
(
selector
)
.
remove
(
)
;
}
let
moreSettings
=
this
.
querySelector
(
"
#
more
-
settings
-
options
"
)
;
if
(
moreSettings
.
children
.
length
<
=
1
)
{
moreSettings
.
remove
(
)
;
}
}
requestPrint
(
)
{
this
.
requestSubmit
(
this
.
printButton
)
;
}
update
(
settings
)
{
this
.
querySelector
(
"
#
system
-
print
"
)
.
hidden
=
AppConstants
.
platform
=
=
=
"
win
"
&
&
!
settings
.
defaultSystemPrinter
;
this
.
querySelector
(
"
#
two
-
sided
-
printing
"
)
.
hidden
=
!
settings
.
supportsDuplex
;
}
enable
(
)
{
let
isValid
=
this
.
checkValidity
(
)
;
document
.
body
.
toggleAttribute
(
"
invalid
"
!
isValid
)
;
if
(
isValid
)
{
for
(
let
element
of
this
.
elements
)
{
if
(
!
element
.
hasAttribute
(
"
disallowed
"
)
)
{
element
.
disabled
=
false
;
}
}
document
.
querySelector
(
"
#
sheet
-
count
"
)
.
parentNode
.
setAttribute
(
"
aria
-
live
"
"
polite
"
)
;
}
else
{
let
invalidElement
;
for
(
let
element
of
this
.
elements
)
{
if
(
!
element
.
checkValidity
(
)
)
{
invalidElement
=
element
;
break
;
}
}
let
section
=
invalidElement
.
closest
(
"
.
section
-
block
"
)
;
document
.
body
.
toggleAttribute
(
"
invalid
"
!
isValid
)
;
document
.
body
.
removeAttribute
(
"
aria
-
describedby
"
)
;
for
(
let
element
of
this
.
elements
)
{
element
.
disabled
=
element
.
hasAttribute
(
"
disallowed
"
)
|
|
(
!
isValid
&
&
element
.
validity
.
valid
&
&
element
.
name
!
=
"
cancel
"
&
&
element
.
closest
(
"
.
section
-
block
"
)
!
=
this
.
_printerDestination
&
&
element
.
closest
(
"
.
section
-
block
"
)
!
=
section
)
;
}
}
}
disable
(
filterFn
)
{
for
(
let
element
of
this
.
elements
)
{
if
(
filterFn
&
&
!
filterFn
(
element
)
)
{
continue
;
}
element
.
disabled
=
element
.
name
!
=
"
cancel
"
;
}
}
handleEvent
(
e
)
{
if
(
e
.
target
.
id
=
=
"
open
-
dialog
-
link
"
)
{
this
.
dispatchEvent
(
new
Event
(
"
open
-
system
-
dialog
"
{
bubbles
:
true
}
)
)
;
return
;
}
if
(
e
.
type
=
=
"
submit
"
)
{
e
.
preventDefault
(
)
;
if
(
e
.
submitter
.
name
=
=
"
print
"
&
&
this
.
checkValidity
(
)
)
{
this
.
dispatchEvent
(
new
Event
(
"
print
"
{
bubbles
:
true
}
)
)
;
}
}
else
if
(
(
e
.
type
=
=
"
input
"
|
|
e
.
type
=
=
"
revalidate
"
)
&
&
!
this
.
printerChanging
)
{
this
.
enable
(
)
;
}
}
}
customElements
.
define
(
"
print
-
form
"
PrintUIForm
{
extends
:
"
form
"
}
)
;
class
PrintSettingSelect
extends
PrintUIControlMixin
(
HTMLSelectElement
)
{
initialize
(
)
{
super
.
initialize
(
)
;
this
.
addEventListener
(
"
keypress
"
this
)
;
}
connectedCallback
(
)
{
this
.
settingName
=
this
.
dataset
.
settingName
;
super
.
connectedCallback
(
)
;
}
setOptions
(
optionValues
=
[
]
)
{
this
.
textContent
=
"
"
;
for
(
let
optionData
of
optionValues
)
{
let
opt
=
new
Option
(
optionData
.
name
"
value
"
in
optionData
?
optionData
.
value
:
optionData
.
name
)
;
if
(
optionData
.
nameId
)
{
document
.
l10n
.
setAttributes
(
opt
optionData
.
nameId
)
;
}
this
.
options
.
add
(
opt
)
;
}
}
update
(
settings
)
{
if
(
this
.
settingName
)
{
this
.
value
=
settings
[
this
.
settingName
]
;
}
}
handleEvent
(
e
)
{
if
(
e
.
type
=
=
"
input
"
&
&
this
.
settingName
)
{
this
.
dispatchSettingsChange
(
{
[
this
.
settingName
]
:
e
.
target
.
value
}
)
;
}
else
if
(
e
.
type
=
=
"
keypress
"
)
{
if
(
e
.
key
=
=
"
Enter
"
&
&
(
!
e
.
metaKey
|
|
AppConstants
.
platform
=
=
"
macosx
"
)
)
{
this
.
form
.
requestPrint
(
)
;
}
}
}
}
customElements
.
define
(
"
setting
-
select
"
PrintSettingSelect
{
extends
:
"
select
"
}
)
;
class
PrintSettingNumber
extends
PrintUIControlMixin
(
HTMLInputElement
)
{
initialize
(
)
{
super
.
initialize
(
)
;
this
.
addEventListener
(
"
keypress
"
e
=
>
this
.
handleKeypress
(
e
)
)
;
this
.
addEventListener
(
"
paste
"
e
=
>
this
.
handlePaste
(
e
)
)
;
}
connectedCallback
(
)
{
this
.
type
=
"
number
"
;
this
.
settingName
=
this
.
dataset
.
settingName
;
super
.
connectedCallback
(
)
;
}
update
(
settings
)
{
if
(
this
.
settingName
)
{
this
.
value
=
settings
[
this
.
settingName
]
;
}
}
handleKeypress
(
e
)
{
let
char
=
String
.
fromCharCode
(
e
.
charCode
)
;
let
acceptedChar
=
e
.
target
.
step
.
includes
(
"
.
"
)
?
char
.
match
(
/
^
[
0
-
9
.
]
/
)
:
char
.
match
(
/
^
[
0
-
9
]
/
)
;
if
(
!
acceptedChar
&
&
!
char
.
match
(
"
\
x00
"
)
&
&
!
e
.
ctrlKey
&
&
!
e
.
metaKey
)
{
e
.
preventDefault
(
)
;
}
}
handlePaste
(
e
)
{
let
paste
=
(
e
.
clipboardData
|
|
window
.
clipboardData
)
.
getData
(
"
text
"
)
.
trim
(
)
;
let
acceptedChars
=
e
.
target
.
step
.
includes
(
"
.
"
)
?
paste
.
match
(
/
^
[
0
-
9
.
]
*
/
)
:
paste
.
match
(
/
^
[
0
-
9
]
*
/
)
;
if
(
!
acceptedChars
)
{
e
.
preventDefault
(
)
;
}
}
handleEvent
(
e
)
{
switch
(
e
.
type
)
{
case
"
paste
"
:
this
.
handlePaste
(
)
;
break
;
case
"
keypress
"
:
this
.
handleKeypress
(
)
;
break
;
case
"
input
"
:
if
(
this
.
settingName
&
&
this
.
checkValidity
(
)
)
{
this
.
dispatchSettingsChange
(
{
[
this
.
settingName
]
:
this
.
value
}
)
;
}
break
;
}
}
}
customElements
.
define
(
"
setting
-
number
"
PrintSettingNumber
{
extends
:
"
input
"
}
)
;
class
PrintSettingCheckbox
extends
PrintUIControlMixin
(
HTMLInputElement
)
{
connectedCallback
(
)
{
this
.
type
=
"
checkbox
"
;
this
.
settingName
=
this
.
dataset
.
settingName
;
super
.
connectedCallback
(
)
;
}
update
(
settings
)
{
this
.
checked
=
settings
[
this
.
settingName
]
;
}
handleEvent
(
e
)
{
this
.
dispatchSettingsChange
(
{
[
this
.
settingName
]
:
this
.
checked
}
)
;
}
}
customElements
.
define
(
"
setting
-
checkbox
"
PrintSettingCheckbox
{
extends
:
"
input
"
}
)
;
class
PrintSettingRadio
extends
PrintUIControlMixin
(
HTMLInputElement
)
{
connectedCallback
(
)
{
this
.
type
=
"
radio
"
;
this
.
settingName
=
this
.
dataset
.
settingName
;
super
.
connectedCallback
(
)
;
}
update
(
settings
)
{
this
.
checked
=
settings
[
this
.
settingName
]
=
=
this
.
value
;
}
handleEvent
(
e
)
{
this
.
dispatchSettingsChange
(
{
[
this
.
settingName
]
:
this
.
value
}
)
;
}
}
customElements
.
define
(
"
setting
-
radio
"
PrintSettingRadio
{
extends
:
"
input
"
}
)
;
class
DestinationPicker
extends
PrintSettingSelect
{
initialize
(
)
{
super
.
initialize
(
)
;
document
.
addEventListener
(
"
available
-
destinations
"
this
)
;
}
update
(
settings
)
{
super
.
update
(
settings
)
;
let
isPdf
=
settings
.
outputFormat
=
=
Ci
.
nsIPrintSettings
.
kOutputFormatPDF
;
this
.
setAttribute
(
"
output
"
isPdf
?
"
pdf
"
:
"
paper
"
)
;
}
handleEvent
(
e
)
{
super
.
handleEvent
(
e
)
;
if
(
e
.
type
=
=
"
available
-
destinations
"
)
{
this
.
setOptions
(
e
.
detail
)
;
}
}
}
customElements
.
define
(
"
destination
-
picker
"
DestinationPicker
{
extends
:
"
select
"
}
)
;
class
ColorModePicker
extends
PrintSettingSelect
{
update
(
settings
)
{
this
.
value
=
settings
[
this
.
settingName
]
?
"
color
"
:
"
bw
"
;
let
canSwitch
=
settings
.
supportsColor
&
&
settings
.
supportsMonochrome
;
if
(
this
.
disablePicker
!
=
canSwitch
)
{
this
.
toggleAttribute
(
"
disallowed
"
!
canSwitch
)
;
this
.
disabled
=
!
canSwitch
;
}
this
.
disablePicker
=
canSwitch
;
}
handleEvent
(
e
)
{
if
(
e
.
type
=
=
"
input
"
)
{
this
.
dispatchSettingsChange
(
{
[
this
.
settingName
]
:
this
.
value
=
=
"
color
"
}
)
;
}
}
}
customElements
.
define
(
"
color
-
mode
-
select
"
ColorModePicker
{
extends
:
"
select
"
}
)
;
class
PaperSizePicker
extends
PrintSettingSelect
{
initialize
(
)
{
super
.
initialize
(
)
;
this
.
_printerName
=
null
;
}
update
(
settings
)
{
if
(
settings
.
printerName
!
=
=
this
.
_printerName
)
{
this
.
_printerName
=
settings
.
printerName
;
this
.
setOptions
(
settings
.
paperSizes
)
;
}
this
.
value
=
settings
.
paperId
;
}
}
customElements
.
define
(
"
paper
-
size
-
select
"
PaperSizePicker
{
extends
:
"
select
"
}
)
;
class
OrientationInput
extends
PrintUIControlMixin
(
HTMLElement
)
{
initialize
(
)
{
super
.
initialize
(
)
;
document
.
addEventListener
(
"
hide
-
orientation
"
this
)
;
}
get
templateId
(
)
{
return
"
orientation
-
template
"
;
}
update
(
settings
)
{
for
(
let
input
of
this
.
querySelectorAll
(
"
input
"
)
)
{
input
.
checked
=
settings
.
orientation
=
=
input
.
value
;
}
}
handleEvent
(
e
)
{
if
(
e
.
type
=
=
"
hide
-
orientation
"
)
{
document
.
getElementById
(
"
orientation
"
)
.
hidden
=
true
;
return
;
}
this
.
dispatchSettingsChange
(
{
orientation
:
e
.
target
.
value
}
)
;
}
}
customElements
.
define
(
"
orientation
-
input
"
OrientationInput
)
;
class
CopiesInput
extends
PrintUIControlMixin
(
HTMLElement
)
{
get
templateId
(
)
{
return
"
copy
-
template
"
;
}
initialize
(
)
{
super
.
initialize
(
)
;
this
.
_copiesSection
=
this
.
closest
(
"
.
section
-
block
"
)
;
this
.
_copiesInput
=
this
.
querySelector
(
"
#
copies
-
count
"
)
;
this
.
_copiesError
=
this
.
querySelector
(
"
#
error
-
invalid
-
copies
"
)
;
}
update
(
settings
)
{
this
.
_copiesSection
.
hidden
=
settings
.
willSaveToFile
;
this
.
_copiesError
.
hidden
=
true
;
}
handleEvent
(
e
)
{
this
.
_copiesError
.
hidden
=
this
.
_copiesInput
.
checkValidity
(
)
;
}
}
customElements
.
define
(
"
copy
-
count
-
input
"
CopiesInput
)
;
class
ScaleInput
extends
PrintUIControlMixin
(
HTMLElement
)
{
get
templateId
(
)
{
return
"
scale
-
template
"
;
}
initialize
(
)
{
super
.
initialize
(
)
;
this
.
_percentScale
=
this
.
querySelector
(
"
#
percent
-
scale
"
)
;
this
.
_shrinkToFitChoice
=
this
.
querySelector
(
"
#
fit
-
choice
"
)
;
this
.
_scaleChoice
=
this
.
querySelector
(
"
#
percent
-
scale
-
choice
"
)
;
this
.
_scaleError
=
this
.
querySelector
(
"
#
error
-
invalid
-
scale
"
)
;
}
updateScale
(
)
{
this
.
dispatchSettingsChange
(
{
scaling
:
Number
(
this
.
_percentScale
.
value
/
100
)
}
)
;
}
update
(
settings
)
{
let
{
scaling
shrinkToFit
printerName
}
=
settings
;
this
.
_shrinkToFitChoice
.
checked
=
shrinkToFit
;
this
.
_scaleChoice
.
checked
=
!
shrinkToFit
;
if
(
this
.
disableScale
!
=
shrinkToFit
)
{
this
.
_percentScale
.
disabled
=
shrinkToFit
;
this
.
_percentScale
.
toggleAttribute
(
"
disallowed
"
shrinkToFit
)
;
}
this
.
disableScale
=
shrinkToFit
;
if
(
!
this
.
printerName
)
{
this
.
printerName
=
printerName
;
}
let
isValid
=
this
.
_percentScale
.
checkValidity
(
)
;
if
(
!
this
.
_percentScale
.
value
|
|
(
this
.
_shrinkToFitChoice
.
checked
&
&
!
isValid
)
|
|
(
this
.
printerName
!
=
printerName
&
&
!
isValid
)
)
{
this
.
_percentScale
.
value
=
parseInt
(
scaling
*
100
10
)
;
this
.
printerName
=
printerName
;
if
(
!
isValid
)
{
this
.
dispatchEvent
(
new
Event
(
"
revalidate
"
{
bubbles
:
true
}
)
)
;
this
.
_scaleError
.
hidden
=
true
;
}
}
}
handleEvent
(
e
)
{
if
(
e
.
target
=
=
this
.
_shrinkToFitChoice
|
|
e
.
target
=
=
this
.
_scaleChoice
)
{
if
(
!
this
.
_percentScale
.
checkValidity
(
)
)
{
this
.
_percentScale
.
value
=
100
;
}
let
scale
=
e
.
target
=
=
this
.
_shrinkToFitChoice
?
1
:
Number
(
this
.
_percentScale
.
value
/
100
)
;
this
.
dispatchSettingsChange
(
{
shrinkToFit
:
this
.
_shrinkToFitChoice
.
checked
scaling
:
scale
}
)
;
this
.
_scaleError
.
hidden
=
true
;
}
else
if
(
e
.
type
=
=
"
input
"
)
{
if
(
this
.
_percentScale
.
checkValidity
(
)
)
{
this
.
updateScale
(
)
;
}
}
window
.
clearTimeout
(
this
.
showErrorTimeoutId
)
;
if
(
this
.
_percentScale
.
validity
.
valid
)
{
this
.
_scaleError
.
hidden
=
true
;
}
else
{
this
.
cancelSettingsChange
(
{
scaling
:
true
}
)
;
this
.
showErrorTimeoutId
=
window
.
setTimeout
(
(
)
=
>
{
this
.
_scaleError
.
hidden
=
false
;
}
INPUT_DELAY_MS
)
;
}
}
}
customElements
.
define
(
"
scale
-
input
"
ScaleInput
)
;
class
PageRangeInput
extends
PrintUIControlMixin
(
HTMLElement
)
{
initialize
(
)
{
super
.
initialize
(
)
;
this
.
_rangeInput
=
this
.
querySelector
(
"
#
custom
-
range
"
)
;
this
.
_rangeInput
.
title
=
"
"
;
this
.
_rangePicker
=
this
.
querySelector
(
"
#
range
-
picker
"
)
;
this
.
_rangePickerEvenOption
=
this
.
_rangePicker
.
namedItem
(
"
even
"
)
;
this
.
_rangeError
=
this
.
querySelector
(
"
#
error
-
invalid
-
range
"
)
;
this
.
_startRangeOverflowError
=
this
.
querySelector
(
"
#
error
-
invalid
-
start
-
range
-
overflow
"
)
;
this
.
_pagesSet
=
new
Set
(
)
;
this
.
addEventListener
(
"
keypress
"
this
)
;
this
.
addEventListener
(
"
paste
"
this
)
;
document
.
addEventListener
(
"
page
-
count
"
this
)
;
}
get
templateId
(
)
{
return
"
page
-
range
-
template
"
;
}
updatePageRange
(
)
{
let
isCustom
=
this
.
_rangePicker
.
value
=
=
"
custom
"
;
if
(
isCustom
)
{
this
.
validateRangeInput
(
)
;
}
else
{
this
.
_pagesSet
.
clear
(
)
;
if
(
this
.
_rangePicker
.
value
=
=
"
odd
"
)
{
for
(
let
i
=
1
;
i
<
=
this
.
_numPages
;
i
+
=
2
)
{
this
.
_pagesSet
.
add
(
i
)
;
}
}
else
if
(
this
.
_rangePicker
.
value
=
=
"
even
"
)
{
for
(
let
i
=
2
;
i
<
=
this
.
_numPages
;
i
+
=
2
)
{
this
.
_pagesSet
.
add
(
i
)
;
}
}
if
(
!
this
.
_rangeInput
.
checkValidity
(
)
)
{
this
.
_rangeInput
.
setCustomValidity
(
"
"
)
;
this
.
_rangeInput
.
value
=
"
"
;
}
}
this
.
dispatchEvent
(
new
Event
(
"
revalidate
"
{
bubbles
:
true
}
)
)
;
document
.
l10n
.
setAttributes
(
this
.
_rangeError
"
printui
-
error
-
invalid
-
range
"
{
numPages
:
this
.
_numPages
}
)
;
if
(
this
.
_rangeInput
.
validity
.
valid
|
|
!
isCustom
)
{
window
.
clearTimeout
(
this
.
showErrorTimeoutId
)
;
this
.
_startRangeOverflowError
.
hidden
=
this
.
_rangeError
.
hidden
=
true
;
}
else
{
this
.
_rangeInput
.
focus
(
)
;
}
}
dispatchPageRange
(
shouldCancel
=
true
)
{
window
.
clearTimeout
(
this
.
showErrorTimeoutId
)
;
if
(
this
.
_rangeInput
.
validity
.
valid
|
|
this
.
_rangePicker
.
value
!
=
"
custom
"
)
{
this
.
dispatchSettingsChange
(
{
pageRanges
:
this
.
formatPageRange
(
)
}
)
;
}
else
{
if
(
shouldCancel
)
{
this
.
cancelSettingsChange
(
{
pageRanges
:
true
}
)
;
}
this
.
showErrorTimeoutId
=
window
.
setTimeout
(
(
)
=
>
{
this
.
_rangeError
.
hidden
=
this
.
_rangeInput
.
validationMessage
!
=
"
invalid
"
;
this
.
_startRangeOverflowError
.
hidden
=
this
.
_rangeInput
.
validationMessage
!
=
"
startRangeOverflow
"
;
}
INPUT_DELAY_MS
)
;
}
}
formatPageRange
(
)
{
if
(
this
.
_pagesSet
.
size
=
=
0
|
|
(
this
.
_rangePicker
.
value
=
=
"
custom
"
&
&
this
.
_rangeInput
.
value
=
=
"
"
)
|
|
this
.
_rangePicker
.
value
=
=
"
all
"
)
{
return
[
]
;
}
let
pages
=
Array
.
from
(
this
.
_pagesSet
)
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
let
formattedRanges
=
[
]
;
let
startRange
=
pages
[
0
]
;
let
endRange
=
pages
[
0
]
;
formattedRanges
.
push
(
startRange
)
;
for
(
let
i
=
1
;
i
<
pages
.
length
;
i
+
+
)
{
let
currentPage
=
pages
[
i
-
1
]
;
let
nextPage
=
pages
[
i
]
;
if
(
nextPage
>
currentPage
+
1
)
{
formattedRanges
.
push
(
endRange
)
;
startRange
=
endRange
=
nextPage
;
formattedRanges
.
push
(
startRange
)
;
}
else
{
endRange
=
nextPage
;
}
}
formattedRanges
.
push
(
endRange
)
;
return
formattedRanges
;
}
update
(
settings
)
{
let
{
pageRanges
printerName
}
=
settings
;
this
.
toggleAttribute
(
"
all
-
pages
"
!
pageRanges
.
length
)
;
if
(
!
this
.
printerName
)
{
this
.
printerName
=
printerName
;
}
let
isValid
=
this
.
_rangeInput
.
checkValidity
(
)
;
if
(
this
.
printerName
!
=
printerName
&
&
!
isValid
)
{
this
.
printerName
=
printerName
;
this
.
_rangeInput
.
value
=
"
"
;
this
.
updatePageRange
(
)
;
this
.
dispatchPageRange
(
)
;
}
}
handleKeypress
(
e
)
{
let
char
=
String
.
fromCharCode
(
e
.
charCode
)
;
let
acceptedChar
=
char
.
match
(
/
^
[
0
-
9
-
]
/
)
;
if
(
!
acceptedChar
&
&
!
char
.
match
(
"
\
x00
"
)
&
&
!
e
.
ctrlKey
&
&
!
e
.
metaKey
)
{
e
.
preventDefault
(
)
;
}
}
handlePaste
(
e
)
{
let
paste
=
(
e
.
clipboardData
|
|
window
.
clipboardData
)
.
getData
(
"
text
"
)
.
trim
(
)
;
if
(
!
paste
.
match
(
/
^
[
0
-
9
-
]
*
/
)
)
{
e
.
preventDefault
(
)
;
}
}
_validateRangeInput
(
value
numPages
)
{
this
.
_pagesSet
.
clear
(
)
;
var
ranges
=
value
.
split
(
"
"
)
;
for
(
let
range
of
ranges
)
{
let
rangeParts
=
range
.
split
(
"
-
"
)
;
if
(
rangeParts
.
length
>
2
)
{
this
.
_rangeInput
.
setCustomValidity
(
"
invalid
"
)
;
this
.
_rangeInput
.
title
=
"
"
;
this
.
_pagesSet
.
clear
(
)
;
return
;
}
let
startRange
=
parseInt
(
rangeParts
[
0
]
10
)
;
let
endRange
=
parseInt
(
rangeParts
.
length
=
=
2
?
rangeParts
[
1
]
:
rangeParts
[
0
]
10
)
;
if
(
isNaN
(
startRange
)
&
&
isNaN
(
endRange
)
)
{
continue
;
}
if
(
isNaN
(
startRange
)
&
&
rangeParts
[
0
]
=
=
"
"
)
{
startRange
=
1
;
}
if
(
isNaN
(
endRange
)
&
&
rangeParts
[
1
]
=
=
"
"
)
{
endRange
=
numPages
;
}
if
(
endRange
<
startRange
)
{
this
.
_rangeInput
.
setCustomValidity
(
"
startRangeOverflow
"
)
;
this
.
_pagesSet
.
clear
(
)
;
return
;
}
else
if
(
startRange
>
numPages
|
|
endRange
>
numPages
|
|
startRange
=
=
0
)
{
this
.
_rangeInput
.
setCustomValidity
(
"
invalid
"
)
;
this
.
_rangeInput
.
title
=
"
"
;
this
.
_pagesSet
.
clear
(
)
;
return
;
}
for
(
let
i
=
startRange
;
i
<
=
endRange
;
i
+
+
)
{
this
.
_pagesSet
.
add
(
i
)
;
}
}
this
.
_rangeInput
.
setCustomValidity
(
"
"
)
;
}
validateRangeInput
(
)
{
let
value
=
this
.
_rangePicker
.
value
=
=
"
custom
"
?
this
.
_rangeInput
.
value
:
"
"
;
this
.
_validateRangeInput
(
value
this
.
_numPages
)
;
}
handleEvent
(
e
)
{
if
(
e
.
type
=
=
"
keypress
"
)
{
if
(
e
.
target
=
=
this
.
_rangeInput
)
{
this
.
handleKeypress
(
e
)
;
}
return
;
}
if
(
e
.
type
=
=
=
"
paste
"
&
&
e
.
target
=
=
this
.
_rangeInput
)
{
this
.
handlePaste
(
e
)
;
return
;
}
if
(
e
.
type
=
=
"
page
-
count
"
)
{
let
{
totalPages
}
=
e
.
detail
;
if
(
this
.
_numPages
=
=
totalPages
)
{
return
;
}
this
.
_numPages
=
totalPages
;
this
.
_rangeInput
.
disabled
=
false
;
this
.
_rangePickerEvenOption
.
disabled
=
this
.
_numPages
<
2
;
let
prevPages
=
Array
.
from
(
this
.
_pagesSet
)
;
this
.
updatePageRange
(
)
;
if
(
prevPages
.
length
!
=
this
.
_pagesSet
.
size
|
|
!
prevPages
.
every
(
page
=
>
this
.
_pagesSet
.
has
(
page
)
)
)
{
this
.
dispatchPageRange
(
false
)
;
}
return
;
}
if
(
e
.
target
=
=
this
.
_rangePicker
)
{
this
.
_rangeInput
.
hidden
=
e
.
target
.
value
!
=
"
custom
"
;
this
.
updatePageRange
(
)
;
this
.
dispatchPageRange
(
)
;
if
(
!
this
.
_rangeInput
.
hidden
)
{
this
.
_rangeInput
.
select
(
)
;
}
}
else
if
(
e
.
target
=
=
this
.
_rangeInput
)
{
this
.
_rangeInput
.
focus
(
)
;
if
(
this
.
_numPages
)
{
this
.
updatePageRange
(
)
;
this
.
dispatchPageRange
(
)
;
}
}
}
}
customElements
.
define
(
"
page
-
range
-
input
"
PageRangeInput
)
;
class
MarginsPicker
extends
PrintUIControlMixin
(
HTMLElement
)
{
initialize
(
)
{
super
.
initialize
(
)
;
this
.
_marginPicker
=
this
.
querySelector
(
"
#
margins
-
picker
"
)
;
this
.
_customTopMargin
=
this
.
querySelector
(
"
#
custom
-
margin
-
top
"
)
;
this
.
_customBottomMargin
=
this
.
querySelector
(
"
#
custom
-
margin
-
bottom
"
)
;
this
.
_customLeftMargin
=
this
.
querySelector
(
"
#
custom
-
margin
-
left
"
)
;
this
.
_customRightMargin
=
this
.
querySelector
(
"
#
custom
-
margin
-
right
"
)
;
this
.
_marginError
=
this
.
querySelector
(
"
#
error
-
invalid
-
margin
"
)
;
this
.
_sizeUnit
=
null
;
this
.
_toInchesMultiplier
=
1
;
}
get
templateId
(
)
{
return
"
margins
-
template
"
;
}
updateCustomMargins
(
)
{
let
newMargins
=
{
marginTop
:
this
.
toInchValue
(
this
.
_customTopMargin
.
value
)
marginBottom
:
this
.
toInchValue
(
this
.
_customBottomMargin
.
value
)
marginLeft
:
this
.
toInchValue
(
this
.
_customLeftMargin
.
value
)
marginRight
:
this
.
toInchValue
(
this
.
_customRightMargin
.
value
)
}
;
this
.
dispatchSettingsChange
(
{
margins
:
"
custom
"
customMargins
:
newMargins
}
)
;
this
.
_marginError
.
hidden
=
true
;
}
updateMaxValues
(
)
{
let
maxWidth
=
this
.
toCurrentUnitValue
(
this
.
_maxWidth
)
;
let
maxHeight
=
this
.
toCurrentUnitValue
(
this
.
_maxHeight
)
;
this
.
_customTopMargin
.
max
=
this
.
formatMaxAttr
(
maxHeight
-
this
.
_customBottomMargin
.
value
)
;
this
.
_customBottomMargin
.
max
=
this
.
formatMaxAttr
(
maxHeight
-
this
.
_customTopMargin
.
value
)
;
this
.
_customLeftMargin
.
max
=
this
.
formatMaxAttr
(
maxWidth
-
this
.
_customRightMargin
.
value
)
;
this
.
_customRightMargin
.
max
=
this
.
formatMaxAttr
(
maxWidth
-
this
.
_customLeftMargin
.
value
)
;
}
truncateTwoDecimals
(
val
)
{
if
(
val
.
split
(
"
.
"
)
[
1
]
.
length
>
2
)
{
let
dotIndex
=
val
.
indexOf
(
"
.
"
)
;
return
val
.
slice
(
0
dotIndex
+
3
)
;
}
return
val
;
}
formatMaxAttr
(
val
)
{
const
strVal
=
val
.
toString
(
)
;
if
(
strVal
.
includes
(
"
.
"
)
)
{
return
this
.
truncateTwoDecimals
(
strVal
)
;
}
return
val
;
}
formatMargin
(
target
)
{
if
(
target
.
value
.
includes
(
"
.
"
)
)
{
target
.
value
=
this
.
truncateTwoDecimals
(
target
.
value
)
;
}
}
toCurrentUnitValue
(
val
)
{
if
(
typeof
val
=
=
"
string
"
)
{
val
=
parseFloat
(
val
)
;
}
return
val
/
this
.
_toInchesMultiplier
;
}
toInchValue
(
val
)
{
if
(
typeof
val
=
=
"
string
"
)
{
val
=
parseFloat
(
val
)
;
}
return
val
*
this
.
_toInchesMultiplier
;
}
setAllMarginValues
(
settings
)
{
this
.
_customTopMargin
.
value
=
this
.
toCurrentUnitValue
(
settings
.
customMargins
.
marginTop
)
.
toFixed
(
2
)
;
this
.
_customBottomMargin
.
value
=
this
.
toCurrentUnitValue
(
settings
.
customMargins
.
marginBottom
)
.
toFixed
(
2
)
;
this
.
_customLeftMargin
.
value
=
this
.
toCurrentUnitValue
(
settings
.
customMargins
.
marginLeft
)
.
toFixed
(
2
)
;
this
.
_customRightMargin
.
value
=
this
.
toCurrentUnitValue
(
settings
.
customMargins
.
marginRight
)
.
toFixed
(
2
)
;
}
update
(
settings
)
{
this
.
_toInchesMultiplier
=
settings
.
paperSizeUnit
=
=
settings
.
kPaperSizeMillimeters
?
INCHES_PER_MM
:
1
;
if
(
settings
.
paperId
!
=
=
this
.
_paperId
|
|
settings
.
printerName
!
=
=
this
.
_printerName
|
|
settings
.
orientation
!
=
=
this
.
_orientation
)
{
let
enabledMargins
=
settings
.
marginOptions
;
for
(
let
option
of
this
.
_marginPicker
.
options
)
{
option
.
hidden
=
!
enabledMargins
[
option
.
value
]
;
}
this
.
_paperId
=
settings
.
paperId
;
this
.
_printerName
=
settings
.
printerName
;
this
.
_orientation
=
settings
.
orientation
;
let
height
=
this
.
_orientation
=
=
0
?
settings
.
paperHeight
:
settings
.
paperWidth
;
let
width
=
this
.
_orientation
=
=
0
?
settings
.
paperWidth
:
settings
.
paperHeight
;
let
heightInches
=
Math
.
round
(
this
.
_toInchesMultiplier
*
height
*
100
)
/
100
;
let
widthInches
=
Math
.
round
(
this
.
_toInchesMultiplier
*
width
*
100
)
/
100
;
this
.
_maxHeight
=
heightInches
-
settings
.
unwriteableMarginTop
-
settings
.
unwriteableMarginBottom
;
this
.
_maxWidth
=
widthInches
-
settings
.
unwriteableMarginLeft
-
settings
.
unwriteableMarginRight
;
this
.
_defaultPresets
=
settings
.
defaultMargins
;
this
.
setAllMarginValues
(
settings
)
;
this
.
updateMaxValues
(
)
;
this
.
dispatchEvent
(
new
Event
(
"
revalidate
"
{
bubbles
:
true
}
)
)
;
this
.
_marginError
.
hidden
=
true
;
}
if
(
settings
.
paperSizeUnit
!
=
=
this
.
_sizeUnit
)
{
this
.
_sizeUnit
=
settings
.
paperSizeUnit
;
let
unitStr
=
this
.
_sizeUnit
=
=
settings
.
kPaperSizeMillimeters
?
"
mm
"
:
"
inches
"
;
for
(
let
elem
of
this
.
querySelectorAll
(
"
[
data
-
unit
-
prefix
-
l10n
-
id
]
"
)
)
{
let
l10nId
=
elem
.
getAttribute
(
"
data
-
unit
-
prefix
-
l10n
-
id
"
)
+
unitStr
;
elem
.
setAttribute
(
"
data
-
l10n
-
id
"
l10nId
)
;
}
}
if
(
this
.
_marginPicker
.
value
!
=
"
custom
"
)
{
if
(
!
this
.
_customTopMargin
.
checkValidity
(
)
|
|
!
this
.
_customBottomMargin
.
checkValidity
(
)
|
|
!
this
.
_customLeftMargin
.
checkValidity
(
)
|
|
!
this
.
_customRightMargin
.
checkValidity
(
)
)
{
window
.
clearTimeout
(
this
.
showErrorTimeoutId
)
;
this
.
setAllMarginValues
(
settings
)
;
this
.
updateMaxValues
(
)
;
this
.
dispatchEvent
(
new
Event
(
"
revalidate
"
{
bubbles
:
true
}
)
)
;
this
.
_marginError
.
hidden
=
true
;
}
if
(
settings
.
margins
=
=
"
custom
"
)
{
this
.
querySelector
(
"
.
margin
-
group
"
)
.
hidden
=
false
;
}
this
.
_marginPicker
.
value
=
settings
.
margins
;
}
}
handleEvent
(
e
)
{
if
(
e
.
target
=
=
this
.
_marginPicker
)
{
let
customMargin
=
e
.
target
.
value
=
=
"
custom
"
;
this
.
querySelector
(
"
.
margin
-
group
"
)
.
hidden
=
!
customMargin
;
if
(
customMargin
)
{
this
.
updateCustomMargins
(
)
;
return
;
}
this
.
dispatchSettingsChange
(
{
margins
:
e
.
target
.
value
customMargins
:
null
}
)
;
}
if
(
e
.
target
=
=
this
.
_customTopMargin
|
|
e
.
target
=
=
this
.
_customBottomMargin
|
|
e
.
target
=
=
this
.
_customLeftMargin
|
|
e
.
target
=
=
this
.
_customRightMargin
)
{
if
(
e
.
target
.
checkValidity
(
)
)
{
this
.
updateMaxValues
(
)
;
}
if
(
this
.
_customTopMargin
.
validity
.
valid
&
&
this
.
_customBottomMargin
.
validity
.
valid
&
&
this
.
_customLeftMargin
.
validity
.
valid
&
&
this
.
_customRightMargin
.
validity
.
valid
)
{
this
.
formatMargin
(
e
.
target
)
;
this
.
updateCustomMargins
(
)
;
}
else
if
(
e
.
target
.
validity
.
stepMismatch
)
{
this
.
formatMargin
(
e
.
target
)
;
}
}
window
.
clearTimeout
(
this
.
showErrorTimeoutId
)
;
if
(
this
.
_customTopMargin
.
validity
.
valid
&
&
this
.
_customBottomMargin
.
validity
.
valid
&
&
this
.
_customLeftMargin
.
validity
.
valid
&
&
this
.
_customRightMargin
.
validity
.
valid
)
{
this
.
_marginError
.
hidden
=
true
;
}
else
{
this
.
cancelSettingsChange
(
{
customMargins
:
true
margins
:
true
}
)
;
this
.
showErrorTimeoutId
=
window
.
setTimeout
(
(
)
=
>
{
this
.
_marginError
.
hidden
=
false
;
}
INPUT_DELAY_MS
)
;
}
}
}
customElements
.
define
(
"
margins
-
select
"
MarginsPicker
)
;
class
TwistySummary
extends
PrintUIControlMixin
(
HTMLElement
)
{
get
isOpen
(
)
{
return
this
.
closest
(
"
details
"
)
?
.
hasAttribute
(
"
open
"
)
;
}
get
templateId
(
)
{
return
"
twisty
-
summary
-
template
"
;
}
initialize
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
super
.
initialize
(
)
;
this
.
label
=
this
.
querySelector
(
"
.
label
"
)
;
this
.
addEventListener
(
"
click
"
this
)
;
let
shouldOpen
=
Services
.
prefs
.
getBoolPref
(
"
print
.
more
-
settings
.
open
"
false
)
;
this
.
closest
(
"
details
"
)
.
open
=
shouldOpen
;
this
.
updateSummary
(
shouldOpen
)
;
}
handleEvent
(
e
)
{
let
willOpen
=
!
this
.
isOpen
;
Services
.
prefs
.
setBoolPref
(
"
print
.
more
-
settings
.
open
"
willOpen
)
;
this
.
updateSummary
(
willOpen
)
;
}
updateSummary
(
open
)
{
document
.
l10n
.
setAttributes
(
this
.
label
open
?
this
.
getAttribute
(
"
data
-
open
-
l10n
-
id
"
)
:
this
.
getAttribute
(
"
data
-
closed
-
l10n
-
id
"
)
)
;
}
}
customElements
.
define
(
"
twisty
-
summary
"
TwistySummary
)
;
class
PageCount
extends
PrintUIControlMixin
(
HTMLElement
)
{
initialize
(
)
{
super
.
initialize
(
)
;
document
.
addEventListener
(
"
page
-
count
"
this
)
;
}
update
(
settings
)
{
this
.
numCopies
=
settings
.
numCopies
;
this
.
duplex
=
settings
.
duplex
;
this
.
printToFile
=
settings
.
printToFile
;
this
.
render
(
)
;
}
render
(
)
{
if
(
!
this
.
numCopies
|
|
!
this
.
sheetCount
)
{
return
;
}
let
sheetCount
=
this
.
sheetCount
;
if
(
!
this
.
printToFile
&
&
this
.
duplex
!
=
Ci
.
nsIPrintSettings
.
kDuplexNone
)
{
sheetCount
=
Math
.
ceil
(
sheetCount
/
2
)
;
}
sheetCount
*
=
this
.
numCopies
;
document
.
l10n
.
setAttributes
(
this
"
printui
-
sheets
-
count
"
{
sheetCount
}
)
;
if
(
this
.
hasAttribute
(
"
loading
"
)
)
{
this
.
removeAttribute
(
"
loading
"
)
;
}
if
(
this
.
id
)
{
document
.
body
.
setAttribute
(
"
aria
-
describedby
"
this
.
id
)
;
}
}
handleEvent
(
e
)
{
this
.
sheetCount
=
e
.
detail
.
sheetCount
;
this
.
render
(
)
;
}
}
customElements
.
define
(
"
page
-
count
"
PageCount
)
;
class
PrintBackgrounds
extends
PrintSettingCheckbox
{
update
(
settings
)
{
super
.
update
(
settings
)
;
let
isSimplified
=
settings
.
sourceVersion
=
=
"
simplified
"
;
this
.
disabled
=
isSimplified
;
this
.
toggleAttribute
(
"
disallowed
"
isSimplified
)
;
this
.
checked
=
!
isSimplified
&
&
settings
.
printBackgrounds
;
}
}
customElements
.
define
(
"
print
-
backgrounds
"
PrintBackgrounds
{
extends
:
"
input
"
}
)
;
class
PrintButton
extends
PrintUIControlMixin
(
HTMLButtonElement
)
{
update
(
settings
)
{
let
l10nId
=
settings
.
printerName
=
=
PrintUtils
.
SAVE_TO_PDF_PRINTER
?
"
printui
-
primary
-
button
-
save
"
:
"
printui
-
primary
-
button
"
;
document
.
l10n
.
setAttributes
(
this
l10nId
)
;
}
}
customElements
.
define
(
"
print
-
button
"
PrintButton
{
extends
:
"
button
"
}
)
;
class
CancelButton
extends
HTMLButtonElement
{
constructor
(
)
{
super
(
)
;
this
.
addEventListener
(
"
click
"
(
)
=
>
{
this
.
dispatchEvent
(
new
Event
(
"
cancel
-
print
"
{
bubbles
:
true
}
)
)
;
}
)
;
}
}
customElements
.
define
(
"
cancel
-
button
"
CancelButton
{
extends
:
"
button
"
}
)
;
async
function
pickFileName
(
contentTitle
currentURI
)
{
let
picker
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
let
[
title
]
=
await
document
.
l10n
.
formatMessages
(
[
{
id
:
"
printui
-
save
-
to
-
pdf
-
title
"
}
]
)
;
title
=
title
.
value
;
let
filename
;
if
(
contentTitle
!
=
"
"
)
{
filename
=
contentTitle
;
}
else
{
let
url
=
new
URL
(
currentURI
)
;
let
path
=
decodeURIComponent
(
url
.
pathname
)
;
path
=
path
.
replace
(
/
\
/
/
"
"
)
;
filename
=
path
.
split
(
"
/
"
)
.
pop
(
)
;
if
(
filename
=
=
"
"
)
{
filename
=
url
.
hostname
;
}
}
if
(
!
filename
.
endsWith
(
"
.
pdf
"
)
)
{
filename
+
=
"
.
pdf
"
;
}
filename
=
DownloadPaths
.
sanitize
(
filename
)
;
picker
.
init
(
window
.
docShell
.
chromeEventHandler
.
ownerGlobal
title
Ci
.
nsIFilePicker
.
modeSave
)
;
picker
.
appendFilter
(
"
PDF
"
"
*
.
pdf
"
)
;
picker
.
defaultExtension
=
"
pdf
"
;
picker
.
defaultString
=
filename
;
let
retval
=
await
new
Promise
(
resolve
=
>
picker
.
open
(
resolve
)
)
;
if
(
retval
=
=
1
)
{
throw
new
Error
(
{
reason
:
"
cancelled
"
}
)
;
}
else
{
try
{
let
fstream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
fstream
.
init
(
picker
.
file
0x2a
0o666
0
)
;
fstream
.
close
(
)
;
await
IOUtils
.
remove
(
picker
.
file
.
path
)
;
}
catch
(
e
)
{
throw
new
Error
(
{
reason
:
retval
=
=
0
?
"
not_saved
"
:
"
not_replaced
"
}
)
;
}
}
return
picker
.
file
.
path
;
}
