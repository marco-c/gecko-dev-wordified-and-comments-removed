XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
PRINT_TAB_MODAL
"
"
print
.
tab_modal
.
enabled
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
PRINT_ALWAYS_SILENT
"
"
print
.
always_print_silent
"
false
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromptUtils
"
"
resource
:
/
/
gre
/
modules
/
SharedPromptUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrintingParent
"
"
resource
:
/
/
gre
/
actors
/
PrintingParent
.
jsm
"
)
;
var
gFocusedElement
=
null
;
var
gPendingPrintPreviews
=
new
Map
(
)
;
var
PrintUtils
=
{
SAVE_TO_PDF_PRINTER
:
"
Mozilla
Save
to
PDF
"
get
_bundle
(
)
{
delete
this
.
_bundle
;
return
(
this
.
_bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
printing
.
properties
"
)
)
;
}
showPageSetup
(
)
{
let
printSettings
=
this
.
getPrintSettings
(
)
;
let
PSSVC
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
if
(
!
PSSVC
.
lastUsedPrinterName
)
{
if
(
printSettings
.
printerName
)
{
PSSVC
.
savePrintSettingsToPrefs
(
printSettings
false
Ci
.
nsIPrintSettings
.
kInitSavePrinterName
)
;
PSSVC
.
savePrintSettingsToPrefs
(
printSettings
true
Ci
.
nsIPrintSettings
.
kInitSaveAll
)
;
}
}
try
{
var
PRINTPROMPTSVC
=
Cc
[
"
mozilla
.
org
/
embedcomp
/
printingprompt
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintingPromptService
)
;
PRINTPROMPTSVC
.
showPageSetupDialog
(
window
printSettings
null
)
;
}
catch
(
e
)
{
dump
(
"
showPageSetup
"
+
e
+
"
\
n
"
)
;
return
false
;
}
return
true
;
}
getTabDialogBox
(
sourceBrowser
)
{
return
gBrowser
.
getTabDialogBox
(
sourceBrowser
)
;
}
getPreviewBrowser
(
sourceBrowser
)
{
let
dialogBox
=
this
.
getTabDialogBox
(
sourceBrowser
)
;
for
(
let
dialog
of
dialogBox
.
getTabDialogManager
(
)
.
_dialogs
)
{
let
browser
=
dialog
.
_box
.
querySelector
(
"
.
printPreviewBrowser
"
)
;
if
(
browser
)
{
return
browser
;
}
}
return
null
;
}
updatePrintPreviewMenuHiddenState
(
)
{
let
printPreviewMenuItem
=
document
.
getElementById
(
"
menu_printPreview
"
)
;
if
(
printPreviewMenuItem
)
{
printPreviewMenuItem
.
hidden
=
PRINT_TAB_MODAL
;
}
let
pageSetupMenuItem
=
document
.
getElementById
(
"
menu_printSetup
"
)
;
if
(
pageSetupMenuItem
)
{
pageSetupMenuItem
.
hidden
=
PRINT_TAB_MODAL
;
}
}
createBrowser
(
params
)
{
return
gBrowser
.
createBrowser
(
params
)
;
}
_openTabModalPrint
(
aBrowsingContext
aOpenWindowInfo
aPrintInitiationTime
aPrintSelectionOnly
aPrintFrameOnly
)
{
let
sourceBrowser
=
aBrowsingContext
.
top
.
embedderElement
;
let
previewBrowser
=
this
.
getPreviewBrowser
(
sourceBrowser
)
;
if
(
previewBrowser
)
{
return
{
promise
:
Promise
.
reject
(
)
browser
:
null
}
;
}
let
args
=
PromptUtils
.
objectToPropBag
(
{
printSelectionOnly
:
!
!
aPrintSelectionOnly
isArticle
:
sourceBrowser
.
isArticle
printFrameOnly
:
!
!
aPrintFrameOnly
}
)
;
let
dialogBox
=
this
.
getTabDialogBox
(
sourceBrowser
)
;
let
{
closedPromise
dialog
}
=
dialogBox
.
open
(
chrome
:
/
/
global
/
content
/
print
.
html
?
printInitiationTime
=
{
aPrintInitiationTime
}
{
features
:
"
resizable
=
no
"
sizeTo
:
"
available
"
}
args
)
;
let
settingsBrowser
=
dialog
.
_frame
;
let
printPreview
=
new
PrintPreview
(
{
sourceBrowsingContext
:
aBrowsingContext
settingsBrowser
topBrowsingContext
:
aBrowsingContext
.
top
activeBrowsingContext
:
aBrowsingContext
openWindowInfo
:
aOpenWindowInfo
printFrameOnly
:
aPrintFrameOnly
}
)
;
settingsBrowser
.
parentElement
.
insertBefore
(
printPreview
settingsBrowser
)
;
return
{
promise
:
closedPromise
browser
:
printPreview
.
sourceBrowser
}
;
}
startPrintWindow
(
aBrowsingContext
aOptions
)
{
const
printInitiationTime
=
Date
.
now
(
)
;
let
openWindowInfo
printSelectionOnly
printFrameOnly
;
if
(
aOptions
)
{
(
{
openWindowInfo
printSelectionOnly
printFrameOnly
}
=
aOptions
)
;
}
if
(
PRINT_TAB_MODAL
&
&
!
PRINT_ALWAYS_SILENT
&
&
(
!
openWindowInfo
|
|
openWindowInfo
.
isForWindowDotPrint
)
)
{
let
browsingContext
=
aBrowsingContext
;
let
focusedBc
=
Services
.
focus
.
focusedContentBrowsingContext
;
if
(
focusedBc
&
&
focusedBc
.
top
.
embedderElement
=
=
browsingContext
.
top
.
embedderElement
&
&
(
!
openWindowInfo
|
|
!
openWindowInfo
.
isForWindowDotPrint
)
&
&
!
printFrameOnly
)
{
browsingContext
=
focusedBc
;
}
let
{
promise
browser
}
=
this
.
_openTabModalPrint
(
browsingContext
openWindowInfo
printInitiationTime
printSelectionOnly
printFrameOnly
)
;
promise
.
catch
(
e
=
>
{
Cu
.
reportError
(
e
)
;
}
)
;
return
browser
;
}
if
(
openWindowInfo
)
{
let
printPreview
=
new
PrintPreview
(
{
sourceBrowsingContext
:
aBrowsingContext
openWindowInfo
}
)
;
let
browser
=
printPreview
.
createPreviewBrowser
(
"
source
"
)
;
document
.
documentElement
.
append
(
browser
)
;
return
browser
;
}
let
settings
=
this
.
getPrintSettings
(
)
;
settings
.
printSelectionOnly
=
printSelectionOnly
;
this
.
printWindow
(
aBrowsingContext
settings
)
;
return
null
;
}
printWindow
(
aBrowsingContext
aPrintSettings
)
{
let
wg
=
aBrowsingContext
.
currentWindowGlobal
;
const
printPreviewIsOpen
=
!
!
document
.
getElementById
(
"
print
-
preview
-
toolbar
"
)
;
if
(
printPreviewIsOpen
)
{
this
.
_logKeyedTelemetry
(
"
PRINT_DIALOG_OPENED_COUNT
"
"
FROM_PREVIEW
"
)
;
}
else
{
this
.
_logKeyedTelemetry
(
"
PRINT_DIALOG_OPENED_COUNT
"
"
FROM_PAGE
"
)
;
}
let
printSettings
=
aPrintSettings
|
|
this
.
getPrintSettings
(
)
;
printSettings
.
title
=
this
.
_originalTitle
|
|
wg
.
documentTitle
;
if
(
this
.
_shouldSimplify
)
{
printSettings
.
docURL
=
this
.
_originalURL
|
|
wg
.
documentURI
;
}
let
promise
=
aBrowsingContext
.
print
(
printSettings
)
;
if
(
printPreviewIsOpen
)
{
if
(
this
.
_shouldSimplify
)
{
this
.
_logKeyedTelemetry
(
"
PRINT_COUNT
"
"
SIMPLIFIED
"
)
;
}
else
{
this
.
_logKeyedTelemetry
(
"
PRINT_COUNT
"
"
WITH_PREVIEW
"
)
;
}
}
else
{
this
.
_logKeyedTelemetry
(
"
PRINT_COUNT
"
"
WITHOUT_PREVIEW
"
)
;
}
return
promise
;
}
printPreview
(
aListenerObj
)
{
if
(
PRINT_TAB_MODAL
)
{
let
currentDialogBox
=
gBrowser
.
selectedBrowser
.
tabDialogBox
;
if
(
currentDialogBox
)
{
let
manager
=
currentDialogBox
.
getTabDialogManager
(
)
;
let
dialogs
=
manager
.
hasDialogs
&
&
manager
.
dialogs
;
if
(
dialogs
)
{
for
(
let
dialog
of
dialogs
)
{
if
(
dialog
.
_openedURL
.
includes
(
"
print
.
html
"
)
)
{
dialog
.
close
(
)
;
return
Promise
.
resolve
(
)
;
}
}
}
}
let
browsingContext
=
gBrowser
.
selectedBrowser
.
browsingContext
;
let
focusedBc
=
Services
.
focus
.
focusedContentBrowsingContext
;
if
(
focusedBc
&
&
focusedBc
.
top
.
embedderElement
=
=
browsingContext
.
top
.
embedderElement
)
{
browsingContext
=
focusedBc
;
}
return
this
.
_openTabModalPrint
(
browsingContext
undefined
Date
.
now
(
)
)
.
promise
;
}
let
printPreviewTB
=
document
.
getElementById
(
"
print
-
preview
-
toolbar
"
)
;
if
(
!
printPreviewTB
)
{
this
.
_listener
=
aListenerObj
;
this
.
_sourceBrowser
=
aListenerObj
.
getSourceBrowser
(
)
;
this
.
_originalTitle
=
this
.
_sourceBrowser
.
contentTitle
;
this
.
_originalURL
=
this
.
_sourceBrowser
.
currentURI
.
spec
;
this
.
logTelemetry
(
"
PRINT_PREVIEW_OPENED_COUNT
"
)
;
}
else
{
printPreviewTB
.
disableUpdateTriggers
(
true
)
;
this
.
_sourceBrowser
=
this
.
_shouldSimplify
?
this
.
_listener
.
getSimplifiedPrintPreviewBrowser
(
)
:
this
.
_listener
.
getPrintPreviewBrowser
(
)
;
this
.
_sourceBrowser
.
collapsed
=
true
;
this
.
ensureProgressDialogClosed
(
)
;
}
this
.
_webProgressPP
=
{
}
;
let
ppParams
=
{
}
;
let
notifyOnOpen
=
{
}
;
let
printSettings
=
this
.
getPrintSettings
(
)
;
let
PPROMPTSVC
=
Cc
[
"
mozilla
.
org
/
embedcomp
/
printingprompt
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintingPromptService
)
;
let
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_onEntered
.
push
(
{
resolve
reject
}
)
;
}
)
;
try
{
PPROMPTSVC
.
showPrintProgressDialog
(
window
printSettings
this
.
_obsPP
false
this
.
_webProgressPP
ppParams
notifyOnOpen
)
;
if
(
ppParams
.
value
)
{
ppParams
.
value
.
docTitle
=
this
.
_originalTitle
;
ppParams
.
value
.
docURL
=
this
.
_originalURL
;
}
if
(
!
notifyOnOpen
.
value
.
valueOf
(
)
|
|
this
.
_webProgressPP
.
value
=
=
null
)
{
this
.
_enterPrintPreview
(
)
;
}
}
catch
(
e
)
{
this
.
_enterPrintPreview
(
)
;
}
return
promise
;
}
_listener
:
null
_closeHandlerPP
:
null
_webProgressPP
:
null
_sourceBrowser
:
null
_originalTitle
:
"
"
_originalURL
:
"
"
_shouldSimplify
:
false
_getErrorCodeForNSResult
(
nsresult
)
{
const
MSG_CODES
=
[
"
GFX_PRINTER_NO_PRINTER_AVAILABLE
"
"
GFX_PRINTER_NAME_NOT_FOUND
"
"
GFX_PRINTER_COULD_NOT_OPEN_FILE
"
"
GFX_PRINTER_STARTDOC
"
"
GFX_PRINTER_ENDDOC
"
"
GFX_PRINTER_STARTPAGE
"
"
GFX_PRINTER_DOC_IS_BUSY
"
"
ABORT
"
"
NOT_AVAILABLE
"
"
NOT_IMPLEMENTED
"
"
OUT_OF_MEMORY
"
"
UNEXPECTED
"
]
;
for
(
let
code
of
MSG_CODES
)
{
let
nsErrorResult
=
"
NS_ERROR_
"
+
code
;
if
(
Cr
[
nsErrorResult
]
=
=
nsresult
)
{
return
code
;
}
}
return
"
FAILURE
"
;
}
_displayPrintingError
(
nsresult
isPrinting
)
{
let
msgName
=
"
PERR_
"
+
this
.
_getErrorCodeForNSResult
(
nsresult
)
;
let
msg
title
;
if
(
!
isPrinting
)
{
let
ppMsgName
=
msgName
+
"
_PP
"
;
try
{
msg
=
this
.
_bundle
.
GetStringFromName
(
ppMsgName
)
;
}
catch
(
e
)
{
}
}
if
(
!
msg
)
{
msg
=
this
.
_bundle
.
GetStringFromName
(
msgName
)
;
}
title
=
this
.
_bundle
.
GetStringFromName
(
isPrinting
?
"
print_error_dialog_title
"
:
"
printpreview_error_dialog_title
"
)
;
Services
.
prompt
.
alert
(
window
title
msg
)
;
Services
.
telemetry
.
keyedScalarAdd
(
"
printing
.
error
"
this
.
_getErrorCodeForNSResult
(
nsresult
)
1
)
;
}
_setPrinterDefaultsForSelectedPrinter
(
aPSSVC
aPrintSettings
defaultsOnly
=
false
)
{
if
(
!
aPrintSettings
.
printerName
)
{
aPrintSettings
.
printerName
=
aPSSVC
.
lastUsedPrinterName
;
if
(
!
aPrintSettings
.
printerName
)
{
let
printerList
=
Cc
[
"
mozilla
.
org
/
gfx
/
printerlist
;
1
"
]
.
getService
(
Ci
.
nsIPrinterList
)
;
aPrintSettings
.
printerName
=
printerList
.
systemDefaultPrinterName
;
}
}
if
(
aPrintSettings
.
printerName
!
=
this
.
SAVE_TO_PDF_PRINTER
)
{
aPSSVC
.
initPrintSettingsFromPrinter
(
aPrintSettings
.
printerName
aPrintSettings
)
;
}
if
(
!
defaultsOnly
)
{
aPSSVC
.
initPrintSettingsFromPrefs
(
aPrintSettings
true
aPrintSettings
.
kInitSaveAll
)
;
}
}
getPrintSettings
(
aPrinterName
defaultsOnly
)
{
var
printSettings
;
try
{
var
PSSVC
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
printSettings
=
PSSVC
.
newPrintSettings
;
if
(
aPrinterName
)
{
printSettings
.
printerName
=
aPrinterName
;
}
this
.
_setPrinterDefaultsForSelectedPrinter
(
PSSVC
printSettings
defaultsOnly
)
;
}
catch
(
e
)
{
dump
(
"
getPrintSettings
:
"
+
e
+
"
\
n
"
)
;
}
return
printSettings
;
}
_obsPP
:
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
)
{
return
;
}
setTimeout
(
function
(
)
{
PrintUtils
.
_enterPrintPreview
(
)
;
}
0
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
}
get
shouldSimplify
(
)
{
return
this
.
_shouldSimplify
;
}
setSimplifiedMode
(
shouldSimplify
)
{
this
.
_shouldSimplify
=
shouldSimplify
;
}
_onEntered
:
[
]
_ppBrowsers
:
new
Set
(
)
_currentPPBrowser
:
null
_enterPrintPreview
(
)
{
let
ppBrowser
=
this
.
_shouldSimplify
?
this
.
_listener
.
getSimplifiedPrintPreviewBrowser
(
)
:
this
.
_listener
.
getPrintPreviewBrowser
(
)
;
this
.
_ppBrowsers
.
add
(
ppBrowser
)
;
let
oldPPBrowser
=
null
;
let
changingPrintPreviewBrowsers
=
false
;
if
(
this
.
_currentPPBrowser
&
&
ppBrowser
!
=
this
.
_currentPPBrowser
)
{
changingPrintPreviewBrowsers
=
true
;
oldPPBrowser
=
this
.
_currentPPBrowser
;
}
this
.
_currentPPBrowser
=
ppBrowser
;
let
waitForPrintProgressToEnableToolbar
=
false
;
if
(
this
.
_webProgressPP
.
value
)
{
waitForPrintProgressToEnableToolbar
=
true
;
}
gPendingPrintPreviews
.
set
(
ppBrowser
waitForPrintProgressToEnableToolbar
)
;
if
(
this
.
_shouldSimplify
)
{
let
simplifiedBrowser
=
this
.
_listener
.
getSimplifiedSourceBrowser
(
)
;
if
(
!
simplifiedBrowser
)
{
simplifiedBrowser
=
this
.
_listener
.
createSimplifiedBrowser
(
)
;
simplifiedBrowser
.
sendMessageToActor
(
"
Printing
:
Preview
:
ParseDocument
"
{
URL
:
this
.
_originalURL
windowID
:
oldPPBrowser
.
outerWindowID
}
"
Printing
"
)
;
this
.
logTelemetry
(
"
PRINT_PREVIEW_SIMPLIFY_PAGE_OPENED_COUNT
"
)
;
return
;
}
}
this
.
sendEnterPrintPreviewToChild
(
ppBrowser
this
.
_sourceBrowser
this
.
_shouldSimplify
changingPrintPreviewBrowsers
)
;
}
sendEnterPrintPreviewToChild
(
ppBrowser
sourceBrowser
simplifiedMode
changingBrowsers
)
{
ppBrowser
.
sendMessageToActor
(
"
Printing
:
Preview
:
Enter
"
{
browsingContextId
:
sourceBrowser
.
browsingContext
.
id
simplifiedMode
changingBrowsers
lastUsedPrinterName
:
this
.
getLastUsedPrinterName
(
)
}
"
Printing
"
)
;
}
printPreviewEntered
(
ppBrowser
previewResult
)
{
let
waitForPrintProgressToEnableToolbar
=
gPendingPrintPreviews
.
get
(
ppBrowser
)
;
gPendingPrintPreviews
.
delete
(
ppBrowser
)
;
for
(
let
{
resolve
reject
}
of
this
.
_onEntered
)
{
if
(
previewResult
.
failed
)
{
reject
(
)
;
}
else
{
resolve
(
)
;
}
}
this
.
_onEntered
=
[
]
;
if
(
previewResult
.
failed
)
{
this
.
_ppBrowsers
.
clear
(
)
;
this
.
_listener
.
onEnter
(
)
;
this
.
_listener
.
onExit
(
)
;
return
;
}
gFocusedElement
=
document
.
commandDispatcher
.
focusedElement
;
let
printPreviewTB
=
document
.
getElementById
(
"
print
-
preview
-
toolbar
"
)
;
if
(
printPreviewTB
)
{
if
(
previewResult
.
changingBrowsers
)
{
printPreviewTB
.
destroy
(
)
;
printPreviewTB
.
initialize
(
ppBrowser
)
;
}
else
{
printPreviewTB
.
updateToolbar
(
)
;
}
if
(
!
waitForPrintProgressToEnableToolbar
)
{
printPreviewTB
.
disableUpdateTriggers
(
false
)
;
}
ppBrowser
.
collapsed
=
false
;
ppBrowser
.
focus
(
)
;
return
;
}
if
(
this
.
_listener
.
activateBrowser
)
{
this
.
_listener
.
activateBrowser
(
this
.
_sourceBrowser
)
;
}
else
{
this
.
_sourceBrowser
.
docShellIsActive
=
true
;
}
printPreviewTB
=
document
.
createXULElement
(
"
toolbar
"
{
is
:
"
printpreview
-
toolbar
"
}
)
;
printPreviewTB
.
setAttribute
(
"
fullscreentoolbar
"
true
)
;
printPreviewTB
.
setAttribute
(
"
flex
"
"
1
"
)
;
printPreviewTB
.
id
=
"
print
-
preview
-
toolbar
"
;
let
navToolbox
=
this
.
_listener
.
getNavToolbox
(
)
;
navToolbox
.
parentNode
.
insertBefore
(
printPreviewTB
navToolbox
)
;
printPreviewTB
.
initialize
(
ppBrowser
)
;
if
(
waitForPrintProgressToEnableToolbar
)
{
printPreviewTB
.
disableUpdateTriggers
(
true
)
;
}
if
(
this
.
_sourceBrowser
.
isArticle
)
{
printPreviewTB
.
enableSimplifyPage
(
)
;
}
else
{
this
.
logTelemetry
(
"
PRINT_PREVIEW_SIMPLIFY_PAGE_UNAVAILABLE_COUNT
"
)
;
printPreviewTB
.
disableSimplifyPage
(
)
;
}
if
(
window
.
onclose
)
{
this
.
_closeHandlerPP
=
window
.
onclose
;
}
else
{
this
.
_closeHandlerPP
=
null
;
}
window
.
onclose
=
function
(
)
{
PrintUtils
.
exitPrintPreview
(
)
;
return
false
;
}
;
window
.
addEventListener
(
"
keydown
"
this
.
onKeyDownPP
true
)
;
window
.
addEventListener
(
"
keypress
"
this
.
onKeyPressPP
true
)
;
ppBrowser
.
collapsed
=
false
;
ppBrowser
.
focus
(
)
;
this
.
_listener
.
onEnter
(
)
;
}
readerModeReady
(
sourceBrowser
)
{
if
(
PRINT_TAB_MODAL
)
{
return
;
}
let
ppBrowser
=
this
.
_listener
.
getSimplifiedPrintPreviewBrowser
(
)
;
this
.
sendEnterPrintPreviewToChild
(
ppBrowser
sourceBrowser
true
true
)
;
}
getLastUsedPrinterName
(
)
{
let
PSSVC
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
let
lastUsedPrinterName
=
PSSVC
.
lastUsedPrinterName
;
if
(
!
lastUsedPrinterName
)
{
let
settings
=
this
.
getPrintSettings
(
)
;
if
(
settings
.
printerName
)
{
PSSVC
.
savePrintSettingsToPrefs
(
settings
false
Ci
.
nsIPrintSettings
.
kInitSavePrinterName
)
;
PSSVC
.
savePrintSettingsToPrefs
(
settings
true
Ci
.
nsIPrintSettings
.
kInitSaveAll
)
;
lastUsedPrinterName
=
settings
.
printerName
;
}
}
return
lastUsedPrinterName
;
}
exitPrintPreview
(
)
{
for
(
let
browser
of
this
.
_ppBrowsers
)
{
browser
.
sendMessageToActor
(
"
Printing
:
Preview
:
Exit
"
{
}
"
Printing
"
)
;
}
this
.
_ppBrowsers
.
clear
(
)
;
this
.
_currentPPBrowser
=
null
;
window
.
removeEventListener
(
"
keydown
"
this
.
onKeyDownPP
true
)
;
window
.
removeEventListener
(
"
keypress
"
this
.
onKeyPressPP
true
)
;
if
(
this
.
_closeHandlerPP
)
{
window
.
onclose
=
this
.
_closeHandlerPP
;
}
else
{
window
.
onclose
=
null
;
}
this
.
_closeHandlerPP
=
null
;
let
printPreviewTB
=
document
.
getElementById
(
"
print
-
preview
-
toolbar
"
)
;
printPreviewTB
.
destroy
(
)
;
printPreviewTB
.
remove
(
)
;
if
(
gFocusedElement
)
{
Services
.
focus
.
setFocus
(
gFocusedElement
Services
.
focus
.
FLAG_NOSCROLL
)
;
}
else
{
this
.
_sourceBrowser
.
focus
(
)
;
}
gFocusedElement
=
null
;
this
.
setSimplifiedMode
(
false
)
;
this
.
ensureProgressDialogClosed
(
)
;
this
.
_listener
.
onExit
(
)
;
this
.
_originalTitle
=
"
"
;
this
.
_originalURL
=
"
"
;
}
logTelemetry
(
ID
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
ID
)
;
histogram
.
add
(
true
)
;
}
_logKeyedTelemetry
(
id
key
)
{
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
id
)
;
histogram
.
add
(
key
)
;
}
onKeyDownPP
(
aEvent
)
{
if
(
aEvent
.
keyCode
=
=
aEvent
.
DOM_VK_ESCAPE
)
{
PrintUtils
.
exitPrintPreview
(
)
;
}
}
onKeyPressPP
(
aEvent
)
{
var
closeKey
;
try
{
closeKey
=
document
.
getElementById
(
"
key_close
"
)
.
getAttribute
(
"
key
"
)
;
closeKey
=
aEvent
[
"
DOM_VK_
"
+
closeKey
]
;
}
catch
(
e
)
{
}
var
isModif
=
aEvent
.
ctrlKey
|
|
aEvent
.
metaKey
;
if
(
isModif
&
&
(
aEvent
.
charCode
=
=
closeKey
|
|
aEvent
.
charCode
=
=
closeKey
+
32
)
)
{
PrintUtils
.
exitPrintPreview
(
)
;
}
else
if
(
isModif
)
{
var
printPreviewTB
=
document
.
getElementById
(
"
print
-
preview
-
toolbar
"
)
;
var
printKey
=
document
.
getElementById
(
"
printKb
"
)
.
getAttribute
(
"
key
"
)
.
toUpperCase
(
)
;
var
pressedKey
=
String
.
fromCharCode
(
aEvent
.
charCode
)
.
toUpperCase
(
)
;
if
(
printKey
=
=
pressedKey
)
{
printPreviewTB
.
print
(
)
;
}
}
if
(
isModif
)
{
aEvent
.
preventDefault
(
)
;
aEvent
.
stopPropagation
(
)
;
}
}
ensureProgressDialogClosed
(
)
{
if
(
this
.
_webProgressPP
&
&
this
.
_webProgressPP
.
value
)
{
this
.
_webProgressPP
.
value
.
onStateChange
(
null
null
Ci
.
nsIWebProgressListener
.
STATE_STOP
0
)
;
}
}
}
;
class
PrintPreview
extends
MozElements
.
BaseControl
{
constructor
(
{
sourceBrowsingContext
settingsBrowser
topBrowsingContext
activeBrowsingContext
openWindowInfo
printFrameOnly
}
)
{
super
(
)
;
this
.
sourceBrowsingContext
=
sourceBrowsingContext
;
this
.
settingsBrowser
=
settingsBrowser
;
this
.
topBrowsingContext
=
topBrowsingContext
;
this
.
activeBrowsingContext
=
activeBrowsingContext
;
this
.
openWindowInfo
=
openWindowInfo
;
this
.
printFrameOnly
=
printFrameOnly
;
this
.
printSelectionOnly
=
false
;
this
.
simplifyPage
=
false
;
this
.
sourceBrowser
=
null
;
this
.
selectionBrowser
=
null
;
this
.
simplifiedBrowser
=
null
;
this
.
lastPreviewBrowser
=
null
;
}
connectedCallback
(
)
{
if
(
this
.
childElementCount
>
0
)
{
return
;
}
this
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
append
(
MozXULElement
.
parseXULToFragment
(
<
stack
class
=
"
previewStack
"
rendering
=
"
true
"
flex
=
"
1
"
previewtype
=
"
primary
"
>
<
vbox
class
=
"
previewRendering
"
flex
=
"
1
"
>
<
h1
class
=
"
print
-
pending
-
label
"
data
-
l10n
-
id
=
"
printui
-
loading
"
>
<
/
h1
>
<
/
vbox
>
<
html
:
printpreview
-
pagination
class
=
"
printPreviewNavigation
"
>
<
/
html
:
printpreview
-
pagination
>
<
/
stack
>
)
)
;
this
.
stack
=
this
.
firstElementChild
;
this
.
paginator
=
this
.
querySelector
(
"
printpreview
-
pagination
"
)
;
if
(
this
.
openWindowInfo
)
{
this
.
createPreviewBrowser
(
"
source
"
)
;
}
}
disconnectedCallback
(
)
{
this
.
exitPrintPreview
(
)
;
}
getSourceBrowsingContext
(
)
{
if
(
this
.
openWindowInfo
)
{
return
this
.
sourceBrowser
.
browsingContext
;
}
return
this
.
sourceBrowsingContext
;
}
get
canPrintSelectionOnly
(
)
{
return
!
!
this
.
sourceBrowsingContext
.
currentRemoteType
;
}
get
currentBrowsingContext
(
)
{
return
this
.
lastPreviewBrowser
.
browsingContext
;
}
exitPrintPreview
(
)
{
this
.
sourceBrowser
?
.
frameLoader
?
.
exitPrintPreview
(
)
;
this
.
simplifiedBrowser
?
.
frameLoader
?
.
exitPrintPreview
(
)
;
this
.
selectionBrowser
?
.
frameLoader
?
.
exitPrintPreview
(
)
;
this
.
textContent
=
"
"
;
}
async
printPreview
(
settings
{
sourceVersion
sourceURI
}
)
{
this
.
stack
.
setAttribute
(
"
rendering
"
true
)
;
let
result
=
await
this
.
_printPreview
(
settings
{
sourceVersion
sourceURI
}
)
;
let
browser
=
this
.
lastPreviewBrowser
;
this
.
stack
.
setAttribute
(
"
previewtype
"
browser
.
getAttribute
(
"
previewtype
"
)
)
;
browser
.
setAttribute
(
"
sheet
-
count
"
result
.
sheetCount
)
;
browser
.
setAttribute
(
"
current
-
page
"
1
)
;
this
.
paginator
.
observePreviewBrowser
(
browser
)
;
await
document
.
l10n
.
translateElements
(
[
browser
]
)
;
this
.
stack
.
removeAttribute
(
"
rendering
"
)
;
return
result
;
}
async
_printPreview
(
settings
{
sourceVersion
sourceURI
}
)
{
let
printSelectionOnly
=
sourceVersion
=
=
"
selection
"
&
&
this
.
canPrintSelectionOnly
;
let
simplifyPage
=
sourceVersion
=
=
"
simplified
"
;
let
selectionTypeBrowser
;
let
previewBrowser
;
if
(
printSelectionOnly
)
{
selectionTypeBrowser
=
this
.
selectionBrowser
;
previewBrowser
=
this
.
selectionBrowser
;
}
else
{
selectionTypeBrowser
=
this
.
sourceBrowser
;
previewBrowser
=
simplifyPage
?
this
.
simplifiedBrowser
:
this
.
sourceBrowser
;
}
settings
.
docURL
=
sourceURI
;
if
(
previewBrowser
)
{
this
.
lastPreviewBrowser
=
previewBrowser
;
if
(
this
.
openWindowInfo
)
{
this
.
openWindowInfo
=
null
;
}
return
previewBrowser
.
frameLoader
.
printPreview
(
settings
null
)
;
}
if
(
!
selectionTypeBrowser
)
{
selectionTypeBrowser
=
this
.
createPreviewBrowser
(
simplifyPage
?
"
source
"
:
sourceVersion
)
;
let
browsingContext
=
printSelectionOnly
|
|
this
.
printFrameOnly
?
this
.
activeBrowsingContext
:
this
.
topBrowsingContext
;
let
result
=
await
selectionTypeBrowser
.
frameLoader
.
printPreview
(
settings
browsingContext
)
;
if
(
!
simplifyPage
)
{
this
.
lastPreviewBrowser
=
selectionTypeBrowser
;
return
result
;
}
}
previewBrowser
=
this
.
createPreviewBrowser
(
sourceVersion
)
;
await
previewBrowser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
Printing
"
)
.
sendQuery
(
"
Printing
:
Preview
:
ParseDocument
"
{
URL
:
sourceURI
windowID
:
selectionTypeBrowser
.
browsingContext
.
currentWindowGlobal
.
outerWindowId
}
)
;
this
.
lastPreviewBrowser
=
previewBrowser
;
return
previewBrowser
.
frameLoader
.
printPreview
(
settings
previewBrowser
.
browsingContext
)
;
}
createPreviewBrowser
(
sourceVersion
)
{
let
browser
=
document
.
createXULElement
(
"
browser
"
)
;
let
browsingContext
=
sourceVersion
=
=
"
selection
"
|
|
this
.
printFrameOnly
|
|
(
sourceVersion
=
=
"
source
"
&
&
this
.
openWindowInfo
)
?
this
.
sourceBrowsingContext
:
this
.
sourceBrowsingContext
.
top
;
if
(
sourceVersion
=
=
"
source
"
&
&
this
.
openWindowInfo
)
{
browser
.
openWindowInfo
=
this
.
openWindowInfo
;
}
else
{
let
userContextId
=
browsingContext
.
originAttributes
.
userContextId
;
if
(
userContextId
)
{
browser
.
setAttribute
(
"
usercontextid
"
userContextId
)
;
}
browser
.
setAttribute
(
"
initialBrowsingContextGroupId
"
browsingContext
.
group
.
id
)
;
}
browser
.
setAttribute
(
"
type
"
"
content
"
)
;
let
remoteType
=
browsingContext
.
currentRemoteType
;
if
(
remoteType
)
{
browser
.
setAttribute
(
"
remoteType
"
remoteType
)
;
browser
.
setAttribute
(
"
remote
"
"
true
"
)
;
}
browser
.
addEventListener
(
"
DOMWindowClose
"
function
(
e
)
{
if
(
this
.
isConnected
)
{
this
.
remove
(
)
;
}
e
.
stopPropagation
(
)
;
e
.
preventDefault
(
)
;
}
)
;
if
(
this
.
settingsBrowser
)
{
browser
.
addEventListener
(
"
contextmenu
"
function
(
e
)
{
e
.
preventDefault
(
)
;
}
)
;
browser
.
setAttribute
(
"
previewtype
"
sourceVersion
)
;
browser
.
classList
.
add
(
"
printPreviewBrowser
"
)
;
browser
.
setAttribute
(
"
flex
"
"
1
"
)
;
browser
.
setAttribute
(
"
printpreview
"
"
true
"
)
;
browser
.
setAttribute
(
"
nodefaultsrc
"
"
true
"
)
;
document
.
l10n
.
setAttributes
(
browser
"
printui
-
preview
-
label
"
)
;
this
.
stack
.
insertBefore
(
browser
this
.
paginator
)
;
if
(
sourceVersion
=
=
"
source
"
)
{
this
.
sourceBrowser
=
browser
;
}
else
if
(
sourceVersion
=
=
"
selection
"
)
{
this
.
selectionBrowser
=
browser
;
}
else
if
(
sourceVersion
=
=
"
simplified
"
)
{
this
.
simplifiedBrowser
=
browser
;
}
}
else
{
browser
.
style
.
visibility
=
"
collapse
"
;
}
return
browser
;
}
}
customElements
.
define
(
"
print
-
preview
"
PrintPreview
)
;
