XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
SHOW_PAGE_SETUP_MENU
"
"
print
.
show_page_setup_menu
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
PRINT_ALWAYS_SILENT
"
"
print
.
always_print_silent
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
PREFER_SYSTEM_DIALOG
"
"
print
.
prefer_system_dialog
"
false
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromptUtils
"
"
resource
:
/
/
gre
/
modules
/
SharedPromptUtils
.
jsm
"
)
;
var
PrintUtils
=
{
SAVE_TO_PDF_PRINTER
:
"
Mozilla
Save
to
PDF
"
get
_bundle
(
)
{
delete
this
.
_bundle
;
return
(
this
.
_bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
printing
.
properties
"
)
)
;
}
async
checkForSelection
(
browsingContext
)
{
try
{
let
sourceActor
=
browsingContext
.
currentWindowGlobal
.
getActor
(
"
PrintingSelection
"
)
;
return
await
sourceActor
.
sendQuery
(
"
PrintingSelection
:
HasSelection
"
{
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
false
;
}
updatePrintSetupMenuHiddenState
(
)
{
let
pageSetupMenuItem
=
document
.
getElementById
(
"
menu_printSetup
"
)
;
if
(
pageSetupMenuItem
)
{
pageSetupMenuItem
.
hidden
=
!
SHOW_PAGE_SETUP_MENU
;
}
}
showPageSetup
(
)
{
let
printSettings
=
this
.
getPrintSettings
(
)
;
let
PSSVC
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
if
(
!
PSSVC
.
lastUsedPrinterName
)
{
if
(
printSettings
.
printerName
)
{
PSSVC
.
savePrintSettingsToPrefs
(
printSettings
false
Ci
.
nsIPrintSettings
.
kInitSavePrinterName
)
;
PSSVC
.
savePrintSettingsToPrefs
(
printSettings
true
Ci
.
nsIPrintSettings
.
kInitSaveAll
)
;
}
}
try
{
var
PRINTDIALOGSVC
=
Cc
[
"
mozilla
.
org
/
widget
/
printdialog
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintDialogService
)
;
PRINTDIALOGSVC
.
showPageSetupDialog
(
window
printSettings
null
)
;
}
catch
(
e
)
{
dump
(
"
showPageSetup
"
+
e
+
"
\
n
"
)
;
return
false
;
}
return
true
;
}
getTabDialogBox
(
sourceBrowser
)
{
return
gBrowser
.
getTabDialogBox
(
sourceBrowser
)
;
}
getPreviewBrowser
(
sourceBrowser
)
{
let
dialogBox
=
this
.
getTabDialogBox
(
sourceBrowser
)
;
for
(
let
dialog
of
dialogBox
.
getTabDialogManager
(
)
.
_dialogs
)
{
let
browser
=
dialog
.
_box
.
querySelector
(
"
.
printPreviewBrowser
"
)
;
if
(
browser
)
{
return
browser
;
}
}
return
null
;
}
_openTabModalPrint
(
aBrowsingContext
aOpenWindowInfo
aPrintInitiationTime
aPrintSelectionOnly
aPrintFrameOnly
)
{
let
sourceBrowser
=
aBrowsingContext
.
top
.
embedderElement
;
let
previewBrowser
=
this
.
getPreviewBrowser
(
sourceBrowser
)
;
if
(
previewBrowser
)
{
Cu
.
reportError
(
"
Tab
-
modal
print
UI
already
open
"
)
;
return
null
;
}
let
args
=
PromptUtils
.
objectToPropBag
(
{
printSelectionOnly
:
!
!
aPrintSelectionOnly
isArticle
:
sourceBrowser
.
isArticle
printFrameOnly
:
!
!
aPrintFrameOnly
}
)
;
let
dialogBox
=
this
.
getTabDialogBox
(
sourceBrowser
)
;
let
{
closedPromise
dialog
}
=
dialogBox
.
open
(
chrome
:
/
/
global
/
content
/
print
.
html
?
printInitiationTime
=
{
aPrintInitiationTime
}
{
features
:
"
resizable
=
no
"
sizeTo
:
"
available
"
}
args
)
;
closedPromise
.
catch
(
e
=
>
{
Cu
.
reportError
(
e
)
;
}
)
;
let
settingsBrowser
=
dialog
.
_frame
;
let
printPreview
=
new
PrintPreview
(
{
sourceBrowsingContext
:
aBrowsingContext
settingsBrowser
topBrowsingContext
:
aBrowsingContext
.
top
activeBrowsingContext
:
aBrowsingContext
openWindowInfo
:
aOpenWindowInfo
printFrameOnly
:
aPrintFrameOnly
}
)
;
settingsBrowser
.
parentElement
.
insertBefore
(
printPreview
settingsBrowser
)
;
return
printPreview
.
sourceBrowser
;
}
startPrintWindow
(
aBrowsingContext
aOptions
)
{
const
printInitiationTime
=
Date
.
now
(
)
;
let
{
printSelectionOnly
printFrameOnly
windowDotPrintOpenWindowInfo
}
=
aOptions
|
|
{
}
;
if
(
windowDotPrintOpenWindowInfo
&
&
!
windowDotPrintOpenWindowInfo
.
isForWindowDotPrint
)
{
throw
new
Error
(
"
Only
expect
openWindowInfo
for
window
.
print
(
)
"
)
;
}
let
browsingContext
=
aBrowsingContext
;
if
(
printSelectionOnly
)
{
let
focusedBc
=
Services
.
focus
.
focusedContentBrowsingContext
;
if
(
focusedBc
&
&
focusedBc
.
top
.
embedderElement
=
=
browsingContext
.
top
.
embedderElement
)
{
browsingContext
=
focusedBc
;
}
}
if
(
!
PRINT_ALWAYS_SILENT
&
&
!
PREFER_SYSTEM_DIALOG
)
{
return
this
.
_openTabModalPrint
(
browsingContext
windowDotPrintOpenWindowInfo
printInitiationTime
printSelectionOnly
printFrameOnly
)
;
}
const
useSystemDialog
=
PREFER_SYSTEM_DIALOG
&
&
!
PRINT_ALWAYS_SILENT
;
let
browser
=
null
;
if
(
windowDotPrintOpenWindowInfo
)
{
browser
=
this
.
createParentBrowserForStaticClone
(
browsingContext
windowDotPrintOpenWindowInfo
)
;
browsingContext
=
browser
.
browsingContext
;
}
async
function
makePrintSettingsAndInvokePrint
(
)
{
let
settings
=
PrintUtils
.
getPrintSettings
(
"
"
false
!
useSystemDialog
)
;
settings
.
printSelectionOnly
=
printSelectionOnly
;
if
(
settings
.
outputDestination
=
=
Ci
.
nsIPrintSettings
.
kOutputDestinationFile
&
&
!
settings
.
toFileName
)
{
let
dest
=
undefined
;
try
{
dest
=
Services
.
dirsvc
.
get
(
"
CurWorkD
"
Ci
.
nsIFile
)
.
path
;
}
catch
(
e
)
{
}
if
(
!
dest
)
{
dest
=
Services
.
dirsvc
.
get
(
"
Home
"
Ci
.
nsIFile
)
.
path
;
}
settings
.
toFileName
=
PathUtils
.
join
(
dest
"
mozilla
.
pdf
"
)
;
}
if
(
useSystemDialog
)
{
const
hasSelection
=
await
PrintUtils
.
checkForSelection
(
browsingContext
)
;
try
{
await
Cc
[
"
mozilla
.
org
/
widget
/
printdialog
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintDialogService
)
.
showPrintDialog
(
browsingContext
.
topChromeWindow
hasSelection
settings
)
;
}
catch
(
e
)
{
if
(
browser
)
{
browser
.
remove
(
)
;
}
if
(
e
.
result
=
=
Cr
.
NS_ERROR_ABORT
)
{
return
;
}
throw
e
;
}
Services
.
prefs
.
setStringPref
(
"
print_printer
"
settings
.
printerName
)
;
var
PSSVC
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
PSSVC
.
savePrintSettingsToPrefs
(
settings
true
Ci
.
nsIPrintSettings
.
kInitSaveAll
)
;
}
browsingContext
.
print
(
settings
)
;
}
setTimeout
(
makePrintSettingsAndInvokePrint
0
)
;
return
browser
;
}
togglePrintPreview
(
aBrowsingContext
)
{
let
dialogBox
=
this
.
getTabDialogBox
(
aBrowsingContext
.
top
.
embedderElement
)
;
let
dialogs
=
dialogBox
.
getTabDialogManager
(
)
.
dialogs
;
let
previewDialog
=
dialogs
.
find
(
d
=
>
d
.
_box
.
querySelector
(
"
.
printSettingsBrowser
"
)
)
;
if
(
previewDialog
)
{
previewDialog
.
close
(
)
;
return
;
}
this
.
startPrintWindow
(
aBrowsingContext
)
;
}
handleStaticCloneCreatedForPrint
(
aOpenWindowInfo
)
{
let
browsingContext
=
aOpenWindowInfo
.
parent
;
if
(
aOpenWindowInfo
.
isForWindowDotPrint
)
{
return
this
.
startPrintWindow
(
browsingContext
{
windowDotPrintOpenWindowInfo
:
aOpenWindowInfo
}
)
;
}
return
this
.
createParentBrowserForStaticClone
(
browsingContext
aOpenWindowInfo
)
;
}
createParentBrowserForStaticClone
(
aBrowsingContext
aOpenWindowInfo
)
{
let
printPreview
=
new
PrintPreview
(
{
sourceBrowsingContext
:
aBrowsingContext
openWindowInfo
:
aOpenWindowInfo
}
)
;
let
browser
=
printPreview
.
createPreviewBrowser
(
"
source
"
)
;
document
.
documentElement
.
append
(
browser
)
;
return
browser
;
}
_getErrorCodeForNSResult
(
nsresult
)
{
const
MSG_CODES
=
[
"
GFX_PRINTER_NO_PRINTER_AVAILABLE
"
"
GFX_PRINTER_NAME_NOT_FOUND
"
"
GFX_PRINTER_COULD_NOT_OPEN_FILE
"
"
GFX_PRINTER_STARTDOC
"
"
GFX_PRINTER_ENDDOC
"
"
GFX_PRINTER_STARTPAGE
"
"
GFX_PRINTER_DOC_IS_BUSY
"
"
ABORT
"
"
NOT_AVAILABLE
"
"
NOT_IMPLEMENTED
"
"
OUT_OF_MEMORY
"
"
UNEXPECTED
"
]
;
for
(
let
code
of
MSG_CODES
)
{
let
nsErrorResult
=
"
NS_ERROR_
"
+
code
;
if
(
Cr
[
nsErrorResult
]
=
=
nsresult
)
{
return
code
;
}
}
return
"
FAILURE
"
;
}
_displayPrintingError
(
nsresult
isPrinting
)
{
let
msgName
=
"
PERR_
"
+
this
.
_getErrorCodeForNSResult
(
nsresult
)
;
let
msg
title
;
if
(
!
isPrinting
)
{
let
ppMsgName
=
msgName
+
"
_PP
"
;
try
{
msg
=
this
.
_bundle
.
GetStringFromName
(
ppMsgName
)
;
}
catch
(
e
)
{
}
}
if
(
!
msg
)
{
msg
=
this
.
_bundle
.
GetStringFromName
(
msgName
)
;
}
title
=
this
.
_bundle
.
GetStringFromName
(
isPrinting
?
"
print_error_dialog_title
"
:
"
printpreview_error_dialog_title
"
)
;
Services
.
prompt
.
alert
(
window
title
msg
)
;
Services
.
telemetry
.
keyedScalarAdd
(
"
printing
.
error
"
this
.
_getErrorCodeForNSResult
(
nsresult
)
1
)
;
}
getPrintSettings
(
aPrinterName
aDefaultsOnly
aAllowPseudoPrinter
=
true
)
{
var
printSettings
;
try
{
var
PSSVC
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
function
isValidPrinterName
(
aPrinterName
)
{
return
(
aPrinterName
&
&
(
aAllowPseudoPrinter
|
|
aPrinterName
!
=
PrintUtils
.
SAVE_TO_PDF_PRINTER
)
)
;
}
const
printerName
=
(
function
(
)
{
if
(
isValidPrinterName
(
aPrinterName
)
)
{
return
aPrinterName
;
}
if
(
isValidPrinterName
(
PSSVC
.
lastUsedPrinterName
)
)
{
return
PSSVC
.
lastUsedPrinterName
;
}
return
Cc
[
"
mozilla
.
org
/
gfx
/
printerlist
;
1
"
]
.
getService
(
Ci
.
nsIPrinterList
)
.
systemDefaultPrinterName
;
}
)
(
)
;
printSettings
=
PSSVC
.
createNewPrintSettings
(
)
;
printSettings
.
printerName
=
printerName
;
if
(
printSettings
.
printerName
!
=
this
.
SAVE_TO_PDF_PRINTER
)
{
PSSVC
.
initPrintSettingsFromPrinter
(
printSettings
.
printerName
printSettings
)
;
}
if
(
!
aDefaultsOnly
)
{
PSSVC
.
initPrintSettingsFromPrefs
(
printSettings
true
printSettings
.
kInitSaveAll
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
"
PrintUtils
.
getPrintSettings
failed
:
"
+
e
+
"
\
n
"
)
;
}
return
printSettings
;
}
}
;
class
PrintPreview
extends
MozElements
.
BaseControl
{
constructor
(
{
sourceBrowsingContext
settingsBrowser
topBrowsingContext
activeBrowsingContext
openWindowInfo
printFrameOnly
}
)
{
super
(
)
;
this
.
sourceBrowsingContext
=
sourceBrowsingContext
;
this
.
settingsBrowser
=
settingsBrowser
;
this
.
topBrowsingContext
=
topBrowsingContext
;
this
.
activeBrowsingContext
=
activeBrowsingContext
;
this
.
openWindowInfo
=
openWindowInfo
;
this
.
printFrameOnly
=
printFrameOnly
;
this
.
printSelectionOnly
=
false
;
this
.
simplifyPage
=
false
;
this
.
sourceBrowser
=
null
;
this
.
selectionBrowser
=
null
;
this
.
simplifiedBrowser
=
null
;
this
.
lastPreviewBrowser
=
null
;
}
connectedCallback
(
)
{
if
(
this
.
childElementCount
>
0
)
{
return
;
}
this
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
append
(
MozXULElement
.
parseXULToFragment
(
<
stack
class
=
"
previewStack
"
rendering
=
"
true
"
flex
=
"
1
"
previewtype
=
"
primary
"
>
<
vbox
class
=
"
previewRendering
"
flex
=
"
1
"
>
<
h1
class
=
"
print
-
pending
-
label
"
data
-
l10n
-
id
=
"
printui
-
loading
"
>
<
/
h1
>
<
/
vbox
>
<
html
:
printpreview
-
pagination
class
=
"
printPreviewNavigation
"
>
<
/
html
:
printpreview
-
pagination
>
<
/
stack
>
)
)
;
this
.
stack
=
this
.
firstElementChild
;
this
.
paginator
=
this
.
querySelector
(
"
printpreview
-
pagination
"
)
;
if
(
this
.
openWindowInfo
)
{
this
.
createPreviewBrowser
(
"
source
"
)
;
}
}
disconnectedCallback
(
)
{
this
.
exitPrintPreview
(
)
;
}
getSourceBrowsingContext
(
)
{
if
(
this
.
openWindowInfo
)
{
return
this
.
sourceBrowser
.
browsingContext
;
}
return
this
.
sourceBrowsingContext
;
}
get
currentBrowsingContext
(
)
{
return
this
.
lastPreviewBrowser
.
browsingContext
;
}
exitPrintPreview
(
)
{
this
.
sourceBrowser
?
.
frameLoader
?
.
exitPrintPreview
(
)
;
this
.
simplifiedBrowser
?
.
frameLoader
?
.
exitPrintPreview
(
)
;
this
.
selectionBrowser
?
.
frameLoader
?
.
exitPrintPreview
(
)
;
this
.
textContent
=
"
"
;
}
async
printPreview
(
settings
{
sourceVersion
sourceURI
}
)
{
this
.
stack
.
setAttribute
(
"
rendering
"
true
)
;
let
result
=
await
this
.
_printPreview
(
settings
{
sourceVersion
sourceURI
}
)
;
let
browser
=
this
.
lastPreviewBrowser
;
this
.
stack
.
setAttribute
(
"
previewtype
"
browser
.
getAttribute
(
"
previewtype
"
)
)
;
browser
.
setAttribute
(
"
sheet
-
count
"
result
.
sheetCount
)
;
browser
.
setAttribute
(
"
current
-
page
"
1
)
;
this
.
paginator
.
observePreviewBrowser
(
browser
)
;
await
document
.
l10n
.
translateElements
(
[
browser
]
)
;
this
.
stack
.
removeAttribute
(
"
rendering
"
)
;
return
result
;
}
async
_printPreview
(
settings
{
sourceVersion
sourceURI
}
)
{
let
printSelectionOnly
=
sourceVersion
=
=
"
selection
"
;
let
simplifyPage
=
sourceVersion
=
=
"
simplified
"
;
let
selectionTypeBrowser
;
let
previewBrowser
;
if
(
printSelectionOnly
)
{
selectionTypeBrowser
=
this
.
selectionBrowser
;
previewBrowser
=
this
.
selectionBrowser
;
}
else
{
selectionTypeBrowser
=
this
.
sourceBrowser
;
previewBrowser
=
simplifyPage
?
this
.
simplifiedBrowser
:
this
.
sourceBrowser
;
}
settings
.
docURL
=
sourceURI
;
if
(
previewBrowser
)
{
this
.
lastPreviewBrowser
=
previewBrowser
;
if
(
this
.
openWindowInfo
)
{
this
.
openWindowInfo
=
null
;
}
return
previewBrowser
.
frameLoader
.
printPreview
(
settings
null
)
;
}
if
(
!
selectionTypeBrowser
)
{
selectionTypeBrowser
=
this
.
createPreviewBrowser
(
simplifyPage
?
"
source
"
:
sourceVersion
)
;
let
browsingContext
=
printSelectionOnly
|
|
this
.
printFrameOnly
?
this
.
activeBrowsingContext
:
this
.
topBrowsingContext
;
let
result
=
await
selectionTypeBrowser
.
frameLoader
.
printPreview
(
settings
browsingContext
)
;
if
(
!
simplifyPage
)
{
this
.
lastPreviewBrowser
=
selectionTypeBrowser
;
return
result
;
}
}
previewBrowser
=
this
.
createPreviewBrowser
(
sourceVersion
)
;
await
previewBrowser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
Printing
"
)
.
sendQuery
(
"
Printing
:
Preview
:
ParseDocument
"
{
URL
:
sourceURI
windowID
:
selectionTypeBrowser
.
browsingContext
.
currentWindowGlobal
.
outerWindowId
}
)
;
this
.
lastPreviewBrowser
=
previewBrowser
;
return
previewBrowser
.
frameLoader
.
printPreview
(
settings
previewBrowser
.
browsingContext
)
;
}
createPreviewBrowser
(
sourceVersion
)
{
let
browser
=
document
.
createXULElement
(
"
browser
"
)
;
let
browsingContext
=
sourceVersion
=
=
"
selection
"
|
|
this
.
printFrameOnly
|
|
(
sourceVersion
=
=
"
source
"
&
&
this
.
openWindowInfo
)
?
this
.
sourceBrowsingContext
:
this
.
sourceBrowsingContext
.
top
;
if
(
sourceVersion
=
=
"
source
"
&
&
this
.
openWindowInfo
)
{
browser
.
openWindowInfo
=
this
.
openWindowInfo
;
}
else
{
let
userContextId
=
browsingContext
.
originAttributes
.
userContextId
;
if
(
userContextId
)
{
browser
.
setAttribute
(
"
usercontextid
"
userContextId
)
;
}
browser
.
setAttribute
(
"
initialBrowsingContextGroupId
"
browsingContext
.
group
.
id
)
;
}
browser
.
setAttribute
(
"
type
"
"
content
"
)
;
let
remoteType
=
browsingContext
.
currentRemoteType
;
if
(
remoteType
)
{
browser
.
setAttribute
(
"
remoteType
"
remoteType
)
;
browser
.
setAttribute
(
"
remote
"
"
true
"
)
;
}
browser
.
addEventListener
(
"
DOMWindowClose
"
function
(
e
)
{
if
(
this
.
isConnected
)
{
this
.
remove
(
)
;
}
e
.
stopPropagation
(
)
;
e
.
preventDefault
(
)
;
}
)
;
if
(
this
.
settingsBrowser
)
{
browser
.
addEventListener
(
"
contextmenu
"
function
(
e
)
{
e
.
preventDefault
(
)
;
}
)
;
browser
.
setAttribute
(
"
previewtype
"
sourceVersion
)
;
browser
.
classList
.
add
(
"
printPreviewBrowser
"
)
;
browser
.
setAttribute
(
"
flex
"
"
1
"
)
;
browser
.
setAttribute
(
"
printpreview
"
"
true
"
)
;
browser
.
setAttribute
(
"
nodefaultsrc
"
"
true
"
)
;
document
.
l10n
.
setAttributes
(
browser
"
printui
-
preview
-
label
"
)
;
this
.
stack
.
insertBefore
(
browser
this
.
paginator
)
;
if
(
sourceVersion
=
=
"
source
"
)
{
this
.
sourceBrowser
=
browser
;
}
else
if
(
sourceVersion
=
=
"
selection
"
)
{
this
.
selectionBrowser
=
browser
;
}
else
if
(
sourceVersion
=
=
"
simplified
"
)
{
this
.
simplifiedBrowser
=
browser
;
}
}
else
{
browser
.
style
.
visibility
=
"
collapse
"
;
}
return
browser
;
}
}
customElements
.
define
(
"
print
-
preview
"
PrintPreview
)
;
