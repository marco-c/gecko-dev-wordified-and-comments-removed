function
waitForAnimationFrames
(
)
{
return
new
Promise
(
resolve
=
>
window
.
requestAnimationFrame
(
(
)
=
>
window
.
requestAnimationFrame
(
resolve
)
)
)
;
}
async
function
mouseMoveAndWait
(
elem
)
{
let
mouseMovePromise
=
BrowserTestUtils
.
waitForEvent
(
elem
"
mousemove
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
elem
{
type
:
"
mousemove
"
}
)
;
await
mouseMovePromise
;
await
TestUtils
.
waitForTick
(
)
;
}
function
closeEnough
(
actual
expected
)
{
return
expected
-
1
<
actual
&
&
actual
<
expected
+
1
;
}
async
function
resizeWindow
(
x
y
)
{
let
resizePromise
=
BrowserTestUtils
.
waitForEvent
(
window
"
resize
"
)
;
window
.
resizeTo
(
x
+
window
.
outerWidth
-
window
.
innerWidth
y
+
window
.
outerHeight
-
window
.
innerHeight
)
;
await
resizePromise
;
await
waitForAnimationFrames
(
)
;
ok
(
closeEnough
(
window
.
innerWidth
x
)
Window
innerWidth
{
window
.
innerWidth
}
is
close
enough
to
{
x
}
)
;
ok
(
closeEnough
(
window
.
innerHeight
y
)
Window
innerHeight
{
window
.
innerHeight
}
is
close
enough
to
{
y
}
)
;
}
async
function
waitForExpectedSize
(
helper
x
y
)
{
await
waitForAnimationFrames
(
)
;
let
isExpectedSize
=
(
)
=
>
{
let
box
=
helper
.
dialog
.
_box
;
info
(
Dialog
is
{
box
.
clientWidth
}
x
{
box
.
clientHeight
}
)
;
if
(
closeEnough
(
box
.
clientWidth
x
)
&
&
closeEnough
(
box
.
clientHeight
y
)
)
{
ok
(
true
{
box
.
clientWidth
}
close
enough
to
{
x
}
)
;
ok
(
true
{
box
.
clientHeight
}
close
enough
to
{
y
}
)
;
return
true
;
}
return
false
;
}
;
if
(
isExpectedSize
(
)
)
{
return
;
}
await
TestUtils
.
waitForCondition
(
isExpectedSize
Wait
for
{
x
}
x
{
y
}
)
;
}
async
function
checkPreviewNavigationVisibility
(
expected
)
{
function
isHidden
(
elem
)
{
return
!
elem
.
getBoundingClientRect
(
)
.
height
;
}
let
previewStack
=
document
.
querySelector
(
"
.
previewStack
"
)
;
let
paginationElem
=
document
.
querySelector
(
"
.
printPreviewNavigation
"
)
;
await
mouseMoveAndWait
(
gURLBar
.
textbox
)
;
await
mouseMoveAndWait
(
previewStack
)
;
ok
(
BrowserTestUtils
.
is_visible
(
paginationElem
)
"
The
preview
pagination
toolbar
is
visible
"
)
;
for
(
let
[
id
visible
]
of
Object
.
entries
(
expected
)
)
{
let
elem
=
paginationElem
.
shadowRoot
.
querySelector
(
#
{
id
}
)
;
if
(
visible
)
{
ok
(
!
isHidden
(
elem
)
Navigation
element
{
id
}
is
visible
)
;
}
else
{
ok
(
isHidden
(
elem
)
Navigation
element
{
id
}
is
hidden
)
;
}
}
}
add_task
(
async
function
testResizing
(
)
{
if
(
window
.
windowState
!
=
window
.
STATE_NORMAL
)
{
todo_is
(
window
.
windowState
window
.
STATE_NORMAL
"
windowState
should
be
STATE_NORMAL
"
)
;
window
.
restore
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
async
(
)
=
>
{
let
width
=
window
.
screen
.
availWidth
*
0
.
75
;
let
height
=
window
.
screen
.
availHeight
*
0
.
75
;
window
.
resizeTo
(
width
height
)
;
return
(
closeEnough
(
window
.
outerWidth
width
)
&
&
closeEnough
(
window
.
outerHeight
height
)
)
;
}
)
;
}
await
PrintHelper
.
withTestPage
(
async
helper
=
>
{
let
{
innerWidth
innerHeight
}
=
window
;
await
resizeWindow
(
500
400
)
;
await
helper
.
startPrint
(
)
;
let
chromeHeight
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
document
.
getElementById
(
"
browser
"
)
)
.
top
;
let
initialWidth
=
500
-
8
;
let
initialHeight
=
400
-
16
-
chromeHeight
+
5
;
await
waitForExpectedSize
(
helper
initialWidth
initialHeight
)
;
await
checkPreviewNavigationVisibility
(
{
navigateHome
:
false
navigatePrevious
:
false
navigateNext
:
false
navigateEnd
:
false
sheetIndicator
:
true
}
)
;
await
resizeWindow
(
600
500
)
;
await
checkPreviewNavigationVisibility
(
{
navigateHome
:
true
navigatePrevious
:
true
navigateNext
:
true
navigateEnd
:
true
sheetIndicator
:
true
}
)
;
let
updatedWidth
=
initialWidth
+
100
+
8
-
32
;
await
waitForExpectedSize
(
helper
updatedWidth
initialHeight
+
100
)
;
await
resizeWindow
(
1100
900
)
;
await
waitForExpectedSize
(
helper
1000
650
)
;
await
checkPreviewNavigationVisibility
(
{
navigateHome
:
true
navigatePrevious
:
true
navigateNext
:
true
navigateEnd
:
true
sheetIndicator
:
true
}
)
;
await
helper
.
closeDialog
(
)
;
await
resizeWindow
(
innerWidth
innerHeight
)
;
}
)
;
}
)
;
