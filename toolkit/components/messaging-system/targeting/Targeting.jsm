"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
ASRouterTargeting
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ASRouterTargeting
.
jsm
"
FilterExpressions
:
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
FilterExpressions
.
jsm
"
ClientEnvironment
:
"
resource
:
/
/
normandy
/
lib
/
ClientEnvironment
.
jsm
"
ClientEnvironmentBase
:
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
ClientEnvironment
.
jsm
"
TelemetryEnvironment
:
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
TargetingContext
"
]
;
const
TARGETING_EVENT_CATEGORY
=
"
messaging_experiments
"
;
const
TARGETING_EVENT_METHOD
=
"
targeting
"
;
const
DEFAULT_TIMEOUT
=
5000
;
const
ERROR_TYPES
=
{
ATTRIBUTE_ERROR
:
"
attribute_error
"
TIMEOUT
:
"
attribute_timeout
"
}
;
const
TargetingEnvironment
=
{
get
locale
(
)
{
return
lazy
.
ASRouterTargeting
.
Environment
.
locale
;
}
get
localeLanguageCode
(
)
{
return
lazy
.
ASRouterTargeting
.
Environment
.
localeLanguageCode
;
}
get
region
(
)
{
return
lazy
.
ASRouterTargeting
.
Environment
.
region
;
}
get
userId
(
)
{
return
lazy
.
ClientEnvironment
.
userId
;
}
get
version
(
)
{
return
AppConstants
.
MOZ_APP_VERSION_DISPLAY
;
}
get
channel
(
)
{
const
{
settings
}
=
lazy
.
TelemetryEnvironment
.
currentEnvironment
;
return
settings
.
update
.
channel
;
}
get
platform
(
)
{
return
AppConstants
.
platform
;
}
get
os
(
)
{
return
lazy
.
ClientEnvironmentBase
.
os
;
}
}
;
class
TargetingContext
{
#
telemetrySource
=
null
;
constructor
(
customContext
options
=
{
source
:
null
}
)
{
if
(
customContext
)
{
this
.
ctx
=
new
Proxy
(
customContext
{
get
:
(
customCtx
prop
)
=
>
{
if
(
prop
in
TargetingEnvironment
)
{
return
TargetingEnvironment
[
prop
]
;
}
return
customCtx
[
prop
]
;
}
}
)
;
}
else
{
this
.
ctx
=
TargetingEnvironment
;
}
this
.
#
telemetrySource
=
options
.
source
;
Services
.
telemetry
.
setEventRecordingEnabled
(
TARGETING_EVENT_CATEGORY
true
)
;
}
setTelemetrySource
(
source
)
{
if
(
source
)
{
this
.
#
telemetrySource
=
source
;
}
}
_sendUndesiredEvent
(
eventData
)
{
if
(
this
.
#
telemetrySource
)
{
Services
.
telemetry
.
recordEvent
(
TARGETING_EVENT_CATEGORY
TARGETING_EVENT_METHOD
eventData
.
event
eventData
.
value
{
source
:
this
.
#
telemetrySource
}
)
;
}
else
{
Services
.
telemetry
.
recordEvent
(
TARGETING_EVENT_CATEGORY
TARGETING_EVENT_METHOD
eventData
.
event
eventData
.
value
)
;
}
}
createContextWithTimeout
(
context
key
=
null
)
{
const
timeoutDuration
=
key
?
context
[
key
]
.
timeout
:
context
.
timeout
;
const
logUndesiredEvent
=
(
event
key
prop
)
=
>
{
const
value
=
key
?
{
key
}
.
{
prop
}
:
prop
;
this
.
_sendUndesiredEvent
(
{
event
value
}
)
;
Cu
.
reportError
(
{
event
}
:
{
value
}
)
;
}
;
return
new
Proxy
(
context
{
get
(
target
prop
)
{
return
new
Promise
(
async
(
resolve
reject
)
=
>
{
let
timeout
=
lazy
.
setTimeout
(
(
)
=
>
{
logUndesiredEvent
(
ERROR_TYPES
.
TIMEOUT
key
prop
)
;
reject
(
new
Error
(
{
prop
}
targeting
getter
timed
out
after
{
timeoutDuration
|
|
DEFAULT_TIMEOUT
}
ms
)
)
;
}
timeoutDuration
|
|
DEFAULT_TIMEOUT
)
;
try
{
resolve
(
await
(
key
?
target
[
key
]
[
prop
]
:
target
[
prop
]
)
)
;
}
catch
(
error
)
{
logUndesiredEvent
(
ERROR_TYPES
.
ATTRIBUTE_ERROR
key
prop
)
;
reject
(
error
)
;
Cu
.
reportError
(
error
)
;
}
finally
{
lazy
.
clearTimeout
(
timeout
)
;
}
}
)
;
}
}
)
;
}
mergeEvaluationContexts
(
contexts
)
{
let
context
=
{
}
;
for
(
let
c
of
contexts
)
{
for
(
let
envNamespace
of
Object
.
keys
(
c
)
)
{
context
[
envNamespace
]
=
this
.
createContextWithTimeout
(
c
envNamespace
)
;
}
}
return
context
;
}
static
combineContexts
(
.
.
.
contexts
)
{
return
new
Proxy
(
{
}
{
get
(
target
prop
)
{
for
(
let
context
of
contexts
)
{
if
(
prop
in
context
)
{
return
context
[
prop
]
;
}
}
return
null
;
}
}
)
;
}
eval
(
expression
.
.
.
contexts
)
{
return
lazy
.
FilterExpressions
.
eval
(
expression
this
.
mergeEvaluationContexts
(
[
{
ctx
:
this
.
ctx
}
.
.
.
contexts
]
)
)
;
}
evalWithDefault
(
expression
)
{
return
lazy
.
FilterExpressions
.
eval
(
expression
this
.
createContextWithTimeout
(
this
.
ctx
)
)
;
}
}
