"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ExperimentAPI
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ExperimentStore
:
"
resource
:
/
/
messaging
-
system
/
experiments
/
ExperimentStore
.
jsm
"
ExperimentManager
:
"
resource
:
/
/
messaging
-
system
/
experiments
/
ExperimentManager
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
}
)
;
const
IS_MAIN_PROCESS
=
Services
.
appinfo
.
processType
=
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
;
const
COLLECTION_ID_PREF
=
"
messaging
-
system
.
rsexperimentloader
.
collection_id
"
;
const
COLLECTION_ID_FALLBACK
=
"
nimbus
-
desktop
-
experiments
"
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
COLLECTION_ID
"
COLLECTION_ID_PREF
COLLECTION_ID_FALLBACK
)
;
const
ExperimentAPI
=
{
ready
(
)
{
return
this
.
_store
.
ready
(
)
;
}
getExperiment
(
{
slug
featureId
sendExposurePing
}
=
{
}
)
{
if
(
!
slug
&
&
!
featureId
)
{
throw
new
Error
(
"
getExperiment
(
options
)
must
include
a
slug
or
a
feature
.
"
)
;
}
let
experimentData
;
try
{
if
(
slug
)
{
experimentData
=
this
.
_store
.
get
(
slug
)
;
}
else
if
(
featureId
)
{
experimentData
=
this
.
_store
.
getExperimentForFeature
(
featureId
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
experimentData
)
{
return
{
slug
:
experimentData
.
slug
active
:
experimentData
.
active
exposurePingSent
:
experimentData
.
exposurePingSent
branch
:
this
.
activateBranch
(
{
featureId
sendExposurePing
}
)
}
;
}
return
null
;
}
getExperimentMetaData
(
{
slug
featureId
}
)
{
if
(
!
slug
&
&
!
featureId
)
{
throw
new
Error
(
"
getExperiment
(
options
)
must
include
a
slug
or
a
feature
.
"
)
;
}
let
experimentData
;
try
{
if
(
slug
)
{
experimentData
=
this
.
_store
.
get
(
slug
)
;
}
else
if
(
featureId
)
{
experimentData
=
this
.
_store
.
getExperimentForFeature
(
featureId
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
experimentData
)
{
return
{
slug
:
experimentData
.
slug
active
:
experimentData
.
active
exposurePingSent
:
experimentData
.
exposurePingSent
branch
:
{
slug
:
experimentData
.
branch
.
slug
}
}
;
}
return
null
;
}
activateBranch
(
{
slug
featureId
sendExposurePing
=
true
}
)
{
let
experiment
=
null
;
try
{
if
(
slug
)
{
experiment
=
this
.
_store
.
get
(
slug
)
;
}
else
if
(
featureId
)
{
experiment
=
this
.
_store
.
getExperimentForFeature
(
featureId
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
!
experiment
)
{
return
null
;
}
if
(
sendExposurePing
)
{
this
.
_store
.
_emitExperimentExposure
(
{
experimentSlug
:
experiment
.
slug
branchSlug
:
experiment
?
.
branch
?
.
slug
featureId
}
)
;
}
return
experiment
?
.
branch
|
|
null
;
}
isFeatureEnabled
(
featureId
defaultValue
{
sendExposurePing
=
true
}
=
{
}
)
{
const
branch
=
this
.
activateBranch
(
{
featureId
sendExposurePing
}
)
;
if
(
branch
?
.
feature
.
enabled
!
=
=
undefined
)
{
return
branch
.
feature
.
enabled
;
}
return
defaultValue
;
}
getFeatureValue
(
options
)
{
return
this
.
activateBranch
(
options
)
?
.
feature
.
value
;
}
on
(
eventName
options
callback
)
{
if
(
!
options
)
{
throw
new
Error
(
"
Please
include
an
experiment
slug
or
featureId
"
)
;
}
let
fullEventName
=
{
eventName
}
:
{
options
.
slug
|
|
options
.
featureId
}
;
this
.
_store
.
ready
(
)
.
then
(
(
)
=
>
{
let
experiment
=
this
.
getExperiment
(
options
)
;
if
(
experiment
)
{
callback
(
fullEventName
experiment
)
;
}
}
)
;
this
.
_store
.
on
(
fullEventName
callback
)
;
}
off
(
eventName
callback
)
{
this
.
_store
.
off
(
eventName
callback
)
;
}
async
getRecipe
(
slug
)
{
if
(
!
IS_MAIN_PROCESS
)
{
throw
new
Error
(
"
getRecipe
(
)
should
only
be
called
from
the
main
process
"
)
;
}
let
recipe
;
try
{
[
recipe
]
=
await
this
.
_remoteSettingsClient
.
get
(
{
syncIfEmpty
:
false
filters
:
{
slug
}
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
recipe
=
undefined
;
}
return
recipe
;
}
async
getAllBranches
(
slug
)
{
if
(
!
IS_MAIN_PROCESS
)
{
throw
new
Error
(
"
getAllBranches
(
)
should
only
be
called
from
the
main
process
"
)
;
}
const
recipe
=
await
this
.
getRecipe
(
slug
)
;
return
recipe
?
.
branches
;
}
recordExposureEvent
(
name
{
sent
experimentSlug
branchSlug
}
)
{
if
(
!
IS_MAIN_PROCESS
)
{
Cu
.
reportError
(
"
Need
to
call
from
Parent
process
"
)
;
return
false
;
}
if
(
sent
)
{
return
false
;
}
this
.
_store
.
_emitExperimentExposure
(
{
featureId
:
name
experimentSlug
branchSlug
}
)
;
return
true
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
ExperimentAPI
"
_store
"
function
(
)
{
return
IS_MAIN_PROCESS
?
ExperimentManager
.
store
:
new
ExperimentStore
(
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
ExperimentAPI
"
_remoteSettingsClient
"
function
(
)
{
return
RemoteSettings
(
COLLECTION_ID
)
;
}
)
;
