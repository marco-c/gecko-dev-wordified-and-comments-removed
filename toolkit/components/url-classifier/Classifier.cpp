#
include
"
Classifier
.
h
"
#
include
"
LookupCacheV4
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIRandomGenerator
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsIUrlClassifierUtils
.
h
"
#
include
"
nsUrlClassifierDBService
.
h
"
extern
mozilla
:
:
LazyLogModule
gUrlClassifierDbServiceLog
;
#
define
LOG
(
args
)
MOZ_LOG
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
MOZ_LOG_TEST
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
)
#
define
STORE_DIRECTORY
NS_LITERAL_CSTRING
(
"
safebrowsing
"
)
#
define
TO_DELETE_DIR_SUFFIX
NS_LITERAL_CSTRING
(
"
-
to_delete
"
)
#
define
BACKUP_DIR_SUFFIX
NS_LITERAL_CSTRING
(
"
-
backup
"
)
#
define
UPDATING_DIR_SUFFIX
NS_LITERAL_CSTRING
(
"
-
updating
"
)
#
define
METADATA_SUFFIX
NS_LITERAL_CSTRING
(
"
.
metadata
"
)
namespace
mozilla
{
namespace
safebrowsing
{
namespace
{
class
ScopedUpdatesClearer
{
public
:
explicit
ScopedUpdatesClearer
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
)
:
mUpdatesArrayRef
(
aUpdates
)
{
for
(
auto
update
:
*
aUpdates
)
{
mUpdatesPointerHolder
.
AppendElement
(
update
)
;
}
}
~
ScopedUpdatesClearer
(
)
{
mUpdatesArrayRef
-
>
Clear
(
)
;
}
private
:
nsTArray
<
TableUpdate
*
>
*
mUpdatesArrayRef
;
nsTArray
<
UniquePtr
<
TableUpdate
>
>
mUpdatesPointerHolder
;
}
;
}
void
Classifier
:
:
SplitTables
(
const
nsACString
&
str
nsTArray
<
nsCString
>
&
tables
)
{
tables
.
Clear
(
)
;
nsACString
:
:
const_iterator
begin
iter
end
;
str
.
BeginReading
(
begin
)
;
str
.
EndReading
(
end
)
;
while
(
begin
!
=
end
)
{
iter
=
begin
;
FindCharInReadable
(
'
'
iter
end
)
;
nsDependentCSubstring
table
=
Substring
(
begin
iter
)
;
if
(
!
table
.
IsEmpty
(
)
)
{
tables
.
AppendElement
(
Substring
(
begin
iter
)
)
;
}
begin
=
iter
;
if
(
begin
!
=
end
)
{
begin
+
+
;
}
}
}
nsresult
Classifier
:
:
GetPrivateStoreDirectory
(
nsIFile
*
aRootStoreDirectory
const
nsACString
&
aTableName
const
nsACString
&
aProvider
nsIFile
*
*
aPrivateStoreDirectory
)
{
NS_ENSURE_ARG_POINTER
(
aPrivateStoreDirectory
)
;
if
(
!
StringEndsWith
(
aTableName
NS_LITERAL_CSTRING
(
"
-
proto
"
)
)
)
{
nsCOMPtr
<
nsIFile
>
(
aRootStoreDirectory
)
.
forget
(
aPrivateStoreDirectory
)
;
return
NS_OK
;
}
if
(
aProvider
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIFile
>
(
aRootStoreDirectory
)
.
forget
(
aPrivateStoreDirectory
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
providerDirectory
;
nsresult
rv
=
aRootStoreDirectory
-
>
Clone
(
getter_AddRefs
(
providerDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
providerDirectory
-
>
AppendNative
(
aProvider
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
dirExists
;
rv
=
providerDirectory
-
>
Exists
(
&
dirExists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
dirExists
)
{
LOG
(
(
"
Creating
private
directory
for
%
s
"
nsCString
(
aTableName
)
.
get
(
)
)
)
;
rv
=
providerDirectory
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
providerDirectory
.
forget
(
aPrivateStoreDirectory
)
;
return
rv
;
}
bool
isDir
;
rv
=
providerDirectory
-
>
IsDirectory
(
&
isDir
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isDir
)
{
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
providerDirectory
.
forget
(
aPrivateStoreDirectory
)
;
return
NS_OK
;
}
Classifier
:
:
Classifier
(
)
:
mIsTableRequestResultOutdated
(
true
)
mUpdateInterrupted
(
true
)
{
NS_NewNamedThread
(
NS_LITERAL_CSTRING
(
"
Classifier
Update
"
)
getter_AddRefs
(
mUpdateThread
)
)
;
}
Classifier
:
:
~
Classifier
(
)
{
Close
(
)
;
}
nsresult
Classifier
:
:
SetupPathNames
(
)
{
nsresult
rv
=
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
mRootStoreDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mRootStoreDirectory
-
>
AppendNative
(
STORE_DIRECTORY
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
mLookupCaches
.
Length
(
)
;
i
+
+
)
{
mLookupCaches
[
i
]
-
>
UpdateRootDirHandle
(
mRootStoreDirectory
)
;
}
rv
=
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
mBackupDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mBackupDirectory
-
>
AppendNative
(
STORE_DIRECTORY
+
BACKUP_DIR_SUFFIX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
mUpdatingDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mUpdatingDirectory
-
>
AppendNative
(
STORE_DIRECTORY
+
UPDATING_DIR_SUFFIX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
mToDeleteDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mToDeleteDirectory
-
>
AppendNative
(
STORE_DIRECTORY
+
TO_DELETE_DIR_SUFFIX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
CreateStoreDirectory
(
)
{
bool
storeExists
;
nsresult
rv
=
mRootStoreDirectory
-
>
Exists
(
&
storeExists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
storeExists
)
{
rv
=
mRootStoreDirectory
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
bool
storeIsDir
;
rv
=
mRootStoreDirectory
-
>
IsDirectory
(
&
storeIsDir
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
storeIsDir
)
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
return
NS_OK
;
}
nsresult
Classifier
:
:
Open
(
nsIFile
&
aCacheDirectory
)
{
nsresult
rv
=
aCacheDirectory
.
Clone
(
getter_AddRefs
(
mCacheDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetupPathNames
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CleanToDelete
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mUpdatingDirectory
-
>
Remove
(
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
We
may
have
hit
a
crash
in
the
previous
update
.
"
)
)
;
}
rv
=
RecoverBackups
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CreateStoreDirectory
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RegenActiveTables
(
)
;
return
NS_OK
;
}
void
Classifier
:
:
Close
(
)
{
DropStores
(
)
;
}
void
Classifier
:
:
Reset
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
!
=
mUpdateThread
"
Reset
(
)
MUST
NOT
be
called
on
update
thread
"
)
;
LOG
(
(
"
Reset
(
)
is
called
so
we
interrupt
the
update
.
"
)
)
;
mUpdateInterrupted
=
true
;
auto
resetFunc
=
[
=
]
{
DropStores
(
)
;
mRootStoreDirectory
-
>
Remove
(
true
)
;
mBackupDirectory
-
>
Remove
(
true
)
;
mUpdatingDirectory
-
>
Remove
(
true
)
;
mToDeleteDirectory
-
>
Remove
(
true
)
;
CreateStoreDirectory
(
)
;
RegenActiveTables
(
)
;
}
;
if
(
!
mUpdateThread
)
{
LOG
(
(
"
Async
update
has
been
disabled
.
Just
Reset
(
)
on
worker
thread
.
"
)
)
;
resetFunc
(
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
safebrowsing
:
:
Classifier
:
:
Reset
"
resetFunc
)
;
SyncRunnable
:
:
DispatchToThread
(
mUpdateThread
r
)
;
}
void
Classifier
:
:
ResetTables
(
ClearType
aType
const
nsTArray
<
nsCString
>
&
aTables
)
{
for
(
uint32_t
i
=
0
;
i
<
aTables
.
Length
(
)
;
i
+
+
)
{
LOG
(
(
"
Resetting
table
:
%
s
"
aTables
[
i
]
.
get
(
)
)
)
;
LookupCache
*
cache
=
GetLookupCache
(
aTables
[
i
]
)
;
if
(
cache
)
{
if
(
aType
=
=
Clear_Cache
)
{
cache
-
>
ClearCache
(
)
;
}
else
{
cache
-
>
ClearAll
(
)
;
}
}
}
if
(
aType
=
=
Clear_All
)
{
DeleteTables
(
mRootStoreDirectory
aTables
)
;
RegenActiveTables
(
)
;
}
}
void
Classifier
:
:
DeleteTables
(
nsIFile
*
aDirectory
const
nsTArray
<
nsCString
>
&
aTables
)
{
nsCOMPtr
<
nsIDirectoryEnumerator
>
entries
;
nsresult
rv
=
aDirectory
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsCOMPtr
<
nsIFile
>
file
;
while
(
NS_SUCCEEDED
(
rv
=
entries
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
)
&
&
file
)
{
bool
isDirectory
;
if
(
NS_FAILED
(
file
-
>
IsDirectory
(
&
isDirectory
)
)
)
{
continue
;
}
if
(
isDirectory
)
{
DeleteTables
(
file
aTables
)
;
continue
;
}
nsCString
leafName
;
rv
=
file
-
>
GetNativeLeafName
(
leafName
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
int32_t
dotPosition
=
leafName
.
RFind
(
"
.
"
)
;
if
(
dotPosition
>
=
0
)
{
leafName
.
Truncate
(
dotPosition
)
;
}
if
(
!
leafName
.
IsEmpty
(
)
&
&
aTables
.
Contains
(
leafName
)
)
{
if
(
NS_FAILED
(
file
-
>
Remove
(
false
)
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
Fail
to
remove
file
%
s
from
the
disk
"
leafName
.
get
(
)
)
.
get
(
)
)
;
}
}
}
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
void
Classifier
:
:
TableRequest
(
nsACString
&
aResult
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
TableRequest
must
be
called
on
the
classifier
worker
thread
.
"
)
;
if
(
!
mIsTableRequestResultOutdated
)
{
aResult
=
mTableRequestResult
;
return
;
}
nsTArray
<
nsCString
>
tables
;
ActiveTables
(
tables
)
;
for
(
uint32_t
i
=
0
;
i
<
tables
.
Length
(
)
;
i
+
+
)
{
HashStore
store
(
tables
[
i
]
GetProvider
(
tables
[
i
]
)
mRootStoreDirectory
)
;
nsresult
rv
=
store
.
Open
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
ChunkSet
&
adds
=
store
.
AddChunks
(
)
;
ChunkSet
&
subs
=
store
.
SubChunks
(
)
;
if
(
adds
.
Length
(
)
=
=
0
&
&
subs
.
Length
(
)
=
=
0
)
{
continue
;
}
aResult
.
Append
(
store
.
TableName
(
)
)
;
aResult
.
Append
(
'
;
'
)
;
if
(
adds
.
Length
(
)
>
0
)
{
aResult
.
AppendLiteral
(
"
a
:
"
)
;
nsAutoCString
addList
;
adds
.
Serialize
(
addList
)
;
aResult
.
Append
(
addList
)
;
}
if
(
subs
.
Length
(
)
>
0
)
{
if
(
adds
.
Length
(
)
>
0
)
aResult
.
Append
(
'
:
'
)
;
aResult
.
AppendLiteral
(
"
s
:
"
)
;
nsAutoCString
subList
;
subs
.
Serialize
(
subList
)
;
aResult
.
Append
(
subList
)
;
}
aResult
.
Append
(
'
\
n
'
)
;
}
nsCString
metadata
;
nsresult
rv
=
LoadMetadata
(
mRootStoreDirectory
metadata
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aResult
.
Append
(
metadata
)
;
}
mTableRequestResult
=
aResult
;
mIsTableRequestResultOutdated
=
false
;
}
nsresult
Classifier
:
:
Check
(
const
nsACString
&
aSpec
const
nsACString
&
aTables
LookupResultArray
&
aResults
)
{
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
URLCLASSIFIER_CL_CHECK_TIME
>
timer
;
nsTArray
<
nsCString
>
fragments
;
nsresult
rv
=
LookupCache
:
:
GetLookupFragments
(
aSpec
&
fragments
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsTArray
<
nsCString
>
activeTables
;
SplitTables
(
aTables
activeTables
)
;
nsTArray
<
LookupCache
*
>
cacheArray
;
for
(
uint32_t
i
=
0
;
i
<
activeTables
.
Length
(
)
;
i
+
+
)
{
LOG
(
(
"
Checking
table
%
s
"
activeTables
[
i
]
.
get
(
)
)
)
;
LookupCache
*
cache
=
GetLookupCache
(
activeTables
[
i
]
)
;
if
(
cache
)
{
cacheArray
.
AppendElement
(
cache
)
;
}
else
{
return
NS_ERROR_FAILURE
;
}
}
for
(
uint32_t
i
=
0
;
i
<
fragments
.
Length
(
)
;
i
+
+
)
{
Completion
lookupHash
;
lookupHash
.
FromPlaintext
(
fragments
[
i
]
)
;
if
(
LOG_ENABLED
(
)
)
{
nsAutoCString
checking
;
lookupHash
.
ToHexString
(
checking
)
;
LOG
(
(
"
Checking
fragment
%
s
hash
%
s
(
%
X
)
"
fragments
[
i
]
.
get
(
)
checking
.
get
(
)
lookupHash
.
ToUint32
(
)
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
cacheArray
.
Length
(
)
;
i
+
+
)
{
LookupCache
*
cache
=
cacheArray
[
i
]
;
bool
has
confirmed
;
uint32_t
matchLength
;
rv
=
cache
-
>
Has
(
lookupHash
&
has
&
matchLength
&
confirmed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
has
)
{
LookupResult
*
result
=
aResults
.
AppendElement
(
fallible
)
;
if
(
!
result
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
LOG
(
(
"
Found
a
result
in
%
s
:
%
s
"
cache
-
>
TableName
(
)
.
get
(
)
confirmed
?
"
confirmed
.
"
:
"
Not
confirmed
.
"
)
)
;
result
-
>
hash
.
complete
=
lookupHash
;
result
-
>
mConfirmed
=
confirmed
;
result
-
>
mTableName
.
Assign
(
cache
-
>
TableName
(
)
)
;
result
-
>
mPartialHashLength
=
confirmed
?
COMPLETE_SIZE
:
matchLength
;
result
-
>
mProtocolV2
=
LookupCache
:
:
Cast
<
LookupCacheV2
>
(
cache
)
;
}
}
}
return
NS_OK
;
}
static
nsresult
SwapDirectoryContent
(
nsIFile
*
aDir1
nsIFile
*
aDir2
nsIFile
*
aParentDir
nsIFile
*
aTempDir
)
{
nsAutoCString
tempDirName
;
aTempDir
-
>
GetNativeLeafName
(
tempDirName
)
;
nsresult
rv
;
nsAutoCString
dirName1
dirName2
;
aDir1
-
>
GetNativeLeafName
(
dirName1
)
;
aDir2
-
>
GetNativeLeafName
(
dirName2
)
;
LOG
(
(
"
Swapping
directories
%
s
and
%
s
.
.
.
"
dirName1
.
get
(
)
dirName2
.
get
(
)
)
)
;
rv
=
aDir1
-
>
RenameToNative
(
nullptr
tempDirName
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Unable
to
rename
%
s
to
%
s
"
dirName1
.
get
(
)
tempDirName
.
get
(
)
)
)
;
return
rv
;
}
nsCOMPtr
<
nsIFile
>
tempDirectory
;
rv
=
aParentDir
-
>
Clone
(
getter_AddRefs
(
tempDirectory
)
)
;
rv
=
tempDirectory
-
>
AppendNative
(
tempDirName
)
;
rv
=
aDir2
-
>
RenameToNative
(
nullptr
dirName1
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
rename
%
s
to
%
s
.
Rename
temp
directory
back
to
%
s
"
dirName2
.
get
(
)
dirName1
.
get
(
)
dirName1
.
get
(
)
)
)
;
nsresult
rbrv
=
tempDirectory
-
>
RenameToNative
(
nullptr
dirName1
)
;
NS_ENSURE_SUCCESS
(
rbrv
rbrv
)
;
return
rv
;
}
rv
=
tempDirectory
-
>
RenameToNative
(
nullptr
dirName2
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
rename
temp
directory
to
%
s
.
"
dirName2
.
get
(
)
)
)
;
nsresult
rbrv
;
rbrv
=
aDir1
-
>
RenameToNative
(
nullptr
dirName2
)
;
NS_ENSURE_SUCCESS
(
rbrv
rbrv
)
;
rbrv
=
tempDirectory
-
>
RenameToNative
(
nullptr
dirName1
)
;
NS_ENSURE_SUCCESS
(
rbrv
rbrv
)
;
return
rv
;
}
return
rv
;
}
void
Classifier
:
:
RemoveUpdateIntermediaries
(
)
{
for
(
auto
c
:
mNewLookupCaches
)
{
delete
c
;
}
mNewLookupCaches
.
Clear
(
)
;
if
(
NS_FAILED
(
mUpdatingDirectory
-
>
Remove
(
true
)
)
)
{
LOG
(
(
"
Failed
to
remove
updating
directory
.
"
)
)
;
}
}
void
Classifier
:
:
CopyAndInvalidateFullHashCache
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
!
=
mUpdateThread
"
CopyAndInvalidateFullHashCache
cannot
be
called
on
update
thread
"
"
since
it
mutates
mLookupCaches
which
is
only
safe
on
"
"
worker
thread
.
"
)
;
for
(
auto
&
newCache
:
mNewLookupCaches
)
{
for
(
auto
&
oldCache
:
mLookupCaches
)
{
if
(
oldCache
-
>
TableName
(
)
=
=
newCache
-
>
TableName
(
)
)
{
newCache
-
>
CopyFullHashCache
(
oldCache
)
;
break
;
}
}
}
for
(
auto
&
newCache
:
mNewLookupCaches
)
{
newCache
-
>
InvalidateExpiredCacheEntries
(
)
;
}
}
void
Classifier
:
:
MergeNewLookupCaches
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
!
=
mUpdateThread
"
MergeNewLookupCaches
cannot
be
called
on
update
thread
"
"
since
it
mutates
mLookupCaches
which
is
only
safe
on
"
"
worker
thread
.
"
)
;
for
(
auto
&
newCache
:
mNewLookupCaches
)
{
size_t
swapIndex
=
0
;
for
(
;
swapIndex
<
mLookupCaches
.
Length
(
)
;
swapIndex
+
+
)
{
if
(
mLookupCaches
[
swapIndex
]
-
>
TableName
(
)
=
=
newCache
-
>
TableName
(
)
)
{
break
;
}
}
if
(
swapIndex
=
=
mLookupCaches
.
Length
(
)
)
{
mLookupCaches
.
AppendElement
(
nullptr
)
;
}
Swap
(
mLookupCaches
[
swapIndex
]
newCache
)
;
mLookupCaches
[
swapIndex
]
-
>
UpdateRootDirHandle
(
mRootStoreDirectory
)
;
}
}
nsresult
Classifier
:
:
SwapInNewTablesAndCleanup
(
)
{
nsresult
rv
;
rv
=
SwapDirectoryContent
(
mUpdatingDirectory
mRootStoreDirectory
mCacheDirectory
mBackupDirectory
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
swap
in
on
-
disk
tables
.
"
)
)
;
RemoveUpdateIntermediaries
(
)
;
return
rv
;
}
MergeNewLookupCaches
(
)
;
rv
=
RegenActiveTables
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
re
-
generate
active
tables
!
"
)
)
;
}
RemoveUpdateIntermediaries
(
)
;
mIsTableRequestResultOutdated
=
true
;
LOG
(
(
"
Done
swap
in
updated
tables
.
"
)
)
;
return
rv
;
}
void
Classifier
:
:
FlushAndDisableAsyncUpdate
(
)
{
LOG
(
(
"
Classifier
:
:
FlushAndDisableAsyncUpdate
[
%
p
%
p
]
"
this
mUpdateThread
.
get
(
)
)
)
;
if
(
!
mUpdateThread
)
{
LOG
(
(
"
Async
update
has
been
disabled
.
"
)
)
;
return
;
}
mUpdateThread
-
>
Shutdown
(
)
;
mUpdateThread
=
nullptr
;
}
nsresult
Classifier
:
:
AsyncApplyUpdates
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
const
AsyncUpdateCallback
&
aCallback
)
{
LOG
(
(
"
Classifier
:
:
AsyncApplyUpdates
"
)
)
;
if
(
!
mUpdateThread
)
{
LOG
(
(
"
Async
update
has
already
been
disabled
.
"
)
)
;
return
NS_ERROR_FAILURE
;
}
mUpdateInterrupted
=
false
;
nsresult
rv
=
mRootStoreDirectory
-
>
Clone
(
getter_AddRefs
(
mRootStoreDirectoryForUpdate
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
clone
mRootStoreDirectory
for
update
.
"
)
)
;
return
rv
;
}
nsCOMPtr
<
nsIThread
>
callerThread
=
NS_GetCurrentThread
(
)
;
MOZ_ASSERT
(
callerThread
!
=
mUpdateThread
)
;
nsCOMPtr
<
nsIRunnable
>
bgRunnable
=
NS_NewRunnableFunction
(
"
safebrowsing
:
:
Classifier
:
:
AsyncApplyUpdates
"
[
=
]
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mUpdateThread
"
MUST
be
on
update
thread
"
)
;
LOG
(
(
"
Step
1
.
ApplyUpdatesBackground
on
update
thread
.
"
)
)
;
nsCString
failedTableName
;
nsresult
bgRv
=
ApplyUpdatesBackground
(
aUpdates
failedTableName
)
;
nsCOMPtr
<
nsIRunnable
>
fgRunnable
=
NS_NewRunnableFunction
(
"
safebrowsing
:
:
Classifier
:
:
AsyncApplyUpdates
"
[
=
]
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
callerThread
"
MUST
be
on
caller
thread
"
)
;
LOG
(
(
"
Step
2
.
ApplyUpdatesForeground
on
caller
thread
"
)
)
;
nsresult
rv
=
ApplyUpdatesForeground
(
bgRv
failedTableName
)
;
;
LOG
(
(
"
Step
3
.
Updates
applied
!
Fire
callback
.
"
)
)
;
aCallback
(
rv
)
;
}
)
;
callerThread
-
>
Dispatch
(
fgRunnable
NS_DISPATCH_NORMAL
)
;
}
)
;
return
mUpdateThread
-
>
Dispatch
(
bgRunnable
NS_DISPATCH_NORMAL
)
;
}
nsresult
Classifier
:
:
ApplyUpdatesBackground
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
nsACString
&
aFailedTableName
)
{
if
(
!
aUpdates
|
|
aUpdates
-
>
Length
(
)
=
=
0
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIUrlClassifierUtils
>
urlUtil
=
do_GetService
(
NS_URLCLASSIFIERUTILS_CONTRACTID
)
;
nsCString
provider
;
urlUtil
-
>
GetTelemetryProvider
(
(
*
aUpdates
)
[
0
]
-
>
TableName
(
)
provider
)
;
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
URLCLASSIFIER_CL_KEYED_UPDATE_TIME
>
keyedTimer
(
provider
)
;
PRIntervalTime
clockStart
=
0
;
if
(
LOG_ENABLED
(
)
)
{
clockStart
=
PR_IntervalNow
(
)
;
}
nsresult
rv
;
{
ScopedUpdatesClearer
scopedUpdatesClearer
(
aUpdates
)
;
{
if
(
mUpdateInterrupted
)
{
LOG
(
(
"
Update
is
interrupted
.
Don
'
t
copy
files
.
"
)
)
;
return
NS_OK
;
}
rv
=
CopyInUseDirForUpdate
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
copy
in
-
use
directory
for
update
.
"
)
)
;
return
rv
;
}
}
LOG
(
(
"
Applying
%
zu
table
updates
.
"
aUpdates
-
>
Length
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
-
>
Length
(
)
;
i
+
+
)
{
if
(
(
*
aUpdates
)
[
i
]
)
{
nsCString
updateTable
(
aUpdates
-
>
ElementAt
(
i
)
-
>
TableName
(
)
)
;
if
(
mUpdateInterrupted
)
{
LOG
(
(
"
Update
is
interrupted
.
Stop
building
new
tables
.
"
)
)
;
return
NS_OK
;
}
if
(
TableUpdate
:
:
Cast
<
TableUpdateV2
>
(
(
*
aUpdates
)
[
i
]
)
)
{
rv
=
UpdateHashStore
(
aUpdates
updateTable
)
;
}
else
{
rv
=
UpdateTableV4
(
aUpdates
updateTable
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
aFailedTableName
=
updateTable
;
RemoveUpdateIntermediaries
(
)
;
return
rv
;
}
}
}
}
if
(
LOG_ENABLED
(
)
)
{
PRIntervalTime
clockEnd
=
PR_IntervalNow
(
)
;
LOG
(
(
"
update
took
%
dms
\
n
"
PR_IntervalToMilliseconds
(
clockEnd
-
clockStart
)
)
)
;
}
return
rv
;
}
nsresult
Classifier
:
:
ApplyUpdatesForeground
(
nsresult
aBackgroundRv
const
nsACString
&
aFailedTableName
)
{
if
(
mUpdateInterrupted
)
{
LOG
(
(
"
Update
is
interrupted
!
Just
remove
update
intermediaries
.
"
)
)
;
RemoveUpdateIntermediaries
(
)
;
return
NS_OK
;
}
if
(
NS_SUCCEEDED
(
aBackgroundRv
)
)
{
CopyAndInvalidateFullHashCache
(
)
;
return
SwapInNewTablesAndCleanup
(
)
;
}
if
(
NS_ERROR_OUT_OF_MEMORY
!
=
aBackgroundRv
)
{
ResetTables
(
Clear_All
nsTArray
<
nsCString
>
{
nsCString
(
aFailedTableName
)
}
)
;
}
return
aBackgroundRv
;
}
nsresult
Classifier
:
:
ApplyFullHashes
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
!
=
mUpdateThread
"
ApplyFullHashes
(
)
MUST
NOT
be
called
on
update
thread
"
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
ApplyFullHashes
(
)
must
be
called
on
the
classifier
worker
thread
.
"
)
;
LOG
(
(
"
Applying
%
zu
table
gethashes
.
"
aUpdates
-
>
Length
(
)
)
)
;
ScopedUpdatesClearer
scopedUpdatesClearer
(
aUpdates
)
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
-
>
Length
(
)
;
i
+
+
)
{
TableUpdate
*
update
=
aUpdates
-
>
ElementAt
(
i
)
;
nsresult
rv
=
UpdateCache
(
update
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aUpdates
-
>
ElementAt
(
i
)
=
nullptr
;
}
return
NS_OK
;
}
void
Classifier
:
:
GetCacheInfo
(
const
nsACString
&
aTable
nsIUrlClassifierCacheInfo
*
*
aCache
)
{
LookupCache
*
lookupCache
=
GetLookupCache
(
aTable
)
;
if
(
!
lookupCache
)
{
return
;
}
lookupCache
-
>
GetCacheInfo
(
aCache
)
;
}
void
Classifier
:
:
DropStores
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mLookupCaches
.
Length
(
)
;
i
+
+
)
{
delete
mLookupCaches
[
i
]
;
}
mLookupCaches
.
Clear
(
)
;
}
nsresult
Classifier
:
:
RegenActiveTables
(
)
{
mActiveTablesCache
.
Clear
(
)
;
nsTArray
<
nsCString
>
foundTables
;
ScanStoreDir
(
mRootStoreDirectory
foundTables
)
;
for
(
uint32_t
i
=
0
;
i
<
foundTables
.
Length
(
)
;
i
+
+
)
{
nsCString
table
(
foundTables
[
i
]
)
;
LookupCache
*
lookupCache
=
GetLookupCache
(
table
)
;
if
(
!
lookupCache
)
{
LOG
(
(
"
Inactive
table
(
no
cache
)
:
%
s
"
table
.
get
(
)
)
)
;
continue
;
}
if
(
!
lookupCache
-
>
IsPrimed
(
)
)
{
LOG
(
(
"
Inactive
table
(
cache
not
primed
)
:
%
s
"
table
.
get
(
)
)
)
;
continue
;
}
if
(
LookupCache
:
:
Cast
<
LookupCacheV4
>
(
lookupCache
)
)
{
LOG
(
(
"
Active
v4
table
:
%
s
"
table
.
get
(
)
)
)
;
}
else
{
HashStore
store
(
table
GetProvider
(
table
)
mRootStoreDirectory
)
;
nsresult
rv
=
store
.
Open
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
const
ChunkSet
&
adds
=
store
.
AddChunks
(
)
;
const
ChunkSet
&
subs
=
store
.
SubChunks
(
)
;
if
(
adds
.
Length
(
)
=
=
0
&
&
subs
.
Length
(
)
=
=
0
)
{
continue
;
}
LOG
(
(
"
Active
v2
table
:
%
s
"
store
.
TableName
(
)
.
get
(
)
)
)
;
}
mActiveTablesCache
.
AppendElement
(
table
)
;
}
return
NS_OK
;
}
nsresult
Classifier
:
:
ScanStoreDir
(
nsIFile
*
aDirectory
nsTArray
<
nsCString
>
&
aTables
)
{
nsCOMPtr
<
nsIDirectoryEnumerator
>
entries
;
nsresult
rv
=
aDirectory
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
file
;
while
(
NS_SUCCEEDED
(
rv
=
entries
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
)
&
&
file
)
{
bool
isDirectory
;
if
(
NS_FAILED
(
file
-
>
IsDirectory
(
&
isDirectory
)
)
)
{
continue
;
}
if
(
isDirectory
)
{
ScanStoreDir
(
file
aTables
)
;
continue
;
}
nsCString
leafName
;
rv
=
file
-
>
GetNativeLeafName
(
leafName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCString
suffix
(
NS_LITERAL_CSTRING
(
"
.
pset
"
)
)
;
int32_t
dot
=
leafName
.
RFind
(
suffix
)
;
if
(
dot
!
=
-
1
)
{
leafName
.
Cut
(
dot
suffix
.
Length
(
)
)
;
aTables
.
AppendElement
(
leafName
)
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
ActiveTables
(
nsTArray
<
nsCString
>
&
aTables
)
const
{
aTables
=
mActiveTablesCache
;
return
NS_OK
;
}
nsresult
Classifier
:
:
CleanToDelete
(
)
{
bool
exists
;
nsresult
rv
=
mToDeleteDirectory
-
>
Exists
(
&
exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
exists
)
{
rv
=
mToDeleteDirectory
-
>
Remove
(
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
#
ifdef
MOZ_SAFEBROWSING_DUMP_FAILED_UPDATES
already_AddRefed
<
nsIFile
>
Classifier
:
:
GetFailedUpdateDirectroy
(
)
{
nsCString
failedUpdatekDirName
=
STORE_DIRECTORY
+
nsCString
(
"
-
failedupdate
"
)
;
nsCOMPtr
<
nsIFile
>
failedUpdatekDirectory
;
if
(
NS_FAILED
(
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
failedUpdatekDirectory
)
)
)
|
|
NS_FAILED
(
failedUpdatekDirectory
-
>
AppendNative
(
failedUpdatekDirName
)
)
)
{
LOG
(
(
"
Failed
to
init
failedUpdatekDirectory
.
"
)
)
;
return
nullptr
;
}
return
failedUpdatekDirectory
.
forget
(
)
;
}
nsresult
Classifier
:
:
DumpRawTableUpdates
(
const
nsACString
&
aRawUpdates
)
{
LOG
(
(
"
Dumping
raw
table
updates
.
.
.
"
)
)
;
DumpFailedUpdate
(
)
;
nsCOMPtr
<
nsIFile
>
failedUpdatekDirectory
=
GetFailedUpdateDirectroy
(
)
;
nsCOMPtr
<
nsIFile
>
rawTableUpdatesFile
;
nsCOMPtr
<
nsIOutputStream
>
outputStream
;
if
(
NS_FAILED
(
failedUpdatekDirectory
-
>
Clone
(
getter_AddRefs
(
rawTableUpdatesFile
)
)
)
|
|
NS_FAILED
(
rawTableUpdatesFile
-
>
AppendNative
(
nsCString
(
"
tableupdates
.
bin
"
)
)
)
|
|
NS_FAILED
(
NS_NewLocalFileOutputStream
(
getter_AddRefs
(
outputStream
)
rawTableUpdatesFile
PR_WRONLY
|
PR_TRUNCATE
|
PR_CREATE_FILE
)
)
)
{
LOG
(
(
"
Failed
to
create
file
to
dump
raw
table
updates
.
"
)
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
written
;
nsresult
rv
=
outputStream
-
>
Write
(
aRawUpdates
.
BeginReading
(
)
aRawUpdates
.
Length
(
)
&
written
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
written
=
=
aRawUpdates
.
Length
(
)
NS_ERROR_FAILURE
)
;
return
rv
;
}
nsresult
Classifier
:
:
DumpFailedUpdate
(
)
{
LOG
(
(
"
Dumping
failed
update
.
.
.
"
)
)
;
nsCOMPtr
<
nsIFile
>
failedUpdatekDirectory
=
GetFailedUpdateDirectroy
(
)
;
failedUpdatekDirectory
-
>
Remove
(
true
)
;
nsCString
failedUpdatekDirName
;
nsresult
rv
=
failedUpdatekDirectory
-
>
GetNativeLeafName
(
failedUpdatekDirName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
inUseDirectory
;
if
(
NS_FAILED
(
mRootStoreDirectory
-
>
Clone
(
getter_AddRefs
(
inUseDirectory
)
)
)
|
|
NS_FAILED
(
inUseDirectory
-
>
CopyToNative
(
nullptr
failedUpdatekDirName
)
)
)
{
LOG
(
(
"
Failed
to
move
in
-
use
to
the
\
"
failed
update
\
"
directory
%
s
"
failedUpdatekDirName
.
get
(
)
)
)
;
return
NS_ERROR_FAILURE
;
}
return
rv
;
}
#
endif
nsresult
Classifier
:
:
CopyInUseDirForUpdate
(
)
{
LOG
(
(
"
Copy
in
-
use
directory
content
for
update
.
"
)
)
;
nsCString
updatingDirName
;
nsresult
rv
=
mUpdatingDirectory
-
>
GetNativeLeafName
(
updatingDirName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mUpdatingDirectory
-
>
Remove
(
true
)
;
if
(
!
mRootStoreDirectoryForUpdate
)
{
LOG
(
(
"
mRootStoreDirectoryForUpdate
is
null
.
"
)
)
;
return
NS_ERROR_NULL_POINTER
;
}
rv
=
mRootStoreDirectoryForUpdate
-
>
CopyToNative
(
nullptr
updatingDirName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
RecoverBackups
(
)
{
bool
backupExists
;
nsresult
rv
=
mBackupDirectory
-
>
Exists
(
&
backupExists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
backupExists
)
{
nsCString
storeDirName
;
rv
=
mRootStoreDirectory
-
>
GetNativeLeafName
(
storeDirName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
storeExists
;
rv
=
mRootStoreDirectory
-
>
Exists
(
&
storeExists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
storeExists
)
{
rv
=
mRootStoreDirectory
-
>
Remove
(
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
mBackupDirectory
-
>
MoveToNative
(
nullptr
storeDirName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetupPathNames
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
bool
Classifier
:
:
CheckValidUpdate
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
const
nsACString
&
aTable
)
{
uint32_t
validupdates
=
0
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
-
>
Length
(
)
;
i
+
+
)
{
TableUpdate
*
update
=
aUpdates
-
>
ElementAt
(
i
)
;
if
(
!
update
|
|
!
update
-
>
TableName
(
)
.
Equals
(
aTable
)
)
continue
;
if
(
update
-
>
Empty
(
)
)
{
aUpdates
-
>
ElementAt
(
i
)
=
nullptr
;
continue
;
}
validupdates
+
+
;
}
if
(
!
validupdates
)
{
return
false
;
}
return
true
;
}
nsCString
Classifier
:
:
GetProvider
(
const
nsACString
&
aTableName
)
{
nsCOMPtr
<
nsIUrlClassifierUtils
>
urlUtil
=
do_GetService
(
NS_URLCLASSIFIERUTILS_CONTRACTID
)
;
nsCString
provider
;
nsresult
rv
=
urlUtil
-
>
GetProvider
(
aTableName
provider
)
;
return
NS_SUCCEEDED
(
rv
)
?
provider
:
EmptyCString
(
)
;
}
nsresult
Classifier
:
:
UpdateHashStore
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
const
nsACString
&
aTable
)
{
if
(
nsUrlClassifierDBService
:
:
ShutdownHasStarted
(
)
)
{
return
NS_ERROR_UC_UPDATE_SHUTDOWNING
;
}
LOG
(
(
"
Classifier
:
:
UpdateHashStore
(
%
s
)
"
PromiseFlatCString
(
aTable
)
.
get
(
)
)
)
;
HashStore
store
(
aTable
GetProvider
(
aTable
)
mUpdatingDirectory
)
;
if
(
!
CheckValidUpdate
(
aUpdates
store
.
TableName
(
)
)
)
{
return
NS_OK
;
}
nsresult
rv
=
store
.
Open
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
store
.
BeginUpdate
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LookupCacheV2
*
lookupCache
=
LookupCache
:
:
Cast
<
LookupCacheV2
>
(
GetLookupCacheForUpdate
(
store
.
TableName
(
)
)
)
;
if
(
!
lookupCache
)
{
return
NS_ERROR_UC_UPDATE_TABLE_NOT_FOUND
;
}
FallibleTArray
<
uint32_t
>
AddPrefixHashes
;
rv
=
lookupCache
-
>
GetPrefixes
(
AddPrefixHashes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
store
.
AugmentAdds
(
AddPrefixHashes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AddPrefixHashes
.
Clear
(
)
;
uint32_t
applied
=
0
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
-
>
Length
(
)
;
i
+
+
)
{
TableUpdate
*
update
=
aUpdates
-
>
ElementAt
(
i
)
;
if
(
!
update
|
|
!
update
-
>
TableName
(
)
.
Equals
(
store
.
TableName
(
)
)
)
{
continue
;
}
TableUpdateV2
*
updateV2
=
TableUpdate
:
:
Cast
<
TableUpdateV2
>
(
update
)
;
NS_ENSURE_TRUE
(
updateV2
NS_ERROR_UC_UPDATE_UNEXPECTED_VERSION
)
;
rv
=
store
.
ApplyUpdate
(
updateV2
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
applied
+
+
;
LOG
(
(
"
Applied
update
to
table
%
s
:
"
store
.
TableName
(
)
.
get
(
)
)
)
;
LOG
(
(
"
%
d
add
chunks
"
updateV2
-
>
AddChunks
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
add
prefixes
"
updateV2
-
>
AddPrefixes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
add
completions
"
updateV2
-
>
AddCompletes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
d
sub
chunks
"
updateV2
-
>
SubChunks
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
sub
prefixes
"
updateV2
-
>
SubPrefixes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
sub
completions
"
updateV2
-
>
SubCompletes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
d
add
expirations
"
updateV2
-
>
AddExpirations
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
d
sub
expirations
"
updateV2
-
>
SubExpirations
(
)
.
Length
(
)
)
)
;
aUpdates
-
>
ElementAt
(
i
)
=
nullptr
;
}
LOG
(
(
"
Applied
%
d
update
(
s
)
to
%
s
.
"
applied
store
.
TableName
(
)
.
get
(
)
)
)
;
rv
=
store
.
Rebuild
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOG
(
(
"
Table
%
s
now
has
:
"
store
.
TableName
(
)
.
get
(
)
)
)
;
LOG
(
(
"
%
d
add
chunks
"
store
.
AddChunks
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
add
prefixes
"
store
.
AddPrefixes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
add
completions
"
store
.
AddCompletes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
d
sub
chunks
"
store
.
SubChunks
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
sub
prefixes
"
store
.
SubPrefixes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
sub
completions
"
store
.
SubCompletes
(
)
.
Length
(
)
)
)
;
rv
=
store
.
WriteFile
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
lookupCache
-
>
Build
(
store
.
AddPrefixes
(
)
store
.
AddCompletes
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_UC_UPDATE_BUILD_PREFIX_FAILURE
)
;
#
if
defined
(
DEBUG
)
lookupCache
-
>
DumpCompletions
(
)
;
#
endif
rv
=
lookupCache
-
>
WriteFile
(
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_UC_UPDATE_FAIL_TO_WRITE_DISK
)
;
LOG
(
(
"
Successfully
updated
%
s
"
store
.
TableName
(
)
.
get
(
)
)
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
UpdateTableV4
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
const
nsACString
&
aTable
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
UpdateTableV4
must
be
called
on
the
classifier
worker
thread
.
"
)
;
if
(
nsUrlClassifierDBService
:
:
ShutdownHasStarted
(
)
)
{
return
NS_ERROR_UC_UPDATE_SHUTDOWNING
;
}
LOG
(
(
"
Classifier
:
:
UpdateTableV4
(
%
s
)
"
PromiseFlatCString
(
aTable
)
.
get
(
)
)
)
;
if
(
!
CheckValidUpdate
(
aUpdates
aTable
)
)
{
return
NS_OK
;
}
LookupCacheV4
*
lookupCache
=
LookupCache
:
:
Cast
<
LookupCacheV4
>
(
GetLookupCacheForUpdate
(
aTable
)
)
;
if
(
!
lookupCache
)
{
return
NS_ERROR_UC_UPDATE_TABLE_NOT_FOUND
;
}
nsresult
rv
=
NS_OK
;
PrefixStringMap
prefixes1
prefixes2
;
PrefixStringMap
*
input
=
&
prefixes1
;
PrefixStringMap
*
output
=
&
prefixes2
;
TableUpdateV4
*
lastAppliedUpdate
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
-
>
Length
(
)
;
i
+
+
)
{
TableUpdate
*
update
=
aUpdates
-
>
ElementAt
(
i
)
;
if
(
!
update
|
|
!
update
-
>
TableName
(
)
.
Equals
(
aTable
)
)
{
continue
;
}
auto
updateV4
=
TableUpdate
:
:
Cast
<
TableUpdateV4
>
(
update
)
;
NS_ENSURE_TRUE
(
updateV4
NS_ERROR_UC_UPDATE_UNEXPECTED_VERSION
)
;
if
(
updateV4
-
>
IsFullUpdate
(
)
)
{
input
-
>
Clear
(
)
;
output
-
>
Clear
(
)
;
rv
=
lookupCache
-
>
ApplyUpdate
(
updateV4
*
input
*
output
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
{
if
(
prefixes1
.
IsEmpty
(
)
&
&
prefixes2
.
IsEmpty
(
)
)
{
lookupCache
-
>
GetPrefixes
(
prefixes1
)
;
}
else
{
MOZ_ASSERT
(
prefixes1
.
IsEmpty
(
)
^
prefixes2
.
IsEmpty
(
)
)
;
input
=
prefixes1
.
IsEmpty
(
)
?
&
prefixes2
:
&
prefixes1
;
output
=
prefixes1
.
IsEmpty
(
)
?
&
prefixes1
:
&
prefixes2
;
}
rv
=
lookupCache
-
>
ApplyUpdate
(
updateV4
*
input
*
output
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
input
-
>
Clear
(
)
;
}
lastAppliedUpdate
=
updateV4
;
aUpdates
-
>
ElementAt
(
i
)
=
nullptr
;
}
rv
=
lookupCache
-
>
Build
(
*
output
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_UC_UPDATE_BUILD_PREFIX_FAILURE
)
;
rv
=
lookupCache
-
>
WriteFile
(
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_UC_UPDATE_FAIL_TO_WRITE_DISK
)
;
if
(
lastAppliedUpdate
)
{
LOG
(
(
"
Write
meta
data
of
the
last
applied
update
.
"
)
)
;
rv
=
lookupCache
-
>
WriteMetadata
(
lastAppliedUpdate
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_UC_UPDATE_FAIL_TO_WRITE_DISK
)
;
}
LOG
(
(
"
Successfully
updated
%
s
\
n
"
PromiseFlatCString
(
aTable
)
.
get
(
)
)
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
UpdateCache
(
TableUpdate
*
aUpdate
)
{
if
(
!
aUpdate
)
{
return
NS_OK
;
}
nsAutoCString
table
(
aUpdate
-
>
TableName
(
)
)
;
LOG
(
(
"
Classifier
:
:
UpdateCache
(
%
s
)
"
table
.
get
(
)
)
)
;
LookupCache
*
lookupCache
=
GetLookupCache
(
table
)
;
if
(
!
lookupCache
)
{
return
NS_ERROR_FAILURE
;
}
auto
lookupV2
=
LookupCache
:
:
Cast
<
LookupCacheV2
>
(
lookupCache
)
;
if
(
lookupV2
)
{
auto
updateV2
=
TableUpdate
:
:
Cast
<
TableUpdateV2
>
(
aUpdate
)
;
lookupV2
-
>
AddGethashResultToCache
(
updateV2
-
>
AddCompletes
(
)
updateV2
-
>
MissPrefixes
(
)
)
;
}
else
{
auto
lookupV4
=
LookupCache
:
:
Cast
<
LookupCacheV4
>
(
lookupCache
)
;
if
(
!
lookupV4
)
{
return
NS_ERROR_FAILURE
;
}
auto
updateV4
=
TableUpdate
:
:
Cast
<
TableUpdateV4
>
(
aUpdate
)
;
lookupV4
-
>
AddFullHashResponseToCache
(
updateV4
-
>
FullHashResponse
(
)
)
;
}
#
if
defined
(
DEBUG
)
lookupCache
-
>
DumpCache
(
)
;
#
endif
return
NS_OK
;
}
LookupCache
*
Classifier
:
:
GetLookupCache
(
const
nsACString
&
aTable
bool
aForUpdate
)
{
MOZ_ASSERT_IF
(
aForUpdate
NS_GetCurrentThread
(
)
=
=
mUpdateThread
)
;
nsTArray
<
LookupCache
*
>
&
lookupCaches
=
aForUpdate
?
mNewLookupCaches
:
mLookupCaches
;
auto
&
rootStoreDirectory
=
aForUpdate
?
mUpdatingDirectory
:
mRootStoreDirectory
;
for
(
auto
c
:
lookupCaches
)
{
if
(
c
-
>
TableName
(
)
.
Equals
(
aTable
)
)
{
return
c
;
}
}
if
(
nsUrlClassifierDBService
:
:
ShutdownHasStarted
(
)
)
{
return
nullptr
;
}
UniquePtr
<
LookupCache
>
cache
;
nsCString
provider
=
GetProvider
(
aTable
)
;
if
(
StringEndsWith
(
aTable
NS_LITERAL_CSTRING
(
"
-
proto
"
)
)
)
{
cache
=
MakeUnique
<
LookupCacheV4
>
(
aTable
provider
rootStoreDirectory
)
;
}
else
{
cache
=
MakeUnique
<
LookupCacheV2
>
(
aTable
provider
rootStoreDirectory
)
;
}
nsresult
rv
=
cache
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
rv
=
cache
-
>
Open
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
lookupCaches
.
AppendElement
(
cache
.
get
(
)
)
;
return
cache
.
release
(
)
;
}
if
(
aForUpdate
)
{
RemoveUpdateIntermediaries
(
)
;
return
nullptr
;
}
if
(
rv
=
=
NS_ERROR_FILE_CORRUPTED
)
{
Reset
(
)
;
}
return
nullptr
;
}
nsresult
Classifier
:
:
ReadNoiseEntries
(
const
Prefix
&
aPrefix
const
nsACString
&
aTableName
uint32_t
aCount
PrefixArray
*
aNoiseEntries
)
{
FallibleTArray
<
uint32_t
>
prefixes
;
nsresult
rv
;
LookupCache
*
cache
=
GetLookupCache
(
aTableName
)
;
if
(
!
cache
)
{
return
NS_ERROR_FAILURE
;
}
LookupCacheV2
*
cacheV2
=
LookupCache
:
:
Cast
<
LookupCacheV2
>
(
cache
)
;
if
(
cacheV2
)
{
rv
=
cacheV2
-
>
GetPrefixes
(
prefixes
)
;
}
else
{
rv
=
LookupCache
:
:
Cast
<
LookupCacheV4
>
(
cache
)
-
>
GetFixedLengthPrefixes
(
prefixes
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
prefixes
.
Length
(
)
=
=
0
)
{
NS_WARNING
(
"
Could
not
find
prefix
in
PrefixSet
during
noise
lookup
"
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
m
=
prefixes
.
Length
(
)
;
uint32_t
a
=
aCount
%
m
;
uint32_t
idx
=
aPrefix
.
ToUint32
(
)
%
m
;
for
(
size_t
i
=
0
;
i
<
aCount
;
i
+
+
)
{
idx
=
(
a
*
idx
+
a
)
%
m
;
Prefix
newPrefix
;
uint32_t
hash
=
prefixes
[
idx
]
;
if
(
!
cacheV2
&
&
!
bool
(
MOZ_BIG_ENDIAN
)
)
{
hash
=
NativeEndian
:
:
swapFromBigEndian
(
prefixes
[
idx
]
)
;
}
newPrefix
.
FromUint32
(
hash
)
;
if
(
newPrefix
!
=
aPrefix
)
{
aNoiseEntries
-
>
AppendElement
(
newPrefix
)
;
}
}
return
NS_OK
;
}
nsresult
Classifier
:
:
LoadMetadata
(
nsIFile
*
aDirectory
nsACString
&
aResult
)
{
nsCOMPtr
<
nsIDirectoryEnumerator
>
entries
;
nsresult
rv
=
aDirectory
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_ARG_POINTER
(
entries
)
;
nsCOMPtr
<
nsIFile
>
file
;
while
(
NS_SUCCEEDED
(
rv
=
entries
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
)
&
&
file
)
{
bool
isDirectory
;
if
(
NS_FAILED
(
file
-
>
IsDirectory
(
&
isDirectory
)
)
)
{
continue
;
}
if
(
isDirectory
)
{
LoadMetadata
(
file
aResult
)
;
continue
;
}
nsCString
tableName
;
rv
=
file
-
>
GetNativeLeafName
(
tableName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
dot
=
tableName
.
RFind
(
METADATA_SUFFIX
)
;
if
(
dot
=
=
-
1
)
{
continue
;
}
tableName
.
Cut
(
dot
METADATA_SUFFIX
.
Length
(
)
)
;
LookupCacheV4
*
lookupCache
=
LookupCache
:
:
Cast
<
LookupCacheV4
>
(
GetLookupCache
(
tableName
)
)
;
if
(
!
lookupCache
)
{
continue
;
}
nsCString
state
;
nsCString
checksum
;
rv
=
lookupCache
-
>
LoadMetadata
(
state
checksum
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
get
metadata
for
table
%
s
"
tableName
.
get
(
)
)
)
;
continue
;
}
nsAutoCString
stateBase64
;
rv
=
Base64Encode
(
state
stateBase64
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
checksumBase64
;
rv
=
Base64Encode
(
checksum
checksumBase64
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOG
(
(
"
Appending
state
'
%
s
'
and
checksum
'
%
s
'
for
table
%
s
"
stateBase64
.
get
(
)
checksumBase64
.
get
(
)
tableName
.
get
(
)
)
)
;
aResult
.
AppendPrintf
(
"
%
s
;
%
s
:
%
s
\
n
"
tableName
.
get
(
)
stateBase64
.
get
(
)
checksumBase64
.
get
(
)
)
;
}
return
rv
;
}
}
}
