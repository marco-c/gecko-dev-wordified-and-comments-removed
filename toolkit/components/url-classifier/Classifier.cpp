#
include
"
Classifier
.
h
"
#
include
"
LookupCacheV4
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIRandomGenerator
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
SizePrintfMacros
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
nsIUrlClassifierUtils
.
h
"
#
include
"
nsUrlClassifierDBService
.
h
"
extern
mozilla
:
:
LazyLogModule
gUrlClassifierDbServiceLog
;
#
define
LOG
(
args
)
MOZ_LOG
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
MOZ_LOG_TEST
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
)
#
define
STORE_DIRECTORY
NS_LITERAL_CSTRING
(
"
safebrowsing
"
)
#
define
TO_DELETE_DIR_SUFFIX
NS_LITERAL_CSTRING
(
"
-
to_delete
"
)
#
define
BACKUP_DIR_SUFFIX
NS_LITERAL_CSTRING
(
"
-
backup
"
)
#
define
UPDATING_DIR_SUFFIX
NS_LITERAL_CSTRING
(
"
-
updating
"
)
#
define
METADATA_SUFFIX
NS_LITERAL_CSTRING
(
"
.
metadata
"
)
namespace
mozilla
{
namespace
safebrowsing
{
namespace
{
class
ScopedUpdatesClearer
{
public
:
explicit
ScopedUpdatesClearer
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
)
:
mUpdatesArrayRef
(
aUpdates
)
{
for
(
auto
update
:
*
aUpdates
)
{
mUpdatesPointerHolder
.
AppendElement
(
update
)
;
}
}
~
ScopedUpdatesClearer
(
)
{
mUpdatesArrayRef
-
>
Clear
(
)
;
}
private
:
nsTArray
<
TableUpdate
*
>
*
mUpdatesArrayRef
;
nsTArray
<
nsAutoPtr
<
TableUpdate
>
>
mUpdatesPointerHolder
;
}
;
}
void
Classifier
:
:
SplitTables
(
const
nsACString
&
str
nsTArray
<
nsCString
>
&
tables
)
{
tables
.
Clear
(
)
;
nsACString
:
:
const_iterator
begin
iter
end
;
str
.
BeginReading
(
begin
)
;
str
.
EndReading
(
end
)
;
while
(
begin
!
=
end
)
{
iter
=
begin
;
FindCharInReadable
(
'
'
iter
end
)
;
nsDependentCSubstring
table
=
Substring
(
begin
iter
)
;
if
(
!
table
.
IsEmpty
(
)
)
{
tables
.
AppendElement
(
Substring
(
begin
iter
)
)
;
}
begin
=
iter
;
if
(
begin
!
=
end
)
{
begin
+
+
;
}
}
}
nsresult
Classifier
:
:
GetPrivateStoreDirectory
(
nsIFile
*
aRootStoreDirectory
const
nsACString
&
aTableName
const
nsACString
&
aProvider
nsIFile
*
*
aPrivateStoreDirectory
)
{
NS_ENSURE_ARG_POINTER
(
aPrivateStoreDirectory
)
;
if
(
!
StringEndsWith
(
aTableName
NS_LITERAL_CSTRING
(
"
-
proto
"
)
)
)
{
nsCOMPtr
<
nsIFile
>
(
aRootStoreDirectory
)
.
forget
(
aPrivateStoreDirectory
)
;
return
NS_OK
;
}
if
(
aProvider
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIFile
>
(
aRootStoreDirectory
)
.
forget
(
aPrivateStoreDirectory
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
providerDirectory
;
nsresult
rv
=
aRootStoreDirectory
-
>
Clone
(
getter_AddRefs
(
providerDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
providerDirectory
-
>
AppendNative
(
aProvider
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
dirExists
;
rv
=
providerDirectory
-
>
Exists
(
&
dirExists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
dirExists
)
{
LOG
(
(
"
Creating
private
directory
for
%
s
"
nsCString
(
aTableName
)
.
get
(
)
)
)
;
rv
=
providerDirectory
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
providerDirectory
.
forget
(
aPrivateStoreDirectory
)
;
return
rv
;
}
bool
isDir
;
rv
=
providerDirectory
-
>
IsDirectory
(
&
isDir
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isDir
)
{
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
providerDirectory
.
forget
(
aPrivateStoreDirectory
)
;
return
NS_OK
;
}
Classifier
:
:
Classifier
(
)
:
mIsTableRequestResultOutdated
(
true
)
{
}
Classifier
:
:
~
Classifier
(
)
{
Close
(
)
;
}
nsresult
Classifier
:
:
SetupPathNames
(
)
{
nsresult
rv
=
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
mRootStoreDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mRootStoreDirectory
-
>
AppendNative
(
STORE_DIRECTORY
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
mLookupCaches
.
Length
(
)
;
i
+
+
)
{
mLookupCaches
[
i
]
-
>
UpdateRootDirHandle
(
mRootStoreDirectory
)
;
}
rv
=
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
mBackupDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mBackupDirectory
-
>
AppendNative
(
STORE_DIRECTORY
+
BACKUP_DIR_SUFFIX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
mUpdatingDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mUpdatingDirectory
-
>
AppendNative
(
STORE_DIRECTORY
+
UPDATING_DIR_SUFFIX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
mToDeleteDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mToDeleteDirectory
-
>
AppendNative
(
STORE_DIRECTORY
+
TO_DELETE_DIR_SUFFIX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
CreateStoreDirectory
(
)
{
bool
storeExists
;
nsresult
rv
=
mRootStoreDirectory
-
>
Exists
(
&
storeExists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
storeExists
)
{
rv
=
mRootStoreDirectory
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
bool
storeIsDir
;
rv
=
mRootStoreDirectory
-
>
IsDirectory
(
&
storeIsDir
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
storeIsDir
)
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
return
NS_OK
;
}
nsresult
Classifier
:
:
Open
(
nsIFile
&
aCacheDirectory
)
{
nsresult
rv
=
aCacheDirectory
.
Clone
(
getter_AddRefs
(
mCacheDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetupPathNames
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CleanToDelete
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mUpdatingDirectory
-
>
Remove
(
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
We
may
have
hit
a
crash
in
the
previous
update
.
"
)
)
;
}
rv
=
RecoverBackups
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CreateStoreDirectory
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCryptoHash
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RegenActiveTables
(
)
;
return
NS_OK
;
}
void
Classifier
:
:
Close
(
)
{
DropStores
(
)
;
}
void
Classifier
:
:
Reset
(
)
{
DropStores
(
)
;
mRootStoreDirectory
-
>
Remove
(
true
)
;
mBackupDirectory
-
>
Remove
(
true
)
;
mUpdatingDirectory
-
>
Remove
(
true
)
;
mToDeleteDirectory
-
>
Remove
(
true
)
;
CreateStoreDirectory
(
)
;
mTableFreshness
.
Clear
(
)
;
RegenActiveTables
(
)
;
}
void
Classifier
:
:
ResetTables
(
ClearType
aType
const
nsTArray
<
nsCString
>
&
aTables
)
{
for
(
uint32_t
i
=
0
;
i
<
aTables
.
Length
(
)
;
i
+
+
)
{
LOG
(
(
"
Resetting
table
:
%
s
"
aTables
[
i
]
.
get
(
)
)
)
;
mTableFreshness
.
Remove
(
aTables
[
i
]
)
;
LookupCache
*
cache
=
GetLookupCache
(
aTables
[
i
]
)
;
if
(
cache
)
{
if
(
aType
=
=
Clear_Cache
)
{
cache
-
>
ClearCache
(
)
;
}
else
{
cache
-
>
ClearAll
(
)
;
}
}
}
if
(
aType
=
=
Clear_All
)
{
DeleteTables
(
mRootStoreDirectory
aTables
)
;
RegenActiveTables
(
)
;
}
}
void
Classifier
:
:
DeleteTables
(
nsIFile
*
aDirectory
const
nsTArray
<
nsCString
>
&
aTables
)
{
nsCOMPtr
<
nsISimpleEnumerator
>
entries
;
nsresult
rv
=
aDirectory
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
bool
hasMore
;
while
(
NS_SUCCEEDED
(
rv
=
entries
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
supports
;
rv
=
entries
-
>
GetNext
(
getter_AddRefs
(
supports
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsCOMPtr
<
nsIFile
>
file
=
do_QueryInterface
(
supports
)
;
NS_ENSURE_TRUE_VOID
(
file
)
;
bool
isDirectory
;
if
(
NS_FAILED
(
file
-
>
IsDirectory
(
&
isDirectory
)
)
)
{
continue
;
}
if
(
isDirectory
)
{
DeleteTables
(
file
aTables
)
;
continue
;
}
nsCString
leafName
;
rv
=
file
-
>
GetNativeLeafName
(
leafName
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
leafName
.
Truncate
(
leafName
.
RFind
(
"
.
"
)
)
;
if
(
aTables
.
Contains
(
leafName
)
)
{
if
(
NS_FAILED
(
file
-
>
Remove
(
false
)
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
Fail
to
remove
file
%
s
from
the
disk
"
leafName
.
get
(
)
)
.
get
(
)
)
;
}
}
}
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
void
Classifier
:
:
AbortUpdateAndReset
(
const
nsCString
&
aTable
)
{
if
(
nsUrlClassifierDBService
:
:
ShutdownHasStarted
(
)
)
{
return
;
}
LOG
(
(
"
Abort
updating
table
%
s
.
"
aTable
.
get
(
)
)
)
;
ResetTables
(
Clear_All
nsTArray
<
nsCString
>
{
aTable
}
)
;
}
void
Classifier
:
:
TableRequest
(
nsACString
&
aResult
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
TableRequest
must
be
called
on
the
classifier
worker
thread
.
"
)
;
if
(
!
mIsTableRequestResultOutdated
)
{
aResult
=
mTableRequestResult
;
return
;
}
nsTArray
<
nsCString
>
tables
;
ActiveTables
(
tables
)
;
for
(
uint32_t
i
=
0
;
i
<
tables
.
Length
(
)
;
i
+
+
)
{
HashStore
store
(
tables
[
i
]
GetProvider
(
tables
[
i
]
)
mRootStoreDirectory
)
;
nsresult
rv
=
store
.
Open
(
)
;
if
(
NS_FAILED
(
rv
)
)
continue
;
aResult
.
Append
(
store
.
TableName
(
)
)
;
aResult
.
Append
(
'
;
'
)
;
ChunkSet
&
adds
=
store
.
AddChunks
(
)
;
ChunkSet
&
subs
=
store
.
SubChunks
(
)
;
if
(
adds
.
Length
(
)
>
0
)
{
aResult
.
AppendLiteral
(
"
a
:
"
)
;
nsAutoCString
addList
;
adds
.
Serialize
(
addList
)
;
aResult
.
Append
(
addList
)
;
}
if
(
subs
.
Length
(
)
>
0
)
{
if
(
adds
.
Length
(
)
>
0
)
aResult
.
Append
(
'
:
'
)
;
aResult
.
AppendLiteral
(
"
s
:
"
)
;
nsAutoCString
subList
;
subs
.
Serialize
(
subList
)
;
aResult
.
Append
(
subList
)
;
}
aResult
.
Append
(
'
\
n
'
)
;
}
nsCString
metadata
;
nsresult
rv
=
LoadMetadata
(
mRootStoreDirectory
metadata
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aResult
.
Append
(
metadata
)
;
}
mTableRequestResult
=
aResult
;
mIsTableRequestResultOutdated
=
false
;
}
enum
class
PrefixMatch
:
uint8_t
{
eNoMatch
=
0x00
eMatchV2Prefix
=
0x01
eMatchV4Prefix
=
0x02
eMatchBoth
=
eMatchV2Prefix
|
eMatchV4Prefix
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
PrefixMatch
)
nsresult
Classifier
:
:
Check
(
const
nsACString
&
aSpec
const
nsACString
&
aTables
uint32_t
aFreshnessGuarantee
LookupResultArray
&
aResults
)
{
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
URLCLASSIFIER_CL_CHECK_TIME
>
timer
;
nsTArray
<
nsCString
>
fragments
;
nsresult
rv
=
LookupCache
:
:
GetLookupFragments
(
aSpec
&
fragments
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsTArray
<
nsCString
>
activeTables
;
SplitTables
(
aTables
activeTables
)
;
nsTArray
<
LookupCache
*
>
cacheArray
;
for
(
uint32_t
i
=
0
;
i
<
activeTables
.
Length
(
)
;
i
+
+
)
{
LOG
(
(
"
Checking
table
%
s
"
activeTables
[
i
]
.
get
(
)
)
)
;
LookupCache
*
cache
=
GetLookupCache
(
activeTables
[
i
]
)
;
if
(
cache
)
{
cacheArray
.
AppendElement
(
cache
)
;
}
else
{
return
NS_ERROR_FAILURE
;
}
}
bool
isV2Empty
=
true
isV4Empty
=
true
;
for
(
auto
&
&
cache
:
cacheArray
)
{
bool
&
ref
=
LookupCache
:
:
Cast
<
LookupCacheV2
>
(
cache
)
?
isV2Empty
:
isV4Empty
;
ref
=
ref
?
cache
-
>
IsEmpty
(
)
:
false
;
if
(
!
isV2Empty
&
&
!
isV4Empty
)
{
break
;
}
}
PrefixMatch
matchingStatistics
=
PrefixMatch
:
:
eNoMatch
;
for
(
uint32_t
i
=
0
;
i
<
fragments
.
Length
(
)
;
i
+
+
)
{
Completion
lookupHash
;
lookupHash
.
FromPlaintext
(
fragments
[
i
]
mCryptoHash
)
;
if
(
LOG_ENABLED
(
)
)
{
nsAutoCString
checking
;
lookupHash
.
ToHexString
(
checking
)
;
LOG
(
(
"
Checking
fragment
%
s
hash
%
s
(
%
X
)
"
fragments
[
i
]
.
get
(
)
checking
.
get
(
)
lookupHash
.
ToUint32
(
)
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
cacheArray
.
Length
(
)
;
i
+
+
)
{
LookupCache
*
cache
=
cacheArray
[
i
]
;
bool
has
fromCache
;
uint32_t
matchLength
;
rv
=
cache
-
>
Has
(
lookupHash
&
has
&
matchLength
&
fromCache
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
has
)
{
LookupResult
*
result
=
aResults
.
AppendElement
(
)
;
if
(
!
result
)
return
NS_ERROR_OUT_OF_MEMORY
;
bool
confirmed
=
false
;
if
(
fromCache
)
{
cache
-
>
IsHashEntryConfirmed
(
lookupHash
mTableFreshness
aFreshnessGuarantee
&
confirmed
)
;
}
LOG
(
(
"
Found
a
result
in
%
s
:
%
s
"
cache
-
>
TableName
(
)
.
get
(
)
confirmed
?
"
confirmed
.
"
:
"
Not
confirmed
.
"
)
)
;
result
-
>
hash
.
complete
=
lookupHash
;
result
-
>
mConfirmed
=
confirmed
;
result
-
>
mTableName
.
Assign
(
cache
-
>
TableName
(
)
)
;
result
-
>
mPartialHashLength
=
confirmed
?
COMPLETE_SIZE
:
matchLength
;
if
(
LookupCache
:
:
Cast
<
LookupCacheV4
>
(
cache
)
)
{
matchingStatistics
|
=
PrefixMatch
:
:
eMatchV4Prefix
;
result
-
>
mProtocolV2
=
false
;
}
else
{
matchingStatistics
|
=
PrefixMatch
:
:
eMatchV2Prefix
;
result
-
>
mProtocolV2
=
true
;
}
}
}
if
(
!
isV2Empty
&
&
!
isV4Empty
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
URLCLASSIFIER_PREFIX_MATCH
static_cast
<
uint8_t
>
(
matchingStatistics
)
)
;
}
}
return
NS_OK
;
}
static
nsresult
SwapDirectoryContent
(
nsIFile
*
aDir1
nsIFile
*
aDir2
nsIFile
*
aParentDir
nsIFile
*
aTempDir
)
{
nsAutoCString
tempDirName
;
aTempDir
-
>
GetNativeLeafName
(
tempDirName
)
;
nsresult
rv
;
nsAutoCString
dirName1
dirName2
;
aDir1
-
>
GetNativeLeafName
(
dirName1
)
;
aDir2
-
>
GetNativeLeafName
(
dirName2
)
;
LOG
(
(
"
Swapping
directories
%
s
and
%
s
.
.
.
"
dirName1
.
get
(
)
dirName2
.
get
(
)
)
)
;
rv
=
aDir1
-
>
RenameToNative
(
nullptr
tempDirName
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Unable
to
rename
%
s
to
%
s
"
dirName1
.
get
(
)
tempDirName
.
get
(
)
)
)
;
return
rv
;
}
nsCOMPtr
<
nsIFile
>
tempDirectory
;
rv
=
aParentDir
-
>
Clone
(
getter_AddRefs
(
tempDirectory
)
)
;
rv
=
tempDirectory
-
>
AppendNative
(
tempDirName
)
;
rv
=
aDir2
-
>
RenameToNative
(
nullptr
dirName1
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
rename
%
s
to
%
s
.
Rename
temp
directory
back
to
%
s
"
dirName2
.
get
(
)
dirName1
.
get
(
)
dirName1
.
get
(
)
)
)
;
nsresult
rbrv
=
tempDirectory
-
>
RenameToNative
(
nullptr
dirName1
)
;
NS_ENSURE_SUCCESS
(
rbrv
rbrv
)
;
return
rv
;
}
rv
=
tempDirectory
-
>
RenameToNative
(
nullptr
dirName2
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
rename
temp
directory
to
%
s
.
"
dirName2
.
get
(
)
)
)
;
nsresult
rbrv
;
rbrv
=
aDir1
-
>
RenameToNative
(
nullptr
dirName2
)
;
NS_ENSURE_SUCCESS
(
rbrv
rbrv
)
;
rbrv
=
tempDirectory
-
>
RenameToNative
(
nullptr
dirName1
)
;
NS_ENSURE_SUCCESS
(
rbrv
rbrv
)
;
return
rv
;
}
return
rv
;
}
void
Classifier
:
:
RemoveUpdateIntermediaries
(
)
{
for
(
auto
c
:
mNewLookupCaches
)
{
delete
c
;
}
mNewLookupCaches
.
Clear
(
)
;
if
(
NS_FAILED
(
mUpdatingDirectory
-
>
Remove
(
true
)
)
)
{
LOG
(
(
"
Failed
to
remove
updating
directory
.
"
)
)
;
}
}
nsresult
Classifier
:
:
SwapInNewTablesAndCleanup
(
)
{
nsresult
rv
;
rv
=
SwapDirectoryContent
(
mUpdatingDirectory
mRootStoreDirectory
mCacheDirectory
mBackupDirectory
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
swap
in
on
-
disk
tables
.
"
)
)
;
RemoveUpdateIntermediaries
(
)
;
return
rv
;
}
mLookupCaches
.
SwapElements
(
mNewLookupCaches
)
;
for
(
auto
c
:
mLookupCaches
)
{
c
-
>
UpdateRootDirHandle
(
mRootStoreDirectory
)
;
}
rv
=
RegenActiveTables
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
re
-
generate
active
tables
!
"
)
)
;
}
RemoveUpdateIntermediaries
(
)
;
mIsTableRequestResultOutdated
=
true
;
LOG
(
(
"
Done
swap
in
updated
tables
.
"
)
)
;
return
rv
;
}
nsresult
Classifier
:
:
ApplyUpdates
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
)
{
if
(
!
aUpdates
|
|
aUpdates
-
>
Length
(
)
=
=
0
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIUrlClassifierUtils
>
urlUtil
=
do_GetService
(
NS_URLCLASSIFIERUTILS_CONTRACTID
)
;
nsCString
provider
;
urlUtil
-
>
GetTelemetryProvider
(
(
*
aUpdates
)
[
0
]
-
>
TableName
(
)
provider
)
;
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
URLCLASSIFIER_CL_KEYED_UPDATE_TIME
>
keyedTimer
(
provider
)
;
PRIntervalTime
clockStart
=
0
;
if
(
LOG_ENABLED
(
)
)
{
clockStart
=
PR_IntervalNow
(
)
;
}
nsresult
rv
;
{
ScopedUpdatesClearer
scopedUpdatesClearer
(
aUpdates
)
;
{
rv
=
CopyInUseDirForUpdate
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
copy
in
-
use
directory
for
update
.
"
)
)
;
return
rv
;
}
CopyInUseLookupCacheForUpdate
(
)
;
}
LOG
(
(
"
Applying
%
"
PRIuSIZE
"
table
updates
.
"
aUpdates
-
>
Length
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
-
>
Length
(
)
;
i
+
+
)
{
if
(
(
*
aUpdates
)
[
i
]
)
{
nsCString
updateTable
(
aUpdates
-
>
ElementAt
(
i
)
-
>
TableName
(
)
)
;
if
(
TableUpdate
:
:
Cast
<
TableUpdateV2
>
(
(
*
aUpdates
)
[
i
]
)
)
{
rv
=
UpdateHashStore
(
aUpdates
updateTable
)
;
}
else
{
rv
=
UpdateTableV4
(
aUpdates
updateTable
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
!
=
NS_ERROR_OUT_OF_MEMORY
)
{
#
ifdef
MOZ_SAFEBROWSING_DUMP_FAILED_UPDATES
DumpFailedUpdate
(
)
;
#
endif
AbortUpdateAndReset
(
updateTable
)
;
}
RemoveUpdateIntermediaries
(
)
;
return
rv
;
}
}
}
}
rv
=
SwapInNewTablesAndCleanup
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
swap
in
new
tables
.
"
)
)
;
}
if
(
LOG_ENABLED
(
)
)
{
PRIntervalTime
clockEnd
=
PR_IntervalNow
(
)
;
LOG
(
(
"
update
took
%
dms
\
n
"
PR_IntervalToMilliseconds
(
clockEnd
-
clockStart
)
)
)
;
}
return
rv
;
}
nsresult
Classifier
:
:
ApplyFullHashes
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
)
{
LOG
(
(
"
Applying
%
"
PRIuSIZE
"
table
gethashes
.
"
aUpdates
-
>
Length
(
)
)
)
;
ScopedUpdatesClearer
scopedUpdatesClearer
(
aUpdates
)
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
-
>
Length
(
)
;
i
+
+
)
{
TableUpdate
*
update
=
aUpdates
-
>
ElementAt
(
i
)
;
nsresult
rv
=
UpdateCache
(
update
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aUpdates
-
>
ElementAt
(
i
)
=
nullptr
;
}
return
NS_OK
;
}
int64_t
Classifier
:
:
GetLastUpdateTime
(
const
nsACString
&
aTableName
)
{
int64_t
age
;
bool
found
=
mTableFreshness
.
Get
(
aTableName
&
age
)
;
return
found
?
(
age
*
PR_MSEC_PER_SEC
)
:
0
;
}
void
Classifier
:
:
SetLastUpdateTime
(
const
nsACString
&
aTable
uint64_t
updateTime
)
{
LOG
(
(
"
Marking
table
%
s
as
last
updated
on
%
"
PRIu64
PromiseFlatCString
(
aTable
)
.
get
(
)
updateTime
)
)
;
mTableFreshness
.
Put
(
aTable
updateTime
/
PR_MSEC_PER_SEC
)
;
}
void
Classifier
:
:
DropStores
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mLookupCaches
.
Length
(
)
;
i
+
+
)
{
delete
mLookupCaches
[
i
]
;
}
mLookupCaches
.
Clear
(
)
;
}
nsresult
Classifier
:
:
RegenActiveTables
(
)
{
mActiveTablesCache
.
Clear
(
)
;
nsTArray
<
nsCString
>
foundTables
;
ScanStoreDir
(
foundTables
)
;
for
(
uint32_t
i
=
0
;
i
<
foundTables
.
Length
(
)
;
i
+
+
)
{
nsCString
table
(
foundTables
[
i
]
)
;
HashStore
store
(
table
GetProvider
(
table
)
mRootStoreDirectory
)
;
nsresult
rv
=
store
.
Open
(
)
;
if
(
NS_FAILED
(
rv
)
)
continue
;
LookupCache
*
lookupCache
=
GetLookupCache
(
store
.
TableName
(
)
)
;
if
(
!
lookupCache
)
{
continue
;
}
if
(
!
lookupCache
-
>
IsPrimed
(
)
)
continue
;
const
ChunkSet
&
adds
=
store
.
AddChunks
(
)
;
const
ChunkSet
&
subs
=
store
.
SubChunks
(
)
;
if
(
adds
.
Length
(
)
=
=
0
&
&
subs
.
Length
(
)
=
=
0
)
continue
;
LOG
(
(
"
Active
table
:
%
s
"
store
.
TableName
(
)
.
get
(
)
)
)
;
mActiveTablesCache
.
AppendElement
(
store
.
TableName
(
)
)
;
}
return
NS_OK
;
}
nsresult
Classifier
:
:
ScanStoreDir
(
nsTArray
<
nsCString
>
&
aTables
)
{
nsCOMPtr
<
nsISimpleEnumerator
>
entries
;
nsresult
rv
=
mRootStoreDirectory
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasMore
;
while
(
NS_SUCCEEDED
(
rv
=
entries
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
supports
;
rv
=
entries
-
>
GetNext
(
getter_AddRefs
(
supports
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
file
=
do_QueryInterface
(
supports
)
;
nsCString
leafName
;
rv
=
file
-
>
GetNativeLeafName
(
leafName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCString
suffix
(
NS_LITERAL_CSTRING
(
"
.
sbstore
"
)
)
;
int32_t
dot
=
leafName
.
RFind
(
suffix
0
)
;
if
(
dot
!
=
-
1
)
{
leafName
.
Cut
(
dot
suffix
.
Length
(
)
)
;
aTables
.
AppendElement
(
leafName
)
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
ActiveTables
(
nsTArray
<
nsCString
>
&
aTables
)
{
aTables
=
mActiveTablesCache
;
return
NS_OK
;
}
nsresult
Classifier
:
:
CleanToDelete
(
)
{
bool
exists
;
nsresult
rv
=
mToDeleteDirectory
-
>
Exists
(
&
exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
exists
)
{
rv
=
mToDeleteDirectory
-
>
Remove
(
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
#
ifdef
MOZ_SAFEBROWSING_DUMP_FAILED_UPDATES
already_AddRefed
<
nsIFile
>
Classifier
:
:
GetFailedUpdateDirectroy
(
)
{
nsCString
failedUpdatekDirName
=
STORE_DIRECTORY
+
nsCString
(
"
-
failedupdate
"
)
;
nsCOMPtr
<
nsIFile
>
failedUpdatekDirectory
;
if
(
NS_FAILED
(
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
failedUpdatekDirectory
)
)
)
|
|
NS_FAILED
(
failedUpdatekDirectory
-
>
AppendNative
(
failedUpdatekDirName
)
)
)
{
LOG
(
(
"
Failed
to
init
failedUpdatekDirectory
.
"
)
)
;
return
nullptr
;
}
return
failedUpdatekDirectory
.
forget
(
)
;
}
nsresult
Classifier
:
:
DumpRawTableUpdates
(
const
nsACString
&
aRawUpdates
)
{
LOG
(
(
"
Dumping
raw
table
updates
.
.
.
"
)
)
;
nsCOMPtr
<
nsIFile
>
failedUpdatekDirectory
=
GetFailedUpdateDirectroy
(
)
;
nsCOMPtr
<
nsIFile
>
rawTableUpdatesFile
;
nsCOMPtr
<
nsIOutputStream
>
outputStream
;
if
(
NS_FAILED
(
failedUpdatekDirectory
-
>
Clone
(
getter_AddRefs
(
rawTableUpdatesFile
)
)
)
|
|
NS_FAILED
(
rawTableUpdatesFile
-
>
AppendNative
(
nsCString
(
"
tableupdates
.
bin
"
)
)
)
|
|
NS_FAILED
(
NS_NewLocalFileOutputStream
(
getter_AddRefs
(
outputStream
)
rawTableUpdatesFile
PR_WRONLY
|
PR_TRUNCATE
|
PR_CREATE_FILE
)
)
)
{
LOG
(
(
"
Failed
to
create
file
to
dump
raw
table
updates
.
"
)
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
written
;
nsresult
rv
=
outputStream
-
>
Write
(
aRawUpdates
.
BeginReading
(
)
aRawUpdates
.
Length
(
)
&
written
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
written
=
=
aRawUpdates
.
Length
(
)
NS_ERROR_FAILURE
)
;
return
rv
;
}
nsresult
Classifier
:
:
DumpFailedUpdate
(
)
{
LOG
(
(
"
Dumping
failed
update
.
.
.
"
)
)
;
nsCOMPtr
<
nsIFile
>
failedUpdatekDirectory
=
GetFailedUpdateDirectroy
(
)
;
failedUpdatekDirectory
-
>
Remove
(
true
)
;
nsCString
failedUpdatekDirName
;
nsresult
rv
=
failedUpdatekDirectory
-
>
GetNativeLeafName
(
failedUpdatekDirName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
inUseDirectory
;
if
(
NS_FAILED
(
mRootStoreDirectory
-
>
Clone
(
getter_AddRefs
(
inUseDirectory
)
)
)
|
|
NS_FAILED
(
inUseDirectory
-
>
CopyToNative
(
nullptr
failedUpdatekDirName
)
)
)
{
LOG
(
(
"
Failed
to
move
in
-
use
to
the
\
"
failed
update
\
"
directory
%
s
"
failedUpdatekDirName
.
get
(
)
)
)
;
return
NS_ERROR_FAILURE
;
}
return
rv
;
}
#
endif
nsresult
Classifier
:
:
CopyInUseDirForUpdate
(
)
{
LOG
(
(
"
Copy
in
-
use
directory
content
for
update
.
"
)
)
;
nsCString
updatingDirName
;
nsresult
rv
=
mUpdatingDirectory
-
>
GetNativeLeafName
(
updatingDirName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mUpdatingDirectory
-
>
Remove
(
true
)
;
rv
=
mRootStoreDirectory
-
>
CopyToNative
(
nullptr
updatingDirName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetupPathNames
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
void
Classifier
:
:
CopyInUseLookupCacheForUpdate
(
)
{
MOZ_ASSERT
(
mNewLookupCaches
.
IsEmpty
(
)
"
Update
intermediaries
is
forgotten
to
"
"
be
removed
in
the
previous
update
.
"
)
;
for
(
auto
c
:
mLookupCaches
)
{
Unused
<
<
GetLookupCacheForUpdate
(
c
-
>
TableName
(
)
)
;
}
}
nsresult
Classifier
:
:
RecoverBackups
(
)
{
bool
backupExists
;
nsresult
rv
=
mBackupDirectory
-
>
Exists
(
&
backupExists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
backupExists
)
{
nsCString
storeDirName
;
rv
=
mRootStoreDirectory
-
>
GetNativeLeafName
(
storeDirName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
storeExists
;
rv
=
mRootStoreDirectory
-
>
Exists
(
&
storeExists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
storeExists
)
{
rv
=
mRootStoreDirectory
-
>
Remove
(
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
mBackupDirectory
-
>
MoveToNative
(
nullptr
storeDirName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetupPathNames
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
bool
Classifier
:
:
CheckValidUpdate
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
const
nsACString
&
aTable
)
{
uint32_t
validupdates
=
0
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
-
>
Length
(
)
;
i
+
+
)
{
TableUpdate
*
update
=
aUpdates
-
>
ElementAt
(
i
)
;
if
(
!
update
|
|
!
update
-
>
TableName
(
)
.
Equals
(
aTable
)
)
continue
;
if
(
update
-
>
Empty
(
)
)
{
aUpdates
-
>
ElementAt
(
i
)
=
nullptr
;
continue
;
}
validupdates
+
+
;
}
if
(
!
validupdates
)
{
return
false
;
}
return
true
;
}
nsCString
Classifier
:
:
GetProvider
(
const
nsACString
&
aTableName
)
{
nsCOMPtr
<
nsIUrlClassifierUtils
>
urlUtil
=
do_GetService
(
NS_URLCLASSIFIERUTILS_CONTRACTID
)
;
nsCString
provider
;
nsresult
rv
=
urlUtil
-
>
GetProvider
(
aTableName
provider
)
;
return
NS_SUCCEEDED
(
rv
)
?
provider
:
EmptyCString
(
)
;
}
nsresult
Classifier
:
:
UpdateHashStore
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
const
nsACString
&
aTable
)
{
if
(
nsUrlClassifierDBService
:
:
ShutdownHasStarted
(
)
)
{
return
NS_ERROR_ABORT
;
}
LOG
(
(
"
Classifier
:
:
UpdateHashStore
(
%
s
)
"
PromiseFlatCString
(
aTable
)
.
get
(
)
)
)
;
HashStore
store
(
aTable
GetProvider
(
aTable
)
mUpdatingDirectory
)
;
if
(
!
CheckValidUpdate
(
aUpdates
store
.
TableName
(
)
)
)
{
return
NS_OK
;
}
nsresult
rv
=
store
.
Open
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
store
.
BeginUpdate
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LookupCacheV2
*
lookupCache
=
LookupCache
:
:
Cast
<
LookupCacheV2
>
(
GetLookupCacheForUpdate
(
store
.
TableName
(
)
)
)
;
if
(
!
lookupCache
)
{
return
NS_ERROR_FAILURE
;
}
lookupCache
-
>
ClearCache
(
)
;
FallibleTArray
<
uint32_t
>
AddPrefixHashes
;
rv
=
lookupCache
-
>
GetPrefixes
(
AddPrefixHashes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
store
.
AugmentAdds
(
AddPrefixHashes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AddPrefixHashes
.
Clear
(
)
;
uint32_t
applied
=
0
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
-
>
Length
(
)
;
i
+
+
)
{
TableUpdate
*
update
=
aUpdates
-
>
ElementAt
(
i
)
;
if
(
!
update
|
|
!
update
-
>
TableName
(
)
.
Equals
(
store
.
TableName
(
)
)
)
continue
;
rv
=
store
.
ApplyUpdate
(
*
update
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
applied
+
+
;
auto
updateV2
=
TableUpdate
:
:
Cast
<
TableUpdateV2
>
(
update
)
;
if
(
updateV2
)
{
LOG
(
(
"
Applied
update
to
table
%
s
:
"
store
.
TableName
(
)
.
get
(
)
)
)
;
LOG
(
(
"
%
d
add
chunks
"
updateV2
-
>
AddChunks
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
"
PRIuSIZE
"
add
prefixes
"
updateV2
-
>
AddPrefixes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
"
PRIuSIZE
"
add
completions
"
updateV2
-
>
AddCompletes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
d
sub
chunks
"
updateV2
-
>
SubChunks
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
"
PRIuSIZE
"
sub
prefixes
"
updateV2
-
>
SubPrefixes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
"
PRIuSIZE
"
sub
completions
"
updateV2
-
>
SubCompletes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
d
add
expirations
"
updateV2
-
>
AddExpirations
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
d
sub
expirations
"
updateV2
-
>
SubExpirations
(
)
.
Length
(
)
)
)
;
}
aUpdates
-
>
ElementAt
(
i
)
=
nullptr
;
}
LOG
(
(
"
Applied
%
d
update
(
s
)
to
%
s
.
"
applied
store
.
TableName
(
)
.
get
(
)
)
)
;
rv
=
store
.
Rebuild
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOG
(
(
"
Table
%
s
now
has
:
"
store
.
TableName
(
)
.
get
(
)
)
)
;
LOG
(
(
"
%
d
add
chunks
"
store
.
AddChunks
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
"
PRIuSIZE
"
add
prefixes
"
store
.
AddPrefixes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
"
PRIuSIZE
"
add
completions
"
store
.
AddCompletes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
d
sub
chunks
"
store
.
SubChunks
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
"
PRIuSIZE
"
sub
prefixes
"
store
.
SubPrefixes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
"
PRIuSIZE
"
sub
completions
"
store
.
SubCompletes
(
)
.
Length
(
)
)
)
;
rv
=
store
.
WriteFile
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
lookupCache
-
>
Build
(
store
.
AddPrefixes
(
)
store
.
AddCompletes
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
#
if
defined
(
DEBUG
)
lookupCache
-
>
DumpCompletions
(
)
;
#
endif
rv
=
lookupCache
-
>
WriteFile
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int64_t
now
=
(
PR_Now
(
)
/
PR_USEC_PER_SEC
)
;
LOG
(
(
"
Successfully
updated
%
s
"
store
.
TableName
(
)
.
get
(
)
)
)
;
mTableFreshness
.
Put
(
store
.
TableName
(
)
now
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
UpdateTableV4
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
const
nsACString
&
aTable
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
UpdateTableV4
must
be
called
on
the
classifier
worker
thread
.
"
)
;
if
(
nsUrlClassifierDBService
:
:
ShutdownHasStarted
(
)
)
{
return
NS_ERROR_ABORT
;
}
LOG
(
(
"
Classifier
:
:
UpdateTableV4
(
%
s
)
"
PromiseFlatCString
(
aTable
)
.
get
(
)
)
)
;
if
(
!
CheckValidUpdate
(
aUpdates
aTable
)
)
{
return
NS_OK
;
}
LookupCacheV4
*
lookupCache
=
LookupCache
:
:
Cast
<
LookupCacheV4
>
(
GetLookupCacheForUpdate
(
aTable
)
)
;
if
(
!
lookupCache
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
NS_OK
;
PrefixStringMap
prefixes1
prefixes2
;
PrefixStringMap
*
input
=
&
prefixes1
;
PrefixStringMap
*
output
=
&
prefixes2
;
TableUpdateV4
*
lastAppliedUpdate
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
-
>
Length
(
)
;
i
+
+
)
{
TableUpdate
*
update
=
aUpdates
-
>
ElementAt
(
i
)
;
if
(
!
update
|
|
!
update
-
>
TableName
(
)
.
Equals
(
aTable
)
)
{
continue
;
}
auto
updateV4
=
TableUpdate
:
:
Cast
<
TableUpdateV4
>
(
update
)
;
NS_ENSURE_TRUE
(
updateV4
NS_ERROR_FAILURE
)
;
if
(
updateV4
-
>
IsFullUpdate
(
)
)
{
input
-
>
Clear
(
)
;
output
-
>
Clear
(
)
;
rv
=
lookupCache
-
>
ApplyUpdate
(
updateV4
*
input
*
output
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
{
if
(
prefixes1
.
IsEmpty
(
)
&
&
prefixes2
.
IsEmpty
(
)
)
{
lookupCache
-
>
GetPrefixes
(
prefixes1
)
;
}
else
{
MOZ_ASSERT
(
prefixes1
.
IsEmpty
(
)
^
prefixes2
.
IsEmpty
(
)
)
;
input
=
prefixes1
.
IsEmpty
(
)
?
&
prefixes2
:
&
prefixes1
;
output
=
prefixes1
.
IsEmpty
(
)
?
&
prefixes1
:
&
prefixes2
;
}
rv
=
lookupCache
-
>
ApplyUpdate
(
updateV4
*
input
*
output
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
input
-
>
Clear
(
)
;
}
lastAppliedUpdate
=
updateV4
;
aUpdates
-
>
ElementAt
(
i
)
=
nullptr
;
}
rv
=
lookupCache
-
>
Build
(
*
output
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
lookupCache
-
>
WriteFile
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
lastAppliedUpdate
)
{
LOG
(
(
"
Write
meta
data
of
the
last
applied
update
.
"
)
)
;
rv
=
lookupCache
-
>
WriteMetadata
(
lastAppliedUpdate
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
int64_t
now
=
(
PR_Now
(
)
/
PR_USEC_PER_SEC
)
;
LOG
(
(
"
Successfully
updated
%
s
\
n
"
PromiseFlatCString
(
aTable
)
.
get
(
)
)
)
;
mTableFreshness
.
Put
(
aTable
now
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
UpdateCache
(
TableUpdate
*
aUpdate
)
{
if
(
!
aUpdate
)
{
return
NS_OK
;
}
nsAutoCString
table
(
aUpdate
-
>
TableName
(
)
)
;
LOG
(
(
"
Classifier
:
:
UpdateCache
(
%
s
)
"
table
.
get
(
)
)
)
;
LookupCache
*
lookupCache
=
GetLookupCache
(
table
)
;
if
(
!
lookupCache
)
{
return
NS_ERROR_FAILURE
;
}
auto
updateV2
=
TableUpdate
:
:
Cast
<
TableUpdateV2
>
(
aUpdate
)
;
lookupCache
-
>
AddCompletionsToCache
(
updateV2
-
>
AddCompletes
(
)
)
;
#
if
defined
(
DEBUG
)
lookupCache
-
>
DumpCache
(
)
;
#
endif
return
NS_OK
;
}
LookupCache
*
Classifier
:
:
GetLookupCache
(
const
nsACString
&
aTable
bool
aForUpdate
)
{
if
(
aForUpdate
)
{
return
GetLookupCacheFrom
(
aTable
mNewLookupCaches
mUpdatingDirectory
)
;
}
return
GetLookupCacheFrom
(
aTable
mLookupCaches
mRootStoreDirectory
)
;
}
LookupCache
*
Classifier
:
:
GetLookupCacheFrom
(
const
nsACString
&
aTable
nsTArray
<
LookupCache
*
>
&
aLookupCaches
nsIFile
*
aRootStoreDirectory
)
{
for
(
uint32_t
i
=
0
;
i
<
aLookupCaches
.
Length
(
)
;
i
+
+
)
{
if
(
aLookupCaches
[
i
]
-
>
TableName
(
)
.
Equals
(
aTable
)
)
{
return
aLookupCaches
[
i
]
;
}
}
UniquePtr
<
LookupCache
>
cache
;
nsCString
provider
=
GetProvider
(
aTable
)
;
if
(
StringEndsWith
(
aTable
NS_LITERAL_CSTRING
(
"
-
proto
"
)
)
)
{
cache
=
MakeUnique
<
LookupCacheV4
>
(
aTable
provider
aRootStoreDirectory
)
;
}
else
{
cache
=
MakeUnique
<
LookupCacheV2
>
(
aTable
provider
aRootStoreDirectory
)
;
}
nsresult
rv
=
cache
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
rv
=
cache
-
>
Open
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_FILE_CORRUPTED
)
{
Reset
(
)
;
}
return
nullptr
;
}
aLookupCaches
.
AppendElement
(
cache
.
get
(
)
)
;
return
cache
.
release
(
)
;
}
nsresult
Classifier
:
:
ReadNoiseEntries
(
const
Prefix
&
aPrefix
const
nsACString
&
aTableName
uint32_t
aCount
PrefixArray
*
aNoiseEntries
)
{
LookupCacheV2
*
cache
=
LookupCache
:
:
Cast
<
LookupCacheV2
>
(
GetLookupCache
(
aTableName
)
)
;
if
(
!
cache
)
{
return
NS_ERROR_FAILURE
;
}
FallibleTArray
<
uint32_t
>
prefixes
;
nsresult
rv
=
cache
-
>
GetPrefixes
(
prefixes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
size_t
idx
=
prefixes
.
BinaryIndexOf
(
aPrefix
.
ToUint32
(
)
)
;
if
(
idx
=
=
nsTArray
<
uint32_t
>
:
:
NoIndex
)
{
NS_WARNING
(
"
Could
not
find
prefix
in
PrefixSet
during
noise
lookup
"
)
;
return
NS_ERROR_FAILURE
;
}
idx
-
=
idx
%
aCount
;
for
(
size_t
i
=
0
;
(
i
<
aCount
)
&
&
(
(
idx
+
i
)
<
prefixes
.
Length
(
)
)
;
i
+
+
)
{
Prefix
newPref
;
newPref
.
FromUint32
(
prefixes
[
idx
+
i
]
)
;
if
(
newPref
!
=
aPrefix
)
{
aNoiseEntries
-
>
AppendElement
(
newPref
)
;
}
}
return
NS_OK
;
}
nsresult
Classifier
:
:
LoadMetadata
(
nsIFile
*
aDirectory
nsACString
&
aResult
)
{
nsCOMPtr
<
nsISimpleEnumerator
>
entries
;
nsresult
rv
=
aDirectory
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_ARG_POINTER
(
entries
)
;
bool
hasMore
;
while
(
NS_SUCCEEDED
(
rv
=
entries
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
supports
;
rv
=
entries
-
>
GetNext
(
getter_AddRefs
(
supports
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
file
=
do_QueryInterface
(
supports
)
;
bool
isDirectory
;
if
(
NS_FAILED
(
file
-
>
IsDirectory
(
&
isDirectory
)
)
)
{
continue
;
}
if
(
isDirectory
)
{
LoadMetadata
(
file
aResult
)
;
continue
;
}
nsCString
tableName
;
rv
=
file
-
>
GetNativeLeafName
(
tableName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
dot
=
tableName
.
RFind
(
METADATA_SUFFIX
0
)
;
if
(
dot
=
=
-
1
)
{
continue
;
}
tableName
.
Cut
(
dot
METADATA_SUFFIX
.
Length
(
)
)
;
LookupCacheV4
*
lookupCache
=
LookupCache
:
:
Cast
<
LookupCacheV4
>
(
GetLookupCache
(
tableName
)
)
;
if
(
!
lookupCache
)
{
continue
;
}
nsCString
state
;
nsCString
checksum
;
rv
=
lookupCache
-
>
LoadMetadata
(
state
checksum
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
get
metadata
for
table
%
s
"
tableName
.
get
(
)
)
)
;
continue
;
}
nsAutoCString
stateBase64
;
rv
=
Base64Encode
(
state
stateBase64
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
checksumBase64
;
rv
=
Base64Encode
(
checksum
checksumBase64
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOG
(
(
"
Appending
state
'
%
s
'
and
checksum
'
%
s
'
for
table
%
s
"
stateBase64
.
get
(
)
checksumBase64
.
get
(
)
tableName
.
get
(
)
)
)
;
aResult
.
AppendPrintf
(
"
%
s
;
%
s
:
%
s
\
n
"
tableName
.
get
(
)
stateBase64
.
get
(
)
checksumBase64
.
get
(
)
)
;
}
return
rv
;
}
}
}
