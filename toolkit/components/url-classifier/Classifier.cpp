#
include
"
Classifier
.
h
"
#
include
"
LookupCacheV4
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
LazyIdleThread
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsUrlClassifierDBService
.
h
"
#
include
"
nsUrlClassifierUtils
.
h
"
extern
mozilla
:
:
LazyLogModule
gUrlClassifierDbServiceLog
;
#
define
LOG
(
args
)
\
MOZ_LOG
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
\
MOZ_LOG_TEST
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
)
#
define
STORE_DIRECTORY
"
safebrowsing
"
_ns
#
define
TO_DELETE_DIR_SUFFIX
"
-
to_delete
"
_ns
#
define
BACKUP_DIR_SUFFIX
"
-
backup
"
_ns
#
define
UPDATING_DIR_SUFFIX
"
-
updating
"
_ns
#
define
V4_METADATA_SUFFIX
"
.
metadata
"
_ns
#
define
V2_METADATA_SUFFIX
"
.
sbstore
"
_ns
#
define
DEFAULT_THREAD_TIMEOUT_MS
5000
namespace
mozilla
{
namespace
safebrowsing
{
bool
Classifier
:
:
OnUpdateThread
(
)
const
{
bool
onthread
=
false
;
if
(
mUpdateThread
)
{
mUpdateThread
-
>
IsOnCurrentThread
(
&
onthread
)
;
}
return
onthread
;
}
void
Classifier
:
:
SplitTables
(
const
nsACString
&
str
nsTArray
<
nsCString
>
&
tables
)
{
tables
.
Clear
(
)
;
nsACString
:
:
const_iterator
begin
iter
end
;
str
.
BeginReading
(
begin
)
;
str
.
EndReading
(
end
)
;
while
(
begin
!
=
end
)
{
iter
=
begin
;
FindCharInReadable
(
'
'
iter
end
)
;
nsDependentCSubstring
table
=
Substring
(
begin
iter
)
;
if
(
!
table
.
IsEmpty
(
)
)
{
tables
.
AppendElement
(
Substring
(
begin
iter
)
)
;
}
begin
=
iter
;
if
(
begin
!
=
end
)
{
begin
+
+
;
}
}
tables
.
Sort
(
)
;
const
auto
newEnd
=
std
:
:
unique
(
tables
.
begin
(
)
tables
.
end
(
)
)
;
tables
.
TruncateLength
(
std
:
:
distance
(
tables
.
begin
(
)
newEnd
)
)
;
}
nsresult
Classifier
:
:
GetPrivateStoreDirectory
(
nsIFile
*
aRootStoreDirectory
const
nsACString
&
aTableName
const
nsACString
&
aProvider
nsIFile
*
*
aPrivateStoreDirectory
)
{
NS_ENSURE_ARG_POINTER
(
aPrivateStoreDirectory
)
;
if
(
!
StringEndsWith
(
aTableName
"
-
proto
"
_ns
)
)
{
nsCOMPtr
<
nsIFile
>
(
aRootStoreDirectory
)
.
forget
(
aPrivateStoreDirectory
)
;
return
NS_OK
;
}
if
(
aProvider
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIFile
>
(
aRootStoreDirectory
)
.
forget
(
aPrivateStoreDirectory
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
providerDirectory
;
nsresult
rv
=
aRootStoreDirectory
-
>
Clone
(
getter_AddRefs
(
providerDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
providerDirectory
-
>
AppendNative
(
aProvider
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
dirExists
;
rv
=
providerDirectory
-
>
Exists
(
&
dirExists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
dirExists
)
{
LOG
(
(
"
Creating
private
directory
for
%
s
"
nsCString
(
aTableName
)
.
get
(
)
)
)
;
rv
=
providerDirectory
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
providerDirectory
.
forget
(
aPrivateStoreDirectory
)
;
return
rv
;
}
bool
isDir
;
rv
=
providerDirectory
-
>
IsDirectory
(
&
isDir
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isDir
)
{
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
providerDirectory
.
forget
(
aPrivateStoreDirectory
)
;
return
NS_OK
;
}
Classifier
:
:
Classifier
(
)
:
mIsTableRequestResultOutdated
(
true
)
mUpdateInterrupted
(
true
)
mIsClosed
(
false
)
{
mUpdateThread
=
new
LazyIdleThread
(
DEFAULT_THREAD_TIMEOUT_MS
"
Classifier
Update
"
_ns
LazyIdleThread
:
:
ShutdownMethod
:
:
ManualShutdown
)
;
}
Classifier
:
:
~
Classifier
(
)
{
if
(
mUpdateThread
)
{
mUpdateThread
-
>
Shutdown
(
)
;
mUpdateThread
=
nullptr
;
}
Close
(
)
;
}
nsresult
Classifier
:
:
SetupPathNames
(
)
{
nsresult
rv
=
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
mRootStoreDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mRootStoreDirectory
-
>
AppendNative
(
STORE_DIRECTORY
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
mLookupCaches
.
Length
(
)
;
i
+
+
)
{
mLookupCaches
[
i
]
-
>
UpdateRootDirHandle
(
mRootStoreDirectory
)
;
}
rv
=
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
mBackupDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mBackupDirectory
-
>
AppendNative
(
STORE_DIRECTORY
+
BACKUP_DIR_SUFFIX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
mUpdatingDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mUpdatingDirectory
-
>
AppendNative
(
STORE_DIRECTORY
+
UPDATING_DIR_SUFFIX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
mToDeleteDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mToDeleteDirectory
-
>
AppendNative
(
STORE_DIRECTORY
+
TO_DELETE_DIR_SUFFIX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
CreateStoreDirectory
(
)
{
if
(
ShouldAbort
(
)
)
{
return
NS_OK
;
}
bool
storeExists
;
nsresult
rv
=
mRootStoreDirectory
-
>
Exists
(
&
storeExists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
storeExists
)
{
rv
=
mRootStoreDirectory
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
bool
storeIsDir
;
rv
=
mRootStoreDirectory
-
>
IsDirectory
(
&
storeIsDir
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
storeIsDir
)
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
return
NS_OK
;
}
nsresult
Classifier
:
:
ClearLegacyFiles
(
)
{
if
(
ShouldAbort
(
)
)
{
return
NS_OK
;
}
nsTArray
<
nsLiteralCString
>
tables
=
{
"
test
-
phish
-
simple
"
_ns
"
test
-
malware
-
simple
"
_ns
"
test
-
unwanted
-
simple
"
_ns
"
test
-
harmful
-
simple
"
_ns
"
test
-
track
-
simple
"
_ns
"
test
-
trackwhite
-
simple
"
_ns
"
test
-
block
-
simple
"
_ns
}
;
const
auto
fnFindAndRemove
=
[
]
(
nsIFile
*
aRootDirectory
const
nsACString
&
aFileName
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
aRootDirectory
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
rv
=
file
-
>
AppendNative
(
aFileName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
bool
exists
;
rv
=
file
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
exists
)
{
return
false
;
}
rv
=
file
-
>
Remove
(
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
return
true
;
}
;
for
(
const
auto
&
table
:
tables
)
{
if
(
fnFindAndRemove
(
mRootStoreDirectory
table
+
"
.
sbstore
"
_ns
)
)
{
fnFindAndRemove
(
mRootStoreDirectory
table
+
"
.
vlpset
"
_ns
)
;
}
}
return
NS_OK
;
}
nsresult
Classifier
:
:
Open
(
nsIFile
&
aCacheDirectory
)
{
nsresult
rv
=
aCacheDirectory
.
Clone
(
getter_AddRefs
(
mCacheDirectory
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetupPathNames
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CleanToDelete
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mUpdatingDirectory
-
>
Remove
(
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
We
may
have
hit
a
crash
in
the
previous
update
.
"
)
)
;
}
rv
=
RecoverBackups
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CreateStoreDirectory
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ClearLegacyFiles
(
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
RegenActiveTables
(
)
;
return
NS_OK
;
}
void
Classifier
:
:
Close
(
)
{
mIsClosed
=
true
;
DropStores
(
)
;
}
void
Classifier
:
:
Reset
(
)
{
MOZ_ASSERT
(
!
OnUpdateThread
(
)
"
Reset
(
)
MUST
NOT
be
called
on
update
thread
"
)
;
LOG
(
(
"
Reset
(
)
is
called
so
we
interrupt
the
update
.
"
)
)
;
mUpdateInterrupted
=
true
;
auto
resetFunc
=
[
&
]
{
if
(
this
-
>
mIsClosed
)
{
return
;
}
this
-
>
DropStores
(
)
;
this
-
>
mRootStoreDirectory
-
>
Remove
(
true
)
;
this
-
>
mBackupDirectory
-
>
Remove
(
true
)
;
this
-
>
mUpdatingDirectory
-
>
Remove
(
true
)
;
this
-
>
mToDeleteDirectory
-
>
Remove
(
true
)
;
this
-
>
CreateStoreDirectory
(
)
;
this
-
>
RegenActiveTables
(
)
;
}
;
if
(
!
mUpdateThread
)
{
LOG
(
(
"
Async
update
has
been
disabled
.
Just
Reset
(
)
on
worker
thread
.
"
)
)
;
resetFunc
(
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
safebrowsing
:
:
Classifier
:
:
Reset
"
resetFunc
)
;
SyncRunnable
:
:
DispatchToThread
(
mUpdateThread
r
)
;
}
void
Classifier
:
:
ResetTables
(
ClearType
aType
const
nsTArray
<
nsCString
>
&
aTables
)
{
for
(
uint32_t
i
=
0
;
i
<
aTables
.
Length
(
)
;
i
+
+
)
{
LOG
(
(
"
Resetting
table
:
%
s
"
aTables
[
i
]
.
get
(
)
)
)
;
RefPtr
<
LookupCache
>
cache
=
GetLookupCache
(
aTables
[
i
]
)
;
if
(
cache
)
{
if
(
aType
=
=
Clear_Cache
)
{
cache
-
>
ClearCache
(
)
;
}
else
{
cache
-
>
ClearAll
(
)
;
}
}
}
if
(
aType
=
=
Clear_All
)
{
DeleteTables
(
mRootStoreDirectory
aTables
)
;
RegenActiveTables
(
)
;
}
}
void
Classifier
:
:
DeleteTables
(
nsIFile
*
aDirectory
const
nsTArray
<
nsCString
>
&
aTables
)
{
nsCOMPtr
<
nsIDirectoryEnumerator
>
entries
;
nsresult
rv
=
aDirectory
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsCOMPtr
<
nsIFile
>
file
;
while
(
NS_SUCCEEDED
(
rv
=
entries
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
)
&
&
file
)
{
bool
isDirectory
;
if
(
NS_FAILED
(
file
-
>
IsDirectory
(
&
isDirectory
)
)
)
{
continue
;
}
if
(
isDirectory
)
{
DeleteTables
(
file
aTables
)
;
continue
;
}
nsCString
leafName
;
rv
=
file
-
>
GetNativeLeafName
(
leafName
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
int32_t
dotPosition
=
leafName
.
RFind
(
"
.
"
)
;
if
(
dotPosition
>
=
0
)
{
leafName
.
Truncate
(
dotPosition
)
;
}
if
(
!
leafName
.
IsEmpty
(
)
&
&
aTables
.
Contains
(
leafName
)
)
{
if
(
NS_FAILED
(
file
-
>
Remove
(
false
)
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
Fail
to
remove
file
%
s
from
the
disk
"
leafName
.
get
(
)
)
.
get
(
)
)
;
}
}
}
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
void
Classifier
:
:
TableRequest
(
nsACString
&
aResult
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
TableRequest
must
be
called
on
the
classifier
worker
thread
.
"
)
;
if
(
!
mIsTableRequestResultOutdated
)
{
aResult
=
mTableRequestResult
;
return
;
}
nsTArray
<
nsCString
>
failedTables
;
nsCString
v2Metadata
;
nsresult
rv
=
LoadHashStore
(
mRootStoreDirectory
v2Metadata
failedTables
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aResult
.
Append
(
v2Metadata
)
;
}
nsCString
v4Metadata
;
rv
=
LoadMetadata
(
mRootStoreDirectory
v4Metadata
failedTables
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aResult
.
Append
(
v4Metadata
)
;
}
if
(
failedTables
.
Length
(
)
!
=
0
)
{
LOG
(
(
"
Reset
tables
failed
to
open
before
applying
an
update
"
)
)
;
ResetTables
(
Clear_All
failedTables
)
;
}
mTableRequestResult
=
aResult
;
mIsTableRequestResultOutdated
=
false
;
}
nsresult
Classifier
:
:
CheckURIFragments
(
const
nsTArray
<
nsCString
>
&
aSpecFragments
const
nsACString
&
aTable
LookupResultArray
&
aResults
)
{
MOZ_ASSERT
(
aSpecFragments
.
Length
(
)
!
=
0
)
;
MOZ_ASSERT
(
aSpecFragments
.
Length
(
)
<
=
(
MAX_HOST_COMPONENTS
*
(
MAX_PATH_COMPONENTS
+
2
)
)
)
;
if
(
LOG_ENABLED
(
)
)
{
uint32_t
urlIdx
=
0
;
for
(
uint32_t
i
=
1
;
i
<
aSpecFragments
.
Length
(
)
;
i
+
+
)
{
if
(
aSpecFragments
[
urlIdx
]
.
Length
(
)
<
aSpecFragments
[
i
]
.
Length
(
)
)
{
urlIdx
=
i
;
}
}
LOG
(
(
"
Checking
table
%
s
URL
is
%
s
"
aTable
.
BeginReading
(
)
aSpecFragments
[
urlIdx
]
.
get
(
)
)
)
;
}
RefPtr
<
LookupCache
>
cache
=
GetLookupCache
(
aTable
)
;
if
(
NS_WARN_IF
(
!
cache
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
uint32_t
i
=
0
;
i
<
aSpecFragments
.
Length
(
)
;
i
+
+
)
{
Completion
lookupHash
;
lookupHash
.
FromPlaintext
(
aSpecFragments
[
i
]
)
;
bool
has
confirmed
;
uint32_t
matchLength
;
nsresult
rv
=
cache
-
>
Has
(
lookupHash
&
has
&
matchLength
&
confirmed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
has
)
{
RefPtr
<
LookupResult
>
result
=
new
LookupResult
;
aResults
.
AppendElement
(
result
)
;
if
(
LOG_ENABLED
(
)
)
{
nsAutoCString
checking
;
lookupHash
.
ToHexString
(
checking
)
;
LOG
(
(
"
Found
a
result
in
fragment
%
s
hash
%
s
(
%
X
)
"
aSpecFragments
[
i
]
.
get
(
)
checking
.
get
(
)
lookupHash
.
ToUint32
(
)
)
)
;
LOG
(
(
"
Result
%
s
match
%
d
-
bytes
prefix
"
confirmed
?
"
confirmed
.
"
:
"
Not
confirmed
.
"
matchLength
)
)
;
}
result
-
>
hash
.
complete
=
lookupHash
;
result
-
>
mConfirmed
=
confirmed
;
result
-
>
mTableName
.
Assign
(
cache
-
>
TableName
(
)
)
;
result
-
>
mPartialHashLength
=
confirmed
?
COMPLETE_SIZE
:
matchLength
;
result
-
>
mProtocolV2
=
LookupCache
:
:
Cast
<
LookupCacheV2
>
(
cache
)
;
}
}
return
NS_OK
;
}
static
nsresult
SwapDirectoryContent
(
nsIFile
*
aDir1
nsIFile
*
aDir2
nsIFile
*
aParentDir
nsIFile
*
aTempDir
)
{
nsAutoCString
tempDirName
;
aTempDir
-
>
GetNativeLeafName
(
tempDirName
)
;
nsresult
rv
;
nsAutoCString
dirName1
dirName2
;
aDir1
-
>
GetNativeLeafName
(
dirName1
)
;
aDir2
-
>
GetNativeLeafName
(
dirName2
)
;
LOG
(
(
"
Swapping
directories
%
s
and
%
s
.
.
.
"
dirName1
.
get
(
)
dirName2
.
get
(
)
)
)
;
rv
=
aDir1
-
>
RenameToNative
(
nullptr
tempDirName
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Unable
to
rename
%
s
to
%
s
"
dirName1
.
get
(
)
tempDirName
.
get
(
)
)
)
;
return
rv
;
}
nsCOMPtr
<
nsIFile
>
tempDirectory
;
rv
=
aParentDir
-
>
Clone
(
getter_AddRefs
(
tempDirectory
)
)
;
rv
=
tempDirectory
-
>
AppendNative
(
tempDirName
)
;
rv
=
aDir2
-
>
RenameToNative
(
nullptr
dirName1
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
rename
%
s
to
%
s
.
Rename
temp
directory
back
to
%
s
"
dirName2
.
get
(
)
dirName1
.
get
(
)
dirName1
.
get
(
)
)
)
;
nsresult
rbrv
=
tempDirectory
-
>
RenameToNative
(
nullptr
dirName1
)
;
NS_ENSURE_SUCCESS
(
rbrv
rbrv
)
;
return
rv
;
}
rv
=
tempDirectory
-
>
RenameToNative
(
nullptr
dirName2
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
rename
temp
directory
to
%
s
.
"
dirName2
.
get
(
)
)
)
;
nsresult
rbrv
;
rbrv
=
aDir1
-
>
RenameToNative
(
nullptr
dirName2
)
;
NS_ENSURE_SUCCESS
(
rbrv
rbrv
)
;
rbrv
=
tempDirectory
-
>
RenameToNative
(
nullptr
dirName1
)
;
NS_ENSURE_SUCCESS
(
rbrv
rbrv
)
;
return
rv
;
}
return
rv
;
}
void
Classifier
:
:
RemoveUpdateIntermediaries
(
)
{
mNewLookupCaches
.
Clear
(
)
;
if
(
NS_FAILED
(
mUpdatingDirectory
-
>
Remove
(
true
)
)
)
{
LOG
(
(
"
Failed
to
remove
updating
directory
.
"
)
)
;
}
}
void
Classifier
:
:
CopyAndInvalidateFullHashCache
(
)
{
MOZ_ASSERT
(
!
OnUpdateThread
(
)
"
CopyAndInvalidateFullHashCache
cannot
be
called
on
update
thread
"
"
since
it
mutates
mLookupCaches
which
is
only
safe
on
"
"
worker
thread
.
"
)
;
for
(
auto
&
newCache
:
mNewLookupCaches
)
{
for
(
auto
&
oldCache
:
mLookupCaches
)
{
if
(
oldCache
-
>
TableName
(
)
=
=
newCache
-
>
TableName
(
)
)
{
newCache
-
>
CopyFullHashCache
(
oldCache
)
;
break
;
}
}
}
for
(
auto
&
newCache
:
mNewLookupCaches
)
{
newCache
-
>
InvalidateExpiredCacheEntries
(
)
;
}
}
void
Classifier
:
:
MergeNewLookupCaches
(
)
{
MOZ_ASSERT
(
!
OnUpdateThread
(
)
"
MergeNewLookupCaches
cannot
be
called
on
update
thread
"
"
since
it
mutates
mLookupCaches
which
is
only
safe
on
"
"
worker
thread
.
"
)
;
for
(
auto
&
newCache
:
mNewLookupCaches
)
{
size_t
swapIndex
=
0
;
for
(
;
swapIndex
<
mLookupCaches
.
Length
(
)
;
swapIndex
+
+
)
{
if
(
mLookupCaches
[
swapIndex
]
-
>
TableName
(
)
=
=
newCache
-
>
TableName
(
)
)
{
break
;
}
}
if
(
swapIndex
=
=
mLookupCaches
.
Length
(
)
)
{
mLookupCaches
.
AppendElement
(
nullptr
)
;
}
std
:
:
swap
(
mLookupCaches
[
swapIndex
]
newCache
)
;
mLookupCaches
[
swapIndex
]
-
>
UpdateRootDirHandle
(
mRootStoreDirectory
)
;
}
}
nsresult
Classifier
:
:
SwapInNewTablesAndCleanup
(
)
{
nsresult
rv
;
rv
=
SwapDirectoryContent
(
mUpdatingDirectory
mRootStoreDirectory
mCacheDirectory
mBackupDirectory
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
swap
in
on
-
disk
tables
.
"
)
)
;
RemoveUpdateIntermediaries
(
)
;
return
rv
;
}
MergeNewLookupCaches
(
)
;
rv
=
RegenActiveTables
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
re
-
generate
active
tables
!
"
)
)
;
}
RemoveUpdateIntermediaries
(
)
;
mIsTableRequestResultOutdated
=
true
;
LOG
(
(
"
Done
swap
in
updated
tables
.
"
)
)
;
return
rv
;
}
void
Classifier
:
:
FlushAndDisableAsyncUpdate
(
)
{
LOG
(
(
"
Classifier
:
:
FlushAndDisableAsyncUpdate
[
%
p
%
p
]
"
this
mUpdateThread
.
get
(
)
)
)
;
if
(
!
mUpdateThread
)
{
LOG
(
(
"
Async
update
has
been
disabled
.
"
)
)
;
return
;
}
mUpdateThread
-
>
Shutdown
(
)
;
mUpdateThread
=
nullptr
;
}
nsresult
Classifier
:
:
AsyncApplyUpdates
(
const
TableUpdateArray
&
aUpdates
const
AsyncUpdateCallback
&
aCallback
)
{
LOG
(
(
"
Classifier
:
:
AsyncApplyUpdates
"
)
)
;
if
(
!
mUpdateThread
)
{
LOG
(
(
"
Async
update
has
already
been
disabled
.
"
)
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
mNewLookupCaches
.
IsEmpty
(
)
"
There
should
be
no
leftovers
from
a
previous
update
.
"
)
;
mUpdateInterrupted
=
false
;
nsresult
rv
=
mRootStoreDirectory
-
>
Clone
(
getter_AddRefs
(
mRootStoreDirectoryForUpdate
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
clone
mRootStoreDirectory
for
update
.
"
)
)
;
return
rv
;
}
nsCOMPtr
<
nsIThread
>
callerThread
=
NS_GetCurrentThread
(
)
;
MOZ_ASSERT
(
!
OnUpdateThread
(
)
)
;
RefPtr
<
Classifier
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
bgRunnable
=
NS_NewRunnableFunction
(
"
safebrowsing
:
:
Classifier
:
:
AsyncApplyUpdates
"
[
self
aUpdates
=
aUpdates
.
Clone
(
)
aCallback
callerThread
]
(
)
mutable
{
MOZ_ASSERT
(
self
-
>
OnUpdateThread
(
)
"
MUST
be
on
update
thread
"
)
;
nsresult
bgRv
;
nsTArray
<
nsCString
>
failedTableNames
;
TableUpdateArray
updates
;
if
(
updates
.
AppendElements
(
std
:
:
move
(
aUpdates
)
fallible
)
)
{
LOG
(
(
"
Step
1
.
ApplyUpdatesBackground
on
update
thread
.
"
)
)
;
bgRv
=
self
-
>
ApplyUpdatesBackground
(
updates
failedTableNames
)
;
}
else
{
LOG
(
(
"
Step
1
.
Not
enough
memory
to
run
ApplyUpdatesBackground
on
"
"
update
thread
.
"
)
)
;
bgRv
=
NS_ERROR_OUT_OF_MEMORY
;
}
nsCOMPtr
<
nsIRunnable
>
fgRunnable
=
NS_NewRunnableFunction
(
"
safebrowsing
:
:
Classifier
:
:
AsyncApplyUpdates
"
[
self
=
std
:
:
move
(
self
)
aCallback
bgRv
failedTableNames
=
std
:
:
move
(
failedTableNames
)
callerThread
]
(
)
mutable
{
RefPtr
<
Classifier
>
classifier
=
std
:
:
move
(
self
)
;
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
callerThread
"
MUST
be
on
caller
thread
"
)
;
LOG
(
(
"
Step
2
.
ApplyUpdatesForeground
on
caller
thread
"
)
)
;
nsresult
rv
=
classifier
-
>
ApplyUpdatesForeground
(
bgRv
failedTableNames
)
;
LOG
(
(
"
Step
3
.
Updates
applied
!
Fire
callback
.
"
)
)
;
aCallback
(
rv
)
;
}
)
;
callerThread
-
>
Dispatch
(
fgRunnable
NS_DISPATCH_NORMAL
)
;
}
)
;
return
mUpdateThread
-
>
Dispatch
(
bgRunnable
NS_DISPATCH_NORMAL
)
;
}
nsresult
Classifier
:
:
ApplyUpdatesBackground
(
TableUpdateArray
&
aUpdates
nsTArray
<
nsCString
>
&
aFailedTableNames
)
{
if
(
aUpdates
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
nsUrlClassifierUtils
*
urlUtil
=
nsUrlClassifierUtils
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
!
urlUtil
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCString
provider
;
urlUtil
-
>
GetTelemetryProvider
(
aUpdates
[
0
]
-
>
TableName
(
)
provider
)
;
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
URLCLASSIFIER_CL_KEYED_UPDATE_TIME
>
keyedTimer
(
provider
)
;
PRIntervalTime
clockStart
=
0
;
if
(
LOG_ENABLED
(
)
)
{
clockStart
=
PR_IntervalNow
(
)
;
}
nsresult
rv
;
rv
=
CopyInUseDirForUpdate
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
copy
in
-
use
directory
for
update
.
"
)
)
;
return
(
rv
=
=
NS_ERROR_ABORT
)
?
NS_OK
:
rv
;
}
LOG
(
(
"
Applying
%
zu
table
updates
.
"
aUpdates
.
Length
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
const
TableUpdate
>
update
=
aUpdates
[
i
]
;
if
(
!
update
)
{
continue
;
}
nsAutoCString
updateTable
(
update
-
>
TableName
(
)
)
;
if
(
ShouldAbort
(
)
)
{
LOG
(
(
"
Update
is
interrupted
.
Stop
building
new
tables
.
"
)
)
;
return
NS_OK
;
}
if
(
TableUpdate
:
:
Cast
<
TableUpdateV2
>
(
update
)
)
{
rv
=
UpdateHashStore
(
aUpdates
updateTable
)
;
}
else
{
rv
=
UpdateTableV4
(
aUpdates
updateTable
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG
(
(
"
Failed
to
update
table
:
%
s
"
updateTable
.
get
(
)
)
)
;
aFailedTableNames
.
AppendElement
(
updateTable
)
;
continue
;
}
}
if
(
!
aFailedTableNames
.
IsEmpty
(
)
)
{
RemoveUpdateIntermediaries
(
)
;
return
NS_ERROR_FAILURE
;
}
if
(
LOG_ENABLED
(
)
)
{
PRIntervalTime
clockEnd
=
PR_IntervalNow
(
)
;
LOG
(
(
"
update
took
%
dms
\
n
"
PR_IntervalToMilliseconds
(
clockEnd
-
clockStart
)
)
)
;
}
return
rv
;
}
nsresult
Classifier
:
:
ApplyUpdatesForeground
(
nsresult
aBackgroundRv
const
nsTArray
<
nsCString
>
&
aFailedTableNames
)
{
if
(
ShouldAbort
(
)
)
{
LOG
(
(
"
Update
is
interrupted
!
Just
remove
update
intermediaries
.
"
)
)
;
RemoveUpdateIntermediaries
(
)
;
return
NS_OK
;
}
if
(
NS_SUCCEEDED
(
aBackgroundRv
)
)
{
CopyAndInvalidateFullHashCache
(
)
;
return
SwapInNewTablesAndCleanup
(
)
;
}
if
(
NS_ERROR_OUT_OF_MEMORY
!
=
aBackgroundRv
)
{
ResetTables
(
Clear_All
aFailedTableNames
)
;
}
return
aBackgroundRv
;
}
nsresult
Classifier
:
:
ApplyFullHashes
(
ConstTableUpdateArray
&
aUpdates
)
{
MOZ_ASSERT
(
!
OnUpdateThread
(
)
"
ApplyFullHashes
(
)
MUST
NOT
be
called
on
update
thread
"
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
ApplyFullHashes
(
)
must
be
called
on
the
classifier
worker
thread
.
"
)
;
LOG
(
(
"
Applying
%
zu
table
gethashes
.
"
aUpdates
.
Length
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
.
Length
(
)
;
i
+
+
)
{
nsresult
rv
=
UpdateCache
(
aUpdates
[
i
]
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aUpdates
[
i
]
=
nullptr
;
}
return
NS_OK
;
}
void
Classifier
:
:
GetCacheInfo
(
const
nsACString
&
aTable
nsIUrlClassifierCacheInfo
*
*
aCache
)
{
RefPtr
<
const
LookupCache
>
lookupCache
=
GetLookupCache
(
aTable
)
;
if
(
!
lookupCache
)
{
return
;
}
lookupCache
-
>
GetCacheInfo
(
aCache
)
;
}
void
Classifier
:
:
DropStores
(
)
{
mLookupCaches
.
Clear
(
)
;
}
nsresult
Classifier
:
:
RegenActiveTables
(
)
{
if
(
ShouldAbort
(
)
)
{
return
NS_OK
;
}
mActiveTablesCache
.
Clear
(
)
;
nsTArray
<
nsCString
>
exts
=
{
"
.
vlpset
"
_ns
"
.
pset
"
_ns
}
;
nsTArray
<
nsCString
>
foundTables
;
nsresult
rv
=
ScanStoreDir
(
mRootStoreDirectory
exts
foundTables
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
rv
=
AddMozEntries
(
foundTables
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
for
(
const
auto
&
table
:
foundTables
)
{
RefPtr
<
const
LookupCache
>
lookupCache
=
GetLookupCache
(
table
)
;
if
(
!
lookupCache
)
{
LOG
(
(
"
Inactive
table
(
no
cache
)
:
%
s
"
table
.
get
(
)
)
)
;
continue
;
}
if
(
!
lookupCache
-
>
IsPrimed
(
)
)
{
LOG
(
(
"
Inactive
table
(
cache
not
primed
)
:
%
s
"
table
.
get
(
)
)
)
;
continue
;
}
LOG
(
(
"
Active
%
s
table
:
%
s
"
LookupCache
:
:
Cast
<
const
LookupCacheV4
>
(
lookupCache
)
?
"
v4
"
:
"
v2
"
table
.
get
(
)
)
)
;
mActiveTablesCache
.
AppendElement
(
table
)
;
}
return
NS_OK
;
}
nsresult
Classifier
:
:
AddMozEntries
(
nsTArray
<
nsCString
>
&
aTables
)
{
nsTArray
<
nsLiteralCString
>
tables
=
{
"
moztest
-
phish
-
simple
"
_ns
"
moztest
-
malware
-
simple
"
_ns
"
moztest
-
unwanted
-
simple
"
_ns
"
moztest
-
harmful
-
simple
"
_ns
"
moztest
-
track
-
simple
"
_ns
"
moztest
-
trackwhite
-
simple
"
_ns
"
moztest
-
block
-
simple
"
_ns
}
;
for
(
const
auto
&
table
:
tables
)
{
RefPtr
<
LookupCache
>
c
=
GetLookupCache
(
table
false
)
;
RefPtr
<
LookupCacheV2
>
lookupCache
=
LookupCache
:
:
Cast
<
LookupCacheV2
>
(
c
)
;
if
(
!
lookupCache
|
|
lookupCache
-
>
IsPrimed
(
)
)
{
continue
;
}
aTables
.
AppendElement
(
table
)
;
}
return
NS_OK
;
}
nsresult
Classifier
:
:
ScanStoreDir
(
nsIFile
*
aDirectory
const
nsTArray
<
nsCString
>
&
aExtensions
nsTArray
<
nsCString
>
&
aTables
)
{
nsCOMPtr
<
nsIDirectoryEnumerator
>
entries
;
nsresult
rv
=
aDirectory
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
file
;
while
(
NS_SUCCEEDED
(
rv
=
entries
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
)
&
&
file
)
{
bool
isDirectory
;
if
(
NS_FAILED
(
file
-
>
IsDirectory
(
&
isDirectory
)
)
)
{
continue
;
}
if
(
isDirectory
)
{
ScanStoreDir
(
file
aExtensions
aTables
)
;
continue
;
}
nsAutoCString
leafName
;
rv
=
file
-
>
GetNativeLeafName
(
leafName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
const
auto
&
ext
:
aExtensions
)
{
if
(
StringEndsWith
(
leafName
ext
)
)
{
aTables
.
AppendElement
(
Substring
(
leafName
0
leafName
.
Length
(
)
-
strlen
(
ext
.
get
(
)
)
)
)
;
break
;
}
}
}
return
NS_OK
;
}
nsresult
Classifier
:
:
ActiveTables
(
nsTArray
<
nsCString
>
&
aTables
)
const
{
aTables
=
mActiveTablesCache
.
Clone
(
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
CleanToDelete
(
)
{
bool
exists
;
nsresult
rv
=
mToDeleteDirectory
-
>
Exists
(
&
exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
exists
)
{
rv
=
mToDeleteDirectory
-
>
Remove
(
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
#
ifdef
MOZ_SAFEBROWSING_DUMP_FAILED_UPDATES
already_AddRefed
<
nsIFile
>
Classifier
:
:
GetFailedUpdateDirectroy
(
)
{
nsCString
failedUpdatekDirName
=
STORE_DIRECTORY
+
nsCString
(
"
-
failedupdate
"
)
;
nsCOMPtr
<
nsIFile
>
failedUpdatekDirectory
;
if
(
NS_FAILED
(
mCacheDirectory
-
>
Clone
(
getter_AddRefs
(
failedUpdatekDirectory
)
)
)
|
|
NS_FAILED
(
failedUpdatekDirectory
-
>
AppendNative
(
failedUpdatekDirName
)
)
)
{
LOG
(
(
"
Failed
to
init
failedUpdatekDirectory
.
"
)
)
;
return
nullptr
;
}
return
failedUpdatekDirectory
.
forget
(
)
;
}
nsresult
Classifier
:
:
DumpRawTableUpdates
(
const
nsACString
&
aRawUpdates
)
{
LOG
(
(
"
Dumping
raw
table
updates
.
.
.
"
)
)
;
DumpFailedUpdate
(
)
;
nsCOMPtr
<
nsIFile
>
failedUpdatekDirectory
=
GetFailedUpdateDirectroy
(
)
;
nsCOMPtr
<
nsIFile
>
rawTableUpdatesFile
;
nsCOMPtr
<
nsIOutputStream
>
outputStream
;
if
(
NS_FAILED
(
failedUpdatekDirectory
-
>
Clone
(
getter_AddRefs
(
rawTableUpdatesFile
)
)
)
|
|
NS_FAILED
(
rawTableUpdatesFile
-
>
AppendNative
(
nsCString
(
"
tableupdates
.
bin
"
)
)
)
|
|
NS_FAILED
(
NS_NewLocalFileOutputStream
(
getter_AddRefs
(
outputStream
)
rawTableUpdatesFile
PR_WRONLY
|
PR_TRUNCATE
|
PR_CREATE_FILE
)
)
)
{
LOG
(
(
"
Failed
to
create
file
to
dump
raw
table
updates
.
"
)
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
written
;
nsresult
rv
=
outputStream
-
>
Write
(
aRawUpdates
.
BeginReading
(
)
aRawUpdates
.
Length
(
)
&
written
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
written
=
=
aRawUpdates
.
Length
(
)
NS_ERROR_FAILURE
)
;
return
rv
;
}
nsresult
Classifier
:
:
DumpFailedUpdate
(
)
{
LOG
(
(
"
Dumping
failed
update
.
.
.
"
)
)
;
nsCOMPtr
<
nsIFile
>
failedUpdatekDirectory
=
GetFailedUpdateDirectroy
(
)
;
failedUpdatekDirectory
-
>
Remove
(
true
)
;
nsCString
failedUpdatekDirName
;
nsresult
rv
=
failedUpdatekDirectory
-
>
GetNativeLeafName
(
failedUpdatekDirName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
inUseDirectory
;
if
(
NS_FAILED
(
mRootStoreDirectory
-
>
Clone
(
getter_AddRefs
(
inUseDirectory
)
)
)
|
|
NS_FAILED
(
inUseDirectory
-
>
CopyToNative
(
nullptr
failedUpdatekDirName
)
)
)
{
LOG
(
(
"
Failed
to
move
in
-
use
to
the
\
"
failed
update
\
"
directory
%
s
"
failedUpdatekDirName
.
get
(
)
)
)
;
return
NS_ERROR_FAILURE
;
}
return
rv
;
}
#
endif
nsresult
Classifier
:
:
CopyDirectoryInterruptible
(
nsCOMPtr
<
nsIFile
>
&
aDestDir
nsCOMPtr
<
nsIFile
>
&
aSourceDir
)
{
nsCOMPtr
<
nsIDirectoryEnumerator
>
entries
;
nsresult
rv
=
aSourceDir
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
entries
)
;
nsCOMPtr
<
nsIFile
>
source
;
while
(
NS_SUCCEEDED
(
rv
=
entries
-
>
GetNextFile
(
getter_AddRefs
(
source
)
)
)
&
&
source
)
{
if
(
ShouldAbort
(
)
)
{
LOG
(
(
"
Update
is
interrupted
.
Aborting
the
directory
copy
"
)
)
;
return
NS_ERROR_ABORT
;
}
bool
isDirectory
;
rv
=
source
-
>
IsDirectory
(
&
isDirectory
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
isDirectory
)
{
nsAutoCString
leaf
;
source
-
>
GetNativeLeafName
(
leaf
)
;
MOZ_ASSERT
(
!
leaf
.
IsEmpty
(
)
)
;
nsCOMPtr
<
nsIFile
>
dest
;
aDestDir
-
>
Clone
(
getter_AddRefs
(
dest
)
)
;
dest
-
>
AppendNative
(
leaf
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CopyDirectoryInterruptible
(
dest
source
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
source
-
>
CopyToNative
(
aDestDir
EmptyCString
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
bool
exist
;
rv
=
aDestDir
-
>
Exists
(
&
exist
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
exist
)
{
rv
=
aDestDir
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
Classifier
:
:
CopyInUseDirForUpdate
(
)
{
LOG
(
(
"
Copy
in
-
use
directory
content
for
update
.
"
)
)
;
if
(
ShouldAbort
(
)
)
{
return
NS_ERROR_UC_UPDATE_SHUTDOWNING
;
}
mUpdatingDirectory
-
>
Remove
(
true
)
;
if
(
!
mRootStoreDirectoryForUpdate
)
{
LOG
(
(
"
mRootStoreDirectoryForUpdate
is
null
.
"
)
)
;
return
NS_ERROR_NULL_POINTER
;
}
nsresult
rv
=
CopyDirectoryInterruptible
(
mUpdatingDirectory
mRootStoreDirectoryForUpdate
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
RecoverBackups
(
)
{
bool
backupExists
;
nsresult
rv
=
mBackupDirectory
-
>
Exists
(
&
backupExists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
backupExists
)
{
nsCString
storeDirName
;
rv
=
mRootStoreDirectory
-
>
GetNativeLeafName
(
storeDirName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
storeExists
;
rv
=
mRootStoreDirectory
-
>
Exists
(
&
storeExists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
storeExists
)
{
rv
=
mRootStoreDirectory
-
>
Remove
(
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
mBackupDirectory
-
>
MoveToNative
(
nullptr
storeDirName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetupPathNames
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
bool
Classifier
:
:
CheckValidUpdate
(
TableUpdateArray
&
aUpdates
const
nsACString
&
aTable
)
{
uint32_t
validupdates
=
0
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
const
TableUpdate
>
update
=
aUpdates
[
i
]
;
if
(
!
update
|
|
!
update
-
>
TableName
(
)
.
Equals
(
aTable
)
)
{
continue
;
}
if
(
update
-
>
Empty
(
)
)
{
aUpdates
[
i
]
=
nullptr
;
continue
;
}
validupdates
+
+
;
}
if
(
!
validupdates
)
{
return
false
;
}
return
true
;
}
nsCString
Classifier
:
:
GetProvider
(
const
nsACString
&
aTableName
)
{
nsUrlClassifierUtils
*
urlUtil
=
nsUrlClassifierUtils
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
!
urlUtil
)
)
{
return
EmptyCString
(
)
;
}
nsCString
provider
;
nsresult
rv
=
urlUtil
-
>
GetProvider
(
aTableName
provider
)
;
return
NS_SUCCEEDED
(
rv
)
?
provider
:
EmptyCString
(
)
;
}
nsresult
Classifier
:
:
UpdateHashStore
(
TableUpdateArray
&
aUpdates
const
nsACString
&
aTable
)
{
if
(
ShouldAbort
(
)
)
{
return
NS_ERROR_UC_UPDATE_SHUTDOWNING
;
}
LOG
(
(
"
Classifier
:
:
UpdateHashStore
(
%
s
)
"
PromiseFlatCString
(
aTable
)
.
get
(
)
)
)
;
MOZ_ASSERT
(
!
nsUrlClassifierUtils
:
:
IsMozTestTable
(
aTable
)
)
;
HashStore
store
(
aTable
GetProvider
(
aTable
)
mUpdatingDirectory
)
;
if
(
!
CheckValidUpdate
(
aUpdates
store
.
TableName
(
)
)
)
{
return
NS_OK
;
}
nsresult
rv
=
store
.
Open
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
store
.
BeginUpdate
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
LookupCacheV2
>
lookupCacheV2
;
{
RefPtr
<
LookupCache
>
lookupCache
=
GetLookupCacheForUpdate
(
store
.
TableName
(
)
)
;
if
(
lookupCache
)
{
lookupCacheV2
=
LookupCache
:
:
Cast
<
LookupCacheV2
>
(
lookupCache
)
;
}
}
if
(
!
lookupCacheV2
)
{
return
NS_ERROR_UC_UPDATE_TABLE_NOT_FOUND
;
}
FallibleTArray
<
uint32_t
>
AddPrefixHashes
;
FallibleTArray
<
nsCString
>
AddCompletesHashes
;
rv
=
lookupCacheV2
-
>
GetPrefixes
(
AddPrefixHashes
AddCompletesHashes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
store
.
AugmentAdds
(
AddPrefixHashes
AddCompletesHashes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AddPrefixHashes
.
Clear
(
)
;
AddCompletesHashes
.
Clear
(
)
;
uint32_t
applied
=
0
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
TableUpdate
>
update
=
aUpdates
[
i
]
;
if
(
!
update
|
|
!
update
-
>
TableName
(
)
.
Equals
(
store
.
TableName
(
)
)
)
{
continue
;
}
RefPtr
<
TableUpdateV2
>
updateV2
=
TableUpdate
:
:
Cast
<
TableUpdateV2
>
(
update
)
;
NS_ENSURE_TRUE
(
updateV2
NS_ERROR_UC_UPDATE_UNEXPECTED_VERSION
)
;
rv
=
store
.
ApplyUpdate
(
updateV2
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
applied
+
+
;
LOG
(
(
"
Applied
update
to
table
%
s
:
"
store
.
TableName
(
)
.
get
(
)
)
)
;
LOG
(
(
"
%
d
add
chunks
"
updateV2
-
>
AddChunks
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
add
prefixes
"
updateV2
-
>
AddPrefixes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
add
completions
"
updateV2
-
>
AddCompletes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
d
sub
chunks
"
updateV2
-
>
SubChunks
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
sub
prefixes
"
updateV2
-
>
SubPrefixes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
sub
completions
"
updateV2
-
>
SubCompletes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
d
add
expirations
"
updateV2
-
>
AddExpirations
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
d
sub
expirations
"
updateV2
-
>
SubExpirations
(
)
.
Length
(
)
)
)
;
aUpdates
[
i
]
=
nullptr
;
}
LOG
(
(
"
Applied
%
d
update
(
s
)
to
%
s
.
"
applied
store
.
TableName
(
)
.
get
(
)
)
)
;
rv
=
store
.
Rebuild
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOG
(
(
"
Table
%
s
now
has
:
"
store
.
TableName
(
)
.
get
(
)
)
)
;
LOG
(
(
"
%
d
add
chunks
"
store
.
AddChunks
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
add
prefixes
"
store
.
AddPrefixes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
add
completions
"
store
.
AddCompletes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
d
sub
chunks
"
store
.
SubChunks
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
sub
prefixes
"
store
.
SubPrefixes
(
)
.
Length
(
)
)
)
;
LOG
(
(
"
%
zu
sub
completions
"
store
.
SubCompletes
(
)
.
Length
(
)
)
)
;
rv
=
store
.
WriteFile
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
lookupCacheV2
-
>
Build
(
store
.
AddPrefixes
(
)
store
.
AddCompletes
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_UC_UPDATE_BUILD_PREFIX_FAILURE
)
;
rv
=
lookupCacheV2
-
>
WriteFile
(
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_UC_UPDATE_FAIL_TO_WRITE_DISK
)
;
LOG
(
(
"
Successfully
updated
%
s
"
store
.
TableName
(
)
.
get
(
)
)
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
UpdateTableV4
(
TableUpdateArray
&
aUpdates
const
nsACString
&
aTable
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
UpdateTableV4
must
be
called
on
the
classifier
worker
thread
.
"
)
;
if
(
ShouldAbort
(
)
)
{
return
NS_ERROR_UC_UPDATE_SHUTDOWNING
;
}
MOZ_ASSERT
(
!
nsUrlClassifierUtils
:
:
IsMozTestTable
(
aTable
)
)
;
LOG
(
(
"
Classifier
:
:
UpdateTableV4
(
%
s
)
"
PromiseFlatCString
(
aTable
)
.
get
(
)
)
)
;
if
(
!
CheckValidUpdate
(
aUpdates
aTable
)
)
{
return
NS_OK
;
}
RefPtr
<
LookupCacheV4
>
lookupCacheV4
;
{
RefPtr
<
LookupCache
>
lookupCache
=
GetLookupCacheForUpdate
(
aTable
)
;
if
(
lookupCache
)
{
lookupCacheV4
=
LookupCache
:
:
Cast
<
LookupCacheV4
>
(
lookupCache
)
;
}
}
if
(
!
lookupCacheV4
)
{
return
NS_ERROR_UC_UPDATE_TABLE_NOT_FOUND
;
}
nsresult
rv
=
NS_OK
;
PrefixStringMap
prefixes1
prefixes2
;
PrefixStringMap
*
input
=
&
prefixes1
;
PrefixStringMap
*
output
=
&
prefixes2
;
RefPtr
<
const
TableUpdateV4
>
lastAppliedUpdate
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
aUpdates
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
TableUpdate
>
update
=
aUpdates
[
i
]
;
if
(
!
update
|
|
!
update
-
>
TableName
(
)
.
Equals
(
aTable
)
)
{
continue
;
}
RefPtr
<
TableUpdateV4
>
updateV4
=
TableUpdate
:
:
Cast
<
TableUpdateV4
>
(
update
)
;
NS_ENSURE_TRUE
(
updateV4
NS_ERROR_UC_UPDATE_UNEXPECTED_VERSION
)
;
if
(
updateV4
-
>
IsFullUpdate
(
)
)
{
input
-
>
Clear
(
)
;
output
-
>
Clear
(
)
;
rv
=
lookupCacheV4
-
>
ApplyUpdate
(
updateV4
*
input
*
output
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
{
if
(
prefixes1
.
IsEmpty
(
)
&
&
prefixes2
.
IsEmpty
(
)
)
{
lookupCacheV4
-
>
GetPrefixes
(
prefixes1
)
;
}
else
{
MOZ_ASSERT
(
prefixes1
.
IsEmpty
(
)
^
prefixes2
.
IsEmpty
(
)
)
;
input
=
prefixes1
.
IsEmpty
(
)
?
&
prefixes2
:
&
prefixes1
;
output
=
prefixes1
.
IsEmpty
(
)
?
&
prefixes1
:
&
prefixes2
;
}
rv
=
lookupCacheV4
-
>
ApplyUpdate
(
updateV4
*
input
*
output
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
input
-
>
Clear
(
)
;
}
lastAppliedUpdate
=
updateV4
;
aUpdates
[
i
]
=
nullptr
;
}
rv
=
lookupCacheV4
-
>
Build
(
*
output
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_UC_UPDATE_BUILD_PREFIX_FAILURE
)
;
rv
=
lookupCacheV4
-
>
WriteFile
(
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_UC_UPDATE_FAIL_TO_WRITE_DISK
)
;
if
(
lastAppliedUpdate
)
{
LOG
(
(
"
Write
meta
data
of
the
last
applied
update
.
"
)
)
;
rv
=
lookupCacheV4
-
>
WriteMetadata
(
lastAppliedUpdate
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_UC_UPDATE_FAIL_TO_WRITE_DISK
)
;
}
LOG
(
(
"
Successfully
updated
%
s
\
n
"
PromiseFlatCString
(
aTable
)
.
get
(
)
)
)
;
return
NS_OK
;
}
nsresult
Classifier
:
:
UpdateCache
(
RefPtr
<
const
TableUpdate
>
aUpdate
)
{
if
(
!
aUpdate
)
{
return
NS_OK
;
}
nsAutoCString
table
(
aUpdate
-
>
TableName
(
)
)
;
LOG
(
(
"
Classifier
:
:
UpdateCache
(
%
s
)
"
table
.
get
(
)
)
)
;
RefPtr
<
LookupCache
>
lookupCache
=
GetLookupCache
(
table
)
;
if
(
!
lookupCache
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
LookupCacheV2
>
lookupV2
=
LookupCache
:
:
Cast
<
LookupCacheV2
>
(
lookupCache
)
;
if
(
lookupV2
)
{
RefPtr
<
const
TableUpdateV2
>
updateV2
=
TableUpdate
:
:
Cast
<
TableUpdateV2
>
(
aUpdate
)
;
lookupV2
-
>
AddGethashResultToCache
(
updateV2
-
>
AddCompletes
(
)
updateV2
-
>
MissPrefixes
(
)
)
;
}
else
{
RefPtr
<
LookupCacheV4
>
lookupV4
=
LookupCache
:
:
Cast
<
LookupCacheV4
>
(
lookupCache
)
;
if
(
!
lookupV4
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
const
TableUpdateV4
>
updateV4
=
TableUpdate
:
:
Cast
<
TableUpdateV4
>
(
aUpdate
)
;
lookupV4
-
>
AddFullHashResponseToCache
(
updateV4
-
>
FullHashResponse
(
)
)
;
}
#
if
defined
(
DEBUG
)
lookupCache
-
>
DumpCache
(
)
;
#
endif
return
NS_OK
;
}
RefPtr
<
LookupCache
>
Classifier
:
:
GetLookupCache
(
const
nsACString
&
aTable
bool
aForUpdate
)
{
MOZ_ASSERT_IF
(
aForUpdate
OnUpdateThread
(
)
)
;
LookupCacheArray
&
lookupCaches
=
aForUpdate
?
mNewLookupCaches
:
mLookupCaches
;
auto
&
rootStoreDirectory
=
aForUpdate
?
mUpdatingDirectory
:
mRootStoreDirectory
;
for
(
auto
c
:
lookupCaches
)
{
if
(
c
-
>
TableName
(
)
.
Equals
(
aTable
)
)
{
return
c
;
}
}
if
(
ShouldAbort
(
)
)
{
return
nullptr
;
}
RefPtr
<
LookupCache
>
cache
;
nsCString
provider
=
GetProvider
(
aTable
)
;
if
(
nsUrlClassifierUtils
:
:
IsInSafeMode
(
)
)
{
if
(
provider
.
EqualsASCII
(
"
google
"
)
|
|
provider
.
EqualsASCII
(
"
google4
"
)
)
{
return
nullptr
;
}
}
if
(
StringEndsWith
(
aTable
"
-
proto
"
_ns
)
)
{
cache
=
new
LookupCacheV4
(
aTable
provider
rootStoreDirectory
)
;
}
else
{
cache
=
new
LookupCacheV2
(
aTable
provider
rootStoreDirectory
)
;
}
nsresult
rv
=
cache
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
rv
=
cache
-
>
Open
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
lookupCaches
.
AppendElement
(
cache
)
;
return
cache
;
}
if
(
aForUpdate
)
{
RemoveUpdateIntermediaries
(
)
;
return
nullptr
;
}
if
(
rv
=
=
NS_ERROR_FILE_CORRUPTED
)
{
LOG
(
(
"
Failed
to
get
prefixes
from
file
for
table
%
s
delete
on
-
disk
data
!
"
aTable
.
BeginReading
(
)
)
)
;
DeleteTables
(
mRootStoreDirectory
nsTArray
<
nsCString
>
{
nsCString
(
aTable
)
}
)
;
}
return
nullptr
;
}
nsresult
Classifier
:
:
ReadNoiseEntries
(
const
Prefix
&
aPrefix
const
nsACString
&
aTableName
uint32_t
aCount
PrefixArray
&
aNoiseEntries
)
{
FallibleTArray
<
uint32_t
>
prefixes
;
nsresult
rv
;
RefPtr
<
LookupCache
>
cache
=
GetLookupCache
(
aTableName
)
;
if
(
!
cache
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
LookupCacheV2
>
cacheV2
=
LookupCache
:
:
Cast
<
LookupCacheV2
>
(
cache
)
;
if
(
cacheV2
)
{
rv
=
cacheV2
-
>
GetPrefixes
(
prefixes
)
;
}
else
{
rv
=
LookupCache
:
:
Cast
<
LookupCacheV4
>
(
cache
)
-
>
GetFixedLengthPrefixes
(
prefixes
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
prefixes
.
Length
(
)
=
=
0
)
{
NS_WARNING
(
"
Could
not
find
prefix
in
PrefixSet
during
noise
lookup
"
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
m
=
prefixes
.
Length
(
)
;
uint32_t
a
=
aCount
%
m
;
uint32_t
idx
=
aPrefix
.
ToUint32
(
)
%
m
;
for
(
size_t
i
=
0
;
i
<
aCount
;
i
+
+
)
{
idx
=
(
a
*
idx
+
a
)
%
m
;
Prefix
newPrefix
;
uint32_t
hash
=
prefixes
[
idx
]
;
if
(
!
cacheV2
&
&
!
bool
(
MOZ_BIG_ENDIAN
(
)
)
)
{
hash
=
NativeEndian
:
:
swapFromBigEndian
(
prefixes
[
idx
]
)
;
}
newPrefix
.
FromUint32
(
hash
)
;
if
(
newPrefix
!
=
aPrefix
)
{
aNoiseEntries
.
AppendElement
(
newPrefix
)
;
}
}
return
NS_OK
;
}
nsresult
Classifier
:
:
LoadHashStore
(
nsIFile
*
aDirectory
nsACString
&
aResult
nsTArray
<
nsCString
>
&
aFailedTableNames
)
{
nsTArray
<
nsCString
>
tables
;
nsTArray
<
nsCString
>
exts
=
{
V2_METADATA_SUFFIX
}
;
nsresult
rv
=
ScanStoreDir
(
mRootStoreDirectory
exts
tables
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
const
auto
&
table
:
tables
)
{
HashStore
store
(
table
GetProvider
(
table
)
mRootStoreDirectory
)
;
nsresult
rv
=
store
.
Open
(
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
GetLookupCache
(
table
)
)
{
LOG
(
(
"
Failed
to
get
metadata
for
v2
table
%
s
"
table
.
get
(
)
)
)
;
aFailedTableNames
.
AppendElement
(
table
)
;
continue
;
}
ChunkSet
&
adds
=
store
.
AddChunks
(
)
;
ChunkSet
&
subs
=
store
.
SubChunks
(
)
;
if
(
adds
.
Length
(
)
=
=
0
&
&
subs
.
Length
(
)
=
=
0
)
{
continue
;
}
aResult
.
Append
(
store
.
TableName
(
)
)
;
aResult
.
Append
(
'
;
'
)
;
if
(
adds
.
Length
(
)
>
0
)
{
aResult
.
AppendLiteral
(
"
a
:
"
)
;
nsAutoCString
addList
;
adds
.
Serialize
(
addList
)
;
aResult
.
Append
(
addList
)
;
}
if
(
subs
.
Length
(
)
>
0
)
{
if
(
adds
.
Length
(
)
>
0
)
{
aResult
.
Append
(
'
:
'
)
;
}
aResult
.
AppendLiteral
(
"
s
:
"
)
;
nsAutoCString
subList
;
subs
.
Serialize
(
subList
)
;
aResult
.
Append
(
subList
)
;
}
aResult
.
Append
(
'
\
n
'
)
;
}
return
rv
;
}
nsresult
Classifier
:
:
LoadMetadata
(
nsIFile
*
aDirectory
nsACString
&
aResult
nsTArray
<
nsCString
>
&
aFailedTableNames
)
{
nsTArray
<
nsCString
>
tables
;
nsTArray
<
nsCString
>
exts
=
{
V4_METADATA_SUFFIX
}
;
nsresult
rv
=
ScanStoreDir
(
mRootStoreDirectory
exts
tables
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
const
auto
&
table
:
tables
)
{
RefPtr
<
LookupCache
>
c
=
GetLookupCache
(
table
)
;
RefPtr
<
LookupCacheV4
>
lookupCacheV4
=
LookupCache
:
:
Cast
<
LookupCacheV4
>
(
c
)
;
if
(
!
lookupCacheV4
)
{
aFailedTableNames
.
AppendElement
(
table
)
;
continue
;
}
nsCString
state
sha256
;
rv
=
lookupCacheV4
-
>
LoadMetadata
(
state
sha256
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
URLCLASSIFIER_VLPS_METADATA_CORRUPT
rv
=
=
NS_ERROR_FILE_CORRUPTED
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
get
metadata
for
v4
table
%
s
"
table
.
get
(
)
)
)
;
aFailedTableNames
.
AppendElement
(
table
)
;
continue
;
}
nsAutoCString
stateBase64
;
rv
=
Base64Encode
(
state
stateBase64
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoCString
checksumBase64
;
rv
=
Base64Encode
(
sha256
checksumBase64
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
LOG
(
(
"
Appending
state
'
%
s
'
and
checksum
'
%
s
'
for
table
%
s
"
stateBase64
.
get
(
)
checksumBase64
.
get
(
)
table
.
get
(
)
)
)
;
aResult
.
AppendPrintf
(
"
%
s
;
%
s
:
%
s
\
n
"
table
.
get
(
)
stateBase64
.
get
(
)
checksumBase64
.
get
(
)
)
;
}
return
rv
;
}
bool
Classifier
:
:
ShouldAbort
(
)
const
{
return
mIsClosed
|
|
nsUrlClassifierDBService
:
:
ShutdownHasStarted
(
)
|
|
(
mUpdateInterrupted
&
&
(
NS_GetCurrentThread
(
)
=
=
mUpdateThread
)
)
;
}
}
}
