#
ifndef
SBEntries_h__
#
define
SBEntries_h__
#
include
"
mozilla
/
crypto_hash_sha2
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsTHashMap
.
h
"
namespace
mozilla
{
namespace
safebrowsing
{
#
define
PREFIX_SIZE
4
#
define
COMPLETE_SIZE
32
template
<
uint32_t
S
class
Comparator
>
struct
SafebrowsingHash
{
static_assert
(
S
>
=
4
"
The
SafebrowsingHash
should
be
at
least
4
bytes
.
"
)
;
static
const
uint32_t
sHashSize
=
S
;
typedef
SafebrowsingHash
<
S
Comparator
>
self_type
;
uint8_t
buf
[
S
]
;
nsresult
FromPlaintext
(
const
nsACString
&
aPlainText
)
{
uint8_t
hash
[
COMPLETE_SIZE
]
;
crypto_hash_sha256
(
reinterpret_cast
<
const
uint8_t
*
>
(
aPlainText
.
Data
(
)
)
aPlainText
.
Length
(
)
hash
)
;
memcpy
(
buf
hash
sHashSize
)
;
return
NS_OK
;
}
void
Assign
(
const
nsACString
&
aStr
)
{
NS_ASSERTION
(
aStr
.
Length
(
)
>
=
sHashSize
"
string
must
be
at
least
sHashSize
characters
long
"
)
;
memcpy
(
buf
aStr
.
BeginReading
(
)
sHashSize
)
;
}
int
Compare
(
const
self_type
&
aOther
)
const
{
return
Comparator
:
:
Compare
(
buf
aOther
.
buf
)
;
}
bool
operator
=
=
(
const
self_type
&
aOther
)
const
{
return
Comparator
:
:
Compare
(
buf
aOther
.
buf
)
=
=
0
;
}
bool
operator
!
=
(
const
self_type
&
aOther
)
const
{
return
Comparator
:
:
Compare
(
buf
aOther
.
buf
)
!
=
0
;
}
bool
operator
<
(
const
self_type
&
aOther
)
const
{
return
Comparator
:
:
Compare
(
buf
aOther
.
buf
)
<
0
;
}
void
ToString
(
nsACString
&
aStr
)
const
{
[
[
maybe_unused
]
]
nsresult
nr
=
Base64Encode
(
(
char
*
)
buf
sHashSize
aStr
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
nr
)
)
;
}
nsCString
ToString
(
)
const
{
nsAutoCString
str
;
ToString
(
str
)
;
return
std
:
:
move
(
str
)
;
}
void
ToHexString
(
nsACString
&
aStr
)
const
{
static
const
char
*
const
lut
=
"
0123456789ABCDEF
"
;
size_t
len
=
32
;
aStr
.
SetCapacity
(
2
*
len
)
;
for
(
size_t
i
=
0
;
i
<
len
;
+
+
i
)
{
const
char
c
=
static_cast
<
char
>
(
buf
[
i
]
)
;
aStr
.
Append
(
lut
[
(
c
>
>
4
)
&
0x0F
]
)
;
aStr
.
Append
(
lut
[
c
&
15
]
)
;
}
}
uint32_t
ToUint32
(
)
const
{
uint32_t
n
;
memcpy
(
&
n
buf
sizeof
(
n
)
)
;
return
n
;
}
void
FromUint32
(
uint32_t
aHash
)
{
memcpy
(
buf
&
aHash
sizeof
(
aHash
)
)
;
}
}
;
class
PrefixComparator
{
public
:
static
int
Compare
(
const
uint8_t
*
a
const
uint8_t
*
b
)
{
uint32_t
first
;
memcpy
(
&
first
a
sizeof
(
uint32_t
)
)
;
uint32_t
second
;
memcpy
(
&
second
b
sizeof
(
uint32_t
)
)
;
if
(
first
>
second
)
{
return
1
;
}
else
if
(
first
=
=
second
)
{
return
0
;
}
else
{
return
-
1
;
}
}
}
;
typedef
SafebrowsingHash
<
PREFIX_SIZE
PrefixComparator
>
Prefix
;
typedef
nsTArray
<
Prefix
>
PrefixArray
;
class
CompletionComparator
{
public
:
static
int
Compare
(
const
uint8_t
*
a
const
uint8_t
*
b
)
{
return
memcmp
(
a
b
COMPLETE_SIZE
)
;
}
}
;
typedef
SafebrowsingHash
<
COMPLETE_SIZE
CompletionComparator
>
Completion
;
typedef
nsTArray
<
Completion
>
CompletionArray
;
struct
AddPrefix
{
Prefix
prefix
;
uint32_t
addChunk
;
AddPrefix
(
)
:
addChunk
(
0
)
{
}
uint32_t
Chunk
(
)
const
{
return
addChunk
;
}
const
Prefix
&
PrefixHash
(
)
const
{
return
prefix
;
}
template
<
class
T
>
int
Compare
(
const
T
&
other
)
const
{
int
cmp
=
prefix
.
Compare
(
other
.
PrefixHash
(
)
)
;
if
(
cmp
!
=
0
)
{
return
cmp
;
}
return
addChunk
-
other
.
addChunk
;
}
}
;
struct
AddComplete
{
Completion
complete
;
uint32_t
addChunk
;
AddComplete
(
)
:
addChunk
(
0
)
{
}
uint32_t
Chunk
(
)
const
{
return
addChunk
;
}
uint32_t
ToUint32
(
)
const
{
return
complete
.
ToUint32
(
)
;
}
const
Completion
&
CompleteHash
(
)
const
{
return
complete
;
}
template
<
class
T
>
int
Compare
(
const
T
&
other
)
const
{
int
cmp
=
complete
.
Compare
(
other
.
CompleteHash
(
)
)
;
if
(
cmp
!
=
0
)
{
return
cmp
;
}
return
addChunk
-
other
.
addChunk
;
}
bool
operator
!
=
(
const
AddComplete
&
aOther
)
const
{
if
(
addChunk
!
=
aOther
.
addChunk
)
{
return
true
;
}
return
complete
!
=
aOther
.
complete
;
}
}
;
struct
SubPrefix
{
Prefix
prefix
;
uint32_t
addChunk
;
uint32_t
subChunk
;
SubPrefix
(
)
:
addChunk
(
0
)
subChunk
(
0
)
{
}
uint32_t
Chunk
(
)
const
{
return
subChunk
;
}
uint32_t
AddChunk
(
)
const
{
return
addChunk
;
}
const
Prefix
&
PrefixHash
(
)
const
{
return
prefix
;
}
template
<
class
T
>
int
Compare
(
const
T
&
aOther
)
const
{
int
cmp
=
prefix
.
Compare
(
aOther
.
PrefixHash
(
)
)
;
if
(
cmp
!
=
0
)
return
cmp
;
if
(
addChunk
!
=
aOther
.
addChunk
)
return
addChunk
-
aOther
.
addChunk
;
return
subChunk
-
aOther
.
subChunk
;
}
template
<
class
T
>
int
CompareAlt
(
const
T
&
aOther
)
const
{
Prefix
other
;
other
.
FromUint32
(
aOther
.
ToUint32
(
)
)
;
int
cmp
=
prefix
.
Compare
(
other
)
;
if
(
cmp
!
=
0
)
return
cmp
;
return
addChunk
-
aOther
.
addChunk
;
}
}
;
struct
SubComplete
{
Completion
complete
;
uint32_t
addChunk
;
uint32_t
subChunk
;
SubComplete
(
)
:
addChunk
(
0
)
subChunk
(
0
)
{
}
uint32_t
Chunk
(
)
const
{
return
subChunk
;
}
uint32_t
AddChunk
(
)
const
{
return
addChunk
;
}
const
Completion
&
CompleteHash
(
)
const
{
return
complete
;
}
uint32_t
ToUint32
(
)
const
{
return
complete
.
ToUint32
(
)
;
}
int
Compare
(
const
SubComplete
&
aOther
)
const
{
int
cmp
=
complete
.
Compare
(
aOther
.
complete
)
;
if
(
cmp
!
=
0
)
return
cmp
;
if
(
addChunk
!
=
aOther
.
addChunk
)
return
addChunk
-
aOther
.
addChunk
;
return
subChunk
-
aOther
.
subChunk
;
}
}
;
typedef
FallibleTArray
<
AddPrefix
>
AddPrefixArray
;
typedef
FallibleTArray
<
AddComplete
>
AddCompleteArray
;
typedef
FallibleTArray
<
SubPrefix
>
SubPrefixArray
;
typedef
FallibleTArray
<
SubComplete
>
SubCompleteArray
;
typedef
FallibleTArray
<
Prefix
>
MissPrefixArray
;
template
<
class
T
class
Alloc
>
void
EntrySort
(
nsTArray_Impl
<
T
Alloc
>
&
aArray
)
{
aArray
.
Sort
(
[
]
(
const
T
&
aA
const
T
&
aB
)
{
return
aA
.
Compare
(
aB
)
;
}
)
;
}
template
<
class
T
class
Alloc
>
nsresult
ReadTArray
(
nsIInputStream
*
aStream
nsTArray_Impl
<
T
Alloc
>
*
aArray
uint32_t
aNumElements
)
{
if
(
!
aArray
-
>
SetLength
(
aNumElements
fallible
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
void
*
buffer
=
aArray
-
>
Elements
(
)
;
nsresult
rv
=
NS_ReadInputStreamToBuffer
(
aStream
&
buffer
(
aNumElements
*
sizeof
(
T
)
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
template
<
class
T
class
Alloc
>
nsresult
WriteTArray
(
nsIOutputStream
*
aStream
nsTArray_Impl
<
T
Alloc
>
&
aArray
)
{
uint32_t
written
;
return
aStream
-
>
Write
(
reinterpret_cast
<
char
*
>
(
aArray
.
Elements
(
)
)
aArray
.
Length
(
)
*
sizeof
(
T
)
&
written
)
;
}
typedef
nsClassHashtable
<
nsUint32HashKey
nsCString
>
PrefixStringMap
;
typedef
nsTHashMap
<
nsCStringHashKey
int64_t
>
TableFreshnessMap
;
typedef
nsCStringHashKey
FullHashString
;
typedef
nsTHashMap
<
FullHashString
int64_t
>
FullHashExpiryCache
;
struct
CachedFullHashResponse
{
int64_t
negativeCacheExpirySec
;
FullHashExpiryCache
fullHashes
;
CachedFullHashResponse
&
operator
=
(
const
CachedFullHashResponse
&
aOther
)
{
negativeCacheExpirySec
=
aOther
.
negativeCacheExpirySec
;
fullHashes
=
aOther
.
fullHashes
.
Clone
(
)
;
return
*
this
;
}
bool
operator
=
=
(
const
CachedFullHashResponse
&
aOther
)
const
{
if
(
negativeCacheExpirySec
!
=
aOther
.
negativeCacheExpirySec
|
|
fullHashes
.
Count
(
)
!
=
aOther
.
fullHashes
.
Count
(
)
)
{
return
false
;
}
for
(
const
auto
&
entry
:
fullHashes
)
{
if
(
entry
.
GetData
(
)
!
=
aOther
.
fullHashes
.
Get
(
entry
.
GetKey
(
)
)
)
{
return
false
;
}
}
return
true
;
}
}
;
typedef
nsClassHashtable
<
nsUint32HashKey
CachedFullHashResponse
>
FullHashResponseMap
;
template
<
class
T
>
void
CopyClassHashTable
(
const
T
&
aSource
T
&
aDestination
)
{
for
(
const
auto
&
entry
:
aSource
)
{
auto
value
=
aDestination
.
GetOrInsertNew
(
entry
.
GetKey
(
)
)
;
*
value
=
*
(
entry
.
GetData
(
)
)
;
}
}
}
}
#
endif
