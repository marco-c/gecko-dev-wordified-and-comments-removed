#
ifndef
Classifier_h__
#
define
Classifier_h__
#
include
"
Entries
.
h
"
#
include
"
HashStore
.
h
"
#
include
"
ProtocolParser
.
h
"
#
include
"
LookupCache
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIFile
.
h
"
namespace
mozilla
{
class
LazyIdleThread
;
namespace
safebrowsing
{
class
Classifier
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Classifier
)
;
Classifier
(
)
;
nsresult
Open
(
nsIFile
&
aCacheDirectory
)
;
void
Close
(
)
;
void
Reset
(
)
;
enum
ClearType
{
Clear_Cache
Clear_All
}
;
void
ResetTables
(
ClearType
aType
const
nsTArray
<
nsCString
>
&
aTables
)
;
void
TableRequest
(
nsACString
&
aResult
)
;
nsresult
ActiveTables
(
nsTArray
<
nsCString
>
&
aTables
)
const
;
nsresult
CheckURIFragments
(
const
nsTArray
<
nsCString
>
&
aSpecFragments
const
nsACString
&
table
LookupResultArray
&
aResults
)
;
using
AsyncUpdateCallback
=
std
:
:
function
<
void
(
nsresult
)
>
;
nsresult
AsyncApplyUpdates
(
const
TableUpdateArray
&
aUpdates
const
AsyncUpdateCallback
&
aCallback
)
;
void
FlushAndDisableAsyncUpdate
(
)
;
nsresult
ApplyFullHashes
(
ConstTableUpdateArray
&
aUpdates
)
;
nsresult
ReadNoiseEntries
(
const
Prefix
&
aPrefix
const
nsACString
&
aTableName
uint32_t
aCount
PrefixArray
&
aNoiseEntries
)
;
#
ifdef
MOZ_SAFEBROWSING_DUMP_FAILED_UPDATES
nsresult
DumpRawTableUpdates
(
const
nsACString
&
aRawUpdates
)
;
#
endif
static
void
SplitTables
(
const
nsACString
&
str
nsTArray
<
nsCString
>
&
tables
)
;
static
nsresult
GetPrivateStoreDirectory
(
nsIFile
*
aRootStoreDirectory
const
nsACString
&
aTableName
const
nsACString
&
aProvider
nsIFile
*
*
aPrivateStoreDirectory
)
;
nsresult
SwapInNewTablesAndCleanup
(
)
;
RefPtr
<
LookupCache
>
GetLookupCache
(
const
nsACString
&
aTable
bool
aForUpdate
=
false
)
;
void
GetCacheInfo
(
const
nsACString
&
aTable
nsIUrlClassifierCacheInfo
*
*
aCache
)
;
bool
OnUpdateThread
(
)
const
;
private
:
~
Classifier
(
)
;
void
DropStores
(
)
;
void
DeleteTables
(
nsIFile
*
aDirectory
const
nsTArray
<
nsCString
>
&
aTables
)
;
nsresult
CreateStoreDirectory
(
)
;
nsresult
SetupPathNames
(
)
;
nsresult
RecoverBackups
(
)
;
nsresult
CleanToDelete
(
)
;
nsresult
CopyInUseDirForUpdate
(
)
;
nsresult
CopyDirectoryInterruptible
(
nsCOMPtr
<
nsIFile
>
&
aDestDir
nsCOMPtr
<
nsIFile
>
&
aSourceDir
)
;
nsresult
RegenActiveTables
(
)
;
void
MergeNewLookupCaches
(
)
;
void
CopyAndInvalidateFullHashCache
(
)
;
void
RemoveUpdateIntermediaries
(
)
;
#
ifdef
MOZ_SAFEBROWSING_DUMP_FAILED_UPDATES
already_AddRefed
<
nsIFile
>
GetFailedUpdateDirectroy
(
)
;
nsresult
DumpFailedUpdate
(
)
;
#
endif
nsresult
ScanStoreDir
(
nsIFile
*
aDirectory
const
nsTArray
<
nsCString
>
&
aExtensions
nsTArray
<
nsCString
>
&
aTables
)
;
nsresult
UpdateHashStore
(
TableUpdateArray
&
aUpdates
const
nsACString
&
aTable
)
;
nsresult
UpdateTableV4
(
TableUpdateArray
&
aUpdates
const
nsACString
&
aTable
)
;
nsresult
UpdateCache
(
RefPtr
<
const
TableUpdate
>
aUpdates
)
;
RefPtr
<
LookupCache
>
GetLookupCacheForUpdate
(
const
nsACString
&
aTable
)
{
return
GetLookupCache
(
aTable
true
)
;
}
RefPtr
<
LookupCache
>
GetLookupCacheFrom
(
const
nsACString
&
aTable
LookupCacheArray
&
aLookupCaches
nsIFile
*
aRootStoreDirectory
)
;
bool
CheckValidUpdate
(
TableUpdateArray
&
aUpdates
const
nsACString
&
aTable
)
;
nsresult
LoadHashStore
(
nsIFile
*
aDirectory
nsACString
&
aResult
nsTArray
<
nsCString
>
&
aFailedTableNames
)
;
nsresult
LoadMetadata
(
nsIFile
*
aDirectory
nsACString
&
aResult
nsTArray
<
nsCString
>
&
aFailedTableNames
)
;
static
nsCString
GetProvider
(
const
nsACString
&
aTableName
)
;
nsresult
ApplyUpdatesBackground
(
TableUpdateArray
&
aUpdates
nsTArray
<
nsCString
>
&
aFailedTableNames
)
;
nsresult
ApplyUpdatesForeground
(
nsresult
aBackgroundRv
const
nsTArray
<
nsCString
>
&
aFailedTableNames
)
;
bool
ShouldAbort
(
)
const
;
nsresult
AddMozEntries
(
nsTArray
<
nsCString
>
&
aTables
)
;
nsresult
ClearLegacyFiles
(
)
;
nsCOMPtr
<
nsIFile
>
mCacheDirectory
;
nsCOMPtr
<
nsIFile
>
mRootStoreDirectory
;
nsCOMPtr
<
nsIFile
>
mBackupDirectory
;
nsCOMPtr
<
nsIFile
>
mUpdatingDirectory
;
nsCOMPtr
<
nsIFile
>
mToDeleteDirectory
;
LookupCacheArray
mLookupCaches
;
nsTArray
<
nsCString
>
mActiveTablesCache
;
uint32_t
mHashKey
;
nsCString
mTableRequestResult
;
bool
mIsTableRequestResultOutdated
;
LookupCacheArray
mNewLookupCaches
;
bool
mUpdateInterrupted
;
Atomic
<
bool
>
mIsClosed
;
RefPtr
<
LazyIdleThread
>
mUpdateThread
;
nsCOMPtr
<
nsIFile
>
mRootStoreDirectoryForUpdate
;
}
;
}
}
#
endif
