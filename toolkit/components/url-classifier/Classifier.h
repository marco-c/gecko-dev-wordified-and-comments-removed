#
ifndef
Classifier_h__
#
define
Classifier_h__
#
include
"
Entries
.
h
"
#
include
"
HashStore
.
h
"
#
include
"
ProtocolParser
.
h
"
#
include
"
LookupCache
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsDataHashtable
.
h
"
class
nsIThread
;
namespace
mozilla
{
namespace
safebrowsing
{
class
Classifier
{
public
:
Classifier
(
)
;
~
Classifier
(
)
;
nsresult
Open
(
nsIFile
&
aCacheDirectory
)
;
void
Close
(
)
;
void
Reset
(
)
;
enum
ClearType
{
Clear_Cache
Clear_All
}
;
void
ResetTables
(
ClearType
aType
const
nsTArray
<
nsCString
>
&
aTables
)
;
void
TableRequest
(
nsACString
&
aResult
)
;
nsresult
ActiveTables
(
nsTArray
<
nsCString
>
&
aTables
)
;
nsresult
Check
(
const
nsACString
&
aSpec
const
nsACString
&
tables
uint32_t
aFreshnessGuarantee
LookupResultArray
&
aResults
)
;
using
AsyncUpdateCallback
=
std
:
:
function
<
void
(
nsresult
)
>
;
nsresult
AsyncApplyUpdates
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
const
AsyncUpdateCallback
&
aCallback
)
;
void
FlushAndDisableAsyncUpdate
(
)
;
nsresult
ApplyFullHashes
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
)
;
void
SetLastUpdateTime
(
const
nsACString
&
aTableName
uint64_t
updateTime
)
;
int64_t
GetLastUpdateTime
(
const
nsACString
&
aTableName
)
;
nsresult
CacheCompletions
(
const
CacheResultArray
&
aResults
)
;
uint32_t
GetHashKey
(
void
)
{
return
mHashKey
;
}
nsresult
ReadNoiseEntries
(
const
Prefix
&
aPrefix
const
nsACString
&
aTableName
uint32_t
aCount
PrefixArray
*
aNoiseEntries
)
;
#
ifdef
MOZ_SAFEBROWSING_DUMP_FAILED_UPDATES
nsresult
DumpRawTableUpdates
(
const
nsACString
&
aRawUpdates
)
;
#
endif
static
void
SplitTables
(
const
nsACString
&
str
nsTArray
<
nsCString
>
&
tables
)
;
static
nsresult
GetPrivateStoreDirectory
(
nsIFile
*
aRootStoreDirectory
const
nsACString
&
aTableName
const
nsACString
&
aProvider
nsIFile
*
*
aPrivateStoreDirectory
)
;
nsresult
SwapInNewTablesAndCleanup
(
)
;
LookupCache
*
GetLookupCache
(
const
nsACString
&
aTable
bool
aForUpdate
=
false
)
;
private
:
void
DropStores
(
)
;
void
DeleteTables
(
nsIFile
*
aDirectory
const
nsTArray
<
nsCString
>
&
aTables
)
;
nsresult
CreateStoreDirectory
(
)
;
nsresult
SetupPathNames
(
)
;
nsresult
RecoverBackups
(
)
;
nsresult
CleanToDelete
(
)
;
nsresult
CopyInUseDirForUpdate
(
)
;
nsresult
RegenActiveTables
(
)
;
void
MergeNewLookupCaches
(
)
;
void
RemoveUpdateIntermediaries
(
)
;
#
ifdef
MOZ_SAFEBROWSING_DUMP_FAILED_UPDATES
already_AddRefed
<
nsIFile
>
GetFailedUpdateDirectroy
(
)
;
nsresult
DumpFailedUpdate
(
)
;
#
endif
nsresult
ScanStoreDir
(
nsIFile
*
aDirectory
nsTArray
<
nsCString
>
&
aTables
)
;
nsresult
UpdateHashStore
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
const
nsACString
&
aTable
)
;
nsresult
UpdateTableV4
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
const
nsACString
&
aTable
)
;
nsresult
UpdateCache
(
TableUpdate
*
aUpdates
)
;
LookupCache
*
GetLookupCacheForUpdate
(
const
nsACString
&
aTable
)
{
return
GetLookupCache
(
aTable
true
)
;
}
LookupCache
*
GetLookupCacheFrom
(
const
nsACString
&
aTable
nsTArray
<
LookupCache
*
>
&
aLookupCaches
nsIFile
*
aRootStoreDirectory
)
;
bool
CheckValidUpdate
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
const
nsACString
&
aTable
)
;
nsresult
LoadMetadata
(
nsIFile
*
aDirectory
nsACString
&
aResult
)
;
nsCString
GetProvider
(
const
nsACString
&
aTableName
)
;
nsresult
ApplyUpdatesBackground
(
nsTArray
<
TableUpdate
*
>
*
aUpdates
nsACString
&
aFailedTableName
)
;
nsresult
ApplyUpdatesForeground
(
nsresult
aBackgroundRv
const
nsACString
&
aFailedTableName
)
;
nsCOMPtr
<
nsIFile
>
mCacheDirectory
;
nsCOMPtr
<
nsIFile
>
mRootStoreDirectory
;
nsCOMPtr
<
nsIFile
>
mBackupDirectory
;
nsCOMPtr
<
nsIFile
>
mUpdatingDirectory
;
nsCOMPtr
<
nsIFile
>
mToDeleteDirectory
;
nsCOMPtr
<
nsICryptoHash
>
mCryptoHash
;
nsTArray
<
LookupCache
*
>
mLookupCaches
;
nsTArray
<
nsCString
>
mActiveTablesCache
;
uint32_t
mHashKey
;
TableFreshnessMap
mTableFreshness
;
TableFreshnessMap
mNewTableFreshness
;
nsCString
mTableRequestResult
;
bool
mIsTableRequestResultOutdated
;
nsTArray
<
LookupCache
*
>
mNewLookupCaches
;
bool
mUpdateInterrupted
;
nsCOMPtr
<
nsIThread
>
mUpdateThread
;
nsCOMPtr
<
nsIFile
>
mRootStoreDirectoryForUpdate
;
}
;
}
}
#
endif
