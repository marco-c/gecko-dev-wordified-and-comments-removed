#
ifndef
ChunkSet_h__
#
define
ChunkSet_h__
#
include
"
Entries
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
safebrowsing
{
class
ChunkSet
{
public
:
nsresult
Serialize
(
nsACString
&
aStr
)
;
nsresult
Set
(
uint32_t
aChunk
)
;
bool
Has
(
uint32_t
chunk
)
const
;
nsresult
Merge
(
const
ChunkSet
&
aOther
)
;
uint32_t
Length
(
)
const
;
nsresult
Remove
(
const
ChunkSet
&
aOther
)
;
void
Clear
(
)
;
nsresult
Write
(
nsIOutputStream
*
aOut
)
const
;
nsresult
Read
(
nsIInputStream
*
aIn
uint32_t
aNumElements
)
;
private
:
class
Range
{
public
:
Range
(
uint32_t
aBegin
uint32_t
aEnd
)
:
mBegin
(
aBegin
)
mEnd
(
aEnd
)
{
}
uint32_t
Length
(
)
const
;
nsresult
Remove
(
const
Range
&
aRange
ChunkSet
&
aRemainderSet
)
const
;
bool
FoldLeft
(
const
Range
&
aRange
)
;
bool
operator
=
=
(
const
Range
&
rhs
)
const
{
return
mBegin
=
=
rhs
.
mBegin
;
}
bool
operator
<
(
const
Range
&
rhs
)
const
{
return
mBegin
<
rhs
.
mBegin
;
}
uint32_t
Begin
(
)
const
{
return
mBegin
;
}
void
Begin
(
const
uint32_t
aBegin
)
{
mBegin
=
aBegin
;
}
uint32_t
End
(
)
const
{
return
mEnd
;
}
void
End
(
const
uint32_t
aEnd
)
{
mEnd
=
aEnd
;
}
bool
Contains
(
const
Range
&
aRange
)
const
{
return
mBegin
<
=
aRange
.
mBegin
&
&
aRange
.
mEnd
<
=
mEnd
;
}
bool
Precedes
(
const
Range
&
aRange
)
const
{
return
mEnd
+
1
=
=
aRange
.
mBegin
;
}
struct
IntersectionComparator
{
int
operator
(
)
(
const
Range
&
aRange
)
const
{
if
(
aRange
.
mBegin
>
mTarget
.
mEnd
)
{
return
-
1
;
}
if
(
mTarget
.
mBegin
>
aRange
.
mEnd
)
{
return
1
;
}
return
0
;
}
explicit
IntersectionComparator
(
const
Range
&
aTarget
)
:
mTarget
(
aTarget
)
{
}
const
Range
&
mTarget
;
}
;
private
:
uint32_t
mBegin
;
uint32_t
mEnd
;
}
;
static
const
size_t
IO_BUFFER_SIZE
=
1024
;
FallibleTArray
<
Range
>
mRanges
;
bool
HasSubrange
(
const
Range
&
aSubrange
)
const
;
}
;
}
}
#
endif
