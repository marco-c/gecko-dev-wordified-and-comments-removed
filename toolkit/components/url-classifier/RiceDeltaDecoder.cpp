#
include
"
RiceDeltaDecoder
.
h
"
namespace
{
class
BitBuffer
{
public
:
BitBuffer
(
const
uint8_t
*
bytes
size_t
byte_count
)
;
uint64_t
RemainingBitCount
(
)
const
;
bool
ReadBits
(
uint32_t
*
val
size_t
bit_count
)
;
bool
PeekBits
(
uint32_t
*
val
size_t
bit_count
)
;
bool
ReadExponentialGolomb
(
uint32_t
*
val
)
;
bool
ConsumeBits
(
size_t
bit_count
)
;
protected
:
const
uint8_t
*
const
bytes_
;
size_t
byte_count_
;
size_t
byte_offset_
;
size_t
bit_offset_
;
}
;
}
static
void
ReverseByte
(
uint8_t
&
b
)
{
b
=
(
b
&
0xF0
)
>
>
4
|
(
b
&
0x0F
)
<
<
4
;
b
=
(
b
&
0xCC
)
>
>
2
|
(
b
&
0x33
)
<
<
2
;
b
=
(
b
&
0xAA
)
>
>
1
|
(
b
&
0x55
)
<
<
1
;
}
namespace
mozilla
{
namespace
safebrowsing
{
RiceDeltaDecoder
:
:
RiceDeltaDecoder
(
uint8_t
*
aEncodedData
size_t
aEncodedDataSize
)
:
mEncodedData
(
aEncodedData
)
mEncodedDataSize
(
aEncodedDataSize
)
{
}
bool
RiceDeltaDecoder
:
:
Decode
(
uint32_t
aRiceParameter
uint32_t
aFirstValue
uint32_t
aNumEntries
uint32_t
*
aDecodedData
)
{
for
(
size_t
i
=
0
;
i
<
mEncodedDataSize
;
i
+
+
)
{
ReverseByte
(
mEncodedData
[
i
]
)
;
}
BitBuffer
bitBuffer
(
mEncodedData
mEncodedDataSize
)
;
const
uint32_t
k
=
aRiceParameter
;
aDecodedData
[
0
]
=
aFirstValue
;
for
(
uint32_t
i
=
0
;
i
<
aNumEntries
;
i
+
+
)
{
uint32_t
q
;
if
(
!
bitBuffer
.
ReadExponentialGolomb
(
&
q
)
)
{
LOG
(
(
"
Encoded
data
underflow
!
"
)
)
;
return
false
;
}
uint32_t
r
=
0
;
for
(
uint32_t
j
=
0
;
j
<
k
;
j
+
+
)
{
uint32_t
b
=
0
;
if
(
!
bitBuffer
.
ReadBits
(
&
b
1
)
)
{
break
;
}
r
|
=
b
<
<
j
;
}
uint32_t
N
=
(
q
<
<
k
)
+
r
;
aDecodedData
[
i
+
1
]
=
N
+
aDecodedData
[
i
]
;
}
return
true
;
}
}
}
namespace
{
uint8_t
LowestBits
(
uint8_t
byte
size_t
bit_count
)
{
return
byte
&
(
(
1
<
<
bit_count
)
-
1
)
;
}
uint8_t
HighestBits
(
uint8_t
byte
size_t
bit_count
)
{
MOZ_ASSERT
(
bit_count
<
8u
)
;
uint8_t
shift
=
8
-
static_cast
<
uint8_t
>
(
bit_count
)
;
uint8_t
mask
=
0xFF
<
<
shift
;
return
(
byte
&
mask
)
>
>
shift
;
}
BitBuffer
:
:
BitBuffer
(
const
uint8_t
*
bytes
size_t
byte_count
)
:
bytes_
(
bytes
)
byte_count_
(
byte_count
)
byte_offset_
(
)
bit_offset_
(
)
{
MOZ_ASSERT
(
static_cast
<
uint64_t
>
(
byte_count_
)
<
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
;
}
uint64_t
BitBuffer
:
:
RemainingBitCount
(
)
const
{
return
(
static_cast
<
uint64_t
>
(
byte_count_
)
-
byte_offset_
)
*
8
-
bit_offset_
;
}
bool
BitBuffer
:
:
PeekBits
(
uint32_t
*
val
size_t
bit_count
)
{
if
(
!
val
|
|
bit_count
>
RemainingBitCount
(
)
|
|
bit_count
>
32
)
{
return
false
;
}
const
uint8_t
*
bytes
=
bytes_
+
byte_offset_
;
size_t
remaining_bits_in_current_byte
=
8
-
bit_offset_
;
uint32_t
bits
=
LowestBits
(
*
bytes
+
+
remaining_bits_in_current_byte
)
;
if
(
bit_count
<
remaining_bits_in_current_byte
)
{
*
val
=
HighestBits
(
bits
bit_offset_
+
bit_count
)
;
return
true
;
}
bit_count
-
=
remaining_bits_in_current_byte
;
while
(
bit_count
>
=
8
)
{
bits
=
(
bits
<
<
8
)
|
*
bytes
+
+
;
bit_count
-
=
8
;
}
if
(
bit_count
>
0
)
{
bits
<
<
=
bit_count
;
bits
|
=
HighestBits
(
*
bytes
bit_count
)
;
}
*
val
=
bits
;
return
true
;
}
bool
BitBuffer
:
:
ReadBits
(
uint32_t
*
val
size_t
bit_count
)
{
return
PeekBits
(
val
bit_count
)
&
&
ConsumeBits
(
bit_count
)
;
}
bool
BitBuffer
:
:
ConsumeBits
(
size_t
bit_count
)
{
if
(
bit_count
>
RemainingBitCount
(
)
)
{
return
false
;
}
byte_offset_
+
=
(
bit_offset_
+
bit_count
)
/
8
;
bit_offset_
=
(
bit_offset_
+
bit_count
)
%
8
;
return
true
;
}
bool
BitBuffer
:
:
ReadExponentialGolomb
(
uint32_t
*
val
)
{
if
(
!
val
)
{
return
false
;
}
*
val
=
0
;
size_t
one_bit_count
=
0
;
uint32_t
peeked_bit
;
while
(
PeekBits
(
&
peeked_bit
1
)
&
&
peeked_bit
=
=
1
)
{
one_bit_count
+
+
;
ConsumeBits
(
1
)
;
}
if
(
!
ConsumeBits
(
1
)
)
{
return
false
;
}
*
val
=
one_bit_count
;
return
true
;
}
}
