#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsUrlClassifierPrefixSet
.
h
"
#
include
"
Common
.
h
"
static
void
RandomPrefixes
(
uint32_t
N
nsTArray
<
uint32_t
>
&
array
)
{
array
.
Clear
(
)
;
array
.
SetCapacity
(
N
)
;
for
(
uint32_t
i
=
0
;
i
<
N
;
i
+
+
)
{
bool
added
=
false
;
while
(
!
added
)
{
nsAutoCString
prefix
;
char
*
dst
=
prefix
.
BeginWriting
(
)
;
for
(
uint32_t
j
=
0
;
j
<
4
;
j
+
+
)
{
dst
[
j
]
=
static_cast
<
char
>
(
rand
(
)
%
256
)
;
}
const
char
*
src
=
prefix
.
BeginReading
(
)
;
uint32_t
data
=
0
;
memcpy
(
&
data
src
sizeof
(
data
)
)
;
if
(
!
array
.
Contains
(
data
)
)
{
array
.
AppendElement
(
data
)
;
added
=
true
;
}
}
}
struct
Comparator
{
bool
LessThan
(
const
uint32_t
&
aA
const
uint32_t
&
aB
)
const
{
return
aA
<
aB
;
}
bool
Equals
(
const
uint32_t
&
aA
const
uint32_t
&
aB
)
const
{
return
aA
=
=
aB
;
}
}
;
array
.
Sort
(
Comparator
(
)
)
;
}
void
RunTest
(
uint32_t
aTestSize
)
{
RefPtr
<
nsUrlClassifierPrefixSet
>
prefixSet
=
new
nsUrlClassifierPrefixSet
(
)
;
nsTArray
<
uint32_t
>
array
;
RandomPrefixes
(
aTestSize
array
)
;
nsresult
rv
=
prefixSet
-
>
SetPrefixes
(
array
.
Elements
(
)
array
.
Length
(
)
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
array
.
Length
(
)
;
i
+
+
)
{
uint32_t
value
=
0
;
rv
=
prefixSet
-
>
GetPrefixByIndex
(
i
&
value
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
ASSERT_TRUE
(
value
=
=
array
[
i
]
)
;
}
}
TEST
(
URLClassifierPrefixSet
GetTargetPrefixWithLargeSet
)
{
static
const
char
prefKey
[
]
=
"
browser
.
safebrowsing
.
prefixset_max_array_size
"
;
mozilla
:
:
Preferences
:
:
SetUint
(
prefKey
10000
)
;
RunTest
(
100000
)
;
}
TEST
(
URLClassifierPrefixSet
GetTargetPrefixWithSmallSet
)
{
static
const
char
prefKey
[
]
=
"
browser
.
safebrowsing
.
prefixset_max_array_size
"
;
mozilla
:
:
Preferences
:
:
SetUint
(
prefKey
10000
)
;
RunTest
(
1000
)
;
}
