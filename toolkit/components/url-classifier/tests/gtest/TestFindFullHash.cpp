#
include
"
safebrowsing
.
pb
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
nsUrlClassifierUtils
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
safebrowsing
;
namespace
{
class
Base64EncodedStringArray
{
public
:
Base64EncodedStringArray
(
nsCString
aArray
[
]
size_t
N
)
;
operator
const
char
*
*
(
)
const
{
return
(
const
char
*
*
)
&
mArray
[
0
]
;
}
private
:
nsTArray
<
const
char
*
>
mArray
;
nsTArray
<
nsCString
>
mStringStorage
;
}
;
template
<
size_t
N
>
Base64EncodedStringArray
MakeBase64EncodedStringArray
(
nsCString
(
&
aArray
)
[
N
]
)
{
return
Base64EncodedStringArray
(
aArray
N
)
;
}
}
TEST
(
FindFullHash
Request
)
{
nsCOMPtr
<
nsIUrlClassifierUtils
>
urlUtil
=
do_GetService
(
"
mozilla
.
org
/
url
-
classifier
/
utils
;
1
"
)
;
const
char
*
listNames
[
]
=
{
"
test
-
phish
-
proto
"
"
test
-
unwanted
-
proto
"
}
;
nsCString
listStates
[
]
=
{
nsCString
(
"
sta
\
x00te1
"
7
)
nsCString
(
"
sta
\
x00te2
"
7
)
}
;
nsCString
prefixes
[
]
=
{
nsCString
(
"
\
x00
\
x00
\
x00
\
x01
"
4
)
nsCString
(
"
\
x00
\
x00
\
x00
\
x00
\
x01
"
5
)
nsCString
(
"
\
x00
\
xFF
\
x00
\
x01
"
4
)
nsCString
(
"
\
x00
\
xFF
\
x00
\
x01
\
x11
\
x23
\
xAA
\
xBC
"
8
)
nsCString
(
"
\
x00
\
x00
\
x00
\
x01
\
x00
\
x01
\
x98
"
7
)
}
;
nsCString
requestBase64
;
nsresult
rv
;
rv
=
urlUtil
-
>
MakeFindFullHashRequestV4
(
listNames
MakeBase64EncodedStringArray
(
listStates
)
MakeBase64EncodedStringArray
(
prefixes
)
ArrayLength
(
listNames
)
ArrayLength
(
prefixes
)
requestBase64
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
FallibleTArray
<
uint8_t
>
requestBinary
;
rv
=
Base64URLDecode
(
requestBase64
Base64URLDecodePaddingPolicy
:
:
Require
requestBinary
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
FindFullHashesRequest
r
;
ASSERT_TRUE
(
r
.
ParseFromArray
(
&
requestBinary
[
0
]
requestBinary
.
Length
(
)
)
)
;
ASSERT_EQ
(
r
.
client_states_size
(
)
(
int
)
ArrayLength
(
listStates
)
)
;
for
(
int
i
=
0
;
i
<
r
.
client_states_size
(
)
;
i
+
+
)
{
auto
s
=
r
.
client_states
(
i
)
;
ASSERT_TRUE
(
listStates
[
i
]
.
Equals
(
nsCString
(
s
.
c_str
(
)
s
.
size
(
)
)
)
)
;
}
auto
threatInfo
=
r
.
threat_info
(
)
;
ASSERT_EQ
(
threatInfo
.
threat_types_size
(
)
(
int
)
ArrayLength
(
listStates
)
)
;
for
(
int
i
=
0
;
i
<
threatInfo
.
threat_types_size
(
)
;
i
+
+
)
{
uint32_t
expectedThreatType
;
rv
=
urlUtil
-
>
ConvertListNameToThreatType
(
nsCString
(
listNames
[
i
]
)
&
expectedThreatType
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_EQ
(
threatInfo
.
threat_types
(
i
)
expectedThreatType
)
;
}
ASSERT_EQ
(
threatInfo
.
threat_entries_size
(
)
(
int
)
ArrayLength
(
prefixes
)
)
;
for
(
int
i
=
0
;
i
<
threatInfo
.
threat_entries_size
(
)
;
i
+
+
)
{
auto
p
=
threatInfo
.
threat_entries
(
i
)
.
hash
(
)
;
ASSERT_TRUE
(
prefixes
[
i
]
.
Equals
(
nsCString
(
p
.
c_str
(
)
p
.
size
(
)
)
)
)
;
}
}
namespace
{
Base64EncodedStringArray
:
:
Base64EncodedStringArray
(
nsCString
aArray
[
]
size_t
N
)
{
for
(
size_t
i
=
0
;
i
<
N
;
i
+
+
)
{
nsCString
encoded
;
nsresult
rv
=
Base64Encode
(
aArray
[
i
]
encoded
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
mStringStorage
.
AppendElement
(
encoded
)
;
mArray
.
AppendElement
(
encoded
.
get
(
)
)
;
}
}
}
