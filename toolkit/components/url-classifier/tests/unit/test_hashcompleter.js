var
basicCompletionSet
=
[
{
hash
:
"
abcdefgh
"
expectCompletion
:
true
table
:
"
test
"
chunkId
:
1234
}
{
hash
:
"
1234
"
expectCompletion
:
false
}
{
hash
:
"
\
u0000
\
u0000
\
u000012312
"
expectCompletion
:
true
table
:
"
test
"
chunkId
:
1234
}
]
;
var
falseCompletionSet
=
[
{
hash
:
"
1234
"
expectCompletion
:
false
}
{
hash
:
"
"
expectCompletion
:
false
}
{
hash
:
"
abc
"
expectCompletion
:
false
}
]
;
var
dupedCompletionSet
=
[
{
hash
:
"
1234
"
expectCompletion
:
true
table
:
"
test
"
chunkId
:
1
}
{
hash
:
"
5678
"
expectCompletion
:
false
table
:
"
test2
"
chunkId
:
2
}
{
hash
:
"
1234
"
expectCompletion
:
true
table
:
"
test
"
chunkId
:
1
}
{
hash
:
"
5678
"
expectCompletion
:
false
table
:
"
test2
"
chunkId
:
2
}
]
;
var
multipleResponsesCompletionSet
=
[
{
hash
:
"
1234
"
expectCompletion
:
true
multipleCompletions
:
true
completions
:
[
{
hash
:
"
123456
"
table
:
"
test1
"
chunkId
:
3
}
{
hash
:
"
123478
"
table
:
"
test2
"
chunkId
:
4
}
]
}
]
;
function
buildCompletionRequest
(
aCompletionSet
)
{
let
prefixes
=
[
]
;
let
prefixSet
=
new
Set
(
)
;
aCompletionSet
.
forEach
(
s
=
>
{
let
prefix
=
s
.
hash
.
substring
(
0
4
)
;
if
(
prefixSet
.
has
(
prefix
)
)
{
return
;
}
prefixSet
.
add
(
prefix
)
;
prefixes
.
push
(
prefix
)
;
}
)
;
return
4
+
"
:
"
+
(
4
*
prefixes
.
length
)
+
"
\
n
"
+
prefixes
.
join
(
"
"
)
;
}
function
parseCompletionRequest
(
aRequest
)
{
let
tokens
=
/
(
\
d
)
:
(
\
d
+
)
/
.
exec
(
aRequest
)
;
if
(
tokens
.
length
<
3
)
{
dump
(
"
Request
format
error
.
"
)
;
return
null
;
}
let
partialLength
=
parseInt
(
tokens
[
1
]
)
;
let
payloadStart
=
tokens
[
1
]
.
length
+
1
+
tokens
[
2
]
.
length
+
1
;
let
prefixSet
=
[
]
;
for
(
let
i
=
payloadStart
;
i
<
aRequest
.
length
;
i
+
=
partialLength
)
{
let
prefix
=
aRequest
.
substr
(
i
partialLength
)
;
if
(
prefix
.
length
!
=
=
partialLength
)
{
dump
(
"
Header
info
not
correct
:
"
+
aRequest
.
substr
(
0
payloadStart
)
)
;
return
null
;
}
prefixSet
.
push
(
prefix
)
;
}
prefixSet
.
sort
(
)
;
return
prefixSet
;
}
function
compareCompletionRequest
(
aRequest1
aRequest2
)
{
let
prefixSet1
=
parseCompletionRequest
(
aRequest1
)
;
let
prefixSet2
=
parseCompletionRequest
(
aRequest2
)
;
return
equal
(
JSON
.
stringify
(
prefixSet1
)
JSON
.
stringify
(
prefixSet2
)
)
;
}
const
SIZE_OF_RANDOM_SET
=
16
;
function
getRandomCompletionSet
(
forceServerError
)
{
let
completionSet
=
[
]
;
let
hashPrefixes
=
[
]
;
let
seed
=
Math
.
floor
(
Math
.
random
(
)
*
Math
.
pow
(
2
32
)
)
;
dump
(
"
Using
seed
of
"
+
seed
+
"
for
random
completion
set
.
\
n
"
)
;
let
rand
=
new
LFSRgenerator
(
seed
)
;
for
(
let
i
=
0
;
i
<
SIZE_OF_RANDOM_SET
;
i
+
+
)
{
let
completion
=
{
expectCompletion
:
false
forceServerError
:
false
_finished
:
false
}
;
let
hash
;
let
prefix
;
do
{
hash
=
"
"
;
let
length
=
1
+
rand
.
nextNum
(
5
)
;
for
(
let
j
=
0
;
j
<
length
;
j
+
+
)
hash
+
=
String
.
fromCharCode
(
rand
.
nextNum
(
8
)
)
;
prefix
=
hash
.
substring
(
0
4
)
;
}
while
(
hashPrefixes
.
indexOf
(
prefix
)
!
=
-
1
)
;
hashPrefixes
.
push
(
prefix
)
;
completion
.
hash
=
hash
;
if
(
!
forceServerError
)
{
completion
.
expectCompletion
=
rand
.
nextNum
(
1
)
=
=
1
;
}
else
{
completion
.
forceServerError
=
true
;
}
if
(
completion
.
expectCompletion
)
{
completion
.
table
=
"
test
"
+
(
rand
.
nextNum
(
31
)
)
.
toString
(
36
)
;
completion
.
chunkId
=
rand
.
nextNum
(
16
)
;
}
completionSet
.
push
(
completion
)
;
}
return
completionSet
;
}
var
completionSets
=
[
basicCompletionSet
falseCompletionSet
dupedCompletionSet
multipleResponsesCompletionSet
]
;
var
currentCompletionSet
=
-
1
;
var
finishedCompletions
=
0
;
const
SERVER_PATH
=
"
/
hash
-
completer
"
;
var
server
;
const
COMPLETE_LENGTH
=
32
;
var
completer
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
hashcompleter
;
1
"
]
.
getService
(
Ci
.
nsIUrlClassifierHashCompleter
)
;
var
gethashUrl
;
var
expectedMaxServerCompletionSet
=
0
;
var
maxServerCompletionSet
=
0
;
function
run_test
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
safebrowsing
.
provider
.
test
.
disableBackoff
"
false
)
;
completionSets
.
push
(
getRandomCompletionSet
(
false
)
)
;
expectedMaxServerCompletionSet
=
completionSets
.
length
;
for
(
let
j
=
0
;
j
<
10
;
+
+
j
)
{
completionSets
.
push
(
getRandomCompletionSet
(
true
)
)
;
}
for
(
let
completionSet
of
completionSets
)
{
for
(
let
completion
of
completionSet
)
{
if
(
completion
.
multipleCompletions
)
{
for
(
let
responseCompletion
of
completion
.
completions
)
{
let
numChars
=
COMPLETE_LENGTH
-
responseCompletion
.
hash
.
length
;
responseCompletion
.
hash
+
=
(
new
Array
(
numChars
+
1
)
)
.
join
(
"
\
u0000
"
)
;
}
}
else
{
let
numChars
=
COMPLETE_LENGTH
-
completion
.
hash
.
length
;
completion
.
hash
+
=
(
new
Array
(
numChars
+
1
)
)
.
join
(
"
\
u0000
"
)
;
}
}
}
do_test_pending
(
)
;
server
=
new
HttpServer
(
)
;
server
.
registerPathHandler
(
SERVER_PATH
hashCompleterServer
)
;
server
.
start
(
-
1
)
;
const
SERVER_PORT
=
server
.
identity
.
primaryPort
;
gethashUrl
=
"
http
:
/
/
localhost
:
"
+
SERVER_PORT
+
SERVER_PATH
;
runNextCompletion
(
)
;
}
function
runNextCompletion
(
)
{
currentCompletionSet
+
+
;
if
(
currentCompletionSet
>
=
completionSets
.
length
)
{
finish
(
)
;
return
;
}
dump
(
"
Now
on
completion
set
index
"
+
currentCompletionSet
+
"
length
"
+
completionSets
[
currentCompletionSet
]
.
length
+
"
\
n
"
)
;
finishedCompletions
=
0
;
for
(
let
completion
of
completionSets
[
currentCompletionSet
]
)
{
completer
.
complete
(
completion
.
hash
.
substring
(
0
4
)
gethashUrl
"
test
-
phish
-
shavar
"
(
new
callback
(
completion
)
)
)
;
}
}
function
hashCompleterServer
(
aRequest
aResponse
)
{
let
stream
=
aRequest
.
bodyInputStream
;
let
wrapperStream
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
wrapperStream
.
setInputStream
(
stream
)
;
let
len
=
stream
.
available
(
)
;
let
data
=
wrapperStream
.
readBytes
(
len
)
;
let
expectedRequest
=
buildCompletionRequest
(
completionSets
[
currentCompletionSet
]
)
;
compareCompletionRequest
(
data
expectedRequest
)
;
let
completedHashes
=
[
]
;
let
responseText
=
"
"
;
function
responseForCompletion
(
x
)
{
return
x
.
table
+
"
:
"
+
x
.
chunkId
+
"
:
"
+
x
.
hash
.
length
+
"
\
n
"
+
x
.
hash
;
}
let
httpStatus
=
204
;
for
(
let
completion
of
completionSets
[
currentCompletionSet
]
)
{
if
(
completion
.
expectCompletion
&
&
(
completedHashes
.
indexOf
(
completion
.
hash
)
=
=
-
1
)
)
{
completedHashes
.
push
(
completion
.
hash
)
;
if
(
completion
.
multipleCompletions
)
responseText
+
=
completion
.
completions
.
map
(
responseForCompletion
)
.
join
(
"
"
)
;
else
responseText
+
=
responseForCompletion
(
completion
)
;
}
if
(
completion
.
forceServerError
)
{
httpStatus
=
503
;
}
}
dump
(
"
Server
sending
response
for
"
+
currentCompletionSet
+
"
\
n
"
)
;
maxServerCompletionSet
=
currentCompletionSet
;
if
(
responseText
&
&
httpStatus
!
=
503
)
{
aResponse
.
write
(
responseText
)
;
}
else
{
aResponse
.
setStatusLine
(
null
httpStatus
null
)
;
}
}
function
callback
(
completion
)
{
this
.
_completion
=
completion
;
}
callback
.
prototype
=
{
completionV2
:
function
completionV2
(
hash
table
chunkId
trusted
)
{
Assert
.
ok
(
this
.
_completion
.
expectCompletion
)
;
if
(
this
.
_completion
.
multipleCompletions
)
{
for
(
let
completion
of
this
.
_completion
.
completions
)
{
if
(
completion
.
hash
=
=
hash
)
{
Assert
.
equal
(
JSON
.
stringify
(
hash
)
JSON
.
stringify
(
completion
.
hash
)
)
;
Assert
.
equal
(
table
completion
.
table
)
;
Assert
.
equal
(
chunkId
completion
.
chunkId
)
;
completion
.
_completed
=
true
;
if
(
this
.
_completion
.
completions
.
every
(
x
=
>
x
.
_completed
)
)
this
.
_completed
=
true
;
break
;
}
}
}
else
{
Assert
.
equal
(
JSON
.
stringify
(
hash
)
JSON
.
stringify
(
this
.
_completion
.
hash
)
)
;
Assert
.
equal
(
table
this
.
_completion
.
table
)
;
Assert
.
equal
(
chunkId
this
.
_completion
.
chunkId
)
;
this
.
_completed
=
true
;
}
}
completionFinished
:
function
completionFinished
(
status
)
{
finishedCompletions
+
+
;
Assert
.
equal
(
!
!
this
.
_completion
.
expectCompletion
!
!
this
.
_completed
)
;
this
.
_completion
.
_finished
=
true
;
if
(
currentCompletionSet
<
completionSets
.
length
&
&
finishedCompletions
=
=
completionSets
[
currentCompletionSet
]
.
length
)
{
runNextCompletion
(
)
;
}
}
}
;
function
finish
(
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
safebrowsing
.
provider
.
test
.
disableBackoff
"
)
;
Assert
.
equal
(
expectedMaxServerCompletionSet
maxServerCompletionSet
)
;
server
.
stop
(
function
(
)
{
do_test_finished
(
)
;
}
)
;
}
