ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
var
gHttpServ
=
null
;
var
gDbService
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
dbservice
;
1
"
]
.
getService
(
Ci
.
nsIUrlClassifierDBService
)
;
var
gTables
=
{
}
;
function
readFileToString
(
aFilename
)
{
let
f
=
do_get_file
(
aFilename
)
;
let
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
stream
.
init
(
f
-
1
0
0
)
;
let
buf
=
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
)
;
return
buf
;
}
function
registerTableUpdate
(
aTable
aFilename
)
{
return
new
Promise
(
resolve
=
>
{
if
(
!
(
aTable
in
gTables
)
)
{
gTables
[
aTable
]
=
[
]
;
}
let
numChunks
=
gTables
[
aTable
]
.
length
+
1
;
let
redirectPath
=
"
/
"
+
aTable
+
"
-
"
+
numChunks
;
let
redirectUrl
=
"
localhost
:
4444
"
+
redirectPath
;
gTables
[
aTable
]
.
push
(
redirectUrl
)
;
gHttpServ
.
registerPathHandler
(
redirectPath
function
(
request
response
)
{
info
(
"
Mock
safebrowsing
server
handling
request
for
"
+
redirectPath
)
;
let
contents
=
readFileToString
(
aFilename
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
vnd
.
google
.
safebrowsing
-
update
"
false
)
;
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
bodyOutputStream
.
write
(
contents
contents
.
length
)
;
resolve
(
contents
)
;
}
)
;
}
)
;
}
function
processUpdateRequest
(
)
{
let
response
=
"
n
:
1000
\
n
"
;
for
(
let
table
in
gTables
)
{
response
+
=
"
i
:
"
+
table
+
"
\
n
"
;
for
(
let
i
=
0
;
i
<
gTables
[
table
]
.
length
;
+
+
i
)
{
response
+
=
"
u
:
"
+
gTables
[
table
]
[
i
]
+
"
\
n
"
;
}
}
info
(
"
Returning
update
response
:
"
+
response
)
;
return
response
;
}
function
run_test
(
)
{
gHttpServ
=
new
HttpServer
(
)
;
gHttpServ
.
registerDirectory
(
"
/
"
do_get_cwd
(
)
)
;
gHttpServ
.
registerPathHandler
(
"
/
downloads
"
function
(
request
response
)
{
let
blob
=
processUpdateRequest
(
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
vnd
.
google
.
safebrowsing
-
update
"
false
)
;
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
bodyOutputStream
.
write
(
blob
blob
.
length
)
;
}
)
;
gHttpServ
.
start
(
4444
)
;
run_next_test
(
)
;
}
function
handleError
(
aEvent
)
{
do_throw
(
"
We
didn
'
t
download
or
update
correctly
:
"
+
aEvent
)
;
}
add_test
(
function
test_update
(
)
{
let
streamUpdater
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
streamupdater
;
1
"
]
.
getService
(
Ci
.
nsIUrlClassifierStreamUpdater
)
;
registerTableUpdate
(
"
goog
-
downloadwhite
-
digest256
"
"
data
/
digest1
.
chunk
"
)
;
registerTableUpdate
(
"
goog
-
downloadwhite
-
digest256
"
"
data
/
digest2
.
chunk
"
)
;
function
updateSuccess
(
aEvent
)
{
Assert
.
equal
(
"
1000
"
aEvent
)
;
info
(
"
All
data
processed
"
)
;
run_next_test
(
)
;
}
streamUpdater
.
downloadUpdates
(
"
goog
-
downloadwhite
-
digest256
"
"
goog
-
downloadwhite
-
digest256
;
\
n
"
true
"
http
:
/
/
localhost
:
4444
/
downloads
"
updateSuccess
handleError
handleError
)
;
}
)
;
add_test
(
function
test_url_not_whitelisted
(
)
{
let
uri
=
Services
.
io
.
newURI
(
"
http
:
/
/
example
.
com
"
)
;
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
uri
{
}
)
;
gDbService
.
lookup
(
principal
"
goog
-
downloadwhite
-
digest256
"
function
handleEvent
(
aEvent
)
{
Assert
.
equal
(
"
"
aEvent
)
;
run_next_test
(
)
;
}
)
;
}
)
;
add_test
(
function
test_url_whitelisted
(
)
{
let
uri
=
Services
.
io
.
newURI
(
"
http
:
/
/
whitelisted
.
com
"
)
;
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
uri
{
}
)
;
gDbService
.
lookup
(
principal
"
goog
-
downloadwhite
-
digest256
"
function
handleEvent
(
aEvent
)
{
Assert
.
equal
(
"
goog
-
downloadwhite
-
digest256
"
aEvent
)
;
run_next_test
(
)
;
}
)
;
}
)
;
