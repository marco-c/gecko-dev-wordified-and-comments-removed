Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
TEST_TABLE_DATA_LIST
=
[
{
tableName
:
"
test
-
listmanager0
-
digest256
"
providerName
:
"
google
"
updateUrl
:
"
http
:
/
/
localhost
:
4444
/
safebrowsing
/
update
"
gethashUrl
:
"
http
:
/
/
localhost
:
4444
/
safebrowsing
/
gethash0
"
}
{
tableName
:
"
test
-
listmanager1
-
digest256
"
providerName
:
"
google
"
updateUrl
:
"
http
:
/
/
localhost
:
4444
/
safebrowsing
/
update
"
gethashUrl
:
"
http
:
/
/
localhost
:
4444
/
safebrowsing
/
gethash1
"
}
{
tableName
:
"
test
-
listmanager2
-
digest256
"
providerName
:
"
google
"
updateUrl
:
"
http
:
/
/
localhost
:
4444
/
safebrowsing
/
update
"
gethashUrl
:
"
http
:
/
/
localhost
:
4444
/
safebrowsing
/
gethash2
"
}
]
;
const
TEST_TABLE_DATA_V4
=
{
tableName
:
"
test
-
phish
-
proto
"
providerName
:
"
google4
"
updateUrl
:
"
http
:
/
/
localhost
:
5555
/
safebrowsing
/
update
?
"
gethashUrl
:
"
http
:
/
/
localhost
:
5555
/
safebrowsing
/
gethash
-
v4
"
}
;
const
TEST_TABLE_DATA_V4_DISABLED
=
{
tableName
:
"
test
-
unwanted
-
proto
"
providerName
:
"
google4
"
updateUrl
:
"
http
:
/
/
localhost
:
5555
/
safebrowsing
/
update
?
"
gethashUrl
:
"
http
:
/
/
localhost
:
5555
/
safebrowsing
/
gethash
-
v4
"
}
;
const
PREF_NEXTUPDATETIME
=
"
browser
.
safebrowsing
.
provider
.
google
.
nextupdatetime
"
;
const
PREF_NEXTUPDATETIME_V4
=
"
browser
.
safebrowsing
.
provider
.
google4
.
nextupdatetime
"
;
let
gListManager
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
listmanager
;
1
"
]
.
getService
(
Ci
.
nsIUrlListManager
)
;
let
gUrlUtils
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
utils
;
1
"
]
.
getService
(
Ci
.
nsIUrlClassifierUtils
)
;
let
gHttpServ
=
null
;
let
gUpdateResponse
=
"
"
;
let
gExpectedUpdateRequest
=
"
"
;
let
gExpectedQueryV4
=
"
"
;
let
gHttpServV4
=
null
;
let
gUpdatedCntForTableData
=
0
;
let
gIsV4Updated
=
false
;
const
NEW_CLIENT_STATE
=
'
sta
\
0te
'
;
const
CHECKSUM
=
'
check
\
0sum
'
;
prefBranch
.
setBoolPref
(
"
browser
.
safebrowsing
.
debug
"
true
)
;
prefBranch
.
setCharPref
(
"
browser
.
safebrowsing
.
id
"
"
Firefox
\
xFF
\
xFF
"
)
;
TEST_TABLE_DATA_LIST
.
forEach
(
function
(
t
)
{
gListManager
.
registerTable
(
t
.
tableName
t
.
providerName
t
.
updateUrl
t
.
gethashUrl
)
;
}
)
;
gListManager
.
registerTable
(
TEST_TABLE_DATA_V4
.
tableName
TEST_TABLE_DATA_V4
.
providerName
TEST_TABLE_DATA_V4
.
updateUrl
TEST_TABLE_DATA_V4
.
gethashUrl
)
;
gListManager
.
registerTable
(
TEST_TABLE_DATA_V4_DISABLED
.
tableName
TEST_TABLE_DATA_V4_DISABLED
.
providerName
TEST_TABLE_DATA_V4_DISABLED
.
updateUrl
TEST_TABLE_DATA_V4_DISABLED
.
gethashUrl
)
;
const
SERVER_INVOLVED_TEST_CASE_LIST
=
[
function
test_update_table0
(
)
{
disableAllUpdates
(
)
;
gListManager
.
enableUpdate
(
TEST_TABLE_DATA_LIST
[
0
]
.
tableName
)
;
gExpectedUpdateRequest
=
TEST_TABLE_DATA_LIST
[
0
]
.
tableName
+
"
;
\
n
"
;
gUpdateResponse
=
"
n
:
1000
\
ni
:
"
+
TEST_TABLE_DATA_LIST
[
0
]
.
tableName
+
"
\
n
"
;
gUpdateResponse
+
=
readFileToString
(
"
data
/
digest2
.
chunk
"
)
;
forceTableUpdate
(
)
;
}
function
test_update_table0_with_existing_chunks
(
)
{
disableAllUpdates
(
)
;
gListManager
.
enableUpdate
(
TEST_TABLE_DATA_LIST
[
0
]
.
tableName
)
;
gExpectedUpdateRequest
=
TEST_TABLE_DATA_LIST
[
0
]
.
tableName
+
"
;
a
:
5
\
n
"
;
gUpdateResponse
=
"
n
:
1000
\
ni
:
"
+
TEST_TABLE_DATA_LIST
[
0
]
.
tableName
+
"
\
n
"
;
gUpdateResponse
+
=
readFileToString
(
"
data
/
digest1
.
chunk
"
)
;
forceTableUpdate
(
)
;
}
function
test_update_all_tables
(
)
{
disableAllUpdates
(
)
;
TEST_TABLE_DATA_LIST
.
forEach
(
function
(
t
)
{
gListManager
.
enableUpdate
(
t
.
tableName
)
;
}
)
;
gListManager
.
enableUpdate
(
TEST_TABLE_DATA_V4
.
tableName
)
;
gListManager
.
disableUpdate
(
TEST_TABLE_DATA_V4_DISABLED
.
tableName
)
;
gExpectedUpdateRequest
=
TEST_TABLE_DATA_LIST
[
0
]
.
tableName
+
"
;
a
:
5
:
s
:
2
-
12
\
n
"
+
TEST_TABLE_DATA_LIST
[
1
]
.
tableName
+
"
;
\
n
"
+
TEST_TABLE_DATA_LIST
[
2
]
.
tableName
+
"
;
\
n
"
;
gUpdateResponse
=
"
n
:
1000
\
n
"
;
let
requestV4
=
gUrlUtils
.
makeUpdateRequestV4
(
[
TEST_TABLE_DATA_V4
.
tableName
]
[
"
"
]
1
)
;
gExpectedQueryV4
=
"
&
req
=
"
+
requestV4
;
forceTableUpdate
(
)
;
}
]
;
SERVER_INVOLVED_TEST_CASE_LIST
.
forEach
(
t
=
>
add_test
(
t
)
)
;
add_test
(
function
test_partialUpdateV4
(
)
{
disableAllUpdates
(
)
;
gListManager
.
enableUpdate
(
TEST_TABLE_DATA_V4
.
tableName
)
;
let
requestV4
=
gUrlUtils
.
makeUpdateRequestV4
(
[
TEST_TABLE_DATA_V4
.
tableName
]
[
btoa
(
NEW_CLIENT_STATE
)
]
1
)
;
gExpectedQueryV4
=
"
&
req
=
"
+
requestV4
;
forceTableUpdate
(
)
;
}
)
;
add_test
(
function
test_getGethashUrl
(
)
{
TEST_TABLE_DATA_LIST
.
forEach
(
function
(
t
)
{
equal
(
gListManager
.
getGethashUrl
(
t
.
tableName
)
t
.
gethashUrl
)
;
}
)
;
equal
(
gListManager
.
getGethashUrl
(
TEST_TABLE_DATA_V4
.
tableName
)
TEST_TABLE_DATA_V4
.
gethashUrl
)
;
run_next_test
(
)
;
}
)
;
function
run_test
(
)
{
gHttpServ
=
new
HttpServer
(
)
;
gHttpServ
.
registerDirectory
(
"
/
"
do_get_cwd
(
)
)
;
gHttpServ
.
registerPathHandler
(
"
/
safebrowsing
/
update
"
function
(
request
response
)
{
let
body
=
NetUtil
.
readInputStreamToString
(
request
.
bodyInputStream
request
.
bodyInputStream
.
available
(
)
)
;
equal
(
body
gExpectedUpdateRequest
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
vnd
.
google
.
safebrowsing
-
update
"
false
)
;
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
bodyOutputStream
.
write
(
gUpdateResponse
gUpdateResponse
.
length
)
;
gUpdatedCntForTableData
+
+
;
if
(
gUpdatedCntForTableData
!
=
=
SERVER_INVOLVED_TEST_CASE_LIST
.
length
)
{
waitForUpdateSuccess
(
run_next_test
)
;
return
;
}
if
(
gIsV4Updated
)
{
run_next_test
(
)
;
return
;
}
do_print
(
"
Waiting
for
TEST_TABLE_DATA_V4
to
be
tested
.
.
.
"
)
;
}
)
;
gHttpServ
.
start
(
4444
)
;
gHttpServV4
=
new
HttpServer
(
)
;
gHttpServV4
.
registerDirectory
(
"
/
"
do_get_cwd
(
)
)
;
gHttpServV4
.
registerPathHandler
(
"
/
safebrowsing
/
update
"
function
(
request
response
)
{
equal
(
request
.
bodyInputStream
.
available
(
)
0
)
;
equal
(
request
.
getHeader
(
"
X
-
HTTP
-
Method
-
Override
"
)
"
POST
"
)
;
equal
(
request
.
method
"
GET
"
)
;
equal
(
request
.
queryString
gExpectedQueryV4
)
;
equal
(
request
.
queryString
.
indexOf
(
'
+
'
)
-
1
)
;
equal
(
request
.
queryString
.
indexOf
(
'
/
'
)
-
1
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
vnd
.
google
.
safebrowsing
-
update
"
false
)
;
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
let
content
=
"
\
x0A
\
x33
\
x08
\
x02
\
x20
\
x02
\
x2A
\
x18
\
x08
\
x01
\
x12
\
x14
\
x08
\
x04
\
x12
\
x10
\
x00
\
x00
\
x00
\
x00
\
x00
\
x00
\
x00
\
x01
\
x00
\
x00
\
x00
\
x02
\
x00
\
x00
\
x00
\
x03
\
x3A
\
x06
\
x73
\
x74
\
x61
\
x00
\
x74
\
x65
\
x42
\
x0B
\
x0A
\
x09
\
x63
\
x68
\
x65
\
x63
\
x6B
\
x00
\
x73
\
x75
\
x6D
\
x12
\
x08
\
x08
\
x08
\
x10
\
x80
\
x94
\
xEB
\
xDC
\
x03
"
;
response
.
bodyOutputStream
.
write
(
content
content
.
length
)
;
if
(
gIsV4Updated
)
{
run_next_test
(
)
;
return
;
}
waitUntilMetaDataSaved
(
NEW_CLIENT_STATE
CHECKSUM
(
)
=
>
{
gIsV4Updated
=
true
;
if
(
gUpdatedCntForTableData
=
=
=
SERVER_INVOLVED_TEST_CASE_LIST
.
length
)
{
run_next_test
(
)
;
return
;
}
do_print
(
"
Wait
for
all
sever
-
involved
tests
to
be
done
.
.
.
"
)
;
}
)
;
}
)
;
gHttpServV4
.
start
(
5555
)
;
run_next_test
(
)
;
}
function
forceTableUpdate
(
)
{
prefBranch
.
setCharPref
(
PREF_NEXTUPDATETIME
"
1
"
)
;
prefBranch
.
setCharPref
(
PREF_NEXTUPDATETIME_V4
"
1
"
)
;
gListManager
.
maybeToggleUpdateChecking
(
)
;
}
function
disableAllUpdates
(
)
{
TEST_TABLE_DATA_LIST
.
forEach
(
t
=
>
gListManager
.
disableUpdate
(
t
.
tableName
)
)
;
gListManager
.
disableUpdate
(
TEST_TABLE_DATA_V4
.
tableName
)
;
}
function
waitForUpdateSuccess
(
callback
)
{
let
nextupdatetime
=
parseInt
(
prefBranch
.
getCharPref
(
PREF_NEXTUPDATETIME
)
)
;
do_print
(
"
nextupdatetime
:
"
+
nextupdatetime
)
;
if
(
nextupdatetime
!
=
=
1
)
{
callback
(
)
;
return
;
}
do_timeout
(
1000
waitForUpdateSuccess
.
bind
(
null
callback
)
)
;
}
function
readFileToString
(
aFilename
)
{
let
f
=
do_get_file
(
aFilename
)
;
let
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
stream
.
init
(
f
-
1
0
0
)
;
let
buf
=
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
)
;
return
buf
;
}
function
waitUntilMetaDataSaved
(
expectedState
expectedChecksum
callback
)
{
let
dbService
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
dbservice
;
1
"
]
.
getService
(
Ci
.
nsIUrlClassifierDBService
)
;
dbService
.
getTables
(
metaData
=
>
{
do_print
(
"
metadata
:
"
+
metaData
)
;
let
didCallback
=
false
;
metaData
.
split
(
"
\
n
"
)
.
some
(
line
=
>
{
let
p
=
line
.
indexOf
(
"
;
"
)
;
if
(
-
1
=
=
=
p
)
{
return
false
;
}
let
tableName
=
line
.
substring
(
0
p
)
;
let
metadata
=
line
.
substring
(
p
+
1
)
.
split
(
"
:
"
)
;
let
stateBase64
=
metadata
[
0
]
;
let
checksumBase64
=
metadata
[
1
]
;
if
(
tableName
!
=
=
'
test
-
phish
-
proto
'
)
{
return
false
;
}
if
(
stateBase64
=
=
=
btoa
(
expectedState
)
&
&
checksumBase64
=
=
=
btoa
(
expectedChecksum
)
)
{
do_print
(
'
State
has
been
saved
to
disk
!
'
)
;
callback
(
)
;
didCallback
=
true
;
}
return
true
;
}
)
;
if
(
!
didCallback
)
{
do_timeout
(
1000
waitUntilMetaDataSaved
.
bind
(
null
expectedState
expectedChecksum
callback
)
)
;
}
}
)
;
}
