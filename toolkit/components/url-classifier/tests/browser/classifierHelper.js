let
dbService
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
dbservice
;
1
"
]
.
getService
(
Ci
.
nsIUrlClassifierDBService
)
;
let
listmanager
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
listmanager
;
1
"
]
.
getService
(
Ci
.
nsIUrlListManager
)
;
if
(
typeof
classifierHelper
=
=
"
undefined
"
)
{
var
classifierHelper
=
{
}
;
}
const
HASHLEN
=
32
;
const
PREFS
=
{
PROVIDER_LISTS
:
"
browser
.
safebrowsing
.
provider
.
mozilla
.
lists
"
DISALLOW_COMPLETIONS
:
"
urlclassifier
.
disallow_completions
"
PROVIDER_GETHASHURL
:
"
browser
.
safebrowsing
.
provider
.
mozilla
.
gethashURL
"
}
;
classifierHelper
.
_curAddChunkNum
=
1
;
classifierHelper
.
_updatesToCleanup
=
[
]
;
classifierHelper
.
waitForInit
=
function
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
function
checkForInit
(
)
{
if
(
listmanager
.
isRegistered
(
)
)
{
resolve
(
)
;
}
else
{
setTimeout
(
(
)
=
>
{
checkForInit
(
)
;
}
1000
)
;
}
}
checkForInit
(
)
;
}
)
;
}
;
classifierHelper
.
allowCompletion
=
function
(
lists
url
)
{
for
(
let
list
of
lists
)
{
let
pref
=
Services
.
prefs
.
getCharPref
(
PREFS
.
PROVIDER_LISTS
)
;
pref
+
=
"
"
+
list
;
Services
.
prefs
.
setCharPref
(
PREFS
.
PROVIDER_LISTS
pref
)
;
pref
=
Services
.
prefs
.
getCharPref
(
PREFS
.
DISALLOW_COMPLETIONS
)
;
pref
=
pref
.
replace
(
list
list
+
"
-
backup
"
)
;
Services
.
prefs
.
setCharPref
(
PREFS
.
DISALLOW_COMPLETIONS
pref
)
;
}
Services
.
prefs
.
setCharPref
(
PREFS
.
PROVIDER_GETHASHURL
url
)
;
}
;
classifierHelper
.
addUrlToDB
=
function
(
updateData
)
{
let
testUpdate
=
"
"
;
for
(
let
update
of
updateData
)
{
let
LISTNAME
=
update
.
db
;
let
CHUNKDATA
=
update
.
url
;
let
CHUNKLEN
=
CHUNKDATA
.
length
;
let
HASHLEN
=
update
.
len
?
update
.
len
:
32
;
update
.
addChunk
=
classifierHelper
.
_curAddChunkNum
;
classifierHelper
.
_curAddChunkNum
+
=
1
;
classifierHelper
.
_updatesToCleanup
.
push
(
update
)
;
testUpdate
+
=
"
n
:
1000
\
n
"
+
"
i
:
"
+
LISTNAME
+
"
\
n
"
+
"
ad
:
1
\
n
"
+
"
a
:
"
+
update
.
addChunk
+
"
:
"
+
HASHLEN
+
"
:
"
+
CHUNKLEN
+
"
\
n
"
+
CHUNKDATA
;
}
return
classifierHelper
.
_update
(
testUpdate
)
;
}
;
classifierHelper
.
resetDatabase
=
function
(
)
{
var
testUpdate
=
"
"
;
for
(
var
update
of
classifierHelper
.
_updatesToCleanup
)
{
testUpdate
+
=
"
n
:
1000
\
ni
:
"
+
update
.
db
+
"
\
nad
:
"
+
update
.
addChunk
+
"
\
n
"
;
}
return
classifierHelper
.
_update
(
testUpdate
)
;
}
;
classifierHelper
.
reloadDatabase
=
function
(
)
{
dbService
.
reloadDatabase
(
)
;
}
;
classifierHelper
.
_update
=
function
(
update
)
{
return
(
async
function
(
)
{
let
success
=
false
;
while
(
!
success
)
{
try
{
await
new
Promise
(
(
resolve
reject
)
=
>
{
let
listener
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUrlClassifierUpdateObserver
"
]
)
updateUrlRequested
(
url
)
{
}
streamFinished
(
status
)
{
}
updateError
(
errorCode
)
{
reject
(
errorCode
)
;
}
updateSuccess
(
requestedTimeout
)
{
resolve
(
)
;
}
}
;
dbService
.
beginUpdate
(
listener
"
"
"
"
)
;
dbService
.
beginStream
(
"
"
"
"
)
;
dbService
.
updateStream
(
update
)
;
dbService
.
finishStream
(
)
;
dbService
.
finishUpdate
(
)
;
}
)
;
success
=
true
;
}
catch
(
e
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
1000
)
)
;
}
}
}
)
(
)
;
}
;
classifierHelper
.
_cleanup
=
function
(
)
{
for
(
var
pref
in
PREFS
)
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
if
(
!
classifierHelper
.
_updatesToCleanup
)
{
return
Promise
.
resolve
(
)
;
}
return
classifierHelper
.
resetDatabase
(
)
;
}
;
registerCleanupFunction
(
classifierHelper
.
_cleanup
)
;
