Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
let
dbService
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
dbservice
;
1
"
]
.
getService
(
Ci
.
nsIUrlClassifierDBService
)
;
if
(
typeof
(
classifierHelper
)
=
=
"
undefined
"
)
{
var
classifierHelper
=
{
}
;
}
const
ADD_CHUNKNUM
=
524
;
const
SUB_CHUNKNUM
=
523
;
const
HASHLEN
=
32
;
const
PREFS
=
{
PROVIDER_LISTS
:
"
browser
.
safebrowsing
.
provider
.
mozilla
.
lists
"
DISALLOW_COMPLETIONS
:
"
urlclassifier
.
disallow_completions
"
PROVIDER_GETHASHURL
:
"
browser
.
safebrowsing
.
provider
.
mozilla
.
gethashURL
"
}
;
classifierHelper
.
_updatesToCleanup
=
[
]
;
classifierHelper
.
waitForInit
=
function
(
)
{
let
observerService
=
Cc
[
"
mozilla
.
org
/
observer
-
service
;
1
"
]
.
getService
(
Ci
.
nsIObserverService
)
;
let
secMan
=
Cc
[
"
mozilla
.
org
/
scriptsecuritymanager
;
1
"
]
.
getService
(
Ci
.
nsIScriptSecurityManager
)
;
let
iosvc
=
Cc
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIOService
)
;
const
table
=
"
test
-
phish
-
simple
"
;
const
url
=
"
http
:
/
/
itisatrap
.
org
/
firefox
/
its
-
a
-
trap
.
html
"
;
let
principal
=
secMan
.
createCodebasePrincipal
(
iosvc
.
newURI
(
url
)
{
}
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
observerService
.
addObserver
(
function
(
)
{
resolve
(
)
;
}
"
mozentries
-
update
-
finished
"
)
;
let
listener
=
{
QueryInterface
:
function
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsISupports
)
|
|
iid
.
equals
(
Ci
.
nsIUrlClassifierUpdateObserver
)
)
return
this
;
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
handleEvent
:
function
(
value
)
{
if
(
value
=
=
=
table
)
{
resolve
(
)
;
}
}
}
;
dbService
.
lookup
(
principal
table
listener
)
;
}
)
;
}
classifierHelper
.
allowCompletion
=
function
(
lists
url
)
{
for
(
let
list
of
lists
)
{
let
pref
=
Services
.
prefs
.
getCharPref
(
PREFS
.
PROVIDER_LISTS
)
;
pref
+
=
"
"
+
list
;
Services
.
prefs
.
setCharPref
(
PREFS
.
PROVIDER_LISTS
pref
)
;
pref
=
Services
.
prefs
.
getCharPref
(
PREFS
.
DISALLOW_COMPLETIONS
)
;
pref
=
pref
.
replace
(
list
list
+
"
-
backup
"
)
;
Services
.
prefs
.
setCharPref
(
PREFS
.
DISALLOW_COMPLETIONS
pref
)
;
}
Services
.
prefs
.
setCharPref
(
PREFS
.
PROVIDER_GETHASHURL
url
)
;
}
classifierHelper
.
addUrlToDB
=
function
(
updateData
)
{
let
testUpdate
=
"
"
;
for
(
let
update
of
updateData
)
{
let
LISTNAME
=
update
.
db
;
let
CHUNKDATA
=
update
.
url
;
let
CHUNKLEN
=
CHUNKDATA
.
length
;
let
HASHLEN
=
update
.
len
?
update
.
len
:
32
;
classifierHelper
.
_updatesToCleanup
.
push
(
update
)
;
testUpdate
+
=
"
n
:
1000
\
n
"
+
"
i
:
"
+
LISTNAME
+
"
\
n
"
+
"
ad
:
1
\
n
"
+
"
a
:
"
+
ADD_CHUNKNUM
+
"
:
"
+
HASHLEN
+
"
:
"
+
CHUNKLEN
+
"
\
n
"
+
CHUNKDATA
;
}
return
classifierHelper
.
_update
(
testUpdate
)
;
}
classifierHelper
.
removeUrlFromDB
=
function
(
updateData
)
{
var
testUpdate
=
"
"
;
for
(
var
update
of
updateData
)
{
var
LISTNAME
=
update
.
db
;
var
CHUNKDATA
=
ADD_CHUNKNUM
+
"
:
"
+
update
.
url
;
var
CHUNKLEN
=
CHUNKDATA
.
length
;
var
HASHLEN
=
update
.
len
?
update
.
len
:
32
;
testUpdate
+
=
"
n
:
1000
\
n
"
+
"
i
:
"
+
LISTNAME
+
"
\
n
"
+
"
s
:
"
+
SUB_CHUNKNUM
+
"
:
"
+
HASHLEN
+
"
:
"
+
CHUNKLEN
+
"
\
n
"
+
CHUNKDATA
;
}
classifierHelper
.
_updatesToCleanup
=
classifierHelper
.
_updatesToCleanup
.
filter
(
(
v
)
=
>
{
return
updateData
.
indexOf
(
v
)
=
=
-
1
;
}
)
;
return
classifierHelper
.
_update
(
testUpdate
)
;
}
;
classifierHelper
.
resetDB
=
function
(
)
{
var
testUpdate
=
"
"
;
for
(
var
update
of
classifierHelper
.
_updatesToCleanup
)
{
if
(
testUpdate
.
includes
(
update
.
db
)
)
continue
;
testUpdate
+
=
"
n
:
1000
\
n
"
+
"
i
:
"
+
update
.
db
+
"
\
n
"
+
"
ad
:
"
+
ADD_CHUNKNUM
+
"
\
n
"
+
"
sd
:
"
+
SUB_CHUNKNUM
+
"
\
n
"
}
return
classifierHelper
.
_update
(
testUpdate
)
;
}
;
classifierHelper
.
reloadDatabase
=
function
(
)
{
dbService
.
reloadDatabase
(
)
;
}
classifierHelper
.
_update
=
function
(
update
)
{
return
Task
.
spawn
(
function
*
(
)
{
let
success
=
false
;
while
(
!
success
)
{
try
{
yield
new
Promise
(
(
resolve
reject
)
=
>
{
let
listener
=
{
QueryInterface
:
function
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsISupports
)
|
|
iid
.
equals
(
Ci
.
nsIUrlClassifierUpdateObserver
)
)
return
this
;
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
updateUrlRequested
:
function
(
url
)
{
}
streamFinished
:
function
(
status
)
{
}
updateError
:
function
(
errorCode
)
{
reject
(
errorCode
)
;
}
updateSuccess
:
function
(
requestedTimeout
)
{
resolve
(
)
;
}
}
;
dbService
.
beginUpdate
(
listener
"
"
"
"
)
;
dbService
.
beginStream
(
"
"
"
"
)
;
dbService
.
updateStream
(
update
)
;
dbService
.
finishStream
(
)
;
dbService
.
finishUpdate
(
)
;
}
)
;
success
=
true
;
}
catch
(
e
)
{
yield
new
Promise
(
resolve
=
>
setTimeout
(
resolve
1000
)
)
;
}
}
}
)
;
}
;
classifierHelper
.
_cleanup
=
function
(
)
{
for
(
var
pref
in
PREFS
)
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
if
(
!
classifierHelper
.
_updatesToCleanup
)
{
return
Promise
.
resolve
(
)
;
}
return
classifierHelper
.
resetDB
(
)
;
}
;
registerCleanupFunction
(
classifierHelper
.
_cleanup
)
;
