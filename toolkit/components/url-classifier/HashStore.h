#
ifndef
HashStore_h__
#
define
HashStore_h__
#
include
"
Entries
.
h
"
#
include
"
ChunkSet
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
safebrowsing
.
pb
.
h
"
#
include
<
string
>
namespace
mozilla
{
namespace
safebrowsing
{
class
TableUpdate
{
public
:
TableUpdate
(
const
nsACString
&
aTable
)
:
mTable
(
aTable
)
{
}
virtual
~
TableUpdate
(
)
{
}
virtual
bool
Empty
(
)
const
=
0
;
const
nsCString
&
TableName
(
)
const
{
return
mTable
;
}
template
<
typename
T
>
static
T
*
Cast
(
TableUpdate
*
aThat
)
{
return
(
T
:
:
TAG
=
=
aThat
-
>
Tag
(
)
?
reinterpret_cast
<
T
*
>
(
aThat
)
:
nullptr
)
;
}
private
:
virtual
int
Tag
(
)
const
=
0
;
nsCString
mTable
;
}
;
class
TableUpdateV2
:
public
TableUpdate
{
public
:
explicit
TableUpdateV2
(
const
nsACString
&
aTable
)
:
TableUpdate
(
aTable
)
{
}
bool
Empty
(
)
const
override
{
return
mAddChunks
.
Length
(
)
=
=
0
&
&
mSubChunks
.
Length
(
)
=
=
0
&
&
mAddExpirations
.
Length
(
)
=
=
0
&
&
mSubExpirations
.
Length
(
)
=
=
0
&
&
mAddPrefixes
.
Length
(
)
=
=
0
&
&
mSubPrefixes
.
Length
(
)
=
=
0
&
&
mAddCompletes
.
Length
(
)
=
=
0
&
&
mSubCompletes
.
Length
(
)
=
=
0
;
}
MOZ_MUST_USE
nsresult
NewAddChunk
(
uint32_t
aChunk
)
{
return
mAddChunks
.
Set
(
aChunk
)
;
}
;
MOZ_MUST_USE
nsresult
NewSubChunk
(
uint32_t
aChunk
)
{
return
mSubChunks
.
Set
(
aChunk
)
;
}
;
MOZ_MUST_USE
nsresult
NewAddExpiration
(
uint32_t
aChunk
)
{
return
mAddExpirations
.
Set
(
aChunk
)
;
}
;
MOZ_MUST_USE
nsresult
NewSubExpiration
(
uint32_t
aChunk
)
{
return
mSubExpirations
.
Set
(
aChunk
)
;
}
;
MOZ_MUST_USE
nsresult
NewAddPrefix
(
uint32_t
aAddChunk
const
Prefix
&
aPrefix
)
;
MOZ_MUST_USE
nsresult
NewSubPrefix
(
uint32_t
aAddChunk
const
Prefix
&
aPrefix
uint32_t
aSubChunk
)
;
MOZ_MUST_USE
nsresult
NewAddComplete
(
uint32_t
aChunk
const
Completion
&
aCompletion
)
;
MOZ_MUST_USE
nsresult
NewSubComplete
(
uint32_t
aAddChunk
const
Completion
&
aCompletion
uint32_t
aSubChunk
)
;
ChunkSet
&
AddChunks
(
)
{
return
mAddChunks
;
}
ChunkSet
&
SubChunks
(
)
{
return
mSubChunks
;
}
ChunkSet
&
AddExpirations
(
)
{
return
mAddExpirations
;
}
ChunkSet
&
SubExpirations
(
)
{
return
mSubExpirations
;
}
AddPrefixArray
&
AddPrefixes
(
)
{
return
mAddPrefixes
;
}
SubPrefixArray
&
SubPrefixes
(
)
{
return
mSubPrefixes
;
}
AddCompleteArray
&
AddCompletes
(
)
{
return
mAddCompletes
;
}
SubCompleteArray
&
SubCompletes
(
)
{
return
mSubCompletes
;
}
static
const
int
TAG
=
2
;
private
:
ChunkSet
mAddChunks
;
ChunkSet
mSubChunks
;
ChunkSet
mAddExpirations
;
ChunkSet
mSubExpirations
;
AddPrefixArray
mAddPrefixes
;
SubPrefixArray
mSubPrefixes
;
AddCompleteArray
mAddCompletes
;
SubCompleteArray
mSubCompletes
;
virtual
int
Tag
(
)
const
override
{
return
TAG
;
}
}
;
class
TableUpdateV4
:
public
TableUpdate
{
public
:
struct
PrefixString
{
private
:
std
:
:
string
mStorage
;
nsDependentCSubstring
mString
;
public
:
explicit
PrefixString
(
std
:
:
string
&
aString
)
{
aString
.
swap
(
mStorage
)
;
mString
.
Rebind
(
mStorage
.
data
(
)
mStorage
.
size
(
)
)
;
}
;
const
nsACString
&
GetPrefixString
(
)
const
{
return
mString
;
}
;
}
;
typedef
nsClassHashtable
<
nsUint32HashKey
PrefixString
>
PrefixesStringMap
;
typedef
nsTArray
<
int32_t
>
RemovalIndiceArray
;
public
:
explicit
TableUpdateV4
(
const
nsACString
&
aTable
)
:
TableUpdate
(
aTable
)
mFullUpdate
(
false
)
{
}
bool
Empty
(
)
const
override
{
return
mPrefixesMap
.
IsEmpty
(
)
&
&
mRemovalIndiceArray
.
IsEmpty
(
)
;
}
bool
IsFullUpdate
(
)
const
{
return
mFullUpdate
;
}
PrefixesStringMap
&
Prefixes
(
)
{
return
mPrefixesMap
;
}
RemovalIndiceArray
&
RemovalIndices
(
)
{
return
mRemovalIndiceArray
;
}
static
const
int
TAG
=
4
;
void
SetFullUpdate
(
bool
aIsFullUpdate
)
{
mFullUpdate
=
aIsFullUpdate
;
}
void
NewPrefixes
(
int32_t
aSize
std
:
:
string
&
aPrefixes
)
;
void
NewRemovalIndices
(
const
uint32_t
*
aIndices
size_t
aNumOfIndices
)
;
private
:
virtual
int
Tag
(
)
const
override
{
return
TAG
;
}
bool
mFullUpdate
;
PrefixesStringMap
mPrefixesMap
;
RemovalIndiceArray
mRemovalIndiceArray
;
}
;
class
HashStore
{
public
:
HashStore
(
const
nsACString
&
aTableName
nsIFile
*
aRootStoreFile
)
;
~
HashStore
(
)
;
const
nsCString
&
TableName
(
)
const
{
return
mTableName
;
}
nsresult
Open
(
)
;
nsresult
AugmentAdds
(
const
nsTArray
<
uint32_t
>
&
aPrefixes
)
;
ChunkSet
&
AddChunks
(
)
;
ChunkSet
&
SubChunks
(
)
;
AddPrefixArray
&
AddPrefixes
(
)
{
return
mAddPrefixes
;
}
SubPrefixArray
&
SubPrefixes
(
)
{
return
mSubPrefixes
;
}
AddCompleteArray
&
AddCompletes
(
)
;
SubCompleteArray
&
SubCompletes
(
)
;
nsresult
BeginUpdate
(
)
;
nsresult
ApplyUpdate
(
TableUpdate
&
aUpdate
)
;
nsresult
Expire
(
)
;
nsresult
Rebuild
(
)
;
nsresult
WriteFile
(
)
;
void
ClearCompletes
(
)
;
private
:
nsresult
Reset
(
)
;
nsresult
ReadHeader
(
)
;
nsresult
SanityCheck
(
)
;
nsresult
CalculateChecksum
(
nsAutoCString
&
aChecksum
uint32_t
aFileSize
bool
aChecksumPresent
)
;
nsresult
CheckChecksum
(
uint32_t
aFileSize
)
;
void
UpdateHeader
(
)
;
nsresult
ReadCompletions
(
)
;
nsresult
ReadChunkNumbers
(
)
;
nsresult
ReadHashes
(
)
;
nsresult
ReadAddPrefixes
(
)
;
nsresult
ReadSubPrefixes
(
)
;
nsresult
WriteAddPrefixes
(
nsIOutputStream
*
aOut
)
;
nsresult
WriteSubPrefixes
(
nsIOutputStream
*
aOut
)
;
nsresult
ProcessSubs
(
)
;
nsresult
PrepareForUpdate
(
)
;
bool
AlreadyReadChunkNumbers
(
)
;
bool
AlreadyReadCompletions
(
)
;
struct
Header
{
uint32_t
magic
;
uint32_t
version
;
uint32_t
numAddChunks
;
uint32_t
numSubChunks
;
uint32_t
numAddPrefixes
;
uint32_t
numSubPrefixes
;
uint32_t
numAddCompletes
;
uint32_t
numSubCompletes
;
}
;
Header
mHeader
;
nsCString
mTableName
;
nsCOMPtr
<
nsIFile
>
mStoreDirectory
;
bool
mInUpdate
;
nsCOMPtr
<
nsIInputStream
>
mInputStream
;
ChunkSet
mAddChunks
;
ChunkSet
mSubChunks
;
ChunkSet
mAddExpirations
;
ChunkSet
mSubExpirations
;
AddPrefixArray
mAddPrefixes
;
SubPrefixArray
mSubPrefixes
;
AddCompleteArray
mAddCompletes
;
SubCompleteArray
mSubCompletes
;
uint32_t
mFileSize
;
friend
class
PerProviderDirectoryTestUtils
;
}
;
}
}
#
endif
