#
include
"
LookupCacheV4
.
h
"
#
include
"
HashStore
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
string
>
extern
mozilla
:
:
LazyLogModule
gUrlClassifierDbServiceLog
;
#
define
LOG
(
args
)
MOZ_LOG
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
MOZ_LOG_TEST
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
)
#
define
METADATA_SUFFIX
NS_LITERAL_CSTRING
(
"
.
metadata
"
)
namespace
mozilla
{
namespace
safebrowsing
{
const
int
LookupCacheV4
:
:
VER
=
4
;
class
VLPrefixSet
{
public
:
explicit
VLPrefixSet
(
const
PrefixStringMap
&
aMap
)
;
explicit
VLPrefixSet
(
const
TableUpdateV4
:
:
PrefixStdStringMap
&
aMap
)
;
void
Merge
(
PrefixStringMap
&
aPrefixMap
)
;
bool
GetSmallestPrefix
(
nsDependentCSubstring
&
aOutString
)
;
uint32_t
Count
(
)
const
{
return
mCount
;
}
private
:
struct
PrefixString
{
PrefixString
(
const
nsACString
&
aStr
uint32_t
aSize
)
:
pos
(
0
)
size
(
aSize
)
{
data
.
Rebind
(
aStr
.
BeginReading
(
)
aStr
.
Length
(
)
)
;
}
const
char
*
get
(
)
{
return
pos
<
data
.
Length
(
)
?
data
.
BeginReading
(
)
+
pos
:
nullptr
;
}
void
next
(
)
{
pos
+
=
size
;
}
uint32_t
remaining
(
)
{
return
data
.
Length
(
)
-
pos
;
}
nsDependentCSubstring
data
;
uint32_t
pos
;
uint32_t
size
;
}
;
nsClassHashtable
<
nsUint32HashKey
PrefixString
>
mMap
;
uint32_t
mCount
;
}
;
nsresult
LookupCacheV4
:
:
Init
(
)
{
mVLPrefixSet
=
new
VariableLengthPrefixSet
(
)
;
nsresult
rv
=
mVLPrefixSet
-
>
Init
(
mTableName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
LookupCacheV4
:
:
Has
(
const
Completion
&
aCompletion
bool
*
aHas
uint32_t
*
aMatchLength
bool
*
aConfirmed
)
{
*
aHas
=
*
aConfirmed
=
false
;
*
aMatchLength
=
0
;
uint32_t
length
=
0
;
nsDependentCSubstring
fullhash
;
fullhash
.
Rebind
(
(
const
char
*
)
aCompletion
.
buf
COMPLETE_SIZE
)
;
nsresult
rv
=
mVLPrefixSet
-
>
Matches
(
fullhash
&
length
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
length
=
=
0
|
|
(
length
>
=
PREFIX_SIZE
&
&
length
<
=
COMPLETE_SIZE
)
)
;
*
aHas
=
length
>
=
PREFIX_SIZE
;
*
aMatchLength
=
length
;
if
(
LOG_ENABLED
(
)
)
{
uint32_t
prefix
=
aCompletion
.
ToUint32
(
)
;
LOG
(
(
"
Probe
in
V4
%
s
:
%
X
found
%
d
complete
%
d
"
mTableName
.
get
(
)
prefix
*
aHas
length
=
=
COMPLETE_SIZE
)
)
;
}
if
(
!
(
*
aHas
)
)
{
return
NS_OK
;
}
return
CheckCache
(
aCompletion
aHas
aConfirmed
)
;
}
bool
LookupCacheV4
:
:
IsEmpty
(
)
{
bool
isEmpty
;
mVLPrefixSet
-
>
IsEmpty
(
&
isEmpty
)
;
return
isEmpty
;
}
nsresult
LookupCacheV4
:
:
Build
(
PrefixStringMap
&
aPrefixMap
)
{
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
URLCLASSIFIER_VLPS_CONSTRUCT_TIME
>
timer
;
return
mVLPrefixSet
-
>
SetPrefixes
(
aPrefixMap
)
;
}
nsresult
LookupCacheV4
:
:
GetPrefixes
(
PrefixStringMap
&
aPrefixMap
)
{
return
mVLPrefixSet
-
>
GetPrefixes
(
aPrefixMap
)
;
}
nsresult
LookupCacheV4
:
:
GetFixedLengthPrefixes
(
FallibleTArray
<
uint32_t
>
&
aPrefixes
)
{
return
mVLPrefixSet
-
>
GetFixedLengthPrefixes
(
aPrefixes
)
;
}
nsresult
LookupCacheV4
:
:
ClearPrefixes
(
)
{
PrefixStringMap
map
;
return
mVLPrefixSet
-
>
SetPrefixes
(
map
)
;
}
nsresult
LookupCacheV4
:
:
StoreToFile
(
nsIFile
*
aFile
)
{
return
mVLPrefixSet
-
>
StoreToFile
(
aFile
)
;
}
nsresult
LookupCacheV4
:
:
LoadFromFile
(
nsIFile
*
aFile
)
{
nsresult
rv
=
mVLPrefixSet
-
>
LoadFromFile
(
aFile
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCString
state
checksum
;
rv
=
LoadMetadata
(
state
checksum
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
VerifyChecksum
(
checksum
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
URLCLASSIFIER_VLPS_LOAD_CORRUPT
rv
=
=
NS_ERROR_FILE_CORRUPTED
)
;
return
rv
;
}
size_t
LookupCacheV4
:
:
SizeOfPrefixSet
(
)
{
return
mVLPrefixSet
-
>
SizeOfIncludingThis
(
moz_malloc_size_of
)
;
}
static
void
AppendPrefixToMap
(
PrefixStringMap
&
prefixes
nsDependentCSubstring
&
prefix
)
{
if
(
!
prefix
.
Length
(
)
)
{
return
;
}
nsCString
*
prefixString
=
prefixes
.
LookupOrAdd
(
prefix
.
Length
(
)
)
;
prefixString
-
>
Append
(
prefix
.
BeginReading
(
)
prefix
.
Length
(
)
)
;
}
static
void
UpdateChecksum
(
nsICryptoHash
*
aCrypto
const
nsACString
&
aPrefix
)
{
MOZ_ASSERT
(
aCrypto
)
;
aCrypto
-
>
Update
(
reinterpret_cast
<
uint8_t
*
>
(
const_cast
<
char
*
>
(
aPrefix
.
BeginReading
(
)
)
)
aPrefix
.
Length
(
)
)
;
}
nsresult
LookupCacheV4
:
:
ApplyUpdate
(
TableUpdateV4
*
aTableUpdate
PrefixStringMap
&
aInputMap
PrefixStringMap
&
aOutputMap
)
{
MOZ_ASSERT
(
aOutputMap
.
IsEmpty
(
)
)
;
nsCOMPtr
<
nsICryptoHash
>
crypto
;
nsresult
rv
=
InitCrypto
(
crypto
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
VLPrefixSet
oldPSet
(
aInputMap
)
;
VLPrefixSet
addPSet
(
aTableUpdate
-
>
Prefixes
(
)
)
;
TableUpdateV4
:
:
RemovalIndiceArray
&
removalArray
=
aTableUpdate
-
>
RemovalIndices
(
)
;
uint32_t
removalIndex
=
0
;
int32_t
numOldPrefixPicked
=
-
1
;
nsDependentCSubstring
smallestOldPrefix
;
nsDependentCSubstring
smallestAddPrefix
;
bool
isOldMapEmpty
=
false
isAddMapEmpty
=
false
;
int32_t
index
=
oldPSet
.
Count
(
)
+
addPSet
.
Count
(
)
+
1
;
for
(
;
index
>
0
;
index
-
-
)
{
if
(
smallestOldPrefix
.
IsEmpty
(
)
&
&
!
isOldMapEmpty
)
{
isOldMapEmpty
=
!
oldPSet
.
GetSmallestPrefix
(
smallestOldPrefix
)
;
}
if
(
smallestAddPrefix
.
IsEmpty
(
)
&
&
!
isAddMapEmpty
)
{
isAddMapEmpty
=
!
addPSet
.
GetSmallestPrefix
(
smallestAddPrefix
)
;
}
bool
pickOld
;
if
(
!
isOldMapEmpty
&
&
!
isAddMapEmpty
)
{
if
(
smallestOldPrefix
=
=
smallestAddPrefix
)
{
LOG
(
(
"
Add
prefix
should
not
exist
in
the
original
prefix
set
.
"
)
)
;
return
NS_ERROR_UC_UPDATE_DUPLICATE_PREFIX
;
}
pickOld
=
smallestOldPrefix
<
smallestAddPrefix
;
}
else
if
(
!
isOldMapEmpty
&
&
isAddMapEmpty
)
{
pickOld
=
true
;
}
else
if
(
isOldMapEmpty
&
&
!
isAddMapEmpty
)
{
pickOld
=
false
;
}
else
{
break
;
}
if
(
pickOld
)
{
numOldPrefixPicked
+
+
;
if
(
removalIndex
<
removalArray
.
Length
(
)
&
&
numOldPrefixPicked
=
=
removalArray
[
removalIndex
]
)
{
removalIndex
+
+
;
}
else
{
AppendPrefixToMap
(
aOutputMap
smallestOldPrefix
)
;
UpdateChecksum
(
crypto
smallestOldPrefix
)
;
}
smallestOldPrefix
.
SetLength
(
0
)
;
}
else
{
AppendPrefixToMap
(
aOutputMap
smallestAddPrefix
)
;
UpdateChecksum
(
crypto
smallestAddPrefix
)
;
smallestAddPrefix
.
SetLength
(
0
)
;
}
}
if
(
index
<
=
0
)
{
LOG
(
(
"
There
are
still
prefixes
remaining
after
reaching
maximum
runs
.
"
)
)
;
return
NS_ERROR_UC_UPDATE_INFINITE_LOOP
;
}
if
(
removalIndex
<
removalArray
.
Length
(
)
)
{
LOG
(
(
"
There
are
still
prefixes
to
remove
after
exhausting
the
old
PrefixSet
.
"
)
)
;
return
NS_ERROR_UC_UPDATE_WRONG_REMOVAL_INDICES
;
}
nsAutoCString
checksum
;
crypto
-
>
Finish
(
false
checksum
)
;
if
(
aTableUpdate
-
>
Checksum
(
)
.
IsEmpty
(
)
)
{
LOG
(
(
"
Update
checksum
missing
.
"
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
URLCLASSIFIER_UPDATE_ERROR
mProvider
NS_ERROR_GET_CODE
(
NS_ERROR_UC_UPDATE_MISSING_CHECKSUM
)
)
;
std
:
:
string
stdChecksum
(
checksum
.
BeginReading
(
)
checksum
.
Length
(
)
)
;
aTableUpdate
-
>
NewChecksum
(
stdChecksum
)
;
}
else
if
(
aTableUpdate
-
>
Checksum
(
)
!
=
checksum
)
{
LOG
(
(
"
Checksum
mismatch
after
applying
partial
update
"
)
)
;
return
NS_ERROR_UC_UPDATE_CHECKSUM_MISMATCH
;
}
return
NS_OK
;
}
nsresult
LookupCacheV4
:
:
AddFullHashResponseToCache
(
const
FullHashResponseMap
&
aResponseMap
)
{
for
(
auto
iter
=
aResponseMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
CachedFullHashResponse
*
response
=
mCache
.
LookupOrAdd
(
iter
.
Key
(
)
)
;
*
response
=
*
(
iter
.
Data
(
)
)
;
}
return
NS_OK
;
}
nsresult
LookupCacheV4
:
:
InitCrypto
(
nsCOMPtr
<
nsICryptoHash
>
&
aCrypto
)
{
nsresult
rv
;
aCrypto
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aCrypto
-
>
Init
(
nsICryptoHash
:
:
SHA256
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
InitCrypto
failed
"
)
;
return
rv
;
}
nsresult
LookupCacheV4
:
:
VerifyChecksum
(
const
nsACString
&
aChecksum
)
{
nsCOMPtr
<
nsICryptoHash
>
crypto
;
nsresult
rv
=
InitCrypto
(
crypto
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
PrefixStringMap
map
;
mVLPrefixSet
-
>
GetPrefixes
(
map
)
;
VLPrefixSet
loadPSet
(
map
)
;
uint32_t
index
=
loadPSet
.
Count
(
)
+
1
;
for
(
;
index
>
0
;
index
-
-
)
{
nsDependentCSubstring
prefix
;
if
(
!
loadPSet
.
GetSmallestPrefix
(
prefix
)
)
{
break
;
}
UpdateChecksum
(
crypto
prefix
)
;
}
nsAutoCString
checksum
;
crypto
-
>
Finish
(
false
checksum
)
;
if
(
checksum
!
=
aChecksum
)
{
LOG
(
(
"
Checksum
mismatch
when
loading
prefixes
from
file
.
"
)
)
;
return
NS_ERROR_FILE_CORRUPTED
;
}
return
NS_OK
;
}
namespace
{
template
<
typename
T
>
struct
ValueTraits
{
static
uint32_t
Length
(
const
T
&
aValue
)
{
return
sizeof
(
T
)
;
}
static
char
*
WritePtr
(
T
&
aValue
uint32_t
aLength
)
{
return
(
char
*
)
&
aValue
;
}
static
const
char
*
ReadPtr
(
const
T
&
aValue
)
{
return
(
char
*
)
&
aValue
;
}
static
bool
IsFixedLength
(
)
{
return
true
;
}
}
;
template
<
>
struct
ValueTraits
<
nsACString
>
{
static
bool
IsFixedLength
(
)
{
return
false
;
}
static
uint32_t
Length
(
const
nsACString
&
aValue
)
{
return
aValue
.
Length
(
)
;
}
static
char
*
WritePtr
(
nsACString
&
aValue
uint32_t
aLength
)
{
aValue
.
SetLength
(
aLength
)
;
return
aValue
.
BeginWriting
(
)
;
}
static
const
char
*
ReadPtr
(
const
nsACString
&
aValue
)
{
return
aValue
.
BeginReading
(
)
;
}
}
;
template
<
typename
T
>
static
nsresult
WriteValue
(
nsIOutputStream
*
aOutputStream
const
T
&
aValue
)
{
uint32_t
writeLength
=
ValueTraits
<
T
>
:
:
Length
(
aValue
)
;
if
(
!
ValueTraits
<
T
>
:
:
IsFixedLength
(
)
)
{
nsresult
rv
=
WriteValue
(
aOutputStream
writeLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
auto
valueReadPtr
=
ValueTraits
<
T
>
:
:
ReadPtr
(
aValue
)
;
uint32_t
written
;
nsresult
rv
=
aOutputStream
-
>
Write
(
valueReadPtr
writeLength
&
written
)
;
if
(
NS_FAILED
(
rv
)
|
|
written
!
=
writeLength
)
{
LOG
(
(
"
Failed
to
write
the
value
.
"
)
)
;
return
NS_FAILED
(
rv
)
?
rv
:
NS_ERROR_FAILURE
;
}
return
rv
;
}
template
<
typename
T
>
static
nsresult
ReadValue
(
nsIInputStream
*
aInputStream
T
&
aValue
)
{
nsresult
rv
;
uint32_t
readLength
;
if
(
ValueTraits
<
T
>
:
:
IsFixedLength
(
)
)
{
readLength
=
ValueTraits
<
T
>
:
:
Length
(
aValue
)
;
}
else
{
nsresult
rv
=
ReadValue
(
aInputStream
readLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
uint32_t
read
;
auto
valueWritePtr
=
ValueTraits
<
T
>
:
:
WritePtr
(
aValue
readLength
)
;
rv
=
aInputStream
-
>
Read
(
valueWritePtr
readLength
&
read
)
;
if
(
NS_FAILED
(
rv
)
|
|
read
!
=
readLength
)
{
LOG
(
(
"
Failed
to
read
the
value
.
"
)
)
;
return
NS_FAILED
(
rv
)
?
rv
:
NS_ERROR_FAILURE
;
}
return
rv
;
}
}
nsresult
LookupCacheV4
:
:
WriteMetadata
(
TableUpdateV4
*
aTableUpdate
)
{
NS_ENSURE_ARG_POINTER
(
aTableUpdate
)
;
if
(
nsUrlClassifierDBService
:
:
ShutdownHasStarted
(
)
)
{
return
NS_ERROR_ABORT
;
}
nsCOMPtr
<
nsIFile
>
metaFile
;
nsresult
rv
=
mStoreDirectory
-
>
Clone
(
getter_AddRefs
(
metaFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
metaFile
-
>
AppendNative
(
mTableName
+
METADATA_SUFFIX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIOutputStream
>
outputStream
;
rv
=
NS_NewLocalFileOutputStream
(
getter_AddRefs
(
outputStream
)
metaFile
PR_WRONLY
|
PR_TRUNCATE
|
PR_CREATE_FILE
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
Unable
to
create
file
to
store
metadata
.
"
)
)
;
return
rv
;
}
rv
=
WriteValue
(
outputStream
aTableUpdate
-
>
ClientState
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
write
the
list
state
.
"
)
)
;
return
rv
;
}
rv
=
WriteValue
(
outputStream
aTableUpdate
-
>
Checksum
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
write
the
list
checksum
.
"
)
)
;
return
rv
;
}
return
rv
;
}
nsresult
LookupCacheV4
:
:
LoadMetadata
(
nsACString
&
aState
nsACString
&
aChecksum
)
{
nsCOMPtr
<
nsIFile
>
metaFile
;
nsresult
rv
=
mStoreDirectory
-
>
Clone
(
getter_AddRefs
(
metaFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
metaFile
-
>
AppendNative
(
mTableName
+
METADATA_SUFFIX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
localInFile
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
localInFile
)
metaFile
PR_RDONLY
|
nsIFile
:
:
OS_READAHEAD
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Unable
to
open
metadata
file
.
"
)
)
;
return
rv
;
}
rv
=
ReadValue
(
localInFile
aState
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
read
state
.
"
)
)
;
return
rv
;
}
rv
=
ReadValue
(
localInFile
aChecksum
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
read
checksum
.
"
)
)
;
return
rv
;
}
return
rv
;
}
VLPrefixSet
:
:
VLPrefixSet
(
const
PrefixStringMap
&
aMap
)
:
mCount
(
0
)
{
for
(
auto
iter
=
aMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
uint32_t
size
=
iter
.
Key
(
)
;
mMap
.
Put
(
size
new
PrefixString
(
*
iter
.
Data
(
)
size
)
)
;
mCount
+
=
iter
.
Data
(
)
-
>
Length
(
)
/
size
;
}
}
VLPrefixSet
:
:
VLPrefixSet
(
const
TableUpdateV4
:
:
PrefixStdStringMap
&
aMap
)
:
mCount
(
0
)
{
for
(
auto
iter
=
aMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
uint32_t
size
=
iter
.
Key
(
)
;
mMap
.
Put
(
size
new
PrefixString
(
iter
.
Data
(
)
-
>
GetPrefixString
(
)
size
)
)
;
mCount
+
=
iter
.
Data
(
)
-
>
GetPrefixString
(
)
.
Length
(
)
/
size
;
}
}
void
VLPrefixSet
:
:
Merge
(
PrefixStringMap
&
aPrefixMap
)
{
for
(
auto
iter
=
mMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsCString
*
prefixString
=
aPrefixMap
.
LookupOrAdd
(
iter
.
Key
(
)
)
;
PrefixString
*
str
=
iter
.
Data
(
)
;
if
(
str
-
>
get
(
)
)
{
prefixString
-
>
Append
(
str
-
>
get
(
)
str
-
>
remaining
(
)
)
;
}
}
}
bool
VLPrefixSet
:
:
GetSmallestPrefix
(
nsDependentCSubstring
&
aOutString
)
{
PrefixString
*
pick
=
nullptr
;
for
(
auto
iter
=
mMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
PrefixString
*
str
=
iter
.
Data
(
)
;
if
(
!
str
-
>
get
(
)
)
{
continue
;
}
if
(
aOutString
.
IsEmpty
(
)
)
{
aOutString
.
Rebind
(
str
-
>
get
(
)
iter
.
Key
(
)
)
;
pick
=
str
;
continue
;
}
nsDependentCSubstring
cur
(
str
-
>
get
(
)
iter
.
Key
(
)
)
;
if
(
cur
<
aOutString
)
{
aOutString
.
Rebind
(
str
-
>
get
(
)
iter
.
Key
(
)
)
;
pick
=
str
;
}
}
if
(
pick
)
{
pick
-
>
next
(
)
;
}
return
pick
!
=
nullptr
;
}
}
}
