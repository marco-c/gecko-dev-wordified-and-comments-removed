#
include
"
LookupCacheV4
.
h
"
#
include
"
HashStore
.
h
"
extern
mozilla
:
:
LazyLogModule
gUrlClassifierDbServiceLog
;
#
define
LOG
(
args
)
MOZ_LOG
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
MOZ_LOG_TEST
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
)
namespace
mozilla
{
namespace
safebrowsing
{
const
int
LookupCacheV4
:
:
VER
=
4
;
class
VLPrefixSet
{
public
:
explicit
VLPrefixSet
(
const
PrefixStringMap
&
aMap
)
;
explicit
VLPrefixSet
(
const
TableUpdateV4
:
:
PrefixStdStringMap
&
aMap
)
;
void
Merge
(
PrefixStringMap
&
aPrefixMap
)
;
bool
GetSmallestPrefix
(
nsDependentCSubstring
&
aOutString
)
;
uint32_t
Count
(
)
const
{
return
mCount
;
}
private
:
struct
PrefixString
{
PrefixString
(
const
nsACString
&
aStr
uint32_t
aSize
)
:
pos
(
0
)
size
(
aSize
)
{
data
.
Rebind
(
aStr
.
BeginReading
(
)
aStr
.
Length
(
)
)
;
}
const
char
*
get
(
)
{
return
pos
<
data
.
Length
(
)
?
data
.
BeginReading
(
)
+
pos
:
nullptr
;
}
void
next
(
)
{
pos
+
=
size
;
}
uint32_t
remaining
(
)
{
return
data
.
Length
(
)
-
pos
;
}
nsDependentCSubstring
data
;
uint32_t
pos
;
uint32_t
size
;
}
;
nsClassHashtable
<
nsUint32HashKey
PrefixString
>
mMap
;
uint32_t
mCount
;
}
;
nsresult
LookupCacheV4
:
:
Init
(
)
{
mVLPrefixSet
=
new
VariableLengthPrefixSet
(
)
;
nsresult
rv
=
mVLPrefixSet
-
>
Init
(
mTableName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
LookupCacheV4
:
:
Has
(
const
Completion
&
aCompletion
bool
*
aHas
bool
*
aComplete
)
{
*
aHas
=
false
;
return
NS_OK
;
}
nsresult
LookupCacheV4
:
:
Build
(
PrefixStringMap
&
aPrefixMap
)
{
return
mVLPrefixSet
-
>
SetPrefixes
(
aPrefixMap
)
;
}
nsresult
LookupCacheV4
:
:
GetPrefixes
(
PrefixStringMap
&
aPrefixMap
)
{
return
mVLPrefixSet
-
>
GetPrefixes
(
aPrefixMap
)
;
}
nsresult
LookupCacheV4
:
:
ClearPrefixes
(
)
{
PrefixStringMap
map
;
return
mVLPrefixSet
-
>
SetPrefixes
(
map
)
;
}
nsresult
LookupCacheV4
:
:
StoreToFile
(
nsIFile
*
aFile
)
{
return
mVLPrefixSet
-
>
StoreToFile
(
aFile
)
;
}
nsresult
LookupCacheV4
:
:
LoadFromFile
(
nsIFile
*
aFile
)
{
return
mVLPrefixSet
-
>
LoadFromFile
(
aFile
)
;
}
size_t
LookupCacheV4
:
:
SizeOfPrefixSet
(
)
{
return
mVLPrefixSet
-
>
SizeOfIncludingThis
(
moz_malloc_size_of
)
;
}
static
void
AppendPrefixToMap
(
PrefixStringMap
&
prefixes
nsDependentCSubstring
&
prefix
)
{
if
(
!
prefix
.
Length
(
)
)
{
return
;
}
nsCString
*
prefixString
=
prefixes
.
LookupOrAdd
(
prefix
.
Length
(
)
)
;
prefixString
-
>
Append
(
prefix
.
BeginReading
(
)
prefix
.
Length
(
)
)
;
}
nsresult
LookupCacheV4
:
:
ApplyPartialUpdate
(
TableUpdateV4
*
aTableUpdate
PrefixStringMap
&
aInputMap
PrefixStringMap
&
aOutputMap
)
{
MOZ_ASSERT
(
aOutputMap
.
IsEmpty
(
)
)
;
VLPrefixSet
oldPSet
(
aInputMap
)
;
VLPrefixSet
addPSet
(
aTableUpdate
-
>
Prefixes
(
)
)
;
TableUpdateV4
:
:
RemovalIndiceArray
&
removalArray
=
aTableUpdate
-
>
RemovalIndices
(
)
;
uint32_t
removalIndex
=
0
;
int32_t
numOldPrefixPicked
=
-
1
;
nsDependentCSubstring
smallestOldPrefix
;
nsDependentCSubstring
smallestAddPrefix
;
uint32_t
index
=
oldPSet
.
Count
(
)
+
addPSet
.
Count
(
)
+
1
;
for
(
;
index
>
0
;
index
-
-
)
{
if
(
smallestOldPrefix
.
IsEmpty
(
)
)
{
if
(
!
oldPSet
.
GetSmallestPrefix
(
smallestOldPrefix
)
)
{
AppendPrefixToMap
(
aOutputMap
smallestAddPrefix
)
;
addPSet
.
Merge
(
aOutputMap
)
;
break
;
}
}
if
(
smallestAddPrefix
.
IsEmpty
(
)
)
{
if
(
!
addPSet
.
GetSmallestPrefix
(
smallestAddPrefix
)
&
&
removalIndex
>
=
removalArray
.
Length
(
)
)
{
AppendPrefixToMap
(
aOutputMap
smallestOldPrefix
)
;
oldPSet
.
Merge
(
aOutputMap
)
;
break
;
}
}
if
(
smallestOldPrefix
<
smallestAddPrefix
|
|
smallestAddPrefix
.
IsEmpty
(
)
)
{
numOldPrefixPicked
+
+
;
if
(
removalIndex
<
removalArray
.
Length
(
)
&
&
numOldPrefixPicked
=
=
removalArray
[
removalIndex
]
)
{
removalIndex
+
+
;
}
else
{
AppendPrefixToMap
(
aOutputMap
smallestOldPrefix
)
;
}
smallestOldPrefix
.
SetLength
(
0
)
;
}
else
if
(
smallestOldPrefix
>
smallestAddPrefix
|
|
smallestOldPrefix
.
IsEmpty
(
)
)
{
AppendPrefixToMap
(
aOutputMap
smallestAddPrefix
)
;
smallestAddPrefix
.
SetLength
(
0
)
;
}
else
{
NS_WARNING
(
"
Add
prefix
should
not
exist
in
the
original
prefix
set
.
"
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
URLCLASSIFIER_UPDATE_ERROR_TYPE
DUPLICATE_PREFIX
)
;
return
NS_ERROR_FAILURE
;
}
}
if
(
index
<
=
0
)
{
NS_WARNING
(
"
There
are
still
prefixes
remaining
after
reaching
maximum
runs
.
"
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
URLCLASSIFIER_UPDATE_ERROR_TYPE
INFINITE_LOOP
)
;
return
NS_ERROR_FAILURE
;
}
if
(
removalIndex
<
removalArray
.
Length
(
)
)
{
NS_WARNING
(
"
There
are
still
prefixes
to
remove
after
exhausting
the
old
PrefixSet
.
"
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
URLCLASSIFIER_UPDATE_ERROR_TYPE
WRONG_REMOVAL_INDICES
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
VLPrefixSet
:
:
VLPrefixSet
(
const
PrefixStringMap
&
aMap
)
:
mCount
(
0
)
{
for
(
auto
iter
=
aMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
uint32_t
size
=
iter
.
Key
(
)
;
mMap
.
Put
(
size
new
PrefixString
(
*
iter
.
Data
(
)
size
)
)
;
mCount
+
=
iter
.
Data
(
)
-
>
Length
(
)
/
size
;
}
}
VLPrefixSet
:
:
VLPrefixSet
(
const
TableUpdateV4
:
:
PrefixStdStringMap
&
aMap
)
:
mCount
(
0
)
{
for
(
auto
iter
=
aMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
uint32_t
size
=
iter
.
Key
(
)
;
mMap
.
Put
(
size
new
PrefixString
(
iter
.
Data
(
)
-
>
GetPrefixString
(
)
size
)
)
;
mCount
+
=
iter
.
Data
(
)
-
>
GetPrefixString
(
)
.
Length
(
)
/
size
;
}
}
void
VLPrefixSet
:
:
Merge
(
PrefixStringMap
&
aPrefixMap
)
{
for
(
auto
iter
=
mMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsCString
*
prefixString
=
aPrefixMap
.
LookupOrAdd
(
iter
.
Key
(
)
)
;
PrefixString
*
str
=
iter
.
Data
(
)
;
if
(
str
-
>
get
(
)
)
{
prefixString
-
>
Append
(
str
-
>
get
(
)
str
-
>
remaining
(
)
)
;
}
}
}
bool
VLPrefixSet
:
:
GetSmallestPrefix
(
nsDependentCSubstring
&
aOutString
)
{
PrefixString
*
pick
=
nullptr
;
for
(
auto
iter
=
mMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
PrefixString
*
str
=
iter
.
Data
(
)
;
if
(
!
str
-
>
get
(
)
)
{
continue
;
}
if
(
aOutString
.
IsEmpty
(
)
)
{
aOutString
.
Rebind
(
str
-
>
get
(
)
iter
.
Key
(
)
)
;
pick
=
str
;
continue
;
}
nsDependentCSubstring
cur
(
str
-
>
get
(
)
iter
.
Key
(
)
)
;
if
(
cur
<
aOutString
)
{
aOutString
.
Rebind
(
str
-
>
get
(
)
iter
.
Key
(
)
)
;
pick
=
str
;
}
}
if
(
pick
)
{
pick
-
>
next
(
)
;
}
return
pick
!
=
nullptr
;
}
}
}
