#
include
"
LookupCacheV4
.
h
"
#
include
"
HashStore
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCheckSummedOutputStream
.
h
"
#
include
"
crc32c
.
h
"
#
include
<
string
>
extern
mozilla
:
:
LazyLogModule
gUrlClassifierDbServiceLog
;
#
define
LOG
(
args
)
\
MOZ_LOG
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
\
MOZ_LOG_TEST
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
)
#
define
METADATA_SUFFIX
NS_LITERAL_CSTRING
(
"
.
metadata
"
)
namespace
mozilla
{
namespace
safebrowsing
{
const
int
LookupCacheV4
:
:
VER
=
4
;
const
uint32_t
LookupCacheV4
:
:
VLPSET_MAGIC
=
0x36044a35
;
const
uint32_t
LookupCacheV4
:
:
VLPSET_VERSION
=
1
;
const
uint32_t
LookupCacheV4
:
:
MAX_METADATA_VALUE_LENGTH
=
256
;
class
VLPrefixSet
{
public
:
explicit
VLPrefixSet
(
const
PrefixStringMap
&
aMap
)
;
void
Merge
(
PrefixStringMap
&
aPrefixMap
)
;
bool
GetSmallestPrefix
(
nsACString
&
aOutString
)
const
;
uint32_t
Count
(
)
const
{
return
mCount
;
}
private
:
struct
PrefixString
{
PrefixString
(
const
nsACString
&
aStr
uint32_t
aSize
)
:
data
(
aStr
)
pos
(
0
)
size
(
aSize
)
{
MOZ_ASSERT
(
data
.
Length
(
)
%
size
=
=
0
"
PrefixString
length
must
be
a
multiple
of
the
prefix
size
.
"
)
;
}
void
getRemainingString
(
nsACString
&
out
)
{
MOZ_ASSERT
(
out
.
IsEmpty
(
)
)
;
if
(
remaining
(
)
>
0
)
{
out
=
Substring
(
data
pos
)
;
}
}
void
getPrefix
(
nsACString
&
out
)
{
MOZ_ASSERT
(
out
.
IsEmpty
(
)
)
;
if
(
remaining
(
)
>
=
size
)
{
out
=
Substring
(
data
pos
size
)
;
}
else
{
MOZ_ASSERT
(
remaining
(
)
=
=
0
"
Remaining
bytes
but
not
enough
for
a
(
size
)
-
byte
prefix
.
"
)
;
}
}
void
next
(
)
{
pos
+
=
size
;
MOZ_ASSERT
(
pos
<
=
data
.
Length
(
)
)
;
}
uint32_t
remaining
(
)
{
return
data
.
Length
(
)
-
pos
;
MOZ_ASSERT
(
pos
<
=
data
.
Length
(
)
)
;
}
nsCString
data
;
uint32_t
pos
;
uint32_t
size
;
}
;
nsClassHashtable
<
nsUint32HashKey
PrefixString
>
mMap
;
uint32_t
mCount
;
}
;
nsresult
LookupCacheV4
:
:
Has
(
const
Completion
&
aCompletion
bool
*
aHas
uint32_t
*
aMatchLength
bool
*
aConfirmed
)
{
*
aHas
=
*
aConfirmed
=
false
;
*
aMatchLength
=
0
;
uint32_t
length
=
0
;
nsDependentCSubstring
fullhash
;
fullhash
.
Rebind
(
(
const
char
*
)
aCompletion
.
buf
COMPLETE_SIZE
)
;
uint32_t
prefix
=
BigEndian
:
:
readUint32
(
reinterpret_cast
<
const
uint32_t
*
>
(
fullhash
.
BeginReading
(
)
)
)
;
nsresult
rv
=
mVLPrefixSet
-
>
Matches
(
prefix
fullhash
&
length
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
length
=
=
0
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
length
>
=
PREFIX_SIZE
&
&
length
<
=
COMPLETE_SIZE
)
;
*
aHas
=
true
;
*
aMatchLength
=
length
;
return
CheckCache
(
aCompletion
aHas
aConfirmed
)
;
}
nsresult
LookupCacheV4
:
:
Build
(
PrefixStringMap
&
aPrefixMap
)
{
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
URLCLASSIFIER_VLPS_CONSTRUCT_TIME
>
timer
;
nsresult
rv
=
mVLPrefixSet
-
>
SetPrefixes
(
aPrefixMap
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mPrimed
=
true
;
return
NS_OK
;
}
nsresult
LookupCacheV4
:
:
GetPrefixes
(
PrefixStringMap
&
aPrefixMap
)
{
if
(
!
mPrimed
)
{
LOG
(
(
"
GetPrefixes
from
empty
LookupCache
"
)
)
;
return
NS_OK
;
}
return
mVLPrefixSet
-
>
GetPrefixes
(
aPrefixMap
)
;
}
nsresult
LookupCacheV4
:
:
GetFixedLengthPrefixes
(
FallibleTArray
<
uint32_t
>
&
aPrefixes
)
{
return
mVLPrefixSet
-
>
GetFixedLengthPrefixes
(
&
aPrefixes
nullptr
)
;
}
nsresult
LookupCacheV4
:
:
ClearLegacyFile
(
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
mStoreDirectory
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
file
-
>
AppendNative
(
mTableName
+
NS_LITERAL_CSTRING
(
"
.
pset
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
exists
;
rv
=
file
-
>
Exists
(
&
exists
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
exists
)
{
rv
=
file
-
>
Remove
(
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
LOG
(
(
"
[
%
s
]
Old
PrefixSet
is
succuessfully
removed
!
"
mTableName
.
get
(
)
)
)
;
}
return
NS_OK
;
}
nsresult
LookupCacheV4
:
:
LoadLegacyFile
(
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
mStoreDirectory
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
file
-
>
AppendNative
(
mTableName
+
NS_LITERAL_CSTRING
(
"
.
pset
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
exists
;
rv
=
file
-
>
Exists
(
&
exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
exists
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIInputStream
>
localInFile
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
localInFile
)
file
PR_RDONLY
|
nsIFile
:
:
OS_READAHEAD
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
int64_t
fileSize
;
rv
=
file
-
>
GetFileSize
(
&
fileSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
fileSize
<
0
|
|
fileSize
>
UINT32_MAX
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
bufferSize
=
std
:
:
min
<
uint32_t
>
(
static_cast
<
uint32_t
>
(
fileSize
)
MAX_BUFFER_SIZE
)
;
nsCOMPtr
<
nsIInputStream
>
in
;
rv
=
NS_NewBufferedInputStream
(
getter_AddRefs
(
in
)
localInFile
.
forget
(
)
bufferSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mVLPrefixSet
-
>
LoadPrefixes
(
in
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mPrimed
=
true
;
LOG
(
(
"
[
%
s
]
Loading
Legacy
PrefixSet
successful
"
mTableName
.
get
(
)
)
)
;
return
NS_OK
;
}
void
LookupCacheV4
:
:
GetHeader
(
Header
&
aHeader
)
{
aHeader
.
magic
=
LookupCacheV4
:
:
VLPSET_MAGIC
;
aHeader
.
version
=
LookupCacheV4
:
:
VLPSET_VERSION
;
}
nsresult
LookupCacheV4
:
:
SanityCheck
(
const
Header
&
aHeader
)
{
if
(
aHeader
.
magic
!
=
LookupCacheV4
:
:
VLPSET_MAGIC
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
if
(
aHeader
.
version
!
=
LookupCacheV4
:
:
VLPSET_VERSION
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsCString
LookupCacheV4
:
:
GetPrefixSetSuffix
(
)
const
{
return
NS_LITERAL_CSTRING
(
"
.
vlpset
"
)
;
}
static
nsresult
AppendPrefixToMap
(
PrefixStringMap
&
prefixes
const
nsACString
&
prefix
)
{
uint32_t
len
=
prefix
.
Length
(
)
;
MOZ_ASSERT
(
len
>
=
PREFIX_SIZE
&
&
len
<
=
COMPLETE_SIZE
)
;
if
(
!
len
)
{
return
NS_OK
;
}
nsCString
*
prefixString
=
prefixes
.
LookupOrAdd
(
len
)
;
if
(
!
prefixString
-
>
Append
(
prefix
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
static
nsresult
InitCrypto
(
nsCOMPtr
<
nsICryptoHash
>
&
aCrypto
)
{
nsresult
rv
;
aCrypto
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aCrypto
-
>
Init
(
nsICryptoHash
:
:
SHA256
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
InitCrypto
failed
"
)
;
return
rv
;
}
static
void
UpdateSHA256
(
nsICryptoHash
*
aCrypto
const
nsACString
&
aPrefix
)
{
MOZ_ASSERT
(
aCrypto
)
;
aCrypto
-
>
Update
(
reinterpret_cast
<
uint8_t
*
>
(
const_cast
<
char
*
>
(
aPrefix
.
BeginReading
(
)
)
)
aPrefix
.
Length
(
)
)
;
}
nsresult
LookupCacheV4
:
:
ApplyUpdate
(
RefPtr
<
TableUpdateV4
>
aTableUpdate
PrefixStringMap
&
aInputMap
PrefixStringMap
&
aOutputMap
)
{
MOZ_ASSERT
(
aOutputMap
.
IsEmpty
(
)
)
;
nsCOMPtr
<
nsICryptoHash
>
crypto
;
nsresult
rv
=
InitCrypto
(
crypto
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
VLPrefixSet
oldPSet
(
aInputMap
)
;
VLPrefixSet
addPSet
(
aTableUpdate
-
>
Prefixes
(
)
)
;
const
TableUpdateV4
:
:
RemovalIndiceArray
&
removalArray
=
aTableUpdate
-
>
RemovalIndices
(
)
;
uint32_t
removalIndex
=
0
;
int32_t
numOldPrefixPicked
=
-
1
;
nsAutoCString
smallestOldPrefix
;
nsAutoCString
smallestAddPrefix
;
bool
isOldMapEmpty
=
false
isAddMapEmpty
=
false
;
int32_t
index
=
oldPSet
.
Count
(
)
+
addPSet
.
Count
(
)
+
1
;
for
(
;
index
>
0
;
index
-
-
)
{
if
(
smallestOldPrefix
.
IsEmpty
(
)
&
&
!
isOldMapEmpty
)
{
isOldMapEmpty
=
!
oldPSet
.
GetSmallestPrefix
(
smallestOldPrefix
)
;
}
if
(
smallestAddPrefix
.
IsEmpty
(
)
&
&
!
isAddMapEmpty
)
{
isAddMapEmpty
=
!
addPSet
.
GetSmallestPrefix
(
smallestAddPrefix
)
;
}
bool
pickOld
;
if
(
!
isOldMapEmpty
&
&
!
isAddMapEmpty
)
{
if
(
smallestOldPrefix
=
=
smallestAddPrefix
)
{
LOG
(
(
"
Add
prefix
should
not
exist
in
the
original
prefix
set
.
"
)
)
;
return
NS_ERROR_UC_UPDATE_DUPLICATE_PREFIX
;
}
pickOld
=
smallestOldPrefix
<
smallestAddPrefix
;
}
else
if
(
!
isOldMapEmpty
&
&
isAddMapEmpty
)
{
pickOld
=
true
;
}
else
if
(
isOldMapEmpty
&
&
!
isAddMapEmpty
)
{
pickOld
=
false
;
}
else
{
break
;
}
if
(
pickOld
)
{
numOldPrefixPicked
+
+
;
if
(
removalIndex
<
removalArray
.
Length
(
)
&
&
numOldPrefixPicked
=
=
removalArray
[
removalIndex
]
)
{
removalIndex
+
+
;
}
else
{
rv
=
AppendPrefixToMap
(
aOutputMap
smallestOldPrefix
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
UpdateSHA256
(
crypto
smallestOldPrefix
)
;
}
smallestOldPrefix
.
SetLength
(
0
)
;
}
else
{
rv
=
AppendPrefixToMap
(
aOutputMap
smallestAddPrefix
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
UpdateSHA256
(
crypto
smallestAddPrefix
)
;
smallestAddPrefix
.
SetLength
(
0
)
;
}
}
if
(
index
<
=
0
)
{
LOG
(
(
"
There
are
still
prefixes
remaining
after
reaching
maximum
runs
.
"
)
)
;
return
NS_ERROR_UC_UPDATE_INFINITE_LOOP
;
}
if
(
removalIndex
<
removalArray
.
Length
(
)
)
{
LOG
(
(
"
There
are
still
prefixes
to
remove
after
exhausting
the
old
"
"
PrefixSet
.
"
)
)
;
return
NS_ERROR_UC_UPDATE_WRONG_REMOVAL_INDICES
;
}
aTableUpdate
-
>
Clear
(
)
;
nsAutoCString
sha256
;
crypto
-
>
Finish
(
false
sha256
)
;
if
(
aTableUpdate
-
>
SHA256
(
)
.
IsEmpty
(
)
)
{
LOG
(
(
"
Update
sha256
hash
missing
.
"
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
URLCLASSIFIER_UPDATE_ERROR
mProvider
NS_ERROR_GET_CODE
(
NS_ERROR_UC_UPDATE_MISSING_CHECKSUM
)
)
;
std
:
:
string
stdSha256
(
sha256
.
BeginReading
(
)
sha256
.
Length
(
)
)
;
aTableUpdate
-
>
SetSHA256
(
stdSha256
)
;
}
else
if
(
aTableUpdate
-
>
SHA256
(
)
!
=
sha256
)
{
LOG
(
(
"
SHA256
hash
mismatch
after
applying
partial
update
"
)
)
;
return
NS_ERROR_UC_UPDATE_CHECKSUM_MISMATCH
;
}
return
NS_OK
;
}
nsresult
LookupCacheV4
:
:
AddFullHashResponseToCache
(
const
FullHashResponseMap
&
aResponseMap
)
{
CopyClassHashTable
<
FullHashResponseMap
>
(
aResponseMap
mFullHashCache
)
;
return
NS_OK
;
}
nsresult
LookupCacheV4
:
:
WriteMetadata
(
RefPtr
<
const
TableUpdateV4
>
aTableUpdate
)
{
NS_ENSURE_ARG_POINTER
(
aTableUpdate
)
;
if
(
nsUrlClassifierDBService
:
:
ShutdownHasStarted
(
)
)
{
return
NS_ERROR_ABORT
;
}
nsCOMPtr
<
nsIFile
>
metaFile
;
nsresult
rv
=
mStoreDirectory
-
>
Clone
(
getter_AddRefs
(
metaFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
metaFile
-
>
AppendNative
(
mTableName
+
METADATA_SUFFIX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIOutputStream
>
outputStream
;
rv
=
NS_NewLocalFileOutputStream
(
getter_AddRefs
(
outputStream
)
metaFile
PR_WRONLY
|
PR_TRUNCATE
|
PR_CREATE_FILE
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
WriteValue
(
outputStream
aTableUpdate
-
>
ClientState
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
WriteValue
(
outputStream
aTableUpdate
-
>
SHA256
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
rv
;
}
nsresult
LookupCacheV4
:
:
LoadMetadata
(
nsACString
&
aState
nsACString
&
aSHA256
)
{
nsCOMPtr
<
nsIFile
>
metaFile
;
nsresult
rv
=
mStoreDirectory
-
>
Clone
(
getter_AddRefs
(
metaFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
metaFile
-
>
AppendNative
(
mTableName
+
METADATA_SUFFIX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
localInFile
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
localInFile
)
metaFile
PR_RDONLY
|
nsIFile
:
:
OS_READAHEAD
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Unable
to
open
metadata
file
.
"
)
)
;
return
rv
;
}
rv
=
ReadValue
(
localInFile
aState
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
read
state
.
"
)
)
;
return
rv
;
}
rv
=
ReadValue
(
localInFile
aSHA256
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
read
SHA256
hash
.
"
)
)
;
return
rv
;
}
return
rv
;
}
VLPrefixSet
:
:
VLPrefixSet
(
const
PrefixStringMap
&
aMap
)
:
mCount
(
0
)
{
for
(
auto
iter
=
aMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
uint32_t
size
=
iter
.
Key
(
)
;
MOZ_ASSERT
(
iter
.
Data
(
)
-
>
Length
(
)
%
size
=
=
0
"
PrefixString
must
be
a
multiple
of
the
prefix
size
.
"
)
;
mMap
.
Put
(
size
new
PrefixString
(
*
iter
.
Data
(
)
size
)
)
;
mCount
+
=
iter
.
Data
(
)
-
>
Length
(
)
/
size
;
}
}
void
VLPrefixSet
:
:
Merge
(
PrefixStringMap
&
aPrefixMap
)
{
for
(
auto
iter
=
mMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsCString
*
prefixString
=
aPrefixMap
.
LookupOrAdd
(
iter
.
Key
(
)
)
;
PrefixString
*
str
=
iter
.
Data
(
)
;
nsAutoCString
remainingString
;
str
-
>
getRemainingString
(
remainingString
)
;
if
(
!
remainingString
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
remainingString
.
Length
(
)
=
=
str
-
>
remaining
(
)
)
;
prefixString
-
>
Append
(
remainingString
)
;
}
}
}
bool
VLPrefixSet
:
:
GetSmallestPrefix
(
nsACString
&
aOutString
)
const
{
PrefixString
*
pick
=
nullptr
;
for
(
auto
iter
=
mMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
PrefixString
*
str
=
iter
.
Data
(
)
;
if
(
str
-
>
remaining
(
)
<
=
0
)
{
continue
;
}
if
(
aOutString
.
IsEmpty
(
)
)
{
str
-
>
getPrefix
(
aOutString
)
;
MOZ_ASSERT
(
aOutString
.
Length
(
)
=
=
iter
.
Key
(
)
)
;
pick
=
str
;
continue
;
}
nsAutoCString
cur
;
str
-
>
getPrefix
(
cur
)
;
if
(
!
cur
.
IsEmpty
(
)
&
&
cur
<
aOutString
)
{
aOutString
.
Assign
(
cur
)
;
MOZ_ASSERT
(
aOutString
.
Length
(
)
=
=
iter
.
Key
(
)
)
;
pick
=
str
;
}
}
if
(
pick
)
{
pick
-
>
next
(
)
;
}
return
pick
!
=
nullptr
;
}
nsresult
LookupCacheV4
:
:
LoadMozEntries
(
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
}
}
