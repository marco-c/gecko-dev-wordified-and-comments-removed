#
ifndef
LookupCache_h__
#
define
LookupCache_h__
#
include
"
Entries
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsUrlClassifierPrefixSet
.
h
"
#
include
"
VariableLengthPrefixSet
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
namespace
mozilla
{
namespace
safebrowsing
{
#
define
MAX_HOST_COMPONENTS
5
#
define
MAX_PATH_COMPONENTS
4
enum
class
MatchResult
:
uint8_t
{
eNoMatch
=
0x00
eV2Prefix
=
0x01
eV4Prefix
=
0x02
eV2Completion
=
0x04
eV4Completion
=
0x08
eTelemetryDisabled
=
0x10
eBothPrefix
=
eV2Prefix
|
eV4Prefix
eBothCompletion
=
eV2Completion
|
eV4Completion
eV2PreAndCom
=
eV2Prefix
|
eV2Completion
eV4PreAndCom
=
eV4Prefix
|
eV4Completion
eBothPreAndV2Com
=
eBothPrefix
|
eV2Completion
eBothPreAndV4Com
=
eBothPrefix
|
eV4Completion
eAll
=
eBothPrefix
|
eBothCompletion
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
MatchResult
)
class
LookupResult
{
public
:
LookupResult
(
)
:
mNoise
(
false
)
mProtocolConfirmed
(
false
)
mPartialHashLength
(
0
)
mConfirmed
(
false
)
mProtocolV2
(
true
)
mMatchResult
(
MatchResult
:
:
eTelemetryDisabled
)
{
}
union
{
Prefix
fixedLengthPrefix
;
Completion
complete
;
}
hash
;
const
Completion
&
CompleteHash
(
)
{
MOZ_ASSERT
(
!
mNoise
)
;
return
hash
.
complete
;
}
nsCString
PartialHash
(
)
{
MOZ_ASSERT
(
mPartialHashLength
<
=
COMPLETE_SIZE
)
;
return
nsCString
(
reinterpret_cast
<
char
*
>
(
hash
.
complete
.
buf
)
mPartialHashLength
)
;
}
nsCString
PartialHashHex
(
)
{
nsAutoCString
hex
;
for
(
size_t
i
=
0
;
i
<
mPartialHashLength
;
i
+
+
)
{
hex
.
AppendPrintf
(
"
%
.
2X
"
hash
.
complete
.
buf
[
i
]
)
;
}
return
hex
;
}
bool
Confirmed
(
)
const
{
return
mConfirmed
|
|
mProtocolConfirmed
;
}
bool
Complete
(
)
const
{
return
mPartialHashLength
=
=
COMPLETE_SIZE
;
}
bool
mNoise
;
bool
mProtocolConfirmed
;
nsCString
mTableName
;
uint32_t
mPartialHashLength
;
bool
mConfirmed
;
bool
mProtocolV2
;
MatchResult
mMatchResult
;
}
;
typedef
nsTArray
<
LookupResult
>
LookupResultArray
;
class
CacheResult
{
public
:
enum
{
V2
V4
}
;
virtual
int
Ver
(
)
const
=
0
;
virtual
bool
findCompletion
(
const
Completion
&
aCompletion
)
const
=
0
;
virtual
~
CacheResult
(
)
{
}
template
<
typename
T
>
static
T
*
Cast
(
CacheResult
*
aThat
)
{
return
(
(
aThat
&
&
T
:
:
VER
=
=
aThat
-
>
Ver
(
)
)
?
reinterpret_cast
<
T
*
>
(
aThat
)
:
nullptr
)
;
}
nsCString
table
;
Prefix
prefix
;
}
;
class
CacheResultV2
final
:
public
CacheResult
{
public
:
static
const
int
VER
;
Completion
completion
;
uint32_t
addChunk
;
bool
operator
=
=
(
const
CacheResultV2
&
aOther
)
const
{
return
table
=
=
aOther
.
table
&
&
prefix
=
=
aOther
.
prefix
&
&
completion
=
=
aOther
.
completion
&
&
addChunk
=
=
aOther
.
addChunk
;
}
bool
findCompletion
(
const
Completion
&
aCompletion
)
const
override
{
return
completion
=
=
aCompletion
;
}
virtual
int
Ver
(
)
const
override
{
return
VER
;
}
}
;
class
CacheResultV4
final
:
public
CacheResult
{
public
:
static
const
int
VER
;
CachedFullHashResponse
response
;
bool
operator
=
=
(
const
CacheResultV4
&
aOther
)
const
{
return
table
=
=
aOther
.
table
&
&
prefix
=
=
aOther
.
prefix
&
&
response
=
=
aOther
.
response
;
}
bool
findCompletion
(
const
Completion
&
aCompletion
)
const
override
{
nsDependentCSubstring
completion
(
reinterpret_cast
<
const
char
*
>
(
aCompletion
.
buf
)
COMPLETE_SIZE
)
;
return
response
.
fullHashes
.
Contains
(
completion
)
;
}
virtual
int
Ver
(
)
const
override
{
return
VER
;
}
}
;
typedef
nsTArray
<
UniquePtr
<
CacheResult
>
>
CacheResultArray
;
class
LookupCache
{
public
:
static
bool
IsCanonicalizedIP
(
const
nsACString
&
aHost
)
;
static
nsresult
GetLookupFragments
(
const
nsACString
&
aSpec
nsTArray
<
nsCString
>
*
aFragments
)
;
static
nsresult
GetHostKeys
(
const
nsACString
&
aSpec
nsTArray
<
nsCString
>
*
aHostKeys
)
;
LookupCache
(
const
nsACString
&
aTableName
const
nsACString
&
aProvider
nsIFile
*
aStoreFile
)
;
virtual
~
LookupCache
(
)
{
}
const
nsCString
&
TableName
(
)
const
{
return
mTableName
;
}
nsresult
UpdateRootDirHandle
(
nsIFile
*
aRootStoreDirectory
)
;
nsresult
WriteFile
(
)
;
bool
IsPrimed
(
)
const
{
return
mPrimed
;
}
;
virtual
nsresult
Open
(
)
;
virtual
nsresult
Init
(
)
=
0
;
virtual
nsresult
ClearPrefixes
(
)
=
0
;
virtual
nsresult
Has
(
const
Completion
&
aCompletion
const
TableFreshnessMap
&
aTableFreshness
uint32_t
aFreshnessGuarantee
bool
*
aHas
uint32_t
*
aMatchLength
bool
*
aConfirmed
bool
*
aFromCache
)
=
0
;
virtual
void
ClearCache
(
)
=
0
;
virtual
bool
IsEmpty
(
)
=
0
;
virtual
void
ClearAll
(
)
;
#
if
DEBUG
virtual
void
DumpCache
(
)
=
0
;
#
endif
template
<
typename
T
>
static
T
*
Cast
(
LookupCache
*
aThat
)
{
return
(
(
aThat
&
&
T
:
:
VER
=
=
aThat
-
>
Ver
(
)
)
?
reinterpret_cast
<
T
*
>
(
aThat
)
:
nullptr
)
;
}
private
:
nsresult
LoadPrefixSet
(
)
;
virtual
nsresult
StoreToFile
(
nsIFile
*
aFile
)
=
0
;
virtual
nsresult
LoadFromFile
(
nsIFile
*
aFile
)
=
0
;
virtual
size_t
SizeOfPrefixSet
(
)
=
0
;
virtual
int
Ver
(
)
const
=
0
;
protected
:
bool
mPrimed
;
nsCString
mTableName
;
nsCString
mProvider
;
nsCOMPtr
<
nsIFile
>
mRootStoreDirectory
;
nsCOMPtr
<
nsIFile
>
mStoreDirectory
;
friend
class
PerProviderDirectoryTestUtils
;
}
;
class
LookupCacheV2
final
:
public
LookupCache
{
public
:
explicit
LookupCacheV2
(
const
nsACString
&
aTableName
const
nsACString
&
aProvider
nsIFile
*
aStoreFile
)
:
LookupCache
(
aTableName
aProvider
aStoreFile
)
{
}
~
LookupCacheV2
(
)
{
}
virtual
nsresult
Init
(
)
override
;
virtual
nsresult
Open
(
)
override
;
virtual
void
ClearCache
(
)
override
;
virtual
void
ClearAll
(
)
override
;
virtual
nsresult
Has
(
const
Completion
&
aCompletion
const
TableFreshnessMap
&
aTableFreshness
uint32_t
aFreshnessGuarantee
bool
*
aHas
uint32_t
*
aMatchLength
bool
*
aConfirmed
bool
*
aFromCache
)
override
;
virtual
bool
IsEmpty
(
)
override
;
nsresult
Build
(
AddPrefixArray
&
aAddPrefixes
AddCompleteArray
&
aAddCompletes
)
;
nsresult
GetPrefixes
(
FallibleTArray
<
uint32_t
>
&
aAddPrefixes
)
;
nsresult
AddCompletionsToCache
(
AddCompleteArray
&
aAddCompletes
)
;
#
if
DEBUG
virtual
void
DumpCache
(
)
override
;
void
DumpCompletions
(
)
;
#
endif
static
const
int
VER
;
protected
:
nsresult
ReadCompletions
(
)
;
virtual
nsresult
ClearPrefixes
(
)
override
;
virtual
nsresult
StoreToFile
(
nsIFile
*
aFile
)
override
;
virtual
nsresult
LoadFromFile
(
nsIFile
*
aFile
)
override
;
virtual
size_t
SizeOfPrefixSet
(
)
override
;
private
:
virtual
int
Ver
(
)
const
override
{
return
VER
;
}
nsresult
ConstructPrefixSet
(
AddPrefixArray
&
aAddPrefixes
)
;
CompletionArray
mUpdateCompletions
;
RefPtr
<
nsUrlClassifierPrefixSet
>
mPrefixSet
;
CompletionArray
mGetHashCache
;
}
;
}
}
#
endif
