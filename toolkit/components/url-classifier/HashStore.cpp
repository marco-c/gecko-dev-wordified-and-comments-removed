#
include
"
HashStore
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsIStreamConverterService
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsCheckSummedOutputStream
.
h
"
#
include
"
prio
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
zlib
.
h
"
#
include
"
Classifier
.
h
"
#
include
"
nsUrlClassifierDBService
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
define
STORE_SUFFIX
"
.
sbstore
"
extern
mozilla
:
:
LazyLogModule
gUrlClassifierDbServiceLog
;
#
define
LOG
(
args
)
\
MOZ_LOG
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
\
MOZ_LOG_TEST
(
gUrlClassifierDbServiceLog
mozilla
:
:
LogLevel
:
:
Debug
)
namespace
mozilla
{
namespace
safebrowsing
{
const
uint32_t
STORE_MAGIC
=
0x1231af3b
;
const
uint32_t
CURRENT_VERSION
=
3
;
nsresult
TableUpdateV2
:
:
NewAddPrefix
(
uint32_t
aAddChunk
const
Prefix
&
aHash
)
{
AddPrefix
*
add
=
mAddPrefixes
.
AppendElement
(
fallible
)
;
if
(
!
add
)
return
NS_ERROR_OUT_OF_MEMORY
;
add
-
>
addChunk
=
aAddChunk
;
add
-
>
prefix
=
aHash
;
return
NS_OK
;
}
nsresult
TableUpdateV2
:
:
NewSubPrefix
(
uint32_t
aAddChunk
const
Prefix
&
aHash
uint32_t
aSubChunk
)
{
SubPrefix
*
sub
=
mSubPrefixes
.
AppendElement
(
fallible
)
;
if
(
!
sub
)
return
NS_ERROR_OUT_OF_MEMORY
;
sub
-
>
addChunk
=
aAddChunk
;
sub
-
>
prefix
=
aHash
;
sub
-
>
subChunk
=
aSubChunk
;
return
NS_OK
;
}
nsresult
TableUpdateV2
:
:
NewAddComplete
(
uint32_t
aAddChunk
const
Completion
&
aHash
)
{
AddComplete
*
add
=
mAddCompletes
.
AppendElement
(
fallible
)
;
if
(
!
add
)
return
NS_ERROR_OUT_OF_MEMORY
;
add
-
>
addChunk
=
aAddChunk
;
add
-
>
complete
=
aHash
;
return
NS_OK
;
}
nsresult
TableUpdateV2
:
:
NewSubComplete
(
uint32_t
aAddChunk
const
Completion
&
aHash
uint32_t
aSubChunk
)
{
SubComplete
*
sub
=
mSubCompletes
.
AppendElement
(
fallible
)
;
if
(
!
sub
)
return
NS_ERROR_OUT_OF_MEMORY
;
sub
-
>
addChunk
=
aAddChunk
;
sub
-
>
complete
=
aHash
;
sub
-
>
subChunk
=
aSubChunk
;
return
NS_OK
;
}
nsresult
TableUpdateV2
:
:
NewMissPrefix
(
const
Prefix
&
aPrefix
)
{
Prefix
*
prefix
=
mMissPrefixes
.
AppendElement
(
aPrefix
fallible
)
;
if
(
!
prefix
)
return
NS_ERROR_OUT_OF_MEMORY
;
return
NS_OK
;
}
void
TableUpdateV4
:
:
NewPrefixes
(
int32_t
aSize
const
nsACString
&
aPrefixes
)
{
NS_ENSURE_TRUE_VOID
(
aSize
>
=
4
&
&
aSize
<
=
COMPLETE_SIZE
)
;
NS_ENSURE_TRUE_VOID
(
aPrefixes
.
Length
(
)
%
aSize
=
=
0
)
;
NS_ENSURE_TRUE_VOID
(
!
mPrefixesMap
.
Get
(
aSize
)
)
;
int
numOfPrefixes
=
aPrefixes
.
Length
(
)
/
aSize
;
if
(
aSize
>
4
)
{
#
ifdef
NIGHTLY_BUILD
for
(
int
i
=
0
;
i
<
std
:
:
min
(
20
numOfPrefixes
)
;
i
+
+
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
URLCLASSIFIER_VLPS_LONG_PREFIXES
aSize
)
;
}
#
endif
}
else
if
(
LOG_ENABLED
(
)
)
{
const
uint32_t
*
p
=
reinterpret_cast
<
const
uint32_t
*
>
(
ToNewCString
(
aPrefixes
)
)
;
LOG
(
(
"
*
The
first
10
(
maximum
)
fixed
-
length
prefixes
:
"
)
)
;
for
(
int
i
=
0
;
i
<
std
:
:
min
(
10
numOfPrefixes
)
;
i
+
+
)
{
const
uint8_t
*
c
=
reinterpret_cast
<
const
uint8_t
*
>
(
&
p
[
i
]
)
;
LOG
(
(
"
%
.
2X
%
.
2X
%
.
2X
%
.
2X
"
c
[
0
]
c
[
1
]
c
[
2
]
c
[
3
]
)
)
;
}
LOG
(
(
"
*
The
last
10
(
maximum
)
fixed
-
length
prefixes
:
"
)
)
;
for
(
int
i
=
std
:
:
max
(
0
numOfPrefixes
-
10
)
;
i
<
numOfPrefixes
;
i
+
+
)
{
const
uint8_t
*
c
=
reinterpret_cast
<
const
uint8_t
*
>
(
&
p
[
i
]
)
;
LOG
(
(
"
%
.
2X
%
.
2X
%
.
2X
%
.
2X
"
c
[
0
]
c
[
1
]
c
[
2
]
c
[
3
]
)
)
;
}
LOG
(
(
"
-
-
-
-
%
u
fixed
-
length
prefixes
in
total
.
"
aPrefixes
.
Length
(
)
/
aSize
)
)
;
}
mPrefixesMap
.
Put
(
aSize
new
nsCString
(
aPrefixes
)
)
;
}
nsresult
TableUpdateV4
:
:
NewRemovalIndices
(
const
uint32_t
*
aIndices
size_t
aNumOfIndices
)
{
MOZ_ASSERT
(
mRemovalIndiceArray
.
IsEmpty
(
)
"
mRemovalIndiceArray
must
be
empty
"
)
;
if
(
!
mRemovalIndiceArray
.
SetCapacity
(
aNumOfIndices
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
size_t
i
=
0
;
i
<
aNumOfIndices
;
i
+
+
)
{
mRemovalIndiceArray
.
AppendElement
(
aIndices
[
i
]
)
;
}
return
NS_OK
;
}
void
TableUpdateV4
:
:
SetSHA256
(
const
std
:
:
string
&
aSHA256
)
{
mSHA256
.
Assign
(
aSHA256
.
data
(
)
aSHA256
.
size
(
)
)
;
}
nsresult
TableUpdateV4
:
:
NewFullHashResponse
(
const
Prefix
&
aPrefix
const
CachedFullHashResponse
&
aResponse
)
{
CachedFullHashResponse
*
response
=
mFullHashResponseMap
.
LookupOrAdd
(
aPrefix
.
ToUint32
(
)
)
;
if
(
!
response
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
*
response
=
aResponse
;
return
NS_OK
;
}
HashStore
:
:
HashStore
(
const
nsACString
&
aTableName
const
nsACString
&
aProvider
nsIFile
*
aRootStoreDir
)
:
mTableName
(
aTableName
)
mInUpdate
(
false
)
mFileSize
(
0
)
{
nsresult
rv
=
Classifier
:
:
GetPrivateStoreDirectory
(
aRootStoreDir
aTableName
aProvider
getter_AddRefs
(
mStoreDirectory
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
get
private
store
directory
for
%
s
"
mTableName
.
get
(
)
)
)
;
mStoreDirectory
=
aRootStoreDir
;
}
}
HashStore
:
:
~
HashStore
(
)
=
default
;
nsresult
HashStore
:
:
Reset
(
)
{
LOG
(
(
"
HashStore
resetting
"
)
)
;
nsCOMPtr
<
nsIFile
>
storeFile
;
nsresult
rv
=
mStoreDirectory
-
>
Clone
(
getter_AddRefs
(
storeFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
storeFile
-
>
AppendNative
(
mTableName
+
NS_LITERAL_CSTRING
(
STORE_SUFFIX
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
storeFile
-
>
Remove
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mFileSize
=
0
;
return
NS_OK
;
}
nsresult
HashStore
:
:
CheckChecksum
(
uint32_t
aFileSize
)
{
if
(
!
mInputStream
)
{
return
NS_OK
;
}
nsAutoCString
hash
;
nsAutoCString
compareHash
;
uint32_t
read
;
nsresult
rv
=
CalculateChecksum
(
hash
aFileSize
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
compareHash
.
SetLength
(
hash
.
Length
(
)
)
;
if
(
hash
.
Length
(
)
>
aFileSize
)
{
NS_WARNING
(
"
SafeBrowing
file
not
long
enough
to
store
its
hash
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISeekableStream
>
seekIn
=
do_QueryInterface
(
mInputStream
)
;
rv
=
seekIn
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
aFileSize
-
hash
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mInputStream
-
>
Read
(
compareHash
.
BeginWriting
(
)
hash
.
Length
(
)
&
read
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
read
=
=
hash
.
Length
(
)
"
Could
not
read
hash
bytes
"
)
;
if
(
!
hash
.
Equals
(
compareHash
)
)
{
NS_WARNING
(
"
Safebrowing
file
failed
checksum
.
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
HashStore
:
:
Open
(
)
{
nsCOMPtr
<
nsIFile
>
storeFile
;
nsresult
rv
=
mStoreDirectory
-
>
Clone
(
getter_AddRefs
(
storeFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
storeFile
-
>
AppendNative
(
mTableName
+
NS_LITERAL_CSTRING
(
"
.
sbstore
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
origStream
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
origStream
)
storeFile
PR_RDONLY
|
nsIFile
:
:
OS_READAHEAD
)
;
if
(
rv
=
=
NS_ERROR_FILE_NOT_FOUND
)
{
UpdateHeader
(
)
;
return
NS_OK
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int64_t
fileSize
;
rv
=
storeFile
-
>
GetFileSize
(
&
fileSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
fileSize
<
0
|
|
fileSize
>
UINT32_MAX
)
{
return
NS_ERROR_FAILURE
;
}
mFileSize
=
static_cast
<
uint32_t
>
(
fileSize
)
;
rv
=
NS_NewBufferedInputStream
(
getter_AddRefs
(
mInputStream
)
origStream
.
forget
(
)
mFileSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadHeader
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SanityCheck
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HashStore
:
:
ReadHeader
(
)
{
if
(
!
mInputStream
)
{
UpdateHeader
(
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsISeekableStream
>
seekable
=
do_QueryInterface
(
mInputStream
)
;
nsresult
rv
=
seekable
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
void
*
buffer
=
&
mHeader
;
rv
=
NS_ReadInputStreamToBuffer
(
mInputStream
&
buffer
sizeof
(
Header
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HashStore
:
:
SanityCheck
(
)
const
{
if
(
mHeader
.
magic
!
=
STORE_MAGIC
|
|
mHeader
.
version
!
=
CURRENT_VERSION
)
{
NS_WARNING
(
"
Unexpected
header
data
in
the
store
.
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
HashStore
:
:
CalculateChecksum
(
nsAutoCString
&
aChecksum
uint32_t
aFileSize
bool
aChecksumPresent
)
{
aChecksum
.
Truncate
(
)
;
nsCOMPtr
<
nsISeekableStream
>
seekable
=
do_QueryInterface
(
mInputStream
)
;
nsresult
rv
=
seekable
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
0
)
;
nsCOMPtr
<
nsICryptoHash
>
hash
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
const
uint32_t
CHECKSUM_SIZE
=
16
;
rv
=
hash
-
>
Init
(
nsICryptoHash
:
:
MD5
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
aChecksumPresent
)
{
rv
=
hash
-
>
UpdateFromStream
(
mInputStream
UINT32_MAX
)
;
}
else
{
if
(
aFileSize
<
CHECKSUM_SIZE
)
{
NS_WARNING
(
"
SafeBrowsing
file
isn
'
t
long
enough
to
store
its
checksum
"
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
hash
-
>
UpdateFromStream
(
mInputStream
aFileSize
-
CHECKSUM_SIZE
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
hash
-
>
Finish
(
false
aChecksum
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
void
HashStore
:
:
UpdateHeader
(
)
{
mHeader
.
magic
=
STORE_MAGIC
;
mHeader
.
version
=
CURRENT_VERSION
;
mHeader
.
numAddChunks
=
mAddChunks
.
Length
(
)
;
mHeader
.
numSubChunks
=
mSubChunks
.
Length
(
)
;
mHeader
.
numAddPrefixes
=
mAddPrefixes
.
Length
(
)
;
mHeader
.
numSubPrefixes
=
mSubPrefixes
.
Length
(
)
;
mHeader
.
numAddCompletes
=
mAddCompletes
.
Length
(
)
;
mHeader
.
numSubCompletes
=
mSubCompletes
.
Length
(
)
;
}
nsresult
HashStore
:
:
ReadChunkNumbers
(
)
{
if
(
!
mInputStream
|
|
AlreadyReadChunkNumbers
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsISeekableStream
>
seekable
=
do_QueryInterface
(
mInputStream
)
;
nsresult
rv
=
seekable
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
sizeof
(
Header
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mAddChunks
.
Read
(
mInputStream
mHeader
.
numAddChunks
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
mAddChunks
.
Length
(
)
=
=
mHeader
.
numAddChunks
"
Read
the
right
amount
of
add
chunks
.
"
)
;
rv
=
mSubChunks
.
Read
(
mInputStream
mHeader
.
numSubChunks
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
mSubChunks
.
Length
(
)
=
=
mHeader
.
numSubChunks
"
Read
the
right
amount
of
sub
chunks
.
"
)
;
return
NS_OK
;
}
nsresult
HashStore
:
:
ReadHashes
(
)
{
if
(
!
mInputStream
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsISeekableStream
>
seekable
=
do_QueryInterface
(
mInputStream
)
;
uint32_t
offset
=
sizeof
(
Header
)
;
offset
+
=
(
mHeader
.
numAddChunks
+
mHeader
.
numSubChunks
)
*
sizeof
(
uint32_t
)
;
nsresult
rv
=
seekable
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadAddPrefixes
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadSubPrefixes
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
AlreadyReadCompletions
(
)
)
{
return
NS_OK
;
}
rv
=
ReadTArray
(
mInputStream
&
mAddCompletes
mHeader
.
numAddCompletes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadTArray
(
mInputStream
&
mSubCompletes
mHeader
.
numSubCompletes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HashStore
:
:
ReadCompletions
(
)
{
if
(
!
mInputStream
|
|
AlreadyReadCompletions
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
storeFile
;
nsresult
rv
=
mStoreDirectory
-
>
Clone
(
getter_AddRefs
(
storeFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
storeFile
-
>
AppendNative
(
mTableName
+
NS_LITERAL_CSTRING
(
STORE_SUFFIX
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
offset
=
mFileSize
-
sizeof
(
struct
AddComplete
)
*
mHeader
.
numAddCompletes
-
sizeof
(
struct
SubComplete
)
*
mHeader
.
numSubCompletes
-
nsCheckSummedOutputStream
:
:
CHECKSUM_SIZE
;
nsCOMPtr
<
nsISeekableStream
>
seekable
=
do_QueryInterface
(
mInputStream
)
;
rv
=
seekable
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadTArray
(
mInputStream
&
mAddCompletes
mHeader
.
numAddCompletes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadTArray
(
mInputStream
&
mSubCompletes
mHeader
.
numSubCompletes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HashStore
:
:
PrepareForUpdate
(
)
{
nsresult
rv
=
CheckChecksum
(
mFileSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadChunkNumbers
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadHashes
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HashStore
:
:
BeginUpdate
(
)
{
nsresult
rv
=
PrepareForUpdate
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mInputStream
)
{
rv
=
mInputStream
-
>
Close
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mInUpdate
=
true
;
return
NS_OK
;
}
template
<
class
T
>
static
nsresult
Merge
(
ChunkSet
*
aStoreChunks
FallibleTArray
<
T
>
*
aStorePrefixes
const
ChunkSet
&
aUpdateChunks
FallibleTArray
<
T
>
&
aUpdatePrefixes
bool
aAllowMerging
=
false
)
{
EntrySort
(
aUpdatePrefixes
)
;
auto
storeIter
=
aStorePrefixes
-
>
begin
(
)
;
auto
storeEnd
=
aStorePrefixes
-
>
end
(
)
;
nsTArray
<
T
>
adds
;
for
(
const
auto
&
updatePrefix
:
aUpdatePrefixes
)
{
if
(
aStoreChunks
-
>
Has
(
updatePrefix
.
Chunk
(
)
)
)
if
(
!
aAllowMerging
)
continue
;
while
(
storeIter
<
storeEnd
&
&
(
storeIter
-
>
Compare
(
updatePrefix
)
<
0
)
)
{
storeIter
+
+
;
}
if
(
storeIter
=
=
storeEnd
|
|
storeIter
-
>
Compare
(
updatePrefix
)
!
=
0
)
{
if
(
!
adds
.
AppendElement
(
updatePrefix
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
}
aStoreChunks
-
>
Merge
(
aUpdateChunks
)
;
if
(
!
aStorePrefixes
-
>
AppendElements
(
adds
fallible
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
EntrySort
(
*
aStorePrefixes
)
;
return
NS_OK
;
}
nsresult
HashStore
:
:
ApplyUpdate
(
RefPtr
<
TableUpdateV2
>
aUpdate
)
{
MOZ_ASSERT
(
mTableName
.
Equals
(
aUpdate
-
>
TableName
(
)
)
)
;
nsresult
rv
=
mAddExpirations
.
Merge
(
aUpdate
-
>
AddExpirations
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mSubExpirations
.
Merge
(
aUpdate
-
>
SubExpirations
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
Expire
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
Merge
(
&
mAddChunks
&
mAddPrefixes
aUpdate
-
>
AddChunks
(
)
aUpdate
-
>
AddPrefixes
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
Merge
(
&
mAddChunks
&
mAddCompletes
aUpdate
-
>
AddChunks
(
)
aUpdate
-
>
AddCompletes
(
)
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
Merge
(
&
mSubChunks
&
mSubPrefixes
aUpdate
-
>
SubChunks
(
)
aUpdate
-
>
SubPrefixes
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
Merge
(
&
mSubChunks
&
mSubCompletes
aUpdate
-
>
SubChunks
(
)
aUpdate
-
>
SubCompletes
(
)
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HashStore
:
:
Rebuild
(
)
{
NS_ASSERTION
(
mInUpdate
"
Must
be
in
update
to
rebuild
.
"
)
;
nsresult
rv
=
ProcessSubs
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
UpdateHeader
(
)
;
return
NS_OK
;
}
void
HashStore
:
:
ClearCompletes
(
)
{
NS_ASSERTION
(
mInUpdate
"
Must
be
in
update
to
clear
completes
.
"
)
;
mAddCompletes
.
Clear
(
)
;
mSubCompletes
.
Clear
(
)
;
UpdateHeader
(
)
;
}
template
<
class
T
>
static
void
ExpireEntries
(
FallibleTArray
<
T
>
*
aEntries
ChunkSet
&
aExpirations
)
{
auto
addIter
=
aEntries
-
>
begin
(
)
;
for
(
const
auto
&
entry
:
*
aEntries
)
{
if
(
!
aExpirations
.
Has
(
entry
.
Chunk
(
)
)
)
{
*
addIter
=
entry
;
addIter
+
+
;
}
}
aEntries
-
>
TruncateLength
(
addIter
-
aEntries
-
>
begin
(
)
)
;
}
nsresult
HashStore
:
:
Expire
(
)
{
ExpireEntries
(
&
mAddPrefixes
mAddExpirations
)
;
ExpireEntries
(
&
mAddCompletes
mAddExpirations
)
;
ExpireEntries
(
&
mSubPrefixes
mSubExpirations
)
;
ExpireEntries
(
&
mSubCompletes
mSubExpirations
)
;
mAddChunks
.
Remove
(
mAddExpirations
)
;
mSubChunks
.
Remove
(
mSubExpirations
)
;
mAddExpirations
.
Clear
(
)
;
mSubExpirations
.
Clear
(
)
;
return
NS_OK
;
}
template
<
class
T
>
nsresult
DeflateWriteTArray
(
nsIOutputStream
*
aStream
nsTArray
<
T
>
&
aIn
)
{
uLongf
insize
=
aIn
.
Length
(
)
*
sizeof
(
T
)
;
uLongf
outsize
=
compressBound
(
insize
)
;
FallibleTArray
<
char
>
outBuff
;
if
(
!
outBuff
.
SetLength
(
outsize
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
int
zerr
=
compress
(
reinterpret_cast
<
Bytef
*
>
(
outBuff
.
Elements
(
)
)
&
outsize
reinterpret_cast
<
const
Bytef
*
>
(
aIn
.
Elements
(
)
)
insize
)
;
if
(
zerr
!
=
Z_OK
)
{
return
NS_ERROR_FAILURE
;
}
LOG
(
(
"
DeflateWriteTArray
:
%
lu
in
%
lu
out
"
insize
outsize
)
)
;
outBuff
.
TruncateLength
(
outsize
)
;
uint32_t
dataLen
=
outBuff
.
Length
(
)
;
uint32_t
written
;
nsresult
rv
=
aStream
-
>
Write
(
reinterpret_cast
<
char
*
>
(
&
dataLen
)
sizeof
(
dataLen
)
&
written
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
written
=
=
sizeof
(
dataLen
)
"
Error
writing
deflate
length
"
)
;
rv
=
WriteTArray
(
aStream
outBuff
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
template
<
class
T
>
nsresult
InflateReadTArray
(
nsIInputStream
*
aStream
FallibleTArray
<
T
>
*
aOut
uint32_t
aExpectedSize
)
{
uint32_t
inLen
;
uint32_t
read
;
nsresult
rv
=
aStream
-
>
Read
(
reinterpret_cast
<
char
*
>
(
&
inLen
)
sizeof
(
inLen
)
&
read
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
read
=
=
sizeof
(
inLen
)
"
Error
reading
inflate
length
"
)
;
FallibleTArray
<
char
>
inBuff
;
if
(
!
inBuff
.
SetLength
(
inLen
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
rv
=
ReadTArray
(
aStream
&
inBuff
inLen
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uLongf
insize
=
inLen
;
uLongf
outsize
=
aExpectedSize
*
sizeof
(
T
)
;
if
(
!
aOut
-
>
SetLength
(
aExpectedSize
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
int
zerr
=
uncompress
(
reinterpret_cast
<
Bytef
*
>
(
aOut
-
>
Elements
(
)
)
&
outsize
reinterpret_cast
<
const
Bytef
*
>
(
inBuff
.
Elements
(
)
)
insize
)
;
if
(
zerr
!
=
Z_OK
)
{
return
NS_ERROR_FAILURE
;
}
LOG
(
(
"
InflateReadTArray
:
%
lu
in
%
lu
out
"
insize
outsize
)
)
;
NS_ASSERTION
(
outsize
=
=
aExpectedSize
*
sizeof
(
T
)
"
Decompression
size
mismatch
"
)
;
return
NS_OK
;
}
static
nsresult
ByteSliceWrite
(
nsIOutputStream
*
aOut
nsTArray
<
uint32_t
>
&
aData
)
{
nsTArray
<
uint8_t
>
slice
;
uint32_t
count
=
aData
.
Length
(
)
;
if
(
!
slice
.
SetLength
(
count
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
slice
[
i
]
=
(
aData
[
i
]
>
>
24
)
;
}
nsresult
rv
=
DeflateWriteTArray
(
aOut
slice
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
slice
[
i
]
=
(
(
aData
[
i
]
>
>
16
)
&
0xFF
)
;
}
rv
=
DeflateWriteTArray
(
aOut
slice
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
slice
[
i
]
=
(
(
aData
[
i
]
>
>
8
)
&
0xFF
)
;
}
rv
=
DeflateWriteTArray
(
aOut
slice
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
slice
[
i
]
=
(
aData
[
i
]
&
0xFF
)
;
}
rv
=
WriteTArray
(
aOut
slice
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
static
nsresult
ByteSliceRead
(
nsIInputStream
*
aInStream
FallibleTArray
<
uint32_t
>
*
aData
uint32_t
count
)
{
FallibleTArray
<
uint8_t
>
slice1
;
FallibleTArray
<
uint8_t
>
slice2
;
FallibleTArray
<
uint8_t
>
slice3
;
FallibleTArray
<
uint8_t
>
slice4
;
nsresult
rv
=
InflateReadTArray
(
aInStream
&
slice1
count
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
InflateReadTArray
(
aInStream
&
slice2
count
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
InflateReadTArray
(
aInStream
&
slice3
count
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadTArray
(
aInStream
&
slice4
count
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
aData
-
>
SetCapacity
(
count
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
aData
-
>
AppendElement
(
(
slice1
[
i
]
<
<
24
)
|
(
slice2
[
i
]
<
<
16
)
|
(
slice3
[
i
]
<
<
8
)
|
(
slice4
[
i
]
)
fallible
)
;
}
return
NS_OK
;
}
nsresult
HashStore
:
:
ReadAddPrefixes
(
)
{
FallibleTArray
<
uint32_t
>
chunks
;
uint32_t
count
=
mHeader
.
numAddPrefixes
;
nsresult
rv
=
ByteSliceRead
(
mInputStream
&
chunks
count
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mAddPrefixes
.
SetCapacity
(
count
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
AddPrefix
*
add
=
mAddPrefixes
.
AppendElement
(
fallible
)
;
add
-
>
prefix
.
FromUint32
(
0
)
;
add
-
>
addChunk
=
chunks
[
i
]
;
}
return
NS_OK
;
}
nsresult
HashStore
:
:
ReadSubPrefixes
(
)
{
FallibleTArray
<
uint32_t
>
addchunks
;
FallibleTArray
<
uint32_t
>
subchunks
;
FallibleTArray
<
uint32_t
>
prefixes
;
uint32_t
count
=
mHeader
.
numSubPrefixes
;
nsresult
rv
=
ByteSliceRead
(
mInputStream
&
addchunks
count
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ByteSliceRead
(
mInputStream
&
subchunks
count
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ByteSliceRead
(
mInputStream
&
prefixes
count
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mSubPrefixes
.
SetCapacity
(
count
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
SubPrefix
*
sub
=
mSubPrefixes
.
AppendElement
(
fallible
)
;
sub
-
>
addChunk
=
addchunks
[
i
]
;
sub
-
>
prefix
.
FromUint32
(
prefixes
[
i
]
)
;
sub
-
>
subChunk
=
subchunks
[
i
]
;
}
return
NS_OK
;
}
nsresult
HashStore
:
:
WriteAddPrefixes
(
nsIOutputStream
*
aOut
)
{
nsTArray
<
uint32_t
>
chunks
;
uint32_t
count
=
mAddPrefixes
.
Length
(
)
;
if
(
!
chunks
.
SetCapacity
(
count
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
chunks
.
AppendElement
(
mAddPrefixes
[
i
]
.
Chunk
(
)
)
;
}
nsresult
rv
=
ByteSliceWrite
(
aOut
chunks
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HashStore
:
:
WriteSubPrefixes
(
nsIOutputStream
*
aOut
)
{
nsTArray
<
uint32_t
>
addchunks
;
nsTArray
<
uint32_t
>
subchunks
;
nsTArray
<
uint32_t
>
prefixes
;
uint32_t
count
=
mSubPrefixes
.
Length
(
)
;
if
(
!
addchunks
.
SetCapacity
(
count
fallible
)
|
|
!
subchunks
.
SetCapacity
(
count
fallible
)
|
|
!
prefixes
.
SetCapacity
(
count
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
addchunks
.
AppendElement
(
mSubPrefixes
[
i
]
.
AddChunk
(
)
)
;
prefixes
.
AppendElement
(
mSubPrefixes
[
i
]
.
PrefixHash
(
)
.
ToUint32
(
)
)
;
subchunks
.
AppendElement
(
mSubPrefixes
[
i
]
.
Chunk
(
)
)
;
}
nsresult
rv
=
ByteSliceWrite
(
aOut
addchunks
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ByteSliceWrite
(
aOut
subchunks
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ByteSliceWrite
(
aOut
prefixes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HashStore
:
:
WriteFile
(
)
{
NS_ASSERTION
(
mInUpdate
"
Must
be
in
update
to
write
database
.
"
)
;
if
(
nsUrlClassifierDBService
:
:
ShutdownHasStarted
(
)
)
{
return
NS_ERROR_ABORT
;
}
nsCOMPtr
<
nsIFile
>
storeFile
;
nsresult
rv
=
mStoreDirectory
-
>
Clone
(
getter_AddRefs
(
storeFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
storeFile
-
>
AppendNative
(
mTableName
+
NS_LITERAL_CSTRING
(
"
.
sbstore
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIOutputStream
>
out
;
rv
=
NS_NewCheckSummedOutputStream
(
getter_AddRefs
(
out
)
storeFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
written
;
rv
=
out
-
>
Write
(
reinterpret_cast
<
char
*
>
(
&
mHeader
)
sizeof
(
mHeader
)
&
written
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mAddChunks
.
Write
(
out
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mSubChunks
.
Write
(
out
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
WriteAddPrefixes
(
out
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
WriteSubPrefixes
(
out
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
WriteTArray
(
out
mAddCompletes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
WriteTArray
(
out
mSubCompletes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsISafeOutputStream
>
safeOut
=
do_QueryInterface
(
out
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
safeOut
-
>
Finish
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
template
<
class
T
>
static
void
Erase
(
FallibleTArray
<
T
>
*
array
typename
nsTArray
<
T
>
:
:
iterator
&
iterStart
typename
nsTArray
<
T
>
:
:
iterator
&
iterEnd
)
{
uint32_t
start
=
iterStart
-
array
-
>
begin
(
)
;
uint32_t
count
=
iterEnd
-
iterStart
;
if
(
count
>
0
)
{
array
-
>
RemoveElementsAt
(
start
count
)
;
}
}
template
<
class
TSub
class
TAdd
>
static
void
KnockoutSubs
(
FallibleTArray
<
TSub
>
*
aSubs
FallibleTArray
<
TAdd
>
*
aAdds
)
{
auto
addOut
=
aAdds
-
>
begin
(
)
;
auto
addIter
=
aAdds
-
>
begin
(
)
;
auto
subOut
=
aSubs
-
>
begin
(
)
;
auto
subIter
=
aSubs
-
>
begin
(
)
;
auto
addEnd
=
aAdds
-
>
end
(
)
;
auto
subEnd
=
aSubs
-
>
end
(
)
;
while
(
addIter
!
=
addEnd
&
&
subIter
!
=
subEnd
)
{
int32_t
cmp
=
addIter
-
>
Compare
(
*
subIter
)
;
if
(
cmp
>
0
)
{
*
subOut
=
*
subIter
;
+
+
subOut
;
+
+
subIter
;
}
else
if
(
cmp
<
0
)
{
*
addOut
=
*
addIter
;
+
+
addOut
;
+
+
addIter
;
}
else
{
+
+
addIter
;
+
+
subIter
;
}
}
Erase
(
aAdds
addOut
addIter
)
;
Erase
(
aSubs
subOut
subIter
)
;
}
template
<
class
T
>
static
void
RemoveMatchingPrefixes
(
const
SubPrefixArray
&
aSubs
FallibleTArray
<
T
>
*
aFullHashes
)
{
auto
out
=
aFullHashes
-
>
begin
(
)
;
auto
hashIter
=
aFullHashes
-
>
begin
(
)
;
auto
hashEnd
=
aFullHashes
-
>
end
(
)
;
auto
removeIter
=
aSubs
.
begin
(
)
;
auto
removeEnd
=
aSubs
.
end
(
)
;
while
(
hashIter
!
=
hashEnd
&
&
removeIter
!
=
removeEnd
)
{
int32_t
cmp
=
removeIter
-
>
CompareAlt
(
*
hashIter
)
;
if
(
cmp
>
0
)
{
*
out
=
*
hashIter
;
+
+
out
;
+
+
hashIter
;
}
else
if
(
cmp
<
0
)
{
+
+
removeIter
;
}
else
{
do
{
+
+
hashIter
;
}
while
(
hashIter
!
=
hashEnd
&
&
!
(
removeIter
-
>
CompareAlt
(
*
hashIter
)
<
0
)
)
;
+
+
removeIter
;
}
}
Erase
(
aFullHashes
out
hashIter
)
;
}
static
void
RemoveDeadSubPrefixes
(
SubPrefixArray
&
aSubs
ChunkSet
&
aAddChunks
)
{
auto
subIter
=
aSubs
.
begin
(
)
;
for
(
const
auto
&
sub
:
aSubs
)
{
bool
hasChunk
=
aAddChunks
.
Has
(
sub
.
AddChunk
(
)
)
;
if
(
!
hasChunk
)
{
*
subIter
=
sub
;
subIter
+
+
;
}
}
LOG
(
(
"
Removed
%
"
PRId64
"
dead
SubPrefix
entries
.
"
static_cast
<
int64_t
>
(
aSubs
.
end
(
)
-
subIter
)
)
)
;
aSubs
.
TruncateLength
(
subIter
-
aSubs
.
begin
(
)
)
;
}
#
ifdef
DEBUG
template
<
class
T
>
static
void
EnsureSorted
(
FallibleTArray
<
T
>
*
aArray
)
{
auto
start
=
aArray
-
>
begin
(
)
;
auto
end
=
aArray
-
>
end
(
)
;
auto
iter
=
start
;
auto
previous
=
start
;
while
(
iter
!
=
end
)
{
previous
=
iter
;
+
+
iter
;
if
(
iter
!
=
end
)
{
MOZ_ASSERT
(
iter
-
>
Compare
(
*
previous
)
>
=
0
)
;
}
}
return
;
}
#
endif
nsresult
HashStore
:
:
ProcessSubs
(
)
{
#
ifdef
DEBUG
EnsureSorted
(
&
mAddPrefixes
)
;
EnsureSorted
(
&
mSubPrefixes
)
;
EnsureSorted
(
&
mAddCompletes
)
;
EnsureSorted
(
&
mSubCompletes
)
;
LOG
(
(
"
All
databases
seem
to
have
a
consistent
sort
order
.
"
)
)
;
#
endif
RemoveMatchingPrefixes
(
mSubPrefixes
&
mAddCompletes
)
;
RemoveMatchingPrefixes
(
mSubPrefixes
&
mSubCompletes
)
;
KnockoutSubs
(
&
mSubPrefixes
&
mAddPrefixes
)
;
KnockoutSubs
(
&
mSubCompletes
&
mAddCompletes
)
;
RemoveDeadSubPrefixes
(
mSubPrefixes
mAddChunks
)
;
#
ifdef
DEBUG
EnsureSorted
(
&
mAddPrefixes
)
;
EnsureSorted
(
&
mSubPrefixes
)
;
EnsureSorted
(
&
mAddCompletes
)
;
EnsureSorted
(
&
mSubCompletes
)
;
LOG
(
(
"
All
databases
seem
to
have
a
consistent
sort
order
.
"
)
)
;
#
endif
return
NS_OK
;
}
nsresult
HashStore
:
:
AugmentAdds
(
const
nsTArray
<
uint32_t
>
&
aPrefixes
)
{
uint32_t
cnt
=
aPrefixes
.
Length
(
)
;
if
(
cnt
!
=
mAddPrefixes
.
Length
(
)
)
{
LOG
(
(
"
Amount
of
prefixes
in
cache
not
consistent
with
store
(
%
zu
vs
%
zu
)
"
aPrefixes
.
Length
(
)
mAddPrefixes
.
Length
(
)
)
)
;
return
NS_ERROR_FAILURE
;
}
for
(
uint32_t
i
=
0
;
i
<
cnt
;
i
+
+
)
{
mAddPrefixes
[
i
]
.
prefix
.
FromUint32
(
aPrefixes
[
i
]
)
;
}
return
NS_OK
;
}
ChunkSet
&
HashStore
:
:
AddChunks
(
)
{
ReadChunkNumbers
(
)
;
return
mAddChunks
;
}
ChunkSet
&
HashStore
:
:
SubChunks
(
)
{
ReadChunkNumbers
(
)
;
return
mSubChunks
;
}
AddCompleteArray
&
HashStore
:
:
AddCompletes
(
)
{
ReadCompletions
(
)
;
return
mAddCompletes
;
}
SubCompleteArray
&
HashStore
:
:
SubCompletes
(
)
{
ReadCompletions
(
)
;
return
mSubCompletes
;
}
bool
HashStore
:
:
AlreadyReadChunkNumbers
(
)
const
{
if
(
(
mHeader
.
numAddChunks
!
=
0
&
&
mAddChunks
.
Length
(
)
=
=
0
)
|
|
(
mHeader
.
numSubChunks
!
=
0
&
&
mSubChunks
.
Length
(
)
=
=
0
)
)
{
return
false
;
}
return
true
;
}
bool
HashStore
:
:
AlreadyReadCompletions
(
)
const
{
if
(
(
mHeader
.
numAddCompletes
!
=
0
&
&
mAddCompletes
.
Length
(
)
=
=
0
)
|
|
(
mHeader
.
numSubCompletes
!
=
0
&
&
mSubCompletes
.
Length
(
)
=
=
0
)
)
{
return
false
;
}
return
true
;
}
}
}
