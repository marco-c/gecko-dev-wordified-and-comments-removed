var
Modules
=
(
function
(
modules
)
{
if
(
modules
.
Parser
)
{
modules
.
Parser
.
prototype
.
impliedRules
=
function
(
node
uf
parentClasses
)
{
var
typeVersion
=
(
uf
.
typeVersion
)
?
uf
.
typeVersion
:
'
v2
'
;
if
(
this
.
options
.
impliedPropertiesByVersion
=
=
=
false
)
{
typeVersion
=
'
v2
'
;
}
if
(
node
&
&
uf
&
&
uf
.
properties
)
{
uf
=
this
.
impliedBackwardComp
(
node
uf
parentClasses
)
;
if
(
typeVersion
=
=
=
'
v2
'
)
{
uf
=
this
.
impliedhFeedTitle
(
uf
)
;
uf
=
this
.
impliedName
(
node
uf
)
;
uf
=
this
.
impliedPhoto
(
node
uf
)
;
uf
=
this
.
impliedUrl
(
node
uf
)
;
}
uf
=
this
.
impliedValue
(
node
uf
parentClasses
)
;
uf
=
this
.
impliedDate
(
uf
)
;
if
(
this
.
options
.
parseLatLonGeo
=
=
=
true
)
{
uf
=
this
.
impliedGeo
(
uf
)
;
}
}
return
uf
;
}
;
modules
.
Parser
.
prototype
.
impliedName
=
function
(
node
uf
)
{
var
name
value
;
if
(
!
uf
.
properties
.
name
)
{
value
=
this
.
getImpliedProperty
(
node
[
'
img
'
'
area
'
'
abbr
'
]
this
.
getNameAttr
)
;
var
textFormat
=
this
.
options
.
textFormat
;
if
(
!
value
)
{
name
=
[
modules
.
text
.
parse
(
this
.
document
node
textFormat
)
]
;
}
else
{
name
=
[
modules
.
text
.
parseText
(
this
.
document
value
textFormat
)
]
;
}
if
(
name
&
&
name
[
0
]
!
=
=
'
'
)
{
uf
.
properties
.
name
=
name
;
}
}
return
uf
;
}
;
modules
.
Parser
.
prototype
.
impliedPhoto
=
function
(
node
uf
)
{
var
value
;
if
(
!
uf
.
properties
.
photo
)
{
value
=
this
.
getImpliedProperty
(
node
[
'
img
'
'
object
'
]
this
.
getPhotoAttr
)
;
if
(
value
)
{
if
(
value
&
&
value
!
=
=
'
'
&
&
this
.
options
.
baseUrl
!
=
=
'
'
&
&
!
value
.
includes
(
'
:
/
/
'
)
)
{
value
=
modules
.
url
.
resolve
(
value
this
.
options
.
baseUrl
)
;
}
uf
.
properties
.
photo
=
[
modules
.
utils
.
trim
(
value
)
]
;
}
}
return
uf
;
}
;
modules
.
Parser
.
prototype
.
impliedUrl
=
function
(
node
uf
)
{
var
value
;
if
(
!
uf
.
properties
.
url
)
{
value
=
this
.
getImpliedProperty
(
node
[
'
a
'
'
area
'
]
this
.
getURLAttr
)
;
if
(
value
)
{
if
(
value
&
&
value
!
=
=
'
'
&
&
this
.
options
.
baseUrl
!
=
=
'
'
&
&
!
value
.
includes
(
'
:
/
/
'
)
)
{
value
=
modules
.
url
.
resolve
(
value
this
.
options
.
baseUrl
)
;
}
uf
.
properties
.
url
=
[
modules
.
utils
.
trim
(
value
)
]
;
}
}
return
uf
;
}
;
modules
.
Parser
.
prototype
.
impliedDate
=
function
(
uf
)
{
var
newDate
;
if
(
uf
.
times
.
length
>
0
&
&
uf
.
dates
.
length
>
0
)
{
newDate
=
modules
.
dates
.
dateTimeUnion
(
uf
.
dates
[
0
]
[
1
]
uf
.
times
[
0
]
[
1
]
this
.
options
.
dateFormat
)
;
uf
.
properties
[
this
.
removePropPrefix
(
uf
.
times
[
0
]
[
0
]
)
]
[
0
]
=
newDate
.
toString
(
this
.
options
.
dateFormat
)
;
}
delete
uf
.
times
;
delete
uf
.
dates
;
return
uf
;
}
;
modules
.
Parser
.
prototype
.
getImpliedProperty
=
function
(
node
tagList
getAttrFunction
)
{
var
value
=
getAttrFunction
(
node
)
descendant
child
;
if
(
!
value
)
{
descendant
=
modules
.
domUtils
.
getSingleDescendantOfType
(
node
tagList
)
;
if
(
descendant
&
&
this
.
hasHClass
(
descendant
)
=
=
=
false
)
{
value
=
getAttrFunction
(
descendant
)
;
}
if
(
node
.
children
.
length
>
0
)
{
child
=
modules
.
domUtils
.
getSingleDescendant
(
node
)
;
if
(
child
&
&
this
.
hasHClass
(
child
)
=
=
=
false
)
{
descendant
=
modules
.
domUtils
.
getSingleDescendantOfType
(
child
tagList
)
;
if
(
descendant
&
&
this
.
hasHClass
(
descendant
)
=
=
=
false
)
{
value
=
getAttrFunction
(
descendant
)
;
}
}
}
}
return
value
;
}
;
modules
.
Parser
.
prototype
.
getNameAttr
=
function
(
node
)
{
var
value
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
img
'
'
area
'
]
'
alt
'
)
;
if
(
!
value
)
{
value
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
abbr
'
]
'
title
'
)
;
}
return
value
;
}
;
modules
.
Parser
.
prototype
.
getPhotoAttr
=
function
(
node
)
{
var
value
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
img
'
]
'
src
'
)
;
if
(
!
value
&
&
modules
.
domUtils
.
hasAttributeValue
(
node
'
class
'
'
include
'
)
=
=
=
false
)
{
value
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
object
'
]
'
data
'
)
;
}
return
value
;
}
;
modules
.
Parser
.
prototype
.
getURLAttr
=
function
(
node
)
{
var
value
=
null
;
if
(
modules
.
domUtils
.
hasAttributeValue
(
node
'
class
'
'
include
'
)
=
=
=
false
)
{
value
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
a
'
]
'
href
'
)
;
if
(
!
value
)
{
value
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
area
'
]
'
href
'
)
;
}
}
return
value
;
}
;
modules
.
Parser
.
prototype
.
impliedValue
=
function
(
node
uf
parentClasses
)
{
if
(
uf
.
properties
.
name
)
{
if
(
uf
.
value
&
&
parentClasses
.
root
.
length
>
0
&
&
parentClasses
.
properties
.
length
=
=
=
1
)
{
uf
=
this
.
getAltValue
(
uf
parentClasses
.
properties
[
0
]
[
0
]
'
p
-
name
'
uf
.
properties
.
name
[
0
]
)
;
}
}
if
(
uf
.
properties
.
url
)
{
if
(
parentClasses
&
&
parentClasses
.
root
.
length
=
=
=
1
&
&
parentClasses
.
properties
.
length
=
=
=
1
)
{
uf
=
this
.
getAltValue
(
uf
parentClasses
.
properties
[
0
]
[
0
]
'
u
-
url
'
uf
.
properties
.
url
[
0
]
)
;
}
}
if
(
uf
.
altValue
!
=
=
null
)
{
uf
.
value
=
uf
.
altValue
.
value
;
}
delete
uf
.
altValue
;
return
uf
;
}
;
modules
.
Parser
.
prototype
.
getAltValue
=
function
(
uf
parentPropertyName
propertyName
value
)
{
if
(
uf
.
value
&
&
!
uf
.
altValue
)
{
if
(
modules
.
utils
.
startWith
(
parentPropertyName
'
p
-
'
)
&
&
propertyName
=
=
=
'
p
-
name
'
)
{
uf
.
altValue
=
{
name
:
propertyName
value
:
value
}
;
}
if
(
modules
.
utils
.
startWith
(
parentPropertyName
'
e
-
'
)
&
&
modules
.
utils
.
startWith
(
propertyName
'
e
-
'
)
)
{
uf
.
altValue
=
{
name
:
propertyName
value
:
value
}
;
}
if
(
modules
.
utils
.
startWith
(
parentPropertyName
'
u
-
'
)
&
&
propertyName
=
=
=
'
u
-
url
'
)
{
uf
.
altValue
=
{
name
:
propertyName
value
:
value
}
;
}
}
return
uf
;
}
;
modules
.
Parser
.
prototype
.
impliedhFeedTitle
=
function
(
uf
)
{
if
(
uf
.
type
&
&
uf
.
type
.
indexOf
(
'
h
-
feed
'
)
>
-
1
)
{
if
(
uf
.
properties
.
name
=
=
=
undefined
|
|
uf
.
properties
.
name
[
0
]
=
=
=
'
'
)
{
var
title
=
modules
.
domUtils
.
querySelector
(
this
.
document
'
title
'
)
;
if
(
title
)
{
uf
.
properties
.
name
=
[
modules
.
domUtils
.
textContent
(
title
)
]
;
}
}
}
return
uf
;
}
;
modules
.
Parser
.
prototype
.
impliedGeo
=
function
(
uf
)
{
var
geoPair
parts
longitude
latitude
valid
=
true
;
if
(
uf
.
type
&
&
uf
.
type
.
indexOf
(
'
h
-
geo
'
)
>
-
1
)
{
if
(
uf
.
properties
.
latitude
=
=
=
undefined
|
|
uf
.
properties
.
longitude
=
=
=
undefined
)
{
geoPair
=
(
uf
.
properties
.
name
)
?
uf
.
properties
.
name
[
0
]
:
null
;
geoPair
=
(
!
geoPair
&
&
uf
.
properties
.
value
)
?
uf
.
properties
.
value
:
geoPair
;
if
(
geoPair
)
{
geoPair
=
geoPair
.
replace
(
'
;
'
'
'
)
;
if
(
geoPair
.
indexOf
(
'
'
)
>
-
1
)
{
parts
=
geoPair
.
split
(
'
'
)
;
if
(
parts
.
length
>
1
)
{
latitude
=
parseFloat
(
parts
[
0
]
)
;
if
(
modules
.
utils
.
isNumber
(
latitude
)
&
&
latitude
>
90
|
|
latitude
<
-
90
)
{
valid
=
false
;
}
longitude
=
parseFloat
(
parts
[
1
]
)
;
if
(
modules
.
utils
.
isNumber
(
longitude
)
&
&
longitude
>
180
|
|
longitude
<
-
180
)
{
valid
=
false
;
}
if
(
valid
)
{
uf
.
properties
.
latitude
=
[
latitude
]
;
uf
.
properties
.
longitude
=
[
longitude
]
;
}
}
}
}
}
}
return
uf
;
}
;
modules
.
Parser
.
prototype
.
impliedBackwardComp
=
function
(
node
uf
parentClasses
)
{
if
(
parentClasses
.
root
.
length
=
=
=
1
&
&
parentClasses
.
properties
.
length
=
=
=
1
)
{
if
(
parentClasses
.
root
[
0
]
.
replace
(
'
h
-
'
'
'
)
=
=
=
this
.
removePropPrefix
(
parentClasses
.
properties
[
0
]
[
0
]
)
)
{
if
(
modules
.
utils
.
hasProperties
(
uf
.
properties
)
=
=
=
false
)
{
uf
=
this
.
impliedName
(
node
uf
)
;
}
}
}
return
uf
;
}
;
}
return
modules
;
}
(
Modules
|
|
{
}
)
)
;
