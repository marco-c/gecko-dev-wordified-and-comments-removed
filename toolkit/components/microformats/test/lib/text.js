var
Modules
=
(
function
(
modules
)
{
modules
.
text
=
{
textFormat
:
'
whitespacetrimmed
'
blockLevelTags
:
[
'
h1
'
'
h2
'
'
h3
'
'
h4
'
'
h5
'
'
h6
'
'
p
'
'
hr
'
'
pre
'
'
table
'
'
address
'
'
article
'
'
aside
'
'
blockquote
'
'
caption
'
'
col
'
'
colgroup
'
'
dd
'
'
div
'
'
dt
'
'
dir
'
'
fieldset
'
'
figcaption
'
'
figure
'
'
footer
'
'
form
'
'
header
'
'
hgroup
'
'
hr
'
'
li
'
'
map
'
'
menu
'
'
nav
'
'
optgroup
'
'
option
'
'
section
'
'
tbody
'
'
testarea
'
'
tfoot
'
'
th
'
'
thead
'
'
tr
'
'
td
'
'
ul
'
'
ol
'
'
dl
'
'
details
'
]
excludeTags
:
[
'
noframe
'
'
noscript
'
'
template
'
'
script
'
'
style
'
'
frames
'
'
frameset
'
]
parse
:
function
(
doc
node
textFormat
)
{
var
out
;
this
.
textFormat
=
(
textFormat
)
?
textFormat
:
this
.
textFormat
;
if
(
this
.
textFormat
=
=
=
'
normalised
'
)
{
out
=
this
.
walkTreeForText
(
node
)
;
if
(
out
!
=
=
undefined
)
{
return
this
.
normalise
(
doc
out
)
;
}
else
{
return
'
'
;
}
}
else
{
return
this
.
formatText
(
doc
modules
.
domUtils
.
textContent
(
node
)
this
.
textFormat
)
;
}
}
parseText
:
function
(
doc
text
textFormat
)
{
var
node
=
modules
.
domUtils
.
createNodeWithText
(
'
div
'
text
)
;
return
this
.
parse
(
doc
node
textFormat
)
;
}
formatText
:
function
(
doc
text
textFormat
)
{
this
.
textFormat
=
(
textFormat
)
?
textFormat
:
this
.
textFormat
;
if
(
text
)
{
var
out
=
'
'
regex
=
/
(
<
(
[
^
>
]
+
)
>
)
/
ig
;
out
=
text
.
replace
(
regex
'
'
)
;
if
(
this
.
textFormat
=
=
=
'
whitespacetrimmed
'
)
{
out
=
modules
.
utils
.
trimWhitespace
(
out
)
;
}
return
modules
.
domUtils
.
decodeEntities
(
doc
out
)
;
}
else
{
return
'
'
;
}
}
normalise
:
function
(
doc
text
)
{
text
=
text
.
replace
(
/
&
nbsp
;
/
g
'
'
)
;
text
=
modules
.
utils
.
collapseWhiteSpace
(
text
)
;
text
=
modules
.
domUtils
.
decodeEntities
(
doc
text
)
;
text
=
text
.
replace
(
'
'
'
-
'
)
;
return
modules
.
utils
.
trim
(
text
)
;
}
walkTreeForText
:
function
(
node
)
{
var
out
=
'
'
j
=
0
;
if
(
node
.
tagName
&
&
this
.
excludeTags
.
indexOf
(
node
.
tagName
.
toLowerCase
(
)
)
>
-
1
)
{
return
out
;
}
if
(
node
.
nodeType
&
&
node
.
nodeType
=
=
=
3
)
{
out
+
=
modules
.
domUtils
.
getElementText
(
node
)
;
}
if
(
node
.
childNodes
&
&
node
.
childNodes
.
length
>
0
)
{
for
(
j
=
0
;
j
<
node
.
childNodes
.
length
;
j
+
+
)
{
var
text
=
this
.
walkTreeForText
(
node
.
childNodes
[
j
]
)
;
if
(
text
!
=
=
undefined
)
{
out
+
=
text
;
}
}
}
if
(
node
.
tagName
&
&
this
.
blockLevelTags
.
indexOf
(
node
.
tagName
.
toLowerCase
(
)
)
!
=
=
-
1
)
{
out
+
=
'
'
;
}
return
(
out
=
=
=
'
'
)
?
undefined
:
out
;
}
}
;
return
modules
;
}
(
Modules
|
|
{
}
)
)
;
