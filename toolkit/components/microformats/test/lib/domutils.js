var
Modules
=
(
function
(
modules
)
{
modules
.
domUtils
=
{
document
:
null
rootNode
:
null
getDOMParser
:
function
(
)
{
if
(
typeof
DOMParser
=
=
=
undefined
)
{
try
{
return
Components
.
classes
[
"
mozilla
.
org
/
xmlextras
/
domparser
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIDOMParser
)
;
}
catch
(
e
)
{
return
;
}
}
else
{
return
new
DOMParser
(
)
;
}
}
getDOMContext
:
function
(
options
)
{
if
(
options
.
node
)
{
this
.
rootNode
=
options
.
node
;
}
if
(
options
.
html
)
{
var
domParser
=
this
.
getDOMParser
(
)
;
this
.
rootNode
=
domParser
.
parseFromString
(
options
.
html
'
text
/
html
'
)
;
}
if
(
this
.
rootNode
!
=
=
null
)
{
if
(
this
.
rootNode
.
nodeType
=
=
=
9
)
{
this
.
document
=
this
.
rootNode
;
this
.
rootNode
=
modules
.
domUtils
.
querySelector
(
this
.
rootNode
'
html
'
)
;
}
else
{
this
.
document
=
modules
.
domUtils
.
ownerDocument
(
this
.
rootNode
)
;
}
}
if
(
!
this
.
rootNode
&
&
document
)
{
this
.
rootNode
=
modules
.
domUtils
.
querySelector
(
document
'
html
'
)
;
this
.
document
=
document
;
}
if
(
this
.
rootNode
&
&
this
.
document
)
{
return
{
document
:
this
.
document
rootNode
:
this
.
rootNode
}
;
}
return
{
document
:
null
rootNode
:
null
}
;
}
getTopMostNode
:
function
(
node
)
{
return
node
;
}
ownerDocument
:
function
(
node
)
{
return
node
.
ownerDocument
;
}
textContent
:
function
(
node
)
{
if
(
node
.
textContent
)
{
return
node
.
textContent
;
}
else
if
(
node
.
innerText
)
{
return
node
.
innerText
;
}
return
'
'
;
}
innerHTML
:
function
(
node
)
{
return
node
.
innerHTML
;
}
hasAttribute
:
function
(
node
attributeName
)
{
return
node
.
hasAttribute
(
attributeName
)
;
}
hasAttributeValue
:
function
(
node
attributeName
value
)
{
return
(
this
.
getAttributeList
(
node
attributeName
)
.
indexOf
(
value
)
>
-
1
)
;
}
getAttribute
:
function
(
node
attributeName
)
{
return
node
.
getAttribute
(
attributeName
)
;
}
setAttribute
:
function
(
node
attributeName
attributeValue
)
{
node
.
setAttribute
(
attributeName
attributeValue
)
;
}
removeAttribute
:
function
(
node
attributeName
)
{
node
.
removeAttribute
(
attributeName
)
;
}
getElementById
:
function
(
docNode
id
)
{
return
docNode
.
querySelector
(
'
#
'
+
id
)
;
}
querySelector
:
function
(
docNode
selector
)
{
return
docNode
.
querySelector
(
selector
)
;
}
getAttributeList
:
function
(
node
attributeName
)
{
var
out
=
[
]
attList
;
attList
=
node
.
getAttribute
(
attributeName
)
;
if
(
attList
&
&
attList
!
=
=
'
'
)
{
if
(
attList
.
indexOf
(
'
'
)
>
-
1
)
{
out
=
attList
.
split
(
'
'
)
;
}
else
{
out
.
push
(
attList
)
;
}
}
return
out
;
}
getNodesByAttribute
:
function
(
node
attributeName
)
{
var
selector
=
'
[
'
+
attributeName
+
'
]
'
;
return
node
.
querySelectorAll
(
selector
)
;
}
getNodesByAttributeValue
:
function
(
rootNode
name
value
)
{
var
arr
=
[
]
x
=
0
i
out
=
[
]
;
arr
=
this
.
getNodesByAttribute
(
rootNode
name
)
;
if
(
arr
)
{
i
=
arr
.
length
;
while
(
x
<
i
)
{
if
(
this
.
hasAttributeValue
(
arr
[
x
]
name
value
)
)
{
out
.
push
(
arr
[
x
]
)
;
}
x
+
+
;
}
}
return
out
;
}
getAttrValFromTagList
:
function
(
node
tagNames
attributeName
)
{
var
i
=
tagNames
.
length
;
while
(
i
-
-
)
{
if
(
node
.
tagName
.
toLowerCase
(
)
=
=
=
tagNames
[
i
]
)
{
var
attrValue
=
this
.
getAttribute
(
node
attributeName
)
;
if
(
attrValue
&
&
attrValue
!
=
=
'
'
)
{
return
attrValue
;
}
}
}
return
null
;
}
getSingleDescendant
:
function
(
node
)
{
return
this
.
getDescendant
(
node
null
false
)
;
}
getSingleDescendantOfType
:
function
(
node
tagNames
)
{
return
this
.
getDescendant
(
node
tagNames
true
)
;
}
getDescendant
:
function
(
node
tagNames
onlyOfType
)
{
var
i
=
node
.
children
.
length
countAll
=
0
countOfType
=
0
child
out
=
null
;
while
(
i
-
-
)
{
child
=
node
.
children
[
i
]
;
if
(
child
.
nodeType
=
=
=
1
)
{
if
(
tagNames
)
{
if
(
this
.
hasTagName
(
child
tagNames
)
)
{
out
=
child
;
countOfType
+
+
;
}
}
else
{
out
=
child
;
countAll
+
+
;
}
}
}
if
(
onlyOfType
=
=
=
true
)
{
return
(
countOfType
=
=
=
1
)
?
out
:
null
;
}
else
{
return
(
countAll
=
=
=
1
)
?
out
:
null
;
}
}
hasTagName
:
function
(
node
tagNames
)
{
var
i
=
tagNames
.
length
;
while
(
i
-
-
)
{
if
(
node
.
tagName
.
toLowerCase
(
)
=
=
=
tagNames
[
i
]
)
{
return
true
;
}
}
return
false
;
}
appendChild
:
function
(
node
childNode
)
{
return
node
.
appendChild
(
childNode
)
;
}
removeChild
:
function
(
childNode
)
{
if
(
childNode
.
parentNode
)
{
return
childNode
.
parentNode
.
removeChild
(
childNode
)
;
}
else
{
return
null
;
}
}
clone
:
function
(
node
)
{
var
newNode
=
node
.
cloneNode
(
true
)
;
newNode
.
removeAttribute
(
'
id
'
)
;
return
newNode
;
}
getElementText
:
function
(
node
)
{
if
(
node
&
&
node
.
data
)
{
return
node
.
data
;
}
else
{
return
'
'
;
}
}
getOrderedAttributes
:
function
(
node
)
{
var
nodeStr
=
node
.
outerHTML
attrs
=
[
]
;
for
(
var
i
=
0
;
i
<
node
.
attributes
.
length
;
i
+
+
)
{
var
attr
=
node
.
attributes
[
i
]
;
attr
.
indexNum
=
nodeStr
.
indexOf
(
attr
.
name
)
;
attrs
.
push
(
attr
)
;
}
return
attrs
.
sort
(
modules
.
utils
.
sortObjects
(
'
indexNum
'
)
)
;
}
decodeEntities
:
function
(
doc
text
)
{
return
doc
.
createTextNode
(
text
)
.
nodeValue
;
}
cloneDocument
:
function
(
document
)
{
var
newNode
newDocument
=
null
;
if
(
this
.
canCloneDocument
(
document
)
)
{
newDocument
=
document
.
implementation
.
createHTMLDocument
(
'
'
)
;
newNode
=
newDocument
.
importNode
(
document
.
documentElement
true
)
;
newDocument
.
replaceChild
(
newNode
newDocument
.
querySelector
(
'
html
'
)
)
;
}
return
(
newNode
&
&
newNode
.
nodeType
&
&
newNode
.
nodeType
=
=
=
1
)
?
newDocument
:
document
;
}
canCloneDocument
:
function
(
document
)
{
return
(
document
&
&
document
.
importNode
&
&
document
.
implementation
&
&
document
.
implementation
.
createHTMLDocument
)
;
}
getChildIndex
:
function
(
node
)
{
var
parent
=
node
.
parentNode
i
=
-
1
child
;
while
(
parent
&
&
(
child
=
parent
.
childNodes
[
+
+
i
]
)
)
{
if
(
child
=
=
=
node
)
{
return
i
;
}
}
return
-
1
;
}
getNodePath
:
function
(
node
)
{
var
parent
=
node
.
parentNode
path
=
[
]
index
=
this
.
getChildIndex
(
node
)
;
if
(
parent
&
&
(
path
=
this
.
getNodePath
(
parent
)
)
)
{
if
(
index
>
-
1
)
{
path
.
push
(
index
)
;
}
}
return
path
;
}
getNodeByPath
:
function
(
document
path
)
{
var
node
=
document
.
documentElement
i
=
0
index
;
while
(
(
index
=
path
[
+
+
i
]
)
>
-
1
)
{
node
=
node
.
childNodes
[
index
]
;
}
return
node
;
}
getChildren
:
function
(
node
)
{
return
node
.
children
;
}
createNode
:
function
(
tagName
)
{
return
this
.
document
.
createElement
(
tagName
)
;
}
createNodeWithText
:
function
(
tagName
text
)
{
var
node
=
this
.
document
.
createElement
(
tagName
)
;
node
.
innerHTML
=
text
;
return
node
;
}
}
;
return
modules
;
}
(
Modules
|
|
{
}
)
)
;
