var
Modules
=
(
function
(
modules
)
{
modules
.
utils
=
{
isString
:
function
(
obj
)
{
return
typeof
(
obj
)
=
=
=
'
string
'
;
}
isNumber
:
function
(
obj
)
{
return
!
isNaN
(
parseFloat
(
obj
)
)
&
&
isFinite
(
obj
)
;
}
isArray
:
function
(
obj
)
{
return
obj
&
&
!
(
obj
.
propertyIsEnumerable
(
'
length
'
)
)
&
&
typeof
obj
=
=
=
'
object
'
&
&
typeof
obj
.
length
=
=
=
'
number
'
;
}
isFunction
:
function
(
obj
)
{
return
!
!
(
obj
&
&
obj
.
constructor
&
&
obj
.
call
&
&
obj
.
apply
)
;
}
startWith
:
function
(
text
test
)
{
return
(
text
.
indexOf
(
test
)
=
=
=
0
)
;
}
trim
:
function
(
text
)
{
if
(
text
&
&
this
.
isString
(
text
)
)
{
return
(
text
.
trim
(
)
)
?
text
.
trim
(
)
:
text
.
replace
(
/
^
\
s
+
|
\
s
+
/
g
'
'
)
;
}
else
{
return
'
'
;
}
}
replaceCharAt
:
function
(
text
index
character
)
{
if
(
text
&
&
text
.
length
>
index
)
{
return
text
.
substr
(
0
index
)
+
character
+
text
.
substr
(
index
+
character
.
length
)
;
}
else
{
return
text
;
}
}
trimWhitespace
:
function
(
text
)
{
if
(
text
&
&
text
.
length
)
{
var
i
=
text
.
length
x
=
0
;
while
(
i
-
-
)
{
if
(
this
.
isOnlyWhiteSpace
(
text
[
i
]
)
)
{
text
=
this
.
replaceCharAt
(
text
i
'
'
)
;
}
else
{
break
;
}
}
i
=
text
.
length
;
while
(
x
<
i
)
{
if
(
this
.
isOnlyWhiteSpace
(
text
[
x
]
)
)
{
text
=
this
.
replaceCharAt
(
text
i
'
'
)
;
}
else
{
break
;
}
x
+
+
;
}
}
return
this
.
trim
(
text
)
;
}
isOnlyWhiteSpace
:
function
(
text
)
{
return
!
(
/
[
^
\
t
\
n
\
r
]
/
.
test
(
text
)
)
;
}
collapseWhiteSpace
:
function
(
text
)
{
return
text
.
replace
(
/
[
\
t
\
n
\
r
]
+
/
g
'
'
)
;
}
hasProperties
:
function
(
obj
)
{
var
key
;
for
(
key
in
obj
)
{
if
(
obj
.
hasOwnProperty
(
key
)
)
{
return
true
;
}
}
return
false
;
}
sortObjects
:
function
(
property
reverse
)
{
reverse
=
(
reverse
)
?
-
1
:
1
;
return
function
(
a
b
)
{
a
=
a
[
property
]
;
b
=
b
[
property
]
;
if
(
a
<
b
)
{
return
reverse
*
-
1
;
}
if
(
a
>
b
)
{
return
reverse
*
1
;
}
return
0
;
}
;
}
}
;
return
modules
;
}
(
Modules
|
|
{
}
)
)
;
