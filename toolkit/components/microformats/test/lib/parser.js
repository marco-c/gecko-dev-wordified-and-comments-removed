var
Modules
=
(
function
(
modules
)
{
modules
.
Parser
=
function
(
)
{
this
.
rootPrefix
=
'
h
-
'
;
this
.
propertyPrefixes
=
[
'
p
-
'
'
dt
-
'
'
u
-
'
'
e
-
'
]
;
this
.
excludeTags
=
[
'
br
'
'
hr
'
]
;
}
;
modules
.
maps
=
(
modules
.
maps
)
?
modules
.
maps
:
{
}
;
modules
.
rels
=
(
modules
.
rels
)
?
modules
.
rels
:
{
}
;
modules
.
Parser
.
prototype
=
{
init
:
function
(
)
{
this
.
rootNode
=
null
;
this
.
document
=
null
;
this
.
options
=
{
'
baseUrl
'
:
'
'
'
filters
'
:
[
]
'
textFormat
'
:
'
whitespacetrimmed
'
'
dateFormat
'
:
'
auto
'
'
overlappingVersions
'
:
false
'
impliedPropertiesByVersion
'
:
true
'
parseLatLonGeo
'
:
false
}
;
this
.
rootID
=
0
;
this
.
errors
=
[
]
;
this
.
noContentErr
=
'
No
options
.
node
or
options
.
html
was
provided
and
no
document
object
could
be
found
.
'
;
}
get
:
function
(
options
)
{
var
out
=
this
.
formatEmpty
(
)
data
=
[
]
rels
;
this
.
init
(
)
;
options
=
(
options
)
?
options
:
{
}
;
this
.
mergeOptions
(
options
)
;
this
.
getDOMContext
(
options
)
;
if
(
!
this
.
rootNode
|
|
!
this
.
document
)
{
this
.
errors
.
push
(
this
.
noContentErr
)
;
}
else
{
if
(
this
.
hasMicroformats
(
this
.
rootNode
options
)
)
{
this
.
prepareDOM
(
options
)
;
if
(
this
.
options
.
filters
.
length
>
0
)
{
var
newRootNode
=
this
.
findFilterNodes
(
this
.
rootNode
this
.
options
.
filters
)
;
data
=
this
.
walkRoot
(
newRootNode
)
;
}
else
{
data
=
this
.
walkRoot
(
this
.
rootNode
)
;
}
out
.
items
=
data
;
if
(
modules
.
domUtils
.
canCloneDocument
(
this
.
document
)
=
=
=
false
)
{
this
.
clearUpDom
(
this
.
rootNode
)
;
}
}
if
(
this
.
findRels
)
{
rels
=
this
.
findRels
(
this
.
rootNode
)
;
out
.
rels
=
rels
.
rels
;
out
[
'
rel
-
urls
'
]
=
rels
[
'
rel
-
urls
'
]
;
}
}
if
(
this
.
errors
.
length
>
0
)
{
return
this
.
formatError
(
)
;
}
return
out
;
}
getParent
:
function
(
node
options
)
{
this
.
init
(
)
;
options
=
(
options
)
?
options
:
{
}
;
if
(
node
)
{
return
this
.
getParentTreeWalk
(
node
options
)
;
}
else
{
this
.
errors
.
push
(
this
.
noContentErr
)
;
return
this
.
formatError
(
)
;
}
}
count
:
function
(
options
)
{
var
out
=
{
}
items
classItems
x
i
;
this
.
init
(
)
;
options
=
(
options
)
?
options
:
{
}
;
this
.
getDOMContext
(
options
)
;
if
(
!
this
.
rootNode
|
|
!
this
.
document
)
{
return
{
'
errors
'
:
[
this
.
noContentErr
]
}
;
}
else
{
items
=
this
.
findRootNodes
(
this
.
rootNode
true
)
;
i
=
items
.
length
;
while
(
i
-
-
)
{
classItems
=
modules
.
domUtils
.
getAttributeList
(
items
[
i
]
'
class
'
)
;
x
=
classItems
.
length
;
while
(
x
-
-
)
{
if
(
modules
.
utils
.
startWith
(
classItems
[
x
]
'
h
-
'
)
)
{
this
.
appendCount
(
classItems
[
x
]
1
out
)
;
}
for
(
var
key
in
modules
.
maps
)
{
if
(
modules
.
maps
[
key
]
.
root
=
=
=
classItems
[
x
]
&
&
classItems
.
indexOf
(
key
)
=
=
=
-
1
)
{
this
.
appendCount
(
key
1
out
)
;
}
}
}
}
var
relCount
=
this
.
countRels
(
this
.
rootNode
)
;
if
(
relCount
>
0
)
{
out
.
rels
=
relCount
;
}
return
out
;
}
}
isMicroformat
:
function
(
node
options
)
{
var
classes
i
;
if
(
!
node
)
{
return
false
;
}
node
=
modules
.
domUtils
.
getTopMostNode
(
node
)
;
classes
=
this
.
getUfClassNames
(
node
)
;
if
(
options
&
&
options
.
filters
&
&
modules
.
utils
.
isArray
(
options
.
filters
)
)
{
i
=
options
.
filters
.
length
;
while
(
i
-
-
)
{
if
(
classes
.
root
.
indexOf
(
options
.
filters
[
i
]
)
>
-
1
)
{
return
true
;
}
}
return
false
;
}
else
{
return
(
classes
.
root
.
length
>
0
)
;
}
}
hasMicroformats
:
function
(
node
options
)
{
var
items
i
;
if
(
!
node
)
{
return
false
;
}
node
=
modules
.
domUtils
.
getTopMostNode
(
node
)
;
items
=
this
.
findRootNodes
(
node
true
)
;
if
(
options
&
&
options
.
filters
&
&
modules
.
utils
.
isArray
(
options
.
filters
)
)
{
i
=
items
.
length
;
while
(
i
-
-
)
{
if
(
this
.
isMicroformat
(
items
[
i
]
options
)
)
{
return
true
;
}
}
return
false
;
}
else
{
return
(
items
.
length
>
0
)
;
}
}
add
:
function
(
maps
)
{
maps
.
forEach
(
function
(
map
)
{
if
(
map
&
&
map
.
root
&
&
map
.
name
&
&
map
.
properties
)
{
modules
.
maps
[
map
.
name
]
=
JSON
.
parse
(
JSON
.
stringify
(
map
)
)
;
}
}
)
;
}
getParentTreeWalk
:
function
(
node
options
recursive
)
{
options
=
(
options
)
?
options
:
{
}
;
if
(
recursive
=
=
=
undefined
)
{
if
(
node
.
parentNode
&
&
node
.
nodeName
!
=
=
'
HTML
'
)
{
return
this
.
getParentTreeWalk
(
node
.
parentNode
options
true
)
;
}
else
{
return
this
.
formatEmpty
(
)
;
}
}
if
(
node
!
=
=
null
&
&
node
!
=
=
undefined
&
&
node
.
parentNode
)
{
if
(
this
.
isMicroformat
(
node
options
)
)
{
options
.
node
=
node
;
return
this
.
get
(
options
)
;
}
else
{
return
this
.
getParentTreeWalk
(
node
.
parentNode
options
true
)
;
}
}
else
{
return
this
.
formatEmpty
(
)
;
}
}
getDOMContext
:
function
(
options
)
{
var
nodes
=
modules
.
domUtils
.
getDOMContext
(
options
)
;
this
.
rootNode
=
nodes
.
rootNode
;
this
.
document
=
nodes
.
document
;
}
prepareDOM
:
function
(
options
)
{
var
baseTag
href
;
try
{
if
(
!
options
.
baseUrl
&
&
this
.
document
&
&
this
.
document
.
location
)
{
this
.
options
.
baseUrl
=
this
.
document
.
location
.
href
;
}
}
catch
(
e
)
{
}
baseTag
=
modules
.
domUtils
.
querySelector
(
this
.
document
'
base
'
)
;
if
(
baseTag
)
{
href
=
modules
.
domUtils
.
getAttribute
(
baseTag
'
href
'
)
;
if
(
href
)
{
this
.
options
.
baseUrl
=
href
;
}
}
var
path
newDocument
newRootNode
;
path
=
modules
.
domUtils
.
getNodePath
(
this
.
rootNode
)
;
newDocument
=
modules
.
domUtils
.
cloneDocument
(
this
.
document
)
;
newRootNode
=
modules
.
domUtils
.
getNodeByPath
(
newDocument
path
)
;
if
(
newDocument
&
&
newRootNode
)
{
this
.
document
=
newDocument
;
this
.
rootNode
=
newRootNode
;
}
if
(
this
.
addIncludes
)
{
this
.
addIncludes
(
this
.
document
)
;
}
return
(
this
.
rootNode
&
&
this
.
document
)
;
}
formatError
:
function
(
)
{
var
out
=
this
.
formatEmpty
(
)
;
out
.
errors
=
this
.
errors
;
return
out
;
}
formatEmpty
:
function
(
)
{
return
{
'
items
'
:
[
]
'
rels
'
:
{
}
'
rel
-
urls
'
:
{
}
}
;
}
findFilterNodes
:
function
(
rootNode
filters
)
{
var
newRootNode
=
modules
.
domUtils
.
createNode
(
'
div
'
)
items
=
this
.
findRootNodes
(
rootNode
true
)
i
=
0
x
=
0
y
=
0
;
if
(
items
)
{
i
=
items
.
length
;
while
(
x
<
i
)
{
y
=
filters
.
length
;
while
(
y
-
-
)
{
if
(
this
.
getMapping
(
filters
[
y
]
)
)
{
var
v1Name
=
this
.
getMapping
(
filters
[
y
]
)
.
root
;
filters
.
push
(
v1Name
)
;
}
}
y
=
filters
.
length
;
while
(
y
-
-
)
{
if
(
modules
.
domUtils
.
hasAttributeValue
(
items
[
x
]
'
class
'
filters
[
y
]
)
)
{
var
clone
=
modules
.
domUtils
.
clone
(
items
[
x
]
)
;
modules
.
domUtils
.
appendChild
(
newRootNode
clone
)
;
break
;
}
}
x
+
+
;
}
}
return
newRootNode
;
}
appendCount
:
function
(
name
count
out
)
{
if
(
out
[
name
]
)
{
out
[
name
]
=
out
[
name
]
+
count
;
}
else
{
out
[
name
]
=
count
;
}
}
shouldInclude
:
function
(
uf
filters
)
{
var
i
;
if
(
modules
.
utils
.
isArray
(
filters
)
&
&
filters
.
length
>
0
)
{
i
=
filters
.
length
;
while
(
i
-
-
)
{
if
(
uf
.
type
[
0
]
=
=
=
filters
[
i
]
)
{
return
true
;
}
}
return
false
;
}
else
{
return
true
;
}
}
findRootNodes
:
function
(
rootNode
includeRoot
)
{
var
arr
=
null
out
=
[
]
classList
=
[
]
items
x
i
y
key
;
for
(
key
in
modules
.
maps
)
{
if
(
modules
.
maps
.
hasOwnProperty
(
key
)
)
{
classList
.
push
(
modules
.
maps
[
key
]
.
root
)
;
}
}
includeRoot
=
(
includeRoot
)
?
includeRoot
:
false
;
if
(
includeRoot
&
&
rootNode
.
parentNode
)
{
arr
=
modules
.
domUtils
.
getNodesByAttribute
(
rootNode
.
parentNode
'
class
'
)
;
}
else
{
arr
=
modules
.
domUtils
.
getNodesByAttribute
(
rootNode
'
class
'
)
;
}
x
=
0
;
i
=
arr
.
length
;
while
(
x
<
i
)
{
items
=
modules
.
domUtils
.
getAttributeList
(
arr
[
x
]
'
class
'
)
;
y
=
items
.
length
;
while
(
y
-
-
)
{
if
(
classList
.
indexOf
(
items
[
y
]
)
>
-
1
)
{
out
.
push
(
arr
[
x
]
)
;
break
;
}
if
(
modules
.
utils
.
startWith
(
items
[
y
]
'
h
-
'
)
)
{
out
.
push
(
arr
[
x
]
)
;
break
;
}
}
x
+
+
;
}
return
out
;
}
walkRoot
:
function
(
node
)
{
var
context
=
this
children
=
[
]
child
classes
items
=
[
]
out
=
[
]
;
classes
=
this
.
getUfClassNames
(
node
)
;
if
(
classes
&
&
classes
.
root
.
length
>
0
)
{
items
=
this
.
walkTree
(
node
)
;
if
(
items
.
length
>
0
)
{
out
=
out
.
concat
(
items
)
;
}
}
else
{
children
=
modules
.
domUtils
.
getChildren
(
node
)
;
if
(
children
&
&
children
.
length
>
0
&
&
this
.
findRootNodes
(
node
true
)
.
length
>
-
1
)
{
for
(
var
i
=
0
;
i
<
children
.
length
;
i
+
+
)
{
child
=
children
[
i
]
;
items
=
context
.
walkRoot
(
child
)
;
if
(
items
.
length
>
0
)
{
out
=
out
.
concat
(
items
)
;
}
}
}
}
return
out
;
}
walkTree
:
function
(
node
)
{
var
classes
out
=
[
]
obj
itemRootID
;
classes
=
this
.
getUfClassNames
(
node
)
;
if
(
classes
&
&
classes
.
root
.
length
&
&
classes
.
root
.
length
>
0
)
{
this
.
rootID
+
+
;
itemRootID
=
this
.
rootID
;
obj
=
this
.
createUfObject
(
classes
.
root
classes
.
typeVersion
)
;
this
.
walkChildren
(
node
obj
classes
.
root
itemRootID
classes
)
;
if
(
this
.
impliedRules
)
{
this
.
impliedRules
(
node
obj
classes
)
;
}
out
.
push
(
this
.
cleanUfObject
(
obj
)
)
;
}
return
out
;
}
walkChildren
:
function
(
node
out
ufName
rootID
parentClasses
)
{
var
context
=
this
children
=
[
]
rootItem
itemRootID
value
propertyName
propertyVersion
i
x
y
z
child
;
children
=
modules
.
domUtils
.
getChildren
(
node
)
;
y
=
0
;
z
=
children
.
length
;
while
(
y
<
z
)
{
child
=
children
[
y
]
;
var
classes
=
context
.
getUfClassNames
(
child
ufName
)
;
if
(
classes
.
root
.
length
>
0
&
&
classes
.
properties
.
length
>
0
&
&
!
child
.
addedAsRoot
)
{
rootItem
=
context
.
createUfObject
(
classes
.
root
classes
.
typeVersion
modules
.
text
.
parse
(
this
.
document
child
context
.
options
.
textFormat
)
)
;
propertyName
=
context
.
removePropPrefix
(
classes
.
properties
[
0
]
[
0
]
)
;
if
(
parentClasses
&
&
parentClasses
.
root
.
length
=
=
=
1
&
&
parentClasses
.
properties
.
length
=
=
=
1
)
{
if
(
context
.
impliedValueRule
)
{
out
=
context
.
impliedValueRule
(
out
parentClasses
.
properties
[
0
]
[
0
]
classes
.
properties
[
0
]
[
0
]
value
)
;
}
}
if
(
out
.
properties
[
propertyName
]
)
{
out
.
properties
[
propertyName
]
.
push
(
rootItem
)
;
}
else
{
out
.
properties
[
propertyName
]
=
[
rootItem
]
;
}
context
.
rootID
+
+
;
child
.
addedAsRoot
=
true
;
x
=
0
;
i
=
rootItem
.
type
.
length
;
itemRootID
=
context
.
rootID
;
while
(
x
<
i
)
{
context
.
walkChildren
(
child
rootItem
rootItem
.
type
itemRootID
classes
)
;
x
+
+
;
}
if
(
this
.
impliedRules
)
{
context
.
impliedRules
(
child
rootItem
classes
)
;
}
this
.
cleanUfObject
(
rootItem
)
;
}
if
(
classes
.
root
.
length
=
=
=
0
&
&
classes
.
properties
.
length
>
0
)
{
x
=
0
;
i
=
classes
.
properties
.
length
;
while
(
x
<
i
)
{
value
=
context
.
getValue
(
child
classes
.
properties
[
x
]
[
0
]
out
)
;
propertyName
=
context
.
removePropPrefix
(
classes
.
properties
[
x
]
[
0
]
)
;
propertyVersion
=
classes
.
properties
[
x
]
[
1
]
;
if
(
parentClasses
&
&
parentClasses
.
root
.
length
=
=
=
1
&
&
parentClasses
.
properties
.
length
=
=
=
1
)
{
if
(
context
.
impliedValueRule
)
{
out
=
context
.
impliedValueRule
(
out
parentClasses
.
properties
[
0
]
[
0
]
classes
.
properties
[
x
]
[
0
]
value
)
;
}
}
if
(
!
context
.
hasRootID
(
child
rootID
propertyName
)
)
{
if
(
context
.
isAllowedPropertyVersion
(
out
.
typeVersion
propertyVersion
)
)
{
if
(
out
.
properties
[
propertyName
]
)
{
out
.
properties
[
propertyName
]
.
push
(
value
)
;
}
else
{
out
.
properties
[
propertyName
]
=
[
value
]
;
}
context
.
appendRootID
(
child
rootID
propertyName
)
;
}
}
x
+
+
;
}
context
.
walkChildren
(
child
out
ufName
rootID
classes
)
;
}
if
(
classes
.
root
.
length
=
=
=
0
&
&
classes
.
properties
.
length
=
=
=
0
)
{
context
.
walkChildren
(
child
out
ufName
rootID
classes
)
;
}
if
(
classes
.
root
.
length
>
0
&
&
classes
.
properties
.
length
=
=
=
0
)
{
rootItem
=
context
.
createUfObject
(
classes
.
root
classes
.
typeVersion
modules
.
text
.
parse
(
this
.
document
child
context
.
options
.
textFormat
)
)
;
if
(
!
out
.
children
)
{
out
.
children
=
[
]
;
}
if
(
!
context
.
hasRootID
(
child
rootID
'
child
-
root
'
)
)
{
out
.
children
.
push
(
rootItem
)
;
context
.
appendRootID
(
child
rootID
'
child
-
root
'
)
;
context
.
rootID
+
+
;
}
x
=
0
;
i
=
rootItem
.
type
.
length
;
itemRootID
=
context
.
rootID
;
while
(
x
<
i
)
{
context
.
walkChildren
(
child
rootItem
rootItem
.
type
itemRootID
classes
)
;
x
+
+
;
}
if
(
this
.
impliedRules
)
{
context
.
impliedRules
(
child
rootItem
classes
)
;
}
context
.
cleanUfObject
(
rootItem
)
;
}
y
+
+
;
}
}
getValue
:
function
(
node
className
uf
)
{
var
value
=
'
'
;
if
(
modules
.
utils
.
startWith
(
className
'
p
-
'
)
)
{
value
=
this
.
getPValue
(
node
true
)
;
}
if
(
modules
.
utils
.
startWith
(
className
'
e
-
'
)
)
{
value
=
this
.
getEValue
(
node
)
;
}
if
(
modules
.
utils
.
startWith
(
className
'
u
-
'
)
)
{
value
=
this
.
getUValue
(
node
true
)
;
}
if
(
modules
.
utils
.
startWith
(
className
'
dt
-
'
)
)
{
value
=
this
.
getDTValue
(
node
className
uf
true
)
;
}
return
value
;
}
getPValue
:
function
(
node
valueParse
)
{
var
out
=
'
'
;
if
(
valueParse
)
{
out
=
this
.
getValueClass
(
node
'
p
'
)
;
}
if
(
!
out
&
&
valueParse
)
{
out
=
this
.
getValueTitle
(
node
)
;
}
if
(
!
out
)
{
out
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
abbr
'
]
'
title
'
)
;
}
if
(
!
out
)
{
out
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
data
'
'
input
'
]
'
value
'
)
;
}
if
(
node
.
name
=
=
=
'
br
'
|
|
node
.
name
=
=
=
'
hr
'
)
{
out
=
'
'
;
}
if
(
!
out
)
{
out
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
img
'
'
area
'
]
'
alt
'
)
;
}
if
(
!
out
)
{
out
=
modules
.
text
.
parse
(
this
.
document
node
this
.
options
.
textFormat
)
;
}
return
(
out
)
?
out
:
'
'
;
}
getEValue
:
function
(
node
)
{
var
out
=
{
value
:
'
'
html
:
'
'
}
;
this
.
expandURLs
(
node
'
src
'
this
.
options
.
baseUrl
)
;
this
.
expandURLs
(
node
'
href
'
this
.
options
.
baseUrl
)
;
out
.
value
=
modules
.
text
.
parse
(
this
.
document
node
this
.
options
.
textFormat
)
;
out
.
html
=
modules
.
html
.
parse
(
node
)
;
return
out
;
}
getUValue
:
function
(
node
valueParse
)
{
var
out
=
'
'
;
if
(
valueParse
)
{
out
=
this
.
getValueClass
(
node
'
u
'
)
;
}
if
(
!
out
&
&
valueParse
)
{
out
=
this
.
getValueTitle
(
node
)
;
}
if
(
!
out
)
{
out
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
a
'
'
area
'
]
'
href
'
)
;
}
if
(
!
out
)
{
out
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
img
'
'
audio
'
'
video
'
'
source
'
]
'
src
'
)
;
}
if
(
!
out
)
{
out
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
object
'
]
'
data
'
)
;
}
if
(
out
&
&
out
!
=
=
'
'
&
&
out
.
indexOf
(
'
:
/
/
'
)
=
=
=
-
1
)
{
out
=
modules
.
url
.
resolve
(
out
this
.
options
.
baseUrl
)
;
}
if
(
!
out
)
{
out
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
abbr
'
]
'
title
'
)
;
}
if
(
!
out
)
{
out
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
data
'
'
input
'
]
'
value
'
)
;
}
if
(
!
out
)
{
out
=
modules
.
text
.
parse
(
this
.
document
node
this
.
options
.
textFormat
)
;
}
return
(
out
)
?
out
:
'
'
;
}
getDTValue
:
function
(
node
className
uf
valueParse
)
{
var
out
=
'
'
;
if
(
valueParse
)
{
out
=
this
.
getValueClass
(
node
'
dt
'
)
;
}
if
(
!
out
&
&
valueParse
)
{
out
=
this
.
getValueTitle
(
node
)
;
}
if
(
!
out
)
{
out
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
time
'
'
ins
'
'
del
'
]
'
datetime
'
)
;
}
if
(
!
out
)
{
out
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
abbr
'
]
'
title
'
)
;
}
if
(
!
out
)
{
out
=
modules
.
domUtils
.
getAttrValFromTagList
(
node
[
'
data
'
'
input
'
]
'
value
'
)
;
}
if
(
!
out
)
{
out
=
modules
.
text
.
parse
(
this
.
document
node
this
.
options
.
textFormat
)
;
}
if
(
out
)
{
if
(
modules
.
dates
.
isDuration
(
out
)
)
{
return
out
;
}
else
if
(
modules
.
dates
.
isTime
(
out
)
)
{
if
(
uf
)
{
uf
.
times
.
push
(
[
className
modules
.
dates
.
parseAmPmTime
(
out
this
.
options
.
dateFormat
)
]
)
;
}
return
modules
.
dates
.
parseAmPmTime
(
out
this
.
options
.
dateFormat
)
;
}
else
{
if
(
uf
)
{
uf
.
dates
.
push
(
[
className
new
modules
.
ISODate
(
out
)
.
toString
(
this
.
options
.
dateFormat
)
]
)
;
}
return
new
modules
.
ISODate
(
out
)
.
toString
(
this
.
options
.
dateFormat
)
;
}
}
else
{
return
'
'
;
}
}
appendRootID
:
function
(
node
id
propertyName
)
{
if
(
this
.
hasRootID
(
node
id
propertyName
)
=
=
=
false
)
{
var
rootids
=
[
]
;
if
(
modules
.
domUtils
.
hasAttribute
(
node
'
rootids
'
)
)
{
rootids
=
modules
.
domUtils
.
getAttributeList
(
node
'
rootids
'
)
;
}
rootids
.
push
(
'
id
'
+
id
+
'
-
'
+
propertyName
)
;
modules
.
domUtils
.
setAttribute
(
node
'
rootids
'
rootids
.
join
(
'
'
)
)
;
}
}
hasRootID
:
function
(
node
id
propertyName
)
{
var
rootids
=
[
]
;
if
(
!
modules
.
domUtils
.
hasAttribute
(
node
'
rootids
'
)
)
{
return
false
;
}
else
{
rootids
=
modules
.
domUtils
.
getAttributeList
(
node
'
rootids
'
)
;
return
(
rootids
.
indexOf
(
'
id
'
+
id
+
'
-
'
+
propertyName
)
>
-
1
)
;
}
}
getValueClass
:
function
(
node
propertyType
)
{
var
context
=
this
children
=
[
]
out
=
[
]
child
x
i
;
children
=
modules
.
domUtils
.
getChildren
(
node
)
;
x
=
0
;
i
=
children
.
length
;
while
(
x
<
i
)
{
child
=
children
[
x
]
;
var
value
=
null
;
if
(
modules
.
domUtils
.
hasAttributeValue
(
child
'
class
'
'
value
'
)
)
{
switch
(
propertyType
)
{
case
'
p
'
:
value
=
context
.
getPValue
(
child
false
)
;
break
;
case
'
u
'
:
value
=
context
.
getUValue
(
child
false
)
;
break
;
case
'
dt
'
:
value
=
context
.
getDTValue
(
child
'
'
null
false
)
;
break
;
}
if
(
value
)
{
out
.
push
(
modules
.
utils
.
trim
(
value
)
)
;
}
}
x
+
+
;
}
if
(
out
.
length
>
0
)
{
if
(
propertyType
=
=
=
'
p
'
)
{
return
modules
.
text
.
parseText
(
this
.
document
out
.
join
(
'
'
)
this
.
options
.
textFormat
)
;
}
if
(
propertyType
=
=
=
'
u
'
)
{
return
out
.
join
(
'
'
)
;
}
if
(
propertyType
=
=
=
'
dt
'
)
{
return
modules
.
dates
.
concatFragments
(
out
this
.
options
.
dateFormat
)
.
toString
(
this
.
options
.
dateFormat
)
;
}
}
else
{
return
null
;
}
}
getValueTitle
:
function
(
node
)
{
var
out
=
[
]
items
i
x
;
items
=
modules
.
domUtils
.
getNodesByAttributeValue
(
node
'
class
'
'
value
-
title
'
)
;
x
=
0
;
i
=
items
.
length
;
while
(
x
<
i
)
{
if
(
modules
.
domUtils
.
hasAttribute
(
items
[
x
]
'
title
'
)
)
{
out
.
push
(
modules
.
domUtils
.
getAttribute
(
items
[
x
]
'
title
'
)
)
;
}
x
+
+
;
}
return
out
.
join
(
'
'
)
;
}
hasHClass
:
function
(
node
)
{
var
classes
=
this
.
getUfClassNames
(
node
)
;
if
(
classes
.
root
&
&
classes
.
root
.
length
>
0
)
{
return
true
;
}
else
{
return
false
;
}
}
getUfClassNames
:
function
(
node
ufNameArr
)
{
var
context
=
this
out
=
{
'
root
'
:
[
]
'
properties
'
:
[
]
}
classNames
key
items
item
i
x
z
y
map
prop
propName
v2Name
impiedRel
ufName
;
if
(
modules
.
domUtils
.
hasTagName
(
node
this
.
excludeTags
)
=
=
=
false
)
{
classNames
=
modules
.
domUtils
.
getAttribute
(
node
'
class
'
)
;
if
(
classNames
)
{
items
=
classNames
.
split
(
'
'
)
;
x
=
0
;
i
=
items
.
length
;
while
(
x
<
i
)
{
item
=
modules
.
utils
.
trim
(
items
[
x
]
)
;
if
(
modules
.
utils
.
startWith
(
item
context
.
rootPrefix
)
)
{
if
(
out
.
root
.
indexOf
(
item
)
=
=
=
-
1
)
{
out
.
root
.
push
(
item
)
;
}
out
.
typeVersion
=
'
v2
'
;
}
z
=
context
.
propertyPrefixes
.
length
;
while
(
z
-
-
)
{
if
(
modules
.
utils
.
startWith
(
item
context
.
propertyPrefixes
[
z
]
)
)
{
out
.
properties
.
push
(
[
item
'
v2
'
]
)
;
}
}
for
(
key
in
modules
.
maps
)
{
if
(
modules
.
maps
.
hasOwnProperty
(
key
)
)
{
if
(
modules
.
maps
[
key
]
.
root
=
=
=
item
&
&
out
.
root
.
indexOf
(
key
)
=
=
=
-
1
)
{
if
(
modules
.
maps
[
key
]
.
subTree
)
{
out
.
properties
.
push
(
[
'
p
-
'
+
modules
.
maps
[
key
]
.
root
'
v1
'
]
)
;
}
else
{
out
.
root
.
push
(
key
)
;
if
(
!
out
.
typeVersion
)
{
out
.
typeVersion
=
'
v1
'
;
}
}
}
}
}
if
(
ufNameArr
)
{
for
(
var
a
=
0
;
a
<
ufNameArr
.
length
;
a
+
+
)
{
ufName
=
ufNameArr
[
a
]
;
map
=
context
.
getMapping
(
ufName
)
;
if
(
map
)
{
for
(
key
in
map
.
properties
)
{
if
(
map
.
properties
.
hasOwnProperty
(
key
)
)
{
prop
=
map
.
properties
[
key
]
;
propName
=
(
prop
.
map
)
?
prop
.
map
:
'
p
-
'
+
key
;
if
(
key
=
=
=
item
)
{
if
(
prop
.
uf
)
{
y
=
0
;
while
(
y
<
i
)
{
v2Name
=
context
.
getV2RootName
(
items
[
y
]
)
;
if
(
prop
.
uf
.
indexOf
(
v2Name
)
>
-
1
&
&
out
.
root
.
indexOf
(
v2Name
)
=
=
=
-
1
)
{
out
.
root
.
push
(
v2Name
)
;
out
.
typeVersion
=
'
v1
'
;
}
y
+
+
;
}
if
(
out
.
properties
.
indexOf
(
propName
)
=
=
=
-
1
)
{
out
.
properties
.
push
(
[
propName
'
v1
'
]
)
;
}
}
else
{
if
(
out
.
properties
.
indexOf
(
propName
)
=
=
=
-
1
)
{
out
.
properties
.
push
(
[
propName
'
v1
'
]
)
;
}
}
}
}
}
}
}
}
x
+
+
;
}
}
}
if
(
ufNameArr
&
&
this
.
findRelImpied
)
{
for
(
var
b
=
0
;
b
<
ufNameArr
.
length
;
b
+
+
)
{
ufName
=
ufNameArr
[
b
]
;
impiedRel
=
this
.
findRelImpied
(
node
ufName
)
;
if
(
impiedRel
&
&
out
.
properties
.
indexOf
(
impiedRel
)
=
=
=
-
1
)
{
out
.
properties
.
push
(
[
impiedRel
'
v1
'
]
)
;
}
}
}
return
out
;
}
getMapping
:
function
(
name
)
{
var
key
;
for
(
key
in
modules
.
maps
)
{
if
(
modules
.
maps
[
key
]
.
root
=
=
=
name
|
|
key
=
=
=
name
)
{
return
modules
.
maps
[
key
]
;
}
}
return
null
;
}
getV2RootName
:
function
(
name
)
{
var
key
;
for
(
key
in
modules
.
maps
)
{
if
(
modules
.
maps
[
key
]
.
root
=
=
=
name
)
{
return
key
;
}
}
return
null
;
}
isAllowedPropertyVersion
:
function
(
typeVersion
propertyVersion
)
{
if
(
this
.
options
.
overlappingVersions
=
=
=
true
)
{
return
true
;
}
else
{
return
(
typeVersion
=
=
=
propertyVersion
)
;
}
}
createUfObject
:
function
(
names
typeVersion
value
)
{
var
out
=
{
}
;
if
(
value
&
&
modules
.
utils
.
isOnlyWhiteSpace
(
value
)
=
=
=
false
)
{
out
.
value
=
value
;
}
if
(
modules
.
utils
.
isArray
(
names
)
)
{
out
.
type
=
names
;
}
else
{
out
.
type
=
[
names
]
;
}
out
.
properties
=
{
}
;
out
.
typeVersion
=
typeVersion
;
out
.
times
=
[
]
;
out
.
dates
=
[
]
;
out
.
altValue
=
null
;
return
out
;
}
cleanUfObject
:
function
(
microformat
)
{
delete
microformat
.
times
;
delete
microformat
.
dates
;
delete
microformat
.
typeVersion
;
delete
microformat
.
altValue
;
return
microformat
;
}
removePropPrefix
:
function
(
text
)
{
var
i
;
i
=
this
.
propertyPrefixes
.
length
;
while
(
i
-
-
)
{
var
prefix
=
this
.
propertyPrefixes
[
i
]
;
if
(
modules
.
utils
.
startWith
(
text
prefix
)
)
{
text
=
text
.
substr
(
prefix
.
length
)
;
}
}
return
text
;
}
expandURLs
:
function
(
node
attrName
baseUrl
)
{
var
i
nodes
attr
;
nodes
=
modules
.
domUtils
.
getNodesByAttribute
(
node
attrName
)
;
i
=
nodes
.
length
;
while
(
i
-
-
)
{
try
{
attr
=
modules
.
domUtils
.
getAttribute
(
nodes
[
i
]
attrName
)
;
if
(
attr
&
&
attr
!
=
=
'
'
&
&
baseUrl
!
=
=
'
'
&
&
attr
.
indexOf
(
'
:
/
/
'
)
=
=
=
-
1
)
{
attr
=
modules
.
url
.
resolve
(
attr
baseUrl
)
;
modules
.
domUtils
.
setAttribute
(
nodes
[
i
]
attrName
attr
)
;
}
}
catch
(
err
)
{
}
}
}
mergeOptions
:
function
(
options
)
{
var
key
;
for
(
key
in
options
)
{
if
(
options
.
hasOwnProperty
(
key
)
)
{
this
.
options
[
key
]
=
options
[
key
]
;
}
}
}
removeRootIds
:
function
(
rootNode
)
{
var
arr
i
;
arr
=
modules
.
domUtils
.
getNodesByAttribute
(
rootNode
'
rootids
'
)
;
i
=
arr
.
length
;
while
(
i
-
-
)
{
modules
.
domUtils
.
removeAttribute
(
arr
[
i
]
'
rootids
'
)
;
}
}
clearUpDom
:
function
(
rootNode
)
{
if
(
this
.
removeIncludes
)
{
this
.
removeIncludes
(
rootNode
)
;
}
this
.
removeRootIds
(
rootNode
)
;
}
}
;
modules
.
Parser
.
prototype
.
constructor
=
modules
.
Parser
;
return
modules
;
}
(
Modules
|
|
{
}
)
)
;
