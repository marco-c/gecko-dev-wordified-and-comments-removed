"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ExperimentManager
"
"
_ExperimentManager
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
FirstStartup
:
"
resource
:
/
/
gre
/
modules
/
FirstStartup
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
ClientEnvironment
:
"
resource
:
/
/
normandy
/
lib
/
ClientEnvironment
.
jsm
"
ExperimentStore
:
"
resource
:
/
/
nimbus
/
lib
/
ExperimentStore
.
jsm
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
NormandyUtils
:
"
resource
:
/
/
normandy
/
lib
/
NormandyUtils
.
jsm
"
Sampling
:
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
Sampling
.
jsm
"
TelemetryEvents
:
"
resource
:
/
/
normandy
/
lib
/
TelemetryEvents
.
jsm
"
TelemetryEnvironment
:
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
PrefUtils
:
"
resource
:
/
/
normandy
/
lib
/
PrefUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
log
"
(
)
=
>
{
const
{
Logger
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
messaging
-
system
/
lib
/
Logger
.
jsm
"
)
;
return
new
Logger
(
"
ExperimentManager
"
)
;
}
)
;
const
TELEMETRY_EVENT_OBJECT
=
"
nimbus_experiment
"
;
const
TELEMETRY_EXPERIMENT_ACTIVE_PREFIX
=
"
nimbus
-
"
;
const
TELEMETRY_DEFAULT_EXPERIMENT_TYPE
=
"
nimbus
"
;
const
UPLOAD_ENABLED_PREF
=
"
datareporting
.
healthreport
.
uploadEnabled
"
;
const
STUDIES_OPT_OUT_PREF
=
"
app
.
shield
.
optoutstudies
.
enabled
"
;
const
STUDIES_ENABLED_CHANGED
=
"
nimbus
:
studies
-
enabled
-
changed
"
;
function
featuresCompat
(
branch
)
{
if
(
!
branch
|
|
(
!
branch
.
feature
&
&
!
branch
.
features
)
)
{
return
[
]
;
}
let
{
features
}
=
branch
;
if
(
!
features
)
{
features
=
[
branch
.
feature
]
;
}
return
features
;
}
function
getFeatureFromBranch
(
branch
featureId
)
{
return
featuresCompat
(
branch
)
.
find
(
featureConfig
=
>
featureConfig
.
featureId
=
=
=
featureId
)
;
}
class
_ExperimentManager
{
constructor
(
{
id
=
"
experimentmanager
"
store
}
=
{
}
)
{
this
.
id
=
id
;
this
.
store
=
store
|
|
new
lazy
.
ExperimentStore
(
)
;
this
.
sessions
=
new
Map
(
)
;
this
.
extraContext
=
{
}
;
Services
.
prefs
.
addObserver
(
UPLOAD_ENABLED_PREF
this
)
;
Services
.
prefs
.
addObserver
(
STUDIES_OPT_OUT_PREF
this
)
;
this
.
_prefs
=
new
Map
(
)
;
this
.
_prefsBySlug
=
new
Map
(
)
;
}
get
studiesEnabled
(
)
{
return
(
Services
.
prefs
.
getBoolPref
(
UPLOAD_ENABLED_PREF
)
&
&
Services
.
prefs
.
getBoolPref
(
STUDIES_OPT_OUT_PREF
)
)
;
}
createTargetingContext
(
)
{
let
context
=
{
isFirstStartup
:
lazy
.
FirstStartup
.
state
=
=
=
lazy
.
FirstStartup
.
IN_PROGRESS
.
.
.
this
.
extraContext
}
;
Object
.
defineProperty
(
context
"
activeExperiments
"
{
get
:
async
(
)
=
>
{
await
this
.
store
.
ready
(
)
;
return
this
.
store
.
getAllActive
(
)
.
map
(
exp
=
>
exp
.
slug
)
;
}
}
)
;
Object
.
defineProperty
(
context
"
activeRollouts
"
{
get
:
async
(
)
=
>
{
await
this
.
store
.
ready
(
)
;
return
this
.
store
.
getAllRollouts
(
)
.
map
(
rollout
=
>
rollout
.
slug
)
;
}
}
)
;
return
context
;
}
async
onStartup
(
extraContext
=
{
}
)
{
await
this
.
store
.
init
(
)
;
this
.
extraContext
=
extraContext
;
const
restoredExperiments
=
this
.
store
.
getAllActive
(
)
;
const
restoredRollouts
=
this
.
store
.
getAllRollouts
(
)
;
for
(
const
experiment
of
restoredExperiments
)
{
this
.
setExperimentActive
(
experiment
)
;
if
(
this
.
_restoreEnrollmentPrefs
(
experiment
)
)
{
this
.
_updatePrefObservers
(
experiment
)
;
}
}
for
(
const
rollout
of
restoredRollouts
)
{
this
.
setExperimentActive
(
rollout
)
;
if
(
this
.
_restoreEnrollmentPrefs
(
rollout
)
)
{
this
.
_updatePrefObservers
(
rollout
)
;
}
}
this
.
observe
(
)
;
}
async
onRecipe
(
recipe
source
)
{
const
{
slug
isEnrollmentPaused
}
=
recipe
;
if
(
!
source
)
{
throw
new
Error
(
"
When
calling
onRecipe
you
must
specify
a
source
.
"
)
;
}
if
(
!
this
.
sessions
.
has
(
source
)
)
{
this
.
sessions
.
set
(
source
new
Set
(
)
)
;
}
this
.
sessions
.
get
(
source
)
.
add
(
slug
)
;
if
(
this
.
store
.
has
(
slug
)
)
{
this
.
updateEnrollment
(
recipe
)
;
}
else
if
(
isEnrollmentPaused
)
{
lazy
.
log
.
debug
(
Enrollment
is
paused
for
"
{
slug
}
"
)
;
}
else
if
(
!
(
await
this
.
isInBucketAllocation
(
recipe
.
bucketConfig
)
)
)
{
lazy
.
log
.
debug
(
"
Client
was
not
enrolled
because
of
the
bucket
sampling
"
)
;
}
else
{
await
this
.
enroll
(
recipe
source
)
;
}
}
_checkUnseenEnrollments
(
enrollments
sourceToCheck
recipeMismatches
invalidRecipes
invalidBranches
invalidFeatures
)
{
for
(
const
enrollment
of
enrollments
)
{
const
{
slug
source
}
=
enrollment
;
if
(
sourceToCheck
!
=
=
source
)
{
continue
;
}
if
(
!
this
.
sessions
.
get
(
source
)
?
.
has
(
slug
)
)
{
lazy
.
log
.
debug
(
Stopping
study
for
recipe
{
slug
}
)
;
try
{
let
reason
;
if
(
recipeMismatches
.
includes
(
slug
)
)
{
reason
=
"
targeting
-
mismatch
"
;
}
else
if
(
invalidRecipes
.
includes
(
slug
)
)
{
reason
=
"
invalid
-
recipe
"
;
}
else
if
(
invalidBranches
.
has
(
slug
)
|
|
invalidFeatures
.
has
(
slug
)
)
{
reason
=
"
invalid
-
branch
"
;
}
else
{
reason
=
"
recipe
-
not
-
seen
"
;
}
this
.
unenroll
(
slug
reason
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
}
}
onFinalize
(
sourceToCheck
{
recipeMismatches
=
[
]
invalidRecipes
=
[
]
invalidBranches
=
new
Map
(
)
invalidFeatures
=
new
Map
(
)
validationEnabled
=
true
}
=
{
}
)
{
if
(
!
sourceToCheck
)
{
throw
new
Error
(
"
When
calling
onFinalize
you
must
specify
a
source
.
"
)
;
}
const
activeExperiments
=
this
.
store
.
getAllActive
(
)
;
const
activeRollouts
=
this
.
store
.
getAllRollouts
(
)
;
this
.
_checkUnseenEnrollments
(
activeExperiments
sourceToCheck
recipeMismatches
invalidRecipes
invalidBranches
invalidFeatures
)
;
this
.
_checkUnseenEnrollments
(
activeRollouts
sourceToCheck
recipeMismatches
invalidRecipes
invalidBranches
invalidFeatures
)
;
if
(
validationEnabled
)
{
for
(
const
slug
of
invalidRecipes
)
{
this
.
sendValidationFailedTelemetry
(
slug
"
invalid
-
recipe
"
)
;
}
for
(
const
[
slug
branches
]
of
invalidBranches
.
entries
(
)
)
{
for
(
const
branch
of
branches
)
{
this
.
sendValidationFailedTelemetry
(
slug
"
invalid
-
branch
"
{
branch
}
)
;
}
}
for
(
const
[
slug
featureIds
]
of
invalidFeatures
.
entries
(
)
)
{
for
(
const
featureId
of
featureIds
)
{
this
.
sendValidationFailedTelemetry
(
slug
"
invalid
-
feature
"
{
feature
:
featureId
}
)
;
}
}
}
this
.
sessions
.
delete
(
sourceToCheck
)
;
}
isInBucketAllocation
(
bucketConfig
)
{
if
(
!
bucketConfig
)
{
lazy
.
log
.
debug
(
"
Cannot
enroll
if
recipe
bucketConfig
is
not
set
.
"
)
;
return
false
;
}
let
id
;
if
(
bucketConfig
.
randomizationUnit
=
=
=
"
normandy_id
"
)
{
id
=
lazy
.
ClientEnvironment
.
userId
;
}
else
{
lazy
.
log
.
debug
(
Invalid
randomizationUnit
:
{
bucketConfig
.
randomizationUnit
}
)
;
return
false
;
}
return
lazy
.
Sampling
.
bucketSample
(
[
id
bucketConfig
.
namespace
]
bucketConfig
.
start
bucketConfig
.
count
bucketConfig
.
total
)
;
}
async
enroll
(
recipe
source
)
{
let
{
slug
branches
}
=
recipe
;
if
(
this
.
store
.
has
(
slug
)
)
{
this
.
sendFailureTelemetry
(
"
enrollFailed
"
slug
"
name
-
conflict
"
)
;
throw
new
Error
(
An
experiment
with
the
slug
"
{
slug
}
"
already
exists
.
)
;
}
let
storeLookupByFeature
=
recipe
.
isRollout
?
this
.
store
.
getRolloutForFeature
.
bind
(
this
.
store
)
:
this
.
store
.
hasExperimentForFeature
.
bind
(
this
.
store
)
;
const
branch
=
await
this
.
chooseBranch
(
slug
branches
)
;
const
features
=
featuresCompat
(
branch
)
;
for
(
let
feature
of
features
)
{
if
(
storeLookupByFeature
(
feature
?
.
featureId
)
)
{
lazy
.
log
.
debug
(
Skipping
enrollment
for
"
{
slug
}
"
because
there
is
an
existing
{
recipe
.
isRollout
?
"
rollout
"
:
"
experiment
"
}
for
this
feature
.
)
;
this
.
sendFailureTelemetry
(
"
enrollFailed
"
slug
"
feature
-
conflict
"
)
;
return
null
;
}
}
return
this
.
_enroll
(
recipe
branch
source
)
;
}
_enroll
(
{
slug
experimentType
=
TELEMETRY_DEFAULT_EXPERIMENT_TYPE
userFacingName
userFacingDescription
featureIds
isRollout
}
branch
source
options
=
{
}
)
{
const
{
prefs
prefsToSet
}
=
this
.
_getPrefsForBranch
(
branch
isRollout
)
;
const
experiment
=
{
slug
branch
active
:
true
enrollmentId
:
lazy
.
NormandyUtils
.
generateUuid
(
)
experimentType
source
userFacingName
userFacingDescription
lastSeen
:
new
Date
(
)
.
toJSON
(
)
featureIds
prefs
}
;
if
(
typeof
isRollout
!
=
=
"
undefined
"
)
{
experiment
.
isRollout
=
isRollout
;
}
if
(
options
.
force
)
{
experiment
.
force
=
true
;
}
if
(
isRollout
)
{
experiment
.
experimentType
=
"
rollout
"
;
this
.
store
.
addEnrollment
(
experiment
)
;
this
.
setExperimentActive
(
experiment
)
;
}
else
{
this
.
store
.
addEnrollment
(
experiment
)
;
this
.
setExperimentActive
(
experiment
)
;
}
this
.
sendEnrollmentTelemetry
(
experiment
)
;
this
.
_setEnrollmentPrefs
(
prefsToSet
)
;
this
.
_updatePrefObservers
(
experiment
)
;
lazy
.
log
.
debug
(
New
{
isRollout
?
"
rollout
"
:
"
experiment
"
}
started
:
{
slug
}
{
branch
.
slug
}
)
;
return
experiment
;
}
forceEnroll
(
recipe
branch
source
=
"
force
-
enrollment
"
)
{
const
features
=
featuresCompat
(
branch
)
;
for
(
let
feature
of
features
)
{
const
isRollout
=
recipe
.
isRollout
?
?
false
;
let
enrollment
=
isRollout
?
this
.
store
.
getRolloutForFeature
(
feature
?
.
featureId
)
:
this
.
store
.
getExperimentForFeature
(
feature
?
.
featureId
)
;
if
(
enrollment
)
{
lazy
.
log
.
debug
(
Existing
{
isRollout
?
"
rollout
"
:
"
experiment
"
}
found
for
the
same
feature
{
feature
.
featureId
}
unenrolling
.
)
;
this
.
unenroll
(
enrollment
.
slug
source
)
;
}
}
recipe
.
userFacingName
=
{
recipe
.
userFacingName
}
-
Forced
enrollment
;
const
slug
=
optin
-
{
recipe
.
slug
}
;
const
enrollment
=
this
.
_enroll
(
{
.
.
.
recipe
slug
}
branch
source
{
force
:
true
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
nimbus
:
force
-
enroll
"
slug
)
;
return
enrollment
;
}
updateEnrollment
(
recipe
)
{
const
enrollment
=
this
.
store
.
get
(
recipe
.
slug
)
;
if
(
enrollment
.
active
=
=
=
false
)
{
lazy
.
log
.
debug
(
Enrollment
{
recipe
.
slug
}
has
expired
aborting
.
)
;
return
false
;
}
const
branch
=
recipe
.
branches
.
find
(
branch
=
>
branch
.
slug
=
=
=
enrollment
.
branch
.
slug
)
;
if
(
!
branch
)
{
this
.
unenroll
(
recipe
.
slug
"
branch
-
removed
"
)
;
}
return
true
;
}
unenroll
(
slug
reason
=
"
unknown
"
)
{
const
enrollment
=
this
.
store
.
get
(
slug
)
;
if
(
!
enrollment
)
{
this
.
sendFailureTelemetry
(
"
unenrollFailed
"
slug
"
does
-
not
-
exist
"
)
;
throw
new
Error
(
Could
not
find
an
experiment
with
the
slug
"
{
slug
}
"
)
;
}
this
.
_unenroll
(
enrollment
{
reason
}
)
;
}
_unenroll
(
enrollment
{
reason
=
"
unknown
"
changedPref
=
undefined
duringRestore
=
false
}
=
{
}
)
{
const
{
slug
}
=
enrollment
;
if
(
!
enrollment
.
active
)
{
this
.
sendFailureTelemetry
(
"
unenrollFailed
"
slug
"
already
-
unenrolled
"
)
;
throw
new
Error
(
Cannot
stop
experiment
"
{
slug
}
"
because
it
is
already
expired
)
;
}
lazy
.
TelemetryEnvironment
.
setExperimentInactive
(
slug
)
;
Services
.
fog
.
setExperimentInactive
(
slug
)
;
this
.
store
.
updateExperiment
(
slug
{
active
:
false
}
)
;
lazy
.
TelemetryEvents
.
sendEvent
(
"
unenroll
"
TELEMETRY_EVENT_OBJECT
slug
{
reason
branch
:
enrollment
.
branch
.
slug
enrollmentId
:
enrollment
.
enrollmentId
|
|
lazy
.
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
Glean
.
nimbusEvents
.
unenrollment
.
record
(
{
experiment
:
slug
branch
:
enrollment
.
branch
.
slug
enrollment_id
:
enrollment
.
enrollmentId
|
|
lazy
.
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
reason
}
)
;
this
.
_unsetEnrollmentPrefs
(
enrollment
{
changedPref
duringRestore
}
)
;
lazy
.
log
.
debug
(
Recipe
unenrolled
:
{
slug
}
)
;
}
observe
(
aSubject
aTopic
aPrefName
)
{
if
(
!
this
.
studiesEnabled
)
{
for
(
const
{
slug
}
of
this
.
store
.
getAllActive
(
)
)
{
this
.
unenroll
(
slug
"
studies
-
opt
-
out
"
)
;
}
for
(
const
{
slug
}
of
this
.
store
.
getAllRollouts
(
)
)
{
this
.
unenroll
(
slug
"
studies
-
opt
-
out
"
)
;
}
}
Services
.
obs
.
notifyObservers
(
null
STUDIES_ENABLED_CHANGED
)
;
}
sendFailureTelemetry
(
eventName
slug
reason
)
{
lazy
.
TelemetryEvents
.
sendEvent
(
eventName
TELEMETRY_EVENT_OBJECT
slug
{
reason
}
)
;
if
(
eventName
=
=
"
enrollFailed
"
)
{
Glean
.
nimbusEvents
.
enrollFailed
.
record
(
{
experiment
:
slug
reason
}
)
;
}
else
if
(
eventName
=
=
"
unenrollFailed
"
)
{
Glean
.
nimbusEvents
.
unenrollFailed
.
record
(
{
experiment
:
slug
reason
}
)
;
}
}
sendValidationFailedTelemetry
(
slug
reason
extra
)
{
lazy
.
TelemetryEvents
.
sendEvent
(
"
validationFailed
"
TELEMETRY_EVENT_OBJECT
slug
{
reason
.
.
.
extra
}
)
;
Glean
.
nimbusEvents
.
validationFailed
.
record
(
{
experiment
:
slug
reason
.
.
.
extra
}
)
;
}
sendEnrollmentTelemetry
(
{
slug
branch
experimentType
enrollmentId
}
)
{
lazy
.
TelemetryEvents
.
sendEvent
(
"
enroll
"
TELEMETRY_EVENT_OBJECT
slug
{
experimentType
branch
:
branch
.
slug
enrollmentId
:
enrollmentId
|
|
lazy
.
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
Glean
.
nimbusEvents
.
enrollment
.
record
(
{
experiment
:
slug
branch
:
branch
.
slug
enrollment_id
:
enrollmentId
|
|
lazy
.
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
experiment_type
:
experimentType
}
)
;
}
setExperimentActive
(
experiment
)
{
lazy
.
TelemetryEnvironment
.
setExperimentActive
(
experiment
.
slug
experiment
.
branch
.
slug
{
type
:
{
TELEMETRY_EXPERIMENT_ACTIVE_PREFIX
}
{
experiment
.
experimentType
}
enrollmentId
:
experiment
.
enrollmentId
|
|
lazy
.
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
Services
.
fog
.
setExperimentActive
(
experiment
.
slug
experiment
.
branch
.
slug
{
type
:
{
TELEMETRY_EXPERIMENT_ACTIVE_PREFIX
}
{
experiment
.
experimentType
}
enrollmentId
:
experiment
.
enrollmentId
|
|
lazy
.
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
}
async
generateTestIds
(
{
slug
branches
namespace
start
count
total
}
)
{
const
branchValues
=
{
}
;
if
(
!
slug
|
|
!
namespace
)
{
throw
new
Error
(
slug
namespace
not
in
expected
format
)
;
}
if
(
!
(
start
<
total
&
&
count
<
total
)
)
{
throw
new
Error
(
"
Must
include
start
count
and
total
as
integers
"
)
;
}
if
(
!
Array
.
isArray
(
branches
)
|
|
branches
.
filter
(
branch
=
>
branch
.
slug
&
&
branch
.
ratio
)
.
length
!
=
=
branches
.
length
)
{
throw
new
Error
(
"
branches
parameter
not
in
expected
format
"
)
;
}
while
(
Object
.
keys
(
branchValues
)
.
length
<
branches
.
length
+
1
)
{
const
id
=
lazy
.
NormandyUtils
.
generateUuid
(
)
;
const
enrolls
=
await
lazy
.
Sampling
.
bucketSample
(
[
id
namespace
]
start
count
total
)
;
if
(
enrolls
)
{
const
{
slug
:
pickedBranch
}
=
await
this
.
chooseBranch
(
slug
branches
id
)
;
if
(
!
Object
.
keys
(
branchValues
)
.
includes
(
pickedBranch
)
)
{
branchValues
[
pickedBranch
]
=
id
;
lazy
.
log
.
debug
(
Found
a
value
for
"
{
pickedBranch
}
"
)
;
}
}
else
if
(
!
branchValues
.
notInExperiment
)
{
branchValues
.
notInExperiment
=
id
;
}
}
return
branchValues
;
}
async
chooseBranch
(
slug
branches
userId
=
lazy
.
ClientEnvironment
.
userId
)
{
const
ratios
=
branches
.
map
(
(
{
ratio
=
1
}
)
=
>
ratio
)
;
const
input
=
{
this
.
id
}
-
{
userId
}
-
{
slug
}
-
branch
;
const
index
=
await
lazy
.
Sampling
.
ratioSample
(
input
ratios
)
;
return
branches
[
index
]
;
}
_getPrefsForBranch
(
branch
isRollout
=
false
)
{
const
prefs
=
[
]
;
const
prefsToSet
=
[
]
;
const
getConflictingEnrollment
=
this
.
_makeEnrollmentCache
(
isRollout
)
;
for
(
const
{
featureId
value
:
featureValue
}
of
featuresCompat
(
branch
)
)
{
const
feature
=
lazy
.
NimbusFeatures
[
featureId
]
;
if
(
!
feature
)
{
continue
;
}
const
conflictingEnrollment
=
getConflictingEnrollment
(
featureId
)
;
const
prefBranch
=
feature
.
manifest
.
isEarlyStartup
?
?
false
?
"
user
"
:
"
default
"
;
for
(
const
[
variable
value
]
of
Object
.
entries
(
featureValue
)
)
{
const
prefName
=
feature
.
getSetPrefName
(
variable
)
;
if
(
prefName
)
{
let
originalValue
;
const
conflictingPref
=
conflictingEnrollment
?
.
prefs
?
.
find
(
p
=
>
p
.
name
=
=
=
prefName
)
;
if
(
conflictingPref
)
{
originalValue
=
conflictingPref
.
originalValue
;
}
else
if
(
prefBranch
=
=
=
"
user
"
&
&
!
Services
.
prefs
.
prefHasUserValue
(
prefName
)
)
{
originalValue
=
null
;
}
else
{
originalValue
=
lazy
.
PrefUtils
.
getPref
(
prefName
{
branch
:
prefBranch
}
)
;
}
prefs
.
push
(
{
name
:
prefName
branch
:
prefBranch
featureId
variable
originalValue
}
)
;
if
(
!
isRollout
|
|
!
conflictingPref
)
{
prefsToSet
.
push
(
{
name
:
prefName
value
prefBranch
}
)
;
}
}
}
}
return
{
prefs
prefsToSet
}
;
}
_setEnrollmentPrefs
(
prefsToSet
)
{
for
(
const
{
name
value
prefBranch
}
of
prefsToSet
)
{
const
entry
=
this
.
_prefs
.
get
(
name
)
;
if
(
entry
)
{
entry
.
enrollmentChanging
=
true
;
}
lazy
.
PrefUtils
.
setPref
(
name
value
{
branch
:
prefBranch
}
)
;
if
(
entry
)
{
entry
.
enrollmentChanging
=
false
;
}
}
}
_unsetEnrollmentPrefs
(
enrollment
{
changedPref
duringRestore
}
=
{
}
)
{
if
(
!
enrollment
.
prefs
?
.
length
)
{
return
;
}
const
getConflictingEnrollment
=
this
.
_makeEnrollmentCache
(
enrollment
.
isRollout
)
;
for
(
const
pref
of
enrollment
.
prefs
)
{
this
.
_removePrefObserver
(
pref
.
name
enrollment
.
slug
)
;
if
(
changedPref
?
.
name
=
=
pref
.
name
&
&
changedPref
.
branch
=
=
=
pref
.
branch
)
{
continue
;
}
let
newValue
=
pref
.
originalValue
;
if
(
!
duringRestore
|
|
enrollment
.
isRollout
)
{
const
conflictingEnrollment
=
getConflictingEnrollment
(
pref
.
featureId
)
;
const
conflictingPref
=
conflictingEnrollment
?
.
prefs
?
.
find
(
p
=
>
p
.
name
=
=
=
pref
.
name
)
;
if
(
conflictingPref
)
{
if
(
enrollment
.
isRollout
)
{
continue
;
}
else
{
newValue
=
getFeatureFromBranch
(
conflictingEnrollment
.
branch
pref
.
featureId
)
.
value
[
pref
.
variable
]
;
}
}
}
const
entry
=
this
.
_prefs
.
get
(
pref
.
name
)
;
if
(
entry
)
{
entry
.
enrollmentChanging
=
true
;
}
lazy
.
PrefUtils
.
setPref
(
pref
.
name
newValue
{
branch
:
pref
.
branch
}
)
;
if
(
entry
)
{
entry
.
enrollmentChanging
=
false
;
}
}
}
_restoreEnrollmentPrefs
(
enrollment
)
{
const
{
branch
prefs
=
[
]
isRollout
}
=
enrollment
;
if
(
!
prefs
?
.
length
)
{
return
false
;
}
const
featuresById
=
Object
.
assign
(
.
.
.
featuresCompat
(
branch
)
.
map
(
f
=
>
(
{
[
f
.
featureId
]
:
f
}
)
)
)
;
for
(
const
{
name
featureId
variable
}
of
prefs
)
{
if
(
!
Object
.
hasOwn
(
lazy
.
NimbusFeatures
featureId
)
)
{
this
.
_unenroll
(
enrollment
{
reason
:
"
invalid
-
feature
"
duringRestore
:
true
}
)
;
return
false
;
}
const
variables
=
lazy
.
NimbusFeatures
[
featureId
]
.
manifest
.
variables
;
if
(
!
Object
.
hasOwn
(
variables
variable
)
)
{
this
.
_unenroll
(
enrollment
{
reason
:
"
pref
-
variable
-
missing
"
duringRestore
:
true
}
)
;
return
false
;
}
const
variableDef
=
variables
[
variable
]
;
if
(
!
Object
.
hasOwn
(
variableDef
"
setPref
"
)
)
{
this
.
_unenroll
(
enrollment
{
reason
:
"
pref
-
variable
-
no
-
longer
"
duringRestore
:
true
}
)
;
return
false
;
}
if
(
variableDef
.
setPref
!
=
=
name
)
{
this
.
_unenroll
(
enrollment
{
reason
:
"
pref
-
variable
-
changed
"
duringRestore
:
true
}
)
;
return
false
;
}
}
for
(
const
{
name
branch
:
prefBranch
featureId
variable
}
of
prefs
)
{
if
(
prefBranch
=
=
=
"
user
"
)
{
continue
;
}
if
(
isRollout
)
{
const
conflictingEnrollment
=
this
.
store
.
getExperimentForFeature
(
featureId
)
;
const
conflictingPref
=
conflictingEnrollment
?
.
prefs
?
.
find
(
p
=
>
p
.
name
=
=
=
name
)
;
if
(
conflictingPref
)
{
continue
;
}
}
const
value
=
featuresById
[
featureId
]
.
value
[
variable
]
;
if
(
prefBranch
!
=
=
"
user
"
)
{
lazy
.
PrefUtils
.
setPref
(
name
value
{
branch
:
prefBranch
}
)
;
}
}
return
true
;
}
_makeEnrollmentCache
(
isRollout
)
{
const
getOtherEnrollment
=
(
isRollout
?
this
.
store
.
getExperimentForFeature
:
this
.
store
.
getRolloutForFeature
)
.
bind
(
this
.
store
)
;
const
conflictingEnrollments
=
{
}
;
return
featureId
=
>
{
if
(
!
Object
.
hasOwn
(
conflictingEnrollments
featureId
)
)
{
conflictingEnrollments
[
featureId
]
=
getOtherEnrollment
(
featureId
)
;
}
return
conflictingEnrollments
[
featureId
]
;
}
;
}
_updatePrefObservers
(
{
slug
prefs
}
)
{
if
(
!
prefs
?
.
length
)
{
return
;
}
for
(
const
pref
of
prefs
)
{
const
{
name
}
=
pref
;
if
(
!
this
.
_prefs
.
has
(
name
)
)
{
const
observer
=
(
)
=
>
this
.
_onExperimentPrefChanged
(
pref
)
;
const
entry
=
{
slugs
:
new
Set
(
[
slug
]
)
enrollmentChanging
:
false
observer
}
;
Services
.
prefs
.
addObserver
(
name
observer
)
;
this
.
_prefs
.
set
(
name
entry
)
;
}
else
{
this
.
_prefs
.
get
(
name
)
.
slugs
.
add
(
slug
)
;
}
if
(
!
this
.
_prefsBySlug
.
has
(
slug
)
)
{
this
.
_prefsBySlug
.
set
(
slug
new
Set
(
[
name
]
)
)
;
}
else
{
this
.
_prefsBySlug
.
get
(
slug
)
.
add
(
name
)
;
}
}
}
_removePrefObserver
(
name
slug
)
{
const
entry
=
this
.
_prefs
.
get
(
name
)
;
if
(
entry
)
{
entry
.
slugs
.
delete
(
slug
)
;
if
(
entry
.
slugs
.
size
=
=
0
)
{
Services
.
prefs
.
removeObserver
(
name
entry
.
observer
)
;
this
.
_prefs
.
delete
(
name
)
;
}
}
const
bySlug
=
this
.
_prefsBySlug
.
get
(
slug
)
;
if
(
bySlug
)
{
bySlug
.
delete
(
name
)
;
if
(
bySlug
.
size
=
=
0
)
{
this
.
_prefsBySlug
.
delete
(
slug
)
;
}
}
}
_onExperimentPrefChanged
(
pref
)
{
const
entry
=
this
.
_prefs
.
get
(
pref
.
name
)
;
if
(
entry
.
enrollmentChanging
)
{
return
;
}
const
slugs
=
Array
.
from
(
entry
.
slugs
)
;
for
(
const
slug
of
slugs
)
{
const
toRemove
=
Array
.
from
(
this
.
_prefsBySlug
.
get
(
slug
)
?
?
[
]
)
;
for
(
const
name
of
toRemove
)
{
this
.
_removePrefObserver
(
name
slug
)
;
}
}
const
enrollments
=
Array
.
from
(
slugs
)
.
map
(
slug
=
>
this
.
store
.
get
(
slug
)
)
;
if
(
enrollments
.
length
=
=
2
)
{
if
(
!
enrollments
[
0
]
.
isRollout
)
{
enrollments
.
reverse
(
)
;
}
}
let
branch
;
if
(
Services
.
prefs
.
prefHasUserValue
(
pref
.
name
)
)
{
branch
=
"
user
"
;
}
else
if
(
!
Services
.
prefs
.
prefHasDefaultValue
(
pref
.
name
)
)
{
branch
=
"
user
"
;
}
else
if
(
pref
.
branch
=
=
=
"
default
"
)
{
const
feature
=
getFeatureFromBranch
(
enrollments
.
at
(
-
1
)
.
branch
pref
.
featureId
)
;
const
expectedValue
=
feature
.
value
[
pref
.
variable
]
;
const
value
=
lazy
.
PrefUtils
.
getPref
(
pref
.
name
{
branch
:
pref
.
branch
}
)
;
if
(
value
=
=
=
expectedValue
)
{
branch
=
"
user
"
;
}
else
{
branch
=
"
default
"
;
}
}
else
{
branch
=
"
user
"
;
}
const
changedPref
=
{
name
:
pref
.
name
branch
}
;
for
(
const
enrollment
of
enrollments
)
{
this
.
_unenroll
(
enrollment
{
reason
:
"
changed
-
pref
"
changedPref
}
)
;
}
}
}
const
ExperimentManager
=
new
_ExperimentManager
(
)
;
