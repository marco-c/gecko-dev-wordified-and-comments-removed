"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
_RemoteSettingsExperimentLoader
"
"
RemoteSettingsExperimentLoader
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ASRouterTargeting
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ASRouterTargeting
.
jsm
"
TargetingContext
:
"
resource
:
/
/
messaging
-
system
/
targeting
/
Targeting
.
jsm
"
ExperimentManager
:
"
resource
:
/
/
nimbus
/
lib
/
ExperimentManager
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
CleanupManager
:
"
resource
:
/
/
normandy
/
lib
/
CleanupManager
.
jsm
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
Validator
:
"
resource
:
/
/
gre
/
modules
/
JsonSchema
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
const
{
Logger
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
messaging
-
system
/
lib
/
Logger
.
jsm
"
)
;
return
new
Logger
(
"
RSLoader
"
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
timerManager
"
"
mozilla
.
org
/
updates
/
timer
-
manager
;
1
"
"
nsIUpdateTimerManager
"
)
;
const
COLLECTION_ID_PREF
=
"
messaging
-
system
.
rsexperimentloader
.
collection_id
"
;
const
COLLECTION_ID_FALLBACK
=
"
nimbus
-
desktop
-
experiments
"
;
const
ENABLED_PREF
=
"
messaging
-
system
.
rsexperimentloader
.
enabled
"
;
const
STUDIES_OPT_OUT_PREF
=
"
app
.
shield
.
optoutstudies
.
enabled
"
;
const
TIMER_NAME
=
"
rs
-
experiment
-
loader
-
timer
"
;
const
TIMER_LAST_UPDATE_PREF
=
app
.
update
.
lastUpdateTime
.
{
TIMER_NAME
}
;
const
RUN_INTERVAL_PREF
=
"
app
.
normandy
.
run_interval_seconds
"
;
const
NIMBUS_DEBUG_PREF
=
"
nimbus
.
debug
"
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
COLLECTION_ID
"
COLLECTION_ID_PREF
COLLECTION_ID_FALLBACK
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
NIMBUS_DEBUG
"
NIMBUS_DEBUG_PREF
false
)
;
const
SCHEMAS
=
{
get
NimbusExperiment
(
)
{
return
fetch
(
"
resource
:
/
/
nimbus
/
schemas
/
NimbusExperiment
.
schema
.
json
"
{
credentials
:
"
omit
"
}
)
.
then
(
rsp
=
>
rsp
.
json
(
)
)
.
then
(
json
=
>
json
.
definitions
.
NimbusExperiment
)
;
}
}
;
class
_RemoteSettingsExperimentLoader
{
constructor
(
)
{
this
.
_initialized
=
false
;
this
.
_updating
=
false
;
this
.
manager
=
ExperimentManager
;
XPCOMUtils
.
defineLazyGetter
(
this
"
remoteSettingsClient
"
(
)
=
>
{
return
RemoteSettings
(
COLLECTION_ID
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
enabled
"
ENABLED_PREF
false
this
.
onEnabledPrefChange
.
bind
(
this
)
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
studiesEnabled
"
STUDIES_OPT_OUT_PREF
false
this
.
onEnabledPrefChange
.
bind
(
this
)
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
intervalInSeconds
"
RUN_INTERVAL_PREF
21600
(
)
=
>
this
.
setTimer
(
)
)
;
}
async
init
(
)
{
if
(
this
.
_initialized
|
|
!
this
.
enabled
|
|
!
this
.
studiesEnabled
)
{
return
;
}
this
.
setTimer
(
)
;
CleanupManager
.
addCleanupHandler
(
(
)
=
>
this
.
uninit
(
)
)
;
this
.
_initialized
=
true
;
await
this
.
updateRecipes
(
)
;
}
uninit
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
timerManager
.
unregisterTimer
(
TIMER_NAME
)
;
this
.
_initialized
=
false
;
this
.
_updating
=
false
;
}
async
evaluateJexl
(
jexlString
customContext
)
{
if
(
customContext
&
&
!
customContext
.
experiment
)
{
throw
new
Error
(
"
Expected
an
.
experiment
property
in
second
param
of
this
function
"
)
;
}
if
(
!
customContext
.
source
)
{
throw
new
Error
(
"
Expected
a
.
source
property
that
identifies
which
targeting
expression
is
being
evaluated
.
"
)
;
}
const
context
=
TargetingContext
.
combineContexts
(
customContext
this
.
manager
.
createTargetingContext
(
)
ASRouterTargeting
.
Environment
)
;
log
.
debug
(
"
Testing
targeting
expression
:
"
jexlString
)
;
const
targetingContext
=
new
TargetingContext
(
context
{
source
:
customContext
.
source
}
)
;
let
result
=
null
;
try
{
result
=
await
targetingContext
.
evalWithDefault
(
jexlString
)
;
}
catch
(
e
)
{
log
.
debug
(
"
Targeting
failed
because
of
an
error
"
)
;
Cu
.
reportError
(
e
)
;
}
return
result
;
}
async
checkTargeting
(
recipe
)
{
if
(
!
recipe
.
targeting
)
{
log
.
debug
(
"
No
targeting
for
recipe
so
it
matches
automatically
"
)
;
return
true
;
}
const
result
=
await
this
.
evaluateJexl
(
recipe
.
targeting
{
experiment
:
recipe
source
:
recipe
.
slug
}
)
;
return
Boolean
(
result
)
;
}
async
updateRecipes
(
trigger
)
{
if
(
this
.
_updating
|
|
!
this
.
_initialized
)
{
return
;
}
this
.
_updating
=
true
;
log
.
debug
(
"
Updating
recipes
"
+
(
trigger
?
with
trigger
{
trigger
}
:
"
"
)
)
;
let
recipes
;
let
loadingError
=
false
;
try
{
recipes
=
await
this
.
remoteSettingsClient
.
get
(
)
;
log
.
debug
(
Got
{
recipes
.
length
}
recipes
from
Remote
Settings
)
;
}
catch
(
e
)
{
log
.
debug
(
"
Error
getting
recipes
from
remote
settings
.
"
)
;
loadingError
=
true
;
Cu
.
reportError
(
e
)
;
}
const
recipeValidator
=
new
Validator
(
await
SCHEMAS
.
NimbusExperiment
)
;
let
matches
=
0
;
let
recipeMismatches
=
[
]
;
let
validatorCache
=
{
}
;
if
(
recipes
&
&
!
loadingError
)
{
for
(
const
r
of
recipes
)
{
let
validation
=
recipeValidator
.
validate
(
r
)
;
if
(
!
validation
.
valid
)
{
Cu
.
reportError
(
Could
not
validate
experiment
recipe
{
r
.
id
}
:
{
JSON
.
stringify
(
validation
.
errors
undefined
2
)
}
)
;
continue
;
}
let
type
=
r
.
isRollout
?
"
rollout
"
:
"
experiment
"
;
if
(
!
(
await
this
.
_validateBranches
(
r
validatorCache
)
)
)
{
log
.
debug
(
{
r
.
id
}
did
not
validate
)
;
continue
;
}
if
(
await
this
.
checkTargeting
(
r
)
)
{
matches
+
+
;
log
.
debug
(
[
{
type
}
]
{
r
.
id
}
matched
)
;
await
this
.
manager
.
onRecipe
(
r
"
rs
-
loader
"
)
;
}
else
{
log
.
debug
(
{
r
.
id
}
did
not
match
due
to
targeting
)
;
recipeMismatches
.
push
(
r
.
slug
)
;
}
}
log
.
debug
(
{
matches
}
recipes
matched
.
Finalizing
ExperimentManager
.
)
;
this
.
manager
.
onFinalize
(
"
rs
-
loader
"
{
recipeMismatches
}
)
;
}
if
(
trigger
!
=
=
"
timer
"
)
{
const
lastUpdateTime
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
Services
.
prefs
.
setIntPref
(
TIMER_LAST_UPDATE_PREF
lastUpdateTime
)
;
}
this
.
_updating
=
false
;
}
async
optInToExperiment
(
{
slug
branch
:
branchSlug
collection
}
)
{
log
.
debug
(
Attempting
force
enrollment
with
{
slug
}
/
{
branchSlug
}
)
;
if
(
!
NIMBUS_DEBUG
)
{
log
.
debug
(
Force
enrollment
only
works
when
'
{
NIMBUS_DEBUG_PREF
}
'
is
enabled
.
)
;
throw
new
Error
(
"
Could
not
opt
in
.
"
)
;
}
let
recipes
;
try
{
recipes
=
await
RemoteSettings
(
collection
|
|
COLLECTION_ID
)
.
get
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
throw
new
Error
(
"
Error
getting
recipes
from
remote
settings
.
"
)
;
}
let
recipe
=
recipes
.
find
(
r
=
>
r
.
slug
=
=
=
slug
)
;
if
(
!
recipe
)
{
throw
new
Error
(
Could
not
find
experiment
slug
{
slug
}
in
collection
{
collection
|
|
COLLECTION_ID
}
.
)
;
}
let
branch
=
recipe
.
branches
.
find
(
b
=
>
b
.
slug
=
=
=
branchSlug
)
;
if
(
!
branch
)
{
throw
new
Error
(
Could
not
find
branch
slug
{
branchSlug
}
in
{
slug
}
.
)
;
}
return
ExperimentManager
.
forceEnroll
(
recipe
branch
)
;
}
onEnabledPrefChange
(
prefName
oldValue
newValue
)
{
if
(
this
.
_initialized
&
&
!
newValue
)
{
this
.
uninit
(
)
;
}
else
if
(
!
this
.
_initialized
&
&
newValue
&
&
this
.
enabled
)
{
this
.
init
(
)
;
}
}
setTimer
(
)
{
if
(
this
.
intervalInSeconds
=
=
=
0
)
{
return
;
}
timerManager
.
registerTimer
(
TIMER_NAME
(
)
=
>
this
.
updateRecipes
(
"
timer
"
)
this
.
intervalInSeconds
)
;
log
.
debug
(
"
Registered
update
timer
"
)
;
}
async
_validateBranches
(
{
id
branches
}
validatorCache
=
{
}
)
{
for
(
const
[
branchIdx
branch
]
of
branches
.
entries
(
)
)
{
const
features
=
branch
.
features
?
?
[
branch
.
feature
]
;
for
(
const
feature
of
features
)
{
const
{
featureId
value
}
=
feature
;
if
(
!
NimbusFeatures
[
featureId
]
)
{
Cu
.
reportError
(
Experiment
{
id
}
has
unknown
featureId
:
{
featureId
}
)
;
return
false
;
}
let
validator
;
if
(
validatorCache
[
featureId
]
)
{
validator
=
validatorCache
[
featureId
]
;
}
else
if
(
NimbusFeatures
[
featureId
]
.
manifest
.
schema
)
{
const
schema
=
await
fetch
(
NimbusFeatures
[
featureId
]
.
manifest
.
schema
{
credentials
:
"
omit
"
}
)
.
then
(
rsp
=
>
rsp
.
json
(
)
)
;
validator
=
validatorCache
[
featureId
]
=
new
Validator
(
schema
)
;
}
else
{
continue
;
}
if
(
feature
.
enabled
?
?
true
)
{
const
result
=
validator
.
validate
(
value
)
;
if
(
!
result
.
valid
)
{
Cu
.
reportError
(
Experiment
{
id
}
branch
{
branchIdx
}
feature
{
featureId
}
does
not
validate
:
{
JSON
.
stringify
(
result
.
errors
undefined
2
)
}
)
;
return
false
;
}
}
else
{
log
.
debug
(
Experiment
{
id
}
branch
{
branchIdx
}
feature
{
featureId
}
disabled
;
skipping
validation
)
;
}
}
}
return
true
;
}
}
const
RemoteSettingsExperimentLoader
=
new
_RemoteSettingsExperimentLoader
(
)
;
