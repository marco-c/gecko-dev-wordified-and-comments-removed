"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ExperimentAPI
"
"
ExperimentFeature
"
"
NimbusFeatures
"
]
;
function
isBooleanValueDefined
(
value
)
{
return
typeof
value
=
=
=
"
boolean
"
;
}
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ExperimentStore
:
"
resource
:
/
/
nimbus
/
lib
/
ExperimentStore
.
jsm
"
ExperimentManager
:
"
resource
:
/
/
nimbus
/
lib
/
ExperimentManager
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
FeatureManifest
:
"
resource
:
/
/
nimbus
/
FeatureManifest
.
js
"
}
)
;
const
IS_MAIN_PROCESS
=
Services
.
appinfo
.
processType
=
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
;
const
COLLECTION_ID_PREF
=
"
messaging
-
system
.
rsexperimentloader
.
collection_id
"
;
const
COLLECTION_ID_FALLBACK
=
"
nimbus
-
desktop
-
experiments
"
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
COLLECTION_ID
"
COLLECTION_ID_PREF
COLLECTION_ID_FALLBACK
)
;
const
EXPOSURE_EVENT_CATEGORY
=
"
normandy
"
;
const
EXPOSURE_EVENT_METHOD
=
"
expose
"
;
const
EXPOSURE_EVENT_OBJECT
=
"
nimbus_experiment
"
;
function
parseJSON
(
value
)
{
if
(
value
)
{
try
{
return
JSON
.
parse
(
value
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
return
null
;
}
const
ExperimentAPI
=
{
ready
(
)
{
return
this
.
_store
.
ready
(
)
;
}
getExperiment
(
{
slug
featureId
sendExposureEvent
}
=
{
}
)
{
if
(
!
slug
&
&
!
featureId
)
{
throw
new
Error
(
"
getExperiment
(
options
)
must
include
a
slug
or
a
feature
.
"
)
;
}
let
experimentData
;
try
{
if
(
slug
)
{
experimentData
=
this
.
_store
.
get
(
slug
)
;
}
else
if
(
featureId
)
{
experimentData
=
this
.
_store
.
getExperimentForFeature
(
featureId
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
experimentData
)
{
return
{
slug
:
experimentData
.
slug
active
:
experimentData
.
active
branch
:
this
.
activateBranch
(
{
slug
featureId
sendExposureEvent
}
)
}
;
}
return
null
;
}
getExperimentMetaData
(
{
slug
featureId
}
)
{
if
(
!
slug
&
&
!
featureId
)
{
throw
new
Error
(
"
getExperiment
(
options
)
must
include
a
slug
or
a
feature
.
"
)
;
}
let
experimentData
;
try
{
if
(
slug
)
{
experimentData
=
this
.
_store
.
get
(
slug
)
;
}
else
if
(
featureId
)
{
experimentData
=
this
.
_store
.
getExperimentForFeature
(
featureId
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
experimentData
)
{
return
{
slug
:
experimentData
.
slug
active
:
experimentData
.
active
branch
:
{
slug
:
experimentData
.
branch
.
slug
}
}
;
}
return
null
;
}
activateBranch
(
{
slug
featureId
sendExposureEvent
}
)
{
let
experiment
=
null
;
try
{
if
(
slug
)
{
experiment
=
this
.
_store
.
get
(
slug
)
;
}
else
if
(
featureId
)
{
experiment
=
this
.
_store
.
getExperimentForFeature
(
featureId
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
!
experiment
)
{
return
null
;
}
if
(
sendExposureEvent
)
{
this
.
recordExposureEvent
(
{
experimentSlug
:
experiment
.
slug
branchSlug
:
experiment
.
branch
.
slug
featureId
}
)
;
}
return
experiment
?
.
branch
|
|
null
;
}
on
(
eventName
options
callback
)
{
if
(
!
options
)
{
throw
new
Error
(
"
Please
include
an
experiment
slug
or
featureId
"
)
;
}
let
fullEventName
=
{
eventName
}
:
{
options
.
slug
|
|
options
.
featureId
}
;
this
.
_store
.
ready
(
)
.
then
(
(
)
=
>
{
let
experiment
=
this
.
getExperiment
(
options
)
;
if
(
experiment
)
{
callback
(
fullEventName
experiment
)
;
}
}
)
;
this
.
_store
.
on
(
fullEventName
callback
)
;
}
off
(
eventName
callback
)
{
this
.
_store
.
off
(
eventName
callback
)
;
}
async
getRecipe
(
slug
)
{
if
(
!
IS_MAIN_PROCESS
)
{
throw
new
Error
(
"
getRecipe
(
)
should
only
be
called
from
the
main
process
"
)
;
}
let
recipe
;
try
{
[
recipe
]
=
await
this
.
_remoteSettingsClient
.
get
(
{
syncIfEmpty
:
false
filters
:
{
slug
}
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
recipe
=
undefined
;
}
return
recipe
;
}
async
getAllBranches
(
slug
)
{
if
(
!
IS_MAIN_PROCESS
)
{
throw
new
Error
(
"
getAllBranches
(
)
should
only
be
called
from
the
main
process
"
)
;
}
const
recipe
=
await
this
.
getRecipe
(
slug
)
;
return
recipe
?
.
branches
;
}
recordExposureEvent
(
{
featureId
experimentSlug
branchSlug
}
)
{
Services
.
telemetry
.
setEventRecordingEnabled
(
EXPOSURE_EVENT_CATEGORY
true
)
;
try
{
Services
.
telemetry
.
recordEvent
(
EXPOSURE_EVENT_CATEGORY
EXPOSURE_EVENT_METHOD
EXPOSURE_EVENT_OBJECT
experimentSlug
{
branchSlug
featureId
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
;
const
NimbusFeatures
=
{
}
;
for
(
let
feature
in
FeatureManifest
)
{
XPCOMUtils
.
defineLazyGetter
(
NimbusFeatures
feature
(
)
=
>
feature
=
=
=
"
upgradeDialog
"
?
NimbusFeatures
.
aboutwelcome
:
new
ExperimentFeature
(
feature
)
)
;
}
class
ExperimentFeature
{
constructor
(
featureId
manifest
)
{
this
.
featureId
=
featureId
;
this
.
prefGetters
=
{
}
;
this
.
manifest
=
manifest
|
|
FeatureManifest
[
featureId
]
;
if
(
!
this
.
manifest
)
{
Cu
.
reportError
(
No
manifest
entry
for
{
featureId
}
.
Please
add
one
to
toolkit
/
components
/
nimbus
/
FeatureManifest
.
js
)
;
}
this
.
_sendExposureEventOnce
=
true
;
this
.
_onRemoteReady
=
null
;
this
.
_waitForRemote
=
new
Promise
(
resolve
=
>
(
this
.
_onRemoteReady
=
resolve
)
)
;
this
.
_listenForRemoteDefaults
=
this
.
_listenForRemoteDefaults
.
bind
(
this
)
;
const
variables
=
this
.
manifest
?
.
variables
|
|
{
}
;
if
(
this
.
manifest
?
.
enabledFallbackPref
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
enabled
"
this
.
manifest
?
.
enabledFallbackPref
null
(
)
=
>
{
ExperimentAPI
.
_store
.
_emitFeatureUpdate
(
this
.
featureId
"
pref
-
updated
"
)
;
}
)
;
}
Object
.
keys
(
variables
)
.
forEach
(
key
=
>
{
const
{
type
fallbackPref
}
=
variables
[
key
]
;
if
(
fallbackPref
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
.
prefGetters
key
fallbackPref
null
(
)
=
>
{
ExperimentAPI
.
_store
.
_emitFeatureUpdate
(
this
.
featureId
"
pref
-
updated
"
)
;
}
type
=
=
=
"
json
"
?
parseJSON
:
val
=
>
val
)
;
}
}
)
;
ExperimentAPI
.
_store
.
on
(
"
remote
-
defaults
-
finalized
"
this
.
_listenForRemoteDefaults
)
;
this
.
onUpdate
(
this
.
_listenForRemoteDefaults
)
;
}
_listenForRemoteDefaults
(
eventName
reason
)
{
if
(
eventName
=
=
=
"
remote
-
defaults
-
finalized
"
|
|
reason
=
=
=
"
experiment
-
updated
"
|
|
reason
=
=
=
"
remote
-
defaults
-
update
"
)
{
ExperimentAPI
.
_store
.
off
(
"
remote
-
defaults
-
updated
"
this
.
_listenForRemoteDefaults
)
;
this
.
off
(
this
.
_listenForRemoteDefaults
)
;
this
.
_onRemoteReady
(
)
;
}
}
_getUserPrefsValues
(
)
{
let
userPrefs
=
{
}
;
Object
.
keys
(
this
.
manifest
?
.
variables
|
|
{
}
)
.
forEach
(
variable
=
>
{
if
(
this
.
manifest
.
variables
[
variable
]
.
fallbackPref
&
&
Services
.
prefs
.
prefHasUserValue
(
this
.
manifest
.
variables
[
variable
]
.
fallbackPref
)
)
{
userPrefs
[
variable
]
=
this
.
prefGetters
[
variable
]
;
}
}
)
;
return
userPrefs
;
}
async
ready
(
timeout
)
{
const
REMOTE_DEFAULTS_TIMEOUT_MS
=
15
*
1000
;
await
ExperimentAPI
.
ready
(
)
;
let
remoteTimeoutId
=
setTimeout
(
this
.
_onRemoteReady
timeout
|
|
REMOTE_DEFAULTS_TIMEOUT_MS
)
;
await
this
.
_waitForRemote
;
clearTimeout
(
remoteTimeoutId
)
;
}
isEnabled
(
{
sendExposureEvent
defaultValue
=
null
}
=
{
}
)
{
const
branch
=
ExperimentAPI
.
activateBranch
(
{
featureId
:
this
.
featureId
sendExposureEvent
:
sendExposureEvent
&
&
this
.
_sendExposureEventOnce
}
)
;
if
(
branch
&
&
sendExposureEvent
)
{
this
.
_sendExposureEventOnce
=
false
;
}
if
(
isBooleanValueDefined
(
branch
?
.
feature
.
enabled
)
)
{
return
branch
.
feature
.
enabled
;
}
if
(
isBooleanValueDefined
(
this
.
getRemoteConfig
(
)
?
.
enabled
)
)
{
return
this
.
getRemoteConfig
(
)
.
enabled
;
}
if
(
isBooleanValueDefined
(
this
.
enabled
)
)
{
return
this
.
enabled
;
}
return
defaultValue
;
}
getValue
(
{
sendExposureEvent
}
=
{
}
)
{
let
userPrefs
=
this
.
_getUserPrefsValues
(
)
;
const
branch
=
ExperimentAPI
.
activateBranch
(
{
featureId
:
this
.
featureId
sendExposureEvent
:
sendExposureEvent
&
&
this
.
_sendExposureEventOnce
}
)
;
if
(
branch
&
&
sendExposureEvent
)
{
this
.
_sendExposureEventOnce
=
false
;
}
if
(
branch
?
.
feature
?
.
value
)
{
return
{
.
.
.
branch
.
feature
.
value
.
.
.
userPrefs
}
;
}
return
{
.
.
.
this
.
prefGetters
.
.
.
this
.
getRemoteConfig
(
)
?
.
variables
.
.
.
userPrefs
}
;
}
getRemoteConfig
(
)
{
let
remoteConfig
=
ExperimentAPI
.
_store
.
getRemoteConfig
(
this
.
featureId
)
;
if
(
!
remoteConfig
)
{
return
null
;
}
return
remoteConfig
;
}
recordExposureEvent
(
)
{
if
(
this
.
_sendExposureEventOnce
)
{
let
experimentData
=
ExperimentAPI
.
activateBranch
(
{
featureId
:
this
.
featureId
sendExposureEvent
:
true
}
)
;
if
(
experimentData
)
{
this
.
_sendExposureEventOnce
=
false
;
}
}
}
onUpdate
(
callback
)
{
ExperimentAPI
.
_store
.
_onFeatureUpdate
(
this
.
featureId
callback
)
;
}
off
(
callback
)
{
ExperimentAPI
.
_store
.
_offFeatureUpdate
(
this
.
featureId
callback
)
;
}
debug
(
)
{
return
{
enabled
:
this
.
isEnabled
(
)
value
:
this
.
getValue
(
)
experiment
:
ExperimentAPI
.
getExperimentMetaData
(
{
featureId
:
this
.
featureId
}
)
fallbackPrefs
:
this
.
prefGetters
&
&
Object
.
keys
(
this
.
prefGetters
)
.
map
(
prefName
=
>
[
prefName
this
.
prefGetters
[
prefName
]
]
)
userPrefs
:
this
.
_getUserPrefsValues
(
)
remoteDefaults
:
this
.
getRemoteConfig
(
)
}
;
}
}
XPCOMUtils
.
defineLazyGetter
(
ExperimentAPI
"
_store
"
function
(
)
{
return
IS_MAIN_PROCESS
?
ExperimentManager
.
store
:
new
ExperimentStore
(
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
ExperimentAPI
"
_remoteSettingsClient
"
function
(
)
{
return
RemoteSettings
(
COLLECTION_ID
)
;
}
)
;
