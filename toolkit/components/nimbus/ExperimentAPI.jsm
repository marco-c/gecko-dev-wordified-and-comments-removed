"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ExperimentAPI
"
"
NimbusFeatures
"
"
_ExperimentFeature
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
ExperimentStore
:
"
resource
:
/
/
nimbus
/
lib
/
ExperimentStore
.
jsm
"
ExperimentManager
:
"
resource
:
/
/
nimbus
/
lib
/
ExperimentManager
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
FeatureManifest
:
"
resource
:
/
/
nimbus
/
FeatureManifest
.
js
"
}
)
;
const
IS_MAIN_PROCESS
=
Services
.
appinfo
.
processType
=
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
;
const
COLLECTION_ID_PREF
=
"
messaging
-
system
.
rsexperimentloader
.
collection_id
"
;
const
COLLECTION_ID_FALLBACK
=
"
nimbus
-
desktop
-
experiments
"
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
COLLECTION_ID
"
COLLECTION_ID_PREF
COLLECTION_ID_FALLBACK
)
;
const
EXPOSURE_EVENT_CATEGORY
=
"
normandy
"
;
const
EXPOSURE_EVENT_METHOD
=
"
expose
"
;
const
EXPOSURE_EVENT_OBJECT
=
"
nimbus_experiment
"
;
function
parseJSON
(
value
)
{
if
(
value
)
{
try
{
return
JSON
.
parse
(
value
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
return
null
;
}
function
featuresCompat
(
branch
)
{
if
(
!
branch
)
{
return
[
]
;
}
let
{
features
}
=
branch
;
if
(
!
features
)
{
features
=
[
branch
.
feature
]
;
}
return
features
;
}
const
experimentBranchAccessor
=
{
get
:
(
target
prop
)
=
>
{
if
(
!
(
prop
in
target
)
&
&
target
.
features
)
{
return
target
.
features
.
find
(
f
=
>
f
.
featureId
=
=
=
prop
)
;
}
else
if
(
target
.
feature
?
.
featureId
=
=
=
prop
)
{
return
target
.
feature
;
}
return
target
[
prop
]
;
}
}
;
const
ExperimentAPI
=
{
ready
(
)
{
return
this
.
_store
.
ready
(
)
;
}
getExperiment
(
{
slug
featureId
}
=
{
}
)
{
if
(
!
slug
&
&
!
featureId
)
{
throw
new
Error
(
"
getExperiment
(
options
)
must
include
a
slug
or
a
feature
.
"
)
;
}
let
experimentData
;
try
{
if
(
slug
)
{
experimentData
=
this
.
_store
.
get
(
slug
)
;
}
else
if
(
featureId
)
{
experimentData
=
this
.
_store
.
getExperimentForFeature
(
featureId
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
experimentData
)
{
return
{
slug
:
experimentData
.
slug
active
:
experimentData
.
active
branch
:
new
Proxy
(
experimentData
.
branch
experimentBranchAccessor
)
}
;
}
return
null
;
}
getEnrollmentMetaData
(
{
slug
featureId
}
isRollout
)
{
if
(
!
slug
&
&
!
featureId
)
{
throw
new
Error
(
"
getExperiment
(
options
)
must
include
a
slug
or
a
feature
.
"
)
;
}
let
experimentData
;
try
{
if
(
slug
)
{
experimentData
=
this
.
_store
.
get
(
slug
)
;
}
else
if
(
featureId
)
{
if
(
isRollout
)
{
experimentData
=
this
.
_store
.
getRolloutForFeature
(
featureId
)
;
}
else
{
experimentData
=
this
.
_store
.
getExperimentForFeature
(
featureId
)
;
}
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
experimentData
)
{
return
{
slug
:
experimentData
.
slug
active
:
experimentData
.
active
branch
:
{
slug
:
experimentData
.
branch
.
slug
}
}
;
}
return
null
;
}
getExperimentMetaData
(
options
)
{
return
this
.
getEnrollmentMetaData
(
options
)
;
}
getRolloutMetaData
(
options
)
{
return
this
.
getEnrollmentMetaData
(
options
true
)
;
}
getActiveBranch
(
{
slug
featureId
}
)
{
let
experiment
=
null
;
try
{
if
(
slug
)
{
experiment
=
this
.
_store
.
get
(
slug
)
;
}
else
if
(
featureId
)
{
experiment
=
this
.
_store
.
getExperimentForFeature
(
featureId
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
!
experiment
)
{
return
null
;
}
return
experiment
?
.
branch
|
|
null
;
}
on
(
eventName
options
callback
)
{
if
(
!
options
)
{
throw
new
Error
(
"
Please
include
an
experiment
slug
or
featureId
"
)
;
}
let
fullEventName
=
{
eventName
}
:
{
options
.
slug
|
|
options
.
featureId
}
;
if
(
this
.
_store
.
_isReady
)
{
let
experiment
=
this
.
getExperiment
(
options
)
;
if
(
experiment
)
{
callback
(
fullEventName
experiment
)
;
}
}
this
.
_store
.
on
(
fullEventName
callback
)
;
}
off
(
eventName
callback
)
{
this
.
_store
.
off
(
eventName
callback
)
;
}
async
getRecipe
(
slug
)
{
if
(
!
IS_MAIN_PROCESS
)
{
throw
new
Error
(
"
getRecipe
(
)
should
only
be
called
from
the
main
process
"
)
;
}
let
recipe
;
try
{
[
recipe
]
=
await
this
.
_remoteSettingsClient
.
get
(
{
syncIfEmpty
:
false
filters
:
{
slug
}
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
recipe
=
undefined
;
}
return
recipe
;
}
async
getAllBranches
(
slug
)
{
if
(
!
IS_MAIN_PROCESS
)
{
throw
new
Error
(
"
getAllBranches
(
)
should
only
be
called
from
the
main
process
"
)
;
}
const
recipe
=
await
this
.
getRecipe
(
slug
)
;
return
recipe
?
.
branches
.
map
(
branch
=
>
new
Proxy
(
branch
experimentBranchAccessor
)
)
;
}
recordExposureEvent
(
{
featureId
experimentSlug
branchSlug
}
)
{
Services
.
telemetry
.
setEventRecordingEnabled
(
EXPOSURE_EVENT_CATEGORY
true
)
;
try
{
Services
.
telemetry
.
recordEvent
(
EXPOSURE_EVENT_CATEGORY
EXPOSURE_EVENT_METHOD
EXPOSURE_EVENT_OBJECT
experimentSlug
{
branchSlug
featureId
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
Glean
.
nimbusEvents
.
exposure
.
record
(
{
experiment
:
experimentSlug
branch
:
branchSlug
feature_id
:
featureId
}
)
;
}
}
;
const
NimbusFeatures
=
{
}
;
for
(
let
feature
in
lazy
.
FeatureManifest
)
{
XPCOMUtils
.
defineLazyGetter
(
NimbusFeatures
feature
(
)
=
>
{
return
new
_ExperimentFeature
(
feature
)
;
}
)
;
}
class
_ExperimentFeature
{
constructor
(
featureId
manifest
)
{
this
.
featureId
=
featureId
;
this
.
prefGetters
=
{
}
;
this
.
manifest
=
manifest
|
|
lazy
.
FeatureManifest
[
featureId
]
;
if
(
!
this
.
manifest
)
{
Cu
.
reportError
(
No
manifest
entry
for
{
featureId
}
.
Please
add
one
to
toolkit
/
components
/
nimbus
/
FeatureManifest
.
js
)
;
}
this
.
_didSendExposureEvent
=
false
;
const
variables
=
this
.
manifest
?
.
variables
|
|
{
}
;
Object
.
keys
(
variables
)
.
forEach
(
key
=
>
{
const
{
type
fallbackPref
}
=
variables
[
key
]
;
if
(
fallbackPref
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
.
prefGetters
key
fallbackPref
null
(
)
=
>
{
ExperimentAPI
.
_store
.
_emitFeatureUpdate
(
this
.
featureId
"
pref
-
updated
"
)
;
}
type
=
=
=
"
json
"
?
parseJSON
:
val
=
>
val
)
;
}
}
)
;
}
getPreferenceName
(
variable
)
{
return
this
.
manifest
?
.
variables
?
.
[
variable
]
?
.
fallbackPref
;
}
_getUserPrefsValues
(
)
{
let
userPrefs
=
{
}
;
Object
.
keys
(
this
.
manifest
?
.
variables
|
|
{
}
)
.
forEach
(
variable
=
>
{
if
(
this
.
manifest
.
variables
[
variable
]
.
fallbackPref
&
&
Services
.
prefs
.
prefHasUserValue
(
this
.
manifest
.
variables
[
variable
]
.
fallbackPref
)
)
{
userPrefs
[
variable
]
=
this
.
prefGetters
[
variable
]
;
}
}
)
;
return
userPrefs
;
}
ready
(
)
{
return
ExperimentAPI
.
ready
(
)
;
}
getAllVariables
(
{
defaultValues
=
null
}
=
{
}
)
{
let
userPrefs
=
this
.
_getUserPrefsValues
(
)
;
const
branch
=
ExperimentAPI
.
getActiveBranch
(
{
featureId
:
this
.
featureId
}
)
;
const
featureValue
=
featuresCompat
(
branch
)
.
find
(
(
{
featureId
}
)
=
>
featureId
=
=
=
this
.
featureId
)
?
.
value
;
return
{
.
.
.
this
.
prefGetters
.
.
.
defaultValues
.
.
.
(
featureValue
?
featureValue
:
this
.
getRollout
(
)
?
.
value
)
.
.
.
userPrefs
}
;
}
getVariable
(
variable
)
{
const
prefName
=
this
.
getPreferenceName
(
variable
)
;
const
prefValue
=
prefName
?
this
.
prefGetters
[
variable
]
:
undefined
;
if
(
!
this
.
manifest
?
.
variables
?
.
[
variable
]
)
{
if
(
Cu
.
isInAutomation
|
|
AppConstants
.
NIGHTLY_BUILD
)
{
throw
new
Error
(
Nimbus
:
Warning
-
variable
"
{
variable
}
"
is
not
defined
in
FeatureManifest
.
js
)
;
}
}
if
(
prefName
&
&
Services
.
prefs
.
prefHasUserValue
(
prefName
)
)
{
return
prefValue
;
}
const
branch
=
ExperimentAPI
.
getActiveBranch
(
{
featureId
:
this
.
featureId
}
)
;
const
experimentValue
=
featuresCompat
(
branch
)
.
find
(
(
{
featureId
}
)
=
>
featureId
=
=
=
this
.
featureId
)
?
.
value
?
.
[
variable
]
;
if
(
typeof
experimentValue
!
=
=
"
undefined
"
)
{
return
experimentValue
;
}
const
remoteValue
=
this
.
getRollout
(
)
?
.
value
?
.
[
variable
]
;
if
(
typeof
remoteValue
!
=
=
"
undefined
"
)
{
return
remoteValue
;
}
return
prefValue
;
}
getRollout
(
)
{
let
remoteConfig
=
ExperimentAPI
.
_store
.
getRolloutForFeature
(
this
.
featureId
)
;
if
(
!
remoteConfig
)
{
return
null
;
}
if
(
remoteConfig
.
branch
?
.
features
)
{
return
remoteConfig
.
branch
?
.
features
.
find
(
f
=
>
f
.
featureId
=
=
=
this
.
featureId
)
;
}
if
(
remoteConfig
.
branch
?
.
feature
)
{
return
remoteConfig
.
branch
.
feature
;
}
return
null
;
}
recordExposureEvent
(
{
once
=
false
}
=
{
}
)
{
if
(
once
&
&
this
.
_didSendExposureEvent
)
{
return
;
}
let
enrollmentData
=
ExperimentAPI
.
getExperimentMetaData
(
{
featureId
:
this
.
featureId
}
)
;
if
(
!
enrollmentData
)
{
enrollmentData
=
ExperimentAPI
.
getRolloutMetaData
(
{
featureId
:
this
.
featureId
}
)
;
}
if
(
enrollmentData
)
{
ExperimentAPI
.
recordExposureEvent
(
{
featureId
:
this
.
featureId
experimentSlug
:
enrollmentData
.
slug
branchSlug
:
enrollmentData
.
branch
?
.
slug
}
)
;
this
.
_didSendExposureEvent
=
true
;
}
}
onUpdate
(
callback
)
{
ExperimentAPI
.
_store
.
_onFeatureUpdate
(
this
.
featureId
callback
)
;
}
off
(
callback
)
{
ExperimentAPI
.
_store
.
_offFeatureUpdate
(
this
.
featureId
callback
)
;
}
get
applications
(
)
{
return
this
.
manifest
.
applications
?
?
[
"
firefox
-
desktop
"
]
;
}
debug
(
)
{
return
{
variables
:
this
.
getAllVariables
(
)
experiment
:
ExperimentAPI
.
getExperimentMetaData
(
{
featureId
:
this
.
featureId
}
)
fallbackPrefs
:
this
.
prefGetters
&
&
Object
.
keys
(
this
.
prefGetters
)
.
map
(
prefName
=
>
[
prefName
this
.
prefGetters
[
prefName
]
]
)
userPrefs
:
this
.
_getUserPrefsValues
(
)
rollouts
:
this
.
getRollout
(
)
}
;
}
}
XPCOMUtils
.
defineLazyGetter
(
ExperimentAPI
"
_store
"
function
(
)
{
return
IS_MAIN_PROCESS
?
lazy
.
ExperimentManager
.
store
:
new
lazy
.
ExperimentStore
(
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
ExperimentAPI
"
_remoteSettingsClient
"
function
(
)
{
return
lazy
.
RemoteSettings
(
lazy
.
COLLECTION_ID
)
;
}
)
;
