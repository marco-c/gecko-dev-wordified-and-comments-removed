"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
ExperimentStore
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
nimbus
/
lib
/
ExperimentStore
.
jsm
"
)
;
const
{
FileTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
FileTestUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
_ExperimentManager
:
"
resource
:
/
/
nimbus
/
lib
/
ExperimentManager
.
jsm
"
ExperimentManager
:
"
resource
:
/
/
nimbus
/
lib
/
ExperimentManager
.
jsm
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
NormandyUtils
:
"
resource
:
/
/
normandy
/
lib
/
NormandyUtils
.
jsm
"
_RemoteSettingsExperimentLoader
:
"
resource
:
/
/
nimbus
/
lib
/
RemoteSettingsExperimentLoader
.
jsm
"
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
jsm
"
FeatureManifest
:
"
resource
:
/
/
nimbus
/
FeatureManifest
.
js
"
JsonSchema
:
"
resource
:
/
/
gre
/
modules
/
JsonSchema
.
jsm
"
}
)
;
const
{
SYNC_DATA_PREF_BRANCH
SYNC_DEFAULTS_PREF_BRANCH
}
=
ExperimentStore
;
const
PATH
=
FileTestUtils
.
getTempFile
(
"
shared
-
data
-
map
"
)
.
path
;
async
function
fetchSchema
(
url
)
{
const
response
=
await
fetch
(
url
)
;
const
schema
=
await
response
.
json
(
)
;
if
(
!
schema
)
{
throw
new
Error
(
Failed
to
load
{
url
}
)
;
}
return
schema
;
}
const
EXPORTED_SYMBOLS
=
[
"
ExperimentTestUtils
"
"
ExperimentFakes
"
]
;
const
ExperimentTestUtils
=
{
_validateSchema
(
schema
value
errorMsg
)
{
const
result
=
lazy
.
JsonSchema
.
validate
(
value
schema
{
shortCircuit
:
false
}
)
;
if
(
result
.
errors
.
length
)
{
throw
new
Error
(
{
errorMsg
}
:
{
JSON
.
stringify
(
result
.
errors
undefined
2
)
}
)
;
}
return
value
;
}
_validateFeatureValueEnum
(
{
branch
}
)
{
let
{
features
}
=
branch
;
for
(
let
feature
of
features
)
{
if
(
!
lazy
.
FeatureManifest
[
feature
.
featureId
]
)
{
return
true
;
}
let
{
variables
}
=
lazy
.
FeatureManifest
[
feature
.
featureId
]
;
for
(
let
varName
of
Object
.
keys
(
variables
)
)
{
let
varValue
=
feature
.
value
[
varName
]
;
if
(
varValue
&
&
variables
[
varName
]
.
enum
&
&
!
variables
[
varName
]
.
enum
.
includes
(
varValue
)
)
{
throw
new
Error
(
{
varName
}
should
have
one
of
the
following
values
:
{
JSON
.
stringify
(
variables
[
varName
]
.
enum
)
}
but
has
value
'
{
varValue
}
'
)
;
}
}
}
return
true
;
}
async
validateExperiment
(
experiment
)
{
const
schema
=
await
fetchSchema
(
"
resource
:
/
/
nimbus
/
schemas
/
NimbusExperiment
.
schema
.
json
"
)
;
const
{
branches
}
=
experiment
;
branches
.
forEach
(
branch
=
>
{
branch
.
features
.
map
(
(
{
featureId
}
)
=
>
{
if
(
!
experiment
.
featureIds
.
includes
(
featureId
)
)
{
throw
new
Error
(
Branch
(
{
branch
.
slug
}
)
contains
feature
(
{
featureId
}
)
but
that
'
s
not
declared
in
recipe
(
{
experiment
.
slug
}
)
.
featureIds
)
;
}
}
)
;
}
)
;
return
this
.
_validateSchema
(
schema
experiment
Experiment
{
experiment
.
slug
}
not
valid
)
;
}
async
validateEnrollment
(
enrollment
)
{
const
schema
=
await
fetchSchema
(
"
resource
:
/
/
nimbus
/
schemas
/
NimbusEnrollment
.
schema
.
json
"
)
;
if
(
!
enrollment
.
branch
.
features
&
&
enrollment
.
branch
.
feature
)
{
return
true
;
}
return
(
this
.
_validateFeatureValueEnum
(
enrollment
)
&
&
this
.
_validateSchema
(
schema
enrollment
Enrollment
{
enrollment
.
slug
}
is
not
valid
)
)
;
}
async
validateRollouts
(
rollout
)
{
const
schema
=
await
fetchSchema
(
"
resource
:
/
/
nimbus
/
schemas
/
NimbusEnrollment
.
schema
.
json
"
)
;
return
this
.
_validateSchema
(
schema
rollout
Rollout
configuration
{
rollout
.
slug
}
is
not
valid
)
;
}
addTestFeatures
(
.
.
.
features
)
{
for
(
const
feature
of
features
)
{
if
(
Object
.
hasOwn
(
lazy
.
NimbusFeatures
feature
.
featureId
)
)
{
throw
new
Error
(
Cannot
add
feature
{
feature
.
featureId
}
-
-
a
feature
with
this
ID
already
exists
!
)
;
}
lazy
.
NimbusFeatures
[
feature
.
featureId
]
=
feature
;
}
return
(
)
=
>
{
for
(
const
{
featureId
}
of
features
)
{
delete
lazy
.
NimbusFeatures
[
featureId
]
;
}
}
;
}
}
;
const
ExperimentFakes
=
{
manager
(
store
)
{
let
sandbox
=
lazy
.
sinon
.
createSandbox
(
)
;
let
manager
=
new
lazy
.
_ExperimentManager
(
{
store
:
store
|
|
this
.
store
(
)
}
)
;
let
origAddExperiment
=
manager
.
store
.
addEnrollment
.
bind
(
manager
.
store
)
;
sandbox
.
stub
(
manager
.
store
"
addEnrollment
"
)
.
callsFake
(
async
enrollment
=
>
{
await
ExperimentTestUtils
.
validateEnrollment
(
enrollment
)
;
return
origAddExperiment
(
enrollment
)
;
}
)
;
return
manager
;
}
store
(
)
{
return
new
ExperimentStore
(
"
FakeStore
"
{
path
:
PATH
isParent
:
true
}
)
;
}
waitForExperimentUpdate
(
ExperimentAPI
options
)
{
if
(
!
options
)
{
throw
new
Error
(
"
Must
specify
an
expected
recipe
update
"
)
;
}
return
new
Promise
(
resolve
=
>
ExperimentAPI
.
on
(
"
update
"
options
resolve
)
)
;
}
async
enrollWithRollout
(
featureConfig
{
manager
=
lazy
.
ExperimentManager
source
}
=
{
}
)
{
await
manager
.
store
.
init
(
)
;
const
rollout
=
this
.
rollout
(
{
featureConfig
.
featureId
}
-
rollout
{
branch
:
{
slug
:
{
featureConfig
.
featureId
}
-
rollout
-
branch
features
:
[
featureConfig
]
}
}
)
;
if
(
source
)
{
rollout
.
source
=
source
;
}
await
ExperimentTestUtils
.
validateRollouts
(
rollout
)
;
await
manager
.
store
.
addEnrollment
(
rollout
)
;
manager
.
store
.
_syncToChildren
(
{
flush
:
true
}
)
;
let
unenrollCompleted
=
slug
=
>
new
Promise
(
resolve
=
>
manager
.
store
.
on
(
update
:
{
slug
}
(
event
enrollment
)
=
>
{
if
(
enrollment
.
slug
=
=
=
rollout
.
slug
&
&
!
enrollment
.
active
)
{
manager
.
store
.
_deleteForTests
(
rollout
.
slug
)
;
resolve
(
)
;
}
}
)
)
;
return
(
)
=
>
{
let
promise
=
unenrollCompleted
(
rollout
.
slug
)
;
manager
.
unenroll
(
rollout
.
slug
"
cleanup
"
)
;
return
promise
;
}
;
}
async
enrollWithFeatureConfig
(
featureConfig
{
manager
=
lazy
.
ExperimentManager
}
=
{
}
)
{
await
manager
.
store
.
ready
(
)
;
let
experimentId
=
{
featureConfig
.
featureId
}
{
featureConfig
?
.
value
?
.
id
?
"
-
"
+
featureConfig
?
.
value
?
.
id
:
"
"
}
-
experiment
-
{
Math
.
random
(
)
}
;
let
recipe
=
this
.
recipe
(
experimentId
{
bucketConfig
:
{
namespace
:
"
mstest
-
utils
"
randomizationUnit
:
"
normandy_id
"
start
:
0
count
:
1000
total
:
1000
}
branches
:
[
{
slug
:
"
control
"
ratio
:
1
features
:
[
featureConfig
]
}
]
}
)
;
let
{
enrollmentPromise
doExperimentCleanup
}
=
this
.
enrollmentHelper
(
recipe
{
manager
}
)
;
await
enrollmentPromise
;
return
doExperimentCleanup
;
}
enrollmentHelper
(
recipe
=
{
}
{
manager
=
lazy
.
ExperimentManager
}
=
{
}
)
{
let
enrollmentPromise
=
new
Promise
(
resolve
=
>
manager
.
store
.
on
(
update
:
{
recipe
.
slug
}
(
event
experiment
)
=
>
{
if
(
experiment
.
active
)
{
manager
.
store
.
_syncToChildren
(
{
flush
:
true
}
)
;
resolve
(
experiment
)
;
}
}
)
)
;
let
unenrollCompleted
=
slug
=
>
new
Promise
(
resolve
=
>
manager
.
store
.
on
(
update
:
{
slug
}
(
event
experiment
)
=
>
{
if
(
!
experiment
.
active
)
{
manager
.
store
.
_deleteForTests
(
recipe
.
slug
)
;
resolve
(
)
;
}
}
)
)
;
let
doExperimentCleanup
=
async
(
)
=
>
{
for
(
let
experiment
of
manager
.
store
.
getAllActive
(
)
)
{
let
promise
=
unenrollCompleted
(
experiment
.
slug
)
;
manager
.
unenroll
(
experiment
.
slug
"
cleanup
"
)
;
await
promise
;
}
if
(
manager
.
store
.
getAllActive
(
)
.
length
)
{
throw
new
Error
(
"
Cleanup
failed
"
)
;
}
}
;
if
(
recipe
.
slug
)
{
if
(
!
manager
.
store
.
_isReady
)
{
throw
new
Error
(
"
Manager
store
not
ready
call
manager
.
onStartup
"
)
;
}
manager
.
enroll
(
recipe
"
enrollmentHelper
"
)
;
}
return
{
enrollmentPromise
doExperimentCleanup
}
;
}
cleanupStorePrefCache
(
)
{
try
{
Services
.
prefs
.
deleteBranch
(
SYNC_DATA_PREF_BRANCH
)
;
Services
.
prefs
.
deleteBranch
(
SYNC_DEFAULTS_PREF_BRANCH
)
;
}
catch
(
e
)
{
}
}
childStore
(
)
{
return
new
ExperimentStore
(
"
FakeStore
"
{
isParent
:
false
}
)
;
}
rsLoader
(
)
{
const
loader
=
new
lazy
.
_RemoteSettingsExperimentLoader
(
)
;
Object
.
defineProperty
(
loader
"
remoteSettingsClient
"
{
value
:
{
get
:
(
)
=
>
Promise
.
resolve
(
[
]
)
}
}
)
;
loader
.
manager
=
this
.
manager
(
)
;
return
loader
;
}
experiment
(
slug
props
=
{
}
)
{
return
{
slug
active
:
true
enrollmentId
:
lazy
.
NormandyUtils
.
generateUuid
(
)
branch
:
{
slug
:
"
treatment
"
features
:
[
{
featureId
:
"
testFeature
"
value
:
{
testInt
:
123
enabled
:
true
}
}
]
.
.
.
props
}
source
:
"
NimbusTestUtils
"
isEnrollmentPaused
:
true
experimentType
:
"
NimbusTestUtils
"
userFacingName
:
"
NimbusTestUtils
"
userFacingDescription
:
"
NimbusTestUtils
"
lastSeen
:
new
Date
(
)
.
toJSON
(
)
featureIds
:
props
?
.
branch
?
.
features
?
.
map
(
f
=
>
f
.
featureId
)
|
|
[
"
testFeature
"
]
.
.
.
props
}
;
}
rollout
(
slug
props
=
{
}
)
{
return
{
slug
active
:
true
enrollmentId
:
lazy
.
NormandyUtils
.
generateUuid
(
)
isRollout
:
true
branch
:
{
slug
:
"
treatment
"
features
:
[
{
featureId
:
"
testFeature
"
value
:
{
testInt
:
123
enabled
:
true
}
}
]
.
.
.
props
}
source
:
"
NimbusTestUtils
"
isEnrollmentPaused
:
true
experimentType
:
"
rollout
"
userFacingName
:
"
NimbusTestUtils
"
userFacingDescription
:
"
NimbusTestUtils
"
lastSeen
:
new
Date
(
)
.
toJSON
(
)
featureIds
:
(
props
?
.
branch
?
.
features
|
|
props
?
.
features
)
?
.
map
(
f
=
>
f
.
featureId
)
|
|
[
"
testFeature
"
]
.
.
.
props
}
;
}
recipe
(
slug
=
lazy
.
NormandyUtils
.
generateUuid
(
)
props
=
{
}
)
{
return
{
id
:
lazy
.
NormandyUtils
.
generateUuid
(
)
schemaVersion
:
"
1
.
7
.
0
"
appName
:
"
firefox_desktop
"
appId
:
"
firefox
-
desktop
"
channel
:
"
nightly
"
slug
isEnrollmentPaused
:
false
probeSets
:
[
]
startDate
:
null
endDate
:
null
proposedEnrollment
:
7
referenceBranch
:
"
control
"
application
:
"
firefox
-
desktop
"
branches
:
[
{
slug
:
"
control
"
ratio
:
1
features
:
[
{
featureId
:
"
testFeature
"
value
:
{
testInt
:
123
enabled
:
true
}
}
]
}
{
slug
:
"
treatment
"
ratio
:
1
features
:
[
{
featureId
:
"
testFeature
"
value
:
{
testInt
:
123
enabled
:
true
}
}
]
}
]
bucketConfig
:
{
namespace
:
"
nimbus
-
test
-
utils
"
randomizationUnit
:
"
normandy_id
"
start
:
0
count
:
100
total
:
1000
}
userFacingName
:
"
Nimbus
recipe
"
userFacingDescription
:
"
NimbusTestUtils
recipe
"
featureIds
:
props
?
.
branches
?
.
[
0
]
.
features
?
.
map
(
f
=
>
f
.
featureId
)
|
|
[
"
testFeature
"
]
.
.
.
props
}
;
}
}
;
