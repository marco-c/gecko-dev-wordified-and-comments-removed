"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
MessagePort
"
"
MessageListener
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AsyncPrefs
"
"
resource
:
/
/
gre
/
modules
/
AsyncPrefs
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
let
RPMAccessManager
=
{
accessMap
:
{
"
about
:
privatebrowsing
"
:
{
"
getBoolPref
"
:
[
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
"
browser
.
privatebrowsing
.
searchUI
"
]
"
getFormatURLPref
"
:
[
"
privacy
.
trackingprotection
.
introURL
"
"
app
.
support
.
baseURL
"
]
"
isWindowPrivate
"
:
[
"
yes
"
]
}
}
checkAllowAccess
(
aPrincipal
aFeature
aValue
)
{
if
(
!
aPrincipal
|
|
!
aPrincipal
.
URI
)
{
return
false
;
}
let
uri
=
aPrincipal
.
URI
.
asciiSpec
;
let
accessMapForURI
=
this
.
accessMap
[
uri
]
;
if
(
!
accessMapForURI
)
{
Cu
.
reportError
(
"
RPMAccessManager
does
not
allow
access
to
Feature
:
"
+
aFeature
+
"
for
:
"
+
uri
)
;
return
false
;
}
let
accessMapForFeature
=
accessMapForURI
[
aFeature
]
;
if
(
!
accessMapForFeature
)
{
Cu
.
reportError
(
"
RPMAccessManager
does
not
allow
access
to
Feature
:
"
+
aFeature
+
"
for
:
"
+
uri
)
;
return
false
;
}
if
(
accessMapForFeature
.
includes
(
aValue
)
)
{
return
true
;
}
Cu
.
reportError
(
"
RPMAccessManager
does
not
allow
access
to
Feature
:
"
+
aFeature
+
"
for
:
"
+
uri
)
;
return
false
;
}
}
;
class
MessageListener
{
constructor
(
)
{
this
.
listeners
=
new
Map
(
)
;
}
keys
(
)
{
return
this
.
listeners
.
keys
(
)
;
}
has
(
name
)
{
return
this
.
listeners
.
has
(
name
)
;
}
callListeners
(
message
)
{
let
listeners
=
this
.
listeners
.
get
(
message
.
name
)
;
if
(
!
listeners
)
{
return
;
}
for
(
let
listener
of
listeners
.
values
(
)
)
{
try
{
listener
(
message
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
addMessageListener
(
name
callback
)
{
if
(
!
this
.
listeners
.
has
(
name
)
)
this
.
listeners
.
set
(
name
new
Set
(
[
callback
]
)
)
;
else
this
.
listeners
.
get
(
name
)
.
add
(
callback
)
;
}
removeMessageListener
(
name
callback
)
{
if
(
!
this
.
listeners
.
has
(
name
)
)
return
;
this
.
listeners
.
get
(
name
)
.
delete
(
callback
)
;
}
}
class
MessagePort
{
constructor
(
messageManager
portID
)
{
this
.
messageManager
=
messageManager
;
this
.
portID
=
portID
;
this
.
destroyed
=
false
;
this
.
listener
=
new
MessageListener
(
)
;
this
.
message
=
this
.
message
.
bind
(
this
)
;
this
.
messageManager
.
addMessageListener
(
"
RemotePage
:
Message
"
this
.
message
)
;
}
swapMessageManager
(
messageManager
)
{
this
.
messageManager
.
removeMessageListener
(
"
RemotePage
:
Message
"
this
.
message
)
;
this
.
messageManager
=
messageManager
;
this
.
messageManager
.
addMessageListener
(
"
RemotePage
:
Message
"
this
.
message
)
;
}
addMessageListener
(
name
callback
)
{
if
(
this
.
destroyed
)
{
throw
new
Error
(
"
Message
port
has
been
destroyed
"
)
;
}
this
.
listener
.
addMessageListener
(
name
callback
)
;
}
removeMessageListener
(
name
callback
)
{
if
(
this
.
destroyed
)
{
throw
new
Error
(
"
Message
port
has
been
destroyed
"
)
;
}
this
.
listener
.
removeMessageListener
(
name
callback
)
;
}
sendAsyncMessage
(
name
data
=
null
)
{
if
(
this
.
destroyed
)
{
throw
new
Error
(
"
Message
port
has
been
destroyed
"
)
;
}
this
.
messageManager
.
sendAsyncMessage
(
"
RemotePage
:
Message
"
{
portID
:
this
.
portID
name
data
}
)
;
}
destroy
(
)
{
try
{
this
.
messageManager
.
removeMessageListener
(
"
RemotePage
:
Message
"
this
.
message
)
;
}
catch
(
e
)
{
}
this
.
messageManager
=
null
;
this
.
destroyed
=
true
;
this
.
portID
=
null
;
this
.
listener
=
null
;
}
getBoolPref
(
aPref
)
{
let
principal
=
this
.
window
.
document
.
nodePrincipal
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
principal
"
getBoolPref
"
aPref
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
getBoolPref
"
)
;
}
return
Services
.
prefs
.
getBoolPref
(
aPref
)
;
}
setBoolPref
(
aPref
aVal
)
{
return
new
this
.
window
.
Promise
(
function
(
resolve
)
{
AsyncPrefs
.
set
(
aPref
aVal
)
.
then
(
function
(
)
{
resolve
(
)
;
}
)
;
}
)
;
}
getFormatURLPref
(
aFormatURL
)
{
let
principal
=
this
.
window
.
document
.
nodePrincipal
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
principal
"
getFormatURLPref
"
aFormatURL
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
getFormatURLPref
"
)
;
}
return
Services
.
urlFormatter
.
formatURLPref
(
aFormatURL
)
;
}
isWindowPrivate
(
)
{
let
principal
=
this
.
window
.
document
.
nodePrincipal
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
principal
"
isWindowPrivate
"
"
yes
"
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
isWindowPrivate
"
)
;
}
return
PrivateBrowsingUtils
.
isContentWindowPrivate
(
this
.
window
)
;
}
}
