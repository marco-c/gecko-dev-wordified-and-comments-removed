"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
MessagePort
"
"
MessageListener
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AsyncPrefs
"
"
resource
:
/
/
gre
/
modules
/
AsyncPrefs
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
let
RPMAccessManager
=
{
accessMap
:
{
"
about
:
certerror
"
:
{
getFormatURLPref
:
[
"
app
.
support
.
baseURL
"
]
getBoolPref
:
[
"
security
.
certerrors
.
mitm
.
priming
.
enabled
"
"
security
.
enterprise_roots
.
auto
-
enabled
"
"
security
.
certerror
.
hideAddException
"
"
security
.
ssl
.
errorReporting
.
automatic
"
"
security
.
ssl
.
errorReporting
.
enabled
"
]
setBoolPref
:
[
"
security
.
ssl
.
errorReporting
.
automatic
"
]
getIntPref
:
[
"
services
.
settings
.
clock_skew_seconds
"
"
services
.
settings
.
last_update_seconds
"
]
getAppBuildID
:
[
"
yes
"
]
recordTelemetryEvent
:
[
"
yes
"
]
addToHistogram
:
[
"
yes
"
]
}
"
about
:
neterror
"
:
{
getFormatURLPref
:
[
"
app
.
support
.
baseURL
"
]
getBoolPref
:
[
"
security
.
certerror
.
hideAddException
"
"
security
.
ssl
.
errorReporting
.
automatic
"
"
security
.
ssl
.
errorReporting
.
enabled
"
"
security
.
tls
.
version
.
enable
-
deprecated
"
]
setBoolPref
:
[
"
security
.
ssl
.
errorReporting
.
automatic
"
]
addToHistogram
:
[
"
yes
"
]
}
"
about
:
privatebrowsing
"
:
{
getFormatURLPref
:
[
"
app
.
support
.
baseURL
"
]
isWindowPrivate
:
[
"
yes
"
]
}
"
about
:
protections
"
:
{
getBoolPref
:
[
"
browser
.
contentblocking
.
report
.
lockwise
.
enabled
"
"
browser
.
contentblocking
.
report
.
monitor
.
enabled
"
"
privacy
.
socialtracking
.
block_cookies
.
enabled
"
"
browser
.
contentblocking
.
report
.
proxy
.
enabled
"
"
privacy
.
trackingprotection
.
cryptomining
.
enabled
"
"
privacy
.
trackingprotection
.
fingerprinting
.
enabled
"
"
privacy
.
trackingprotection
.
enabled
"
"
privacy
.
trackingprotection
.
socialtracking
.
enabled
"
]
getStringPref
:
[
"
browser
.
contentblocking
.
category
"
"
browser
.
contentblocking
.
report
.
lockwise
.
url
"
"
browser
.
contentblocking
.
report
.
monitor
.
url
"
"
browser
.
contentblocking
.
report
.
monitor
.
sign_in_url
"
"
browser
.
contentblocking
.
report
.
manage_devices
.
url
"
"
browser
.
contentblocking
.
report
.
proxy_extension
.
url
"
]
getIntPref
:
[
"
network
.
cookie
.
cookieBehavior
"
]
getFormatURLPref
:
[
"
browser
.
contentblocking
.
report
.
monitor
.
how_it_works
.
url
"
"
browser
.
contentblocking
.
report
.
lockwise
.
how_it_works
.
url
"
"
browser
.
contentblocking
.
report
.
social
.
url
"
"
browser
.
contentblocking
.
report
.
cookie
.
url
"
"
browser
.
contentblocking
.
report
.
tracker
.
url
"
"
browser
.
contentblocking
.
report
.
fingerprinter
.
url
"
"
browser
.
contentblocking
.
report
.
cryptominer
.
url
"
]
recordTelemetryEvent
:
[
"
yes
"
]
}
"
about
:
newinstall
"
:
{
getUpdateChannel
:
[
"
yes
"
]
getFxAccountsEndpoint
:
[
"
yes
"
]
}
}
checkAllowAccess
(
aDocument
aFeature
aValue
)
{
let
principal
=
aDocument
.
nodePrincipal
;
if
(
!
principal
)
{
return
false
;
}
let
uri
;
if
(
principal
.
isNullPrincipal
|
|
!
principal
.
URI
)
{
uri
=
aDocument
.
documentURIObject
;
}
else
{
uri
=
principal
.
URI
;
}
let
spec
=
uri
.
prePath
+
uri
.
filePath
;
if
(
!
uri
.
schemeIs
(
"
about
"
)
)
{
Cu
.
reportError
(
"
RPMAccessManager
does
not
allow
access
to
Feature
:
"
+
aFeature
+
"
for
:
"
+
spec
)
;
return
false
;
}
let
accessMapForURI
=
this
.
accessMap
[
spec
]
;
if
(
!
accessMapForURI
)
{
Cu
.
reportError
(
"
RPMAccessManager
does
not
allow
access
to
Feature
:
"
+
aFeature
+
"
for
:
"
+
spec
)
;
return
false
;
}
let
accessMapForFeature
=
accessMapForURI
[
aFeature
]
;
if
(
!
accessMapForFeature
)
{
Cu
.
reportError
(
"
RPMAccessManager
does
not
allow
access
to
Feature
:
"
+
aFeature
+
"
for
:
"
+
spec
)
;
return
false
;
}
if
(
accessMapForFeature
.
includes
(
aValue
)
)
{
return
true
;
}
Cu
.
reportError
(
"
RPMAccessManager
does
not
allow
access
to
Feature
:
"
+
aFeature
+
"
for
:
"
+
spec
)
;
return
false
;
}
}
;
class
MessageListener
{
constructor
(
)
{
this
.
listeners
=
new
Map
(
)
;
}
keys
(
)
{
return
this
.
listeners
.
keys
(
)
;
}
has
(
name
)
{
return
this
.
listeners
.
has
(
name
)
;
}
callListeners
(
message
)
{
let
listeners
=
this
.
listeners
.
get
(
message
.
name
)
;
if
(
!
listeners
)
{
return
;
}
for
(
let
listener
of
listeners
.
values
(
)
)
{
try
{
listener
(
message
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
addMessageListener
(
name
callback
)
{
if
(
!
this
.
listeners
.
has
(
name
)
)
{
this
.
listeners
.
set
(
name
new
Set
(
[
callback
]
)
)
;
}
else
{
this
.
listeners
.
get
(
name
)
.
add
(
callback
)
;
}
}
removeMessageListener
(
name
callback
)
{
if
(
!
this
.
listeners
.
has
(
name
)
)
{
return
;
}
this
.
listeners
.
get
(
name
)
.
delete
(
callback
)
;
}
}
class
MessagePort
{
constructor
(
messageManagerOrActor
portID
)
{
this
.
messageManager
=
messageManagerOrActor
;
this
.
portID
=
portID
;
this
.
destroyed
=
false
;
this
.
listener
=
new
MessageListener
(
)
;
this
.
requests
=
[
]
;
this
.
message
=
this
.
message
.
bind
(
this
)
;
this
.
receiveRequest
=
this
.
receiveRequest
.
bind
(
this
)
;
this
.
receiveResponse
=
this
.
receiveResponse
.
bind
(
this
)
;
this
.
addMessageListeners
(
)
;
}
addMessageListeners
(
)
{
if
(
!
(
this
.
messageManager
instanceof
Ci
.
nsIMessageSender
)
)
{
return
;
}
this
.
messageManager
.
addMessageListener
(
"
RemotePage
:
Message
"
this
.
message
)
;
this
.
messageManager
.
addMessageListener
(
"
RemotePage
:
Request
"
this
.
receiveRequest
)
;
this
.
messageManager
.
addMessageListener
(
"
RemotePage
:
Response
"
this
.
receiveResponse
)
;
}
removeMessageListeners
(
)
{
if
(
!
(
this
.
messageManager
instanceof
Ci
.
nsIMessageSender
)
)
{
return
;
}
this
.
messageManager
.
removeMessageListener
(
"
RemotePage
:
Message
"
this
.
message
)
;
this
.
messageManager
.
removeMessageListener
(
"
RemotePage
:
Request
"
this
.
receiveRequest
)
;
this
.
messageManager
.
removeMessageListener
(
"
RemotePage
:
Response
"
this
.
receiveResponse
)
;
}
swapMessageManager
(
messageManager
)
{
this
.
removeMessageListeners
(
)
;
this
.
messageManager
=
messageManager
;
this
.
addMessageListeners
(
)
;
}
sendRequest
(
name
data
=
null
)
{
if
(
this
.
destroyed
)
{
return
this
.
window
.
Promise
.
reject
(
new
Error
(
"
Message
port
has
been
destroyed
"
)
)
;
}
let
deferred
=
PromiseUtils
.
defer
(
)
;
this
.
requests
.
push
(
deferred
)
;
this
.
messageManager
.
sendAsyncMessage
(
"
RemotePage
:
Request
"
{
portID
:
this
.
portID
requestID
:
this
.
requests
.
length
-
1
name
data
}
)
;
return
this
.
wrapPromise
(
deferred
.
promise
)
;
}
async
receiveRequest
(
{
data
:
messagedata
}
)
{
if
(
this
.
destroyed
|
|
messagedata
.
portID
!
=
this
.
portID
)
{
return
;
}
let
data
=
{
portID
:
this
.
portID
requestID
:
messagedata
.
requestID
}
;
try
{
data
.
resolve
=
await
this
.
handleRequest
(
messagedata
.
name
messagedata
.
data
)
;
}
catch
(
e
)
{
data
.
reject
=
e
;
}
this
.
messageManager
.
sendAsyncMessage
(
"
RemotePage
:
Response
"
data
)
;
}
receiveResponse
(
{
data
:
messagedata
}
)
{
if
(
this
.
destroyed
|
|
messagedata
.
portID
!
=
this
.
portID
)
{
return
;
}
let
deferred
=
this
.
requests
[
messagedata
.
requestID
]
;
if
(
!
deferred
)
{
Cu
.
reportError
(
"
Received
a
response
to
an
unknown
request
.
"
)
;
return
;
}
delete
this
.
requests
[
messagedata
.
requestID
]
;
if
(
"
resolve
"
in
messagedata
)
{
deferred
.
resolve
(
messagedata
.
resolve
)
;
}
else
if
(
"
reject
"
in
messagedata
)
{
deferred
.
reject
(
messagedata
.
reject
)
;
}
else
{
deferred
.
reject
(
new
Error
(
"
Internal
RPM
error
.
"
)
)
;
}
}
message
(
{
data
:
messagedata
}
)
{
if
(
this
.
destroyed
|
|
messagedata
.
portID
!
=
this
.
portID
)
{
return
;
}
this
.
handleMessage
(
messagedata
)
;
}
addMessageListener
(
name
callback
)
{
if
(
this
.
destroyed
)
{
throw
new
Error
(
"
Message
port
has
been
destroyed
"
)
;
}
this
.
listener
.
addMessageListener
(
name
callback
)
;
}
removeMessageListener
(
name
callback
)
{
if
(
this
.
destroyed
)
{
throw
new
Error
(
"
Message
port
has
been
destroyed
"
)
;
}
this
.
listener
.
removeMessageListener
(
name
callback
)
;
}
sendAsyncMessage
(
name
data
=
null
)
{
if
(
this
.
destroyed
)
{
throw
new
Error
(
"
Message
port
has
been
destroyed
"
)
;
}
let
id
;
if
(
this
.
window
)
{
id
=
this
.
window
.
docShell
.
browsingContext
.
id
;
}
if
(
this
.
messageManager
instanceof
Ci
.
nsIMessageSender
)
{
this
.
messageManager
.
sendAsyncMessage
(
"
RemotePage
:
Message
"
{
portID
:
this
.
portID
browsingContextID
:
id
name
data
}
)
;
}
else
{
this
.
messageManager
.
sendAsyncMessage
(
name
data
)
;
}
}
destroy
(
)
{
try
{
this
.
removeMessageListeners
(
)
;
}
catch
(
e
)
{
}
for
(
let
deferred
of
this
.
requests
)
{
if
(
deferred
)
{
deferred
.
reject
(
new
Error
(
"
Message
port
has
been
destroyed
"
)
)
;
}
}
this
.
messageManager
=
null
;
this
.
destroyed
=
true
;
this
.
portID
=
null
;
this
.
listener
=
null
;
this
.
requests
=
[
]
;
}
wrapPromise
(
promise
)
{
return
new
this
.
window
.
Promise
(
(
resolve
reject
)
=
>
promise
.
then
(
resolve
reject
)
)
;
}
getAppBuildID
(
)
{
let
doc
=
this
.
window
.
document
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
doc
"
getAppBuildID
"
"
yes
"
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
getAppBuildID
"
)
;
}
return
Services
.
appinfo
.
appBuildID
;
}
getIntPref
(
aPref
defaultValue
)
{
let
doc
=
this
.
window
.
document
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
doc
"
getIntPref
"
aPref
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
getIntPref
"
)
;
}
if
(
defaultValue
!
=
=
undefined
)
{
return
Services
.
prefs
.
getIntPref
(
aPref
defaultValue
)
;
}
return
Services
.
prefs
.
getIntPref
(
aPref
)
;
}
getStringPref
(
aPref
)
{
let
doc
=
this
.
window
.
document
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
doc
"
getStringPref
"
aPref
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
getStringPref
"
)
;
}
return
Services
.
prefs
.
getStringPref
(
aPref
)
;
}
getBoolPref
(
aPref
defaultValue
)
{
let
doc
=
this
.
window
.
document
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
doc
"
getBoolPref
"
aPref
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
getBoolPref
"
)
;
}
if
(
defaultValue
!
=
=
undefined
)
{
return
Services
.
prefs
.
getBoolPref
(
aPref
defaultValue
)
;
}
return
Services
.
prefs
.
getBoolPref
(
aPref
)
;
}
setBoolPref
(
aPref
aVal
)
{
return
this
.
wrapPromise
(
AsyncPrefs
.
set
(
aPref
aVal
)
)
;
}
getFormatURLPref
(
aFormatURL
)
{
let
doc
=
this
.
window
.
document
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
doc
"
getFormatURLPref
"
aFormatURL
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
getFormatURLPref
"
)
;
}
return
Services
.
urlFormatter
.
formatURLPref
(
aFormatURL
)
;
}
isWindowPrivate
(
)
{
let
doc
=
this
.
window
.
document
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
doc
"
isWindowPrivate
"
"
yes
"
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
isWindowPrivate
"
)
;
}
return
PrivateBrowsingUtils
.
isContentWindowPrivate
(
this
.
window
)
;
}
getUpdateChannel
(
)
{
let
doc
=
this
.
window
.
document
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
doc
"
getUpdateChannel
"
"
yes
"
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
getUpdateChannel
"
)
;
}
return
UpdateUtils
.
UpdateChannel
;
}
getFxAccountsEndpoint
(
aEntrypoint
)
{
let
doc
=
this
.
window
.
document
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
doc
"
getFxAccountsEndpoint
"
"
yes
"
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
getFxAccountsEndpoint
"
)
;
}
return
this
.
sendRequest
(
"
FxAccountsEndpoint
"
aEntrypoint
)
;
}
recordTelemetryEvent
(
category
event
object
value
extra
)
{
let
doc
=
this
.
window
.
document
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
doc
"
recordTelemetryEvent
"
"
yes
"
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
recordTelemetryEvent
"
)
;
}
return
Services
.
telemetry
.
recordEvent
(
category
event
object
value
extra
)
;
}
addToHistogram
(
histID
bin
)
{
let
doc
=
this
.
window
.
document
;
if
(
!
RPMAccessManager
.
checkAllowAccess
(
doc
"
addToHistogram
"
"
yes
"
)
)
{
throw
new
Error
(
"
RPMAccessManager
does
not
allow
access
to
addToHistogram
"
)
;
}
Services
.
telemetry
.
getHistogramById
(
histID
)
.
add
(
bin
)
;
}
}
