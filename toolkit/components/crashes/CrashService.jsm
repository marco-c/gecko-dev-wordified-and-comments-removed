"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
this
)
;
var
gQuitting
=
false
;
var
gRunningProcesses
=
new
Set
(
)
;
async
function
maybeRunMinidumpAnalyzer
(
minidumpPath
allThreads
)
{
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
let
shutdown
=
env
.
exists
(
"
MOZ_CRASHREPORTER_SHUTDOWN
"
)
;
if
(
gQuitting
|
|
shutdown
)
{
return
;
}
await
runMinidumpAnalyzer
(
minidumpPath
allThreads
)
.
catch
(
e
=
>
Cu
.
reportError
(
e
)
)
;
}
function
getMinidumpAnalyzerPath
(
)
{
const
binSuffix
=
AppConstants
.
platform
=
=
=
"
win
"
?
"
.
exe
"
:
"
"
;
const
exeName
=
"
minidump
-
analyzer
"
+
binSuffix
;
let
exe
=
Services
.
dirsvc
.
get
(
"
GreBinD
"
Ci
.
nsIFile
)
;
exe
.
append
(
exeName
)
;
return
exe
;
}
function
runMinidumpAnalyzer
(
minidumpPath
allThreads
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
try
{
let
exe
=
getMinidumpAnalyzerPath
(
)
;
let
args
=
[
minidumpPath
]
;
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
process
.
init
(
exe
)
;
process
.
startHidden
=
true
;
process
.
noShell
=
true
;
if
(
allThreads
)
{
args
.
unshift
(
"
-
-
full
"
)
;
}
process
.
runAsync
(
args
args
.
length
(
subject
topic
data
)
=
>
{
switch
(
topic
)
{
case
"
process
-
finished
"
:
gRunningProcesses
.
delete
(
process
)
;
resolve
(
)
;
break
;
case
"
process
-
failed
"
:
gRunningProcesses
.
delete
(
process
)
;
resolve
(
)
;
break
;
default
:
reject
(
new
Error
(
"
Unexpected
topic
received
"
+
topic
)
)
;
break
;
}
}
)
;
gRunningProcesses
.
add
(
process
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
;
}
function
computeMinidumpHash
(
minidumpPath
)
{
return
(
async
function
(
)
{
try
{
let
minidumpData
=
await
OS
.
File
.
read
(
minidumpPath
)
;
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA256
)
;
hasher
.
update
(
minidumpData
minidumpData
.
length
)
;
let
hashBin
=
hasher
.
finish
(
false
)
;
let
hash
=
"
"
;
for
(
let
i
=
0
;
i
<
hashBin
.
length
;
i
+
+
)
{
hash
+
=
(
"
0
"
+
hashBin
.
charCodeAt
(
i
)
.
toString
(
16
)
)
.
slice
(
-
2
)
;
}
return
hash
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
null
;
}
}
)
(
)
;
}
function
processExtraFile
(
extraPath
)
{
return
(
async
function
(
)
{
try
{
let
decoder
=
new
TextDecoder
(
)
;
let
extraData
=
await
OS
.
File
.
read
(
extraPath
)
;
return
JSON
.
parse
(
decoder
.
decode
(
extraData
)
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
{
}
;
}
}
)
(
)
;
}
this
.
CrashService
=
function
(
)
{
Services
.
obs
.
addObserver
(
this
"
quit
-
application
"
)
;
}
;
CrashService
.
prototype
=
Object
.
freeze
(
{
classID
:
Components
.
ID
(
"
{
92668367
-
1b17
-
4190
-
86b2
-
1061b2179744
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsICrashService
Ci
.
nsIObserver
]
)
async
addCrash
(
processType
crashType
id
)
{
switch
(
processType
)
{
case
Ci
.
nsICrashService
.
PROCESS_TYPE_MAIN
:
processType
=
Services
.
crashmanager
.
PROCESS_TYPE_MAIN
;
break
;
case
Ci
.
nsICrashService
.
PROCESS_TYPE_CONTENT
:
processType
=
Services
.
crashmanager
.
PROCESS_TYPE_CONTENT
;
break
;
case
Ci
.
nsICrashService
.
PROCESS_TYPE_PLUGIN
:
processType
=
Services
.
crashmanager
.
PROCESS_TYPE_PLUGIN
;
break
;
case
Ci
.
nsICrashService
.
PROCESS_TYPE_GMPLUGIN
:
processType
=
Services
.
crashmanager
.
PROCESS_TYPE_GMPLUGIN
;
break
;
case
Ci
.
nsICrashService
.
PROCESS_TYPE_GPU
:
processType
=
Services
.
crashmanager
.
PROCESS_TYPE_GPU
;
break
;
case
Ci
.
nsICrashService
.
PROCESS_TYPE_VR
:
processType
=
Services
.
crashmanager
.
PROCESS_TYPE_VR
;
break
;
case
Ci
.
nsICrashService
.
PROCESS_TYPE_RDD
:
processType
=
Services
.
crashmanager
.
PROCESS_TYPE_RDD
;
break
;
case
Ci
.
nsICrashService
.
PROCESS_TYPE_SOCKET
:
processType
=
Services
.
crashmanager
.
PROCESS_TYPE_SOCKET
;
break
;
case
Ci
.
nsICrashService
.
PROCESS_TYPE_IPDLUNITTEST
:
return
;
default
:
throw
new
Error
(
"
Unrecognized
PROCESS_TYPE
:
"
+
processType
)
;
}
let
allThreads
=
false
;
switch
(
crashType
)
{
case
Ci
.
nsICrashService
.
CRASH_TYPE_CRASH
:
crashType
=
Services
.
crashmanager
.
CRASH_TYPE_CRASH
;
break
;
case
Ci
.
nsICrashService
.
CRASH_TYPE_HANG
:
crashType
=
Services
.
crashmanager
.
CRASH_TYPE_HANG
;
allThreads
=
true
;
break
;
default
:
throw
new
Error
(
"
Unrecognized
CRASH_TYPE
:
"
+
crashType
)
;
}
let
cr
=
Cc
[
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
]
.
getService
(
Ci
.
nsICrashReporter
)
;
let
minidumpPath
=
cr
.
getMinidumpForID
(
id
)
.
path
;
let
extraPath
=
cr
.
getExtraFileForID
(
id
)
.
path
;
let
metadata
=
{
}
;
let
hash
=
null
;
await
maybeRunMinidumpAnalyzer
(
minidumpPath
allThreads
)
;
metadata
=
await
processExtraFile
(
extraPath
)
;
hash
=
await
computeMinidumpHash
(
minidumpPath
)
;
if
(
hash
)
{
metadata
.
MinidumpSha256Hash
=
hash
;
}
let
blocker
=
Services
.
crashmanager
.
addCrash
(
processType
crashType
id
new
Date
(
)
metadata
)
;
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
CrashService
waiting
for
content
crash
ping
to
be
sent
"
blocker
)
;
blocker
.
then
(
AsyncShutdown
.
profileBeforeChange
.
removeBlocker
(
blocker
)
)
;
await
blocker
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
profile
-
after
-
change
"
:
Services
.
crashmanager
;
break
;
case
"
quit
-
application
"
:
gQuitting
=
true
;
gRunningProcesses
.
forEach
(
process
=
>
{
try
{
process
.
kill
(
)
;
}
catch
(
e
)
{
}
Services
.
obs
.
notifyObservers
(
null
"
test
-
minidump
-
analyzer
-
killed
"
)
;
}
)
;
break
;
}
}
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
CrashService
"
]
;
