"
use
strict
"
;
const
TEST_DOMAIN_A
=
"
example
.
com
"
;
const
TEST_DOMAIN_B
=
"
example
.
org
"
;
const
TEST_DOMAIN_C
=
"
example
.
net
"
;
const
TEST_ORIGIN_A
=
"
https
:
/
/
"
+
TEST_DOMAIN_A
;
const
TEST_ORIGIN_B
=
"
https
:
/
/
"
+
TEST_DOMAIN_B
;
const
TEST_ORIGIN_C
=
"
https
:
/
/
"
+
TEST_DOMAIN_C
;
const
TEST_PATH
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
"
)
;
const
TEST_PAGE_A
=
TEST_ORIGIN_A
+
TEST_PATH
+
"
file_banner
.
html
"
;
const
TEST_PAGE_B
=
TEST_ORIGIN_B
+
TEST_PATH
+
"
file_banner
.
html
"
;
const
TEST_PAGE_C
=
TEST_ORIGIN_C
+
TEST_PATH
+
"
file_banner_b
.
html
"
;
function
genUUID
(
)
{
return
Services
.
uuid
.
generateUUID
(
)
.
number
.
slice
(
1
-
1
)
;
}
async
function
testSetup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
cookiebanners
.
listService
.
logLevel
"
"
Debug
"
]
[
"
cookiebanners
.
listService
.
testSkipRemoteSettings
"
true
]
]
}
)
;
await
Services
.
fog
.
testFlushAllChildren
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
cookiebanners
.
service
.
mode
"
)
;
Services
.
prefs
.
clearUserPref
(
"
cookiebanners
.
service
.
mode
.
privateBrowsing
"
)
;
if
(
Services
.
cookieBanners
.
isEnabled
)
{
Services
.
cookieBanners
.
resetRules
(
true
)
;
}
Services
.
cookieBanners
.
removeAllExecutedRecords
(
false
)
;
Services
.
cookieBanners
.
removeAllExecutedRecords
(
true
)
;
}
)
;
}
async
function
clickTestSetup
(
)
{
await
testSetup
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
cookiebanners
.
bannerClicking
.
logLevel
"
"
Debug
"
]
[
"
cookiebanners
.
bannerClicking
.
testing
"
true
]
[
"
cookiebanners
.
bannerClicking
.
timeoutAfterLoad
"
500
]
[
"
cookiebanners
.
bannerClicking
.
enabled
"
true
]
[
"
cookiebanners
.
cookieInjector
.
enabled
"
false
]
]
}
)
;
}
async
function
cookieInjectorTestSetup
(
)
{
await
testSetup
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
cookiebanners
.
cookieInjector
.
enabled
"
true
]
[
"
cookiebanners
.
bannerClicking
.
enabled
"
true
]
]
}
)
;
}
function
promiseBannerClickingFinish
(
domain
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
data
)
{
if
(
data
!
=
domain
)
{
return
;
}
Services
.
obs
.
removeObserver
(
observer
"
cookie
-
banner
-
test
-
clicking
-
finish
"
)
;
resolve
(
)
;
}
"
cookie
-
banner
-
test
-
clicking
-
finish
"
)
;
}
)
;
}
async
function
verifyBannerState
(
bc
visible
expected
bannerId
=
"
banner
"
)
{
info
(
"
Verify
the
cookie
banner
state
.
"
)
;
await
SpecialPowers
.
spawn
(
bc
[
visible
expected
bannerId
]
(
visible
expected
bannerId
)
=
>
{
let
banner
=
content
.
document
.
getElementById
(
bannerId
)
;
is
(
banner
.
checkVisibility
(
{
checkOpacity
:
true
checkVisibilityCSS
:
true
}
)
visible
The
banner
element
should
be
{
visible
?
"
visible
"
:
"
hidden
"
}
)
;
let
result
=
content
.
document
.
getElementById
(
"
result
"
)
;
is
(
result
.
textContent
expected
"
The
build
click
state
is
correct
.
"
)
;
}
)
;
}
async
function
openPageAndVerify
(
{
win
=
window
domain
testURL
visible
expected
bannerId
=
"
banner
"
keepTabOpen
=
false
expectActorEnabled
=
true
}
)
{
info
(
Opening
{
testURL
}
)
;
let
promise
=
expectActorEnabled
?
promiseBannerClickingFinish
(
domain
)
:
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
testURL
)
;
await
promise
;
await
verifyBannerState
(
tab
.
linkedBrowser
visible
expected
bannerId
)
;
if
(
!
keepTabOpen
)
{
BrowserTestUtils
.
removeTab
(
tab
)
;
}
}
async
function
openIframeAndVerify
(
{
win
domain
testURL
visible
expected
}
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
TEST_ORIGIN_C
)
;
let
promise
=
promiseBannerClickingFinish
(
domain
)
;
let
iframeBC
=
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
testURL
]
async
testURL
=
>
{
let
iframe
=
content
.
document
.
createElement
(
"
iframe
"
)
;
iframe
.
src
=
testURL
;
content
.
document
.
body
.
appendChild
(
iframe
)
;
await
ContentTaskUtils
.
waitForEvent
(
iframe
"
load
"
)
;
return
iframe
.
browsingContext
;
}
)
;
await
promise
;
await
verifyBannerState
(
iframeBC
visible
expected
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
function
insertTestClickRules
(
insertGlobalRules
=
true
)
{
info
(
"
Clearing
existing
rules
"
)
;
Services
.
cookieBanners
.
resetRules
(
false
)
;
info
(
"
Inserting
test
rules
.
"
)
;
info
(
"
Add
opt
-
out
click
rule
for
DOMAIN_A
.
"
)
;
let
ruleA
=
Cc
[
"
mozilla
.
org
/
cookie
-
banner
-
rule
;
1
"
]
.
createInstance
(
Ci
.
nsICookieBannerRule
)
;
ruleA
.
id
=
genUUID
(
)
;
ruleA
.
domains
=
[
TEST_DOMAIN_A
]
;
ruleA
.
addClickRule
(
"
div
#
banner
"
false
Ci
.
nsIClickRule
.
RUN_ALL
null
"
button
#
optOut
"
"
button
#
optIn
"
)
;
Services
.
cookieBanners
.
insertRule
(
ruleA
)
;
info
(
"
Add
opt
-
in
click
rule
for
DOMAIN_B
.
"
)
;
let
ruleB
=
Cc
[
"
mozilla
.
org
/
cookie
-
banner
-
rule
;
1
"
]
.
createInstance
(
Ci
.
nsICookieBannerRule
)
;
ruleB
.
id
=
genUUID
(
)
;
ruleB
.
domains
=
[
TEST_DOMAIN_B
]
;
ruleB
.
addClickRule
(
"
div
#
banner
"
false
Ci
.
nsIClickRule
.
RUN_ALL
null
null
"
button
#
optIn
"
)
;
Services
.
cookieBanners
.
insertRule
(
ruleB
)
;
if
(
insertGlobalRules
)
{
info
(
"
Add
global
ruleC
which
targets
a
non
-
existing
banner
(
presence
)
.
"
)
;
let
ruleC
=
Cc
[
"
mozilla
.
org
/
cookie
-
banner
-
rule
;
1
"
]
.
createInstance
(
Ci
.
nsICookieBannerRule
)
;
ruleC
.
id
=
genUUID
(
)
;
ruleC
.
domains
=
[
]
;
ruleC
.
addClickRule
(
"
div
#
nonExistingBanner
"
false
Ci
.
nsIClickRule
.
RUN_ALL
null
null
"
button
#
optIn
"
)
;
Services
.
cookieBanners
.
insertRule
(
ruleC
)
;
info
(
"
Add
global
ruleD
which
targets
a
non
-
existing
banner
(
presence
)
.
"
)
;
let
ruleD
=
Cc
[
"
mozilla
.
org
/
cookie
-
banner
-
rule
;
1
"
]
.
createInstance
(
Ci
.
nsICookieBannerRule
)
;
ruleD
.
id
=
genUUID
(
)
;
ruleD
.
domains
=
[
]
;
ruleD
.
addClickRule
(
"
div
#
nonExistingBanner2
"
false
Ci
.
nsIClickRule
.
RUN_ALL
null
"
button
#
optOut
"
"
button
#
optIn
"
)
;
Services
.
cookieBanners
.
insertRule
(
ruleD
)
;
}
}
function
insertTestCookieRules
(
)
{
info
(
"
Clearing
existing
rules
"
)
;
Services
.
cookieBanners
.
resetRules
(
false
)
;
info
(
"
Inserting
test
rules
.
"
)
;
let
ruleA
=
Cc
[
"
mozilla
.
org
/
cookie
-
banner
-
rule
;
1
"
]
.
createInstance
(
Ci
.
nsICookieBannerRule
)
;
ruleA
.
domains
=
[
TEST_DOMAIN_A
TEST_DOMAIN_C
]
;
Services
.
cookieBanners
.
insertRule
(
ruleA
)
;
ruleA
.
addCookie
(
true
cookieConsent_
{
TEST_DOMAIN_A
}
_1
"
optOut1
"
null
"
/
"
3600
"
"
false
false
false
0
0
)
;
ruleA
.
addCookie
(
true
cookieConsent_
{
TEST_DOMAIN_A
}
_2
"
optOut2
"
null
"
/
"
3600
"
"
false
false
false
0
0
)
;
let
ruleB
=
Cc
[
"
mozilla
.
org
/
cookie
-
banner
-
rule
;
1
"
]
.
createInstance
(
Ci
.
nsICookieBannerRule
)
;
ruleB
.
domains
=
[
TEST_DOMAIN_B
]
;
Services
.
cookieBanners
.
insertRule
(
ruleB
)
;
ruleB
.
addCookie
(
false
cookieConsent_
{
TEST_DOMAIN_B
}
_1
"
optIn1
"
TEST_DOMAIN_B
"
/
"
3600
"
UNSET
"
false
false
true
0
0
)
;
}
async
function
testClickResultTelemetry
(
expected
resetFOG
=
true
)
{
if
(
AppConstants
.
platform
=
=
"
linux
"
)
{
ok
(
true
"
Skip
click
telemetry
tests
on
linux
.
"
)
;
return
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
cookiebanners
.
service
.
enableGlobalRules
"
)
)
{
ok
(
true
"
Skip
click
telemetry
when
global
rules
are
enabled
.
"
)
;
return
;
}
await
Services
.
fog
.
testFlushAllChildren
(
)
;
let
labels
=
[
"
success
"
"
success_cookie_injected
"
"
success_dom_content_loaded
"
"
success_mutation_pre_load
"
"
success_mutation_post_load
"
"
fail
"
"
fail_banner_not_found
"
"
fail_banner_not_visible
"
"
fail_button_not_found
"
"
fail_no_rule_for_mode
"
"
fail_actor_destroyed
"
]
;
let
testMetricState
=
doAssert
=
>
{
for
(
let
label
of
labels
)
{
let
expectedValue
=
expected
[
label
]
?
?
null
;
if
(
doAssert
)
{
is
(
Glean
.
cookieBannersClick
.
result
[
label
]
.
testGetValue
(
)
expectedValue
Counter
for
label
'
{
label
}
'
has
correct
state
.
)
;
}
else
if
(
Glean
.
cookieBannersClick
.
result
[
label
]
.
testGetValue
(
)
!
=
=
expectedValue
)
{
return
false
;
}
}
return
true
;
}
;
try
{
await
TestUtils
.
waitForCondition
(
testMetricState
"
Waiting
for
cookieBannersClick
.
result
metric
to
match
.
"
)
;
}
finally
{
testMetricState
(
true
)
;
if
(
resetFOG
)
{
await
Services
.
fog
.
testFlushAllChildren
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
}
}
}
async
function
runEventTest
(
{
mode
detectOnly
initFn
triggerFn
testURL
}
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
cookiebanners
.
service
.
mode
"
mode
]
[
"
cookiebanners
.
service
.
mode
.
privateBrowsing
"
Ci
.
nsICookieBannerService
.
MODE_DISABLED
]
[
"
cookiebanners
.
service
.
detectOnly
"
detectOnly
]
]
}
)
;
await
initFn
(
)
;
let
expectEventDetected
=
mode
!
=
Ci
.
nsICookieBannerService
.
MODE_DISABLED
;
let
expectEventHandled
=
!
detectOnly
&
&
(
mode
=
=
Ci
.
nsICookieBannerService
.
MODE_REJECT
|
|
mode
=
=
Ci
.
nsICookieBannerService
.
MODE_REJECT_OR_ACCEPT
)
;
let
eventObservedDetected
=
false
;
let
eventObservedHandled
=
false
;
let
promiseEventDetected
=
BrowserTestUtils
.
waitForEvent
(
window
"
cookiebannerdetected
"
false
(
)
=
>
{
eventObservedDetected
=
true
;
return
true
;
}
)
;
let
promiseEventHandled
=
BrowserTestUtils
.
waitForEvent
(
window
"
cookiebannerhandled
"
false
(
)
=
>
{
eventObservedHandled
=
true
;
return
true
;
}
)
;
let
firstEventPromise
;
if
(
expectEventDetected
|
|
expectEventHandled
)
{
firstEventPromise
=
Promise
.
race
(
[
promiseEventHandled
promiseEventDetected
]
)
;
}
await
triggerFn
(
)
;
let
eventDetected
;
if
(
expectEventDetected
)
{
eventDetected
=
await
promiseEventDetected
;
is
(
eventDetected
.
type
"
cookiebannerdetected
"
"
Should
dispatch
cookiebannerdetected
event
.
"
)
;
}
let
eventHandled
;
if
(
expectEventHandled
)
{
eventHandled
=
await
promiseEventHandled
;
is
(
eventHandled
.
type
"
cookiebannerhandled
"
"
Should
dispatch
cookiebannerhandled
event
.
"
)
;
}
let
eventsToTest
=
[
eventDetected
eventHandled
]
.
filter
(
event
=
>
!
!
event
)
;
for
(
let
event
of
eventsToTest
)
{
info
(
Testing
properties
of
event
{
event
.
type
}
)
;
let
{
windowContext
}
=
event
.
detail
;
ok
(
windowContext
Event
{
event
.
type
}
detail
should
contain
a
WindowContext
)
;
let
browser
=
windowContext
.
browsingContext
.
top
.
embedderElement
;
ok
(
browser
"
WindowContext
should
have
an
associated
top
embedder
element
.
"
)
;
is
(
browser
.
tagName
"
browser
"
"
The
top
embedder
element
should
be
a
browser
"
)
;
let
chromeWin
=
browser
.
ownerGlobal
;
is
(
chromeWin
window
"
The
chrome
window
associated
with
the
browser
should
match
the
window
where
the
cookie
banner
was
handled
.
"
)
;
is
(
chromeWin
.
gBrowser
.
selectedBrowser
browser
"
The
browser
associated
with
the
event
should
be
the
selected
browser
.
"
)
;
is
(
browser
.
currentURI
.
spec
testURL
"
The
browser
'
s
URI
spec
should
match
the
cookie
banner
test
page
.
"
)
;
}
let
firstEvent
=
await
firstEventPromise
;
is
(
expectEventDetected
|
|
expectEventHandled
!
!
firstEvent
"
Should
have
observed
the
first
event
if
banner
clicking
is
enabled
.
"
)
;
if
(
expectEventDetected
|
|
expectEventHandled
)
{
is
(
firstEvent
.
type
"
cookiebannerdetected
"
"
Detected
event
should
be
dispatched
first
"
)
;
}
is
(
eventObservedDetected
expectEventDetected
Should
{
expectEventDetected
?
"
"
:
"
not
"
}
have
observed
'
cookiebannerdetected
'
event
for
mode
{
mode
}
)
;
is
(
eventObservedHandled
expectEventHandled
Should
{
expectEventHandled
?
"
"
:
"
not
"
}
have
observed
'
cookiebannerhandled
'
event
for
mode
{
mode
}
)
;
for
(
let
eventType
of
[
"
cookiebannerdetected
"
"
cookiebannerhandled
"
]
)
{
let
event
=
new
CustomEvent
(
eventType
{
bubbles
:
true
cancelable
:
false
}
)
;
window
.
windowUtils
.
dispatchEventToChromeOnly
(
window
event
)
;
}
await
promiseEventDetected
;
await
promiseEventHandled
;
}
