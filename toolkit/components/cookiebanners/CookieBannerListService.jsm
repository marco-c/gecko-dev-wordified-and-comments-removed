"
use
strict
"
;
const
lazy
=
{
}
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
RemoteSettings
"
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
DEFAULT_EXPIRY_RELATIVE
"
"
cookiebanners
.
cookieInjector
.
defaultExpiryRelative
"
)
;
const
COLLECTION_NAME
=
"
cookie
-
banner
-
rules
-
list
"
;
let
logConsole
;
function
log
(
.
.
.
args
)
{
if
(
!
logConsole
)
{
logConsole
=
console
.
createInstance
(
{
prefix
:
"
*
*
CookieBannerListService
.
jsm
"
maxLogLevelPref
:
"
cookiebanners
.
listService
.
logLevel
"
}
)
;
}
logConsole
.
log
(
.
.
.
args
)
;
}
class
CookieBannerListService
{
classId
=
Components
.
ID
(
"
{
1d8d9470
-
97d3
-
4885
-
a108
-
44a5c4fb36e2
}
"
)
;
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsICookieBannerListService
"
]
)
;
#
rs
=
null
;
#
onSyncCallback
=
null
;
constructor
(
)
{
this
.
#
rs
=
lazy
.
RemoteSettings
(
COLLECTION_NAME
)
;
}
init
(
)
{
log
(
"
init
"
)
;
if
(
!
this
.
#
onSyncCallback
)
{
this
.
#
onSyncCallback
=
this
.
onSync
.
bind
(
this
)
;
this
.
#
rs
.
on
(
"
sync
"
this
.
#
onSyncCallback
)
;
}
return
this
.
importAllRules
(
)
;
}
async
importAllRules
(
)
{
log
(
"
importAllRules
"
)
;
let
rules
=
await
this
.
#
rs
.
get
(
)
;
this
.
#
importRules
(
rules
)
;
}
shutdown
(
)
{
log
(
"
shutdown
"
)
;
if
(
this
.
#
onSyncCallback
)
{
this
.
#
rs
.
off
(
"
sync
"
this
.
#
onSyncCallback
)
;
this
.
#
onSyncCallback
=
null
;
}
}
onSync
(
{
data
:
{
created
updated
deleted
}
}
)
{
log
(
"
onSync
"
{
created
updated
deleted
}
)
;
this
.
removeRules
(
deleted
)
;
this
.
#
importRules
(
created
.
concat
(
updated
.
map
(
u
=
>
u
.
new
)
)
)
;
}
removeRules
(
rules
=
[
]
)
{
log
(
"
removeRules
"
rules
)
;
rules
.
map
(
rule
=
>
rule
.
domain
)
.
forEach
(
Services
.
cookieBanners
.
removeRuleForDomain
)
;
}
#
importRules
(
rules
)
{
log
(
"
importRules
"
rules
)
;
rules
.
forEach
(
(
{
domain
cookies
click
}
)
=
>
{
let
rule
=
Cc
[
"
mozilla
.
org
/
cookie
-
banner
-
rule
;
1
"
]
.
createInstance
(
Ci
.
nsICookieBannerRule
)
;
rule
.
domain
=
domain
;
this
.
#
importCookieRule
(
rule
cookies
)
;
this
.
#
importClickRule
(
rule
click
)
;
Services
.
cookieBanners
.
insertRule
(
rule
)
;
}
)
;
}
#
importCookieRule
(
rule
cookies
)
{
if
(
!
cookies
)
{
return
;
}
for
(
let
category
of
[
"
optOut
"
"
optIn
"
]
)
{
if
(
!
cookies
[
category
]
)
{
continue
;
}
let
isOptOut
=
category
=
=
"
optOut
"
;
for
(
let
c
of
cookies
[
category
]
)
{
let
{
expiryRelative
}
=
c
;
if
(
expiryRelative
=
=
null
|
|
expiryRelative
<
=
0
)
{
expiryRelative
=
lazy
.
DEFAULT_EXPIRY_RELATIVE
;
}
rule
.
addCookie
(
isOptOut
c
.
name
c
.
value
c
.
host
|
|
.
{
rule
.
domain
}
c
.
path
|
|
"
/
"
expiryRelative
c
.
unsetValue
c
.
isSecure
c
.
isHTTPOnly
c
.
isSession
?
?
true
c
.
sameSite
c
.
schemeMap
)
;
}
}
}
#
importClickRule
(
rule
click
)
{
if
(
!
click
)
{
return
;
}
rule
.
addClickRule
(
click
.
presence
click
.
hide
click
.
optOut
click
.
optIn
)
;
}
}
var
EXPORTED_SYMBOLS
=
[
"
CookieBannerListService
"
]
;
