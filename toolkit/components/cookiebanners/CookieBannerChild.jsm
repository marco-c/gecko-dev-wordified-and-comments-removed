"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
CookieBannerChild
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
observeTimeout
"
"
cookiebanners
.
bannerClicking
.
timeout
"
3000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
testing
"
"
cookiebanners
.
bannerClicking
.
testing
"
false
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logConsole
"
(
)
=
>
{
return
console
.
createInstance
(
{
prefix
:
"
CookieBannerChild
"
maxLogLevelPref
:
"
cookiebanners
.
bannerClicking
.
logLevel
"
}
)
;
}
)
;
class
CookieBannerChild
extends
JSWindowActorChild
{
#
clickRules
;
#
originalBannerDisplay
=
null
;
#
observerCleanUp
;
async
handleEvent
(
event
)
{
if
(
event
.
type
!
=
"
DOMContentLoaded
"
)
{
return
;
}
let
principal
=
this
.
document
?
.
nodePrincipal
;
if
(
!
principal
?
.
isContentPrincipal
)
{
return
;
}
if
(
!
principal
.
schemeIs
(
"
http
"
)
&
&
!
principal
.
schemeIs
(
"
https
"
)
)
{
return
;
}
lazy
.
logConsole
.
debug
(
Send
message
to
get
rule
for
{
principal
.
baseDomain
}
)
;
let
rules
;
try
{
rules
=
await
this
.
sendQuery
(
"
CookieBanner
:
:
GetClickRules
"
{
}
)
;
}
catch
(
e
)
{
lazy
.
logConsole
.
warn
(
"
Failed
to
get
click
rule
from
parent
.
"
)
;
return
;
}
lazy
.
logConsole
.
debug
(
"
Got
rules
:
"
rules
)
;
if
(
!
rules
.
length
)
{
this
.
#
maybeSendTestMessage
(
)
;
return
;
}
this
.
#
clickRules
=
rules
;
await
this
.
handleCookieBanner
(
)
;
this
.
#
maybeSendTestMessage
(
)
;
}
didDestroy
(
)
{
this
.
#
observerCleanUp
?
.
(
)
;
}
async
handleCookieBanner
(
)
{
lazy
.
logConsole
.
debug
(
"
handleCookieBanner
"
this
.
document
?
.
location
.
href
)
;
let
rules
=
await
this
.
#
detectBanner
(
)
;
if
(
!
rules
.
length
)
{
return
;
}
let
matchedRule
=
this
.
#
hideBanner
(
rules
)
;
let
successClick
=
false
;
try
{
successClick
=
await
this
.
#
clickTarget
(
rules
)
;
}
finally
{
if
(
!
successClick
)
{
this
.
#
showBanner
(
matchedRule
)
;
}
}
if
(
successClick
)
{
lazy
.
logConsole
.
info
(
"
Handled
cookie
banner
.
"
{
url
:
this
.
document
?
.
location
.
href
rule
:
matchedRule
}
)
;
}
}
#
promiseObserve
(
checkFn
timeout
)
{
if
(
this
.
#
observerCleanUp
)
{
throw
new
Error
(
"
The
promiseObserve
is
called
before
previous
one
resolves
.
"
)
;
}
return
new
Promise
(
resolve
=
>
{
let
win
=
this
.
contentWindow
;
let
timer
;
let
observer
=
new
win
.
MutationObserver
(
mutationList
=
>
{
lazy
.
logConsole
.
debug
(
"
#
promiseObserve
:
Mutation
observed
"
mutationList
)
;
let
result
=
checkFn
?
.
(
)
;
if
(
result
)
{
cleanup
(
result
observer
timer
)
;
}
}
)
;
timer
=
lazy
.
setTimeout
(
(
)
=
>
{
lazy
.
logConsole
.
debug
(
"
#
promiseObserve
:
timeout
"
)
;
cleanup
(
null
observer
)
;
}
timeout
)
;
observer
.
observe
(
win
.
document
.
body
{
attributes
:
true
subtree
:
true
childList
:
true
}
)
;
let
cleanup
=
(
result
observer
timer
)
=
>
{
lazy
.
logConsole
.
debug
(
"
#
promiseObserve
cleanup
"
result
observer
timer
)
;
if
(
observer
)
{
observer
.
disconnect
(
)
;
observer
=
null
;
}
if
(
timer
)
{
lazy
.
clearTimeout
(
timer
)
;
}
this
.
#
observerCleanUp
=
null
;
resolve
(
result
)
;
}
;
this
.
#
observerCleanUp
=
(
)
=
>
{
cleanup
(
null
observer
timer
)
;
}
;
}
)
;
}
async
#
detectBanner
(
)
{
if
(
!
this
.
#
clickRules
?
.
length
)
{
return
[
]
;
}
lazy
.
logConsole
.
debug
(
"
Starting
to
detect
the
banner
"
)
;
let
presenceDetector
=
(
)
=
>
{
lazy
.
logConsole
.
debug
(
"
presenceDetector
start
"
)
;
let
matchingRules
=
this
.
#
clickRules
.
filter
(
rule
=
>
{
let
{
presence
}
=
rule
;
let
banner
=
this
.
document
.
querySelector
(
presence
)
;
lazy
.
logConsole
.
debug
(
"
Testing
banner
el
presence
"
{
result
:
banner
rule
presence
}
)
;
if
(
!
banner
)
{
return
false
;
}
return
this
.
#
isVisible
(
banner
)
;
}
)
;
if
(
!
matchingRules
.
length
)
{
return
null
;
}
return
matchingRules
;
}
;
lazy
.
logConsole
.
debug
(
"
Initial
call
to
presenceDetector
"
)
;
let
rules
=
presenceDetector
(
)
;
if
(
!
rules
?
.
length
)
{
lazy
.
logConsole
.
debug
(
"
Initial
presenceDetector
failed
registering
MutationObserver
"
rules
)
;
rules
=
await
this
.
#
promiseObserve
(
presenceDetector
lazy
.
observeTimeout
)
;
}
if
(
!
rules
?
.
length
)
{
lazy
.
logConsole
.
debug
(
"
Couldn
'
t
detect
the
banner
"
rules
)
;
return
[
]
;
}
lazy
.
logConsole
.
debug
(
"
Detected
the
banner
for
rules
"
rules
)
;
return
rules
;
}
async
#
clickTarget
(
rules
)
{
lazy
.
logConsole
.
debug
(
"
Starting
to
detect
the
target
button
"
)
;
let
targetEl
;
for
(
let
rule
of
rules
)
{
targetEl
=
this
.
document
.
querySelector
(
rule
.
target
)
;
if
(
targetEl
)
{
break
;
}
}
if
(
!
targetEl
)
{
targetEl
=
await
this
.
#
promiseObserve
(
(
)
=
>
{
for
(
let
rule
of
rules
)
{
let
el
=
this
.
document
.
querySelector
(
rule
.
target
)
;
lazy
.
logConsole
.
debug
(
"
Testing
button
el
presence
"
{
result
:
el
rule
target
:
rule
.
target
}
)
;
if
(
el
)
{
lazy
.
logConsole
.
debug
(
"
Found
button
from
rule
"
rule
rule
.
target
el
)
;
return
el
;
}
}
return
null
;
}
lazy
.
observeTimeout
)
;
if
(
!
targetEl
)
{
lazy
.
logConsole
.
debug
(
"
Cannot
find
the
target
button
.
"
)
;
return
false
;
}
}
lazy
.
logConsole
.
debug
(
"
Found
the
target
button
click
it
.
"
targetEl
)
;
targetEl
.
click
(
)
;
return
true
;
}
#
isVisible
(
element
)
{
return
element
.
checkVisibility
(
{
checkOpacity
:
true
checkVisibilityCSS
:
true
}
)
;
}
#
hideBanner
(
rules
)
{
if
(
this
.
#
originalBannerDisplay
)
{
return
null
;
}
let
banner
;
let
rule
;
for
(
let
r
of
rules
)
{
banner
=
this
.
document
.
querySelector
(
r
.
hide
)
;
if
(
banner
)
{
rule
=
r
;
break
;
}
}
if
(
!
banner
)
{
lazy
.
logConsole
.
debug
(
"
Failed
to
find
banner
element
to
hide
from
rules
.
"
rules
)
;
return
null
;
}
lazy
.
logConsole
.
debug
(
"
Found
banner
element
to
hide
from
rules
.
"
rules
)
;
this
.
#
originalBannerDisplay
=
banner
.
style
.
display
;
banner
.
ownerGlobal
.
requestAnimationFrame
(
(
)
=
>
{
banner
.
style
.
display
=
"
none
"
;
}
)
;
return
rule
;
}
#
showBanner
(
{
hide
}
)
{
if
(
this
.
#
originalBannerDisplay
=
=
=
null
)
{
return
;
}
let
banner
=
this
.
document
.
querySelector
(
hide
)
;
let
originalDisplay
=
this
.
#
originalBannerDisplay
;
this
.
#
originalBannerDisplay
=
null
;
banner
.
ownerGlobal
.
requestAnimationFrame
(
(
)
=
>
{
banner
.
style
.
display
=
originalDisplay
;
}
)
;
}
#
maybeSendTestMessage
(
)
{
if
(
lazy
.
testing
)
{
let
win
=
this
.
contentWindow
;
win
.
requestAnimationFrame
(
(
)
=
>
{
win
.
setTimeout
(
(
)
=
>
{
this
.
sendAsyncMessage
(
"
CookieBanner
:
:
Test
-
FinishClicking
"
)
;
}
0
)
;
}
)
;
}
}
}
