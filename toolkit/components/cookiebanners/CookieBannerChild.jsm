"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
CookieBannerChild
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
observeTimeout
"
"
cookiebanners
.
bannerClicking
.
timeout
"
3000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
testing
"
"
cookiebanners
.
bannerClicking
.
testing
"
false
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logConsole
"
(
)
=
>
{
return
console
.
createInstance
(
{
prefix
:
"
CookieBannerChild
"
maxLogLevelPref
:
"
cookiebanners
.
bannerClicking
.
logLevel
"
}
)
;
}
)
;
class
CookieBannerChild
extends
JSWindowActorChild
{
#
clickRule
;
#
originalBannerDisplay
=
null
;
#
observerCleanUp
;
async
handleEvent
(
event
)
{
if
(
event
.
type
!
=
"
DOMContentLoaded
"
)
{
return
;
}
let
principal
=
this
.
document
?
.
nodePrincipal
;
if
(
!
principal
?
.
isContentPrincipal
)
{
return
;
}
if
(
!
principal
.
schemeIs
(
"
http
"
)
&
&
!
principal
.
schemeIs
(
"
https
"
)
)
{
return
;
}
let
domain
=
principal
.
baseDomain
;
if
(
!
domain
)
{
return
;
}
lazy
.
logConsole
.
debug
(
Send
message
to
get
rule
for
{
domain
}
)
;
let
rule
;
try
{
rule
=
await
this
.
sendQuery
(
"
CookieBanner
:
:
GetClickRule
"
{
domain
}
)
;
}
catch
(
e
)
{
lazy
.
logConsole
.
warn
(
"
Failed
to
get
click
rule
from
parent
.
"
)
;
}
lazy
.
logConsole
.
debug
(
"
Got
rule
:
"
rule
)
;
if
(
!
rule
?
.
target
)
{
this
.
#
maybeSendTestMessage
(
)
;
return
;
}
this
.
#
clickRule
=
rule
;
await
this
.
handleCookieBanner
(
)
;
this
.
#
maybeSendTestMessage
(
)
;
}
didDestroy
(
)
{
this
.
#
observerCleanUp
?
.
(
)
;
}
async
handleCookieBanner
(
)
{
let
bannerFound
=
await
this
.
#
detectBanner
(
)
;
if
(
!
bannerFound
)
{
return
;
}
this
.
#
hideBanner
(
)
;
let
successClick
=
false
;
try
{
successClick
=
await
this
.
#
clickTarget
(
)
;
}
finally
{
if
(
!
successClick
)
{
this
.
#
showBanner
(
)
;
}
}
}
#
promiseObserve
(
checkFn
timeout
)
{
if
(
this
.
#
observerCleanUp
)
{
throw
new
Error
(
"
The
promiseObserve
is
called
before
previous
one
resolves
.
"
)
;
}
return
new
Promise
(
resolve
=
>
{
let
win
=
this
.
contentWindow
;
let
timer
;
let
observer
=
new
win
.
MutationObserver
(
(
)
=
>
{
if
(
checkFn
?
.
(
)
)
{
cleanup
(
true
observer
timer
)
;
}
}
)
;
timer
=
lazy
.
setTimeout
(
(
)
=
>
{
cleanup
(
false
observer
)
;
}
timeout
)
;
observer
.
observe
(
win
.
document
.
body
{
attributes
:
true
subtree
:
true
childList
:
true
}
)
;
let
cleanup
=
(
result
observer
timer
)
=
>
{
if
(
observer
)
{
observer
.
disconnect
(
)
;
observer
=
null
;
}
if
(
timer
)
{
lazy
.
clearTimeout
(
timer
)
;
}
this
.
#
observerCleanUp
=
null
;
resolve
(
result
)
;
}
;
this
.
#
observerCleanUp
=
(
)
=
>
{
cleanup
(
false
observer
timer
)
;
}
;
}
)
;
}
async
#
detectBanner
(
)
{
if
(
!
this
.
#
clickRule
)
{
return
false
;
}
lazy
.
logConsole
.
debug
(
"
Starting
to
detect
the
banner
"
)
;
let
detector
=
(
)
=
>
{
let
banner
=
this
.
document
.
querySelector
(
this
.
#
clickRule
.
presence
)
;
return
banner
&
&
this
.
#
isVisible
(
banner
)
;
}
;
let
found
=
detector
(
)
;
if
(
!
found
&
&
!
(
await
this
.
#
promiseObserve
(
detector
lazy
.
observeTimeout
)
)
)
{
lazy
.
logConsole
.
debug
(
"
Couldn
'
t
detect
the
banner
"
)
;
return
false
;
}
lazy
.
logConsole
.
debug
(
"
Detected
the
banner
"
)
;
return
true
;
}
async
#
clickTarget
(
)
{
if
(
!
this
.
#
clickRule
)
{
return
false
;
}
lazy
.
logConsole
.
debug
(
"
Starting
to
detect
the
target
button
"
)
;
let
target
=
this
.
document
.
querySelector
(
this
.
#
clickRule
.
target
)
;
if
(
!
target
)
{
await
this
.
#
promiseObserve
(
(
)
=
>
{
target
=
this
.
document
.
querySelector
(
this
.
#
clickRule
.
target
)
;
return
!
!
target
;
}
lazy
.
observeTimeout
)
;
if
(
!
target
)
{
lazy
.
logConsole
.
debug
(
"
Cannot
find
the
target
button
.
"
)
;
return
false
;
}
}
lazy
.
logConsole
.
debug
(
"
Found
the
target
button
click
it
.
"
)
;
target
.
click
(
)
;
return
true
;
}
#
isVisible
(
element
)
{
return
element
.
checkVisibility
(
{
checkOpacity
:
true
checkVisibilityCSS
:
true
}
)
;
}
#
hideBanner
(
)
{
let
banner
=
this
.
document
.
querySelector
(
this
.
#
clickRule
.
hide
)
;
if
(
this
.
#
originalBannerDisplay
)
{
return
;
}
this
.
#
originalBannerDisplay
=
banner
.
style
.
display
;
banner
.
ownerGlobal
.
requestAnimationFrame
(
(
)
=
>
{
banner
.
style
.
display
=
"
none
"
;
}
)
;
}
#
showBanner
(
)
{
if
(
this
.
#
originalBannerDisplay
=
=
=
null
)
{
return
;
}
let
banner
=
this
.
document
.
querySelector
(
this
.
#
clickRule
.
hide
)
;
let
originalDisplay
=
this
.
#
originalBannerDisplay
;
this
.
#
originalBannerDisplay
=
null
;
banner
.
ownerGlobal
.
requestAnimationFrame
(
(
)
=
>
{
banner
.
style
.
display
=
originalDisplay
;
}
)
;
}
#
maybeSendTestMessage
(
)
{
if
(
lazy
.
testing
)
{
let
win
=
this
.
contentWindow
;
win
.
requestAnimationFrame
(
(
)
=
>
{
win
.
setTimeout
(
(
)
=
>
{
this
.
sendAsyncMessage
(
"
CookieBanner
:
:
Test
-
FinishClicking
"
)
;
}
0
)
;
}
)
;
}
}
}
