"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
CookieBannerChild
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
serviceMode
"
"
cookiebanners
.
service
.
mode
"
Ci
.
nsICookieBannerService
.
MODE_DISABLED
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
serviceModePBM
"
"
cookiebanners
.
service
.
mode
.
privateBrowsing
"
Ci
.
nsICookieBannerService
.
MODE_DISABLED
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
bannerClickingEnabled
"
"
cookiebanners
.
bannerClicking
.
enabled
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
observeTimeout
"
"
cookiebanners
.
bannerClicking
.
timeout
"
3000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
testing
"
"
cookiebanners
.
bannerClicking
.
testing
"
false
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logConsole
"
(
)
=
>
{
return
console
.
createInstance
(
{
prefix
:
"
CookieBannerChild
"
maxLogLevelPref
:
"
cookiebanners
.
bannerClicking
.
logLevel
"
}
)
;
}
)
;
class
CookieBannerChild
extends
JSWindowActorChild
{
#
clickRules
;
#
originalBannerDisplay
=
null
;
#
observerCleanUp
;
#
observerCleanUpTimer
;
#
didLoad
=
false
;
#
telemetryStatus
=
{
currentStage
:
null
success
:
false
successStage
:
null
failReason
:
null
bannerVisibilityFail
:
false
}
;
#
gleanBannerHandlingTimer
=
null
;
handleEvent
(
event
)
{
if
(
!
this
.
#
isEnabled
)
{
this
.
#
maybeSendTestMessage
(
)
;
return
;
}
switch
(
event
.
type
)
{
case
"
DOMContentLoaded
"
:
this
.
#
onDOMContentLoaded
(
)
;
break
;
case
"
load
"
:
this
.
#
onLoad
(
)
;
break
;
default
:
lazy
.
logConsole
.
warn
(
Unexpected
event
{
event
.
type
}
.
event
)
;
}
}
get
#
isPrivateBrowsing
(
)
{
return
lazy
.
PrivateBrowsingUtils
.
isContentWindowPrivate
(
this
.
contentWindow
)
;
}
get
#
isEnabled
(
)
{
if
(
!
lazy
.
bannerClickingEnabled
)
{
return
false
;
}
if
(
this
.
#
isPrivateBrowsing
)
{
return
lazy
.
serviceModePBM
!
=
Ci
.
nsICookieBannerService
.
MODE_DISABLED
;
}
return
lazy
.
serviceMode
!
=
Ci
.
nsICookieBannerService
.
MODE_DISABLED
;
}
get
#
isDetectOnly
(
)
{
if
(
!
this
.
#
isEnabled
)
{
return
false
;
}
if
(
this
.
#
isPrivateBrowsing
)
{
return
lazy
.
serviceModePBM
=
=
Ci
.
nsICookieBannerService
.
MODE_DETECT_ONLY
;
}
return
lazy
.
serviceMode
=
=
Ci
.
nsICookieBannerService
.
MODE_DETECT_ONLY
;
}
async
#
onDOMContentLoaded
(
)
{
lazy
.
logConsole
.
debug
(
"
onDOMContentLoaded
"
{
didLoad
:
this
.
#
didLoad
}
)
;
this
.
#
didLoad
=
false
;
this
.
#
telemetryStatus
.
currentStage
=
"
dom_content_loaded
"
;
let
principal
=
this
.
document
?
.
nodePrincipal
;
if
(
!
principal
?
.
isContentPrincipal
)
{
return
;
}
if
(
!
principal
.
schemeIs
(
"
http
"
)
&
&
!
principal
.
schemeIs
(
"
https
"
)
)
{
return
;
}
lazy
.
logConsole
.
debug
(
"
Send
message
to
get
rule
"
{
baseDomain
:
principal
.
baseDomain
isTopLevel
:
this
.
browsingContext
=
=
this
.
browsingContext
?
.
top
}
)
;
let
rules
;
try
{
rules
=
await
this
.
sendQuery
(
"
CookieBanner
:
:
GetClickRules
"
{
}
)
;
}
catch
(
e
)
{
lazy
.
logConsole
.
warn
(
"
Failed
to
get
click
rule
from
parent
.
"
e
)
;
return
;
}
lazy
.
logConsole
.
debug
(
"
Got
rules
:
"
rules
)
;
if
(
!
rules
.
length
)
{
this
.
#
maybeSendTestMessage
(
)
;
return
;
}
this
.
#
clickRules
=
rules
;
if
(
!
this
.
#
isDetectOnly
)
{
this
.
#
gleanBannerHandlingTimer
=
Glean
.
cookieBannersClick
.
handleDuration
.
start
(
)
;
}
let
{
bannerHandled
bannerDetected
matchedRule
}
=
await
this
.
handleCookieBanner
(
)
;
if
(
bannerDetected
)
{
lazy
.
logConsole
.
info
(
"
Detected
cookie
banner
.
"
{
url
:
this
.
document
?
.
location
.
href
}
)
;
this
.
sendAsyncMessage
(
"
CookieBanner
:
:
DetectedBanner
"
)
;
}
if
(
bannerHandled
)
{
lazy
.
logConsole
.
info
(
"
Handled
cookie
banner
.
"
{
url
:
this
.
document
?
.
location
.
href
rule
:
matchedRule
}
)
;
lazy
.
logConsole
.
debug
(
"
Telemetry
timer
:
stop
and
accumulate
"
this
.
#
gleanBannerHandlingTimer
)
;
Glean
.
cookieBannersClick
.
handleDuration
.
stopAndAccumulate
(
this
.
#
gleanBannerHandlingTimer
)
;
this
.
sendAsyncMessage
(
"
CookieBanner
:
:
HandledBanner
"
)
;
}
else
if
(
!
this
.
#
isDetectOnly
)
{
Glean
.
cookieBannersClick
.
handleDuration
.
cancel
(
this
.
#
gleanBannerHandlingTimer
)
;
}
this
.
#
maybeSendTestMessage
(
)
;
}
#
onLoad
(
)
{
this
.
#
didLoad
=
true
;
if
(
!
this
.
#
clickRules
?
.
length
)
{
return
;
}
lazy
.
logConsole
.
debug
(
"
Observed
'
load
'
event
"
{
href
:
this
.
document
?
.
location
.
href
hasActiveObserver
:
!
!
this
.
#
observerCleanUp
observerCleanupTimer
:
this
.
#
observerCleanUpTimer
}
)
;
if
(
!
this
.
#
telemetryStatus
.
success
)
{
this
.
#
telemetryStatus
.
currentStage
=
"
mutation_post_load
"
;
}
this
.
#
startObserverCleanupTimer
(
)
;
}
#
startObserverCleanupTimer
(
)
{
if
(
!
this
.
#
observerCleanUp
|
|
this
.
#
observerCleanUpTimer
)
{
return
;
}
lazy
.
logConsole
.
debug
(
"
Starting
MutationObserver
cleanup
timeout
"
)
;
this
.
#
observerCleanUpTimer
=
lazy
.
setTimeout
(
(
)
=
>
{
lazy
.
logConsole
.
debug
(
MutationObserver
timeout
after
{
lazy
.
observeTimeout
}
ms
.
)
;
this
.
#
observerCleanUp
(
)
;
}
lazy
.
observeTimeout
)
;
}
didDestroy
(
)
{
this
.
#
reportTelemetry
(
)
;
this
.
#
observerCleanUp
?
.
(
)
;
}
#
reportTelemetry
(
)
{
if
(
this
.
#
telemetryStatus
.
currentStage
=
=
null
|
|
!
this
.
#
clickRules
?
.
length
)
{
lazy
.
logConsole
.
debug
(
"
Skip
clickResult
telemetry
"
this
.
#
telemetryStatus
this
.
#
clickRules
)
;
return
;
}
let
{
success
successStage
currentStage
failReason
}
=
this
.
#
telemetryStatus
;
if
(
this
.
#
observerCleanUp
&
&
!
success
)
{
failReason
=
"
actor_destroyed
"
;
}
let
status
reason
;
if
(
success
)
{
status
=
"
success
"
;
reason
=
successStage
;
}
else
{
status
=
"
fail
"
;
reason
=
failReason
;
}
Glean
.
cookieBannersClick
.
result
[
status
]
.
add
(
1
)
;
if
(
reason
)
{
Glean
.
cookieBannersClick
.
result
[
{
status
}
_
{
reason
}
]
.
add
(
1
)
;
}
else
{
lazy
.
logConsole
.
debug
(
"
Could
not
determine
success
/
fail
reason
for
telemetry
.
"
)
;
}
lazy
.
logConsole
.
debug
(
"
Submitted
clickResult
telemetry
"
status
reason
{
success
successStage
currentStage
failReason
}
)
;
}
async
handleCookieBanner
(
)
{
lazy
.
logConsole
.
debug
(
"
handleCookieBanner
"
this
.
document
?
.
location
.
href
)
;
let
rules
=
await
this
.
#
detectBanner
(
)
;
if
(
!
rules
.
length
)
{
this
.
#
telemetryStatus
.
success
=
false
;
if
(
this
.
#
telemetryStatus
.
bannerVisibilityFail
)
{
this
.
#
telemetryStatus
.
failReason
=
"
banner_not_visible
"
;
}
else
{
this
.
#
telemetryStatus
.
failReason
=
"
banner_not_found
"
;
}
return
{
bannerHandled
:
false
bannerDetected
:
false
}
;
}
if
(
rules
.
every
(
rule
=
>
rule
.
target
=
=
null
)
)
{
this
.
#
telemetryStatus
.
success
=
false
;
this
.
#
telemetryStatus
.
failReason
=
"
no_rule_for_mode
"
;
return
{
bannerHandled
:
false
bannerDetected
:
false
}
;
}
if
(
this
.
#
isDetectOnly
)
{
return
{
bannerHandled
:
false
bannerDetected
:
true
}
;
}
let
matchedRule
=
this
.
#
hideBanner
(
rules
)
;
let
successClick
=
false
;
try
{
successClick
=
await
this
.
#
clickTarget
(
rules
)
;
}
finally
{
if
(
!
successClick
)
{
this
.
#
showBanner
(
matchedRule
)
;
}
}
if
(
successClick
)
{
this
.
#
telemetryStatus
.
successStage
=
this
.
#
telemetryStatus
.
currentStage
;
}
else
{
this
.
#
telemetryStatus
.
failReason
=
"
button_not_found
"
;
this
.
#
telemetryStatus
.
successStage
=
null
;
}
this
.
#
telemetryStatus
.
success
=
successClick
;
return
{
bannerHandled
:
successClick
bannerDetected
:
true
matchedRule
}
;
}
#
promiseObserve
(
checkFn
)
{
if
(
this
.
#
observerCleanUp
)
{
throw
new
Error
(
"
The
promiseObserve
is
called
before
previous
one
resolves
.
"
)
;
}
lazy
.
logConsole
.
debug
(
"
#
promiseObserve
"
{
didLoad
:
this
.
#
didLoad
}
)
;
return
new
Promise
(
resolve
=
>
{
let
win
=
this
.
contentWindow
;
let
observer
=
new
win
.
MutationObserver
(
mutationList
=
>
{
lazy
.
logConsole
.
debug
(
"
#
promiseObserve
:
Mutation
observed
"
mutationList
)
;
let
result
=
checkFn
?
.
(
)
;
if
(
result
)
{
cleanup
(
result
observer
)
;
}
}
)
;
observer
.
observe
(
win
.
document
.
body
{
attributes
:
true
subtree
:
true
childList
:
true
}
)
;
let
cleanup
=
(
result
observer
)
=
>
{
lazy
.
logConsole
.
debug
(
"
#
promiseObserve
cleanup
"
result
observer
this
.
#
observerCleanUpTimer
)
;
if
(
observer
)
{
observer
.
disconnect
(
)
;
observer
=
null
;
}
if
(
this
.
#
observerCleanUpTimer
)
{
lazy
.
clearTimeout
(
this
.
#
observerCleanUpTimer
)
;
}
this
.
#
observerCleanUp
=
null
;
resolve
(
result
)
;
}
;
this
.
#
observerCleanUp
=
(
)
=
>
{
cleanup
(
null
observer
)
;
}
;
if
(
this
.
#
didLoad
)
{
this
.
#
startObserverCleanupTimer
(
)
;
}
}
)
;
}
async
#
detectBanner
(
)
{
if
(
!
this
.
#
clickRules
?
.
length
)
{
return
[
]
;
}
lazy
.
logConsole
.
debug
(
"
Starting
to
detect
the
banner
"
)
;
let
presenceDetector
=
(
)
=
>
{
lazy
.
logConsole
.
debug
(
"
presenceDetector
start
"
)
;
let
matchingRules
=
this
.
#
clickRules
.
filter
(
rule
=
>
{
let
{
presence
skipPresenceVisibilityCheck
}
=
rule
;
let
banner
=
this
.
document
.
querySelector
(
presence
)
;
lazy
.
logConsole
.
debug
(
"
Testing
banner
el
presence
"
{
result
:
banner
rule
presence
}
)
;
if
(
!
banner
)
{
return
false
;
}
if
(
skipPresenceVisibilityCheck
)
{
return
true
;
}
let
isVisible
=
this
.
#
isVisible
(
banner
)
;
this
.
#
telemetryStatus
.
bannerVisibilityFail
=
!
isVisible
;
return
isVisible
;
}
)
;
if
(
!
matchingRules
.
length
)
{
return
null
;
}
return
matchingRules
;
}
;
lazy
.
logConsole
.
debug
(
"
Initial
call
to
presenceDetector
"
)
;
let
rules
=
presenceDetector
(
)
;
if
(
!
rules
?
.
length
)
{
lazy
.
logConsole
.
debug
(
"
Initial
presenceDetector
failed
registering
MutationObserver
"
rules
)
;
this
.
#
telemetryStatus
.
currentStage
=
"
mutation_pre_load
"
;
rules
=
await
this
.
#
promiseObserve
(
presenceDetector
lazy
.
observeTimeout
)
;
}
if
(
!
rules
?
.
length
)
{
lazy
.
logConsole
.
debug
(
"
Couldn
'
t
detect
the
banner
"
rules
)
;
return
[
]
;
}
lazy
.
logConsole
.
debug
(
"
Detected
the
banner
for
rules
"
rules
)
;
return
rules
;
}
async
#
clickTarget
(
rules
)
{
lazy
.
logConsole
.
debug
(
"
Starting
to
detect
the
target
button
"
)
;
let
targetEl
;
for
(
let
rule
of
rules
)
{
targetEl
=
this
.
document
.
querySelector
(
rule
.
target
)
;
if
(
targetEl
)
{
break
;
}
}
if
(
!
targetEl
)
{
targetEl
=
await
this
.
#
promiseObserve
(
(
)
=
>
{
for
(
let
rule
of
rules
)
{
let
el
=
this
.
document
.
querySelector
(
rule
.
target
)
;
lazy
.
logConsole
.
debug
(
"
Testing
button
el
presence
"
{
result
:
el
rule
target
:
rule
.
target
}
)
;
if
(
el
)
{
lazy
.
logConsole
.
debug
(
"
Found
button
from
rule
"
rule
rule
.
target
el
)
;
return
el
;
}
}
return
null
;
}
lazy
.
observeTimeout
)
;
if
(
!
targetEl
)
{
lazy
.
logConsole
.
debug
(
"
Cannot
find
the
target
button
.
"
)
;
return
false
;
}
}
lazy
.
logConsole
.
debug
(
"
Found
the
target
button
click
it
.
"
targetEl
)
;
targetEl
.
click
(
)
;
return
true
;
}
#
isVisible
(
element
)
{
return
element
.
checkVisibility
(
{
checkOpacity
:
true
checkVisibilityCSS
:
true
}
)
;
}
#
hideBanner
(
rules
)
{
if
(
this
.
#
originalBannerDisplay
)
{
return
null
;
}
let
banner
;
let
rule
;
for
(
let
r
of
rules
)
{
banner
=
this
.
document
.
querySelector
(
r
.
hide
)
;
if
(
banner
)
{
rule
=
r
;
break
;
}
}
if
(
!
banner
)
{
lazy
.
logConsole
.
debug
(
"
Failed
to
find
banner
element
to
hide
from
rules
.
"
rules
)
;
return
null
;
}
lazy
.
logConsole
.
debug
(
"
Found
banner
element
to
hide
from
rules
.
"
rules
)
;
this
.
#
originalBannerDisplay
=
banner
.
style
.
display
;
banner
.
ownerGlobal
.
requestAnimationFrame
(
(
)
=
>
{
banner
.
style
.
display
=
"
none
"
;
}
)
;
return
rule
;
}
#
showBanner
(
{
hide
}
)
{
if
(
this
.
#
originalBannerDisplay
=
=
=
null
)
{
return
;
}
let
banner
=
this
.
document
.
querySelector
(
hide
)
;
if
(
!
banner
|
|
Cu
.
isDeadWrapper
(
banner
)
|
|
!
banner
.
ownerGlobal
)
{
return
;
}
let
originalDisplay
=
this
.
#
originalBannerDisplay
;
this
.
#
originalBannerDisplay
=
null
;
banner
.
ownerGlobal
.
requestAnimationFrame
(
(
)
=
>
{
banner
.
style
.
display
=
originalDisplay
;
}
)
;
}
#
maybeSendTestMessage
(
)
{
if
(
lazy
.
testing
)
{
let
win
=
this
.
contentWindow
;
win
.
requestAnimationFrame
(
(
)
=
>
{
win
.
setTimeout
(
(
)
=
>
{
this
.
sendAsyncMessage
(
"
CookieBanner
:
:
Test
-
FinishClicking
"
)
;
}
0
)
;
}
)
;
}
}
}
