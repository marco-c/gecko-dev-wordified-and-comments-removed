"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
CookieBannerParent
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
serviceMode
"
"
cookiebanners
.
service
.
mode
"
Ci
.
nsICookieBannerService
.
MODE_DISABLED
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
serviceModePBM
"
"
cookiebanners
.
service
.
mode
.
privateBrowsing
"
Ci
.
nsICookieBannerService
.
MODE_DISABLED
)
;
class
CookieBannerParent
extends
JSWindowActorParent
{
#
isPrivateBrowsing
(
)
{
let
topBC
=
this
.
browsingContext
.
top
;
if
(
topBC
.
embedderElementType
!
=
"
browser
"
|
|
!
topBC
.
embedderElement
)
{
return
false
;
}
return
lazy
.
PrivateBrowsingUtils
.
isBrowserPrivate
(
topBC
.
embedderElement
)
;
}
async
receiveMessage
(
message
)
{
if
(
message
.
name
=
=
"
CookieBanner
:
:
Test
-
FinishClicking
"
)
{
Services
.
obs
.
notifyObservers
(
null
"
cookie
-
banner
-
test
-
clicking
-
finish
"
this
.
manager
.
documentPrincipal
?
.
baseDomain
)
;
return
undefined
;
}
if
(
message
.
name
!
=
"
CookieBanner
:
:
GetClickRules
"
)
{
return
undefined
;
}
let
mode
;
let
isPrivateBrowsing
=
this
.
#
isPrivateBrowsing
(
)
;
if
(
isPrivateBrowsing
)
{
mode
=
lazy
.
serviceModePBM
;
}
else
{
mode
=
lazy
.
serviceMode
;
}
let
topBrowsingContext
=
this
.
manager
.
browsingContext
.
top
;
let
topURI
=
topBrowsingContext
.
currentWindowGlobal
?
.
documentURI
;
if
(
mode
!
=
Ci
.
nsICookieBannerService
.
MODE_DISABLED
&
&
topURI
)
{
try
{
let
perDomainMode
=
Services
.
cookieBanners
.
getDomainPref
(
topURI
isPrivateBrowsing
)
;
if
(
perDomainMode
!
=
Ci
.
nsICookieBannerService
.
MODE_UNSET
)
{
mode
=
perDomainMode
;
}
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_NOT_AVAILABLE
)
{
Cu
.
reportError
(
"
The
cookie
banner
handling
service
is
not
available
"
)
;
}
else
{
Cu
.
reportError
(
"
Fail
on
getting
domain
pref
:
"
+
e
)
;
}
}
}
if
(
mode
=
=
Ci
.
nsICookieBannerService
.
MODE_DISABLED
)
{
return
[
]
;
}
let
domain
=
this
.
manager
.
documentPrincipal
?
.
baseDomain
;
if
(
!
domain
)
{
return
[
]
;
}
let
rules
=
Services
.
cookieBanners
.
getClickRulesForDomain
(
domain
)
;
if
(
!
rules
.
length
)
{
return
[
]
;
}
let
modeIsRejectOrAccept
=
mode
=
=
Ci
.
nsICookieBannerService
.
MODE_REJECT_OR_ACCEPT
;
return
rules
.
map
(
rule
=
>
{
let
target
=
rule
.
optOut
;
if
(
modeIsRejectOrAccept
&
&
!
target
)
{
target
=
rule
.
optIn
;
}
return
{
hide
:
rule
.
hide
?
?
rule
.
presence
presence
:
rule
.
presence
target
}
;
}
)
;
}
}
