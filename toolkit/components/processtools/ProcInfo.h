#
ifndef
__mozilla_ProcInfo_h
#
define
__mozilla_ProcInfo_h
#
include
<
base
/
process
.
h
>
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
ChromeUtilsBinding
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
GeckoChildProcessHost
;
}
enum
class
ProcType
{
Web
WebIsolated
File
Extension
PrivilegedAbout
PrivilegedMozilla
WebLargeAllocation
WebCOOPCOEP
Browser
IPDLUnitTest
GMPlugin
GPU
VR
RDD
Socket
RemoteSandboxBroker
#
ifdef
MOZ_ENABLE_FORKSERVER
ForkServer
#
endif
Preallocated
Unknown
Max
=
Unknown
}
;
struct
ThreadInfo
{
base
:
:
ProcessId
tid
=
0
;
nsString
name
;
uint64_t
cpuUser
=
0
;
uint64_t
cpuKernel
=
0
;
uint64_t
cpuCycleCount
=
0
;
}
;
struct
WindowInfo
{
explicit
WindowInfo
(
)
:
outerWindowId
(
0
)
documentURI
(
nullptr
)
documentTitle
(
u
"
"
_ns
)
isProcessRoot
(
false
)
isInProcess
(
false
)
{
}
WindowInfo
(
uint64_t
aOuterWindowId
nsIURI
*
aDocumentURI
nsAString
&
&
aDocumentTitle
bool
aIsProcessRoot
bool
aIsInProcess
)
:
outerWindowId
(
aOuterWindowId
)
documentURI
(
aDocumentURI
)
documentTitle
(
std
:
:
move
(
aDocumentTitle
)
)
isProcessRoot
(
aIsProcessRoot
)
isInProcess
(
aIsInProcess
)
{
}
const
uint64_t
outerWindowId
;
const
nsCOMPtr
<
nsIURI
>
documentURI
;
const
nsString
documentTitle
;
const
bool
isProcessRoot
;
const
bool
isInProcess
;
}
;
struct
ProcInfo
{
base
:
:
ProcessId
pid
=
0
;
dom
:
:
ContentParentId
childId
;
ProcType
type
;
nsCString
origin
;
nsString
filename
;
uint64_t
memory
=
0
;
uint64_t
cpuUser
=
0
;
uint64_t
cpuKernel
=
0
;
uint64_t
cpuCycleCount
=
0
;
CopyableTArray
<
ThreadInfo
>
threads
;
CopyableTArray
<
WindowInfo
>
windows
;
}
;
typedef
MozPromise
<
mozilla
:
:
HashMap
<
base
:
:
ProcessId
ProcInfo
>
nsresult
true
>
ProcInfoPromise
;
struct
ProcInfoRequest
{
ProcInfoRequest
(
base
:
:
ProcessId
aPid
ProcType
aProcessType
const
nsACString
&
aOrigin
nsTArray
<
WindowInfo
>
&
&
aWindowInfo
uint32_t
aChildId
=
0
#
ifdef
XP_MACOSX
mach_port_t
aChildTask
=
0
#
endif
)
:
pid
(
aPid
)
processType
(
aProcessType
)
origin
(
aOrigin
)
windowInfo
(
std
:
:
move
(
aWindowInfo
)
)
childId
(
aChildId
)
#
ifdef
XP_MACOSX
childTask
(
aChildTask
)
#
endif
{
}
const
base
:
:
ProcessId
pid
;
const
ProcType
processType
;
const
nsCString
origin
;
const
nsTArray
<
WindowInfo
>
windowInfo
;
const
int32_t
childId
;
#
ifdef
XP_MACOSX
const
mach_port_t
childTask
;
#
endif
}
;
RefPtr
<
ProcInfoPromise
>
GetProcInfo
(
nsTArray
<
ProcInfoRequest
>
&
&
aRequests
)
;
template
<
typename
T
>
nsresult
CopySysProcInfoToDOM
(
const
ProcInfo
&
source
T
*
dest
)
{
dest
-
>
mPid
=
source
.
pid
;
dest
-
>
mFilename
.
Assign
(
source
.
filename
)
;
dest
-
>
mMemory
=
source
.
memory
;
dest
-
>
mCpuUser
=
source
.
cpuUser
;
dest
-
>
mCpuKernel
=
source
.
cpuKernel
;
dest
-
>
mCpuCycleCount
=
source
.
cpuCycleCount
;
mozilla
:
:
dom
:
:
Sequence
<
mozilla
:
:
dom
:
:
ThreadInfoDictionary
>
threads
;
for
(
const
ThreadInfo
&
entry
:
source
.
threads
)
{
mozilla
:
:
dom
:
:
ThreadInfoDictionary
*
thread
=
threads
.
AppendElement
(
fallible
)
;
if
(
NS_WARN_IF
(
!
thread
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
thread
-
>
mCpuUser
=
entry
.
cpuUser
;
thread
-
>
mCpuKernel
=
entry
.
cpuKernel
;
thread
-
>
mCpuCycleCount
=
entry
.
cpuCycleCount
;
thread
-
>
mTid
=
entry
.
tid
;
thread
-
>
mName
.
Assign
(
entry
.
name
)
;
}
dest
-
>
mThreads
=
std
:
:
move
(
threads
)
;
return
NS_OK
;
}
}
#
endif
