#
include
"
mozilla
/
ProcInfo
.
h
"
#
include
"
mozilla
/
ipc
/
GeckoChildProcessHost
.
h
"
#
include
"
mozilla
/
SSE
.
h
"
#
include
"
gfxWindowsPlatform
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
<
windows
.
h
>
#
include
<
psapi
.
h
>
#
include
<
tlhelp32
.
h
>
#
define
PR_USEC_PER_NSEC
1000L
typedef
HRESULT
(
WINAPI
*
GETTHREADDESCRIPTION
)
(
HANDLE
hThread
PWSTR
*
threadDescription
)
;
namespace
mozilla
{
static
uint64_t
ToNanoSeconds
(
const
FILETIME
&
aFileTime
)
{
ULARGE_INTEGER
usec
=
{
{
aFileTime
.
dwLowDateTime
aFileTime
.
dwHighDateTime
}
}
;
return
usec
.
QuadPart
*
100
;
}
static
int
GetCycleTimeFrequency
(
)
{
static
int
result
=
-
1
;
if
(
result
!
=
-
1
)
{
return
result
;
}
result
=
0
;
if
(
!
mozilla
:
:
has_constant_tsc
(
)
)
{
return
result
;
}
HKEY
key
;
static
const
WCHAR
keyName
[
]
=
L
"
HARDWARE
\
\
DESCRIPTION
\
\
System
\
\
CentralProcessor
\
\
0
"
;
if
(
RegOpenKeyEx
(
HKEY_LOCAL_MACHINE
keyName
0
KEY_QUERY_VALUE
&
key
)
=
=
ERROR_SUCCESS
)
{
DWORD
data
len
;
len
=
sizeof
(
data
)
;
if
(
RegQueryValueEx
(
key
L
"
~
Mhz
"
0
0
reinterpret_cast
<
LPBYTE
>
(
&
data
)
&
len
)
=
=
ERROR_SUCCESS
)
{
result
=
static_cast
<
int
>
(
data
)
;
}
}
return
result
;
}
nsresult
GetCpuTimeSinceProcessStartInMs
(
uint64_t
*
aResult
)
{
FILETIME
createTime
exitTime
kernelTime
userTime
;
int
frequencyInMHz
=
GetCycleTimeFrequency
(
)
;
if
(
frequencyInMHz
)
{
uint64_t
cpuCycleCount
;
if
(
!
QueryProcessCycleTime
(
:
:
GetCurrentProcess
(
)
&
cpuCycleCount
)
)
{
return
NS_ERROR_FAILURE
;
}
constexpr
int
HZ_PER_MHZ
=
1000000
;
*
aResult
=
cpuCycleCount
/
(
frequencyInMHz
*
(
HZ_PER_MHZ
/
PR_MSEC_PER_SEC
)
)
;
return
NS_OK
;
}
if
(
!
GetProcessTimes
(
:
:
GetCurrentProcess
(
)
&
createTime
&
exitTime
&
kernelTime
&
userTime
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aResult
=
(
ToNanoSeconds
(
kernelTime
)
+
ToNanoSeconds
(
userTime
)
)
/
PR_NSEC_PER_MSEC
;
return
NS_OK
;
}
nsresult
GetGpuTimeSinceProcessStartInMs
(
uint64_t
*
aResult
)
{
return
gfxWindowsPlatform
:
:
GetGpuTimeSinceProcessStartInMs
(
aResult
)
;
}
ProcInfoPromise
:
:
ResolveOrRejectValue
GetProcInfoSync
(
nsTArray
<
ProcInfoRequest
>
&
&
aRequests
)
{
ProcInfoPromise
:
:
ResolveOrRejectValue
result
;
HashMap
<
base
:
:
ProcessId
ProcInfo
>
gathered
;
if
(
!
gathered
.
reserve
(
aRequests
.
Length
(
)
)
)
{
result
.
SetReject
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
result
;
}
int
frequencyInMHz
=
GetCycleTimeFrequency
(
)
;
for
(
const
auto
&
request
:
aRequests
)
{
nsAutoHandle
handle
(
OpenProcess
(
PROCESS_QUERY_INFORMATION
|
PROCESS_VM_READ
FALSE
request
.
pid
)
)
;
if
(
!
handle
)
{
continue
;
}
uint64_t
cpuCycleTime
;
if
(
!
QueryProcessCycleTime
(
handle
.
get
(
)
&
cpuCycleTime
)
)
{
continue
;
}
uint64_t
cpuTime
;
if
(
frequencyInMHz
)
{
cpuTime
=
cpuCycleTime
*
PR_USEC_PER_NSEC
/
frequencyInMHz
;
}
else
{
FILETIME
createTime
exitTime
kernelTime
userTime
;
if
(
!
GetProcessTimes
(
handle
.
get
(
)
&
createTime
&
exitTime
&
kernelTime
&
userTime
)
)
{
continue
;
}
cpuTime
=
ToNanoSeconds
(
kernelTime
)
+
ToNanoSeconds
(
userTime
)
;
}
PROCESS_MEMORY_COUNTERS_EX
memoryCounters
;
if
(
!
GetProcessMemoryInfo
(
handle
.
get
(
)
(
PPROCESS_MEMORY_COUNTERS
)
&
memoryCounters
sizeof
(
memoryCounters
)
)
)
{
continue
;
}
ProcInfo
info
;
info
.
pid
=
request
.
pid
;
info
.
childId
=
request
.
childId
;
info
.
type
=
request
.
processType
;
info
.
origin
=
request
.
origin
;
info
.
windows
=
std
:
:
move
(
request
.
windowInfo
)
;
info
.
cpuTime
=
cpuTime
;
info
.
cpuCycleCount
=
cpuCycleTime
;
info
.
memory
=
memoryCounters
.
PrivateUsage
;
if
(
!
gathered
.
put
(
request
.
pid
std
:
:
move
(
info
)
)
)
{
result
.
SetReject
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
result
;
}
}
nsAutoHandle
hThreadSnap
(
CreateToolhelp32Snapshot
(
TH32CS_SNAPTHREAD
0
)
)
;
if
(
!
hThreadSnap
)
{
result
.
SetReject
(
NS_ERROR_UNEXPECTED
)
;
return
result
;
}
auto
getThreadDescription
=
reinterpret_cast
<
GETTHREADDESCRIPTION
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandleW
(
L
"
Kernel32
.
dll
"
)
"
GetThreadDescription
"
)
)
;
THREADENTRY32
te32
;
te32
.
dwSize
=
sizeof
(
THREADENTRY32
)
;
for
(
auto
success
=
Thread32First
(
hThreadSnap
.
get
(
)
&
te32
)
;
success
;
success
=
Thread32Next
(
hThreadSnap
.
get
(
)
&
te32
)
)
{
auto
processLookup
=
gathered
.
lookup
(
te32
.
th32OwnerProcessID
)
;
if
(
!
processLookup
)
{
continue
;
}
ThreadInfo
*
threadInfo
=
processLookup
-
>
value
(
)
.
threads
.
AppendElement
(
fallible
)
;
if
(
!
threadInfo
)
{
result
.
SetReject
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
result
;
}
nsAutoHandle
hThread
(
OpenThread
(
THREAD_QUERY_INFORMATION
FALSE
te32
.
th32ThreadID
)
)
;
if
(
!
hThread
)
{
processLookup
-
>
value
(
)
.
threads
.
RemoveLastElement
(
)
;
continue
;
}
threadInfo
-
>
tid
=
te32
.
th32ThreadID
;
if
(
QueryThreadCycleTime
(
hThread
.
get
(
)
&
threadInfo
-
>
cpuCycleCount
)
&
&
frequencyInMHz
)
{
threadInfo
-
>
cpuTime
=
threadInfo
-
>
cpuCycleCount
*
PR_USEC_PER_NSEC
/
frequencyInMHz
;
}
else
{
FILETIME
createTime
exitTime
kernelTime
userTime
;
if
(
GetThreadTimes
(
hThread
.
get
(
)
&
createTime
&
exitTime
&
kernelTime
&
userTime
)
)
{
threadInfo
-
>
cpuTime
=
ToNanoSeconds
(
kernelTime
)
+
ToNanoSeconds
(
userTime
)
;
}
}
if
(
getThreadDescription
)
{
PWSTR
threadName
=
nullptr
;
if
(
getThreadDescription
(
hThread
.
get
(
)
&
threadName
)
&
&
threadName
)
{
threadInfo
-
>
name
=
threadName
;
}
if
(
threadName
)
{
LocalFree
(
threadName
)
;
}
}
}
result
.
SetResolve
(
std
:
:
move
(
gathered
)
)
;
return
result
;
}
RefPtr
<
ProcInfoPromise
>
GetProcInfo
(
nsTArray
<
ProcInfoRequest
>
&
&
aRequests
)
{
auto
holder
=
MakeUnique
<
MozPromiseHolder
<
ProcInfoPromise
>
>
(
)
;
RefPtr
<
ProcInfoPromise
>
promise
=
holder
-
>
Ensure
(
__func__
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
get
stream
transport
service
"
)
;
holder
-
>
Reject
(
rv
__func__
)
;
return
promise
;
}
RefPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
holder
=
std
:
:
move
(
holder
)
requests
=
std
:
:
move
(
aRequests
)
]
(
)
mutable
-
>
void
{
holder
-
>
ResolveOrReject
(
GetProcInfoSync
(
std
:
:
move
(
requests
)
)
__func__
)
;
}
)
;
rv
=
target
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
the
LoadDataRunnable
.
"
)
;
}
return
promise
;
}
}
