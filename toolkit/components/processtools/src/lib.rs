#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
extern
crate
libc
;
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
extern
crate
log
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
extern
crate
winapi
;
extern
crate
nserror
;
extern
crate
xpcom
;
use
std
:
:
convert
:
:
TryInto
;
use
nserror
:
:
{
nsresult
NS_ERROR_FAILURE
NS_ERROR_NOT_AVAILABLE
NS_OK
}
;
use
xpcom
:
:
{
interfaces
:
:
nsIProcessToolsService
xpcom
xpcom_method
RefPtr
}
;
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
use
log
:
:
error
;
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
use
nserror
:
:
{
NS_ERROR_CANNOT_CONVERT_DATA
NS_ERROR_UNEXPECTED
}
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
struct
Handle
(
winapi
:
:
um
:
:
winnt
:
:
HANDLE
)
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
impl
Handle
{
fn
from_raw
(
raw
:
winapi
:
:
um
:
:
winnt
:
:
HANDLE
)
-
>
Option
<
Self
>
{
(
raw
!
=
std
:
:
ptr
:
:
null_mut
(
)
&
&
raw
!
=
winapi
:
:
um
:
:
handleapi
:
:
INVALID_HANDLE_VALUE
)
.
then_some
(
Handle
(
raw
)
)
}
fn
raw
(
self
:
&
Self
)
-
>
winapi
:
:
um
:
:
winnt
:
:
HANDLE
{
self
.
0
}
}
#
[
cfg
(
target_os
=
"
windows
"
)
]
impl
Drop
for
Handle
{
fn
drop
(
&
mut
self
)
{
unsafe
{
winapi
:
:
um
:
:
handleapi
:
:
CloseHandle
(
self
.
raw
(
)
)
;
}
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
new_process_tools_service
(
result
:
*
mut
*
const
nsIProcessToolsService
)
{
let
service
:
RefPtr
<
ProcessToolsService
>
=
ProcessToolsService
:
:
new
(
)
;
RefPtr
:
:
new
(
service
.
coerce
:
:
<
nsIProcessToolsService
>
(
)
)
.
forget
(
&
mut
*
result
)
;
}
#
[
xpcom
(
implement
(
nsIProcessToolsService
)
atomic
)
]
pub
struct
ProcessToolsService
{
}
impl
ProcessToolsService
{
pub
fn
new
(
)
-
>
RefPtr
<
ProcessToolsService
>
{
ProcessToolsService
:
:
allocate
(
InitProcessToolsService
{
}
)
}
xpcom_method
!
(
kill
=
>
Kill
(
id
:
u64
)
)
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
pub
fn
kill
(
&
self
pid
:
u64
)
-
>
Result
<
(
)
nsresult
>
{
let
handle
=
unsafe
{
winapi
:
:
um
:
:
processthreadsapi
:
:
OpenProcess
(
winapi
:
:
um
:
:
winnt
:
:
PROCESS_TERMINATE
|
winapi
:
:
um
:
:
winnt
:
:
SYNCHRONIZE
0
pid
.
try_into
(
)
.
unwrap
(
)
)
}
;
let
handle
=
Handle
:
:
from_raw
(
handle
)
.
ok_or
(
NS_ERROR_NOT_AVAILABLE
)
?
;
let
result
=
unsafe
{
winapi
:
:
um
:
:
processthreadsapi
:
:
TerminateProcess
(
handle
.
raw
(
)
0
)
}
;
if
result
=
=
0
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
Ok
(
(
)
)
}
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
fn
do_kill
(
&
self
pid
:
u64
signal
:
i32
)
-
>
Result
<
(
)
nsresult
>
{
let
pid
=
pid
.
try_into
(
)
.
or
(
Err
(
NS_ERROR_CANNOT_CONVERT_DATA
)
)
?
;
let
result
=
unsafe
{
libc
:
:
kill
(
pid
signal
)
}
;
if
result
=
=
0
{
Ok
(
(
)
)
}
else
{
match
std
:
:
io
:
:
Error
:
:
last_os_error
(
)
.
raw_os_error
(
)
{
Some
(
libc
:
:
ESRCH
)
=
>
Err
(
NS_ERROR_NOT_AVAILABLE
)
Some
(
errno_value
)
=
>
{
error
!
(
"
kill
(
{
}
)
failed
:
errno
=
{
}
"
pid
errno_value
)
;
Err
(
NS_ERROR_FAILURE
)
}
None
=
>
Err
(
NS_ERROR_UNEXPECTED
)
}
}
}
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
pub
fn
kill
(
&
self
pid
:
u64
)
-
>
Result
<
(
)
nsresult
>
{
self
.
do_kill
(
pid
libc
:
:
SIGKILL
)
}
xpcom_method
!
(
crash
=
>
Crash
(
id
:
u64
)
)
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
pub
fn
crash
(
&
self
pid
:
u64
)
-
>
Result
<
(
)
nsresult
>
{
let
ntdll
=
unsafe
{
winapi
:
:
um
:
:
libloaderapi
:
:
GetModuleHandleA
(
std
:
:
mem
:
:
transmute
(
b
"
ntdll
.
dll
\
0
"
.
as_ptr
(
)
)
)
}
;
if
ntdll
.
is_null
(
)
{
return
Err
(
NS_ERROR_NOT_AVAILABLE
)
;
}
let
dbg_break_point
=
unsafe
{
winapi
:
:
um
:
:
libloaderapi
:
:
GetProcAddress
(
ntdll
std
:
:
mem
:
:
transmute
(
b
"
DbgBreakPoint
\
0
"
.
as_ptr
(
)
)
)
}
;
if
dbg_break_point
.
is_null
(
)
{
return
Err
(
NS_ERROR_NOT_AVAILABLE
)
;
}
let
target_proc
=
unsafe
{
winapi
:
:
um
:
:
processthreadsapi
:
:
OpenProcess
(
winapi
:
:
um
:
:
winnt
:
:
PROCESS_VM_OPERATION
|
winapi
:
:
um
:
:
winnt
:
:
PROCESS_CREATE_THREAD
|
winapi
:
:
um
:
:
winnt
:
:
PROCESS_QUERY_INFORMATION
0
pid
.
try_into
(
)
.
unwrap
(
)
)
}
;
let
target_proc
=
Handle
:
:
from_raw
(
target_proc
)
.
ok_or
(
NS_ERROR_NOT_AVAILABLE
)
?
;
let
new_thread
=
unsafe
{
winapi
:
:
um
:
:
processthreadsapi
:
:
CreateRemoteThread
(
target_proc
.
raw
(
)
std
:
:
ptr
:
:
null_mut
(
)
0
Some
(
std
:
:
mem
:
:
transmute
(
dbg_break_point
)
)
std
:
:
ptr
:
:
null_mut
(
)
0
std
:
:
ptr
:
:
null_mut
(
)
)
}
;
let
new_thread
=
Handle
:
:
from_raw
(
new_thread
)
.
ok_or
(
NS_ERROR_FAILURE
)
?
;
unsafe
{
winapi
:
:
um
:
:
synchapi
:
:
WaitForSingleObject
(
new_thread
.
raw
(
)
winapi
:
:
um
:
:
winbase
:
:
INFINITE
)
;
}
Ok
(
(
)
)
}
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
pub
fn
crash
(
&
self
pid
:
u64
)
-
>
Result
<
(
)
nsresult
>
{
self
.
do_kill
(
pid
libc
:
:
SIGABRT
)
}
xpcom_method
!
(
get_pid
=
>
GetPid
(
)
-
>
u64
)
;
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
pub
fn
get_pid
(
&
self
)
-
>
Result
<
u64
nsresult
>
{
let
pid
=
unsafe
{
libc
:
:
getpid
(
)
}
as
u64
;
Ok
(
pid
)
}
#
[
cfg
(
target_os
=
"
windows
"
)
]
pub
fn
get_pid
(
&
self
)
-
>
Result
<
u64
nsresult
>
{
let
pid
=
unsafe
{
winapi
:
:
um
:
:
processthreadsapi
:
:
GetCurrentProcessId
(
)
}
as
u64
;
Ok
(
pid
)
}
}
