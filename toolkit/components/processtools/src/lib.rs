#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
extern
crate
libc
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
extern
crate
winapi
;
extern
crate
nserror
;
extern
crate
xpcom
;
use
std
:
:
convert
:
:
TryInto
;
use
nserror
:
:
{
nsresult
NS_ERROR_FAILURE
NS_ERROR_NOT_AVAILABLE
NS_OK
}
;
use
xpcom
:
:
{
interfaces
:
:
nsIProcessToolsService
xpcom
xpcom_method
RefPtr
}
;
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
new_process_tools_service
(
result
:
*
mut
*
const
nsIProcessToolsService
)
{
let
service
:
RefPtr
<
ProcessToolsService
>
=
ProcessToolsService
:
:
new
(
)
;
RefPtr
:
:
new
(
service
.
coerce
:
:
<
nsIProcessToolsService
>
(
)
)
.
forget
(
&
mut
*
result
)
;
}
#
[
derive
(
xpcom
)
]
#
[
refcnt
=
"
atomic
"
]
#
[
xpimplements
(
nsIProcessToolsService
)
]
pub
struct
InitProcessToolsService
{
}
impl
ProcessToolsService
{
pub
fn
new
(
)
-
>
RefPtr
<
ProcessToolsService
>
{
ProcessToolsService
:
:
allocate
(
InitProcessToolsService
{
}
)
}
xpcom_method
!
(
kill
=
>
Kill
(
id
:
u64
)
)
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
pub
fn
kill
(
&
self
pid
:
u64
)
-
>
Result
<
(
)
nsresult
>
{
let
handle
=
unsafe
{
winapi
:
:
um
:
:
processthreadsapi
:
:
OpenProcess
(
winapi
:
:
um
:
:
winnt
:
:
PROCESS_TERMINATE
|
winapi
:
:
um
:
:
winnt
:
:
SYNCHRONIZE
0
pid
.
try_into
(
)
.
unwrap
(
)
)
}
;
if
handle
.
is_null
(
)
{
return
Err
(
NS_ERROR_NOT_AVAILABLE
)
;
}
let
result
=
unsafe
{
winapi
:
:
um
:
:
processthreadsapi
:
:
TerminateProcess
(
handle
0
)
}
;
let
_
=
unsafe
{
winapi
:
:
um
:
:
handleapi
:
:
CloseHandle
(
handle
)
}
;
if
result
=
=
0
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
Ok
(
(
)
)
}
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
pub
fn
kill
(
&
self
pid
:
u64
)
-
>
Result
<
(
)
nsresult
>
{
let
pid
=
pid
.
try_into
(
)
.
or
(
Err
(
NS_ERROR_FAILURE
)
)
?
;
let
result
=
unsafe
{
libc
:
:
kill
(
pid
libc
:
:
SIGKILL
)
}
;
if
result
=
=
0
{
Ok
(
(
)
)
}
else
{
Err
(
NS_ERROR_FAILURE
)
}
}
xpcom_method
!
(
get_pid
=
>
GetPid
(
)
-
>
u64
)
;
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
pub
fn
get_pid
(
&
self
)
-
>
Result
<
u64
nsresult
>
{
let
pid
=
unsafe
{
libc
:
:
getpid
(
)
}
as
u64
;
Ok
(
pid
)
}
#
[
cfg
(
target_os
=
"
windows
"
)
]
pub
fn
get_pid
(
&
self
)
-
>
Result
<
u64
nsresult
>
{
let
pid
=
unsafe
{
winapi
:
:
um
:
:
processthreadsapi
:
:
GetCurrentProcessId
(
)
}
as
u64
;
Ok
(
pid
)
}
}
