#
include
"
mozilla
/
ProcInfo
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
ipc
/
GeckoChildProcessHost
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
<
cstdio
>
#
include
<
cstring
>
#
include
<
unistd
.
h
>
#
include
<
libproc
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
include
<
mach
/
mach
.
h
>
namespace
mozilla
{
nsresult
GetCpuTimeSinceProcessStartInMs
(
uint64_t
*
aResult
)
{
struct
proc_taskinfo
pti
;
if
(
(
unsigned
long
)
proc_pidinfo
(
getpid
(
)
PROC_PIDTASKINFO
0
&
pti
PROC_PIDTASKINFO_SIZE
)
<
PROC_PIDTASKINFO_SIZE
)
{
return
NS_ERROR_FAILURE
;
}
*
aResult
=
(
pti
.
pti_total_user
+
pti
.
pti_total_system
)
/
PR_NSEC_PER_MSEC
;
return
NS_OK
;
}
nsresult
GetGpuTimeSinceProcessStartInMs
(
uint64_t
*
aResult
)
{
task_power_info_v2_data_t
task_power_info
;
mach_msg_type_number_t
count
=
TASK_POWER_INFO_V2_COUNT
;
kern_return_t
kr
=
task_info
(
mach_task_self
(
)
TASK_POWER_INFO_V2
(
task_info_t
)
&
task_power_info
&
count
)
;
if
(
kr
!
=
KERN_SUCCESS
)
{
return
NS_ERROR_FAILURE
;
}
*
aResult
=
task_power_info
.
gpu_energy
.
task_gpu_utilisation
/
PR_NSEC_PER_MSEC
;
return
NS_OK
;
}
ProcInfoPromise
:
:
ResolveOrRejectValue
GetProcInfoSync
(
nsTArray
<
ProcInfoRequest
>
&
&
aRequests
)
{
ProcInfoPromise
:
:
ResolveOrRejectValue
result
;
HashMap
<
base
:
:
ProcessId
ProcInfo
>
gathered
;
if
(
!
gathered
.
reserve
(
aRequests
.
Length
(
)
)
)
{
result
.
SetReject
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
result
;
}
for
(
const
auto
&
request
:
aRequests
)
{
ProcInfo
info
;
info
.
pid
=
request
.
pid
;
info
.
childId
=
request
.
childId
;
info
.
type
=
request
.
processType
;
info
.
origin
=
std
:
:
move
(
request
.
origin
)
;
info
.
windows
=
std
:
:
move
(
request
.
windowInfo
)
;
struct
proc_taskinfo
pti
;
if
(
(
unsigned
long
)
proc_pidinfo
(
request
.
pid
PROC_PIDTASKINFO
0
&
pti
PROC_PIDTASKINFO_SIZE
)
<
PROC_PIDTASKINFO_SIZE
)
{
continue
;
}
info
.
cpuTime
=
pti
.
pti_total_user
+
pti
.
pti_total_system
;
mach_port_t
selectedTask
;
if
(
request
.
childTask
=
=
MACH_PORT_NULL
)
{
selectedTask
=
mach_task_self
(
)
;
}
else
{
selectedTask
=
request
.
childTask
;
}
task_vm_info_data_t
task_vm_info
;
mach_msg_type_number_t
count
=
TASK_VM_INFO_COUNT
;
kern_return_t
kr
=
task_info
(
selectedTask
TASK_VM_INFO
(
task_info_t
)
&
task_vm_info
&
count
)
;
info
.
memory
=
kr
=
=
KERN_SUCCESS
?
task_vm_info
.
phys_footprint
:
0
;
thread_act_port_array_t
threadList
;
mach_msg_type_number_t
threadCount
;
kern_return_t
kret
=
task_threads
(
selectedTask
&
threadList
&
threadCount
)
;
if
(
kret
!
=
KERN_SUCCESS
)
{
continue
;
}
auto
guardThreadCount
=
MakeScopeExit
(
[
&
]
{
if
(
threadList
=
=
nullptr
)
{
return
;
}
for
(
mach_msg_type_number_t
i
=
0
;
i
<
threadCount
;
i
+
+
)
{
mach_port_deallocate
(
mach_task_self
(
)
threadList
[
i
]
)
;
}
vm_deallocate
(
mach_task_self
(
)
(
vm_address_t
)
threadList
sizeof
(
thread_t
)
*
threadCount
)
;
}
)
;
for
(
mach_msg_type_number_t
i
=
0
;
i
<
threadCount
;
i
+
+
)
{
thread_extended_info_data_t
threadInfoData
;
count
=
THREAD_EXTENDED_INFO_COUNT
;
kret
=
thread_info
(
threadList
[
i
]
THREAD_EXTENDED_INFO
(
thread_info_t
)
&
threadInfoData
&
count
)
;
if
(
kret
!
=
KERN_SUCCESS
)
{
continue
;
}
thread_identifier_info
identifierInfo
;
count
=
THREAD_IDENTIFIER_INFO_COUNT
;
kret
=
thread_info
(
threadList
[
i
]
THREAD_IDENTIFIER_INFO
(
thread_info_t
)
&
identifierInfo
&
count
)
;
if
(
kret
!
=
KERN_SUCCESS
)
{
continue
;
}
ThreadInfo
*
thread
=
info
.
threads
.
AppendElement
(
fallible
)
;
if
(
!
thread
)
{
result
.
SetReject
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
result
;
}
thread
-
>
cpuTime
=
threadInfoData
.
pth_user_time
+
threadInfoData
.
pth_system_time
;
thread
-
>
name
.
AssignASCII
(
threadInfoData
.
pth_name
)
;
thread
-
>
tid
=
identifierInfo
.
thread_id
;
}
if
(
!
gathered
.
put
(
request
.
pid
std
:
:
move
(
info
)
)
)
{
result
.
SetReject
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
result
;
}
}
result
.
SetResolve
(
std
:
:
move
(
gathered
)
)
;
return
result
;
}
}
