#
include
<
shlobj
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
wtsapi32
.
h
>
#
include
<
userenv
.
h
>
#
include
<
shellapi
.
h
>
#
ifndef
__MINGW32__
#
pragma
comment
(
lib
"
wtsapi32
.
lib
"
)
#
pragma
comment
(
lib
"
userenv
.
lib
"
)
#
pragma
comment
(
lib
"
shlwapi
.
lib
"
)
#
pragma
comment
(
lib
"
ole32
.
lib
"
)
#
pragma
comment
(
lib
"
rpcrt4
.
lib
"
)
#
endif
#
include
"
mozilla
/
CmdLineAndEnvUtils
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
using
mozilla
:
:
UniquePtr
;
#
include
"
workmonitor
.
h
"
#
include
"
serviceinstall
.
h
"
#
include
"
servicebase
.
h
"
#
include
"
registrycertificates
.
h
"
#
include
"
uachelper
.
h
"
#
include
"
updatehelper
.
h
"
#
include
"
pathhash
.
h
"
#
include
"
updatererrors
.
h
"
#
include
"
commonupdatedir
.
h
"
static
const
int
TIME_TO_WAIT_ON_UPDATER
=
15
*
60
*
1000
;
BOOL
PathGetSiblingFilePath
(
LPWSTR
destinationBuffer
LPCWSTR
siblingFilePath
LPCWSTR
newFileName
)
;
BOOL
DoesFallbackKeyExist
(
)
;
static
BOOL
IsStatusApplying
(
LPCWSTR
patchDirPath
BOOL
&
isApplying
)
{
isApplying
=
FALSE
;
WCHAR
statusFilePath
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
!
GetSecureOutputFilePath
(
patchDirPath
L
"
.
status
"
statusFilePath
)
)
{
LOG_WARN
(
(
"
Could
not
get
path
for
the
secure
update
status
file
"
)
)
;
return
FALSE
;
}
nsAutoHandle
statusFile
(
CreateFileW
(
statusFilePath
GENERIC_READ
FILE_SHARE_READ
|
FILE_SHARE_WRITE
|
FILE_SHARE_DELETE
nullptr
OPEN_EXISTING
0
nullptr
)
)
;
if
(
INVALID_HANDLE_VALUE
=
=
statusFile
)
{
LOG_WARN
(
(
"
Could
not
open
update
.
status
file
"
)
)
;
return
FALSE
;
}
char
buf
[
32
]
=
{
0
}
;
DWORD
read
;
if
(
!
ReadFile
(
statusFile
buf
sizeof
(
buf
)
&
read
nullptr
)
)
{
LOG_WARN
(
(
"
Could
not
read
from
update
.
status
file
"
)
)
;
return
FALSE
;
}
const
char
kApplying
[
]
=
"
applying
"
;
isApplying
=
strncmp
(
buf
kApplying
sizeof
(
kApplying
)
-
1
)
=
=
0
;
return
TRUE
;
}
static
bool
IsUpdateBeingStaged
(
int
argc
LPWSTR
*
argv
)
{
return
(
argc
=
=
4
&
&
!
wcscmp
(
argv
[
3
]
L
"
-
1
"
)
)
|
|
(
argc
=
=
5
&
&
!
wcscmp
(
argv
[
4
]
L
"
-
1
"
)
)
;
}
static
bool
IsDigits
(
WCHAR
*
str
)
{
while
(
*
str
)
{
if
(
!
iswdigit
(
*
str
+
+
)
)
{
return
FALSE
;
}
}
return
TRUE
;
}
static
bool
IsOldCommandline
(
int
argc
LPWSTR
*
argv
)
{
return
(
argc
=
=
4
&
&
!
wcscmp
(
argv
[
3
]
L
"
-
1
"
)
)
|
|
(
argc
>
=
4
&
&
(
wcsstr
(
argv
[
3
]
L
"
/
replace
"
)
|
|
IsDigits
(
argv
[
3
]
)
)
)
;
}
static
BOOL
GetInstallationDir
(
int
argcTmp
LPWSTR
*
argvTmp
WCHAR
aResultDir
[
MAX_PATH
+
1
]
)
{
int
index
=
3
;
if
(
IsOldCommandline
(
argcTmp
argvTmp
)
)
{
index
=
2
;
}
if
(
argcTmp
<
index
)
{
return
FALSE
;
}
wcsncpy
(
aResultDir
argvTmp
[
2
]
MAX_PATH
)
;
WCHAR
*
backSlash
=
wcsrchr
(
aResultDir
L
'
\
\
'
)
;
if
(
backSlash
&
&
(
backSlash
[
1
]
=
=
L
'
\
0
'
)
)
{
*
backSlash
=
L
'
\
0
'
;
}
if
(
index
=
=
2
)
{
bool
backgroundUpdate
=
IsUpdateBeingStaged
(
argcTmp
argvTmp
)
;
bool
replaceRequest
=
(
argcTmp
>
=
4
&
&
wcsstr
(
argvTmp
[
3
]
L
"
/
replace
"
)
)
;
if
(
backgroundUpdate
|
|
replaceRequest
)
{
return
PathRemoveFileSpecW
(
aResultDir
)
;
}
}
return
TRUE
;
}
BOOL
StartUpdateProcess
(
int
argc
LPWSTR
*
argv
LPCWSTR
installDir
BOOL
&
processStarted
)
{
processStarted
=
FALSE
;
LOG
(
(
"
Starting
update
process
as
the
service
in
session
0
.
"
)
)
;
STARTUPINFOW
si
;
PROCESS_INFORMATION
pi
;
ZeroMemory
(
&
si
sizeof
(
si
)
)
;
ZeroMemory
(
&
pi
sizeof
(
pi
)
)
;
si
.
cb
=
sizeof
(
si
)
;
si
.
lpDesktop
=
const_cast
<
LPWSTR
>
(
L
"
winsta0
\
\
Default
"
)
;
auto
cmdLine
=
mozilla
:
:
MakeCommandLine
(
argc
argv
)
;
int
index
=
3
;
if
(
IsOldCommandline
(
argc
argv
)
)
{
index
=
2
;
}
if
(
argc
>
=
index
)
{
si
.
lpDesktop
=
const_cast
<
LPWSTR
>
(
L
"
"
)
;
si
.
dwFlags
|
=
STARTF_USESHOWWINDOW
;
si
.
wShowWindow
=
SW_HIDE
;
}
putenv
(
const_cast
<
char
*
>
(
"
MOZ_USING_SERVICE
=
1
"
)
)
;
LOG
(
(
"
Starting
service
with
cmdline
:
%
ls
"
cmdLine
.
get
(
)
)
)
;
processStarted
=
CreateProcessW
(
argv
[
0
]
cmdLine
.
get
(
)
nullptr
nullptr
FALSE
CREATE_DEFAULT_ERROR_MODE
nullptr
nullptr
&
si
&
pi
)
;
BOOL
updateWasSuccessful
=
FALSE
;
if
(
processStarted
)
{
BOOL
processTerminated
=
FALSE
;
BOOL
noProcessExitCode
=
FALSE
;
LOG
(
(
"
Process
was
started
.
.
.
waiting
on
result
.
"
)
)
;
DWORD
waitRes
=
WaitForSingleObject
(
pi
.
hProcess
TIME_TO_WAIT_ON_UPDATER
)
;
if
(
WAIT_TIMEOUT
=
=
waitRes
)
{
TerminateProcess
(
pi
.
hProcess
1
)
;
processTerminated
=
TRUE
;
}
else
{
DWORD
returnCode
;
if
(
GetExitCodeProcess
(
pi
.
hProcess
&
returnCode
)
)
{
LOG
(
(
"
Process
finished
with
return
code
%
lu
.
"
returnCode
)
)
;
updateWasSuccessful
=
(
returnCode
=
=
0
)
;
}
else
{
LOG_WARN
(
(
"
Process
finished
but
could
not
obtain
return
code
.
"
)
)
;
noProcessExitCode
=
TRUE
;
}
}
CloseHandle
(
pi
.
hProcess
)
;
CloseHandle
(
pi
.
hThread
)
;
BOOL
isApplying
=
FALSE
;
if
(
IsStatusApplying
(
argv
[
1
]
isApplying
)
&
&
isApplying
)
{
if
(
updateWasSuccessful
)
{
LOG
(
(
"
update
.
status
is
still
applying
even
though
update
was
"
"
successful
.
"
)
)
;
if
(
!
WriteStatusFailure
(
argv
[
1
]
SERVICE_STILL_APPLYING_ON_SUCCESS
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
still
applying
on
"
"
success
error
.
"
)
)
;
}
updateWasSuccessful
=
FALSE
;
}
else
{
LOG_WARN
(
(
"
update
.
status
is
still
applying
and
update
was
not
successful
.
"
)
)
;
int
failcode
=
SERVICE_STILL_APPLYING_ON_FAILURE
;
if
(
noProcessExitCode
)
{
failcode
=
SERVICE_STILL_APPLYING_NO_EXIT_CODE
;
}
else
if
(
processTerminated
)
{
failcode
=
SERVICE_STILL_APPLYING_TERMINATED
;
}
if
(
!
WriteStatusFailure
(
argv
[
1
]
failcode
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
still
applying
on
"
"
failure
error
.
"
)
)
;
}
}
}
}
else
{
DWORD
lastError
=
GetLastError
(
)
;
LOG_WARN
(
(
"
Could
not
create
process
as
current
user
"
"
updaterPath
:
%
ls
;
cmdLine
:
%
ls
.
(
%
lu
)
"
argv
[
0
]
cmdLine
.
get
(
)
lastError
)
)
;
}
putenv
(
const_cast
<
char
*
>
(
"
MOZ_USING_SERVICE
=
"
)
)
;
return
updateWasSuccessful
;
}
static
bool
UpdaterIsValid
(
LPWSTR
updater
LPWSTR
installDir
LPWSTR
updateDir
)
{
BOOL
isLocal
=
FALSE
;
if
(
!
IsLocalFile
(
updater
isLocal
)
|
|
!
isLocal
)
{
LOG_WARN
(
(
"
Filesystem
in
path
%
ls
is
not
supported
(
%
lu
)
"
updater
GetLastError
(
)
)
)
;
if
(
!
WriteStatusFailure
(
updateDir
SERVICE_UPDATER_NOT_FIXED_DRIVE
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
service
update
failure
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
}
return
false
;
}
nsAutoHandle
noWriteLock
(
CreateFileW
(
updater
GENERIC_READ
FILE_SHARE_READ
nullptr
OPEN_EXISTING
0
nullptr
)
)
;
if
(
INVALID_HANDLE_VALUE
=
=
noWriteLock
)
{
LOG_WARN
(
(
"
Could
not
set
no
write
sharing
access
on
file
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
if
(
!
WriteStatusFailure
(
updateDir
SERVICE_COULD_NOT_LOCK_UPDATER
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
service
update
failure
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
}
return
false
;
}
WCHAR
installDirUpdater
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
wcsncpy
(
installDirUpdater
installDir
MAX_PATH
)
;
if
(
!
PathAppendSafe
(
installDirUpdater
L
"
updater
.
exe
"
)
)
{
LOG_WARN
(
(
"
Install
directory
updater
could
not
be
determined
.
"
)
)
;
return
false
;
}
BOOL
updaterIsCorrect
;
if
(
!
VerifySameFiles
(
updater
installDirUpdater
updaterIsCorrect
)
)
{
LOG_WARN
(
(
"
Error
checking
if
the
updaters
are
the
same
.
\
n
"
"
Path
1
:
%
ls
\
nPath
2
:
%
ls
"
updater
installDirUpdater
)
)
;
return
false
;
}
if
(
!
updaterIsCorrect
)
{
LOG_WARN
(
(
"
The
updaters
do
not
match
updater
will
not
run
.
\
n
"
"
Path
1
:
%
ls
\
nPath
2
:
%
ls
"
updater
installDirUpdater
)
)
;
if
(
!
WriteStatusFailure
(
updateDir
SERVICE_UPDATER_COMPARE_ERROR
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
updater
compare
failure
.
"
)
)
;
}
return
false
;
}
LOG
(
(
"
updater
.
exe
was
compared
successfully
to
the
installation
directory
"
"
updater
.
exe
.
"
)
)
;
bool
result
=
true
;
HMODULE
updaterModule
=
LoadLibraryEx
(
updater
nullptr
LOAD_LIBRARY_AS_DATAFILE
)
;
if
(
!
updaterModule
)
{
LOG_WARN
(
(
"
updater
.
exe
module
could
not
be
loaded
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
result
=
false
;
}
else
{
char
updaterIdentity
[
64
]
;
if
(
!
LoadStringA
(
updaterModule
IDS_UPDATER_IDENTITY
updaterIdentity
sizeof
(
updaterIdentity
)
)
)
{
LOG_WARN
(
(
"
The
updater
.
exe
application
does
not
contain
the
Mozilla
"
"
updater
identity
.
"
)
)
;
result
=
false
;
}
if
(
strcmp
(
updaterIdentity
UPDATER_IDENTITY_STRING
)
)
{
LOG_WARN
(
(
"
The
updater
.
exe
identity
string
is
not
valid
.
"
)
)
;
result
=
false
;
}
FreeLibrary
(
updaterModule
)
;
}
if
(
result
)
{
LOG
(
(
"
The
updater
.
exe
application
contains
the
Mozilla
"
"
updater
identity
.
"
)
)
;
}
else
{
if
(
!
WriteStatusFailure
(
updateDir
SERVICE_UPDATER_IDENTITY_ERROR
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
no
updater
identity
.
"
)
)
;
}
return
false
;
}
return
DoesBinaryMatchAllowedCertificates
(
installDir
updater
)
;
}
BOOL
ProcessSoftwareUpdateCommand
(
DWORD
argc
LPWSTR
*
argv
)
{
BOOL
result
=
TRUE
;
if
(
argc
<
3
)
{
LOG_WARN
(
(
"
Not
enough
command
line
parameters
specified
.
"
"
Updating
update
.
status
.
"
)
)
;
if
(
argc
<
2
|
|
!
WriteStatusFailure
(
argv
[
1
]
SERVICE_NOT_ENOUGH_COMMAND_LINE_ARGS
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
service
update
failure
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
}
return
FALSE
;
}
WCHAR
installDir
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
!
GetInstallationDir
(
argc
argv
installDir
)
)
{
LOG_WARN
(
(
"
Could
not
get
the
installation
directory
"
)
)
;
if
(
!
WriteStatusFailure
(
argv
[
1
]
SERVICE_INSTALLDIR_ERROR
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
for
GetInstallationDir
failure
.
"
)
)
;
}
return
FALSE
;
}
if
(
UpdaterIsValid
(
argv
[
0
]
installDir
argv
[
1
]
)
)
{
BOOL
updateProcessWasStarted
=
FALSE
;
if
(
StartUpdateProcess
(
argc
argv
installDir
updateProcessWasStarted
)
)
{
LOG
(
(
"
updater
.
exe
was
launched
and
run
successfully
!
"
)
)
;
LogFlush
(
)
;
if
(
!
IsUpdateBeingStaged
(
argc
argv
)
)
{
LOG
(
(
"
Starting
service
update
"
)
)
;
StartServiceUpdate
(
installDir
)
;
}
else
{
LOG
(
(
"
Skipping
update
of
the
service
because
we
are
staging
"
)
)
;
}
}
else
{
result
=
FALSE
;
LOG_WARN
(
(
"
Error
running
update
process
.
Updating
update
.
status
(
%
lu
)
"
GetLastError
(
)
)
)
;
LogFlush
(
)
;
if
(
!
updateProcessWasStarted
)
{
if
(
!
WriteStatusFailure
(
argv
[
1
]
SERVICE_UPDATER_COULD_NOT_BE_STARTED
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
service
update
failure
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
}
}
}
}
else
{
result
=
FALSE
;
LOG_WARN
(
(
"
Could
not
start
process
due
to
certificate
check
error
on
"
"
updater
.
exe
.
Updating
update
.
status
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
if
(
!
WriteStatusFailure
(
argv
[
1
]
SERVICE_UPDATER_SIGN_ERROR
)
)
{
LOG_WARN
(
(
"
Could
not
write
pending
state
to
update
.
status
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
}
}
return
result
;
}
BOOL
GetSecureUpdaterPath
(
WCHAR
serviceUpdaterPath
[
MAX_PATH
+
1
]
)
{
if
(
!
GetModuleFileNameW
(
nullptr
serviceUpdaterPath
MAX_PATH
)
)
{
LOG_WARN
(
(
"
Could
not
obtain
module
filename
when
attempting
to
"
"
use
a
secure
updater
path
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
return
FALSE
;
}
if
(
!
PathRemoveFileSpecW
(
serviceUpdaterPath
)
)
{
LOG_WARN
(
(
"
Couldn
'
t
remove
file
spec
when
attempting
to
use
a
secure
"
"
updater
path
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
return
FALSE
;
}
if
(
!
PathAppendSafe
(
serviceUpdaterPath
L
"
update
"
)
)
{
LOG_WARN
(
(
"
Couldn
'
t
append
file
spec
when
attempting
to
use
a
secure
"
"
updater
path
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
return
FALSE
;
}
CreateDirectoryW
(
serviceUpdaterPath
nullptr
)
;
if
(
!
PathAppendSafe
(
serviceUpdaterPath
L
"
updater
.
exe
"
)
)
{
LOG_WARN
(
(
"
Couldn
'
t
append
file
spec
when
attempting
to
use
a
secure
"
"
updater
path
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
return
FALSE
;
}
return
TRUE
;
}
BOOL
DeleteSecureUpdater
(
WCHAR
serviceUpdaterPath
[
MAX_PATH
+
1
]
)
{
BOOL
result
=
FALSE
;
if
(
serviceUpdaterPath
[
0
]
)
{
result
=
DeleteFileW
(
serviceUpdaterPath
)
;
if
(
!
result
&
&
GetLastError
(
)
!
=
ERROR_PATH_NOT_FOUND
&
&
GetLastError
(
)
!
=
ERROR_FILE_NOT_FOUND
)
{
LOG_WARN
(
(
"
Could
not
delete
service
updater
path
:
'
%
ls
'
.
"
serviceUpdaterPath
)
)
;
}
WCHAR
updaterINIPath
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
PathGetSiblingFilePath
(
updaterINIPath
serviceUpdaterPath
L
"
updater
.
ini
"
)
)
{
result
=
DeleteFileW
(
updaterINIPath
)
;
if
(
!
result
&
&
GetLastError
(
)
!
=
ERROR_PATH_NOT_FOUND
&
&
GetLastError
(
)
!
=
ERROR_FILE_NOT_FOUND
)
{
LOG_WARN
(
(
"
Could
not
delete
service
updater
INI
path
:
'
%
ls
'
.
"
updaterINIPath
)
)
;
}
}
}
return
result
;
}
BOOL
ExecuteServiceCommand
(
int
argc
LPWSTR
*
argv
)
{
if
(
argc
<
3
)
{
LOG_WARN
(
(
"
Not
enough
command
line
arguments
to
execute
a
service
command
"
)
)
;
return
FALSE
;
}
WCHAR
uuidString
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
GetUUIDString
(
uuidString
)
)
{
LOG
(
(
"
Executing
service
command
%
ls
ID
:
%
ls
"
argv
[
2
]
uuidString
)
)
;
}
else
{
LOG
(
(
"
Executing
service
command
%
ls
"
argv
[
2
]
)
)
;
}
BOOL
result
=
FALSE
;
if
(
!
lstrcmpi
(
argv
[
2
]
L
"
software
-
update
"
)
)
{
if
(
argc
<
=
4
|
|
!
IsValidFullPath
(
argv
[
4
]
)
)
{
LOG_WARN
(
(
"
The
patch
directory
path
is
not
valid
for
this
application
.
"
)
)
;
return
FALSE
;
}
size_t
fullPathLen
=
NS_tstrlen
(
argv
[
4
]
)
;
size_t
relPathLen
=
NS_tstrlen
(
PATCH_DIR_PATH
)
;
if
(
relPathLen
>
fullPathLen
)
{
LOG_WARN
(
(
"
The
patch
directory
path
length
is
not
valid
for
this
"
"
application
.
"
)
)
;
return
FALSE
;
}
if
(
_wcsnicmp
(
argv
[
4
]
+
fullPathLen
-
relPathLen
PATCH_DIR_PATH
relPathLen
)
!
=
0
)
{
LOG_WARN
(
(
"
The
patch
directory
path
subdirectory
is
not
valid
for
this
"
"
application
.
"
)
)
;
return
FALSE
;
}
RemoveSecureOutputFiles
(
argv
[
4
]
)
;
if
(
!
WriteSecureIDFile
(
argv
[
4
]
)
)
{
LOG_WARN
(
(
"
Unable
to
write
to
secure
ID
file
.
"
)
)
;
return
FALSE
;
}
if
(
argc
<
=
5
|
|
!
IsValidFullPath
(
argv
[
5
]
)
#
ifndef
DISABLE_UPDATER_AUTHENTICODE_CHECK
|
|
!
IsProgramFilesPath
(
argv
[
5
]
)
#
endif
)
{
LOG_WARN
(
(
"
The
install
directory
path
is
not
valid
for
this
application
.
"
)
)
;
if
(
!
WriteStatusFailure
(
argv
[
4
]
SERVICE_INVALID_INSTALL_DIR_PATH_ERROR
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
for
previous
failure
.
"
)
)
;
}
return
FALSE
;
}
if
(
!
IsOldCommandline
(
argc
-
3
argv
+
3
)
)
{
if
(
argc
<
=
6
|
|
!
IsValidFullPath
(
argv
[
6
]
)
)
{
LOG_WARN
(
(
"
The
working
directory
path
is
not
valid
for
this
application
.
"
)
)
;
if
(
!
WriteStatusFailure
(
argv
[
4
]
SERVICE_INVALID_WORKING_DIR_PATH_ERROR
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
for
previous
failure
.
"
)
)
;
}
return
FALSE
;
}
if
(
_wcsnicmp
(
argv
[
6
]
argv
[
5
]
MAX_PATH
)
!
=
0
)
{
if
(
argc
<
=
7
|
|
(
wcscmp
(
argv
[
7
]
L
"
-
1
"
)
!
=
0
&
&
!
wcsstr
(
argv
[
7
]
L
"
/
replace
"
)
)
)
{
LOG_WARN
(
(
"
Installation
directory
and
working
directory
must
be
the
"
"
same
for
non
-
staged
updates
.
Exiting
.
"
)
)
;
if
(
!
WriteStatusFailure
(
argv
[
4
]
SERVICE_INVALID_APPLYTO_DIR_ERROR
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
for
previous
failure
.
"
)
)
;
}
return
FALSE
;
}
NS_tchar
workingDirParent
[
MAX_PATH
]
;
NS_tsnprintf
(
workingDirParent
sizeof
(
workingDirParent
)
/
sizeof
(
workingDirParent
[
0
]
)
NS_T
(
"
%
s
"
)
argv
[
6
]
)
;
if
(
!
PathRemoveFileSpecW
(
workingDirParent
)
)
{
LOG_WARN
(
(
"
Couldn
'
t
remove
file
spec
when
attempting
to
verify
the
"
"
working
directory
path
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
if
(
!
WriteStatusFailure
(
argv
[
4
]
REMOVE_FILE_SPEC_ERROR
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
for
previous
failure
.
"
)
)
;
}
return
FALSE
;
}
if
(
_wcsnicmp
(
workingDirParent
argv
[
5
]
MAX_PATH
)
!
=
0
)
{
LOG_WARN
(
(
"
The
apply
-
to
directory
must
be
the
same
as
or
"
"
a
child
of
the
installation
directory
!
Exiting
.
"
)
)
;
if
(
!
WriteStatusFailure
(
argv
[
4
]
SERVICE_INVALID_APPLYTO_DIR_STAGED_ERROR
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
for
previous
failure
.
"
)
)
;
}
return
FALSE
;
}
}
}
WCHAR
installDir
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
!
GetInstallationDir
(
argc
-
3
argv
+
3
installDir
)
)
{
LOG_WARN
(
(
"
Could
not
get
the
installation
directory
"
)
)
;
if
(
!
WriteStatusFailure
(
argv
[
4
]
SERVICE_INSTALLDIR_ERROR
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
for
previous
failure
.
"
)
)
;
}
return
FALSE
;
}
if
(
!
DoesFallbackKeyExist
(
)
)
{
WCHAR
maintenanceServiceKey
[
MAX_PATH
+
1
]
;
if
(
CalculateRegistryPathFromFilePath
(
installDir
maintenanceServiceKey
)
)
{
LOG
(
(
"
Checking
for
Maintenance
Service
registry
.
key
:
'
%
ls
'
"
maintenanceServiceKey
)
)
;
HKEY
baseKey
=
nullptr
;
if
(
RegOpenKeyExW
(
HKEY_LOCAL_MACHINE
maintenanceServiceKey
0
KEY_READ
|
KEY_WOW64_64KEY
&
baseKey
)
!
=
ERROR_SUCCESS
)
{
LOG_WARN
(
(
"
The
maintenance
service
registry
key
does
not
exist
.
"
)
)
;
if
(
!
WriteStatusFailure
(
argv
[
4
]
SERVICE_INSTALL_DIR_REG_ERROR
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
for
previous
failure
.
"
)
)
;
}
return
FALSE
;
}
RegCloseKey
(
baseKey
)
;
}
else
{
if
(
!
WriteStatusFailure
(
argv
[
4
]
SERVICE_CALC_REG_PATH_ERROR
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
for
previous
failure
.
"
)
)
;
}
return
FALSE
;
}
}
WCHAR
installDirUpdater
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
wcsncpy
(
installDirUpdater
installDir
MAX_PATH
)
;
if
(
!
PathAppendSafe
(
installDirUpdater
L
"
updater
.
exe
"
)
)
{
LOG_WARN
(
(
"
Install
directory
updater
could
not
be
determined
.
"
)
)
;
result
=
FALSE
;
}
result
=
UpdaterIsValid
(
installDirUpdater
installDir
argv
[
4
]
)
;
WCHAR
secureUpdaterPath
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
result
)
{
result
=
GetSecureUpdaterPath
(
secureUpdaterPath
)
;
}
if
(
result
)
{
LOG
(
(
"
Passed
in
path
:
'
%
ls
'
(
ignored
)
;
"
"
Install
dir
has
:
'
%
ls
'
;
"
"
Using
this
path
for
updating
:
'
%
ls
'
.
"
argv
[
3
]
installDirUpdater
secureUpdaterPath
)
)
;
DeleteSecureUpdater
(
secureUpdaterPath
)
;
result
=
CopyFileW
(
installDirUpdater
secureUpdaterPath
FALSE
)
;
}
if
(
!
result
)
{
LOG_WARN
(
(
"
Could
not
copy
path
to
secure
location
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
if
(
!
WriteStatusFailure
(
argv
[
4
]
SERVICE_COULD_NOT_COPY_UPDATER
)
)
{
LOG_WARN
(
(
"
Could
not
write
update
.
status
could
not
copy
updater
error
"
)
)
;
}
}
else
{
argv
[
3
]
=
secureUpdaterPath
;
WCHAR
installDirUpdaterINIPath
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
WCHAR
secureUpdaterINIPath
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
PathGetSiblingFilePath
(
secureUpdaterINIPath
secureUpdaterPath
L
"
updater
.
ini
"
)
&
&
PathGetSiblingFilePath
(
installDirUpdaterINIPath
installDirUpdater
L
"
updater
.
ini
"
)
)
{
if
(
!
CopyFileW
(
installDirUpdaterINIPath
secureUpdaterINIPath
FALSE
)
)
{
LOG_WARN
(
(
"
Could
not
copy
updater
.
ini
from
:
'
%
ls
'
to
'
%
ls
'
.
(
%
lu
)
"
installDirUpdaterINIPath
secureUpdaterINIPath
GetLastError
(
)
)
)
;
}
}
result
=
ProcessSoftwareUpdateCommand
(
argc
-
3
argv
+
3
)
;
DeleteSecureUpdater
(
secureUpdaterPath
)
;
}
LOG
(
(
"
Service
command
%
ls
complete
.
"
argv
[
2
]
)
)
;
}
else
{
LOG_WARN
(
(
"
Service
command
not
recognized
:
%
ls
.
"
argv
[
2
]
)
)
;
}
LOG
(
(
"
service
command
%
ls
complete
with
result
:
%
ls
.
"
argv
[
1
]
(
result
?
L
"
Success
"
:
L
"
Failure
"
)
)
)
;
return
result
;
}
