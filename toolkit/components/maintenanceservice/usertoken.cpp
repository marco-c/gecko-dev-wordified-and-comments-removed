#
include
<
windows
.
h
>
#
include
<
stdio
.
h
>
#
include
<
oleauto
.
h
>
#
include
<
sddl
.
h
>
#
include
<
wbemidl
.
h
>
#
include
<
shellapi
.
h
>
#
ifndef
__MINGW32__
#
pragma
comment
(
lib
"
shell32
.
lib
"
)
#
pragma
comment
(
lib
"
oleaut32
.
lib
"
)
#
pragma
comment
(
lib
"
wbemuuid
.
lib
"
)
#
endif
#
include
"
usertoken
.
h
"
#
include
"
updatecommon
.
h
"
#
include
"
RefPtr
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
using
mozilla
:
:
UniquePtr
;
using
mozilla
:
:
MakeUnique
;
class
CoInitScope
{
private
:
HRESULT
hr
;
public
:
CoInitScope
(
)
{
hr
=
:
:
CoInitializeEx
(
0
COINIT_APARTMENTTHREADED
)
;
if
(
SUCCEEDED
(
hr
)
)
{
hr
=
:
:
CoInitializeSecurity
(
nullptr
-
1
nullptr
nullptr
RPC_C_AUTHN_LEVEL_DEFAULT
RPC_C_IMP_LEVEL_IMPERSONATE
nullptr
EOAC_NONE
nullptr
)
;
if
(
!
SUCCEEDED
(
hr
)
)
{
:
:
CoUninitialize
(
)
;
}
}
}
MOZ_IMPLICIT
operator
bool
(
)
const
{
return
SUCCEEDED
(
hr
)
;
}
HRESULT
GetHRESULT
(
)
const
{
return
hr
;
}
~
CoInitScope
(
)
{
if
(
SUCCEEDED
(
hr
)
)
{
:
:
CoUninitialize
(
)
;
}
}
private
:
CoInitScope
(
const
CoInitScope
&
)
=
delete
;
CoInitScope
&
operator
=
(
const
CoInitScope
&
)
=
delete
;
CoInitScope
(
CoInitScope
&
&
)
=
delete
;
CoInitScope
&
operator
=
(
CoInitScope
&
&
)
=
delete
;
}
;
class
AutoVariant
{
private
:
VARIANT
v
;
public
:
AutoVariant
(
)
{
:
:
VariantInit
(
&
v
)
;
}
~
AutoVariant
(
)
{
:
:
VariantClear
(
&
v
)
;
}
VARIANT
&
get
(
)
{
return
v
;
}
private
:
AutoVariant
(
const
AutoVariant
&
)
=
delete
;
AutoVariant
&
operator
=
(
const
AutoVariant
&
)
=
delete
;
AutoVariant
(
AutoVariant
&
&
)
=
delete
;
AutoVariant
&
operator
=
(
AutoVariant
&
&
)
=
delete
;
}
;
struct
SysFreeStringDeleter
{
void
operator
(
)
(
void
*
aPtr
)
{
SysFreeString
(
(
BSTR
)
aPtr
)
;
}
}
;
typedef
UniquePtr
<
WCHAR
SysFreeStringDeleter
>
UniqueBstr
;
static
inline
UniqueBstr
UniqueBstrFromWSTR
(
LPCWSTR
wstr
)
{
UniqueBstr
bstr
(
SysAllocString
(
wstr
)
)
;
return
bstr
;
}
static
UniquePtr
<
WCHAR
[
]
>
QuoteWQLString
(
LPCWSTR
src
)
{
const
WCHAR
kQuote
=
L
'
\
'
'
;
const
WCHAR
kBs
=
L
'
\
\
'
;
size_t
quotedLength
=
3
;
for
(
size_t
i
=
0
;
;
i
+
+
)
{
WCHAR
c
=
src
[
i
]
;
if
(
c
=
=
kQuote
|
|
c
=
=
kBs
)
{
quotedLength
+
+
;
}
else
if
(
c
=
=
L
'
\
0
'
)
{
break
;
}
quotedLength
+
+
;
}
UniquePtr
<
WCHAR
[
]
>
quoted
=
MakeUnique
<
WCHAR
[
]
>
(
quotedLength
)
;
if
(
!
quoted
)
{
return
nullptr
;
}
quoted
[
0
]
=
kQuote
;
for
(
size_t
i
=
0
quotedIdx
=
1
;
;
i
+
+
)
{
WCHAR
c
=
src
[
i
]
;
if
(
c
=
=
kQuote
|
|
c
=
=
kBs
)
{
quoted
[
quotedIdx
+
+
]
=
kBs
;
}
else
if
(
c
=
=
L
'
\
0
'
)
{
quoted
[
quotedIdx
+
+
]
=
kQuote
;
quoted
[
quotedIdx
+
+
]
=
L
'
\
0
'
;
break
;
}
quoted
[
quotedIdx
+
+
]
=
c
;
}
return
quoted
;
}
static
bool
CheckCreationTime
(
const
CoInitScope
&
coInited
HANDLE
hProc
BSTR
checkCreationDateLocal
)
{
if
(
!
coInited
)
{
return
false
;
}
UniqueBstr
checkCreationDate
;
{
RefPtr
<
ISWbemDateTime
>
pCheckDateTime
;
if
(
FAILED
(
CoCreateInstance
(
CLSID_SWbemDateTime
nullptr
CLSCTX_INPROC_SERVER
IID_ISWbemDateTime
getter_AddRefs
(
pCheckDateTime
)
)
)
)
{
return
false
;
}
UniqueBstr
checkCreationFILETIME
;
{
BSTR
checkCreationFILETIMERaw
=
nullptr
;
if
(
FAILED
(
pCheckDateTime
-
>
put_Value
(
checkCreationDateLocal
)
)
|
|
FAILED
(
pCheckDateTime
-
>
GetFileTime
(
VARIANT_FALSE
&
checkCreationFILETIMERaw
)
)
)
{
return
false
;
}
checkCreationFILETIME
.
reset
(
checkCreationFILETIMERaw
)
;
}
BSTR
checkCreationDateRaw
;
if
(
FAILED
(
pCheckDateTime
-
>
SetFileTime
(
checkCreationFILETIME
.
get
(
)
VARIANT_FALSE
)
)
|
|
FAILED
(
pCheckDateTime
-
>
get_Value
(
&
checkCreationDateRaw
)
)
)
{
return
false
;
}
checkCreationDate
.
reset
(
checkCreationDateRaw
)
;
}
UniqueBstr
procCreationDate
;
{
FILETIME
procCreationTime
_exitTime
_kernelTime
_userTime
;
if
(
!
GetProcessTimes
(
hProc
&
procCreationTime
&
_exitTime
&
_kernelTime
&
_userTime
)
)
{
LOG_WARN
(
(
"
GetProcessTimes
failed
.
(
%
lu
)
"
GetLastError
(
)
)
)
;
return
false
;
}
UniqueBstr
createFILETIME
;
{
ULARGE_INTEGER
timeInt
;
timeInt
.
LowPart
=
procCreationTime
.
dwLowDateTime
;
timeInt
.
HighPart
=
procCreationTime
.
dwHighDateTime
;
static
const
WCHAR
timeFmt
[
]
=
L
"
%
llu
"
;
const
size_t
timeBufLen
=
_scwprintf
(
timeFmt
timeInt
.
QuadPart
)
+
1
;
UniquePtr
<
WCHAR
[
]
>
timeBuf
=
MakeUnique
<
WCHAR
[
]
>
(
timeBufLen
)
;
swprintf_s
(
timeBuf
.
get
(
)
timeBufLen
timeFmt
timeInt
.
QuadPart
)
;
createFILETIME
=
UniqueBstrFromWSTR
(
timeBuf
.
get
(
)
)
;
if
(
!
createFILETIME
)
{
return
false
;
}
}
RefPtr
<
ISWbemDateTime
>
pProcDateTime
;
if
(
FAILED
(
CoCreateInstance
(
CLSID_SWbemDateTime
nullptr
CLSCTX_INPROC_SERVER
IID_ISWbemDateTime
getter_AddRefs
(
pProcDateTime
)
)
)
)
{
return
false
;
}
BSTR
procCreationDateRaw
;
if
(
FAILED
(
pProcDateTime
-
>
SetFileTime
(
createFILETIME
.
get
(
)
VARIANT_FALSE
)
)
|
|
FAILED
(
pProcDateTime
-
>
get_Value
(
&
procCreationDateRaw
)
)
)
{
return
false
;
}
procCreationDate
.
reset
(
procCreationDateRaw
)
;
}
return
!
wcscmp
(
checkCreationDate
.
get
(
)
procCreationDate
.
get
(
)
)
;
}
HANDLE
GetUserProcessToken
(
LPCWSTR
updaterPath
int
updaterArgc
LPCWSTR
updaterArgv
[
]
)
{
CoInitScope
coInited
;
if
(
!
coInited
)
{
LOG_WARN
(
(
"
Failed
to
initialize
COM
or
COM
security
.
(
hr
=
%
ld
)
"
coInited
.
GetHRESULT
(
)
)
)
;
return
nullptr
;
}
nsAutoHandle
rv
;
DWORD
matchedPid
=
0
;
HRESULT
hr
;
UniquePtr
<
void
LocalFreeDeleter
>
systemSid
;
{
PSID
sid
;
if
(
!
ConvertStringSidToSidA
(
"
SY
"
&
sid
)
)
{
return
nullptr
;
}
systemSid
.
reset
(
sid
)
;
}
UniquePtr
<
void
LocalFreeDeleter
>
usersSid
;
{
PSID
sid
;
if
(
!
ConvertStringSidToSidA
(
"
BU
"
&
sid
)
)
{
return
nullptr
;
}
usersSid
.
reset
(
sid
)
;
}
UniqueBstr
processIdName
=
UniqueBstrFromWSTR
(
L
"
ProcessId
"
)
;
UniqueBstr
creationDateName
=
UniqueBstrFromWSTR
(
L
"
CreationDate
"
)
;
UniqueBstr
commandLineName
=
UniqueBstrFromWSTR
(
L
"
CommandLine
"
)
;
if
(
!
processIdName
|
|
!
creationDateName
|
|
!
commandLineName
)
{
return
nullptr
;
}
RefPtr
<
IEnumWbemClassObject
>
pQueryRows
;
{
static
const
WCHAR
queryFormat
[
]
=
L
"
SELECT
ProcessId
CreationDate
CommandLine
"
"
FROM
Win32_Process
"
"
WHERE
ExecutablePath
=
%
ls
"
;
UniqueBstr
queryBstr
;
{
UniquePtr
<
WCHAR
[
]
>
quotedExePath
=
QuoteWQLString
(
updaterPath
)
;
if
(
!
quotedExePath
)
{
return
nullptr
;
}
const
size_t
queryBufLen
=
_scwprintf
(
queryFormat
quotedExePath
.
get
(
)
)
+
1
;
UniquePtr
<
WCHAR
[
]
>
query
=
MakeUnique
<
WCHAR
[
]
>
(
queryBufLen
)
;
if
(
!
query
)
{
return
nullptr
;
}
swprintf_s
(
query
.
get
(
)
queryBufLen
queryFormat
quotedExePath
.
get
(
)
)
;
queryBstr
=
UniqueBstrFromWSTR
(
query
.
get
(
)
)
;
if
(
!
queryBstr
)
{
return
nullptr
;
}
}
RefPtr
<
IWbemLocator
>
pLocator
;
hr
=
CoCreateInstance
(
CLSID_WbemLocator
nullptr
CLSCTX_INPROC_SERVER
IID_IWbemLocator
getter_AddRefs
(
pLocator
)
)
;
if
(
FAILED
(
hr
)
)
{
LOG_WARN
(
(
"
Failed
to
create
WbemLocator
.
(
hr
=
%
ld
)
"
hr
)
)
;
return
nullptr
;
}
RefPtr
<
IWbemServices
>
pServices
;
UniqueBstr
resourceBstr
(
SysAllocString
(
L
"
ROOT
\
\
CimV2
"
)
)
;
if
(
!
resourceBstr
)
{
return
nullptr
;
}
hr
=
pLocator
-
>
ConnectServer
(
resourceBstr
.
get
(
)
nullptr
nullptr
nullptr
WBEM_FLAG_CONNECT_USE_MAX_WAIT
nullptr
nullptr
getter_AddRefs
(
pServices
)
)
;
if
(
FAILED
(
hr
)
)
{
LOG_WARN
(
(
"
Failed
to
connect
to
WMI
server
.
(
hr
=
%
ld
)
"
hr
)
)
;
return
nullptr
;
}
if
(
FAILED
(
CoSetProxyBlanket
(
pServices
RPC_C_AUTHN_WINNT
RPC_C_AUTHZ_NONE
nullptr
RPC_C_AUTHN_LEVEL_CALL
RPC_C_IMP_LEVEL_IMPERSONATE
nullptr
EOAC_NONE
)
)
)
{
LOG_WARN
(
(
"
Failed
to
set
proxy
blanket
.
(
hr
=
%
ld
)
"
hr
)
)
;
return
nullptr
;
}
UniqueBstr
wqlBstr
(
SysAllocString
(
L
"
WQL
"
)
)
;
hr
=
pServices
-
>
ExecQuery
(
wqlBstr
.
get
(
)
queryBstr
.
get
(
)
0
nullptr
getter_AddRefs
(
pQueryRows
)
)
;
if
(
FAILED
(
hr
)
)
{
LOG_WARN
(
(
"
Command
line
query
failed
.
(
hr
=
%
ld
)
"
hr
)
)
;
return
nullptr
;
}
}
HRESULT
hIterRes
;
RefPtr
<
IWbemClassObject
>
pRow
;
DWORD
uReturned
=
0
;
while
(
SUCCEEDED
(
hIterRes
=
pQueryRows
-
>
Next
(
WBEM_INFINITE
1
getter_AddRefs
(
pRow
)
&
uReturned
)
)
)
{
if
(
hIterRes
=
=
WBEM_S_FALSE
&
&
uReturned
=
=
0
)
{
break
;
}
else
if
(
hIterRes
!
=
WBEM_S_NO_ERROR
|
|
uReturned
!
=
1
)
{
LOG_WARN
(
(
"
Get
next
row
failed
.
(
hr
=
%
ld
)
"
hIterRes
)
)
;
return
nullptr
;
}
AutoVariant
commandLine
;
if
(
FAILED
(
pRow
-
>
Get
(
commandLineName
.
get
(
)
0
&
commandLine
.
get
(
)
nullptr
nullptr
)
)
)
{
return
nullptr
;
}
if
(
V_VT
(
&
commandLine
.
get
(
)
)
!
=
VT_BSTR
)
{
return
nullptr
;
}
{
int
resultArgc
=
0
;
UniquePtr
<
LPWSTR
LocalFreeDeleter
>
resultArgv
(
CommandLineToArgvW
(
commandLine
.
get
(
)
.
bstrVal
&
resultArgc
)
)
;
if
(
!
resultArgv
|
|
resultArgc
!
=
updaterArgc
)
{
continue
;
}
bool
matched
=
true
;
for
(
int
i
=
1
;
matched
&
&
i
<
resultArgc
;
i
+
+
)
{
if
(
wcsicmp
(
resultArgv
.
get
(
)
[
i
]
updaterArgv
[
i
]
)
)
{
matched
=
false
;
}
}
if
(
!
matched
)
{
continue
;
}
}
DWORD
pid
;
{
AutoVariant
processId
;
CIMTYPE
processIdCimType
;
if
(
FAILED
(
pRow
-
>
Get
(
processIdName
.
get
(
)
0
&
processId
.
get
(
)
&
processIdCimType
nullptr
)
)
)
{
return
nullptr
;
}
if
(
V_VT
(
&
processId
.
get
(
)
)
!
=
VT_I4
|
|
processIdCimType
!
=
CIM_UINT32
)
{
LOG_WARN
(
(
"
Unexpected
variant
type
%
d
or
CIM
type
%
d
for
processId
"
V_VT
(
&
processId
.
get
(
)
)
processIdCimType
)
)
;
return
nullptr
;
}
pid
=
static_cast
<
DWORD
>
(
processId
.
get
(
)
.
lVal
)
;
}
AutoVariant
creationDate
;
CIMTYPE
creationDateCimType
;
if
(
FAILED
(
pRow
-
>
Get
(
creationDateName
.
get
(
)
0
&
creationDate
.
get
(
)
&
creationDateCimType
nullptr
)
)
)
{
return
nullptr
;
}
if
(
V_VT
(
&
creationDate
.
get
(
)
)
!
=
VT_BSTR
|
|
creationDateCimType
!
=
CIM_DATETIME
)
{
LOG_WARN
(
(
"
Unexpected
variant
type
%
d
or
CIM
type
%
d
for
creationDate
"
V_VT
(
&
creationDate
.
get
(
)
)
creationDateCimType
)
)
;
return
nullptr
;
}
nsAutoHandle
hProc
(
OpenProcess
(
PROCESS_QUERY_INFORMATION
FALSE
pid
)
)
;
if
(
!
hProc
)
{
continue
;
}
if
(
!
CheckCreationTime
(
coInited
hProc
creationDate
.
get
(
)
.
bstrVal
)
)
{
LOG_WARN
(
(
"
Failed
to
verify
process
creation
time
skipping
.
"
)
)
;
continue
;
}
nsAutoHandle
hDupToken
;
{
HANDLE
hRawProcToken
=
nullptr
;
if
(
!
OpenProcessToken
(
hProc
TOKEN_DUPLICATE
|
TOKEN_IMPERSONATE
|
TOKEN_QUERY
(
PVOID
*
)
&
hRawProcToken
)
)
{
LOG_WARN
(
(
"
Failed
to
open
impersonation
token
for
pid
(
%
lu
)
.
(
%
d
)
"
pid
GetLastError
(
)
)
)
;
continue
;
}
SECURITY_ATTRIBUTES
sa
;
sa
.
nLength
=
sizeof
(
sa
)
;
sa
.
bInheritHandle
=
TRUE
;
sa
.
lpSecurityDescriptor
=
nullptr
;
HANDLE
hRawDupToken
=
nullptr
;
BOOL
result
=
DuplicateTokenEx
(
hRawProcToken
TOKEN_DUPLICATE
|
TOKEN_IMPERSONATE
|
TOKEN_QUERY
&
sa
SecurityImpersonation
TokenImpersonation
&
hRawDupToken
)
;
CloseHandle
(
hRawProcToken
)
;
if
(
!
result
)
{
LOG_WARN
(
(
"
Failed
to
duplicate
impersonation
token
for
pid
(
%
lu
)
.
(
%
d
)
"
pid
GetLastError
(
)
)
)
;
continue
;
}
hDupToken
.
own
(
hRawDupToken
)
;
}
{
BOOL
isMember
=
FALSE
;
if
(
!
CheckTokenMembership
(
hDupToken
.
get
(
)
systemSid
.
get
(
)
&
isMember
)
|
|
isMember
)
{
continue
;
}
if
(
!
CheckTokenMembership
(
hDupToken
.
get
(
)
usersSid
.
get
(
)
&
isMember
)
|
|
!
isMember
)
{
continue
;
}
}
if
(
rv
)
{
LOG_WARN
(
(
"
Matched
multiple
possible
updater
processes
"
"
(
pids
%
lu
and
%
lu
)
can
'
t
choose
one
to
impersonate
.
"
pid
matchedPid
)
)
;
return
nullptr
;
}
rv
.
swap
(
hDupToken
)
;
matchedPid
=
pid
;
}
if
(
!
rv
)
{
LOG_WARN
(
(
"
Found
no
matching
updater
process
to
impersonate
.
"
)
)
;
}
else
{
LOG_WARN
(
(
"
Successfully
matched
pid
%
lu
and
got
impersonation
token
.
"
matchedPid
)
)
;
}
return
rv
.
disown
(
)
;
}
