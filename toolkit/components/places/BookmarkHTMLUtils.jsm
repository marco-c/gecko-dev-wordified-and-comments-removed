var
EXPORTED_SYMBOLS
=
[
"
BookmarkHTMLUtils
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
XMLHttpRequest
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesBackups
"
"
resource
:
/
/
gre
/
modules
/
PlacesBackups
.
jsm
"
)
;
const
Container_Normal
=
0
;
const
Container_Toolbar
=
1
;
const
Container_Menu
=
2
;
const
Container_Unfiled
=
3
;
const
Container_Places
=
4
;
const
LOAD_IN_SIDEBAR_ANNO
=
"
bookmarkProperties
/
loadInSidebar
"
;
const
DESCRIPTION_ANNO
=
"
bookmarkProperties
/
description
"
;
const
MICROSEC_PER_SEC
=
1000000
;
const
EXPORT_INDENT
=
"
"
;
function
base64EncodeString
(
aString
)
{
let
stream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stream
.
setData
(
aString
aString
.
length
)
;
let
encoder
=
Cc
[
"
mozilla
.
org
/
scriptablebase64encoder
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptableBase64Encoder
)
;
return
encoder
.
encodeToString
(
stream
aString
.
length
)
;
}
function
escapeHtmlEntities
(
aText
)
{
return
(
aText
|
|
"
"
)
.
replace
(
/
&
/
g
"
&
amp
;
"
)
.
replace
(
/
<
/
g
"
&
lt
;
"
)
.
replace
(
/
>
/
g
"
&
gt
;
"
)
.
replace
(
/
"
/
g
"
&
quot
;
"
)
.
replace
(
/
'
/
g
"
&
#
39
;
"
)
;
}
function
escapeUrl
(
aText
)
{
return
(
aText
|
|
"
"
)
.
replace
(
/
"
/
g
"
%
22
"
)
;
}
function
notifyObservers
(
aTopic
aInitialImport
)
{
Services
.
obs
.
notifyObservers
(
null
aTopic
aInitialImport
?
"
html
-
initial
"
:
"
html
"
)
;
}
var
BookmarkHTMLUtils
=
Object
.
freeze
(
{
async
importFromURL
(
aSpec
{
replace
:
aInitialImport
=
false
source
:
aSource
=
aInitialImport
?
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE
:
PlacesUtils
.
bookmarks
.
SOURCES
.
IMPORT
}
=
{
}
)
{
notifyObservers
(
PlacesUtils
.
TOPIC_BOOKMARKS_RESTORE_BEGIN
aInitialImport
)
;
try
{
let
importer
=
new
BookmarkImporter
(
aInitialImport
aSource
)
;
await
importer
.
importFromURL
(
aSpec
)
;
notifyObservers
(
PlacesUtils
.
TOPIC_BOOKMARKS_RESTORE_SUCCESS
aInitialImport
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
import
bookmarks
from
"
+
aSpec
+
"
:
"
+
ex
)
;
notifyObservers
(
PlacesUtils
.
TOPIC_BOOKMARKS_RESTORE_FAILED
aInitialImport
)
;
throw
ex
;
}
}
async
importFromFile
(
aFilePath
{
replace
:
aInitialImport
=
false
source
:
aSource
=
aInitialImport
?
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE
:
PlacesUtils
.
bookmarks
.
SOURCES
.
IMPORT
}
=
{
}
)
{
notifyObservers
(
PlacesUtils
.
TOPIC_BOOKMARKS_RESTORE_BEGIN
aInitialImport
)
;
try
{
if
(
!
(
await
OS
.
File
.
exists
(
aFilePath
)
)
)
{
throw
new
Error
(
"
Cannot
import
from
nonexisting
html
file
:
"
+
aFilePath
)
;
}
let
importer
=
new
BookmarkImporter
(
aInitialImport
aSource
)
;
await
importer
.
importFromURL
(
OS
.
Path
.
toFileURI
(
aFilePath
)
)
;
notifyObservers
(
PlacesUtils
.
TOPIC_BOOKMARKS_RESTORE_SUCCESS
aInitialImport
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
import
bookmarks
from
"
+
aFilePath
+
"
:
"
+
ex
)
;
notifyObservers
(
PlacesUtils
.
TOPIC_BOOKMARKS_RESTORE_FAILED
aInitialImport
)
;
throw
ex
;
}
}
async
exportToFile
(
aFilePath
)
{
let
[
bookmarks
count
]
=
await
PlacesBackups
.
getBookmarksTree
(
)
;
let
startTime
=
Date
.
now
(
)
;
let
exporter
=
new
BookmarkExporter
(
bookmarks
)
;
await
exporter
.
exportToFile
(
aFilePath
)
;
try
{
Services
.
telemetry
.
getHistogramById
(
"
PLACES_EXPORT_TOHTML_MS
"
)
.
add
(
Date
.
now
(
)
-
startTime
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Unable
to
report
telemetry
.
"
)
;
}
return
count
;
}
get
defaultPath
(
)
{
try
{
return
Services
.
prefs
.
getCharPref
(
"
browser
.
bookmarks
.
file
"
)
;
}
catch
(
ex
)
{
}
return
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
bookmarks
.
html
"
)
;
}
}
)
;
function
Frame
(
aFolder
)
{
this
.
folder
=
aFolder
;
this
.
containerNesting
=
0
;
this
.
lastContainerType
=
Container_Normal
;
this
.
previousText
=
"
"
;
this
.
inDescription
=
false
;
this
.
previousLink
=
null
;
this
.
previousFeed
=
null
;
this
.
previousItem
=
null
;
this
.
previousDateAdded
=
null
;
this
.
previousLastModifiedDate
=
null
;
}
function
BookmarkImporter
(
aInitialImport
aSource
)
{
this
.
_isImportDefaults
=
aInitialImport
;
this
.
_source
=
aSource
;
this
.
_bookmarkTree
=
{
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
guid
:
PlacesUtils
.
bookmarks
.
menuGuid
children
:
[
]
}
;
this
.
_frames
=
[
]
;
this
.
_frames
.
push
(
new
Frame
(
this
.
_bookmarkTree
)
)
;
}
BookmarkImporter
.
prototype
=
{
_safeTrim
:
function
safeTrim
(
aStr
)
{
return
aStr
?
aStr
.
trim
(
)
:
aStr
;
}
get
_curFrame
(
)
{
return
this
.
_frames
[
this
.
_frames
.
length
-
1
]
;
}
get
_previousFrame
(
)
{
return
this
.
_frames
[
this
.
_frames
.
length
-
2
]
;
}
_newFrame
:
function
newFrame
(
)
{
let
frame
=
this
.
_curFrame
;
let
containerTitle
=
frame
.
previousText
;
frame
.
previousText
=
"
"
;
let
containerType
=
frame
.
lastContainerType
;
let
folder
=
{
children
:
[
]
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
;
switch
(
containerType
)
{
case
Container_Normal
:
folder
.
title
=
containerTitle
;
break
;
case
Container_Places
:
folder
.
guid
=
PlacesUtils
.
bookmarks
.
rootGuid
;
break
;
case
Container_Menu
:
folder
.
guid
=
PlacesUtils
.
bookmarks
.
menuGuid
;
break
;
case
Container_Unfiled
:
folder
.
guid
=
PlacesUtils
.
bookmarks
.
unfiledGuid
;
break
;
case
Container_Toolbar
:
folder
.
guid
=
PlacesUtils
.
bookmarks
.
toolbarGuid
;
break
;
default
:
throw
new
Error
(
"
Unknown
bookmark
container
type
!
"
)
;
}
frame
.
folder
.
children
.
push
(
folder
)
;
if
(
frame
.
previousDateAdded
!
=
null
)
{
folder
.
dateAdded
=
frame
.
previousDateAdded
;
frame
.
previousDateAdded
=
null
;
}
if
(
frame
.
previousLastModifiedDate
!
=
null
)
{
folder
.
lastModified
=
frame
.
previousLastModifiedDate
;
frame
.
previousLastModifiedDate
=
null
;
}
if
(
!
folder
.
hasOwnProperty
(
"
dateAdded
"
)
&
&
folder
.
hasOwnProperty
(
"
lastModified
"
)
)
{
folder
.
dateAdded
=
folder
.
lastModified
;
}
frame
.
previousItem
=
folder
;
this
.
_frames
.
push
(
new
Frame
(
folder
)
)
;
}
_handleSeparator
:
function
handleSeparator
(
aElt
)
{
let
frame
=
this
.
_curFrame
;
let
separator
=
{
type
:
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
}
;
frame
.
folder
.
children
.
push
(
separator
)
;
frame
.
previousItem
=
separator
;
}
_handleHeadBegin
:
function
handleHeadBegin
(
aElt
)
{
let
frame
=
this
.
_curFrame
;
frame
.
previousLink
=
null
;
frame
.
lastContainerType
=
Container_Normal
;
if
(
frame
.
containerNesting
=
=
0
&
&
this
.
_frames
.
length
>
1
)
{
this
.
_frames
.
pop
(
)
;
}
if
(
aElt
.
hasAttribute
(
"
personal_toolbar_folder
"
)
)
{
if
(
this
.
_isImportDefaults
)
{
frame
.
lastContainerType
=
Container_Toolbar
;
}
}
else
if
(
aElt
.
hasAttribute
(
"
bookmarks_menu
"
)
)
{
if
(
this
.
_isImportDefaults
)
{
frame
.
lastContainerType
=
Container_Menu
;
}
}
else
if
(
aElt
.
hasAttribute
(
"
unfiled_bookmarks_folder
"
)
)
{
if
(
this
.
_isImportDefaults
)
{
frame
.
lastContainerType
=
Container_Unfiled
;
}
}
else
if
(
aElt
.
hasAttribute
(
"
places_root
"
)
)
{
if
(
this
.
_isImportDefaults
)
{
frame
.
lastContainerType
=
Container_Places
;
}
}
else
{
let
addDate
=
aElt
.
getAttribute
(
"
add_date
"
)
;
if
(
addDate
)
{
frame
.
previousDateAdded
=
this
.
_convertImportedDateToInternalDate
(
addDate
)
;
}
let
modDate
=
aElt
.
getAttribute
(
"
last_modified
"
)
;
if
(
modDate
)
{
frame
.
previousLastModifiedDate
=
this
.
_convertImportedDateToInternalDate
(
modDate
)
;
}
}
this
.
_curFrame
.
previousText
=
"
"
;
}
_handleLinkBegin
:
function
handleLinkBegin
(
aElt
)
{
let
frame
=
this
.
_curFrame
;
frame
.
previousFeed
=
null
;
frame
.
previousItem
=
null
;
frame
.
previousText
=
"
"
;
let
href
=
this
.
_safeTrim
(
aElt
.
getAttribute
(
"
href
"
)
)
;
let
feedUrl
=
this
.
_safeTrim
(
aElt
.
getAttribute
(
"
feedurl
"
)
)
;
let
icon
=
this
.
_safeTrim
(
aElt
.
getAttribute
(
"
icon
"
)
)
;
let
iconUri
=
this
.
_safeTrim
(
aElt
.
getAttribute
(
"
icon_uri
"
)
)
;
let
lastCharset
=
this
.
_safeTrim
(
aElt
.
getAttribute
(
"
last_charset
"
)
)
;
let
keyword
=
this
.
_safeTrim
(
aElt
.
getAttribute
(
"
shortcuturl
"
)
)
;
let
postData
=
this
.
_safeTrim
(
aElt
.
getAttribute
(
"
post_data
"
)
)
;
let
webPanel
=
this
.
_safeTrim
(
aElt
.
getAttribute
(
"
web_panel
"
)
)
;
let
dateAdded
=
this
.
_safeTrim
(
aElt
.
getAttribute
(
"
add_date
"
)
)
;
let
lastModified
=
this
.
_safeTrim
(
aElt
.
getAttribute
(
"
last_modified
"
)
)
;
let
tags
=
this
.
_safeTrim
(
aElt
.
getAttribute
(
"
tags
"
)
)
;
if
(
feedUrl
)
{
frame
.
previousFeed
=
feedUrl
;
}
if
(
href
)
{
try
{
frame
.
previousLink
=
Services
.
io
.
newURI
(
href
)
.
spec
;
}
catch
(
e
)
{
if
(
!
frame
.
previousFeed
)
{
frame
.
previousLink
=
null
;
return
;
}
}
}
else
{
frame
.
previousLink
=
null
;
if
(
!
frame
.
previousFeed
)
{
return
;
}
}
let
bookmark
=
{
}
;
if
(
frame
.
previousLink
&
&
!
frame
.
previousFeed
)
{
bookmark
.
url
=
frame
.
previousLink
;
}
if
(
dateAdded
)
{
bookmark
.
dateAdded
=
this
.
_convertImportedDateToInternalDate
(
dateAdded
)
;
}
if
(
lastModified
)
{
bookmark
.
lastModified
=
this
.
_convertImportedDateToInternalDate
(
lastModified
)
;
}
if
(
!
dateAdded
&
&
lastModified
)
{
bookmark
.
dateAdded
=
bookmark
.
lastModified
;
}
if
(
frame
.
previousFeed
)
{
frame
.
folder
.
children
.
push
(
bookmark
)
;
frame
.
previousItem
=
bookmark
;
return
;
}
if
(
tags
)
{
bookmark
.
tags
=
tags
.
split
(
"
"
)
.
filter
(
aTag
=
>
aTag
.
length
>
0
&
&
aTag
.
length
<
=
Ci
.
nsITaggingService
.
MAX_TAG_LENGTH
)
;
if
(
!
bookmark
.
tags
.
length
)
{
delete
bookmark
.
tags
;
}
}
if
(
webPanel
&
&
webPanel
.
toLowerCase
(
)
=
=
"
true
"
)
{
if
(
!
bookmark
.
hasOwnProperty
(
"
annos
"
)
)
{
bookmark
.
annos
=
[
]
;
}
bookmark
.
annos
.
push
(
{
"
name
"
:
LOAD_IN_SIDEBAR_ANNO
"
flags
"
:
0
"
expires
"
:
4
"
value
"
:
1
}
)
;
}
if
(
lastCharset
)
{
bookmark
.
charset
=
lastCharset
;
}
if
(
keyword
)
{
bookmark
.
keyword
=
keyword
;
}
if
(
postData
)
{
bookmark
.
postData
=
postData
;
}
if
(
icon
)
{
bookmark
.
icon
=
icon
;
}
if
(
iconUri
)
{
bookmark
.
iconUri
=
iconUri
;
}
frame
.
folder
.
children
.
push
(
bookmark
)
;
frame
.
previousItem
=
bookmark
;
}
_handleContainerBegin
:
function
handleContainerBegin
(
)
{
this
.
_curFrame
.
containerNesting
+
+
;
}
_handleContainerEnd
:
function
handleContainerEnd
(
)
{
let
frame
=
this
.
_curFrame
;
if
(
frame
.
containerNesting
>
0
)
frame
.
containerNesting
-
-
;
if
(
this
.
_frames
.
length
>
1
&
&
frame
.
containerNesting
=
=
0
)
{
this
.
_frames
.
pop
(
)
;
}
}
_handleHeadEnd
:
function
handleHeadEnd
(
)
{
this
.
_newFrame
(
)
;
}
_handleLinkEnd
:
function
handleLinkEnd
(
)
{
let
frame
=
this
.
_curFrame
;
frame
.
previousText
=
frame
.
previousText
.
trim
(
)
;
if
(
frame
.
previousItem
!
=
null
)
{
if
(
frame
.
previousFeed
)
{
if
(
!
frame
.
previousItem
.
hasOwnProperty
(
"
annos
"
)
)
{
frame
.
previousItem
.
annos
=
[
]
;
}
frame
.
previousItem
.
type
=
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
;
frame
.
previousItem
.
annos
.
push
(
{
"
name
"
:
PlacesUtils
.
LMANNO_FEEDURI
"
flags
"
:
0
"
expires
"
:
4
"
value
"
:
frame
.
previousFeed
}
)
;
if
(
frame
.
previousLink
)
{
frame
.
previousItem
.
annos
.
push
(
{
"
name
"
:
PlacesUtils
.
LMANNO_SITEURI
"
flags
"
:
0
"
expires
"
:
4
"
value
"
:
frame
.
previousLink
}
)
;
}
}
frame
.
previousItem
.
title
=
frame
.
previousText
;
}
frame
.
previousText
=
"
"
;
}
_openContainer
:
function
openContainer
(
aElt
)
{
if
(
aElt
.
namespaceURI
!
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
)
{
return
;
}
switch
(
aElt
.
localName
)
{
case
"
h2
"
:
case
"
h3
"
:
case
"
h4
"
:
case
"
h5
"
:
case
"
h6
"
:
this
.
_handleHeadBegin
(
aElt
)
;
break
;
case
"
a
"
:
this
.
_handleLinkBegin
(
aElt
)
;
break
;
case
"
dl
"
:
case
"
ul
"
:
case
"
menu
"
:
this
.
_handleContainerBegin
(
)
;
break
;
case
"
dd
"
:
this
.
_curFrame
.
inDescription
=
true
;
break
;
case
"
hr
"
:
this
.
_handleSeparator
(
aElt
)
;
break
;
}
}
_closeContainer
:
function
closeContainer
(
aElt
)
{
let
frame
=
this
.
_curFrame
;
if
(
frame
.
inDescription
)
{
frame
.
previousText
=
frame
.
previousText
.
trim
(
)
;
if
(
frame
.
previousText
)
{
let
item
=
frame
.
previousLink
?
frame
.
previousItem
:
frame
.
folder
;
if
(
!
item
.
hasOwnProperty
(
"
annos
"
)
)
{
item
.
annos
=
[
]
;
}
item
.
annos
.
push
(
{
"
name
"
:
DESCRIPTION_ANNO
"
flags
"
:
0
"
expires
"
:
4
"
value
"
:
frame
.
previousText
}
)
;
frame
.
previousText
=
"
"
;
}
frame
.
inDescription
=
false
;
}
if
(
aElt
.
namespaceURI
!
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
)
{
return
;
}
switch
(
aElt
.
localName
)
{
case
"
dl
"
:
case
"
ul
"
:
case
"
menu
"
:
this
.
_handleContainerEnd
(
)
;
break
;
case
"
dt
"
:
break
;
case
"
h1
"
:
break
;
case
"
h2
"
:
case
"
h3
"
:
case
"
h4
"
:
case
"
h5
"
:
case
"
h6
"
:
this
.
_handleHeadEnd
(
)
;
break
;
case
"
a
"
:
this
.
_handleLinkEnd
(
)
;
break
;
default
:
break
;
}
}
_appendText
:
function
appendText
(
str
)
{
this
.
_curFrame
.
previousText
+
=
str
;
}
_convertImportedDateToInternalDate
:
function
convertImportedDateToInternalDate
(
aDate
)
{
try
{
if
(
aDate
&
&
!
isNaN
(
aDate
)
)
{
return
new
Date
(
parseInt
(
aDate
)
*
1000
)
;
}
}
catch
(
ex
)
{
}
return
new
Date
(
)
;
}
_walkTreeForImport
(
aDoc
)
{
if
(
!
aDoc
)
{
return
;
}
let
current
=
aDoc
;
let
next
;
for
(
;
;
)
{
switch
(
current
.
nodeType
)
{
case
current
.
ELEMENT_NODE
:
this
.
_openContainer
(
current
)
;
break
;
case
current
.
TEXT_NODE
:
this
.
_appendText
(
current
.
data
)
;
break
;
}
if
(
(
next
=
current
.
firstChild
)
)
{
current
=
next
;
continue
;
}
for
(
;
;
)
{
if
(
current
.
nodeType
=
=
current
.
ELEMENT_NODE
)
{
this
.
_closeContainer
(
current
)
;
}
if
(
current
=
=
aDoc
)
{
return
;
}
if
(
(
next
=
current
.
nextSibling
)
)
{
current
=
next
;
break
;
}
current
=
current
.
parentNode
;
}
}
}
_getBookmarkTrees
(
)
{
if
(
!
this
.
_isImportDefaults
)
{
return
[
this
.
_bookmarkTree
]
;
}
let
bookmarkTrees
=
[
this
.
_bookmarkTree
]
;
this
.
_bookmarkTree
.
children
=
this
.
_bookmarkTree
.
children
.
filter
(
child
=
>
{
if
(
child
.
guid
&
&
PlacesUtils
.
bookmarks
.
userContentRoots
.
includes
(
child
.
guid
)
)
{
bookmarkTrees
.
push
(
child
)
;
return
false
;
}
return
true
;
}
)
;
return
bookmarkTrees
;
}
async
_importBookmarks
(
)
{
if
(
this
.
_isImportDefaults
)
{
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
}
let
bookmarksTrees
=
this
.
_getBookmarkTrees
(
)
;
for
(
let
tree
of
bookmarksTrees
)
{
if
(
!
tree
.
children
.
length
)
{
continue
;
}
tree
.
source
=
this
.
_source
;
await
PlacesUtils
.
bookmarks
.
insertTree
(
tree
{
fixupOrSkipInvalidEntries
:
true
}
)
;
insertFaviconsForTree
(
tree
)
;
}
}
async
importFromURL
(
href
)
{
let
data
=
await
fetchData
(
href
)
;
this
.
_walkTreeForImport
(
data
)
;
await
this
.
_importBookmarks
(
)
;
}
}
;
function
BookmarkExporter
(
aBookmarksTree
)
{
let
rootsMap
=
new
Map
(
)
;
for
(
let
child
of
aBookmarksTree
.
children
)
{
if
(
child
.
root
)
{
rootsMap
.
set
(
child
.
root
child
)
;
child
.
title
=
PlacesUtils
.
bookmarks
.
getLocalizedTitle
(
child
)
;
}
}
this
.
_root
=
rootsMap
.
get
(
"
bookmarksMenuFolder
"
)
;
for
(
let
key
of
[
"
toolbarFolder
"
"
unfiledBookmarksFolder
"
]
)
{
let
root
=
rootsMap
.
get
(
key
)
;
if
(
root
.
children
&
&
root
.
children
.
length
>
0
)
{
if
(
!
this
.
_root
.
children
)
this
.
_root
.
children
=
[
]
;
this
.
_root
.
children
.
push
(
root
)
;
}
}
}
BookmarkExporter
.
prototype
=
{
exportToFile
:
function
exportToFile
(
aFilePath
)
{
return
(
async
(
)
=
>
{
let
out
=
FileUtils
.
openAtomicFileOutputStream
(
new
FileUtils
.
File
(
aFilePath
)
)
;
try
{
let
bufferedOut
=
Cc
[
"
mozilla
.
org
/
network
/
buffered
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIBufferedOutputStream
)
;
bufferedOut
.
init
(
out
4096
)
;
try
{
this
.
_converterOut
=
Cc
[
"
mozilla
.
org
/
intl
/
converter
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIConverterOutputStream
)
;
this
.
_converterOut
.
init
(
bufferedOut
"
utf
-
8
"
)
;
try
{
this
.
_writeHeader
(
)
;
await
this
.
_writeContainer
(
this
.
_root
)
;
bufferedOut
.
QueryInterface
(
Ci
.
nsISafeOutputStream
)
.
finish
(
)
;
}
finally
{
this
.
_converterOut
.
close
(
)
;
this
.
_converterOut
=
null
;
}
}
finally
{
bufferedOut
.
close
(
)
;
}
}
finally
{
out
.
close
(
)
;
}
}
)
(
)
;
}
_converterOut
:
null
_write
(
aText
)
{
this
.
_converterOut
.
writeString
(
aText
|
|
"
"
)
;
}
_writeAttribute
(
aName
aValue
)
{
this
.
_write
(
"
"
+
aName
+
'
=
"
'
+
aValue
+
'
"
'
)
;
}
_writeLine
(
aText
)
{
this
.
_write
(
aText
+
"
\
n
"
)
;
}
_writeHeader
(
)
{
this
.
_writeLine
(
"
<
!
DOCTYPE
NETSCAPE
-
Bookmark
-
file
-
1
>
"
)
;
this
.
_writeLine
(
"
<
!
-
-
This
is
an
automatically
generated
file
.
"
)
;
this
.
_writeLine
(
"
It
will
be
read
and
overwritten
.
"
)
;
this
.
_writeLine
(
"
DO
NOT
EDIT
!
-
-
>
"
)
;
this
.
_writeLine
(
'
<
META
HTTP
-
EQUIV
=
"
Content
-
Type
"
CONTENT
=
"
text
/
html
;
'
+
'
charset
=
UTF
-
8
"
>
'
)
;
this
.
_writeLine
(
"
<
TITLE
>
Bookmarks
<
/
TITLE
>
"
)
;
}
async
_writeContainer
(
aItem
aIndent
=
"
"
)
{
if
(
aItem
=
=
this
.
_root
)
{
this
.
_writeLine
(
"
<
H1
>
"
+
escapeHtmlEntities
(
this
.
_root
.
title
)
+
"
<
/
H1
>
"
)
;
this
.
_writeLine
(
"
"
)
;
}
else
{
this
.
_write
(
aIndent
+
"
<
DT
>
<
H3
"
)
;
this
.
_writeDateAttributes
(
aItem
)
;
if
(
aItem
.
root
=
=
=
"
toolbarFolder
"
)
this
.
_writeAttribute
(
"
PERSONAL_TOOLBAR_FOLDER
"
"
true
"
)
;
else
if
(
aItem
.
root
=
=
=
"
unfiledBookmarksFolder
"
)
this
.
_writeAttribute
(
"
UNFILED_BOOKMARKS_FOLDER
"
"
true
"
)
;
this
.
_writeLine
(
"
>
"
+
escapeHtmlEntities
(
aItem
.
title
)
+
"
<
/
H3
>
"
)
;
}
this
.
_writeDescription
(
aItem
aIndent
)
;
this
.
_writeLine
(
aIndent
+
"
<
DL
>
<
p
>
"
)
;
if
(
aItem
.
children
)
await
this
.
_writeContainerContents
(
aItem
aIndent
)
;
if
(
aItem
=
=
this
.
_root
)
this
.
_writeLine
(
aIndent
+
"
<
/
DL
>
"
)
;
else
this
.
_writeLine
(
aIndent
+
"
<
/
DL
>
<
p
>
"
)
;
}
async
_writeContainerContents
(
aItem
aIndent
)
{
let
localIndent
=
aIndent
+
EXPORT_INDENT
;
for
(
let
child
of
aItem
.
children
)
{
if
(
child
.
annos
&
&
child
.
annos
.
some
(
anno
=
>
anno
.
name
=
=
PlacesUtils
.
LMANNO_FEEDURI
)
)
{
this
.
_writeLivemark
(
child
localIndent
)
;
}
else
if
(
child
.
type
=
=
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
)
{
await
this
.
_writeContainer
(
child
localIndent
)
;
}
else
if
(
child
.
type
=
=
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
)
{
this
.
_writeSeparator
(
child
localIndent
)
;
}
else
{
await
this
.
_writeItem
(
child
localIndent
)
;
}
}
}
_writeSeparator
(
aItem
aIndent
)
{
this
.
_write
(
aIndent
+
"
<
HR
"
)
;
if
(
aItem
.
title
)
this
.
_writeAttribute
(
"
NAME
"
escapeHtmlEntities
(
aItem
.
title
)
)
;
this
.
_write
(
"
>
"
)
;
}
_writeLivemark
(
aItem
aIndent
)
{
this
.
_write
(
aIndent
+
"
<
DT
>
<
A
"
)
;
let
feedSpec
=
aItem
.
annos
.
find
(
anno
=
>
anno
.
name
=
=
PlacesUtils
.
LMANNO_FEEDURI
)
.
value
;
this
.
_writeAttribute
(
"
FEEDURL
"
escapeUrl
(
feedSpec
)
)
;
let
siteSpecAnno
=
aItem
.
annos
.
find
(
anno
=
>
anno
.
name
=
=
PlacesUtils
.
LMANNO_SITEURI
)
;
if
(
siteSpecAnno
)
this
.
_writeAttribute
(
"
HREF
"
escapeUrl
(
siteSpecAnno
.
value
)
)
;
this
.
_writeLine
(
"
>
"
+
escapeHtmlEntities
(
aItem
.
title
)
+
"
<
/
A
>
"
)
;
this
.
_writeDescription
(
aItem
aIndent
)
;
}
async
_writeItem
(
aItem
aIndent
)
{
try
{
NetUtil
.
newURI
(
aItem
.
uri
)
;
}
catch
(
ex
)
{
return
;
}
this
.
_write
(
aIndent
+
"
<
DT
>
<
A
"
)
;
this
.
_writeAttribute
(
"
HREF
"
escapeUrl
(
aItem
.
uri
)
)
;
this
.
_writeDateAttributes
(
aItem
)
;
await
this
.
_writeFaviconAttribute
(
aItem
)
;
if
(
aItem
.
keyword
)
{
this
.
_writeAttribute
(
"
SHORTCUTURL
"
escapeHtmlEntities
(
aItem
.
keyword
)
)
;
if
(
aItem
.
postData
)
this
.
_writeAttribute
(
"
POST_DATA
"
escapeHtmlEntities
(
aItem
.
postData
)
)
;
}
if
(
aItem
.
annos
&
&
aItem
.
annos
.
some
(
anno
=
>
anno
.
name
=
=
LOAD_IN_SIDEBAR_ANNO
)
)
this
.
_writeAttribute
(
"
WEB_PANEL
"
"
true
"
)
;
if
(
aItem
.
charset
)
this
.
_writeAttribute
(
"
LAST_CHARSET
"
escapeHtmlEntities
(
aItem
.
charset
)
)
;
if
(
aItem
.
tags
)
this
.
_writeAttribute
(
"
TAGS
"
escapeHtmlEntities
(
aItem
.
tags
)
)
;
this
.
_writeLine
(
"
>
"
+
escapeHtmlEntities
(
aItem
.
title
)
+
"
<
/
A
>
"
)
;
this
.
_writeDescription
(
aItem
aIndent
)
;
}
_writeDateAttributes
(
aItem
)
{
if
(
aItem
.
dateAdded
)
this
.
_writeAttribute
(
"
ADD_DATE
"
Math
.
floor
(
aItem
.
dateAdded
/
MICROSEC_PER_SEC
)
)
;
if
(
aItem
.
lastModified
)
this
.
_writeAttribute
(
"
LAST_MODIFIED
"
Math
.
floor
(
aItem
.
lastModified
/
MICROSEC_PER_SEC
)
)
;
}
async
_writeFaviconAttribute
(
aItem
)
{
if
(
!
aItem
.
iconuri
)
return
;
let
favicon
;
try
{
favicon
=
await
PlacesUtils
.
promiseFaviconData
(
aItem
.
uri
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Unexpected
Error
trying
to
fetch
icon
data
"
)
;
return
;
}
this
.
_writeAttribute
(
"
ICON_URI
"
escapeUrl
(
favicon
.
uri
.
spec
)
)
;
if
(
!
favicon
.
uri
.
schemeIs
(
"
chrome
"
)
&
&
favicon
.
dataLen
>
0
)
{
let
faviconContents
=
"
data
:
image
/
png
;
base64
"
+
base64EncodeString
(
String
.
fromCharCode
.
apply
(
String
favicon
.
data
)
)
;
this
.
_writeAttribute
(
"
ICON
"
faviconContents
)
;
}
}
_writeDescription
(
aItem
aIndent
)
{
let
descriptionAnno
=
aItem
.
annos
&
&
aItem
.
annos
.
find
(
anno
=
>
anno
.
name
=
=
DESCRIPTION_ANNO
)
;
if
(
descriptionAnno
)
this
.
_writeLine
(
aIndent
+
"
<
DD
>
"
+
escapeHtmlEntities
(
descriptionAnno
.
value
)
)
;
}
}
;
function
insertFaviconForNode
(
node
)
{
if
(
node
.
icon
)
{
try
{
let
faviconURI
=
Services
.
io
.
newURI
(
"
fake
-
favicon
-
uri
:
"
+
node
.
url
)
;
PlacesUtils
.
favicons
.
replaceFaviconDataFromDataURL
(
faviconURI
node
.
icon
0
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
PlacesUtils
.
favicons
.
setAndFetchFaviconForPage
(
Services
.
io
.
newURI
(
node
.
url
)
faviconURI
false
PlacesUtils
.
favicons
.
FAVICON_LOAD_NON_PRIVATE
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
import
favicon
data
:
"
+
ex
)
;
}
}
if
(
!
node
.
iconUri
)
{
return
;
}
try
{
PlacesUtils
.
favicons
.
setAndFetchFaviconForPage
(
Services
.
io
.
newURI
(
node
.
url
)
Services
.
io
.
newURI
(
node
.
iconUri
)
false
PlacesUtils
.
favicons
.
FAVICON_LOAD_NON_PRIVATE
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
import
favicon
URI
:
"
+
ex
)
;
}
}
function
insertFaviconsForTree
(
nodeTree
)
{
insertFaviconForNode
(
nodeTree
)
;
if
(
nodeTree
.
children
)
{
for
(
let
child
of
nodeTree
.
children
)
{
insertFaviconsForTree
(
child
)
;
}
}
}
function
fetchData
(
href
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
onload
=
(
)
=
>
{
resolve
(
xhr
.
responseXML
)
;
}
;
xhr
.
onabort
=
xhr
.
onerror
=
xhr
.
ontimeout
=
(
)
=
>
{
reject
(
new
Error
(
"
xmlhttprequest
failed
"
)
)
;
}
;
xhr
.
open
(
"
GET
"
href
)
;
xhr
.
responseType
=
"
document
"
;
xhr
.
overrideMimeType
(
"
text
/
html
"
)
;
xhr
.
send
(
)
;
}
)
;
}
