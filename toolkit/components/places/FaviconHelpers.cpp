#
include
"
FaviconHelpers
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsNavHistory
.
h
"
#
include
"
nsFaviconService
.
h
"
#
include
"
mozilla
/
storage
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsIPrivateBrowsingChannel
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
<
algorithm
>
#
include
<
deque
>
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
ImageOps
.
h
"
#
include
"
imgIEncoder
.
h
"
using
namespace
mozilla
:
:
places
;
using
namespace
mozilla
:
:
storage
;
namespace
mozilla
{
namespace
places
{
namespace
{
nsresult
FetchPageInfo
(
const
RefPtr
<
Database
>
&
aDB
PageData
&
_page
)
{
MOZ_ASSERT
(
_page
.
spec
.
Length
(
)
"
Must
have
a
non
-
empty
spec
!
"
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCString
query
=
nsPrintfCString
(
"
SELECT
h
.
id
pi
.
id
h
.
guid
(
"
"
WITH
RECURSIVE
"
"
destinations
(
visit_type
from_visit
place_id
rev_host
bm
)
AS
(
"
"
SELECT
v
.
visit_type
v
.
from_visit
p
.
id
p
.
rev_host
b
.
id
"
"
FROM
moz_places
p
"
"
LEFT
JOIN
moz_historyvisits
v
ON
v
.
place_id
=
p
.
id
"
"
LEFT
JOIN
moz_bookmarks
b
ON
b
.
fk
=
p
.
id
"
"
WHERE
p
.
id
=
h
.
id
"
"
UNION
"
"
SELECT
src
.
visit_type
src
.
from_visit
src
.
place_id
p
.
rev_host
b
.
id
"
"
FROM
moz_places
p
"
"
JOIN
moz_historyvisits
src
ON
src
.
place_id
=
p
.
id
"
"
JOIN
destinations
dest
ON
dest
.
from_visit
=
src
.
id
AND
dest
.
visit_type
"
"
IN
(
%
d
%
d
)
"
"
LEFT
JOIN
moz_bookmarks
b
ON
b
.
fk
=
src
.
place_id
"
"
WHERE
instr
(
p
.
rev_host
dest
.
rev_host
)
=
1
"
"
OR
instr
(
dest
.
rev_host
p
.
rev_host
)
=
1
"
"
)
"
"
SELECT
url
"
"
FROM
moz_places
p
"
"
JOIN
destinations
r
ON
r
.
place_id
=
p
.
id
"
"
WHERE
bm
NOTNULL
"
"
LIMIT
1
"
"
)
fixup_url
(
get_unreversed_host
(
h
.
rev_host
)
)
AS
host
"
"
FROM
moz_places
h
"
"
LEFT
JOIN
moz_pages_w_icons
pi
ON
page_url_hash
=
hash
(
:
page_url
)
AND
"
"
page_url
=
:
page_url
"
"
WHERE
h
.
url_hash
=
hash
(
:
page_url
)
AND
h
.
url
=
:
page_url
"
nsINavHistoryService
:
:
TRANSITION_REDIRECT_PERMANENT
nsINavHistoryService
:
:
TRANSITION_REDIRECT_TEMPORARY
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aDB
-
>
GetStatement
(
query
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
nsresult
rv
=
URIBinder
:
:
Bind
(
stmt
NS_LITERAL_CSTRING
(
"
page_url
"
)
_page
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasResult
;
rv
=
stmt
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
hasResult
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
rv
=
stmt
-
>
GetInt64
(
0
&
_page
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
_page
.
id
=
stmt
-
>
AsInt64
(
1
)
;
rv
=
stmt
-
>
GetUTF8String
(
2
_page
.
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
isNull
;
rv
=
stmt
-
>
GetIsNull
(
3
&
isNull
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isNull
)
{
rv
=
stmt
-
>
GetUTF8String
(
3
_page
.
bookmarkedSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
_page
.
host
.
IsEmpty
(
)
)
{
rv
=
stmt
-
>
GetUTF8String
(
4
_page
.
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
_page
.
canAddToHistory
)
{
if
(
_page
.
bookmarkedSpec
.
IsEmpty
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
else
{
if
(
!
_page
.
bookmarkedSpec
.
Equals
(
_page
.
spec
)
)
{
_page
.
spec
=
_page
.
bookmarkedSpec
;
rv
=
FetchPageInfo
(
aDB
_page
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
return
NS_OK
;
}
nsresult
SetIconInfo
(
const
RefPtr
<
Database
>
&
aDB
IconData
&
aIcon
bool
aMustReplace
=
false
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aIcon
.
payloads
.
Length
(
)
>
0
)
;
MOZ_ASSERT
(
!
aIcon
.
spec
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aIcon
.
expiration
>
0
)
;
nsCOMPtr
<
mozIStorageStatement
>
selectStmt
=
aDB
-
>
GetStatement
(
"
SELECT
id
FROM
moz_icons
"
"
WHERE
fixed_icon_url_hash
=
hash
(
fixup_url
(
:
url
)
)
"
"
AND
icon_url
=
:
url
"
)
;
NS_ENSURE_STATE
(
selectStmt
)
;
mozStorageStatementScoper
scoper
(
selectStmt
)
;
nsresult
rv
=
URIBinder
:
:
Bind
(
selectStmt
NS_LITERAL_CSTRING
(
"
url
"
)
aIcon
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
std
:
:
deque
<
int64_t
>
ids
;
bool
hasResult
=
false
;
while
(
NS_SUCCEEDED
(
selectStmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
int64_t
id
=
selectStmt
-
>
AsInt64
(
0
)
;
MOZ_ASSERT
(
id
>
0
)
;
ids
.
push_back
(
id
)
;
}
if
(
aMustReplace
&
&
ids
.
empty
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
mozIStorageStatement
>
insertStmt
=
aDB
-
>
GetStatement
(
"
INSERT
INTO
moz_icons
"
"
(
icon_url
fixed_icon_url_hash
width
root
expire_ms
data
)
"
"
VALUES
(
:
url
hash
(
fixup_url
(
:
url
)
)
:
width
:
root
:
expire
:
data
)
"
)
;
NS_ENSURE_STATE
(
insertStmt
)
;
nsCOMPtr
<
mozIStorageStatement
>
updateStmt
=
aDB
-
>
GetStatement
(
"
UPDATE
moz_icons
SET
width
=
:
width
"
"
expire_ms
=
:
expire
"
"
data
=
:
data
"
"
root
=
(
root
OR
:
root
)
"
"
WHERE
id
=
:
id
"
)
;
NS_ENSURE_STATE
(
updateStmt
)
;
for
(
auto
&
payload
:
aIcon
.
payloads
)
{
MOZ_ASSERT
(
payload
.
mimeType
.
EqualsLiteral
(
PNG_MIME_TYPE
)
|
|
payload
.
mimeType
.
EqualsLiteral
(
SVG_MIME_TYPE
)
"
Only
png
and
svg
payloads
are
supported
"
)
;
MOZ_ASSERT
(
!
payload
.
mimeType
.
EqualsLiteral
(
SVG_MIME_TYPE
)
|
|
payload
.
width
=
=
UINT16_MAX
"
SVG
payloads
should
have
max
width
"
)
;
MOZ_ASSERT
(
payload
.
width
>
0
"
Payload
should
have
a
width
"
)
;
#
ifdef
DEBUG
payload
.
id
=
0
;
#
endif
if
(
!
ids
.
empty
(
)
)
{
int64_t
id
=
ids
.
front
(
)
;
ids
.
pop_front
(
)
;
mozStorageStatementScoper
scoper
(
updateStmt
)
;
rv
=
updateStmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
id
"
)
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updateStmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
width
"
)
payload
.
width
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updateStmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
expire
"
)
aIcon
.
expiration
/
1000
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updateStmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
root
"
)
aIcon
.
rootIcon
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updateStmt
-
>
BindBlobByName
(
NS_LITERAL_CSTRING
(
"
data
"
)
TO_INTBUFFER
(
payload
.
data
)
payload
.
data
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updateStmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
payload
.
id
=
id
;
}
else
{
mozStorageStatementScoper
scoper
(
insertStmt
)
;
rv
=
URIBinder
:
:
Bind
(
insertStmt
NS_LITERAL_CSTRING
(
"
url
"
)
aIcon
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
insertStmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
width
"
)
payload
.
width
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
insertStmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
root
"
)
aIcon
.
rootIcon
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
insertStmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
expire
"
)
aIcon
.
expiration
/
1000
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
insertStmt
-
>
BindBlobByName
(
NS_LITERAL_CSTRING
(
"
data
"
)
TO_INTBUFFER
(
payload
.
data
)
payload
.
data
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
insertStmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
payload
.
id
=
nsFaviconService
:
:
sLastInsertedIconId
;
}
MOZ_ASSERT
(
payload
.
id
>
0
"
Payload
should
have
an
id
"
)
;
}
if
(
!
ids
.
empty
(
)
)
{
nsAutoCString
sql
(
"
DELETE
FROM
moz_icons
WHERE
id
IN
(
"
)
;
for
(
int64_t
id
:
ids
)
{
sql
.
AppendInt
(
id
)
;
sql
.
AppendLiteral
(
"
"
)
;
}
sql
.
AppendLiteral
(
"
0
)
"
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aDB
-
>
GetStatement
(
sql
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
FetchIconInfo
(
const
RefPtr
<
Database
>
&
aDB
uint16_t
aPreferredWidth
IconData
&
_icon
)
{
MOZ_ASSERT
(
_icon
.
spec
.
Length
(
)
"
Must
have
a
non
-
empty
spec
!
"
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
_icon
.
status
&
ICON_STATUS_CACHED
)
{
return
NS_OK
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aDB
-
>
GetStatement
(
"
/
*
do
not
warn
(
bug
no
:
not
worth
having
a
compound
index
)
*
/
"
"
SELECT
id
expire_ms
data
width
root
"
"
FROM
moz_icons
"
"
WHERE
fixed_icon_url_hash
=
hash
(
fixup_url
(
:
url
)
)
"
"
AND
icon_url
=
:
url
"
"
ORDER
BY
width
DESC
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
DebugOnly
<
nsresult
>
rv
=
URIBinder
:
:
Bind
(
stmt
NS_LITERAL_CSTRING
(
"
url
"
)
_icon
.
spec
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
bool
hasResult
=
false
;
while
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
IconPayload
payload
;
rv
=
stmt
-
>
GetInt64
(
0
&
payload
.
id
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
bool
isNull
;
rv
=
stmt
-
>
GetIsNull
(
1
&
isNull
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
isNull
)
{
int64_t
expire_ms
;
rv
=
stmt
-
>
GetInt64
(
1
&
expire_ms
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
_icon
.
expiration
=
expire_ms
*
1000
;
}
uint8_t
*
data
;
uint32_t
dataLen
=
0
;
rv
=
stmt
-
>
GetBlob
(
2
&
dataLen
&
data
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
payload
.
data
.
Adopt
(
TO_CHARBUFFER
(
data
)
dataLen
)
;
int32_t
width
;
rv
=
stmt
-
>
GetInt32
(
3
&
width
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
payload
.
width
=
width
;
if
(
payload
.
width
=
=
UINT16_MAX
)
{
payload
.
mimeType
.
AssignLiteral
(
SVG_MIME_TYPE
)
;
}
else
{
payload
.
mimeType
.
AssignLiteral
(
PNG_MIME_TYPE
)
;
}
int32_t
rootIcon
;
rv
=
stmt
-
>
GetInt32
(
4
&
rootIcon
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
_icon
.
rootIcon
=
rootIcon
;
if
(
aPreferredWidth
=
=
0
|
|
_icon
.
payloads
.
Length
(
)
=
=
0
)
{
_icon
.
payloads
.
AppendElement
(
payload
)
;
}
else
if
(
payload
.
width
>
=
aPreferredWidth
)
{
_icon
.
payloads
.
ReplaceElementAt
(
0
payload
)
;
}
else
{
break
;
}
}
return
NS_OK
;
}
nsresult
FetchIconPerSpec
(
const
RefPtr
<
Database
>
&
aDB
const
nsACString
&
aPageSpec
const
nsACString
&
aPageHost
IconData
&
aIconData
uint16_t
aPreferredWidth
)
{
MOZ_ASSERT
(
!
aPageSpec
.
IsEmpty
(
)
"
Page
spec
must
not
be
empty
.
"
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aDB
-
>
GetStatement
(
"
/
*
do
not
warn
(
bug
no
:
not
worth
having
a
compound
index
)
*
/
"
"
SELECT
width
icon_url
root
"
"
FROM
moz_icons
i
"
"
JOIN
moz_icons_to_pages
ON
i
.
id
=
icon_id
"
"
JOIN
moz_pages_w_icons
p
ON
p
.
id
=
page_id
"
"
WHERE
page_url_hash
=
hash
(
:
url
)
AND
page_url
=
:
url
"
"
OR
(
:
hash_idx
AND
page_url_hash
=
hash
(
substr
(
:
url
0
:
hash_idx
)
)
"
"
AND
page_url
=
substr
(
:
url
0
:
hash_idx
)
)
"
"
UNION
ALL
"
"
SELECT
width
icon_url
root
"
"
FROM
moz_icons
i
"
"
WHERE
fixed_icon_url_hash
=
hash
(
fixup_url
(
:
root_icon_url
)
)
"
"
ORDER
BY
width
DESC
root
ASC
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
nsresult
rv
=
URIBinder
:
:
Bind
(
stmt
NS_LITERAL_CSTRING
(
"
url
"
)
aPageSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
rootIconFixedUrl
(
aPageHost
)
;
if
(
!
rootIconFixedUrl
.
IsEmpty
(
)
)
{
rootIconFixedUrl
.
AppendLiteral
(
"
/
favicon
.
ico
"
)
;
}
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
root_icon_url
"
)
rootIconFixedUrl
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
hashIdx
=
PromiseFlatCString
(
aPageSpec
)
.
RFind
(
"
#
"
)
;
rv
=
stmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
hash_idx
"
)
hashIdx
+
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasResult
;
int32_t
lastWidth
=
0
;
while
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
int32_t
width
;
rv
=
stmt
-
>
GetInt32
(
0
&
width
)
;
if
(
lastWidth
=
=
width
)
{
continue
;
}
if
(
!
aIconData
.
spec
.
IsEmpty
(
)
&
&
width
<
aPreferredWidth
)
{
break
;
}
lastWidth
=
width
;
rv
=
stmt
-
>
GetUTF8String
(
1
aIconData
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
PRTime
GetExpirationTimeFromChannel
(
nsIChannel
*
aChannel
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
PRTime
expiration
=
-
1
;
nsCOMPtr
<
nsICachingChannel
>
cachingChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
cachingChannel
)
{
nsCOMPtr
<
nsISupports
>
cacheToken
;
nsresult
rv
=
cachingChannel
-
>
GetCacheToken
(
getter_AddRefs
(
cacheToken
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsICacheEntry
>
cacheEntry
=
do_QueryInterface
(
cacheToken
)
;
uint32_t
seconds
;
rv
=
cacheEntry
-
>
GetExpirationTime
(
&
seconds
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
expiration
=
PR_Now
(
)
+
std
:
:
min
(
(
PRTime
)
seconds
*
PR_USEC_PER_SEC
MAX_FAVICON_EXPIRATION
)
;
}
}
}
return
expiration
<
0
?
PR_Now
(
)
+
MAX_FAVICON_EXPIRATION
:
expiration
;
}
}
NS_IMPL_ISUPPORTS_INHERITED
(
AsyncFetchAndSetIconForPage
Runnable
nsIStreamListener
nsIInterfaceRequestor
nsIChannelEventSink
mozIPlacesPendingOperation
)
AsyncFetchAndSetIconForPage
:
:
AsyncFetchAndSetIconForPage
(
IconData
&
aIcon
PageData
&
aPage
bool
aFaviconLoadPrivate
nsIFaviconDataCallback
*
aCallback
nsIPrincipal
*
aLoadingPrincipal
uint64_t
aRequestContextID
)
:
Runnable
(
"
places
:
:
AsyncFetchAndSetIconForPage
"
)
mCallback
(
new
nsMainThreadPtrHolder
<
nsIFaviconDataCallback
>
(
"
AsyncFetchAndSetIconForPage
:
:
mCallback
"
aCallback
)
)
mIcon
(
aIcon
)
mPage
(
aPage
)
mFaviconLoadPrivate
(
aFaviconLoadPrivate
)
mLoadingPrincipal
(
new
nsMainThreadPtrHolder
<
nsIPrincipal
>
(
"
AsyncFetchAndSetIconForPage
:
:
mLoadingPrincipal
"
aLoadingPrincipal
)
)
mCanceled
(
false
)
mRequestContextID
(
aRequestContextID
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
NS_IMETHODIMP
AsyncFetchAndSetIconForPage
:
:
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
nsresult
rv
=
FetchIconInfo
(
DB
0
mIcon
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
isInvalidIcon
=
!
mIcon
.
payloads
.
Length
(
)
|
|
PR_Now
(
)
>
mIcon
.
expiration
;
bool
fetchIconFromNetwork
=
mIcon
.
fetchMode
=
=
FETCH_ALWAYS
|
|
(
mIcon
.
fetchMode
=
=
FETCH_IF_MISSING
&
&
isInvalidIcon
)
;
rv
=
FetchPageInfo
(
DB
mPage
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
if
(
!
mPage
.
canAddToHistory
)
{
return
NS_OK
;
}
}
return
rv
;
}
if
(
!
fetchIconFromNetwork
)
{
RefPtr
<
AsyncAssociateIconToPage
>
event
=
new
AsyncAssociateIconToPage
(
mIcon
mPage
mCallback
)
;
return
event
-
>
Run
(
)
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
places
:
:
AsyncFetchAndSetIconForPage
:
:
FetchFromNetwork
"
this
&
AsyncFetchAndSetIconForPage
:
:
FetchFromNetwork
)
;
return
NS_DispatchToMainThread
(
event
)
;
}
nsresult
AsyncFetchAndSetIconForPage
:
:
FetchFromNetwork
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mCanceled
)
{
return
NS_OK
;
}
mIcon
.
payloads
.
Clear
(
)
;
IconPayload
payload
;
mIcon
.
payloads
.
AppendElement
(
payload
)
;
nsCOMPtr
<
nsIURI
>
iconURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
iconURI
)
mIcon
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
iconURI
mLoadingPrincipal
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
|
nsILoadInfo
:
:
SEC_ALLOW_CHROME
|
nsILoadInfo
:
:
SEC_DISALLOW_SCRIPT
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
listenerRequestor
=
do_QueryInterface
(
reinterpret_cast
<
nsISupports
*
>
(
this
)
)
;
NS_ENSURE_STATE
(
listenerRequestor
)
;
rv
=
channel
-
>
SetNotificationCallbacks
(
listenerRequestor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrivateBrowsingChannel
>
pbChannel
=
do_QueryInterface
(
channel
)
;
if
(
pbChannel
)
{
rv
=
pbChannel
-
>
SetPrivate
(
mFaviconLoadPrivate
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsISupportsPriority
>
priorityChannel
=
do_QueryInterface
(
channel
)
;
if
(
priorityChannel
)
{
priorityChannel
-
>
AdjustPriority
(
nsISupportsPriority
:
:
PRIORITY_LOWEST
)
;
}
if
(
nsContentUtils
:
:
IsTailingEnabled
(
)
)
{
nsCOMPtr
<
nsIClassOfService
>
cos
=
do_QueryInterface
(
channel
)
;
if
(
cos
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Tail
|
nsIClassOfService
:
:
Throttleable
)
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
channel
)
)
;
if
(
httpChannel
)
{
Unused
<
<
httpChannel
-
>
SetRequestContextID
(
mRequestContextID
)
;
}
}
rv
=
channel
-
>
AsyncOpen
(
this
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mRequest
=
channel
;
}
return
rv
;
}
NS_IMETHODIMP
AsyncFetchAndSetIconForPage
:
:
Cancel
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mCanceled
)
{
return
NS_ERROR_UNEXPECTED
;
}
mCanceled
=
true
;
if
(
mRequest
)
{
mRequest
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AsyncFetchAndSetIconForPage
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
mRequest
=
aRequest
;
if
(
mCanceled
)
{
mRequest
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AsyncFetchAndSetIconForPage
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
MOZ_ASSERT
(
mIcon
.
payloads
.
Length
(
)
=
=
1
)
;
const
size_t
kMaxDownloadSize
=
500
*
1024
;
if
(
mIcon
.
payloads
[
0
]
.
data
.
Length
(
)
+
aCount
>
kMaxDownloadSize
)
{
mIcon
.
payloads
.
Clear
(
)
;
return
NS_ERROR_FILE_TOO_BIG
;
}
nsAutoCString
buffer
;
nsresult
rv
=
NS_ConsumeStream
(
aInputStream
aCount
buffer
)
;
if
(
rv
!
=
NS_BASE_STREAM_WOULD_BLOCK
&
&
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
mIcon
.
payloads
[
0
]
.
data
.
Append
(
buffer
fallible
)
)
{
mIcon
.
payloads
.
Clear
(
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AsyncFetchAndSetIconForPage
:
:
GetInterface
(
const
nsIID
&
uuid
void
*
*
aResult
)
{
return
QueryInterface
(
uuid
aResult
)
;
}
NS_IMETHODIMP
AsyncFetchAndSetIconForPage
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
oldChannel
nsIChannel
*
newChannel
uint32_t
flags
nsIAsyncVerifyRedirectCallback
*
cb
)
{
(
void
)
cb
-
>
OnRedirectVerifyCallback
(
mCanceled
?
NS_BINDING_ABORTED
:
NS_OK
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AsyncFetchAndSetIconForPage
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatusCode
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mRequest
=
nullptr
;
if
(
mCanceled
)
{
return
NS_OK
;
}
nsFaviconService
*
favicons
=
nsFaviconService
:
:
GetFaviconService
(
)
;
NS_ENSURE_STATE
(
favicons
)
;
nsresult
rv
;
if
(
NS_FAILED
(
aStatusCode
)
|
|
mIcon
.
payloads
.
Length
(
)
=
=
0
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
MOZ_ASSERT
(
channel
)
;
MOZ_ASSERT
(
mIcon
.
payloads
.
Length
(
)
=
=
1
)
;
IconPayload
&
payload
=
mIcon
.
payloads
[
0
]
;
nsAutoCString
contentType
;
channel
-
>
GetContentType
(
contentType
)
;
if
(
contentType
.
EqualsLiteral
(
SVG_MIME_TYPE
)
)
{
payload
.
mimeType
.
AssignLiteral
(
SVG_MIME_TYPE
)
;
payload
.
width
=
UINT16_MAX
;
}
else
{
NS_SniffContent
(
NS_DATA_SNIFFER_CATEGORY
aRequest
TO_INTBUFFER
(
payload
.
data
)
payload
.
data
.
Length
(
)
payload
.
mimeType
)
;
}
if
(
payload
.
mimeType
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
mIcon
.
expiration
=
GetExpirationTimeFromChannel
(
channel
)
;
if
(
payload
.
mimeType
.
EqualsLiteral
(
PNG_MIME_TYPE
)
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
PLACES_FAVICON_PNG_SIZES
payload
.
data
.
Length
(
)
)
;
}
else
if
(
payload
.
mimeType
.
EqualsLiteral
(
"
image
/
x
-
icon
"
)
|
|
payload
.
mimeType
.
EqualsLiteral
(
"
image
/
vnd
.
microsoft
.
icon
"
)
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
PLACES_FAVICON_ICO_SIZES
payload
.
data
.
Length
(
)
)
;
}
else
if
(
payload
.
mimeType
.
EqualsLiteral
(
"
image
/
jpeg
"
)
|
|
payload
.
mimeType
.
EqualsLiteral
(
"
image
/
pjpeg
"
)
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
PLACES_FAVICON_JPEG_SIZES
payload
.
data
.
Length
(
)
)
;
}
else
if
(
payload
.
mimeType
.
EqualsLiteral
(
"
image
/
gif
"
)
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
PLACES_FAVICON_GIF_SIZES
payload
.
data
.
Length
(
)
)
;
}
else
if
(
payload
.
mimeType
.
EqualsLiteral
(
"
image
/
bmp
"
)
|
|
payload
.
mimeType
.
EqualsLiteral
(
"
image
/
x
-
windows
-
bmp
"
)
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
PLACES_FAVICON_BMP_SIZES
payload
.
data
.
Length
(
)
)
;
}
else
if
(
payload
.
mimeType
.
EqualsLiteral
(
SVG_MIME_TYPE
)
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
PLACES_FAVICON_SVG_SIZES
payload
.
data
.
Length
(
)
)
;
}
else
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
PLACES_FAVICON_OTHER_SIZES
payload
.
data
.
Length
(
)
)
;
}
rv
=
favicons
-
>
OptimizeIconSizes
(
mIcon
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mIcon
.
payloads
.
Length
(
)
=
=
0
)
{
return
NS_OK
;
}
mIcon
.
status
=
ICON_STATUS_CHANGED
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
RefPtr
<
AsyncAssociateIconToPage
>
event
=
new
AsyncAssociateIconToPage
(
mIcon
mPage
mCallback
)
;
DB
-
>
DispatchToAsyncThread
(
event
)
;
return
NS_OK
;
}
AsyncAssociateIconToPage
:
:
AsyncAssociateIconToPage
(
const
IconData
&
aIcon
const
PageData
&
aPage
const
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
&
aCallback
)
:
Runnable
(
"
places
:
:
AsyncAssociateIconToPage
"
)
mCallback
(
aCallback
)
mIcon
(
aIcon
)
mPage
(
aPage
)
{
}
NS_IMETHODIMP
AsyncAssociateIconToPage
:
:
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mPage
.
guid
.
IsEmpty
(
)
"
Page
info
should
have
been
fetched
already
"
)
;
MOZ_ASSERT
(
mPage
.
canAddToHistory
|
|
!
mPage
.
bookmarkedSpec
.
IsEmpty
(
)
"
The
page
should
be
addable
to
history
or
a
bookmark
"
)
;
bool
shouldUpdateIcon
=
mIcon
.
status
&
ICON_STATUS_CHANGED
;
if
(
!
shouldUpdateIcon
)
{
for
(
const
auto
&
payload
:
mIcon
.
payloads
)
{
if
(
payload
.
id
=
=
0
)
{
shouldUpdateIcon
=
true
;
break
;
}
}
}
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
mozStorageTransaction
transaction
(
DB
-
>
MainConn
(
)
false
mozIStorageConnection
:
:
TRANSACTION_IMMEDIATE
)
;
nsresult
rv
;
if
(
shouldUpdateIcon
)
{
rv
=
SetIconInfo
(
DB
mIcon
)
;
if
(
NS_FAILED
(
rv
)
)
{
(
void
)
transaction
.
Commit
(
)
;
return
rv
;
}
mIcon
.
status
=
(
mIcon
.
status
&
~
(
ICON_STATUS_CACHED
)
)
|
ICON_STATUS_SAVED
;
}
if
(
mPage
.
placeId
=
=
0
)
{
rv
=
transaction
.
Commit
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
if
(
!
mIcon
.
rootIcon
|
|
!
mIcon
.
host
.
Equals
(
mPage
.
host
)
)
{
if
(
mPage
.
id
!
=
0
)
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
stmt
=
DB
-
>
GetStatement
(
"
DELETE
FROM
moz_icons_to_pages
"
"
WHERE
icon_id
IN
(
"
"
SELECT
icon_id
FROM
moz_icons_to_pages
"
"
JOIN
moz_icons
i
ON
icon_id
=
i
.
id
"
"
WHERE
page_id
=
:
page_id
"
"
AND
expire_ms
<
strftime
(
'
%
s
'
'
now
'
'
localtime
'
'
start
of
day
'
'
-
7
"
"
days
'
'
utc
'
)
*
1000
"
"
)
AND
page_id
=
:
page_id
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
page_id
"
)
mPage
.
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
stmt
=
DB
-
>
GetStatement
(
"
INSERT
OR
IGNORE
INTO
moz_pages_w_icons
(
page_url
page_url_hash
)
"
"
VALUES
(
:
page_url
hash
(
:
page_url
)
)
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
URIBinder
:
:
Bind
(
stmt
NS_LITERAL_CSTRING
(
"
page_url
"
)
mPage
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
stmt
=
DB
-
>
GetStatement
(
"
INSERT
OR
IGNORE
INTO
moz_icons_to_pages
(
page_id
icon_id
)
"
"
VALUES
(
(
SELECT
id
from
moz_pages_w_icons
WHERE
page_url_hash
=
"
"
hash
(
:
page_url
)
AND
page_url
=
:
page_url
)
"
"
:
icon_id
)
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
for
(
const
auto
&
payload
:
mIcon
.
payloads
)
{
mozStorageStatementScoper
scoper
(
stmt
)
;
nsCOMPtr
<
mozIStorageBindingParams
>
params
;
rv
=
URIBinder
:
:
Bind
(
stmt
NS_LITERAL_CSTRING
(
"
page_url
"
)
mPage
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
icon_id
"
)
payload
.
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
mIcon
.
status
|
=
ICON_STATUS_ASSOCIATED
;
rv
=
transaction
.
Commit
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyIconObservers
(
mIcon
mPage
mCallback
)
;
rv
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mPage
.
bookmarkedSpec
.
IsEmpty
(
)
&
&
!
mPage
.
bookmarkedSpec
.
Equals
(
mPage
.
spec
)
)
{
PageData
bookmarkedPage
;
bookmarkedPage
.
spec
=
mPage
.
bookmarkedSpec
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
if
(
DB
&
&
NS_SUCCEEDED
(
FetchPageInfo
(
DB
bookmarkedPage
)
)
)
{
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
nullCallback
;
RefPtr
<
AsyncAssociateIconToPage
>
event
=
new
AsyncAssociateIconToPage
(
mIcon
bookmarkedPage
nullCallback
)
;
Unused
<
<
event
-
>
Run
(
)
;
}
}
return
NS_OK
;
}
AsyncGetFaviconURLForPage
:
:
AsyncGetFaviconURLForPage
(
const
nsACString
&
aPageSpec
const
nsACString
&
aPageHost
uint16_t
aPreferredWidth
nsIFaviconDataCallback
*
aCallback
)
:
Runnable
(
"
places
:
:
AsyncGetFaviconURLForPage
"
)
mPreferredWidth
(
aPreferredWidth
=
=
0
?
UINT16_MAX
:
aPreferredWidth
)
mCallback
(
new
nsMainThreadPtrHolder
<
nsIFaviconDataCallback
>
(
"
AsyncGetFaviconURLForPage
:
:
mCallback
"
aCallback
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mPageSpec
.
Assign
(
aPageSpec
)
;
mPageHost
.
Assign
(
aPageHost
)
;
}
NS_IMETHODIMP
AsyncGetFaviconURLForPage
:
:
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
IconData
iconData
;
nsresult
rv
=
FetchIconPerSpec
(
DB
mPageSpec
mPageHost
iconData
mPreferredWidth
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
PageData
pageData
;
pageData
.
spec
.
Assign
(
mPageSpec
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyIconObservers
(
iconData
pageData
mCallback
)
;
rv
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
AsyncGetFaviconDataForPage
:
:
AsyncGetFaviconDataForPage
(
const
nsACString
&
aPageSpec
const
nsACString
&
aPageHost
uint16_t
aPreferredWidth
nsIFaviconDataCallback
*
aCallback
)
:
Runnable
(
"
places
:
:
AsyncGetFaviconDataForPage
"
)
mPreferredWidth
(
aPreferredWidth
=
=
0
?
UINT16_MAX
:
aPreferredWidth
)
mCallback
(
new
nsMainThreadPtrHolder
<
nsIFaviconDataCallback
>
(
"
AsyncGetFaviconDataForPage
:
:
mCallback
"
aCallback
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mPageSpec
.
Assign
(
aPageSpec
)
;
mPageHost
.
Assign
(
aPageHost
)
;
}
NS_IMETHODIMP
AsyncGetFaviconDataForPage
:
:
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
IconData
iconData
;
nsresult
rv
=
FetchIconPerSpec
(
DB
mPageSpec
mPageHost
iconData
mPreferredWidth
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
iconData
.
spec
.
IsEmpty
(
)
)
{
rv
=
FetchIconInfo
(
DB
mPreferredWidth
iconData
)
;
if
(
NS_FAILED
(
rv
)
)
{
iconData
.
spec
.
Truncate
(
)
;
}
}
PageData
pageData
;
pageData
.
spec
.
Assign
(
mPageSpec
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyIconObservers
(
iconData
pageData
mCallback
)
;
rv
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
AsyncReplaceFaviconData
:
:
AsyncReplaceFaviconData
(
const
IconData
&
aIcon
)
:
Runnable
(
"
places
:
:
AsyncReplaceFaviconData
"
)
mIcon
(
aIcon
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
NS_IMETHODIMP
AsyncReplaceFaviconData
:
:
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
mozStorageTransaction
transaction
(
DB
-
>
MainConn
(
)
false
mozIStorageConnection
:
:
TRANSACTION_IMMEDIATE
)
;
nsresult
rv
=
SetIconInfo
(
DB
mIcon
true
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
(
void
)
transaction
.
Commit
(
)
;
return
NS_OK
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
transaction
.
Commit
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
places
:
:
AsyncReplaceFaviconData
:
:
RemoveIconDataCacheEntry
"
this
&
AsyncReplaceFaviconData
:
:
RemoveIconDataCacheEntry
)
;
rv
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
AsyncReplaceFaviconData
:
:
RemoveIconDataCacheEntry
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIURI
>
iconURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
iconURI
)
mIcon
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsFaviconService
*
favicons
=
nsFaviconService
:
:
GetFaviconService
(
)
;
NS_ENSURE_STATE
(
favicons
)
;
favicons
-
>
mUnassociatedIcons
.
RemoveEntry
(
iconURI
)
;
return
NS_OK
;
}
NotifyIconObservers
:
:
NotifyIconObservers
(
const
IconData
&
aIcon
const
PageData
&
aPage
const
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
&
aCallback
)
:
Runnable
(
"
places
:
:
NotifyIconObservers
"
)
mCallback
(
aCallback
)
mIcon
(
aIcon
)
mPage
(
aPage
)
{
}
NS_IMETHODIMP
NotifyIconObservers
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIURI
>
iconURI
;
if
(
!
mIcon
.
spec
.
IsEmpty
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
iconURI
)
mIcon
.
spec
)
)
;
if
(
iconURI
)
{
if
(
mIcon
.
status
&
ICON_STATUS_SAVED
|
|
mIcon
.
status
&
ICON_STATUS_ASSOCIATED
)
{
nsCOMPtr
<
nsIURI
>
pageURI
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
pageURI
)
mPage
.
spec
)
)
;
if
(
pageURI
)
{
nsFaviconService
*
favicons
=
nsFaviconService
:
:
GetFaviconService
(
)
;
MOZ_ASSERT
(
favicons
)
;
if
(
favicons
)
{
(
void
)
favicons
-
>
SendFaviconNotifications
(
pageURI
iconURI
mPage
.
guid
)
;
}
}
}
}
}
if
(
!
mCallback
)
{
return
NS_OK
;
}
if
(
mIcon
.
payloads
.
Length
(
)
>
0
)
{
IconPayload
&
payload
=
mIcon
.
payloads
[
0
]
;
return
mCallback
-
>
OnComplete
(
iconURI
payload
.
data
.
Length
(
)
TO_INTBUFFER
(
payload
.
data
)
payload
.
mimeType
payload
.
width
)
;
}
return
mCallback
-
>
OnComplete
(
iconURI
0
TO_INTBUFFER
(
EmptyCString
(
)
)
EmptyCString
(
)
0
)
;
}
FetchAndConvertUnsupportedPayloads
:
:
FetchAndConvertUnsupportedPayloads
(
mozIStorageConnection
*
aDBConn
)
:
Runnable
(
"
places
:
:
FetchAndConvertUnsupportedPayloads
"
)
mDB
(
aDBConn
)
{
}
NS_IMETHODIMP
FetchAndConvertUnsupportedPayloads
:
:
Run
(
)
{
if
(
NS_IsMainThread
(
)
)
{
Preferences
:
:
ClearUser
(
PREF_CONVERT_PAYLOADS
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
NS_ENSURE_STATE
(
mDB
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
nsresult
rv
=
mDB
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
id
width
data
FROM
moz_icons
WHERE
typeof
(
width
)
=
'
text
'
"
"
ORDER
BY
id
ASC
"
"
LIMIT
200
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mozStorageTransaction
transaction
(
mDB
false
mozIStorageConnection
:
:
TRANSACTION_IMMEDIATE
)
;
uint8_t
count
=
0
;
bool
hasResult
;
while
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
+
+
count
;
int64_t
id
=
stmt
-
>
AsInt64
(
0
)
;
MOZ_ASSERT
(
id
>
0
)
;
nsAutoCString
mimeType
;
rv
=
stmt
-
>
GetUTF8String
(
1
mimeType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
uint8_t
*
data
;
uint32_t
dataLen
=
0
;
rv
=
stmt
-
>
GetBlob
(
2
&
dataLen
&
data
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
nsCString
buf
;
buf
.
Adopt
(
TO_CHARBUFFER
(
data
)
dataLen
)
;
int32_t
width
=
0
;
rv
=
ConvertPayload
(
id
mimeType
buf
&
width
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
StorePayload
(
id
width
buf
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
}
}
rv
=
transaction
.
Commit
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
count
=
=
200
)
{
return
NS_DispatchToCurrentThread
(
this
)
;
}
rv
=
mDB
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DELETE
FROM
moz_icons
WHERE
typeof
(
width
)
=
'
text
'
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDB
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
VACUUM
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_DispatchToMainThread
(
this
)
;
}
nsresult
FetchAndConvertUnsupportedPayloads
:
:
ConvertPayload
(
int64_t
aId
const
nsACString
&
aMimeType
nsCString
&
aPayload
int32_t
*
aWidth
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
*
aWidth
=
0
;
if
(
aPayload
.
Length
(
)
=
=
0
|
|
!
imgLoader
:
:
SupportImageWithMimeType
(
PromiseFlatCString
(
aMimeType
)
.
get
(
)
AcceptedMimeTypes
:
:
IMAGES_AND_DOCUMENTS
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aMimeType
.
EqualsLiteral
(
SVG_MIME_TYPE
)
)
{
*
aWidth
=
UINT16_MAX
;
return
NS_OK
;
}
nsCOMPtr
<
nsIInputStream
>
stream
;
nsresult
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
stream
)
aPayload
.
get
(
)
aPayload
.
Length
(
)
NS_ASSIGNMENT_DEPEND
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
gfx
:
:
SourceSurface
>
surface
=
image
:
:
ImageOps
:
:
DecodeToSurface
(
stream
.
forget
(
)
aMimeType
imgIContainer
:
:
DECODE_FLAGS_DEFAULT
)
;
NS_ENSURE_STATE
(
surface
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
NS_ENSURE_STATE
(
dataSurface
)
;
int32_t
width
=
dataSurface
-
>
GetSize
(
)
.
width
;
int32_t
height
=
dataSurface
-
>
GetSize
(
)
.
height
;
int32_t
originalSize
=
std
:
:
max
(
width
height
)
;
int32_t
size
=
originalSize
;
for
(
uint16_t
supportedSize
:
sFaviconSizes
)
{
if
(
supportedSize
<
=
originalSize
)
{
size
=
supportedSize
;
break
;
}
}
*
aWidth
=
size
;
if
(
aMimeType
.
EqualsLiteral
(
PNG_MIME_TYPE
)
&
&
size
=
=
originalSize
)
{
return
NS_OK
;
}
RefPtr
<
gfx
:
:
DataSourceSurface
>
targetDataSurface
=
gfx
:
:
Factory
:
:
CreateDataSourceSurface
(
gfx
:
:
IntSize
(
size
size
)
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
true
)
;
NS_ENSURE_STATE
(
targetDataSurface
)
;
{
gfx
:
:
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
targetDataSurface
-
>
Map
(
gfx
:
:
DataSourceSurface
:
:
MapType
:
:
WRITE
&
map
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
gfx
:
:
DrawTarget
>
dt
=
gfx
:
:
Factory
:
:
CreateDrawTargetForData
(
gfx
:
:
BackendType
:
:
CAIRO
map
.
mData
targetDataSurface
-
>
GetSize
(
)
map
.
mStride
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
)
;
NS_ENSURE_STATE
(
dt
)
;
gfx
:
:
IntSize
frameSize
=
dataSurface
-
>
GetSize
(
)
;
dt
-
>
DrawSurface
(
dataSurface
gfx
:
:
Rect
(
0
0
size
size
)
gfx
:
:
Rect
(
0
0
frameSize
.
width
frameSize
.
height
)
gfx
:
:
DrawSurfaceOptions
(
)
gfx
:
:
DrawOptions
(
1
.
0f
gfx
:
:
CompositionOp
:
:
OP_SOURCE
)
)
;
targetDataSurface
-
>
Unmap
(
)
;
}
nsCOMPtr
<
imgIEncoder
>
encoder
=
do_CreateInstance
(
"
mozilla
.
org
/
image
/
encoder
;
2
?
type
=
image
/
png
"
)
;
NS_ENSURE_STATE
(
encoder
)
;
gfx
:
:
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
targetDataSurface
-
>
Map
(
gfx
:
:
DataSourceSurface
:
:
MapType
:
:
READ
&
map
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
encoder
-
>
InitFromData
(
map
.
mData
map
.
mStride
*
size
size
size
map
.
mStride
imgIEncoder
:
:
INPUT_FORMAT_HOSTARGB
EmptyString
(
)
)
;
targetDataSurface
-
>
Unmap
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
iconStream
=
encoder
;
NS_ENSURE_STATE
(
iconStream
)
;
rv
=
NS_ConsumeStream
(
iconStream
UINT32_MAX
aPayload
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
FetchAndConvertUnsupportedPayloads
:
:
StorePayload
(
int64_t
aId
int32_t
aWidth
const
nsCString
&
aPayload
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
NS_ENSURE_STATE
(
mDB
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
nsresult
rv
=
mDB
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
UPDATE
moz_icons
SET
data
=
:
data
width
=
:
width
WHERE
id
=
:
id
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
id
"
)
aId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
width
"
)
aWidth
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindBlobByName
(
NS_LITERAL_CSTRING
(
"
data
"
)
TO_INTBUFFER
(
aPayload
)
aPayload
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
AsyncCopyFavicons
:
:
AsyncCopyFavicons
(
PageData
&
aFromPage
PageData
&
aToPage
nsIFaviconDataCallback
*
aCallback
)
:
Runnable
(
"
places
:
:
AsyncCopyFavicons
"
)
mFromPage
(
aFromPage
)
mToPage
(
aToPage
)
mCallback
(
new
nsMainThreadPtrHolder
<
nsIFaviconDataCallback
>
(
"
AsyncCopyFavicons
:
:
mCallback
"
aCallback
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
NS_IMETHODIMP
AsyncCopyFavicons
:
:
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
IconData
icon
;
auto
cleanup
=
MakeScopeExit
(
[
&
]
(
)
{
if
(
!
(
icon
.
status
&
ICON_STATUS_ASSOCIATED
)
)
{
icon
.
spec
.
Truncate
(
)
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyIconObservers
(
icon
mToPage
mCallback
)
;
NS_DispatchToMainThread
(
event
)
;
}
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
nsresult
rv
=
FetchPageInfo
(
DB
mToPage
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
|
|
!
mToPage
.
placeId
)
{
return
NS_OK
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
FetchIconPerSpec
(
DB
mFromPage
.
spec
EmptyCString
(
)
icon
UINT16_MAX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
icon
.
spec
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
!
mToPage
.
id
)
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
stmt
=
DB
-
>
GetStatement
(
"
INSERT
OR
IGNORE
INTO
moz_pages_w_icons
(
page_url
page_url_hash
)
"
"
VALUES
(
:
page_url
hash
(
:
page_url
)
)
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
URIBinder
:
:
Bind
(
stmt
NS_LITERAL_CSTRING
(
"
page_url
"
)
mToPage
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
FetchPageInfo
(
DB
mToPage
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
DB
-
>
GetStatement
(
"
INSERT
OR
IGNORE
INTO
moz_icons_to_pages
(
page_id
icon_id
)
"
"
SELECT
:
id
icon_id
"
"
FROM
moz_icons_to_pages
"
"
WHERE
page_id
=
(
SELECT
id
FROM
moz_pages_w_icons
WHERE
page_url_hash
=
"
"
hash
(
:
url
)
AND
page_url
=
:
url
)
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
id
"
)
mToPage
.
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
URIBinder
:
:
Bind
(
stmt
NS_LITERAL_CSTRING
(
"
url
"
)
mFromPage
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
icon
.
status
|
=
ICON_STATUS_ASSOCIATED
;
return
NS_OK
;
}
}
}
