#
include
"
FaviconHelpers
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsNavHistory
.
h
"
#
include
"
nsFaviconService
.
h
"
#
include
"
mozilla
/
dom
/
PlacesFavicon
.
h
"
#
include
"
mozilla
/
dom
/
PlacesObservers
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
storage
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsIPrivateBrowsingChannel
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
<
algorithm
>
#
include
<
deque
>
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
ImageOps
.
h
"
#
include
"
imgIEncoder
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
places
;
using
namespace
mozilla
:
:
storage
;
namespace
mozilla
{
namespace
places
{
namespace
{
nsresult
FetchPageInfo
(
const
RefPtr
<
Database
>
&
aDB
PageData
&
_page
)
{
MOZ_ASSERT
(
_page
.
spec
.
Length
(
)
"
Must
have
a
non
-
empty
spec
!
"
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCString
query
=
nsPrintfCString
(
"
SELECT
h
.
id
pi
.
id
h
.
guid
(
"
"
WITH
RECURSIVE
"
"
destinations
(
visit_type
from_visit
place_id
rev_host
bm
)
AS
(
"
"
SELECT
v
.
visit_type
v
.
from_visit
p
.
id
p
.
rev_host
b
.
id
"
"
FROM
moz_places
p
"
"
LEFT
JOIN
moz_historyvisits
v
ON
v
.
place_id
=
p
.
id
"
"
LEFT
JOIN
moz_bookmarks
b
ON
b
.
fk
=
p
.
id
"
"
WHERE
p
.
id
=
h
.
id
"
"
UNION
"
"
SELECT
src
.
visit_type
src
.
from_visit
src
.
place_id
p
.
rev_host
b
.
id
"
"
FROM
moz_places
p
"
"
JOIN
moz_historyvisits
src
ON
src
.
place_id
=
p
.
id
"
"
JOIN
destinations
dest
ON
dest
.
from_visit
=
src
.
id
AND
dest
.
visit_type
"
"
IN
(
%
d
%
d
)
"
"
LEFT
JOIN
moz_bookmarks
b
ON
b
.
fk
=
src
.
place_id
"
"
WHERE
instr
(
p
.
rev_host
dest
.
rev_host
)
=
1
"
"
OR
instr
(
dest
.
rev_host
p
.
rev_host
)
=
1
"
"
)
"
"
SELECT
url
"
"
FROM
moz_places
p
"
"
JOIN
destinations
r
ON
r
.
place_id
=
p
.
id
"
"
WHERE
bm
NOTNULL
"
"
LIMIT
1
"
"
)
fixup_url
(
get_unreversed_host
(
h
.
rev_host
)
)
AS
host
"
"
FROM
moz_places
h
"
"
LEFT
JOIN
moz_pages_w_icons
pi
ON
page_url_hash
=
hash
(
:
page_url
)
AND
"
"
page_url
=
:
page_url
"
"
WHERE
h
.
url_hash
=
hash
(
:
page_url
)
AND
h
.
url
=
:
page_url
"
nsINavHistoryService
:
:
TRANSITION_REDIRECT_PERMANENT
nsINavHistoryService
:
:
TRANSITION_REDIRECT_TEMPORARY
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aDB
-
>
GetStatement
(
query
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
nsresult
rv
=
URIBinder
:
:
Bind
(
stmt
"
page_url
"
_ns
_page
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasResult
;
rv
=
stmt
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
hasResult
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
rv
=
stmt
-
>
GetInt64
(
0
&
_page
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
_page
.
id
=
stmt
-
>
AsInt64
(
1
)
;
rv
=
stmt
-
>
GetUTF8String
(
2
_page
.
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
isNull
;
rv
=
stmt
-
>
GetIsNull
(
3
&
isNull
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isNull
)
{
rv
=
stmt
-
>
GetUTF8String
(
3
_page
.
bookmarkedSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
_page
.
host
.
IsEmpty
(
)
)
{
rv
=
stmt
-
>
GetUTF8String
(
4
_page
.
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
_page
.
canAddToHistory
)
{
if
(
_page
.
bookmarkedSpec
.
IsEmpty
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
else
{
if
(
!
_page
.
bookmarkedSpec
.
Equals
(
_page
.
spec
)
)
{
_page
.
spec
=
_page
.
bookmarkedSpec
;
rv
=
FetchPageInfo
(
aDB
_page
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
return
NS_OK
;
}
nsresult
SetIconInfo
(
const
RefPtr
<
Database
>
&
aDB
IconData
&
aIcon
bool
aMustReplace
=
false
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aIcon
.
payloads
.
Length
(
)
>
0
)
;
MOZ_ASSERT
(
!
aIcon
.
spec
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aIcon
.
expiration
>
0
)
;
nsCOMPtr
<
mozIStorageStatement
>
selectStmt
=
aDB
-
>
GetStatement
(
"
SELECT
id
FROM
moz_icons
"
"
WHERE
fixed_icon_url_hash
=
hash
(
fixup_url
(
:
url
)
)
"
"
AND
icon_url
=
:
url
"
)
;
NS_ENSURE_STATE
(
selectStmt
)
;
mozStorageStatementScoper
scoper
(
selectStmt
)
;
nsresult
rv
=
URIBinder
:
:
Bind
(
selectStmt
"
url
"
_ns
aIcon
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
std
:
:
deque
<
int64_t
>
ids
;
bool
hasResult
=
false
;
while
(
NS_SUCCEEDED
(
selectStmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
int64_t
id
=
selectStmt
-
>
AsInt64
(
0
)
;
MOZ_ASSERT
(
id
>
0
)
;
ids
.
push_back
(
id
)
;
}
if
(
aMustReplace
&
&
ids
.
empty
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
mozIStorageStatement
>
insertStmt
=
aDB
-
>
GetStatement
(
"
INSERT
INTO
moz_icons
"
"
(
icon_url
fixed_icon_url_hash
width
root
expire_ms
data
flags
)
"
"
VALUES
(
:
url
hash
(
fixup_url
(
:
url
)
)
:
width
:
root
:
expire
:
data
"
"
:
flags
)
"
)
;
NS_ENSURE_STATE
(
insertStmt
)
;
nsCOMPtr
<
mozIStorageStatement
>
updateStmt
=
aDB
-
>
GetStatement
(
"
UPDATE
moz_icons
SET
width
=
:
width
"
"
expire_ms
=
:
expire
"
"
data
=
:
data
"
"
root
=
(
root
OR
:
root
)
"
"
flags
=
:
flags
"
"
WHERE
id
=
:
id
"
)
;
NS_ENSURE_STATE
(
updateStmt
)
;
for
(
auto
&
payload
:
aIcon
.
payloads
)
{
MOZ_ASSERT
(
payload
.
mimeType
.
EqualsLiteral
(
PNG_MIME_TYPE
)
|
|
payload
.
mimeType
.
EqualsLiteral
(
SVG_MIME_TYPE
)
"
Only
png
and
svg
payloads
are
supported
"
)
;
MOZ_ASSERT
(
!
payload
.
mimeType
.
EqualsLiteral
(
SVG_MIME_TYPE
)
|
|
payload
.
width
=
=
UINT16_MAX
"
SVG
payloads
should
have
max
width
"
)
;
MOZ_ASSERT
(
payload
.
width
>
0
"
Payload
should
have
a
width
"
)
;
#
ifdef
DEBUG
payload
.
id
=
0
;
#
endif
if
(
!
ids
.
empty
(
)
)
{
int64_t
id
=
ids
.
front
(
)
;
ids
.
pop_front
(
)
;
mozStorageStatementScoper
scoper
(
updateStmt
)
;
rv
=
updateStmt
-
>
BindInt64ByName
(
"
id
"
_ns
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updateStmt
-
>
BindInt32ByName
(
"
width
"
_ns
payload
.
width
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updateStmt
-
>
BindInt64ByName
(
"
expire
"
_ns
aIcon
.
expiration
/
1000
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updateStmt
-
>
BindInt32ByName
(
"
root
"
_ns
aIcon
.
rootIcon
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updateStmt
-
>
BindBlobByName
(
"
data
"
_ns
TO_INTBUFFER
(
payload
.
data
)
payload
.
data
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updateStmt
-
>
BindInt32ByName
(
"
flags
"
_ns
aIcon
.
flags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updateStmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
payload
.
id
=
id
;
}
else
{
mozStorageStatementScoper
scoper
(
insertStmt
)
;
rv
=
URIBinder
:
:
Bind
(
insertStmt
"
url
"
_ns
aIcon
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
insertStmt
-
>
BindInt32ByName
(
"
width
"
_ns
payload
.
width
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
insertStmt
-
>
BindInt32ByName
(
"
root
"
_ns
aIcon
.
rootIcon
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
insertStmt
-
>
BindInt64ByName
(
"
expire
"
_ns
aIcon
.
expiration
/
1000
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
insertStmt
-
>
BindBlobByName
(
"
data
"
_ns
TO_INTBUFFER
(
payload
.
data
)
payload
.
data
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
insertStmt
-
>
BindInt32ByName
(
"
flags
"
_ns
aIcon
.
flags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
insertStmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
payload
.
id
=
nsFaviconService
:
:
sLastInsertedIconId
;
}
MOZ_ASSERT
(
payload
.
id
>
0
"
Payload
should
have
an
id
"
)
;
}
if
(
!
ids
.
empty
(
)
)
{
nsAutoCString
sql
(
"
DELETE
FROM
moz_icons
WHERE
id
IN
(
"
)
;
for
(
int64_t
id
:
ids
)
{
sql
.
AppendInt
(
id
)
;
sql
.
AppendLiteral
(
"
"
)
;
}
sql
.
AppendLiteral
(
"
0
)
"
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aDB
-
>
GetStatement
(
sql
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
FetchIconInfo
(
const
RefPtr
<
Database
>
&
aDB
uint16_t
aPreferredWidth
IconData
&
_icon
)
{
MOZ_ASSERT
(
_icon
.
spec
.
Length
(
)
"
Must
have
a
non
-
empty
spec
!
"
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
_icon
.
status
&
ICON_STATUS_CACHED
)
{
return
NS_OK
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aDB
-
>
GetStatement
(
"
/
*
do
not
warn
(
bug
no
:
not
worth
having
a
compound
index
)
*
/
"
"
SELECT
id
expire_ms
data
width
root
"
"
FROM
moz_icons
"
"
WHERE
fixed_icon_url_hash
=
hash
(
fixup_url
(
:
url
)
)
"
"
AND
icon_url
=
:
url
"
"
ORDER
BY
width
DESC
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
DebugOnly
<
nsresult
>
rv
=
URIBinder
:
:
Bind
(
stmt
"
url
"
_ns
_icon
.
spec
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
bool
hasResult
=
false
;
while
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
IconPayload
payload
;
rv
=
stmt
-
>
GetInt64
(
0
&
payload
.
id
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
bool
isNull
;
rv
=
stmt
-
>
GetIsNull
(
1
&
isNull
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
isNull
)
{
int64_t
expire_ms
;
rv
=
stmt
-
>
GetInt64
(
1
&
expire_ms
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
_icon
.
expiration
=
expire_ms
*
1000
;
}
uint8_t
*
data
;
uint32_t
dataLen
=
0
;
rv
=
stmt
-
>
GetBlob
(
2
&
dataLen
&
data
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
payload
.
data
.
Adopt
(
TO_CHARBUFFER
(
data
)
dataLen
)
;
int32_t
width
;
rv
=
stmt
-
>
GetInt32
(
3
&
width
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
payload
.
width
=
width
;
if
(
payload
.
width
=
=
UINT16_MAX
)
{
payload
.
mimeType
.
AssignLiteral
(
SVG_MIME_TYPE
)
;
}
else
{
payload
.
mimeType
.
AssignLiteral
(
PNG_MIME_TYPE
)
;
}
int32_t
rootIcon
;
rv
=
stmt
-
>
GetInt32
(
4
&
rootIcon
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
_icon
.
rootIcon
=
rootIcon
;
if
(
aPreferredWidth
=
=
0
|
|
_icon
.
payloads
.
Length
(
)
=
=
0
)
{
_icon
.
payloads
.
AppendElement
(
payload
)
;
}
else
if
(
payload
.
width
>
=
aPreferredWidth
)
{
_icon
.
payloads
.
ReplaceElementAt
(
0
payload
)
;
}
else
{
break
;
}
}
return
NS_OK
;
}
nsresult
FetchMostFrecentSubPageIcon
(
const
RefPtr
<
Database
>
&
aDB
const
nsACString
&
aPageRoot
IconData
&
aIconData
)
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aDB
-
>
GetStatement
(
"
SELECT
i
.
icon_url
"
"
FROM
moz_pages_w_icons
pwi
"
"
JOIN
moz_icons_to_pages
itp
ON
pwi
.
id
=
itp
.
page_id
"
"
JOIN
moz_icons
i
ON
itp
.
icon_id
=
i
.
id
"
"
JOIN
moz_places
p
ON
p
.
url_hash
=
pwi
.
page_url_hash
"
"
WHERE
p
.
url
BETWEEN
:
pageRoot
AND
:
pageRoot
|
|
"
"
X
'
FFFF
'
"
"
ORDER
BY
p
.
frecency
DESC
i
.
width
DESC
"
"
LIMIT
1
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoperFallback
(
stmt
)
;
nsresult
rv
=
stmt
-
>
BindUTF8StringByName
(
"
pageRoot
"
_ns
aPageRoot
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasResult
;
if
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
rv
=
stmt
-
>
GetUTF8String
(
0
aIconData
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
FetchIconPerSpec
(
const
RefPtr
<
Database
>
&
aDB
const
nsCOMPtr
<
nsIURI
>
&
aPageURI
IconData
&
aIconData
uint16_t
aPreferredWidth
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPageURI
"
URI
must
exist
.
"
)
;
nsAutoCString
pageSpec
;
nsresult
rv
=
aPageURI
-
>
GetSpec
(
pageSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
!
pageSpec
.
IsEmpty
(
)
"
Page
spec
must
not
be
empty
.
"
)
;
nsAutoCString
pageHostAndPort
;
Unused
<
<
aPageURI
-
>
GetHostPort
(
pageHostAndPort
)
;
const
uint16_t
THRESHOLD_WIDTH
=
64
;
nsCString
query
=
nsPrintfCString
(
"
/
*
do
not
warn
(
bug
no
:
not
worth
having
a
compound
index
)
*
/
"
"
SELECT
width
icon_url
root
(
flags
&
%
d
)
as
isRich
"
"
FROM
moz_icons
i
"
"
JOIN
moz_icons_to_pages
ON
i
.
id
=
icon_id
"
"
JOIN
moz_pages_w_icons
p
ON
p
.
id
=
page_id
"
"
WHERE
page_url_hash
=
hash
(
:
url
)
AND
page_url
=
:
url
"
"
OR
(
:
hash_idx
AND
page_url_hash
=
hash
(
substr
(
:
url
0
:
hash_idx
)
)
"
"
AND
page_url
=
substr
(
:
url
0
:
hash_idx
)
)
"
"
UNION
ALL
"
"
SELECT
width
icon_url
root
(
flags
&
%
d
)
as
isRich
"
"
FROM
moz_icons
i
"
"
WHERE
fixed_icon_url_hash
=
hash
(
fixup_url
(
:
hostAndPort
)
|
|
"
"
'
/
favicon
.
ico
'
)
"
"
ORDER
BY
%
s
width
DESC
root
ASC
"
nsIFaviconService
:
:
ICONDATA_FLAGS_RICH
nsIFaviconService
:
:
ICONDATA_FLAGS_RICH
aPreferredWidth
<
=
THRESHOLD_WIDTH
?
"
isRich
ASC
"
:
"
"
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aDB
-
>
GetStatement
(
query
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
URIBinder
:
:
Bind
(
stmt
"
url
"
_ns
pageSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
"
hostAndPort
"
_ns
pageHostAndPort
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
hashIdx
=
PromiseFlatCString
(
pageSpec
)
.
RFind
(
"
#
"
)
;
rv
=
stmt
-
>
BindInt32ByName
(
"
hash_idx
"
_ns
hashIdx
+
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasResult
;
struct
IconInfo
{
int32_t
width
=
0
;
int32_t
isRich
=
0
;
nsAutoCString
spec
;
bool
isSet
(
)
{
return
width
>
0
;
}
;
}
;
IconInfo
svgIcon
;
IconInfo
lastIcon
;
IconInfo
selectedIcon
;
bool
preferNonRichIcons
=
aPreferredWidth
<
=
THRESHOLD_WIDTH
;
while
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
int32_t
width
;
rv
=
stmt
-
>
GetInt32
(
0
&
width
)
;
if
(
lastIcon
.
width
=
=
width
)
{
continue
;
}
int32_t
isRich
=
stmt
-
>
AsInt32
(
3
)
;
int32_t
isSVG
=
(
width
=
=
UINT16_MAX
)
;
nsAutoCString
iconURL
;
stmt
-
>
GetUTF8String
(
1
iconURL
)
;
if
(
isSVG
&
&
!
svgIcon
.
isSet
(
)
)
{
if
(
(
preferNonRichIcons
&
&
!
isRich
)
|
|
!
preferNonRichIcons
)
{
svgIcon
=
{
width
isRich
iconURL
}
;
}
}
if
(
preferNonRichIcons
&
&
lastIcon
.
isSet
(
)
&
&
isRich
&
&
!
lastIcon
.
isRich
)
{
break
;
}
if
(
!
aIconData
.
spec
.
IsEmpty
(
)
&
&
width
<
aPreferredWidth
)
{
if
(
aPreferredWidth
-
width
<
abs
(
lastIcon
.
width
-
aPreferredWidth
)
/
4
)
{
selectedIcon
=
{
width
isRich
}
;
rv
=
stmt
-
>
GetUTF8String
(
1
aIconData
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
break
;
}
lastIcon
=
{
width
isRich
}
;
selectedIcon
=
{
width
isRich
}
;
rv
=
stmt
-
>
GetUTF8String
(
1
aIconData
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
svgIcon
.
isSet
(
)
&
&
!
svgIcon
.
spec
.
IsEmpty
(
)
)
{
if
(
(
selectedIcon
.
width
!
=
aPreferredWidth
)
|
|
(
preferNonRichIcons
&
&
selectedIcon
.
isRich
)
)
{
aIconData
.
spec
=
svgIcon
.
spec
;
}
}
if
(
aIconData
.
spec
.
IsEmpty
(
)
)
{
nsAutoCString
pageFilePath
;
rv
=
aPageURI
-
>
GetFilePath
(
pageFilePath
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
pageFilePath
=
=
"
/
"
_ns
)
{
rv
=
FetchMostFrecentSubPageIcon
(
aDB
pageSpec
aIconData
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
}
AsyncAssociateIconToPage
:
:
AsyncAssociateIconToPage
(
const
IconData
&
aIcon
const
PageData
&
aPage
const
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
&
aCallback
)
:
Runnable
(
"
places
:
:
AsyncAssociateIconToPage
"
)
mCallback
(
aCallback
)
mIcon
(
aIcon
)
mPage
(
aPage
)
{
}
NS_IMETHODIMP
AsyncAssociateIconToPage
:
:
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mPage
.
guid
.
IsEmpty
(
)
"
Page
info
should
have
been
fetched
already
"
)
;
MOZ_ASSERT
(
mPage
.
canAddToHistory
|
|
!
mPage
.
bookmarkedSpec
.
IsEmpty
(
)
"
The
page
should
be
addable
to
history
or
a
bookmark
"
)
;
bool
shouldUpdateIcon
=
mIcon
.
status
&
ICON_STATUS_CHANGED
;
if
(
!
shouldUpdateIcon
)
{
for
(
const
auto
&
payload
:
mIcon
.
payloads
)
{
if
(
payload
.
id
=
=
0
)
{
shouldUpdateIcon
=
true
;
break
;
}
}
}
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
mozStorageTransaction
transaction
(
DB
-
>
MainConn
(
)
false
mozIStorageConnection
:
:
TRANSACTION_IMMEDIATE
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
transaction
.
Start
(
)
)
)
;
nsresult
rv
;
if
(
shouldUpdateIcon
)
{
rv
=
SetIconInfo
(
DB
mIcon
)
;
if
(
NS_FAILED
(
rv
)
)
{
(
void
)
transaction
.
Commit
(
)
;
return
rv
;
}
mIcon
.
status
=
(
mIcon
.
status
&
~
(
ICON_STATUS_CACHED
)
)
|
ICON_STATUS_SAVED
;
}
if
(
mPage
.
placeId
=
=
0
)
{
rv
=
transaction
.
Commit
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
if
(
mPage
.
id
>
0
)
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
stmt
=
DB
-
>
GetStatement
(
"
DELETE
FROM
moz_icons_to_pages
"
"
WHERE
page_id
=
:
page_id
"
"
AND
expire_ms
<
strftime
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
BindInt64ByName
(
"
page_id
"
_ns
mPage
.
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
mIcon
.
rootIcon
|
|
!
mIcon
.
host
.
Equals
(
mPage
.
host
)
)
{
if
(
mPage
.
id
=
=
0
)
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
stmt
=
DB
-
>
GetStatement
(
"
INSERT
OR
IGNORE
INTO
moz_pages_w_icons
(
page_url
page_url_hash
)
"
"
VALUES
(
:
page_url
hash
(
:
page_url
)
)
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
URIBinder
:
:
Bind
(
stmt
"
page_url
"
_ns
mPage
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
stmt
=
DB
-
>
GetStatement
(
"
INSERT
INTO
moz_icons_to_pages
(
page_id
icon_id
expire_ms
)
"
"
VALUES
(
(
SELECT
id
from
moz_pages_w_icons
WHERE
page_url_hash
=
"
"
hash
(
:
page_url
)
AND
page_url
=
:
page_url
)
"
"
:
icon_id
:
expire
)
"
"
ON
CONFLICT
(
page_id
icon_id
)
DO
"
"
UPDATE
SET
expire_ms
=
:
expire
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
for
(
const
auto
&
payload
:
mIcon
.
payloads
)
{
mozStorageStatementScoper
scoper
(
stmt
)
;
nsCOMPtr
<
mozIStorageBindingParams
>
params
;
rv
=
URIBinder
:
:
Bind
(
stmt
"
page_url
"
_ns
mPage
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt64ByName
(
"
icon_id
"
_ns
payload
.
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt64ByName
(
"
expire
"
_ns
mIcon
.
expiration
/
1000
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
mIcon
.
status
|
=
ICON_STATUS_ASSOCIATED
;
rv
=
transaction
.
Commit
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyIconObservers
(
mIcon
mPage
mCallback
)
;
rv
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mPage
.
bookmarkedSpec
.
IsEmpty
(
)
&
&
!
mPage
.
bookmarkedSpec
.
Equals
(
mPage
.
spec
)
)
{
PageData
bookmarkedPage
;
bookmarkedPage
.
spec
=
mPage
.
bookmarkedSpec
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
if
(
DB
&
&
NS_SUCCEEDED
(
FetchPageInfo
(
DB
bookmarkedPage
)
)
)
{
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
nullCallback
;
RefPtr
<
AsyncAssociateIconToPage
>
event
=
new
AsyncAssociateIconToPage
(
mIcon
bookmarkedPage
nullCallback
)
;
Unused
<
<
event
-
>
Run
(
)
;
}
}
return
NS_OK
;
}
AsyncSetIconForPage
:
:
AsyncSetIconForPage
(
const
IconData
&
aIcon
const
PageData
&
aPage
dom
:
:
Promise
*
aPromise
)
:
Runnable
(
"
places
:
:
AsyncSetIconForPage
"
)
mPromise
(
new
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
(
"
AsyncSetIconForPage
:
:
Promise
"
aPromise
false
)
)
mIcon
(
aIcon
)
mPage
(
aPage
)
{
}
NS_IMETHODIMP
AsyncSetIconForPage
:
:
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mIcon
.
payloads
.
Length
(
)
"
The
icon
should
have
valid
data
"
)
;
MOZ_ASSERT
(
mPage
.
spec
.
Length
(
)
"
The
page
should
have
spec
"
)
;
MOZ_ASSERT
(
mPage
.
guid
.
IsEmpty
(
)
"
The
page
should
not
have
guid
"
)
;
nsresult
rv
=
NS_OK
;
auto
guard
=
MakeScopeExit
(
[
&
]
(
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
AsyncSetIconForPage
:
:
Promise
"
[
rv
promise
=
std
:
:
move
(
mPromise
)
]
(
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
else
{
promise
-
>
MaybeReject
(
rv
)
;
}
}
)
)
;
}
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
if
(
MOZ_UNLIKELY
(
!
DB
)
)
{
return
(
rv
=
NS_ERROR_UNEXPECTED
)
;
}
rv
=
FetchPageInfo
(
DB
mPage
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
nullCallback
;
AsyncAssociateIconToPage
event
(
mIcon
mPage
nullCallback
)
;
return
(
rv
=
event
.
Run
(
)
)
;
}
AsyncGetFaviconURLForPage
:
:
AsyncGetFaviconURLForPage
(
const
nsCOMPtr
<
nsIURI
>
&
aPageURI
uint16_t
aPreferredWidth
nsIFaviconDataCallback
*
aCallback
)
:
Runnable
(
"
places
:
:
AsyncGetFaviconURLForPage
"
)
mPreferredWidth
(
aPreferredWidth
=
=
0
?
UINT16_MAX
:
aPreferredWidth
)
mCallback
(
new
nsMainThreadPtrHolder
<
nsIFaviconDataCallback
>
(
"
AsyncGetFaviconURLForPage
:
:
mCallback
"
aCallback
)
)
mPageURI
(
aPageURI
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
NS_IMETHODIMP
AsyncGetFaviconURLForPage
:
:
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
IconData
iconData
;
nsresult
rv
=
FetchIconPerSpec
(
DB
mPageURI
iconData
mPreferredWidth
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
PageData
pageData
;
mPageURI
-
>
GetSpec
(
pageData
.
spec
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyIconObservers
(
iconData
pageData
mCallback
)
;
rv
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
AsyncGetFaviconDataForPage
:
:
AsyncGetFaviconDataForPage
(
const
nsCOMPtr
<
nsIURI
>
&
aPageURI
uint16_t
aPreferredWidth
nsIFaviconDataCallback
*
aCallback
)
:
Runnable
(
"
places
:
:
AsyncGetFaviconDataForPage
"
)
mPreferredWidth
(
aPreferredWidth
=
=
0
?
UINT16_MAX
:
aPreferredWidth
)
mCallback
(
new
nsMainThreadPtrHolder
<
nsIFaviconDataCallback
>
(
"
AsyncGetFaviconDataForPage
:
:
mCallback
"
aCallback
)
)
mPageURI
(
aPageURI
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
NS_IMETHODIMP
AsyncGetFaviconDataForPage
:
:
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
IconData
iconData
;
nsresult
rv
=
FetchIconPerSpec
(
DB
mPageURI
iconData
mPreferredWidth
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
iconData
.
spec
.
IsEmpty
(
)
)
{
rv
=
FetchIconInfo
(
DB
mPreferredWidth
iconData
)
;
if
(
NS_FAILED
(
rv
)
)
{
iconData
.
spec
.
Truncate
(
)
;
}
}
PageData
pageData
;
mPageURI
-
>
GetSpec
(
pageData
.
spec
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyIconObservers
(
iconData
pageData
mCallback
)
;
rv
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NotifyIconObservers
:
:
NotifyIconObservers
(
const
IconData
&
aIcon
const
PageData
&
aPage
const
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
&
aCallback
)
:
Runnable
(
"
places
:
:
NotifyIconObservers
"
)
mCallback
(
aCallback
)
mIcon
(
aIcon
)
mPage
(
aPage
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHODIMP
NotifyIconObservers
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIURI
>
iconURI
;
if
(
!
mIcon
.
spec
.
IsEmpty
(
)
)
{
if
(
!
NS_WARN_IF
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
iconURI
)
mIcon
.
spec
)
)
)
)
{
if
(
mIcon
.
status
&
ICON_STATUS_SAVED
|
|
mIcon
.
status
&
ICON_STATUS_ASSOCIATED
)
{
nsCOMPtr
<
nsIURI
>
pageURI
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
pageURI
)
mPage
.
spec
)
)
)
)
{
nsFaviconService
*
favicons
=
nsFaviconService
:
:
GetFaviconService
(
)
;
MOZ_ASSERT
(
favicons
)
;
if
(
favicons
)
{
nsCString
pageIconSpec
(
"
page
-
icon
:
"
)
;
pageIconSpec
.
Append
(
mPage
.
spec
)
;
nsCOMPtr
<
nsIURI
>
pageIconURI
;
if
(
NS_SUCCEEDED
(
NS_NewURI
(
getter_AddRefs
(
pageIconURI
)
pageIconSpec
)
)
)
{
favicons
-
>
ClearImageCache
(
pageIconURI
)
;
}
}
dom
:
:
Sequence
<
OwningNonNull
<
dom
:
:
PlacesEvent
>
>
events
;
RefPtr
<
dom
:
:
PlacesFavicon
>
faviconEvent
=
new
dom
:
:
PlacesFavicon
(
)
;
AppendUTF8toUTF16
(
mPage
.
spec
faviconEvent
-
>
mUrl
)
;
AppendUTF8toUTF16
(
mIcon
.
spec
faviconEvent
-
>
mFaviconUrl
)
;
faviconEvent
-
>
mPageGuid
.
Assign
(
mPage
.
guid
)
;
bool
success
=
!
!
events
.
AppendElement
(
faviconEvent
.
forget
(
)
fallible
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
dom
:
:
PlacesObservers
:
:
NotifyListeners
(
events
)
;
}
}
}
}
if
(
!
mCallback
)
{
return
NS_OK
;
}
if
(
mIcon
.
payloads
.
Length
(
)
>
0
)
{
IconPayload
&
payload
=
mIcon
.
payloads
[
0
]
;
return
mCallback
-
>
OnComplete
(
iconURI
payload
.
data
.
Length
(
)
TO_INTBUFFER
(
payload
.
data
)
payload
.
mimeType
payload
.
width
)
;
}
return
mCallback
-
>
OnComplete
(
iconURI
0
TO_INTBUFFER
(
EmptyCString
(
)
)
"
"
_ns
0
)
;
}
AsyncCopyFavicons
:
:
AsyncCopyFavicons
(
PageData
&
aFromPage
PageData
&
aToPage
nsIFaviconDataCallback
*
aCallback
)
:
Runnable
(
"
places
:
:
AsyncCopyFavicons
"
)
mFromPage
(
aFromPage
)
mToPage
(
aToPage
)
mCallback
(
new
nsMainThreadPtrHolder
<
nsIFaviconDataCallback
>
(
"
AsyncCopyFavicons
:
:
mCallback
"
aCallback
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
NS_IMETHODIMP
AsyncCopyFavicons
:
:
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
IconData
icon
;
auto
cleanup
=
MakeScopeExit
(
[
&
]
(
)
{
if
(
!
(
icon
.
status
&
ICON_STATUS_ASSOCIATED
)
)
{
icon
.
spec
.
Truncate
(
)
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyIconObservers
(
icon
mToPage
mCallback
)
;
NS_DispatchToMainThread
(
event
)
;
}
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
nsresult
rv
=
FetchPageInfo
(
DB
mToPage
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
|
|
!
mToPage
.
placeId
)
{
return
NS_OK
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
pageURI
;
rv
=
NS_NewURI
(
getter_AddRefs
(
pageURI
)
mFromPage
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
FetchIconPerSpec
(
DB
pageURI
icon
UINT16_MAX
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
icon
.
spec
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
!
mToPage
.
id
)
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
stmt
=
DB
-
>
GetStatement
(
"
INSERT
OR
IGNORE
INTO
moz_pages_w_icons
(
page_url
page_url_hash
)
"
"
VALUES
(
:
page_url
hash
(
:
page_url
)
)
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
URIBinder
:
:
Bind
(
stmt
"
page_url
"
_ns
mToPage
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
FetchPageInfo
(
DB
mToPage
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
DB
-
>
GetStatement
(
"
INSERT
OR
IGNORE
INTO
moz_icons_to_pages
(
page_id
icon_id
expire_ms
)
"
"
SELECT
:
id
icon_id
expire_ms
"
"
FROM
moz_icons_to_pages
"
"
WHERE
page_id
=
(
SELECT
id
FROM
moz_pages_w_icons
WHERE
page_url_hash
=
"
"
hash
(
:
url
)
AND
page_url
=
:
url
)
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
BindInt64ByName
(
"
id
"
_ns
mToPage
.
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
URIBinder
:
:
Bind
(
stmt
"
url
"
_ns
mFromPage
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
icon
.
status
|
=
ICON_STATUS_ASSOCIATED
;
return
NS_OK
;
}
}
}
