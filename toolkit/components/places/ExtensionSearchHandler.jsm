"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionSearchHandler
"
]
;
let
gKeywordMap
=
new
Map
(
)
;
let
gActiveInputSession
=
null
;
let
gCurrentCallbackID
=
0
;
class
KeywordInfo
{
constructor
(
extension
description
)
{
this
.
_extension
=
extension
;
this
.
_description
=
description
;
}
get
description
(
)
{
return
this
.
_description
;
}
set
description
(
desc
)
{
this
.
_description
=
desc
;
}
get
extension
(
)
{
return
this
.
_extension
;
}
}
class
InputSession
{
constructor
(
keyword
extension
)
{
this
.
_keyword
=
keyword
;
this
.
_extension
=
extension
;
this
.
_suggestionsCallback
=
null
;
this
.
_searchCompleteCallback
=
null
;
}
get
keyword
(
)
{
return
this
.
_keyword
;
}
registerSuggestionsCallback
(
callback
)
{
this
.
_suggestionsCallback
=
callback
;
}
registerSearchCompleteCallback
(
callback
)
{
this
.
_onSearchComplete
=
callback
;
}
addSuggestions
(
suggestions
)
{
if
(
this
.
_suggestionsCallback
)
{
this
.
_suggestionsCallback
(
suggestions
)
;
}
}
start
(
eventName
)
{
this
.
_extension
.
emit
(
eventName
)
;
}
update
(
eventName
text
)
{
this
.
_extension
.
emit
(
eventName
text
+
+
gCurrentCallbackID
)
;
if
(
this
.
_searchCompleteCallback
)
{
this
.
_searchCompleteCallback
(
)
;
}
}
cancel
(
eventName
)
{
this
.
_extension
.
emit
(
eventName
)
;
if
(
this
.
_searchCompleteCallback
)
{
this
.
_searchCompleteCallback
(
)
;
}
}
end
(
eventName
text
disposition
)
{
this
.
_extension
.
emit
(
eventName
text
disposition
)
;
if
(
this
.
_searchCompleteCallback
)
{
this
.
_searchCompleteCallback
(
)
;
}
}
}
var
ExtensionSearchHandler
=
Object
.
freeze
(
{
MSG_INPUT_STARTED
:
"
webext
-
omnibox
-
input
-
started
"
MSG_INPUT_CHANGED
:
"
webext
-
omnibox
-
input
-
changed
"
MSG_INPUT_ENTERED
:
"
webext
-
omnibox
-
input
-
entered
"
MSG_INPUT_CANCELLED
:
"
webext
-
omnibox
-
input
-
cancelled
"
registerKeyword
(
keyword
extension
)
{
if
(
gKeywordMap
.
has
(
keyword
)
)
{
throw
new
Error
(
The
keyword
provided
is
already
registered
:
"
{
keyword
}
"
)
;
}
gKeywordMap
.
set
(
keyword
new
KeywordInfo
(
extension
extension
.
name
)
)
;
}
unregisterKeyword
(
keyword
)
{
if
(
!
gKeywordMap
.
has
(
keyword
)
)
{
throw
new
Error
(
The
keyword
provided
is
not
registered
:
"
{
keyword
}
"
)
;
}
gActiveInputSession
=
null
;
gKeywordMap
.
delete
(
keyword
)
;
}
isKeywordRegistered
(
keyword
)
{
return
gKeywordMap
.
has
(
keyword
)
;
}
hasActiveInputSession
(
)
{
return
gActiveInputSession
!
=
null
;
}
getDescription
(
keyword
)
{
if
(
!
gKeywordMap
.
has
(
keyword
)
)
{
throw
new
Error
(
The
keyword
provided
is
not
registered
:
"
{
keyword
}
"
)
;
}
return
gKeywordMap
.
get
(
keyword
)
.
description
;
}
setDefaultSuggestion
(
keyword
{
description
}
)
{
if
(
!
gKeywordMap
.
has
(
keyword
)
)
{
throw
new
Error
(
The
keyword
provided
is
not
registered
:
"
{
keyword
}
"
)
;
}
gKeywordMap
.
get
(
keyword
)
.
description
=
description
;
}
addSuggestions
(
keyword
id
suggestions
)
{
if
(
!
gKeywordMap
.
has
(
keyword
)
)
{
throw
new
Error
(
The
keyword
provided
is
not
registered
:
"
{
keyword
}
"
)
;
}
if
(
!
gActiveInputSession
|
|
gActiveInputSession
.
keyword
!
=
keyword
)
{
throw
new
Error
(
The
keyword
provided
is
not
apart
of
an
active
input
session
:
"
{
keyword
}
"
)
;
}
if
(
id
!
=
gCurrentCallbackID
)
{
throw
new
Error
(
The
callback
is
no
longer
active
for
the
keyword
provided
:
"
{
keyword
}
"
)
;
}
gActiveInputSession
.
addSuggestions
(
suggestions
)
;
}
handleSearch
(
keyword
text
callback
)
{
if
(
!
gKeywordMap
.
has
(
keyword
)
)
{
throw
new
Error
(
The
keyword
provided
is
not
registered
:
"
{
keyword
}
"
)
;
}
if
(
gActiveInputSession
&
&
gActiveInputSession
.
keyword
!
=
keyword
)
{
throw
new
Error
(
"
A
different
input
session
is
already
ongoing
"
)
;
}
if
(
!
text
|
|
!
text
.
startsWith
(
{
keyword
}
)
)
{
throw
new
Error
(
The
text
provided
must
start
with
:
"
{
keyword
}
"
)
;
}
if
(
!
callback
)
{
throw
new
Error
(
"
A
callback
must
be
provided
"
)
;
}
let
{
extension
}
=
gKeywordMap
.
get
(
keyword
)
;
text
=
text
.
substring
(
keyword
.
length
+
1
)
;
if
(
!
gActiveInputSession
)
{
gActiveInputSession
=
new
InputSession
(
keyword
extension
)
;
gActiveInputSession
.
start
(
this
.
MSG_INPUT_STARTED
)
;
if
(
text
.
length
)
{
gActiveInputSession
.
registerSuggestionsCallback
(
callback
)
;
gActiveInputSession
.
update
(
this
.
MSG_INPUT_CHANGED
text
)
;
}
return
Promise
.
resolve
(
)
;
}
gActiveInputSession
.
registerSuggestionsCallback
(
callback
)
;
gActiveInputSession
.
update
(
this
.
MSG_INPUT_CHANGED
text
)
;
return
new
Promise
(
resolve
=
>
{
gActiveInputSession
.
registerSearchCompleteCallback
(
resolve
)
;
}
)
;
}
handleInputEntered
(
keyword
text
where
)
{
if
(
!
gKeywordMap
.
has
(
keyword
)
)
{
throw
new
Error
(
The
keyword
provided
is
not
registered
:
"
{
keyword
}
"
)
;
}
if
(
gActiveInputSession
&
&
gActiveInputSession
.
keyword
!
=
keyword
)
{
throw
new
Error
(
"
A
different
input
session
is
already
ongoing
"
)
;
}
if
(
!
text
|
|
!
text
.
startsWith
(
{
keyword
}
)
)
{
throw
new
Error
(
The
text
provided
must
start
with
:
"
{
keyword
}
"
)
;
}
let
dispositionMap
=
{
current
:
"
currentTab
"
tab
:
"
newForegroundTab
"
tabshifted
:
"
newBackgroundTab
"
}
let
disposition
=
dispositionMap
[
where
]
;
if
(
!
disposition
)
{
throw
new
Error
(
Invalid
"
where
"
argument
:
{
where
}
)
;
}
let
{
extension
}
=
gKeywordMap
.
get
(
keyword
)
;
text
=
text
.
substring
(
keyword
.
length
+
1
)
;
gActiveInputSession
.
end
(
this
.
MSG_INPUT_ENTERED
text
disposition
)
gActiveInputSession
=
null
;
}
handleInputCancelled
(
)
{
if
(
!
gActiveInputSession
)
{
throw
new
Error
(
"
There
is
no
active
input
session
"
)
;
}
gActiveInputSession
.
cancel
(
this
.
MSG_INPUT_CANCELLED
)
;
gActiveInputSession
=
null
;
}
}
)
;
