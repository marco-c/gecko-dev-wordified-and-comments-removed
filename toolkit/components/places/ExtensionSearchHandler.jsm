"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionSearchHandler
"
]
;
let
gActiveKeyword
=
null
;
let
gCurrentCallbackID
=
0
;
let
gSuggestionsCallback
=
null
;
let
gKeywordMap
=
new
Map
(
)
;
class
KeywordInfo
{
constructor
(
extension
)
{
this
.
extension
=
extension
;
this
.
description
=
extension
.
name
;
}
}
var
ExtensionSearchHandler
=
Object
.
freeze
(
{
MSG_INPUT_STARTED
:
"
webext
-
omnibox
-
input
-
started
"
MSG_INPUT_CHANGED
:
"
webext
-
omnibox
-
input
-
changed
"
MSG_INPUT_ENTERED
:
"
webext
-
omnibox
-
input
-
entered
"
MSG_INPUT_CANCELLED
:
"
webext
-
omnibox
-
input
-
cancelled
"
registerKeyword
(
keyword
extension
)
{
if
(
gKeywordMap
.
has
(
keyword
)
)
{
throw
new
Error
(
The
keyword
provided
is
already
registered
:
{
keyword
}
)
;
}
gKeywordMap
.
set
(
keyword
new
KeywordInfo
(
extension
)
)
;
}
unregisterKeyword
(
keyword
)
{
if
(
!
gKeywordMap
.
has
(
keyword
)
)
{
throw
new
Error
(
The
keyword
provided
is
not
registered
:
{
keyword
}
)
;
}
gActiveKeyword
=
null
;
gKeywordMap
.
delete
(
keyword
)
;
}
isKeywordRegistered
(
keyword
)
{
return
gKeywordMap
.
has
(
keyword
)
;
}
getDescription
(
keyword
)
{
if
(
!
gKeywordMap
.
has
(
keyword
)
)
{
throw
new
Error
(
The
keyword
provided
is
not
registered
:
{
keyword
}
)
;
}
return
gKeywordMap
.
get
(
keyword
)
.
description
;
}
hasActiveInputSession
(
)
{
return
gActiveKeyword
!
=
null
;
}
setDefaultSuggestion
(
keyword
{
description
}
)
{
if
(
!
gKeywordMap
.
has
(
keyword
)
)
{
throw
new
Error
(
The
keyword
provided
is
not
registered
:
{
keyword
}
)
;
}
gKeywordMap
.
get
(
keyword
)
.
description
=
description
;
}
addSuggestions
(
keyword
id
suggestions
)
{
if
(
!
gKeywordMap
.
has
(
keyword
)
)
{
throw
new
Error
(
The
keyword
provided
is
not
registered
:
{
keyword
}
)
;
}
if
(
keyword
!
=
gActiveKeyword
)
{
throw
new
Error
(
"
A
different
input
session
is
already
ongoing
"
)
;
}
if
(
id
!
=
gCurrentCallbackID
)
{
throw
new
Error
(
"
The
callback
is
no
longer
active
"
)
;
}
gSuggestionsCallback
(
suggestions
)
;
}
handleSearch
(
keyword
text
callback
)
{
if
(
!
gKeywordMap
.
has
(
keyword
)
)
{
throw
new
Error
(
The
keyword
provided
is
not
registered
:
{
keyword
}
)
;
}
if
(
gActiveKeyword
&
&
keyword
!
=
gActiveKeyword
)
{
throw
new
Error
(
"
A
different
input
session
is
already
ongoing
"
)
;
}
if
(
!
callback
)
{
throw
new
Error
(
"
A
callback
must
be
provided
"
)
;
}
let
{
extension
}
=
gKeywordMap
.
get
(
keyword
)
;
if
(
!
gActiveKeyword
)
{
extension
.
emit
(
this
.
MSG_INPUT_STARTED
)
;
}
text
=
text
.
substring
(
keyword
.
length
+
1
)
;
if
(
gActiveKeyword
|
|
text
.
length
)
{
gCurrentCallbackID
+
+
;
gSuggestionsCallback
=
callback
;
extension
.
emit
(
this
.
MSG_INPUT_CHANGED
text
gCurrentCallbackID
)
;
}
if
(
!
gActiveKeyword
)
{
gActiveKeyword
=
keyword
;
}
}
handleInputEntered
(
keyword
text
where
)
{
let
dispositionMap
=
{
current
:
"
currentTab
"
tab
:
"
newForegroundTab
"
tabshifted
:
"
newBackgroundTab
"
}
let
{
extension
}
=
gKeywordMap
.
get
(
keyword
)
;
let
disposition
=
dispositionMap
[
where
]
|
|
dispositionMap
.
current
;
text
=
text
.
substring
(
keyword
.
length
+
1
)
;
gCurrentCallbackID
+
+
;
gActiveKeyword
=
null
;
extension
.
emit
(
this
.
MSG_INPUT_ENTERED
text
disposition
)
;
}
handleInputCancelled
(
)
{
if
(
!
gActiveKeyword
)
{
throw
new
Error
(
"
There
is
no
active
input
session
to
handle
"
)
;
}
let
{
extension
}
=
gKeywordMap
.
get
(
gActiveKeyword
)
;
gCurrentCallbackID
+
+
;
gActiveKeyword
=
null
;
extension
.
emit
(
this
.
MSG_INPUT_CANCELLED
)
;
}
}
)
;
