#
include
"
Helpers
.
h
"
#
include
"
mozIStorageError
.
h
"
#
include
"
prio
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsNavHistory
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
Services
.
h
"
#
define
GUID_LENGTH
12
#
define
MAX_CHARS_TO_HASH
1500U
namespace
mozilla
{
namespace
places
{
NS_IMPL_ISUPPORTS
(
AsyncStatementCallback
mozIStorageStatementCallback
)
NS_IMETHODIMP
WeakAsyncStatementCallback
:
:
HandleResult
(
mozIStorageResultSet
*
aResultSet
)
{
MOZ_ASSERT
(
false
"
Was
not
expecting
a
resultset
but
got
it
.
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
WeakAsyncStatementCallback
:
:
HandleCompletion
(
uint16_t
aReason
)
{
return
NS_OK
;
}
NS_IMETHODIMP
WeakAsyncStatementCallback
:
:
HandleError
(
mozIStorageError
*
aError
)
{
#
ifdef
DEBUG
int32_t
result
;
nsresult
rv
=
aError
-
>
GetResult
(
&
result
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
message
;
rv
=
aError
-
>
GetMessage
(
message
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
warnMsg
;
warnMsg
.
AppendLiteral
(
"
An
error
occurred
while
executing
an
async
statement
:
"
)
;
warnMsg
.
AppendInt
(
result
)
;
warnMsg
.
Append
(
'
'
)
;
warnMsg
.
Append
(
message
)
;
NS_WARNING
(
warnMsg
.
get
(
)
)
;
#
endif
return
NS_OK
;
}
#
define
URI_TO_URLCSTRING
(
uri
spec
)
\
nsAutoCString
spec
;
\
if
(
NS_FAILED
(
aURI
-
>
GetSpec
(
spec
)
)
)
{
\
return
NS_ERROR_UNEXPECTED
;
\
}
nsresult
URIBinder
:
:
Bind
(
mozIStorageStatement
*
aStatement
int32_t
aIndex
nsIURI
*
aURI
)
{
NS_ASSERTION
(
aStatement
"
Must
have
non
-
null
statement
"
)
;
NS_ASSERTION
(
aURI
"
Must
have
non
-
null
uri
"
)
;
URI_TO_URLCSTRING
(
aURI
spec
)
;
return
URIBinder
:
:
Bind
(
aStatement
aIndex
spec
)
;
}
nsresult
URIBinder
:
:
Bind
(
mozIStorageStatement
*
aStatement
int32_t
index
const
nsACString
&
aURLString
)
{
NS_ASSERTION
(
aStatement
"
Must
have
non
-
null
statement
"
)
;
return
aStatement
-
>
BindUTF8StringByIndex
(
index
StringHead
(
aURLString
URI_LENGTH_MAX
)
)
;
}
nsresult
URIBinder
:
:
Bind
(
mozIStorageStatement
*
aStatement
const
nsACString
&
aName
nsIURI
*
aURI
)
{
NS_ASSERTION
(
aStatement
"
Must
have
non
-
null
statement
"
)
;
NS_ASSERTION
(
aURI
"
Must
have
non
-
null
uri
"
)
;
URI_TO_URLCSTRING
(
aURI
spec
)
;
return
URIBinder
:
:
Bind
(
aStatement
aName
spec
)
;
}
nsresult
URIBinder
:
:
Bind
(
mozIStorageStatement
*
aStatement
const
nsACString
&
aName
const
nsACString
&
aURLString
)
{
NS_ASSERTION
(
aStatement
"
Must
have
non
-
null
statement
"
)
;
return
aStatement
-
>
BindUTF8StringByName
(
aName
StringHead
(
aURLString
URI_LENGTH_MAX
)
)
;
}
nsresult
URIBinder
:
:
Bind
(
mozIStorageBindingParams
*
aParams
int32_t
aIndex
nsIURI
*
aURI
)
{
NS_ASSERTION
(
aParams
"
Must
have
non
-
null
statement
"
)
;
NS_ASSERTION
(
aURI
"
Must
have
non
-
null
uri
"
)
;
URI_TO_URLCSTRING
(
aURI
spec
)
;
return
URIBinder
:
:
Bind
(
aParams
aIndex
spec
)
;
}
nsresult
URIBinder
:
:
Bind
(
mozIStorageBindingParams
*
aParams
int32_t
index
const
nsACString
&
aURLString
)
{
NS_ASSERTION
(
aParams
"
Must
have
non
-
null
statement
"
)
;
return
aParams
-
>
BindUTF8StringByIndex
(
index
StringHead
(
aURLString
URI_LENGTH_MAX
)
)
;
}
nsresult
URIBinder
:
:
Bind
(
mozIStorageBindingParams
*
aParams
const
nsACString
&
aName
nsIURI
*
aURI
)
{
NS_ASSERTION
(
aParams
"
Must
have
non
-
null
params
array
"
)
;
NS_ASSERTION
(
aURI
"
Must
have
non
-
null
uri
"
)
;
URI_TO_URLCSTRING
(
aURI
spec
)
;
return
URIBinder
:
:
Bind
(
aParams
aName
spec
)
;
}
nsresult
URIBinder
:
:
Bind
(
mozIStorageBindingParams
*
aParams
const
nsACString
&
aName
const
nsACString
&
aURLString
)
{
NS_ASSERTION
(
aParams
"
Must
have
non
-
null
params
array
"
)
;
nsresult
rv
=
aParams
-
>
BindUTF8StringByName
(
aName
StringHead
(
aURLString
URI_LENGTH_MAX
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
#
undef
URI_TO_URLCSTRING
nsresult
GetReversedHostname
(
nsIURI
*
aURI
nsString
&
aRevHost
)
{
nsAutoCString
forward8
;
nsresult
rv
=
aURI
-
>
GetHost
(
forward8
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
GetReversedHostname
(
NS_ConvertUTF8toUTF16
(
forward8
)
aRevHost
)
;
return
NS_OK
;
}
void
GetReversedHostname
(
const
nsString
&
aForward
nsString
&
aRevHost
)
{
ReverseString
(
aForward
aRevHost
)
;
aRevHost
.
Append
(
char16_t
(
'
.
'
)
)
;
}
void
ReverseString
(
const
nsString
&
aInput
nsString
&
aReversed
)
{
aReversed
.
Truncate
(
0
)
;
for
(
int32_t
i
=
aInput
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
aReversed
.
Append
(
aInput
[
i
]
)
;
}
}
static
nsresult
GenerateRandomBytes
(
uint32_t
aSize
uint8_t
*
_buffer
)
{
#
if
defined
(
XP_WIN
)
const
nsNavHistory
*
history
=
nsNavHistory
:
:
GetConstHistoryService
(
)
;
HCRYPTPROV
cryptoProvider
;
nsresult
rv
=
history
-
>
GetCryptoProvider
(
cryptoProvider
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
BOOL
rc
=
CryptGenRandom
(
cryptoProvider
aSize
_buffer
)
;
return
rc
?
NS_OK
:
NS_ERROR_FAILURE
;
#
elif
defined
(
XP_UNIX
)
NS_ENSURE_ARG_MAX
(
aSize
INT32_MAX
)
;
PRFileDesc
*
urandom
=
PR_Open
(
"
/
dev
/
urandom
"
PR_RDONLY
0
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
if
(
urandom
)
{
int32_t
bytesRead
=
PR_Read
(
urandom
_buffer
aSize
)
;
if
(
bytesRead
=
=
static_cast
<
int32_t
>
(
aSize
)
)
{
rv
=
NS_OK
;
}
(
void
)
PR_Close
(
urandom
)
;
}
return
rv
;
#
endif
}
nsresult
GenerateGUID
(
nsACString
&
_guid
)
{
_guid
.
Truncate
(
)
;
const
uint32_t
kRequiredBytesLength
=
static_cast
<
uint32_t
>
(
GUID_LENGTH
/
4
*
3
)
;
uint8_t
buffer
[
kRequiredBytesLength
]
;
nsresult
rv
=
GenerateRandomBytes
(
kRequiredBytesLength
buffer
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
Base64URLEncode
(
kRequiredBytesLength
buffer
Base64URLEncodePaddingPolicy
:
:
Omit
_guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
_guid
.
Length
(
)
=
=
GUID_LENGTH
"
GUID
is
not
the
right
size
!
"
)
;
return
NS_OK
;
}
bool
IsValidGUID
(
const
nsACString
&
aGUID
)
{
nsCString
:
:
size_type
len
=
aGUID
.
Length
(
)
;
if
(
len
!
=
GUID_LENGTH
)
{
return
false
;
}
for
(
nsCString
:
:
size_type
i
=
0
;
i
<
len
;
i
+
+
)
{
char
c
=
aGUID
[
i
]
;
if
(
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
|
|
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
|
|
(
c
>
=
'
0
'
&
&
c
<
=
'
9
'
)
|
|
c
=
=
'
-
'
|
|
c
=
=
'
_
'
)
{
continue
;
}
return
false
;
}
return
true
;
}
void
TruncateTitle
(
const
nsACString
&
aTitle
nsACString
&
aTrimmed
)
{
if
(
aTitle
.
IsVoid
(
)
)
{
return
;
}
aTrimmed
=
aTitle
;
if
(
aTitle
.
Length
(
)
>
TITLE_LENGTH_MAX
)
{
aTrimmed
=
StringHead
(
aTitle
TITLE_LENGTH_MAX
)
;
}
}
PRTime
RoundToMilliseconds
(
PRTime
aTime
)
{
return
aTime
-
(
aTime
%
PR_USEC_PER_MSEC
)
;
}
PRTime
RoundedPRNow
(
)
{
return
RoundToMilliseconds
(
PR_Now
(
)
)
;
}
nsresult
HashURL
(
const
nsACString
&
aSpec
const
nsACString
&
aMode
uint64_t
*
_hash
)
{
NS_ENSURE_ARG_POINTER
(
_hash
)
;
const
uint32_t
maxLenToHash
=
std
:
:
min
(
static_cast
<
uint32_t
>
(
aSpec
.
Length
(
)
)
MAX_CHARS_TO_HASH
)
;
if
(
aMode
.
IsEmpty
(
)
)
{
const
nsDependentCSubstring
&
strHead
=
StringHead
(
aSpec
50
)
;
nsACString
:
:
const_iterator
start
tip
end
;
strHead
.
BeginReading
(
tip
)
;
start
=
tip
;
strHead
.
EndReading
(
end
)
;
uint32_t
strHash
=
HashString
(
aSpec
.
BeginReading
(
)
maxLenToHash
)
;
if
(
FindCharInReadable
(
'
:
'
tip
end
)
)
{
const
nsDependentCSubstring
&
prefix
=
Substring
(
start
tip
)
;
uint64_t
prefixHash
=
static_cast
<
uint64_t
>
(
HashString
(
prefix
)
&
0x0000FFFF
)
;
*
_hash
=
(
prefixHash
<
<
32
)
+
strHash
;
}
else
{
*
_hash
=
strHash
;
}
}
else
if
(
aMode
.
EqualsLiteral
(
"
prefix_lo
"
)
)
{
*
_hash
=
static_cast
<
uint64_t
>
(
HashString
(
aSpec
.
BeginReading
(
)
maxLenToHash
)
&
0x0000FFFF
)
<
<
32
;
}
else
if
(
aMode
.
EqualsLiteral
(
"
prefix_hi
"
)
)
{
*
_hash
=
static_cast
<
uint64_t
>
(
HashString
(
aSpec
.
BeginReading
(
)
maxLenToHash
)
&
0x0000FFFF
)
<
<
32
;
*
_hash
+
=
0xFFFFFFFF
;
}
else
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
bool
GetHiddenState
(
bool
aIsRedirect
uint32_t
aTransitionType
)
{
return
aTransitionType
=
=
nsINavHistoryService
:
:
TRANSITION_FRAMED_LINK
|
|
aTransitionType
=
=
nsINavHistoryService
:
:
TRANSITION_EMBED
|
|
aIsRedirect
;
}
nsresult
TokenizeQueryString
(
const
nsACString
&
aQuery
nsTArray
<
QueryKeyValuePair
>
*
aTokens
)
{
const
uint32_t
prefixlen
=
6
;
nsCString
query
;
if
(
aQuery
.
Length
(
)
>
=
prefixlen
&
&
Substring
(
aQuery
0
prefixlen
)
.
EqualsLiteral
(
"
place
:
"
)
)
query
=
Substring
(
aQuery
prefixlen
)
;
else
query
=
aQuery
;
int32_t
keyFirstIndex
=
0
;
int32_t
equalsIndex
=
0
;
for
(
uint32_t
i
=
0
;
i
<
query
.
Length
(
)
;
i
+
+
)
{
if
(
query
[
i
]
=
=
'
&
'
)
{
if
(
i
-
keyFirstIndex
>
1
)
{
if
(
!
aTokens
-
>
AppendElement
(
QueryKeyValuePair
(
query
keyFirstIndex
equalsIndex
i
)
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
}
keyFirstIndex
=
equalsIndex
=
i
+
1
;
}
else
if
(
query
[
i
]
=
=
'
=
'
)
{
equalsIndex
=
i
;
}
}
if
(
query
.
Length
(
)
-
keyFirstIndex
>
1
)
{
if
(
!
aTokens
-
>
AppendElement
(
QueryKeyValuePair
(
query
keyFirstIndex
equalsIndex
query
.
Length
(
)
)
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
void
TokensToQueryString
(
const
nsTArray
<
QueryKeyValuePair
>
&
aTokens
nsACString
&
aQuery
)
{
aQuery
=
NS_LITERAL_CSTRING
(
"
place
:
"
)
;
for
(
uint32_t
i
=
0
;
i
<
aTokens
.
Length
(
)
;
i
+
+
)
{
if
(
i
>
0
)
{
aQuery
.
Append
(
"
&
"
)
;
}
aQuery
.
Append
(
aTokens
[
i
]
.
key
)
;
aQuery
.
AppendLiteral
(
"
=
"
)
;
aQuery
.
Append
(
aTokens
[
i
]
.
value
)
;
}
}
NS_IMETHODIMP
AsyncStatementCallbackNotifier
:
:
HandleCompletion
(
uint16_t
aReason
)
{
if
(
aReason
!
=
mozIStorageStatementCallback
:
:
REASON_FINISHED
)
return
NS_ERROR_UNEXPECTED
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
(
void
)
obs
-
>
NotifyObservers
(
nullptr
mTopic
nullptr
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AsyncStatementTelemetryTimer
:
:
HandleCompletion
(
uint16_t
aReason
)
{
if
(
aReason
=
=
mozIStorageStatementCallback
:
:
REASON_FINISHED
)
{
Telemetry
:
:
AccumulateTimeDelta
(
mHistogramId
mStart
)
;
}
return
NS_OK
;
}
}
}
