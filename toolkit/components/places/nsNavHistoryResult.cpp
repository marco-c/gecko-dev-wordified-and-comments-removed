#
include
<
stdio
.
h
>
#
include
"
nsNavHistory
.
h
"
#
include
"
nsNavBookmarks
.
h
"
#
include
"
nsFaviconService
.
h
"
#
include
"
nsAnnotationService
.
h
"
#
include
"
Helpers
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
prtime
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
mozilla
/
dom
/
PlacesObservers
.
h
"
#
include
"
mozilla
/
dom
/
PlacesVisit
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
undef
CompareString
#
define
TO_ICONTAINER
(
_node
)
\
static_cast
<
nsINavHistoryContainerResultNode
*
>
(
_node
)
#
define
TO_CONTAINER
(
_node
)
static_cast
<
nsNavHistoryContainerResultNode
*
>
(
_node
)
#
define
NOTIFY_RESULT_OBSERVERS_RET
(
_result
_method
_ret
)
\
PR_BEGIN_MACRO
\
NS_ENSURE_TRUE
(
_result
_ret
)
;
\
if
(
!
_result
-
>
mSuppressNotifications
)
{
\
ENUMERATE_WEAKARRAY
(
_result
-
>
mObservers
nsINavHistoryResultObserver
\
_method
)
\
}
\
PR_END_MACRO
#
define
NOTIFY_RESULT_OBSERVERS
(
_result
_method
)
\
NOTIFY_RESULT_OBSERVERS_RET
(
_result
_method
NS_ERROR_UNEXPECTED
)
#
define
NS_INTERFACE_MAP_STATIC_AMBIGUOUS
(
_class
)
\
if
(
aIID
.
Equals
(
NS_GET_IID
(
_class
)
)
)
{
\
NS_ADDREF
(
this
)
;
\
*
aInstancePtr
=
this
;
\
return
NS_OK
;
\
}
else
#
define
MAX_BATCH_CHANGES_BEFORE_REFRESH
5
using
namespace
mozilla
;
using
namespace
mozilla
:
:
places
;
namespace
{
uint32_t
getUpdateRequirements
(
const
RefPtr
<
nsNavHistoryQuery
>
&
aQuery
const
RefPtr
<
nsNavHistoryQueryOptions
>
&
aOptions
bool
*
aHasSearchTerms
)
{
bool
hasSearchTerms
=
*
aHasSearchTerms
=
!
aQuery
-
>
SearchTerms
(
)
.
IsEmpty
(
)
;
bool
nonTimeBasedItems
=
false
;
bool
domainBasedItems
=
false
;
if
(
aQuery
-
>
Parents
(
)
.
Length
(
)
>
0
|
|
aQuery
-
>
OnlyBookmarked
(
)
|
|
aQuery
-
>
Tags
(
)
.
Length
(
)
>
0
|
|
(
aOptions
-
>
QueryType
(
)
=
=
nsINavHistoryQueryOptions
:
:
QUERY_TYPE_BOOKMARKS
&
&
hasSearchTerms
)
)
{
return
QUERYUPDATE_COMPLEX_WITH_BOOKMARKS
;
}
if
(
hasSearchTerms
|
|
!
aQuery
-
>
Domain
(
)
.
IsVoid
(
)
|
|
aQuery
-
>
Uri
(
)
!
=
nullptr
)
nonTimeBasedItems
=
true
;
if
(
!
aQuery
-
>
Domain
(
)
.
IsVoid
(
)
)
domainBasedItems
=
true
;
if
(
aOptions
-
>
ResultType
(
)
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_TAGS_ROOT
)
return
QUERYUPDATE_COMPLEX_WITH_BOOKMARKS
;
if
(
aOptions
-
>
ResultType
(
)
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_ROOTS_QUERY
)
return
QUERYUPDATE_MOBILEPREF
;
if
(
aOptions
-
>
ResultType
(
)
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_LEFT_PANE_QUERY
)
return
QUERYUPDATE_NONE
;
uint16_t
sortingMode
=
aOptions
-
>
SortingMode
(
)
;
if
(
aOptions
-
>
MaxResults
(
)
>
0
&
&
sortingMode
!
=
nsINavHistoryQueryOptions
:
:
SORT_BY_DATE_ASCENDING
&
&
sortingMode
!
=
nsINavHistoryQueryOptions
:
:
SORT_BY_DATE_DESCENDING
)
return
QUERYUPDATE_COMPLEX
;
if
(
domainBasedItems
)
return
QUERYUPDATE_HOST
;
if
(
!
nonTimeBasedItems
)
return
QUERYUPDATE_TIME
;
return
QUERYUPDATE_SIMPLE
;
}
nsresult
asciiHostNameFromHostString
(
const
nsACString
&
aHostName
nsACString
&
aAscii
)
{
aAscii
.
Truncate
(
)
;
if
(
aHostName
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
nsAutoCString
fakeURL
(
"
http
:
/
/
"
)
;
fakeURL
.
Append
(
aHostName
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
fakeURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
uri
-
>
GetAsciiHost
(
aAscii
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
bool
evaluateQueryForNode
(
const
RefPtr
<
nsNavHistoryQuery
>
&
aQuery
const
RefPtr
<
nsNavHistoryQueryOptions
>
&
aOptions
const
RefPtr
<
nsNavHistoryResultNode
>
&
aNode
)
{
if
(
aNode
-
>
mHidden
&
&
!
aOptions
-
>
IncludeHidden
(
)
)
return
false
;
bool
hasIt
;
aQuery
-
>
GetHasBeginTime
(
&
hasIt
)
;
if
(
hasIt
)
{
PRTime
beginTime
=
nsNavHistory
:
:
NormalizeTime
(
aQuery
-
>
BeginTimeReference
(
)
aQuery
-
>
BeginTime
(
)
)
;
if
(
aNode
-
>
mTime
<
beginTime
)
return
false
;
}
aQuery
-
>
GetHasEndTime
(
&
hasIt
)
;
if
(
hasIt
)
{
PRTime
endTime
=
nsNavHistory
:
:
NormalizeTime
(
aQuery
-
>
EndTimeReference
(
)
aQuery
-
>
EndTime
(
)
)
;
if
(
aNode
-
>
mTime
>
endTime
)
return
false
;
}
if
(
!
aQuery
-
>
SearchTerms
(
)
.
IsEmpty
(
)
)
{
nsCOMArray
<
nsNavHistoryResultNode
>
inputSet
;
inputSet
.
AppendObject
(
aNode
)
;
nsCOMArray
<
nsNavHistoryResultNode
>
filteredSet
;
nsresult
rv
=
nsNavHistory
:
:
FilterResultSet
(
nullptr
inputSet
&
filteredSet
aQuery
aOptions
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
if
(
!
filteredSet
.
Count
(
)
)
return
false
;
}
if
(
!
aQuery
-
>
Domain
(
)
.
IsVoid
(
)
)
{
nsCOMPtr
<
nsIURI
>
nodeUri
;
if
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
nodeUri
)
aNode
-
>
mURI
)
)
)
return
false
;
nsAutoCString
asciiRequest
;
if
(
NS_FAILED
(
asciiHostNameFromHostString
(
aQuery
-
>
Domain
(
)
asciiRequest
)
)
)
return
false
;
if
(
aQuery
-
>
DomainIsHost
(
)
)
{
nsAutoCString
host
;
if
(
NS_FAILED
(
nodeUri
-
>
GetAsciiHost
(
host
)
)
)
return
false
;
if
(
!
asciiRequest
.
Equals
(
host
)
)
return
false
;
}
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
if
(
!
history
)
return
false
;
nsAutoCString
domain
;
history
-
>
DomainNameFromURI
(
nodeUri
domain
)
;
if
(
!
asciiRequest
.
Equals
(
domain
)
)
return
false
;
}
if
(
aQuery
-
>
Uri
(
)
)
{
nsCOMPtr
<
nsIURI
>
nodeUri
;
if
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
nodeUri
)
aNode
-
>
mURI
)
)
)
return
false
;
bool
equals
;
nsresult
rv
=
aQuery
-
>
Uri
(
)
-
>
Equals
(
nodeUri
&
equals
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
!
equals
)
return
false
;
}
const
nsTArray
<
uint32_t
>
&
transitions
=
aQuery
-
>
Transitions
(
)
;
if
(
aNode
-
>
mTransitionType
>
0
&
&
transitions
.
Length
(
)
&
&
!
transitions
.
Contains
(
aNode
-
>
mTransitionType
)
)
{
return
false
;
}
return
true
;
}
inline
int32_t
ComparePRTime
(
PRTime
a
PRTime
b
)
{
if
(
a
<
b
)
return
-
1
;
else
if
(
a
>
b
)
return
1
;
return
0
;
}
inline
int32_t
CompareIntegers
(
uint32_t
a
uint32_t
b
)
{
return
a
-
b
;
}
}
NS_IMPL_CYCLE_COLLECTION
(
nsNavHistoryResultNode
mParent
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsNavHistoryResultNode
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsINavHistoryResultNode
)
NS_INTERFACE_MAP_ENTRY
(
nsINavHistoryResultNode
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsNavHistoryResultNode
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsNavHistoryResultNode
)
nsNavHistoryResultNode
:
:
nsNavHistoryResultNode
(
const
nsACString
&
aURI
const
nsACString
&
aTitle
uint32_t
aAccessCount
PRTime
aTime
)
:
mParent
(
nullptr
)
mURI
(
aURI
)
mTitle
(
aTitle
)
mAreTagsSorted
(
false
)
mAccessCount
(
aAccessCount
)
mTime
(
aTime
)
mBookmarkIndex
(
-
1
)
mItemId
(
-
1
)
mFolderId
(
-
1
)
mVisitId
(
-
1
)
mFromVisitId
(
-
1
)
mDateAdded
(
0
)
mLastModified
(
0
)
mIndentLevel
(
-
1
)
mFrecency
(
0
)
mHidden
(
false
)
mTransitionType
(
0
)
{
mTags
.
SetIsVoid
(
true
)
;
}
NS_IMETHODIMP
nsNavHistoryResultNode
:
:
GetIcon
(
nsACString
&
aIcon
)
{
if
(
this
-
>
IsContainer
(
)
|
|
mURI
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
aIcon
.
AppendLiteral
(
"
page
-
icon
:
"
)
;
aIcon
.
Append
(
mURI
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResultNode
:
:
GetParent
(
nsINavHistoryContainerResultNode
*
*
aParent
)
{
NS_IF_ADDREF
(
*
aParent
=
mParent
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResultNode
:
:
GetParentResult
(
nsINavHistoryResult
*
*
aResult
)
{
*
aResult
=
nullptr
;
if
(
IsContainer
(
)
)
NS_IF_ADDREF
(
*
aResult
=
GetAsContainer
(
)
-
>
mResult
)
;
else
if
(
mParent
)
NS_IF_ADDREF
(
*
aResult
=
mParent
-
>
mResult
)
;
NS_ENSURE_STATE
(
*
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResultNode
:
:
GetTags
(
nsAString
&
aTags
)
{
if
(
!
IsURI
(
)
)
{
aTags
.
Truncate
(
)
;
return
NS_OK
;
}
if
(
!
mTags
.
IsVoid
(
)
)
{
if
(
!
mAreTagsSorted
)
{
nsTArray
<
nsCString
>
tags
;
ParseString
(
NS_ConvertUTF16toUTF8
(
mTags
)
'
'
tags
)
;
tags
.
Sort
(
)
;
mTags
.
SetIsVoid
(
true
)
;
for
(
nsTArray
<
nsCString
>
:
:
index_type
i
=
0
;
i
<
tags
.
Length
(
)
;
+
+
i
)
{
AppendUTF8toUTF16
(
tags
[
i
]
mTags
)
;
if
(
i
<
tags
.
Length
(
)
-
1
)
mTags
.
AppendLiteral
(
"
"
)
;
}
mAreTagsSorted
=
true
;
}
aTags
.
Assign
(
mTags
)
;
return
NS_OK
;
}
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
DB
-
>
GetStatement
(
"
/
*
do
not
warn
(
bug
487594
)
*
/
"
"
SELECT
GROUP_CONCAT
(
tag_title
'
'
)
"
"
FROM
(
"
"
SELECT
t
.
title
AS
tag_title
"
"
FROM
moz_bookmarks
b
"
"
JOIN
moz_bookmarks
t
ON
t
.
id
=
+
b
.
parent
"
"
WHERE
b
.
fk
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
"
"
hash
(
:
page_url
)
AND
url
=
:
page_url
)
"
"
AND
t
.
parent
=
:
tags_folder
"
"
ORDER
BY
t
.
title
COLLATE
NOCASE
ASC
"
"
)
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_STATE
(
history
)
;
nsresult
rv
=
stmt
-
>
BindInt64ByName
(
"
tags_folder
"
_ns
history
-
>
GetTagsFolder
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
URIBinder
:
:
Bind
(
stmt
"
page_url
"
_ns
mURI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasTags
=
false
;
if
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasTags
)
)
&
&
hasTags
)
{
rv
=
stmt
-
>
GetString
(
0
mTags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aTags
.
Assign
(
mTags
)
;
mAreTagsSorted
=
true
;
}
if
(
mParent
&
&
mParent
-
>
IsQuery
(
)
&
&
mParent
-
>
mOptions
-
>
QueryType
(
)
=
=
nsINavHistoryQueryOptions
:
:
QUERY_TYPE_HISTORY
)
{
nsNavHistoryQueryResultNode
*
query
=
mParent
-
>
GetAsQuery
(
)
;
nsNavHistoryResult
*
result
=
query
-
>
GetResult
(
)
;
NS_ENSURE_STATE
(
result
)
;
result
-
>
AddAllBookmarksObserver
(
query
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResultNode
:
:
GetPageGuid
(
nsACString
&
aPageGuid
)
{
aPageGuid
=
mPageGuid
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResultNode
:
:
GetBookmarkGuid
(
nsACString
&
aBookmarkGuid
)
{
aBookmarkGuid
=
mBookmarkGuid
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResultNode
:
:
GetVisitId
(
int64_t
*
aVisitId
)
{
*
aVisitId
=
mVisitId
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResultNode
:
:
GetFromVisitId
(
int64_t
*
aFromVisitId
)
{
*
aFromVisitId
=
mFromVisitId
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResultNode
:
:
GetVisitType
(
uint32_t
*
aVisitType
)
{
*
aVisitType
=
mTransitionType
;
return
NS_OK
;
}
void
nsNavHistoryResultNode
:
:
OnRemoving
(
)
{
mParent
=
nullptr
;
}
nsNavHistoryResult
*
nsNavHistoryResultNode
:
:
GetResult
(
)
{
nsNavHistoryResultNode
*
node
=
this
;
do
{
if
(
node
-
>
IsContainer
(
)
)
{
nsNavHistoryContainerResultNode
*
container
=
TO_CONTAINER
(
node
)
;
return
container
-
>
mResult
;
}
node
=
node
-
>
mParent
;
}
while
(
node
)
;
MOZ_ASSERT
(
false
"
No
container
node
found
in
hierarchy
!
"
)
;
return
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
nsNavHistoryContainerResultNode
nsNavHistoryResultNode
mResult
mChildren
)
NS_IMPL_ADDREF_INHERITED
(
nsNavHistoryContainerResultNode
nsNavHistoryResultNode
)
NS_IMPL_RELEASE_INHERITED
(
nsNavHistoryContainerResultNode
nsNavHistoryResultNode
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsNavHistoryContainerResultNode
)
NS_INTERFACE_MAP_STATIC_AMBIGUOUS
(
nsNavHistoryContainerResultNode
)
NS_INTERFACE_MAP_ENTRY
(
nsINavHistoryContainerResultNode
)
NS_INTERFACE_MAP_END_INHERITING
(
nsNavHistoryResultNode
)
nsNavHistoryContainerResultNode
:
:
nsNavHistoryContainerResultNode
(
const
nsACString
&
aURI
const
nsACString
&
aTitle
PRTime
aTime
uint32_t
aContainerType
nsNavHistoryQueryOptions
*
aOptions
)
:
nsNavHistoryResultNode
(
aURI
aTitle
0
aTime
)
mResult
(
nullptr
)
mContainerType
(
aContainerType
)
mExpanded
(
false
)
mOptions
(
aOptions
)
mAsyncCanceledState
(
NOT_CANCELED
)
{
MOZ_ASSERT
(
mOptions
)
;
MOZ_ALWAYS_SUCCEEDS
(
mOptions
-
>
Clone
(
getter_AddRefs
(
mOriginalOptions
)
)
)
;
}
nsNavHistoryContainerResultNode
:
:
~
nsNavHistoryContainerResultNode
(
)
{
mChildren
.
Clear
(
)
;
}
void
nsNavHistoryContainerResultNode
:
:
OnRemoving
(
)
{
nsNavHistoryResultNode
:
:
OnRemoving
(
)
;
for
(
int32_t
i
=
0
;
i
<
mChildren
.
Count
(
)
;
+
+
i
)
mChildren
[
i
]
-
>
OnRemoving
(
)
;
mChildren
.
Clear
(
)
;
mResult
=
nullptr
;
}
bool
nsNavHistoryContainerResultNode
:
:
AreChildrenVisible
(
)
{
nsNavHistoryResult
*
result
=
GetResult
(
)
;
if
(
!
result
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
result
"
)
;
return
false
;
}
if
(
!
mExpanded
)
return
false
;
nsNavHistoryContainerResultNode
*
ancestor
=
mParent
;
while
(
ancestor
)
{
if
(
!
ancestor
-
>
mExpanded
)
return
false
;
ancestor
=
ancestor
-
>
mParent
;
}
return
true
;
}
NS_IMETHODIMP
nsNavHistoryContainerResultNode
:
:
GetContainerOpen
(
bool
*
aContainerOpen
)
{
*
aContainerOpen
=
mExpanded
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryContainerResultNode
:
:
SetContainerOpen
(
bool
aContainerOpen
)
{
if
(
aContainerOpen
)
{
if
(
!
mExpanded
)
{
if
(
mOptions
-
>
AsyncEnabled
(
)
)
OpenContainerAsync
(
)
;
else
OpenContainer
(
)
;
}
}
else
{
if
(
mExpanded
)
CloseContainer
(
)
;
else
if
(
mAsyncPendingStmt
)
CancelAsyncOpen
(
false
)
;
}
return
NS_OK
;
}
nsresult
nsNavHistoryContainerResultNode
:
:
NotifyOnStateChange
(
uint16_t
aOldState
)
{
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NS_ENSURE_STATE
(
result
)
;
nsresult
rv
;
uint16_t
currState
;
rv
=
GetState
(
&
currState
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NOTIFY_RESULT_OBSERVERS
(
result
ContainerStateChanged
(
this
aOldState
currState
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryContainerResultNode
:
:
GetState
(
uint16_t
*
_state
)
{
NS_ENSURE_ARG_POINTER
(
_state
)
;
*
_state
=
mExpanded
?
(
uint16_t
)
STATE_OPENED
:
mAsyncPendingStmt
?
(
uint16_t
)
STATE_LOADING
:
(
uint16_t
)
STATE_CLOSED
;
return
NS_OK
;
}
nsresult
nsNavHistoryContainerResultNode
:
:
OpenContainer
(
)
{
NS_ASSERTION
(
!
mExpanded
"
Container
must
not
be
expanded
to
open
it
"
)
;
mExpanded
=
true
;
nsresult
rv
=
NotifyOnStateChange
(
STATE_CLOSED
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
nsNavHistoryContainerResultNode
:
:
CloseContainer
(
bool
aSuppressNotifications
)
{
NS_ASSERTION
(
(
mExpanded
&
&
!
mAsyncPendingStmt
)
|
|
(
!
mExpanded
&
&
mAsyncPendingStmt
)
"
Container
must
be
expanded
or
loading
to
close
it
"
)
;
nsresult
rv
;
uint16_t
oldState
;
rv
=
GetState
(
&
oldState
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mExpanded
)
{
for
(
int32_t
i
=
0
;
i
<
mChildren
.
Count
(
)
;
+
+
i
)
{
if
(
mChildren
[
i
]
-
>
IsContainer
(
)
&
&
mChildren
[
i
]
-
>
GetAsContainer
(
)
-
>
mExpanded
)
mChildren
[
i
]
-
>
GetAsContainer
(
)
-
>
CloseContainer
(
true
)
;
}
mExpanded
=
false
;
}
mAsyncPendingStmt
=
nullptr
;
if
(
!
aSuppressNotifications
)
{
rv
=
NotifyOnStateChange
(
oldState
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NS_ENSURE_STATE
(
result
)
;
if
(
result
-
>
mRootNode
=
=
this
)
{
result
-
>
StopObserving
(
)
;
if
(
this
-
>
IsQuery
(
)
)
this
-
>
GetAsQuery
(
)
-
>
ClearChildren
(
true
)
;
else
if
(
this
-
>
IsFolder
(
)
)
this
-
>
GetAsFolder
(
)
-
>
ClearChildren
(
true
)
;
}
return
NS_OK
;
}
nsresult
nsNavHistoryContainerResultNode
:
:
OpenContainerAsync
(
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
void
nsNavHistoryContainerResultNode
:
:
CancelAsyncOpen
(
bool
aRestart
)
{
NS_ASSERTION
(
mAsyncPendingStmt
"
Async
execution
canceled
but
not
pending
"
)
;
mAsyncCanceledState
=
aRestart
?
CANCELED_RESTART_NEEDED
:
CANCELED
;
(
void
)
mAsyncPendingStmt
-
>
Cancel
(
)
;
}
void
nsNavHistoryContainerResultNode
:
:
FillStats
(
)
{
uint32_t
accessCount
=
0
;
PRTime
newTime
=
0
;
for
(
int32_t
i
=
0
;
i
<
mChildren
.
Count
(
)
;
+
+
i
)
{
nsNavHistoryResultNode
*
node
=
mChildren
[
i
]
;
SetAsParentOfNode
(
node
)
;
accessCount
+
=
node
-
>
mAccessCount
;
if
(
node
-
>
mTime
>
newTime
)
newTime
=
node
-
>
mTime
;
}
if
(
mExpanded
)
{
mAccessCount
=
accessCount
;
if
(
!
IsQuery
(
)
|
|
newTime
>
mTime
)
mTime
=
newTime
;
}
}
void
nsNavHistoryContainerResultNode
:
:
SetAsParentOfNode
(
nsNavHistoryResultNode
*
aNode
)
{
aNode
-
>
mParent
=
this
;
aNode
-
>
mIndentLevel
=
mIndentLevel
+
1
;
if
(
aNode
-
>
IsContainer
(
)
)
{
nsNavHistoryContainerResultNode
*
container
=
aNode
-
>
GetAsContainer
(
)
;
if
(
mOptions
-
>
ExcludeItems
(
)
)
{
container
-
>
mOptions
-
>
SetExcludeItems
(
true
)
;
}
if
(
mOptions
-
>
ExcludeQueries
(
)
)
{
container
-
>
mOptions
-
>
SetExcludeQueries
(
true
)
;
}
if
(
aNode
-
>
IsFolder
(
)
&
&
mOptions
-
>
AsyncEnabled
(
)
)
{
container
-
>
mOptions
-
>
SetAsyncEnabled
(
true
)
;
}
if
(
!
mOptions
-
>
ExpandQueries
(
)
)
{
container
-
>
mOptions
-
>
SetExpandQueries
(
false
)
;
}
container
-
>
mResult
=
mResult
;
container
-
>
FillStats
(
)
;
}
}
nsresult
nsNavHistoryContainerResultNode
:
:
ReverseUpdateStats
(
int32_t
aAccessCountChange
)
{
if
(
mParent
)
{
nsNavHistoryResult
*
result
=
GetResult
(
)
;
bool
shouldNotify
=
result
&
&
mParent
-
>
mParent
&
&
mParent
-
>
mParent
-
>
AreChildrenVisible
(
)
;
uint32_t
oldAccessCount
=
mParent
-
>
mAccessCount
;
PRTime
oldTime
=
mParent
-
>
mTime
;
mParent
-
>
mAccessCount
+
=
aAccessCountChange
;
bool
timeChanged
=
false
;
if
(
mTime
>
mParent
-
>
mTime
)
{
timeChanged
=
true
;
mParent
-
>
mTime
=
mTime
;
}
if
(
shouldNotify
)
{
NOTIFY_RESULT_OBSERVERS
(
result
NodeHistoryDetailsChanged
(
TO_ICONTAINER
(
mParent
)
oldTime
oldAccessCount
)
)
;
}
uint16_t
sortMode
=
mParent
-
>
GetSortType
(
)
;
bool
sortingByVisitCount
=
sortMode
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_VISITCOUNT_ASCENDING
|
|
sortMode
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_VISITCOUNT_DESCENDING
;
bool
sortingByTime
=
sortMode
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_DATE_ASCENDING
|
|
sortMode
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_DATE_DESCENDING
;
if
(
(
sortingByVisitCount
&
&
aAccessCountChange
!
=
0
)
|
|
(
sortingByTime
&
&
timeChanged
)
)
{
int32_t
ourIndex
=
mParent
-
>
FindChild
(
this
)
;
NS_ASSERTION
(
ourIndex
>
=
0
"
Could
not
find
self
in
parent
"
)
;
if
(
ourIndex
>
=
0
)
EnsureItemPosition
(
static_cast
<
uint32_t
>
(
ourIndex
)
)
;
}
nsresult
rv
=
mParent
-
>
ReverseUpdateStats
(
aAccessCountChange
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
uint16_t
nsNavHistoryContainerResultNode
:
:
GetSortType
(
)
{
if
(
mParent
)
return
mParent
-
>
GetSortType
(
)
;
if
(
mResult
)
return
mResult
-
>
mSortingMode
;
return
nsINavHistoryQueryOptions
:
:
SORT_BY_NONE
;
}
nsresult
nsNavHistoryContainerResultNode
:
:
Refresh
(
)
{
NS_WARNING
(
"
Refresh
(
)
is
supported
by
queries
or
folders
not
generic
containers
.
"
)
;
return
NS_OK
;
}
nsNavHistoryContainerResultNode
:
:
SortComparator
nsNavHistoryContainerResultNode
:
:
GetSortingComparator
(
uint16_t
aSortType
)
{
switch
(
aSortType
)
{
case
nsINavHistoryQueryOptions
:
:
SORT_BY_NONE
:
return
&
SortComparison_Bookmark
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_TITLE_ASCENDING
:
return
&
SortComparison_TitleLess
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_TITLE_DESCENDING
:
return
&
SortComparison_TitleGreater
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_DATE_ASCENDING
:
return
&
SortComparison_DateLess
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_DATE_DESCENDING
:
return
&
SortComparison_DateGreater
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_URI_ASCENDING
:
return
&
SortComparison_URILess
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_URI_DESCENDING
:
return
&
SortComparison_URIGreater
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_VISITCOUNT_ASCENDING
:
return
&
SortComparison_VisitCountLess
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_VISITCOUNT_DESCENDING
:
return
&
SortComparison_VisitCountGreater
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_DATEADDED_ASCENDING
:
return
&
SortComparison_DateAddedLess
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_DATEADDED_DESCENDING
:
return
&
SortComparison_DateAddedGreater
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_LASTMODIFIED_ASCENDING
:
return
&
SortComparison_LastModifiedLess
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_LASTMODIFIED_DESCENDING
:
return
&
SortComparison_LastModifiedGreater
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_TAGS_ASCENDING
:
return
&
SortComparison_TagsLess
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_TAGS_DESCENDING
:
return
&
SortComparison_TagsGreater
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_FRECENCY_ASCENDING
:
return
&
SortComparison_FrecencyLess
;
case
nsINavHistoryQueryOptions
:
:
SORT_BY_FRECENCY_DESCENDING
:
return
&
SortComparison_FrecencyGreater
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Bad
sorting
type
"
)
;
return
nullptr
;
}
}
void
nsNavHistoryContainerResultNode
:
:
RecursiveSort
(
SortComparator
aComparator
)
{
mChildren
.
Sort
(
aComparator
nullptr
)
;
for
(
int32_t
i
=
0
;
i
<
mChildren
.
Count
(
)
;
+
+
i
)
{
if
(
mChildren
[
i
]
-
>
IsContainer
(
)
)
mChildren
[
i
]
-
>
GetAsContainer
(
)
-
>
RecursiveSort
(
aComparator
)
;
}
}
uint32_t
nsNavHistoryContainerResultNode
:
:
FindInsertionPoint
(
nsNavHistoryResultNode
*
aNode
SortComparator
aComparator
bool
*
aItemExists
)
{
if
(
aItemExists
)
(
*
aItemExists
)
=
false
;
if
(
mChildren
.
Count
(
)
=
=
0
)
return
0
;
int32_t
res
;
res
=
aComparator
(
aNode
mChildren
[
0
]
nullptr
)
;
if
(
res
<
=
0
)
{
if
(
aItemExists
&
&
res
=
=
0
)
(
*
aItemExists
)
=
true
;
return
0
;
}
res
=
aComparator
(
aNode
mChildren
[
mChildren
.
Count
(
)
-
1
]
nullptr
)
;
if
(
res
>
=
0
)
{
if
(
aItemExists
&
&
res
=
=
0
)
(
*
aItemExists
)
=
true
;
return
mChildren
.
Count
(
)
;
}
uint32_t
beginRange
=
0
;
uint32_t
endRange
=
mChildren
.
Count
(
)
;
while
(
1
)
{
if
(
beginRange
=
=
endRange
)
return
endRange
;
uint32_t
center
=
beginRange
+
(
endRange
-
beginRange
)
/
2
;
int32_t
res
=
aComparator
(
aNode
mChildren
[
center
]
nullptr
)
;
if
(
res
<
=
0
)
{
endRange
=
center
;
if
(
aItemExists
&
&
res
=
=
0
)
(
*
aItemExists
)
=
true
;
}
else
{
beginRange
=
center
+
1
;
}
}
}
bool
nsNavHistoryContainerResultNode
:
:
DoesChildNeedResorting
(
uint32_t
aIndex
SortComparator
aComparator
)
{
NS_ASSERTION
(
aIndex
<
uint32_t
(
mChildren
.
Count
(
)
)
"
Input
index
out
of
range
"
)
;
if
(
mChildren
.
Count
(
)
=
=
1
)
return
false
;
if
(
aIndex
>
0
)
{
if
(
aComparator
(
mChildren
[
aIndex
-
1
]
mChildren
[
aIndex
]
nullptr
)
>
0
)
return
true
;
}
if
(
aIndex
<
uint32_t
(
mChildren
.
Count
(
)
)
-
1
)
{
if
(
aComparator
(
mChildren
[
aIndex
]
mChildren
[
aIndex
+
1
]
nullptr
)
>
0
)
return
true
;
}
return
false
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_StringLess
(
const
nsAString
&
a
const
nsAString
&
b
)
{
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
history
0
)
;
nsICollation
*
collation
=
history
-
>
GetCollation
(
)
;
NS_ENSURE_TRUE
(
collation
0
)
;
int32_t
res
=
0
;
collation
-
>
CompareString
(
nsICollation
:
:
kCollationCaseInSensitive
a
b
&
res
)
;
return
res
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_Bookmark
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
return
a
-
>
mBookmarkIndex
-
b
-
>
mBookmarkIndex
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_TitleLess
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
uint32_t
aType
;
a
-
>
GetType
(
&
aType
)
;
int32_t
value
=
SortComparison_StringLess
(
NS_ConvertUTF8toUTF16
(
a
-
>
mTitle
)
NS_ConvertUTF8toUTF16
(
b
-
>
mTitle
)
)
;
if
(
value
=
=
0
)
{
if
(
a
-
>
IsURI
(
)
)
{
value
=
a
-
>
mURI
.
Compare
(
b
-
>
mURI
.
get
(
)
)
;
}
if
(
value
=
=
0
)
{
value
=
ComparePRTime
(
a
-
>
mTime
b
-
>
mTime
)
;
if
(
value
=
=
0
)
value
=
nsNavHistoryContainerResultNode
:
:
SortComparison_Bookmark
(
a
b
closure
)
;
}
}
return
value
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_TitleGreater
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
return
-
SortComparison_TitleLess
(
a
b
closure
)
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_DateLess
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
int32_t
value
=
ComparePRTime
(
a
-
>
mTime
b
-
>
mTime
)
;
if
(
value
=
=
0
)
{
value
=
SortComparison_StringLess
(
NS_ConvertUTF8toUTF16
(
a
-
>
mTitle
)
NS_ConvertUTF8toUTF16
(
b
-
>
mTitle
)
)
;
if
(
value
=
=
0
)
value
=
nsNavHistoryContainerResultNode
:
:
SortComparison_Bookmark
(
a
b
closure
)
;
}
return
value
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_DateGreater
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
return
-
nsNavHistoryContainerResultNode
:
:
SortComparison_DateLess
(
a
b
closure
)
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_DateAddedLess
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
int32_t
value
=
ComparePRTime
(
a
-
>
mDateAdded
b
-
>
mDateAdded
)
;
if
(
value
=
=
0
)
{
value
=
SortComparison_StringLess
(
NS_ConvertUTF8toUTF16
(
a
-
>
mTitle
)
NS_ConvertUTF8toUTF16
(
b
-
>
mTitle
)
)
;
if
(
value
=
=
0
)
value
=
nsNavHistoryContainerResultNode
:
:
SortComparison_Bookmark
(
a
b
closure
)
;
}
return
value
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_DateAddedGreater
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
return
-
nsNavHistoryContainerResultNode
:
:
SortComparison_DateAddedLess
(
a
b
closure
)
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_LastModifiedLess
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
int32_t
value
=
ComparePRTime
(
a
-
>
mLastModified
b
-
>
mLastModified
)
;
if
(
value
=
=
0
)
{
value
=
SortComparison_StringLess
(
NS_ConvertUTF8toUTF16
(
a
-
>
mTitle
)
NS_ConvertUTF8toUTF16
(
b
-
>
mTitle
)
)
;
if
(
value
=
=
0
)
value
=
nsNavHistoryContainerResultNode
:
:
SortComparison_Bookmark
(
a
b
closure
)
;
}
return
value
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_LastModifiedGreater
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
return
-
nsNavHistoryContainerResultNode
:
:
SortComparison_LastModifiedLess
(
a
b
closure
)
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_URILess
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
int32_t
value
;
if
(
a
-
>
IsURI
(
)
&
&
b
-
>
IsURI
(
)
)
{
value
=
a
-
>
mURI
.
Compare
(
b
-
>
mURI
.
get
(
)
)
;
}
else
if
(
a
-
>
IsContainer
(
)
&
&
!
b
-
>
IsContainer
(
)
)
{
return
-
1
;
}
else
if
(
b
-
>
IsContainer
(
)
&
&
!
a
-
>
IsContainer
(
)
)
{
return
1
;
}
else
{
value
=
SortComparison_StringLess
(
NS_ConvertUTF8toUTF16
(
a
-
>
mTitle
)
NS_ConvertUTF8toUTF16
(
b
-
>
mTitle
)
)
;
}
if
(
value
=
=
0
)
{
value
=
ComparePRTime
(
a
-
>
mTime
b
-
>
mTime
)
;
if
(
value
=
=
0
)
value
=
nsNavHistoryContainerResultNode
:
:
SortComparison_Bookmark
(
a
b
closure
)
;
}
return
value
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_URIGreater
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
return
-
SortComparison_URILess
(
a
b
closure
)
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_VisitCountLess
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
int32_t
value
=
CompareIntegers
(
a
-
>
mAccessCount
b
-
>
mAccessCount
)
;
if
(
value
=
=
0
)
{
value
=
ComparePRTime
(
a
-
>
mTime
b
-
>
mTime
)
;
if
(
value
=
=
0
)
value
=
nsNavHistoryContainerResultNode
:
:
SortComparison_Bookmark
(
a
b
closure
)
;
}
return
value
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_VisitCountGreater
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
return
-
nsNavHistoryContainerResultNode
:
:
SortComparison_VisitCountLess
(
a
b
closure
)
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_TagsLess
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
int32_t
value
=
0
;
nsAutoString
aTags
bTags
;
nsresult
rv
=
a
-
>
GetTags
(
aTags
)
;
NS_ENSURE_SUCCESS
(
rv
0
)
;
rv
=
b
-
>
GetTags
(
bTags
)
;
NS_ENSURE_SUCCESS
(
rv
0
)
;
value
=
SortComparison_StringLess
(
aTags
bTags
)
;
if
(
value
=
=
0
)
value
=
SortComparison_TitleLess
(
a
b
closure
)
;
return
value
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_TagsGreater
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
return
-
SortComparison_TagsLess
(
a
b
closure
)
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_FrecencyLess
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
int32_t
value
=
CompareIntegers
(
a
-
>
mFrecency
b
-
>
mFrecency
)
;
if
(
value
=
=
0
)
{
value
=
ComparePRTime
(
a
-
>
mTime
b
-
>
mTime
)
;
if
(
value
=
=
0
)
{
value
=
nsNavHistoryContainerResultNode
:
:
SortComparison_Bookmark
(
a
b
closure
)
;
}
}
return
value
;
}
int32_t
nsNavHistoryContainerResultNode
:
:
SortComparison_FrecencyGreater
(
nsNavHistoryResultNode
*
a
nsNavHistoryResultNode
*
b
void
*
closure
)
{
return
-
nsNavHistoryContainerResultNode
:
:
SortComparison_FrecencyLess
(
a
b
closure
)
;
}
nsNavHistoryResultNode
*
nsNavHistoryContainerResultNode
:
:
FindChildURI
(
const
nsACString
&
aSpec
uint32_t
*
aNodeIndex
)
{
for
(
int32_t
i
=
0
;
i
<
mChildren
.
Count
(
)
;
+
+
i
)
{
if
(
mChildren
[
i
]
-
>
IsURI
(
)
)
{
if
(
aSpec
.
Equals
(
mChildren
[
i
]
-
>
mURI
)
)
{
*
aNodeIndex
=
i
;
return
mChildren
[
i
]
;
}
}
}
return
nullptr
;
}
nsNavHistoryResultNode
*
nsNavHistoryContainerResultNode
:
:
FindChildByGuid
(
const
nsACString
&
guid
int32_t
*
nodeIndex
)
{
*
nodeIndex
=
-
1
;
for
(
int32_t
i
=
0
;
i
<
mChildren
.
Count
(
)
;
+
+
i
)
{
if
(
mChildren
[
i
]
-
>
mBookmarkGuid
=
=
guid
|
|
mChildren
[
i
]
-
>
mPageGuid
=
=
guid
|
|
(
mChildren
[
i
]
-
>
IsFolder
(
)
&
&
mChildren
[
i
]
-
>
GetAsFolder
(
)
-
>
mTargetFolderGuid
=
=
guid
)
)
{
*
nodeIndex
=
i
;
return
mChildren
[
i
]
;
}
}
return
nullptr
;
}
nsresult
nsNavHistoryContainerResultNode
:
:
InsertChildAt
(
nsNavHistoryResultNode
*
aNode
int32_t
aIndex
)
{
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NS_ENSURE_STATE
(
result
)
;
SetAsParentOfNode
(
aNode
)
;
if
(
!
mChildren
.
InsertObjectAt
(
aNode
aIndex
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
uint32_t
oldAccessCount
=
mAccessCount
;
PRTime
oldTime
=
mTime
;
mAccessCount
+
=
aNode
-
>
mAccessCount
;
if
(
mTime
<
aNode
-
>
mTime
)
mTime
=
aNode
-
>
mTime
;
if
(
!
mParent
|
|
mParent
-
>
AreChildrenVisible
(
)
)
{
NOTIFY_RESULT_OBSERVERS
(
result
NodeHistoryDetailsChanged
(
TO_ICONTAINER
(
this
)
oldTime
oldAccessCount
)
)
;
}
nsresult
rv
=
ReverseUpdateStats
(
aNode
-
>
mAccessCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
AreChildrenVisible
(
)
)
NOTIFY_RESULT_OBSERVERS
(
result
NodeInserted
(
this
aNode
aIndex
)
)
;
return
NS_OK
;
}
nsresult
nsNavHistoryContainerResultNode
:
:
InsertSortedChild
(
nsNavHistoryResultNode
*
aNode
bool
aIgnoreDuplicates
)
{
if
(
mChildren
.
Count
(
)
=
=
0
)
return
InsertChildAt
(
aNode
0
)
;
SortComparator
comparator
=
GetSortingComparator
(
GetSortType
(
)
)
;
if
(
comparator
)
{
if
(
aNode
-
>
IsContainer
(
)
)
{
nsNavHistoryContainerResultNode
*
container
=
aNode
-
>
GetAsContainer
(
)
;
container
-
>
mResult
=
mResult
;
container
-
>
FillStats
(
)
;
}
bool
itemExists
;
uint32_t
position
=
FindInsertionPoint
(
aNode
comparator
&
itemExists
)
;
if
(
aIgnoreDuplicates
&
&
itemExists
)
return
NS_OK
;
return
InsertChildAt
(
aNode
position
)
;
}
return
InsertChildAt
(
aNode
mChildren
.
Count
(
)
)
;
}
bool
nsNavHistoryContainerResultNode
:
:
EnsureItemPosition
(
uint32_t
aIndex
)
{
NS_ASSERTION
(
aIndex
<
(
uint32_t
)
mChildren
.
Count
(
)
"
Invalid
index
"
)
;
if
(
aIndex
>
=
(
uint32_t
)
mChildren
.
Count
(
)
)
return
false
;
SortComparator
comparator
=
GetSortingComparator
(
GetSortType
(
)
)
;
if
(
!
comparator
)
return
false
;
if
(
!
DoesChildNeedResorting
(
aIndex
comparator
)
)
return
false
;
RefPtr
<
nsNavHistoryResultNode
>
node
(
mChildren
[
aIndex
]
)
;
mChildren
.
RemoveObjectAt
(
aIndex
)
;
uint32_t
newIndex
=
FindInsertionPoint
(
node
comparator
nullptr
)
;
mChildren
.
InsertObjectAt
(
node
.
get
(
)
newIndex
)
;
if
(
AreChildrenVisible
(
)
)
{
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NOTIFY_RESULT_OBSERVERS_RET
(
result
NodeMoved
(
node
this
aIndex
this
newIndex
)
false
)
;
}
return
true
;
}
nsresult
nsNavHistoryContainerResultNode
:
:
RemoveChildAt
(
int32_t
aIndex
)
{
NS_ASSERTION
(
aIndex
>
=
0
&
&
aIndex
<
mChildren
.
Count
(
)
"
Invalid
index
"
)
;
RefPtr
<
nsNavHistoryResultNode
>
oldNode
=
mChildren
[
aIndex
]
;
uint32_t
oldAccessCount
=
mAccessCount
;
mAccessCount
-
=
mChildren
[
aIndex
]
-
>
mAccessCount
;
mChildren
.
RemoveObjectAt
(
aIndex
)
;
if
(
AreChildrenVisible
(
)
)
{
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NOTIFY_RESULT_OBSERVERS
(
result
NodeRemoved
(
this
oldNode
aIndex
)
)
;
}
nsresult
rv
=
ReverseUpdateStats
(
mAccessCount
-
oldAccessCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
oldNode
-
>
OnRemoving
(
)
;
return
NS_OK
;
}
void
nsNavHistoryContainerResultNode
:
:
RecursiveFindURIs
(
bool
aOnlyOne
nsNavHistoryContainerResultNode
*
aContainer
const
nsCString
&
aSpec
nsCOMArray
<
nsNavHistoryResultNode
>
*
aMatches
)
{
for
(
int32_t
child
=
0
;
child
<
aContainer
-
>
mChildren
.
Count
(
)
;
+
+
child
)
{
uint32_t
type
;
aContainer
-
>
mChildren
[
child
]
-
>
GetType
(
&
type
)
;
if
(
nsNavHistoryResultNode
:
:
IsTypeURI
(
type
)
)
{
nsNavHistoryResultNode
*
uriNode
=
aContainer
-
>
mChildren
[
child
]
;
if
(
uriNode
-
>
mURI
.
Equals
(
aSpec
)
)
{
aMatches
-
>
AppendObject
(
uriNode
)
;
if
(
aOnlyOne
)
return
;
}
}
}
}
bool
nsNavHistoryContainerResultNode
:
:
UpdateURIs
(
bool
aRecursive
bool
aOnlyOne
bool
aUpdateSort
const
nsCString
&
aSpec
nsresult
(
*
aCallback
)
(
nsNavHistoryResultNode
*
const
void
*
const
nsNavHistoryResult
*
)
const
void
*
aClosure
)
{
const
nsNavHistoryResult
*
result
=
GetResult
(
)
;
if
(
!
result
)
{
MOZ_ASSERT
(
false
"
Should
have
a
result
"
)
;
return
false
;
}
nsCOMArray
<
nsNavHistoryResultNode
>
matches
;
if
(
aRecursive
)
{
RecursiveFindURIs
(
aOnlyOne
this
aSpec
&
matches
)
;
}
else
if
(
aOnlyOne
)
{
uint32_t
nodeIndex
;
nsNavHistoryResultNode
*
node
=
FindChildURI
(
aSpec
&
nodeIndex
)
;
if
(
node
)
matches
.
AppendObject
(
node
)
;
}
else
{
MOZ_ASSERT
(
false
"
UpdateURIs
does
not
handle
nonrecursive
updates
of
multiple
items
.
"
)
;
return
false
;
}
if
(
matches
.
Count
(
)
=
=
0
)
return
false
;
for
(
int32_t
i
=
0
;
i
<
matches
.
Count
(
)
;
+
+
i
)
{
nsNavHistoryResultNode
*
node
=
matches
[
i
]
;
nsNavHistoryContainerResultNode
*
parent
=
node
-
>
mParent
;
if
(
!
parent
)
{
MOZ_ASSERT
(
false
"
All
URI
nodes
being
updated
must
have
parents
"
)
;
continue
;
}
uint32_t
oldAccessCount
=
node
-
>
mAccessCount
;
PRTime
oldTime
=
node
-
>
mTime
;
uint32_t
parentOldAccessCount
=
parent
-
>
mAccessCount
;
PRTime
parentOldTime
=
parent
-
>
mTime
;
aCallback
(
node
aClosure
result
)
;
if
(
oldAccessCount
!
=
node
-
>
mAccessCount
|
|
oldTime
!
=
node
-
>
mTime
)
{
parent
-
>
mAccessCount
+
=
node
-
>
mAccessCount
-
oldAccessCount
;
if
(
node
-
>
mTime
>
parent
-
>
mTime
)
parent
-
>
mTime
=
node
-
>
mTime
;
if
(
parent
-
>
AreChildrenVisible
(
)
)
{
NOTIFY_RESULT_OBSERVERS_RET
(
result
NodeHistoryDetailsChanged
(
TO_ICONTAINER
(
parent
)
parentOldTime
parentOldAccessCount
)
true
)
;
}
DebugOnly
<
nsresult
>
rv
=
parent
-
>
ReverseUpdateStats
(
node
-
>
mAccessCount
-
oldAccessCount
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
should
be
able
to
ReverseUpdateStats
"
)
;
}
if
(
aUpdateSort
)
{
int32_t
childIndex
=
parent
-
>
FindChild
(
node
)
;
MOZ_ASSERT
(
childIndex
>
=
0
"
Could
not
find
child
we
just
got
a
reference
to
"
)
;
if
(
childIndex
>
=
0
)
parent
-
>
EnsureItemPosition
(
childIndex
)
;
}
}
return
true
;
}
static
nsresult
setTitleCallback
(
nsNavHistoryResultNode
*
aNode
const
void
*
aClosure
const
nsNavHistoryResult
*
aResult
)
{
const
nsACString
*
newTitle
=
static_cast
<
const
nsACString
*
>
(
aClosure
)
;
aNode
-
>
mTitle
=
*
newTitle
;
if
(
aResult
&
&
(
!
aNode
-
>
mParent
|
|
aNode
-
>
mParent
-
>
AreChildrenVisible
(
)
)
)
NOTIFY_RESULT_OBSERVERS
(
aResult
NodeTitleChanged
(
aNode
*
newTitle
)
)
;
return
NS_OK
;
}
nsresult
nsNavHistoryContainerResultNode
:
:
ChangeTitles
(
nsIURI
*
aURI
const
nsACString
&
aNewTitle
bool
aRecursive
bool
aOnlyOne
)
{
nsAutoCString
uriString
;
nsresult
rv
=
aURI
-
>
GetSpec
(
uriString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NS_ENSURE_STATE
(
result
)
;
uint16_t
sortType
=
GetSortType
(
)
;
bool
updateSorting
=
(
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_TITLE_ASCENDING
|
|
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_TITLE_DESCENDING
)
;
UpdateURIs
(
aRecursive
aOnlyOne
updateSorting
uriString
setTitleCallback
static_cast
<
const
void
*
>
(
&
aNewTitle
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryContainerResultNode
:
:
GetHasChildren
(
bool
*
aHasChildren
)
{
*
aHasChildren
=
(
mChildren
.
Count
(
)
>
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryContainerResultNode
:
:
GetChildCount
(
uint32_t
*
aChildCount
)
{
if
(
!
mExpanded
)
return
NS_ERROR_NOT_AVAILABLE
;
*
aChildCount
=
mChildren
.
Count
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryContainerResultNode
:
:
GetChild
(
uint32_t
aIndex
nsINavHistoryResultNode
*
*
_child
)
{
if
(
!
mExpanded
)
return
NS_ERROR_NOT_AVAILABLE
;
if
(
aIndex
>
=
uint32_t
(
mChildren
.
Count
(
)
)
)
return
NS_ERROR_INVALID_ARG
;
nsCOMPtr
<
nsINavHistoryResultNode
>
child
=
mChildren
[
aIndex
]
;
child
.
forget
(
_child
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryContainerResultNode
:
:
GetChildIndex
(
nsINavHistoryResultNode
*
aNode
uint32_t
*
_retval
)
{
if
(
!
mExpanded
)
return
NS_ERROR_NOT_AVAILABLE
;
int32_t
nodeIndex
=
FindChild
(
static_cast
<
nsNavHistoryResultNode
*
>
(
aNode
)
)
;
if
(
nodeIndex
=
=
-
1
)
return
NS_ERROR_INVALID_ARG
;
*
_retval
=
nodeIndex
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsNavHistoryQueryResultNode
nsNavHistoryContainerResultNode
nsINavHistoryQueryResultNode
)
nsNavHistoryQueryResultNode
:
:
nsNavHistoryQueryResultNode
(
const
nsACString
&
aTitle
PRTime
aTime
const
nsACString
&
aQueryURI
const
RefPtr
<
nsNavHistoryQuery
>
&
aQuery
const
RefPtr
<
nsNavHistoryQueryOptions
>
&
aOptions
)
:
nsNavHistoryContainerResultNode
(
aQueryURI
aTitle
aTime
nsNavHistoryResultNode
:
:
RESULT_TYPE_QUERY
aOptions
)
mQuery
(
aQuery
)
mLiveUpdate
(
getUpdateRequirements
(
aQuery
aOptions
&
mHasSearchTerms
)
)
mContentsValid
(
false
)
mBatchChanges
(
0
)
mTransitions
(
aQuery
-
>
Transitions
(
)
.
Clone
(
)
)
{
}
nsNavHistoryQueryResultNode
:
:
~
nsNavHistoryQueryResultNode
(
)
{
if
(
mResult
&
&
mResult
-
>
mAllBookmarksObservers
.
Contains
(
this
)
)
mResult
-
>
RemoveAllBookmarksObserver
(
this
)
;
if
(
mResult
&
&
mResult
-
>
mHistoryObservers
.
Contains
(
this
)
)
mResult
-
>
RemoveHistoryObserver
(
this
)
;
if
(
mResult
&
&
mResult
-
>
mMobilePrefObservers
.
Contains
(
this
)
)
mResult
-
>
RemoveMobilePrefsObserver
(
this
)
;
}
bool
nsNavHistoryQueryResultNode
:
:
CanExpand
(
)
{
if
(
(
mResult
&
&
mResult
-
>
mRootNode
=
=
this
)
|
|
IsContainersQuery
(
)
)
{
return
true
;
}
if
(
mOptions
-
>
ExcludeItems
(
)
)
{
return
false
;
}
if
(
mOptions
-
>
ExpandQueries
(
)
)
{
return
true
;
}
return
false
;
}
bool
nsNavHistoryQueryResultNode
:
:
IsContainersQuery
(
)
{
uint16_t
resultType
=
Options
(
)
-
>
ResultType
(
)
;
return
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_DATE_QUERY
|
|
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_DATE_SITE_QUERY
|
|
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_TAGS_ROOT
|
|
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_SITE_QUERY
|
|
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_ROOTS_QUERY
|
|
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_LEFT_PANE_QUERY
;
}
void
nsNavHistoryQueryResultNode
:
:
OnRemoving
(
)
{
nsNavHistoryResultNode
:
:
OnRemoving
(
)
;
ClearChildren
(
true
)
;
mResult
=
nullptr
;
}
nsresult
nsNavHistoryQueryResultNode
:
:
OpenContainer
(
)
{
NS_ASSERTION
(
!
mExpanded
"
Container
must
be
closed
to
open
it
"
)
;
mExpanded
=
true
;
nsresult
rv
;
if
(
!
CanExpand
(
)
)
return
NS_OK
;
if
(
!
mContentsValid
)
{
rv
=
FillChildren
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
NotifyOnStateChange
(
STATE_CLOSED
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
GetHasChildren
(
bool
*
aHasChildren
)
{
*
aHasChildren
=
false
;
if
(
!
CanExpand
(
)
)
{
return
NS_OK
;
}
uint16_t
resultType
=
mOptions
-
>
ResultType
(
)
;
if
(
mQuery
-
>
Tags
(
)
.
Length
(
)
=
=
1
&
&
mParent
&
&
mParent
-
>
mOptions
-
>
ResultType
(
)
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_TAGS_ROOT
)
{
*
aHasChildren
=
true
;
return
NS_OK
;
}
if
(
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_ROOTS_QUERY
|
|
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_LEFT_PANE_QUERY
)
{
*
aHasChildren
=
true
;
return
NS_OK
;
}
if
(
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_DATE_QUERY
|
|
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_DATE_SITE_QUERY
|
|
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_SITE_QUERY
)
{
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
history
NS_ERROR_OUT_OF_MEMORY
)
;
*
aHasChildren
=
history
-
>
hasHistoryEntries
(
)
;
return
NS_OK
;
}
if
(
mContentsValid
)
{
*
aHasChildren
=
(
mChildren
.
Count
(
)
>
0
)
;
return
NS_OK
;
}
*
aHasChildren
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
GetUri
(
nsACString
&
aURI
)
{
aURI
=
mURI
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
GetFolderItemId
(
int64_t
*
aItemId
)
{
*
aItemId
=
-
1
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
GetTargetFolderGuid
(
nsACString
&
aGuid
)
{
aGuid
.
Truncate
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
GetQuery
(
nsINavHistoryQuery
*
*
_query
)
{
RefPtr
<
nsNavHistoryQuery
>
query
=
mQuery
;
query
.
forget
(
_query
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
GetQueryOptions
(
nsINavHistoryQueryOptions
*
*
_options
)
{
MOZ_ASSERT
(
mOptions
"
Options
should
be
valid
"
)
;
RefPtr
<
nsNavHistoryQueryOptions
>
options
=
mOptions
;
options
.
forget
(
_options
)
;
return
NS_OK
;
}
nsNavHistoryQueryOptions
*
nsNavHistoryQueryResultNode
:
:
Options
(
)
{
MOZ_ASSERT
(
mOptions
"
Options
invalid
cannot
generate
from
URI
"
)
;
return
mOptions
;
}
nsresult
nsNavHistoryQueryResultNode
:
:
FillChildren
(
)
{
MOZ_ASSERT
(
!
mContentsValid
"
Don
'
t
call
FillChildren
when
contents
are
valid
"
)
;
MOZ_ASSERT
(
mChildren
.
Count
(
)
=
=
0
"
We
are
trying
to
fill
children
when
there
already
are
some
"
)
;
NS_ENSURE_STATE
(
mQuery
&
&
mOptions
)
;
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
history
NS_ERROR_OUT_OF_MEMORY
)
;
nsresult
rv
=
history
-
>
GetQueryResults
(
this
mQuery
mOptions
&
mChildren
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
FillStats
(
)
;
uint16_t
sortType
=
GetSortType
(
)
;
if
(
mResult
&
&
mResult
-
>
mNeedsToApplySortingMode
)
{
mResult
-
>
SetSortingMode
(
mResult
-
>
mSortingMode
)
;
}
else
if
(
mOptions
-
>
QueryType
(
)
!
=
nsINavHistoryQueryOptions
:
:
QUERY_TYPE_HISTORY
|
|
sortType
!
=
nsINavHistoryQueryOptions
:
:
SORT_BY_NONE
)
{
SortComparator
comparator
=
GetSortingComparator
(
GetSortType
(
)
)
;
if
(
comparator
)
{
if
(
IsContainersQuery
(
)
&
&
sortType
=
=
mOptions
-
>
SortingMode
(
)
&
&
(
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_TITLE_ASCENDING
|
|
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_TITLE_DESCENDING
)
)
{
nsNavHistoryContainerResultNode
:
:
RecursiveSort
(
comparator
)
;
}
else
{
RecursiveSort
(
comparator
)
;
}
}
}
if
(
!
mParent
&
&
mOptions
-
>
MaxResults
(
)
)
{
while
(
(
uint32_t
)
mChildren
.
Count
(
)
>
mOptions
-
>
MaxResults
(
)
)
mChildren
.
RemoveObjectAt
(
mChildren
.
Count
(
)
-
1
)
;
}
if
(
mLiveUpdate
=
=
QUERYUPDATE_NONE
)
{
mContentsValid
=
true
;
return
NS_OK
;
}
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NS_ENSURE_STATE
(
result
)
;
if
(
mOptions
-
>
QueryType
(
)
=
=
nsINavHistoryQueryOptions
:
:
QUERY_TYPE_HISTORY
|
|
mOptions
-
>
QueryType
(
)
=
=
nsINavHistoryQueryOptions
:
:
QUERY_TYPE_UNIFIED
)
{
if
(
!
mParent
|
|
mParent
-
>
mOptions
-
>
ResultType
(
)
!
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_DATE_SITE_QUERY
)
{
result
-
>
AddHistoryObserver
(
this
)
;
}
}
if
(
mOptions
-
>
QueryType
(
)
=
=
nsINavHistoryQueryOptions
:
:
QUERY_TYPE_BOOKMARKS
|
|
mOptions
-
>
QueryType
(
)
=
=
nsINavHistoryQueryOptions
:
:
QUERY_TYPE_UNIFIED
|
|
mLiveUpdate
=
=
QUERYUPDATE_COMPLEX_WITH_BOOKMARKS
|
|
mHasSearchTerms
)
{
result
-
>
AddAllBookmarksObserver
(
this
)
;
}
if
(
mLiveUpdate
=
=
QUERYUPDATE_MOBILEPREF
)
{
result
-
>
AddMobilePrefsObserver
(
this
)
;
}
mContentsValid
=
true
;
return
NS_OK
;
}
void
nsNavHistoryQueryResultNode
:
:
ClearChildren
(
bool
aUnregister
)
{
for
(
int32_t
i
=
0
;
i
<
mChildren
.
Count
(
)
;
+
+
i
)
mChildren
[
i
]
-
>
OnRemoving
(
)
;
mChildren
.
Clear
(
)
;
if
(
aUnregister
&
&
mContentsValid
)
{
nsNavHistoryResult
*
result
=
GetResult
(
)
;
if
(
result
)
{
result
-
>
RemoveHistoryObserver
(
this
)
;
result
-
>
RemoveAllBookmarksObserver
(
this
)
;
result
-
>
RemoveMobilePrefsObserver
(
this
)
;
}
}
mContentsValid
=
false
;
}
nsresult
nsNavHistoryQueryResultNode
:
:
Refresh
(
)
{
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NS_ENSURE_STATE
(
result
)
;
if
(
result
-
>
mBatchInProgress
)
{
result
-
>
requestRefresh
(
this
)
;
return
NS_OK
;
}
if
(
mIndentLevel
>
-
1
&
&
!
mParent
)
return
NS_OK
;
if
(
!
mExpanded
)
{
ClearChildren
(
true
)
;
return
NS_OK
;
}
if
(
mParent
&
&
mParent
-
>
IsQuery
(
)
)
{
nsNavHistoryQueryResultNode
*
parent
=
mParent
-
>
GetAsQuery
(
)
;
if
(
parent
-
>
IsContainersQuery
(
)
&
&
parent
-
>
mLiveUpdate
!
=
QUERYUPDATE_NONE
)
{
ClearChildren
(
true
)
;
return
NS_OK
;
}
}
if
(
mLiveUpdate
=
=
QUERYUPDATE_COMPLEX_WITH_BOOKMARKS
)
ClearChildren
(
true
)
;
else
ClearChildren
(
false
)
;
(
void
)
FillChildren
(
)
;
NOTIFY_RESULT_OBSERVERS
(
result
InvalidateContainer
(
TO_CONTAINER
(
this
)
)
)
;
return
NS_OK
;
}
uint16_t
nsNavHistoryQueryResultNode
:
:
GetSortType
(
)
{
if
(
mParent
)
return
mOptions
-
>
SortingMode
(
)
;
if
(
mResult
)
return
mResult
-
>
mSortingMode
;
return
nsINavHistoryQueryOptions
:
:
SORT_BY_NONE
;
}
void
nsNavHistoryQueryResultNode
:
:
RecursiveSort
(
SortComparator
aComparator
)
{
if
(
!
IsContainersQuery
(
)
)
mChildren
.
Sort
(
aComparator
nullptr
)
;
for
(
int32_t
i
=
0
;
i
<
mChildren
.
Count
(
)
;
+
+
i
)
{
if
(
mChildren
[
i
]
-
>
IsContainer
(
)
)
mChildren
[
i
]
-
>
GetAsContainer
(
)
-
>
RecursiveSort
(
aComparator
)
;
}
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
GetSkipTags
(
bool
*
aSkipTags
)
{
*
aSkipTags
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
OnBeginUpdateBatch
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
OnEndUpdateBatch
(
)
{
if
(
mChildren
.
Count
(
)
=
=
0
)
{
nsresult
rv
=
Refresh
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mBatchChanges
=
0
;
return
NS_OK
;
}
static
nsresult
setHistoryDetailsCallback
(
nsNavHistoryResultNode
*
aNode
const
void
*
aClosure
const
nsNavHistoryResult
*
aResult
)
{
const
nsNavHistoryResultNode
*
updatedNode
=
static_cast
<
const
nsNavHistoryResultNode
*
>
(
aClosure
)
;
aNode
-
>
mAccessCount
=
updatedNode
-
>
mAccessCount
;
aNode
-
>
mTime
=
updatedNode
-
>
mTime
;
aNode
-
>
mFrecency
=
updatedNode
-
>
mFrecency
;
aNode
-
>
mHidden
=
updatedNode
-
>
mHidden
;
return
NS_OK
;
}
nsresult
nsNavHistoryQueryResultNode
:
:
OnVisit
(
nsIURI
*
aURI
int64_t
aVisitId
PRTime
aTime
uint32_t
aTransitionType
bool
aHidden
uint32_t
*
aAdded
)
{
if
(
aHidden
&
&
!
mOptions
-
>
IncludeHidden
(
)
)
return
NS_OK
;
if
(
mTransitions
.
Length
(
)
>
0
&
&
!
mTransitions
.
Contains
(
aTransitionType
)
)
return
NS_OK
;
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NS_ENSURE_STATE
(
result
)
;
if
(
result
-
>
mBatchInProgress
&
&
+
+
mBatchChanges
>
MAX_BATCH_CHANGES_BEFORE_REFRESH
)
{
nsresult
rv
=
Refresh
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
history
NS_ERROR_OUT_OF_MEMORY
)
;
switch
(
mLiveUpdate
)
{
case
QUERYUPDATE_MOBILEPREF
:
{
return
NS_OK
;
}
case
QUERYUPDATE_HOST
:
{
if
(
mQuery
-
>
Domain
(
)
.
IsVoid
(
)
)
return
NS_OK
;
nsAutoCString
host
;
if
(
NS_FAILED
(
aURI
-
>
GetAsciiHost
(
host
)
)
)
return
NS_OK
;
if
(
!
mQuery
-
>
Domain
(
)
.
Equals
(
host
)
)
return
NS_OK
;
[
[
fallthrough
]
]
;
}
case
QUERYUPDATE_TIME
:
{
bool
hasIt
;
mQuery
-
>
GetHasBeginTime
(
&
hasIt
)
;
if
(
hasIt
)
{
PRTime
beginTime
=
history
-
>
NormalizeTime
(
mQuery
-
>
BeginTimeReference
(
)
mQuery
-
>
BeginTime
(
)
)
;
if
(
aTime
<
beginTime
)
return
NS_OK
;
}
mQuery
-
>
GetHasEndTime
(
&
hasIt
)
;
if
(
hasIt
)
{
PRTime
endTime
=
history
-
>
NormalizeTime
(
mQuery
-
>
EndTimeReference
(
)
mQuery
-
>
EndTime
(
)
)
;
if
(
aTime
>
endTime
)
return
NS_OK
;
}
[
[
fallthrough
]
]
;
}
case
QUERYUPDATE_SIMPLE
:
{
RefPtr
<
nsNavHistoryResultNode
>
addition
;
nsresult
rv
=
history
-
>
VisitIdToResultNode
(
aVisitId
mOptions
getter_AddRefs
(
addition
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
addition
)
{
return
NS_OK
;
}
addition
-
>
mTransitionType
=
aTransitionType
;
if
(
!
evaluateQueryForNode
(
mQuery
mOptions
addition
)
)
return
NS_OK
;
if
(
mOptions
-
>
MaxResults
(
)
&
&
static_cast
<
uint32_t
>
(
mChildren
.
Count
(
)
)
>
=
mOptions
-
>
MaxResults
(
)
)
{
uint16_t
sortType
=
GetSortType
(
)
;
if
(
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_DATE_ASCENDING
&
&
aTime
>
std
:
:
max
(
mChildren
[
0
]
-
>
mTime
mChildren
[
mChildren
.
Count
(
)
-
1
]
-
>
mTime
)
)
{
return
NS_OK
;
}
if
(
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_DATE_DESCENDING
&
&
aTime
<
std
:
:
min
(
mChildren
[
0
]
-
>
mTime
mChildren
[
mChildren
.
Count
(
)
-
1
]
-
>
mTime
)
)
{
return
NS_OK
;
}
}
if
(
mOptions
-
>
ResultType
(
)
=
=
nsNavHistoryQueryOptions
:
:
RESULTS_AS_VISIT
)
{
rv
=
InsertSortedChild
(
addition
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
uint16_t
sortType
=
GetSortType
(
)
;
bool
updateSorting
=
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_VISITCOUNT_ASCENDING
|
|
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_VISITCOUNT_DESCENDING
|
|
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_DATE_ASCENDING
|
|
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_DATE_DESCENDING
|
|
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_FRECENCY_ASCENDING
|
|
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_FRECENCY_DESCENDING
;
if
(
!
UpdateURIs
(
false
true
updateSorting
addition
-
>
mURI
setHistoryDetailsCallback
const_cast
<
void
*
>
(
static_cast
<
void
*
>
(
addition
.
get
(
)
)
)
)
)
{
rv
=
InsertSortedChild
(
addition
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
mOptions
-
>
MaxResults
(
)
&
&
static_cast
<
uint32_t
>
(
mChildren
.
Count
(
)
)
>
mOptions
-
>
MaxResults
(
)
)
{
mChildren
.
RemoveObjectAt
(
mChildren
.
Count
(
)
-
1
)
;
}
if
(
aAdded
)
+
+
(
*
aAdded
)
;
break
;
}
case
QUERYUPDATE_COMPLEX
:
case
QUERYUPDATE_COMPLEX_WITH_BOOKMARKS
:
return
Refresh
(
)
;
default
:
MOZ_ASSERT
(
false
"
Invalid
value
for
mLiveUpdate
"
)
;
return
Refresh
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
OnTitleChanged
(
nsIURI
*
aURI
const
nsAString
&
aPageTitle
const
nsACString
&
aGUID
)
{
if
(
!
mExpanded
)
{
ClearChildren
(
true
)
;
return
NS_OK
;
}
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NS_ENSURE_STATE
(
result
)
;
if
(
result
-
>
mBatchInProgress
&
&
+
+
mBatchChanges
>
MAX_BATCH_CHANGES_BEFORE_REFRESH
)
{
nsresult
rv
=
Refresh
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_ConvertUTF16toUTF8
newTitle
(
aPageTitle
)
;
bool
onlyOneEntry
=
mOptions
-
>
ResultType
(
)
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_URI
;
if
(
mHasSearchTerms
)
{
nsCOMArray
<
nsNavHistoryResultNode
>
matches
;
nsAutoCString
spec
;
nsresult
rv
=
aURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RecursiveFindURIs
(
onlyOneEntry
this
spec
&
matches
)
;
if
(
matches
.
Count
(
)
=
=
0
)
{
RefPtr
<
nsNavHistoryResultNode
>
node
;
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
history
NS_ERROR_OUT_OF_MEMORY
)
;
rv
=
history
-
>
URIToResultNode
(
aURI
mOptions
getter_AddRefs
(
node
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
evaluateQueryForNode
(
mQuery
mOptions
node
)
)
{
rv
=
InsertSortedChild
(
node
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
for
(
int32_t
i
=
0
;
i
<
matches
.
Count
(
)
;
+
+
i
)
{
nsNavHistoryResultNode
*
node
=
matches
[
i
]
;
node
-
>
mTitle
=
newTitle
;
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
history
NS_ERROR_OUT_OF_MEMORY
)
;
if
(
!
evaluateQueryForNode
(
mQuery
mOptions
node
)
)
{
nsNavHistoryContainerResultNode
*
parent
=
node
-
>
mParent
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_UNEXPECTED
)
;
int32_t
childIndex
=
parent
-
>
FindChild
(
node
)
;
NS_ASSERTION
(
childIndex
>
=
0
"
Child
not
found
in
parent
"
)
;
parent
-
>
RemoveChildAt
(
childIndex
)
;
}
}
}
return
ChangeTitles
(
aURI
newTitle
true
onlyOneEntry
)
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
OnFrecencyChanged
(
nsIURI
*
aURI
int32_t
aNewFrecency
const
nsACString
&
aGUID
bool
aHidden
PRTime
aLastVisitDate
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
OnManyFrecenciesChanged
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
OnDeleteURI
(
nsIURI
*
aURI
const
nsACString
&
aGUID
uint16_t
aReason
)
{
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NS_ENSURE_STATE
(
result
)
;
if
(
result
-
>
mBatchInProgress
&
&
+
+
mBatchChanges
>
MAX_BATCH_CHANGES_BEFORE_REFRESH
)
{
nsresult
rv
=
Refresh
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
if
(
IsContainersQuery
(
)
)
{
nsresult
rv
=
Refresh
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
bool
onlyOneEntry
=
mOptions
-
>
ResultType
(
)
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_URI
;
nsAutoCString
spec
;
nsresult
rv
=
aURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMArray
<
nsNavHistoryResultNode
>
matches
;
RecursiveFindURIs
(
onlyOneEntry
this
spec
&
matches
)
;
for
(
int32_t
i
=
0
;
i
<
matches
.
Count
(
)
;
+
+
i
)
{
nsNavHistoryResultNode
*
node
=
matches
[
i
]
;
nsNavHistoryContainerResultNode
*
parent
=
node
-
>
mParent
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_UNEXPECTED
)
;
int32_t
childIndex
=
parent
-
>
FindChild
(
node
)
;
NS_ASSERTION
(
childIndex
>
=
0
"
Child
not
found
in
parent
"
)
;
parent
-
>
RemoveChildAt
(
childIndex
)
;
if
(
parent
-
>
mChildren
.
Count
(
)
=
=
0
&
&
parent
-
>
IsQuery
(
)
&
&
parent
-
>
mIndentLevel
>
-
1
)
{
matches
.
AppendObject
(
parent
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
OnClearHistory
(
)
{
nsresult
rv
=
Refresh
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
static
nsresult
setFaviconCallback
(
nsNavHistoryResultNode
*
aNode
const
void
*
aClosure
const
nsNavHistoryResult
*
aResult
)
{
if
(
aResult
&
&
(
!
aNode
-
>
mParent
|
|
aNode
-
>
mParent
-
>
AreChildrenVisible
(
)
)
)
NOTIFY_RESULT_OBSERVERS
(
aResult
NodeIconChanged
(
aNode
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
OnPageChanged
(
nsIURI
*
aURI
uint32_t
aChangedAttribute
const
nsAString
&
aNewValue
const
nsACString
&
aGUID
)
{
nsAutoCString
spec
;
nsresult
rv
=
aURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
switch
(
aChangedAttribute
)
{
case
nsINavHistoryObserver
:
:
ATTRIBUTE_FAVICON
:
{
bool
onlyOneEntry
=
mOptions
-
>
ResultType
(
)
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_URI
;
UpdateURIs
(
true
onlyOneEntry
false
spec
setFaviconCallback
nullptr
)
;
break
;
}
default
:
NS_WARNING
(
"
Unknown
page
changed
notification
"
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
OnDeleteVisits
(
nsIURI
*
aURI
bool
aPartialRemoval
const
nsACString
&
aGUID
uint16_t
aReason
uint32_t
aTransitionType
)
{
MOZ_ASSERT
(
mOptions
-
>
QueryType
(
)
=
=
nsINavHistoryQueryOptions
:
:
QUERY_TYPE_HISTORY
"
Bookmarks
queries
should
not
get
a
OnDeleteVisits
notification
"
)
;
if
(
!
aPartialRemoval
)
{
nsresult
rv
=
OnDeleteURI
(
aURI
aGUID
aReason
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
aTransitionType
>
0
)
{
if
(
mTransitions
.
Length
(
)
>
0
&
&
mTransitions
.
Contains
(
aTransitionType
)
)
{
nsresult
rv
=
OnDeleteURI
(
aURI
aGUID
aReason
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
nsresult
nsNavHistoryQueryResultNode
:
:
NotifyIfTagsChanged
(
nsIURI
*
aURI
)
{
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NS_ENSURE_STATE
(
result
)
;
nsAutoCString
spec
;
nsresult
rv
=
aURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
onlyOneEntry
=
mOptions
-
>
ResultType
(
)
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_URI
;
RefPtr
<
nsNavHistoryResultNode
>
node
;
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
nsCOMArray
<
nsNavHistoryResultNode
>
matches
;
RecursiveFindURIs
(
onlyOneEntry
this
spec
&
matches
)
;
if
(
matches
.
Count
(
)
=
=
0
&
&
mHasSearchTerms
)
{
NS_ENSURE_TRUE
(
history
NS_ERROR_OUT_OF_MEMORY
)
;
rv
=
history
-
>
URIToResultNode
(
aURI
mOptions
getter_AddRefs
(
node
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
evaluateQueryForNode
(
mQuery
mOptions
node
)
)
{
rv
=
InsertSortedChild
(
node
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
for
(
int32_t
i
=
0
;
i
<
matches
.
Count
(
)
;
+
+
i
)
{
nsNavHistoryResultNode
*
node
=
matches
[
i
]
;
node
-
>
mTags
.
SetIsVoid
(
true
)
;
nsAutoString
tags
;
rv
=
node
-
>
GetTags
(
tags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mHasSearchTerms
&
&
!
evaluateQueryForNode
(
mQuery
mOptions
node
)
)
{
nsNavHistoryContainerResultNode
*
parent
=
node
-
>
mParent
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_UNEXPECTED
)
;
int32_t
childIndex
=
parent
-
>
FindChild
(
node
)
;
NS_ASSERTION
(
childIndex
>
=
0
"
Child
not
found
in
parent
"
)
;
parent
-
>
RemoveChildAt
(
childIndex
)
;
}
else
{
NOTIFY_RESULT_OBSERVERS
(
result
NodeTagsChanged
(
node
)
)
;
}
}
return
NS_OK
;
}
nsresult
nsNavHistoryQueryResultNode
:
:
OnItemAdded
(
int64_t
aItemId
int64_t
aParentId
int32_t
aIndex
uint16_t
aItemType
nsIURI
*
aURI
PRTime
aDateAdded
const
nsACString
&
aGUID
const
nsACString
&
aParentGUID
uint16_t
aSource
)
{
if
(
aItemType
=
=
nsINavBookmarksService
:
:
TYPE_BOOKMARK
&
&
mLiveUpdate
!
=
QUERYUPDATE_SIMPLE
&
&
mLiveUpdate
!
=
QUERYUPDATE_TIME
&
&
mLiveUpdate
!
=
QUERYUPDATE_MOBILEPREF
)
{
nsresult
rv
=
Refresh
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
nsNavHistoryQueryResultNode
:
:
OnItemRemoved
(
int64_t
aItemId
int64_t
aParentFolder
int32_t
aIndex
uint16_t
aItemType
nsIURI
*
aURI
const
nsACString
&
aGUID
const
nsACString
&
aParentGUID
uint16_t
aSource
)
{
if
(
(
aItemType
=
=
nsINavBookmarksService
:
:
TYPE_BOOKMARK
|
|
(
aItemType
=
=
nsINavBookmarksService
:
:
TYPE_FOLDER
&
&
mOptions
-
>
ResultType
(
)
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_TAGS_ROOT
&
&
aParentGUID
.
EqualsLiteral
(
TAGS_ROOT_GUID
)
)
)
&
&
mLiveUpdate
!
=
QUERYUPDATE_SIMPLE
&
&
mLiveUpdate
!
=
QUERYUPDATE_TIME
&
&
mLiveUpdate
!
=
QUERYUPDATE_MOBILEPREF
)
{
nsresult
rv
=
Refresh
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
OnItemChanged
(
int64_t
aItemId
const
nsACString
&
aProperty
bool
aIsAnnotationProperty
const
nsACString
&
aNewValue
PRTime
aLastModified
uint16_t
aItemType
int64_t
aParentId
const
nsACString
&
aGUID
const
nsACString
&
aParentGUID
const
nsACString
&
aOldValue
uint16_t
aSource
)
{
if
(
aItemType
!
=
nsINavBookmarksService
:
:
TYPE_BOOKMARK
)
{
return
NS_OK
;
}
nsresult
rv
=
nsNavHistoryResultNode
:
:
OnItemChanged
(
aItemId
aProperty
aIsAnnotationProperty
aNewValue
aLastModified
aItemType
aParentId
aGUID
aParentGUID
aOldValue
aSource
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aItemId
=
=
mItemId
&
&
aProperty
.
EqualsLiteral
(
"
uri
"
)
)
{
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
history
NS_ERROR_OUT_OF_MEMORY
)
;
nsCOMPtr
<
nsINavHistoryQuery
>
query
;
nsCOMPtr
<
nsINavHistoryQueryOptions
>
options
;
rv
=
history
-
>
QueryStringToQuery
(
mURI
getter_AddRefs
(
query
)
getter_AddRefs
(
options
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mQuery
=
do_QueryObject
(
query
)
;
NS_ENSURE_STATE
(
mQuery
)
;
mOptions
=
do_QueryObject
(
options
)
;
NS_ENSURE_STATE
(
mOptions
)
;
rv
=
mOptions
-
>
Clone
(
getter_AddRefs
(
mOriginalOptions
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
mLiveUpdate
=
=
QUERYUPDATE_COMPLEX_WITH_BOOKMARKS
)
{
return
Refresh
(
)
;
}
NS_WARNING_ASSERTION
(
mResult
&
&
(
mResult
-
>
mIsAllBookmarksObserver
|
|
mResult
-
>
mIsBookmarkFolderObserver
)
"
history
observers
should
not
get
OnItemChanged
but
should
get
the
"
"
corresponding
history
notifications
instead
"
)
;
if
(
aItemType
=
=
nsINavBookmarksService
:
:
TYPE_BOOKMARK
&
&
aProperty
.
EqualsLiteral
(
"
tags
"
)
)
{
nsNavBookmarks
*
bookmarks
=
nsNavBookmarks
:
:
GetBookmarksService
(
)
;
NS_ENSURE_TRUE
(
bookmarks
NS_ERROR_OUT_OF_MEMORY
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
bookmarks
-
>
GetBookmarkURI
(
aItemId
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
NotifyIfTagsChanged
(
uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
OnItemVisited
(
int64_t
aItemId
int64_t
aVisitId
PRTime
aTime
uint32_t
aTransitionType
nsIURI
*
aURI
int64_t
aParentId
const
nsACString
&
aGUID
const
nsACString
&
aParentGUID
)
{
if
(
mLiveUpdate
!
=
QUERYUPDATE_COMPLEX_WITH_BOOKMARKS
)
NS_WARNING_ASSERTION
(
mResult
&
&
(
mResult
-
>
mIsAllBookmarksObserver
|
|
mResult
-
>
mIsBookmarkFolderObserver
)
"
history
observers
should
not
get
OnItemVisited
but
"
"
should
get
OnVisit
"
"
instead
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryQueryResultNode
:
:
OnItemMoved
(
int64_t
aFolder
int64_t
aOldParent
int32_t
aOldIndex
int64_t
aNewParent
int32_t
aNewIndex
uint16_t
aItemType
const
nsACString
&
aGUID
const
nsACString
&
aOldParentGUID
const
nsACString
&
aNewParentGUID
uint16_t
aSource
const
nsACString
&
aURI
)
{
if
(
mLiveUpdate
=
=
QUERYUPDATE_COMPLEX_WITH_BOOKMARKS
&
&
aItemType
!
=
nsINavBookmarksService
:
:
TYPE_SEPARATOR
&
&
aOldParent
!
=
aNewParent
)
{
return
Refresh
(
)
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsNavHistoryFolderResultNode
nsNavHistoryContainerResultNode
nsINavHistoryQueryResultNode
mozIStorageStatementCallback
)
nsNavHistoryFolderResultNode
:
:
nsNavHistoryFolderResultNode
(
const
nsACString
&
aTitle
nsNavHistoryQueryOptions
*
aOptions
int64_t
aFolderId
)
:
nsNavHistoryContainerResultNode
(
"
"
_ns
aTitle
0
nsNavHistoryResultNode
:
:
RESULT_TYPE_FOLDER
aOptions
)
mContentsValid
(
false
)
mTargetFolderItemId
(
aFolderId
)
mIsRegisteredFolderObserver
(
false
)
{
mItemId
=
aFolderId
;
}
nsNavHistoryFolderResultNode
:
:
~
nsNavHistoryFolderResultNode
(
)
{
if
(
mIsRegisteredFolderObserver
&
&
mResult
)
mResult
-
>
RemoveBookmarkFolderObserver
(
this
mTargetFolderItemId
)
;
}
void
nsNavHistoryFolderResultNode
:
:
OnRemoving
(
)
{
nsNavHistoryResultNode
:
:
OnRemoving
(
)
;
ClearChildren
(
true
)
;
mResult
=
nullptr
;
}
nsresult
nsNavHistoryFolderResultNode
:
:
OpenContainer
(
)
{
NS_ASSERTION
(
!
mExpanded
"
Container
must
be
expanded
to
close
it
"
)
;
nsresult
rv
;
if
(
!
mContentsValid
)
{
rv
=
FillChildren
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mExpanded
=
true
;
rv
=
NotifyOnStateChange
(
STATE_CLOSED
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
nsNavHistoryFolderResultNode
:
:
OpenContainerAsync
(
)
{
NS_ASSERTION
(
!
mExpanded
"
Container
already
expanded
when
opening
it
"
)
;
if
(
mContentsValid
)
return
OpenContainer
(
)
;
nsresult
rv
=
FillChildrenAsync
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
NotifyOnStateChange
(
STATE_CLOSED
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
GetHasChildren
(
bool
*
aHasChildren
)
{
if
(
!
mContentsValid
)
{
nsresult
rv
=
FillChildren
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
*
aHasChildren
=
(
mChildren
.
Count
(
)
>
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
GetFolderItemId
(
int64_t
*
aItemId
)
{
*
aItemId
=
mTargetFolderItemId
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
GetTargetFolderGuid
(
nsACString
&
aGuid
)
{
aGuid
=
mTargetFolderGuid
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
GetUri
(
nsACString
&
aURI
)
{
if
(
!
mURI
.
IsEmpty
(
)
)
{
aURI
=
mURI
;
return
NS_OK
;
}
nsCOMPtr
<
nsINavHistoryQuery
>
query
;
nsresult
rv
=
GetQuery
(
getter_AddRefs
(
query
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
history
NS_ERROR_OUT_OF_MEMORY
)
;
rv
=
history
-
>
QueryToQueryString
(
query
mOriginalOptions
mURI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aURI
=
mURI
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
GetQuery
(
nsINavHistoryQuery
*
*
_query
)
{
RefPtr
<
nsNavHistoryQuery
>
query
=
new
nsNavHistoryQuery
(
)
;
nsTArray
<
nsCString
>
parents
;
parents
.
AppendElement
(
mTargetFolderGuid
)
;
nsresult
rv
=
query
-
>
SetParents
(
parents
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
query
.
forget
(
_query
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
GetQueryOptions
(
nsINavHistoryQueryOptions
*
*
_options
)
{
MOZ_ASSERT
(
mOptions
"
Options
should
be
valid
"
)
;
RefPtr
<
nsNavHistoryQueryOptions
>
options
=
mOptions
;
options
.
forget
(
_options
)
;
return
NS_OK
;
}
nsresult
nsNavHistoryFolderResultNode
:
:
FillChildren
(
)
{
NS_ASSERTION
(
!
mContentsValid
"
Don
'
t
call
FillChildren
when
contents
are
valid
"
)
;
NS_ASSERTION
(
mChildren
.
Count
(
)
=
=
0
"
We
are
trying
to
fill
children
when
there
already
are
some
"
)
;
nsNavBookmarks
*
bookmarks
=
nsNavBookmarks
:
:
GetBookmarksService
(
)
;
NS_ENSURE_TRUE
(
bookmarks
NS_ERROR_OUT_OF_MEMORY
)
;
nsresult
rv
=
bookmarks
-
>
QueryFolderChildren
(
mTargetFolderItemId
mOptions
&
mChildren
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
OnChildrenFilled
(
)
;
}
nsresult
nsNavHistoryFolderResultNode
:
:
OnChildrenFilled
(
)
{
FillStats
(
)
;
if
(
mResult
&
&
mResult
-
>
mNeedsToApplySortingMode
)
{
mResult
-
>
SetSortingMode
(
mResult
-
>
mSortingMode
)
;
}
else
{
SortComparator
comparator
=
GetSortingComparator
(
GetSortType
(
)
)
;
if
(
comparator
)
{
RecursiveSort
(
comparator
)
;
}
}
if
(
!
mParent
&
&
mOptions
-
>
MaxResults
(
)
)
{
while
(
(
uint32_t
)
mChildren
.
Count
(
)
>
mOptions
-
>
MaxResults
(
)
)
mChildren
.
RemoveObjectAt
(
mChildren
.
Count
(
)
-
1
)
;
}
EnsureRegisteredAsFolderObserver
(
)
;
mContentsValid
=
true
;
return
NS_OK
;
}
void
nsNavHistoryFolderResultNode
:
:
EnsureRegisteredAsFolderObserver
(
)
{
if
(
!
mIsRegisteredFolderObserver
&
&
mResult
)
{
mResult
-
>
AddBookmarkFolderObserver
(
this
mTargetFolderItemId
)
;
mIsRegisteredFolderObserver
=
true
;
}
}
nsresult
nsNavHistoryFolderResultNode
:
:
FillChildrenAsync
(
)
{
NS_ASSERTION
(
!
mContentsValid
"
FillChildrenAsync
when
contents
are
valid
"
)
;
NS_ASSERTION
(
mChildren
.
Count
(
)
=
=
0
"
FillChildrenAsync
when
children
exist
"
)
;
mAsyncBookmarkIndex
=
-
1
;
nsNavBookmarks
*
bmSvc
=
nsNavBookmarks
:
:
GetBookmarksService
(
)
;
NS_ENSURE_TRUE
(
bmSvc
NS_ERROR_OUT_OF_MEMORY
)
;
nsresult
rv
=
bmSvc
-
>
QueryFolderChildrenAsync
(
this
getter_AddRefs
(
mAsyncPendingStmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
EnsureRegisteredAsFolderObserver
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
HandleResult
(
mozIStorageResultSet
*
aResultSet
)
{
NS_ENSURE_ARG_POINTER
(
aResultSet
)
;
nsNavBookmarks
*
bmSvc
=
nsNavBookmarks
:
:
GetBookmarksService
(
)
;
if
(
!
bmSvc
)
{
CancelAsyncOpen
(
false
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsCOMPtr
<
mozIStorageRow
>
row
;
while
(
NS_SUCCEEDED
(
aResultSet
-
>
GetNextRow
(
getter_AddRefs
(
row
)
)
)
&
&
row
)
{
nsresult
rv
=
bmSvc
-
>
ProcessFolderNodeRow
(
row
mOptions
&
mChildren
mAsyncBookmarkIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
CancelAsyncOpen
(
false
)
;
return
rv
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
HandleCompletion
(
uint16_t
aReason
)
{
if
(
aReason
=
=
mozIStorageStatementCallback
:
:
REASON_FINISHED
&
&
mAsyncCanceledState
=
=
NOT_CANCELED
)
{
nsresult
rv
=
OnChildrenFilled
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mExpanded
=
true
;
mAsyncPendingStmt
=
nullptr
;
rv
=
NotifyOnStateChange
(
STATE_LOADING
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
mAsyncCanceledState
=
=
CANCELED_RESTART_NEEDED
)
{
mAsyncCanceledState
=
NOT_CANCELED
;
ClearChildren
(
false
)
;
FillChildrenAsync
(
)
;
}
else
{
mAsyncCanceledState
=
NOT_CANCELED
;
ClearChildren
(
true
)
;
CloseContainer
(
)
;
}
return
NS_OK
;
}
void
nsNavHistoryFolderResultNode
:
:
ClearChildren
(
bool
unregister
)
{
for
(
int32_t
i
=
0
;
i
<
mChildren
.
Count
(
)
;
+
+
i
)
mChildren
[
i
]
-
>
OnRemoving
(
)
;
mChildren
.
Clear
(
)
;
bool
needsUnregister
=
unregister
&
&
(
mContentsValid
|
|
mAsyncPendingStmt
)
;
if
(
needsUnregister
&
&
mResult
&
&
mIsRegisteredFolderObserver
)
{
mResult
-
>
RemoveBookmarkFolderObserver
(
this
mTargetFolderItemId
)
;
mIsRegisteredFolderObserver
=
false
;
}
mContentsValid
=
false
;
}
nsresult
nsNavHistoryFolderResultNode
:
:
Refresh
(
)
{
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NS_ENSURE_STATE
(
result
)
;
if
(
result
-
>
mBatchInProgress
)
{
result
-
>
requestRefresh
(
this
)
;
return
NS_OK
;
}
ClearChildren
(
true
)
;
if
(
!
mExpanded
)
{
return
NS_OK
;
}
(
void
)
FillChildren
(
)
;
NOTIFY_RESULT_OBSERVERS
(
result
InvalidateContainer
(
TO_CONTAINER
(
this
)
)
)
;
return
NS_OK
;
}
bool
nsNavHistoryFolderResultNode
:
:
StartIncrementalUpdate
(
)
{
if
(
!
mOptions
-
>
ExcludeItems
(
)
&
&
!
mOptions
-
>
ExcludeQueries
(
)
)
{
if
(
mExpanded
|
|
AreChildrenVisible
(
)
)
return
true
;
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NS_ENSURE_TRUE
(
result
false
)
;
if
(
mParent
)
return
result
-
>
mObservers
.
Length
(
)
>
0
;
}
(
void
)
Refresh
(
)
;
return
false
;
}
void
nsNavHistoryFolderResultNode
:
:
ReindexRange
(
int32_t
aStartIndex
int32_t
aEndIndex
int32_t
aDelta
)
{
for
(
int32_t
i
=
0
;
i
<
mChildren
.
Count
(
)
;
+
+
i
)
{
nsNavHistoryResultNode
*
node
=
mChildren
[
i
]
;
if
(
node
-
>
mBookmarkIndex
>
=
aStartIndex
&
&
node
-
>
mBookmarkIndex
<
=
aEndIndex
)
node
-
>
mBookmarkIndex
+
=
aDelta
;
}
}
nsNavHistoryResultNode
*
nsNavHistoryFolderResultNode
:
:
FindChildById
(
int64_t
aItemId
uint32_t
*
aNodeIndex
)
{
for
(
int32_t
i
=
0
;
i
<
mChildren
.
Count
(
)
;
+
+
i
)
{
if
(
mChildren
[
i
]
-
>
mItemId
=
=
aItemId
|
|
(
mChildren
[
i
]
-
>
IsFolder
(
)
&
&
mChildren
[
i
]
-
>
GetAsFolder
(
)
-
>
mTargetFolderItemId
=
=
aItemId
)
)
{
*
aNodeIndex
=
i
;
return
mChildren
[
i
]
;
}
}
return
nullptr
;
}
#
define
RESTART_AND_RETURN_IF_ASYNC_PENDING
(
)
\
if
(
mAsyncPendingStmt
)
{
\
CancelAsyncOpen
(
true
)
;
\
return
NS_OK
;
\
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
GetSkipTags
(
bool
*
aSkipTags
)
{
*
aSkipTags
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
OnBeginUpdateBatch
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
OnEndUpdateBatch
(
)
{
return
NS_OK
;
}
nsresult
nsNavHistoryFolderResultNode
:
:
OnItemAdded
(
int64_t
aItemId
int64_t
aParentFolder
int32_t
aIndex
uint16_t
aItemType
nsIURI
*
aURI
PRTime
aDateAdded
const
nsACString
&
aGUID
const
nsACString
&
aParentGUID
uint16_t
aSource
)
{
MOZ_ASSERT
(
aParentFolder
=
=
mTargetFolderItemId
"
Got
wrong
bookmark
update
"
)
;
RESTART_AND_RETURN_IF_ASYNC_PENDING
(
)
;
{
uint32_t
index
;
nsNavHistoryResultNode
*
node
=
FindChildById
(
aItemId
&
index
)
;
if
(
node
)
return
NS_OK
;
}
bool
excludeItems
=
mOptions
-
>
ExcludeItems
(
)
;
if
(
aIndex
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
index
for
item
adding
:
<
0
"
)
;
aIndex
=
0
;
}
else
if
(
aIndex
>
mChildren
.
Count
(
)
)
{
if
(
!
excludeItems
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
index
for
item
adding
:
greater
than
"
"
count
"
)
;
}
aIndex
=
mChildren
.
Count
(
)
;
}
nsresult
rv
;
bool
isQuery
=
false
;
if
(
aItemType
=
=
nsINavBookmarksService
:
:
TYPE_BOOKMARK
)
{
NS_ASSERTION
(
aURI
"
Got
a
null
URI
when
we
are
a
bookmark
?
!
"
)
;
nsAutoCString
itemURISpec
;
rv
=
aURI
-
>
GetSpec
(
itemURISpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
isQuery
=
IsQueryURI
(
itemURISpec
)
;
}
if
(
aItemType
!
=
nsINavBookmarksService
:
:
TYPE_FOLDER
&
&
!
isQuery
&
&
excludeItems
)
{
ReindexRange
(
aIndex
INT32_MAX
1
)
;
return
NS_OK
;
}
if
(
!
StartIncrementalUpdate
(
)
)
return
NS_OK
;
ReindexRange
(
aIndex
INT32_MAX
1
)
;
RefPtr
<
nsNavHistoryResultNode
>
node
;
if
(
aItemType
=
=
nsINavBookmarksService
:
:
TYPE_BOOKMARK
)
{
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
history
NS_ERROR_OUT_OF_MEMORY
)
;
rv
=
history
-
>
BookmarkIdToResultNode
(
aItemId
mOptions
getter_AddRefs
(
node
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
aItemType
=
=
nsINavBookmarksService
:
:
TYPE_FOLDER
)
{
nsNavBookmarks
*
bookmarks
=
nsNavBookmarks
:
:
GetBookmarksService
(
)
;
NS_ENSURE_TRUE
(
bookmarks
NS_ERROR_OUT_OF_MEMORY
)
;
rv
=
bookmarks
-
>
ResultNodeForContainer
(
PromiseFlatCString
(
aGUID
)
new
nsNavHistoryQueryOptions
(
)
getter_AddRefs
(
node
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
aItemType
=
=
nsINavBookmarksService
:
:
TYPE_SEPARATOR
)
{
node
=
new
nsNavHistorySeparatorResultNode
(
)
;
node
-
>
mItemId
=
aItemId
;
node
-
>
mBookmarkGuid
=
aGUID
;
node
-
>
mDateAdded
=
aDateAdded
;
node
-
>
mLastModified
=
aDateAdded
;
}
node
-
>
mBookmarkIndex
=
aIndex
;
if
(
aItemType
=
=
nsINavBookmarksService
:
:
TYPE_SEPARATOR
|
|
GetSortType
(
)
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_NONE
)
{
return
InsertChildAt
(
node
aIndex
)
;
}
return
InsertSortedChild
(
node
)
;
}
nsresult
nsNavHistoryQueryResultNode
:
:
OnMobilePrefChanged
(
bool
newValue
)
{
RESTART_AND_RETURN_IF_ASYNC_PENDING
(
)
;
if
(
newValue
)
{
return
Refresh
(
)
;
}
int32_t
existingIndex
;
FindChildByGuid
(
nsLiteralCString
(
MOBILE_BOOKMARKS_VIRTUAL_GUID
)
&
existingIndex
)
;
if
(
existingIndex
=
=
-
1
)
{
return
NS_OK
;
}
return
RemoveChildAt
(
existingIndex
)
;
}
nsresult
nsNavHistoryFolderResultNode
:
:
OnItemRemoved
(
int64_t
aItemId
int64_t
aParentFolder
int32_t
aIndex
uint16_t
aItemType
nsIURI
*
aURI
const
nsACString
&
aGUID
const
nsACString
&
aParentGUID
uint16_t
aSource
)
{
MOZ_ASSERT_IF
(
mItemId
!
=
mTargetFolderItemId
aItemId
!
=
mTargetFolderItemId
)
;
MOZ_ASSERT_IF
(
mItemId
=
=
mTargetFolderItemId
aItemId
!
=
mItemId
)
;
if
(
mTargetFolderItemId
=
=
aItemId
|
|
mItemId
=
=
aItemId
)
return
NS_OK
;
MOZ_ASSERT
(
aParentFolder
=
=
mTargetFolderItemId
"
Got
wrong
bookmark
update
"
)
;
RESTART_AND_RETURN_IF_ASYNC_PENDING
(
)
;
uint32_t
index
;
nsNavHistoryResultNode
*
node
=
FindChildById
(
aItemId
&
index
)
;
if
(
!
node
)
{
return
NS_OK
;
}
bool
excludeItems
=
mOptions
-
>
ExcludeItems
(
)
;
if
(
(
node
-
>
IsURI
(
)
|
|
node
-
>
IsSeparator
(
)
)
&
&
excludeItems
)
{
ReindexRange
(
aIndex
INT32_MAX
-
1
)
;
return
NS_OK
;
}
if
(
!
StartIncrementalUpdate
(
)
)
return
NS_OK
;
ReindexRange
(
aIndex
+
1
INT32_MAX
-
1
)
;
return
RemoveChildAt
(
index
)
;
}
NS_IMETHODIMP
nsNavHistoryResultNode
:
:
OnItemChanged
(
int64_t
aItemId
const
nsACString
&
aProperty
bool
aIsAnnotationProperty
const
nsACString
&
aNewValue
PRTime
aLastModified
uint16_t
aItemType
int64_t
aParentId
const
nsACString
&
aGUID
const
nsACString
&
aParentGUID
const
nsACString
&
aOldValue
uint16_t
aSource
)
{
if
(
aItemId
!
=
mItemId
)
return
NS_OK
;
if
(
!
aProperty
.
EqualsLiteral
(
"
favicon
"
)
)
{
mLastModified
=
aLastModified
;
}
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NS_ENSURE_STATE
(
result
)
;
bool
shouldNotify
=
!
mParent
|
|
mParent
-
>
AreChildrenVisible
(
)
;
if
(
aProperty
.
EqualsLiteral
(
"
title
"
)
)
{
mTitle
=
aNewValue
;
if
(
shouldNotify
)
NOTIFY_RESULT_OBSERVERS
(
result
NodeTitleChanged
(
this
mTitle
)
)
;
}
else
if
(
aProperty
.
EqualsLiteral
(
"
uri
"
)
)
{
mTags
.
SetIsVoid
(
true
)
;
nsCString
oldURI
(
mURI
)
;
mURI
=
aNewValue
;
if
(
shouldNotify
)
NOTIFY_RESULT_OBSERVERS
(
result
NodeURIChanged
(
this
oldURI
)
)
;
}
else
if
(
aProperty
.
EqualsLiteral
(
"
favicon
"
)
)
{
if
(
shouldNotify
)
NOTIFY_RESULT_OBSERVERS
(
result
NodeIconChanged
(
this
)
)
;
}
else
if
(
aProperty
.
EqualsLiteral
(
"
cleartime
"
)
)
{
PRTime
oldTime
=
mTime
;
mTime
=
0
;
if
(
shouldNotify
)
{
NOTIFY_RESULT_OBSERVERS
(
result
NodeHistoryDetailsChanged
(
this
oldTime
mAccessCount
)
)
;
}
}
else
if
(
aProperty
.
EqualsLiteral
(
"
tags
"
)
)
{
mTags
.
SetIsVoid
(
true
)
;
if
(
shouldNotify
)
NOTIFY_RESULT_OBSERVERS
(
result
NodeTagsChanged
(
this
)
)
;
}
else
if
(
aProperty
.
EqualsLiteral
(
"
dateAdded
"
)
)
{
mDateAdded
=
aLastModified
;
if
(
shouldNotify
)
NOTIFY_RESULT_OBSERVERS
(
result
NodeDateAddedChanged
(
this
mDateAdded
)
)
;
}
else
if
(
aProperty
.
EqualsLiteral
(
"
lastModified
"
)
)
{
if
(
shouldNotify
)
{
NOTIFY_RESULT_OBSERVERS
(
result
NodeLastModifiedChanged
(
this
aLastModified
)
)
;
}
}
else
if
(
aProperty
.
EqualsLiteral
(
"
keyword
"
)
)
{
if
(
shouldNotify
)
NOTIFY_RESULT_OBSERVERS
(
result
NodeKeywordChanged
(
this
aNewValue
)
)
;
}
else
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
bookmark
property
changing
.
"
)
;
if
(
!
mParent
)
return
NS_OK
;
int32_t
ourIndex
=
mParent
-
>
FindChild
(
this
)
;
NS_ASSERTION
(
ourIndex
>
=
0
"
Could
not
find
self
in
parent
"
)
;
if
(
ourIndex
>
=
0
)
mParent
-
>
EnsureItemPosition
(
ourIndex
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
OnItemChanged
(
int64_t
aItemId
const
nsACString
&
aProperty
bool
aIsAnnotationProperty
const
nsACString
&
aNewValue
PRTime
aLastModified
uint16_t
aItemType
int64_t
aParentId
const
nsACString
&
aGUID
const
nsACString
&
aParentGUID
const
nsACString
&
aOldValue
uint16_t
aSource
)
{
RESTART_AND_RETURN_IF_ASYNC_PENDING
(
)
;
return
nsNavHistoryResultNode
:
:
OnItemChanged
(
aItemId
aProperty
aIsAnnotationProperty
aNewValue
aLastModified
aItemType
aParentId
aGUID
aParentGUID
aOldValue
aSource
)
;
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
OnItemVisited
(
int64_t
aItemId
int64_t
aVisitId
PRTime
aTime
uint32_t
aTransitionType
nsIURI
*
aURI
int64_t
aParentId
const
nsACString
&
aGUID
const
nsACString
&
aParentGUID
)
{
if
(
mOptions
-
>
ExcludeItems
(
)
)
return
NS_OK
;
RESTART_AND_RETURN_IF_ASYNC_PENDING
(
)
;
if
(
!
StartIncrementalUpdate
(
)
)
return
NS_OK
;
uint32_t
nodeIndex
;
nsNavHistoryResultNode
*
node
=
FindChildById
(
aItemId
&
nodeIndex
)
;
if
(
!
node
)
return
NS_ERROR_FAILURE
;
uint32_t
nodeOldAccessCount
=
node
-
>
mAccessCount
;
PRTime
nodeOldTime
=
node
-
>
mTime
;
node
-
>
mTime
=
aTime
;
+
+
node
-
>
mAccessCount
;
int32_t
oldAccessCount
=
mAccessCount
;
+
+
mAccessCount
;
if
(
aTime
>
mTime
)
mTime
=
aTime
;
nsresult
rv
=
ReverseUpdateStats
(
mAccessCount
-
oldAccessCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
history
NS_OK
)
;
RefPtr
<
nsNavHistoryResultNode
>
visitNode
;
rv
=
history
-
>
VisitIdToResultNode
(
aVisitId
mOptions
getter_AddRefs
(
visitNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
visitNode
)
{
return
NS_OK
;
}
node
-
>
mFrecency
=
visitNode
-
>
mFrecency
;
if
(
AreChildrenVisible
(
)
)
{
nsNavHistoryResult
*
result
=
GetResult
(
)
;
NOTIFY_RESULT_OBSERVERS
(
result
NodeHistoryDetailsChanged
(
node
nodeOldTime
nodeOldAccessCount
)
)
;
}
uint32_t
sortType
=
GetSortType
(
)
;
if
(
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_VISITCOUNT_ASCENDING
|
|
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_VISITCOUNT_DESCENDING
|
|
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_DATE_ASCENDING
|
|
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_DATE_DESCENDING
|
|
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_FRECENCY_ASCENDING
|
|
sortType
=
=
nsINavHistoryQueryOptions
:
:
SORT_BY_FRECENCY_DESCENDING
)
{
int32_t
childIndex
=
FindChild
(
node
)
;
NS_ASSERTION
(
childIndex
>
=
0
"
Could
not
find
child
we
just
got
a
reference
to
"
)
;
if
(
childIndex
>
=
0
)
{
EnsureItemPosition
(
childIndex
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryFolderResultNode
:
:
OnItemMoved
(
int64_t
aItemId
int64_t
aOldParent
int32_t
aOldIndex
int64_t
aNewParent
int32_t
aNewIndex
uint16_t
aItemType
const
nsACString
&
aGUID
const
nsACString
&
aOldParentGUID
const
nsACString
&
aNewParentGUID
uint16_t
aSource
const
nsACString
&
aURI
)
{
NS_ASSERTION
(
aOldParent
=
=
mTargetFolderItemId
|
|
aNewParent
=
=
mTargetFolderItemId
"
Got
a
bookmark
message
that
doesn
'
t
belong
to
us
"
)
;
RESTART_AND_RETURN_IF_ASYNC_PENDING
(
)
;
bool
excludeItems
=
mOptions
-
>
ExcludeItems
(
)
;
if
(
excludeItems
&
&
(
aItemType
=
=
nsINavBookmarksService
:
:
TYPE_SEPARATOR
|
|
(
aItemType
=
=
nsINavBookmarksService
:
:
TYPE_BOOKMARK
&
&
!
StringBeginsWith
(
aURI
"
place
:
"
_ns
)
)
)
)
{
return
NS_OK
;
}
uint32_t
index
;
nsNavHistoryResultNode
*
node
=
FindChildById
(
aItemId
&
index
)
;
if
(
node
&
&
aNewParent
=
=
mTargetFolderItemId
&
&
index
=
=
static_cast
<
uint32_t
>
(
aNewIndex
)
)
return
NS_OK
;
if
(
!
node
&
&
aOldParent
=
=
mTargetFolderItemId
)
return
NS_OK
;
if
(
!
StartIncrementalUpdate
(
)
)
return
NS_OK
;
if
(
aOldParent
=
=
aNewParent
)
{
ReindexRange
(
aOldIndex
+
1
INT32_MAX
-
1
)
;
ReindexRange
(
aNewIndex
INT32_MAX
1
)
;
MOZ_ASSERT
(
node
"
Can
'
t
find
folder
that
is
moving
!
"
)
;
if
(
!
node
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
index
<
uint32_t
(
mChildren
.
Count
(
)
)
"
Invalid
index
!
"
)
;
node
-
>
mBookmarkIndex
=
aNewIndex
;
EnsureItemPosition
(
index
)
;
return
NS_OK
;
}
else
{
nsCOMPtr
<
nsIURI
>
itemURI
;
if
(
aItemType
=
=
nsINavBookmarksService
:
:
TYPE_BOOKMARK
)
{
nsNavBookmarks
*
bookmarks
=
nsNavBookmarks
:
:
GetBookmarksService
(
)
;
NS_ENSURE_TRUE
(
bookmarks
NS_ERROR_OUT_OF_MEMORY
)
;
nsresult
rv
=
bookmarks
-
>
GetBookmarkURI
(
aItemId
getter_AddRefs
(
itemURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
aOldParent
=
=
mTargetFolderItemId
)
{
OnItemRemoved
(
aItemId
aOldParent
aOldIndex
aItemType
itemURI
aGUID
aOldParentGUID
aSource
)
;
}
if
(
aNewParent
=
=
mTargetFolderItemId
)
{
OnItemAdded
(
aItemId
aNewParent
aNewIndex
aItemType
itemURI
RoundedPRNow
(
)
aGUID
aNewParentGUID
aSource
)
;
}
}
return
NS_OK
;
}
nsNavHistorySeparatorResultNode
:
:
nsNavHistorySeparatorResultNode
(
)
:
nsNavHistoryResultNode
(
"
"
_ns
"
"
_ns
0
0
)
{
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsNavHistoryResult
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsNavHistoryResult
)
tmp
-
>
StopObserving
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mRootNode
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mObservers
)
for
(
auto
it
=
tmp
-
>
mBookmarkFolderObservers
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
delete
it
.
Data
(
)
;
it
.
Remove
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMobilePrefObservers
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAllBookmarksObservers
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mHistoryObservers
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mRefreshParticipants
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_WEAK_REFERENCE
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsNavHistoryResult
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRootNode
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mObservers
)
for
(
auto
it
=
tmp
-
>
mBookmarkFolderObservers
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
nsNavHistoryResult
:
:
FolderObserverList
*
&
list
=
it
.
Data
(
)
;
for
(
uint32_t
i
=
0
;
i
<
list
-
>
Length
(
)
;
+
+
i
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mBookmarkFolderObservers
value
[
i
]
"
)
;
nsNavHistoryResultNode
*
node
=
list
-
>
ElementAt
(
i
)
;
cb
.
NoteXPCOMChild
(
node
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMobilePrefObservers
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAllBookmarksObservers
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mHistoryObservers
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRefreshParticipants
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsNavHistoryResult
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsNavHistoryResult
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsNavHistoryResult
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsINavHistoryResult
)
NS_INTERFACE_MAP_STATIC_AMBIGUOUS
(
nsNavHistoryResult
)
NS_INTERFACE_MAP_ENTRY
(
nsINavHistoryResult
)
NS_INTERFACE_MAP_ENTRY
(
nsINavBookmarkObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsINavHistoryObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END
nsNavHistoryResult
:
:
nsNavHistoryResult
(
nsNavHistoryContainerResultNode
*
aRoot
const
RefPtr
<
nsNavHistoryQuery
>
&
aQuery
const
RefPtr
<
nsNavHistoryQueryOptions
>
&
aOptions
)
:
mRootNode
(
aRoot
)
mQuery
(
aQuery
)
mOptions
(
aOptions
)
mNeedsToApplySortingMode
(
false
)
mIsHistoryObserver
(
false
)
mIsBookmarkFolderObserver
(
false
)
mIsAllBookmarksObserver
(
false
)
mIsMobilePrefObserver
(
false
)
mBookmarkFolderObservers
(
64
)
mBatchInProgress
(
false
)
mSuppressNotifications
(
false
)
{
mSortingMode
=
aOptions
-
>
SortingMode
(
)
;
mRootNode
-
>
mResult
=
this
;
MOZ_ASSERT
(
mRootNode
-
>
mIndentLevel
=
=
-
1
"
Root
node
'
s
indent
level
initialized
wrong
"
)
;
mRootNode
-
>
FillStats
(
)
;
}
nsNavHistoryResult
:
:
~
nsNavHistoryResult
(
)
{
for
(
auto
it
=
mBookmarkFolderObservers
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
delete
it
.
Data
(
)
;
it
.
Remove
(
)
;
}
}
void
nsNavHistoryResult
:
:
StopObserving
(
)
{
AutoTArray
<
PlacesEventType
3
>
events
;
if
(
mIsBookmarkFolderObserver
|
|
mIsAllBookmarksObserver
)
{
nsNavBookmarks
*
bookmarks
=
nsNavBookmarks
:
:
GetBookmarksService
(
)
;
if
(
bookmarks
)
{
bookmarks
-
>
RemoveObserver
(
this
)
;
mIsBookmarkFolderObserver
=
false
;
mIsAllBookmarksObserver
=
false
;
}
events
.
AppendElement
(
PlacesEventType
:
:
Bookmark_added
)
;
events
.
AppendElement
(
PlacesEventType
:
:
Bookmark_removed
)
;
}
if
(
mIsMobilePrefObserver
)
{
Preferences
:
:
UnregisterCallback
(
OnMobilePrefChangedCallback
MOBILE_BOOKMARKS_PREF
this
)
;
mIsMobilePrefObserver
=
false
;
}
if
(
mIsHistoryObserver
)
{
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
if
(
history
)
{
history
-
>
RemoveObserver
(
this
)
;
events
.
AppendElement
(
PlacesEventType
:
:
Page_visited
)
;
mIsHistoryObserver
=
false
;
}
}
PlacesObservers
:
:
RemoveListener
(
events
this
)
;
}
void
nsNavHistoryResult
:
:
AddHistoryObserver
(
nsNavHistoryQueryResultNode
*
aNode
)
{
if
(
!
mIsHistoryObserver
)
{
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ASSERTION
(
history
"
Can
'
t
create
history
service
"
)
;
history
-
>
AddObserver
(
this
true
)
;
AutoTArray
<
PlacesEventType
1
>
events
;
events
.
AppendElement
(
PlacesEventType
:
:
Page_visited
)
;
PlacesObservers
:
:
AddListener
(
events
this
)
;
mIsHistoryObserver
=
true
;
}
if
(
mHistoryObservers
.
IndexOf
(
aNode
)
=
=
QueryObserverList
:
:
NoIndex
)
{
mHistoryObservers
.
AppendElement
(
aNode
)
;
}
}
void
nsNavHistoryResult
:
:
AddAllBookmarksObserver
(
nsNavHistoryQueryResultNode
*
aNode
)
{
if
(
!
mIsAllBookmarksObserver
&
&
!
mIsBookmarkFolderObserver
)
{
nsNavBookmarks
*
bookmarks
=
nsNavBookmarks
:
:
GetBookmarksService
(
)
;
if
(
!
bookmarks
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Can
'
t
create
bookmark
service
"
)
;
return
;
}
bookmarks
-
>
AddObserver
(
this
true
)
;
AutoTArray
<
PlacesEventType
2
>
events
;
events
.
AppendElement
(
PlacesEventType
:
:
Bookmark_added
)
;
events
.
AppendElement
(
PlacesEventType
:
:
Bookmark_removed
)
;
PlacesObservers
:
:
AddListener
(
events
this
)
;
mIsAllBookmarksObserver
=
true
;
}
if
(
mAllBookmarksObservers
.
IndexOf
(
aNode
)
=
=
QueryObserverList
:
:
NoIndex
)
{
mAllBookmarksObservers
.
AppendElement
(
aNode
)
;
}
}
void
nsNavHistoryResult
:
:
AddMobilePrefsObserver
(
nsNavHistoryQueryResultNode
*
aNode
)
{
if
(
!
mIsMobilePrefObserver
)
{
Preferences
:
:
RegisterCallback
(
OnMobilePrefChangedCallback
MOBILE_BOOKMARKS_PREF
this
)
;
mIsMobilePrefObserver
=
true
;
}
if
(
mMobilePrefObservers
.
IndexOf
(
aNode
)
=
=
mMobilePrefObservers
.
NoIndex
)
{
mMobilePrefObservers
.
AppendElement
(
aNode
)
;
}
}
void
nsNavHistoryResult
:
:
AddBookmarkFolderObserver
(
nsNavHistoryFolderResultNode
*
aNode
int64_t
aFolder
)
{
if
(
!
mIsBookmarkFolderObserver
&
&
!
mIsAllBookmarksObserver
)
{
nsNavBookmarks
*
bookmarks
=
nsNavBookmarks
:
:
GetBookmarksService
(
)
;
if
(
!
bookmarks
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Can
'
t
create
bookmark
service
"
)
;
return
;
}
bookmarks
-
>
AddObserver
(
this
true
)
;
AutoTArray
<
PlacesEventType
2
>
events
;
events
.
AppendElement
(
PlacesEventType
:
:
Bookmark_added
)
;
events
.
AppendElement
(
PlacesEventType
:
:
Bookmark_removed
)
;
PlacesObservers
:
:
AddListener
(
events
this
)
;
mIsBookmarkFolderObserver
=
true
;
}
FolderObserverList
*
list
=
BookmarkFolderObserversForId
(
aFolder
true
)
;
if
(
list
-
>
IndexOf
(
aNode
)
=
=
FolderObserverList
:
:
NoIndex
)
{
list
-
>
AppendElement
(
aNode
)
;
}
}
void
nsNavHistoryResult
:
:
RemoveHistoryObserver
(
nsNavHistoryQueryResultNode
*
aNode
)
{
mHistoryObservers
.
RemoveElement
(
aNode
)
;
}
void
nsNavHistoryResult
:
:
RemoveAllBookmarksObserver
(
nsNavHistoryQueryResultNode
*
aNode
)
{
mAllBookmarksObservers
.
RemoveElement
(
aNode
)
;
}
void
nsNavHistoryResult
:
:
RemoveMobilePrefsObserver
(
nsNavHistoryQueryResultNode
*
aNode
)
{
mMobilePrefObservers
.
RemoveElement
(
aNode
)
;
}
void
nsNavHistoryResult
:
:
RemoveBookmarkFolderObserver
(
nsNavHistoryFolderResultNode
*
aNode
int64_t
aFolder
)
{
FolderObserverList
*
list
=
BookmarkFolderObserversForId
(
aFolder
false
)
;
if
(
!
list
)
return
;
list
-
>
RemoveElement
(
aNode
)
;
}
nsNavHistoryResult
:
:
FolderObserverList
*
nsNavHistoryResult
:
:
BookmarkFolderObserversForId
(
int64_t
aFolderId
bool
aCreate
)
{
FolderObserverList
*
list
;
if
(
mBookmarkFolderObservers
.
Get
(
aFolderId
&
list
)
)
return
list
;
if
(
!
aCreate
)
return
nullptr
;
list
=
new
FolderObserverList
;
mBookmarkFolderObservers
.
Put
(
aFolderId
list
)
;
return
list
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
GetSortingMode
(
uint16_t
*
aSortingMode
)
{
*
aSortingMode
=
mSortingMode
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
SetSortingMode
(
uint16_t
aSortingMode
)
{
NS_ENSURE_STATE
(
mRootNode
)
;
if
(
aSortingMode
>
nsINavHistoryQueryOptions
:
:
SORT_BY_FRECENCY_DESCENDING
)
return
NS_ERROR_INVALID_ARG
;
NS_ASSERTION
(
mOptions
"
Options
should
always
be
present
for
a
root
query
"
)
;
mSortingMode
=
aSortingMode
;
if
(
!
mRootNode
-
>
mExpanded
)
{
mNeedsToApplySortingMode
=
true
;
return
NS_OK
;
}
nsNavHistoryContainerResultNode
:
:
SortComparator
comparator
=
nsNavHistoryContainerResultNode
:
:
GetSortingComparator
(
aSortingMode
)
;
if
(
comparator
)
{
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
history
NS_ERROR_OUT_OF_MEMORY
)
;
mRootNode
-
>
RecursiveSort
(
comparator
)
;
}
NOTIFY_RESULT_OBSERVERS
(
this
SortingChanged
(
aSortingMode
)
)
;
NOTIFY_RESULT_OBSERVERS
(
this
InvalidateContainer
(
mRootNode
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
AddObserver
(
nsINavHistoryResultObserver
*
aObserver
bool
aOwnsWeak
)
{
NS_ENSURE_ARG
(
aObserver
)
;
nsresult
rv
=
mObservers
.
AppendWeakElementUnlessExists
(
aObserver
aOwnsWeak
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aObserver
-
>
SetResult
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mBatchInProgress
)
{
NOTIFY_RESULT_OBSERVERS
(
this
Batching
(
true
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
RemoveObserver
(
nsINavHistoryResultObserver
*
aObserver
)
{
NS_ENSURE_ARG
(
aObserver
)
;
return
mObservers
.
RemoveWeakElement
(
aObserver
)
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
GetSuppressNotifications
(
bool
*
_retval
)
{
*
_retval
=
mSuppressNotifications
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
SetSuppressNotifications
(
bool
aSuppressNotifications
)
{
mSuppressNotifications
=
aSuppressNotifications
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
GetRoot
(
nsINavHistoryContainerResultNode
*
*
aRoot
)
{
if
(
!
mRootNode
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Root
is
null
"
)
;
*
aRoot
=
nullptr
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsNavHistoryContainerResultNode
>
node
(
mRootNode
)
;
node
.
forget
(
aRoot
)
;
return
NS_OK
;
}
void
nsNavHistoryResult
:
:
requestRefresh
(
nsNavHistoryContainerResultNode
*
aContainer
)
{
if
(
mRefreshParticipants
.
IndexOf
(
aContainer
)
=
=
ContainerObserverList
:
:
NoIndex
)
mRefreshParticipants
.
AppendElement
(
aContainer
)
;
}
#
define
ENUMERATE_BOOKMARK_FOLDER_OBSERVERS
(
_folderId
_functionCall
)
\
PR_BEGIN_MACRO
\
FolderObserverList
*
_fol
=
BookmarkFolderObserversForId
(
_folderId
false
)
;
\
if
(
_fol
)
{
\
FolderObserverList
_listCopy
(
_fol
-
>
Clone
(
)
)
;
\
for
(
uint32_t
_fol_i
=
0
;
_fol_i
<
_listCopy
.
Length
(
)
;
+
+
_fol_i
)
{
\
if
(
_listCopy
[
_fol_i
]
)
_listCopy
[
_fol_i
]
-
>
_functionCall
;
\
}
\
}
\
PR_END_MACRO
#
define
ENUMERATE_LIST_OBSERVERS
(
_listType
_functionCall
_observersList
\
_conditionCall
)
\
PR_BEGIN_MACRO
\
_listType
_listCopy
(
_observersList
.
Clone
(
)
)
;
\
for
(
uint32_t
_obs_i
=
0
;
_obs_i
<
_listCopy
.
Length
(
)
;
+
+
_obs_i
)
{
\
if
(
_listCopy
[
_obs_i
]
&
&
_listCopy
[
_obs_i
]
-
>
_conditionCall
)
\
_listCopy
[
_obs_i
]
-
>
_functionCall
;
\
}
\
PR_END_MACRO
#
define
ENUMERATE_QUERY_OBSERVERS
(
_functionCall
_observersList
\
_conditionCall
)
\
ENUMERATE_LIST_OBSERVERS
(
QueryObserverList
_functionCall
_observersList
\
_conditionCall
)
#
define
ENUMERATE_ALL_BOOKMARKS_OBSERVERS
(
_functionCall
)
\
ENUMERATE_QUERY_OBSERVERS
(
_functionCall
mAllBookmarksObservers
IsQuery
(
)
)
#
define
ENUMERATE_HISTORY_OBSERVERS
(
_functionCall
)
\
ENUMERATE_QUERY_OBSERVERS
(
_functionCall
mHistoryObservers
IsQuery
(
)
)
#
define
ENUMERATE_MOBILE_PREF_OBSERVERS
(
_functionCall
)
\
ENUMERATE_QUERY_OBSERVERS
(
_functionCall
mMobilePrefObservers
IsQuery
(
)
)
#
define
NOTIFY_REFRESH_PARTICIPANTS
(
)
\
PR_BEGIN_MACRO
\
ENUMERATE_LIST_OBSERVERS
(
ContainerObserverList
Refresh
(
)
\
mRefreshParticipants
IsContainer
(
)
)
;
\
mRefreshParticipants
.
Clear
(
)
;
\
PR_END_MACRO
NS_IMETHODIMP
nsNavHistoryResult
:
:
GetSkipTags
(
bool
*
aSkipTags
)
{
*
aSkipTags
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
OnBeginUpdateBatch
(
)
{
if
(
!
mBatchInProgress
)
{
mBatchInProgress
=
true
;
ENUMERATE_HISTORY_OBSERVERS
(
OnBeginUpdateBatch
(
)
)
;
ENUMERATE_ALL_BOOKMARKS_OBSERVERS
(
OnBeginUpdateBatch
(
)
)
;
NOTIFY_RESULT_OBSERVERS
(
this
Batching
(
true
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
OnEndUpdateBatch
(
)
{
if
(
mBatchInProgress
)
{
ENUMERATE_HISTORY_OBSERVERS
(
OnEndUpdateBatch
(
)
)
;
ENUMERATE_ALL_BOOKMARKS_OBSERVERS
(
OnEndUpdateBatch
(
)
)
;
mBatchInProgress
=
false
;
NOTIFY_REFRESH_PARTICIPANTS
(
)
;
NOTIFY_RESULT_OBSERVERS
(
this
Batching
(
false
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
OnItemChanged
(
int64_t
aItemId
const
nsACString
&
aProperty
bool
aIsAnnotationProperty
const
nsACString
&
aNewValue
PRTime
aLastModified
uint16_t
aItemType
int64_t
aParentId
const
nsACString
&
aGUID
const
nsACString
&
aParentGUID
const
nsACString
&
aOldValue
uint16_t
aSource
)
{
ENUMERATE_ALL_BOOKMARKS_OBSERVERS
(
OnItemChanged
(
aItemId
aProperty
aIsAnnotationProperty
aNewValue
aLastModified
aItemType
aParentId
aGUID
aParentGUID
aOldValue
aSource
)
)
;
FolderObserverList
*
list
=
BookmarkFolderObserversForId
(
aParentId
false
)
;
if
(
!
list
)
return
NS_OK
;
for
(
uint32_t
i
=
0
;
i
<
list
-
>
Length
(
)
;
+
+
i
)
{
RefPtr
<
nsNavHistoryFolderResultNode
>
folder
=
list
-
>
ElementAt
(
i
)
;
if
(
folder
)
{
uint32_t
nodeIndex
;
RefPtr
<
nsNavHistoryResultNode
>
node
=
folder
-
>
FindChildById
(
aItemId
&
nodeIndex
)
;
bool
excludeItems
=
folder
-
>
mOptions
-
>
ExcludeItems
(
)
;
if
(
node
&
&
(
!
excludeItems
|
|
!
(
node
-
>
IsURI
(
)
|
|
node
-
>
IsSeparator
(
)
)
)
&
&
folder
-
>
StartIncrementalUpdate
(
)
)
{
node
-
>
OnItemChanged
(
aItemId
aProperty
aIsAnnotationProperty
aNewValue
aLastModified
aItemType
aParentId
aGUID
aParentGUID
aOldValue
aSource
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
OnItemVisited
(
int64_t
aItemId
int64_t
aVisitId
PRTime
aVisitTime
uint32_t
aTransitionType
nsIURI
*
aURI
int64_t
aParentId
const
nsACString
&
aGUID
const
nsACString
&
aParentGUID
)
{
NS_ENSURE_ARG
(
aURI
)
;
ENUMERATE_BOOKMARK_FOLDER_OBSERVERS
(
aParentId
OnItemVisited
(
aItemId
aVisitId
aVisitTime
aTransitionType
aURI
aParentId
aGUID
aParentGUID
)
)
;
ENUMERATE_ALL_BOOKMARKS_OBSERVERS
(
OnItemVisited
(
aItemId
aVisitId
aVisitTime
aTransitionType
aURI
aParentId
aGUID
aParentGUID
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
OnItemMoved
(
int64_t
aItemId
int64_t
aOldParent
int32_t
aOldIndex
int64_t
aNewParent
int32_t
aNewIndex
uint16_t
aItemType
const
nsACString
&
aGUID
const
nsACString
&
aOldParentGUID
const
nsACString
&
aNewParentGUID
uint16_t
aSource
const
nsACString
&
aURI
)
{
ENUMERATE_BOOKMARK_FOLDER_OBSERVERS
(
aOldParent
OnItemMoved
(
aItemId
aOldParent
aOldIndex
aNewParent
aNewIndex
aItemType
aGUID
aOldParentGUID
aNewParentGUID
aSource
aURI
)
)
;
if
(
aNewParent
!
=
aOldParent
)
{
ENUMERATE_BOOKMARK_FOLDER_OBSERVERS
(
aNewParent
OnItemMoved
(
aItemId
aOldParent
aOldIndex
aNewParent
aNewIndex
aItemType
aGUID
aOldParentGUID
aNewParentGUID
aSource
aURI
)
)
;
}
ENUMERATE_ALL_BOOKMARKS_OBSERVERS
(
OnItemMoved
(
aItemId
aOldParent
aOldIndex
aNewParent
aNewIndex
aItemType
aGUID
aOldParentGUID
aNewParentGUID
aSource
aURI
)
)
;
ENUMERATE_HISTORY_OBSERVERS
(
OnItemMoved
(
aItemId
aOldParent
aOldIndex
aNewParent
aNewIndex
aItemType
aGUID
aOldParentGUID
aNewParentGUID
aSource
aURI
)
)
;
return
NS_OK
;
}
nsresult
nsNavHistoryResult
:
:
OnVisit
(
nsIURI
*
aURI
int64_t
aVisitId
PRTime
aTime
uint32_t
aTransitionType
const
nsACString
&
aGUID
bool
aHidden
uint32_t
aVisitCount
const
nsAString
&
aLastKnownTitle
)
{
NS_ENSURE_ARG
(
aURI
)
;
if
(
aTransitionType
=
=
nsINavHistoryService
:
:
TRANSITION_EMBED
)
{
return
NS_OK
;
}
uint32_t
added
=
0
;
ENUMERATE_HISTORY_OBSERVERS
(
OnVisit
(
aURI
aVisitId
aTime
aTransitionType
aHidden
&
added
)
)
;
if
(
!
aLastKnownTitle
.
IsVoid
(
)
&
&
aVisitCount
=
=
1
)
{
ENUMERATE_HISTORY_OBSERVERS
(
OnTitleChanged
(
aURI
aLastKnownTitle
aGUID
)
)
;
}
if
(
!
mRootNode
-
>
mExpanded
)
return
NS_OK
;
bool
todayIsMissing
=
false
;
uint32_t
resultType
=
mRootNode
-
>
mOptions
-
>
ResultType
(
)
;
if
(
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_DATE_QUERY
|
|
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_DATE_SITE_QUERY
)
{
uint32_t
childCount
;
nsresult
rv
=
mRootNode
-
>
GetChildCount
(
&
childCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
childCount
)
{
nsCOMPtr
<
nsINavHistoryResultNode
>
firstChild
;
rv
=
mRootNode
-
>
GetChild
(
0
getter_AddRefs
(
firstChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
title
;
rv
=
firstChild
-
>
GetTitle
(
title
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsNavHistory
*
history
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
history
NS_OK
)
;
nsAutoCString
todayLabel
;
history
-
>
GetStringFromName
(
"
finduri
-
AgeInDays
-
is
-
0
"
todayLabel
)
;
todayIsMissing
=
!
todayLabel
.
Equals
(
title
)
;
}
}
if
(
!
added
|
|
todayIsMissing
)
{
uint32_t
resultType
=
mRootNode
-
>
mOptions
-
>
ResultType
(
)
;
if
(
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_DATE_QUERY
|
|
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_DATE_SITE_QUERY
)
{
int64_t
beginOfToday
=
nsNavHistory
:
:
NormalizeTime
(
nsINavHistoryQuery
:
:
TIME_RELATIVE_TODAY
0
)
;
if
(
todayIsMissing
|
|
aTime
<
beginOfToday
)
{
(
void
)
mRootNode
-
>
GetAsQuery
(
)
-
>
Refresh
(
)
;
}
return
NS_OK
;
}
if
(
resultType
=
=
nsINavHistoryQueryOptions
:
:
RESULTS_AS_SITE_QUERY
)
{
(
void
)
mRootNode
-
>
GetAsQuery
(
)
-
>
Refresh
(
)
;
return
NS_OK
;
}
ENUMERATE_QUERY_OBSERVERS
(
Refresh
(
)
mHistoryObservers
IsContainersQuery
(
)
)
;
}
return
NS_OK
;
}
void
nsNavHistoryResult
:
:
HandlePlacesEvent
(
const
PlacesEventSequence
&
aEvents
)
{
for
(
const
auto
&
event
:
aEvents
)
{
switch
(
event
-
>
Type
(
)
)
{
case
PlacesEventType
:
:
Page_visited
:
{
const
dom
:
:
PlacesVisit
*
visit
=
event
-
>
AsPlacesVisit
(
)
;
if
(
NS_WARN_IF
(
!
visit
)
)
{
continue
;
}
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
uri
)
visit
-
>
mUrl
)
)
;
if
(
!
uri
)
{
continue
;
}
OnVisit
(
uri
visit
-
>
mVisitId
visit
-
>
mVisitTime
*
1000
visit
-
>
mTransitionType
visit
-
>
mPageGuid
visit
-
>
mHidden
visit
-
>
mVisitCount
visit
-
>
mLastKnownTitle
)
;
break
;
}
case
PlacesEventType
:
:
Bookmark_added
:
{
const
dom
:
:
PlacesBookmarkAddition
*
item
=
event
-
>
AsPlacesBookmarkAddition
(
)
;
if
(
NS_WARN_IF
(
!
item
)
)
{
continue
;
}
nsCOMPtr
<
nsIURI
>
uri
;
if
(
item
-
>
mItemType
=
=
nsINavBookmarksService
:
:
TYPE_BOOKMARK
)
{
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
uri
)
item
-
>
mUrl
)
)
;
if
(
!
uri
)
{
continue
;
}
}
ENUMERATE_BOOKMARK_FOLDER_OBSERVERS
(
item
-
>
mParentId
OnItemAdded
(
item
-
>
mId
item
-
>
mParentId
item
-
>
mIndex
item
-
>
mItemType
uri
item
-
>
mDateAdded
*
1000
item
-
>
mGuid
item
-
>
mParentGuid
item
-
>
mSource
)
)
;
ENUMERATE_HISTORY_OBSERVERS
(
OnItemAdded
(
item
-
>
mId
item
-
>
mParentId
item
-
>
mIndex
item
-
>
mItemType
uri
item
-
>
mDateAdded
*
1000
item
-
>
mGuid
item
-
>
mParentGuid
item
-
>
mSource
)
)
;
ENUMERATE_ALL_BOOKMARKS_OBSERVERS
(
OnItemAdded
(
item
-
>
mId
item
-
>
mParentId
item
-
>
mIndex
item
-
>
mItemType
uri
item
-
>
mDateAdded
*
1000
item
-
>
mGuid
item
-
>
mParentGuid
item
-
>
mSource
)
)
;
break
;
}
case
PlacesEventType
:
:
Bookmark_removed
:
{
const
dom
:
:
PlacesBookmarkRemoved
*
item
=
event
-
>
AsPlacesBookmarkRemoved
(
)
;
if
(
NS_WARN_IF
(
!
item
)
)
{
continue
;
}
nsCOMPtr
<
nsIURI
>
uri
;
if
(
item
-
>
mIsDescendantRemoval
)
{
continue
;
}
ENUMERATE_BOOKMARK_FOLDER_OBSERVERS
(
item
-
>
mParentId
OnItemRemoved
(
item
-
>
mId
item
-
>
mParentId
item
-
>
mIndex
item
-
>
mItemType
uri
item
-
>
mGuid
item
-
>
mParentGuid
item
-
>
mSource
)
)
;
ENUMERATE_ALL_BOOKMARKS_OBSERVERS
(
OnItemRemoved
(
item
-
>
mId
item
-
>
mParentId
item
-
>
mIndex
item
-
>
mItemType
uri
item
-
>
mGuid
item
-
>
mParentGuid
item
-
>
mSource
)
)
;
ENUMERATE_HISTORY_OBSERVERS
(
OnItemRemoved
(
item
-
>
mId
item
-
>
mParentId
item
-
>
mIndex
item
-
>
mItemType
uri
item
-
>
mGuid
item
-
>
mParentGuid
item
-
>
mSource
)
)
;
break
;
}
default
:
{
MOZ_ASSERT_UNREACHABLE
(
"
Receive
notification
of
a
type
not
subscribed
to
.
"
)
;
}
}
}
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
OnTitleChanged
(
nsIURI
*
aURI
const
nsAString
&
aPageTitle
const
nsACString
&
aGUID
)
{
NS_ENSURE_ARG
(
aURI
)
;
ENUMERATE_HISTORY_OBSERVERS
(
OnTitleChanged
(
aURI
aPageTitle
aGUID
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
OnFrecencyChanged
(
nsIURI
*
aURI
int32_t
aNewFrecency
const
nsACString
&
aGUID
bool
aHidden
PRTime
aLastVisitDate
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
OnManyFrecenciesChanged
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
OnDeleteURI
(
nsIURI
*
aURI
const
nsACString
&
aGUID
uint16_t
aReason
)
{
NS_ENSURE_ARG
(
aURI
)
;
ENUMERATE_HISTORY_OBSERVERS
(
OnDeleteURI
(
aURI
aGUID
aReason
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
OnClearHistory
(
)
{
ENUMERATE_HISTORY_OBSERVERS
(
OnClearHistory
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
OnPageChanged
(
nsIURI
*
aURI
uint32_t
aChangedAttribute
const
nsAString
&
aValue
const
nsACString
&
aGUID
)
{
NS_ENSURE_ARG
(
aURI
)
;
ENUMERATE_HISTORY_OBSERVERS
(
OnPageChanged
(
aURI
aChangedAttribute
aValue
aGUID
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNavHistoryResult
:
:
OnDeleteVisits
(
nsIURI
*
aURI
bool
aPartialRemoval
const
nsACString
&
aGUID
uint16_t
aReason
uint32_t
aTransitionType
)
{
NS_ENSURE_ARG
(
aURI
)
;
ENUMERATE_HISTORY_OBSERVERS
(
OnDeleteVisits
(
aURI
aPartialRemoval
aGUID
aReason
aTransitionType
)
)
;
return
NS_OK
;
}
void
nsNavHistoryResult
:
:
OnMobilePrefChanged
(
)
{
ENUMERATE_MOBILE_PREF_OBSERVERS
(
OnMobilePrefChanged
(
Preferences
:
:
GetBool
(
MOBILE_BOOKMARKS_PREF
false
)
)
)
;
}
void
nsNavHistoryResult
:
:
OnMobilePrefChangedCallback
(
const
char
*
prefName
void
*
self
)
{
MOZ_ASSERT
(
!
strcmp
(
prefName
MOBILE_BOOKMARKS_PREF
)
"
We
only
expected
Mobile
Bookmarks
pref
change
.
"
)
;
static_cast
<
nsNavHistoryResult
*
>
(
self
)
-
>
OnMobilePrefChanged
(
)
;
}
