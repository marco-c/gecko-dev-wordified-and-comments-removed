"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SyncedBookmarksMirror
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Async
:
"
resource
:
/
/
services
-
common
/
async
.
js
"
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
PlacesSyncUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
MirrorLog
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Sync
.
Engine
.
Bookmarks
.
Mirror
"
)
)
;
const
SyncedBookmarksMerger
=
Components
.
Constructor
(
"
mozilla
.
org
/
browser
/
synced
-
bookmarks
-
merger
;
1
"
"
mozISyncedBookmarksMerger
"
)
;
const
DB_URL_LENGTH_MAX
=
65536
;
const
DB_TITLE_LENGTH_MAX
=
4096
;
const
MIRROR_SCHEMA_VERSION
=
7
;
const
DEFAULT_MAX_FRECENCIES_TO_RECALCULATE
=
400
;
XPCOMUtils
.
defineLazyGetter
(
this
"
yieldState
"
(
)
=
>
Async
.
yieldState
(
)
)
;
class
MirrorLoggerAdapter
{
constructor
(
log
)
{
this
.
log
=
log
;
}
get
maxLevel
(
)
{
let
level
=
this
.
log
.
level
;
if
(
level
<
=
Log
.
Level
.
All
)
{
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_TRACE
;
}
if
(
level
<
=
Log
.
Level
.
Info
)
{
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_DEBUG
;
}
if
(
level
<
=
Log
.
Level
.
Warn
)
{
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_WARN
;
}
if
(
level
<
=
Log
.
Level
.
Error
)
{
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_ERROR
;
}
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_OFF
;
}
trace
(
message
)
{
this
.
log
.
trace
(
message
)
;
}
debug
(
message
)
{
this
.
log
.
debug
(
message
)
;
}
warn
(
message
)
{
this
.
log
.
warn
(
message
)
;
}
error
(
message
)
{
this
.
log
.
error
(
message
)
;
}
}
class
ProgressTracker
{
constructor
(
recordStepTelemetry
)
{
this
.
recordStepTelemetry
=
recordStepTelemetry
;
this
.
steps
=
[
]
;
}
step
(
name
took
=
-
1
counts
=
null
)
{
let
info
=
{
step
:
name
at
:
Date
.
now
(
)
}
;
if
(
took
>
-
1
)
{
info
.
took
=
took
;
}
if
(
counts
)
{
info
.
counts
=
counts
;
}
this
.
steps
.
push
(
info
)
;
}
stepWithTelemetry
(
name
took
counts
=
null
)
{
this
.
step
(
name
took
counts
)
;
this
.
recordStepTelemetry
(
name
took
counts
)
;
}
stepWithItemCount
(
name
took
count
)
{
this
.
stepWithTelemetry
(
name
took
[
{
name
:
"
items
"
count
}
]
)
;
}
reset
(
)
{
this
.
steps
=
[
]
;
}
fetchState
(
)
{
return
{
steps
:
this
.
steps
}
;
}
}
ProgressTracker
.
STEPS
=
{
FETCH_LOCAL_TREE
:
"
fetchLocalTree
"
FETCH_REMOTE_TREE
:
"
fetchRemoteTree
"
MERGE
:
"
merge
"
APPLY
:
"
apply
"
NOTIFY_OBSERVERS
:
"
notifyObservers
"
FETCH_LOCAL_CHANGE_RECORDS
:
"
fetchLocalChangeRecords
"
FINALIZE
:
"
finalize
"
}
;
class
SyncedBookmarksMirror
{
constructor
(
db
wasCorrupt
=
false
{
recordStepTelemetry
recordValidationTelemetry
finalizeAt
=
PlacesUtils
.
history
.
shutdownClient
.
jsclient
}
=
{
}
)
{
this
.
db
=
db
;
this
.
wasCorrupt
=
wasCorrupt
;
this
.
recordValidationTelemetry
=
recordValidationTelemetry
;
this
.
merger
=
new
SyncedBookmarksMerger
(
)
;
this
.
merger
.
db
=
db
.
unsafeRawConnection
.
QueryInterface
(
Ci
.
mozIStorageConnection
)
;
this
.
merger
.
logger
=
new
MirrorLoggerAdapter
(
MirrorLog
)
;
this
.
progress
=
new
ProgressTracker
(
recordStepTelemetry
)
;
this
.
finalizeController
=
new
AbortController
(
)
;
this
.
finalizeAt
=
finalizeAt
;
this
.
finalizeBound
=
(
)
=
>
this
.
finalize
(
{
alsoCleanup
:
false
}
)
;
this
.
finalizeAt
.
addBlocker
(
"
SyncedBookmarksMirror
:
finalize
"
this
.
finalizeBound
{
fetchState
:
(
)
=
>
this
.
progress
}
)
;
}
static
async
open
(
options
)
{
let
db
=
await
PlacesUtils
.
promiseUnsafeWritableDBConnection
(
)
;
if
(
!
db
)
{
throw
new
TypeError
(
"
Can
'
t
open
mirror
without
Places
connection
"
)
;
}
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
options
.
path
)
;
let
wasCorrupt
=
false
;
try
{
await
attachAndInitMirrorDatabase
(
db
path
)
;
}
catch
(
ex
)
{
if
(
isDatabaseCorrupt
(
ex
)
)
{
MirrorLog
.
warn
(
"
Error
attaching
mirror
to
Places
;
removing
and
"
+
"
recreating
mirror
"
ex
)
;
wasCorrupt
=
true
;
await
OS
.
File
.
remove
(
path
)
;
await
attachAndInitMirrorDatabase
(
db
path
)
;
}
else
{
MirrorLog
.
error
(
"
Unrecoverable
error
attaching
mirror
to
Places
"
ex
)
;
throw
ex
;
}
}
return
new
SyncedBookmarksMirror
(
db
wasCorrupt
options
)
;
}
async
getCollectionHighWaterMark
(
)
{
let
rows
=
await
this
.
db
.
executeCached
(
SELECT
MAX
(
IFNULL
(
(
SELECT
MAX
(
serverModified
)
-
1000
FROM
items
)
0
)
IFNULL
(
(
SELECT
CAST
(
value
AS
INTEGER
)
FROM
meta
WHERE
key
=
:
modifiedKey
)
0
)
)
AS
highWaterMark
{
modifiedKey
:
SyncedBookmarksMirror
.
META_KEY
.
LAST_MODIFIED
}
)
;
let
highWaterMark
=
rows
[
0
]
.
getResultByName
(
"
highWaterMark
"
)
;
return
highWaterMark
/
1000
;
}
async
setCollectionLastModified
(
lastModifiedSeconds
)
{
let
lastModified
=
Math
.
floor
(
lastModifiedSeconds
*
1000
)
;
if
(
!
Number
.
isInteger
(
lastModified
)
)
{
throw
new
TypeError
(
"
Invalid
collection
last
modified
time
"
)
;
}
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
setCollectionLastModified
"
db
=
>
db
.
executeCached
(
REPLACE
INTO
meta
(
key
value
)
VALUES
(
:
modifiedKey
:
lastModified
)
{
modifiedKey
:
SyncedBookmarksMirror
.
META_KEY
.
LAST_MODIFIED
lastModified
}
)
)
;
}
async
getSyncId
(
)
{
let
rows
=
await
this
.
db
.
executeCached
(
SELECT
value
FROM
meta
WHERE
key
=
:
syncIdKey
{
syncIdKey
:
SyncedBookmarksMirror
.
META_KEY
.
SYNC_ID
}
)
;
return
rows
.
length
?
rows
[
0
]
.
getResultByName
(
"
value
"
)
:
"
"
;
}
async
ensureCurrentSyncId
(
newSyncId
)
{
if
(
!
newSyncId
|
|
typeof
newSyncId
!
=
"
string
"
)
{
throw
new
TypeError
(
"
Invalid
new
bookmarks
sync
ID
"
)
;
}
let
existingSyncId
=
await
this
.
getSyncId
(
)
;
if
(
existingSyncId
=
=
newSyncId
)
{
MirrorLog
.
trace
(
"
Sync
ID
up
-
to
-
date
in
mirror
"
{
existingSyncId
}
)
;
return
;
}
MirrorLog
.
info
(
"
Sync
ID
changed
from
{
existingSyncId
}
to
"
+
"
{
newSyncId
}
;
resetting
mirror
"
{
existingSyncId
newSyncId
}
)
;
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
ensureCurrentSyncId
"
db
=
>
db
.
executeTransaction
(
async
function
(
)
{
await
resetMirror
(
db
)
;
await
db
.
execute
(
REPLACE
INTO
meta
(
key
value
)
VALUES
(
:
syncIdKey
:
newSyncId
)
{
syncIdKey
:
SyncedBookmarksMirror
.
META_KEY
.
SYNC_ID
newSyncId
}
)
;
}
)
)
;
}
async
store
(
records
{
needsMerge
=
true
signal
=
null
}
=
{
}
)
{
let
options
=
{
needsMerge
signal
:
anyAborted
(
this
.
finalizeController
.
signal
signal
)
}
;
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
store
"
db
=
>
db
.
executeTransaction
(
async
(
)
=
>
{
for
(
let
record
of
records
)
{
if
(
options
.
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
while
storing
incoming
items
"
)
;
}
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
if
(
guid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
)
{
throw
new
TypeError
(
"
Can
'
t
store
Places
root
"
)
;
}
if
(
MirrorLog
.
level
<
=
Log
.
Level
.
Trace
)
{
MirrorLog
.
trace
(
Storing
in
mirror
:
{
record
.
cleartextToString
(
)
}
)
;
}
switch
(
record
.
type
)
{
case
"
bookmark
"
:
await
this
.
storeRemoteBookmark
(
record
options
)
;
continue
;
case
"
query
"
:
await
this
.
storeRemoteQuery
(
record
options
)
;
continue
;
case
"
folder
"
:
await
this
.
storeRemoteFolder
(
record
options
)
;
continue
;
case
"
livemark
"
:
await
this
.
storeRemoteLivemark
(
record
options
)
;
continue
;
case
"
separator
"
:
await
this
.
storeRemoteSeparator
(
record
options
)
;
continue
;
default
:
if
(
record
.
deleted
)
{
await
this
.
storeRemoteTombstone
(
record
options
)
;
continue
;
}
}
MirrorLog
.
warn
(
"
Ignoring
record
with
unknown
type
"
record
.
type
)
;
}
}
)
)
;
}
async
apply
(
{
localTimeSeconds
remoteTimeSeconds
weakUpload
maxFrecenciesToRecalculate
notifyInStableOrder
signal
=
null
}
=
{
}
)
{
let
finalizeOrInterruptSignal
=
anyAborted
(
this
.
finalizeController
.
signal
signal
)
;
let
changeRecords
;
try
{
changeRecords
=
await
this
.
tryApply
(
finalizeOrInterruptSignal
localTimeSeconds
remoteTimeSeconds
weakUpload
maxFrecenciesToRecalculate
notifyInStableOrder
)
;
}
finally
{
this
.
progress
.
reset
(
)
;
}
return
changeRecords
;
}
async
tryApply
(
signal
localTimeSeconds
remoteTimeSeconds
weakUpload
maxFrecenciesToRecalculate
=
DEFAULT_MAX_FRECENCIES_TO_RECALCULATE
notifyInStableOrder
=
false
)
{
let
wasMerged
=
await
withTiming
(
"
Merging
bookmarks
in
Rust
"
(
)
=
>
this
.
merge
(
signal
localTimeSeconds
remoteTimeSeconds
weakUpload
)
)
;
if
(
!
wasMerged
)
{
MirrorLog
.
debug
(
"
No
changes
detected
in
both
mirror
and
Places
"
)
;
await
updateFrecencies
(
this
.
db
maxFrecenciesToRecalculate
)
;
return
{
}
;
}
let
observersToNotify
=
new
BookmarkObserverRecorder
(
this
.
db
{
maxFrecenciesToRecalculate
signal
notifyInStableOrder
}
)
;
await
withTiming
(
"
Notifying
Places
observers
"
async
(
)
=
>
{
try
{
await
observersToNotify
.
notifyAll
(
)
;
}
catch
(
ex
)
{
PlacesUtils
.
invalidateCachedGuids
(
)
;
await
PlacesUtils
.
keywords
.
invalidateCachedKeywords
(
)
;
MirrorLog
.
warn
(
"
Error
notifying
Places
observers
"
ex
)
;
}
finally
{
await
this
.
db
.
executeTransaction
(
async
(
)
=
>
{
await
this
.
db
.
execute
(
DELETE
FROM
itemsAdded
)
;
await
this
.
db
.
execute
(
DELETE
FROM
guidsChanged
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsChanged
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsRemoved
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsMoved
)
;
}
)
;
}
}
time
=
>
this
.
progress
.
stepWithTelemetry
(
ProgressTracker
.
STEPS
.
NOTIFY_OBSERVERS
time
)
)
;
let
{
changeRecords
}
=
await
withTiming
(
"
Fetching
records
for
local
items
to
upload
"
async
(
)
=
>
{
try
{
let
result
=
await
this
.
fetchLocalChangeRecords
(
signal
)
;
return
result
;
}
finally
{
await
this
.
db
.
execute
(
DELETE
FROM
itemsToUpload
)
;
}
}
(
time
result
)
=
>
this
.
progress
.
stepWithItemCount
(
ProgressTracker
.
STEPS
.
FETCH_LOCAL_CHANGE_RECORDS
time
result
.
count
)
)
;
return
changeRecords
;
}
merge
(
signal
localTimeSeconds
=
Date
.
now
(
)
/
1000
remoteTimeSeconds
=
0
weakUpload
=
[
]
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
op
=
null
;
function
onAbort
(
)
{
signal
.
removeEventListener
(
"
abort
"
onAbort
)
;
op
.
cancel
(
)
;
}
let
callback
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
mozISyncedBookmarksMirrorProgressListener
Ci
.
mozISyncedBookmarksMirrorCallback
]
)
onFetchLocalTree
:
(
took
itemCount
deleteCount
problemsBag
)
=
>
{
let
counts
=
[
{
name
:
"
items
"
count
:
itemCount
}
{
name
:
"
deletions
"
count
:
deleteCount
}
]
;
this
.
progress
.
stepWithTelemetry
(
ProgressTracker
.
STEPS
.
FETCH_LOCAL_TREE
took
counts
)
;
}
onFetchRemoteTree
:
(
took
itemCount
deleteCount
problemsBag
)
=
>
{
let
counts
=
[
{
name
:
"
items
"
count
:
itemCount
}
{
name
:
"
deletions
"
count
:
deleteCount
}
]
;
this
.
progress
.
stepWithTelemetry
(
ProgressTracker
.
STEPS
.
FETCH_REMOTE_TREE
took
counts
)
;
let
problems
=
bagToNamedCounts
(
problemsBag
[
"
orphans
"
"
misparentedRoots
"
"
multipleParents
"
"
nonFolderParents
"
"
parentChildDisagreements
"
"
missingChildren
"
]
)
;
let
checked
=
itemCount
+
deleteCount
;
this
.
recordValidationTelemetry
(
took
checked
problems
)
;
}
onMerge
:
(
took
countsBag
)
=
>
{
let
counts
=
bagToNamedCounts
(
countsBag
[
"
items
"
"
dupes
"
"
remoteRevives
"
"
localDeletes
"
"
localRevives
"
"
remoteDeletes
"
]
)
;
this
.
progress
.
stepWithTelemetry
(
ProgressTracker
.
STEPS
.
MERGE
took
counts
)
;
}
onApply
:
took
=
>
{
this
.
progress
.
stepWithTelemetry
(
ProgressTracker
.
STEPS
.
APPLY
took
)
;
}
handleSuccess
(
result
)
{
signal
.
removeEventListener
(
"
abort
"
onAbort
)
;
resolve
(
result
)
;
}
handleError
(
code
message
)
{
signal
.
removeEventListener
(
"
abort
"
onAbort
)
;
switch
(
code
)
{
case
Cr
.
NS_ERROR_STORAGE_BUSY
:
reject
(
new
SyncedBookmarksMirror
.
MergeConflictError
(
"
Local
tree
changed
during
merge
"
)
)
;
break
;
case
Cr
.
NS_ERROR_ABORT
:
reject
(
new
SyncedBookmarksMirror
.
InterruptedError
(
message
)
)
;
break
;
default
:
reject
(
new
SyncedBookmarksMirror
.
MergeError
(
message
)
)
;
}
}
}
;
op
=
this
.
merger
.
merge
(
localTimeSeconds
remoteTimeSeconds
weakUpload
callback
)
;
if
(
signal
.
aborted
)
{
op
.
cancel
(
)
;
}
else
{
signal
.
addEventListener
(
"
abort
"
onAbort
)
;
}
}
)
;
}
async
reset
(
)
{
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
reset
"
db
=
>
db
.
executeTransaction
(
(
)
=
>
resetMirror
(
db
)
)
)
;
}
async
fetchUnmergedGuids
(
)
{
let
rows
=
await
this
.
db
.
execute
(
SELECT
guid
FROM
items
WHERE
needsMerge
ORDER
BY
guid
)
;
return
rows
.
map
(
row
=
>
row
.
getResultByName
(
"
guid
"
)
)
;
}
async
storeRemoteBookmark
(
record
{
needsMerge
signal
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
url
=
validateURL
(
record
.
bmkUri
)
;
if
(
url
)
{
await
this
.
maybeStoreRemoteURL
(
url
)
;
}
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
keyword
=
validateKeyword
(
record
.
keyword
)
;
let
validity
=
url
?
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_VALID
:
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REPLACE
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
title
keyword
validity
urlId
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
'
'
)
:
keyword
:
validity
(
SELECT
id
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_BOOKMARK
dateAdded
title
keyword
url
:
url
?
url
.
href
:
null
validity
}
)
;
let
tags
=
record
.
tags
;
if
(
tags
&
&
Array
.
isArray
(
tags
)
)
{
for
(
let
rawTag
of
tags
)
{
if
(
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
while
storing
tags
for
incoming
bookmark
"
)
;
}
let
tag
=
validateTag
(
rawTag
)
;
if
(
!
tag
)
{
continue
;
}
await
this
.
db
.
executeCached
(
INSERT
INTO
tags
(
itemId
tag
)
SELECT
id
:
tag
FROM
items
WHERE
guid
=
:
guid
{
tag
guid
}
)
;
}
}
}
async
storeRemoteQuery
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_VALID
;
let
url
=
validateURL
(
record
.
bmkUri
)
;
if
(
url
)
{
let
params
=
new
URLSearchParams
(
url
.
href
.
slice
(
url
.
protocol
.
length
)
)
;
let
type
=
+
params
.
get
(
"
type
"
)
;
if
(
type
=
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAG_CONTENTS
)
{
let
tagFolderName
=
validateTag
(
record
.
folderName
)
;
if
(
tagFolderName
)
{
try
{
url
.
href
=
place
:
tag
=
{
tagFolderName
}
;
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REUPLOAD
;
}
catch
(
ex
)
{
url
=
null
;
}
}
else
{
url
=
null
;
}
}
else
{
let
folder
=
params
.
get
(
"
folder
"
)
;
if
(
folder
&
&
!
params
.
has
(
"
excludeItems
"
)
)
{
try
{
url
.
href
=
{
url
.
href
}
&
excludeItems
=
1
;
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REUPLOAD
;
}
catch
(
ex
)
{
url
=
null
;
}
}
}
}
if
(
url
)
{
await
this
.
maybeStoreRemoteURL
(
url
)
;
}
else
{
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REPLACE
;
}
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
title
urlId
validity
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
'
'
)
(
SELECT
id
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
:
validity
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_QUERY
dateAdded
title
url
:
url
?
url
.
href
:
null
validity
}
)
;
}
async
storeRemoteFolder
(
record
{
needsMerge
signal
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
title
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
'
'
)
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_FOLDER
dateAdded
title
}
)
;
let
children
=
record
.
children
;
if
(
children
&
&
Array
.
isArray
(
children
)
)
{
let
offset
=
0
;
for
(
let
chunk
of
PlacesUtils
.
chunkArray
(
children
this
.
db
.
variableLimit
-
1
)
)
{
if
(
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
while
storing
children
for
incoming
folder
"
)
;
}
let
valuesFragment
=
Array
.
from
(
{
length
:
chunk
.
length
}
(
_
index
)
=
>
(
?
{
index
+
2
}
?
1
{
offset
+
index
}
)
)
.
join
(
"
"
)
;
await
this
.
db
.
execute
(
INSERT
INTO
structure
(
guid
parentGuid
position
)
VALUES
{
valuesFragment
}
[
guid
.
.
.
chunk
.
map
(
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
)
]
)
;
offset
+
=
chunk
.
length
;
}
}
}
async
storeRemoteLivemark
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
feedURL
=
validateURL
(
record
.
feedUri
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
siteURL
=
validateURL
(
record
.
siteUri
)
;
let
validity
=
feedURL
?
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_VALID
:
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REPLACE
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
title
feedURL
siteURL
validity
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
'
'
)
:
feedURL
:
siteURL
:
validity
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_LIVEMARK
dateAdded
title
feedURL
:
feedURL
?
feedURL
.
href
:
null
siteURL
:
siteURL
?
siteURL
.
href
:
null
validity
}
)
;
}
async
storeRemoteSeparator
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_SEPARATOR
dateAdded
}
)
;
}
async
storeRemoteTombstone
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
serverModified
=
determineServerModified
(
record
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
isDeleted
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
1
)
{
guid
serverModified
needsMerge
}
)
;
}
async
maybeStoreRemoteURL
(
url
)
{
await
this
.
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
urls
(
guid
url
hash
revHost
)
VALUES
(
IFNULL
(
(
SELECT
guid
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
GENERATE_GUID
(
)
)
:
url
hash
(
:
url
)
:
revHost
)
{
url
:
url
.
href
revHost
:
PlacesUtils
.
getReversedHost
(
url
)
}
)
;
}
async
fetchLocalChangeRecords
(
signal
)
{
let
changeRecords
=
{
}
;
let
childRecordIdsByLocalParentId
=
new
Map
(
)
;
let
tagsByLocalId
=
new
Map
(
)
;
let
childGuidRows
=
[
]
;
await
this
.
db
.
execute
(
SELECT
parentId
guid
FROM
structureToUpload
ORDER
BY
parentId
position
null
(
row
cancel
)
=
>
{
if
(
signal
.
aborted
)
{
cancel
(
)
;
}
else
{
childGuidRows
.
push
(
row
)
;
}
}
)
;
await
Async
.
yieldingForEach
(
childGuidRows
row
=
>
{
if
(
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
while
fetching
structure
to
upload
"
)
;
}
let
localParentId
=
row
.
getResultByName
(
"
parentId
"
)
;
let
childRecordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
row
.
getResultByName
(
"
guid
"
)
)
;
let
childRecordIds
=
childRecordIdsByLocalParentId
.
get
(
localParentId
)
;
if
(
childRecordIds
)
{
childRecordIds
.
push
(
childRecordId
)
;
}
else
{
childRecordIdsByLocalParentId
.
set
(
localParentId
[
childRecordId
]
)
;
}
}
yieldState
)
;
let
tagRows
=
[
]
;
await
this
.
db
.
execute
(
SELECT
id
tag
FROM
tagsToUpload
null
(
row
cancel
)
=
>
{
if
(
signal
.
aborted
)
{
cancel
(
)
;
}
else
{
tagRows
.
push
(
row
)
;
}
}
)
;
await
Async
.
yieldingForEach
(
tagRows
row
=
>
{
if
(
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
while
fetching
tags
to
upload
"
)
;
}
let
localId
=
row
.
getResultByName
(
"
id
"
)
;
let
tag
=
row
.
getResultByName
(
"
tag
"
)
;
let
tags
=
tagsByLocalId
.
get
(
localId
)
;
if
(
tags
)
{
tags
.
push
(
tag
)
;
}
else
{
tagsByLocalId
.
set
(
localId
[
tag
]
)
;
}
}
yieldState
)
;
let
itemRows
=
[
]
;
await
this
.
db
.
execute
(
SELECT
id
syncChangeCounter
guid
isDeleted
type
isQuery
tagFolderName
keyword
url
IFNULL
(
title
'
'
)
AS
title
position
parentGuid
IFNULL
(
parentTitle
'
'
)
AS
parentTitle
dateAdded
FROM
itemsToUpload
null
(
row
cancel
)
=
>
{
if
(
signal
.
interrupted
)
{
cancel
(
)
;
}
else
{
itemRows
.
push
(
row
)
;
}
}
)
;
await
Async
.
yieldingForEach
(
itemRows
row
=
>
{
if
(
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
while
fetching
items
to
upload
"
)
;
}
let
syncChangeCounter
=
row
.
getResultByName
(
"
syncChangeCounter
"
)
;
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
recordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
guid
)
;
let
isDeleted
=
row
.
getResultByName
(
"
isDeleted
"
)
;
if
(
isDeleted
)
{
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
{
id
:
recordId
deleted
:
true
}
)
;
return
;
}
let
parentGuid
=
row
.
getResultByName
(
"
parentGuid
"
)
;
let
parentRecordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
parentGuid
)
;
let
type
=
row
.
getResultByName
(
"
type
"
)
;
switch
(
type
)
{
case
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
:
{
let
isQuery
=
row
.
getResultByName
(
"
isQuery
"
)
;
if
(
isQuery
)
{
let
queryCleartext
=
{
id
:
recordId
type
:
"
query
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
bmkUri
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
folderName
:
row
.
getResultByName
(
"
tagFolderName
"
)
|
|
undefined
}
;
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
queryCleartext
)
;
return
;
}
let
bookmarkCleartext
=
{
id
:
recordId
type
:
"
bookmark
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
bmkUri
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
}
;
let
keyword
=
row
.
getResultByName
(
"
keyword
"
)
;
if
(
keyword
)
{
bookmarkCleartext
.
keyword
=
keyword
;
}
let
localId
=
row
.
getResultByName
(
"
id
"
)
;
let
tags
=
tagsByLocalId
.
get
(
localId
)
;
if
(
tags
)
{
bookmarkCleartext
.
tags
=
tags
;
}
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
bookmarkCleartext
)
;
return
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
:
{
let
folderCleartext
=
{
id
:
recordId
type
:
"
folder
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
title
:
row
.
getResultByName
(
"
title
"
)
}
;
let
localId
=
row
.
getResultByName
(
"
id
"
)
;
let
childRecordIds
=
childRecordIdsByLocalParentId
.
get
(
localId
)
;
folderCleartext
.
children
=
childRecordIds
|
|
[
]
;
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
folderCleartext
)
;
return
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
:
{
let
separatorCleartext
=
{
id
:
recordId
type
:
"
separator
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
pos
:
row
.
getResultByName
(
"
position
"
)
}
;
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
separatorCleartext
)
;
return
;
}
default
:
throw
new
TypeError
(
"
Can
'
t
create
record
for
unknown
Places
item
"
)
;
}
}
yieldState
)
;
return
{
changeRecords
count
:
itemRows
.
length
}
;
}
finalize
(
{
alsoCleanup
=
true
}
=
{
}
)
{
if
(
!
this
.
finalizePromise
)
{
this
.
finalizePromise
=
(
async
(
)
=
>
{
this
.
progress
.
step
(
ProgressTracker
.
STEPS
.
FINALIZE
)
;
this
.
finalizeController
.
abort
(
)
;
this
.
merger
.
reset
(
)
;
if
(
alsoCleanup
)
{
await
cleanupMirrorDatabase
(
this
.
db
)
;
}
await
this
.
db
.
execute
(
PRAGMA
mirror
.
optimize
(
0x02
)
)
;
await
this
.
db
.
execute
(
DETACH
mirror
)
;
this
.
finalizeAt
.
removeBlocker
(
this
.
finalizeBound
)
;
}
)
(
)
;
}
return
this
.
finalizePromise
;
}
}
this
.
SyncedBookmarksMirror
=
SyncedBookmarksMirror
;
SyncedBookmarksMirror
.
META_KEY
=
{
LAST_MODIFIED
:
"
collection
/
lastModified
"
SYNC_ID
:
"
collection
/
syncId
"
}
;
class
InterruptedError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
InterruptedError
"
;
}
}
SyncedBookmarksMirror
.
InterruptedError
=
InterruptedError
;
class
MergeError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
MergeError
"
;
}
}
SyncedBookmarksMirror
.
MergeError
=
MergeError
;
class
MergeConflictError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
MergeConflictError
"
;
}
}
SyncedBookmarksMirror
.
MergeConflictError
=
MergeConflictError
;
class
DatabaseCorruptError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
DatabaseCorruptError
"
;
}
}
function
isDatabaseCorrupt
(
error
)
{
if
(
error
instanceof
DatabaseCorruptError
)
{
return
true
;
}
if
(
error
.
errors
)
{
return
error
.
errors
.
some
(
error
=
>
error
instanceof
Ci
.
mozIStorageError
&
&
(
error
.
result
=
=
Ci
.
mozIStorageError
.
CORRUPT
|
|
error
.
result
=
=
Ci
.
mozIStorageError
.
NOTADB
)
)
;
}
return
false
;
}
async
function
attachAndInitMirrorDatabase
(
db
path
)
{
await
db
.
execute
(
ATTACH
:
path
AS
mirror
{
path
}
)
;
try
{
await
db
.
executeTransaction
(
async
function
(
)
{
let
currentSchemaVersion
=
await
db
.
getSchemaVersion
(
"
mirror
"
)
;
if
(
currentSchemaVersion
>
0
)
{
if
(
currentSchemaVersion
<
MIRROR_SCHEMA_VERSION
)
{
await
migrateMirrorSchema
(
db
currentSchemaVersion
)
;
}
}
else
{
await
initializeMirrorDatabase
(
db
)
;
}
await
db
.
setSchemaVersion
(
MIRROR_SCHEMA_VERSION
"
mirror
"
)
;
await
initializeTempMirrorEntities
(
db
)
;
}
)
;
}
catch
(
ex
)
{
await
db
.
execute
(
DETACH
mirror
)
;
throw
ex
;
}
}
async
function
migrateMirrorSchema
(
db
currentSchemaVersion
)
{
if
(
currentSchemaVersion
<
5
)
{
throw
new
DatabaseCorruptError
(
Can
'
t
migrate
from
schema
version
{
currentSchemaVersion
}
;
too
old
)
;
}
if
(
currentSchemaVersion
<
6
)
{
await
db
.
execute
(
CREATE
INDEX
IF
NOT
EXISTS
mirror
.
itemURLs
ON
items
(
urlId
)
)
;
await
db
.
execute
(
CREATE
INDEX
IF
NOT
EXISTS
mirror
.
itemKeywords
ON
items
(
keyword
)
WHERE
keyword
NOT
NULL
)
;
}
if
(
currentSchemaVersion
<
7
)
{
await
db
.
execute
(
CREATE
INDEX
IF
NOT
EXISTS
mirror
.
structurePositions
ON
structure
(
parentGuid
position
)
)
;
}
}
async
function
initializeMirrorDatabase
(
db
)
{
await
db
.
execute
(
CREATE
TABLE
mirror
.
meta
(
key
TEXT
PRIMARY
KEY
value
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
items
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
UNIQUE
NOT
NULL
/
*
The
"
parentid
"
from
the
record
.
*
/
parentGuid
TEXT
/
*
The
server
modified
time
in
milliseconds
.
*
/
serverModified
INTEGER
NOT
NULL
DEFAULT
0
needsMerge
BOOLEAN
NOT
NULL
DEFAULT
0
validity
INTEGER
NOT
NULL
DEFAULT
{
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_VALID
}
isDeleted
BOOLEAN
NOT
NULL
DEFAULT
0
kind
INTEGER
NOT
NULL
DEFAULT
-
1
/
*
The
creation
date
in
milliseconds
.
*
/
dateAdded
INTEGER
NOT
NULL
DEFAULT
0
title
TEXT
urlId
INTEGER
REFERENCES
urls
(
id
)
ON
DELETE
SET
NULL
keyword
TEXT
description
TEXT
loadInSidebar
BOOLEAN
smartBookmarkName
TEXT
feedURL
TEXT
siteURL
TEXT
)
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
structure
(
guid
TEXT
parentGuid
TEXT
REFERENCES
items
(
guid
)
ON
DELETE
CASCADE
position
INTEGER
NOT
NULL
PRIMARY
KEY
(
parentGuid
guid
)
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
urls
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
NOT
NULL
url
TEXT
NOT
NULL
hash
INTEGER
NOT
NULL
revHost
TEXT
NOT
NULL
)
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
tags
(
itemId
INTEGER
NOT
NULL
REFERENCES
items
(
id
)
ON
DELETE
CASCADE
tag
TEXT
NOT
NULL
)
)
;
await
db
.
execute
(
CREATE
INDEX
mirror
.
structurePositions
ON
structure
(
parentGuid
position
)
)
;
await
db
.
execute
(
CREATE
INDEX
mirror
.
urlHashes
ON
urls
(
hash
)
)
;
await
db
.
execute
(
CREATE
INDEX
mirror
.
itemURLs
ON
items
(
urlId
)
)
;
await
db
.
execute
(
CREATE
INDEX
mirror
.
itemKeywords
ON
items
(
keyword
)
WHERE
keyword
NOT
NULL
)
;
await
createMirrorRoots
(
db
)
;
}
async
function
cleanupMirrorDatabase
(
db
)
{
await
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
execute
(
DROP
TABLE
changeGuidOps
)
;
await
db
.
execute
(
DROP
TABLE
itemsToApply
)
;
await
db
.
execute
(
DROP
TABLE
applyNewLocalStructureOps
)
;
await
db
.
execute
(
DROP
VIEW
localTags
)
;
await
db
.
execute
(
DROP
TABLE
itemsAdded
)
;
await
db
.
execute
(
DROP
TABLE
guidsChanged
)
;
await
db
.
execute
(
DROP
TABLE
itemsChanged
)
;
await
db
.
execute
(
DROP
TABLE
itemsMoved
)
;
await
db
.
execute
(
DROP
TABLE
itemsRemoved
)
;
await
db
.
execute
(
DROP
TABLE
itemsToUpload
)
;
await
db
.
execute
(
DROP
TABLE
structureToUpload
)
;
await
db
.
execute
(
DROP
TABLE
tagsToUpload
)
;
}
)
;
}
async
function
createMirrorRoots
(
db
)
{
const
syncableRoots
=
[
{
guid
:
PlacesUtils
.
bookmarks
.
rootGuid
parentGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
position
:
-
1
needsMerge
:
false
}
.
.
.
PlacesUtils
.
bookmarks
.
userContentRoots
.
map
(
(
guid
position
)
=
>
{
return
{
guid
parentGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
position
needsMerge
:
true
}
;
}
)
]
;
for
(
let
{
guid
parentGuid
position
needsMerge
}
of
syncableRoots
)
{
await
db
.
executeCached
(
INSERT
INTO
items
(
guid
parentGuid
kind
needsMerge
)
VALUES
(
:
guid
:
parentGuid
:
kind
:
needsMerge
)
{
guid
parentGuid
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_FOLDER
needsMerge
}
)
;
await
db
.
executeCached
(
INSERT
INTO
structure
(
guid
parentGuid
position
)
VALUES
(
:
guid
:
parentGuid
:
position
)
{
guid
parentGuid
position
}
)
;
}
}
async
function
initializeTempMirrorEntities
(
db
)
{
await
db
.
execute
(
CREATE
TEMP
TABLE
changeGuidOps
(
localGuid
TEXT
PRIMARY
KEY
mergedGuid
TEXT
UNIQUE
NOT
NULL
syncStatus
INTEGER
level
INTEGER
NOT
NULL
lastModifiedMicroseconds
INTEGER
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
changeGuids
AFTER
DELETE
ON
changeGuidOps
BEGIN
/
*
Record
item
changed
notifications
for
the
updated
GUIDs
.
*
/
INSERT
INTO
guidsChanged
(
itemId
oldGuid
level
)
SELECT
b
.
id
OLD
.
localGuid
OLD
.
level
FROM
moz_bookmarks
b
WHERE
b
.
guid
=
OLD
.
localGuid
;
UPDATE
moz_bookmarks
SET
guid
=
OLD
.
mergedGuid
lastModified
=
OLD
.
lastModifiedMicroseconds
syncStatus
=
IFNULL
(
OLD
.
syncStatus
syncStatus
)
WHERE
guid
=
OLD
.
localGuid
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsToApply
(
mergedGuid
TEXT
PRIMARY
KEY
localId
INTEGER
UNIQUE
remoteId
INTEGER
UNIQUE
NOT
NULL
remoteGuid
TEXT
UNIQUE
NOT
NULL
newLevel
INTEGER
NOT
NULL
newType
INTEGER
NOT
NULL
localDateAddedMicroseconds
INTEGER
remoteDateAddedMicroseconds
INTEGER
NOT
NULL
lastModifiedMicroseconds
INTEGER
NOT
NULL
oldTitle
TEXT
newTitle
TEXT
oldPlaceId
INTEGER
newPlaceId
INTEGER
newKeyword
TEXT
)
)
;
await
db
.
execute
(
CREATE
INDEX
existingItems
ON
itemsToApply
(
localId
)
WHERE
localId
NOT
NULL
)
;
await
db
.
execute
(
CREATE
INDEX
oldPlaceIds
ON
itemsToApply
(
oldPlaceId
)
WHERE
oldPlaceId
NOT
NULL
)
;
await
db
.
execute
(
CREATE
INDEX
newPlaceIds
ON
itemsToApply
(
newPlaceId
)
WHERE
newPlaceId
NOT
NULL
)
;
await
db
.
execute
(
CREATE
INDEX
newKeywords
ON
itemsToApply
(
newKeyword
)
WHERE
newKeyword
NOT
NULL
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
applyNewLocalStructureOps
(
mergedGuid
TEXT
PRIMARY
KEY
mergedParentGuid
TEXT
NOT
NULL
position
INTEGER
NOT
NULL
level
INTEGER
NOT
NULL
lastModifiedMicroseconds
INTEGER
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
applyNewLocalStructure
AFTER
DELETE
ON
applyNewLocalStructureOps
BEGIN
INSERT
INTO
itemsMoved
(
itemId
oldParentId
oldParentGuid
oldPosition
level
)
SELECT
b
.
id
p
.
id
p
.
guid
b
.
position
OLD
.
level
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
guid
=
OLD
.
mergedGuid
;
UPDATE
moz_bookmarks
SET
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
OLD
.
mergedParentGuid
)
position
=
OLD
.
position
lastModified
=
OLD
.
lastModifiedMicroseconds
WHERE
guid
=
OLD
.
mergedGuid
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
VIEW
localTags
(
tagEntryId
tagEntryGuid
tagFolderId
tagFolderGuid
tagEntryPosition
tagEntryType
tag
placeId
lastModifiedMicroseconds
)
AS
SELECT
b
.
id
b
.
guid
p
.
id
p
.
guid
b
.
position
b
.
type
p
.
title
b
.
fk
b
.
lastModified
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
type
=
{
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
}
AND
p
.
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
untagLocalPlace
INSTEAD
OF
DELETE
ON
localTags
BEGIN
/
*
Record
an
item
removed
notification
for
the
tag
entry
.
*
/
INSERT
INTO
itemsRemoved
(
itemId
parentId
position
type
placeId
guid
parentGuid
isUntagging
)
VALUES
(
OLD
.
tagEntryId
OLD
.
tagFolderId
OLD
.
tagEntryPosition
OLD
.
tagEntryType
OLD
.
placeId
OLD
.
tagEntryGuid
OLD
.
tagFolderGuid
1
)
;
DELETE
FROM
moz_bookmarks
WHERE
id
=
OLD
.
tagEntryId
;
/
*
Fix
the
positions
of
the
sibling
tag
entries
.
*
/
UPDATE
moz_bookmarks
SET
position
=
position
-
1
WHERE
parent
=
OLD
.
tagFolderId
AND
position
>
OLD
.
tagEntryPosition
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
tagLocalPlace
INSTEAD
OF
INSERT
ON
localTags
BEGIN
/
*
Ensure
the
tag
folder
exists
.
*
/
INSERT
OR
IGNORE
INTO
moz_bookmarks
(
guid
parent
position
type
title
dateAdded
lastModified
)
VALUES
(
IFNULL
(
(
SELECT
b
.
guid
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
title
=
NEW
.
tag
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
GENERATE_GUID
(
)
)
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
(
SELECT
COUNT
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
{
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
NEW
.
tag
NEW
.
lastModifiedMicroseconds
NEW
.
lastModifiedMicroseconds
)
;
/
*
Record
an
item
added
notification
if
we
created
a
tag
folder
.
"
CHANGES
(
)
"
returns
the
number
of
rows
affected
by
the
INSERT
above
:
1
if
we
created
the
folder
or
0
if
the
folder
already
existed
.
*
/
INSERT
INTO
itemsAdded
(
guid
isTagging
)
SELECT
b
.
guid
1
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
CHANGES
(
)
>
0
AND
b
.
title
=
NEW
.
tag
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
;
/
*
Add
a
tag
entry
for
the
URL
under
the
tag
folder
.
Omitting
the
place
ID
creates
a
tag
folder
without
tagging
the
URL
.
*
/
INSERT
OR
IGNORE
INTO
moz_bookmarks
(
guid
parent
position
type
fk
dateAdded
lastModified
)
SELECT
IFNULL
(
(
SELECT
b
.
guid
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
fk
=
NEW
.
placeId
AND
p
.
title
=
NEW
.
tag
AND
p
.
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
)
GENERATE_GUID
(
)
)
(
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
AND
b
.
title
=
NEW
.
tag
)
(
SELECT
COUNT
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
p
.
title
=
NEW
.
tag
AND
p
.
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
)
{
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
}
NEW
.
placeId
NEW
.
lastModifiedMicroseconds
NEW
.
lastModifiedMicroseconds
WHERE
NEW
.
placeId
NOT
NULL
;
/
*
Record
an
item
added
notification
for
the
tag
entry
.
*
/
INSERT
INTO
itemsAdded
(
guid
isTagging
)
SELECT
b
.
guid
1
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
CHANGES
(
)
>
0
AND
b
.
fk
=
NEW
.
placeId
AND
p
.
title
=
NEW
.
tag
AND
p
.
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsAdded
(
guid
TEXT
PRIMARY
KEY
isTagging
BOOLEAN
NOT
NULL
DEFAULT
0
keywordChanged
BOOLEAN
NOT
NULL
DEFAULT
0
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
INDEX
addedItemLevels
ON
itemsAdded
(
level
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
guidsChanged
(
itemId
INTEGER
PRIMARY
KEY
oldGuid
TEXT
NOT
NULL
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
)
;
await
db
.
execute
(
CREATE
INDEX
changedGuidLevels
ON
guidsChanged
(
level
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsChanged
(
itemId
INTEGER
PRIMARY
KEY
oldTitle
TEXT
oldPlaceId
INTEGER
keywordChanged
BOOLEAN
NOT
NULL
DEFAULT
0
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
)
;
await
db
.
execute
(
CREATE
INDEX
changedItemLevels
ON
itemsChanged
(
level
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsMoved
(
itemId
INTEGER
PRIMARY
KEY
oldParentId
INTEGER
NOT
NULL
oldParentGuid
TEXT
NOT
NULL
oldPosition
INTEGER
NOT
NULL
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
)
;
await
db
.
execute
(
CREATE
INDEX
movedItemLevels
ON
itemsMoved
(
level
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsRemoved
(
itemId
INTEGER
PRIMARY
KEY
guid
TEXT
NOT
NULL
parentId
INTEGER
NOT
NULL
position
INTEGER
NOT
NULL
type
INTEGER
NOT
NULL
placeId
INTEGER
parentGuid
TEXT
NOT
NULL
/
*
We
record
the
original
level
of
the
removed
item
in
the
tree
so
that
we
can
notify
children
before
parents
.
*
/
level
INTEGER
NOT
NULL
DEFAULT
-
1
isUntagging
BOOLEAN
NOT
NULL
DEFAULT
0
)
)
;
await
db
.
execute
(
CREATE
INDEX
removedItemLevels
ON
itemsRemoved
(
level
DESC
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsToUpload
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
UNIQUE
NOT
NULL
syncChangeCounter
INTEGER
NOT
NULL
isDeleted
BOOLEAN
NOT
NULL
DEFAULT
0
parentGuid
TEXT
parentTitle
TEXT
dateAdded
INTEGER
/
*
In
milliseconds
.
*
/
type
INTEGER
title
TEXT
placeId
INTEGER
isQuery
BOOLEAN
NOT
NULL
DEFAULT
0
url
TEXT
tagFolderName
TEXT
keyword
TEXT
position
INTEGER
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
structureToUpload
(
guid
TEXT
PRIMARY
KEY
parentId
INTEGER
NOT
NULL
REFERENCES
itemsToUpload
(
id
)
ON
DELETE
CASCADE
position
INTEGER
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
INDEX
parentsToUpload
ON
structureToUpload
(
parentId
position
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
tagsToUpload
(
id
INTEGER
REFERENCES
itemsToUpload
(
id
)
ON
DELETE
CASCADE
tag
TEXT
PRIMARY
KEY
(
id
tag
)
)
WITHOUT
ROWID
)
;
}
async
function
resetMirror
(
db
)
{
await
db
.
execute
(
DELETE
FROM
meta
)
;
await
db
.
execute
(
DELETE
FROM
structure
)
;
await
db
.
execute
(
DELETE
FROM
items
)
;
await
db
.
execute
(
DELETE
FROM
urls
)
;
await
createMirrorRoots
(
db
)
;
}
function
determineServerModified
(
record
)
{
return
Math
.
max
(
record
.
modified
*
1000
0
)
|
|
0
;
}
function
determineDateAdded
(
record
)
{
let
serverModified
=
determineServerModified
(
record
)
;
return
PlacesSyncUtils
.
bookmarks
.
ratchetTimestampBackwards
(
record
.
dateAdded
serverModified
)
;
}
function
validateTitle
(
rawTitle
)
{
if
(
typeof
rawTitle
!
=
"
string
"
|
|
!
rawTitle
)
{
return
null
;
}
return
rawTitle
.
slice
(
0
DB_TITLE_LENGTH_MAX
)
;
}
function
validateURL
(
rawURL
)
{
if
(
typeof
rawURL
!
=
"
string
"
|
|
rawURL
.
length
>
DB_URL_LENGTH_MAX
)
{
return
null
;
}
let
url
=
null
;
try
{
url
=
new
URL
(
rawURL
)
;
}
catch
(
ex
)
{
}
return
url
;
}
function
validateKeyword
(
rawKeyword
)
{
if
(
typeof
rawKeyword
!
=
"
string
"
)
{
return
null
;
}
let
keyword
=
rawKeyword
.
trim
(
)
;
return
keyword
?
keyword
.
toLowerCase
(
)
:
null
;
}
function
validateTag
(
rawTag
)
{
if
(
typeof
rawTag
!
=
"
string
"
)
{
return
null
;
}
let
tag
=
rawTag
.
trim
(
)
;
if
(
!
tag
|
|
tag
.
length
>
PlacesUtils
.
bookmarks
.
MAX_TAG_LENGTH
)
{
return
null
;
}
return
tag
;
}
async
function
withTiming
(
name
func
recordTiming
)
{
MirrorLog
.
debug
(
name
)
;
let
startTime
=
Cu
.
now
(
)
;
let
result
=
await
func
(
)
;
let
elapsedTime
=
Cu
.
now
(
)
-
startTime
;
MirrorLog
.
debug
(
{
name
}
took
{
elapsedTime
.
toFixed
(
3
)
}
ms
)
;
if
(
typeof
recordTiming
=
=
"
function
"
)
{
recordTiming
(
elapsedTime
result
)
;
}
return
result
;
}
class
BookmarkObserverRecorder
{
constructor
(
db
{
maxFrecenciesToRecalculate
notifyInStableOrder
signal
}
)
{
this
.
db
=
db
;
this
.
maxFrecenciesToRecalculate
=
maxFrecenciesToRecalculate
;
this
.
notifyInStableOrder
=
notifyInStableOrder
;
this
.
signal
=
signal
;
this
.
placesEvents
=
[
]
;
this
.
guidChangedArgs
=
[
]
;
this
.
itemMovedArgs
=
[
]
;
this
.
itemChangedArgs
=
[
]
;
this
.
shouldInvalidateKeywords
=
false
;
}
async
notifyAll
(
)
{
await
this
.
noteAllChanges
(
)
;
if
(
this
.
shouldInvalidateKeywords
)
{
await
PlacesUtils
.
keywords
.
invalidateCachedKeywords
(
)
;
}
await
this
.
notifyBookmarkObservers
(
)
;
if
(
this
.
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
before
recalculating
frecencies
for
new
URLs
"
)
;
}
await
updateFrecencies
(
this
.
db
this
.
maxFrecenciesToRecalculate
)
;
}
orderBy
(
level
parent
position
)
{
return
ORDER
BY
{
this
.
notifyInStableOrder
?
{
level
}
{
parent
}
{
position
}
:
level
}
;
}
async
noteAllChanges
(
)
{
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
removed
items
"
)
;
await
this
.
db
.
execute
(
SELECT
v
.
itemId
AS
id
v
.
parentId
v
.
parentGuid
v
.
position
v
.
type
(
SELECT
h
.
url
FROM
moz_places
h
WHERE
h
.
id
=
v
.
placeId
)
AS
url
v
.
guid
v
.
isUntagging
FROM
itemsRemoved
v
{
this
.
orderBy
(
"
v
.
level
"
"
v
.
parentId
"
"
v
.
position
"
)
}
null
(
row
cancel
)
=
>
{
if
(
this
.
signal
.
aborted
)
{
cancel
(
)
;
return
;
}
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
position
:
row
.
getResultByName
(
"
position
"
)
type
:
row
.
getResultByName
(
"
type
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
isUntagging
:
row
.
getResultByName
(
"
isUntagging
"
)
}
;
this
.
noteItemRemoved
(
info
)
;
}
)
;
if
(
this
.
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
while
recording
observer
notifications
for
removed
items
"
)
;
}
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
changed
GUIDs
"
)
;
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
lastModified
b
.
type
b
.
guid
AS
newGuid
c
.
oldGuid
p
.
id
AS
parentId
p
.
guid
AS
parentGuid
FROM
guidsChanged
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
{
this
.
orderBy
(
"
c
.
level
"
"
b
.
parent
"
"
b
.
position
"
)
}
null
(
row
cancel
)
=
>
{
if
(
this
.
signal
.
aborted
)
{
cancel
(
)
;
return
;
}
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
lastModified
:
row
.
getResultByName
(
"
lastModified
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newGuid
:
row
.
getResultByName
(
"
newGuid
"
)
oldGuid
:
row
.
getResultByName
(
"
oldGuid
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
}
;
this
.
noteGuidChanged
(
info
)
;
}
)
;
if
(
this
.
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
while
recording
observer
notifications
for
changed
GUIDs
"
)
;
}
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
new
items
"
)
;
await
this
.
db
.
execute
(
SELECT
b
.
id
p
.
id
AS
parentId
b
.
position
b
.
type
(
SELECT
h
.
url
FROM
moz_places
h
WHERE
h
.
id
=
b
.
fk
)
AS
url
IFNULL
(
b
.
title
'
'
)
AS
title
b
.
dateAdded
b
.
guid
p
.
guid
AS
parentGuid
n
.
isTagging
n
.
keywordChanged
FROM
itemsAdded
n
JOIN
moz_bookmarks
b
ON
b
.
guid
=
n
.
guid
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
{
this
.
orderBy
(
"
n
.
level
"
"
b
.
parent
"
"
b
.
position
"
)
}
null
(
row
cancel
)
=
>
{
if
(
this
.
signal
.
aborted
)
{
cancel
(
)
;
return
;
}
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
position
:
row
.
getResultByName
(
"
position
"
)
type
:
row
.
getResultByName
(
"
type
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
isTagging
:
row
.
getResultByName
(
"
isTagging
"
)
}
;
this
.
noteItemAdded
(
info
)
;
if
(
row
.
getResultByName
(
"
keywordChanged
"
)
)
{
this
.
shouldInvalidateKeywords
=
true
;
}
}
)
;
if
(
this
.
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
while
recording
observer
notifications
for
new
items
"
)
;
}
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
moved
items
"
)
;
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
guid
b
.
type
p
.
id
AS
newParentId
c
.
oldParentId
p
.
guid
AS
newParentGuid
c
.
oldParentGuid
b
.
position
AS
newPosition
c
.
oldPosition
(
SELECT
h
.
url
FROM
moz_places
h
WHERE
h
.
id
=
b
.
fk
)
AS
url
FROM
itemsMoved
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
{
this
.
orderBy
(
"
c
.
level
"
"
b
.
parent
"
"
b
.
position
"
)
}
null
(
row
cancel
)
=
>
{
if
(
this
.
signal
.
aborted
)
{
cancel
(
)
;
return
;
}
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newParentId
:
row
.
getResultByName
(
"
newParentId
"
)
oldParentId
:
row
.
getResultByName
(
"
oldParentId
"
)
newParentGuid
:
row
.
getResultByName
(
"
newParentGuid
"
)
oldParentGuid
:
row
.
getResultByName
(
"
oldParentGuid
"
)
newPosition
:
row
.
getResultByName
(
"
newPosition
"
)
oldPosition
:
row
.
getResultByName
(
"
oldPosition
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
}
;
this
.
noteItemMoved
(
info
)
;
}
)
;
if
(
this
.
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
while
recording
observer
notifications
for
moved
items
"
)
;
}
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
changed
items
"
)
;
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
guid
b
.
lastModified
b
.
type
IFNULL
(
b
.
title
'
'
)
AS
newTitle
IFNULL
(
c
.
oldTitle
'
'
)
AS
oldTitle
(
SELECT
h
.
url
FROM
moz_places
h
WHERE
h
.
id
=
b
.
fk
)
AS
newURL
(
SELECT
h
.
url
FROM
moz_places
h
WHERE
h
.
id
=
c
.
oldPlaceId
)
AS
oldURL
p
.
id
AS
parentId
p
.
guid
AS
parentGuid
c
.
keywordChanged
FROM
itemsChanged
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
{
this
.
orderBy
(
"
c
.
level
"
"
b
.
parent
"
"
b
.
position
"
)
}
null
(
row
cancel
)
=
>
{
if
(
this
.
signal
.
aborted
)
{
cancel
(
)
;
return
;
}
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
lastModified
:
row
.
getResultByName
(
"
lastModified
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newTitle
:
row
.
getResultByName
(
"
newTitle
"
)
oldTitle
:
row
.
getResultByName
(
"
oldTitle
"
)
newURLHref
:
row
.
getResultByName
(
"
newURL
"
)
oldURLHref
:
row
.
getResultByName
(
"
oldURL
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
}
;
this
.
noteItemChanged
(
info
)
;
if
(
row
.
getResultByName
(
"
keywordChanged
"
)
)
{
this
.
shouldInvalidateKeywords
=
true
;
}
}
)
;
if
(
this
.
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
while
recording
observer
notifications
for
changed
items
"
)
;
}
}
noteItemAdded
(
info
)
{
this
.
placesEvents
.
push
(
new
PlacesBookmarkAddition
(
{
id
:
info
.
id
parentId
:
info
.
parentId
index
:
info
.
position
url
:
info
.
urlHref
|
|
"
"
title
:
info
.
title
dateAdded
:
info
.
dateAdded
/
1000
guid
:
info
.
guid
parentGuid
:
info
.
parentGuid
source
:
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
itemType
:
info
.
type
isTagging
:
info
.
isTagging
}
)
)
;
}
noteGuidChanged
(
info
)
{
PlacesUtils
.
invalidateCachedGuidFor
(
info
.
id
)
;
this
.
guidChangedArgs
.
push
(
[
info
.
id
"
guid
"
false
info
.
newGuid
info
.
lastModified
info
.
type
info
.
parentId
info
.
newGuid
info
.
parentGuid
info
.
oldGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
)
;
}
noteItemMoved
(
info
)
{
this
.
itemMovedArgs
.
push
(
[
info
.
id
info
.
oldParentId
info
.
oldPosition
info
.
newParentId
info
.
newPosition
info
.
type
info
.
guid
info
.
oldParentGuid
info
.
newParentGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
info
.
urlHref
]
)
;
}
noteItemChanged
(
info
)
{
if
(
info
.
oldTitle
!
=
info
.
newTitle
)
{
this
.
itemChangedArgs
.
push
(
[
info
.
id
"
title
"
false
info
.
newTitle
info
.
lastModified
info
.
type
info
.
parentId
info
.
guid
info
.
parentGuid
info
.
oldTitle
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
)
;
}
if
(
info
.
oldURLHref
!
=
info
.
newURLHref
)
{
this
.
itemChangedArgs
.
push
(
[
info
.
id
"
uri
"
false
info
.
newURLHref
info
.
lastModified
info
.
type
info
.
parentId
info
.
guid
info
.
parentGuid
info
.
oldURLHref
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
)
;
}
}
noteItemRemoved
(
info
)
{
this
.
placesEvents
.
push
(
new
PlacesBookmarkRemoved
(
{
id
:
info
.
id
parentId
:
info
.
parentId
index
:
info
.
position
url
:
info
.
urlHref
|
|
"
"
guid
:
info
.
guid
parentGuid
:
info
.
parentGuid
source
:
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
itemType
:
info
.
type
isTagging
:
info
.
isUntagging
isDescendantRemoval
:
false
}
)
)
;
}
async
notifyBookmarkObservers
(
)
{
MirrorLog
.
trace
(
"
Notifying
bookmark
observers
"
)
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
for
(
let
observer
of
observers
)
{
this
.
notifyObserver
(
observer
"
onBeginUpdateBatch
"
)
;
}
await
Async
.
yieldingForEach
(
this
.
guidChangedArgs
args
=
>
{
if
(
this
.
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
while
notifying
observers
for
changed
GUIDs
"
)
;
}
this
.
notifyObserversWithInfo
(
observers
"
onItemChanged
"
{
isTagging
:
false
args
}
)
;
}
yieldState
)
;
if
(
this
.
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
before
notifying
observers
for
new
items
"
)
;
}
PlacesObservers
.
notifyListeners
(
this
.
placesEvents
)
;
await
Async
.
yieldingForEach
(
this
.
itemMovedArgs
args
=
>
{
if
(
this
.
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
before
notifying
observers
for
moved
items
"
)
;
}
this
.
notifyObserversWithInfo
(
observers
"
onItemMoved
"
{
isTagging
:
false
args
}
)
;
}
yieldState
)
;
await
Async
.
yieldingForEach
(
this
.
itemChangedArgs
args
=
>
{
if
(
this
.
signal
.
aborted
)
{
throw
new
SyncedBookmarksMirror
.
InterruptedError
(
"
Interrupted
before
notifying
observers
for
changed
items
"
)
;
}
this
.
notifyObserversWithInfo
(
observers
"
onItemChanged
"
{
isTagging
:
false
args
}
)
;
}
yieldState
)
;
for
(
let
observer
of
observers
)
{
this
.
notifyObserver
(
observer
"
onEndUpdateBatch
"
)
;
}
}
notifyObserversWithInfo
(
observers
name
info
)
{
for
(
let
observer
of
observers
)
{
if
(
info
.
isTagging
&
&
observer
.
skipTags
)
{
return
;
}
this
.
notifyObserver
(
observer
name
info
.
args
)
;
}
}
notifyObserver
(
observer
notification
args
=
[
]
)
{
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
MirrorLog
.
warn
(
"
Error
notifying
observer
"
ex
)
;
}
}
}
class
BookmarkChangeRecord
{
constructor
(
syncChangeCounter
cleartext
)
{
this
.
tombstone
=
cleartext
.
deleted
=
=
=
true
;
this
.
counter
=
syncChangeCounter
;
this
.
cleartext
=
cleartext
;
this
.
synced
=
false
;
}
}
async
function
updateFrecencies
(
db
limit
)
{
MirrorLog
.
trace
(
"
Recalculating
frecencies
for
new
URLs
"
)
;
await
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
CALCULATE_FRECENCY
(
id
)
WHERE
id
IN
(
SELECT
id
FROM
moz_places
WHERE
frecency
<
0
ORDER
BY
frecency
ASC
LIMIT
:
limit
)
{
limit
}
)
;
}
function
bagToNamedCounts
(
bag
names
)
{
let
counts
=
[
]
;
for
(
let
name
of
names
)
{
let
count
=
bag
.
getProperty
(
name
)
;
if
(
count
>
0
)
{
counts
.
push
(
{
name
count
}
)
;
}
}
return
counts
;
}
function
anyAborted
(
finalizeSignal
interruptSignal
=
null
)
{
if
(
finalizeSignal
.
aborted
|
|
!
interruptSignal
)
{
return
finalizeSignal
;
}
if
(
interruptSignal
.
aborted
)
{
return
interruptSignal
;
}
let
controller
=
new
AbortController
(
)
;
function
onAbort
(
)
{
finalizeSignal
.
removeEventListener
(
"
abort
"
onAbort
)
;
interruptSignal
.
removeEventListener
(
"
abort
"
onAbort
)
;
controller
.
abort
(
)
;
}
finalizeSignal
.
addEventListener
(
"
abort
"
onAbort
)
;
interruptSignal
.
addEventListener
(
"
abort
"
onAbort
)
;
return
controller
.
signal
;
}
