"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SyncedBookmarksMirror
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Async
:
"
resource
:
/
/
services
-
common
/
async
.
js
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
PlacesSyncUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
MirrorLog
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Sync
.
Engine
.
Bookmarks
.
Mirror
"
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
LocalItemsSQLFragment
"
(
)
=
>
localItems
(
id
guid
parentId
parentGuid
position
type
title
parentTitle
placeId
dateAdded
lastModified
syncChangeCounter
isSyncable
level
)
AS
(
SELECT
b
.
id
b
.
guid
p
.
id
p
.
guid
b
.
position
b
.
type
b
.
title
p
.
title
b
.
fk
b
.
dateAdded
b
.
lastModified
b
.
syncChangeCounter
b
.
guid
IN
(
{
PlacesUtils
.
bookmarks
.
userContentRoots
.
map
(
v
=
>
'
{
v
}
'
)
.
join
(
"
"
)
}
)
0
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
guid
<
>
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
UNION
ALL
SELECT
b
.
id
b
.
guid
s
.
id
s
.
guid
b
.
position
b
.
type
b
.
title
s
.
title
b
.
fk
b
.
dateAdded
b
.
lastModified
b
.
syncChangeCounter
s
.
isSyncable
s
.
level
+
1
FROM
moz_bookmarks
b
JOIN
localItems
s
ON
s
.
id
=
b
.
parent
)
)
;
const
DB_URL_LENGTH_MAX
=
65536
;
const
DB_TITLE_LENGTH_MAX
=
4096
;
const
DB_DESCRIPTION_LENGTH_MAX
=
256
;
const
SQLITE_MAX_VARIABLE_NUMBER
=
999
;
const
MIRROR_SCHEMA_VERSION
=
2
;
XPCOMUtils
.
defineLazyGetter
(
this
"
maybeYield
"
(
)
=
>
Async
.
jankYielder
(
)
)
;
function
yieldingIterator
(
collection
)
{
return
Async
.
yieldingIterator
(
collection
maybeYield
)
;
}
class
SyncedBookmarksMirror
{
constructor
(
db
{
recordTelemetryEvent
finalizeAt
=
AsyncShutdown
.
profileBeforeChange
}
=
{
}
)
{
this
.
db
=
db
;
this
.
recordTelemetryEvent
=
recordTelemetryEvent
;
this
.
finalizeAt
=
finalizeAt
;
this
.
finalizeBound
=
(
)
=
>
this
.
finalize
(
)
;
this
.
finalizeAt
.
addBlocker
(
"
SyncedBookmarksMirror
:
finalize
"
this
.
finalizeBound
)
;
}
static
async
open
(
options
)
{
let
db
=
await
Sqlite
.
cloneStorageConnection
(
{
connection
:
PlacesUtils
.
history
.
DBConnection
readOnly
:
false
}
)
;
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
options
.
path
)
;
let
whyFailed
=
"
initialize
"
;
try
{
await
db
.
execute
(
PRAGMA
foreign_keys
=
ON
)
;
try
{
await
attachAndInitMirrorDatabase
(
db
path
)
;
}
catch
(
ex
)
{
if
(
isDatabaseCorrupt
(
ex
)
)
{
MirrorLog
.
warn
(
"
Error
attaching
mirror
to
Places
;
removing
and
"
+
"
recreating
mirror
"
ex
)
;
options
.
recordTelemetryEvent
(
"
mirror
"
"
open
"
"
retry
"
{
why
:
"
corrupt
"
}
)
;
whyFailed
=
"
remove
"
;
await
OS
.
File
.
remove
(
path
)
;
whyFailed
=
"
replace
"
;
await
attachAndInitMirrorDatabase
(
db
path
)
;
}
else
{
MirrorLog
.
error
(
"
Unrecoverable
error
attaching
mirror
to
Places
"
ex
)
;
throw
ex
;
}
}
try
{
let
info
=
await
OS
.
File
.
stat
(
path
)
;
let
size
=
Math
.
floor
(
info
.
size
/
1024
)
;
options
.
recordTelemetryEvent
(
"
mirror
"
"
open
"
"
success
"
{
size
}
)
;
}
catch
(
ex
)
{
MirrorLog
.
warn
(
"
Error
recording
stats
for
mirror
database
size
"
ex
)
;
}
}
catch
(
ex
)
{
options
.
recordTelemetryEvent
(
"
mirror
"
"
open
"
"
error
"
{
why
:
whyFailed
}
)
;
await
db
.
close
(
)
;
throw
ex
;
}
return
new
SyncedBookmarksMirror
(
db
options
)
;
}
async
getCollectionHighWaterMark
(
)
{
let
rows
=
await
this
.
db
.
executeCached
(
SELECT
MAX
(
IFNULL
(
(
SELECT
MAX
(
serverModified
)
-
1000
FROM
items
)
0
)
IFNULL
(
(
SELECT
CAST
(
value
AS
INTEGER
)
FROM
meta
WHERE
key
=
:
modifiedKey
)
0
)
)
AS
highWaterMark
{
modifiedKey
:
SyncedBookmarksMirror
.
META_KEY
.
LAST_MODIFIED
}
)
;
let
highWaterMark
=
rows
[
0
]
.
getResultByName
(
"
highWaterMark
"
)
;
return
highWaterMark
/
1000
;
}
async
setCollectionLastModified
(
lastModifiedSeconds
)
{
let
lastModified
=
Math
.
floor
(
lastModifiedSeconds
*
1000
)
;
if
(
!
Number
.
isInteger
(
lastModified
)
)
{
throw
new
TypeError
(
"
Invalid
collection
last
modified
time
"
)
;
}
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
setCollectionLastModified
"
db
=
>
db
.
executeCached
(
REPLACE
INTO
meta
(
key
value
)
VALUES
(
:
modifiedKey
:
lastModified
)
{
modifiedKey
:
SyncedBookmarksMirror
.
META_KEY
.
LAST_MODIFIED
lastModified
}
)
)
;
}
async
getSyncId
(
)
{
let
rows
=
await
this
.
db
.
executeCached
(
SELECT
value
FROM
meta
WHERE
key
=
:
syncIdKey
{
syncIdKey
:
SyncedBookmarksMirror
.
META_KEY
.
SYNC_ID
}
)
;
return
rows
.
length
?
rows
[
0
]
.
getResultByName
(
"
value
"
)
:
"
"
;
}
async
ensureCurrentSyncId
(
newSyncId
)
{
if
(
!
newSyncId
|
|
typeof
newSyncId
!
=
"
string
"
)
{
throw
new
TypeError
(
"
Invalid
new
bookmarks
sync
ID
"
)
;
}
let
existingSyncId
=
await
this
.
getSyncId
(
)
;
if
(
existingSyncId
=
=
newSyncId
)
{
MirrorLog
.
trace
(
"
Sync
ID
up
-
to
-
date
in
mirror
"
{
existingSyncId
}
)
;
return
;
}
MirrorLog
.
info
(
"
Sync
ID
changed
from
{
existingSyncId
}
to
"
+
"
{
newSyncId
}
;
resetting
mirror
"
{
existingSyncId
newSyncId
}
)
;
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
ensureCurrentSyncId
"
db
=
>
db
.
executeTransaction
(
async
function
(
)
{
await
resetMirror
(
db
)
;
await
db
.
execute
(
REPLACE
INTO
meta
(
key
value
)
VALUES
(
:
syncIdKey
:
newSyncId
)
{
syncIdKey
:
SyncedBookmarksMirror
.
META_KEY
.
SYNC_ID
newSyncId
}
)
;
}
)
)
;
}
async
store
(
records
{
needsMerge
=
true
}
=
{
}
)
{
let
options
=
{
needsMerge
}
;
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
store
"
db
=
>
db
.
executeTransaction
(
async
(
)
=
>
{
for
await
(
let
record
of
yieldingIterator
(
records
)
)
{
MirrorLog
.
trace
(
Storing
in
mirror
:
{
record
.
cleartextToString
(
)
}
)
;
switch
(
record
.
type
)
{
case
"
bookmark
"
:
await
this
.
storeRemoteBookmark
(
record
options
)
;
continue
;
case
"
query
"
:
await
this
.
storeRemoteQuery
(
record
options
)
;
continue
;
case
"
folder
"
:
await
this
.
storeRemoteFolder
(
record
options
)
;
continue
;
case
"
livemark
"
:
await
this
.
storeRemoteLivemark
(
record
options
)
;
continue
;
case
"
separator
"
:
await
this
.
storeRemoteSeparator
(
record
options
)
;
continue
;
default
:
if
(
record
.
deleted
)
{
await
this
.
storeRemoteTombstone
(
record
options
)
;
continue
;
}
}
MirrorLog
.
warn
(
"
Ignoring
record
with
unknown
type
"
record
.
type
)
;
}
}
)
)
;
}
async
apply
(
{
localTimeSeconds
=
Date
.
now
(
)
/
1000
remoteTimeSeconds
=
0
weakUpload
=
[
]
}
=
{
}
)
{
let
hasChanges
=
weakUpload
.
length
>
0
|
|
(
await
this
.
hasChanges
(
)
)
;
if
(
!
hasChanges
)
{
MirrorLog
.
debug
(
"
No
changes
detected
in
both
mirror
and
Places
"
)
;
return
{
}
;
}
let
flowID
=
PlacesUtils
.
history
.
makeGuid
(
)
;
let
{
missingParents
missingChildren
parentsWithGaps
}
=
await
this
.
fetchRemoteOrphans
(
)
;
if
(
missingParents
.
length
)
{
MirrorLog
.
warn
(
"
Temporarily
reparenting
remote
items
with
missing
"
+
"
parents
to
unfiled
"
missingParents
)
;
}
if
(
missingChildren
.
length
)
{
MirrorLog
.
warn
(
"
Remote
tree
missing
items
"
missingChildren
)
;
}
if
(
parentsWithGaps
.
length
)
{
MirrorLog
.
warn
(
"
Remote
tree
has
parents
with
gaps
in
positions
"
parentsWithGaps
)
;
}
let
{
missingLocal
missingRemote
wrongSyncStatus
}
=
await
this
.
fetchSyncStatusMismatches
(
)
;
if
(
missingLocal
.
length
)
{
MirrorLog
.
warn
(
"
Remote
tree
has
merged
items
that
don
'
t
exist
locally
"
missingLocal
)
;
}
if
(
missingRemote
.
length
)
{
MirrorLog
.
warn
(
"
Local
tree
has
synced
items
that
don
'
t
exist
remotely
"
missingRemote
)
;
}
if
(
wrongSyncStatus
.
length
)
{
MirrorLog
.
warn
(
"
Local
tree
has
wrong
sync
statuses
for
items
that
"
+
"
exist
remotely
"
wrongSyncStatus
)
;
}
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
problems
"
{
flowID
missingParents
:
missingParents
.
length
missingChildren
:
missingChildren
.
length
parentsWithGaps
:
parentsWithGaps
.
length
missingLocal
:
missingLocal
.
length
missingRemote
:
missingRemote
.
length
wrongSyncStatus
:
wrongSyncStatus
.
length
}
)
;
let
remoteTree
=
await
withTiming
(
"
Building
remote
tree
from
mirror
"
(
)
=
>
this
.
fetchRemoteTree
(
remoteTimeSeconds
)
(
time
tree
)
=
>
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
fetchRemoteTree
"
{
flowID
time
deletions
:
tree
.
deletedGuids
.
size
nodes
:
tree
.
byGuid
.
size
}
)
)
;
if
(
MirrorLog
.
level
<
=
Log
.
Level
.
Debug
)
{
MirrorLog
.
debug
(
"
Built
remote
tree
from
mirror
\
n
"
+
remoteTree
.
toASCIITreeString
(
)
)
;
}
let
observersToNotify
=
new
BookmarkObserverRecorder
(
this
.
db
)
;
let
changeRecords
;
try
{
changeRecords
=
await
this
.
db
.
executeTransaction
(
async
(
)
=
>
{
let
localTree
=
await
withTiming
(
"
Building
local
tree
from
Places
"
(
)
=
>
this
.
fetchLocalTree
(
localTimeSeconds
)
(
time
tree
)
=
>
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
fetchLocalTree
"
{
flowID
time
deletions
:
tree
.
deletedGuids
.
size
nodes
:
tree
.
byGuid
.
size
}
)
)
;
if
(
MirrorLog
.
level
<
=
Log
.
Level
.
Debug
)
{
MirrorLog
.
debug
(
"
Built
local
tree
from
Places
\
n
"
+
localTree
.
toASCIITreeString
(
)
)
;
}
let
newRemoteContents
=
await
withTiming
(
"
Fetching
content
info
for
new
mirror
items
"
(
)
=
>
this
.
fetchNewRemoteContents
(
)
(
time
contents
)
=
>
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
fetchNewRemoteContents
"
{
flowID
time
count
:
contents
.
size
}
)
)
;
let
newLocalContents
=
await
withTiming
(
"
Fetching
content
info
for
new
Places
items
"
(
)
=
>
this
.
fetchNewLocalContents
(
)
(
time
contents
)
=
>
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
fetchNewLocalContents
"
{
flowID
time
count
:
contents
.
size
}
)
)
;
let
merger
=
new
BookmarkMerger
(
localTree
newLocalContents
remoteTree
newRemoteContents
)
;
let
mergedRoot
=
await
withTiming
(
"
Building
complete
merged
tree
"
(
)
=
>
merger
.
merge
(
)
time
=
>
{
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
merge
"
{
flowID
time
nodes
:
merger
.
mergedGuids
.
size
localDeletions
:
merger
.
deleteLocally
.
size
remoteDeletions
:
merger
.
deleteRemotely
.
size
dupes
:
merger
.
dupeCount
}
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
merge
"
"
structure
"
merger
.
structureCounts
)
;
}
)
;
if
(
MirrorLog
.
level
<
=
Log
.
Level
.
Debug
)
{
MirrorLog
.
debug
(
[
"
Built
new
merged
tree
"
mergedRoot
.
toASCIITreeString
(
)
.
.
.
merger
.
deletionsToStrings
(
)
]
.
join
(
"
\
n
"
)
)
;
}
if
(
!
await
merger
.
subsumes
(
localTree
)
)
{
throw
new
SyncedBookmarksMirror
.
ConsistencyError
(
"
Merged
tree
doesn
'
t
mention
all
items
from
local
tree
"
)
;
}
if
(
!
await
merger
.
subsumes
(
remoteTree
)
)
{
throw
new
SyncedBookmarksMirror
.
ConsistencyError
(
"
Merged
tree
doesn
'
t
mention
all
items
from
remote
tree
"
)
;
}
await
withTiming
(
"
Applying
merged
tree
"
async
(
)
=
>
{
let
deletions
=
[
]
;
for
await
(
let
deletion
of
yieldingIterator
(
merger
.
deletions
(
)
)
)
{
deletions
.
push
(
deletion
)
;
}
await
this
.
updateLocalItemsInPlaces
(
mergedRoot
deletions
)
;
}
time
=
>
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
updateLocalItemsInPlaces
"
{
flowID
time
}
)
)
;
await
withTiming
(
"
Recording
observer
notifications
"
(
)
=
>
this
.
noteObserverChanges
(
observersToNotify
)
time
=
>
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
noteObserverChanges
"
{
flowID
time
}
)
)
;
await
withTiming
(
"
Staging
locally
changed
items
for
upload
"
(
)
=
>
this
.
stageItemsToUpload
(
weakUpload
)
time
=
>
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
stageItemsToUpload
"
{
flowID
time
}
)
)
;
let
changeRecords
=
await
withTiming
(
"
Fetching
records
for
local
items
to
upload
"
(
)
=
>
this
.
fetchLocalChangeRecords
(
)
(
time
records
)
=
>
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
fetchLocalChangeRecords
"
{
flowID
count
:
Object
.
keys
(
records
)
.
length
}
)
)
;
await
withTiming
(
"
Cleaning
up
merge
tables
"
async
(
)
=
>
{
await
this
.
db
.
execute
(
DELETE
FROM
mergeStates
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsAdded
)
;
await
this
.
db
.
execute
(
DELETE
FROM
guidsChanged
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsChanged
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsRemoved
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsMoved
)
;
await
this
.
db
.
execute
(
DELETE
FROM
annosChanged
)
;
await
this
.
db
.
execute
(
DELETE
FROM
idsToWeaklyUpload
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsToUpload
)
;
}
time
=
>
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
cleanup
"
{
flowID
time
}
)
)
;
return
changeRecords
;
}
)
;
}
catch
(
ex
)
{
let
why
=
(
typeof
ex
.
message
=
=
"
string
"
?
ex
.
message
:
String
(
ex
)
)
.
slice
(
0
85
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
error
"
{
flowID
why
}
)
;
throw
ex
;
}
MirrorLog
.
debug
(
"
Replaying
recorded
observer
notifications
"
)
;
try
{
await
observersToNotify
.
notifyAll
(
)
;
}
catch
(
ex
)
{
MirrorLog
.
warn
(
"
Error
notifying
Places
observers
"
ex
)
;
}
return
changeRecords
;
}
async
reset
(
)
{
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
reset
"
db
=
>
db
.
executeTransaction
(
(
)
=
>
resetMirror
(
db
)
)
)
;
}
async
fetchUnmergedGuids
(
)
{
let
rows
=
await
this
.
db
.
execute
(
SELECT
guid
FROM
items
WHERE
needsMerge
)
;
return
rows
.
map
(
row
=
>
row
.
getResultByName
(
"
guid
"
)
)
;
}
async
storeRemoteBookmark
(
record
{
needsMerge
}
)
{
let
guid
=
validateGuid
(
record
.
id
)
;
if
(
!
guid
)
{
MirrorLog
.
warn
(
"
Ignoring
bookmark
with
invalid
ID
"
record
.
id
)
;
return
;
}
let
url
=
validateURL
(
record
.
bmkUri
)
;
if
(
!
url
)
{
MirrorLog
.
warn
(
"
Ignoring
bookmark
{
guid
}
with
invalid
URL
{
url
}
"
{
guid
url
:
record
.
bmkUri
}
)
;
return
;
}
await
this
.
maybeStoreRemoteURL
(
url
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
keyword
=
validateKeyword
(
record
.
keyword
)
;
let
description
=
validateDescription
(
record
.
description
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
kind
dateAdded
title
keyword
urlId
description
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
"
"
)
:
keyword
(
SELECT
id
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
:
description
)
{
guid
serverModified
needsMerge
kind
:
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
dateAdded
title
keyword
url
:
url
.
href
description
}
)
;
let
tags
=
record
.
tags
;
if
(
tags
&
&
Array
.
isArray
(
tags
)
)
{
for
(
let
rawTag
of
tags
)
{
let
tag
=
validateTag
(
rawTag
)
;
if
(
!
tag
)
{
continue
;
}
await
this
.
db
.
executeCached
(
INSERT
INTO
tags
(
itemId
tag
)
SELECT
id
:
tag
FROM
items
WHERE
guid
=
:
guid
{
tag
guid
}
)
;
}
}
}
async
storeRemoteQuery
(
record
{
needsMerge
}
)
{
let
guid
=
validateGuid
(
record
.
id
)
;
if
(
!
guid
)
{
MirrorLog
.
warn
(
"
Ignoring
query
with
invalid
ID
"
record
.
id
)
;
return
;
}
let
url
=
validateURL
(
record
.
bmkUri
)
;
if
(
!
url
)
{
MirrorLog
.
warn
(
"
Ignoring
query
{
guid
}
with
invalid
URL
{
url
}
"
{
guid
url
:
record
.
bmkUri
}
)
;
return
;
}
let
params
=
new
URLSearchParams
(
url
.
pathname
)
;
let
type
=
+
params
.
get
(
"
type
"
)
;
if
(
type
=
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAG_CONTENTS
)
{
let
tagFolderName
=
validateTag
(
record
.
folderName
)
;
if
(
!
tagFolderName
)
{
MirrorLog
.
warn
(
"
Ignoring
tag
query
{
guid
}
with
invalid
tag
name
"
+
"
{
tagFolderName
}
"
{
guid
tagFolderName
}
)
;
return
;
}
url
=
new
URL
(
place
:
tag
=
{
tagFolderName
}
)
;
}
else
{
let
folder
=
params
.
get
(
"
folder
"
)
;
if
(
folder
)
{
url
.
href
=
{
url
.
href
}
&
excludeItems
=
1
;
}
}
await
this
.
maybeStoreRemoteURL
(
url
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
description
=
validateDescription
(
record
.
description
)
;
let
smartBookmarkName
=
typeof
record
.
queryId
=
=
"
string
"
?
record
.
queryId
:
null
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
kind
dateAdded
title
urlId
description
smartBookmarkName
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
"
"
)
(
SELECT
id
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
:
description
:
smartBookmarkName
)
{
guid
serverModified
needsMerge
kind
:
SyncedBookmarksMirror
.
KIND
.
QUERY
dateAdded
title
url
:
url
.
href
description
smartBookmarkName
}
)
;
}
async
storeRemoteFolder
(
record
{
needsMerge
}
)
{
let
guid
=
validateGuid
(
record
.
id
)
;
if
(
!
guid
)
{
MirrorLog
.
warn
(
"
Ignoring
folder
with
invalid
ID
"
record
.
id
)
;
return
;
}
if
(
guid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
)
{
MirrorLog
.
warn
(
"
Ignoring
Places
root
record
"
record
)
;
}
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
description
=
validateDescription
(
record
.
description
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
kind
dateAdded
title
description
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
"
"
)
:
description
)
{
guid
serverModified
needsMerge
kind
:
SyncedBookmarksMirror
.
KIND
.
FOLDER
dateAdded
title
description
}
)
;
let
children
=
record
.
children
;
if
(
children
&
&
Array
.
isArray
(
children
)
)
{
for
(
let
position
=
0
;
position
<
children
.
length
;
+
+
position
)
{
await
maybeYield
(
)
;
let
childRecordId
=
children
[
position
]
;
let
childGuid
=
validateGuid
(
childRecordId
)
;
if
(
!
childGuid
)
{
MirrorLog
.
warn
(
"
Ignoring
child
of
folder
{
parentGuid
}
with
"
+
"
invalid
ID
{
childRecordId
}
"
{
parentGuid
:
guid
childRecordId
}
)
;
continue
;
}
if
(
childGuid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
|
|
PlacesUtils
.
bookmarks
.
userContentRoots
.
includes
(
childGuid
)
)
{
MirrorLog
.
warn
(
"
Ignoring
move
for
root
"
childGuid
)
;
continue
;
}
await
this
.
db
.
executeCached
(
REPLACE
INTO
structure
(
guid
parentGuid
position
)
VALUES
(
:
childGuid
:
parentGuid
:
position
)
{
childGuid
parentGuid
:
guid
position
}
)
;
}
}
let
parentGuid
=
validateGuid
(
record
.
parentid
)
;
if
(
parentGuid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
&
&
!
PlacesUtils
.
bookmarks
.
userContentRoots
.
includes
(
guid
)
)
{
await
this
.
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
structure
(
guid
parentGuid
position
)
VALUES
(
:
guid
:
parentGuid
-
1
)
{
guid
parentGuid
}
)
;
}
}
async
storeRemoteLivemark
(
record
{
needsMerge
}
)
{
let
guid
=
validateGuid
(
record
.
id
)
;
if
(
!
guid
)
{
MirrorLog
.
warn
(
"
Ignoring
livemark
with
invalid
ID
"
record
.
id
)
;
return
;
}
let
feedURL
=
validateURL
(
record
.
feedUri
)
;
if
(
!
feedURL
)
{
MirrorLog
.
warn
(
"
Ignoring
livemark
{
guid
}
with
invalid
feed
URL
{
url
}
"
{
guid
url
:
record
.
feedUri
}
)
;
return
;
}
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
description
=
validateDescription
(
record
.
description
)
;
let
siteURL
=
validateURL
(
record
.
siteUri
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
kind
dateAdded
title
description
feedURL
siteURL
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
"
"
)
:
description
:
feedURL
:
siteURL
)
{
guid
serverModified
needsMerge
kind
:
SyncedBookmarksMirror
.
KIND
.
LIVEMARK
dateAdded
title
description
feedURL
:
feedURL
.
href
siteURL
:
siteURL
?
siteURL
.
href
:
null
}
)
;
}
async
storeRemoteSeparator
(
record
{
needsMerge
}
)
{
let
guid
=
validateGuid
(
record
.
id
)
;
if
(
!
guid
)
{
MirrorLog
.
warn
(
"
Ignoring
separator
with
invalid
ID
"
record
.
id
)
;
return
;
}
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
kind
dateAdded
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
)
{
guid
serverModified
needsMerge
kind
:
SyncedBookmarksMirror
.
KIND
.
SEPARATOR
dateAdded
}
)
;
}
async
storeRemoteTombstone
(
record
{
needsMerge
}
)
{
let
guid
=
validateGuid
(
record
.
id
)
;
if
(
!
guid
)
{
MirrorLog
.
warn
(
"
Ignoring
tombstone
with
invalid
ID
"
record
.
id
)
;
return
;
}
if
(
guid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
|
|
PlacesUtils
.
bookmarks
.
userContentRoots
.
includes
(
guid
)
)
{
MirrorLog
.
warn
(
"
Ignoring
tombstone
for
root
"
guid
)
;
return
;
}
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
isDeleted
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
1
)
{
guid
serverModified
:
determineServerModified
(
record
)
needsMerge
}
)
;
}
async
maybeStoreRemoteURL
(
url
)
{
await
this
.
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
urls
(
guid
url
hash
revHost
)
VALUES
(
IFNULL
(
(
SELECT
guid
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
GENERATE_GUID
(
)
)
:
url
hash
(
:
url
)
:
revHost
)
{
url
:
url
.
href
revHost
:
PlacesUtils
.
getReversedHost
(
url
)
}
)
;
}
async
fetchRemoteOrphans
(
)
{
let
infos
=
{
missingParents
:
[
]
missingChildren
:
[
]
parentsWithGaps
:
[
]
}
;
let
orphanRows
=
await
this
.
db
.
execute
(
SELECT
v
.
guid
AS
guid
1
AS
missingParent
0
AS
missingChild
0
AS
parentWithGaps
FROM
items
v
LEFT
JOIN
structure
s
ON
s
.
guid
=
v
.
guid
WHERE
NOT
v
.
isDeleted
AND
s
.
guid
IS
NULL
UNION
ALL
SELECT
s
.
guid
AS
guid
0
AS
missingParent
1
AS
missingChild
0
AS
parentsWithGaps
FROM
structure
s
LEFT
JOIN
items
v
ON
v
.
guid
=
s
.
guid
WHERE
v
.
guid
IS
NULL
UNION
ALL
SELECT
s
.
parentGuid
AS
guid
0
AS
missingParent
0
AS
missingChild
1
AS
parentWithGaps
FROM
structure
s
GROUP
BY
s
.
parentGuid
HAVING
(
sum
(
DISTINCT
position
+
1
)
-
(
count
(
*
)
*
(
count
(
*
)
+
1
)
/
2
)
)
<
>
0
)
;
for
await
(
let
row
of
yieldingIterator
(
orphanRows
)
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
missingParent
=
row
.
getResultByName
(
"
missingParent
"
)
;
if
(
missingParent
)
{
infos
.
missingParents
.
push
(
guid
)
;
}
let
missingChild
=
row
.
getResultByName
(
"
missingChild
"
)
;
if
(
missingChild
)
{
infos
.
missingChildren
.
push
(
guid
)
;
}
let
parentWithGaps
=
row
.
getResultByName
(
"
parentWithGaps
"
)
;
if
(
parentWithGaps
)
{
infos
.
parentsWithGaps
.
push
(
guid
)
;
}
}
return
infos
;
}
async
fetchSyncStatusMismatches
(
)
{
let
infos
=
{
missingLocal
:
[
]
missingRemote
:
[
]
wrongSyncStatus
:
[
]
}
;
let
problemRows
=
await
this
.
db
.
execute
(
SELECT
v
.
guid
1
AS
missingLocal
0
AS
missingRemote
0
AS
wrongSyncStatus
FROM
items
v
LEFT
JOIN
moz_bookmarks
b
ON
b
.
guid
=
v
.
guid
LEFT
JOIN
moz_bookmarks_deleted
d
ON
d
.
guid
=
v
.
guid
WHERE
NOT
v
.
needsMerge
AND
NOT
v
.
isDeleted
AND
b
.
guid
IS
NULL
AND
d
.
guid
IS
NULL
UNION
ALL
SELECT
b
.
guid
0
AS
missingLocal
1
AS
missingRemote
0
AS
wrongSyncStatus
FROM
moz_bookmarks
b
LEFT
JOIN
items
v
ON
v
.
guid
=
b
.
guid
WHERE
EXISTS
(
SELECT
1
FROM
items
WHERE
NOT
needsMerge
AND
guid
<
>
:
rootGuid
)
AND
b
.
syncStatus
=
:
syncStatus
AND
v
.
guid
IS
NULL
UNION
ALL
SELECT
d
.
guid
0
AS
missingLocal
1
AS
missingRemote
0
AS
wrongSyncStatus
FROM
moz_bookmarks_deleted
d
LEFT
JOIN
items
v
ON
v
.
guid
=
d
.
guid
WHERE
EXISTS
(
SELECT
1
FROM
items
WHERE
NOT
needsMerge
AND
guid
<
>
:
rootGuid
)
AND
v
.
guid
IS
NULL
UNION
ALL
SELECT
b
.
guid
0
AS
missingLocal
0
AS
missingRemote
1
AS
wrongSyncStatus
FROM
moz_bookmarks
b
JOIN
items
v
ON
v
.
guid
=
b
.
guid
WHERE
EXISTS
(
SELECT
1
FROM
items
WHERE
NOT
needsMerge
AND
guid
<
>
:
rootGuid
)
AND
b
.
guid
<
>
:
rootGuid
AND
b
.
syncStatus
<
>
:
syncStatus
{
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
}
)
;
for
await
(
let
row
of
yieldingIterator
(
problemRows
)
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
missingLocal
=
row
.
getResultByName
(
"
missingLocal
"
)
;
if
(
missingLocal
)
{
infos
.
missingLocal
.
push
(
guid
)
;
}
let
missingRemote
=
row
.
getResultByName
(
"
missingRemote
"
)
;
if
(
missingRemote
)
{
infos
.
missingRemote
.
push
(
guid
)
;
}
let
wrongSyncStatus
=
row
.
getResultByName
(
"
wrongSyncStatus
"
)
;
if
(
wrongSyncStatus
)
{
infos
.
wrongSyncStatus
.
push
(
guid
)
;
}
}
return
infos
;
}
async
hasChanges
(
)
{
let
rows
=
await
this
.
db
.
execute
(
SELECT
EXISTS
(
SELECT
1
FROM
items
v
LEFT
JOIN
moz_bookmarks
b
ON
v
.
guid
=
b
.
guid
WHERE
v
.
needsMerge
AND
(
NOT
v
.
isDeleted
OR
b
.
guid
NOT
NULL
)
)
OR
EXISTS
(
WITH
RECURSIVE
{
LocalItemsSQLFragment
}
SELECT
1
FROM
localItems
WHERE
syncChangeCounter
>
0
)
OR
EXISTS
(
SELECT
1
FROM
moz_bookmarks_deleted
)
AS
hasChanges
)
;
return
!
!
rows
[
0
]
.
getResultByName
(
"
hasChanges
"
)
;
}
async
fetchRemoteTree
(
remoteTimeSeconds
)
{
let
remoteTree
=
new
BookmarkTree
(
BookmarkNode
.
root
(
)
)
;
let
itemRows
=
await
this
.
db
.
execute
(
SELECT
v
.
guid
IFNULL
(
s
.
parentGuid
:
unfiledGuid
)
AS
parentGuid
IFNULL
(
s
.
position
-
1
)
AS
position
v
.
serverModified
v
.
kind
v
.
needsMerge
FROM
items
v
LEFT
JOIN
structure
s
ON
s
.
guid
=
v
.
guid
WHERE
NOT
v
.
isDeleted
AND
v
.
guid
<
>
:
rootGuid
AND
(
s
.
parentGuid
IS
NOT
NULL
OR
v
.
kind
<
>
:
queryKind
)
ORDER
BY
parentGuid
position
=
-
1
position
v
.
guid
{
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
queryKind
:
SyncedBookmarksMirror
.
KIND
.
QUERY
}
)
;
let
pseudoTree
=
new
Map
(
)
;
for
await
(
let
row
of
yieldingIterator
(
itemRows
)
)
{
let
parentGuid
=
row
.
getResultByName
(
"
parentGuid
"
)
;
let
node
=
BookmarkNode
.
fromRemoteRow
(
row
remoteTimeSeconds
)
;
if
(
pseudoTree
.
has
(
parentGuid
)
)
{
let
nodes
=
pseudoTree
.
get
(
parentGuid
)
;
nodes
.
push
(
node
)
;
}
else
{
pseudoTree
.
set
(
parentGuid
[
node
]
)
;
}
}
await
inflateTree
(
remoteTree
pseudoTree
remoteTree
.
root
)
;
let
tombstoneRows
=
await
this
.
db
.
execute
(
SELECT
guid
FROM
items
WHERE
isDeleted
AND
needsMerge
)
;
for
await
(
let
row
of
yieldingIterator
(
tombstoneRows
)
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
remoteTree
.
noteDeleted
(
guid
)
;
}
return
remoteTree
;
}
async
fetchNewRemoteContents
(
)
{
let
newRemoteContents
=
new
Map
(
)
;
let
rows
=
await
this
.
db
.
execute
(
SELECT
v
.
guid
IFNULL
(
v
.
title
"
"
)
AS
title
u
.
url
v
.
smartBookmarkName
IFNULL
(
s
.
position
-
1
)
AS
position
FROM
items
v
LEFT
JOIN
urls
u
ON
u
.
id
=
v
.
urlId
LEFT
JOIN
structure
s
ON
s
.
guid
=
v
.
guid
LEFT
JOIN
moz_bookmarks
b
ON
b
.
guid
=
v
.
guid
WHERE
NOT
v
.
isDeleted
AND
v
.
needsMerge
AND
b
.
guid
IS
NULL
AND
IFNULL
(
s
.
parentGuid
:
unfiledGuid
)
<
>
:
rootGuid
{
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
}
)
;
for
await
(
let
row
of
yieldingIterator
(
rows
)
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
content
=
BookmarkContent
.
fromRow
(
row
)
;
newRemoteContents
.
set
(
guid
content
)
;
}
return
newRemoteContents
;
}
async
fetchLocalTree
(
localTimeSeconds
)
{
let
localTree
=
new
BookmarkTree
(
BookmarkNode
.
root
(
)
)
;
let
itemRows
=
await
this
.
db
.
execute
(
WITH
RECURSIVE
{
LocalItemsSQLFragment
}
SELECT
s
.
id
s
.
guid
s
.
parentGuid
/
*
Map
Places
item
types
to
Sync
record
kinds
.
*
/
(
CASE
s
.
type
WHEN
:
bookmarkType
THEN
(
CASE
SUBSTR
(
(
SELECT
h
.
url
FROM
moz_places
h
WHERE
h
.
id
=
s
.
placeId
)
1
6
)
/
*
Queries
are
bookmarks
with
a
"
place
:
"
URL
scheme
.
*
/
WHEN
'
place
:
'
THEN
:
queryKind
ELSE
:
bookmarkKind
END
)
WHEN
:
folderType
THEN
(
CASE
WHEN
EXISTS
(
/
*
Livemarks
are
folders
with
a
feed
URL
annotation
.
*
/
SELECT
1
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
a
.
item_id
=
s
.
id
AND
n
.
name
=
:
feedURLAnno
)
THEN
:
livemarkKind
ELSE
:
folderKind
END
)
ELSE
:
separatorKind
END
)
AS
kind
s
.
lastModified
/
1000
AS
localModified
s
.
syncChangeCounter
s
.
level
s
.
isSyncable
FROM
localItems
s
ORDER
BY
s
.
level
s
.
parentId
s
.
position
{
bookmarkType
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
queryKind
:
SyncedBookmarksMirror
.
KIND
.
QUERY
bookmarkKind
:
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
folderType
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
feedURLAnno
:
PlacesUtils
.
LMANNO_FEEDURI
livemarkKind
:
SyncedBookmarksMirror
.
KIND
.
LIVEMARK
folderKind
:
SyncedBookmarksMirror
.
KIND
.
FOLDER
separatorKind
:
SyncedBookmarksMirror
.
KIND
.
SEPARATOR
}
)
;
for
await
(
let
row
of
yieldingIterator
(
itemRows
)
)
{
let
parentGuid
=
row
.
getResultByName
(
"
parentGuid
"
)
;
let
node
=
BookmarkNode
.
fromLocalRow
(
row
localTimeSeconds
)
;
localTree
.
insert
(
parentGuid
node
)
;
}
let
tombstoneRows
=
await
this
.
db
.
execute
(
SELECT
guid
FROM
moz_bookmarks_deleted
)
;
for
await
(
let
row
of
yieldingIterator
(
tombstoneRows
)
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
localTree
.
noteDeleted
(
guid
)
;
}
return
localTree
;
}
async
fetchNewLocalContents
(
)
{
let
newLocalContents
=
new
Map
(
)
;
let
rows
=
await
this
.
db
.
execute
(
SELECT
b
.
guid
IFNULL
(
b
.
title
"
"
)
AS
title
h
.
url
(
SELECT
a
.
content
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
a
.
item_id
=
b
.
id
AND
n
.
name
=
:
smartBookmarkAnno
)
AS
smartBookmarkName
b
.
position
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
LEFT
JOIN
items
v
ON
v
.
guid
=
b
.
guid
WHERE
v
.
guid
IS
NULL
AND
p
.
guid
<
>
:
rootGuid
AND
b
.
syncStatus
<
>
:
syncStatus
{
smartBookmarkAnno
:
PlacesSyncUtils
.
bookmarks
.
SMART_BOOKMARKS_ANNO
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
)
;
for
await
(
let
row
of
yieldingIterator
(
rows
)
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
content
=
BookmarkContent
.
fromRow
(
row
)
;
newLocalContents
.
set
(
guid
content
)
;
}
return
newLocalContents
;
}
async
updateLocalItemsInPlaces
(
mergedRoot
deletions
)
{
MirrorLog
.
trace
(
"
Setting
up
merge
states
table
"
)
;
let
mergeStatesParams
=
[
]
;
for
await
(
let
param
of
yieldingIterator
(
mergedRoot
.
mergeStatesParams
(
)
)
)
{
mergeStatesParams
.
push
(
param
)
;
}
if
(
mergeStatesParams
.
length
)
{
await
this
.
db
.
execute
(
INSERT
INTO
mergeStates
(
localGuid
mergedGuid
parentGuid
level
position
valueState
structureState
)
VALUES
(
IFNULL
(
:
localGuid
:
mergedGuid
)
:
mergedGuid
:
parentGuid
:
level
:
position
:
valueState
:
structureState
)
mergeStatesParams
)
;
}
MirrorLog
.
trace
(
"
Inserting
new
URLs
into
Places
"
)
;
await
this
.
db
.
execute
(
INSERT
OR
IGNORE
INTO
moz_places
(
url
url_hash
rev_host
hidden
frecency
guid
)
SELECT
u
.
url
u
.
hash
u
.
revHost
0
(
CASE
v
.
kind
WHEN
:
queryKind
THEN
0
ELSE
-
1
END
)
IFNULL
(
(
SELECT
h
.
guid
FROM
moz_places
h
WHERE
h
.
url_hash
=
u
.
hash
AND
h
.
url
=
u
.
url
)
u
.
guid
)
FROM
items
v
JOIN
urls
u
ON
u
.
id
=
v
.
urlId
JOIN
mergeStates
r
ON
r
.
mergedGuid
=
v
.
guid
WHERE
r
.
valueState
=
:
valueState
{
queryKind
:
SyncedBookmarksMirror
.
KIND
.
QUERY
valueState
:
BookmarkMergeState
.
TYPE
.
REMOTE
}
)
;
await
this
.
db
.
execute
(
DELETE
FROM
moz_updateoriginsinsert_temp
)
;
MirrorLog
.
trace
(
"
Setting
up
deletions
table
"
)
;
for
(
let
chunk
of
PlacesSyncUtils
.
chunkArray
(
deletions
SQLITE_MAX_VARIABLE_NUMBER
)
)
{
await
this
.
db
.
execute
(
INSERT
INTO
itemsToRemove
(
guid
localLevel
shouldUploadTombstone
)
VALUES
{
chunk
.
map
(
(
{
localLevel
shouldUploadTombstone
}
)
=
>
(
?
{
localLevel
}
{
shouldUploadTombstone
}
)
)
.
join
(
"
"
)
}
chunk
.
map
(
(
{
guid
}
)
=
>
guid
)
)
;
}
MirrorLog
.
trace
(
"
Updating
value
states
for
local
bookmarks
"
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsToMerge
)
;
MirrorLog
.
trace
(
"
Updating
structure
states
for
local
bookmarks
"
)
;
await
this
.
db
.
execute
(
DELETE
FROM
structureToMerge
)
;
MirrorLog
.
trace
(
"
Removing
remotely
deleted
items
from
Places
"
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsToRemove
)
;
}
async
noteObserverChanges
(
observersToNotify
)
{
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
removed
items
"
)
;
let
removedItemRows
=
await
this
.
db
.
execute
(
SELECT
v
.
itemId
AS
id
v
.
parentId
v
.
parentGuid
v
.
position
v
.
type
h
.
url
v
.
guid
v
.
isUntagging
FROM
itemsRemoved
v
LEFT
JOIN
moz_places
h
ON
h
.
id
=
v
.
placeId
ORDER
BY
v
.
level
DESC
v
.
parentId
v
.
position
)
;
for
await
(
let
row
of
yieldingIterator
(
removedItemRows
)
)
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
position
:
row
.
getResultByName
(
"
position
"
)
type
:
row
.
getResultByName
(
"
type
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
isUntagging
:
row
.
getResultByName
(
"
isUntagging
"
)
}
;
observersToNotify
.
noteItemRemoved
(
info
)
;
}
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
changed
GUIDs
"
)
;
let
changedGuidRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
lastModified
b
.
type
b
.
guid
AS
newGuid
c
.
oldGuid
p
.
id
AS
parentId
p
.
guid
AS
parentGuid
FROM
guidsChanged
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
ORDER
BY
c
.
level
p
.
id
b
.
position
)
;
for
await
(
let
row
of
yieldingIterator
(
changedGuidRows
)
)
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
lastModified
:
row
.
getResultByName
(
"
lastModified
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newGuid
:
row
.
getResultByName
(
"
newGuid
"
)
oldGuid
:
row
.
getResultByName
(
"
oldGuid
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
}
;
observersToNotify
.
noteGuidChanged
(
info
)
;
}
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
new
items
"
)
;
let
newItemRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
p
.
id
AS
parentId
b
.
position
b
.
type
h
.
url
IFNULL
(
b
.
title
"
"
)
AS
title
b
.
dateAdded
b
.
guid
p
.
guid
AS
parentGuid
n
.
isTagging
FROM
itemsAdded
n
JOIN
moz_bookmarks
b
ON
b
.
guid
=
n
.
guid
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
ORDER
BY
n
.
level
p
.
id
b
.
position
)
;
for
await
(
let
row
of
yieldingIterator
(
newItemRows
)
)
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
position
:
row
.
getResultByName
(
"
position
"
)
type
:
row
.
getResultByName
(
"
type
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
isTagging
:
row
.
getResultByName
(
"
isTagging
"
)
}
;
observersToNotify
.
noteItemAdded
(
info
)
;
}
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
moved
items
"
)
;
let
movedItemRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
guid
b
.
type
p
.
id
AS
newParentId
c
.
oldParentId
p
.
guid
AS
newParentGuid
c
.
oldParentGuid
b
.
position
AS
newPosition
c
.
oldPosition
h
.
url
FROM
itemsMoved
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
ORDER
BY
c
.
level
newParentId
newPosition
)
;
for
await
(
let
row
of
yieldingIterator
(
movedItemRows
)
)
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newParentId
:
row
.
getResultByName
(
"
newParentId
"
)
oldParentId
:
row
.
getResultByName
(
"
oldParentId
"
)
newParentGuid
:
row
.
getResultByName
(
"
newParentGuid
"
)
oldParentGuid
:
row
.
getResultByName
(
"
oldParentGuid
"
)
newPosition
:
row
.
getResultByName
(
"
newPosition
"
)
oldPosition
:
row
.
getResultByName
(
"
oldPosition
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
}
;
observersToNotify
.
noteItemMoved
(
info
)
;
}
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
changed
items
"
)
;
let
changedItemRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
guid
b
.
lastModified
b
.
type
IFNULL
(
b
.
title
"
"
)
AS
newTitle
IFNULL
(
c
.
oldTitle
"
"
)
AS
oldTitle
h
.
url
AS
newURL
i
.
url
AS
oldURL
p
.
id
AS
parentId
p
.
guid
AS
parentGuid
FROM
itemsChanged
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
LEFT
JOIN
moz_places
i
ON
i
.
id
=
c
.
oldPlaceId
ORDER
BY
c
.
level
p
.
id
b
.
position
)
;
for
await
(
let
row
of
yieldingIterator
(
changedItemRows
)
)
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
lastModified
:
row
.
getResultByName
(
"
lastModified
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newTitle
:
row
.
getResultByName
(
"
newTitle
"
)
oldTitle
:
row
.
getResultByName
(
"
oldTitle
"
)
newURLHref
:
row
.
getResultByName
(
"
newURL
"
)
oldURLHref
:
row
.
getResultByName
(
"
oldURL
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
}
;
observersToNotify
.
noteItemChanged
(
info
)
;
}
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
changed
annos
"
)
;
let
annoRows
=
await
this
.
db
.
execute
(
SELECT
itemId
annoName
wasRemoved
FROM
annosChanged
ORDER
BY
itemId
)
;
for
await
(
let
row
of
yieldingIterator
(
annoRows
)
)
{
let
id
=
row
.
getResultByName
(
"
itemId
"
)
;
let
name
=
row
.
getResultByName
(
"
annoName
"
)
;
if
(
row
.
getResultByName
(
"
wasRemoved
"
)
)
{
observersToNotify
.
noteAnnoRemoved
(
id
name
)
;
}
else
{
observersToNotify
.
noteAnnoSet
(
id
name
)
;
}
}
MirrorLog
.
trace
(
"
Recording
notifications
for
changed
keywords
"
)
;
let
keywordsChangedRows
=
await
this
.
db
.
execute
(
SELECT
EXISTS
(
SELECT
1
FROM
itemsAdded
WHERE
keywordChanged
)
OR
EXISTS
(
SELECT
1
FROM
itemsChanged
WHERE
keywordChanged
)
AS
keywordsChanged
)
;
observersToNotify
.
shouldInvalidateKeywords
=
!
!
keywordsChangedRows
[
0
]
.
getResultByName
(
"
keywordsChanged
"
)
;
}
async
stageItemsToUpload
(
weakUpload
)
{
for
(
let
chunk
of
PlacesSyncUtils
.
chunkArray
(
weakUpload
SQLITE_MAX_VARIABLE_NUMBER
)
)
{
await
this
.
db
.
execute
(
INSERT
INTO
idsToWeaklyUpload
(
id
)
SELECT
b
.
id
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
{
new
Array
(
chunk
.
length
)
.
fill
(
"
?
"
)
.
join
(
"
"
)
}
)
chunk
)
;
}
await
this
.
db
.
execute
(
INSERT
OR
IGNORE
INTO
idsToWeaklyUpload
(
id
)
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
mergeStates
r
ON
r
.
mergedGuid
=
b
.
guid
JOIN
items
v
ON
v
.
guid
=
r
.
mergedGuid
WHERE
r
.
valueState
=
:
valueState
AND
/
*
"
b
.
dateAdded
"
is
in
microseconds
;
"
v
.
dateAdded
"
is
in
milliseconds
.
*
/
b
.
dateAdded
/
1000
<
v
.
dateAdded
{
valueState
:
BookmarkMergeState
.
TYPE
.
REMOTE
}
)
;
await
this
.
db
.
execute
(
WITH
RECURSIVE
{
LocalItemsSQLFragment
}
INSERT
INTO
itemsToUpload
(
id
guid
syncChangeCounter
parentGuid
parentTitle
dateAdded
type
title
isQuery
url
tags
description
smartBookmarkName
keyword
feedURL
siteURL
position
tagFolderName
)
SELECT
s
.
id
s
.
guid
s
.
syncChangeCounter
s
.
parentGuid
s
.
parentTitle
s
.
dateAdded
/
1000
s
.
type
s
.
title
IFNULL
(
SUBSTR
(
h
.
url
1
6
)
=
'
place
:
'
0
)
AS
isQuery
h
.
url
(
SELECT
GROUP_CONCAT
(
t
.
title
'
'
)
FROM
moz_bookmarks
e
JOIN
moz_bookmarks
t
ON
t
.
id
=
e
.
parent
JOIN
moz_bookmarks
r
ON
r
.
id
=
t
.
parent
WHERE
s
.
type
=
:
bookmarkType
AND
r
.
guid
=
:
tagsGuid
AND
e
.
fk
=
h
.
id
)
(
SELECT
a
.
content
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
s
.
type
IN
(
:
bookmarkType
:
folderType
)
AND
a
.
item_id
=
s
.
id
AND
n
.
name
=
:
descriptionAnno
)
(
SELECT
a
.
content
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
a
.
item_id
=
s
.
id
AND
n
.
name
=
:
smartBookmarkAnno
)
(
SELECT
keyword
FROM
moz_keywords
WHERE
place_id
=
h
.
id
)
(
SELECT
a
.
content
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
s
.
type
=
:
folderType
AND
a
.
item_id
=
s
.
id
AND
n
.
name
=
:
feedURLAnno
)
(
SELECT
a
.
content
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
s
.
type
=
:
folderType
AND
a
.
item_id
=
s
.
id
AND
n
.
name
=
:
siteURLAnno
)
s
.
position
(
SELECT
get_query_param
(
substr
(
url
7
)
'
tag
'
)
WHERE
substr
(
h
.
url
1
6
)
=
'
place
:
'
)
FROM
localItems
s
LEFT
JOIN
moz_places
h
ON
h
.
id
=
s
.
placeId
LEFT
JOIN
idsToWeaklyUpload
w
ON
w
.
id
=
s
.
id
WHERE
s
.
syncChangeCounter
>
=
1
OR
w
.
id
NOT
NULL
{
bookmarkType
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
tagsGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
descriptionAnno
:
PlacesSyncUtils
.
bookmarks
.
DESCRIPTION_ANNO
smartBookmarkAnno
:
PlacesSyncUtils
.
bookmarks
.
SMART_BOOKMARKS_ANNO
folderType
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
feedURLAnno
:
PlacesUtils
.
LMANNO_FEEDURI
siteURLAnno
:
PlacesUtils
.
LMANNO_SITEURI
}
)
;
await
this
.
db
.
execute
(
INSERT
INTO
structureToUpload
(
guid
parentId
position
)
SELECT
b
.
guid
b
.
parent
b
.
position
FROM
moz_bookmarks
b
JOIN
itemsToUpload
o
ON
o
.
id
=
b
.
parent
)
;
await
this
.
db
.
execute
(
INSERT
OR
IGNORE
INTO
itemsToUpload
(
guid
syncChangeCounter
isDeleted
)
SELECT
guid
1
1
FROM
moz_bookmarks_deleted
)
;
}
async
fetchLocalChangeRecords
(
)
{
let
changeRecords
=
{
}
;
let
childRecordIdsByLocalParentId
=
new
Map
(
)
;
let
childGuidRows
=
await
this
.
db
.
execute
(
SELECT
parentId
guid
FROM
structureToUpload
ORDER
BY
parentId
position
)
;
for
await
(
let
row
of
yieldingIterator
(
childGuidRows
)
)
{
let
localParentId
=
row
.
getResultByName
(
"
parentId
"
)
;
let
childRecordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
row
.
getResultByName
(
"
guid
"
)
)
;
if
(
childRecordIdsByLocalParentId
.
has
(
localParentId
)
)
{
let
childRecordIds
=
childRecordIdsByLocalParentId
.
get
(
localParentId
)
;
childRecordIds
.
push
(
childRecordId
)
;
}
else
{
childRecordIdsByLocalParentId
.
set
(
localParentId
[
childRecordId
]
)
;
}
}
let
itemRows
=
await
this
.
db
.
execute
(
SELECT
id
syncChangeCounter
guid
isDeleted
type
isQuery
smartBookmarkName
tagFolderName
keyword
tags
url
IFNULL
(
title
"
"
)
AS
title
description
feedURL
siteURL
position
parentGuid
IFNULL
(
parentTitle
"
"
)
AS
parentTitle
dateAdded
FROM
itemsToUpload
)
;
for
await
(
let
row
of
yieldingIterator
(
itemRows
)
)
{
let
syncChangeCounter
=
row
.
getResultByName
(
"
syncChangeCounter
"
)
;
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
recordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
guid
)
;
let
isDeleted
=
row
.
getResultByName
(
"
isDeleted
"
)
;
if
(
isDeleted
)
{
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
{
id
:
recordId
deleted
:
true
}
)
;
continue
;
}
let
parentGuid
=
row
.
getResultByName
(
"
parentGuid
"
)
;
let
parentRecordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
parentGuid
)
;
let
type
=
row
.
getResultByName
(
"
type
"
)
;
switch
(
type
)
{
case
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
:
{
let
isQuery
=
row
.
getResultByName
(
"
isQuery
"
)
;
if
(
isQuery
)
{
let
queryCleartext
=
{
id
:
recordId
type
:
"
query
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
bmkUri
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
queryId
:
row
.
getResultByName
(
"
smartBookmarkName
"
)
folderName
:
row
.
getResultByName
(
"
tagFolderName
"
)
|
|
undefined
}
;
let
description
=
row
.
getResultByName
(
"
description
"
)
;
if
(
description
)
{
queryCleartext
.
description
=
description
;
}
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
queryCleartext
)
;
continue
;
}
let
bookmarkCleartext
=
{
id
:
recordId
type
:
"
bookmark
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
bmkUri
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
}
;
let
description
=
row
.
getResultByName
(
"
description
"
)
;
if
(
description
)
{
bookmarkCleartext
.
description
=
description
;
}
let
keyword
=
row
.
getResultByName
(
"
keyword
"
)
;
if
(
keyword
)
{
bookmarkCleartext
.
keyword
=
keyword
;
}
let
tags
=
row
.
getResultByName
(
"
tags
"
)
;
if
(
tags
)
{
bookmarkCleartext
.
tags
=
tags
.
split
(
"
"
)
;
}
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
bookmarkCleartext
)
;
continue
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
:
{
let
feedURLHref
=
row
.
getResultByName
(
"
feedURL
"
)
;
if
(
feedURLHref
)
{
let
livemarkCleartext
=
{
id
:
recordId
type
:
"
livemark
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
title
:
row
.
getResultByName
(
"
title
"
)
feedUri
:
feedURLHref
}
;
let
description
=
row
.
getResultByName
(
"
description
"
)
;
if
(
description
)
{
livemarkCleartext
.
description
=
description
;
}
let
siteURLHref
=
row
.
getResultByName
(
"
siteURL
"
)
;
if
(
siteURLHref
)
{
livemarkCleartext
.
siteUri
=
siteURLHref
;
}
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
livemarkCleartext
)
;
continue
;
}
let
folderCleartext
=
{
id
:
recordId
type
:
"
folder
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
title
:
row
.
getResultByName
(
"
title
"
)
}
;
let
description
=
row
.
getResultByName
(
"
description
"
)
;
if
(
description
)
{
folderCleartext
.
description
=
description
;
}
let
localId
=
row
.
getResultByName
(
"
id
"
)
;
let
childRecordIds
=
childRecordIdsByLocalParentId
.
get
(
localId
)
;
folderCleartext
.
children
=
childRecordIds
|
|
[
]
;
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
folderCleartext
)
;
continue
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
:
{
let
separatorCleartext
=
{
id
:
recordId
type
:
"
separator
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
pos
:
row
.
getResultByName
(
"
position
"
)
}
;
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
separatorCleartext
)
;
continue
;
}
default
:
throw
new
TypeError
(
"
Can
'
t
create
record
for
unknown
Places
item
"
)
;
}
}
return
changeRecords
;
}
finalize
(
)
{
if
(
!
this
.
finalizePromise
)
{
this
.
finalizePromise
=
(
async
(
)
=
>
{
await
this
.
db
.
close
(
)
;
this
.
finalizeAt
.
removeBlocker
(
this
.
finalizeBound
)
;
}
)
(
)
;
}
return
this
.
finalizePromise
;
}
}
this
.
SyncedBookmarksMirror
=
SyncedBookmarksMirror
;
SyncedBookmarksMirror
.
KIND
=
{
BOOKMARK
:
1
QUERY
:
2
FOLDER
:
3
LIVEMARK
:
4
SEPARATOR
:
5
}
;
SyncedBookmarksMirror
.
META_KEY
=
{
LAST_MODIFIED
:
"
collection
/
lastModified
"
SYNC_ID
:
"
collection
/
syncId
"
}
;
class
ConsistencyError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
ConsistencyError
"
;
}
}
SyncedBookmarksMirror
.
ConsistencyError
=
ConsistencyError
;
class
DatabaseCorruptError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
DatabaseCorruptError
"
;
}
}
function
isDatabaseCorrupt
(
error
)
{
if
(
error
instanceof
DatabaseCorruptError
)
{
return
true
;
}
if
(
error
.
errors
)
{
return
error
.
errors
.
some
(
error
=
>
error
instanceof
Ci
.
mozIStorageError
&
&
(
error
.
result
=
=
Ci
.
mozIStorageError
.
CORRUPT
|
|
error
.
result
=
=
Ci
.
mozIStorageError
.
NOTADB
)
)
;
}
return
false
;
}
async
function
attachAndInitMirrorDatabase
(
db
path
)
{
await
db
.
execute
(
ATTACH
:
path
AS
mirror
{
path
}
)
;
try
{
await
db
.
executeTransaction
(
async
function
(
)
{
let
currentSchemaVersion
=
await
db
.
getSchemaVersion
(
"
mirror
"
)
;
if
(
currentSchemaVersion
>
0
)
{
if
(
currentSchemaVersion
<
MIRROR_SCHEMA_VERSION
)
{
await
migrateMirrorSchema
(
db
currentSchemaVersion
)
;
}
}
else
{
await
initializeMirrorDatabase
(
db
)
;
}
await
db
.
setSchemaVersion
(
MIRROR_SCHEMA_VERSION
"
mirror
"
)
;
await
initializeTempMirrorEntities
(
db
)
;
}
)
;
}
catch
(
ex
)
{
await
db
.
execute
(
DETACH
mirror
)
;
throw
ex
;
}
}
async
function
migrateMirrorSchema
(
db
currentSchemaVersion
)
{
if
(
currentSchemaVersion
<
2
)
{
throw
new
DatabaseCorruptError
(
Can
'
t
migrate
from
schema
version
{
currentSchemaVersion
}
;
too
old
)
;
}
}
async
function
initializeMirrorDatabase
(
db
)
{
await
db
.
execute
(
CREATE
TABLE
mirror
.
meta
(
key
TEXT
PRIMARY
KEY
value
NOT
NULL
)
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
items
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
UNIQUE
NOT
NULL
/
*
The
server
modified
time
in
milliseconds
.
*
/
serverModified
INTEGER
NOT
NULL
DEFAULT
0
needsMerge
BOOLEAN
NOT
NULL
DEFAULT
0
isDeleted
BOOLEAN
NOT
NULL
DEFAULT
0
kind
INTEGER
NOT
NULL
DEFAULT
-
1
/
*
The
creation
date
in
milliseconds
.
*
/
dateAdded
INTEGER
NOT
NULL
DEFAULT
0
title
TEXT
urlId
INTEGER
REFERENCES
urls
(
id
)
ON
DELETE
SET
NULL
keyword
TEXT
description
TEXT
loadInSidebar
BOOLEAN
smartBookmarkName
TEXT
feedURL
TEXT
siteURL
TEXT
/
*
Only
bookmarks
and
queries
must
have
URLs
.
*
/
CHECK
(
CASE
WHEN
kind
IN
(
{
[
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
SyncedBookmarksMirror
.
KIND
.
QUERY
]
.
join
(
"
"
)
}
)
THEN
urlId
NOT
NULL
ELSE
urlId
IS
NULL
END
)
)
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
structure
(
guid
TEXT
NOT
NULL
PRIMARY
KEY
parentGuid
TEXT
NOT
NULL
REFERENCES
items
(
guid
)
ON
DELETE
CASCADE
position
INTEGER
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
urls
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
NOT
NULL
url
TEXT
NOT
NULL
hash
INTEGER
NOT
NULL
revHost
TEXT
NOT
NULL
)
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
tags
(
itemId
INTEGER
NOT
NULL
REFERENCES
items
(
id
)
ON
DELETE
CASCADE
tag
TEXT
NOT
NULL
)
)
;
await
db
.
execute
(
CREATE
INDEX
mirror
.
urlHashes
ON
urls
(
hash
)
)
;
await
createMirrorRoots
(
db
)
;
}
async
function
createMirrorRoots
(
db
)
{
const
syncableRoots
=
[
{
guid
:
PlacesUtils
.
bookmarks
.
rootGuid
parentGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
position
:
-
1
needsMerge
:
false
}
.
.
.
PlacesUtils
.
bookmarks
.
userContentRoots
.
map
(
(
guid
position
)
=
>
{
return
{
guid
parentGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
position
needsMerge
:
true
}
;
}
)
]
;
for
(
let
{
guid
parentGuid
position
needsMerge
}
of
syncableRoots
)
{
await
db
.
executeCached
(
INSERT
INTO
items
(
guid
kind
needsMerge
)
VALUES
(
:
guid
:
kind
:
needsMerge
)
{
guid
kind
:
SyncedBookmarksMirror
.
KIND
.
FOLDER
needsMerge
}
)
;
await
db
.
executeCached
(
INSERT
INTO
structure
(
guid
parentGuid
position
)
VALUES
(
:
guid
:
parentGuid
:
position
)
{
guid
parentGuid
position
}
)
;
}
}
async
function
initializeTempMirrorEntities
(
db
)
{
const
syncedAnnoTriggers
=
[
{
annoName
:
PlacesSyncUtils
.
bookmarks
.
DESCRIPTION_ANNO
columnName
:
"
newDescription
"
type
:
PlacesUtils
.
annotations
.
TYPE_STRING
}
{
annoName
:
PlacesSyncUtils
.
bookmarks
.
SMART_BOOKMARKS_ANNO
columnName
:
"
newSmartBookmarkName
"
type
:
PlacesUtils
.
annotations
.
TYPE_STRING
}
{
annoName
:
PlacesUtils
.
LMANNO_FEEDURI
columnName
:
"
newFeedURL
"
type
:
PlacesUtils
.
annotations
.
TYPE_STRING
}
{
annoName
:
PlacesUtils
.
LMANNO_SITEURI
columnName
:
"
newSiteURL
"
type
:
PlacesUtils
.
annotations
.
TYPE_STRING
}
]
;
await
db
.
execute
(
CREATE
TEMP
TABLE
mergeStates
(
localGuid
TEXT
NOT
NULL
mergedGuid
TEXT
NOT
NULL
parentGuid
TEXT
NOT
NULL
level
INTEGER
NOT
NULL
position
INTEGER
NOT
NULL
valueState
INTEGER
NOT
NULL
structureState
INTEGER
NOT
NULL
PRIMARY
KEY
(
localGuid
mergedGuid
)
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsToRemove
(
guid
TEXT
PRIMARY
KEY
localLevel
INTEGER
NOT
NULL
shouldUploadTombstone
BOOLEAN
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
noteItemRemoved
AFTER
INSERT
ON
itemsToRemove
BEGIN
/
*
Note
that
we
can
'
t
record
item
removed
notifications
in
the
"
removeLocalItems
"
trigger
because
SQLite
can
delete
rows
in
any
order
and
might
fire
the
trigger
for
a
removed
parent
before
its
children
.
*
/
INSERT
INTO
itemsRemoved
(
itemId
parentId
position
type
placeId
guid
parentGuid
level
)
SELECT
b
.
id
b
.
parent
b
.
position
b
.
type
b
.
fk
b
.
guid
p
.
guid
NEW
.
localLevel
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
guid
=
NEW
.
guid
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
removeLocalItems
AFTER
DELETE
ON
itemsToRemove
BEGIN
/
*
Recalculate
frecencies
.
*
/
UPDATE
moz_places
SET
frecency
=
-
1
WHERE
id
=
(
SELECT
fk
FROM
moz_bookmarks
WHERE
guid
=
OLD
.
guid
)
;
/
*
Remove
annos
for
the
deleted
items
.
*
/
DELETE
FROM
moz_items_annos
WHERE
item_id
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
OLD
.
guid
)
;
/
*
Don
'
t
reupload
tombstones
for
items
that
are
already
deleted
on
the
server
.
*
/
DELETE
FROM
moz_bookmarks_deleted
WHERE
NOT
OLD
.
shouldUploadTombstone
AND
guid
=
OLD
.
guid
;
/
*
Upload
tombstones
for
non
-
syncable
items
.
We
can
remove
the
"
shouldUploadTombstone
"
check
and
persist
tombstones
unconditionally
in
bug
1343103
.
*
/
INSERT
OR
IGNORE
INTO
moz_bookmarks_deleted
(
guid
dateRemoved
)
SELECT
OLD
.
guid
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
WHERE
OLD
.
shouldUploadTombstone
;
/
*
Remove
the
item
from
Places
.
*
/
DELETE
FROM
moz_bookmarks
WHERE
guid
=
OLD
.
guid
;
/
*
Flag
applied
deletions
as
merged
.
*
/
UPDATE
items
SET
needsMerge
=
0
WHERE
needsMerge
AND
guid
=
OLD
.
guid
AND
/
*
Don
'
t
flag
tombstones
for
items
that
don
'
t
exist
in
the
local
tree
.
This
can
be
removed
once
we
persist
tombstones
in
bug
1343103
.
*
/
(
NOT
isDeleted
OR
OLD
.
localLevel
>
-
1
)
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
VIEW
itemsToMerge
(
localId
remoteId
hasRemoteValue
newLevel
oldGuid
newGuid
newType
newDateAddedMicroseconds
newTitle
oldPlaceId
newPlaceId
newKeyword
newDescription
newSmartBookmarkName
newFeedURL
newSiteURL
)
AS
SELECT
b
.
id
v
.
id
r
.
valueState
=
{
BookmarkMergeState
.
TYPE
.
REMOTE
}
r
.
level
r
.
localGuid
r
.
mergedGuid
(
CASE
WHEN
v
.
kind
IN
(
{
[
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
SyncedBookmarksMirror
.
KIND
.
QUERY
]
.
join
(
"
"
)
}
)
THEN
{
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
}
WHEN
v
.
kind
IN
(
{
[
SyncedBookmarksMirror
.
KIND
.
FOLDER
SyncedBookmarksMirror
.
KIND
.
LIVEMARK
]
.
join
(
"
"
)
}
)
THEN
{
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
ELSE
{
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
}
END
)
/
*
Take
the
older
creation
date
.
"
b
.
dateAdded
"
is
in
microseconds
;
"
v
.
dateAdded
"
is
in
milliseconds
.
*
/
(
CASE
WHEN
b
.
dateAdded
/
1000
<
v
.
dateAdded
THEN
b
.
dateAdded
ELSE
v
.
dateAdded
*
1000
END
)
v
.
title
h
.
id
u
.
newPlaceId
v
.
keyword
v
.
description
v
.
smartBookmarkName
v
.
feedURL
v
.
siteURL
FROM
items
v
JOIN
mergeStates
r
ON
r
.
mergedGuid
=
v
.
guid
LEFT
JOIN
moz_bookmarks
b
ON
b
.
guid
=
r
.
localGuid
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
LEFT
JOIN
(
SELECT
h
.
id
AS
newPlaceId
u
.
id
AS
urlId
FROM
urls
u
JOIN
moz_places
h
ON
h
.
url_hash
=
u
.
hash
AND
h
.
url
=
u
.
url
)
u
ON
u
.
urlId
=
v
.
urlId
WHERE
r
.
mergedGuid
<
>
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
mergeGuids
INSTEAD
OF
DELETE
ON
itemsToMerge
BEGIN
/
*
We
update
GUIDs
here
instead
of
in
the
"
updateExistingLocalItems
"
trigger
because
deduped
items
where
we
'
re
keeping
the
local
value
state
won
'
t
have
"
hasRemoteValue
"
set
.
*
/
UPDATE
moz_bookmarks
SET
guid
=
OLD
.
newGuid
syncStatus
=
{
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
WHERE
OLD
.
oldGuid
<
>
OLD
.
newGuid
AND
id
=
OLD
.
localId
;
/
*
Record
item
changed
notifications
for
the
updated
GUIDs
.
*
/
INSERT
INTO
guidsChanged
(
itemId
oldGuid
level
)
SELECT
OLD
.
localId
OLD
.
oldGuid
OLD
.
newLevel
WHERE
OLD
.
oldGuid
<
>
OLD
.
newGuid
;
/
*
Drop
local
tombstones
for
revived
remote
items
.
*
/
DELETE
FROM
moz_bookmarks_deleted
WHERE
guid
=
OLD
.
newGuid
;
/
*
Flag
the
remote
item
as
merged
.
*
/
UPDATE
items
SET
needsMerge
=
0
WHERE
needsMerge
AND
id
=
OLD
.
remoteId
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
insertNewLocalItems
INSTEAD
OF
DELETE
ON
itemsToMerge
WHEN
OLD
.
localId
IS
NULL
BEGIN
/
*
Record
an
item
added
notification
for
the
new
item
.
*
/
INSERT
INTO
itemsAdded
(
guid
keywordChanged
level
)
VALUES
(
OLD
.
newGuid
OLD
.
newKeyword
NOT
NULL
OR
EXISTS
(
SELECT
1
FROM
moz_keywords
WHERE
place_id
=
OLD
.
newPlaceId
OR
keyword
=
OLD
.
newKeyword
)
OLD
.
newLevel
)
;
/
*
Sync
associates
keywords
with
bookmarks
and
doesn
'
t
sync
POST
data
;
Places
associates
keywords
with
(
URL
POST
data
)
pairs
and
multiple
bookmarks
may
have
the
same
URL
.
For
simplicity
we
bump
the
change
counter
for
all
local
bookmarks
with
the
remote
URL
(
bug
1328737
)
then
remove
all
local
keywords
from
remote
URLs
and
the
remote
keyword
from
local
URLs
.
*
/
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
fk
IN
(
/
*
We
intentionally
use
"
place_id
=
OLD
.
newPlaceId
"
in
the
subquery
instead
of
"
fk
=
OLD
.
newPlaceId
OR
fk
IN
(
.
.
.
)
"
in
the
WHERE
clause
above
because
we
only
want
to
bump
the
counter
if
the
URL
has
keywords
.
*
/
SELECT
place_id
FROM
moz_keywords
WHERE
place_id
=
OLD
.
newPlaceId
OR
keyword
=
OLD
.
newKeyword
)
;
/
*
Remove
the
new
keyword
from
existing
items
and
all
keywords
from
the
new
URL
.
*
/
DELETE
FROM
moz_keywords
WHERE
place_id
=
OLD
.
newPlaceId
OR
keyword
=
OLD
.
newKeyword
;
/
*
Remove
existing
tags
for
the
new
URL
.
*
/
DELETE
FROM
localTags
WHERE
placeId
=
OLD
.
newPlaceId
;
/
*
Insert
the
new
item
using
"
-
1
"
as
the
placeholder
parent
and
position
.
We
'
ll
update
these
later
in
the
"
updateLocalStructure
"
trigger
.
*
/
INSERT
INTO
moz_bookmarks
(
guid
parent
position
type
fk
title
dateAdded
lastModified
syncStatus
syncChangeCounter
)
VALUES
(
OLD
.
newGuid
-
1
-
1
OLD
.
newType
OLD
.
newPlaceId
OLD
.
newTitle
OLD
.
newDateAddedMicroseconds
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
{
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
0
)
;
/
*
Insert
a
new
keyword
for
the
new
URL
if
one
is
set
.
*
/
INSERT
OR
IGNORE
INTO
moz_keywords
(
keyword
place_id
post_data
)
SELECT
OLD
.
newKeyword
OLD
.
newPlaceId
'
'
WHERE
OLD
.
newKeyword
NOT
NULL
;
/
*
Insert
new
tags
for
the
new
URL
.
*
/
INSERT
INTO
localTags
(
tag
placeId
)
SELECT
t
.
tag
OLD
.
newPlaceId
FROM
tags
t
WHERE
t
.
itemId
=
OLD
.
remoteId
;
/
*
Insert
new
synced
annos
.
These
are
almost
identical
to
the
statements
for
updates
except
we
need
an
additional
subquery
to
fetch
the
new
item
'
s
ID
.
We
can
also
skip
removing
existing
annos
.
*
/
INSERT
OR
IGNORE
INTO
moz_anno_attributes
(
name
)
VALUES
{
syncedAnnoTriggers
.
map
(
annoTrigger
=
>
(
'
{
annoTrigger
.
annoName
}
'
)
)
.
join
(
"
"
)
}
;
{
syncedAnnoTriggers
.
map
(
annoTrigger
=
>
INSERT
INTO
moz_items_annos
(
item_id
anno_attribute_id
content
flags
expiration
type
lastModified
dateAdded
)
SELECT
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
OLD
.
newGuid
)
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
'
{
annoTrigger
.
annoName
}
'
)
OLD
.
{
annoTrigger
.
columnName
}
0
{
PlacesUtils
.
annotations
.
EXPIRE_NEVER
}
{
annoTrigger
.
type
}
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
WHERE
OLD
.
{
annoTrigger
.
columnName
}
NOT
NULL
;
/
*
Record
an
anno
set
notification
for
the
new
synced
anno
.
*
/
REPLACE
INTO
annosChanged
(
itemId
annoName
wasRemoved
)
SELECT
b
.
id
'
{
annoTrigger
.
annoName
}
'
0
FROM
moz_bookmarks
b
WHERE
b
.
guid
=
OLD
.
newGuid
AND
OLD
.
{
annoTrigger
.
columnName
}
NOT
NULL
;
)
.
join
(
"
"
)
}
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
updateExistingLocalItems
INSTEAD
OF
DELETE
ON
itemsToMerge
WHEN
OLD
.
hasRemoteValue
AND
OLD
.
localId
NOT
NULL
BEGIN
/
*
Record
an
item
changed
notification
for
the
existing
item
.
*
/
INSERT
INTO
itemsChanged
(
itemId
oldTitle
oldPlaceId
keywordChanged
level
)
SELECT
id
title
OLD
.
oldPlaceId
OLD
.
newKeyword
NOT
NULL
OR
EXISTS
(
SELECT
1
FROM
moz_keywords
WHERE
place_id
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
OR
keyword
=
OLD
.
newKeyword
)
OLD
.
newLevel
FROM
moz_bookmarks
WHERE
id
=
OLD
.
localId
;
UPDATE
moz_bookmarks
SET
title
=
OLD
.
newTitle
dateAdded
=
OLD
.
newDateAddedMicroseconds
lastModified
=
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
syncStatus
=
{
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
syncChangeCounter
=
0
WHERE
id
=
OLD
.
localId
;
/
*
Bump
the
change
counter
for
items
with
the
old
URL
new
URL
and
new
keyword
.
*
/
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
fk
IN
(
SELECT
place_id
FROM
moz_keywords
WHERE
place_id
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
OR
keyword
=
OLD
.
newKeyword
)
;
/
*
Remove
the
new
keyword
from
existing
items
and
all
keywords
from
the
old
and
new
URLs
.
*
/
DELETE
FROM
moz_keywords
WHERE
place_id
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
OR
keyword
=
OLD
.
newKeyword
;
/
*
Remove
existing
tags
.
*
/
DELETE
FROM
localTags
WHERE
placeId
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
;
/
*
Update
the
URL
and
recalculate
frecency
.
It
'
s
important
we
do
this
*
after
*
removing
old
keywords
and
*
before
*
inserting
new
ones
so
that
the
above
statements
select
the
correct
affected
items
.
*
/
UPDATE
moz_bookmarks
SET
fk
=
OLD
.
newPlaceId
WHERE
OLD
.
oldPlaceId
<
>
OLD
.
newPlaceId
AND
id
=
OLD
.
localId
;
UPDATE
moz_places
SET
frecency
=
-
1
WHERE
OLD
.
oldPlaceId
<
>
OLD
.
newPlaceId
AND
id
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
;
/
*
Insert
a
new
keyword
for
the
new
URL
if
one
is
set
.
*
/
INSERT
OR
IGNORE
INTO
moz_keywords
(
keyword
place_id
post_data
)
SELECT
OLD
.
newKeyword
OLD
.
newPlaceId
'
'
WHERE
OLD
.
newKeyword
NOT
NULL
;
/
*
Insert
new
tags
for
the
new
URL
.
*
/
INSERT
INTO
localTags
(
tag
placeId
)
SELECT
t
.
tag
OLD
.
newPlaceId
FROM
tags
t
WHERE
t
.
itemId
=
OLD
.
remoteId
;
/
*
Record
anno
removed
notifications
for
the
synced
annos
.
*
/
REPLACE
INTO
annosChanged
(
itemId
annoName
wasRemoved
)
SELECT
a
.
item_id
n
.
name
1
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
item_id
=
OLD
.
localId
AND
anno_attribute_id
IN
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
IN
(
{
syncedAnnoTriggers
.
map
(
annoTrigger
=
>
'
{
annoTrigger
.
annoName
}
'
)
.
join
(
"
"
)
}
)
)
;
/
*
Remove
existing
synced
annos
.
*
/
DELETE
FROM
moz_items_annos
WHERE
item_id
=
OLD
.
localId
AND
anno_attribute_id
IN
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
IN
(
{
syncedAnnoTriggers
.
map
(
annoTrigger
=
>
'
{
annoTrigger
.
annoName
}
'
)
.
join
(
"
"
)
}
)
)
;
/
*
Insert
new
synced
annos
.
*
/
INSERT
OR
IGNORE
INTO
moz_anno_attributes
(
name
)
VALUES
{
syncedAnnoTriggers
.
map
(
annoTrigger
=
>
(
'
{
annoTrigger
.
annoName
}
'
)
)
.
join
(
"
"
)
}
;
{
syncedAnnoTriggers
.
map
(
annoTrigger
=
>
INSERT
INTO
moz_items_annos
(
item_id
anno_attribute_id
content
flags
expiration
type
lastModified
dateAdded
)
SELECT
OLD
.
localId
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
'
{
annoTrigger
.
annoName
}
'
)
OLD
.
{
annoTrigger
.
columnName
}
0
{
PlacesUtils
.
annotations
.
EXPIRE_NEVER
}
{
annoTrigger
.
type
}
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
WHERE
OLD
.
{
annoTrigger
.
columnName
}
NOT
NULL
;
/
*
Record
an
anno
set
notification
for
the
new
synced
anno
.
*
/
REPLACE
INTO
annosChanged
(
itemId
annoName
wasRemoved
)
SELECT
OLD
.
localId
'
{
annoTrigger
.
annoName
}
'
0
WHERE
OLD
.
{
annoTrigger
.
columnName
}
NOT
NULL
;
)
.
join
(
"
"
)
}
END
)
;
await
db
.
execute
(
CREATE
TEMP
VIEW
structureToMerge
(
localId
hasNewStructure
isRoot
oldParentId
newParentId
oldPosition
newPosition
newLevel
)
AS
SELECT
b
.
id
r
.
structureState
=
{
BookmarkMergeState
.
TYPE
.
NEW
}
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
IN
(
r
.
mergedGuid
r
.
parentGuid
)
b
.
parent
p
.
id
b
.
position
r
.
position
r
.
level
FROM
moz_bookmarks
b
JOIN
mergeStates
r
ON
r
.
mergedGuid
=
b
.
guid
JOIN
moz_bookmarks
p
ON
p
.
guid
=
r
.
parentGuid
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
updateLocalStructure
INSTEAD
OF
DELETE
ON
structureToMerge
WHEN
NOT
OLD
.
isRoot
BEGIN
UPDATE
moz_bookmarks
SET
parent
=
OLD
.
newParentId
WHERE
id
=
OLD
.
localId
AND
parent
<
>
OLD
.
newParentId
;
UPDATE
moz_bookmarks
SET
position
=
OLD
.
newPosition
WHERE
id
=
OLD
.
localId
AND
position
<
>
OLD
.
newPosition
;
/
*
Record
observer
notifications
for
moved
items
.
We
ignore
items
that
didn
'
t
move
and
items
with
placeholder
parents
and
positions
of
"
-
1
"
since
they
'
re
new
.
*
/
INSERT
INTO
itemsMoved
(
itemId
oldParentId
oldParentGuid
oldPosition
level
)
SELECT
OLD
.
localId
OLD
.
oldParentId
p
.
guid
OLD
.
oldPosition
OLD
.
newLevel
FROM
moz_bookmarks
p
WHERE
p
.
id
=
OLD
.
oldParentId
AND
-
1
NOT
IN
(
OLD
.
oldParentId
OLD
.
oldPosition
)
AND
(
OLD
.
oldParentId
<
>
OLD
.
newParentId
OR
OLD
.
oldPosition
<
>
OLD
.
newPosition
)
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
flagNewStructure
INSTEAD
OF
DELETE
ON
structureToMerge
WHEN
OLD
.
hasNewStructure
BEGIN
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
id
=
OLD
.
localId
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
VIEW
localTags
(
tagEntryId
tagEntryGuid
tagFolderId
tagFolderGuid
tagEntryPosition
tagEntryType
tag
placeId
)
AS
SELECT
b
.
id
b
.
guid
p
.
id
p
.
guid
b
.
position
b
.
type
p
.
title
b
.
fk
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
moz_bookmarks
r
ON
r
.
id
=
p
.
parent
WHERE
b
.
type
=
{
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
}
AND
r
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
untagLocalPlace
INSTEAD
OF
DELETE
ON
localTags
BEGIN
/
*
Record
an
item
removed
notification
for
the
tag
entry
.
*
/
INSERT
INTO
itemsRemoved
(
itemId
parentId
position
type
placeId
guid
parentGuid
isUntagging
)
VALUES
(
OLD
.
tagEntryId
OLD
.
tagFolderId
OLD
.
tagEntryPosition
OLD
.
tagEntryType
OLD
.
placeId
OLD
.
tagEntryGuid
OLD
.
tagFolderGuid
1
)
;
DELETE
FROM
moz_bookmarks
WHERE
id
=
OLD
.
tagEntryId
;
/
*
Fix
the
positions
of
the
sibling
tag
entries
.
*
/
UPDATE
moz_bookmarks
SET
position
=
position
-
1
WHERE
parent
=
OLD
.
tagFolderId
AND
position
>
OLD
.
tagEntryPosition
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
tagLocalPlace
INSTEAD
OF
INSERT
ON
localTags
BEGIN
/
*
Ensure
the
tag
folder
exists
.
*
/
INSERT
OR
IGNORE
INTO
moz_bookmarks
(
guid
parent
position
type
title
dateAdded
lastModified
)
VALUES
(
IFNULL
(
(
SELECT
b
.
guid
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
title
=
NEW
.
tag
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
GENERATE_GUID
(
)
)
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
(
SELECT
COUNT
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
{
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
NEW
.
tag
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
)
;
/
*
Record
an
item
added
notification
if
we
created
a
tag
folder
.
"
CHANGES
(
)
"
returns
the
number
of
rows
affected
by
the
INSERT
above
:
1
if
we
created
the
folder
or
0
if
the
folder
already
existed
.
*
/
INSERT
INTO
itemsAdded
(
guid
isTagging
)
SELECT
b
.
guid
1
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
CHANGES
(
)
>
0
AND
b
.
title
=
NEW
.
tag
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
;
/
*
Add
a
tag
entry
for
the
URL
under
the
tag
folder
.
Omitting
the
place
ID
creates
a
tag
folder
without
tagging
the
URL
.
*
/
INSERT
OR
IGNORE
INTO
moz_bookmarks
(
guid
parent
position
type
fk
dateAdded
lastModified
)
SELECT
GENERATE_GUID
(
)
(
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
AND
b
.
title
=
NEW
.
tag
)
(
SELECT
COUNT
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
moz_bookmarks
r
ON
r
.
id
=
p
.
parent
WHERE
p
.
title
=
NEW
.
tag
AND
r
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
{
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
}
NEW
.
placeId
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
WHERE
NEW
.
placeId
NOT
NULL
;
/
*
Record
an
item
added
notification
for
the
tag
entry
.
*
/
INSERT
INTO
itemsAdded
(
guid
isTagging
)
SELECT
b
.
guid
1
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
moz_bookmarks
r
ON
r
.
id
=
p
.
parent
WHERE
b
.
fk
=
NEW
.
placeId
AND
p
.
title
=
NEW
.
tag
AND
r
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsAdded
(
guid
TEXT
PRIMARY
KEY
isTagging
BOOLEAN
NOT
NULL
DEFAULT
0
keywordChanged
BOOLEAN
NOT
NULL
DEFAULT
0
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
guidsChanged
(
itemId
INTEGER
NOT
NULL
oldGuid
TEXT
NOT
NULL
level
INTEGER
NOT
NULL
DEFAULT
-
1
PRIMARY
KEY
(
itemId
oldGuid
)
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsChanged
(
itemId
INTEGER
PRIMARY
KEY
oldTitle
TEXT
oldPlaceId
INTEGER
keywordChanged
BOOLEAN
NOT
NULL
DEFAULT
0
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsMoved
(
itemId
INTEGER
PRIMARY
KEY
oldParentId
INTEGER
NOT
NULL
oldParentGuid
TEXT
NOT
NULL
oldPosition
INTEGER
NOT
NULL
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsRemoved
(
guid
TEXT
PRIMARY
KEY
itemId
INTEGER
NOT
NULL
parentId
INTEGER
NOT
NULL
position
INTEGER
NOT
NULL
type
INTEGER
NOT
NULL
placeId
INTEGER
parentGuid
TEXT
NOT
NULL
/
*
We
record
the
original
level
of
the
removed
item
in
the
tree
so
that
we
can
notify
children
before
parents
.
*
/
level
INTEGER
NOT
NULL
DEFAULT
-
1
isUntagging
BOOLEAN
NOT
NULL
DEFAULT
0
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
annosChanged
(
itemId
INTEGER
NOT
NULL
annoName
TEXT
NOT
NULL
wasRemoved
BOOLEAN
NOT
NULL
PRIMARY
KEY
(
itemId
annoName
wasRemoved
)
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
idsToWeaklyUpload
(
id
INTEGER
PRIMARY
KEY
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsToUpload
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
UNIQUE
NOT
NULL
syncChangeCounter
INTEGER
NOT
NULL
isDeleted
BOOLEAN
NOT
NULL
DEFAULT
0
parentGuid
TEXT
parentTitle
TEXT
dateAdded
INTEGER
/
*
In
milliseconds
.
*
/
type
INTEGER
title
TEXT
isQuery
BOOLEAN
NOT
NULL
DEFAULT
0
url
TEXT
tags
TEXT
description
TEXT
smartBookmarkName
TEXT
tagFolderName
TEXT
keyword
TEXT
feedURL
TEXT
siteURL
TEXT
position
INTEGER
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
structureToUpload
(
guid
TEXT
PRIMARY
KEY
parentId
INTEGER
NOT
NULL
REFERENCES
itemsToUpload
(
id
)
ON
DELETE
CASCADE
position
INTEGER
NOT
NULL
)
WITHOUT
ROWID
)
;
}
async
function
resetMirror
(
db
)
{
await
db
.
execute
(
DELETE
FROM
meta
)
;
await
db
.
execute
(
DELETE
FROM
structure
)
;
await
db
.
execute
(
DELETE
FROM
items
)
;
await
db
.
execute
(
DELETE
FROM
urls
)
;
await
createMirrorRoots
(
db
)
;
}
function
validateGuid
(
recordId
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
recordId
)
;
return
PlacesUtils
.
isValidGuid
(
guid
)
?
guid
:
null
;
}
function
determineServerModified
(
record
)
{
return
Math
.
max
(
record
.
modified
*
1000
0
)
|
|
0
;
}
function
determineDateAdded
(
record
)
{
let
serverModified
=
determineServerModified
(
record
)
;
return
PlacesSyncUtils
.
bookmarks
.
ratchetTimestampBackwards
(
record
.
dateAdded
serverModified
)
;
}
function
validateTitle
(
rawTitle
)
{
if
(
typeof
rawTitle
!
=
"
string
"
|
|
!
rawTitle
)
{
return
null
;
}
return
rawTitle
.
slice
(
0
DB_TITLE_LENGTH_MAX
)
;
}
function
validateURL
(
rawURL
)
{
if
(
typeof
rawURL
!
=
"
string
"
|
|
rawURL
.
length
>
DB_URL_LENGTH_MAX
)
{
return
null
;
}
let
url
=
null
;
try
{
url
=
new
URL
(
rawURL
)
;
}
catch
(
ex
)
{
}
return
url
;
}
function
validateDescription
(
rawDescription
)
{
if
(
typeof
rawDescription
!
=
"
string
"
|
|
!
rawDescription
)
{
return
null
;
}
return
rawDescription
.
slice
(
0
DB_DESCRIPTION_LENGTH_MAX
)
;
}
function
validateKeyword
(
rawKeyword
)
{
if
(
typeof
rawKeyword
!
=
"
string
"
)
{
return
null
;
}
let
keyword
=
rawKeyword
.
trim
(
)
;
return
keyword
?
keyword
.
toLowerCase
(
)
:
null
;
}
function
validateTag
(
rawTag
)
{
if
(
typeof
rawTag
!
=
"
string
"
)
{
return
null
;
}
let
tag
=
rawTag
.
trim
(
)
;
if
(
!
tag
|
|
tag
.
length
>
Ci
.
nsITaggingService
.
MAX_TAG_LENGTH
)
{
return
null
;
}
return
tag
;
}
async
function
inflateTree
(
tree
pseudoTree
parentNode
)
{
let
nodes
=
pseudoTree
.
get
(
parentNode
.
guid
)
;
if
(
nodes
)
{
for
(
let
node
of
nodes
)
{
await
maybeYield
(
)
;
node
.
level
=
parentNode
.
level
+
1
;
node
.
isSyncable
=
parentNode
=
=
tree
.
root
?
PlacesUtils
.
bookmarks
.
userContentRoots
.
includes
(
node
.
guid
)
:
parentNode
.
isSyncable
;
tree
.
insert
(
parentNode
.
guid
node
)
;
await
inflateTree
(
tree
pseudoTree
node
)
;
}
}
}
async
function
withTiming
(
name
func
recordTiming
)
{
MirrorLog
.
debug
(
name
)
;
let
startTime
=
Cu
.
now
(
)
;
let
result
=
await
func
(
)
;
let
elapsedTime
=
Cu
.
now
(
)
-
startTime
;
MirrorLog
.
trace
(
{
name
}
took
{
elapsedTime
.
toFixed
(
3
)
}
ms
)
;
recordTiming
(
elapsedTime
result
)
;
return
result
;
}
class
BookmarkContent
{
constructor
(
title
urlHref
smartBookmarkName
position
)
{
this
.
title
=
title
;
this
.
urlHref
=
urlHref
;
this
.
smartBookmarkName
=
smartBookmarkName
;
this
.
position
=
position
;
}
static
fromRow
(
row
)
{
let
title
=
row
.
getResultByName
(
"
title
"
)
;
let
urlHref
=
row
.
getResultByName
(
"
url
"
)
;
let
smartBookmarkName
=
row
.
getResultByName
(
"
smartBookmarkName
"
)
;
let
position
=
row
.
getResultByName
(
"
position
"
)
;
return
new
BookmarkContent
(
title
urlHref
smartBookmarkName
position
)
;
}
}
function
makeDupeKey
(
node
content
)
{
switch
(
node
.
kind
)
{
case
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
:
return
JSON
.
stringify
(
[
node
.
kind
content
.
title
content
.
urlHref
]
)
;
case
SyncedBookmarksMirror
.
KIND
.
QUERY
:
if
(
content
.
smartBookmarkName
)
{
return
JSON
.
stringify
(
[
node
.
kind
content
.
smartBookmarkName
]
)
;
}
return
JSON
.
stringify
(
[
node
.
kind
content
.
title
content
.
urlHref
]
)
;
case
SyncedBookmarksMirror
.
KIND
.
FOLDER
:
case
SyncedBookmarksMirror
.
KIND
.
LIVEMARK
:
return
JSON
.
stringify
(
[
node
.
kind
content
.
title
]
)
;
case
SyncedBookmarksMirror
.
KIND
.
SEPARATOR
:
return
JSON
.
stringify
(
[
node
.
kind
content
.
position
]
)
;
}
return
JSON
.
stringify
(
[
node
.
guid
]
)
;
}
class
BookmarkMergeState
{
constructor
(
value
structure
=
value
)
{
this
.
value
=
value
;
this
.
structure
=
structure
;
}
static
new
(
oldState
)
{
return
new
BookmarkMergeState
(
oldState
.
value
BookmarkMergeState
.
TYPE
.
NEW
)
;
}
toString
(
)
{
return
(
{
this
.
valueToString
(
)
}
;
{
this
.
structureToString
(
)
}
)
;
}
valueToString
(
)
{
switch
(
this
.
value
)
{
case
BookmarkMergeState
.
TYPE
.
LOCAL
:
return
"
Value
:
Local
"
;
case
BookmarkMergeState
.
TYPE
.
REMOTE
:
return
"
Value
:
Remote
"
;
}
return
"
Value
:
?
"
;
}
structureToString
(
)
{
switch
(
this
.
structure
)
{
case
BookmarkMergeState
.
TYPE
.
LOCAL
:
return
"
Structure
:
Local
"
;
case
BookmarkMergeState
.
TYPE
.
REMOTE
:
return
"
Structure
:
Remote
"
;
case
BookmarkMergeState
.
TYPE
.
NEW
:
return
"
Structure
:
New
"
;
}
return
"
Structure
:
?
"
;
}
toJSON
(
)
{
return
this
.
toString
(
)
;
}
}
BookmarkMergeState
.
TYPE
=
{
LOCAL
:
1
REMOTE
:
2
NEW
:
3
}
;
BookmarkMergeState
.
local
=
new
BookmarkMergeState
(
BookmarkMergeState
.
TYPE
.
LOCAL
)
;
BookmarkMergeState
.
remote
=
new
BookmarkMergeState
(
BookmarkMergeState
.
TYPE
.
REMOTE
)
;
class
BookmarkNode
{
constructor
(
guid
kind
{
age
=
0
needsMerge
=
false
level
=
0
isSyncable
=
true
}
=
{
}
)
{
this
.
guid
=
guid
;
this
.
kind
=
kind
;
this
.
age
=
age
;
this
.
needsMerge
=
needsMerge
;
this
.
level
=
level
;
this
.
isSyncable
=
isSyncable
;
this
.
children
=
[
]
;
}
static
root
(
)
{
let
guid
=
PlacesUtils
.
bookmarks
.
rootGuid
;
return
new
BookmarkNode
(
guid
SyncedBookmarksMirror
.
KIND
.
FOLDER
)
;
}
static
fromLocalRow
(
row
localTimeSeconds
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
localModified
=
row
.
getResultByName
(
"
localModified
"
)
;
let
age
=
Math
.
max
(
localTimeSeconds
-
localModified
/
1000
0
)
|
|
0
;
let
kind
=
row
.
getResultByName
(
"
kind
"
)
;
let
level
=
row
.
getResultByName
(
"
level
"
)
;
let
isSyncable
=
!
!
row
.
getResultByName
(
"
isSyncable
"
)
;
let
syncChangeCounter
=
row
.
getResultByName
(
"
syncChangeCounter
"
)
;
let
needsMerge
=
syncChangeCounter
>
0
;
return
new
BookmarkNode
(
guid
kind
{
age
needsMerge
level
isSyncable
}
)
;
}
static
fromRemoteRow
(
row
remoteTimeSeconds
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
serverModified
=
row
.
getResultByName
(
"
serverModified
"
)
;
let
age
=
Math
.
max
(
remoteTimeSeconds
-
serverModified
/
1000
0
)
|
|
0
;
let
kind
=
row
.
getResultByName
(
"
kind
"
)
;
let
needsMerge
=
!
!
row
.
getResultByName
(
"
needsMerge
"
)
;
return
new
BookmarkNode
(
guid
kind
{
age
needsMerge
}
)
;
}
isFolder
(
)
{
return
this
.
kind
=
=
SyncedBookmarksMirror
.
KIND
.
FOLDER
;
}
newerThan
(
otherNode
)
{
return
this
.
age
<
otherNode
.
age
;
}
hasCompatibleKind
(
remoteNode
)
{
if
(
this
.
kind
=
=
remoteNode
.
kind
)
{
return
true
;
}
if
(
(
this
.
kind
=
=
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
&
&
remoteNode
.
kind
=
=
SyncedBookmarksMirror
.
KIND
.
QUERY
)
|
|
(
this
.
kind
=
=
SyncedBookmarksMirror
.
KIND
.
QUERY
&
&
remoteNode
.
kind
=
=
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
)
)
{
return
true
;
}
if
(
this
.
kind
=
=
SyncedBookmarksMirror
.
KIND
.
FOLDER
&
&
remoteNode
.
kind
=
=
SyncedBookmarksMirror
.
KIND
.
LIVEMARK
)
{
return
true
;
}
return
false
;
}
toASCIITreeString
(
prefix
=
"
"
)
{
if
(
!
this
.
isFolder
(
)
)
{
return
prefix
+
"
-
"
+
this
.
toString
(
)
;
}
return
prefix
+
"
+
"
+
this
.
toString
(
)
+
"
\
n
"
+
this
.
children
.
map
(
childNode
=
>
childNode
.
toASCIITreeString
(
{
prefix
}
|
)
)
.
join
(
"
\
n
"
)
;
}
toString
(
)
{
let
info
=
{
this
.
kindToString
(
)
}
;
Age
=
{
this
.
age
.
toFixed
(
3
)
}
s
;
if
(
this
.
needsMerge
)
{
info
+
=
"
;
Unmerged
"
;
}
return
{
this
.
guid
}
(
{
info
}
)
;
}
kindToString
(
)
{
switch
(
this
.
kind
)
{
case
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
:
return
"
Bookmark
"
;
case
SyncedBookmarksMirror
.
KIND
.
QUERY
:
return
"
Query
"
;
case
SyncedBookmarksMirror
.
KIND
.
FOLDER
:
return
"
Folder
"
;
case
SyncedBookmarksMirror
.
KIND
.
LIVEMARK
:
return
"
Livemark
"
;
case
SyncedBookmarksMirror
.
KIND
.
SEPARATOR
:
return
"
Separator
"
;
}
return
"
Unknown
"
;
}
toJSON
(
)
{
return
this
.
toString
(
)
;
}
}
class
BookmarkTree
{
constructor
(
root
)
{
this
.
root
=
root
;
this
.
byGuid
=
new
Map
(
[
[
this
.
root
.
guid
this
.
root
]
]
)
;
this
.
parentNodeByChildNode
=
new
Map
(
[
[
this
.
root
null
]
]
)
;
this
.
deletedGuids
=
new
Set
(
)
;
}
isDeleted
(
guid
)
{
return
this
.
deletedGuids
.
has
(
guid
)
;
}
nodeForGuid
(
guid
)
{
return
this
.
byGuid
.
get
(
guid
)
;
}
parentNodeFor
(
childNode
)
{
return
this
.
parentNodeByChildNode
.
get
(
childNode
)
;
}
insert
(
parentGuid
node
)
{
if
(
this
.
byGuid
.
has
(
node
.
guid
)
)
{
let
existingNode
=
this
.
byGuid
.
get
(
node
.
guid
)
;
MirrorLog
.
error
(
"
Can
'
t
replace
existing
node
{
existingNode
}
with
node
"
+
"
{
node
}
"
{
existingNode
node
}
)
;
throw
new
TypeError
(
"
Node
already
exists
in
tree
"
)
;
}
let
parentNode
=
this
.
byGuid
.
get
(
parentGuid
)
;
if
(
!
parentNode
)
{
MirrorLog
.
error
(
"
Missing
parent
{
parentGuid
}
for
node
{
node
}
"
{
parentGuid
node
}
)
;
throw
new
TypeError
(
"
Can
'
t
insert
node
into
nonexistent
parent
"
)
;
}
if
(
!
parentNode
.
isFolder
(
)
)
{
MirrorLog
.
error
(
"
Non
-
folder
parent
{
parentNode
}
for
node
{
node
}
"
{
parentNode
node
}
)
;
throw
new
TypeError
(
"
Can
'
t
insert
node
into
non
-
folder
"
)
;
}
parentNode
.
children
.
push
(
node
)
;
this
.
byGuid
.
set
(
node
.
guid
node
)
;
this
.
parentNodeByChildNode
.
set
(
node
parentNode
)
;
}
noteDeleted
(
guid
)
{
this
.
deletedGuids
.
add
(
guid
)
;
}
*
guids
(
)
{
for
(
let
[
guid
]
of
this
.
byGuid
)
{
yield
guid
;
}
for
(
let
guid
of
this
.
deletedGuids
)
{
yield
guid
;
}
}
toASCIITreeString
(
)
{
return
{
this
.
root
.
toASCIITreeString
(
)
}
\
nDeleted
:
[
{
Array
.
from
(
this
.
deletedGuids
)
.
join
(
"
"
)
}
]
;
}
}
class
MergedBookmarkNode
{
constructor
(
guid
localNode
remoteNode
mergeState
)
{
this
.
guid
=
guid
;
this
.
localNode
=
localNode
;
this
.
remoteNode
=
remoteNode
;
this
.
mergeState
=
mergeState
;
this
.
mergedChildren
=
[
]
;
}
*
mergeStatesParams
(
level
=
0
)
{
for
(
let
position
=
0
;
position
<
this
.
mergedChildren
.
length
;
+
+
position
)
{
let
mergedChild
=
this
.
mergedChildren
[
position
]
;
let
mergeStateParam
=
{
localGuid
:
mergedChild
.
localNode
?
mergedChild
.
localNode
.
guid
:
null
mergedGuid
:
mergedChild
.
guid
parentGuid
:
this
.
guid
level
position
valueState
:
mergedChild
.
mergeState
.
value
structureState
:
mergedChild
.
mergeState
.
structure
}
;
yield
mergeStateParam
;
yield
*
mergedChild
.
mergeStatesParams
(
level
+
1
)
;
}
}
toASCIITreeString
(
prefix
=
"
"
)
{
if
(
!
this
.
mergedChildren
.
length
)
{
return
prefix
+
"
-
"
+
this
.
toString
(
)
;
}
return
prefix
+
"
+
"
+
this
.
toString
(
)
+
"
\
n
"
+
this
.
mergedChildren
.
map
(
mergedChildNode
=
>
mergedChildNode
.
toASCIITreeString
(
{
prefix
}
|
)
)
.
join
(
"
\
n
"
)
;
}
toString
(
)
{
return
{
this
.
guid
}
{
this
.
mergeState
.
toString
(
)
}
;
}
toJSON
(
)
{
return
this
.
toString
(
)
;
}
}
class
BookmarkMerger
{
constructor
(
localTree
newLocalContents
remoteTree
newRemoteContents
)
{
this
.
localTree
=
localTree
;
this
.
newLocalContents
=
newLocalContents
;
this
.
remoteTree
=
remoteTree
;
this
.
newRemoteContents
=
newRemoteContents
;
this
.
matchingDupesByLocalParentNode
=
new
Map
(
)
;
this
.
mergedGuids
=
new
Set
(
)
;
this
.
deleteLocally
=
new
Set
(
)
;
this
.
deleteRemotely
=
new
Set
(
)
;
this
.
structureCounts
=
{
new
:
0
remoteRevives
:
0
localDeletes
:
0
localRevives
:
0
remoteDeletes
:
0
}
;
this
.
dupeCount
=
0
;
}
async
merge
(
)
{
let
localRoot
=
this
.
localTree
.
nodeForGuid
(
PlacesUtils
.
bookmarks
.
rootGuid
)
;
let
remoteRoot
=
this
.
remoteTree
.
nodeForGuid
(
PlacesUtils
.
bookmarks
.
rootGuid
)
;
let
mergedRoot
=
await
this
.
mergeNode
(
PlacesUtils
.
bookmarks
.
rootGuid
localRoot
remoteRoot
)
;
for
await
(
let
guid
of
yieldingIterator
(
this
.
localTree
.
deletedGuids
)
)
{
if
(
!
this
.
mentions
(
guid
)
)
{
this
.
deleteRemotely
.
add
(
guid
)
;
}
}
for
await
(
let
guid
of
yieldingIterator
(
this
.
remoteTree
.
deletedGuids
)
)
{
if
(
!
this
.
mentions
(
guid
)
)
{
this
.
deleteLocally
.
add
(
guid
)
;
}
}
return
mergedRoot
;
}
async
subsumes
(
tree
)
{
for
await
(
let
guid
of
yieldingIterator
(
tree
.
guids
(
)
)
)
{
if
(
!
this
.
mentions
(
guid
)
)
{
return
false
;
}
}
return
true
;
}
mentions
(
guid
)
{
return
this
.
mergedGuids
.
has
(
guid
)
|
|
this
.
deleteLocally
.
has
(
guid
)
|
|
this
.
deleteRemotely
.
has
(
guid
)
;
}
*
deletions
(
)
{
for
(
let
guid
of
this
.
deleteLocally
)
{
if
(
this
.
deleteRemotely
.
has
(
guid
)
)
{
continue
;
}
let
localNode
=
this
.
localTree
.
nodeForGuid
(
guid
)
;
yield
{
guid
localLevel
:
localNode
?
localNode
.
level
:
-
1
shouldUploadTombstone
:
false
}
;
}
for
(
let
guid
of
this
.
deleteRemotely
)
{
let
localNode
=
this
.
localTree
.
nodeForGuid
(
guid
)
;
yield
{
guid
localLevel
:
localNode
?
localNode
.
level
:
-
1
shouldUploadTombstone
:
true
}
;
}
}
async
mergeNode
(
mergedGuid
localNode
remoteNode
)
{
await
maybeYield
(
)
;
this
.
mergedGuids
.
add
(
mergedGuid
)
;
if
(
localNode
)
{
if
(
localNode
.
guid
!
=
mergedGuid
)
{
this
.
mergedGuids
.
add
(
localNode
.
guid
)
;
}
if
(
remoteNode
)
{
MirrorLog
.
trace
(
"
Item
{
mergedGuid
}
exists
locally
as
{
localNode
}
"
+
"
and
remotely
as
{
remoteNode
}
;
merging
"
{
mergedGuid
localNode
remoteNode
}
)
;
let
mergedNode
=
await
this
.
twoWayMerge
(
mergedGuid
localNode
remoteNode
)
;
return
mergedNode
;
}
MirrorLog
.
trace
(
"
Item
{
mergedGuid
}
only
exists
locally
as
"
+
"
{
localNode
}
;
taking
local
state
"
{
mergedGuid
localNode
}
)
;
let
mergedNode
=
new
MergedBookmarkNode
(
mergedGuid
localNode
null
BookmarkMergeState
.
local
)
;
if
(
localNode
.
isFolder
(
)
)
{
await
this
.
mergeChildListsIntoMergedNode
(
mergedNode
localNode
null
)
;
}
return
mergedNode
;
}
if
(
remoteNode
)
{
MirrorLog
.
trace
(
"
Item
{
mergedGuid
}
only
exists
remotely
as
"
+
"
{
remoteNode
}
;
taking
remote
state
"
{
mergedGuid
remoteNode
}
)
;
let
mergedNode
=
new
MergedBookmarkNode
(
mergedGuid
null
remoteNode
BookmarkMergeState
.
remote
)
;
if
(
remoteNode
.
isFolder
(
)
)
{
await
this
.
mergeChildListsIntoMergedNode
(
mergedNode
null
remoteNode
)
;
}
return
mergedNode
;
}
throw
new
TypeError
(
"
Can
'
t
merge
two
nonexistent
nodes
"
)
;
}
async
twoWayMerge
(
mergedGuid
localNode
remoteNode
)
{
let
mergeState
=
this
.
resolveTwoWayValueConflict
(
mergedGuid
localNode
remoteNode
)
;
MirrorLog
.
trace
(
"
Merge
state
for
{
mergedGuid
}
is
{
mergeState
}
"
{
mergedGuid
mergeState
}
)
;
let
mergedNode
=
new
MergedBookmarkNode
(
mergedGuid
localNode
remoteNode
mergeState
)
;
if
(
!
localNode
.
hasCompatibleKind
(
remoteNode
)
)
{
MirrorLog
.
error
(
"
Merging
local
{
localNode
}
and
remote
{
remoteNode
}
"
+
"
with
different
kinds
"
{
localNode
remoteNode
}
)
;
throw
new
SyncedBookmarksMirror
.
ConsistencyError
(
"
Can
'
t
merge
different
item
kinds
"
)
;
}
if
(
localNode
.
isFolder
(
)
)
{
if
(
remoteNode
.
isFolder
(
)
)
{
MirrorLog
.
trace
(
"
Merging
folders
{
localNode
}
and
{
remoteNode
}
"
{
localNode
remoteNode
}
)
;
await
this
.
mergeChildListsIntoMergedNode
(
mergedNode
localNode
remoteNode
)
;
return
mergedNode
;
}
}
MirrorLog
.
trace
(
"
Merging
non
-
folders
{
localNode
}
and
{
remoteNode
}
"
{
localNode
remoteNode
}
)
;
return
mergedNode
;
}
resolveTwoWayValueConflict
(
mergedGuid
localNode
remoteNode
)
{
if
(
PlacesUtils
.
bookmarks
.
userContentRoots
.
includes
(
mergedGuid
)
)
{
return
BookmarkMergeState
.
local
;
}
if
(
!
remoteNode
.
needsMerge
)
{
return
BookmarkMergeState
.
local
;
}
if
(
!
localNode
.
needsMerge
)
{
return
BookmarkMergeState
.
remote
;
}
let
valueState
=
localNode
.
newerThan
(
remoteNode
)
?
BookmarkMergeState
.
local
:
BookmarkMergeState
.
remote
;
return
valueState
;
}
async
mergeRemoteChildIntoMergedNode
(
mergedNode
remoteParentNode
remoteChildNode
)
{
if
(
this
.
mergedGuids
.
has
(
remoteChildNode
.
guid
)
)
{
MirrorLog
.
trace
(
"
Remote
child
{
remoteChildNode
}
already
seen
in
"
+
"
another
folder
and
merged
"
{
remoteChildNode
}
)
;
return
false
;
}
MirrorLog
.
trace
(
"
Merging
remote
child
{
remoteChildNode
}
of
"
+
"
{
remoteParentNode
}
into
{
mergedNode
}
"
{
remoteChildNode
remoteParentNode
mergedNode
}
)
;
let
structureChange
=
await
this
.
checkForLocalStructureChangeOfRemoteNode
(
mergedNode
remoteParentNode
remoteChildNode
)
;
if
(
structureChange
=
=
BookmarkMerger
.
STRUCTURE
.
DELETED
)
{
return
true
;
}
let
localChildNode
=
this
.
localTree
.
nodeForGuid
(
remoteChildNode
.
guid
)
;
if
(
!
localChildNode
)
{
MirrorLog
.
trace
(
"
Remote
child
{
remoteChildNode
}
doesn
'
t
exist
"
+
"
locally
;
looking
for
local
content
match
"
{
remoteChildNode
}
)
;
let
localChildNodeByContent
=
await
this
.
findLocalNodeMatchingRemoteNode
(
mergedNode
remoteChildNode
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
remoteChildNode
.
guid
localChildNodeByContent
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
false
;
}
let
localParentNode
=
this
.
localTree
.
parentNodeFor
(
localChildNode
)
;
if
(
!
localParentNode
)
{
MirrorLog
.
error
(
"
Remote
child
{
remoteChildNode
}
exists
locally
as
"
+
"
{
localChildNode
}
without
local
parent
"
{
remoteChildNode
localChildNode
}
)
;
throw
new
TypeError
(
"
Can
'
t
merge
existing
remote
child
without
local
parent
"
)
;
}
MirrorLog
.
trace
(
"
Remote
child
{
remoteChildNode
}
exists
locally
in
"
+
"
{
localParentNode
}
and
remotely
in
{
remoteParentNode
}
"
{
remoteChildNode
localParentNode
remoteParentNode
}
)
;
if
(
this
.
remoteTree
.
isDeleted
(
localParentNode
.
guid
)
)
{
MirrorLog
.
trace
(
"
Unconditionally
taking
remote
move
for
"
+
"
{
remoteChildNode
}
to
{
remoteParentNode
}
because
"
+
"
local
parent
{
localParentNode
}
is
deleted
remotely
"
{
remoteChildNode
remoteParentNode
localParentNode
}
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
localChildNode
.
guid
localChildNode
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
false
;
}
if
(
localParentNode
.
needsMerge
)
{
if
(
remoteParentNode
.
needsMerge
)
{
MirrorLog
.
trace
(
"
Local
{
localParentNode
}
and
remote
"
+
"
{
remoteParentNode
}
parents
changed
;
comparing
"
+
"
modified
times
to
decide
parent
for
remote
child
"
+
"
{
remoteChildNode
}
"
{
localParentNode
remoteParentNode
remoteChildNode
}
)
;
let
latestLocalAge
=
Math
.
min
(
localChildNode
.
age
localParentNode
.
age
)
;
let
latestRemoteAge
=
Math
.
min
(
remoteChildNode
.
age
remoteParentNode
.
age
)
;
if
(
latestLocalAge
<
latestRemoteAge
)
{
MirrorLog
.
trace
(
"
Ignoring
older
remote
move
for
{
remoteChildNode
}
"
+
"
to
{
remoteParentNode
}
at
{
latestRemoteAge
}
;
"
+
"
local
move
to
{
localParentNode
}
at
"
+
"
{
latestLocalAge
}
is
newer
"
{
remoteChildNode
remoteParentNode
latestRemoteAge
localParentNode
latestLocalAge
}
)
;
return
true
;
}
MirrorLog
.
trace
(
"
Taking
newer
remote
move
for
{
remoteChildNode
}
to
"
+
"
{
remoteParentNode
}
at
{
latestRemoteAge
}
;
local
"
+
"
move
to
{
localParentNode
}
at
{
latestLocalAge
}
is
"
+
"
older
"
{
remoteChildNode
remoteParentNode
latestRemoteAge
localParentNode
latestLocalAge
}
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
remoteChildNode
.
guid
localChildNode
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
false
;
}
MirrorLog
.
trace
(
"
Remote
parent
unchanged
;
keeping
remote
child
"
+
"
{
remoteChildNode
}
in
{
localParentNode
}
"
{
remoteChildNode
localParentNode
}
)
;
return
true
;
}
MirrorLog
.
trace
(
"
Local
parent
unchanged
;
keeping
remote
child
"
+
"
{
remoteChildNode
}
in
{
remoteParentNode
}
"
{
remoteChildNode
remoteParentNode
}
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
remoteChildNode
.
guid
localChildNode
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
false
;
}
async
mergeLocalChildIntoMergedNode
(
mergedNode
localParentNode
localChildNode
)
{
if
(
this
.
mergedGuids
.
has
(
localChildNode
.
guid
)
)
{
MirrorLog
.
trace
(
"
Local
child
{
localChildNode
}
already
seen
in
"
+
"
another
folder
and
merged
"
{
localChildNode
}
)
;
return
false
;
}
MirrorLog
.
trace
(
"
Merging
local
child
{
localChildNode
}
of
"
+
"
{
localParentNode
}
into
{
mergedNode
}
"
{
localChildNode
localParentNode
mergedNode
}
)
;
let
structureChange
=
await
this
.
checkForRemoteStructureChangeOfLocalNode
(
mergedNode
localParentNode
localChildNode
)
;
if
(
structureChange
=
=
BookmarkMerger
.
STRUCTURE
.
DELETED
)
{
return
true
;
}
let
remoteChildNode
=
this
.
remoteTree
.
nodeForGuid
(
localChildNode
.
guid
)
;
if
(
!
remoteChildNode
)
{
MirrorLog
.
trace
(
"
Local
child
{
localChildNode
}
doesn
'
t
exist
"
+
"
remotely
;
looking
for
remote
content
match
"
{
localChildNode
}
)
;
let
remoteChildNodeByContent
=
await
this
.
findRemoteNodeMatchingLocalNode
(
mergedNode
localChildNode
)
;
if
(
remoteChildNodeByContent
)
{
let
mergedChildNode
=
await
this
.
mergeNode
(
remoteChildNodeByContent
.
guid
localChildNode
remoteChildNodeByContent
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
false
;
}
let
mergedChildNode
=
await
this
.
mergeNode
(
localChildNode
.
guid
localChildNode
null
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
true
;
}
let
remoteParentNode
=
this
.
remoteTree
.
parentNodeFor
(
remoteChildNode
)
;
if
(
!
remoteParentNode
)
{
MirrorLog
.
error
(
"
Local
child
{
localChildNode
}
exists
remotely
as
"
+
"
{
remoteChildNode
}
without
remote
parent
"
{
localChildNode
remoteChildNode
}
)
;
throw
new
TypeError
(
"
Can
'
t
merge
existing
local
child
without
remote
parent
"
)
;
}
MirrorLog
.
trace
(
"
Local
child
{
localChildNode
}
exists
locally
in
"
+
"
{
localParentNode
}
and
remotely
in
{
remoteParentNode
}
"
{
localChildNode
localParentNode
remoteParentNode
}
)
;
if
(
this
.
localTree
.
isDeleted
(
remoteParentNode
.
guid
)
)
{
MirrorLog
.
trace
(
"
Unconditionally
taking
local
move
for
"
+
"
{
localChildNode
}
to
{
localParentNode
}
because
"
+
"
remote
parent
{
remoteParentNode
}
is
deleted
locally
"
{
localChildNode
localParentNode
remoteParentNode
}
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
localChildNode
.
guid
localChildNode
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
true
;
}
if
(
localParentNode
.
needsMerge
)
{
if
(
remoteParentNode
.
needsMerge
)
{
MirrorLog
.
trace
(
"
Local
{
localParentNode
}
and
remote
"
+
"
{
remoteParentNode
}
parents
changed
;
comparing
"
+
"
modified
times
to
decide
parent
for
local
child
"
+
"
{
localChildNode
}
"
{
localParentNode
remoteParentNode
localChildNode
}
)
;
let
latestLocalAge
=
Math
.
min
(
localChildNode
.
age
localParentNode
.
age
)
;
let
latestRemoteAge
=
Math
.
min
(
remoteChildNode
.
age
remoteParentNode
.
age
)
;
if
(
latestRemoteAge
<
=
latestLocalAge
)
{
MirrorLog
.
trace
(
"
Ignoring
older
local
move
for
{
localChildNode
}
"
+
"
to
{
localParentNode
}
at
{
latestLocalAge
}
;
"
+
"
remote
move
to
{
remoteParentNode
}
at
"
+
"
{
latestRemoteAge
}
is
newer
"
{
localChildNode
localParentNode
latestLocalAge
remoteParentNode
latestRemoteAge
}
)
;
return
false
;
}
MirrorLog
.
trace
(
"
Taking
newer
local
move
for
{
localChildNode
}
to
"
+
"
{
localParentNode
}
at
{
latestLocalAge
}
;
remote
"
+
"
move
to
{
remoteParentNode
}
at
{
latestRemoteAge
}
"
+
"
is
older
"
{
localChildNode
localParentNode
latestLocalAge
remoteParentNode
latestRemoteAge
}
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
localChildNode
.
guid
localChildNode
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
true
;
}
MirrorLog
.
trace
(
"
Remote
parent
unchanged
;
keeping
local
child
"
+
"
{
localChildNode
}
in
local
parent
{
localParentNode
}
"
{
localChildNode
localParentNode
}
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
localChildNode
.
guid
localChildNode
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
true
;
}
MirrorLog
.
trace
(
"
Local
parent
unchanged
;
keeping
local
child
"
+
"
{
localChildNode
}
in
remote
parent
{
remoteParentNode
}
"
{
localChildNode
remoteParentNode
}
)
;
return
false
;
}
async
mergeChildListsIntoMergedNode
(
mergedNode
localNode
remoteNode
)
{
let
mergeStateChanged
=
false
;
if
(
localNode
&
&
remoteNode
)
{
if
(
localNode
.
newerThan
(
remoteNode
)
)
{
if
(
await
this
.
mergeLocalChildrenIntoMergedNode
(
mergedNode
localNode
)
)
{
mergeStateChanged
=
true
;
}
if
(
await
this
.
mergeRemoteChildrenIntoMergedNode
(
mergedNode
remoteNode
)
)
{
mergeStateChanged
=
true
;
}
}
else
{
if
(
await
this
.
mergeRemoteChildrenIntoMergedNode
(
mergedNode
remoteNode
)
)
{
mergeStateChanged
=
true
;
}
if
(
await
this
.
mergeLocalChildrenIntoMergedNode
(
mergedNode
localNode
)
)
{
mergeStateChanged
=
true
;
}
}
}
else
if
(
localNode
)
{
if
(
await
this
.
mergeLocalChildrenIntoMergedNode
(
mergedNode
localNode
)
)
{
mergeStateChanged
=
true
;
}
}
else
if
(
remoteNode
)
{
if
(
await
this
.
mergeRemoteChildrenIntoMergedNode
(
mergedNode
remoteNode
)
)
{
mergeStateChanged
=
true
;
}
}
else
{
throw
new
TypeError
(
"
Can
'
t
merge
children
for
two
nonexistent
nodes
"
)
;
}
if
(
mergeStateChanged
)
{
let
newMergeState
=
BookmarkMergeState
.
new
(
mergedNode
.
mergeState
)
;
MirrorLog
.
trace
(
"
Merge
state
for
{
mergedNode
}
has
new
structure
"
+
"
{
newMergeState
}
"
{
mergedNode
newMergeState
}
)
;
this
.
structureCounts
.
new
+
+
;
mergedNode
.
mergeState
=
newMergeState
;
}
}
async
mergeRemoteChildrenIntoMergedNode
(
mergedNode
remoteNode
)
{
MirrorLog
.
trace
(
"
Merging
remote
children
of
{
remoteNode
}
into
"
+
"
{
mergedNode
}
"
{
remoteNode
mergedNode
}
)
;
let
mergeStateChanged
=
false
;
for
await
(
let
remoteChildNode
of
yieldingIterator
(
remoteNode
.
children
)
)
{
let
remoteChildrenChanged
=
await
this
.
mergeRemoteChildIntoMergedNode
(
mergedNode
remoteNode
remoteChildNode
)
;
if
(
remoteChildrenChanged
)
{
mergeStateChanged
=
true
;
}
}
return
mergeStateChanged
;
}
async
mergeLocalChildrenIntoMergedNode
(
mergedNode
localNode
)
{
MirrorLog
.
trace
(
"
Merging
local
children
of
{
localNode
}
into
"
+
"
{
mergedNode
}
"
{
localNode
mergedNode
}
)
;
let
mergeStateChanged
=
false
;
for
await
(
let
localChildNode
of
yieldingIterator
(
localNode
.
children
)
)
{
let
remoteChildrenChanged
=
await
this
.
mergeLocalChildIntoMergedNode
(
mergedNode
localNode
localChildNode
)
;
if
(
remoteChildrenChanged
)
{
mergeStateChanged
=
true
;
}
}
return
mergeStateChanged
;
}
async
checkForLocalStructureChangeOfRemoteNode
(
mergedNode
remoteParentNode
remoteNode
)
{
if
(
!
remoteNode
.
isSyncable
)
{
this
.
deleteRemotely
.
add
(
remoteNode
.
guid
)
;
if
(
remoteNode
.
isFolder
(
)
)
{
await
this
.
relocateRemoteOrphansToMergedNode
(
mergedNode
remoteNode
)
;
}
return
BookmarkMerger
.
STRUCTURE
.
DELETED
;
}
if
(
!
this
.
localTree
.
isDeleted
(
remoteNode
.
guid
)
)
{
let
localNode
=
this
.
localTree
.
nodeForGuid
(
remoteNode
.
guid
)
;
if
(
!
localNode
)
{
return
BookmarkMerger
.
STRUCTURE
.
UNCHANGED
;
}
if
(
!
localNode
.
isSyncable
)
{
this
.
deleteRemotely
.
add
(
remoteNode
.
guid
)
;
if
(
remoteNode
.
isFolder
(
)
)
{
await
this
.
relocateRemoteOrphansToMergedNode
(
mergedNode
remoteNode
)
;
}
return
BookmarkMerger
.
STRUCTURE
.
DELETED
;
}
let
localParentNode
=
this
.
localTree
.
parentNodeFor
(
localNode
)
;
if
(
!
localParentNode
)
{
throw
new
TypeError
(
"
Can
'
t
check
for
structure
changes
without
local
parent
"
)
;
}
if
(
localParentNode
.
guid
!
=
remoteParentNode
.
guid
)
{
return
BookmarkMerger
.
STRUCTURE
.
MOVED
;
}
return
BookmarkMerger
.
STRUCTURE
.
UNCHANGED
;
}
if
(
remoteNode
.
needsMerge
)
{
if
(
!
remoteNode
.
isFolder
(
)
)
{
MirrorLog
.
trace
(
"
Remote
non
-
folder
{
remoteNode
}
deleted
locally
"
+
"
and
changed
remotely
;
taking
remote
change
"
{
remoteNode
}
)
;
this
.
structureCounts
.
remoteRevives
+
+
;
return
BookmarkMerger
.
STRUCTURE
.
UNCHANGED
;
}
MirrorLog
.
trace
(
"
Remote
folder
{
remoteNode
}
deleted
locally
"
+
"
and
changed
remotely
;
taking
local
deletion
"
{
remoteNode
}
)
;
this
.
structureCounts
.
localDeletes
+
+
;
}
else
{
MirrorLog
.
trace
(
"
Remote
node
{
remoteNode
}
deleted
locally
and
not
"
+
"
changed
remotely
;
taking
local
deletion
"
{
remoteNode
}
)
;
}
this
.
deleteRemotely
.
add
(
remoteNode
.
guid
)
;
if
(
remoteNode
.
isFolder
(
)
)
{
await
this
.
relocateRemoteOrphansToMergedNode
(
mergedNode
remoteNode
)
;
}
return
BookmarkMerger
.
STRUCTURE
.
DELETED
;
}
async
checkForRemoteStructureChangeOfLocalNode
(
mergedNode
localParentNode
localNode
)
{
if
(
!
localNode
.
isSyncable
)
{
this
.
deleteLocally
.
add
(
localNode
.
guid
)
;
if
(
localNode
.
isFolder
(
)
)
{
await
this
.
relocateLocalOrphansToMergedNode
(
mergedNode
localNode
)
;
}
return
BookmarkMerger
.
STRUCTURE
.
DELETED
;
}
if
(
!
this
.
remoteTree
.
isDeleted
(
localNode
.
guid
)
)
{
let
remoteNode
=
this
.
remoteTree
.
nodeForGuid
(
localNode
.
guid
)
;
if
(
!
remoteNode
)
{
return
BookmarkMerger
.
STRUCTURE
.
UNCHANGED
;
}
if
(
!
remoteNode
.
isSyncable
)
{
this
.
deleteLocally
.
add
(
localNode
.
guid
)
;
if
(
remoteNode
.
isFolder
(
)
)
{
await
this
.
relocateLocalOrphansToMergedNode
(
mergedNode
localNode
)
;
}
return
BookmarkMerger
.
STRUCTURE
.
DELETED
;
}
let
remoteParentNode
=
this
.
remoteTree
.
parentNodeFor
(
remoteNode
)
;
if
(
!
remoteParentNode
)
{
throw
new
TypeError
(
"
Can
'
t
check
for
structure
changes
without
remote
parent
"
)
;
}
if
(
remoteParentNode
.
guid
!
=
localParentNode
.
guid
)
{
return
BookmarkMerger
.
STRUCTURE
.
MOVED
;
}
return
BookmarkMerger
.
STRUCTURE
.
UNCHANGED
;
}
if
(
localNode
.
needsMerge
)
{
if
(
!
localNode
.
isFolder
(
)
)
{
MirrorLog
.
trace
(
"
Local
non
-
folder
{
localNode
}
deleted
remotely
and
"
+
"
changed
locally
;
taking
local
change
"
{
localNode
}
)
;
this
.
structureCounts
.
localRevives
+
+
;
return
BookmarkMerger
.
STRUCTURE
.
UNCHANGED
;
}
MirrorLog
.
trace
(
"
Local
folder
{
localNode
}
deleted
remotely
and
"
+
"
changed
locally
;
taking
remote
deletion
"
{
localNode
}
)
;
this
.
structureCounts
.
remoteDeletes
+
+
;
}
else
{
MirrorLog
.
trace
(
"
Local
node
{
localNode
}
deleted
remotely
and
not
"
+
"
changed
locally
;
taking
remote
deletion
"
{
localNode
}
)
;
}
this
.
deleteLocally
.
add
(
localNode
.
guid
)
;
if
(
localNode
.
isFolder
(
)
)
{
await
this
.
relocateLocalOrphansToMergedNode
(
mergedNode
localNode
)
;
}
return
BookmarkMerger
.
STRUCTURE
.
DELETED
;
}
async
relocateRemoteOrphansToMergedNode
(
mergedNode
remoteNode
)
{
let
remoteOrphanNodes
=
[
]
;
for
await
(
let
remoteChildNode
of
yieldingIterator
(
remoteNode
.
children
)
)
{
let
structureChange
=
await
this
.
checkForLocalStructureChangeOfRemoteNode
(
mergedNode
remoteNode
remoteChildNode
)
;
if
(
structureChange
=
=
BookmarkMerger
.
STRUCTURE
.
MOVED
|
|
structureChange
=
=
BookmarkMerger
.
STRUCTURE
.
DELETED
)
{
continue
;
}
remoteOrphanNodes
.
push
(
remoteChildNode
)
;
}
let
mergedOrphanNodes
=
[
]
;
for
await
(
let
remoteOrphanNode
of
yieldingIterator
(
remoteOrphanNodes
)
)
{
let
localOrphanNode
=
this
.
localTree
.
nodeForGuid
(
remoteOrphanNode
.
guid
)
;
let
mergedOrphanNode
=
await
this
.
mergeNode
(
remoteOrphanNode
.
guid
localOrphanNode
remoteOrphanNode
)
;
mergedOrphanNodes
.
push
(
mergedOrphanNode
)
;
}
MirrorLog
.
trace
(
"
Relocating
remote
orphans
{
mergedOrphanNodes
}
to
"
+
"
{
mergedNode
}
"
{
mergedOrphanNodes
mergedNode
}
)
;
for
await
(
let
mergedOrphanNode
of
yieldingIterator
(
mergedOrphanNodes
)
)
{
let
mergeState
=
BookmarkMergeState
.
new
(
mergedOrphanNode
.
mergeState
)
;
mergedOrphanNode
.
mergeState
=
mergeState
;
mergedNode
.
mergedChildren
.
push
(
mergedOrphanNode
)
;
}
}
async
relocateLocalOrphansToMergedNode
(
mergedNode
localNode
)
{
let
localOrphanNodes
=
[
]
;
for
await
(
let
localChildNode
of
yieldingIterator
(
localNode
.
children
)
)
{
let
structureChange
=
await
this
.
checkForRemoteStructureChangeOfLocalNode
(
mergedNode
localNode
localChildNode
)
;
if
(
structureChange
=
=
BookmarkMerger
.
STRUCTURE
.
MOVED
|
|
structureChange
=
=
BookmarkMerger
.
STRUCTURE
.
DELETED
)
{
continue
;
}
localOrphanNodes
.
push
(
localChildNode
)
;
}
let
mergedOrphanNodes
=
[
]
;
for
await
(
let
localOrphanNode
of
yieldingIterator
(
localOrphanNodes
)
)
{
let
remoteOrphanNode
=
this
.
remoteTree
.
nodeForGuid
(
localOrphanNode
.
guid
)
;
let
mergedNode
=
await
this
.
mergeNode
(
localOrphanNode
.
guid
localOrphanNode
remoteOrphanNode
)
;
mergedOrphanNodes
.
push
(
mergedNode
)
;
}
MirrorLog
.
trace
(
"
Relocating
local
orphans
{
mergedOrphanNodes
}
to
"
+
"
{
mergedNode
}
"
{
mergedOrphanNodes
mergedNode
}
)
;
for
await
(
let
mergedOrphanNode
of
yieldingIterator
(
mergedOrphanNodes
)
)
{
let
mergeState
=
BookmarkMergeState
.
new
(
mergedOrphanNode
.
mergeState
)
;
mergedOrphanNode
.
mergeState
=
mergeState
;
mergedNode
.
mergedChildren
.
push
(
mergedOrphanNode
)
;
}
}
async
findAllMatchingDupesInFolders
(
localParentNode
remoteParentNode
)
{
let
matches
=
new
Map
(
)
;
let
dupeKeyToLocalNodes
=
new
Map
(
)
;
for
await
(
let
localChildNode
of
yieldingIterator
(
localParentNode
.
children
)
)
{
let
localChildContent
=
this
.
newLocalContents
.
get
(
localChildNode
.
guid
)
;
if
(
!
localChildContent
)
{
MirrorLog
.
trace
(
"
Not
deduping
local
child
{
localChildNode
}
;
already
"
+
"
uploaded
"
{
localChildNode
}
)
;
continue
;
}
let
remoteChildNodeByGuid
=
this
.
remoteTree
.
nodeForGuid
(
localChildNode
.
guid
)
;
if
(
remoteChildNodeByGuid
)
{
MirrorLog
.
trace
(
"
Not
deduping
local
child
{
localChildNode
}
;
already
"
+
"
exists
remotely
as
{
remoteChildNodeByGuid
}
"
{
localChildNode
remoteChildNodeByGuid
}
)
;
continue
;
}
if
(
this
.
remoteTree
.
isDeleted
(
localChildNode
.
guid
)
)
{
MirrorLog
.
trace
(
"
Not
deduping
local
child
{
localChildNode
}
;
deleted
"
+
"
remotely
"
{
localChildNode
}
)
;
continue
;
}
let
dupeKey
=
makeDupeKey
(
localChildNode
localChildContent
)
;
let
localNodesForKey
=
dupeKeyToLocalNodes
.
get
(
dupeKey
)
;
if
(
localNodesForKey
)
{
localNodesForKey
.
push
(
localChildNode
)
;
}
else
{
dupeKeyToLocalNodes
.
set
(
dupeKey
[
localChildNode
]
)
;
}
}
for
await
(
let
remoteChildNode
of
yieldingIterator
(
remoteParentNode
.
children
)
)
{
if
(
matches
.
has
(
remoteChildNode
)
)
{
MirrorLog
.
trace
(
"
Not
deduping
remote
child
{
remoteChildNode
}
;
"
+
"
already
deduped
"
{
remoteChildNode
}
)
;
continue
;
}
let
remoteChildContent
=
this
.
newRemoteContents
.
get
(
remoteChildNode
.
guid
)
;
if
(
!
remoteChildContent
)
{
MirrorLog
.
trace
(
"
Not
deduping
remote
child
{
remoteChildNode
}
;
"
+
"
already
merged
"
{
remoteChildNode
}
)
;
continue
;
}
let
dupeKey
=
makeDupeKey
(
remoteChildNode
remoteChildContent
)
;
let
localNodesForKey
=
dupeKeyToLocalNodes
.
get
(
dupeKey
)
;
if
(
!
localNodesForKey
)
{
MirrorLog
.
trace
(
"
Not
deduping
remote
child
{
remoteChildNode
}
;
no
"
+
"
local
content
matches
"
{
remoteChildNode
}
)
;
continue
;
}
let
localChildNode
=
localNodesForKey
.
shift
(
)
;
if
(
!
localChildNode
)
{
MirrorLog
.
trace
(
"
Not
deduping
remote
child
{
remoteChildNode
}
;
no
"
+
"
remaining
local
content
matches
"
{
remoteChildNode
}
)
;
continue
;
}
MirrorLog
.
trace
(
"
Deduping
local
child
{
localChildNode
}
to
remote
"
+
"
child
{
remoteChildNode
}
"
{
localChildNode
remoteChildNode
}
)
;
matches
.
set
(
localChildNode
remoteChildNode
)
;
matches
.
set
(
remoteChildNode
localChildNode
)
;
}
return
matches
;
}
async
findRemoteNodeMatchingLocalNode
(
mergedNode
localChildNode
)
{
let
remoteParentNode
=
mergedNode
.
remoteNode
;
if
(
!
remoteParentNode
)
{
MirrorLog
.
trace
(
"
Merged
node
{
mergedNode
}
doesn
'
t
exist
remotely
;
no
"
+
"
potential
dupes
for
local
child
{
localChildNode
}
"
{
mergedNode
localChildNode
}
)
;
return
null
;
}
let
localParentNode
=
mergedNode
.
localNode
;
if
(
!
localParentNode
)
{
throw
new
TypeError
(
"
Can
'
t
find
remote
content
match
without
local
parent
"
)
;
}
let
matches
=
this
.
matchingDupesByLocalParentNode
.
get
(
localParentNode
)
;
if
(
!
matches
)
{
MirrorLog
.
trace
(
"
First
local
child
{
localChildNode
}
doesn
'
t
exist
"
+
"
remotely
;
finding
all
matching
dupes
in
local
"
+
"
{
localParentNode
}
and
remote
{
remoteParentNode
}
"
{
localChildNode
localParentNode
remoteParentNode
}
)
;
matches
=
await
this
.
findAllMatchingDupesInFolders
(
localParentNode
remoteParentNode
)
;
this
.
matchingDupesByLocalParentNode
.
set
(
localParentNode
matches
)
;
}
let
newRemoteNode
=
matches
.
get
(
localChildNode
)
;
if
(
!
newRemoteNode
)
{
return
null
;
}
this
.
dupeCount
+
+
;
return
newRemoteNode
;
}
async
findLocalNodeMatchingRemoteNode
(
mergedNode
remoteChildNode
)
{
let
localParentNode
=
mergedNode
.
localNode
;
if
(
!
localParentNode
)
{
MirrorLog
.
trace
(
"
Merged
node
{
mergedNode
}
doesn
'
t
exist
locally
;
no
"
+
"
potential
dupes
for
remote
child
{
remoteChildNode
}
"
{
mergedNode
remoteChildNode
}
)
;
return
null
;
}
let
remoteParentNode
=
mergedNode
.
remoteNode
;
if
(
!
remoteParentNode
)
{
throw
new
TypeError
(
"
Can
'
t
find
local
content
match
without
remote
parent
"
)
;
}
let
matches
=
this
.
matchingDupesByLocalParentNode
.
get
(
localParentNode
)
;
if
(
!
matches
)
{
MirrorLog
.
trace
(
"
First
remote
child
{
remoteChildNode
}
doesn
'
t
exist
"
+
"
locally
;
finding
all
matching
dupes
in
local
"
+
"
{
localParentNode
}
and
remote
{
remoteParentNode
}
"
{
remoteChildNode
localParentNode
remoteParentNode
}
)
;
matches
=
await
this
.
findAllMatchingDupesInFolders
(
localParentNode
remoteParentNode
)
;
this
.
matchingDupesByLocalParentNode
.
set
(
localParentNode
matches
)
;
}
let
newLocalNode
=
matches
.
get
(
remoteChildNode
)
;
if
(
!
newLocalNode
)
{
return
null
;
}
this
.
dupeCount
+
+
;
return
newLocalNode
;
}
deletionsToStrings
(
)
{
let
infos
=
[
]
;
if
(
this
.
deleteLocally
.
size
)
{
infos
.
push
(
"
Delete
Locally
:
"
+
Array
.
from
(
this
.
deleteLocally
)
.
join
(
"
"
)
)
;
}
if
(
this
.
deleteRemotely
.
size
)
{
infos
.
push
(
"
Delete
Remotely
:
"
+
Array
.
from
(
this
.
deleteRemotely
)
.
join
(
"
"
)
)
;
}
return
infos
;
}
}
BookmarkMerger
.
STRUCTURE
=
{
UNCHANGED
:
1
MOVED
:
2
DELETED
:
3
}
;
class
BookmarkObserverRecorder
{
constructor
(
db
)
{
this
.
db
=
db
;
this
.
bookmarkObserverNotifications
=
[
]
;
this
.
annoObserverNotifications
=
[
]
;
this
.
shouldInvalidateKeywords
=
false
;
this
.
shouldInvalidateLivemarks
=
false
;
}
async
notifyAll
(
)
{
if
(
this
.
shouldInvalidateKeywords
)
{
await
PlacesUtils
.
keywords
.
invalidateCachedKeywords
(
)
;
}
await
this
.
notifyBookmarkObservers
(
)
;
await
this
.
notifyAnnoObservers
(
)
;
if
(
this
.
shouldInvalidateLivemarks
)
{
await
PlacesUtils
.
livemarks
.
invalidateCachedLivemarks
(
)
;
}
await
this
.
updateFrecencies
(
)
;
}
async
updateFrecencies
(
)
{
MirrorLog
.
trace
(
"
Recalculating
frecencies
for
new
URLs
"
)
;
await
this
.
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
CALCULATE_FRECENCY
(
id
)
WHERE
frecency
=
-
1
)
;
}
noteItemAdded
(
info
)
{
let
uri
=
info
.
urlHref
?
Services
.
io
.
newURI
(
info
.
urlHref
)
:
null
;
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemAdded
"
isTagging
:
info
.
isTagging
args
:
[
info
.
id
info
.
parentId
info
.
position
info
.
type
uri
info
.
title
info
.
dateAdded
info
.
guid
info
.
parentGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
noteGuidChanged
(
info
)
{
PlacesUtils
.
invalidateCachedGuidFor
(
info
.
id
)
;
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemChanged
"
isTagging
:
false
args
:
[
info
.
id
"
guid
"
false
info
.
newGuid
info
.
lastModified
info
.
type
info
.
parentId
info
.
newGuid
info
.
parentGuid
info
.
oldGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
noteItemMoved
(
info
)
{
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemMoved
"
isTagging
:
false
args
:
[
info
.
id
info
.
oldParentId
info
.
oldPosition
info
.
newParentId
info
.
newPosition
info
.
type
info
.
guid
info
.
oldParentGuid
info
.
newParentGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
info
.
urlHref
]
}
)
;
}
noteItemChanged
(
info
)
{
if
(
info
.
oldTitle
!
=
info
.
newTitle
)
{
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemChanged
"
isTagging
:
false
args
:
[
info
.
id
"
title
"
false
info
.
newTitle
info
.
lastModified
info
.
type
info
.
parentId
info
.
guid
info
.
parentGuid
info
.
oldTitle
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
if
(
info
.
oldURLHref
!
=
info
.
newURLHref
)
{
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemChanged
"
isTagging
:
false
args
:
[
info
.
id
"
uri
"
false
info
.
newURLHref
info
.
lastModified
info
.
type
info
.
parentId
info
.
guid
info
.
parentGuid
info
.
oldURLHref
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
}
noteItemRemoved
(
info
)
{
let
uri
=
info
.
urlHref
?
Services
.
io
.
newURI
(
info
.
urlHref
)
:
null
;
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemRemoved
"
isTagging
:
info
.
isUntagging
args
:
[
info
.
id
info
.
parentId
info
.
position
info
.
type
uri
info
.
guid
info
.
parentGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
noteAnnoSet
(
id
name
)
{
if
(
isLivemarkAnno
(
name
)
)
{
this
.
shouldInvalidateLivemarks
=
true
;
}
this
.
annoObserverNotifications
.
push
(
{
name
:
"
onItemAnnotationSet
"
args
:
[
id
name
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
noteAnnoRemoved
(
id
name
)
{
if
(
isLivemarkAnno
(
name
)
)
{
this
.
shouldInvalidateLivemarks
=
true
;
}
this
.
annoObserverNotifications
.
push
(
{
name
:
"
onItemAnnotationRemoved
"
args
:
[
id
name
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
async
notifyBookmarkObservers
(
)
{
MirrorLog
.
trace
(
"
Notifying
bookmark
observers
"
)
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
for
(
let
observer
of
observers
)
{
this
.
notifyObserver
(
observer
"
onBeginUpdateBatch
"
)
;
for
await
(
let
info
of
yieldingIterator
(
this
.
bookmarkObserverNotifications
)
)
{
if
(
info
.
isTagging
&
&
observer
.
skipTags
)
{
continue
;
}
this
.
notifyObserver
(
observer
info
.
name
info
.
args
)
;
}
this
.
notifyObserver
(
observer
"
onEndUpdateBatch
"
)
;
}
}
async
notifyAnnoObservers
(
)
{
MirrorLog
.
trace
(
"
Notifying
anno
observers
"
)
;
let
observers
=
PlacesUtils
.
annotations
.
getObservers
(
)
;
for
(
let
observer
of
observers
)
{
let
wrapped
=
yieldingIterator
(
this
.
annoObserverNotifications
)
;
for
await
(
let
{
name
args
}
of
wrapped
)
{
this
.
notifyObserver
(
observer
name
args
)
;
}
}
}
notifyObserver
(
observer
notification
args
=
[
]
)
{
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
MirrorLog
.
warn
(
"
Error
notifying
observer
"
ex
)
;
}
}
}
function
isLivemarkAnno
(
name
)
{
return
name
=
=
PlacesUtils
.
LMANNO_FEEDURI
|
|
name
=
=
PlacesUtils
.
LMANNO_SITEURI
;
}
class
BookmarkChangeRecord
{
constructor
(
syncChangeCounter
cleartext
)
{
this
.
tombstone
=
cleartext
.
deleted
=
=
=
true
;
this
.
counter
=
syncChangeCounter
;
this
.
cleartext
=
cleartext
;
this
.
synced
=
false
;
}
}
