"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SyncedBookmarksMirror
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Async
:
"
resource
:
/
/
services
-
common
/
async
.
js
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
PlacesSyncUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
MirrorLog
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Sync
.
Engine
.
Bookmarks
.
Mirror
"
)
)
;
const
SyncedBookmarksMerger
=
Components
.
Constructor
(
"
mozilla
.
org
/
browser
/
synced
-
bookmarks
-
merger
;
1
"
"
mozISyncedBookmarksMerger
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
LocalItemsSQLFragment
"
(
)
=
>
localItems
(
id
guid
parentId
parentGuid
position
type
title
parentTitle
placeId
dateAdded
lastModified
syncChangeCounter
isSyncable
level
)
AS
(
SELECT
b
.
id
b
.
guid
p
.
id
p
.
guid
b
.
position
b
.
type
b
.
title
p
.
title
b
.
fk
b
.
dateAdded
b
.
lastModified
b
.
syncChangeCounter
b
.
guid
IN
(
{
PlacesUtils
.
bookmarks
.
userContentRoots
.
map
(
v
=
>
'
{
v
}
'
)
.
join
(
"
"
)
}
)
0
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
guid
<
>
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
UNION
ALL
SELECT
b
.
id
b
.
guid
s
.
id
s
.
guid
b
.
position
b
.
type
b
.
title
s
.
title
b
.
fk
b
.
dateAdded
b
.
lastModified
b
.
syncChangeCounter
s
.
isSyncable
s
.
level
+
1
FROM
moz_bookmarks
b
JOIN
localItems
s
ON
s
.
id
=
b
.
parent
WHERE
b
.
guid
<
>
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
)
)
;
const
DB_URL_LENGTH_MAX
=
65536
;
const
DB_TITLE_LENGTH_MAX
=
4096
;
const
SQLITE_MAX_VARIABLE_NUMBER
=
999
;
const
MIRROR_SCHEMA_VERSION
=
6
;
const
DEFAULT_MAX_FRECENCIES_TO_RECALCULATE
=
400
;
XPCOMUtils
.
defineLazyGetter
(
this
"
yieldState
"
(
)
=
>
Async
.
yieldState
(
)
)
;
class
MirrorLoggerAdapter
{
constructor
(
log
)
{
this
.
log
=
log
;
}
get
maxLevel
(
)
{
let
level
=
this
.
log
.
level
;
if
(
level
<
=
Log
.
Level
.
All
)
{
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_TRACE
;
}
if
(
level
<
=
Log
.
Level
.
Info
)
{
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_DEBUG
;
}
if
(
level
<
=
Log
.
Level
.
Warn
)
{
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_WARN
;
}
if
(
level
<
=
Log
.
Level
.
Error
)
{
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_ERROR
;
}
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_OFF
;
}
trace
(
message
)
{
this
.
log
.
trace
(
message
)
;
}
debug
(
message
)
{
this
.
log
.
debug
(
message
)
;
}
warn
(
message
)
{
this
.
log
.
warn
(
message
)
;
}
error
(
message
)
{
this
.
log
.
error
(
message
)
;
}
}
class
ProgressTracker
{
constructor
(
recordStepTelemetry
)
{
this
.
recordStepTelemetry
=
recordStepTelemetry
;
this
.
steps
=
[
]
;
}
step
(
name
)
{
this
.
steps
.
push
(
{
step
:
name
at
:
Date
.
now
(
)
}
)
;
}
stepWithTelemetry
(
name
took
counts
=
null
)
{
this
.
step
(
name
)
;
this
.
recordStepTelemetry
(
name
took
counts
)
;
}
stepWithItemCount
(
name
took
count
)
{
this
.
stepWithTelemetry
(
name
took
[
{
name
:
"
items
"
count
}
]
)
;
}
reset
(
)
{
this
.
steps
=
[
]
;
}
fetchState
(
)
{
return
{
steps
:
this
.
steps
}
;
}
}
ProgressTracker
.
STEPS
=
{
FETCH_LOCAL_TREE
:
"
fetchLocalTree
"
FETCH_REMOTE_TREE
:
"
fetchRemoteTree
"
MERGE
:
"
merge
"
APPLY
:
"
apply
"
NOTIFY_OBSERVERS
:
"
notifyObservers
"
FETCH_LOCAL_CHANGE_RECORDS
:
"
fetchLocalChangeRecords
"
FINALIZE
:
"
finalize
"
}
;
class
SyncedBookmarksMirror
{
constructor
(
db
{
recordTelemetryEvent
recordStepTelemetry
recordValidationTelemetry
finalizeAt
=
AsyncShutdown
.
profileBeforeChange
}
=
{
}
)
{
this
.
db
=
db
;
this
.
recordTelemetryEvent
=
recordTelemetryEvent
;
this
.
recordValidationTelemetry
=
recordValidationTelemetry
;
this
.
merger
=
new
SyncedBookmarksMerger
(
)
;
this
.
merger
.
db
=
db
.
unsafeRawConnection
.
QueryInterface
(
Ci
.
mozIStorageConnection
)
;
this
.
merger
.
logger
=
new
MirrorLoggerAdapter
(
MirrorLog
)
;
this
.
progress
=
new
ProgressTracker
(
recordStepTelemetry
)
;
this
.
finalizeAt
=
finalizeAt
;
this
.
finalizeBound
=
(
)
=
>
this
.
finalize
(
)
;
this
.
finalizeAt
.
addBlocker
(
"
SyncedBookmarksMirror
:
finalize
"
this
.
finalizeBound
{
fetchState
:
(
)
=
>
this
.
progress
}
)
;
}
static
async
open
(
options
)
{
let
db
=
await
Sqlite
.
cloneStorageConnection
(
{
connection
:
PlacesUtils
.
history
.
DBConnection
readOnly
:
false
}
)
;
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
options
.
path
)
;
let
whyFailed
=
"
initialize
"
;
try
{
await
db
.
execute
(
PRAGMA
foreign_keys
=
ON
)
;
try
{
await
attachAndInitMirrorDatabase
(
db
path
)
;
}
catch
(
ex
)
{
if
(
isDatabaseCorrupt
(
ex
)
)
{
MirrorLog
.
warn
(
"
Error
attaching
mirror
to
Places
;
removing
and
"
+
"
recreating
mirror
"
ex
)
;
options
.
recordTelemetryEvent
(
"
mirror
"
"
open
"
"
retry
"
{
why
:
"
corrupt
"
}
)
;
whyFailed
=
"
remove
"
;
await
OS
.
File
.
remove
(
path
)
;
whyFailed
=
"
replace
"
;
await
attachAndInitMirrorDatabase
(
db
path
)
;
}
else
{
MirrorLog
.
error
(
"
Unrecoverable
error
attaching
mirror
to
Places
"
ex
)
;
throw
ex
;
}
}
try
{
let
info
=
await
OS
.
File
.
stat
(
path
)
;
let
size
=
Math
.
floor
(
info
.
size
/
1024
)
;
options
.
recordTelemetryEvent
(
"
mirror
"
"
open
"
"
success
"
{
size
}
)
;
}
catch
(
ex
)
{
MirrorLog
.
warn
(
"
Error
recording
stats
for
mirror
database
size
"
ex
)
;
}
}
catch
(
ex
)
{
options
.
recordTelemetryEvent
(
"
mirror
"
"
open
"
"
error
"
{
why
:
whyFailed
}
)
;
await
db
.
close
(
)
;
throw
ex
;
}
return
new
SyncedBookmarksMirror
(
db
options
)
;
}
async
getCollectionHighWaterMark
(
)
{
let
rows
=
await
this
.
db
.
executeCached
(
SELECT
MAX
(
IFNULL
(
(
SELECT
MAX
(
serverModified
)
-
1000
FROM
items
)
0
)
IFNULL
(
(
SELECT
CAST
(
value
AS
INTEGER
)
FROM
meta
WHERE
key
=
:
modifiedKey
)
0
)
)
AS
highWaterMark
{
modifiedKey
:
SyncedBookmarksMirror
.
META_KEY
.
LAST_MODIFIED
}
)
;
let
highWaterMark
=
rows
[
0
]
.
getResultByName
(
"
highWaterMark
"
)
;
return
highWaterMark
/
1000
;
}
async
setCollectionLastModified
(
lastModifiedSeconds
)
{
let
lastModified
=
Math
.
floor
(
lastModifiedSeconds
*
1000
)
;
if
(
!
Number
.
isInteger
(
lastModified
)
)
{
throw
new
TypeError
(
"
Invalid
collection
last
modified
time
"
)
;
}
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
setCollectionLastModified
"
db
=
>
db
.
executeCached
(
REPLACE
INTO
meta
(
key
value
)
VALUES
(
:
modifiedKey
:
lastModified
)
{
modifiedKey
:
SyncedBookmarksMirror
.
META_KEY
.
LAST_MODIFIED
lastModified
}
)
)
;
}
async
getSyncId
(
)
{
let
rows
=
await
this
.
db
.
executeCached
(
SELECT
value
FROM
meta
WHERE
key
=
:
syncIdKey
{
syncIdKey
:
SyncedBookmarksMirror
.
META_KEY
.
SYNC_ID
}
)
;
return
rows
.
length
?
rows
[
0
]
.
getResultByName
(
"
value
"
)
:
"
"
;
}
async
ensureCurrentSyncId
(
newSyncId
)
{
if
(
!
newSyncId
|
|
typeof
newSyncId
!
=
"
string
"
)
{
throw
new
TypeError
(
"
Invalid
new
bookmarks
sync
ID
"
)
;
}
let
existingSyncId
=
await
this
.
getSyncId
(
)
;
if
(
existingSyncId
=
=
newSyncId
)
{
MirrorLog
.
trace
(
"
Sync
ID
up
-
to
-
date
in
mirror
"
{
existingSyncId
}
)
;
return
;
}
MirrorLog
.
info
(
"
Sync
ID
changed
from
{
existingSyncId
}
to
"
+
"
{
newSyncId
}
;
resetting
mirror
"
{
existingSyncId
newSyncId
}
)
;
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
ensureCurrentSyncId
"
db
=
>
db
.
executeTransaction
(
async
function
(
)
{
await
resetMirror
(
db
)
;
await
db
.
execute
(
REPLACE
INTO
meta
(
key
value
)
VALUES
(
:
syncIdKey
:
newSyncId
)
{
syncIdKey
:
SyncedBookmarksMirror
.
META_KEY
.
SYNC_ID
newSyncId
}
)
;
}
)
)
;
}
async
store
(
records
{
needsMerge
=
true
}
=
{
}
)
{
let
options
=
{
needsMerge
}
;
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
store
"
db
=
>
db
.
executeTransaction
(
async
(
)
=
>
{
await
Async
.
yieldingForEach
(
records
async
record
=
>
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
if
(
guid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
)
{
throw
new
TypeError
(
"
Can
'
t
store
Places
root
"
)
;
}
MirrorLog
.
trace
(
Storing
in
mirror
:
{
record
.
cleartextToString
(
)
}
)
;
switch
(
record
.
type
)
{
case
"
bookmark
"
:
await
this
.
storeRemoteBookmark
(
record
options
)
;
return
;
case
"
query
"
:
await
this
.
storeRemoteQuery
(
record
options
)
;
return
;
case
"
folder
"
:
await
this
.
storeRemoteFolder
(
record
options
)
;
return
;
case
"
livemark
"
:
await
this
.
storeRemoteLivemark
(
record
options
)
;
return
;
case
"
separator
"
:
await
this
.
storeRemoteSeparator
(
record
options
)
;
return
;
default
:
if
(
record
.
deleted
)
{
await
this
.
storeRemoteTombstone
(
record
options
)
;
return
;
}
}
MirrorLog
.
warn
(
"
Ignoring
record
with
unknown
type
"
record
.
type
)
;
}
yieldState
)
;
}
)
)
;
}
async
apply
(
options
=
{
}
)
{
let
hasChanges
=
(
"
weakUpload
"
in
options
&
&
options
.
weakUpload
.
length
>
0
)
|
|
(
await
this
.
hasChanges
(
)
)
;
if
(
!
hasChanges
)
{
MirrorLog
.
debug
(
"
No
changes
detected
in
both
mirror
and
Places
"
)
;
let
limit
=
"
maxFrecenciesToRecalculate
"
in
options
?
options
.
maxFrecenciesToRecalculate
:
DEFAULT_MAX_FRECENCIES_TO_RECALCULATE
;
await
updateFrecencies
(
this
.
db
limit
)
;
return
{
}
;
}
let
changeRecords
=
await
this
.
forceApply
(
options
)
;
return
changeRecords
;
}
async
forceApply
(
{
localTimeSeconds
=
Date
.
now
(
)
/
1000
remoteTimeSeconds
=
0
weakUpload
=
[
]
maxFrecenciesToRecalculate
=
DEFAULT_MAX_FRECENCIES_TO_RECALCULATE
}
=
{
}
)
{
let
observersToNotify
=
new
BookmarkObserverRecorder
(
this
.
db
{
maxFrecenciesToRecalculate
}
)
;
if
(
!
(
await
this
.
validLocalRoots
(
)
)
)
{
throw
new
SyncedBookmarksMirror
.
MergeError
(
"
Local
tree
has
misparented
root
"
)
;
}
let
changeRecords
;
try
{
changeRecords
=
await
this
.
tryApply
(
localTimeSeconds
remoteTimeSeconds
observersToNotify
weakUpload
)
;
}
finally
{
this
.
progress
.
reset
(
)
;
}
return
changeRecords
;
}
async
tryApply
(
localTimeSeconds
remoteTimeSeconds
observersToNotify
weakUpload
)
{
await
withTiming
(
"
Merging
bookmarks
in
Rust
"
(
)
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
callback
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
mozISyncedBookmarksMirrorProgressListener
Ci
.
mozISyncedBookmarksMirrorCallback
]
)
onFetchLocalTree
:
(
took
count
problems
)
=
>
{
this
.
progress
.
stepWithItemCount
(
ProgressTracker
.
STEPS
.
FETCH_LOCAL_TREE
took
count
)
;
}
onFetchRemoteTree
:
(
took
count
problemsBag
)
=
>
{
this
.
progress
.
stepWithItemCount
(
ProgressTracker
.
STEPS
.
FETCH_REMOTE_TREE
took
count
)
;
let
problems
=
bagToNamedCounts
(
problemsBag
[
"
orphans
"
"
misparentedRoots
"
"
multipleParents
"
"
nonFolderParents
"
"
parentChildDisagreements
"
"
missingChildren
"
]
)
;
this
.
recordValidationTelemetry
(
took
count
problems
)
;
}
onMerge
:
(
took
countsBag
)
=
>
{
let
counts
=
bagToNamedCounts
(
countsBag
[
"
items
"
"
deletes
"
"
dupes
"
"
remoteRevives
"
"
localDeletes
"
"
localRevives
"
"
remoteDeletes
"
]
)
;
this
.
progress
.
stepWithTelemetry
(
ProgressTracker
.
STEPS
.
MERGE
took
counts
)
;
}
onApply
:
took
=
>
{
this
.
progress
.
stepWithTelemetry
(
ProgressTracker
.
STEPS
.
APPLY
took
)
;
}
handleSuccess
:
resolve
handleError
(
code
message
)
{
switch
(
code
)
{
case
Cr
.
NS_ERROR_STORAGE_BUSY
:
reject
(
new
SyncedBookmarksMirror
.
MergeConflictError
(
"
Local
tree
changed
during
merge
"
)
)
;
break
;
case
Cr
.
NS_ERROR_ABORT
:
reject
(
new
SyncedBookmarksMirror
.
ShutdownError
(
"
Merge
interrupted
at
shutdown
"
)
)
;
break
;
default
:
reject
(
new
SyncedBookmarksMirror
.
MergeError
(
message
)
)
;
}
}
}
;
this
.
merger
.
merge
(
localTimeSeconds
remoteTimeSeconds
weakUpload
callback
)
;
}
)
;
}
)
;
await
withTiming
(
"
Notifying
Places
observers
"
async
(
)
=
>
{
try
{
await
observersToNotify
.
notifyAll
(
)
;
}
catch
(
ex
)
{
MirrorLog
.
warn
(
"
Error
notifying
Places
observers
"
ex
)
;
}
finally
{
await
this
.
db
.
executeTransaction
(
async
(
)
=
>
{
await
this
.
db
.
execute
(
DELETE
FROM
itemsAdded
)
;
await
this
.
db
.
execute
(
DELETE
FROM
guidsChanged
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsChanged
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsRemoved
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsMoved
)
;
}
)
;
}
}
time
=
>
this
.
progress
.
stepWithTelemetry
(
ProgressTracker
.
STEPS
.
NOTIFY_OBSERVERS
time
)
)
;
return
withTiming
(
"
Fetching
records
for
local
items
to
upload
"
async
(
)
=
>
{
try
{
let
changeRecords
=
await
this
.
fetchLocalChangeRecords
(
)
;
return
changeRecords
;
}
finally
{
await
this
.
db
.
execute
(
DELETE
FROM
itemsToUpload
)
;
}
}
(
time
records
)
=
>
this
.
progress
.
stepWithItemCount
(
ProgressTracker
.
STEPS
.
FETCH_LOCAL_CHANGE_RECORDS
time
Object
.
keys
(
records
)
.
length
)
)
;
}
async
reset
(
)
{
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
reset
"
db
=
>
db
.
executeTransaction
(
(
)
=
>
resetMirror
(
db
)
)
)
;
}
async
fetchUnmergedGuids
(
)
{
let
rows
=
await
this
.
db
.
execute
(
SELECT
guid
FROM
items
WHERE
needsMerge
ORDER
BY
guid
)
;
return
rows
.
map
(
row
=
>
row
.
getResultByName
(
"
guid
"
)
)
;
}
async
storeRemoteBookmark
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
url
=
validateURL
(
record
.
bmkUri
)
;
if
(
url
)
{
await
this
.
maybeStoreRemoteURL
(
url
)
;
}
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
keyword
=
validateKeyword
(
record
.
keyword
)
;
let
validity
=
url
?
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_VALID
:
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REPLACE
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
title
keyword
validity
urlId
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
'
'
)
:
keyword
:
validity
(
SELECT
id
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_BOOKMARK
dateAdded
title
keyword
url
:
url
?
url
.
href
:
null
validity
}
)
;
let
tags
=
record
.
tags
;
if
(
tags
&
&
Array
.
isArray
(
tags
)
)
{
for
(
let
rawTag
of
tags
)
{
let
tag
=
validateTag
(
rawTag
)
;
if
(
!
tag
)
{
continue
;
}
await
this
.
db
.
executeCached
(
INSERT
INTO
tags
(
itemId
tag
)
SELECT
id
:
tag
FROM
items
WHERE
guid
=
:
guid
{
tag
guid
}
)
;
}
}
}
async
storeRemoteQuery
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_VALID
;
let
url
=
validateURL
(
record
.
bmkUri
)
;
if
(
url
)
{
let
params
=
new
URLSearchParams
(
url
.
pathname
)
;
let
type
=
+
params
.
get
(
"
type
"
)
;
if
(
type
=
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAG_CONTENTS
)
{
let
tagFolderName
=
validateTag
(
record
.
folderName
)
;
if
(
tagFolderName
)
{
url
.
href
=
place
:
tag
=
{
tagFolderName
}
;
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REUPLOAD
;
}
else
{
url
=
null
;
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REPLACE
;
}
}
else
{
let
folder
=
params
.
get
(
"
folder
"
)
;
if
(
folder
&
&
!
params
.
has
(
"
excludeItems
"
)
)
{
url
.
href
=
{
url
.
href
}
&
excludeItems
=
1
;
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REUPLOAD
;
}
}
await
this
.
maybeStoreRemoteURL
(
url
)
;
}
else
{
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REPLACE
;
}
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
title
urlId
validity
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
'
'
)
(
SELECT
id
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
:
validity
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_QUERY
dateAdded
title
url
:
url
?
url
.
href
:
null
validity
}
)
;
}
async
storeRemoteFolder
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
title
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
'
'
)
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_FOLDER
dateAdded
title
}
)
;
let
children
=
record
.
children
;
if
(
children
&
&
Array
.
isArray
(
children
)
)
{
for
(
let
[
offset
chunk
]
of
PlacesSyncUtils
.
chunkArray
(
children
SQLITE_MAX_VARIABLE_NUMBER
-
1
)
)
{
let
valuesFragment
=
Array
.
from
(
{
length
:
chunk
.
length
}
(
_
index
)
=
>
(
?
{
index
+
2
}
?
1
{
offset
+
index
}
)
)
.
join
(
"
"
)
;
await
this
.
db
.
execute
(
INSERT
INTO
structure
(
guid
parentGuid
position
)
VALUES
{
valuesFragment
}
[
guid
.
.
.
chunk
.
map
(
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
)
]
)
;
}
}
}
async
storeRemoteLivemark
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
feedURL
=
validateURL
(
record
.
feedUri
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
siteURL
=
validateURL
(
record
.
siteUri
)
;
let
validity
=
feedURL
?
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_VALID
:
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REPLACE
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
title
feedURL
siteURL
validity
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
'
'
)
:
feedURL
:
siteURL
:
validity
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_LIVEMARK
dateAdded
title
feedURL
:
feedURL
?
feedURL
.
href
:
null
siteURL
:
siteURL
?
siteURL
.
href
:
null
validity
}
)
;
}
async
storeRemoteSeparator
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_SEPARATOR
dateAdded
}
)
;
}
async
storeRemoteTombstone
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
serverModified
=
determineServerModified
(
record
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
isDeleted
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
1
)
{
guid
serverModified
needsMerge
}
)
;
}
async
maybeStoreRemoteURL
(
url
)
{
await
this
.
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
urls
(
guid
url
hash
revHost
)
VALUES
(
IFNULL
(
(
SELECT
guid
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
GENERATE_GUID
(
)
)
:
url
hash
(
:
url
)
:
revHost
)
{
url
:
url
.
href
revHost
:
PlacesUtils
.
getReversedHost
(
url
)
}
)
;
}
async
hasChanges
(
)
{
let
rows
=
await
this
.
db
.
execute
(
SELECT
EXISTS
(
SELECT
1
FROM
items
v
LEFT
JOIN
moz_bookmarks
b
ON
v
.
guid
=
b
.
guid
WHERE
v
.
needsMerge
AND
(
NOT
v
.
isDeleted
OR
b
.
guid
NOT
NULL
)
)
OR
EXISTS
(
WITH
RECURSIVE
{
LocalItemsSQLFragment
}
SELECT
1
FROM
localItems
WHERE
syncChangeCounter
>
0
)
OR
EXISTS
(
SELECT
1
FROM
moz_bookmarks_deleted
)
AS
hasChanges
)
;
return
!
!
rows
[
0
]
.
getResultByName
(
"
hasChanges
"
)
;
}
async
validLocalRoots
(
)
{
let
rows
=
await
this
.
db
.
execute
(
SELECT
EXISTS
(
SELECT
1
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
AND
parent
=
0
)
AND
(
SELECT
COUNT
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
guid
IN
(
{
PlacesUtils
.
bookmarks
.
userContentRoots
.
map
(
v
=
>
'
{
v
}
'
)
}
)
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
)
=
{
PlacesUtils
.
bookmarks
.
userContentRoots
.
length
}
AS
areValid
)
;
return
!
!
rows
[
0
]
.
getResultByName
(
"
areValid
"
)
;
}
async
fetchLocalChangeRecords
(
)
{
let
changeRecords
=
{
}
;
let
childRecordIdsByLocalParentId
=
new
Map
(
)
;
let
tagsByLocalId
=
new
Map
(
)
;
let
childGuidRows
=
await
this
.
db
.
execute
(
SELECT
parentId
guid
FROM
structureToUpload
ORDER
BY
parentId
position
)
;
await
Async
.
yieldingForEach
(
childGuidRows
row
=
>
{
let
localParentId
=
row
.
getResultByName
(
"
parentId
"
)
;
let
childRecordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
row
.
getResultByName
(
"
guid
"
)
)
;
let
childRecordIds
=
childRecordIdsByLocalParentId
.
get
(
localParentId
)
;
if
(
childRecordIds
)
{
childRecordIds
.
push
(
childRecordId
)
;
}
else
{
childRecordIdsByLocalParentId
.
set
(
localParentId
[
childRecordId
]
)
;
}
}
yieldState
)
;
let
tagRows
=
await
this
.
db
.
execute
(
SELECT
id
tag
FROM
tagsToUpload
)
;
await
Async
.
yieldingForEach
(
tagRows
row
=
>
{
let
localId
=
row
.
getResultByName
(
"
id
"
)
;
let
tag
=
row
.
getResultByName
(
"
tag
"
)
;
let
tags
=
tagsByLocalId
.
get
(
localId
)
;
if
(
tags
)
{
tags
.
push
(
tag
)
;
}
else
{
tagsByLocalId
.
set
(
localId
[
tag
]
)
;
}
}
yieldState
)
;
let
itemRows
=
await
this
.
db
.
execute
(
SELECT
id
syncChangeCounter
guid
isDeleted
type
isQuery
tagFolderName
keyword
url
IFNULL
(
title
'
'
)
AS
title
position
parentGuid
IFNULL
(
parentTitle
'
'
)
AS
parentTitle
dateAdded
FROM
itemsToUpload
)
;
await
Async
.
yieldingForEach
(
itemRows
row
=
>
{
let
syncChangeCounter
=
row
.
getResultByName
(
"
syncChangeCounter
"
)
;
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
recordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
guid
)
;
let
isDeleted
=
row
.
getResultByName
(
"
isDeleted
"
)
;
if
(
isDeleted
)
{
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
{
id
:
recordId
deleted
:
true
}
)
;
return
;
}
let
parentGuid
=
row
.
getResultByName
(
"
parentGuid
"
)
;
let
parentRecordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
parentGuid
)
;
let
type
=
row
.
getResultByName
(
"
type
"
)
;
switch
(
type
)
{
case
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
:
{
let
isQuery
=
row
.
getResultByName
(
"
isQuery
"
)
;
if
(
isQuery
)
{
let
queryCleartext
=
{
id
:
recordId
type
:
"
query
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
bmkUri
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
folderName
:
row
.
getResultByName
(
"
tagFolderName
"
)
|
|
undefined
}
;
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
queryCleartext
)
;
return
;
}
let
bookmarkCleartext
=
{
id
:
recordId
type
:
"
bookmark
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
bmkUri
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
}
;
let
keyword
=
row
.
getResultByName
(
"
keyword
"
)
;
if
(
keyword
)
{
bookmarkCleartext
.
keyword
=
keyword
;
}
let
localId
=
row
.
getResultByName
(
"
id
"
)
;
let
tags
=
tagsByLocalId
.
get
(
localId
)
;
if
(
tags
)
{
bookmarkCleartext
.
tags
=
tags
;
}
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
bookmarkCleartext
)
;
return
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
:
{
let
folderCleartext
=
{
id
:
recordId
type
:
"
folder
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
title
:
row
.
getResultByName
(
"
title
"
)
}
;
let
localId
=
row
.
getResultByName
(
"
id
"
)
;
let
childRecordIds
=
childRecordIdsByLocalParentId
.
get
(
localId
)
;
folderCleartext
.
children
=
childRecordIds
|
|
[
]
;
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
folderCleartext
)
;
return
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
:
{
let
separatorCleartext
=
{
id
:
recordId
type
:
"
separator
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
pos
:
row
.
getResultByName
(
"
position
"
)
}
;
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
separatorCleartext
)
;
return
;
}
default
:
throw
new
TypeError
(
"
Can
'
t
create
record
for
unknown
Places
item
"
)
;
}
}
yieldState
)
;
return
changeRecords
;
}
finalize
(
)
{
if
(
!
this
.
finalizePromise
)
{
this
.
finalizePromise
=
(
async
(
)
=
>
{
this
.
progress
.
step
(
ProgressTracker
.
STEPS
.
FINALIZE
)
;
this
.
merger
.
finalize
(
)
;
await
this
.
db
.
close
(
)
;
this
.
finalizeAt
.
removeBlocker
(
this
.
finalizeBound
)
;
}
)
(
)
;
}
return
this
.
finalizePromise
;
}
}
this
.
SyncedBookmarksMirror
=
SyncedBookmarksMirror
;
SyncedBookmarksMirror
.
META_KEY
=
{
LAST_MODIFIED
:
"
collection
/
lastModified
"
SYNC_ID
:
"
collection
/
syncId
"
}
;
class
ShutdownError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
ShutdownError
"
;
this
.
appIsShuttingDown
=
true
;
}
}
SyncedBookmarksMirror
.
ShutdownError
=
ShutdownError
;
class
MergeError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
MergeError
"
;
}
}
SyncedBookmarksMirror
.
MergeError
=
MergeError
;
class
MergeConflictError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
MergeConflictError
"
;
}
}
SyncedBookmarksMirror
.
MergeConflictError
=
MergeConflictError
;
class
DatabaseCorruptError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
DatabaseCorruptError
"
;
}
}
function
isDatabaseCorrupt
(
error
)
{
if
(
error
instanceof
DatabaseCorruptError
)
{
return
true
;
}
if
(
error
.
errors
)
{
return
error
.
errors
.
some
(
error
=
>
error
instanceof
Ci
.
mozIStorageError
&
&
(
error
.
result
=
=
Ci
.
mozIStorageError
.
CORRUPT
|
|
error
.
result
=
=
Ci
.
mozIStorageError
.
NOTADB
)
)
;
}
return
false
;
}
async
function
attachAndInitMirrorDatabase
(
db
path
)
{
await
db
.
execute
(
ATTACH
:
path
AS
mirror
{
path
}
)
;
try
{
await
db
.
executeTransaction
(
async
function
(
)
{
let
currentSchemaVersion
=
await
db
.
getSchemaVersion
(
"
mirror
"
)
;
if
(
currentSchemaVersion
>
0
)
{
if
(
currentSchemaVersion
<
MIRROR_SCHEMA_VERSION
)
{
await
migrateMirrorSchema
(
db
currentSchemaVersion
)
;
}
}
else
{
await
initializeMirrorDatabase
(
db
)
;
}
await
db
.
setSchemaVersion
(
MIRROR_SCHEMA_VERSION
"
mirror
"
)
;
await
initializeTempMirrorEntities
(
db
)
;
}
)
;
}
catch
(
ex
)
{
await
db
.
execute
(
DETACH
mirror
)
;
throw
ex
;
}
}
async
function
migrateMirrorSchema
(
db
currentSchemaVersion
)
{
if
(
currentSchemaVersion
<
5
)
{
throw
new
DatabaseCorruptError
(
Can
'
t
migrate
from
schema
version
{
currentSchemaVersion
}
;
too
old
)
;
}
if
(
currentSchemaVersion
<
6
)
{
await
db
.
execute
(
CREATE
INDEX
mirror
.
itemURLs
ON
items
(
urlId
)
)
;
await
db
.
execute
(
CREATE
INDEX
mirror
.
itemKeywords
ON
items
(
keyword
)
WHERE
keyword
NOT
NULL
)
;
}
}
async
function
initializeMirrorDatabase
(
db
)
{
await
db
.
execute
(
CREATE
TABLE
mirror
.
meta
(
key
TEXT
PRIMARY
KEY
value
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
items
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
UNIQUE
NOT
NULL
/
*
The
"
parentid
"
from
the
record
.
*
/
parentGuid
TEXT
/
*
The
server
modified
time
in
milliseconds
.
*
/
serverModified
INTEGER
NOT
NULL
DEFAULT
0
needsMerge
BOOLEAN
NOT
NULL
DEFAULT
0
validity
INTEGER
NOT
NULL
DEFAULT
{
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_VALID
}
isDeleted
BOOLEAN
NOT
NULL
DEFAULT
0
kind
INTEGER
NOT
NULL
DEFAULT
-
1
/
*
The
creation
date
in
milliseconds
.
*
/
dateAdded
INTEGER
NOT
NULL
DEFAULT
0
title
TEXT
urlId
INTEGER
REFERENCES
urls
(
id
)
ON
DELETE
SET
NULL
keyword
TEXT
description
TEXT
loadInSidebar
BOOLEAN
smartBookmarkName
TEXT
feedURL
TEXT
siteURL
TEXT
)
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
structure
(
guid
TEXT
parentGuid
TEXT
REFERENCES
items
(
guid
)
ON
DELETE
CASCADE
position
INTEGER
NOT
NULL
PRIMARY
KEY
(
parentGuid
guid
)
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
urls
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
NOT
NULL
url
TEXT
NOT
NULL
hash
INTEGER
NOT
NULL
revHost
TEXT
NOT
NULL
)
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
tags
(
itemId
INTEGER
NOT
NULL
REFERENCES
items
(
id
)
ON
DELETE
CASCADE
tag
TEXT
NOT
NULL
)
)
;
await
db
.
execute
(
CREATE
INDEX
mirror
.
urlHashes
ON
urls
(
hash
)
)
;
await
db
.
execute
(
CREATE
INDEX
mirror
.
itemURLs
ON
items
(
urlId
)
)
;
await
db
.
execute
(
CREATE
INDEX
mirror
.
itemKeywords
ON
items
(
keyword
)
WHERE
keyword
NOT
NULL
)
;
await
createMirrorRoots
(
db
)
;
}
async
function
createMirrorRoots
(
db
)
{
const
syncableRoots
=
[
{
guid
:
PlacesUtils
.
bookmarks
.
rootGuid
parentGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
position
:
-
1
needsMerge
:
false
}
.
.
.
PlacesUtils
.
bookmarks
.
userContentRoots
.
map
(
(
guid
position
)
=
>
{
return
{
guid
parentGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
position
needsMerge
:
true
}
;
}
)
]
;
for
(
let
{
guid
parentGuid
position
needsMerge
}
of
syncableRoots
)
{
await
db
.
executeCached
(
INSERT
INTO
items
(
guid
parentGuid
kind
needsMerge
)
VALUES
(
:
guid
:
parentGuid
:
kind
:
needsMerge
)
{
guid
parentGuid
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_FOLDER
needsMerge
}
)
;
await
db
.
executeCached
(
INSERT
INTO
structure
(
guid
parentGuid
position
)
VALUES
(
:
guid
:
parentGuid
:
position
)
{
guid
parentGuid
position
}
)
;
}
}
async
function
initializeTempMirrorEntities
(
db
)
{
await
db
.
execute
(
CREATE
TEMP
TABLE
changeGuidOps
(
localGuid
TEXT
PRIMARY
KEY
mergedGuid
TEXT
UNIQUE
NOT
NULL
syncStatus
INTEGER
level
INTEGER
NOT
NULL
lastModifiedMicroseconds
INTEGER
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
changeGuids
AFTER
DELETE
ON
changeGuidOps
BEGIN
/
*
Record
item
changed
notifications
for
the
updated
GUIDs
.
*
/
INSERT
INTO
guidsChanged
(
itemId
oldGuid
level
)
SELECT
b
.
id
OLD
.
localGuid
OLD
.
level
FROM
moz_bookmarks
b
WHERE
b
.
guid
=
OLD
.
localGuid
;
UPDATE
moz_bookmarks
SET
guid
=
OLD
.
mergedGuid
lastModified
=
OLD
.
lastModifiedMicroseconds
syncStatus
=
IFNULL
(
OLD
.
syncStatus
syncStatus
)
WHERE
guid
=
OLD
.
localGuid
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsToApply
(
mergedGuid
TEXT
PRIMARY
KEY
localId
INTEGER
UNIQUE
remoteId
INTEGER
UNIQUE
NOT
NULL
remoteGuid
TEXT
UNIQUE
NOT
NULL
newLevel
INTEGER
NOT
NULL
newType
INTEGER
NOT
NULL
localDateAddedMicroseconds
INTEGER
remoteDateAddedMicroseconds
INTEGER
NOT
NULL
lastModifiedMicroseconds
INTEGER
NOT
NULL
oldTitle
TEXT
newTitle
TEXT
oldPlaceId
INTEGER
newPlaceId
INTEGER
newKeyword
TEXT
)
)
;
await
db
.
execute
(
CREATE
INDEX
existingItems
ON
itemsToApply
(
localId
)
WHERE
localId
NOT
NULL
)
;
await
db
.
execute
(
CREATE
INDEX
oldPlaceIds
ON
itemsToApply
(
oldPlaceId
)
WHERE
oldPlaceId
NOT
NULL
)
;
await
db
.
execute
(
CREATE
INDEX
newPlaceIds
ON
itemsToApply
(
newPlaceId
)
WHERE
newPlaceId
NOT
NULL
)
;
await
db
.
execute
(
CREATE
INDEX
newKeywords
ON
itemsToApply
(
newKeyword
)
WHERE
newKeyword
NOT
NULL
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
applyNewLocalStructureOps
(
mergedGuid
TEXT
PRIMARY
KEY
mergedParentGuid
TEXT
NOT
NULL
position
INTEGER
NOT
NULL
level
INTEGER
NOT
NULL
lastModifiedMicroseconds
INTEGER
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
applyNewLocalStructure
AFTER
DELETE
ON
applyNewLocalStructureOps
BEGIN
INSERT
INTO
itemsMoved
(
itemId
oldParentId
oldParentGuid
oldPosition
level
)
SELECT
b
.
id
p
.
id
p
.
guid
b
.
position
OLD
.
level
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
guid
=
OLD
.
mergedGuid
;
UPDATE
moz_bookmarks
SET
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
OLD
.
mergedParentGuid
)
position
=
OLD
.
position
lastModified
=
OLD
.
lastModifiedMicroseconds
WHERE
guid
=
OLD
.
mergedGuid
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsToRemove
(
guid
TEXT
PRIMARY
KEY
localLevel
INTEGER
NOT
NULL
shouldUploadTombstone
BOOLEAN
NOT
NULL
dateRemovedMicroseconds
INTEGER
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
VIEW
localTags
(
tagEntryId
tagEntryGuid
tagFolderId
tagFolderGuid
tagEntryPosition
tagEntryType
tag
placeId
lastModifiedMicroseconds
)
AS
SELECT
b
.
id
b
.
guid
p
.
id
p
.
guid
b
.
position
b
.
type
p
.
title
b
.
fk
b
.
lastModified
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
type
=
{
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
}
AND
p
.
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
untagLocalPlace
INSTEAD
OF
DELETE
ON
localTags
BEGIN
/
*
Record
an
item
removed
notification
for
the
tag
entry
.
*
/
INSERT
INTO
itemsRemoved
(
itemId
parentId
position
type
placeId
guid
parentGuid
isUntagging
)
VALUES
(
OLD
.
tagEntryId
OLD
.
tagFolderId
OLD
.
tagEntryPosition
OLD
.
tagEntryType
OLD
.
placeId
OLD
.
tagEntryGuid
OLD
.
tagFolderGuid
1
)
;
DELETE
FROM
moz_bookmarks
WHERE
id
=
OLD
.
tagEntryId
;
/
*
Fix
the
positions
of
the
sibling
tag
entries
.
*
/
UPDATE
moz_bookmarks
SET
position
=
position
-
1
WHERE
parent
=
OLD
.
tagFolderId
AND
position
>
OLD
.
tagEntryPosition
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
tagLocalPlace
INSTEAD
OF
INSERT
ON
localTags
BEGIN
/
*
Ensure
the
tag
folder
exists
.
*
/
INSERT
OR
IGNORE
INTO
moz_bookmarks
(
guid
parent
position
type
title
dateAdded
lastModified
)
VALUES
(
IFNULL
(
(
SELECT
b
.
guid
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
title
=
NEW
.
tag
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
GENERATE_GUID
(
)
)
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
(
SELECT
COUNT
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
{
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
NEW
.
tag
NEW
.
lastModifiedMicroseconds
NEW
.
lastModifiedMicroseconds
)
;
/
*
Record
an
item
added
notification
if
we
created
a
tag
folder
.
"
CHANGES
(
)
"
returns
the
number
of
rows
affected
by
the
INSERT
above
:
1
if
we
created
the
folder
or
0
if
the
folder
already
existed
.
*
/
INSERT
INTO
itemsAdded
(
guid
isTagging
)
SELECT
b
.
guid
1
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
CHANGES
(
)
>
0
AND
b
.
title
=
NEW
.
tag
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
;
/
*
Add
a
tag
entry
for
the
URL
under
the
tag
folder
.
Omitting
the
place
ID
creates
a
tag
folder
without
tagging
the
URL
.
*
/
INSERT
OR
IGNORE
INTO
moz_bookmarks
(
guid
parent
position
type
fk
dateAdded
lastModified
)
SELECT
GENERATE_GUID
(
)
(
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
AND
b
.
title
=
NEW
.
tag
)
(
SELECT
COUNT
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
p
.
title
=
NEW
.
tag
AND
p
.
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
)
{
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
}
NEW
.
placeId
NEW
.
lastModifiedMicroseconds
NEW
.
lastModifiedMicroseconds
WHERE
NEW
.
placeId
NOT
NULL
;
/
*
Record
an
item
added
notification
for
the
tag
entry
.
*
/
INSERT
INTO
itemsAdded
(
guid
isTagging
)
SELECT
b
.
guid
1
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
fk
=
NEW
.
placeId
AND
p
.
title
=
NEW
.
tag
AND
p
.
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsAdded
(
guid
TEXT
PRIMARY
KEY
isTagging
BOOLEAN
NOT
NULL
DEFAULT
0
keywordChanged
BOOLEAN
NOT
NULL
DEFAULT
0
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
guidsChanged
(
itemId
INTEGER
NOT
NULL
oldGuid
TEXT
NOT
NULL
level
INTEGER
NOT
NULL
DEFAULT
-
1
PRIMARY
KEY
(
itemId
oldGuid
)
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsChanged
(
itemId
INTEGER
PRIMARY
KEY
oldTitle
TEXT
oldPlaceId
INTEGER
keywordChanged
BOOLEAN
NOT
NULL
DEFAULT
0
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsMoved
(
itemId
INTEGER
PRIMARY
KEY
oldParentId
INTEGER
NOT
NULL
oldParentGuid
TEXT
NOT
NULL
oldPosition
INTEGER
NOT
NULL
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsRemoved
(
guid
TEXT
PRIMARY
KEY
itemId
INTEGER
NOT
NULL
parentId
INTEGER
NOT
NULL
position
INTEGER
NOT
NULL
type
INTEGER
NOT
NULL
placeId
INTEGER
parentGuid
TEXT
NOT
NULL
/
*
We
record
the
original
level
of
the
removed
item
in
the
tree
so
that
we
can
notify
children
before
parents
.
*
/
level
INTEGER
NOT
NULL
DEFAULT
-
1
isUntagging
BOOLEAN
NOT
NULL
DEFAULT
0
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsToUpload
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
UNIQUE
NOT
NULL
syncChangeCounter
INTEGER
NOT
NULL
isDeleted
BOOLEAN
NOT
NULL
DEFAULT
0
parentGuid
TEXT
parentTitle
TEXT
dateAdded
INTEGER
/
*
In
milliseconds
.
*
/
type
INTEGER
title
TEXT
placeId
INTEGER
isQuery
BOOLEAN
NOT
NULL
DEFAULT
0
url
TEXT
tagFolderName
TEXT
keyword
TEXT
position
INTEGER
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
structureToUpload
(
guid
TEXT
PRIMARY
KEY
parentId
INTEGER
NOT
NULL
REFERENCES
itemsToUpload
(
id
)
ON
DELETE
CASCADE
position
INTEGER
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
tagsToUpload
(
id
INTEGER
REFERENCES
itemsToUpload
(
id
)
ON
DELETE
CASCADE
tag
TEXT
PRIMARY
KEY
(
id
tag
)
)
WITHOUT
ROWID
)
;
}
async
function
resetMirror
(
db
)
{
await
db
.
execute
(
DELETE
FROM
meta
)
;
await
db
.
execute
(
DELETE
FROM
structure
)
;
await
db
.
execute
(
DELETE
FROM
items
)
;
await
db
.
execute
(
DELETE
FROM
urls
)
;
await
createMirrorRoots
(
db
)
;
}
function
determineServerModified
(
record
)
{
return
Math
.
max
(
record
.
modified
*
1000
0
)
|
|
0
;
}
function
determineDateAdded
(
record
)
{
let
serverModified
=
determineServerModified
(
record
)
;
return
PlacesSyncUtils
.
bookmarks
.
ratchetTimestampBackwards
(
record
.
dateAdded
serverModified
)
;
}
function
validateTitle
(
rawTitle
)
{
if
(
typeof
rawTitle
!
=
"
string
"
|
|
!
rawTitle
)
{
return
null
;
}
return
rawTitle
.
slice
(
0
DB_TITLE_LENGTH_MAX
)
;
}
function
validateURL
(
rawURL
)
{
if
(
typeof
rawURL
!
=
"
string
"
|
|
rawURL
.
length
>
DB_URL_LENGTH_MAX
)
{
return
null
;
}
let
url
=
null
;
try
{
url
=
new
URL
(
rawURL
)
;
}
catch
(
ex
)
{
}
return
url
;
}
function
validateKeyword
(
rawKeyword
)
{
if
(
typeof
rawKeyword
!
=
"
string
"
)
{
return
null
;
}
let
keyword
=
rawKeyword
.
trim
(
)
;
return
keyword
?
keyword
.
toLowerCase
(
)
:
null
;
}
function
validateTag
(
rawTag
)
{
if
(
typeof
rawTag
!
=
"
string
"
)
{
return
null
;
}
let
tag
=
rawTag
.
trim
(
)
;
if
(
!
tag
|
|
tag
.
length
>
PlacesUtils
.
bookmarks
.
MAX_TAG_LENGTH
)
{
return
null
;
}
return
tag
;
}
async
function
withTiming
(
name
func
recordTiming
)
{
MirrorLog
.
debug
(
name
)
;
let
startTime
=
Cu
.
now
(
)
;
let
result
=
await
func
(
)
;
let
elapsedTime
=
Cu
.
now
(
)
-
startTime
;
MirrorLog
.
debug
(
{
name
}
took
{
elapsedTime
.
toFixed
(
3
)
}
ms
)
;
if
(
typeof
recordTiming
=
=
"
function
"
)
{
recordTiming
(
elapsedTime
result
)
;
}
return
result
;
}
class
BookmarkObserverRecorder
{
constructor
(
db
{
maxFrecenciesToRecalculate
}
)
{
this
.
db
=
db
;
this
.
maxFrecenciesToRecalculate
=
maxFrecenciesToRecalculate
;
this
.
placesEvents
=
[
]
;
this
.
itemRemovedNotifications
=
[
]
;
this
.
guidChangedArgs
=
[
]
;
this
.
itemMovedArgs
=
[
]
;
this
.
itemChangedArgs
=
[
]
;
this
.
shouldInvalidateKeywords
=
false
;
}
async
notifyAll
(
)
{
await
this
.
noteAllChanges
(
)
;
if
(
this
.
shouldInvalidateKeywords
)
{
await
PlacesUtils
.
keywords
.
invalidateCachedKeywords
(
)
;
}
await
this
.
notifyBookmarkObservers
(
)
;
await
updateFrecencies
(
this
.
db
this
.
maxFrecenciesToRecalculate
)
;
}
async
noteAllChanges
(
)
{
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
removed
items
"
)
;
let
removedItemRows
=
await
this
.
db
.
execute
(
SELECT
v
.
itemId
AS
id
v
.
parentId
v
.
parentGuid
v
.
position
v
.
type
h
.
url
v
.
guid
v
.
isUntagging
FROM
itemsRemoved
v
LEFT
JOIN
moz_places
h
ON
h
.
id
=
v
.
placeId
ORDER
BY
v
.
level
DESC
v
.
parentId
v
.
position
)
;
await
Async
.
yieldingForEach
(
removedItemRows
row
=
>
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
position
:
row
.
getResultByName
(
"
position
"
)
type
:
row
.
getResultByName
(
"
type
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
isUntagging
:
row
.
getResultByName
(
"
isUntagging
"
)
}
;
this
.
noteItemRemoved
(
info
)
;
}
yieldState
)
;
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
changed
GUIDs
"
)
;
let
changedGuidRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
lastModified
b
.
type
b
.
guid
AS
newGuid
c
.
oldGuid
p
.
id
AS
parentId
p
.
guid
AS
parentGuid
FROM
guidsChanged
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
ORDER
BY
c
.
level
p
.
id
b
.
position
)
;
await
Async
.
yieldingForEach
(
changedGuidRows
row
=
>
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
lastModified
:
row
.
getResultByName
(
"
lastModified
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newGuid
:
row
.
getResultByName
(
"
newGuid
"
)
oldGuid
:
row
.
getResultByName
(
"
oldGuid
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
}
;
this
.
noteGuidChanged
(
info
)
;
}
yieldState
)
;
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
new
items
"
)
;
let
newItemRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
p
.
id
AS
parentId
b
.
position
b
.
type
h
.
url
IFNULL
(
b
.
title
'
'
)
AS
title
b
.
dateAdded
b
.
guid
p
.
guid
AS
parentGuid
n
.
isTagging
n
.
keywordChanged
FROM
itemsAdded
n
JOIN
moz_bookmarks
b
ON
b
.
guid
=
n
.
guid
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
ORDER
BY
n
.
level
p
.
id
b
.
position
)
;
await
Async
.
yieldingForEach
(
newItemRows
row
=
>
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
position
:
row
.
getResultByName
(
"
position
"
)
type
:
row
.
getResultByName
(
"
type
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
isTagging
:
row
.
getResultByName
(
"
isTagging
"
)
}
;
this
.
noteItemAdded
(
info
)
;
if
(
row
.
getResultByName
(
"
keywordChanged
"
)
)
{
this
.
shouldInvalidateKeywords
=
true
;
}
}
yieldState
)
;
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
moved
items
"
)
;
let
movedItemRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
guid
b
.
type
p
.
id
AS
newParentId
c
.
oldParentId
p
.
guid
AS
newParentGuid
c
.
oldParentGuid
b
.
position
AS
newPosition
c
.
oldPosition
h
.
url
FROM
itemsMoved
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
ORDER
BY
c
.
level
newParentId
newPosition
)
;
await
Async
.
yieldingForEach
(
movedItemRows
row
=
>
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newParentId
:
row
.
getResultByName
(
"
newParentId
"
)
oldParentId
:
row
.
getResultByName
(
"
oldParentId
"
)
newParentGuid
:
row
.
getResultByName
(
"
newParentGuid
"
)
oldParentGuid
:
row
.
getResultByName
(
"
oldParentGuid
"
)
newPosition
:
row
.
getResultByName
(
"
newPosition
"
)
oldPosition
:
row
.
getResultByName
(
"
oldPosition
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
}
;
this
.
noteItemMoved
(
info
)
;
}
yieldState
)
;
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
changed
items
"
)
;
let
changedItemRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
guid
b
.
lastModified
b
.
type
IFNULL
(
b
.
title
'
'
)
AS
newTitle
IFNULL
(
c
.
oldTitle
'
'
)
AS
oldTitle
h
.
url
AS
newURL
i
.
url
AS
oldURL
p
.
id
AS
parentId
p
.
guid
AS
parentGuid
c
.
keywordChanged
FROM
itemsChanged
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
LEFT
JOIN
moz_places
i
ON
i
.
id
=
c
.
oldPlaceId
ORDER
BY
c
.
level
p
.
id
b
.
position
)
;
await
Async
.
yieldingForEach
(
changedItemRows
row
=
>
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
lastModified
:
row
.
getResultByName
(
"
lastModified
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newTitle
:
row
.
getResultByName
(
"
newTitle
"
)
oldTitle
:
row
.
getResultByName
(
"
oldTitle
"
)
newURLHref
:
row
.
getResultByName
(
"
newURL
"
)
oldURLHref
:
row
.
getResultByName
(
"
oldURL
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
}
;
this
.
noteItemChanged
(
info
)
;
if
(
row
.
getResultByName
(
"
keywordChanged
"
)
)
{
this
.
shouldInvalidateKeywords
=
true
;
}
}
yieldState
)
;
}
noteItemAdded
(
info
)
{
this
.
placesEvents
.
push
(
new
PlacesBookmarkAddition
(
{
id
:
info
.
id
parentId
:
info
.
parentId
index
:
info
.
position
url
:
info
.
urlHref
|
|
"
"
title
:
info
.
title
dateAdded
:
info
.
dateAdded
guid
:
info
.
guid
parentGuid
:
info
.
parentGuid
source
:
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
itemType
:
info
.
type
isTagging
:
info
.
isTagging
}
)
)
;
}
noteGuidChanged
(
info
)
{
PlacesUtils
.
invalidateCachedGuidFor
(
info
.
id
)
;
this
.
guidChangedArgs
.
push
(
[
info
.
id
"
guid
"
false
info
.
newGuid
info
.
lastModified
info
.
type
info
.
parentId
info
.
newGuid
info
.
parentGuid
info
.
oldGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
)
;
}
noteItemMoved
(
info
)
{
this
.
itemMovedArgs
.
push
(
[
info
.
id
info
.
oldParentId
info
.
oldPosition
info
.
newParentId
info
.
newPosition
info
.
type
info
.
guid
info
.
oldParentGuid
info
.
newParentGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
info
.
urlHref
]
)
;
}
noteItemChanged
(
info
)
{
if
(
info
.
oldTitle
!
=
info
.
newTitle
)
{
this
.
itemChangedArgs
.
push
(
[
info
.
id
"
title
"
false
info
.
newTitle
info
.
lastModified
info
.
type
info
.
parentId
info
.
guid
info
.
parentGuid
info
.
oldTitle
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
)
;
}
if
(
info
.
oldURLHref
!
=
info
.
newURLHref
)
{
this
.
itemChangedArgs
.
push
(
[
info
.
id
"
uri
"
false
info
.
newURLHref
info
.
lastModified
info
.
type
info
.
parentId
info
.
guid
info
.
parentGuid
info
.
oldURLHref
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
)
;
}
}
noteItemRemoved
(
info
)
{
let
uri
=
info
.
urlHref
?
Services
.
io
.
newURI
(
info
.
urlHref
)
:
null
;
this
.
itemRemovedNotifications
.
push
(
{
isTagging
:
info
.
isUntagging
args
:
[
info
.
id
info
.
parentId
info
.
position
info
.
type
uri
info
.
guid
info
.
parentGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
async
notifyBookmarkObservers
(
)
{
MirrorLog
.
trace
(
"
Notifying
bookmark
observers
"
)
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
for
(
let
observer
of
observers
)
{
this
.
notifyObserver
(
observer
"
onBeginUpdateBatch
"
)
;
}
await
Async
.
yieldingForEach
(
this
.
itemRemovedNotifications
info
=
>
{
this
.
notifyObserversWithInfo
(
observers
"
onItemRemoved
"
info
)
;
}
yieldState
)
;
await
Async
.
yieldingForEach
(
this
.
guidChangedArgs
args
=
>
{
this
.
notifyObserversWithInfo
(
observers
"
onItemChanged
"
{
isTagging
:
false
args
}
)
;
}
yieldState
)
;
PlacesObservers
.
notifyListeners
(
this
.
placesEvents
)
;
await
Async
.
yieldingForEach
(
this
.
itemMovedArgs
args
=
>
{
this
.
notifyObserversWithInfo
(
observers
"
onItemMoved
"
{
isTagging
:
false
args
}
)
;
}
yieldState
)
;
await
Async
.
yieldingForEach
(
this
.
itemChangedArgs
args
=
>
{
this
.
notifyObserversWithInfo
(
observers
"
onItemChanged
"
{
isTagging
:
false
args
}
)
;
}
yieldState
)
;
for
(
let
observer
of
observers
)
{
this
.
notifyObserver
(
observer
"
onEndUpdateBatch
"
)
;
}
}
notifyObserversWithInfo
(
observers
name
info
)
{
for
(
let
observer
of
observers
)
{
if
(
info
.
isTagging
&
&
observer
.
skipTags
)
{
return
;
}
this
.
notifyObserver
(
observer
name
info
.
args
)
;
}
}
notifyObserver
(
observer
notification
args
=
[
]
)
{
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
MirrorLog
.
warn
(
"
Error
notifying
observer
"
ex
)
;
}
}
}
class
BookmarkChangeRecord
{
constructor
(
syncChangeCounter
cleartext
)
{
this
.
tombstone
=
cleartext
.
deleted
=
=
=
true
;
this
.
counter
=
syncChangeCounter
;
this
.
cleartext
=
cleartext
;
this
.
synced
=
false
;
}
}
async
function
updateFrecencies
(
db
limit
)
{
MirrorLog
.
trace
(
"
Recalculating
frecencies
for
new
URLs
"
)
;
await
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
CALCULATE_FRECENCY
(
id
)
WHERE
id
IN
(
SELECT
id
FROM
moz_places
WHERE
frecency
<
0
ORDER
BY
frecency
ASC
LIMIT
:
limit
)
{
limit
}
)
;
await
db
.
execute
(
DELETE
FROM
moz_updateoriginsupdate_temp
)
;
}
function
bagToNamedCounts
(
bag
names
)
{
return
names
.
map
(
name
=
>
(
{
name
count
:
bag
.
getProperty
(
name
)
}
)
)
;
}
