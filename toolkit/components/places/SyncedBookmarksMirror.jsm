"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SyncedBookmarksMirror
"
]
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Async
:
"
resource
:
/
/
services
-
common
/
async
.
js
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
PlacesSyncUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
MirrorLog
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Sync
.
Engine
.
Bookmarks
.
Mirror
"
)
)
;
const
DB_URL_LENGTH_MAX
=
65536
;
const
DB_TITLE_LENGTH_MAX
=
4096
;
const
DB_DESCRIPTION_LENGTH_MAX
=
256
;
const
SQLITE_MAX_VARIABLE_NUMBER
=
999
;
const
MIRROR_SCHEMA_VERSION
=
1
;
XPCOMUtils
.
defineLazyGetter
(
this
"
maybeYield
"
(
)
=
>
Async
.
jankYielder
(
)
)
;
function
yieldingIterator
(
collection
)
{
return
Async
.
yieldingIterator
(
collection
maybeYield
)
;
}
class
SyncedBookmarksMirror
{
constructor
(
db
{
recordTelemetryEvent
finalizeAt
=
AsyncShutdown
.
profileBeforeChange
}
=
{
}
)
{
this
.
db
=
db
;
this
.
recordTelemetryEvent
=
recordTelemetryEvent
;
this
.
finalizeAt
=
finalizeAt
;
this
.
finalizeBound
=
(
)
=
>
this
.
finalize
(
)
;
this
.
finalizeAt
.
addBlocker
(
"
SyncedBookmarksMirror
:
finalize
"
this
.
finalizeBound
)
;
}
static
async
open
(
options
)
{
let
db
=
await
Sqlite
.
cloneStorageConnection
(
{
connection
:
PlacesUtils
.
history
.
DBConnection
readOnly
:
false
}
)
;
try
{
try
{
await
db
.
execute
(
ATTACH
:
mirrorPath
AS
mirror
{
mirrorPath
:
options
.
path
}
)
;
}
catch
(
ex
)
{
if
(
ex
.
errors
&
&
isDatabaseCorrupt
(
ex
.
errors
[
0
]
)
)
{
MirrorLog
.
warn
(
"
Error
attaching
mirror
to
Places
;
removing
and
"
+
"
recreating
mirror
"
ex
)
;
options
.
recordTelemetryEvent
(
"
mirror
"
"
open
"
"
error
"
{
why
:
"
corrupt
"
}
)
;
await
OS
.
File
.
remove
(
options
.
path
)
;
await
db
.
execute
(
ATTACH
:
mirrorPath
AS
mirror
{
mirrorPath
:
options
.
path
}
)
;
}
else
{
MirrorLog
.
warn
(
"
Unrecoverable
error
attaching
mirror
to
Places
"
ex
)
;
throw
ex
;
}
}
await
db
.
execute
(
PRAGMA
foreign_keys
=
ON
)
;
await
migrateMirrorSchema
(
db
)
;
await
initializeTempMirrorEntities
(
db
)
;
}
catch
(
ex
)
{
options
.
recordTelemetryEvent
(
"
mirror
"
"
open
"
"
error
"
{
why
:
"
initialize
"
}
)
;
await
db
.
close
(
)
;
throw
ex
;
}
return
new
SyncedBookmarksMirror
(
db
options
)
;
}
async
getCollectionHighWaterMark
(
)
{
let
rows
=
await
this
.
db
.
execute
(
SELECT
MAX
(
IFNULL
(
(
SELECT
MAX
(
serverModified
)
-
1000
FROM
items
)
0
)
IFNULL
(
(
SELECT
CAST
(
value
AS
INTEGER
)
FROM
meta
WHERE
key
=
:
modifiedKey
)
0
)
)
AS
highWaterMark
{
modifiedKey
:
SyncedBookmarksMirror
.
META
.
MODIFIED
}
)
;
let
highWaterMark
=
rows
[
0
]
.
getResultByName
(
"
highWaterMark
"
)
;
return
highWaterMark
/
1000
;
}
async
setCollectionLastModified
(
lastModifiedSeconds
)
{
let
lastModified
=
lastModifiedSeconds
*
1000
;
if
(
!
Number
.
isFinite
(
lastModified
)
)
{
throw
new
TypeError
(
"
Invalid
collection
last
modified
time
"
)
;
}
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
setCollectionLastModified
"
db
=
>
db
.
execute
(
REPLACE
INTO
meta
(
key
value
)
VALUES
(
:
modifiedKey
:
lastModified
)
{
modifiedKey
:
SyncedBookmarksMirror
.
META
.
MODIFIED
lastModified
}
)
)
;
}
async
store
(
records
{
needsMerge
=
true
}
=
{
}
)
{
let
options
=
{
needsMerge
}
;
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
store
"
db
=
>
db
.
executeTransaction
(
async
(
)
=
>
{
for
await
(
let
record
of
yieldingIterator
(
records
)
)
{
switch
(
record
.
type
)
{
case
"
bookmark
"
:
MirrorLog
.
trace
(
"
Storing
bookmark
in
mirror
"
record
.
cleartext
)
;
await
this
.
storeRemoteBookmark
(
record
options
)
;
continue
;
case
"
query
"
:
MirrorLog
.
trace
(
"
Storing
query
in
mirror
"
record
.
cleartext
)
;
await
this
.
storeRemoteQuery
(
record
options
)
;
continue
;
case
"
folder
"
:
MirrorLog
.
trace
(
"
Storing
folder
in
mirror
"
record
.
cleartext
)
;
await
this
.
storeRemoteFolder
(
record
options
)
;
continue
;
case
"
livemark
"
:
MirrorLog
.
trace
(
"
Storing
livemark
in
mirror
"
record
.
cleartext
)
;
await
this
.
storeRemoteLivemark
(
record
options
)
;
continue
;
case
"
separator
"
:
MirrorLog
.
trace
(
"
Storing
separator
in
mirror
"
record
.
cleartext
)
;
await
this
.
storeRemoteSeparator
(
record
options
)
;
continue
;
default
:
if
(
record
.
deleted
)
{
MirrorLog
.
trace
(
"
Storing
tombstone
in
mirror
"
record
.
cleartext
)
;
await
this
.
storeRemoteTombstone
(
record
options
)
;
continue
;
}
}
MirrorLog
.
warn
(
"
Ignoring
record
with
unknown
type
"
record
.
type
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
ignore
"
"
unknown
"
{
why
:
"
kind
"
}
)
;
}
}
)
)
;
}
async
apply
(
{
localTimeSeconds
=
Date
.
now
(
)
/
1000
remoteTimeSeconds
=
0
}
=
{
}
)
{
let
hasChanges
=
await
this
.
hasChanges
(
)
;
if
(
!
hasChanges
)
{
MirrorLog
.
debug
(
"
No
changes
detected
in
both
mirror
and
Places
"
)
;
return
{
}
;
}
let
{
missingParents
missingChildren
}
=
await
this
.
fetchRemoteOrphans
(
)
;
if
(
missingParents
.
length
)
{
MirrorLog
.
warn
(
"
Temporarily
reparenting
remote
items
with
missing
"
+
"
parents
to
unfiled
"
missingParents
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
orphans
"
"
parents
"
{
count
:
String
(
missingParents
.
length
)
}
)
;
}
if
(
missingChildren
.
length
)
{
MirrorLog
.
warn
(
"
Remote
tree
missing
items
"
missingChildren
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
orphans
"
"
children
"
{
count
:
String
(
missingChildren
.
length
)
}
)
;
}
let
{
missingLocal
missingRemote
}
=
await
this
.
fetchInconsistencies
(
)
;
if
(
missingLocal
.
length
)
{
MirrorLog
.
warn
(
"
Remote
tree
has
merged
items
that
don
'
t
exist
locally
"
missingLocal
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
inconsistencies
"
"
local
"
{
count
:
String
(
missingLocal
.
length
)
}
)
;
}
if
(
missingRemote
.
length
)
{
MirrorLog
.
error
(
"
Local
tree
has
synced
items
that
don
'
t
exist
remotely
"
missingRemote
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
inconsistencies
"
"
remote
"
{
count
:
String
(
missingRemote
.
length
)
}
)
;
}
MirrorLog
.
debug
(
"
Building
remote
tree
from
mirror
"
)
;
let
remoteTree
=
await
this
.
fetchRemoteTree
(
remoteTimeSeconds
)
;
if
(
MirrorLog
.
level
<
=
Log
.
Level
.
Trace
)
{
MirrorLog
.
trace
(
"
Built
remote
tree
from
mirror
\
n
"
+
remoteTree
.
toASCIITreeString
(
)
)
;
}
let
observersToNotify
=
new
BookmarkObserverRecorder
(
this
.
db
)
;
let
changeRecords
=
await
this
.
db
.
executeTransaction
(
async
(
)
=
>
{
MirrorLog
.
debug
(
"
Building
local
tree
from
Places
"
)
;
let
localTree
=
await
this
.
fetchLocalTree
(
localTimeSeconds
)
;
if
(
MirrorLog
.
level
<
=
Log
.
Level
.
Trace
)
{
MirrorLog
.
trace
(
"
Built
local
tree
from
Places
\
n
"
+
localTree
.
toASCIITreeString
(
)
)
;
}
MirrorLog
.
debug
(
"
Fetching
content
info
for
new
mirror
items
"
)
;
let
newRemoteContents
=
await
this
.
fetchNewRemoteContents
(
)
;
MirrorLog
.
debug
(
"
Fetching
content
info
for
new
Places
items
"
)
;
let
newLocalContents
=
await
this
.
fetchNewLocalContents
(
)
;
MirrorLog
.
debug
(
"
Building
complete
merged
tree
"
)
;
let
merger
=
new
BookmarkMerger
(
localTree
newLocalContents
remoteTree
newRemoteContents
)
;
let
mergedRoot
=
await
merger
.
merge
(
)
;
for
(
let
{
value
extra
}
of
merger
.
telemetryEvents
)
{
this
.
recordTelemetryEvent
(
"
mirror
"
"
merge
"
value
extra
)
;
}
if
(
MirrorLog
.
level
<
=
Log
.
Level
.
Trace
)
{
MirrorLog
.
trace
(
[
"
Built
new
merged
tree
"
mergedRoot
.
toASCIITreeString
(
)
.
.
.
merger
.
deletionsToStrings
(
)
]
.
join
(
"
\
n
"
)
)
;
}
if
(
!
await
merger
.
subsumes
(
localTree
)
)
{
throw
new
SyncedBookmarksMirror
.
ConsistencyError
(
"
Merged
tree
doesn
'
t
mention
all
items
from
local
tree
"
)
;
}
if
(
!
await
merger
.
subsumes
(
remoteTree
)
)
{
throw
new
SyncedBookmarksMirror
.
ConsistencyError
(
"
Merged
tree
doesn
'
t
mention
all
items
from
remote
tree
"
)
;
}
MirrorLog
.
debug
(
"
Applying
merged
tree
"
)
;
let
localDeletions
=
Array
.
from
(
merger
.
deleteLocally
)
.
map
(
guid
=
>
(
{
guid
level
:
localTree
.
levelForGuid
(
guid
)
}
)
)
;
let
remoteDeletions
=
Array
.
from
(
merger
.
deleteRemotely
)
;
await
this
.
updateLocalItemsInPlaces
(
mergedRoot
localDeletions
remoteDeletions
)
;
MirrorLog
.
debug
(
"
Recording
observer
notifications
"
)
;
await
this
.
noteObserverChanges
(
observersToNotify
)
;
MirrorLog
.
debug
(
"
Staging
locally
changed
items
for
upload
"
)
;
await
this
.
stageItemsToUpload
(
)
;
MirrorLog
.
debug
(
"
Fetching
records
for
local
items
to
upload
"
)
;
let
changeRecords
=
await
this
.
fetchLocalChangeRecords
(
)
;
await
this
.
db
.
execute
(
DELETE
FROM
mergeStates
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsAdded
)
;
await
this
.
db
.
execute
(
DELETE
FROM
guidsChanged
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsChanged
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsRemoved
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsMoved
)
;
await
this
.
db
.
execute
(
DELETE
FROM
annosChanged
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsToWeaklyReupload
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsToUpload
)
;
return
changeRecords
;
}
this
.
db
.
TRANSACTION_IMMEDIATE
)
;
MirrorLog
.
debug
(
"
Replaying
recorded
observer
notifications
"
)
;
try
{
await
observersToNotify
.
notifyAll
(
)
;
}
catch
(
ex
)
{
MirrorLog
.
error
(
"
Error
notifying
Places
observers
"
ex
)
;
}
return
changeRecords
;
}
async
reset
(
)
{
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
reset
"
async
function
(
db
)
{
await
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
execute
(
DELETE
FROM
meta
)
;
await
db
.
execute
(
DELETE
FROM
structure
)
;
await
db
.
execute
(
DELETE
FROM
items
)
;
await
db
.
execute
(
DELETE
FROM
urls
)
;
await
createMirrorRoots
(
db
)
;
}
)
;
}
)
;
}
async
fetchUnmergedGuids
(
)
{
let
rows
=
await
this
.
db
.
execute
(
SELECT
guid
FROM
items
WHERE
needsMerge
)
;
return
rows
.
map
(
row
=
>
row
.
getResultByName
(
"
guid
"
)
)
;
}
async
storeRemoteBookmark
(
record
{
needsMerge
}
)
{
let
guid
=
validateGuid
(
record
.
id
)
;
if
(
!
guid
)
{
MirrorLog
.
warn
(
"
Ignoring
bookmark
with
invalid
ID
"
record
.
id
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
ignore
"
"
bookmark
"
{
why
:
"
id
"
}
)
;
return
;
}
let
url
=
validateURL
(
record
.
bmkUri
)
;
if
(
!
url
)
{
MirrorLog
.
trace
(
"
Ignoring
bookmark
{
guid
}
with
invalid
URL
{
url
}
"
{
guid
url
:
record
.
bmkUri
}
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
ignore
"
"
bookmark
"
{
why
:
"
url
"
}
)
;
return
;
}
await
this
.
maybeStoreRemoteURL
(
url
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
keyword
=
validateKeyword
(
record
.
keyword
)
;
let
description
=
validateDescription
(
record
.
description
)
;
let
loadInSidebar
=
record
.
loadInSidebar
=
=
=
true
?
"
1
"
:
null
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
kind
dateAdded
title
keyword
urlId
description
loadInSidebar
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
"
"
)
:
keyword
(
SELECT
id
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
:
description
:
loadInSidebar
)
{
guid
serverModified
needsMerge
kind
:
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
dateAdded
title
keyword
url
:
url
.
href
description
loadInSidebar
}
)
;
let
tags
=
record
.
tags
;
if
(
tags
&
&
Array
.
isArray
(
tags
)
)
{
for
(
let
rawTag
of
tags
)
{
let
tag
=
validateTag
(
rawTag
)
;
if
(
!
tag
)
{
continue
;
}
await
this
.
db
.
executeCached
(
INSERT
INTO
tags
(
itemId
tag
)
SELECT
id
:
tag
FROM
items
WHERE
guid
=
:
guid
{
tag
guid
}
)
;
}
}
}
async
storeRemoteQuery
(
record
{
needsMerge
}
)
{
let
guid
=
validateGuid
(
record
.
id
)
;
if
(
!
guid
)
{
MirrorLog
.
warn
(
"
Ignoring
query
with
invalid
ID
"
record
.
id
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
ignore
"
"
query
"
{
why
:
"
id
"
}
)
;
return
;
}
let
url
=
validateURL
(
record
.
bmkUri
)
;
if
(
!
url
)
{
MirrorLog
.
trace
(
"
Ignoring
query
{
guid
}
with
invalid
URL
{
url
}
"
{
guid
url
:
record
.
bmkUri
}
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
ignore
"
"
query
"
{
why
:
"
url
"
}
)
;
return
;
}
await
this
.
maybeStoreRemoteURL
(
url
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
tagFolderName
=
validateTag
(
record
.
folderName
)
;
let
description
=
validateDescription
(
record
.
description
)
;
let
smartBookmarkName
=
typeof
record
.
queryId
=
=
"
string
"
?
record
.
queryId
:
null
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
kind
dateAdded
title
tagFolderName
urlId
description
smartBookmarkName
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
"
"
)
:
tagFolderName
(
SELECT
id
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
:
description
:
smartBookmarkName
)
{
guid
serverModified
needsMerge
kind
:
SyncedBookmarksMirror
.
KIND
.
QUERY
dateAdded
title
tagFolderName
url
:
url
.
href
description
smartBookmarkName
}
)
;
}
async
storeRemoteFolder
(
record
{
needsMerge
}
)
{
let
guid
=
validateGuid
(
record
.
id
)
;
if
(
!
guid
)
{
MirrorLog
.
warn
(
"
Ignoring
folder
with
invalid
ID
"
record
.
id
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
ignore
"
"
folder
"
{
why
:
"
id
"
}
)
;
return
;
}
if
(
guid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
)
{
MirrorLog
.
warn
(
"
Ignoring
Places
root
record
"
record
.
cleartext
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
ignore
"
"
folder
"
{
why
:
"
root
"
}
)
;
return
;
}
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
description
=
validateDescription
(
record
.
description
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
kind
dateAdded
title
description
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
"
"
)
:
description
)
{
guid
serverModified
needsMerge
kind
:
SyncedBookmarksMirror
.
KIND
.
FOLDER
dateAdded
title
description
}
)
;
let
children
=
record
.
children
;
if
(
children
&
&
Array
.
isArray
(
children
)
)
{
for
(
let
position
=
0
;
position
<
children
.
length
;
+
+
position
)
{
await
maybeYield
(
)
;
let
childRecordId
=
children
[
position
]
;
let
childGuid
=
validateGuid
(
childRecordId
)
;
if
(
!
childGuid
)
{
MirrorLog
.
warn
(
"
Ignoring
child
of
folder
{
parentGuid
}
with
"
+
"
invalid
ID
{
childRecordId
}
"
{
parentGuid
:
guid
childRecordId
}
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
ignore
"
"
child
"
{
why
:
"
id
"
}
)
;
continue
;
}
await
this
.
db
.
executeCached
(
REPLACE
INTO
structure
(
guid
parentGuid
position
)
VALUES
(
:
childGuid
:
parentGuid
:
position
)
{
childGuid
parentGuid
:
guid
position
}
)
;
}
}
}
async
storeRemoteLivemark
(
record
{
needsMerge
}
)
{
let
guid
=
validateGuid
(
record
.
id
)
;
if
(
!
guid
)
{
MirrorLog
.
warn
(
"
Ignoring
livemark
with
invalid
ID
"
record
.
id
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
ignore
"
"
livemark
"
{
why
:
"
id
"
}
)
;
return
;
}
let
feedURL
=
validateURL
(
record
.
feedUri
)
;
if
(
!
feedURL
)
{
MirrorLog
.
trace
(
"
Ignoring
livemark
{
guid
}
with
invalid
feed
URL
{
url
}
"
{
guid
url
:
record
.
feedUri
}
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
ignore
"
"
livemark
"
{
why
:
"
feed
"
}
)
;
return
;
}
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
description
=
validateDescription
(
record
.
description
)
;
let
siteURL
=
validateURL
(
record
.
siteUri
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
kind
dateAdded
title
description
feedURL
siteURL
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
"
"
)
:
description
:
feedURL
:
siteURL
)
{
guid
serverModified
needsMerge
kind
:
SyncedBookmarksMirror
.
KIND
.
LIVEMARK
dateAdded
title
description
feedURL
:
feedURL
.
href
siteURL
:
siteURL
?
siteURL
.
href
:
null
}
)
;
}
async
storeRemoteSeparator
(
record
{
needsMerge
}
)
{
let
guid
=
validateGuid
(
record
.
id
)
;
if
(
!
guid
)
{
MirrorLog
.
warn
(
"
Ignoring
separator
with
invalid
ID
"
record
.
id
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
ignore
"
"
separator
"
{
why
:
"
id
"
}
)
;
return
;
}
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
kind
dateAdded
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
)
{
guid
serverModified
needsMerge
kind
:
SyncedBookmarksMirror
.
KIND
.
SEPARATOR
dateAdded
}
)
;
}
async
storeRemoteTombstone
(
record
{
needsMerge
}
)
{
let
guid
=
validateGuid
(
record
.
id
)
;
if
(
!
guid
)
{
MirrorLog
.
warn
(
"
Ignoring
tombstone
with
invalid
ID
"
record
.
id
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
ignore
"
"
tombstone
"
{
why
:
"
id
"
}
)
;
return
;
}
if
(
PlacesUtils
.
bookmarks
.
userContentRoots
.
includes
(
guid
)
)
{
MirrorLog
.
warn
(
"
Ignoring
tombstone
for
syncable
root
"
guid
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
ignore
"
"
tombstone
"
{
why
:
"
root
"
}
)
;
return
;
}
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
isDeleted
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
1
)
{
guid
serverModified
:
determineServerModified
(
record
)
needsMerge
}
)
;
}
async
maybeStoreRemoteURL
(
url
)
{
await
this
.
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
urls
(
guid
url
hash
revHost
)
VALUES
(
IFNULL
(
(
SELECT
guid
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
GENERATE_GUID
(
)
)
:
url
hash
(
:
url
)
:
revHost
)
{
url
:
url
.
href
revHost
:
PlacesUtils
.
getReversedHost
(
url
)
}
)
;
}
async
fetchRemoteOrphans
(
)
{
let
infos
=
{
missingParents
:
[
]
missingChildren
:
[
]
}
;
let
orphanRows
=
await
this
.
db
.
execute
(
SELECT
v
.
guid
AS
guid
1
AS
missingParent
0
AS
missingChild
FROM
items
v
LEFT
JOIN
structure
s
ON
s
.
guid
=
v
.
guid
WHERE
NOT
v
.
isDeleted
AND
s
.
guid
IS
NULL
UNION
ALL
SELECT
s
.
guid
AS
guid
0
AS
missingParent
1
AS
missingChild
FROM
structure
s
LEFT
JOIN
items
v
ON
v
.
guid
=
s
.
guid
WHERE
v
.
guid
IS
NULL
)
;
for
await
(
let
row
of
yieldingIterator
(
orphanRows
)
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
missingParent
=
row
.
getResultByName
(
"
missingParent
"
)
;
if
(
missingParent
)
{
infos
.
missingParents
.
push
(
guid
)
;
}
let
missingChild
=
row
.
getResultByName
(
"
missingChild
"
)
;
if
(
missingChild
)
{
infos
.
missingChildren
.
push
(
guid
)
;
}
}
return
infos
;
}
async
fetchInconsistencies
(
)
{
let
infos
=
{
missingLocal
:
[
]
missingRemote
:
[
]
}
;
let
problemRows
=
await
this
.
db
.
execute
(
SELECT
v
.
guid
1
AS
missingLocal
0
AS
missingRemote
FROM
items
v
LEFT
JOIN
moz_bookmarks
b
ON
b
.
guid
=
v
.
guid
LEFT
JOIN
moz_bookmarks_deleted
d
ON
d
.
guid
=
v
.
guid
WHERE
NOT
v
.
needsMerge
AND
NOT
v
.
isDeleted
AND
b
.
guid
IS
NULL
AND
d
.
guid
IS
NULL
UNION
ALL
SELECT
b
.
guid
0
AS
missingLocal
1
AS
missingRemote
FROM
moz_bookmarks
b
LEFT
JOIN
items
v
ON
v
.
guid
=
b
.
guid
WHERE
b
.
syncStatus
=
:
syncStatus
AND
v
.
guid
IS
NULL
UNION
ALL
SELECT
d
.
guid
0
AS
missingLocal
1
AS
missingRemote
FROM
moz_bookmarks_deleted
d
LEFT
JOIN
items
v
ON
v
.
guid
=
d
.
guid
WHERE
v
.
guid
IS
NULL
{
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
)
;
for
await
(
let
row
of
yieldingIterator
(
problemRows
)
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
missingLocal
=
row
.
getResultByName
(
"
missingLocal
"
)
;
if
(
missingLocal
)
{
infos
.
missingLocal
.
push
(
guid
)
;
}
let
missingRemote
=
row
.
getResultByName
(
"
missingRemote
"
)
;
if
(
missingRemote
)
{
infos
.
missingRemote
.
push
(
guid
)
;
}
}
return
infos
;
}
async
hasChanges
(
)
{
let
rows
=
await
this
.
db
.
execute
(
SELECT
EXISTS
(
SELECT
1
FROM
items
v
LEFT
JOIN
moz_bookmarks
b
ON
v
.
guid
=
b
.
guid
WHERE
v
.
needsMerge
AND
(
NOT
v
.
isDeleted
OR
b
.
guid
NOT
NULL
)
)
OR
EXISTS
(
WITH
RECURSIVE
syncedItems
(
id
syncChangeCounter
)
AS
(
SELECT
b
.
id
b
.
syncChangeCounter
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
'
menu________
'
'
toolbar_____
'
'
unfiled_____
'
'
mobile______
'
)
UNION
ALL
SELECT
b
.
id
b
.
syncChangeCounter
FROM
moz_bookmarks
b
JOIN
syncedItems
s
ON
b
.
parent
=
s
.
id
)
SELECT
1
FROM
syncedItems
WHERE
syncChangeCounter
>
0
)
OR
EXISTS
(
SELECT
1
FROM
moz_bookmarks_deleted
)
AS
hasChanges
)
;
return
!
!
rows
[
0
]
.
getResultByName
(
"
hasChanges
"
)
;
}
async
fetchRemoteTree
(
remoteTimeSeconds
)
{
let
remoteTree
=
new
BookmarkTree
(
BookmarkNode
.
root
(
)
)
;
let
startTime
=
Cu
.
now
(
)
;
let
itemRows
=
await
this
.
db
.
execute
(
SELECT
v
.
guid
IFNULL
(
s
.
parentGuid
:
unfiledGuid
)
AS
parentGuid
IFNULL
(
s
.
position
-
1
)
AS
position
v
.
serverModified
v
.
kind
v
.
needsMerge
FROM
items
v
LEFT
JOIN
structure
s
ON
s
.
guid
=
v
.
guid
WHERE
NOT
v
.
isDeleted
AND
v
.
guid
<
>
:
rootGuid
ORDER
BY
parentGuid
position
=
-
1
position
v
.
guid
{
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
}
)
;
let
pseudoTree
=
new
Map
(
)
;
for
await
(
let
row
of
yieldingIterator
(
itemRows
)
)
{
let
parentGuid
=
row
.
getResultByName
(
"
parentGuid
"
)
;
let
node
=
BookmarkNode
.
fromRemoteRow
(
row
remoteTimeSeconds
)
;
if
(
pseudoTree
.
has
(
parentGuid
)
)
{
let
nodes
=
pseudoTree
.
get
(
parentGuid
)
;
nodes
.
push
(
node
)
;
}
else
{
pseudoTree
.
set
(
parentGuid
[
node
]
)
;
}
}
await
inflateTree
(
remoteTree
pseudoTree
PlacesUtils
.
bookmarks
.
rootGuid
)
;
let
tombstoneRows
=
await
this
.
db
.
execute
(
SELECT
guid
FROM
items
WHERE
isDeleted
AND
needsMerge
)
;
for
await
(
let
row
of
yieldingIterator
(
tombstoneRows
)
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
remoteTree
.
noteDeleted
(
guid
)
;
}
let
elapsedTime
=
Cu
.
now
(
)
-
startTime
;
let
totalRows
=
itemRows
.
length
+
tombstoneRows
.
length
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
fetch
"
"
remoteTree
"
{
time
:
String
(
elapsedTime
)
count
:
String
(
totalRows
)
}
)
;
return
remoteTree
;
}
async
fetchNewRemoteContents
(
)
{
let
newRemoteContents
=
new
Map
(
)
;
let
startTime
=
Cu
.
now
(
)
;
let
rows
=
await
this
.
db
.
execute
(
SELECT
v
.
guid
IFNULL
(
v
.
title
"
"
)
AS
title
u
.
url
v
.
smartBookmarkName
IFNULL
(
s
.
position
-
1
)
AS
position
FROM
items
v
LEFT
JOIN
urls
u
ON
u
.
id
=
v
.
urlId
LEFT
JOIN
structure
s
ON
s
.
guid
=
v
.
guid
LEFT
JOIN
moz_bookmarks
b
ON
b
.
guid
=
v
.
guid
WHERE
NOT
v
.
isDeleted
AND
v
.
needsMerge
AND
b
.
guid
IS
NULL
AND
IFNULL
(
s
.
parentGuid
:
unfiledGuid
)
<
>
:
rootGuid
{
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
}
)
;
for
await
(
let
row
of
yieldingIterator
(
rows
)
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
content
=
BookmarkContent
.
fromRow
(
row
)
;
newRemoteContents
.
set
(
guid
content
)
;
}
let
elapsedTime
=
Cu
.
now
(
)
-
startTime
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
fetch
"
"
newRemoteContents
"
{
time
:
String
(
elapsedTime
)
count
:
String
(
rows
.
length
)
}
)
;
return
newRemoteContents
;
}
async
fetchLocalTree
(
localTimeSeconds
)
{
let
localTree
=
new
BookmarkTree
(
BookmarkNode
.
root
(
)
)
;
let
startTime
=
Cu
.
now
(
)
;
let
itemRows
=
await
this
.
db
.
execute
(
WITH
RECURSIVE
syncedItems
(
id
level
)
AS
(
SELECT
b
.
id
0
AS
level
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
:
menuGuid
:
toolbarGuid
:
unfiledGuid
:
mobileGuid
)
UNION
ALL
SELECT
b
.
id
s
.
level
+
1
AS
level
FROM
moz_bookmarks
b
JOIN
syncedItems
s
ON
s
.
id
=
b
.
parent
)
SELECT
b
.
id
b
.
guid
p
.
guid
AS
parentGuid
/
*
Map
Places
item
types
to
Sync
record
kinds
.
*
/
(
CASE
b
.
type
WHEN
:
bookmarkType
THEN
(
CASE
SUBSTR
(
(
SELECT
h
.
url
FROM
moz_places
h
WHERE
h
.
id
=
b
.
fk
)
1
6
)
/
*
Queries
are
bookmarks
with
a
"
place
:
"
URL
scheme
.
*
/
WHEN
'
place
:
'
THEN
:
queryKind
ELSE
:
bookmarkKind
END
)
WHEN
:
folderType
THEN
(
CASE
WHEN
EXISTS
(
/
*
Livemarks
are
folders
with
a
feed
URL
annotation
.
*
/
SELECT
1
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
a
.
item_id
=
b
.
id
AND
n
.
name
=
:
feedURLAnno
)
THEN
:
livemarkKind
ELSE
:
folderKind
END
)
ELSE
:
separatorKind
END
)
AS
kind
b
.
lastModified
b
.
syncChangeCounter
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
syncedItems
s
ON
s
.
id
=
b
.
id
ORDER
BY
s
.
level
b
.
parent
b
.
position
{
menuGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
toolbarGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
mobileGuid
:
PlacesUtils
.
bookmarks
.
mobileGuid
bookmarkType
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
queryKind
:
SyncedBookmarksMirror
.
KIND
.
QUERY
bookmarkKind
:
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
folderType
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
feedURLAnno
:
PlacesUtils
.
LMANNO_FEEDURI
livemarkKind
:
SyncedBookmarksMirror
.
KIND
.
LIVEMARK
folderKind
:
SyncedBookmarksMirror
.
KIND
.
FOLDER
separatorKind
:
SyncedBookmarksMirror
.
KIND
.
SEPARATOR
}
)
;
for
await
(
let
row
of
yieldingIterator
(
itemRows
)
)
{
let
parentGuid
=
row
.
getResultByName
(
"
parentGuid
"
)
;
let
node
=
BookmarkNode
.
fromLocalRow
(
row
localTimeSeconds
)
;
localTree
.
insert
(
parentGuid
node
)
;
}
let
tombstoneRows
=
await
this
.
db
.
execute
(
SELECT
guid
FROM
moz_bookmarks_deleted
)
;
for
await
(
let
row
of
yieldingIterator
(
tombstoneRows
)
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
localTree
.
noteDeleted
(
guid
)
;
}
let
elapsedTime
=
Cu
.
now
(
)
-
startTime
;
let
totalRows
=
itemRows
.
length
+
tombstoneRows
.
length
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
fetch
"
"
localTree
"
{
time
:
String
(
elapsedTime
)
count
:
String
(
totalRows
)
}
)
;
return
localTree
;
}
async
fetchNewLocalContents
(
)
{
let
newLocalContents
=
new
Map
(
)
;
let
startTime
=
Cu
.
now
(
)
;
let
rows
=
await
this
.
db
.
execute
(
SELECT
b
.
guid
IFNULL
(
b
.
title
"
"
)
AS
title
h
.
url
(
SELECT
a
.
content
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
a
.
item_id
=
b
.
id
AND
n
.
name
=
:
smartBookmarkAnno
)
AS
smartBookmarkName
b
.
position
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
LEFT
JOIN
items
v
ON
v
.
guid
=
b
.
guid
WHERE
v
.
guid
IS
NULL
AND
p
.
guid
<
>
:
rootGuid
AND
b
.
syncStatus
<
>
:
syncStatus
{
smartBookmarkAnno
:
PlacesSyncUtils
.
bookmarks
.
SMART_BOOKMARKS_ANNO
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
)
;
for
await
(
let
row
of
yieldingIterator
(
rows
)
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
content
=
BookmarkContent
.
fromRow
(
row
)
;
newLocalContents
.
set
(
guid
content
)
;
}
let
elapsedTime
=
Cu
.
now
(
)
-
startTime
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
fetch
"
"
newLocalContents
"
{
time
:
String
(
elapsedTime
)
count
:
String
(
rows
.
length
)
}
)
;
return
newLocalContents
;
}
async
updateLocalItemsInPlaces
(
mergedRoot
localDeletions
remoteDeletions
)
{
MirrorLog
.
debug
(
"
Setting
up
merge
states
table
"
)
;
let
mergeStatesParams
=
Array
.
from
(
mergedRoot
.
mergeStatesParams
(
)
)
;
if
(
mergeStatesParams
.
length
)
{
await
this
.
db
.
execute
(
INSERT
INTO
mergeStates
(
localGuid
mergedGuid
parentGuid
level
position
valueState
structureState
)
VALUES
(
IFNULL
(
:
localGuid
:
mergedGuid
)
:
mergedGuid
:
parentGuid
:
level
:
position
:
valueState
:
structureState
)
mergeStatesParams
)
;
}
MirrorLog
.
debug
(
"
Rewriting
tag
queries
in
mirror
"
)
;
await
this
.
rewriteRemoteTagQueries
(
)
;
MirrorLog
.
debug
(
"
Inserting
new
URLs
into
Places
"
)
;
await
this
.
db
.
execute
(
INSERT
OR
IGNORE
INTO
moz_places
(
url
url_hash
rev_host
hidden
frecency
guid
)
SELECT
u
.
url
u
.
hash
u
.
revHost
0
(
CASE
v
.
kind
WHEN
:
queryKind
THEN
0
ELSE
-
1
END
)
IFNULL
(
(
SELECT
h
.
guid
FROM
moz_places
h
WHERE
h
.
url_hash
=
u
.
hash
AND
h
.
url
=
u
.
url
)
u
.
guid
)
FROM
items
v
JOIN
urls
u
ON
u
.
id
=
v
.
urlId
JOIN
mergeStates
r
ON
r
.
mergedGuid
=
v
.
guid
WHERE
r
.
valueState
=
:
valueState
{
queryKind
:
SyncedBookmarksMirror
.
KIND
.
QUERY
valueState
:
BookmarkMergeState
.
TYPE
.
REMOTE
}
)
;
await
this
.
db
.
execute
(
DELETE
FROM
moz_updatehostsinsert_temp
)
;
MirrorLog
.
debug
(
"
Updating
value
states
for
local
bookmarks
"
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsToMerge
)
;
MirrorLog
.
debug
(
"
Updating
structure
states
for
local
bookmarks
"
)
;
await
this
.
db
.
execute
(
DELETE
FROM
structureToMerge
)
;
MirrorLog
.
debug
(
"
Removing
remotely
deleted
items
from
Places
"
)
;
for
(
let
chunk
of
PlacesSyncUtils
.
chunkArray
(
localDeletions
SQLITE_MAX_VARIABLE_NUMBER
)
)
{
let
guids
=
chunk
.
map
(
(
{
guid
}
)
=
>
guid
)
;
await
this
.
db
.
execute
(
WITH
guidsWithLevelsToDelete
(
guid
level
)
AS
(
VALUES
{
chunk
.
map
(
(
{
level
}
)
=
>
(
?
{
level
}
)
)
.
join
(
"
"
)
}
)
INSERT
INTO
itemsRemoved
(
itemId
parentId
position
type
placeId
guid
parentGuid
level
)
SELECT
b
.
id
b
.
parent
b
.
position
b
.
type
b
.
fk
b
.
guid
p
.
guid
o
.
level
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
guidsWithLevelsToDelete
o
ON
o
.
guid
=
b
.
guid
guids
)
;
await
this
.
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
-
1
WHERE
id
IN
(
SELECT
placeId
FROM
itemsRemoved
WHERE
NOT
isUntagging
)
)
;
await
this
.
db
.
execute
(
DELETE
FROM
moz_items_annos
WHERE
item_id
IN
(
SELECT
itemId
FROM
itemsRemoved
WHERE
NOT
isUntagging
)
)
;
await
this
.
db
.
execute
(
DELETE
FROM
moz_bookmarks_deleted
WHERE
guid
IN
(
SELECT
guid
FROM
itemsRemoved
)
)
;
await
this
.
db
.
execute
(
DELETE
FROM
moz_bookmarks
WHERE
id
IN
(
SELECT
itemId
FROM
itemsRemoved
WHERE
NOT
isUntagging
)
)
;
await
this
.
db
.
execute
(
UPDATE
items
SET
needsMerge
=
0
WHERE
needsMerge
AND
guid
IN
(
SELECT
guid
FROM
itemsRemoved
WHERE
NOT
isUntagging
)
)
;
}
MirrorLog
.
debug
(
"
Flagging
remotely
deleted
items
as
merged
"
)
;
for
(
let
chunk
of
PlacesSyncUtils
.
chunkArray
(
remoteDeletions
SQLITE_MAX_VARIABLE_NUMBER
)
)
{
await
this
.
db
.
execute
(
UPDATE
items
SET
needsMerge
=
0
WHERE
needsMerge
AND
guid
IN
(
{
new
Array
(
chunk
.
length
)
.
fill
(
"
?
"
)
.
join
(
"
"
)
}
)
chunk
)
;
}
}
async
rewriteRemoteTagQueries
(
)
{
await
this
.
db
.
execute
(
INSERT
INTO
localTags
(
tag
)
SELECT
v
.
tagFolderName
FROM
items
v
JOIN
mergeStates
r
ON
r
.
mergedGuid
=
v
.
guid
WHERE
r
.
valueState
=
:
valueState
AND
v
.
tagFolderName
NOT
NULL
{
valueState
:
BookmarkMergeState
.
TYPE
.
REMOTE
}
)
;
let
queryRows
=
await
this
.
db
.
execute
(
SELECT
u
.
id
AS
urlId
u
.
url
b
.
id
AS
newTagFolderId
FROM
urls
u
JOIN
items
v
ON
v
.
urlId
=
u
.
id
JOIN
mergeStates
r
ON
r
.
mergedGuid
=
v
.
guid
JOIN
moz_bookmarks
b
ON
b
.
title
=
v
.
tagFolderName
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
p
.
guid
=
:
tagsGuid
AND
r
.
valueState
=
:
valueState
AND
v
.
kind
=
:
queryKind
AND
v
.
tagFolderName
NOT
NULL
{
tagsGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
valueState
:
BookmarkMergeState
.
TYPE
.
REMOTE
queryKind
:
SyncedBookmarksMirror
.
KIND
.
QUERY
}
)
;
let
urlsParams
=
[
]
;
for
(
let
row
of
queryRows
)
{
let
url
=
new
URL
(
row
.
getResultByName
(
"
url
"
)
)
;
let
tagQueryParams
=
new
URLSearchParams
(
url
.
pathname
)
;
let
type
=
Number
(
tagQueryParams
.
get
(
"
type
"
)
)
;
if
(
type
!
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAG_CONTENTS
)
{
continue
;
}
let
newTagFolderId
=
row
.
getResultByName
(
"
newTagFolderId
"
)
;
tagQueryParams
.
set
(
"
folder
"
newTagFolderId
)
;
let
newURLHref
=
url
.
protocol
+
tagQueryParams
;
urlsParams
.
push
(
{
urlId
:
row
.
getResultByName
(
"
urlId
"
)
url
:
newURLHref
}
)
;
}
if
(
urlsParams
.
length
)
{
await
this
.
db
.
execute
(
UPDATE
urls
SET
url
=
:
url
hash
=
hash
(
:
url
)
WHERE
id
=
:
urlId
urlsParams
)
;
}
}
async
noteObserverChanges
(
observersToNotify
)
{
MirrorLog
.
debug
(
"
Recording
observer
notifications
for
removed
items
"
)
;
let
removedItemRows
=
await
this
.
db
.
execute
(
SELECT
v
.
itemId
AS
id
v
.
parentId
v
.
parentGuid
v
.
position
v
.
type
h
.
url
v
.
guid
v
.
isUntagging
FROM
itemsRemoved
v
LEFT
JOIN
moz_places
h
ON
h
.
id
=
v
.
placeId
ORDER
BY
v
.
level
DESC
v
.
parentId
v
.
position
)
;
for
await
(
let
row
of
yieldingIterator
(
removedItemRows
)
)
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
position
:
row
.
getResultByName
(
"
position
"
)
type
:
row
.
getResultByName
(
"
type
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
isUntagging
:
row
.
getResultByName
(
"
isUntagging
"
)
}
;
observersToNotify
.
noteItemRemoved
(
info
)
;
}
MirrorLog
.
debug
(
"
Recording
observer
notifications
for
changed
GUIDs
"
)
;
let
changedGuidRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
lastModified
b
.
type
b
.
guid
AS
newGuid
c
.
oldGuid
p
.
id
AS
parentId
p
.
guid
AS
parentGuid
FROM
guidsChanged
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
ORDER
BY
c
.
level
p
.
id
b
.
position
)
;
for
await
(
let
row
of
yieldingIterator
(
changedGuidRows
)
)
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
lastModified
:
row
.
getResultByName
(
"
lastModified
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newGuid
:
row
.
getResultByName
(
"
newGuid
"
)
oldGuid
:
row
.
getResultByName
(
"
oldGuid
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
}
;
observersToNotify
.
noteGuidChanged
(
info
)
;
}
MirrorLog
.
debug
(
"
Recording
observer
notifications
for
new
items
"
)
;
let
newItemRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
p
.
id
AS
parentId
b
.
position
b
.
type
h
.
url
IFNULL
(
b
.
title
"
"
)
AS
title
b
.
dateAdded
b
.
guid
p
.
guid
AS
parentGuid
n
.
isTagging
FROM
itemsAdded
n
JOIN
moz_bookmarks
b
ON
b
.
guid
=
n
.
guid
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
ORDER
BY
n
.
level
p
.
id
b
.
position
)
;
for
await
(
let
row
of
yieldingIterator
(
newItemRows
)
)
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
position
:
row
.
getResultByName
(
"
position
"
)
type
:
row
.
getResultByName
(
"
type
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
isTagging
:
row
.
getResultByName
(
"
isTagging
"
)
}
;
observersToNotify
.
noteItemAdded
(
info
)
;
}
MirrorLog
.
debug
(
"
Recording
observer
notifications
for
moved
items
"
)
;
let
movedItemRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
guid
b
.
type
p
.
id
AS
newParentId
c
.
oldParentId
p
.
guid
AS
newParentGuid
c
.
oldParentGuid
b
.
position
AS
newPosition
c
.
oldPosition
FROM
itemsMoved
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
ORDER
BY
c
.
level
newParentId
newPosition
)
;
for
await
(
let
row
of
yieldingIterator
(
movedItemRows
)
)
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newParentId
:
row
.
getResultByName
(
"
newParentId
"
)
oldParentId
:
row
.
getResultByName
(
"
oldParentId
"
)
newParentGuid
:
row
.
getResultByName
(
"
newParentGuid
"
)
oldParentGuid
:
row
.
getResultByName
(
"
oldParentGuid
"
)
newPosition
:
row
.
getResultByName
(
"
newPosition
"
)
oldPosition
:
row
.
getResultByName
(
"
oldPosition
"
)
}
;
observersToNotify
.
noteItemMoved
(
info
)
;
}
MirrorLog
.
debug
(
"
Recording
observer
notifications
for
changed
items
"
)
;
let
changedItemRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
guid
b
.
lastModified
b
.
type
IFNULL
(
b
.
title
"
"
)
AS
newTitle
IFNULL
(
c
.
oldTitle
"
"
)
AS
oldTitle
h
.
url
AS
newURL
i
.
url
AS
oldURL
p
.
id
AS
parentId
p
.
guid
AS
parentGuid
FROM
itemsChanged
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
LEFT
JOIN
moz_places
i
ON
i
.
id
=
c
.
oldPlaceId
ORDER
BY
c
.
level
p
.
id
b
.
position
)
;
for
await
(
let
row
of
yieldingIterator
(
changedItemRows
)
)
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
lastModified
:
row
.
getResultByName
(
"
lastModified
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newTitle
:
row
.
getResultByName
(
"
newTitle
"
)
oldTitle
:
row
.
getResultByName
(
"
oldTitle
"
)
newURLHref
:
row
.
getResultByName
(
"
newURL
"
)
oldURLHref
:
row
.
getResultByName
(
"
oldURL
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
}
;
observersToNotify
.
noteItemChanged
(
info
)
;
}
MirrorLog
.
debug
(
"
Recording
observer
notifications
for
changed
annos
"
)
;
let
annoRows
=
await
this
.
db
.
execute
(
SELECT
itemId
annoName
wasRemoved
FROM
annosChanged
ORDER
BY
itemId
)
;
for
await
(
let
row
of
yieldingIterator
(
annoRows
)
)
{
let
id
=
row
.
getResultByName
(
"
itemId
"
)
;
let
name
=
row
.
getResultByName
(
"
annoName
"
)
;
if
(
row
.
getResultByName
(
"
wasRemoved
"
)
)
{
observersToNotify
.
noteAnnoRemoved
(
id
name
)
;
}
else
{
observersToNotify
.
noteAnnoSet
(
id
name
)
;
}
}
MirrorLog
.
debug
(
"
Recording
notifications
for
changed
keywords
"
)
;
let
keywordsChangedRows
=
await
this
.
db
.
execute
(
SELECT
EXISTS
(
SELECT
1
FROM
itemsAdded
WHERE
keywordChanged
)
OR
EXISTS
(
SELECT
1
FROM
itemsChanged
WHERE
keywordChanged
)
AS
keywordsChanged
)
;
observersToNotify
.
shouldInvalidateKeywords
=
!
!
keywordsChangedRows
[
0
]
.
getResultByName
(
"
keywordsChanged
"
)
;
}
async
stageItemsToUpload
(
)
{
await
this
.
db
.
execute
(
INSERT
INTO
itemsToWeaklyReupload
(
id
)
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
mergeStates
r
ON
r
.
mergedGuid
=
b
.
guid
JOIN
items
v
ON
v
.
guid
=
r
.
mergedGuid
WHERE
r
.
valueState
=
:
valueState
AND
b
.
dateAdded
<
v
.
dateAdded
{
valueState
:
BookmarkMergeState
.
TYPE
.
REMOTE
}
)
;
await
this
.
db
.
execute
(
WITH
RECURSIVE
syncedItems
(
id
level
)
AS
(
SELECT
b
.
id
0
AS
level
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
:
menuGuid
:
toolbarGuid
:
unfiledGuid
:
mobileGuid
)
UNION
ALL
SELECT
b
.
id
s
.
level
+
1
AS
level
FROM
moz_bookmarks
b
JOIN
syncedItems
s
ON
s
.
id
=
b
.
parent
)
INSERT
INTO
itemsToUpload
(
id
guid
syncChangeCounter
parentGuid
parentTitle
dateAdded
type
title
isQuery
url
tags
description
loadInSidebar
smartBookmarkName
keyword
feedURL
siteURL
position
)
SELECT
b
.
id
b
.
guid
b
.
syncChangeCounter
p
.
guid
p
.
title
b
.
dateAdded
b
.
type
b
.
title
IFNULL
(
SUBSTR
(
h
.
url
1
6
)
=
'
place
:
'
0
)
h
.
url
(
SELECT
GROUP_CONCAT
(
t
.
title
'
'
)
FROM
moz_bookmarks
e
JOIN
moz_bookmarks
t
ON
t
.
id
=
e
.
parent
JOIN
moz_bookmarks
r
ON
r
.
id
=
t
.
parent
WHERE
b
.
type
=
:
bookmarkType
AND
r
.
guid
=
:
tagsGuid
AND
e
.
fk
=
h
.
id
)
(
SELECT
a
.
content
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
b
.
type
IN
(
:
bookmarkType
:
folderType
)
AND
a
.
item_id
=
b
.
id
AND
n
.
name
=
:
descriptionAnno
)
IFNULL
(
(
SELECT
a
.
content
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
a
.
item_id
=
b
.
id
AND
n
.
name
=
:
sidebarAnno
)
0
)
(
SELECT
a
.
content
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
a
.
item_id
=
b
.
id
AND
n
.
name
=
:
smartBookmarkAnno
)
(
SELECT
keyword
FROM
moz_keywords
WHERE
place_id
=
h
.
id
)
(
SELECT
a
.
content
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
b
.
type
=
:
folderType
AND
a
.
item_id
=
b
.
id
AND
n
.
name
=
:
feedURLAnno
)
(
SELECT
a
.
content
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
b
.
type
=
:
folderType
AND
a
.
item_id
=
b
.
id
AND
n
.
name
=
:
siteURLAnno
)
b
.
position
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
syncedItems
s
ON
s
.
id
=
b
.
id
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
LEFT
JOIN
itemsToWeaklyReupload
w
ON
w
.
id
=
b
.
id
WHERE
b
.
syncChangeCounter
>
=
1
OR
w
.
id
NOT
NULL
{
menuGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
toolbarGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
mobileGuid
:
PlacesUtils
.
bookmarks
.
mobileGuid
bookmarkType
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
tagsGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
descriptionAnno
:
PlacesSyncUtils
.
bookmarks
.
DESCRIPTION_ANNO
sidebarAnno
:
PlacesSyncUtils
.
bookmarks
.
SIDEBAR_ANNO
smartBookmarkAnno
:
PlacesSyncUtils
.
bookmarks
.
SMART_BOOKMARKS_ANNO
folderType
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
feedURLAnno
:
PlacesUtils
.
LMANNO_FEEDURI
siteURLAnno
:
PlacesUtils
.
LMANNO_SITEURI
}
)
;
let
queryRows
=
await
this
.
db
.
execute
(
SELECT
id
url
FROM
itemsToUpload
WHERE
isQuery
)
;
let
tagFolderNameParams
=
[
]
;
for
(
let
row
of
queryRows
)
{
let
url
=
new
URL
(
row
.
getResultByName
(
"
url
"
)
)
;
let
tagQueryParams
=
new
URLSearchParams
(
url
.
pathname
)
;
let
type
=
Number
(
tagQueryParams
.
get
(
"
type
"
)
)
;
if
(
type
=
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAG_CONTENTS
)
{
continue
;
}
let
tagFolderId
=
Number
(
tagQueryParams
.
get
(
"
folder
"
)
)
;
tagFolderNameParams
.
push
(
{
id
:
row
.
getResultByName
(
"
id
"
)
tagFolderId
folderType
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
)
;
}
if
(
tagFolderNameParams
.
length
)
{
await
this
.
db
.
execute
(
UPDATE
itemsToUpload
SET
tagFolderName
=
(
SELECT
b
.
title
FROM
moz_bookmarks
b
WHERE
b
.
id
=
:
tagFolderId
AND
b
.
type
=
:
folderType
)
WHERE
id
=
:
id
)
;
}
await
this
.
db
.
execute
(
INSERT
INTO
structureToUpload
(
guid
parentId
position
)
SELECT
b
.
guid
b
.
parent
b
.
position
FROM
moz_bookmarks
b
JOIN
itemsToUpload
o
ON
o
.
id
=
b
.
parent
)
;
await
this
.
db
.
execute
(
INSERT
OR
IGNORE
INTO
itemsToUpload
(
guid
syncChangeCounter
isDeleted
dateAdded
)
SELECT
guid
1
1
dateRemoved
FROM
moz_bookmarks_deleted
)
;
}
async
fetchLocalChangeRecords
(
)
{
let
changeRecords
=
{
}
;
let
itemRows
=
await
this
.
db
.
execute
(
SELECT
id
syncChangeCounter
guid
isDeleted
type
isQuery
smartBookmarkName
IFNULL
(
tagFolderName
"
"
)
AS
tagFolderName
loadInSidebar
keyword
tags
url
IFNULL
(
title
"
"
)
AS
title
description
feedURL
siteURL
position
parentGuid
IFNULL
(
parentTitle
"
"
)
AS
parentTitle
dateAdded
FROM
itemsToUpload
)
;
for
await
(
let
row
of
yieldingIterator
(
itemRows
)
)
{
let
syncChangeCounter
=
row
.
getResultByName
(
"
syncChangeCounter
"
)
;
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
recordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
guid
)
;
let
isDeleted
=
row
.
getResultByName
(
"
isDeleted
"
)
;
if
(
isDeleted
)
{
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
{
id
:
recordId
deleted
:
true
}
)
;
continue
;
}
let
parentGuid
=
row
.
getResultByName
(
"
parentGuid
"
)
;
let
parentRecordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
parentGuid
)
;
let
dateAdded
=
PlacesUtils
.
toDate
(
row
.
getResultByName
(
"
dateAdded
"
)
)
.
getTime
(
)
;
let
type
=
row
.
getResultByName
(
"
type
"
)
;
switch
(
type
)
{
case
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
:
{
let
isQuery
=
row
.
getResultByName
(
"
isQuery
"
)
;
if
(
isQuery
)
{
let
queryCleartext
=
{
id
:
recordId
type
:
"
query
"
parentid
:
parentRecordId
hasDupe
:
false
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
bmkUri
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
queryId
:
row
.
getResultByName
(
"
smartBookmarkName
"
)
folderName
:
row
.
getResultByName
(
"
tagFolderName
"
)
}
;
let
description
=
row
.
getResultByName
(
"
description
"
)
;
if
(
description
)
{
queryCleartext
.
description
=
description
;
}
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
queryCleartext
)
;
continue
;
}
let
bookmarkCleartext
=
{
id
:
recordId
type
:
"
bookmark
"
parentid
:
parentRecordId
hasDupe
:
false
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
bmkUri
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
}
;
let
description
=
row
.
getResultByName
(
"
description
"
)
;
if
(
description
)
{
bookmarkCleartext
.
description
=
description
;
}
let
loadInSidebar
=
row
.
getResultByName
(
"
loadInSidebar
"
)
;
if
(
loadInSidebar
)
{
bookmarkCleartext
.
loadInSidebar
=
true
;
}
let
keyword
=
row
.
getResultByName
(
"
keyword
"
)
;
if
(
keyword
)
{
bookmarkCleartext
.
keyword
=
keyword
;
}
let
tags
=
row
.
getResultByName
(
"
tags
"
)
;
if
(
tags
)
{
bookmarkCleartext
.
tags
=
tags
.
split
(
"
"
)
;
}
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
bookmarkCleartext
)
;
continue
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
:
{
let
feedURLHref
=
row
.
getResultByName
(
"
feedURL
"
)
;
if
(
feedURLHref
)
{
let
livemarkCleartext
=
{
id
:
recordId
type
:
"
livemark
"
parentid
:
parentRecordId
hasDupe
:
false
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
title
:
row
.
getResultByName
(
"
title
"
)
feedUri
:
feedURLHref
}
;
let
description
=
row
.
getResultByName
(
"
description
"
)
;
if
(
description
)
{
livemarkCleartext
.
description
=
description
;
}
let
siteURLHref
=
row
.
getResultByName
(
"
siteURL
"
)
;
if
(
siteURLHref
)
{
livemarkCleartext
.
siteUri
=
siteURLHref
;
}
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
livemarkCleartext
)
;
continue
;
}
let
folderCleartext
=
{
id
:
recordId
type
:
"
folder
"
parentid
:
parentRecordId
hasDupe
:
false
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
title
:
row
.
getResultByName
(
"
title
"
)
}
;
let
description
=
row
.
getResultByName
(
"
description
"
)
;
if
(
description
)
{
folderCleartext
.
description
=
description
;
}
let
childGuidRows
=
await
this
.
db
.
executeCached
(
SELECT
guid
FROM
structureToUpload
WHERE
parentId
=
:
id
ORDER
BY
position
{
id
:
row
.
getResultByName
(
"
id
"
)
}
)
;
folderCleartext
.
children
=
childGuidRows
.
map
(
row
=
>
{
let
childGuid
=
row
.
getResultByName
(
"
guid
"
)
;
return
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
childGuid
)
;
}
)
;
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
folderCleartext
)
;
continue
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
:
{
let
separatorCleartext
=
{
id
:
recordId
type
:
"
separator
"
parentid
:
parentRecordId
hasDupe
:
false
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
pos
:
row
.
getResultByName
(
"
position
"
)
}
;
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
separatorCleartext
)
;
continue
;
}
default
:
throw
new
TypeError
(
"
Can
'
t
create
record
for
unknown
Places
item
"
)
;
}
}
return
changeRecords
;
}
finalize
(
)
{
if
(
!
this
.
finalizePromise
)
{
this
.
finalizePromise
=
(
async
(
)
=
>
{
await
this
.
db
.
close
(
)
;
this
.
finalizeAt
.
removeBlocker
(
this
.
finalizeBound
)
;
}
)
(
)
;
}
return
this
.
finalizePromise
;
}
}
this
.
SyncedBookmarksMirror
=
SyncedBookmarksMirror
;
SyncedBookmarksMirror
.
KIND
=
{
BOOKMARK
:
1
QUERY
:
2
FOLDER
:
3
LIVEMARK
:
4
SEPARATOR
:
5
}
;
SyncedBookmarksMirror
.
META
=
{
MODIFIED
:
1
}
;
SyncedBookmarksMirror
.
ConsistencyError
=
class
ConsistencyError
extends
Error
{
}
;
function
isDatabaseCorrupt
(
error
)
{
return
error
instanceof
Ci
.
mozIStorageError
&
&
(
error
.
result
=
=
Ci
.
mozIStorageError
.
CORRUPT
|
|
error
.
result
=
=
Ci
.
mozIStorageError
.
NOTADB
)
;
}
function
migrateMirrorSchema
(
db
)
{
return
db
.
executeTransaction
(
async
function
(
)
{
let
currentSchemaVersion
=
await
db
.
getSchemaVersion
(
"
mirror
"
)
;
if
(
currentSchemaVersion
<
1
)
{
await
initializeMirrorDatabase
(
db
)
;
}
await
db
.
setSchemaVersion
(
MIRROR_SCHEMA_VERSION
"
mirror
"
)
;
}
)
;
}
async
function
initializeMirrorDatabase
(
db
)
{
await
db
.
execute
(
CREATE
TABLE
mirror
.
meta
(
key
INTEGER
PRIMARY
KEY
value
NOT
NULL
CHECK
(
key
=
{
SyncedBookmarksMirror
.
META
.
MODIFIED
}
)
)
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
items
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
UNIQUE
NOT
NULL
/
*
The
server
modified
time
in
milliseconds
.
*
/
serverModified
INTEGER
NOT
NULL
DEFAULT
0
needsMerge
BOOLEAN
NOT
NULL
DEFAULT
0
isDeleted
BOOLEAN
NOT
NULL
DEFAULT
0
kind
INTEGER
NOT
NULL
DEFAULT
-
1
/
*
The
creation
date
in
microseconds
.
*
/
dateAdded
INTEGER
NOT
NULL
DEFAULT
0
title
TEXT
urlId
INTEGER
REFERENCES
urls
(
id
)
ON
DELETE
SET
NULL
keyword
TEXT
tagFolderName
TEXT
description
TEXT
loadInSidebar
BOOLEAN
smartBookmarkName
TEXT
feedURL
TEXT
siteURL
TEXT
/
*
Only
bookmarks
and
queries
must
have
URLs
.
*
/
CHECK
(
CASE
WHEN
kind
IN
(
{
[
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
SyncedBookmarksMirror
.
KIND
.
QUERY
]
.
join
(
"
"
)
}
)
THEN
urlId
NOT
NULL
ELSE
urlId
IS
NULL
END
)
)
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
structure
(
guid
TEXT
NOT
NULL
PRIMARY
KEY
parentGuid
TEXT
NOT
NULL
REFERENCES
items
(
guid
)
ON
DELETE
CASCADE
position
INTEGER
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
urls
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
NOT
NULL
url
TEXT
NOT
NULL
hash
INTEGER
NOT
NULL
revHost
TEXT
NOT
NULL
)
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
tags
(
itemId
INTEGER
NOT
NULL
REFERENCES
items
(
id
)
ON
DELETE
CASCADE
tag
TEXT
NOT
NULL
)
)
;
await
db
.
execute
(
CREATE
INDEX
mirror
.
urlHashes
ON
urls
(
hash
)
)
;
await
createMirrorRoots
(
db
)
;
}
async
function
createMirrorRoots
(
db
)
{
const
syncableRoots
=
[
{
guid
:
PlacesUtils
.
bookmarks
.
rootGuid
parentGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
position
:
-
1
}
{
guid
:
PlacesUtils
.
bookmarks
.
menuGuid
parentGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
position
:
0
}
{
guid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
parentGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
position
:
1
}
{
guid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
parentGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
position
:
2
}
{
guid
:
PlacesUtils
.
bookmarks
.
mobileGuid
parentGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
position
:
3
}
]
;
for
(
let
info
of
syncableRoots
)
{
await
db
.
executeCached
(
INSERT
INTO
items
(
guid
kind
)
VALUES
(
:
guid
:
kind
)
{
guid
:
info
.
guid
kind
:
SyncedBookmarksMirror
.
KIND
.
FOLDER
}
)
;
await
db
.
executeCached
(
INSERT
INTO
structure
(
guid
parentGuid
position
)
VALUES
(
:
guid
:
parentGuid
:
position
)
info
)
;
}
}
async
function
initializeTempMirrorEntities
(
db
)
{
const
syncedAnnoTriggers
=
[
{
annoName
:
PlacesSyncUtils
.
bookmarks
.
DESCRIPTION_ANNO
columnName
:
"
newDescription
"
type
:
PlacesUtils
.
annotations
.
TYPE_STRING
}
{
annoName
:
PlacesSyncUtils
.
bookmarks
.
SIDEBAR_ANNO
columnName
:
"
newLoadInSidebar
"
type
:
PlacesUtils
.
annotations
.
TYPE_INT32
}
{
annoName
:
PlacesSyncUtils
.
bookmarks
.
SMART_BOOKMARKS_ANNO
columnName
:
"
newSmartBookmarkName
"
type
:
PlacesUtils
.
annotations
.
TYPE_STRING
}
{
annoName
:
PlacesUtils
.
LMANNO_FEEDURI
columnName
:
"
newFeedURL
"
type
:
PlacesUtils
.
annotations
.
TYPE_STRING
}
{
annoName
:
PlacesUtils
.
LMANNO_SITEURI
columnName
:
"
newSiteURL
"
type
:
PlacesUtils
.
annotations
.
TYPE_STRING
}
]
;
await
db
.
execute
(
CREATE
TEMP
TABLE
mergeStates
(
localGuid
TEXT
NOT
NULL
mergedGuid
TEXT
NOT
NULL
parentGuid
TEXT
NOT
NULL
level
INTEGER
NOT
NULL
position
INTEGER
NOT
NULL
valueState
INTEGER
NOT
NULL
structureState
INTEGER
NOT
NULL
PRIMARY
KEY
(
localGuid
mergedGuid
)
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
VIEW
itemsToMerge
(
localId
remoteId
hasRemoteValue
newLevel
oldGuid
newGuid
newType
newDateAdded
newTitle
oldPlaceId
newPlaceId
newKeyword
newDescription
newLoadInSidebar
newSmartBookmarkName
newFeedURL
newSiteURL
)
AS
SELECT
b
.
id
v
.
id
r
.
valueState
=
{
BookmarkMergeState
.
TYPE
.
REMOTE
}
r
.
level
r
.
localGuid
r
.
mergedGuid
(
CASE
WHEN
v
.
kind
IN
(
{
[
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
SyncedBookmarksMirror
.
KIND
.
QUERY
]
.
join
(
"
"
)
}
)
THEN
{
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
}
WHEN
v
.
kind
IN
(
{
[
SyncedBookmarksMirror
.
KIND
.
FOLDER
SyncedBookmarksMirror
.
KIND
.
LIVEMARK
]
.
join
(
"
"
)
}
)
THEN
{
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
ELSE
{
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
}
END
)
(
CASE
WHEN
b
.
dateAdded
<
v
.
dateAdded
THEN
b
.
dateAdded
ELSE
v
.
dateAdded
END
)
v
.
title
h
.
id
u
.
newPlaceId
v
.
keyword
v
.
description
v
.
loadInSidebar
v
.
smartBookmarkName
v
.
feedURL
v
.
siteURL
FROM
items
v
JOIN
mergeStates
r
ON
r
.
mergedGuid
=
v
.
guid
LEFT
JOIN
moz_bookmarks
b
ON
b
.
guid
=
r
.
localGuid
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
LEFT
JOIN
(
SELECT
h
.
id
AS
newPlaceId
u
.
id
AS
urlId
FROM
urls
u
JOIN
moz_places
h
ON
h
.
url_hash
=
u
.
hash
AND
h
.
url
=
u
.
url
)
u
ON
u
.
urlId
=
v
.
urlId
WHERE
r
.
mergedGuid
<
>
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
mergeGuids
INSTEAD
OF
DELETE
ON
itemsToMerge
BEGIN
/
*
We
update
GUIDs
here
instead
of
in
the
"
updateExistingLocalItems
"
trigger
because
deduped
items
where
we
'
re
keeping
the
local
value
state
won
'
t
have
"
needsMerge
"
set
.
*
/
UPDATE
moz_bookmarks
SET
guid
=
OLD
.
newGuid
WHERE
OLD
.
oldGuid
<
>
OLD
.
newGuid
AND
id
=
OLD
.
localId
;
/
*
Record
item
changed
notifications
for
the
updated
GUIDs
.
*
/
INSERT
INTO
guidsChanged
(
itemId
oldGuid
level
)
SELECT
OLD
.
localId
OLD
.
oldGuid
OLD
.
newLevel
WHERE
OLD
.
oldGuid
<
>
OLD
.
newGuid
;
/
*
Drop
local
tombstones
for
revived
remote
items
.
*
/
DELETE
FROM
moz_bookmarks_deleted
WHERE
guid
=
OLD
.
newGuid
;
/
*
Flag
the
remote
item
as
merged
.
*
/
UPDATE
items
SET
needsMerge
=
0
WHERE
needsMerge
AND
id
=
OLD
.
remoteId
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
insertNewLocalItems
INSTEAD
OF
DELETE
ON
itemsToMerge
WHEN
OLD
.
localId
IS
NULL
BEGIN
/
*
Record
an
item
added
notification
for
the
new
item
.
*
/
INSERT
INTO
itemsAdded
(
guid
keywordChanged
level
)
VALUES
(
OLD
.
newGuid
OLD
.
newKeyword
NOT
NULL
OR
EXISTS
(
SELECT
1
FROM
moz_keywords
WHERE
place_id
=
OLD
.
newPlaceId
OR
keyword
=
OLD
.
newKeyword
)
OLD
.
newLevel
)
;
/
*
Sync
associates
keywords
with
bookmarks
and
doesn
'
t
sync
POST
data
;
Places
associates
keywords
with
(
URL
POST
data
)
pairs
and
multiple
bookmarks
may
have
the
same
URL
.
For
simplicity
we
bump
the
change
counter
for
all
local
bookmarks
with
the
remote
URL
(
bug
1328737
)
then
remove
all
local
keywords
from
remote
URLs
and
the
remote
keyword
from
local
URLs
.
*
/
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
fk
IN
(
/
*
We
intentionally
use
"
place_id
=
OLD
.
newPlaceId
"
in
the
subquery
instead
of
"
fk
=
OLD
.
newPlaceId
OR
fk
IN
(
.
.
.
)
"
in
the
WHERE
clause
above
because
we
only
want
to
bump
the
counter
if
the
URL
has
keywords
.
*
/
SELECT
place_id
FROM
moz_keywords
WHERE
place_id
=
OLD
.
newPlaceId
OR
keyword
=
OLD
.
newKeyword
)
;
/
*
Remove
the
new
keyword
from
existing
items
and
all
keywords
from
the
new
URL
.
*
/
DELETE
FROM
moz_keywords
WHERE
place_id
=
OLD
.
newPlaceId
OR
keyword
=
OLD
.
newKeyword
;
/
*
Remove
existing
tags
for
the
new
URL
.
*
/
DELETE
FROM
localTags
WHERE
placeId
=
OLD
.
newPlaceId
;
/
*
Insert
the
new
item
using
"
-
1
"
as
the
placeholder
parent
and
position
.
We
'
ll
update
these
later
in
the
"
updateLocalStructure
"
trigger
.
*
/
INSERT
INTO
moz_bookmarks
(
guid
parent
position
type
fk
title
dateAdded
lastModified
syncStatus
syncChangeCounter
)
VALUES
(
OLD
.
newGuid
-
1
-
1
OLD
.
newType
OLD
.
newPlaceId
OLD
.
newTitle
OLD
.
newDateAdded
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
{
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
0
)
;
/
*
Insert
a
new
keyword
for
the
new
URL
if
one
is
set
.
*
/
INSERT
OR
IGNORE
INTO
moz_keywords
(
keyword
place_id
post_data
)
SELECT
OLD
.
newKeyword
OLD
.
newPlaceId
'
'
WHERE
OLD
.
newKeyword
NOT
NULL
;
/
*
Insert
new
tags
for
the
new
URL
.
*
/
INSERT
INTO
localTags
(
tag
placeId
)
SELECT
t
.
tag
OLD
.
newPlaceId
FROM
tags
t
WHERE
t
.
itemId
=
OLD
.
remoteId
;
/
*
Insert
new
synced
annos
.
These
are
almost
identical
to
the
statements
for
updates
except
we
need
an
additional
subquery
to
fetch
the
new
item
'
s
ID
.
We
can
also
skip
removing
existing
annos
.
*
/
INSERT
OR
IGNORE
INTO
moz_anno_attributes
(
name
)
VALUES
{
syncedAnnoTriggers
.
map
(
annoTrigger
=
>
(
'
{
annoTrigger
.
annoName
}
'
)
)
.
join
(
"
"
)
}
;
{
syncedAnnoTriggers
.
map
(
annoTrigger
=
>
INSERT
INTO
moz_items_annos
(
item_id
anno_attribute_id
content
flags
expiration
type
lastModified
dateAdded
)
SELECT
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
OLD
.
newGuid
)
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
'
{
annoTrigger
.
annoName
}
'
)
OLD
.
{
annoTrigger
.
columnName
}
0
{
PlacesUtils
.
annotations
.
EXPIRE_NEVER
}
{
annoTrigger
.
type
}
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
WHERE
OLD
.
{
annoTrigger
.
columnName
}
NOT
NULL
;
/
*
Record
an
anno
set
notification
for
the
new
synced
anno
.
*
/
REPLACE
INTO
annosChanged
(
itemId
annoName
wasRemoved
)
SELECT
b
.
id
'
{
annoTrigger
.
annoName
}
'
0
FROM
moz_bookmarks
b
WHERE
b
.
guid
=
OLD
.
newGuid
AND
OLD
.
{
annoTrigger
.
columnName
}
NOT
NULL
;
)
.
join
(
"
"
)
}
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
updateExistingLocalItems
INSTEAD
OF
DELETE
ON
itemsToMerge
WHEN
OLD
.
hasRemoteValue
AND
OLD
.
localId
NOT
NULL
BEGIN
/
*
Record
an
item
changed
notification
for
the
existing
item
.
*
/
INSERT
INTO
itemsChanged
(
itemId
oldTitle
oldPlaceId
keywordChanged
level
)
SELECT
id
title
OLD
.
oldPlaceId
OLD
.
newKeyword
NOT
NULL
OR
EXISTS
(
SELECT
1
FROM
moz_keywords
WHERE
place_id
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
OR
keyword
=
OLD
.
newKeyword
)
OLD
.
newLevel
FROM
moz_bookmarks
WHERE
id
=
OLD
.
localId
;
UPDATE
moz_bookmarks
SET
title
=
OLD
.
newTitle
dateAdded
=
OLD
.
newDateAdded
lastModified
=
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
syncStatus
=
{
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
syncChangeCounter
=
0
WHERE
id
=
OLD
.
localId
;
/
*
Bump
the
change
counter
for
items
with
the
old
URL
new
URL
and
new
keyword
.
*
/
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
fk
IN
(
SELECT
place_id
FROM
moz_keywords
WHERE
place_id
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
OR
keyword
=
OLD
.
newKeyword
)
;
/
*
Remove
the
new
keyword
from
existing
items
and
all
keywords
from
the
old
and
new
URLs
.
*
/
DELETE
FROM
moz_keywords
WHERE
place_id
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
OR
keyword
=
OLD
.
newKeyword
;
/
*
Remove
existing
tags
.
*
/
DELETE
FROM
localTags
WHERE
placeId
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
;
/
*
Update
the
URL
and
recalculate
frecency
.
It
'
s
important
we
do
this
*
after
*
removing
old
keywords
and
*
before
*
inserting
new
ones
so
that
the
above
statements
select
the
correct
affected
items
.
*
/
UPDATE
moz_bookmarks
SET
fk
=
OLD
.
newPlaceId
WHERE
OLD
.
oldPlaceId
<
>
OLD
.
newPlaceId
AND
id
=
OLD
.
localId
;
UPDATE
moz_places
SET
frecency
=
-
1
WHERE
OLD
.
oldPlaceId
<
>
OLD
.
newPlaceId
AND
id
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
;
/
*
Insert
a
new
keyword
for
the
new
URL
if
one
is
set
.
*
/
INSERT
OR
IGNORE
INTO
moz_keywords
(
keyword
place_id
post_data
)
SELECT
OLD
.
newKeyword
OLD
.
newPlaceId
'
'
WHERE
OLD
.
newKeyword
NOT
NULL
;
/
*
Insert
new
tags
for
the
new
URL
.
*
/
INSERT
INTO
localTags
(
tag
placeId
)
SELECT
t
.
tag
OLD
.
newPlaceId
FROM
tags
t
WHERE
t
.
itemId
=
OLD
.
remoteId
;
/
*
Record
anno
removed
notifications
for
the
synced
annos
.
*
/
REPLACE
INTO
annosChanged
(
itemId
annoName
wasRemoved
)
SELECT
a
.
item_id
n
.
name
1
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
item_id
=
OLD
.
localId
AND
anno_attribute_id
IN
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
IN
(
{
syncedAnnoTriggers
.
map
(
annoTrigger
=
>
'
{
annoTrigger
.
annoName
}
'
)
.
join
(
"
"
)
}
)
)
;
/
*
Remove
existing
synced
annos
.
*
/
DELETE
FROM
moz_items_annos
WHERE
item_id
=
OLD
.
localId
AND
anno_attribute_id
IN
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
IN
(
{
syncedAnnoTriggers
.
map
(
annoTrigger
=
>
'
{
annoTrigger
.
annoName
}
'
)
.
join
(
"
"
)
}
)
)
;
/
*
Insert
new
synced
annos
.
*
/
INSERT
OR
IGNORE
INTO
moz_anno_attributes
(
name
)
VALUES
{
syncedAnnoTriggers
.
map
(
annoTrigger
=
>
(
'
{
annoTrigger
.
annoName
}
'
)
)
.
join
(
"
"
)
}
;
{
syncedAnnoTriggers
.
map
(
annoTrigger
=
>
INSERT
INTO
moz_items_annos
(
item_id
anno_attribute_id
content
flags
expiration
type
lastModified
dateAdded
)
SELECT
OLD
.
localId
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
'
{
annoTrigger
.
annoName
}
'
)
OLD
.
{
annoTrigger
.
columnName
}
0
{
PlacesUtils
.
annotations
.
EXPIRE_NEVER
}
{
annoTrigger
.
type
}
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
WHERE
OLD
.
{
annoTrigger
.
columnName
}
NOT
NULL
;
/
*
Record
an
anno
set
notification
for
the
new
synced
anno
.
*
/
REPLACE
INTO
annosChanged
(
itemId
annoName
wasRemoved
)
SELECT
OLD
.
localId
'
{
annoTrigger
.
annoName
}
'
0
WHERE
OLD
.
{
annoTrigger
.
columnName
}
NOT
NULL
;
)
.
join
(
"
"
)
}
END
)
;
await
db
.
execute
(
CREATE
TEMP
VIEW
structureToMerge
(
localId
hasNewStructure
isRoot
oldParentId
newParentId
oldPosition
newPosition
newLevel
)
AS
SELECT
b
.
id
r
.
structureState
=
{
BookmarkMergeState
.
TYPE
.
NEW
}
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
IN
(
r
.
mergedGuid
r
.
parentGuid
)
b
.
parent
p
.
id
b
.
position
r
.
position
r
.
level
FROM
moz_bookmarks
b
JOIN
mergeStates
r
ON
r
.
mergedGuid
=
b
.
guid
JOIN
moz_bookmarks
p
ON
p
.
guid
=
r
.
parentGuid
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
updateLocalStructure
INSTEAD
OF
DELETE
ON
structureToMerge
WHEN
NOT
OLD
.
isRoot
BEGIN
UPDATE
moz_bookmarks
SET
parent
=
OLD
.
newParentId
WHERE
id
=
OLD
.
localId
AND
parent
<
>
OLD
.
newParentId
;
UPDATE
moz_bookmarks
SET
position
=
OLD
.
newPosition
WHERE
id
=
OLD
.
localId
AND
position
<
>
OLD
.
newPosition
;
/
*
Record
observer
notifications
for
moved
items
.
We
ignore
items
that
didn
'
t
move
and
items
with
placeholder
parents
and
positions
of
"
-
1
"
since
they
'
re
new
.
*
/
INSERT
INTO
itemsMoved
(
itemId
oldParentId
oldParentGuid
oldPosition
level
)
SELECT
OLD
.
localId
OLD
.
oldParentId
p
.
guid
OLD
.
oldPosition
OLD
.
newLevel
FROM
moz_bookmarks
p
WHERE
p
.
id
=
OLD
.
oldParentId
AND
-
1
NOT
IN
(
OLD
.
oldParentId
OLD
.
oldPosition
)
AND
(
OLD
.
oldParentId
<
>
OLD
.
newParentId
OR
OLD
.
oldPosition
<
>
OLD
.
newPosition
)
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
flagNewStructure
INSTEAD
OF
DELETE
ON
structureToMerge
WHEN
OLD
.
hasNewStructure
BEGIN
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
id
=
OLD
.
localId
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
VIEW
localTags
(
tagEntryId
tagEntryGuid
tagFolderId
tagFolderGuid
tagEntryPosition
tagEntryType
tag
placeId
)
AS
SELECT
b
.
id
b
.
guid
p
.
id
p
.
guid
b
.
position
b
.
type
p
.
title
b
.
fk
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
moz_bookmarks
r
ON
r
.
id
=
p
.
parent
WHERE
b
.
type
=
{
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
}
AND
r
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
untagLocalPlace
INSTEAD
OF
DELETE
ON
localTags
BEGIN
/
*
Record
an
item
removed
notification
for
the
tag
entry
.
*
/
INSERT
INTO
itemsRemoved
(
itemId
parentId
position
type
placeId
guid
parentGuid
isUntagging
)
VALUES
(
OLD
.
tagEntryId
OLD
.
tagFolderId
OLD
.
tagEntryPosition
OLD
.
tagEntryType
OLD
.
placeId
OLD
.
tagEntryGuid
OLD
.
tagFolderGuid
1
)
;
DELETE
FROM
moz_bookmarks
WHERE
id
=
OLD
.
tagEntryId
;
/
*
Fix
the
positions
of
the
sibling
tag
entries
.
*
/
UPDATE
moz_bookmarks
SET
position
=
position
-
1
WHERE
parent
=
OLD
.
tagFolderId
AND
position
>
OLD
.
tagEntryPosition
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
tagLocalPlace
INSTEAD
OF
INSERT
ON
localTags
BEGIN
/
*
Ensure
the
tag
folder
exists
.
*
/
INSERT
OR
IGNORE
INTO
moz_bookmarks
(
guid
parent
position
type
title
dateAdded
lastModified
)
VALUES
(
IFNULL
(
(
SELECT
b
.
guid
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
title
=
NEW
.
tag
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
GENERATE_GUID
(
)
)
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
(
SELECT
COUNT
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
{
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
NEW
.
tag
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
)
;
/
*
Record
an
item
added
notification
if
we
created
a
tag
folder
.
"
CHANGES
(
)
"
returns
the
number
of
rows
affected
by
the
INSERT
above
:
1
if
we
created
the
folder
or
0
if
the
folder
already
existed
.
*
/
INSERT
INTO
itemsAdded
(
guid
isTagging
)
SELECT
b
.
guid
1
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
CHANGES
(
)
>
0
AND
b
.
title
=
NEW
.
tag
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
;
/
*
Add
a
tag
entry
for
the
URL
under
the
tag
folder
.
Omitting
the
place
ID
creates
a
tag
folder
without
tagging
the
URL
.
*
/
INSERT
OR
IGNORE
INTO
moz_bookmarks
(
guid
parent
position
type
fk
dateAdded
lastModified
)
SELECT
GENERATE_GUID
(
)
(
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
AND
b
.
title
=
NEW
.
tag
)
(
SELECT
COUNT
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
moz_bookmarks
r
ON
r
.
id
=
p
.
parent
WHERE
p
.
title
=
NEW
.
tag
AND
r
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
{
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
}
NEW
.
placeId
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
WHERE
NEW
.
placeId
NOT
NULL
;
/
*
Record
an
item
added
notification
for
the
tag
entry
.
*
/
INSERT
INTO
itemsAdded
(
guid
isTagging
)
SELECT
b
.
guid
1
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
moz_bookmarks
r
ON
r
.
id
=
p
.
parent
WHERE
b
.
fk
=
NEW
.
placeId
AND
p
.
title
=
NEW
.
tag
AND
r
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsAdded
(
guid
TEXT
PRIMARY
KEY
isTagging
BOOLEAN
NOT
NULL
DEFAULT
0
keywordChanged
BOOLEAN
NOT
NULL
DEFAULT
0
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
guidsChanged
(
itemId
INTEGER
NOT
NULL
oldGuid
TEXT
NOT
NULL
level
INTEGER
NOT
NULL
DEFAULT
-
1
PRIMARY
KEY
(
itemId
oldGuid
)
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsChanged
(
itemId
INTEGER
PRIMARY
KEY
oldTitle
TEXT
oldPlaceId
INTEGER
keywordChanged
BOOLEAN
NOT
NULL
DEFAULT
0
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsMoved
(
itemId
INTEGER
PRIMARY
KEY
oldParentId
INTEGER
NOT
NULL
oldParentGuid
TEXT
NOT
NULL
oldPosition
INTEGER
NOT
NULL
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsRemoved
(
guid
TEXT
PRIMARY
KEY
itemId
INTEGER
NOT
NULL
parentId
INTEGER
NOT
NULL
position
INTEGER
NOT
NULL
type
INTEGER
NOT
NULL
placeId
INTEGER
parentGuid
TEXT
NOT
NULL
/
*
We
record
the
original
level
of
the
removed
item
in
the
tree
so
that
we
can
notify
children
before
parents
.
*
/
level
INTEGER
NOT
NULL
DEFAULT
-
1
isUntagging
BOOLEAN
NOT
NULL
DEFAULT
0
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
annosChanged
(
itemId
INTEGER
NOT
NULL
annoName
TEXT
NOT
NULL
wasRemoved
BOOLEAN
NOT
NULL
PRIMARY
KEY
(
itemId
annoName
wasRemoved
)
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsToWeaklyReupload
(
id
INTEGER
PRIMARY
KEY
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsToUpload
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
UNIQUE
NOT
NULL
syncChangeCounter
INTEGER
NOT
NULL
isDeleted
BOOLEAN
NOT
NULL
DEFAULT
0
parentGuid
TEXT
parentTitle
TEXT
dateAdded
INTEGER
type
INTEGER
title
TEXT
isQuery
BOOLEAN
NOT
NULL
DEFAULT
0
url
TEXT
tags
TEXT
description
TEXT
loadInSidebar
BOOLEAN
smartBookmarkName
TEXT
tagFolderName
TEXT
keyword
TEXT
feedURL
TEXT
siteURL
TEXT
position
INTEGER
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
structureToUpload
(
guid
TEXT
PRIMARY
KEY
parentId
INTEGER
NOT
NULL
REFERENCES
itemsToUpload
(
id
)
ON
DELETE
CASCADE
position
INTEGER
NOT
NULL
)
WITHOUT
ROWID
)
;
}
function
validateGuid
(
recordId
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
recordId
)
;
return
PlacesUtils
.
isValidGuid
(
guid
)
?
guid
:
null
;
}
function
determineServerModified
(
record
)
{
return
Math
.
max
(
record
.
modified
*
1000
0
)
|
|
0
;
}
function
determineDateAdded
(
record
)
{
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
PlacesSyncUtils
.
bookmarks
.
ratchetTimestampBackwards
(
record
.
dateAdded
serverModified
)
;
return
dateAdded
?
PlacesUtils
.
toPRTime
(
new
Date
(
dateAdded
)
)
:
0
;
}
function
validateTitle
(
rawTitle
)
{
if
(
typeof
rawTitle
!
=
"
string
"
|
|
!
rawTitle
)
{
return
null
;
}
return
rawTitle
.
slice
(
0
DB_TITLE_LENGTH_MAX
)
;
}
function
validateURL
(
rawURL
)
{
if
(
typeof
rawURL
!
=
"
string
"
|
|
rawURL
.
length
>
DB_URL_LENGTH_MAX
)
{
return
null
;
}
let
url
=
null
;
try
{
url
=
new
URL
(
rawURL
)
;
}
catch
(
ex
)
{
}
return
url
;
}
function
validateDescription
(
rawDescription
)
{
if
(
typeof
rawDescription
!
=
"
string
"
|
|
!
rawDescription
)
{
return
null
;
}
return
rawDescription
.
slice
(
0
DB_DESCRIPTION_LENGTH_MAX
)
;
}
function
validateKeyword
(
rawKeyword
)
{
if
(
typeof
rawKeyword
!
=
"
string
"
)
{
return
null
;
}
let
keyword
=
rawKeyword
.
trim
(
)
;
return
keyword
?
keyword
.
toLowerCase
(
)
:
null
;
}
function
validateTag
(
rawTag
)
{
if
(
typeof
rawTag
!
=
"
string
"
)
{
return
null
;
}
let
tag
=
rawTag
.
trim
(
)
;
if
(
!
tag
|
|
tag
.
length
>
Ci
.
nsITaggingService
.
MAX_TAG_LENGTH
)
{
return
null
;
}
return
tag
;
}
async
function
inflateTree
(
tree
pseudoTree
parentGuid
)
{
let
nodes
=
pseudoTree
.
get
(
parentGuid
)
;
if
(
nodes
)
{
for
(
let
node
of
nodes
)
{
await
maybeYield
(
)
;
tree
.
insert
(
parentGuid
node
)
;
await
inflateTree
(
tree
pseudoTree
node
.
guid
)
;
}
}
}
class
BookmarkContent
{
constructor
(
title
urlHref
smartBookmarkName
position
)
{
this
.
title
=
title
;
this
.
url
=
urlHref
?
new
URL
(
urlHref
)
:
null
;
this
.
smartBookmarkName
=
smartBookmarkName
;
this
.
position
=
position
;
}
static
fromRow
(
row
)
{
let
title
=
row
.
getResultByName
(
"
title
"
)
;
let
urlHref
=
row
.
getResultByName
(
"
url
"
)
;
let
smartBookmarkName
=
row
.
getResultByName
(
"
smartBookmarkName
"
)
;
let
position
=
row
.
getResultByName
(
"
position
"
)
;
return
new
BookmarkContent
(
title
urlHref
smartBookmarkName
position
)
;
}
hasSameURL
(
otherContent
)
{
return
!
!
this
.
url
=
=
!
!
otherContent
.
url
&
&
this
.
url
.
href
=
=
otherContent
.
url
.
href
;
}
}
class
BookmarkMergeState
{
constructor
(
type
newStructureNode
=
null
)
{
this
.
type
=
type
;
this
.
newStructureNode
=
newStructureNode
;
}
static
new
(
oldState
newStructureNode
)
{
return
new
BookmarkMergeState
(
oldState
.
type
newStructureNode
)
;
}
structure
(
)
{
return
this
.
newStructureNode
?
BookmarkMergeState
.
TYPE
.
NEW
:
this
.
type
;
}
value
(
)
{
return
this
.
type
;
}
toString
(
)
{
return
(
{
this
.
valueToString
(
)
}
;
{
this
.
structureToString
(
)
}
)
;
}
valueToString
(
)
{
switch
(
this
.
value
(
)
)
{
case
BookmarkMergeState
.
TYPE
.
LOCAL
:
return
"
V
:
L
"
;
case
BookmarkMergeState
.
TYPE
.
REMOTE
:
return
"
V
:
R
"
;
}
return
"
V
:
?
"
;
}
structureToString
(
)
{
switch
(
this
.
structure
(
)
)
{
case
BookmarkMergeState
.
TYPE
.
LOCAL
:
return
"
S
:
L
"
;
case
BookmarkMergeState
.
TYPE
.
REMOTE
:
return
"
S
:
R
"
;
case
BookmarkMergeState
.
TYPE
.
NEW
:
return
"
S
:
+
"
;
}
return
"
S
:
?
"
;
}
toJSON
(
)
{
return
this
.
toString
(
)
;
}
}
BookmarkMergeState
.
TYPE
=
{
LOCAL
:
1
REMOTE
:
2
NEW
:
3
}
;
BookmarkMergeState
.
local
=
new
BookmarkMergeState
(
BookmarkMergeState
.
TYPE
.
LOCAL
)
;
BookmarkMergeState
.
remote
=
new
BookmarkMergeState
(
BookmarkMergeState
.
TYPE
.
REMOTE
)
;
class
BookmarkNode
{
constructor
(
guid
age
kind
needsMerge
=
false
)
{
this
.
guid
=
guid
;
this
.
kind
=
kind
;
this
.
age
=
age
;
this
.
needsMerge
=
needsMerge
;
this
.
children
=
[
]
;
}
static
root
(
)
{
let
guid
=
PlacesUtils
.
bookmarks
.
rootGuid
;
return
new
BookmarkNode
(
guid
0
SyncedBookmarksMirror
.
KIND
.
FOLDER
)
;
}
static
fromLocalRow
(
row
localTimeSeconds
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
localModified
=
row
.
getResultByName
(
"
lastModified
"
)
;
let
age
=
Math
.
max
(
localTimeSeconds
-
localModified
/
1000000
0
)
|
|
0
;
let
kind
=
row
.
getResultByName
(
"
kind
"
)
;
let
syncChangeCounter
=
row
.
getResultByName
(
"
syncChangeCounter
"
)
;
let
needsMerge
=
syncChangeCounter
>
0
;
return
new
BookmarkNode
(
guid
age
kind
needsMerge
)
;
}
static
fromRemoteRow
(
row
remoteTimeSeconds
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
serverModified
=
row
.
getResultByName
(
"
serverModified
"
)
;
let
age
=
Math
.
max
(
remoteTimeSeconds
-
serverModified
/
1000
0
)
|
|
0
;
let
kind
=
row
.
getResultByName
(
"
kind
"
)
;
let
needsMerge
=
!
!
row
.
getResultByName
(
"
needsMerge
"
)
;
return
new
BookmarkNode
(
guid
age
kind
needsMerge
)
;
}
isRoot
(
)
{
return
this
.
guid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
|
|
PlacesUtils
.
bookmarks
.
userContentRoots
.
includes
(
this
.
guid
)
;
}
isFolder
(
)
{
return
this
.
kind
=
=
SyncedBookmarksMirror
.
KIND
.
FOLDER
;
}
newerThan
(
otherNode
)
{
return
this
.
age
<
otherNode
.
age
;
}
*
descendants
(
)
{
for
(
let
node
of
this
.
children
)
{
yield
node
;
if
(
node
.
isFolder
(
)
)
{
yield
*
node
.
descendants
(
)
;
}
}
}
toASCIITreeString
(
prefix
=
"
"
)
{
if
(
!
this
.
isFolder
(
)
)
{
return
prefix
+
"
-
"
+
this
.
toString
(
)
;
}
return
prefix
+
"
+
"
+
this
.
toString
(
)
+
"
\
n
"
+
this
.
children
.
map
(
childNode
=
>
childNode
.
toASCIITreeString
(
{
prefix
}
|
)
)
.
join
(
"
\
n
"
)
;
}
toString
(
)
{
let
info
=
{
this
.
kindToString
(
)
}
;
{
this
.
age
.
toFixed
(
3
)
}
s
;
if
(
this
.
needsMerge
)
{
info
+
=
"
;
!
"
;
}
return
{
this
.
guid
}
(
{
info
}
)
;
}
kindToString
(
)
{
switch
(
this
.
kind
)
{
case
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
:
return
"
B
"
;
case
SyncedBookmarksMirror
.
KIND
.
QUERY
:
return
"
Q
"
;
case
SyncedBookmarksMirror
.
KIND
.
FOLDER
:
return
"
F
"
;
case
SyncedBookmarksMirror
.
KIND
.
LIVEMARK
:
return
"
L
"
;
case
SyncedBookmarksMirror
.
KIND
.
SEPARATOR
:
return
"
S
"
;
}
return
"
?
"
;
}
toJSON
(
)
{
return
this
.
toString
(
)
;
}
}
class
BookmarkTree
{
constructor
(
root
)
{
this
.
byGuid
=
new
Map
(
)
;
this
.
infosByNode
=
new
WeakMap
(
)
;
this
.
deletedGuids
=
new
Set
(
)
;
this
.
root
=
root
;
this
.
byGuid
.
set
(
this
.
root
.
guid
this
.
root
)
;
}
isDeleted
(
guid
)
{
return
this
.
deletedGuids
.
has
(
guid
)
;
}
nodeForGuid
(
guid
)
{
return
this
.
byGuid
.
get
(
guid
)
;
}
parentNodeFor
(
childNode
)
{
let
info
=
this
.
infosByNode
.
get
(
childNode
)
;
return
info
?
info
.
parentNode
:
null
;
}
levelForGuid
(
guid
)
{
let
node
=
this
.
byGuid
.
get
(
guid
)
;
if
(
!
node
)
{
return
-
1
;
}
let
info
=
this
.
infosByNode
.
get
(
node
)
;
return
info
?
info
.
level
:
-
1
;
}
insert
(
parentGuid
node
)
{
if
(
this
.
byGuid
.
has
(
node
.
guid
)
)
{
let
existingNode
=
this
.
byGuid
.
get
(
node
.
guid
)
;
MirrorLog
.
error
(
"
Can
'
t
replace
existing
node
{
existingNode
}
with
node
"
+
"
{
node
}
"
{
existingNode
node
}
)
;
throw
new
TypeError
(
"
Node
already
exists
in
tree
"
)
;
}
let
parentNode
=
this
.
byGuid
.
get
(
parentGuid
)
;
if
(
!
parentNode
)
{
MirrorLog
.
error
(
"
Missing
parent
{
parentGuid
}
for
node
{
node
}
"
{
parentGuid
node
}
)
;
throw
new
TypeError
(
"
Can
'
t
insert
node
into
nonexistent
parent
"
)
;
}
if
(
!
parentNode
.
isFolder
(
)
)
{
MirrorLog
.
error
(
"
Non
-
folder
parent
{
parentNode
}
for
node
{
node
}
"
{
parentNode
node
}
)
;
throw
new
TypeError
(
"
Can
'
t
insert
node
into
non
-
folder
"
)
;
}
parentNode
.
children
.
push
(
node
)
;
this
.
byGuid
.
set
(
node
.
guid
node
)
;
let
parentInfo
=
this
.
infosByNode
.
get
(
parentNode
)
;
let
level
=
parentInfo
?
parentInfo
.
level
+
1
:
0
;
this
.
infosByNode
.
set
(
node
{
parentNode
level
}
)
;
}
noteDeleted
(
guid
)
{
this
.
deletedGuids
.
add
(
guid
)
;
}
*
guids
(
)
{
for
(
let
[
guid
node
]
of
this
.
byGuid
)
{
if
(
node
=
=
this
.
root
)
{
continue
;
}
yield
guid
;
}
for
(
let
guid
of
this
.
deletedGuids
)
{
yield
guid
;
}
}
toASCIITreeString
(
)
{
return
this
.
root
.
toASCIITreeString
(
)
+
"
\
n
"
+
Array
.
from
(
this
.
deletedGuids
guid
=
>
~
{
guid
}
)
.
join
(
"
"
)
;
}
}
class
MergedBookmarkNode
{
constructor
(
guid
localNode
remoteNode
mergeState
)
{
this
.
guid
=
guid
;
this
.
localNode
=
localNode
;
this
.
remoteNode
=
remoteNode
;
this
.
mergeState
=
mergeState
;
this
.
mergedChildren
=
[
]
;
}
*
mergeStatesParams
(
level
=
0
)
{
for
(
let
position
=
0
;
position
<
this
.
mergedChildren
.
length
;
+
+
position
)
{
let
mergedChild
=
this
.
mergedChildren
[
position
]
;
let
mergeStateParam
=
{
localGuid
:
mergedChild
.
localNode
?
mergedChild
.
localNode
.
guid
:
null
mergedGuid
:
mergedChild
.
guid
parentGuid
:
this
.
guid
level
position
valueState
:
mergedChild
.
mergeState
.
value
(
)
structureState
:
mergedChild
.
mergeState
.
structure
(
)
}
;
yield
mergeStateParam
;
yield
*
mergedChild
.
mergeStatesParams
(
level
+
1
)
;
}
}
async
toBookmarkNode
(
)
{
if
(
MergedBookmarkNode
.
cachedBookmarkNodes
.
has
(
this
)
)
{
return
MergedBookmarkNode
.
cachedBookmarkNodes
.
get
(
this
)
;
}
let
decidedValueNode
=
this
.
decidedValue
(
)
;
let
decidedStructureState
=
this
.
mergeState
.
structure
(
)
;
let
needsMerge
=
decidedStructureState
=
=
BookmarkMergeState
.
TYPE
.
NEW
|
|
(
decidedStructureState
=
=
BookmarkMergeState
.
TYPE
.
LOCAL
&
&
decidedValueNode
.
needsMerge
)
;
let
newNode
=
new
BookmarkNode
(
this
.
guid
decidedValueNode
.
age
decidedValueNode
.
kind
needsMerge
)
;
MergedBookmarkNode
.
cachedBookmarkNodes
.
set
(
this
newNode
)
;
if
(
newNode
.
isFolder
(
)
)
{
for
await
(
let
mergedChildNode
of
yieldingIterator
(
this
.
mergedChildren
)
)
{
newNode
.
children
.
push
(
await
mergedChildNode
.
toBookmarkNode
(
)
)
;
}
}
return
newNode
;
}
decidedValue
(
)
{
let
valueState
=
this
.
mergeState
.
value
(
)
;
switch
(
valueState
)
{
case
BookmarkMergeState
.
TYPE
.
LOCAL
:
if
(
!
this
.
localNode
)
{
MirrorLog
.
error
(
"
Merged
node
{
guid
}
has
local
value
state
but
"
+
"
no
local
node
"
this
)
;
throw
new
TypeError
(
"
Can
'
t
take
local
value
state
without
local
node
"
)
;
}
return
this
.
localNode
;
case
BookmarkMergeState
.
TYPE
.
REMOTE
:
if
(
!
this
.
remoteNode
)
{
MirrorLog
.
error
(
"
Merged
node
{
guid
}
has
remote
value
state
but
"
+
"
no
remote
node
"
this
)
;
throw
new
TypeError
(
"
Can
'
t
take
remote
value
state
without
remote
node
"
)
;
}
return
this
.
remoteNode
;
}
MirrorLog
.
error
(
"
Merged
node
{
guid
}
has
unknown
value
state
{
valueState
}
"
{
guid
:
this
.
guid
valueState
}
)
;
throw
new
TypeError
(
"
Can
'
t
take
unknown
value
state
"
)
;
}
toASCIITreeString
(
prefix
=
"
"
)
{
if
(
!
this
.
mergedChildren
.
length
)
{
return
prefix
+
"
-
"
+
this
.
toString
(
)
;
}
return
prefix
+
"
+
"
+
this
.
toString
(
)
+
"
\
n
"
+
this
.
mergedChildren
.
map
(
mergedChildNode
=
>
mergedChildNode
.
toASCIITreeString
(
{
prefix
}
|
)
)
.
join
(
"
\
n
"
)
;
}
toString
(
)
{
return
{
this
.
guid
}
{
this
.
mergeState
.
toString
(
)
}
;
}
toJSON
(
)
{
return
this
.
toString
(
)
;
}
}
MergedBookmarkNode
.
cachedBookmarkNodes
=
new
WeakMap
(
)
;
class
BookmarkMerger
{
constructor
(
localTree
newLocalContents
remoteTree
newRemoteContents
)
{
this
.
localTree
=
localTree
;
this
.
newLocalContents
=
newLocalContents
;
this
.
remoteTree
=
remoteTree
;
this
.
newRemoteContents
=
newRemoteContents
;
this
.
mergedGuids
=
new
Set
(
)
;
this
.
deleteLocally
=
new
Set
(
)
;
this
.
deleteRemotely
=
new
Set
(
)
;
this
.
telemetryEvents
=
[
]
;
}
async
merge
(
)
{
let
localRoot
=
this
.
localTree
.
nodeForGuid
(
PlacesUtils
.
bookmarks
.
rootGuid
)
;
let
remoteRoot
=
this
.
remoteTree
.
nodeForGuid
(
PlacesUtils
.
bookmarks
.
rootGuid
)
;
let
mergedRoot
=
await
this
.
mergeNode
(
PlacesUtils
.
bookmarks
.
rootGuid
localRoot
remoteRoot
)
;
for
await
(
let
guid
of
yieldingIterator
(
this
.
localTree
.
deletedGuids
)
)
{
if
(
!
this
.
mentions
(
guid
)
)
{
this
.
deleteRemotely
.
add
(
guid
)
;
}
}
for
await
(
let
guid
of
yieldingIterator
(
this
.
remoteTree
.
deletedGuids
)
)
{
if
(
!
this
.
mentions
(
guid
)
)
{
this
.
deleteLocally
.
add
(
guid
)
;
}
}
return
mergedRoot
;
}
async
subsumes
(
tree
)
{
for
await
(
let
guid
of
Async
.
yieldingIterator
(
tree
.
guids
(
)
)
)
{
if
(
!
this
.
mentions
(
guid
)
)
{
return
false
;
}
}
return
true
;
}
mentions
(
guid
)
{
return
this
.
mergedGuids
.
has
(
guid
)
|
|
this
.
deleteLocally
.
has
(
guid
)
|
|
this
.
deleteRemotely
.
has
(
guid
)
;
}
async
mergeNode
(
mergedGuid
localNode
remoteNode
)
{
await
maybeYield
(
)
;
this
.
mergedGuids
.
add
(
mergedGuid
)
;
if
(
localNode
)
{
if
(
localNode
.
guid
!
=
mergedGuid
)
{
this
.
mergedGuids
.
add
(
localNode
.
guid
)
;
}
if
(
remoteNode
)
{
MirrorLog
.
trace
(
"
Item
{
mergedGuid
}
exists
locally
as
{
localNode
}
"
+
"
and
remotely
as
{
remoteNode
}
;
merging
"
{
mergedGuid
localNode
remoteNode
}
)
;
let
mergedNode
=
await
this
.
twoWayMerge
(
mergedGuid
localNode
remoteNode
)
;
return
mergedNode
;
}
MirrorLog
.
trace
(
"
Item
{
mergedGuid
}
only
exists
locally
as
"
+
"
{
localNode
}
;
taking
local
state
"
{
mergedGuid
localNode
}
)
;
let
mergedNode
=
new
MergedBookmarkNode
(
mergedGuid
localNode
null
BookmarkMergeState
.
local
)
;
if
(
localNode
.
isFolder
(
)
)
{
await
this
.
mergeChildListsIntoMergedNode
(
mergedNode
localNode
null
)
;
}
return
mergedNode
;
}
if
(
remoteNode
)
{
MirrorLog
.
trace
(
"
Item
{
mergedGuid
}
only
exists
remotely
as
"
+
"
{
remoteNode
}
;
taking
remote
state
"
{
mergedGuid
remoteNode
}
)
;
let
mergedNode
=
new
MergedBookmarkNode
(
mergedGuid
null
remoteNode
BookmarkMergeState
.
remote
)
;
if
(
remoteNode
.
isFolder
(
)
)
{
await
this
.
mergeChildListsIntoMergedNode
(
mergedNode
null
remoteNode
)
;
}
return
mergedNode
;
}
throw
new
TypeError
(
"
Can
'
t
merge
two
nonexistent
nodes
"
)
;
}
async
twoWayMerge
(
mergedGuid
localNode
remoteNode
)
{
let
mergeState
=
this
.
resolveTwoWayValueConflict
(
mergedGuid
localNode
remoteNode
)
;
MirrorLog
.
trace
(
"
Merge
state
for
{
mergedGuid
}
is
{
mergeState
}
"
{
mergedGuid
mergeState
}
)
;
let
mergedNode
=
new
MergedBookmarkNode
(
mergedGuid
localNode
remoteNode
mergeState
)
;
if
(
localNode
.
isFolder
(
)
)
{
if
(
remoteNode
.
isFolder
(
)
)
{
MirrorLog
.
trace
(
"
Merging
folders
{
localNode
}
and
{
remoteNode
}
"
{
localNode
remoteNode
}
)
;
await
this
.
mergeChildListsIntoMergedNode
(
mergedNode
localNode
remoteNode
)
;
return
mergedNode
;
}
if
(
remoteNode
.
kind
=
=
SyncedBookmarksMirror
.
KIND
.
LIVEMARK
)
{
MirrorLog
.
trace
(
"
Merging
local
folder
{
localNode
}
and
remote
"
+
"
livemark
{
remoteNode
}
"
{
localNode
remoteNode
}
)
;
this
.
telemetryEvents
.
push
(
{
value
:
"
kind
"
extra
:
{
local
:
"
folder
"
remote
:
"
folder
"
}
}
)
;
return
mergedNode
;
}
MirrorLog
.
error
(
"
Merging
local
folder
{
localNode
}
and
remote
"
+
"
non
-
folder
{
remoteNode
}
"
{
localNode
remoteNode
}
)
;
throw
new
SyncedBookmarksMirror
.
ConsistencyError
(
"
Can
'
t
merge
folder
and
non
-
folder
"
)
;
}
if
(
localNode
.
kind
=
=
remoteNode
.
kind
)
{
MirrorLog
.
trace
(
"
Merging
non
-
folders
{
localNode
}
and
{
remoteNode
}
"
{
localNode
remoteNode
}
)
;
return
mergedNode
;
}
MirrorLog
.
error
(
"
Merging
local
{
localNode
}
and
remote
{
remoteNode
}
"
+
"
with
different
kinds
"
{
localNode
remoteNode
}
)
;
throw
new
SyncedBookmarksMirror
.
ConsistencyError
(
"
Can
'
t
merge
different
item
kinds
"
)
;
}
resolveTwoWayValueConflict
(
mergedGuid
localNode
remoteNode
)
{
if
(
PlacesUtils
.
bookmarks
.
userContentRoots
.
includes
(
mergedGuid
)
)
{
return
BookmarkMergeState
.
local
;
}
if
(
!
remoteNode
.
needsMerge
)
{
return
BookmarkMergeState
.
local
;
}
if
(
!
localNode
.
needsMerge
)
{
return
BookmarkMergeState
.
remote
;
}
let
valueState
=
localNode
.
newerThan
(
remoteNode
)
?
BookmarkMergeState
.
local
:
BookmarkMergeState
.
remote
;
return
valueState
;
}
async
mergeRemoteChildIntoMergedNode
(
mergedNode
remoteParentNode
remoteChildNode
)
{
if
(
this
.
mergedGuids
.
has
(
remoteChildNode
.
guid
)
)
{
MirrorLog
.
trace
(
"
Remote
child
{
remoteChildNode
}
already
seen
in
"
+
"
another
folder
and
merged
"
{
remoteChildNode
}
)
;
return
false
;
}
MirrorLog
.
trace
(
"
Merging
remote
child
{
remoteChildNode
}
of
"
+
"
{
remoteParentNode
}
into
{
mergedNode
}
"
{
remoteChildNode
remoteParentNode
mergedNode
}
)
;
let
structureChange
=
await
this
.
checkForLocalStructureChangeOfRemoteNode
(
mergedNode
remoteParentNode
remoteChildNode
)
;
if
(
structureChange
=
=
BookmarkMerger
.
STRUCTURE
.
DELETED
)
{
return
true
;
}
let
localChildNode
=
this
.
localTree
.
nodeForGuid
(
remoteChildNode
.
guid
)
;
if
(
!
localChildNode
)
{
MirrorLog
.
trace
(
"
Remote
child
{
remoteChildNode
}
doesn
'
t
exist
"
+
"
locally
;
looking
for
content
match
"
{
remoteChildNode
}
)
;
let
localChildNodeByContent
=
await
this
.
findLocalNodeMatchingRemoteNode
(
mergedNode
remoteChildNode
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
remoteChildNode
.
guid
localChildNodeByContent
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
false
;
}
let
localParentNode
=
this
.
localTree
.
parentNodeFor
(
localChildNode
)
;
if
(
!
localParentNode
)
{
MirrorLog
.
error
(
"
Remote
child
{
remoteChildNode
}
exists
locally
as
"
+
"
{
localChildNode
}
without
local
parent
"
{
remoteChildNode
localChildNode
}
)
;
throw
new
SyncedBookmarksMirror
.
ConsistencyError
(
"
Local
child
node
is
orphan
"
)
;
}
MirrorLog
.
trace
(
"
Remote
child
{
remoteChildNode
}
exists
locally
in
"
+
"
{
localParentNode
}
and
remotely
in
{
remoteParentNode
}
"
{
remoteChildNode
localParentNode
remoteParentNode
}
)
;
if
(
this
.
remoteTree
.
isDeleted
(
localParentNode
.
guid
)
)
{
MirrorLog
.
trace
(
"
Unconditionally
taking
remote
move
for
"
+
"
{
remoteChildNode
}
to
{
remoteParentNode
}
because
"
+
"
local
parent
{
localParentNode
}
is
deleted
remotely
"
{
remoteChildNode
remoteParentNode
localParentNode
}
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
localChildNode
.
guid
localChildNode
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
false
;
}
if
(
localParentNode
.
needsMerge
)
{
if
(
remoteParentNode
.
needsMerge
)
{
MirrorLog
.
trace
(
"
Local
{
localParentNode
}
and
remote
"
+
"
{
remoteParentNode
}
parents
changed
;
comparing
"
+
"
modified
times
to
decide
parent
for
remote
child
"
+
"
{
remoteChildNode
}
"
{
localParentNode
remoteParentNode
remoteChildNode
}
)
;
let
latestLocalAge
=
Math
.
min
(
localChildNode
.
age
localParentNode
.
age
)
;
let
latestRemoteAge
=
Math
.
min
(
remoteChildNode
.
age
remoteParentNode
.
age
)
;
if
(
latestLocalAge
<
latestRemoteAge
)
{
MirrorLog
.
trace
(
"
Ignoring
older
remote
move
for
{
remoteChildNode
}
"
+
"
to
{
remoteParentNode
}
at
{
latestRemoteAge
}
;
"
+
"
local
move
to
{
localParentNode
}
at
"
+
"
{
latestLocalAge
}
is
newer
"
{
remoteChildNode
remoteParentNode
latestRemoteAge
localParentNode
latestLocalAge
}
)
;
return
true
;
}
MirrorLog
.
trace
(
"
Taking
newer
remote
move
for
{
remoteChildNode
}
to
"
+
"
{
remoteParentNode
}
at
{
latestRemoteAge
}
;
local
"
+
"
move
to
{
localParentNode
}
at
{
latestLocalAge
}
is
"
+
"
older
"
{
remoteChildNode
remoteParentNode
latestRemoteAge
localParentNode
latestLocalAge
}
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
remoteChildNode
.
guid
localChildNode
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
false
;
}
MirrorLog
.
trace
(
"
Remote
parent
unchanged
;
keeping
remote
child
"
+
"
{
remoteChildNode
}
in
{
localParentNode
}
"
{
remoteChildNode
localParentNode
}
)
;
return
true
;
}
MirrorLog
.
trace
(
"
Local
parent
unchanged
;
keeping
remote
child
"
+
"
{
remoteChildNode
}
in
{
remoteParentNode
}
"
{
remoteChildNode
remoteParentNode
}
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
remoteChildNode
.
guid
localChildNode
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
false
;
}
async
mergeLocalChildIntoMergedNode
(
mergedNode
localParentNode
localChildNode
)
{
if
(
this
.
mergedGuids
.
has
(
localChildNode
.
guid
)
)
{
MirrorLog
.
trace
(
"
Local
child
{
localChildNode
}
already
seen
in
"
+
"
another
folder
and
merged
"
{
localChildNode
}
)
;
return
false
;
}
MirrorLog
.
trace
(
"
Merging
local
child
{
localChildNode
}
of
"
+
"
{
localParentNode
}
into
{
mergedNode
}
"
{
localChildNode
localParentNode
mergedNode
}
)
;
let
structureChange
=
await
this
.
checkForRemoteStructureChangeOfLocalNode
(
mergedNode
localParentNode
localChildNode
)
;
if
(
structureChange
=
=
BookmarkMerger
.
STRUCTURE
.
DELETED
)
{
return
true
;
}
let
remoteChildNode
=
this
.
remoteTree
.
nodeForGuid
(
localChildNode
.
guid
)
;
if
(
!
remoteChildNode
)
{
let
mergedChildNode
=
await
this
.
mergeNode
(
localChildNode
.
guid
localChildNode
null
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
true
;
}
let
remoteParentNode
=
this
.
remoteTree
.
parentNodeFor
(
remoteChildNode
)
;
if
(
!
remoteParentNode
)
{
MirrorLog
.
error
(
"
Local
child
{
localChildNode
}
exists
remotely
as
"
+
"
{
remoteChildNode
}
without
remote
parent
"
{
localChildNode
remoteChildNode
}
)
;
throw
new
SyncedBookmarksMirror
.
ConsistencyError
(
"
Remote
child
node
is
orphan
"
)
;
}
MirrorLog
.
trace
(
"
Local
child
{
localChildNode
}
exists
locally
in
"
+
"
{
localParentNode
}
and
remotely
in
{
remoteParentNode
}
"
{
localChildNode
localParentNode
remoteParentNode
}
)
;
if
(
this
.
localTree
.
isDeleted
(
remoteParentNode
.
guid
)
)
{
MirrorLog
.
trace
(
"
Unconditionally
taking
local
move
for
"
+
"
{
localChildNode
}
to
{
localParentNode
}
because
"
+
"
remote
parent
{
remoteParentNode
}
is
deleted
locally
"
{
localChildNode
localParentNode
remoteParentNode
}
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
localChildNode
.
guid
localChildNode
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
true
;
}
if
(
localParentNode
.
needsMerge
)
{
if
(
remoteParentNode
.
needsMerge
)
{
MirrorLog
.
trace
(
"
Local
{
localParentNode
}
and
remote
"
+
"
{
remoteParentNode
}
parents
changed
;
comparing
"
+
"
modified
times
to
decide
parent
for
local
child
"
+
"
{
localChildNode
}
"
{
localParentNode
remoteParentNode
localChildNode
}
)
;
let
latestLocalAge
=
Math
.
min
(
localChildNode
.
age
localParentNode
.
age
)
;
let
latestRemoteAge
=
Math
.
min
(
remoteChildNode
.
age
remoteParentNode
.
age
)
;
if
(
latestRemoteAge
<
=
latestLocalAge
)
{
MirrorLog
.
trace
(
"
Ignoring
older
local
move
for
{
localChildNode
}
"
+
"
to
{
localParentNode
}
at
{
latestLocalAge
}
;
"
+
"
remote
move
to
{
remoteParentNode
}
at
"
+
"
{
latestRemoteAge
}
is
newer
"
{
localChildNode
localParentNode
latestLocalAge
remoteParentNode
latestRemoteAge
}
)
;
return
false
;
}
MirrorLog
.
trace
(
"
Taking
newer
local
move
for
{
localChildNode
}
to
"
+
"
{
localParentNode
}
at
{
latestLocalAge
}
;
remote
"
+
"
move
to
{
remoteParentNode
}
at
{
latestRemoteAge
}
"
+
"
is
older
"
{
localChildNode
localParentNode
latestLocalAge
remoteParentNode
latestRemoteAge
}
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
localChildNode
.
guid
localChildNode
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
true
;
}
MirrorLog
.
trace
(
"
Remote
parent
unchanged
;
keeping
local
child
"
+
"
{
localChildNode
}
in
local
parent
{
localParentNode
}
"
{
localChildNode
localParentNode
}
)
;
let
mergedChildNode
=
await
this
.
mergeNode
(
localChildNode
.
guid
localChildNode
remoteChildNode
)
;
mergedNode
.
mergedChildren
.
push
(
mergedChildNode
)
;
return
true
;
}
MirrorLog
.
trace
(
"
Local
parent
unchanged
;
keeping
local
child
"
+
"
{
localChildNode
}
in
remote
parent
{
remoteParentNode
}
"
{
localChildNode
remoteParentNode
}
)
;
return
false
;
}
async
mergeChildListsIntoMergedNode
(
mergedNode
localNode
remoteNode
)
{
let
mergeStateChanged
=
false
;
if
(
localNode
&
&
remoteNode
)
{
if
(
localNode
.
newerThan
(
remoteNode
)
)
{
if
(
await
this
.
mergeLocalChildrenIntoMergedNode
(
mergedNode
localNode
)
)
{
mergeStateChanged
=
true
;
}
if
(
await
this
.
mergeRemoteChildrenIntoMergedNode
(
mergedNode
remoteNode
)
)
{
mergeStateChanged
=
true
;
}
}
else
{
if
(
await
this
.
mergeRemoteChildrenIntoMergedNode
(
mergedNode
remoteNode
)
)
{
mergeStateChanged
=
true
;
}
if
(
await
this
.
mergeLocalChildrenIntoMergedNode
(
mergedNode
localNode
)
)
{
mergeStateChanged
=
true
;
}
}
}
else
if
(
localNode
)
{
if
(
await
this
.
mergeLocalChildrenIntoMergedNode
(
mergedNode
localNode
)
)
{
mergeStateChanged
=
true
;
}
}
else
if
(
remoteNode
)
{
if
(
await
this
.
mergeRemoteChildrenIntoMergedNode
(
mergedNode
remoteNode
)
)
{
mergeStateChanged
=
true
;
}
}
else
{
throw
new
TypeError
(
"
Can
'
t
merge
children
for
two
nonexistent
nodes
"
)
;
}
if
(
mergeStateChanged
)
{
let
newStructureNode
=
await
mergedNode
.
toBookmarkNode
(
)
;
let
newMergeState
=
BookmarkMergeState
.
new
(
mergedNode
.
mergeState
newStructureNode
)
;
MirrorLog
.
trace
(
"
Merge
state
for
{
mergedNode
}
has
new
structure
"
+
"
{
newMergeState
}
"
{
mergedNode
newMergeState
}
)
;
this
.
telemetryEvents
.
push
(
{
value
:
"
structure
"
extra
:
{
type
:
"
new
"
}
}
)
;
mergedNode
.
mergeState
=
newMergeState
;
}
}
async
mergeRemoteChildrenIntoMergedNode
(
mergedNode
remoteNode
)
{
MirrorLog
.
trace
(
"
Merging
remote
children
of
{
remoteNode
}
into
"
+
"
{
mergedNode
}
"
{
remoteNode
mergedNode
}
)
;
let
mergeStateChanged
=
false
;
for
await
(
let
remoteChildNode
of
yieldingIterator
(
remoteNode
.
children
)
)
{
let
remoteChildrenChanged
=
await
this
.
mergeRemoteChildIntoMergedNode
(
mergedNode
remoteNode
remoteChildNode
)
;
if
(
remoteChildrenChanged
)
{
mergeStateChanged
=
true
;
}
}
return
mergeStateChanged
;
}
async
mergeLocalChildrenIntoMergedNode
(
mergedNode
localNode
)
{
MirrorLog
.
trace
(
"
Merging
local
children
of
{
localNode
}
into
"
+
"
{
mergedNode
}
"
{
localNode
mergedNode
}
)
;
let
mergeStateChanged
=
false
;
for
await
(
let
localChildNode
of
yieldingIterator
(
localNode
.
children
)
)
{
let
remoteChildrenChanged
=
await
this
.
mergeLocalChildIntoMergedNode
(
mergedNode
localNode
localChildNode
)
;
if
(
remoteChildrenChanged
)
{
mergeStateChanged
=
true
;
}
}
return
mergeStateChanged
;
}
async
checkForLocalStructureChangeOfRemoteNode
(
mergedNode
remoteParentNode
remoteNode
)
{
if
(
!
this
.
localTree
.
isDeleted
(
remoteNode
.
guid
)
)
{
let
localNode
=
this
.
localTree
.
nodeForGuid
(
remoteNode
.
guid
)
;
if
(
!
localNode
)
{
return
BookmarkMerger
.
STRUCTURE
.
UNCHANGED
;
}
let
localParentNode
=
this
.
localTree
.
parentNodeFor
(
localNode
)
;
if
(
!
localParentNode
)
{
throw
new
SyncedBookmarksMirror
.
ConsistencyError
(
"
Can
'
t
check
for
structure
changes
of
local
orphan
"
)
;
}
if
(
localParentNode
.
guid
!
=
remoteParentNode
.
guid
)
{
return
BookmarkMerger
.
STRUCTURE
.
MOVED
;
}
return
BookmarkMerger
.
STRUCTURE
.
UNCHANGED
;
}
if
(
remoteNode
.
needsMerge
)
{
if
(
!
remoteNode
.
isFolder
(
)
)
{
MirrorLog
.
trace
(
"
Remote
non
-
folder
{
remoteNode
}
deleted
locally
"
+
"
and
changed
remotely
;
taking
remote
change
"
{
remoteNode
}
)
;
this
.
telemetryEvents
.
push
(
{
value
:
"
structure
"
extra
:
{
type
:
"
delete
"
kind
:
"
item
"
prefer
:
"
remote
"
}
}
)
;
return
false
;
}
MirrorLog
.
trace
(
"
Remote
folder
{
remoteNode
}
deleted
locally
"
+
"
and
changed
remotely
;
taking
local
deletion
"
{
remoteNode
}
)
;
this
.
telemetryEvents
.
push
(
{
value
:
"
structure
"
extra
:
{
type
:
"
delete
"
kind
:
"
folder
"
prefer
:
"
local
"
}
}
)
;
}
else
{
MirrorLog
.
trace
(
"
Remote
node
{
remoteNode
}
deleted
locally
and
not
"
+
"
changed
remotely
;
taking
local
deletion
"
{
remoteNode
}
)
;
}
this
.
deleteRemotely
.
add
(
remoteNode
.
guid
)
;
let
mergedOrphanNodes
=
await
this
.
processRemoteOrphansForNode
(
mergedNode
remoteNode
)
;
await
this
.
relocateOrphansTo
(
mergedNode
mergedOrphanNodes
)
;
MirrorLog
.
trace
(
"
Relocating
remote
orphans
{
mergedOrphanNodes
}
to
"
+
"
{
mergedNode
}
"
{
mergedOrphanNodes
mergedNode
}
)
;
return
BookmarkMerger
.
STRUCTURE
.
DELETED
;
}
async
checkForRemoteStructureChangeOfLocalNode
(
mergedNode
localParentNode
localNode
)
{
if
(
!
this
.
remoteTree
.
isDeleted
(
localNode
.
guid
)
)
{
let
remoteNode
=
this
.
remoteTree
.
nodeForGuid
(
localNode
.
guid
)
;
if
(
!
remoteNode
)
{
return
BookmarkMerger
.
STRUCTURE
.
UNCHANGED
;
}
let
remoteParentNode
=
this
.
remoteTree
.
parentNodeFor
(
remoteNode
)
;
if
(
!
remoteParentNode
)
{
throw
new
SyncedBookmarksMirror
.
ConsistencyError
(
"
Can
'
t
check
for
structure
changes
of
remote
orphan
"
)
;
}
if
(
remoteParentNode
.
guid
!
=
localParentNode
.
guid
)
{
return
BookmarkMerger
.
STRUCTURE
.
MOVED
;
}
return
BookmarkMerger
.
STRUCTURE
.
UNCHANGED
;
}
if
(
localNode
.
needsMerge
)
{
if
(
!
localNode
.
isFolder
(
)
)
{
MirrorLog
.
trace
(
"
Local
non
-
folder
{
localNode
}
deleted
remotely
and
"
+
"
changed
locally
;
taking
local
change
"
{
localNode
}
)
;
this
.
telemetryEvents
.
push
(
{
value
:
"
structure
"
extra
:
{
type
:
"
delete
"
kind
:
"
item
"
prefer
:
"
local
"
}
}
)
;
return
false
;
}
MirrorLog
.
trace
(
"
Local
folder
{
localNode
}
deleted
remotely
and
"
+
"
changed
locally
;
taking
remote
deletion
"
{
localNode
}
)
;
this
.
telemetryEvents
.
push
(
{
value
:
"
structure
"
extra
:
{
type
:
"
delete
"
kind
:
"
folder
"
prefer
:
"
remote
"
}
}
)
;
}
else
{
MirrorLog
.
trace
(
"
Local
node
{
localNode
}
deleted
remotely
and
not
"
+
"
changed
locally
;
taking
remote
deletion
"
{
localNode
}
)
;
}
MirrorLog
.
trace
(
"
Local
node
{
localNode
}
deleted
remotely
;
taking
remote
"
+
"
deletion
"
{
localNode
}
)
;
this
.
deleteLocally
.
add
(
localNode
.
guid
)
;
let
mergedOrphanNodes
=
await
this
.
processLocalOrphansForNode
(
mergedNode
localNode
)
;
await
this
.
relocateOrphansTo
(
mergedNode
mergedOrphanNodes
)
;
MirrorLog
.
trace
(
"
Relocating
local
orphans
{
mergedOrphanNodes
}
to
"
+
"
{
mergedNode
}
"
{
mergedOrphanNodes
mergedNode
}
)
;
return
BookmarkMerger
.
STRUCTURE
.
DELETED
;
}
async
processRemoteOrphansForNode
(
mergedNode
remoteNode
)
{
let
remoteOrphanNodes
=
[
]
;
for
await
(
let
remoteChildNode
of
yieldingIterator
(
remoteNode
.
children
)
)
{
let
structureChange
=
await
this
.
checkForLocalStructureChangeOfRemoteNode
(
mergedNode
remoteNode
remoteChildNode
)
;
if
(
structureChange
=
=
BookmarkMerger
.
STRUCTURE
.
MOVED
|
|
structureChange
=
=
BookmarkMerger
.
STRUCTURE
.
DELETED
)
{
continue
;
}
remoteOrphanNodes
.
push
(
remoteChildNode
)
;
}
let
mergedOrphanNodes
=
[
]
;
for
await
(
let
remoteOrphanNode
of
yieldingIterator
(
remoteOrphanNodes
)
)
{
let
localOrphanNode
=
this
.
localTree
.
nodeForGuid
(
remoteOrphanNode
.
guid
)
;
let
mergedOrphanNode
=
await
this
.
mergeNode
(
remoteOrphanNode
.
guid
localOrphanNode
remoteOrphanNode
)
;
mergedOrphanNodes
.
push
(
mergedOrphanNode
)
;
}
return
mergedOrphanNodes
;
}
async
processLocalOrphansForNode
(
mergedNode
localNode
)
{
if
(
!
localNode
.
isFolder
(
)
)
{
return
[
]
;
}
let
localOrphanNodes
=
[
]
;
for
await
(
let
localChildNode
of
yieldingIterator
(
localNode
.
children
)
)
{
let
structureChange
=
await
this
.
checkForRemoteStructureChangeOfLocalNode
(
mergedNode
localNode
localChildNode
)
;
if
(
structureChange
=
=
BookmarkMerger
.
STRUCTURE
.
MOVED
|
|
structureChange
=
=
BookmarkMerger
.
STRUCTURE
.
DELETED
)
{
continue
;
}
localOrphanNodes
.
push
(
localChildNode
)
;
}
let
mergedOrphanNodes
=
[
]
;
for
await
(
let
localOrphanNode
of
yieldingIterator
(
localOrphanNodes
)
)
{
let
remoteOrphanNode
=
this
.
remoteTree
.
nodeForGuid
(
localOrphanNode
.
guid
)
;
let
mergedNode
=
await
this
.
mergeNode
(
localOrphanNode
.
guid
localOrphanNode
remoteOrphanNode
)
;
mergedOrphanNodes
.
push
(
mergedNode
)
;
}
return
mergedOrphanNodes
;
}
async
relocateOrphansTo
(
mergedNode
mergedOrphanNodes
)
{
for
(
let
mergedOrphanNode
of
mergedOrphanNodes
)
{
let
newStructureNode
=
await
mergedOrphanNode
.
toBookmarkNode
(
)
;
let
newMergeState
=
BookmarkMergeState
.
new
(
mergedOrphanNode
.
mergeState
newStructureNode
)
;
mergedOrphanNode
.
mergeState
=
newMergeState
;
mergedNode
.
mergedChildren
.
push
(
mergedOrphanNode
)
;
}
}
async
findLocalNodeMatchingRemoteNode
(
mergedNode
remoteChildNode
)
{
let
localParentNode
=
mergedNode
.
localNode
;
if
(
!
localParentNode
)
{
MirrorLog
.
trace
(
"
Merged
node
{
mergedNode
}
doesn
'
t
exist
locally
;
no
"
+
"
potential
dupes
for
{
remoteChildNode
}
"
{
mergedNode
remoteChildNode
}
)
;
return
null
;
}
let
remoteChildContent
=
this
.
newRemoteContents
.
get
(
remoteChildNode
.
guid
)
;
if
(
!
remoteChildContent
)
{
return
null
;
}
let
newLocalNode
=
null
;
for
await
(
let
localChildNode
of
yieldingIterator
(
localParentNode
.
children
)
)
{
if
(
this
.
mergedGuids
.
has
(
localChildNode
.
guid
)
)
{
MirrorLog
.
trace
(
"
Not
deduping
{
localChildNode
}
;
already
seen
in
"
+
"
another
folder
"
{
localChildNode
}
)
;
continue
;
}
if
(
!
this
.
newLocalContents
.
has
(
localChildNode
.
guid
)
)
{
MirrorLog
.
trace
(
"
Not
deduping
{
localChildNode
}
;
already
uploaded
"
{
localChildNode
}
)
;
continue
;
}
let
remoteCandidate
=
this
.
remoteTree
.
nodeForGuid
(
localChildNode
.
guid
)
;
if
(
remoteCandidate
)
{
MirrorLog
.
trace
(
"
Not
deduping
{
localChildNode
}
;
already
exists
"
+
"
remotely
"
{
localChildNode
}
)
;
continue
;
}
if
(
this
.
remoteTree
.
isDeleted
(
localChildNode
.
guid
)
)
{
MirrorLog
.
trace
(
"
Not
deduping
{
localChildNode
}
;
deleted
on
server
"
{
localChildNode
}
)
;
continue
;
}
let
localChildContent
=
this
.
newLocalContents
.
get
(
localChildNode
.
guid
)
;
if
(
!
contentsMatch
(
localChildNode
localChildContent
remoteChildNode
remoteChildContent
)
)
{
MirrorLog
.
trace
(
"
{
localChildNode
}
is
not
a
dupe
of
{
remoteChildNode
}
"
{
localChildNode
remoteChildNode
}
)
;
continue
;
}
this
.
telemetryEvents
.
push
(
{
value
:
"
dupe
"
}
)
;
newLocalNode
=
localChildNode
;
break
;
}
return
newLocalNode
;
}
deletionsToStrings
(
)
{
let
infos
=
[
]
;
if
(
this
.
deleteLocally
.
size
)
{
infos
.
push
(
"
L
:
"
+
Array
.
from
(
this
.
deleteLocally
guid
=
>
~
{
guid
}
)
.
join
(
"
"
)
)
;
}
if
(
this
.
deleteRemotely
.
size
)
{
infos
.
push
(
"
R
:
"
+
Array
.
from
(
this
.
deleteRemotely
guid
=
>
~
{
guid
}
)
.
join
(
"
"
)
)
;
}
return
infos
;
}
}
BookmarkMerger
.
STRUCTURE
=
{
UNCHANGED
:
1
MOVED
:
2
DELETED
:
3
}
;
function
contentsMatch
(
localNode
localContent
remoteNode
remoteContent
)
{
if
(
localNode
.
kind
!
=
remoteNode
.
kind
)
{
return
false
;
}
switch
(
localNode
.
kind
)
{
case
SyncedBookmarksMirror
.
KIND
.
BOOKMARK
:
return
localContent
.
title
=
=
remoteContent
.
title
&
&
localContent
.
hasSameURL
(
remoteContent
)
;
case
SyncedBookmarksMirror
.
KIND
.
QUERY
:
if
(
localContent
.
smartBookmarkName
|
|
remoteContent
.
smartBookmarkName
)
{
return
localContent
.
smartBookmarkName
=
=
remoteContent
.
smartBookmarkName
;
}
return
localContent
.
title
=
=
remoteContent
.
title
&
&
localContent
.
hasSameURL
(
remoteContent
)
;
case
SyncedBookmarksMirror
.
KIND
.
FOLDER
:
case
SyncedBookmarksMirror
.
KIND
.
LIVEMARK
:
return
localContent
.
title
=
=
remoteContent
.
title
;
case
SyncedBookmarksMirror
.
KIND
.
SEPARATOR
:
return
localContent
.
position
=
=
remoteContent
.
position
;
}
return
false
;
}
class
BookmarkObserverRecorder
{
constructor
(
db
)
{
this
.
db
=
db
;
this
.
bookmarkObserverNotifications
=
[
]
;
this
.
annoObserverNotifications
=
[
]
;
this
.
shouldInvalidateKeywords
=
false
;
this
.
shouldInvalidateLivemarks
=
false
;
}
async
notifyAll
(
)
{
if
(
this
.
shouldInvalidateKeywords
)
{
await
PlacesUtils
.
keywords
.
invalidateCachedKeywords
(
)
;
}
await
this
.
notifyBookmarkObservers
(
)
;
await
this
.
notifyAnnoObservers
(
)
;
if
(
this
.
shouldInvalidateLivemarks
)
{
await
PlacesUtils
.
livemarks
.
invalidateCachedLivemarks
(
)
;
}
await
this
.
updateFrecencies
(
)
;
}
async
updateFrecencies
(
)
{
MirrorLog
.
debug
(
"
Recalculating
frecencies
for
new
URLs
"
)
;
await
this
.
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
CALCULATE_FRECENCY
(
id
)
WHERE
frecency
=
-
1
)
;
}
noteItemAdded
(
info
)
{
let
uri
=
info
.
urlHref
?
Services
.
io
.
newURI
(
info
.
urlHref
)
:
null
;
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemAdded
"
isTagging
:
info
.
isTagging
args
:
[
info
.
id
info
.
parentId
info
.
position
info
.
type
uri
info
.
title
info
.
dateAdded
info
.
guid
info
.
parentGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
noteGuidChanged
(
info
)
{
PlacesUtils
.
invalidateCachedGuidFor
(
info
.
id
)
;
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemChanged
"
isTagging
:
false
args
:
[
info
.
id
"
guid
"
false
info
.
newGuid
info
.
lastModified
info
.
type
info
.
parentId
info
.
newGuid
info
.
parentGuid
info
.
oldGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
noteItemMoved
(
info
)
{
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemMoved
"
isTagging
:
false
args
:
[
info
.
id
info
.
oldParentId
info
.
oldPosition
info
.
newParentId
info
.
newPosition
info
.
type
info
.
guid
info
.
oldParentGuid
info
.
newParentGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
noteItemChanged
(
info
)
{
if
(
info
.
oldTitle
!
=
info
.
newTitle
)
{
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemChanged
"
isTagging
:
false
args
:
[
info
.
id
"
title
"
false
info
.
newTitle
info
.
lastModified
info
.
type
info
.
parentId
info
.
guid
info
.
parentGuid
info
.
oldTitle
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
if
(
info
.
oldURLHref
!
=
info
.
newURLHref
)
{
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemChanged
"
isTagging
:
false
args
:
[
info
.
id
"
uri
"
false
info
.
newURLHref
info
.
lastModified
info
.
type
info
.
parentId
info
.
guid
info
.
parentGuid
info
.
oldURLHref
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
}
noteItemRemoved
(
info
)
{
let
uri
=
info
.
urlHref
?
Services
.
io
.
newURI
(
info
.
urlHref
)
:
null
;
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemRemoved
"
isTagging
:
info
.
isUntagging
args
:
[
info
.
id
info
.
parentId
info
.
position
info
.
type
uri
info
.
guid
info
.
parentGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
noteAnnoSet
(
id
name
)
{
if
(
isLivemarkAnno
(
name
)
)
{
this
.
shouldInvalidateLivemarks
=
true
;
}
this
.
annoObserverNotifications
.
push
(
{
name
:
"
onItemAnnotationSet
"
args
:
[
id
name
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
noteAnnoRemoved
(
id
name
)
{
if
(
isLivemarkAnno
(
name
)
)
{
this
.
shouldInvalidateLivemarks
=
true
;
}
this
.
annoObserverNotifications
.
push
(
{
name
:
"
onItemAnnotationRemoved
"
args
:
[
id
name
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
async
notifyBookmarkObservers
(
)
{
MirrorLog
.
debug
(
"
Notifying
bookmark
observers
"
)
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
for
(
let
observer
of
observers
)
{
this
.
notifyObserver
(
observer
"
onBeginUpdateBatch
"
)
;
for
await
(
let
info
of
yieldingIterator
(
this
.
bookmarkObserverNotifications
)
)
{
if
(
info
.
isTagging
&
&
observer
.
skipTags
)
{
continue
;
}
this
.
notifyObserver
(
observer
info
.
name
info
.
args
)
;
}
this
.
notifyObserver
(
observer
"
onEndUpdateBatch
"
)
;
}
}
async
notifyAnnoObservers
(
)
{
MirrorLog
.
debug
(
"
Notifying
anno
observers
"
)
;
let
observers
=
PlacesUtils
.
annotations
.
getObservers
(
)
;
for
(
let
observer
of
observers
)
{
let
wrapped
=
yieldingIterator
(
this
.
annoObserverNotifications
)
;
for
await
(
let
{
name
args
}
of
wrapped
)
{
this
.
notifyObserver
(
observer
name
args
)
;
}
}
}
notifyObserver
(
observer
notification
args
=
[
]
)
{
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
MirrorLog
.
warn
(
"
Error
notifying
observer
"
ex
)
;
}
}
}
function
isLivemarkAnno
(
name
)
{
return
name
=
=
PlacesUtils
.
LMANNO_FEEDURI
|
|
name
=
=
PlacesUtils
.
LMANNO_SITEURI
;
}
class
BookmarkChangeRecord
{
constructor
(
syncChangeCounter
cleartext
)
{
this
.
tombstone
=
cleartext
.
deleted
=
=
=
true
;
this
.
counter
=
syncChangeCounter
;
this
.
cleartext
=
cleartext
;
this
.
synced
=
false
;
}
}
