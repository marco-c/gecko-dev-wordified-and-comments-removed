"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SyncedBookmarksMirror
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Async
:
"
resource
:
/
/
services
-
common
/
async
.
js
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
PlacesSyncUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
MirrorLog
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Sync
.
Engine
.
Bookmarks
.
Mirror
"
)
)
;
const
SyncedBookmarksMerger
=
Components
.
Constructor
(
"
mozilla
.
org
/
browser
/
synced
-
bookmarks
-
merger
;
1
"
"
mozISyncedBookmarksMerger
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
LocalItemsSQLFragment
"
(
)
=
>
localItems
(
id
guid
parentId
parentGuid
position
type
title
parentTitle
placeId
dateAdded
lastModified
syncChangeCounter
isSyncable
level
)
AS
(
SELECT
b
.
id
b
.
guid
p
.
id
p
.
guid
b
.
position
b
.
type
b
.
title
p
.
title
b
.
fk
b
.
dateAdded
b
.
lastModified
b
.
syncChangeCounter
b
.
guid
IN
(
{
PlacesUtils
.
bookmarks
.
userContentRoots
.
map
(
v
=
>
'
{
v
}
'
)
.
join
(
"
"
)
}
)
0
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
guid
<
>
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
UNION
ALL
SELECT
b
.
id
b
.
guid
s
.
id
s
.
guid
b
.
position
b
.
type
b
.
title
s
.
title
b
.
fk
b
.
dateAdded
b
.
lastModified
b
.
syncChangeCounter
s
.
isSyncable
s
.
level
+
1
FROM
moz_bookmarks
b
JOIN
localItems
s
ON
s
.
id
=
b
.
parent
WHERE
b
.
guid
<
>
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
)
)
;
const
DB_URL_LENGTH_MAX
=
65536
;
const
DB_TITLE_LENGTH_MAX
=
4096
;
const
SQLITE_MAX_VARIABLE_NUMBER
=
999
;
const
MIRROR_SCHEMA_VERSION
=
4
;
const
DEFAULT_MAX_FRECENCIES_TO_RECALCULATE
=
400
;
XPCOMUtils
.
defineLazyGetter
(
this
"
yieldState
"
(
)
=
>
Async
.
yieldState
(
)
)
;
class
MirrorLoggerAdapter
{
constructor
(
log
)
{
this
.
log
=
log
;
}
get
maxLevel
(
)
{
let
level
=
this
.
log
.
level
;
if
(
level
<
=
Log
.
Level
.
All
)
{
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_TRACE
;
}
if
(
level
<
=
Log
.
Level
.
Info
)
{
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_DEBUG
;
}
if
(
level
<
=
Log
.
Level
.
Warn
)
{
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_WARN
;
}
if
(
level
<
=
Log
.
Level
.
Error
)
{
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_ERROR
;
}
return
Ci
.
mozISyncedBookmarksMirrorLogger
.
LEVEL_OFF
;
}
trace
(
message
)
{
this
.
log
.
trace
(
message
)
;
}
debug
(
message
)
{
this
.
log
.
debug
(
message
)
;
}
warn
(
message
)
{
this
.
log
.
warn
(
message
)
;
}
error
(
message
)
{
this
.
log
.
error
(
message
)
;
}
}
class
SyncedBookmarksMirror
{
constructor
(
db
{
recordTelemetryEvent
finalizeAt
=
AsyncShutdown
.
profileBeforeChange
}
=
{
}
)
{
this
.
db
=
db
;
this
.
recordTelemetryEvent
=
recordTelemetryEvent
;
this
.
merger
=
new
SyncedBookmarksMerger
(
)
;
this
.
merger
.
db
=
db
.
unsafeRawConnection
.
QueryInterface
(
Ci
.
mozIStorageConnection
)
;
this
.
merger
.
logger
=
new
MirrorLoggerAdapter
(
MirrorLog
)
;
this
.
finalizeAt
=
finalizeAt
;
this
.
finalizeBound
=
(
)
=
>
this
.
finalize
(
)
;
this
.
finalizeAt
.
addBlocker
(
"
SyncedBookmarksMirror
:
finalize
"
this
.
finalizeBound
)
;
}
static
async
open
(
options
)
{
let
db
=
await
Sqlite
.
cloneStorageConnection
(
{
connection
:
PlacesUtils
.
history
.
DBConnection
readOnly
:
false
}
)
;
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
options
.
path
)
;
let
whyFailed
=
"
initialize
"
;
try
{
await
db
.
execute
(
PRAGMA
foreign_keys
=
ON
)
;
try
{
await
attachAndInitMirrorDatabase
(
db
path
)
;
}
catch
(
ex
)
{
if
(
isDatabaseCorrupt
(
ex
)
)
{
MirrorLog
.
warn
(
"
Error
attaching
mirror
to
Places
;
removing
and
"
+
"
recreating
mirror
"
ex
)
;
options
.
recordTelemetryEvent
(
"
mirror
"
"
open
"
"
retry
"
{
why
:
"
corrupt
"
}
)
;
whyFailed
=
"
remove
"
;
await
OS
.
File
.
remove
(
path
)
;
whyFailed
=
"
replace
"
;
await
attachAndInitMirrorDatabase
(
db
path
)
;
}
else
{
MirrorLog
.
error
(
"
Unrecoverable
error
attaching
mirror
to
Places
"
ex
)
;
throw
ex
;
}
}
try
{
let
info
=
await
OS
.
File
.
stat
(
path
)
;
let
size
=
Math
.
floor
(
info
.
size
/
1024
)
;
options
.
recordTelemetryEvent
(
"
mirror
"
"
open
"
"
success
"
{
size
}
)
;
}
catch
(
ex
)
{
MirrorLog
.
warn
(
"
Error
recording
stats
for
mirror
database
size
"
ex
)
;
}
}
catch
(
ex
)
{
options
.
recordTelemetryEvent
(
"
mirror
"
"
open
"
"
error
"
{
why
:
whyFailed
}
)
;
await
db
.
close
(
)
;
throw
ex
;
}
return
new
SyncedBookmarksMirror
(
db
options
)
;
}
async
getCollectionHighWaterMark
(
)
{
let
rows
=
await
this
.
db
.
executeCached
(
SELECT
MAX
(
IFNULL
(
(
SELECT
MAX
(
serverModified
)
-
1000
FROM
items
)
0
)
IFNULL
(
(
SELECT
CAST
(
value
AS
INTEGER
)
FROM
meta
WHERE
key
=
:
modifiedKey
)
0
)
)
AS
highWaterMark
{
modifiedKey
:
SyncedBookmarksMirror
.
META_KEY
.
LAST_MODIFIED
}
)
;
let
highWaterMark
=
rows
[
0
]
.
getResultByName
(
"
highWaterMark
"
)
;
return
highWaterMark
/
1000
;
}
async
setCollectionLastModified
(
lastModifiedSeconds
)
{
let
lastModified
=
Math
.
floor
(
lastModifiedSeconds
*
1000
)
;
if
(
!
Number
.
isInteger
(
lastModified
)
)
{
throw
new
TypeError
(
"
Invalid
collection
last
modified
time
"
)
;
}
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
setCollectionLastModified
"
db
=
>
db
.
executeCached
(
REPLACE
INTO
meta
(
key
value
)
VALUES
(
:
modifiedKey
:
lastModified
)
{
modifiedKey
:
SyncedBookmarksMirror
.
META_KEY
.
LAST_MODIFIED
lastModified
}
)
)
;
}
async
getSyncId
(
)
{
let
rows
=
await
this
.
db
.
executeCached
(
SELECT
value
FROM
meta
WHERE
key
=
:
syncIdKey
{
syncIdKey
:
SyncedBookmarksMirror
.
META_KEY
.
SYNC_ID
}
)
;
return
rows
.
length
?
rows
[
0
]
.
getResultByName
(
"
value
"
)
:
"
"
;
}
async
ensureCurrentSyncId
(
newSyncId
)
{
if
(
!
newSyncId
|
|
typeof
newSyncId
!
=
"
string
"
)
{
throw
new
TypeError
(
"
Invalid
new
bookmarks
sync
ID
"
)
;
}
let
existingSyncId
=
await
this
.
getSyncId
(
)
;
if
(
existingSyncId
=
=
newSyncId
)
{
MirrorLog
.
trace
(
"
Sync
ID
up
-
to
-
date
in
mirror
"
{
existingSyncId
}
)
;
return
;
}
MirrorLog
.
info
(
"
Sync
ID
changed
from
{
existingSyncId
}
to
"
+
"
{
newSyncId
}
;
resetting
mirror
"
{
existingSyncId
newSyncId
}
)
;
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
ensureCurrentSyncId
"
db
=
>
db
.
executeTransaction
(
async
function
(
)
{
await
resetMirror
(
db
)
;
await
db
.
execute
(
REPLACE
INTO
meta
(
key
value
)
VALUES
(
:
syncIdKey
:
newSyncId
)
{
syncIdKey
:
SyncedBookmarksMirror
.
META_KEY
.
SYNC_ID
newSyncId
}
)
;
}
)
)
;
}
async
store
(
records
{
needsMerge
=
true
}
=
{
}
)
{
let
options
=
{
needsMerge
}
;
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
store
"
db
=
>
db
.
executeTransaction
(
async
(
)
=
>
{
await
Async
.
yieldingForEach
(
records
async
(
record
)
=
>
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
if
(
guid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
)
{
throw
new
TypeError
(
"
Can
'
t
store
Places
root
"
)
;
}
MirrorLog
.
trace
(
Storing
in
mirror
:
{
record
.
cleartextToString
(
)
}
)
;
switch
(
record
.
type
)
{
case
"
bookmark
"
:
await
this
.
storeRemoteBookmark
(
record
options
)
;
return
;
case
"
query
"
:
await
this
.
storeRemoteQuery
(
record
options
)
;
return
;
case
"
folder
"
:
await
this
.
storeRemoteFolder
(
record
options
)
;
return
;
case
"
livemark
"
:
await
this
.
storeRemoteLivemark
(
record
options
)
;
return
;
case
"
separator
"
:
await
this
.
storeRemoteSeparator
(
record
options
)
;
return
;
default
:
if
(
record
.
deleted
)
{
await
this
.
storeRemoteTombstone
(
record
options
)
;
return
;
}
}
MirrorLog
.
warn
(
"
Ignoring
record
with
unknown
type
"
record
.
type
)
;
}
yieldState
)
;
}
)
)
;
}
async
apply
(
options
=
{
}
)
{
let
hasChanges
=
(
"
weakUpload
"
in
options
&
&
options
.
weakUpload
.
length
>
0
)
|
|
(
await
this
.
hasChanges
(
)
)
;
if
(
!
hasChanges
)
{
MirrorLog
.
debug
(
"
No
changes
detected
in
both
mirror
and
Places
"
)
;
let
limit
=
"
maxFrecenciesToRecalculate
"
in
options
?
options
.
maxFrecenciesToRecalculate
:
DEFAULT_MAX_FRECENCIES_TO_RECALCULATE
;
await
updateFrecencies
(
this
.
db
limit
)
;
return
{
}
;
}
let
changeRecords
=
await
this
.
forceApply
(
options
)
;
return
changeRecords
;
}
async
forceApply
(
{
localTimeSeconds
=
Date
.
now
(
)
/
1000
remoteTimeSeconds
=
0
weakUpload
=
[
]
maxFrecenciesToRecalculate
=
DEFAULT_MAX_FRECENCIES_TO_RECALCULATE
}
=
{
}
)
{
let
observersToNotify
=
new
BookmarkObserverRecorder
(
this
.
db
{
maxFrecenciesToRecalculate
}
)
;
if
(
!
(
await
this
.
validLocalRoots
(
)
)
)
{
throw
new
SyncedBookmarksMirror
.
MergeError
(
"
Local
tree
has
misparented
root
"
)
;
}
let
flowID
=
PlacesUtils
.
history
.
makeGuid
(
)
;
let
changeRecords
;
try
{
changeRecords
=
await
this
.
tryApply
(
flowID
localTimeSeconds
remoteTimeSeconds
observersToNotify
weakUpload
)
;
}
catch
(
ex
)
{
let
why
=
(
typeof
ex
.
message
=
=
"
string
"
?
ex
.
message
:
String
(
ex
)
)
.
slice
(
0
85
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
error
"
{
flowID
why
}
)
;
throw
ex
;
}
return
changeRecords
;
}
async
tryApply
(
flowID
localTimeSeconds
remoteTimeSeconds
observersToNotify
weakUpload
)
{
let
{
missingParents
missingChildren
parentsWithGaps
}
=
await
this
.
fetchRemoteOrphans
(
)
;
if
(
missingParents
.
length
)
{
MirrorLog
.
warn
(
"
Temporarily
reparenting
remote
items
with
missing
"
+
"
parents
to
unfiled
"
missingParents
)
;
}
if
(
missingChildren
.
length
)
{
MirrorLog
.
warn
(
"
Remote
tree
missing
items
"
missingChildren
)
;
}
if
(
parentsWithGaps
.
length
)
{
MirrorLog
.
warn
(
"
Remote
tree
has
parents
with
gaps
in
positions
"
parentsWithGaps
)
;
}
let
{
missingLocal
missingRemote
wrongSyncStatus
}
=
await
this
.
fetchSyncStatusMismatches
(
)
;
if
(
missingLocal
.
length
)
{
MirrorLog
.
warn
(
"
Remote
tree
has
merged
items
that
don
'
t
exist
locally
"
missingLocal
)
;
}
if
(
missingRemote
.
length
)
{
MirrorLog
.
warn
(
"
Local
tree
has
synced
items
that
don
'
t
exist
remotely
"
missingRemote
)
;
}
if
(
wrongSyncStatus
.
length
)
{
MirrorLog
.
warn
(
"
Local
tree
has
wrong
sync
statuses
for
items
that
"
+
"
exist
remotely
"
wrongSyncStatus
)
;
}
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
problems
"
{
flowID
missingParents
:
missingParents
.
length
missingChildren
:
missingChildren
.
length
parentsWithGaps
:
parentsWithGaps
.
length
missingLocal
:
missingLocal
.
length
missingRemote
:
missingRemote
.
length
wrongSyncStatus
:
wrongSyncStatus
.
length
}
)
;
let
result
=
await
withTiming
(
"
Merging
bookmarks
in
Rust
"
(
)
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
callback
=
{
handleResult
:
resolve
handleError
(
code
message
)
{
if
(
code
=
=
Cr
.
NS_ERROR_STORAGE_BUSY
)
{
reject
(
new
SyncedBookmarksMirror
.
MergeConflictError
(
"
Local
tree
changed
during
merge
"
)
)
;
}
else
{
reject
(
new
SyncedBookmarksMirror
.
MergeError
(
message
)
)
;
}
}
}
;
this
.
merger
.
merge
(
localTimeSeconds
remoteTimeSeconds
weakUpload
callback
)
;
}
)
;
}
)
;
let
telem
=
result
.
QueryInterface
(
Ci
.
nsIPropertyBag
)
;
const
telemPropToEventValue
=
[
[
"
fetchLocalTreeTime
"
"
fetchLocalTree
"
]
[
"
fetchNewLocalContentsTime
"
"
fetchNewLocalContents
"
]
[
"
fetchRemoteTreeTime
"
"
fetchRemoteTree
"
]
[
"
fetchNewRemoteContentsTime
"
"
fetchNewRemoteContents
"
]
]
;
for
(
let
[
prop
value
]
of
telemPropToEventValue
)
{
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
value
{
flowID
time
:
telem
.
getProperty
(
prop
)
}
)
;
}
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
merge
"
{
flowID
time
:
telem
.
getProperty
(
"
mergeTime
"
)
nodes
:
telem
.
getProperty
(
"
mergedNodesCount
"
)
deletions
:
telem
.
getProperty
(
"
mergedDeletionsCount
"
)
dupes
:
telem
.
getProperty
(
"
dupesCount
"
)
}
)
;
this
.
recordTelemetryEvent
(
"
mirror
"
"
merge
"
"
structure
"
{
remoteRevives
:
telem
.
getProperty
(
"
remoteRevivesCount
"
)
localDeletes
:
telem
.
getProperty
(
"
localDeletesCount
"
)
localRevives
:
telem
.
getProperty
(
"
localRevivesCount
"
)
remoteDeletes
:
telem
.
getProperty
(
"
remoteDeletesCount
"
)
}
)
;
await
withTiming
(
"
Notifying
Places
observers
"
async
(
)
=
>
{
try
{
await
observersToNotify
.
notifyAll
(
)
;
}
catch
(
ex
)
{
MirrorLog
.
warn
(
"
Error
notifying
Places
observers
"
ex
)
;
}
finally
{
await
this
.
db
.
executeTransaction
(
async
(
)
=
>
{
await
this
.
db
.
execute
(
DELETE
FROM
itemsAdded
)
;
await
this
.
db
.
execute
(
DELETE
FROM
guidsChanged
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsChanged
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsRemoved
)
;
await
this
.
db
.
execute
(
DELETE
FROM
itemsMoved
)
;
}
)
;
}
}
time
=
>
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
notifyObservers
"
{
flowID
time
}
)
)
;
return
withTiming
(
"
Fetching
records
for
local
items
to
upload
"
async
(
)
=
>
{
try
{
let
changeRecords
=
await
this
.
fetchLocalChangeRecords
(
)
;
return
changeRecords
;
}
finally
{
await
this
.
db
.
execute
(
DELETE
FROM
itemsToUpload
)
;
}
}
time
=
>
this
.
recordTelemetryEvent
(
"
mirror
"
"
apply
"
"
fetchLocalChangeRecords
"
{
flowID
time
}
)
)
;
}
async
reset
(
)
{
await
this
.
db
.
executeBeforeShutdown
(
"
SyncedBookmarksMirror
:
reset
"
db
=
>
db
.
executeTransaction
(
(
)
=
>
resetMirror
(
db
)
)
)
;
}
async
fetchUnmergedGuids
(
)
{
let
rows
=
await
this
.
db
.
execute
(
SELECT
guid
FROM
items
WHERE
needsMerge
)
;
return
rows
.
map
(
row
=
>
row
.
getResultByName
(
"
guid
"
)
)
;
}
async
storeRemoteBookmark
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
url
=
validateURL
(
record
.
bmkUri
)
;
if
(
url
)
{
await
this
.
maybeStoreRemoteURL
(
url
)
;
}
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
keyword
=
validateKeyword
(
record
.
keyword
)
;
let
validity
=
url
?
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_VALID
:
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REPLACE
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
title
keyword
validity
urlId
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
"
"
)
:
keyword
:
validity
(
SELECT
id
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_BOOKMARK
dateAdded
title
keyword
url
:
url
?
url
.
href
:
null
validity
}
)
;
let
tags
=
record
.
tags
;
if
(
tags
&
&
Array
.
isArray
(
tags
)
)
{
for
(
let
rawTag
of
tags
)
{
let
tag
=
validateTag
(
rawTag
)
;
if
(
!
tag
)
{
continue
;
}
await
this
.
db
.
executeCached
(
INSERT
INTO
tags
(
itemId
tag
)
SELECT
id
:
tag
FROM
items
WHERE
guid
=
:
guid
{
tag
guid
}
)
;
}
}
}
async
storeRemoteQuery
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_VALID
;
let
url
=
validateURL
(
record
.
bmkUri
)
;
if
(
url
)
{
let
params
=
new
URLSearchParams
(
url
.
pathname
)
;
let
type
=
+
params
.
get
(
"
type
"
)
;
if
(
type
=
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAG_CONTENTS
)
{
let
tagFolderName
=
validateTag
(
record
.
folderName
)
;
if
(
tagFolderName
)
{
url
.
href
=
place
:
tag
=
{
tagFolderName
}
;
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REUPLOAD
;
}
else
{
url
=
null
;
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REPLACE
;
}
}
else
{
let
folder
=
params
.
get
(
"
folder
"
)
;
if
(
folder
&
&
!
params
.
has
(
"
excludeItems
"
)
)
{
url
.
href
=
{
url
.
href
}
&
excludeItems
=
1
;
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REUPLOAD
;
}
}
await
this
.
maybeStoreRemoteURL
(
url
)
;
}
else
{
validity
=
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REPLACE
;
}
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
title
urlId
validity
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
"
"
)
(
SELECT
id
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
:
validity
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_QUERY
dateAdded
title
url
:
url
?
url
.
href
:
null
validity
}
)
;
}
async
storeRemoteFolder
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
title
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
"
"
)
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_FOLDER
dateAdded
title
}
)
;
let
children
=
record
.
children
;
if
(
children
&
&
Array
.
isArray
(
children
)
)
{
for
(
let
[
offset
chunk
]
of
PlacesSyncUtils
.
chunkArray
(
children
SQLITE_MAX_VARIABLE_NUMBER
-
1
)
)
{
let
valuesFragment
=
Array
.
from
(
{
length
:
chunk
.
length
}
(
_
index
)
=
>
(
?
{
index
+
2
}
?
1
{
offset
+
index
}
)
)
.
join
(
"
"
)
;
await
this
.
db
.
execute
(
INSERT
INTO
structure
(
guid
parentGuid
position
)
VALUES
{
valuesFragment
}
[
guid
.
.
.
chunk
.
map
(
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
)
]
)
;
}
}
}
async
storeRemoteLivemark
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
feedURL
=
validateURL
(
record
.
feedUri
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
let
title
=
validateTitle
(
record
.
title
)
;
let
siteURL
=
validateURL
(
record
.
siteUri
)
;
let
validity
=
feedURL
?
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_VALID
:
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_REPLACE
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
title
feedURL
siteURL
validity
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
NULLIF
(
:
title
"
"
)
:
feedURL
:
siteURL
:
validity
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_LIVEMARK
dateAdded
title
feedURL
:
feedURL
?
feedURL
.
href
:
null
siteURL
:
siteURL
?
siteURL
.
href
:
null
validity
}
)
;
}
async
storeRemoteSeparator
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
parentGuid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
parentid
)
;
let
serverModified
=
determineServerModified
(
record
)
;
let
dateAdded
=
determineDateAdded
(
record
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
parentGuid
serverModified
needsMerge
kind
dateAdded
)
VALUES
(
:
guid
:
parentGuid
:
serverModified
:
needsMerge
:
kind
:
dateAdded
)
{
guid
parentGuid
serverModified
needsMerge
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_SEPARATOR
dateAdded
}
)
;
}
async
storeRemoteTombstone
(
record
{
needsMerge
}
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
record
.
id
)
;
let
serverModified
=
determineServerModified
(
record
)
;
await
this
.
db
.
executeCached
(
REPLACE
INTO
items
(
guid
serverModified
needsMerge
isDeleted
)
VALUES
(
:
guid
:
serverModified
:
needsMerge
1
)
{
guid
serverModified
needsMerge
}
)
;
}
async
maybeStoreRemoteURL
(
url
)
{
await
this
.
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
urls
(
guid
url
hash
revHost
)
VALUES
(
IFNULL
(
(
SELECT
guid
FROM
urls
WHERE
hash
=
hash
(
:
url
)
AND
url
=
:
url
)
GENERATE_GUID
(
)
)
:
url
hash
(
:
url
)
:
revHost
)
{
url
:
url
.
href
revHost
:
PlacesUtils
.
getReversedHost
(
url
)
}
)
;
}
async
fetchRemoteOrphans
(
)
{
let
infos
=
{
missingParents
:
[
]
missingChildren
:
[
]
parentsWithGaps
:
[
]
}
;
let
orphanRows
=
await
this
.
db
.
execute
(
SELECT
v
.
guid
AS
guid
1
AS
missingParent
0
AS
missingChild
0
AS
parentWithGaps
FROM
items
v
LEFT
JOIN
structure
s
ON
s
.
guid
=
v
.
guid
WHERE
NOT
v
.
isDeleted
AND
s
.
guid
IS
NULL
UNION
ALL
SELECT
s
.
guid
AS
guid
0
AS
missingParent
1
AS
missingChild
0
AS
parentsWithGaps
FROM
structure
s
LEFT
JOIN
items
v
ON
v
.
guid
=
s
.
guid
WHERE
v
.
guid
IS
NULL
UNION
ALL
SELECT
s
.
parentGuid
AS
guid
0
AS
missingParent
0
AS
missingChild
1
AS
parentWithGaps
FROM
structure
s
WHERE
s
.
guid
<
>
:
rootGuid
GROUP
BY
s
.
parentGuid
HAVING
(
sum
(
DISTINCT
position
+
1
)
-
(
count
(
*
)
*
(
count
(
*
)
+
1
)
/
2
)
)
<
>
0
ORDER
BY
guid
{
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
}
)
;
await
Async
.
yieldingForEach
(
orphanRows
row
=
>
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
missingParent
=
row
.
getResultByName
(
"
missingParent
"
)
;
if
(
missingParent
)
{
infos
.
missingParents
.
push
(
guid
)
;
}
let
missingChild
=
row
.
getResultByName
(
"
missingChild
"
)
;
if
(
missingChild
)
{
infos
.
missingChildren
.
push
(
guid
)
;
}
let
parentWithGaps
=
row
.
getResultByName
(
"
parentWithGaps
"
)
;
if
(
parentWithGaps
)
{
infos
.
parentsWithGaps
.
push
(
guid
)
;
}
}
yieldState
)
;
return
infos
;
}
async
fetchSyncStatusMismatches
(
)
{
let
infos
=
{
missingLocal
:
[
]
missingRemote
:
[
]
wrongSyncStatus
:
[
]
}
;
let
problemRows
=
await
this
.
db
.
execute
(
SELECT
v
.
guid
1
AS
missingLocal
0
AS
missingRemote
0
AS
wrongSyncStatus
FROM
items
v
LEFT
JOIN
moz_bookmarks
b
ON
b
.
guid
=
v
.
guid
LEFT
JOIN
moz_bookmarks_deleted
d
ON
d
.
guid
=
v
.
guid
WHERE
NOT
v
.
needsMerge
AND
NOT
v
.
isDeleted
AND
b
.
guid
IS
NULL
AND
d
.
guid
IS
NULL
UNION
ALL
SELECT
b
.
guid
0
AS
missingLocal
1
AS
missingRemote
0
AS
wrongSyncStatus
FROM
moz_bookmarks
b
LEFT
JOIN
items
v
ON
v
.
guid
=
b
.
guid
WHERE
EXISTS
(
SELECT
1
FROM
items
WHERE
NOT
needsMerge
AND
guid
<
>
:
rootGuid
)
AND
b
.
syncStatus
=
:
syncStatus
AND
v
.
guid
IS
NULL
UNION
ALL
SELECT
d
.
guid
0
AS
missingLocal
1
AS
missingRemote
0
AS
wrongSyncStatus
FROM
moz_bookmarks_deleted
d
LEFT
JOIN
items
v
ON
v
.
guid
=
d
.
guid
WHERE
EXISTS
(
SELECT
1
FROM
items
WHERE
NOT
needsMerge
AND
guid
<
>
:
rootGuid
)
AND
v
.
guid
IS
NULL
UNION
ALL
SELECT
b
.
guid
0
AS
missingLocal
0
AS
missingRemote
1
AS
wrongSyncStatus
FROM
moz_bookmarks
b
JOIN
items
v
ON
v
.
guid
=
b
.
guid
WHERE
EXISTS
(
SELECT
1
FROM
items
WHERE
NOT
needsMerge
AND
guid
<
>
:
rootGuid
)
AND
b
.
guid
<
>
:
rootGuid
AND
b
.
syncStatus
<
>
:
syncStatus
{
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
}
)
;
await
Async
.
yieldingForEach
(
problemRows
row
=
>
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
missingLocal
=
row
.
getResultByName
(
"
missingLocal
"
)
;
if
(
missingLocal
)
{
infos
.
missingLocal
.
push
(
guid
)
;
}
let
missingRemote
=
row
.
getResultByName
(
"
missingRemote
"
)
;
if
(
missingRemote
)
{
infos
.
missingRemote
.
push
(
guid
)
;
}
let
wrongSyncStatus
=
row
.
getResultByName
(
"
wrongSyncStatus
"
)
;
if
(
wrongSyncStatus
)
{
infos
.
wrongSyncStatus
.
push
(
guid
)
;
}
}
yieldState
)
;
return
infos
;
}
async
hasChanges
(
)
{
let
rows
=
await
this
.
db
.
execute
(
SELECT
EXISTS
(
SELECT
1
FROM
items
v
LEFT
JOIN
moz_bookmarks
b
ON
v
.
guid
=
b
.
guid
WHERE
v
.
needsMerge
AND
(
NOT
v
.
isDeleted
OR
b
.
guid
NOT
NULL
)
)
OR
EXISTS
(
WITH
RECURSIVE
{
LocalItemsSQLFragment
}
SELECT
1
FROM
localItems
WHERE
syncChangeCounter
>
0
)
OR
EXISTS
(
SELECT
1
FROM
moz_bookmarks_deleted
)
AS
hasChanges
)
;
return
!
!
rows
[
0
]
.
getResultByName
(
"
hasChanges
"
)
;
}
async
validLocalRoots
(
)
{
let
rows
=
await
this
.
db
.
execute
(
SELECT
EXISTS
(
SELECT
1
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
AND
parent
=
0
)
AND
(
SELECT
COUNT
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
guid
IN
(
{
PlacesUtils
.
bookmarks
.
userContentRoots
.
map
(
v
=
>
'
{
v
}
'
)
}
)
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
)
=
{
PlacesUtils
.
bookmarks
.
userContentRoots
.
length
}
AS
areValid
)
;
return
!
!
rows
[
0
]
.
getResultByName
(
"
areValid
"
)
;
}
async
fetchLocalChangeRecords
(
)
{
let
changeRecords
=
{
}
;
let
childRecordIdsByLocalParentId
=
new
Map
(
)
;
let
tagsByLocalId
=
new
Map
(
)
;
let
childGuidRows
=
await
this
.
db
.
execute
(
SELECT
parentId
guid
FROM
structureToUpload
ORDER
BY
parentId
position
)
;
await
Async
.
yieldingForEach
(
childGuidRows
row
=
>
{
let
localParentId
=
row
.
getResultByName
(
"
parentId
"
)
;
let
childRecordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
row
.
getResultByName
(
"
guid
"
)
)
;
let
childRecordIds
=
childRecordIdsByLocalParentId
.
get
(
localParentId
)
;
if
(
childRecordIds
)
{
childRecordIds
.
push
(
childRecordId
)
;
}
else
{
childRecordIdsByLocalParentId
.
set
(
localParentId
[
childRecordId
]
)
;
}
}
yieldState
)
;
let
tagRows
=
await
this
.
db
.
execute
(
SELECT
id
tag
FROM
tagsToUpload
)
;
await
Async
.
yieldingForEach
(
tagRows
row
=
>
{
let
localId
=
row
.
getResultByName
(
"
id
"
)
;
let
tag
=
row
.
getResultByName
(
"
tag
"
)
;
let
tags
=
tagsByLocalId
.
get
(
localId
)
;
if
(
tags
)
{
tags
.
push
(
tag
)
;
}
else
{
tagsByLocalId
.
set
(
localId
[
tag
]
)
;
}
}
yieldState
)
;
let
itemRows
=
await
this
.
db
.
execute
(
SELECT
id
syncChangeCounter
guid
isDeleted
type
isQuery
tagFolderName
keyword
url
IFNULL
(
title
"
"
)
AS
title
position
parentGuid
IFNULL
(
parentTitle
"
"
)
AS
parentTitle
dateAdded
FROM
itemsToUpload
)
;
await
Async
.
yieldingForEach
(
itemRows
row
=
>
{
let
syncChangeCounter
=
row
.
getResultByName
(
"
syncChangeCounter
"
)
;
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
recordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
guid
)
;
let
isDeleted
=
row
.
getResultByName
(
"
isDeleted
"
)
;
if
(
isDeleted
)
{
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
{
id
:
recordId
deleted
:
true
}
)
;
return
;
}
let
parentGuid
=
row
.
getResultByName
(
"
parentGuid
"
)
;
let
parentRecordId
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
parentGuid
)
;
let
type
=
row
.
getResultByName
(
"
type
"
)
;
switch
(
type
)
{
case
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
:
{
let
isQuery
=
row
.
getResultByName
(
"
isQuery
"
)
;
if
(
isQuery
)
{
let
queryCleartext
=
{
id
:
recordId
type
:
"
query
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
bmkUri
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
folderName
:
row
.
getResultByName
(
"
tagFolderName
"
)
|
|
undefined
}
;
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
queryCleartext
)
;
return
;
}
let
bookmarkCleartext
=
{
id
:
recordId
type
:
"
bookmark
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
bmkUri
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
}
;
let
keyword
=
row
.
getResultByName
(
"
keyword
"
)
;
if
(
keyword
)
{
bookmarkCleartext
.
keyword
=
keyword
;
}
let
localId
=
row
.
getResultByName
(
"
id
"
)
;
let
tags
=
tagsByLocalId
.
get
(
localId
)
;
if
(
tags
)
{
bookmarkCleartext
.
tags
=
tags
;
}
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
bookmarkCleartext
)
;
return
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
:
{
let
folderCleartext
=
{
id
:
recordId
type
:
"
folder
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
title
:
row
.
getResultByName
(
"
title
"
)
}
;
let
localId
=
row
.
getResultByName
(
"
id
"
)
;
let
childRecordIds
=
childRecordIdsByLocalParentId
.
get
(
localId
)
;
folderCleartext
.
children
=
childRecordIds
|
|
[
]
;
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
folderCleartext
)
;
return
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
:
{
let
separatorCleartext
=
{
id
:
recordId
type
:
"
separator
"
parentid
:
parentRecordId
hasDupe
:
true
parentName
:
row
.
getResultByName
(
"
parentTitle
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
|
|
undefined
pos
:
row
.
getResultByName
(
"
position
"
)
}
;
changeRecords
[
recordId
]
=
new
BookmarkChangeRecord
(
syncChangeCounter
separatorCleartext
)
;
return
;
}
default
:
throw
new
TypeError
(
"
Can
'
t
create
record
for
unknown
Places
item
"
)
;
}
}
yieldState
)
;
return
changeRecords
;
}
finalize
(
)
{
if
(
!
this
.
finalizePromise
)
{
this
.
finalizePromise
=
(
async
(
)
=
>
{
this
.
merger
.
finalize
(
)
;
await
this
.
db
.
close
(
)
;
this
.
finalizeAt
.
removeBlocker
(
this
.
finalizeBound
)
;
}
)
(
)
;
}
return
this
.
finalizePromise
;
}
}
this
.
SyncedBookmarksMirror
=
SyncedBookmarksMirror
;
SyncedBookmarksMirror
.
META_KEY
=
{
LAST_MODIFIED
:
"
collection
/
lastModified
"
SYNC_ID
:
"
collection
/
syncId
"
}
;
class
MergeError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
MergeError
"
;
}
}
SyncedBookmarksMirror
.
MergeError
=
MergeError
;
class
MergeConflictError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
MergeConflictError
"
;
}
}
SyncedBookmarksMirror
.
MergeConflictError
=
MergeConflictError
;
class
DatabaseCorruptError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
DatabaseCorruptError
"
;
}
}
function
isDatabaseCorrupt
(
error
)
{
if
(
error
instanceof
DatabaseCorruptError
)
{
return
true
;
}
if
(
error
.
errors
)
{
return
error
.
errors
.
some
(
error
=
>
error
instanceof
Ci
.
mozIStorageError
&
&
(
error
.
result
=
=
Ci
.
mozIStorageError
.
CORRUPT
|
|
error
.
result
=
=
Ci
.
mozIStorageError
.
NOTADB
)
)
;
}
return
false
;
}
async
function
attachAndInitMirrorDatabase
(
db
path
)
{
await
db
.
execute
(
ATTACH
:
path
AS
mirror
{
path
}
)
;
try
{
await
db
.
executeTransaction
(
async
function
(
)
{
let
currentSchemaVersion
=
await
db
.
getSchemaVersion
(
"
mirror
"
)
;
if
(
currentSchemaVersion
>
0
)
{
if
(
currentSchemaVersion
<
MIRROR_SCHEMA_VERSION
)
{
await
migrateMirrorSchema
(
db
currentSchemaVersion
)
;
}
}
else
{
await
initializeMirrorDatabase
(
db
)
;
}
await
db
.
setSchemaVersion
(
MIRROR_SCHEMA_VERSION
"
mirror
"
)
;
await
initializeTempMirrorEntities
(
db
)
;
}
)
;
}
catch
(
ex
)
{
await
db
.
execute
(
DETACH
mirror
)
;
throw
ex
;
}
}
async
function
migrateMirrorSchema
(
db
currentSchemaVersion
)
{
if
(
currentSchemaVersion
<
4
)
{
throw
new
DatabaseCorruptError
(
Can
'
t
migrate
from
schema
version
{
currentSchemaVersion
}
;
too
old
)
;
}
}
async
function
initializeMirrorDatabase
(
db
)
{
await
db
.
execute
(
CREATE
TABLE
mirror
.
meta
(
key
TEXT
PRIMARY
KEY
value
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
items
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
UNIQUE
NOT
NULL
/
*
The
"
parentid
"
from
the
record
.
*
/
parentGuid
TEXT
/
*
The
server
modified
time
in
milliseconds
.
*
/
serverModified
INTEGER
NOT
NULL
DEFAULT
0
needsMerge
BOOLEAN
NOT
NULL
DEFAULT
0
validity
INTEGER
NOT
NULL
DEFAULT
{
Ci
.
mozISyncedBookmarksMerger
.
VALIDITY_VALID
}
isDeleted
BOOLEAN
NOT
NULL
DEFAULT
0
kind
INTEGER
NOT
NULL
DEFAULT
-
1
/
*
The
creation
date
in
milliseconds
.
*
/
dateAdded
INTEGER
NOT
NULL
DEFAULT
0
title
TEXT
urlId
INTEGER
REFERENCES
urls
(
id
)
ON
DELETE
SET
NULL
keyword
TEXT
description
TEXT
loadInSidebar
BOOLEAN
smartBookmarkName
TEXT
feedURL
TEXT
siteURL
TEXT
)
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
structure
(
guid
TEXT
parentGuid
TEXT
REFERENCES
items
(
guid
)
ON
DELETE
CASCADE
position
INTEGER
NOT
NULL
PRIMARY
KEY
(
parentGuid
guid
)
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
urls
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
NOT
NULL
url
TEXT
NOT
NULL
hash
INTEGER
NOT
NULL
revHost
TEXT
NOT
NULL
)
)
;
await
db
.
execute
(
CREATE
TABLE
mirror
.
tags
(
itemId
INTEGER
NOT
NULL
REFERENCES
items
(
id
)
ON
DELETE
CASCADE
tag
TEXT
NOT
NULL
)
)
;
await
db
.
execute
(
CREATE
INDEX
mirror
.
urlHashes
ON
urls
(
hash
)
)
;
await
createMirrorRoots
(
db
)
;
}
async
function
createMirrorRoots
(
db
)
{
const
syncableRoots
=
[
{
guid
:
PlacesUtils
.
bookmarks
.
rootGuid
parentGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
position
:
-
1
needsMerge
:
false
}
.
.
.
PlacesUtils
.
bookmarks
.
userContentRoots
.
map
(
(
guid
position
)
=
>
{
return
{
guid
parentGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
position
needsMerge
:
true
}
;
}
)
]
;
for
(
let
{
guid
parentGuid
position
needsMerge
}
of
syncableRoots
)
{
await
db
.
executeCached
(
INSERT
INTO
items
(
guid
parentGuid
kind
needsMerge
)
VALUES
(
:
guid
:
parentGuid
:
kind
:
needsMerge
)
{
guid
parentGuid
kind
:
Ci
.
mozISyncedBookmarksMerger
.
KIND_FOLDER
needsMerge
}
)
;
await
db
.
executeCached
(
INSERT
INTO
structure
(
guid
parentGuid
position
)
VALUES
(
:
guid
:
parentGuid
:
position
)
{
guid
parentGuid
position
}
)
;
}
}
async
function
initializeTempMirrorEntities
(
db
)
{
await
db
.
execute
(
CREATE
TEMP
TABLE
mergeStates
(
mergedGuid
TEXT
PRIMARY
KEY
localGuid
TEXT
remoteGuid
TEXT
mergedParentGuid
TEXT
NOT
NULL
level
INTEGER
NOT
NULL
position
INTEGER
NOT
NULL
useRemote
BOOLEAN
NOT
NULL
/
*
Take
the
remote
state
when
merging
?
*
/
shouldUpload
BOOLEAN
NOT
NULL
/
*
Flag
the
item
for
upload
?
*
/
/
*
The
node
should
exist
on
at
least
one
side
.
*
/
CHECK
(
localGuid
NOT
NULL
OR
remoteGuid
NOT
NULL
)
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsToRemove
(
guid
TEXT
PRIMARY
KEY
localLevel
INTEGER
NOT
NULL
shouldUploadTombstone
BOOLEAN
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
noteItemRemoved
AFTER
INSERT
ON
itemsToRemove
BEGIN
/
*
Note
that
we
can
'
t
record
item
removed
notifications
in
the
"
removeLocalItems
"
trigger
because
SQLite
can
delete
rows
in
any
order
and
might
fire
the
trigger
for
a
removed
parent
before
its
children
.
*
/
INSERT
INTO
itemsRemoved
(
itemId
parentId
position
type
placeId
guid
parentGuid
level
)
SELECT
b
.
id
b
.
parent
b
.
position
b
.
type
b
.
fk
b
.
guid
p
.
guid
NEW
.
localLevel
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
guid
=
NEW
.
guid
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
removeLocalItems
AFTER
DELETE
ON
itemsToRemove
BEGIN
/
*
Flag
URL
frecency
for
recalculation
.
*
/
UPDATE
moz_places
SET
frecency
=
-
frecency
WHERE
id
=
(
SELECT
fk
FROM
moz_bookmarks
WHERE
guid
=
OLD
.
guid
)
AND
frecency
>
0
;
/
*
Trigger
frecency
updates
for
all
affected
origins
.
*
/
DELETE
FROM
moz_updateoriginsupdate_temp
;
/
*
Remove
annos
for
the
deleted
items
.
This
can
be
removed
in
bug
1460577
.
*
/
DELETE
FROM
moz_items_annos
WHERE
item_id
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
OLD
.
guid
)
;
/
*
Don
'
t
reupload
tombstones
for
items
that
are
already
deleted
on
the
server
.
*
/
DELETE
FROM
moz_bookmarks_deleted
WHERE
NOT
OLD
.
shouldUploadTombstone
AND
guid
=
OLD
.
guid
;
/
*
Upload
tombstones
for
non
-
syncable
items
.
We
can
remove
the
"
shouldUploadTombstone
"
check
and
persist
tombstones
unconditionally
in
bug
1343103
.
*
/
INSERT
OR
IGNORE
INTO
moz_bookmarks_deleted
(
guid
dateRemoved
)
SELECT
OLD
.
guid
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
WHERE
OLD
.
shouldUploadTombstone
;
/
*
Remove
the
item
from
Places
.
*
/
DELETE
FROM
moz_bookmarks
WHERE
guid
=
OLD
.
guid
;
/
*
Flag
applied
deletions
as
merged
.
*
/
UPDATE
items
SET
needsMerge
=
0
WHERE
needsMerge
AND
guid
=
OLD
.
guid
AND
/
*
Don
'
t
flag
tombstones
for
items
that
don
'
t
exist
in
the
local
tree
.
This
can
be
removed
once
we
persist
tombstones
in
bug
1343103
.
*
/
(
NOT
isDeleted
OR
OLD
.
localLevel
>
-
1
)
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
VIEW
itemsToMerge
(
localId
localGuid
remoteId
remoteGuid
mergedGuid
useRemote
shouldUpload
newLevel
newType
newDateAddedMicroseconds
newTitle
oldPlaceId
newPlaceId
newKeyword
)
AS
SELECT
b
.
id
b
.
guid
v
.
id
v
.
guid
r
.
mergedGuid
r
.
useRemote
r
.
shouldUpload
r
.
level
(
CASE
WHEN
v
.
kind
IN
(
{
[
Ci
.
mozISyncedBookmarksMerger
.
KIND_BOOKMARK
Ci
.
mozISyncedBookmarksMerger
.
KIND_QUERY
]
.
join
(
"
"
)
}
)
THEN
{
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
}
WHEN
v
.
kind
IN
(
{
[
Ci
.
mozISyncedBookmarksMerger
.
KIND_FOLDER
Ci
.
mozISyncedBookmarksMerger
.
KIND_LIVEMARK
]
.
join
(
"
"
)
}
)
THEN
{
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
ELSE
{
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
}
END
)
/
*
Take
the
older
creation
date
.
"
b
.
dateAdded
"
is
in
microseconds
;
"
v
.
dateAdded
"
is
in
milliseconds
.
*
/
(
CASE
WHEN
b
.
dateAdded
/
1000
<
v
.
dateAdded
THEN
b
.
dateAdded
ELSE
v
.
dateAdded
*
1000
END
)
v
.
title
h
.
id
(
SELECT
n
.
id
FROM
moz_places
n
WHERE
n
.
url_hash
=
u
.
hash
AND
n
.
url
=
u
.
url
)
v
.
keyword
FROM
mergeStates
r
LEFT
JOIN
items
v
ON
v
.
guid
=
r
.
remoteGuid
LEFT
JOIN
moz_bookmarks
b
ON
b
.
guid
=
r
.
localGuid
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
LEFT
JOIN
urls
u
ON
u
.
id
=
v
.
urlId
WHERE
r
.
mergedGuid
<
>
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
updateGuidsAndSyncFlags
INSTEAD
OF
DELETE
ON
itemsToMerge
BEGIN
UPDATE
moz_bookmarks
SET
/
*
We
update
GUIDs
here
instead
of
in
the
"
updateExistingLocalItems
"
trigger
because
deduped
items
where
we
'
re
keeping
the
local
value
state
won
'
t
have
"
useRemote
"
set
.
*
/
guid
=
OLD
.
mergedGuid
syncStatus
=
CASE
WHEN
OLD
.
useRemote
THEN
{
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
ELSE
syncStatus
END
/
*
Flag
updated
local
items
and
new
structure
for
upload
.
*
/
syncChangeCounter
=
OLD
.
shouldUpload
lastModified
=
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
WHERE
id
=
OLD
.
localId
;
/
*
Record
item
changed
notifications
for
the
updated
GUIDs
.
*
/
INSERT
INTO
guidsChanged
(
itemId
oldGuid
level
)
SELECT
OLD
.
localId
OLD
.
localGuid
OLD
.
newLevel
WHERE
OLD
.
localGuid
<
>
OLD
.
mergedGuid
;
/
*
Drop
local
tombstones
for
revived
remote
items
.
*
/
DELETE
FROM
moz_bookmarks_deleted
WHERE
guid
IN
(
OLD
.
localGuid
OLD
.
remoteGuid
)
;
/
*
Flag
the
remote
item
as
merged
.
*
/
UPDATE
items
SET
needsMerge
=
0
WHERE
needsMerge
AND
guid
IN
(
OLD
.
remoteGuid
OLD
.
localGuid
)
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
updateLocalItems
INSTEAD
OF
DELETE
ON
itemsToMerge
WHEN
OLD
.
useRemote
BEGIN
/
*
Record
an
item
added
notification
for
the
new
item
.
*
/
INSERT
INTO
itemsAdded
(
guid
keywordChanged
level
)
SELECT
OLD
.
mergedGuid
OLD
.
newKeyword
NOT
NULL
OR
EXISTS
(
SELECT
1
FROM
moz_keywords
WHERE
place_id
=
OLD
.
newPlaceId
OR
keyword
=
OLD
.
newKeyword
)
OLD
.
newLevel
WHERE
OLD
.
localId
IS
NULL
;
/
*
Record
an
item
changed
notification
for
the
existing
item
.
*
/
INSERT
INTO
itemsChanged
(
itemId
oldTitle
oldPlaceId
keywordChanged
level
)
SELECT
id
title
OLD
.
oldPlaceId
OLD
.
newKeyword
NOT
NULL
OR
EXISTS
(
SELECT
1
FROM
moz_keywords
WHERE
place_id
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
OR
keyword
=
OLD
.
newKeyword
)
OLD
.
newLevel
FROM
moz_bookmarks
WHERE
OLD
.
localId
NOT
NULL
AND
id
=
OLD
.
localId
;
/
*
Sync
associates
keywords
with
bookmarks
and
doesn
'
t
sync
POST
data
;
Places
associates
keywords
with
(
URL
POST
data
)
pairs
and
multiple
bookmarks
may
have
the
same
URL
.
For
consistency
(
bug
1328737
)
we
reupload
all
items
with
the
old
URL
new
URL
and
new
keyword
.
Note
that
we
intentionally
use
"
k
.
place_id
IN
(
.
.
.
)
"
instead
of
"
b
.
fk
=
OLD
.
newPlaceId
OR
fk
IN
(
.
.
.
)
"
in
the
WHERE
clause
because
we
only
want
to
reupload
items
with
keywords
.
*
/
INSERT
OR
IGNORE
INTO
relatedIdsToReupload
(
id
)
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
moz_keywords
k
ON
k
.
place_id
=
b
.
fk
WHERE
(
b
.
id
<
>
OLD
.
localId
OR
OLD
.
localId
IS
NULL
)
AND
(
k
.
place_id
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
OR
k
.
keyword
=
OLD
.
newKeyword
)
;
/
*
Remove
all
keywords
from
the
old
and
new
URLs
and
remove
the
new
keyword
from
all
existing
URLs
.
*
/
DELETE
FROM
moz_keywords
WHERE
place_id
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
OR
keyword
=
OLD
.
newKeyword
;
/
*
Remove
existing
tags
.
*
/
DELETE
FROM
localTags
WHERE
placeId
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
;
/
*
Insert
the
new
item
using
"
-
1
"
as
the
placeholder
parent
and
position
.
We
'
ll
update
these
later
in
the
"
updateLocalStructure
"
trigger
.
*
/
INSERT
INTO
moz_bookmarks
(
id
guid
parent
position
type
fk
title
dateAdded
lastModified
syncStatus
syncChangeCounter
)
VALUES
(
OLD
.
localId
OLD
.
mergedGuid
-
1
-
1
OLD
.
newType
OLD
.
newPlaceId
OLD
.
newTitle
OLD
.
newDateAddedMicroseconds
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
{
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
OLD
.
shouldUpload
)
ON
CONFLICT
(
id
)
DO
UPDATE
SET
title
=
excluded
.
title
dateAdded
=
excluded
.
dateAdded
lastModified
=
excluded
.
lastModified
/
*
It
'
s
important
that
we
update
the
URL
*
after
*
removing
old
keywords
and
*
before
*
inserting
new
ones
so
that
the
above
DELETEs
select
the
correct
affected
items
.
*
/
fk
=
excluded
.
fk
;
/
*
Recalculate
frecency
.
*
/
UPDATE
moz_places
SET
frecency
=
-
frecency
WHERE
OLD
.
oldPlaceId
<
>
OLD
.
newPlaceId
AND
id
IN
(
OLD
.
oldPlaceId
OLD
.
newPlaceId
)
AND
frecency
>
0
;
/
*
Trigger
frecency
updates
for
all
affected
origins
.
*
/
DELETE
FROM
moz_updateoriginsupdate_temp
;
/
*
Insert
a
new
keyword
for
the
new
URL
if
one
is
set
.
*
/
INSERT
OR
IGNORE
INTO
moz_keywords
(
keyword
place_id
post_data
)
SELECT
OLD
.
newKeyword
OLD
.
newPlaceId
'
'
WHERE
OLD
.
newKeyword
NOT
NULL
;
/
*
Insert
new
tags
for
the
new
URL
.
*
/
INSERT
INTO
localTags
(
tag
placeId
)
SELECT
t
.
tag
OLD
.
newPlaceId
FROM
tags
t
WHERE
t
.
itemId
=
OLD
.
remoteId
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
VIEW
structureToMerge
(
localId
oldParentId
newParentId
oldPosition
newPosition
newLevel
)
AS
SELECT
b
.
id
b
.
parent
p
.
id
b
.
position
r
.
position
r
.
level
FROM
moz_bookmarks
b
JOIN
mergeStates
r
ON
r
.
mergedGuid
=
b
.
guid
JOIN
moz_bookmarks
p
ON
p
.
guid
=
r
.
mergedParentGuid
/
*
Don
'
t
reposition
roots
since
we
never
upload
the
Places
root
and
our
merged
tree
doesn
'
t
have
a
tags
root
.
*
/
WHERE
'
{
PlacesUtils
.
bookmarks
.
rootGuid
}
'
NOT
IN
(
r
.
mergedGuid
r
.
mergedParentGuid
)
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
updateLocalStructure
INSTEAD
OF
DELETE
ON
structureToMerge
BEGIN
UPDATE
moz_bookmarks
SET
parent
=
OLD
.
newParentId
WHERE
id
=
OLD
.
localId
AND
parent
<
>
OLD
.
newParentId
;
UPDATE
moz_bookmarks
SET
position
=
OLD
.
newPosition
WHERE
id
=
OLD
.
localId
AND
position
<
>
OLD
.
newPosition
;
/
*
Record
observer
notifications
for
moved
items
.
We
ignore
items
that
didn
'
t
move
and
items
with
placeholder
parents
and
positions
of
"
-
1
"
since
they
'
re
new
.
*
/
INSERT
INTO
itemsMoved
(
itemId
oldParentId
oldParentGuid
oldPosition
level
)
SELECT
OLD
.
localId
OLD
.
oldParentId
p
.
guid
OLD
.
oldPosition
OLD
.
newLevel
FROM
moz_bookmarks
p
WHERE
p
.
id
=
OLD
.
oldParentId
AND
-
1
NOT
IN
(
OLD
.
oldParentId
OLD
.
oldPosition
)
AND
(
OLD
.
oldParentId
<
>
OLD
.
newParentId
OR
OLD
.
oldPosition
<
>
OLD
.
newPosition
)
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
VIEW
localTags
(
tagEntryId
tagEntryGuid
tagFolderId
tagFolderGuid
tagEntryPosition
tagEntryType
tag
placeId
)
AS
SELECT
b
.
id
b
.
guid
p
.
id
p
.
guid
b
.
position
b
.
type
p
.
title
b
.
fk
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
moz_bookmarks
r
ON
r
.
id
=
p
.
parent
WHERE
b
.
type
=
{
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
}
AND
r
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
untagLocalPlace
INSTEAD
OF
DELETE
ON
localTags
BEGIN
/
*
Record
an
item
removed
notification
for
the
tag
entry
.
*
/
INSERT
INTO
itemsRemoved
(
itemId
parentId
position
type
placeId
guid
parentGuid
isUntagging
)
VALUES
(
OLD
.
tagEntryId
OLD
.
tagFolderId
OLD
.
tagEntryPosition
OLD
.
tagEntryType
OLD
.
placeId
OLD
.
tagEntryGuid
OLD
.
tagFolderGuid
1
)
;
DELETE
FROM
moz_bookmarks
WHERE
id
=
OLD
.
tagEntryId
;
/
*
Fix
the
positions
of
the
sibling
tag
entries
.
*
/
UPDATE
moz_bookmarks
SET
position
=
position
-
1
WHERE
parent
=
OLD
.
tagFolderId
AND
position
>
OLD
.
tagEntryPosition
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
tagLocalPlace
INSTEAD
OF
INSERT
ON
localTags
BEGIN
/
*
Ensure
the
tag
folder
exists
.
*
/
INSERT
OR
IGNORE
INTO
moz_bookmarks
(
guid
parent
position
type
title
dateAdded
lastModified
)
VALUES
(
IFNULL
(
(
SELECT
b
.
guid
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
title
=
NEW
.
tag
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
GENERATE_GUID
(
)
)
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
(
SELECT
COUNT
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
{
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
NEW
.
tag
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
)
;
/
*
Record
an
item
added
notification
if
we
created
a
tag
folder
.
"
CHANGES
(
)
"
returns
the
number
of
rows
affected
by
the
INSERT
above
:
1
if
we
created
the
folder
or
0
if
the
folder
already
existed
.
*
/
INSERT
INTO
itemsAdded
(
guid
isTagging
)
SELECT
b
.
guid
1
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
CHANGES
(
)
>
0
AND
b
.
title
=
NEW
.
tag
AND
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
;
/
*
Add
a
tag
entry
for
the
URL
under
the
tag
folder
.
Omitting
the
place
ID
creates
a
tag
folder
without
tagging
the
URL
.
*
/
INSERT
OR
IGNORE
INTO
moz_bookmarks
(
guid
parent
position
type
fk
dateAdded
lastModified
)
SELECT
GENERATE_GUID
(
)
(
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
p
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
AND
b
.
title
=
NEW
.
tag
)
(
SELECT
COUNT
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
moz_bookmarks
r
ON
r
.
id
=
p
.
parent
WHERE
p
.
title
=
NEW
.
tag
AND
r
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
)
{
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
}
NEW
.
placeId
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
WHERE
NEW
.
placeId
NOT
NULL
;
/
*
Record
an
item
added
notification
for
the
tag
entry
.
*
/
INSERT
INTO
itemsAdded
(
guid
isTagging
)
SELECT
b
.
guid
1
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
moz_bookmarks
r
ON
r
.
id
=
p
.
parent
WHERE
b
.
fk
=
NEW
.
placeId
AND
p
.
title
=
NEW
.
tag
AND
r
.
guid
=
'
{
PlacesUtils
.
bookmarks
.
tagsGuid
}
'
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsAdded
(
guid
TEXT
PRIMARY
KEY
isTagging
BOOLEAN
NOT
NULL
DEFAULT
0
keywordChanged
BOOLEAN
NOT
NULL
DEFAULT
0
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
guidsChanged
(
itemId
INTEGER
NOT
NULL
oldGuid
TEXT
NOT
NULL
level
INTEGER
NOT
NULL
DEFAULT
-
1
PRIMARY
KEY
(
itemId
oldGuid
)
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsChanged
(
itemId
INTEGER
PRIMARY
KEY
oldTitle
TEXT
oldPlaceId
INTEGER
keywordChanged
BOOLEAN
NOT
NULL
DEFAULT
0
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsMoved
(
itemId
INTEGER
PRIMARY
KEY
oldParentId
INTEGER
NOT
NULL
oldParentGuid
TEXT
NOT
NULL
oldPosition
INTEGER
NOT
NULL
level
INTEGER
NOT
NULL
DEFAULT
-
1
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsRemoved
(
guid
TEXT
PRIMARY
KEY
itemId
INTEGER
NOT
NULL
parentId
INTEGER
NOT
NULL
position
INTEGER
NOT
NULL
type
INTEGER
NOT
NULL
placeId
INTEGER
parentGuid
TEXT
NOT
NULL
/
*
We
record
the
original
level
of
the
removed
item
in
the
tree
so
that
we
can
notify
children
before
parents
.
*
/
level
INTEGER
NOT
NULL
DEFAULT
-
1
isUntagging
BOOLEAN
NOT
NULL
DEFAULT
0
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
idsToWeaklyUpload
(
id
INTEGER
PRIMARY
KEY
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
relatedIdsToReupload
(
id
INTEGER
PRIMARY
KEY
)
)
;
await
db
.
execute
(
CREATE
TEMP
TRIGGER
reuploadIds
AFTER
DELETE
ON
relatedIdsToReupload
BEGIN
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
id
=
OLD
.
id
;
END
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
itemsToUpload
(
id
INTEGER
PRIMARY
KEY
guid
TEXT
UNIQUE
NOT
NULL
syncChangeCounter
INTEGER
NOT
NULL
isDeleted
BOOLEAN
NOT
NULL
DEFAULT
0
parentGuid
TEXT
parentTitle
TEXT
dateAdded
INTEGER
/
*
In
milliseconds
.
*
/
type
INTEGER
title
TEXT
placeId
INTEGER
isQuery
BOOLEAN
NOT
NULL
DEFAULT
0
url
TEXT
tagFolderName
TEXT
keyword
TEXT
position
INTEGER
)
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
structureToUpload
(
guid
TEXT
PRIMARY
KEY
parentId
INTEGER
NOT
NULL
REFERENCES
itemsToUpload
(
id
)
ON
DELETE
CASCADE
position
INTEGER
NOT
NULL
)
WITHOUT
ROWID
)
;
await
db
.
execute
(
CREATE
TEMP
TABLE
tagsToUpload
(
id
INTEGER
REFERENCES
itemsToUpload
(
id
)
ON
DELETE
CASCADE
tag
TEXT
PRIMARY
KEY
(
id
tag
)
)
WITHOUT
ROWID
)
;
}
async
function
resetMirror
(
db
)
{
await
db
.
execute
(
DELETE
FROM
meta
)
;
await
db
.
execute
(
DELETE
FROM
structure
)
;
await
db
.
execute
(
DELETE
FROM
items
)
;
await
db
.
execute
(
DELETE
FROM
urls
)
;
await
createMirrorRoots
(
db
)
;
}
function
determineServerModified
(
record
)
{
return
Math
.
max
(
record
.
modified
*
1000
0
)
|
|
0
;
}
function
determineDateAdded
(
record
)
{
let
serverModified
=
determineServerModified
(
record
)
;
return
PlacesSyncUtils
.
bookmarks
.
ratchetTimestampBackwards
(
record
.
dateAdded
serverModified
)
;
}
function
validateTitle
(
rawTitle
)
{
if
(
typeof
rawTitle
!
=
"
string
"
|
|
!
rawTitle
)
{
return
null
;
}
return
rawTitle
.
slice
(
0
DB_TITLE_LENGTH_MAX
)
;
}
function
validateURL
(
rawURL
)
{
if
(
typeof
rawURL
!
=
"
string
"
|
|
rawURL
.
length
>
DB_URL_LENGTH_MAX
)
{
return
null
;
}
let
url
=
null
;
try
{
url
=
new
URL
(
rawURL
)
;
}
catch
(
ex
)
{
}
return
url
;
}
function
validateKeyword
(
rawKeyword
)
{
if
(
typeof
rawKeyword
!
=
"
string
"
)
{
return
null
;
}
let
keyword
=
rawKeyword
.
trim
(
)
;
return
keyword
?
keyword
.
toLowerCase
(
)
:
null
;
}
function
validateTag
(
rawTag
)
{
if
(
typeof
rawTag
!
=
"
string
"
)
{
return
null
;
}
let
tag
=
rawTag
.
trim
(
)
;
if
(
!
tag
|
|
tag
.
length
>
PlacesUtils
.
bookmarks
.
MAX_TAG_LENGTH
)
{
return
null
;
}
return
tag
;
}
async
function
withTiming
(
name
func
recordTiming
)
{
MirrorLog
.
debug
(
name
)
;
let
startTime
=
Cu
.
now
(
)
;
let
result
=
await
func
(
)
;
let
elapsedTime
=
Cu
.
now
(
)
-
startTime
;
MirrorLog
.
trace
(
{
name
}
took
{
elapsedTime
.
toFixed
(
3
)
}
ms
)
;
if
(
typeof
recordTiming
=
=
"
function
"
)
{
recordTiming
(
elapsedTime
)
;
}
return
result
;
}
class
BookmarkObserverRecorder
{
constructor
(
db
{
maxFrecenciesToRecalculate
}
)
{
this
.
db
=
db
;
this
.
maxFrecenciesToRecalculate
=
maxFrecenciesToRecalculate
;
this
.
bookmarkObserverNotifications
=
[
]
;
this
.
shouldInvalidateKeywords
=
false
;
}
async
notifyAll
(
)
{
await
this
.
noteAllChanges
(
)
;
if
(
this
.
shouldInvalidateKeywords
)
{
await
PlacesUtils
.
keywords
.
invalidateCachedKeywords
(
)
;
}
await
this
.
notifyBookmarkObservers
(
)
;
await
updateFrecencies
(
this
.
db
this
.
maxFrecenciesToRecalculate
)
;
}
async
noteAllChanges
(
)
{
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
removed
items
"
)
;
let
removedItemRows
=
await
this
.
db
.
execute
(
SELECT
v
.
itemId
AS
id
v
.
parentId
v
.
parentGuid
v
.
position
v
.
type
h
.
url
v
.
guid
v
.
isUntagging
FROM
itemsRemoved
v
LEFT
JOIN
moz_places
h
ON
h
.
id
=
v
.
placeId
ORDER
BY
v
.
level
DESC
v
.
parentId
v
.
position
)
;
await
Async
.
yieldingForEach
(
removedItemRows
row
=
>
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
position
:
row
.
getResultByName
(
"
position
"
)
type
:
row
.
getResultByName
(
"
type
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
isUntagging
:
row
.
getResultByName
(
"
isUntagging
"
)
}
;
this
.
noteItemRemoved
(
info
)
;
}
yieldState
)
;
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
changed
GUIDs
"
)
;
let
changedGuidRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
lastModified
b
.
type
b
.
guid
AS
newGuid
c
.
oldGuid
p
.
id
AS
parentId
p
.
guid
AS
parentGuid
FROM
guidsChanged
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
ORDER
BY
c
.
level
p
.
id
b
.
position
)
;
await
Async
.
yieldingForEach
(
changedGuidRows
row
=
>
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
lastModified
:
row
.
getResultByName
(
"
lastModified
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newGuid
:
row
.
getResultByName
(
"
newGuid
"
)
oldGuid
:
row
.
getResultByName
(
"
oldGuid
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
}
;
this
.
noteGuidChanged
(
info
)
;
}
yieldState
)
;
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
new
items
"
)
;
let
newItemRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
p
.
id
AS
parentId
b
.
position
b
.
type
h
.
url
IFNULL
(
b
.
title
"
"
)
AS
title
b
.
dateAdded
b
.
guid
p
.
guid
AS
parentGuid
n
.
isTagging
FROM
itemsAdded
n
JOIN
moz_bookmarks
b
ON
b
.
guid
=
n
.
guid
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
ORDER
BY
n
.
level
p
.
id
b
.
position
)
;
await
Async
.
yieldingForEach
(
newItemRows
row
=
>
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
position
:
row
.
getResultByName
(
"
position
"
)
type
:
row
.
getResultByName
(
"
type
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
dateAdded
:
row
.
getResultByName
(
"
dateAdded
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
isTagging
:
row
.
getResultByName
(
"
isTagging
"
)
}
;
this
.
noteItemAdded
(
info
)
;
}
yieldState
)
;
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
moved
items
"
)
;
let
movedItemRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
guid
b
.
type
p
.
id
AS
newParentId
c
.
oldParentId
p
.
guid
AS
newParentGuid
c
.
oldParentGuid
b
.
position
AS
newPosition
c
.
oldPosition
h
.
url
FROM
itemsMoved
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
ORDER
BY
c
.
level
newParentId
newPosition
)
;
await
Async
.
yieldingForEach
(
movedItemRows
row
=
>
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newParentId
:
row
.
getResultByName
(
"
newParentId
"
)
oldParentId
:
row
.
getResultByName
(
"
oldParentId
"
)
newParentGuid
:
row
.
getResultByName
(
"
newParentGuid
"
)
oldParentGuid
:
row
.
getResultByName
(
"
oldParentGuid
"
)
newPosition
:
row
.
getResultByName
(
"
newPosition
"
)
oldPosition
:
row
.
getResultByName
(
"
oldPosition
"
)
urlHref
:
row
.
getResultByName
(
"
url
"
)
}
;
this
.
noteItemMoved
(
info
)
;
}
yieldState
)
;
MirrorLog
.
trace
(
"
Recording
observer
notifications
for
changed
items
"
)
;
let
changedItemRows
=
await
this
.
db
.
execute
(
SELECT
b
.
id
b
.
guid
b
.
lastModified
b
.
type
IFNULL
(
b
.
title
"
"
)
AS
newTitle
IFNULL
(
c
.
oldTitle
"
"
)
AS
oldTitle
h
.
url
AS
newURL
i
.
url
AS
oldURL
p
.
id
AS
parentId
p
.
guid
AS
parentGuid
FROM
itemsChanged
c
JOIN
moz_bookmarks
b
ON
b
.
id
=
c
.
itemId
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
LEFT
JOIN
moz_places
i
ON
i
.
id
=
c
.
oldPlaceId
ORDER
BY
c
.
level
p
.
id
b
.
position
)
;
await
Async
.
yieldingForEach
(
changedItemRows
row
=
>
{
let
info
=
{
id
:
row
.
getResultByName
(
"
id
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
lastModified
:
row
.
getResultByName
(
"
lastModified
"
)
type
:
row
.
getResultByName
(
"
type
"
)
newTitle
:
row
.
getResultByName
(
"
newTitle
"
)
oldTitle
:
row
.
getResultByName
(
"
oldTitle
"
)
newURLHref
:
row
.
getResultByName
(
"
newURL
"
)
oldURLHref
:
row
.
getResultByName
(
"
oldURL
"
)
parentId
:
row
.
getResultByName
(
"
parentId
"
)
parentGuid
:
row
.
getResultByName
(
"
parentGuid
"
)
}
;
this
.
noteItemChanged
(
info
)
;
}
yieldState
)
;
MirrorLog
.
trace
(
"
Recording
notifications
for
changed
keywords
"
)
;
let
keywordsChangedRows
=
await
this
.
db
.
execute
(
SELECT
EXISTS
(
SELECT
1
FROM
itemsAdded
WHERE
keywordChanged
)
OR
EXISTS
(
SELECT
1
FROM
itemsChanged
WHERE
keywordChanged
)
AS
keywordsChanged
)
;
this
.
shouldInvalidateKeywords
=
!
!
keywordsChangedRows
[
0
]
.
getResultByName
(
"
keywordsChanged
"
)
;
}
noteItemAdded
(
info
)
{
this
.
bookmarkObserverNotifications
.
push
(
new
PlacesBookmarkAddition
(
{
id
:
info
.
id
parentId
:
info
.
parentId
index
:
info
.
position
url
:
info
.
urlHref
|
|
"
"
title
:
info
.
title
dateAdded
:
info
.
dateAdded
guid
:
info
.
guid
parentGuid
:
info
.
parentGuid
source
:
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
itemType
:
info
.
type
isTagging
:
info
.
isTagging
}
)
)
;
}
noteGuidChanged
(
info
)
{
PlacesUtils
.
invalidateCachedGuidFor
(
info
.
id
)
;
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemChanged
"
isTagging
:
false
args
:
[
info
.
id
"
guid
"
false
info
.
newGuid
info
.
lastModified
info
.
type
info
.
parentId
info
.
newGuid
info
.
parentGuid
info
.
oldGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
noteItemMoved
(
info
)
{
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemMoved
"
isTagging
:
false
args
:
[
info
.
id
info
.
oldParentId
info
.
oldPosition
info
.
newParentId
info
.
newPosition
info
.
type
info
.
guid
info
.
oldParentGuid
info
.
newParentGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
info
.
urlHref
]
}
)
;
}
noteItemChanged
(
info
)
{
if
(
info
.
oldTitle
!
=
info
.
newTitle
)
{
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemChanged
"
isTagging
:
false
args
:
[
info
.
id
"
title
"
false
info
.
newTitle
info
.
lastModified
info
.
type
info
.
parentId
info
.
guid
info
.
parentGuid
info
.
oldTitle
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
if
(
info
.
oldURLHref
!
=
info
.
newURLHref
)
{
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemChanged
"
isTagging
:
false
args
:
[
info
.
id
"
uri
"
false
info
.
newURLHref
info
.
lastModified
info
.
type
info
.
parentId
info
.
guid
info
.
parentGuid
info
.
oldURLHref
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
}
noteItemRemoved
(
info
)
{
let
uri
=
info
.
urlHref
?
Services
.
io
.
newURI
(
info
.
urlHref
)
:
null
;
this
.
bookmarkObserverNotifications
.
push
(
{
name
:
"
onItemRemoved
"
isTagging
:
info
.
isUntagging
args
:
[
info
.
id
info
.
parentId
info
.
position
info
.
type
uri
info
.
guid
info
.
parentGuid
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
}
)
;
}
async
notifyBookmarkObservers
(
)
{
MirrorLog
.
trace
(
"
Notifying
bookmark
observers
"
)
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
for
(
let
observer
of
observers
)
{
this
.
notifyObserver
(
observer
"
onBeginUpdateBatch
"
)
;
}
await
Async
.
yieldingForEach
(
this
.
bookmarkObserverNotifications
info
=
>
{
if
(
info
instanceof
PlacesEvent
)
{
PlacesObservers
.
notifyListeners
(
[
info
]
)
;
}
else
{
for
(
let
observer
of
observers
)
{
if
(
info
.
isTagging
&
&
observer
.
skipTags
)
{
return
;
}
this
.
notifyObserver
(
observer
info
.
name
info
.
args
)
;
}
}
}
yieldState
)
;
for
(
let
observer
of
observers
)
{
this
.
notifyObserver
(
observer
"
onEndUpdateBatch
"
)
;
}
}
notifyObserver
(
observer
notification
args
=
[
]
)
{
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
MirrorLog
.
warn
(
"
Error
notifying
observer
"
ex
)
;
}
}
}
class
BookmarkChangeRecord
{
constructor
(
syncChangeCounter
cleartext
)
{
this
.
tombstone
=
cleartext
.
deleted
=
=
=
true
;
this
.
counter
=
syncChangeCounter
;
this
.
cleartext
=
cleartext
;
this
.
synced
=
false
;
}
}
async
function
updateFrecencies
(
db
limit
)
{
MirrorLog
.
trace
(
"
Recalculating
frecencies
for
new
URLs
"
)
;
await
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
CALCULATE_FRECENCY
(
id
)
WHERE
id
IN
(
SELECT
id
FROM
moz_places
WHERE
frecency
<
0
ORDER
BY
frecency
ASC
LIMIT
:
limit
)
{
limit
}
)
;
await
db
.
execute
(
DELETE
FROM
moz_updateoriginsupdate_temp
)
;
}
