#
include
"
Shutdown
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
SimpleEnumerator
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIProperty
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIWritablePropertyBag
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
Database
.
h
"
namespace
mozilla
{
namespace
places
{
uint16_t
PlacesShutdownBlocker
:
:
sCounter
=
0
;
Atomic
<
bool
>
PlacesShutdownBlocker
:
:
sIsStarted
(
false
)
;
PlacesShutdownBlocker
:
:
PlacesShutdownBlocker
(
const
nsString
&
aName
)
:
mName
(
aName
)
mState
(
NOT_STARTED
)
mCounter
(
sCounter
+
+
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mCounter
>
1
)
{
mName
.
AppendInt
(
mCounter
)
;
}
nsCOMPtr
<
nsIAsyncShutdownService
>
asyncShutdown
=
services
:
:
GetAsyncShutdownService
(
)
;
MOZ_ASSERT
(
asyncShutdown
)
;
if
(
asyncShutdown
)
{
nsCOMPtr
<
nsIAsyncShutdownBarrier
>
barrier
;
nsresult
rv
=
asyncShutdown
-
>
MakeBarrier
(
mName
getter_AddRefs
(
barrier
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
barrier
)
{
mBarrier
=
new
nsMainThreadPtrHolder
<
nsIAsyncShutdownBarrier
>
(
"
PlacesShutdownBlocker
:
:
mBarrier
"
barrier
)
;
}
}
}
NS_IMETHODIMP
PlacesShutdownBlocker
:
:
GetName
(
nsAString
&
aName
)
{
aName
=
mName
;
return
NS_OK
;
}
NS_IMETHODIMP
PlacesShutdownBlocker
:
:
GetState
(
nsIPropertyBag
*
*
_state
)
{
NS_ENSURE_ARG_POINTER
(
_state
)
;
nsCOMPtr
<
nsIWritablePropertyBag
>
bag
=
do_CreateInstance
(
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
)
;
NS_ENSURE_TRUE
(
bag
NS_ERROR_OUT_OF_MEMORY
)
;
RefPtr
<
nsVariant
>
progress
=
new
nsVariant
(
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
progress
-
>
SetAsUint8
(
mState
)
)
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
bag
-
>
SetProperty
(
u
"
PlacesShutdownProgress
"
_ns
progress
)
)
)
;
if
(
mBarrier
)
{
nsCOMPtr
<
nsIPropertyBag
>
barrierState
;
if
(
NS_SUCCEEDED
(
mBarrier
-
>
GetState
(
getter_AddRefs
(
barrierState
)
)
)
&
&
barrierState
)
{
nsCOMPtr
<
nsISimpleEnumerator
>
enumerator
;
if
(
NS_SUCCEEDED
(
barrierState
-
>
GetEnumerator
(
getter_AddRefs
(
enumerator
)
)
)
&
&
enumerator
)
{
for
(
const
auto
&
property
:
SimpleEnumerator
<
nsIProperty
>
(
enumerator
)
)
{
nsAutoString
prefix
(
u
"
Barrier
:
"
_ns
)
;
nsAutoString
name
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
property
-
>
GetName
(
name
)
)
)
;
prefix
.
Append
(
name
)
;
nsCOMPtr
<
nsIVariant
>
value
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
property
-
>
GetValue
(
getter_AddRefs
(
value
)
)
)
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
bag
-
>
SetProperty
(
prefix
value
)
)
)
;
}
}
}
}
bag
.
forget
(
_state
)
;
return
NS_OK
;
}
already_AddRefed
<
nsIAsyncShutdownClient
>
PlacesShutdownBlocker
:
:
GetClient
(
)
{
nsCOMPtr
<
nsIAsyncShutdownClient
>
client
;
if
(
mBarrier
)
{
MOZ_ALWAYS_SUCCEEDS
(
mBarrier
-
>
GetClient
(
getter_AddRefs
(
client
)
)
)
;
}
return
client
.
forget
(
)
;
}
NS_IMETHODIMP
PlacesShutdownBlocker
:
:
BlockShutdown
(
nsIAsyncShutdownClient
*
aParentClient
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mParentClient
=
new
nsMainThreadPtrHolder
<
nsIAsyncShutdownClient
>
(
"
ClientsShutdownBlocker
:
:
mParentClient
"
aParentClient
)
;
mState
=
RECEIVED_BLOCK_SHUTDOWN
;
if
(
NS_WARN_IF
(
!
mBarrier
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
MOZ_ALWAYS_SUCCEEDS
(
mBarrier
-
>
Wait
(
this
)
)
;
mState
=
CALLED_WAIT_CLIENTS
;
return
NS_OK
;
}
NS_IMETHODIMP
PlacesShutdownBlocker
:
:
Done
(
)
{
MOZ_ASSERT
(
false
"
Should
always
be
overridden
"
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
PlacesShutdownBlocker
nsIAsyncShutdownBlocker
nsIAsyncShutdownCompletionCallback
)
ClientsShutdownBlocker
:
:
ClientsShutdownBlocker
(
)
:
PlacesShutdownBlocker
(
u
"
Places
Clients
shutdown
"
_ns
)
{
}
NS_IMETHODIMP
ClientsShutdownBlocker
:
:
Done
(
)
{
mState
=
RECEIVED_DONE
;
if
(
mParentClient
)
{
nsresult
rv
=
mParentClient
-
>
RemoveBlocker
(
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
mParentClient
=
nullptr
;
}
mBarrier
=
nullptr
;
return
NS_OK
;
}
ConnectionShutdownBlocker
:
:
ConnectionShutdownBlocker
(
Database
*
aDatabase
)
:
PlacesShutdownBlocker
(
u
"
Places
Connection
shutdown
"
_ns
)
mDatabase
(
aDatabase
)
{
}
NS_IMETHODIMP
ConnectionShutdownBlocker
:
:
Done
(
)
{
mState
=
RECEIVED_DONE
;
sIsStarted
=
true
;
MOZ_ASSERT
(
Database
:
:
gDatabase
=
=
nullptr
|
|
Database
:
:
gDatabase
=
=
mDatabase
)
;
Database
:
:
gDatabase
=
nullptr
;
mDatabase
-
>
Shutdown
(
)
;
mState
=
CALLED_STORAGESHUTDOWN
;
mBarrier
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
ConnectionShutdownBlocker
:
:
Complete
(
nsresult
nsISupports
*
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mState
=
RECEIVED_STORAGESHUTDOWN_COMPLETE
;
mDatabase
=
nullptr
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
os
)
;
if
(
os
)
{
MOZ_ALWAYS_SUCCEEDS
(
os
-
>
NotifyObservers
(
nullptr
TOPIC_PLACES_CONNECTION_CLOSED
nullptr
)
)
;
}
mState
=
NOTIFIED_OBSERVERS_PLACES_CONNECTION_CLOSED
;
if
(
mParentClient
)
{
nsresult
rv
=
mParentClient
-
>
RemoveBlocker
(
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
mParentClient
=
nullptr
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
ConnectionShutdownBlocker
PlacesShutdownBlocker
mozIStorageCompletionCallback
)
}
}
