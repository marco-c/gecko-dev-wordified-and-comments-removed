#
include
"
Shutdown
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
namespace
mozilla
{
namespace
places
{
uint16_t
PlacesShutdownBlocker
:
:
sCounter
=
0
;
Atomic
<
bool
>
PlacesShutdownBlocker
:
:
sIsStarted
(
false
)
;
PlacesShutdownBlocker
:
:
PlacesShutdownBlocker
(
const
nsString
&
aName
)
:
mName
(
aName
)
mState
(
NOT_STARTED
)
mCounter
(
sCounter
+
+
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mCounter
>
1
)
{
mName
.
AppendInt
(
mCounter
)
;
}
}
NS_IMETHODIMP
PlacesShutdownBlocker
:
:
GetName
(
nsAString
&
aName
)
{
aName
=
mName
;
return
NS_OK
;
}
NS_IMETHODIMP
PlacesShutdownBlocker
:
:
GetState
(
nsIPropertyBag
*
*
_state
)
{
NS_ENSURE_ARG_POINTER
(
_state
)
;
nsCOMPtr
<
nsIWritablePropertyBag2
>
bag
=
do_CreateInstance
(
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
)
;
NS_ENSURE_TRUE
(
bag
NS_ERROR_OUT_OF_MEMORY
)
;
bag
.
forget
(
_state
)
;
RefPtr
<
nsVariant
>
progress
=
new
nsVariant
(
)
;
nsresult
rv
=
progress
-
>
SetAsUint8
(
mState
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
rv
=
static_cast
<
nsIWritablePropertyBag2
*
>
(
*
_state
)
-
>
SetPropertyAsInterface
(
NS_LITERAL_STRING
(
"
progress
"
)
progress
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
if
(
!
mBarrier
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPropertyBag
>
barrierState
;
rv
=
mBarrier
-
>
GetState
(
getter_AddRefs
(
barrierState
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
RefPtr
<
nsVariant
>
barrier
=
new
nsVariant
(
)
;
rv
=
barrier
-
>
SetAsInterface
(
NS_GET_IID
(
nsIPropertyBag
)
barrierState
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
rv
=
static_cast
<
nsIWritablePropertyBag2
*
>
(
*
_state
)
-
>
SetPropertyAsInterface
(
NS_LITERAL_STRING
(
"
Barrier
"
)
barrier
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
return
NS_OK
;
}
NS_IMETHODIMP
PlacesShutdownBlocker
:
:
BlockShutdown
(
nsIAsyncShutdownClient
*
aParentClient
)
{
MOZ_ASSERT
(
false
"
should
always
be
overridden
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMPL_ISUPPORTS
(
PlacesShutdownBlocker
nsIAsyncShutdownBlocker
)
ClientsShutdownBlocker
:
:
ClientsShutdownBlocker
(
)
:
PlacesShutdownBlocker
(
NS_LITERAL_STRING
(
"
Places
Clients
shutdown
"
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIAsyncShutdownService
>
asyncShutdown
=
services
:
:
GetAsyncShutdown
(
)
;
MOZ_ASSERT
(
asyncShutdown
)
;
if
(
asyncShutdown
)
{
nsCOMPtr
<
nsIAsyncShutdownBarrier
>
barrier
;
MOZ_ALWAYS_SUCCEEDS
(
asyncShutdown
-
>
MakeBarrier
(
mName
getter_AddRefs
(
barrier
)
)
)
;
mBarrier
=
new
nsMainThreadPtrHolder
<
nsIAsyncShutdownBarrier
>
(
"
ClientsShutdownBlocker
:
:
mBarrier
"
barrier
)
;
}
}
already_AddRefed
<
nsIAsyncShutdownClient
>
ClientsShutdownBlocker
:
:
GetClient
(
)
{
nsCOMPtr
<
nsIAsyncShutdownClient
>
client
;
if
(
mBarrier
)
{
MOZ_ALWAYS_SUCCEEDS
(
mBarrier
-
>
GetClient
(
getter_AddRefs
(
client
)
)
)
;
}
return
client
.
forget
(
)
;
}
NS_IMETHODIMP
ClientsShutdownBlocker
:
:
BlockShutdown
(
nsIAsyncShutdownClient
*
aParentClient
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mParentClient
=
new
nsMainThreadPtrHolder
<
nsIAsyncShutdownClient
>
(
"
ClientsShutdownBlocker
:
:
mParentClient
"
aParentClient
)
;
mState
=
RECEIVED_BLOCK_SHUTDOWN
;
if
(
NS_WARN_IF
(
!
mBarrier
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
MOZ_ALWAYS_SUCCEEDS
(
mBarrier
-
>
Wait
(
this
)
)
;
mState
=
CALLED_WAIT_CLIENTS
;
return
NS_OK
;
}
NS_IMETHODIMP
ClientsShutdownBlocker
:
:
Done
(
)
{
mState
=
RECEIVED_DONE
;
if
(
mParentClient
)
{
nsresult
rv
=
mParentClient
-
>
RemoveBlocker
(
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
mParentClient
=
nullptr
;
}
mBarrier
=
nullptr
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
ClientsShutdownBlocker
PlacesShutdownBlocker
nsIAsyncShutdownCompletionCallback
)
ConnectionShutdownBlocker
:
:
ConnectionShutdownBlocker
(
Database
*
aDatabase
)
:
PlacesShutdownBlocker
(
NS_LITERAL_STRING
(
"
Places
Connection
shutdown
"
)
)
mDatabase
(
aDatabase
)
{
}
NS_IMETHODIMP
ConnectionShutdownBlocker
:
:
BlockShutdown
(
nsIAsyncShutdownClient
*
aParentClient
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mParentClient
=
new
nsMainThreadPtrHolder
<
nsIAsyncShutdownClient
>
(
"
ConnectionShutdownBlocker
:
:
mParentClient
"
aParentClient
)
;
mState
=
RECEIVED_BLOCK_SHUTDOWN
;
sIsStarted
=
true
;
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
os
)
;
if
(
os
)
{
Unused
<
<
os
-
>
NotifyObservers
(
nullptr
TOPIC_PLACES_WILL_CLOSE_CONNECTION
nullptr
)
;
}
mState
=
NOTIFIED_OBSERVERS_PLACES_WILL_CLOSE_CONNECTION
;
MOZ_ASSERT
(
Database
:
:
gDatabase
=
=
nullptr
|
|
Database
:
:
gDatabase
=
=
mDatabase
)
;
Database
:
:
gDatabase
=
nullptr
;
mDatabase
-
>
Shutdown
(
)
;
mState
=
CALLED_STORAGESHUTDOWN
;
return
NS_OK
;
}
NS_IMETHODIMP
ConnectionShutdownBlocker
:
:
Complete
(
nsresult
nsISupports
*
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mState
=
RECEIVED_STORAGESHUTDOWN_COMPLETE
;
mDatabase
=
nullptr
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
os
)
;
if
(
os
)
{
MOZ_ALWAYS_SUCCEEDS
(
os
-
>
NotifyObservers
(
nullptr
TOPIC_PLACES_CONNECTION_CLOSED
nullptr
)
)
;
}
mState
=
NOTIFIED_OBSERVERS_PLACES_CONNECTION_CLOSED
;
if
(
mParentClient
)
{
nsresult
rv
=
mParentClient
-
>
RemoveBlocker
(
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
mParentClient
=
nullptr
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
ConnectionShutdownBlocker
PlacesShutdownBlocker
mozIStorageCompletionCallback
)
}
}
