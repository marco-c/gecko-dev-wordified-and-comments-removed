const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
const
BYTES_PER_MEBIBYTE
=
1048576
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
PlacesDBUtils
"
]
;
this
.
PlacesDBUtils
=
{
_isShuttingDown
:
false
shutdown
(
)
{
PlacesDBUtils
.
_isShuttingDown
=
true
;
}
_clearTaskQueue
:
false
clearPendingTasks
(
)
{
PlacesDBUtils
.
_clearTaskQueue
=
true
;
}
async
maintenanceOnIdle
(
)
{
let
tasks
=
[
this
.
checkIntegrity
this
.
invalidateCaches
this
.
checkCoherence
this
.
_refreshUI
]
;
let
telemetryStartTime
=
Date
.
now
(
)
;
let
taskStatusMap
=
await
PlacesDBUtils
.
runTasks
(
tasks
)
;
Services
.
prefs
.
setIntPref
(
"
places
.
database
.
lastMaintenance
"
parseInt
(
Date
.
now
(
)
/
1000
)
)
;
Services
.
telemetry
.
getHistogramById
(
"
PLACES_IDLE_MAINTENANCE_TIME_MS
"
)
.
add
(
Date
.
now
(
)
-
telemetryStartTime
)
;
return
taskStatusMap
;
}
async
checkAndFixDatabase
(
)
{
let
tasks
=
[
this
.
checkIntegrity
this
.
invalidateCaches
this
.
checkCoherence
this
.
expire
this
.
vacuum
this
.
stats
this
.
_refreshUI
]
;
return
PlacesDBUtils
.
runTasks
(
tasks
)
;
}
async
_refreshUI
(
)
{
let
observers
=
PlacesUtils
.
history
.
getObservers
(
)
;
for
(
let
observer
of
observers
)
{
observer
.
onBeginUpdateBatch
(
)
;
observer
.
onEndUpdateBatch
(
)
;
}
return
[
]
;
}
async
checkIntegrity
(
)
{
let
logs
=
[
]
;
async
function
integrity
(
db
)
{
let
row
;
await
db
.
execute
(
"
PRAGMA
integrity_check
"
null
(
r
cancel
)
=
>
{
row
=
r
;
cancel
(
)
;
}
)
;
return
row
.
getResultByIndex
(
0
)
=
=
=
"
ok
"
;
}
try
{
await
PlacesUtils
.
withConnectionWrapper
(
"
PlacesDBUtils
:
check
the
integrity
"
async
(
db
)
=
>
{
let
isOk
=
await
integrity
(
db
)
;
if
(
isOk
)
{
logs
.
push
(
"
The
database
is
sane
"
)
;
}
else
{
logs
.
push
(
"
The
database
is
corrupt
"
)
;
await
db
.
execute
(
"
REINDEX
"
)
;
logs
.
push
(
"
The
database
has
been
REINDEXed
"
)
;
isOk
=
await
integrity
(
db
)
;
if
(
isOk
)
{
logs
.
push
(
"
The
database
is
now
sane
"
)
;
}
else
{
logs
.
push
(
"
The
database
is
still
corrupt
"
)
;
Services
.
prefs
.
setBoolPref
(
"
places
.
database
.
replaceOnStartup
"
true
)
;
PlacesDBUtils
.
clearPendingTasks
(
)
;
throw
new
Error
(
"
Unable
to
fix
corruption
database
will
be
replaced
on
next
startup
"
)
;
}
}
}
)
;
}
catch
(
ex
)
{
if
(
ex
.
message
.
indexOf
(
"
Unable
to
fix
corruption
"
)
!
=
=
0
)
{
PlacesDBUtils
.
clearPendingTasks
(
)
;
throw
new
Error
(
"
Unable
to
check
database
integrity
"
)
;
}
}
return
logs
;
}
async
invalidateCaches
(
)
{
let
logs
=
[
]
;
try
{
await
PlacesUtils
.
withConnectionWrapper
(
"
PlacesDBUtils
:
invalidate
caches
"
async
(
db
)
=
>
{
let
idsWithInvalidGuidsRows
=
await
db
.
execute
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
IS
NULL
OR
NOT
IS_VALID_GUID
(
guid
)
)
;
for
(
let
row
of
idsWithInvalidGuidsRows
)
{
let
id
=
row
.
getResultByName
(
"
id
"
)
;
PlacesUtils
.
invalidateCachedGuidFor
(
id
)
;
}
}
)
;
logs
.
push
(
"
The
caches
have
been
invalidated
"
)
;
}
catch
(
ex
)
{
PlacesDBUtils
.
clearPendingTasks
(
)
;
throw
new
Error
(
"
Unable
to
invalidate
caches
"
)
;
}
return
logs
;
}
async
checkCoherence
(
)
{
let
logs
=
[
]
;
let
stmts
=
await
PlacesDBUtils
.
_getCoherenceStatements
(
)
;
let
coherenceCheck
=
true
;
await
PlacesUtils
.
withConnectionWrapper
(
"
PlacesDBUtils
:
coherence
check
:
"
db
=
>
db
.
executeTransaction
(
async
(
)
=
>
{
for
(
let
{
query
params
}
of
stmts
)
{
try
{
await
db
.
execute
(
query
params
|
|
null
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
coherenceCheck
=
false
;
}
}
}
)
)
;
if
(
coherenceCheck
)
{
logs
.
push
(
"
The
database
is
coherent
"
)
;
}
else
{
PlacesDBUtils
.
clearPendingTasks
(
)
;
throw
new
Error
(
"
Unable
to
complete
the
coherence
check
"
)
;
}
return
logs
;
}
async
_getCoherenceStatements
(
)
{
let
updateRootTitleSql
=
UPDATE
moz_bookmarks
SET
title
=
:
title
WHERE
id
=
:
root_id
AND
title
<
>
:
title
;
let
cleanupStatements
=
[
{
query
:
DELETE
FROM
moz_annos
WHERE
type
=
4
OR
anno_attribute_id
IN
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
'
downloads
/
destinationFileName
'
OR
name
BETWEEN
'
weave
/
'
AND
'
weave0
'
)
}
{
query
:
DELETE
FROM
moz_items_annos
WHERE
type
=
4
OR
anno_attribute_id
IN
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
'
sync
/
children
'
OR
name
=
'
placesInternal
/
GUID
'
OR
name
BETWEEN
'
weave
/
'
AND
'
weave0
'
)
}
{
query
:
DELETE
FROM
moz_anno_attributes
WHERE
id
IN
(
SELECT
id
FROM
moz_anno_attributes
n
WHERE
NOT
EXISTS
(
SELECT
id
FROM
moz_annos
WHERE
anno_attribute_id
=
n
.
id
LIMIT
1
)
AND
NOT
EXISTS
(
SELECT
id
FROM
moz_items_annos
WHERE
anno_attribute_id
=
n
.
id
LIMIT
1
)
)
}
{
query
:
DELETE
FROM
moz_annos
WHERE
id
IN
(
SELECT
id
FROM
moz_annos
a
WHERE
NOT
EXISTS
(
SELECT
id
FROM
moz_anno_attributes
WHERE
id
=
a
.
anno_attribute_id
LIMIT
1
)
)
}
{
query
:
DELETE
FROM
moz_annos
WHERE
id
IN
(
SELECT
id
FROM
moz_annos
a
WHERE
NOT
EXISTS
(
SELECT
id
FROM
moz_places
WHERE
id
=
a
.
place_id
LIMIT
1
)
)
}
{
query
:
updateRootTitleSql
params
:
{
root_id
:
PlacesUtils
.
placesRootId
title
:
"
"
}
}
{
query
:
updateRootTitleSql
params
:
{
root_id
:
PlacesUtils
.
bookmarksMenuFolderId
title
:
PlacesUtils
.
getString
(
"
BookmarksMenuFolderTitle
"
)
}
}
{
query
:
updateRootTitleSql
params
:
{
root_id
:
PlacesUtils
.
bookmarksMenuFolderId
title
:
PlacesUtils
.
getString
(
"
BookmarksMenuFolderTitle
"
)
}
}
{
query
:
updateRootTitleSql
params
:
{
root_id
:
PlacesUtils
.
toolbarFolderId
title
:
PlacesUtils
.
getString
(
"
BookmarksToolbarFolderTitle
"
)
}
}
{
query
:
updateRootTitleSql
params
:
{
root_id
:
PlacesUtils
.
unfiledBookmarksFolderId
title
:
PlacesUtils
.
getString
(
"
OtherBookmarksFolderTitle
"
)
}
}
{
query
:
updateRootTitleSql
params
:
{
root_id
:
PlacesUtils
.
tagsFolderId
title
:
PlacesUtils
.
getString
(
"
TagsFolderTitle
"
)
}
}
{
query
:
DELETE
FROM
moz_bookmarks
WHERE
guid
NOT
IN
(
:
rootGuid
:
menuGuid
:
toolbarGuid
:
unfiledGuid
:
tagsGuid
/
*
skip
roots
*
/
)
AND
id
IN
(
SELECT
b
.
id
FROM
moz_bookmarks
b
WHERE
fk
NOT
NULL
AND
b
.
type
=
:
bookmark_type
AND
NOT
EXISTS
(
SELECT
url
FROM
moz_places
WHERE
id
=
b
.
fk
LIMIT
1
)
)
params
:
{
bookmark_type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
menuGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
toolbarGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
tagsGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
}
}
{
query
:
DELETE
FROM
moz_bookmarks
WHERE
guid
NOT
IN
(
:
rootGuid
:
menuGuid
:
toolbarGuid
:
unfiledGuid
:
tagsGuid
/
*
skip
roots
*
/
)
AND
id
IN
(
SELECT
b
.
id
FROM
moz_bookmarks
b
WHERE
b
.
parent
IN
(
SELECT
id
FROM
moz_bookmarks
WHERE
parent
=
:
tags_folder
)
AND
b
.
type
<
>
:
bookmark_type
)
params
:
{
tags_folder
:
PlacesUtils
.
tagsFolderId
bookmark_type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
menuGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
toolbarGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
tagsGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
}
}
{
query
:
DELETE
FROM
moz_bookmarks
WHERE
guid
NOT
IN
(
:
rootGuid
:
menuGuid
:
toolbarGuid
:
unfiledGuid
:
tagsGuid
/
*
skip
roots
*
/
)
AND
id
IN
(
SELECT
b
.
id
FROM
moz_bookmarks
b
WHERE
b
.
id
IN
(
SELECT
id
FROM
moz_bookmarks
WHERE
parent
=
:
tags_folder
)
AND
NOT
EXISTS
(
SELECT
id
from
moz_bookmarks
WHERE
parent
=
b
.
id
LIMIT
1
)
)
params
:
{
tags_folder
:
PlacesUtils
.
tagsFolderId
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
menuGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
toolbarGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
tagsGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
}
}
{
query
:
UPDATE
moz_bookmarks
SET
parent
=
:
unsorted_folder
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
guid
NOT
IN
(
:
rootGuid
:
menuGuid
:
toolbarGuid
:
unfiledGuid
:
tagsGuid
/
*
skip
roots
*
/
)
AND
id
IN
(
SELECT
b
.
id
FROM
moz_bookmarks
b
WHERE
NOT
EXISTS
(
SELECT
id
FROM
moz_bookmarks
WHERE
id
=
b
.
parent
LIMIT
1
)
)
params
:
{
unsorted_folder
:
PlacesUtils
.
unfiledBookmarksFolderId
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
menuGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
toolbarGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
tagsGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
}
}
{
query
:
UPDATE
moz_bookmarks
SET
type
=
:
bookmark_type
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
guid
NOT
IN
(
:
rootGuid
:
menuGuid
:
toolbarGuid
:
unfiledGuid
:
tagsGuid
/
*
skip
roots
*
/
)
AND
id
IN
(
SELECT
id
FROM
moz_bookmarks
b
WHERE
type
IN
(
:
folder_type
:
separator_type
)
AND
fk
NOTNULL
)
params
:
{
bookmark_type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
folder_type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
separator_type
:
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
menuGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
toolbarGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
tagsGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
}
}
{
query
:
UPDATE
moz_bookmarks
SET
type
=
:
folder_type
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
guid
NOT
IN
(
:
rootGuid
:
menuGuid
:
toolbarGuid
:
unfiledGuid
:
tagsGuid
/
*
skip
roots
*
/
)
AND
id
IN
(
SELECT
id
FROM
moz_bookmarks
b
WHERE
type
=
:
bookmark_type
AND
fk
IS
NULL
)
params
:
{
bookmark_type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
folder_type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
menuGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
toolbarGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
tagsGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
}
}
{
query
:
UPDATE
moz_bookmarks
SET
parent
=
:
unsorted_folder
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
guid
NOT
IN
(
:
rootGuid
:
menuGuid
:
toolbarGuid
:
unfiledGuid
:
tagsGuid
/
*
skip
roots
*
/
)
AND
id
IN
(
SELECT
id
FROM
moz_bookmarks
b
WHERE
EXISTS
(
SELECT
id
FROM
moz_bookmarks
WHERE
id
=
b
.
parent
AND
type
IN
(
:
bookmark_type
:
separator_type
)
LIMIT
1
)
)
params
:
{
unsorted_folder
:
PlacesUtils
.
unfiledBookmarksFolderId
bookmark_type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
separator_type
:
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
rootGuid
:
PlacesUtils
.
bookmarks
.
rootGuid
menuGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
toolbarGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
tagsGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
}
}
{
query
:
CREATE
TEMP
TABLE
IF
NOT
EXISTS
moz_bm_reindex_temp
(
id
INTEGER
parent
INTEGER
position
INTEGER
)
}
{
query
:
INSERT
INTO
moz_bm_reindex_temp
SELECT
id
parent
0
FROM
moz_bookmarks
b
WHERE
parent
IN
(
SELECT
parent
FROM
moz_bookmarks
GROUP
BY
parent
HAVING
(
SUM
(
DISTINCT
position
+
1
)
-
(
count
(
*
)
*
(
count
(
*
)
+
1
)
/
2
)
)
<
>
0
)
ORDER
BY
parent
ASC
position
ASC
ROWID
ASC
}
{
query
:
CREATE
INDEX
IF
NOT
EXISTS
moz_bm_reindex_temp_index
ON
moz_bm_reindex_temp
(
parent
)
}
{
query
:
UPDATE
moz_bm_reindex_temp
SET
position
=
(
ROWID
-
(
SELECT
MIN
(
t
.
ROWID
)
FROM
moz_bm_reindex_temp
t
WHERE
t
.
parent
=
moz_bm_reindex_temp
.
parent
)
)
}
{
query
:
CREATE
TEMP
TRIGGER
IF
NOT
EXISTS
moz_bm_reindex_temp_trigger
BEFORE
DELETE
ON
moz_bm_reindex_temp
FOR
EACH
ROW
BEGIN
UPDATE
moz_bookmarks
SET
position
=
OLD
.
position
WHERE
id
=
OLD
.
id
;
END
}
{
query
:
DELETE
FROM
moz_bm_reindex_temp
}
{
query
:
DROP
INDEX
moz_bm_reindex_temp_index
}
{
query
:
DROP
TRIGGER
moz_bm_reindex_temp_trigger
}
{
query
:
DROP
TABLE
moz_bm_reindex_temp
}
{
query
:
UPDATE
moz_bookmarks
SET
title
=
:
empty_title
WHERE
length
(
title
)
=
0
AND
type
=
:
folder_type
AND
parent
=
:
tags_folder
params
:
{
empty_title
:
"
(
notitle
)
"
folder_type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
tags_folder
:
PlacesUtils
.
tagsFolderId
}
}
{
query
:
DELETE
FROM
moz_pages_w_icons
WHERE
page_url_hash
NOT
IN
(
SELECT
url_hash
FROM
moz_places
)
}
{
query
:
DELETE
FROM
moz_icons
WHERE
id
IN
(
SELECT
id
FROM
moz_icons
WHERE
root
=
0
EXCEPT
SELECT
icon_id
FROM
moz_icons_to_pages
)
}
{
query
:
DELETE
FROM
moz_historyvisits
WHERE
id
IN
(
SELECT
id
FROM
moz_historyvisits
v
WHERE
NOT
EXISTS
(
SELECT
id
FROM
moz_places
WHERE
id
=
v
.
place_id
LIMIT
1
)
)
}
{
query
:
DELETE
FROM
moz_inputhistory
WHERE
place_id
IN
(
SELECT
place_id
FROM
moz_inputhistory
i
WHERE
NOT
EXISTS
(
SELECT
id
FROM
moz_places
WHERE
id
=
i
.
place_id
LIMIT
1
)
)
}
{
query
:
DELETE
FROM
moz_items_annos
WHERE
id
IN
(
SELECT
id
FROM
moz_items_annos
t
WHERE
NOT
EXISTS
(
SELECT
id
FROM
moz_anno_attributes
WHERE
id
=
t
.
anno_attribute_id
LIMIT
1
)
)
}
{
query
:
DELETE
FROM
moz_items_annos
WHERE
id
IN
(
SELECT
id
FROM
moz_items_annos
t
WHERE
NOT
EXISTS
(
SELECT
id
FROM
moz_bookmarks
WHERE
id
=
t
.
item_id
LIMIT
1
)
)
}
{
query
:
DELETE
FROM
moz_keywords
WHERE
id
IN
(
SELECT
id
FROM
moz_keywords
k
WHERE
NOT
EXISTS
(
SELECT
1
FROM
moz_places
h
WHERE
k
.
place_id
=
h
.
id
)
)
}
{
query
:
UPDATE
moz_places
SET
visit_count
=
(
SELECT
count
(
*
)
FROM
moz_historyvisits
WHERE
place_id
=
moz_places
.
id
AND
visit_type
NOT
IN
(
0
4
7
8
9
)
)
last_visit_date
=
(
SELECT
MAX
(
visit_date
)
FROM
moz_historyvisits
WHERE
place_id
=
moz_places
.
id
)
WHERE
id
IN
(
SELECT
h
.
id
FROM
moz_places
h
WHERE
visit_count
<
>
(
SELECT
count
(
*
)
FROM
moz_historyvisits
v
WHERE
v
.
place_id
=
h
.
id
AND
visit_type
NOT
IN
(
0
4
7
8
9
)
)
OR
last_visit_date
<
>
(
SELECT
MAX
(
visit_date
)
FROM
moz_historyvisits
v
WHERE
v
.
place_id
=
h
.
id
)
)
}
{
query
:
UPDATE
moz_places
SET
hidden
=
1
WHERE
id
IN
(
SELECT
h
.
id
FROM
moz_places
h
JOIN
moz_historyvisits
src
ON
src
.
place_id
=
h
.
id
JOIN
moz_historyvisits
dst
ON
dst
.
from_visit
=
src
.
id
AND
dst
.
visit_type
IN
(
5
6
)
LEFT
JOIN
moz_bookmarks
on
fk
=
h
.
id
AND
fk
ISNULL
GROUP
BY
src
.
place_id
HAVING
count
(
*
)
=
visit_count
)
}
{
query
:
UPDATE
moz_places
SET
foreign_count
=
(
SELECT
count
(
*
)
FROM
moz_bookmarks
WHERE
fk
=
moz_places
.
id
)
+
(
SELECT
count
(
*
)
FROM
moz_keywords
WHERE
place_id
=
moz_places
.
id
)
}
{
query
:
UPDATE
moz_places
SET
url_hash
=
hash
(
url
)
WHERE
url_hash
=
0
}
{
query
:
UPDATE
moz_places
SET
guid
=
GENERATE_GUID
(
)
WHERE
guid
IS
NULL
OR
NOT
IS_VALID_GUID
(
guid
)
}
{
query
:
INSERT
OR
IGNORE
INTO
moz_bookmarks_deleted
(
guid
dateRemoved
)
SELECT
guid
:
dateRemoved
FROM
moz_bookmarks
WHERE
syncStatus
<
>
:
syncStatus
AND
guid
NOT
NULL
AND
NOT
IS_VALID_GUID
(
guid
)
params
:
{
dateRemoved
:
PlacesUtils
.
toPRTime
(
new
Date
(
)
)
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NEW
}
}
{
query
:
UPDATE
moz_bookmarks
SET
guid
=
GENERATE_GUID
(
)
syncChangeCounter
=
syncChangeCounter
+
1
syncStatus
=
:
syncStatus
WHERE
guid
IS
NULL
OR
NOT
IS_VALID_GUID
(
guid
)
params
:
{
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NEW
}
}
{
query
:
DELETE
FROM
moz_bookmarks_deleted
WHERE
guid
IN
(
SELECT
guid
FROM
moz_bookmarks
)
}
{
query
:
UPDATE
moz_bookmarks
SET
dateAdded
=
COALESCE
(
dateAdded
lastModified
(
SELECT
MIN
(
visit_date
)
FROM
moz_historyvisits
WHERE
place_id
=
fk
)
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
)
lastModified
=
COALESCE
(
lastModified
dateAdded
(
SELECT
MAX
(
visit_date
)
FROM
moz_historyvisits
WHERE
place_id
=
fk
)
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
)
WHERE
dateAdded
IS
NULL
OR
lastModified
IS
NULL
}
]
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
execute
(
SELECT
id
FROM
moz_bookmarks
WHERE
id
=
:
root
{
root
:
PlacesUtils
.
placesRootId
}
)
;
if
(
rows
.
length
=
=
=
0
)
{
cleanupStatements
.
unshift
(
{
query
:
UPDATE
moz_bookmarks
SET
parent
=
:
places_root
WHERE
guid
IN
(
:
menuGuid
:
toolbarGuid
:
unfiledGuid
:
tagsGuid
)
params
:
{
places_root
:
PlacesUtils
.
placesRootId
menuGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
toolbarGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
unfiledGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
tagsGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
}
}
)
;
cleanupStatements
.
unshift
(
{
query
:
INSERT
INTO
moz_bookmarks
(
id
type
fk
parent
position
title
guid
)
VALUES
(
:
places_root
2
NULL
0
0
:
title
:
guid
)
params
:
{
places_root
:
PlacesUtils
.
placesRootId
title
:
"
"
guid
:
PlacesUtils
.
bookmarks
.
rootGuid
}
}
)
;
}
cleanupStatements
.
unshift
(
{
query
:
CREATE
TEMP
TRIGGER
IF
NOT
EXISTS
moz_bm_sync_change_temp_trigger
AFTER
UPDATE
of
guid
parent
position
ON
moz_bookmarks
FOR
EACH
ROW
BEGIN
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
id
=
NEW
.
parent
OR
(
OLD
.
parent
<
>
NEW
.
parent
AND
id
=
OLD
.
parent
)
;
END
}
)
;
cleanupStatements
.
unshift
(
{
query
:
CREATE
TEMP
TRIGGER
IF
NOT
EXISTS
moz_bm_sync_tombstone_temp_trigger
AFTER
DELETE
ON
moz_bookmarks
FOR
EACH
ROW
WHEN
OLD
.
guid
NOT
NULL
AND
OLD
.
syncStatus
<
>
1
BEGIN
INSERT
INTO
moz_bookmarks_deleted
(
guid
dateRemoved
)
VALUES
(
OLD
.
guid
STRFTIME
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
*
1000000
)
;
END
}
)
;
cleanupStatements
.
push
(
{
query
:
DROP
TRIGGER
moz_bm_sync_change_temp_trigger
}
)
;
cleanupStatements
.
push
(
{
query
:
DROP
TRIGGER
moz_bm_sync_tombstone_temp_trigger
}
)
;
return
cleanupStatements
;
}
async
vacuum
(
)
{
let
logs
=
[
]
;
let
DBFile
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
DBFile
.
append
(
"
places
.
sqlite
"
)
;
logs
.
push
(
"
Initial
database
size
is
"
+
parseInt
(
DBFile
.
fileSize
/
1024
)
+
"
KiB
"
)
;
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesDBUtils
:
vacuum
"
async
(
db
)
=
>
{
await
db
.
execute
(
"
VACUUM
"
)
;
}
)
.
then
(
(
)
=
>
{
logs
.
push
(
"
The
database
has
been
vacuumed
"
)
;
let
vacuumedDBFile
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
vacuumedDBFile
.
append
(
"
places
.
sqlite
"
)
;
logs
.
push
(
"
Final
database
size
is
"
+
parseInt
(
vacuumedDBFile
.
fileSize
/
1024
)
+
"
KiB
"
)
;
return
logs
;
}
)
.
catch
(
(
)
=
>
{
PlacesDBUtils
.
clearPendingTasks
(
)
;
throw
new
Error
(
"
Unable
to
vacuum
database
"
)
;
}
)
;
}
async
expire
(
)
{
let
logs
=
[
]
;
let
expiration
=
Cc
[
"
mozilla
.
org
/
places
/
expiration
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
;
let
returnPromise
=
new
Promise
(
res
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
logs
.
push
(
"
Database
cleaned
up
"
)
;
res
(
logs
)
;
}
;
Services
.
obs
.
addObserver
(
observer
PlacesUtils
.
TOPIC_EXPIRATION_FINISHED
)
;
}
)
;
expiration
.
observe
(
null
"
places
-
debug
-
start
-
expiration
"
0
)
;
return
returnPromise
;
}
async
stats
(
)
{
let
logs
=
[
]
;
let
DBFile
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
DBFile
.
append
(
"
places
.
sqlite
"
)
;
logs
.
push
(
"
Database
size
is
"
+
parseInt
(
DBFile
.
fileSize
/
1024
)
+
"
KiB
"
)
;
let
pragmas
=
[
"
user_version
"
"
page_size
"
"
cache_size
"
"
journal_mode
"
"
synchronous
"
]
.
map
(
p
=
>
pragma_
{
p
}
)
;
let
pragmaQuery
=
SELECT
*
FROM
{
pragmas
.
join
(
"
"
)
}
;
await
PlacesUtils
.
withConnectionWrapper
(
"
PlacesDBUtils
:
pragma
for
stats
"
async
(
db
)
=
>
{
let
row
=
(
await
db
.
execute
(
pragmaQuery
)
)
[
0
]
;
for
(
let
i
=
0
;
i
!
=
pragmas
.
length
;
i
+
+
)
{
logs
.
push
(
{
pragmas
[
i
]
}
is
{
row
.
getResultByIndex
(
i
)
}
)
;
}
}
)
.
catch
(
(
)
=
>
{
logs
.
push
(
"
Could
not
set
pragma
for
stat
collection
"
)
;
}
)
;
try
{
let
limitURIs
=
Services
.
prefs
.
getIntPref
(
"
places
.
history
.
expiration
.
transient_current_max_pages
"
)
;
logs
.
push
(
"
History
can
store
a
maximum
of
"
+
limitURIs
+
"
unique
pages
"
)
;
}
catch
(
ex
)
{
}
let
query
=
"
SELECT
name
FROM
sqlite_master
WHERE
type
=
:
type
"
;
let
params
=
{
}
;
let
_getTableCount
=
async
(
tableName
)
=
>
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
execute
(
SELECT
count
(
*
)
FROM
{
tableName
}
)
;
logs
.
push
(
Table
{
tableName
}
has
{
rows
[
0
]
.
getResultByIndex
(
0
)
}
records
)
;
}
;
try
{
params
.
type
=
"
table
"
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
await
db
.
execute
(
query
params
r
=
>
_getTableCount
(
r
.
getResultByIndex
(
0
)
)
)
;
params
.
type
=
"
index
"
;
await
db
.
execute
(
query
params
r
=
>
{
logs
.
push
(
Index
{
r
.
getResultByIndex
(
0
)
}
)
;
}
)
;
params
.
type
=
"
trigger
"
;
await
db
.
execute
(
query
params
r
=
>
{
logs
.
push
(
Trigger
{
r
.
getResultByIndex
(
0
)
}
)
;
}
)
;
}
catch
(
ex
)
{
throw
new
Error
(
"
Unable
to
collect
stats
.
"
)
;
}
return
logs
;
}
async
telemetry
(
)
{
let
probeValues
=
{
}
;
let
probes
=
[
{
histogram
:
"
PLACES_PAGES_COUNT
"
query
:
"
SELECT
count
(
*
)
FROM
moz_places
"
}
{
histogram
:
"
PLACES_BOOKMARKS_COUNT
"
query
:
SELECT
count
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
t
ON
t
.
id
=
b
.
parent
AND
t
.
parent
<
>
:
tags_folder
WHERE
b
.
type
=
:
type_bookmark
}
{
histogram
:
"
PLACES_TAGS_COUNT
"
query
:
SELECT
count
(
*
)
FROM
moz_bookmarks
WHERE
parent
=
:
tags_folder
}
{
histogram
:
"
PLACES_KEYWORDS_COUNT
"
query
:
"
SELECT
count
(
*
)
FROM
moz_keywords
"
}
{
histogram
:
"
PLACES_SORTED_BOOKMARKS_PERC
"
query
:
SELECT
IFNULL
(
ROUND
(
(
SELECT
count
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
t
ON
t
.
id
=
b
.
parent
AND
t
.
parent
<
>
:
tags_folder
AND
t
.
parent
>
:
places_root
WHERE
b
.
type
=
:
type_bookmark
)
*
100
/
(
SELECT
count
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
t
ON
t
.
id
=
b
.
parent
AND
t
.
parent
<
>
:
tags_folder
WHERE
b
.
type
=
:
type_bookmark
)
)
0
)
}
{
histogram
:
"
PLACES_TAGGED_BOOKMARKS_PERC
"
query
:
SELECT
IFNULL
(
ROUND
(
(
SELECT
count
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
t
ON
t
.
id
=
b
.
parent
AND
t
.
parent
=
:
tags_folder
)
*
100
/
(
SELECT
count
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
t
ON
t
.
id
=
b
.
parent
AND
t
.
parent
<
>
:
tags_folder
WHERE
b
.
type
=
:
type_bookmark
)
)
0
)
}
{
histogram
:
"
PLACES_DATABASE_FILESIZE_MB
"
callback
(
)
{
let
DBFile
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
DBFile
.
append
(
"
places
.
sqlite
"
)
;
return
parseInt
(
DBFile
.
fileSize
/
BYTES_PER_MEBIBYTE
)
;
}
}
{
histogram
:
"
PLACES_DATABASE_PAGESIZE_B
"
query
:
"
PRAGMA
page_size
/
*
PlacesDBUtils
.
jsm
PAGESIZE_B
*
/
"
}
{
histogram
:
"
PLACES_DATABASE_SIZE_PER_PAGE_B
"
query
:
"
PRAGMA
page_count
"
callback
(
aDbPageCount
)
{
let
dbPageSize
=
probeValues
.
PLACES_DATABASE_PAGESIZE_B
;
let
placesPageCount
=
probeValues
.
PLACES_PAGES_COUNT
;
return
Math
.
round
(
(
dbPageSize
*
aDbPageCount
)
/
placesPageCount
)
;
}
}
{
histogram
:
"
PLACES_ANNOS_BOOKMARKS_COUNT
"
query
:
"
SELECT
count
(
*
)
FROM
moz_items_annos
"
}
{
histogram
:
"
PLACES_ANNOS_PAGES_COUNT
"
query
:
"
SELECT
count
(
*
)
FROM
moz_annos
"
}
{
histogram
:
"
PLACES_MAINTENANCE_DAYSFROMLAST
"
callback
(
)
{
try
{
let
lastMaintenance
=
Services
.
prefs
.
getIntPref
(
"
places
.
database
.
lastMaintenance
"
)
;
let
nowSeconds
=
parseInt
(
Date
.
now
(
)
/
1000
)
;
return
parseInt
(
(
nowSeconds
-
lastMaintenance
)
/
86400
)
;
}
catch
(
ex
)
{
return
60
;
}
}
}
]
;
let
params
=
{
tags_folder
:
PlacesUtils
.
tagsFolderId
type_folder
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
type_bookmark
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
places_root
:
PlacesUtils
.
placesRootId
}
;
for
(
let
i
=
0
;
i
<
probes
.
length
;
i
+
+
)
{
let
probe
=
probes
[
i
]
;
let
promiseDone
=
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
!
(
"
query
"
in
probe
)
)
{
resolve
(
[
probe
]
)
;
return
;
}
let
filteredParams
=
{
}
;
for
(
let
p
in
params
)
{
if
(
probe
.
query
.
includes
(
:
{
p
}
)
)
{
filteredParams
[
p
]
=
params
[
p
]
;
}
}
PlacesUtils
.
promiseDBConnection
(
)
.
then
(
db
=
>
db
.
execute
(
probe
.
query
filteredParams
)
)
.
then
(
rows
=
>
resolve
(
[
probe
rows
[
0
]
.
getResultByIndex
(
0
)
]
)
)
.
catch
(
ex
=
>
reject
(
new
Error
(
"
Unable
to
get
telemetry
from
database
.
"
)
)
)
;
}
)
;
promiseDone
.
then
(
(
[
aProbe
aValue
]
)
=
>
{
let
value
=
aValue
;
if
(
"
callback
"
in
aProbe
)
{
value
=
aProbe
.
callback
(
value
)
;
}
probeValues
[
aProbe
.
histogram
]
=
value
;
Services
.
telemetry
.
getHistogramById
(
aProbe
.
histogram
)
.
add
(
value
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
}
async
runTasks
(
tasks
)
{
PlacesDBUtils
.
_clearTaskQueue
=
false
;
let
tasksMap
=
new
Map
(
)
;
for
(
let
task
of
tasks
)
{
if
(
PlacesDBUtils
.
_isShuttingDown
)
{
tasksMap
.
set
(
task
.
name
{
succeeded
:
false
logs
:
[
"
Shutting
down
will
not
schedule
the
task
.
"
]
}
)
;
continue
;
}
if
(
PlacesDBUtils
.
_clearTaskQueue
)
{
tasksMap
.
set
(
task
.
name
{
succeeded
:
false
logs
:
[
"
The
task
queue
was
cleared
by
an
error
in
another
task
.
"
]
}
)
;
continue
;
}
let
result
=
await
task
(
)
.
then
(
logs
=
>
{
return
{
succeeded
:
true
logs
}
;
}
)
.
catch
(
err
=
>
{
return
{
succeeded
:
false
logs
:
[
err
.
message
]
}
;
}
)
;
tasksMap
.
set
(
task
.
name
result
)
;
}
return
tasksMap
;
}
}
;
