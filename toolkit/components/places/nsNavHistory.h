#
ifndef
nsNavHistory_h_
#
define
nsNavHistory_h_
#
include
"
nsINavHistoryService
.
h
"
#
include
"
nsINavBookmarksService
.
h
"
#
include
"
nsIFaviconService
.
h
"
#
include
"
nsIGlobalHistory2
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsICollation
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsMaybeWeakPtr
.
h
"
#
include
"
nsCategoryCache
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsToolkitCompsCID
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsNavHistoryResult
.
h
"
#
include
"
nsNavHistoryQuery
.
h
"
#
include
"
Database
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
ifdef
XP_WIN
#
include
"
WinUtils
.
h
"
#
include
<
wincrypt
.
h
>
#
endif
#
define
QUERYUPDATE_TIME
0
#
define
QUERYUPDATE_SIMPLE
1
#
define
QUERYUPDATE_COMPLEX
2
#
define
QUERYUPDATE_COMPLEX_WITH_BOOKMARKS
3
#
define
QUERYUPDATE_HOST
4
#
define
QUERYUPDATE_MOBILEPREF
5
#
define
QUERYUPDATE_NONE
6
#
define
URI_LENGTH_MAX
65536
#
define
TITLE_LENGTH_MAX
4096
#
define
RECENT_EVENT_THRESHOLD
PRTime
(
(
int64_t
)
15
*
60
*
PR_USEC_PER_SEC
)
#
ifdef
MOZ_XUL
#
define
TOPIC_AUTOCOMPLETE_FEEDBACK_UPDATED
"
places
-
autocomplete
-
feedback
-
updated
"
#
endif
#
define
TOPIC_FRECENCY_UPDATED
"
places
-
frecency
-
updated
"
#
define
MOBILE_BOOKMARKS_PREF
"
browser
.
bookmarks
.
showMobileBookmarks
"
#
define
MOBILE_BOOKMARKS_VIRTUAL_GUID
"
mobile____v
"
class
nsNavHistory
;
class
QueryKeyValuePair
;
class
nsIEffectiveTLDService
;
class
nsIIDNService
;
class
PlacesSQLQueryBuilder
;
class
nsIAutoCompleteController
;
class
nsNavHistory
final
:
public
nsSupportsWeakReference
public
nsINavHistoryService
public
nsIObserver
public
mozIStorageVacuumParticipant
{
friend
class
PlacesSQLQueryBuilder
;
public
:
nsNavHistory
(
)
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSINAVHISTORYSERVICE
NS_DECL_NSIOBSERVER
NS_DECL_MOZISTORAGEVACUUMPARTICIPANT
static
already_AddRefed
<
nsNavHistory
>
GetSingleton
(
)
;
nsresult
Init
(
)
;
static
nsNavHistory
*
GetHistoryService
(
)
{
if
(
!
gHistoryService
)
{
nsCOMPtr
<
nsINavHistoryService
>
serv
=
do_GetService
(
NS_NAVHISTORYSERVICE_CONTRACTID
)
;
NS_ENSURE_TRUE
(
serv
nullptr
)
;
NS_ASSERTION
(
gHistoryService
"
Should
have
static
instance
pointer
now
"
)
;
}
return
gHistoryService
;
}
static
const
nsNavHistory
*
GetConstHistoryService
(
)
{
const
nsNavHistory
*
const
history
=
gHistoryService
;
return
history
;
}
nsresult
GetIdForPage
(
nsIURI
*
aURI
int64_t
*
_pageId
nsCString
&
_GUID
)
;
nsresult
GetOrCreateIdForPage
(
nsIURI
*
aURI
int64_t
*
_pageId
nsCString
&
_GUID
)
;
nsresult
UpdateFrecency
(
int64_t
aPlaceId
)
;
nsresult
FixInvalidFrecencies
(
)
;
nsresult
invalidateFrecencies
(
const
nsCString
&
aPlaceIdsQueryString
)
;
nsresult
NotifyOnPageExpired
(
nsIURI
*
aURI
PRTime
aVisitTime
bool
aWholeEntry
const
nsACString
&
aGUID
uint16_t
aReason
uint32_t
aTransitionType
)
;
nsIStringBundle
*
GetBundle
(
)
;
nsICollation
*
GetCollation
(
)
;
void
GetStringFromName
(
const
char
*
aName
nsACString
&
aResult
)
;
void
GetAgeInDaysString
(
int32_t
aInt
const
char
*
aName
nsACString
&
aResult
)
;
static
void
GetMonthName
(
const
PRExplodedTime
&
aTime
nsACString
&
aResult
)
;
static
void
GetMonthYear
(
const
PRExplodedTime
&
aTime
nsACString
&
aResult
)
;
bool
IsHistoryDisabled
(
)
{
return
!
mHistoryEnabled
;
}
static
const
int32_t
kGetInfoIndex_PageID
;
static
const
int32_t
kGetInfoIndex_URL
;
static
const
int32_t
kGetInfoIndex_Title
;
static
const
int32_t
kGetInfoIndex_RevHost
;
static
const
int32_t
kGetInfoIndex_VisitCount
;
static
const
int32_t
kGetInfoIndex_VisitDate
;
static
const
int32_t
kGetInfoIndex_FaviconURL
;
static
const
int32_t
kGetInfoIndex_ItemId
;
static
const
int32_t
kGetInfoIndex_ItemDateAdded
;
static
const
int32_t
kGetInfoIndex_ItemLastModified
;
static
const
int32_t
kGetInfoIndex_ItemParentId
;
static
const
int32_t
kGetInfoIndex_ItemTags
;
static
const
int32_t
kGetInfoIndex_Frecency
;
static
const
int32_t
kGetInfoIndex_Hidden
;
static
const
int32_t
kGetInfoIndex_Guid
;
static
const
int32_t
kGetInfoIndex_VisitId
;
static
const
int32_t
kGetInfoIndex_FromVisitId
;
static
const
int32_t
kGetInfoIndex_VisitType
;
int64_t
GetTagsFolder
(
)
;
nsresult
GetQueryResults
(
nsNavHistoryQueryResultNode
*
aResultNode
const
RefPtr
<
nsNavHistoryQuery
>
&
aQuery
const
RefPtr
<
nsNavHistoryQueryOptions
>
&
aOptions
nsCOMArray
<
nsNavHistoryResultNode
>
*
aResults
)
;
nsresult
RowToResult
(
mozIStorageValueArray
*
aRow
nsNavHistoryQueryOptions
*
aOptions
nsNavHistoryResultNode
*
*
aResult
)
;
nsresult
QueryRowToResult
(
int64_t
aItemId
const
nsACString
&
aBookmarkGuid
const
nsACString
&
aURI
const
nsACString
&
aTitle
uint32_t
aAccessCount
PRTime
aTime
nsNavHistoryResultNode
*
*
aNode
)
;
nsresult
VisitIdToResultNode
(
int64_t
visitId
nsNavHistoryQueryOptions
*
aOptions
nsNavHistoryResultNode
*
*
aResult
)
;
nsresult
BookmarkIdToResultNode
(
int64_t
aBookmarkId
nsNavHistoryQueryOptions
*
aOptions
nsNavHistoryResultNode
*
*
aResult
)
;
nsresult
URIToResultNode
(
nsIURI
*
aURI
nsNavHistoryQueryOptions
*
aOptions
nsNavHistoryResultNode
*
*
aResult
)
;
void
SendPageChangedNotification
(
nsIURI
*
aURI
uint32_t
aChangedAttribute
const
nsAString
&
aValue
const
nsACString
&
aGUID
)
;
int32_t
GetDaysOfHistory
(
)
;
void
DomainNameFromURI
(
nsIURI
*
aURI
nsACString
&
aDomainName
)
;
static
PRTime
NormalizeTime
(
uint32_t
aRelative
PRTime
aOffset
)
;
nsresult
BeginUpdateBatch
(
)
;
nsresult
EndUpdateBatch
(
)
;
int32_t
mBatchLevel
;
mozStorageTransaction
*
mBatchDBTransaction
;
typedef
nsDataHashtable
<
nsCStringHashKey
nsCString
>
StringHash
;
bool
canNotify
(
)
{
return
mCanNotify
;
}
enum
RecentEventFlags
{
RECENT_TYPED
=
1
<
<
0
RECENT_ACTIVATED
=
1
<
<
1
RECENT_BOOKMARKED
=
1
<
<
2
}
;
uint32_t
GetRecentFlags
(
nsIURI
*
aURI
)
;
bool
hasHistoryEntries
(
)
;
void
registerEmbedVisit
(
nsIURI
*
aURI
int64_t
aTime
)
;
bool
hasEmbedVisit
(
nsIURI
*
aURI
)
;
int32_t
GetFrecencyAgedWeight
(
int32_t
aAgeInDays
)
const
{
if
(
aAgeInDays
<
=
mFirstBucketCutoffInDays
)
{
return
mFirstBucketWeight
;
}
if
(
aAgeInDays
<
=
mSecondBucketCutoffInDays
)
{
return
mSecondBucketWeight
;
}
if
(
aAgeInDays
<
=
mThirdBucketCutoffInDays
)
{
return
mThirdBucketWeight
;
}
if
(
aAgeInDays
<
=
mFourthBucketCutoffInDays
)
{
return
mFourthBucketWeight
;
}
return
mDefaultWeight
;
}
int32_t
GetFrecencyBucketWeight
(
int32_t
aBucketIndex
)
const
{
switch
(
aBucketIndex
)
{
case
1
:
return
mFirstBucketWeight
;
case
2
:
return
mSecondBucketWeight
;
case
3
:
return
mThirdBucketWeight
;
case
4
:
return
mFourthBucketWeight
;
default
:
return
mDefaultWeight
;
}
}
int32_t
GetFrecencyTransitionBonus
(
int32_t
aTransitionType
bool
aVisited
bool
aRedirect
=
false
)
const
{
if
(
aRedirect
)
{
return
mRedirectSourceVisitBonus
;
}
switch
(
aTransitionType
)
{
case
nsINavHistoryService
:
:
TRANSITION_EMBED
:
return
mEmbedVisitBonus
;
case
nsINavHistoryService
:
:
TRANSITION_FRAMED_LINK
:
return
mFramedLinkVisitBonus
;
case
nsINavHistoryService
:
:
TRANSITION_LINK
:
return
mLinkVisitBonus
;
case
nsINavHistoryService
:
:
TRANSITION_TYPED
:
return
aVisited
?
mTypedVisitBonus
:
mUnvisitedTypedBonus
;
case
nsINavHistoryService
:
:
TRANSITION_BOOKMARK
:
return
aVisited
?
mBookmarkVisitBonus
:
mUnvisitedBookmarkBonus
;
case
nsINavHistoryService
:
:
TRANSITION_DOWNLOAD
:
return
mDownloadVisitBonus
;
case
nsINavHistoryService
:
:
TRANSITION_REDIRECT_PERMANENT
:
return
mPermRedirectVisitBonus
;
case
nsINavHistoryService
:
:
TRANSITION_REDIRECT_TEMPORARY
:
return
mTempRedirectVisitBonus
;
case
nsINavHistoryService
:
:
TRANSITION_RELOAD
:
return
mReloadVisitBonus
;
default
:
NS_WARNING_ASSERTION
(
!
aTransitionType
"
new
transition
but
no
bonus
for
frecency
"
)
;
return
mDefaultVisitBonus
;
}
}
int32_t
GetNumVisitsForFrecency
(
)
const
{
return
mNumVisitsForFrecency
;
}
void
NotifyOnVisits
(
nsIVisitData
*
*
aVisits
uint32_t
aVisitsCount
)
;
void
NotifyTitleChange
(
nsIURI
*
aURI
const
nsString
&
title
const
nsACString
&
aGUID
)
;
void
NotifyFrecencyChanged
(
nsIURI
*
aURI
int32_t
aNewFrecency
const
nsACString
&
aGUID
bool
aHidden
PRTime
aLastVisitDate
)
;
void
NotifyManyFrecenciesChanged
(
)
;
void
DispatchFrecencyChangedNotification
(
const
nsACString
&
aSpec
int32_t
aNewFrecency
const
nsACString
&
aGUID
bool
aHidden
PRTime
aLastVisitDate
)
const
;
static
mozilla
:
:
Atomic
<
int64_t
>
sLastInsertedPlaceId
;
static
mozilla
:
:
Atomic
<
int64_t
>
sLastInsertedVisitId
;
static
void
StoreLastInsertedId
(
const
nsACString
&
aTable
const
int64_t
aLastInsertedId
)
;
bool
isBatching
(
)
{
return
mBatchLevel
>
0
;
}
#
ifdef
XP_WIN
nsresult
GetCryptoProvider
(
HCRYPTPROV
&
aCryptoProvider
)
const
{
NS_ENSURE_STATE
(
mCryptoProviderInitialized
)
;
aCryptoProvider
=
mCryptoProvider
;
return
NS_OK
;
}
#
endif
static
nsresult
FilterResultSet
(
nsNavHistoryQueryResultNode
*
aParentNode
const
nsCOMArray
<
nsNavHistoryResultNode
>
&
aSet
nsCOMArray
<
nsNavHistoryResultNode
>
*
aFiltered
const
RefPtr
<
nsNavHistoryQuery
>
&
aQuery
nsNavHistoryQueryOptions
*
aOptions
)
;
private
:
~
nsNavHistory
(
)
;
static
nsNavHistory
*
gHistoryService
;
protected
:
RefPtr
<
mozilla
:
:
places
:
:
Database
>
mDB
;
nsresult
DecayFrecency
(
)
;
void
LoadPrefs
(
)
;
PRTime
GetNow
(
)
;
PRTime
mCachedNow
;
nsCOMPtr
<
nsITimer
>
mExpireNowTimer
;
static
void
expireNowTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
nsresult
ConstructQueryString
(
const
RefPtr
<
nsNavHistoryQuery
>
&
aQuery
const
RefPtr
<
nsNavHistoryQueryOptions
>
&
aOptions
nsCString
&
queryString
bool
&
aParamsPresent
StringHash
&
aAddParams
)
;
nsresult
QueryToSelectClause
(
const
RefPtr
<
nsNavHistoryQuery
>
&
aQuery
const
RefPtr
<
nsNavHistoryQueryOptions
>
&
aOptions
nsCString
*
aClause
)
;
nsresult
BindQueryClauseParameters
(
mozIStorageBaseStatement
*
statement
const
RefPtr
<
nsNavHistoryQuery
>
&
aQuery
const
RefPtr
<
nsNavHistoryQueryOptions
>
&
aOptions
)
;
nsresult
ResultsAsList
(
mozIStorageStatement
*
statement
nsNavHistoryQueryOptions
*
aOptions
nsCOMArray
<
nsNavHistoryResultNode
>
*
aResults
)
;
nsMaybeWeakPtrArray
<
nsINavHistoryObserver
>
mObservers
;
nsCOMPtr
<
nsIEffectiveTLDService
>
mTLDService
;
nsCOMPtr
<
nsIIDNService
>
mIDNService
;
nsCOMPtr
<
nsIStringBundle
>
mBundle
;
nsCOMPtr
<
nsICollation
>
mCollation
;
typedef
nsDataHashtable
<
nsCStringHashKey
int64_t
>
RecentEventHash
;
RecentEventHash
mRecentTyped
;
RecentEventHash
mRecentLink
;
RecentEventHash
mRecentBookmark
;
class
VisitHashKey
:
public
nsURIHashKey
{
public
:
explicit
VisitHashKey
(
const
nsIURI
*
aURI
)
:
nsURIHashKey
(
aURI
)
{
}
VisitHashKey
(
const
VisitHashKey
&
aOther
)
:
nsURIHashKey
(
aOther
)
{
NS_NOTREACHED
(
"
Do
not
call
me
!
"
)
;
}
PRTime
visitTime
;
}
;
nsTHashtable
<
VisitHashKey
>
mEmbedVisits
;
bool
CheckIsRecentEvent
(
RecentEventHash
*
hashTable
const
nsACString
&
url
)
;
void
ExpireNonrecentEvents
(
RecentEventHash
*
hashTable
)
;
#
ifdef
MOZ_XUL
nsresult
AutoCompleteFeedback
(
int32_t
aIndex
nsIAutoCompleteController
*
aController
)
;
#
endif
bool
mHistoryEnabled
;
int32_t
mNumVisitsForFrecency
;
int32_t
mFirstBucketCutoffInDays
;
int32_t
mSecondBucketCutoffInDays
;
int32_t
mThirdBucketCutoffInDays
;
int32_t
mFourthBucketCutoffInDays
;
int32_t
mFirstBucketWeight
;
int32_t
mSecondBucketWeight
;
int32_t
mThirdBucketWeight
;
int32_t
mFourthBucketWeight
;
int32_t
mDefaultWeight
;
int32_t
mEmbedVisitBonus
;
int32_t
mFramedLinkVisitBonus
;
int32_t
mLinkVisitBonus
;
int32_t
mTypedVisitBonus
;
int32_t
mBookmarkVisitBonus
;
int32_t
mDownloadVisitBonus
;
int32_t
mPermRedirectVisitBonus
;
int32_t
mTempRedirectVisitBonus
;
int32_t
mRedirectSourceVisitBonus
;
int32_t
mDefaultVisitBonus
;
int32_t
mUnvisitedBookmarkBonus
;
int32_t
mUnvisitedTypedBonus
;
int32_t
mReloadVisitBonus
;
nsresult
TokensToQuery
(
const
nsTArray
<
QueryKeyValuePair
>
&
aTokens
nsNavHistoryQuery
*
aQuery
nsNavHistoryQueryOptions
*
aOptions
)
;
int64_t
mTagsFolder
;
int32_t
mDaysOfHistory
;
int64_t
mLastCachedStartOfDay
;
int64_t
mLastCachedEndOfDay
;
bool
mCanNotify
;
#
ifdef
XP_WIN
HCRYPTPROV
mCryptoProvider
;
bool
mCryptoProviderInitialized
;
#
endif
}
;
#
define
PLACES_URI_PREFIX
"
place
:
"
inline
bool
IsQueryURI
(
const
nsCString
&
uri
)
{
return
StringBeginsWith
(
uri
NS_LITERAL_CSTRING
(
PLACES_URI_PREFIX
)
)
;
}
inline
const
nsDependentCSubstring
QueryURIToQuery
(
const
nsCString
&
uri
)
{
NS_ASSERTION
(
IsQueryURI
(
uri
)
"
should
only
be
called
for
query
URIs
"
)
;
return
Substring
(
uri
NS_LITERAL_CSTRING
(
PLACES_URI_PREFIX
)
.
Length
(
)
)
;
}
#
endif
