#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
History
.
h
"
#
include
"
nsNavHistory
.
h
"
#
include
"
nsNavBookmarks
.
h
"
#
include
"
Helpers
.
h
"
#
include
"
PlaceInfo
.
h
"
#
include
"
VisitInfo
.
h
"
#
include
"
nsPlacesMacros
.
h
"
#
include
"
mozilla
/
storage
.
h
"
#
include
"
mozilla
/
dom
/
Link
.
h
"
#
include
"
nsDocShellCID
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIFileURL
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
PlacesObservers
.
h
"
#
include
"
mozilla
/
dom
/
PlacesVisit
.
h
"
#
include
"
mozilla
/
dom
/
ProcessGlobal
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
define
VISIT_OBSERVERS_INITIAL_CACHE_LENGTH
64
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
ipc
;
using
mozilla
:
:
Unused
;
namespace
mozilla
{
namespace
places
{
#
define
URI_VISITED
"
visited
"
#
define
URI_NOT_VISITED
"
not
visited
"
#
define
URI_VISITED_RESOLUTION_TOPIC
"
visited
-
status
-
resolution
"
#
define
URI_VISIT_SAVED
"
uri
-
visit
-
saved
"
#
define
DESTINATIONFILEURI_ANNO
\
NS_LITERAL_CSTRING
(
"
downloads
/
destinationFileURI
"
)
struct
VisitData
{
VisitData
(
)
:
placeId
(
0
)
visitId
(
0
)
hidden
(
true
)
shouldUpdateHidden
(
true
)
typed
(
false
)
transitionType
(
UINT32_MAX
)
visitTime
(
0
)
frecency
(
-
1
)
lastVisitId
(
0
)
lastVisitTime
(
0
)
visitCount
(
0
)
referrerVisitId
(
0
)
titleChanged
(
false
)
shouldUpdateFrecency
(
true
)
useFrecencyRedirectBonus
(
false
)
{
guid
.
SetIsVoid
(
true
)
;
title
.
SetIsVoid
(
true
)
;
}
explicit
VisitData
(
nsIURI
*
aURI
nsIURI
*
aReferrer
=
nullptr
)
:
placeId
(
0
)
visitId
(
0
)
hidden
(
true
)
shouldUpdateHidden
(
true
)
typed
(
false
)
transitionType
(
UINT32_MAX
)
visitTime
(
0
)
frecency
(
-
1
)
lastVisitId
(
0
)
lastVisitTime
(
0
)
visitCount
(
0
)
referrerVisitId
(
0
)
titleChanged
(
false
)
shouldUpdateFrecency
(
true
)
useFrecencyRedirectBonus
(
false
)
{
MOZ_ASSERT
(
aURI
)
;
if
(
aURI
)
{
(
void
)
aURI
-
>
GetSpec
(
spec
)
;
(
void
)
GetReversedHostname
(
aURI
revHost
)
;
}
if
(
aReferrer
)
{
(
void
)
aReferrer
-
>
GetSpec
(
referrerSpec
)
;
}
guid
.
SetIsVoid
(
true
)
;
title
.
SetIsVoid
(
true
)
;
}
void
SetTransitionType
(
uint32_t
aTransitionType
)
{
typed
=
aTransitionType
=
=
nsINavHistoryService
:
:
TRANSITION_TYPED
;
transitionType
=
aTransitionType
;
}
int64_t
placeId
;
nsCString
guid
;
int64_t
visitId
;
nsCString
spec
;
nsString
revHost
;
bool
hidden
;
bool
shouldUpdateHidden
;
bool
typed
;
uint32_t
transitionType
;
PRTime
visitTime
;
int32_t
frecency
;
int64_t
lastVisitId
;
PRTime
lastVisitTime
;
uint32_t
visitCount
;
nsString
title
;
nsCString
referrerSpec
;
int64_t
referrerVisitId
;
bool
titleChanged
;
bool
shouldUpdateFrecency
;
bool
useFrecencyRedirectBonus
;
}
;
namespace
{
nsresult
GetJSArrayFromJSValue
(
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
JSContext
*
aCtx
JS
:
:
MutableHandle
<
JSObject
*
>
_array
uint32_t
*
_arrayLength
)
{
if
(
aValue
.
isObjectOrNull
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
val
(
aCtx
aValue
.
toObjectOrNull
(
)
)
;
bool
isArray
;
if
(
!
JS_IsArrayObject
(
aCtx
val
&
isArray
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
isArray
)
{
_array
.
set
(
val
)
;
(
void
)
JS_GetArrayLength
(
aCtx
_array
_arrayLength
)
;
NS_ENSURE_ARG
(
*
_arrayLength
>
0
)
;
return
NS_OK
;
}
}
*
_arrayLength
=
1
;
_array
.
set
(
JS_NewArrayObject
(
aCtx
0
)
)
;
NS_ENSURE_TRUE
(
_array
NS_ERROR_OUT_OF_MEMORY
)
;
bool
rc
=
JS_DefineElement
(
aCtx
_array
0
aValue
0
)
;
NS_ENSURE_TRUE
(
rc
NS_ERROR_UNEXPECTED
)
;
return
NS_OK
;
}
already_AddRefed
<
nsIURI
>
GetJSValueAsURI
(
JSContext
*
aCtx
const
JS
:
:
Value
&
aValue
)
{
if
(
!
aValue
.
isPrimitive
(
)
)
{
nsCOMPtr
<
nsIXPConnect
>
xpc
=
mozilla
:
:
services
:
:
GetXPConnect
(
)
;
nsCOMPtr
<
nsIXPConnectWrappedNative
>
wrappedObj
;
nsresult
rv
=
xpc
-
>
GetWrappedNativeOfJSObject
(
aCtx
aValue
.
toObjectOrNull
(
)
getter_AddRefs
(
wrappedObj
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
nsCOMPtr
<
nsIURI
>
uri
=
do_QueryWrappedNative
(
wrappedObj
)
;
return
uri
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
nsIURI
>
GetURIFromJSObject
(
JSContext
*
aCtx
JS
:
:
Handle
<
JSObject
*
>
aObject
const
char
*
aProperty
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
uriVal
(
aCtx
)
;
bool
rc
=
JS_GetProperty
(
aCtx
aObject
aProperty
&
uriVal
)
;
NS_ENSURE_TRUE
(
rc
nullptr
)
;
return
GetJSValueAsURI
(
aCtx
uriVal
)
;
}
void
GetJSValueAsString
(
JSContext
*
aCtx
const
JS
:
:
Value
&
aValue
nsString
&
_string
)
{
if
(
aValue
.
isUndefined
(
)
|
|
!
(
aValue
.
isNull
(
)
|
|
aValue
.
isString
(
)
)
)
{
_string
.
SetIsVoid
(
true
)
;
return
;
}
if
(
aValue
.
isNull
(
)
)
{
_string
.
Truncate
(
)
;
return
;
}
if
(
!
AssignJSString
(
aCtx
_string
aValue
.
toString
(
)
)
)
{
_string
.
SetIsVoid
(
true
)
;
}
}
void
GetStringFromJSObject
(
JSContext
*
aCtx
JS
:
:
Handle
<
JSObject
*
>
aObject
const
char
*
aProperty
nsString
&
_string
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
aCtx
)
;
bool
rc
=
JS_GetProperty
(
aCtx
aObject
aProperty
&
val
)
;
if
(
!
rc
)
{
_string
.
SetIsVoid
(
true
)
;
return
;
}
else
{
GetJSValueAsString
(
aCtx
val
_string
)
;
}
}
template
<
typename
IntType
>
nsresult
GetIntFromJSObject
(
JSContext
*
aCtx
JS
:
:
Handle
<
JSObject
*
>
aObject
const
char
*
aProperty
IntType
*
_int
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCtx
)
;
bool
rc
=
JS_GetProperty
(
aCtx
aObject
aProperty
&
value
)
;
NS_ENSURE_TRUE
(
rc
NS_ERROR_UNEXPECTED
)
;
if
(
value
.
isUndefined
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
NS_ENSURE_ARG
(
value
.
isPrimitive
(
)
)
;
NS_ENSURE_ARG
(
value
.
isNumber
(
)
)
;
double
num
;
rc
=
JS
:
:
ToNumber
(
aCtx
value
&
num
)
;
NS_ENSURE_TRUE
(
rc
NS_ERROR_UNEXPECTED
)
;
NS_ENSURE_ARG
(
IntType
(
num
)
=
=
num
)
;
*
_int
=
IntType
(
num
)
;
return
NS_OK
;
}
nsresult
GetJSObjectFromArray
(
JSContext
*
aCtx
JS
:
:
Handle
<
JSObject
*
>
aArray
uint32_t
aIndex
JS
:
:
MutableHandle
<
JSObject
*
>
objOut
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCtx
)
;
bool
rc
=
JS_GetElement
(
aCtx
aArray
aIndex
&
value
)
;
NS_ENSURE_TRUE
(
rc
NS_ERROR_UNEXPECTED
)
;
NS_ENSURE_ARG
(
!
value
.
isPrimitive
(
)
)
;
objOut
.
set
(
&
value
.
toObject
(
)
)
;
return
NS_OK
;
}
class
VisitedQuery
final
:
public
AsyncStatementCallback
public
mozIStorageCompletionCallback
{
public
:
NS_DECL_ISUPPORTS_INHERITED
static
nsresult
Start
(
nsIURI
*
aURI
mozIVisitedStatusCallback
*
aCallback
=
nullptr
)
{
MOZ_ASSERT
(
aURI
"
Null
URI
"
)
;
if
(
XRE_IsContentProcess
(
)
)
{
URIParams
uri
;
SerializeURI
(
aURI
uri
)
;
mozilla
:
:
dom
:
:
ContentChild
*
cpc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
NS_ASSERTION
(
cpc
"
Content
Protocol
is
NULL
!
"
)
;
(
void
)
cpc
-
>
SendStartVisitedQuery
(
uri
)
;
return
NS_OK
;
}
nsMainThreadPtrHandle
<
mozIVisitedStatusCallback
>
callback
(
new
nsMainThreadPtrHolder
<
mozIVisitedStatusCallback
>
(
"
mozIVisitedStatusCallback
"
aCallback
)
)
;
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_STATE
(
navHistory
)
;
if
(
navHistory
-
>
hasEmbedVisit
(
aURI
)
)
{
RefPtr
<
VisitedQuery
>
cb
=
new
VisitedQuery
(
aURI
callback
true
)
;
NS_ENSURE_TRUE
(
cb
NS_ERROR_OUT_OF_MEMORY
)
;
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
places
:
:
VisitedQuery
:
:
NotifyVisitedStatus
"
cb
&
VisitedQuery
:
:
NotifyVisitedStatus
)
)
;
return
NS_OK
;
}
History
*
history
=
History
:
:
GetService
(
)
;
NS_ENSURE_STATE
(
history
)
;
RefPtr
<
VisitedQuery
>
cb
=
new
VisitedQuery
(
aURI
callback
)
;
NS_ENSURE_TRUE
(
cb
NS_ERROR_OUT_OF_MEMORY
)
;
nsresult
rv
=
history
-
>
GetIsVisitedStatement
(
cb
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHOD
Complete
(
nsresult
aResult
nsISupports
*
aStatement
)
override
{
NS_ENSURE_SUCCESS
(
aResult
aResult
)
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
stmt
=
do_QueryInterface
(
aStatement
)
;
NS_ENSURE_STATE
(
stmt
)
;
nsresult
rv
=
URIBinder
:
:
Bind
(
stmt
0
mURI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
handle
;
return
stmt
-
>
ExecuteAsync
(
this
getter_AddRefs
(
handle
)
)
;
}
NS_IMETHOD
HandleResult
(
mozIStorageResultSet
*
aResults
)
override
{
mIsVisited
=
true
;
return
NS_OK
;
}
NS_IMETHOD
HandleError
(
mozIStorageError
*
aError
)
override
{
return
NS_OK
;
}
NS_IMETHOD
HandleCompletion
(
uint16_t
aReason
)
override
{
if
(
aReason
!
=
mozIStorageStatementCallback
:
:
REASON_FINISHED
)
{
return
NS_OK
;
}
nsresult
rv
=
NotifyVisitedStatus
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
NotifyVisitedStatus
(
)
{
if
(
!
!
mCallback
)
{
mCallback
-
>
IsVisited
(
mURI
mIsVisited
)
;
return
NS_OK
;
}
if
(
mIsVisited
)
{
History
*
history
=
History
:
:
GetService
(
)
;
NS_ENSURE_STATE
(
history
)
;
history
-
>
NotifyVisited
(
mURI
)
;
AutoTArray
<
URIParams
1
>
uris
;
URIParams
uri
;
SerializeURI
(
mURI
uri
)
;
uris
.
AppendElement
(
std
:
:
move
(
uri
)
)
;
history
-
>
NotifyVisitedParent
(
uris
)
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
nsAutoString
status
;
if
(
mIsVisited
)
{
status
.
AssignLiteral
(
URI_VISITED
)
;
}
else
{
status
.
AssignLiteral
(
URI_NOT_VISITED
)
;
}
(
void
)
observerService
-
>
NotifyObservers
(
mURI
URI_VISITED_RESOLUTION_TOPIC
status
.
get
(
)
)
;
}
return
NS_OK
;
}
private
:
explicit
VisitedQuery
(
nsIURI
*
aURI
const
nsMainThreadPtrHandle
<
mozIVisitedStatusCallback
>
&
aCallback
bool
aIsVisited
=
false
)
:
mURI
(
aURI
)
mCallback
(
aCallback
)
mIsVisited
(
aIsVisited
)
{
}
~
VisitedQuery
(
)
{
}
nsCOMPtr
<
nsIURI
>
mURI
;
nsMainThreadPtrHandle
<
mozIVisitedStatusCallback
>
mCallback
;
bool
mIsVisited
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
VisitedQuery
AsyncStatementCallback
mozIStorageCompletionCallback
)
class
NotifyManyVisitsObservers
:
public
Runnable
{
public
:
explicit
NotifyManyVisitsObservers
(
const
VisitData
&
aPlace
)
:
Runnable
(
"
places
:
:
NotifyManyVisitsObservers
"
)
mPlace
(
aPlace
)
mHistory
(
History
:
:
GetService
(
)
)
{
}
explicit
NotifyManyVisitsObservers
(
nsTArray
<
VisitData
>
&
aPlaces
)
:
Runnable
(
"
places
:
:
NotifyManyVisitsObservers
"
)
mHistory
(
History
:
:
GetService
(
)
)
{
aPlaces
.
SwapElements
(
mPlaces
)
;
}
nsresult
NotifyVisit
(
nsNavHistory
*
aNavHistory
nsCOMPtr
<
nsIObserverService
>
&
aObsService
PRTime
aNow
nsIURI
*
aURI
const
VisitData
&
aPlace
)
{
if
(
aObsService
)
{
DebugOnly
<
nsresult
>
rv
=
aObsService
-
>
NotifyObservers
(
aURI
URI_VISIT_SAVED
nullptr
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Could
not
notify
observers
"
)
;
}
if
(
aNow
-
aPlace
.
visitTime
<
RECENTLY_VISITED_URIS_MAX_AGE
)
{
mHistory
-
>
AppendToRecentlyVisitedURIs
(
aURI
)
;
}
mHistory
-
>
NotifyVisited
(
aURI
)
;
if
(
aPlace
.
titleChanged
)
{
aNavHistory
-
>
NotifyTitleChange
(
aURI
aPlace
.
title
aPlace
.
guid
)
;
}
aNavHistory
-
>
UpdateDaysOfHistory
(
aPlace
.
visitTime
)
;
return
NS_OK
;
}
void
AddPlaceForNotify
(
const
VisitData
&
aPlace
nsIURI
*
aURI
Sequence
<
OwningNonNull
<
PlacesEvent
>
>
&
aEvents
)
{
if
(
aPlace
.
transitionType
!
=
nsINavHistoryService
:
:
TRANSITION_EMBED
)
{
RefPtr
<
PlacesVisit
>
vd
=
new
PlacesVisit
(
)
;
vd
-
>
mVisitId
=
aPlace
.
visitId
;
vd
-
>
mUrl
.
Assign
(
NS_ConvertUTF8toUTF16
(
aPlace
.
spec
)
)
;
vd
-
>
mVisitTime
=
aPlace
.
visitTime
/
1000
;
vd
-
>
mReferringVisitId
=
aPlace
.
referrerVisitId
;
vd
-
>
mTransitionType
=
aPlace
.
transitionType
;
vd
-
>
mPageGuid
.
Assign
(
aPlace
.
guid
)
;
vd
-
>
mHidden
=
aPlace
.
hidden
;
vd
-
>
mVisitCount
=
aPlace
.
visitCount
+
1
;
vd
-
>
mTypedCount
=
static_cast
<
uint32_t
>
(
aPlace
.
typed
)
;
vd
-
>
mLastKnownTitle
.
Assign
(
aPlace
.
title
)
;
bool
success
=
!
!
aEvents
.
AppendElement
(
vd
.
forget
(
)
fallible
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
}
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
This
should
be
called
on
the
main
thread
"
)
;
if
(
mHistory
-
>
IsShuttingDown
(
)
)
{
return
NS_OK
;
}
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
if
(
!
navHistory
)
{
NS_WARNING
(
"
Trying
to
notify
visits
observers
but
cannot
get
the
history
service
!
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
Sequence
<
OwningNonNull
<
PlacesEvent
>
>
events
;
nsCOMArray
<
nsIURI
>
uris
;
if
(
mPlaces
.
Length
(
)
>
0
)
{
for
(
uint32_t
i
=
0
;
i
<
mPlaces
.
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
uri
)
mPlaces
[
i
]
.
spec
)
)
;
if
(
!
uri
)
{
return
NS_ERROR_UNEXPECTED
;
}
AddPlaceForNotify
(
mPlaces
[
i
]
uri
events
)
;
uris
.
AppendElement
(
uri
.
forget
(
)
)
;
}
}
else
{
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
uri
)
mPlace
.
spec
)
)
;
if
(
!
uri
)
{
return
NS_ERROR_UNEXPECTED
;
}
AddPlaceForNotify
(
mPlace
uri
events
)
;
uris
.
AppendElement
(
uri
.
forget
(
)
)
;
}
if
(
events
.
Length
(
)
>
0
)
{
PlacesObservers
:
:
NotifyListeners
(
events
)
;
}
PRTime
now
=
PR_Now
(
)
;
if
(
mPlaces
.
Length
(
)
>
0
)
{
InfallibleTArray
<
URIParams
>
serializableUris
(
mPlaces
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mPlaces
.
Length
(
)
;
+
+
i
)
{
nsresult
rv
=
NotifyVisit
(
navHistory
obsService
now
uris
[
i
]
mPlaces
[
i
]
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
URIParams
serializedUri
;
SerializeURI
(
uris
[
i
]
serializedUri
)
;
serializableUris
.
AppendElement
(
std
:
:
move
(
serializedUri
)
)
;
}
mHistory
-
>
NotifyVisitedParent
(
serializableUris
)
;
}
else
{
AutoTArray
<
URIParams
1
>
serializableUris
;
nsresult
rv
=
NotifyVisit
(
navHistory
obsService
now
uris
[
0
]
mPlace
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
URIParams
serializedUri
;
SerializeURI
(
uris
[
0
]
serializedUri
)
;
serializableUris
.
AppendElement
(
std
:
:
move
(
serializedUri
)
)
;
mHistory
-
>
NotifyVisitedParent
(
serializableUris
)
;
}
return
NS_OK
;
}
private
:
nsTArray
<
VisitData
>
mPlaces
;
VisitData
mPlace
;
RefPtr
<
History
>
mHistory
;
}
;
class
NotifyTitleObservers
:
public
Runnable
{
public
:
NotifyTitleObservers
(
const
nsCString
&
aSpec
const
nsString
&
aTitle
const
nsCString
&
aGUID
)
:
Runnable
(
"
places
:
:
NotifyTitleObservers
"
)
mSpec
(
aSpec
)
mTitle
(
aTitle
)
mGUID
(
aGUID
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
This
should
be
called
on
the
main
thread
"
)
;
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
navHistory
NS_ERROR_OUT_OF_MEMORY
)
;
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
uri
)
mSpec
)
)
;
if
(
!
uri
)
{
return
NS_ERROR_UNEXPECTED
;
}
navHistory
-
>
NotifyTitleChange
(
uri
mTitle
mGUID
)
;
return
NS_OK
;
}
private
:
const
nsCString
mSpec
;
const
nsString
mTitle
;
const
nsCString
mGUID
;
}
;
class
NotifyPlaceInfoCallback
:
public
Runnable
{
public
:
NotifyPlaceInfoCallback
(
const
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
&
aCallback
const
VisitData
&
aPlace
bool
aIsSingleVisit
nsresult
aResult
)
:
Runnable
(
"
places
:
:
NotifyPlaceInfoCallback
"
)
mCallback
(
aCallback
)
mPlace
(
aPlace
)
mResult
(
aResult
)
mIsSingleVisit
(
aIsSingleVisit
)
{
MOZ_ASSERT
(
aCallback
"
Must
pass
a
non
-
null
callback
!
"
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
This
should
be
called
on
the
main
thread
"
)
;
bool
hasValidURIs
=
true
;
nsCOMPtr
<
nsIURI
>
referrerURI
;
if
(
!
mPlace
.
referrerSpec
.
IsEmpty
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
referrerURI
)
mPlace
.
referrerSpec
)
)
;
hasValidURIs
=
!
!
referrerURI
;
}
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
uri
)
mPlace
.
spec
)
)
;
hasValidURIs
=
hasValidURIs
&
&
!
!
uri
;
nsCOMPtr
<
mozIPlaceInfo
>
place
;
if
(
mIsSingleVisit
)
{
nsCOMPtr
<
mozIVisitInfo
>
visit
=
new
VisitInfo
(
mPlace
.
visitId
mPlace
.
visitTime
mPlace
.
transitionType
referrerURI
.
forget
(
)
)
;
PlaceInfo
:
:
VisitsArray
visits
;
(
void
)
visits
.
AppendElement
(
visit
)
;
place
=
new
PlaceInfo
(
mPlace
.
placeId
mPlace
.
guid
uri
.
forget
(
)
mPlace
.
title
-
1
visits
)
;
}
else
{
place
=
new
PlaceInfo
(
mPlace
.
placeId
mPlace
.
guid
uri
.
forget
(
)
mPlace
.
title
-
1
)
;
}
if
(
NS_SUCCEEDED
(
mResult
)
&
&
hasValidURIs
)
{
(
void
)
mCallback
-
>
HandleResult
(
place
)
;
}
else
{
(
void
)
mCallback
-
>
HandleError
(
mResult
place
)
;
}
return
NS_OK
;
}
private
:
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
mCallback
;
VisitData
mPlace
;
const
nsresult
mResult
;
bool
mIsSingleVisit
;
}
;
class
NotifyCompletion
:
public
Runnable
{
public
:
explicit
NotifyCompletion
(
const
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
&
aCallback
uint32_t
aUpdatedCount
=
0
)
:
Runnable
(
"
places
:
:
NotifyCompletion
"
)
mCallback
(
aCallback
)
mUpdatedCount
(
aUpdatedCount
)
{
MOZ_ASSERT
(
aCallback
"
Must
pass
a
non
-
null
callback
!
"
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
NS_IsMainThread
(
)
)
{
(
void
)
mCallback
-
>
HandleCompletion
(
mUpdatedCount
)
;
}
else
{
(
void
)
NS_DispatchToMainThread
(
this
)
;
}
return
NS_OK
;
}
private
:
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
mCallback
;
uint32_t
mUpdatedCount
;
}
;
bool
CanAddURI
(
nsIURI
*
aURI
const
nsCString
&
aGUID
=
EmptyCString
(
)
mozIVisitInfoCallback
*
aCallback
=
nullptr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
navHistory
false
)
;
bool
canAdd
;
nsresult
rv
=
navHistory
-
>
CanAddURI
(
aURI
&
canAdd
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
canAdd
)
{
return
true
;
}
;
if
(
aCallback
)
{
VisitData
place
(
aURI
)
;
place
.
guid
=
aGUID
;
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
callback
(
new
nsMainThreadPtrHolder
<
mozIVisitInfoCallback
>
(
"
mozIVisitInfoCallback
"
aCallback
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyPlaceInfoCallback
(
callback
place
true
NS_ERROR_INVALID_ARG
)
;
(
void
)
NS_DispatchToMainThread
(
event
)
;
}
return
false
;
}
class
NotifyManyFrecenciesChanged
final
:
public
Runnable
{
public
:
NotifyManyFrecenciesChanged
(
)
:
Runnable
(
"
places
:
:
NotifyManyFrecenciesChanged
"
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
This
should
be
called
on
the
main
thread
"
)
;
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_STATE
(
navHistory
)
;
navHistory
-
>
NotifyManyFrecenciesChanged
(
)
;
return
NS_OK
;
}
}
;
class
InsertVisitedURIs
final
:
public
Runnable
{
public
:
static
nsresult
Start
(
mozIStorageConnection
*
aConnection
nsTArray
<
VisitData
>
&
aPlaces
mozIVisitInfoCallback
*
aCallback
=
nullptr
bool
aGroupNotifications
=
false
uint32_t
aInitialUpdatedCount
=
0
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
This
should
be
called
on
the
main
thread
"
)
;
MOZ_ASSERT
(
aPlaces
.
Length
(
)
>
0
"
Must
pass
a
non
-
empty
array
!
"
)
;
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
MOZ_ASSERT
(
navHistory
"
Could
not
get
nsNavHistory
?
!
"
)
;
if
(
!
navHistory
)
{
return
NS_ERROR_FAILURE
;
}
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
callback
(
new
nsMainThreadPtrHolder
<
mozIVisitInfoCallback
>
(
"
mozIVisitInfoCallback
"
aCallback
)
)
;
bool
ignoreErrors
=
false
ignoreResults
=
false
;
if
(
aCallback
)
{
Unused
<
<
aCallback
-
>
GetIgnoreErrors
(
&
ignoreErrors
)
;
Unused
<
<
aCallback
-
>
GetIgnoreResults
(
&
ignoreResults
)
;
}
RefPtr
<
InsertVisitedURIs
>
event
=
new
InsertVisitedURIs
(
aConnection
aPlaces
callback
aGroupNotifications
ignoreErrors
ignoreResults
aInitialUpdatedCount
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetInterface
(
aConnection
)
;
NS_ENSURE_TRUE
(
target
NS_ERROR_UNEXPECTED
)
;
nsresult
rv
=
target
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
This
should
not
be
called
on
the
main
thread
"
)
;
nsresult
rv
=
InnerRun
(
)
;
if
(
mSuccessfulUpdatedCount
>
0
&
&
mGroupNotifications
)
{
NS_DispatchToMainThread
(
new
NotifyManyFrecenciesChanged
(
)
)
;
}
if
(
!
!
mCallback
)
{
NS_DispatchToMainThread
(
new
NotifyCompletion
(
mCallback
mSuccessfulUpdatedCount
)
)
;
}
return
rv
;
}
nsresult
InnerRun
(
)
{
MutexAutoLock
lockedScope
(
mHistory
-
>
GetShutdownMutex
(
)
)
;
if
(
mHistory
-
>
IsShuttingDown
(
)
)
{
return
NS_OK
;
}
mozStorageTransaction
transaction
(
mDBConn
false
mozIStorageConnection
:
:
TRANSACTION_IMMEDIATE
)
;
const
VisitData
*
lastFetchedPlace
=
nullptr
;
uint32_t
lastFetchedVisitCount
=
0
;
bool
shouldChunkNotifications
=
mPlaces
.
Length
(
)
>
NOTIFY_VISITS_CHUNK_SIZE
;
InfallibleTArray
<
VisitData
>
notificationChunk
;
if
(
shouldChunkNotifications
)
{
notificationChunk
.
SetCapacity
(
NOTIFY_VISITS_CHUNK_SIZE
)
;
}
for
(
nsTArray
<
VisitData
>
:
:
size_type
i
=
0
;
i
<
mPlaces
.
Length
(
)
;
i
+
+
)
{
VisitData
&
place
=
mPlaces
.
ElementAt
(
i
)
;
bool
typed
=
place
.
typed
;
bool
hidden
=
place
.
hidden
;
bool
known
=
lastFetchedPlace
&
&
lastFetchedPlace
-
>
spec
.
Equals
(
place
.
spec
)
;
if
(
!
known
)
{
nsresult
rv
=
mHistory
-
>
FetchPageInfo
(
place
&
known
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
!
!
mCallback
&
&
!
mIgnoreErrors
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyPlaceInfoCallback
(
mCallback
place
true
rv
)
;
return
NS_DispatchToMainThread
(
event
)
;
}
return
NS_OK
;
}
lastFetchedPlace
=
&
mPlaces
.
ElementAt
(
i
)
;
lastFetchedVisitCount
=
lastFetchedPlace
-
>
visitCount
;
}
else
{
place
.
placeId
=
lastFetchedPlace
-
>
placeId
;
place
.
guid
=
lastFetchedPlace
-
>
guid
;
place
.
lastVisitId
=
lastFetchedPlace
-
>
visitId
;
place
.
lastVisitTime
=
lastFetchedPlace
-
>
visitTime
;
if
(
!
place
.
title
.
IsVoid
(
)
)
{
place
.
titleChanged
=
!
lastFetchedPlace
-
>
title
.
Equals
(
place
.
title
)
;
}
place
.
frecency
=
lastFetchedPlace
-
>
frecency
;
place
.
visitCount
=
+
+
lastFetchedVisitCount
;
}
if
(
typed
!
=
lastFetchedPlace
-
>
typed
)
{
place
.
typed
=
true
;
}
if
(
hidden
!
=
lastFetchedPlace
-
>
hidden
)
{
place
.
hidden
=
false
;
}
if
(
!
known
|
|
!
lastFetchedPlace
-
>
hidden
)
{
place
.
shouldUpdateHidden
=
false
;
}
FetchReferrerInfo
(
place
)
;
nsresult
rv
=
DoDatabaseInserts
(
known
place
)
;
if
(
!
!
mCallback
)
{
if
(
(
NS_SUCCEEDED
(
rv
)
&
&
!
mIgnoreResults
)
|
|
(
NS_FAILED
(
rv
)
&
&
!
mIgnoreErrors
)
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyPlaceInfoCallback
(
mCallback
place
true
rv
)
;
nsresult
rv2
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv2
rv2
)
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
shouldChunkNotifications
)
{
int32_t
numRemaining
=
mPlaces
.
Length
(
)
-
(
i
+
1
)
;
notificationChunk
.
AppendElement
(
place
)
;
if
(
notificationChunk
.
Length
(
)
=
=
NOTIFY_VISITS_CHUNK_SIZE
|
|
numRemaining
=
=
0
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyManyVisitsObservers
(
notificationChunk
)
;
rv
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
nextCapacity
=
std
:
:
min
(
NOTIFY_VISITS_CHUNK_SIZE
numRemaining
)
;
notificationChunk
.
SetCapacity
(
nextCapacity
)
;
}
}
mSuccessfulUpdatedCount
+
+
;
}
{
nsAutoCString
query
(
"
DELETE
FROM
moz_updateoriginsinsert_temp
"
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
mHistory
-
>
GetStatement
(
query
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
nsresult
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
{
nsAutoCString
query
(
"
DELETE
FROM
moz_updateoriginsupdate_temp
"
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
mHistory
-
>
GetStatement
(
query
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
nsresult
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsresult
rv
=
transaction
.
Commit
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
shouldChunkNotifications
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyManyVisitsObservers
(
mPlaces
)
;
rv
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
private
:
InsertVisitedURIs
(
mozIStorageConnection
*
aConnection
nsTArray
<
VisitData
>
&
aPlaces
const
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
&
aCallback
bool
aGroupNotifications
bool
aIgnoreErrors
bool
aIgnoreResults
uint32_t
aInitialUpdatedCount
)
:
Runnable
(
"
places
:
:
InsertVisitedURIs
"
)
mDBConn
(
aConnection
)
mCallback
(
aCallback
)
mGroupNotifications
(
aGroupNotifications
)
mIgnoreErrors
(
aIgnoreErrors
)
mIgnoreResults
(
aIgnoreResults
)
mSuccessfulUpdatedCount
(
aInitialUpdatedCount
)
mHistory
(
History
:
:
GetService
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
This
should
be
called
on
the
main
thread
"
)
;
mPlaces
.
SwapElements
(
aPlaces
)
;
#
ifdef
DEBUG
for
(
nsTArray
<
VisitData
>
:
:
size_type
i
=
0
;
i
<
mPlaces
.
Length
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
NS_NewURI
(
getter_AddRefs
(
uri
)
mPlaces
[
i
]
.
spec
)
)
)
;
MOZ_ASSERT
(
CanAddURI
(
uri
)
"
Passed
a
VisitData
with
a
URI
we
cannot
add
to
history
!
"
)
;
}
#
endif
}
nsresult
DoDatabaseInserts
(
bool
aKnown
VisitData
&
aPlace
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
This
should
not
be
called
on
the
main
thread
"
)
;
nsresult
rv
;
if
(
aKnown
)
{
rv
=
mHistory
-
>
UpdatePlace
(
aPlace
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
mHistory
-
>
InsertPlace
(
aPlace
!
mGroupNotifications
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aPlace
.
placeId
=
nsNavHistory
:
:
sLastInsertedPlaceId
;
}
MOZ_ASSERT
(
aPlace
.
placeId
>
0
)
;
rv
=
AddVisit
(
aPlace
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aPlace
.
shouldUpdateFrecency
)
{
rv
=
UpdateFrecency
(
aPlace
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
void
FetchReferrerInfo
(
VisitData
&
aPlace
)
{
if
(
aPlace
.
referrerSpec
.
IsEmpty
(
)
)
{
return
;
}
VisitData
referrer
;
referrer
.
spec
=
aPlace
.
referrerSpec
;
if
(
aPlace
.
referrerSpec
.
Equals
(
aPlace
.
spec
)
)
{
referrer
=
aPlace
;
aPlace
.
referrerVisitId
=
aPlace
.
lastVisitId
;
}
else
{
bool
exists
=
false
;
if
(
NS_SUCCEEDED
(
mHistory
-
>
FetchPageInfo
(
referrer
&
exists
)
)
&
&
exists
)
{
aPlace
.
referrerVisitId
=
referrer
.
lastVisitId
;
}
}
if
(
!
aPlace
.
referrerVisitId
|
|
!
referrer
.
lastVisitTime
|
|
aPlace
.
visitTime
-
referrer
.
lastVisitTime
>
RECENT_EVENT_THRESHOLD
)
{
aPlace
.
referrerSpec
.
Truncate
(
)
;
aPlace
.
referrerVisitId
=
0
;
}
}
nsresult
AddVisit
(
VisitData
&
_place
)
{
MOZ_ASSERT
(
_place
.
placeId
>
0
)
;
nsresult
rv
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
stmt
=
mHistory
-
>
GetStatement
(
"
INSERT
INTO
moz_historyvisits
"
"
(
from_visit
place_id
visit_date
visit_type
session
)
"
"
VALUES
(
:
from_visit
:
page_id
:
visit_date
:
visit_type
0
)
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
page_id
"
)
_place
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
from_visit
"
)
_place
.
referrerVisitId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
visit_date
"
)
_place
.
visitTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
transitionType
=
_place
.
transitionType
;
MOZ_ASSERT
(
transitionType
>
=
nsINavHistoryService
:
:
TRANSITION_LINK
&
&
transitionType
<
=
nsINavHistoryService
:
:
TRANSITION_RELOAD
"
Invalid
transition
type
!
"
)
;
rv
=
stmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
visit_type
"
)
transitionType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
_place
.
visitId
=
nsNavHistory
:
:
sLastInsertedVisitId
;
MOZ_ASSERT
(
_place
.
visitId
>
0
)
;
return
NS_OK
;
}
nsresult
UpdateFrecency
(
const
VisitData
&
aPlace
)
{
MOZ_ASSERT
(
aPlace
.
shouldUpdateFrecency
)
;
MOZ_ASSERT
(
aPlace
.
placeId
>
0
)
;
nsresult
rv
;
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
if
(
!
mGroupNotifications
)
{
stmt
=
mHistory
-
>
GetStatement
(
"
UPDATE
moz_places
"
"
SET
frecency
=
NOTIFY_FRECENCY
(
"
"
CALCULATE_FRECENCY
(
:
page_id
:
redirect
)
"
"
url
guid
hidden
last_visit_date
"
"
)
"
"
WHERE
id
=
:
page_id
"
)
;
}
else
{
stmt
=
mHistory
-
>
GetStatement
(
"
UPDATE
moz_places
"
"
SET
frecency
=
CALCULATE_FRECENCY
(
:
page_id
:
redirect
)
"
"
WHERE
id
=
:
page_id
"
)
;
}
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
page_id
"
)
aPlace
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
redirect
"
)
aPlace
.
useFrecencyRedirectBonus
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
aPlace
.
hidden
&
&
aPlace
.
shouldUpdateHidden
)
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
stmt
=
mHistory
-
>
GetStatement
(
"
UPDATE
moz_places
"
"
SET
hidden
=
0
"
"
WHERE
id
=
:
page_id
AND
frecency
<
>
0
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
page_id
"
)
aPlace
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
mozIStorageConnection
*
mDBConn
;
nsTArray
<
VisitData
>
mPlaces
;
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
mCallback
;
bool
mGroupNotifications
;
bool
mIgnoreErrors
;
bool
mIgnoreResults
;
uint32_t
mSuccessfulUpdatedCount
;
RefPtr
<
History
>
mHistory
;
}
;
class
SetPageTitle
:
public
Runnable
{
public
:
static
nsresult
Start
(
mozIStorageConnection
*
aConnection
nsIURI
*
aURI
const
nsAString
&
aTitle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
This
should
be
called
on
the
main
thread
"
)
;
MOZ_ASSERT
(
aURI
"
Must
pass
a
non
-
null
URI
object
!
"
)
;
nsCString
spec
;
nsresult
rv
=
aURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
SetPageTitle
>
event
=
new
SetPageTitle
(
spec
aTitle
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetInterface
(
aConnection
)
;
NS_ENSURE_TRUE
(
target
NS_ERROR_UNEXPECTED
)
;
rv
=
target
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
This
should
not
be
called
on
the
main
thread
"
)
;
bool
exists
;
nsresult
rv
=
mHistory
-
>
FetchPageInfo
(
mPlace
&
exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
exists
|
|
!
mPlace
.
titleChanged
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mPlace
.
placeId
>
0
"
We
somehow
have
an
invalid
place
id
here
!
"
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
mHistory
-
>
GetStatement
(
"
UPDATE
moz_places
"
"
SET
title
=
:
page_title
"
"
WHERE
id
=
:
page_id
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
{
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
page_id
"
)
mPlace
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mPlace
.
title
.
IsEmpty
(
)
)
{
rv
=
stmt
-
>
BindNullByName
(
NS_LITERAL_CSTRING
(
"
page_title
"
)
)
;
}
else
{
rv
=
stmt
-
>
BindStringByName
(
NS_LITERAL_CSTRING
(
"
page_title
"
)
StringHead
(
mPlace
.
title
TITLE_LENGTH_MAX
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyTitleObservers
(
mPlace
.
spec
mPlace
.
title
mPlace
.
guid
)
;
rv
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
private
:
SetPageTitle
(
const
nsCString
&
aSpec
const
nsAString
&
aTitle
)
:
Runnable
(
"
places
:
:
SetPageTitle
"
)
mHistory
(
History
:
:
GetService
(
)
)
{
mPlace
.
spec
=
aSpec
;
mPlace
.
title
=
aTitle
;
}
VisitData
mPlace
;
RefPtr
<
History
>
mHistory
;
}
;
void
StoreAndNotifyEmbedVisit
(
VisitData
&
aPlace
mozIVisitInfoCallback
*
aCallback
=
nullptr
)
{
MOZ_ASSERT
(
aPlace
.
transitionType
=
=
nsINavHistoryService
:
:
TRANSITION_EMBED
"
Must
only
pass
TRANSITION_EMBED
visits
to
this
!
"
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
called
on
the
main
thread
!
"
)
;
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
uri
)
aPlace
.
spec
)
)
;
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
if
(
!
navHistory
|
|
!
uri
)
{
return
;
}
navHistory
-
>
registerEmbedVisit
(
uri
aPlace
.
visitTime
)
;
if
(
!
!
aCallback
)
{
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
callback
(
new
nsMainThreadPtrHolder
<
mozIVisitInfoCallback
>
(
"
mozIVisitInfoCallback
"
aCallback
)
)
;
bool
ignoreResults
=
false
;
Unused
<
<
aCallback
-
>
GetIgnoreResults
(
&
ignoreResults
)
;
if
(
!
ignoreResults
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyPlaceInfoCallback
(
callback
aPlace
true
NS_OK
)
;
(
void
)
NS_DispatchToMainThread
(
event
)
;
}
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyManyVisitsObservers
(
aPlace
)
;
(
void
)
NS_DispatchToMainThread
(
event
)
;
}
}
History
*
History
:
:
gService
=
nullptr
;
History
:
:
History
(
)
:
mShuttingDown
(
false
)
mShutdownMutex
(
"
History
:
:
mShutdownMutex
"
)
mObservers
(
VISIT_OBSERVERS_INITIAL_CACHE_LENGTH
)
mRecentlyVisitedURIs
(
RECENTLY_VISITED_URIS_SIZE
)
{
NS_ASSERTION
(
!
gService
"
Ruh
-
roh
!
This
service
has
already
been
created
!
"
)
;
gService
=
this
;
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
NS_WARNING_ASSERTION
(
os
"
Observer
service
was
not
found
!
"
)
;
if
(
os
)
{
(
void
)
os
-
>
AddObserver
(
this
TOPIC_PLACES_SHUTDOWN
false
)
;
}
}
History
:
:
~
History
(
)
{
UnregisterWeakMemoryReporter
(
this
)
;
MOZ_ASSERT
(
gService
=
=
this
)
;
gService
=
nullptr
;
}
void
History
:
:
InitMemoryReporter
(
)
{
RegisterWeakMemoryReporter
(
this
)
;
}
static
nsIDocument
*
GetLinkDocument
(
Link
*
aLink
)
{
Element
*
element
=
aLink
-
>
GetElement
(
)
;
return
element
?
element
-
>
OwnerDoc
(
)
:
nullptr
;
}
void
History
:
:
NotifyVisitedParent
(
const
nsTArray
<
URIParams
>
&
aURIs
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsTArray
<
ContentParent
*
>
cplist
;
ContentParent
:
:
GetAll
(
cplist
)
;
if
(
!
cplist
.
IsEmpty
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
cplist
.
Length
(
)
;
+
+
i
)
{
Unused
<
<
cplist
[
i
]
-
>
SendNotifyVisited
(
aURIs
)
;
}
}
}
NS_IMETHODIMP
History
:
:
NotifyVisited
(
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aURI
)
;
nsAutoScriptBlocker
scriptBlocker
;
KeyClass
*
key
=
mObservers
.
GetEntry
(
aURI
)
;
if
(
!
key
)
{
return
NS_OK
;
}
key
-
>
mVisited
=
true
;
MOZ_ASSERT
(
!
key
-
>
array
.
IsEmpty
(
)
)
;
{
nsTArray
<
nsIDocument
*
>
seen
;
ObserverArray
:
:
BackwardIterator
iter
(
key
-
>
array
)
;
while
(
iter
.
HasMore
(
)
)
{
Link
*
link
=
iter
.
GetNext
(
)
;
nsIDocument
*
doc
=
GetLinkDocument
(
link
)
;
if
(
seen
.
Contains
(
doc
)
)
{
continue
;
}
seen
.
AppendElement
(
doc
)
;
DispatchNotifyVisited
(
aURI
doc
)
;
}
}
return
NS_OK
;
}
void
History
:
:
NotifyVisitedForDocument
(
nsIURI
*
aURI
nsIDocument
*
aDocument
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsAutoScriptBlocker
scriptBlocker
;
KeyClass
*
key
=
mObservers
.
GetEntry
(
aURI
)
;
if
(
!
key
)
{
return
;
}
{
ObserverArray
:
:
BackwardIterator
iter
(
key
-
>
array
)
;
while
(
iter
.
HasMore
(
)
)
{
Link
*
link
=
iter
.
GetNext
(
)
;
nsIDocument
*
doc
=
GetLinkDocument
(
link
)
;
if
(
doc
=
=
aDocument
)
{
link
-
>
SetLinkState
(
eLinkState_Visited
)
;
iter
.
Remove
(
)
;
}
MOZ_ASSERT
(
key
=
=
mObservers
.
GetEntry
(
aURI
)
"
The
URIs
hash
mutated
!
"
)
;
}
}
if
(
key
-
>
array
.
IsEmpty
(
)
)
{
mObservers
.
RemoveEntry
(
key
)
;
}
}
void
History
:
:
DispatchNotifyVisited
(
nsIURI
*
aURI
nsIDocument
*
aDocument
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
aDocument
;
nsCOMPtr
<
nsIURI
>
uri
=
aURI
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
History
:
:
DispatchNotifyVisited
"
[
uri
doc
]
{
nsCOMPtr
<
IHistory
>
history
=
services
:
:
GetHistoryService
(
)
;
static_cast
<
History
*
>
(
history
.
get
(
)
)
-
>
NotifyVisitedForDocument
(
uri
doc
)
;
}
)
;
if
(
doc
)
{
doc
-
>
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
else
{
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
}
class
ConcurrentStatementsHolder
final
:
public
mozIStorageCompletionCallback
{
public
:
NS_DECL_ISUPPORTS
explicit
ConcurrentStatementsHolder
(
mozIStorageConnection
*
aDBConn
)
:
mShutdownWasInvoked
(
false
)
{
DebugOnly
<
nsresult
>
rv
=
aDBConn
-
>
AsyncClone
(
true
this
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
NS_IMETHOD
Complete
(
nsresult
aStatus
nsISupports
*
aConnection
)
override
{
if
(
NS_FAILED
(
aStatus
)
)
{
return
NS_OK
;
}
mReadOnlyDBConn
=
do_QueryInterface
(
aConnection
)
;
if
(
mShutdownWasInvoked
)
{
Shutdown
(
)
;
return
NS_OK
;
}
if
(
!
mIsVisitedStatement
)
{
(
void
)
mReadOnlyDBConn
-
>
CreateAsyncStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
1
FROM
moz_places
h
"
"
WHERE
url_hash
=
hash
(
?
1
)
AND
url
=
?
1
AND
last_visit_date
NOTNULL
"
)
getter_AddRefs
(
mIsVisitedStatement
)
)
;
MOZ_ASSERT
(
mIsVisitedStatement
)
;
nsresult
result
=
mIsVisitedStatement
?
NS_OK
:
NS_ERROR_NOT_AVAILABLE
;
for
(
int32_t
i
=
0
;
i
<
mIsVisitedCallbacks
.
Count
(
)
;
+
+
i
)
{
DebugOnly
<
nsresult
>
rv
;
rv
=
mIsVisitedCallbacks
[
i
]
-
>
Complete
(
result
mIsVisitedStatement
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
mIsVisitedCallbacks
.
Clear
(
)
;
}
return
NS_OK
;
}
void
GetIsVisitedStatement
(
mozIStorageCompletionCallback
*
aCallback
)
{
if
(
mIsVisitedStatement
)
{
DebugOnly
<
nsresult
>
rv
;
rv
=
aCallback
-
>
Complete
(
NS_OK
mIsVisitedStatement
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
else
{
DebugOnly
<
bool
>
added
=
mIsVisitedCallbacks
.
AppendObject
(
aCallback
)
;
MOZ_ASSERT
(
added
)
;
}
}
void
Shutdown
(
)
{
mShutdownWasInvoked
=
true
;
if
(
mReadOnlyDBConn
)
{
mIsVisitedCallbacks
.
Clear
(
)
;
DebugOnly
<
nsresult
>
rv
;
if
(
mIsVisitedStatement
)
{
rv
=
mIsVisitedStatement
-
>
Finalize
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
rv
=
mReadOnlyDBConn
-
>
AsyncClose
(
nullptr
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
mReadOnlyDBConn
=
nullptr
;
}
}
private
:
~
ConcurrentStatementsHolder
(
)
{
}
nsCOMPtr
<
mozIStorageAsyncConnection
>
mReadOnlyDBConn
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
mIsVisitedStatement
;
nsCOMArray
<
mozIStorageCompletionCallback
>
mIsVisitedCallbacks
;
bool
mShutdownWasInvoked
;
}
;
NS_IMPL_ISUPPORTS
(
ConcurrentStatementsHolder
mozIStorageCompletionCallback
)
nsresult
History
:
:
GetIsVisitedStatement
(
mozIStorageCompletionCallback
*
aCallback
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mShuttingDown
)
return
NS_ERROR_NOT_AVAILABLE
;
if
(
!
mConcurrentStatementsHolder
)
{
mozIStorageConnection
*
dbConn
=
GetDBConn
(
)
;
NS_ENSURE_STATE
(
dbConn
)
;
mConcurrentStatementsHolder
=
new
ConcurrentStatementsHolder
(
dbConn
)
;
}
mConcurrentStatementsHolder
-
>
GetIsVisitedStatement
(
aCallback
)
;
return
NS_OK
;
}
nsresult
History
:
:
InsertPlace
(
VisitData
&
aPlace
bool
aShouldNotifyFrecencyChanged
)
{
MOZ_ASSERT
(
aPlace
.
placeId
=
=
0
"
should
not
have
a
valid
place
id
!
"
)
;
MOZ_ASSERT
(
!
aPlace
.
shouldUpdateHidden
"
We
should
not
need
to
update
hidden
"
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
must
be
called
off
of
the
main
thread
!
"
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
GetStatement
(
"
INSERT
INTO
moz_places
"
"
(
url
url_hash
title
rev_host
hidden
typed
frecency
guid
)
"
"
VALUES
(
:
url
hash
(
:
url
)
:
title
:
rev_host
:
hidden
:
typed
:
frecency
:
guid
)
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
nsresult
rv
=
stmt
-
>
BindStringByName
(
NS_LITERAL_CSTRING
(
"
rev_host
"
)
aPlace
.
revHost
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
URIBinder
:
:
Bind
(
stmt
NS_LITERAL_CSTRING
(
"
url
"
)
aPlace
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsString
title
=
aPlace
.
title
;
if
(
title
.
IsEmpty
(
)
)
{
rv
=
stmt
-
>
BindNullByName
(
NS_LITERAL_CSTRING
(
"
title
"
)
)
;
}
else
{
title
.
Assign
(
StringHead
(
aPlace
.
title
TITLE_LENGTH_MAX
)
)
;
rv
=
stmt
-
>
BindStringByName
(
NS_LITERAL_CSTRING
(
"
title
"
)
title
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
typed
"
)
aPlace
.
typed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
frecency
=
aPlace
.
shouldUpdateFrecency
?
aPlace
.
frecency
:
0
;
rv
=
stmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
frecency
"
)
frecency
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
hidden
"
)
aPlace
.
hidden
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aPlace
.
guid
.
IsVoid
(
)
)
{
rv
=
GenerateGUID
(
aPlace
.
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
guid
"
)
aPlace
.
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aShouldNotifyFrecencyChanged
)
{
const
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetConstHistoryService
(
)
;
NS_ENSURE_STATE
(
navHistory
)
;
navHistory
-
>
DispatchFrecencyChangedNotification
(
aPlace
.
spec
frecency
aPlace
.
guid
aPlace
.
hidden
aPlace
.
visitTime
)
;
}
return
NS_OK
;
}
nsresult
History
:
:
UpdatePlace
(
const
VisitData
&
aPlace
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
must
be
called
off
of
the
main
thread
!
"
)
;
MOZ_ASSERT
(
aPlace
.
placeId
>
0
"
must
have
a
valid
place
id
!
"
)
;
MOZ_ASSERT
(
!
aPlace
.
guid
.
IsVoid
(
)
"
must
have
a
guid
!
"
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
bool
titleIsVoid
=
aPlace
.
title
.
IsVoid
(
)
;
if
(
titleIsVoid
)
{
stmt
=
GetStatement
(
"
UPDATE
moz_places
"
"
SET
hidden
=
:
hidden
"
"
typed
=
:
typed
"
"
guid
=
:
guid
"
"
WHERE
id
=
:
page_id
"
)
;
}
else
{
stmt
=
GetStatement
(
"
UPDATE
moz_places
"
"
SET
title
=
:
title
"
"
hidden
=
:
hidden
"
"
typed
=
:
typed
"
"
guid
=
:
guid
"
"
WHERE
id
=
:
page_id
"
)
;
}
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
nsresult
rv
;
if
(
!
titleIsVoid
)
{
if
(
aPlace
.
title
.
IsEmpty
(
)
)
{
rv
=
stmt
-
>
BindNullByName
(
NS_LITERAL_CSTRING
(
"
title
"
)
)
;
}
else
{
rv
=
stmt
-
>
BindStringByName
(
NS_LITERAL_CSTRING
(
"
title
"
)
StringHead
(
aPlace
.
title
TITLE_LENGTH_MAX
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
stmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
typed
"
)
aPlace
.
typed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
hidden
"
)
aPlace
.
hidden
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
guid
"
)
aPlace
.
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
page_id
"
)
aPlace
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
History
:
:
FetchPageInfo
(
VisitData
&
_place
bool
*
_exists
)
{
MOZ_ASSERT
(
!
_place
.
spec
.
IsEmpty
(
)
|
|
!
_place
.
guid
.
IsEmpty
(
)
"
must
have
either
a
non
-
empty
spec
or
guid
!
"
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
must
be
called
off
of
the
main
thread
!
"
)
;
nsresult
rv
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
bool
selectByURI
=
!
_place
.
spec
.
IsEmpty
(
)
;
if
(
selectByURI
)
{
stmt
=
GetStatement
(
"
SELECT
guid
id
title
hidden
typed
frecency
visit_count
last_visit_date
"
"
(
SELECT
id
FROM
moz_historyvisits
"
"
WHERE
place_id
=
h
.
id
AND
visit_date
=
h
.
last_visit_date
)
AS
last_visit_id
"
"
FROM
moz_places
h
"
"
WHERE
url_hash
=
hash
(
:
page_url
)
AND
url
=
:
page_url
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
rv
=
URIBinder
:
:
Bind
(
stmt
NS_LITERAL_CSTRING
(
"
page_url
"
)
_place
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
stmt
=
GetStatement
(
"
SELECT
url
id
title
hidden
typed
frecency
visit_count
last_visit_date
"
"
(
SELECT
id
FROM
moz_historyvisits
"
"
WHERE
place_id
=
h
.
id
AND
visit_date
=
h
.
last_visit_date
)
AS
last_visit_id
"
"
FROM
moz_places
h
"
"
WHERE
guid
=
:
guid
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
guid
"
)
_place
.
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
ExecuteStep
(
_exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
*
_exists
)
{
return
NS_OK
;
}
if
(
selectByURI
)
{
if
(
_place
.
guid
.
IsEmpty
(
)
)
{
rv
=
stmt
-
>
GetUTF8String
(
0
_place
.
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
{
nsAutoCString
spec
;
rv
=
stmt
-
>
GetUTF8String
(
0
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
_place
.
spec
=
spec
;
}
rv
=
stmt
-
>
GetInt64
(
1
&
_place
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
title
;
rv
=
stmt
-
>
GetString
(
2
title
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
_place
.
title
.
IsVoid
(
)
)
{
_place
.
title
=
title
;
}
else
{
_place
.
titleChanged
=
!
(
_place
.
title
.
Equals
(
title
)
)
&
&
!
(
_place
.
title
.
IsEmpty
(
)
&
&
title
.
IsVoid
(
)
)
;
}
int32_t
hidden
;
rv
=
stmt
-
>
GetInt32
(
3
&
hidden
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
_place
.
hidden
=
!
!
hidden
;
int32_t
typed
;
rv
=
stmt
-
>
GetInt32
(
4
&
typed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
_place
.
typed
=
!
!
typed
;
rv
=
stmt
-
>
GetInt32
(
5
&
_place
.
frecency
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
visitCount
;
rv
=
stmt
-
>
GetInt32
(
6
&
visitCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
_place
.
visitCount
=
visitCount
;
rv
=
stmt
-
>
GetInt64
(
7
&
_place
.
lastVisitTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
GetInt64
(
8
&
_place
.
lastVisitId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
HistoryMallocSizeOf
)
NS_IMETHODIMP
History
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
history
-
links
-
hashtable
"
KIND_HEAP
UNITS_BYTES
SizeOfIncludingThis
(
HistoryMallocSizeOf
)
"
Memory
used
by
the
hashtable
that
records
changes
to
the
visited
state
"
"
of
links
.
"
)
;
return
NS_OK
;
}
size_t
History
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOfThis
)
{
return
aMallocSizeOfThis
(
this
)
+
mObservers
.
SizeOfExcludingThis
(
aMallocSizeOfThis
)
;
}
History
*
History
:
:
GetService
(
)
{
if
(
gService
)
{
return
gService
;
}
nsCOMPtr
<
IHistory
>
service
(
do_GetService
(
NS_IHISTORY_CONTRACTID
)
)
;
if
(
service
)
{
NS_ASSERTION
(
gService
"
Our
constructor
was
not
run
?
!
"
)
;
}
return
gService
;
}
already_AddRefed
<
History
>
History
:
:
GetSingleton
(
)
{
if
(
!
gService
)
{
RefPtr
<
History
>
svc
=
new
History
(
)
;
MOZ_ASSERT
(
gService
=
=
svc
.
get
(
)
)
;
svc
-
>
InitMemoryReporter
(
)
;
return
svc
.
forget
(
)
;
}
return
do_AddRef
(
gService
)
;
}
mozIStorageConnection
*
History
:
:
GetDBConn
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mShuttingDown
)
return
nullptr
;
if
(
!
mDB
)
{
mDB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_TRUE
(
mDB
nullptr
)
;
mDB
-
>
EnsureConnection
(
)
;
NS_ENSURE_TRUE
(
mDB
nullptr
)
;
}
return
mDB
-
>
MainConn
(
)
;
}
const
mozIStorageConnection
*
History
:
:
GetConstDBConn
(
)
{
MOZ_ASSERT
(
mDB
|
|
mShuttingDown
)
;
if
(
mShuttingDown
|
|
!
mDB
)
{
return
nullptr
;
}
return
mDB
-
>
MainConn
(
)
;
}
void
History
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lockedScope
(
mShutdownMutex
)
;
MOZ_ASSERT
(
!
mShuttingDown
&
&
"
Shutdown
was
called
more
than
once
!
"
)
;
mShuttingDown
=
true
;
if
(
mConcurrentStatementsHolder
)
{
mConcurrentStatementsHolder
-
>
Shutdown
(
)
;
}
}
void
History
:
:
AppendToRecentlyVisitedURIs
(
nsIURI
*
aURI
)
{
RecentURIKey
*
entry
=
mRecentlyVisitedURIs
.
GetEntry
(
aURI
)
;
if
(
!
entry
)
{
entry
=
mRecentlyVisitedURIs
.
PutEntry
(
aURI
)
;
}
if
(
entry
)
{
entry
-
>
time
=
PR_Now
(
)
;
}
for
(
auto
iter
=
mRecentlyVisitedURIs
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RecentURIKey
*
entry
=
iter
.
Get
(
)
;
if
(
(
PR_Now
(
)
-
entry
-
>
time
)
>
RECENTLY_VISITED_URIS_MAX_AGE
)
{
iter
.
Remove
(
)
;
}
}
}
inline
bool
History
:
:
IsRecentlyVisitedURI
(
nsIURI
*
aURI
)
{
RecentURIKey
*
entry
=
mRecentlyVisitedURIs
.
GetEntry
(
aURI
)
;
return
entry
&
&
(
PR_Now
(
)
-
entry
-
>
time
)
<
RECENTLY_VISITED_URIS_MAX_AGE
;
}
NS_IMETHODIMP
History
:
:
VisitURI
(
nsIURI
*
aURI
nsIURI
*
aLastVisitedURI
uint32_t
aFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aURI
)
;
if
(
mShuttingDown
)
{
return
NS_OK
;
}
if
(
XRE_IsContentProcess
(
)
)
{
URIParams
uri
;
SerializeURI
(
aURI
uri
)
;
OptionalURIParams
lastVisitedURI
;
SerializeURI
(
aLastVisitedURI
lastVisitedURI
)
;
mozilla
:
:
dom
:
:
ContentChild
*
cpc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
NS_ASSERTION
(
cpc
"
Content
Protocol
is
NULL
!
"
)
;
(
void
)
cpc
-
>
SendVisitURI
(
uri
lastVisitedURI
aFlags
)
;
return
NS_OK
;
}
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
navHistory
NS_ERROR_OUT_OF_MEMORY
)
;
bool
canAdd
;
nsresult
rv
=
navHistory
-
>
CanAddURI
(
aURI
&
canAdd
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
canAdd
)
{
return
NS_OK
;
}
bool
reload
=
false
;
if
(
aLastVisitedURI
)
{
rv
=
aURI
-
>
Equals
(
aLastVisitedURI
&
reload
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
reload
&
&
IsRecentlyVisitedURI
(
aURI
)
)
{
AppendToRecentlyVisitedURIs
(
aURI
)
;
return
NS_OK
;
}
}
nsTArray
<
VisitData
>
placeArray
(
1
)
;
NS_ENSURE_TRUE
(
placeArray
.
AppendElement
(
VisitData
(
aURI
aLastVisitedURI
)
)
NS_ERROR_OUT_OF_MEMORY
)
;
VisitData
&
place
=
placeArray
.
ElementAt
(
0
)
;
NS_ENSURE_FALSE
(
place
.
spec
.
IsEmpty
(
)
NS_ERROR_INVALID_ARG
)
;
place
.
visitTime
=
PR_Now
(
)
;
uint32_t
recentFlags
=
navHistory
-
>
GetRecentFlags
(
aURI
)
;
bool
isFollowedLink
=
recentFlags
&
nsNavHistory
:
:
RECENT_ACTIVATED
;
uint32_t
transitionType
=
nsINavHistoryService
:
:
TRANSITION_LINK
;
if
(
!
(
aFlags
&
IHistory
:
:
TOP_LEVEL
)
&
&
!
isFollowedLink
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_EMBED
;
}
else
if
(
aFlags
&
IHistory
:
:
REDIRECT_TEMPORARY
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_REDIRECT_TEMPORARY
;
}
else
if
(
aFlags
&
IHistory
:
:
REDIRECT_PERMANENT
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_REDIRECT_PERMANENT
;
}
else
if
(
reload
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_RELOAD
;
}
else
if
(
(
recentFlags
&
nsNavHistory
:
:
RECENT_TYPED
)
&
&
!
(
aFlags
&
IHistory
:
:
UNRECOVERABLE_ERROR
)
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_TYPED
;
}
else
if
(
recentFlags
&
nsNavHistory
:
:
RECENT_BOOKMARKED
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_BOOKMARK
;
}
else
if
(
!
(
aFlags
&
IHistory
:
:
TOP_LEVEL
)
&
&
isFollowedLink
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_FRAMED_LINK
;
}
place
.
SetTransitionType
(
transitionType
)
;
bool
isRedirect
=
aFlags
&
IHistory
:
:
REDIRECT_SOURCE
;
if
(
isRedirect
)
{
place
.
useFrecencyRedirectBonus
=
(
aFlags
&
IHistory
:
:
REDIRECT_SOURCE_PERMANENT
)
|
|
transitionType
!
=
nsINavHistoryService
:
:
TRANSITION_TYPED
;
}
place
.
hidden
=
GetHiddenState
(
isRedirect
place
.
transitionType
)
;
if
(
aFlags
&
IHistory
:
:
UNRECOVERABLE_ERROR
)
{
place
.
shouldUpdateFrecency
=
false
;
}
if
(
place
.
transitionType
=
=
nsINavHistoryService
:
:
TRANSITION_EMBED
)
{
StoreAndNotifyEmbedVisit
(
place
)
;
}
else
{
mozIStorageConnection
*
dbConn
=
GetDBConn
(
)
;
NS_ENSURE_STATE
(
dbConn
)
;
rv
=
InsertVisitedURIs
:
:
Start
(
dbConn
placeArray
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
History
:
:
RegisterVisitedCallback
(
nsIURI
*
aURI
Link
*
aLink
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ASSERTION
(
aURI
"
Must
pass
a
non
-
null
URI
!
"
)
;
if
(
XRE_IsContentProcess
(
)
)
{
MOZ_ASSERT
(
aLink
"
Must
pass
a
non
-
null
Link
!
"
)
;
}
#
ifdef
DEBUG
bool
keyAlreadyExists
=
!
!
mObservers
.
GetEntry
(
aURI
)
;
#
endif
KeyClass
*
key
=
mObservers
.
PutEntry
(
aURI
)
;
NS_ENSURE_TRUE
(
key
NS_ERROR_OUT_OF_MEMORY
)
;
ObserverArray
&
observers
=
key
-
>
array
;
if
(
observers
.
IsEmpty
(
)
)
{
NS_ASSERTION
(
!
keyAlreadyExists
"
An
empty
key
was
kept
around
in
our
hashtable
!
"
)
;
nsresult
rv
=
VisitedQuery
:
:
Start
(
aURI
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
aLink
)
{
MOZ_ASSERT
(
key
=
=
mObservers
.
GetEntry
(
aURI
)
"
The
URIs
hash
mutated
!
"
)
;
key
=
mObservers
.
GetEntry
(
aURI
)
;
if
(
key
)
{
mObservers
.
RemoveEntry
(
key
)
;
}
return
rv
;
}
}
else
if
(
!
aLink
)
{
NS_ASSERTION
(
XRE_IsParentProcess
(
)
"
We
should
only
ever
get
a
null
Link
in
the
default
process
!
"
)
;
return
NS_OK
;
}
NS_ASSERTION
(
!
observers
.
Contains
(
aLink
)
"
Already
tracking
this
Link
object
!
"
)
;
if
(
!
observers
.
AppendElement
(
aLink
)
)
{
(
void
)
UnregisterVisitedCallback
(
aURI
aLink
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
key
-
>
mVisited
)
{
DispatchNotifyVisited
(
aURI
GetLinkDocument
(
aLink
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
History
:
:
UnregisterVisitedCallback
(
nsIURI
*
aURI
Link
*
aLink
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ASSERTION
(
aURI
"
Must
pass
a
non
-
null
URI
!
"
)
;
NS_ASSERTION
(
aLink
"
Must
pass
a
non
-
null
Link
object
!
"
)
;
KeyClass
*
key
=
mObservers
.
GetEntry
(
aURI
)
;
if
(
!
key
)
{
NS_ERROR
(
"
Trying
to
unregister
for
a
URI
that
wasn
'
t
registered
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
ObserverArray
&
observers
=
key
-
>
array
;
if
(
!
observers
.
RemoveElement
(
aLink
)
)
{
NS_ERROR
(
"
Trying
to
unregister
a
node
that
wasn
'
t
registered
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
observers
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
key
=
=
mObservers
.
GetEntry
(
aURI
)
"
The
URIs
hash
mutated
!
"
)
;
mObservers
.
RemoveEntry
(
key
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
History
:
:
SetURITitle
(
nsIURI
*
aURI
const
nsAString
&
aTitle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aURI
)
;
if
(
mShuttingDown
)
{
return
NS_OK
;
}
if
(
XRE_IsContentProcess
(
)
)
{
URIParams
uri
;
SerializeURI
(
aURI
uri
)
;
mozilla
:
:
dom
:
:
ContentChild
*
cpc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
NS_ASSERTION
(
cpc
"
Content
Protocol
is
NULL
!
"
)
;
(
void
)
cpc
-
>
SendSetURITitle
(
uri
PromiseFlatString
(
aTitle
)
)
;
return
NS_OK
;
}
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
navHistory
NS_ERROR_FAILURE
)
;
bool
canAdd
;
nsresult
rv
=
navHistory
-
>
CanAddURI
(
aURI
&
canAdd
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
canAdd
)
{
return
NS_OK
;
}
if
(
navHistory
-
>
hasEmbedVisit
(
aURI
)
)
{
return
NS_OK
;
}
mozIStorageConnection
*
dbConn
=
GetDBConn
(
)
;
NS_ENSURE_STATE
(
dbConn
)
;
rv
=
SetPageTitle
:
:
Start
(
dbConn
aURI
aTitle
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
History
:
:
UpdatePlaces
(
JS
:
:
Handle
<
JS
:
:
Value
>
aPlaceInfos
mozIVisitInfoCallback
*
aCallback
bool
aGroupNotifications
JSContext
*
aCtx
)
{
NS_ENSURE_TRUE
(
NS_IsMainThread
(
)
NS_ERROR_UNEXPECTED
)
;
NS_ENSURE_TRUE
(
!
aPlaceInfos
.
isPrimitive
(
)
NS_ERROR_INVALID_ARG
)
;
uint32_t
infosLength
;
JS
:
:
Rooted
<
JSObject
*
>
infos
(
aCtx
)
;
nsresult
rv
=
GetJSArrayFromJSValue
(
aPlaceInfos
aCtx
&
infos
&
infosLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
initialUpdatedCount
=
0
;
nsTArray
<
VisitData
>
visitData
;
for
(
uint32_t
i
=
0
;
i
<
infosLength
;
i
+
+
)
{
JS
:
:
Rooted
<
JSObject
*
>
info
(
aCtx
)
;
nsresult
rv
=
GetJSObjectFromArray
(
aCtx
infos
i
&
info
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
=
GetURIFromJSObject
(
aCtx
info
"
uri
"
)
;
nsCString
guid
;
{
nsString
fatGUID
;
GetStringFromJSObject
(
aCtx
info
"
guid
"
fatGUID
)
;
if
(
fatGUID
.
IsVoid
(
)
)
{
guid
.
SetIsVoid
(
true
)
;
}
else
{
guid
=
NS_ConvertUTF16toUTF8
(
fatGUID
)
;
}
}
if
(
uri
&
&
!
CanAddURI
(
uri
guid
aCallback
)
)
{
continue
;
}
NS_ENSURE_ARG
(
uri
|
|
!
guid
.
IsVoid
(
)
)
;
bool
isValidGUID
=
IsValidGUID
(
guid
)
;
NS_ENSURE_ARG
(
guid
.
IsVoid
(
)
|
|
isValidGUID
)
;
nsString
title
;
GetStringFromJSObject
(
aCtx
info
"
title
"
title
)
;
JS
:
:
Rooted
<
JSObject
*
>
visits
(
aCtx
nullptr
)
;
{
JS
:
:
Rooted
<
JS
:
:
Value
>
visitsVal
(
aCtx
)
;
bool
rc
=
JS_GetProperty
(
aCtx
info
"
visits
"
&
visitsVal
)
;
NS_ENSURE_TRUE
(
rc
NS_ERROR_UNEXPECTED
)
;
if
(
!
visitsVal
.
isPrimitive
(
)
)
{
visits
=
visitsVal
.
toObjectOrNull
(
)
;
bool
isArray
;
if
(
!
JS_IsArrayObject
(
aCtx
visits
&
isArray
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
isArray
)
{
return
NS_ERROR_INVALID_ARG
;
}
}
}
NS_ENSURE_ARG
(
visits
)
;
uint32_t
visitsLength
=
0
;
if
(
visits
)
{
(
void
)
JS_GetArrayLength
(
aCtx
visits
&
visitsLength
)
;
}
NS_ENSURE_ARG
(
visitsLength
>
0
)
;
visitData
.
SetCapacity
(
visitData
.
Length
(
)
+
visitsLength
)
;
for
(
uint32_t
j
=
0
;
j
<
visitsLength
;
j
+
+
)
{
JS
:
:
Rooted
<
JSObject
*
>
visit
(
aCtx
)
;
rv
=
GetJSObjectFromArray
(
aCtx
visits
j
&
visit
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
VisitData
&
data
=
*
visitData
.
AppendElement
(
VisitData
(
uri
)
)
;
if
(
!
title
.
IsEmpty
(
)
)
{
data
.
title
=
title
;
}
else
if
(
!
title
.
IsVoid
(
)
)
{
data
.
title
.
SetIsVoid
(
false
)
;
}
data
.
guid
=
guid
;
rv
=
GetIntFromJSObject
(
aCtx
visit
"
visitDate
"
&
data
.
visitTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
data
.
visitTime
<
(
PR_Now
(
)
/
1000
)
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIXPConnect
>
xpc
=
do_GetService
(
nsIXPConnect
:
:
GetCID
(
)
)
;
Unused
<
<
xpc
-
>
DebugDumpJSStack
(
false
false
false
)
;
MOZ_CRASH
(
"
invalid
time
format
passed
to
updatePlaces
"
)
;
#
endif
return
NS_ERROR_INVALID_ARG
;
}
uint32_t
transitionType
=
0
;
rv
=
GetIntFromJSObject
(
aCtx
visit
"
transitionType
"
&
transitionType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_ARG_RANGE
(
transitionType
nsINavHistoryService
:
:
TRANSITION_LINK
nsINavHistoryService
:
:
TRANSITION_RELOAD
)
;
data
.
SetTransitionType
(
transitionType
)
;
data
.
hidden
=
GetHiddenState
(
false
transitionType
)
;
if
(
transitionType
=
=
nsINavHistoryService
:
:
TRANSITION_EMBED
)
{
StoreAndNotifyEmbedVisit
(
data
aCallback
)
;
visitData
.
RemoveLastElement
(
)
;
initialUpdatedCount
+
+
;
continue
;
}
nsCOMPtr
<
nsIURI
>
referrer
=
GetURIFromJSObject
(
aCtx
visit
"
referrerURI
"
)
;
if
(
referrer
)
{
(
void
)
referrer
-
>
GetSpec
(
data
.
referrerSpec
)
;
}
}
}
mozIStorageConnection
*
dbConn
=
GetDBConn
(
)
;
NS_ENSURE_STATE
(
dbConn
)
;
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
callback
(
new
nsMainThreadPtrHolder
<
mozIVisitInfoCallback
>
(
"
mozIVisitInfoCallback
"
aCallback
)
)
;
if
(
visitData
.
Length
(
)
)
{
nsresult
rv
=
InsertVisitedURIs
:
:
Start
(
dbConn
visitData
callback
aGroupNotifications
initialUpdatedCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
aCallback
)
{
nsCOMPtr
<
nsIEventTarget
>
backgroundThread
=
do_GetInterface
(
dbConn
)
;
NS_ENSURE_TRUE
(
backgroundThread
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyCompletion
(
callback
initialUpdatedCount
)
;
return
backgroundThread
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
History
:
:
IsURIVisited
(
nsIURI
*
aURI
mozIVisitedStatusCallback
*
aCallback
)
{
NS_ENSURE_STATE
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aURI
)
;
NS_ENSURE_ARG
(
aCallback
)
;
nsresult
rv
=
VisitedQuery
:
:
Start
(
aURI
aCallback
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
History
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
strcmp
(
aTopic
TOPIC_PLACES_SHUTDOWN
)
=
=
0
)
{
Shutdown
(
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
(
void
)
os
-
>
RemoveObserver
(
this
TOPIC_PLACES_SHUTDOWN
)
;
}
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
History
IHistory
mozIAsyncHistory
nsIObserver
nsIMemoryReporter
)
}
}
