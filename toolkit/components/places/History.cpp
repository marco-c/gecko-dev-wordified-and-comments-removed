#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
History
.
h
"
#
include
"
nsNavHistory
.
h
"
#
include
"
nsNavBookmarks
.
h
"
#
include
"
Helpers
.
h
"
#
include
"
PlaceInfo
.
h
"
#
include
"
VisitInfo
.
h
"
#
include
"
nsPlacesMacros
.
h
"
#
include
"
NotifyRankingChanged
.
h
"
#
include
"
mozilla
/
storage
.
h
"
#
include
"
mozilla
/
dom
/
Link
.
h
"
#
include
"
nsDocShellCID
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsStandardURL
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
dom
/
ContentProcessMessageManager
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
PlacesObservers
.
h
"
#
include
"
mozilla
/
dom
/
PlacesVisit
.
h
"
#
include
"
mozilla
/
dom
/
PlacesVisitTitle
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsIBrowserWindowTracker
.
h
"
#
include
"
nsImportModule
.
h
"
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
ipc
;
using
mozilla
:
:
Unused
;
namespace
mozilla
{
namespace
places
{
#
define
URI_VISIT_SAVED
"
uri
-
visit
-
saved
"
#
define
DESTINATIONFILEURI_ANNO
"
downloads
/
destinationFileURI
"
_ns
struct
VisitData
{
VisitData
(
)
:
placeId
(
0
)
visitId
(
0
)
hidden
(
true
)
shouldUpdateHidden
(
true
)
typed
(
false
)
transitionType
(
UINT32_MAX
)
visitTime
(
0
)
frecency
(
-
1
)
lastVisitId
(
0
)
lastVisitTime
(
0
)
visitCount
(
0
)
referrerVisitId
(
0
)
titleChanged
(
false
)
shouldUpdateFrecency
(
true
)
useFrecencyRedirectBonus
(
false
)
source
(
nsINavHistoryService
:
:
VISIT_SOURCE_ORGANIC
)
triggeringPlaceId
(
0
)
triggeringSponsoredURLVisitTimeMS
(
0
)
bookmarked
(
false
)
{
guid
.
SetIsVoid
(
true
)
;
title
.
SetIsVoid
(
true
)
;
baseDomain
.
SetIsVoid
(
true
)
;
triggeringSponsoredURL
.
SetIsVoid
(
true
)
;
triggeringSponsoredURLBaseDomain
.
SetIsVoid
(
true
)
;
}
explicit
VisitData
(
nsIURI
*
aURI
nsIURI
*
aReferrer
=
nullptr
)
:
placeId
(
0
)
visitId
(
0
)
hidden
(
true
)
shouldUpdateHidden
(
true
)
typed
(
false
)
transitionType
(
UINT32_MAX
)
visitTime
(
0
)
frecency
(
-
1
)
lastVisitId
(
0
)
lastVisitTime
(
0
)
visitCount
(
0
)
referrerVisitId
(
0
)
titleChanged
(
false
)
shouldUpdateFrecency
(
true
)
useFrecencyRedirectBonus
(
false
)
source
(
nsINavHistoryService
:
:
VISIT_SOURCE_ORGANIC
)
triggeringPlaceId
(
0
)
triggeringSponsoredURLVisitTimeMS
(
0
)
bookmarked
(
false
)
{
MOZ_ASSERT
(
aURI
)
;
if
(
aURI
)
{
(
void
)
aURI
-
>
GetSpec
(
spec
)
;
(
void
)
GetReversedHostname
(
aURI
revHost
)
;
}
if
(
aReferrer
)
{
(
void
)
aReferrer
-
>
GetSpec
(
referrerSpec
)
;
}
guid
.
SetIsVoid
(
true
)
;
title
.
SetIsVoid
(
true
)
;
baseDomain
.
SetIsVoid
(
true
)
;
triggeringSponsoredURL
.
SetIsVoid
(
true
)
;
triggeringSponsoredURLBaseDomain
.
SetIsVoid
(
true
)
;
}
void
SetTransitionType
(
uint32_t
aTransitionType
)
{
typed
=
aTransitionType
=
=
nsINavHistoryService
:
:
TRANSITION_TYPED
;
transitionType
=
aTransitionType
;
}
int64_t
placeId
;
nsCString
guid
;
int64_t
visitId
;
nsCString
spec
;
nsCString
baseDomain
;
nsString
revHost
;
bool
hidden
;
bool
shouldUpdateHidden
;
bool
typed
;
uint32_t
transitionType
;
PRTime
visitTime
;
int32_t
frecency
;
int64_t
lastVisitId
;
PRTime
lastVisitTime
;
uint32_t
visitCount
;
nsString
title
;
nsCString
referrerSpec
;
int64_t
referrerVisitId
;
bool
titleChanged
;
bool
shouldUpdateFrecency
;
bool
useFrecencyRedirectBonus
;
uint16_t
source
;
int64_t
triggeringPlaceId
;
nsCString
triggeringSponsoredURL
;
nsCString
triggeringSponsoredURLBaseDomain
;
int64_t
triggeringSponsoredURLVisitTimeMS
;
bool
bookmarked
;
}
;
namespace
{
nsresult
GetJSArrayFromJSValue
(
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
JSContext
*
aCtx
JS
:
:
MutableHandle
<
JSObject
*
>
_array
uint32_t
*
_arrayLength
)
{
if
(
aValue
.
isObjectOrNull
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
val
(
aCtx
aValue
.
toObjectOrNull
(
)
)
;
bool
isArray
;
if
(
!
JS
:
:
IsArrayObject
(
aCtx
val
&
isArray
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
isArray
)
{
_array
.
set
(
val
)
;
(
void
)
JS
:
:
GetArrayLength
(
aCtx
_array
_arrayLength
)
;
NS_ENSURE_ARG
(
*
_arrayLength
>
0
)
;
return
NS_OK
;
}
}
*
_arrayLength
=
1
;
_array
.
set
(
JS
:
:
NewArrayObject
(
aCtx
0
)
)
;
NS_ENSURE_TRUE
(
_array
NS_ERROR_OUT_OF_MEMORY
)
;
bool
rc
=
JS_DefineElement
(
aCtx
_array
0
aValue
0
)
;
NS_ENSURE_TRUE
(
rc
NS_ERROR_UNEXPECTED
)
;
return
NS_OK
;
}
already_AddRefed
<
nsIURI
>
GetJSValueAsURI
(
JSContext
*
aCtx
const
JS
:
:
Value
&
aValue
)
{
if
(
!
aValue
.
isPrimitive
(
)
)
{
nsCOMPtr
<
nsIXPConnect
>
xpc
=
nsIXPConnect
:
:
XPConnect
(
)
;
nsCOMPtr
<
nsIXPConnectWrappedNative
>
wrappedObj
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCtx
aValue
.
toObjectOrNull
(
)
)
;
nsresult
rv
=
xpc
-
>
GetWrappedNativeOfJSObject
(
aCtx
obj
getter_AddRefs
(
wrappedObj
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
nsCOMPtr
<
nsIURI
>
uri
=
do_QueryInterface
(
wrappedObj
-
>
Native
(
)
)
;
return
uri
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
nsIURI
>
GetURIFromJSObject
(
JSContext
*
aCtx
JS
:
:
Handle
<
JSObject
*
>
aObject
const
char
*
aProperty
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
uriVal
(
aCtx
)
;
bool
rc
=
JS_GetProperty
(
aCtx
aObject
aProperty
&
uriVal
)
;
NS_ENSURE_TRUE
(
rc
nullptr
)
;
return
GetJSValueAsURI
(
aCtx
uriVal
)
;
}
void
GetJSValueAsString
(
JSContext
*
aCtx
const
JS
:
:
Value
&
aValue
nsString
&
_string
)
{
if
(
aValue
.
isUndefined
(
)
|
|
!
(
aValue
.
isNull
(
)
|
|
aValue
.
isString
(
)
)
)
{
_string
.
SetIsVoid
(
true
)
;
return
;
}
if
(
aValue
.
isNull
(
)
)
{
_string
.
Truncate
(
)
;
return
;
}
if
(
!
AssignJSString
(
aCtx
_string
aValue
.
toString
(
)
)
)
{
_string
.
SetIsVoid
(
true
)
;
}
}
void
GetStringFromJSObject
(
JSContext
*
aCtx
JS
:
:
Handle
<
JSObject
*
>
aObject
const
char
*
aProperty
nsString
&
_string
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
aCtx
)
;
bool
rc
=
JS_GetProperty
(
aCtx
aObject
aProperty
&
val
)
;
if
(
!
rc
)
{
_string
.
SetIsVoid
(
true
)
;
return
;
}
else
{
GetJSValueAsString
(
aCtx
val
_string
)
;
}
}
template
<
typename
IntType
>
nsresult
GetIntFromJSObject
(
JSContext
*
aCtx
JS
:
:
Handle
<
JSObject
*
>
aObject
const
char
*
aProperty
IntType
*
_int
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCtx
)
;
bool
rc
=
JS_GetProperty
(
aCtx
aObject
aProperty
&
value
)
;
NS_ENSURE_TRUE
(
rc
NS_ERROR_UNEXPECTED
)
;
if
(
value
.
isUndefined
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
NS_ENSURE_ARG
(
value
.
isPrimitive
(
)
)
;
NS_ENSURE_ARG
(
value
.
isNumber
(
)
)
;
double
num
;
rc
=
JS
:
:
ToNumber
(
aCtx
value
&
num
)
;
NS_ENSURE_TRUE
(
rc
NS_ERROR_UNEXPECTED
)
;
NS_ENSURE_ARG
(
IntType
(
num
)
=
=
num
)
;
*
_int
=
IntType
(
num
)
;
return
NS_OK
;
}
nsresult
GetJSObjectFromArray
(
JSContext
*
aCtx
JS
:
:
Handle
<
JSObject
*
>
aArray
uint32_t
aIndex
JS
:
:
MutableHandle
<
JSObject
*
>
objOut
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCtx
)
;
bool
rc
=
JS_GetElement
(
aCtx
aArray
aIndex
&
value
)
;
NS_ENSURE_TRUE
(
rc
NS_ERROR_UNEXPECTED
)
;
NS_ENSURE_ARG
(
!
value
.
isPrimitive
(
)
)
;
objOut
.
set
(
&
value
.
toObject
(
)
)
;
return
NS_OK
;
}
}
class
VisitedQuery
final
:
public
AsyncStatementCallback
{
public
:
NS_DECL_ISUPPORTS_INHERITED
static
nsresult
Start
(
nsIURI
*
aURI
History
:
:
ContentParentSet
&
&
aContentProcessesToNotify
)
{
MOZ_ASSERT
(
aURI
"
Null
URI
"
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
History
*
history
=
History
:
:
GetService
(
)
;
NS_ENSURE_STATE
(
history
)
;
RefPtr
<
VisitedQuery
>
query
=
new
VisitedQuery
(
aURI
std
:
:
move
(
aContentProcessesToNotify
)
)
;
return
history
-
>
QueueVisitedStatement
(
std
:
:
move
(
query
)
)
;
}
static
nsresult
Start
(
nsIURI
*
aURI
mozIVisitedStatusCallback
*
aCallback
=
nullptr
)
{
MOZ_ASSERT
(
aURI
"
Null
URI
"
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsMainThreadPtrHandle
<
mozIVisitedStatusCallback
>
callback
(
new
nsMainThreadPtrHolder
<
mozIVisitedStatusCallback
>
(
"
mozIVisitedStatusCallback
"
aCallback
)
)
;
History
*
history
=
History
:
:
GetService
(
)
;
NS_ENSURE_STATE
(
history
)
;
RefPtr
<
VisitedQuery
>
query
=
new
VisitedQuery
(
aURI
callback
)
;
return
history
-
>
QueueVisitedStatement
(
std
:
:
move
(
query
)
)
;
}
void
Execute
(
mozIStorageAsyncStatement
&
aStatement
)
{
nsresult
rv
=
URIBinder
:
:
Bind
(
&
aStatement
0
mURI
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
nsCOMPtr
<
mozIStoragePendingStatement
>
handle
;
rv
=
aStatement
.
ExecuteAsync
(
this
getter_AddRefs
(
handle
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
Unused
<
<
rv
;
}
NS_IMETHOD
HandleResult
(
mozIStorageResultSet
*
aResults
)
override
{
mIsVisited
=
true
;
return
NS_OK
;
}
NS_IMETHOD
HandleError
(
mozIStorageError
*
aError
)
override
{
return
NS_OK
;
}
NS_IMETHOD
HandleCompletion
(
uint16_t
aReason
)
override
{
if
(
aReason
=
=
mozIStorageStatementCallback
:
:
REASON_FINISHED
)
{
NotifyVisitedStatus
(
)
;
}
return
NS_OK
;
}
void
NotifyVisitedStatus
(
)
{
if
(
mCallback
)
{
mCallback
-
>
IsVisited
(
mURI
mIsVisited
)
;
return
;
}
if
(
History
*
history
=
History
:
:
GetService
(
)
)
{
auto
status
=
mIsVisited
?
IHistory
:
:
VisitedStatus
:
:
Visited
:
IHistory
:
:
VisitedStatus
:
:
Unvisited
;
history
-
>
NotifyVisited
(
mURI
status
&
mContentProcessesToNotify
)
;
}
}
private
:
explicit
VisitedQuery
(
nsIURI
*
aURI
const
nsMainThreadPtrHandle
<
mozIVisitedStatusCallback
>
&
aCallback
)
:
mURI
(
aURI
)
mCallback
(
aCallback
)
{
}
explicit
VisitedQuery
(
nsIURI
*
aURI
History
:
:
ContentParentSet
&
&
aContentProcessesToNotify
)
:
mURI
(
aURI
)
mContentProcessesToNotify
(
std
:
:
move
(
aContentProcessesToNotify
)
)
{
}
~
VisitedQuery
(
)
=
default
;
nsCOMPtr
<
nsIURI
>
mURI
;
nsMainThreadPtrHandle
<
mozIVisitedStatusCallback
>
mCallback
;
History
:
:
ContentParentSet
mContentProcessesToNotify
;
bool
mIsVisited
=
false
;
}
;
NS_IMPL_ISUPPORTS_INHERITED0
(
VisitedQuery
AsyncStatementCallback
)
class
NotifyManyVisitsObservers
:
public
Runnable
{
public
:
explicit
NotifyManyVisitsObservers
(
const
VisitData
&
aPlace
)
:
Runnable
(
"
places
:
:
NotifyManyVisitsObservers
"
)
mPlaces
(
{
aPlace
}
)
mHistory
(
History
:
:
GetService
(
)
)
{
}
explicit
NotifyManyVisitsObservers
(
nsTArray
<
VisitData
>
&
&
aPlaces
)
:
Runnable
(
"
places
:
:
NotifyManyVisitsObservers
"
)
mPlaces
(
std
:
:
move
(
aPlaces
)
)
mHistory
(
History
:
:
GetService
(
)
)
{
}
nsresult
NotifyVisit
(
nsNavHistory
*
aNavHistory
nsCOMPtr
<
nsIObserverService
>
&
aObsService
PRTime
aNow
nsIURI
*
aURI
const
VisitData
&
aPlace
)
{
if
(
aObsService
)
{
DebugOnly
<
nsresult
>
rv
=
aObsService
-
>
NotifyObservers
(
aURI
URI_VISIT_SAVED
nullptr
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Could
not
notify
observers
"
)
;
}
if
(
aNow
-
aPlace
.
visitTime
<
RECENTLY_VISITED_URIS_MAX_AGE
)
{
mHistory
-
>
AppendToRecentlyVisitedURIs
(
aURI
aPlace
.
hidden
)
;
}
mHistory
-
>
NotifyVisited
(
aURI
IHistory
:
:
VisitedStatus
:
:
Visited
)
;
aNavHistory
-
>
UpdateDaysOfHistory
(
aPlace
.
visitTime
)
;
return
NS_OK
;
}
void
AddPlaceForNotify
(
const
VisitData
&
aPlace
Sequence
<
OwningNonNull
<
PlacesEvent
>
>
&
aEvents
)
{
if
(
aPlace
.
transitionType
=
=
nsINavHistoryService
:
:
TRANSITION_EMBED
)
{
return
;
}
RefPtr
<
PlacesVisit
>
visitEvent
=
new
PlacesVisit
(
)
;
visitEvent
-
>
mVisitId
=
aPlace
.
visitId
;
visitEvent
-
>
mUrl
.
Assign
(
NS_ConvertUTF8toUTF16
(
aPlace
.
spec
)
)
;
visitEvent
-
>
mVisitTime
=
aPlace
.
visitTime
/
1000
;
visitEvent
-
>
mReferringVisitId
=
aPlace
.
referrerVisitId
;
visitEvent
-
>
mTransitionType
=
aPlace
.
transitionType
;
visitEvent
-
>
mPageGuid
.
Assign
(
aPlace
.
guid
)
;
visitEvent
-
>
mHidden
=
aPlace
.
hidden
;
visitEvent
-
>
mVisitCount
=
aPlace
.
visitCount
+
1
;
visitEvent
-
>
mTypedCount
=
static_cast
<
uint32_t
>
(
aPlace
.
typed
)
;
visitEvent
-
>
mLastKnownTitle
.
Assign
(
aPlace
.
title
)
;
bool
success
=
!
!
aEvents
.
AppendElement
(
visitEvent
.
forget
(
)
fallible
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
if
(
aPlace
.
titleChanged
)
{
RefPtr
<
PlacesVisitTitle
>
titleEvent
=
new
PlacesVisitTitle
(
)
;
titleEvent
-
>
mUrl
.
Assign
(
NS_ConvertUTF8toUTF16
(
aPlace
.
spec
)
)
;
titleEvent
-
>
mPageGuid
.
Assign
(
aPlace
.
guid
)
;
titleEvent
-
>
mTitle
.
Assign
(
aPlace
.
title
)
;
bool
success
=
!
!
aEvents
.
AppendElement
(
titleEvent
.
forget
(
)
fallible
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
This
should
be
called
on
the
main
thread
"
)
;
if
(
mHistory
-
>
IsShuttingDown
(
)
)
{
return
NS_OK
;
}
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
if
(
!
navHistory
)
{
NS_WARNING
(
"
Trying
to
notify
visits
observers
but
cannot
get
the
history
"
"
service
!
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
Sequence
<
OwningNonNull
<
PlacesEvent
>
>
events
;
PRTime
now
=
PR_Now
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mPlaces
.
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
uri
)
mPlaces
[
i
]
.
spec
)
)
;
if
(
!
uri
)
{
return
NS_ERROR_UNEXPECTED
;
}
AddPlaceForNotify
(
mPlaces
[
i
]
events
)
;
nsresult
rv
=
NotifyVisit
(
navHistory
obsService
now
uri
mPlaces
[
i
]
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
events
.
Length
(
)
>
0
)
{
PlacesObservers
:
:
NotifyListeners
(
events
)
;
}
return
NS_OK
;
}
private
:
AutoTArray
<
VisitData
1
>
mPlaces
;
RefPtr
<
History
>
mHistory
;
}
;
class
NotifyTitleObservers
:
public
Runnable
{
public
:
NotifyTitleObservers
(
const
nsCString
&
aSpec
const
nsString
&
aTitle
const
nsCString
&
aGUID
)
:
Runnable
(
"
places
:
:
NotifyTitleObservers
"
)
mSpec
(
aSpec
)
mTitle
(
aTitle
)
mGUID
(
aGUID
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
This
should
be
called
on
the
main
thread
"
)
;
RefPtr
<
PlacesVisitTitle
>
titleEvent
=
new
PlacesVisitTitle
(
)
;
titleEvent
-
>
mUrl
.
Assign
(
NS_ConvertUTF8toUTF16
(
mSpec
)
)
;
titleEvent
-
>
mPageGuid
.
Assign
(
mGUID
)
;
titleEvent
-
>
mTitle
.
Assign
(
mTitle
)
;
Sequence
<
OwningNonNull
<
PlacesEvent
>
>
events
;
bool
success
=
!
!
events
.
AppendElement
(
titleEvent
.
forget
(
)
fallible
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
PlacesObservers
:
:
NotifyListeners
(
events
)
;
return
NS_OK
;
}
private
:
const
nsCString
mSpec
;
const
nsString
mTitle
;
const
nsCString
mGUID
;
}
;
class
NotifyPlaceInfoCallback
:
public
Runnable
{
public
:
NotifyPlaceInfoCallback
(
const
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
&
aCallback
const
VisitData
&
aPlace
bool
aIsSingleVisit
nsresult
aResult
)
:
Runnable
(
"
places
:
:
NotifyPlaceInfoCallback
"
)
mCallback
(
aCallback
)
mPlace
(
aPlace
)
mResult
(
aResult
)
mIsSingleVisit
(
aIsSingleVisit
)
{
MOZ_ASSERT
(
aCallback
"
Must
pass
a
non
-
null
callback
!
"
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
This
should
be
called
on
the
main
thread
"
)
;
bool
hasValidURIs
=
true
;
nsCOMPtr
<
nsIURI
>
referrerURI
;
if
(
!
mPlace
.
referrerSpec
.
IsEmpty
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
referrerURI
)
mPlace
.
referrerSpec
)
)
;
hasValidURIs
=
!
!
referrerURI
;
}
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
uri
)
mPlace
.
spec
)
)
;
hasValidURIs
=
hasValidURIs
&
&
!
!
uri
;
nsCOMPtr
<
mozIPlaceInfo
>
place
;
if
(
mIsSingleVisit
)
{
nsCOMPtr
<
mozIVisitInfo
>
visit
=
new
VisitInfo
(
mPlace
.
visitId
mPlace
.
visitTime
mPlace
.
transitionType
referrerURI
.
forget
(
)
)
;
PlaceInfo
:
:
VisitsArray
visits
;
(
void
)
visits
.
AppendElement
(
visit
)
;
place
=
new
PlaceInfo
(
mPlace
.
placeId
mPlace
.
guid
uri
.
forget
(
)
mPlace
.
title
-
1
visits
)
;
}
else
{
place
=
new
PlaceInfo
(
mPlace
.
placeId
mPlace
.
guid
uri
.
forget
(
)
mPlace
.
title
-
1
)
;
}
if
(
NS_SUCCEEDED
(
mResult
)
&
&
hasValidURIs
)
{
(
void
)
mCallback
-
>
HandleResult
(
place
)
;
}
else
{
(
void
)
mCallback
-
>
HandleError
(
mResult
place
)
;
}
return
NS_OK
;
}
private
:
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
mCallback
;
VisitData
mPlace
;
const
nsresult
mResult
;
bool
mIsSingleVisit
;
}
;
class
NotifyCompletion
:
public
Runnable
{
public
:
explicit
NotifyCompletion
(
const
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
&
aCallback
uint32_t
aUpdatedCount
=
0
)
:
Runnable
(
"
places
:
:
NotifyCompletion
"
)
mCallback
(
aCallback
)
mUpdatedCount
(
aUpdatedCount
)
{
MOZ_ASSERT
(
aCallback
"
Must
pass
a
non
-
null
callback
!
"
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
NS_IsMainThread
(
)
)
{
(
void
)
mCallback
-
>
HandleCompletion
(
mUpdatedCount
)
;
}
else
{
(
void
)
NS_DispatchToMainThread
(
this
)
;
}
return
NS_OK
;
}
private
:
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
mCallback
;
uint32_t
mUpdatedCount
;
}
;
bool
CanAddURI
(
nsIURI
*
aURI
const
nsCString
&
aGUID
=
"
"
_ns
mozIVisitInfoCallback
*
aCallback
=
nullptr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
navHistory
false
)
;
bool
canAdd
;
nsresult
rv
=
navHistory
-
>
CanAddURI
(
aURI
&
canAdd
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
canAdd
)
{
return
true
;
}
;
if
(
aCallback
)
{
VisitData
place
(
aURI
)
;
place
.
guid
=
aGUID
;
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
callback
(
new
nsMainThreadPtrHolder
<
mozIVisitInfoCallback
>
(
"
mozIVisitInfoCallback
"
aCallback
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyPlaceInfoCallback
(
callback
place
true
NS_ERROR_INVALID_ARG
)
;
(
void
)
NS_DispatchToMainThread
(
event
)
;
}
return
false
;
}
class
InsertVisitedURIs
final
:
public
Runnable
{
public
:
static
nsresult
Start
(
mozIStorageConnection
*
aConnection
nsTArray
<
VisitData
>
&
&
aPlaces
mozIVisitInfoCallback
*
aCallback
=
nullptr
uint32_t
aInitialUpdatedCount
=
0
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
This
should
be
called
on
the
main
thread
"
)
;
MOZ_ASSERT
(
aPlaces
.
Length
(
)
>
0
"
Must
pass
a
non
-
empty
array
!
"
)
;
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
MOZ_ASSERT
(
navHistory
"
Could
not
get
nsNavHistory
?
!
"
)
;
if
(
!
navHistory
)
{
return
NS_ERROR_FAILURE
;
}
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
callback
(
new
nsMainThreadPtrHolder
<
mozIVisitInfoCallback
>
(
"
mozIVisitInfoCallback
"
aCallback
)
)
;
bool
ignoreErrors
=
false
ignoreResults
=
false
;
if
(
aCallback
)
{
Unused
<
<
aCallback
-
>
GetIgnoreErrors
(
&
ignoreErrors
)
;
Unused
<
<
aCallback
-
>
GetIgnoreResults
(
&
ignoreResults
)
;
}
RefPtr
<
InsertVisitedURIs
>
event
=
new
InsertVisitedURIs
(
aConnection
std
:
:
move
(
aPlaces
)
callback
ignoreErrors
ignoreResults
aInitialUpdatedCount
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetInterface
(
aConnection
)
;
NS_ENSURE_TRUE
(
target
NS_ERROR_UNEXPECTED
)
;
nsresult
rv
=
target
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
This
should
not
be
called
on
the
main
thread
"
)
;
nsresult
rv
=
InnerRun
(
)
;
if
(
mSuccessfulUpdatedCount
>
0
)
{
NS_DispatchToMainThread
(
new
NotifyRankingChanged
(
)
)
;
}
if
(
!
!
mCallback
)
{
NS_DispatchToMainThread
(
new
NotifyCompletion
(
mCallback
mSuccessfulUpdatedCount
)
)
;
}
return
rv
;
}
nsresult
InnerRun
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MutexAutoLock
lockedScope
(
mHistory
-
>
mBlockShutdownMutex
)
;
if
(
mHistory
-
>
IsShuttingDown
(
)
)
{
return
NS_OK
;
}
mozStorageTransaction
transaction
(
mDBConn
false
mozIStorageConnection
:
:
TRANSACTION_IMMEDIATE
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
transaction
.
Start
(
)
)
)
;
const
VisitData
*
lastFetchedPlace
=
nullptr
;
uint32_t
lastFetchedVisitCount
=
0
;
bool
shouldChunkNotifications
=
mPlaces
.
Length
(
)
>
NOTIFY_VISITS_CHUNK_SIZE
;
nsTArray
<
VisitData
>
notificationChunk
;
if
(
shouldChunkNotifications
)
{
notificationChunk
.
SetCapacity
(
NOTIFY_VISITS_CHUNK_SIZE
)
;
}
for
(
nsTArray
<
VisitData
>
:
:
size_type
i
=
0
;
i
<
mPlaces
.
Length
(
)
;
i
+
+
)
{
VisitData
&
place
=
mPlaces
.
ElementAt
(
i
)
;
bool
typed
=
place
.
typed
;
bool
hidden
=
place
.
hidden
;
bool
known
=
lastFetchedPlace
&
&
lastFetchedPlace
-
>
spec
.
Equals
(
place
.
spec
)
;
if
(
!
known
)
{
nsresult
rv
=
mHistory
-
>
FetchPageInfo
(
place
&
known
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
!
!
mCallback
&
&
!
mIgnoreErrors
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyPlaceInfoCallback
(
mCallback
place
true
rv
)
;
return
NS_DispatchToMainThread
(
event
)
;
}
return
NS_OK
;
}
lastFetchedPlace
=
&
mPlaces
.
ElementAt
(
i
)
;
lastFetchedVisitCount
=
lastFetchedPlace
-
>
visitCount
;
}
else
{
place
.
placeId
=
lastFetchedPlace
-
>
placeId
;
place
.
guid
=
lastFetchedPlace
-
>
guid
;
place
.
lastVisitId
=
lastFetchedPlace
-
>
visitId
;
place
.
lastVisitTime
=
lastFetchedPlace
-
>
visitTime
;
if
(
!
place
.
title
.
IsVoid
(
)
)
{
place
.
titleChanged
=
!
lastFetchedPlace
-
>
title
.
Equals
(
place
.
title
)
;
}
place
.
frecency
=
lastFetchedPlace
-
>
frecency
;
place
.
visitCount
=
+
+
lastFetchedVisitCount
;
}
if
(
typed
!
=
lastFetchedPlace
-
>
typed
)
{
place
.
typed
=
true
;
}
if
(
hidden
!
=
lastFetchedPlace
-
>
hidden
)
{
place
.
hidden
=
false
;
}
if
(
!
known
|
|
!
lastFetchedPlace
-
>
hidden
)
{
place
.
shouldUpdateHidden
=
false
;
}
FetchReferrerInfo
(
place
)
;
UpdateVisitSource
(
place
mHistory
)
;
nsresult
rv
=
DoDatabaseInserts
(
known
place
)
;
if
(
!
!
mCallback
)
{
if
(
(
NS_SUCCEEDED
(
rv
)
&
&
!
mIgnoreResults
)
|
|
(
NS_FAILED
(
rv
)
&
&
!
mIgnoreErrors
)
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyPlaceInfoCallback
(
mCallback
place
true
rv
)
;
nsresult
rv2
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv2
rv2
)
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
shouldChunkNotifications
)
{
int32_t
numRemaining
=
mPlaces
.
Length
(
)
-
(
i
+
1
)
;
notificationChunk
.
AppendElement
(
place
)
;
if
(
notificationChunk
.
Length
(
)
=
=
NOTIFY_VISITS_CHUNK_SIZE
|
|
numRemaining
=
=
0
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyManyVisitsObservers
(
std
:
:
move
(
notificationChunk
)
)
;
rv
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
nextCapacity
=
std
:
:
min
(
NOTIFY_VISITS_CHUNK_SIZE
numRemaining
)
;
notificationChunk
.
SetCapacity
(
nextCapacity
)
;
}
}
mSuccessfulUpdatedCount
+
+
;
}
{
nsAutoCString
query
(
"
DELETE
FROM
moz_updateoriginsinsert_temp
"
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
mHistory
-
>
GetStatement
(
query
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
nsresult
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
{
nsAutoCString
query
(
"
DELETE
FROM
moz_updateoriginsupdate_temp
"
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
mHistory
-
>
GetStatement
(
query
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
nsresult
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsresult
rv
=
transaction
.
Commit
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
shouldChunkNotifications
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyManyVisitsObservers
(
std
:
:
move
(
mPlaces
)
)
;
rv
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
private
:
InsertVisitedURIs
(
mozIStorageConnection
*
aConnection
nsTArray
<
VisitData
>
&
&
aPlaces
const
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
&
aCallback
bool
aIgnoreErrors
bool
aIgnoreResults
uint32_t
aInitialUpdatedCount
)
:
Runnable
(
"
places
:
:
InsertVisitedURIs
"
)
mDBConn
(
aConnection
)
mPlaces
(
std
:
:
move
(
aPlaces
)
)
mCallback
(
aCallback
)
mIgnoreErrors
(
aIgnoreErrors
)
mIgnoreResults
(
aIgnoreResults
)
mSuccessfulUpdatedCount
(
aInitialUpdatedCount
)
mHistory
(
History
:
:
GetService
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
This
should
be
called
on
the
main
thread
"
)
;
#
ifdef
DEBUG
for
(
nsTArray
<
VisitData
>
:
:
size_type
i
=
0
;
i
<
mPlaces
.
Length
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
NS_NewURI
(
getter_AddRefs
(
uri
)
mPlaces
[
i
]
.
spec
)
)
)
;
MOZ_ASSERT
(
CanAddURI
(
uri
)
"
Passed
a
VisitData
with
a
URI
we
cannot
add
to
history
!
"
)
;
}
#
endif
mSponsoredSessionTimeoutSec
=
Preferences
:
:
GetUint
(
"
places
.
sponsoredSession
.
timeOutSec
"
3600
)
;
}
nsresult
DoDatabaseInserts
(
bool
aKnown
VisitData
&
aPlace
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
This
should
not
be
called
on
the
main
thread
"
)
;
nsresult
rv
;
if
(
aKnown
)
{
rv
=
mHistory
-
>
UpdatePlace
(
aPlace
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
mHistory
-
>
InsertPlace
(
aPlace
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aPlace
.
placeId
=
nsNavHistory
:
:
sLastInsertedPlaceId
;
}
MOZ_ASSERT
(
aPlace
.
placeId
>
0
)
;
rv
=
AddVisit
(
aPlace
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aPlace
.
shouldUpdateFrecency
)
{
rv
=
UpdateFrecency
(
aPlace
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
void
FetchReferrerInfo
(
VisitData
&
aPlace
)
{
if
(
aPlace
.
referrerSpec
.
IsEmpty
(
)
)
{
return
;
}
VisitData
referrer
;
referrer
.
spec
=
aPlace
.
referrerSpec
;
if
(
aPlace
.
referrerSpec
.
Equals
(
aPlace
.
spec
)
)
{
referrer
=
aPlace
;
aPlace
.
referrerVisitId
=
aPlace
.
lastVisitId
;
}
else
{
bool
exists
=
false
;
if
(
NS_SUCCEEDED
(
mHistory
-
>
FetchPageInfo
(
referrer
&
exists
)
)
&
&
exists
)
{
aPlace
.
referrerVisitId
=
referrer
.
lastVisitId
;
}
}
if
(
!
aPlace
.
referrerVisitId
|
|
!
referrer
.
lastVisitTime
|
|
aPlace
.
visitTime
-
referrer
.
lastVisitTime
>
RECENT_EVENT_THRESHOLD
)
{
aPlace
.
referrerSpec
.
Truncate
(
)
;
aPlace
.
referrerVisitId
=
0
;
}
}
nsresult
AddVisit
(
VisitData
&
_place
)
{
MOZ_ASSERT
(
_place
.
placeId
>
0
)
;
nsresult
rv
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
stmt
=
mHistory
-
>
GetStatement
(
"
INSERT
INTO
moz_historyvisits
"
"
(
from_visit
place_id
visit_date
visit_type
session
source
"
"
triggeringPlaceId
)
"
"
VALUES
(
:
from_visit
:
page_id
:
visit_date
:
visit_type
0
:
source
"
"
:
triggeringPlaceId
)
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
BindInt64ByName
(
"
page_id
"
_ns
_place
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt64ByName
(
"
from_visit
"
_ns
_place
.
referrerVisitId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt64ByName
(
"
visit_date
"
_ns
_place
.
visitTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
transitionType
=
_place
.
transitionType
;
MOZ_ASSERT
(
transitionType
>
=
nsINavHistoryService
:
:
TRANSITION_LINK
&
&
transitionType
<
=
nsINavHistoryService
:
:
TRANSITION_RELOAD
"
Invalid
transition
type
!
"
)
;
rv
=
stmt
-
>
BindInt32ByName
(
"
visit_type
"
_ns
transitionType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt32ByName
(
"
source
"
_ns
_place
.
source
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
_place
.
triggeringPlaceId
!
=
0
)
{
rv
=
stmt
-
>
BindInt64ByName
(
"
triggeringPlaceId
"
_ns
_place
.
triggeringPlaceId
)
;
}
else
{
rv
=
stmt
-
>
BindNullByName
(
"
triggeringPlaceId
"
_ns
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
_place
.
visitId
=
nsNavHistory
:
:
sLastInsertedVisitId
;
MOZ_ASSERT
(
_place
.
visitId
>
0
)
;
return
NS_OK
;
}
nsresult
UpdateFrecency
(
const
VisitData
&
aPlace
)
{
MOZ_ASSERT
(
aPlace
.
shouldUpdateFrecency
)
;
MOZ_ASSERT
(
aPlace
.
placeId
>
0
)
;
nsresult
rv
;
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
mHistory
-
>
GetStatement
(
"
UPDATE
moz_places
"
"
SET
frecency
=
CALCULATE_FRECENCY
(
:
page_id
:
redirect
)
"
"
WHERE
id
=
:
page_id
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
BindInt64ByName
(
"
page_id
"
_ns
aPlace
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt32ByName
(
"
redirect
"
_ns
aPlace
.
useFrecencyRedirectBonus
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
aPlace
.
hidden
&
&
aPlace
.
shouldUpdateHidden
)
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
stmt
=
mHistory
-
>
GetStatement
(
"
UPDATE
moz_places
"
"
SET
hidden
=
0
"
"
WHERE
id
=
:
page_id
AND
frecency
<
>
0
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
BindInt64ByName
(
"
page_id
"
_ns
aPlace
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
UpdateVisitSource
(
VisitData
&
aPlace
History
*
aHistory
)
{
aPlace
.
source
=
aPlace
.
bookmarked
?
nsINavHistoryService
:
:
VISIT_SOURCE_BOOKMARKED
:
nsINavHistoryService
:
:
VISIT_SOURCE_ORGANIC
;
if
(
aPlace
.
triggeringSponsoredURL
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
(
aPlace
.
visitTime
-
aPlace
.
triggeringSponsoredURLVisitTimeMS
*
PR_USEC_PER_MSEC
)
>
mSponsoredSessionTimeoutSec
*
PR_USEC_PER_SEC
)
{
return
NS_OK
;
}
if
(
aPlace
.
spec
.
Equals
(
aPlace
.
triggeringSponsoredURL
)
)
{
aPlace
.
source
=
nsINavHistoryService
:
:
VISIT_SOURCE_SPONSORED
;
return
NS_OK
;
}
if
(
!
aPlace
.
baseDomain
.
Equals
(
aPlace
.
triggeringSponsoredURLBaseDomain
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
stmt
=
aHistory
-
>
GetStatement
(
"
SELECT
id
FROM
moz_places
h
"
"
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
nsresult
rv
=
URIBinder
:
:
Bind
(
stmt
"
url
"
_ns
aPlace
.
triggeringSponsoredURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
bool
exists
;
rv
=
stmt
-
>
ExecuteStep
(
&
exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
exists
)
{
return
NS_OK
;
}
rv
=
stmt
-
>
GetInt64
(
0
&
aPlace
.
triggeringPlaceId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aPlace
.
source
=
nsINavHistoryService
:
:
VISIT_SOURCE_SPONSORED
;
return
NS_OK
;
}
mozIStorageConnection
*
mDBConn
;
nsTArray
<
VisitData
>
mPlaces
;
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
mCallback
;
bool
mIgnoreErrors
;
bool
mIgnoreResults
;
uint32_t
mSuccessfulUpdatedCount
;
uint32_t
mSponsoredSessionTimeoutSec
;
RefPtr
<
History
>
mHistory
;
}
;
class
SetPageTitle
:
public
Runnable
{
public
:
static
nsresult
Start
(
mozIStorageConnection
*
aConnection
nsIURI
*
aURI
const
nsAString
&
aTitle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
This
should
be
called
on
the
main
thread
"
)
;
MOZ_ASSERT
(
aURI
"
Must
pass
a
non
-
null
URI
object
!
"
)
;
nsCString
spec
;
nsresult
rv
=
aURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
SetPageTitle
>
event
=
new
SetPageTitle
(
spec
aTitle
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetInterface
(
aConnection
)
;
NS_ENSURE_TRUE
(
target
NS_ERROR_UNEXPECTED
)
;
rv
=
target
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
This
should
not
be
called
on
the
main
thread
"
)
;
bool
exists
;
nsresult
rv
=
mHistory
-
>
FetchPageInfo
(
mPlace
&
exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
exists
|
|
!
mPlace
.
titleChanged
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mPlace
.
placeId
>
0
"
We
somehow
have
an
invalid
place
id
here
!
"
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
mHistory
-
>
GetStatement
(
"
UPDATE
moz_places
"
"
SET
title
=
:
page_title
"
"
WHERE
id
=
:
page_id
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
{
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
BindInt64ByName
(
"
page_id
"
_ns
mPlace
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mPlace
.
title
.
IsEmpty
(
)
)
{
rv
=
stmt
-
>
BindNullByName
(
"
page_title
"
_ns
)
;
}
else
{
rv
=
stmt
-
>
BindStringByName
(
"
page_title
"
_ns
StringHead
(
mPlace
.
title
TITLE_LENGTH_MAX
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyTitleObservers
(
mPlace
.
spec
mPlace
.
title
mPlace
.
guid
)
;
rv
=
NS_DispatchToMainThread
(
event
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
private
:
SetPageTitle
(
const
nsCString
&
aSpec
const
nsAString
&
aTitle
)
:
Runnable
(
"
places
:
:
SetPageTitle
"
)
mHistory
(
History
:
:
GetService
(
)
)
{
mPlace
.
spec
=
aSpec
;
mPlace
.
title
=
aTitle
;
}
VisitData
mPlace
;
RefPtr
<
History
>
mHistory
;
}
;
void
NotifyEmbedVisit
(
VisitData
&
aPlace
mozIVisitInfoCallback
*
aCallback
=
nullptr
)
{
MOZ_ASSERT
(
aPlace
.
transitionType
=
=
nsINavHistoryService
:
:
TRANSITION_EMBED
"
Must
only
pass
TRANSITION_EMBED
visits
to
this
!
"
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
called
on
the
main
thread
!
"
)
;
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
uri
)
aPlace
.
spec
)
)
;
if
(
!
uri
)
{
return
;
}
if
(
!
!
aCallback
)
{
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
callback
(
new
nsMainThreadPtrHolder
<
mozIVisitInfoCallback
>
(
"
mozIVisitInfoCallback
"
aCallback
)
)
;
bool
ignoreResults
=
false
;
Unused
<
<
aCallback
-
>
GetIgnoreResults
(
&
ignoreResults
)
;
if
(
!
ignoreResults
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyPlaceInfoCallback
(
callback
aPlace
true
NS_OK
)
;
(
void
)
NS_DispatchToMainThread
(
event
)
;
}
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyManyVisitsObservers
(
aPlace
)
;
(
void
)
NS_DispatchToMainThread
(
event
)
;
}
History
*
History
:
:
gService
=
nullptr
;
History
:
:
History
(
)
:
mShuttingDown
(
false
)
mShuttingDownMutex
(
"
History
:
:
mShuttingDownMutex
"
)
mBlockShutdownMutex
(
"
History
:
:
mBlockShutdownMutex
"
)
mRecentlyVisitedURIs
(
RECENTLY_VISITED_URIS_SIZE
)
{
NS_ASSERTION
(
!
gService
"
Ruh
-
roh
!
This
service
has
already
been
created
!
"
)
;
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsIProperties
>
dirsvc
=
components
:
:
Directory
:
:
Service
(
)
;
bool
haveProfile
=
false
;
MOZ_RELEASE_ASSERT
(
dirsvc
&
&
NS_SUCCEEDED
(
dirsvc
-
>
Has
(
NS_APP_USER_PROFILE_50_DIR
&
haveProfile
)
)
&
&
haveProfile
"
Can
'
t
construct
history
service
if
there
is
no
profile
.
"
)
;
}
gService
=
this
;
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
NS_WARNING_ASSERTION
(
os
"
Observer
service
was
not
found
!
"
)
;
if
(
os
)
{
(
void
)
os
-
>
AddObserver
(
this
TOPIC_PLACES_SHUTDOWN
false
)
;
}
}
History
:
:
~
History
(
)
{
UnregisterWeakMemoryReporter
(
this
)
;
MOZ_ASSERT
(
gService
=
=
this
)
;
gService
=
nullptr
;
}
void
History
:
:
InitMemoryReporter
(
)
{
RegisterWeakMemoryReporter
(
this
)
;
}
class
ConcurrentStatementsHolder
final
:
public
mozIStorageCompletionCallback
{
public
:
NS_DECL_ISUPPORTS
explicit
ConcurrentStatementsHolder
(
mozIStorageConnection
*
aDBConn
)
:
mShutdownWasInvoked
(
false
)
{
DebugOnly
<
nsresult
>
rv
=
aDBConn
-
>
AsyncClone
(
true
this
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
NS_IMETHOD
Complete
(
nsresult
aStatus
nsISupports
*
aConnection
)
override
{
if
(
NS_FAILED
(
aStatus
)
)
{
return
NS_OK
;
}
mReadOnlyDBConn
=
do_QueryInterface
(
aConnection
)
;
if
(
mShutdownWasInvoked
)
{
Shutdown
(
)
;
return
NS_OK
;
}
if
(
!
mIsVisitedStatement
)
{
(
void
)
mReadOnlyDBConn
-
>
CreateAsyncStatement
(
nsLiteralCString
(
"
SELECT
1
FROM
moz_places
h
"
"
WHERE
url_hash
=
hash
(
?
1
)
AND
url
=
?
1
AND
"
"
last_visit_date
NOTNULL
"
)
getter_AddRefs
(
mIsVisitedStatement
)
)
;
MOZ_ASSERT
(
mIsVisitedStatement
)
;
auto
queries
=
std
:
:
move
(
mVisitedQueries
)
;
if
(
mIsVisitedStatement
)
{
for
(
auto
&
query
:
queries
)
{
query
-
>
Execute
(
*
mIsVisitedStatement
)
;
}
}
}
return
NS_OK
;
}
void
QueueVisitedStatement
(
RefPtr
<
VisitedQuery
>
aCallback
)
{
if
(
mIsVisitedStatement
)
{
aCallback
-
>
Execute
(
*
mIsVisitedStatement
)
;
}
else
{
mVisitedQueries
.
AppendElement
(
std
:
:
move
(
aCallback
)
)
;
}
}
void
Shutdown
(
)
{
mShutdownWasInvoked
=
true
;
if
(
mReadOnlyDBConn
)
{
mVisitedQueries
.
Clear
(
)
;
DebugOnly
<
nsresult
>
rv
;
if
(
mIsVisitedStatement
)
{
rv
=
mIsVisitedStatement
-
>
Finalize
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
rv
=
mReadOnlyDBConn
-
>
AsyncClose
(
nullptr
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
mReadOnlyDBConn
=
nullptr
;
}
}
private
:
~
ConcurrentStatementsHolder
(
)
=
default
;
nsCOMPtr
<
mozIStorageAsyncConnection
>
mReadOnlyDBConn
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
mIsVisitedStatement
;
nsTArray
<
RefPtr
<
VisitedQuery
>
>
mVisitedQueries
;
bool
mShutdownWasInvoked
;
}
;
NS_IMPL_ISUPPORTS
(
ConcurrentStatementsHolder
mozIStorageCompletionCallback
)
nsresult
History
:
:
QueueVisitedStatement
(
RefPtr
<
VisitedQuery
>
aQuery
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsShuttingDown
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
mConcurrentStatementsHolder
)
{
mozIStorageConnection
*
dbConn
=
GetDBConn
(
)
;
NS_ENSURE_STATE
(
dbConn
)
;
mConcurrentStatementsHolder
=
new
ConcurrentStatementsHolder
(
dbConn
)
;
}
mConcurrentStatementsHolder
-
>
QueueVisitedStatement
(
std
:
:
move
(
aQuery
)
)
;
return
NS_OK
;
}
nsresult
History
:
:
InsertPlace
(
VisitData
&
aPlace
)
{
MOZ_ASSERT
(
aPlace
.
placeId
=
=
0
"
should
not
have
a
valid
place
id
!
"
)
;
MOZ_ASSERT
(
!
aPlace
.
shouldUpdateHidden
"
We
should
not
need
to
update
hidden
"
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
must
be
called
off
of
the
main
thread
!
"
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
GetStatement
(
"
INSERT
INTO
moz_places
"
"
(
url
url_hash
title
rev_host
hidden
typed
frecency
guid
)
"
"
VALUES
(
:
url
hash
(
:
url
)
:
title
:
rev_host
:
hidden
:
typed
"
"
:
frecency
:
guid
)
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
nsresult
rv
=
stmt
-
>
BindStringByName
(
"
rev_host
"
_ns
aPlace
.
revHost
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
URIBinder
:
:
Bind
(
stmt
"
url
"
_ns
aPlace
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsString
title
=
aPlace
.
title
;
if
(
title
.
IsEmpty
(
)
)
{
rv
=
stmt
-
>
BindNullByName
(
"
title
"
_ns
)
;
}
else
{
title
.
Assign
(
StringHead
(
aPlace
.
title
TITLE_LENGTH_MAX
)
)
;
rv
=
stmt
-
>
BindStringByName
(
"
title
"
_ns
title
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt32ByName
(
"
typed
"
_ns
aPlace
.
typed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
frecency
=
aPlace
.
shouldUpdateFrecency
?
aPlace
.
frecency
:
0
;
rv
=
stmt
-
>
BindInt32ByName
(
"
frecency
"
_ns
frecency
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt32ByName
(
"
hidden
"
_ns
aPlace
.
hidden
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aPlace
.
guid
.
IsVoid
(
)
)
{
rv
=
GenerateGUID
(
aPlace
.
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
stmt
-
>
BindUTF8StringByName
(
"
guid
"
_ns
aPlace
.
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
History
:
:
UpdatePlace
(
const
VisitData
&
aPlace
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
must
be
called
off
of
the
main
thread
!
"
)
;
MOZ_ASSERT
(
aPlace
.
placeId
>
0
"
must
have
a
valid
place
id
!
"
)
;
MOZ_ASSERT
(
!
aPlace
.
guid
.
IsVoid
(
)
"
must
have
a
guid
!
"
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
bool
titleIsVoid
=
aPlace
.
title
.
IsVoid
(
)
;
if
(
titleIsVoid
)
{
stmt
=
GetStatement
(
"
UPDATE
moz_places
"
"
SET
hidden
=
:
hidden
"
"
typed
=
:
typed
"
"
guid
=
:
guid
"
"
WHERE
id
=
:
page_id
"
)
;
}
else
{
stmt
=
GetStatement
(
"
UPDATE
moz_places
"
"
SET
title
=
:
title
"
"
hidden
=
:
hidden
"
"
typed
=
:
typed
"
"
guid
=
:
guid
"
"
WHERE
id
=
:
page_id
"
)
;
}
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scoper
(
stmt
)
;
nsresult
rv
;
if
(
!
titleIsVoid
)
{
if
(
aPlace
.
title
.
IsEmpty
(
)
)
{
rv
=
stmt
-
>
BindNullByName
(
"
title
"
_ns
)
;
}
else
{
rv
=
stmt
-
>
BindStringByName
(
"
title
"
_ns
StringHead
(
aPlace
.
title
TITLE_LENGTH_MAX
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
stmt
-
>
BindInt32ByName
(
"
typed
"
_ns
aPlace
.
typed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt32ByName
(
"
hidden
"
_ns
aPlace
.
hidden
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
"
guid
"
_ns
aPlace
.
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt64ByName
(
"
page_id
"
_ns
aPlace
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
History
:
:
FetchPageInfo
(
VisitData
&
_place
bool
*
_exists
)
{
MOZ_ASSERT
(
!
_place
.
spec
.
IsEmpty
(
)
|
|
!
_place
.
guid
.
IsEmpty
(
)
"
must
have
either
a
non
-
empty
spec
or
guid
!
"
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
must
be
called
off
of
the
main
thread
!
"
)
;
nsresult
rv
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
bool
selectByURI
=
!
_place
.
spec
.
IsEmpty
(
)
;
if
(
selectByURI
)
{
stmt
=
GetStatement
(
"
SELECT
guid
id
title
hidden
typed
frecency
visit_count
"
"
last_visit_date
"
"
(
SELECT
id
FROM
moz_historyvisits
"
"
WHERE
place_id
=
h
.
id
AND
visit_date
=
h
.
last_visit_date
)
AS
"
"
last_visit_id
"
"
EXISTS
(
SELECT
1
FROM
moz_bookmarks
WHERE
fk
=
h
.
id
)
AS
bookmarked
"
"
FROM
moz_places
h
"
"
WHERE
url_hash
=
hash
(
:
page_url
)
AND
url
=
:
page_url
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
rv
=
URIBinder
:
:
Bind
(
stmt
"
page_url
"
_ns
_place
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
stmt
=
GetStatement
(
"
SELECT
url
id
title
hidden
typed
frecency
visit_count
"
"
last_visit_date
"
"
(
SELECT
id
FROM
moz_historyvisits
"
"
WHERE
place_id
=
h
.
id
AND
visit_date
=
h
.
last_visit_date
)
AS
"
"
last_visit_id
"
"
EXISTS
(
SELECT
1
FROM
moz_bookmarks
WHERE
fk
=
h
.
id
)
AS
bookmarked
"
"
FROM
moz_places
h
"
"
WHERE
guid
=
:
guid
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
"
guid
"
_ns
_place
.
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mozStorageStatementScoper
scoper
(
stmt
)
;
rv
=
stmt
-
>
ExecuteStep
(
_exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
*
_exists
)
{
return
NS_OK
;
}
if
(
selectByURI
)
{
if
(
_place
.
guid
.
IsEmpty
(
)
)
{
rv
=
stmt
-
>
GetUTF8String
(
0
_place
.
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
{
nsAutoCString
spec
;
rv
=
stmt
-
>
GetUTF8String
(
0
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
_place
.
spec
=
spec
;
}
rv
=
stmt
-
>
GetInt64
(
1
&
_place
.
placeId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
title
;
rv
=
stmt
-
>
GetString
(
2
title
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
_place
.
title
.
IsVoid
(
)
)
{
_place
.
title
=
title
;
}
else
{
_place
.
titleChanged
=
!
(
_place
.
title
.
Equals
(
title
)
)
&
&
!
(
_place
.
title
.
IsEmpty
(
)
&
&
title
.
IsVoid
(
)
)
;
}
int32_t
hidden
;
rv
=
stmt
-
>
GetInt32
(
3
&
hidden
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
_place
.
hidden
=
!
!
hidden
;
int32_t
typed
;
rv
=
stmt
-
>
GetInt32
(
4
&
typed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
_place
.
typed
=
!
!
typed
;
rv
=
stmt
-
>
GetInt32
(
5
&
_place
.
frecency
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
visitCount
;
rv
=
stmt
-
>
GetInt32
(
6
&
visitCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
_place
.
visitCount
=
visitCount
;
rv
=
stmt
-
>
GetInt64
(
7
&
_place
.
lastVisitTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
GetInt64
(
8
&
_place
.
lastVisitId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
bookmarked
;
rv
=
stmt
-
>
GetInt32
(
9
&
bookmarked
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
_place
.
bookmarked
=
bookmarked
=
=
1
;
return
NS_OK
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
HistoryMallocSizeOf
)
NS_IMETHODIMP
History
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
history
-
links
-
hashtable
"
KIND_HEAP
UNITS_BYTES
SizeOfIncludingThis
(
HistoryMallocSizeOf
)
"
Memory
used
by
the
hashtable
that
records
changes
to
the
visited
state
"
"
of
links
.
"
)
;
return
NS_OK
;
}
size_t
History
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
size_t
size
=
aMallocSizeOf
(
this
)
;
size
+
=
mTrackedURIs
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
entry
:
mTrackedURIs
.
Values
(
)
)
{
size
+
=
entry
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
return
size
;
}
History
*
History
:
:
GetService
(
)
{
if
(
gService
)
{
return
gService
;
}
nsCOMPtr
<
IHistory
>
service
=
components
:
:
History
:
:
Service
(
)
;
if
(
service
)
{
NS_ASSERTION
(
gService
"
Our
constructor
was
not
run
?
!
"
)
;
}
return
gService
;
}
already_AddRefed
<
History
>
History
:
:
GetSingleton
(
)
{
if
(
!
gService
)
{
RefPtr
<
History
>
svc
=
new
History
(
)
;
MOZ_ASSERT
(
gService
=
=
svc
.
get
(
)
)
;
svc
-
>
InitMemoryReporter
(
)
;
return
svc
.
forget
(
)
;
}
return
do_AddRef
(
gService
)
;
}
mozIStorageConnection
*
History
:
:
GetDBConn
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsShuttingDown
(
)
)
{
return
nullptr
;
}
if
(
!
mDB
)
{
mDB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_TRUE
(
mDB
nullptr
)
;
mDB
-
>
EnsureConnection
(
)
;
NS_ENSURE_TRUE
(
mDB
nullptr
)
;
}
return
mDB
-
>
MainConn
(
)
;
}
const
mozIStorageConnection
*
History
:
:
GetConstDBConn
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
{
MOZ_ASSERT
(
mDB
|
|
IsShuttingDown
(
)
)
;
if
(
IsShuttingDown
(
)
|
|
!
mDB
)
{
return
nullptr
;
}
}
return
mDB
-
>
MainConn
(
)
;
}
void
History
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lockedScope
(
mBlockShutdownMutex
)
;
{
MutexAutoLock
lockedScope
(
mShuttingDownMutex
)
;
MOZ_ASSERT
(
!
mShuttingDown
&
&
"
Shutdown
was
called
more
than
once
!
"
)
;
mShuttingDown
=
true
;
}
if
(
mConcurrentStatementsHolder
)
{
mConcurrentStatementsHolder
-
>
Shutdown
(
)
;
}
}
void
History
:
:
AppendToRecentlyVisitedURIs
(
nsIURI
*
aURI
bool
aHidden
)
{
PRTime
now
=
PR_Now
(
)
;
mRecentlyVisitedURIs
.
InsertOrUpdate
(
aURI
RecentURIVisit
{
now
aHidden
}
)
;
for
(
auto
iter
=
mRecentlyVisitedURIs
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
(
now
-
iter
.
Data
(
)
.
mTime
)
>
RECENTLY_VISITED_URIS_MAX_AGE
)
{
iter
.
Remove
(
)
;
}
}
}
NS_IMETHODIMP
History
:
:
VisitURI
(
nsIWidget
*
aWidget
nsIURI
*
aURI
nsIURI
*
aLastVisitedURI
uint32_t
aFlags
uint64_t
aBrowserId
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aURI
)
;
if
(
IsShuttingDown
(
)
)
{
return
NS_OK
;
}
if
(
XRE_IsContentProcess
(
)
)
{
if
(
!
BaseHistory
:
:
CanStore
(
aURI
)
)
{
return
NS_OK
;
}
NS_ENSURE_ARG
(
aWidget
)
;
BrowserChild
*
browserChild
=
aWidget
-
>
GetOwningBrowserChild
(
)
;
NS_ENSURE_TRUE
(
browserChild
NS_ERROR_FAILURE
)
;
(
void
)
browserChild
-
>
SendVisitURI
(
aURI
aLastVisitedURI
aFlags
aBrowserId
)
;
return
NS_OK
;
}
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
navHistory
NS_ERROR_OUT_OF_MEMORY
)
;
bool
canAdd
;
nsresult
rv
=
navHistory
-
>
CanAddURI
(
aURI
&
canAdd
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
canAdd
)
{
return
NS_OK
;
}
bool
reload
=
false
;
if
(
aLastVisitedURI
)
{
rv
=
aURI
-
>
Equals
(
aLastVisitedURI
&
reload
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsTArray
<
VisitData
>
placeArray
(
1
)
;
placeArray
.
AppendElement
(
VisitData
(
aURI
aLastVisitedURI
)
)
;
VisitData
&
place
=
placeArray
.
ElementAt
(
0
)
;
NS_ENSURE_FALSE
(
place
.
spec
.
IsEmpty
(
)
NS_ERROR_INVALID_ARG
)
;
place
.
visitTime
=
PR_Now
(
)
;
uint32_t
recentFlags
=
navHistory
-
>
GetRecentFlags
(
aURI
)
;
bool
isFollowedLink
=
recentFlags
&
nsNavHistory
:
:
RECENT_ACTIVATED
;
uint32_t
transitionType
=
nsINavHistoryService
:
:
TRANSITION_LINK
;
if
(
!
(
aFlags
&
IHistory
:
:
TOP_LEVEL
)
&
&
!
isFollowedLink
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_EMBED
;
}
else
if
(
aFlags
&
IHistory
:
:
REDIRECT_TEMPORARY
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_REDIRECT_TEMPORARY
;
}
else
if
(
aFlags
&
IHistory
:
:
REDIRECT_PERMANENT
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_REDIRECT_PERMANENT
;
}
else
if
(
reload
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_RELOAD
;
}
else
if
(
(
recentFlags
&
nsNavHistory
:
:
RECENT_TYPED
)
&
&
!
(
aFlags
&
IHistory
:
:
UNRECOVERABLE_ERROR
)
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_TYPED
;
}
else
if
(
recentFlags
&
nsNavHistory
:
:
RECENT_BOOKMARKED
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_BOOKMARK
;
}
else
if
(
!
(
aFlags
&
IHistory
:
:
TOP_LEVEL
)
&
&
isFollowedLink
)
{
transitionType
=
nsINavHistoryService
:
:
TRANSITION_FRAMED_LINK
;
}
place
.
SetTransitionType
(
transitionType
)
;
bool
isRedirect
=
aFlags
&
IHistory
:
:
REDIRECT_SOURCE
;
if
(
isRedirect
)
{
place
.
useFrecencyRedirectBonus
=
(
aFlags
&
IHistory
:
:
REDIRECT_SOURCE_PERMANENT
)
|
|
transitionType
!
=
nsINavHistoryService
:
:
TRANSITION_TYPED
;
}
place
.
hidden
=
GetHiddenState
(
isRedirect
place
.
transitionType
)
;
if
(
aFlags
&
IHistory
:
:
UNRECOVERABLE_ERROR
)
{
place
.
shouldUpdateFrecency
=
false
;
}
if
(
reload
)
{
auto
entry
=
mRecentlyVisitedURIs
.
Lookup
(
aURI
)
;
if
(
entry
&
&
(
PR_Now
(
)
-
entry
-
>
mTime
)
<
RECENTLY_VISITED_URIS_MAX_AGE
)
{
bool
wasHidden
=
entry
-
>
mHidden
;
AppendToRecentlyVisitedURIs
(
aURI
place
.
hidden
)
;
if
(
!
wasHidden
|
|
place
.
hidden
)
{
return
NS_OK
;
}
}
}
nsCOMPtr
<
nsIBrowserWindowTracker
>
bwt
=
do_ImportModule
(
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
"
BrowserWindowTracker
"
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsISupports
>
browser
;
rv
=
bwt
-
>
GetBrowserById
(
aBrowserId
getter_AddRefs
(
browser
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
browser
)
{
RefPtr
<
Element
>
browserElement
=
static_cast
<
Element
*
>
(
browser
.
get
(
)
)
;
nsAutoString
triggeringSponsoredURL
;
browserElement
-
>
GetAttribute
(
u
"
triggeringSponsoredURL
"
_ns
triggeringSponsoredURL
)
;
if
(
!
triggeringSponsoredURL
.
IsEmpty
(
)
)
{
place
.
triggeringSponsoredURL
.
Assign
(
NS_ConvertUTF16toUTF8
(
triggeringSponsoredURL
)
)
;
nsAutoString
triggeringSponsoredURLVisitTimeMS
;
browserElement
-
>
GetAttribute
(
u
"
triggeringSponsoredURLVisitTimeMS
"
_ns
triggeringSponsoredURLVisitTimeMS
)
;
place
.
triggeringSponsoredURLVisitTimeMS
=
triggeringSponsoredURLVisitTimeMS
.
ToInteger64
(
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
currentURL
;
rv
=
NS_MutateURI
(
new
net
:
:
nsStandardURL
:
:
Mutator
(
)
)
.
SetSpec
(
place
.
spec
)
.
Finalize
(
currentURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
sponsoredURL
;
rv
=
NS_MutateURI
(
new
net
:
:
nsStandardURL
:
:
Mutator
(
)
)
.
SetSpec
(
place
.
triggeringSponsoredURL
)
.
Finalize
(
sponsoredURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
navHistory
-
>
DomainNameFromURI
(
currentURL
place
.
baseDomain
)
;
navHistory
-
>
DomainNameFromURI
(
sponsoredURL
place
.
triggeringSponsoredURLBaseDomain
)
;
}
}
}
if
(
place
.
transitionType
=
=
nsINavHistoryService
:
:
TRANSITION_EMBED
)
{
NotifyEmbedVisit
(
place
)
;
}
else
{
mozIStorageConnection
*
dbConn
=
GetDBConn
(
)
;
NS_ENSURE_STATE
(
dbConn
)
;
rv
=
InsertVisitedURIs
:
:
Start
(
dbConn
std
:
:
move
(
placeArray
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
History
:
:
SetURITitle
(
nsIURI
*
aURI
const
nsAString
&
aTitle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aURI
)
;
if
(
IsShuttingDown
(
)
)
{
return
NS_OK
;
}
if
(
XRE_IsContentProcess
(
)
)
{
auto
*
cpc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
cpc
"
Content
Protocol
is
NULL
!
"
)
;
Unused
<
<
cpc
-
>
SendSetURITitle
(
aURI
PromiseFlatString
(
aTitle
)
)
;
return
NS_OK
;
}
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
navHistory
NS_ERROR_FAILURE
)
;
bool
canAdd
;
nsresult
rv
=
navHistory
-
>
CanAddURI
(
aURI
&
canAdd
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
canAdd
)
{
return
NS_OK
;
}
mozIStorageConnection
*
dbConn
=
GetDBConn
(
)
;
NS_ENSURE_STATE
(
dbConn
)
;
return
SetPageTitle
:
:
Start
(
dbConn
aURI
aTitle
)
;
}
NS_IMETHODIMP
History
:
:
UpdatePlaces
(
JS
:
:
Handle
<
JS
:
:
Value
>
aPlaceInfos
mozIVisitInfoCallback
*
aCallback
JSContext
*
aCtx
)
{
NS_ENSURE_TRUE
(
NS_IsMainThread
(
)
NS_ERROR_UNEXPECTED
)
;
NS_ENSURE_TRUE
(
!
aPlaceInfos
.
isPrimitive
(
)
NS_ERROR_INVALID_ARG
)
;
uint32_t
infosLength
;
JS
:
:
Rooted
<
JSObject
*
>
infos
(
aCtx
)
;
nsresult
rv
=
GetJSArrayFromJSValue
(
aPlaceInfos
aCtx
&
infos
&
infosLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
initialUpdatedCount
=
0
;
nsTArray
<
VisitData
>
visitData
;
for
(
uint32_t
i
=
0
;
i
<
infosLength
;
i
+
+
)
{
JS
:
:
Rooted
<
JSObject
*
>
info
(
aCtx
)
;
nsresult
rv
=
GetJSObjectFromArray
(
aCtx
infos
i
&
info
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
=
GetURIFromJSObject
(
aCtx
info
"
uri
"
)
;
nsCString
guid
;
{
nsString
fatGUID
;
GetStringFromJSObject
(
aCtx
info
"
guid
"
fatGUID
)
;
if
(
fatGUID
.
IsVoid
(
)
)
{
guid
.
SetIsVoid
(
true
)
;
}
else
{
CopyUTF16toUTF8
(
fatGUID
guid
)
;
}
}
if
(
uri
&
&
!
CanAddURI
(
uri
guid
aCallback
)
)
{
continue
;
}
NS_ENSURE_ARG
(
uri
|
|
!
guid
.
IsVoid
(
)
)
;
bool
isValidGUID
=
IsValidGUID
(
guid
)
;
NS_ENSURE_ARG
(
guid
.
IsVoid
(
)
|
|
isValidGUID
)
;
nsString
title
;
GetStringFromJSObject
(
aCtx
info
"
title
"
title
)
;
JS
:
:
Rooted
<
JSObject
*
>
visits
(
aCtx
nullptr
)
;
{
JS
:
:
Rooted
<
JS
:
:
Value
>
visitsVal
(
aCtx
)
;
bool
rc
=
JS_GetProperty
(
aCtx
info
"
visits
"
&
visitsVal
)
;
NS_ENSURE_TRUE
(
rc
NS_ERROR_UNEXPECTED
)
;
if
(
!
visitsVal
.
isPrimitive
(
)
)
{
visits
=
visitsVal
.
toObjectOrNull
(
)
;
bool
isArray
;
if
(
!
JS
:
:
IsArrayObject
(
aCtx
visits
&
isArray
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
isArray
)
{
return
NS_ERROR_INVALID_ARG
;
}
}
}
NS_ENSURE_ARG
(
visits
)
;
uint32_t
visitsLength
=
0
;
if
(
visits
)
{
(
void
)
JS
:
:
GetArrayLength
(
aCtx
visits
&
visitsLength
)
;
}
NS_ENSURE_ARG
(
visitsLength
>
0
)
;
visitData
.
SetCapacity
(
visitData
.
Length
(
)
+
visitsLength
)
;
for
(
uint32_t
j
=
0
;
j
<
visitsLength
;
j
+
+
)
{
JS
:
:
Rooted
<
JSObject
*
>
visit
(
aCtx
)
;
rv
=
GetJSObjectFromArray
(
aCtx
visits
j
&
visit
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
VisitData
&
data
=
*
visitData
.
AppendElement
(
VisitData
(
uri
)
)
;
if
(
!
title
.
IsEmpty
(
)
)
{
data
.
title
=
title
;
}
else
if
(
!
title
.
IsVoid
(
)
)
{
data
.
title
.
SetIsVoid
(
false
)
;
}
data
.
guid
=
guid
;
rv
=
GetIntFromJSObject
(
aCtx
visit
"
visitDate
"
&
data
.
visitTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
data
.
visitTime
<
(
PR_Now
(
)
/
1000
)
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIXPConnect
>
xpc
=
nsIXPConnect
:
:
XPConnect
(
)
;
Unused
<
<
xpc
-
>
DebugDumpJSStack
(
false
false
false
)
;
MOZ_CRASH
(
"
invalid
time
format
passed
to
updatePlaces
"
)
;
#
endif
return
NS_ERROR_INVALID_ARG
;
}
uint32_t
transitionType
=
0
;
rv
=
GetIntFromJSObject
(
aCtx
visit
"
transitionType
"
&
transitionType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_ARG_RANGE
(
transitionType
nsINavHistoryService
:
:
TRANSITION_LINK
nsINavHistoryService
:
:
TRANSITION_RELOAD
)
;
data
.
SetTransitionType
(
transitionType
)
;
data
.
hidden
=
GetHiddenState
(
false
transitionType
)
;
if
(
transitionType
=
=
nsINavHistoryService
:
:
TRANSITION_EMBED
)
{
NotifyEmbedVisit
(
data
aCallback
)
;
visitData
.
RemoveLastElement
(
)
;
initialUpdatedCount
+
+
;
continue
;
}
nsCOMPtr
<
nsIURI
>
referrer
=
GetURIFromJSObject
(
aCtx
visit
"
referrerURI
"
)
;
if
(
referrer
)
{
(
void
)
referrer
-
>
GetSpec
(
data
.
referrerSpec
)
;
}
}
}
mozIStorageConnection
*
dbConn
=
GetDBConn
(
)
;
NS_ENSURE_STATE
(
dbConn
)
;
nsMainThreadPtrHandle
<
mozIVisitInfoCallback
>
callback
(
new
nsMainThreadPtrHolder
<
mozIVisitInfoCallback
>
(
"
mozIVisitInfoCallback
"
aCallback
)
)
;
if
(
visitData
.
Length
(
)
)
{
nsresult
rv
=
InsertVisitedURIs
:
:
Start
(
dbConn
std
:
:
move
(
visitData
)
callback
initialUpdatedCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
aCallback
)
{
nsCOMPtr
<
nsIEventTarget
>
backgroundThread
=
do_GetInterface
(
dbConn
)
;
NS_ENSURE_TRUE
(
backgroundThread
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
NotifyCompletion
(
callback
initialUpdatedCount
)
;
return
backgroundThread
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
History
:
:
IsURIVisited
(
nsIURI
*
aURI
mozIVisitedStatusCallback
*
aCallback
)
{
NS_ENSURE_STATE
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aURI
)
;
NS_ENSURE_ARG
(
aCallback
)
;
return
VisitedQuery
:
:
Start
(
aURI
aCallback
)
;
}
void
History
:
:
StartPendingVisitedQueries
(
PendingVisitedQueries
&
&
aQueries
)
{
if
(
XRE_IsContentProcess
(
)
)
{
auto
*
cpc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
cpc
"
Content
Protocol
is
NULL
!
"
)
;
constexpr
size_t
kBatchLimit
=
4000
;
nsTArray
<
RefPtr
<
nsIURI
>
>
uris
(
aQueries
.
Count
(
)
)
;
for
(
const
auto
&
entry
:
aQueries
)
{
uris
.
AppendElement
(
entry
.
GetKey
(
)
)
;
MOZ_ASSERT
(
entry
.
GetData
(
)
.
IsEmpty
(
)
"
Child
process
shouldn
'
t
have
parent
requests
"
)
;
if
(
uris
.
Length
(
)
=
=
kBatchLimit
)
{
Unused
<
<
cpc
-
>
SendStartVisitedQueries
(
uris
)
;
uris
.
ClearAndRetainStorage
(
)
;
}
}
if
(
!
uris
.
IsEmpty
(
)
)
{
Unused
<
<
cpc
-
>
SendStartVisitedQueries
(
uris
)
;
}
}
else
{
for
(
auto
&
entry
:
aQueries
)
{
nsresult
queryStatus
=
VisitedQuery
:
:
Start
(
entry
.
GetKey
(
)
std
:
:
move
(
*
entry
.
GetModifiableData
(
)
)
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
queryStatus
)
)
;
}
}
}
NS_IMETHODIMP
History
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
strcmp
(
aTopic
TOPIC_PLACES_SHUTDOWN
)
=
=
0
)
{
Shutdown
(
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
(
void
)
os
-
>
RemoveObserver
(
this
TOPIC_PLACES_SHUTDOWN
)
;
}
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
History
IHistory
mozIAsyncHistory
nsIObserver
nsIMemoryReporter
)
}
}
