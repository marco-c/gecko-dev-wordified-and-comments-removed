var
EXPORTED_SYMBOLS
=
[
"
BookmarkJSONUtils
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
PlacesUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesBackups
"
"
resource
:
/
/
gre
/
modules
/
PlacesBackups
.
jsm
"
)
;
const
OLD_BOOKMARK_QUERY_TRANSLATIONS
=
{
"
PLACES_ROOT
"
:
PlacesUtils
.
bookmarks
.
rootGuid
"
BOOKMARKS_MENU
"
:
PlacesUtils
.
bookmarks
.
menuGuid
"
TAGS
"
:
PlacesUtils
.
bookmarks
.
tagsGuid
"
UNFILED_BOOKMARKS
"
:
PlacesUtils
.
bookmarks
.
unfiledGuid
"
TOOLBAR
"
:
PlacesUtils
.
bookmarks
.
toolbarGuid
"
MOBILE_BOOKMARKS
"
:
PlacesUtils
.
bookmarks
.
mobileGuid
}
;
function
generateHash
(
aString
)
{
let
cryptoHash
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
cryptoHash
.
init
(
Ci
.
nsICryptoHash
.
MD5
)
;
let
stringStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stringStream
.
data
=
aString
;
cryptoHash
.
updateFromStream
(
stringStream
-
1
)
;
return
cryptoHash
.
finish
(
true
)
.
replace
(
/
\
/
/
g
"
-
"
)
;
}
var
BookmarkJSONUtils
=
Object
.
freeze
(
{
async
importFromURL
(
aSpec
{
replace
:
aReplace
=
false
source
:
aSource
=
aReplace
?
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE
:
PlacesUtils
.
bookmarks
.
SOURCES
.
IMPORT
}
=
{
}
)
{
notifyObservers
(
PlacesUtils
.
TOPIC_BOOKMARKS_RESTORE_BEGIN
aReplace
)
;
try
{
let
importer
=
new
BookmarkImporter
(
aReplace
aSource
)
;
await
importer
.
importFromURL
(
aSpec
)
;
notifyObservers
(
PlacesUtils
.
TOPIC_BOOKMARKS_RESTORE_SUCCESS
aReplace
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
restore
bookmarks
from
"
+
aSpec
+
"
:
"
+
ex
)
;
notifyObservers
(
PlacesUtils
.
TOPIC_BOOKMARKS_RESTORE_FAILED
aReplace
)
;
}
}
async
importFromFile
(
aFilePath
{
replace
:
aReplace
=
false
source
:
aSource
=
aReplace
?
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE
:
PlacesUtils
.
bookmarks
.
SOURCES
.
IMPORT
}
=
{
}
)
{
notifyObservers
(
PlacesUtils
.
TOPIC_BOOKMARKS_RESTORE_BEGIN
aReplace
)
;
try
{
if
(
!
(
await
OS
.
File
.
exists
(
aFilePath
)
)
)
throw
new
Error
(
"
Cannot
restore
from
nonexisting
json
file
"
)
;
let
importer
=
new
BookmarkImporter
(
aReplace
aSource
)
;
if
(
aFilePath
.
endsWith
(
"
jsonlz4
"
)
)
{
await
importer
.
importFromCompressedFile
(
aFilePath
)
;
}
else
{
await
importer
.
importFromURL
(
OS
.
Path
.
toFileURI
(
aFilePath
)
)
;
}
notifyObservers
(
PlacesUtils
.
TOPIC_BOOKMARKS_RESTORE_SUCCESS
aReplace
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
restore
bookmarks
from
"
+
aFilePath
+
"
:
"
+
ex
)
;
notifyObservers
(
PlacesUtils
.
TOPIC_BOOKMARKS_RESTORE_FAILED
aReplace
)
;
throw
ex
;
}
}
async
exportToFile
(
aFilePath
aOptions
=
{
}
)
{
let
[
bookmarks
count
]
=
await
PlacesBackups
.
getBookmarksTree
(
)
;
let
startTime
=
Date
.
now
(
)
;
let
jsonString
=
JSON
.
stringify
(
bookmarks
)
;
try
{
Services
.
telemetry
.
getHistogramById
(
"
PLACES_BACKUPS_TOJSON_MS
"
)
.
add
(
Date
.
now
(
)
-
startTime
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Unable
to
report
telemetry
.
"
)
;
}
let
hash
=
generateHash
(
jsonString
)
;
if
(
hash
=
=
=
aOptions
.
failIfHashIs
)
{
let
e
=
new
Error
(
"
Hash
conflict
"
)
;
e
.
becauseSameHash
=
true
;
throw
e
;
}
let
writeOptions
=
{
tmpPath
:
OS
.
Path
.
join
(
aFilePath
+
"
.
tmp
"
)
}
;
if
(
aOptions
.
compress
)
writeOptions
.
compression
=
"
lz4
"
;
await
OS
.
File
.
writeAtomic
(
aFilePath
jsonString
writeOptions
)
;
return
{
count
hash
}
;
}
}
)
;
function
BookmarkImporter
(
aReplace
aSource
)
{
this
.
_replace
=
aReplace
;
this
.
_source
=
aSource
;
}
BookmarkImporter
.
prototype
=
{
async
importFromURL
(
spec
)
{
let
nodes
=
await
(
await
fetch
(
spec
)
)
.
json
(
)
;
if
(
!
nodes
.
children
|
|
!
nodes
.
children
.
length
)
{
return
;
}
await
this
.
import
(
nodes
)
;
}
importFromCompressedFile
:
async
function
BI_importFromCompressedFile
(
aFilePath
)
{
let
aResult
=
await
OS
.
File
.
read
(
aFilePath
{
compression
:
"
lz4
"
}
)
;
let
decoder
=
new
TextDecoder
(
)
;
let
jsonString
=
decoder
.
decode
(
aResult
)
;
await
this
.
importFromJSON
(
jsonString
)
;
}
async
importFromJSON
(
aString
)
{
let
nodes
=
PlacesUtils
.
unwrapNodes
(
aString
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
)
;
if
(
nodes
.
length
=
=
0
|
|
!
nodes
[
0
]
.
children
|
|
nodes
[
0
]
.
children
.
length
=
=
0
)
{
return
;
}
await
this
.
import
(
nodes
[
0
]
)
;
}
async
import
(
rootNode
)
{
let
nodes
=
rootNode
.
children
.
filter
(
node
=
>
node
.
root
!
=
=
"
tagsFolder
"
)
;
if
(
this
.
_replace
)
{
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
{
source
:
this
.
_source
}
)
;
}
let
folderIdToGuidMap
=
{
}
;
for
(
let
node
of
nodes
)
{
if
(
!
node
.
children
|
|
node
.
children
.
length
=
=
0
)
continue
;
node
.
source
=
this
.
_source
;
let
folders
=
translateTreeTypes
(
node
)
;
folderIdToGuidMap
=
Object
.
assign
(
folderIdToGuidMap
folders
)
;
}
for
(
let
node
of
nodes
)
{
if
(
!
node
.
children
|
|
node
.
children
.
length
=
=
0
)
{
continue
;
}
if
(
!
PlacesUtils
.
bookmarks
.
userContentRoots
.
includes
(
node
.
guid
)
)
{
continue
;
}
fixupSearchQueries
(
node
folderIdToGuidMap
)
;
await
PlacesUtils
.
bookmarks
.
insertTree
(
node
{
fixupOrSkipInvalidEntries
:
true
}
)
;
try
{
insertFaviconsForTree
(
node
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Failed
to
insert
favicons
:
{
ex
}
)
;
}
}
}
}
;
function
notifyObservers
(
topic
replace
)
{
Services
.
obs
.
notifyObservers
(
null
topic
replace
?
"
json
"
:
"
json
-
append
"
)
;
}
function
fixupSearchQueries
(
aNode
aFolderIdMap
)
{
if
(
aNode
.
url
&
&
aNode
.
url
.
startsWith
(
"
place
:
"
)
)
{
aNode
.
url
=
fixupQuery
(
aNode
.
url
aFolderIdMap
)
;
}
if
(
aNode
.
children
)
{
for
(
let
child
of
aNode
.
children
)
{
fixupSearchQueries
(
child
aFolderIdMap
)
;
}
}
}
function
fixupQuery
(
aQueryURL
aFolderIdMap
)
{
let
invalid
=
false
;
let
convert
=
function
(
str
existingFolderId
)
{
let
guid
;
if
(
Object
.
keys
(
OLD_BOOKMARK_QUERY_TRANSLATIONS
)
.
includes
(
existingFolderId
)
)
{
guid
=
OLD_BOOKMARK_QUERY_TRANSLATIONS
[
existingFolderId
]
;
}
else
{
guid
=
aFolderIdMap
[
existingFolderId
]
;
if
(
!
guid
)
{
invalid
=
true
;
return
invalidOldParentId
=
{
existingFolderId
}
;
}
}
return
parent
=
{
guid
}
;
}
;
let
url
=
aQueryURL
.
replace
(
/
folder
=
(
[
A
-
Za
-
z0
-
9_
]
+
)
/
g
convert
)
;
if
(
invalid
)
{
url
+
=
"
&
excludeItems
=
1
"
;
}
return
url
;
}
const
rootToFolderGuidMap
=
{
"
placesRoot
"
:
PlacesUtils
.
bookmarks
.
rootGuid
"
bookmarksMenuFolder
"
:
PlacesUtils
.
bookmarks
.
menuGuid
"
unfiledBookmarksFolder
"
:
PlacesUtils
.
bookmarks
.
unfiledGuid
"
toolbarFolder
"
:
PlacesUtils
.
bookmarks
.
toolbarGuid
"
mobileFolder
"
:
PlacesUtils
.
bookmarks
.
mobileGuid
}
;
function
fixupRootFolderGuid
(
node
)
{
if
(
!
node
.
guid
&
&
node
.
root
&
&
node
.
root
in
rootToFolderGuidMap
)
{
node
.
guid
=
rootToFolderGuidMap
[
node
.
root
]
;
}
}
function
translateTreeTypes
(
node
)
{
let
folderIdToGuidMap
=
{
}
;
if
(
node
.
uri
)
{
node
.
url
=
node
.
uri
;
delete
node
.
uri
;
}
switch
(
node
.
type
)
{
case
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
:
node
.
type
=
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
;
let
isMobileFolder
=
node
.
annos
&
&
node
.
annos
.
some
(
anno
=
>
anno
.
name
=
=
PlacesUtils
.
MOBILE_ROOT_ANNO
)
;
if
(
isMobileFolder
)
{
node
.
guid
=
PlacesUtils
.
bookmarks
.
mobileGuid
;
}
else
{
fixupRootFolderGuid
(
node
)
;
}
folderIdToGuidMap
[
node
.
id
]
=
node
.
guid
;
break
;
case
PlacesUtils
.
TYPE_X_MOZ_PLACE
:
node
.
type
=
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
;
break
;
case
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
:
node
.
type
=
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
;
if
(
"
title
"
in
node
)
{
delete
node
.
title
;
}
break
;
default
:
Cu
.
reportError
(
Unexpected
bookmark
type
{
node
.
type
}
)
;
break
;
}
if
(
node
.
dateAdded
)
{
node
.
dateAdded
=
PlacesUtils
.
toDate
(
node
.
dateAdded
)
;
}
if
(
node
.
lastModified
)
{
let
lastModified
=
PlacesUtils
.
toDate
(
node
.
lastModified
)
;
if
(
lastModified
>
=
node
.
dateAdded
)
{
node
.
lastModified
=
lastModified
;
}
else
{
delete
node
.
lastModified
;
}
}
if
(
node
.
tags
)
{
node
.
tags
=
node
.
tags
.
split
(
"
"
)
.
filter
(
aTag
=
>
aTag
.
length
>
0
&
&
aTag
.
length
<
=
PlacesUtils
.
bookmarks
.
MAX_TAG_LENGTH
)
;
if
(
!
node
.
tags
.
length
)
{
delete
node
.
tags
;
}
}
if
(
node
.
postData
=
=
null
)
{
delete
node
.
postData
;
}
if
(
!
node
.
children
)
{
return
folderIdToGuidMap
;
}
node
.
children
=
node
.
children
.
sort
(
(
a
b
)
=
>
{
return
a
.
index
-
b
.
index
;
}
)
;
for
(
let
child
of
node
.
children
)
{
let
folders
=
translateTreeTypes
(
child
)
;
folderIdToGuidMap
=
Object
.
assign
(
folderIdToGuidMap
folders
)
;
}
return
folderIdToGuidMap
;
}
function
insertFaviconForNode
(
node
)
{
if
(
node
.
icon
)
{
try
{
let
faviconURI
=
Services
.
io
.
newURI
(
"
fake
-
favicon
-
uri
:
"
+
node
.
url
)
;
PlacesUtils
.
favicons
.
replaceFaviconDataFromDataURL
(
faviconURI
node
.
icon
0
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
PlacesUtils
.
favicons
.
setAndFetchFaviconForPage
(
Services
.
io
.
newURI
(
node
.
url
)
faviconURI
false
PlacesUtils
.
favicons
.
FAVICON_LOAD_NON_PRIVATE
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
import
favicon
data
:
"
+
ex
)
;
}
}
if
(
!
node
.
iconUri
)
{
return
;
}
try
{
PlacesUtils
.
favicons
.
setAndFetchFaviconForPage
(
Services
.
io
.
newURI
(
node
.
url
)
Services
.
io
.
newURI
(
node
.
iconUri
)
false
PlacesUtils
.
favicons
.
FAVICON_LOAD_NON_PRIVATE
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
import
favicon
URI
:
"
+
ex
)
;
}
}
function
insertFaviconsForTree
(
nodeTree
)
{
insertFaviconForNode
(
nodeTree
)
;
if
(
nodeTree
.
children
)
{
for
(
let
child
of
nodeTree
.
children
)
{
insertFaviconsForTree
(
child
)
;
}
}
}
