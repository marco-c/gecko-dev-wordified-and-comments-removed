"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PlacesSyncUtils
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
Cu
.
importGlobalProperties
(
[
"
URL
"
"
URLSearchParams
"
]
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
var
PlacesSyncUtils
=
{
}
;
const
{
SOURCE_SYNC
}
=
Ci
.
nsINavBookmarksService
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ROOT_SYNC_ID_TO_GUID
"
(
)
=
>
(
{
menu
:
PlacesUtils
.
bookmarks
.
menuGuid
places
:
PlacesUtils
.
bookmarks
.
rootGuid
tags
:
PlacesUtils
.
bookmarks
.
tagsGuid
toolbar
:
PlacesUtils
.
bookmarks
.
toolbarGuid
unfiled
:
PlacesUtils
.
bookmarks
.
unfiledGuid
mobile
:
PlacesUtils
.
bookmarks
.
mobileGuid
}
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ROOT_GUID_TO_SYNC_ID
"
(
)
=
>
(
{
[
PlacesUtils
.
bookmarks
.
menuGuid
]
:
"
menu
"
[
PlacesUtils
.
bookmarks
.
rootGuid
]
:
"
places
"
[
PlacesUtils
.
bookmarks
.
tagsGuid
]
:
"
tags
"
[
PlacesUtils
.
bookmarks
.
toolbarGuid
]
:
"
toolbar
"
[
PlacesUtils
.
bookmarks
.
unfiledGuid
]
:
"
unfiled
"
[
PlacesUtils
.
bookmarks
.
mobileGuid
]
:
"
mobile
"
}
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ROOTS
"
(
)
=
>
Object
.
keys
(
ROOT_SYNC_ID_TO_GUID
)
)
;
const
BookmarkSyncUtils
=
PlacesSyncUtils
.
bookmarks
=
Object
.
freeze
(
{
SMART_BOOKMARKS_ANNO
:
"
Places
/
SmartBookmark
"
DESCRIPTION_ANNO
:
"
bookmarkProperties
/
description
"
SIDEBAR_ANNO
:
"
bookmarkProperties
/
loadInSidebar
"
SYNC_PARENT_ANNO
:
"
sync
/
parent
"
SYNC_MOBILE_ROOT_ANNO
:
"
mobile
/
bookmarksRoot
"
KINDS
:
{
BOOKMARK
:
"
bookmark
"
MICROSUMMARY
:
"
microsummary
"
QUERY
:
"
query
"
FOLDER
:
"
folder
"
LIVEMARK
:
"
livemark
"
SEPARATOR
:
"
separator
"
}
get
ROOTS
(
)
{
return
ROOTS
;
}
guidToSyncId
(
guid
)
{
return
ROOT_GUID_TO_SYNC_ID
[
guid
]
|
|
guid
;
}
syncIdToGuid
(
syncId
)
{
return
ROOT_SYNC_ID_TO_GUID
[
syncId
]
|
|
syncId
;
}
fetchChildSyncIds
:
Task
.
async
(
function
*
(
parentSyncId
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
syncId
(
parentSyncId
)
;
let
parentGuid
=
BookmarkSyncUtils
.
syncIdToGuid
(
parentSyncId
)
;
let
db
=
yield
PlacesUtils
.
promiseDBConnection
(
)
;
let
children
=
yield
fetchAllChildren
(
db
parentGuid
)
;
return
children
.
map
(
child
=
>
BookmarkSyncUtils
.
guidToSyncId
(
child
.
guid
)
)
;
}
)
order
:
Task
.
async
(
function
*
(
parentSyncId
childSyncIds
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
syncId
(
parentSyncId
)
;
if
(
!
childSyncIds
.
length
)
{
return
undefined
;
}
let
parentGuid
=
BookmarkSyncUtils
.
syncIdToGuid
(
parentSyncId
)
;
if
(
parentGuid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
)
{
return
undefined
;
}
let
orderedChildrenGuids
=
childSyncIds
.
map
(
BookmarkSyncUtils
.
syncIdToGuid
)
;
return
PlacesUtils
.
bookmarks
.
reorder
(
parentGuid
orderedChildrenGuids
{
source
:
SOURCE_SYNC
}
)
;
}
)
remove
:
Task
.
async
(
function
*
(
syncId
options
=
{
}
)
{
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
syncId
)
;
if
(
guid
in
ROOT_GUID_TO_SYNC_ID
)
{
BookmarkSyncLog
.
warn
(
remove
:
Refusing
to
remove
root
{
syncId
}
)
;
return
null
;
}
return
PlacesUtils
.
bookmarks
.
remove
(
guid
Object
.
assign
(
{
}
options
{
source
:
SOURCE_SYNC
}
)
)
;
}
)
isRootSyncID
(
syncID
)
{
return
ROOT_SYNC_ID_TO_GUID
.
hasOwnProperty
(
syncID
)
;
}
changeGuid
:
Task
.
async
(
function
*
(
oldGuid
newGuid
)
{
PlacesUtils
.
BOOKMARK_VALIDATORS
.
guid
(
oldGuid
)
;
PlacesUtils
.
BOOKMARK_VALIDATORS
.
guid
(
newGuid
)
;
let
itemId
=
yield
PlacesUtils
.
promiseItemId
(
oldGuid
)
;
if
(
PlacesUtils
.
isRootItem
(
itemId
)
)
{
throw
new
Error
(
Cannot
change
GUID
of
Places
root
{
oldGuid
}
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
changeGuid
"
Task
.
async
(
function
*
(
db
)
{
yield
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
guid
=
:
newGuid
WHERE
id
=
:
itemId
{
newGuid
itemId
}
)
;
PlacesUtils
.
invalidateCachedGuidFor
(
itemId
)
;
return
newGuid
;
}
)
)
;
}
)
update
:
Task
.
async
(
function
*
(
info
)
{
let
updateInfo
=
validateSyncBookmarkObject
(
info
{
syncId
:
{
required
:
true
}
}
)
;
return
updateSyncBookmark
(
updateInfo
)
;
}
)
insert
:
Task
.
async
(
function
*
(
info
)
{
let
insertInfo
=
validateNewBookmark
(
info
)
;
return
insertSyncBookmark
(
insertInfo
)
;
}
)
fetch
:
Task
.
async
(
function
*
(
syncId
)
{
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
syncId
)
;
let
bookmarkItem
=
yield
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
;
if
(
!
bookmarkItem
)
{
return
null
;
}
let
kind
=
yield
getKindForItem
(
bookmarkItem
)
;
let
item
;
switch
(
kind
)
{
case
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
:
case
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
:
item
=
yield
fetchBookmarkItem
(
bookmarkItem
)
;
break
;
case
BookmarkSyncUtils
.
KINDS
.
QUERY
:
item
=
yield
fetchQueryItem
(
bookmarkItem
)
;
break
;
case
BookmarkSyncUtils
.
KINDS
.
FOLDER
:
item
=
yield
fetchFolderItem
(
bookmarkItem
)
;
break
;
case
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
:
item
=
yield
fetchLivemarkItem
(
bookmarkItem
)
;
break
;
case
BookmarkSyncUtils
.
KINDS
.
SEPARATOR
:
item
=
yield
placesBookmarkToSyncBookmark
(
bookmarkItem
)
;
item
.
index
=
bookmarkItem
.
index
;
break
;
default
:
throw
new
Error
(
Unknown
bookmark
kind
:
{
kind
}
)
;
}
if
(
bookmarkItem
.
parentGuid
)
{
let
parent
=
yield
PlacesUtils
.
bookmarks
.
fetch
(
bookmarkItem
.
parentGuid
)
;
if
(
"
title
"
in
parent
)
{
item
.
parentTitle
=
parent
.
title
;
}
}
return
item
;
}
)
getKindForSyncId
(
syncId
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
syncId
(
syncId
)
;
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
syncId
)
;
return
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
.
then
(
item
=
>
{
if
(
!
item
)
{
return
null
;
}
return
getKindForItem
(
item
)
}
)
;
}
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
BookmarkSyncLog
"
(
)
=
>
{
return
Log
.
repository
.
getLogger
(
"
BookmarkSyncUtils
"
)
;
}
)
;
function
validateSyncBookmarkObject
(
input
behavior
)
{
return
PlacesUtils
.
validateItemProperties
(
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
input
behavior
)
;
}
var
fetchAllChildren
=
Task
.
async
(
function
*
(
db
parentGuid
)
{
let
rows
=
yield
db
.
executeCached
(
SELECT
id
parent
position
type
guid
FROM
moz_bookmarks
WHERE
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
:
parentGuid
)
ORDER
BY
position
{
parentGuid
}
)
;
return
rows
.
map
(
row
=
>
(
{
id
:
row
.
getResultByName
(
"
id
"
)
parentId
:
row
.
getResultByName
(
"
parent
"
)
index
:
row
.
getResultByName
(
"
position
"
)
type
:
row
.
getResultByName
(
"
type
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
}
)
)
;
}
)
;
var
GUIDMissing
=
Task
.
async
(
function
*
(
guid
)
{
try
{
yield
PlacesUtils
.
promiseItemId
(
guid
)
;
return
false
;
}
catch
(
ex
)
{
if
(
ex
.
message
=
=
"
no
item
found
for
the
given
GUID
"
)
{
return
true
;
}
throw
ex
;
}
}
)
;
var
updateTagQueryFolder
=
Task
.
async
(
function
*
(
info
)
{
if
(
info
.
kind
!
=
BookmarkSyncUtils
.
KINDS
.
QUERY
|
|
!
info
.
folder
|
|
!
info
.
url
|
|
info
.
url
.
protocol
!
=
"
place
:
"
)
{
return
info
;
}
let
params
=
new
URLSearchParams
(
info
.
url
.
pathname
)
;
let
type
=
+
params
.
get
(
"
type
"
)
;
if
(
type
!
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAG_CONTENTS
)
{
return
info
;
}
let
id
=
yield
getOrCreateTagFolder
(
info
.
folder
)
;
BookmarkSyncLog
.
debug
(
updateTagQueryFolder
:
Tag
query
folder
:
{
info
.
folder
}
=
{
id
}
)
;
params
.
set
(
"
folder
"
id
)
;
info
.
url
=
new
URL
(
info
.
url
.
protocol
+
params
)
;
return
info
;
}
)
;
var
annotateOrphan
=
Task
.
async
(
function
*
(
item
requestedParentSyncId
)
{
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
item
.
syncId
)
;
let
itemId
=
yield
PlacesUtils
.
promiseItemId
(
guid
)
;
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
SYNC_PARENT_ANNO
requestedParentSyncId
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
}
)
;
var
reparentOrphans
=
Task
.
async
(
function
*
(
item
)
{
if
(
item
.
kind
!
=
BookmarkSyncUtils
.
KINDS
.
FOLDER
)
{
return
;
}
let
orphanGuids
=
yield
fetchGuidsWithAnno
(
BookmarkSyncUtils
.
SYNC_PARENT_ANNO
item
.
syncId
)
;
let
folderGuid
=
BookmarkSyncUtils
.
syncIdToGuid
(
item
.
syncId
)
;
BookmarkSyncLog
.
debug
(
reparentOrphans
:
Reparenting
{
JSON
.
stringify
(
orphanGuids
)
}
to
{
item
.
syncId
}
)
;
for
(
let
i
=
0
;
i
<
orphanGuids
.
length
;
+
+
i
)
{
let
isReparented
=
false
;
try
{
BookmarkSyncLog
.
trace
(
reparentOrphans
:
Attempting
to
move
item
{
orphanGuids
[
i
]
}
to
new
parent
{
item
.
syncId
}
)
;
yield
PlacesUtils
.
bookmarks
.
update
(
{
guid
:
orphanGuids
[
i
]
parentGuid
:
folderGuid
index
:
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
source
:
SOURCE_SYNC
}
)
;
isReparented
=
true
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
error
(
reparentOrphans
:
Failed
to
reparent
item
{
orphanGuids
[
i
]
}
to
{
item
.
syncId
}
ex
)
;
}
if
(
isReparented
)
{
let
orphanId
=
yield
PlacesUtils
.
promiseItemId
(
orphanGuids
[
i
]
)
;
PlacesUtils
.
annotations
.
removeItemAnnotation
(
orphanId
BookmarkSyncUtils
.
SYNC_PARENT_ANNO
SOURCE_SYNC
)
;
}
}
}
)
;
var
insertSyncBookmark
=
Task
.
async
(
function
*
(
insertInfo
)
{
let
requestedParentSyncId
=
insertInfo
.
parentSyncId
;
let
requestedParentGuid
=
BookmarkSyncUtils
.
syncIdToGuid
(
insertInfo
.
parentSyncId
)
;
let
isOrphan
=
yield
GUIDMissing
(
requestedParentGuid
)
;
if
(
!
isOrphan
)
{
BookmarkSyncLog
.
debug
(
insertSyncBookmark
:
Item
{
insertInfo
.
syncId
}
is
not
an
orphan
)
;
}
else
{
BookmarkSyncLog
.
debug
(
insertSyncBookmark
:
Item
{
insertInfo
.
syncId
}
is
an
orphan
:
parent
{
insertInfo
.
parentSyncId
}
doesn
'
t
exist
;
reparenting
to
unfiled
)
;
insertInfo
.
parentSyncId
=
"
unfiled
"
;
}
insertInfo
=
yield
updateTagQueryFolder
(
insertInfo
)
;
let
newItem
;
if
(
insertInfo
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
)
{
newItem
=
yield
insertSyncLivemark
(
insertInfo
)
;
}
else
{
let
bookmarkInfo
=
syncBookmarkToPlacesBookmark
(
insertInfo
)
;
let
bookmarkItem
=
yield
PlacesUtils
.
bookmarks
.
insert
(
bookmarkInfo
)
;
newItem
=
yield
insertBookmarkMetadata
(
bookmarkItem
insertInfo
)
;
}
if
(
!
newItem
)
{
return
null
;
}
if
(
isOrphan
)
{
yield
annotateOrphan
(
newItem
requestedParentSyncId
)
;
}
yield
reparentOrphans
(
newItem
)
;
return
newItem
;
}
)
;
var
insertSyncLivemark
=
Task
.
async
(
function
*
(
insertInfo
)
{
if
(
!
insertInfo
.
feed
)
{
BookmarkSyncLog
.
debug
(
insertSyncLivemark
:
{
insertInfo
.
syncId
}
missing
feed
URL
)
;
return
null
;
}
let
livemarkInfo
=
syncBookmarkToPlacesBookmark
(
insertInfo
)
;
let
parentIsLivemark
=
yield
getAnno
(
livemarkInfo
.
parentGuid
PlacesUtils
.
LMANNO_FEEDURI
)
;
if
(
parentIsLivemark
)
{
BookmarkSyncLog
.
debug
(
insertSyncLivemark
:
Invalid
parent
{
insertInfo
.
parentSyncId
}
;
skipping
livemark
record
{
insertInfo
.
syncId
}
)
;
return
null
;
}
let
livemarkItem
=
yield
PlacesUtils
.
livemarks
.
addLivemark
(
livemarkInfo
)
;
return
insertBookmarkMetadata
(
livemarkItem
insertInfo
)
;
}
)
;
var
insertBookmarkMetadata
=
Task
.
async
(
function
*
(
bookmarkItem
insertInfo
)
{
let
itemId
=
yield
PlacesUtils
.
promiseItemId
(
bookmarkItem
.
guid
)
;
let
newItem
=
yield
placesBookmarkToSyncBookmark
(
bookmarkItem
)
;
if
(
insertInfo
.
query
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
SMART_BOOKMARKS_ANNO
insertInfo
.
query
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
newItem
.
query
=
insertInfo
.
query
;
}
try
{
newItem
.
tags
=
yield
tagItem
(
bookmarkItem
insertInfo
.
tags
)
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
warn
(
insertBookmarkMetadata
:
Error
tagging
item
{
insertInfo
.
syncId
}
ex
)
;
}
if
(
insertInfo
.
keyword
)
{
yield
PlacesUtils
.
keywords
.
insert
(
{
keyword
:
insertInfo
.
keyword
url
:
bookmarkItem
.
url
.
href
source
:
SOURCE_SYNC
}
)
;
newItem
.
keyword
=
insertInfo
.
keyword
;
}
if
(
insertInfo
.
description
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
DESCRIPTION_ANNO
insertInfo
.
description
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
newItem
.
description
=
insertInfo
.
description
;
}
if
(
insertInfo
.
loadInSidebar
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
SIDEBAR_ANNO
insertInfo
.
loadInSidebar
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
newItem
.
loadInSidebar
=
insertInfo
.
loadInSidebar
;
}
return
newItem
;
}
)
;
var
getKindForItem
=
Task
.
async
(
function
*
(
item
)
{
switch
(
item
.
type
)
{
case
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
:
{
let
isLivemark
=
yield
getAnno
(
item
.
guid
PlacesUtils
.
LMANNO_FEEDURI
)
;
return
isLivemark
?
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
:
BookmarkSyncUtils
.
KINDS
.
FOLDER
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
:
return
item
.
url
.
protocol
=
=
"
place
:
"
?
BookmarkSyncUtils
.
KINDS
.
QUERY
:
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
;
case
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
:
return
BookmarkSyncUtils
.
KINDS
.
SEPARATOR
;
}
return
null
;
}
)
;
function
getTypeForKind
(
kind
)
{
switch
(
kind
)
{
case
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
:
case
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
:
case
BookmarkSyncUtils
.
KINDS
.
QUERY
:
return
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
;
case
BookmarkSyncUtils
.
KINDS
.
FOLDER
:
case
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
:
return
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
;
case
BookmarkSyncUtils
.
KINDS
.
SEPARATOR
:
return
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
;
}
throw
new
Error
(
Unknown
bookmark
kind
:
{
kind
}
)
;
}
var
shouldReinsertLivemark
=
Task
.
async
(
function
*
(
updateInfo
)
{
let
hasFeed
=
updateInfo
.
hasOwnProperty
(
"
feed
"
)
;
let
hasSite
=
updateInfo
.
hasOwnProperty
(
"
site
"
)
;
if
(
!
hasFeed
&
&
!
hasSite
)
{
return
false
;
}
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
updateInfo
.
syncId
)
;
let
livemark
=
yield
PlacesUtils
.
livemarks
.
getLivemark
(
{
guid
}
)
;
if
(
hasFeed
)
{
let
feedURI
=
PlacesUtils
.
toURI
(
updateInfo
.
feed
)
;
if
(
!
livemark
.
feedURI
.
equals
(
feedURI
)
)
{
return
true
;
}
}
if
(
hasSite
)
{
if
(
!
updateInfo
.
site
)
{
return
!
!
livemark
.
siteURI
;
}
let
siteURI
=
PlacesUtils
.
toURI
(
updateInfo
.
site
)
;
if
(
!
livemark
.
siteURI
|
|
!
siteURI
.
equals
(
livemark
.
siteURI
)
)
{
return
true
;
}
}
return
false
;
}
)
;
var
updateSyncBookmark
=
Task
.
async
(
function
*
(
updateInfo
)
{
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
updateInfo
.
syncId
)
;
let
oldBookmarkItem
=
yield
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
;
if
(
!
oldBookmarkItem
)
{
throw
new
Error
(
Bookmark
with
sync
ID
{
updateInfo
.
syncId
}
does
not
exist
)
;
}
let
shouldReinsert
=
false
;
let
oldKind
=
yield
getKindForItem
(
oldBookmarkItem
)
;
if
(
updateInfo
.
hasOwnProperty
(
"
kind
"
)
&
&
updateInfo
.
kind
!
=
oldKind
)
{
shouldReinsert
=
true
;
if
(
BookmarkSyncLog
.
level
<
=
Log
.
Level
.
Warn
)
{
let
oldSyncId
=
BookmarkSyncUtils
.
guidToSyncId
(
oldBookmarkItem
.
guid
)
;
BookmarkSyncLog
.
warn
(
updateSyncBookmark
:
Local
{
oldSyncId
}
kind
=
{
oldKind
}
;
remote
{
updateInfo
.
syncId
}
kind
=
{
updateInfo
.
kind
}
.
Deleting
and
recreating
)
;
}
}
else
if
(
oldKind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
)
{
shouldReinsert
=
yield
shouldReinsertLivemark
(
updateInfo
)
;
if
(
BookmarkSyncLog
.
level
<
=
Log
.
Level
.
Debug
)
{
let
oldSyncId
=
BookmarkSyncUtils
.
guidToSyncId
(
oldBookmarkItem
.
guid
)
;
BookmarkSyncLog
.
debug
(
updateSyncBookmark
:
Local
{
oldSyncId
}
and
remote
{
updateInfo
.
syncId
}
livemarks
have
different
URLs
)
;
}
}
if
(
shouldReinsert
)
{
let
newInfo
=
validateNewBookmark
(
updateInfo
)
;
yield
PlacesUtils
.
bookmarks
.
remove
(
{
guid
source
:
SOURCE_SYNC
}
)
;
return
insertSyncBookmark
(
newInfo
)
;
}
let
isOrphan
=
false
requestedParentSyncId
;
if
(
updateInfo
.
hasOwnProperty
(
"
parentSyncId
"
)
)
{
requestedParentSyncId
=
updateInfo
.
parentSyncId
;
let
oldParentSyncId
=
BookmarkSyncUtils
.
guidToSyncId
(
oldBookmarkItem
.
parentGuid
)
;
if
(
requestedParentSyncId
!
=
oldParentSyncId
)
{
let
oldId
=
yield
PlacesUtils
.
promiseItemId
(
oldBookmarkItem
.
guid
)
;
if
(
PlacesUtils
.
isRootItem
(
oldId
)
)
{
throw
new
Error
(
Cannot
move
Places
root
{
oldId
}
)
;
}
let
requestedParentGuid
=
BookmarkSyncUtils
.
syncIdToGuid
(
requestedParentSyncId
)
;
isOrphan
=
yield
GUIDMissing
(
requestedParentGuid
)
;
if
(
!
isOrphan
)
{
BookmarkSyncLog
.
debug
(
updateSyncBookmark
:
Item
{
updateInfo
.
syncId
}
is
not
an
orphan
)
;
}
else
{
BookmarkSyncLog
.
trace
(
updateSyncBookmark
:
Item
{
updateInfo
.
syncId
}
is
an
orphan
:
could
not
find
parent
{
requestedParentSyncId
}
)
;
delete
updateInfo
.
parentSyncId
;
}
}
else
{
delete
updateInfo
.
parentSyncId
;
}
}
updateInfo
=
yield
updateTagQueryFolder
(
updateInfo
)
;
let
bookmarkInfo
=
syncBookmarkToPlacesBookmark
(
updateInfo
)
;
let
newBookmarkItem
=
shouldUpdateBookmark
(
bookmarkInfo
)
?
yield
PlacesUtils
.
bookmarks
.
update
(
bookmarkInfo
)
:
oldBookmarkItem
;
let
newItem
=
yield
updateBookmarkMetadata
(
oldBookmarkItem
newBookmarkItem
updateInfo
)
;
if
(
isOrphan
)
{
yield
annotateOrphan
(
newItem
requestedParentSyncId
)
;
}
yield
reparentOrphans
(
newItem
)
;
return
newItem
;
}
)
;
var
updateBookmarkMetadata
=
Task
.
async
(
function
*
(
oldBookmarkItem
newBookmarkItem
updateInfo
)
{
let
itemId
=
yield
PlacesUtils
.
promiseItemId
(
newBookmarkItem
.
guid
)
;
let
newItem
=
yield
placesBookmarkToSyncBookmark
(
newBookmarkItem
)
;
try
{
newItem
.
tags
=
yield
tagItem
(
newBookmarkItem
updateInfo
.
tags
)
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
warn
(
updateBookmarkMetadata
:
Error
tagging
item
{
updateInfo
.
syncId
}
ex
)
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
keyword
"
)
)
{
let
entry
=
yield
PlacesUtils
.
keywords
.
fetch
(
{
url
:
oldBookmarkItem
.
url
.
href
}
)
;
if
(
entry
)
{
yield
PlacesUtils
.
keywords
.
remove
(
{
keyword
:
entry
.
keyword
source
:
SOURCE_SYNC
}
)
;
}
if
(
updateInfo
.
keyword
)
{
yield
PlacesUtils
.
keywords
.
insert
(
{
keyword
:
updateInfo
.
keyword
url
:
newItem
.
url
.
href
source
:
SOURCE_SYNC
}
)
;
}
newItem
.
keyword
=
updateInfo
.
keyword
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
description
"
)
)
{
if
(
updateInfo
.
description
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
DESCRIPTION_ANNO
updateInfo
.
description
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
}
else
{
PlacesUtils
.
annotations
.
removeItemAnnotation
(
itemId
BookmarkSyncUtils
.
DESCRIPTION_ANNO
SOURCE_SYNC
)
;
}
newItem
.
description
=
updateInfo
.
description
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
loadInSidebar
"
)
)
{
if
(
updateInfo
.
loadInSidebar
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
SIDEBAR_ANNO
updateInfo
.
loadInSidebar
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
}
else
{
PlacesUtils
.
annotations
.
removeItemAnnotation
(
itemId
BookmarkSyncUtils
.
SIDEBAR_ANNO
SOURCE_SYNC
)
;
}
newItem
.
loadInSidebar
=
updateInfo
.
loadInSidebar
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
query
"
)
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
SMART_BOOKMARKS_ANNO
updateInfo
.
query
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
newItem
.
query
=
updateInfo
.
query
;
}
return
newItem
;
}
)
;
function
validateNewBookmark
(
info
)
{
let
insertInfo
=
validateSyncBookmarkObject
(
info
{
kind
:
{
required
:
true
}
syncId
:
{
required
:
true
}
url
:
{
requiredIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
parentSyncId
:
{
required
:
true
}
title
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
BookmarkSyncUtils
.
KINDS
.
QUERY
BookmarkSyncUtils
.
KINDS
.
FOLDER
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
]
.
includes
(
b
.
kind
)
}
query
:
{
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
QUERY
}
folder
:
{
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
QUERY
}
tags
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
keyword
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
description
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
BookmarkSyncUtils
.
KINDS
.
QUERY
BookmarkSyncUtils
.
KINDS
.
FOLDER
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
]
.
includes
(
b
.
kind
)
}
loadInSidebar
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
feed
:
{
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
}
site
:
{
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
}
}
)
;
return
insertInfo
;
}
var
fetchGuidsWithAnno
=
Task
.
async
(
function
*
(
anno
val
)
{
let
db
=
yield
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
yield
db
.
executeCached
(
SELECT
b
.
guid
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
JOIN
moz_bookmarks
b
ON
b
.
id
=
a
.
item_id
WHERE
n
.
name
=
:
anno
AND
a
.
content
=
:
val
{
anno
val
}
)
;
return
rows
.
map
(
row
=
>
row
.
getResultByName
(
"
guid
"
)
)
;
}
)
;
var
getAnno
=
Task
.
async
(
function
*
(
guid
anno
)
{
let
db
=
yield
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
yield
db
.
executeCached
(
SELECT
a
.
content
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
JOIN
moz_bookmarks
b
ON
b
.
id
=
a
.
item_id
WHERE
b
.
guid
=
:
guid
AND
n
.
name
=
:
anno
{
guid
anno
}
)
;
return
rows
.
length
?
rows
[
0
]
.
getResultByName
(
"
content
"
)
:
null
;
}
)
;
var
tagItem
=
Task
.
async
(
function
(
item
tags
)
{
if
(
!
item
.
url
)
{
return
[
]
;
}
let
newTags
=
tags
.
map
(
tag
=
>
tag
.
trim
(
)
)
.
filter
(
Boolean
)
;
let
dummyURI
=
PlacesUtils
.
toURI
(
"
about
:
weave
#
BStore_tagURI
"
)
;
let
bookmarkURI
=
PlacesUtils
.
toURI
(
item
.
url
.
href
)
;
PlacesUtils
.
tagging
.
tagURI
(
dummyURI
newTags
SOURCE_SYNC
)
;
PlacesUtils
.
tagging
.
untagURI
(
bookmarkURI
null
SOURCE_SYNC
)
;
PlacesUtils
.
tagging
.
tagURI
(
bookmarkURI
newTags
SOURCE_SYNC
)
;
PlacesUtils
.
tagging
.
untagURI
(
dummyURI
null
SOURCE_SYNC
)
;
return
newTags
;
}
)
;
function
shouldUpdateBookmark
(
bookmarkInfo
)
{
return
bookmarkInfo
.
hasOwnProperty
(
"
parentGuid
"
)
|
|
bookmarkInfo
.
hasOwnProperty
(
"
title
"
)
|
|
bookmarkInfo
.
hasOwnProperty
(
"
url
"
)
;
}
var
getTagFolder
=
Task
.
async
(
function
*
(
tag
)
{
let
db
=
yield
PlacesUtils
.
promiseDBConnection
(
)
;
let
results
=
yield
db
.
executeCached
(
SELECT
id
FROM
moz_bookmarks
WHERE
parent
=
:
tagsFolder
AND
title
=
:
tag
LIMIT
1
{
tagsFolder
:
PlacesUtils
.
bookmarks
.
tagsFolder
tag
}
)
;
return
results
.
length
?
results
[
0
]
.
getResultByName
(
"
id
"
)
:
null
;
}
)
;
var
getOrCreateTagFolder
=
Task
.
async
(
function
*
(
tag
)
{
let
id
=
yield
getTagFolder
(
tag
)
;
if
(
id
)
{
return
id
;
}
let
item
=
yield
PlacesUtils
.
bookmarks
.
insert
(
{
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
parentGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
title
:
tag
source
:
SOURCE_SYNC
}
)
;
return
PlacesUtils
.
promiseItemId
(
item
.
guid
)
;
}
)
;
var
placesBookmarkToSyncBookmark
=
Task
.
async
(
function
*
(
bookmarkItem
)
{
let
item
=
{
}
;
for
(
let
prop
in
bookmarkItem
)
{
switch
(
prop
)
{
case
"
guid
"
:
item
.
syncId
=
BookmarkSyncUtils
.
guidToSyncId
(
bookmarkItem
.
guid
)
;
break
;
case
"
parentGuid
"
:
item
.
parentSyncId
=
BookmarkSyncUtils
.
guidToSyncId
(
bookmarkItem
.
parentGuid
)
;
break
;
case
"
type
"
:
item
.
kind
=
yield
getKindForItem
(
bookmarkItem
)
;
break
;
case
"
title
"
:
case
"
url
"
:
item
[
prop
]
=
bookmarkItem
[
prop
]
;
break
;
case
"
feedURI
"
:
item
.
feed
=
new
URL
(
bookmarkItem
.
feedURI
.
spec
)
;
break
;
case
"
siteURI
"
:
if
(
bookmarkItem
.
siteURI
)
{
item
.
site
=
new
URL
(
bookmarkItem
.
siteURI
.
spec
)
;
}
break
;
}
}
return
item
;
}
)
;
function
syncBookmarkToPlacesBookmark
(
info
)
{
let
bookmarkInfo
=
{
source
:
SOURCE_SYNC
}
;
for
(
let
prop
in
info
)
{
switch
(
prop
)
{
case
"
kind
"
:
bookmarkInfo
.
type
=
getTypeForKind
(
info
.
kind
)
;
break
;
case
"
syncId
"
:
bookmarkInfo
.
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
info
.
syncId
)
;
break
;
case
"
parentSyncId
"
:
bookmarkInfo
.
parentGuid
=
BookmarkSyncUtils
.
syncIdToGuid
(
info
.
parentSyncId
)
;
bookmarkInfo
.
index
=
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
;
break
;
case
"
title
"
:
case
"
url
"
:
bookmarkInfo
[
prop
]
=
info
[
prop
]
;
break
;
case
"
feed
"
:
bookmarkInfo
.
feedURI
=
PlacesUtils
.
toURI
(
info
.
feed
)
;
break
;
case
"
site
"
:
if
(
info
.
site
)
{
bookmarkInfo
.
siteURI
=
PlacesUtils
.
toURI
(
info
.
site
)
;
}
break
;
}
}
return
bookmarkInfo
;
}
var
fetchBookmarkItem
=
Task
.
async
(
function
*
(
bookmarkItem
)
{
let
item
=
yield
placesBookmarkToSyncBookmark
(
bookmarkItem
)
;
item
.
tags
=
PlacesUtils
.
tagging
.
getTagsForURI
(
PlacesUtils
.
toURI
(
bookmarkItem
.
url
)
{
}
)
;
let
keywordEntry
=
yield
PlacesUtils
.
keywords
.
fetch
(
{
url
:
bookmarkItem
.
url
}
)
;
if
(
keywordEntry
)
{
item
.
keyword
=
keywordEntry
.
keyword
;
}
let
description
=
yield
getAnno
(
bookmarkItem
.
guid
BookmarkSyncUtils
.
DESCRIPTION_ANNO
)
;
if
(
description
)
{
item
.
description
=
description
;
}
item
.
loadInSidebar
=
!
!
(
yield
getAnno
(
bookmarkItem
.
guid
BookmarkSyncUtils
.
SIDEBAR_ANNO
)
)
;
return
item
;
}
)
;
var
fetchFolderItem
=
Task
.
async
(
function
*
(
bookmarkItem
)
{
let
item
=
yield
placesBookmarkToSyncBookmark
(
bookmarkItem
)
;
let
description
=
yield
getAnno
(
bookmarkItem
.
guid
BookmarkSyncUtils
.
DESCRIPTION_ANNO
)
;
if
(
description
)
{
item
.
description
=
description
;
}
let
db
=
yield
PlacesUtils
.
promiseDBConnection
(
)
;
let
children
=
yield
fetchAllChildren
(
db
bookmarkItem
.
guid
)
;
item
.
childSyncIds
=
children
.
map
(
child
=
>
BookmarkSyncUtils
.
guidToSyncId
(
child
.
guid
)
)
;
return
item
;
}
)
;
var
fetchLivemarkItem
=
Task
.
async
(
function
*
(
bookmarkItem
)
{
let
item
=
yield
placesBookmarkToSyncBookmark
(
bookmarkItem
)
;
let
description
=
yield
getAnno
(
bookmarkItem
.
guid
BookmarkSyncUtils
.
DESCRIPTION_ANNO
)
;
if
(
description
)
{
item
.
description
=
description
;
}
let
feedAnno
=
yield
getAnno
(
bookmarkItem
.
guid
PlacesUtils
.
LMANNO_FEEDURI
)
;
item
.
feed
=
new
URL
(
feedAnno
)
;
let
siteAnno
=
yield
getAnno
(
bookmarkItem
.
guid
PlacesUtils
.
LMANNO_SITEURI
)
;
if
(
siteAnno
)
{
item
.
site
=
new
URL
(
siteAnno
)
;
}
return
item
;
}
)
;
var
fetchQueryItem
=
Task
.
async
(
function
*
(
bookmarkItem
)
{
let
item
=
yield
placesBookmarkToSyncBookmark
(
bookmarkItem
)
;
let
description
=
yield
getAnno
(
bookmarkItem
.
guid
BookmarkSyncUtils
.
DESCRIPTION_ANNO
)
;
if
(
description
)
{
item
.
description
=
description
;
}
let
folder
=
null
;
let
params
=
new
URLSearchParams
(
bookmarkItem
.
url
.
pathname
)
;
let
tagFolderId
=
+
params
.
get
(
"
folder
"
)
;
if
(
tagFolderId
)
{
try
{
let
tagFolderGuid
=
yield
PlacesUtils
.
promiseItemGuid
(
tagFolderId
)
;
let
tagFolder
=
yield
PlacesUtils
.
bookmarks
.
fetch
(
tagFolderGuid
)
;
folder
=
tagFolder
.
title
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
warn
(
"
fetchQueryItem
:
Query
"
+
bookmarkItem
.
url
.
href
+
"
points
to
nonexistent
folder
"
+
tagFolderId
ex
)
;
}
}
if
(
folder
!
=
null
)
{
item
.
folder
=
folder
;
}
let
query
=
yield
getAnno
(
bookmarkItem
.
guid
BookmarkSyncUtils
.
SMART_BOOKMARKS_ANNO
)
;
if
(
query
)
{
item
.
query
=
query
;
}
return
item
;
}
)
;
