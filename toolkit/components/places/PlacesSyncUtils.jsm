"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PlacesSyncUtils
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
Cu
.
importGlobalProperties
(
[
"
URL
"
"
URLSearchParams
"
]
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
var
PlacesSyncUtils
=
{
}
;
const
{
SOURCE_SYNC
}
=
Ci
.
nsINavBookmarksService
;
const
MICROSECONDS_PER_SECOND
=
1000000
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ROOT_SYNC_ID_TO_GUID
"
(
)
=
>
(
{
menu
:
PlacesUtils
.
bookmarks
.
menuGuid
places
:
PlacesUtils
.
bookmarks
.
rootGuid
tags
:
PlacesUtils
.
bookmarks
.
tagsGuid
toolbar
:
PlacesUtils
.
bookmarks
.
toolbarGuid
unfiled
:
PlacesUtils
.
bookmarks
.
unfiledGuid
mobile
:
PlacesUtils
.
bookmarks
.
mobileGuid
}
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ROOT_GUID_TO_SYNC_ID
"
(
)
=
>
(
{
[
PlacesUtils
.
bookmarks
.
menuGuid
]
:
"
menu
"
[
PlacesUtils
.
bookmarks
.
rootGuid
]
:
"
places
"
[
PlacesUtils
.
bookmarks
.
tagsGuid
]
:
"
tags
"
[
PlacesUtils
.
bookmarks
.
toolbarGuid
]
:
"
toolbar
"
[
PlacesUtils
.
bookmarks
.
unfiledGuid
]
:
"
unfiled
"
[
PlacesUtils
.
bookmarks
.
mobileGuid
]
:
"
mobile
"
}
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ROOTS
"
(
)
=
>
Object
.
keys
(
ROOT_SYNC_ID_TO_GUID
)
)
;
const
HistorySyncUtils
=
PlacesSyncUtils
.
history
=
Object
.
freeze
(
{
async
fetchURLFrecency
(
url
)
{
let
canonicalURL
=
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
url
(
url
)
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
frecency
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
LIMIT
1
{
url
:
canonicalURL
.
href
}
)
;
return
rows
.
length
?
rows
[
0
]
.
getResultByName
(
"
frecency
"
)
:
-
1
;
}
}
)
;
const
BookmarkSyncUtils
=
PlacesSyncUtils
.
bookmarks
=
Object
.
freeze
(
{
SMART_BOOKMARKS_ANNO
:
"
Places
/
SmartBookmark
"
DESCRIPTION_ANNO
:
"
bookmarkProperties
/
description
"
SIDEBAR_ANNO
:
"
bookmarkProperties
/
loadInSidebar
"
SYNC_PARENT_ANNO
:
"
sync
/
parent
"
SYNC_MOBILE_ROOT_ANNO
:
"
mobile
/
bookmarksRoot
"
EARLIEST_BOOKMARK_TIMESTAMP
:
Date
.
UTC
(
1993
0
23
)
KINDS
:
{
BOOKMARK
:
"
bookmark
"
QUERY
:
"
query
"
FOLDER
:
"
folder
"
LIVEMARK
:
"
livemark
"
SEPARATOR
:
"
separator
"
}
get
ROOTS
(
)
{
return
ROOTS
;
}
guidToSyncId
(
guid
)
{
return
ROOT_GUID_TO_SYNC_ID
[
guid
]
|
|
guid
;
}
syncIdToGuid
(
syncId
)
{
return
ROOT_SYNC_ID_TO_GUID
[
syncId
]
|
|
syncId
;
}
async
getChangedIds
(
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
result
=
await
db
.
executeCached
(
SELECT
guid
FROM
moz_bookmarks
WHERE
syncChangeCounter
>
=
1
)
;
return
result
.
map
(
row
=
>
BookmarkSyncUtils
.
guidToSyncId
(
row
.
getResultByName
(
"
guid
"
)
)
)
;
}
async
fetchChildSyncIds
(
parentSyncId
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
syncId
(
parentSyncId
)
;
let
parentGuid
=
BookmarkSyncUtils
.
syncIdToGuid
(
parentSyncId
)
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
childGuids
=
await
fetchChildGuids
(
db
parentGuid
)
;
return
childGuids
.
map
(
guid
=
>
BookmarkSyncUtils
.
guidToSyncId
(
guid
)
)
;
}
async
fetchSyncIdsForRepair
(
requestedSyncIds
)
{
let
requestedGuids
=
requestedSyncIds
.
map
(
BookmarkSyncUtils
.
syncIdToGuid
)
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
WITH
RECURSIVE
syncedItems
(
id
)
AS
(
SELECT
b
.
id
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
'
menu________
'
'
toolbar_____
'
'
unfiled_____
'
'
mobile______
'
)
UNION
ALL
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
syncedItems
s
ON
b
.
parent
=
s
.
id
)
descendants
(
id
)
AS
(
SELECT
b
.
id
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
{
requestedGuids
.
map
(
guid
=
>
JSON
.
stringify
(
guid
)
)
.
join
(
"
"
)
}
)
UNION
ALL
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
descendants
d
ON
d
.
id
=
b
.
parent
)
SELECT
b
.
guid
s
.
id
NOT
NULL
AS
syncable
FROM
descendants
d
JOIN
moz_bookmarks
b
ON
b
.
id
=
d
.
id
LEFT
JOIN
syncedItems
s
ON
s
.
id
=
d
.
id
)
;
return
rows
.
map
(
row
=
>
{
let
syncId
=
BookmarkSyncUtils
.
guidToSyncId
(
row
.
getResultByName
(
"
guid
"
)
)
;
let
syncable
=
!
!
row
.
getResultByName
(
"
syncable
"
)
;
return
{
syncId
syncable
}
;
}
)
;
}
migrateOldTrackerEntries
(
entries
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
migrateOldTrackerEntries
"
function
(
db
)
{
return
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
executeCached
(
WITH
RECURSIVE
syncedItems
(
id
)
AS
(
SELECT
b
.
id
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
'
menu________
'
'
toolbar_____
'
'
unfiled_____
'
'
mobile______
'
)
UNION
ALL
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
syncedItems
s
ON
b
.
parent
=
s
.
id
)
UPDATE
moz_bookmarks
SET
syncStatus
=
:
syncStatus
syncChangeCounter
=
0
WHERE
id
IN
syncedItems
{
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_bookmarks_deleted
)
;
await
db
.
executeCached
(
CREATE
TEMP
TABLE
moz_bookmarks_tracked
(
guid
TEXT
PRIMARY
KEY
time
INTEGER
)
)
;
try
{
for
(
let
{
syncId
modified
}
of
entries
)
{
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
syncId
)
;
if
(
!
PlacesUtils
.
isValidGuid
(
guid
)
)
{
BookmarkSyncLog
.
warn
(
migrateOldTrackerEntries
:
Ignoring
+
change
for
invalid
item
{
guid
}
)
;
continue
;
}
let
time
=
PlacesUtils
.
toPRTime
(
Number
.
isFinite
(
modified
)
?
modified
:
Date
.
now
(
)
)
;
await
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
moz_bookmarks_tracked
(
guid
time
)
VALUES
(
:
guid
:
time
)
{
guid
time
}
)
;
}
await
db
.
executeCached
(
INSERT
OR
REPLACE
INTO
moz_bookmarks
(
id
fk
type
parent
position
title
dateAdded
lastModified
guid
syncChangeCounter
syncStatus
)
SELECT
b
.
id
b
.
fk
b
.
type
b
.
parent
b
.
position
b
.
title
b
.
dateAdded
MAX
(
b
.
lastModified
t
.
time
)
b
.
guid
b
.
syncChangeCounter
+
1
b
.
syncStatus
FROM
moz_bookmarks
b
JOIN
moz_bookmarks_tracked
t
ON
b
.
guid
=
t
.
guid
)
;
await
db
.
executeCached
(
INSERT
OR
REPLACE
INTO
moz_bookmarks_deleted
(
guid
dateRemoved
)
SELECT
t
.
guid
MAX
(
IFNULL
(
(
SELECT
dateRemoved
FROM
moz_bookmarks_deleted
WHERE
guid
=
t
.
guid
)
0
)
t
.
time
)
FROM
moz_bookmarks_tracked
t
LEFT
JOIN
moz_bookmarks
b
ON
t
.
guid
=
b
.
guid
WHERE
b
.
guid
IS
NULL
)
;
}
finally
{
await
db
.
executeCached
(
DROP
TABLE
moz_bookmarks_tracked
)
;
}
}
)
;
}
)
;
}
async
order
(
parentSyncId
childSyncIds
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
syncId
(
parentSyncId
)
;
if
(
!
childSyncIds
.
length
)
{
return
undefined
;
}
let
parentGuid
=
BookmarkSyncUtils
.
syncIdToGuid
(
parentSyncId
)
;
if
(
parentGuid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
)
{
return
undefined
;
}
let
orderedChildrenGuids
=
childSyncIds
.
map
(
BookmarkSyncUtils
.
syncIdToGuid
)
;
return
PlacesUtils
.
bookmarks
.
reorder
(
parentGuid
orderedChildrenGuids
{
source
:
SOURCE_SYNC
}
)
;
}
async
havePendingChanges
(
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
WITH
RECURSIVE
syncedItems
(
id
guid
syncChangeCounter
)
AS
(
SELECT
b
.
id
b
.
guid
b
.
syncChangeCounter
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
'
menu________
'
'
toolbar_____
'
'
unfiled_____
'
'
mobile______
'
)
UNION
ALL
SELECT
b
.
id
b
.
guid
b
.
syncChangeCounter
FROM
moz_bookmarks
b
JOIN
syncedItems
s
ON
b
.
parent
=
s
.
id
)
changedItems
(
guid
)
AS
(
SELECT
guid
FROM
syncedItems
WHERE
syncChangeCounter
>
=
1
UNION
ALL
SELECT
guid
FROM
moz_bookmarks_deleted
)
SELECT
EXISTS
(
SELECT
guid
FROM
changedItems
)
AS
haveChanges
)
;
return
!
!
rows
[
0
]
.
getResultByName
(
"
haveChanges
"
)
;
}
pullChanges
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
pullChanges
"
db
=
>
pullSyncChanges
(
db
)
)
;
}
pushChanges
(
changeRecords
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
.
pushChanges
"
async
function
(
db
)
{
let
skippedCount
=
0
;
let
syncedTombstoneGuids
=
[
]
;
let
syncedChanges
=
[
]
;
for
(
let
syncId
in
changeRecords
)
{
let
changeRecord
=
validateChangeRecord
(
changeRecords
[
syncId
]
{
tombstone
:
{
required
:
true
}
counter
:
{
required
:
true
}
synced
:
{
required
:
true
}
}
)
;
if
(
!
changeRecord
.
synced
)
{
skippedCount
+
+
;
continue
;
}
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
syncId
)
;
if
(
changeRecord
.
tombstone
)
{
syncedTombstoneGuids
.
push
(
guid
)
;
}
else
{
syncedChanges
.
push
(
[
guid
changeRecord
]
)
;
}
}
if
(
syncedChanges
.
length
|
|
syncedTombstoneGuids
.
length
)
{
await
db
.
executeTransaction
(
async
function
(
)
{
for
(
let
[
guid
changeRecord
]
of
syncedChanges
)
{
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
MAX
(
syncChangeCounter
-
:
syncChangeDelta
0
)
syncStatus
=
:
syncStatus
WHERE
guid
=
:
guid
{
guid
syncChangeDelta
:
changeRecord
.
counter
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
)
;
}
await
removeTombstones
(
db
syncedTombstoneGuids
)
;
}
)
;
}
BookmarkSyncLog
.
debug
(
pushChanges
:
Processed
change
records
{
skipped
:
skippedCount
updated
:
syncedChanges
.
length
tombstones
:
syncedTombstoneGuids
.
length
}
)
;
}
)
;
}
async
remove
(
syncIds
)
{
if
(
!
syncIds
.
length
)
{
return
null
;
}
let
folderGuids
=
[
]
;
for
(
let
syncId
of
syncIds
)
{
if
(
syncId
in
ROOT_SYNC_ID_TO_GUID
)
{
BookmarkSyncLog
.
warn
(
remove
:
Refusing
to
remove
root
{
syncId
}
)
;
continue
;
}
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
syncId
)
;
let
bookmarkItem
=
await
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
;
if
(
!
bookmarkItem
)
{
BookmarkSyncLog
.
trace
(
remove
:
Item
{
guid
}
already
removed
)
;
continue
;
}
let
kind
=
await
getKindForItem
(
bookmarkItem
)
;
if
(
kind
=
=
BookmarkSyncUtils
.
KINDS
.
FOLDER
)
{
folderGuids
.
push
(
bookmarkItem
.
guid
)
;
continue
;
}
let
wasRemoved
=
await
deleteSyncedAtom
(
bookmarkItem
)
;
if
(
wasRemoved
)
{
BookmarkSyncLog
.
trace
(
remove
:
Removed
item
{
guid
}
with
+
kind
{
kind
}
)
;
}
}
for
(
let
guid
of
folderGuids
)
{
let
bookmarkItem
=
await
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
;
if
(
!
bookmarkItem
)
{
BookmarkSyncLog
.
trace
(
remove
:
Folder
{
guid
}
already
removed
)
;
continue
;
}
let
wasRemoved
=
await
deleteSyncedFolder
(
bookmarkItem
)
;
if
(
wasRemoved
)
{
BookmarkSyncLog
.
trace
(
remove
:
Removed
folder
{
bookmarkItem
.
guid
}
)
;
}
}
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
remove
"
db
=
>
pullSyncChanges
(
db
)
)
;
}
async
touch
(
syncId
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
syncId
(
syncId
)
;
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
syncId
)
;
let
bookmarkItem
=
await
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
;
if
(
!
bookmarkItem
)
{
return
null
;
}
let
kind
=
await
getKindForItem
(
bookmarkItem
)
;
if
(
kind
=
=
BookmarkSyncUtils
.
KINDS
.
FOLDER
)
{
return
null
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
touch
"
db
=
>
touchSyncBookmark
(
db
bookmarkItem
)
)
;
}
isRootSyncID
(
syncID
)
{
return
ROOT_SYNC_ID_TO_GUID
.
hasOwnProperty
(
syncID
)
;
}
async
wipe
(
)
{
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
{
source
:
SOURCE_SYNC
}
)
;
await
BookmarkSyncUtils
.
reset
(
)
;
}
async
reset
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
reset
"
function
(
db
)
{
return
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
1
syncStatus
=
:
syncStatus
{
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NEW
}
)
;
await
db
.
execute
(
DELETE
FROM
moz_items_annos
WHERE
anno_attribute_id
=
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
:
orphanAnno
)
{
orphanAnno
:
BookmarkSyncUtils
.
SYNC_PARENT_ANNO
}
)
;
await
db
.
executeCached
(
"
DELETE
FROM
moz_bookmarks_deleted
"
)
;
}
)
;
}
)
;
}
async
dedupe
(
localSyncId
remoteSyncId
remoteParentSyncId
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
syncId
(
localSyncId
)
;
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
syncId
(
remoteSyncId
)
;
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
syncId
(
remoteParentSyncId
)
;
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
dedupe
"
db
=
>
dedupeSyncBookmark
(
db
BookmarkSyncUtils
.
syncIdToGuid
(
localSyncId
)
BookmarkSyncUtils
.
syncIdToGuid
(
remoteSyncId
)
BookmarkSyncUtils
.
syncIdToGuid
(
remoteParentSyncId
)
)
)
;
}
async
update
(
info
)
{
let
updateInfo
=
validateSyncBookmarkObject
(
info
{
syncId
:
{
required
:
true
}
}
)
;
return
updateSyncBookmark
(
updateInfo
)
;
}
async
insert
(
info
)
{
let
insertInfo
=
validateNewBookmark
(
info
)
;
return
insertSyncBookmark
(
insertInfo
)
;
}
async
fetch
(
syncId
)
{
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
syncId
)
;
let
bookmarkItem
=
await
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
;
if
(
!
bookmarkItem
)
{
return
null
;
}
let
kind
=
await
getKindForItem
(
bookmarkItem
)
;
let
item
;
switch
(
kind
)
{
case
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
:
item
=
await
fetchBookmarkItem
(
bookmarkItem
)
;
break
;
case
BookmarkSyncUtils
.
KINDS
.
QUERY
:
item
=
await
fetchQueryItem
(
bookmarkItem
)
;
break
;
case
BookmarkSyncUtils
.
KINDS
.
FOLDER
:
item
=
await
fetchFolderItem
(
bookmarkItem
)
;
break
;
case
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
:
item
=
await
fetchLivemarkItem
(
bookmarkItem
)
;
break
;
case
BookmarkSyncUtils
.
KINDS
.
SEPARATOR
:
item
=
await
placesBookmarkToSyncBookmark
(
bookmarkItem
)
;
item
.
index
=
bookmarkItem
.
index
;
break
;
default
:
throw
new
Error
(
Unknown
bookmark
kind
:
{
kind
}
)
;
}
if
(
bookmarkItem
.
parentGuid
)
{
let
parent
=
await
PlacesUtils
.
bookmarks
.
fetch
(
bookmarkItem
.
parentGuid
)
;
item
.
parentTitle
=
parent
.
title
|
|
"
"
;
}
return
item
;
}
getKindForSyncId
(
syncId
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
syncId
(
syncId
)
;
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
syncId
)
;
return
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
.
then
(
item
=
>
{
if
(
!
item
)
{
return
null
;
}
return
getKindForItem
(
item
)
}
)
;
}
determineSyncChangeDelta
(
source
)
{
return
source
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
?
0
:
1
;
}
determineInitialSyncStatus
(
source
)
{
if
(
source
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
)
{
return
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
;
}
if
(
source
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
IMPORT_REPLACE
)
{
return
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
UNKNOWN
;
}
return
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NEW
;
}
addSyncChangesForBookmarksWithURL
(
db
url
syncChangeDelta
)
{
if
(
!
url
|
|
!
syncChangeDelta
)
{
return
Promise
.
resolve
(
)
;
}
return
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
:
syncChangeDelta
WHERE
type
=
:
type
AND
fk
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
{
syncChangeDelta
type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
url
:
url
.
href
}
)
;
}
ratchetTimestampBackwards
(
existingMillis
serverMillis
lowerBound
=
BookmarkSyncUtils
.
EARLIEST_BOOKMARK_TIMESTAMP
)
{
const
possible
=
[
+
existingMillis
+
serverMillis
]
.
filter
(
n
=
>
!
isNaN
(
n
)
&
&
n
>
lowerBound
)
;
if
(
!
possible
.
length
)
{
return
undefined
;
}
return
Math
.
min
(
.
.
.
possible
)
;
}
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
BookmarkSyncLog
"
(
)
=
>
{
return
Log
.
repository
.
getLogger
(
"
BookmarkSyncUtils
"
)
;
}
)
;
function
validateSyncBookmarkObject
(
input
behavior
)
{
return
PlacesUtils
.
validateItemProperties
(
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
input
behavior
)
;
}
function
validateChangeRecord
(
changeRecord
behavior
)
{
return
PlacesUtils
.
validateItemProperties
(
PlacesUtils
.
SYNC_CHANGE_RECORD_VALIDATORS
changeRecord
behavior
)
;
}
var
fetchChildGuids
=
async
function
(
db
parentGuid
)
{
let
rows
=
await
db
.
executeCached
(
SELECT
guid
FROM
moz_bookmarks
WHERE
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
:
parentGuid
)
ORDER
BY
position
{
parentGuid
}
)
;
return
rows
.
map
(
row
=
>
row
.
getResultByName
(
"
guid
"
)
)
;
}
;
var
GUIDMissing
=
async
function
(
guid
)
{
try
{
await
PlacesUtils
.
promiseItemId
(
guid
)
;
return
false
;
}
catch
(
ex
)
{
if
(
ex
.
message
=
=
"
no
item
found
for
the
given
GUID
"
)
{
return
true
;
}
throw
ex
;
}
}
;
var
updateTagQueryFolder
=
async
function
(
info
)
{
if
(
info
.
kind
!
=
BookmarkSyncUtils
.
KINDS
.
QUERY
|
|
!
info
.
folder
|
|
!
info
.
url
|
|
info
.
url
.
protocol
!
=
"
place
:
"
)
{
return
info
;
}
let
params
=
new
URLSearchParams
(
info
.
url
.
pathname
)
;
let
type
=
+
params
.
get
(
"
type
"
)
;
if
(
type
!
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAG_CONTENTS
)
{
return
info
;
}
let
id
=
await
getOrCreateTagFolder
(
info
.
folder
)
;
BookmarkSyncLog
.
debug
(
updateTagQueryFolder
:
Tag
query
folder
:
{
info
.
folder
}
=
{
id
}
)
;
params
.
set
(
"
folder
"
id
)
;
info
.
url
=
new
URL
(
info
.
url
.
protocol
+
params
)
;
return
info
;
}
;
var
annotateOrphan
=
async
function
(
item
requestedParentSyncId
)
{
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
item
.
syncId
)
;
let
itemId
=
await
PlacesUtils
.
promiseItemId
(
guid
)
;
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
SYNC_PARENT_ANNO
requestedParentSyncId
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
}
;
var
reparentOrphans
=
async
function
(
item
)
{
if
(
!
item
.
kind
|
|
item
.
kind
!
=
BookmarkSyncUtils
.
KINDS
.
FOLDER
)
{
return
;
}
let
orphanGuids
=
await
fetchGuidsWithAnno
(
BookmarkSyncUtils
.
SYNC_PARENT_ANNO
item
.
syncId
)
;
let
folderGuid
=
BookmarkSyncUtils
.
syncIdToGuid
(
item
.
syncId
)
;
BookmarkSyncLog
.
debug
(
reparentOrphans
:
Reparenting
{
JSON
.
stringify
(
orphanGuids
)
}
to
{
item
.
syncId
}
)
;
for
(
let
i
=
0
;
i
<
orphanGuids
.
length
;
+
+
i
)
{
try
{
BookmarkSyncLog
.
trace
(
reparentOrphans
:
Attempting
to
move
item
{
orphanGuids
[
i
]
}
to
new
parent
{
item
.
syncId
}
)
;
await
PlacesUtils
.
bookmarks
.
update
(
{
guid
:
orphanGuids
[
i
]
parentGuid
:
folderGuid
index
:
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
source
:
SOURCE_SYNC
}
)
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
error
(
reparentOrphans
:
Failed
to
reparent
item
{
orphanGuids
[
i
]
}
to
{
item
.
syncId
}
ex
)
;
}
}
}
;
var
insertSyncBookmark
=
async
function
(
insertInfo
)
{
let
requestedParentSyncId
=
insertInfo
.
parentSyncId
;
let
requestedParentGuid
=
BookmarkSyncUtils
.
syncIdToGuid
(
insertInfo
.
parentSyncId
)
;
let
isOrphan
=
await
GUIDMissing
(
requestedParentGuid
)
;
if
(
!
isOrphan
)
{
BookmarkSyncLog
.
debug
(
insertSyncBookmark
:
Item
{
insertInfo
.
syncId
}
is
not
an
orphan
)
;
}
else
{
BookmarkSyncLog
.
debug
(
insertSyncBookmark
:
Item
{
insertInfo
.
syncId
}
is
an
orphan
:
parent
{
insertInfo
.
parentSyncId
}
doesn
'
t
exist
;
reparenting
to
unfiled
)
;
insertInfo
.
parentSyncId
=
"
unfiled
"
;
}
insertInfo
=
await
updateTagQueryFolder
(
insertInfo
)
;
let
newItem
;
if
(
insertInfo
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
)
{
newItem
=
await
insertSyncLivemark
(
insertInfo
)
;
}
else
{
let
bookmarkInfo
=
syncBookmarkToPlacesBookmark
(
insertInfo
)
;
let
bookmarkItem
=
await
PlacesUtils
.
bookmarks
.
insert
(
bookmarkInfo
)
;
newItem
=
await
insertBookmarkMetadata
(
bookmarkItem
insertInfo
)
;
}
if
(
!
newItem
)
{
return
null
;
}
if
(
isOrphan
)
{
await
annotateOrphan
(
newItem
requestedParentSyncId
)
;
}
await
reparentOrphans
(
newItem
)
;
return
newItem
;
}
;
var
insertSyncLivemark
=
async
function
(
insertInfo
)
{
if
(
!
insertInfo
.
feed
)
{
BookmarkSyncLog
.
debug
(
insertSyncLivemark
:
{
insertInfo
.
syncId
}
missing
feed
URL
)
;
return
null
;
}
let
livemarkInfo
=
syncBookmarkToPlacesBookmark
(
insertInfo
)
;
let
parentIsLivemark
=
await
getAnno
(
livemarkInfo
.
parentGuid
PlacesUtils
.
LMANNO_FEEDURI
)
;
if
(
parentIsLivemark
)
{
BookmarkSyncLog
.
debug
(
insertSyncLivemark
:
Invalid
parent
{
insertInfo
.
parentSyncId
}
;
skipping
livemark
record
{
insertInfo
.
syncId
}
)
;
return
null
;
}
let
livemarkItem
=
await
PlacesUtils
.
livemarks
.
addLivemark
(
livemarkInfo
)
;
return
insertBookmarkMetadata
(
livemarkItem
insertInfo
)
;
}
;
function
removeConflictingKeywords
(
bookmarkURL
newKeyword
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
removeConflictingKeywords
"
async
function
(
db
)
{
let
entryForURL
=
await
PlacesUtils
.
keywords
.
fetch
(
{
url
:
bookmarkURL
.
href
}
)
;
if
(
entryForURL
&
&
entryForURL
.
keyword
!
=
=
newKeyword
)
{
await
PlacesUtils
.
keywords
.
remove
(
{
keyword
:
entryForURL
.
keyword
source
:
SOURCE_SYNC
}
)
;
await
BookmarkSyncUtils
.
addSyncChangesForBookmarksWithURL
(
db
entryForURL
.
url
1
)
;
}
if
(
!
newKeyword
)
{
return
;
}
let
entryForNewKeyword
=
await
PlacesUtils
.
keywords
.
fetch
(
{
keyword
:
newKeyword
}
)
;
if
(
entryForNewKeyword
)
{
await
PlacesUtils
.
keywords
.
remove
(
{
keyword
:
entryForNewKeyword
.
keyword
source
:
SOURCE_SYNC
}
)
;
await
BookmarkSyncUtils
.
addSyncChangesForBookmarksWithURL
(
db
entryForNewKeyword
.
url
1
)
;
}
}
)
;
}
var
insertBookmarkMetadata
=
async
function
(
bookmarkItem
insertInfo
)
{
let
itemId
=
await
PlacesUtils
.
promiseItemId
(
bookmarkItem
.
guid
)
;
let
newItem
=
await
placesBookmarkToSyncBookmark
(
bookmarkItem
)
;
if
(
insertInfo
.
query
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
SMART_BOOKMARKS_ANNO
insertInfo
.
query
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
newItem
.
query
=
insertInfo
.
query
;
}
try
{
newItem
.
tags
=
tagItem
(
bookmarkItem
insertInfo
.
tags
)
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
warn
(
insertBookmarkMetadata
:
Error
tagging
item
{
insertInfo
.
syncId
}
ex
)
;
}
if
(
insertInfo
.
keyword
)
{
await
removeConflictingKeywords
(
bookmarkItem
.
url
insertInfo
.
keyword
)
;
await
PlacesUtils
.
keywords
.
insert
(
{
keyword
:
insertInfo
.
keyword
url
:
bookmarkItem
.
url
.
href
source
:
SOURCE_SYNC
}
)
;
newItem
.
keyword
=
insertInfo
.
keyword
;
}
if
(
insertInfo
.
description
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
DESCRIPTION_ANNO
insertInfo
.
description
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
newItem
.
description
=
insertInfo
.
description
;
}
if
(
insertInfo
.
loadInSidebar
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
SIDEBAR_ANNO
insertInfo
.
loadInSidebar
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
newItem
.
loadInSidebar
=
insertInfo
.
loadInSidebar
;
}
return
newItem
;
}
;
var
getKindForItem
=
async
function
(
item
)
{
switch
(
item
.
type
)
{
case
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
:
{
let
isLivemark
=
await
getAnno
(
item
.
guid
PlacesUtils
.
LMANNO_FEEDURI
)
;
return
isLivemark
?
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
:
BookmarkSyncUtils
.
KINDS
.
FOLDER
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
:
return
item
.
url
.
protocol
=
=
"
place
:
"
?
BookmarkSyncUtils
.
KINDS
.
QUERY
:
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
;
case
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
:
return
BookmarkSyncUtils
.
KINDS
.
SEPARATOR
;
}
return
null
;
}
;
function
getTypeForKind
(
kind
)
{
switch
(
kind
)
{
case
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
:
case
BookmarkSyncUtils
.
KINDS
.
QUERY
:
return
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
;
case
BookmarkSyncUtils
.
KINDS
.
FOLDER
:
case
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
:
return
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
;
case
BookmarkSyncUtils
.
KINDS
.
SEPARATOR
:
return
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
;
}
throw
new
Error
(
Unknown
bookmark
kind
:
{
kind
}
)
;
}
var
shouldReinsertLivemark
=
async
function
(
updateInfo
)
{
let
hasFeed
=
updateInfo
.
hasOwnProperty
(
"
feed
"
)
;
let
hasSite
=
updateInfo
.
hasOwnProperty
(
"
site
"
)
;
if
(
!
hasFeed
&
&
!
hasSite
)
{
return
false
;
}
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
updateInfo
.
syncId
)
;
let
livemark
=
await
PlacesUtils
.
livemarks
.
getLivemark
(
{
guid
}
)
;
if
(
hasFeed
)
{
let
feedURI
=
PlacesUtils
.
toURI
(
updateInfo
.
feed
)
;
if
(
!
livemark
.
feedURI
.
equals
(
feedURI
)
)
{
return
true
;
}
}
if
(
hasSite
)
{
if
(
!
updateInfo
.
site
)
{
return
!
!
livemark
.
siteURI
;
}
let
siteURI
=
PlacesUtils
.
toURI
(
updateInfo
.
site
)
;
if
(
!
livemark
.
siteURI
|
|
!
siteURI
.
equals
(
livemark
.
siteURI
)
)
{
return
true
;
}
}
return
false
;
}
;
var
updateSyncBookmark
=
async
function
(
updateInfo
)
{
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
updateInfo
.
syncId
)
;
let
oldBookmarkItem
=
await
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
;
if
(
!
oldBookmarkItem
)
{
throw
new
Error
(
Bookmark
with
sync
ID
{
updateInfo
.
syncId
}
does
not
exist
)
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
dateAdded
"
)
)
{
let
newDateAdded
=
BookmarkSyncUtils
.
ratchetTimestampBackwards
(
oldBookmarkItem
.
dateAdded
updateInfo
.
dateAdded
)
;
if
(
!
newDateAdded
|
|
newDateAdded
=
=
=
oldBookmarkItem
.
dateAdded
)
{
delete
updateInfo
.
dateAdded
;
}
else
{
updateInfo
.
dateAdded
=
newDateAdded
;
}
}
let
shouldReinsert
=
false
;
let
oldKind
=
await
getKindForItem
(
oldBookmarkItem
)
;
if
(
updateInfo
.
hasOwnProperty
(
"
kind
"
)
&
&
updateInfo
.
kind
!
=
oldKind
)
{
shouldReinsert
=
true
;
if
(
BookmarkSyncLog
.
level
<
=
Log
.
Level
.
Warn
)
{
let
oldSyncId
=
BookmarkSyncUtils
.
guidToSyncId
(
oldBookmarkItem
.
guid
)
;
BookmarkSyncLog
.
warn
(
updateSyncBookmark
:
Local
{
oldSyncId
}
kind
=
{
oldKind
}
;
remote
{
updateInfo
.
syncId
}
kind
=
{
updateInfo
.
kind
}
.
Deleting
and
recreating
)
;
}
}
else
if
(
oldKind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
)
{
shouldReinsert
=
await
shouldReinsertLivemark
(
updateInfo
)
;
if
(
BookmarkSyncLog
.
level
<
=
Log
.
Level
.
Debug
)
{
let
oldSyncId
=
BookmarkSyncUtils
.
guidToSyncId
(
oldBookmarkItem
.
guid
)
;
BookmarkSyncLog
.
debug
(
updateSyncBookmark
:
Local
{
oldSyncId
}
and
remote
{
updateInfo
.
syncId
}
livemarks
have
different
URLs
)
;
}
}
if
(
shouldReinsert
)
{
if
(
!
updateInfo
.
hasOwnProperty
(
"
dateAdded
"
)
)
{
updateInfo
.
dateAdded
=
oldBookmarkItem
.
dateAdded
.
getTime
(
)
;
}
let
newInfo
=
validateNewBookmark
(
updateInfo
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
{
guid
source
:
SOURCE_SYNC
}
)
;
return
insertSyncBookmark
(
newInfo
)
;
}
let
isOrphan
=
false
requestedParentSyncId
;
if
(
updateInfo
.
hasOwnProperty
(
"
parentSyncId
"
)
)
{
requestedParentSyncId
=
updateInfo
.
parentSyncId
;
let
oldParentSyncId
=
BookmarkSyncUtils
.
guidToSyncId
(
oldBookmarkItem
.
parentGuid
)
;
if
(
requestedParentSyncId
!
=
oldParentSyncId
)
{
let
oldId
=
await
PlacesUtils
.
promiseItemId
(
oldBookmarkItem
.
guid
)
;
if
(
PlacesUtils
.
isRootItem
(
oldId
)
)
{
throw
new
Error
(
Cannot
move
Places
root
{
oldId
}
)
;
}
let
requestedParentGuid
=
BookmarkSyncUtils
.
syncIdToGuid
(
requestedParentSyncId
)
;
isOrphan
=
await
GUIDMissing
(
requestedParentGuid
)
;
if
(
!
isOrphan
)
{
BookmarkSyncLog
.
debug
(
updateSyncBookmark
:
Item
{
updateInfo
.
syncId
}
is
not
an
orphan
)
;
}
else
{
BookmarkSyncLog
.
trace
(
updateSyncBookmark
:
Item
{
updateInfo
.
syncId
}
is
an
orphan
:
could
not
find
parent
{
requestedParentSyncId
}
)
;
delete
updateInfo
.
parentSyncId
;
}
}
else
{
delete
updateInfo
.
parentSyncId
;
}
}
updateInfo
=
await
updateTagQueryFolder
(
updateInfo
)
;
let
bookmarkInfo
=
syncBookmarkToPlacesBookmark
(
updateInfo
)
;
let
newBookmarkItem
=
shouldUpdateBookmark
(
bookmarkInfo
)
?
await
PlacesUtils
.
bookmarks
.
update
(
bookmarkInfo
)
:
oldBookmarkItem
;
let
newItem
=
await
updateBookmarkMetadata
(
oldBookmarkItem
newBookmarkItem
updateInfo
)
;
if
(
isOrphan
)
{
await
annotateOrphan
(
newItem
requestedParentSyncId
)
;
}
await
reparentOrphans
(
newItem
)
;
return
newItem
;
}
;
var
updateBookmarkMetadata
=
async
function
(
oldBookmarkItem
newBookmarkItem
updateInfo
)
{
let
itemId
=
await
PlacesUtils
.
promiseItemId
(
newBookmarkItem
.
guid
)
;
let
newItem
=
await
placesBookmarkToSyncBookmark
(
newBookmarkItem
)
;
try
{
newItem
.
tags
=
tagItem
(
newBookmarkItem
updateInfo
.
tags
)
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
warn
(
updateBookmarkMetadata
:
Error
tagging
item
{
updateInfo
.
syncId
}
ex
)
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
keyword
"
)
)
{
await
removeConflictingKeywords
(
oldBookmarkItem
.
url
updateInfo
.
keyword
)
;
if
(
updateInfo
.
keyword
)
{
await
PlacesUtils
.
keywords
.
insert
(
{
keyword
:
updateInfo
.
keyword
url
:
newItem
.
url
.
href
source
:
SOURCE_SYNC
}
)
;
}
newItem
.
keyword
=
updateInfo
.
keyword
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
description
"
)
)
{
if
(
updateInfo
.
description
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
DESCRIPTION_ANNO
updateInfo
.
description
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
}
else
{
PlacesUtils
.
annotations
.
removeItemAnnotation
(
itemId
BookmarkSyncUtils
.
DESCRIPTION_ANNO
SOURCE_SYNC
)
;
}
newItem
.
description
=
updateInfo
.
description
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
loadInSidebar
"
)
)
{
if
(
updateInfo
.
loadInSidebar
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
SIDEBAR_ANNO
updateInfo
.
loadInSidebar
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
}
else
{
PlacesUtils
.
annotations
.
removeItemAnnotation
(
itemId
BookmarkSyncUtils
.
SIDEBAR_ANNO
SOURCE_SYNC
)
;
}
newItem
.
loadInSidebar
=
updateInfo
.
loadInSidebar
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
query
"
)
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
BookmarkSyncUtils
.
SMART_BOOKMARKS_ANNO
updateInfo
.
query
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
newItem
.
query
=
updateInfo
.
query
;
}
return
newItem
;
}
;
function
validateNewBookmark
(
info
)
{
let
insertInfo
=
validateSyncBookmarkObject
(
info
{
kind
:
{
required
:
true
}
syncId
:
{
required
:
true
}
url
:
{
requiredIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
parentSyncId
:
{
required
:
true
}
title
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
QUERY
BookmarkSyncUtils
.
KINDS
.
FOLDER
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
]
.
includes
(
b
.
kind
)
}
query
:
{
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
QUERY
}
folder
:
{
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
QUERY
}
tags
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
keyword
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
description
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
QUERY
BookmarkSyncUtils
.
KINDS
.
FOLDER
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
]
.
includes
(
b
.
kind
)
}
loadInSidebar
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
feed
:
{
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
}
site
:
{
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
}
dateAdded
:
{
required
:
false
}
}
)
;
return
insertInfo
;
}
var
fetchGuidsWithAnno
=
async
function
(
anno
val
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
b
.
guid
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
JOIN
moz_bookmarks
b
ON
b
.
id
=
a
.
item_id
WHERE
n
.
name
=
:
anno
AND
a
.
content
=
:
val
{
anno
val
}
)
;
return
rows
.
map
(
row
=
>
row
.
getResultByName
(
"
guid
"
)
)
;
}
;
var
getAnno
=
async
function
(
guid
anno
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
a
.
content
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
JOIN
moz_bookmarks
b
ON
b
.
id
=
a
.
item_id
WHERE
b
.
guid
=
:
guid
AND
n
.
name
=
:
anno
{
guid
anno
}
)
;
return
rows
.
length
?
rows
[
0
]
.
getResultByName
(
"
content
"
)
:
null
;
}
;
function
tagItem
(
item
tags
)
{
if
(
!
item
.
url
)
{
return
[
]
;
}
let
newTags
=
tags
?
tags
.
map
(
tag
=
>
tag
.
trim
(
)
)
.
filter
(
Boolean
)
:
[
]
;
let
dummyURI
=
PlacesUtils
.
toURI
(
"
about
:
weave
#
BStore_tagURI
"
)
;
let
bookmarkURI
=
PlacesUtils
.
toURI
(
item
.
url
.
href
)
;
if
(
newTags
&
&
newTags
.
length
>
0
)
PlacesUtils
.
tagging
.
tagURI
(
dummyURI
newTags
SOURCE_SYNC
)
;
PlacesUtils
.
tagging
.
untagURI
(
bookmarkURI
null
SOURCE_SYNC
)
;
if
(
newTags
&
&
newTags
.
length
>
0
)
PlacesUtils
.
tagging
.
tagURI
(
bookmarkURI
newTags
SOURCE_SYNC
)
;
PlacesUtils
.
tagging
.
untagURI
(
dummyURI
null
SOURCE_SYNC
)
;
return
newTags
;
}
function
shouldUpdateBookmark
(
bookmarkInfo
)
{
return
bookmarkInfo
.
hasOwnProperty
(
"
parentGuid
"
)
|
|
bookmarkInfo
.
hasOwnProperty
(
"
title
"
)
|
|
bookmarkInfo
.
hasOwnProperty
(
"
url
"
)
;
}
var
getTagFolder
=
async
function
(
tag
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
results
=
await
db
.
executeCached
(
SELECT
id
FROM
moz_bookmarks
WHERE
type
=
:
type
AND
parent
=
:
tagsFolderId
AND
title
=
:
tag
{
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
tagsFolderId
:
PlacesUtils
.
tagsFolderId
tag
}
)
;
return
results
.
length
?
results
[
0
]
.
getResultByName
(
"
id
"
)
:
null
;
}
;
var
getOrCreateTagFolder
=
async
function
(
tag
)
{
let
id
=
await
getTagFolder
(
tag
)
;
if
(
id
)
{
return
id
;
}
let
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
parentGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
title
:
tag
source
:
SOURCE_SYNC
}
)
;
return
PlacesUtils
.
promiseItemId
(
item
.
guid
)
;
}
;
var
placesBookmarkToSyncBookmark
=
async
function
(
bookmarkItem
)
{
let
item
=
{
}
;
for
(
let
prop
in
bookmarkItem
)
{
switch
(
prop
)
{
case
"
guid
"
:
item
.
syncId
=
BookmarkSyncUtils
.
guidToSyncId
(
bookmarkItem
.
guid
)
;
break
;
case
"
parentGuid
"
:
item
.
parentSyncId
=
BookmarkSyncUtils
.
guidToSyncId
(
bookmarkItem
.
parentGuid
)
;
break
;
case
"
type
"
:
item
.
kind
=
await
getKindForItem
(
bookmarkItem
)
;
break
;
case
"
title
"
:
case
"
url
"
:
item
[
prop
]
=
bookmarkItem
[
prop
]
;
break
;
case
"
dateAdded
"
:
item
[
prop
]
=
new
Date
(
bookmarkItem
[
prop
]
)
.
getTime
(
)
;
break
;
case
"
feedURI
"
:
item
.
feed
=
new
URL
(
bookmarkItem
.
feedURI
.
spec
)
;
break
;
case
"
siteURI
"
:
if
(
bookmarkItem
.
siteURI
)
{
item
.
site
=
new
URL
(
bookmarkItem
.
siteURI
.
spec
)
;
}
break
;
}
}
return
item
;
}
;
function
syncBookmarkToPlacesBookmark
(
info
)
{
let
bookmarkInfo
=
{
source
:
SOURCE_SYNC
}
;
for
(
let
prop
in
info
)
{
switch
(
prop
)
{
case
"
kind
"
:
bookmarkInfo
.
type
=
getTypeForKind
(
info
.
kind
)
;
break
;
case
"
syncId
"
:
bookmarkInfo
.
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
info
.
syncId
)
;
break
;
case
"
dateAdded
"
:
bookmarkInfo
.
dateAdded
=
new
Date
(
info
.
dateAdded
)
;
break
;
case
"
parentSyncId
"
:
bookmarkInfo
.
parentGuid
=
BookmarkSyncUtils
.
syncIdToGuid
(
info
.
parentSyncId
)
;
bookmarkInfo
.
index
=
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
;
break
;
case
"
title
"
:
case
"
url
"
:
bookmarkInfo
[
prop
]
=
info
[
prop
]
;
break
;
case
"
feed
"
:
bookmarkInfo
.
feedURI
=
PlacesUtils
.
toURI
(
info
.
feed
)
;
break
;
case
"
site
"
:
if
(
info
.
site
)
{
bookmarkInfo
.
siteURI
=
PlacesUtils
.
toURI
(
info
.
site
)
;
}
break
;
}
}
return
bookmarkInfo
;
}
var
fetchBookmarkItem
=
async
function
(
bookmarkItem
)
{
let
item
=
await
placesBookmarkToSyncBookmark
(
bookmarkItem
)
;
if
(
!
item
.
title
)
{
item
.
title
=
"
"
;
}
item
.
tags
=
PlacesUtils
.
tagging
.
getTagsForURI
(
PlacesUtils
.
toURI
(
bookmarkItem
.
url
)
{
}
)
;
let
keywordEntry
=
await
PlacesUtils
.
keywords
.
fetch
(
{
url
:
bookmarkItem
.
url
}
)
;
if
(
keywordEntry
)
{
item
.
keyword
=
keywordEntry
.
keyword
;
}
let
description
=
await
getAnno
(
bookmarkItem
.
guid
BookmarkSyncUtils
.
DESCRIPTION_ANNO
)
;
if
(
description
)
{
item
.
description
=
description
;
}
item
.
loadInSidebar
=
!
!
(
await
getAnno
(
bookmarkItem
.
guid
BookmarkSyncUtils
.
SIDEBAR_ANNO
)
)
;
return
item
;
}
;
var
fetchFolderItem
=
async
function
(
bookmarkItem
)
{
let
item
=
await
placesBookmarkToSyncBookmark
(
bookmarkItem
)
;
if
(
!
item
.
title
)
{
item
.
title
=
"
"
;
}
let
description
=
await
getAnno
(
bookmarkItem
.
guid
BookmarkSyncUtils
.
DESCRIPTION_ANNO
)
;
if
(
description
)
{
item
.
description
=
description
;
}
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
childGuids
=
await
fetchChildGuids
(
db
bookmarkItem
.
guid
)
;
item
.
childSyncIds
=
childGuids
.
map
(
guid
=
>
BookmarkSyncUtils
.
guidToSyncId
(
guid
)
)
;
return
item
;
}
;
var
fetchLivemarkItem
=
async
function
(
bookmarkItem
)
{
let
item
=
await
placesBookmarkToSyncBookmark
(
bookmarkItem
)
;
if
(
!
item
.
title
)
{
item
.
title
=
"
"
;
}
let
description
=
await
getAnno
(
bookmarkItem
.
guid
BookmarkSyncUtils
.
DESCRIPTION_ANNO
)
;
if
(
description
)
{
item
.
description
=
description
;
}
let
feedAnno
=
await
getAnno
(
bookmarkItem
.
guid
PlacesUtils
.
LMANNO_FEEDURI
)
;
item
.
feed
=
new
URL
(
feedAnno
)
;
let
siteAnno
=
await
getAnno
(
bookmarkItem
.
guid
PlacesUtils
.
LMANNO_SITEURI
)
;
if
(
siteAnno
)
{
item
.
site
=
new
URL
(
siteAnno
)
;
}
return
item
;
}
;
var
fetchQueryItem
=
async
function
(
bookmarkItem
)
{
let
item
=
await
placesBookmarkToSyncBookmark
(
bookmarkItem
)
;
let
description
=
await
getAnno
(
bookmarkItem
.
guid
BookmarkSyncUtils
.
DESCRIPTION_ANNO
)
;
if
(
description
)
{
item
.
description
=
description
;
}
let
folder
=
null
;
let
params
=
new
URLSearchParams
(
bookmarkItem
.
url
.
pathname
)
;
let
tagFolderId
=
+
params
.
get
(
"
folder
"
)
;
if
(
tagFolderId
)
{
try
{
let
tagFolderGuid
=
await
PlacesUtils
.
promiseItemGuid
(
tagFolderId
)
;
let
tagFolder
=
await
PlacesUtils
.
bookmarks
.
fetch
(
tagFolderGuid
)
;
folder
=
tagFolder
.
title
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
warn
(
"
fetchQueryItem
:
Query
"
+
bookmarkItem
.
url
.
href
+
"
points
to
nonexistent
folder
"
+
tagFolderId
ex
)
;
}
}
if
(
folder
!
=
null
)
{
item
.
folder
=
folder
;
}
let
query
=
await
getAnno
(
bookmarkItem
.
guid
BookmarkSyncUtils
.
SMART_BOOKMARKS_ANNO
)
;
if
(
query
)
{
item
.
query
=
query
;
}
return
item
;
}
;
function
addRowToChangeRecords
(
row
changeRecords
)
{
let
syncId
=
BookmarkSyncUtils
.
guidToSyncId
(
row
.
getResultByName
(
"
guid
"
)
)
;
let
modifiedAsPRTime
=
row
.
getResultByName
(
"
modified
"
)
;
let
modified
=
modifiedAsPRTime
/
MICROSECONDS_PER_SECOND
;
if
(
Number
.
isNaN
(
modified
)
|
|
modified
<
=
0
)
{
BookmarkSyncLog
.
error
(
"
addRowToChangeRecords
:
Invalid
modified
date
for
"
+
syncId
modifiedAsPRTime
)
;
modified
=
0
;
}
changeRecords
[
syncId
]
=
{
modified
counter
:
row
.
getResultByName
(
"
syncChangeCounter
"
)
status
:
row
.
getResultByName
(
"
syncStatus
"
)
tombstone
:
!
!
row
.
getResultByName
(
"
tombstone
"
)
synced
:
false
}
;
}
var
pullSyncChanges
=
async
function
(
db
)
{
let
changeRecords
=
{
}
;
await
db
.
executeCached
(
WITH
RECURSIVE
syncedItems
(
id
guid
modified
syncChangeCounter
syncStatus
)
AS
(
SELECT
b
.
id
b
.
guid
b
.
lastModified
b
.
syncChangeCounter
b
.
syncStatus
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
'
menu________
'
'
toolbar_____
'
'
unfiled_____
'
'
mobile______
'
)
UNION
ALL
SELECT
b
.
id
b
.
guid
b
.
lastModified
b
.
syncChangeCounter
b
.
syncStatus
FROM
moz_bookmarks
b
JOIN
syncedItems
s
ON
b
.
parent
=
s
.
id
)
SELECT
guid
modified
syncChangeCounter
syncStatus
0
AS
tombstone
FROM
syncedItems
WHERE
syncChangeCounter
>
=
1
UNION
ALL
SELECT
guid
dateRemoved
AS
modified
1
AS
syncChangeCounter
:
deletedSyncStatus
1
AS
tombstone
FROM
moz_bookmarks_deleted
{
deletedSyncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
row
=
>
addRowToChangeRecords
(
row
changeRecords
)
)
;
await
markChangesAsSyncing
(
db
changeRecords
)
;
return
changeRecords
;
}
;
var
touchSyncBookmark
=
async
function
(
db
bookmarkItem
)
{
if
(
BookmarkSyncLog
.
level
<
=
Log
.
Level
.
Trace
)
{
BookmarkSyncLog
.
trace
(
touch
:
Reviving
item
"
{
bookmarkItem
.
guid
}
"
and
marking
parent
+
BookmarkSyncUtils
.
guidToSyncId
(
bookmarkItem
.
parentGuid
)
+
as
modified
)
;
}
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
guid
IN
(
:
guid
:
parentGuid
)
{
guid
:
bookmarkItem
.
guid
parentGuid
:
bookmarkItem
.
parentGuid
}
)
;
return
pullSyncChanges
(
db
)
;
}
;
var
dedupeSyncBookmark
=
async
function
(
db
localGuid
remoteGuid
remoteParentGuid
)
{
let
rows
=
await
db
.
executeCached
(
SELECT
b
.
id
b
.
type
p
.
id
AS
parentId
p
.
guid
AS
parentGuid
b
.
syncStatus
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
WHERE
b
.
guid
=
:
localGuid
{
localGuid
}
)
;
if
(
!
rows
.
length
)
{
throw
new
Error
(
Local
item
{
localGuid
}
does
not
exist
)
;
}
let
localId
=
rows
[
0
]
.
getResultByName
(
"
id
"
)
;
let
localParentId
=
rows
[
0
]
.
getResultByName
(
"
parentId
"
)
;
let
bookmarkType
=
rows
[
0
]
.
getResultByName
(
"
type
"
)
;
if
(
PlacesUtils
.
isRootItem
(
localId
)
)
{
throw
new
Error
(
Cannot
de
-
dupe
local
root
{
localGuid
}
)
;
}
let
localParentGuid
=
rows
[
0
]
.
getResultByName
(
"
parentGuid
"
)
;
let
sameParent
=
localParentGuid
=
=
remoteParentGuid
;
let
modified
=
PlacesUtils
.
toPRTime
(
Date
.
now
(
)
)
;
await
db
.
executeTransaction
(
async
function
(
)
{
BookmarkSyncLog
.
debug
(
"
dedupeSyncBookmark
:
Switching
local
GUID
"
+
localGuid
+
"
to
incoming
GUID
"
+
remoteGuid
)
;
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
guid
=
:
remoteGuid
WHERE
id
=
:
localId
{
remoteGuid
localId
}
)
;
PlacesUtils
.
invalidateCachedGuidFor
(
localId
)
;
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
guid
=
:
localParentGuid
{
localParentGuid
}
)
;
if
(
!
sameParent
)
{
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
guid
=
:
remoteParentGuid
{
remoteParentGuid
}
)
;
}
let
localSyncStatus
=
rows
[
0
]
.
getResultByName
(
"
syncStatus
"
)
;
if
(
localSyncStatus
=
=
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
)
{
await
db
.
executeCached
(
INSERT
INTO
moz_bookmarks_deleted
(
guid
dateRemoved
)
VALUES
(
:
localGuid
:
modified
)
{
localGuid
modified
}
)
;
}
}
)
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
notify
(
observers
"
onItemChanged
"
[
localId
"
guid
"
false
remoteGuid
modified
bookmarkType
localParentId
remoteGuid
remoteParentGuid
localGuid
SOURCE_SYNC
]
)
;
let
changeRecords
=
await
pullSyncChanges
(
db
)
;
if
(
BookmarkSyncLog
.
level
<
=
Log
.
Level
.
Debug
&
&
!
sameParent
)
{
let
remoteParentSyncId
=
BookmarkSyncUtils
.
guidToSyncId
(
remoteParentGuid
)
;
if
(
!
changeRecords
.
hasOwnProperty
(
remoteParentSyncId
)
)
{
BookmarkSyncLog
.
debug
(
"
dedupeSyncBookmark
:
Incoming
duplicate
item
"
+
remoteGuid
+
"
specifies
non
-
existing
parent
"
+
remoteParentGuid
)
;
}
}
return
changeRecords
;
}
;
var
deleteSyncedFolder
=
async
function
(
bookmarkItem
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
childGuids
=
await
fetchChildGuids
(
db
bookmarkItem
.
guid
)
;
if
(
!
childGuids
.
length
)
{
return
deleteSyncedAtom
(
bookmarkItem
)
;
}
if
(
BookmarkSyncLog
.
level
<
=
Log
.
Level
.
Trace
)
{
BookmarkSyncLog
.
trace
(
deleteSyncedFolder
:
Moving
{
JSON
.
stringify
(
childGuids
)
}
children
of
+
"
{
bookmarkItem
.
guid
}
"
to
grandparent
"
{
BookmarkSyncUtils
.
guidToSyncId
(
bookmarkItem
.
parentGuid
)
}
"
before
+
deletion
)
;
}
for
(
let
guid
of
childGuids
)
{
await
PlacesUtils
.
bookmarks
.
update
(
{
guid
parentGuid
:
bookmarkItem
.
parentGuid
index
:
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
source
:
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC_REPARENT_REMOVED_FOLDER_CHILDREN
}
)
;
}
try
{
await
PlacesUtils
.
bookmarks
.
remove
(
bookmarkItem
.
guid
{
preventRemovalOfNonEmptyFolders
:
true
source
:
SOURCE_SYNC
}
)
;
}
catch
(
e
)
{
BookmarkSyncLog
.
trace
(
deleteSyncedFolder
:
Error
removing
parent
+
{
bookmarkItem
.
guid
}
after
reparenting
children
e
)
;
return
false
;
}
return
true
;
}
;
var
deleteSyncedAtom
=
async
function
(
bookmarkItem
)
{
try
{
await
PlacesUtils
.
bookmarks
.
remove
(
bookmarkItem
.
guid
{
preventRemovalOfNonEmptyFolders
:
true
source
:
SOURCE_SYNC
}
)
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
trace
(
deleteSyncedAtom
:
Error
removing
+
bookmarkItem
.
guid
ex
)
;
return
false
;
}
return
true
;
}
;
function
markChangesAsSyncing
(
db
changeRecords
)
{
let
unsyncedGuids
=
[
]
;
for
(
let
syncId
in
changeRecords
)
{
if
(
changeRecords
[
syncId
]
.
tombstone
)
{
continue
;
}
if
(
changeRecords
[
syncId
]
.
status
=
=
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
)
{
continue
;
}
let
guid
=
BookmarkSyncUtils
.
syncIdToGuid
(
syncId
)
;
unsyncedGuids
.
push
(
JSON
.
stringify
(
guid
)
)
;
}
if
(
!
unsyncedGuids
.
length
)
{
return
Promise
.
resolve
(
)
;
}
return
db
.
execute
(
UPDATE
moz_bookmarks
SET
syncStatus
=
:
syncStatus
WHERE
guid
IN
(
{
unsyncedGuids
.
join
(
"
"
)
}
)
{
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
)
;
}
var
removeTombstones
=
async
function
(
db
guids
)
{
if
(
!
guids
.
length
)
{
return
Promise
.
resolve
(
)
;
}
return
db
.
execute
(
DELETE
FROM
moz_bookmarks_deleted
WHERE
guid
IN
(
{
guids
.
map
(
guid
=
>
JSON
.
stringify
(
guid
)
)
.
join
(
"
"
)
}
)
)
;
}
;
function
notify
(
observers
notification
args
=
[
]
)
{
for
(
let
observer
of
observers
)
{
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
}
}
}
