"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PlacesSyncUtils
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
"
URLSearchParams
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
var
PlacesSyncUtils
=
{
}
;
const
{
SOURCE_SYNC
}
=
Ci
.
nsINavBookmarksService
;
const
MICROSECONDS_PER_SECOND
=
1000000
;
const
MOBILE_BOOKMARKS_PREF
=
"
browser
.
bookmarks
.
showMobileBookmarks
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ROOT_RECORD_ID_TO_GUID
"
(
)
=
>
(
{
menu
:
PlacesUtils
.
bookmarks
.
menuGuid
places
:
PlacesUtils
.
bookmarks
.
rootGuid
tags
:
PlacesUtils
.
bookmarks
.
tagsGuid
toolbar
:
PlacesUtils
.
bookmarks
.
toolbarGuid
unfiled
:
PlacesUtils
.
bookmarks
.
unfiledGuid
mobile
:
PlacesUtils
.
bookmarks
.
mobileGuid
}
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ROOT_GUID_TO_RECORD_ID
"
(
)
=
>
(
{
[
PlacesUtils
.
bookmarks
.
menuGuid
]
:
"
menu
"
[
PlacesUtils
.
bookmarks
.
rootGuid
]
:
"
places
"
[
PlacesUtils
.
bookmarks
.
tagsGuid
]
:
"
tags
"
[
PlacesUtils
.
bookmarks
.
toolbarGuid
]
:
"
toolbar
"
[
PlacesUtils
.
bookmarks
.
unfiledGuid
]
:
"
unfiled
"
[
PlacesUtils
.
bookmarks
.
mobileGuid
]
:
"
mobile
"
}
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ROOTS
"
(
)
=
>
Object
.
keys
(
ROOT_RECORD_ID_TO_GUID
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
IGNORED_TRANSITIONS_AS_SQL_LIST
"
(
)
=
>
[
0
PlacesUtils
.
history
.
TRANSITION_FRAMED_LINK
PlacesUtils
.
history
.
TRANSITION_DOWNLOAD
]
.
toString
(
)
)
;
const
HistorySyncUtils
=
(
PlacesSyncUtils
.
history
=
Object
.
freeze
(
{
SYNC_ID_META_KEY
:
"
sync
/
history
/
syncId
"
LAST_SYNC_META_KEY
:
"
sync
/
history
/
lastSync
"
getSyncId
(
)
{
return
PlacesUtils
.
metadata
.
get
(
HistorySyncUtils
.
SYNC_ID_META_KEY
"
"
)
;
}
resetSyncId
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
HistorySyncUtils
:
resetSyncId
"
function
(
db
)
{
let
newSyncId
=
PlacesUtils
.
history
.
makeGuid
(
)
;
return
db
.
executeTransaction
(
async
function
(
)
{
await
setHistorySyncId
(
db
newSyncId
)
;
return
newSyncId
;
}
)
;
}
)
;
}
async
ensureCurrentSyncId
(
newSyncId
)
{
if
(
!
newSyncId
|
|
typeof
newSyncId
!
=
"
string
"
)
{
throw
new
TypeError
(
"
Invalid
new
history
sync
ID
"
)
;
}
await
PlacesUtils
.
withConnectionWrapper
(
"
HistorySyncUtils
:
ensureCurrentSyncId
"
async
function
(
db
)
{
let
existingSyncId
=
await
PlacesUtils
.
metadata
.
getWithConnection
(
db
HistorySyncUtils
.
SYNC_ID_META_KEY
"
"
)
;
if
(
existingSyncId
=
=
newSyncId
)
{
HistorySyncLog
.
trace
(
"
History
sync
ID
up
-
to
-
date
"
{
existingSyncId
}
)
;
return
;
}
HistorySyncLog
.
info
(
"
History
sync
ID
changed
;
resetting
metadata
"
{
existingSyncId
newSyncId
}
)
;
await
db
.
executeTransaction
(
function
(
)
{
return
setHistorySyncId
(
db
newSyncId
)
;
}
)
;
}
)
;
}
async
getLastSync
(
)
{
let
lastSync
=
await
PlacesUtils
.
metadata
.
get
(
HistorySyncUtils
.
LAST_SYNC_META_KEY
0
)
;
return
lastSync
/
1000
;
}
async
setLastSync
(
lastSyncSeconds
)
{
let
lastSync
=
Math
.
floor
(
lastSyncSeconds
*
1000
)
;
if
(
!
Number
.
isInteger
(
lastSync
)
)
{
throw
new
TypeError
(
"
Invalid
history
last
sync
timestamp
"
)
;
}
await
PlacesUtils
.
metadata
.
set
(
HistorySyncUtils
.
LAST_SYNC_META_KEY
lastSync
)
;
}
async
wipe
(
)
{
await
PlacesUtils
.
history
.
clear
(
)
;
await
HistorySyncUtils
.
reset
(
)
;
}
reset
(
)
{
return
PlacesUtils
.
metadata
.
delete
(
HistorySyncUtils
.
SYNC_ID_META_KEY
HistorySyncUtils
.
LAST_SYNC_META_KEY
)
;
}
clampVisitDate
(
visitDate
)
{
let
currentDate
=
new
Date
(
)
;
if
(
visitDate
>
currentDate
)
{
return
currentDate
;
}
if
(
visitDate
<
BookmarkSyncUtils
.
EARLIEST_BOOKMARK_TIMESTAMP
)
{
return
new
Date
(
BookmarkSyncUtils
.
EARLIEST_BOOKMARK_TIMESTAMP
)
;
}
return
visitDate
;
}
async
fetchURLFrecency
(
url
)
{
let
canonicalURL
=
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
url
(
url
)
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
frecency
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
LIMIT
1
{
url
:
canonicalURL
.
href
}
)
;
return
rows
.
length
?
rows
[
0
]
.
getResultByName
(
"
frecency
"
)
:
-
1
;
}
async
determineNonSyncableGuids
(
guids
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
nonSyncableGuids
=
[
]
;
for
(
let
chunk
of
PlacesUtils
.
chunkArray
(
guids
db
.
variableLimit
)
)
{
let
rows
=
await
db
.
execute
(
SELECT
DISTINCT
p
.
guid
FROM
moz_places
p
JOIN
moz_historyvisits
v
ON
p
.
id
=
v
.
place_id
WHERE
p
.
guid
IN
(
{
new
Array
(
chunk
.
length
)
.
fill
(
"
?
"
)
.
join
(
"
"
)
}
)
AND
(
p
.
hidden
=
1
OR
v
.
visit_type
IN
(
{
IGNORED_TRANSITIONS_AS_SQL_LIST
}
)
)
chunk
)
;
nonSyncableGuids
=
nonSyncableGuids
.
concat
(
rows
.
map
(
row
=
>
row
.
getResultByName
(
"
guid
"
)
)
)
;
}
return
nonSyncableGuids
;
}
changeGuid
(
uri
guid
)
{
let
canonicalURL
=
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
url
(
uri
)
;
let
validatedGuid
=
PlacesUtils
.
BOOKMARK_VALIDATORS
.
guid
(
guid
)
;
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesSyncUtils
.
history
:
changeGuid
"
async
function
(
db
)
{
await
db
.
executeCached
(
UPDATE
moz_places
SET
guid
=
:
guid
WHERE
url_hash
=
hash
(
:
page_url
)
AND
url
=
:
page_url
{
guid
:
validatedGuid
page_url
:
canonicalURL
.
href
}
)
;
}
)
;
}
async
fetchVisitsForURL
(
url
)
{
let
canonicalURL
=
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
url
(
url
)
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
visit_type
type
visit_date
date
FROM
moz_historyvisits
JOIN
moz_places
h
ON
h
.
id
=
place_id
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
ORDER
BY
date
DESC
LIMIT
20
{
url
:
canonicalURL
.
href
}
)
;
return
rows
.
map
(
row
=
>
{
let
visitDate
=
row
.
getResultByName
(
"
date
"
)
;
let
visitType
=
row
.
getResultByName
(
"
type
"
)
;
return
{
date
:
visitDate
type
:
visitType
}
;
}
)
;
}
async
fetchGuidForURL
(
url
)
{
let
canonicalURL
=
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
url
(
url
)
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
guid
FROM
moz_places
WHERE
url_hash
=
hash
(
:
page_url
)
AND
url
=
:
page_url
{
page_url
:
canonicalURL
.
href
}
)
;
if
(
!
rows
.
length
)
{
return
null
;
}
return
rows
[
0
]
.
getResultByName
(
"
guid
"
)
;
}
async
fetchURLInfoForGuid
(
guid
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
url
IFNULL
(
title
'
'
)
AS
title
frecency
FROM
moz_places
WHERE
guid
=
:
guid
{
guid
}
)
;
if
(
rows
.
length
=
=
=
0
)
{
return
null
;
}
return
{
url
:
rows
[
0
]
.
getResultByName
(
"
url
"
)
title
:
rows
[
0
]
.
getResultByName
(
"
title
"
)
frecency
:
rows
[
0
]
.
getResultByName
(
"
frecency
"
)
}
;
}
async
getAllURLs
(
options
)
{
if
(
!
Number
.
isFinite
(
options
.
limit
)
)
{
throw
new
Error
(
"
The
number
provided
in
options
.
limit
is
not
finite
.
"
)
;
}
if
(
!
options
.
since
|
|
Object
.
prototype
.
toString
.
call
(
options
.
since
)
!
=
"
[
object
Date
]
"
)
{
throw
new
Error
(
"
The
property
since
of
the
options
object
must
be
of
type
Date
.
"
)
;
}
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
sinceInMicroseconds
=
PlacesUtils
.
toPRTime
(
options
.
since
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
DISTINCT
p
.
url
FROM
moz_places
p
JOIN
moz_historyvisits
v
ON
p
.
id
=
v
.
place_id
WHERE
p
.
last_visit_date
>
:
cutoff_date
AND
p
.
hidden
=
0
AND
v
.
visit_type
NOT
IN
(
{
IGNORED_TRANSITIONS_AS_SQL_LIST
}
)
ORDER
BY
frecency
DESC
LIMIT
:
max_results
{
cutoff_date
:
sinceInMicroseconds
max_results
:
options
.
limit
}
)
;
return
rows
.
map
(
row
=
>
row
.
getResultByName
(
"
url
"
)
)
;
}
}
)
)
;
const
BookmarkSyncUtils
=
(
PlacesSyncUtils
.
bookmarks
=
Object
.
freeze
(
{
SYNC_PARENT_ANNO
:
"
sync
/
parent
"
SYNC_ID_META_KEY
:
"
sync
/
bookmarks
/
syncId
"
LAST_SYNC_META_KEY
:
"
sync
/
bookmarks
/
lastSync
"
WIPE_REMOTE_META_KEY
:
"
sync
/
bookmarks
/
wipeRemote
"
EARLIEST_BOOKMARK_TIMESTAMP
:
Date
.
UTC
(
1993
0
23
)
KINDS
:
{
BOOKMARK
:
"
bookmark
"
QUERY
:
"
query
"
FOLDER
:
"
folder
"
LIVEMARK
:
"
livemark
"
SEPARATOR
:
"
separator
"
}
get
ROOTS
(
)
{
return
ROOTS
;
}
getSyncId
(
)
{
return
PlacesUtils
.
metadata
.
get
(
BookmarkSyncUtils
.
SYNC_ID_META_KEY
"
"
)
;
}
async
shouldWipeRemote
(
)
{
let
shouldWipeRemote
=
await
PlacesUtils
.
metadata
.
get
(
BookmarkSyncUtils
.
WIPE_REMOTE_META_KEY
false
)
;
return
!
!
shouldWipeRemote
;
}
resetSyncId
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
resetSyncId
"
function
(
db
)
{
let
newSyncId
=
PlacesUtils
.
history
.
makeGuid
(
)
;
return
db
.
executeTransaction
(
async
function
(
)
{
await
setBookmarksSyncId
(
db
newSyncId
)
;
await
resetAllSyncStatuses
(
db
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NEW
)
;
return
newSyncId
;
}
)
;
}
)
;
}
async
ensureCurrentSyncId
(
newSyncId
)
{
if
(
!
newSyncId
|
|
typeof
newSyncId
!
=
"
string
"
)
{
throw
new
TypeError
(
"
Invalid
new
bookmarks
sync
ID
"
)
;
}
await
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
ensureCurrentSyncId
"
async
function
(
db
)
{
let
existingSyncId
=
await
PlacesUtils
.
metadata
.
getWithConnection
(
db
BookmarkSyncUtils
.
SYNC_ID_META_KEY
"
"
)
;
if
(
!
existingSyncId
)
{
BookmarkSyncLog
.
info
(
"
Taking
new
bookmarks
sync
ID
"
{
newSyncId
}
)
;
await
db
.
executeTransaction
(
(
)
=
>
setBookmarksSyncId
(
db
newSyncId
)
)
;
return
;
}
if
(
existingSyncId
=
=
newSyncId
)
{
BookmarkSyncLog
.
trace
(
"
Bookmarks
sync
ID
up
-
to
-
date
"
{
existingSyncId
}
)
;
return
;
}
BookmarkSyncLog
.
info
(
"
Bookmarks
sync
ID
changed
;
resetting
sync
statuses
"
{
existingSyncId
newSyncId
}
)
;
await
db
.
executeTransaction
(
async
function
(
)
{
await
setBookmarksSyncId
(
db
newSyncId
)
;
await
resetAllSyncStatuses
(
db
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
UNKNOWN
)
;
}
)
;
}
)
;
}
async
getLastSync
(
)
{
let
lastSync
=
await
PlacesUtils
.
metadata
.
get
(
BookmarkSyncUtils
.
LAST_SYNC_META_KEY
0
)
;
return
lastSync
/
1000
;
}
async
setLastSync
(
lastSyncSeconds
)
{
let
lastSync
=
Math
.
floor
(
lastSyncSeconds
*
1000
)
;
if
(
!
Number
.
isInteger
(
lastSync
)
)
{
throw
new
TypeError
(
"
Invalid
bookmarks
last
sync
timestamp
"
)
;
}
await
PlacesUtils
.
metadata
.
set
(
BookmarkSyncUtils
.
LAST_SYNC_META_KEY
lastSync
)
;
}
async
resetSyncMetadata
(
db
source
)
{
if
(
!
[
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE_ON_STARTUP
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
]
.
includes
(
source
)
)
{
return
;
}
await
PlacesUtils
.
metadata
.
deleteWithConnection
(
db
BookmarkSyncUtils
.
SYNC_ID_META_KEY
BookmarkSyncUtils
.
LAST_SYNC_META_KEY
)
;
await
PlacesUtils
.
metadata
.
setWithConnection
(
db
BookmarkSyncUtils
.
WIPE_REMOTE_META_KEY
source
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE
)
;
let
syncStatus
=
source
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE_ON_STARTUP
?
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
UNKNOWN
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NEW
;
await
resetAllSyncStatuses
(
db
syncStatus
)
;
}
guidToRecordId
(
guid
)
{
return
ROOT_GUID_TO_RECORD_ID
[
guid
]
|
|
guid
;
}
recordIdToGuid
(
recordId
)
{
return
ROOT_RECORD_ID_TO_GUID
[
recordId
]
|
|
recordId
;
}
fetchChildRecordIds
(
parentRecordId
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
recordId
(
parentRecordId
)
;
let
parentGuid
=
BookmarkSyncUtils
.
recordIdToGuid
(
parentRecordId
)
;
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
fetchChildRecordIds
"
async
function
(
db
)
{
let
childGuids
=
await
fetchChildGuids
(
db
parentGuid
)
;
return
childGuids
.
map
(
guid
=
>
BookmarkSyncUtils
.
guidToRecordId
(
guid
)
)
;
}
)
;
}
migrateOldTrackerEntries
(
entries
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
migrateOldTrackerEntries
"
function
(
db
)
{
return
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
executeCached
(
WITH
RECURSIVE
syncedItems
(
id
)
AS
(
SELECT
b
.
id
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
'
menu________
'
'
toolbar_____
'
'
unfiled_____
'
'
mobile______
'
)
UNION
ALL
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
syncedItems
s
ON
b
.
parent
=
s
.
id
)
UPDATE
moz_bookmarks
SET
syncStatus
=
:
syncStatus
syncChangeCounter
=
0
WHERE
id
IN
syncedItems
{
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_bookmarks_deleted
)
;
await
db
.
executeCached
(
CREATE
TEMP
TABLE
moz_bookmarks_tracked
(
guid
TEXT
PRIMARY
KEY
time
INTEGER
)
)
;
try
{
for
(
let
{
recordId
modified
}
of
entries
)
{
let
guid
=
BookmarkSyncUtils
.
recordIdToGuid
(
recordId
)
;
if
(
!
PlacesUtils
.
isValidGuid
(
guid
)
)
{
BookmarkSyncLog
.
warn
(
migrateOldTrackerEntries
:
Ignoring
+
change
for
invalid
item
{
guid
}
)
;
continue
;
}
let
time
=
PlacesUtils
.
toPRTime
(
Number
.
isFinite
(
modified
)
?
modified
:
Date
.
now
(
)
)
;
await
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
moz_bookmarks_tracked
(
guid
time
)
VALUES
(
:
guid
:
time
)
{
guid
time
}
)
;
}
await
db
.
executeCached
(
INSERT
OR
REPLACE
INTO
moz_bookmarks
(
id
fk
type
parent
position
title
dateAdded
lastModified
guid
syncChangeCounter
syncStatus
)
SELECT
b
.
id
b
.
fk
b
.
type
b
.
parent
b
.
position
b
.
title
b
.
dateAdded
MAX
(
b
.
lastModified
t
.
time
)
b
.
guid
b
.
syncChangeCounter
+
1
b
.
syncStatus
FROM
moz_bookmarks
b
JOIN
moz_bookmarks_tracked
t
ON
b
.
guid
=
t
.
guid
)
;
await
db
.
executeCached
(
INSERT
OR
REPLACE
INTO
moz_bookmarks_deleted
(
guid
dateRemoved
)
SELECT
t
.
guid
MAX
(
IFNULL
(
(
SELECT
dateRemoved
FROM
moz_bookmarks_deleted
WHERE
guid
=
t
.
guid
)
0
)
t
.
time
)
FROM
moz_bookmarks_tracked
t
LEFT
JOIN
moz_bookmarks
b
ON
t
.
guid
=
b
.
guid
WHERE
b
.
guid
IS
NULL
)
;
}
finally
{
await
db
.
executeCached
(
DROP
TABLE
moz_bookmarks_tracked
)
;
}
}
)
;
}
)
;
}
order
(
parentRecordId
childRecordIds
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
recordId
(
parentRecordId
)
;
if
(
!
childRecordIds
.
length
)
{
return
undefined
;
}
let
parentGuid
=
BookmarkSyncUtils
.
recordIdToGuid
(
parentRecordId
)
;
if
(
parentGuid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
)
{
return
undefined
;
}
let
orderedChildrenGuids
=
childRecordIds
.
map
(
BookmarkSyncUtils
.
recordIdToGuid
)
;
return
PlacesUtils
.
bookmarks
.
reorder
(
parentGuid
orderedChildrenGuids
{
source
:
SOURCE_SYNC
}
)
;
}
havePendingChanges
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
havePendingChanges
"
async
function
(
db
)
{
let
rows
=
await
db
.
executeCached
(
WITH
RECURSIVE
syncedItems
(
id
guid
syncChangeCounter
)
AS
(
SELECT
b
.
id
b
.
guid
b
.
syncChangeCounter
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
'
menu________
'
'
toolbar_____
'
'
unfiled_____
'
'
mobile______
'
)
UNION
ALL
SELECT
b
.
id
b
.
guid
b
.
syncChangeCounter
FROM
moz_bookmarks
b
JOIN
syncedItems
s
ON
b
.
parent
=
s
.
id
)
changedItems
(
guid
)
AS
(
SELECT
guid
FROM
syncedItems
WHERE
syncChangeCounter
>
=
1
UNION
ALL
SELECT
guid
FROM
moz_bookmarks_deleted
)
SELECT
EXISTS
(
SELECT
guid
FROM
changedItems
)
AS
haveChanges
)
;
return
!
!
rows
[
0
]
.
getResultByName
(
"
haveChanges
"
)
;
}
)
;
}
pullChanges
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
pullChanges
"
pullSyncChanges
)
;
}
markChangesAsSyncing
(
changeRecords
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
markChangesAsSyncing
"
db
=
>
markChangesAsSyncing
(
db
changeRecords
)
)
;
}
pushChanges
(
changeRecords
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
pushChanges
"
async
function
(
db
)
{
let
skippedCount
=
0
;
let
weakCount
=
0
;
let
updateParams
=
[
]
;
let
tombstoneGuidsToRemove
=
[
]
;
for
(
let
recordId
in
changeRecords
)
{
let
changeRecord
=
validateChangeRecord
(
"
BookmarkSyncUtils
:
pushChanges
"
changeRecords
[
recordId
]
{
tombstone
:
{
required
:
true
}
counter
:
{
required
:
true
}
synced
:
{
required
:
true
}
}
)
;
if
(
!
changeRecord
.
counter
)
{
weakCount
+
+
;
continue
;
}
if
(
!
changeRecord
.
synced
)
{
skippedCount
+
+
;
continue
;
}
let
guid
=
BookmarkSyncUtils
.
recordIdToGuid
(
recordId
)
;
if
(
changeRecord
.
tombstone
)
{
tombstoneGuidsToRemove
.
push
(
guid
)
;
}
else
{
updateParams
.
push
(
{
guid
syncChangeDelta
:
changeRecord
.
counter
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
)
;
}
}
if
(
updateParams
.
length
|
|
tombstoneGuidsToRemove
.
length
)
{
await
db
.
executeTransaction
(
async
function
(
)
{
if
(
updateParams
.
length
)
{
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
MAX
(
syncChangeCounter
-
:
syncChangeDelta
0
)
syncStatus
=
:
syncStatus
WHERE
guid
=
:
guid
updateParams
)
;
let
dupedGuids
=
updateParams
.
map
(
(
{
guid
}
)
=
>
guid
)
;
await
removeUndeletedTombstones
(
db
dupedGuids
)
;
}
await
removeTombstones
(
db
tombstoneGuidsToRemove
)
;
}
)
;
}
BookmarkSyncLog
.
debug
(
pushChanges
:
Processed
change
records
{
weak
:
weakCount
skipped
:
skippedCount
updated
:
updateParams
.
length
}
)
;
}
)
;
}
remove
(
recordIds
)
{
if
(
!
recordIds
.
length
)
{
return
null
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
remove
"
async
function
(
db
)
{
let
folderGuids
=
[
]
;
for
(
let
recordId
of
recordIds
)
{
if
(
recordId
in
ROOT_RECORD_ID_TO_GUID
)
{
BookmarkSyncLog
.
warn
(
remove
:
Refusing
to
remove
root
{
recordId
}
)
;
continue
;
}
let
guid
=
BookmarkSyncUtils
.
recordIdToGuid
(
recordId
)
;
let
bookmarkItem
=
await
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
;
if
(
!
bookmarkItem
)
{
BookmarkSyncLog
.
trace
(
remove
:
Item
{
guid
}
already
removed
)
;
continue
;
}
let
kind
=
await
getKindForItem
(
db
bookmarkItem
)
;
if
(
kind
=
=
BookmarkSyncUtils
.
KINDS
.
FOLDER
)
{
folderGuids
.
push
(
bookmarkItem
.
guid
)
;
continue
;
}
let
wasRemoved
=
await
deleteSyncedAtom
(
bookmarkItem
)
;
if
(
wasRemoved
)
{
BookmarkSyncLog
.
trace
(
remove
:
Removed
item
{
guid
}
with
kind
{
kind
}
)
;
}
}
for
(
let
guid
of
folderGuids
)
{
let
bookmarkItem
=
await
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
;
if
(
!
bookmarkItem
)
{
BookmarkSyncLog
.
trace
(
remove
:
Folder
{
guid
}
already
removed
)
;
continue
;
}
let
wasRemoved
=
await
deleteSyncedFolder
(
db
bookmarkItem
)
;
if
(
wasRemoved
)
{
BookmarkSyncLog
.
trace
(
remove
:
Removed
folder
{
bookmarkItem
.
guid
}
)
;
}
}
return
pullSyncChanges
(
db
)
;
}
)
;
}
isRootRecordID
(
id
)
{
return
ROOT_RECORD_ID_TO_GUID
.
hasOwnProperty
(
id
)
;
}
wipe
(
)
{
return
PlacesUtils
.
bookmarks
.
eraseEverything
(
{
source
:
SOURCE_SYNC
}
)
;
}
reset
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
reset
"
function
(
db
)
{
return
db
.
executeTransaction
(
async
function
(
)
{
await
BookmarkSyncUtils
.
resetSyncMetadata
(
db
SOURCE_SYNC
)
;
}
)
;
}
)
;
}
async
fetch
(
recordId
)
{
let
guid
=
BookmarkSyncUtils
.
recordIdToGuid
(
recordId
)
;
let
bookmarkItem
=
await
PlacesUtils
.
bookmarks
.
fetch
(
guid
)
;
if
(
!
bookmarkItem
)
{
return
null
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
fetch
"
async
function
(
db
)
{
let
kind
=
await
getKindForItem
(
db
bookmarkItem
)
;
let
item
;
switch
(
kind
)
{
case
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
:
item
=
await
fetchBookmarkItem
(
db
bookmarkItem
)
;
break
;
case
BookmarkSyncUtils
.
KINDS
.
QUERY
:
item
=
await
fetchQueryItem
(
db
bookmarkItem
)
;
break
;
case
BookmarkSyncUtils
.
KINDS
.
FOLDER
:
item
=
await
fetchFolderItem
(
db
bookmarkItem
)
;
break
;
case
BookmarkSyncUtils
.
KINDS
.
SEPARATOR
:
item
=
await
placesBookmarkToSyncBookmark
(
db
bookmarkItem
)
;
item
.
index
=
bookmarkItem
.
index
;
break
;
default
:
throw
new
Error
(
Unknown
bookmark
kind
:
{
kind
}
)
;
}
if
(
bookmarkItem
.
parentGuid
)
{
let
parent
=
await
PlacesUtils
.
bookmarks
.
fetch
(
bookmarkItem
.
parentGuid
)
;
item
.
parentTitle
=
parent
.
title
|
|
"
"
;
}
return
item
;
}
)
;
}
determineSyncChangeDelta
(
source
)
{
return
source
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
?
0
:
1
;
}
determineInitialSyncStatus
(
source
)
{
if
(
source
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
)
{
return
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
;
}
if
(
source
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE_ON_STARTUP
)
{
return
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
UNKNOWN
;
}
return
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NEW
;
}
addSyncChangesForBookmarksWithURL
(
db
url
syncChangeDelta
)
{
if
(
!
url
|
|
!
syncChangeDelta
)
{
return
Promise
.
resolve
(
)
;
}
return
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
:
syncChangeDelta
WHERE
type
=
:
type
AND
fk
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
{
syncChangeDelta
type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
url
:
url
.
href
}
)
;
}
async
removeLivemark
(
livemarkInfo
)
{
let
info
=
validateSyncBookmarkObject
(
"
BookmarkSyncUtils
:
removeLivemark
"
livemarkInfo
{
kind
:
{
required
:
true
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
}
recordId
:
{
required
:
true
}
parentRecordId
:
{
required
:
true
}
}
)
;
let
guid
=
BookmarkSyncUtils
.
recordIdToGuid
(
info
.
recordId
)
;
let
parentGuid
=
BookmarkSyncUtils
.
recordIdToGuid
(
info
.
parentRecordId
)
;
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
removeLivemark
"
async
function
(
db
)
{
if
(
await
GUIDMissing
(
guid
)
)
{
await
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
1
WHERE
guid
=
:
parentGuid
{
parentGuid
}
)
;
await
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
moz_bookmarks_deleted
(
guid
dateRemoved
)
VALUES
(
:
guid
{
PlacesUtils
.
toPRTime
(
Date
.
now
(
)
)
}
)
{
guid
}
)
;
}
)
;
}
else
{
await
PlacesUtils
.
bookmarks
.
remove
(
{
guid
source
:
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC_REPARENT_REMOVED_FOLDER_CHILDREN
}
)
;
}
return
pullSyncChanges
(
db
[
guid
parentGuid
]
)
;
}
)
;
}
ratchetTimestampBackwards
(
existingMillis
serverMillis
lowerBound
=
BookmarkSyncUtils
.
EARLIEST_BOOKMARK_TIMESTAMP
)
{
const
possible
=
[
+
existingMillis
+
serverMillis
]
.
filter
(
n
=
>
!
isNaN
(
n
)
&
&
n
>
lowerBound
)
;
if
(
!
possible
.
length
)
{
return
0
;
}
return
Math
.
min
(
.
.
.
possible
)
;
}
async
ensureMobileQuery
(
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
mobileChildGuids
=
await
fetchChildGuids
(
db
PlacesUtils
.
bookmarks
.
mobileGuid
)
;
let
hasMobileBookmarks
=
!
!
mobileChildGuids
.
length
;
Services
.
prefs
.
setBoolPref
(
MOBILE_BOOKMARKS_PREF
hasMobileBookmarks
)
;
}
async
fetchGuidsWithAnno
(
anno
val
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
return
fetchGuidsWithAnno
(
db
anno
val
)
;
}
}
)
)
;
PlacesSyncUtils
.
test
=
{
}
;
PlacesSyncUtils
.
test
.
bookmarks
=
Object
.
freeze
(
{
insert
(
info
)
{
let
insertInfo
=
validateNewBookmark
(
"
BookmarkTestUtils
:
insert
"
info
)
;
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkTestUtils
:
insert
"
async
db
=
>
{
insertInfo
=
await
updateTagQueryFolder
(
db
insertInfo
)
;
let
bookmarkInfo
=
syncBookmarkToPlacesBookmark
(
insertInfo
)
;
let
bookmarkItem
=
await
PlacesUtils
.
bookmarks
.
insert
(
bookmarkInfo
)
;
let
newItem
=
await
insertBookmarkMetadata
(
db
bookmarkItem
insertInfo
)
;
return
newItem
;
}
)
;
}
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
HistorySyncLog
"
(
)
=
>
{
return
Log
.
repository
.
getLogger
(
"
Sync
.
Engine
.
History
.
HistorySyncUtils
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
BookmarkSyncLog
"
(
)
=
>
{
return
Log
.
repository
.
getLogger
(
"
Sync
.
Engine
.
Bookmarks
.
BookmarkSyncUtils
"
)
;
}
)
;
function
validateSyncBookmarkObject
(
name
input
behavior
)
{
return
PlacesUtils
.
validateItemProperties
(
name
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
input
behavior
)
;
}
function
validateChangeRecord
(
name
changeRecord
behavior
)
{
return
PlacesUtils
.
validateItemProperties
(
name
PlacesUtils
.
SYNC_CHANGE_RECORD_VALIDATORS
changeRecord
behavior
)
;
}
var
fetchChildGuids
=
async
function
(
db
parentGuid
)
{
let
rows
=
await
db
.
executeCached
(
SELECT
guid
FROM
moz_bookmarks
WHERE
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
:
parentGuid
)
ORDER
BY
position
{
parentGuid
}
)
;
return
rows
.
map
(
row
=
>
row
.
getResultByName
(
"
guid
"
)
)
;
}
;
var
GUIDMissing
=
async
function
(
guid
)
{
try
{
await
PlacesUtils
.
promiseItemId
(
guid
)
;
return
false
;
}
catch
(
ex
)
{
if
(
ex
.
message
=
=
"
no
item
found
for
the
given
GUID
"
)
{
return
true
;
}
throw
ex
;
}
}
;
function
updateTagQueryFolder
(
db
info
)
{
if
(
info
.
kind
!
=
BookmarkSyncUtils
.
KINDS
.
QUERY
|
|
!
info
.
folder
|
|
!
info
.
url
|
|
info
.
url
.
protocol
!
=
"
place
:
"
)
{
return
info
;
}
let
params
=
new
URLSearchParams
(
info
.
url
.
pathname
)
;
let
type
=
+
params
.
get
(
"
type
"
)
;
if
(
type
!
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAG_CONTENTS
)
{
return
info
;
}
BookmarkSyncLog
.
debug
(
updateTagQueryFolder
:
Tag
query
folder
:
{
info
.
folder
}
)
;
params
.
delete
(
"
queryType
"
)
;
params
.
delete
(
"
type
"
)
;
params
.
delete
(
"
folder
"
)
;
params
.
set
(
"
tag
"
info
.
folder
)
;
info
.
url
=
new
URL
(
info
.
url
.
protocol
+
params
)
;
return
info
;
}
function
removeConflictingKeywords
(
bookmarkURL
newKeyword
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
removeConflictingKeywords
"
async
function
(
db
)
{
let
entryForURL
=
await
PlacesUtils
.
keywords
.
fetch
(
{
url
:
bookmarkURL
.
href
}
)
;
if
(
entryForURL
&
&
entryForURL
.
keyword
!
=
=
newKeyword
)
{
await
PlacesUtils
.
keywords
.
remove
(
{
keyword
:
entryForURL
.
keyword
source
:
SOURCE_SYNC
}
)
;
await
BookmarkSyncUtils
.
addSyncChangesForBookmarksWithURL
(
db
entryForURL
.
url
1
)
;
}
if
(
!
newKeyword
)
{
return
;
}
let
entryForNewKeyword
=
await
PlacesUtils
.
keywords
.
fetch
(
{
keyword
:
newKeyword
}
)
;
if
(
entryForNewKeyword
)
{
await
PlacesUtils
.
keywords
.
remove
(
{
keyword
:
entryForNewKeyword
.
keyword
source
:
SOURCE_SYNC
}
)
;
await
BookmarkSyncUtils
.
addSyncChangesForBookmarksWithURL
(
db
entryForNewKeyword
.
url
1
)
;
}
}
)
;
}
async
function
insertBookmarkMetadata
(
db
bookmarkItem
insertInfo
)
{
let
newItem
=
await
placesBookmarkToSyncBookmark
(
db
bookmarkItem
)
;
try
{
newItem
.
tags
=
tagItem
(
bookmarkItem
insertInfo
.
tags
)
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
warn
(
insertBookmarkMetadata
:
Error
tagging
item
{
insertInfo
.
recordId
}
ex
)
;
}
if
(
insertInfo
.
keyword
)
{
await
removeConflictingKeywords
(
bookmarkItem
.
url
insertInfo
.
keyword
)
;
await
PlacesUtils
.
keywords
.
insert
(
{
keyword
:
insertInfo
.
keyword
url
:
bookmarkItem
.
url
.
href
source
:
SOURCE_SYNC
}
)
;
newItem
.
keyword
=
insertInfo
.
keyword
;
}
return
newItem
;
}
async
function
getKindForItem
(
db
item
)
{
switch
(
item
.
type
)
{
case
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
:
{
return
BookmarkSyncUtils
.
KINDS
.
FOLDER
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
:
return
item
.
url
.
protocol
=
=
"
place
:
"
?
BookmarkSyncUtils
.
KINDS
.
QUERY
:
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
;
case
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
:
return
BookmarkSyncUtils
.
KINDS
.
SEPARATOR
;
}
return
null
;
}
function
getTypeForKind
(
kind
)
{
switch
(
kind
)
{
case
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
:
case
BookmarkSyncUtils
.
KINDS
.
QUERY
:
return
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
;
case
BookmarkSyncUtils
.
KINDS
.
FOLDER
:
return
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
;
case
BookmarkSyncUtils
.
KINDS
.
SEPARATOR
:
return
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
;
}
throw
new
Error
(
Unknown
bookmark
kind
:
{
kind
}
)
;
}
function
validateNewBookmark
(
name
info
)
{
let
insertInfo
=
validateSyncBookmarkObject
(
name
info
{
kind
:
{
required
:
true
}
recordId
:
{
required
:
true
}
url
:
{
requiredIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
parentRecordId
:
{
required
:
true
}
title
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
QUERY
BookmarkSyncUtils
.
KINDS
.
FOLDER
]
.
includes
(
b
.
kind
)
|
|
b
.
title
=
=
=
"
"
}
query
:
{
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
QUERY
}
folder
:
{
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
QUERY
}
tags
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
keyword
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
dateAdded
:
{
required
:
false
}
}
)
;
return
insertInfo
;
}
async
function
fetchGuidsWithAnno
(
db
anno
val
)
{
let
rows
=
await
db
.
executeCached
(
SELECT
b
.
guid
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
n
.
id
=
a
.
anno_attribute_id
JOIN
moz_bookmarks
b
ON
b
.
id
=
a
.
item_id
WHERE
n
.
name
=
:
anno
AND
a
.
content
=
:
val
{
anno
val
}
)
;
return
rows
.
map
(
row
=
>
row
.
getResultByName
(
"
guid
"
)
)
;
}
function
tagItem
(
item
tags
)
{
if
(
!
item
.
url
)
{
return
[
]
;
}
let
newTags
=
tags
?
tags
.
map
(
tag
=
>
tag
.
trim
(
)
)
.
filter
(
Boolean
)
:
[
]
;
let
dummyURI
=
PlacesUtils
.
toURI
(
"
about
:
weave
#
BStore_tagURI
"
)
;
let
bookmarkURI
=
PlacesUtils
.
toURI
(
item
.
url
.
href
)
;
if
(
newTags
&
&
newTags
.
length
)
{
PlacesUtils
.
tagging
.
tagURI
(
dummyURI
newTags
SOURCE_SYNC
)
;
}
PlacesUtils
.
tagging
.
untagURI
(
bookmarkURI
null
SOURCE_SYNC
)
;
if
(
newTags
&
&
newTags
.
length
)
{
PlacesUtils
.
tagging
.
tagURI
(
bookmarkURI
newTags
SOURCE_SYNC
)
;
}
PlacesUtils
.
tagging
.
untagURI
(
dummyURI
null
SOURCE_SYNC
)
;
return
newTags
;
}
async
function
placesBookmarkToSyncBookmark
(
db
bookmarkItem
)
{
let
item
=
{
}
;
for
(
let
prop
in
bookmarkItem
)
{
switch
(
prop
)
{
case
"
guid
"
:
item
.
recordId
=
BookmarkSyncUtils
.
guidToRecordId
(
bookmarkItem
.
guid
)
;
break
;
case
"
parentGuid
"
:
item
.
parentRecordId
=
BookmarkSyncUtils
.
guidToRecordId
(
bookmarkItem
.
parentGuid
)
;
break
;
case
"
type
"
:
item
.
kind
=
await
getKindForItem
(
db
bookmarkItem
)
;
break
;
case
"
title
"
:
case
"
url
"
:
item
[
prop
]
=
bookmarkItem
[
prop
]
;
break
;
case
"
dateAdded
"
:
item
[
prop
]
=
new
Date
(
bookmarkItem
[
prop
]
)
.
getTime
(
)
;
break
;
}
}
return
item
;
}
function
syncBookmarkToPlacesBookmark
(
info
)
{
let
bookmarkInfo
=
{
source
:
SOURCE_SYNC
}
;
for
(
let
prop
in
info
)
{
switch
(
prop
)
{
case
"
kind
"
:
bookmarkInfo
.
type
=
getTypeForKind
(
info
.
kind
)
;
break
;
case
"
recordId
"
:
bookmarkInfo
.
guid
=
BookmarkSyncUtils
.
recordIdToGuid
(
info
.
recordId
)
;
break
;
case
"
dateAdded
"
:
bookmarkInfo
.
dateAdded
=
new
Date
(
info
.
dateAdded
)
;
break
;
case
"
parentRecordId
"
:
bookmarkInfo
.
parentGuid
=
BookmarkSyncUtils
.
recordIdToGuid
(
info
.
parentRecordId
)
;
bookmarkInfo
.
index
=
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
;
break
;
case
"
title
"
:
case
"
url
"
:
bookmarkInfo
[
prop
]
=
info
[
prop
]
;
break
;
}
}
return
bookmarkInfo
;
}
var
fetchBookmarkItem
=
async
function
(
db
bookmarkItem
)
{
let
item
=
await
placesBookmarkToSyncBookmark
(
db
bookmarkItem
)
;
if
(
!
item
.
title
)
{
item
.
title
=
"
"
;
}
item
.
tags
=
PlacesUtils
.
tagging
.
getTagsForURI
(
PlacesUtils
.
toURI
(
bookmarkItem
.
url
)
)
;
let
keywordEntry
=
await
PlacesUtils
.
keywords
.
fetch
(
{
url
:
bookmarkItem
.
url
}
)
;
if
(
keywordEntry
)
{
item
.
keyword
=
keywordEntry
.
keyword
;
}
return
item
;
}
;
async
function
fetchFolderItem
(
db
bookmarkItem
)
{
let
item
=
await
placesBookmarkToSyncBookmark
(
db
bookmarkItem
)
;
if
(
!
item
.
title
)
{
item
.
title
=
"
"
;
}
let
childGuids
=
await
fetchChildGuids
(
db
bookmarkItem
.
guid
)
;
item
.
childRecordIds
=
childGuids
.
map
(
guid
=
>
BookmarkSyncUtils
.
guidToRecordId
(
guid
)
)
;
return
item
;
}
async
function
fetchQueryItem
(
db
bookmarkItem
)
{
let
item
=
await
placesBookmarkToSyncBookmark
(
db
bookmarkItem
)
;
let
params
=
new
URLSearchParams
(
bookmarkItem
.
url
.
pathname
)
;
let
tags
=
params
.
getAll
(
"
tag
"
)
;
if
(
tags
.
length
=
=
1
)
{
item
.
folder
=
tags
[
0
]
;
}
return
item
;
}
function
addRowToChangeRecords
(
row
changeRecords
)
{
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
if
(
!
guid
)
{
throw
new
Error
(
Changed
item
missing
GUID
)
;
}
let
isTombstone
=
!
!
row
.
getResultByName
(
"
tombstone
"
)
;
let
recordId
=
BookmarkSyncUtils
.
guidToRecordId
(
guid
)
;
if
(
recordId
in
changeRecords
)
{
let
existingRecord
=
changeRecords
[
recordId
]
;
if
(
existingRecord
.
tombstone
=
=
isTombstone
)
{
throw
new
Error
(
Duplicate
item
or
tombstone
{
recordId
}
in
changeset
)
;
}
if
(
!
existingRecord
.
tombstone
&
&
isTombstone
)
{
BookmarkSyncLog
.
warn
(
"
addRowToChangeRecords
:
Ignoring
tombstone
for
undeleted
item
"
recordId
)
;
return
;
}
BookmarkSyncLog
.
warn
(
"
addRowToChangeRecords
:
Replacing
tombstone
for
undeleted
item
"
recordId
)
;
}
let
modifiedAsPRTime
=
row
.
getResultByName
(
"
modified
"
)
;
let
modified
=
modifiedAsPRTime
/
MICROSECONDS_PER_SECOND
;
if
(
Number
.
isNaN
(
modified
)
|
|
modified
<
=
0
)
{
BookmarkSyncLog
.
error
(
"
addRowToChangeRecords
:
Invalid
modified
date
for
"
+
recordId
modifiedAsPRTime
)
;
modified
=
0
;
}
changeRecords
[
recordId
]
=
{
modified
counter
:
row
.
getResultByName
(
"
syncChangeCounter
"
)
status
:
row
.
getResultByName
(
"
syncStatus
"
)
tombstone
:
isTombstone
synced
:
false
}
;
}
var
pullSyncChanges
=
async
function
(
db
forGuids
=
[
]
)
{
let
changeRecords
=
{
}
;
let
itemConditions
=
[
"
syncChangeCounter
>
=
1
"
]
;
let
tombstoneConditions
=
[
"
1
=
1
"
]
;
if
(
forGuids
.
length
)
{
let
restrictToGuids
=
guid
IN
(
{
forGuids
.
map
(
guid
=
>
JSON
.
stringify
(
guid
)
)
.
join
(
"
"
)
}
)
;
itemConditions
.
push
(
restrictToGuids
)
;
tombstoneConditions
.
push
(
restrictToGuids
)
;
}
let
rows
=
await
db
.
executeCached
(
WITH
RECURSIVE
syncedItems
(
id
guid
modified
syncChangeCounter
syncStatus
)
AS
(
SELECT
b
.
id
b
.
guid
b
.
lastModified
b
.
syncChangeCounter
b
.
syncStatus
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
'
menu________
'
'
toolbar_____
'
'
unfiled_____
'
'
mobile______
'
)
UNION
ALL
SELECT
b
.
id
b
.
guid
b
.
lastModified
b
.
syncChangeCounter
b
.
syncStatus
FROM
moz_bookmarks
b
JOIN
syncedItems
s
ON
b
.
parent
=
s
.
id
)
SELECT
guid
modified
syncChangeCounter
syncStatus
0
AS
tombstone
FROM
syncedItems
WHERE
{
itemConditions
.
join
(
"
AND
"
)
}
UNION
ALL
SELECT
guid
dateRemoved
AS
modified
1
AS
syncChangeCounter
:
deletedSyncStatus
1
AS
tombstone
FROM
moz_bookmarks_deleted
WHERE
{
tombstoneConditions
.
join
(
"
AND
"
)
}
{
deletedSyncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
)
;
for
(
let
row
of
rows
)
{
addRowToChangeRecords
(
row
changeRecords
)
;
}
return
changeRecords
;
}
;
async
function
deleteSyncedFolder
(
db
bookmarkItem
)
{
let
childGuids
=
await
fetchChildGuids
(
db
bookmarkItem
.
guid
)
;
if
(
!
childGuids
.
length
)
{
return
deleteSyncedAtom
(
bookmarkItem
)
;
}
if
(
BookmarkSyncLog
.
level
<
=
Log
.
Level
.
Trace
)
{
BookmarkSyncLog
.
trace
(
deleteSyncedFolder
:
Moving
{
JSON
.
stringify
(
childGuids
)
}
children
of
+
"
{
bookmarkItem
.
guid
}
"
to
grandparent
"
{
BookmarkSyncUtils
.
guidToRecordId
(
bookmarkItem
.
parentGuid
)
}
"
before
+
deletion
)
;
}
for
(
let
guid
of
childGuids
)
{
await
PlacesUtils
.
bookmarks
.
update
(
{
guid
parentGuid
:
bookmarkItem
.
parentGuid
index
:
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
source
:
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC_REPARENT_REMOVED_FOLDER_CHILDREN
}
)
;
}
try
{
await
PlacesUtils
.
bookmarks
.
remove
(
bookmarkItem
.
guid
{
preventRemovalOfNonEmptyFolders
:
true
source
:
SOURCE_SYNC
}
)
;
}
catch
(
e
)
{
BookmarkSyncLog
.
trace
(
deleteSyncedFolder
:
Error
removing
parent
+
{
bookmarkItem
.
guid
}
after
reparenting
children
e
)
;
return
false
;
}
return
true
;
}
var
deleteSyncedAtom
=
async
function
(
bookmarkItem
)
{
try
{
await
PlacesUtils
.
bookmarks
.
remove
(
bookmarkItem
.
guid
{
preventRemovalOfNonEmptyFolders
:
true
source
:
SOURCE_SYNC
}
)
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
trace
(
deleteSyncedAtom
:
Error
removing
+
bookmarkItem
.
guid
ex
)
;
return
false
;
}
return
true
;
}
;
function
markChangesAsSyncing
(
db
changeRecords
)
{
let
unsyncedGuids
=
[
]
;
for
(
let
recordId
in
changeRecords
)
{
if
(
changeRecords
[
recordId
]
.
tombstone
)
{
continue
;
}
if
(
changeRecords
[
recordId
]
.
status
=
=
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
)
{
continue
;
}
let
guid
=
BookmarkSyncUtils
.
recordIdToGuid
(
recordId
)
;
unsyncedGuids
.
push
(
JSON
.
stringify
(
guid
)
)
;
}
if
(
!
unsyncedGuids
.
length
)
{
return
Promise
.
resolve
(
)
;
}
return
db
.
execute
(
UPDATE
moz_bookmarks
SET
syncStatus
=
:
syncStatus
WHERE
guid
IN
(
{
unsyncedGuids
.
join
(
"
"
)
}
)
{
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
)
;
}
var
removeTombstones
=
function
(
db
guids
)
{
if
(
!
guids
.
length
)
{
return
Promise
.
resolve
(
)
;
}
return
db
.
execute
(
DELETE
FROM
moz_bookmarks_deleted
WHERE
guid
IN
(
{
guids
.
map
(
guid
=
>
JSON
.
stringify
(
guid
)
)
.
join
(
"
"
)
}
)
)
;
}
;
var
removeUndeletedTombstones
=
function
(
db
guids
)
{
if
(
!
guids
.
length
)
{
return
Promise
.
resolve
(
)
;
}
return
db
.
execute
(
DELETE
FROM
moz_bookmarks_deleted
WHERE
guid
IN
(
{
guids
.
map
(
guid
=
>
JSON
.
stringify
(
guid
)
)
.
join
(
"
"
)
}
)
AND
guid
IN
(
SELECT
guid
from
moz_bookmarks
)
)
;
}
;
async
function
setHistorySyncId
(
db
newSyncId
)
{
await
PlacesUtils
.
metadata
.
setWithConnection
(
db
HistorySyncUtils
.
SYNC_ID_META_KEY
newSyncId
)
;
await
PlacesUtils
.
metadata
.
deleteWithConnection
(
db
HistorySyncUtils
.
LAST_SYNC_META_KEY
)
;
}
async
function
setBookmarksSyncId
(
db
newSyncId
)
{
await
PlacesUtils
.
metadata
.
setWithConnection
(
db
BookmarkSyncUtils
.
SYNC_ID_META_KEY
newSyncId
)
;
await
PlacesUtils
.
metadata
.
deleteWithConnection
(
db
BookmarkSyncUtils
.
LAST_SYNC_META_KEY
BookmarkSyncUtils
.
WIPE_REMOTE_META_KEY
)
;
}
async
function
resetAllSyncStatuses
(
db
syncStatus
)
{
await
db
.
execute
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
1
syncStatus
=
:
syncStatus
{
syncStatus
}
)
;
await
db
.
execute
(
DELETE
FROM
moz_items_annos
WHERE
anno_attribute_id
=
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
:
orphanAnno
)
{
orphanAnno
:
BookmarkSyncUtils
.
SYNC_PARENT_ANNO
}
)
;
await
db
.
execute
(
"
DELETE
FROM
moz_bookmarks_deleted
"
)
;
}
