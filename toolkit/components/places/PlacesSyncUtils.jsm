"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PlacesSyncUtils
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
Cu
.
importGlobalProperties
(
[
"
URL
"
"
URLSearchParams
"
]
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
var
PlacesSyncUtils
=
{
}
;
const
SMART_BOOKMARKS_ANNO
=
"
Places
/
SmartBookmark
"
;
const
DESCRIPTION_ANNO
=
"
bookmarkProperties
/
description
"
;
const
SIDEBAR_ANNO
=
"
bookmarkProperties
/
loadInSidebar
"
;
const
PARENT_ANNO
=
"
sync
/
parent
"
;
const
{
SOURCE_SYNC
}
=
Ci
.
nsINavBookmarksService
;
const
BookmarkSyncUtils
=
PlacesSyncUtils
.
bookmarks
=
Object
.
freeze
(
{
KINDS
:
{
BOOKMARK
:
"
bookmark
"
MICROSUMMARY
:
"
microsummary
"
QUERY
:
"
query
"
FOLDER
:
"
folder
"
LIVEMARK
:
"
livemark
"
SEPARATOR
:
"
separator
"
}
fetchChildGuids
:
Task
.
async
(
function
*
(
parentGuid
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
guid
(
parentGuid
)
;
let
db
=
yield
PlacesUtils
.
promiseDBConnection
(
)
;
let
children
=
yield
fetchAllChildren
(
db
parentGuid
)
;
let
childGuids
=
[
]
;
let
guidsToSet
=
new
Map
(
)
;
for
(
let
child
of
children
)
{
let
guid
=
child
.
guid
;
if
(
!
PlacesUtils
.
isValidGuid
(
guid
)
)
{
guid
=
yield
generateGuid
(
db
)
;
BookmarkSyncLog
.
warn
(
fetchChildGuids
:
Assigning
{
guid
}
to
item
without
GUID
{
child
.
id
}
)
;
guidsToSet
.
set
(
child
.
id
guid
)
;
}
childGuids
.
push
(
guid
)
;
}
if
(
guidsToSet
.
size
>
0
)
{
yield
setGuids
(
guidsToSet
)
;
}
return
childGuids
;
}
)
order
:
Task
.
async
(
function
*
(
parentGuid
childGuids
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
guid
(
parentGuid
)
;
for
(
let
guid
of
childGuids
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
guid
(
guid
)
;
}
if
(
parentGuid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
)
{
return
Promise
.
resolve
(
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
order
"
Task
.
async
(
function
*
(
db
)
{
let
children
;
yield
db
.
executeTransaction
(
function
*
(
)
{
children
=
yield
fetchAllChildren
(
db
parentGuid
)
;
if
(
!
children
.
length
)
{
return
;
}
for
(
let
child
of
children
)
{
child
.
oldIndex
=
child
.
index
;
}
let
delta
=
0
;
for
(
let
i
=
0
;
i
<
childGuids
.
length
;
+
+
i
)
{
let
guid
=
childGuids
[
i
]
;
let
child
=
findChildByGuid
(
children
guid
)
;
if
(
!
child
)
{
delta
+
+
;
BookmarkSyncLog
.
trace
(
order
:
Ignoring
missing
child
{
guid
}
)
;
continue
;
}
let
newIndex
=
i
-
delta
;
updateChildIndex
(
children
child
newIndex
)
;
}
children
.
sort
(
(
a
b
)
=
>
a
.
index
-
b
.
index
)
;
yield
db
.
executeCached
(
WITH
sorting
(
g
p
)
AS
(
VALUES
{
children
.
map
(
(
child
i
)
=
>
(
"
{
child
.
guid
}
"
{
i
}
)
)
.
join
(
)
}
)
UPDATE
moz_bookmarks
SET
position
=
(
SELECT
p
FROM
sorting
WHERE
g
=
guid
)
WHERE
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
:
parentGuid
)
{
parentGuid
}
)
;
}
)
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
for
(
let
child
of
children
)
{
notify
(
observers
"
onItemMoved
"
[
child
.
id
child
.
parentId
child
.
oldIndex
child
.
parentId
child
.
index
child
.
type
child
.
guid
parentGuid
parentGuid
SOURCE_SYNC
]
)
;
}
}
)
)
;
}
)
remove
:
Task
.
async
(
function
*
(
guid
)
{
return
PlacesUtils
.
bookmarks
.
remove
(
guid
{
source
:
SOURCE_SYNC
}
)
;
}
)
clear
:
Task
.
async
(
function
*
(
folderGuid
)
{
let
folderId
=
yield
PlacesUtils
.
promiseItemId
(
folderGuid
)
;
PlacesUtils
.
bookmarks
.
removeFolderChildren
(
folderId
SOURCE_SYNC
)
;
}
)
ensureGuidForId
:
Task
.
async
(
function
*
(
itemId
)
{
let
guid
;
try
{
guid
=
yield
PlacesUtils
.
promiseItemGuid
(
itemId
)
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
warn
(
ensureGuidForId
:
Error
fetching
GUID
for
{
itemId
}
ex
)
;
if
(
!
isInvalidCachedGuidError
(
ex
)
)
{
throw
ex
;
}
guid
=
yield
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
ensureGuidForId
"
Task
.
async
(
function
*
(
db
)
{
let
guid
=
yield
generateGuid
(
db
)
;
BookmarkSyncLog
.
warn
(
ensureGuidForId
:
Assigning
{
guid
}
to
item
without
GUID
{
itemId
}
)
;
return
setGuid
(
db
itemId
guid
)
;
}
)
)
;
}
return
guid
;
}
)
changeGuid
:
Task
.
async
(
function
*
(
oldGuid
newGuid
)
{
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
.
guid
(
oldGuid
)
;
let
itemId
=
yield
PlacesUtils
.
promiseItemId
(
oldGuid
)
;
if
(
PlacesUtils
.
isRootItem
(
itemId
)
)
{
throw
new
Error
(
Cannot
change
GUID
of
Places
root
{
oldGuid
}
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
changeGuid
"
db
=
>
setGuid
(
db
itemId
newGuid
)
)
;
}
)
update
:
Task
.
async
(
function
*
(
info
)
{
let
updateInfo
=
validateSyncBookmarkObject
(
info
{
guid
:
{
required
:
true
}
type
:
{
validIf
:
(
)
=
>
false
}
index
:
{
validIf
:
(
)
=
>
false
}
source
:
{
validIf
:
(
)
=
>
false
}
}
)
;
updateInfo
.
source
=
SOURCE_SYNC
;
return
updateSyncBookmark
(
updateInfo
)
;
}
)
insert
:
Task
.
async
(
function
*
(
info
)
{
let
insertInfo
=
validateNewBookmark
(
info
)
;
return
insertSyncBookmark
(
insertInfo
)
;
}
)
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
BookmarkSyncLog
"
(
)
=
>
{
return
Log
.
repository
.
getLogger
(
"
BookmarkSyncUtils
"
)
;
}
)
;
function
validateSyncBookmarkObject
(
input
behavior
)
{
return
PlacesUtils
.
validateItemProperties
(
PlacesUtils
.
SYNC_BOOKMARK_VALIDATORS
input
behavior
)
;
}
var
fetchAllChildren
=
Task
.
async
(
function
*
(
db
parentGuid
)
{
let
rows
=
yield
db
.
executeCached
(
SELECT
id
parent
position
type
guid
FROM
moz_bookmarks
WHERE
parent
=
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
:
parentGuid
)
ORDER
BY
position
{
parentGuid
}
)
;
return
rows
.
map
(
row
=
>
(
{
id
:
row
.
getResultByName
(
"
id
"
)
parentId
:
row
.
getResultByName
(
"
parent
"
)
index
:
row
.
getResultByName
(
"
position
"
)
type
:
row
.
getResultByName
(
"
type
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
}
)
)
;
}
)
;
function
findChildByGuid
(
children
guid
)
{
return
children
.
find
(
child
=
>
child
.
guid
=
=
guid
)
;
}
function
findChildByIndex
(
children
index
)
{
return
children
.
find
(
child
=
>
child
.
index
=
=
index
)
;
}
function
updateChildIndex
(
children
child
newIndex
)
{
let
siblings
=
[
]
;
let
lowIndex
=
Math
.
min
(
child
.
index
newIndex
)
;
let
highIndex
=
Math
.
max
(
child
.
index
newIndex
)
;
for
(
;
lowIndex
<
highIndex
;
+
+
lowIndex
)
{
let
sibling
=
findChildByIndex
(
children
lowIndex
)
;
siblings
.
push
(
sibling
)
;
}
let
sign
=
newIndex
<
child
.
index
?
+
1
:
-
1
;
for
(
let
sibling
of
siblings
)
{
sibling
.
index
+
=
sign
;
}
child
.
index
=
newIndex
;
}
function
notify
(
observers
notification
args
)
{
for
(
let
observer
of
observers
)
{
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
}
}
}
function
isInvalidCachedGuidError
(
error
)
{
return
error
&
&
error
.
message
=
=
"
Trying
to
update
the
GUIDs
cache
with
an
invalid
GUID
"
;
}
var
updateTagQueryFolder
=
Task
.
async
(
function
*
(
item
)
{
if
(
item
.
kind
!
=
BookmarkSyncUtils
.
KINDS
.
QUERY
|
|
!
item
.
folder
|
|
!
item
.
url
|
|
item
.
url
.
protocol
!
=
"
place
:
"
)
{
return
item
;
}
let
params
=
new
URLSearchParams
(
item
.
url
.
pathname
)
;
let
type
=
+
params
.
get
(
"
type
"
)
;
if
(
type
!
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAG_CONTENTS
)
{
return
item
;
}
let
id
=
yield
getOrCreateTagFolder
(
item
.
folder
)
;
BookmarkSyncLog
.
debug
(
updateTagQueryFolder
:
Tag
query
folder
:
{
item
.
folder
}
=
{
id
}
)
;
params
.
set
(
"
folder
"
id
)
;
item
.
url
=
new
URL
(
item
.
url
.
protocol
+
params
)
;
return
item
;
}
)
;
var
annotateOrphan
=
Task
.
async
(
function
*
(
item
requestedParentGuid
)
{
let
itemId
=
yield
PlacesUtils
.
promiseItemId
(
item
.
guid
)
;
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
PARENT_ANNO
requestedParentGuid
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
}
)
;
var
reparentOrphans
=
Task
.
async
(
function
*
(
item
)
{
if
(
item
.
type
!
=
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
)
{
return
;
}
let
orphanIds
=
findAnnoItems
(
PARENT_ANNO
item
.
guid
)
;
let
orphanGuids
=
yield
Promise
.
all
(
orphanIds
.
map
(
id
=
>
PlacesUtils
.
promiseItemGuid
(
id
)
)
)
;
BookmarkSyncLog
.
debug
(
reparentOrphans
:
Reparenting
{
JSON
.
stringify
(
orphanGuids
)
}
to
{
item
.
guid
}
)
;
for
(
let
i
=
0
;
i
<
orphanGuids
.
length
;
+
+
i
)
{
let
isReparented
=
false
;
try
{
BookmarkSyncLog
.
trace
(
reparentOrphans
:
Attempting
to
move
item
{
orphanGuids
[
i
]
}
to
new
parent
{
item
.
guid
}
)
;
yield
PlacesUtils
.
bookmarks
.
update
(
{
guid
:
orphanGuids
[
i
]
parentGuid
:
item
.
guid
index
:
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
source
:
SOURCE_SYNC
}
)
;
isReparented
=
true
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
error
(
reparentOrphans
:
Failed
to
reparent
item
{
orphanGuids
[
i
]
}
to
{
item
.
guid
}
ex
)
;
}
if
(
isReparented
)
{
PlacesUtils
.
annotations
.
removeItemAnnotation
(
orphanIds
[
i
]
PARENT_ANNO
SOURCE_SYNC
)
;
}
}
}
)
;
var
insertSyncBookmark
=
Task
.
async
(
function
*
(
insertInfo
)
{
let
requestedParentGuid
=
insertInfo
.
parentGuid
;
let
parent
=
yield
PlacesUtils
.
bookmarks
.
fetch
(
requestedParentGuid
)
;
if
(
parent
)
{
BookmarkSyncLog
.
debug
(
insertSyncBookmark
:
Item
{
insertInfo
.
guid
}
is
not
an
orphan
)
;
}
else
{
BookmarkSyncLog
.
debug
(
insertSyncBookmark
:
Item
{
insertInfo
.
guid
}
is
an
orphan
:
parent
{
requestedParentGuid
}
doesn
'
t
exist
;
reparenting
to
unfiled
)
;
insertInfo
.
parentGuid
=
PlacesUtils
.
bookmarks
.
unfiledGuid
;
}
insertInfo
=
yield
updateTagQueryFolder
(
insertInfo
)
;
let
newItem
;
if
(
insertInfo
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
)
{
newItem
=
yield
insertSyncLivemark
(
parent
insertInfo
)
;
}
else
{
let
item
=
yield
PlacesUtils
.
bookmarks
.
insert
(
insertInfo
)
;
let
newId
=
yield
PlacesUtils
.
promiseItemId
(
item
.
guid
)
;
newItem
=
yield
insertBookmarkMetadata
(
newId
item
insertInfo
)
;
}
if
(
!
newItem
)
{
return
null
;
}
if
(
!
parent
)
{
yield
annotateOrphan
(
newItem
requestedParentGuid
)
;
}
yield
reparentOrphans
(
newItem
)
;
return
newItem
;
}
)
;
var
insertSyncLivemark
=
Task
.
async
(
function
*
(
requestedParent
insertInfo
)
{
let
parentId
=
yield
PlacesUtils
.
promiseItemId
(
insertInfo
.
parentGuid
)
;
let
parentIsLivemark
=
PlacesUtils
.
annotations
.
itemHasAnnotation
(
parentId
PlacesUtils
.
LMANNO_FEEDURI
)
;
if
(
parentIsLivemark
)
{
BookmarkSyncLog
.
debug
(
insertSyncLivemark
:
Invalid
parent
{
insertInfo
.
parentGuid
}
;
skipping
livemark
record
{
insertInfo
.
guid
}
)
;
return
null
;
}
let
feedURI
=
PlacesUtils
.
toURI
(
insertInfo
.
feed
)
;
let
siteURI
=
insertInfo
.
site
?
PlacesUtils
.
toURI
(
insertInfo
.
site
)
:
null
;
let
item
=
yield
PlacesUtils
.
livemarks
.
addLivemark
(
{
title
:
insertInfo
.
title
parentGuid
:
insertInfo
.
parentGuid
index
:
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
feedURI
siteURI
guid
:
insertInfo
.
guid
source
:
SOURCE_SYNC
}
)
;
return
insertBookmarkMetadata
(
item
.
id
item
insertInfo
)
;
}
)
;
var
insertBookmarkMetadata
=
Task
.
async
(
function
*
(
itemId
item
insertInfo
)
{
if
(
insertInfo
.
query
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
SMART_BOOKMARKS_ANNO
insertInfo
.
query
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
item
.
query
=
insertInfo
.
query
;
}
try
{
item
.
tags
=
yield
tagItem
(
item
insertInfo
.
tags
)
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
warn
(
insertBookmarkMetadata
:
Error
tagging
item
{
item
.
guid
}
ex
)
;
}
if
(
insertInfo
.
keyword
)
{
yield
PlacesUtils
.
keywords
.
insert
(
{
keyword
:
insertInfo
.
keyword
url
:
item
.
url
.
href
source
:
SOURCE_SYNC
}
)
;
item
.
keyword
=
insertInfo
.
keyword
;
}
if
(
insertInfo
.
description
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
DESCRIPTION_ANNO
insertInfo
.
description
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
item
.
description
=
insertInfo
.
description
;
}
if
(
insertInfo
.
loadInSidebar
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
SIDEBAR_ANNO
insertInfo
.
loadInSidebar
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
item
.
loadInSidebar
=
insertInfo
.
loadInSidebar
;
}
return
item
;
}
)
;
var
getKindForItem
=
Task
.
async
(
function
*
(
item
)
{
switch
(
item
.
type
)
{
case
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
:
{
let
itemId
=
yield
PlacesUtils
.
promiseItemId
(
item
.
guid
)
;
let
isLivemark
=
PlacesUtils
.
annotations
.
itemHasAnnotation
(
itemId
PlacesUtils
.
LMANNO_FEEDURI
)
;
return
isLivemark
?
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
:
BookmarkSyncUtils
.
KINDS
.
FOLDER
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
:
return
item
.
url
.
protocol
=
=
"
place
:
"
?
BookmarkSyncUtils
.
KINDS
.
QUERY
:
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
;
case
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
:
return
BookmarkSyncUtils
.
KINDS
.
SEPARATOR
;
}
return
null
;
}
)
;
function
getTypeForKind
(
kind
)
{
switch
(
kind
)
{
case
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
:
case
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
:
case
BookmarkSyncUtils
.
KINDS
.
QUERY
:
return
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
;
case
BookmarkSyncUtils
.
KINDS
.
FOLDER
:
case
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
:
return
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
;
case
BookmarkSyncUtils
.
KINDS
.
SEPARATOR
:
return
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
;
}
throw
new
Error
(
Unknown
bookmark
kind
:
{
kind
}
)
;
}
var
shouldReinsertLivemark
=
Task
.
async
(
function
*
(
updateInfo
)
{
let
hasFeed
=
updateInfo
.
hasOwnProperty
(
"
feed
"
)
;
let
hasSite
=
updateInfo
.
hasOwnProperty
(
"
site
"
)
;
if
(
!
hasFeed
&
&
!
hasSite
)
{
return
false
;
}
let
livemark
=
yield
PlacesUtils
.
livemarks
.
getLivemark
(
{
guid
:
updateInfo
.
guid
}
)
;
if
(
hasFeed
)
{
let
feedURI
=
PlacesUtils
.
toURI
(
updateInfo
.
feed
)
;
if
(
!
livemark
.
feedURI
.
equals
(
feedURI
)
)
{
return
true
;
}
}
if
(
hasSite
)
{
if
(
!
updateInfo
.
site
)
{
return
!
!
livemark
.
siteURI
;
}
let
siteURI
=
PlacesUtils
.
toURI
(
updateInfo
.
site
)
;
if
(
!
livemark
.
siteURI
|
|
!
siteURI
.
equals
(
livemark
.
siteURI
)
)
{
return
true
;
}
}
return
false
;
}
)
;
var
updateSyncBookmark
=
Task
.
async
(
function
*
(
updateInfo
)
{
let
oldItem
=
yield
PlacesUtils
.
bookmarks
.
fetch
(
updateInfo
.
guid
)
;
if
(
!
oldItem
)
{
throw
new
Error
(
Bookmark
with
GUID
{
updateInfo
.
guid
}
does
not
exist
)
;
}
let
shouldReinsert
=
false
;
let
oldKind
=
yield
getKindForItem
(
oldItem
)
;
if
(
updateInfo
.
hasOwnProperty
(
"
kind
"
)
&
&
updateInfo
.
kind
!
=
oldKind
)
{
shouldReinsert
=
true
;
BookmarkSyncLog
.
warn
(
updateSyncBookmark
:
Local
{
oldItem
.
guid
}
kind
=
(
{
oldKind
}
)
;
remote
{
updateInfo
.
guid
}
kind
=
{
updateInfo
.
kind
}
.
Deleting
and
recreating
)
;
}
else
if
(
oldKind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
)
{
shouldReinsert
=
yield
shouldReinsertLivemark
(
updateInfo
)
;
if
(
shouldReinsert
)
{
BookmarkSyncLog
.
debug
(
updateSyncBookmark
:
Local
{
oldItem
.
guid
}
and
remote
{
updateInfo
.
guid
}
livemarks
have
different
URLs
)
;
}
}
if
(
shouldReinsert
)
{
delete
updateInfo
.
source
;
let
newItem
=
validateNewBookmark
(
updateInfo
)
;
yield
PlacesUtils
.
bookmarks
.
remove
(
{
guid
:
oldItem
.
guid
source
:
SOURCE_SYNC
}
)
;
return
insertSyncBookmark
(
newItem
)
;
}
let
isOrphan
=
false
requestedParentGuid
;
if
(
updateInfo
.
hasOwnProperty
(
"
parentGuid
"
)
)
{
requestedParentGuid
=
updateInfo
.
parentGuid
;
if
(
requestedParentGuid
!
=
oldItem
.
parentGuid
)
{
let
oldId
=
yield
PlacesUtils
.
promiseItemId
(
oldItem
.
guid
)
;
if
(
PlacesUtils
.
isRootItem
(
oldId
)
)
{
throw
new
Error
(
Cannot
move
Places
root
{
oldId
}
)
;
}
let
parent
=
yield
PlacesUtils
.
bookmarks
.
fetch
(
requestedParentGuid
)
;
if
(
parent
)
{
BookmarkSyncLog
.
debug
(
updateSyncBookmark
:
Item
{
updateInfo
.
guid
}
is
not
an
orphan
)
;
}
else
{
BookmarkSyncLog
.
trace
(
updateSyncBookmark
:
Item
{
updateInfo
.
guid
}
is
an
orphan
:
could
not
find
parent
{
requestedParentGuid
}
)
;
isOrphan
=
true
;
delete
updateInfo
.
parentGuid
;
}
updateInfo
.
index
=
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
;
}
else
{
delete
updateInfo
.
parentGuid
;
}
}
updateInfo
=
yield
updateTagQueryFolder
(
updateInfo
)
;
let
newItem
=
shouldUpdateBookmark
(
updateInfo
)
?
yield
PlacesUtils
.
bookmarks
.
update
(
updateInfo
)
:
oldItem
;
let
itemId
=
yield
PlacesUtils
.
promiseItemId
(
newItem
.
guid
)
;
newItem
=
yield
updateBookmarkMetadata
(
itemId
oldItem
newItem
updateInfo
)
;
if
(
isOrphan
)
{
yield
annotateOrphan
(
newItem
requestedParentGuid
)
;
}
yield
reparentOrphans
(
newItem
)
;
return
newItem
;
}
)
;
var
updateBookmarkMetadata
=
Task
.
async
(
function
*
(
itemId
oldItem
newItem
updateInfo
)
{
try
{
newItem
.
tags
=
yield
tagItem
(
newItem
updateInfo
.
tags
)
;
}
catch
(
ex
)
{
BookmarkSyncLog
.
warn
(
updateBookmarkMetadata
:
Error
tagging
item
{
newItem
.
guid
}
ex
)
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
keyword
"
)
)
{
let
entry
=
yield
PlacesUtils
.
keywords
.
fetch
(
{
url
:
oldItem
.
url
.
href
}
)
;
if
(
entry
)
{
yield
PlacesUtils
.
keywords
.
remove
(
{
keyword
:
entry
.
keyword
source
:
SOURCE_SYNC
}
)
;
}
if
(
updateInfo
.
keyword
)
{
yield
PlacesUtils
.
keywords
.
insert
(
{
keyword
:
updateInfo
.
keyword
url
:
newItem
.
url
.
href
source
:
SOURCE_SYNC
}
)
;
}
newItem
.
keyword
=
updateInfo
.
keyword
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
description
"
)
)
{
if
(
updateInfo
.
description
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
DESCRIPTION_ANNO
updateInfo
.
description
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
}
else
{
PlacesUtils
.
annotations
.
removeItemAnnotation
(
itemId
DESCRIPTION_ANNO
SOURCE_SYNC
)
;
}
newItem
.
description
=
updateInfo
.
description
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
loadInSidebar
"
)
)
{
if
(
updateInfo
.
loadInSidebar
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
SIDEBAR_ANNO
updateInfo
.
loadInSidebar
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
}
else
{
PlacesUtils
.
annotations
.
removeItemAnnotation
(
itemId
SIDEBAR_ANNO
SOURCE_SYNC
)
;
}
newItem
.
loadInSidebar
=
updateInfo
.
loadInSidebar
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
query
"
)
)
{
PlacesUtils
.
annotations
.
setItemAnnotation
(
itemId
SMART_BOOKMARKS_ANNO
updateInfo
.
query
0
PlacesUtils
.
annotations
.
EXPIRE_NEVER
SOURCE_SYNC
)
;
newItem
.
query
=
updateInfo
.
query
;
}
return
newItem
;
}
)
;
function
generateGuid
(
db
)
{
return
db
.
executeCached
(
"
SELECT
GENERATE_GUID
(
)
AS
guid
"
)
.
then
(
rows
=
>
rows
[
0
]
.
getResultByName
(
"
guid
"
)
)
;
}
function
setGuids
(
guids
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
BookmarkSyncUtils
:
setGuids
"
db
=
>
db
.
executeTransaction
(
function
*
(
)
{
let
promises
=
[
]
;
for
(
let
[
itemId
newGuid
]
of
guids
)
{
promises
.
push
(
setGuid
(
db
itemId
newGuid
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
)
)
;
}
var
setGuid
=
Task
.
async
(
function
*
(
db
itemId
newGuid
)
{
yield
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
guid
=
:
newGuid
WHERE
id
=
:
itemId
{
newGuid
itemId
}
)
;
PlacesUtils
.
invalidateCachedGuidFor
(
itemId
)
;
return
newGuid
;
}
)
;
function
validateNewBookmark
(
info
)
{
let
insertInfo
=
validateSyncBookmarkObject
(
info
{
kind
:
{
required
:
true
}
type
:
{
validIf
:
(
)
=
>
false
}
index
:
{
validIf
:
(
)
=
>
false
}
source
:
{
validIf
:
(
)
=
>
false
}
guid
:
{
required
:
true
}
url
:
{
requiredIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
parentGuid
:
{
required
:
true
}
title
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
BookmarkSyncUtils
.
KINDS
.
QUERY
BookmarkSyncUtils
.
KINDS
.
FOLDER
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
]
.
includes
(
b
.
kind
)
}
query
:
{
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
QUERY
}
folder
:
{
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
QUERY
}
tags
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
keyword
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
BookmarkSyncUtils
.
KINDS
.
QUERY
]
.
includes
(
b
.
kind
)
}
description
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
BookmarkSyncUtils
.
KINDS
.
QUERY
BookmarkSyncUtils
.
KINDS
.
FOLDER
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
]
.
includes
(
b
.
kind
)
}
loadInSidebar
:
{
validIf
:
b
=
>
[
BookmarkSyncUtils
.
KINDS
.
BOOKMARK
BookmarkSyncUtils
.
KINDS
.
MICROSUMMARY
]
.
includes
(
b
.
kind
)
}
feed
:
{
requiredIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
}
site
:
{
validIf
:
b
=
>
b
.
kind
=
=
BookmarkSyncUtils
.
KINDS
.
LIVEMARK
}
}
)
;
let
time
=
new
Date
(
)
;
insertInfo
.
dateAdded
=
insertInfo
.
lastModified
=
time
;
insertInfo
.
type
=
getTypeForKind
(
insertInfo
.
kind
)
;
insertInfo
.
source
=
SOURCE_SYNC
;
return
insertInfo
;
}
function
findAnnoItems
(
anno
val
)
{
let
annos
=
PlacesUtils
.
annotations
;
return
annos
.
getItemsWithAnnotation
(
anno
{
}
)
.
filter
(
id
=
>
annos
.
getItemAnnotation
(
id
anno
)
=
=
val
)
;
}
var
tagItem
=
Task
.
async
(
function
(
item
tags
)
{
if
(
!
item
.
url
)
{
return
[
]
;
}
let
newTags
=
tags
.
map
(
tag
=
>
tag
.
trim
(
)
)
.
filter
(
Boolean
)
;
let
dummyURI
=
PlacesUtils
.
toURI
(
"
about
:
weave
#
BStore_tagURI
"
)
;
let
bookmarkURI
=
PlacesUtils
.
toURI
(
item
.
url
.
href
)
;
PlacesUtils
.
tagging
.
tagURI
(
dummyURI
newTags
SOURCE_SYNC
)
;
PlacesUtils
.
tagging
.
untagURI
(
bookmarkURI
null
SOURCE_SYNC
)
;
PlacesUtils
.
tagging
.
tagURI
(
bookmarkURI
newTags
SOURCE_SYNC
)
;
PlacesUtils
.
tagging
.
untagURI
(
dummyURI
null
SOURCE_SYNC
)
;
return
newTags
;
}
)
;
function
shouldUpdateBookmark
(
updateInfo
)
{
let
propsToUpdate
=
0
;
for
(
let
prop
in
PlacesUtils
.
BOOKMARK_VALIDATORS
)
{
if
(
!
updateInfo
.
hasOwnProperty
(
prop
)
)
{
continue
;
}
if
(
+
+
propsToUpdate
>
=
3
)
{
return
true
;
}
}
return
false
;
}
var
getTagFolder
=
Task
.
async
(
function
*
(
tag
)
{
let
db
=
yield
PlacesUtils
.
promiseDBConnection
(
)
;
let
results
=
yield
db
.
executeCached
(
SELECT
id
FROM
moz_bookmarks
WHERE
parent
=
:
tagsFolder
AND
title
=
:
tag
LIMIT
1
{
tagsFolder
:
PlacesUtils
.
bookmarks
.
tagsFolder
tag
}
)
;
return
results
.
length
?
results
[
0
]
.
getResultByName
(
"
id
"
)
:
null
;
}
)
;
var
getOrCreateTagFolder
=
Task
.
async
(
function
*
(
tag
)
{
let
id
=
yield
getTagFolder
(
tag
)
;
if
(
id
)
{
return
id
;
}
let
item
=
yield
PlacesUtils
.
bookmarks
.
insert
(
{
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
parentGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
title
:
tag
}
)
;
return
PlacesUtils
.
promiseItemId
(
item
.
guid
)
;
}
)
;
