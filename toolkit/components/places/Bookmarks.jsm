"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Bookmarks
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesSyncUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
)
;
var
gTagsFolderId
;
async
function
promiseTagsFolderId
(
)
{
if
(
gTagsFolderId
)
return
gTagsFolderId
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
execute
(
"
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
:
guid
"
{
guid
:
Bookmarks
.
tagsGuid
}
)
;
return
gTagsFolderId
=
rows
[
0
]
.
getResultByName
(
"
id
"
)
;
}
const
MATCH_ANYWHERE_UNMODIFIED
=
Ci
.
mozIPlacesAutoComplete
.
MATCH_ANYWHERE_UNMODIFIED
;
const
BEHAVIOR_BOOKMARK
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_BOOKMARK
;
const
SQLITE_MAX_VARIABLE_NUMBER
=
999
;
const
ACCEPTED_ANNOTATIONS
=
[
PlacesUtils
.
LMANNO_FEEDURI
PlacesUtils
.
LMANNO_SITEURI
]
;
var
Bookmarks
=
Object
.
freeze
(
{
TYPE_BOOKMARK
:
1
TYPE_FOLDER
:
2
TYPE_SEPARATOR
:
3
SYNC_STATUS
:
{
UNKNOWN
:
Ci
.
nsINavBookmarksService
.
SYNC_STATUS_UNKNOWN
NEW
:
Ci
.
nsINavBookmarksService
.
SYNC_STATUS_NEW
NORMAL
:
Ci
.
nsINavBookmarksService
.
SYNC_STATUS_NORMAL
}
DEFAULT_INDEX
:
-
1
MAX_TAG_LENGTH
:
100
SOURCES
:
{
DEFAULT
:
Ci
.
nsINavBookmarksService
.
SOURCE_DEFAULT
SYNC
:
Ci
.
nsINavBookmarksService
.
SOURCE_SYNC
IMPORT
:
Ci
.
nsINavBookmarksService
.
SOURCE_IMPORT
SYNC_REPARENT_REMOVED_FOLDER_CHILDREN
:
Ci
.
nsINavBookmarksService
.
SOURCE_SYNC_REPARENT_REMOVED_FOLDER_CHILDREN
RESTORE
:
Ci
.
nsINavBookmarksService
.
SOURCE_RESTORE
RESTORE_ON_STARTUP
:
Ci
.
nsINavBookmarksService
.
SOURCE_RESTORE_ON_STARTUP
}
rootGuid
:
"
root________
"
menuGuid
:
"
menu________
"
toolbarGuid
:
"
toolbar_____
"
unfiledGuid
:
"
unfiled_____
"
mobileGuid
:
"
mobile______
"
tagsGuid
:
"
tags________
"
userContentRoots
:
[
"
toolbar_____
"
"
menu________
"
"
unfiled_____
"
"
mobile______
"
]
virtualMenuGuid
:
"
menu_______v
"
virtualToolbarGuid
:
"
toolbar____v
"
virtualUnfiledGuid
:
"
unfiled___v
"
virtualMobileGuid
:
"
mobile____v
"
isVirtualRootItem
(
guid
)
{
return
guid
=
=
PlacesUtils
.
bookmarks
.
virtualMenuGuid
|
|
guid
=
=
PlacesUtils
.
bookmarks
.
virtualToolbarGuid
|
|
guid
=
=
PlacesUtils
.
bookmarks
.
virtualUnfiledGuid
|
|
guid
=
=
PlacesUtils
.
bookmarks
.
virtualMobileGuid
;
}
getLocalizedTitle
(
info
)
{
if
(
!
PlacesUtils
.
bookmarks
.
userContentRoots
.
includes
(
info
.
guid
)
)
{
return
info
.
title
;
}
switch
(
info
.
guid
)
{
case
PlacesUtils
.
bookmarks
.
toolbarGuid
:
return
PlacesUtils
.
getString
(
"
BookmarksToolbarFolderTitle
"
)
;
case
PlacesUtils
.
bookmarks
.
menuGuid
:
return
PlacesUtils
.
getString
(
"
BookmarksMenuFolderTitle
"
)
;
case
PlacesUtils
.
bookmarks
.
unfiledGuid
:
return
PlacesUtils
.
getString
(
"
OtherBookmarksFolderTitle
"
)
;
case
PlacesUtils
.
bookmarks
.
mobileGuid
:
return
PlacesUtils
.
getString
(
"
MobileBookmarksFolderTitle
"
)
;
default
:
throw
new
Error
(
Unsupported
guid
{
info
.
guid
}
passed
to
getLocalizedTitle
!
)
;
}
}
insert
(
info
)
{
let
now
=
new
Date
(
)
;
let
addedTime
=
(
info
&
&
info
.
dateAdded
)
|
|
now
;
let
modTime
=
addedTime
;
if
(
addedTime
>
now
)
{
modTime
=
now
;
}
let
insertInfo
=
validateBookmarkObject
(
"
Bookmarks
.
jsm
:
insert
"
info
{
type
:
{
defaultValue
:
this
.
TYPE_BOOKMARK
}
index
:
{
defaultValue
:
this
.
DEFAULT_INDEX
}
url
:
{
requiredIf
:
b
=
>
b
.
type
=
=
this
.
TYPE_BOOKMARK
validIf
:
b
=
>
b
.
type
=
=
this
.
TYPE_BOOKMARK
}
parentGuid
:
{
required
:
true
validIf
:
b
=
>
b
.
parentGuid
!
=
this
.
rootGuid
}
title
:
{
defaultValue
:
"
"
validIf
:
b
=
>
b
.
type
=
=
this
.
TYPE_BOOKMARK
|
|
b
.
type
=
=
this
.
TYPE_FOLDER
|
|
b
.
title
=
=
=
"
"
}
dateAdded
:
{
defaultValue
:
addedTime
}
lastModified
:
{
defaultValue
:
modTime
validIf
:
b
=
>
b
.
lastModified
>
=
now
|
|
(
b
.
dateAdded
&
&
b
.
lastModified
>
=
b
.
dateAdded
)
}
source
:
{
defaultValue
:
this
.
SOURCES
.
DEFAULT
}
}
)
;
return
(
async
(
)
=
>
{
let
parent
=
await
fetchBookmark
(
{
guid
:
insertInfo
.
parentGuid
}
)
;
if
(
!
parent
)
throw
new
Error
(
"
parentGuid
must
be
valid
"
)
;
if
(
insertInfo
.
index
=
=
this
.
DEFAULT_INDEX
|
|
insertInfo
.
index
>
parent
.
_childCount
)
{
insertInfo
.
index
=
parent
.
_childCount
;
}
let
item
=
await
insertBookmark
(
insertInfo
parent
)
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
let
uri
=
item
.
hasOwnProperty
(
"
url
"
)
?
PlacesUtils
.
toURI
(
item
.
url
)
:
null
;
let
itemId
=
await
PlacesUtils
.
promiseItemId
(
item
.
guid
)
;
let
isTagging
=
parent
.
_parentId
=
=
PlacesUtils
.
tagsFolderId
;
let
isTagsFolder
=
parent
.
_id
=
=
PlacesUtils
.
tagsFolderId
;
notify
(
observers
"
onItemAdded
"
[
itemId
parent
.
_id
item
.
index
item
.
type
uri
item
.
title
PlacesUtils
.
toPRTime
(
item
.
dateAdded
)
item
.
guid
item
.
parentGuid
item
.
source
]
{
isTagging
:
isTagging
|
|
isTagsFolder
}
)
;
if
(
isTagging
)
{
for
(
let
entry
of
(
await
fetchBookmarksByURL
(
item
true
)
)
)
{
notify
(
observers
"
onItemChanged
"
[
entry
.
_id
"
tags
"
false
"
"
PlacesUtils
.
toPRTime
(
entry
.
lastModified
)
entry
.
type
entry
.
_parentId
entry
.
guid
entry
.
parentGuid
"
"
item
.
source
]
)
;
}
}
delete
item
.
source
;
return
Object
.
assign
(
{
}
item
)
;
}
)
(
)
;
}
insertTree
(
tree
options
)
{
if
(
!
tree
|
|
typeof
tree
!
=
"
object
"
)
{
throw
new
Error
(
"
Should
be
provided
a
valid
tree
object
.
"
)
;
}
if
(
!
Array
.
isArray
(
tree
.
children
)
|
|
!
tree
.
children
.
length
)
{
throw
new
Error
(
"
Should
have
a
non
-
zero
number
of
children
to
insert
.
"
)
;
}
if
(
!
PlacesUtils
.
isValidGuid
(
tree
.
guid
)
)
{
throw
new
Error
(
The
parent
guid
is
not
valid
(
{
tree
.
guid
}
{
tree
.
title
}
)
.
)
;
}
if
(
tree
.
guid
=
=
this
.
rootGuid
)
{
throw
new
Error
(
"
Can
'
t
insert
into
the
root
.
"
)
;
}
if
(
tree
.
guid
=
=
this
.
tagsGuid
)
{
throw
new
Error
(
"
Can
'
t
use
insertTree
to
insert
tags
.
"
)
;
}
if
(
tree
.
hasOwnProperty
(
"
source
"
)
&
&
!
Object
.
values
(
this
.
SOURCES
)
.
includes
(
tree
.
source
)
)
{
throw
new
Error
(
"
Can
'
t
use
source
value
"
+
tree
.
source
)
;
}
if
(
options
&
&
typeof
options
!
=
"
object
"
)
{
throw
new
Error
(
"
Options
should
be
a
valid
object
"
)
;
}
let
fixupOrSkipInvalidEntries
=
options
&
&
!
!
options
.
fixupOrSkipInvalidEntries
;
let
insertInfos
=
[
]
;
let
insertLivemarkInfos
=
[
]
;
let
urlsThatMightNeedPlaces
=
[
]
;
let
fallbackLastAdded
=
new
Date
(
)
;
const
{
TYPE_BOOKMARK
TYPE_FOLDER
SOURCES
}
=
this
;
let
source
=
tree
.
source
|
|
SOURCES
.
DEFAULT
;
function
appendInsertionInfoForInfoArray
(
infos
indexToUse
parentGuid
)
{
let
shouldUseNullIndices
=
false
;
if
(
indexToUse
=
=
=
null
)
{
shouldUseNullIndices
=
true
;
indexToUse
=
0
;
}
let
lastAddedForParent
=
new
Date
(
0
)
;
for
(
let
info
of
infos
)
{
let
time
=
(
info
&
&
info
.
dateAdded
)
|
|
fallbackLastAdded
;
let
insertInfo
=
{
guid
:
{
defaultValue
:
PlacesUtils
.
history
.
makeGuid
(
)
}
type
:
{
defaultValue
:
TYPE_BOOKMARK
}
url
:
{
requiredIf
:
b
=
>
b
.
type
=
=
TYPE_BOOKMARK
validIf
:
b
=
>
b
.
type
=
=
TYPE_BOOKMARK
}
parentGuid
:
{
replaceWith
:
parentGuid
}
title
:
{
defaultValue
:
"
"
validIf
:
b
=
>
b
.
type
=
=
TYPE_BOOKMARK
|
|
b
.
type
=
=
TYPE_FOLDER
|
|
b
.
title
=
=
=
"
"
}
dateAdded
:
{
defaultValue
:
time
validIf
:
b
=
>
!
b
.
lastModified
|
|
b
.
dateAdded
<
=
b
.
lastModified
}
lastModified
:
{
defaultValue
:
time
validIf
:
b
=
>
(
!
b
.
dateAdded
&
&
b
.
lastModified
>
=
time
)
|
|
(
b
.
dateAdded
&
&
b
.
lastModified
>
=
b
.
dateAdded
)
}
index
:
{
replaceWith
:
indexToUse
+
+
}
source
:
{
replaceWith
:
source
}
annos
:
{
validIf
:
b
=
>
false
fixup
:
b
=
>
b
.
annos
=
b
.
annos
.
filter
(
anno
=
>
ACCEPTED_ANNOTATIONS
.
includes
(
anno
.
name
)
)
}
keyword
:
{
validIf
:
b
=
>
b
.
type
=
=
TYPE_BOOKMARK
}
charset
:
{
validIf
:
b
=
>
b
.
type
=
=
TYPE_BOOKMARK
}
postData
:
{
validIf
:
b
=
>
b
.
type
=
=
TYPE_BOOKMARK
}
tags
:
{
validIf
:
b
=
>
b
.
type
=
=
TYPE_BOOKMARK
}
children
:
{
validIf
:
b
=
>
b
.
type
=
=
TYPE_FOLDER
&
&
Array
.
isArray
(
b
.
children
)
}
}
;
if
(
fixupOrSkipInvalidEntries
)
{
insertInfo
.
guid
.
fixup
=
b
=
>
b
.
guid
=
PlacesUtils
.
history
.
makeGuid
(
)
;
insertInfo
.
dateAdded
.
fixup
=
insertInfo
.
lastModified
.
fixup
=
b
=
>
b
.
lastModified
=
b
.
dateAdded
=
fallbackLastAdded
;
}
try
{
insertInfo
=
validateBookmarkObject
(
"
Bookmarks
.
jsm
:
insertTree
"
info
insertInfo
)
;
}
catch
(
ex
)
{
if
(
fixupOrSkipInvalidEntries
)
{
indexToUse
-
-
;
continue
;
}
else
{
throw
ex
;
}
}
if
(
shouldUseNullIndices
)
{
insertInfo
.
index
=
null
;
}
if
(
insertInfo
.
type
=
=
Bookmarks
.
TYPE_BOOKMARK
)
{
urlsThatMightNeedPlaces
.
push
(
insertInfo
.
url
)
;
}
if
(
isLivemark
(
insertInfo
)
)
{
let
livemarkInfo
=
Object
.
assign
(
{
}
insertInfo
)
;
delete
insertInfo
.
annos
;
insertLivemarkInfos
.
push
(
livemarkInfo
)
;
}
insertInfos
.
push
(
insertInfo
)
;
if
(
info
.
children
)
{
let
childrenLastAdded
=
appendInsertionInfoForInfoArray
(
info
.
children
0
insertInfo
.
guid
)
;
if
(
childrenLastAdded
>
insertInfo
.
lastModified
)
{
insertInfo
.
lastModified
=
childrenLastAdded
;
}
if
(
childrenLastAdded
>
lastAddedForParent
)
{
lastAddedForParent
=
childrenLastAdded
;
}
}
if
(
insertInfo
.
dateAdded
>
lastAddedForParent
)
{
lastAddedForParent
=
insertInfo
.
dateAdded
;
}
}
return
lastAddedForParent
;
}
let
lastAddedForParent
=
appendInsertionInfoForInfoArray
(
tree
.
children
null
tree
.
guid
)
;
return
(
async
function
(
)
{
let
treeParent
=
await
fetchBookmark
(
{
guid
:
tree
.
guid
}
)
;
if
(
!
treeParent
)
{
throw
new
Error
(
"
The
parent
you
specified
doesn
'
t
exist
.
"
)
;
}
if
(
treeParent
.
_parentId
=
=
PlacesUtils
.
tagsFolderId
)
{
throw
new
Error
(
"
Can
'
t
use
insertTree
to
insert
tags
.
"
)
;
}
await
insertBookmarkTree
(
insertInfos
source
treeParent
urlsThatMightNeedPlaces
lastAddedForParent
)
;
for
(
let
info
of
insertLivemarkInfos
)
{
try
{
await
insertLivemarkData
(
info
)
;
}
catch
(
ex
)
{
if
(
fixupOrSkipInvalidEntries
)
{
let
placeholderIndex
=
insertInfos
.
findIndex
(
item
=
>
item
.
guid
=
=
info
.
guid
)
;
if
(
placeholderIndex
!
=
-
1
)
{
insertInfos
.
splice
(
placeholderIndex
1
)
;
}
}
else
{
throw
ex
;
}
}
}
let
rootIndex
=
treeParent
.
_childCount
;
for
(
let
insertInfo
of
insertInfos
)
{
if
(
insertInfo
.
parentGuid
=
=
tree
.
guid
)
{
insertInfo
.
index
+
=
rootIndex
+
+
;
}
}
let
itemIdMap
=
await
PlacesUtils
.
promiseManyItemIds
(
insertInfos
.
map
(
info
=
>
info
.
guid
)
)
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
for
(
let
i
=
0
;
i
<
insertInfos
.
length
;
i
+
+
)
{
let
item
=
insertInfos
[
i
]
;
let
itemId
=
itemIdMap
.
get
(
item
.
guid
)
;
let
uri
=
item
.
hasOwnProperty
(
"
url
"
)
?
PlacesUtils
.
toURI
(
item
.
url
)
:
null
;
let
parentId
;
if
(
item
.
parentGuid
=
=
=
treeParent
.
guid
)
{
parentId
=
treeParent
.
_id
;
}
else
{
parentId
=
itemIdMap
.
get
(
item
.
parentGuid
)
;
}
notify
(
observers
"
onItemAdded
"
[
itemId
parentId
item
.
index
item
.
type
uri
item
.
title
PlacesUtils
.
toPRTime
(
item
.
dateAdded
)
item
.
guid
item
.
parentGuid
item
.
source
]
{
isTagging
:
false
}
)
;
try
{
await
handleBookmarkItemSpecialData
(
itemId
item
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
An
error
occured
while
handling
special
bookmark
data
:
{
ex
}
)
;
}
delete
item
.
source
;
insertInfos
[
i
]
=
Object
.
assign
(
{
}
item
)
;
}
return
insertInfos
;
}
)
(
)
;
}
update
(
info
)
{
let
updateInfo
=
validateBookmarkObject
(
"
Bookmarks
.
jsm
:
update
"
info
{
guid
:
{
required
:
true
}
index
:
{
requiredIf
:
b
=
>
b
.
hasOwnProperty
(
"
parentGuid
"
)
validIf
:
b
=
>
b
.
index
>
=
0
|
|
b
.
index
=
=
this
.
DEFAULT_INDEX
}
parentGuid
:
{
validIf
:
b
=
>
b
.
parentGuid
!
=
this
.
rootGuid
}
source
:
{
defaultValue
:
this
.
SOURCES
.
DEFAULT
}
}
)
;
if
(
Object
.
keys
(
updateInfo
)
.
length
<
3
)
throw
new
Error
(
"
Not
enough
properties
to
update
"
)
;
return
(
async
(
)
=
>
{
let
item
=
await
fetchBookmark
(
updateInfo
)
;
if
(
!
item
)
throw
new
Error
(
"
No
bookmarks
found
for
the
provided
GUID
"
)
;
if
(
updateInfo
.
hasOwnProperty
(
"
type
"
)
&
&
updateInfo
.
type
!
=
item
.
type
)
throw
new
Error
(
"
The
bookmark
type
cannot
be
changed
"
)
;
removeSameValueProperties
(
updateInfo
item
)
;
if
(
Object
.
keys
(
updateInfo
)
.
length
<
3
)
{
return
Object
.
assign
(
{
}
item
)
;
}
const
now
=
new
Date
(
)
;
let
lastModifiedDefault
=
now
;
if
(
!
(
"
lastModified
"
in
updateInfo
)
&
&
"
dateAdded
"
in
updateInfo
)
{
lastModifiedDefault
=
new
Date
(
Math
.
max
(
item
.
lastModified
updateInfo
.
dateAdded
)
)
;
}
updateInfo
=
validateBookmarkObject
(
"
Bookmarks
.
jsm
:
update
"
updateInfo
{
url
:
{
validIf
:
(
)
=
>
item
.
type
=
=
this
.
TYPE_BOOKMARK
}
title
:
{
validIf
:
(
)
=
>
[
this
.
TYPE_BOOKMARK
this
.
TYPE_FOLDER
]
.
includes
(
item
.
type
)
}
lastModified
:
{
defaultValue
:
lastModifiedDefault
validIf
:
b
=
>
b
.
lastModified
>
=
now
|
|
b
.
lastModified
>
=
(
b
.
dateAdded
|
|
item
.
dateAdded
)
}
dateAdded
:
{
defaultValue
:
item
.
dateAdded
}
}
)
;
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
update
"
async
db
=
>
{
let
parent
;
if
(
updateInfo
.
hasOwnProperty
(
"
parentGuid
"
)
)
{
if
(
PlacesUtils
.
isRootItem
(
item
.
guid
)
)
{
throw
new
Error
(
"
It
'
s
not
possible
to
move
Places
root
folders
.
"
)
;
}
if
(
item
.
type
=
=
this
.
TYPE_FOLDER
)
{
let
rows
=
await
db
.
executeCached
(
WITH
RECURSIVE
descendants
(
did
)
AS
(
VALUES
(
:
id
)
UNION
ALL
SELECT
id
FROM
moz_bookmarks
JOIN
descendants
ON
parent
=
did
WHERE
type
=
:
type
)
SELECT
guid
FROM
moz_bookmarks
WHERE
id
IN
descendants
{
id
:
item
.
_id
type
:
this
.
TYPE_FOLDER
}
)
;
if
(
rows
.
map
(
r
=
>
r
.
getResultByName
(
"
guid
"
)
)
.
includes
(
updateInfo
.
parentGuid
)
)
throw
new
Error
(
"
Cannot
insert
a
folder
into
itself
or
one
of
its
descendants
"
)
;
}
parent
=
await
fetchBookmark
(
{
guid
:
updateInfo
.
parentGuid
}
)
;
if
(
!
parent
)
throw
new
Error
(
"
No
bookmarks
found
for
the
provided
parentGuid
"
)
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
index
"
)
)
{
if
(
PlacesUtils
.
isRootItem
(
item
.
guid
)
)
{
throw
new
Error
(
"
It
'
s
not
possible
to
move
Places
root
folders
.
"
)
;
}
if
(
!
parent
)
parent
=
await
fetchBookmark
(
{
guid
:
item
.
parentGuid
}
)
;
if
(
updateInfo
.
index
>
=
parent
.
_childCount
|
|
updateInfo
.
index
=
=
this
.
DEFAULT_INDEX
)
{
updateInfo
.
index
=
parent
.
_childCount
;
if
(
parent
.
guid
=
=
item
.
parentGuid
)
updateInfo
.
index
-
-
;
}
}
let
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
info
.
source
)
;
let
updatedItem
=
await
db
.
executeTransaction
(
async
function
(
)
{
let
updatedItem
=
await
updateBookmark
(
db
updateInfo
item
item
.
index
parent
syncChangeDelta
)
;
if
(
parent
)
{
await
setAncestorsLastModified
(
db
parent
.
guid
updatedItem
.
lastModified
syncChangeDelta
)
;
}
return
updatedItem
;
}
)
;
if
(
item
.
type
=
=
this
.
TYPE_BOOKMARK
&
&
item
.
url
.
href
!
=
updatedItem
.
url
.
href
)
{
updateFrecency
(
db
[
item
.
url
]
)
.
catch
(
Cu
.
reportError
)
;
updateFrecency
(
db
[
updatedItem
.
url
]
)
.
catch
(
Cu
.
reportError
)
;
}
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
if
(
info
.
hasOwnProperty
(
"
lastModified
"
)
&
&
updateInfo
.
hasOwnProperty
(
"
lastModified
"
)
&
&
item
.
lastModified
!
=
updatedItem
.
lastModified
)
{
notify
(
observers
"
onItemChanged
"
[
updatedItem
.
_id
"
lastModified
"
false
{
PlacesUtils
.
toPRTime
(
updatedItem
.
lastModified
)
}
PlacesUtils
.
toPRTime
(
updatedItem
.
lastModified
)
updatedItem
.
type
updatedItem
.
_parentId
updatedItem
.
guid
updatedItem
.
parentGuid
"
"
updatedItem
.
source
]
)
;
}
if
(
info
.
hasOwnProperty
(
"
dateAdded
"
)
&
&
updateInfo
.
hasOwnProperty
(
"
dateAdded
"
)
&
&
item
.
dateAdded
!
=
updatedItem
.
dateAdded
)
{
notify
(
observers
"
onItemChanged
"
[
updatedItem
.
_id
"
dateAdded
"
false
{
PlacesUtils
.
toPRTime
(
updatedItem
.
dateAdded
)
}
PlacesUtils
.
toPRTime
(
updatedItem
.
lastModified
)
updatedItem
.
type
updatedItem
.
_parentId
updatedItem
.
guid
updatedItem
.
parentGuid
"
"
updatedItem
.
source
]
)
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
title
"
)
)
{
let
isTagging
=
updatedItem
.
parentGuid
=
=
Bookmarks
.
tagsGuid
;
notify
(
observers
"
onItemChanged
"
[
updatedItem
.
_id
"
title
"
false
updatedItem
.
title
PlacesUtils
.
toPRTime
(
updatedItem
.
lastModified
)
updatedItem
.
type
updatedItem
.
_parentId
updatedItem
.
guid
updatedItem
.
parentGuid
"
"
updatedItem
.
source
]
{
isTagging
}
)
;
if
(
isTagging
)
{
let
URIs
=
PlacesUtils
.
tagging
.
getURIsForTag
(
updatedItem
.
title
)
;
for
(
let
uri
of
URIs
)
{
for
(
let
entry
of
(
await
fetchBookmarksByURL
(
{
url
:
new
URL
(
uri
.
spec
)
}
true
)
)
)
{
notify
(
observers
"
onItemChanged
"
[
entry
.
_id
"
tags
"
false
"
"
PlacesUtils
.
toPRTime
(
entry
.
lastModified
)
entry
.
type
entry
.
_parentId
entry
.
guid
entry
.
parentGuid
"
"
updatedItem
.
source
]
)
;
}
}
}
}
if
(
updateInfo
.
hasOwnProperty
(
"
url
"
)
)
{
await
PlacesUtils
.
keywords
.
reassign
(
item
.
url
updatedItem
.
url
updatedItem
.
source
)
;
notify
(
observers
"
onItemChanged
"
[
updatedItem
.
_id
"
uri
"
false
updatedItem
.
url
.
href
PlacesUtils
.
toPRTime
(
updatedItem
.
lastModified
)
updatedItem
.
type
updatedItem
.
_parentId
updatedItem
.
guid
updatedItem
.
parentGuid
item
.
url
.
href
updatedItem
.
source
]
)
;
}
if
(
item
.
parentGuid
!
=
updatedItem
.
parentGuid
|
|
item
.
index
!
=
updatedItem
.
index
)
{
notify
(
observers
"
onItemMoved
"
[
updatedItem
.
_id
item
.
_parentId
item
.
index
updatedItem
.
_parentId
updatedItem
.
index
updatedItem
.
type
updatedItem
.
guid
item
.
parentGuid
updatedItem
.
parentGuid
updatedItem
.
source
updatedItem
.
url
&
&
updatedItem
.
url
.
href
]
)
;
}
delete
updatedItem
.
source
;
return
Object
.
assign
(
{
}
updatedItem
)
;
}
)
;
}
)
(
)
;
}
moveToFolder
(
guids
parentGuid
index
source
)
{
if
(
!
Array
.
isArray
(
guids
)
|
|
guids
.
length
<
1
)
{
throw
new
Error
(
"
guids
should
be
an
array
of
at
least
one
item
"
)
;
}
if
(
!
guids
.
every
(
guid
=
>
PlacesUtils
.
isValidGuid
(
guid
)
)
)
{
throw
new
Error
(
"
Expected
only
valid
GUIDs
to
be
passed
.
"
)
;
}
if
(
parentGuid
&
&
!
PlacesUtils
.
isValidGuid
(
parentGuid
)
)
{
throw
new
Error
(
"
parentGuid
should
be
a
valid
GUID
"
)
;
}
if
(
parentGuid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
)
{
throw
new
Error
(
"
Cannot
move
bookmarks
into
root
.
"
)
;
}
if
(
typeof
index
!
=
"
number
"
|
|
index
<
this
.
DEFAULT_INDEX
)
{
throw
new
Error
(
index
should
be
a
number
greater
than
{
this
.
DEFAULT_INDEX
}
)
;
}
if
(
!
source
)
{
source
=
this
.
SOURCES
.
DEFAULT
;
}
return
(
async
(
)
=
>
{
let
updateInfos
=
[
]
;
let
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
source
)
;
await
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
moveToFolder
"
async
db
=
>
{
const
lastModified
=
new
Date
(
)
;
let
targetParentGuid
=
parentGuid
|
|
undefined
;
for
(
let
guid
of
guids
)
{
let
existingItem
=
await
fetchBookmark
(
{
guid
}
false
db
)
;
if
(
!
existingItem
)
throw
new
Error
(
"
No
bookmarks
found
for
the
provided
GUID
"
)
;
if
(
parentGuid
)
{
if
(
existingItem
.
type
=
=
this
.
TYPE_FOLDER
)
{
let
rows
=
await
db
.
executeCached
(
WITH
RECURSIVE
descendants
(
did
)
AS
(
VALUES
(
:
id
)
UNION
ALL
SELECT
id
FROM
moz_bookmarks
JOIN
descendants
ON
parent
=
did
WHERE
type
=
:
type
)
SELECT
guid
FROM
moz_bookmarks
WHERE
id
IN
descendants
{
id
:
existingItem
.
_id
type
:
this
.
TYPE_FOLDER
}
)
;
if
(
rows
.
map
(
r
=
>
r
.
getResultByName
(
"
guid
"
)
)
.
includes
(
parentGuid
)
)
throw
new
Error
(
"
Cannot
insert
a
folder
into
itself
or
one
of
its
descendants
"
)
;
}
}
else
if
(
!
targetParentGuid
)
{
targetParentGuid
=
existingItem
.
parentGuid
;
}
else
if
(
existingItem
.
parentGuid
!
=
targetParentGuid
)
{
throw
new
Error
(
"
All
bookmarks
should
be
in
the
same
folder
if
no
parent
is
specified
"
)
;
}
updateInfos
.
push
(
{
existingItem
currIndex
:
existingItem
.
index
}
)
;
}
let
newParent
=
await
fetchBookmark
(
{
guid
:
targetParentGuid
}
false
db
)
;
if
(
newParent
.
_grandParentId
=
=
PlacesUtils
.
tagsFolderId
)
{
throw
new
Error
(
"
Can
'
t
move
to
a
tags
folder
"
)
;
}
let
newParentChildCount
=
newParent
.
_childCount
;
await
db
.
executeTransaction
(
async
(
)
=
>
{
for
(
let
i
=
0
;
i
<
updateInfos
.
length
;
i
+
+
)
{
let
info
=
updateInfos
[
i
]
;
if
(
index
!
=
this
.
DEFAULT_INDEX
)
{
if
(
info
.
existingItem
.
parentGuid
=
=
newParent
.
guid
)
{
if
(
index
>
info
.
existingItem
.
index
)
{
index
-
-
;
}
else
if
(
index
=
=
info
.
existingItem
.
index
)
{
info
.
updatedItem
=
{
.
.
.
info
.
existingItem
}
;
continue
;
}
}
}
if
(
index
=
=
this
.
DEFAULT_INDEX
|
|
index
>
=
newParentChildCount
)
{
index
=
newParentChildCount
;
if
(
info
.
existingItem
.
parentGuid
=
=
newParent
.
guid
)
{
index
-
-
;
}
}
info
.
updatedItem
=
await
updateBookmark
(
db
{
lastModified
index
}
info
.
existingItem
info
.
currIndex
newParent
syncChangeDelta
)
;
if
(
info
.
existingItem
.
parentGuid
=
=
newParent
.
guid
)
{
let
sign
=
index
<
info
.
currIndex
?
1
:
-
1
;
for
(
let
j
=
0
;
j
<
updateInfos
.
length
;
j
+
+
)
{
if
(
j
=
=
i
)
{
continue
;
}
if
(
updateInfos
[
j
]
.
currIndex
>
=
Math
.
min
(
info
.
currIndex
index
)
&
&
updateInfos
[
j
]
.
currIndex
<
=
Math
.
max
(
info
.
currIndex
index
)
)
{
updateInfos
[
j
]
.
currIndex
+
=
sign
;
}
}
}
info
.
currIndex
=
index
;
if
(
info
.
existingItem
.
parentGuid
!
=
newParent
.
guid
)
{
newParentChildCount
+
+
;
}
index
+
+
;
}
await
setAncestorsLastModified
(
db
newParent
.
guid
lastModified
syncChangeDelta
)
;
}
)
;
}
)
;
for
(
let
{
updatedItem
existingItem
}
of
updateInfos
)
{
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
if
(
existingItem
.
parentGuid
!
=
updatedItem
.
parentGuid
|
|
existingItem
.
index
!
=
updatedItem
.
index
)
{
notify
(
observers
"
onItemMoved
"
[
updatedItem
.
_id
existingItem
.
_parentId
existingItem
.
index
updatedItem
.
_parentId
updatedItem
.
index
updatedItem
.
type
updatedItem
.
guid
existingItem
.
parentGuid
updatedItem
.
parentGuid
source
existingItem
.
url
]
)
;
}
delete
updatedItem
.
source
;
}
return
updateInfos
.
map
(
updateInfo
=
>
Object
.
assign
(
{
}
updateInfo
.
updatedItem
)
)
;
}
)
(
)
;
}
remove
(
guidOrInfo
options
=
{
}
)
{
let
infos
=
guidOrInfo
;
if
(
!
infos
)
throw
new
Error
(
"
Input
should
be
a
valid
object
"
)
;
if
(
!
Array
.
isArray
(
guidOrInfo
)
)
{
if
(
typeof
(
guidOrInfo
)
!
=
"
object
"
)
{
infos
=
[
{
guid
:
guidOrInfo
}
]
;
}
else
{
infos
=
[
guidOrInfo
]
;
}
}
if
(
!
(
"
source
"
in
options
)
)
{
options
.
source
=
Bookmarks
.
SOURCES
.
DEFAULT
;
}
let
removeInfos
=
[
]
;
for
(
let
info
of
infos
)
{
if
(
[
Bookmarks
.
rootGuid
Bookmarks
.
menuGuid
Bookmarks
.
toolbarGuid
Bookmarks
.
unfiledGuid
Bookmarks
.
tagsGuid
Bookmarks
.
mobileGuid
]
.
includes
(
info
.
guid
)
)
{
throw
new
Error
(
"
It
'
s
not
possible
to
remove
Places
root
folders
.
"
)
;
}
let
removeInfo
=
validateBookmarkObject
(
"
Bookmarks
.
jsm
:
remove
"
info
)
;
removeInfos
.
push
(
removeInfo
)
;
}
return
(
async
function
(
)
{
let
removeItems
=
[
]
;
for
(
let
info
of
removeInfos
)
{
let
item
=
await
fetchBookmark
(
info
)
;
if
(
!
item
)
throw
new
Error
(
"
No
bookmarks
found
for
the
provided
GUID
.
"
)
;
removeItems
.
push
(
item
)
;
}
await
removeBookmarks
(
removeItems
options
)
;
for
(
let
item
of
removeItems
)
{
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
let
uri
=
item
.
hasOwnProperty
(
"
url
"
)
?
PlacesUtils
.
toURI
(
item
.
url
)
:
null
;
let
isUntagging
=
item
.
_grandParentId
=
=
PlacesUtils
.
tagsFolderId
;
notify
(
observers
"
onItemRemoved
"
[
item
.
_id
item
.
_parentId
item
.
index
item
.
type
uri
item
.
guid
item
.
parentGuid
options
.
source
]
{
isTagging
:
isUntagging
}
)
;
if
(
isUntagging
)
{
for
(
let
entry
of
(
await
fetchBookmarksByURL
(
item
true
)
)
)
{
notify
(
observers
"
onItemChanged
"
[
entry
.
_id
"
tags
"
false
"
"
PlacesUtils
.
toPRTime
(
entry
.
lastModified
)
entry
.
type
entry
.
_parentId
entry
.
guid
entry
.
parentGuid
"
"
options
.
source
]
)
;
}
}
}
}
)
(
)
;
}
eraseEverything
(
options
=
{
}
)
{
if
(
!
options
.
source
)
{
options
.
source
=
Bookmarks
.
SOURCES
.
DEFAULT
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
eraseEverything
"
async
function
(
db
)
{
let
urls
;
await
db
.
executeTransaction
(
async
function
(
)
{
urls
=
await
removeFoldersContents
(
db
Bookmarks
.
userContentRoots
options
)
;
const
time
=
PlacesUtils
.
toPRTime
(
new
Date
(
)
)
;
const
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
options
.
source
)
;
for
(
let
folderGuid
of
Bookmarks
.
userContentRoots
)
{
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
lastModified
=
:
time
syncChangeCounter
=
syncChangeCounter
+
:
syncChangeDelta
WHERE
id
IN
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
:
folderGuid
)
{
folderGuid
time
syncChangeDelta
}
)
;
}
await
PlacesSyncUtils
.
bookmarks
.
resetSyncMetadata
(
db
options
.
source
)
;
}
)
;
if
(
urls
&
&
urls
.
length
)
{
await
PlacesUtils
.
keywords
.
eraseEverything
(
)
;
updateFrecency
(
db
urls
true
)
.
catch
(
Cu
.
reportError
)
;
}
}
)
;
}
getRecent
(
numberOfItems
)
{
if
(
numberOfItems
=
=
=
undefined
)
{
throw
new
Error
(
"
numberOfItems
argument
is
required
"
)
;
}
if
(
!
typeof
numberOfItems
=
=
=
"
number
"
|
|
(
numberOfItems
%
1
)
!
=
=
0
)
{
throw
new
Error
(
"
numberOfItems
argument
must
be
an
integer
"
)
;
}
if
(
numberOfItems
<
=
0
)
{
throw
new
Error
(
"
numberOfItems
argument
must
be
greater
than
zero
"
)
;
}
return
fetchRecentBookmarks
(
numberOfItems
)
;
}
fetch
(
guidOrInfo
onResult
=
null
options
=
{
}
)
{
if
(
!
(
"
concurrent
"
in
options
)
)
{
options
.
concurrent
=
false
;
}
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
throw
new
Error
(
"
onResult
callback
must
be
a
valid
function
"
)
;
let
info
=
guidOrInfo
;
if
(
!
info
)
throw
new
Error
(
"
Input
should
be
a
valid
object
"
)
;
if
(
typeof
(
info
)
!
=
"
object
"
)
{
info
=
{
guid
:
guidOrInfo
}
;
}
else
if
(
Object
.
keys
(
info
)
.
length
=
=
1
)
{
if
(
!
[
"
url
"
"
guid
"
"
parentGuid
"
"
index
"
"
guidPrefix
"
]
.
includes
(
Object
.
keys
(
info
)
[
0
]
)
)
throw
new
Error
(
Unexpected
number
of
conditions
provided
:
0
)
;
}
else
{
let
conditionsCount
=
[
v
=
>
v
.
hasOwnProperty
(
"
guid
"
)
v
=
>
v
.
hasOwnProperty
(
"
parentGuid
"
)
&
&
v
.
hasOwnProperty
(
"
index
"
)
v
=
>
v
.
hasOwnProperty
(
"
url
"
)
v
=
>
v
.
hasOwnProperty
(
"
guidPrefix
"
)
]
.
reduce
(
(
old
fn
)
=
>
old
+
fn
(
info
)
|
0
0
)
;
if
(
conditionsCount
!
=
1
)
throw
new
Error
(
Unexpected
number
of
conditions
provided
:
{
conditionsCount
}
)
;
}
let
behavior
=
{
}
;
if
(
info
.
hasOwnProperty
(
"
parentGuid
"
)
|
|
info
.
hasOwnProperty
(
"
index
"
)
)
{
behavior
=
{
parentGuid
:
{
requiredIf
:
b
=
>
b
.
hasOwnProperty
(
"
index
"
)
}
index
:
{
requiredIf
:
b
=
>
b
.
hasOwnProperty
(
"
parentGuid
"
)
validIf
:
b
=
>
typeof
(
b
.
index
)
=
=
"
number
"
&
&
b
.
index
>
=
0
|
|
b
.
index
=
=
this
.
DEFAULT_INDEX
}
}
;
}
let
fetchInfo
=
validateBookmarkObject
(
"
Bookmarks
.
jsm
:
fetch
"
info
behavior
)
;
return
(
async
function
(
)
{
let
results
;
if
(
fetchInfo
.
hasOwnProperty
(
"
url
"
)
)
results
=
await
fetchBookmarksByURL
(
fetchInfo
options
&
&
options
.
concurrent
)
;
else
if
(
fetchInfo
.
hasOwnProperty
(
"
guid
"
)
)
results
=
await
fetchBookmark
(
fetchInfo
options
&
&
options
.
concurrent
)
;
else
if
(
fetchInfo
.
hasOwnProperty
(
"
parentGuid
"
)
&
&
fetchInfo
.
hasOwnProperty
(
"
index
"
)
)
results
=
await
fetchBookmarkByPosition
(
fetchInfo
options
&
&
options
.
concurrent
)
;
else
if
(
fetchInfo
.
hasOwnProperty
(
"
guidPrefix
"
)
)
results
=
await
fetchBookmarksByGUIDPrefix
(
fetchInfo
options
&
&
options
.
concurrent
)
;
if
(
!
results
)
return
null
;
if
(
!
Array
.
isArray
(
results
)
)
results
=
[
results
]
;
results
=
results
.
map
(
r
=
>
Object
.
assign
(
{
}
r
)
)
;
if
(
onResult
)
{
for
(
let
result
of
results
)
{
try
{
onResult
(
result
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
return
results
[
0
]
;
}
)
(
)
;
}
fetchTree
(
guid
=
"
"
options
=
{
}
)
{
throw
new
Error
(
"
Not
yet
implemented
"
)
;
}
async
fetchTags
(
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
b
.
title
AS
name
count
(
*
)
AS
count
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
b
.
parent
=
p
.
id
JOIN
moz_bookmarks
c
ON
c
.
parent
=
b
.
id
WHERE
p
.
guid
=
:
tagsGuid
GROUP
BY
name
ORDER
BY
name
COLLATE
nocase
ASC
{
tagsGuid
:
this
.
tagsGuid
}
)
;
return
rows
.
map
(
r
=
>
(
{
name
:
r
.
getResultByName
(
"
name
"
)
count
:
r
.
getResultByName
(
"
count
"
)
}
)
)
;
}
reorder
(
parentGuid
orderedChildrenGuids
options
=
{
}
)
{
let
info
=
{
guid
:
parentGuid
}
;
info
=
validateBookmarkObject
(
"
Bookmarks
.
jsm
:
reorder
"
info
{
guid
:
{
required
:
true
}
}
)
;
if
(
!
Array
.
isArray
(
orderedChildrenGuids
)
|
|
!
orderedChildrenGuids
.
length
)
throw
new
Error
(
"
Must
provide
a
sorted
array
of
children
GUIDs
.
"
)
;
try
{
orderedChildrenGuids
.
forEach
(
PlacesUtils
.
BOOKMARK_VALIDATORS
.
guid
)
;
}
catch
(
ex
)
{
throw
new
Error
(
"
Invalid
GUID
found
in
the
sorted
children
array
.
"
)
;
}
if
(
!
(
"
source
"
in
options
)
)
{
options
.
source
=
Bookmarks
.
SOURCES
.
DEFAULT
;
}
return
(
async
(
)
=
>
{
let
parent
=
await
fetchBookmark
(
info
)
;
if
(
!
parent
|
|
parent
.
type
!
=
this
.
TYPE_FOLDER
)
throw
new
Error
(
"
No
folder
found
for
the
provided
GUID
.
"
)
;
let
sortedChildren
=
await
reorderChildren
(
parent
orderedChildrenGuids
options
)
;
let
{
source
=
Bookmarks
.
SOURCES
.
DEFAULT
}
=
options
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
for
(
let
i
=
0
;
i
<
sortedChildren
.
length
;
+
+
i
)
{
let
child
=
sortedChildren
[
i
]
;
notify
(
observers
"
onItemMoved
"
[
child
.
_id
child
.
_parentId
child
.
index
child
.
_parentId
i
child
.
type
child
.
guid
child
.
parentGuid
child
.
parentGuid
source
child
.
url
&
&
child
.
url
.
href
]
)
;
}
}
)
(
)
;
}
search
(
query
)
{
if
(
!
query
)
{
throw
new
Error
(
"
Query
object
is
required
"
)
;
}
if
(
typeof
query
=
=
=
"
string
"
)
{
query
=
{
query
}
;
}
if
(
typeof
query
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Query
must
be
an
object
or
a
string
"
)
;
}
if
(
query
.
query
&
&
typeof
query
.
query
!
=
=
"
string
"
)
{
throw
new
Error
(
"
Query
option
must
be
a
string
"
)
;
}
if
(
query
.
title
&
&
typeof
query
.
title
!
=
=
"
string
"
)
{
throw
new
Error
(
"
Title
option
must
be
a
string
"
)
;
}
if
(
query
.
url
)
{
if
(
typeof
query
.
url
=
=
=
"
string
"
|
|
(
query
.
url
instanceof
URL
)
)
{
query
.
url
=
new
URL
(
query
.
url
)
.
href
;
}
else
if
(
query
.
url
instanceof
Ci
.
nsIURI
)
{
query
.
url
=
query
.
url
.
spec
;
}
else
{
throw
new
Error
(
"
Url
option
must
be
a
string
or
a
URL
object
"
)
;
}
}
return
queryBookmarks
(
query
)
;
}
}
)
;
function
notify
(
observers
notification
args
=
[
]
information
=
{
}
)
{
for
(
let
observer
of
observers
)
{
if
(
information
.
isTagging
&
&
observer
.
skipTags
)
{
continue
;
}
if
(
information
.
isDescendantRemoval
&
&
observer
.
skipDescendantsOnItemRemoval
&
&
!
(
PlacesUtils
.
bookmarks
.
userContentRoots
.
includes
(
information
.
parentGuid
)
)
)
{
continue
;
}
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
}
}
}
async
function
updateBookmark
(
db
info
item
oldIndex
newParent
syncChangeDelta
)
{
let
tuples
=
new
Map
(
)
;
tuples
.
set
(
"
lastModified
"
{
value
:
PlacesUtils
.
toPRTime
(
info
.
lastModified
)
}
)
;
if
(
info
.
hasOwnProperty
(
"
title
"
)
)
{
tuples
.
set
(
"
title
"
{
value
:
info
.
title
fragment
:
title
=
NULLIF
(
:
title
"
"
)
}
)
;
}
if
(
info
.
hasOwnProperty
(
"
dateAdded
"
)
)
{
tuples
.
set
(
"
dateAdded
"
{
value
:
PlacesUtils
.
toPRTime
(
info
.
dateAdded
)
}
)
;
}
if
(
info
.
hasOwnProperty
(
"
url
"
)
)
{
await
maybeInsertPlace
(
db
info
.
url
)
;
tuples
.
set
(
"
url
"
{
value
:
info
.
url
.
href
fragment
:
"
fk
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
"
}
)
;
}
let
newIndex
=
info
.
hasOwnProperty
(
"
index
"
)
?
info
.
index
:
item
.
index
;
if
(
newParent
)
{
tuples
.
set
(
"
position
"
{
value
:
newIndex
}
)
;
if
(
newParent
.
guid
=
=
item
.
parentGuid
)
{
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
position
=
CASE
WHEN
:
newIndex
<
:
currIndex
THEN
position
+
1
ELSE
position
-
1
END
WHERE
parent
=
:
newParentId
AND
position
BETWEEN
:
lowIndex
AND
:
highIndex
{
newIndex
currIndex
:
oldIndex
newParentId
:
newParent
.
_id
lowIndex
:
Math
.
min
(
oldIndex
newIndex
)
highIndex
:
Math
.
max
(
oldIndex
newIndex
)
}
)
;
}
else
{
tuples
.
set
(
"
parent
"
{
value
:
newParent
.
_id
}
)
;
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
position
=
position
-
1
WHERE
parent
=
:
oldParentId
AND
position
>
=
:
oldIndex
{
oldParentId
:
item
.
_parentId
oldIndex
}
)
;
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
position
=
position
+
1
WHERE
parent
=
:
newParentId
AND
position
>
=
:
newIndex
{
newParentId
:
newParent
.
_id
newIndex
}
)
;
await
setAncestorsLastModified
(
db
item
.
parentGuid
info
.
lastModified
syncChangeDelta
)
;
}
}
if
(
syncChangeDelta
)
{
let
sizeThreshold
=
1
;
if
(
newIndex
!
=
oldIndex
)
{
+
+
sizeThreshold
;
}
if
(
tuples
.
has
(
"
dateAdded
"
)
)
{
+
+
sizeThreshold
;
}
let
needsSyncChange
=
tuples
.
size
>
sizeThreshold
;
if
(
needsSyncChange
)
{
tuples
.
set
(
"
syncChangeDelta
"
{
value
:
syncChangeDelta
fragment
:
"
syncChangeCounter
=
syncChangeCounter
+
:
syncChangeDelta
"
}
)
;
}
}
let
isTagging
=
item
.
_grandParentId
=
=
PlacesUtils
.
tagsFolderId
;
if
(
isTagging
)
{
await
PlacesSyncUtils
.
bookmarks
.
addSyncChangesForBookmarksWithURL
(
db
item
.
url
syncChangeDelta
)
;
if
(
info
.
hasOwnProperty
(
"
url
"
)
)
{
await
PlacesSyncUtils
.
bookmarks
.
addSyncChangesForBookmarksWithURL
(
db
info
.
url
syncChangeDelta
)
;
}
}
let
isChangingTagFolder
=
item
.
_parentId
=
=
PlacesUtils
.
tagsFolderId
;
if
(
isChangingTagFolder
&
&
syncChangeDelta
)
{
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
:
syncChangeDelta
WHERE
type
=
:
type
AND
fk
=
(
SELECT
fk
FROM
moz_bookmarks
WHERE
parent
=
:
parent
)
{
syncChangeDelta
type
:
Bookmarks
.
TYPE_BOOKMARK
parent
:
item
.
_id
}
)
;
}
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
{
Array
.
from
(
tuples
.
keys
(
)
)
.
map
(
v
=
>
tuples
.
get
(
v
)
.
fragment
|
|
{
v
}
=
:
{
v
}
)
.
join
(
"
"
)
}
WHERE
guid
=
:
guid
Object
.
assign
(
{
guid
:
item
.
guid
}
[
.
.
.
tuples
.
entries
(
)
]
.
reduce
(
(
p
c
)
=
>
{
p
[
c
[
0
]
]
=
c
[
1
]
.
value
;
return
p
;
}
{
}
)
)
)
;
if
(
newParent
)
{
if
(
newParent
.
guid
=
=
item
.
parentGuid
)
{
const
startIndex
=
Math
.
min
(
newIndex
oldIndex
)
;
await
adjustSeparatorsSyncCounter
(
db
newParent
.
_id
startIndex
syncChangeDelta
)
;
}
else
{
await
adjustSeparatorsSyncCounter
(
db
item
.
_parentId
oldIndex
syncChangeDelta
)
;
await
adjustSeparatorsSyncCounter
(
db
newParent
.
_id
newIndex
syncChangeDelta
)
;
}
await
db
.
executeCached
(
DELETE
FROM
moz_items_annos
WHERE
anno_attribute_id
=
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
:
orphanAnno
)
AND
item_id
=
:
id
{
orphanAnno
:
PlacesSyncUtils
.
bookmarks
.
SYNC_PARENT_ANNO
id
:
item
.
_id
}
)
;
}
let
additionalParentInfo
=
{
}
;
if
(
newParent
)
{
additionalParentInfo
.
parentGuid
=
newParent
.
guid
;
Object
.
defineProperty
(
additionalParentInfo
"
_parentId
"
{
value
:
newParent
.
_id
enumerable
:
false
}
)
;
Object
.
defineProperty
(
additionalParentInfo
"
_grandParentId
"
{
value
:
newParent
.
_parentId
enumerable
:
false
}
)
;
}
return
mergeIntoNewObject
(
item
info
additionalParentInfo
)
;
}
function
insertBookmark
(
item
parent
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
insertBookmark
"
async
function
(
db
)
{
let
hasExistingGuid
=
item
.
hasOwnProperty
(
"
guid
"
)
;
if
(
!
hasExistingGuid
)
item
.
guid
=
PlacesUtils
.
history
.
makeGuid
(
)
;
let
isTagging
=
parent
.
_parentId
=
=
PlacesUtils
.
tagsFolderId
;
await
db
.
executeTransaction
(
async
function
transaction
(
)
{
if
(
item
.
type
=
=
Bookmarks
.
TYPE_BOOKMARK
)
{
await
maybeInsertPlace
(
db
item
.
url
)
;
}
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
position
=
position
+
1
WHERE
parent
=
:
parent
AND
position
>
=
:
index
{
parent
:
parent
.
_id
index
:
item
.
index
}
)
;
let
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
item
.
source
)
;
let
syncStatus
=
PlacesSyncUtils
.
bookmarks
.
determineInitialSyncStatus
(
item
.
source
)
;
await
db
.
executeCached
(
INSERT
INTO
moz_bookmarks
(
fk
type
parent
position
title
dateAdded
lastModified
guid
syncChangeCounter
syncStatus
)
VALUES
(
CASE
WHEN
:
url
ISNULL
THEN
NULL
ELSE
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
END
:
type
:
parent
:
index
NULLIF
(
:
title
"
"
)
:
date_added
:
last_modified
:
guid
:
syncChangeCounter
:
syncStatus
)
{
url
:
item
.
hasOwnProperty
(
"
url
"
)
?
item
.
url
.
href
:
null
type
:
item
.
type
parent
:
parent
.
_id
index
:
item
.
index
title
:
item
.
title
date_added
:
PlacesUtils
.
toPRTime
(
item
.
dateAdded
)
last_modified
:
PlacesUtils
.
toPRTime
(
item
.
lastModified
)
guid
:
item
.
guid
syncChangeCounter
:
syncChangeDelta
syncStatus
}
)
;
await
adjustSeparatorsSyncCounter
(
db
parent
.
_id
item
.
index
+
1
syncChangeDelta
)
;
if
(
hasExistingGuid
)
{
await
db
.
executeCached
(
DELETE
FROM
moz_bookmarks_deleted
WHERE
guid
=
:
guid
{
guid
:
item
.
guid
}
)
;
}
if
(
isTagging
)
{
await
PlacesSyncUtils
.
bookmarks
.
addSyncChangesForBookmarksWithURL
(
db
item
.
url
syncChangeDelta
)
;
}
await
setAncestorsLastModified
(
db
item
.
parentGuid
item
.
dateAdded
syncChangeDelta
)
;
}
)
;
if
(
item
.
type
=
=
Bookmarks
.
TYPE_BOOKMARK
&
&
!
isTagging
)
{
updateFrecency
(
db
[
item
.
url
]
)
.
catch
(
Cu
.
reportError
)
;
}
return
item
;
}
)
;
}
function
isLivemark
(
node
)
{
return
node
.
type
=
=
Bookmarks
.
TYPE_FOLDER
&
&
node
.
annos
&
&
node
.
annos
.
some
(
anno
=
>
anno
.
name
=
=
PlacesUtils
.
LMANNO_FEEDURI
)
;
}
function
insertBookmarkTree
(
items
source
parent
urls
lastAddedForParent
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
insertBookmarkTree
"
async
function
(
db
)
{
await
db
.
executeTransaction
(
async
function
transaction
(
)
{
await
maybeInsertManyPlaces
(
db
urls
)
;
let
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
source
)
;
let
syncStatus
=
PlacesSyncUtils
.
bookmarks
.
determineInitialSyncStatus
(
source
)
;
let
rootId
=
parent
.
_id
;
items
=
items
.
map
(
item
=
>
(
{
url
:
item
.
url
&
&
item
.
url
.
href
type
:
item
.
type
parentGuid
:
item
.
parentGuid
index
:
item
.
index
title
:
item
.
title
date_added
:
PlacesUtils
.
toPRTime
(
item
.
dateAdded
)
last_modified
:
PlacesUtils
.
toPRTime
(
item
.
lastModified
)
guid
:
item
.
guid
syncChangeCounter
:
syncChangeDelta
syncStatus
rootId
}
)
)
;
await
db
.
executeCached
(
INSERT
INTO
moz_bookmarks
(
fk
type
parent
position
title
dateAdded
lastModified
guid
syncChangeCounter
syncStatus
)
VALUES
(
CASE
WHEN
:
url
ISNULL
THEN
NULL
ELSE
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
END
:
type
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
:
parentGuid
)
IFNULL
(
:
index
(
SELECT
count
(
*
)
FROM
moz_bookmarks
WHERE
parent
=
:
rootId
)
)
NULLIF
(
:
title
"
"
)
:
date_added
:
last_modified
:
guid
:
syncChangeCounter
:
syncStatus
)
items
)
;
for
(
let
chunk
of
chunkArray
(
items
SQLITE_MAX_VARIABLE_NUMBER
)
)
{
await
db
.
executeCached
(
DELETE
FROM
moz_bookmarks_deleted
WHERE
guid
IN
(
{
new
Array
(
chunk
.
length
)
.
fill
(
"
?
"
)
.
join
(
"
"
)
}
)
chunk
.
map
(
item
=
>
item
.
guid
)
)
;
}
await
setAncestorsLastModified
(
db
parent
.
guid
lastAddedForParent
syncChangeDelta
)
;
}
)
;
updateFrecency
(
db
urls
true
)
.
catch
(
Cu
.
reportError
)
;
return
items
;
}
)
;
}
async
function
insertLivemarkData
(
item
)
{
let
placeholder
=
await
Bookmarks
.
fetch
(
item
.
guid
)
;
let
index
=
placeholder
.
index
;
await
removeBookmarks
(
[
item
]
{
source
:
item
.
source
}
)
;
let
feedURI
=
null
;
let
siteURI
=
null
;
item
.
annos
=
item
.
annos
.
filter
(
function
(
aAnno
)
{
switch
(
aAnno
.
name
)
{
case
PlacesUtils
.
LMANNO_FEEDURI
:
feedURI
=
NetUtil
.
newURI
(
aAnno
.
value
)
;
return
false
;
case
PlacesUtils
.
LMANNO_SITEURI
:
siteURI
=
NetUtil
.
newURI
(
aAnno
.
value
)
;
return
false
;
default
:
return
true
;
}
}
)
;
if
(
feedURI
)
{
item
.
feedURI
=
feedURI
;
item
.
siteURI
=
siteURI
;
item
.
index
=
index
;
if
(
item
.
dateAdded
)
{
item
.
dateAdded
=
PlacesUtils
.
toPRTime
(
item
.
dateAdded
)
;
}
if
(
item
.
lastModified
)
{
item
.
lastModified
=
PlacesUtils
.
toPRTime
(
item
.
lastModified
)
;
}
let
livemark
=
await
PlacesUtils
.
livemarks
.
addLivemark
(
item
)
;
let
id
=
livemark
.
id
;
if
(
item
.
annos
&
&
item
.
annos
.
length
)
{
PlacesUtils
.
setAnnotationsForItem
(
id
item
.
annos
item
.
source
true
)
;
}
}
}
async
function
handleBookmarkItemSpecialData
(
itemId
item
)
{
if
(
item
.
annos
&
&
item
.
annos
.
length
)
{
try
{
PlacesUtils
.
setAnnotationsForItem
(
itemId
item
.
annos
item
.
source
true
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Failed
to
insert
annotations
for
item
:
{
ex
}
)
;
}
}
if
(
"
keyword
"
in
item
&
&
item
.
keyword
)
{
try
{
await
PlacesUtils
.
keywords
.
insert
(
{
keyword
:
item
.
keyword
url
:
item
.
url
postData
:
item
.
postData
source
:
item
.
source
}
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Failed
to
insert
keyword
"
{
item
.
keyword
}
for
{
item
.
url
}
"
:
{
ex
}
)
;
}
}
if
(
"
tags
"
in
item
)
{
try
{
PlacesUtils
.
tagging
.
tagURI
(
NetUtil
.
newURI
(
item
.
url
)
item
.
tags
item
.
source
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Unable
to
set
tags
"
{
item
.
tags
.
join
(
"
"
)
}
"
for
{
item
.
url
}
:
{
ex
}
)
;
}
}
if
(
"
charset
"
in
item
&
&
item
.
charset
)
{
try
{
await
PlacesUtils
.
setCharsetForURI
(
NetUtil
.
newURI
(
item
.
url
)
item
.
charset
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Failed
to
set
charset
"
{
item
.
charset
}
"
for
{
item
.
url
}
:
{
ex
}
)
;
}
}
}
async
function
queryBookmarks
(
info
)
{
let
queryParams
=
{
tags_folder
:
await
promiseTagsFolderId
(
)
}
;
let
queryString
=
"
WHERE
b
.
parent
<
>
:
tags_folder
"
;
queryString
+
=
"
AND
p
.
parent
<
>
:
tags_folder
"
;
if
(
info
.
title
)
{
queryString
+
=
"
AND
b
.
title
=
:
title
"
;
queryParams
.
title
=
info
.
title
;
}
if
(
info
.
url
)
{
queryString
+
=
"
AND
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
"
;
queryParams
.
url
=
info
.
url
;
}
if
(
info
.
query
)
{
queryString
+
=
"
AND
AUTOCOMPLETE_MATCH
(
:
query
h
.
url
b
.
title
NULL
NULL
1
1
NULL
:
matchBehavior
:
searchBehavior
)
"
;
queryParams
.
query
=
info
.
query
;
queryParams
.
matchBehavior
=
MATCH_ANYWHERE_UNMODIFIED
;
queryParams
.
searchBehavior
=
BEHAVIOR_BOOKMARK
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
queryBookmarks
"
async
function
(
db
)
{
let
rows
=
await
db
.
executeCached
(
SELECT
b
.
guid
IFNULL
(
p
.
guid
"
"
)
AS
parentGuid
b
.
position
AS
'
index
'
b
.
dateAdded
b
.
lastModified
b
.
type
IFNULL
(
b
.
title
"
"
)
AS
title
h
.
url
AS
url
b
.
parent
p
.
parent
NULL
AS
_id
NULL
AS
_childCount
NULL
AS
_grandParentId
NULL
AS
_parentId
NULL
AS
_syncStatus
FROM
moz_bookmarks
b
LEFT
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
{
queryString
}
queryParams
)
;
return
rowsToItemsArray
(
rows
)
;
}
)
;
}
async
function
fetchBookmark
(
info
concurrent
db
)
{
let
query
=
async
function
(
db
)
{
let
rows
=
await
db
.
executeCached
(
SELECT
b
.
guid
IFNULL
(
p
.
guid
"
"
)
AS
parentGuid
b
.
position
AS
'
index
'
b
.
dateAdded
b
.
lastModified
b
.
type
IFNULL
(
b
.
title
"
"
)
AS
title
h
.
url
AS
url
b
.
id
AS
_id
b
.
parent
AS
_parentId
(
SELECT
count
(
*
)
FROM
moz_bookmarks
WHERE
parent
=
b
.
id
)
AS
_childCount
p
.
parent
AS
_grandParentId
b
.
syncStatus
AS
_syncStatus
FROM
moz_bookmarks
b
LEFT
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
WHERE
b
.
guid
=
:
guid
{
guid
:
info
.
guid
}
)
;
return
rows
.
length
?
rowsToItemsArray
(
rows
)
[
0
]
:
null
;
}
;
if
(
concurrent
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
return
query
(
db
)
;
}
if
(
db
)
{
return
query
(
db
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
fetchBookmark
"
query
)
;
}
async
function
fetchBookmarkByPosition
(
info
concurrent
)
{
let
query
=
async
function
(
db
)
{
let
index
=
info
.
index
=
=
Bookmarks
.
DEFAULT_INDEX
?
null
:
info
.
index
;
let
rows
=
await
db
.
executeCached
(
SELECT
b
.
guid
IFNULL
(
p
.
guid
"
"
)
AS
parentGuid
b
.
position
AS
'
index
'
b
.
dateAdded
b
.
lastModified
b
.
type
IFNULL
(
b
.
title
"
"
)
AS
title
h
.
url
AS
url
b
.
id
AS
_id
b
.
parent
AS
_parentId
(
SELECT
count
(
*
)
FROM
moz_bookmarks
WHERE
parent
=
b
.
id
)
AS
_childCount
p
.
parent
AS
_grandParentId
b
.
syncStatus
AS
_syncStatus
FROM
moz_bookmarks
b
LEFT
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
WHERE
p
.
guid
=
:
parentGuid
AND
b
.
position
=
IFNULL
(
:
index
(
SELECT
count
(
*
)
-
1
FROM
moz_bookmarks
WHERE
parent
=
p
.
id
)
)
{
parentGuid
:
info
.
parentGuid
index
}
)
;
return
rows
.
length
?
rowsToItemsArray
(
rows
)
[
0
]
:
null
;
}
;
if
(
concurrent
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
return
query
(
db
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
fetchBookmarkByPosition
"
query
)
;
}
async
function
fetchBookmarksByGUIDPrefix
(
info
concurrent
)
{
let
query
=
async
function
(
db
)
{
let
rows
=
await
db
.
executeCached
(
SELECT
b
.
guid
IFNULL
(
p
.
guid
"
"
)
AS
parentGuid
b
.
position
AS
'
index
'
b
.
dateAdded
b
.
lastModified
b
.
type
IFNULL
(
b
.
title
"
"
)
AS
title
h
.
url
AS
url
b
.
id
AS
_id
b
.
parent
AS
_parentId
NULL
AS
_childCount
p
.
parent
AS
_grandParentId
b
.
syncStatus
AS
_syncStatus
FROM
moz_bookmarks
b
LEFT
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
WHERE
b
.
guid
LIKE
:
guidPrefix
ORDER
BY
b
.
lastModified
DESC
{
guidPrefix
:
info
.
guidPrefix
+
"
%
"
}
)
;
return
rows
.
length
?
rowsToItemsArray
(
rows
)
:
null
;
}
;
if
(
concurrent
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
return
query
(
db
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
fetchBookmarksByGUIDPrefix
"
query
)
;
}
async
function
fetchBookmarksByURL
(
info
concurrent
)
{
let
query
=
async
function
(
db
)
{
let
tagsFolderId
=
await
promiseTagsFolderId
(
)
;
let
rows
=
await
db
.
executeCached
(
/
*
do
not
warn
(
bug
no
)
:
not
worth
to
add
an
index
*
/
SELECT
b
.
guid
IFNULL
(
p
.
guid
"
"
)
AS
parentGuid
b
.
position
AS
'
index
'
b
.
dateAdded
b
.
lastModified
b
.
type
IFNULL
(
b
.
title
"
"
)
AS
title
h
.
url
AS
url
b
.
id
AS
_id
b
.
parent
AS
_parentId
NULL
AS
_childCount
/
*
Unused
for
now
*
/
p
.
parent
AS
_grandParentId
b
.
syncStatus
AS
_syncStatus
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
WHERE
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
AND
_grandParentId
<
>
:
tagsFolderId
ORDER
BY
b
.
lastModified
DESC
{
url
:
info
.
url
.
href
tagsFolderId
}
)
;
return
rows
.
length
?
rowsToItemsArray
(
rows
)
:
null
;
}
;
if
(
concurrent
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
return
query
(
db
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
fetchBookmarksByURL
"
query
)
;
}
function
fetchRecentBookmarks
(
numberOfItems
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
fetchRecentBookmarks
"
async
function
(
db
)
{
let
tagsFolderId
=
await
promiseTagsFolderId
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
b
.
guid
IFNULL
(
p
.
guid
"
"
)
AS
parentGuid
b
.
position
AS
'
index
'
b
.
dateAdded
b
.
lastModified
b
.
type
IFNULL
(
b
.
title
"
"
)
AS
title
h
.
url
AS
url
NULL
AS
_id
NULL
AS
_parentId
NULL
AS
_childCount
NULL
AS
_grandParentId
NULL
AS
_syncStatus
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
WHERE
p
.
parent
<
>
:
tagsFolderId
AND
b
.
type
=
:
type
AND
url_hash
NOT
BETWEEN
hash
(
"
place
"
"
prefix_lo
"
)
AND
hash
(
"
place
"
"
prefix_hi
"
)
ORDER
BY
b
.
dateAdded
DESC
b
.
ROWID
DESC
LIMIT
:
numberOfItems
{
tagsFolderId
type
:
Bookmarks
.
TYPE_BOOKMARK
numberOfItems
}
)
;
return
rows
.
length
?
rowsToItemsArray
(
rows
)
:
[
]
;
}
)
;
}
async
function
fetchBookmarksByParent
(
db
info
)
{
let
rows
=
await
db
.
executeCached
(
SELECT
b
.
guid
IFNULL
(
p
.
guid
"
"
)
AS
parentGuid
b
.
position
AS
'
index
'
b
.
dateAdded
b
.
lastModified
b
.
type
IFNULL
(
b
.
title
"
"
)
AS
title
h
.
url
AS
url
b
.
id
AS
_id
b
.
parent
AS
_parentId
(
SELECT
count
(
*
)
FROM
moz_bookmarks
WHERE
parent
=
b
.
id
)
AS
_childCount
p
.
parent
AS
_grandParentId
b
.
syncStatus
AS
_syncStatus
FROM
moz_bookmarks
b
LEFT
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
WHERE
p
.
guid
=
:
parentGuid
ORDER
BY
b
.
position
ASC
{
parentGuid
:
info
.
parentGuid
}
)
;
return
rowsToItemsArray
(
rows
)
;
}
function
removeBookmarks
(
items
options
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
removeBookmarks
"
async
function
(
db
)
{
let
urls
=
[
]
;
await
db
.
executeTransaction
(
async
function
transaction
(
)
{
let
parentGuids
=
new
Set
(
)
;
let
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
options
.
source
)
;
for
(
let
item
of
items
)
{
parentGuids
.
add
(
item
.
parentGuid
)
;
if
(
item
.
type
=
=
Bookmarks
.
TYPE_FOLDER
)
{
if
(
options
.
preventRemovalOfNonEmptyFolders
&
&
item
.
_childCount
>
0
)
{
throw
new
Error
(
"
Cannot
remove
a
non
-
empty
folder
.
"
)
;
}
urls
=
urls
.
concat
(
await
removeFoldersContents
(
db
[
item
.
guid
]
options
)
)
;
}
}
for
(
let
chunk
of
chunkArray
(
items
SQLITE_MAX_VARIABLE_NUMBER
)
)
{
await
removeAnnotationsForItems
(
db
chunk
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_bookmarks
WHERE
guid
IN
(
{
new
Array
(
chunk
.
length
)
.
fill
(
"
?
"
)
.
join
(
"
"
)
}
)
chunk
.
map
(
item
=
>
item
.
guid
)
)
;
}
for
(
let
item
of
items
)
{
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
position
=
position
-
1
WHERE
parent
=
:
parentId
AND
position
>
:
index
{
parentId
:
item
.
_parentId
index
:
item
.
index
}
)
;
if
(
item
.
_grandParentId
=
=
PlacesUtils
.
tagsFolderId
)
{
await
PlacesSyncUtils
.
bookmarks
.
addSyncChangesForBookmarksWithURL
(
db
item
.
url
syncChangeDelta
)
;
}
await
adjustSeparatorsSyncCounter
(
db
item
.
_parentId
item
.
index
syncChangeDelta
)
;
}
for
(
let
guid
of
parentGuids
)
{
await
setAncestorsLastModified
(
db
guid
new
Date
(
)
syncChangeDelta
)
;
}
await
insertTombstones
(
db
items
syncChangeDelta
)
;
}
)
;
urls
=
urls
.
concat
(
items
.
filter
(
item
=
>
{
let
isUntagging
=
item
.
_grandParentId
=
=
PlacesUtils
.
tagsFolderId
;
return
!
isUntagging
&
&
"
url
"
in
item
;
}
)
.
map
(
item
=
>
item
.
url
)
)
;
if
(
urls
.
length
)
{
await
PlacesUtils
.
keywords
.
removeFromURLsIfNotBookmarked
(
urls
)
;
updateFrecency
(
db
urls
urls
.
length
>
1
)
.
catch
(
Cu
.
reportError
)
;
}
}
)
;
}
function
reorderChildren
(
parent
orderedChildrenGuids
options
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
reorderChildren
"
db
=
>
db
.
executeTransaction
(
async
function
(
)
{
let
children
=
await
fetchBookmarksByParent
(
db
{
parentGuid
:
parent
.
guid
}
)
;
if
(
!
children
.
length
)
{
return
[
]
;
}
let
guidIndices
=
new
Map
(
)
;
let
currentIndices
=
new
Map
(
)
;
for
(
let
i
=
0
;
i
<
orderedChildrenGuids
.
length
;
+
+
i
)
{
let
guid
=
orderedChildrenGuids
[
i
]
;
guidIndices
.
set
(
guid
i
)
;
}
let
needReorder
=
true
;
let
requestedChildIndices
=
[
]
;
for
(
let
i
=
0
;
i
<
children
.
length
;
+
+
i
)
{
currentIndices
.
set
(
children
[
i
]
.
guid
i
)
;
if
(
guidIndices
.
has
(
children
[
i
]
.
guid
)
)
{
let
index
=
guidIndices
.
get
(
children
[
i
]
.
guid
)
;
requestedChildIndices
.
push
(
index
)
;
}
}
if
(
requestedChildIndices
.
length
)
{
needReorder
=
false
;
for
(
let
i
=
1
;
i
<
requestedChildIndices
.
length
;
+
+
i
)
{
if
(
requestedChildIndices
[
i
-
1
]
>
requestedChildIndices
[
i
]
)
{
needReorder
=
true
;
break
;
}
}
}
if
(
needReorder
)
{
children
.
sort
(
(
a
b
)
=
>
{
if
(
!
guidIndices
.
has
(
a
.
guid
)
&
&
!
guidIndices
.
has
(
b
.
guid
)
)
{
return
currentIndices
.
get
(
a
.
guid
)
<
currentIndices
.
get
(
b
.
guid
)
?
-
1
:
1
;
}
if
(
!
guidIndices
.
has
(
a
.
guid
)
)
{
return
1
;
}
if
(
!
guidIndices
.
has
(
b
.
guid
)
)
{
return
-
1
;
}
return
guidIndices
.
get
(
a
.
guid
)
<
guidIndices
.
get
(
b
.
guid
)
?
-
1
:
1
;
}
)
;
let
valuesTable
=
children
.
map
(
(
child
i
)
=
>
(
"
{
child
.
guid
}
"
{
i
}
)
)
.
join
(
)
;
await
db
.
execute
(
WITH
sorting
(
g
p
)
AS
(
VALUES
{
valuesTable
}
)
UPDATE
moz_bookmarks
SET
position
=
(
SELECT
CASE
count
(
*
)
WHEN
0
THEN
-
position
ELSE
count
(
*
)
-
1
END
FROM
sorting
a
JOIN
sorting
b
ON
b
.
p
<
=
a
.
p
WHERE
a
.
g
=
guid
)
WHERE
parent
=
:
parentId
{
parentId
:
parent
.
_id
}
)
;
let
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
options
.
source
)
;
if
(
syncChangeDelta
)
{
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
:
syncChangeDelta
WHERE
id
=
:
parentId
{
parentId
:
parent
.
_id
syncChangeDelta
}
)
;
}
await
db
.
executeCached
(
CREATE
TEMP
TRIGGER
moz_bookmarks_reorder_trigger
AFTER
UPDATE
OF
position
ON
moz_bookmarks
WHEN
NEW
.
position
=
-
1
BEGIN
UPDATE
moz_bookmarks
SET
position
=
(
SELECT
MAX
(
position
)
FROM
moz_bookmarks
WHERE
parent
=
NEW
.
parent
)
+
(
SELECT
count
(
*
)
FROM
moz_bookmarks
WHERE
parent
=
NEW
.
parent
AND
position
BETWEEN
OLD
.
position
AND
-
1
)
WHERE
guid
=
NEW
.
guid
;
END
)
;
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
position
=
-
1
WHERE
position
<
0
)
;
await
db
.
executeCached
(
DROP
TRIGGER
moz_bookmarks_reorder_trigger
)
;
}
let
possibleOrphanIds
=
[
]
;
for
(
let
child
of
children
)
{
if
(
guidIndices
.
has
(
child
.
guid
)
)
{
possibleOrphanIds
.
push
(
child
.
_id
)
;
}
}
await
db
.
executeCached
(
DELETE
FROM
moz_items_annos
WHERE
anno_attribute_id
=
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
:
orphanAnno
)
AND
item_id
IN
(
{
possibleOrphanIds
.
join
(
"
"
)
}
)
{
orphanAnno
:
PlacesSyncUtils
.
bookmarks
.
SYNC_PARENT_ANNO
}
)
;
return
children
;
}
)
)
;
}
function
mergeIntoNewObject
(
.
.
.
sources
)
{
let
dest
=
{
}
;
for
(
let
src
of
sources
)
{
for
(
let
prop
of
Object
.
getOwnPropertyNames
(
src
)
)
{
Object
.
defineProperty
(
dest
prop
Object
.
getOwnPropertyDescriptor
(
src
prop
)
)
;
}
}
return
dest
;
}
function
removeSameValueProperties
(
dest
src
)
{
for
(
let
prop
in
dest
)
{
let
remove
=
false
;
switch
(
prop
)
{
case
"
lastModified
"
:
case
"
dateAdded
"
:
remove
=
src
.
hasOwnProperty
(
prop
)
&
&
dest
[
prop
]
.
getTime
(
)
=
=
src
[
prop
]
.
getTime
(
)
;
break
;
case
"
url
"
:
remove
=
src
.
hasOwnProperty
(
prop
)
&
&
dest
[
prop
]
.
href
=
=
src
[
prop
]
.
href
;
break
;
default
:
remove
=
dest
[
prop
]
=
=
src
[
prop
]
;
}
if
(
remove
&
&
prop
!
=
"
guid
"
)
delete
dest
[
prop
]
;
}
}
function
rowsToItemsArray
(
rows
)
{
return
rows
.
map
(
row
=
>
{
let
item
=
{
}
;
for
(
let
prop
of
[
"
guid
"
"
index
"
"
type
"
"
title
"
]
)
{
item
[
prop
]
=
row
.
getResultByName
(
prop
)
;
}
for
(
let
prop
of
[
"
dateAdded
"
"
lastModified
"
]
)
{
let
value
=
row
.
getResultByName
(
prop
)
;
if
(
value
)
item
[
prop
]
=
PlacesUtils
.
toDate
(
value
)
;
}
let
parentGuid
=
row
.
getResultByName
(
"
parentGuid
"
)
;
if
(
parentGuid
)
{
item
.
parentGuid
=
parentGuid
;
}
let
url
=
row
.
getResultByName
(
"
url
"
)
;
if
(
url
)
{
item
.
url
=
new
URL
(
url
)
;
}
for
(
let
prop
of
[
"
_id
"
"
_parentId
"
"
_childCount
"
"
_grandParentId
"
"
_syncStatus
"
]
)
{
let
val
=
row
.
getResultByName
(
prop
)
;
if
(
val
!
=
=
null
)
{
Object
.
defineProperty
(
item
prop
{
value
:
val
enumerable
:
false
configurable
:
true
}
)
;
}
}
return
item
;
}
)
;
}
function
validateBookmarkObject
(
name
input
behavior
)
{
return
PlacesUtils
.
validateItemProperties
(
name
PlacesUtils
.
BOOKMARK_VALIDATORS
input
behavior
)
;
}
var
updateFrecency
=
async
function
(
db
urls
collapseNotifications
=
false
)
{
let
urlQuery
=
'
hash
(
"
'
+
urls
.
map
(
url
=
>
url
.
href
)
.
join
(
'
"
)
hash
(
"
'
)
+
'
"
)
'
;
let
frecencyClause
=
"
CALCULATE_FRECENCY
(
id
)
"
;
if
(
!
collapseNotifications
)
{
frecencyClause
=
"
NOTIFY_FRECENCY
(
"
+
frecencyClause
+
"
url
guid
hidden
last_visit_date
)
"
;
}
await
db
.
execute
(
UPDATE
moz_places
SET
hidden
=
(
url_hash
BETWEEN
hash
(
"
place
"
"
prefix_lo
"
)
AND
hash
(
"
place
"
"
prefix_hi
"
)
)
frecency
=
{
frecencyClause
}
WHERE
url_hash
IN
(
{
urlQuery
}
)
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_updateoriginsupdate_temp
)
;
if
(
collapseNotifications
)
{
let
observers
=
PlacesUtils
.
history
.
getObservers
(
)
;
notify
(
observers
"
onManyFrecenciesChanged
"
)
;
}
}
;
var
removeOrphanAnnotations
=
async
function
(
db
)
{
await
db
.
executeCached
(
DELETE
FROM
moz_items_annos
WHERE
id
IN
(
SELECT
a
.
id
from
moz_items_annos
a
LEFT
JOIN
moz_bookmarks
b
ON
a
.
item_id
=
b
.
id
WHERE
b
.
id
ISNULL
)
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_anno_attributes
WHERE
id
IN
(
SELECT
n
.
id
from
moz_anno_attributes
n
LEFT
JOIN
moz_annos
a1
ON
a1
.
anno_attribute_id
=
n
.
id
LEFT
JOIN
moz_items_annos
a2
ON
a2
.
anno_attribute_id
=
n
.
id
WHERE
a1
.
id
ISNULL
AND
a2
.
id
ISNULL
)
)
;
}
;
var
removeAnnotationsForItems
=
async
function
(
db
items
)
{
let
ids
=
sqlList
(
items
.
map
(
item
=
>
item
.
_id
)
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_items_annos
WHERE
item_id
IN
(
{
ids
}
)
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_anno_attributes
WHERE
id
IN
(
SELECT
n
.
id
from
moz_anno_attributes
n
LEFT
JOIN
moz_annos
a1
ON
a1
.
anno_attribute_id
=
n
.
id
LEFT
JOIN
moz_items_annos
a2
ON
a2
.
anno_attribute_id
=
n
.
id
WHERE
a1
.
id
ISNULL
AND
a2
.
id
ISNULL
)
)
;
}
;
var
setAncestorsLastModified
=
async
function
(
db
folderGuid
time
syncChangeDelta
)
{
await
db
.
executeCached
(
WITH
RECURSIVE
ancestors
(
aid
)
AS
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
:
guid
UNION
ALL
SELECT
parent
FROM
moz_bookmarks
JOIN
ancestors
ON
id
=
aid
WHERE
type
=
:
type
)
UPDATE
moz_bookmarks
SET
lastModified
=
:
time
WHERE
id
IN
ancestors
{
guid
:
folderGuid
type
:
Bookmarks
.
TYPE_FOLDER
time
:
PlacesUtils
.
toPRTime
(
time
)
}
)
;
if
(
syncChangeDelta
)
{
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
:
syncChangeDelta
WHERE
guid
=
:
guid
{
guid
:
folderGuid
syncChangeDelta
}
)
;
}
}
;
var
removeFoldersContents
=
async
function
(
db
folderGuids
options
)
{
let
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
options
.
source
)
;
let
itemsRemoved
=
[
]
;
for
(
let
folderGuid
of
folderGuids
)
{
let
rows
=
await
db
.
executeCached
(
WITH
RECURSIVE
descendants
(
did
)
AS
(
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
b
.
parent
=
p
.
id
WHERE
p
.
guid
=
:
folderGuid
UNION
ALL
SELECT
id
FROM
moz_bookmarks
JOIN
descendants
ON
parent
=
did
)
SELECT
b
.
id
AS
_id
b
.
parent
AS
_parentId
b
.
position
AS
'
index
'
b
.
type
url
b
.
guid
p
.
guid
AS
parentGuid
b
.
dateAdded
b
.
lastModified
IFNULL
(
b
.
title
"
"
)
AS
title
p
.
parent
AS
_grandParentId
NULL
AS
_childCount
b
.
syncStatus
AS
_syncStatus
FROM
descendants
/
*
The
usage
of
CROSS
JOIN
is
not
random
it
tells
the
optimizer
to
retain
the
original
rows
order
so
the
hierarchy
is
respected
*
/
CROSS
JOIN
moz_bookmarks
b
ON
did
=
b
.
id
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
b
.
fk
=
h
.
id
{
folderGuid
}
)
;
itemsRemoved
=
itemsRemoved
.
concat
(
rowsToItemsArray
(
rows
)
)
;
await
db
.
executeCached
(
WITH
RECURSIVE
descendants
(
did
)
AS
(
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
b
.
parent
=
p
.
id
WHERE
p
.
guid
=
:
folderGuid
UNION
ALL
SELECT
id
FROM
moz_bookmarks
JOIN
descendants
ON
parent
=
did
)
DELETE
FROM
moz_bookmarks
WHERE
id
IN
descendants
{
folderGuid
}
)
;
}
await
insertTombstones
(
db
itemsRemoved
syncChangeDelta
)
;
await
addSyncChangesForRemovedTagFolders
(
db
itemsRemoved
syncChangeDelta
)
;
await
removeOrphanAnnotations
(
db
)
;
let
{
source
=
Bookmarks
.
SOURCES
.
DEFAULT
}
=
options
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
for
(
let
item
of
itemsRemoved
.
reverse
(
)
)
{
let
uri
=
item
.
hasOwnProperty
(
"
url
"
)
?
PlacesUtils
.
toURI
(
item
.
url
)
:
null
;
notify
(
observers
"
onItemRemoved
"
[
item
.
_id
item
.
_parentId
item
.
index
item
.
type
uri
item
.
guid
item
.
parentGuid
source
]
{
isDescendantRemoval
:
true
parentGuid
:
item
.
parentGuid
}
)
;
let
isUntagging
=
item
.
_grandParentId
=
=
PlacesUtils
.
tagsFolderId
;
if
(
isUntagging
)
{
for
(
let
entry
of
(
await
fetchBookmarksByURL
(
item
true
)
)
)
{
notify
(
observers
"
onItemChanged
"
[
entry
.
_id
"
tags
"
false
"
"
PlacesUtils
.
toPRTime
(
entry
.
lastModified
)
entry
.
type
entry
.
_parentId
entry
.
guid
entry
.
parentGuid
"
"
source
]
)
;
}
}
}
return
itemsRemoved
.
filter
(
item
=
>
"
url
"
in
item
)
.
map
(
item
=
>
item
.
url
)
;
}
;
async
function
maybeInsertPlace
(
db
url
)
{
await
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
moz_places
(
url
url_hash
rev_host
hidden
frecency
guid
)
VALUES
(
:
url
hash
(
:
url
)
:
rev_host
0
:
frecency
IFNULL
(
(
SELECT
guid
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
GENERATE_GUID
(
)
)
)
{
url
:
url
.
href
rev_host
:
PlacesUtils
.
getReversedHost
(
url
)
frecency
:
url
.
protocol
=
=
"
place
:
"
?
0
:
-
1
}
)
;
await
db
.
executeCached
(
"
DELETE
FROM
moz_updateoriginsinsert_temp
"
)
;
}
async
function
maybeInsertManyPlaces
(
db
urls
)
{
await
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
moz_places
(
url
url_hash
rev_host
hidden
frecency
guid
)
VALUES
(
:
url
hash
(
:
url
)
:
rev_host
0
:
frecency
IFNULL
(
(
SELECT
guid
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
:
maybeguid
)
)
urls
.
map
(
url
=
>
(
{
url
:
url
.
href
rev_host
:
PlacesUtils
.
getReversedHost
(
url
)
frecency
:
url
.
protocol
=
=
"
place
:
"
?
0
:
-
1
maybeguid
:
PlacesUtils
.
history
.
makeGuid
(
)
}
)
)
)
;
await
db
.
executeCached
(
"
DELETE
FROM
moz_updateoriginsinsert_temp
"
)
;
}
function
needsTombstone
(
item
)
{
return
item
.
_syncStatus
=
=
Bookmarks
.
SYNC_STATUS
.
NORMAL
;
}
function
insertTombstones
(
db
itemsRemoved
syncChangeDelta
)
{
if
(
!
syncChangeDelta
)
{
return
Promise
.
resolve
(
)
;
}
let
syncedItems
=
itemsRemoved
.
filter
(
needsTombstone
)
;
if
(
!
syncedItems
.
length
)
{
return
Promise
.
resolve
(
)
;
}
let
dateRemoved
=
PlacesUtils
.
toPRTime
(
Date
.
now
(
)
)
;
let
valuesTable
=
syncedItems
.
map
(
item
=
>
(
{
JSON
.
stringify
(
item
.
guid
)
}
{
dateRemoved
}
)
)
.
join
(
"
"
)
;
return
db
.
execute
(
INSERT
INTO
moz_bookmarks_deleted
(
guid
dateRemoved
)
VALUES
{
valuesTable
}
)
;
}
var
addSyncChangesForRemovedTagFolders
=
async
function
(
db
itemsRemoved
syncChangeDelta
)
{
if
(
!
syncChangeDelta
)
{
return
;
}
for
(
let
item
of
itemsRemoved
)
{
let
isUntagging
=
item
.
_grandParentId
=
=
PlacesUtils
.
tagsFolderId
;
if
(
isUntagging
)
{
await
PlacesSyncUtils
.
bookmarks
.
addSyncChangesForBookmarksWithURL
(
db
item
.
url
syncChangeDelta
)
;
}
}
}
;
function
adjustSeparatorsSyncCounter
(
db
parentId
startIndex
syncChangeDelta
)
{
if
(
!
syncChangeDelta
)
{
return
Promise
.
resolve
(
)
;
}
return
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
:
delta
WHERE
parent
=
:
parent
AND
position
>
=
:
start_index
AND
type
=
:
item_type
{
delta
:
syncChangeDelta
parent
:
parentId
start_index
:
startIndex
item_type
:
Bookmarks
.
TYPE_SEPARATOR
}
)
;
}
function
*
chunkArray
(
array
chunkLength
)
{
if
(
array
.
length
<
=
chunkLength
)
{
yield
array
;
return
;
}
let
startIndex
=
0
;
while
(
startIndex
<
array
.
length
)
{
yield
array
.
slice
(
startIndex
startIndex
+
=
chunkLength
)
;
}
}
function
sqlList
(
list
)
{
return
list
.
map
(
JSON
.
stringify
)
.
join
(
)
;
}
