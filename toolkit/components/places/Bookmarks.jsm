"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
Bookmarks
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Promise
"
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Sqlite
"
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesSyncUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
)
;
const
MATCH_ANYWHERE_UNMODIFIED
=
Ci
.
mozIPlacesAutoComplete
.
MATCH_ANYWHERE_UNMODIFIED
;
const
BEHAVIOR_BOOKMARK
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_BOOKMARK
;
var
Bookmarks
=
Object
.
freeze
(
{
TYPE_BOOKMARK
:
1
TYPE_FOLDER
:
2
TYPE_SEPARATOR
:
3
SYNC_STATUS
:
{
UNKNOWN
:
Ci
.
nsINavBookmarksService
.
SYNC_STATUS_UNKNOWN
NEW
:
Ci
.
nsINavBookmarksService
.
SYNC_STATUS_NEW
NORMAL
:
Ci
.
nsINavBookmarksService
.
SYNC_STATUS_NORMAL
}
DEFAULT_INDEX
:
-
1
SOURCES
:
{
DEFAULT
:
Ci
.
nsINavBookmarksService
.
SOURCE_DEFAULT
SYNC
:
Ci
.
nsINavBookmarksService
.
SOURCE_SYNC
IMPORT
:
Ci
.
nsINavBookmarksService
.
SOURCE_IMPORT
IMPORT_REPLACE
:
Ci
.
nsINavBookmarksService
.
SOURCE_IMPORT_REPLACE
SYNC_REPARENT_REMOVED_FOLDER_CHILDREN
:
Ci
.
nsINavBookmarksService
.
SOURCE_SYNC_REPARENT_REMOVED_FOLDER_CHILDREN
}
rootGuid
:
"
root________
"
menuGuid
:
"
menu________
"
toolbarGuid
:
"
toolbar_____
"
unfiledGuid
:
"
unfiled_____
"
mobileGuid
:
"
mobile______
"
tagsGuid
:
"
tags________
"
insert
(
info
)
{
let
time
=
(
info
&
&
info
.
dateAdded
)
|
|
new
Date
(
)
;
let
insertInfo
=
validateBookmarkObject
(
info
{
type
:
{
defaultValue
:
this
.
TYPE_BOOKMARK
}
index
:
{
defaultValue
:
this
.
DEFAULT_INDEX
}
url
:
{
requiredIf
:
b
=
>
b
.
type
=
=
this
.
TYPE_BOOKMARK
validIf
:
b
=
>
b
.
type
=
=
this
.
TYPE_BOOKMARK
}
parentGuid
:
{
required
:
true
}
title
:
{
validIf
:
b
=
>
[
this
.
TYPE_BOOKMARK
this
.
TYPE_FOLDER
]
.
includes
(
b
.
type
)
}
dateAdded
:
{
defaultValue
:
time
validIf
:
b
=
>
!
b
.
lastModified
|
|
b
.
dateAdded
<
=
b
.
lastModified
}
lastModified
:
{
defaultValue
:
time
validIf
:
b
=
>
(
!
b
.
dateAdded
&
&
b
.
lastModified
>
=
time
)
|
|
(
b
.
dateAdded
&
&
b
.
lastModified
>
=
b
.
dateAdded
)
}
source
:
{
defaultValue
:
this
.
SOURCES
.
DEFAULT
}
}
)
;
return
Task
.
spawn
(
function
*
(
)
{
let
parent
=
yield
fetchBookmark
(
{
guid
:
insertInfo
.
parentGuid
}
)
;
if
(
!
parent
)
throw
new
Error
(
"
parentGuid
must
be
valid
"
)
;
if
(
insertInfo
.
index
=
=
this
.
DEFAULT_INDEX
|
|
insertInfo
.
index
>
parent
.
_childCount
)
{
insertInfo
.
index
=
parent
.
_childCount
;
}
let
item
=
yield
insertBookmark
(
insertInfo
parent
)
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
let
uri
=
item
.
hasOwnProperty
(
"
url
"
)
?
PlacesUtils
.
toURI
(
item
.
url
)
:
null
;
let
itemId
=
yield
PlacesUtils
.
promiseItemId
(
item
.
guid
)
;
let
isTagging
=
parent
.
_parentId
=
=
PlacesUtils
.
tagsFolderId
;
let
isTagsFolder
=
parent
.
_id
=
=
PlacesUtils
.
tagsFolderId
;
notify
(
observers
"
onItemAdded
"
[
itemId
parent
.
_id
item
.
index
item
.
type
uri
item
.
title
|
|
null
PlacesUtils
.
toPRTime
(
item
.
dateAdded
)
item
.
guid
item
.
parentGuid
item
.
source
]
{
isTagging
:
isTagging
|
|
isTagsFolder
}
)
;
if
(
isTagging
)
{
for
(
let
entry
of
(
yield
fetchBookmarksByURL
(
item
)
)
)
{
notify
(
observers
"
onItemChanged
"
[
entry
.
_id
"
tags
"
false
"
"
PlacesUtils
.
toPRTime
(
entry
.
lastModified
)
entry
.
type
entry
.
_parentId
entry
.
guid
entry
.
parentGuid
"
"
item
.
source
]
)
;
}
}
delete
item
.
source
;
return
Object
.
assign
(
{
}
item
)
;
}
.
bind
(
this
)
)
;
}
update
(
info
)
{
let
updateInfo
=
validateBookmarkObject
(
info
{
guid
:
{
required
:
true
}
index
:
{
requiredIf
:
b
=
>
b
.
hasOwnProperty
(
"
parentGuid
"
)
validIf
:
b
=
>
b
.
index
>
=
0
|
|
b
.
index
=
=
this
.
DEFAULT_INDEX
}
source
:
{
defaultValue
:
this
.
SOURCES
.
DEFAULT
}
}
)
;
if
(
Object
.
keys
(
updateInfo
)
.
length
<
3
)
throw
new
Error
(
"
Not
enough
properties
to
update
"
)
;
return
Task
.
spawn
(
function
*
(
)
{
let
item
=
yield
fetchBookmark
(
updateInfo
)
;
if
(
!
item
)
throw
new
Error
(
"
No
bookmarks
found
for
the
provided
GUID
"
)
;
if
(
updateInfo
.
hasOwnProperty
(
"
type
"
)
&
&
updateInfo
.
type
!
=
item
.
type
)
throw
new
Error
(
"
The
bookmark
type
cannot
be
changed
"
)
;
if
(
updateInfo
.
hasOwnProperty
(
"
dateAdded
"
)
&
&
updateInfo
.
dateAdded
.
getTime
(
)
!
=
item
.
dateAdded
.
getTime
(
)
)
throw
new
Error
(
"
The
bookmark
dateAdded
cannot
be
changed
"
)
;
removeSameValueProperties
(
updateInfo
item
)
;
if
(
Object
.
keys
(
updateInfo
)
.
length
<
3
)
{
return
Object
.
assign
(
{
}
item
)
;
}
updateInfo
=
validateBookmarkObject
(
updateInfo
{
url
:
{
validIf
:
(
)
=
>
item
.
type
=
=
this
.
TYPE_BOOKMARK
}
title
:
{
validIf
:
(
)
=
>
[
this
.
TYPE_BOOKMARK
this
.
TYPE_FOLDER
]
.
includes
(
item
.
type
)
}
lastModified
:
{
defaultValue
:
new
Date
(
)
validIf
:
b
=
>
b
.
lastModified
>
=
item
.
dateAdded
}
}
)
;
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
update
"
Task
.
async
(
function
*
(
db
)
{
let
parent
;
if
(
updateInfo
.
hasOwnProperty
(
"
parentGuid
"
)
)
{
if
(
item
.
type
=
=
this
.
TYPE_FOLDER
)
{
let
rows
=
yield
db
.
executeCached
(
WITH
RECURSIVE
descendants
(
did
)
AS
(
VALUES
(
:
id
)
UNION
ALL
SELECT
id
FROM
moz_bookmarks
JOIN
descendants
ON
parent
=
did
WHERE
type
=
:
type
)
SELECT
guid
FROM
moz_bookmarks
WHERE
id
IN
descendants
{
id
:
item
.
_id
type
:
this
.
TYPE_FOLDER
}
)
;
if
(
rows
.
map
(
r
=
>
r
.
getResultByName
(
"
guid
"
)
)
.
includes
(
updateInfo
.
parentGuid
)
)
throw
new
Error
(
"
Cannot
insert
a
folder
into
itself
or
one
of
its
descendants
"
)
;
}
parent
=
yield
fetchBookmark
(
{
guid
:
updateInfo
.
parentGuid
}
)
;
if
(
!
parent
)
throw
new
Error
(
"
No
bookmarks
found
for
the
provided
parentGuid
"
)
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
index
"
)
)
{
if
(
!
parent
)
parent
=
yield
fetchBookmark
(
{
guid
:
item
.
parentGuid
}
)
;
if
(
updateInfo
.
index
>
=
parent
.
_childCount
|
|
updateInfo
.
index
=
=
this
.
DEFAULT_INDEX
)
{
updateInfo
.
index
=
parent
.
_childCount
;
if
(
parent
.
guid
=
=
item
.
parentGuid
)
updateInfo
.
index
-
-
;
}
}
let
updatedItem
=
yield
updateBookmark
(
updateInfo
item
parent
)
;
if
(
item
.
type
=
=
this
.
TYPE_BOOKMARK
&
&
item
.
url
.
href
!
=
updatedItem
.
url
.
href
)
{
updateFrecency
(
db
[
item
.
url
]
)
.
then
(
null
Cu
.
reportError
)
;
updateFrecency
(
db
[
updatedItem
.
url
]
)
.
then
(
null
Cu
.
reportError
)
;
}
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
if
(
info
.
hasOwnProperty
(
"
lastModified
"
)
&
&
updateInfo
.
hasOwnProperty
(
"
lastModified
"
)
&
&
item
.
lastModified
!
=
updatedItem
.
lastModified
)
{
notify
(
observers
"
onItemChanged
"
[
updatedItem
.
_id
"
lastModified
"
false
{
PlacesUtils
.
toPRTime
(
updatedItem
.
lastModified
)
}
PlacesUtils
.
toPRTime
(
updatedItem
.
lastModified
)
updatedItem
.
type
updatedItem
.
_parentId
updatedItem
.
guid
updatedItem
.
parentGuid
"
"
updatedItem
.
source
]
)
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
title
"
)
)
{
notify
(
observers
"
onItemChanged
"
[
updatedItem
.
_id
"
title
"
false
updatedItem
.
title
PlacesUtils
.
toPRTime
(
updatedItem
.
lastModified
)
updatedItem
.
type
updatedItem
.
_parentId
updatedItem
.
guid
updatedItem
.
parentGuid
"
"
updatedItem
.
source
]
)
;
}
if
(
updateInfo
.
hasOwnProperty
(
"
url
"
)
)
{
notify
(
observers
"
onItemChanged
"
[
updatedItem
.
_id
"
uri
"
false
updatedItem
.
url
.
href
PlacesUtils
.
toPRTime
(
updatedItem
.
lastModified
)
updatedItem
.
type
updatedItem
.
_parentId
updatedItem
.
guid
updatedItem
.
parentGuid
item
.
url
.
href
updatedItem
.
source
]
)
;
}
if
(
item
.
parentGuid
!
=
updatedItem
.
parentGuid
|
|
item
.
index
!
=
updatedItem
.
index
)
{
notify
(
observers
"
onItemMoved
"
[
updatedItem
.
_id
item
.
_parentId
item
.
index
updatedItem
.
_parentId
updatedItem
.
index
updatedItem
.
type
updatedItem
.
guid
item
.
parentGuid
updatedItem
.
parentGuid
updatedItem
.
source
]
)
;
}
delete
updatedItem
.
source
;
return
Object
.
assign
(
{
}
updatedItem
)
;
}
.
bind
(
this
)
)
)
;
}
.
bind
(
this
)
)
;
}
remove
(
guidOrInfo
options
=
{
}
)
{
let
info
=
guidOrInfo
;
if
(
!
info
)
throw
new
Error
(
"
Input
should
be
a
valid
object
"
)
;
if
(
typeof
(
guidOrInfo
)
!
=
"
object
"
)
info
=
{
guid
:
guidOrInfo
}
;
if
(
[
this
.
rootGuid
this
.
menuGuid
this
.
toolbarGuid
this
.
unfiledGuid
this
.
tagsGuid
this
.
mobileGuid
]
.
includes
(
info
.
guid
)
)
{
throw
new
Error
(
"
It
'
s
not
possible
to
remove
Places
root
folders
.
"
)
;
}
let
removeInfo
=
validateBookmarkObject
(
info
)
;
return
Task
.
spawn
(
function
*
(
)
{
let
item
=
yield
fetchBookmark
(
removeInfo
)
;
if
(
!
item
)
throw
new
Error
(
"
No
bookmarks
found
for
the
provided
GUID
.
"
)
;
item
=
yield
removeBookmark
(
item
options
)
;
let
{
source
=
Bookmarks
.
SOURCES
.
DEFAULT
}
=
options
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
let
uri
=
item
.
hasOwnProperty
(
"
url
"
)
?
PlacesUtils
.
toURI
(
item
.
url
)
:
null
;
let
isUntagging
=
item
.
_grandParentId
=
=
PlacesUtils
.
tagsFolderId
;
notify
(
observers
"
onItemRemoved
"
[
item
.
_id
item
.
_parentId
item
.
index
item
.
type
uri
item
.
guid
item
.
parentGuid
source
]
{
isTagging
:
isUntagging
}
)
;
if
(
isUntagging
)
{
for
(
let
entry
of
(
yield
fetchBookmarksByURL
(
item
)
)
)
{
notify
(
observers
"
onItemChanged
"
[
entry
.
_id
"
tags
"
false
"
"
PlacesUtils
.
toPRTime
(
entry
.
lastModified
)
entry
.
type
entry
.
_parentId
entry
.
guid
entry
.
parentGuid
"
"
source
]
)
;
}
}
return
Object
.
assign
(
{
}
item
)
;
}
)
;
}
eraseEverything
(
options
=
{
}
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
eraseEverything
"
db
=
>
db
.
executeTransaction
(
function
*
(
)
{
const
folderGuids
=
[
this
.
toolbarGuid
this
.
menuGuid
this
.
unfiledGuid
this
.
mobileGuid
]
;
yield
removeFoldersContents
(
db
folderGuids
options
)
;
const
time
=
PlacesUtils
.
toPRTime
(
new
Date
(
)
)
;
const
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
options
.
source
)
;
for
(
let
folderGuid
of
folderGuids
)
{
yield
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
lastModified
=
:
time
syncChangeCounter
=
syncChangeCounter
+
:
syncChangeDelta
WHERE
id
IN
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
:
folderGuid
)
{
folderGuid
time
syncChangeDelta
}
)
;
}
}
.
bind
(
this
)
)
)
;
}
getRecent
(
numberOfItems
)
{
if
(
numberOfItems
=
=
=
undefined
)
{
throw
new
Error
(
"
numberOfItems
argument
is
required
"
)
;
}
if
(
!
typeof
numberOfItems
=
=
=
"
number
"
|
|
(
numberOfItems
%
1
)
!
=
=
0
)
{
throw
new
Error
(
"
numberOfItems
argument
must
be
an
integer
"
)
;
}
if
(
numberOfItems
<
=
0
)
{
throw
new
Error
(
"
numberOfItems
argument
must
be
greater
than
zero
"
)
;
}
return
Task
.
spawn
(
function
*
(
)
{
return
yield
fetchRecentBookmarks
(
numberOfItems
)
;
}
)
;
}
fetch
(
guidOrInfo
onResult
=
null
)
{
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
throw
new
Error
(
"
onResult
callback
must
be
a
valid
function
"
)
;
let
info
=
guidOrInfo
;
if
(
!
info
)
throw
new
Error
(
"
Input
should
be
a
valid
object
"
)
;
if
(
typeof
(
info
)
!
=
"
object
"
)
info
=
{
guid
:
guidOrInfo
}
;
let
conditionsCount
=
[
v
=
>
v
.
hasOwnProperty
(
"
guid
"
)
v
=
>
v
.
hasOwnProperty
(
"
parentGuid
"
)
&
&
v
.
hasOwnProperty
(
"
index
"
)
v
=
>
v
.
hasOwnProperty
(
"
url
"
)
]
.
reduce
(
(
old
fn
)
=
>
old
+
fn
(
info
)
|
0
0
)
;
if
(
conditionsCount
!
=
1
)
throw
new
Error
(
Unexpected
number
of
conditions
provided
:
{
conditionsCount
}
)
;
let
fetchInfo
=
validateBookmarkObject
(
info
{
parentGuid
:
{
requiredIf
:
b
=
>
b
.
hasOwnProperty
(
"
index
"
)
}
index
:
{
requiredIf
:
b
=
>
b
.
hasOwnProperty
(
"
parentGuid
"
)
validIf
:
b
=
>
typeof
(
b
.
index
)
=
=
"
number
"
&
&
b
.
index
>
=
0
|
|
b
.
index
=
=
this
.
DEFAULT_INDEX
}
}
)
;
return
Task
.
spawn
(
function
*
(
)
{
let
results
;
if
(
fetchInfo
.
hasOwnProperty
(
"
guid
"
)
)
results
=
yield
fetchBookmark
(
fetchInfo
)
;
else
if
(
fetchInfo
.
hasOwnProperty
(
"
parentGuid
"
)
&
&
fetchInfo
.
hasOwnProperty
(
"
index
"
)
)
results
=
yield
fetchBookmarkByPosition
(
fetchInfo
)
;
else
if
(
fetchInfo
.
hasOwnProperty
(
"
url
"
)
)
results
=
yield
fetchBookmarksByURL
(
fetchInfo
)
;
if
(
!
results
)
return
null
;
if
(
!
Array
.
isArray
(
results
)
)
results
=
[
results
]
;
results
=
results
.
map
(
r
=
>
Object
.
assign
(
{
}
r
)
)
;
if
(
onResult
)
{
for
(
let
result
of
results
)
{
try
{
onResult
(
result
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
return
results
[
0
]
;
}
)
;
}
fetchTree
(
guid
=
"
"
options
=
{
}
)
{
throw
new
Error
(
"
Not
yet
implemented
"
)
;
}
reorder
(
parentGuid
orderedChildrenGuids
options
=
{
}
)
{
let
info
=
{
guid
:
parentGuid
}
;
info
=
validateBookmarkObject
(
info
{
guid
:
{
required
:
true
}
}
)
;
if
(
!
Array
.
isArray
(
orderedChildrenGuids
)
|
|
!
orderedChildrenGuids
.
length
)
throw
new
Error
(
"
Must
provide
a
sorted
array
of
children
GUIDs
.
"
)
;
try
{
orderedChildrenGuids
.
forEach
(
PlacesUtils
.
BOOKMARK_VALIDATORS
.
guid
)
;
}
catch
(
ex
)
{
throw
new
Error
(
"
Invalid
GUID
found
in
the
sorted
children
array
.
"
)
;
}
return
Task
.
spawn
(
function
*
(
)
{
let
parent
=
yield
fetchBookmark
(
info
)
;
if
(
!
parent
|
|
parent
.
type
!
=
this
.
TYPE_FOLDER
)
throw
new
Error
(
"
No
folder
found
for
the
provided
GUID
.
"
)
;
let
sortedChildren
=
yield
reorderChildren
(
parent
orderedChildrenGuids
options
)
;
let
{
source
=
Bookmarks
.
SOURCES
.
DEFAULT
}
=
options
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
for
(
let
i
=
0
;
i
<
sortedChildren
.
length
;
+
+
i
)
{
let
child
=
sortedChildren
[
i
]
;
notify
(
observers
"
onItemMoved
"
[
child
.
_id
child
.
_parentId
child
.
index
child
.
_parentId
i
child
.
type
child
.
guid
child
.
parentGuid
child
.
parentGuid
source
]
)
;
}
}
.
bind
(
this
)
)
;
}
search
(
query
)
{
if
(
!
query
)
{
throw
new
Error
(
"
Query
object
is
required
"
)
;
}
if
(
typeof
query
=
=
=
"
string
"
)
{
query
=
{
query
}
;
}
if
(
typeof
query
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Query
must
be
an
object
or
a
string
"
)
;
}
if
(
query
.
query
&
&
typeof
query
.
query
!
=
=
"
string
"
)
{
throw
new
Error
(
"
Query
option
must
be
a
string
"
)
;
}
if
(
query
.
title
&
&
typeof
query
.
title
!
=
=
"
string
"
)
{
throw
new
Error
(
"
Title
option
must
be
a
string
"
)
;
}
if
(
query
.
url
)
{
if
(
typeof
query
.
url
=
=
=
"
string
"
|
|
(
query
.
url
instanceof
URL
)
)
{
query
.
url
=
new
URL
(
query
.
url
)
.
href
;
}
else
if
(
query
.
url
instanceof
Ci
.
nsIURI
)
{
query
.
url
=
query
.
url
.
spec
;
}
else
{
throw
new
Error
(
"
Url
option
must
be
a
string
or
a
URL
object
"
)
;
}
}
return
Task
.
spawn
(
function
*
(
)
{
let
results
=
yield
queryBookmarks
(
query
)
;
return
results
;
}
)
;
}
}
)
;
function
notify
(
observers
notification
args
information
=
{
}
)
{
for
(
let
observer
of
observers
)
{
if
(
information
.
isTagging
&
&
observer
.
skipTags
)
{
continue
;
}
if
(
information
.
isDescendantRemoval
&
&
observer
.
skipDescendantsOnItemRemoval
)
{
continue
;
}
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
}
}
}
function
updateBookmark
(
info
item
newParent
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
updateBookmark
"
Task
.
async
(
function
*
(
db
)
{
let
tuples
=
new
Map
(
)
;
tuples
.
set
(
"
lastModified
"
{
value
:
PlacesUtils
.
toPRTime
(
info
.
lastModified
)
}
)
;
if
(
info
.
hasOwnProperty
(
"
title
"
)
)
tuples
.
set
(
"
title
"
{
value
:
info
.
title
}
)
;
yield
db
.
executeTransaction
(
function
*
(
)
{
let
isTagging
=
item
.
_grandParentId
=
=
PlacesUtils
.
tagsFolderId
;
let
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
info
.
source
)
;
if
(
info
.
hasOwnProperty
(
"
url
"
)
)
{
yield
maybeInsertPlace
(
db
info
.
url
)
;
tuples
.
set
(
"
url
"
{
value
:
info
.
url
.
href
fragment
:
"
fk
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
"
}
)
;
}
if
(
newParent
)
{
let
newIndex
=
info
.
hasOwnProperty
(
"
index
"
)
?
info
.
index
:
item
.
index
;
tuples
.
set
(
"
position
"
{
value
:
newIndex
}
)
;
if
(
newParent
.
guid
=
=
item
.
parentGuid
)
{
let
sign
=
newIndex
<
item
.
index
?
+
1
:
-
1
;
yield
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
position
=
position
+
:
sign
WHERE
parent
=
:
newParentId
AND
position
BETWEEN
:
lowIndex
AND
:
highIndex
{
sign
newParentId
:
newParent
.
_id
lowIndex
:
Math
.
min
(
item
.
index
newIndex
)
highIndex
:
Math
.
max
(
item
.
index
newIndex
)
}
)
;
}
else
{
tuples
.
set
(
"
parent
"
{
value
:
newParent
.
_id
}
)
;
yield
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
position
=
position
+
:
sign
WHERE
parent
=
:
oldParentId
AND
position
>
=
:
oldIndex
{
sign
:
-
1
oldParentId
:
item
.
_parentId
oldIndex
:
item
.
index
}
)
;
yield
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
position
=
position
+
:
sign
WHERE
parent
=
:
newParentId
AND
position
>
=
:
newIndex
{
sign
:
+
1
newParentId
:
newParent
.
_id
newIndex
}
)
;
yield
setAncestorsLastModified
(
db
item
.
parentGuid
info
.
lastModified
syncChangeDelta
)
;
}
yield
setAncestorsLastModified
(
db
newParent
.
guid
info
.
lastModified
syncChangeDelta
)
;
}
if
(
syncChangeDelta
)
{
let
isChangingIndex
=
info
.
hasOwnProperty
(
"
index
"
)
&
&
info
.
index
!
=
item
.
index
;
let
needsSyncChange
=
isChangingIndex
?
tuples
.
size
>
2
:
tuples
.
size
>
1
;
if
(
needsSyncChange
)
{
tuples
.
set
(
"
syncChangeDelta
"
{
value
:
syncChangeDelta
fragment
:
"
syncChangeCounter
=
syncChangeCounter
+
:
syncChangeDelta
"
}
)
;
}
}
if
(
isTagging
)
{
yield
PlacesSyncUtils
.
bookmarks
.
addSyncChangesForBookmarksWithURL
(
db
item
.
url
syncChangeDelta
)
;
if
(
info
.
hasOwnProperty
(
"
url
"
)
)
{
yield
PlacesSyncUtils
.
bookmarks
.
addSyncChangesForBookmarksWithURL
(
db
info
.
url
syncChangeDelta
)
;
}
}
let
isChangingTagFolder
=
item
.
_parentId
=
=
PlacesUtils
.
tagsFolderId
;
if
(
isChangingTagFolder
)
{
yield
addSyncChangesForBookmarksInFolder
(
db
item
syncChangeDelta
)
;
}
yield
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
{
Array
.
from
(
tuples
.
keys
(
)
)
.
map
(
v
=
>
tuples
.
get
(
v
)
.
fragment
|
|
{
v
}
=
:
{
v
}
)
.
join
(
"
"
)
}
WHERE
guid
=
:
guid
Object
.
assign
(
{
guid
:
info
.
guid
}
[
.
.
.
tuples
.
entries
(
)
]
.
reduce
(
(
p
c
)
=
>
{
p
[
c
[
0
]
]
=
c
[
1
]
.
value
;
return
p
;
}
{
}
)
)
)
;
if
(
newParent
)
{
yield
db
.
executeCached
(
DELETE
FROM
moz_items_annos
WHERE
anno_attribute_id
=
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
:
orphanAnno
)
AND
item_id
=
:
id
{
orphanAnno
:
PlacesSyncUtils
.
bookmarks
.
SYNC_PARENT_ANNO
id
:
item
.
_id
}
)
;
}
}
)
;
let
additionalParentInfo
=
{
}
;
if
(
newParent
)
{
Object
.
defineProperty
(
additionalParentInfo
"
_parentId
"
{
value
:
newParent
.
_id
enumerable
:
false
}
)
;
Object
.
defineProperty
(
additionalParentInfo
"
_grandParentId
"
{
value
:
newParent
.
_parentId
enumerable
:
false
}
)
;
}
let
updatedItem
=
mergeIntoNewObject
(
item
info
additionalParentInfo
)
;
if
(
updatedItem
.
hasOwnProperty
(
"
title
"
)
&
&
updatedItem
.
title
=
=
=
null
)
delete
updatedItem
.
title
;
return
updatedItem
;
}
)
)
;
}
function
insertBookmark
(
item
parent
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
insertBookmark
"
Task
.
async
(
function
*
(
db
)
{
let
hasExistingGuid
=
item
.
hasOwnProperty
(
"
guid
"
)
;
if
(
!
hasExistingGuid
)
item
.
guid
=
(
yield
db
.
executeCached
(
"
SELECT
GENERATE_GUID
(
)
AS
guid
"
)
)
[
0
]
.
getResultByName
(
"
guid
"
)
;
let
isTagging
=
parent
.
_parentId
=
=
PlacesUtils
.
tagsFolderId
;
yield
db
.
executeTransaction
(
function
*
transaction
(
)
{
if
(
item
.
type
=
=
Bookmarks
.
TYPE_BOOKMARK
)
{
yield
maybeInsertPlace
(
db
item
.
url
)
;
}
yield
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
position
=
position
+
1
WHERE
parent
=
:
parent
AND
position
>
=
:
index
{
parent
:
parent
.
_id
index
:
item
.
index
}
)
;
let
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
item
.
source
)
;
let
syncStatus
=
PlacesSyncUtils
.
bookmarks
.
determineInitialSyncStatus
(
item
.
source
)
;
yield
db
.
executeCached
(
INSERT
INTO
moz_bookmarks
(
fk
type
parent
position
title
dateAdded
lastModified
guid
syncChangeCounter
syncStatus
)
VALUES
(
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
:
type
:
parent
:
index
:
title
:
date_added
:
last_modified
:
guid
:
syncChangeCounter
:
syncStatus
)
{
url
:
item
.
hasOwnProperty
(
"
url
"
)
?
item
.
url
.
href
:
"
nonexistent
"
type
:
item
.
type
parent
:
parent
.
_id
index
:
item
.
index
title
:
item
.
title
date_added
:
PlacesUtils
.
toPRTime
(
item
.
dateAdded
)
last_modified
:
PlacesUtils
.
toPRTime
(
item
.
lastModified
)
guid
:
item
.
guid
syncChangeCounter
:
syncChangeDelta
syncStatus
}
)
;
if
(
hasExistingGuid
)
{
yield
db
.
executeCached
(
DELETE
FROM
moz_bookmarks_deleted
WHERE
guid
=
:
guid
{
guid
:
item
.
guid
}
)
;
}
if
(
isTagging
)
{
yield
PlacesSyncUtils
.
bookmarks
.
addSyncChangesForBookmarksWithURL
(
db
item
.
url
syncChangeDelta
)
;
}
yield
setAncestorsLastModified
(
db
item
.
parentGuid
item
.
dateAdded
syncChangeDelta
)
;
}
)
;
if
(
item
.
type
=
=
Bookmarks
.
TYPE_BOOKMARK
&
&
!
isTagging
)
{
updateFrecency
(
db
[
item
.
url
]
)
.
then
(
null
Cu
.
reportError
)
;
}
if
(
item
.
hasOwnProperty
(
"
title
"
)
&
&
item
.
title
=
=
=
null
)
delete
item
.
title
;
return
item
;
}
)
)
;
}
function
queryBookmarks
(
info
)
{
let
queryParams
=
{
tags_folder
:
PlacesUtils
.
tagsFolderId
}
;
let
queryString
=
"
WHERE
p
.
parent
<
>
:
tags_folder
"
;
if
(
info
.
title
)
{
queryString
+
=
"
AND
b
.
title
=
:
title
"
;
queryParams
.
title
=
info
.
title
;
}
if
(
info
.
url
)
{
queryString
+
=
"
AND
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
"
;
queryParams
.
url
=
info
.
url
;
}
if
(
info
.
query
)
{
queryString
+
=
"
AND
AUTOCOMPLETE_MATCH
(
:
query
h
.
url
b
.
title
NULL
NULL
1
1
NULL
:
matchBehavior
:
searchBehavior
)
"
;
queryParams
.
query
=
info
.
query
;
queryParams
.
matchBehavior
=
MATCH_ANYWHERE_UNMODIFIED
;
queryParams
.
searchBehavior
=
BEHAVIOR_BOOKMARK
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
queryBookmarks
"
Task
.
async
(
function
*
(
db
)
{
let
rows
=
yield
db
.
executeCached
(
SELECT
b
.
guid
IFNULL
(
p
.
guid
"
"
)
AS
parentGuid
b
.
position
AS
'
index
'
b
.
dateAdded
b
.
lastModified
b
.
type
b
.
title
h
.
url
AS
url
b
.
parent
p
.
parent
NULL
AS
_id
NULL
AS
_childCount
NULL
AS
_grandParentId
NULL
AS
_parentId
NULL
AS
_syncStatus
FROM
moz_bookmarks
b
LEFT
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
{
queryString
}
queryParams
)
;
return
rowsToItemsArray
(
rows
)
;
}
)
)
;
}
function
fetchBookmark
(
info
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
fetchBookmark
"
Task
.
async
(
function
*
(
db
)
{
let
rows
=
yield
db
.
executeCached
(
SELECT
b
.
guid
IFNULL
(
p
.
guid
"
"
)
AS
parentGuid
b
.
position
AS
'
index
'
b
.
dateAdded
b
.
lastModified
b
.
type
b
.
title
h
.
url
AS
url
b
.
id
AS
_id
b
.
parent
AS
_parentId
(
SELECT
count
(
*
)
FROM
moz_bookmarks
WHERE
parent
=
b
.
id
)
AS
_childCount
p
.
parent
AS
_grandParentId
b
.
syncStatus
AS
_syncStatus
FROM
moz_bookmarks
b
LEFT
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
WHERE
b
.
guid
=
:
guid
{
guid
:
info
.
guid
}
)
;
return
rows
.
length
?
rowsToItemsArray
(
rows
)
[
0
]
:
null
;
}
)
)
;
}
function
fetchBookmarkByPosition
(
info
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
fetchBookmarkByPosition
"
Task
.
async
(
function
*
(
db
)
{
let
index
=
info
.
index
=
=
Bookmarks
.
DEFAULT_INDEX
?
null
:
info
.
index
;
let
rows
=
yield
db
.
executeCached
(
SELECT
b
.
guid
IFNULL
(
p
.
guid
"
"
)
AS
parentGuid
b
.
position
AS
'
index
'
b
.
dateAdded
b
.
lastModified
b
.
type
b
.
title
h
.
url
AS
url
b
.
id
AS
_id
b
.
parent
AS
_parentId
(
SELECT
count
(
*
)
FROM
moz_bookmarks
WHERE
parent
=
b
.
id
)
AS
_childCount
p
.
parent
AS
_grandParentId
b
.
syncStatus
AS
_syncStatus
FROM
moz_bookmarks
b
LEFT
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
WHERE
p
.
guid
=
:
parentGuid
AND
b
.
position
=
IFNULL
(
:
index
(
SELECT
count
(
*
)
-
1
FROM
moz_bookmarks
WHERE
parent
=
p
.
id
)
)
{
parentGuid
:
info
.
parentGuid
index
}
)
;
return
rows
.
length
?
rowsToItemsArray
(
rows
)
[
0
]
:
null
;
}
)
)
;
}
function
fetchBookmarksByURL
(
info
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
fetchBookmarksByURL
"
Task
.
async
(
function
*
(
db
)
{
let
rows
=
yield
db
.
executeCached
(
/
*
do
not
warn
(
bug
no
)
:
not
worth
to
add
an
index
*
/
SELECT
b
.
guid
IFNULL
(
p
.
guid
"
"
)
AS
parentGuid
b
.
position
AS
'
index
'
b
.
dateAdded
b
.
lastModified
b
.
type
b
.
title
h
.
url
AS
url
b
.
id
AS
_id
b
.
parent
AS
_parentId
(
SELECT
count
(
*
)
FROM
moz_bookmarks
WHERE
parent
=
b
.
id
)
AS
_childCount
p
.
parent
AS
_grandParentId
b
.
syncStatus
AS
_syncStatus
FROM
moz_bookmarks
b
LEFT
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
WHERE
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
AND
_grandParentId
<
>
:
tags_folder
ORDER
BY
b
.
lastModified
DESC
{
url
:
info
.
url
.
href
tags_folder
:
PlacesUtils
.
tagsFolderId
}
)
;
return
rows
.
length
?
rowsToItemsArray
(
rows
)
:
null
;
}
)
)
;
}
function
fetchRecentBookmarks
(
numberOfItems
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
fetchRecentBookmarks
"
Task
.
async
(
function
*
(
db
)
{
let
rows
=
yield
db
.
executeCached
(
SELECT
b
.
guid
IFNULL
(
p
.
guid
"
"
)
AS
parentGuid
b
.
position
AS
'
index
'
b
.
dateAdded
b
.
lastModified
b
.
type
b
.
title
h
.
url
AS
url
NULL
AS
_id
NULL
AS
_parentId
NULL
AS
_childCount
NULL
AS
_grandParentId
NULL
AS
_syncStatus
FROM
moz_bookmarks
b
LEFT
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
WHERE
p
.
parent
<
>
:
tags_folder
ORDER
BY
b
.
dateAdded
DESC
b
.
ROWID
DESC
LIMIT
:
numberOfItems
{
tags_folder
:
PlacesUtils
.
tagsFolderId
numberOfItems
}
)
;
return
rows
.
length
?
rowsToItemsArray
(
rows
)
:
[
]
;
}
)
)
;
}
function
fetchBookmarksByParent
(
info
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
fetchBookmarksByParent
"
Task
.
async
(
function
*
(
db
)
{
let
rows
=
yield
db
.
executeCached
(
SELECT
b
.
guid
IFNULL
(
p
.
guid
"
"
)
AS
parentGuid
b
.
position
AS
'
index
'
b
.
dateAdded
b
.
lastModified
b
.
type
b
.
title
h
.
url
AS
url
b
.
id
AS
_id
b
.
parent
AS
_parentId
(
SELECT
count
(
*
)
FROM
moz_bookmarks
WHERE
parent
=
b
.
id
)
AS
_childCount
p
.
parent
AS
_grandParentId
b
.
syncStatus
AS
_syncStatus
FROM
moz_bookmarks
b
LEFT
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
b
.
fk
WHERE
p
.
guid
=
:
parentGuid
ORDER
BY
b
.
position
ASC
{
parentGuid
:
info
.
parentGuid
}
)
;
return
rowsToItemsArray
(
rows
)
;
}
)
)
;
}
function
removeBookmark
(
item
options
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
removeBookmark
"
Task
.
async
(
function
*
(
db
)
{
let
isUntagging
=
item
.
_grandParentId
=
=
PlacesUtils
.
tagsFolderId
;
yield
db
.
executeTransaction
(
function
*
transaction
(
)
{
if
(
item
.
type
=
=
Bookmarks
.
TYPE_FOLDER
)
{
if
(
options
.
preventRemovalOfNonEmptyFolders
&
&
item
.
_childCount
>
0
)
{
throw
new
Error
(
"
Cannot
remove
a
non
-
empty
folder
.
"
)
;
}
yield
removeFoldersContents
(
db
[
item
.
guid
]
options
)
;
}
if
(
!
isUntagging
)
{
yield
removeAnnotationsForItem
(
db
item
.
_id
)
;
}
yield
db
.
executeCached
(
DELETE
FROM
moz_bookmarks
WHERE
guid
=
:
guid
{
guid
:
item
.
guid
}
)
;
yield
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
position
=
position
-
1
WHERE
parent
=
:
parentId
AND
position
>
:
index
{
parentId
:
item
.
_parentId
index
:
item
.
index
}
)
;
let
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
options
.
source
)
;
if
(
isUntagging
)
{
yield
PlacesSyncUtils
.
bookmarks
.
addSyncChangesForBookmarksWithURL
(
db
item
.
url
syncChangeDelta
)
;
}
yield
insertTombstone
(
db
item
syncChangeDelta
)
;
yield
setAncestorsLastModified
(
db
item
.
parentGuid
new
Date
(
)
syncChangeDelta
)
;
}
)
;
if
(
item
.
type
=
=
Bookmarks
.
TYPE_BOOKMARK
&
&
!
isUntagging
)
{
updateFrecency
(
db
[
item
.
url
]
)
.
then
(
null
Cu
.
reportError
)
;
}
return
item
;
}
)
)
;
}
function
reorderChildren
(
parent
orderedChildrenGuids
options
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
Bookmarks
.
jsm
:
updateBookmark
"
db
=
>
db
.
executeTransaction
(
function
*
(
)
{
let
children
=
yield
fetchBookmarksByParent
(
{
parentGuid
:
parent
.
guid
}
)
;
if
(
!
children
.
length
)
return
undefined
;
let
guidIndices
=
new
Map
(
)
;
for
(
let
i
=
0
;
i
<
orderedChildrenGuids
.
length
;
+
+
i
)
{
let
guid
=
orderedChildrenGuids
[
i
]
;
guidIndices
.
set
(
guid
i
)
;
}
children
.
sort
(
(
a
b
)
=
>
{
if
(
!
guidIndices
.
has
(
a
.
guid
)
&
&
!
guidIndices
.
has
(
b
.
guid
)
)
{
return
0
;
}
if
(
!
guidIndices
.
has
(
a
.
guid
)
)
{
return
1
;
}
if
(
!
guidIndices
.
has
(
b
.
guid
)
)
{
return
-
1
;
}
return
guidIndices
.
get
(
a
.
guid
)
<
guidIndices
.
get
(
b
.
guid
)
?
-
1
:
1
;
}
)
;
let
valuesTable
=
children
.
map
(
(
child
i
)
=
>
(
"
{
child
.
guid
}
"
{
i
}
)
)
.
join
(
)
;
yield
db
.
execute
(
WITH
sorting
(
g
p
)
AS
(
VALUES
{
valuesTable
}
)
UPDATE
moz_bookmarks
SET
position
=
(
SELECT
CASE
count
(
*
)
WHEN
0
THEN
-
position
ELSE
count
(
*
)
-
1
END
FROM
sorting
a
JOIN
sorting
b
ON
b
.
p
<
=
a
.
p
WHERE
a
.
g
=
guid
)
WHERE
parent
=
:
parentId
{
parentId
:
parent
.
_id
}
)
;
let
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
options
.
source
)
;
if
(
syncChangeDelta
)
{
yield
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
:
syncChangeDelta
WHERE
id
=
:
parentId
{
parentId
:
parent
.
_id
syncChangeDelta
}
)
;
}
yield
db
.
executeCached
(
CREATE
TEMP
TRIGGER
moz_bookmarks_reorder_trigger
AFTER
UPDATE
OF
position
ON
moz_bookmarks
WHEN
NEW
.
position
=
-
1
BEGIN
UPDATE
moz_bookmarks
SET
position
=
(
SELECT
MAX
(
position
)
FROM
moz_bookmarks
WHERE
parent
=
NEW
.
parent
)
+
(
SELECT
count
(
*
)
FROM
moz_bookmarks
WHERE
parent
=
NEW
.
parent
AND
position
BETWEEN
OLD
.
position
AND
-
1
)
WHERE
guid
=
NEW
.
guid
;
END
)
;
yield
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
position
=
-
1
WHERE
position
<
0
)
;
yield
db
.
executeCached
(
DROP
TRIGGER
moz_bookmarks_reorder_trigger
)
;
let
possibleOrphanIds
=
[
]
;
for
(
let
child
of
children
)
{
if
(
guidIndices
.
has
(
child
.
guid
)
)
{
possibleOrphanIds
.
push
(
child
.
_id
)
;
}
}
yield
db
.
executeCached
(
DELETE
FROM
moz_items_annos
WHERE
anno_attribute_id
=
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
:
orphanAnno
)
AND
item_id
IN
(
{
possibleOrphanIds
.
join
(
"
"
)
}
)
{
orphanAnno
:
PlacesSyncUtils
.
bookmarks
.
SYNC_PARENT_ANNO
}
)
;
return
children
;
}
)
)
;
}
function
mergeIntoNewObject
(
.
.
.
sources
)
{
let
dest
=
{
}
;
for
(
let
src
of
sources
)
{
for
(
let
prop
of
Object
.
getOwnPropertyNames
(
src
)
)
{
Object
.
defineProperty
(
dest
prop
Object
.
getOwnPropertyDescriptor
(
src
prop
)
)
;
}
}
return
dest
;
}
function
removeSameValueProperties
(
dest
src
)
{
for
(
let
prop
in
dest
)
{
let
remove
=
false
;
switch
(
prop
)
{
case
"
lastModified
"
:
case
"
dateAdded
"
:
remove
=
src
.
hasOwnProperty
(
prop
)
&
&
dest
[
prop
]
.
getTime
(
)
=
=
src
[
prop
]
.
getTime
(
)
;
break
;
case
"
url
"
:
remove
=
src
.
hasOwnProperty
(
prop
)
&
&
dest
[
prop
]
.
href
=
=
src
[
prop
]
.
href
;
break
;
default
:
remove
=
dest
[
prop
]
=
=
src
[
prop
]
;
}
if
(
remove
&
&
prop
!
=
"
guid
"
)
delete
dest
[
prop
]
;
}
}
function
rowsToItemsArray
(
rows
)
{
return
rows
.
map
(
row
=
>
{
let
item
=
{
}
;
for
(
let
prop
of
[
"
guid
"
"
index
"
"
type
"
]
)
{
item
[
prop
]
=
row
.
getResultByName
(
prop
)
;
}
for
(
let
prop
of
[
"
dateAdded
"
"
lastModified
"
]
)
{
item
[
prop
]
=
PlacesUtils
.
toDate
(
row
.
getResultByName
(
prop
)
)
;
}
for
(
let
prop
of
[
"
title
"
"
parentGuid
"
"
url
"
]
)
{
let
val
=
row
.
getResultByName
(
prop
)
;
if
(
val
)
item
[
prop
]
=
prop
=
=
=
"
url
"
?
new
URL
(
val
)
:
val
;
}
for
(
let
prop
of
[
"
_id
"
"
_parentId
"
"
_childCount
"
"
_grandParentId
"
"
_syncStatus
"
]
)
{
let
val
=
row
.
getResultByName
(
prop
)
;
if
(
val
!
=
=
null
)
{
Object
.
defineProperty
(
item
prop
{
value
:
val
enumerable
:
false
configurable
:
true
}
)
;
}
}
return
item
;
}
)
;
}
function
validateBookmarkObject
(
input
behavior
)
{
return
PlacesUtils
.
validateItemProperties
(
PlacesUtils
.
BOOKMARK_VALIDATORS
input
behavior
)
;
}
var
updateFrecency
=
Task
.
async
(
function
*
(
db
urls
)
{
yield
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
NOTIFY_FRECENCY
(
CALCULATE_FRECENCY
(
id
)
url
guid
hidden
last_visit_date
)
WHERE
url_hash
IN
(
{
urls
.
map
(
url
=
>
hash
(
"
{
url
.
href
}
"
)
)
.
join
(
"
"
)
}
)
)
;
yield
db
.
execute
(
UPDATE
moz_places
SET
hidden
=
0
WHERE
url_hash
IN
(
{
urls
.
map
(
url
=
>
hash
(
{
JSON
.
stringify
(
url
.
href
)
}
)
)
.
join
(
"
"
)
}
)
AND
frecency
<
>
0
)
;
}
)
;
var
removeOrphanAnnotations
=
Task
.
async
(
function
*
(
db
)
{
yield
db
.
executeCached
(
DELETE
FROM
moz_items_annos
WHERE
id
IN
(
SELECT
a
.
id
from
moz_items_annos
a
LEFT
JOIN
moz_bookmarks
b
ON
a
.
item_id
=
b
.
id
WHERE
b
.
id
ISNULL
)
)
;
yield
db
.
executeCached
(
DELETE
FROM
moz_anno_attributes
WHERE
id
IN
(
SELECT
n
.
id
from
moz_anno_attributes
n
LEFT
JOIN
moz_annos
a1
ON
a1
.
anno_attribute_id
=
n
.
id
LEFT
JOIN
moz_items_annos
a2
ON
a2
.
anno_attribute_id
=
n
.
id
WHERE
a1
.
id
ISNULL
AND
a2
.
id
ISNULL
)
)
;
}
)
;
var
removeAnnotationsForItem
=
Task
.
async
(
function
*
(
db
itemId
)
{
yield
db
.
executeCached
(
DELETE
FROM
moz_items_annos
WHERE
item_id
=
:
id
{
id
:
itemId
}
)
;
yield
db
.
executeCached
(
DELETE
FROM
moz_anno_attributes
WHERE
id
IN
(
SELECT
n
.
id
from
moz_anno_attributes
n
LEFT
JOIN
moz_annos
a1
ON
a1
.
anno_attribute_id
=
n
.
id
LEFT
JOIN
moz_items_annos
a2
ON
a2
.
anno_attribute_id
=
n
.
id
WHERE
a1
.
id
ISNULL
AND
a2
.
id
ISNULL
)
)
;
}
)
;
var
setAncestorsLastModified
=
Task
.
async
(
function
*
(
db
folderGuid
time
syncChangeDelta
)
{
yield
db
.
executeCached
(
WITH
RECURSIVE
ancestors
(
aid
)
AS
(
SELECT
id
FROM
moz_bookmarks
WHERE
guid
=
:
guid
UNION
ALL
SELECT
parent
FROM
moz_bookmarks
JOIN
ancestors
ON
id
=
aid
WHERE
type
=
:
type
)
UPDATE
moz_bookmarks
SET
lastModified
=
:
time
WHERE
id
IN
ancestors
{
guid
:
folderGuid
type
:
Bookmarks
.
TYPE_FOLDER
time
:
PlacesUtils
.
toPRTime
(
time
)
}
)
;
if
(
syncChangeDelta
)
{
yield
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
:
syncChangeDelta
WHERE
guid
=
:
guid
{
guid
:
folderGuid
syncChangeDelta
}
)
;
}
}
)
;
var
removeFoldersContents
=
Task
.
async
(
function
*
(
db
folderGuids
options
)
{
let
syncChangeDelta
=
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
options
.
source
)
;
let
itemsRemoved
=
[
]
;
for
(
let
folderGuid
of
folderGuids
)
{
let
rows
=
yield
db
.
executeCached
(
WITH
RECURSIVE
descendants
(
did
)
AS
(
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
b
.
parent
=
p
.
id
WHERE
p
.
guid
=
:
folderGuid
UNION
ALL
SELECT
id
FROM
moz_bookmarks
JOIN
descendants
ON
parent
=
did
)
SELECT
b
.
id
AS
_id
b
.
parent
AS
_parentId
b
.
position
AS
'
index
'
b
.
type
url
b
.
guid
p
.
guid
AS
parentGuid
b
.
dateAdded
b
.
lastModified
b
.
title
p
.
parent
AS
_grandParentId
NULL
AS
_childCount
b
.
syncStatus
AS
_syncStatus
FROM
descendants
JOIN
moz_bookmarks
b
ON
did
=
b
.
id
JOIN
moz_bookmarks
p
ON
p
.
id
=
b
.
parent
LEFT
JOIN
moz_places
h
ON
b
.
fk
=
h
.
id
{
folderGuid
}
)
;
itemsRemoved
=
itemsRemoved
.
concat
(
rowsToItemsArray
(
rows
)
)
;
yield
db
.
executeCached
(
WITH
RECURSIVE
descendants
(
did
)
AS
(
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
b
.
parent
=
p
.
id
WHERE
p
.
guid
=
:
folderGuid
UNION
ALL
SELECT
id
FROM
moz_bookmarks
JOIN
descendants
ON
parent
=
did
)
DELETE
FROM
moz_bookmarks
WHERE
id
IN
descendants
{
folderGuid
}
)
;
}
yield
insertTombstones
(
db
itemsRemoved
syncChangeDelta
)
;
yield
addSyncChangesForRemovedTagFolders
(
db
itemsRemoved
syncChangeDelta
)
;
yield
removeOrphanAnnotations
(
db
)
;
let
urls
=
itemsRemoved
.
filter
(
item
=
>
"
url
"
in
item
)
.
map
(
item
=
>
item
.
url
)
;
updateFrecency
(
db
urls
)
.
then
(
null
Cu
.
reportError
)
;
let
{
source
=
Bookmarks
.
SOURCES
.
DEFAULT
}
=
options
;
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
for
(
let
item
of
itemsRemoved
.
reverse
(
)
)
{
let
uri
=
item
.
hasOwnProperty
(
"
url
"
)
?
PlacesUtils
.
toURI
(
item
.
url
)
:
null
;
notify
(
observers
"
onItemRemoved
"
[
item
.
_id
item
.
_parentId
item
.
index
item
.
type
uri
item
.
guid
item
.
parentGuid
source
]
{
isDescendantRemoval
:
true
}
)
;
let
isUntagging
=
item
.
_grandParentId
=
=
PlacesUtils
.
tagsFolderId
;
if
(
isUntagging
)
{
for
(
let
entry
of
(
yield
fetchBookmarksByURL
(
item
)
)
)
{
notify
(
observers
"
onItemChanged
"
[
entry
.
_id
"
tags
"
false
"
"
PlacesUtils
.
toPRTime
(
entry
.
lastModified
)
entry
.
type
entry
.
_parentId
entry
.
guid
entry
.
parentGuid
"
"
source
]
)
;
}
}
}
}
)
;
function
maybeInsertPlace
(
db
url
)
{
return
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
moz_places
(
url
url_hash
rev_host
hidden
frecency
guid
)
VALUES
(
:
url
hash
(
:
url
)
:
rev_host
0
:
frecency
IFNULL
(
(
SELECT
guid
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
GENERATE_GUID
(
)
)
)
{
url
:
url
.
href
rev_host
:
PlacesUtils
.
getReversedHost
(
url
)
frecency
:
url
.
protocol
=
=
"
place
:
"
?
0
:
-
1
}
)
;
}
function
needsTombstone
(
item
)
{
return
item
.
_syncStatus
=
=
Bookmarks
.
SYNC_STATUS
.
NORMAL
;
}
function
insertTombstone
(
db
item
syncChangeDelta
)
{
if
(
!
syncChangeDelta
|
|
!
needsTombstone
(
item
)
)
{
return
Promise
.
resolve
(
)
;
}
return
db
.
executeCached
(
INSERT
INTO
moz_bookmarks_deleted
(
guid
dateRemoved
)
VALUES
(
:
guid
:
dateRemoved
)
{
guid
:
item
.
guid
dateRemoved
:
PlacesUtils
.
toPRTime
(
Date
.
now
(
)
)
}
)
;
}
function
insertTombstones
(
db
itemsRemoved
syncChangeDelta
)
{
if
(
!
syncChangeDelta
)
{
return
Promise
.
resolve
(
)
;
}
let
syncedItems
=
itemsRemoved
.
filter
(
needsTombstone
)
;
if
(
!
syncedItems
.
length
)
{
return
Promise
.
resolve
(
)
;
}
let
dateRemoved
=
PlacesUtils
.
toPRTime
(
Date
.
now
(
)
)
;
let
valuesTable
=
syncedItems
.
map
(
item
=
>
(
{
JSON
.
stringify
(
item
.
guid
)
}
{
dateRemoved
}
)
)
.
join
(
"
"
)
;
return
db
.
execute
(
INSERT
INTO
moz_bookmarks_deleted
(
guid
dateRemoved
)
VALUES
{
valuesTable
}
)
;
}
var
addSyncChangesForRemovedTagFolders
=
Task
.
async
(
function
*
(
db
itemsRemoved
syncChangeDelta
)
{
if
(
!
syncChangeDelta
)
{
return
;
}
for
(
let
item
of
itemsRemoved
)
{
let
isUntagging
=
item
.
_grandParentId
=
=
PlacesUtils
.
tagsFolderId
;
if
(
isUntagging
)
{
yield
PlacesSyncUtils
.
bookmarks
.
addSyncChangesForBookmarksWithURL
(
db
item
.
url
syncChangeDelta
)
;
}
}
}
)
;
function
addSyncChangesForBookmarksInFolder
(
db
folder
syncChangeDelta
)
{
if
(
!
syncChangeDelta
)
{
return
Promise
.
resolve
(
)
;
}
return
db
.
execute
(
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
syncChangeCounter
+
:
syncChangeDelta
WHERE
type
=
:
type
AND
fk
=
(
SELECT
fk
FROM
moz_bookmarks
WHERE
parent
=
:
parent
)
{
syncChangeDelta
type
:
Bookmarks
.
TYPE_BOOKMARK
parent
:
folder
.
_id
}
)
;
}
