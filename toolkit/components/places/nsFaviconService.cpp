#
include
"
nsFaviconService
.
h
"
#
include
"
PlacesCompletionCallback
.
h
"
#
include
"
nsNavHistory
.
h
"
#
include
"
nsPlacesMacros
.
h
"
#
include
"
Helpers
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
plbase64
.
h
"
#
include
"
nsIClassInfoImpl
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
imgICache
.
h
"
#
define
UNASSOCIATED_FAVICONS_LENGTH
32
#
define
UNASSOCIATED_ICON_EXPIRY_INTERVAL
60000
using
namespace
mozilla
;
using
namespace
mozilla
:
:
places
;
const
uint16_t
gFaviconSizes
[
7
]
=
{
192
144
96
64
48
32
16
}
;
class
ExpireFaviconsStatementCallbackNotifier
:
public
AsyncStatementCallback
{
public
:
ExpireFaviconsStatementCallbackNotifier
(
)
;
NS_IMETHOD
HandleCompletion
(
uint16_t
aReason
)
override
;
}
;
namespace
{
nsresult
GetFramesInfoForContainer
(
imgIContainer
*
aContainer
nsTArray
<
FrameData
>
&
aFramesInfo
)
{
bool
animated
;
nsresult
rv
=
aContainer
-
>
GetAnimated
(
&
animated
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
animated
)
{
nsTArray
<
nsIntSize
>
nativeSizes
;
rv
=
aContainer
-
>
GetNativeSizes
(
nativeSizes
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
nativeSizes
.
Length
(
)
>
1
)
{
for
(
uint32_t
i
=
0
;
i
<
nativeSizes
.
Length
(
)
;
+
+
i
)
{
nsIntSize
nativeSize
=
nativeSizes
[
i
]
;
if
(
nativeSize
.
width
!
=
nativeSize
.
height
)
{
continue
;
}
const
auto
*
end
=
std
:
:
end
(
gFaviconSizes
)
;
const
uint16_t
*
matchingSize
=
std
:
:
find
(
std
:
:
begin
(
gFaviconSizes
)
end
nativeSize
.
width
)
;
if
(
matchingSize
!
=
end
)
{
bool
dupe
=
false
;
for
(
const
auto
&
frameInfo
:
aFramesInfo
)
{
if
(
frameInfo
.
width
=
=
*
matchingSize
)
{
dupe
=
true
;
break
;
}
}
if
(
!
dupe
)
{
aFramesInfo
.
AppendElement
(
FrameData
(
i
*
matchingSize
)
)
;
}
}
}
}
}
if
(
aFramesInfo
.
Length
(
)
=
=
0
)
{
int32_t
width
;
rv
=
aContainer
-
>
GetWidth
(
&
width
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
height
;
rv
=
aContainer
-
>
GetHeight
(
&
height
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aFramesInfo
.
AppendElement
(
FrameData
(
0
std
:
:
max
(
width
height
)
)
)
;
}
return
NS_OK
;
}
}
PLACES_FACTORY_SINGLETON_IMPLEMENTATION
(
nsFaviconService
gFaviconService
)
NS_IMPL_CLASSINFO
(
nsFaviconService
nullptr
0
NS_FAVICONSERVICE_CID
)
NS_IMPL_ISUPPORTS_CI
(
nsFaviconService
nsIFaviconService
nsITimerCallback
nsINamed
)
nsFaviconService
:
:
nsFaviconService
(
)
:
mUnassociatedIcons
(
UNASSOCIATED_FAVICONS_LENGTH
)
mDefaultIconURIPreferredSize
(
UINT16_MAX
)
{
NS_ASSERTION
(
!
gFaviconService
"
Attempting
to
create
two
instances
of
the
service
!
"
)
;
gFaviconService
=
this
;
}
nsFaviconService
:
:
~
nsFaviconService
(
)
{
NS_ASSERTION
(
gFaviconService
=
=
this
"
Deleting
a
non
-
singleton
instance
of
the
service
"
)
;
if
(
gFaviconService
=
=
this
)
gFaviconService
=
nullptr
;
}
Atomic
<
int64_t
>
nsFaviconService
:
:
sLastInsertedIconId
(
0
)
;
void
nsFaviconService
:
:
StoreLastInsertedId
(
const
nsACString
&
aTable
const
int64_t
aLastInsertedId
)
{
MOZ_ASSERT
(
aTable
.
EqualsLiteral
(
"
moz_icons
"
)
)
;
sLastInsertedIconId
=
aLastInsertedId
;
}
nsresult
nsFaviconService
:
:
Init
(
)
{
mDB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
mDB
)
;
mExpireUnassociatedIconsTimer
=
NS_NewTimer
(
)
;
NS_ENSURE_STATE
(
mExpireUnassociatedIconsTimer
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFaviconService
:
:
ExpireAllFavicons
(
)
{
NS_ENSURE_STATE
(
mDB
)
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
removePagesStmt
=
mDB
-
>
GetAsyncStatement
(
"
DELETE
FROM
moz_pages_w_icons
"
)
;
NS_ENSURE_STATE
(
removePagesStmt
)
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
removeIconsStmt
=
mDB
-
>
GetAsyncStatement
(
"
DELETE
FROM
moz_icons
"
)
;
NS_ENSURE_STATE
(
removeIconsStmt
)
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
unlinkIconsStmt
=
mDB
-
>
GetAsyncStatement
(
"
DELETE
FROM
moz_icons_to_pages
"
)
;
NS_ENSURE_STATE
(
unlinkIconsStmt
)
;
nsTArray
<
RefPtr
<
mozIStorageBaseStatement
>
>
stmts
=
{
ToRefPtr
(
std
:
:
move
(
removePagesStmt
)
)
ToRefPtr
(
std
:
:
move
(
removeIconsStmt
)
)
ToRefPtr
(
std
:
:
move
(
unlinkIconsStmt
)
)
}
;
nsCOMPtr
<
mozIStorageConnection
>
conn
=
mDB
-
>
MainConn
(
)
;
if
(
!
conn
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
mozIStoragePendingStatement
>
ps
;
RefPtr
<
ExpireFaviconsStatementCallbackNotifier
>
callback
=
new
ExpireFaviconsStatementCallbackNotifier
(
)
;
return
conn
-
>
ExecuteAsync
(
stmts
callback
getter_AddRefs
(
ps
)
)
;
}
NS_IMETHODIMP
nsFaviconService
:
:
Notify
(
nsITimer
*
timer
)
{
if
(
timer
!
=
mExpireUnassociatedIconsTimer
.
get
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
PRTime
now
=
PR_Now
(
)
;
for
(
auto
iter
=
mUnassociatedIcons
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
UnassociatedIconHashKey
*
iconKey
=
iter
.
Get
(
)
;
if
(
now
-
iconKey
-
>
created
>
=
UNASSOCIATED_ICON_EXPIRY_INTERVAL
)
{
iter
.
Remove
(
)
;
}
}
if
(
mUnassociatedIcons
.
Count
(
)
>
0
)
{
mExpireUnassociatedIconsTimer
-
>
InitWithCallback
(
this
UNASSOCIATED_ICON_EXPIRY_INTERVAL
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsFaviconService
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
nsFaviconService
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFaviconService
:
:
GetDefaultFavicon
(
nsIURI
*
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
if
(
!
mDefaultIcon
)
{
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
mDefaultIcon
)
nsLiteralCString
(
FAVICON_DEFAULT_URL
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIURI
>
uri
=
mDefaultIcon
;
uri
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFaviconService
:
:
GetDefaultFaviconMimeType
(
nsACString
&
_retval
)
{
_retval
=
nsLiteralCString
(
FAVICON_DEFAULT_MIMETYPE
)
;
return
NS_OK
;
}
void
nsFaviconService
:
:
ClearImageCache
(
nsIURI
*
aImageURI
)
{
MOZ_ASSERT
(
aImageURI
"
Must
pass
a
non
-
null
URI
"
)
;
nsCOMPtr
<
imgICache
>
imgCache
;
nsresult
rv
=
GetImgTools
(
)
-
>
GetImgCacheForDocument
(
nullptr
getter_AddRefs
(
imgCache
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
Unused
<
<
imgCache
-
>
RemoveEntry
(
aImageURI
nullptr
)
;
}
}
NS_IMETHODIMP
nsFaviconService
:
:
SetFaviconForPage
(
nsIURI
*
aPageURI
nsIURI
*
aFaviconURI
nsIURI
*
aDataURL
PRTime
aExpiration
=
0
PlacesCompletionCallback
*
aCallback
=
nullptr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aPageURI
)
;
NS_ENSURE_ARG
(
aFaviconURI
)
;
NS_ENSURE_ARG
(
aDataURL
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aDataURL
-
>
SchemeIs
(
"
data
"
)
)
;
if
(
!
aDataURL
-
>
SchemeIs
(
"
data
"
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
return
NS_OK
;
}
PRTime
now
=
PR_Now
(
)
;
if
(
aExpiration
<
now
+
MIN_FAVICON_EXPIRATION
)
{
aExpiration
=
now
+
MAX_FAVICON_EXPIRATION
;
}
nsresult
rv
=
NS_OK
;
auto
guard
=
MakeScopeExit
(
[
&
]
(
)
{
if
(
aCallback
)
{
aCallback
-
>
Complete
(
rv
)
;
}
}
)
;
nsCOMPtr
<
nsIIOService
>
ioService
=
do_GetIOService
(
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIProtocolHandler
>
protocolHandler
;
rv
=
ioService
-
>
GetProtocolHandler
(
"
data
"
getter_AddRefs
(
protocolHandler
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
if
(
MOZ_UNLIKELY
(
!
(
loadingPrincipal
)
)
)
{
return
(
rv
=
NS_ERROR_NULL_POINTER
)
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
new
mozilla
:
:
net
:
:
LoadInfo
(
loadingPrincipal
nullptr
nullptr
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_INHERITS_SEC_CONTEXT
|
nsILoadInfo
:
:
SEC_ALLOW_CHROME
|
nsILoadInfo
:
:
SEC_DISALLOW_SCRIPT
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
protocolHandler
-
>
NewChannel
(
aDataURL
loadInfo
getter_AddRefs
(
channel
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
channel
-
>
Open
(
getter_AddRefs
(
stream
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint64_t
available64
;
rv
=
stream
-
>
Available
(
&
available64
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
available64
=
=
0
|
|
available64
>
UINT32_MAX
/
sizeof
(
uint8_t
)
)
{
return
(
rv
=
NS_ERROR_FILE_TOO_BIG
)
;
}
uint32_t
available
=
(
uint32_t
)
available64
;
nsTArray
<
uint8_t
>
buffer
;
buffer
.
SetLength
(
available
)
;
uint32_t
numRead
;
rv
=
stream
-
>
Read
(
TO_CHARBUFFER
(
buffer
.
Elements
(
)
)
available
&
numRead
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
numRead
!
=
available
)
{
return
(
rv
=
NS_ERROR_UNEXPECTED
)
;
}
nsAutoCString
mimeType
;
rv
=
channel
-
>
GetContentType
(
mimeType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
imgLoader
:
:
SupportImageWithMimeType
(
mimeType
AcceptedMimeTypes
:
:
IMAGES_AND_DOCUMENTS
)
)
{
return
(
rv
=
NS_ERROR_UNEXPECTED
)
;
}
nsCOMPtr
<
nsIURI
>
faviconURI
=
GetExposableURI
(
aFaviconURI
)
;
nsCOMPtr
<
nsIURI
>
pageURI
=
GetExposableURI
(
aPageURI
)
;
IconData
icon
;
icon
.
expiration
=
aExpiration
;
icon
.
status
=
ICON_STATUS_CACHED
;
icon
.
fetchMode
=
FETCH_NEVER
;
rv
=
faviconURI
-
>
GetSpec
(
icon
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
(
void
)
faviconURI
-
>
GetHost
(
icon
.
host
)
;
if
(
StringBeginsWith
(
icon
.
host
"
www
.
"
_ns
)
)
{
icon
.
host
.
Cut
(
0
4
)
;
}
IconPayload
payload
;
payload
.
mimeType
=
mimeType
;
payload
.
data
.
Assign
(
TO_CHARBUFFER
(
buffer
.
Elements
(
)
)
buffer
.
Length
(
)
)
;
if
(
payload
.
mimeType
.
EqualsLiteral
(
SVG_MIME_TYPE
)
)
{
payload
.
width
=
UINT16_MAX
;
}
icon
.
payloads
.
AppendElement
(
payload
)
;
rv
=
OptimizeIconSizes
(
icon
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
PageData
page
;
rv
=
pageURI
-
>
GetSpec
(
page
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
(
void
)
pageURI
-
>
GetHost
(
page
.
host
)
;
if
(
StringBeginsWith
(
page
.
host
"
www
.
"
_ns
)
)
{
page
.
host
.
Cut
(
0
4
)
;
}
nsAutoCString
path
;
if
(
NS_SUCCEEDED
(
faviconURI
-
>
GetPathQueryRef
(
path
)
)
&
&
!
icon
.
host
.
IsEmpty
(
)
&
&
icon
.
host
.
Equals
(
page
.
host
)
&
&
path
.
EqualsLiteral
(
"
/
favicon
.
ico
"
)
)
{
icon
.
rootIcon
=
1
;
}
if
(
icon
.
spec
.
Equals
(
page
.
spec
)
|
|
icon
.
spec
.
EqualsLiteral
(
FAVICON_CERTERRORPAGE_URL
)
|
|
icon
.
spec
.
EqualsLiteral
(
FAVICON_ERRORPAGE_URL
)
)
{
return
NS_OK
;
}
RefPtr
<
AsyncSetIconForPage
>
event
=
new
AsyncSetIconForPage
(
icon
page
aCallback
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
if
(
MOZ_UNLIKELY
(
!
DB
)
)
{
return
(
rv
=
NS_ERROR_UNEXPECTED
)
;
}
DB
-
>
DispatchToAsyncThread
(
event
)
;
guard
.
release
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFaviconService
:
:
SetAndFetchFaviconForPage
(
nsIURI
*
aPageURI
nsIURI
*
aFaviconURI
bool
aForceReload
uint32_t
aFaviconLoadType
nsIFaviconDataCallback
*
aCallback
nsIPrincipal
*
aLoadingPrincipal
uint64_t
aRequestContextID
mozIPlacesPendingOperation
*
*
_canceler
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aPageURI
)
;
NS_ENSURE_ARG
(
aFaviconURI
)
;
NS_ENSURE_ARG_POINTER
(
_canceler
)
;
nsCOMPtr
<
nsIURI
>
pageURI
=
GetExposableURI
(
aPageURI
)
;
nsCOMPtr
<
nsIURI
>
faviconURI
=
GetExposableURI
(
aFaviconURI
)
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
aLoadingPrincipal
;
MOZ_ASSERT
(
loadingPrincipal
"
please
provide
aLoadingPrincipal
for
this
favicon
"
)
;
if
(
!
loadingPrincipal
)
{
AutoTArray
<
nsString
2
>
params
=
{
u
"
nsFaviconService
:
:
setAndFetchFaviconForPage
(
)
"
_ns
u
"
nsFaviconService
:
:
setAndFetchFaviconForPage
(
.
.
.
"
"
[
optional
aLoadingPrincipal
]
)
"
_ns
}
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Security
by
Default
"
_ns
nullptr
nsContentUtils
:
:
eNECKO_PROPERTIES
"
APIDeprecationWarning
"
params
)
;
loadingPrincipal
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
}
NS_ENSURE_TRUE
(
loadingPrincipal
NS_ERROR_FAILURE
)
;
bool
loadPrivate
=
aFaviconLoadType
=
=
nsIFaviconService
:
:
FAVICON_LOAD_PRIVATE
;
PageData
page
;
nsresult
rv
=
pageURI
-
>
GetSpec
(
page
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Unused
<
<
pageURI
-
>
GetHost
(
page
.
host
)
;
if
(
StringBeginsWith
(
page
.
host
"
www
.
"
_ns
)
)
{
page
.
host
.
Cut
(
0
4
)
;
}
bool
canAddToHistory
;
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
navHistory
NS_ERROR_OUT_OF_MEMORY
)
;
rv
=
navHistory
-
>
CanAddURI
(
pageURI
&
canAddToHistory
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
page
.
canAddToHistory
=
!
!
canAddToHistory
&
&
!
loadPrivate
;
IconData
icon
;
UnassociatedIconHashKey
*
iconKey
=
mUnassociatedIcons
.
GetEntry
(
faviconURI
)
;
if
(
iconKey
)
{
icon
=
iconKey
-
>
iconData
;
mUnassociatedIcons
.
RemoveEntry
(
iconKey
)
;
}
else
{
icon
.
fetchMode
=
aForceReload
?
FETCH_ALWAYS
:
FETCH_IF_MISSING
;
rv
=
faviconURI
-
>
GetSpec
(
icon
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Unused
<
<
faviconURI
-
>
GetHost
(
icon
.
host
)
;
if
(
StringBeginsWith
(
icon
.
host
"
www
.
"
_ns
)
)
{
icon
.
host
.
Cut
(
0
4
)
;
}
}
nsAutoCString
path
;
if
(
NS_SUCCEEDED
(
faviconURI
-
>
GetPathQueryRef
(
path
)
)
&
&
!
icon
.
host
.
IsEmpty
(
)
&
&
icon
.
host
.
Equals
(
page
.
host
)
&
&
path
.
EqualsLiteral
(
"
/
favicon
.
ico
"
)
)
{
icon
.
rootIcon
=
1
;
}
if
(
icon
.
spec
.
Equals
(
page
.
spec
)
|
|
icon
.
spec
.
EqualsLiteral
(
FAVICON_CERTERRORPAGE_URL
)
|
|
icon
.
spec
.
EqualsLiteral
(
FAVICON_ERRORPAGE_URL
)
)
{
return
NS_OK
;
}
RefPtr
<
AsyncFetchAndSetIconForPage
>
event
=
new
AsyncFetchAndSetIconForPage
(
icon
page
loadPrivate
aCallback
aLoadingPrincipal
aRequestContextID
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
DB
-
>
DispatchToAsyncThread
(
event
)
;
event
.
forget
(
_canceler
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFaviconService
:
:
ReplaceFaviconData
(
nsIURI
*
aFaviconURI
const
nsTArray
<
uint8_t
>
&
aData
const
nsACString
&
aMimeType
PRTime
aExpiration
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aFaviconURI
)
;
NS_ENSURE_ARG
(
aData
.
Length
(
)
>
0
)
;
NS_ENSURE_ARG
(
aMimeType
.
Length
(
)
>
0
)
;
NS_ENSURE_ARG
(
imgLoader
:
:
SupportImageWithMimeType
(
aMimeType
AcceptedMimeTypes
:
:
IMAGES_AND_DOCUMENTS
)
)
;
nsCOMPtr
<
nsIURI
>
faviconURI
=
GetExposableURI
(
aFaviconURI
)
;
PRTime
now
=
PR_Now
(
)
;
if
(
aExpiration
<
now
+
MIN_FAVICON_EXPIRATION
)
{
aExpiration
=
now
+
MAX_FAVICON_EXPIRATION
;
}
UnassociatedIconHashKey
*
iconKey
=
mUnassociatedIcons
.
PutEntry
(
faviconURI
)
;
if
(
!
iconKey
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
iconKey
-
>
created
=
now
;
uint32_t
unassociatedCount
=
mUnassociatedIcons
.
Count
(
)
;
if
(
unassociatedCount
=
=
1
)
{
mExpireUnassociatedIconsTimer
-
>
Cancel
(
)
;
mExpireUnassociatedIconsTimer
-
>
InitWithCallback
(
this
UNASSOCIATED_ICON_EXPIRY_INTERVAL
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
IconData
*
iconData
=
&
(
iconKey
-
>
iconData
)
;
iconData
-
>
expiration
=
aExpiration
;
iconData
-
>
status
=
ICON_STATUS_CACHED
;
iconData
-
>
fetchMode
=
FETCH_NEVER
;
nsresult
rv
=
faviconURI
-
>
GetSpec
(
iconData
-
>
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Unused
<
<
faviconURI
-
>
GetHost
(
iconData
-
>
host
)
;
if
(
StringBeginsWith
(
iconData
-
>
host
"
www
.
"
_ns
)
)
{
iconData
-
>
host
.
Cut
(
0
4
)
;
}
IconPayload
payload
;
payload
.
mimeType
=
aMimeType
;
payload
.
data
.
Assign
(
TO_CHARBUFFER
(
aData
.
Elements
(
)
)
aData
.
Length
(
)
)
;
if
(
payload
.
mimeType
.
EqualsLiteral
(
SVG_MIME_TYPE
)
)
{
payload
.
width
=
UINT16_MAX
;
}
iconData
-
>
payloads
.
Clear
(
)
;
iconData
-
>
payloads
.
AppendElement
(
payload
)
;
rv
=
OptimizeIconSizes
(
*
iconData
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
(
*
iconData
)
.
payloads
.
Length
(
)
=
=
0
)
{
mUnassociatedIcons
.
RemoveEntry
(
faviconURI
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
AsyncReplaceFaviconData
>
event
=
new
AsyncReplaceFaviconData
(
*
iconData
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
DB
-
>
DispatchToAsyncThread
(
event
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFaviconService
:
:
ReplaceFaviconDataFromDataURL
(
nsIURI
*
aFaviconURI
const
nsAString
&
aDataURL
PRTime
aExpiration
nsIPrincipal
*
aLoadingPrincipal
)
{
NS_ENSURE_ARG
(
aFaviconURI
)
;
NS_ENSURE_TRUE
(
aDataURL
.
Length
(
)
>
0
NS_ERROR_INVALID_ARG
)
;
PRTime
now
=
PR_Now
(
)
;
if
(
aExpiration
<
now
+
MIN_FAVICON_EXPIRATION
)
{
aExpiration
=
now
+
MAX_FAVICON_EXPIRATION
;
}
nsCOMPtr
<
nsIURI
>
dataURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
dataURI
)
aDataURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIIOService
>
ioService
=
do_GetIOService
(
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIProtocolHandler
>
protocolHandler
;
rv
=
ioService
-
>
GetProtocolHandler
(
"
data
"
getter_AddRefs
(
protocolHandler
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
aLoadingPrincipal
;
MOZ_ASSERT
(
loadingPrincipal
"
please
provide
aLoadingPrincipal
for
this
favicon
"
)
;
if
(
!
loadingPrincipal
)
{
AutoTArray
<
nsString
2
>
params
=
{
u
"
nsFaviconService
:
:
ReplaceFaviconDataFromDataURL
(
)
"
_ns
u
"
nsFaviconService
:
:
ReplaceFaviconDataFromDataURL
(
.
.
.
"
"
[
optional
aLoadingPrincipal
]
)
"
_ns
}
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Security
by
Default
"
_ns
nullptr
nsContentUtils
:
:
eNECKO_PROPERTIES
"
APIDeprecationWarning
"
params
)
;
loadingPrincipal
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
}
NS_ENSURE_TRUE
(
loadingPrincipal
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
new
mozilla
:
:
net
:
:
LoadInfo
(
loadingPrincipal
nullptr
nullptr
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_INHERITS_SEC_CONTEXT
|
nsILoadInfo
:
:
SEC_ALLOW_CHROME
|
nsILoadInfo
:
:
SEC_DISALLOW_SCRIPT
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
protocolHandler
-
>
NewChannel
(
dataURI
loadInfo
getter_AddRefs
(
channel
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
channel
-
>
Open
(
getter_AddRefs
(
stream
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint64_t
available64
;
rv
=
stream
-
>
Available
(
&
available64
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
available64
=
=
0
|
|
available64
>
UINT32_MAX
/
sizeof
(
uint8_t
)
)
{
return
NS_ERROR_FILE_TOO_BIG
;
}
uint32_t
available
=
(
uint32_t
)
available64
;
nsTArray
<
uint8_t
>
buffer
;
buffer
.
SetLength
(
available
)
;
uint32_t
numRead
;
rv
=
stream
-
>
Read
(
TO_CHARBUFFER
(
buffer
.
Elements
(
)
)
available
&
numRead
)
;
if
(
NS_FAILED
(
rv
)
|
|
numRead
!
=
available
)
{
return
rv
;
}
nsAutoCString
mimeType
;
rv
=
channel
-
>
GetContentType
(
mimeType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
ReplaceFaviconData
(
aFaviconURI
buffer
mimeType
aExpiration
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFaviconService
:
:
GetFaviconURLForPage
(
nsIURI
*
aPageURI
nsIFaviconDataCallback
*
aCallback
uint16_t
aPreferredWidth
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aPageURI
)
;
NS_ENSURE_ARG
(
aCallback
)
;
if
(
aPreferredWidth
=
=
0
)
{
aPreferredWidth
=
mDefaultIconURIPreferredSize
;
}
nsCOMPtr
<
nsIURI
>
pageURI
=
GetExposableURI
(
aPageURI
)
;
nsAutoCString
pageSpec
;
nsresult
rv
=
pageURI
-
>
GetSpec
(
pageSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
pageHost
;
Unused
<
<
aPageURI
-
>
GetHost
(
pageHost
)
;
RefPtr
<
AsyncGetFaviconURLForPage
>
event
=
new
AsyncGetFaviconURLForPage
(
pageSpec
pageHost
aPreferredWidth
aCallback
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
DB
-
>
DispatchToAsyncThread
(
event
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFaviconService
:
:
GetFaviconDataForPage
(
nsIURI
*
aPageURI
nsIFaviconDataCallback
*
aCallback
uint16_t
aPreferredWidth
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aPageURI
)
;
NS_ENSURE_ARG
(
aCallback
)
;
if
(
aPreferredWidth
=
=
0
)
{
aPreferredWidth
=
mDefaultIconURIPreferredSize
;
}
nsCOMPtr
<
nsIURI
>
pageURI
=
GetExposableURI
(
aPageURI
)
;
nsAutoCString
pageSpec
;
nsresult
rv
=
pageURI
-
>
GetSpec
(
pageSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
pageHost
;
Unused
<
<
pageURI
-
>
GetHost
(
pageHost
)
;
RefPtr
<
AsyncGetFaviconDataForPage
>
event
=
new
AsyncGetFaviconDataForPage
(
pageSpec
pageHost
aPreferredWidth
aCallback
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
DB
-
>
DispatchToAsyncThread
(
event
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFaviconService
:
:
CopyFavicons
(
nsIURI
*
aFromPageURI
nsIURI
*
aToPageURI
uint32_t
aFaviconLoadType
nsIFaviconDataCallback
*
aCallback
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aFromPageURI
)
;
NS_ENSURE_ARG
(
aToPageURI
)
;
NS_ENSURE_TRUE
(
aFaviconLoadType
>
=
nsIFaviconService
:
:
FAVICON_LOAD_PRIVATE
&
&
aFaviconLoadType
<
=
nsIFaviconService
:
:
FAVICON_LOAD_NON_PRIVATE
NS_ERROR_INVALID_ARG
)
;
nsCOMPtr
<
nsIURI
>
fromPageURI
=
GetExposableURI
(
aFromPageURI
)
;
nsCOMPtr
<
nsIURI
>
toPageURI
=
GetExposableURI
(
aToPageURI
)
;
PageData
fromPage
;
nsresult
rv
=
fromPageURI
-
>
GetSpec
(
fromPage
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
PageData
toPage
;
rv
=
toPageURI
-
>
GetSpec
(
toPage
.
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
canAddToHistory
;
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetHistoryService
(
)
;
NS_ENSURE_TRUE
(
navHistory
NS_ERROR_OUT_OF_MEMORY
)
;
rv
=
navHistory
-
>
CanAddURI
(
toPageURI
&
canAddToHistory
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
toPage
.
canAddToHistory
=
!
!
canAddToHistory
&
&
aFaviconLoadType
!
=
nsIFaviconService
:
:
FAVICON_LOAD_PRIVATE
;
RefPtr
<
AsyncCopyFavicons
>
event
=
new
AsyncCopyFavicons
(
fromPage
toPage
aCallback
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
DB
-
>
DispatchToAsyncThread
(
event
)
;
return
NS_OK
;
}
nsresult
nsFaviconService
:
:
GetFaviconLinkForIcon
(
nsIURI
*
aFaviconURI
nsIURI
*
*
_retval
)
{
NS_ENSURE_ARG
(
aFaviconURI
)
;
NS_ENSURE_ARG_POINTER
(
_retval
)
;
nsAutoCString
spec
;
if
(
aFaviconURI
)
{
nsCOMPtr
<
nsIURI
>
faviconURI
=
GetExposableURI
(
aFaviconURI
)
;
static
constexpr
nsLiteralCString
sDirectRequestProtocols
[
]
=
{
"
about
"
_ns
"
cached
-
favicon
"
_ns
"
chrome
"
_ns
"
data
"
_ns
"
file
"
_ns
"
moz
-
page
-
thumb
"
_ns
"
page
-
icon
"
_ns
"
resource
"
_ns
}
;
nsAutoCString
iconURIScheme
;
if
(
NS_SUCCEEDED
(
faviconURI
-
>
GetScheme
(
iconURIScheme
)
)
&
&
std
:
:
find
(
std
:
:
begin
(
sDirectRequestProtocols
)
std
:
:
end
(
sDirectRequestProtocols
)
iconURIScheme
)
!
=
std
:
:
end
(
sDirectRequestProtocols
)
)
{
*
_retval
=
do_AddRef
(
faviconURI
)
.
take
(
)
;
return
NS_OK
;
}
nsresult
rv
=
faviconURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
GetFaviconLinkForIconString
(
spec
_retval
)
;
}
nsresult
nsFaviconService
:
:
GetFaviconLinkForIconString
(
const
nsCString
&
aSpec
nsIURI
*
*
aOutput
)
{
if
(
aSpec
.
IsEmpty
(
)
)
{
return
GetDefaultFavicon
(
aOutput
)
;
}
if
(
StringBeginsWith
(
aSpec
"
chrome
:
"
_ns
)
)
{
return
NS_NewURI
(
aOutput
aSpec
)
;
}
nsAutoCString
annoUri
;
annoUri
.
AssignLiteral
(
"
cached
-
favicon
:
"
)
;
annoUri
+
=
aSpec
;
return
NS_NewURI
(
aOutput
annoUri
)
;
}
nsresult
nsFaviconService
:
:
OptimizeIconSizes
(
IconData
&
aIcon
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aIcon
.
payloads
.
Length
(
)
=
=
1
)
;
IconPayload
payload
=
aIcon
.
payloads
[
0
]
;
if
(
payload
.
mimeType
.
EqualsLiteral
(
SVG_MIME_TYPE
)
)
{
if
(
payload
.
data
.
Length
(
)
>
=
nsIFaviconService
:
:
MAX_FAVICON_BUFFER_SIZE
)
{
aIcon
.
payloads
.
Clear
(
)
;
}
return
NS_OK
;
}
aIcon
.
payloads
.
Clear
(
)
;
nsCOMPtr
<
imgIContainer
>
container
;
nsresult
rv
=
GetImgTools
(
)
-
>
DecodeImageFromBuffer
(
payload
.
data
.
get
(
)
payload
.
data
.
Length
(
)
payload
.
mimeType
getter_AddRefs
(
container
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsTArray
<
FrameData
>
framesInfo
;
rv
=
GetFramesInfoForContainer
(
container
framesInfo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
const
auto
&
frameInfo
:
framesInfo
)
{
IconPayload
newPayload
;
newPayload
.
mimeType
=
nsLiteralCString
(
PNG_MIME_TYPE
)
;
newPayload
.
width
=
frameInfo
.
width
;
for
(
uint16_t
size
:
gFaviconSizes
)
{
if
(
frameInfo
.
width
>
=
16
)
{
if
(
size
>
frameInfo
.
width
)
{
continue
;
}
newPayload
.
width
=
size
;
}
bool
animated
;
if
(
newPayload
.
mimeType
.
Equals
(
payload
.
mimeType
)
&
&
newPayload
.
width
=
=
frameInfo
.
width
&
&
payload
.
data
.
Length
(
)
<
nsIFaviconService
:
:
MAX_FAVICON_BUFFER_SIZE
&
&
(
NS_FAILED
(
container
-
>
GetAnimated
(
&
animated
)
)
|
|
!
animated
)
)
{
newPayload
.
data
=
payload
.
data
;
break
;
}
nsCOMPtr
<
nsIInputStream
>
iconStream
;
rv
=
GetImgTools
(
)
-
>
EncodeScaledImage
(
container
newPayload
.
mimeType
newPayload
.
width
newPayload
.
width
u
"
"
_ns
getter_AddRefs
(
iconStream
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
NS_ConsumeStream
(
iconStream
UINT32_MAX
newPayload
.
data
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
newPayload
.
data
.
Length
(
)
<
nsIFaviconService
:
:
MAX_FAVICON_BUFFER_SIZE
)
{
break
;
}
}
MOZ_ASSERT
(
newPayload
.
data
.
Length
(
)
<
nsIFaviconService
:
:
MAX_FAVICON_BUFFER_SIZE
)
;
if
(
newPayload
.
data
.
Length
(
)
<
nsIFaviconService
:
:
MAX_FAVICON_BUFFER_SIZE
)
{
aIcon
.
payloads
.
AppendElement
(
newPayload
)
;
}
}
return
NS_OK
;
}
nsresult
nsFaviconService
:
:
GetFaviconDataAsync
(
const
nsCString
&
aFaviconSpec
mozIStorageStatementCallback
*
aCallback
)
{
MOZ_ASSERT
(
aCallback
"
Doesn
'
t
make
sense
to
call
this
without
a
callback
"
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aFaviconSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uri
=
GetExposableURI
(
uri
)
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
stmt
=
mDB
-
>
GetAsyncStatement
(
"
/
*
Do
not
warn
(
bug
no
:
not
worth
adding
an
index
*
/
"
"
SELECT
data
width
FROM
moz_icons
"
"
WHERE
fixed_icon_url_hash
=
hash
(
fixup_url
(
:
url
)
)
AND
icon_url
=
:
url
"
"
ORDER
BY
width
DESC
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
rv
=
URIBinder
:
:
Bind
(
stmt
"
url
"
_ns
uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
pendingStatement
;
return
stmt
-
>
ExecuteAsync
(
aCallback
getter_AddRefs
(
pendingStatement
)
)
;
}
NS_IMETHODIMP
nsFaviconService
:
:
SetDefaultIconURIPreferredSize
(
uint16_t
aDefaultSize
)
{
mDefaultIconURIPreferredSize
=
aDefaultSize
>
0
?
aDefaultSize
:
UINT16_MAX
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFaviconService
:
:
PreferredSizeFromURI
(
nsIURI
*
aURI
uint16_t
*
_size
)
{
NS_ENSURE_ARG
(
aURI
)
;
*
_size
=
mDefaultIconURIPreferredSize
;
nsAutoCString
ref
;
if
(
NS_FAILED
(
aURI
-
>
GetRef
(
ref
)
)
|
|
ref
.
Length
(
)
=
=
0
)
return
NS_OK
;
int32_t
start
=
ref
.
RFind
(
"
size
=
"
)
;
if
(
start
>
=
0
&
&
ref
.
Length
(
)
>
static_cast
<
uint32_t
>
(
start
)
+
5
)
{
nsDependentCSubstring
size
;
size
.
Rebind
(
ref
start
+
5
)
;
auto
begin
=
size
.
BeginReading
(
)
end
=
size
.
EndReading
(
)
;
for
(
const
auto
*
ch
=
begin
;
ch
<
end
;
+
+
ch
)
{
if
(
*
ch
<
'
0
'
|
|
*
ch
>
'
9
'
)
{
return
NS_OK
;
}
}
nsresult
rv
;
uint16_t
val
=
PromiseFlatCString
(
size
)
.
ToInteger
(
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
_size
=
val
;
}
}
return
NS_OK
;
}
ExpireFaviconsStatementCallbackNotifier
:
:
ExpireFaviconsStatementCallbackNotifier
(
)
=
default
;
NS_IMETHODIMP
ExpireFaviconsStatementCallbackNotifier
:
:
HandleCompletion
(
uint16_t
aReason
)
{
if
(
aReason
!
=
mozIStorageStatementCallback
:
:
REASON_FINISHED
)
return
NS_OK
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
(
void
)
observerService
-
>
NotifyObservers
(
nullptr
NS_PLACES_FAVICONS_EXPIRED_TOPIC_ID
nullptr
)
;
}
return
NS_OK
;
}
