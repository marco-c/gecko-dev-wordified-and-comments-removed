"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PlacesPreviews
"
"
PlacesPreviewsHelperService
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
ComponentUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ComponentUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
BackgroundPageThumbs
:
"
resource
:
/
/
gre
/
modules
/
BackgroundPageThumbs
.
jsm
"
EventEmitter
:
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
PageThumbsStorage
:
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
function
(
)
{
return
console
.
createInstance
(
{
prefix
:
"
PlacesPreviews
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
places
.
previews
.
log
"
false
)
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
previewsEnabled
"
function
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
places
.
previews
.
enabled
"
false
)
;
}
)
;
const
DELETE_CHUNK_SIZE
=
50
;
const
DELETE_TIMEOUT_MS
=
60000
;
const
PREVIEWS_DIRECTORY
=
"
places
-
previews
"
;
const
DAYS_BEFORE_REPLACEMENT
=
30
;
class
LimitedSet
extends
Set
{
#
limit
=
100
;
add
(
key
)
{
super
.
add
(
key
)
;
let
oversize
=
this
.
size
-
this
.
#
limit
;
if
(
oversize
>
0
)
{
for
(
let
entry
of
this
)
{
if
(
oversize
-
-
<
=
0
)
{
break
;
}
this
.
delete
(
entry
)
;
}
}
}
}
class
DeletionHandler
{
#
timeoutId
=
null
;
#
shutdownProgress
=
{
}
;
#
timeout
=
DELETE_TIMEOUT_MS
;
get
timeout
(
)
{
return
this
.
#
timeout
;
}
set
timeout
(
val
)
{
if
(
this
.
#
timeoutId
)
{
clearTimeout
(
this
.
#
timeoutId
)
;
this
.
#
timeoutId
=
null
;
}
this
.
#
timeout
=
val
;
this
.
ensureRunning
(
)
;
}
constructor
(
)
{
PlacesUtils
.
history
.
shutdownClient
.
jsclient
.
addBlocker
(
"
PlacesPreviews
.
jsm
:
:
DeletionHandler
"
async
(
)
=
>
{
this
.
#
shutdownProgress
.
shuttingDown
=
true
;
clearTimeout
(
this
.
#
timeoutId
)
;
this
.
#
timeoutId
=
null
;
}
{
fetchState
:
(
)
=
>
this
.
#
shutdownProgress
}
)
;
}
ensureRunning
(
)
{
if
(
this
.
#
timeoutId
|
|
this
.
#
shutdownProgress
.
shuttingDown
)
{
return
;
}
this
.
#
timeoutId
=
setTimeout
(
(
)
=
>
{
this
.
#
timeoutId
=
null
;
ChromeUtils
.
idleDispatch
(
(
)
=
>
{
this
.
#
deleteChunk
(
)
.
catch
(
ex
=
>
logConsole
.
error
(
"
Error
during
previews
deletion
:
"
+
ex
)
)
;
}
)
;
}
this
.
timeout
)
;
}
async
#
deleteChunk
(
)
{
if
(
this
.
#
shutdownProgress
.
shuttingDown
)
{
return
;
}
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
count
;
let
hashes
=
(
await
db
.
executeCached
(
SELECT
hash
(
SELECT
count
(
*
)
FROM
moz_previews_tombstones
)
AS
count
FROM
moz_previews_tombstones
LIMIT
{
DELETE_CHUNK_SIZE
}
)
)
.
map
(
r
=
>
{
if
(
count
=
=
=
undefined
)
{
count
=
r
.
getResultByName
(
"
count
"
)
;
}
return
r
.
getResultByName
(
"
hash
"
)
;
}
)
;
if
(
!
count
|
|
this
.
#
shutdownProgress
.
shuttingDown
)
{
return
;
}
let
deleted
=
[
]
;
for
(
let
hash
of
hashes
)
{
let
filePath
=
PlacesPreviews
.
getPathForHash
(
hash
)
;
try
{
await
IOUtils
.
remove
(
filePath
)
;
PlacesPreviews
.
onDelete
(
filePath
)
;
deleted
.
push
(
hash
)
;
}
catch
(
ex
)
{
if
(
ex
instanceof
DOMException
&
&
ex
.
name
=
=
"
NotFoundError
"
)
{
deleted
.
push
(
hash
)
;
}
else
{
logConsole
.
error
(
"
Unable
to
delete
file
:
"
+
filePath
)
;
}
}
if
(
this
.
#
shutdownProgress
.
shuttingDown
)
{
return
;
}
}
/
/
Delete
hashes
from
tombstones
.
let
params
=
deleted
.
reduce
(
(
p
c
i
)
=
>
{
p
[
"
hash
"
+
i
]
=
c
;
return
p
;
}
{
}
)
;
await
PlacesUtils
.
withConnectionWrapper
(
"
PlacesPreviews
.
jsm
:
:
ExpirePreviews
"
async
db
=
>
{
await
db
.
execute
(
DELETE
FROM
moz_previews_tombstones
WHERE
hash
in
(
{
Object
.
keys
(
params
)
.
map
(
p
=
>
:
{
p
}
)
.
join
(
"
"
)
}
)
params
)
;
}
)
;
if
(
count
>
DELETE_CHUNK_SIZE
)
{
this
.
ensureRunning
(
)
;
}
}
}
/
*
*
*
Handles
previews
for
Places
urls
.
*
Previews
are
stored
in
WebP
format
using
MD5
hash
of
the
page
url
in
hex
*
format
.
All
the
previews
are
saved
into
a
"
places
-
previews
"
folder
under
*
the
roaming
profile
folder
.
*
/
const
PlacesPreviews
=
new
(
class
extends
EventEmitter
{
#
placesObserver
=
null
;
#
deletionHandler
=
null
;
/
/
This
is
used
as
a
cache
to
avoid
fetching
the
same
preview
multiple
/
/
times
in
a
short
timeframe
.
#
recentlyUpdatedPreviews
=
new
LimitedSet
(
)
;
fileExtension
=
"
.
webp
"
;
fileContentType
=
"
image
/
webp
"
;
constructor
(
)
{
super
(
)
;
this
.
#
placesObserver
=
new
PlacesWeakCallbackWrapper
(
this
.
handlePlacesEvents
.
bind
(
this
)
)
;
PlacesObservers
.
addListener
(
[
"
history
-
cleared
"
"
page
-
removed
"
]
this
.
#
placesObserver
)
;
this
.
#
deletionHandler
=
new
DeletionHandler
(
)
;
this
.
#
deletionHandler
.
ensureRunning
(
)
;
}
handlePlacesEvents
(
events
)
{
for
(
const
event
of
events
)
{
if
(
event
.
type
=
=
"
history
-
cleared
"
|
|
(
event
.
type
=
=
"
page
-
removed
"
&
&
event
.
isRemovedFromStore
)
)
{
this
.
#
deletionHandler
.
ensureRunning
(
)
;
return
;
}
}
}
get
enabled
(
)
{
return
previewsEnabled
;
}
getPath
(
)
{
return
PathUtils
.
join
(
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
.
path
PREVIEWS_DIRECTORY
)
;
}
getPathForUrl
(
url
)
{
return
PathUtils
.
join
(
this
.
getPath
(
)
PlacesUtils
.
md5
(
url
{
format
:
"
hex
"
}
)
+
this
.
fileExtension
)
;
}
getPathForHash
(
hash
)
{
return
PathUtils
.
join
(
this
.
getPath
(
)
hash
+
this
.
fileExtension
)
;
}
getPageThumbURL
(
url
)
{
return
(
"
moz
-
page
-
thumb
:
/
/
"
+
"
places
-
previews
"
+
"
/
?
url
=
"
+
encodeURIComponent
(
url
)
+
"
&
revision
=
"
+
PageThumbsStorage
.
getRevision
(
url
)
)
;
}
async
update
(
url
{
forceUpdate
=
false
}
=
{
}
)
{
if
(
!
this
.
enabled
)
{
return
false
;
}
let
filePath
=
this
.
getPathForUrl
(
url
)
;
if
(
!
forceUpdate
)
{
if
(
this
.
#
recentlyUpdatedPreviews
.
has
(
filePath
)
)
{
logConsole
.
debug
(
"
Skipping
update
because
recently
updated
"
)
;
return
true
;
}
try
{
let
fileInfo
=
await
IOUtils
.
stat
(
filePath
)
;
if
(
fileInfo
.
lastModified
>
Date
.
now
(
)
-
DAYS_BEFORE_REPLACEMENT
*
86400000
)
{
this
.
#
recentlyUpdatedPreviews
.
add
(
filePath
)
;
logConsole
.
debug
(
"
Skipping
update
because
file
is
recent
"
)
;
return
true
;
}
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
DOMException
)
|
|
ex
.
name
!
=
"
NotFoundError
"
)
{
logConsole
.
error
(
"
Error
while
trying
to
stat
(
)
preview
"
+
ex
)
;
return
false
;
}
}
}
let
buffer
=
await
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
errorUrl
)
=
>
{
if
(
errorUrl
=
=
url
)
{
resolve
(
null
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
"
page
-
thumbnail
:
error
"
)
;
BackgroundPageThumbs
.
capture
(
url
{
dontStore
:
true
contentType
:
this
.
fileContentType
onDone
:
(
url
reason
handle
)
=
>
{
Services
.
obs
.
removeObserver
(
observer
"
page
-
thumbnail
:
error
"
)
;
resolve
(
handle
?
.
data
)
;
}
}
)
;
}
)
;
if
(
!
buffer
)
{
logConsole
.
error
(
"
Unable
to
fetch
preview
:
"
+
url
)
;
return
false
;
}
try
{
await
IOUtils
.
makeDirectory
(
this
.
getPath
(
)
{
ignoreExisting
:
true
}
)
;
await
IOUtils
.
write
(
filePath
new
Uint8Array
(
buffer
)
{
tmpPath
:
filePath
+
"
.
tmp
"
}
)
;
}
catch
(
ex
)
{
logConsole
.
error
(
logConsole
.
error
(
"
Unable
to
create
preview
:
"
+
ex
)
)
;
return
false
;
}
this
.
#
recentlyUpdatedPreviews
.
add
(
filePath
)
;
return
true
;
}
async
deleteOrphans
(
)
{
if
(
!
this
.
enabled
)
{
return
false
;
}
let
files
=
await
IOUtils
.
getChildren
(
this
.
getPath
(
)
)
;
let
hashes
=
files
.
map
(
f
=
>
PathUtils
.
filename
(
f
)
)
.
filter
(
n
=
>
/
^
[
a
-
f0
-
9
]
{
32
}
\
.
webp
/
)
.
map
(
n
=
>
n
.
substring
(
0
n
.
lastIndexOf
(
"
.
"
)
)
)
;
await
PlacesUtils
.
withConnectionWrapper
(
"
PlacesPreviews
.
jsm
:
:
deleteOrphans
"
async
db
=
>
{
await
db
.
execute
(
WITH
files
(
hash
)
AS
(
VALUES
{
hashes
.
map
(
h
=
>
(
'
{
h
}
'
)
)
.
join
(
"
"
)
}
)
INSERT
OR
IGNORE
INTO
moz_previews_tombstones
SELECT
hash
FROM
files
EXCEPT
SELECT
md5hex
(
url
)
FROM
moz_places
)
;
}
)
;
this
.
#
deletionHandler
.
ensureRunning
(
)
;
return
true
;
}
onDelete
(
filePath
)
{
this
.
#
recentlyUpdatedPreviews
.
delete
(
filePath
)
;
this
.
emit
(
"
places
-
preview
-
deleted
"
filePath
)
;
}
testSetDeletionTimeout
(
timeout
)
{
if
(
timeout
=
=
=
null
)
{
this
.
#
deletionHandler
.
timeout
=
DELETE_TIMEOUT_MS
;
}
else
{
this
.
#
deletionHandler
.
timeout
=
timeout
;
}
}
}
)
(
)
;
function
PlacesPreviewsHelperService
(
)
{
}
PlacesPreviewsHelperService
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
bd0a4d3b
-
ff26
-
4d4d
-
9a62
-
a513e1c1bf92
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIPlacesPreviewsHelperService
"
]
)
_xpcom_factory
:
ComponentUtils
.
generateSingletonFactory
(
PlacesPreviewsHelperService
)
getFilePathForURL
(
url
)
{
return
PlacesPreviews
.
getPathForUrl
(
url
)
;
}
}
;
