const
FRECENCY_DEFAULT
=
10000
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
{
let
commonFile
=
do_get_file
(
"
.
.
/
head_common
.
js
"
false
)
;
let
uri
=
Services
.
io
.
newFileURI
(
commonFile
)
;
Services
.
scriptloader
.
loadSubScript
(
uri
.
spec
this
)
;
}
{
let
file
=
do_get_file
(
"
autofill_tasks
.
js
"
false
)
;
let
uri
=
Services
.
io
.
newFileURI
(
file
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
addAutofillTasks
"
uri
.
spec
)
;
}
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProviderOpenTabs
:
"
resource
:
/
/
/
modules
/
UrlbarProviderOpenTabs
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
}
)
;
const
TITLE_SEARCH_ENGINE_SEPARATOR
=
"
\
u00B7
\
u2013
\
u00B7
"
;
async
function
cleanup
(
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
autoFill
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
autoFill
.
searchEngines
"
)
;
let
suggestPrefs
=
[
"
history
"
"
bookmark
"
"
openpage
"
"
searches
"
]
;
for
(
let
type
of
suggestPrefs
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
suggest
.
"
+
type
)
;
}
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
registerCleanupFunction
(
cleanup
)
;
function
AutoCompleteInput
(
aSearches
)
{
this
.
searches
=
aSearches
;
}
AutoCompleteInput
.
prototype
=
{
popup
:
{
selectedIndex
:
-
1
invalidate
(
)
{
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAutoCompletePopup
]
)
}
popupOpen
:
false
disableAutoComplete
:
false
completeDefaultIndex
:
true
completeSelectedIndex
:
true
forceComplete
:
false
minResultsForPopup
:
0
maxRows
:
0
timeout
:
10
searchParam
:
"
"
get
searchCount
(
)
{
return
this
.
searches
.
length
;
}
getSearchAt
(
aIndex
)
{
return
this
.
searches
[
aIndex
]
;
}
textValue
:
"
"
_selStart
:
0
_selEnd
:
0
get
selectionStart
(
)
{
return
this
.
_selStart
;
}
get
selectionEnd
(
)
{
return
this
.
_selEnd
;
}
selectTextRange
(
aStart
aEnd
)
{
this
.
_selStart
=
aStart
;
this
.
_selEnd
=
aEnd
;
}
onSearchBegin
(
)
{
}
onSearchComplete
(
)
{
}
onTextEntered
:
(
)
=
>
false
onTextReverted
:
(
)
=
>
false
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAutoCompleteInput
]
)
}
;
async
function
_check_autocomplete_matches
(
match
result
)
{
let
{
uri
tags
style
}
=
match
;
if
(
uri
instanceof
Ci
.
nsIURI
)
{
uri
=
uri
.
spec
;
}
let
title
=
match
.
comment
|
|
match
.
title
;
if
(
tags
)
title
+
=
"
\
u2013
"
+
tags
.
sort
(
)
.
join
(
"
"
)
;
if
(
style
)
style
=
style
.
sort
(
)
;
else
style
=
[
"
favicon
"
]
;
let
actual
=
{
value
:
result
.
value
comment
:
result
.
comment
}
;
let
expected
=
{
value
:
match
.
value
|
|
uri
comment
:
title
}
;
info
(
Checking
match
:
+
actual
=
{
JSON
.
stringify
(
actual
)
}
.
.
.
+
expected
=
{
JSON
.
stringify
(
expected
)
}
)
;
let
actualAction
=
PlacesUtils
.
parseActionUrl
(
actual
.
value
)
;
let
expectedAction
=
PlacesUtils
.
parseActionUrl
(
expected
.
value
)
;
if
(
actualAction
&
&
expectedAction
)
{
if
(
!
ObjectUtils
.
deepEqual
(
actualAction
expectedAction
)
)
{
return
false
;
}
}
else
if
(
actual
.
value
!
=
expected
.
value
)
{
return
false
;
}
if
(
actual
.
comment
!
=
expected
.
comment
)
{
return
false
;
}
let
actualStyle
=
result
.
style
.
split
(
/
\
s
+
/
)
.
sort
(
)
;
if
(
style
)
Assert
.
equal
(
actualStyle
.
toString
(
)
style
.
toString
(
)
"
Match
should
have
expected
style
"
)
;
if
(
uri
&
&
uri
.
startsWith
(
"
moz
-
action
:
"
)
)
{
Assert
.
ok
(
actualStyle
.
includes
(
"
action
"
)
"
moz
-
action
results
should
always
have
'
action
'
in
their
style
"
)
;
}
if
(
match
.
icon
)
{
await
compareFavicons
(
result
.
image
match
.
icon
"
Match
should
have
the
expected
icon
"
)
;
}
return
true
;
}
async
function
check_autocomplete
(
test
)
{
await
PlacesTestUtils
.
promiseAsyncUpdates
(
)
;
let
input
=
test
.
input
|
|
new
AutoCompleteInput
(
[
"
unifiedcomplete
"
]
)
;
input
.
textValue
=
test
.
search
;
if
(
test
.
searchParam
)
input
.
searchParam
=
test
.
searchParam
;
let
strLen
=
test
.
search
.
length
;
input
.
selectTextRange
(
strLen
strLen
)
;
Assert
.
equal
(
input
.
selectionStart
strLen
"
Selection
starts
at
end
"
)
;
Assert
.
equal
(
input
.
selectionEnd
strLen
"
Selection
ends
at
the
end
"
)
;
let
controller
=
Cc
[
"
mozilla
.
org
/
autocomplete
/
controller
;
1
"
]
.
getService
(
Ci
.
nsIAutoCompleteController
)
;
controller
.
input
=
input
;
let
numSearchesStarted
=
0
;
input
.
onSearchBegin
=
(
)
=
>
{
info
(
"
onSearchBegin
received
"
)
;
numSearchesStarted
+
+
;
}
;
let
searchCompletePromise
=
new
Promise
(
resolve
=
>
{
input
.
onSearchComplete
=
(
)
=
>
{
info
(
"
onSearchComplete
received
"
)
;
resolve
(
)
;
}
;
}
)
;
let
expectedSearches
=
1
;
if
(
test
.
incompleteSearch
)
{
controller
.
startSearch
(
test
.
incompleteSearch
)
;
expectedSearches
+
+
;
}
info
(
"
Searching
for
:
'
"
+
test
.
search
+
"
'
"
)
;
controller
.
startSearch
(
test
.
search
)
;
await
searchCompletePromise
;
Assert
.
equal
(
numSearchesStarted
expectedSearches
"
All
searches
started
"
)
;
if
(
test
.
matches
)
{
let
matches
=
test
.
matches
.
slice
(
)
;
if
(
matches
.
length
)
{
let
firstIndexToCheck
=
0
;
if
(
test
.
searchParam
&
&
test
.
searchParam
.
includes
(
"
enable
-
actions
"
)
)
{
firstIndexToCheck
=
1
;
info
(
"
Checking
first
match
is
first
autocomplete
entry
"
)
;
let
result
=
{
value
:
controller
.
getValueAt
(
0
)
comment
:
controller
.
getCommentAt
(
0
)
style
:
controller
.
getStyleAt
(
0
)
image
:
controller
.
getImageAt
(
0
)
}
;
info
(
First
match
is
"
{
result
.
value
}
"
"
{
result
.
comment
}
"
)
;
Assert
.
ok
(
await
_check_autocomplete_matches
(
matches
[
0
]
result
)
"
first
item
is
correct
"
)
;
info
(
"
Checking
rest
of
the
matches
"
)
;
}
for
(
let
i
=
firstIndexToCheck
;
i
<
controller
.
matchCount
;
i
+
+
)
{
let
result
=
{
value
:
controller
.
getValueAt
(
i
)
comment
:
controller
.
getCommentAt
(
i
)
style
:
controller
.
getStyleAt
(
i
)
image
:
controller
.
getImageAt
(
i
)
}
;
info
(
Actual
result
at
index
{
i
}
:
{
JSON
.
stringify
(
result
)
}
)
;
let
lowerBound
=
test
.
checkSorting
?
i
:
firstIndexToCheck
;
let
upperBound
=
test
.
checkSorting
?
i
+
1
:
matches
.
length
;
let
found
=
false
;
for
(
let
j
=
lowerBound
;
j
<
upperBound
;
+
+
j
)
{
if
(
matches
[
j
]
=
=
undefined
)
continue
;
if
(
await
_check_autocomplete_matches
(
matches
[
j
]
result
)
)
{
info
(
"
Got
a
match
at
index
"
+
j
+
"
!
"
)
;
matches
[
j
]
=
undefined
;
found
=
true
;
break
;
}
}
if
(
!
found
)
do_throw
(
Didn
'
t
find
the
current
result
(
"
{
result
.
value
}
"
"
{
result
.
comment
}
"
)
in
matches
)
;
}
}
Assert
.
equal
(
controller
.
matchCount
matches
.
length
"
Got
as
many
results
as
expected
"
)
;
Assert
.
equal
(
controller
.
searchStatus
matches
.
length
?
Ci
.
nsIAutoCompleteController
.
STATUS_COMPLETE_MATCH
:
Ci
.
nsIAutoCompleteController
.
STATUS_COMPLETE_NO_MATCH
)
;
}
if
(
test
.
autofilled
)
{
Assert
.
equal
(
input
.
textValue
test
.
autofilled
"
Autofilled
value
is
correct
"
)
;
controller
.
handleEnter
(
false
)
;
Assert
.
equal
(
input
.
textValue
test
.
completed
"
Completed
value
is
correct
"
)
;
}
return
input
;
}
var
addBookmark
=
async
function
(
aBookmarkObj
)
{
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
title
:
aBookmarkObj
.
title
|
|
"
A
bookmark
"
url
:
aBookmarkObj
.
uri
}
)
;
if
(
aBookmarkObj
.
keyword
)
{
await
PlacesUtils
.
keywords
.
insert
(
{
keyword
:
aBookmarkObj
.
keyword
url
:
aBookmarkObj
.
uri
instanceof
Ci
.
nsIURI
?
aBookmarkObj
.
uri
.
spec
:
aBookmarkObj
.
uri
postData
:
aBookmarkObj
.
postData
}
)
;
}
if
(
aBookmarkObj
.
tags
)
{
let
uri
=
aBookmarkObj
.
uri
instanceof
Ci
.
nsIURI
?
aBookmarkObj
.
uri
:
Services
.
io
.
newURI
(
aBookmarkObj
.
uri
)
;
PlacesUtils
.
tagging
.
tagURI
(
uri
aBookmarkObj
.
tags
)
;
}
}
;
function
addOpenPages
(
aUri
aCount
=
1
aUserContextId
=
0
)
{
for
(
let
i
=
0
;
i
<
aCount
;
i
+
+
)
{
UrlbarProviderOpenTabs
.
registerOpenTab
(
aUri
.
spec
aUserContextId
)
;
}
}
function
removeOpenPages
(
aUri
aCount
=
1
aUserContextId
=
0
)
{
for
(
let
i
=
0
;
i
<
aCount
;
i
+
+
)
{
UrlbarProviderOpenTabs
.
unregisterOpenTab
(
aUri
.
spec
aUserContextId
)
;
}
}
function
stripPrefix
(
spec
)
{
[
"
http
:
/
/
"
"
https
:
/
/
"
"
ftp
:
/
/
"
]
.
some
(
scheme
=
>
{
if
(
spec
.
startsWith
(
scheme
)
)
{
spec
=
spec
.
slice
(
scheme
.
length
)
;
return
true
;
}
return
false
;
}
)
;
if
(
spec
.
startsWith
(
"
www
.
"
)
)
{
spec
=
spec
.
slice
(
4
)
;
}
return
spec
;
}
function
makeActionURI
(
action
params
)
{
let
encodedParams
=
{
}
;
for
(
let
key
in
params
)
{
encodedParams
[
key
]
=
encodeURIComponent
(
params
[
key
]
)
;
}
let
url
=
"
moz
-
action
:
"
+
action
+
"
"
+
JSON
.
stringify
(
encodedParams
)
;
return
NetUtil
.
newURI
(
url
)
;
}
function
makeSearchMatch
(
input
extra
=
{
}
)
{
let
params
=
{
engineName
:
extra
.
engineName
|
|
"
MozSearch
"
input
searchQuery
:
"
searchQuery
"
in
extra
?
extra
.
searchQuery
:
input
}
;
let
style
=
[
"
action
"
"
searchengine
"
]
;
if
(
"
style
"
in
extra
&
&
Array
.
isArray
(
extra
.
style
)
)
{
style
.
push
(
.
.
.
extra
.
style
)
;
}
if
(
extra
.
heuristic
)
{
style
.
push
(
"
heuristic
"
)
;
}
if
(
"
alias
"
in
extra
)
{
params
.
alias
=
extra
.
alias
;
style
.
push
(
"
alias
"
)
;
}
if
(
"
searchSuggestion
"
in
extra
)
{
params
.
searchSuggestion
=
extra
.
searchSuggestion
;
style
.
push
(
"
suggestion
"
)
;
}
return
{
uri
:
makeActionURI
(
"
searchengine
"
params
)
title
:
params
.
engineName
style
}
;
}
function
makeVisitMatch
(
input
url
extra
=
{
}
)
{
let
params
=
{
url
input
}
;
let
style
=
[
"
action
"
"
visiturl
"
]
;
if
(
extra
.
heuristic
)
{
style
.
push
(
"
heuristic
"
)
;
}
return
{
uri
:
makeActionURI
(
"
visiturl
"
params
)
title
:
extra
.
title
|
|
url
style
}
;
}
function
makeSwitchToTabMatch
(
url
extra
=
{
}
)
{
return
{
uri
:
makeActionURI
(
"
switchtab
"
{
url
}
)
title
:
extra
.
title
|
|
url
style
:
[
"
action
"
"
switchtab
"
]
}
;
}
function
makeExtensionMatch
(
extra
=
{
}
)
{
let
style
=
[
"
action
"
"
extension
"
]
;
if
(
extra
.
heuristic
)
{
style
.
push
(
"
heuristic
"
)
;
}
return
{
uri
:
makeActionURI
(
"
extension
"
{
content
:
extra
.
content
keyword
:
extra
.
keyword
}
)
title
:
extra
.
description
style
}
;
}
function
makeTestServer
(
port
=
-
1
)
{
let
httpServer
=
new
HttpServer
(
)
;
httpServer
.
start
(
port
)
;
registerCleanupFunction
(
(
)
=
>
httpServer
.
stop
(
(
)
=
>
{
}
)
)
;
return
httpServer
;
}
function
addTestEngine
(
basename
httpServer
=
undefined
)
{
httpServer
=
httpServer
|
|
makeTestServer
(
)
;
httpServer
.
registerDirectory
(
"
/
"
do_get_cwd
(
)
)
;
let
dataUrl
=
"
http
:
/
/
localhost
:
"
+
httpServer
.
identity
.
primaryPort
+
"
/
data
/
"
;
info
(
"
Adding
engine
:
"
+
basename
)
;
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
obs
(
subject
topic
data
)
{
let
engine
=
subject
.
QueryInterface
(
Ci
.
nsISearchEngine
)
;
info
(
"
Observed
"
+
data
+
"
for
"
+
engine
.
name
)
;
if
(
data
!
=
"
engine
-
added
"
|
|
engine
.
name
!
=
basename
)
{
return
;
}
Services
.
obs
.
removeObserver
(
obs
"
browser
-
search
-
engine
-
modified
"
)
;
registerCleanupFunction
(
(
)
=
>
Services
.
search
.
removeEngine
(
engine
)
)
;
resolve
(
engine
)
;
}
"
browser
-
search
-
engine
-
modified
"
)
;
info
(
"
Adding
engine
from
URL
:
"
+
dataUrl
+
basename
)
;
Services
.
search
.
addEngine
(
dataUrl
+
basename
null
false
)
;
}
)
;
}
async
function
addTestSuggestionsEngine
(
suggestionsFn
=
null
)
{
let
server
=
makeTestServer
(
9000
)
;
server
.
registerPathHandler
(
"
/
suggest
"
(
req
resp
)
=
>
{
let
searchStr
=
decodeURIComponent
(
req
.
queryString
.
replace
(
/
\
+
/
g
"
"
)
)
;
let
suggestions
=
suggestionsFn
?
suggestionsFn
(
searchStr
)
:
[
searchStr
]
.
concat
(
[
"
foo
"
"
bar
"
]
.
map
(
s
=
>
searchStr
+
"
"
+
s
)
)
;
let
data
=
[
searchStr
suggestions
]
;
resp
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
"
false
)
;
resp
.
write
(
JSON
.
stringify
(
data
)
)
;
}
)
;
let
engine
=
await
addTestEngine
(
"
engine
-
suggestions
.
xml
"
server
)
;
return
engine
;
}
add_task
(
async
function
ensure_search_engine
(
)
{
Services
.
prefs
.
setBoolPref
(
"
keyword
.
enabled
"
true
)
;
let
geoPref
=
"
browser
.
search
.
geoip
.
url
"
;
Services
.
prefs
.
setCharPref
(
geoPref
"
"
)
;
registerCleanupFunction
(
(
)
=
>
Services
.
prefs
.
clearUserPref
(
geoPref
)
)
;
await
new
Promise
(
resolve
=
>
{
Services
.
search
.
init
(
resolve
)
;
}
)
;
for
(
let
engine
of
Services
.
search
.
getEngines
(
)
)
{
Services
.
search
.
removeEngine
(
engine
)
;
}
Services
.
search
.
addEngineWithDetails
(
"
MozSearch
"
"
"
"
"
"
"
"
GET
"
"
http
:
/
/
s
.
example
.
com
/
search
"
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
"
MozSearch
"
)
;
Services
.
search
.
currentEngine
=
engine
;
}
)
;
function
addAdaptiveFeedback
(
aUrl
aSearch
)
{
let
promise
=
TestUtils
.
topicObserved
(
"
places
-
autocomplete
-
feedback
-
updated
"
)
;
let
thing
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAutoCompleteInput
Ci
.
nsIAutoCompletePopup
Ci
.
nsIAutoCompleteController
]
)
get
popup
(
)
{
return
thing
;
}
get
controller
(
)
{
return
thing
;
}
popupOpen
:
true
selectedIndex
:
0
getValueAt
:
(
)
=
>
aUrl
searchString
:
aSearch
}
;
Services
.
obs
.
notifyObservers
(
thing
"
autocomplete
-
will
-
enter
-
text
"
)
;
return
promise
;
}
