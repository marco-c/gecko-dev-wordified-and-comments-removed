const
SUGGESTIONS_ENGINE_NAME
=
"
engine
-
suggestions
.
xml
"
;
add_task
(
async
function
basicGetAndPost
(
)
{
await
Services
.
search
.
addEngineWithDetails
(
"
AliasedGETMozSearch
"
{
alias
:
"
get
"
method
:
"
GET
"
template
:
"
http
:
/
/
s
.
example
.
com
/
search
"
}
)
;
await
Services
.
search
.
addEngineWithDetails
(
"
AliasedPOSTMozSearch
"
{
alias
:
"
post
"
method
:
"
POST
"
template
:
"
http
:
/
/
s
.
example
.
com
/
search
"
}
)
;
await
PlacesTestUtils
.
addVisits
(
"
http
:
/
/
s
.
example
.
com
/
search
?
q
=
firefox
"
)
;
let
historyMatch
=
{
value
:
"
http
:
/
/
s
.
example
.
com
/
search
?
q
=
firefox
"
comment
:
"
test
visit
for
http
:
/
/
s
.
example
.
com
/
search
?
q
=
firefox
"
}
;
for
(
let
alias
of
[
"
get
"
"
post
"
]
)
{
await
check_autocomplete
(
{
search
:
alias
searchParam
:
"
enable
-
actions
"
matches
:
[
makeSearchMatch
(
{
alias
}
{
engineName
:
Aliased
{
alias
.
toUpperCase
(
)
}
MozSearch
searchQuery
:
"
"
alias
heuristic
:
true
}
)
historyMatch
]
}
)
;
await
check_autocomplete
(
{
search
:
{
alias
}
searchParam
:
"
enable
-
actions
"
matches
:
[
makeSearchMatch
(
{
alias
}
{
engineName
:
Aliased
{
alias
.
toUpperCase
(
)
}
MozSearch
searchQuery
:
"
"
alias
heuristic
:
true
}
)
historyMatch
]
}
)
;
await
check_autocomplete
(
{
search
:
{
alias
}
fire
searchParam
:
"
enable
-
actions
"
matches
:
[
makeSearchMatch
(
{
alias
}
fire
{
engineName
:
Aliased
{
alias
.
toUpperCase
(
)
}
MozSearch
searchQuery
:
"
fire
"
alias
heuristic
:
true
}
)
historyMatch
]
}
)
;
await
check_autocomplete
(
{
search
:
{
alias
}
mozilla
searchParam
:
"
enable
-
actions
"
matches
:
[
makeSearchMatch
(
{
alias
}
mozilla
{
engineName
:
Aliased
{
alias
.
toUpperCase
(
)
}
MozSearch
searchQuery
:
"
mozilla
"
alias
heuristic
:
true
}
)
]
}
)
;
await
check_autocomplete
(
{
search
:
{
alias
}
MoZiLlA
searchParam
:
"
enable
-
actions
"
matches
:
[
makeSearchMatch
(
{
alias
}
MoZiLlA
{
engineName
:
Aliased
{
alias
.
toUpperCase
(
)
}
MozSearch
searchQuery
:
"
MoZiLlA
"
alias
heuristic
:
true
}
)
]
}
)
;
await
check_autocomplete
(
{
search
:
{
alias
}
mozzarella
mozilla
searchParam
:
"
enable
-
actions
"
matches
:
[
makeSearchMatch
(
{
alias
}
mozzarella
mozilla
{
engineName
:
Aliased
{
alias
.
toUpperCase
(
)
}
MozSearch
searchQuery
:
"
mozzarella
mozilla
"
alias
heuristic
:
true
}
)
]
}
)
;
for
(
let
token
of
Object
.
values
(
UrlbarTokenizer
.
RESTRICT
)
)
{
let
search
=
{
token
}
{
alias
}
query
string
;
let
searchQuery
=
token
=
=
UrlbarTokenizer
.
RESTRICT
.
SEARCH
&
&
search
.
startsWith
(
UrlbarTokenizer
.
RESTRICT
.
SEARCH
)
?
search
.
substring
(
2
)
:
search
;
await
check_autocomplete
(
{
search
searchParam
:
"
enable
-
actions
"
matches
:
[
makeSearchMatch
(
search
{
engineName
:
"
MozSearch
"
searchQuery
heuristic
:
true
}
)
]
}
)
;
}
}
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
engineWithSuggestions
(
)
{
let
engine
=
await
addTestSuggestionsEngine
(
)
;
let
historyTitle
=
"
fire
"
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
engine
.
searchForm
title
:
historyTitle
}
)
;
let
historyMatch
=
{
value
:
"
http
:
/
/
localhost
:
9000
/
search
"
comment
:
historyTitle
}
;
for
(
let
private
of
[
false
true
]
)
{
let
searchParam
=
"
enable
-
actions
"
;
if
(
private
)
{
searchParam
+
=
"
private
-
window
"
;
}
for
(
let
alias
of
[
"
moz
"
"
moz
"
]
)
{
engine
.
alias
=
alias
;
Assert
.
equal
(
engine
.
alias
alias
)
;
let
expectedMatches
=
[
makeSearchMatch
(
{
alias
}
{
engineName
:
SUGGESTIONS_ENGINE_NAME
alias
searchQuery
:
"
"
heuristic
:
true
}
)
]
;
if
(
alias
[
0
]
!
=
"
"
)
{
expectedMatches
.
push
(
historyMatch
)
;
}
await
check_autocomplete
(
{
search
:
alias
searchParam
matches
:
expectedMatches
}
)
;
expectedMatches
=
[
makeSearchMatch
(
{
alias
}
{
engineName
:
SUGGESTIONS_ENGINE_NAME
alias
searchQuery
:
"
"
heuristic
:
true
}
)
]
;
if
(
alias
[
0
]
!
=
"
"
)
{
expectedMatches
.
push
(
historyMatch
)
;
}
await
check_autocomplete
(
{
search
:
{
alias
}
searchParam
matches
:
expectedMatches
}
)
;
expectedMatches
=
[
makeSearchMatch
(
{
alias
}
{
historyTitle
}
{
engineName
:
SUGGESTIONS_ENGINE_NAME
alias
searchQuery
:
historyTitle
heuristic
:
true
}
)
]
;
if
(
!
private
)
{
expectedMatches
.
push
(
makeSearchMatch
(
{
alias
}
{
historyTitle
}
foo
{
engineName
:
SUGGESTIONS_ENGINE_NAME
alias
searchQuery
:
historyTitle
searchSuggestion
:
{
historyTitle
}
foo
}
)
makeSearchMatch
(
{
alias
}
{
historyTitle
}
bar
{
engineName
:
SUGGESTIONS_ENGINE_NAME
alias
searchQuery
:
historyTitle
searchSuggestion
:
{
historyTitle
}
bar
}
)
)
;
}
if
(
alias
[
0
]
!
=
"
"
)
{
expectedMatches
.
push
(
historyMatch
)
;
}
await
check_autocomplete
(
{
search
:
{
alias
}
{
historyTitle
}
searchParam
matches
:
expectedMatches
}
)
;
}
}
engine
.
alias
=
"
"
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
tokenAliasEngines
(
)
{
await
Services
.
search
.
init
(
)
;
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
region
"
"
US
"
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
geoSpecificDefaults
"
false
)
;
Services
.
search
.
restoreDefaultEngines
(
)
;
Services
.
search
.
resetToOriginalDefaultEngine
(
)
;
let
tokenEngines
=
[
]
;
for
(
let
engine
of
await
Services
.
search
.
getEngines
(
)
)
{
let
aliases
=
[
]
;
if
(
engine
.
alias
)
{
aliases
.
push
(
engine
.
alias
)
;
}
aliases
.
push
(
.
.
.
engine
.
wrappedJSObject
.
_internalAliases
)
;
let
tokenAliases
=
aliases
.
filter
(
a
=
>
a
.
startsWith
(
"
"
)
)
;
if
(
tokenAliases
.
length
)
{
tokenEngines
.
push
(
{
engine
tokenAliases
}
)
;
}
}
if
(
!
tokenEngines
.
length
)
{
Assert
.
ok
(
true
"
No
token
alias
engines
skipping
task
.
"
)
;
return
;
}
info
(
"
Got
token
alias
engines
:
"
+
tokenEngines
.
map
(
(
{
engine
}
)
=
>
engine
.
name
)
)
;
await
check_autocomplete
(
{
search
:
"
"
searchParam
:
"
enable
-
actions
"
matches
:
tokenEngines
.
map
(
(
{
engine
tokenAliases
}
)
=
>
{
let
alias
=
tokenAliases
[
0
]
;
return
makeSearchMatch
(
alias
+
"
"
{
engineName
:
engine
.
name
alias
searchQuery
:
"
"
}
)
;
}
)
}
)
;
await
cleanup
(
)
;
}
)
;
