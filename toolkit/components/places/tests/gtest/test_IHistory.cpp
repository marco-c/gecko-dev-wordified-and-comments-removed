#
include
"
places_test_harness
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mock_Link
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
void
expect_visit
(
nsLinkState
aState
)
{
do_check_true
(
aState
=
=
eLinkState_Visited
)
;
}
void
expect_no_visit
(
nsLinkState
aState
)
{
do_check_true
(
aState
=
=
eLinkState_Unvisited
)
;
}
already_AddRefed
<
nsIURI
>
new_test_uri
(
)
{
static
int32_t
specNumber
=
0
;
nsCString
spec
=
NS_LITERAL_CSTRING
(
"
http
:
/
/
mozilla
.
org
/
"
)
;
spec
.
AppendInt
(
specNumber
+
+
)
;
nsCOMPtr
<
nsIURI
>
testURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
testURI
)
spec
)
;
do_check_success
(
rv
)
;
return
testURI
.
forget
(
)
;
}
class
VisitURIObserver
final
:
public
nsIObserver
{
~
VisitURIObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
explicit
VisitURIObserver
(
int
aExpectedVisits
=
1
)
:
mVisits
(
0
)
mExpectedVisits
(
aExpectedVisits
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
do_GetService
(
NS_OBSERVERSERVICE_CONTRACTID
)
;
do_check_true
(
observerService
)
;
(
void
)
observerService
-
>
AddObserver
(
this
"
uri
-
visit
-
saved
"
false
)
;
}
void
WaitForNotification
(
)
{
SpinEventLoopUntil
(
[
&
]
(
)
{
return
mVisits
>
=
mExpectedVisits
;
}
)
;
}
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
mVisits
+
+
;
if
(
mVisits
=
=
mExpectedVisits
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
do_GetService
(
NS_OBSERVERSERVICE_CONTRACTID
)
;
(
void
)
observerService
-
>
RemoveObserver
(
this
"
uri
-
visit
-
saved
"
)
;
}
return
NS_OK
;
}
private
:
int
mVisits
;
int
mExpectedVisits
;
}
;
NS_IMPL_ISUPPORTS
(
VisitURIObserver
nsIObserver
)
void
test_set_places_enabled
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
&
rv
)
;
do_check_success
(
rv
)
;
rv
=
prefBranch
-
>
SetBoolPref
(
"
places
.
history
.
enabled
"
true
)
;
do_check_success
(
rv
)
;
run_next_test
(
)
;
}
void
test_wait_checkpoint
(
)
{
nsCOMPtr
<
mozIStorageConnection
>
db
=
do_get_db
(
)
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
stmt
;
db
-
>
CreateAsyncStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
1
"
)
getter_AddRefs
(
stmt
)
)
;
RefPtr
<
PlacesAsyncStatementSpinner
>
spinner
=
new
PlacesAsyncStatementSpinner
(
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
pending
;
(
void
)
stmt
-
>
ExecuteAsync
(
spinner
getter_AddRefs
(
pending
)
)
;
spinner
-
>
SpinUntilCompleted
(
)
;
run_next_test
(
)
;
}
namespace
test_unvisited_does_not_notify
{
nsCOMPtr
<
nsIURI
>
testURI
;
RefPtr
<
mock_Link
>
testLink
;
}
void
test_unvisited_does_not_notify_part1
(
)
{
using
namespace
test_unvisited_does_not_notify
;
testURI
=
new_test_uri
(
)
;
testLink
=
new
mock_Link
(
expect_no_visit
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsresult
rv
=
history
-
>
RegisterVisitedCallback
(
testURI
testLink
)
;
do_check_success
(
rv
)
;
run_next_test
(
)
;
}
void
test_visited_notifies
(
)
{
nsCOMPtr
<
nsIURI
>
testURI
=
new_test_uri
(
)
;
addURI
(
testURI
)
;
RefPtr
<
Link
>
link
=
new
mock_Link
(
expect_visit
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsresult
rv
=
history
-
>
RegisterVisitedCallback
(
testURI
link
)
;
do_check_success
(
rv
)
;
}
void
test_unvisited_does_not_notify_part2
(
)
{
using
namespace
test_unvisited_does_not_notify
;
if
(
StaticPrefs
:
:
layout_css_notify_of_unvisited
(
)
)
{
SpinEventLoopUntil
(
[
&
]
(
)
{
return
testLink
-
>
GotNotified
(
)
;
}
)
;
}
testLink
-
>
AwaitNewNotification
(
expect_visit
)
;
addURI
(
testURI
)
;
testURI
=
nullptr
;
testLink
=
nullptr
;
}
void
test_same_uri_notifies_both
(
)
{
nsCOMPtr
<
nsIURI
>
testURI
=
new_test_uri
(
)
;
addURI
(
testURI
)
;
RefPtr
<
Link
>
link1
=
new
mock_Link
(
expect_visit
false
)
;
RefPtr
<
Link
>
link2
=
new
mock_Link
(
expect_visit
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsresult
rv
=
history
-
>
RegisterVisitedCallback
(
testURI
link1
)
;
do_check_success
(
rv
)
;
rv
=
history
-
>
RegisterVisitedCallback
(
testURI
link2
)
;
do_check_success
(
rv
)
;
}
void
test_unregistered_visited_does_not_notify
(
)
{
nsCOMPtr
<
nsIURI
>
testURI
=
new_test_uri
(
)
;
RefPtr
<
Link
>
link
=
new
mock_Link
(
expect_no_visit
false
)
;
nsCOMPtr
<
IHistory
>
history
(
do_get_IHistory
(
)
)
;
nsresult
rv
=
history
-
>
RegisterVisitedCallback
(
testURI
link
)
;
do_check_success
(
rv
)
;
history
-
>
UnregisterVisitedCallback
(
testURI
link
)
;
addURI
(
testURI
)
;
run_next_test
(
)
;
}
void
test_new_visit_notifies_waiting_Link
(
)
{
RefPtr
<
mock_Link
>
link
=
new
mock_Link
(
expect_no_visit
)
;
nsCOMPtr
<
nsIURI
>
testURI
=
new_test_uri
(
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsresult
rv
=
history
-
>
RegisterVisitedCallback
(
testURI
link
)
;
do_check_success
(
rv
)
;
if
(
StaticPrefs
:
:
layout_css_notify_of_unvisited
(
)
)
{
SpinEventLoopUntil
(
[
&
]
(
)
{
return
link
-
>
GotNotified
(
)
;
}
)
;
}
link
-
>
AwaitNewNotification
(
expect_visit
)
;
addURI
(
testURI
)
;
}
void
test_RegisterVisitedCallback_returns_before_notifying
(
)
{
nsCOMPtr
<
nsIURI
>
testURI
=
new_test_uri
(
)
;
addURI
(
testURI
)
;
RefPtr
<
Link
>
link
=
new
mock_Link
(
expect_no_visit
false
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsresult
rv
=
history
-
>
RegisterVisitedCallback
(
testURI
link
)
;
do_check_success
(
rv
)
;
history
-
>
UnregisterVisitedCallback
(
testURI
link
)
;
run_next_test
(
)
;
}
namespace
test_observer_topic_dispatched_helpers
{
#
define
URI_VISITED
"
visited
"
#
define
URI_NOT_VISITED
"
not
visited
"
#
define
URI_VISITED_RESOLUTION_TOPIC
"
visited
-
status
-
resolution
"
class
statusObserver
final
:
public
nsIObserver
{
~
statusObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
statusObserver
(
nsIURI
*
aURI
const
bool
aExpectVisit
bool
&
_notified
)
:
mURI
(
aURI
)
mExpectVisit
(
aExpectVisit
)
mNotified
(
_notified
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
do_GetService
(
NS_OBSERVERSERVICE_CONTRACTID
)
;
do_check_true
(
observerService
)
;
(
void
)
observerService
-
>
AddObserver
(
this
URI_VISITED_RESOLUTION_TOPIC
false
)
;
}
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
do_check_false
(
strcmp
(
aTopic
URI_VISITED_RESOLUTION_TOPIC
)
)
;
nsCOMPtr
<
nsIURI
>
notifiedURI
=
do_QueryInterface
(
aSubject
)
;
do_check_true
(
notifiedURI
)
;
bool
isOurURI
;
nsresult
rv
=
notifiedURI
-
>
Equals
(
mURI
&
isOurURI
)
;
do_check_success
(
rv
)
;
if
(
!
isOurURI
)
{
return
NS_OK
;
}
bool
visited
=
!
!
NS_LITERAL_STRING
(
URI_VISITED
)
.
Equals
(
aData
)
;
bool
notVisited
=
!
!
NS_LITERAL_STRING
(
URI_NOT_VISITED
)
.
Equals
(
aData
)
;
do_check_true
(
visited
|
|
notVisited
)
;
do_check_eq
(
visited
mExpectVisit
)
;
mNotified
=
true
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
do_GetService
(
NS_OBSERVERSERVICE_CONTRACTID
)
;
(
void
)
observerService
-
>
RemoveObserver
(
this
URI_VISITED_RESOLUTION_TOPIC
)
;
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIURI
>
mURI
;
const
bool
mExpectVisit
;
bool
&
mNotified
;
}
;
NS_IMPL_ISUPPORTS
(
statusObserver
nsIObserver
)
}
void
test_observer_topic_dispatched
(
)
{
using
namespace
test_observer_topic_dispatched_helpers
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsIURI
>
notVisitedURI
=
new_test_uri
(
)
;
bool
urisEqual
;
nsresult
rv
=
visitedURI
-
>
Equals
(
notVisitedURI
&
urisEqual
)
;
do_check_success
(
rv
)
;
do_check_false
(
urisEqual
)
;
addURI
(
visitedURI
)
;
RefPtr
<
Link
>
visitedLink
=
new
mock_Link
(
expect_visit
false
)
;
RefPtr
<
Link
>
notVisitedLink
=
new
mock_Link
(
expect_no_visit
false
)
;
RefPtr
<
Link
>
visitedLinkCopy
=
visitedLink
;
bool
visitedNotified
=
false
;
nsCOMPtr
<
nsIObserver
>
visitedObs
=
new
statusObserver
(
visitedURI
true
visitedNotified
)
;
bool
notVisitedNotified
=
false
;
nsCOMPtr
<
nsIObserver
>
unvisitedObs
=
new
statusObserver
(
notVisitedURI
false
notVisitedNotified
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
rv
=
history
-
>
RegisterVisitedCallback
(
visitedURI
visitedLink
)
;
do_check_success
(
rv
)
;
rv
=
history
-
>
RegisterVisitedCallback
(
notVisitedURI
notVisitedLink
)
;
do_check_success
(
rv
)
;
SpinEventLoopUntil
(
[
&
]
(
)
{
return
visitedNotified
&
&
notVisitedNotified
;
}
)
;
history
-
>
UnregisterVisitedCallback
(
notVisitedURI
notVisitedLink
)
;
run_next_test
(
)
;
}
void
test_visituri_inserts
(
)
{
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsCOMPtr
<
nsIURI
>
lastURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
mozilla
:
:
IHistory
:
:
TOP_LEVEL
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
do_get_place
(
visitedURI
place
)
;
do_check_true
(
place
.
id
>
0
)
;
do_check_false
(
place
.
hidden
)
;
do_check_false
(
place
.
typed
)
;
do_check_eq
(
place
.
visitCount
1
)
;
run_next_test
(
)
;
}
void
test_visituri_updates
(
)
{
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsCOMPtr
<
nsIURI
>
lastURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
RefPtr
<
VisitURIObserver
>
finisher
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
mozilla
:
:
IHistory
:
:
TOP_LEVEL
)
;
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
mozilla
:
:
IHistory
:
:
TOP_LEVEL
)
;
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
do_get_place
(
visitedURI
place
)
;
do_check_eq
(
place
.
visitCount
2
)
;
run_next_test
(
)
;
}
void
test_visituri_preserves_shown_and_typed
(
)
{
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsCOMPtr
<
nsIURI
>
lastURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
mozilla
:
:
IHistory
:
:
TOP_LEVEL
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
0
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
2
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
do_get_place
(
visitedURI
place
)
;
do_check_false
(
place
.
hidden
)
;
run_next_test
(
)
;
}
void
test_visituri_creates_visit
(
)
{
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsCOMPtr
<
nsIURI
>
lastURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
mozilla
:
:
IHistory
:
:
TOP_LEVEL
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
VisitRecord
visit
;
do_get_place
(
visitedURI
place
)
;
do_get_lastVisit
(
place
.
id
visit
)
;
do_check_true
(
visit
.
id
>
0
)
;
do_check_eq
(
visit
.
lastVisitId
0
)
;
do_check_eq
(
visit
.
transitionType
nsINavHistoryService
:
:
TRANSITION_LINK
)
;
run_next_test
(
)
;
}
void
test_visituri_transition_typed
(
)
{
nsCOMPtr
<
nsINavHistoryService
>
navHistory
=
do_get_NavHistory
(
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsCOMPtr
<
nsIURI
>
lastURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
navHistory
-
>
MarkPageAsTyped
(
visitedURI
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
mozilla
:
:
IHistory
:
:
TOP_LEVEL
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
VisitRecord
visit
;
do_get_place
(
visitedURI
place
)
;
do_get_lastVisit
(
place
.
id
visit
)
;
do_check_true
(
visit
.
transitionType
=
=
nsINavHistoryService
:
:
TRANSITION_TYPED
)
;
run_next_test
(
)
;
}
void
test_visituri_transition_embed
(
)
{
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsCOMPtr
<
nsIURI
>
lastURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
0
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
VisitRecord
visit
;
do_get_place
(
visitedURI
place
)
;
do_get_lastVisit
(
place
.
id
visit
)
;
do_check_eq
(
place
.
id
0
)
;
do_check_eq
(
visit
.
id
0
)
;
run_next_test
(
)
;
}
void
test_new_visit_adds_place_guid
(
)
{
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsresult
rv
=
history
-
>
VisitURI
(
nullptr
visitedURI
nullptr
mozilla
:
:
IHistory
:
:
TOP_LEVEL
)
;
do_check_success
(
rv
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
do_get_place
(
visitedURI
place
)
;
do_check_eq
(
place
.
visitCount
1
)
;
do_check_eq
(
place
.
guid
.
Length
(
)
12u
)
;
run_next_test
(
)
;
}
void
test_two_null_links_same_uri
(
)
{
nsCOMPtr
<
nsIURI
>
testURI
=
new_test_uri
(
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsresult
rv
=
history
-
>
RegisterVisitedCallback
(
testURI
nullptr
)
;
do_check_success
(
rv
)
;
rv
=
history
-
>
RegisterVisitedCallback
(
testURI
nullptr
)
;
do_check_success
(
rv
)
;
rv
=
history
-
>
VisitURI
(
nullptr
testURI
nullptr
mozilla
:
:
IHistory
:
:
TOP_LEVEL
)
;
do_check_success
(
rv
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
run_next_test
(
)
;
}
Test
gTests
[
]
=
{
PTEST
(
test_set_places_enabled
)
PTEST
(
test_wait_checkpoint
)
PTEST
(
test_unvisited_does_not_notify_part1
)
PTEST
(
test_visited_notifies
)
PTEST
(
test_unvisited_does_not_notify_part2
)
PTEST
(
test_same_uri_notifies_both
)
PTEST
(
test_unregistered_visited_does_not_notify
)
PTEST
(
test_new_visit_notifies_waiting_Link
)
PTEST
(
test_RegisterVisitedCallback_returns_before_notifying
)
PTEST
(
test_observer_topic_dispatched
)
PTEST
(
test_visituri_inserts
)
PTEST
(
test_visituri_updates
)
PTEST
(
test_visituri_preserves_shown_and_typed
)
PTEST
(
test_visituri_creates_visit
)
PTEST
(
test_visituri_transition_typed
)
PTEST
(
test_visituri_transition_embed
)
PTEST
(
test_new_visit_adds_place_guid
)
PTEST
(
test_two_null_links_same_uri
)
}
;
#
define
TEST_NAME
"
IHistory
"
#
include
"
places_test_harness_tail
.
h
"
