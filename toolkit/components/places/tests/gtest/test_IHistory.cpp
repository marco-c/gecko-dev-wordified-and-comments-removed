#
include
"
places_test_harness
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mock_Link
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
void
expect_visit
(
Link
:
:
State
aState
)
{
do_check_true
(
aState
=
=
Link
:
:
State
:
:
Visited
)
;
}
void
expect_no_visit
(
Link
:
:
State
aState
)
{
do_check_true
(
aState
=
=
Link
:
:
State
:
:
Unvisited
)
;
}
already_AddRefed
<
nsIURI
>
new_test_uri
(
)
{
static
int32_t
specNumber
=
0
;
nsCString
spec
=
"
http
:
/
/
mozilla
.
org
/
"
_ns
;
spec
.
AppendInt
(
specNumber
+
+
)
;
nsCOMPtr
<
nsIURI
>
testURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
testURI
)
spec
)
;
do_check_success
(
rv
)
;
return
testURI
.
forget
(
)
;
}
class
VisitURIObserver
final
:
public
nsIObserver
{
~
VisitURIObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
explicit
VisitURIObserver
(
int
aExpectedVisits
=
1
)
:
mVisits
(
0
)
mExpectedVisits
(
aExpectedVisits
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
do_GetService
(
NS_OBSERVERSERVICE_CONTRACTID
)
;
do_check_true
(
observerService
)
;
(
void
)
observerService
-
>
AddObserver
(
this
"
uri
-
visit
-
saved
"
false
)
;
}
void
WaitForNotification
(
)
{
SpinEventLoopUntil
(
"
places
:
VisitURIObserver
:
:
WaitForNotification
"
_ns
[
&
]
(
)
{
return
mVisits
>
=
mExpectedVisits
;
}
)
;
}
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
mVisits
+
+
;
if
(
mVisits
=
=
mExpectedVisits
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
do_GetService
(
NS_OBSERVERSERVICE_CONTRACTID
)
;
(
void
)
observerService
-
>
RemoveObserver
(
this
"
uri
-
visit
-
saved
"
)
;
}
return
NS_OK
;
}
private
:
int
mVisits
;
int
mExpectedVisits
;
}
;
NS_IMPL_ISUPPORTS
(
VisitURIObserver
nsIObserver
)
void
test_set_places_enabled
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
&
rv
)
;
do_check_success
(
rv
)
;
rv
=
prefBranch
-
>
SetBoolPref
(
"
places
.
history
.
enabled
"
true
)
;
do_check_success
(
rv
)
;
run_next_test
(
)
;
}
void
test_wait_checkpoint
(
)
{
nsCOMPtr
<
mozIStorageConnection
>
db
=
do_get_db
(
)
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
stmt
;
db
-
>
CreateAsyncStatement
(
"
SELECT
1
"
_ns
getter_AddRefs
(
stmt
)
)
;
RefPtr
<
PlacesAsyncStatementSpinner
>
spinner
=
new
PlacesAsyncStatementSpinner
(
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
pending
;
(
void
)
stmt
-
>
ExecuteAsync
(
spinner
getter_AddRefs
(
pending
)
)
;
spinner
-
>
SpinUntilCompleted
(
)
;
run_next_test
(
)
;
}
namespace
test_unvisited_does_not_notify
{
constinit
nsCOMPtr
<
nsIURI
>
testURI
;
constinit
RefPtr
<
mock_Link
>
testLink
;
}
void
test_unvisited_does_not_notify_part1
(
)
{
using
namespace
test_unvisited_does_not_notify
;
testURI
=
new_test_uri
(
)
;
testLink
=
new
mock_Link
(
expect_no_visit
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
history
-
>
RegisterVisitedCallback
(
testURI
testLink
)
;
run_next_test
(
)
;
}
void
test_visited_notifies
(
)
{
nsCOMPtr
<
nsIURI
>
testURI
=
new_test_uri
(
)
;
addURI
(
testURI
)
;
RefPtr
<
Link
>
link
=
new
mock_Link
(
expect_visit
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
history
-
>
RegisterVisitedCallback
(
testURI
link
)
;
}
void
test_unvisited_does_not_notify_part2
(
)
{
using
namespace
test_unvisited_does_not_notify
;
SpinEventLoopUntil
(
"
places
:
test_unvisited_does_not_notify_part2
"
_ns
[
&
]
(
)
{
return
testLink
-
>
GotNotified
(
)
;
}
)
;
testLink
-
>
AwaitNewNotification
(
expect_visit
)
;
addURI
(
testURI
)
;
testURI
=
nullptr
;
testLink
=
nullptr
;
}
void
test_same_uri_notifies_both
(
)
{
nsCOMPtr
<
nsIURI
>
testURI
=
new_test_uri
(
)
;
addURI
(
testURI
)
;
RefPtr
<
Link
>
link1
=
new
mock_Link
(
expect_visit
false
)
;
RefPtr
<
Link
>
link2
=
new
mock_Link
(
expect_visit
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
history
-
>
RegisterVisitedCallback
(
testURI
link1
)
;
history
-
>
RegisterVisitedCallback
(
testURI
link2
)
;
}
void
test_unregistered_visited_does_not_notify
(
)
{
nsCOMPtr
<
nsIURI
>
testURI
=
new_test_uri
(
)
;
RefPtr
<
Link
>
link
=
new
mock_Link
(
expect_no_visit
false
)
;
nsCOMPtr
<
IHistory
>
history
(
do_get_IHistory
(
)
)
;
history
-
>
RegisterVisitedCallback
(
testURI
link
)
;
history
-
>
UnregisterVisitedCallback
(
testURI
link
)
;
addURI
(
testURI
)
;
run_next_test
(
)
;
}
void
test_new_visit_notifies_waiting_Link
(
)
{
RefPtr
<
mock_Link
>
link
=
new
mock_Link
(
expect_no_visit
)
;
nsCOMPtr
<
nsIURI
>
testURI
=
new_test_uri
(
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
history
-
>
RegisterVisitedCallback
(
testURI
link
)
;
SpinEventLoopUntil
(
"
places
:
test_new_visit_notifies_waiting_Link
"
_ns
[
&
]
(
)
{
return
link
-
>
GotNotified
(
)
;
}
)
;
link
-
>
AwaitNewNotification
(
expect_visit
)
;
addURI
(
testURI
)
;
}
void
test_RegisterVisitedCallback_returns_before_notifying
(
)
{
nsCOMPtr
<
nsIURI
>
testURI
=
new_test_uri
(
)
;
addURI
(
testURI
)
;
RefPtr
<
Link
>
link
=
new
mock_Link
(
expect_no_visit
false
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
history
-
>
RegisterVisitedCallback
(
testURI
link
)
;
history
-
>
UnregisterVisitedCallback
(
testURI
link
)
;
run_next_test
(
)
;
}
void
test_visituri_inserts
(
)
{
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsCOMPtr
<
nsIURI
>
lastURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
mozilla
:
:
IHistory
:
:
TOP_LEVEL
0
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
do_get_place
(
visitedURI
place
)
;
do_check_true
(
place
.
id
>
0
)
;
do_check_false
(
place
.
hidden
)
;
do_check_false
(
place
.
typed
)
;
do_check_eq
(
place
.
visitCount
1
)
;
run_next_test
(
)
;
}
void
test_visituri_updates
(
)
{
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsCOMPtr
<
nsIURI
>
lastURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
RefPtr
<
VisitURIObserver
>
finisher
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
mozilla
:
:
IHistory
:
:
TOP_LEVEL
0
)
;
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
mozilla
:
:
IHistory
:
:
TOP_LEVEL
0
)
;
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
do_get_place
(
visitedURI
place
)
;
do_check_eq
(
place
.
visitCount
2
)
;
run_next_test
(
)
;
}
void
test_visituri_preserves_shown_and_typed
(
)
{
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsCOMPtr
<
nsIURI
>
lastURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
mozilla
:
:
IHistory
:
:
TOP_LEVEL
0
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
0
0
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
2
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
do_get_place
(
visitedURI
place
)
;
do_check_false
(
place
.
hidden
)
;
run_next_test
(
)
;
}
void
test_visituri_creates_visit
(
)
{
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsCOMPtr
<
nsIURI
>
lastURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
mozilla
:
:
IHistory
:
:
TOP_LEVEL
0
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
VisitRecord
visit
;
do_get_place
(
visitedURI
place
)
;
do_get_lastVisit
(
place
.
id
visit
)
;
do_check_true
(
visit
.
id
>
0
)
;
do_check_eq
(
visit
.
lastVisitId
0
)
;
do_check_eq
(
visit
.
transitionType
nsINavHistoryService
:
:
TRANSITION_LINK
)
;
run_next_test
(
)
;
}
void
test_visituri_frecency
(
)
{
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
RefPtr
<
WaitForNotificationSpinner
>
spinner
=
new
WaitForNotificationSpinner
(
PlacesEventType
:
:
Pages_rank_changed
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
nullptr
mozilla
:
:
IHistory
:
:
TOP_LEVEL
0
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
spinner
-
>
SpinUntilCompleted
(
)
;
PlaceRecord
place
;
do_get_place
(
visitedURI
place
)
;
do_check_true
(
place
.
frecency
>
0
)
;
run_next_test
(
)
;
}
void
test_visituri_hidden
(
)
{
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
{
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsINavHistoryService
>
navHistory
=
do_get_NavHistory
(
)
;
navHistory
-
>
MarkPageAsFollowedLink
(
visitedURI
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
nullptr
0
0
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
do_get_place
(
visitedURI
place
)
;
do_check_true
(
place
.
hidden
)
;
}
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
nullptr
mozilla
:
:
IHistory
:
:
TOP_LEVEL
|
IHistory
:
:
REDIRECT_SOURCE
0
)
;
{
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
do_get_place
(
visitedURI
place
)
;
do_check_true
(
place
.
hidden
)
;
}
history
-
>
VisitURI
(
nullptr
visitedURI
nullptr
mozilla
:
:
IHistory
:
:
TOP_LEVEL
0
)
;
{
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
do_get_place
(
visitedURI
place
)
;
do_check_false
(
place
.
hidden
)
;
}
history
-
>
VisitURI
(
nullptr
visitedURI
nullptr
mozilla
:
:
IHistory
:
:
TOP_LEVEL
|
IHistory
:
:
REDIRECT_SOURCE
0
)
;
{
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
do_get_place
(
visitedURI
place
)
;
do_check_false
(
place
.
hidden
)
;
}
run_next_test
(
)
;
}
void
test_visituri_transition_typed
(
)
{
nsCOMPtr
<
nsINavHistoryService
>
navHistory
=
do_get_NavHistory
(
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsCOMPtr
<
nsIURI
>
lastURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
navHistory
-
>
MarkPageAsTyped
(
visitedURI
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
mozilla
:
:
IHistory
:
:
TOP_LEVEL
0
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
VisitRecord
visit
;
do_get_place
(
visitedURI
place
)
;
do_get_lastVisit
(
place
.
id
visit
)
;
do_check_true
(
visit
.
transitionType
=
=
nsINavHistoryService
:
:
TRANSITION_TYPED
)
;
run_next_test
(
)
;
}
void
test_visituri_transition_embed
(
)
{
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsCOMPtr
<
nsIURI
>
lastURI
=
new_test_uri
(
)
;
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
history
-
>
VisitURI
(
nullptr
visitedURI
lastURI
0
0
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
VisitRecord
visit
;
do_get_place
(
visitedURI
place
)
;
do_get_lastVisit
(
place
.
id
visit
)
;
do_check_eq
(
place
.
id
0
)
;
do_check_eq
(
visit
.
id
0
)
;
run_next_test
(
)
;
}
void
test_new_visit_adds_place_guid
(
)
{
nsCOMPtr
<
nsIURI
>
visitedURI
=
new_test_uri
(
)
;
nsCOMPtr
<
IHistory
>
history
=
do_get_IHistory
(
)
;
nsresult
rv
=
history
-
>
VisitURI
(
nullptr
visitedURI
nullptr
mozilla
:
:
IHistory
:
:
TOP_LEVEL
0
)
;
do_check_success
(
rv
)
;
RefPtr
<
VisitURIObserver
>
finisher
=
new
VisitURIObserver
(
)
;
finisher
-
>
WaitForNotification
(
)
;
PlaceRecord
place
;
do_get_place
(
visitedURI
place
)
;
do_check_eq
(
place
.
visitCount
1
)
;
do_check_eq
(
place
.
guid
.
Length
(
)
12u
)
;
run_next_test
(
)
;
}
Test
gTests
[
]
=
{
PTEST
(
test_set_places_enabled
)
PTEST
(
test_wait_checkpoint
)
PTEST
(
test_unvisited_does_not_notify_part1
)
PTEST
(
test_visited_notifies
)
PTEST
(
test_unvisited_does_not_notify_part2
)
PTEST
(
test_same_uri_notifies_both
)
PTEST
(
test_unregistered_visited_does_not_notify
)
PTEST
(
test_new_visit_adds_place_guid
)
PTEST
(
test_new_visit_notifies_waiting_Link
)
PTEST
(
test_RegisterVisitedCallback_returns_before_notifying
)
PTEST
(
test_visituri_inserts
)
PTEST
(
test_visituri_updates
)
PTEST
(
test_visituri_preserves_shown_and_typed
)
PTEST
(
test_visituri_creates_visit
)
PTEST
(
test_visituri_frecency
)
PTEST
(
test_visituri_hidden
)
PTEST
(
test_visituri_transition_typed
)
PTEST
(
test_visituri_transition_embed
)
}
;
int
gTestsIndex
=
0
;
class
RunNextTest
:
public
mozilla
:
:
Runnable
{
public
:
RunNextTest
(
)
:
mozilla
:
:
Runnable
(
"
RunNextTest
"
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
Not
running
on
the
main
thread
?
"
)
;
if
(
gTestsIndex
<
int
(
std
:
:
size
(
gTests
)
)
)
{
do_test_pending
(
)
;
Test
&
test
=
gTests
[
gTestsIndex
+
+
]
;
(
void
)
fprintf
(
stderr
TEST_INFO_STR
"
Running
%
s
.
\
n
"
test
.
name
)
;
test
.
func
(
)
;
}
do_test_finished
(
)
;
return
NS_OK
;
}
}
;
static
const
bool
kDebugRunNextTest
=
false
;
void
run_next_test
(
)
{
if
(
kDebugRunNextTest
)
{
printf_stderr
(
"
run_next_test
(
)
\
n
"
)
;
MozWalkTheStack
(
stderr
)
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
RunNextTest
(
)
;
do_check_success
(
NS_DispatchToCurrentThread
(
event
)
)
;
}
int
gPendingTests
=
0
;
void
do_test_pending
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
Not
running
on
the
main
thread
?
"
)
;
if
(
kDebugRunNextTest
)
{
printf_stderr
(
"
do_test_pending
(
)
\
n
"
)
;
MozWalkTheStack
(
stderr
)
;
}
gPendingTests
+
+
;
}
void
do_test_finished
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
Not
running
on
the
main
thread
?
"
)
;
MOZ_RELEASE_ASSERT
(
gPendingTests
>
0
"
Invalid
pending
test
count
!
"
)
;
gPendingTests
-
-
;
}
TEST
(
IHistory
Test
)
{
RefPtr
<
WaitForConnectionClosed
>
spinClose
=
new
WaitForConnectionClosed
(
)
;
disable_idle_service
(
)
;
do_test_pending
(
)
;
run_next_test
(
)
;
mozilla
:
:
SpinEventLoopUntil
(
"
places
:
TEST
(
IHistory
Test
)
"
_ns
[
&
]
(
)
{
return
!
gPendingTests
;
}
)
;
(
void
)
NS_ProcessPendingEvents
(
nullptr
)
;
}
