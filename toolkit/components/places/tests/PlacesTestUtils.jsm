"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PlacesTestUtils
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
this
.
PlacesTestUtils
=
Object
.
freeze
(
{
addVisits
:
Task
.
async
(
function
*
(
placeInfo
)
{
let
places
=
[
]
;
let
infos
=
[
]
;
if
(
placeInfo
instanceof
Ci
.
nsIURI
|
|
placeInfo
instanceof
URL
|
|
typeof
placeInfo
=
=
"
string
"
)
{
places
.
push
(
{
uri
:
placeInfo
}
)
;
}
else
if
(
Array
.
isArray
(
placeInfo
)
)
{
places
=
places
.
concat
(
placeInfo
)
;
}
else
if
(
typeof
placeInfo
=
=
"
object
"
&
&
placeInfo
.
uri
)
{
places
.
push
(
placeInfo
)
}
else
{
throw
new
Error
(
"
Unsupported
type
passed
to
addVisits
"
)
;
}
for
(
let
place
of
places
)
{
let
info
=
{
url
:
place
.
uri
}
;
info
.
title
=
(
typeof
place
.
title
=
=
=
"
string
"
)
?
place
.
title
:
"
test
visit
for
"
+
info
.
url
.
spec
;
if
(
typeof
place
.
referrer
=
=
"
string
"
)
{
place
.
referrer
=
NetUtil
.
newURI
(
place
.
referrer
)
;
}
else
if
(
place
.
referrer
&
&
place
.
referrer
instanceof
URL
)
{
place
.
referrer
=
NetUtil
.
newURI
(
place
.
referrer
.
href
)
;
}
let
visitDate
=
place
.
visitDate
;
if
(
visitDate
)
{
if
(
!
(
visitDate
instanceof
Date
)
)
{
visitDate
=
PlacesUtils
.
toDate
(
visitDate
)
;
}
}
else
{
visitDate
=
new
Date
(
)
;
}
info
.
visits
=
[
{
transition
:
place
.
transition
date
:
visitDate
referrer
:
place
.
referrer
}
]
;
infos
.
push
(
info
)
;
}
return
PlacesUtils
.
history
.
insertMany
(
infos
)
;
}
)
clearHistory
(
)
{
let
expirationFinished
=
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observe
(
subj
topic
data
)
{
Services
.
obs
.
removeObserver
(
observe
topic
)
;
resolve
(
)
;
}
PlacesUtils
.
TOPIC_EXPIRATION_FINISHED
false
)
;
}
)
;
return
Promise
.
all
(
[
expirationFinished
PlacesUtils
.
history
.
clear
(
)
]
)
;
}
promiseAsyncUpdates
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
promiseAsyncUpdates
"
Task
.
async
(
function
*
(
db
)
{
try
{
yield
db
.
executeCached
(
"
BEGIN
EXCLUSIVE
"
)
;
yield
db
.
executeCached
(
"
COMMIT
"
)
;
}
catch
(
ex
)
{
}
}
)
)
;
}
isPageInDB
:
Task
.
async
(
function
*
(
aURI
)
{
let
url
=
aURI
instanceof
Ci
.
nsIURI
?
aURI
.
spec
:
aURI
;
let
db
=
yield
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
yield
db
.
executeCached
(
"
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
"
{
url
}
)
;
return
rows
.
length
>
0
;
}
)
visitsInDB
:
Task
.
async
(
function
*
(
aURI
)
{
let
url
=
aURI
instanceof
Ci
.
nsIURI
?
aURI
.
spec
:
aURI
;
let
db
=
yield
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
yield
db
.
executeCached
(
SELECT
count
(
*
)
FROM
moz_historyvisits
v
JOIN
moz_places
h
ON
h
.
id
=
v
.
place_id
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
{
url
}
)
;
return
rows
[
0
]
.
getResultByIndex
(
0
)
;
}
)
}
)
;
