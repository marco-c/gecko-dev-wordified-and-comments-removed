"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PlacesTestUtils
"
]
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TestUtils
"
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
;
var
PlacesTestUtils
=
Object
.
freeze
(
{
async
addVisits
(
placeInfo
)
{
let
places
=
[
]
;
let
infos
=
[
]
;
if
(
placeInfo
instanceof
Ci
.
nsIURI
|
|
placeInfo
instanceof
URL
|
|
typeof
placeInfo
=
=
"
string
"
)
{
places
.
push
(
{
uri
:
placeInfo
}
)
;
}
else
if
(
Array
.
isArray
(
placeInfo
)
)
{
places
=
places
.
concat
(
placeInfo
)
;
}
else
if
(
typeof
placeInfo
=
=
"
object
"
&
&
placeInfo
.
uri
)
{
places
.
push
(
placeInfo
)
;
}
else
{
throw
new
Error
(
"
Unsupported
type
passed
to
addVisits
"
)
;
}
let
lastStoredVisit
;
for
(
let
place
of
places
)
{
let
info
=
{
url
:
place
.
uri
}
;
let
spec
=
place
.
uri
instanceof
Ci
.
nsIURI
?
place
.
uri
.
spec
:
new
URL
(
place
.
uri
)
.
href
;
info
.
title
=
"
title
"
in
place
?
place
.
title
:
"
test
visit
for
"
+
spec
;
if
(
typeof
place
.
referrer
=
=
"
string
"
)
{
place
.
referrer
=
Services
.
io
.
newURI
(
place
.
referrer
)
;
}
else
if
(
place
.
referrer
&
&
place
.
referrer
instanceof
URL
)
{
place
.
referrer
=
Services
.
io
.
newURI
(
place
.
referrer
.
href
)
;
}
let
visitDate
=
place
.
visitDate
;
if
(
visitDate
)
{
if
(
visitDate
.
constructor
.
name
!
=
"
Date
"
)
{
if
(
visitDate
<
=
Date
.
now
(
)
)
{
throw
new
Error
(
"
AddVisits
expects
a
Date
object
or
_micro_seconds
!
"
)
;
}
visitDate
=
PlacesUtils
.
toDate
(
visitDate
)
;
}
}
else
{
visitDate
=
new
Date
(
)
;
}
info
.
visits
=
[
{
transition
:
place
.
transition
date
:
visitDate
referrer
:
place
.
referrer
}
]
;
infos
.
push
(
info
)
;
if
(
place
.
transition
!
=
PlacesUtils
.
history
.
TRANSITIONS
.
EMBED
)
lastStoredVisit
=
info
;
}
await
PlacesUtils
.
history
.
insertMany
(
infos
)
;
if
(
lastStoredVisit
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
PlacesUtils
.
history
.
fetch
(
lastStoredVisit
.
url
)
"
Ensure
history
has
been
updated
and
is
visible
to
read
-
only
connections
"
)
;
}
}
async
addFavicons
(
faviconURLs
)
{
let
faviconPromises
=
[
]
;
if
(
!
faviconURLs
)
{
throw
new
Error
(
"
No
favicon
URLs
were
provided
"
)
;
}
for
(
let
[
key
val
]
of
faviconURLs
)
{
if
(
!
val
)
{
throw
new
Error
(
"
URL
does
not
exist
"
)
;
}
faviconPromises
.
push
(
new
Promise
(
(
resolve
reject
)
=
>
{
let
uri
=
Services
.
io
.
newURI
(
key
)
;
let
faviconURI
=
Services
.
io
.
newURI
(
val
)
;
try
{
PlacesUtils
.
favicons
.
setAndFetchFaviconForPage
(
uri
faviconURI
false
PlacesUtils
.
favicons
.
FAVICON_LOAD_NON_PRIVATE
resolve
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
}
}
)
)
;
}
await
Promise
.
all
(
faviconPromises
)
;
}
promiseAsyncUpdates
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
promiseAsyncUpdates
"
async
function
(
db
)
{
try
{
await
db
.
executeCached
(
"
BEGIN
EXCLUSIVE
"
)
;
await
db
.
executeCached
(
"
COMMIT
"
)
;
}
catch
(
ex
)
{
}
}
)
;
}
async
isPageInDB
(
aURI
)
{
let
url
=
aURI
instanceof
Ci
.
nsIURI
?
aURI
.
spec
:
aURI
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
"
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
"
{
url
}
)
;
return
rows
.
length
>
0
;
}
async
visitsInDB
(
aURI
)
{
let
url
=
aURI
instanceof
Ci
.
nsIURI
?
aURI
.
spec
:
aURI
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
count
(
*
)
FROM
moz_historyvisits
v
JOIN
moz_places
h
ON
h
.
id
=
v
.
place_id
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
{
url
}
)
;
return
rows
[
0
]
.
getResultByIndex
(
0
)
;
}
fieldInDB
(
aURI
field
)
{
let
url
=
aURI
instanceof
Ci
.
nsIURI
?
new
URL
(
aURI
.
spec
)
:
new
URL
(
aURI
)
;
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesTestUtils
.
jsm
:
fieldInDb
"
async
db
=
>
{
let
rows
=
await
db
.
executeCached
(
SELECT
{
field
}
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
{
url
:
url
.
href
}
)
;
return
rows
[
0
]
.
getResultByIndex
(
0
)
;
}
)
;
}
markBookmarksAsSynced
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesTestUtils
:
markBookmarksAsSynced
"
function
(
db
)
{
return
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
executeCached
(
WITH
RECURSIVE
syncedItems
(
id
)
AS
(
SELECT
b
.
id
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
'
menu________
'
'
toolbar_____
'
'
unfiled_____
'
'
mobile______
'
)
UNION
ALL
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
syncedItems
s
ON
b
.
parent
=
s
.
id
)
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
0
syncStatus
=
:
syncStatus
WHERE
id
IN
syncedItems
{
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
)
;
await
db
.
executeCached
(
"
DELETE
FROM
moz_bookmarks_deleted
"
)
;
}
)
;
}
)
;
}
setBookmarkSyncFields
(
.
.
.
aFieldInfos
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesTestUtils
:
setBookmarkSyncFields
"
function
(
db
)
{
return
db
.
executeTransaction
(
async
function
(
)
{
for
(
let
info
of
aFieldInfos
)
{
if
(
!
PlacesUtils
.
isValidGuid
(
info
.
guid
)
)
{
throw
new
Error
(
Invalid
GUID
:
{
info
.
guid
}
)
;
}
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncStatus
=
IFNULL
(
:
syncStatus
syncStatus
)
syncChangeCounter
=
IFNULL
(
:
syncChangeCounter
syncChangeCounter
)
lastModified
=
IFNULL
(
:
lastModified
lastModified
)
dateAdded
=
IFNULL
(
:
dateAdded
dateAdded
)
WHERE
guid
=
:
guid
{
guid
:
info
.
guid
syncChangeCounter
:
info
.
syncChangeCounter
syncStatus
:
"
syncStatus
"
in
info
?
info
.
syncStatus
:
null
lastModified
:
"
lastModified
"
in
info
?
PlacesUtils
.
toPRTime
(
info
.
lastModified
)
:
null
dateAdded
:
"
dateAdded
"
in
info
?
PlacesUtils
.
toPRTime
(
info
.
dateAdded
)
:
null
}
)
;
}
}
)
;
}
)
;
}
async
fetchBookmarkSyncFields
(
.
.
.
aGuids
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
results
=
[
]
;
for
(
let
guid
of
aGuids
)
{
let
rows
=
await
db
.
executeCached
(
SELECT
syncStatus
syncChangeCounter
lastModified
dateAdded
FROM
moz_bookmarks
WHERE
guid
=
:
guid
{
guid
}
)
;
if
(
!
rows
.
length
)
{
throw
new
Error
(
Bookmark
{
guid
}
does
not
exist
)
;
}
results
.
push
(
{
guid
syncStatus
:
rows
[
0
]
.
getResultByName
(
"
syncStatus
"
)
syncChangeCounter
:
rows
[
0
]
.
getResultByName
(
"
syncChangeCounter
"
)
lastModified
:
PlacesUtils
.
toDate
(
rows
[
0
]
.
getResultByName
(
"
lastModified
"
)
)
dateAdded
:
PlacesUtils
.
toDate
(
rows
[
0
]
.
getResultByName
(
"
dateAdded
"
)
)
}
)
;
}
return
results
;
}
async
fetchSyncTombstones
(
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
guid
dateRemoved
FROM
moz_bookmarks_deleted
ORDER
BY
guid
)
;
return
rows
.
map
(
row
=
>
(
{
guid
:
row
.
getResultByName
(
"
guid
"
)
dateRemoved
:
PlacesUtils
.
toDate
(
row
.
getResultByName
(
"
dateRemoved
"
)
)
}
)
)
;
}
waitForNotification
(
notification
conditionFn
=
(
)
=
>
true
type
=
"
bookmarks
"
)
{
if
(
type
=
=
"
places
"
)
{
return
new
Promise
(
resolve
=
>
{
function
listener
(
events
)
{
if
(
conditionFn
(
events
)
)
{
PlacesObservers
.
removeListener
(
[
notification
]
listener
)
;
resolve
(
)
;
}
}
PlacesObservers
.
addListener
(
[
notification
]
listener
)
;
}
)
;
}
let
iface
=
type
=
=
"
bookmarks
"
?
Ci
.
nsINavBookmarkObserver
:
Ci
.
nsINavHistoryObserver
;
return
new
Promise
(
resolve
=
>
{
let
proxifiedObserver
=
new
Proxy
(
{
}
{
get
:
(
target
name
)
=
>
{
if
(
name
=
=
"
QueryInterface
"
)
return
ChromeUtils
.
generateQI
(
[
iface
]
)
;
if
(
name
=
=
notification
)
return
(
.
.
.
args
)
=
>
{
if
(
conditionFn
.
apply
(
this
args
)
)
{
PlacesUtils
[
type
]
.
removeObserver
(
proxifiedObserver
)
;
resolve
(
)
;
}
}
;
if
(
name
=
=
"
skipTags
"
|
|
name
=
=
"
skipDescendantsOnItemRemoval
"
)
{
return
false
;
}
return
(
)
=
>
false
;
}
}
)
;
PlacesUtils
[
type
]
.
addObserver
(
proxifiedObserver
)
;
}
)
;
}
async
dumpTable
(
db
table
)
{
let
rows
=
await
db
.
execute
(
SELECT
*
FROM
{
table
}
)
;
dump
(
Table
{
table
}
contains
{
rows
.
length
}
rows
\
n
)
;
let
results
=
[
]
;
for
(
let
row
of
rows
)
{
let
numColumns
=
row
.
numEntries
;
let
rowValues
=
[
]
;
for
(
let
i
=
0
;
i
<
numColumns
;
+
+
i
)
{
switch
(
row
.
getTypeOfIndex
(
i
)
)
{
case
Ci
.
mozIStorageValueArray
.
VALUE_TYPE_NULL
:
rowValues
.
push
(
"
NULL
"
)
;
break
;
case
Ci
.
mozIStorageValueArray
.
VALUE_TYPE_INTEGER
:
rowValues
.
push
(
row
.
getInt64
(
i
)
)
;
break
;
case
Ci
.
mozIStorageValueArray
.
VALUE_TYPE_FLOAT
:
rowValues
.
push
(
row
.
getDouble
(
i
)
)
;
break
;
case
Ci
.
mozIStorageValueArray
.
VALUE_TYPE_TEXT
:
rowValues
.
push
(
JSON
.
stringify
(
row
.
getString
(
i
)
)
)
;
break
;
}
}
results
.
push
(
rowValues
.
join
(
"
\
t
"
)
)
;
}
results
.
push
(
"
\
n
"
)
;
dump
(
results
.
join
(
"
\
n
"
)
)
;
}
clearMetadata
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesTestUtils
:
clearMetadata
"
async
db
=
>
{
await
db
.
execute
(
DELETE
FROM
moz_meta
)
;
PlacesUtils
.
metadata
.
cache
.
clear
(
)
;
}
)
;
}
ComparePlacesURIs
(
url1
url2
)
{
url1
=
url1
instanceof
Ci
.
nsIURI
?
url1
.
spec
:
new
URL
(
url1
)
;
if
(
url1
.
protocol
!
=
"
place
:
"
)
throw
new
Error
(
"
Expected
a
place
:
uri
got
"
+
url1
.
href
)
;
url2
=
url2
instanceof
Ci
.
nsIURI
?
url2
.
spec
:
new
URL
(
url2
)
;
if
(
url2
.
protocol
!
=
"
place
:
"
)
throw
new
Error
(
"
Expected
a
place
:
uri
got
"
+
url2
.
href
)
;
let
tokens1
=
url1
.
pathname
.
split
(
"
&
"
)
.
sort
(
)
.
join
(
"
&
"
)
;
let
tokens2
=
url2
.
pathname
.
split
(
"
&
"
)
.
sort
(
)
.
join
(
"
&
"
)
;
if
(
tokens1
!
=
tokens2
)
{
dump
(
Failed
comparison
between
:
\
n
{
tokens1
}
\
n
{
tokens2
}
\
n
)
;
return
false
;
}
return
true
;
}
}
)
;
