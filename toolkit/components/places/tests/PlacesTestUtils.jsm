"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PlacesTestUtils
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
this
.
PlacesTestUtils
=
Object
.
freeze
(
{
async
addVisits
(
placeInfo
)
{
let
places
=
[
]
;
let
infos
=
[
]
;
if
(
placeInfo
instanceof
Ci
.
nsIURI
|
|
placeInfo
instanceof
URL
|
|
typeof
placeInfo
=
=
"
string
"
)
{
places
.
push
(
{
uri
:
placeInfo
}
)
;
}
else
if
(
Array
.
isArray
(
placeInfo
)
)
{
places
=
places
.
concat
(
placeInfo
)
;
}
else
if
(
typeof
placeInfo
=
=
"
object
"
&
&
placeInfo
.
uri
)
{
places
.
push
(
placeInfo
)
}
else
{
throw
new
Error
(
"
Unsupported
type
passed
to
addVisits
"
)
;
}
for
(
let
place
of
places
)
{
let
info
=
{
url
:
place
.
uri
}
;
info
.
title
=
(
typeof
place
.
title
=
=
=
"
string
"
)
?
place
.
title
:
"
test
visit
for
"
+
info
.
url
.
spec
;
if
(
typeof
place
.
referrer
=
=
"
string
"
)
{
place
.
referrer
=
NetUtil
.
newURI
(
place
.
referrer
)
;
}
else
if
(
place
.
referrer
&
&
place
.
referrer
instanceof
URL
)
{
place
.
referrer
=
NetUtil
.
newURI
(
place
.
referrer
.
href
)
;
}
let
visitDate
=
place
.
visitDate
;
if
(
visitDate
)
{
if
(
visitDate
.
constructor
.
name
!
=
"
Date
"
)
{
if
(
visitDate
<
=
Date
.
now
(
)
)
{
throw
new
Error
(
"
AddVisits
expects
a
Date
object
or
_micro_seconds
!
"
)
;
}
visitDate
=
PlacesUtils
.
toDate
(
visitDate
)
;
}
}
else
{
visitDate
=
new
Date
(
)
;
}
info
.
visits
=
[
{
transition
:
place
.
transition
date
:
visitDate
referrer
:
place
.
referrer
}
]
;
infos
.
push
(
info
)
;
}
return
PlacesUtils
.
history
.
insertMany
(
infos
)
;
}
async
addFavicons
(
faviconURLs
)
{
let
faviconPromises
=
[
]
;
if
(
!
faviconURLs
)
{
throw
new
Error
(
"
No
favicon
URLs
were
provided
"
)
;
}
for
(
let
[
key
val
]
of
faviconURLs
)
{
if
(
!
val
)
{
throw
new
Error
(
"
URL
does
not
exist
"
)
;
}
faviconPromises
.
push
(
new
Promise
(
(
resolve
reject
)
=
>
{
let
uri
=
NetUtil
.
newURI
(
key
)
;
let
faviconURI
=
NetUtil
.
newURI
(
val
)
;
try
{
PlacesUtils
.
favicons
.
setAndFetchFaviconForPage
(
uri
faviconURI
false
PlacesUtils
.
favicons
.
FAVICON_LOAD_NON_PRIVATE
resolve
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
}
}
)
)
;
}
await
Promise
.
all
(
faviconPromises
)
;
}
clearHistory
(
)
{
let
expirationFinished
=
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observe
(
subj
topic
data
)
{
Services
.
obs
.
removeObserver
(
observe
topic
)
;
resolve
(
)
;
}
PlacesUtils
.
TOPIC_EXPIRATION_FINISHED
)
;
}
)
;
return
Promise
.
all
(
[
expirationFinished
PlacesUtils
.
history
.
clear
(
)
]
)
;
}
promiseAsyncUpdates
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
promiseAsyncUpdates
"
async
function
(
db
)
{
try
{
await
db
.
executeCached
(
"
BEGIN
EXCLUSIVE
"
)
;
await
db
.
executeCached
(
"
COMMIT
"
)
;
}
catch
(
ex
)
{
}
}
)
;
}
async
isPageInDB
(
aURI
)
{
let
url
=
aURI
instanceof
Ci
.
nsIURI
?
aURI
.
spec
:
aURI
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
"
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
"
{
url
}
)
;
return
rows
.
length
>
0
;
}
async
visitsInDB
(
aURI
)
{
let
url
=
aURI
instanceof
Ci
.
nsIURI
?
aURI
.
spec
:
aURI
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
count
(
*
)
FROM
moz_historyvisits
v
JOIN
moz_places
h
ON
h
.
id
=
v
.
place_id
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
{
url
}
)
;
return
rows
[
0
]
.
getResultByIndex
(
0
)
;
}
async
fieldInDB
(
aURI
field
)
{
let
url
=
aURI
instanceof
Ci
.
nsIURI
?
new
URL
(
aURI
.
spec
)
:
new
URL
(
aURI
)
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
{
field
}
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
{
url
:
url
.
href
}
)
;
return
rows
[
0
]
.
getResultByIndex
(
0
)
;
}
markBookmarksAsSynced
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesTestUtils
:
markBookmarksAsSynced
"
function
(
db
)
{
return
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
executeCached
(
WITH
RECURSIVE
syncedItems
(
id
)
AS
(
SELECT
b
.
id
FROM
moz_bookmarks
b
WHERE
b
.
guid
IN
(
'
menu________
'
'
toolbar_____
'
'
unfiled_____
'
'
mobile______
'
)
UNION
ALL
SELECT
b
.
id
FROM
moz_bookmarks
b
JOIN
syncedItems
s
ON
b
.
parent
=
s
.
id
)
UPDATE
moz_bookmarks
SET
syncChangeCounter
=
0
syncStatus
=
:
syncStatus
WHERE
id
IN
syncedItems
{
syncStatus
:
PlacesUtils
.
bookmarks
.
SYNC_STATUS
.
NORMAL
}
)
;
await
db
.
executeCached
(
"
DELETE
FROM
moz_bookmarks_deleted
"
)
;
}
)
;
}
)
;
}
setBookmarkSyncFields
(
.
.
.
aFieldInfos
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesTestUtils
:
setBookmarkSyncFields
"
function
(
db
)
{
return
db
.
executeTransaction
(
async
function
(
)
{
for
(
let
info
of
aFieldInfos
)
{
if
(
!
PlacesUtils
.
isValidGuid
(
info
.
guid
)
)
{
throw
new
Error
(
Invalid
GUID
:
{
info
.
guid
}
)
;
}
await
db
.
executeCached
(
UPDATE
moz_bookmarks
SET
syncStatus
=
IFNULL
(
:
syncStatus
syncStatus
)
syncChangeCounter
=
IFNULL
(
:
syncChangeCounter
syncChangeCounter
)
lastModified
=
IFNULL
(
:
lastModified
lastModified
)
dateAdded
=
IFNULL
(
:
dateAdded
dateAdded
)
WHERE
guid
=
:
guid
{
guid
:
info
.
guid
syncChangeCounter
:
info
.
syncChangeCounter
syncStatus
:
"
syncStatus
"
in
info
?
info
.
syncStatus
:
null
lastModified
:
"
lastModified
"
in
info
?
PlacesUtils
.
toPRTime
(
info
.
lastModified
)
:
null
dateAdded
:
"
dateAdded
"
in
info
?
PlacesUtils
.
toPRTime
(
info
.
dateAdded
)
:
null
}
)
;
}
}
)
;
}
)
;
}
async
fetchBookmarkSyncFields
(
.
.
.
aGuids
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
results
=
[
]
;
for
(
let
guid
of
aGuids
)
{
let
rows
=
await
db
.
executeCached
(
SELECT
syncStatus
syncChangeCounter
lastModified
dateAdded
FROM
moz_bookmarks
WHERE
guid
=
:
guid
{
guid
}
)
;
if
(
!
rows
.
length
)
{
throw
new
Error
(
Bookmark
{
guid
}
does
not
exist
)
;
}
results
.
push
(
{
guid
syncStatus
:
rows
[
0
]
.
getResultByName
(
"
syncStatus
"
)
syncChangeCounter
:
rows
[
0
]
.
getResultByName
(
"
syncChangeCounter
"
)
lastModified
:
PlacesUtils
.
toDate
(
rows
[
0
]
.
getResultByName
(
"
lastModified
"
)
)
dateAdded
:
PlacesUtils
.
toDate
(
rows
[
0
]
.
getResultByName
(
"
dateAdded
"
)
)
}
)
;
}
return
results
;
}
async
fetchSyncTombstones
(
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
guid
dateRemoved
FROM
moz_bookmarks_deleted
ORDER
BY
guid
)
;
return
rows
.
map
(
row
=
>
(
{
guid
:
row
.
getResultByName
(
"
guid
"
)
dateRemoved
:
PlacesUtils
.
toDate
(
row
.
getResultByName
(
"
dateRemoved
"
)
)
}
)
)
;
}
waitForNotification
(
notification
conditionFn
=
(
)
=
>
true
type
=
"
bookmarks
"
)
{
let
iface
=
type
=
=
"
bookmarks
"
?
Ci
.
nsINavBookmarkObserver
:
Ci
.
nsINavHistoryObserver
;
return
new
Promise
(
resolve
=
>
{
let
proxifiedObserver
=
new
Proxy
(
{
}
{
get
:
(
target
name
)
=
>
{
if
(
name
=
=
"
QueryInterface
"
)
return
XPCOMUtils
.
generateQI
(
[
iface
]
)
;
if
(
name
=
=
notification
)
return
(
.
.
.
args
)
=
>
{
if
(
conditionFn
.
apply
(
this
args
)
)
{
PlacesUtils
[
type
]
.
removeObserver
(
proxifiedObserver
)
;
resolve
(
)
;
}
}
if
(
name
=
=
"
skipTags
"
|
|
name
=
=
"
skipDescendantsOnItemRemoval
"
)
{
return
false
;
}
return
(
)
=
>
false
;
}
}
)
;
PlacesUtils
[
type
]
.
addObserver
(
proxifiedObserver
)
;
}
)
;
}
}
)
;
