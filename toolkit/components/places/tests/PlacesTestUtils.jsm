"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PlacesTestUtils
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
this
.
PlacesTestUtils
=
Object
.
freeze
(
{
addVisits
:
Task
.
async
(
function
*
(
placeInfo
)
{
let
places
=
[
]
;
if
(
placeInfo
instanceof
Ci
.
nsIURI
|
|
placeInfo
instanceof
URL
|
|
typeof
placeInfo
=
=
"
string
"
)
{
places
.
push
(
{
uri
:
placeInfo
}
)
;
}
else
if
(
Array
.
isArray
(
placeInfo
)
)
{
places
=
places
.
concat
(
placeInfo
)
;
}
else
if
(
typeof
placeInfo
=
=
"
object
"
&
&
placeInfo
.
uri
)
{
places
.
push
(
placeInfo
)
}
else
{
throw
new
Error
(
"
Unsupported
type
passed
to
addVisits
"
)
;
}
let
now
=
Date
.
now
(
)
;
for
(
let
place
of
places
)
{
if
(
typeof
place
.
uri
=
=
"
string
"
)
{
place
.
uri
=
NetUtil
.
newURI
(
place
.
uri
)
;
}
else
if
(
place
.
uri
instanceof
URL
)
{
place
.
uri
=
NetUtil
.
newURI
(
place
.
href
)
;
}
if
(
typeof
place
.
title
!
=
"
string
"
)
{
place
.
title
=
"
test
visit
for
"
+
place
.
uri
.
spec
;
}
place
.
visits
=
[
{
transitionType
:
place
.
transition
=
=
=
undefined
?
Ci
.
nsINavHistoryService
.
TRANSITION_LINK
:
place
.
transition
visitDate
:
place
.
visitDate
|
|
(
now
+
+
)
*
1000
referrerURI
:
place
.
referrer
}
]
;
}
yield
new
Promise
(
(
resolve
reject
)
=
>
{
PlacesUtils
.
asyncHistory
.
updatePlaces
(
places
{
handleError
(
resultCode
placeInfo
)
{
let
ex
=
new
Components
.
Exception
(
"
Unexpected
error
in
adding
visits
.
"
resultCode
)
;
reject
(
ex
)
;
}
handleResult
:
function
(
)
{
}
handleCompletion
(
)
{
resolve
(
)
;
}
}
)
;
}
)
;
}
)
clearHistory
(
)
{
let
expirationFinished
=
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observe
(
subj
topic
data
)
{
Services
.
obs
.
removeObserver
(
observe
topic
)
;
resolve
(
)
;
}
PlacesUtils
.
TOPIC_EXPIRATION_FINISHED
false
)
;
}
)
;
return
Promise
.
all
(
[
expirationFinished
PlacesUtils
.
history
.
clear
(
)
]
)
;
}
promiseAsyncUpdates
(
)
{
return
new
Promise
(
resolve
=
>
{
let
db
=
PlacesUtils
.
history
.
DBConnection
;
let
begin
=
db
.
createAsyncStatement
(
"
BEGIN
EXCLUSIVE
"
)
;
begin
.
executeAsync
(
)
;
begin
.
finalize
(
)
;
let
commit
=
db
.
createAsyncStatement
(
"
COMMIT
"
)
;
commit
.
executeAsync
(
{
handleResult
:
function
(
)
{
}
handleError
:
function
(
)
{
}
handleCompletion
:
function
(
aReason
)
{
resolve
(
)
;
}
}
)
;
commit
.
finalize
(
)
;
}
)
;
}
isPageInDB
:
Task
.
async
(
function
*
(
aURI
)
{
let
url
=
aURI
instanceof
Ci
.
nsIURI
?
aURI
.
spec
:
aURI
;
let
db
=
yield
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
yield
db
.
executeCached
(
"
SELECT
id
FROM
moz_places
WHERE
url
=
:
url
"
{
url
}
)
;
return
rows
.
length
>
0
;
}
)
visitsInDB
:
Task
.
async
(
function
*
(
aURI
)
{
let
url
=
aURI
instanceof
Ci
.
nsIURI
?
aURI
.
spec
:
aURI
;
let
db
=
yield
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
yield
db
.
executeCached
(
SELECT
count
(
*
)
FROM
moz_historyvisits
v
JOIN
moz_places
h
ON
h
.
id
=
v
.
place_id
WHERE
url
=
:
url
{
url
}
)
;
return
rows
[
0
]
.
getResultByIndex
(
0
)
;
}
)
}
)
;
