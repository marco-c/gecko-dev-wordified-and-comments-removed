const
searchTerm
=
"
about
"
;
var
testRoot
;
var
testRootId
;
add_task
(
async
function
setup
(
)
{
testRoot
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
title
:
searchTerm
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
)
;
testRootId
=
await
PlacesUtils
.
promiseItemId
(
testRoot
.
guid
)
;
}
)
;
add_task
(
async
function
test_savedsearches_bookmarks
(
)
{
let
bookmark
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
title
:
searchTerm
url
:
"
http
:
/
/
foo
.
com
"
}
)
;
let
search
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
testRoot
.
guid
title
:
searchTerm
url
:
"
place
:
terms
=
"
+
searchTerm
+
"
&
excludeQueries
=
1
&
expandQueries
=
1
&
queryType
=
1
"
}
)
;
try
{
let
options
=
PlacesUtils
.
history
.
getNewQueryOptions
(
)
;
options
.
expandQueries
=
0
;
let
query
=
PlacesUtils
.
history
.
getNewQuery
(
)
;
query
.
setFolders
(
[
testRootId
]
1
)
;
let
result
=
PlacesUtils
.
history
.
executeQuery
(
query
options
)
;
let
rootNode
=
result
.
root
;
rootNode
.
containerOpen
=
true
;
let
cc
=
rootNode
.
childCount
;
do_check_eq
(
cc
1
)
;
for
(
let
i
=
0
;
i
<
cc
;
i
+
+
)
{
let
node
=
rootNode
.
getChild
(
i
)
;
do_check_true
(
node
.
itemId
>
0
)
;
node
.
QueryInterface
(
Ci
.
nsINavHistoryContainerResultNode
)
;
do_check_eq
(
node
.
containerOpen
false
)
;
}
rootNode
.
containerOpen
=
false
;
}
catch
(
ex
)
{
do_throw
(
"
expandQueries
=
0
query
error
:
"
+
ex
)
;
}
try
{
let
options
=
PlacesUtils
.
history
.
getNewQueryOptions
(
)
;
options
.
expandQueries
=
1
;
let
query
=
PlacesUtils
.
history
.
getNewQuery
(
)
;
query
.
setFolders
(
[
testRootId
]
1
)
;
let
result
=
PlacesUtils
.
history
.
executeQuery
(
query
options
)
;
let
rootNode
=
result
.
root
;
rootNode
.
containerOpen
=
true
;
let
cc
=
rootNode
.
childCount
;
do_check_eq
(
cc
1
)
;
for
(
let
i
=
0
;
i
<
cc
;
i
+
+
)
{
let
node
=
rootNode
.
getChild
(
i
)
;
do_check_eq
(
node
.
type
node
.
RESULT_TYPE_QUERY
)
;
do_check_true
(
node
.
itemId
>
0
)
;
node
.
QueryInterface
(
Ci
.
nsINavHistoryContainerResultNode
)
;
node
.
containerOpen
=
true
;
do_check_eq
(
node
.
childCount
1
)
;
var
item
=
node
.
getChild
(
0
)
;
do_check_eq
(
item
.
bookmarkGuid
bookmark
.
guid
)
;
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
title
:
searchTerm
+
"
zaa
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
)
;
do_check_eq
(
node
.
childCount
1
)
;
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
title
:
searchTerm
+
"
blah
"
url
:
"
place
:
terms
=
foo
&
excludeQueries
=
1
&
expandQueries
=
1
&
queryType
=
1
"
}
)
;
do_check_eq
(
node
.
childCount
1
)
;
}
rootNode
.
containerOpen
=
false
;
}
catch
(
ex
)
{
do_throw
(
"
expandQueries
=
1
bookmarks
query
:
"
+
ex
)
;
}
await
PlacesUtils
.
bookmarks
.
remove
(
search
)
;
}
)
;
add_task
(
async
function
test_savedsearches_history
(
)
{
var
testURI
=
uri
(
"
http
:
/
/
"
+
searchTerm
+
"
.
com
"
)
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
testURI
title
:
searchTerm
}
)
;
var
searchItem
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
testRoot
.
guid
title
:
searchTerm
url
:
"
place
:
terms
=
"
+
searchTerm
+
"
&
excludeQueries
=
1
&
expandQueries
=
1
&
queryType
=
0
"
}
)
;
try
{
var
options
=
PlacesUtils
.
history
.
getNewQueryOptions
(
)
;
options
.
expandQueries
=
1
;
var
query
=
PlacesUtils
.
history
.
getNewQuery
(
)
;
query
.
setFolders
(
[
testRootId
]
1
)
;
var
result
=
PlacesUtils
.
history
.
executeQuery
(
query
options
)
;
var
rootNode
=
result
.
root
;
rootNode
.
containerOpen
=
true
;
var
cc
=
rootNode
.
childCount
;
do_check_eq
(
cc
1
)
;
for
(
var
i
=
0
;
i
<
cc
;
i
+
+
)
{
var
node
=
rootNode
.
getChild
(
i
)
;
do_check_eq
(
node
.
type
node
.
RESULT_TYPE_QUERY
)
;
do_check_eq
(
node
.
bookmarkGuid
searchItem
.
guid
)
;
node
.
QueryInterface
(
Ci
.
nsINavHistoryContainerResultNode
)
;
node
.
containerOpen
=
true
;
do_check_eq
(
node
.
childCount
1
)
;
var
item
=
node
.
getChild
(
0
)
;
do_check_eq
(
item
.
type
item
.
RESULT_TYPE_URI
)
;
do_check_eq
(
item
.
itemId
-
1
)
;
do_check_eq
(
item
.
uri
testURI
.
spec
)
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
uri
(
"
http
:
/
/
foo
.
com
"
)
title
:
searchTerm
+
"
blah
"
}
)
;
do_check_eq
(
node
.
childCount
2
)
;
await
PlacesUtils
.
history
.
remove
(
"
http
:
/
/
foo
.
com
"
)
;
do_check_eq
(
node
.
childCount
1
)
;
node
.
containerOpen
=
false
;
}
let
tmpFolder
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
testRoot
.
guid
title
:
"
foo
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
)
;
searchItem
.
parentGuid
=
tmpFolder
.
guid
;
await
PlacesUtils
.
bookmarks
.
update
(
searchItem
)
;
var
tmpFolderNode
=
rootNode
.
getChild
(
0
)
;
do_check_eq
(
tmpFolderNode
.
bookmarkGuid
tmpFolder
.
guid
)
;
tmpFolderNode
.
QueryInterface
(
Ci
.
nsINavHistoryContainerResultNode
)
;
tmpFolderNode
.
containerOpen
=
true
;
do_check_eq
(
tmpFolderNode
.
childCount
1
)
;
searchItem
.
title
=
"
foo
"
;
await
PlacesUtils
.
bookmarks
.
update
(
searchItem
)
;
do_check_eq
(
tmpFolderNode
.
title
"
foo
"
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
searchItem
)
;
Assert
.
throws
(
(
)
=
>
tmpFolderNode
=
rootNode
.
getChild
(
1
)
/
NS_ERROR_ILLEGAL_VALUE
/
"
getting
a
deleted
child
should
throw
"
)
;
tmpFolderNode
.
containerOpen
=
false
;
rootNode
.
containerOpen
=
false
;
}
catch
(
ex
)
{
do_throw
(
"
expandQueries
=
1
bookmarks
query
:
"
+
ex
)
;
}
}
)
;
