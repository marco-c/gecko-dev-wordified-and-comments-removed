var
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
{
let
commonFile
=
do_get_file
(
"
.
.
/
head_common
.
js
"
false
)
;
let
uri
=
Services
.
io
.
newFileURI
(
commonFile
)
;
Services
.
scriptloader
.
loadSubScript
(
uri
.
spec
this
)
;
}
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PlacesDBUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesDBUtils
.
jsm
"
}
)
;
async
function
createCorruptDb
(
filename
)
{
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
filename
)
;
await
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
let
dir
=
await
OS
.
File
.
getCurrentDirectory
(
)
;
let
src
=
OS
.
Path
.
join
(
dir
"
corruptDB
.
sqlite
"
)
;
await
OS
.
File
.
copy
(
src
path
)
;
}
async
function
test_database_replacement
(
src
filename
shouldClone
dbStatus
)
{
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
places
.
database
.
cloneOnCorruption
"
)
;
}
)
;
Services
.
prefs
.
setBoolPref
(
"
places
.
database
.
cloneOnCorruption
"
shouldClone
)
;
let
willClone
=
shouldClone
&
&
filename
=
=
DB_FILENAME
;
let
dest
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
filename
)
;
Assert
.
ok
(
!
await
OS
.
File
.
exists
(
dest
)
"
{
filename
}
should
not
exist
initially
)
;
let
corrupt
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
{
filename
}
.
corrupt
)
;
Assert
.
ok
(
!
await
OS
.
File
.
exists
(
corrupt
)
{
filename
}
.
corrupt
should
not
exist
initially
)
;
let
dir
=
await
OS
.
File
.
getCurrentDirectory
(
)
;
src
=
OS
.
Path
.
join
(
dir
src
)
;
await
OS
.
File
.
copy
(
src
dest
)
;
let
db
=
await
Sqlite
.
openConnection
(
{
path
:
dest
}
)
;
await
db
.
execute
(
CREATE
TABLE
moz_cloned
(
id
INTEGER
PRIMARY
KEY
)
)
;
await
db
.
execute
(
CREATE
TABLE
not_cloned
(
id
INTEGER
PRIMARY
KEY
)
)
;
await
db
.
execute
(
DELETE
FROM
moz_cloned
)
;
await
db
.
close
(
)
;
Services
.
prefs
.
setCharPref
(
"
places
.
database
.
replaceDatabaseOnStartup
"
filename
)
;
Assert
.
equal
(
PlacesUtils
.
history
.
databaseStatus
dbStatus
)
;
Assert
.
ok
(
await
OS
.
File
.
exists
(
dest
)
"
The
database
should
exist
"
)
;
db
=
await
Sqlite
.
openConnection
(
{
path
:
dest
}
)
;
if
(
willClone
)
{
await
db
.
execute
(
DELETE
FROM
moz_cloned
)
;
}
await
Assert
.
rejects
(
db
.
execute
(
DELETE
FROM
not_cloned
)
/
no
such
table
/
"
The
database
should
have
been
replaced
"
)
;
await
db
.
close
(
)
;
if
(
willClone
)
{
Assert
.
ok
(
!
await
OS
.
File
.
exists
(
corrupt
)
"
The
corrupt
db
should
not
exist
"
)
;
}
else
{
Assert
.
ok
(
await
OS
.
File
.
exists
(
corrupt
)
"
The
corrupt
db
should
exist
"
)
;
}
}
