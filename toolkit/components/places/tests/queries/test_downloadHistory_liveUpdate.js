function
accumulateNotifications
(
result
)
{
let
notifications
=
[
]
;
let
resultObserver
=
new
Proxy
(
NavHistoryResultObserver
{
get
(
target
name
)
{
if
(
name
=
=
"
check
"
)
{
result
.
removeObserver
(
resultObserver
false
)
;
return
expectedNotifications
=
>
Assert
.
deepEqual
(
notifications
expectedNotifications
)
;
}
if
(
[
"
QueryInterface
"
"
containerStateChanged
"
]
.
includes
(
name
)
)
return
(
)
=
>
{
}
;
return
(
)
=
>
{
notifications
.
push
(
name
)
;
}
;
}
}
)
;
result
.
addObserver
(
resultObserver
false
)
;
return
resultObserver
;
}
add_task
(
async
function
test_downloadhistory_query_notifications
(
)
{
const
MAX_RESULTS
=
5
;
let
query
=
PlacesUtils
.
history
.
getNewQuery
(
)
;
query
.
setTransitions
(
[
PlacesUtils
.
history
.
TRANSITIONS
.
DOWNLOAD
]
1
)
;
let
options
=
PlacesUtils
.
history
.
getNewQueryOptions
(
)
;
options
.
sortingMode
=
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_DATE_DESCENDING
;
options
.
maxResults
=
MAX_RESULTS
;
let
result
=
PlacesUtils
.
history
.
executeQuery
(
query
options
)
;
let
notifications
=
accumulateNotifications
(
result
)
;
let
root
=
PlacesUtils
.
asContainer
(
result
.
root
)
;
root
.
containerOpen
=
true
;
let
transitions
=
Object
.
values
(
PlacesUtils
.
history
.
TRANSITIONS
)
;
for
(
let
transition
of
transitions
)
{
let
uri
=
"
http
:
/
/
fx
-
search
.
com
/
"
+
transition
;
await
PlacesTestUtils
.
addVisits
(
{
uri
transition
title
:
"
test
"
+
transition
}
)
;
await
PlacesUtils
.
bookmarks
.
insert
(
{
url
:
uri
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
}
)
;
await
PlacesUtils
.
history
.
update
(
{
url
:
uri
annotations
:
new
Map
(
[
[
"
test
/
anno
"
"
testValue
"
]
]
)
}
)
;
await
PlacesTestUtils
.
addFavicons
(
new
Map
(
[
[
uri
SMALLPNG_DATA_URI
.
spec
]
]
)
)
;
}
for
(
let
transition
of
transitions
)
{
let
uri
=
Services
.
io
.
newURI
(
"
http
:
/
/
fx
-
search
.
com
/
"
+
transition
)
;
await
PlacesUtils
.
history
.
remove
(
uri
)
;
}
root
.
containerOpen
=
false
;
notifications
.
check
(
[
"
nodeHistoryDetailsChanged
"
"
nodeInserted
"
"
nodeTitleChanged
"
"
nodeIconChanged
"
"
nodeRemoved
"
]
)
;
}
)
;
add_task
(
async
function
test_downloadhistory_query_filtering
(
)
{
const
MAX_RESULTS
=
3
;
let
query
=
PlacesUtils
.
history
.
getNewQuery
(
)
;
query
.
setTransitions
(
[
PlacesUtils
.
history
.
TRANSITIONS
.
DOWNLOAD
]
1
)
;
let
options
=
PlacesUtils
.
history
.
getNewQueryOptions
(
)
;
options
.
sortingMode
=
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_DATE_DESCENDING
;
options
.
maxResults
=
MAX_RESULTS
;
let
result
=
PlacesUtils
.
history
.
executeQuery
(
query
options
)
;
let
root
=
PlacesUtils
.
asContainer
(
result
.
root
)
;
root
.
containerOpen
=
true
;
Assert
.
equal
(
root
.
childCount
0
"
No
visits
found
"
)
;
let
uris
=
[
]
;
let
visitDate
=
Date
.
now
(
)
*
1000
;
for
(
let
i
=
0
;
i
<
MAX_RESULTS
+
1
;
+
+
i
visitDate
+
=
1000
)
{
let
uri
=
http
:
/
/
fx
-
search
.
com
/
download
/
{
i
}
;
await
PlacesTestUtils
.
addVisits
(
{
uri
transition
:
PlacesUtils
.
history
.
TRANSITIONS
.
DOWNLOAD
visitDate
}
)
;
uris
.
push
(
uri
)
;
}
await
PlacesTestUtils
.
addVisits
(
{
uri
:
http
:
/
/
fx
-
search
.
com
/
download
/
unordered
transition
:
PlacesUtils
.
history
.
TRANSITIONS
.
DOWNLOAD
visitDate
:
new
Date
(
Date
.
now
(
)
-
7200000
)
}
)
;
Assert
.
equal
(
root
.
childCount
MAX_RESULTS
"
Result
should
be
limited
"
)
;
uris
.
reverse
(
)
;
for
(
let
i
=
0
;
i
<
root
.
childCount
;
+
+
i
)
{
let
node
=
root
.
getChild
(
i
)
;
Assert
.
equal
(
node
.
uri
uris
[
i
]
"
Found
the
expected
uri
"
)
;
}
root
.
containerOpen
=
false
;
}
)
;
