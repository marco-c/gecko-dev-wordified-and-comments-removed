var
testData
=
[
{
isVisit
:
true
uri
:
"
file
:
/
/
/
directory
/
1
"
lastVisit
:
today
title
:
"
test
visit
"
isInQuery
:
true
}
{
isVisit
:
true
uri
:
"
http
:
/
/
example
.
com
/
1
"
lastVisit
:
today
title
:
"
test
visit
"
isInQuery
:
true
}
{
isVisit
:
true
uri
:
"
http
:
/
/
example
.
com
/
2
"
lastVisit
:
today
title
:
"
test
visit
"
isInQuery
:
true
}
{
isVisit
:
true
uri
:
"
file
:
/
/
/
directory
/
2
"
lastVisit
:
olderthansixmonths
title
:
"
test
visit
"
isInQuery
:
true
}
{
isVisit
:
true
uri
:
"
http
:
/
/
example
.
com
/
3
"
lastVisit
:
olderthansixmonths
title
:
"
test
visit
"
isInQuery
:
true
}
{
isVisit
:
true
uri
:
"
http
:
/
/
example
.
com
/
4
"
lastVisit
:
olderthansixmonths
title
:
"
test
visit
"
isInQuery
:
true
}
{
isVisit
:
true
uri
:
"
http
:
/
/
example
.
net
/
1
"
lastVisit
:
olderthansixmonths
+
1000
title
:
"
test
visit
"
isInQuery
:
true
}
]
;
var
leveledTestData
=
[
[
[
0
]
[
1
2
]
]
[
[
3
]
[
4
5
]
[
6
]
]
]
;
var
testDataAddedLater
=
[
{
isVisit
:
true
uri
:
"
http
:
/
/
example
.
com
/
5
"
lastVisit
:
olderthansixmonths
title
:
"
test
visit
"
isInQuery
:
true
levels
:
[
1
1
]
}
{
isVisit
:
true
uri
:
"
http
:
/
/
example
.
com
/
6
"
lastVisit
:
olderthansixmonths
title
:
"
test
visit
"
isInQuery
:
true
levels
:
[
1
1
]
}
{
isVisit
:
true
uri
:
"
http
:
/
/
example
.
com
/
7
"
lastVisit
:
today
title
:
"
test
visit
"
isInQuery
:
true
levels
:
[
0
1
]
}
{
isVisit
:
true
uri
:
"
file
:
/
/
/
directory
/
3
"
lastVisit
:
today
title
:
"
test
visit
"
isInQuery
:
true
levels
:
[
0
0
]
}
]
;
add_task
(
async
function
test_sort_date_site_grouping
(
)
{
await
task_populateDB
(
testData
)
;
let
isLinux
=
"
mozilla
.
org
/
gnome
-
gconf
-
service
;
1
"
in
Cc
;
if
(
isLinux
)
{
return
;
}
let
roots
=
[
]
;
let
query
=
PlacesUtils
.
history
.
getNewQuery
(
)
;
let
options
=
PlacesUtils
.
history
.
getNewQueryOptions
(
)
;
options
.
resultType
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_DATE_SITE_QUERY
;
let
root
=
PlacesUtils
.
history
.
executeQuery
(
query
options
)
.
root
;
root
.
containerOpen
=
true
;
Assert
.
equal
(
root
.
childCount
leveledTestData
.
length
)
;
for
(
let
index
=
0
;
index
<
leveledTestData
.
length
;
index
+
+
)
{
let
node
=
root
.
getChild
(
index
)
;
checkFirstLevel
(
index
node
roots
)
;
}
for
(
let
visit
of
testDataAddedLater
)
{
await
task_populateDB
(
[
visit
]
)
;
let
oldLength
=
testData
.
length
;
let
i
=
visit
.
levels
[
0
]
;
let
j
=
visit
.
levels
[
1
]
;
testData
.
push
(
visit
)
;
leveledTestData
[
i
]
[
j
]
.
push
(
oldLength
)
;
compareArrayToResult
(
leveledTestData
[
i
]
[
j
]
.
map
(
x
=
>
testData
[
x
]
)
roots
[
i
]
[
j
]
)
;
}
for
(
let
i
=
0
;
i
<
roots
.
length
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
roots
[
i
]
.
length
;
j
+
+
)
{
roots
[
i
]
[
j
]
.
containerOpen
=
false
;
}
}
root
.
containerOpen
=
false
;
}
)
;
function
checkFirstLevel
(
index
node
roots
)
{
PlacesUtils
.
asContainer
(
node
)
.
containerOpen
=
true
;
Assert
.
ok
(
PlacesUtils
.
nodeIsDay
(
node
)
)
;
PlacesUtils
.
asQuery
(
node
)
;
let
query
=
node
.
query
;
let
options
=
node
.
queryOptions
;
Assert
.
ok
(
query
.
hasBeginTime
&
&
query
.
hasEndTime
)
;
let
root
=
PlacesUtils
.
history
.
executeQuery
(
query
options
)
.
root
;
roots
.
push
(
[
]
)
;
root
.
containerOpen
=
true
;
Assert
.
equal
(
root
.
childCount
leveledTestData
[
index
]
.
length
)
;
for
(
var
secondIndex
=
0
;
secondIndex
<
root
.
childCount
;
secondIndex
+
+
)
{
let
child
=
PlacesUtils
.
asQuery
(
root
.
getChild
(
secondIndex
)
)
;
checkSecondLevel
(
index
secondIndex
child
roots
)
;
}
root
.
containerOpen
=
false
;
node
.
containerOpen
=
false
;
}
function
checkSecondLevel
(
index
secondIndex
child
roots
)
{
let
query
=
child
.
query
;
let
options
=
child
.
queryOptions
;
Assert
.
ok
(
query
.
hasDomain
)
;
Assert
.
ok
(
query
.
hasBeginTime
&
&
query
.
hasEndTime
)
;
let
root
=
PlacesUtils
.
history
.
executeQuery
(
query
options
)
.
root
;
roots
[
index
]
.
push
(
root
)
;
root
.
containerOpen
=
true
;
compareArrayToResult
(
leveledTestData
[
index
]
[
secondIndex
]
.
map
(
x
=
>
testData
[
x
]
)
root
)
;
}
