var
tests
=
[
{
desc
:
"
nsNavHistoryFolderResultNode
:
Basic
test
asynchronously
open
and
"
+
"
close
container
with
a
single
child
"
loading
(
node
newState
oldState
)
{
this
.
checkStateChanged
(
"
loading
"
1
)
;
this
.
checkArgs
(
"
loading
"
node
oldState
node
.
STATE_CLOSED
)
;
}
opened
(
node
newState
oldState
)
{
this
.
checkStateChanged
(
"
opened
"
1
)
;
this
.
checkState
(
"
loading
"
1
)
;
this
.
checkArgs
(
"
opened
"
node
oldState
node
.
STATE_LOADING
)
;
print
(
"
Checking
node
children
"
)
;
compareArrayToResult
(
this
.
data
node
)
;
print
(
"
Closing
container
"
)
;
node
.
containerOpen
=
false
;
}
closed
(
node
newState
oldState
)
{
this
.
checkStateChanged
(
"
closed
"
1
)
;
this
.
checkState
(
"
opened
"
1
)
;
this
.
checkArgs
(
"
closed
"
node
oldState
node
.
STATE_OPENED
)
;
this
.
success
(
)
;
}
}
{
desc
:
"
nsNavHistoryFolderResultNode
:
After
async
open
and
no
changes
"
+
"
second
open
should
be
synchronous
"
loading
(
node
newState
oldState
)
{
this
.
checkStateChanged
(
"
loading
"
1
)
;
this
.
checkState
(
"
closed
"
0
)
;
this
.
checkArgs
(
"
loading
"
node
oldState
node
.
STATE_CLOSED
)
;
}
opened
(
node
newState
oldState
)
{
let
cnt
=
this
.
checkStateChanged
(
"
opened
"
1
2
)
;
let
expectOldState
=
cnt
=
=
=
1
?
node
.
STATE_LOADING
:
node
.
STATE_CLOSED
;
this
.
checkArgs
(
"
opened
"
node
oldState
expectOldState
)
;
print
(
"
Checking
node
children
"
)
;
compareArrayToResult
(
this
.
data
node
)
;
print
(
"
Closing
container
"
)
;
node
.
containerOpen
=
false
;
}
closed
(
node
newState
oldState
)
{
let
cnt
=
this
.
checkStateChanged
(
"
closed
"
1
2
)
;
this
.
checkArgs
(
"
closed
"
node
oldState
node
.
STATE_OPENED
)
;
switch
(
cnt
)
{
case
1
:
node
.
containerOpen
=
true
;
break
;
case
2
:
this
.
success
(
)
;
break
;
}
}
}
{
desc
:
"
nsNavHistoryFolderResultNode
:
After
closing
container
in
"
+
"
loading
(
)
opened
(
)
should
not
be
called
"
loading
(
node
newState
oldState
)
{
this
.
checkStateChanged
(
"
loading
"
1
)
;
this
.
checkArgs
(
"
loading
"
node
oldState
node
.
STATE_CLOSED
)
;
print
(
"
Closing
container
"
)
;
node
.
containerOpen
=
false
;
}
opened
(
node
newState
oldState
)
{
do_throw
(
"
opened
should
not
be
called
"
)
;
}
closed
(
node
newState
oldState
)
{
this
.
checkStateChanged
(
"
closed
"
1
)
;
this
.
checkState
(
"
loading
"
1
)
;
this
.
checkArgs
(
"
closed
"
node
oldState
node
.
STATE_LOADING
)
;
this
.
success
(
)
;
}
}
]
;
function
Test
(
)
{
this
.
stateCounts
=
{
}
;
this
.
deferNextTest
=
PromiseUtils
.
defer
(
)
;
}
Test
.
prototype
=
{
checkArgs
(
aNewState
aNode
aOldState
aExpectOldState
)
{
print
(
"
Node
passed
on
"
+
aNewState
+
"
should
be
result
.
root
"
)
;
Assert
.
equal
(
this
.
result
.
root
aNode
)
;
print
(
"
Old
state
passed
on
"
+
aNewState
+
"
should
be
"
+
aExpectOldState
)
;
Assert
.
ok
(
aOldState
=
=
=
aExpectOldState
)
;
}
checkStateChanged
(
aState
aExpectedMin
aExpectedMax
)
{
print
(
aState
+
"
state
change
observed
"
)
;
if
(
!
this
.
stateCounts
.
hasOwnProperty
(
aState
)
)
{
this
.
stateCounts
[
aState
]
=
0
;
}
this
.
stateCounts
[
aState
]
+
+
;
return
this
.
checkState
(
aState
aExpectedMin
aExpectedMax
)
;
}
checkState
(
aState
aExpectedMin
aExpectedMax
)
{
let
cnt
=
this
.
stateCounts
[
aState
]
|
|
0
;
if
(
aExpectedMax
=
=
=
undefined
)
{
aExpectedMax
=
aExpectedMin
;
}
if
(
aExpectedMin
=
=
=
aExpectedMax
)
{
print
(
aState
+
"
should
be
observed
only
"
+
aExpectedMin
+
"
times
(
actual
=
"
+
cnt
+
"
)
"
)
;
}
else
{
print
(
aState
+
"
should
be
observed
at
least
"
+
aExpectedMin
+
"
times
and
at
most
"
+
aExpectedMax
+
"
times
(
actual
=
"
+
cnt
+
"
)
"
)
;
}
Assert
.
ok
(
cnt
>
=
aExpectedMin
&
&
cnt
<
=
aExpectedMax
)
;
return
cnt
;
}
openContainer
(
)
{
let
self
=
this
;
this
.
observer
=
{
containerStateChanged
(
container
oldState
newState
)
{
print
(
"
New
state
passed
to
containerStateChanged
(
)
should
equal
the
"
+
"
container
'
s
current
state
"
)
;
Assert
.
equal
(
newState
container
.
state
)
;
try
{
switch
(
newState
)
{
case
Ci
.
nsINavHistoryContainerResultNode
.
STATE_LOADING
:
self
.
loading
(
container
newState
oldState
)
;
break
;
case
Ci
.
nsINavHistoryContainerResultNode
.
STATE_OPENED
:
self
.
opened
(
container
newState
oldState
)
;
break
;
case
Ci
.
nsINavHistoryContainerResultNode
.
STATE_CLOSED
:
self
.
closed
(
container
newState
oldState
)
;
break
;
default
:
do_throw
(
"
Unexpected
new
state
!
"
+
newState
)
;
}
}
catch
(
err
)
{
do_throw
(
err
)
;
}
}
}
;
this
.
result
.
addObserver
(
this
.
observer
)
;
print
(
"
Opening
container
"
)
;
this
.
result
.
root
.
containerOpen
=
true
;
}
run
(
)
{
this
.
openContainer
(
)
;
return
this
.
deferNextTest
.
promise
;
}
async
setup
(
)
{
this
.
data
=
DataHelper
.
makeDataArray
(
[
{
type
:
"
bookmark
"
}
{
type
:
"
separator
"
}
{
type
:
"
folder
"
}
{
type
:
"
bookmark
"
uri
:
"
place
:
terms
=
foo
"
}
]
)
;
await
task_populateDB
(
this
.
data
)
;
this
.
query
=
PlacesUtils
.
history
.
getNewQuery
(
)
;
this
.
query
.
setParents
(
[
DataHelper
.
defaults
.
bookmark
.
parentGuid
]
)
;
this
.
opts
=
PlacesUtils
.
history
.
getNewQueryOptions
(
)
;
this
.
opts
.
asyncEnabled
=
true
;
this
.
result
=
PlacesUtils
.
history
.
executeQuery
(
this
.
query
this
.
opts
)
;
}
success
(
)
{
this
.
result
.
removeObserver
(
this
.
observer
)
;
this
.
deferNextTest
.
resolve
(
)
;
}
}
;
var
DataHelper
=
{
defaults
:
{
bookmark
:
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
uri
:
"
http
:
/
/
example
.
com
/
"
title
:
"
test
bookmark
"
}
folder
:
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
title
:
"
test
folder
"
}
separator
:
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
}
}
makeDataArray
:
function
DH_makeDataArray
(
aData
)
{
let
self
=
this
;
return
aData
.
map
(
function
(
dat
)
{
let
type
=
dat
.
type
;
dat
=
self
.
_makeDataWithDefaults
(
dat
self
.
defaults
[
type
]
)
;
switch
(
type
)
{
case
"
bookmark
"
:
return
{
isBookmark
:
true
uri
:
dat
.
uri
parentGuid
:
dat
.
parentGuid
index
:
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
title
:
dat
.
title
isInQuery
:
true
}
;
case
"
separator
"
:
return
{
isSeparator
:
true
parentGuid
:
dat
.
parentGuid
index
:
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
isInQuery
:
true
}
;
case
"
folder
"
:
return
{
isFolder
:
true
parentGuid
:
dat
.
parentGuid
index
:
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
title
:
dat
.
title
isInQuery
:
true
}
;
default
:
do_throw
(
"
Unknown
data
type
when
populating
DB
:
"
+
type
)
;
return
undefined
;
}
}
)
;
}
_makeDataWithDefaults
:
function
DH__makeDataWithDefaults
(
aData
aDefaults
)
{
let
dat
=
{
}
;
for
(
let
[
prop
val
]
of
Object
.
entries
(
aDefaults
)
)
{
dat
[
prop
]
=
aData
.
hasOwnProperty
(
prop
)
?
aData
[
prop
]
:
val
;
}
return
dat
;
}
}
;
add_task
(
async
function
test_async
(
)
{
for
(
let
test
of
tests
)
{
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
test
.
__proto__
=
new
Test
(
)
;
await
test
.
setup
(
)
;
print
(
"
-
-
-
-
-
-
Running
test
:
"
+
test
.
desc
)
;
await
test
.
run
(
)
;
}
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
print
(
"
All
tests
done
exiting
"
)
;
}
)
;
