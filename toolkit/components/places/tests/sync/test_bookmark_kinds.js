add_task
(
async
function
test_queries
(
)
{
let
buf
=
await
openMirror
(
"
queries
"
)
;
info
(
"
Set
up
places
"
)
;
let
tag
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
parentGuid
:
PlacesUtils
.
bookmarks
.
tagsGuid
title
:
"
a
-
tag
"
}
)
;
await
PlacesTestUtils
.
markBookmarksAsSynced
(
)
;
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
menuGuid
children
:
[
{
guid
:
"
queryAAAAAAA
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
title
:
"
TAG_QUERY
query
"
url
:
place
:
tag
=
a
-
tag
&
&
sort
=
14
&
maxResults
=
10
}
{
guid
:
"
queryBBBBBBB
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
title
:
"
TAG_QUERY
query
but
invalid
folder
id
"
url
:
place
:
tag
=
b
-
tag
&
sort
=
14
&
maxResults
=
10
}
{
guid
:
"
queryCCCCCCC
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
title
:
"
TAG_QUERY
without
a
folder
at
all
"
url
:
"
place
:
sort
=
14
&
maxResults
=
10
"
}
{
guid
:
"
queryDDDDDDD
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
title
:
"
TAG_QUERY
without
a
folder
at
all
"
url
:
"
place
:
tag
=
a
-
tag
"
}
]
}
)
;
info
(
"
Make
remote
changes
"
)
;
await
storeRecords
(
buf
shuffle
(
[
{
id
:
"
toolbar
"
parentid
:
"
places
"
type
:
"
folder
"
children
:
[
"
queryEEEEEEE
"
"
queryFFFFFFF
"
"
queryGGGGGGG
"
"
queryHHHHHHH
"
]
}
{
id
:
"
queryEEEEEEE
"
parentid
:
"
toolbar
"
type
:
"
query
"
title
:
"
E
"
bmkUri
:
"
place
:
type
=
7
&
folder
=
999
"
folderName
:
"
taggy
"
}
{
id
:
"
queryFFFFFFF
"
parentid
:
"
toolbar
"
type
:
"
query
"
title
:
"
F
"
bmkUri
:
"
place
:
tag
=
a
-
tag
"
folderName
:
"
a
-
tag
"
}
{
id
:
"
queryGGGGGGG
"
parentid
:
"
toolbar
"
type
:
"
query
"
title
:
"
G
"
bmkUri
:
"
place
:
type
=
7
&
folder
=
111
&
something
=
else
"
folderName
:
"
a
-
tag
"
}
{
id
:
"
queryHHHHHHH
"
parentid
:
"
toolbar
"
type
:
"
query
"
title
:
"
H
"
bmkUri
:
"
place
:
folder
=
1
"
}
]
)
)
;
info
(
"
Create
records
to
upload
"
)
;
let
changes
=
await
buf
.
apply
(
)
;
Assert
.
strictEqual
(
changes
.
queryAAAAAAA
.
cleartext
.
folderName
tag
.
title
)
;
Assert
.
strictEqual
(
changes
.
queryBBBBBBB
.
cleartext
.
folderName
"
b
-
tag
"
)
;
Assert
.
strictEqual
(
changes
.
queryCCCCCCC
.
cleartext
.
folderName
undefined
)
;
Assert
.
strictEqual
(
changes
.
queryDDDDDDD
.
cleartext
.
folderName
tag
.
title
)
;
await
assertLocalTree
(
PlacesUtils
.
bookmarks
.
toolbarGuid
{
guid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
index
:
1
title
:
BookmarksToolbarTitle
children
:
[
{
guid
:
"
queryEEEEEEE
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
index
:
0
title
:
"
E
"
url
:
"
place
:
tag
=
taggy
"
}
{
guid
:
"
queryFFFFFFF
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
index
:
1
title
:
"
F
"
url
:
"
place
:
tag
=
a
-
tag
"
}
{
guid
:
"
queryGGGGGGG
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
index
:
2
title
:
"
G
"
url
:
"
place
:
tag
=
a
-
tag
"
}
{
guid
:
"
queryHHHHHHH
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
index
:
3
title
:
"
H
"
url
:
"
place
:
folder
=
1
&
excludeItems
=
1
"
}
]
}
"
Should
rewrite
legacy
remote
queries
"
)
;
await
buf
.
finalize
(
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesSyncUtils
.
bookmarks
.
reset
(
)
;
}
)
;
add_task
(
async
function
test_mismatched_but_compatible_folder_types
(
)
{
let
buf
=
await
openMirror
(
"
mismatched_types
"
)
;
info
(
"
Set
up
mirror
"
)
;
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
children
:
[
{
guid
:
"
l1nZZXfB8nC7
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
title
:
"
Innerst
i
Sneglehode
"
}
]
}
)
;
await
PlacesTestUtils
.
markBookmarksAsSynced
(
)
;
info
(
"
Make
remote
changes
"
)
;
await
storeRecords
(
buf
[
{
id
:
"
toolbar
"
parentid
:
"
places
"
type
:
"
folder
"
children
:
[
"
l1nZZXfB8nC7
"
]
}
{
"
id
"
:
"
l1nZZXfB8nC7
"
"
type
"
:
"
livemark
"
"
siteUri
"
:
"
http
:
/
/
sneglehode
.
wordpress
.
com
/
"
"
feedUri
"
:
"
http
:
/
/
sneglehode
.
wordpress
.
com
/
feed
/
"
"
parentName
"
:
"
Bookmarks
Toolbar
"
"
title
"
:
"
Innerst
i
Sneglehode
"
"
description
"
:
null
"
children
"
:
[
"
HCRq40Rnxhrd
"
"
YeyWCV1RVsYw
"
"
GCceVZMhvMbP
"
"
sYi2hevdArlF
"
"
vjbZlPlSyGY8
"
"
UtjUhVyrpeG6
"
"
rVq8WMG2wfZI
"
"
Lx0tcy43ZKhZ
"
"
oT74WwV8_j4P
"
"
IztsItWVSo3
-
"
]
"
parentid
"
:
"
toolbar
"
}
]
)
;
info
(
"
Apply
remote
"
)
;
let
changesToUpload
=
await
buf
.
apply
(
)
;
deepEqual
(
await
buf
.
fetchUnmergedGuids
(
)
[
]
"
Should
merge
all
items
"
)
;
let
idsToUpload
=
inspectChangeRecords
(
changesToUpload
)
;
deepEqual
(
idsToUpload
{
updated
:
[
"
toolbar
"
]
deleted
:
[
"
l1nZZXfB8nC7
"
]
}
"
Legacy
livemark
should
be
deleted
remotely
"
)
;
await
buf
.
finalize
(
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesSyncUtils
.
bookmarks
.
reset
(
)
;
}
)
;
add_task
(
async
function
test_different_but_compatible_bookmark_types
(
)
{
try
{
let
buf
=
await
openMirror
(
"
partial_queries
"
)
;
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
menuGuid
children
:
[
{
guid
:
"
bookmarkAAAA
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
title
:
"
not
yet
a
query
"
url
:
"
about
:
blank
"
}
{
guid
:
"
bookmarkBBBB
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
title
:
"
a
query
"
url
:
"
place
:
foo
"
}
]
}
)
;
let
changes
=
await
buf
.
apply
(
)
;
Assert
.
equal
(
changes
.
bookmarkAAAA
.
cleartext
.
type
"
bookmark
"
)
;
Assert
.
equal
(
changes
.
bookmarkBBBB
.
cleartext
.
type
"
query
"
)
;
await
storeRecords
(
buf
[
{
id
:
"
menu
"
parentid
:
"
places
"
type
:
"
folder
"
children
:
[
"
bookmarkAAAA
"
"
bookmarkBBBB
"
]
}
{
id
:
"
bookmarkAAAA
"
parentid
:
"
menu
"
type
:
"
bookmark
"
title
:
"
not
yet
a
query
"
bmkUri
:
"
about
:
blank
"
}
{
id
:
"
bookmarkBBBB
"
parentid
:
"
menu
"
type
:
"
query
"
title
:
"
a
query
"
bmkUri
:
"
place
:
foo
"
}
]
{
needsMerge
:
false
}
)
;
await
PlacesTestUtils
.
markBookmarksAsSynced
(
)
;
await
PlacesUtils
.
bookmarks
.
update
(
{
guid
:
"
bookmarkAAAA
"
url
:
"
place
:
type
=
6
&
sort
=
14
&
maxResults
=
10
"
}
)
;
await
PlacesUtils
.
bookmarks
.
update
(
{
guid
:
"
bookmarkBBBB
"
url
:
"
about
:
robots
"
}
)
;
changes
=
await
buf
.
apply
(
)
;
Assert
.
equal
(
changes
.
bookmarkAAAA
.
cleartext
.
type
"
query
"
)
;
Assert
.
equal
(
changes
.
bookmarkBBBB
.
cleartext
.
type
"
bookmark
"
)
;
}
finally
{
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesSyncUtils
.
bookmarks
.
reset
(
)
;
}
}
)
;
add_task
(
async
function
test_incompatible_types
(
)
{
let
sawMismatchError
=
false
;
let
recordTelemetryEvent
=
(
object
method
value
extra
)
=
>
{
if
(
method
=
=
"
apply
"
&
&
value
=
=
"
error
"
&
&
extra
&
&
extra
.
why
=
=
"
Can
'
t
merge
different
item
kinds
"
)
{
sawMismatchError
=
true
;
}
}
;
try
{
let
buf
=
await
openMirror
(
"
partial_queries
"
{
recordTelemetryEvent
}
)
;
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
menuGuid
children
:
[
{
guid
:
"
AAAAAAAAAAAA
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
title
:
"
a
bookmark
"
url
:
"
about
:
blank
"
}
]
}
)
;
await
buf
.
apply
(
)
;
await
storeRecords
(
buf
[
{
id
:
"
menu
"
parentid
:
"
places
"
type
:
"
folder
"
children
:
[
"
AAAAAAAAAAAA
"
]
}
{
id
:
"
AAAAAAAAAAAA
"
parentid
:
"
menu
"
type
:
"
folder
"
title
:
"
conflicting
folder
"
}
]
{
needsMerge
:
true
}
)
;
await
PlacesTestUtils
.
markBookmarksAsSynced
(
)
;
await
Assert
.
rejects
(
buf
.
apply
(
)
/
Can
'
t
merge
different
item
kinds
/
)
;
Assert
.
ok
(
sawMismatchError
"
saw
expected
mismatch
event
"
)
;
}
finally
{
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesSyncUtils
.
bookmarks
.
reset
(
)
;
}
}
)
;
