const
NUMBER_OF_BACKUPS
=
10
;
async
function
createBackups
(
nBackups
dateObj
bookmarksBackupDir
)
{
let
dates
=
[
]
;
while
(
dates
.
length
<
nBackups
)
{
let
randomDate
=
new
Date
(
dateObj
.
getFullYear
(
)
-
1
Math
.
floor
(
12
*
Math
.
random
(
)
)
Math
.
floor
(
28
*
Math
.
random
(
)
)
)
;
if
(
!
dates
.
includes
(
randomDate
.
getTime
(
)
)
)
{
dates
.
push
(
randomDate
.
getTime
(
)
)
;
}
}
dates
.
sort
(
)
;
for
(
let
i
=
dates
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
backupFilename
=
PlacesBackups
.
getFilenameForDate
(
new
Date
(
dates
[
i
]
)
)
;
let
backupFile
=
bookmarksBackupDir
.
clone
(
)
;
backupFile
.
append
(
backupFilename
)
;
backupFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
parseInt
(
"
0666
"
8
)
)
;
info
(
"
Creating
fake
backup
"
+
backupFile
.
leafName
)
;
if
(
!
backupFile
.
exists
(
)
)
{
do_throw
(
"
Unable
to
create
fake
backup
"
+
backupFile
.
leafName
)
;
}
}
return
dates
;
}
async
function
checkBackups
(
dates
bookmarksBackupDir
)
{
for
(
let
i
=
0
;
i
<
dates
.
length
;
i
+
+
)
{
let
backupFilename
;
let
shouldExist
;
let
backupFile
;
if
(
i
>
0
)
{
let
files
=
bookmarksBackupDir
.
directoryEntries
;
while
(
files
.
hasMoreElements
(
)
)
{
let
entry
=
files
.
nextFile
;
if
(
PlacesBackups
.
filenamesRegex
.
test
(
entry
.
leafName
)
)
{
backupFilename
=
entry
.
leafName
;
backupFile
=
entry
;
break
;
}
}
shouldExist
=
true
;
}
else
{
backupFilename
=
PlacesBackups
.
getFilenameForDate
(
new
Date
(
dates
[
i
]
)
)
;
backupFile
=
bookmarksBackupDir
.
clone
(
)
;
backupFile
.
append
(
backupFilename
)
;
shouldExist
=
false
;
}
if
(
backupFile
.
exists
(
)
!
=
shouldExist
)
{
do_throw
(
"
Backup
should
"
+
(
shouldExist
?
"
"
:
"
not
"
)
+
"
exist
:
"
+
backupFilename
)
;
}
}
}
async
function
cleanupFiles
(
bookmarksBackupDir
)
{
let
files
=
bookmarksBackupDir
.
directoryEntries
;
while
(
files
.
hasMoreElements
(
)
)
{
let
entry
=
files
.
nextFile
;
entry
.
remove
(
false
)
;
}
delete
PlacesBackups
.
_backupFiles
;
Assert
.
ok
(
!
bookmarksBackupDir
.
directoryEntries
.
hasMoreElements
(
)
)
;
}
add_task
(
async
function
test_create_backups
(
)
{
let
backupFolderPath
=
await
PlacesBackups
.
getBackupFolder
(
)
;
let
bookmarksBackupDir
=
new
FileUtils
.
File
(
backupFolderPath
)
;
let
dateObj
=
new
Date
(
)
;
let
dates
=
await
createBackups
(
NUMBER_OF_BACKUPS
dateObj
bookmarksBackupDir
)
;
await
PlacesBackups
.
create
(
NUMBER_OF_BACKUPS
)
;
dates
.
push
(
dateObj
.
getTime
(
)
)
;
await
checkBackups
(
dates
bookmarksBackupDir
)
;
await
cleanupFiles
(
bookmarksBackupDir
)
;
}
)
;
add_task
(
async
function
test_saveBookmarks_with_no_backups
(
)
{
let
backupFolderPath
=
await
PlacesBackups
.
getBackupFolder
(
)
;
let
bookmarksBackupDir
=
new
FileUtils
.
File
(
backupFolderPath
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
bookmarks
.
max_backups
"
0
)
;
let
filePath
=
PathUtils
.
join
(
do_get_tempdir
(
)
.
path
"
backup
.
json
"
)
;
await
PlacesBackups
.
saveBookmarksToJSONFile
(
filePath
)
;
let
files
=
bookmarksBackupDir
.
directoryEntries
;
Assert
.
ok
(
!
files
.
hasMoreElements
(
)
"
Should
have
no
backup
files
.
"
)
;
await
IOUtils
.
remove
(
filePath
)
;
delete
PlacesBackups
.
_backupFiles
;
}
)
;
add_task
(
async
function
test_saveBookmarks_with_backups
(
)
{
let
backupFolderPath
=
await
PlacesBackups
.
getBackupFolder
(
)
;
let
bookmarksBackupDir
=
new
FileUtils
.
File
(
backupFolderPath
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
bookmarks
.
max_backups
"
NUMBER_OF_BACKUPS
)
;
let
filePath
=
PathUtils
.
join
(
do_get_tempdir
(
)
.
path
"
backup
.
json
"
)
;
let
dateObj
=
new
Date
(
)
;
let
dates
=
await
createBackups
(
NUMBER_OF_BACKUPS
dateObj
bookmarksBackupDir
)
;
await
PlacesBackups
.
saveBookmarksToJSONFile
(
filePath
)
;
let
backupPath
=
await
PlacesBackups
.
getMostRecentBackup
(
)
;
Assert
.
ok
(
await
IOUtils
.
read
(
backupPath
{
decompress
:
true
}
)
)
;
dates
.
push
(
dateObj
.
getTime
(
)
)
;
await
checkBackups
(
dates
bookmarksBackupDir
)
;
await
IOUtils
.
remove
(
filePath
)
;
await
cleanupFiles
(
bookmarksBackupDir
)
;
}
)
;
