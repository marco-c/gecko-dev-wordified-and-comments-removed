var
histsvc
=
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
history
-
service
;
1
"
]
.
getService
(
Ci
.
nsINavHistoryService
)
;
var
tagssvc
=
Cc
[
"
mozilla
.
org
/
browser
/
tagging
-
service
;
1
"
]
.
getService
(
Ci
.
nsITaggingService
)
;
const
BOOKMARK_URI
=
uri
(
"
http
:
/
/
example
.
com
/
"
)
;
add_task
(
async
function
test_removing_tagged_bookmark_removes_tag
(
)
{
print
(
"
Make
a
bookmark
.
"
)
;
let
bookmark
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
BOOKMARK_URI
title
:
"
test
bookmark
"
}
)
;
print
(
"
Tag
it
up
.
"
)
;
let
tags
=
[
"
foo
"
"
bar
"
]
;
tagssvc
.
tagURI
(
BOOKMARK_URI
tags
)
;
ensureTagsExist
(
tags
)
;
print
(
"
Remove
the
bookmark
.
The
tags
should
no
longer
exist
.
"
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
bookmark
.
guid
)
;
ensureTagsExist
(
[
]
)
;
}
)
;
add_task
(
async
function
test_removing_folder_containing_tagged_bookmark_removes_tag
(
)
{
print
(
"
Make
a
folder
.
"
)
;
let
folder
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
title
:
"
test
folder
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
)
;
print
(
"
Stick
a
bookmark
in
the
folder
.
"
)
;
var
bookmark
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folder
.
guid
url
:
BOOKMARK_URI
title
:
"
test
bookmark
"
}
)
;
print
(
"
Tag
the
bookmark
.
"
)
;
var
tags
=
[
"
foo
"
"
bar
"
]
;
tagssvc
.
tagURI
(
BOOKMARK_URI
tags
)
;
ensureTagsExist
(
tags
)
;
print
(
"
Remove
the
folder
.
The
tags
should
no
longer
exist
.
"
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
bookmark
.
guid
)
;
ensureTagsExist
(
[
]
)
;
}
)
;
function
ensureTagsExist
(
aTags
)
{
var
query
=
histsvc
.
getNewQuery
(
)
;
var
opts
=
histsvc
.
getNewQueryOptions
(
)
;
opts
.
resultType
=
opts
.
RESULTS_AS_TAG_QUERY
;
var
resultRoot
=
histsvc
.
executeQuery
(
query
opts
)
.
root
;
var
tags
=
aTags
.
slice
(
0
)
;
resultRoot
.
containerOpen
=
true
;
do_check_eq
(
resultRoot
.
childCount
tags
.
length
)
;
for
(
let
i
=
0
;
i
<
resultRoot
.
childCount
;
i
+
+
)
{
var
tag
=
resultRoot
.
getChild
(
i
)
.
title
;
var
indexOfTag
=
tags
.
indexOf
(
tag
)
;
do_check_true
(
indexOfTag
>
=
0
)
;
tags
.
splice
(
indexOfTag
1
)
;
}
resultRoot
.
containerOpen
=
false
;
}
