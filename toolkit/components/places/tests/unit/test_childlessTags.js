var
histsvc
=
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
history
-
service
;
1
"
]
.
getService
(
Ci
.
nsINavHistoryService
)
;
var
tagssvc
=
Cc
[
"
mozilla
.
org
/
browser
/
tagging
-
service
;
1
"
]
.
getService
(
Ci
.
nsITaggingService
)
;
const
BOOKMARK_URI
=
uri
(
"
http
:
/
/
example
.
com
/
"
)
;
add_task
(
async
function
test_removing_tagged_bookmark_removes_tag
(
)
{
print
(
"
Make
a
bookmark
.
"
)
;
let
bookmark
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
BOOKMARK_URI
title
:
"
test
bookmark
"
}
)
;
print
(
"
Tag
it
up
.
"
)
;
let
tags
=
[
"
foo
"
"
bar
"
]
;
tagssvc
.
tagURI
(
BOOKMARK_URI
tags
)
;
ensureTagsExist
(
tags
)
;
let
root
=
getTagRoot
(
)
;
root
.
containerOpen
=
true
;
let
oldCount
=
root
.
childCount
;
root
.
containerOpen
=
false
;
print
(
"
Remove
the
bookmark
.
The
tags
should
no
longer
exist
.
"
)
;
let
wait
=
TestUtils
.
waitForCondition
(
(
)
=
>
{
root
=
getTagRoot
(
)
;
root
.
containerOpen
=
true
;
let
val
=
root
.
childCount
=
=
oldCount
-
2
;
root
.
containerOpen
=
false
;
return
val
;
}
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
bookmark
.
guid
)
;
await
wait
;
ensureTagsExist
(
[
]
)
;
}
)
;
add_task
(
async
function
test_removing_folder_containing_tagged_bookmark_removes_tag
(
)
{
print
(
"
Make
a
folder
.
"
)
;
let
folder
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
title
:
"
test
folder
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
)
;
print
(
"
Stick
a
bookmark
in
the
folder
.
"
)
;
var
bookmark
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folder
.
guid
url
:
BOOKMARK_URI
title
:
"
test
bookmark
"
}
)
;
print
(
"
Tag
the
bookmark
.
"
)
;
var
tags
=
[
"
foo
"
"
bar
"
]
;
tagssvc
.
tagURI
(
BOOKMARK_URI
tags
)
;
ensureTagsExist
(
tags
)
;
let
oldCountFoo
=
await
tagCount
(
"
foo
"
)
;
let
oldCountBar
=
await
tagCount
(
"
bar
"
)
;
print
(
"
Remove
the
folder
.
The
tags
should
no
longer
exist
.
"
)
;
let
wait
=
TestUtils
.
waitForCondition
(
async
(
)
=
>
{
let
newCountFoo
=
await
tagCount
(
"
foo
"
)
;
let
newCountBar
=
await
tagCount
(
"
bar
"
)
;
return
newCountFoo
=
=
oldCountFoo
-
1
&
&
newCountBar
=
=
oldCountBar
-
1
;
}
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
bookmark
.
guid
)
;
await
wait
;
ensureTagsExist
(
[
]
)
;
}
)
;
async
function
tagCount
(
aTag
)
{
let
allTags
=
await
PlacesUtils
.
bookmarks
.
fetchTags
(
)
;
for
(
let
i
of
allTags
)
{
if
(
i
.
name
=
=
aTag
)
{
return
i
.
count
;
}
}
return
0
;
}
function
getTagRoot
(
)
{
var
query
=
histsvc
.
getNewQuery
(
)
;
var
opts
=
histsvc
.
getNewQueryOptions
(
)
;
opts
.
resultType
=
opts
.
RESULTS_AS_TAGS_ROOT
;
var
resultRoot
=
histsvc
.
executeQuery
(
query
opts
)
.
root
;
return
resultRoot
;
}
function
ensureTagsExist
(
aTags
)
{
var
query
=
histsvc
.
getNewQuery
(
)
;
var
opts
=
histsvc
.
getNewQueryOptions
(
)
;
opts
.
resultType
=
opts
.
RESULTS_AS_TAGS_ROOT
;
var
resultRoot
=
histsvc
.
executeQuery
(
query
opts
)
.
root
;
var
tags
=
aTags
.
slice
(
0
)
;
resultRoot
.
containerOpen
=
true
;
Assert
.
equal
(
resultRoot
.
childCount
tags
.
length
)
;
for
(
let
i
=
0
;
i
<
resultRoot
.
childCount
;
i
+
+
)
{
var
tag
=
resultRoot
.
getChild
(
i
)
.
title
;
var
indexOfTag
=
tags
.
indexOf
(
tag
)
;
Assert
.
ok
(
indexOfTag
>
=
0
)
;
tags
.
splice
(
indexOfTag
1
)
;
}
resultRoot
.
containerOpen
=
false
;
}
