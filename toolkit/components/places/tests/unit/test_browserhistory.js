const
TEST_URI
=
NetUtil
.
newURI
(
"
http
:
/
/
mozilla
.
com
/
"
)
;
const
TEST_SUBDOMAIN_URI
=
NetUtil
.
newURI
(
"
http
:
/
/
foobar
.
mozilla
.
com
/
"
)
;
add_task
(
async
function
test_addPage
(
)
{
await
PlacesTestUtils
.
addVisits
(
TEST_URI
)
;
do_check_eq
(
1
PlacesUtils
.
history
.
hasHistoryEntries
)
;
}
)
;
add_task
(
async
function
test_removePage
(
)
{
await
PlacesUtils
.
history
.
remove
(
TEST_URI
)
;
do_check_eq
(
0
PlacesUtils
.
history
.
hasHistoryEntries
)
;
}
)
;
add_task
(
async
function
test_removePages
(
)
{
let
pages
=
[
]
;
for
(
let
i
=
0
;
i
<
8
;
i
+
+
)
{
pages
.
push
(
NetUtil
.
newURI
(
TEST_URI
.
spec
+
i
)
)
;
}
await
PlacesTestUtils
.
addVisits
(
pages
.
map
(
uri
=
>
(
{
uri
}
)
)
)
;
const
ANNO_INDEX
=
1
;
const
ANNO_NAME
=
"
testAnno
"
;
const
ANNO_VALUE
=
"
foo
"
;
const
BOOKMARK_INDEX
=
2
;
PlacesUtils
.
annotations
.
setPageAnnotation
(
pages
[
ANNO_INDEX
]
ANNO_NAME
ANNO_VALUE
0
Ci
.
nsIAnnotationService
.
EXPIRE_NEVER
)
;
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
pages
[
BOOKMARK_INDEX
]
title
:
"
test
bookmark
"
}
)
;
PlacesUtils
.
annotations
.
setPageAnnotation
(
pages
[
BOOKMARK_INDEX
]
ANNO_NAME
ANNO_VALUE
0
Ci
.
nsIAnnotationService
.
EXPIRE_NEVER
)
;
await
PlacesUtils
.
history
.
remove
(
pages
)
;
do_check_eq
(
0
PlacesUtils
.
history
.
hasHistoryEntries
)
;
let
folder
=
await
PlacesUtils
.
getFolderContents
(
PlacesUtils
.
unfiledBookmarksFolderId
)
;
do_check_eq
(
folder
.
root
.
childCount
1
)
;
do_check_eq
(
PlacesUtils
.
annotations
.
getPageAnnotation
(
pages
[
BOOKMARK_INDEX
]
ANNO_NAME
)
ANNO_VALUE
)
;
try
{
PlacesUtils
.
annotations
.
getPageAnnotation
(
pages
[
ANNO_INDEX
]
ANNO_NAME
)
;
do_throw
(
"
did
not
expire
expire_never
anno
on
a
not
bookmarked
item
"
)
;
}
catch
(
ex
)
{
}
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesTestUtils
.
clearHistory
(
)
;
}
)
;
add_task
(
async
function
test_removePagesByTimeframe
(
)
{
let
visits
=
[
]
;
let
startDate
=
(
Date
.
now
(
)
-
10000
)
*
1000
;
for
(
let
i
=
0
;
i
<
10
;
i
+
+
)
{
visits
.
push
(
{
uri
:
NetUtil
.
newURI
(
TEST_URI
.
spec
+
i
)
visitDate
:
startDate
+
i
*
1000
}
)
;
}
await
PlacesTestUtils
.
addVisits
(
visits
)
;
PlacesUtils
.
history
.
removePagesByTimeframe
(
startDate
+
1000
startDate
+
8000
)
;
for
(
let
i
=
0
;
i
<
10
;
i
+
+
)
{
do_check_eq
(
page_in_database
(
NetUtil
.
newURI
(
TEST_URI
.
spec
+
i
)
)
=
=
0
i
>
0
&
&
i
<
9
)
;
}
PlacesUtils
.
history
.
removePagesByTimeframe
(
startDate
startDate
+
9000
)
;
do_check_eq
(
0
PlacesUtils
.
history
.
hasHistoryEntries
)
;
}
)
;
add_task
(
async
function
test_removePagesFromHost
(
)
{
await
PlacesTestUtils
.
addVisits
(
TEST_URI
)
;
PlacesUtils
.
history
.
removePagesFromHost
(
"
mozilla
.
com
"
true
)
;
do_check_eq
(
0
PlacesUtils
.
history
.
hasHistoryEntries
)
;
}
)
;
add_task
(
async
function
test_removePagesFromHost_keepSubdomains
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
TEST_URI
}
{
uri
:
TEST_SUBDOMAIN_URI
}
]
)
;
PlacesUtils
.
history
.
removePagesFromHost
(
"
mozilla
.
com
"
false
)
;
do_check_eq
(
1
PlacesUtils
.
history
.
hasHistoryEntries
)
;
}
)
;
add_task
(
async
function
test_history_clear
(
)
{
await
PlacesTestUtils
.
clearHistory
(
)
;
do_check_eq
(
0
PlacesUtils
.
history
.
hasHistoryEntries
)
;
}
)
;
add_task
(
async
function
test_getObservers
(
)
{
await
PlacesTestUtils
.
addVisits
(
TEST_URI
)
;
do_check_eq
(
1
PlacesUtils
.
history
.
hasHistoryEntries
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
DBConn
(
)
.
executeSimpleSQLAsync
(
"
DELETE
FROM
moz_historyvisits
"
{
handleError
(
error
)
{
reject
(
error
)
;
}
handleResult
(
result
)
{
}
handleCompletion
(
result
)
{
PlacesUtils
.
history
.
getObservers
(
)
;
do_check_eq
(
0
PlacesUtils
.
history
.
hasHistoryEntries
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
)
;
