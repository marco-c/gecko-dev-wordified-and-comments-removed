XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gDownloadHistory
"
"
mozilla
.
org
/
browser
/
download
-
history
;
1
"
"
nsIDownloadHistory
"
)
;
const
DOWNLOAD_URI
=
NetUtil
.
newURI
(
"
http
:
/
/
www
.
example
.
com
/
"
)
;
const
REFERRER_URI
=
NetUtil
.
newURI
(
"
http
:
/
/
www
.
example
.
org
/
"
)
;
const
PRIVATE_URI
=
NetUtil
.
newURI
(
"
http
:
/
/
www
.
example
.
net
/
"
)
;
function
waitForOnVisit
(
aCallback
)
{
function
listener
(
aEvents
)
{
Assert
.
equal
(
aEvents
.
length
1
"
Right
number
of
visits
notified
"
)
;
Assert
.
equal
(
aEvents
[
0
]
.
type
"
page
-
visited
"
)
;
let
{
url
visitId
visitTime
referringVisitId
transitionType
pageGuid
hidden
visitCount
typedCount
lastKnownTitle
}
=
aEvents
[
0
]
;
PlacesObservers
.
removeListener
(
[
"
page
-
visited
"
]
listener
)
;
let
uriArg
=
NetUtil
.
newURI
(
url
)
;
aCallback
(
uriArg
visitId
visitTime
0
referringVisitId
transitionType
pageGuid
hidden
visitCount
typedCount
lastKnownTitle
)
;
}
PlacesObservers
.
addListener
(
[
"
page
-
visited
"
]
listener
)
;
}
function
waitForOnDeleteURI
(
aCallback
)
{
let
historyObserver
=
{
__proto__
:
NavHistoryObserver
.
prototype
onDeleteURI
:
function
HO_onDeleteURI
(
)
{
PlacesUtils
.
history
.
removeObserver
(
this
)
;
aCallback
.
apply
(
null
arguments
)
;
}
}
;
PlacesUtils
.
history
.
addObserver
(
historyObserver
)
;
}
function
waitForOnDeleteVisits
(
aCallback
)
{
let
historyObserver
=
{
__proto__
:
NavHistoryObserver
.
prototype
onDeleteVisits
:
function
HO_onDeleteVisits
(
)
{
PlacesUtils
.
history
.
removeObserver
(
this
)
;
aCallback
.
apply
(
null
arguments
)
;
}
}
;
PlacesUtils
.
history
.
addObserver
(
historyObserver
)
;
}
add_test
(
function
test_dh_is_from_places
(
)
{
Assert
.
ok
(
gDownloadHistory
instanceof
Ci
.
mozIAsyncHistory
)
;
run_next_test
(
)
;
}
)
;
add_test
(
function
test_dh_addRemoveDownload
(
)
{
waitForOnVisit
(
function
DHAD_onVisit
(
aURI
)
{
Assert
.
ok
(
aURI
.
equals
(
DOWNLOAD_URI
)
)
;
Assert
.
ok
(
!
!
page_in_database
(
DOWNLOAD_URI
)
)
;
waitForOnDeleteURI
(
function
DHRAD_onDeleteURI
(
aDeletedURI
)
{
Assert
.
ok
(
aDeletedURI
.
equals
(
DOWNLOAD_URI
)
)
;
Assert
.
ok
(
!
page_in_database
(
DOWNLOAD_URI
)
)
;
run_next_test
(
)
;
}
)
;
gDownloadHistory
.
removeAllDownloads
(
)
;
}
)
;
gDownloadHistory
.
addDownload
(
DOWNLOAD_URI
null
Date
.
now
(
)
*
1000
)
;
}
)
;
add_test
(
function
test_dh_addMultiRemoveDownload
(
)
{
PlacesTestUtils
.
addVisits
(
{
uri
:
DOWNLOAD_URI
transition
:
TRANSITION_TYPED
}
)
.
then
(
function
(
)
{
waitForOnVisit
(
function
DHAD_onVisit
(
aURI
)
{
Assert
.
ok
(
aURI
.
equals
(
DOWNLOAD_URI
)
)
;
Assert
.
ok
(
!
!
page_in_database
(
DOWNLOAD_URI
)
)
;
waitForOnDeleteVisits
(
function
DHRAD_onDeleteVisits
(
aDeletedURI
)
{
Assert
.
ok
(
aDeletedURI
.
equals
(
DOWNLOAD_URI
)
)
;
Assert
.
ok
(
!
!
page_in_database
(
DOWNLOAD_URI
)
)
;
PlacesUtils
.
history
.
clear
(
)
.
then
(
run_next_test
)
;
}
)
;
gDownloadHistory
.
removeAllDownloads
(
)
;
}
)
;
gDownloadHistory
.
addDownload
(
DOWNLOAD_URI
null
Date
.
now
(
)
*
1000
)
;
}
)
;
}
)
;
add_task
(
async
function
test_dh_addBookmarkRemoveDownload
(
)
{
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
DOWNLOAD_URI
title
:
"
A
bookmark
"
}
)
;
await
new
Promise
(
resolve
=
>
{
waitForOnVisit
(
function
DHAD_onVisit
(
aURI
)
{
Assert
.
ok
(
aURI
.
equals
(
DOWNLOAD_URI
)
)
;
Assert
.
ok
(
!
!
page_in_database
(
DOWNLOAD_URI
)
)
;
waitForOnDeleteVisits
(
function
DHRAD_onDeleteVisits
(
aDeletedURI
)
{
Assert
.
ok
(
aDeletedURI
.
equals
(
DOWNLOAD_URI
)
)
;
Assert
.
ok
(
!
!
page_in_database
(
DOWNLOAD_URI
)
)
;
PlacesUtils
.
history
.
clear
(
)
.
then
(
resolve
)
;
}
)
;
gDownloadHistory
.
removeAllDownloads
(
)
;
}
)
;
gDownloadHistory
.
addDownload
(
DOWNLOAD_URI
null
Date
.
now
(
)
*
1000
)
;
}
)
;
}
)
;
add_task
(
async
function
test_dh_addDownload_referrer
(
)
{
let
visitId
;
let
referrerPromise
=
PlacesTestUtils
.
waitForNotification
(
"
page
-
visited
"
visits
=
>
{
visitId
=
visits
[
0
]
.
visitId
;
let
{
url
}
=
visits
[
0
]
;
return
url
=
=
REFERRER_URI
.
spec
;
}
"
places
"
)
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
REFERRER_URI
transition
:
Ci
.
nsINavHistoryService
.
TRANSITION_TYPED
}
]
)
;
await
referrerPromise
;
Assert
.
ok
(
!
!
PlacesTestUtils
.
isPageInDB
(
REFERRER_URI
)
)
;
Assert
.
equal
(
visitId
1
)
;
let
referrerId
;
let
downloadPromise
=
PlacesTestUtils
.
waitForNotification
(
"
page
-
visited
"
visits
=
>
{
referrerId
=
visits
[
0
]
.
referringVisitId
;
let
{
url
}
=
visits
[
0
]
;
return
url
=
=
DOWNLOAD_URI
.
spec
;
}
"
places
"
)
;
gDownloadHistory
.
addDownload
(
DOWNLOAD_URI
REFERRER_URI
Date
.
now
(
)
*
1000
)
;
await
downloadPromise
;
Assert
.
ok
(
!
!
PlacesTestUtils
.
isPageInDB
(
DOWNLOAD_URI
)
)
;
Assert
.
equal
(
visitId
referrerId
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_test
(
function
test_dh_addDownload_disabledHistory
(
)
{
waitForOnVisit
(
function
DHAD_onVisit
(
aURI
)
{
Assert
.
ok
(
aURI
.
equals
(
DOWNLOAD_URI
)
)
;
Assert
.
ok
(
!
!
page_in_database
(
DOWNLOAD_URI
)
)
;
Assert
.
ok
(
!
page_in_database
(
PRIVATE_URI
)
)
;
PlacesUtils
.
history
.
clear
(
)
.
then
(
run_next_test
)
;
}
)
;
Services
.
prefs
.
setBoolPref
(
"
places
.
history
.
enabled
"
false
)
;
gDownloadHistory
.
addDownload
(
PRIVATE_URI
REFERRER_URI
Date
.
now
(
)
*
1000
)
;
Services
.
prefs
.
setBoolPref
(
"
places
.
history
.
enabled
"
true
)
;
gDownloadHistory
.
addDownload
(
DOWNLOAD_URI
REFERRER_URI
Date
.
now
(
)
*
1000
)
;
}
)
;
add_test
(
function
test_dh_details
(
)
{
const
REMOTE_URI
=
NetUtil
.
newURI
(
"
http
:
/
/
localhost
/
"
)
;
const
SOURCE_URI
=
NetUtil
.
newURI
(
"
http
:
/
/
example
.
com
/
test_dh_details
"
)
;
const
DEST_FILE_NAME
=
"
dest
.
txt
"
;
let
destFileUri
=
NetUtil
.
newURI
(
FileUtils
.
getFile
(
"
TmpD
"
[
DEST_FILE_NAME
]
)
)
;
let
titleSet
=
false
;
let
destinationFileUriSet
=
false
;
function
checkFinished
(
)
{
if
(
titleSet
&
&
destinationFileUriSet
)
{
PlacesUtils
.
annotations
.
removeObserver
(
annoObserver
)
;
PlacesUtils
.
history
.
removeObserver
(
historyObserver
)
;
PlacesUtils
.
history
.
clear
(
)
.
then
(
run_next_test
)
;
}
}
let
annoObserver
=
{
onPageAnnotationSet
:
function
AO_onPageAnnotationSet
(
aPage
aName
)
{
if
(
aPage
.
equals
(
SOURCE_URI
)
)
{
let
value
=
PlacesUtils
.
annotations
.
getPageAnnotation
(
aPage
aName
)
;
switch
(
aName
)
{
case
"
downloads
/
destinationFileURI
"
:
destinationFileUriSet
=
true
;
Assert
.
equal
(
value
destFileUri
.
spec
)
;
break
;
}
checkFinished
(
)
;
}
}
onItemAnnotationSet
(
)
{
}
onPageAnnotationRemoved
(
)
{
}
onItemAnnotationRemoved
(
)
{
}
}
;
let
historyObserver
=
{
onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
(
)
{
}
onTitleChanged
:
function
HO_onTitleChanged
(
aURI
aPageTitle
)
{
if
(
aURI
.
equals
(
SOURCE_URI
)
)
{
titleSet
=
true
;
Assert
.
equal
(
aPageTitle
DEST_FILE_NAME
)
;
checkFinished
(
)
;
}
}
onDeleteURI
(
)
{
}
onClearHistory
(
)
{
}
onPageChanged
(
)
{
}
onDeleteVisits
(
)
{
}
}
;
PlacesUtils
.
annotations
.
addObserver
(
annoObserver
)
;
PlacesUtils
.
history
.
addObserver
(
historyObserver
)
;
gDownloadHistory
.
addDownload
(
SOURCE_URI
null
Date
.
now
(
)
*
1000
)
;
gDownloadHistory
.
addDownload
(
SOURCE_URI
null
Date
.
now
(
)
*
1000
null
)
;
gDownloadHistory
.
addDownload
(
SOURCE_URI
null
Date
.
now
(
)
*
1000
REMOTE_URI
)
;
gDownloadHistory
.
addDownload
(
SOURCE_URI
null
Date
.
now
(
)
*
1000
destFileUri
)
;
}
)
;
