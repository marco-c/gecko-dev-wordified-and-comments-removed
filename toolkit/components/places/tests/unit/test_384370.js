var
tagData
=
[
{
uri
:
uri
(
"
http
:
/
/
slint
.
us
"
)
tags
:
[
"
indie
"
"
kentucky
"
"
music
"
]
}
{
uri
:
uri
(
"
http
:
/
/
en
.
wikipedia
.
org
/
wiki
/
Diplodocus
"
)
tags
:
[
"
dinosaur
"
"
dj
"
"
rad
word
"
]
}
]
;
var
bookmarkData
=
[
{
uri
:
uri
(
"
http
:
/
/
slint
.
us
"
)
title
:
"
indie
kentucky
music
"
}
{
uri
:
uri
(
"
http
:
/
/
en
.
wikipedia
.
org
/
wiki
/
Diplodocus
"
)
title
:
"
dinosaur
dj
rad
word
"
}
]
;
add_task
(
async
function
(
)
{
let
jsonFile
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
bookmarks
.
exported
.
json
"
)
;
if
(
(
await
OS
.
File
.
exists
(
jsonFile
)
)
)
await
OS
.
File
.
remove
(
jsonFile
)
;
let
htmlFile
=
OS
.
Path
.
join
(
do_get_cwd
(
)
.
path
"
bookmarks
.
preplaces
.
html
"
)
;
await
BookmarkHTMLUtils
.
importFromFile
(
htmlFile
{
replace
:
true
}
)
;
for
(
let
{
uri
tags
}
of
tagData
)
{
PlacesUtils
.
tagging
.
tagURI
(
uri
tags
)
;
}
for
(
let
{
uri
title
}
of
bookmarkData
)
{
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
uri
title
}
)
;
}
for
(
let
{
uri
title
}
of
bookmarkData
)
{
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
url
:
uri
title
}
)
;
}
await
validate
(
"
initial
database
"
)
;
await
BookmarkJSONUtils
.
exportToFile
(
jsonFile
)
;
info
(
"
exported
json
"
)
;
await
BookmarkJSONUtils
.
importFromFile
(
jsonFile
{
replace
:
true
}
)
;
info
(
"
imported
json
"
)
;
await
validate
(
"
re
-
imported
json
"
)
;
info
(
"
validated
import
"
)
;
}
)
;
async
function
validate
(
infoMsg
)
{
info
(
Validating
{
infoMsg
}
:
testMenuBookmarks
)
;
await
testMenuBookmarks
(
)
;
info
(
Validating
{
infoMsg
}
:
testToolbarBookmarks
)
;
await
testToolbarBookmarks
(
)
;
info
(
Validating
{
infoMsg
}
:
testUnfiledBookmarks
)
;
testUnfiledBookmarks
(
)
;
info
(
Validating
{
infoMsg
}
:
testTags
)
;
testTags
(
)
;
await
PlacesTestUtils
.
promiseAsyncUpdates
(
)
;
}
async
function
testMenuBookmarks
(
)
{
let
root
=
PlacesUtils
.
getFolderContents
(
PlacesUtils
.
bookmarks
.
menuGuid
)
.
root
;
Assert
.
equal
(
root
.
childCount
3
)
;
let
separatorNode
=
root
.
getChild
(
1
)
;
Assert
.
equal
(
separatorNode
.
type
separatorNode
.
RESULT_TYPE_SEPARATOR
)
;
let
folderNode
=
root
.
getChild
(
2
)
;
Assert
.
equal
(
folderNode
.
type
folderNode
.
RESULT_TYPE_FOLDER
)
;
Assert
.
equal
(
folderNode
.
title
"
test
"
)
;
let
folder
=
await
PlacesUtils
.
bookmarks
.
fetch
(
folderNode
.
bookmarkGuid
)
;
Assert
.
equal
(
folder
.
dateAdded
.
getTime
(
)
1177541020000
)
;
Assert
.
equal
(
PlacesUtils
.
asQuery
(
folderNode
)
.
hasChildren
true
)
;
folderNode
.
containerOpen
=
true
;
Assert
.
equal
(
folderNode
.
childCount
1
)
;
let
bookmarkNode
=
folderNode
.
getChild
(
0
)
;
Assert
.
equal
(
"
http
:
/
/
test
/
post
"
bookmarkNode
.
uri
)
;
Assert
.
equal
(
"
test
post
keyword
"
bookmarkNode
.
title
)
;
Assert
.
equal
(
bookmarkNode
.
dateAdded
1177375336000000
)
;
let
entry
=
await
PlacesUtils
.
keywords
.
fetch
(
{
url
:
bookmarkNode
.
uri
}
)
;
Assert
.
equal
(
"
test
"
entry
.
keyword
)
;
Assert
.
equal
(
"
hidden1
%
3Dbar
&
text1
%
3D
%
25s
"
entry
.
postData
)
;
let
pageInfo
=
await
PlacesUtils
.
history
.
fetch
(
bookmarkNode
.
uri
{
includeAnnotations
:
true
}
)
;
Assert
.
equal
(
pageInfo
.
annotations
.
get
(
PlacesUtils
.
CHARSET_ANNO
)
"
ISO
-
8859
-
1
"
"
Should
have
the
correct
charset
"
)
;
folderNode
.
containerOpen
=
false
;
root
.
containerOpen
=
false
;
}
async
function
testToolbarBookmarks
(
)
{
let
root
=
PlacesUtils
.
getFolderContents
(
PlacesUtils
.
bookmarks
.
toolbarGuid
)
.
root
;
Assert
.
equal
(
root
.
childCount
bookmarkData
.
length
+
3
)
;
let
livemarkNode
=
root
.
getChild
(
1
)
;
Assert
.
equal
(
"
Latest
Headlines
"
livemarkNode
.
title
)
;
let
livemark
=
await
PlacesUtils
.
livemarks
.
getLivemark
(
{
id
:
livemarkNode
.
itemId
}
)
;
Assert
.
equal
(
"
http
:
/
/
en
-
us
.
fxfeeds
.
mozilla
.
com
/
en
-
US
/
firefox
/
livebookmarks
/
"
livemark
.
siteURI
.
spec
)
;
Assert
.
equal
(
"
http
:
/
/
en
-
us
.
fxfeeds
.
mozilla
.
com
/
en
-
US
/
firefox
/
headlines
.
xml
"
livemark
.
feedURI
.
spec
)
;
livemarkNode
=
root
.
getChild
(
2
)
;
Assert
.
equal
(
"
Latest
Headlines
No
Site
"
livemarkNode
.
title
)
;
livemark
=
await
PlacesUtils
.
livemarks
.
getLivemark
(
{
id
:
livemarkNode
.
itemId
}
)
;
Assert
.
equal
(
null
livemark
.
siteURI
)
;
Assert
.
equal
(
"
http
:
/
/
en
-
us
.
fxfeeds
.
mozilla
.
com
/
en
-
US
/
firefox
/
headlines
.
xml
"
livemark
.
feedURI
.
spec
)
;
let
bookmarkNode
=
root
.
getChild
(
3
)
;
Assert
.
equal
(
bookmarkNode
.
uri
bookmarkData
[
0
]
.
uri
.
spec
)
;
Assert
.
equal
(
bookmarkNode
.
title
bookmarkData
[
0
]
.
title
)
;
bookmarkNode
=
root
.
getChild
(
4
)
;
Assert
.
equal
(
bookmarkNode
.
uri
bookmarkData
[
1
]
.
uri
.
spec
)
;
Assert
.
equal
(
bookmarkNode
.
title
bookmarkData
[
1
]
.
title
)
;
root
.
containerOpen
=
false
;
}
function
testUnfiledBookmarks
(
)
{
let
root
=
PlacesUtils
.
getFolderContents
(
PlacesUtils
.
bookmarks
.
unfiledGuid
)
.
root
;
Assert
.
equal
(
root
.
childCount
bookmarkData
.
length
+
1
)
;
for
(
let
i
=
1
;
i
<
root
.
childCount
;
+
+
i
)
{
let
child
=
root
.
getChild
(
i
)
;
Assert
.
equal
(
child
.
uri
bookmarkData
[
i
-
1
]
.
uri
.
spec
)
;
Assert
.
equal
(
child
.
title
bookmarkData
[
i
-
1
]
.
title
)
;
if
(
child
.
tags
)
Assert
.
equal
(
child
.
tags
bookmarkData
[
i
-
1
]
.
title
)
;
}
root
.
containerOpen
=
false
;
}
function
testTags
(
)
{
for
(
let
{
uri
tags
}
of
tagData
)
{
info
(
"
Test
tags
for
"
+
uri
.
spec
+
"
:
"
+
tags
+
"
\
n
"
)
;
let
foundTags
=
PlacesUtils
.
tagging
.
getTagsForURI
(
uri
)
;
Assert
.
equal
(
foundTags
.
length
tags
.
length
)
;
Assert
.
ok
(
tags
.
every
(
tag
=
>
foundTags
.
includes
(
tag
)
)
)
;
}
}
