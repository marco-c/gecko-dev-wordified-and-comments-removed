try
{
var
histsvc
=
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
history
-
service
;
1
"
]
.
getService
(
Ci
.
nsINavHistoryService
)
;
}
catch
(
ex
)
{
do_throw
(
"
Could
not
get
services
\
n
"
)
;
}
var
bucketPrefs
=
[
[
"
firstBucketCutoff
"
"
firstBucketWeight
"
]
[
"
secondBucketCutoff
"
"
secondBucketWeight
"
]
[
"
thirdBucketCutoff
"
"
thirdBucketWeight
"
]
[
"
fourthBucketCutoff
"
"
fourthBucketWeight
"
]
[
null
"
defaultBucketWeight
"
]
]
;
var
bonusPrefs
=
{
embedVisitBonus
:
Ci
.
nsINavHistoryService
.
TRANSITION_EMBED
framedLinkVisitBonus
:
Ci
.
nsINavHistoryService
.
TRANSITION_FRAMED_LINK
linkVisitBonus
:
Ci
.
nsINavHistoryService
.
TRANSITION_LINK
typedVisitBonus
:
Ci
.
nsINavHistoryService
.
TRANSITION_TYPED
bookmarkVisitBonus
:
Ci
.
nsINavHistoryService
.
TRANSITION_BOOKMARK
downloadVisitBonus
:
Ci
.
nsINavHistoryService
.
TRANSITION_DOWNLOAD
permRedirectVisitBonus
:
Ci
.
nsINavHistoryService
.
TRANSITION_REDIRECT_PERMANENT
tempRedirectVisitBonus
:
Ci
.
nsINavHistoryService
.
TRANSITION_REDIRECT_TEMPORARY
reloadVisitBonus
:
Ci
.
nsINavHistoryService
.
TRANSITION_RELOAD
}
;
var
searchTerm
=
"
frecency
"
;
var
results
=
[
]
;
var
now
=
Date
.
now
(
)
;
var
prefPrefix
=
"
places
.
frecency
.
"
;
async
function
task_initializeBucket
(
bucket
)
{
let
[
cutoffName
weightName
]
=
bucket
;
var
weight
=
Services
.
prefs
.
getIntPref
(
prefPrefix
+
weightName
0
)
;
var
cutoff
=
Services
.
prefs
.
getIntPref
(
prefPrefix
+
cutoffName
0
)
;
if
(
cutoff
<
1
)
{
return
;
}
var
dateInPeriod
=
(
now
-
(
cutoff
-
1
)
*
86400
*
1000
)
*
1000
;
for
(
let
[
bonusName
visitType
]
of
Object
.
entries
(
bonusPrefs
)
)
{
var
frecency
=
-
1
;
var
calculatedURI
=
null
;
var
matchTitle
=
"
"
;
var
bonusValue
=
Services
.
prefs
.
getIntPref
(
prefPrefix
+
bonusName
)
;
if
(
bonusName
=
=
"
unvisitedBookmarkBonus
"
|
|
bonusName
=
=
"
unvisitedTypedBonus
"
)
{
if
(
cutoffName
=
=
"
firstBucketCutoff
"
)
{
let
points
=
Math
.
ceil
(
(
bonusValue
/
parseFloat
(
100
.
0
)
)
*
weight
)
;
var
visitCount
=
1
;
frecency
=
Math
.
ceil
(
visitCount
*
points
)
;
calculatedURI
=
uri
(
"
http
:
/
/
"
+
searchTerm
+
"
.
com
/
"
+
bonusName
+
"
:
"
+
bonusValue
+
"
/
cutoff
:
"
+
cutoff
+
"
/
weight
:
"
+
weight
+
"
/
frecency
:
"
+
frecency
)
;
if
(
bonusName
=
=
"
unvisitedBookmarkBonus
"
)
{
matchTitle
=
searchTerm
+
"
UnvisitedBookmark
"
;
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
calculatedURI
title
:
matchTitle
}
)
;
}
else
{
matchTitle
=
searchTerm
+
"
UnvisitedTyped
"
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
calculatedURI
title
:
matchTitle
transition
:
visitType
visitDate
:
now
}
)
;
histsvc
.
markPageAsTyped
(
calculatedURI
)
;
}
}
}
else
{
if
(
visitType
=
=
Ci
.
nsINavHistoryService
.
TRANSITION_BOOKMARK
)
{
bonusValue
=
bonusValue
*
2
;
}
let
points
=
Math
.
ceil
(
(
1
*
(
(
bonusValue
/
parseFloat
(
100
.
0
)
)
.
toFixed
(
6
)
*
weight
)
)
/
1
)
;
if
(
!
points
)
{
if
(
visitType
=
=
Ci
.
nsINavHistoryService
.
TRANSITION_EMBED
|
|
visitType
=
=
Ci
.
nsINavHistoryService
.
TRANSITION_FRAMED_LINK
|
|
visitType
=
=
Ci
.
nsINavHistoryService
.
TRANSITION_DOWNLOAD
|
|
visitType
=
=
Ci
.
nsINavHistoryService
.
TRANSITION_RELOAD
|
|
bonusName
=
=
"
defaultVisitBonus
"
)
{
frecency
=
0
;
}
else
{
frecency
=
-
1
;
}
}
else
{
frecency
=
points
;
}
calculatedURI
=
uri
(
"
http
:
/
/
"
+
searchTerm
+
"
.
com
/
"
+
bonusName
+
"
:
"
+
bonusValue
+
"
/
cutoff
:
"
+
cutoff
+
"
/
weight
:
"
+
weight
+
"
/
frecency
:
"
+
frecency
)
;
if
(
visitType
=
=
Ci
.
nsINavHistoryService
.
TRANSITION_BOOKMARK
)
{
matchTitle
=
searchTerm
+
"
Bookmarked
"
;
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
calculatedURI
title
:
matchTitle
}
)
;
}
else
{
matchTitle
=
calculatedURI
.
spec
.
substr
(
calculatedURI
.
spec
.
lastIndexOf
(
"
/
"
)
+
1
)
;
}
await
PlacesTestUtils
.
addVisits
(
{
uri
:
calculatedURI
transition
:
visitType
visitDate
:
dateInPeriod
}
)
;
}
if
(
calculatedURI
&
&
frecency
)
{
results
.
push
(
[
calculatedURI
frecency
matchTitle
]
)
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
calculatedURI
title
:
matchTitle
transition
:
visitType
visitDate
:
dateInPeriod
}
)
;
}
}
}
function
AutoCompleteInput
(
aSearches
)
{
this
.
searches
=
aSearches
;
}
AutoCompleteInput
.
prototype
=
{
constructor
:
AutoCompleteInput
searches
:
null
minResultsForPopup
:
0
timeout
:
10
searchParam
:
"
"
textValue
:
"
"
disableAutoComplete
:
false
completeDefaultIndex
:
false
get
searchCount
(
)
{
return
this
.
searches
.
length
;
}
getSearchAt
(
aIndex
)
{
return
this
.
searches
[
aIndex
]
;
}
onSearchBegin
(
)
{
}
onSearchComplete
(
)
{
}
popupOpen
:
false
popup
:
{
setSelectedIndex
(
aIndex
)
{
}
invalidate
(
)
{
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIAutoCompletePopup
"
]
)
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIAutoCompleteInput
"
]
)
}
;
add_task
(
async
function
test_frecency
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
autoFill
"
false
)
;
registerCleanupFunction
(
(
)
=
>
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
autoFill
"
)
)
;
for
(
let
bucket
of
bucketPrefs
)
{
await
task_initializeBucket
(
bucket
)
;
}
results
.
sort
(
(
a
b
)
=
>
b
[
1
]
-
a
[
1
]
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
urlbar
.
maxRichResults
"
results
.
length
)
;
await
PlacesTestUtils
.
promiseAsyncUpdates
(
)
;
var
controller
=
Cc
[
"
mozilla
.
org
/
autocomplete
/
controller
;
1
"
]
.
getService
(
Ci
.
nsIAutoCompleteController
)
;
var
input
=
new
AutoCompleteInput
(
[
"
unifiedcomplete
"
]
)
;
controller
.
input
=
input
;
Services
.
prefs
.
setIntPref
(
"
browser
.
urlbar
.
search
.
sources
"
3
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
urlbar
.
default
.
behavior
"
0
)
;
var
numSearchesStarted
=
0
;
input
.
onSearchBegin
=
function
(
)
{
numSearchesStarted
+
+
;
Assert
.
equal
(
numSearchesStarted
1
)
;
}
;
await
new
Promise
(
resolve
=
>
{
input
.
onSearchComplete
=
function
(
)
{
Assert
.
equal
(
numSearchesStarted
1
)
;
Assert
.
equal
(
controller
.
searchStatus
Ci
.
nsIAutoCompleteController
.
STATUS_COMPLETE_MATCH
)
;
Assert
.
equal
(
controller
.
matchCount
results
.
length
)
;
for
(
var
i
=
0
;
i
<
controller
.
matchCount
;
i
+
+
)
{
let
searchURL
=
controller
.
getValueAt
(
i
)
;
let
expectURL
=
results
[
i
]
[
0
]
.
spec
;
if
(
searchURL
=
=
expectURL
)
{
Assert
.
equal
(
controller
.
getValueAt
(
i
)
results
[
i
]
[
0
]
.
spec
)
;
Assert
.
equal
(
controller
.
getCommentAt
(
i
)
results
[
i
]
[
2
]
)
;
}
else
{
let
getFrecency
=
aURL
=
>
aURL
.
match
(
/
frecency
:
(
-
?
\
d
+
)
/
)
[
1
]
;
print
(
"
#
#
#
checking
for
same
frecency
between
'
"
+
searchURL
+
"
'
and
'
"
+
expectURL
+
"
'
"
)
;
Assert
.
equal
(
getFrecency
(
searchURL
)
getFrecency
(
expectURL
)
)
;
}
}
resolve
(
)
;
}
;
controller
.
startSearch
(
searchTerm
)
;
}
)
;
}
)
;
