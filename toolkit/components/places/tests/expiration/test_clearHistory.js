add_task
(
async
function
test_historyClear
(
)
{
let
as
=
PlacesUtils
.
annotations
;
setInterval
(
3600
)
;
setMaxPages
(
0
)
;
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
let
pageURI
=
uri
(
"
http
:
/
/
item_anno
.
"
+
i
+
"
.
mozilla
.
org
/
"
)
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
pageURI
}
)
;
let
bm
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
pageURI
title
:
null
}
)
;
let
id
=
await
PlacesUtils
.
promiseItemId
(
bm
.
guid
)
;
as
.
setItemAnnotation
(
id
"
persist
"
"
test
"
0
as
.
EXPIRE_NEVER
)
;
await
PlacesUtils
.
history
.
update
(
{
url
:
pageURI
annotations
:
new
Map
(
[
[
"
persist
"
"
test
"
]
]
)
}
)
;
}
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
let
pageURI
=
uri
(
"
http
:
/
/
page_anno
.
"
+
i
+
"
.
mozilla
.
org
/
"
)
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
pageURI
}
)
;
await
PlacesUtils
.
history
.
update
(
{
url
:
pageURI
annotations
:
new
Map
(
[
[
"
expire
"
"
test
"
]
]
)
}
)
;
}
await
PlacesUtils
.
history
.
clear
(
)
;
Assert
.
equal
(
(
await
getPagesWithAnnotation
(
"
expire
"
)
)
.
length
0
)
;
let
pages
=
await
getPagesWithAnnotation
(
"
persist
"
)
;
Assert
.
equal
(
pages
.
length
5
)
;
let
items
=
await
getItemsWithAnnotation
(
"
persist
"
)
;
Assert
.
equal
(
items
.
length
5
)
;
for
(
let
guid
of
items
)
{
Assert
.
ok
(
await
PlacesUtils
.
bookmarks
.
fetch
(
{
guid
}
)
"
item
exists
"
)
;
}
}
)
;
