var
gNow
=
getExpirablePRTime
(
60
)
;
add_task
(
async
function
test_expire_orphans
(
)
{
await
PlacesTestUtils
.
addVisits
(
{
uri
:
uri
(
"
http
:
/
/
page1
.
mozilla
.
org
/
"
)
visitDate
:
gNow
+
+
}
)
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
uri
(
"
http
:
/
/
page2
.
mozilla
.
org
/
"
)
visitDate
:
gNow
+
+
}
)
;
let
bm
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
"
http
:
/
/
page3
.
mozilla
.
org
/
"
title
:
"
"
}
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
bm
)
;
await
promiseForceExpirationStep
(
0
)
;
Assert
.
equal
(
visits_in_database
(
"
http
:
/
/
page1
.
mozilla
.
org
/
"
)
1
)
;
Assert
.
equal
(
visits_in_database
(
"
http
:
/
/
page2
.
mozilla
.
org
/
"
)
1
)
;
Assert
.
ok
(
!
page_in_database
(
"
http
:
/
/
page3
.
mozilla
.
org
/
"
)
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_task
(
async
function
test_expire_orphans_optionalarg
(
)
{
await
PlacesTestUtils
.
addVisits
(
{
uri
:
uri
(
"
http
:
/
/
page1
.
mozilla
.
org
/
"
)
visitDate
:
gNow
+
+
}
)
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
uri
(
"
http
:
/
/
page2
.
mozilla
.
org
/
"
)
visitDate
:
gNow
+
+
}
)
;
let
bm
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
"
http
:
/
/
page3
.
mozilla
.
org
/
"
title
:
"
"
}
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
bm
)
;
await
promiseForceExpirationStep
(
)
;
Assert
.
equal
(
visits_in_database
(
"
http
:
/
/
page1
.
mozilla
.
org
/
"
)
1
)
;
Assert
.
equal
(
visits_in_database
(
"
http
:
/
/
page2
.
mozilla
.
org
/
"
)
1
)
;
Assert
.
ok
(
!
page_in_database
(
"
http
:
/
/
page3
.
mozilla
.
org
/
"
)
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_task
(
async
function
test_expire_limited
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
old
.
mozilla
.
org
/
"
visitDate
:
gNow
+
+
}
{
uri
:
"
http
:
/
/
new
.
mozilla
.
org
/
"
visitDate
:
gNow
+
+
}
]
)
;
await
promiseForceExpirationStep
(
1
)
;
Assert
.
equal
(
visits_in_database
(
"
http
:
/
/
new
.
mozilla
.
org
/
"
)
1
)
;
Assert
.
ok
(
!
page_in_database
(
"
http
:
/
/
old
.
mozilla
.
org
/
"
)
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_task
(
async
function
test_expire_limited_longurl
(
)
{
let
longurl
=
"
http
:
/
/
long
.
mozilla
.
org
/
"
+
"
a
"
.
repeat
(
232
)
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
old
.
mozilla
.
org
/
"
visitDate
:
gNow
+
+
}
{
uri
:
longurl
visitDate
:
gNow
+
+
}
{
uri
:
longurl
visitDate
:
getExpirablePRTime
(
58
)
}
]
)
;
await
promiseForceExpirationStep
(
1
)
;
Assert
.
equal
(
visits_in_database
(
longurl
)
1
)
;
Assert
.
ok
(
!
page_in_database
(
"
http
:
/
/
old
.
mozilla
.
org
/
"
)
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_task
(
async
function
test_expire_limited_exoticurl
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
old
.
mozilla
.
org
/
"
visitDate
:
gNow
+
+
}
{
uri
:
"
http
:
/
/
download
.
mozilla
.
org
"
visitDate
:
gNow
+
+
transition
:
7
}
{
uri
:
"
http
:
/
/
nonexpirable
-
download
.
mozilla
.
org
"
visitDate
:
getExpirablePRTime
(
58
)
transition
:
7
}
]
)
;
await
promiseForceExpirationStep
(
1
)
;
Assert
.
equal
(
visits_in_database
(
"
http
:
/
/
nonexpirable
-
download
.
mozilla
.
org
/
"
)
1
)
;
Assert
.
equal
(
visits_in_database
(
"
http
:
/
/
download
.
mozilla
.
org
/
"
)
0
)
;
Assert
.
ok
(
!
page_in_database
(
"
http
:
/
/
old
.
mozilla
.
org
/
"
)
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_task
(
async
function
test_expire_unlimited
(
)
{
let
longurl
=
"
http
:
/
/
long
.
mozilla
.
org
/
"
+
"
a
"
.
repeat
(
232
)
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
old
.
mozilla
.
org
/
"
visitDate
:
gNow
+
+
}
{
uri
:
"
http
:
/
/
new
.
mozilla
.
org
/
"
visitDate
:
gNow
+
+
}
{
uri
:
"
http
:
/
/
download
.
mozilla
.
org
/
"
visitDate
:
gNow
+
+
transition
:
PlacesUtils
.
history
.
TRANSITION_DOWNLOAD
}
{
uri
:
longurl
visitDate
:
gNow
+
+
}
{
uri
:
"
http
:
/
/
nonexpirable
.
mozilla
.
org
/
"
visitDate
:
getExpirablePRTime
(
5
)
}
{
uri
:
"
http
:
/
/
nonexpirable
-
download
.
mozilla
.
org
/
"
visitDate
:
getExpirablePRTime
(
5
)
transition
:
PlacesUtils
.
history
.
TRANSITION_DOWNLOAD
}
{
uri
:
longurl
visitDate
:
getExpirablePRTime
(
5
)
}
]
)
;
await
promiseForceExpirationStep
(
-
1
)
;
Assert
.
equal
(
visits_in_database
(
"
http
:
/
/
nonexpirable
.
mozilla
.
org
/
"
)
1
)
;
Assert
.
equal
(
visits_in_database
(
"
http
:
/
/
nonexpirable
-
download
.
mozilla
.
org
/
"
)
1
)
;
Assert
.
equal
(
visits_in_database
(
longurl
)
1
)
;
Assert
.
ok
(
!
page_in_database
(
"
http
:
/
/
old
.
mozilla
.
org
/
"
)
)
;
Assert
.
ok
(
!
page_in_database
(
"
http
:
/
/
download
.
mozilla
.
org
/
"
)
)
;
Assert
.
ok
(
!
page_in_database
(
"
http
:
/
/
new
.
mozilla
.
org
/
"
)
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_task
(
async
function
test_expire_icons
(
)
{
const
dataUrl
=
"
data
:
image
/
png
;
base64
iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAA
"
+
"
AAAA6fptVAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg
=
=
"
;
const
entries
=
[
{
desc
:
"
Expired
because
it
redirects
"
page
:
"
http
:
/
/
source
.
old
.
org
/
"
icon
:
"
http
:
/
/
source
.
old
.
org
/
test_icon
.
png
"
expire
:
new
Date
(
)
.
setYear
(
2018
)
*
1000
redirect
:
"
http
:
/
/
dest
.
old
.
org
/
"
removed
:
true
}
{
desc
:
"
Not
expired
because
recent
"
page
:
"
http
:
/
/
source
.
new
.
org
/
"
icon
:
"
http
:
/
/
source
.
new
.
org
/
test_icon
.
png
"
expire
:
0
redirect
:
"
http
:
/
/
dest
.
new
.
org
/
"
removed
:
false
}
{
desc
:
"
Not
expired
because
does
not
match
even
if
old
"
page
:
"
http
:
/
/
stay
.
moz
.
org
/
"
icon
:
"
http
:
/
/
stay
.
moz
.
org
/
test_icon
.
png
"
expire
:
new
Date
(
)
.
setYear
(
2018
)
*
1000
removed
:
false
}
{
desc
:
"
Not
expired
because
does
not
have
a
root
icon
even
if
old
"
page
:
"
http
:
/
/
noroot
.
ref
.
org
/
#
test
"
icon
:
"
http
:
/
/
noroot
.
ref
.
org
/
test_icon
.
png
"
expire
:
new
Date
(
)
.
setYear
(
2018
)
*
1000
removed
:
false
}
{
desc
:
"
Expired
because
has
a
root
icon
"
page
:
"
http
:
/
/
root
.
ref
.
org
/
#
test
"
icon
:
"
http
:
/
/
root
.
ref
.
org
/
test_icon
.
png
"
root
:
"
http
:
/
/
root
.
ref
.
org
/
favicon
.
ico
"
expire
:
new
Date
(
)
.
setYear
(
2018
)
*
1000
removed
:
true
}
{
desc
:
"
Not
expired
because
recent
"
page
:
"
http
:
/
/
new
.
ref
.
org
/
#
test
"
icon
:
"
http
:
/
/
new
.
ref
.
org
/
test_icon
.
png
"
expire
:
0
root
:
"
http
:
/
/
new
.
ref
.
org
/
favicon
.
ico
"
removed
:
false
}
]
;
for
(
let
entry
of
entries
)
{
if
(
entry
.
redirect
)
{
await
PlacesTestUtils
.
addVisits
(
entry
.
page
)
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
entry
.
redirect
transition
:
TRANSITION_REDIRECT_PERMANENT
referrer
:
entry
.
page
}
)
;
}
else
{
await
PlacesTestUtils
.
addVisits
(
entry
.
page
)
;
}
PlacesUtils
.
favicons
.
replaceFaviconDataFromDataURL
(
Services
.
io
.
newURI
(
entry
.
icon
)
dataUrl
entry
.
expire
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
await
PlacesTestUtils
.
addFavicons
(
new
Map
(
[
[
entry
.
page
entry
.
icon
]
]
)
)
;
Assert
.
equal
(
await
getFaviconUrlForPage
(
entry
.
page
)
entry
.
icon
"
Sanity
check
the
icon
exists
"
)
;
if
(
entry
.
root
)
{
PlacesUtils
.
favicons
.
replaceFaviconDataFromDataURL
(
Services
.
io
.
newURI
(
entry
.
root
)
dataUrl
entry
.
expire
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
await
PlacesTestUtils
.
addFavicons
(
new
Map
(
[
[
entry
.
page
entry
.
root
]
]
)
)
;
}
}
info
(
"
Run
expiration
"
)
;
await
promiseForceExpirationStep
(
-
1
)
;
info
(
"
Check
expiration
"
)
;
await
PlacesUtils
.
withConnectionWrapper
(
"
test_debug_expiration
.
js
"
db
=
>
db
.
execute
(
DELETE
FROM
moz_icons
WHERE
root
=
1
)
)
;
for
(
let
entry
of
entries
)
{
Assert
.
ok
(
page_in_database
(
entry
.
page
)
)
;
if
(
entry
.
removed
)
{
await
Assert
.
rejects
(
getFaviconUrlForPage
(
entry
.
page
)
/
Unable
to
find
an
icon
/
entry
.
desc
)
;
}
else
{
Assert
.
equal
(
await
getFaviconUrlForPage
(
entry
.
page
)
entry
.
icon
entry
.
desc
)
;
}
}
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
function
run_test
(
)
{
setInterval
(
3600
)
;
setMaxPages
(
1
)
;
run_next_test
(
)
;
}
