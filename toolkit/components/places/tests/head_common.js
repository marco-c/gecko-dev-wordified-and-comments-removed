const
NS_APP_USER_PROFILE_50_DIR
=
"
ProfD
"
;
const
TRANSITION_LINK
=
Ci
.
nsINavHistoryService
.
TRANSITION_LINK
;
const
TRANSITION_TYPED
=
Ci
.
nsINavHistoryService
.
TRANSITION_TYPED
;
const
TRANSITION_BOOKMARK
=
Ci
.
nsINavHistoryService
.
TRANSITION_BOOKMARK
;
const
TRANSITION_EMBED
=
Ci
.
nsINavHistoryService
.
TRANSITION_EMBED
;
const
TRANSITION_FRAMED_LINK
=
Ci
.
nsINavHistoryService
.
TRANSITION_FRAMED_LINK
;
const
TRANSITION_REDIRECT_PERMANENT
=
Ci
.
nsINavHistoryService
.
TRANSITION_REDIRECT_PERMANENT
;
const
TRANSITION_REDIRECT_TEMPORARY
=
Ci
.
nsINavHistoryService
.
TRANSITION_REDIRECT_TEMPORARY
;
const
TRANSITION_DOWNLOAD
=
Ci
.
nsINavHistoryService
.
TRANSITION_DOWNLOAD
;
const
TRANSITION_RELOAD
=
Ci
.
nsINavHistoryService
.
TRANSITION_RELOAD
;
const
TITLE_LENGTH_MAX
=
4096
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
var
{
PlacesSyncUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
BookmarkHTMLUtils
:
"
resource
:
/
/
gre
/
modules
/
BookmarkHTMLUtils
.
sys
.
mjs
"
BookmarkJSONUtils
:
"
resource
:
/
/
gre
/
modules
/
BookmarkJSONUtils
.
sys
.
mjs
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
sys
.
mjs
"
ObjectUtils
:
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
sys
.
mjs
"
PlacesBackups
:
"
resource
:
/
/
gre
/
modules
/
PlacesBackups
.
sys
.
mjs
"
PlacesDBUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesDBUtils
.
sys
.
mjs
"
PlacesTestUtils
:
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
sys
.
mjs
"
PlacesTransactions
:
"
resource
:
/
/
gre
/
modules
/
PlacesTransactions
.
sys
.
mjs
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
sys
.
mjs
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
SMALLPNG_DATA_URI
"
function
(
)
{
return
NetUtil
.
newURI
(
"
data
:
image
/
png
;
base64
iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAA
"
+
"
AAAA6fptVAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg
=
=
"
)
;
}
)
;
const
SMALLPNG_DATA_LEN
=
67
;
ChromeUtils
.
defineLazyGetter
(
this
"
SMALLSVG_DATA_URI
"
function
(
)
{
return
NetUtil
.
newURI
(
"
data
:
image
/
svg
+
xml
;
base64
PHN2ZyB4bWxucz0iaHR0cDovL3d3dy5
"
+
"
3My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBmaWxs
"
+
"
PSIjNDI0ZTVhIj4NCiAgPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iN
"
+
"
DQiIHN0cm9rZT0iIzQyNGU1YSIgc3Ryb2tlLXdpZHRoPSIxMSIgZmlsbD
"
+
"
0ibm9uZSIvPg0KICA8Y2lyY2xlIGN4PSI1MCIgY3k9IjI0LjYiIHI9IjY
"
+
"
uNCIvPg0KICA8cmVjdCB4PSI0NSIgeT0iMzkuOSIgd2lkdGg9IjEwLjEi
"
+
"
IGhlaWdodD0iNDEuOCIvPg0KPC9zdmc
%
2BDQo
%
3D
"
)
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
PlacesFrecencyRecalculator
"
(
)
=
>
{
return
Cc
[
"
mozilla
.
org
/
places
/
frecency
-
recalculator
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
.
wrappedJSObject
;
}
)
;
var
gTestDir
=
do_get_cwd
(
)
;
var
gProfD
=
do_get_profile
(
true
)
;
clearDB
(
)
;
function
uri
(
aSpec
)
{
return
NetUtil
.
newURI
(
aSpec
)
;
}
var
gDBConn
;
function
DBConn
(
aForceNewConnection
)
{
if
(
!
aForceNewConnection
)
{
let
db
=
PlacesUtils
.
history
.
DBConnection
;
if
(
db
.
connectionReady
)
{
return
db
;
}
}
if
(
!
gDBConn
|
|
aForceNewConnection
)
{
let
file
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
file
.
append
(
"
places
.
sqlite
"
)
;
let
dbConn
=
(
gDBConn
=
Services
.
storage
.
openDatabase
(
file
)
)
;
promiseTopicObserved
(
"
profile
-
before
-
change
"
)
.
then
(
(
)
=
>
dbConn
.
asyncClose
(
)
)
;
}
return
gDBConn
.
connectionReady
?
gDBConn
:
null
;
}
function
readInputStreamData
(
aStream
)
{
let
bistream
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
try
{
bistream
.
setInputStream
(
aStream
)
;
let
expectedData
=
[
]
;
let
avail
;
while
(
(
avail
=
bistream
.
available
(
)
)
)
{
expectedData
=
expectedData
.
concat
(
bistream
.
readByteArray
(
avail
)
)
;
}
return
expectedData
;
}
finally
{
bistream
.
close
(
)
;
}
}
function
readFileData
(
aFile
)
{
let
inputStream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
inputStream
.
init
(
aFile
0x01
-
1
null
)
;
let
size
=
inputStream
.
available
(
)
;
let
bytes
=
readInputStreamData
(
inputStream
)
;
if
(
size
!
=
bytes
.
length
)
{
throw
new
Error
(
"
Didn
'
t
read
expected
number
of
bytes
"
)
;
}
return
bytes
;
}
function
readFileOfLength
(
aFileName
aExpectedLength
)
{
let
data
=
readFileData
(
do_get_file
(
aFileName
)
)
;
Assert
.
equal
(
data
.
length
aExpectedLength
)
;
return
data
;
}
async
function
readFileDataAsDataURL
(
file
mimeType
)
{
const
data
=
readFileData
(
file
)
;
return
PlacesTestUtils
.
fileDataToDataURL
(
data
mimeType
)
;
}
function
base64EncodeString
(
aString
)
{
var
stream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stream
.
setData
(
aString
aString
.
length
)
;
var
encoder
=
Cc
[
"
mozilla
.
org
/
scriptablebase64encoder
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptableBase64Encoder
)
;
return
encoder
.
encodeToString
(
stream
aString
.
length
)
;
}
function
compareArrays
(
aArray1
aArray2
)
{
if
(
aArray1
.
length
!
=
aArray2
.
length
)
{
print
(
"
compareArrays
:
array
lengths
differ
\
n
"
)
;
return
false
;
}
for
(
let
i
=
0
;
i
<
aArray1
.
length
;
i
+
+
)
{
if
(
aArray1
[
i
]
!
=
aArray2
[
i
]
)
{
print
(
"
compareArrays
:
arrays
differ
at
index
"
+
i
+
"
:
"
+
"
(
"
+
aArray1
[
i
]
+
"
)
!
=
(
"
+
aArray2
[
i
]
+
"
)
\
n
"
)
;
return
false
;
}
}
return
true
;
}
function
clearDB
(
)
{
try
{
let
file
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
file
.
append
(
"
places
.
sqlite
"
)
;
if
(
file
.
exists
(
)
)
{
file
.
remove
(
false
)
;
}
}
catch
(
ex
)
{
dump
(
"
Exception
:
"
+
ex
)
;
}
}
function
dump_table
(
aName
dbConn
)
{
if
(
!
dbConn
)
{
dbConn
=
DBConn
(
)
;
}
let
stmt
=
dbConn
.
createStatement
(
"
SELECT
*
FROM
"
+
aName
)
;
print
(
"
\
n
*
*
*
Printing
data
from
"
+
aName
)
;
let
count
=
0
;
while
(
stmt
.
executeStep
(
)
)
{
let
columns
=
stmt
.
numEntries
;
if
(
count
=
=
0
)
{
for
(
let
i
=
0
;
i
<
columns
;
i
+
+
)
{
dump
(
stmt
.
getColumnName
(
i
)
+
"
\
t
"
)
;
}
dump
(
"
\
n
"
)
;
}
for
(
let
i
=
0
;
i
<
columns
;
i
+
+
)
{
switch
(
stmt
.
getTypeOfIndex
(
i
)
)
{
case
Ci
.
mozIStorageValueArray
.
VALUE_TYPE_NULL
:
dump
(
"
NULL
\
t
"
)
;
break
;
case
Ci
.
mozIStorageValueArray
.
VALUE_TYPE_INTEGER
:
dump
(
stmt
.
getInt64
(
i
)
+
"
\
t
"
)
;
break
;
case
Ci
.
mozIStorageValueArray
.
VALUE_TYPE_FLOAT
:
dump
(
stmt
.
getDouble
(
i
)
+
"
\
t
"
)
;
break
;
case
Ci
.
mozIStorageValueArray
.
VALUE_TYPE_TEXT
:
dump
(
stmt
.
getString
(
i
)
+
"
\
t
"
)
;
break
;
}
}
dump
(
"
\
n
"
)
;
count
+
+
;
}
print
(
"
*
*
*
There
were
a
total
of
"
+
count
+
"
rows
of
data
.
\
n
"
)
;
stmt
.
finalize
(
)
;
}
function
page_in_database
(
aURI
)
{
let
url
=
aURI
instanceof
Ci
.
nsIURI
?
aURI
.
spec
:
aURI
;
let
stmt
=
DBConn
(
)
.
createStatement
(
"
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
"
)
;
stmt
.
params
.
url
=
url
;
try
{
if
(
!
stmt
.
executeStep
(
)
)
{
return
0
;
}
return
stmt
.
getInt64
(
0
)
;
}
finally
{
stmt
.
finalize
(
)
;
}
}
function
visits_in_database
(
aURI
)
{
let
url
=
aURI
instanceof
Ci
.
nsIURI
?
aURI
.
spec
:
aURI
;
let
stmt
=
DBConn
(
)
.
createStatement
(
SELECT
count
(
*
)
FROM
moz_historyvisits
v
JOIN
moz_places
h
ON
h
.
id
=
v
.
place_id
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
;
stmt
.
params
.
url
=
url
;
try
{
if
(
!
stmt
.
executeStep
(
)
)
{
return
0
;
}
return
stmt
.
getInt64
(
0
)
;
}
finally
{
stmt
.
finalize
(
)
;
}
}
function
promiseTopicObserved
(
aTopic
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observe
(
aObsSubject
aObsTopic
aObsData
)
{
Services
.
obs
.
removeObserver
(
observe
aObsTopic
)
;
resolve
(
[
aObsSubject
aObsData
]
)
;
}
aTopic
)
;
}
)
;
}
var
shutdownPlaces
=
function
(
)
{
info
(
"
shutdownPlaces
:
starting
"
)
;
let
promise
=
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
resolve
"
places
-
connection
-
closed
"
)
;
}
)
;
let
hs
=
PlacesUtils
.
history
.
QueryInterface
(
Ci
.
nsIObserver
)
;
hs
.
observe
(
null
"
profile
-
change
-
teardown
"
null
)
;
info
(
"
shutdownPlaces
:
sent
profile
-
change
-
teardown
"
)
;
hs
.
observe
(
null
"
test
-
simulate
-
places
-
shutdown
"
null
)
;
info
(
"
shutdownPlaces
:
sent
test
-
simulate
-
places
-
shutdown
"
)
;
return
promise
.
then
(
(
)
=
>
{
info
(
"
shutdownPlaces
:
complete
"
)
;
}
)
;
}
;
const
FILENAME_BOOKMARKS_HTML
=
"
bookmarks
.
html
"
;
const
FILENAME_BOOKMARKS_JSON
=
"
bookmarks
-
"
+
PlacesBackups
.
toISODateString
(
new
Date
(
)
)
+
"
.
json
"
;
function
create_bookmarks_html
(
aFilename
)
{
if
(
!
aFilename
)
{
do_throw
(
"
you
must
pass
a
filename
to
create_bookmarks_html
function
"
)
;
}
remove_bookmarks_html
(
)
;
let
bookmarksHTMLFile
=
gTestDir
.
clone
(
)
;
bookmarksHTMLFile
.
append
(
aFilename
)
;
Assert
.
ok
(
bookmarksHTMLFile
.
exists
(
)
)
;
bookmarksHTMLFile
.
copyTo
(
gProfD
FILENAME_BOOKMARKS_HTML
)
;
let
profileBookmarksHTMLFile
=
gProfD
.
clone
(
)
;
profileBookmarksHTMLFile
.
append
(
FILENAME_BOOKMARKS_HTML
)
;
Assert
.
ok
(
profileBookmarksHTMLFile
.
exists
(
)
)
;
return
profileBookmarksHTMLFile
;
}
function
remove_bookmarks_html
(
)
{
let
profileBookmarksHTMLFile
=
gProfD
.
clone
(
)
;
profileBookmarksHTMLFile
.
append
(
FILENAME_BOOKMARKS_HTML
)
;
if
(
profileBookmarksHTMLFile
.
exists
(
)
)
{
profileBookmarksHTMLFile
.
remove
(
false
)
;
Assert
.
ok
(
!
profileBookmarksHTMLFile
.
exists
(
)
)
;
}
}
function
check_bookmarks_html
(
)
{
let
profileBookmarksHTMLFile
=
gProfD
.
clone
(
)
;
profileBookmarksHTMLFile
.
append
(
FILENAME_BOOKMARKS_HTML
)
;
Assert
.
ok
(
profileBookmarksHTMLFile
.
exists
(
)
)
;
return
profileBookmarksHTMLFile
;
}
function
create_JSON_backup
(
aFilename
)
{
if
(
!
aFilename
)
{
do_throw
(
"
you
must
pass
a
filename
to
create_JSON_backup
function
"
)
;
}
let
bookmarksBackupDir
=
gProfD
.
clone
(
)
;
bookmarksBackupDir
.
append
(
"
bookmarkbackups
"
)
;
if
(
!
bookmarksBackupDir
.
exists
(
)
)
{
bookmarksBackupDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
parseInt
(
"
0755
"
8
)
)
;
Assert
.
ok
(
bookmarksBackupDir
.
exists
(
)
)
;
}
let
profileBookmarksJSONFile
=
bookmarksBackupDir
.
clone
(
)
;
profileBookmarksJSONFile
.
append
(
FILENAME_BOOKMARKS_JSON
)
;
if
(
profileBookmarksJSONFile
.
exists
(
)
)
{
profileBookmarksJSONFile
.
remove
(
)
;
}
let
bookmarksJSONFile
=
gTestDir
.
clone
(
)
;
bookmarksJSONFile
.
append
(
aFilename
)
;
Assert
.
ok
(
bookmarksJSONFile
.
exists
(
)
)
;
bookmarksJSONFile
.
copyTo
(
bookmarksBackupDir
FILENAME_BOOKMARKS_JSON
)
;
profileBookmarksJSONFile
=
bookmarksBackupDir
.
clone
(
)
;
profileBookmarksJSONFile
.
append
(
FILENAME_BOOKMARKS_JSON
)
;
Assert
.
ok
(
profileBookmarksJSONFile
.
exists
(
)
)
;
return
profileBookmarksJSONFile
;
}
function
remove_all_JSON_backups
(
)
{
let
bookmarksBackupDir
=
gProfD
.
clone
(
)
;
bookmarksBackupDir
.
append
(
"
bookmarkbackups
"
)
;
if
(
bookmarksBackupDir
.
exists
(
)
)
{
bookmarksBackupDir
.
remove
(
true
)
;
Assert
.
ok
(
!
bookmarksBackupDir
.
exists
(
)
)
;
}
}
function
check_JSON_backup
(
aIsAutomaticBackup
)
{
let
profileBookmarksJSONFile
;
if
(
aIsAutomaticBackup
)
{
let
bookmarksBackupDir
=
gProfD
.
clone
(
)
;
bookmarksBackupDir
.
append
(
"
bookmarkbackups
"
)
;
let
files
=
bookmarksBackupDir
.
directoryEntries
;
while
(
files
.
hasMoreElements
(
)
)
{
let
entry
=
files
.
nextFile
;
if
(
PlacesBackups
.
filenamesRegex
.
test
(
entry
.
leafName
)
)
{
profileBookmarksJSONFile
=
entry
;
break
;
}
}
}
else
{
profileBookmarksJSONFile
=
gProfD
.
clone
(
)
;
profileBookmarksJSONFile
.
append
(
"
bookmarkbackups
"
)
;
profileBookmarksJSONFile
.
append
(
FILENAME_BOOKMARKS_JSON
)
;
}
Assert
.
ok
(
profileBookmarksJSONFile
.
exists
(
)
)
;
return
profileBookmarksJSONFile
;
}
function
isUrlHidden
(
aURI
)
{
let
url
=
aURI
instanceof
Ci
.
nsIURI
?
aURI
.
spec
:
aURI
;
let
stmt
=
DBConn
(
)
.
createStatement
(
"
SELECT
hidden
FROM
moz_places
WHERE
url_hash
=
hash
(
?
1
)
AND
url
=
?
1
"
)
;
stmt
.
bindByIndex
(
0
url
)
;
if
(
!
stmt
.
executeStep
(
)
)
{
throw
new
Error
(
"
No
result
for
hidden
.
"
)
;
}
let
hidden
=
stmt
.
getInt32
(
0
)
;
stmt
.
finalize
(
)
;
return
!
!
hidden
;
}
function
is_time_ordered
(
before
after
)
{
let
isWindows
=
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
in
Cc
;
let
skew
=
isWindows
?
20000000
:
0
;
return
after
-
before
>
-
skew
;
}
function
waitForConnectionClosed
(
aCallback
)
{
promiseTopicObserved
(
"
places
-
connection
-
closed
"
)
.
then
(
aCallback
)
;
shutdownPlaces
(
)
;
}
function
do_check_valid_places_guid
(
aGuid
)
{
Assert
.
ok
(
/
^
[
a
-
zA
-
Z0
-
9
\
-
_
]
{
12
}
/
.
test
(
aGuid
)
"
Should
be
a
valid
GUID
"
)
;
}
async
function
check_guid_for_uri
(
aURI
aGUID
)
{
let
guid
=
await
PlacesTestUtils
.
getDatabaseValue
(
"
moz_places
"
"
guid
"
{
url
:
aURI
}
)
;
if
(
aGUID
)
{
do_check_valid_places_guid
(
aGUID
)
;
Assert
.
equal
(
guid
aGUID
"
Should
have
a
guid
in
moz_places
for
the
URI
"
)
;
}
}
async
function
check_guid_for_bookmark
(
aId
aGUID
)
{
let
guid
=
await
PlacesTestUtils
.
getDatabaseValue
(
"
moz_bookmarks
"
"
guid
"
{
id
:
aId
}
)
;
if
(
aGUID
)
{
do_check_valid_places_guid
(
aGUID
)
;
Assert
.
equal
(
guid
aGUID
"
Should
have
the
correct
GUID
for
the
bookmark
"
)
;
}
}
function
do_compare_arrays
(
a1
a2
sorted
)
{
if
(
a1
.
length
!
=
a2
.
length
)
{
return
false
;
}
if
(
sorted
)
{
return
a1
.
every
(
(
e
i
)
=
>
e
=
=
a2
[
i
]
)
;
}
return
(
!
a1
.
filter
(
e
=
>
!
a2
.
includes
(
e
)
)
.
length
&
&
!
a2
.
filter
(
e
=
>
!
a1
.
includes
(
e
)
)
.
length
)
;
}
function
NavHistoryResultObserver
(
)
{
}
NavHistoryResultObserver
.
prototype
=
{
batching
(
)
{
}
containerStateChanged
(
)
{
}
invalidateContainer
(
)
{
}
nodeDateAddedChanged
(
)
{
}
nodeHistoryDetailsChanged
(
)
{
}
nodeIconChanged
(
)
{
}
nodeInserted
(
)
{
}
nodeKeywordChanged
(
)
{
}
nodeLastModifiedChanged
(
)
{
}
nodeMoved
(
)
{
}
nodeRemoved
(
)
{
}
nodeTagsChanged
(
)
{
}
nodeTitleChanged
(
)
{
}
nodeURIChanged
(
)
{
}
sortingChanged
(
)
{
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsINavHistoryResultObserver
"
]
)
}
;
function
checkBookmarkObject
(
info
)
{
do_check_valid_places_guid
(
info
.
guid
)
;
do_check_valid_places_guid
(
info
.
parentGuid
)
;
Assert
.
ok
(
typeof
info
.
index
=
=
"
number
"
"
index
should
be
a
number
"
)
;
Assert
.
ok
(
info
.
dateAdded
.
constructor
.
name
=
=
"
Date
"
"
dateAdded
should
be
a
Date
"
)
;
Assert
.
ok
(
info
.
lastModified
.
constructor
.
name
=
=
"
Date
"
"
lastModified
should
be
a
Date
"
)
;
Assert
.
ok
(
info
.
lastModified
>
=
info
.
dateAdded
"
lastModified
should
never
be
smaller
than
dateAdded
"
)
;
Assert
.
ok
(
typeof
info
.
type
=
=
"
number
"
"
type
should
be
a
number
"
)
;
}
async
function
foreign_count
(
url
)
{
if
(
url
instanceof
Ci
.
nsIURI
)
{
url
=
url
.
spec
;
}
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
foreign_count
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
{
url
}
)
;
return
!
rows
.
length
?
0
:
rows
[
0
]
.
getResultByName
(
"
foreign_count
"
)
;
}
function
compareAscending
(
a
b
)
{
if
(
a
>
b
)
{
return
1
;
}
if
(
a
<
b
)
{
return
-
1
;
}
return
0
;
}
function
sortBy
(
array
prop
)
{
return
array
.
sort
(
(
a
b
)
=
>
compareAscending
(
a
[
prop
]
b
[
prop
]
)
)
;
}
async
function
setFaviconForPage
(
page
icon
forceReload
=
true
)
{
let
pageURI
=
page
instanceof
Ci
.
nsIURI
?
page
:
NetUtil
.
newURI
(
new
URL
(
page
)
.
href
)
;
let
iconURI
=
icon
instanceof
Ci
.
nsIURI
?
icon
:
NetUtil
.
newURI
(
new
URL
(
icon
)
.
href
)
;
let
dataURL
;
if
(
!
forceReload
)
{
dataURL
=
await
PlacesTestUtils
.
getFaviconDataURLFromDB
(
iconURI
)
;
}
if
(
!
dataURL
)
{
dataURL
=
await
PlacesTestUtils
.
getFaviconDataURLFromNetwork
(
iconURI
)
;
}
await
new
Promise
(
resolve
=
>
{
PlacesUtils
.
favicons
.
setFaviconForPage
(
pageURI
iconURI
dataURL
null
resolve
)
;
}
)
;
}
function
getFaviconUrlForPage
(
page
width
=
0
)
{
let
pageURI
=
page
instanceof
Ci
.
nsIURI
?
page
:
NetUtil
.
newURI
(
new
URL
(
page
)
.
href
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
PlacesUtils
.
favicons
.
getFaviconURLForPage
(
pageURI
iconURI
=
>
{
if
(
iconURI
)
{
resolve
(
iconURI
.
spec
)
;
}
else
{
reject
(
"
Unable
to
find
an
icon
for
"
+
pageURI
.
spec
)
;
}
}
width
)
;
}
)
;
}
function
getFaviconDataForPage
(
page
width
=
0
)
{
let
pageURI
=
page
instanceof
Ci
.
nsIURI
?
page
:
NetUtil
.
newURI
(
new
URL
(
page
)
.
href
)
;
return
new
Promise
(
resolve
=
>
{
PlacesUtils
.
favicons
.
getFaviconDataForPage
(
pageURI
(
iconUri
len
data
mimeType
)
=
>
{
resolve
(
{
data
mimeType
}
)
;
}
width
)
;
}
)
;
}
async
function
compareFavicons
(
icon1
icon2
msg
)
{
icon1
=
new
URL
(
icon1
instanceof
Ci
.
nsIURI
?
icon1
.
spec
:
icon1
)
;
icon2
=
new
URL
(
icon2
instanceof
Ci
.
nsIURI
?
icon2
.
spec
:
icon2
)
;
function
getIconData
(
icon
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
NetUtil
.
asyncFetch
(
{
uri
:
icon
.
href
loadUsingSystemPrincipal
:
true
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_INTERNAL_IMAGE_FAVICON
}
function
(
inputStream
status
)
{
if
(
!
Components
.
isSuccessCode
(
status
)
)
{
reject
(
)
;
}
let
size
=
inputStream
.
available
(
)
;
resolve
(
NetUtil
.
readInputStreamToString
(
inputStream
size
)
)
;
}
)
;
}
)
;
}
let
data1
=
await
getIconData
(
icon1
)
;
Assert
.
ok
(
!
!
data1
.
length
"
Should
fetch
icon
data
"
)
;
let
data2
=
await
getIconData
(
icon2
)
;
Assert
.
ok
(
!
!
data2
.
length
"
Should
fetch
icon
data
"
)
;
Assert
.
deepEqual
(
data1
data2
msg
)
;
}
function
mapItemGuidToInternalRootName
(
itemGuid
)
{
switch
(
itemGuid
)
{
case
PlacesUtils
.
bookmarks
.
rootGuid
:
return
"
placesRoot
"
;
case
PlacesUtils
.
bookmarks
.
menuGuid
:
return
"
bookmarksMenuFolder
"
;
case
PlacesUtils
.
bookmarks
.
toolbarGuid
:
return
"
toolbarFolder
"
;
case
PlacesUtils
.
bookmarks
.
unfiledGuid
:
return
"
unfiledBookmarksFolder
"
;
case
PlacesUtils
.
bookmarks
.
mobileGuid
:
return
"
mobileFolder
"
;
}
return
null
;
}
const
DB_FILENAME
=
"
places
.
sqlite
"
;
async
function
setupPlacesDatabase
(
path
destFileName
=
DB_FILENAME
)
{
let
currentDir
=
do_get_cwd
(
)
.
path
;
if
(
typeof
path
=
=
"
string
"
)
{
path
=
[
path
]
;
}
else
{
currentDir
=
PathUtils
.
parent
(
currentDir
)
;
}
let
src
=
PathUtils
.
join
(
currentDir
.
.
.
path
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
src
)
"
Database
file
found
"
)
;
let
dest
=
PathUtils
.
join
(
PathUtils
.
profileDir
destFileName
)
;
Assert
.
ok
(
!
(
await
IOUtils
.
exists
(
dest
)
)
"
Database
file
should
not
exist
yet
"
)
;
await
IOUtils
.
copy
(
src
dest
)
;
return
dest
;
}
function
getPagesWithAnnotation
(
name
)
{
return
PlacesUtils
.
promiseDBConnection
(
)
.
then
(
async
db
=
>
{
let
rows
=
await
db
.
execute
(
SELECT
h
.
url
FROM
moz_anno_attributes
n
JOIN
moz_annos
a
ON
n
.
id
=
a
.
anno_attribute_id
JOIN
moz_places
h
ON
h
.
id
=
a
.
place_id
WHERE
n
.
name
=
:
name
{
name
}
)
;
return
rows
.
map
(
row
=
>
row
.
getResultByName
(
"
url
"
)
)
;
}
)
;
}
async
function
assertNoOrphanPageAnnotations
(
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
execute
(
SELECT
place_id
FROM
moz_annos
WHERE
place_id
NOT
IN
(
SELECT
id
FROM
moz_places
)
)
;
Assert
.
equal
(
rows
.
length
0
"
Should
not
have
any
orphan
page
annotations
"
)
;
rows
=
await
db
.
execute
(
SELECT
id
FROM
moz_anno_attributes
WHERE
id
NOT
IN
(
SELECT
anno_attribute_id
FROM
moz_annos
)
AND
id
NOT
IN
(
SELECT
anno_attribute_id
FROM
moz_items_annos
)
)
;
}
