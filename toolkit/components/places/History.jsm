"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
History
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AsyncShutdown
"
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Promise
"
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Sqlite
"
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
const
NOTIFICATION_CHUNK_SIZE
=
300
;
const
ONRESULT_CHUNK_SIZE
=
300
;
const
TIMERS_RESOLUTION_SKEW_MS
=
16
;
function
notify
(
observers
notification
args
=
[
]
)
{
for
(
let
observer
of
observers
)
{
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
}
}
}
this
.
History
=
Object
.
freeze
(
{
fetch
:
function
(
guidOrURI
)
{
throw
new
Error
(
"
Method
not
implemented
"
)
;
}
insert
:
function
(
pageInfo
)
{
if
(
typeof
pageInfo
!
=
"
object
"
|
|
!
pageInfo
)
{
throw
new
TypeError
(
"
pageInfo
must
be
an
object
"
)
;
}
let
info
=
validatePageInfo
(
pageInfo
)
;
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
insert
"
db
=
>
insert
(
db
info
)
)
;
}
insertMany
:
function
(
pageInfos
onResult
onError
)
{
let
infos
=
[
]
;
if
(
!
Array
.
isArray
(
pageInfos
)
)
{
throw
new
TypeError
(
"
pageInfos
must
be
an
array
"
)
;
}
if
(
!
pageInfos
.
length
)
{
throw
new
TypeError
(
"
pageInfos
may
not
be
an
empty
array
"
)
;
}
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
{
throw
new
TypeError
(
onResult
:
{
onResult
}
is
not
a
valid
function
)
;
}
if
(
onError
&
&
typeof
onError
!
=
"
function
"
)
{
throw
new
TypeError
(
onError
:
{
onError
}
is
not
a
valid
function
)
;
}
for
(
let
pageInfo
of
pageInfos
)
{
let
info
=
validatePageInfo
(
pageInfo
)
;
infos
.
push
(
info
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
insertMany
"
db
=
>
insertMany
(
db
infos
onResult
onError
)
)
;
}
remove
:
function
(
pages
onResult
=
null
)
{
if
(
Array
.
isArray
(
pages
)
)
{
if
(
pages
.
length
=
=
0
)
{
throw
new
TypeError
(
"
Expected
at
least
one
page
"
)
;
}
}
else
{
pages
=
[
pages
]
;
}
let
guids
=
[
]
;
let
urls
=
[
]
;
for
(
let
page
of
pages
)
{
let
normalized
=
normalizeToURLOrGUID
(
page
)
;
if
(
typeof
normalized
=
=
=
"
string
"
)
{
guids
.
push
(
normalized
)
;
}
else
{
urls
.
push
(
normalized
.
href
)
;
}
}
let
normalizedPages
=
{
guids
:
guids
urls
:
urls
}
;
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
{
throw
new
TypeError
(
"
Invalid
function
:
"
+
onResult
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
remove
"
db
=
>
remove
(
db
normalizedPages
onResult
)
)
;
}
removeVisitsByFilter
:
function
(
filter
onResult
=
null
)
{
if
(
!
filter
|
|
typeof
filter
!
=
"
object
"
)
{
throw
new
TypeError
(
"
Expected
a
filter
"
)
;
}
let
hasBeginDate
=
"
beginDate
"
in
filter
;
let
hasEndDate
=
"
endDate
"
in
filter
;
if
(
hasBeginDate
)
{
ensureDate
(
filter
.
beginDate
)
;
}
if
(
hasEndDate
)
{
ensureDate
(
filter
.
endDate
)
;
}
if
(
hasBeginDate
&
&
hasEndDate
&
&
filter
.
beginDate
>
filter
.
endDate
)
{
throw
new
TypeError
(
"
beginDate
should
be
at
least
as
old
as
endDate
"
)
;
}
if
(
!
hasBeginDate
&
&
!
hasEndDate
)
{
throw
new
TypeError
(
"
Expected
a
non
-
empty
filter
"
)
;
}
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
{
throw
new
TypeError
(
"
Invalid
function
:
"
+
onResult
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
removeVisitsByFilter
"
db
=
>
removeVisitsByFilter
(
db
filter
onResult
)
)
;
}
hasVisits
:
function
(
page
onResult
)
{
throw
new
Error
(
"
Method
not
implemented
"
)
;
}
clear
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
clear
"
clear
)
;
}
TRANSITIONS
:
{
LINK
:
Ci
.
nsINavHistoryService
.
TRANSITION_LINK
TYPED
:
Ci
.
nsINavHistoryService
.
TRANSITION_TYPED
BOOKMARK
:
Ci
.
nsINavHistoryService
.
TRANSITION_BOOKMARK
EMBED
:
Ci
.
nsINavHistoryService
.
TRANSITION_EMBED
REDIRECT_PERMANENT
:
Ci
.
nsINavHistoryService
.
TRANSITION_REDIRECT_PERMANENT
REDIRECT_TEMPORARY
:
Ci
.
nsINavHistoryService
.
TRANSITION_REDIRECT_TEMPORARY
DOWNLOAD
:
Ci
.
nsINavHistoryService
.
TRANSITION_DOWNLOAD
FRAMED_LINK
:
Ci
.
nsINavHistoryService
.
TRANSITION_FRAMED_LINK
RELOAD
:
Ci
.
nsINavHistoryService
.
TRANSITION_RELOAD
}
}
)
;
function
validatePageInfo
(
pageInfo
)
{
let
info
=
{
visits
:
[
]
}
;
if
(
!
pageInfo
.
url
)
{
throw
new
TypeError
(
"
PageInfo
object
must
have
a
url
property
"
)
;
}
info
.
url
=
normalizeToURLOrGUID
(
pageInfo
.
url
)
;
if
(
typeof
pageInfo
.
title
=
=
=
"
string
"
)
{
info
.
title
=
pageInfo
.
title
;
}
else
if
(
pageInfo
.
title
!
=
null
&
&
pageInfo
.
title
!
=
undefined
)
{
throw
new
TypeError
(
title
property
of
PageInfo
object
:
{
pageInfo
.
title
}
must
be
a
string
if
provided
)
;
}
if
(
!
pageInfo
.
visits
|
|
!
Array
.
isArray
(
pageInfo
.
visits
)
|
|
!
pageInfo
.
visits
.
length
)
{
throw
new
TypeError
(
"
PageInfo
object
must
have
an
array
of
visits
"
)
;
}
for
(
let
inVisit
of
pageInfo
.
visits
)
{
let
visit
=
{
date
:
new
Date
(
)
transition
:
inVisit
.
transition
|
|
History
.
TRANSITIONS
.
LINK
}
;
if
(
!
isValidTransitionType
(
visit
.
transition
)
)
{
throw
new
TypeError
(
transition
:
{
visit
.
transition
}
is
not
a
valid
transition
type
)
;
}
if
(
inVisit
.
date
)
{
ensureDate
(
inVisit
.
date
)
;
if
(
inVisit
.
date
>
(
Date
.
now
(
)
+
TIMERS_RESOLUTION_SKEW_MS
)
)
{
throw
new
TypeError
(
date
:
{
inVisit
.
date
}
cannot
be
a
future
date
)
;
}
visit
.
date
=
inVisit
.
date
;
}
if
(
inVisit
.
referrer
)
{
visit
.
referrer
=
normalizeToURLOrGUID
(
inVisit
.
referrer
)
;
}
info
.
visits
.
push
(
visit
)
;
}
return
info
;
}
function
convertForUpdatePlaces
(
pageInfo
)
{
let
info
=
{
uri
:
PlacesUtils
.
toURI
(
pageInfo
.
url
)
title
:
pageInfo
.
title
visits
:
[
]
}
;
for
(
let
inVisit
of
pageInfo
.
visits
)
{
let
visit
=
{
visitDate
:
PlacesUtils
.
toPRTime
(
inVisit
.
date
)
transitionType
:
inVisit
.
transition
referrerURI
:
(
inVisit
.
referrer
)
?
PlacesUtils
.
toURI
(
inVisit
.
referrer
)
:
undefined
}
;
info
.
visits
.
push
(
visit
)
;
}
return
info
;
}
function
isValidTransitionType
(
transitionType
)
{
return
Object
.
values
(
History
.
TRANSITIONS
)
.
includes
(
transitionType
)
;
}
function
normalizeToURLOrGUID
(
key
)
{
if
(
typeof
key
=
=
=
"
string
"
)
{
if
(
PlacesUtils
.
isValidGuid
(
key
)
)
{
return
key
;
}
return
new
URL
(
key
)
;
}
if
(
key
instanceof
URL
)
{
return
key
;
}
if
(
key
instanceof
Ci
.
nsIURI
)
{
return
new
URL
(
key
.
spec
)
;
}
throw
new
TypeError
(
"
Invalid
url
or
guid
:
"
+
key
)
;
}
function
ensureDate
(
arg
)
{
if
(
!
arg
|
|
typeof
arg
!
=
"
object
"
|
|
arg
.
constructor
.
name
!
=
"
Date
"
)
{
throw
new
TypeError
(
"
Expected
a
Date
got
"
+
arg
)
;
}
}
function
sqlList
(
list
)
{
return
list
.
map
(
JSON
.
stringify
)
.
join
(
)
;
}
var
invalidateFrecencies
=
Task
.
async
(
function
*
(
db
idList
)
{
if
(
idList
.
length
=
=
0
)
{
return
;
}
let
ids
=
sqlList
(
idList
)
;
yield
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
NOTIFY_FRECENCY
(
CALCULATE_FRECENCY
(
id
)
url
guid
hidden
last_visit_date
)
WHERE
id
in
(
{
ids
}
)
)
;
yield
db
.
execute
(
UPDATE
moz_places
SET
hidden
=
0
WHERE
id
in
(
{
ids
}
)
AND
frecency
<
>
0
)
;
}
)
;
var
clear
=
Task
.
async
(
function
*
(
db
)
{
yield
db
.
execute
(
"
DELETE
FROM
moz_historyvisits
"
)
;
PlacesUtils
.
history
.
clearEmbedVisits
(
)
;
let
observers
=
PlacesUtils
.
history
.
getObservers
(
)
;
notify
(
observers
"
onClearHistory
"
)
;
yield
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
(
CASE
WHEN
url_hash
BETWEEN
hash
(
"
place
"
"
prefix_lo
"
)
AND
hash
(
"
place
"
"
prefix_hi
"
)
THEN
0
ELSE
-
1
END
)
WHERE
frecency
>
0
)
;
notify
(
observers
"
onManyFrecenciesChanged
"
)
;
}
)
;
var
cleanupPages
=
Task
.
async
(
function
*
(
db
pages
)
{
yield
invalidateFrecencies
(
db
pages
.
filter
(
p
=
>
p
.
hasForeign
|
|
p
.
hasVisits
)
.
map
(
p
=
>
p
.
id
)
)
;
let
pageIdsToRemove
=
pages
.
filter
(
p
=
>
!
p
.
hasForeign
&
&
!
p
.
hasVisits
)
.
map
(
p
=
>
p
.
id
)
;
if
(
pageIdsToRemove
.
length
>
0
)
{
let
idsList
=
sqlList
(
pageIdsToRemove
)
;
yield
db
.
execute
(
DELETE
FROM
moz_places
WHERE
id
IN
(
{
idsList
}
)
)
;
yield
db
.
executeCached
(
DELETE
FROM
moz_updatehosts_temp
)
;
yield
db
.
executeCached
(
DELETE
FROM
moz_favicons
WHERE
NOT
EXISTS
(
SELECT
1
FROM
moz_places
WHERE
favicon_id
=
moz_favicons
.
id
)
)
;
yield
db
.
execute
(
DELETE
FROM
moz_annos
WHERE
place_id
IN
(
{
idsList
}
)
)
;
yield
db
.
execute
(
DELETE
FROM
moz_inputhistory
WHERE
place_id
IN
(
{
idsList
}
)
)
;
}
}
)
;
var
notifyCleanup
=
Task
.
async
(
function
*
(
db
pages
)
{
let
notifiedCount
=
0
;
let
observers
=
PlacesUtils
.
history
.
getObservers
(
)
;
let
reason
=
Ci
.
nsINavHistoryObserver
.
REASON_DELETED
;
for
(
let
page
of
pages
)
{
let
uri
=
NetUtil
.
newURI
(
page
.
url
.
href
)
;
let
guid
=
page
.
guid
;
if
(
page
.
hasVisits
)
{
continue
;
}
if
(
page
.
hasForeign
)
{
notify
(
observers
"
onDeleteVisits
"
[
uri
0
guid
reason
-
1
]
)
;
}
else
{
notify
(
observers
"
onDeleteURI
"
[
uri
guid
reason
]
)
;
}
if
(
+
+
notifiedCount
%
NOTIFICATION_CHUNK_SIZE
=
=
0
)
{
yield
Promise
.
resolve
(
)
;
}
}
}
)
;
var
notifyOnResult
=
Task
.
async
(
function
*
(
data
onResult
)
{
if
(
!
onResult
)
{
return
;
}
let
notifiedCount
=
0
;
for
(
let
info
of
data
)
{
try
{
onResult
(
info
)
;
}
catch
(
ex
)
{
Promise
.
reject
(
ex
)
;
}
if
(
+
+
notifiedCount
%
ONRESULT_CHUNK_SIZE
=
=
0
)
{
yield
Promise
.
resolve
(
)
;
}
}
}
)
;
var
removeVisitsByFilter
=
Task
.
async
(
function
*
(
db
filter
onResult
=
null
)
{
let
dates
=
{
conditions
:
[
]
args
:
{
}
}
;
if
(
"
beginDate
"
in
filter
)
{
dates
.
conditions
.
push
(
"
visit_date
>
=
:
begin
*
1000
"
)
;
dates
.
args
.
begin
=
Number
(
filter
.
beginDate
)
;
}
if
(
"
endDate
"
in
filter
)
{
dates
.
conditions
.
push
(
"
visit_date
<
=
:
end
*
1000
"
)
;
dates
.
args
.
end
=
Number
(
filter
.
endDate
)
;
}
let
visitsToRemove
=
[
]
;
let
pagesToInspect
=
new
Set
(
)
;
let
onResultData
=
onResult
?
[
]
:
null
;
yield
db
.
executeCached
(
SELECT
id
place_id
visit_date
/
1000
AS
date
visit_type
FROM
moz_historyvisits
WHERE
{
dates
.
conditions
.
join
(
"
AND
"
)
}
dates
.
args
row
=
>
{
let
id
=
row
.
getResultByName
(
"
id
"
)
;
let
place_id
=
row
.
getResultByName
(
"
place_id
"
)
;
visitsToRemove
.
push
(
id
)
;
pagesToInspect
.
add
(
place_id
)
;
if
(
onResult
)
{
onResultData
.
push
(
{
date
:
new
Date
(
row
.
getResultByName
(
"
date
"
)
)
transition
:
row
.
getResultByName
(
"
visit_type
"
)
}
)
;
}
}
)
;
try
{
if
(
visitsToRemove
.
length
=
=
0
)
{
return
false
;
}
let
pages
=
[
]
;
yield
db
.
executeTransaction
(
function
*
(
)
{
yield
db
.
execute
(
DELETE
FROM
moz_historyvisits
WHERE
id
IN
(
{
sqlList
(
visitsToRemove
)
}
)
)
;
yield
db
.
execute
(
SELECT
id
url
guid
(
foreign_count
!
=
0
)
AS
has_foreign
(
last_visit_date
NOTNULL
)
as
has_visits
FROM
moz_places
WHERE
id
IN
(
{
sqlList
(
[
.
.
.
pagesToInspect
]
)
}
)
null
row
=
>
{
let
page
=
{
id
:
row
.
getResultByName
(
"
id
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
hasForeign
:
row
.
getResultByName
(
"
has_foreign
"
)
hasVisits
:
row
.
getResultByName
(
"
has_visits
"
)
url
:
new
URL
(
row
.
getResultByName
(
"
url
"
)
)
}
;
pages
.
push
(
page
)
;
}
)
;
yield
cleanupPages
(
db
pages
)
;
}
)
;
notifyCleanup
(
db
pages
)
;
notifyOnResult
(
onResultData
onResult
)
;
}
finally
{
PlacesUtils
.
history
.
clearEmbedVisits
(
)
;
}
return
visitsToRemove
.
length
!
=
0
;
}
)
;
var
remove
=
Task
.
async
(
function
*
(
db
{
guids
urls
}
onResult
=
null
)
{
let
query
=
SELECT
id
url
guid
foreign_count
title
frecency
FROM
moz_places
WHERE
guid
IN
(
{
sqlList
(
guids
)
}
)
OR
(
url_hash
IN
(
{
urls
.
map
(
u
=
>
"
hash
(
"
+
JSON
.
stringify
(
u
)
+
"
)
"
)
.
join
(
"
"
)
}
)
AND
url
IN
(
{
sqlList
(
urls
)
}
)
)
;
let
onResultData
=
onResult
?
[
]
:
null
;
let
pages
=
[
]
;
let
hasPagesToKeep
=
false
;
let
hasPagesToRemove
=
false
;
yield
db
.
execute
(
query
null
Task
.
async
(
function
*
(
row
)
{
let
hasForeign
=
row
.
getResultByName
(
"
foreign_count
"
)
!
=
0
;
if
(
hasForeign
)
{
hasPagesToKeep
=
true
;
}
else
{
hasPagesToRemove
=
true
;
}
let
id
=
row
.
getResultByName
(
"
id
"
)
;
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
url
=
row
.
getResultByName
(
"
url
"
)
;
let
page
=
{
id
guid
hasForeign
hasVisits
:
false
url
:
new
URL
(
url
)
}
;
pages
.
push
(
page
)
;
if
(
onResult
)
{
onResultData
.
push
(
{
guid
:
guid
title
:
row
.
getResultByName
(
"
title
"
)
frecency
:
row
.
getResultByName
(
"
frecency
"
)
url
:
new
URL
(
url
)
}
)
;
}
}
)
)
;
try
{
if
(
pages
.
length
=
=
0
)
{
return
false
;
}
yield
db
.
executeTransaction
(
function
*
(
)
{
yield
db
.
execute
(
DELETE
FROM
moz_historyvisits
WHERE
place_id
IN
(
{
sqlList
(
pages
.
map
(
p
=
>
p
.
id
)
)
}
)
)
;
yield
cleanupPages
(
db
pages
)
;
}
)
;
notifyCleanup
(
db
pages
)
;
notifyOnResult
(
onResultData
onResult
)
;
}
finally
{
PlacesUtils
.
history
.
clearEmbedVisits
(
)
;
}
return
hasPagesToRemove
;
}
)
;
function
mergeUpdateInfoIntoPageInfo
(
updateInfo
pageInfo
=
{
}
)
{
pageInfo
.
guid
=
updateInfo
.
guid
;
if
(
!
pageInfo
.
url
)
{
pageInfo
.
url
=
new
URL
(
updateInfo
.
uri
.
spec
)
;
pageInfo
.
title
=
updateInfo
.
title
;
pageInfo
.
visits
=
updateInfo
.
visits
.
map
(
visit
=
>
{
return
{
date
:
PlacesUtils
.
toDate
(
visit
.
visitDate
)
transition
:
visit
.
transitionType
referrer
:
(
visit
.
referrerURI
)
?
new
URL
(
visit
.
referrerURI
.
spec
)
:
null
}
}
)
;
}
return
pageInfo
;
}
var
insert
=
Task
.
async
(
function
*
(
db
pageInfo
)
{
let
info
=
convertForUpdatePlaces
(
pageInfo
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
PlacesUtils
.
asyncHistory
.
updatePlaces
(
info
{
handleError
:
error
=
>
{
reject
(
error
)
;
}
handleResult
:
result
=
>
{
pageInfo
=
mergeUpdateInfoIntoPageInfo
(
result
pageInfo
)
;
}
handleCompletion
:
(
)
=
>
{
resolve
(
pageInfo
)
;
}
}
)
;
}
)
;
}
)
;
var
insertMany
=
Task
.
async
(
function
*
(
db
pageInfos
onResult
onError
)
{
let
infos
=
[
]
;
let
onResultData
=
[
]
;
let
onErrorData
=
[
]
;
for
(
let
pageInfo
of
pageInfos
)
{
let
info
=
convertForUpdatePlaces
(
pageInfo
)
;
infos
.
push
(
info
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
PlacesUtils
.
asyncHistory
.
updatePlaces
(
infos
{
handleError
:
(
resultCode
result
)
=
>
{
let
pageInfo
=
mergeUpdateInfoIntoPageInfo
(
result
)
;
onErrorData
.
push
(
pageInfo
)
;
}
handleResult
:
result
=
>
{
let
pageInfo
=
mergeUpdateInfoIntoPageInfo
(
result
)
;
onResultData
.
push
(
pageInfo
)
;
}
handleCompletion
:
(
)
=
>
{
notifyOnResult
(
onResultData
onResult
)
;
notifyOnResult
(
onErrorData
onError
)
;
if
(
onResultData
.
length
)
{
resolve
(
)
;
}
else
{
reject
(
{
message
:
"
No
items
were
added
to
history
.
"
}
)
}
}
}
)
;
}
)
;
}
)
;
