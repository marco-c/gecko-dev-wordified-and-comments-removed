"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
History
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
asyncHistory
"
"
mozilla
.
org
/
browser
/
history
;
1
"
"
mozIAsyncHistory
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
const
NOTIFICATION_CHUNK_SIZE
=
300
;
const
ONRESULT_CHUNK_SIZE
=
300
;
const
REMOVE_PAGES_CHUNKLEN
=
300
;
function
notify
(
observers
notification
args
=
[
]
)
{
for
(
let
observer
of
observers
)
{
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
}
}
}
var
History
=
Object
.
freeze
(
{
fetch
(
guidOrURI
options
=
{
}
)
{
guidOrURI
=
PlacesUtils
.
normalizeToURLOrGUID
(
guidOrURI
)
;
if
(
!
options
|
|
typeof
options
!
=
=
"
object
"
)
{
throw
new
TypeError
(
"
options
should
be
an
object
and
not
null
"
)
;
}
let
hasIncludeVisits
=
"
includeVisits
"
in
options
;
if
(
hasIncludeVisits
&
&
typeof
options
.
includeVisits
!
=
=
"
boolean
"
)
{
throw
new
TypeError
(
"
includeVisits
should
be
a
boolean
if
exists
"
)
;
}
let
hasIncludeMeta
=
"
includeMeta
"
in
options
;
if
(
hasIncludeMeta
&
&
typeof
options
.
includeMeta
!
=
=
"
boolean
"
)
{
throw
new
TypeError
(
"
includeMeta
should
be
a
boolean
if
exists
"
)
;
}
return
PlacesUtils
.
promiseDBConnection
(
)
.
then
(
db
=
>
fetch
(
db
guidOrURI
options
)
)
;
}
insert
(
pageInfo
)
{
let
info
=
PlacesUtils
.
validatePageInfo
(
pageInfo
)
;
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
insert
"
db
=
>
insert
(
db
info
)
)
;
}
insertMany
(
pageInfos
onResult
onError
)
{
let
infos
=
[
]
;
if
(
!
Array
.
isArray
(
pageInfos
)
)
{
throw
new
TypeError
(
"
pageInfos
must
be
an
array
"
)
;
}
if
(
!
pageInfos
.
length
)
{
throw
new
TypeError
(
"
pageInfos
may
not
be
an
empty
array
"
)
;
}
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
{
throw
new
TypeError
(
onResult
:
{
onResult
}
is
not
a
valid
function
)
;
}
if
(
onError
&
&
typeof
onError
!
=
"
function
"
)
{
throw
new
TypeError
(
onError
:
{
onError
}
is
not
a
valid
function
)
;
}
for
(
let
pageInfo
of
pageInfos
)
{
let
info
=
PlacesUtils
.
validatePageInfo
(
pageInfo
)
;
infos
.
push
(
info
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
insertMany
"
db
=
>
insertMany
(
db
infos
onResult
onError
)
)
;
}
remove
(
pages
onResult
=
null
)
{
if
(
Array
.
isArray
(
pages
)
)
{
if
(
pages
.
length
=
=
0
)
{
throw
new
TypeError
(
"
Expected
at
least
one
page
"
)
;
}
}
else
{
pages
=
[
pages
]
;
}
let
guids
=
[
]
;
let
urls
=
[
]
;
for
(
let
page
of
pages
)
{
let
normalized
=
PlacesUtils
.
normalizeToURLOrGUID
(
page
)
;
if
(
typeof
normalized
=
=
=
"
string
"
)
{
guids
.
push
(
normalized
)
;
}
else
{
urls
.
push
(
normalized
.
href
)
;
}
}
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
{
throw
new
TypeError
(
"
Invalid
function
:
"
+
onResult
)
;
}
return
(
async
function
(
)
{
let
removedPages
=
false
;
let
count
=
0
;
while
(
guids
.
length
|
|
urls
.
length
)
{
if
(
count
&
&
count
%
2
=
=
0
)
{
await
Promise
.
resolve
(
)
;
}
count
+
+
;
let
guidsSlice
=
guids
.
splice
(
0
REMOVE_PAGES_CHUNKLEN
)
;
let
urlsSlice
=
[
]
;
if
(
guidsSlice
.
length
<
REMOVE_PAGES_CHUNKLEN
)
{
urlsSlice
=
urls
.
splice
(
0
REMOVE_PAGES_CHUNKLEN
-
guidsSlice
.
length
)
;
}
let
pages
=
{
guids
:
guidsSlice
urls
:
urlsSlice
}
;
let
result
=
await
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
remove
"
db
=
>
remove
(
db
pages
onResult
)
)
;
removedPages
=
removedPages
|
|
result
;
}
return
removedPages
;
}
)
(
)
;
}
removeVisitsByFilter
(
filter
onResult
=
null
)
{
if
(
!
filter
|
|
typeof
filter
!
=
"
object
"
)
{
throw
new
TypeError
(
"
Expected
a
filter
"
)
;
}
let
hasBeginDate
=
"
beginDate
"
in
filter
;
let
hasEndDate
=
"
endDate
"
in
filter
;
let
hasURL
=
"
url
"
in
filter
;
let
hasLimit
=
"
limit
"
in
filter
;
if
(
hasBeginDate
)
{
this
.
ensureDate
(
filter
.
beginDate
)
;
}
if
(
hasEndDate
)
{
this
.
ensureDate
(
filter
.
endDate
)
;
}
if
(
hasBeginDate
&
&
hasEndDate
&
&
filter
.
beginDate
>
filter
.
endDate
)
{
throw
new
TypeError
(
"
beginDate
should
be
at
least
as
old
as
endDate
"
)
;
}
if
(
!
hasBeginDate
&
&
!
hasEndDate
&
&
!
hasURL
&
&
!
hasLimit
)
{
throw
new
TypeError
(
"
Expected
a
non
-
empty
filter
"
)
;
}
if
(
hasURL
&
&
!
(
filter
.
url
instanceof
URL
)
&
&
typeof
filter
.
url
!
=
"
string
"
&
&
!
(
filter
.
url
instanceof
Ci
.
nsIURI
)
)
{
throw
new
TypeError
(
"
Expected
a
valid
URL
for
url
"
)
;
}
if
(
hasLimit
&
&
(
typeof
filter
.
limit
!
=
"
number
"
|
|
filter
.
limit
<
=
0
|
|
!
Number
.
isInteger
(
filter
.
limit
)
)
)
{
throw
new
TypeError
(
"
Expected
a
non
-
zero
positive
integer
as
a
limit
"
)
;
}
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
{
throw
new
TypeError
(
"
Invalid
function
:
"
+
onResult
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
removeVisitsByFilter
"
db
=
>
removeVisitsByFilter
(
db
filter
onResult
)
)
;
}
removeByFilter
(
filter
onResult
)
{
if
(
!
filter
|
|
typeof
filter
!
=
=
"
object
"
)
{
throw
new
TypeError
(
"
Expected
a
filter
object
"
)
;
}
let
hasHost
=
filter
.
host
;
if
(
hasHost
)
{
if
(
typeof
filter
.
host
!
=
=
"
string
"
)
{
throw
new
TypeError
(
"
host
should
be
a
string
"
)
;
}
filter
.
host
=
filter
.
host
.
toLowerCase
(
)
;
if
(
filter
.
host
.
length
>
1
&
&
filter
.
host
.
lastIndexOf
(
"
.
"
)
=
=
0
)
{
filter
.
host
=
filter
.
host
.
slice
(
1
)
;
}
}
let
hasBeginDate
=
"
beginDate
"
in
filter
;
if
(
hasBeginDate
)
{
this
.
ensureDate
(
filter
.
beginDate
)
;
}
let
hasEndDate
=
"
endDate
"
in
filter
;
if
(
hasEndDate
)
{
this
.
ensureDate
(
filter
.
endDate
)
;
}
if
(
hasBeginDate
&
&
hasEndDate
&
&
filter
.
beginDate
>
filter
.
endDate
)
{
throw
new
TypeError
(
"
beginDate
should
be
at
least
as
old
as
endDate
"
)
;
}
if
(
!
hasBeginDate
&
&
!
hasEndDate
&
&
!
hasHost
)
{
throw
new
TypeError
(
"
Expected
a
non
-
empty
filter
"
)
;
}
if
(
hasHost
&
&
(
!
/
^
(
\
.
?
(
[
.
a
-
z0
-
9
-
]
+
\
.
[
a
-
z0
-
9
-
]
+
)
?
|
[
a
-
z0
-
9
-
]
+
)
/
.
test
(
filter
.
host
)
|
|
filter
.
host
.
includes
(
"
.
.
"
)
)
)
{
throw
new
TypeError
(
"
Expected
well
formed
hostname
string
for
host
with
atmost
1
wildcard
.
"
)
;
}
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
{
throw
new
TypeError
(
"
Invalid
function
:
"
+
onResult
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
removeByFilter
"
db
=
>
removeByFilter
(
db
filter
onResult
)
)
;
}
hasVisits
(
guidOrURI
)
{
if
(
guidOrURI
instanceof
Ci
.
nsIURI
)
{
return
new
Promise
(
resolve
=
>
{
asyncHistory
.
isURIVisited
(
guidOrURI
(
aURI
aIsVisited
)
=
>
{
resolve
(
aIsVisited
)
;
}
)
;
}
)
;
}
guidOrURI
=
PlacesUtils
.
normalizeToURLOrGUID
(
guidOrURI
)
;
let
isGuid
=
typeof
guidOrURI
=
=
"
string
"
;
let
sqlFragment
=
isGuid
?
"
guid
=
:
val
"
:
"
url_hash
=
hash
(
:
val
)
AND
url
=
:
val
"
;
return
PlacesUtils
.
promiseDBConnection
(
)
.
then
(
async
db
=
>
{
let
rows
=
await
db
.
executeCached
(
SELECT
1
FROM
moz_places
WHERE
{
sqlFragment
}
AND
last_visit_date
NOTNULL
{
val
:
isGuid
?
guidOrURI
:
guidOrURI
.
href
}
)
;
return
!
!
rows
.
length
;
}
)
;
}
clear
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
clear
"
clear
)
;
}
isValidTransition
(
transitionType
)
{
return
Object
.
values
(
History
.
TRANSITIONS
)
.
includes
(
transitionType
)
;
}
ensureDate
(
arg
)
{
if
(
!
arg
|
|
typeof
arg
!
=
"
object
"
|
|
arg
.
constructor
.
name
!
=
"
Date
"
)
{
throw
new
TypeError
(
"
Expected
a
Date
got
"
+
arg
)
;
}
}
update
(
pageInfo
)
{
let
info
=
PlacesUtils
.
validatePageInfo
(
pageInfo
false
)
;
if
(
info
.
description
=
=
=
undefined
&
&
info
.
previewImageURL
=
=
=
undefined
)
{
throw
new
TypeError
(
"
pageInfo
object
must
at
least
have
either
a
description
or
a
previewImageURL
property
"
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
update
"
db
=
>
update
(
db
info
)
)
;
}
TRANSITIONS
:
{
LINK
:
Ci
.
nsINavHistoryService
.
TRANSITION_LINK
TYPED
:
Ci
.
nsINavHistoryService
.
TRANSITION_TYPED
BOOKMARK
:
Ci
.
nsINavHistoryService
.
TRANSITION_BOOKMARK
EMBED
:
Ci
.
nsINavHistoryService
.
TRANSITION_EMBED
REDIRECT_PERMANENT
:
Ci
.
nsINavHistoryService
.
TRANSITION_REDIRECT_PERMANENT
REDIRECT_TEMPORARY
:
Ci
.
nsINavHistoryService
.
TRANSITION_REDIRECT_TEMPORARY
DOWNLOAD
:
Ci
.
nsINavHistoryService
.
TRANSITION_DOWNLOAD
FRAMED_LINK
:
Ci
.
nsINavHistoryService
.
TRANSITION_FRAMED_LINK
RELOAD
:
Ci
.
nsINavHistoryService
.
TRANSITION_RELOAD
}
}
)
;
function
convertForUpdatePlaces
(
pageInfo
)
{
let
info
=
{
guid
:
pageInfo
.
guid
uri
:
PlacesUtils
.
toURI
(
pageInfo
.
url
)
title
:
pageInfo
.
title
visits
:
[
]
}
;
for
(
let
inVisit
of
pageInfo
.
visits
)
{
let
visit
=
{
visitDate
:
PlacesUtils
.
toPRTime
(
inVisit
.
date
)
transitionType
:
inVisit
.
transition
referrerURI
:
(
inVisit
.
referrer
)
?
PlacesUtils
.
toURI
(
inVisit
.
referrer
)
:
undefined
}
;
info
.
visits
.
push
(
visit
)
;
}
return
info
;
}
function
sqlList
(
list
)
{
return
list
.
map
(
JSON
.
stringify
)
.
join
(
)
;
}
var
invalidateFrecencies
=
async
function
(
db
idList
)
{
if
(
idList
.
length
=
=
0
)
{
return
;
}
let
ids
=
sqlList
(
idList
)
;
await
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
NOTIFY_FRECENCY
(
CALCULATE_FRECENCY
(
id
)
url
guid
hidden
last_visit_date
)
WHERE
id
in
(
{
ids
}
)
)
;
await
db
.
execute
(
UPDATE
moz_places
SET
hidden
=
0
WHERE
id
in
(
{
ids
}
)
AND
frecency
<
>
0
)
;
await
db
.
execute
(
DELETE
FROM
moz_updateoriginsupdate_temp
)
;
}
;
var
clear
=
async
function
(
db
)
{
await
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
execute
(
DELETE
FROM
moz_places
WHERE
foreign_count
=
0
)
;
await
db
.
execute
(
DELETE
FROM
moz_updateoriginsdelete_temp
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_pages_w_icons
WHERE
page_url_hash
NOT
IN
(
SELECT
url_hash
FROM
moz_places
)
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_icons
WHERE
id
IN
(
SELECT
id
FROM
moz_icons
WHERE
root
=
0
EXCEPT
SELECT
icon_id
FROM
moz_icons_to_pages
)
)
;
await
db
.
execute
(
DELETE
FROM
moz_items_annos
WHERE
expiration
=
:
expire_session
{
expire_session
:
Ci
.
nsIAnnotationService
.
EXPIRE_SESSION
}
)
;
await
db
.
execute
(
DELETE
FROM
moz_annos
WHERE
id
in
(
SELECT
a
.
id
FROM
moz_annos
a
LEFT
JOIN
moz_places
h
ON
a
.
place_id
=
h
.
id
WHERE
h
.
id
IS
NULL
OR
expiration
=
:
expire_session
OR
(
expiration
=
:
expire_with_history
AND
h
.
last_visit_date
ISNULL
)
)
{
expire_session
:
Ci
.
nsIAnnotationService
.
EXPIRE_SESSION
expire_with_history
:
Ci
.
nsIAnnotationService
.
EXPIRE_WITH_HISTORY
}
)
;
await
db
.
execute
(
DELETE
FROM
moz_inputhistory
WHERE
place_id
IN
(
SELECT
i
.
place_id
FROM
moz_inputhistory
i
LEFT
JOIN
moz_places
h
ON
h
.
id
=
i
.
place_id
WHERE
h
.
id
IS
NULL
)
)
;
await
db
.
execute
(
"
DELETE
FROM
moz_historyvisits
"
)
;
await
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
(
CASE
WHEN
url_hash
BETWEEN
hash
(
"
place
"
"
prefix_lo
"
)
AND
hash
(
"
place
"
"
prefix_hi
"
)
THEN
0
ELSE
-
1
END
)
WHERE
frecency
>
0
)
;
}
)
;
PlacesUtils
.
history
.
clearEmbedVisits
(
)
;
let
observers
=
PlacesUtils
.
history
.
getObservers
(
)
;
notify
(
observers
"
onClearHistory
"
)
;
notify
(
observers
"
onManyFrecenciesChanged
"
)
;
await
db
.
execute
(
DELETE
FROM
moz_updateoriginsupdate_temp
)
;
}
;
var
cleanupPages
=
async
function
(
db
pages
)
{
await
invalidateFrecencies
(
db
pages
.
filter
(
p
=
>
p
.
hasForeign
|
|
p
.
hasVisits
)
.
map
(
p
=
>
p
.
id
)
)
;
let
pagesToRemove
=
pages
.
filter
(
p
=
>
!
p
.
hasForeign
&
&
!
p
.
hasVisits
)
;
if
(
pagesToRemove
.
length
=
=
0
)
return
;
let
idsList
=
sqlList
(
pagesToRemove
.
map
(
p
=
>
p
.
id
)
)
;
await
db
.
execute
(
DELETE
FROM
moz_places
WHERE
id
IN
(
{
idsList
}
)
AND
foreign_count
=
0
AND
last_visit_date
ISNULL
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_updateoriginsdelete_temp
)
;
let
hashesToRemove
=
pagesToRemove
.
map
(
p
=
>
p
.
hash
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_pages_w_icons
WHERE
page_url_hash
IN
(
{
sqlList
(
hashesToRemove
)
}
)
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_icons
WHERE
id
IN
(
SELECT
id
FROM
moz_icons
WHERE
root
=
0
EXCEPT
SELECT
icon_id
FROM
moz_icons_to_pages
)
)
;
await
db
.
execute
(
DELETE
FROM
moz_annos
WHERE
place_id
IN
(
{
idsList
}
)
)
;
await
db
.
execute
(
DELETE
FROM
moz_inputhistory
WHERE
place_id
IN
(
{
idsList
}
)
)
;
}
;
var
notifyCleanup
=
async
function
(
db
pages
)
{
let
notifiedCount
=
0
;
let
observers
=
PlacesUtils
.
history
.
getObservers
(
)
;
let
reason
=
Ci
.
nsINavHistoryObserver
.
REASON_DELETED
;
for
(
let
page
of
pages
)
{
let
uri
=
NetUtil
.
newURI
(
page
.
url
.
href
)
;
let
guid
=
page
.
guid
;
if
(
page
.
hasVisits
)
{
continue
;
}
if
(
page
.
hasForeign
)
{
notify
(
observers
"
onDeleteVisits
"
[
uri
0
guid
reason
-
1
]
)
;
}
else
{
notify
(
observers
"
onDeleteURI
"
[
uri
guid
reason
]
)
;
}
if
(
+
+
notifiedCount
%
NOTIFICATION_CHUNK_SIZE
=
=
0
)
{
await
Promise
.
resolve
(
)
;
}
}
}
;
var
notifyOnResult
=
async
function
(
data
onResult
)
{
if
(
!
onResult
)
{
return
;
}
let
notifiedCount
=
0
;
for
(
let
info
of
data
)
{
try
{
onResult
(
info
)
;
}
catch
(
ex
)
{
Promise
.
reject
(
ex
)
;
}
if
(
+
+
notifiedCount
%
ONRESULT_CHUNK_SIZE
=
=
0
)
{
await
Promise
.
resolve
(
)
;
}
}
}
;
var
fetch
=
async
function
(
db
guidOrURL
options
)
{
let
whereClauseFragment
=
"
"
;
let
params
=
{
}
;
if
(
guidOrURL
instanceof
URL
)
{
whereClauseFragment
=
"
WHERE
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
"
;
params
.
url
=
guidOrURL
.
href
;
}
else
{
whereClauseFragment
=
"
WHERE
h
.
guid
=
:
guid
"
;
params
.
guid
=
guidOrURL
;
}
let
visitSelectionFragment
=
"
"
;
let
joinFragment
=
"
"
;
let
visitOrderFragment
=
"
"
;
if
(
options
.
includeVisits
)
{
visitSelectionFragment
=
"
v
.
visit_date
v
.
visit_type
"
;
joinFragment
=
"
JOIN
moz_historyvisits
v
ON
h
.
id
=
v
.
place_id
"
;
visitOrderFragment
=
"
ORDER
BY
v
.
visit_date
DESC
"
;
}
let
pageMetaSelectionFragment
=
"
"
;
if
(
options
.
includeMeta
)
{
pageMetaSelectionFragment
=
"
description
preview_image_url
"
;
}
let
query
=
SELECT
h
.
id
guid
url
title
frecency
{
pageMetaSelectionFragment
}
{
visitSelectionFragment
}
FROM
moz_places
h
{
joinFragment
}
{
whereClauseFragment
}
{
visitOrderFragment
}
;
let
pageInfo
=
null
;
await
db
.
executeCached
(
query
params
row
=
>
{
if
(
pageInfo
=
=
=
null
)
{
pageInfo
=
{
guid
:
row
.
getResultByName
(
"
guid
"
)
url
:
new
URL
(
row
.
getResultByName
(
"
url
"
)
)
frecency
:
row
.
getResultByName
(
"
frecency
"
)
title
:
row
.
getResultByName
(
"
title
"
)
|
|
"
"
}
;
}
if
(
options
.
includeMeta
)
{
pageInfo
.
description
=
row
.
getResultByName
(
"
description
"
)
|
|
"
"
;
let
previewImageURL
=
row
.
getResultByName
(
"
preview_image_url
"
)
;
pageInfo
.
previewImageURL
=
previewImageURL
?
new
URL
(
previewImageURL
)
:
null
;
}
if
(
options
.
includeVisits
)
{
if
(
!
(
"
visits
"
in
pageInfo
)
)
{
pageInfo
.
visits
=
[
]
;
}
let
date
=
PlacesUtils
.
toDate
(
row
.
getResultByName
(
"
visit_date
"
)
)
;
let
transition
=
row
.
getResultByName
(
"
visit_type
"
)
;
pageInfo
.
visits
.
push
(
{
date
transition
}
)
;
}
}
)
;
return
pageInfo
;
}
;
var
removeVisitsByFilter
=
async
function
(
db
filter
onResult
=
null
)
{
let
conditions
=
[
]
;
let
args
=
{
}
;
if
(
"
beginDate
"
in
filter
)
{
conditions
.
push
(
"
v
.
visit_date
>
=
:
begin
*
1000
"
)
;
args
.
begin
=
Number
(
filter
.
beginDate
)
;
}
if
(
"
endDate
"
in
filter
)
{
conditions
.
push
(
"
v
.
visit_date
<
=
:
end
*
1000
"
)
;
args
.
end
=
Number
(
filter
.
endDate
)
;
}
if
(
"
limit
"
in
filter
)
{
args
.
limit
=
Number
(
filter
.
limit
)
;
}
let
optionalJoin
=
"
"
;
if
(
"
url
"
in
filter
)
{
let
url
=
filter
.
url
;
if
(
url
instanceof
Ci
.
nsIURI
)
{
url
=
filter
.
url
.
spec
;
}
else
{
url
=
new
URL
(
url
)
.
href
;
}
optionalJoin
=
JOIN
moz_places
h
ON
h
.
id
=
v
.
place_id
;
conditions
.
push
(
"
h
.
url_hash
=
hash
(
:
url
)
"
"
h
.
url
=
:
url
"
)
;
args
.
url
=
url
;
}
let
visitsToRemove
=
[
]
;
let
pagesToInspect
=
new
Set
(
)
;
let
onResultData
=
onResult
?
[
]
:
null
;
await
db
.
executeCached
(
SELECT
v
.
id
place_id
visit_date
/
1000
AS
date
visit_type
FROM
moz_historyvisits
v
{
optionalJoin
}
WHERE
{
conditions
.
join
(
"
AND
"
)
}
{
args
.
limit
?
"
LIMIT
:
limit
"
:
"
"
}
args
row
=
>
{
let
id
=
row
.
getResultByName
(
"
id
"
)
;
let
place_id
=
row
.
getResultByName
(
"
place_id
"
)
;
visitsToRemove
.
push
(
id
)
;
pagesToInspect
.
add
(
place_id
)
;
if
(
onResult
)
{
onResultData
.
push
(
{
date
:
new
Date
(
row
.
getResultByName
(
"
date
"
)
)
transition
:
row
.
getResultByName
(
"
visit_type
"
)
}
)
;
}
}
)
;
try
{
if
(
visitsToRemove
.
length
=
=
0
)
{
return
false
;
}
let
pages
=
[
]
;
await
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
execute
(
DELETE
FROM
moz_historyvisits
WHERE
id
IN
(
{
sqlList
(
visitsToRemove
)
}
)
)
;
await
db
.
execute
(
SELECT
id
url
url_hash
guid
(
foreign_count
!
=
0
)
AS
has_foreign
(
last_visit_date
NOTNULL
)
as
has_visits
FROM
moz_places
WHERE
id
IN
(
{
sqlList
(
[
.
.
.
pagesToInspect
]
)
}
)
null
row
=
>
{
let
page
=
{
id
:
row
.
getResultByName
(
"
id
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
hasForeign
:
row
.
getResultByName
(
"
has_foreign
"
)
hasVisits
:
row
.
getResultByName
(
"
has_visits
"
)
url
:
new
URL
(
row
.
getResultByName
(
"
url
"
)
)
hash
:
row
.
getResultByName
(
"
url_hash
"
)
}
;
pages
.
push
(
page
)
;
}
)
;
await
cleanupPages
(
db
pages
)
;
}
)
;
notifyCleanup
(
db
pages
)
;
notifyOnResult
(
onResultData
onResult
)
;
}
finally
{
PlacesUtils
.
history
.
clearEmbedVisits
(
)
;
}
return
visitsToRemove
.
length
!
=
0
;
}
;
var
removeByFilter
=
async
function
(
db
filter
onResult
=
null
)
{
let
dateFilterSQLFragment
=
"
"
;
let
conditions
=
[
]
;
let
params
=
{
}
;
if
(
"
beginDate
"
in
filter
)
{
conditions
.
push
(
"
v
.
visit_date
>
=
:
begin
"
)
;
params
.
begin
=
PlacesUtils
.
toPRTime
(
filter
.
beginDate
)
;
}
if
(
"
endDate
"
in
filter
)
{
conditions
.
push
(
"
v
.
visit_date
<
=
:
end
"
)
;
params
.
end
=
PlacesUtils
.
toPRTime
(
filter
.
endDate
)
;
}
if
(
conditions
.
length
!
=
=
0
)
{
dateFilterSQLFragment
=
EXISTS
(
SELECT
id
FROM
moz_historyvisits
v
WHERE
v
.
place_id
=
h
.
id
AND
{
conditions
.
join
(
"
AND
"
)
}
LIMIT
1
)
;
}
let
hostFilterSQLFragment
=
"
"
;
if
(
filter
.
host
)
{
let
revHost
=
filter
.
host
.
split
(
"
"
)
.
reverse
(
)
.
join
(
"
"
)
;
if
(
filter
.
host
=
=
"
.
"
)
{
hostFilterSQLFragment
=
h
.
rev_host
=
:
revHost
;
}
else
if
(
filter
.
host
.
startsWith
(
"
.
"
)
)
{
revHost
=
revHost
.
slice
(
0
-
1
)
;
hostFilterSQLFragment
=
h
.
rev_host
between
:
revHost
|
|
"
.
"
and
:
revHost
|
|
"
/
"
;
}
else
{
hostFilterSQLFragment
=
h
.
rev_host
=
:
revHost
|
|
"
.
"
;
}
params
.
revHost
=
revHost
;
}
let
fragmentArray
=
[
hostFilterSQLFragment
dateFilterSQLFragment
]
;
let
query
=
SELECT
h
.
id
url
url_hash
rev_host
guid
title
frecency
foreign_count
FROM
moz_places
h
WHERE
(
{
fragmentArray
.
filter
(
f
=
>
f
!
=
=
"
"
)
.
join
(
"
)
AND
(
"
)
}
)
;
let
onResultData
=
onResult
?
[
]
:
null
;
let
pages
=
[
]
;
let
hasPagesToRemove
=
false
;
await
db
.
executeCached
(
query
params
row
=
>
{
let
hasForeign
=
row
.
getResultByName
(
"
foreign_count
"
)
!
=
0
;
if
(
!
hasForeign
)
{
hasPagesToRemove
=
true
;
}
let
id
=
row
.
getResultByName
(
"
id
"
)
;
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
url
=
row
.
getResultByName
(
"
url
"
)
;
let
page
=
{
id
guid
hasForeign
hasVisits
:
false
url
:
new
URL
(
url
)
hash
:
row
.
getResultByName
(
"
url_hash
"
)
}
;
pages
.
push
(
page
)
;
if
(
onResult
)
{
onResultData
.
push
(
{
guid
title
:
row
.
getResultByName
(
"
title
"
)
frecency
:
row
.
getResultByName
(
"
frecency
"
)
url
:
new
URL
(
url
)
}
)
;
}
}
)
;
if
(
pages
.
length
=
=
=
0
)
{
return
false
;
}
try
{
await
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
execute
(
DELETE
FROM
moz_historyvisits
WHERE
place_id
IN
(
{
sqlList
(
pages
.
map
(
p
=
>
p
.
id
)
)
}
)
)
;
await
cleanupPages
(
db
pages
)
;
}
)
;
notifyCleanup
(
db
pages
)
;
notifyOnResult
(
onResultData
onResult
)
;
}
finally
{
PlacesUtils
.
history
.
clearEmbedVisits
(
)
;
}
return
hasPagesToRemove
;
}
;
var
remove
=
async
function
(
db
{
guids
urls
}
onResult
=
null
)
{
let
query
=
SELECT
id
url
url_hash
guid
foreign_count
title
frecency
FROM
moz_places
WHERE
guid
IN
(
{
sqlList
(
guids
)
}
)
OR
(
url_hash
IN
(
{
urls
.
map
(
u
=
>
"
hash
(
"
+
JSON
.
stringify
(
u
)
+
"
)
"
)
.
join
(
"
"
)
}
)
AND
url
IN
(
{
sqlList
(
urls
)
}
)
)
;
let
onResultData
=
onResult
?
[
]
:
null
;
let
pages
=
[
]
;
let
hasPagesToRemove
=
false
;
await
db
.
execute
(
query
null
function
(
row
)
{
let
hasForeign
=
row
.
getResultByName
(
"
foreign_count
"
)
!
=
0
;
if
(
!
hasForeign
)
{
hasPagesToRemove
=
true
;
}
let
id
=
row
.
getResultByName
(
"
id
"
)
;
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
url
=
row
.
getResultByName
(
"
url
"
)
;
let
page
=
{
id
guid
hasForeign
hasVisits
:
false
url
:
new
URL
(
url
)
hash
:
row
.
getResultByName
(
"
url_hash
"
)
}
;
pages
.
push
(
page
)
;
if
(
onResult
)
{
onResultData
.
push
(
{
guid
title
:
row
.
getResultByName
(
"
title
"
)
frecency
:
row
.
getResultByName
(
"
frecency
"
)
url
:
new
URL
(
url
)
}
)
;
}
}
)
;
try
{
if
(
pages
.
length
=
=
0
)
{
return
false
;
}
await
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
execute
(
DELETE
FROM
moz_historyvisits
WHERE
place_id
IN
(
{
sqlList
(
pages
.
map
(
p
=
>
p
.
id
)
)
}
)
)
;
await
cleanupPages
(
db
pages
)
;
}
)
;
notifyCleanup
(
db
pages
)
;
notifyOnResult
(
onResultData
onResult
)
;
}
finally
{
PlacesUtils
.
history
.
clearEmbedVisits
(
)
;
}
return
hasPagesToRemove
;
}
;
function
mergeUpdateInfoIntoPageInfo
(
updateInfo
pageInfo
=
{
}
)
{
pageInfo
.
guid
=
updateInfo
.
guid
;
pageInfo
.
title
=
updateInfo
.
title
;
if
(
!
pageInfo
.
url
)
{
pageInfo
.
url
=
new
URL
(
updateInfo
.
uri
.
spec
)
;
pageInfo
.
title
=
updateInfo
.
title
;
pageInfo
.
visits
=
updateInfo
.
visits
.
map
(
visit
=
>
{
return
{
date
:
PlacesUtils
.
toDate
(
visit
.
visitDate
)
transition
:
visit
.
transitionType
referrer
:
(
visit
.
referrerURI
)
?
new
URL
(
visit
.
referrerURI
.
spec
)
:
null
}
;
}
)
;
}
return
pageInfo
;
}
var
insert
=
function
(
db
pageInfo
)
{
let
info
=
convertForUpdatePlaces
(
pageInfo
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
asyncHistory
.
updatePlaces
(
info
{
handleError
:
error
=
>
{
reject
(
error
)
;
}
handleResult
:
result
=
>
{
pageInfo
=
mergeUpdateInfoIntoPageInfo
(
result
pageInfo
)
;
}
handleCompletion
:
(
)
=
>
{
resolve
(
pageInfo
)
;
}
}
)
;
}
)
;
}
;
var
insertMany
=
function
(
db
pageInfos
onResult
onError
)
{
let
infos
=
[
]
;
let
onResultData
=
[
]
;
let
onErrorData
=
[
]
;
for
(
let
pageInfo
of
pageInfos
)
{
let
info
=
convertForUpdatePlaces
(
pageInfo
)
;
infos
.
push
(
info
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
asyncHistory
.
updatePlaces
(
infos
{
handleError
:
(
resultCode
result
)
=
>
{
let
pageInfo
=
mergeUpdateInfoIntoPageInfo
(
result
)
;
onErrorData
.
push
(
pageInfo
)
;
}
handleResult
:
result
=
>
{
let
pageInfo
=
mergeUpdateInfoIntoPageInfo
(
result
)
;
onResultData
.
push
(
pageInfo
)
;
}
ignoreErrors
:
!
onError
ignoreResults
:
!
onResult
handleCompletion
:
(
updatedCount
)
=
>
{
notifyOnResult
(
onResultData
onResult
)
;
notifyOnResult
(
onErrorData
onError
)
;
if
(
updatedCount
>
0
)
{
resolve
(
)
;
}
else
{
reject
(
{
message
:
"
No
items
were
added
to
history
.
"
}
)
;
}
}
}
true
)
;
}
)
;
}
;
var
update
=
async
function
(
db
pageInfo
)
{
let
updateFragments
=
[
]
;
let
whereClauseFragment
=
"
"
;
let
params
=
{
}
;
if
(
typeof
pageInfo
.
guid
=
=
=
"
string
"
)
{
whereClauseFragment
=
"
guid
=
:
guid
"
;
params
.
guid
=
pageInfo
.
guid
;
}
else
{
whereClauseFragment
=
"
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
"
;
params
.
url
=
pageInfo
.
url
.
href
;
}
if
(
pageInfo
.
description
|
|
pageInfo
.
description
=
=
=
null
)
{
updateFragments
.
push
(
"
description
"
)
;
params
.
description
=
pageInfo
.
description
;
}
if
(
pageInfo
.
previewImageURL
|
|
pageInfo
.
previewImageURL
=
=
=
null
)
{
updateFragments
.
push
(
"
preview_image_url
"
)
;
params
.
preview_image_url
=
pageInfo
.
previewImageURL
?
pageInfo
.
previewImageURL
.
href
:
null
;
}
await
db
.
execute
(
UPDATE
moz_places
SET
{
updateFragments
.
map
(
v
=
>
{
v
}
=
:
{
v
}
)
.
join
(
"
"
)
}
WHERE
{
whereClauseFragment
}
AND
(
{
updateFragments
.
map
(
v
=
>
IFNULL
(
{
v
}
"
"
)
<
>
IFNULL
(
:
{
v
}
"
"
)
)
.
join
(
"
OR
"
)
}
)
params
)
;
}
;
