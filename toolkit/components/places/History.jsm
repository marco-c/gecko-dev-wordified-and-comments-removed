"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
History
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
asyncHistory
"
"
mozilla
.
org
/
browser
/
history
;
1
"
"
mozIAsyncHistory
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
const
NOTIFICATION_CHUNK_SIZE
=
300
;
const
ONRESULT_CHUNK_SIZE
=
300
;
const
REMOVE_PAGES_CHUNKLEN
=
300
;
function
notify
(
observers
notification
args
=
[
]
)
{
for
(
let
observer
of
observers
)
{
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED
&
&
(
AppConstants
.
DEBUG
|
|
Cu
.
isInAutomation
)
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
}
var
History
=
Object
.
freeze
(
{
ANNOTATION_EXPIRE_NEVER
:
4
ANNOTATION_TYPE_STRING
:
3
ANNOTATION_TYPE_INT64
:
5
fetch
(
guidOrURI
options
=
{
}
)
{
guidOrURI
=
PlacesUtils
.
normalizeToURLOrGUID
(
guidOrURI
)
;
if
(
!
options
|
|
typeof
options
!
=
=
"
object
"
)
{
throw
new
TypeError
(
"
options
should
be
an
object
and
not
null
"
)
;
}
let
hasIncludeVisits
=
"
includeVisits
"
in
options
;
if
(
hasIncludeVisits
&
&
typeof
options
.
includeVisits
!
=
=
"
boolean
"
)
{
throw
new
TypeError
(
"
includeVisits
should
be
a
boolean
if
exists
"
)
;
}
let
hasIncludeMeta
=
"
includeMeta
"
in
options
;
if
(
hasIncludeMeta
&
&
typeof
options
.
includeMeta
!
=
=
"
boolean
"
)
{
throw
new
TypeError
(
"
includeMeta
should
be
a
boolean
if
exists
"
)
;
}
let
hasIncludeAnnotations
=
"
includeAnnotations
"
in
options
;
if
(
hasIncludeAnnotations
&
&
typeof
options
.
includeAnnotations
!
=
=
"
boolean
"
)
{
throw
new
TypeError
(
"
includeAnnotations
should
be
a
boolean
if
exists
"
)
;
}
return
PlacesUtils
.
promiseDBConnection
(
)
.
then
(
db
=
>
fetch
(
db
guidOrURI
options
)
)
;
}
fetchAnnotatedPages
(
annotations
)
{
if
(
!
annotations
|
|
!
Array
.
isArray
(
annotations
)
)
{
throw
new
TypeError
(
"
annotations
should
be
an
Array
and
not
null
"
)
;
}
if
(
annotations
.
some
(
name
=
>
typeof
name
!
=
=
"
string
"
)
)
{
throw
new
TypeError
(
"
all
annotation
values
should
be
strings
"
)
;
}
return
PlacesUtils
.
promiseDBConnection
(
)
.
then
(
db
=
>
fetchAnnotatedPages
(
db
annotations
)
)
;
}
insert
(
pageInfo
)
{
let
info
=
PlacesUtils
.
validatePageInfo
(
pageInfo
)
;
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
insert
"
db
=
>
insert
(
db
info
)
)
;
}
insertMany
(
pageInfos
onResult
onError
)
{
let
infos
=
[
]
;
if
(
!
Array
.
isArray
(
pageInfos
)
)
{
throw
new
TypeError
(
"
pageInfos
must
be
an
array
"
)
;
}
if
(
!
pageInfos
.
length
)
{
throw
new
TypeError
(
"
pageInfos
may
not
be
an
empty
array
"
)
;
}
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
{
throw
new
TypeError
(
onResult
:
{
onResult
}
is
not
a
valid
function
)
;
}
if
(
onError
&
&
typeof
onError
!
=
"
function
"
)
{
throw
new
TypeError
(
onError
:
{
onError
}
is
not
a
valid
function
)
;
}
for
(
let
pageInfo
of
pageInfos
)
{
let
info
=
PlacesUtils
.
validatePageInfo
(
pageInfo
)
;
infos
.
push
(
info
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
insertMany
"
db
=
>
insertMany
(
db
infos
onResult
onError
)
)
;
}
remove
(
pages
onResult
=
null
)
{
if
(
Array
.
isArray
(
pages
)
)
{
if
(
!
pages
.
length
)
{
throw
new
TypeError
(
"
Expected
at
least
one
page
"
)
;
}
}
else
{
pages
=
[
pages
]
;
}
let
guids
=
[
]
;
let
urls
=
[
]
;
for
(
let
page
of
pages
)
{
let
normalized
=
PlacesUtils
.
normalizeToURLOrGUID
(
page
)
;
if
(
typeof
normalized
=
=
=
"
string
"
)
{
guids
.
push
(
normalized
)
;
}
else
{
urls
.
push
(
normalized
.
href
)
;
}
}
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
{
throw
new
TypeError
(
"
Invalid
function
:
"
+
onResult
)
;
}
return
(
async
function
(
)
{
let
removedPages
=
false
;
let
count
=
0
;
while
(
guids
.
length
|
|
urls
.
length
)
{
if
(
count
&
&
count
%
2
=
=
0
)
{
await
Promise
.
resolve
(
)
;
}
count
+
+
;
let
guidsSlice
=
guids
.
splice
(
0
REMOVE_PAGES_CHUNKLEN
)
;
let
urlsSlice
=
[
]
;
if
(
guidsSlice
.
length
<
REMOVE_PAGES_CHUNKLEN
)
{
urlsSlice
=
urls
.
splice
(
0
REMOVE_PAGES_CHUNKLEN
-
guidsSlice
.
length
)
;
}
let
pages
=
{
guids
:
guidsSlice
urls
:
urlsSlice
}
;
let
result
=
await
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
remove
"
db
=
>
remove
(
db
pages
onResult
)
)
;
removedPages
=
removedPages
|
|
result
;
}
return
removedPages
;
}
)
(
)
;
}
removeVisitsByFilter
(
filter
onResult
=
null
)
{
if
(
!
filter
|
|
typeof
filter
!
=
"
object
"
)
{
throw
new
TypeError
(
"
Expected
a
filter
"
)
;
}
let
hasBeginDate
=
"
beginDate
"
in
filter
;
let
hasEndDate
=
"
endDate
"
in
filter
;
let
hasURL
=
"
url
"
in
filter
;
let
hasLimit
=
"
limit
"
in
filter
;
let
hasTransition
=
"
transition
"
in
filter
;
if
(
hasBeginDate
)
{
this
.
ensureDate
(
filter
.
beginDate
)
;
}
if
(
hasEndDate
)
{
this
.
ensureDate
(
filter
.
endDate
)
;
}
if
(
hasBeginDate
&
&
hasEndDate
&
&
filter
.
beginDate
>
filter
.
endDate
)
{
throw
new
TypeError
(
"
beginDate
should
be
at
least
as
old
as
endDate
"
)
;
}
if
(
hasTransition
&
&
!
this
.
isValidTransition
(
filter
.
transition
)
)
{
throw
new
TypeError
(
"
transition
should
be
valid
"
)
;
}
if
(
!
hasBeginDate
&
&
!
hasEndDate
&
&
!
hasURL
&
&
!
hasLimit
&
&
!
hasTransition
)
{
throw
new
TypeError
(
"
Expected
a
non
-
empty
filter
"
)
;
}
if
(
hasURL
&
&
!
(
filter
.
url
instanceof
URL
)
&
&
typeof
filter
.
url
!
=
"
string
"
&
&
!
(
filter
.
url
instanceof
Ci
.
nsIURI
)
)
{
throw
new
TypeError
(
"
Expected
a
valid
URL
for
url
"
)
;
}
if
(
hasLimit
&
&
(
typeof
filter
.
limit
!
=
"
number
"
|
|
filter
.
limit
<
=
0
|
|
!
Number
.
isInteger
(
filter
.
limit
)
)
)
{
throw
new
TypeError
(
"
Expected
a
non
-
zero
positive
integer
as
a
limit
"
)
;
}
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
{
throw
new
TypeError
(
"
Invalid
function
:
"
+
onResult
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
removeVisitsByFilter
"
db
=
>
removeVisitsByFilter
(
db
filter
onResult
)
)
;
}
removeByFilter
(
filter
onResult
)
{
if
(
!
filter
|
|
typeof
filter
!
=
=
"
object
"
)
{
throw
new
TypeError
(
"
Expected
a
filter
object
"
)
;
}
let
hasHost
=
filter
.
host
;
if
(
hasHost
)
{
if
(
typeof
filter
.
host
!
=
=
"
string
"
)
{
throw
new
TypeError
(
"
host
should
be
a
string
"
)
;
}
filter
.
host
=
filter
.
host
.
toLowerCase
(
)
;
if
(
filter
.
host
.
length
>
1
&
&
filter
.
host
.
lastIndexOf
(
"
.
"
)
=
=
0
)
{
filter
.
host
=
filter
.
host
.
slice
(
1
)
;
}
}
let
hasBeginDate
=
"
beginDate
"
in
filter
;
if
(
hasBeginDate
)
{
this
.
ensureDate
(
filter
.
beginDate
)
;
}
let
hasEndDate
=
"
endDate
"
in
filter
;
if
(
hasEndDate
)
{
this
.
ensureDate
(
filter
.
endDate
)
;
}
if
(
hasBeginDate
&
&
hasEndDate
&
&
filter
.
beginDate
>
filter
.
endDate
)
{
throw
new
TypeError
(
"
beginDate
should
be
at
least
as
old
as
endDate
"
)
;
}
if
(
!
hasBeginDate
&
&
!
hasEndDate
&
&
!
hasHost
)
{
throw
new
TypeError
(
"
Expected
a
non
-
empty
filter
"
)
;
}
if
(
hasHost
&
&
(
!
/
^
(
\
.
?
(
[
.
a
-
z0
-
9
-
]
+
\
.
[
a
-
z0
-
9
-
]
+
)
?
|
[
a
-
z0
-
9
-
]
+
)
/
.
test
(
filter
.
host
)
|
|
filter
.
host
.
includes
(
"
.
.
"
)
)
)
{
throw
new
TypeError
(
"
Expected
well
formed
hostname
string
for
host
with
atmost
1
wildcard
.
"
)
;
}
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
{
throw
new
TypeError
(
"
Invalid
function
:
"
+
onResult
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
removeByFilter
"
db
=
>
removeByFilter
(
db
filter
onResult
)
)
;
}
hasVisits
(
guidOrURI
)
{
if
(
guidOrURI
instanceof
Ci
.
nsIURI
)
{
return
new
Promise
(
resolve
=
>
{
asyncHistory
.
isURIVisited
(
guidOrURI
(
aURI
aIsVisited
)
=
>
{
resolve
(
aIsVisited
)
;
}
)
;
}
)
;
}
guidOrURI
=
PlacesUtils
.
normalizeToURLOrGUID
(
guidOrURI
)
;
let
isGuid
=
typeof
guidOrURI
=
=
"
string
"
;
let
sqlFragment
=
isGuid
?
"
guid
=
:
val
"
:
"
url_hash
=
hash
(
:
val
)
AND
url
=
:
val
"
;
return
PlacesUtils
.
promiseDBConnection
(
)
.
then
(
async
db
=
>
{
let
rows
=
await
db
.
executeCached
(
SELECT
1
FROM
moz_places
WHERE
{
sqlFragment
}
AND
last_visit_date
NOTNULL
{
val
:
isGuid
?
guidOrURI
:
guidOrURI
.
href
}
)
;
return
!
!
rows
.
length
;
}
)
;
}
clear
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
clear
"
clear
)
;
}
isValidTransition
(
transition
)
{
return
Object
.
values
(
History
.
TRANSITIONS
)
.
includes
(
transition
)
;
}
ensureDate
(
arg
)
{
if
(
!
arg
|
|
typeof
arg
!
=
"
object
"
|
|
arg
.
constructor
.
name
!
=
"
Date
"
)
{
throw
new
TypeError
(
"
Expected
a
Date
got
"
+
arg
)
;
}
}
update
(
pageInfo
)
{
let
info
=
PlacesUtils
.
validatePageInfo
(
pageInfo
false
)
;
if
(
info
.
description
=
=
=
undefined
&
&
info
.
previewImageURL
=
=
=
undefined
&
&
info
.
annotations
=
=
=
undefined
)
{
throw
new
TypeError
(
"
pageInfo
object
must
at
least
have
either
a
description
previewImageURL
or
annotations
property
.
"
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
History
.
jsm
:
update
"
db
=
>
update
(
db
info
)
)
;
}
TRANSITIONS
:
{
LINK
:
Ci
.
nsINavHistoryService
.
TRANSITION_LINK
TYPED
:
Ci
.
nsINavHistoryService
.
TRANSITION_TYPED
BOOKMARK
:
Ci
.
nsINavHistoryService
.
TRANSITION_BOOKMARK
EMBED
:
Ci
.
nsINavHistoryService
.
TRANSITION_EMBED
REDIRECT_PERMANENT
:
Ci
.
nsINavHistoryService
.
TRANSITION_REDIRECT_PERMANENT
REDIRECT_TEMPORARY
:
Ci
.
nsINavHistoryService
.
TRANSITION_REDIRECT_TEMPORARY
DOWNLOAD
:
Ci
.
nsINavHistoryService
.
TRANSITION_DOWNLOAD
FRAMED_LINK
:
Ci
.
nsINavHistoryService
.
TRANSITION_FRAMED_LINK
RELOAD
:
Ci
.
nsINavHistoryService
.
TRANSITION_RELOAD
}
}
)
;
function
convertForUpdatePlaces
(
pageInfo
)
{
let
info
=
{
guid
:
pageInfo
.
guid
uri
:
PlacesUtils
.
toURI
(
pageInfo
.
url
)
title
:
pageInfo
.
title
visits
:
[
]
}
;
for
(
let
inVisit
of
pageInfo
.
visits
)
{
let
visit
=
{
visitDate
:
PlacesUtils
.
toPRTime
(
inVisit
.
date
)
transitionType
:
inVisit
.
transition
referrerURI
:
inVisit
.
referrer
?
PlacesUtils
.
toURI
(
inVisit
.
referrer
)
:
undefined
}
;
info
.
visits
.
push
(
visit
)
;
}
return
info
;
}
function
sqlBindPlaceholders
(
values
prefix
=
"
"
suffix
=
"
"
)
{
return
new
Array
(
values
.
length
)
.
fill
(
prefix
+
"
?
"
+
suffix
)
.
join
(
"
"
)
;
}
var
invalidateFrecencies
=
async
function
(
db
idList
)
{
if
(
!
idList
.
length
)
{
return
;
}
for
(
let
chunk
of
PlacesUtils
.
chunkArray
(
idList
db
.
variableLimit
)
)
{
await
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
CALCULATE_FRECENCY
(
id
)
WHERE
id
in
(
{
sqlBindPlaceholders
(
chunk
)
}
)
chunk
)
;
await
db
.
execute
(
UPDATE
moz_places
SET
hidden
=
0
WHERE
id
in
(
{
sqlBindPlaceholders
(
chunk
)
}
)
AND
frecency
<
>
0
chunk
)
;
}
const
observers
=
PlacesUtils
.
history
.
getObservers
(
)
;
notify
(
observers
"
onManyFrecenciesChanged
"
)
;
await
db
.
execute
(
DELETE
FROM
moz_updateoriginsupdate_temp
)
;
}
;
var
clear
=
async
function
(
db
)
{
await
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
execute
(
DELETE
FROM
moz_places
WHERE
foreign_count
=
0
)
;
await
db
.
execute
(
DELETE
FROM
moz_updateoriginsdelete_temp
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_pages_w_icons
WHERE
page_url_hash
NOT
IN
(
SELECT
url_hash
FROM
moz_places
)
)
;
await
removeOrphanIcons
(
db
)
;
await
db
.
execute
(
DELETE
FROM
moz_annos
WHERE
NOT
EXISTS
(
SELECT
1
FROM
moz_places
WHERE
id
=
place_id
)
)
;
await
db
.
execute
(
DELETE
FROM
moz_inputhistory
WHERE
place_id
IN
(
SELECT
i
.
place_id
FROM
moz_inputhistory
i
LEFT
JOIN
moz_places
h
ON
h
.
id
=
i
.
place_id
WHERE
h
.
id
IS
NULL
)
)
;
await
db
.
execute
(
"
DELETE
FROM
moz_historyvisits
"
)
;
await
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
(
CASE
WHEN
url_hash
BETWEEN
hash
(
"
place
"
"
prefix_lo
"
)
AND
hash
(
"
place
"
"
prefix_hi
"
)
THEN
0
ELSE
-
1
END
)
WHERE
frecency
>
0
)
;
}
)
;
let
observers
=
PlacesUtils
.
history
.
getObservers
(
)
;
notify
(
observers
"
onManyFrecenciesChanged
"
)
;
PlacesObservers
.
notifyListeners
(
[
new
PlacesHistoryCleared
(
)
]
)
;
await
db
.
execute
(
DELETE
FROM
moz_updateoriginsupdate_temp
)
;
}
;
var
cleanupPages
=
async
function
(
db
pages
)
{
await
invalidateFrecencies
(
db
pages
.
filter
(
p
=
>
p
.
hasForeign
|
|
p
.
hasVisits
)
.
map
(
p
=
>
p
.
id
)
)
;
let
pagesToRemove
=
pages
.
filter
(
p
=
>
!
p
.
hasForeign
&
&
!
p
.
hasVisits
)
;
if
(
!
pagesToRemove
.
length
)
{
return
;
}
for
(
let
chunk
of
PlacesUtils
.
chunkArray
(
pagesToRemove
db
.
variableLimit
)
)
{
let
idsToRemove
=
chunk
.
map
(
p
=
>
p
.
id
)
;
await
db
.
execute
(
DELETE
FROM
moz_places
WHERE
id
IN
(
{
sqlBindPlaceholders
(
idsToRemove
)
}
)
AND
foreign_count
=
0
AND
last_visit_date
ISNULL
idsToRemove
)
;
let
hashesToRemove
=
chunk
.
map
(
p
=
>
p
.
hash
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_pages_w_icons
WHERE
page_url_hash
IN
(
{
sqlBindPlaceholders
(
hashesToRemove
)
}
)
hashesToRemove
)
;
await
db
.
execute
(
DELETE
FROM
moz_annos
WHERE
place_id
IN
(
{
sqlBindPlaceholders
(
idsToRemove
)
}
)
idsToRemove
)
;
await
db
.
execute
(
DELETE
FROM
moz_inputhistory
WHERE
place_id
IN
(
{
sqlBindPlaceholders
(
idsToRemove
)
}
)
idsToRemove
)
;
}
await
db
.
executeCached
(
DELETE
FROM
moz_updateoriginsdelete_temp
)
;
await
removeOrphanIcons
(
db
)
;
}
;
function
removeOrphanIcons
(
db
)
{
return
db
.
executeCached
(
DELETE
FROM
moz_icons
WHERE
id
IN
(
SELECT
id
FROM
moz_icons
WHERE
root
=
0
UNION
ALL
SELECT
id
FROM
moz_icons
WHERE
root
=
1
AND
get_host_and_port
(
icon_url
)
NOT
IN
(
SELECT
host
FROM
moz_origins
)
AND
fixup_url
(
get_host_and_port
(
icon_url
)
)
NOT
IN
(
SELECT
host
FROM
moz_origins
)
EXCEPT
SELECT
icon_id
FROM
moz_icons_to_pages
)
)
;
}
var
notifyCleanup
=
async
function
(
db
pages
transition
=
-
1
)
{
let
notifiedCount
=
0
;
let
observers
=
PlacesUtils
.
history
.
getObservers
(
)
;
let
bookmarkObservers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
let
reason
=
Ci
.
nsINavHistoryObserver
.
REASON_DELETED
;
for
(
let
page
of
pages
)
{
let
uri
=
Services
.
io
.
newURI
(
page
.
url
.
href
)
;
let
guid
=
page
.
guid
;
if
(
page
.
hasVisits
|
|
page
.
hasForeign
)
{
notify
(
observers
"
onDeleteVisits
"
[
uri
page
.
hasVisits
>
0
guid
reason
transition
]
)
;
if
(
!
page
.
hasVisits
)
{
PlacesUtils
.
bookmarks
.
fetch
(
{
url
:
page
.
url
}
async
bookmark
=
>
{
let
itemId
=
await
PlacesUtils
.
promiseItemId
(
bookmark
.
guid
)
;
let
parentId
=
await
PlacesUtils
.
promiseItemId
(
bookmark
.
parentGuid
)
;
notify
(
bookmarkObservers
"
onItemChanged
"
[
itemId
"
cleartime
"
false
"
"
0
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
parentId
bookmark
.
guid
bookmark
.
parentGuid
"
"
PlacesUtils
.
bookmarks
.
SOURCES
.
DEFAULT
]
{
concurrent
:
true
}
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
}
else
{
notify
(
observers
"
onDeleteURI
"
[
uri
guid
reason
]
)
;
}
if
(
+
+
notifiedCount
%
NOTIFICATION_CHUNK_SIZE
=
=
0
)
{
await
Promise
.
resolve
(
)
;
}
}
}
;
var
notifyOnResult
=
async
function
(
data
onResult
)
{
if
(
!
onResult
)
{
return
;
}
let
notifiedCount
=
0
;
for
(
let
info
of
data
)
{
try
{
onResult
(
info
)
;
}
catch
(
ex
)
{
Promise
.
reject
(
ex
)
;
}
if
(
+
+
notifiedCount
%
ONRESULT_CHUNK_SIZE
=
=
0
)
{
await
Promise
.
resolve
(
)
;
}
}
}
;
var
fetch
=
async
function
(
db
guidOrURL
options
)
{
let
whereClauseFragment
=
"
"
;
let
params
=
{
}
;
if
(
guidOrURL
instanceof
URL
)
{
whereClauseFragment
=
"
WHERE
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
"
;
params
.
url
=
guidOrURL
.
href
;
}
else
{
whereClauseFragment
=
"
WHERE
h
.
guid
=
:
guid
"
;
params
.
guid
=
guidOrURL
;
}
let
visitSelectionFragment
=
"
"
;
let
joinFragment
=
"
"
;
let
visitOrderFragment
=
"
"
;
if
(
options
.
includeVisits
)
{
visitSelectionFragment
=
"
v
.
visit_date
v
.
visit_type
"
;
joinFragment
=
"
JOIN
moz_historyvisits
v
ON
h
.
id
=
v
.
place_id
"
;
visitOrderFragment
=
"
ORDER
BY
v
.
visit_date
DESC
"
;
}
let
pageMetaSelectionFragment
=
"
"
;
if
(
options
.
includeMeta
)
{
pageMetaSelectionFragment
=
"
description
preview_image_url
"
;
}
let
query
=
SELECT
h
.
id
guid
url
title
frecency
{
pageMetaSelectionFragment
}
{
visitSelectionFragment
}
FROM
moz_places
h
{
joinFragment
}
{
whereClauseFragment
}
{
visitOrderFragment
}
;
let
pageInfo
=
null
;
let
placeId
=
null
;
await
db
.
executeCached
(
query
params
row
=
>
{
if
(
pageInfo
=
=
=
null
)
{
pageInfo
=
{
guid
:
row
.
getResultByName
(
"
guid
"
)
url
:
new
URL
(
row
.
getResultByName
(
"
url
"
)
)
frecency
:
row
.
getResultByName
(
"
frecency
"
)
title
:
row
.
getResultByName
(
"
title
"
)
|
|
"
"
}
;
placeId
=
row
.
getResultByName
(
"
id
"
)
;
}
if
(
options
.
includeMeta
)
{
pageInfo
.
description
=
row
.
getResultByName
(
"
description
"
)
|
|
"
"
;
let
previewImageURL
=
row
.
getResultByName
(
"
preview_image_url
"
)
;
pageInfo
.
previewImageURL
=
previewImageURL
?
new
URL
(
previewImageURL
)
:
null
;
}
if
(
options
.
includeVisits
)
{
if
(
!
(
"
visits
"
in
pageInfo
)
)
{
pageInfo
.
visits
=
[
]
;
}
let
date
=
PlacesUtils
.
toDate
(
row
.
getResultByName
(
"
visit_date
"
)
)
;
let
transition
=
row
.
getResultByName
(
"
visit_type
"
)
;
pageInfo
.
visits
.
push
(
{
date
transition
}
)
;
}
}
)
;
if
(
pageInfo
&
&
options
.
includeAnnotations
)
{
let
rows
=
await
db
.
executeCached
(
SELECT
n
.
name
a
.
content
FROM
moz_anno_attributes
n
JOIN
moz_annos
a
ON
n
.
id
=
a
.
anno_attribute_id
WHERE
a
.
place_id
=
:
placeId
{
placeId
}
)
;
pageInfo
.
annotations
=
new
Map
(
rows
.
map
(
row
=
>
[
row
.
getResultByName
(
"
name
"
)
row
.
getResultByName
(
"
content
"
)
]
)
)
;
}
return
pageInfo
;
}
;
var
fetchAnnotatedPages
=
async
function
(
db
annotations
)
{
let
result
=
new
Map
(
)
;
let
rows
=
await
db
.
execute
(
SELECT
n
.
name
h
.
url
a
.
content
FROM
moz_anno_attributes
n
JOIN
moz_annos
a
ON
n
.
id
=
a
.
anno_attribute_id
JOIN
moz_places
h
ON
h
.
id
=
a
.
place_id
WHERE
n
.
name
IN
(
{
new
Array
(
annotations
.
length
)
.
fill
(
"
?
"
)
.
join
(
"
"
)
}
)
annotations
)
;
for
(
let
row
of
rows
)
{
let
uri
;
try
{
uri
=
new
URL
(
row
.
getResultByName
(
"
url
"
)
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Invalid
URL
read
from
database
in
fetchAnnotatedPages
"
)
;
continue
;
}
let
anno
=
{
uri
content
:
row
.
getResultByName
(
"
content
"
)
}
;
let
annoName
=
row
.
getResultByName
(
"
name
"
)
;
let
pageAnnos
=
result
.
get
(
annoName
)
;
if
(
!
pageAnnos
)
{
pageAnnos
=
[
]
;
result
.
set
(
annoName
pageAnnos
)
;
}
pageAnnos
.
push
(
anno
)
;
}
return
result
;
}
;
var
removeVisitsByFilter
=
async
function
(
db
filter
onResult
=
null
)
{
let
conditions
=
[
]
;
let
args
=
{
}
;
let
transition
=
-
1
;
if
(
"
beginDate
"
in
filter
)
{
conditions
.
push
(
"
v
.
visit_date
>
=
:
begin
*
1000
"
)
;
args
.
begin
=
Number
(
filter
.
beginDate
)
;
}
if
(
"
endDate
"
in
filter
)
{
conditions
.
push
(
"
v
.
visit_date
<
=
:
end
*
1000
"
)
;
args
.
end
=
Number
(
filter
.
endDate
)
;
}
if
(
"
limit
"
in
filter
)
{
args
.
limit
=
Number
(
filter
.
limit
)
;
}
if
(
"
transition
"
in
filter
)
{
conditions
.
push
(
"
v
.
visit_type
=
:
transition
"
)
;
args
.
transition
=
filter
.
transition
;
transition
=
filter
.
transition
;
}
let
optionalJoin
=
"
"
;
if
(
"
url
"
in
filter
)
{
let
url
=
filter
.
url
;
if
(
url
instanceof
Ci
.
nsIURI
)
{
url
=
filter
.
url
.
spec
;
}
else
{
url
=
new
URL
(
url
)
.
href
;
}
optionalJoin
=
JOIN
moz_places
h
ON
h
.
id
=
v
.
place_id
;
conditions
.
push
(
"
h
.
url_hash
=
hash
(
:
url
)
"
"
h
.
url
=
:
url
"
)
;
args
.
url
=
url
;
}
let
visitsToRemove
=
[
]
;
let
pagesToInspect
=
new
Set
(
)
;
let
onResultData
=
onResult
?
[
]
:
null
;
await
db
.
executeCached
(
SELECT
v
.
id
place_id
visit_date
/
1000
AS
date
visit_type
FROM
moz_historyvisits
v
{
optionalJoin
}
WHERE
{
conditions
.
join
(
"
AND
"
)
}
{
args
.
limit
?
"
LIMIT
:
limit
"
:
"
"
}
args
row
=
>
{
let
id
=
row
.
getResultByName
(
"
id
"
)
;
let
place_id
=
row
.
getResultByName
(
"
place_id
"
)
;
visitsToRemove
.
push
(
id
)
;
pagesToInspect
.
add
(
place_id
)
;
if
(
onResult
)
{
onResultData
.
push
(
{
date
:
new
Date
(
row
.
getResultByName
(
"
date
"
)
)
transition
:
row
.
getResultByName
(
"
visit_type
"
)
}
)
;
}
}
)
;
if
(
!
visitsToRemove
.
length
)
{
return
false
;
}
let
pages
=
[
]
;
await
db
.
executeTransaction
(
async
function
(
)
{
for
(
let
chunk
of
PlacesUtils
.
chunkArray
(
visitsToRemove
db
.
variableLimit
)
)
{
await
db
.
execute
(
DELETE
FROM
moz_historyvisits
WHERE
id
IN
(
{
sqlBindPlaceholders
(
chunk
)
}
)
chunk
)
;
}
for
(
let
chunk
of
PlacesUtils
.
chunkArray
(
[
.
.
.
pagesToInspect
]
db
.
variableLimit
)
)
{
await
db
.
execute
(
SELECT
id
url
url_hash
guid
(
foreign_count
!
=
0
)
AS
has_foreign
(
last_visit_date
NOTNULL
)
as
has_visits
FROM
moz_places
WHERE
id
IN
(
{
sqlBindPlaceholders
(
chunk
)
}
)
chunk
row
=
>
{
let
page
=
{
id
:
row
.
getResultByName
(
"
id
"
)
guid
:
row
.
getResultByName
(
"
guid
"
)
hasForeign
:
row
.
getResultByName
(
"
has_foreign
"
)
hasVisits
:
row
.
getResultByName
(
"
has_visits
"
)
url
:
new
URL
(
row
.
getResultByName
(
"
url
"
)
)
hash
:
row
.
getResultByName
(
"
url_hash
"
)
}
;
pages
.
push
(
page
)
;
}
)
;
}
await
cleanupPages
(
db
pages
)
;
}
)
;
notifyCleanup
(
db
pages
transition
)
;
notifyOnResult
(
onResultData
onResult
)
;
return
!
!
visitsToRemove
.
length
;
}
;
var
removeByFilter
=
async
function
(
db
filter
onResult
=
null
)
{
let
dateFilterSQLFragment
=
"
"
;
let
conditions
=
[
]
;
let
params
=
{
}
;
if
(
"
beginDate
"
in
filter
)
{
conditions
.
push
(
"
v
.
visit_date
>
=
:
begin
"
)
;
params
.
begin
=
PlacesUtils
.
toPRTime
(
filter
.
beginDate
)
;
}
if
(
"
endDate
"
in
filter
)
{
conditions
.
push
(
"
v
.
visit_date
<
=
:
end
"
)
;
params
.
end
=
PlacesUtils
.
toPRTime
(
filter
.
endDate
)
;
}
if
(
conditions
.
length
!
=
=
0
)
{
dateFilterSQLFragment
=
EXISTS
(
SELECT
id
FROM
moz_historyvisits
v
WHERE
v
.
place_id
=
h
.
id
AND
{
conditions
.
join
(
"
AND
"
)
}
LIMIT
1
)
;
}
let
hostFilterSQLFragment
=
"
"
;
if
(
filter
.
host
)
{
let
revHost
=
filter
.
host
.
split
(
"
"
)
.
reverse
(
)
.
join
(
"
"
)
;
if
(
filter
.
host
=
=
"
.
"
)
{
hostFilterSQLFragment
=
h
.
rev_host
=
:
revHost
;
}
else
if
(
filter
.
host
.
startsWith
(
"
.
"
)
)
{
revHost
=
revHost
.
slice
(
0
-
1
)
;
hostFilterSQLFragment
=
h
.
rev_host
between
:
revHost
|
|
"
.
"
and
:
revHost
|
|
"
/
"
;
}
else
{
hostFilterSQLFragment
=
h
.
rev_host
=
:
revHost
|
|
"
.
"
;
}
params
.
revHost
=
revHost
;
}
let
fragmentArray
=
[
hostFilterSQLFragment
dateFilterSQLFragment
]
;
let
query
=
SELECT
h
.
id
url
url_hash
rev_host
guid
title
frecency
foreign_count
FROM
moz_places
h
WHERE
(
{
fragmentArray
.
filter
(
f
=
>
f
!
=
=
"
"
)
.
join
(
"
)
AND
(
"
)
}
)
;
let
onResultData
=
onResult
?
[
]
:
null
;
let
pages
=
[
]
;
let
hasPagesToRemove
=
false
;
await
db
.
executeCached
(
query
params
row
=
>
{
let
hasForeign
=
row
.
getResultByName
(
"
foreign_count
"
)
!
=
0
;
if
(
!
hasForeign
)
{
hasPagesToRemove
=
true
;
}
let
id
=
row
.
getResultByName
(
"
id
"
)
;
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
url
=
row
.
getResultByName
(
"
url
"
)
;
let
page
=
{
id
guid
hasForeign
hasVisits
:
false
url
:
new
URL
(
url
)
hash
:
row
.
getResultByName
(
"
url_hash
"
)
}
;
pages
.
push
(
page
)
;
if
(
onResult
)
{
onResultData
.
push
(
{
guid
title
:
row
.
getResultByName
(
"
title
"
)
frecency
:
row
.
getResultByName
(
"
frecency
"
)
url
:
new
URL
(
url
)
}
)
;
}
}
)
;
if
(
pages
.
length
=
=
=
0
)
{
return
false
;
}
await
db
.
executeTransaction
(
async
function
(
)
{
let
pageIds
=
pages
.
map
(
p
=
>
p
.
id
)
;
for
(
let
chunk
of
PlacesUtils
.
chunkArray
(
pageIds
db
.
variableLimit
)
)
{
await
db
.
execute
(
DELETE
FROM
moz_historyvisits
WHERE
place_id
IN
(
{
sqlBindPlaceholders
(
chunk
)
}
)
chunk
)
;
}
await
cleanupPages
(
db
pages
)
;
}
)
;
notifyCleanup
(
db
pages
)
;
notifyOnResult
(
onResultData
onResult
)
;
return
hasPagesToRemove
;
}
;
var
remove
=
async
function
(
db
{
guids
urls
}
onResult
=
null
)
{
let
onResultData
=
onResult
?
[
]
:
null
;
let
pages
=
[
]
;
let
hasPagesToRemove
=
false
;
function
onRow
(
row
)
{
let
hasForeign
=
row
.
getResultByName
(
"
foreign_count
"
)
!
=
0
;
if
(
!
hasForeign
)
{
hasPagesToRemove
=
true
;
}
let
id
=
row
.
getResultByName
(
"
id
"
)
;
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
url
=
row
.
getResultByName
(
"
url
"
)
;
let
page
=
{
id
guid
hasForeign
hasVisits
:
false
url
:
new
URL
(
url
)
hash
:
row
.
getResultByName
(
"
url_hash
"
)
}
;
pages
.
push
(
page
)
;
if
(
onResult
)
{
onResultData
.
push
(
{
guid
title
:
row
.
getResultByName
(
"
title
"
)
frecency
:
row
.
getResultByName
(
"
frecency
"
)
url
:
new
URL
(
url
)
}
)
;
}
}
for
(
let
chunk
of
PlacesUtils
.
chunkArray
(
guids
db
.
variableLimit
)
)
{
let
query
=
SELECT
id
url
url_hash
guid
foreign_count
title
frecency
FROM
moz_places
WHERE
guid
IN
(
{
sqlBindPlaceholders
(
guids
)
}
)
;
await
db
.
execute
(
query
chunk
onRow
)
;
}
for
(
let
chunk
of
PlacesUtils
.
chunkArray
(
urls
db
.
variableLimit
)
)
{
let
variables
=
Array
.
from
(
{
length
:
chunk
.
length
}
(
_
i
)
=
>
"
?
"
+
(
i
+
1
)
)
;
let
query
=
SELECT
id
url
url_hash
guid
foreign_count
title
frecency
FROM
moz_places
WHERE
url_hash
IN
(
{
variables
.
map
(
v
=
>
hash
(
{
v
}
)
)
.
join
(
"
"
)
}
)
AND
url
IN
(
{
variables
.
join
(
"
"
)
}
)
;
await
db
.
execute
(
query
chunk
onRow
)
;
}
if
(
!
pages
.
length
)
{
return
false
;
}
await
db
.
executeTransaction
(
async
function
(
)
{
let
pageIds
=
pages
.
map
(
p
=
>
p
.
id
)
;
for
(
let
chunk
of
PlacesUtils
.
chunkArray
(
pageIds
db
.
variableLimit
)
)
{
await
db
.
execute
(
DELETE
FROM
moz_historyvisits
WHERE
place_id
IN
(
{
sqlBindPlaceholders
(
chunk
)
}
)
chunk
)
;
}
await
cleanupPages
(
db
pages
)
;
}
)
;
notifyCleanup
(
db
pages
)
;
notifyOnResult
(
onResultData
onResult
)
;
return
hasPagesToRemove
;
}
;
function
mergeUpdateInfoIntoPageInfo
(
updateInfo
pageInfo
=
{
}
)
{
pageInfo
.
guid
=
updateInfo
.
guid
;
pageInfo
.
title
=
updateInfo
.
title
;
if
(
!
pageInfo
.
url
)
{
pageInfo
.
url
=
new
URL
(
updateInfo
.
uri
.
spec
)
;
pageInfo
.
title
=
updateInfo
.
title
;
pageInfo
.
visits
=
updateInfo
.
visits
.
map
(
visit
=
>
{
return
{
date
:
PlacesUtils
.
toDate
(
visit
.
visitDate
)
transition
:
visit
.
transitionType
referrer
:
visit
.
referrerURI
?
new
URL
(
visit
.
referrerURI
.
spec
)
:
null
}
;
}
)
;
}
return
pageInfo
;
}
var
insert
=
function
(
db
pageInfo
)
{
let
info
=
convertForUpdatePlaces
(
pageInfo
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
asyncHistory
.
updatePlaces
(
info
{
handleError
:
error
=
>
{
reject
(
error
)
;
}
handleResult
:
result
=
>
{
pageInfo
=
mergeUpdateInfoIntoPageInfo
(
result
pageInfo
)
;
}
handleCompletion
:
(
)
=
>
{
resolve
(
pageInfo
)
;
}
}
)
;
}
)
;
}
;
var
insertMany
=
function
(
db
pageInfos
onResult
onError
)
{
let
infos
=
[
]
;
let
onResultData
=
[
]
;
let
onErrorData
=
[
]
;
for
(
let
pageInfo
of
pageInfos
)
{
let
info
=
convertForUpdatePlaces
(
pageInfo
)
;
infos
.
push
(
info
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
asyncHistory
.
updatePlaces
(
infos
{
handleError
:
(
resultCode
result
)
=
>
{
let
pageInfo
=
mergeUpdateInfoIntoPageInfo
(
result
)
;
onErrorData
.
push
(
pageInfo
)
;
}
handleResult
:
result
=
>
{
let
pageInfo
=
mergeUpdateInfoIntoPageInfo
(
result
)
;
onResultData
.
push
(
pageInfo
)
;
}
ignoreErrors
:
!
onError
ignoreResults
:
!
onResult
handleCompletion
:
updatedCount
=
>
{
notifyOnResult
(
onResultData
onResult
)
;
notifyOnResult
(
onErrorData
onError
)
;
if
(
updatedCount
>
0
)
{
resolve
(
)
;
}
else
{
reject
(
{
message
:
"
No
items
were
added
to
history
.
"
}
)
;
}
}
}
)
;
}
)
;
}
;
var
update
=
async
function
(
db
pageInfo
)
{
let
id
;
if
(
typeof
pageInfo
.
guid
=
=
=
"
string
"
)
{
let
rows
=
await
db
.
executeCached
(
"
SELECT
id
FROM
moz_places
WHERE
guid
=
:
guid
"
{
guid
:
pageInfo
.
guid
}
)
;
id
=
rows
.
length
?
rows
[
0
]
.
getResultByName
(
"
id
"
)
:
null
;
}
else
{
let
rows
=
await
db
.
executeCached
(
"
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
"
{
url
:
pageInfo
.
url
.
href
}
)
;
id
=
rows
.
length
?
rows
[
0
]
.
getResultByName
(
"
id
"
)
:
null
;
}
if
(
!
id
)
{
return
;
}
let
updateFragments
=
[
]
;
let
params
=
{
}
;
if
(
"
description
"
in
pageInfo
)
{
updateFragments
.
push
(
"
description
"
)
;
params
.
description
=
pageInfo
.
description
;
}
if
(
"
previewImageURL
"
in
pageInfo
)
{
updateFragments
.
push
(
"
preview_image_url
"
)
;
params
.
preview_image_url
=
pageInfo
.
previewImageURL
?
pageInfo
.
previewImageURL
.
href
:
null
;
}
if
(
updateFragments
.
length
)
{
await
db
.
execute
(
UPDATE
moz_places
SET
{
updateFragments
.
map
(
v
=
>
{
v
}
=
:
{
v
}
)
.
join
(
"
"
)
}
WHERE
id
=
:
id
AND
(
{
updateFragments
.
map
(
v
=
>
IFNULL
(
{
v
}
'
'
)
<
>
IFNULL
(
:
{
v
}
'
'
)
)
.
join
(
"
OR
"
)
}
)
{
id
.
.
.
params
}
)
;
}
if
(
pageInfo
.
annotations
)
{
let
annosToRemove
=
[
]
;
let
annosToUpdate
=
[
]
;
for
(
let
anno
of
pageInfo
.
annotations
)
{
anno
[
1
]
?
annosToUpdate
.
push
(
anno
[
0
]
)
:
annosToRemove
.
push
(
anno
[
0
]
)
;
}
await
db
.
executeTransaction
(
async
function
(
)
{
if
(
annosToUpdate
.
length
)
{
await
db
.
execute
(
INSERT
OR
IGNORE
INTO
moz_anno_attributes
(
name
)
VALUES
{
Array
.
from
(
annosToUpdate
.
keys
(
)
)
.
map
(
k
=
>
(
:
{
k
}
)
)
.
join
(
"
"
)
}
Object
.
assign
(
{
}
annosToUpdate
)
)
;
for
(
let
anno
of
annosToUpdate
)
{
let
content
=
pageInfo
.
annotations
.
get
(
anno
)
;
let
type
=
typeof
content
=
=
"
string
"
?
History
.
ANNOTATION_TYPE_STRING
:
History
.
ANNOTATION_TYPE_INT64
;
let
date
=
PlacesUtils
.
toPRTime
(
new
Date
(
)
)
;
await
db
.
execute
(
INSERT
OR
REPLACE
INTO
moz_annos
(
place_id
anno_attribute_id
content
flags
expiration
type
dateAdded
lastModified
)
VALUES
(
:
id
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
:
anno_name
)
:
content
0
:
expiration
:
type
:
date_added
:
last_modified
)
{
id
anno_name
:
anno
content
expiration
:
History
.
ANNOTATION_EXPIRE_NEVER
type
date_added
:
date
last_modified
:
date
}
)
;
}
}
for
(
let
anno
of
annosToRemove
)
{
await
db
.
execute
(
DELETE
FROM
moz_annos
WHERE
place_id
=
:
id
AND
anno_attribute_id
=
(
SELECT
id
FROM
moz_anno_attributes
WHERE
name
=
:
anno_name
)
{
id
anno_name
:
anno
}
)
;
}
}
)
;
}
}
;
