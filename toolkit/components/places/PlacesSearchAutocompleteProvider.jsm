"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PlacesSearchAutocompleteProvider
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SearchSuggestionController
"
"
resource
:
/
/
gre
/
modules
/
SearchSuggestionController
.
jsm
"
)
;
const
SEARCH_ENGINE_TOPIC
=
"
browser
-
search
-
engine
-
modified
"
;
const
SearchAutocompleteProviderInternal
=
{
priorityMatches
:
null
aliasMatches
:
null
defaultMatch
:
null
initialize
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
Services
.
search
.
init
(
status
=
>
{
if
(
!
Components
.
isSuccessCode
(
status
)
)
{
reject
(
new
Error
(
"
Unable
to
initialize
search
service
.
"
)
)
;
}
try
{
this
.
_refresh
(
)
;
Services
.
obs
.
addObserver
(
this
SEARCH_ENGINE_TOPIC
true
)
;
this
.
initialized
=
true
;
resolve
(
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
}
}
)
;
}
)
;
}
initialized
:
false
observe
(
subject
topic
data
)
{
switch
(
data
)
{
case
"
engine
-
added
"
:
case
"
engine
-
changed
"
:
case
"
engine
-
removed
"
:
case
"
engine
-
current
"
:
this
.
_refresh
(
)
;
}
}
_refresh
(
)
{
this
.
priorityMatches
=
[
]
;
this
.
aliasMatches
=
[
]
;
this
.
defaultMatch
=
null
;
let
currentEngine
=
Services
.
search
.
currentEngine
;
if
(
currentEngine
)
{
this
.
defaultMatch
=
{
engineName
:
currentEngine
.
name
iconUrl
:
currentEngine
.
iconURI
?
currentEngine
.
iconURI
.
spec
:
null
}
;
}
Services
.
search
.
getVisibleEngines
(
)
.
forEach
(
e
=
>
this
.
_addEngine
(
e
)
)
;
}
_addEngine
(
engine
)
{
if
(
engine
.
alias
)
{
this
.
aliasMatches
.
push
(
{
alias
:
engine
.
alias
engineName
:
engine
.
name
iconUrl
:
engine
.
iconURI
?
engine
.
iconURI
.
spec
:
null
}
)
;
}
let
domain
=
engine
.
getResultDomain
(
)
;
if
(
domain
)
{
this
.
priorityMatches
.
push
(
{
token
:
domain
url
:
engine
.
searchForm
engineName
:
engine
.
name
iconUrl
:
engine
.
iconURI
?
engine
.
iconURI
.
spec
:
null
}
)
;
}
}
getSuggestionController
(
searchToken
inPrivateContext
maxLocalResults
maxRemoteResults
userContextId
)
{
let
engine
=
Services
.
search
.
currentEngine
;
if
(
!
engine
)
{
return
null
;
}
return
new
SearchSuggestionControllerWrapper
(
engine
searchToken
inPrivateContext
maxLocalResults
maxRemoteResults
userContextId
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
function
SearchSuggestionControllerWrapper
(
engine
searchToken
inPrivateContext
maxLocalResults
maxRemoteResults
userContextId
)
{
this
.
_controller
=
new
SearchSuggestionController
(
)
;
this
.
_controller
.
maxLocalResults
=
maxLocalResults
;
this
.
_controller
.
maxRemoteResults
=
maxRemoteResults
;
let
promise
=
this
.
_controller
.
fetch
(
searchToken
inPrivateContext
engine
userContextId
)
;
this
.
_suggestions
=
[
]
;
this
.
_success
=
false
;
this
.
_promise
=
promise
.
then
(
results
=
>
{
this
.
_success
=
true
;
this
.
_suggestions
=
[
]
;
if
(
results
)
{
this
.
_suggestions
=
this
.
_suggestions
.
concat
(
results
.
local
.
map
(
r
=
>
(
{
suggestion
:
r
historical
:
true
}
)
)
)
;
this
.
_suggestions
=
this
.
_suggestions
.
concat
(
results
.
remote
.
map
(
r
=
>
(
{
suggestion
:
r
historical
:
false
}
)
)
)
;
}
}
)
.
catch
(
err
=
>
{
}
)
;
}
SearchSuggestionControllerWrapper
.
prototype
=
{
get
fetchCompletePromise
(
)
{
return
this
.
_promise
;
}
consume
(
)
{
if
(
!
this
.
_suggestions
.
length
)
return
null
;
let
{
suggestion
historical
}
=
this
.
_suggestions
.
shift
(
)
;
return
{
match
:
SearchAutocompleteProviderInternal
.
defaultMatch
suggestion
historical
}
;
}
get
resultsCount
(
)
{
return
this
.
_success
?
this
.
_suggestions
.
length
:
-
1
;
}
stop
(
)
{
this
.
_controller
.
stop
(
)
;
}
}
;
var
gInitializationPromise
=
null
;
var
PlacesSearchAutocompleteProvider
=
Object
.
freeze
(
{
ensureInitialized
(
)
{
if
(
!
gInitializationPromise
)
{
gInitializationPromise
=
SearchAutocompleteProviderInternal
.
initialize
(
)
;
}
return
gInitializationPromise
;
}
async
findMatchByToken
(
searchToken
)
{
await
this
.
ensureInitialized
(
)
;
return
SearchAutocompleteProviderInternal
.
priorityMatches
.
find
(
m
=
>
m
.
token
.
startsWith
(
searchToken
)
)
;
}
async
findMatchByAlias
(
searchToken
)
{
await
this
.
ensureInitialized
(
)
;
return
SearchAutocompleteProviderInternal
.
aliasMatches
.
find
(
m
=
>
m
.
alias
.
toLocaleLowerCase
(
)
=
=
searchToken
.
toLocaleLowerCase
(
)
)
;
}
async
getDefaultMatch
(
)
{
await
this
.
ensureInitialized
(
)
;
return
SearchAutocompleteProviderInternal
.
defaultMatch
;
}
parseSubmissionURL
(
url
)
{
if
(
!
SearchAutocompleteProviderInternal
.
initialized
)
{
throw
new
Error
(
"
The
component
has
not
been
initialized
.
"
)
;
}
let
parseUrlResult
=
Services
.
search
.
parseSubmissionURL
(
url
)
;
return
parseUrlResult
.
engine
&
&
{
engineName
:
parseUrlResult
.
engine
.
name
terms
:
parseUrlResult
.
terms
}
;
}
getSuggestionController
(
searchToken
inPrivateContext
maxLocalResults
maxRemoteResults
userContextId
)
{
if
(
!
SearchAutocompleteProviderInternal
.
initialized
)
{
throw
new
Error
(
"
The
component
has
not
been
initialized
.
"
)
;
}
return
SearchAutocompleteProviderInternal
.
getSuggestionController
(
searchToken
inPrivateContext
maxLocalResults
maxRemoteResults
userContextId
)
;
}
}
)
;
