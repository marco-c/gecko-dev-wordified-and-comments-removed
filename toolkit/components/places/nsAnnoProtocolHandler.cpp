#
include
"
nsAnnoProtocolHandler
.
h
"
#
include
"
nsFaviconService
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIInputStreamChannel
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsIStandardURL
.
h
"
#
include
"
nsIStringStream
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsInputStreamPump
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
SimpleChannel
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
storage
.
h
"
#
include
"
Helpers
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
places
;
static
nsresult
GetDefaultIcon
(
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
aChannel
)
{
nsCOMPtr
<
nsIURI
>
defaultIconURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
defaultIconURI
)
NS_LITERAL_CSTRING
(
FAVICON_DEFAULT_URL
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_NewChannelInternal
(
aChannel
defaultIconURI
aLoadInfo
)
;
}
namespace
{
class
faviconAsyncLoader
:
public
AsyncStatementCallback
{
public
:
faviconAsyncLoader
(
nsIChannel
*
aChannel
nsIStreamListener
*
aListener
)
:
mChannel
(
aChannel
)
mListener
(
aListener
)
{
NS_ASSERTION
(
aChannel
"
Not
providing
a
channel
will
result
in
crashes
!
"
)
;
NS_ASSERTION
(
aListener
"
Not
providing
a
stream
listener
will
result
in
crashes
!
"
)
;
}
NS_IMETHOD
HandleResult
(
mozIStorageResultSet
*
aResultSet
)
override
{
nsCOMPtr
<
mozIStorageRow
>
row
;
nsresult
rv
=
aResultSet
-
>
GetNextRow
(
getter_AddRefs
(
row
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
mimeType
;
(
void
)
row
-
>
GetUTF8String
(
1
mimeType
)
;
NS_ENSURE_FALSE
(
mimeType
.
IsEmpty
(
)
NS_OK
)
;
rv
=
mChannel
-
>
SetContentType
(
mimeType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint8_t
*
favicon
;
uint32_t
size
=
0
;
rv
=
row
-
>
GetBlob
(
0
&
size
&
favicon
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
stream
)
reinterpret_cast
<
char
*
>
(
favicon
)
size
NS_ASSIGNMENT_ADOPT
)
;
if
(
NS_FAILED
(
rv
)
)
{
free
(
favicon
)
;
return
rv
;
}
RefPtr
<
nsInputStreamPump
>
pump
;
rv
=
nsInputStreamPump
:
:
Create
(
getter_AddRefs
(
pump
)
stream
-
1
-
1
0
0
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mListener
)
;
NS_ENSURE_TRUE
(
mListener
NS_ERROR_UNEXPECTED
)
;
rv
=
pump
-
>
AsyncRead
(
mListener
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mListener
=
nullptr
;
return
NS_OK
;
}
NS_IMETHOD
HandleCompletion
(
uint16_t
aReason
)
override
{
if
(
!
mListener
)
return
NS_OK
;
auto
cleanup
=
MakeScopeExit
(
[
&
]
(
)
{
mListener
=
nullptr
;
}
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
GetLoadInfo
(
)
;
nsCOMPtr
<
nsIChannel
>
newChannel
;
nsresult
rv
=
GetDefaultIcon
(
loadInfo
getter_AddRefs
(
newChannel
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mListener
-
>
OnStartRequest
(
mChannel
nullptr
)
;
mListener
-
>
OnStopRequest
(
mChannel
nullptr
rv
)
;
return
rv
;
}
mChannel
-
>
SetContentType
(
NS_LITERAL_CSTRING
(
"
image
/
png
"
)
)
;
return
newChannel
-
>
AsyncOpen2
(
mListener
)
;
}
protected
:
virtual
~
faviconAsyncLoader
(
)
{
}
private
:
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsCOMPtr
<
nsIStreamListener
>
mListener
;
}
;
}
NS_IMPL_ISUPPORTS
(
nsAnnoProtocolHandler
nsIProtocolHandler
)
NS_IMETHODIMP
nsAnnoProtocolHandler
:
:
GetScheme
(
nsACString
&
aScheme
)
{
aScheme
.
AssignLiteral
(
"
moz
-
anno
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsAnnoProtocolHandler
:
:
GetDefaultPort
(
int32_t
*
aDefaultPort
)
{
*
aDefaultPort
=
-
1
;
return
NS_OK
;
}
NS_IMETHODIMP
nsAnnoProtocolHandler
:
:
GetProtocolFlags
(
uint32_t
*
aProtocolFlags
)
{
*
aProtocolFlags
=
(
URI_NORELATIVE
|
URI_NOAUTH
|
URI_DANGEROUS_TO_LOAD
|
URI_IS_LOCAL_RESOURCE
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsAnnoProtocolHandler
:
:
NewURI
(
const
nsACString
&
aSpec
const
char
*
aOriginCharset
nsIURI
*
aBaseURI
nsIURI
*
*
_retval
)
{
nsCOMPtr
<
nsIURI
>
uri
=
do_CreateInstance
(
NS_SIMPLEURI_CONTRACTID
)
;
if
(
!
uri
)
return
NS_ERROR_OUT_OF_MEMORY
;
nsresult
rv
=
uri
-
>
SetSpec
(
aSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
_retval
=
nullptr
;
uri
.
swap
(
*
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsAnnoProtocolHandler
:
:
NewChannel2
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsCOMPtr
<
nsIURI
>
annoURI
;
nsAutoCString
annoName
;
nsresult
rv
=
ParseAnnoURI
(
aURI
getter_AddRefs
(
annoURI
)
annoName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
annoName
.
EqualsLiteral
(
FAVICON_ANNOTATION_NAME
)
)
return
NS_ERROR_INVALID_ARG
;
return
NewFaviconChannel
(
aURI
annoURI
aLoadInfo
_retval
)
;
}
NS_IMETHODIMP
nsAnnoProtocolHandler
:
:
NewChannel
(
nsIURI
*
aURI
nsIChannel
*
*
_retval
)
{
return
NewChannel2
(
aURI
nullptr
_retval
)
;
}
NS_IMETHODIMP
nsAnnoProtocolHandler
:
:
AllowPort
(
int32_t
port
const
char
*
scheme
bool
*
_retval
)
{
*
_retval
=
false
;
return
NS_OK
;
}
nsresult
nsAnnoProtocolHandler
:
:
ParseAnnoURI
(
nsIURI
*
aURI
nsIURI
*
*
aResultURI
nsCString
&
aName
)
{
nsresult
rv
;
nsAutoCString
path
;
rv
=
aURI
-
>
GetPath
(
path
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
firstColon
=
path
.
FindChar
(
'
:
'
)
;
if
(
firstColon
<
=
0
)
return
NS_ERROR_MALFORMED_URI
;
rv
=
NS_NewURI
(
aResultURI
Substring
(
path
firstColon
+
1
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aName
=
Substring
(
path
0
firstColon
)
;
return
NS_OK
;
}
nsresult
nsAnnoProtocolHandler
:
:
NewFaviconChannel
(
nsIURI
*
aURI
nsIURI
*
aAnnotationURI
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
_channel
)
{
nsCOMPtr
<
nsIChannel
>
channel
=
NS_NewSimpleChannel
(
aURI
aLoadInfo
aAnnotationURI
[
]
(
nsIStreamListener
*
listener
nsIChannel
*
channel
nsIURI
*
annotationURI
)
{
auto
fallback
=
[
&
]
(
)
-
>
RequestOrReason
{
nsCOMPtr
<
nsIChannel
>
chan
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
GetLoadInfo
(
)
;
nsresult
rv
=
GetDefaultIcon
(
loadInfo
getter_AddRefs
(
chan
)
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
rv
=
chan
-
>
AsyncOpen2
(
listener
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
return
RequestOrReason
(
chan
.
forget
(
)
)
;
}
;
nsCOMPtr
<
mozIStorageStatementCallback
>
callback
=
new
faviconAsyncLoader
(
channel
listener
)
;
nsFaviconService
*
faviconService
=
nsFaviconService
:
:
GetFaviconService
(
)
;
if
(
!
callback
|
|
!
faviconService
)
return
fallback
(
)
;
nsresult
rv
=
faviconService
-
>
GetFaviconDataAsync
(
annotationURI
callback
)
;
if
(
NS_FAILED
(
rv
)
)
return
fallback
(
)
;
return
RequestOrReason
(
nullptr
)
;
}
)
;
NS_ENSURE_TRUE
(
channel
NS_ERROR_OUT_OF_MEMORY
)
;
channel
.
forget
(
_channel
)
;
return
NS_OK
;
}
