"
use
strict
"
;
const
MS_PER_DAY
=
86400000
;
const
QUERYTYPE_FILTERED
=
0
;
const
QUERYTYPE_ADAPTIVE
=
3
;
const
FRECENCY_DEFAULT
=
1000
;
const
RECENT_REMOTE_TAB_THRESHOLD_MS
=
259200000
;
const
REGEXP_USER_CONTEXT_ID
=
/
(
?
:
^
|
)
user
-
context
-
id
:
(
\
d
+
)
/
;
const
REGEXP_MAX_RESULTS
=
/
(
?
:
^
|
)
max
-
results
:
(
\
d
+
)
/
;
const
REGEXP_SPACES
=
/
\
s
+
/
;
const
REGEXP_STRIP_PREFIX
=
/
^
[
a
-
z
]
+
:
(
?
:
\
/
)
{
0
2
}
/
i
;
const
NOTIFYRESULT_DELAY_MS
=
16
;
const
QUERYINDEX_QUERYTYPE
=
0
;
const
QUERYINDEX_URL
=
1
;
const
QUERYINDEX_TITLE
=
2
;
const
QUERYINDEX_BOOKMARKED
=
3
;
const
QUERYINDEX_BOOKMARKTITLE
=
4
;
const
QUERYINDEX_TAGS
=
5
;
const
QUERYINDEX_PLACEID
=
8
;
const
QUERYINDEX_SWITCHTAB
=
9
;
const
QUERYINDEX_FRECENCY
=
10
;
const
SQL_BOOKMARK_TAGS_FRAGMENT
=
EXISTS
(
SELECT
1
FROM
moz_bookmarks
WHERE
fk
=
h
.
id
)
AS
bookmarked
(
SELECT
title
FROM
moz_bookmarks
WHERE
fk
=
h
.
id
AND
title
NOTNULL
ORDER
BY
lastModified
DESC
LIMIT
1
)
AS
btitle
(
SELECT
GROUP_CONCAT
(
t
.
title
'
'
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
t
ON
t
.
id
=
+
b
.
parent
AND
t
.
parent
=
:
parent
WHERE
b
.
fk
=
h
.
id
)
AS
tags
;
function
defaultQuery
(
conditions
=
"
"
)
{
let
query
=
SELECT
:
query_type
h
.
url
h
.
title
{
SQL_BOOKMARK_TAGS_FRAGMENT
}
h
.
visit_count
h
.
typed
h
.
id
t
.
open_count
h
.
frecency
FROM
moz_places
h
LEFT
JOIN
moz_openpages_temp
t
ON
t
.
url
=
h
.
url
AND
t
.
userContextId
=
:
userContextId
WHERE
h
.
frecency
<
>
0
AND
CASE
WHEN
bookmarked
THEN
AUTOCOMPLETE_MATCH
(
:
searchString
h
.
url
IFNULL
(
btitle
h
.
title
)
tags
h
.
visit_count
h
.
typed
1
t
.
open_count
:
matchBehavior
:
searchBehavior
)
ELSE
AUTOCOMPLETE_MATCH
(
:
searchString
h
.
url
h
.
title
'
'
h
.
visit_count
h
.
typed
0
t
.
open_count
:
matchBehavior
:
searchBehavior
)
END
{
conditions
?
"
AND
"
:
"
"
}
{
conditions
}
ORDER
BY
h
.
frecency
DESC
h
.
id
DESC
LIMIT
:
maxResults
;
return
query
;
}
const
SQL_SWITCHTAB_QUERY
=
SELECT
:
query_type
t
.
url
t
.
url
NULL
NULL
NULL
NULL
NULL
NULL
t
.
open_count
NULL
FROM
moz_openpages_temp
t
LEFT
JOIN
moz_places
h
ON
h
.
url_hash
=
hash
(
t
.
url
)
AND
h
.
url
=
t
.
url
WHERE
h
.
id
IS
NULL
AND
t
.
userContextId
=
:
userContextId
AND
AUTOCOMPLETE_MATCH
(
:
searchString
t
.
url
t
.
url
NULL
NULL
NULL
NULL
t
.
open_count
:
matchBehavior
:
searchBehavior
)
ORDER
BY
t
.
ROWID
DESC
LIMIT
:
maxResults
;
const
SQL_ADAPTIVE_QUERY
=
/
*
do
not
warn
(
bug
487789
)
*
/
SELECT
:
query_type
h
.
url
h
.
title
{
SQL_BOOKMARK_TAGS_FRAGMENT
}
h
.
visit_count
h
.
typed
h
.
id
t
.
open_count
h
.
frecency
FROM
(
SELECT
ROUND
(
MAX
(
use_count
)
*
(
1
+
(
input
=
:
search_string
)
)
1
)
AS
rank
place_id
FROM
moz_inputhistory
WHERE
input
BETWEEN
:
search_string
AND
:
search_string
|
|
X
'
FFFF
'
GROUP
BY
place_id
)
AS
i
JOIN
moz_places
h
ON
h
.
id
=
i
.
place_id
LEFT
JOIN
moz_openpages_temp
t
ON
t
.
url
=
h
.
url
AND
t
.
userContextId
=
:
userContextId
WHERE
AUTOCOMPLETE_MATCH
(
NULL
h
.
url
IFNULL
(
btitle
h
.
title
)
tags
h
.
visit_count
h
.
typed
bookmarked
t
.
open_count
:
matchBehavior
:
searchBehavior
)
ORDER
BY
rank
DESC
h
.
frecency
DESC
LIMIT
:
maxResults
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AboutPagesUtils
:
"
resource
:
/
/
gre
/
modules
/
AboutPagesUtils
.
jsm
"
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
ObjectUtils
:
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
PlacesRemoteTabsAutocompleteProvider
:
"
resource
:
/
/
gre
/
modules
/
PlacesRemoteTabsAutocompleteProvider
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
ProfileAge
:
"
resource
:
/
/
gre
/
modules
/
ProfileAge
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
syncUsernamePref
"
"
services
.
sync
.
username
"
)
;
function
setTimeout
(
callback
ms
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
callback
ms
timer
.
TYPE_ONE_SHOT
)
;
return
timer
;
}
const
kProtocolsWithIcons
=
[
"
chrome
:
"
"
moz
-
extension
:
"
"
about
:
"
"
http
:
"
"
https
:
"
"
ftp
:
"
]
;
function
iconHelper
(
url
)
{
if
(
typeof
url
=
=
"
string
"
)
{
return
kProtocolsWithIcons
.
some
(
p
=
>
url
.
startsWith
(
p
)
)
?
"
page
-
icon
:
"
+
url
:
PlacesUtils
.
favicons
.
defaultFavicon
.
spec
;
}
if
(
url
&
&
url
instanceof
URL
&
&
kProtocolsWithIcons
.
includes
(
url
.
protocol
)
)
{
return
"
page
-
icon
:
"
+
url
.
href
;
}
return
PlacesUtils
.
favicons
.
defaultFavicon
.
spec
;
}
function
PreloadedSite
(
url
title
)
{
this
.
uri
=
Services
.
io
.
newURI
(
url
)
;
this
.
title
=
title
;
this
.
_matchTitle
=
title
.
toLowerCase
(
)
;
this
.
_hasWWW
=
this
.
uri
.
host
.
startsWith
(
"
www
.
"
)
;
this
.
_hostWithoutWWW
=
this
.
_hasWWW
?
this
.
uri
.
host
.
slice
(
4
)
:
this
.
uri
.
host
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
PreloadedSiteStorage
"
(
)
=
>
Object
.
seal
(
{
sites
:
[
]
add
(
url
title
)
{
let
site
=
new
PreloadedSite
(
url
title
)
;
this
.
sites
.
push
(
site
)
;
}
populate
(
sites
)
{
this
.
sites
=
[
]
;
for
(
let
site
of
sites
)
{
this
.
add
(
site
[
0
]
site
[
1
]
)
;
}
}
}
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ProfileAgeCreatedPromise
"
async
(
)
=
>
{
let
times
=
await
ProfileAge
(
)
;
return
times
.
created
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
typeToBehaviorMap
"
(
)
=
>
{
return
new
Map
(
[
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_HISTORY
"
history
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_BOOKMARK
"
bookmark
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_TAG
"
tag
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_OPENPAGE
"
openpage
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
"
search
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_TITLE
"
title
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_URL
"
url
"
]
]
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
sourceToBehaviorMap
"
(
)
=
>
{
return
new
Map
(
[
[
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
"
history
"
]
[
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
"
bookmark
"
]
[
UrlbarUtils
.
RESULT_SOURCE
.
TABS
"
openpage
"
]
[
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
"
search
"
]
]
)
;
}
)
;
function
stripAnyPrefix
(
str
)
{
let
match
=
REGEXP_STRIP_PREFIX
.
exec
(
str
)
;
if
(
!
match
)
{
return
[
"
"
str
]
;
}
let
prefix
=
match
[
0
]
;
if
(
prefix
.
length
<
str
.
length
&
&
str
[
prefix
.
length
]
=
=
"
"
)
{
return
[
"
"
str
]
;
}
return
[
prefix
str
.
substr
(
prefix
.
length
)
]
;
}
function
stripPrefixAndTrim
(
spec
options
=
{
}
)
{
let
prefix
=
"
"
;
let
suffix
=
"
"
;
if
(
options
.
stripHttp
&
&
spec
.
startsWith
(
"
http
:
/
/
"
)
)
{
spec
=
spec
.
slice
(
7
)
;
prefix
=
"
http
:
/
/
"
;
}
else
if
(
options
.
stripHttps
&
&
spec
.
startsWith
(
"
https
:
/
/
"
)
)
{
spec
=
spec
.
slice
(
8
)
;
prefix
=
"
https
:
/
/
"
;
}
if
(
options
.
stripWww
&
&
spec
.
startsWith
(
"
www
.
"
)
)
{
spec
=
spec
.
slice
(
4
)
;
prefix
+
=
"
www
.
"
;
}
if
(
options
.
trimEmptyHash
&
&
spec
.
endsWith
(
"
#
"
)
)
{
spec
=
spec
.
slice
(
0
-
1
)
;
suffix
=
"
#
"
+
suffix
;
}
if
(
options
.
trimEmptyQuery
&
&
spec
.
endsWith
(
"
?
"
)
)
{
spec
=
spec
.
slice
(
0
-
1
)
;
suffix
=
"
?
"
+
suffix
;
}
if
(
options
.
trimSlash
&
&
spec
.
endsWith
(
"
/
"
)
)
{
spec
=
spec
.
slice
(
0
-
1
)
;
suffix
=
"
/
"
+
suffix
;
}
return
[
spec
prefix
suffix
]
;
}
function
makeKeyForMatch
(
match
)
{
let
key
prefix
;
if
(
match
.
style
&
&
match
.
style
.
includes
(
"
autofill
"
)
)
{
[
key
prefix
]
=
stripPrefixAndTrim
(
match
.
finalCompleteValue
{
stripHttp
:
true
stripHttps
:
true
stripWww
:
true
trimEmptyQuery
:
true
trimSlash
:
true
}
)
;
return
[
key
prefix
null
]
;
}
let
action
=
PlacesUtils
.
parseActionUrl
(
match
.
value
)
;
if
(
!
action
)
{
[
key
prefix
]
=
stripPrefixAndTrim
(
match
.
value
{
stripHttp
:
true
stripHttps
:
true
stripWww
:
true
trimSlash
:
true
trimEmptyQuery
:
true
trimEmptyHash
:
true
}
)
;
return
[
key
prefix
null
]
;
}
switch
(
action
.
type
)
{
case
"
searchengine
"
:
key
=
[
action
.
type
action
.
params
.
engineName
(
action
.
params
.
searchSuggestion
|
|
action
.
params
.
searchQuery
)
.
toLocaleLowerCase
(
)
]
;
break
;
default
:
[
key
prefix
]
=
stripPrefixAndTrim
(
action
.
params
.
url
|
|
match
.
value
{
stripHttp
:
true
stripHttps
:
true
stripWww
:
true
trimEmptyQuery
:
true
trimSlash
:
true
}
)
;
break
;
}
return
[
key
prefix
action
]
;
}
function
makeActionUrl
(
type
params
)
{
let
encodedParams
=
{
}
;
for
(
let
key
in
params
)
{
if
(
params
[
key
]
=
=
=
null
|
|
params
[
key
]
=
=
=
undefined
)
{
continue
;
}
encodedParams
[
key
]
=
encodeURIComponent
(
params
[
key
]
)
;
}
return
moz
-
action
:
{
type
}
{
JSON
.
stringify
(
encodedParams
)
}
;
}
function
Search
(
searchString
searchParam
autocompleteListener
autocompleteSearch
queryContext
)
{
this
.
_originalSearchString
=
searchString
;
this
.
_trimmedOriginalSearchString
=
searchString
.
trim
(
)
;
let
unescapedSearchString
=
Services
.
textToSubURI
.
unEscapeURIForUI
(
this
.
_trimmedOriginalSearchString
)
;
let
[
prefix
suffix
]
=
stripAnyPrefix
(
unescapedSearchString
)
;
this
.
_searchString
=
suffix
;
this
.
_strippedPrefix
=
prefix
.
toLowerCase
(
)
;
this
.
_matchBehavior
=
Ci
.
mozIPlacesAutoComplete
.
MATCH_BOUNDARY
;
this
.
_behavior
=
this
.
_searchString
?
UrlbarPrefs
.
get
(
"
defaultBehavior
"
)
:
this
.
_emptySearchDefaultBehavior
;
if
(
queryContext
)
{
this
.
_enableActions
=
true
;
this
.
_inPrivateWindow
=
queryContext
.
isPrivate
;
this
.
_disablePrivateActions
=
this
.
_inPrivateWindow
&
&
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
;
this
.
_prohibitAutoFill
=
!
queryContext
.
allowAutofill
;
this
.
_maxResults
=
queryContext
.
maxResults
;
this
.
_userContextId
=
queryContext
.
userContextId
;
this
.
_currentPage
=
queryContext
.
currentPage
;
this
.
_searchModeEngine
=
queryContext
.
searchMode
?
.
engineName
;
this
.
_searchMode
=
queryContext
.
searchMode
;
if
(
this
.
_searchModeEngine
)
{
let
engine
=
Services
.
search
.
getEngineByName
(
this
.
_searchModeEngine
)
;
this
.
_filterOnHost
=
engine
.
getResultDomain
(
)
;
}
}
else
{
let
params
=
new
Set
(
searchParam
.
split
(
"
"
)
)
;
this
.
_enableActions
=
params
.
has
(
"
enable
-
actions
"
)
;
this
.
_disablePrivateActions
=
params
.
has
(
"
disable
-
private
-
actions
"
)
;
this
.
_inPrivateWindow
=
params
.
has
(
"
private
-
window
"
)
;
this
.
_prohibitAutoFill
=
params
.
has
(
"
prohibit
-
autofill
"
)
;
let
maxResults
=
searchParam
.
match
(
REGEXP_MAX_RESULTS
)
;
this
.
_maxResults
=
maxResults
?
parseInt
(
maxResults
[
1
]
)
:
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
userContextId
=
searchParam
.
match
(
REGEXP_USER_CONTEXT_ID
)
;
this
.
_userContextId
=
userContextId
?
parseInt
(
userContextId
[
1
]
10
)
:
Ci
.
nsIScriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
;
}
let
{
tokens
}
=
UrlbarTokenizer
.
tokenize
(
{
searchString
:
unescapedSearchString
trimmedSearchString
:
unescapedSearchString
.
trim
(
)
}
)
;
this
.
_leadingRestrictionToken
=
null
;
if
(
tokens
.
length
)
{
if
(
UrlbarTokenizer
.
isRestrictionToken
(
tokens
[
0
]
)
&
&
(
tokens
.
length
>
1
|
|
tokens
[
0
]
.
type
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
)
)
{
this
.
_leadingRestrictionToken
=
tokens
[
0
]
.
value
;
}
if
(
prefix
&
&
tokens
[
0
]
.
value
.
length
>
prefix
.
length
)
{
tokens
[
0
]
.
value
=
tokens
[
0
]
.
value
.
substring
(
prefix
.
length
)
;
}
}
this
.
_searchTokens
=
!
queryContext
|
|
queryContext
.
restrictToken
?
this
.
filterTokens
(
tokens
)
:
tokens
;
if
(
queryContext
&
&
queryContext
.
restrictSource
&
&
sourceToBehaviorMap
.
has
(
queryContext
.
restrictSource
)
)
{
this
.
_behavior
=
0
;
this
.
setBehavior
(
"
restrict
"
)
;
let
behavior
=
sourceToBehaviorMap
.
get
(
queryContext
.
restrictSource
)
;
this
.
setBehavior
(
behavior
)
;
this
.
_heuristicToken
=
null
;
}
else
{
let
firstToken
=
!
!
this
.
_searchTokens
.
length
&
&
this
.
_searchTokens
[
0
]
.
value
;
this
.
_heuristicToken
=
firstToken
&
&
this
.
_trimmedOriginalSearchString
.
startsWith
(
firstToken
)
?
firstToken
:
null
;
}
if
(
!
UrlbarPrefs
.
get
(
"
filter
.
javascript
"
)
)
{
this
.
setBehavior
(
"
javascript
"
)
;
}
this
.
_listener
=
autocompleteListener
;
this
.
_autocompleteSearch
=
autocompleteSearch
;
let
result
=
Cc
[
"
mozilla
.
org
/
autocomplete
/
simple
-
result
;
1
"
]
.
createInstance
(
Ci
.
nsIAutoCompleteSimpleResult
)
;
result
.
setSearchString
(
searchString
)
;
result
.
setDefaultIndex
(
-
1
)
;
this
.
_result
=
result
;
this
.
_adaptiveCount
=
0
;
this
.
_extraAdaptiveRows
=
[
]
;
this
.
_extraRemoteTabRows
=
[
]
;
this
.
_usedURLs
=
[
]
;
this
.
_usedPlaceIds
=
new
Set
(
)
;
this
.
_counts
=
Object
.
values
(
UrlbarUtils
.
RESULT_GROUP
)
.
reduce
(
(
o
p
)
=
>
{
o
[
p
]
=
0
;
return
o
;
}
{
}
)
;
}
Search
.
prototype
=
{
setBehavior
(
type
)
{
type
=
type
.
toUpperCase
(
)
;
this
.
_behavior
|
=
Ci
.
mozIPlacesAutoComplete
[
"
BEHAVIOR_
"
+
type
]
;
}
hasBehavior
(
type
)
{
let
behavior
=
Ci
.
mozIPlacesAutoComplete
[
"
BEHAVIOR_
"
+
type
.
toUpperCase
(
)
]
;
if
(
this
.
_disablePrivateActions
&
&
behavior
=
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_OPENPAGE
)
{
return
false
;
}
return
this
.
_behavior
&
behavior
;
}
_sleepResolve
:
null
_sleep
(
aTimeMs
)
{
if
(
!
this
.
_sleepTimer
)
{
this
.
_sleepTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
return
new
Promise
(
resolve
=
>
{
this
.
_sleepResolve
=
resolve
;
this
.
_sleepTimer
.
initWithCallback
(
resolve
aTimeMs
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
)
;
}
filterTokens
(
tokens
)
{
let
foundToken
=
false
;
let
filtered
=
[
]
;
for
(
let
token
of
tokens
)
{
if
(
!
UrlbarTokenizer
.
isRestrictionToken
(
token
)
)
{
filtered
.
push
(
token
)
;
continue
;
}
let
behavior
=
typeToBehaviorMap
.
get
(
token
.
type
)
;
if
(
!
behavior
)
{
throw
new
Error
(
Unknown
token
type
{
token
.
type
}
)
;
}
if
(
behavior
!
=
"
openpage
"
|
|
this
.
_enableActions
)
{
if
(
!
foundToken
)
{
foundToken
=
true
;
this
.
_behavior
=
0
;
this
.
setBehavior
(
"
restrict
"
)
;
}
this
.
setBehavior
(
behavior
)
;
if
(
behavior
=
=
"
tag
"
)
{
this
.
setBehavior
(
"
bookmark
"
)
;
}
}
}
return
filtered
;
}
stop
(
)
{
if
(
!
this
.
pending
)
{
return
;
}
if
(
this
.
_notifyTimer
)
{
this
.
_notifyTimer
.
cancel
(
)
;
}
this
.
_notifyDelaysCount
=
0
;
if
(
this
.
_sleepTimer
)
{
this
.
_sleepTimer
.
cancel
(
)
;
}
if
(
this
.
_sleepResolve
)
{
this
.
_sleepResolve
(
)
;
this
.
_sleepResolve
=
null
;
}
if
(
typeof
this
.
interrupt
=
=
"
function
"
)
{
this
.
interrupt
(
)
;
}
this
.
pending
=
false
;
}
pending
:
true
async
execute
(
conn
)
{
if
(
!
this
.
pending
)
{
return
;
}
this
.
interrupt
=
(
)
=
>
{
if
(
!
UrlbarProvidersManager
.
interruptLevel
)
{
conn
.
interrupt
(
)
;
}
}
;
await
this
.
_checkPreloadedSitesExpiry
(
)
;
let
tokenAliasEngines
=
await
UrlbarSearchUtils
.
tokenAliasEngines
(
)
;
if
(
this
.
_trimmedOriginalSearchString
=
=
"
"
&
&
tokenAliasEngines
.
length
)
{
this
.
_autocompleteSearch
.
finishSearch
(
true
)
;
return
;
}
this
.
_addingHeuristicResult
=
true
;
await
this
.
_matchFirstHeuristicResult
(
conn
)
;
this
.
_addingHeuristicResult
=
false
;
if
(
!
this
.
pending
)
{
return
;
}
if
(
this
.
_trimmedOriginalSearchString
)
{
await
this
.
_sleep
(
UrlbarPrefs
.
get
(
"
delay
"
)
)
;
if
(
!
this
.
pending
)
{
return
;
}
let
emptySearchRestriction
=
this
.
_trimmedOriginalSearchString
.
length
<
=
3
&
&
this
.
_leadingRestrictionToken
=
=
UrlbarTokenizer
.
RESTRICT
.
SEARCH
&
&
/
\
s
*
\
S
?
/
.
test
(
this
.
_trimmedOriginalSearchString
)
;
if
(
emptySearchRestriction
|
|
(
tokenAliasEngines
&
&
this
.
_trimmedOriginalSearchString
.
startsWith
(
"
"
)
)
|
|
(
this
.
hasBehavior
(
"
search
"
)
&
&
this
.
hasBehavior
(
"
restrict
"
)
)
)
{
this
.
_autocompleteSearch
.
finishSearch
(
true
)
;
return
;
}
}
await
conn
.
executeCached
(
this
.
_adaptiveQuery
[
0
]
this
.
_adaptiveQuery
[
1
]
this
.
_onResultRow
.
bind
(
this
)
)
;
if
(
!
this
.
pending
)
{
return
;
}
if
(
this
.
_enableActions
&
&
this
.
hasBehavior
(
"
openpage
"
)
)
{
await
this
.
_matchRemoteTabs
(
)
;
if
(
!
this
.
pending
)
{
return
;
}
}
let
queries
=
[
]
;
if
(
this
.
hasBehavior
(
"
openpage
"
)
)
{
queries
.
push
(
this
.
_switchToTabQuery
)
;
}
queries
.
push
(
this
.
_searchQuery
)
;
for
(
let
[
query
params
]
of
queries
)
{
await
conn
.
executeCached
(
query
params
this
.
_onResultRow
.
bind
(
this
)
)
;
if
(
!
this
.
pending
)
{
return
;
}
}
while
(
this
.
_extraAdaptiveRows
.
length
&
&
this
.
_result
.
matchCount
<
this
.
_maxResults
)
{
this
.
_addFilteredQueryMatch
(
this
.
_extraAdaptiveRows
.
shift
(
)
)
;
}
while
(
this
.
_extraRemoteTabRows
.
length
&
&
this
.
_result
.
matchCount
<
this
.
_maxResults
)
{
this
.
_addMatch
(
this
.
_extraRemoteTabRows
.
shift
(
)
)
;
}
this
.
_matchAboutPages
(
)
;
let
count
=
this
.
_counts
[
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
]
+
this
.
_counts
[
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
]
;
if
(
count
<
this
.
_maxResults
)
{
this
.
_matchBehavior
=
Ci
.
mozIPlacesAutoComplete
.
MATCH_ANYWHERE
;
let
queries
=
[
this
.
_adaptiveQuery
this
.
_searchQuery
]
;
if
(
this
.
hasBehavior
(
"
openpage
"
)
)
{
queries
.
unshift
(
this
.
_switchToTabQuery
)
;
}
for
(
let
[
query
params
]
of
queries
)
{
await
conn
.
executeCached
(
query
params
this
.
_onResultRow
.
bind
(
this
)
)
;
if
(
!
this
.
pending
)
{
return
;
}
}
}
this
.
_matchPreloadedSites
(
)
;
}
_shouldMatchAboutPages
(
)
{
return
this
.
_strippedPrefix
=
=
"
about
:
"
&
&
this
.
_searchString
;
}
_matchAboutPages
(
)
{
if
(
!
this
.
_shouldMatchAboutPages
(
)
)
{
return
;
}
for
(
const
url
of
AboutPagesUtils
.
visibleAboutUrls
)
{
if
(
url
.
startsWith
(
about
:
{
this
.
_searchString
}
)
)
{
this
.
_addMatch
(
{
value
:
url
comment
:
url
frecency
:
FRECENCY_DEFAULT
}
)
;
}
}
}
async
_checkPreloadedSitesExpiry
(
)
{
if
(
!
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
{
return
;
}
let
profileCreationDate
=
await
ProfileAgeCreatedPromise
;
let
daysSinceProfileCreation
=
(
Date
.
now
(
)
-
profileCreationDate
)
/
MS_PER_DAY
;
if
(
daysSinceProfileCreation
>
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
expire_days
"
)
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
usepreloadedtopurls
.
enabled
"
false
)
;
}
}
_matchPreloadedSites
(
)
{
if
(
!
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
{
return
;
}
if
(
!
this
.
_searchString
)
{
return
;
}
for
(
let
site
of
PreloadedSiteStorage
.
sites
)
{
let
url
=
site
.
uri
.
spec
;
if
(
(
!
this
.
_strippedPrefix
|
|
url
.
startsWith
(
this
.
_strippedPrefix
)
)
&
&
(
site
.
uri
.
host
.
includes
(
this
.
_searchString
)
|
|
site
.
_matchTitle
.
includes
(
this
.
_searchString
)
)
)
{
this
.
_addMatch
(
{
value
:
url
comment
:
site
.
title
style
:
"
preloaded
-
top
-
site
"
frecency
:
FRECENCY_DEFAULT
-
1
}
)
;
}
}
}
_matchPreloadedSiteForAutofill
(
)
{
if
(
!
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
{
return
false
;
}
let
matchedSite
=
PreloadedSiteStorage
.
sites
.
find
(
site
=
>
{
return
(
(
!
this
.
_strippedPrefix
|
|
site
.
uri
.
spec
.
startsWith
(
this
.
_strippedPrefix
)
)
&
&
(
site
.
uri
.
host
.
startsWith
(
this
.
_searchString
)
|
|
site
.
uri
.
host
.
startsWith
(
"
www
.
"
+
this
.
_searchString
)
)
)
;
}
)
;
if
(
!
matchedSite
)
{
return
false
;
}
this
.
_result
.
setDefaultIndex
(
0
)
;
let
url
=
matchedSite
.
uri
.
spec
;
let
value
=
stripAnyPrefix
(
url
)
[
1
]
;
value
=
value
.
substr
(
value
.
indexOf
(
this
.
_searchString
)
)
;
this
.
_addAutofillMatch
(
value
url
Infinity
[
"
preloaded
-
top
-
site
"
]
)
;
return
true
;
}
async
_matchFirstHeuristicResult
(
conn
)
{
if
(
this
.
_searchMode
)
{
return
false
;
}
if
(
this
.
pending
&
&
this
.
_enableActions
&
&
this
.
_heuristicToken
)
{
let
matched
=
await
this
.
_matchSearchEngineAlias
(
this
.
_heuristicToken
)
;
if
(
matched
)
{
return
true
;
}
}
if
(
this
.
pending
&
&
this
.
_heuristicToken
)
{
let
matched
=
await
this
.
_matchPlacesKeyword
(
this
.
_heuristicToken
)
;
if
(
matched
)
{
return
true
;
}
}
let
shouldAutofill
=
this
.
_shouldAutofill
;
if
(
this
.
pending
&
&
shouldAutofill
)
{
let
matched
=
this
.
_matchPreloadedSiteForAutofill
(
)
;
if
(
matched
)
{
return
true
;
}
}
return
false
;
}
async
_matchPlacesKeyword
(
keyword
)
{
let
entry
=
await
PlacesUtils
.
keywords
.
fetch
(
keyword
)
;
if
(
!
entry
)
{
return
false
;
}
let
searchString
=
UrlbarUtils
.
substringAfter
(
this
.
_originalSearchString
keyword
)
.
trim
(
)
;
let
url
=
null
;
let
postData
=
null
;
try
{
[
url
postData
]
=
await
BrowserUtils
.
parseUrlAndPostData
(
entry
.
url
.
href
entry
.
postData
searchString
)
;
}
catch
(
ex
)
{
return
false
;
}
let
style
=
"
keyword
"
;
let
value
=
url
;
if
(
this
.
_enableActions
)
{
style
=
"
action
"
+
style
;
value
=
makeActionUrl
(
"
keyword
"
{
url
keyword
input
:
this
.
_originalSearchString
postData
}
)
;
}
let
match
=
{
value
icon
:
iconHelper
(
entry
.
url
)
style
frecency
:
Infinity
}
;
if
(
this
.
_searchTokens
.
length
>
1
)
{
match
.
comment
=
entry
.
url
.
host
;
}
this
.
_firstTokenIsKeyword
=
true
;
this
.
_filterOnHost
=
entry
.
url
.
host
;
this
.
_addMatch
(
match
)
;
return
true
;
}
async
_matchSearchEngineAlias
(
alias
)
{
let
engine
=
await
UrlbarSearchUtils
.
engineForAlias
(
alias
)
;
if
(
!
engine
)
{
return
false
;
}
let
query
=
UrlbarUtils
.
substringAfter
(
this
.
_originalSearchString
alias
)
;
if
(
UrlbarPrefs
.
get
(
"
update2
"
)
&
&
!
UrlbarTokenizer
.
REGEXP_SPACES_START
.
test
(
query
)
)
{
return
false
;
}
this
.
_searchEngineAliasMatch
=
{
engine
alias
query
:
query
.
trimStart
(
)
}
;
this
.
_firstTokenIsKeyword
=
true
;
this
.
_filterOnHost
=
engine
.
getResultDomain
(
)
;
this
.
_addSearchEngineMatch
(
this
.
_searchEngineAliasMatch
)
;
return
true
;
}
_addSearchEngineMatch
(
{
engine
query
=
"
"
alias
=
undefined
historical
=
false
}
)
{
let
actionURLParams
=
{
engineName
:
engine
.
name
searchQuery
:
query
}
;
if
(
alias
&
&
!
query
)
{
actionURLParams
.
input
=
{
alias
}
;
}
else
{
actionURLParams
.
input
=
this
.
_originalSearchString
;
}
let
match
=
{
comment
:
engine
.
name
icon
:
engine
.
iconURI
?
engine
.
iconURI
.
spec
:
null
style
:
"
action
searchengine
"
frecency
:
FRECENCY_DEFAULT
}
;
if
(
alias
)
{
actionURLParams
.
alias
=
alias
;
match
.
style
+
=
"
alias
"
;
}
match
.
value
=
makeActionUrl
(
"
searchengine
"
actionURLParams
)
;
this
.
_addMatch
(
match
)
;
}
async
_matchRemoteTabs
(
)
{
if
(
!
syncUsernamePref
)
{
return
;
}
let
searchString
=
this
.
_searchTokens
.
map
(
t
=
>
t
.
value
)
.
join
(
"
"
)
;
let
matches
=
await
PlacesRemoteTabsAutocompleteProvider
.
getMatches
(
searchString
this
.
_maxResults
)
;
let
remoteTabsAdded
=
0
;
for
(
let
{
url
title
icon
deviceName
lastUsed
}
of
matches
)
{
if
(
!
icon
)
{
icon
=
iconHelper
(
url
)
;
}
else
{
icon
=
PlacesUtils
.
favicons
.
getFaviconLinkForIcon
(
Services
.
io
.
newURI
(
icon
)
)
.
spec
;
}
let
match
=
{
value
:
makeActionUrl
(
"
remotetab
"
{
url
deviceName
}
)
comment
:
title
|
|
url
style
:
"
action
remotetab
"
frecency
:
FRECENCY_DEFAULT
+
1
icon
}
;
if
(
remoteTabsAdded
<
this
.
_maxResults
/
2
&
&
lastUsed
>
Date
.
now
(
)
-
RECENT_REMOTE_TAB_THRESHOLD_MS
)
{
this
.
_addMatch
(
match
)
;
remoteTabsAdded
+
+
;
}
else
{
this
.
_extraRemoteTabRows
.
push
(
match
)
;
}
}
}
_onResultRow
(
row
cancel
)
{
let
queryType
=
row
.
getResultByIndex
(
QUERYINDEX_QUERYTYPE
)
;
switch
(
queryType
)
{
case
QUERYTYPE_ADAPTIVE
:
this
.
_addAdaptiveQueryMatch
(
row
)
;
break
;
case
QUERYTYPE_FILTERED
:
this
.
_addFilteredQueryMatch
(
row
)
;
break
;
}
let
count
=
this
.
_counts
[
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
]
+
this
.
_counts
[
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
]
;
if
(
!
this
.
pending
|
|
count
>
=
this
.
_maxResults
)
{
cancel
(
)
;
}
}
_maybeRestyleSearchMatch
(
match
)
{
let
historyUrl
=
match
.
value
;
let
parseResult
=
Services
.
search
.
parseSubmissionURL
(
historyUrl
)
;
if
(
!
parseResult
?
.
engine
)
{
return
false
;
}
let
terms
=
parseResult
.
terms
.
toLowerCase
(
)
;
if
(
this
.
_searchTokens
.
length
&
&
this
.
_searchTokens
.
every
(
token
=
>
!
terms
.
includes
(
token
.
value
)
)
)
{
return
false
;
}
let
[
generatedSuggestionUrl
]
=
UrlbarUtils
.
getSearchQueryUrl
(
parseResult
.
engine
this
.
_searchTokens
.
map
(
t
=
>
t
.
value
)
.
join
(
"
"
)
)
;
if
(
!
UrlbarSearchUtils
.
serpsAreEquivalent
(
historyUrl
generatedSuggestionUrl
[
parseResult
.
termsParameterName
]
)
)
{
return
false
;
}
match
.
value
=
makeActionUrl
(
"
searchengine
"
{
engineName
:
parseResult
.
engine
.
name
input
:
parseResult
.
terms
searchSuggestion
:
parseResult
.
terms
searchQuery
:
parseResult
.
terms
isSearchHistory
:
true
}
)
;
match
.
comment
=
parseResult
.
engine
.
name
;
match
.
icon
=
match
.
icon
|
|
match
.
iconUrl
;
match
.
style
=
"
action
searchengine
favicon
suggestion
"
;
return
true
;
}
_addMatch
(
match
)
{
if
(
typeof
match
.
frecency
!
=
"
number
"
)
{
throw
new
Error
(
"
Frecency
not
provided
"
)
;
}
if
(
this
.
_addingHeuristicResult
)
{
match
.
type
=
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
;
}
else
if
(
typeof
match
.
type
!
=
"
string
"
)
{
match
.
type
=
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
;
}
if
(
!
this
.
pending
)
{
return
;
}
match
.
style
=
match
.
style
|
|
"
favicon
"
;
if
(
match
.
style
=
=
"
favicon
"
&
&
(
UrlbarPrefs
.
get
(
"
restyleSearches
"
)
|
|
this
.
_searchModeEngine
)
)
{
let
restyled
=
this
.
_maybeRestyleSearchMatch
(
match
)
;
if
(
restyled
&
&
UrlbarPrefs
.
get
(
"
maxHistoricalSearchSuggestions
"
)
=
=
0
)
{
return
;
}
}
if
(
this
.
_addingHeuristicResult
)
{
match
.
style
+
=
"
heuristic
"
;
}
match
.
icon
=
match
.
icon
|
|
"
"
;
match
.
finalCompleteValue
=
match
.
finalCompleteValue
|
|
"
"
;
let
{
index
replace
}
=
this
.
_getInsertIndexForMatch
(
match
)
;
if
(
index
=
=
-
1
)
{
return
;
}
if
(
replace
)
{
this
.
_result
.
removeMatchAt
(
index
)
;
}
this
.
_result
.
insertMatchAt
(
index
match
.
value
match
.
comment
match
.
icon
match
.
style
match
.
finalCompleteValue
)
;
this
.
_counts
[
match
.
type
]
+
+
;
this
.
notifyResult
(
true
match
.
type
=
=
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
)
;
}
_getInsertIndexForMatch
(
match
)
{
let
[
urlMapKey
prefix
action
]
=
makeKeyForMatch
(
match
)
;
if
(
(
match
.
placeId
&
&
this
.
_usedPlaceIds
.
has
(
match
.
placeId
)
)
|
|
this
.
_usedURLs
.
some
(
e
=
>
ObjectUtils
.
deepEqual
(
e
.
key
urlMapKey
)
)
)
{
let
isDupe
=
true
;
if
(
action
&
&
[
"
switchtab
"
"
remotetab
"
]
.
includes
(
action
.
type
)
)
{
for
(
let
i
=
0
;
i
<
this
.
_usedURLs
.
length
;
+
+
i
)
{
let
{
key
:
matchKey
action
:
matchAction
type
:
matchType
}
=
this
.
_usedURLs
[
i
]
;
if
(
ObjectUtils
.
deepEqual
(
matchKey
urlMapKey
)
)
{
isDupe
=
true
;
if
(
matchType
=
=
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
&
&
action
.
type
=
=
"
switchtab
"
)
{
isDupe
=
false
;
continue
;
}
if
(
!
matchAction
|
|
action
.
type
=
=
"
switchtab
"
)
{
this
.
_usedURLs
[
i
]
=
{
key
:
urlMapKey
action
type
:
match
.
type
prefix
comment
:
match
.
comment
}
;
return
{
index
:
i
replace
:
true
}
;
}
break
;
}
}
}
else
{
let
prefixRank
=
UrlbarUtils
.
getPrefixRank
(
prefix
)
;
for
(
let
i
=
0
;
i
<
this
.
_usedURLs
.
length
;
+
+
i
)
{
if
(
!
this
.
_usedURLs
[
i
]
)
{
continue
;
}
let
{
key
:
existingKey
prefix
:
existingPrefix
type
:
existingType
}
=
this
.
_usedURLs
[
i
]
;
let
existingPrefixRank
=
UrlbarUtils
.
getPrefixRank
(
existingPrefix
)
;
if
(
ObjectUtils
.
deepEqual
(
existingKey
urlMapKey
)
)
{
isDupe
=
true
;
if
(
prefix
=
=
existingPrefix
)
{
if
(
match
.
type
!
=
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
)
{
break
;
}
else
{
this
.
_usedURLs
[
i
]
=
{
key
:
urlMapKey
action
type
:
match
.
type
prefix
comment
:
match
.
comment
}
;
return
{
index
:
i
replace
:
true
}
;
}
}
if
(
prefix
.
endsWith
(
"
www
.
"
)
=
=
existingPrefix
.
endsWith
(
"
www
.
"
)
)
{
if
(
match
.
type
=
=
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
)
{
isDupe
=
false
;
continue
;
}
if
(
prefixRank
<
=
existingPrefixRank
)
{
break
;
}
else
if
(
existingType
!
=
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
)
{
this
.
_usedURLs
[
i
]
=
{
key
:
urlMapKey
action
type
:
match
.
type
prefix
comment
:
match
.
comment
}
;
return
{
index
:
i
replace
:
true
}
;
}
else
{
isDupe
=
false
;
continue
;
}
}
else
{
isDupe
=
false
;
continue
;
}
}
}
}
if
(
isDupe
)
{
return
{
index
:
-
1
replace
:
false
}
;
}
}
if
(
match
.
placeId
)
{
this
.
_usedPlaceIds
.
add
(
match
.
placeId
)
;
}
let
index
=
0
;
if
(
!
this
.
_buckets
)
{
let
buckets
=
match
.
type
=
=
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
&
&
match
.
style
.
includes
(
"
searchengine
"
)
?
UrlbarPrefs
.
get
(
"
matchBucketsSearch
"
)
:
UrlbarPrefs
.
get
(
"
matchBuckets
"
)
;
this
.
_buckets
=
buckets
.
map
(
(
[
type
available
]
)
=
>
(
{
type
available
insertIndex
:
0
count
:
0
}
)
)
;
}
let
replace
=
0
;
for
(
let
bucket
of
this
.
_buckets
)
{
if
(
match
.
type
!
=
bucket
.
type
|
|
!
bucket
.
available
)
{
index
+
=
bucket
.
count
;
continue
;
}
index
+
=
bucket
.
insertIndex
;
bucket
.
available
-
-
;
if
(
bucket
.
insertIndex
<
bucket
.
count
)
{
replace
=
true
;
}
else
{
bucket
.
count
+
+
;
}
bucket
.
insertIndex
+
+
;
break
;
}
this
.
_usedURLs
[
index
]
=
{
key
:
urlMapKey
action
type
:
match
.
type
prefix
comment
:
match
.
comment
|
|
"
"
}
;
return
{
index
replace
}
;
}
_addAutofillMatch
(
autofilledValue
finalCompleteValue
frecency
=
Infinity
extraStyles
=
[
]
)
{
let
[
comment
]
=
stripPrefixAndTrim
(
finalCompleteValue
{
stripHttp
:
true
trimEmptyQuery
:
true
trimSlash
:
!
this
.
_searchString
.
includes
(
"
/
"
)
}
)
;
this
.
_addMatch
(
{
value
:
this
.
_strippedPrefix
+
autofilledValue
finalCompleteValue
comment
frecency
style
:
[
"
autofill
"
]
.
concat
(
extraStyles
)
.
join
(
"
"
)
icon
:
iconHelper
(
finalCompleteValue
)
}
)
;
}
_addAdaptiveQueryMatch
(
row
)
{
if
(
this
.
_searchModeEngine
)
{
return
;
}
if
(
this
.
_adaptiveCount
<
Math
.
ceil
(
this
.
_maxResults
/
4
)
)
{
this
.
_addFilteredQueryMatch
(
row
)
;
}
else
{
this
.
_extraAdaptiveRows
.
push
(
row
)
;
}
this
.
_adaptiveCount
+
+
;
}
_addFilteredQueryMatch
(
row
)
{
let
placeId
=
row
.
getResultByIndex
(
QUERYINDEX_PLACEID
)
;
let
url
=
row
.
getResultByIndex
(
QUERYINDEX_URL
)
;
let
openPageCount
=
row
.
getResultByIndex
(
QUERYINDEX_SWITCHTAB
)
|
|
0
;
let
historyTitle
=
row
.
getResultByIndex
(
QUERYINDEX_TITLE
)
|
|
"
"
;
let
bookmarked
=
row
.
getResultByIndex
(
QUERYINDEX_BOOKMARKED
)
;
let
bookmarkTitle
=
bookmarked
?
row
.
getResultByIndex
(
QUERYINDEX_BOOKMARKTITLE
)
:
null
;
let
tags
=
row
.
getResultByIndex
(
QUERYINDEX_TAGS
)
|
|
"
"
;
let
frecency
=
row
.
getResultByIndex
(
QUERYINDEX_FRECENCY
)
;
let
match
=
{
placeId
value
:
url
comment
:
bookmarkTitle
|
|
historyTitle
icon
:
iconHelper
(
url
)
frecency
:
frecency
|
|
FRECENCY_DEFAULT
}
;
if
(
this
.
_enableActions
&
&
openPageCount
>
0
&
&
this
.
hasBehavior
(
"
openpage
"
)
)
{
if
(
this
.
_currentPage
=
=
match
.
value
)
{
return
;
}
match
.
value
=
makeActionUrl
(
"
switchtab
"
{
url
:
match
.
value
}
)
;
match
.
style
=
"
action
switchtab
"
;
}
else
if
(
this
.
hasBehavior
(
"
history
"
)
&
&
!
this
.
hasBehavior
(
"
bookmark
"
)
&
&
!
tags
)
{
match
.
style
=
"
favicon
"
;
}
else
if
(
tags
)
{
match
.
comment
+
=
UrlbarUtils
.
TITLE_TAGS_SEPARATOR
+
tags
;
match
.
style
=
this
.
hasBehavior
(
"
bookmark
"
)
?
"
bookmark
-
tag
"
:
"
tag
"
;
}
else
if
(
bookmarked
)
{
match
.
style
=
"
bookmark
"
;
}
this
.
_addMatch
(
match
)
;
}
get
_suggestionPrefQuery
(
)
{
let
conditions
=
[
]
;
if
(
this
.
_filterOnHost
)
{
conditions
.
push
(
"
h
.
rev_host
=
get_unreversed_host
(
:
host
|
|
'
.
'
)
|
|
'
.
'
"
)
;
if
(
UrlbarPrefs
.
get
(
"
restyleSearches
"
)
|
|
this
.
_searchModeEngine
)
{
conditions
.
push
(
NOT
EXISTS
(
WITH
visits
(
type
)
AS
(
SELECT
visit_type
FROM
moz_historyvisits
WHERE
place_id
=
h
.
id
ORDER
BY
visit_date
DESC
LIMIT
10
/
*
limit
to
the
last
10
visits
*
/
)
SELECT
1
FROM
visits
WHERE
type
IN
(
5
6
)
)
)
;
}
else
{
conditions
.
push
(
NOT
EXISTS
(
WITH
visits
(
id
)
AS
(
SELECT
id
FROM
moz_historyvisits
WHERE
place_id
=
h
.
id
ORDER
BY
visit_date
DESC
LIMIT
10
/
*
limit
to
the
last
10
visits
*
/
)
SELECT
1
FROM
visits
src
JOIN
moz_historyvisits
dest
ON
src
.
id
=
dest
.
from_visit
WHERE
dest
.
visit_type
IN
(
5
6
)
)
)
;
conditions
.
push
(
"
(
h
.
foreign_count
>
0
OR
h
.
title
NOTNULL
)
"
)
;
}
}
if
(
this
.
hasBehavior
(
"
restrict
"
)
|
|
!
this
.
hasBehavior
(
"
history
"
)
|
|
!
this
.
hasBehavior
(
"
bookmark
"
)
)
{
if
(
this
.
hasBehavior
(
"
history
"
)
)
{
conditions
.
push
(
"
+
h
.
visit_count
>
0
"
)
;
}
if
(
this
.
hasBehavior
(
"
bookmark
"
)
)
{
conditions
.
push
(
"
bookmarked
"
)
;
}
if
(
this
.
hasBehavior
(
"
tag
"
)
)
{
conditions
.
push
(
"
tags
NOTNULL
"
)
;
}
}
return
defaultQuery
(
conditions
.
join
(
"
AND
"
)
)
;
}
get
_emptySearchDefaultBehavior
(
)
{
let
val
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_RESTRICT
;
if
(
UrlbarPrefs
.
get
(
"
suggest
.
history
"
)
)
{
val
|
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_HISTORY
;
}
else
if
(
UrlbarPrefs
.
get
(
"
suggest
.
bookmark
"
)
)
{
val
|
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_BOOKMARK
;
}
else
{
val
|
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_OPENPAGE
;
}
return
val
;
}
get
_keywordFilteredSearchString
(
)
{
let
tokens
=
this
.
_searchTokens
.
map
(
t
=
>
t
.
value
)
;
if
(
this
.
_firstTokenIsKeyword
)
{
tokens
=
tokens
.
slice
(
1
)
;
}
return
tokens
.
join
(
"
"
)
;
}
get
_searchQuery
(
)
{
let
params
=
{
parent
:
PlacesUtils
.
tagsFolderId
query_type
:
QUERYTYPE_FILTERED
matchBehavior
:
this
.
_matchBehavior
searchBehavior
:
this
.
_behavior
searchString
:
this
.
_keywordFilteredSearchString
userContextId
:
this
.
_userContextId
maxResults
:
this
.
_maxResults
}
;
if
(
this
.
_filterOnHost
)
{
params
.
host
=
this
.
_filterOnHost
;
}
return
[
this
.
_suggestionPrefQuery
params
]
;
}
get
_switchToTabQuery
(
)
{
return
[
SQL_SWITCHTAB_QUERY
{
query_type
:
QUERYTYPE_FILTERED
matchBehavior
:
this
.
_matchBehavior
searchBehavior
:
this
.
_behavior
searchString
:
this
.
_keywordFilteredSearchString
userContextId
:
this
.
_userContextId
maxResults
:
this
.
_maxResults
}
]
;
}
get
_adaptiveQuery
(
)
{
return
[
SQL_ADAPTIVE_QUERY
{
parent
:
PlacesUtils
.
tagsFolderId
search_string
:
this
.
_searchString
query_type
:
QUERYTYPE_ADAPTIVE
matchBehavior
:
this
.
_matchBehavior
searchBehavior
:
this
.
_behavior
userContextId
:
this
.
_userContextId
maxResults
:
this
.
_maxResults
}
]
;
}
get
_shouldAutofill
(
)
{
if
(
!
UrlbarPrefs
.
get
(
"
autoFill
"
)
)
{
return
false
;
}
if
(
this
.
_searchTokens
.
length
!
=
1
)
{
return
false
;
}
if
(
!
this
.
hasBehavior
(
"
history
"
)
&
&
!
this
.
hasBehavior
(
"
bookmark
"
)
)
{
return
false
;
}
if
(
this
.
hasBehavior
(
"
title
"
)
|
|
this
.
hasBehavior
(
"
tag
"
)
)
{
return
false
;
}
if
(
REGEXP_SPACES
.
test
(
this
.
_originalSearchString
)
)
{
return
false
;
}
if
(
!
this
.
_searchString
.
length
)
{
return
false
;
}
if
(
this
.
_prohibitAutoFill
)
{
return
false
;
}
return
true
;
}
_notifyTimer
:
null
_notifyDelaysCount
:
0
notifyResult
(
searchOngoing
skipDelay
=
false
)
{
let
notify
=
(
)
=
>
{
if
(
!
this
.
pending
)
{
return
;
}
this
.
_notifyDelaysCount
=
0
;
let
resultCode
=
this
.
_result
.
matchCount
?
"
RESULT_SUCCESS
"
:
"
RESULT_NOMATCH
"
;
if
(
searchOngoing
)
{
resultCode
+
=
"
_ONGOING
"
;
}
let
result
=
this
.
_result
;
result
.
setSearchResult
(
Ci
.
nsIAutoCompleteResult
[
resultCode
]
)
;
this
.
_listener
.
onSearchResult
(
this
.
_autocompleteSearch
result
)
;
if
(
!
searchOngoing
)
{
this
.
_listener
=
null
;
this
.
_autocompleteSearch
=
null
;
this
.
stop
(
)
;
}
}
;
if
(
this
.
_notifyTimer
)
{
this
.
_notifyTimer
.
cancel
(
)
;
}
if
(
skipDelay
|
|
this
.
_notifyDelaysCount
>
3
)
{
notify
(
)
;
}
else
{
this
.
_notifyDelaysCount
+
+
;
this
.
_notifyTimer
=
setTimeout
(
notify
NOTIFYRESULT_DELAY_MS
)
;
}
}
}
;
function
UnifiedComplete
(
)
{
if
(
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
{
ProfileAgeCreatedPromise
;
fetch
(
"
chrome
:
/
/
global
/
content
/
unifiedcomplete
-
top
-
urls
.
json
"
)
.
then
(
response
=
>
response
.
json
(
)
)
.
then
(
sites
=
>
PreloadedSiteStorage
.
populate
(
sites
)
)
.
catch
(
ex
=
>
Cu
.
reportError
(
ex
)
)
;
}
}
UnifiedComplete
.
prototype
=
{
_promiseDatabase
:
null
getDatabaseHandle
(
)
{
if
(
!
this
.
_promiseDatabase
)
{
this
.
_promiseDatabase
=
(
async
(
)
=
>
{
let
conn
=
await
PlacesUtils
.
promiseLargeCacheDBConnection
(
)
;
Sqlite
.
shutdown
.
addBlocker
(
"
Places
UnifiedComplete
.
js
closing
"
(
)
=
>
{
this
.
_currentSearch
=
null
;
}
)
;
return
conn
;
}
)
(
)
.
catch
(
ex
=
>
{
dump
(
"
Couldn
'
t
get
database
handle
:
"
+
ex
+
"
\
n
"
)
;
Cu
.
reportError
(
ex
)
;
}
)
;
}
return
this
.
_promiseDatabase
;
}
populatePreloadedSiteStorage
(
json
)
{
PreloadedSiteStorage
.
populate
(
json
)
;
}
startQuery
(
queryContext
onAutocompleteResult
)
{
let
deferred
=
PromiseUtils
.
defer
(
)
;
let
listener
=
{
onSearchResult
(
_
result
)
{
let
done
=
[
Ci
.
nsIAutoCompleteResult
.
RESULT_IGNORED
Ci
.
nsIAutoCompleteResult
.
RESULT_FAILURE
Ci
.
nsIAutoCompleteResult
.
RESULT_NOMATCH
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
]
.
includes
(
result
.
searchResult
)
|
|
result
.
errorDescription
;
onAutocompleteResult
(
result
)
;
if
(
done
)
{
deferred
.
resolve
(
)
;
}
}
}
;
this
.
startSearch
(
queryContext
.
searchString
"
"
null
listener
queryContext
)
;
this
.
_deferred
=
deferred
;
return
this
.
_deferred
.
promise
;
}
startSearch
(
searchString
searchParam
acPreviousResult
listener
queryContext
)
{
if
(
this
.
_currentSearch
)
{
this
.
stopSearch
(
)
;
}
let
search
=
(
this
.
_currentSearch
=
new
Search
(
searchString
searchParam
listener
this
queryContext
)
)
;
this
.
getDatabaseHandle
(
)
.
then
(
conn
=
>
search
.
execute
(
conn
)
)
.
catch
(
ex
=
>
{
dump
(
Query
failed
:
{
ex
}
\
n
)
;
Cu
.
reportError
(
ex
)
;
}
)
.
then
(
(
)
=
>
{
if
(
search
=
=
this
.
_currentSearch
)
{
this
.
finishSearch
(
true
)
;
}
}
)
;
}
stopSearch
(
)
{
if
(
this
.
_currentSearch
)
{
this
.
_currentSearch
.
stop
(
)
;
}
if
(
this
.
_deferred
)
{
this
.
_deferred
.
resolve
(
)
;
}
this
.
finishSearch
(
)
;
}
finishSearch
(
notify
=
false
)
{
let
search
=
this
.
_currentSearch
;
if
(
!
search
)
{
return
;
}
this
.
_lastLowResultsSearchSuggestion
=
search
.
_lastLowResultsSearchSuggestion
;
if
(
!
notify
|
|
!
search
.
pending
)
{
return
;
}
search
.
notifyResult
(
false
)
;
}
get
searchType
(
)
{
return
Ci
.
nsIAutoCompleteSearchDescriptor
.
SEARCH_TYPE_IMMEDIATE
;
}
get
clearingAutoFillSearchesAgain
(
)
{
return
true
;
}
classID
:
Components
.
ID
(
"
f964a319
-
397a
-
4d21
-
8be6
-
5cdd1ee3e3ae
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIAutoCompleteSearch
"
"
nsIAutoCompleteSearchDescriptor
"
"
mozIPlacesAutoComplete
"
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
}
;
var
EXPORTED_SYMBOLS
=
[
"
UnifiedComplete
"
]
;
